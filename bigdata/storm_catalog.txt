>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>接口自动化测试持续集成
Chapter 1 接口测试基础知识
1.1　接口测试背景　2
1.2　接口基础知识　3
1.2.1　接口的定义　4
1.2.2　接口的分类　4
1.2.3　HTTP　5
1.2.4　HTTP请求　6
1.2.5　HTTP响应　9
1.3　接口测试流程　11
1.4　接口文档系统　13
1.4.1　ShowDoc简介　13
1.4.2　ShowDoc部署　14
1.4.3　接口测试文档示例　16
Chapter　2 初识Postman工具
2.1　安装Postman　19
2.2　Postman工具简介　24
2.3　Postman账号　37
2.4　Postman同步　39
2.5　Postman设置　41
2.6　发送第 一个请求　45
2.7　将请求保存到集合　47
Chapter　3 Postman基本操作
3.1　API请求与响应　49
3.2　API授权、Cookies和证书　70
3.3　抓取HTTP请求　78
3.4　拦截器　80
3.5　代理　83
3.6　生成代码片段　87
3.7　Postman Echo　89
3.7.1　请求方法　89
3.7.2　Headers　95
3.7.3　认证方法　96
3.7.4　Cookies操作　99
Chapter　4 Postman集合
4.1　变量　102
4.1.1　变量的概念　102
4.1.2　管理环境变量　103
4.1.3　管理和查看全局变量　106
4.2　集合　108
4.2.1　创建集合　108
4.2.2　共享集合　111
4.2.3　管理集合　112
4.2.4　导入/导出文件　114
4.3　集合执行　118
4.3.1　集合运行参数　118
4.3.2　使用环境变量　121
4.3.3　使用数据文件　124
4.3.4　迭代运行集合　128
4.3.5　创建工作流　130
4.3.6　分享集合运行结果　133
4.3.7　集合运行排错　134
Chapter　5 Postman脚本的应用
5.1　脚本介绍　139
5.2　预请求脚本　143
5.3　测试脚本　150
5.3.1　Tests基础知识　150
5.3.2　脚本示例　152
5.3.3　脚本进阶　162
5.3.4　pm对象　166
5.4　分支和循环　174
5.5　Postman Sandbox　175
5.6　Newman　178
5.6.1　安装Newman　178
5.6.2　Newman选项　180
5.6.3　集合运行排错　182
5.6.4　定制报告　183
Chapter　6 Jenkins、Git与钉钉
6.1　Jenkins　187
6.1.1　部署Jenkins　188
6.1.2　管理插件　194
6.1.3　创建项目　197
6.1.4　配置项目运行频率　201
6.1.5　配置邮件发送　202
6.2　Git　207
6.2.1　什么是Git　207
6.2.2　安装Git　209
6.2.3　Git常用命令　210
6.2.4　GitHub远程仓库　222
6.2.5　搭建GitLab　227
6.3　钉钉　228
6.3.1　钉钉简介　229
6.3.2　集成Jenkins　231
Chapter　7 接口测试持续集成
7.1　整合GitHub　235
7.2　整合Jenkins　238
7.3　整合钉钉　240
Chapter　8 项目接口测试实战
8.1　项目介绍　243
8.1.1　项目部署　243
8.1.2　查看接口文档　245
8.2　编写接口测试文档　250
8.2.1　编写接口测试计划　251
8.2.2　编写接口测试用例　257
8.3　执行接口测试　267
8.3.1　从Postman执行接口测试　267
8.3.2　从Newman执行接口测试　306
8.4　接口自动化测试持续集成实战　307
8.4.1　通过GitHub维护测试文件　308
8.4.2　配置Jenkins自动化测试任务　309
8.4.3　接收自动化测试结果　311
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>接口自动化测试持续集成
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>冰与火之歌（卷三）
编者语序章正文附录附录一 主要家族谱系表附录二 地图附录三 度量衡表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>冰与火之歌（卷三）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>冰与火之歌·卷三·冰雨的风暴（全三册）
冰与火之歌（7）（卷三）冰雨的风暴（上）
冰与火之歌（8）（卷三）冰雨的风暴（中）
冰与火之歌（9）（卷三）冰雨的风暴（下）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>冰与火之歌·卷三·冰雨的风暴（全三册）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>茶杯里的风暴
推荐序：真物理学家看门道
序  章
第1章 爆米花和火箭——气体定律
玉米粒的微型高压锅
抹香鲸和福卡恰面包
风的瀑布和发泡奶油
马德堡半球和大象的鼻子
古老的蒸汽机和用来送信的火箭
能量和天气
第２章　有升必有落——重力
让葡萄干跳舞
空中坠落和海上摇摆
厨房秤、伦敦塔桥和霸王龙
鱼会打嗝吗？
蜡烛和钻石
第３章　小即是美——表面张力和黏度
咖啡渍和显微镜
偷吃奶油的蓝山雀
飞沫和肺结核
“家庭主妇”和肥皂泡
泳镜上的雾
毛巾和巨型红杉
第4章　时光中的一瞬——走向平衡
番茄酱和蜗牛
极快和极慢
船闸和大坝
晃动的茶水和喘息的狗
墨西哥城和台北101大厦
第5章　涟漪的故事——从水波到无线网络
浪花
银色鲱鱼和杯中硬币
大海的颜色、雷电和烤面包机
海豚和“泰坦尼克号”
灯光密码
温室效应和地球
珍珠和手机通信
第6章　鸭子为什么不会脚冷——原子之舞
盐和糖的真面目
花粉和爱因斯坦
湿衣服和煎奶酪
海冰和“前进号”
冰块、玻璃和体温计
鸭子的绝活
滚烫的勺子和冰冷的食物
第7章　勺子、旋涡和“伴侣号”——旋转定律
旋转中的稀奇事
自行车和弯道飞行
离心机和宇航员
飞饼和地球自转
投石车和人造卫星
掉落的面包和旋转游戏
四季更迭和飞轮储能
第8章　异性相吸——电与磁
磁的魔法
静电和蜜蜂
鸭嘴兽和海上电池
热茶水和电流
祖父的盒子和一段科学史
又是烤面包机
指南针和大陆漂移
最后一块拼图
第9章　不同的视角
人体
地球
文明
致谢
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>茶杯里的风暴
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大西洋的故事
导言　我们的海洋 / 001
序幕　鸿蒙初始 / 023
第1章　摩加多尔紫色群岛
1.　海螺壳 / 041
2.　尖塔顶 / 043
3.　新的伊甸园 / 045
4.　东岸与西岸 / 048
5.　海格力斯之柱 / 049
6.　法罗群岛 / 054
7.　文兰 / 060
8.　哥伦布 / 067
9.　阿特拉斯 / 072
第２章　浅滩与深海
1.　边界 / 079
2.　危险的博哈多尔角 / 0833.　温暖的湾流 / 089
4.　描述海洋 / 093
5.　探索深海 / 096
6.　深海测探 / 105
7.　大洋的边界 / 108
8.　百川终入海 / 112
第３章　美与力量
1.　大洋戏剧 / 117
2.　诗歌与传说 / 120
3.　怪兽与海之灵 / 125
4.　绘画海洋 / 129
5.　天堂的水 / 132
6.　海边的古城 / 134
7.　大海的乐章 / 151
8.　印象·日出 / 154
9.　海洋文学 / 156
第4章　海上悲声
1.　大海之上皆兄弟 / 165
2.　维京人来了 / 168
3.　新大陆 / 170
4.　海盗的黄金时代 / 175
5.　罪恶贸易 / 181
6.　海上霸主 / 188
7.　钢铁战舰的对决 / 192
8.　水下狼群 / 202
9.　无烟炸药 / 208
第5章　海上商人
1.　最古老的议会 / 213
2.　汉萨同盟 / 214
3.　更远的捕捞 / 218
4.　暴烈的邮轮 / 225
5.　海底电缆与无线电报 / 233
6.　移民 / 242
7.　船难悲剧 / 246
第6章　变化与衰落
1.　飞跨大洋 / 255
2.　巨量污染 / 266
3.　海鲜的背后 / 275
4.　北方鱼殇 / 279
5.　南方故事 / 289
6.　未知的恶果 / 296
第7章　仍未知的海洋
1.　被吹来的冰块 / 301
2.　末日之约 / 305
3.　上升的海平面 / 308
4.　飓风 / 315
5.　无尽的未知 / 322
尾声　世界尽头的灯塔 / 331
致谢 / 345
参考书目 / 350

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大西洋的故事
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>风暴眼
译本前言  一把解剖灵魂的手术刀    ——评怀特的《风暴眼》  朱炯强主要人物表第一章第二章第三章第四章第五章第六章第七章第八章第九章第十章第十一章第十二章附录  诺贝尔授奖辞  难忘的1989年7月21日  怀特作品要目
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>风暴眼
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据技术丛书
前言
作者简介
第1章 分布式单词计数
1.1 Storm topology的组成部分——stream、spout和bolt
1.1.1 Storm
1.1.2 spout
1.1.3 bolt
1.2 单词计数topology的数据流
1.2.1 语句生成bolt
1.2.2 语句分割bolt
1.2.3 单词计割bolt
1.2.4 上报bolt
1.3 实现单词计数top
1.3.1 配置开发环境
1.3.2 实现Sentence
1.3.3 实现语句分割bolt
1.3.4 实现单词计割bolt
1.3.5 实现上报bolt
1.3.6 实现单词计数topo
1.4 Storm的并发机制
1.4.1 WordCountTopology的并发机制
1.4.2 给topology增加woker
1.4.3 配置executor和task
1.5 理解数据流分组
1.6 有保障机制的数据处理
1.6.1 spout的可靠性
1.6.2 bolt的可靠性
1.6.3 可靠的单词计数
总结
第2章 配置Storm集群
2.1 Storm集群的框架
2.1.1 理解nimbus守护进程
2.1.2 supervisor守护进程的工作方式
2.1.3 Apache ZooKeeper简介
……
第3章 Trident和传感器数据
第4章 实时趋势分析
第5章 实时图形分析
第6章 人工智能
第7章 整合Druid进行金融分析
第8章 自然语言处理
第9章 在Hadoop上部署Storm进行广告分析
第10章 云环境下的S
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据技术丛书
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>颠覆大数据分析
目录
前言
致谢
关于作者
1 引言：为什么要超越 Hadoop Map-Reduce  1
Hadoop的适用范围  3
大数据分析之机器学习实现的革命  10
第一代机器学习工具 /范式  11
第二代机器学习工具 /范式  11
第三代机器学习工具 /范式  14
小结  18
参考文献  19
2 何为伯克利数据分析栈（BDAS）  23
实现 BDAS的动机  24
Spark：动机  25
Shark：动机  26
Mesos：动机  28
BDAS的设计及架构  29
Spark：高效的集群数据处理的范式  34
Spark的弹性分布式数据集  36
Spark的实现  40
Spark VS. 分布式共享内存系统  42
RDD的表达性  44
类似 Spark的系统  45
Shark：分布式系统上的 SQL接口  46
Spark为 Shark提供的扩展  47
列内存存储  49
分布式数据加载  50
完全分区智能连接  50
分区修剪  50
机器学习的支持  51
Mesos：集群调度及管理系统  51
Mesos组件  52
资源分配  54
隔离  55
容错性  57
小结  58
参考文献  59
3 使用 Spark实现机器学习算法  66
机器学习基础知识  66
机器学习：随机森林示例  68
逻辑回归：概述  72
二元形式的逻辑回归  73
逻辑回归估计  75
多元逻辑回归  76
Spark中的逻辑回归算法  77
支持向量机  80
复杂决策面  81
支持向量机背后的数学原理  82
Spark中的支持向量机  84
Spark对 PMML的支持  85
PMML结构  87
PMML的生产者及消费者  92
Spark对朴素贝叶斯的 PMML支持  94
Spark对线性回归的 PMML支持  95
在 Spark中使用 MLbase进行机器学习  97
参考文献  99
4 实现实时的机器学习算法 101
Storm简介  101
数据流  103
拓扑  104
Storm集群  105
简单的实时计算例子  106
数据流组  108
Storm的消息处理担保  109
基于 Storm的设计模式  111
分布式远程过程调用  111
Trident：基于 Storm的实时聚合  115
实现基于 Storm的逻辑回归算法  116
实现基于 Storm的支持向量机算法  120
Storm对朴素贝叶斯 PMML的支持  122
实时分析的应用  126
工业日志分类  126
互联网流量过滤器  130
Storm的替代品  131
Spark流  133
D-Streams的动机  133
参考文献  135
5 图处理范式 138
Pregel：基于 BSP的图处理框架  139
类似的做法  141
开源的 Pregel实现  143
Giraph  143
GoldenORB  145
Phoebus  145
Apache Hama  146
Stanford GPS  146
GraphLab  147
GraphLab：多核版本  148
分布式的 GraphLab  150
PowerGraph  152
通过 GraphLab实现网页排名算法  156
顶点程序  158
基于 GraphLab实现随机梯度下降算法  163
参考文献  167
6 结论：超越Hadoop Map-Reduce的大数据分析  171
Hadoop YARN概览  172
Hadoop YARN的动机  172
作为资源调度器的 YARN  174
YARN上的其他框架  175
大数据分析的未来是怎样的  177
参考文献  180
附录A 代码笔记  182
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>颠覆大数据分析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>危机领导力
悉尼至霍巴特帆船赛航线图
前言
领导者的角色
第一部分
悉尼至霍巴特帆船赛与
“AFR午夜漫步者”号的故事
1 航海赛事巅峰
2 航海世家的元老
3 “纳祖拉”号与冠军队伍的组建
4 “午夜漫步者”号--孤注一掷的选择
5 “漫步者”号团队--准备启程
6 当地的竞争者
7 “莎扬娜拉”号--美国大车
8 风云莫测--小打小闹还是事态严峻？
9 “AFR午夜漫步者”号--他们出发了！
10 “莎扬娜拉”号--地球上最专业的水手
11 “AFR午夜漫步者”号--帅呆了
12 “莎扬娜拉”号--暂时落后
13 不祥之兆--狂风警报
14 “AFR午夜漫步者”号--是软还是硬？
15 “ C离岸旁观”号--命运的捉弄
16 高空援救--绞盘上的天使
17 “AFR午夜漫步者”号--白浪地狱
18 “AFR午夜漫步者”号--轮流掌舵
19 “猎户之剑”号--失控
20 大营救--灾难成真
21 “AFR午夜漫步者”号--听
22 “莎扬娜拉”号--掉头
23 “AFR午夜漫步者”号-- 一马当先
24 “莎扬娜拉”号--千年之后
25 加油，“漫步者”号！
26 风暴过后
27 远洋，短程--“漫步者”号的连胜纪录
第二部分
危机合作中的关键策略
28 策略简介
29 研究面临的挑战
30 我的霍巴特之旅
31 团结的队伍：策略1--让团队成为明星
32 准备、准备、准备：策略2--不给失败留任何借口
33 适度乐观：策略3--发现并关注获胜的场景
34 学无止境：策略4--打造热衷于学习和创新的“工合”文化
35 评估风险：策略5--愿意驶进风暴
36 保持联络：策略6--透过风浪中的噪声
37 填补空缺：策略7--找到共同掌舵的办法
38 消除阻力：策略8--正视问题：应对前进中的障碍
39 保持适应力：策略9--掌握快速恢复的艺术
40 坚持创新：策略10--永不放弃：总有别的出路
附录1 船长须知
附录2 帆船各部位示意图
致谢
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>危机领导力
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>病毒来袭
第一部分.乌云密布的文明史
01 我们寄居在病毒的星球
如果有一位聪明的天外来客要以哪些生物构成地球生物多样性和生物量的主体为基础，编撰一部生物百科全书的话，其中大部分内容将会介绍肉眼看不见的世界和原核生物。被我们一般认为是全部生物的真核生物，只用薄薄几卷就可以被介绍完。而人类，不过是动物卷里一个显眼的注脚而已。
02  狩猎，加速病毒的跨种群传播
我们倾向于将性或生育之类的事视为亲密举动，因为这些行为将个体以正常互动无法企及的方式联系在一起，但从微生物的视角来看，狩猎和屠宰代表着终极亲密行为。这是将一个物种和另一个物种身上的所有组织，连同栖息在每一个物种上的特定微生物都连接起来的行为。
03  微生物净化使人类更脆弱
当人类祖先从雨林踏入草原，人口的锐减、栖息地的变化以及蒸煮食物等生活方式的新变化，使得他们的微生物库的规模不断缩减，一些抵御传染性疾病的基因防御能力也随之降低。当人类遭到猿类表亲的微生物库侵害时，鲜有招架之功。这为病毒风暴的酝酿创造了条件。
04  驯养活动对病毒传播的三重影响
从抓捕动物到驯养家畜，从采集果实到种植植物，人类祖先的生活开始由游牧转型为定居。而人类与家畜的亲密接触、家畜与野生动物“剪不断、理还乱”的联系、彼此连接的大规模固定社区的发展壮大，让人类置身于一个将首次暴发流行病的世界。
第二部分  流行病风暴来袭
05  什么是流行病
全球交通枢纽将人和动物联系在一起，催生出了一个容易被流行病侵害的互联世界。而我们是否将一种传播的微生物定义为流行病，与其致命性无关。流行病只是病毒传播能力的标记。所有大陆上都有个体被感染到的一种新感染原，我们称之为流行病。
06  地球村与流行病时代
公路、铁路、航海和航空等交通方式的变革，创造了一个全新的互联世界。这给人类带来了便利，却也让以前分散在各处并处于静止状态的病毒有机会快速流动，高度混合。这一事实将永久改变流行病影响人类的方式，把我们真正带入流行病时代。
07  医学技术让我们更“亲密”
输血、移植和注射等医学技术的革新，帮我们摆脱了很多致命疾病的威胁，也使我们的血液、器官与其他人、甚至其他物种的身体组织之间，产生了地球上有生命以来史无前例的联结。人类成为彼此关系亲密的物种，为流行病传播提供了新路径。
08  新一波流行病威胁
当我们将经济开发的足迹伸向丛林，我们也把新的病毒带回城市，高密度的城市人口、野生动物的活体交易、免疫力低下的易感人群，为病毒间的基因重组提供了温床。从未谋面的微生物相遇后将生成新的镶嵌体感染原，其传播方式是母代病毒无法办到的。新的流行病，已经来袭。
第三部分  流行病监测与防控
09  全球性监测系统的建立
等到流行病大暴发后再去应对，往往为时已晚。如何在致命性病毒演变成流行病之前就抓住它、遏制它 ?我们在世界上最偏僻的地方设立监测点，把与动物密切接触的猎人当作哨兵人群。当感染源从动物跳到人类身上时，流行病的警报就拉响了。
10  大数据时代的流行病预测
科学新技术的发展，让我们识别病毒的能力得到加强；而手机信息、搜索引擎、社交媒体等现代信息和传播技术手段的综合运用更是绘制了一副包含了层层信息的疫情聚合图，为我们提早捕获流行病暴发信息提供了条件。谁将是最终的赢家？是流行病将横扫人类，毁掉数百万生命，还是科技将策马前去，拯救人类？
11  病毒对疾病治疗的积极作用
病毒并不总是有害的，如果利用得当，它们能帮我们预防传染性疾病，控制慢性病发展，甚至直接治疗一些疾病。公共卫生事业的目的，不应该是打造一个完全无菌的世界，而是找到坏家伙并控制它们。有朝一日，我们保护自身的方式，也许是仰仗与我们共生的病毒，而不是消灭它们。
12  流行病的末日来临
流行病环球免疫系统的建立，需要政府、企业、公民的共同努力。我们处在一个用技术手段建造环球免疫系统的时代，应该、也能够将流行病预测和预防做得更好。当我们能够宣布“这是最后的一种流行病”时，我们发现和遏制流行病的能力，已经强到连流行病这个词都不需要了。
致谢
译者后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>病毒来袭
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Storm源码分析
第1章　总体架构与代码结构　　1
1.1　Storm的总体结构　　1
1.2　Storm的元数据　　3
1.2.1　元数据介绍　　3
1.2.2　Storm怎么使用这些元数据　　4
1.3　Storm的代码结构　　7
1.3.1　Clojure代码　　7
1.3.2　Java代码　　8
1.3.3　Trident代码　　9
1.3.4　其他代码　　10
第2章　搭建Storm集群　　11
2.1　搭建单机Storm集群　　11
2.2　搭建多机Storm集群　　14
2.2.1　设置环境　　14
2.2.2　启动Storm集群　　15
2.2.3　提交Topology　　15
2.3　WordCountTopology介绍　　15
2.3.1　RandomSentenceSpout　　15
2.3.2　SplitSentence　　16
2.3.3　WordCount　　17
2.3.4　WordCountTopology构建　　17
第3章　Storm编程基础　　19
3.1　Fields定义　　19
3.2　Tuple接口　　20
3.3　常用声明接口　　21
3.3.1　配置声明接口　　22
3.3.2　输入声明接口　　23
3.3.3　输出字段声明接口　　24
3.3.4　组件声明接口　　25
3.4　Spout输出收集器　　25
3.4.1　ISpoutOutputCollector和SpoutOutputCollector　　25
3.4.2　Executor中ISpoutOutputCollector的实现　　27
3.5　Bolt输出收集器　　28
3.5.1　IOutputCollector和OutputCollector　　28
3.5.2　IBasicOutputCollector和BasicOutputCollector　　31
3.5.3　BatchOutputCollector和BatchOutputCollectorImpl　　32
3.5.4　　Executor中的IOutputCollector实现　　34
3.6　组件接口　　35
3.7　Spout接口　　35
3.7.1　ISpout　　36
3.7.2　IRichSpout　　38
3.8　Bolt接口　　38
3.8.1　IBolt　　38
3.8.2　IRichBolt　　40
3.8.3　IBasicBolt　　40
3.8.4　IBatchBolt　　42
3.8.5　小结　　45
3.9　Storm数据结构　　46
3.9.1　GlobalStreamId　　46
3.9.2　消息分组方式　　46
3.9.3　StreamInfo　　47
3.9.4　ShellComponent　　47
3.9.5　ComponentObject　　47
3.9.6　ComponentCommon　　47
3.9.7　SpoutSpec　　48
3.9.8　Bolt　　48
3.9.9　StormTopology　　49
3.9.10　TopologySummary　　49
3.9.11　SupervisorSummary　　49
3.9.12　ClusterSummary　　50
3.9.13　BoltStats　　50
3.9.14　SpoutStats　　50
3.9.15　统计信息　　50
3.9.16　DRPC　　51
3.10　基本Topology构建器　　52
3.10.1　TopologyBuilder　　52
3.10.2　ConfigGetter　　55
3.10.3　SpoutGetter和BoltGetter　　55
3.10.4　一个简单例子　　56
3.11　异常处理　　57
第4章　基础函数和工具类　　58
4.1　计时器　　58
4.1.1　mk-timer　　58
4.1.2　check-active!　　60
4.1.3　schedule　　60
4.1.4　schedule-recurring　　60
4.1.5　cancel-timer　　61
4.2　async-loop　　61
4.3　event-manager　　62
4.4　even-sampler　　63
4.5　ZooKeeper工具类　　64
4.5.1　mk-client　　64
4.5.2　create-node　　65
4.5.3　get-data　　65
4.5.4　进程内启动ZooKeeper　　66
4.6　LocalState　　66
4.7　ClusterState　　68
4.8　StormClusterState　　69
第5章　通信机制　　71
5.1　进程间通信　　71
5.1.1　进程间通信协议　　71
5.1.2　LocalCluster模式实现　　72
5.1.3　分布式模式实现　　73
5.1.4　协议使用　　75
5.2　进程内通信　　77
5.2.1　Disruptor Queue的使用　　77
5.2.2　DisruptorQueue的Clojure处理器　　80
第6章　Nimbus　　81
6.1　Nimbus服务接口定义　　81
6.2　Nimbus相关的数据结构　　83
6.2.1　Java 数据结构　　83
6.2.2　Clojure数据结构　　84
6.3　Nimbus中的线程介绍　　86
6.3.1　mk-assignments　　87
6.3.2　do-cleanup　　89
6.3.3　clean-inbox　　90
6.4　Topology状态转移　　90
6.4.1　transition-name!　　90
6.4.2　transition!　　91
6.4.3　state-transitions　　92
6.5　启动Nimbus服务　　96
6.5.1　launch-server！　　96
6.5.2　service-handler　　97
6.6　关闭Nimbus服务　　99
6.7　主要服务方法　　99
6.7.1　submitTopology　　99
6.7.2　kill、rebalance、activate、deactivate 方法　　101
6.7.3　文件上传与下载　　102
6.7.4　获取UI所需的信息　　104
6.7.3　获取Topology　　106
6.7.6　获取Storm配置项　　107
6.8　主要辅助方法　　107
6.8.1　system-topology!　　107
6.8.2　normalize-topology　　112
6.8.3　compute-new-topology->executor->node+port　　114
6.8.4　compute-executors　　117
第7章　Scheduler　　119
7.1　IScheduler接口　　119
7.2　EvenScheduler　　120
7.2.1　schedule-topolpgies-evenly　　120
7.2.2　schedule-topology　　121
7.2.3　get-alive-assigned-node+
port->executors　　122
7.2.4　sort-slots　　123
7.3　DefaultScheduler　　124
7.3.1　default-schedule　　124
7.3.2　slots-can-reassign　　126
7.3.3　bad-slots　　126
7.4　IsolationScheduler　　127
7.5　调度示例　　131
7.5.1　EvenScheduler和DefaultScheduler　　131
7.5.2　IsolationScheduler　　134
第8章　Scheduler　　137
8.1　与Supervisor相关的数据结构　　137
8.1.1　standalone-supervisor　　137
8.1.2　Supervisor的数据　　138
8.1.3　本地存储数据　　139
8.2　Supervisor中的线程　　140
8.2.1　计时器线程　　140
8.2.2　同步Nimbus任务的线程　　140
8.2.3　管理Worker进程的线程　　143
8.3　启动Supervisor　　145
8.4　关闭Supervisor　　147
8.5　重要方法介绍　　147
8.5.1　launch-worker　　147
8.5.2　read-allocated-workers　　150
8.5.3　wait-for-worker-launch　　151
8.5.4　shutdown-worker　　152
8.5.5　download-storm-code　　152
第9章　Worker　　155
9.1　Worker中的数据　　155
9.2　Worker中的计时器　　157
9.2.1　Worker的心跳　　157
9.2.2　Executor的心跳　　158
9.2.3　Worker中对ZMQ连接的维护　　159
9.2.4　从ZooKeeper获取Topology的活跃情况　　161
9.2.5　小结　　162
9.3　创建Worker　　163
9.4　关闭Worker　　164
9.5　重要辅助方法介绍　　165
9.5.1　Worker中的接收函数　　166
9.5.2　Worker中的发送函数　　167
9.5.3　获取属于Worker的Executor　　169
9.5.4　创建Executor的接收消息队列和查找表　　169
9.5.5　下载Topology的配置项以及代码　　170
9.6　小结　　171
第10章　Executor　　172
10.1　Executor的数据　　172
10.2　Executor的输入和输出　　174
10.2.1　Executor的输入及处理　　174
10.2.2　Executor的输出及发送　　175
10.3　Spout类型的Executor　　176
10.3.1　准备消息循环的数据　　176
10.3.2　Spout输入处理函数　　178
10.3.3　Spout消息发送函数　　180
10.3.4　Spout对象的初始化　　181
10.3.5　消息循环　　182
10.4　Bolt类型的Executor　　184
10.4.1　准备消息循环的数据　　184
10.4.2　Bolt输入处理函数　　184
10.4.3　Bolt的消息发送函数　　185
10.4.4　Bolt对象的初始化　　185
10.4.5　消息循环　　186
10.5　创建Executor　　187
10.6　辅助函数介绍　　188
10.6.1　组件的Grouper函数　　188
10.6.2　带流量控制的错误报告方法　　193
10.6.3　触发系统Ticks　　194
10.7　小结　　196
第11章　Task　　198
11.1　Task的上下文对象　　198
11.1.1　TopologyContext　　198
11.1.2　GeneralTopologyContext　　199
11.1.3　WorkerTopologyContext　　200
11.1.4　TopologyContext　　201
11.2　创建Task数据　　202
11.3　mk-tasks-fn函数　　204
11.4　send-unanchored　　205
11.5　创建Task　　206
11.6　Storm中传输的消息以及序列化　　206
第12章　Storm的Ack框架　　208
12.1　Acker Bolt的实现分析　　209
12.2　启动消息跟踪　　211
12.3　消息跟踪　　212
12.4　Ack机制的例子　　214
第13章　系统运行统计　　216
13.1　基础数据结构以及更新算法　　216
13.1.1　滑动窗口的数据结构　　216
13.1.2　滑动窗口的回调函数　　220
13.1.3　滑动窗口集合的类型　　221
13.2　Storm中的统计信息　　222
13.2.1　Stats中定义的统计类别　　222
13.2.2　运行统计的更新　　223
13.2.3　运行统计的更新时间点　　223
13.2.4　获取统计数据　　228
13.3　运行统计的Thrift结构　　229
第14章　系统运行统计的另一种实现　　231
14.1　内置统计信息的计算　　231
14.1.1　MultiCountMetric　　232
14.1.2　MultiReducedMetric　　233
14.2　内置统计类型　　234
14.2.1　Spout类型的内置统计　　235
14.2.2　Bolt类型的内置统计　　235
14.3　统计触发消息　　235
14.3.1　注册统计信息　　236
14.3.2　触发消息的产生与发送　　237
14.3.3　处理统计触发消息　　238
14.4　运行统计收集节点　　239
14.5　SystemBolt　　241
第15章　事务Topology的实现　　243
15.1　事务Topology的实现概述　　243
15.1.1　事务Topology的类型　　244
15.1.2　事务Topology的类关系　　245
15.2　ITransactionalSpout接口　　246
15.3　协调Spout节点的执行器　　248
15.3.1　ZooKeeper客户端工具　　248
15.3.2　协调Spout的执行器　　255
15.3.3　消息发送Bolt的执行器　　261
15.4　CoordinatedBolt的实现分析　　264
15.4.1　TrackingInfo　　264
15.4.2　CoordinatedOutput-
Collector　　265
15.4.3　CoordinatedBolt中的消息类型　　267
15.4.4　成员变量以及主要方法分析　　267
15.5　分区的事务类型　　271
15.5.1　分区的事务Spout接口　　271
15.5.2　分区的事务Spout的执行器　　273
15.6　分区的模糊事务Spout　　277
15.6.1　分区的模糊事务Spout的接口　　277
15.6.2　模糊的事务Spout执行器　　278
15.7　事务Topology的构建器　　281
15.7.1　构建器的构造函数及成员变量　　281
15.7.2　设置Bolt对象　　283
15.7.3　构建Topology　　284
15.7.4　输入流声明器　　286
第16章　事务Topology示例　　288
16.1　例子代码　　288
16.1.1　分区的事务Spout　　288
16.1.2　局部计数Bolt的实现　　291
16.1.3　全局计数Bolt的实现　　292
16.2　构建Topology　　293
16.3　事务处理示例　　295
第17章　Trident的Spout节点　　298
17.1　ITridentSpout接口　　298
17.1.1　BatchCoordinator接口　　299
17.1.2　TridentSpoutCoordinator　　300
17.1.3　MasterBatchCoordinator　　301
17.1.4　消息发送节点接口　　306
17.1.5　消息发送接口的执行器　　306
17.2　适配IRichSpout接口　　307
17.3　适配IBatchSpout接口　　311
17.4　Trident中分区的Spout类型　　311
17.4.1　分区Spout接口　　311
17.4.2　分区Spout的执行器　　313
17.5　模糊事务类型的Spout节点　　316
17.5.1　模糊事务类型的Spout接口　　317
17.5.2　模糊事务类型Spout的执行器　　317
17.6　构建Spout节点　　320
17.6.1　TridentTopology的newStream调用　　320
17.6.2　TridentTopology中newDRPCStream调用　　321
第18章　Trident的存储　　322
18.1　存储的基本接口　　322
18.2　MapState接口的实现　　323
18.2.1　非事务类型的存储　　324
18.2.2　事务类型的存储　　325
18.2.3　模糊事务类型存储　　327
18.3　值的序列化方法　　329
18.4　数据更新接口　　330
18.4.1　CombinerValueUpdater　　330
18.4.2　ReducerValueUpdater　　331
18.5　存储更新接口　　331
18.5.1　ReducerAggStateUpdater　　332
18.5.2　MapReducerAggStateUpdater　　332
18.5.3　BaseStateUpdater　　334
18.6　创建存储对象　　334
第19章　Trident消息　　336
19.1　ValuePointer　　336
19.2　Factory接口及其实现　　337
19.2.1　ProjectionFactory　　338
19.2.2　FreshOutputFactory　　339
19.2.3　OperationOutputFactory　　339
19.2.4　RootFactory　　341
19.3　消息工厂的例子　　342
19.4　TridentTupleView　　342
19.5　ComboList　　343
第20章　Trident操作与处理节点　　346
20.1　操作的基本接口　　346
20.2　Aggregator实现　　347
20.2.1　GroupedAggregator　　348
20.2.2　ChainedAggregatorImpl　　350
20.2.3　SingleEmitAggregator　　353
20.3　用户接口及其实现　　355
20.3.1　ReducerAggregator接口及其实现　　355
20.3.2　CombinerAggregator接口及其实现　　356
20.4　所有处理节点的上下文　　357
20.4.1　单个处理节点的上下文　　358
20.4.2　操作执行的上下文　　359
20.5　Trident的输出收集器　　359
20.5.1　FreshCollector　　359
20.5.2　CaptureCollector　　360
20.5.3　GroupCollector　　360
20.5.4　AppendCollector　　361
20.5.5　AddIdCollector　　361
20.6　Trident的处理节点　　362
20.6.1　TridentProcessor接口　　363
20.6.2　PartitionPersistProcessor　　363
20.6.3　StateQueryProcessor　　365
20.7　聚集器的执行　　367
第21章　Trident流的基本操作　　370
21.1　流的成员变量和基础方法　　370
21.1.1　流的成员变量　　370
21.1.2　流节点名字　　370
21.1.3　流的映射检查　　372
21.1.4　添加节点　　372
21.2　流映射操作　　373
21.3　流的分组操作　　374
21.4　流的逐行操作　　374
21.5　流的分区操作　　374
21.6　流的单聚集器聚集操作　　376
21.7　流的多聚集器聚集操作　　377
21.7.1　ChainedAggregatorDeclarer　　377
21.7.2　分区上的局部聚集操作　　379
21.7.3　全局聚集操作　　379
21.7.4　含有多个聚集器的partitionAggregate操作　　381
21.8　流的聚集操作　　382
21.9　流的分区写入操作　　383
21.10　查询操作　　384
21.11　流的全局写入操作　　384
21.12　流的操作与有向图构建　　384
21.13　分组流　　385
21.13.1　成员变量　　385
21.13.2　逐行操作　　385
21.13.3　分组流的分区聚集操作　　386
21.13.4　查询操作　　386
21.13.5　聚集操作　　386
21.13.6　写入操作　　387
21.14　利用流操作来构建Topology的例子　　388
第22章　Trident中流的交互操作　　392
22.1　基本接口　　392
22.2　JoinerMultiReducer　　393
22.2.1　成员变量及构造函数　　393
22.2.2　execute方法　　395
22.2.3　complete方法　　397
22.3　GroupedMultiReducerExecutor　　397
22.4　MultiReducerProcessor　　399
22.5　连接操作　　401
22.6　流合并操作　　403
第23章　Trident中的Bolt节点　　404
23.1　SubTopologyBolt　　404
23.1.1　输入准备　　404
23.1.2　成员变量　　405
23.1.3　主要方法　　406
23.2　Trident中的Bolt执行器　　409
23.2.1　ITridentBatchBolt接口　　410
23.2.2　TrackedBatch　　410
23.2.3　定制的输出收集器　　412
23.2.4　消息类型　　414
23.2.5　数据成员分析　　414
23.2.6　主要成员方法分析　　416
第24章　Trident的执行优化　　420
24.1　节点类型　　420
24.1.1　基本节点类型　　420
24.1.2　Spout节点　　422
24.1.3　处理节点　　422
24.1.4　分区节点　　423
24.2　执行优化算法　　426
24.2.1　节点组　　426
24.2.2　节点组的合并算法　　427
24.2.3　处理节点组中的分区节点　　431
24.2.4　节点组以不同的方式收听相同流　　431
24.2.5　执行优化后的节点组　　434
24.2.6　计算节点组的并行度　　434
第25章　Trident与DRPC　　437
25.1　DRPC服务器　　438
25.1.1　DRPC服务器的成员变量　　438
52.1.2　DRPC用户接口及其实现　　439
25.1.3　DRPC Topology端接口及其实现　　440
25.1.4　启动DRPC服务器　　441
25.2　DRPC的客户端　　442
25.3　DRPC中Spout节点　　443
25.4　DRPC Spout的执行器　　446
25.5　completeDRPC操作　　449
25.6　返回DRPC结果　　451
第26章　Trident的Topology构建器　　453
26.1　基本工具函数　　453
26.1.1　committerBatches　　453
26.1.2　fleshOutStreamBatchIds　　453
26.1.3　getOutputStreamBatchGroups　　454
26.2　TridentTopologyBuilder　　455
26.2.1　成员变量　　455
26.2.2　设置Spout节点　　456
26.2.3　设置Bolt节点　　458
26.3　一个例子　　460
第27章　多语言　　462
27.1　ShellProcess　　462
27.2　ShellBolt　　464
27.2.1　成员变量　　464
27.2.2　读写线程　　465
27.3　ShellSpout　　467
第28章　Storm中的配置项　　469

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Storm源码分析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Storm实战
第1 章 Storm 基础 1
1.1 Storm 能做什么 ............................................... 2
1.2 Storm 特性 ...................................................... 3
1.3 其他流计算系统 .............................................. 8
1.4 应用模式 ....................................................... 13
第2 章 Storm 初体验 17
2.1 本地环境搭建 ............................................... 18
2.2 Storm 集群 .................................................... 25
第3 章 构建Topology 41
3.1 Storm 基本概念 ............................................. 42
3.2 构建Topology ............................................... 53
3.3 小结 .............................................................. 61
第4 章 Topology 的并行度 62
4.1 并行元素 ....................................................... 63
4.2 配置并行度 ................................................... 65
4.3 一个运行中Topology 的例子 ....................... 68
4.4 如何更新运行中的Topology 的并行度 ........ 71
第5 章 消息的可靠处理 73
5.1 简介 .............................................................. 74
5.2 理解消息被完整处理 .................................... 74
5.3 消息的生命周期 ............................................ 76
5.4 可靠相关的API ............................................ 79
5.5 高效地实现tuple tree .................................... 84
5.6 选择合适的可靠性级别 ................................ 87
5.7 集群的各级容错 ............................................ 89
5.8 小结 .............................................................. 91
第6 章 一致性事务 92
6.1 简单设计一：强顺序流 ................................ 93
6.2 简单设计二：强顺序batch 流 ...................... 95
6.3 CoordinateBolt 的原理 .................................. 96
6.4 Transactional Topology .................................. 98
第7 章 DRPC 105
7.1 Storm DRPC ................................................ 106
7.2 总体概述 ..................................................... 106
7.3 LinearDRPCTopologyBuilder ...................... 108
7.4 本地模式DRPC .......................................... 110
7.5 远程模式DRPC .......................................... 111
7.6 一个复杂的例子 .......................................... 113
7.7 非线性DRPC 拓扑 ..................................... 117
7.8 LinearDRPCTopologyBuilder 工作过程 ...... 117
7.9 高级进阶 ..................................................... 118
第8 章 Trident 的特性 119
8.1 理解Trident ................................................ 120
8.2 结合多个Trident 任务 ................................ 124
8.3 消费和生产Field ........................................ 126
8.4 State（状态保存） ...................................... 128
8.5 Trident Topology 的执行过程 ...................... 136
8.6 总结 ............................................................ 137
第9 章 Storm 实例 138
9.1 一个简单的实例 .......................................... 139
9.2 复杂一点的实例 .......................................... 150
9.3 其他 ............................................................ 161
第10 章 常见应用问题分析 162
10.1 性能问题排查与定位 ................................ 163
10.2 系统中常见的问题与排查 ......................... 167
10.3 业务问题的定位与排查 ............................ 170
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Storm实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Storm实时数据处理
第1章　搭建开发环境 / 1
1.1　简介 / 1
1.2　搭建开发环境  / 1
1.3　分布式版本控制 / 3
1.4　创建“Hello World”Topology / 6
1.5　创建Storm集群——配置机器 / 12
1.6　创建Storm集群——配置Storm / 18
1.7　获取基本的点击率统计信息 / 23
1.8　对Bolt进行单元测试 / 31
1.9　实现集成测试 / 34
1.10　将产品部署到集群 / 37
第2章　日志流处理 / 38
2.1　简介 / 38
2.2　创建日志代理 / 38
2.3　创建日志Spout / 40
2.4　基于规则的日志流分析 / 45
2.5　索引与持久化日志数据 / 49
2.6　统计与持久化日志统计信息 / 53
2.7　为日志流集群创建集成测试 / 55
2.8　创建日志分析面板 / 59
第3章　使用Trident计算单词重要度 / 71
3.1　简介 / 71
3.2　使用Twitter过滤器创建URL流 / 71
3.3　从文件中获取整洁的词流 / 76
3.4　计算每个单词的相对重要度 / 81
第4章　分布式远程过程调用 / 85
4.1　简介 / 85
4.2　通过DPRC实现所需处理流程 / 85
4.3　对Trident Topology进行集成测试 / 90
4.4　实现滚动窗口Topology / 95
4.5　在集成测试中模拟时间 / 98
第5章　在不同语言中实现Topology / 100
5.1　简介 / 100
5.2　在Qt中实现多语言协议 / 100
5.3　在Qt中实现SplitSentence Bolt / 105
5.4　在Ruby中实现计数 Bolt / 108
5.5　在Clojure中实现单词计数Topology / 109
第6章　Storm与Hadoop集成 / 113
6.1　简介 / 113
6.2　在Hadoop中实现TF-IDF算法 / 115
6.3　持久化来自Storm的文件 / 121
6.4　集成批处理与实时视图 / 122
第7章　实时机器学习 / 127
7.1　简介 / 127
7.2　实现事务性Topology / 129
7.3　在R中创建随机森林分类模型 / 134
7.4　基于随机森林的事务流业务分类 / 143
7.5　在R中创建关联规则模型 / 149
7.6　创建推荐引擎 / 152
7.7　实时在线机器学习 / 157
第8章　持续交付 / 162
8.1　简介 / 162
8.2　搭建CI服务器 / 162
8.3　搭建系统环境 / 164
8.4　定义交付流水线 / 166
8.5　实现自动化验收测试 / 170
第9章　在AWS上部署Storm / 177
9.1　简介 / 177
9.2　使用Pallet在AWS上部署Storm / 177
9.3　 搭建虚拟私有云 / 181
9.4　使用Vagrant在虚拟私有云上部署Storm / 189
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Storm实时数据处理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Storm技术内幕与大数据实践
第1章　绪论 1
1．1　Storm的基本组件 2
1．1．1　集群组成 2
1．1．2　核心概念 3
1．1．3　Storm的可靠性 5
1．1．4　Storm的特性 6
1．2　其他流式处理框架 6
1．2．1　Apache S4 6
1．2．2　Spark Streaming 6
1．2．3　流计算和Storm的应用 7
第2章　实时平台介绍 11
2．1　实时平台架构介绍 11
2．2　Kafka架构 13
2．2．1　Kafka的基本术语和概念 13
2．2．2　Kafka在实时平台中的应用 14
2．2．3　消息的持久化和顺序读写 15
2．2．4　sendfile系统调用和零复制 15
2．2．5　Kafka的客户端 17
2．2．6　Kafka的扩展 17
2．3　大众点评实时平台 17
2．3．1　相关数据 18
2．3．2　实时平台简介 18
2．3．3　Blackhole 19
2．4　1号店实时平台 20
第3章　Storm集群部署和配置 23
3．1　Storm的依赖组件 23
3．2　Storm的部署环境 24
3．3　部署Storm服务 24
3．3．1　部署ZooKeeper 24
3．3．2　部署Storm 25
3．3．3　配置Storm 25
3．4　启动Storm 28
3．5　Storm的守护进程 28
3．6　部署Storm的其他节点 30
3．7　提交Topology 30
第4章　Storm内部剖析 33
4．1　Storm客户端 33
4．2　Nimbus 36
4．2．1　启动Nimbus服务 36
4．2．2　Nimbus服务的执行过程 38
4．2．3　分配Executor 44
4．2．4　调度器 46
4．2．5　默认调度器DefaultScheduler 47
4．2．6　均衡调度器EvenScheduler 50
4．3　Supervisor 53
4．3．1　ISupervisor接口 54
4．3．2　Supervisor的共享数据 54
4．3．3　Supervisor的执行过程 56
4．4　Worker 61
4．4．1　Worker中的数据流 61
4．4．2　创建Worker的过程 62
4．5　Executor 65
4．5．1　Executor的创建 66
4．5．2　创建Spout的Executor 69
4．5．3　创建Bolt的Executor 74
4．6　Task 76
4．6．1　Task的上下文对象 77
4．6．2　Task的创建 82
4．7　Storm中的统计 84
4．7．1　stats框架 85
4．7．2　metric框架 90
4．8　Ack框架 91
4．8．1　Ack的原理 92
4．8．2　Acker Bolt 94
4．9　Storm总体架构 95
第5章　Storm运维和监控 97
5．1　主机信息监控 97
5．1　日志和监控 98
5．2　Storm UI和NimbusClient 99
5．3　Storm Metric的使用 100
5．4　Storm ZooKeeper的目录 102
5．5　Storm Hook的使用 104
第6章　Storm的扩展 107
6．1　Storm UI的扩展 107
6．1．1　Storm UI原生功能 108
6．1．2　Storm UI新功能需求 108
6．1．3　Storm的Thrift接口 109
6．2　资源隔离 110
6．2．1　CGroup测试 111
6．2．2　基于CGroup的资源隔离的实现 119
第7章　Storm开发 121
7．1　简单示例 121
7．2　调试和日志 122
7．3　Storm Trident 124
7．4　Strom DRPC 128
第8章　基于Storm的实时数据平台 129
8．1　Hadoop到Storm的代码迁移经验 129
8．2　实时用户画像 130
8．2．1　简单实时画像 130
8．2．2　实时画像优化 131
8．2．3　实时画像的毫秒级更新 133
8．3　其他场景画像 135
8．4　画像的兴趣度模型构建 136
8．5　外部画像融合经验分享 138
8．6　交互式查询和分析用户画像 142
8．7　实时产品和店铺信息更新 143
第9章　大数据应用案例 145
9．1　实时DAU计算 145
9．2　实时个性化推荐 150
9．2．1　推荐系统介绍 150
9．2．2　实时推荐系统的方法 153
9．2．3　基于Storm的实时推荐系统 156
9．3　广告投放的精准化 158
9．3．1　点击率预测 158
9．3．2　搜索引擎营销 161
9．3．3　精准化营销与千人千面 161
9．4　实时意图和搜索 164
9．4．1　用户意图预测 165
9．4．2　搜索比价 167
9．4．3　搜索排序 168
第10章　Storm使用经验和性能优化 171
10．1　使用经验 171
10．1．1　使用rebalance命令动态调整并发度 171
10．1．2　使用tick消息做定时器 172
10．1．3　使用组件的并行度代替线程池 174
10．1．4　不要用DRPC批量处理大数据 174
10．1．5　不要在Spout中处理耗时的操作 174
10．1．6　log4j的使用技巧 175
10．1．7　注意fieldsGrouping的数据均衡性 176
10．1．8　优先使用localOrShuffleGrouping 176
10．1．9　设置合理的MaxSpoutPending值 177
10．1．10　设置合理的Worker数 177
10．1．11　平衡吞吐量和时效性 178
10．2　性能优化 179
10．2．1　找到Topology的性能瓶颈 179
10．2．2　GC参数优化 181
10．3　性能优化原则 181
附录A　Kafka原理 183
附录B　将Storm源码导入Eclipse 191
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Storm技术内幕与大数据实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>从零开始学Storm
第1章  Storm简介
1.1  什么是Storm
1.2  Storm的诞生
1.2.1  从Twitter说起
1.2.2  Twitter需要处理大批实时性要求高的大数据业务
1.2.3  Storm帮助Twitter解决实时海量大数据处理问题
1.3  Storm的成长
1.3.1  Storm正式开源
1.3.2  Storm的核心技术和基本组成
1.3.3  Storm的项目小组
1.3.4  Storm的技术支持网站
1.4  Storm的优势
1.4.1  集成多种技术
1.4.2  简单的API
1.4.3  可扩展的
1.4.4  容错的
1.4.5  保证数据处理
1.4.6  可以使用任何语言
1.4.7  部署和操作简单
1.4.8  自由开源
1.5  Storm的应用现状和发展趋势
1.5.1  应用现状
1.5.2  发展趋势
1.6  如何学习Storm
1.7  本书的章节安排及学习建议
1.7.1  本书的章节安排
1.7.2  关于如何阅读本书的建议
1.8  本章小结
第2章  Storm的基本知识
2.1  概念
2.1.1  元组（Tuple）
2.1.2  流（Stream）
2.1.3  喷口（Spout）
2.1.4  螺栓（Bolt）
2.1.5  拓扑（Topology）
2.1.6  主控节点与工作节点
2.1.7  Nimbus进程与Supervisor进程
2.1.8  流分组（Stream grouping）
2.1.9  工作进程（Worker）
2.1.10  任务（Task）
2.1.11  执行器（Executor）
2.1.12  可靠性（Reliability）
2.2  Storm的配置
2.2.1  Storm的配置类型
2.2.2  defaults.yaml文件
2.2.3  storm.yaml文件
2.2.4  Config类
2.3  序列化（Serialization）
2.3.1  动态类型
2.3.2  自定义序列化
2.3.3  Java序列化
2.3.4  特定组件序列化注册
2.4  容错机制
2.4.1  Worker进程死亡
2.4.2  节点死亡
2.4.3  Nimbus或者Supervisor守护进程死亡
2.4.4  Nimbus是否是“单点故障”的
2.5  可靠性机制——保证消息处理
2.5.1  消息被“完全处理”的含义
2.5.2  如果一个消息被完全处理或完全处理失败会发生什么
2.5.3  Storm如何保证可靠性
2.5.4  Storm如何实现可靠性
2.5.5  调节可靠性
2.6  消息传输机制
2.6.1  ZeroMQ
2.6.2  Netty
2.6.3  自定义消息通信机制
2.7  Storm的开发环境与生产环境
2.7.1  开发环境与本地模式
2.7.2  生产环境与远程模式
2.7.3  开发环境与生产环境的对比
2.8  Storm拓扑的并行度（parallelism）
2.8.1  工作进程、执行器和任务
2.8.2  配置拓扑的并行度
2.8.3  拓扑示例
2.8.4  如何改变运行中拓扑的并行度
2.9  Storm命令行客户端
2.10  Javadoc文档
2.11  本章小结
第3章  拓扑详解
3.1  什么是拓扑
3.2  TopologyBuilder
3.3  流分组
3.3.1  什么是流分组
3.3.2  不同的流分组方式
3.4  一个简单的拓扑
3.5  在本地模式下运行拓扑
3.6  在生产集群上运行拓扑
3.6.1  常见的配置
3.6.2  杀死拓扑
3.6.3  更新运行中的拓扑
3.6.4  监控拓扑
3.7  拓扑的常见模式
3.7.1  流连接（Stream Join）
3.7.2  批处理（Batching）
3.7.3  BasicBolt
3.7.4  内存中缓存与字段的组合
3.7.5  流的top N
3.7.6  高效保存最近更新缓存对象的TimeCacheMap（已弃用）
3.7.7  分布式RPC的CoordinatedBolt与KeyedFairBolt
3.8  本地模式与StormSubmitter的对比
3.9  多语言协议（Multi-Language Protocol）
3.10  使用非JVM语言操作Storm
3.10.1  支持的非Java语言
3.10.2  对Storm使用非Java语言
3.10.3  实现非Java DSL的笔记
3.11  Hook
3.12  本章小结
第4章  组件详解
4.1  基本接口
4.1.1  IComponent接口
4.1.2  ISpout接口
4.1.3  IBolt接口
4.1.4  IRichSpout与IRichBolt接口
4.1.5  IBasicBolt接口
4.1.6  IStateSpout与IRichStateSpout接口
4.2  基本抽象类
4.2.1  BaseComponent抽象类
4.2.2  BaseRichSpout抽象类
4.2.3  BaseRichBolt抽象类
4.2.4  BaseBasicBolt抽象类
4.3  事务接口
4.3.1  IPartitionedTransactionalSpout
4.3.2  IOpaquePartitionedTransactionalSpout
4.3.3  ITransactionalSpout
4.3.4  ICommitterTransactionalSpout
4.3.5  IBatchBolt
4.4  组件之间的相互关系
4.5  本章小结
第5章  Spout详解
5.1  可靠的与不可靠的消息
5.2  Spout获取数据的方式
5.2.1  直接连接（Direct Connection）
5.2.2  消息队列（Enqueued Messages）
5.2.3  DRPC（分布式RPC）
5.3  常用的Spout
5.3.1  Kestrel作为Spout的数据源
5.3.2  AMQP作为Spout的数据源
5.3.3  JMS作为Spout的数据源
5.3.4  Redis作为Spout的数据源
5.3.5  beanstalkd作为Spout的数据源
5.4  学习编写Spout类
5.5  本章小结
第6章  Bolt详解
6.1  Bolt概述
6.2  可靠的与不可靠的Bolt
6.2.1  使用Anchoring机制实现可靠的Bolt
6.2.2  使用IBasicBolt接口实现自动确认
6.3  复合流与复合Anchoring
6.3.1  复合流
6.3.2  复合Anchoring
6.4  使用其他语言定义Bolt
6.5  学习编写Bolt类
6.5.1  可靠的Bolt
6.5.2  不可靠的Bolt
6.6  本章小结
第7章  ZooKeeper详解
7.1  ZooKeeper简介
7.2  ZooKeeper的下载和部署
7.2.1  ZooKeeper的下载
7.2.2  ZooKeeper的部署
7.3  ZooKeeper的配置
7.4  ZooKeeper的运行
7.5  ZooKeeper的本地模式实例
7.6  ZooKeeper的数据模型
7.6.1  ZNode
7.6.2  ZooKeeper中的时间
7.6.3  ZooKeeper的Stat结构
7.7  ZooKeeper的命令行操作范例
7.8  Storm在ZooKeeper中的目录结构
7.9  本章小结
第8章  基础软件的安装与使用
8.1  Linux的基本操作
8.1.1  环境变量
8.1.2  常用命令
8.2  JDK的下载与配置
8.2.1  Sun JDK的下载
8.2.2  在Linux下安装JDK
8.2.3  在Windows下安装JDK
8.3  GitHub托管项目的下载
8.4  Maven的下载与配置
8.4.1  Maven的下载
8.4.2  在Linux下部署Maven
8.4.3  在Windows下部署Maven
8.5  其他软件——Notepad++
8.6  本章小结
第9章  Storm的安装与配置
9.1  Storm集群的安装步骤与准备工作
9.1.1  搭建ZooKeeper集群
9.1.2  安装Storm的本地依赖
9.1.3  下载并解压Storm发行版本
9.1.4  配置storm.yaml文件
9.1.5  启动Storm的守护进程
9.2  本地模式的Storm完整的配置命令
9.3  本章小结
第10章  Storm集群搭建实践
10.1  准备工作
10.1.1  概述
10.1.2  配置hosts文件
10.1.3  配置静态IP
10.1.4  集群SSH无密码
10.1.5  修改主机名
10.1.6  关闭防火墙
10.1.7  同步时间
10.1.8  安装JDK
10.2  ZooKeeper集群的搭建
10.2.1  部署第一个节点
10.2.2  部署第i个节点
10.2.3  启动ZooKeeper集群
10.2.4  查看ZooKeeper状态
10.2.5  关闭ZooKeeper集群
10.2.6  清理ZooKeeper集群
10.3  Storm集群的搭建
10.3.1  安装Storm依赖（每个Storm节点）
10.3.2  部署第一个节点
10.3.3  部署第i个节点
10.3.4  启动Storm守护进程
10.4  本章小结
第11章  准备Storm的开发环境
11.1  Storm的开发环境
11.1.1  什么是Storm的开发环境
11.1.2  如何管理Storm
11.1.3  如何提交拓扑到集群
11.2  Eclipse的下载与配置
11.2.1  Eclipse的下载
11.2.2  Eclipse的配置与运行
11.2.3  Eclipse插件的安装
11.3  使用Maven管理项目
11.3.1  Maven的下载与配置
11.3.2  配置pom.xml文件
11.3.3  运行Maven命令
11.4  使用Nexus搭建本地Maven私服
11.4.1  下载Nexus
11.4.2  运行Nexus
11.4.3  登录Nexus后台
11.4.4  配置Repositories
11.4.5  配置setting.xml文件
11.4.6  修改Eclipse的Maven插件的配置
11.5  使用SVN管理代码版本
11.5.1  在Windows下搭建SVN服务器
11.5.2  在Linux下搭建SVN服务器
11.5.3  安装SVN客户端
11.6  部署单节点的Storm集群
11.6.1  部署伪分布的ZooKeeper
11.6.2  部署伪分布的Storm集群
11.7  本章小结
第12章  开发自己的Storm应用
12.1  新建Maven项目
12.2  修改为适合Storm开发的项目
12.2.1  对包名进行分类管理
12.2.2  修改pom.xml文件
12.3  编写代码
12.3.1  编写Spout类
12.3.2  编写Bolt类
12.3.3  编写Topology类
12.4  本地测试运行
12.5  提交到Storm集群运行
12.5.1  使用Maven打包
12.5.2  提交jar包到集群
12.6  本章小结
第13章  storm-starter详解
13.1  storm-starter项目概述
13.2  storm-starter的下载
13.3  使用Maven进行管理
13.3.1  使用Maven打包storm-starter
13.3.2  使用Maven直接运行WordCountTopology
13.3.3  使用Maven运行单元测试
13.4  在Eclipse中运行
13.4.1  新建Maven项目的方式
13.4.2  导入已存在的项目的方式
13.5  storm-starter的入门例子
13.5.1  ExclamationTopology
13.5.2  WordCountTopology
13.5.3  ReachTopology
13.6  storm-starter的其他例子
13.6.1  BasicDRPCTopology
13.6.2  ManualDRPC
13.6.3  PrintSampleStream
13.6.4  RollingTopWords
13.6.5  SingleJoinExample
13.6.6  TransactionalGlobalCount
13.6.7  TransactionalWords
13.7  本章小结
第14章  研发与集群管理技巧
14.1  使用daemontools监控Storm进程
14.1.1  daemontools简介
14.1.2  安装daemontools
14.1.3  编写监控脚本
14.2  使用Monit监控Storm
14.2.1  Monit简介
14.2.2  安装Monit
14.2.3  配置Monit
14.2.4  启动Monit
14.2.5  获取Monit帮助信息
14.3  常用的集群操作命令
14.4  使用Storm的经验与建议
14.5  本章小结
第15章  DRPC详解
15.1  概述
15.2  DRPCTopologyBuilder
15.2.1  LinearDRPCTopologyBuilder
15.2.2  LinearDRPCTopologyBuilder提供的方法
15.2.3  LinearDRPCTopologyBuilder使用范例
15.2.4  LinearDRPCTopologyBuilder的工作原理
15.2.5  LinearDRPCTopologyBuilder目前已弃用
15.3  本地模式的DRPC
15.4  远程模式的DRPC
15.5  一个复杂的DRPC例子（计算reach值）
15.6  非线性DRPC
15.7  本章小结
第16章  事务拓扑详解
16.1  什么是事务拓扑
16.1.1  设计1
16.1.2  设计2
16.1.3  设计3（Storm的设计)
16.2  事务拓扑的设计细节
16.3  事务拓扑的实现细节
16.3.1  事务Spout的工作原理	262
16.3.2  “对于给定的事务id不能发射相同的Batch”的处理
16.3.3  更多的细节
16.4  事务拓扑API
16.4.1  Bolt
16.4.2  事务Spout
16.4.3  配置
16.5  TransactionalTopologyBuilder
16.5.1  TransactionalTopologyBuilder提供的方法
16.5.2  TransactionalTopologyBuilder类已弃用
16.6  一个简单的例子
16.7  本章小结
第17章  Trident详解
17.1  Trident概述
17.1.1  简单的例子——单词统计（TridentWordCount）
17.1.2  另一个例子——计算Reach值（TridentReach）
17.1.3  字段和元组
17.1.4  状态（State）
17.1.5  Trident拓扑的执行
17.2  Trident API
17.2.1  概述
17.2.2  本地分区操作
17.2.3  重新分区操作
17.2.4  聚合操作
17.2.5  流分组操作
17.2.6  合并与连接
17.3  Trident的状态
17.3.1  Trident状态分类
17.3.2  事务Spout（Transactional Spout）
17.3.3  不透明事务Spout（Opaque Transactional Spout）
17.3.4  非事务Spout（Non-transactional Spout）
17.3.5  Spout与State之间的联系
17.3.6  State API
17.3.7  persistentAggregate方法
17.3.8  实现 MapStates
17.4  Trident Spout
17.4.1  流水线（Pipelining）
17.4.2  Trident Spout的类型
17.5  本章小结
第18章  Storm的内部实现
18.1  文件系统分析
18.2  数据目录结构
18.2.1  Nimbus节点的目录结构
18.2.2  Supervisor节点的目录结构
18.3  代码库的结构
18.3.1  storm.thrift
18.3.2  Java接口
18.3.3  实现
18.4  拓扑的生命周期
18.4.1  启动拓扑
18.4.2  监控拓扑
18.4.3  杀死拓扑
18.5  Acking框架的实现
18.5.1  异或计算的基本原理
18.5.2  Acking框架的实现原理
18.5.3  Acker的execute方法
18.5.4  待定元组（pending tuple）和RotatingMap
18.6  Metric
18.7  本章小结
第19章  Storm相关的其他项目
19.1  JStorm项目
19.1.1  项目简介
19.1.2  下载与部署
19.1.3  源代码编译
19.2  storm-deploy项目
19.3  Storm与Kafka
19.3.1  Kafka简介
19.3.2  Kafka的安装
19.3.3  启动服务
19.3.4  测试运行
19.3.5  Storm与Kafka的项目
19.4  storm-kestrel项目	334
19.4.1  storm-kestrel项目简介
19.4.2  使用storm-kestrel项目
19.4.3  Kestrel服务器和队列
19.4.4  添加元素到kestrel
19.4.5  从Kestrel中移除元素
19.4.6  持续添加元素到Kestrel
19.4.7  使用KestrelSpout
19.4.8  执行
19.5  本章小结
第20章  企业应用案例
20.1  Storm席卷众多互联网企业
20.1.1  Storm的典型应用场景
20.1.2  Storm的三大基本应用
20.2  Storm在Twitter中的应用
20.2.1  Twitter公司简介
20.2.2  Storm帮助Twitter提升产品性能
20.2.3  MapR在Twitter中的应用简介
20.3  Storm在阿里巴巴集团的应用
20.3.1  阿里巴巴集团简介
20.3.2  Storm在阿里巴巴的应用
20.3.3  Storm在淘宝公司的应用
20.3.4  Storm在支付宝公司的应用
20.4  其他应用Storm的知名企业和项目
20.5  本章小结
参考资料
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>从零开始学Storm
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Storm企业级应用：实战、运维和调优
前　言
基　础　篇
第1章　认识Storm  2
1.1　什么是实时流计算  2
1.1.1　实时流计算背景  3
1.1.2　实时计算应用场景  3
1.1.3　实时计算处理流程  4
1.1.4　实时计算框架  5
1.2　Storm是什么  11
1.2.1　Storm出现的背景  12
1.2.2　Storm简介  12
1.2.3　Storm的设计思想  13
1.2.4　Storm与Hadoop的角色和组件比较  14
1.3　Storm核心组件  15
1.3.1　主节点Nimbus  15
1.3.2　工作节点Supervisor  15
1.3.3　协调服务组件ZooKeeper  16
1.3.4　其他核心组件  16
1.4　Storm的特性  16
1.5　Storm的功能  18
1.6　本章小结  19
第2章　开始使用Storm  20
2.1　环境准备  20
2.1.1　系统配置  20
2.1.2　安装ZooKeeper集群  22
2.2　启动模式  26
2.2.1　本地模式  26
2.2.2　分布式模式  26
2.3　安装部署Storm集群  26
2.3.1　安装Storm依赖库  27
2.3.2　安装Storm集群  28
2.3.3　启动Storm集群  31
2.3.4　停止Storm集群  33
2.4　创建Topology并向集群提交任务  33
2.4.1　创建Topology  34
2.4.2　向集群提交任务  36
2.5　本章小结  36
第3章　核心概念和数据流模型  37
3.1　Tuple元组  37
3.1.1　Tuple描述  37
3.1.2　Tuple的生命周期  38
3.2　Spout数据源  39
3.2.1　Spout介绍  39
3.2.2　Spout实例  40
3.3　Bolt消息处理者  42
3.3.1　Bolt介绍  42
3.3.2　Bolt实例  45
3.4　Topology拓扑  47
3.4.1　Topology实例  48
3.4.2　Topology运行  51
3.5　Stream消息流和Stream Grouping消息流组  55
3.5.1　Stream消息流  55
3.5.2　Stream Grouping消息流组  55
3.6　Task任务  56
3.7　Worker工作者进程  56
3.8　Worker、Task、Executor三者之间的关系  57
3.9　事务  57
3.10　数据流模型  58
3.10.1　数据流模型简介  58
3.10.2　Storm数据流模型  60
3.11　本章小结  61
实　战　篇
第4章　实例1：移动互联——语音“实时墙”  64
4.1　业务背景  64
4.1.1　案例背景  64
4.1.2　设计目标  65
4.1.3　数据格式  66
4.1.4　硬件配置  68
4.2　系统架构与模块设计  68
4.2.1　整体架构  69
4.2.2　数据采集  70
4.2.3　数据实时处理  70
4.2.4　存储设计  70
4.2.5　Web实时展示  71
4.2.6　硬件部署图  72
4.3　核心模块实现  73
4.3.1　实时处理业务逻辑实现  73
4.3.2　Web展示实现  80
4.3.3　最终效果呈现  88
4.4　本章小结  89
第5章　实例2：运营商——网络流量流向实时分析  90
5.1　业务背景  90
5.1.1　案例背景  91
5.1.2　设计目标  91
5.1.3　数据规模预估  92
5.1.4　数据格式  92
5.1.5　统计分析需求  93
5.2　系统架构与模块设计  94
5.2.1　整体架构  94
5.2.2　数据源  95
5.2.3　日志采集  96
5.2.4　数据存储  96
5.2.5　数据处理  97
5.2.6　目标存储和扩展服务  97
5.2.7　结果Web展示  97
5.3　核心模块实现  98
5.3.1　模拟数据实现  98
5.3.2　日志采集和存储实现  102
5.3.3　数据处理实现  105
5.3.4　Web展示实现  111
5.4　本章小结  114
第6章　实例3：交通——基于GPS的实时路况分析  115
6.1　业务背景  115
6.1.1　案例背景  115
6.1.2　设计目标  116
6.1.3　数据格式  118
6.1.4　实时路况分析方法  118
6.2　系统架构和模块设计  118
6.3　核心模块的实现  121
6.3.1　安装Kafka集群  121
6.3.2　Flume整合Kafka  124
6.3.3　实时处理数据  125
6.3.4　Web页面展示  127
6.4　本章小结  129
第7章　实例4：互联网——数据质量实时监控  130
7.1　业务背景  130
7.1.1　案例背景  130
7.1.2　设计目标  132
7.1.3　数据格式  132
7.2　系统架构与模块设计  133
7.2.1　整体架构  133
7.2.2　结果Web展示  135
7.3　核心模块实现  135
7.3.1　模拟数据  135
7.3.2　实时处理业务逻辑的实现  141
7.3.3　Web界面实现  147
7.3.4　最终效果图  150
7.4　本章小结  152
第8章　实例5：交通——超速频发路段监控  153
8.1　业务背景  153
8.1.1　案例背景  153
8.1.2　数据类型  155
8.2　系统架构和模块设计  157
8.3　核心模块实现  158
8.3.1　实现入口类Main  158
8.3.2　数据源SocketSpout的实现  159
8.3.3　实时处理MapSearchBolt和SpeedProcessBolt的实现  161
8.3.4　目标存储DataBaseLoadBolt的实现  169
8.4　本章小结  171
第9章　实例6：互联网——广告实时流量统计  172
9.1　广告实时流量统计系统架构  172
9.1.1　广告数据  172
9.1.2　详细需求描述  174
9.1.3　系统架构  175
9.2　表结构与模块设计  177
9.2.1　表结构设计  177
9.2.2　功能模块设计  178
9.3　核心模块实现  179
9.3.1　部署物理集群环境  179
9.3.2　Kafka生产者逻辑的实现  181
9.3.3　使用Storm-kafka实现业务逻辑  182
9.3.4　使用HBase存储并实现统计  193
9.4　本章小结  194
技　巧　篇
第10章　Storm常见故障及解决方法  196
10.1　安装部署故障  196
10.1.1　“no jzmq in java.library.path”异常  196
10.1.2　“No rule to make target”异常  198
10.1.3　“cannot access org.zeromq.ZMQ”异常  198
10.1.4　缺少pkg-conf?ig异常  198
10.1.5　“java.lang.Unsatisf?iedLinkError”异常  199
10.1.6　“java.lang.NoClassDefFoundError：clojure.core.protocols$”异常  199
10.1.7　“Error：cannot link with -luuid，install uuid-dev”异常  199
10.1.8　“bad interpreter：No such f?ile or directory”异常  200
10.1.9　“org.zeromq.ZMQException：Invalid argument”异常  200
10.2　启动故障  201
10.2.1　“java.io.FileNotFoundException”异常  201
10.2.2　“java.io.EOFException”异常  202
10.3　运行时故障  202
10.3.1　“Nimbus host is not set”异常  203
10.3.2　“AlreadyAliveException（msg：xxx is alreadyactive）”异常  203
10.3.3　无法序列化log4j.Logger异常  203
10.3.4　“Failing message”异常  203
10.3.5　“java.io.NotSerializableException”异常  204
10.3.6　“java.lang.NoClassDefFoundError”异常  205
10.3.7　“java.net.NoRouteToHostException”异常  206
10.3.8　“java.net.UnknownHostException”异常  206
10.3.9　重复defaults.yaml资源文件异常  207
10.3.10　“KeeperException$NoNodeException”异常  208
10.3.11　“A fatal error has been detected by the Java Runtime Environment”错误  209
10.3.12　“java.lang.ArrayIndexOutOfBoundsException”异常  212
10.3.13　DRPC空指针异常  212
10.3.14　Storm Thrift读取数据报错  212
10.4　本章小结  214
第11章　Storm使用技巧和最佳实践  215
11.1　核心组件使用要点  215
11.1.1　Spout和Bolt  215
11.1.2　ZooKeeper集群尽量独立  219
11.1.3　Thrift服务的应用场景  220
11.1.4　序列化机制的使用场景  220
11.2　集群配置技巧  220
11.2.1　默认参数配置  220
11.2.2　日志信息  223
11.2.3　合理配置JVM参数  223
11.3　集群运维技巧  224
11.3.1　Storm计算结果的存储位置  224
11.3.2　Storm集群动态增删节点  224
11.3.3　关闭Storm相关进程  224
11.3.4　Storm UI显示内容的问题  224
11.4　项目开发技巧  225
11.4.1　使用assembly插件打包  225
11.4.2　依赖JAR冲突  228
11.5　保证消息的可靠处理  228
11.5.1　消息失败后的处理  228
11.5.2　主动干预可靠性  229
11.5.3　处理重复的Tuple  229
11.6　理解DRPC原语  230
11.6.1　DRPC工作流  230
11.6.2　LinearDRPCTopologyBuilder实现类  231
11.6.3　DRPC的两种模式  231
11.7　快速理解一致性事务  232
11.7.1　Trident框架的使用  233
11.7.2　Trident框架的细节  234
11.7.3　事务性Spout  236
11.7.4　状态State  238
11.8　本章小结  241
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Storm企业级应用：实战、运维和调优
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>风暴眼
中译序：还神殿以平常任东来
图片与图表说明
前言
致谢
第一章 争夺权力
堕胎、最高法院与美国政治
不再是“最少危险的”部门
第二章 法袍崇拜
举贤神话
任命过程
政治权衡
填塞最高法院
大法官
背叛总统
大法官的非司法性活动
大法官的独立性与可问责性
第三章 大理石神殿内的生活
大理石神殿建成以前
大理石神殿内
大法官及其团队——九个小法律事务所
行政人员与政治斗争
控制案件数量
第四章 决定判决哪些案件
通往正义之路
设定议程
政策制定的议程——谁得益，谁受损？
拒绝重审就与正义无缘？
第五章 判决案件与撰写司法意见
庭辩的作用
案情讨论会
司法意见的写作过程
司法意见书的价值
机构意见与个人意见
第六章 最高法院与美国生活
公布判决的日子
向媒体通报判决
实施判决与获得遵从
最高法院与美国生活
美国最高法院成员任职表
术语表
原始资料来源简称
进一步阅读
译名索引
后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>风暴眼
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>胡風
第一章 眼中天地久沉昏
第二章 烽火連天創《七月》
第三章 鎖鏈不能屬於我
第四章 延安講話和《希望》
第五章 時間真的開始了
第六章 山雨欲來風滿樓
第七章 忍看朋輩成新囚
第八章 弄文罹禍可銷骨
第九章 我花開罷百花殺
第十章 我饑渴勞累困頓
第十一章 無端狂笑無端哭
第十二章 見我鬚髮醉嵯峨
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>胡風
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>东方风暴
译前言
第一章  国家诞生
鞑靼的怒火
马上牧人
早期游牧帝国
秘史
铁木真的崛起
新蒙古
第二章  从中国到里海
立法者
军队的新生
对外扩张
征服金人
神之惩罚
蒙古怒火下的逃亡者
最后复仇
第三章  承诺实现
可怕的王者
黄金家族
窝阔台大汗
广泛影响：耶律楚材
游牧民的都城
向西亚扩张
进攻欧洲
第四章  进攻欧洲
预备进攻
两支军队，两种战争
进入俄罗斯
蒙古的对手
横扫波兰和匈牙利
欧洲骑士的毁灭
进入大西洋的大门
第五章  从长老约翰到末日决战
文明的外来者
长老约翰的传说
教皇与皇帝的斗争
被忽视的讯息
欧洲的惊恐和混乱
蒙古继承权的争夺
侦察西方战场
大汗之死
第六章  出使鞑靼
教皇的使者
拔都汗的觐见者
哈剌和林的新大汗
一位方济各会士眼中的蒙古社会
欧洲的乐观
蒙古的谎言，欧洲的天真
蒙古都城新的权力斗争
第七章  蒙古远征
蒙古高原上的间谍和传教士
计划中东战争
鲁布鲁克返回欧洲
穿过阿姆河进入波斯
巴格达的毁灭
远征叙利亚
蒙古惩罚波兰
不可想象的胜利联盟
第八章  忽必烈汗和中国
中国影响
汗位继承权之战
改革创新
新大都
征服宋王朝的强大海军
崭新大元的文化繁荣
征日失败
第九章  衰落和灭亡
巨大的贸易网
向欧洲求助
波斯的伊利汗国
自然大灾难和叛乱
金帐汗国
黑死病：来自中亚的“礼物”
莫卧儿帝国
蒙古内部的逐步分裂
大事纪年表
译名对照表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>东方风暴
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实时大数据分析
目 录
第1章 大数据技术前景及分析平台 1
1.1 大数据的概念 1
1.2 大数据的维度范式 2
1.3 大数据生态系统 3
1.4 大数据基础设施 4
1.5 大数据生态系统组件 5
1.5.1 构建业务解决方案 8
1.5.2 数据集处理 8
1.5.3 解决方案实施 8
1.5.4 呈现 9
1.6 分布式批处理 9
1.7 分布式数据库（NoSQL） 13
1.7.1 NoSQL数据库的优势 15
1.7.2 选择NoSQL数据库 16
1.8 实时处理 16
1.8.1 电信或移动通信场景 17
1.8.2 运输和物流 17
1.8.3 互联的车辆 18
1.8.4 金融部门 18
1.9 本章小结 18
第2章 熟悉Storm 19
2.1 Storm概述 19
2.2 Storm的发展 20
2.3 Storm的抽象概念 22
2.3.1 流 22
2.3.2 拓扑 22
2.3.3 Spout 23
2.3.4 Bolt 23
2.3.5 任务 24
2.3.6 工作者 25
2.4 Storm的架构及其组件 25
2.4.1 Zookeeper集群 25
2.4.2 Storm集群 25
2.5 如何以及何时使用Storm 27
2.6 Storm的内部特性 32
2.6.1 Storm的并行性 32
2.6.2 Storm的内部消息处理 34
2.7 本章小结 36
第3章 用Storm处理数据...
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实时大数据分析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>以阿拉之名
地圖
前言
1古老記憶　622-1900
2挺身反抗　1901-1918
3理想幻滅　1919-1939
4解放之路　1940-1956
5分分合合　1957-1967
6神權政治與獨裁政治　1968-2005
結語
資料來源
注解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>以阿拉之名
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>火风暴
柯南·道尔产权会官方特别认可/全景展现福尔摩斯的青少年时代/热销25个国家和地区/已出版35种文字
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>火风暴
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>在風暴來臨之前
導讀（成功大學歷史系教授翁嘉聲）
年表
地圖
作者序
前言　羅馬共和國的勝利
第一章　義大利的野獸
第二章　羅馬的繼子
第三章　羅馬廣場上的匕首
第四章　待價而沽的城市
第五章　戰利品
第六章　金耳環
第七章　馬略的騾子
第八章　羅馬的第三位奠基者
第九章　義大利亞
第十章　迦太基的遺跡
第十一章　釘靴
第十二章　內戰
第十三章　終身獨裁官
謝辭
注釋
古代資料來源
現代資料選讀
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>在風暴來臨之前
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>七支箭
本書目錄
推薦序：轉動生命蛻變的醫藥輪
推薦序：醫藥輪的禮物
前言：來自醫藥輪的教導
譯者序：認識醫藥輪之聖靈的力量
簡介
醫藥輪的創造
醫藥輪的方向
醫藥輪之聖靈冥想卡的解讀
0醫藥輪
1造物者
2大地母親
3太陽父親
4月亮祖母
5海龜族群
6青蛙族群
7雷鳥族群
8蝴蝶族群
9北方（北方守護者）
10東方（東方守護者）
11南方（南方守護者）
12西方（西方守護者）
13自我之石
14祖靈之石
15偉大星辰國度
16大地復原之月
17休眠淨化之月
18強風之月
19樹萌芽之月
20蛙回歸之月
21玉米種植之月
22烈日之月
23採莓之月
24收穫之月
25群鴨飛遷之月
26結凍之月
27長雪之月
28藍月
29淨化（北方靈性道路）
30重建（北方靈性道路）
31純潔（北方靈性道路）
32清晰（東方靈性道路）
33智慧（東方靈性道路）
34天啟（東方靈性道路）
35成長（南方靈性道路）
36信任（南方靈性道路）
37愛（南方靈性道路）
38體驗（西方靈性道路）
39內省（西方靈性道路）
40力量（西方靈性道路）
醫藥輪之聖靈冥想卡牌陣
內在靈圈牌陣
花開牌陣
神聖菸斗牌陣
醫藥輪漩渦牌陣
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>七支箭
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>茵梦湖
001 茵梦湖
049 白马骑士
213 汉斯熊
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>茵梦湖
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>時光之輪12：末日風暴（上）
出版緣起 讓想像飛翔
序言 布蘭登．山德森
譯者序 時光的傳承 李鐳
時間之輪大地圖
主要人物表
0 風暴的含義
1 鋼之淚水
2 痛苦的本質
3 榮譽之道
4 夜幕
5 關於血的故事
6 當鐵融化時
7 關於阿拉多曼的計畫
8 乾淨的襯衫
9 離開梅登
10 最後一點菸草
11 艾德林之死
12 預料之外的遭遇
13 提議與離別
14 一只打開的盒子
15 一個開始的地方
16 白塔之中
17 控制的問題
18 急信
19 策略
20 殘破的路上
21 灰燼
22 最後一件可能做的事
23 空氣中的扭曲
24 新的諾言
25 在黑暗中
名詞解釋
中英名詞對照表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>時光之輪12：末日風暴（上）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>時光之輪12：末日風暴（下）
時間之輪大地圖
主要人物表
26 石頭上的裂縫
27 醉騸馬
28 辛德泰普的夜晚
（班達艾班地圖）
29 進入班達艾班
30 舊日的忠告
31 對路斯．瑟林的承諾
32 闇影的河流
33 與真龍的對話
34 故事
35 黑色光環
36 圖昂之死
37 光的力量
38 特．雅蘭．瑞奧德中的訊息
39 兩儀師維林的拜訪
40 白塔撼動
41 力量的泉源
42 提爾之岩前
43 祕密評議會
44 未知的氣味
45 白塔長存
46 重新鍛造
47 他所遺失的
48 解讀注釋
49 另一個人
50 黃金脈絡
51 在光明中
名詞解釋
中英名詞對照表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>時光之輪12：末日風暴（下）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>My Descent Into Death
目录
幽灵的地狱之邀
被耶稣基督救出地狱
爱的治疗，启迪开悟
了解死后发生的事
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>My Descent Into Death
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>系統取向督導完全指南
作者簡介
譯者卅審閱者簡介
推薦序一：專為督導者量身訂製的指南卅吳熙琄
推薦序二：成為受督者的角色模範卅熊秉荃
前言
第一章 督導的基本綱領與實務集錦卅史東＆陶德
第一部	督導情境
第二章	倫理議題：如何拿捏分寸？卅霍格＆史東
第三章	在華人文化中進行具文化敏感度的督導卅郭＆史東
第四章	學術象牙塔與訓練機構：教育性課程中的督導卅史東＆史班可
第五章	社會服務機構中的系統取向臨床督導卅基莫＆庫克
第六章	私人合約的督導卅陶德
第二部 治療哲學理念
第七章	自我督導是督導的共同目標卅 陶德
第八章	以精神分析法督導系統性治療卅雷納
第九章	督導：跨世代模式卅羅貝托－佛曼
第十章	純粹系統性督導模式卅陶德
第十一章 擴展督導的焦點：整合模式的共同主軸卅瑞嘉齊歐－迪吉利歐
第十二章 系統觀督導的後現代模式卅波貝拉＆碧芙
第三部 督導關係
第十三章 合作式督導：留意權力問題卅范恩＆透納
第十四章 督導過程中所遭遇的困難：受督導者的觀點卅陶德
第四部 實務操作
第十五章 督導關係的藍圖：合約 卅史東
第十六章 經典、歷久彌新的督導方法：有關選擇與整合的準則卅史東
第十七章 把關：契合度評估卅史東
第五部 督導者的訓練
第十八章 發展督導能力與指導準督導卅史東, 陶德＆麥道薇
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>系統取向督導完全指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>用正念擁抱恐懼
前言：無懼
1. 許久以前
‧修習：與內在小孩對話
2. 原始恐懼
‧不要害怕過去 ‧計畫未來，無有恐懼
3. 與過去和好
‧修習：接納祖先
4. 釋放對未來的恐懼――五憶念
‧我會衰老，我無法避免衰老 ‧我會生病，我無法避免生病
‧我會死亡，我無法避免死亡 ‧我所珍愛的一切、我所愛的人都會改變。我無法避免要捨棄這一切 ‧我所繼承的，是自己身語意行為的結果。我的行為，就是我的延續 ‧以正念擁抱恐懼的種子
5. 無來無去
‧此刻再沒有恐懼 ‧藏在田裡的寶物 ‧此時此地
‧實相的兩個面向 ‧不生不滅的本性 ‧無來無去 ‧無常
‧欣賞我們之所在 ‧尋找堅實的基礎 ‧修習：回到當下，體驗呼吸
6. 送給你的禮物――無畏
‧毒素 ‧相即的本質 ‧給孤獨長者的事跡
7. 正念的力量
‧培養正念能量 ‧把正念帶在身邊
8. 學習止
‧禪悅為食 ‧身心一體
9. 風暴中的平靜
‧恐懼到訪 ‧腹式呼吸 ‧安全度過風暴 ‧情緒就只是情緒
10. 轉化周遭的恐懼
‧對恐怖主義的恐懼 ‧慈悲起革命 ‧恐怖主義的種子
‧慈悲傾聽 ‧心是橋樑 ‧重建溝通
11. 雲上的藍天
‧團體好比我們的身體 ‧溝通帶來安全
12. 轉化恐懼為愛：四句真言
‧真言：我為你而在 ‧真言：覺知愛人的存在 ‧真言：止息痛苦
‧真言：請求幫助 ‧從自己開始
13. 恐懼的另一面
‧諦聽和愛語 ‧與僧團一起行走 ‧集體正念能量
‧佛陀的僧團 ‧建設僧團
14. 轉化恐懼的修習
‧釋放身心恐懼的八項正念修習 ‧八個呼吸練習：轉化心中恐懼之源
‧放鬆禪：轉化恐懼和壓力 ‧慈心禪：讓我們遠離恐懼
‧五項正念修習 ‧五種覺察
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>用正念擁抱恐懼
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>與人對話01
第一部 終結恐懼，展開生命的探險
對話1 我們能談談嗎？
對話2 有關原因及時間的答覆
對話3 我們肯定知道的一件事
對話4 首先必須改變的信念
對話5 人類最勇敢的作為
對話6 這也關乎你的進化
對話7 極少人願意回答的問題
對話8 難道你不覺得人應該討論它嗎？
對話9 你與人類應有的全新優先順序
對話10 問題一：我個人的想法
對話11 問題二：我個人的想法
對話12 問題三：我個人的想法
對話13 問題四：我個人的想法
對話14 問題五、問題六、問題七：我個人的想法
對話15 「噢，我親愛的克蕾蒙提娜……」
第二部 送舊迎新
對話16 當前令人難以置信的文化內涵
對話17 只要推倒第一個骨牌
對話18 形態場域、臨界點及臨界人數
對話19 嶄新的日子，全新的內涵
對話20 你能相信我們所相信的嗎？
對話21 你能相信只要選擇就可相信的事嗎？
對話22 改變世界的神秘「第三元」
對話23 全然轉變我們「處理生命」的方式？
對話24 當遊戲規則不公平時
對話25 我們已經無法再做什麼
對話26 我們真的有想過這些嗎？
對話27 把靈魂帶進生活：過程與方法
對話28 最關鍵的一點
跋 來自神的邀約
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>與人對話01
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>氣候變遷的關鍵報告
【推薦序】氣候變遷是生活，不是統計　∕徐光蓉
【推薦序】是科學，還是商業？　∕柳中明
【推薦序】你看到的事實，不等於真相　∕汪中和
【推薦序】不要讓節能減碳淪為口號　∕沈世宏
【推薦序】科學家其實沒有標準答案　∕陳瑞賓
【導言】讓人人都了解真相
關於本書的撰寫者與審訂者
第一章 別只聽媒體的，要聽科學家怎麼說
1. 地球曾經全是冰，也曾都沒冰
2. 代理證物：從結凍氣泡到年輪、珊瑚
3. 我們會存活，但過程不一定舒適
4. 氣候變遷都是人類導致的嗎？
5. 地球穿上了發熱衣：二氧化碳
6. 科學家說「氣候變遷」，而非「全球暖化」
7. 「天氣」與「氣候」，相似卻不相同
8. 金星的脫韁溫室效應，會在地球上演嗎？
9. 二氧化碳是元凶，誰是幫凶？
10. 工業革命不只推升經濟，還有溫度
11. 臭氧層破洞與全球暖化，兩者無關
12. 近半世紀，北半球溫度快速上升
13. 燃煤，是主要的碳排放來源
14. 人類造成二氧化碳含量暴增二五％
15. 砍樹、農耕、水泥業，碳排放幫凶
16. 暖化，人類做了些不好事情的證據
17. 大自然要幾千年才能全部吸收
18. 海洋酸化，可能再也吃不到海鮮
19. 地球的肺，每年面積減少六個台灣大
20. 地球暖化的速度，將不只加快兩倍
21. 二氧化碳多一倍，地球可能熱三度
22. 冰原全融，海平面上升二十層樓高
23. 地球在暖化，但未必一年比一年熱
24. 全球暖化，但有些地方反而變冷
25. 比大自然更可怕的力量──人類
第二章 現今的地球，正在發生什麼事？
26. 大氣二氧化碳含量，增加了三○％
27. 海平面每年上升○．三公分，加速中
28. ○．七二度，地球從一九七九年開始發燒
29. 高溫天數是低溫天數的兩倍，或五十倍
30. 暖化，但有些地方的冰河卻成長
31. 不只海平面上升了，地殼也在下沉
32. 你最熟悉的暖化符號──北極熊怎麼說？
33. 春天提早到，萬物生長節奏亂了調
34. 樹皮甲蟲啃光了白雲杉林
35. 目前的生態系統會瓦解，然後……
36. 北極的冰洋融化，南極的海冰增加
37. 北極放大效應，海冰加快越薄
38. 極端天氣更常發生，「異常」變平常
39. 珊瑚把藻類趕出家門
第三章 未來可能會發生什麼事？
40. 氣候模型不完美，卻已接近實情
41. 還會更熱嗎？碳排放量是關鍵
42. 百年內，海平面將上升二至六英尺
43. 神奇的二一○○年，暖化終止？
44. 颱風數量變少，但威力變大
45. 暴潮：慢速的海嘯
46. 你會成為氣候難民嗎？得看你搬多遠
47. 你意想不到的風險：傳染病大流行
48. 第六次大規模物種滅絕，進行中
49. 引發嚴重水問題，讓你沒水喝
50. 乾旱和沙塵暴越來越頻繁
51. 造成糧食短缺，熱帶國家吃大虧
第四章 我們可以做些什麼改變？
52. 攝氏二度：如何替地球退燒？
53. 乙醇替代石油的時候還沒到
54. 「碳捕集封存」技術，治標或治本？
55. 替代能源，並不能全面替代化石燃料
56. 先讓你荷包大失血，你就會節制碳排放
57. 「無碳」的核能發電，恐怖輻射當鄰居
58. 「地球工程」：解決問題同時製造問題
59. 幫動植物搬家，仍會有物種滅絕
60. 減少碳排放量，人人有責付錢
【結語】關於「政府間氣候變遷委員會」（IPCC）
外部審訂者名單
參考資料
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>氣候變遷的關鍵報告
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>社会工作直接实践
目录
前言
第一篇介绍
第一章社会工作的挑战
第二章直接实践：领域、哲理和角色
第三章助人过程
第四章社会工作的核心价值观
第二篇探索、评估和计划
第五章沟通的基石：同理与真诚
第六章对话的跟进、探索和聚焦技巧
第七章消除反效果的沟通模式
第八章评估：探索并理解问题和优势
第九章评估：个人因素与环境因素
第十章评估家庭功能：多元的家庭和文化背景
第十一章小组的形成与评估
第十二章协商目标与形成协议
第三篇改变取向的阶段
第十三章计划并执行改变取向的策略
第十四章干预策略：发展资源、计划和倡导
第十五章改善家庭关系
第十六章社会工作小组干预
第十七章附加的同理心、解析与面质
第十八章处理改变的障碍
第四篇最后阶段
第十九章最后阶段：评估与结案
参考文献
译后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>社会工作直接实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>雪中血
引 子 上海1937
第一部 南京
第一章 幕启
第二章 埼玉县的武士
第三章 防空洞
第四章 青龙之战
第五章 江匪
第六章 慰安所
第七章 战还是走？
第八章 大战前夕
第九章 风和雨
第二部 大屠杀
第一章 醒来
第二章 江心洲
第三章 地狱里的圣诞节
第四章 赎罪
尾 声 黄山1938
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>雪中血
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>聖經信息系列--約拿書
1.　約拿書的文學體裁
2.　抗命的先知（一1-3）
3.　海上暴風（一4-8）
4.　先知告白（一9-16）
5.　生或死？（一17-二10）
6.　約拿呼求耶和華（二1-10）
7.　貫徹始終的神（三1-10）
8.　先知之怒與神的憐憫（四1-11）
9.　尼尼微的悔改與神的子民

附錄
約拿生平概略與年代表
約拿書相關地圖
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>聖經信息系列--約拿書
