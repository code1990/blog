>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala函数式编程
原推荐序
序言
致谢
关于本书
函数式编程介绍
1什么是函数式编程
1．1 函数式编程的好处：一个简单的例子
1．1．1 一段带有副作用的程序
1．1．2 函数式的解法：去除副作用
1．2 （纯）函数究竟是什么
1．3 引用透明、纯粹度以及替代模型
1．4 小结
2在Scala中使用函数式编程
2．1 Scala语言介绍：
2．2 运行程序
2．3 模块、对象和命名空间
2．4 高阶函数：把函数传给函数
2．4．1 迂回做法：使用循环方式
2．4．2 第一个高阶函数
2．5 多态函数：基于类型的抽象
2．5．1 一个多态函数的例子
2．5．2 对高阶函数传入匿名函数
2．6 通过类型来实现多态
2．7 小结
3函数式数据结构
3．1 定义函数式数据结构
3．2 模式匹配
3．3 函数式数据结构中的数据共享
3．3．1 数据共享的效率
3．3．2 改进高阶函数的类型推导
3．4 基于list的递归并泛化为高阶函数
3．4．1 更多与列表相关的函数
3．4．2 用简单组件组合list函数时的效率损失
3．5 树
3．6 小结
4不是用异常来处理错误
4．1 异常的优点与劣势
4．2 异常的其他选择
4．3 Option数据类型
4．3．1 Option的使用模式
4．3．2 Option的组合、提升及对面向异常的API的包装
4．4 Either数据类型
4．5 小结
5严格求值和惰性求值
5．1 严格和非严格函数
5．2 一个扩展例子：惰性列表
5．2．1 对Stream保持记忆，避免重复运算
5．2．2 用于检测Stream的helper函数
5．3 把函数的描述与求值分离
5．4 无限流与共递归
5．5 小结
6纯函数式状态
6．1 以副作用方式生成随机数
6．2 纯函数式随机数生成器
6．3 用纯函数式实现带状态的API
6．4 状态行为的更好的API
6．4．1 组合状态行为
6．4．2 嵌套状态行为
6．5 更通用的状态行为数据类型
6．6 纯函数式命令编程
6．7 小结
功能设计和组合子库
7纯函数式的并行计算
7．1 选择数据类型和函数
7．1．1 一种用于并行计算的数据类型
7．1．2 组合并行计算
7．1．3 显性分流
7．2 确定表现形式
7．3 完善API
7．4 API与代数
7．4．1 映射法则
7．4．2 分流法则
7．4．3 打破法则：一个微妙的bug
7．4．4 用Actor实现一个完全无阻塞的Par
7．5 完善组合子为更通用的形式
7．6 小结
8基于性质的测试
8．1 基于性质测试概览
8．2 选择数据类型和函数
8．2．1 API的初始代码片段
8．2．2 性质的含义与API
8．2．3 生成器的意义和API
8．2．4 生成值决定生成器
8．2．5 精炼Prop的数据类型
8．3 最小化测试用例
8．4 使用库并改进其易用性
8．4．1 一些简单的例子
8．4．2 为并行计算编写测试套件
8．5 测试高阶函数及展望未来
8．6 生成器法则
8．7 小结
9语法分析器组合子
9．1 代数设计，走起
9．2 一种可能的代数
9．2．1 切片和非空重复
9．3 处理上下文的相关性
9．4 写一个JSON分析器
9．4．1 JSON格式
9．4．2 JSON分析器
9．5 错误提示
9．5．1 一种可行的设计
9．5．2 错误嵌套
9．5．3 控制分支和回溯轨迹
9．6 实现代数
9．6．1 一种可能的实现
9．6．2 串化分析器
9．6．3 标记分析器
9．6．4 故障转移和回溯
9．6．5 上下文相关的分析
9．7 小结
函数设计的通用结构
10Monoid
10．1 什么是monoid
10．2 使用monoid折叠列表
10．3 结合律和并行化
10．4 例子：并行解析
10．5 可折叠数据结构
10．6 组合monoid
10．6．1 组装更加复杂的monoid
10．6．2 使用组合的monoid融合多个遍历
10．7 小结 151
11Monad
11．1 函子：对map函数的泛化
11．1．1 函子法则
11．2 Monad：对flatMap和unit函数的泛化
11．3 Monadic组合子
11．4 单子定律
11．4．1 结合法则
11．4．2 为指定的monad证明结合法则
11．4．3 单位元法则
11．5 什么是monad
11．5．1 identity monad
11．5．2 状态monad和partial type application
11．6 小结
12可应用和可遍历函子
12．1 泛化单子
12．2 Applicative trait
12．3 单子与可应用函子的区别
12．3．1 对比Option applicative与Option monad
12．3．2 对比Parser applicative与Parser monad
12．4 可应用函子的优势
12．4．1 不是所有的可应用函子都是Monad
12．5 可应用法则
12．5．1 Left and right identity
12．5．2 结合律
12．5．3 Naturality of product
12．6 可遍历函子
12．7 使用Traverse
12．7．1 从monoid到可应用函子
12．7．2 带状态的遍历
12．7．3 组合可遍历结构
12．7．4 遍历融合
12．7．5 嵌套遍历
12．7．6 Monad组合
12．8 小结
作用与I/O
13外部作用和I/O
13．1 分解作用13．2 一个简单的IO类型
13．2．1 处理输入效果
13．2．2 简单IO类型的优缺点
13．3 避免栈溢出
13．3．1 将一个控制流转化为数据构造子
13．3．2 Trampolining：栈溢出的通用解决方法
13．4 一个更微妙的IO类型
13．4．1 合理的monad
13．4．2 一个支持控制台I/O的monad
13．4．3 纯解释器
13．5 非阻塞和异步I/O
13．6 一个通用的IO类型
13．6．1 最终的main程序
13．7 为什么IO类型不足以支撑流式I/O
13．8 小结
14本地影响和可变状态
14．1 纯函数式的可变状态
14．2 一种限制副作用范围的数据类型
14．2．1 受限可变性的语言表达
14．2．2 一种可变引用的代数表达
14．2．3 执行修改状态的行为
14．2．4 可变数组
14．2．5 一个纯函数的in-place快排实现
14．3 纯粹是相对于上下文的
14．3．1 副作用是什么？
14．4 小结
15流式处理与增量I/O
15．1 命令式I/O的问题示例
15．2 一个简单的流转换器
15．2．1 创建Process
15．2．2 组合和追加处理
15．2．3 处理文件
15．3 可扩展的处理类型
15．3．1 来源
15．3．2 保证资源安全
15．3．3 单一输入过程
15．3．4 多个输入流
15．3．5 去向
15．3．6 Effectful通道
15．3．7 动态资源分配
15．4 应用场景
15．5 小结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala函数式编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>快学Scala
目录
序
前言
关于作者
1 基础 [A1]
1.1 Scala解释器
1.2 声明值和变量
1.3 常用类型
1.4 算术和操作符重载
1.5 调用函数和方法
1.6 apply方法
1.7 Scaladoc
练习
2 控制结构和函数 [A1]
2.1 条件表达式
2.2 语句终止
2.3 块表达式和赋值
2.4 输入和输出
2.5 循环
2.6 高级for循环和for推导式
2.7 函数
2.8 默认参数和带名参数 [L1]
2.9 变长参数 [L1]
2.10 过程
2.11 懒值 [L1]
2.12 异常
练习
3 数组相关操作 [A1]
3.1 定长数组
3.2 变长数组：数组缓冲
3.3 遍历数组和数组缓冲
3.4 数组转换
3.5 常用算法
3.6 解读Scaladoc
3.7 多维数组
3.8 与Java的互操作
练习
4 映射和元组 [A1]
4.1 构造映射
4.2 获取映射中的值
4.3 更新映射中的值
4.4 迭代映射
4.5 已排序映射
4.6 与Java的互操作
4.7 元组
4.8 拉链操作
练习
5 类 [A1]
5.1 简单类和无参方法
5.2 带getter和setter的属性
5.3 只带getter的属性
5.4 对象私有字段
5.5 Bean属性 [L1]
5.6 辅助构造器
5.7 主构造器
5.8 嵌套类 [L1]
练习
6 对象 [A1]
6.1 单例对象
6.2 伴生对象
6.3 扩展类或特质的对象
6.4 apply方法
6.5 应用程序对象
6.6 枚举
练习
7 包和引入 [A1]
7.1 包
7.2 作用域规则
7.3 串联式包语句
7.4 文件顶部标记法
7.5 包对象
7.6 包可见性
7.7 引入
7.8 任何地方都可以声明引入
7.9 重命名和隐藏方法
7.10 隐式引入
练习
8 继承 [A1]
8.1 扩展类
8.2 重写方法
8.3 类型检查和转换
8.4 受保护字段和方法
8.5 超类的构造
8.6 重写字段
8.7 匿名子类
8.8 抽象类
8.9 抽象字段
8.10 构造顺序和提前定义 [L3]
8.11 Scala继承层级
8.12 对象相等性 [L1]
练习
9 文件和正则表达式 [A1]
9.1 读取行
9.2 读取字符
9.3 读取词法单元和数字
9.4 从URL或其他源读取
9.5 读取二进制文件
9.6 写入文本文件
9.7 访问目录
9.8 序列化
9.9 进程控制 [A2]
9.10 正则表达式
9.11 正则表达式组
练习
10 特质 [L1]
10.1 为什么没有多重继承？
10.2 当作接口使用的特质
10.3 带有具体实现的特质
10.4 带有特质的对象
10.5 叠加在一起的特质
10.6 在特质中重写抽象方法
10.7 当作富接口使用的特质
10.8 特质中的具体字段
10.9 特质中的抽象字段
10.10 特质构造顺序
10.11 初始化特质中的字段
10.12 扩展类的特质
10.13 自身类型 [L2]
10.14 背后发生了什么
练习
11 操作符 [L1]
11.1 标识符
11.2 中置操作符
11.3 一元操作符
11.4 赋值操作符
11.5 优先级
11.6 结合性
11.7 apply和update方法
11.8 提取器 [L2]
11.9 带单个参数或无参数的提取器 [L2]
11.10 unapplySeq方法
练习
12 高阶函数 [L1]
12.1 作为值的函数
12.2 匿名函数
12.3 带函数参数的函数
12.4 参数（类型）推断
12.5 一些有用的高阶函数
12.6 闭包
12.7 SAM转换
12.8 柯里化
12.9 控制抽象
12.10 return表达式
练习
13 集合 [A2]
13.1 主要的集合特质
13.2 可变和不可变集合
13.3 序列
13.4 列表
13.5 可变列表
13.6 集
13.7 用于添加或去除元素的操作符
13.8 常用方法
13.9 将函数映射到集合
13.10 化简、折叠和扫描 [A3]
13.11 拉链操作
13.12 迭代器
13.13 流 [A3]
13.14 懒视图
13.15 与Java集合的互操作
13.16 线程安全的集合
13.17 并行集合
练习
14 模式匹配和样例类 [A2]
14.1 更好的switch
14.2 守卫
14.3 模式中的变量
14.4 类型模式
14.5 匹配数组、列表和元组
14.6 提取器
14.7 变量声明中的模式
14.8 for表达式中的模式
14.9 样例类
14.10 copy方法和带名参数
14.11 case语句中的中置表示法
14.12 匹配嵌套结构
14.13 样例类是邪恶的吗？
14.14 密封类
14.15 模拟枚举
14.16 Option类型
14.17 偏函数 [L2]
练习
15 注解 [A2]
15.1 什么是注解？
15.2 什么可以被注解？
15.3 注解参数
15.4 注解实现
15.5 针对Java特性的注解
15.5.1 Java修饰符
15.5.2 标记接口
15.5.3 受检异常
15.5.4 变长参数
15.5.5 JavaBeans
15.6 用于优化的注解
15.6.1 尾递归
15.6.2 跳转表的生成和内联
15.6.3 可省略方法
15.6.4 基本类型的特殊化
15.7 用于错误和警告的注解
练习
16 XML处理 [A2]
16.1 XML字面量
16.2 XML节点
16.3 元素属性
16.4 内嵌表达式
16.5 在属性中使用表达式
16.6 特殊节点类型
16.7 类XPath表达式
16.8 模式匹配
16.9 修改元素和属性
16.10 XML变换
16.11 加载和保存
16.12 命名空间
练习
17 类型参数 [L2]
17.1 泛型类
17.2 泛型函数
17.3 类型变量界定
17.4 视图界定
17.5 上下文界定
17.6 Manifest上下文界定
17.7 多重界定
17.8 类型约束 [L3]
17.9 型变
17.10 协变和逆变点
17.11 对象不能泛型
17.12 类型通配符
练习
18 高级类型 [L2]
18.1 单例类型
18.2 类型投影
18.3 路径
18.4 类型别名
18.5 结构类型
18.6 复合类型
18.7 中置类型
18.8 存在类型
18.9 Scala类型系统
18.10 自身类型
18.11 依赖注入
18.12 抽象类型 [L3]
18.13 家族多态 [L3]
18.14 高等类型 [L3]
练习
19 解析 [A3]
19.1 文法
19.2 连结解析器操作
19.3 解析器结果变换
19.4 丢弃词法单元
19.5 生成解析树
19.6 避免左递归
19.7 更多的连结符
19.8 避免回溯
19.9 记忆式解析器
19.10 解析器说到底是什么？
19.11 正则解析器
19.12 基于词法单元的解析器
19.13 错误处理
练习
20 Actor [A3]
20.1 创建和启动actor
20.2 发送消息
20.3 接收消息
20.4 向其他actor发送消息
20.5 消息通道
20.6 同步消息和Future
20.7 共享线程
20.8 actor的生命周期
20.9 将多个actor链接在一起
20.10 actor的设计
练习
21 隐式转换和隐式参数 [L3]
21.1 隐式转换
21.2 利用隐式转换丰富现有类库的功能
21.3 引入隐式转换
21.4 隐式转换规则
21.5 隐式参数
21.6 利用隐式参数进行隐式转换
21.7 上下文界定
21.8 类型证明
21.9 @implicitNotFound注解
21.10 CanBuildFrom解读
练习
22 定界延续 [L3]
22.1 捕获并执行延续
22.2 “运算当中挖个洞”
22.3 reset和shift的控制流转
22.4 reset表达式的值
22.5 reset和shift表达式的类型
22.6 CPS注解
22.7 将递归访问转化为迭代
22.8 撤销控制反转
22.9 CPS变换
22.10 转换嵌套的控制上下文
练习
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>快学Scala
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala编程
目录	ix
图示清单	xvii
表格清单	xix
代码清单	xxi
序	I
致谢	III
简介	V
第1章  可伸展的语言	3
1.1	与你一同成长的语言	3
1.2	是什么让Scala具有可扩展性？	6
1.3	为什么选择Scala？	8
1.4	Scala的根源	13
1.5	小结	14
第2章  Scala入门初探	15
2.1	第一步  学习使用Scala解释器	15
2.2	第二步  变量定义	16
2.3	第三步  函数定义	18
2.4	第四步  编写Scala脚本	19
2.5	第五步  用while做循环；用if做判断	20
2.6	第六步  用foreach和for做枚举	21
2.7	小结	22
第3章  Scala入门再探	23
3.1	第七步  使用类型参数化数组（Array）	23
3.2	第八步  使用列表（List）	25
3.3	第九步  使用元组（Tuple）	28
3.4	第十步  使用集（set）和映射（map）	29
3.5	第十一步  学习识别函数式风格	32
3.6	第十二步  从文件里读取文本行	34
3.7	小结	36
第4章  类和对象	37
4.1	类、字段和方法	37
4.2	分号推断	40
4.3	Singleton对象	41
4.4	Scala程序	43
4.5	Application特质	45
4.6	小结	45
第5章  基本类型和操作	47
5.1	基本类型	47
5.2	字面量	48
5.3	操作符和方法	52
5.4	数学运算	54
5.5	关系和逻辑操作	55
5.6	位操作符	56
5.7	对象相等性	57
5.8	操作符的优先级和关联性	58
5.9	富包装器	60
5.10	小结	60
第6章  函数式对象	61
6.1	类Rational的规格说明书	61
6.2	创建Rational	62
6.3	重新实现toString方法	63
6.4	检查先决条件	63
6.5	添加字段	64
6.6	自指向	65
6.7	辅助构造器	65
6.8	私有字段和方法	66
6.9	定义操作符	67
6.10	Scala的标识符	68
6.11	方法重载	70
6.12	隐式转换	71
6.13	一番告诫	72
6.14	小结	72
第7章  内建控制结构	73
7.1	If表达式	73
7.2	While循环	74
7.3	for表达式	76
7.4	使用try表达式处理异常	80
7.5	匹配（match）表达式	82
7.6	不再使用break和continue	83
7.7	变量范围	84
7.8	重构指令式风格的代码	87
7.9	小结	88
第8章  函数和闭包	89
8.1	方法	89
8.2	本地函数	90
8.3	头等函数	91
8.4	函数字面量的短格式	93
8.5	占位符语法	93
8.6	部分应用函数	94
8.7	闭包	96
8.8	重复参数	98
8.9	尾递归	99
8.10	小结	102
第9章  控制抽象	103
9.1	减少代码重复	103
9.2	简化客户代码	106
9.3	柯里化（currying）	107
9.4	编写新的控制结构	108
9.5	传名参数（by-name parameter）	110
9.6	小结	112
第10章  组合与继承	113
10.1	二维布局库	113
10.2	抽象类	114
10.3	定义无参数方法	114
10.4	扩展类	116
10.5	重写方法和字段	117
10.6	定义参数化字段	118
10.7	调用超类构造器	119
10.8	使用override修饰符	120
10.9	多态和动态绑定	121
10.10	定义final成员	123
10.11	使用组合与继承	124
10.12	实现above、beside和toString	124
10.13	定义工厂对象	126
10.14	变高变宽	128
10.15	把代码都放在一起	129
10.16	小结	130
第11章  Scala的层级	131
11.1	Scala的类层级	131
11.2	原始类型是如何实现的	134
11.3	底层类型	135
11.4	小结	136
第12章  特质	137
12.1	特质是如何工作的	137
12.2	瘦接口对阵胖接口	139
12.3	样例：长方形对象	140
12.4	Ordered特质	141
12.5	特质用来做可堆叠的改变	143
12.6	为什么不是多重继承？	146
12.7	特质，用还是不用？	148
12.8	小结	149
第13章  包和引用	151
13.1	包	151
13.2	引用	153
13.3	隐式引用	156
13.4	访问修饰符	156
13.5	小结	160
第14章  断言和单元测试	161
14.1	断言	161
14.2	Scala里的单元测试	162
14.3	翔实的失败报告	163
14.4	使用JUnit和TestNG	164
14.5	规格测试	166
14.6	基于属性的测试	167
14.7	组织和运行测试	168
14.8	小结	170
第15章  样本类和模式匹配	171
15.1  简单例子	171
15.2  模式的种类	174
15.3  模式守卫	180
15.4  模式重叠	181
15.5  封闭类	182
15.6  Option类型	183
15.7  模式无处不在	184
15.8  一个更大的例子	187
15.9  小结	192
第16章  使用列表	193
16.1  列表字面量	193
16.2  List类型	193
16.3  构造列表	194
16.4  列表的基本操作	194
16.5  列表模式	195
16.6  List类的一阶方法	196
16.7  List类的高阶方法	204
16.8  List对象的方法	210
16.9  了解Scala的类型推断算法	212
16.10  小结	214
第17章  集合类型	215
17.1  集合库概览	215
17.2  序列	216
17.3  集（Set）和映射（Map）	220
17.4  可变（mutable）集合vs.不可变（immutable）集合	227
17.5  初始化集合	229
17.6  元组	231
17.7  小结	232
第18章  有状态的对象	233
18.1  什么让对象具有状态？	233
18.2  可重新赋值的变量和属性	234
18.3  案例研究：离散事件模拟	237
18.4  为数字电路定制的语言	237
18.5  Simulation API	239
18.6  电路模拟	242
18.7  小结	247
第19章  类型参数化	249
19.1  queues函数式队列	249
19.2  信息隐藏	251
19.3  变化型注解	253
19.4  检查变化型注解	256
19.5  下界	258
19.6  逆变	259
19.7  对象私有数据	261
19.8  上界	263
19.9  小结	264
第20章  抽象成员	265
20.1  抽象成员的快速浏览	265
20.2  类型成员	266
20.3  抽象val	266
20.4  抽象var	267
20.5  初始化抽象val	267
20.6  抽象类型	273
20.7  路径依赖类型	274
20.8  枚举	276
20.9  案例研究：货币	277
20.10  小结	284
第21章  隐式转换和参数	285
21.1  隐式转换	285
21.2  隐式操作规则	287
21.3  隐式转换为期望类型	289
21.4  转换（方法调用的）接收者	290
21.5  隐式参数	292
21.6  视界	296
21.7  隐式操作调试	297
21.8  小结	299
第22章  实现列表	301
22.1  List类原理	301
22.2  ListBuffer类	305
22.3  实际的List类	306
22.4  外在的函数式（风格）	308
22.5  小结	308
第23章  重访For表达式	309
23.1  For表达式	310
23.2  皇后问题	311
23.3  使用for表达式做查询	313
23.4  for表达式的转译	314
23.5  反其道而行之	317
23.6  泛化的for	318
23.7  小结	319
第24章  抽取器（Extractors）	321
24.1  例子：抽取email地址	321
24.2  抽取器	322
24.3  0或1个变量的模式	324
24.4  变参抽取器	325
24.5  抽取器和序列模式	327
24.6  抽取器VS.样本类	327
24.7  正则表达式	328
24.8  小结	330
第25章  注解	331
25.1  为什么要有注解？	331
25.2  注解语法	332
25.3  标准注解	333
25.4  小结	334
第26章  使用XML	335
26.1  半结构化数据	335
26.2  XML概览	335
26.3  XML字面量	336
26.4  序列化	338
26.5  拆解XML	339
26.6  反序列化	340
26.7  加载和保存	341
26.8  XML的模式匹配	342
26.9  小结	344
第27章  使用对象的模块化编程	345
27.1  问题	345
27.2  食谱应用	346
27.3  抽象概念	348
27.4  把模块拆分为特质	350
27.5  运行期链接	352
27.6  跟踪模块实例	353
27.7  小结	354
第28章  对象相等性	355
28.1  Scala中的相等性	355
28.2  编写相等性方法	355
28.3  定义带参数类型的相等性	365
28.4  equals和hashCode的制作方法	368
28.5  小结	371
第29章  结合Scala和Java	373
29.1  在Java中使用Scala	373
29.2  注解	375
29.3  存在类型	379
29.4  小结	381
第30章  Actor和并发	383
30.1  天堂中的烦恼	383
30.2  actor和消息传递	384
30.3  将原生线程当作actor	387
30.4  通过重用线程获得更好的性能	387
30.5  良好的actor风格	389
30.6  更长一些的示例：并行离散事件模拟	394
30.7  小结	406
第31章  连结符解析	407
31.1  示例：算术表达式	408
31.2  运行你的解析器	409
31.3  基本的正则表达式解析器	410
31.4  另一个示例：JSON	410
31.5  解析器输出	412
31.6  实现连结符解析器	416
31.7  字符串字面量和正则表达式	421
31.8  词法分析和解析	422
31.9  错误报告	423
31.10  回溯vs. LL(1)	424
31.11  小结	425
第32章  GUI编程	427
32.1  第一个Swing应用	427
32.2  面板和布局	429
32.3  处理事件	430
32.4  示例：摄氏/华氏温度转换器	432
32.5  小结	434
第33章  Scell试算表	435
33.1  可视化框架	435
33.2  将数据录入和显示分开	437
33.3  公式	439
33.4  解析公式	440
33.5  求值	444
33.6  操作库	446
33.7  修改传达	448
33.8  小结	451
附录A  Unix和Windows的Scala脚本	453
术语表	455
参考文献	465
关于作者	467
索引	469
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala编程（第3版）
序.XXIV
致谢.XXVI
引言.XXIX
第1章　一门可伸缩的语言.1
1.1　一门按需伸缩的语言 2
1.2　是什么让Scala能屈能伸？ 7
1.3　为什么要用Scala？.11
1.4　Scala寻根 17
1.5　结语 19
第2章　Scala入门 20
第1步　使用Scala解释器 21
第2步　定义变量 22
第3步　定义函数 24
第4步　编写Scala脚本 26
第5步　用while做循环；用if做判断 27
第6步　用foreach和for遍历 30
结语 32
第3章　Scala入门（续）.33
第7步　用类型参数化数组 33
第8步　使用列表 38
第9步　使用元组 42
第10步使用集和映射 43
第11步　识别函数式编程风格 48
第12步　从文件读取文本行 51
结语 55
第4章　类和对象.56
4.1　类、字段和方法 56
4.2　分号推断 61
4.3　单例对象 62
4.4　Scala应用程序 65
4.5　App特质 68
4.6　结语 68
第5章　基础类型和操作69
5.1　一些基础类型 69
5.2　字面量 70
5.3　字符串插值 77
5.4　操作符即方法 78
5.5　算术操作 81
5.6　关系和逻辑操作 83
5.7　位运算操作 85
5.8　对象相等性 86
5.9　操作符优先级和结合性 88
5.10　富包装类 91
5.11　结语 91
第6章　函数式对象.93
6.1　Rational类的规格定义 93
6.2　构建Rational 94
6.3　重新实现toString方法 96
6.4　检查前置条件 97
6.5　添加字段 98
6.6　自引用.100
6.7　辅助构造方法.101
6.8　私有字段和方法.102
6.9　定义操作符 104
6.10　Scala中的标识符.106
6.11　方法重载.108
6.12　隐式转换.111
6.13　注意事项.112
6.14　结语 112
第7章　内建的控制结构 114
7.1　if表达式.115
7.2　while循环 116
7.3　for表达式 119
7.4　用try表达式实现异常处理125
7.5　match表达式129
7.6　没有break和continue的日子.131
7.7　变量作用域 134
7.8　对指令式代码进行重构.137
7.9　结语.139
第8章　函数和闭包 140
8.1　方法.140
8.2　局部函数142
8.3　一等函数144
8.4　函数字面量的简写形式.147
8.5　占位符语法 147
8.6　部分应用的函数.149
8.7　闭包.152
8.8　特殊的函数调用形式 156
8.9　尾递归.159
8.10　结语 163
第9章　控制抽象 164
9.1　减少代码重复.164
9.2　简化调用方代码.169
9.3　柯里化.170
9.4　编写新的控制结构173
9.5　传名参数176
9.6　结语.178
第10章　组合和继承179
10.1　一个二维的布局类库179
10.2　抽象类 180
10.3　定义无参方法 182
10.4　扩展类 184
10.5　重写方法和字段 186
10.6　定义参数化字段 188
10.7　调用超类构造方法.189
10.8　使用override修饰符 190
10.9　多态和动态绑定 192
10.10　声明final成员.195
10.11　使用组合和继承196
10.12　实现above、beside和toString.198
10.13　定义工厂对象.201
10.14　增高和增宽.204
10.15　放在一起 206
10.16　结语207
第11章　Scala的继承关系208
11.1　Scala的类继承关系208
11.2　基本类型的实现机制212
11.3　底类型（bottom types）.215
11.4　定义自己的值类型.216
11.5　结语219
第12章　特质.220
12.1　特质如何工作 220
12.2　瘦接口和富接口 224
12.3　示例：矩形对象 225
12.4　Ordered特质 227
12.5　作为可叠加修改的特质229
12.6　为什么不用多重继承？234
12.7　要特质还是不要特质？238
12.8　结语 238
第13章　包和引入240
13.1　将代码放进包里 240
13.2　对相关代码的精简访问242
13.3　引入 246
13.4　隐式引入.249
13.5　访问修饰符250
13.6　包对象 256
13.7　结语 257
第14章　断言和测试258
14.1　断言 258
14.2　用Scala写测试 260
14.3　翔实的失败报告 262
14.4　作为规格说明的测试263
14.5　基于性质的测试 267
14.6　组织和运行测试 268
14.7　结语 270
第15章　样例类和模式匹配.271
15.1　一个简单的例子 271
15.2　模式的种类276
15.3　模式守卫.286
15.4　模式重叠.287
15.5　密封类 289
15.6　Option类型.291
15.7　到处都是模式 293
15.8　一个复杂的例子 298
15.9　结语 306
第16章　使用列表307
16.1　List字面量 307
16.2　List类型 308
16.3　构建列表.309
16.4　列表的基本操作 309
16.5　列表模式.310
16.6　List类的初阶方法 312
16.7　List类的高阶方法 324
16.8　List对象的方法333
16.9　同时处理多个列表.335
16.10　理解Scala的类型推断算法 336
16.11　结语.339
第17章　使用其他集合类 340
17.1　序列 340
17.2　集和映射.344
17.3　在可变和不可变集合类之间选择352
17.4　初始化集合355
17.5　元组 358
17.6　结语 361
第18章　可变对象362
18.1　什么样的对象是可变的？ 362
18.2　可被重新赋值的变量和属性.365
18.3　案例分析：离散事件模拟 368
18.4　用于描述数字电路的语言 369
18.5　Simulation API.372
18.6　电路模拟.376
18.7　结语 384
第19章　类型参数化385
19.1　函数式队列385
19.2　信息隐藏.389
19.3　型变注解.392
19.4　检查型变注解 397
19.5　下界 400
19.6　逆变 402
19.7　对象私有数据 405
19.8　上界 407
19.9　结语 410
第20章　抽象成员 411
20.1　抽象成员概览 411
20.2　类型成员.412
20.3　抽象的val413
20.4　抽象的var414
20.5　初始化抽象的val.415
20.6　抽象类型.423
20.7　路径依赖类型 425
20.8　改良类型.428
20.9　枚举 429
20.10　案例分析：货币431
20.11 结语.441
第21章　隐式转换和隐式参数.442
21.1　隐式转换.442
21.2　隐式规则.445
21.3　隐式转换到一个预期的类型.448
21.4　转换接收端450
21.5　隐式参数.454
21.6　上下文界定460
21.7　当有多个转换可选时463
21.8　调试 465
21.9　结语 467
第22章　实现列表468
22.1　List类的原理.468
22.2　ListBuffer类 475
22.3　List类的实践.476
22.4　外部可见的函数式.479
22.5　结语 480
第23章　重访for表达式 481
23.1　for表达式483
23.2　N皇后问题.484
23.3　用for推导式进行查询 487
23.4　用for推导式进行翻译 489
23.5　反过来 494
23.6　泛化for表达式 495
23.7　结语 497
第24章　深入集合类498
24.1　可变和不可变集合.499
24.2　集合的一致性 501
24.3　Traversable特质 503
24.4　Iterable特质508
24.5　序列型特质Seq、IndexedSeq和LinearSeq.512
24.6　集517
24.7　映射 521
24.8　具体的不可变集合类525
24.9　具体的可变集合类.532
24.10　数组539
24.11　字符串544
24.12　性能特征 545
24.13　相等性547
24.14　视图548
24.15　迭代器554
24.16　从头创建集合.561
24.17　Java和Scala集合互转.563
24.18　结语564
第25章　Scala集合架构565
25.1　集合构建器565
25.2　抽取公共操作 567
25.3　集成新的集合 572
25.4　结语 588
第26章　提取器589
26.1　示例：提取电子邮箱地址 589
26.2　提取器 591
26.3　提取0或1个变量的模式 594
26.4　提取可变长度参数的模式 596
26.5　提取器和序列模式.598
26.6　提取器和样例类的对比599
26.7　正则表达式601
26.8　结语 604
第27章　注解.606
27.1　为什么要有注解？.606
27.2　注解的语法607
27.3　标准注解.609
27.4　结语 613
第28章　使用XML614
28.1　半结构化数据 614
28.2　XML概览615
28.3　XML字面量 616
28.4　序列化 618
28.5　拆解XML620
28.6　反序列化.622
28.7　加载和保存623
28.8　对XML做模式匹配624
28.9　结语 628
第29章　用对象实现模块化编程.629
29.1　问题描述.630
29.2　食谱应用程序 631
29.3　抽象 634
29.4　将模块拆分成特质.638
29.5　运行时链接640
29.6　跟踪模块实例 642
29.7　结语 643
第30章　对象相等性645
30.1　Scala中的相等性.645
30.2　编写相等性方法 646
30.3　为参数化类型定义相等性 660
30.4　如何编写equals和hashCode方法.664
30.5　结语 668
第31章　结合Scala和Java 669
31.1　从Java使用Scala.669
31.2　注解 672
31.3　通配类型.678
31.4　同时编译Scala和Java680
31.5　基于Scala 2.12特性的Java 8集成681
31.6　结语 685
第32章　Future和并发编程 686
32.1　天堂里的烦恼 687
32.2　异步执行和Try.688
32.3　使用Future.690
32.4　测试Future.705
32.5　结语 708
第33章　组合子解析709
33.1　示例：算术表达式.710
33.2　运行你的解析器 712
33.3　基本的正则表达式解析器 713
33.4　另一个示例：JSON 714
33.5　解析器输出717
33.6　实现组合子解析器.723
33.7　字符串字面量和正则表达式.732
33.8　词法分析和解析 733
33.9　错误报告.734
33.10　回溯和LL(1)736
33.11　结语.737
第34章　GUI编程.740
34.1　第一个Swing应用程序.740
34.2　面板和布局743
34.3　处理事件.745
34.4　示例：摄氏/华氏转换器.748
34.5　结语 750
第35章　SCells试算表 752
35.1　可视化框架752
35.2　将数据录入和显示分开755
35.3　公式 758
35.4　解析公式.760
35.5　求值 765
35.6　操作类库.768
35.7　变更通知.771
35.8　结语 775
附录A　Unix和Windows环境的Scala脚本.777
关于作者 798
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala编程（第3版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala程序设计（第2版）
序　　xv
前言　　xvii
第1章　零到六十：Scala简介　　1
1.1　为什么选择Scala　　1
1.1.1　富有魅力的Scala　　2
1.1.2　关于Java 8　　3
1.2　安装Scala　　3
1.2.1　使用SBT　　5
1.2.2　执行Scala命令行工具　　6
1.2.3　在IDE中运行Scala REPL　　8
1.3　使用Scala　　8
1.4　并发　　17
1.5　本章回顾与下一章提要　　27
第2章　更简洁，更强大　　28
2.1　分号　　28
2.2　变量声明　　29
2.3　Range　　31
2.4　偏函数　　32
2.5　方法声明　　33
2.5.1　方法默认值和命名参数列表　　33
2.5.2　方法具有多个参数列表　　34
2.5.3　Future简介　　35
2.5.4　嵌套方法的定义与递归　　38
2.6　推断类型信息　　40
2.7　保留字　　44
2.8　字面量　　46
2.8.1　整数字面量　　46
2.8.2　浮点数字面量　　47
2.8.3　布尔型字面量　　48
2.8.4　字符字面量　　48
2.8.5　字符串字面量　　48
2.8.6　符号字面量　　50
2.8.7　函数字面量　　50
2.8.8　元组字面量　　50
2.9　Option、Some 和None：避免使用null　　52
2.10　封闭类的继承　　53
2.11　用文件和名空间组织代码　　54
2.12　导入类型及其成员　　55
2.12.1　导入是相对的　　56
2.12.2　包对象　　57
2.13　抽象类型与参数化类型　　57
2.14　本章回顾与下一章提要　　59
第3章　要点详解　　60
3.1　操作符重载?　　60
3.2　无参数方法　　63
3.3　优先级规则　　64
3.4　领域特定语言　　65
3.5　Scala中的if语句　　66
3.6　Scala中的for推导式　　67
3.6.1　for循环　　67
3.6.2　生成器表达式　　67
3.6.3　保护式：筛选元素　　67
3.6.4　Yielding　　68
3.6.5　扩展作用域与值定义　　69
3.7　其他循环结构　　70
3.7.1　Scala的while循环　　71
3.7.2　Scala中的do-while循环　　71
3.8　条件操作符　　71
3.9　使用try、catch和final子句　　72
3.10　名字调用和值调用　　75
3.11　惰性赋值　　78
3.12　枚举　　79
3.13　可插入字符串　　81
3.14　Trait：Scala语言的接口和“混入”　　83
3.15　本章回顾与下一章提要　　85
第4章　模式匹配　　86
4.1　简单匹配　　86
4.2　match中的值、变量和类型　　87
4.3　序列的匹配　　90
4.4　元组的匹配　　94
4.5　case中的guard语句　　94
4.6　case类的匹配　　95
4.6.1　unapply方法　　96
4.6.2　unapplySeq方法　　100
4.7　可变参数列表的匹配　　101
4.8　正则表达式的匹配　　103
4.9　再谈case语句的变量绑定　　104
4.10　再谈类型匹配　　104
4.11　封闭继承层级与全覆盖匹配　　105
4.12　模式匹配的其他用法　　107
4.13　总结关于模式匹配的评价　　111
4.14　本章回顾与下一章提要　　111
第5章　隐式详解　　112
5.1　隐式参数　　112
5.2　隐式参数适用的场景　　115
5.2.1　执行上下文　　115
5.2.2　功能控制　　115
5.2.3　限定可用实例　　116
5.2.4　隐式证据　　120
5.2.5　绕开类型擦除带来的限制　　122
5.2.6　改善报错信息　　124
5.2.7　虚类型　　124
5.2.8　隐式参数遵循的规则　　127
5.3　隐式转换　　128
5.3.1　构建独有的字符串插入器　　132
5.3.2　表达式问题　　134
5.4　类型类模式　　135
5.5　隐式所导致的技术问题　　137
5.6　隐式解析规则　　139
5.7　Scala内置的各种隐式　　139
5.8　合理使用隐式　　146
5.9　本章回顾与下一章提要　　146
第6章　Scala函数式编程　　147
6.1　什么是函数式编程　　148
6.1.1　数学中的函数　　148
6.1.2　不可变变量　　149
6.2　Scala中的函数式编程　　151
6.2.1　匿名函数、Lambda与闭包　　152
6.2.2　内部与外部的纯粹性　　154
6.3　递归　　154
6.4　尾部调用和尾部调用优化　　155
6.5　偏应用函数与偏函数　　157
6.6　Curry化与函数的其他转换　　158
6.7　函数式编程的数据结构　　162
6.7.1　序列　　162
6.7.2　映射表　　166
6.7.3　集合　　168
6.8　遍历、映射、过滤、折叠与归约　　168
6.8.1　遍历　　169
6.8.2　映射　　170
6.8.3　扁平映射　　172
6.8.4　过滤　　173
6.8.5　折叠与归约　　174
6.9　向左遍历与向右遍历　　178
6.10　组合器：软件最佳组件抽象　　183
6.11　关于复制　　186
6.12　本章回顾与下一章提要　　188
第7章　深入学习for推导式　　189
7.1　内容回顾：for推导式组成元素　　189
7.2　for推导式：内部机制　　192
7.3　for推导式的转化规则　　194
7.4　Option以及其他的一些容器类型　　197
7.4.1　Option容器　　197
7.4.2　Either：Option类型的逻辑扩展　　200
7.4.3　Try类型　　205
7.4.4　Scalaz提供的Validation类　　206
7.5　本章回顾与下一章提要　　209
第8章　Scala面向对象编程　　210
8.1　类与对象初步　　211
8.2　引用与值类型　　213
8.3　价值类　　214
8.4　父类　　217
8.5　Scala的构造器　　217
8.6　类的字段　　221
8.6.1　统一访问原则　　223
8.6.2　一元方法　　224
8.7　验证输入　　224
8.8　调用父类构造器（与良好的面向对象设计）　　226
8.9　嵌套类型　　230
8.10　本章回顾与下一章提要　　232
第9章　特征　　 233
9.1　Java 8中的接口　　233
9.2　混入trait　　234
9.3　可堆叠的特征　　238
9.4　构造trait　　243
9.5　选择类还是trait　　244
9.6　本章回顾与下一章提要　　245
第10章　Scala对象系统（I）　　246
10.1　参数化类型：继承转化　　246
10.1.1　Hood下的函数　　247
10.1.2　可变类型的变异　　250
10.1.3　Scala和Java中的变异　　252
10.2　Scala的类型层次结构　　253
10.3　闲话Nothing（以及Null）　　254
10.4　Product、case类和元组　　258
10.5　Predef对象　　260
10.5.1　隐式转换　　260
10.5.2　类型定义　　262
10.5.3　条件检查方法　　263
10.5.4　输入输出方法　　263
10.5.5　杂项方法　　265
10.6　对象的相等　　265
10.6.1　equals方法　　266
10.6.2　== 和!=方法　　266
10.6.3　eq 和ne方法　　267
10.6.4　数组相等和sameElements方法　　267
10.7　本章回顾与下一章提要　　268
第11章　Scala对象系统（II）　　269
11.1　覆写类成员和trait成员　　269
11.2　尝试覆写final声明　　272
11.3　覆写抽象方法和具体方法　　272
11.4　覆写抽象字段和具体字段　　274
11.5　覆写抽象类型　　280
11.6　无须区分访问方法和字段：统一访问原则　　280
11.7　对象层次结构的线性化算法　　282
11.8　本章回顾与下一章提要　　287
第12章　Scala集合库　　288
12.1　通用、可变、不可变、并发以及并行集合　　288
12.1.1　scala.collection包　　289
12.1.2　collection.concurrent包　　290
12.1.3　collection.convert包　　291
12.1.4　collection.generic包　　291
12.1.5　collection.immutable包　　291
12.1.6　scala.collection.mutable包　　292
12.1.7　scala.collection.parallel包　　294
12.2　选择集合　　295
12.3　集合库的设计惯例　　296
12.3.1　Builder　　296
12.3.2　CanBuildFrom　　297
12.3.3　Like特征　　298
12.4　值类型的特化　　298
12.5　本章回顾与下一章提要　　300
第13章　可见性规则　　301
13.1　默认可见性：公有可见性　　301
13.2　可见性关键字　　302
13.3　Public可见性　　303
13.4　Protected可见性　　304
13.5　Private可见性　　305
13.6　作用域内私有和作用域内受保护可见性　　306
13.7　对可见性的想法　　312
13.8　本章回顾与下一章提要　　313
第14章　Scala类型系统（I）　　314
14.1　参数化类型　　315
14.1.1　变异标记　　315
14.1.2　类型构造器　　315
14.1.3　类型参数的名称　　315
14.2　类型边界　　315
14.2.1　类型边界上限　　316
14.2.2　类型边界下限　　316
14.3　上下文边界　　320
14.4　视图边界　　320
14.5　理解抽象类型　　322
14.6　自类型标记　　325
14.7　结构化类型　　329
14.8　复合类型　　332
14.9　存在类型　　334
14.10　本章回顾与下一章提要　　335
第15章　Scala类型系统（II）　　336
15.1　路径相关类型　　336
15.1.1　C.this　　337
15.1.2　C.super　　337
15.1.3　path.x　　338
15.2　依赖方法类型　　339
15.3　类型投影　　340
15.4　值的类型　　343
15.4.1　元组类型　　343
15.4.2　函数类型　　343
15.4.3　中缀类型　　343
15.5　Higher-Kinded类型　　344
15.6　类型Lambda　　348
15.7　自递归类型：F-Bounded多态　　350
15.8　本章回顾与下一章提要　　351
第16章　高级函数式编程　　352
16.1　代数数据类型　　352
16.1.1　加法类型与乘法类型　　352
16.1.2　代数数据类型的属性　　354
16.1.3　代数数据类型的最后思考　　355
16.2　范畴理论　　355
16.2.1　关于范畴　　356
16.2.2　Functor范畴　　356
16.2.3　Monad范畴　　360
16.2.4　Monad的重要性　　362
16.3　本章回顾与下一章提要　　363
第17章　并发工具　　365
17.1　scala.sys.process包　　365
17.2　Future类型　　367
17.3　利用Actor模型构造稳固且可扩展的并发应用　　 371
17.4　Akka：为Scala设计的Actor系统　　372
17.5　Pickling和Spores　　383
17.6　反应式编程　　384
17.7　本章回顾与下一章提要　　385
第18章　Scala与大数据　　386
18.1　大数据简史　　386
18.2　用Scala改善MapReduce　　387
18.3　超越MapReduce　　392
18.4　数学范畴　　393
18.5　Scala数据工具列表　　394
18.6　本章回顾与下一章提要　　394
第19章　Scala动态调用　　396
19.1　一个较为激进的示例：Ruby on Rails框架中的ActiveRecord库　　396
19.2　使用动态特征实现Scala 中的动态调用　　397
19.3　关于DSL的一些思考　　402
19.4　本章回顾与下一章提要　　402
第20章　Scala的领域特定语言　　403
20.1　DSL 示例：Scala中XML和JSON DSL　　404
20.2　内部DSL　　406
20.3　包含解析组合子的外部DSL　　410
20.3.1　关于解析组合子　　410
20.3.2　计算工资单的外部DSL　　410
20.4　内部DSL与外部DSL：最后的思考　　413
20.5　本章回顾与下一章提要　　413
第21章　Scala工具和库　　414
21.1　命令行工具　　414
21.1.1　命令行工具：scalac　　414
21.1.2　Scala命令行工具　　418
21.1.3　scalap和javap命令行工具　　421
21.1.4　scaladoc 命令行工具　　422
21.1.5　fsc命令行工具　　422
21.2　构建工具　　422
21.2.1　SBT：Scala标准构建工具　　423
21.2.2　其他构建工具　　425
21.3　与IDE或文本编辑器集成　　425
21.4　在Scala中应用测试驱动开发　　426
21.5　第三方库　　427
21.6　本章回顾与下一章提要　　429
第22章　与Java的互操作　　430
22.1　在Scala代码中使用Java名称　　430
22.2　Java泛型与Scala泛型　　430
22.3　JavaBean的性质　　432
22.4　AnyVal类型与Java原生类型　　433
22.5　Java代码中的Scala名称　　433
22.6　本章回顾与下一章提要　　434
第23章　应用程序设计　　435
23.1　回顾之前的内容　　435
23.2　注解　　437
23.3　Trait即模块　　441
23.4　设计模式　　442
23.4.1　构造型模式　　443
23.4.2　结构型模式　　443
23.4.3　行为型模式　　444
23.5　契约式设计带来更好的设计　　446
23.6　帕特农神庙架构　　448
23.7　本章回顾与下一章提要　　453
第24章　元编程：宏与反射　　454
24.1　用于理解类型的工具　　455
24.2　运行时反射　　455
24.2.1　类型反射　　455
24.2.2　ClassTag、TypeTag与Manifest　　457
24.3　Scala 的高级运行时反射API　　458
24.4　宏　　461
24.4.1　宏的示例：强制不变性　　463
24.4.2　关于宏的最后思考　　466
24.5　本章回顾与下一章提要　　466
附录A　参考文献　　468
作者简介　　473
关于封面　　473
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala程序设计（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>响应式架构
目录
第１章　Actor模型和企业级软件概述. ................................... 1
为什么企业级软件难以开发........1
响应式应用程序简介....................4
响应性 ....................................5
韧性 ...6
灵活性 ....................................6
消息驱动 ................................7
企业级应用程序............................8
Actor模型 ..9
Actor模型的起源 ................10
了解 Actor模型 ................... 11
Actor模型的明晰性 .....................20
下章提要.21
第２章　使用Scala语言和Akka框架实现Actor模型............. 22
怎样获取Scala语言和Akka框架 23
使用 Typesafe Activator编辑器 ..............................23
使用 sbt ................................23
使用 Maven ..........................24
使用 Gradle ..........................25
使用Scala语言编写程序 .............26
Scala概要教程 ....................27
使用Akka框架编写程序.............39
Actor系统 ............................40
实现 Actor对象 ...................46
监督 .52
远程处理 ..............................55
集群功能 ..............................68
测试 Actor对象 ...................94
CompletableApp类 .............98
小结.......100
第３章　性能情结. ........................ 101
晶体管...101
时钟频率....................................103
核心和高速缓存........................104
可伸缩性....................................106
多线程技术的难点....................109
Actor模型的作用 ....................... 114
处理伪共享 ........................ 116
设计模式.................................... 117
第４章　通过Actor对象传递消息. . 119
消息通道....................................120
消息.......121
管道和过滤器............................126
消息路由器................................131
消息译码器................................134
消息端点....................................135
小结.......137
第５章　消息通道. ........................ 138
点对点通道................................140
发布—订阅通道........................143
本地事件流 ........................143
分布式发布—订阅通道 ....149
数据类型通道............................157
非法消息通道............................159
死信通道....................................161
确保送达机制............................164
通道适配器................................172
消息桥...174
消息总线....................................180
小结.......189
第６章　消息结构. ........................ 190
命令消息....................................191
文档消息....................................192
管理处理流程和处理过程 194
事件消息....................................195
请求—回复模式........................197
返回地址....................................199
相关标识符................................203
消息序列....................................204
消息有效期................................206
格式标识符................................209
小结.......213
第７章　消息路由. ........................ 214
基于内容的路由器....................215
消息过滤器................................219
动态路由器................................223
接收者列表................................232
分离器...241
聚合器...245
重新定序器................................252
组合消息处理器........................259
分散—聚集路由器....................260
传送名单....................................274
处理过程管理器........................282
消息经纪人路由器....................298
小结.......301
第８章　消息转换. ........................ 302
封装器...303
内容丰富器................................305
不可变的 DoctorVisitCompleted消息...................309
是否应在本地系统中创建 AccountingEnricherDispatcher对象 ..............309
内容过滤器................................310
存放证...313
标准化器....................................321
规范化消息模型........................322
Actor系统需要标准 ..........323
小结.......324
第９章　消息端点. ........................ 325
消息传输网关............................326
消息传输映射............................332
事务型客户端/ Actor对象 .........339
事务型客户端 ....................341
事务型 Actor对象 .............342
轮询消费者................................350
资源轮询 ............................354
由事件驱动的消费者................358
具有竞争性的消费者................359
消息调度器................................361
选择性消费者............................364
持久订阅者................................367
幂等接收者................................370
避免处理消息副本 ............370
使消息具有相同的效果 ....371
使状态切换操作不受收到消息副本的影响 .........372
服务激活剂................................378
小结.......379
第10章　系统管理和基础结构...... 380
控制总线....................................380
改道器...382
窃听器...384
消息元数据/历史记录 ...............385
消息日志/存储器 .......................389
智能代理....................................392
测试消息....................................397
通道净化器................................399
小结.......401
附录A　.NET平台上的Akka工具集：Dotsero. ................... 402
Dotsero的Actor系统 ..................402
通过C#和.NET使用Actor对象 .405
Dotsero实现 ...............................410
小结.......413
参考资料.. 414
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>响应式架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala程序设计
第1章 简介	1
1.1 为何选择Scala	1
1.2 何为Scala	3
1.3 函数式编程	7
1.4 本书的内容	9
1.5 本书面向的读者	11
1.6 致谢	11
第2章 起步	13
2.1 下载Scala	13
2.2 安装Scala	13
2.2.1 在Windows上安装Scala	14
2.2.2 在类UNIX系统上安装Scala	14
2.3 让Scala跑起来	15
2.4 命令行上的Scala	16
2.5 把Scala代码当作脚本运行	17
2.5.1 在类UNIX系统上作为脚本运行	17
2.5.2 在Windows上作为脚本运行	18
2.6 在IDE里面运行Scala	18
2.7 编译Scala	19
第3章 Scala步入正轨	20
3.1 把Scala当作简洁的Java	20
3.2 Java基本类型对应的Scala类	23
3.3 元组与多重赋值	23
3.4 字符串与多行原始字符串	25
3.5 自适应的默认做法	26
3.6 运算符重载	27
3.7 Scala带给Java程序员的惊奇	29
3.7.1 赋值的结果	29
3.7.2 Scala的==	30
3.7.3 分号是半可选的	31
3.7.4 默认的访问修饰符	32
3.7.5 默认的访问修饰符以及如何修改	32
3.7.6 Scala的Protected	33
3.7.7 细粒度访问控制	34
3.7.8 避免显式return	35
第4章 Scala的类	37
4.1 创建类	37
4.2 定义字段、方法和构造函数	38
4.3 类继承	41
4.4 单例对象	42
4.5 独立对象和伴生对象	43
4.6 Scala中的static	44
第5章 自适应类型	46
5.1 容器和类型推演	47
5.2 Any类型	49
5.3 关于Nothing的更多情况	50
5.4 Option类型	50
5.5 方法返回类型推演	51
5.6 传递变参	52
5.7 参数化类型的可变性	53
第6章 函数值和闭包	57
6.1 从普通函数迈向高阶函数	57
6.2 函数值	58
6.3 具有多参数的函数值	59
6.4 Curry化	61
6.5 重用函数值	62
6.6 参数的位置记法	64
6.7 Execute Around Method模式	65
6.8 偏应用函数	67
6.9 闭包	68
第7章 Trait和类型转换	70
7.1 Trait	70
7.2 选择性混入	72
7.3 以trait进行装饰	74
7.4 Trait方法的延迟绑定	75
7.5 隐式类型转换	77
第8章 使用容器	81
8.1 常见的Scala容器	81
8.2 使用Set	82
8.3 使用Map	83
8.4 使用List	85
8.5 for表达式	90
第9章 模式匹配和正则表达式	93
9.1 匹配字面量和常量	93
9.2 匹配通配符	94
9.3 匹配元组和列表	94
9.4 类型和卫述句的匹配	96
9.5 case表达式里的模式变量和常量	96
9.6 对XML片段进行模式匹配	98
9.7 使用case类进行模式匹配	98
9.8 使用提取器进行匹配	100
9.9 正则表达式	103
9.10 把正则表达式当做提取器	104
第10章 并发编程	106
10.1 促进不变性	106
10.2 使用Actor的并发	107
10.3 消息传递	110
10.4 Actor类	113
10.5 actor方法	115
10.6 receive和receiveWithin方法	117
10.7 react和reactWithin方法	120
10.8 loop和loopWhile	124
10.9 控制线程执行	125
10.10 在各种接收方法中选择	127
第11章 与Java互操作	128
11.1 在Scala里使用Scala类	128
11.2 在Scala里使用Java类	130
11.3 在Java里使用Scala类	132
11.3.1 有普通函数和高阶函数的Scala类	132
11.3.2 同trait一起工作	134
11.3.3 单例对象和伴生对象	134
11.4 继承类	136
第12章 用Scala做单元测试	138
12.1 使用JUnit	138
12.2 使用ScalaTest	139
12.3 以Canary测试开始	140
12.4 使用Runner	140
12.5 Asserts	142
12.6 异常测试	144
12.7 在测试间共享代码	146
12.7.1 用BeforeAndAfter共享代码	146
12.7.2 用闭包共享代码	147
12.8 FunSuite的函数式风格	148
12.9 用JUnit运行ScalaTest	149
第13章 异常处理	152
13.1 异常处理	152
13.2 注意catch顺序	154
第14章 使用Scala	156
14.1 净资产应用实例	156
14.2 获取用户输入	156
14.3 读写文件	157
14.4 XML，作为一等公民	159
14.5 读写XML	161
14.6 从Web获取股票价格	164
14.7 让净资产应用并发	167
14.8 为净资产应用增加GUI	168
附录A Web资源	178
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>快学Scala（第2版）
译者序. V
第1版序.XVII
前言.XIX
作者简介.XXIII
第1章　基础 A1  1
1.1　Scala解释器 1
1.2　声明值和变量 4
1.3　常用类型5
1.4　算术和操作符重载7
1.5　关于方法调用 8
1.6　apply方法 9
1.7　Scaladoc11
练习16
第2章　控制结构和函数 A1  19
2.1　条件表达式20
2.2　语句终止 22
2.3　块表达式和赋值 22
2.4　输入和输出23
2.5　循环25
2.6　高级for循环27
2.7　函数28
2.8　默认参数和带名参数 L1 29
2.9　变长参数 L1 29
2.10　过程 31
2.11　懒值 L1 31
2.12　异常 32
练习35
第3章　数组相关操作 A1 39
3.1　定长数组 39
3.2　变长数组：数组缓冲40
3.3　遍历数组和数组缓冲41
3.4　数组转换 42
3.5　常用算法 44
3.6　解读Scaladoc 45
3.7　多维数组 47
3.8　与Java的互操作48
练习49
第4章　映射和元组 A1 53
4.1　构造映射 53
4.2　获取映射中的值 54
4.3　更新映射中的值 55
4.4　迭代映射 56
4.5　已排序映射57
4.6　与Java的互操作57
4.7　元组58
4.8　拉链操作 59
练习60
第5章　类 A1 63
5.1　简单类和无参方法 63
5.2　带getter和setter的属性 64
5.3　只带getter的属性 67
5.4　对象私有字段68
5.5　Bean属性 L1 69
5.6　辅助构造器71
5.7　主构造器 72
5.8　嵌套类 L1 75
练习78
第6章　对象 A1  81
6.1　单例对象 81
6.2　伴生对象 82
6.3　扩展类或特质的对象83
6.4　apply方法84
6.5　应用程序对象85
6.6　枚举86
练习87
第7章　包和引入 A1  91
7.1　包 91
7.2　作用域规则93
7.3　串联式包语句95
7.4　文件顶部标记法 95
7.5　包对象 96
7.6　包可见性 97
7.7　引入97
7.8　任何地方都可以声明引入 98
7.9　重命名和隐藏方法 99
7.10　隐式引入 99
练习 100
第8章　继承 A1 103
8.1　扩展类103
8.2　重写方法 104
8.3　类型检查和转换105
8.4　受保护字段和方法 106
8.5　超类的构造 106
8.6　重写字段 107
8.7　匿名子类 109
8.8　抽象类109
8.9　抽象字段 110
8.10　构造顺序和提前定义 L3 110
8.11　Scala类继承关系 112
8.12　对象相等性 L1114
8.13　值类 L2 116
练习 117
第9章　文件和正则表达式 A1 121
9.1　读取行121
9.2　读取字符 122
9.3　读取词法单元和数字 123
9.4　从URL或其他源读取 124
9.5　读取二进制文件124
9.6　写入文本文件 124
9.7　访问目录 125
9.8　序列化125
9.9　进程控制 A2126
9.10　正则表达式129
9.11　正则表达式组 130
练习 131
第10章　特质 A1  135
10.1　为什么没有多重继承 135
10.2　当作接口使用的特质 137
10.3　带有具体实现的特质 138
10.4　带有特质的对象 139
10.5　叠加在一起的特质140
10.6　在特质中重写抽象方法 141
10.7　当作富接口使用的特质 142
10.8　特质中的具体字段143
10.9　特质中的抽象字段144
10.10　特质构造顺序145
10.11　初始化特质中的字段147
10.12　扩展类的特质148
10.13　自身类型 L2 149
10.14　背后发生了什么 151
练习 152
第11章　操作符 A1  157
11.1　标识符 157
11.2　中置操作符158
11.3　一元操作符159
11.4　赋值操作符160
11.5　优先级 161
11.6　结合性 162
11.7　apply和update方法162
11.8　提取器 L2 164
11.9　带单个参数或无参数的提取器 L2 166
11.10　unapplySeq方法 L2 167
11.11　动态调用 L2 167
练习 171
第12章　高阶函数 L1 175
12.1　作为值的函数 175
12.2　匿名函数177
12.3　带函数参数的函数178
12.4　参数（类型）推断179
12.5　一些有用的高阶函数 180
12.6　闭包 181
12.7　SAM转换182
12.8　柯里化 183
12.9　控制抽象185
12.10　return表达式 186
练习 187
第13章　集合 A2  191
13.1　主要的集合特质 192
13.2　可变和不可变集合193
13.3　序列 195
13.4　列表 196
13.5　集197
13.6　用于添加或去除元素的操作符 198
13.7　常用方法201
13.8　将函数映射到集合203
13.9　化简、折叠和扫描 A3205
13.10　拉链操作 209
13.11　迭代器 210
13.12　流 A3 211
13.13　懒视图 A3213
13.14　与Java集合的互操作 213
13.15　并行集合 215
练习 217
第14章　模式匹配和样例类 A2  221
14.1　更好的switch222
14.2　守卫 223
14.3　模式中的变量 223
14.4　类型模式224
14.5　匹配数组、列表和元组 225
14.6　提取器 227
14.7　变量声明中的模式227
14.8　for表达式中的模式229
14.9　样例类 229
14.10　copy方法和带名参数 230
14.11　case语句中的中置表示法231
14.12　匹配嵌套结构232
14.13　样例类是邪恶的吗 233
14.14　密封类 234
14.15　模拟枚举 235
14.16　Option类型 235
14.17 偏函数 L2 236
练习 238
第15章　注解 A2  243
15.1　什么是注解243
15.2　什么可以被注解 244
15.3　注解参数245
15.4　注解实现246
15.5　针对Java特性的注解247
15.5.1　Java修饰符 247
15.5.2　标记接口 248
15.5.3　受检异常 249
15.5.4　变长参数 249
15.5.5　JavaBeans 250
15.6　用于优化的注解 250
15.6.1　尾递归250
15.6.2　跳转表生成与内联 252
15.6.3　可省略方法 253
15.6.4　基本类型的特殊化 254
15.7　用于错误和警告的注解 255
练习 256
第16章　XML处理 A2 259
16.1　XML字面量 260
16.2　XML节点 260
16.3　元素属性262
16.4　内嵌表达式263
16.5　在属性中使用表达式 264
16.6　特殊节点类型 265
16.7　类XPath表达式266
16.8　模式匹配267
16.9　修改元素和属性 268
16.10　XML变换269
16.11　加载和保存 270
16.12　命名空间 273
练习 275
第17章　Future A2  277
17.1　在future中运行任务 278
17.2　等待结果280
17.3　Try类 281
17.4　回调 282
17.5　组合future任务 283
17.6　其他future变换 286
17.7　Future对象中的方法288
17.8　Promise.289
17.9　执行上下文291
练习 292
第18章　类型参数 L2 297
18.1　泛型类 298
18.2　泛型函数298
18.3　类型变量界定 298
18.4　视图界定300
18.5　上下文界定301
18.6　ClassTag上下文界定 301
18.7　多重界定302
18.8　类型约束 L3 302
18.9　型变 304
18.10　协变和逆变点305
18.11　对象不能泛型307
18.12　类型通配符 308
练习 309
第19章　高级类型 L2 313
19.1　单例类型313
19.2　类型投影315
19.3　路径 316
19.4　类型别名317
19.5　结构类型318
19.6　复合类型319
19.7　中置类型320
19.8　存在类型321
19.9　Scala类型系统 322
19.10　自身类型 323
19.11　依赖注入 325
19.12　抽象类型 L3 327
19.13　家族多态 L3 329
19.14　高等类型 L3 333
练习 336
第20章　解析 A3  341
20.1　文法 342
20.2　组合解析器操作 343
20.3　解析器结果变换 345
20.4　丢弃词法单元 347
20.5　生成解析树348
20.6　避免左递归348
20.7　更多的组合子 350
20.8　避免回溯352
20.9　记忆式解析器 353
20.10　解析器说到底是什么354
20.11　正则解析器 355
20.12　基于词法单元的解析器 356
20.13　错误处理 358
练习 359
第21章　隐式转换和隐式参数 L3 363
21.1　隐式转换363
21.2　利用隐式转换丰富现有类库的功能 364
21.3　引入隐式转换 365
21.4　隐式转换规则 367
21.5　隐式参数368
21.6　利用隐式参数进行隐式转换 370
21.7　上下文界定371
21.8　类型类 372
21.9　类型证明374
21.10　@implicitNotFound注解.376
21.11　CanBuildFrom解读376
练习 379
词汇表 381
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>快学Scala（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Scala
第1章 Scala——一种混合式编程语言 1
1.1 Scala的设计哲学 1
1.2 当函数式编程遇见面向对象 3
1.2.1 重新发现函数式概念 4
1.2.2 Google Collections中的函数式概念 6
1.3 静态类型和表达力 8
1.3.1 换边 8
1.3.2 类型推断 9
1.3.3 抛开语法 10
1.3.4 隐式转换概念早已有之 11
1.3.5 使用Scala的implicit关键字 12
1.4 与JVM的无缝集成 13
1.4.1 Scala调用Java 13
1.4.2 Java调用Scala 14
1.4.3 JVM的优越性 15
1.5 总结 16
第2章 核心规则 17
2.1 学习使用Scala交互模式（REPL） 17
2.1.1 实验驱动开发 19
2.1.2 绕过积极（eaglerly）解析 20
2.1.3 无法表现的语言特性 21
2.2 优先采用面向表达式编程 22
2.2.1 方法和模式匹配 23
2.2.2 可变性 24
2.3 优先选择不变性 26
2.3.1 判等 27
2.3.2 并发 31
2.4 用None不用null 34
2.5 多态场景下的判等 38
2.5.1 例子：时间线库 38
2.5.2 多态判等实现 40
2.6 总结 43
第3章 来点样式—编码规范 44
3.1 避免照搬其他语言的编码规范 45
3.2 空悬的操作符和括号表达式 48
3.3 使用有意义的命名 50
3.3.1 命名时避免$符号 51
3.3.2 使用命名和默认参数 53
3.4 总是标记覆盖（overriden）方法 56
3.5 对期望的优化进行标注 61
3.6 总结 66
第4章 面向对象编程 68
4.1 限制在对象或特质的body里初始化逻辑的代码 68
4.1.1 延迟构造 69
4.12 多重继承又来了 70
4.2 为特质的抽象方法提供空实现 71
4.3 组合可以包含继承 76
4.3.1 通过继承组合成员 79
4.3.2 经典构造器with a twist 80
4.3.3 总结 82
4.4 提升抽象接口为独立特质 82
4.4.1 和接口交互 84
4.4.2 从历史中吸取教训 85
4.4.3 结论 86
4.5 public接口应当提供返回值 86
4.6 总结 88
第5章 利用隐式转换写更有表达力 89
5.1 介绍隐式转换系统 90
5.1.1 题外话：标识符 91
5.1.2 作用域和绑定 93
5.1.3 隐式解析 97
5.1.4 通过类型参数获得隐式作用域 99
5.1.5 通过嵌套获得隐式作用域 100
5.2 隐式视图：强化已存在的类 101
5.3 隐式参数结合默认参数 106
5.4 限制隐式系统的作用域 112
5.4.1 为导入创建隐式转换 112
5.4.2 没有导入税（import tax）的隐式转换 114
5.5 总结 118
第6章 类型系统 119
6.1 类型 120
6.1.1 类型和路径 121
6.1.2 type关键字 123
6.1.3 结构化类型 124
6.2 类型约束 130
6.3 类型参数和高阶类型（Higher Kinded Types） 133
6.3.1 类型参数约束 133
6.3.2 高阶类型 134
6.4 型变（Variance） 136
6.5 存在类型 143
6.6 总结 148
第7章 隐式转换和类型系统结合应用 149
7.1 上下文边界和视图边界 149
7.2 用隐式转换来捕捉类型 152
7.2.1 捕获类型用于运行时计算（capturing types for runtime evaluation） 152
7.2.2 使用Manifest 153
7.2.3 捕捉类型约束 154
7.2.4 特定方法（Specialized method） 156
7.3 使用类型类 （type class） 158
7.3.1 作为类型类的 FileLike 161
7.3.2 类型类的好处 164
7.4 用类型系统实现条件执行 165
7.4.1 异构类型List 167
7.4.2 IndexedView 170
7.5 总结 177
第8章 Scala集合库 178
8.1 使用正确的集合类型 179
8.1.1 集合库继承层次 179
8.1.2 Traversable 180
8.1.3 Iterable 184
8.1.4 Seq 185
8.1.5 LinearSeq 186
8.1.6 IndexedSeq 188
8.1.7 Set 189
8.1.8 Map 189
8.2 不可变集合 191
8.2.1 Vector 191
8.2.2 List 193
8.2.3 Stream（流） 194
8.3 可变集合 197
8.3.1 ArrayBuffer 197
8.3.2 混入修改事件发布特质 198
8.3.3 混入串行化特质 198
8.4 用视图和并行集合来改变计算策略 199
8.4.1 视图 200
8.4.2 并行集合 201
8.5 编写能处理所有集合类型的方法 204
8.6 总结 209
第9章 Actors 210
9.1 使用Actor的时机 210
9.2 使用有类型的、透明的引用 214
9.3 把故障限制在故障区里 219
9.3.1 发散搜集故障区 219
9.3.2 通常的故障处理实践 222
9.4 利用排期区控制负载 223
9.5 动态Actor拓扑 226
9.6 总结 231
第10章 Scala和Java集成 232
10.1 Scala/Java不匹配 233
10.1.1 基础类型自动打包的差异 234
10.1.2 可见性的差异 238
10.1.3 不可表达的语言特性 239
10.2 谨慎使用隐式转换 242
10.2.1 对象标识和判等 242
10.2.2 链式隐式转换 244
10.3 小心Java序列化 246
10.4 注解你的注解 250
10.4.1 注解目标 252
10.4.2 Scala和静态属性 253
10.5 总结 254
第11章 函数式编程 255
11.1 计算机科学领域的范畴论 255
11.2 函子（Functor）， Monad及它们与范畴的关系 259
11.3 咖喱化和可应用风格（Applicative style） 264
11.3.1 咖喱化 265
11.3.2 可应用风格 267
11.4 用作工作流的单子 270
11.5 总结 274
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Scala
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala编程思想（原书第2版）
编辑器 / 1
shell / 2
安装（Windows） / 5
安装（Mac） / 9
安装（Linux） / 13
运行Scala / 19
注释 / 20
编写脚本 / 21
值 / 22
数据类型 / 24
变量 / 27
表达式 / 29
条件表达式 / 31
计算顺序 / 34
组合表达式 / 37
总结1 / 41
方法 / 45
类和对象 / 50
ScalaDoc / 54
创建类 / 55
类中的方法 / 58
导入和包 / 61
测试 / 65
域 / 70
for循环 / 72
Vector / 75
更多的条件表达式 / 79
总结2 / 82
模式匹配 / 91
类参数 / 94
具名参数和缺省参数 / 98
重载 / 101
构造器 / 104
辅助构造器 / 108
类的练习 / 110
case类 / 112
字符串插值 / 115
参数化类型 / 117
作为对象的函数 / 120
map和reduce / 125
推导 / 128
基于类型的模式匹配 / 133
基于case类的模式匹配 / 136
简洁性 / 139
风格拾遗 / 144
地道的Scala / 147
定义操作符 / 148
自动字符串转换 / 151
元组 / 153
伴随对象 / 157
继承 / 163
基类初始化 / 166
覆盖方法 / 170
枚举 / 173
抽象类 / 176
特征 / 179
统一访问方式和setter / 185
衔接Java / 187
应用 / 190
浅尝反射 / 192
多态 / 194
组合 / 200
使用特征 / 206
标记特征和case对象 / 209
类型参数限制 / 211
使用特征构建系统 / 214
序列 / 219
列表和递归 / 223
将序列与zip相结合 / 226
集 / 229
映射表 / 232
引用和可修改性 / 235
使用元组的模式匹配 / 238
用异常进行错误处理 / 242
构造器和异常 / 247
用Either进行错误报告 / 250
用Option对“非任何值”
进行处理 / 255
用Try来转换异常 / 261
定制错误报告机制 / 269
按契约设计 / 276
记日志 / 279
扩展方法 / 282
使用类型类的可扩展系统 / 285
接下来如何深入学习 / 290
附录A　AtomicTest / 291
附录B　从Java中调用
Scala / 293
索引 / 29
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala编程思想（原书第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala并发编程
前言 ............................................................................................ XVII
1 简介 ........................................................................................................... 1
并发程序设计 .......................................................................................................... 1
传统并发编程技术概述 ............................................................................. 2
现代并发范式 .......................................................................................................... 3
Scala 的优点 ....................................................................... 4
预备知识 ....................................................................................... 5
执行Scala 程序 ......................................................................... 5
Scala 基础知识 ................................................................................................ 6
小结 ...................................................................................................... 11
练习 ........................................................................................ 11
2 JVM 和Java 内存模型中的并发处理方式 ................................................ 13
进程和线程 ...................................................................... 14
创建和启动线程 ....................................................16
原子执行方式 .......................................................21
调整次序 ..................................................................................................25
监控器和同步 ............................................................................................... 27
死锁 .....................................................................................................29
保卫锁 ..........................................................................................................32
中断线程和正常关闭 ...............................................................................................36
Volatile 变量 .................................................................................................. 37
Java 内存模型.............................................................................................. 39
不可变对象和final 字段 .......................................................41
小结 ............................................................. 43
练习 ....................................................................................... 43
3 构建并发程序的传统材料 ............................................. 47
Executor 和ExecutionContext 对象 ................... 48
原子型基元 ...................................................... 52
原子变量 ............................................................................52
无锁编程 ..........................................................55
以明确方式实现锁 ...................................................................57
ABA 问题 .....................................................................59
惰性值 .............................................................................. 61
并发集合 ..................................................................... 66
并发队列 ...............................................................................68
并发集和映射 .....................................................71
并发遍历 .............................................................77
创建和处理进程 ...................................................... 79
小结 ................................................................. 81
练习 ................................................................... 81
4 使用Future 和Promise 对象编写异步程序 .............................................. 85
Future 类 ................................................................................. 86
执行Future 计算....................................................................88
Future 对象的回调函数 ..................................................89
Future 计算和异常 ...............................................92
使用Try 类型 .......................................93
致命异常 ............................................95
Future 对象中的函数组合 ............................................................95
Promise 类 .................................................. 103
转换基于回调函数的API ........................................................... 106
扩展Future API .................................................. 108
取消异步计算操作 ..................................................................................... 109
Future 对象和阻塞操作 ................................................................... 112
等待Future 对象..................................................................................... 112
在异步计算内部执行阻塞操作 ................................................................................... 113
Scala Async 库 ...................................................................... 114
可选的Future 框架 .......................................................................................... 117
小结 ........................................................................................................... 118
练习 ....................................................................................................................... 119
5 数据并行集合 ......................................................................................... 121
Scala 集合概述 ................................................................................................ 122
并行集合的用法 ......................................................................................... 123
并行集合类的层次结构 ....................................................................................... 126
配置并行等级 ...................................................................................................... 128
在JVM 中度量性能 ............................................................................. 129
使用并行集合的注意事项 ................................................................................. 131
非可并行化集合 .................................................................... 131
非可并行化操作 .............................................................................................. 132
并行操作的副作用 .................................................................................................... 134
不确定的并行操作 .................................. 135
可交换和可结合操作符 .............................................................. 137
组合使用并行集合和并发集合 .................................................................... 139
弱一致性迭代器 ........................................................ 140
实现自定义的并行集合 ............................................................................... 141
分离器 ................................................................................................ 142
组合器 ..................................................................................................... 145
可选的数据并行框架 ................................................................. 148
ScalaBlitz 框架中的集合层次结构 .............................................................. 149
小结 ....................................................................................................... 150
练习 ............................................................................................. 151
6 使用Reactive Extensions 编写并发程序 ............................................... 153
创建Observable 对象 ............................................................... 154
Observable 对象和异常 ................................................................ 157
Observable 协定 ................................................................................ 158
实现自定义Observable 对象 ...................................................................................... 160
通过Future 对象创建Observable 对象 ............................................................ 161
Subscription 对象 ............................................................................................ 162
组合Observable 对象 ...................................................................................... 165
嵌套的Observable 对象 ....................................................................................... 166
处理完善Observable 对象失败的情况 .................................................................. 171
Rx 调度器 ............................................................................... 174
使用自定义调度器编写UI 应用程序 .................................................................. 176
Subject 特征和自顶向下的响应式编程 .................................................. 181
小结 ............................................................................................ 186
练习 ..................................................................................... 186
7 基于软件的事务内存 .............................................................................. 189
原子变量带来的麻烦 ...................................................................... 190
使用基于软件的事务内存 .............................................. 194
事务引用 ......................................................... 196
使用atomic 语句 ................................................................ 197
组合事务 .............................................................. 198
事务与副作用 ................................................................. 199
单操作事务 ................................................................. 203
嵌套事务 ........................................................... 205
事务和异常 ...................................................... 208
重新尝试执行事务 ........................................ 212
通过超时设置重新尝试执行事务 ......................................... 216
事务集合 ..................................................................................... 217
事务局部变量 ................................................................. 218
事务数组 ......................................................... 219
事务映射 .............................................................................. 221
小结 ............................................................................................. 222
练习 ............................................................................. 223
8 Actor ...................................................................................................... 227
使用Actor 模型 ............................................................................... 228
创建Actor 系统和Actor 实例 ..................................................................... 230
管理无法正常处理的消息 .................................................................................. 233
Actor 实例的行为和状态 ........................................................................................ 234
Akka 框架中的Actor 层次结构.................................................................................. 239
识别Actor 对象 ............................................................................................... 242
Actor 对象的生命周期 ................................................................................... 245
Actor 对象之间的通信 ...................................................... 249
请求模式 ........................................................ 251
转发模式 ..................................................................... 254
停止Actor 对象 ......................................................................... 255
Actor 监督 .......................................................................... 257
远程Actor 对象 ............................................................. 263
小结 .............................................................................................. 266
练习 ................................................................................................... 267
9 实用并发技术 ......................................................................................... 269
工欲善其事，必先利其器 ....................................................... 269
组合使用多种框架——编写远程文件管理器 ............................................ 273
创建文件系统模型 ........................................................ 274
服务器接口 ......................................................................... 278
客户端导航API.................................................................................. 280
客户端的用户界面 ............................................................................. 284
实现客户端程序的逻辑 .................................................................................. 288
改进远程文件管理器 ........................................................................................ 293
调试并发程序 ................................................................................................................... 294
死锁和暂停处理过程 ............................................................... 295
调试运行结果不正确的程序 ................................................................ 299
性能调试 ............................................................................... 304
小结 .............................................................................................................................. 310
练习 .................................................................................................................................. 311
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala并发编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala与Clojure函数式编程模式
第1章　模式和函数式编程　　1
1.1　什么是函数式编程　　2
1.2　模式词汇表　　4
第2章　TinyWeb：让模式协同工作　　7
2.1　TinyWeb简介　　7
2.2　采用Java来编写TinyWeb　　7
2.3　采用Scala来编写TinyWeb 　　17
2.4　采用Clojure来编写TinyWeb　　25
第3章　替代面向对象模式　　35
简介　　35
模式1　替代函数式接口　　35
模式2　替代承载状态的函数式接口　　42
模式3　替代命令模式　　48
模式4　替代生成器模式来获得不可变对象　　55
模式5　替代迭代器模式　　64
模式6　替代模板方法模式　　73
模式7　替代策略模式　　81
模式8　替代空对象　　87
模式9　替代装饰器模式　　95
模式10　替代访问者模式　　99
模式11　替代依赖注入　　113
第4章　函数式模式　　121
简介　　121
模式12　尾递归模式　　121
模式13　相互递归模式　　128
模式14　Filter-Map-Reduce模式　　136
模式15　操作链模式　　139
模式16　函数生成器模式　　146
模式17　记忆模式　　159
模式18　惰性序列模式　　163
模式19　集中的可变性　　172
模式20　自定义控制流　　180
模式21　领域特定语言　　191
第5章　结束语　　201
参考文献　　202
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala与Clojure函数式编程模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala 编程实战
前言........................................1
第1章字符串........... 11
1.1 测试字符串的相等性..................................14
1.2 创建多个字符串........................................16
1.3 分隔字符串........................................17
1.4 字符串中的变量代换..................................19
1.5 挨个处理字符串中的字符...........................23
1.6 字符串中的查找模式..................................27
1.7 字符串中的替换模式..................................30
1.8 抽取String 中模式匹配的部分.....................31
1.9 访问字符串中的一个字符...........................33
1.10 在String 类中添加自定义的方法...............34
第2章数值..............39
2.1 从字符串到数值........................................40
2.2 数值类型转换........................................44
2.3 重载默认数值类型......................................45
2.4 替代++ 和－－........................................47
2.5 浮点数的比较........................................49
2.6 处理大数........................................51
2.7 生成随机数........................................53
2.8 创建一个数值区间、列表或者数组............55
2.9 格式化数值和金额......................................57
第3章控制结构.......60
3.1 for 和foreach 循环........................................61
3.2 在for 循环中使用多个计数器......................67
3.3 在for 循环中嵌入if 语句（卫语句）............69
3.4 创建for 表达式（for/yield 组合）................70
3.5 实现break 和continue...................................72
3.6 像三元运算符一样使用if............................77
3.7 像switch 语句一样使用匹配表达式.............78
3.8 一条case 语句匹配多个条件........................83
3.9 将匹配表达式的结果赋值给变量...............84
3.10 访问匹配表达式缺省case 的值..................84
3.11 在匹配表达式中使用模式匹配.................85
3.12 在匹配表达式中使用Case 类....................92
3.13 给Case 语句添加if 表达式（卫语句）.......93
3.14 使用匹配表达式替换isInstanceOf.............94
3.15 在匹配表达式中使用List..........................95
3.16 用try/catch 匹配一个或者更多的异常......97
3.17 在try/catch/finally 块中使用变量前定义变量.........................98
3.18 创建自定义控制结构..............................100
第4章类和属性.....103
4.1 创建一个主构造函数................................104
4.2 控制构造函数字段的可见性.....................108
4.3 定义辅助构造函数.................................... 111
4.4 定义私有的主构造函数............................115
4.5 设置构造函数参数的默认值.....................116
4.6 覆写默认的访问和修改方法.....................118
4.7 阻止生成getter 和setter 方法......................121
4.8 将代码块或者函数赋给字段.....................123
4.9 设置未初始化的var 字段类型....................125
4.10 在继承类时处理构造函数参数...............127
4.11 调用父类的构造函数..............................129
4.12 何时使用抽象类......................................131
4.13 在抽象基类(或者特质) 里定义属性........133
4.14 用Case 类生成模板代码..........................137
4.15 定义一个equals 方法（对象的相等性）..141
4.16 创建内部类........................................144
第5章方法............147
5.1 控制方法作用域.......................................148
5.2 调用父类的方法.......................................152
5.3 方法参数默认值.......................................154
5.4 使用参数名........................................157
5.5 定义一个返回多个值(Tuples) 的方法........159
5.6 调用getter/setter 方法时不使用括号..........160
5.7 创建接受变参的方法................................162
5.8 方法的异常声明......................................164
5.9 支持链式调用编码风格............................166解决办法...167
第6章对象............170
6.1 对象的强制转换.......................................171
6.2 Java.class 的Scala 等价类...........................173
6.3 确定对象所属的类....................................174
6.4 用Object 启动一个应用.............................175
6.5 用object 创建单例......................................177
6.6 用伴生类创建静态成员............................178
6.7 将通用代码放入包对象............................180
6.8 不使用new 关键字创建对象实例...............183
6.9 在Scala 中用apply 方法实现工厂方法........187
第7章包和导入.....190
7.1 花括号风格的包记号法............................191
7.2 引入一个或多个成员................................192
7.3 在导入时重命名成员................................194
7.4 在引入时隐藏一个类................................195
7.5 使用静态导入........................................196
7.6 在任意地方使用Import 语句......................197
第8章特质............200
8.1 特质用作接口........................................200
8.2 使用特质中的抽象字段和实际字段..........203
8.3 像抽象类一样使用特质............................204
8.4 简单混入特质........................................205
8.5 通过继承来限制特质的使用范围.............206
8.6 限定特质只可用于指定类型的子类..........208
8.7 保证特质只能被添加到只有一个特定方法的类型..........................210
8.8 为对象实例中添加特质............................211
8.9 像特质一样继承一个Java 接口..................212
第9章函数式编程..214
9.1 使用函数字面量（匿名函数）.................215
9.2 将函数作为变量.......................................216
9.3 定义接受简单函数作为参数的方法..........220
9.4 更多复杂的函数.......................................222
9.5 使用闭包........................................226
9.6 使用部分应用函数....................................231
9.7 创建返回函数的函数................................232
9.8 创建部分应用函数....................................235
9.9 一个真实的例子.......................................239
第10 章集合..........242
10.1 理解集合的层级结构..............................243
10.2 选择一个集合类......................................247
10.3 用一个集合方法解决一个问题...............252
10.4 理解集合的性能......................................258
10.5 在创建集合时声明一个类型...................260
10.6 理解可变变量与不可变集合...................262
10.7 将Vector“变为”不可变序列................263
10.8 把ArrayBuffer 作为可变序列的第一选择265
10.9 用foreach 遍历一个集合..........................267
10.10 用for 循环遍历一个集合........................269
10.11 使用zipWithIndex 或者zip 创建循环计数器........................272
10.12 迭代器的使用.......................................275
10.13 用for/yield 实现集合间的转换...............276
10.14 用map 实现集合的变换.........................279
10.15 展平列表的列表与扁平化问题.............281
10.16 map，flatten 和flatMap 的组合...............283
10.17 用filter 过滤一个集合...........................285
10.18 从集合中提取元素序列........................287
10.19 序列的分割（groupBy 、partition 等）..289
10.20 用reduce 和fold 方法遍历集合...............291
10.21 从序列中提取不重复的元素................296
10.22 合并序列集合.......................................297
10.23 用zip 将两个序列集合合并为一对.........300
10.24 在集合上创建一个惰性视图.................301
10.25 利用Range 创建集合..............................305
10.26 创建使用枚举.......................................307
10.27 当需要一堆元素时使用元组.................308
10.28 集合排序........................................310
10.29 通过mkString 将集合转换成字符串......313
第11 章列表、数组、映射、集及其他..........................315
11.1 创建和填充列表的不同方式...................316
11.2 创建可变List........................................318
11.3 为List 添加元素.......................................319
11.4 从List（或者ListBuffer）中删除元素.....321
11.5 合并或连接列表......................................323
11.6 使用List 的懒惰版本，Stream.................324
11.7 创建和更新数组的不同方式...................326
11.8 创建大小可变的数组（ArrayBuffer）....328
11.9 删除Array 和ArrayBuffer 的元素..............329
11.10 数组排序........................................331
11.11 创建多维数组........................................332
11.12 创建映射........................................334
11.13 选择一种Map 实现.................................336
11.14 为可变映射添加、更新或删除元素......338
11.15 为不可变映射添加、更新或删除元素..340
11.16 访问映射的值........................................342
11.17 遍历映射........................................344
11.18 从映射中获得所有的键或者值.............345
11.19 反转键值........................................346
11.20 测试映射中键/值的存在........................347
11.21 过滤映射........................................348
11.22 根据键或者值对映射排序.....................350
11.23 找到映射中最大的键或者值.................354
11.24 给集添加元素........................................355
11.25 从集中删除元素....................................357
11.26 使用可排序集........................................359
11.27 使用队列........................................360
11.28 使用栈........................................362
11.29 使用Range........................................365
第12 章文件和进程367
12.1 如何打开和读取文本文件.......................367
12.2 写入文本文件........................................373
12.3 读写二进制文件......................................374
12.4 如何处理文本文件中的每个字符...........375
12.5 如何处理CSV 文件.................................376
12.6 将字符串伪装为文件..............................379
12.7 使用序列化........................................381
12.8 列出目录中的文件.................................382
12.9 列举目录之下的子目录..........................384
12.10 执行外部命令.......................................385
12.11 执行外部命令并使用标准输出.............388
12.12 处理外部命令的标准输出和标准错误输出............................390
12.13 构建命令管道.......................................392
12.14 重定向外部命令的标准输出和标准输入.................................393
12.15 在进程中使用AND（&&）和OR（｜｜）395
12.16 外部命令中处理通配符........................396
12.17 如何在不同目录下运行进程.................397
12.18 在运行命令时设置环境变量.................398
12.19 执行外部命令的方法索引....................399
第13 章Actors 和并发........................................401
13.1 Actor 简单入门........................................403
13.2 创建构造函数有参数的actor...................407
13.3 Actor 之间如何通信.................................409
13.4 理解Akka Actor 生命周期方法................411
13.5 启动Actor ........................................414
13.6 停止Actors........................................416
13.7 关闭Akka Actor 系统...............................421
13.8 用watch 监控Actor 的死亡.......................422
13.9 Futures 的简单并发.................................425
13.10 给Actor 发消息并等待回复...................433
13.11 用become 切换不同状态........................434
13.12 使用并发集合.......................................436
第14 章命令行任务440
14.1 Scala REPL 初体验..................................441
14.2 往REPL 中粘贴和加载代码块.................445
14.3 在REPL 的Classpath 中添加JAR 文件和类...............................448
14.4 在REPL 中运行Shell 命令........................449
14.5 用scalac 命令编译，scala 命令运行.........451
14.6 反汇编和反编译Scala 代码......................452
14.7 寻找Scala 类库........................................457
14.8 用scaladoc 生成文档................................458
14.9 更快的命令行编译器fsc..........................463
14.10 将Scala 作为脚本语言使用....................464
14.11 通过脚本访问命令行参数.....................468
14.12 在Scala shell 脚本中输入提示...............469
14.13 让Scala 脚本运行得更快........................473
第15 章Web 服务...475
15.1 从Scala 对象中创建JSON 字符串.............475
15.2 从包含集合的类中生成JSON 字符串......479
15.3 从JSON 字符串生成简单Scala 对象.........484
15.4 将JSON 数据解析成为对象的数组..........485
15.5 用Scalatra 创建Web 服务..........................487
15.6 用Scalatra 挂载替换XML Servlet 映射.....490
15.7 访问Scalatra Web 服务的GET 参数..........492
15.8 用Scalatra 处理POST 请求数据................494
15.9 创建一个简单的GET 请求客户端............497
15.10 向POST 链接发送JSON 数据.................501
15.11 获取URL Headers .................................502
15.12 发送请求时设置链接的Headers............503
15.13 用Play 框架创建一个GET 请求的Web 服务..........................504
15.14 向Play 框架的web 服务POST JSON 数据507
第16 章数据库和持久化........................................510
16.1 用JDBC 连接MySQL...............................511
16.2 用Spring Framework 连接数据库............513
16.3 连接MongoDB 并且插入数据..................516
16.4 用insert，save 或者+= 把文档插入到MongoDB .......................519
16.5 搜索一个MongoDB 集合.........................521
16.6 更新MongoDB 集合中的文档..................525
16.7 获取MongoDB 文档ID.............................526
16.8 删除MongoDB 集合中的文档..................527
16.9 快速浏览Slick........................................529
第17 章与Java 交互........................................531
17.1 与Java 集合的转换..................................531
17.2 给Scala 方法添加异常注解以便与Java 交互........................536
17.3 使用@SerialVersionUID 和其他注解.......538
17.4 使用Spring 框架......................................539
17.5 注解变长参数方法..................................542
17.6 当Java 的代码需要JavaBeans ..................543
17.7 包装特质的实现......................................547
第18 章简单构建工具（SBT）....................................551
18.1 用SBT 创建一个项目目录结构................551
18.2 用SBT 编译、运行和打包一个Scala 项目555
18.3 用SBT 和ScalaTest 运行测试....................560
18.4 用SBT 管理依赖......................................562
18.5 控制所使用的可管理依赖的版本...........565
18.6 创建有子项目的项目..............................567
18.7 在Eclipse 中使用SBT...............................569
18.8 生成项目API 文档...................................571
18.9 指定一个Main 类运行..............................572
18.10 使用GitHub 项目作为项目依赖.............574
18.11 告诉SBT 如何找到一个仓库（使用Resolvers）........................575
18.12 通过SBT 堆栈跟踪解决问题..................576
18.13 设置SBT 日志等级................................577
18.14 部署一个单独的、可执行的JAR 文件...578
18.15 发布类库........................................581
18.16 用Build.scala 取代build.sbt....................582
18.17 在SBT 中使用Maven 仓库的类库...........584
18.18 用Ant 构建Scala 项目.............................586
第19 章类型..........589
19.1 创建使用泛型的类..................................591
19.2 创建一个接收简单泛型的方法...............595
19.3 使用鸭子类型（结构化类型）...............596
19.4 让可变集合非变......................................598
19.5 让不可变集合协变..................................600
19.6 创建所有元素都是基本类型的集合........602
19.7 给封闭模型选择性添加新行为...............605
19.8 用类型构建功能......................................608
第20 章惯用法.......612
20.1 创建没有副作用的方法（纯函数）........613
20.2 选择不可变对象......................................620
20.3 思考“面向表达式编程”.......................624
20.4 使用匹配表达式和模式匹配...................627
20.5 从代码中根除null 值................................630
20.6 使用Option/Some/None 模式..................634
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala 编程实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala学习手册
前言
**部分Scala核心
**章可扩展语言概述
安装Scala
使用Scala REPL
小结
练习
第2章处理数据：字面量、值、变量和类型
值
变量
命名
类型
小结
练习
第3章表达式和条件式
表达式
if...else表达式块
匹配表达式
循环
小结
练习
第4章函数
过程
用空括号定义函数
使用表达式块调用函数
递归函数
嵌套函数
用命名参数调用函数
有默认值的参数
Vararg参数
参数组
类型参数
方法和操作符
编写可读的函数
小结
练习
第5章首类函数
函数类型和值
高阶函数
函数字面量
占位符语法
部分应用函数和柯里化
传名参数
偏函数
用函数字面量块调用高阶函数
小结
练习
第6章常用集合
列表、集和映射
List里有什么？
列表算术运算
映射列表
归约列表
转换集合
使用集合的模式匹配
小结
练习
第7章更多集合
可变集合
数组
Seq和序列
Stream
一元集合
小结
练习
第二部分面向对象Scala
第8章类
定义类
更多类类型
更多字段和方法类型
包装
私密性控制
私密性访问修饰符
*终类和密封类
小结
练习
第9章对象、Case类和Trait
对象
Trait
导入实例成员
小结
中场休息——配置你的**个Scala项目
练习
**0章高级类型
元组和函数值类
隐含参数
隐含类
类型
小结
思考题
附录A保留字
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala学习手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高性能Scala
前言 iX
1 高性能之路  1
-性能的定义 2
- - 高性能软件 2
- - 硬件资源  3
- - 时延和吞吐率  4
- - 瓶颈 5
-性能总结  5
- - 平均数的问题  6
- - 百分位数来救场  8
-指标搜集  9
- - 用基准数据（benchmark）来衡量性能. 9
- - 通过Profiling 来定位瓶颈  10
- - 结合基准测试和profiling  10
-案例分析  11
-工具链 11
-小结  12
2 在JVM 上度量性能 13
-金融领域一瞥 13
-意外的市场波动毁掉了利润 16
-重现故障  17
- - 吞吐量基准测试  17
- - 时延基准测试 20
- - 定位瓶颈  25
- - 微基准取得大进步  42
-小结  49
3 释放Scala 的性能  51
-值类  52
- - 字节码表示  52
- - 性能考虑  54
- - 标记类型——值类的一种替代品  55
-专门化 57
字节码表示  58
性能考虑  60
-元组  65
- - 字节码表示  65
- - 性能考虑  66
-模式匹配  68
- - 字节码表示  68
- - 性能考虑  70
-尾递归 75
- - 字节码表示  78
- - 性能考虑  79
-Option 数据类型  83
- - 字节码表示  83
- - 性能考虑  84
-案例研究——性能更高的Option  85
-小结  89
4 探索集合API 91
-高吞吐量系统 - 改进指令簿  91
- - 理解过去实现上的折中 - list 实现  92
- - 当前的指令簿 - queue 实现  101
- - 通过惰性计算来提升取消操作的性能 104
-历史数据分析  114
- - 滞后时序收益率（lagged time series returns）  114
- - 处理多个收益率序列  122
-小结  127
5 惰性集合及事件溯源  129
-提升用户报表生成速度 129
- - 深入报表生成代码  130
- - 使用视图提速报表生成 133
- - 视图的注意事项 141
- - 打包报表生成结果  145
-重新思考报表架构  146
- - Stream 概览  149
- - 事件变换 152
- - 构建事件源管道 158
- - 马尔可夫流式链 162
- - 流的注意事项  166
-小结  169
6 Scala 的并发  171
-并行回测（backtesting）策略  171
- - 探索Future 173
- - Future 和crazy ideas 177
- - Future 使用时的考量  179
- - 提交执行妨碍性能  185
-处理阻塞调用和回调  188
- - ExecutionContext 和阻塞调用  189
- - 用Promise 转化回调  193
-受命进一步提升回测性能  196
- - 介绍Scalaz Task 197
- - 用Task 为交易日模拟建模  204
- - 总结回测 209
-小结  210
7 高性能架构  211
-分布式自动化交易员（Distributed automated traders）  211
- - 分布式架构概述 212
- - 第一次尝试分布式自动化交易系统  212
- - 引入CRDT 214
- - CRDT 和自动化交易系统 219
- - 当余额不足时  220
-免费交易策略性能提升 222
- - 为交易策略做基准测试 222
- - 无界队列（unbounded queue）的危险 225
- - 应用背压（back pressure） 226
- - 应用负载控制策略  227
- - Free monad 233
-小结  240
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高性能Scala
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala集合技术手册
推荐序 iii
序  iv
第 1 章 Scala 集合库简介 1
Scala 编程语言  1
Scala 集合  2
谁应该阅读此书  7
为什么写这本书  7
印刷体变化  7
内容概要 8
第 2 章 Traversable  9
初始化 Traversable 对象  10
集合的静态类型和类型擦除  12
对 Traversable 实例中每个元素执行操作（foreach）  13
平展一个 Traversable 实例 14
转置 Traversable 集合（transpose）  17
unzip 一个 Traversable 18
连接两个 Traversable 到一个新的 Traversable  19
连接多个 Traversable 对象到一个新的 Traversable  21
利用偏函数筛选元素 22
对所有的元素应用一个函数，并将结果放入一个新的 Traversable 对象中 23
利用 scan 计算 Traversable 元素的阶乘 24
使用指定的函数折叠 Traversable 的元素 26
判断一个 Traversable 非空  28
得到 Traversable 对象的特定的元素 29
得到 Traversable 对象的尾部  30
选择 Traversable 的一段子集  31
选取 Traversable 对象的前 N 个元素 32
跳过开头的前 N 个元素，选择剩余的元素 33
根据条件筛选元素 34
给 Traversable 对象的元素分组  35
检查 Traversable 对象中的元素是否满足条件  37
统计满足断言的元素个数 37
归约操作  38
在 Traversable 对象上调用聚合函数  40
基于 Traversable 对象生成字符串  41
集合类型转换  42
复制元素到一个数组 44
返回一个 Traversable 对象的视图 view 45
得到 Traversable 对象的底层实现  46
使用一个相同的元素填充元素  46
在某个值域上生成指定间隔的队列 47
tabulate  48
生成空的 Traversable 对象 48
得到 Traversable 对象的串行对象和并行对象  49
第 3 章 Iterable 51
将 Iterable 对象分组  53
以滑动窗口的方式分组 Iterable 对象  54
zip 两个集合 55
zipAll 两个长度不同的集合  56
使用本身的索引 zip 一个 Iterable 集合 57
检查两个 Iterables 是否包含相同的元素 57
得到尾部的 N 个元素 58
去掉尾部的 N 个元素 59
第 4 章 Seq  60
得到序列的索引集合 61
序列的长度  61
得到指定索引的元素 62
寻找指定元素的索引 63
寻找满足条件的元素索引 64
寻找指定的子序列  64
寻找满足条件的子序列的长度  65
增加元素到序列中  65
替换序列中的元素  66
更新指定位置的索引 66
排序  67
反转一个序列  68
序列是否包含某个前缀或者后缀  69
序列是否包含某子序列 69
检查两个序列对应的元素是否满足断言 69
集合操作  70
去掉重复的元素 71
得到元素的各种排列 72
得到序列的指定长度的元素的组合 72
将序列进行转换 73
偏函数的应用  74
IndexedSeq 和 LinearSeq  75
Range 和 NumericRange   76
Vector   77
第 5 章 Set  80
检查 Set 集合是否包含元素 82
增加一个元素或者一组元素到 Set 集合中  82
从 Set 集合中去掉一个元素或一组元素 83
二元 Set 集合运算  84
更新一个可变 Set 集合的元素 85
克隆 Set 集合  86
SortedSet  86
BitSet  88
HashSet  90
ListSet   91
LinkedHashSet   92
第 6 章 Map  94
初始化  94
根据键值查找值 95
包含  96
增加新的键值对 97
删除键  97
根据键更新它的值  98
得到键的集合 99
得到值的集合  99
遍历 Map 集合  100
如何将一个可变 Map 集合转换成不可变 Map 集合  100
新的转换函数  101
偏函数 101
克隆  102
反转 Map 的键值对 102
将一个 Set 集合转换成 Map 集合 103
IntMap, LongMap  103
HashMap   104
SortedMap 和 immutable.TreeMap  104
immutable.ListMap,mutable.ListMap  105
mutable.LinkedHashMap 105
mutable.MultiMap  106
mutable.OpenHashMap  107
mutable.WeakHashMap  107
第 7 章 数组109
数组的初始化  110
数组的长度 112
更新数组  113
连接两个数组  113
复制数组  113
生成等差数列 114
填充数组  114
tabulate 115
ArrayOps  115
Searching  116
WrappedArray 116
第 8 章 字符串（String 和 StringBuilder） 117
字符串方法 118
拼接字符串多次  119
把首字母大写  119
字符串比较 120
字符串格式化 120
按照换行符分割字符串  123
正则表达式 124
分割字符串 124
strip 字符串 125
集合方法  126
字符串窜改（String Interpolation） 126
StringBuilder  128
第 9 章 缓冲器 129
增加元素  129
移除元素 130
Trim、clear 和 clone 131
ListBuffer, ArrayBuffer  132
RingBuffer  132
第 10 章 列表 134
Nil, :: 134
初始化，以及 :: 和 ::: 操作符 135
模式匹配  136
MutableList 136
使用列表实现快速排序  137
Option 137
第 11 章 栈和队列 139
栈（Stack）139
ArrayStack . 141
不可变队列（immutable.Queue） 143
可变队列（mutable.Queue） 144
优先级队列（PriorityQueue）  144
第 12 章 流 147
初始化：#:: 和 #:::  148
流相关类  150
记忆化（memoization） 150
栈溢出（StackOverflowError） 150
OOM 问题 152
无限随机数流 153
无限整数流 153
中缀表达式和模式匹配  153
无限流 154
蓄水池抽样算法  156
第 13 章 并行集合 158
并行集合的类型  159
可产生副作用的操作（Side-Effecting Operations） 160
非结合操作（Non-Associative Operations）161
性能 162
串行集合和并行集合的转换 163
不同集合类型之间的转换 164
并发集合配置  165
第 14 章 Scala 集合总结 168
相等（Equality） 168
性能  170
与 Java 集合类的转换 172
技巧和陷阱 174
发布订阅类 177
for 推导式 （for comprehensions）  178
其他集合库 179
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala集合技术手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala 实用指南
第一部分　小试牛刀 1
第1章　探索Scala 3
1.1　Scala的特性 3
1.2　以少胜多 4
1.3　函数式编程 8
1.4　小结 11
第 2章　体验Scala 12
2.1　使用REPL 12
2.2　命令行上的Scala 14
2.3　以独立脚本方式运行Scala代码 15
2.3.1　在类Unix系统上以独立脚本方式运行 15
2.3.2　在Windows上以独立脚本方式运行 16
2.3.3　Scala的IDE支持 16
2.4　编译Scala 17
2.5　小结 17
第3章　从Java到Scala 18
3.1　Scala：简洁的Java 18
3.1.1　减少样板代码 18
3.1.2　更多便利特性 19
3.1.3　转向函数式风格 21
3.2　Java原始类型对应的Scala类 21
3.3　元组和多重赋值 22
3.4　灵活的参数和参数值 24
3.4.1　传递变长参数值 24
3.4.2　为参数提供默认值 25
3.4.3　使用命名参数 26
3.5　隐式参数 27
3.6　字符串和多行原始字符串 29
3.7　字符串插值 30
3.8　合理的约定 32
3.9　操作符重载 33
3.10　Scala与Java的差异 35
3.10.1　赋值的结果 36
3.10.2　Scala的== 36
3.10.3　可有可无的分号 37
3.10.4　避免显式return 38
3.11　默认访问修饰符 39
3.11.1　定制访问修饰 39
3.11.2　Scala的protected 40
3.11.3　细粒度的访问控制 41
3.12　小结 43
第4章　处理对象 44
4.1　创建并使用类 44
4.1.1　创建实例 44
4.1.2　创建类 45
4.1.3　定义字段、方法和构造器 46
4.2　遵循JavaBean惯例 49
4.3　类型别名 50
4.4　扩展一个类 51
4.5　参数化类型 52
4.6　单例对象和伴生对象 54
4.6.1　单例对象 54
4.6.2　独立对象和伴生对象 56
4.6.3　Scala中的static 57
4.7　创建枚举类 59
4.8　包对象 60
4.9　小结 63
第5章　善用类型 64
5.1　类型推断 64
5.1.1　简单类型的类型推断 64
5.1.2　针对泛型和集合的类型推断 66
5.2　基础类型 68
5.2.1　Any类型 68
5.2.2　关于Nothing 69
5.2.3　Option类型 70
5.2.4　Either类型 71
5.3　返回值类型推断 73
5.4　参数化类型的型变 75
5.4.1　协变和逆变 75
5.4.2　支持协变 76
5.4.3　支持逆变 77
5.4.4　定制集合的型变 78
5.5　隐式类型转换 78
5.5.1　隐式函数 79
5.5.2　隐式类 81
5.6　值类 83
5.7　使用隐式转换 86
5.8　小结 88
第二部分　深入Scala 89
第6章　函数值和闭包 91
6.1　常规函数的局限性 91
6.2　可扩展性与高阶函数 92
6.3　具有多个参数的函数值 93
6.4　柯里化 96
6.5　参数的占位符 97
6.6　参数路由 98
6.7　复用函数值 99
6.8　部分应用函数 101
6.9　闭包 102
6.10　Execute Around Method模式 103
6.11　小结 106
第7章　特质 107
7.1　理解特质 107
7.2　选择性混入 110
7.3　使用特质实现装饰器模式 111
7.4　特质中的方法延迟绑定 113
7.5　小结 115
第8章　集合 116
8.1　常见的Scala集合 116
8.2　使用Set 118
8.3　关联映射 119
8.4　不可变列表 121
8.5　方法名约定 124
8.6　for表达式 126
8.7　小结 128
第9章　模式匹配和正则表达式 129
9.1　模式匹配综述 129
9.1.1　匹配字面量和常量 129
9.1.2　匹配通配符 130
9.1.3　匹配元组和列表 131
9.1.4　匹配类型和守卫 132
9.2　case表达式中的模式变量和常量 133
9.3　使用case类进行模式匹配 135
9.4　提取器和正则表达式 138
9.4.1　使用提取器进行模式匹配 138
9.4.2　正则表达式 141
9.4.3　正则表达式作为提取器 142
9.5　无处不在的下划线字符 143
9.6　小结 144
第 10章　处理异常 145
10.1　Scala中的异常 145
10.2　注意catch的顺序 147
10.3　小结 149
第 11章　递归 150
11.1　一个简单的递归 150
11.2　尾调用优化（TCO） 151
11.2.1　常规递归并无优化 152
11.2.2　用尾调用优化来拯救 152
11.2.3　确保尾调用优化 154
11.3　蹦床调用 155
11.4　小结 158
第三部分 Scala中的并发编程 159
第 12章　惰性求值和并行集合 161
12.1　释放惰性 161
12.2　释放严格集合的惰性 164
12.3　终极惰性流 167
12.4　并行集合 170
12.4.1　从顺序集合入手 171
12.4.2　使用并行集合加速 173
12.5　小结 175
第 13章　使用Actor编程 176
13.1　一个顺序耗时问题 176
13.2　曲折的并发之路 178
13.3　创建Actor 179
13.4　Actor和线程 181
13.5　隔离可变性 182
13.6　使用Actor模型进行并发 186
13.7　使用建议 189
13.8　小结 190
第四部分 Scala实战 191
第 14章　和Java进行互操作 193
14.1　在Scala中使用Scala类 193
14.2　在Scala中使用Java类 195
14.3　在Java中使用Scala方法 197
14.4　在Java中使用特质 198
14.5　在Java中使用单例对象和伴生对象 201
14.6　扩展类 203
14.7　小结 204
第 15章　使用Scala创建应用程序 205
15.1　获取用户输入 205
15.2　读写文件 206
15.3　XML作为一等公民 207
15.4　读写XML 210
15.5　从Web获取股票价格 213
15.6　编写并发的资产净值应用程序 216
15.7　小结 217
第 16章　单元测试 218
16.1　使用JUnit 218
16.2　使用ScalaTest 220
16.3　使用Mockito 221
16.3.1 函数式风格的测试 221
16.3.2　创建一个Mock 223
16.4　小结 227
附录A　安装Scala 228
参考文献 230
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala 实用指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>反应式设计模式
第Ⅰ部分  简介
第1章  为什么需要反应式?   3
1.1  剖析反应式应用   5
1.2  应对负载   6
1.3  应对失败   7
1.4  让系统即时响应   9
1.5  避免大泥球   10
1.6  整合非反应式组件   11
1.7  小结   12
第2章  《反应式宣言》概览   13
2.1  对用户作出反应   13
2.1.1  理解传统方法   14
2.1.2  使用共享资源的延迟分析   16
2.1.3  使用队列限制最大延迟   17
2.2  利用并行性   18
2.2.1  通过并行化降低延迟   19
2.2.2  使用可组合的Future改善并行性   21
2.2.3  为序列式执行表象买单   22
2.3  并行执行的限制   24
2.3.1  阿姆达尔定律   24
2.3.2  通用伸缩性法则   25
2.4  对失败作出反应   26
2.4.1  划分与隔离   28
2.4.2  使用断路器   29
2.4.3  监督   30
2.5  放弃强一致性   32
2.5.1  ACID 2.0   33
2.5.2  接受更新   34
2.6  对反应式设计模式的需求   35
2.6.1  管理复杂性   36
2.6.2  使编程模型更贴近真实世界   37
2.7  小结   38
第3章  行业工具   39
3.1  反应式的早期解决方案   39
3.2  函数式编程   41
3.2.1  不可变性   42
3.2.2  引用透明性   44
3.2.3  副作用   45
3.2.4  函数作为一等公民   46
3.3  即时响应用户   47
3.4  对反应式设计的现有支持   49
3.4.1  绿色线程   49
3.4.2  事件循环   50
3.4.3  通信顺序进程   51
3.4.4  Future和Promise   53
3.4.5  反应式扩展工具包   58
3.4.6  Actor模型   59
3.5  小结   64
第Ⅱ部分  微言大义
第4章  消息传递   67
4.1  消息   67
4.2  垂直伸缩   68
4.3 “基于事件”与“基于消息”   69
4.4  “同步”与“异步”   71
4.5  流量控制   73
4.6  送达保证   75
4.7  作为消息的事件   77
4.8  同步消息传递   79
4.9  小结   79
第5章  位置透明性   81
5.1  什么是位置透明性？   81
5.2  透明化远程处理的谬误   82
5.3  基于显式消息传递的纠正方案   83
5.4  优化本地消息传递   84
5.5  消息丢失   85
5.6  水平扩展性   87
5.7  位置透明性使测试更加简单   88
5.8  动态组合   88
5.9  小结   90
第6章  分而治之   91
6.1  分层拆解问题   92
6.2 “依赖”与“子模块”   94
6.3  构建你自己的大公司   96
6.4  规范和测试的优点   97
6.5  水平扩展性和垂直伸缩性   98
6.6  小结   99
第7章  原则性失败处理   101
7.1  所有权意味着承诺   101
7.2  所有权隐含生命周期控制   103
7.3  所有级别上的回弹性   104
7.4  小结   105
第8章  有界一致性   107
8.1  封装模块纠正方案   108
8.2  根据事务边界对数据和行为进行分组   109
8.3  跨事务边界建模工作流   109
8.4  失败单元即一致性单元   110
8.5  分离职责   111
8.6  坚持一致性的隔离范围   113
8.7  小结   114
第9章  按需使用非确定性   115
9.1  逻辑编程和声明式数据流   115
9.2  函数式反应式编程   117
9.3  不共享简化并发   118
9.4  共享状态的并发   119
9.5  如何窘境突围？   119
9.6  小结   121
第10章  消息流   123
10.1  推动数据向前流动   123
10.2  模型化领域流程   125
10.3  认清回弹性的局限性   125
10.4  估计速率和部署规模   126
10.5  为流量控制进行规划   127
10.6  小结   127
第Ⅲ部分  设计模式
第11章  测试反应式应用程序   131
11.1  如何测试   131
11.1.1  单元测试   132
11.1.2  组件测试   133
11.1.3  联动测试   133
11.1.4  集成测试   133
11.1.5  用户验收测试   134
11.1.6  黑盒测试与白盒测试   134
11.2  测试环境   135
11.3  异步测试   136
11.3.1  提供阻塞的消息接收者   137
11.3.2  选择超时时间的难题   139
11.3.3  断言消息的缺失   145
11.3.4  提供同步执行引擎   146
11.3.5  异步断言   148
11.3.6  完全异步的测试   149
11.3.7  断言没有发生异步错误   151
11.4  测试非确定性系统   154
11.4.1  执行计划的麻烦   155
11.4.2  测试分布式组件   155
11.4.3  模拟Actor   156
11.4.4  分布式组件   157
11.5  测试弹性   157
11.6  测试回弹性   158
11.6.1  应用程序回弹性   158
11.6.2  基础设施的回弹性   162
11.7  测试即时响应性   164
11.8  小结   165
第12章  容错及恢复模式   167
12.1  简单组件模式   167
12.1.1  问题设定   168
12.1.2  模式应用   168
12.1.3  模式回顾   170
12.1.4  适用性   171
12.2  错误内核模式   171
12.2.1  问题设定   172
12.2.2  模式应用   172
12.2.3  模式回顾   175
12.2.4  适用性   176
12.3  放任崩溃模式   176
12.3.1  问题设定   177
12.3.2  模式应用   177
12.3.3  模式回顾   178
12.3.4  实现上的考虑   179
12.3.5  推论：心跳模式   180
12.3.6  推论：主动失败信号模式   180
12.4  断路器模式   181
12.4.1  问题设定   182
12.4.2  模式应用   182
12.4.3  模式回顾   186
12.4.4  适用性   187
12.5  小结   187
第13章  复制模式   189
13.1  主动-被动复制模式   190
13.1.1  问题设定   190
13.1.2  模式应用   191
13.1.3  模式回顾   203
13.1.4  适用性   204
13.2  多主复制模式   204
13.2.1  基于共识的复制   205
13.2.2  具有冲突检测与处理方案的复制方式   208
13.2.3  无冲突的可复制数据类型   210
13.3  主动-主动复制模式   217
13.3.1  问题设定   218
13.3.2  模式应用   218
13.3.3  模式回顾   225
13.3.4  与虚拟同步模型的关系   226
13.4  小结   227
第14章  资源管理模式   229
14.1  资源封装模式   229
14.1.1  问题设定   230
14.1.2  模式应用   230
14.1.3  模式回顾   236
14.1.4  适用性   237
14.2  资源借贷模式   237
14.2.1  问题设定   238
14.2.2  模式应用   238
14.2.3  模式回顾   240
14.2.4  适用性   241
14.2.5  实现上的考虑   242
14.2.6  变体：使用资源借贷模式进行局部公开   242
14.3  复杂命令模式   243
14.3.1  问题设定   243
14.3.2  模式应用   244
14.3.3  模式回顾   251
14.3.4  适用性   252
14.4  资源池模式   252
14.4.1  问题设定   253
14.4.2  模式应用   253
14.4.3  模式回顾   255
14.4.4  实现上的考虑   256
14.5  托管阻塞模式   257
14.5.1  问题设定   257
14.5.2  模式应用   258
14.5.3  模式回顾   260
14.5.4  适用性   261
14.6  小结   262
第15章  消息流模式   263
15.1  请求-响应模式   264
15.1.1  问题设定   264
15.1.2  模式应用   265
15.1.3  该模式的常见实例   267
15.1.4  模式回顾   272
15.1.5  适用性   272
15.2  消息自包含模式   273
15.2.1  问题设定   273
15.2.2  模式应用   274
15.2.3  模式回顾   276
15.2.4  适用性   277
15.3  询问模式   277
15.3.1  问题设定   278
15.3.2  模式应用   278
15.3.3  模式回顾   281
15.3.4  适用性   283
15.4  转发流模式   283
15.4.1  问题设定   283
15.4.2  模式应用   284
15.4.3  模式回顾   284
15.4.4  适用性   285
15.5  聚合器模式   285
15.5.1  问题设定   285
15.5.2  模式应用   286
15.5.3  模式回顾   289
15.5.4  适用性   290
15.6  事务序列模式   290
15.6.1  问题设定   291
15.6.2  模式应用   291
15.6.3  模式回顾   293
15.6.4  适用性   294
15.7  业务握手协议(或可靠投递模式)   294
15.7.1  问题设定   295
15.7.2  模式应用   295
15.7.3  模式回顾   300
15.7.4  适用性   301
15.8  小结   301
第16章  流量控制模式   303
16.1  拉取模式   303
16.1.1  问题设定   304
16.1.2  模式应用   304
16.1.3  模式回顾   306
16.1.4  适用性   307
16.2  托管队列模式   307
16.2.1  问题设定   308
16.2.2  模式应用   308
16.2.3  模式回顾   310
16.2.4  适用性   310
16.3  丢弃模式   311
16.3.1  问题设定   311
16.3.2  模式应用   311
16.3.3  模式回顾   313
16.3.4  适用性   316
16.4  限流模式   316
16.4.1  问题设定   316
16.4.2  模式应用   317
16.4.3  模式回顾   320
16.5  小结   320
第17章  状态管理和持久化模式   321
17.1  领域对象模式   321
17.1.1  问题设定   322
17.1.2  模式应用   322
17.1.3  模式回顾   326
17.2  分片模式   326
17.2.1  问题设定   326
17.2.2  模式应用   327
17.2.3  模式回顾   329
17.2.4  重要警告   329
17.3  事件溯源模式   330
17.3.1  问题设定   330
17.3.2  模式应用   330
17.3.3  模式回顾   333
17.3.4  适用性   333
17.4  事件流模式   334
17.4.1  问题设定   334
17.4.2  模式应用   334
17.4.3  模式回顾   336
17.4.4  适用性   337
17.5  小结   337
附录A  反应式系统图示   339
附录B  一个虚构的案例   341
附录C 《反应式宣言》正文   355
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>反应式设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala语言基础与开发实战
前言
基础篇
第1章Scala零基础入门
11Scala概述
12Windows及Linux下Scale运行环境安装配置
121软件工具准备
122Windows环境下的Scala安装
123Linux环境下的Scala安装
124Linux环境下的Hadoop安装与配置
125Linux环境下的Spark安装与配置
13Scala开发环境搭建和HelloWorld实例
131Scala集成开发工具的安装
132HelloWorld编程实例
133WorkSheet的使用
14变量的使用
141Scala解释器中的变量示例
142val变量的定义
143var变量的定义
144var变量与val变量的使用比较
15函数的定义、流程控制、异常处理
151函数的定义
152流程控制（if、while、for）
153异常处理
16Tuple、Array、Map与文件操作
161Tuple元组
162Array数组
163文件操作
164Map映射
17Scala中的apply方法
171Object中的apply
172Class中的apply
173Array数组的apply实现
18小结
第2章Scala面向对象编程开发
21类的定义及属性
211类定义
212带有getter和setter的属性
22主构造器、私有构造器、构造器重载
221构造器重载之辅助构造器
222主构造器
223不同访问权限的构造器
23内部类和外部类
24单例对象、伴生对象
25继承：超类的构造、重写字段、重写方法
251超类的构造
252重写字段
253重写方法
26抽象类、抽象字段、抽象方法
261抽象类
262抽象字段
263抽象方法
27trait特质
271作为接口使用的trait
272在对象中混入trait
273trait深入解析
28多重继承、多重继承构造器执行顺序及AOP实现
281多重继承
282多重继承构造器执行顺序
283AOP实现
29包的定义、包对象、包的引用、包的隐式引用
291包的定义
292包对象
293包的引用
294包的隐式引用
210包、类、对象、成员、伴生类、伴生对象访问权限
2101包、类、对象、成员访问权限
2102伴生类、伴生对象访问权限
211小结
第3章Scala高阶函数
31匿名函数
32偏应用函数
33闭包
34SAM转换
35Curring函数
36高阶函数
37高阶函数在Spark中的应用
38小结
中级篇
第4章Scala模式匹配
41模式匹配简介
42模式匹配类型
421常量模式
422变量模式
423构造器模式
424序列（Sequence)模式
425元组（Tuple)模式
426类型模式
427变量绑定模式
43模式匹配与Case Class
431构造器模式匹配原理
432序列模式匹配原理
433Sealed Class在模式匹配中的应用
44模式匹配应用实例
441for循环控制结构中的模式匹配
442正则表达式中的模式匹配
443异常处理中的模式匹配
444Spark源码中的模式匹配使用
45本章小结
第5章Scala集合
51可变集合与不可变集合（Collection）
511集合的概述
512集合的相关操作
513集合的操作示例
52序列（Seq）
521序列的概述
522序列的相关操作
523序列的操作示例
53列表（List）
531列表的概述
532列表的相关操作
533列表的操作示例
54集（Set）
541集的概述
542集的相关操作
543集的操作示例
55映射（Map）
551映射的概述
552映射的相关操作
553映射的操作示例
56迭代器（Iterator）
561迭代器的概述
562迭代器的相关操作
563迭代器的操作示例
57集合的架构
58小结
高级篇
第6章Scala类型参数
61泛型
611泛型的概述
612泛型的操作示例
62界定
621上下界界定
622视图界定
623上下文界定
624多重界定
625界定的操作示例
63类型约束
631类型约束的概述
632类型约束的操作示例
64类型系统
641类型系统的概述
642类型系统的操作示例
65型变Variance
651协变
652逆变
653协变与逆变的操作示例
66结合Spark源码说明Scala类型参数的使用
67小结
第7章Scala高级类型
71单例类型
711单例类型概述
712单例类型示例
72类型别名
721类型别名概述
722类型别名示例
73自身类型
731自身类型概述
732自身类型示例
74中置类型
741中置类型概述
742中置类型示例
75类型投影
751类型投影概述
752类型投影实例
76结构类型
761结构类型概述
762结构类型示例
77复合类型
771复合类型概述
772复合类型示例
78存在类型
781存在类型概述
782存在类型示例
79函数类型
791函数类型概述
792函数类型示例
710抽象类型
7101抽象类型概述
7102抽象类型实例
711Spark源码中的高级类型使用
712本章小结
第8章Scala隐式转换
81隐式转换函数
811隐式转换函数的定义
812隐式转换函数的功能
82隐式类与隐式对象
821隐式类
822隐式参数与隐式值
83类型证明中的隐式转换
831类型证明的定义
832类型证明使用实例
84上下文界定、视图界定中的隐式转换
841Ordering与Ordered特质
842视图界定中的隐式转换
843上下文界定中的隐式转换
85隐式转换规则
851发生隐式转换的条件
852不会发生隐式转换的条件
86Spark源码中的隐式转换使用
861隐式转换函数
862隐式类
863隐式参数
87本章小结
第9章Scala并发编程
91Scala的Actor模型简介
92Scala Actor的构建方式
921继承Actor类
922Actor工具方法
93Actor的生命周期
931start方法的等幂性
932Actor的不同状态
94Actor之间的通信
941Actor之间发送消息
942Actor接收消息
95使用react重用线程提升性能
96Channel通道
961OutputChannel
962InputChannel
963创建和共享channel
97同步和Future
98Scala并发编程实例
981Scala Actor并发编程
982ExecutorService并发编程
99小结
分布式框架篇
第10章Akka的设计理念
101Akka框架模型
102创建Actor
1021通过实现akkaactorActor来创建Actor类
1022使用非缺省构造方法创建 Actor
1023创建匿名Actor
103Actor API
1031Actor trait基本接口
1032使用DeathWatch进行生命周期监控
1033Hook函数的调用
1034查找Actor
1035消息的不可变性
1036发送消息
1037转发消息
1038接收消息
1039回应消息
10310终止Actor
10311Become/Unbecome
10312杀死Actor
104不同类型的Actor
1041方法派发语义
1042终止有类型Actor
105小结
第11章Akka核心组件及核心特性剖析
111Dispatchers 和 Routers
1111为Actor指定派发器
1112派发器的类型
1113邮箱
1114Routers
1115路由的使用
1116远程部署router
112Supervision和Monitoring
1121Supervision
1122Monitoring
113Akka中的事务
1131STM
1132使用STM事务
1133读取Agent事务中的数据
1134更新Agent事务中的数据
1135Actor中的事务
1136创建Transactor
114小结
第12章Akka程序设计实践
121Akka的配置、日志及部署
1211Akka中配置文件的读写
1212Akka中日志配置
1213Akka部署及应用场景
122使用Akka框架实现单词统计
123分布式Akka环境搭建
124使用Akka微内核部署应用
125Akka框架在Spark中的运用
126小结
第13章Kafka设计理念与基本架构
131Kafka产生的背景
132消息队列系统
1321概述
1322常用的消息队列系统对比
1323Kafka特点及特性
1324Kafka系统应用场景
133Kafka设计理念
1331专业术语解析
1332消息存储与缓存设计
1333消费者与生产者模型
1334Push与Pull机制
1335镜像机制
134Kafka整体架构
1341Kafka基本组成结构
1342Kafka工作流程
135Kafka性能分析及优化
136Kafka未来研究方向
137小结
第14章Kafka核心组件及核心特性剖析
141Kafka核心组件剖析
1411Producers
1412Consumers
1413Low Level Consumer
1414High Level Consumer
142Kafka核心特性剖析
1421Topic、Partitions
1422Replication和Leader Election
1423Consumer Rebalance
1424消息传送机制
1425Kafka的可靠性
1426Kafka的高效性
143Kafka即将发布版本核心组件及特性剖析
1431重新设计的Consumer
1432Coordinator Rebalance
144小结
第15章Kafka应用实践
151Kafka开发环境搭建及运行环境部署
1511Kafka开发环境配置
1512Kafka运行环境安装与部署
152基于Kafka客户端开发
1521消息生产者（Producer）设计
1522消息消费者（Consumer）设计
1523Kafka消费者与生产者配置
153Spark Streaming整合Kafka
1531基本架构设计流程
1532消息消费者（Consumer）设计——基于Receiver方法
1533消息消费者（Consumer）设计——基于No Receiver方法
1534消息生产者（Producer）设计
154小结
附录Kafka集群serverproperties配置文档
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala语言基础与开发实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala谜题
内容提要
序言
致谢
献辞
前言
谜题概览
第1章 使用占位符
第2章 初始化变量
第3章 成员声明的位置
第4章 继承
第5章 集合操作
第6章 参数类型
第7章 闭包
第8章 Map表达式
第9章 循环引用变量
第10章 等式的例子
第11章 lazy val
第12章 集合的迭代顺序
第13章 自引用
第14章 Return语句
第15章 偏函数中的_
第16章 多参数列表
第17章 隐式参数
第18章 重载
第19章 命名参数和缺省参数
第20章 正则表达式
第21章 填充
第22章 投影
第23章 构造器参数
第24章 Double.NaN
第25章 getOrElse
第26章 Any Args
第27章 null
第28章 AnyVal
第29章 隐式变量
第30章 显式声明类型
第31章 View
第32章 toSet
第33章 缺省值
第34章 关于Main
第35章 列表
第36章 计算集合的大小
参考文献
作者简介
主题索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala谜题
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序员修炼之道
目 录

第一部分　用Java 7做开发
第1章　初识Java 7　　2
1.1 　语言与平台　　2
1.2 　Coin项目：浓缩的都是精华　　4
1.3 　Coin项目中的修改　　7
1.3.1 　switch语句中的String　　7
1.3.2 　更强的数值文本表示法　　8
1.3.3 　改善后的异常处理　　9
1.3.4 　try-with-resources（TWR）　　11
1.3.5 　钻石语法　　13
1.3.6 　简化变参方法调用　　14
1.4 　小结　　15
第2章　新I/O　　17
2.1 　Java I/O简史　　18
2.1.1 　Java 1.0到1.3　　19
2.1.2 　在Java 1.4中引入的NIO　　19
2.1.3 　下一代I/O-NIO.2　　20
2.2 　文件I/O的基石：Path　　20
2.2.1 　创建一个Path　　23
2.2.2 　从Path中获取信息　　23
2.2.3 　移除冗余项　　24
2.2.4 　转换Path　　25
2.2.5 　NIO.2 Path和Java已有的File类　　25
2.3 　处理目录和目录树　　26
2.3.1 　在目录中查找文件　　26
2.3.2 　遍历目录树　　27
2.4 　NIO.2的文件系统I/O　　28
2.4.1 　创建和删除文件　　29
2.4.2 　文件的复制和移动　　30
2.4.3 　文件的属性　　31
2.4.4 　快速读写数据　　34
2.4.5 　文件修改通知　　35
2.4.6 　SeekableByteChannel　　37
2.5 　异步 I/O操作　　37
2.5.1 　将来式　　38
2.5.2 　回调式　　40
2.6 　Socket和Channel的整合　　41
2.6.1 　NetworkChannel　　42
2.6.2 　MulticastChannel　　42
2.7 　小结　　43
第二部分　关键技术
第3章　依赖注入　　46
3.1 　知识注入：理解IoC和DI　　46
3.1.1 　控制反转　　47
3.1.2 　依赖注入　　48
3.1.3 　转成DI　　49
3.2 　Java中标准化的DI　　53
3.2.1 　@Inject注解　　54
3.2.2 　@Qualifier注解　　55
3.2.3 　@Named注解　　57
3.2.4 　@Scope注解　　57
3.2.5 　@Singleton注解　　57
3.2.6 　接口Provider<T>　　58
3.3 　 Java中的DI参考实现：Guice 3　　59
3.3.1 　Guice新手指南　　59
3.3.2 　水手绳结：Guice的各种绑定　　62
3.3.3 　在Guice中限定注入对象的生命周期　　64
3.4 　小结　　66
第4章　现代并发　　67
4.1 　并发理论简介　　68
4.1.1 　解释Java线程模型　　68
4.1.2 　设计理念　　69
4.1.3 　这些原则如何以及为何会相互冲突　　70
4.1.4 　系统开销之源　　71
4.1.5 　一个事务处理的例子　　71
4.2 　块结构并发（Java 5之前）　　72
4.2.1 　同步与锁　　73
4.2.2 　线程的状态模型　　74
4.2.3 　完全同步对象　　74
4.2.4 　死锁　　76
4.2.5 　为什么是synchronized　　77
4.2.6 　关键字volatile　　78
4.2.7 　不可变性　　79
4.3 　现代并发应用程序的构件　　80
4.3.1 　原子类：java.util. concurrent.atomic　　81
4.3.2 　线程锁：java.util. concurrent.locks　　81
4.3.3 　CountDownLatch　　85
4.3.4 　ConcurrentHashMap　　86
4.3.5 　CopyOnWriteArrayList　　87
4.3.6 　Queue　　90
4.4 　控制执行　　95
4.4.1 　任务建模　　96
4.4.2 　ScheduledThread-PoolExecutor　　97
4.5 　分支/合并框架　　98
4.5.1 　一个简单的分支/合并例子　　99
4.5.2 　ForkJoinTask与工作窃取　　101
4.5.3 　并行问题　　102
4.6 　Java内存模型　　103
4.7 　小结　　104
第5章　类文件与字节码　　106
5.1 　类加载和类对象　　107
5.1.1 　加载和连接概览　　107
5.1.2 　验证　　108
5.1.3 　Class对象　　108
5.1.4 　类加载器　　109
5.1.5 　示例：依赖注入中的类加载器　　110
5.2 　使用方法句柄　　111
5.2.1 　MethodHandle　　112
5.2.2 　MethodType　　112
5.2.3 　查找方法句柄　　113
5.2.4 　示例：反射、代理与方法句柄　　114
5.2.5 　为什么选择MethodHandle　　116
5.3 　检查类文件　　117
5.3.1 　介绍javap　　117
5.3.2 　方法签名的内部形式　　118
5.3.3 　常量池　　119
5.4 　字节码　　121
5.4.1 　示例：反编译类　　121
5.4.2 　运行时环境　　123
5.4.3 　操作码介绍　　124
5.4.4 　加载和储存操作码　　125
5.4.5 　数学运算操作码　　125
5.4.6 　执行控制操作码　　126
5.4.7 　调用操作码　　126
5.4.8 　平台操作操作码　　127
5.4.9 　操作码的快捷形式　　127
5.4.10 　示例：字符串拼接　　127
5.5 　invokedynamic　　129
5.5.1 　invokedynamic如何工作　　129
5.5.2 　示例：反编译invokedynamic调用　　130
5.6 　小结　　132
第6章　理解性能调优　　133
6.1 　性能术语　　134
6.1.1 　等待时间　　135
6.1.2 　吞吐量　　135
6.1.3 　利用率　　135
6.1.4 　效率　　135
6.1.5 　容量　　136
6.1.6 　扩展性　　136
6.1.7 　退化　　136
6.2 　务实的性能分析法　　136
6.2.1 　知道你在测量什么　　137
6.2.2 　知道怎么测量　　137
6.2.3 　知道性能目标是什么　　138
6.2.4 　知道什么时候停止优化　　139
6.2.5 　知道高性能的成本　　139
6.2.6 　知道过早优化的危险　　140
6.3 　哪里出错了？我们担心的原因　　140
6.3.1 　过去和未来的性能趋势：摩尔定律　　141
6.3.2 　理解内存延迟层级　　142
6.3.3 　为什么Java性能调优存在困难　　143
6.4 　一个来自于硬件的时间问题　　144
6.4.1 　硬件时钟　　144
6.4.2 　麻烦的nanoTime()　　144
6.4.3 　时间在性能调优中的作用　　146
6.4.4 　案例研究：理解缓存未命中　　147
6.5 　垃圾收集　　149
6.5.1 　基本算法　　149
6.5.2 　标记和清除　　150
6.5.3 　jmap　　152
6.5.4 　与GC相关的JVM参数　　155
6.5.5 　读懂GC日志　　156
6.5.6 　用VisualVM查看内存使用情况　　157
6.5.7 　逸出分析　　159
6.5.8 　并发标记清除　　160
6.5.9 　新的收集器：G1　　161
6.6 　HotSpot的JIT编译　　162
6.6.1 　介绍HotSpot　　163
6.6.2 　内联方法　　164
6.6.3 　动态编译和独占调用　　165
6.6.4 　读懂编译日志　　166
6.7 　小结　　167
第三部分　JVM上的多语言编程
第7章　备选JVM语言　　170
7.1 　Java 太笨？纯粹诽谤　　170
7.1.1 　整合系统　　171
7.1.2 　函数式编程的基本原理　　172
7.1.3 　映射与过滤器　　173
7.2 　语言生态学　　174
7.2.1 　解释型与编译型语言　　175
7.2.2 　动态与静态类型　　175
7.2.3 　命令式与函数式语言　　176
7.2.4 　重新实现的语言与原生语言　　176
7.3 　JVM上的多语言编程　　177
7.3.1 　为什么要用非Java语言　　178
7.3.2 　崭露头角的语言新星　　179
7.4 　如何挑选称心的非Java语言　　180
7.4.1 　低风险　　181
7.4.2 　与Java的交互操作　　181
7.4.3 　良好的工具和测试支持　　182
7.4.4 　备选语言学习难度　　182
7.4.5 　使用备选语言的开发者　　182
7.5 　JVM对备选语言的支持　　183
7.5.1 　非Java语言的运行时环境　　183
7.5.2 　编译器小说　　184
7.6 　小结　　185
第8章　Groovy：Java的动态伴侣　　187
8.1 　Groovy入门　　189
8.1.1 　编译和运行　　189
8.1.2 　Groovy控制台　　190
8.2 　Groovy 101：语法和语义　　191
8.2.1 　默认导入　　192
8.2.2 　数字处理　　192
8.2.3 　变量、动态与静态类型、作用域　　193
8.2.4 　列表和映射语法　　195
8.3 　与Java的差异——新手陷阱　　196
8.3.1 　可选的分号和返回语句　　196
8.3.2 　可选的参数括号　　197
8.3.3 　访问限定符　　197
8.3.4 　异常处理　　198
8.3.5 　Groovy中的相等　　198
8.3.6 　内部类　　199
8.4 　Java不具备的Groovy特性　　199
8.4.1 　GroovyBean　　199
8.4.2 　安全解引用操作符　　200
8.4.3 　猫王操作符　　201
8.4.4 　增强型字符串　　201
8.4.5 　函数字面值　　202
8.4.6 　内置的集合操作　　203
8.4.7 　对正则表达式的内置支持　　204
8.4.8 　简单的XML处理　　205
8.5 　Groovy与Java的合作　　207
8.5.1 　从Groovy调用Java　　207
8.5.2 　从Java调用Groovy　　208
8.6 　小结　　211
第9章　Scala：简约而不简单　　212
9.1 　走马观花Scala　　213
9.1.1 　简约的Scala　　213
9.1.2 　match表达式　　215
9.1.3 　case类　　217
9.1.4 　actor　　218
9.2 　Scala能用在我的项目中吗　　219
9.2.1 　Scala和Java的比较　　219
9.2.2 　何时以及如何开始使用Scala　　220
9.2.3 　Scala可能不适合当前项目的迹象　　220
9.3 　让代码因Scala重新绽放　　221
9.3.1 　使用编译器和REPL　　221
9.3.2 　类型推断　　222
9.3.3 　方法　　223
9.3.4 　导入　　224
9.3.5 　循环和控制结构　　224
9.3.6 　Scala的函数式编程　　225
9.4 　Scala对象模型：相似但不同　　226
9.4.1 　一切皆对象　　226
9.4.2 　构造方法　　228
9.4.3 　特质　　228
9.4.4 　单例和伴生对象　　230
9.4.5 　case类和match表达式　　232
9.4.6 　警世寓言　　234
9.5 　数据结构和集合　　235
9.5.1 　List　　235
9.5.2 　Map　　238
9.5.3 　泛型　　239
9.6 　actor介绍　　242
9.6.1 　代码大舞台　　242
9.6.2 　用mailbox跟actor通信　　243
9.7 　小结　　244
第10章　Clojure：更安全地编程　　245
10.1 　Clojure介绍　　245
10.1.1 　Clojure的Hello World　　246
10.1.2 　REPL入门　　247
10.1.3 　犯了错误　　248
10.1.4 　学着去爱括号　　248
10.2 　寻找Clojure：语法和语义　　249
10.2.1 　特殊形式新手营　　249
10.2.2 　列表、向量、映射和集　　250
10.2.3 　数学运算、相等和其他操作　　252
10.3 　使用函数和循环　　253
10.3.1 　一些简单的Clojure函数　　253
10.3.2 　Clojure中的循环　　255
10.3.3 　读取器宏和派发器　　256
10.3.4 　函数式编程和闭包　　257
10.4 　Clojure序列　　258
10.4.1 　懒序列　　260
10.4.2 　序列和变参函数　　261
10.5 　Clojure与Java的互操作　　262
10.5.1 　从Clojure中调用Java　　262
10.5.2 　Clojure值的Java类型　　263
10.5.3 　使用Clojure代理　　264
10.5.4 　用REPL做探索式编程　　264
10.5.5 　在Java中使用Clojure　　265
10.6 　Clojure并发　　265
10.6.1 　未来式与并行调用　　266
10.6.2 　ref形式　　267
10.6.3 　代理　　271
10.7 　小结　　272
第四部分　多语种项目开发
第11章　测试驱动开发　　274
11.1 　TDD概览　　275
11.1.1 　一个测试用例　　276
11.1.2 　多个测试用例　　280
11.1.3 　深入思考红—绿—重构循环　　282
11.1.4 　JUnit　　283
11.2 　测试替身　　285
11.2.1 　虚设对象　　286
11.2.2 　存根对象　　287
11.2.3 　伪装替身　　290
11.2.4 　模拟对象　　295
11.3 　ScalaTest　　296
11.4 　小结　　298
第12章　构建和持续集成　　300
12.1 　与Maven 3相遇　　302
12.2 　Maven 3入门项目　　303
12.3 　用Maven 3构建Java7developer项目　　305
12.3.1 　POM　　305
12.3.2 　运行示例　　311
12.4 　Jenkins：满足CI需求　　314
12.4.1 　基础配置　　315
12.4.2 　设置任务　　316
12.4.3 　执行任务　　319
12.5 　Maven和Jenkins代码指标　　320
12.5.1 　安装Jenkins插件　　321
12.5.2 　用Checkstyle保持代码一致性　　322
12.5.3 　用FindBugs设定质量标杆　　323
12.6 　Leiningen　　325
12.6.1 　Leiningen入门　　326
12.6.2 　Leiningen的架构　　326
12.6.3 　Hello Lein　　327
12.6.4 　用Leiningen做面向REPL的TDD　　329
12.6.5 　用Leiningen打包和部署　　330
12.7 　小结　　332
第13章　快速Web开发　　333
13.1 　Java Web框架的问题　　334
13.1.1 　Java编译为什么不好　　335
13.1.2 　静态类型为什么不好　　335
13.2 　选择Web框架的标准　　336
13.3 　Grails入门　　338
13.4 　Grails快速启动项目　　338
13.4.1 　创建域对象　　340
13.4.2 　测试驱动开发　　340
13.4.3 　域对象持久化　　342
13.4.4 　创建测试数据　　343
13.4.5 　控制器　　343
13.4.6 　GSP/JSP页面　　344
13.4.7 　脚手架和UI的自动化创建　　346
13.4.8 　快速周转的开发　　347
13.5 　深入Grails　　347
13.5.1 　日志　　347
13.5.2 　GORM：对象关系映射　　348
13.5.3 　Grails插件　　349
13.6 　Compojure入门　　350
13.6.1 　Hello Compojure　　350
13.6.2 　Ring和路由　　352
13.6.3 　Hiccup　　353
13.7 　我是不是一只水獭　　353
13.7.1 　项目设置　　354
13.7.2 　核心函数　　357
13.8 　小结　　359
第14章　保持优秀　　361
14.1 　对Java 8的期待　　361
14.1.1 　lambda表达式（闭包）　　362
14.1.2 　模块化（拼图Jigsaw）　　363
14.2 　多语言编程　　365
14.2.1 　语言的互操作性及元对象协议　　365
14.2.2 　多语言模块化　　366
14.3 　未来的并发趋势　　367
14.3.1 　多核的世界　　367
14.3.2 　运行时管理的并发　　367
14.4 　JVM的新方向　　368
14.4.1 　VM的合并　　368
14.4.2 　协同程序　　369
14.4.3 　元组　　370
14.5 　小结　　372
附录A 　java7developer：源码安装　　373
附录B 　glob模式语法及示例　　380
附录C 　安装备选JVM语言　　382
附录D 　Jenkins的下载和安装　　388
附录E 　java7developer：Maven POM　　390

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序员修炼之道
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>函数响应式领域建模
1. 函数式领域建模：介绍.............................................................. 1
1.1　什么是领域模型 .............................................................................................. 2
1.2　领域驱动设计介绍 .......................................................................................... 4
1.2.1　边界上下文 .......................................................................................... 4
1.2.2　领域模型元素 ...................................................................................... 5
1.2.3　领域对象的生命周期 .......................................................................... 8
1.2.4　通用语言 ............................................................................................ 13
1.3　函数化思想 .................................................................................................... 14
1.3.1　哈，纯粹的乐趣 ................................................................................ 17
1.3.2　纯函数组合 ........................................................................................ 21
1.4　管理副作用 .................................................................................................... 26
1.5　纯模型元素的优点 ........................................................................................ 28
1.6　响应式领域模型 ............................................................................................ 31
1.6.1　响应式模型的3+1 视图 .................................................................... 31
1.6.2　揭穿“我的模型不能失败”的神话 ................................................ 32
1.6.3　伸缩性与消息驱动 ............................................................................ 34
1.7　事件驱动编程 ................................................................................................ 35
1.7.1　事件与命令 ........................................................................................ 37
1.7.2　领域事件 ............................................................................................ 38
1.8　函数式遇上响应式 ........................................................................................ 40
1.9　总结 ................................................................................................................ 41
2　Scala 与函数式领域模型..........................................................42
2.1　为什么是Scala ............................................................................................... 43
2.2　静态类型与富领域模型 ................................................................................ 45
2.3　领域行为的纯函数 ........................................................................................ 47
2.3.1　回顾抽象的纯粹性 ............................................................................ 50
2.3.2　引用透明的其他好处 ........................................................................ 53
2.4　代数数据类型与不变性 ................................................................................ 53
2.4.1　基础：和类型与乘积类型 ................................................................ 53
2.4.2　模型中的ADT 结构数据 .................................................................. 56
2.4.3　ADT 与模式匹配 ............................................................................... 56
2.4.4　ADT 鼓励不变性 ............................................................................... 58
2.5　局部用函数，全局用OO.............................................................................. 59
2.5.1　Scala 中的模块 .................................................................................. 60
2.6　用Scala 使模型具备响应性 .......................................................................... 64
2.6.1　管理作用 ............................................................................................ 65
2.6.2　管理失败 ............................................................................................ 65
2.6.3　管理延迟 ............................................................................................ 67
2.7　总结 ................................................................................................................ 69
3　设计函数式领域模型...............................................................70
3.1　API 设计的代数 ............................................................................................. 71
3.1.1　为什么是代数方法 ............................................................................ 72
3.2　为领域服务定义代数 .................................................................................... 72
3.2.1　赋值抽象 ............................................................................................ 73
3.2.2　组合抽象 ............................................................................................ 74
3.2.3　类型的最终代数 ................................................................................ 76
3.2.4　代数法则 ............................................................................................ 77
3.2.5　代数解释程序 .................................................................................... 79
3.3　领域模型生命周期中的模式 ........................................................................ 80
3.3.1　工厂——对象从何处来..................................................................... 82
3.3.2　智能构造器 ........................................................................................ 82
3.3.3　通过更有表现力的类型进一步提升智能 ........................................ 84
3.3.4　用代数数据类型聚合 ........................................................................ 86
3.3.5　用透镜更新聚合功能 ........................................................................ 88
3.3.6　仓储与解耦的永恒艺术 .................................................................... 94
3.3.7　高效地使用生命周期模式——结论............................................... 101
3.4　总结 .............................................................................................................. 102
4　领域模型的函数式模式.......................................................... 103
4.1　模式——代数、函数、类型的聚合 ........................................................... 104
4.1.1　领域模型中的挖掘模式 .................................................................. 106
4.1.2　用函数式模式使领域模型参数化 .................................................. 107
4.2　强类型函数式编程中计算的基本模式 ...................................................... 112
4.2.1　函子——建立模式........................................................................... 112
4.2.2　加强版函子模式 .............................................................................. 114
4.2.3　单子作用——applicative 模式的变体 ............................................ 121
4.3　如何用模式对领域模型进行塑形 .............................................................. 130
4.4　用代数、类型和模式演进API ................................................................... 134
4.4.1　代数——第一稿............................................................................... 136
4.4.2　改进代数 .......................................................................................... 137
4.4.3　最终组合——采用类型................................................................... 138
4.5　用模式和类型增强领域的不变性 .............................................................. 139
4.5.1　贷款处理模型 .................................................................................. 139
4.5.2　使非法状态不可表示 ...................................................................... 141
4.6　总结 .............................................................................................................. 142
5　领域模型的模块化................................................................ 144
5.1　将领域模型模块化 .......................................................................................... 145
5.2　模块化的领域模型——案例学习 ............................................................... 146
5.2.1　模块的解剖 ...................................................................................... 147
5.2.2　模块的构成 ...................................................................................... 154
5.2.3　模块的物理组织 .............................................................................. 155
5.2.4　模块鼓励组合 .................................................................................. 156
5.2.5　领域模型中的模块化——结论....................................................... 157
5.3　类型类模式——模块化的多态行为 ........................................................... 157
5.4　边界上下文的聚合模块 .............................................................................. 160
5.4.1　模块与边界上下文 .......................................................................... 161
5.4.2　边界上下文间的通信 ...................................................................... 162
5.5　模块化的另一个模式——free monad ......................................................... 163
5.5.1　账户存储 .......................................................................................... 163
5.5.2　使它免费 .......................................................................................... 165
5.5.3　账户存储——free monad ................................................................ 167
5.5.4　free monad 解释程序 ....................................................................... 169
5.5.5　free monad——重点回顾 ................................................................ 172
5.6　总结 .............................................................................................................. 173
6　响应式模型.......................................................................... 174
6.1　响应式领域模型 .......................................................................................... 175
6.2　使用future 的非阻塞API 设计 .................................................................. 177
6.2.1　异步作为堆叠作用 .......................................................................... 178
6.2.2　基于monad 转换器的实现 ............................................................. 181
6.2.3　用并行存取降低延迟——一种响应式模式 .................................. 183
6.2.4　使用scalaz.concurrent.Task 作为响应式构造 ................................ 187
6.3　明确的异步消息传递 .................................................................................. 189
6.4　流模式 .......................................................................................................... 191
6.4.1　一个案例 .......................................................................................... 191
6.4.2　领域管道图 ...................................................................................... 195
6.4.3　后端压力处理 .................................................................................. 197
6.5　actor 模型 ..................................................................................................... 198
6.5.1　领域模型与actor ............................................................................. 199
6.6　总结 .............................................................................................................. 203
7　响应式流建模....................................................................... 205
7.1　响应式流模型 .............................................................................................. 206
7.2　何时使用流模型 .......................................................................................... 207
7.3　领域用例 ...................................................................................................... 208
7.4　基于流的领域交互 ...................................................................................... 208
7.5　实现：前台 .................................................................................................. 210
7.6　实现：后台 .................................................................................................. 211
7.7　流模型的主要结论 ...................................................................................... 214
7.8　使模型具有弹性 .......................................................................................... 215
7.8.1　使用Akka Streams 监管 .................................................................. 216
7.8.2　冗余集群 .......................................................................................... 217
7.8.3　数据的持久化 .................................................................................. 217
7.9　基于流的领域模型与响应式原则 .............................................................. 219
7.10　总结 ............................................................................................................ 220
8　响应式持久化与事件溯源...................................................... 221
8.1　领域模型的持久化 ...................................................................................... 222
8.2　关注点分离 .................................................................................................. 224
8.2.1　持久化的读/ 写模型 ....................................................................... 225
8.2.2　命令查询责任分离 .......................................................................... 226
8.3　事件溯源 ..................................................................................................... 228
8.3.1　事件溯源领域模型中的命令和事件 .............................................. 229
8.3.2　实现CQRS 和事件溯源 .................................................................. 231
8.4　实现事件溯源的领域模型（函数式） ........................................................ 232
8.4.1　作为头等实体的事件 ...................................................................... 233
8.4.2　命令是事件上的free monad .......................................................... 235
8.4.3　解释程序——隐藏所有有趣的东西............................................... 237
8.4.4　投影——读取端模型....................................................................... 242
8.4.5　事件存储 .......................................................................................... 243
8.4.6　分布式CQRS——一个短信 ........................................................... 243
8.4.7　实现的总结 ...................................................................................... 244
8.5　其他持久化模型 .......................................................................................... 245
8.5.1　将聚合作为ADT 映射到关系型表 ................................................ 245
8.5.2　操作数据（函数式） ........................................................................ 247
8.5.3　到Akka Streams 管道的响应式获取 .............................................. 248
8.6　总结 .............................................................................................................. 249
9　测试领域模型...................................................................... 250
9.1　测试领域模型概述 .............................................................................................. 251
9.2　设计可测试的领域模型 .............................................................................. 252
9.2.1　解耦副作用 ...................................................................................... 253
9.2.2　为领域函数提供自定义解释程序 .................................................. 254
9.2.3　实现参数化与测试 .......................................................................... 255
9.3　基于xUnit 的测试 ....................................................................................... 256
9.4　回顾模型的代数 .......................................................................................... 257
9.5　基于属性的测试 .......................................................................................... 258
9.5.1　建模属性 .......................................................................................... 258
9.5.2　验证领域模型中的属性 .................................................................. 259
9.5.3　数据生成器 ...................................................................................... 264
9.5.4　是否比基于xUnit 的测试更好 ....................................................... 266
9.6　总结 .............................................................................................................. 267
10　核心思想与原则................................................................ 268
10.1　回顾 ............................................................................................................ 268
10.2　函数式领域建模的核心原则 .................................................................... 269
10.2.1　表达式思想 .................................................................................... 269
10.2.2　早抽象, 晚赋值 ............................................................................. 270
10.2.3　使用合适的抽象 ............................................................................ 270
10.2.4　发布要做什么，在组合器中隐藏如何做 .................................... 270
10.2.5　从实现中解耦代数 ........................................................................ 271
10.2.6　隔离边界上下文 ............................................................................ 271
10.2.7　偏向future 而不是actor ................................................................ 271
10.3　展望未来 .................................................................................................... 272
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>函数响应式领域建模
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala机器学习
译者序
前言
第1章探索数据分析1
1.1Scala入门2
1.2去除分类字段的重复值2
1.3数值字段概述4
1.4基本抽样、分层抽样和一致抽样5
1.5使用Scala和Spark的Note—book工作8
1.6相关性的基础12
1.7总结14
第2章数据管道和建模15
2.1影响图16
2.2序贯试验和风险处理17
2.3探索与利用问题21
2.4不知之不知23
2.5数据驱动系统的基本组件23
2.5.1数据收集24
2.5.2数据转换层25
2.5.3数据分析与机器学习26
2.5.4UI组件26
2.5.5动作引擎28
2.5.6关联引擎28
2.5.7监控28
2.6优化和交互28
2.7总结29
第3章使用Spark和MLlib30
3.1安装Spark31
3.2理解Spark的架构32
3.2.1任务调度32
3.2.2Spark的组件35
3.2.3MQTT、ZeroMQ、Flume和Kafka36
3.2.4HDFS、Cassandra、S3和Tachyon37
3.2.5Mesos、YARN和Standa—lone38
3.3应用38
3.3.1单词计数38
3.3.2基于流的单词计数41
3.3.3SparkSQL和数据框45
3.4机器学习库46
3.4.1SparkR47
3.4.2图算法：Graphx和Graph—Frames48
3.5Spark的性能调整48
3.6运行Hadoop的HDFS49
3.7总结54
第4章监督学习和无监督学习55
4.1记录和监督学习55
4.1.1Iirs数据集56
4.1.2类标签点57
4.1.3SVMWithSGD58
4.1.4logistic回归60
4.1.5决策树62
4.1.6bagging和boosting：集成学习方法66
4.2无监督学习66
4.3数据维度71
4.4总结73
第5章回归和分类74
5.1回归是什么74
5.2连续空间和度量75
5.3线性回归77
5.4logistic回归81
5.5正则化83
5.6多元回归84
5.7异方差84
5.8回归树85
5.9分类的度量87
5.10多分类问题87
5.11感知机87
5.12泛化误差和过拟合90
5.13总结90
第6章使用非结构化数据91
6.1嵌套数据92
6.2其他序列化格式100
6.3Hive和Impala102
6.4会话化104
6.5使用特质109
6.6使用模式匹配110
6.7非结构化数据的其他用途113
6.8概率结构113
6.9投影113
6.10总结113
第7章使用图算法115
7.1图简介115
7.2SBT116
7.3Scala的图项目119
7.3.1增加节点和边121
7.3.2图约束123
7.3.3JSON124
7.4GraphX126
7.4.1谁收到电子邮件130
7.4.2连通分量131
7.4.3三角形计数132
7.4.4强连通分量132
7.4.5PageRank133
7.4.6SVD++134
7.5总结138
第8章Scala与R和Python的集成139
8.1R的集成140
8.1.1R和SparkR的相关配置140
8.1.2数据框144
8.1.3线性模型150
8.1.4广义线性模型152
8.1.5在SparkR中读取JSON文件156
8.1.6在SparkR中写入Parquet文件157
8.1.7从R调用Scala158
8.2Python的集成161
8.2.1安装Python161
8.2.2PySpark162
8.2.3从Java／Scala调用Python163
8.3总结167
第9章Scala中的NLP169
9.1文本分析流程170
9.2Spark的MLlib库177
9.2.1TF—IDF177
9.2.2LDA178
9.3分词、标注和分块185
9.4POS标记186
9.5使用word2vec寻找词关系189
9.6总结192
第10章高级模型监控193
10.1系统监控194
10.2进程监控195
10.3模型监控201
10.3.1随时间变化的性能202
10.3.2模型停用标准202
10.3.3A／B测试202
10.4总结202
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala机器学习