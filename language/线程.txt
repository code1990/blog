1	{"count":43,"start":0,"total":43,"books":[{"rating":{"max":10,"numRaters":456,"average":"8.8","min":0},"subtitle":"使用muduo C++网络库","author":["陈硕"],"pubdate":"2013-1-15","tags":[{"count":606,"name":"网络编程","title":"网络编程"},{"count":543,"name":"Linux","title":"Linux"},{"count":540,"name":"C++","title":"C++"},{"count":454,"name":"多线程","title":"多线程"},{"count":155,"name":"计算机","title":"计算机"},{"count":143,"name":"编程","title":"编程"},{"count":108,"name":"C\/C++","title":"C\/C++"},{"count":87,"name":"Networks","title":"Networks"}],"origin_title":"","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s24522799.jpg","binding":"平装","translator":[],"catalog":"第1 部分C++ 多线程系统编程1\n第1章 线程安全的对象生命期管理3\n1.1 当析构函数遇到多线程. . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n1.1.1 线程安全的定义. . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\n1.1.2 MutexLock 与MutexLockGuard . . . . . . . . . . . . . . . . . . . . 4\n1.1.3 一个线程安全的Counter 示例. . . . . . . . . . . . . . . . . . . . 4\n1.2 对象的创建很简单. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n1.3 销毁太难. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n1.3.1 mutex 不是办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n1.3.2 作为数据成员的mutex 不能保护析构. . . . . . . . . . . . . . . 8\n1.4 线程安全的Observer 有多难. . . . . . . . . . . . . . . . . . . . . . . . . 8\n1.5 原始指针有何不妥. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n1.6 神器shared_ptr\/weak_ptr . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n1.7 插曲：系统地避免各种指针错误. . . . . . . . . . . . . . . . . . . . . . . 14\n1.8 应用到Observer 上. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\n1.9 再论shared_ptr 的线程安全. . . . . . . . . . . . . . . . . . . . . . . . . 17\n1.10 shared_ptr 技术与陷阱. . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n1.11 对象池. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21\n1.11.1 enable_shared_from_this . . . . . . . . . . . . . . . . . . . . . . 23\n1.11.2 弱回调. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\n1.12 替代方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n1.13 心得与小结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n1.14 Observer 之谬. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\n第2章 线程同步精要31\n2.1 互斥器（mutex） . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32\n2.1.1 只使用非递归的mutex . . . . . . . . . . . . . . . . . . . . . . . . 33\n2.1.2 死锁. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\n2.2 条件变量（condition variable） . . . . . . . . . . . . . . . . . . . . . . . 40\n2.3 不要用读写锁和信号量. . . . . . . . . . . . . . . . . . . . . . . . . . . . 43\n2.4 封装MutexLock、MutexLockGuard、Condition . . . . . . . . . . . . . . 44\n2.5 线程安全的Singleton 实现. . . . . . . . . . . . . . . . . . . . . . . . . . 48\n2.6 sleep(3) 不是同步原语. . . . . . . . . . . . . . . . . . . . . . . . . . . . 50\n2.7 归纳与总结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\n2.8 借shared_ptr 实现copy-on-write . . . . . . . . . . . . . . . . . . . . . . 52\n第3章 多线程服务器的适用场合与常用编程模型59\n3.1 进程与线程. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59\n3.2 单线程服务器的常用编程模型. . . . . . . . . . . . . . . . . . . . . . . . 61\n3.3 多线程服务器的常用编程模型. . . . . . . . . . . . . . . . . . . . . . . . 62\n3.3.1 one loop per thread . . . . . . . . . . . . . . . . . . . . . . . . . . 62\n3.3.2 线程池. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63\n3.3.3 推荐模式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64\n3.4 进程间通信只用TCP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65\n3.5 多线程服务器的适用场合. . . . . . . . . . . . . . . . . . . . . . . . . . . 67\n3.5.1 必须用单线程的场合. . . . . . . . . . . . . . . . . . . . . . . . . 69\n3.5.2 单线程程序的优缺点. . . . . . . . . . . . . . . . . . . . . . . . . 70\n3.5.3 适用多线程程序的场景. . . . . . . . . . . . . . . . . . . . . . . . 71\n3.6 “多线程服务器的适用场合”例释与答疑. . . . . . . . . . . . . . . . . . 74\n第4章 C++ 多线程系统编程精要83\n4.1 基本线程原语的选用. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84\n4.2 C\/C++ 系统库的线程安全性. . . . . . . . . . . . . . . . . . . . . . . . . 85\n4.3 Linux 上的线程标识. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89\n4.4 线程的创建与销毁的守则. . . . . . . . . . . . . . . . . . . . . . . . . . . 91\n4.4.1 pthread_cancel 与C++ . . . . . . . . . . . . . . . . . . . . . . . 94\n4.4.2 exit(3) 在C++ 中不是线程安全的. . . . . . . . . . . . . . . . . 94\n4.5 善用__thread 关键字. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96\n4.6 多线程与IO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98\n4.7 用RAII 包装文件描述符. . . . . . . . . . . . . . . . . . . . . . . . . . . 99\n4.8 RAII 与fork() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101\n4.9 多线程与fork() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102\n4.10 多线程与signal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103\n4.11 Linux 新增系统调用的启示. . . . . . . . . . . . . . . . . . . . . . . . . . 105\n第5章 高效的多线程日志107\n5.1 功能需求. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109\n5.2 性能需求. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112\n5.3 多线程异步日志. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114\n5.4 其他方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120\n第2部分 muduo 网络库123\n第6章 muduo 网络库简介125\n6.1 由来. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125\n6.2 安装. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127\n6.3 目录结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129\n6.3.1 代码结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131\n6.3.2 例子. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134\n6.3.3 线程模型. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135\n6.4 使用教程. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136\n6.4.1 TCP 网络编程本质论. . . . . . . . . . . . . . . . . . . . . . . . . 136\n6.4.2 echo 服务的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . 138\n6.4.3 七步实现finger 服务. . . . . . . . . . . . . . . . . . . . . . . . . 140\n6.5 性能评测. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144\n6.5.1 muduo 与Boost.Asio、libevent2 的吞吐量对比. . . . . . . . . . 145\n6.5.2 击鼓传花：对比muduo 与libevent2 的事件处理效率. . . . . . 148\n6.5.3 muduo 与Nginx 的吞吐量对比. . . . . . . . . . . . . . . . . . . 153\n6.5.4 muduo 与ZeroMQ 的延迟对比. . . . . . . . . . . . . . . . . . . 156\n6.6 详解muduo 多线程模型. . . . . . . . . . . . . . . . . . . . . . . . . . . 157\n6.6.1 数独求解服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . . 157\n6.6.2 常见的并发网络服务程序设计方案. . . . . . . . . . . . . . . . . 160\n第7章 muduo 编程示例177\n7.1 五个简单TCP 示例. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178\n7.2 文件传输. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185\n7.3 Boost.Asio 的聊天服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . 194\n7.3.1 TCP 分包. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194\n7.3.2 消息格式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195\n7.3.3 编解码器LengthHeaderCodec . . . . . . . . . . . . . . . . . . . . 197\n7.3.4 服务端的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198\n7.3.5 客户端的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200\n7.4 muduo Buffer 类的设计与使用. . . . . . . . . . . . . . . . . . . . . . . 204\n7.4.1 muduo 的IO 模型. . . . . . . . . . . . . . . . . . . . . . . . . . 204\n7.4.2 为什么non-blocking 网络编程中应用层buffer 是必需的. . . . 205\n7.4.3 Buffer 的功能需求. . . . . . . . . . . . . . . . . . . . . . . . . . 207\n7.4.4 Buffer 的数据结构. . . . . . . . . . . . . . . . . . . . . . . . . . 209\n7.4.5 Buffer 的操作. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211\n7.4.6 其他设计方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217\n7.4.7 性能是不是问题. . . . . . . . . . . . . . . . . . . . . . . . . . . . 218\n7.5 一种自动反射消息类型的Google Protobuf 网络传输方案. . . . . . . . 220\n7.5.1 网络编程中使用Protobuf 的两个先决条件. . . . . . . . . . . . . 220\n7.5.2 根据type name 反射自动创建Message 对象. . . . . . . . . . . . 221\n7.5.3 Protobuf 传输格式. . . . . . . . . . . . . . . . . . . . . . . . . . 226\n7.6 在muduo 中实现Protobuf 编解码器与消息分发器. . . . . . . . . . . . 228\n7.6.1 什么是编解码器（codec） . . . . . . . . . . . . . . . . . . . . . . 229\n7.6.2 实现ProtobufCodec . . . . . . . . . . . . . . . . . . . . . . . . . 232\n7.6.3 消息分发器（dispatcher）有什么用. . . . . . . . . . . . . . . . 232\n7.6.4 ProtobufCodec 与ProtobufDispatcher 的综合运用. . . . . . . 233\n7.6.5 ProtobufDispatcher 的两种实现. . . . . . . . . . . . . . . . . . 234\n7.6.6 ProtobufCodec 和ProtobufDispatcher 有何意义. . . . . . . . . 236\n7.7 限制服务器的最大并发连接数. . . . . . . . . . . . . . . . . . . . . . . . 237\n7.7.1 为什么要限制并发连接数. . . . . . . . . . . . . . . . . . . . . . 237\n7.7.2 在muduo 中限制并发连接数. . . . . . . . . . . . . . . . . . . . 238\n7.8 定时器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240\n7.8.1 程序中的时间. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240\n7.8.2 Linux 时间函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . 241\n7.8.3 muduo 的定时器接口. . . . . . . . . . . . . . . . . . . . . . . . . 242\n7.8.4 Boost.Asio Timer 示例. . . . . . . . . . . . . . . . . . . . . . . . 243\n7.8.5 Java Netty 示例. . . . . . . . . . . . . . . . . . . . . . . . . . . . 245\n7.9 测量两台机器的网络延迟和时间差. . . . . . . . . . . . . . . . . . . . . 248\n7.10 用timing wheel 踢掉空闲连接. . . . . . . . . . . . . . . . . . . . . . . . 250\n7.10.1 timing wheel 原理. . . . . . . . . . . . . . . . . . . . . . . . . . 251\n7.10.2 代码实现与改进. . . . . . . . . . . . . . . . . . . . . . . . . . . . 254\n7.11 简单的消息广播服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257\n7.12 “串并转换”连接服务器及其自动化测试. . . . . . . . . . . . . . . . . . 260\n7.13 socks4a 代理服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264\n7.13.1 TCP 中继器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264\n7.13.2 socks4a 代理服务器. . . . . . . . . . . . . . . . . . . . . . . . . . 267\n7.13.3 N : 1 与1 : N 连接转发. . . . . . . . . . . . . . . . . . . . . . . . 267\n7.14 短址服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267\n7.15 与其他库集成. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268\n7.15.1 UDNS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270\n7.15.2 c-ares DNS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272\n7.15.3 curl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273\n7.15.4 更多. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275\n第8章 muduo 网络库设计与实现277\n8.0 什么都不做的EventLoop . . . . . . . . . . . . . . . . . . . . . . . . . . . 277\n8.1 Reactor 的关键结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280\n8.1.1 Channel class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280\n8.1.2 Poller class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283\n8.1.3 EventLoop 的改动. . . . . . . . . . . . . . . . . . . . . . . . . . . 287\n8.2 TimerQueue 定时器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290\n8.2.1 TimerQueue class . . . . . . . . . . . . . . . . . . . . . . . . . . . 290\n8.2.2 EventLoop 的改动. . . . . . . . . . . . . . . . . . . . . . . . . . . 292\n8.3 EventLoop::runInLoop() 函数. . . . . . . . . . . . . . . . . . . . . . . . 293\n8.3.1 提高TimerQueue 的线程安全性. . . . . . . . . . . . . . . . . . . 296\n8.3.2 EventLoopThread class . . . . . . . . . . . . . . . . . . . . . . . . 297\n8.4 实现TCP 网络库. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299\n8.5 TcpServer 接受新连接. . . . . . . . . . . . . . . . . . . . . . . . . . . . 303\n8.5.1 TcpServer class . . . . . . . . . . . . . . . . . . . . . . . . . . . . 304\n8.5.2 TcpConnection class . . . . . . . . . . . . . . . . . . . . . . . . . 305\n8.6 TcpConnection 断开连接. . . . . . . . . . . . . . . . . . . . . . . . . . . 308\n8.7 Buffer 读取数据. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 313\n8.7.1 TcpConnection 使用Buffer 作为输入缓冲. . . . . . . . . . . . . 314\n8.7.2 Buffer::readFd() . . . . . . . . . . . . . . . . . . . . . . . . . . 315\n8.8 TcpConnection 发送数据. . . . . . . . . . . . . . . . . . . . . . . . . . . 316\n8.9 完善TcpConnection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 320\n8.9.1 SIGPIPE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321\n8.9.2 TCP No Delay 和TCP keepalive . . . . . . . . . . . . . . . . . . 321\n8.9.3 WriteCompleteCallback 和HighWaterMarkCallback . . . . . . . 322\n8.10 多线程TcpServer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 324\n8.11 Connector . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327\n8.12 TcpClient . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 332\n8.13 epoll . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333\n8.14 测试程序一览. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 336\n第3部分 工程实践经验谈337\n第9章 分布式系统工程实践339\n9.1 我们在技术浪潮中的位置. . . . . . . . . . . . . . . . . . . . . . . . . . . 341\n9.1.1 分布式系统的本质困难. . . . . . . . . . . . . . . . . . . . . . . . 343\n9.1.2 分布式系统是个险恶的问题. . . . . . . . . . . . . . . . . . . . . 344\n9.2 分布式系统的可靠性浅说. . . . . . . . . . . . . . . . . . . . . . . . . . . 349\n9.2.1 分布式系统的软件不要求7  24 可靠. . . . . . . . . . . . . . . . 352\n9.2.2 “能随时重启进程”作为程序设计目标. . . . . . . . . . . . . . . 354\n9.3 分布式系统中心跳协议的设计. . . . . . . . . . . . . . . . . . . . . . . . 356\n9.4 分布式系统中的进程标识. . . . . . . . . . . . . . . . . . . . . . . . . . . 360\n9.4.1 错误做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361\n9.4.2 正确做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 362\n9.4.3 TCP 协议的启示. . . . . . . . . . . . . . . . . . . . . . . . . . . . 363\n9.5 构建易于维护的分布式程序. . . . . . . . . . . . . . . . . . . . . . . . . 364\n9.6 为系统演化做准备. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 367\n9.6.1 可扩展的消息格式. . . . . . . . . . . . . . . . . . . . . . . . . . 368\n9.6.2 反面教材：ICE 的消息打包格式. . . . . . . . . . . . . . . . . . . 369\n9.7 分布式程序的自动化回归测试. . . . . . . . . . . . . . . . . . . . . . . . 370\n9.7.1 单元测试的能与不能. . . . . . . . . . . . . . . . . . . . . . . . . 370\n9.7.2 分布式系统测试的要点. . . . . . . . . . . . . . . . . . . . . . . . 373\n9.7.3 分布式系统的抽象观点. . . . . . . . . . . . . . . . . . . . . . . . 374\n9.7.4 一种自动化的回归测试方案. . . . . . . . . . . . . . . . . . . . . 375\n9.7.5 其他用处. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 379\n9.8 分布式系统部署、监控与进程管理的几重境界. . . . . . . . . . . . . . . 380\n9.8.1 境界1：全手工操作. . . . . . . . . . . . . . . . . . . . . . . . . 382\n9.8.2 境界2：使用零散的自动化脚本和第三方组件. . . . . . . . . . . 383\n9.8.3 境界3：自制机群管理系统，集中化配置. . . . . . . . . . . . . 386\n9.8.4 境界4：机群管理与naming service 结合. . . . . . . . . . . . . 389\n第10章 C++ 编译链接模型精要391\n10.1 C 语言的编译模型及其成因. . . . . . . . . . . . . . . . . . . . . . . . . 394\n10.1.1 为什么C 语言需要预处理. . . . . . . . . . . . . . . . . . . . . . 395\n10.1.2 C 语言的编译模型. . . . . . . . . . . . . . . . . . . . . . . . . . . 398\n10.2 C++ 的编译模型. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399\n10.2.1 单遍编译. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399\n10.2.2 前向声明. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 402\n10.3 C++ 链接（linking） . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 404\n10.3.1 函数重载. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 406\n10.3.2 inline 函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 407\n10.3.3 模板. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 409\n10.3.4 虚函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 414\n10.4 工程项目中头文件的使用规则. . . . . . . . . . . . . . . . . . . . . . . . 415\n10.4.1 头文件的害处. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 416\n10.4.2 头文件的使用规则. . . . . . . . . . . . . . . . . . . . . . . . . . 417\n10.5 工程项目中库文件的组织原则. . . . . . . . . . . . . . . . . . . . . . . . 418\n10.5.1 动态库是有害的. . . . . . . . . . . . . . . . . . . . . . . . . . . . 423\n10.5.2 静态库也好不到哪儿去. . . . . . . . . . . . . . . . . . . . . . . . 424\n10.5.3 源码编译是王道. . . . . . . . . . . . . . . . . . . . . . . . . . . . 428\n第11章 反思C++ 面向对象与虚函数429\n11.1 朴实的C++ 设计. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 429\n11.2 程序库的二进制兼容性. . . . . . . . . . . . . . . . . . . . . . . . . . . . 431\n11.2.1 什么是二进制兼容性. . . . . . . . . . . . . . . . . . . . . . . . . 432\n11.2.2 有哪些情况会破坏库的ABI . . . . . . . . . . . . . . . . . . . . . 433\n11.2.3 哪些做法多半是安全的. . . . . . . . . . . . . . . . . . . . . . . . 435\n11.2.4 反面教材：COM . . . . . . . . . . . . . . . . . . . . . . . . . . . 435\n11.2.5 解决办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 436\n11.3 避免使用虚函数作为库的接口. . . . . . . . . . . . . . . . . . . . . . . . 436\n11.3.1 C++ 程序库的作者的生存环境. . . . . . . . . . . . . . . . . . . . 437\n11.3.2 虚函数作为库的接口的两大用途. . . . . . . . . . . . . . . . . . 438\n11.3.3 虚函数作为接口的弊端. . . . . . . . . . . . . . . . . . . . . . . . 439\n11.3.4 假如Linux 系统调用以COM 接口方式实现. . . . . . . . . . . . 442\n11.3.5 Java 是如何应对的. . . . . . . . . . . . . . . . . . . . . . . . . . 443\n11.4 动态库接口的推荐做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . 443\n11.5 以boost::function 和boost::bind 取代虚函数. . . . . . . . . . . . . 447\n11.5.1 基本用途. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 450\n11.5.2 对程序库的影响. . . . . . . . . . . . . . . . . . . . . . . . . . . . 451\n11.5.3 对面向对象程序设计的影响. . . . . . . . . . . . . . . . . . . . . 453\n11.6 iostream 的用途与局限. . . . . . . . . . . . . . . . . . . . . . . . . . . . 457\n11.6.1 stdio 格式化输入输出的缺点. . . . . . . . . . . . . . . . . . . . . 457\n11.6.2 iostream 的设计初衷. . . . . . . . . . . . . . . . . . . . . . . . . 461\n11.6.3 iostream 与标准库其他组件的交互. . . . . . . . . . . . . . . . . 463\n11.6.4 iostream 在使用方面的缺点. . . . . . . . . . . . . . . . . . . . . 464\n11.6.5 iostream 在设计方面的缺点. . . . . . . . . . . . . . . . . . . . . 468\n11.6.6 一个300 行的memory buffer output stream . . . . . . . . . . . 476\n11.6.7 现实的C++ 程序如何做文件IO . . . . . . . . . . . . . . . . . . . 480\n11.7 值语义与数据抽象. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482\n11.7.1 什么是值语义. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482\n11.7.2 值语义与生命期. . . . . . . . . . . . . . . . . . . . . . . . . . . . 483\n11.7.3 值语义与标准库. . . . . . . . . . . . . . . . . . . . . . . . . . . . 488\n11.7.4 值语义与C++ 语言. . . . . . . . . . . . . . . . . . . . . . . . . . 488\n11.7.5 什么是数据抽象. . . . . . . . . . . . . . . . . . . . . . . . . . . . 490\n11.7.6 数据抽象所需的语言设施. . . . . . . . . . . . . . . . . . . . . . 493\n11.7.7 数据抽象的例子. . . . . . . . . . . . . . . . . . . . . . . . . . . . 495\n第12章 C++ 经验谈501\n12.1 用异或来交换变量是错误的. . . . . . . . . . . . . . . . . . . . . . . . . 501\n12.1.1 编译器会分别生成什么代码. . . . . . . . . . . . . . . . . . . . . 503\n12.1.2 为什么短的代码不一定快. . . . . . . . . . . . . . . . . . . . . . 505\n12.2 不要重载全局::operator new() . . . . . . . . . . . . . . . . . . . . . . 507\n12.2.1 内存管理的基本要求. . . . . . . . . . . . . . . . . . . . . . . . . 507\n12.2.2 重载::operator new() 的理由. . . . . . . . . . . . . . . . . . . 508\n12.2.3 ::operator new() 的两种重载方式. . . . . . . . . . . . . . . . . 508\n12.2.4 现实的开发环境. . . . . . . . . . . . . . . . . . . . . . . . . . . . 509\n12.2.5 重载::operator new() 的困境. . . . . . . . . . . . . . . . . . . 510\n12.2.6 解决办法：替换malloc() . . . . . . . . . . . . . . . . . . . . . . 512\n12.2.7 为单独的class 重载::operator new() 有问题吗. . . . . . . . . 513\n12.2.8 有必要自行定制内存分配器吗. . . . . . . . . . . . . . . . . . . . 513\n12.3 带符号整数的除法与余数. . . . . . . . . . . . . . . . . . . . . . . . . . . 514\n12.3.1 语言标准怎么说. . . . . . . . . . . . . . . . . . . . . . . . . . . . 515\n12.3.2 C\/C++ 编译器的表现. . . . . . . . . . . . . . . . . . . . . . . . . 516\n12.3.3 其他语言的规定. . . . . . . . . . . . . . . . . . . . . . . . . . . . 516\n12.3.4 脚本语言解释器代码. . . . . . . . . . . . . . . . . . . . . . . . . 517\n12.3.5 硬件实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521\n12.4 在单元测试中mock 系统调用. . . . . . . . . . . . . . . . . . . . . . . . 522\n12.4.1 系统函数的依赖注入. . . . . . . . . . . . . . . . . . . . . . . . . 522\n12.4.2 链接期垫片（link seam） . . . . . . . . . . . . . . . . . . . . . . 524\n12.5 慎用匿名namespace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 526\n12.5.1 C 语言的static 关键字的两种用法. . . . . . . . . . . . . . . . . 526\n12.5.2 C++ 语言的static 关键字的四种用法. . . . . . . . . . . . . . . . 526\n12.5.3 匿名namespace 的不利之处. . . . . . . . . . . . . . . . . . . . . 527\n12.5.4 替代办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 529\n12.6 采用有利于版本管理的代码格式. . . . . . . . . . . . . . . . . . . . . . . 529\n12.6.1 对diff 友好的代码格式. . . . . . . . . . . . . . . . . . . . . . . . 530\n12.6.2 对grep 友好的代码风格. . . . . . . . . . . . . . . . . . . . . . . 537\n12.6.3 一切为了效率. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 538\n12.7 再探std::string . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539\n12.7.1 直接拷贝（eager copy） . . . . . . . . . . . . . . . . . . . . . . . 540\n12.7.2 写时复制（copy-on-write） . . . . . . . . . . . . . . . . . . . . . 542\n12.7.3 短字符串优化（SSO） . . . . . . . . . . . . . . . . . . . . . . . . 543\n12.8 用STL algorithm 轻松解决几道算法面试题. . . . . . . . . . . . . . . . 546\n12.8.1 用next_permutation() 生成排列与组合. . . . . . . . . . . . . . 546\n12.8.2 用unique() 去除连续重复空白. . . . . . . . . . . . . . . . . . . 548\n12.8.3 用{make,push,pop}_heap() 实现多路归并. . . . . . . . . . . . 549\n12.8.4 用partition() 实现“重排数组，让奇数位于偶数前面” . . . . 553\n12.8.5 用lower_bound() 查找IP 地址所属的城市. . . . . . . . . . . . . 554\n第4 部分附录559\n附录A 谈一谈网络编程学习经验561\n附录B 从《C++ Primer（第4 版）》入手学习C++ 579\n附录C 关于Boost 的看法591\n附录D 关于TCP 并发连接的几个思考题与试验593\n参考文献599","pages":"610","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s24522799.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s24522799.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s24522799.jpg"},"alt":"https:\/\/book.douban.com\/subject\/20471211\/","id":"20471211","publisher":"电子工业出版社","isbn10":"7121192829","isbn13":"9787121192821","title":"Linux多线程服务端编程","url":"https:\/\/api.douban.com\/v2\/book\/20471211","alt_title":"","author_intro":"陈硕，北京师范大学硕士，擅长C++ 多线程网络编程和实时分布式系统架构。曾在摩根士丹利IT 部门工作5 年，从事实时外汇交易系统开发。现在在美国加州硅谷某互联网大公司工作，从事大规模分布式系统的可靠性工程。编写了开源C++ 网络库muduo，参与翻译了《代码大全（ 第2 版）》和《C++ 编程规范（繁体版）》，整理了《C++ Primer （第4 版）（评注版）》，并曾多次在各地技术大会演讲。","summary":"本书主要讲述采用现代C++ 在x86-64 Linux 上编写多线程TCP 网络服务程序的主流常规技术，重点讲解一种适应性较强的多线程服务器的编程模型，即one loop per thread。这是在Linux 下以native 语言编写用户态高性能网络程序最成熟的模式，掌握之后可顺利地开发各类常见的服务端网络应用程序。本书以muduo 网络库为例，讲解这种编程模型的使用方法及注意事项。\n本书的宗旨是贵精不贵多。掌握两种基本的同步原语就可以满足各种多线程同步的功能需求，还能写出更易用的同步设施。掌握一种进程间通信方式和一种多线程网络编程模型就足以应对日常开发任务，编写运行于公司内网环境的分布式服务统。","price":"89.00元"},{"rating":{"max":10,"numRaters":82,"average":"8.6","min":0},"subtitle":"","author":["[日] 结城浩"],"pubdate":"2017-8","tags":[{"count":142,"name":"Java","title":"Java"},{"count":115,"name":"多线程","title":"多线程"},{"count":56,"name":"并发","title":"并发"},{"count":48,"name":"设计模式","title":"设计模式"},{"count":42,"name":"计算机","title":"计算机"},{"count":41,"name":"编程","title":"编程"},{"count":28,"name":"线程","title":"线程"},{"count":13,"name":"结城浩","title":"结城浩"}],"origin_title":"","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s29520124.jpg","binding":"平装","translator":["侯振龙","杨文轩"],"catalog":"序章1　Java线程　　1\nI1.1　Java线程　　2\nI1.2　何谓线程　　2\n明为跟踪处理流程，实为跟踪线程　　2\n单线程程序　　3\n多线程程序　　4\nThread类的run方法和start方法　　5\nI1.3　线程的启动　　9\n线程的启动（1）——利用Thread类的子类　　9\n线程的启动（2）——利用Runnable接口　　10\nI1.4　线程的暂停　　12\nI1.5　线程的互斥处理　　13\nsynchronized方法　　14\nsynchronized代码块　　17\nI1.6　线程的协作　　18\n等待队列——线程休息室　　19\nwait方法——将线程放入等待队列　　19\nnotify方法——从等待队列中取出线程　　21\nnotifyAll方法——从等待队列中取出所有线程　　23\nwait、notify、notifyAll是Object类的方法　　24\nI1.7　线程的状态迁移　　24\nI1.8　线程相关的其他话题　　26\nI1.9　本章所学知识　　26\nI1.10　　练习题　　26\n序章2　多线程程序的评价标准　　31\nI2.1　多线程程序的评价标准　　32\n安全性——不损坏对象　　32\n生存性——必要的处理能够被执行　　32\n可复用性——类可重复利用　　33\n性能——能快速、大批量地执行处理　　33\n评价标准总结　　33\nI2.2　本章所学知识　　34\nI2.3　练习题　　34\n第1章　　Single Threaded Execution模式——能通过这座桥的只有一个人　　35\n1.1　Single Threaded Execution模式　　36\n1.2　示例程序1：不使用Single Threaded Execution模式的程序　　36\nMain类　　37\n非线程安全的Gate类　　37\nUserThread类　　38\n执行起来看看……出错了　　39\n为什么会出错呢　　40\n1.3　示例程序2：使用Single Threaded Execution模式的程序　　41\n线程安全的Gate类　　41\nsynchronized的作用　　42\n1.4　Single Threaded Execution模式中的登场角色　　43\n1.5　拓展思路的要点　　44\n何时使用（可使用Single Threaded Execution模式的情况）　　44\n生存性与死锁　　45\n可复用性和继承反常　　46\n临界区的大小和性能　　46\n1.6　相关的设计模式　　47\nGuarded Suspension模式　　47\nRead-Write Lock模式　　47\nImmutable模式　　47\nThread-Specific Storage模式　　48\n1.7　延伸阅读1：关于synchronized　　48\nsynchronized语法与Before\/After模式　　48\nsynchronized在保护着什么　　49\n该以什么单位来保护呢　　50\n使用哪个锁保护　　50\n原子操作　　51\nlong与double的操作不是原子的　　51\n1.8　延伸阅读2：java.util.concurrent包和计数信号量　　52\n计数信号量和Semaphore类　　52\n使用Semaphore类的示例程序　　52\n1.9　本章所学知识　　55\n1.10　　练习题　　55\n第2章　　Immutable模式——想破坏也破坏不了　　61\n2.1　Immutable模式　　62\n2.2　示例程序　　62\n使用Immutable模式的Person类　　62\nMain类　　63\nPrintPersonThread类　　63\n2.3　Immutable模式中的登场角色　　65\n2.4　拓展思路的要点　　66\n何时使用（可使用Immutable模式的情况）　　66\n考虑成对的mutable类和immutable类 [性能]　　66\n为了确保不可变性 [可复用性]　　67\n标准类库中用到的Immutable模式　　67\n2.5　相关的设计模式　　69\nSingle Threaded Execution模式　　69\nRead-Write Lock模式　　69\nFlyweight模式　　69\n2.6　延伸阅读1：final　　69\nfinal的含义　　69\n2.7　延伸阅读2：集合类与多线程　　71\n示例1：非线程安全的java.util.ArrayList类　　71\n示例2：利用Collections.synchronizedList方法所进行的同步　　74\n示例3：使用copy-on-write的java.util.concurrent.CopyOnWriteArrayList类　　75\n2.8　本章所学知识　　76\n2.9　练习题　　77\n第3章　　Guarded Suspension模式——等我准备好哦　　81\n3.1　Guarded Suspension模式　　82\n3.2　示例程序　　82\nRequest类　　83\nRequestQueue类　　84\nClientThread类　　85\nServerThread类　　85\nMain类　　86\njava.util.Queue与java.util.LinkedList的操作　　87\ngetRequest详解　　87\nputRequest详解　　89\nsynchronized的含义　　89\nwait与锁　　89\n3.3　Guarded Suspension模式中的登场角色　　90\n3.4　拓展思路的要点　　91\n附加条件的synchronized　　91\n多线程版本的if　　91\n忘记改变状态与生存性　　91\nwait与notify\/notifyAll的责任 [可复用性]　　91\n各种称呼　　91\n使用java.util.concurrent.LinkedBlockingQueue的示例程序　　93\n3.5　相关的设计模式　　94\nSingle Threaded Execution模式　　94\nBalking模式　　94\nProducer-Consumer模式　　94\nFuture模式　　94\n3.6　本章所学知识　　95\n3.7　练习题　　95\n第4章　　Balking模式——不需要就算了　　99\n4.1　Balking模式　　100\n4.2　示例程序　　100\nData类　　100\nSaverThread类　　102\nChangerThread类　　102\nMain类　　103\n4.3　Balking模式中的登场角色　　105\n4.4　拓展思路的要点　　106\n何时使用（可使用Balking模式的情况）　　106\nbalk结果的表示方式　　107\n4.5　相关的设计模式　　107\nGuarded Suspension模式　　107\nObserver模式　　107\n4.6　延伸阅读：超时　　108\nBalking模式和Guarded Suspension模式之间　　108\nwait何时终止呢　　108\nguarded timed的实现（使用wait）　　109\nsynchronized中没有超时，也不能中断　　110\njava.util.concurrent中的超时　　111\n4.7　本章所学知识　　111\n4.8　练习题　　112\n第5章　　Producer-Consumer模式——我来做，你来用　　115\n5.1　Producer-Consumer模式　　116\n5.2　示例程序　　116\nMain类　　116\nMakerThread类　　117\nEaterThread类　　118\nTable类　　118\n解读put方法　　120\n解读take方法　　121\n5.3　Producer-Consumer模式中的登场角色　　122\n5.4　拓展思路的要点　　123\n守护安全性的Channel角色（可复用性）　　123\n不可以直接传递吗　　124\nChannel角色的剩余空间所导致的问题　　124\n以什么顺序传递Data角色呢　　125\n“存在中间角色”的意义　　125\nConsumer角色只有一个时会怎么样呢　　126\n5.5　相关的设计模式　　126\nMediator模式　　126\nWorker Thread模式　　126\nCommand模式　　126\nStrategy模式　　127\n5.6　延伸阅读1：理解InterruptedException异常　　127\n可能会花费时间，但可以取消　　127\n加了throws InterruptedException的方法　　127\nsleep方法和interrupt方法　　128\nwait方法和interrupt方法　　128\njoin方法和interrupt方法　　129\ninterrupt方法只是改变中断状态　　129\nisInterrupted方法——检查中断状态　　130\nThread.interrupted方法——检查并清除中断状态　　130\n不可以使用Thread类的stop方法　　130\n5.7　延伸阅读2：java.util.concurrent包和Producer-Consumer模式　　131\njava.util.concurrent包中的队列　　131\n使用java.util.concurrent.ArrayBlockingQueue的示例程序　　132\n使用java.util.concurrent.Exchanger类交换缓冲区　　133\n5.8　本章所学知识　　136\n5.9　练习题　　137\n第6章　　Read-Write Lock模式——大家一起读没问题，但读的时候不要写哦　　141\n6.1　Read-Write Lock模式　　142\n6.2　示例程序　　142\nMain类　　143\nData类　　143\nWriterThread类　　146\nReaderThread类　　146\nReadWriteLock类　　147\n执行起来看看　　149\n守护条件的确认　　150\n6.3　Read-Write Lock模式中的登场角色　　151\n6.4　拓展思路的要点　　153\n利用“读取”操作的线程之间不会冲突的特性来提高程序性能　　153\n适合读取操作繁重时　　153\n适合读取频率比写入频率高时　　153\n锁的含义　　153\n6.5　相关的设计模式　　154\nImmutable模式　　154\nSingle Threaded Execution模式　　154\nGuarded Suspension模式　　154\nBefore\/After模式　　154\nStrategized Locking模式　　154\n6.6　延伸阅读：java.util.concurrent.locks包和Read-Write Lock模式　　154\njava.util.concurrent.locks包　　154\n使用java.util.concurrent.locks的示例程序　　155\n6.7　本章所学知识　　156\n6.8　练习题　　157\n第7章　　Thread-Per-Message模式——这项工作就交给你了　　163\n7.1　Thread-Per-Message模式　　164\n7.2　示例程序　　164\nMain类　　164\nHost类　　165\nHelper类　　166\n7.3　Thread-Per-Message模式中的登场角色　　168\n7.4　拓展思路的要点　　169\n提高响应性，缩短延迟时间　　169\n适用于操作顺序没有要求时　　169\n适用于不需要返回值时　　169\n应用于服务器　　169\n调用方法＋启动线程→发送消息　　170\n7.5　相关的设计模式　　170\nFuture模式　　170\nWorker Thread模式　　170\n7.6　延伸阅读1：进程与线程　　171\n7.7　延伸阅读2：java.util.concurrent包和Thread-Per-Message模式　　171\njava.lang.Thread类　　171\njava.lang.Runnable接口　　172\njava.util.concurrent.ThreadFactory接口　　173\njava.util.concurrent.Executors类获取的ThreadFactory　　174\njava.util.concurrent.Executor接口　　175\njava.util.concurrent.ExecutorService接口　　176\njava.util.concurrent.ScheduledExecutorService类　　177\n总结　　178\n7.8　本章所学知识　　180\n7.9　练习题　　180\n第8章　　Worker Thread模式——工作没来就一直等，工作来了就干活　　187\n8.1　Worker Thread模式　　188\n8.2　示例程序　　188\nMain类　　189\nClientThread类　　190\nRequest类　　190\nChannel类　　191\nWorkerThread类　　192\n8.3　Worker Thread模式中的登场角色　　193\n8.4　拓展思路的要点　　195\n提高吞吐量　　195\n容量控制　　195\n调用与执行的分离　　196\nRunnable接口的意义　　197\n多态的Request角色　　198\n独自一人的Worker角色　　199\n8.5　相关的设计模式　　199\nProducer-Consumer模式　　199\nThread-Per-Message模式　　199\nCommand模式　　199\nFuture模式　　199\nFlyweight模式　　199\nThread-Specific Storage模式　　200\nActive Ojbect模式　　200\n8.6　延伸阅读1：Swing事件分发线程　　200\n什么是事件分发线程　　200\n事件分发线程只有一个　　200\n事件分发线程调用监听器　　201\n注册监听器的意义　　201\n事件分发线程也负责绘制界面　　201\njavax.swing.SwingUtilities类　　202\nSwing的单线程规则　　203\n8.7　延伸阅读2：java.util.concurrent包和Worker Thread模式　　204\nThreadPoolExecutor类　　204\n通过java.util.concurrent包创建线程池　　205\n8.8　本章所学知识　　207\n8.9　练习题　　208\n第9章　　Future模式——先给您提货单　　211\n9.1　Future模式　　212\n9.2　示例程序　　212\nMain类　　214\nHost类　　214\nData接口　　215\nFutureData类　　216\nRealData类　　217\n9.3　Future模式中的登场角色　　218\n9.4　拓展思路的要点　　219\n吞吐量会提高吗　　219\n异步方法调用的“返回值”　　220\n“准备返回值”和“使用返回值”的分离　　220\n变种——不让主线程久等的Future角色　　220\n变种——会发生变化的Future角色　　221\n谁会在意多线程呢？“可复用性”　　221\n回调与Future模式　　221\n9.5　相关的设计模式　　222\nThread-Per-Message模式　　222\nBuilder模式　　222\nProxy模式　　222\nGuarded Suspension模式　　222\nBalking模式　　222\n9.6　延伸阅读：java.util.concurrent包与Future模式　　222\njava.util.concurrent包　　222\n使用了java.util.concurrent包的示例程序　　223\n9.7　本章所学知识　　226\n9.8　练习题　　226\n第10章　　Two-Phase Termination模式——先收拾房间再睡觉　　231\n10.1　Two-Phase Termination模式　　232\n10.2　示例程序　　233\nCountupThread类　　234\nMain类　　236\n10.3　Two-Phase Termination模式中的登场角色　　237\n10.4　拓展思路的要点　　238\n不能使用Thread类的stop方法　　238\n仅仅检查标志是不够的　　239\n仅仅检查中断状态是不够的　　239\n在长时间处理前检查终止请求　　239\njoin方法和isAlive方法　　240\njava.util.concurrent.ExecutorService接口与Two-Phase Termination模式　　240\n要捕获程序整体的终止时　　241\n优雅地终止线程　　243\n10.5　相关的设计模式　　243\nBefore\/After模式　　243\nMultiphase Cancellation模式　　243\nMulti-Phase Startup模式　　244\nBalking模式　　244\n10.6　延伸阅读1：中断状态与InterruptedException异常的相互转换　　244\n中断状态→InterruptedException异常的转换　　244\nInterruptedException异常→中断状态的转换　　245\nInterruptedException异常→InterruptedException异常的转换　　245\n10.7　延伸阅读2：java.util.concurrent包与线程同步　　246\njava.util.concurrent.CountDownLatch类　　246\njava.util.concurrent.CyclicBarrier类　　249\n10.8　本章所学知识　　253\n10.9　练习题　　253\n第11章　　Thread-Specific Storage模式——一个线程一个储物柜　　263\n11.1　Thread-Specific Storage模式　　264\n11.2　关于java.lang.ThreadLocal类　　264\njava.lang.ThreadLocal就是储物间　　264\njava.lang.ThreadLocal与泛型　　265\n11.3　示例程序1：不使用Thread-Specific Storage模式的示例　　265\nLog类　　266\nMain类　　266\n11.4　示例程序2：使用了Thread-Specific Storage模式的示例　　267\n线程特有的TSLog类　　268\nLog类　　269\nClientThread类　　270\nMain类　　271\n11.5　Thread-Specific Storage模式中的登场角色　　272\n11.6　拓展思路的要点　　274\n局部变量与java.lang.ThreadLocal类　　274\n保存线程特有的信息的位置　　275\n不必担心其他线程访问　　275\n吞吐量的提高很大程序上取决于实现方式　　276\n上下文的危险性　　276\n11.7　相关的设计模式　　277\nSingleton模式　　277\nWorker Thread模式　　277\nSingle Threaded Execution模式　　277\nProxy模式　　277\n11.8　延伸阅读：基于角色与基于任务　　277\n主体与客体　　277\n基于角色的考虑方式　　278\n基于任务的考虑方式　　278\n实际上两种方式是综合在一起的　　279\n11.9　本章所学知识　　279\n11.10　　练习题　　280\n第12章　　Active Object模式——接收异步消息的主动对象　　283\n12.1　Active Object模式　　284\n12.2　示例程序1　284\n调用方：Main类　　287\n调用方：MakerClientThread类　　288\n调用方：DisplayClientThread类　　289\n主动对象方：ActiveObject接口　　289\n主动对象方：ActiveObjectFactory类　　290\n主动对象方：Proxy类　　290\n主动对象方：SchedulerThread类　　291\n主动对象方：ActivationQueue类　　292\n主动对象方：MethodRequest类　　293\n主动对象方：MakeStringRequest类　　294\n主动对象方：DisplayStringRequest类　　295\n主动对象方：Result类　　295\n主动对象方：FutureResult类　　296\n主动对象方：RealResult类　　296\n主动对象方：Servant类　　297\n示例程序1的运行　　297\n12.3　ActiveObject模式中的登场角色　　298\n12.4　拓展思路的要点　　304\n到底做了些什么事情　　304\n运用模式时需要考虑问题的粒度　　304\n关于并发性　　304\n增加方法　　305\nScheduler角色的作用　　305\n主动对象之间的交互　　306\n通往分布式——从跨越线程界线变为跨越计算机界线　　306\n12.5　相关的设计模式　　306\nProducer-Consumer模式　　306\nFuture模式　　307\nWorker Thread模式　　307\nThread-Specific Storage模式　　307\n12.6　延伸阅读：java.util.concurrent包与Active Object模式　　307\n类与接口　　307\n调用方：Main类　　309\n调用方：MakerClientThread类　　309\n调用方：DisplayClientThread类　　310\n主动对象方：ActiveObject接口　　311\n主动对象方：ActiveObjectFactory类　　311\n主动对象：ActiveObjectImpl类　　312\n示例程序2的运行　　313\n12.7　本章所学知识　　314\n12.8　练习题　　315\n第13章　　总结——多线程编程的模式语言　　321\n13.1　多线程编程的模式语言　　322\n模式与模式语言　　322\n13.2　Single Threaded Execution模式\n——能通过这座桥的只有一个人　　323\n13.3　Immutable模式\n——想破坏也破坏不了　　324\n13.4　Guarded Suspension模式\n——等我准备好哦　　325\n13.5　Balking模式\n——不需要就算了　　326\n13.6　Producer-Consumer模式\n——我来做，你来用　　327\n13.7　Read-Write Lock模式\n——大家一起读没问题，但读的时候不要写哦　　328\n13.8　Thread-Per-Message模式\n——这项工作就交给你了　　329\n13.9　Worker Thread模式\n——工作没来就一直等，工作来了就干活　　330\n13.10　　Future模式\n——先给您提货单　　330\n13.11　Two-Phase Termination模式\n——先收拾房间再睡觉　　331\n13.12　Thread-Specific Storage模式\n——一个线程一个储物柜　　332\n13.13　Active Object模式\n——接收异步消息的主动对象　　333\n13.14　写在最后　　335\n附录　　337\n附录A　习题解答　　338\n附录B　Java内存模型　　447\n附录C　Java线程的优先级　　467\n附录D　线程相关的主要API　　469\n附录E　java.util.concurrent包　　475\n附录F　示例程序的运行步骤　　483\n附录G　参考文献　　485","pages":"528","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s29520124.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s29520124.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s29520124.jpg"},"alt":"https:\/\/book.douban.com\/subject\/27116724\/","id":"27116724","publisher":"人民邮电出版社","isbn10":"7115462747","isbn13":"9787115462749","title":"图解Java多线程设计模式","url":"https:\/\/api.douban.com\/v2\/book\/27116724","alt_title":"","author_intro":"作者简介：\n结城浩\n生于1963年，日本资深技术作家和程序员。在编程语言、设计模式、数学、加密技术等领域，编写了很多深受欢迎的入门书。代表作有《数学女孩》系列、《程序员的数学》、《图解密码技术》等。\n侯振龙\n管理科学与工程专业硕士，日语一级，软件开发工程师，具有十年对日软件开发经验，现就职于某日本独资企业。\n译者简介：\n杨文轩\n华中科技大学硕士，擅长Web 2.0开发，有丰富的对日开发经验。现就职于日本方正股份有限公司。译作有《图解基础设施设计模式》《C现代编程：集成开发环境、设计模式、极限编程、测试驱动开发、重构、持续集成》及《图解设计模式》。","summary":"本书通过具体的Java 程序，以浅显易懂的语言逐一说明了多线程和并发处理中常用的12 种设计模式。内容涉及线程的基础知识、线程的启动与终止、线程间的互斥处理与协作、线程的有效应用、线程的数量管理以及性能优化的注意事项等。此外，还介绍了一些多线程编程时容易出现的失误，以及多线程程序的阅读技巧等。在讲解过程中，不仅以图配文，理论结合实例，而且提供了运用模式解决具体问题的练习题和答案，帮助读者加深对多线程和并发处理的理解，并掌握其使用技巧。","series":{"id":"34135","title":"图灵程序设计丛书·图解与入门系列"},"price":"89.00元"},{"rating":{"max":10,"numRaters":275,"average":"8.6","min":0},"subtitle":"iOS与OS X多线程和内存管理","author":["坂本一树 (Kazuki Sakamoto)","古本智彦 (Tomohiko Furumoto)"],"pubdate":"2013-6-1","tags":[{"count":248,"name":"Objective-C","title":"Objective-C"},{"count":208,"name":"iOS","title":"iOS"},{"count":116,"name":"iOS进阶","title":"iOS进阶"},{"count":50,"name":"编程","title":"编程"},{"count":47,"name":"计算机","title":"计算机"},{"count":36,"name":"软件开发","title":"软件开发"},{"count":28,"name":"Objectiv-C","title":"Objectiv-C"},{"count":27,"name":"编程语言","title":"编程语言"}],"origin_title":"Pro multithreading and memory  management for iOS and OS X","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s28100915.jpg","binding":"平装","translator":["黎 华"],"catalog":"第1章 自动引用计数　　1\n1.1 　什么是自动引用计数　　2\n1.2 　内存管理\/引用计数　　2\n1.2.1 　概要　　2\n1.2.2 　内存管理的思考方式　　5\n1.2.3 　alloc\/retain\/release\/dealloc实现　　13\n1.2.4 　苹果的实现　　17\n1.2.5 　autorelease　　20\n1.2.6 　autorelease实现　　24\n1.2.7 　苹果的实现　　26\n1.3 　ARC规则　　29\n1.3.1 　概要　　29\n1.3.2 　内存管理的思考方式　　30\n1.3.3 　所有权修饰符　　30\n1.3.4 　规则　　50\n1.3.5 　属性　　62\n1.3.6 　数组　　63\n1.4 　ARC的实现　　65\n1.4.1 　__strong修饰符　　65\n1.4.2 　__weak修饰符　　67\n1.4.3 　__autoreleasing修饰符　　75\n1.4.4 　引用计数　　76\n第2章 Blocks　　79\n2.1 　Blocks概要　　80\n2.1.1 　什么是Blocks　　80\n2.2 　Blocks模式　　83\n2.2.1 　Block语法　　83\n2.2.2 　Block类型变量　　85\n2.2.3 　截获自动变量值　　88\n2.2.4 　__block说明符　　88\n2.2.5 　截获的自动变量　　89\n2.3 　Blocks的实现　　91\n2.3.1 　Block的实质　　91\n2.3.2 　截获自动变量值　　99\n2.3.3 　__block说明符　　102\n2.3.4 　Block存储域　　108\n2.3.5 　__block变量存储域　　117\n2.3.6 　截获对象　　121\n2.3.7 　__block变量和对象　　126\n2.3.8 　Block循环引用　　128\n2.3.9 　copy\/release　　134\n第3章 Grand Central Dispatch　　137\n3.1 　Grand Central Dispatch（GCD）概要　　138\n3.1.1 　什么是GCD　　138\n3.1.2 　多线程编程　　140\n3.2 　GCD的API　　144\n3.2.1 　Dispatch Queue　　144\n3.2.2 　dispatch_queue_create　　147\n3.2.3 　Main Dispatch Queue\/Global Dispatch Queue　　150\n3.2.4 　dispatch_set_target_queue　　153\n3.2.5 　dispatch_after　　154\n3.2.6 　Dispatch Group　　155\n3.2.7 　dispatch_barrier_async　　157\n3.2.8 　dispatch_sync　　160\n3.2.9 　dispatch_apply　　161\n3.2.10 　dispatch_suspend \/ dispatch_resume　　163\n3.2.11 　Dispatch Semaphore　　164\n3.2.12 　dispatch_once　　166\n3.2.13 　Dispatch I\/O　　167\n3.3 　GCD实现　　169\n3.3.1 　Dispatch Queue　　169\n3.3.2 　Dispatch Source　　171\n附录A 　ARC、Blocks、GCD使用范例　　176\n附录B 　参考资料　　182","pages":"186","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s28100915.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s28100915.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s28100915.jpg"},"alt":"https:\/\/book.douban.com\/subject\/24720270\/","id":"24720270","publisher":"人民邮电出版社","isbn10":"7115318093","isbn13":"9787115318091","title":"Objective-C高级编程","url":"https:\/\/api.douban.com\/v2\/book\/24720270","alt_title":"Pro multithreading and memory  management for iOS and OS X","author_intro":"Kazuki Sakamoto\n日本资深软件工程师，具有17年开发经验。在StackOverflow上的威望值超过4500。著有《iOS 4编程基础》、《iPhone&iPad cocos2d游戏编程》等。Twitter：@splhack。\nTomohiko Furumoto\n日本资深软件工程师，擅长游戏和移动应用开发。Twitter：@munakoiso。","summary":"本书在苹果公司公开的源代码基础上，深入剖析了对应用于内存管理的ARC 以及应用于多线程开发的Blocks 和GCD。这些新技术看似简单，实则非常容易成为技术开发的陷阱，开发者仅靠阅读苹果公司的文档是不够的。\n本书适合有一定基础的iOS 开发者阅读。","series":{"id":"28336","title":"图灵程序设计丛书·移动开发系列"},"price":"CNY 49.00"},{"rating":{"max":10,"numRaters":181,"average":"5.0","min":0},"subtitle":"Java Multi-thread Programming","author":["高洪岩"],"pubdate":"2015-6-1","tags":[{"count":79,"name":"Java","title":"Java"},{"count":72,"name":"多线程","title":"多线程"},{"count":23,"name":"堆代码而已","title":"堆代码而已"},{"count":22,"name":"java","title":"java"},{"count":20,"name":"java多线程","title":"java多线程"},{"count":18,"name":"并发","title":"并发"},{"count":15,"name":"计算机","title":"计算机"},{"count":13,"name":"java——多线程","title":"java——多线程"}],"origin_title":"","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s28238985.jpg","binding":"平装","translator":[],"catalog":"前 言\n第1章 Java多线程技能，\n1.1 进程和多线程的概念及线程的优点\n1.2 使用多线程\n1.2.1 继承Thread类\n1.2.2 实现Runnable接口\n1.2.3 实例变量与线程安全\n1.2.4 留意i——与System.out.println（）的异常\n1.3 currentThread（）方法\n1.4 isAlive（）方法\n1.5 sleep（）方法\n1.6 getId（）方法\n1.7 停止线程\n1.7.1 停止不了的线程\n1.7.2 判断线程是否是停止状态\n1.7.3 能停止的线程——异常法\n1.7.4 在沉睡中停止\n1.7.5 能停止的线程——暴力停止\n1.7.6 方法stop（）与java.lang.ThreadDeath异常\n1.7.7 释放锁的不良后果\n1.7.8 使用return停止线程\n1.8 暂停线程\n1.8.1 suspend与resume方法的使用\n1.8.2 suspend与resume方法的缺点——独占\n1.8.3 suspend与resume方法的缺点——不同步\n1.9 yield方法\n1.10 线程的优先级\n1.10.1 线程优先级的继承特性\n1.10.2 优先级具有规则性\n1.10.3 优先级具有随机性\n1.10.4 看谁运行得快\n1.11 守护线程\n1.12 本章小结\n第2章 对象及变量的并发访问\n2.1 synchronized同步方法\n2.1.1 方法内的变量为线程安全\n2.1.2 实例变量非线程安全\n2.1.3 多个对象多个锁\n2.1.4 synchronized方法与锁对象\n2.1.5 脏读\n2.1.6 synchronized锁重入\n2.1.7 出现异常，锁自动释放\n2.1.8 同步不具有继承性\n2.2 synchronized同步语句块\n2.2.1 synchronized方法的弊端\n2.2.2 synchronized同步代码块的使用\n2.2.3 用同步代码块解决同步方法的弊端\n2.2.4 一半异步，一半同步\n2.2.5 synchronized代码块间的同步性\n2.2.6 验证同步synchronized（this）代码块是锁定当前对象的\n2.2.7 将任意对象作为对象监视器\n2.2.8 细化验证3个结论\n2.2.9 静态同步synchronized方法与synchronized（class）代码块\n2.2.10 数据类型String的常量池特性\n2.2.11 同步synchronized方法无限等待与解决\n2.2.12 多线程的死锁\n2.2.13 内置类与静态内置类\n2.2.14 内置类与同步：实验1\n2.2.15 内置类与同步：实验2\n2.2.16 锁对象的改变\n2.3 volatile关键字\n2.3.1 关键字volatile与死循环\n2.3.2 解决同步死循环\n2.3.3 解决异步死循环\n2.3.4 volatile非原子的特性\n2.3.5 使用原子类进行i++操作\n2.3.6 原子类也并不完全安全\n2.3.7 synchronized代码块有volatile同步的功能\n2.4 本章总结\n第3章 线程间通信\n3.1 等待\/通知机制\n3.1.1 不使用等待\/通知机制实现线程间通信\n3.1.2 什么是等待\/通知机制\n3.1.3 等待\/通知机制的实现\n3.1.4 方法wait（）锁释放与notify（）锁不释放\n3.1.5 当interrupt方法遇到wait方法\n3.1.6 只通知一个线程\n3.1.7 唤醒所有线程\n3.1.8 方法wait（long）的使用\n3.1.9 通知过早\n3.1.10 等待wait的条件发生变化\n3.1.11 生产者\/消费者模式实现\n3.1.12 通过管道进行线程间通信：字节流\n3.1.13 通过管道进行线程间通信：字符流\n3.1.14 实战：等待\/通知之交叉备份\n3.2 方法join的使用\n3.2.1 学习方法join前的铺垫\n3.2.2 用join（）方法来解决\n3.2.3 方法join与异常\n3.2.4 方法join（long）的使用\n3.2.5 方法join（long）与sleep（long）的区别\n3.2.6 方法join（）后面的代码提前运行：出现意外\n3.2.7 方法join（）后面的代码提前运行：解释意外\n3.3 类ThreadLocal的使用\n3.3.1 方法get（）与null\n3.3.2 验证线程变量的隔离性\n3.3.3 解决get（）返回null问题\n3.3.4 再次验证线程变量的隔离性\n3.4 类InheritableThreadLocal的使用\n3.4.1 值继承\n3.4.2 值继承再修改\n3.5 本章总结\n第4章 Lock的使用\n4.1 使用ReentrantLock类\n4.1.1 使用ReentrantLock实现同步：测试1\n4.1.2 使用ReentrantLock实现同步：测试2\n4.1.3 使用Condition实现等待\/通知错误用法与解决\n4.1.4 正确使用Condition实现等待\/通知\n4.1.5 使用多个Condition实现通知部分线程：错误用法\n4.1.6 使用多个Condition实现通知部分线程：正确用法\n4.1.7 实现生产者\/消费者模式：一对一交替打印\n4.1.8 实现生产者\/消费者模式：多对多交替打印\n4.1.9 公平锁与非公平锁\n4.1.10 方法getHoldCount（）、getQueueLength（）和getWaitQueueLength（）的测试\n4.1.11 方法hasQueuedThread（）、hasQueuedThreads（）和hasWaiters（）的测试\n4.1.12 方法isFair（）、isHeldByCurrentThread（）和isLocked（）的测试\n4.1.13 方法lockInterruptibly（）、tryLock（）和tryLock（long timeout，TimeUnit unit）的测试\n4.1.14 方法awaitUninterruptibly（）的使用\n4.1.15 方法awaitUntil（）的使用\n4.1.16 使用Condition实现顺序执行\n4.2 使用ReentrantReadWriteLock类\n4.2.1 类ReentrantReadWriteLock的使用：读读共享\n4.2.2 类ReentrantReadWriteLock的使用：写写互斥\n4.2.3 类ReentrantReadWriteLock的使用：读写互斥\n4.2.4 类ReentrantReadWriteLock的使用：写读互斥\n4.3 本章总结\n第5章 定时器Timer\n5.1 定时器Timer的使用\n5.1.1 方法schedule（TimerTask task， Date time）的测试\n5.1.2 方法schedule（TimerTask task， Date firstTime， long period）的测试\n5.1.3 方法schedule（TimerTask task， long delay）的测试\n5.1.4 方法schedule（TimerTask task， long delay， long period）的测试\n5.1.5 方法scheduleAtFixedRate（TimerTask task， Date firstTime， long period）的测试\n5.2 本章总结\n第6章 单例模式与多线程\n6.1 立即加载\/\"饿汉模式\"\n6.2 延迟加载\/\"懒汉模式\"\n6.3 使用静态内置类实现单例模式\n6.4 序列化与反序列化的单例模式实现\n6.5 使用static代码块实现单例模式\n6.6 使用enum枚举数据类型实现单例模式\n6.7 完善使用enum枚举实现单例模式\n6.8 本章总结\n第7章 拾遗增补\n7.1 线程的状态\n7.1.1 验证NEW、RUNNABLE和TERMINATED\n7.1.2 验证TIMED_WAITING\n7.1.3 验证BLOCKED\n7.1.4 验证WAITING\n7.2 线程组\n7.2.1 线程对象关联线程组：1级关联\n7.2.2 线程对象关联线程组：多级关联\n7.2.3 线程组自动归属特性\n7.2.4 获取根线程组\n7.2.5 线程组里加线程组\n7.2.6 组内的线程批量停止\n7.2.7 递归与非递归取得组内对象\n7.3 使线程具有有序性\n7.4 SimpleDateFormat非线程安全\n7.4.1 出现异常\n7.4.2 解决异常方法1\n7.4.3 解决异常方法2\n7.5 线程中出现异常的处理\n7.6 线程组内处理异常\n7.7 线程异常处理的传递\n7.8 本章总结","pages":"306","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s28238985.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s28238985.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s28238985.jpg"},"alt":"https:\/\/book.douban.com\/subject\/26555197\/","id":"26555197","publisher":"机械工业出版社","isbn10":"711150206X","isbn13":"9787111502067","title":"Java多线程编程核心技术","url":"https:\/\/api.douban.com\/v2\/book\/26555197","alt_title":"","author_intro":"高洪岩 某世界500强企业高级项目经理，10余年项目管理与开发经验，10年Java相关开发经验，深谙Java技术开发难点与要点，拥有良好的技术素养和丰富的实践经验。精通J2EE核心技术、基于EJB的分布式系统开发、Android移动开发、智能报表、多线程及高并发等相关的技术内容，近期持续关注并发相关的前沿技术。喜欢技术与教育相结合的方式共享知识，以共同提高。生活中喜欢摄影， 对轮滑，旅游，航模亦兴趣浓厚。","summary":"资深Java专家10年经验总结，全程案例式讲解，首本全面介绍Java多线程编程技术的专著\n结合大量实例，全面讲解Java多线程编程中的并发访问、线程间通信、锁等最难突破的核心技术与应用实践\nJava多线程无处不在，如服务器、数据库、应用。多线程可以有效提升计算和处理效率，大大提升吞吐量和可伸缩性，深得广大程序员和公司的青睐。很多人学习完JavaSE\/JavaEE之后想往更深入的技术进行探索，比如对大数据、分布式、高并发类的专题进行攻克时，立即遇到针对java.lang包中线程类的学习，但线程类的学习并不像JDBC一样简单，学习曲线陡峭，多弯路与“坑”。要学习这些热点技术，Java多线程技术避无可避。而本书将引领读者拿下该“技术高地”。\n本书有以下特点：\n不留遗漏——全面覆盖Java语言多线程知识点；\n直击要害——实战化案例精准定位技术细节；\n学以至用——精要式演示确保开发\/学习不脱节；\n潜移默化——研磨式知识讲解参透技术要点；\n提升效率——垂直式技术精解不绕弯路；\n循序提升——渐进式知识点统排确保连贯。","series":{"id":"34391","title":"Java核心技术系列"},"price":"69.00"},{"rating":{"max":10,"numRaters":47,"average":"8.4","min":0},"subtitle":"南梦宫一线程序员的开发实例","author":["[日]加藤政树"],"pubdate":"2015-2","tags":[{"count":95,"name":"游戏开发","title":"游戏开发"},{"count":83,"name":"unity3D","title":"unity3D"},{"count":49,"name":"游戏设计","title":"游戏设计"},{"count":43,"name":"游戏","title":"游戏"},{"count":28,"name":"计算机","title":"计算机"},{"count":28,"name":"程序设计","title":"程序设计"},{"count":17,"name":"遊戲開發","title":"遊戲開發"},{"count":17,"name":"编程","title":"编程"}],"origin_title":"","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s27995300.jpg","binding":"平装","translator":["罗水东"],"catalog":"第0章　Unity概要　　1\n0.1　Unity基础　Concept　　2\n0.1.1　脚本一览　　2\n0.1.2　本章小节　　2\n0.1.3　本章开发的小游戏　　2\n0.2　入门教程（上）——创建项目　Tips　　3\n0.2.1　概要　　3\n0.2.2　创建新项目　　3\n0.2.3　创建地面（创建游戏对象）　　4\n0.2.4　创建场景，保存项目　　5\n0.2.5　让地面围绕原点移动　　7\n0.2.6　调整场景视图的摄像机　　8\n0.2.7　创建方块和小球（创建游戏对象并调整坐标）　　9\n0.2.8　运行游戏　　12\n0.2.9　模拟物理运动（添加Rigidbody组件）　　12\n0.2.10　让小方块跳起来（添加游戏脚本）　　13\n0.2.11　修改游戏对象的名字　　17\n0.2.12　修改游戏对象的颜色（创建材质）　　17\n0.2.13　让画面更明亮（创建光源）　　19\n0.2.14　调整游戏画面的尺寸（调整播放器设置）　　19\n0.2.15　小结　　21\n0.3　入门教程（下）——让游戏更有趣　Tips　　21\n0.3.1　概要　　21\n0.3.2　让小球飞起来（物理运动和速度）　　21\n0.3.3　创建大量小球（预设游戏对象）　　23\n0.3.4　整理项目视图　　24\n0.3.5　发射小球（通过脚本创建游戏对象）　　26\n0.3.6　删除画面外的小球（通过脚本删除游戏对象）　　29\n0.3.7　防止小方块在空中起跳（发生碰撞时的处理）　　30\n0.3.8　禁止小方块旋转（抑制旋转）　　32\n0.3.9　让小方块不被弹开（设置重量）　　33\n0.3.10　让小球强烈反弹（设置物理材质）　　34\n0.3.11　消除“漂浮感”（调整重力大小）　　36\n0.3.12　调整摄像机的位置　　37\n0.3.13　修复空中起跳的bug（区分碰撞对象）　　39\n0.3.14　小结　　44\n0.4　C#和JavaScript的对比　Tips　　44\n0.4.1　概要　　44\n0.4.2　类的定义　　45\n0.4.3　变量定义　　45\n0.4.4　函数的定义　　46\n0.4.5　作用域　　47\n0.4.6　静态函数和静态变量的定义　　47\n0.4.7　范型方法的调用　　47\n0.4.8　Bool类型和字符串类型　　48\n0.4.9　数组　　48\n0.4.10　小结　　48\n0.5　关于预设　Tips　　48\n0.5.1　概要　　48\n0.5.2　改良“小方块”游戏对象　　48\n0.5.3　预设与对象实例　　50\n0.5.4　预设和实例的变更　　51\n0.5.5　小结　　53\n第1章　点击动作游戏——怪物　　55\n1.1　玩法介绍　How to Play　　56\n1.2　简单的操作和爽快感　Concept　　58\n1.2.1　脚本一览　　58\n1.2.2　本章小节　　60\n1.3　无限滚动的背景　Tips　　60\n1.3.1　关联文件　　60\n1.3.2　概要　　60\n1.3.3　背景组件的显示位置　　61\n1.3.4　小结　　63\n1.4　无限滚动的背景的改良　Tips　　63\n1.4.1　关联文件　　63\n1.4.2　概要　　64\n1.4.3　稍作尝试　　64\n1.4.4　背景组件显示位置的改良　　65\n1.4.5　小结　　67\n1.5　怪物出现模式的管理　Tips　　67\n1.5.1　关联文件　　67\n1.5.2　概要　　67\n1.5.3　怪物出现的时间点　　68\n1.5.4　怪物出现模式的变化　　70\n1.5.5　小结　　74\n1.6　武士和怪物的碰撞检测　Tips　　74\n1.6.1　关联文件　　74\n1.6.2　概要　　74\n1.6.3　分别对各个怪物进行碰撞检测的问题　　75\n1.6.4　把怪物编成小组　　76\n1.6.5　小结　　78\n1.7　得分高低的判定　Tips　　78\n1.7.1　概要　　78\n1.7.2　武士的攻击判定　　78\n1.7.3　判断在多近的距离斩杀　　79\n1.7.4　小结　　82\n1.8　使被砍中的怪物向四处飞散　Tips　　82\n1.8.1　概要　　82\n1.8.2　想象一下“圆锥体”　　82\n1.8.3　具体的计算方法　　84\n1.8.4　小结　　86\n第2章　拼图游戏——迷你拼图　 87\n2.1　玩法介绍　How to Play　　88\n排列拼图碎片，拼出最后的图案！　　88\n2.2　流畅的拖曳操作　Concept　　90\n2.2.1　脚本一览　　90\n2.2.2　本章小节　　90\n2.3　点住碎片的任意位置拖动　Tips　　92\n2.3.1　关联文件　　92\n2.3.2　概要　　92\n2.3.3　透视变换和逆透视变换　　92\n2.3.4　被点击处即为光标的位置　　92\n2.3.5　测试拖曳碎片的中心　　95\n2.3.6　小结　　96\n2.4　打乱拼图碎片　Tips　　96\n2.4.1　关联文件　　96\n2.4.2　概要　　96\n2.4.3　设置拼图碎片的坐标为随机数　　96\n2.4.4　改进策略　　97\n2.4.5　小结　　102\n2.5　游戏对象和组件的关系　Tips　　102\n2.5.1　关联文件　　102\n2.5.2　概要　　102\n2.5.3　虚拟形象（游戏对象）和定制（组件）　　103\n2.5.4　“this”是什么　　105\n2.5.5　GetComponent<>()的缩写　　106\n2.5.6　删除GameObject　　108\n2.5.7　迷你拼图的应用实例　　108\n2.5.8　小结　　110\n第3章　吃豆游戏——地牢吞噬者　　111\n3.1　玩法介绍　How to Play　　112\n3.2　适时进退和逆转的机会　Concept　　114\n3.2.1　脚本一览　　114\n3.2.2　本章小节　　116\n3.3　平滑的网格移动　Tips　　116\n3.3.1　关联文件　　116\n3.3.2　概要　　116\n3.3.3　能够改变方向的时机　　117\n3.3.4　穿过网格的时机　　117\n3.3.5　小结　　119\n3.4　地图数据　Tips　　120\n3.4.1　关联文件　　120\n3.4.2　概要　　120\n3.4.3　文本文件的格式　　120\n3.4.4　扩展编辑器的功能　　125\n3.4.5　小结　　127\n3.5　动画的小技巧　Tips　　127\n3.5.1　关联文件　　127\n3.5.2　概要　　127\n3.5.3　身体各部位的动画　　128\n3.5.4　根据事件播放音效　　129\n3.5.5　小结　　131\n3.6　幽灵的AI　Tips　　131\n3.6.1　关联文件　　131\n3.6.2　概要　　131\n3.6.3　跟踪的算法　　131\n3.6.4　埋伏等待型、包围攻击型和随机型　　135\n3.6.5　观察幽灵的行动　　137\n3.6.6　小结　　138\n第4章　3D声音探索游戏——In the Dark Water　　139\n4.1　玩法介绍　How to Play　　140\n4.2　只依靠声音　Concept　　142\n4.2.1　脚本一览　　142\n4.2.2　本章小节　　144\n4.3　仅依靠声音定位　Tips　　144\n4.3.1　概要　　144\n4.3.2　3D声音的特性　　144\n4.3.3　用于实验的项目　　146\n4.3.4　小结　　147\n4.4　3D声音的控制　Tips　　147\n4.4.1　关联文件　　147\n4.4.2　概要　　147\n4.4.3　3D声音的设置　　147\n4.4.4　按一定间隔发出声音　　148\n4.4.5　声音的淡出　　149\n4.4.6　小结　　150\n4.5　潜水艇的操纵　Tips　　151\n4.5.1　关联文件　　151\n4.5.2　概要　　151\n4.5.3　操作方法　　151\n4.5.4　转弯速度的衰减　　153\n4.5.5　小结　　157\n4.6　声纳的制作方法　Tips　　157\n4.6.1　概要　　157\n4.6.2　Prespective和Ortho　　158\n4.6.3　“Dark Water”的声纳摄像机　　159\n4.6.4　摄像机和对象的层　　160\n4.6.5　稍作尝试　　163\n4.6.6　摄像机的视口　　164\n4.6.7　小结　　165\n第5章　节奏游戏——摇滚女孩　　167\n5.1　玩法介绍　How to Play　　168\n5.2　Band-girl的世界　Concept　　169\n5.2.1　脚本一览　　170\n5.2.2　本章小节　　170\n5.3　显示点击时刻的节拍标记　Tips　　172\n5.3.1　关联文件　　172\n5.3.2　概要　　172\n5.3.3　定位单元　　172\n5.3.4　标记的显示　　175\n5.3.5　小结　　178\n5.4　判断是否配合了音乐点击　Tips　　178\n5.4.1　关联文件　　178\n5.4.2　概要　　178\n5.4.3　得分高低的判断　　178\n5.4.4　避免重复判断　　180\n5.4.5　小结　　185\n5.5　演出数据的管理和执行　Tips　　185\n5.5.1　关联文件　　185\n5.5.2　概要　　185\n5.5.3　事件数据的检索　　185\n5.5.4　定位单元和执行单元　　187\n5.5.5　小结　　191\n5.6　其他调整功能　Tips　　191\n5.6.1　关联文件　　191\n5.6.2　概要　　191\n5.6.3　什么是“turn around”　　192\n5.6.4　显示时刻的偏移值　　192\n5.6.5　定位条　　194\n5.6.6　显示标记的行号　　196\n5.6.7　小结　　196\n第6章　全方位滚动射击游戏——噬星者　　197\n6.1　玩法介绍　How to Play　　198\n6.2　功能强大的激光制导　Concept　　199\n6.2.1　脚本一览　　200\n6.2.2　本章小节　　200\n6.3　索敌激光的碰撞检测　Tips　　202\n6.3.1　关联文件　　202\n6.3.2　概要　　202\n6.3.3　索敌激光的碰撞检测　　202\n6.3.4　碰撞网格的生成方法　　204\n6.3.5　确认碰撞网格　　209\n6.3.6　小结　　209\n6.4　不会重复的锁定　Tips　　210\n6.4.1　关联文件　　210\n6.4.2　概要　　210\n6.4.3　锁定的管理　　210\n6.4.4　小结　　213\n6.5　制导激光　Tips　　213\n6.5.1　关联文件　　213\n6.5.2　概要　　213\n6.5.3　根据TrailRenderer生成网格　　213\n6.5.4　制导激光的移动　　214\n6.5.5　稍作尝试　　218\n6.5.6　小结　　218\n6.6　消息窗口　Tips　　219\n6.6.1　关联文件　　219\n6.6.2　概要　　219\n6.6.3　消息队列和显示缓冲区　　219\n6.6.4　小结　　224\n第7章　消除动作解谜游戏——吃月亮　　225\n7.1　玩法介绍　How to Play　　226\n7.2　爽快的连锁和有趣的方块移动　Concept　　228\n7.2.1　脚本一览　　228\n7.2.2　本章小节　　230\n7.3　同色方块相邻与否的判断　Tips　　230\n7.3.1　关联文件　　230\n7.3.2　概要　　230\n7.3.3　连结与连锁　　230\n7.3.4　不停地检测相邻方块　　231\n7.3.5　递归调用　　233\n7.3.6　用于测试连结检测的工程　　236\n7.3.7　防止无限循环检测　　237\n7.3.8　小结　　238\n7.4　方块的初始设置　Tips　　239\n7.4.1　关联文件　　239\n7.4.2　概要　　239\n7.4.3　颜色的选择方法　　239\n7.4.4　随机选取方块的摆放位置　　242\n7.4.5　小结　　244\n7.5　动画的父子构造关系　Tips　　244\n7.5.1　关联文件　　244\n7.5.2　概要　　244\n7.5.3　方块的运动　　244\n7.5.4　动画的父子构造——用于测试的工程　　247\n7.5.5　“吃月亮”中面板的位置和角度的计算　　252\n7.5.6　小结　　254\n7.6　方块的平滑移动　Tips　　254\n7.6.1　关联文件　　254\n7.6.2　概要　　254\n7.6.3　数组的索引和画面上的位置　　255\n7.6.4　桶列方法　　257\n7.6.5　小结　　260\n第8章　跳跃动作游戏——猫跳纸窗　　261\n8.1　玩法介绍　How to Play　　262\n8.2　刺激的跳跃　Concept　　264\n8.2.1　脚本一览　　264\n8.2.2　本章小节　　266\n8.3　角色的状态管理　Tips　　266\n8.3.1　关联文件　　266\n8.3.2　概要　　266\n8.3.3　角色的动作　　266\n8.3.4　状态的迁移　　267\n8.3.5　状态管理的流程　　268\n8.3.6　小结　　272\n8.4　可以控制高度的跳跃　Tips　　273\n8.4.1　关联文件　　273\n8.4.2　概要　　273\n8.4.3　跳跃的物理规律　　273\n8.4.4　自由控制跳跃高度的操作　　274\n8.4.5　小结　　277\n8.5　窗户纸的碰撞检测　Tips　　277\n8.5.1　关联文件　　277\n8.5.2　概要　　277\n8.5.3　“碰撞”的内部实现机制　　277\n8.5.4　窗户对象　　279\n8.5.5　矛盾的碰撞结果　　279\n8.5.6　平滑地穿过格子眼　　289\n8.5.7　小结　　292\n第9章　角色扮演游戏——村子里的传说　　293\n9.1　玩法介绍　How to Play　　294\n9.2　移动简单，人人都是主人公　Concept　　296\n9.2.1　脚本一览　　296\n9.2.2　本章小节　　298\n9.3　事件和Actor　Tips　　298\n9.3.1　关联文件　　298\n9.3.2　概要　　298\n9.3.3　事件　　298\n9.3.4　事件的数据结构　　302\n9.3.5　Actor　　304\n9.3.6　事件的执行　　307\n9.3.7　试着执行一个事件　　310\n9.3.8　小结　　312\n9.4　游戏内参数　Tips　　312\n9.4.1　关联文件　　312\n9.4.2　概要　　312\n9.4.3　游戏内参数　　312\n9.4.4　小结　　316\n9.5　事件文件的读取　Tips　　316\n9.5.1　关联文件　　316\n9.5.2　概要　　316\n9.5.3　文件的读取　　316\n9.5.4　小结　　320\n9.6　特殊的事件　Tips　　321\n9.6.1　关联文件　　321\n9.6.2　概要　　321\n9.6.3　选项指令　　321\n9.6.4　宝箱事件　　323\n9.6.5　进入屋子的事件　　325\n9.6.6　小结　　326\n第10章　驾驶游戏——迷踪赛道　　327\n10.1　玩法介绍　How to Play　　328\n10.2　自行创建，即作即用　Concept　　330\n10.2.1　脚本一览　　330\n10.2.2　本章小节　　332\n10.2.3　关于Car Tutorial脚本　　332\n10.3　透视变换和逆透视变换　Tips　　332\n10.3.1　关联文件　　332\n10.3.2　概要　　332\n10.3.3　透视变换　　333\n10.3.4　逆透视变换　　335\n10.3.5　小结　　337\n10.4　多边形网格的生成方法　Tips　　338\n10.4.1　关联文件　　338\n10.4.2　概要　　338\n10.4.3　生成道路的中心线　　339\n10.4.4　多边形的生成方法　　341\n10.4.5　生成道路多边形　　342\n10.4.6　急转弯时的多边形重叠　　347\n10.4.7　多边形生成的测试用工程　　348\n10.4.8　小结　　348\n10.5　模型的变形　Tips　　348\n10.5.1　关联文件　　348\n10.5.2　概要　　348\n10.5.3　变形后顶点的位置坐标　　349\n10.5.4　小结　　353\n10.6　点缀实例　Tips　　353\n10.6.1　关联文件　　353\n10.6.2　概要　　353\n10.6.3　生成基准线　　354\n10.6.4　把树木设置到基准线上　　358\n10.6.5　小结　　362\n后记　　363","pages":"384","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s27995300.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s27995300.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s27995300.jpg"},"alt":"https:\/\/book.douban.com\/subject\/26313534\/","id":"26313534","publisher":"人民邮电出版社","isbn10":"711538424X","isbn13":"9787115384249","title":"Unity游戏设计与实现","url":"https:\/\/api.douban.com\/v2\/book\/26313534","alt_title":"","author_intro":"作者简介：\n\n加藤政树\n就职于日本著名的游戏制造商南梦宫。除产品开发外，还负责公司内部中间件的开发和技术研究、高端项目支持、新游戏的研发等工作。近年来也开始致力于NPR（Non Photorealistic Rendering）的研究。代表作品有Fitness Party、Muscle March。\n译者简介：\n罗水东\n资深游戏开发工程师。10年软件和游戏开发经验，期间5年时间在日本工作。热爱技术，乐于分享心得。目前主要关注领域为Unity3D游戏开发技术、游戏设计模式。","summary":"本书出自日本知名游戏公司万代南梦宫的资深开发人员之手，面向初级游戏开发人员，通过10个不同类型的游戏实例，展示了真正的游戏设计和实现过程。本书的重点并不在于讲解Unity的各种功能细节，而在于核心玩法的设计和实现思路。每个实例都从一个idea 开始，不断丰富，自然而然地推出各种概念，引导读者思考必要的数据结构和编程方法。掌握了这些思路，即便换成另外一种引擎，也可以轻松地开发出同类型的游戏。\n本书适合具有一定Unity 和C# 基础的游戏开发者阅读。","series":{"id":"660","title":"图灵程序设计丛书"},"price":"79.00元"},{"rating":{"max":10,"numRaters":21,"average":"7.9","min":0},"subtitle":"多线程与架构设计","author":["汪文君"],"pubdate":"2018-6","tags":[{"count":27,"name":"多线程","title":"多线程"},{"count":25,"name":"并发","title":"并发"},{"count":19,"name":"java","title":"java"},{"count":11,"name":"Java","title":"Java"},{"count":10,"name":"编程","title":"编程"},{"count":6,"name":"计算机","title":"计算机"},{"count":5,"name":"计算科学","title":"计算科学"},{"count":4,"name":"JVM","title":"JVM"}],"origin_title":"","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s29802414.jpg","binding":"平装","translator":[],"catalog":"推荐序一\n推荐序二\n推荐序三\n推荐序四\n前言\n第一部分 多线程基础\n第1章 快速认识线程 3\n1.1 线程的介绍 3\n1.2 快速创建并启动一个线程 3\n1.2.1 尝试并行运行 4\n1.2.2 并发运行交替输出 5\n1.2.3 使用Jconsole观察线程 6\n1.3 线程的生命周期详解 7\n1.3.1 线程的NEW状态 8\n1.3.2 线程的RUNNABLE状态 8\n1.3.3 线程的 RUNNING状态 8\n1.3.4 线程的BLOCKED状态 8\n1.3.5 线程的TERMINATED状态 9\n1.4 线程的start方法剖析：模板设计模式在Thread中的应用 9\n1.4.1 Thread start方法源码分析以及注意事项 9\n1.4.2 模板设计模式在Thread中的应用 11\n1.4.3 Thread模拟营业大厅叫号机程序 13\n1.5 Runnable接口的引入以及策略模式在Thread中的使用 16\n1.5.1 Runnable的职责 16\n1.5.2 策略模式在Thread中的应用 16\n1.5.3 模拟营业大厅叫号机程序 18\n1.6 本章总结 19\n第2章 深入理解Thread构造函数 20\n2.1 线程的命名 20\n2.1.1 线程的默认命名 21\n2.1.2 命名线程 21\n2.1.3 修改线程的名字 22\n2.2 线程的父子关系 22\n2.3 Thread与ThreadGroup 23\n2.4 Thread与Runnable 24\n2.5 Thread与JVM虚拟机栈 25\n2.5.1 Thread与Stacksize 25\n2.5.2 JVM内存结构 27\n2.5.3 Thread与虚拟机栈 30\n2.6 守护线程 33\n2.6.1 什么是守护线程 33\n2.6.2 守护线程的作用 34\n2.7 本章总结 34\n第3章 Thread API的详细介绍 35\n3.1 线程sleep 35\n3.1.1 sleep方法介绍 35\n3.1.2 使用TimeUnit替代Thread.sleep 36\n3.2 线程yield 37\n3.2.1 yield方法介绍 37\n3.2.2 yield和sleep 37\n3.3 设置线程的优先级 38\n3.3.1 线程优先级介绍 38\n3.3.2 线程优先级源码分析 39\n3.3.3 关于优先级的一些总结 40\n3.4 获取线程ID 40\n3.5 获取当前线程 41\n3.6 设置线程上下文类加载器 41\n3.7 线程interrupt 42\n3.7.1 interrupt 42\n3.7.2 isInterrupted 43\n3.7.3 interrupted 45\n3.7.4 interrupt注意事项 46\n3.8 线程join 47\n3.8.1 线程join方法详解 48\n3.8.2 join方法结合实战 50\n3.9 如何关闭一个线程 53\n3.9.1 正常关闭 54\n3.9.2 异常退出 56\n3.9.3 进程假死 56\n3.10 本章总结 58\n第4章 线程安全与数据同步 59\n4.1 数据同步 59\n4.1.1 数据不一致问题的引入 59\n4.1.2 数据不一致问题原因分析 61\n4.2 初识 synchronized关键字 62\n4.2.1 什么是synchronized 63\n4.2.2 synchronized关键字的用法 63\n4.3 深入synchronized关键字 65\n4.3.1 线程堆栈分析 65\n4.3.2 JVM指令分析 67\n4.3.3 使用synchronized需要注意的问题 70\n4.4 This Monitor和Class Monitor的详细介绍 72\n4.4.1 this monitor 72\n4.4.2 class monitor 74\n4.5 程序死锁的原因以及如何诊断 77\n4.5.1 程序死锁 77\n4.5.2 程序死锁举例 77\n4.5.3 死锁诊断 80\n4.6 本章总结 81\n第5章 线程间通信 82\n5.1 同步阻塞与异步非阻塞 82\n5.1.1 同步阻塞消息处理 82\n5.1.2 异步非阻塞消息处理 83\n5.2 单线程间通信 84\n5.2.1 初识wait和notify 84\n5.2.2 wait和notify方法详解 87\n5.2.3 关于wait和notify的注意事项 89\n5.2.4 wait和sleep 90\n5.3 多线程间通信 90\n5.3.1 生产者消费者 90\n5.3.2 线程休息室wait set 93\n5.4 自定义显式锁BooleanLock 94\n5.4.1 synchronized关键字的缺陷 94\n5.4.2 显式锁BooleanLock 95\n5.5 本章总结 104\n第6章 ThreadGroup详细讲解 105\n6.1 ThreadGroup与Thread 105\n6.2 创建ThreadGroup 105\n6.3 复制Thread数组和ThreadGroup数组 106\n6.3.1 复制Thread数组 106\n6.3.2 复制ThreadGroup数组 109\n6.4 ThreadGroup操作 109\n6.4.1 ThreadGroup的基本操作 110\n6.4.2 ThreadGroup的interrupt 113\n6.4.3 ThreadGroup的destroy 114\n6.4.4 守护ThreadGroup 115\n6.5 本章总结 116\n第7章 Hook线程以及捕获线程执行异常 117\n7.1 获取线程运行时异常 117\n7.1.1 UncaughtExceptionHandler的介绍 117\n7.1.2 UncaughtExceptionHandler实例 118\n7.1.3 UncaughtExceptionHandler源码分析 119\n7.2 注入钩子线程 121\n7.2.1 Hook线程介绍 121\n7.2.2 Hook线程实战 122\n7.2.3 Hook线程应用场景以及注意事项 124\n7.3 本章总结 124\n第8章 线程池原理以及自定义线程池 125\n8.1 线程池原理 125\n8.2 线程池实现 126\n8.2.1 线程池接口定义 127\n8.2.2 线程池详细实现 131\n8.3 线程池的应用 139\n8.4 本章总结 142\n第二部分 Java ClassLoader\n第9章 类的加载过程 144\n9.1 类的加载过程简介 144\n9.2 类的主动使用和被动使用 145\n9.3 类的加载过程详解 148\n9.3.1 类的加载阶段 148\n9.3.2 类的连接阶段 149\n9.3.3 类的初始化阶段 154\n9.4 本章总结 156\n第10章 JVM类加载器 158\n10.1 JVM内置三大类加载器 158\n10.1.1 根类加载器介绍 159\n10.1.2 扩展类加载器介绍 159\n10.1.3 系统类加载器介绍 160\n10.2 自定义类加载器 161\n10.2.1 自定义类加载器，问候世界 161\n10.2.2 双亲委托机制详细介绍 165\n10.2.3 破坏双亲委托机制 167\n10.2.4 类加载器命名空间、运行时包、类的卸载等 170\n10.3 本章总结 175\n第11章 线程上下文类加载器 177\n11.1 为什么需要线程上下文类加载器 177\n11.2 数据库驱动的初始化源码分析 178\n11.3 本章总结 180\n第三部分 深入理解volatile关键字\n第12章 volatile关键字的介绍 182\n12.1 初识volatile关键字 182\n12.2 机器硬件CPU 184\n12.2.1 CPU Cache模型 184\n12.2.2 CPU缓存一致性问题 186\n12.3 Java内存模型 187\n12.4 本章总结 188\n第13章 深入volatile关键字 189\n13.1 并发编程的三个重要特性 189\n13.1.1 原子性 189\n13.1.2 可见性 190\n13.1.3 有序性 190\n13.2 JMM如何保证三大特性 191\n13.2.1 JMM与原子性 192\n13.2.2 JMM与可见性 193\n13.2.3 JMM与有序性 194\n13.3 volatile关键字深入解析 195\n13.3.1 volatile关键字的语义 195\n13.3.2 volatile的原理和实现机制 197\n13.3.3 volatile的使用场景 198\n13.3.4 volatile和synchronized 199\n13.4 本章总结 200\n第14章 7种单例设计模式的设计 201\n14.1 饿汉式 201\n14.2 懒汉式 202\n14.3 懒汉式+同步方法 203\n14.4 Double-Check 204\n14.5 Volatile+Double-Check 206\n14.6 Holder方式 206\n14.7 枚举方式 207\n14.8 本章总结 208\n第四部分 多线程设计架构模式\n第15章 监控任务的生命周期 212\n15.1 场景描述 212\n15.2 当观察者模式遇到Thread 212\n15.2.1 接口定义 212\n15.2.2 ObservableThread实现 215\n15.3 本章总结 217\n15.3.1 测试运行 217\n15.3.2 关键点总结 219\n第16章 Single Thread Execution设计模式 220\n16.1 机场过安检 220\n16.1.1 非线程安全 221\n16.1.2 问题分析 223\n16.1.3 线程安全 225\n16.2 吃面问题 225\n16.2.1 吃面引起的死锁 226\n16.2.2 解决吃面引起的死锁问题 228\n16.2.3 哲学家吃面 229\n16.3 本章总结 230\n第17章 读写锁分离设计模式 231\n17.1 场景描述 231\n17.2 读写分离程序设计 232\n17.2.1 接口定义 232\n17.2.2 程序实现 234\n17.3 读写锁的使用 239\n17.4 本章总结 242\n第18章 不可变对象设计模式 244\n18.1 线程安全性 244\n18.2 不可变对象的设计 244\n18.2.1 非线程安全的累加器 245\n18.2.2 方法同步增加线程安全性 247\n18.2.3 不可变的累加器对象设计 248\n18.3 本章总结 249\n第19章 Future设计模式 251\n19.1 先给你一张凭据 251\n19.2 Future设计模式实现 251\n19.2.1 接口定义 252\n19.2.2 程序实现 253\n19.3 Future的使用以及技巧总结 256\n19.4 增强FutureService使其支持回调 257\n19.5 本章总结 258\n第20章 Guarded Suspension设计模式 259\n20.1 什么是Guarded Suspension设计模式 259\n20.2 Guarded Suspension的示例 259\n20.3 本章总结 261\n第21章 线程上下文设计模式 262\n21.1 什么是上下文 262\n21.2 线程上下文设计 263\n21.3 ThreadLocal详解 264\n21.3.1 ThreadLocal的使用场景及注意事项 265\n21.3.2 ThreadLocal的方法详解及源码分析 265\n21.3.3 ThreadLocal的内存泄漏问题分析 270\n21.4 使用ThreadLocal设计线程上下文 274\n21.5 本章总结 276\n第22章 Balking设计模式 277\n22.1 什么是Balking设计 277\n22.2 Balking模式之文档编辑 278\n22.2.1 Document 278\n22.2.2 AutoSaveThread 280\n22.2.3 DocumentEditThread 281\n22.3 本章总结 283\n第23章 Latch设计模式 284\n23.1 什么是Latch 284\n23.2 CountDownLatch程序实现 285\n23.2.1 无限等待的Latch 285\n23.2.2 有超时设置的Latch 289\n23.3 本章总结 291\n第24章 Thread-Per-Message设计模式 293\n24.1 什么是Thread-Per-Message模式 293\n24.2 每个任务一个线程 293\n24.3 多用户的网络聊天 296\n24.3.1 服务端程序 296\n24.3.2 响应客户端连接的Handler 297\n24.3.3 聊天程序测试 299\n24.4 本章总结 300\n第25章 Two Phase Termination设计模式 301\n25.1 什么是Two Phase Termination模式 301\n25.2 Two Phase Termination的示例 302\n25.2.1 线程停止的Two Phase Termination 302\n25.2.2 进程关闭的Two Phase Termination 303\n25.3 知识扩展 304\n25.3.1 Strong Reference及LRUCache 304\n25.3.2 Soft Reference及SoftLRUCache 308\n25.3.3 Weak Reference 311\n25.3.4 Phantom Reference 312\n25.4 本章总结 314\n第26章 Worker-Thread设计模式 315\n26.1 什么是Worker-Thread模式 315\n26.2 Worker-Thread模式实现 315","pages":"379","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s29802414.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s29802414.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s29802414.jpg"},"alt":"https:\/\/book.douban.com\/subject\/30255689\/","id":"30255689","publisher":"机械工业出版社","isbn10":"7111599934","isbn13":"9787111599937","title":"Java高并发编程详解","url":"https:\/\/api.douban.com\/v2\/book\/30255689","alt_title":"","author_intro":"汪文君，汇丰软件（广东）研发中心数据服务中心技术经理、技术专家，目前专注于实时数据data pipeline平台的构建与架构，在加入汇丰软件以前，曾有7年多的移动通信工作经验，以及移动互联网、云计算和B2C电子商务平台的开发架构经验，热衷于技术分享、技术细节锤炼。目前已录制10余套技术视频，在互联网上广泛传播。","summary":"本书共分为四个部分：部分详细地介绍了Java多线程的基本用法和各个API的使用，并且着重介绍了线程与Java虚拟机内存之间的关系。第二部分由线程上下文类加载器方法引入，介绍为什么在线程中要有上下文类加载器的方法函数，从而掌握类在JVM的加载和初始化的整个过程。第三部分主要围绕着volatile关键字展开，在该部分中我们将会了解到现代CPU的架构以及Java的内存模型（JMM）。后一部分，主要站在架构设计的高度看待如何巧妙地开发出真正具备并发能力的系统。","series":{"id":"34391","title":"Java核心技术系列"},"price":"89.00元"},{"rating":{"max":10,"numRaters":90,"average":"8.7","min":0},"subtitle":"","author":["黄文海"],"pubdate":"2017-4","tags":[{"count":141,"name":"Java","title":"Java"},{"count":106,"name":"多线程","title":"多线程"},{"count":100,"name":"Java多线程","title":"Java多线程"},{"count":52,"name":"并发","title":"并发"},{"count":35,"name":"计算机","title":"计算机"},{"count":21,"name":"java","title":"java"},{"count":20,"name":"计算机科学","title":"计算机科学"},{"count":18,"name":"挺不错的一本书","title":"挺不错的一本书"}],"origin_title":"","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s29440409.jpg","binding":"平装","translator":[],"catalog":"第一部分  多线程编程基础\n第1章  走近Java世界中的线程\t2\n1.1  进程、线程与任务\t2\n1.2  多线程编程简介\t4\n1.2.1  什么是多线程编程\t4\n1.2.2  为什么使用多线程\t4\n1.3  Java线程API简介\t5\n1.3.1  线程的创建、启动与运行\t5\n1.3.2  Runnable接口\t9\n1.3.3  线程属性\t12\n1.3.4  Thread类的常用方法\t14\n1.3.5  Thread类的一些废弃方法\t16\n1.4  无处不在的线程\t17\n1.5  线程的层次关系\t19\n1.6  线程的生命周期状态\t21\n1.7  线程的监视\t22\n1.8  多线程编程简单运用实例\t26\n*1.9  多线程编程的优势和风险\t27\n1.10  本章小结\t29\n第2章  多线程编程的目标与挑战\t31\n2.1  串行、并发与并行\t31\n2.2  竞态\t33\n2.2.1  二维表分析法：解释竞态的结果\t37\n2.2.2  竞态的模式与竞态产生的条件\t39\n2.3  线程安全性\t42\n2.4  原子性\t43\n2.5  可见性\t49\n2.6  有序性\t56\n2.6.1  重排序的概念\t56\n2.6.2  指令重排序\t57\n2.6.3  存储子系统重排序\t63\n2.6.4  貌似串行语义\t66\n2.6.5  保证内存访问的顺序性\t68\n2.7  上下文切换\t69\n2.7.1  上下文切换及其产生原因\t69\n2.7.2  上下文切换的分类及具体诱因\t70\n2.7.3  上下文切换的开销和测量\t71\n2.8  线程的活性故障\t73\n2.9  资源争用与调度\t74\n2.10  本章小结\t77\n第3章  Java线程同步机制\t80\n3.1  线程同步机制简介\t80\n3.2  锁概述\t81\n3.2.1  锁的作用\t82\n3.2.2  与锁相关的几个概念\t84\n3.2.3  锁的开销及其可能导致的问题\t86\n3.3  内部锁：synchronized关键字\t86\n3.4  显式锁：Lock接口\t89\n3.4.1  显式锁的调度\t91\n3.4.2  显式锁与内部锁的比较\t92\n3.4.3  内部锁还是显式锁：锁的选用\t95\n*3.4.4  改进型锁：读写锁\t95\n3.5  锁的适用场景\t99\n3.6  线程同步机制的底层助手：内存屏障\t99\n*3.7  锁与重排序\t102\n3.8  轻量级同步机制：volatile关键字\t105\n3.8.1  volatile的作用\t105\n3.8.2  volatile变量的开销\t111\n3.8.3  volatile的典型应用场景与实战案例\t111\n3.9  实践：正确实现看似简单的单例模式\t120\n3.10  CAS与原子变量\t126\n3.10.1  CAS\t127\n3.10.2  原子操作工具：原子变量类\t129\n3.11  对象的发布与逸出\t135\n3.11.1  对象的初始化安全：重访final与static\t137\n3.11.2  安全发布与逸出\t142\n3.12  本章小结\t143\n第4章  牛刀小试：玩转线程\t148\n4.1  挖掘可并发点\t148\n4.2  新战场上的老武器：分而治之\t148\n4.3  基于数据的分割实现并发化\t149\n4.4  基于任务的分割实现并发化\t158\n4.4.1  按任务的资源消耗属性分割\t159\n4.4.2  实战案例的启发\t169\n4.4.3  按处理步骤分割\t171\n4.5  合理设置线程数\t172\n4.5.1  Amdahl's定律\t172\n4.5.2  线程数设置的原则\t173\n4.6  本章小结\t177\n第5章  线程间协作\t179\n5.1  等待与通知：wait\/notify\t179\n5.1.1  wait\/notify的作用与用法\t180\n5.1.2  wait\/notify的开销及问题\t188\n5.1.3  Object.notify()\/notifyAll()的选用\t191\n*5.1.4  wait\/notify与Thread.join()\t191\n5.2  Java条件变量\t192\n5.3  倒计时协调器：CountDownLatch\t198\n5.4  栅栏（CyclicBarrier）\t203\n5.5  生产者—消费者模式\t210\n5.5.1  阻塞队列\t213\n5.5.2  限购：流量控制与信号量（Semaphore）\t216\n*5.5.3  管道：线程间的直接输出与输入\t218\n5.5.4  一手交钱，一手交货：双缓冲与Exchanger\t221\n5.5.5  一个还是一批：产品的粒度\t223\n5.5.6  再探线程与任务之间的关系\t224\n5.6  对不起，打扰一下：线程中断机制\t225\n5.7  线程停止：看似简单，实则不然\t228\n5.7.1  生产者—消费者模式中的线程停止\t233\n5.7.2  实践：Web应用中的线程停止\t233\n5.8  本章小结\t236\n第6章  保障线程安全的设计技术\t240\n*6.1  Java运行时存储空间\t240\n6.2  大公无私：无状态对象\t243\n6.3  以“不变”应万变：不可变对象\t248\n6.4  我有我地盘：线程特有对象\t254\n6.4.1  线程特有对象可能导致的问题及其规避\t258\n6.4.2  线程特有对象的典型应用场景\t264\n6.5  装饰器模式\t265\n6.6  并发集合\t267\n6.7  本章小结\t270\n第7章  线程的活性故障\t273\n7.1  鹬蚌相争：死锁\t273\n7.1.1  死锁的检测\t274\n7.1.2  死锁产生的条件与规避\t283\n7.1.3  死锁的恢复\t296\n7.2  沉睡不醒的睡美人：锁死\t301\n7.2.1  信号丢失锁死\t301\n7.2.2  嵌套监视器锁死\t301\n7.3  巧妇难为无米之炊：线程饥饿\t307\n7.4  屡战屡败，屡败屡战：活锁\t307\n7.5  本章小结\t308\n第8章  线程管理\t310\n8.1  线程组\t310\n8.2  可靠性：线程的未捕获异常与监控\t311\n8.3  有组织有纪律：线程工厂\t316\n8.4  线程的暂挂与恢复\t318\n8.5  线程的高效利用：线程池\t320\n8.5.1  任务的处理结果、异常处理与取消\t326\n8.5.2  线程池监控\t329\n8.5.3  线程池死锁\t330\n8.5.4  工作者线程的异常终止\t330\n8.6  本章小结\t331\n第9章  Java异步编程\t333\n9.1  同步计算与异步计算\t333\n9.2  Java Executor框架\t336\n9.2.1  实用工具类Executors\t337\n9.2.2  异步任务的批量执行：CompletionService\t339\n9.3  异步计算助手：FutureTask\t344\n9.3.1  实践：实现XML文档的异步解析\t345\n9.3.2  可重复执行的异步任务\t349\n9.4  计划任务\t352\n9.5  本章小结\t358\n第10章  Java多线程程序的调试与测试\t360\n10.1  多线程程序的调试技巧\t360\n10.1.1  使用监视点\t360\n10.1.2  设置暂挂策略\t361\n10.2  多线程程序的测试\t363\n10.2.1  可测试性\t364\n10.2.2  静态检查工具：FindBugs\t369\n10.2.3  多线程程序的代码复审\t370\n10.2.4  多线程程序的单元测试：JCStress\t372\n10.3  本章小结\t375\n第二部分  多线程编程进阶\n第11章  多线程编程的硬件基础与Java内存模型\t378\n11.1  填补处理器与内存之间的鸿沟：高速缓存\t378\n11.2  数据世界的交通规则：缓存一致性协议\t382\n11.3  硬件缓冲区：写缓冲器与无效化队列\t386\n11.3.1  存储转发\t388\n11.3.2  再探内存重排序\t388\n11.3.3  再探可见性\t391\n11.4  基本内存屏障\t392\n11.5  Java同步机制与内存屏障\t395\n11.5.1  volatile关键字的实现\t395\n11.5.2  synchronized关键字的实现\t397\n11.5.3  Java虚拟机对内存屏障使用的优化\t398\n11.5.4  final关键字的实现\t398\n11.6  Java内存模型\t399\n11.6.1  什么是Java内存模型\t400\n11.6.2  happen(s)-before关系\t401\n11.6.3  再探对象的安全发布\t407\n11.6.4  JSR 133\t411\n11.7  共享变量与性能\t411\n11.8  本章小结\t411\n第12章  Java多线程程序的性能调校\t415\n12.1  Java虚拟机对内部锁的优化\t415\n12.1.1  锁消除\t415\n12.1.2  锁粗化\t417\n12.1.3  偏向锁\t419\n12.1.4  适应性锁\t420\n12.2  优化对锁的使用\t421\n12.2.1  锁的开销与锁争用监视\t421\n12.2.2  使用可参数化锁\t424\n12.2.3  减小临界区的长度\t428\n12.2.4  减小锁的粒度\t432\n12.2.5  考虑锁的替代品\t438\n12.3  减少系统内耗：上下文切换\t438\n12.4  多线程编程的“三十六计”：多线程设计模式\t440\n12.5  性能的隐形杀手：伪共享\t441\n12.5.1  Java对象内存布局\t442\n12.5.2  伪共享的侦测与消除\t445\n12.6  本章小结\t454\nWeb参考资源\t457\n参考文献\t463","pages":"480","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s29440409.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s29440409.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s29440409.jpg"},"alt":"https:\/\/book.douban.com\/subject\/27034721\/","id":"27034721","publisher":"电子工业出版社","isbn10":"7121310651","isbn13":"9787121310652","title":"Java多线程编程实战指南（核心篇）","url":"https:\/\/api.douban.com\/v2\/book\/27034721","alt_title":"","author_intro":"","summary":"随着现代处理器的生产工艺从提升处理器主频频率转向多核化，即在一块芯片上集成多个处理器内核（Core），多核处理器（Multicore Processor）离我们越来越近了——如今就连智能手机这样的消费类设备都已配备了4核乃至8核的处理器，更何况商用系统！在此背景下，以往靠单个处理器自身处理能力的提升所带来的软件计算性能提升的那种“免费午餐”已不复存在，这使得多线程编程在充分利用计算资源、提高软件服务质量方面扮演了越来越重要的角色。故而，掌握多线程编程技能对广大开发人员的重要性亦由此可见一斑。《Java多线程编程实战指南（核心篇）》以基本概念、原理与方法为主线，辅以丰富的实战案例和生活化实例，并从Java虚拟机、操作系统和硬件多个层次与角度出发，循序渐进、系统地介绍Java平台下的多线程编程核心技术及相关工具。\n《Java多线程编程实战指南（核心篇）》适合有一定Java语言基础的读者作为入门多线程编程之用，也适合有一定多线程编程经验的读者作为重新梳理知识结构以提升认知层次和参考之用。","series":{"id":"41617","title":"Java多线程编程实战系列"},"price":"89"},{"rating":{"max":10,"numRaters":230,"average":"8.3","min":0},"subtitle":"线程完全手册","author":["[美] Jim Beveridge","Robert Wiener"],"pubdate":"2002-1","tags":[{"count":150,"name":"多线程","title":"多线程"},{"count":104,"name":"Windows","title":"Windows"},{"count":63,"name":"Windows编程","title":"Windows编程"},{"count":59,"name":"编程","title":"编程"},{"count":44,"name":"Win32","title":"Win32"},{"count":41,"name":"计算机","title":"计算机"},{"count":32,"name":"侯捷","title":"侯捷"},{"count":30,"name":"C++","title":"C++"}],"origin_title":"","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1483484.jpg","binding":"平装16开","translator":["侯捷"],"catalog":"","pages":"453","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s1483484.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s1483484.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1483484.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1231702\/","id":"1231702","publisher":"华中科技大学出版社","isbn10":"756092638X","isbn13":"9787560926384","title":"Win32多线程程序设计","url":"https:\/\/api.douban.com\/v2\/book\/1231702","alt_title":"","author_intro":"Jim Beveridge进入操作系统的研究领域已有15年，从多处理器数据库到microkernel操作系统的开发，他都有经验。他于Rochoester Institure of Technology获得计算机科学学士学位。他目前受聘为Turning Point Software公司顾问。","summary":"《Win32多线程程序设计》全书共分三篇。第一篇包括线程的启动和结束、核心对象、激发和未激发状态的意义、同步机制及其用途；第二篇介绍C runtime函数库和MFC对线程的支持、如何在USER和GDI的限制之下施行对线程等内容；第三篇谈论如何组织一个程序，使它有效支持多线程。","price":"59.80元"},{"rating":{"max":10,"numRaters":42,"average":"8.3","min":0},"subtitle":"","author":["黄文海"],"pubdate":"2015-10","tags":[{"count":101,"name":"Java","title":"Java"},{"count":82,"name":"多线程","title":"多线程"},{"count":54,"name":"设计模式","title":"设计模式"},{"count":41,"name":"java多线程","title":"java多线程"},{"count":34,"name":"并发编程","title":"并发编程"},{"count":27,"name":"并发","title":"并发"},{"count":22,"name":"java","title":"java"},{"count":13,"name":"技术","title":"技术"}],"origin_title":"","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s28317421.jpg","binding":"","translator":[],"catalog":"1章  Java多线程编程实战基础\t1\n1.1  无处不在的线程\t1\n1.2  线程的创建与运行\t2\n1.3  线程的状态与上下文切换\t5\n1.4  线程的监视\t7\n1.5  原子性、内存可见性和重排序——重新认识synchronized和volatile\t10\n1.6  线程的优势和风险\t11\n1.7  多线程编程常用术语\t13\n第2章  设计模式简介\t17\n2.1  设计模式及其作用\t17\n2.2  多线程设计模式简介\t20\n2.3  设计模式的描述\t21\n第3章  Immutable Object（不可变对象）模式\t23\n3.1  Immutable Object模式简介\t23\n3.2  Immutable Object模式的架构\t25\n3.3  Immutable Object模式实战案例\t27\n3.4  Immutable Object模式的评价与实现考量\t31\n3.5  Immutable Object模式的可复用实现代码\t32\n3.6  Java标准库实例\t32\n3.7  相关模式\t34\n3.7.1  Thread Specific Storage模式（第10章）\t34\n3.7.2  Serial Thread Confinement模式（第11章）\t34\n3.8  参考资源\t34\n第4章  Guarded Suspension（保护性暂挂）模式\t35\n4.1  Guarded Suspension模式简介\t35\n4.2  Guarded Suspension模式的架构\t35\n4.3  Guarded Suspension模式实战案例解析\t39\n4.4  Guarded Suspension模式的评价与实现考量\t45\n4.4.1  内存可见性和锁泄漏（Lock Leak）\t46\n4.4.2  线程过早被唤醒\t46\n4.4.3  嵌套监视器锁死\t47\n4.5  Guarded Suspension模式的可复用实现代码\t50\n4.6  Java标准库实例\t50\n4.7  相关模式\t51\n4.7.1  Promise模式（第6章）\t51\n4.7.2  Producer-Consumer模式（第7章）\t51\n4.8  参考资源\t51\n第5章  Two-phase Termination（两阶段终止）模式\t52\n5.1  Two-phase Termination模式简介\t52\n5.2  Two-phase Termination模式的架构\t53\n5.3  Two-phase Termination模式实战案例\t56\n5.4  Two-phase Termination模式的评价与实现考量\t63\n5.4.1  线程停止标志\t63\n5.4.2  生产者-消费者问题中的线程停止\t64\n5.4.3  隐藏而非暴露可停止的线程\t65\n5.5  Two-phase Termination模式的可复用实现代码\t65\n5.6  Java标准库实例\t66\n5.7  相关模式\t66\n5.7.1  Producer-Consumer模式（第7章）\t66\n5.7.2  Master-Slave模式（第12章）\t66\n5.8  参考资源\t66\n第6章  Promise（承诺）模式\t67\n6.1  Promise模式简介\t67\n6.2  Promise模式的架构\t68\n6.3  Promise模式实战案例解析\t70\n6.4  Promise模式的评价与实现考量\t74\n6.4.1  异步方法的异常处理\t75\n6.4.2  轮询（Polling）\t75\n6.4.3  异步任务的执行\t75\n6.5  Promise模式的可复用实现代码\t77\n6.6  Java标准库实例\t77\n6.7  相关模式\t78\n6.7.1  Guarded Suspension模式（第4章）\t78\n6.7.2  Active Object模式（第8章）\t78\n6.7.3  Master-Slave模式（第12章）\t78\n6.7.4  Factory Method模式\t78\n6.8  参考资源\t79\n第7章  Producer-Consumer（生产者\/消费者）模式\t80\n7.1  Producer-Consumer模式简介\t80\n7.2  Producer-Consumer模式的架构\t80\n7.3  Producer-Consumer模式实战案例解析\t83\n7.4  Producer-Consumer模式的评价与实现考量\t87\n7.4.1  通道积压\t87\n7.4.2  工作窃取算法\t88\n7.4.3  线程的停止\t92\n7.4.4  高性能高可靠性的Producer-Consumer模式实现\t92\n7.5  Producer-Consumer模式的可复用实现代码\t92\n7.6  Java标准库实例\t93\n7.7  相关模式\t93\n7.7.1  Guarded Suspension模式（第4章）\t93\n7.7.2  Thread Pool模式（第9章）\t93\n7.8  参考资源\t93\n第8章  Active Object（主动对象）模式\t94\n8.1  Active Object模式简介\t94\n8.2  Active Object模式的架构\t95\n8.3  Active Object模式实战案例解析\t98\n8.4  Active Object模式的评价与实现考量\t105\n8.4.1  错误隔离\t107\n8.4.2  缓冲区监控\t108\n8.4.3  缓冲区饱和处理策略\t108\n8.4.4  Scheduler空闲工作者线程清理\t109\n8.5  Active Object模式的可复用实现代码\t109\n8.6  Java标准库实例\t111\n8.7  相关模式\t112\n8.7.1  Promise模式（第6章）\t112\n8.7.2  Producer-Consumer模式（第7章）\t112\n8.8  参考资源\t112\n第9章  Thread Pool（线程池）模式\t113\n9.1  Thread Pool模式简介\t113\n9.2  Thread Pool模式的架构\t114\n9.3  Thread Pool模式实战案例解析\t116\n9.4  Thread Pool模式的评价与实现考量\t117\n9.4.1  工作队列的选择\t118\n9.4.2  线程池大小调校\t119\n9.4.3  线程池监控\t121\n9.4.4  线程泄漏\t122\n9.4.5  可靠性与线程池饱和处理策略\t122\n9.4.6  死锁\t125\n9.4.7  线程池空闲线程清理\t126\n9.5  Thread Pool模式的可复用实现代码\t127\n9.6  Java标准库实例\t127\n9.7  相关模式\t127\n9.7.1  Two-phase Termination模式（第5章）\t127\n9.7.2  Promise模式（第6章）\t127\n9.7.3  Producer-Consumer模式（第7章）\t127\n9.8  参考资源\t128\n第10章  Thread Specific Storage（线程特有存储）模式\t129\n10.1  Thread Specific Storage模式简介\t129\n10.2  Thread Specific Storage模式的架构\t131\n10.3  Thread Specific Storage模式实战案例解析\t133\n10.4  Thread Specific Storage模式的评价与实现考量\t135\n10.4.1  线程池环境下使用Thread Specific Storage模式\t138\n10.4.2  内存泄漏与伪内存泄漏\t139\n10.5  Thread Specific Storage模式的可复用实现代码\t145\n10.6  Java标准库实例\t146\n10.7  相关模式\t146\n10.7.1  Immutable Object模式（第3章）\t146\n10.7.2  Proxy（代理）模式\t146\n10.7.3  Singleton（单例）模式\t146\n10.8  参考资源\t147\n第11章  Serial Thread Confinement（串行线程封闭）模式\t148\n11.1  Serial Thread Confinement模式简介\t148\n11.2  Serial Thread Confinement模式的架构\t148\n11.3  Serial Thread Confinement模式实战案例解析\t151\n11.4  Serial Thread Confinement模式的评价与实现考量\t155\n11.4.1  任务的处理结果\t155\n11.5  Serial Thread Confinement模式的可复用实现代码\t156\n11.6  Java标准库实例\t160\n11.7  相关模式\t160\n11.7.1  Immutable Object模式（第3章）\t160\n11.7.2  Promise模式（第6章）\t160\n11.7.3  Producer-Consumer模式（第7章）\t160\n11.7.4  Thread Specific Storage（线程特有存储）模式 （第10章）\t161\n11.8  参考资源\t161\n第12章  Master-Slave（主仆）模式\t162\n12.1  Master-Slave模式简介\t162\n12.2  Master-Slave模式的架构\t162\n12.3  Master-Slave模式实战案例解析\t164\n12.4  Master-Slave模式的评价与实现考量\t171\n12.4.1  子任务的处理结果的收集\t172\n12.4.2  Slave参与者实例的负载均衡与工作窃取\t173\n12.4.3  可靠性与异常处理\t173\n12.4.4  Slave线程的停止\t174\n12.5  Master-Slave模式的可复用实现代码\t174\n12.6  Java标准库实例\t186\n12.7  相关模式\t186\n12.7.1  Two-phase Termination模式（第5章）\t186\n12.7.2  Promise模式（第6章）\t186\n12.7.3  Strategy（策略）模式\t186\n12.7.4  Template（模板）模式\t186\n12.7.5  Factory Method（工厂方法）模式\t186\n12.8  参考资源\t187\n第13章  Pipeline（流水线）模式\t188\n13.1  Pipeline模式简介\t188\n13.2  Pipeline模式的架构\t189\n13.3  Pipeline模式实战案例解析\t194\n13.4  Pipeline模式的评价与实现考量\t208\n13.4.1  Pipeline的深度\t209\n13.4.2  基于线程池的Pipe\t209\n13.4.3  错误处理\t212\n13.4.4  可配置的Pipeline\t212\n13.5  Pipeline模式的可复用实现代码\t212\n13.6  Java标准库实例\t222\n13.7  相关模式\t222\n13.7.1  Serial Thread Confinement模式（第11章）\t222\n13.7.2  Master-Slave模式（第12章）\t222\n13.7.3  Composite模式\t223\n13.8  参考资源\t223\n第14章  Half-sync\/Half-async（半同步\/半异步）模式\t224\n14.1  Half-sync\/Half-async模式简介\t224\n14.2  Half-sync\/Half-async模式的架构\t224\n14.3  Half-sync\/Half-async模式实战案例解析\t226\n14.4  Half-sync\/Half-async模式的评价与实现考量\t234\n14.4.1  队列积压\t235\n14.4.2  避免同步层处理过慢\t235\n14.5  Half-sync\/Half-async模式的可复用实现代码\t236\n14.6  Java标准库实例\t240\n14.7  相关模式\t240\n14.7.1  Two-phase Termination模式（第5章）\t240\n14.7.2  Producer-Consumer模式（第7章）\t241\n14.7.3  Active Object模式（第8章）\t241\n14.7.4  Thread Pool模式（第9章）\t241\n14.8  参考资源\t241\n第15章  模式语言\t242\n15.1  模式与模式间的联系\t242\n15.2  mmutable Object（不可变对象）模式\t244\n15.3  Guarded Suspension（保护性暂挂）模式\t244\n15.4  Two-phase Termination（两阶段终止）模式\t245\n15.5  Promise（承诺）模式\t246\n15.6  Producer-Consumer（生产者\/消费者）模式\t247\n15.7  Active Object（主动对象）模式\t248\n15.8  Thread Pool（线程池）模式\t249\n15.9  Thread Specific Storage（线程特有存储）模式\t250\n15.10  Serial Thread Confinement（串行线程封闭）模式\t251\n15.11  Master-Slave（主仆）模式\t252\n15.12  Pipeline（流水线）模式\t253\n15.13  Half-sync\/Half-async（半同步\/半异步）模式\t254\n附录  本书常用UML图指南\t255\nA.1  UML简介\t255\nA.2  类图（Class Diagram）\t256\nA.1.1  类的属性、方法和立体型（Stereotype）\t256\nA.1.2  类与类之间的关系\t258\nA.3  序列图（Sequence Diagram）\t261\n参考文献\t263","ebook_url":"https:\/\/read.douban.com\/ebook\/35729084\/","pages":"284","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s28317421.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s28317421.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s28317421.jpg"},"alt":"https:\/\/book.douban.com\/subject\/26642317\/","id":"26642317","publisher":"电子工业出版社","isbn10":"7121270064","isbn13":"9787121270062","title":"Java多线程编程实战指南（设计模式篇）","url":"https:\/\/api.douban.com\/v2\/book\/26642317","alt_title":"","author_intro":"黄文海，2004年开始从事软件开发工作，近几年从事软件项目管理工作。在其工作过程中积累了丰富的技术指导经验和企业内部培训经验。曾在InfoQ中文站和IBM developerWorks上发表过十几篇技术、项目管理文章。\n媒体评论","summary":"随着CPU 多核时代的到来，多线程编程在充分利用计算资源、提高软件服务质量方面扮演了越来越重要的角色。而\t解决多线程编程中频繁出现的普遍问题可以借鉴设计模式所提供的现成解决方案。然而，多线程编程相关的设计模式书籍多采用C++作为描述语言，且书中所举的例子多与应用开发人员的实际工作相去甚远。《Java多线程编程实战指南（设计模式篇）》采用Java（JDK1.6）语言和UML 为描述语言，并结合作者多年工作经历的相关实战案例，介绍了多线程环境下常用设计模式的来龙去脉：各个设计模式是什么样的及其典型的实际应用场景、实际应用时需要注意的事项以及各个模式的可复用代码实现。\n《Java多线程编程实战指南（设计模式篇）》适合有一定Java 多线程编程基础、经验的读者。","ebook_price":"22.00","series":{"id":"41617","title":"Java多线程编程实战系列"},"price":"59.00"},{"rating":{"max":10,"numRaters":67,"average":"7.1","min":0},"subtitle":"","author":["Scott Oaks"],"pubdate":"2006-3-1","tags":[{"count":75,"name":"Java","title":"Java"},{"count":21,"name":"线程","title":"线程"},{"count":21,"name":"多线程","title":"多线程"},{"count":13,"name":"thread","title":"thread"},{"count":10,"name":"concurrency","title":"concurrency"},{"count":9,"name":"编程","title":"编程"},{"count":8,"name":"计算机","title":"计算机"},{"count":8,"name":"并发","title":"并发"}],"origin_title":"Java Threads","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s10030589.jpg","binding":"平装","translator":["O''Reilly Taiwan公司"],"catalog":"前言\n第一章 Thread导论\nJava术语\n关于范例\n为何要用Thread？\n总结\n第二章 Thread的创建与管理\n什么是Thread？\n创建Thread\nThread的生命周期\n两种停止Thfead的方式\nRunnable工nterface\nThread与对象\n总结\n第三章 数据同步\nSynchronized关键字\nVolatile关键字\n更多RaceCOnd“iOn的讨论\n明确的 (explicit)Locking\nLock Scope\n选择Locking机制\nNested Lock\n死锁\nLock公平 (Fairness)\n总结\n第四章 Thread NOtification\n等待与通知\n条件变量\n总结\n第五章 极简同步技巧\n能避免同步吗？\nAtomic变量\nThread局部变量\n总结\n第六章 高级同步议题\n同步术语\nJ2SE 5.0中加入的同步Class\n防止死锁\n死锁检测\nLock饥饿\n总结\n第七章 Thread与Swing\nSwing Threading的限制\n事件派发Thread的处理\n使用invokeLater()与invokeAndWait()\n长时间运行的事件回调\n总结\n第八章 Thread与Collection Class\nCollection Class的概述\n同步与Collection Class\n生产者\/肖费者模式\n使用CollectionClass\n总结\n第九章 Thread调度\nThread调度的概述\n以Thread优先级来调度\n常见Threading的实现\n总结\n第十章 Thread Pool\n为何要用Thread Pool？\nExecutor\n使用Thread Pool\nQueue与大小\n创建Thread\nCallable Task与Future结果\n单一Thread化的访问\n总结\n第十一章 Task的调度\nTask调度的概述\njava.util.Timer Class\njavax.Swing.Timer Class\nSCheduledThreadPoolExecutor Class\n总结\n第十二章 Thread与I／O\n传统的I／O服务器\n新的I／O服务器\n被中断的I／O\n总结\n第十三章 各种Thread议题\nThread Group\nThread与Java安全性\nDaemon Thread\nThread与C1ass的力口载\nThread与异常处理\nThread、Stack、 内存的使用\n总结\n第十四章 Thread性能\n性能的概述\n同步的Collection\nAtomic变量与有竞争的同步\nThread的创建与Thread Pool\n总结\n第十五章 多处理器计算机的并行化循环\n对单一Threaded程序的并行化\n多处理器扩大(scaling)\n总结\n附录 被撤换的Threading功能\n索引","pages":"339 页","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s10030589.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s10030589.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s10030589.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1768767\/","id":"1768767","publisher":"东南大学出版社","isbn10":"756410239X","isbn13":"9787564102395","title":"Java线程","url":"https:\/\/api.douban.com\/v2\/book\/1768767","alt_title":"Java Threads","author_intro":"","summary":"本书第三版已经过完整的扩编与修订。本书完整收录了来自java．util．concurrent的并发功能。新的章节涵盖thread的性能、在Swing中使用thread、thread与Collection class、thread pool以及thread与I／0(传统的、新型的、中断的)。还无法配置J2SE 5．0的开发者可以借由附录中所提供的thread工具于较早的Java版本中达成类似的功能。","price":"39.00元"},{"rating":{"max":10,"numRaters":1158,"average":"9.0","min":0},"subtitle":"","author":["Brian Goetz","Tim Peierls","Joshua Bloch","Joseph Bowbeer","David Holmes","Doug Lea"],"pubdate":"2012-2","tags":[{"count":1513,"name":"Java","title":"Java"},{"count":1169,"name":"并发","title":"并发"},{"count":888,"name":"多线程","title":"多线程"},{"count":403,"name":"编程","title":"编程"},{"count":327,"name":"计算机","title":"计算机"},{"count":327,"name":"java","title":"java"},{"count":262,"name":"并发编程","title":"并发编程"},{"count":168,"name":"软件开发","title":"软件开发"}],"origin_title":"Java Concurrency in Practice","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s7663093.jpg","binding":"平装","translator":["童云兰"],"catalog":"对本书的赞誉\n译者序\n前　言\n第1章　简介1\n1.1　并发简史1\n1.2　线程的优势2\n1.2.1　发挥多处理器的强大能力2\n1.2.2　建模的简单性3\n1.2.3　异步事件的简化处理3\n1.2.4　响应更灵敏的用户界面4\n1.3　线程带来的风险4\n1.3.1　安全性问题5\n1.3.2　活跃性问题7\n1.3.3　性能问题7\n1.4　线程无处不在7\n第一部分　基础知识\n第2章　线程安全性11\n2.1　什么是线程安全性13\n2.2　原子性14\n2.2.1　竞态条件15\n2.2.2　示例：延迟初始化中的竞态条件16\n2.2.3　复合操作17\n2.3　加锁机制18\n2.3.1　内置锁20\n2.3.2　重入21\n2.4　用锁来保护状态22\n2.5　活跃性与性能23\n第3章　对象的共享27\n3.1　可见性27\n3.1.1　失效数据28\n3.1.2　非原子的64位操作29\n3.1.3　加锁与可见性30\n3.1.4　Volatile变量 30\n3.2　发布与逸出32\n3.3　线程封闭35\n3.3.1　Ad-hoc线程封闭35\n3.3.2　栈封闭36\n3.3.3　ThreadLocal类37\n3.4　不变性38\n3.4.1　Final域39\n3.4.2　示例：使用Volatile类型来发布不可变对象40\n3.5　安全发布41\n3.5.1　不正确的发布：正确的对象被破坏42\n3.5.2 　不可变对象与初始化安全性42\n3.5.3　安全发布的常用模式43\n3.5.4　事实不可变对象44\n3.5.5　可变对象44\n3.5.6　安全地共享对象44\n第4章　对象的组合46\n4.1　设计线程安全的类46\n4.1.1　收集同步需求47\n4.1.2　依赖状态的操作48\n4.1.3　状态的所有权48\n4.2　实例封闭49\n4.2.1　Java监视器模式51\n4.2.2　示例：车辆追踪51\n4.3　线程安全性的委托53\n4.3.1　示例：基于委托的车辆追踪器54\n4.3.2　独立的状态变量55\n4.3.3　当委托失效时56\n4.3.4　发布底层的状态变量57\n4.3.5　示例：发布状态的车辆追踪器58\n4.4　在现有的线程安全类中添加功能59\n4.4.1　客户端加锁机制60\n4.4.2　组合62\n4.5　将同步策略文档化62\n第5章　基础构建模块66\n5.1　同步容器类66\n5.1.1　同步容器类的问题66\n5.1.2　迭代器与Concurrent-ModificationException68\n5.1.3　隐藏迭代器69\n5.2　并发容器70\n5.2.1　ConcurrentHashMap71\n5.2.2　额外的原子Map操作72\n5.2.3　CopyOnWriteArrayList72\n5.3　阻塞队列和生产者-消费者模式73\n5.3.1　示例：桌面搜索75\n5.3.2　串行线程封闭76\n5.3.3　双端队列与工作密取77\n5.4　阻塞方法与中断方法77\n5.5　同步工具类78\n5.5.1　闭锁79\n5.5.2　FutureTask80\n5.5.3　信号量82\n5.5.4　栅栏83\n5.6　构建高效且可伸缩的结果缓存85\n第二部分　结构化并发应用程序\n第6章　任务执行93\n6.1　在线程中执行任务93\n6.1.1　串行地执行任务94\n6.1.2　显式地为任务创建线程94\n6.1.3　无限制创建线程的不足95\n6.2　Executor框架96\n6.2.1　示例：基于Executor的Web服务器97\n6.2.2　执行策略98\n6.2.3　线程池98\n6.2.4　Executor的生命周期99\n6.2.5　延迟任务与周期任务101\n6.3　找出可利用的并行性102\n6.3.1　示例：串行的页面渲染器102\n6.3.2　携带结果的任务Callable与Future103\n6.3.3　示例：使用Future实现页面渲染器104\n6.3.4　在异构任务并行化中存在的局限106\n6.3.5　CompletionService:Executor与BlockingQueue106\n6.3.6　示例：使用CompletionService实现页面渲染器107\n6.3.7　为任务设置时限108\n6.3.8　示例：旅行预定门户网站109\n第7章　取消与关闭111\n7.1　任务取消111\n7.1.1　中断113\n7.1.2　中断策略116\n7.1.3　响应中断117\n7.1.4　示例：计时运行118\n7.1.5　通过Future来实现取消120\n7.1.6　处理不可中断的阻塞121\n7.1.7　采用newTaskFor来封装非标准的取消122\n7.2　停止基于线程的服务124\n7.2.1　示例：日志服务124\n7.2.2　关闭ExecutorService127\n7.2.3　“毒丸”对象128\n7.2.4　示例：只执行一次的服务129\n7.2.5　shutdownNow的局限性130\n7.3　处理非正常的线程终止132\n7.4　JVM关闭135\n7.4.1　关闭钩子135\n7.4.2　守护线程136\n7.4.3　终结器136\n第8章　线程池的使用138\n8.1　在任务与执行策略之间的隐性耦合138\n8.1.1　线程饥饿死锁139\n8.1.2　运行时间较长的任务140\n8.2　设置线程池的大小140\n8.3　配置ThreadPoolExecutor141\n8.3.1　线程的创建与销毁142\n8.3.2　管理队列任务142\n8.3.3　饱和策略144\n8.3.4　线程工厂146\n8.3.5　在调用构造函数后再定制ThreadPoolExecutor147\n8.4　扩展 ThreadPoolExecutor148\n8.5　递归算法的并行化149\n第9章　图形用户界面应用程序156\n9.1　为什么GUI是单线程的156\n9.1.1　串行事件处理157\n9.1.2　Swing中的线程封闭机制158\n9.2　短时间的GUI任务160\n9.3　长时间的GUI任务161\n9.3.1　取消162\n9.3.2　进度标识和完成标识163\n9.3.3　SwingWorker165\n9.4　共享数据模型165\n9.4.1　线程安全的数据模型166\n9.4.2　分解数据模型166\n9.5　其他形式的单线程子系统167\n第三部分　活跃性、性能与测试\n第10章　避免活跃性危险169\n10.1　死锁169\n10.1.1　锁顺序死锁170\n10.1.2　动态的锁顺序死锁171\n10.1.3　在协作对象之间发生的死锁174\n10.1.4　开放调用175\n10.1.5　资源死锁177\n10.2　死锁的避免与诊断178\n10.2.1　支持定时的锁178\n10.2.2　通过线程转储信息来分析死锁178\n10.3　其他活跃性危险180\n10.3.1　饥饿180\n10.3.2　糟糕的响应性181\n10.3.3　活锁181\n第11章　性能与可伸缩性183\n11.1　对性能的思考183\n11.1.1　性能与可伸缩性184\n11.1.2　评估各种性能权衡因素185\n11.2　Amdahl定律186\n11.2.1　示例：在各种框架中隐藏的串行部分188\n11.2.2　Amdahl定律的应用189\n11.3　线程引入的开销189\n11.3.1　上下文切换190\n11.3.2　内存同步190\n11.3.3　阻塞192\n11.4　减少锁的竞争192\n11.4.1　缩小锁的范围（“快进快出”）193\n11.4.2　减小锁的粒度195\n11.4.3　锁分段196\n11.4.4　避免热点域197\n11.4.5　一些替代独占锁的方法198\n11.4.6　监测CPU的利用率199\n11.4.7　向对象池说“不”200\n11.5　示例：比较Map的性能200\n11.6　减少上下文切换的开销201\n第12章　并发程序的测试204\n12.1　正确性测试205\n12.1.1　基本的单元测试206\n12.1.2　对阻塞操作的测试207\n12.1.3　安全性测试208\n12.1.4　资源管理的测试212\n12.1.5　使用回调213\n12.1.6　产生更多的交替操作214\n12.2　性能测试215\n12.2.1　在PutTakeTest中增加计时功能215\n12.2.2　多种算法的比较217\n12.2.3　响应性衡量218\n12.3　避免性能测试的陷阱220\n12.3.1　垃圾回收220\n12.3.2　动态编译220\n12.3.3　对代码路径的不真实采样222\n12.3.4　不真实的竞争程度222\n12.3.5　无用代码的消除223\n12.4　其他的测试方法224\n12.4.1　代码审查224\n12.4.2　静态分析工具224\n12.4.3　面向方面的测试技术226\n12.4.4　分析与监测工具226\n第四部分　高级主题\n第13章　显式锁227\n13.1　Lock与 ReentrantLock227\n13.1.1　轮询锁与定时锁228\n13.1.2　可中断的锁获取操作230\n13.1.3　非块结构的加锁231\n13.2　性能考虑因素231\n13.3　公平性232\n13.4　在synchronized和ReentrantLock之间进行选择234\n13.5　读-写锁235\n第14章　构建自定义的同步工具238\n14.1　状态依赖性的管理238\n14.1.1　示例：将前提条件的失败传递给调用者240\n14.1.2　示例：通过轮询与休眠来实现简单的阻塞241\n14.1.3　条件队列243\n14.2　使用条件队列244\n14.2.1　条件谓词244\n14.2.2　过早唤醒245\n14.2.3　丢失的信号246\n14.2.4　通知247\n14.2.5　示例：阀门类248\n14.2.6　子类的安全问题249\n14.2.7　封装条件队列250\n14.2.8　入口协议与出口协议250\n14.3　显式的Condition对象251\n14.4　Synchronizer剖析253\n14.5　AbstractQueuedSynchronizer254\n14.6　java.util.concurrent同步器类中的 AQS257\n14.6.1　ReentrantLock257\n14.6.2　Semaphore与CountDownLatch258\n14.6.3　FutureTask259\n14.6.4　ReentrantReadWriteLock259\n第15章　原子变量与非阻塞同步机制261\n15.1　锁的劣势261\n15.2　硬件对并发的支持262\n15.2.1　比较并交换263\n15.2.2　非阻塞的计数器264\n15.2.3　JVM对CAS的支持265\n15.3　原子变量类265\n15.3.1　原子变量是一种“更好的volatile”266\n15.3.2　性能比较：锁与原子变量267\n15.4　非阻塞算法270\n15.4.1　非阻塞的栈270\n15.4.2　非阻塞的链表272\n15.4.3　原子的域更新器274\n15.4.4　ABA问题275\n第16章　Java内存模型277\n16.1　什么是内存模型，为什么需要它277\n16.1.1　平台的内存模型278\n16.1.2　重排序278\n16.1.3　Java内存模型简介280\n16.1.4　借助同步281\n16.2　发布283\n16.2.1　不安全的发布283\n16.2.2　安全的发布284\n16.2.3　安全初始化模式284\n16.2.4　双重检查加锁286\n16.3　初始化过程中的安全性287\n附录A　并发性标注289\n参考文献291","pages":"293","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s7663093.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s7663093.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s7663093.jpg"},"alt":"https:\/\/book.douban.com\/subject\/10484692\/","id":"10484692","publisher":"机械工业出版社华章公司","isbn10":"711137004X","isbn13":"9787111370048","title":"Java并发编程实战","url":"https:\/\/api.douban.com\/v2\/book\/10484692","alt_title":"Java Concurrency in Practice","author_intro":"本书作者都是Java Community Process JSR 166专家组（并发工具）的主要成员，并在其他很多JCP专家组里任职。Brian Goetz有20多年的软件咨询行业经验，并著有至少75篇关于Java开发的文章。Tim Peierls是“现代多处理器”的典范，他在BoxPop.biz、唱片艺术和戏剧表演方面也颇有研究。Joseph Bowbeer是一个Java ME专家，他对并发编程的兴趣始于Apollo计算机时代。David Holmes是《The Java Programming Language》一书的合著者，任职于Sun公司。Joshua Bloch是Google公司的首席Java架构师，《Effective Java》一书的作者，并参与著作了《Java Puzzlers》。Doug Lea是《Concurrent Programming》一书的作者，纽约州立大学 Oswego分校的计算机科学教授。","summary":"本书深入浅出地介绍了Java线程和并发，是一本完美的Java并发参考手册。书中从并发性和线程安全性的基本概念出发，介绍了如何使用类库提供的基本并发构建块，用于避免并发危险、构造线程安全的类及验证线程安全的规则，如何将小的线程安全类组合成更大的线程安全类，如何利用线程来提高并发应用程序的吞吐量，如何识别可并行执行的任务，如何提高单线程子系统的响应性，如何确保并发程序执行预期任务，如何提高并发代码的性能和可伸缩性等内容，最后介绍了一些高级主题，如显式锁、原子变量、非阻塞算法以及如何开发自定义的同步工具类。\n本书适合Java程序开发人员阅读。","series":{"id":"38435","title":"华章专业开发者丛书"},"price":"69.00元"},{"rating":{"max":10,"numRaters":42,"average":"7.2","min":0},"subtitle":"通过软件多线程提升性能","author":["阿克特"],"pubdate":"2007-3","tags":[{"count":37,"name":"多核","title":"多核"},{"count":20,"name":"编程","title":"编程"},{"count":20,"name":"并行","title":"并行"},{"count":16,"name":"多线程","title":"多线程"},{"count":10,"name":"并行计算","title":"并行计算"},{"count":7,"name":"计算机科学","title":"计算机科学"},{"count":7,"name":"计算机","title":"计算机"},{"count":5,"name":"Intel","title":"Intel"}],"origin_title":"Multi-Core Programming: Increasing Performance through Software Multithreading","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s2341132.jpg","binding":"平装","translator":["李宝峰","富弘毅","李韬"],"catalog":"","pages":"351","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s2341132.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s2341132.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s2341132.jpg"},"alt":"https:\/\/book.douban.com\/subject\/2031568\/","id":"2031568","publisher":"电子工业出版社","isbn10":"7121038714","isbn13":"9787121038716","title":"多核程序设计技术","url":"https:\/\/api.douban.com\/v2\/book\/2031568","alt_title":"Multi-Core Programming: Increasing Performance through Software Multithreading","author_intro":"本书从原理、技术、经验和工具等方面为读者提供关于多核程序设计技术的全方位理解。本书由三大部分组成：第一部分包括第1~4章，介绍软件多线程的内容；第二部分包括第5章和第6章，其中讨论用于编写并行程序的常用编程API；第三部分包括其余五章关于多核程序设计的内容，讲述常见并行程序设计问题及解决方法（第7章）、多线程应用程序的调试技术（第8章）、单核与多核处理器基本原理（第9、10章）和所需的Intel公司的软件开发辅助工具（第11 章）。\n本书作者都是长期供职于Intel公司的资深软件工程师和结构师，书中融入了他们自己丰富的软硬件开发经验，可以为面向多核体系结构进行并行程序设计的开发人员提供巨大的帮助。不论对从未接触过并行程序设计的开发人员，还是转型面向多核体系结构进行并行程序设计的开发人员来讲，本书都是一本难得的参考书。","summary":"《多核程序设计技术：通过软件多线程提升性能》从原理、技术、经验和工具等方面为读者提供关于多核程序设计技术的全方位理解。《多核程序设计技术：通过软件多线程提升性能》由三大部分组成：第一部分包括第1一4章，介绍软件多线程的内容；第二部分包括第5章和第6章，其中讨论用于编写并行程序的常用编程API；第三部分包括其余五章关于多核程序设计的内容，讲述常见并行程序设计问题及解决方法(第7章)、多线程应用程序的调试技术(第8章)、单核与多核处理器基本原理(第9、10章)和所需的Intel公司的软件开发辅助工具(第11章)。","price":"49.00元"},{"rating":{"max":10,"numRaters":17,"average":"7.0","min":0},"subtitle":"","author":["\n      "],"pubdate":"2003-4","tags":[{"count":30,"name":"c++","title":"c++"},{"count":21,"name":"多线程","title":"多线程"},{"count":10,"name":"多线程编程","title":"多线程编程"},{"count":7,"name":"编程","title":"编程"},{"count":6,"name":"C\/C++","title":"C\/C++"},{"count":5,"name":"C++面向对象多线程编程","title":"C++面向对象多线程编程"},{"count":5,"name":"C++","title":"C++"},{"count":4,"name":"计算机","title":"计算机"}],"origin_title":"","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s25793453.jpg","binding":"","translator":["周良忠"],"catalog":"\n      ","pages":"516","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s25793453.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s25793453.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s25793453.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1243741\/","id":"1243741","publisher":"人民邮电出版社","isbn10":"7115108811","isbn13":"9787115108814","title":"C++面向对象多线程编程","url":"https:\/\/api.douban.com\/v2\/book\/1243741","alt_title":"","author_intro":"","summary":"《C++面向对象多线程编程》共分13章，全面讲解构建多线程架构与增量多线程编程技术。第1章介绍了用于构建面向对象程序的不同类型C++组件，以及如何使用这些组件来构建多线程架构。第2、3、4章简要介绍进程、线程、多任务处理、多线程化、规划以及线程优先权的概念。第5章讨论进程间和线程间通信。第6章讨论线程与进程同步与合作。第6章详细讨论临界区、死锁、数据竞争以及无限延迟方面的主题。第7-10章讲解用于线程同步、线程间通信、进程间通信以及多线程处理的C++组件。第11章讨论C++对象在多线程环境中的行为和交互方式。第12章简单介绍多线程应用程序的测试技术。第13章对全书内容进行扼要地回顾与思考。","price":"68.00元"},{"rating":{"max":10,"numRaters":12,"average":"6.9","min":0},"subtitle":"","author":["[美] Tobin Titus","[美] Fabio Claudio Ferracchiati"],"pubdate":"2003-11-1","tags":[{"count":13,"name":"c#","title":"c#"},{"count":6,"name":"线程","title":"线程"},{"count":6,"name":".Net","title":".Net"},{"count":5,"name":"多线程","title":"多线程"},{"count":3,"name":"计算机","title":"计算机"},{"count":3,"name":"threading","title":"threading"},{"count":2,"name":"教材","title":"教材"},{"count":2,"name":"CSharp","title":"CSharp"}],"origin_title":"","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1326916.jpg","binding":"平装(无盘)","translator":["王敏"],"catalog":"第1章 定义线程\n1.1 线程的定义\n1.1.1 多任务\n1.1.2 进程\n1.1.3 线程\n1.2 .NET和C#对线程的支持\n1.2.1 System.Appdomai\n","pages":"260","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s1326916.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s1326916.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1326916.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1141299\/","id":"1141299","publisher":"清华大学出版社","isbn10":"7302074038","isbn13":"9787302074038","title":"C#线程参考手册","url":"https:\/\/api.douban.com\/v2\/book\/1141299","alt_title":"","author_intro":"","summary":"书自上而下地介绍了.NET执行C#代码的方法。首先描述了Windows线程的定义，它们与.NET进程、应用程序域的关系以及线程之间的关系。讨论了线程的调度（操作系统如何确定下一个要处理的线程），接着论述了如何编写.NET代码来处理线程。之后介绍了线程的同步，让多个线程安全地访问同一资源。本书还介绍了多线程应用程序使用的一些典型的体系结构，尤其是线程池，并阐述了如何调试多线程代码。最后用一个完整的例","price":"33.00"},{"rating":{"max":10,"numRaters":95,"average":"7.5","min":0},"subtitle":"","author":["[美] David R.Buten"],"pubdate":"2003-1","tags":[{"count":126,"name":"多线程","title":"多线程"},{"count":95,"name":"POSIX","title":"POSIX"},{"count":46,"name":"编程","title":"编程"},{"count":46,"name":"UNIX","title":"UNIX"},{"count":37,"name":"thread","title":"thread"},{"count":28,"name":"programming","title":"programming"},{"count":26,"name":"计算机","title":"计算机"},{"count":24,"name":"linux","title":"linux"}],"origin_title":"Programming with POSIX Threads","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1483836.jpg","binding":"","translator":[],"catalog":"序言\n第1章 概述\n1.1 舀水的程序员\n1.2 术语定义\n1.3 异步编程是直观的\n1.4 关于本书的实例\n1.5 异步编程举例\n","pages":"321","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s1483836.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s1483836.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1483836.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1236825\/","id":"1236825","publisher":"中国电力出版社","isbn10":"750831395X","isbn13":"9787508313955","title":"POSIX多线程程序设计","url":"https:\/\/api.douban.com\/v2\/book\/1236825","alt_title":"Programming with POSIX Threads","author_intro":"David R.Butenhof，是一个公认的Pthreads权威人士，深入参与过IEEE的POSIX标准和X\/OPEN线程扩展的制订。作为DEC公司的工程师，他还是Digital的线程体系的主要构架师和开发者，在Digital UNIX 4.0上设计并实现了大量的Pthreads接口。","summary":"内容提要\n    本书深入描述了IEEE的开放系统接口标准-POSIX线程，通常称为Pthreads标准。本\n书首先解释了线程的基本概念，包括异步编程、线程的生命周期和同步机制；然后讨论了\n一些高级话题，包括属性对象、线程私有数据和实时调度。此外，本书还讨论了调度的问\n题，并给出了避免错误和提高性能等问题的有价值的建议。本书使用了大量注释过的实例\n来解释实际的概念，并包括Pthreads","price":"39.00元"},{"rating":{"max":10,"numRaters":123,"average":"8.5","min":0},"subtitle":"","author":["结城 浩","博硕文化"],"pubdate":"2005-4-1","tags":[{"count":142,"name":"Java","title":"Java"},{"count":127,"name":"多线程","title":"多线程"},{"count":45,"name":"并发","title":"并发"},{"count":35,"name":"JAVA多线程设计模式","title":"JAVA多线程设计模式"},{"count":27,"name":"计算机","title":"计算机"},{"count":21,"name":"编程","title":"编程"},{"count":18,"name":"thread","title":"thread"},{"count":17,"name":"java","title":"java"}],"origin_title":"","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s1406772.jpg","binding":"平装(无盘)","translator":["博硕文化"],"catalog":"","pages":"493","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s1406772.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s1406772.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s1406772.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1281934\/","id":"1281934","publisher":"中国铁道出版社","isbn10":"7113064027","isbn13":"9787113064020","title":"JAVA多线程设计模式","url":"https:\/\/api.douban.com\/v2\/book\/1281934","alt_title":"","author_intro":"","summary":"《JAVA多线程设计模式》中包含JAVA线程的介绍导读，12个重要的线程设计模式和全书总结以及丰富的附录内容。每一章相关线程设计模式的介绍，都举一反三使读者学习更有效率。最后附上练习问题，让读者可以温故而知新，能快速地吸收书中的精华，书中最后附上练习问题解答，方便读者学习验证。","price":"49.00元"},{"rating":{"max":10,"numRaters":2,"average":"0.0","min":0},"subtitle":"","author":[],"pubdate":"2019-5","tags":[{"count":1,"name":"好书，值得一读","title":"好书，值得一读"}],"origin_title":"","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s33476342.jpg","binding":"平装","translator":[],"catalog":"前言\n第1章　Java多线程技能1\n1.1　进程和多线程概述1\n1.2　使用多线程5\n1.2.1　继承Thread类5\n1.2.2　使用常见命令分析线程的信息8\n1.2.3　线程随机性的展现11\n1.2.4　执行start()的顺序不代表执行run()的顺序12\n1.2.5　实现Runnable接口13\n1.2.6　使用Runnable接口实现多线程的优点14\n1.2.7　实现Runnable接口与继承Thread类的内部流程16\n1.2.8　实例变量共享造成的非线程安全问题与解决方案17\n1.2.9　Servlet技术造成的非线程安全问题与解决方案21\n1.2.10　留意i--与System.out.println()出现的非线程安全问题24\n1.3　currentThread()方法26\n1.4　isAlive()方法29\n1.5　sleep(long millis)方法31\n1.6　sleep(long millis, int nanos)方法33\n1.7　StackTraceElement[] getStackTrace()方法33\n1.8　static void dumpStack()方法35\n1.9　static Map<Thread, StackTrace-Element[]> getAllStackTraces()方法36\n1.10　getId()方法38\n1.11　停止线程38\n1.11.1　停止不了的线程39\n1.11.2　判断线程是否为停止状态41\n1.11.3　能停止的线程—异常法43\n1.11.4　在sleep状态下停止线程47\n1.11.5　用stop()方法暴力停止线程49\n1.11.6　stop()方法与java.lang.ThreadDeath异常51\n1.11.7　使用stop()释放锁给数据造成不一致的结果52\n1.11.8　使用“return;”语句停止线程的缺点与解决方案54\n1.12　暂停线程57\n1.12.1　suspend()方法与resume()方法的使用57\n1.12.2　suspend()方法与resume()方法的缺点—独占58\n1.12.3　suspend()方法与resume()方法的缺点—数据不完整62\n1.13　yield()方法63\n1.14　线程的优先级64\n1.14.1　线程优先级的继承特性65\n1.14.2　优先级的规律性66\n1.14.3　优先级的随机性68\n1.14.4　优先级对线程运行速度的影响70\n1.15　守护线程71\n1.16　本章小结73\n第2章　对象及变量的并发访问74\n2.1　synchronized同步方法74\n2.1.1　方法内的变量为线程安全74\n2.1.2　实例变量非线程安全问题与解决方案77\n2.1.3　同步synchronized在字节码指令中的原理80\n2.1.4　多个对象多个锁81\n2.1.5　将synchronized方法与对象作为锁84\n2.1.6　脏读89\n2.1.7　synchronized锁重入91\n2.1.8　锁重入支持继承的环境93\n2.1.9　出现异常，锁自动释放94\n2.1.10　重写方法不使用synchronized96\n2.1.11　public static boolean holdsLock(Object obj)方法的使用99\n2.2　synchronized同步语句块99\n2.2.1　synchronized方法的弊端99\n2.2.2　synchronized同步代码块的使用102\n2.2.3　用同步代码块解决同步方法的弊端104\n2.2.4　一半异步，一半同步105\n2.2.5　synchronized代码块间的同步性108\n2.2.6　println()方法也是同步的110\n2.2.7　验证同步synchronized(this)代码块是锁定当前对象的110\n2.2.8　将任意对象作为锁113\n2.2.9　多个锁就是异步执行116\n2.2.10　验证方法被调用是随机的118\n2.2.11　不同步导致的逻辑错误及其解决方法121\n2.2.12　细化验证3个结论124\n2.2.13　类Class的单例性129\n2.2.14　静态同步synchronized方法与synchronized(class)代码块130\n2.2.15　同步syn static方法可以对类的所有对象实例起作用135\n2.2.16　同步syn(class)代码块可以对类的所有对象实例起作用137\n2.2.17　String常量池特性与同步相关的问题与解决方案138\n2.2.18　同步synchronized方法无限等待问题与解决方案141\n2.2.19　多线程的死锁143\n2.2.20　内置类与静态内置类146\n2.2.21　内置类与同步：实验1149\n2.2.22　内置类与同步：实验2151\n2.2.23　锁对象改变导致异步执行153\n2.2.24　锁对象不改变依然同步执行156\n2.2.25　同步写法案例比较158\n2.3　volatile关键字159\n2.3.1　可见性的测试159\n2.3.2　原子性的测试168\n2.3.3　禁止代码重排序的测试176\n2.4　本章小结187\n第3章　线程间通信188\n3.1　wait\/notify机制188\n3.1.1　不使用wait\/notify机制实现线程间通信188\n3.1.2　wait\/notify机制191\n3.1.3　wait\/notify机制的原理192\n3.1.4　wait()方法的基本使用192\n3.1.5　完整实现wait\/notify机制194\n3.1.6　使用wait\/notify机制实现list.size()等于5时的线程销毁195\n3.1.7　对业务代码进行封装198\n3.1.8　线程状态的切换201\n3.1.9　wait()方法：立即释放锁202\n3.1.10　sleep()方法：不释放锁203\n3.1.11　notify()方法：不立即释放锁204\n3.1.12　interrupt()方法遇到wait()方法206\n3.1.13　notify()方法：只通知一个线程208\n3.1.14　notifyAll()方法：通知所有线程211\n3.1.15　wait(long)方法的基本使用212\n3.1.16　wait(long)方法自动向下运行需要重新持有锁214\n3.1.17　通知过早问题与解决方法217\n3.1.18　wait条件发生变化与使用while的必要性220\n3.1.19　生产者\/消费者模式的实现224\n3.1.20　通过管道进行线程间通信—字节流250\n3.1.21　通过管道进行线程间通信—字符流253\n3.1.22　实现wait\/notify的交叉备份256\n3.2　join()方法的使用259\n3.2.1　学习join()方法前的铺垫259\n3.2.2　join()方法和interrupt()方法出现异常261\n3.2.3　join(long)方法的使用263\n3.2.4　join(long)方法与sleep(long)方法的区别264\n3.2.5　join()方法后面的代码提前运行—出现意外 268\n3.2.6　join()方法后面的代码提前运行—解释意外270\n3.2.7　join(long millis, int nanos)方法的使用273\n3.3　类ThreadLocal的使用273\n3.3.1　get()方法与null274\n3.3.2　类ThreadLocal存取数据流程分析275\n3.3.3　验证线程变量的隔离性277\n3.3.4　解决get()方法返回null的问题282\n3.3.5　验证重写initialValue()方法的隔离性283\n3.4　类InheritableThreadLocal的使用284\n3.4.1　类ThreadLocal不能实现值继承285\n3.4.2　使用InheritableThreadLocal体现值继承特性286\n3.4.3　值继承特性在源代码中的执行流程288\n3.4.4　父线程有最新的值，子线程仍是旧值291\n3.4.5　子线程有最新的值，父线程仍是旧值293\n3.4.6　子线程可以感应对象属性值的变化294\n3.4.7　重写childValue()方法实现对继承的值进行加工297\n3.5　本章小结298\n第4章　Lock对象的使用299\n4.1　使用ReentrantLock类299\n4.1.1　使用ReentrantLock实现同步299\n4.1.2　验证多代码块间的同步性301\n4.1.3　await()方法的错误用法与更正304\n4.1.4　使用await()和signal()实现wait\/notify机制307\n4.1.5　await()方法暂停线程运行的原理309\n4.1.6　通知部分线程—错误用法312\n4.1.7　通知部分线程—正确用法314\n4.1.8　实现生产者\/消费者模式一对一交替输出317\n4.1.9　实现生产者\/消费者模式多对多交替输出319\n4.1.10　公平锁与非公平锁321\n4.1.11　public int getHoldCount()方法的使用324\n4.1.12　public final int getQueue Length()方法的使用325\n4.1.13　public int getWaitQueue-Length (Condition condition)方法的使用327\n4.1.14　public final boolean has-QueuedThread (Thread thread)方法的使用328\n4.1.15　public final boolean has-QueuedThreads()方法的使用329\n4.1.16　public boolean hasWaiters (Con-dition condition)方法的使用331\n4.1.17　public final boolean isFair()方法的使用332\n4.1.18　public boolean isHeldBy-CurrentThread()方法的使用333\n4.1.19　public boolean isLocked()方法的使用334\n4.1.20　public void lockInterruptibly()方法的使用335\n4.1.21　public boolean tryLock()方法的使用336\n4.1.22　public boolean tryLock (long timeout, TimeUnit unit)方法的使用338\n4.1.23　public boolean await (long time, TimeUnit unit)方法的使用339\n4.1.24　public long awaitNanos(long nanosTimeout)方法的使用341\n4.1.25　public boolean awaitUntil(Date deadline)方法的使用342\n4.1.26　public void awaitUninterru-ptibly()方法的使用344\n4.1.27　实现线程按顺序执行业务346\n4.2　使用ReentrantReadWriteLock类349\n4.2.1　ReentrantLock类的缺点349\n4.2.2　ReentrantReadWriteLock类的使用—读读共享351\n4.2.3　ReentrantReadWriteLock类的使用—写写互斥352\n4.2.4　ReentrantReadWriteLock类的使用—读写互斥352\n4.2.5　ReentrantReadWriteLock类的使用—写读互斥354\n4.3　本章小结355\n第5章　定时器Timer356\n5.1　定时器Timer的使用356\n5.1.1　schedule(TimerTask task, Datetime)方法的测试356\n5.1.2　schedule(TimerTask task, Date firstTime, long period)方法的测试366\n5.1.3　schedule(TimerTask task, long delay)方法的测试374\n5.1.4　schedule(TimerTask task, long delay, long period)方法的测试374\n5.1.5　scheduleAtFixedRate (TimerTask task, Date firstTime, long period)方法的测试375\n5.2　本章小结384\n第6章　单例模式与多线程385\n6.1　立即加载\/饿汉模式385\n6.2　延迟加载\/懒汉模式387\n6.2.1　延迟加载\/懒汉模式解析387\n6.2.2　延迟加载\/懒汉模式的缺点388\n6.2.3　延迟加载\/懒汉模式的解决方案390\n6.3　使用静态内置类实现单例模式399\n6.4　序列化与反序列化的单例模式实现400\n6.5　使用static代码块实现单例模式402\n6.6　使用enum枚举数据类型实现单例模式404\n6.7　完善使用enum枚举数据类型实现单例模式405\n6.8　本章小结407\n第7章　拾遗增补408\n7.1　线程的状态408\n7.1.1　验证NEW、RUNNABLE和TERMINATED410\n7.1.2　验证TIMED_WAITING411\n7.1.3　验证BLOCKED412\n7.1.4　验证WAITING414\n7.2　线程组415\n7.2.1　线程对象关联线程组：一级关联416\n7.2.2　线程对象关联线程组：多级关联417\n7.2.3　线程组自动归属特性418\n7.2.4　获取根线程组419\n7.2.5　线程组中加线程组420\n7.2.6　组内的线程批量停止421\n7.2.7　递归取得与非递归取得组内对象422\n7.3　Thread.activeCount()方法的使用423\n7.4　Thread.enumerate(Thread tarray[])方法的使用423\n7.5　再次实现线程执行有序性424\n7.6　SimpleDateFormat非线程安全426\n7.6.1　出现异常426\n7.6.2　解决异常的方法1428\n7.6.3　解决异常的方法2430\n7.7　线程中出现异常的处理431\n7.7.1　线程出现异常的默认行为431\n7.7.2　使用setUncaughtException-Handler()方法进行异常处理432\n7.7.3　使用setDefaultUncaughtExce-ptionHandler()方法进行异常处理433\n7.8　线程组内处理异常434\n7.9　线程异常处理的优先性437\n7.10　本章小结442","pages":"442","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s33476342.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s33476342.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s33476342.jpg"},"alt":"https:\/\/book.douban.com\/subject\/33453918\/","id":"33453918","publisher":"机械工业出版社","isbn10":"7111614909","isbn13":"9787111614906","title":"Java多线程编程核心技术（第2版）","url":"https:\/\/api.douban.com\/v2\/book\/33453918","alt_title":"","author_intro":"某世界500强项目经理，有10年Java相关开发经验，精通Java语言，擅长J2EE、EJB、Android、报表和多线程，以及并发相关的技术内容，理论与实践经验颇丰。著有《Java多线程编程核心技术》《Java并发编程：核心方法与框架》《NIO与Socket编程技术指南》《Java EE核心框架实战 第2版》《Jasper Reports+iReport报表开发详解》《Android学习精要》等书籍。","summary":"技术畅销书全新升级，案例式讲解，逐一分析和验证每个技术点，通俗易懂。本书涵盖多线程编程的核心库、方法、原理，解决高并发环境下的业务瓶颈。第1章讲解Java多线程的基础知识，包括Thread类的核心API使用。第2章讲解了在多线程中通过synchronized关键字对并发访问进行控制的方法，为读者学习同步知识打好坚实的基础。第3章介绍线程间通信，以在多线程中进行数据传递。第4章介绍并发访问时的同步处理实现，包括读写锁（Lock对象）等相关技术点。第5章剖析定时器Timer类的内部原理。定时器在Android开发中会有深入应用，是很重要的技术点。第6章介绍单例模式下多线程的全面解决方案。第7章对前面遗漏的知识点进行补充，使多线程的知识体系更加完整，尽量做到不出现技术空白点。","series":{"id":"34391","title":"Java核心技术系列"},"price":"99.00元"},{"rating":{"max":10,"numRaters":5,"average":"0.0","min":0},"subtitle":"","author":["安德鲁斯"],"pubdate":"1900-01-01","tags":[{"count":9,"name":"分布式","title":"分布式"},{"count":6,"name":"并行","title":"并行"},{"count":4,"name":"计算机","title":"计算机"},{"count":4,"name":"并行程序设计","title":"并行程序设计"},{"count":3,"name":"多线程编程","title":"多线程编程"},{"count":2,"name":"多线程","title":"多线程"},{"count":1,"name":"计算机系统","title":"计算机系统"},{"count":1,"name":"经典","title":"经典"}],"origin_title":"Foundations of Multithreaded, Parallel, and Distributed Programming","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s9804913.jpg","binding":"平装","translator":[],"catalog":"\n      ","pages":"664","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s9804913.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s9804913.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s9804913.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1116601\/","id":"1116601","publisher":"高等教育出版社","isbn10":"7040114003","isbn13":"9787040114003","title":"多线程,并行与分布式程序设计基础(影印版)","url":"https:\/\/api.douban.com\/v2\/book\/1116601","alt_title":"Foundations of Multithreaded, Parallel, and Distributed Programming","author_intro":"","summary":"本书利用现实环境中的例子，着重讲述并行系统的实践与应用。介绍了多线程、并行和分布式计算的基本概念，并且把它们与实现和完成过程联系起来，关注解决方案的正确性和性能。主要内容包括：共享变量程序设计，分布式程序设计，并行程序设计。本书对一些实际案例进行研究，论题包括并行线程、MPI、OpenMP库，还有Java程序设计语言、Ada、高性能Fortran、Linda、Occam和SR。通过完整程序执行具体的例子，程序和实例皆为共享式和分布式的。样例应用领域包括科学计算和分布式系统。本书适用于多线程、并行和分布式计算课程。 作者Greg Andrews是美国亚利桑那大学计算机科学系教授，其研究涉及包括并发和分布式程序设计的各个层面。","price":"46.0"},{"rating":{"max":10,"numRaters":14,"average":"7.3","min":0},"subtitle":"","author":["Scott Oaks"],"pubdate":"2003-05-01","tags":[{"count":13,"name":"Java","title":"Java"},{"count":8,"name":"计算机","title":"计算机"},{"count":3,"name":"multi-thread","title":"multi-thread"},{"count":3,"name":"concurrent","title":"concurrent"},{"count":2,"name":"多线程","title":"多线程"},{"count":1,"name":"程序设计","title":"程序设计"},{"count":1,"name":"并发","title":"并发"},{"count":1,"name":"java多线程","title":"java多线程"}],"origin_title":"Java Threads","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s1094723.jpg","binding":"","translator":["黄若波","程峰"],"catalog":"前言\n第一章 线程简介\njava术语\n线程概述\n为什么要使用线程？\n总结\n第二章 java线程api\n通过thread类创建线程\n使用runable接口的线程\n线程的生命周期\n线程命名\n访问线程\n线程的启动、停止和连接\n总结\n第三章 同步技术\n银行的例子\n异步读取数据\n.一个进行同步操作的类\n同步块\n嵌套锁\n死锁\n返回到银行的例子\n同步静态方法\n总结\n第四章 等待和通知\n返回到银行的例子\n等待和通知\nwait（）、notify（）和notifyall（）\nwait（）和sleep（）\n线程中断\n静态方法（有关同步的细节）\n总结\n第五章 java线程编程的例子\n数据结构和容器\n简单的同步例子\n一个网络服务器类\nasyncinputstream类\n使用tcpserver和asynclnputstream\n总结\n第六章 java线程调度\n线程调度概述\n何时调度是重要的\n调度和线程优先级\n常见的调度实现\n本地调度支持\n其他线程调度方法\n总结\n第七章 java线程调度例子\n线程池\n循环调度\n作业调度\n总结\n第八章 和同步相关的高级主题\n同步术语\n预防死锁\n锁饥饿\n非线程安全的类\n总结\n第九章 多处理器机器上的并行化\n单线程程序并行化\n内层循环线程化\n循环输出\n多处理器扩展\n总结\n第十章 线程组\n线程组概念\n创建线程组\n线程组方法\n操作线程组\n线程组、线程和安全\n总结\n附录一 其他主题\n附录二 异常和错误\n词汇表","pages":"337","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s1094723.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s1094723.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s1094723.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1118754\/","id":"1118754","publisher":"中国电力出版社","isbn10":"7508313186","isbn13":"9787508313184","title":"Java线程","url":"https:\/\/api.douban.com\/v2\/book\/1118754","alt_title":"Java Threads","author_intro":"","summary":"线程并不是新的概念：许多操作系统和语言都支持它们。在Java出现以前，似乎人人都在谈论线程，却很少有人使用它。用线程编程是技巧性很强的且不可移植。\n而在Java中却完全不同。Java的线程工具易于使用，并且像Java中的其他东西一样可以在不同的平台之间移植。这是一件好事，因为如果没有线程，那么除了最简单的applet之外，几乎不可能编写出任何程序。如果你想使用Java，就必须学习线程。\n本书的新版本展示了如何利用Java线程工具的全部优势，并介绍了JDK 2线程接口中的最新变化。你将学习如何使用线程来提高效率，如何有效地使用它们，以及如何避免常见的错误。本书讨论了死锁、竞态条件以及饥饿等问题的细节，帮助你编写没有潜在bug的代码。\n本书第二版提供了对Thread和ThreadGroup类、Runnable接口和语言的同步操作符内容的全面讨论。它解释了如何在不同的平台上调度线程，如何开发CPUScheduler类来实现你自己的调度策略。其他扩展例子包括实现读\/写锁、通用锁、任意作用域的锁和异步I\/O的类。本版本还增加了广泛的例子，展示如何实现线程池和其他同步技术，如条件变量、屏障和守护锁。它展示了如何与非线程安全的类共同工作，并特别关注于Swing的线程问题。新增加的一章介绍了如何为多处理器机器编写并行代码。\n简而言之，本书的新版涉及了有关线程的方方面面，从最简单的动画applet到最复杂的应用程序。如果你计划用Java做任何重要的事情，你将发现本书很有价值。","price":"39.00元"},{"rating":{"max":10,"numRaters":6,"average":"0.0","min":0},"subtitle":"","author":["Paul Hyde"],"pubdate":"2003-11-1","tags":[{"count":7,"name":"Java","title":"Java"},{"count":2,"name":"技术","title":"技术"},{"count":1,"name":"多线程","title":"多线程"},{"count":1,"name":"JAVA&J2EE","title":"JAVA&J2EE"},{"count":1,"name":"2010","title":"2010"}],"origin_title":"","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s9849053.jpg","binding":"平装(无盘)","translator":["周良忠"],"catalog":"第一部分  线\n程\n第1章  线程简介　3\n1.1  什么是线程　4\n1.2  为什么使用多线程　4\n1.2.1  与用户的更佳交互　4\n1.2.2  同步动作的模拟　5\n","pages":"472","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s9849053.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s9849053.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s9849053.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1223077\/","id":"1223077","publisher":"人民邮电出版社","isbn10":"7115117918","isbn13":"9787115117915","title":"Java线程编程","url":"https:\/\/api.douban.com\/v2\/book\/1223077","alt_title":"","author_intro":"","summary":"本书面向的读者是那些已经开始使用Java语方，而且需要开发我线程应用程序和applet（小应用程序）的人。读者可以没有任何线程编程方面的背景，因此本书开始使用的示例简单易懂，随着讲解的深入，以后章节逐渐切入高级主题，并且完涵盖了Java线程编程的所有方面。\n本书以丰富的实例、由浅至深的方式全面讲解如何用Java进行多线程编程。全书分三部分。第一部分（第1章～第10章）介绍基础概念，包括线程、","price":"52.00"},{"rating":{"max":10,"numRaters":5,"average":"0.0","min":0},"subtitle":"","author":["王险峰","刘宝宏"],"pubdate":"2002-7-1","tags":[{"count":5,"name":"多线程","title":"多线程"},{"count":5,"name":"Windows","title":"Windows"},{"count":2,"name":"计算机","title":"计算机"},{"count":1,"name":"程序设计","title":"程序设计"},{"count":1,"name":"想买一本","title":"想买一本"},{"count":1,"name":"专业学习","title":"专业学习"},{"count":1,"name":"【计】","title":"【计】"},{"count":1,"name":"2005","title":"2005"}],"origin_title":"","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s9795756.jpg","binding":"平装(无盘)","translator":[],"catalog":"第一章 概述\n1 进程与线程概念\n……\n第二章 面向对象技术与C++语言概述\n1 面向对象技术概述\n……\n第三章 Windows环境中的多线程实现\n1 Win32 API中的基本线程函数\n……\n第四章 线程间通信概述\n1 线程之间通信的方法\n……\n第五章 互斥及其应用\n1 互斥的实现算法\n……\n第六章 临界段及其应用\n1 临界段的概念\n……\n第七章 事件及其应用\n1 事件的基本概念\n……\n第八章 信号量及其应用\n第九章 附加论题","pages":"368","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s9795756.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s9795756.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s9795756.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1110441\/","id":"1110441","publisher":"清华大学出版社","isbn10":"7302053936","isbn13":"9787302053934","title":"Windows环境下的多线程编程原理与应用","url":"https:\/\/api.douban.com\/v2\/book\/1110441","alt_title":"","author_intro":"","summary":"多线程编程是程序设计技术中的一个很重要的领域，目前多数主流的操作系统都支持多任务操作。多线程是进行大型复杂软件系统开发的一把利器，是否掌握多线程编程是初学者和程序设计高手的重要区别之一。\n    本书共分9章：第1章介绍多线程的概念和与Windows操作系统一些有关的知识；第2章介绍面向对象和C++语言的一些知识；第3章介绍线程创建的各种方法，包括利用Win32 API创建、利用运行时库函数创建","price":"35.00"},{"rating":{"max":10,"numRaters":7,"average":"0.0","min":0},"subtitle":"","author":[],"pubdate":"2011-1","tags":[{"count":5,"name":"计算机","title":"计算机"},{"count":3,"name":"程序设计","title":"程序设计"},{"count":3,"name":"多核","title":"多核"},{"count":2,"name":"多线程","title":"多线程"},{"count":1,"name":"性能","title":"性能"},{"count":1,"name":"Windows编程","title":"Windows编程"}],"origin_title":"","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s4696533.jpg","binding":"","translator":[],"catalog":"","pages":"265","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s4696533.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s4696533.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s4696533.jpg"},"alt":"https:\/\/book.douban.com\/subject\/5391998\/","id":"5391998","publisher":"","isbn10":"7313068700","isbn13":"9787313068705","title":"多核多线程技术","url":"https:\/\/api.douban.com\/v2\/book\/5391998","alt_title":"","author_intro":"","summary":"《多核多线程技术》就多核体系结构、芯片发展与系统软件，多性能并行程序，多线程程序的性能调优方法，多线程编程方法以及编程中的常见问题等作了综合讲述，处处体现了多线程编程理念与综合应用能力的培养。全书深入浅出，适合广大程序员和IT从事人员使用。","price":"49.50元"},{"rating":{"max":10,"numRaters":12,"average":"6.9","min":0},"subtitle":"南梦宫一线程序员的开发实例（修订版）","author":["[日]加藤政树"],"pubdate":"2017-3","tags":[{"count":10,"name":"游戏开发","title":"游戏开发"},{"count":6,"name":"unity","title":"unity"},{"count":4,"name":"计算机","title":"计算机"},{"count":3,"name":"编程","title":"编程"},{"count":3,"name":"Unity","title":"Unity"},{"count":2,"name":"日本","title":"日本"},{"count":2,"name":"C#","title":"C#"},{"count":1,"name":"计算机科学","title":"计算机科学"}],"origin_title":"","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s29419085.jpg","binding":"平装","translator":["罗水东"],"catalog":"第0章　游戏开发前的准备　　1\n0.1　Unity入门　Concept　　2\n0.1.1　概要　　2\n0.1.2　游戏对象　　3\n0.1.3　组件　　5\n0.1.4　资源　　8\n0.1.5　流程　　10\n0.1.6　场景　　11\n0.1.7　预设　　13\n0.1.8　小结　　16\n0.2　先来复习一下Unity的基础知识吧　Concept　　17\n0.2.1　脚本一览　　17\n0.2.2　本章小节　　18\n0.2.3　本章开发的小游戏　　18\n0.3　入门教程（上）——创建项目　Tips　　18\n0.3.1　概要　　18\n0.3.2　创建新项目　　19\n0.3.3　创建地面（创建游戏对象）　　20\n0.3.4　创建场景，保存项目　　21\n0.3.5　调整场景视图的摄像机　　23\n0.3.6　创建方块和小球（创建游戏对象并调整坐标）　　24\n0.3.7　运行游戏　　27\n0.3.8　摄像机的便捷功能　　28\n0.3.9　修改游戏对象的名字　　28\n0.3.10　模拟物理运动（添加Rigidbody组件）　　29\n0.3.11　让玩家角色跳起来（添加游戏脚本）　　30\n0.3.12　修改游戏对象的颜色（创建材质）　　35\n0.3.13　调整游戏画面的尺寸（调整播放器设置）　　36\n0.3.14　小结　　38\n0.4　入门教程（下）——让游戏更有趣　Tips　　38\n0.4.1　概要　　38\n0.4.2　让小球飞起来（物理运动和速度）　　38\n0.4.3　创建大量小球（预设游戏对象）　　39\n0.4.4　整理项目视图　　41\n0.4.5　发射小球（通过脚本创建游戏对象）　　43\n0.4.6　删除画面外的小球（通过脚本删除游戏对象）　　46\n0.4.7　防止玩家角色在空中起跳（发生碰撞时的处理）　　48\n0.4.8　禁止玩家角色旋转（抑制旋转）　　50\n0.4.9　让玩家角色不被弹开（设置重量）　　51\n0.4.10　让小球强烈反弹（设置物理材质）　　52\n0.4.11　消除“漂浮感”（调整重力大小）　　54\n0.4.12　调整摄像机的位置　　56\n0.4.13　修复空中起跳的bug（区分碰撞对象）　　57\n0.4.14　小结　　63\n0.5　关于预设　Tips　　64\n0.5.1　概要　　64\n0.5.2　改良“小方块”游戏对象　　64\n0.5.3　预设与对象实例　　65\n0.5.4　预设和实例的变更　　67\n0.5.5　小结　　70\n0.6　C#和JavaScript的对比　Tips　　71\n0.6.1　概要　　71\n0.6.2　类的定义　　72\n0.6.3　变量的定义　　72\n0.6.4　函数的定义 　　73\n0.6.5　作用域　　74\n0.6.6　静态函数和静态变量的定义　　74\n0.6.7　泛型方法的调用　　74\n0.6.8　Bool类型和字符串类型　　75\n0.6.9　数组　　75\n0.6.10　小结　　75\n第1章　点击动作游戏——怪物　　77\n1.1　玩法介绍　How to Play　　78\n1.2　简单的操作和爽快感　Concept　　80\n1.2.1　脚本一览　　80\n1.2.2　本章小节　　82\n1.3　无限滚动的背景　Tips　　82\n1.3.1　关联文件　　82\n1.3.2　概要　　82\n1.3.3　背景组件的显示位置　　83\n1.3.4　小结　　85\n1.4　无限滚动的背景的改良　Tips　　85\n1.4.1　关联文件　　85\n1.4.2　概要　　86\n1.4.3　稍作尝试　　86\n1.4.4　背景组件显示位置的改良　　87\n1.4.5　小结　　89\n1.5　怪物出现模式的管理　Tips　　89\n1.5.1　关联文件　　89\n1.5.2　概要　　89\n1.5.3　怪物出现的时间点　　90\n1.5.4　怪物出现模式的变化　　92\n1.5.5　小结　　96\n1.6　武士和怪物的碰撞检测　Tips　　96\n1.6.1　关联文件　　96\n1.6.2　概要　　96\n1.6.3　分别对各个怪物进行碰撞检测时的问题　　97\n1.6.4　把怪物编成小组　　98\n1.6.5　小结　　100\n1.7　得分高低的判定　Tips　　100\n1.7.1　概要　　100\n1.7.2　武士的攻击判定　　100\n1.7.3　判断在多近的距离斩杀　　101\n1.7.4　小结　　104\n1.8　使被砍中的怪物向四处飞散　Tips　　104\n1.8.1　概要　　104\n1.8.2　想象一下“圆锥体”　　104\n1.8.3　具体的计算方法　　106\n1.8.4　小结　　108\n第2章　拼图游戏——迷你拼图　　109\n2.1　玩法介绍　How to Play　　110\n排列拼图碎片，拼出最后的图案！　　110\n2.2　流畅的拖曳操作　Concept　　112\n2.2.1　脚本一览　　112\n2.2.2　本章小节　　112\n2.3　点住碎片的任意位置拖动　Tips　　114\n2.3.1　关联文件　　114\n2.3.2　概要　　114\n2.3.3　透视变换和逆透视变换　　114\n2.3.4　被点击处即为光标的位置　　114\n2.3.5　测试拖曳碎片的中心　　117\n2.3.6　小结　　118\n2.4　打乱拼图碎片　Tips　　118\n2.4.1　关联文件　　118\n2.4.2　概要　　118\n2.4.3　设置拼图碎片的坐标为随机数　　118\n2.4.4　改进策略　　119\n2.4.5　小结　　124\n第3章　吃豆游戏——地牢吞噬者　　125\n3.1　玩法介绍　How to Play　　126\n3.2　适时进退和逆转的机会　Concept　　128\n3.2.1　脚本一览　　128\n3.2.2　本章小节　　130\n3.3　平滑的网格移动　Tips　　130\n3.3.1　关联文件　　130\n3.3.2　概要　　130\n3.3.3　能够改变方向的时机　　131\n3.3.4　穿过网格的时机　　131\n3.3.5　小结　　133\n3.4　地图数据　Tips　　134\n3.4.1　关联文件　　134\n3.4.2　概要　　134\n3.4.3　文本文件的格式　　134\n3.4.4　扩展编辑器的功能　　139\n3.4.5　小结　　141\n3.5　摄像机变焦功能的运用　Tips　　141\n3.5.1　关联文件　　141\n3.5.2　概要　　141\n3.5.3　调整策略　　142\n3.5.4　摄像机的视野　　143\n3.5.5　缓动动画　　145\n3.5.6　变焦效果的代码实现　　146\n3.5.7　小结　　149\n3.6　幽灵的AI　Tips　　149\n3.6.1　关联文件　　149\n3.6.2　概要　　149\n3.6.3　跟踪的算法　　150\n3.6.4　埋伏等待型、包围攻击型和随机型　　153\n3.6.5　观察幽灵的行动　　155\n3.6.6　小结　　157\n第4章　3D声音探索游戏——In the Dark Water　　159\n4.1　玩法介绍　How to Play　　160\n4.2　只依靠声音　Concept　　162\n4.2.1　脚本一览　　162\n4.2.2　本章小节　　164\n4.3　仅依靠声音定位　Tips　　164\n4.3.1　概要　　164\n4.3.2　3D 声音的特性　　164\n4.3.3　用于实验的项目　　166\n4.3.4　小结　　167\n4.4　3D声音的控制　Tips　　167\n4.4.1　关联文件　　167\n4.4.2　概要　　167\n4.4.3　3D 声音的设置　　167\n4.4.4　按一定间隔发出声音　　168\n4.4.5　声音的淡出　　169\n4.4.6　小结　　170\n4.5　潜水艇的操纵　Tips　　171\n4.5.1　关联文件　　171\n4.5.2　概要　　171\n4.5.3　操作方法　　171\n4.5.4　转弯速度的衰减　　173\n4.5.5　小结　　177\n4.6　声纳的制作方法　Tips　　177\n4.6.1　概要　　177\n4.6.2　Perspective和Ortho　　178\n4.6.3　Dark Water的声纳摄像机　　179\n4.6.4　摄像机和对象的层　　180\n4.6.5　稍作尝试　　183\n4.6.6　摄像机的视口　　184\n4.6.7　小结　　185\n第5章　节奏游戏——摇滚女孩　　187\n5.1　玩法介绍　How to Play　　188\n5.2　Band-girl的世界　Concept　　189\n5.2.1　脚本一览　　190\n5.2.2　本章小节　　190\n5.3　显示点击时刻的节拍标记　Tips　　192\n5.3.1　关联文件　　192\n5.3.2　概要　　192\n5.3.3　定位单元　　192\n5.3.4　标记的显示　　195\n5.3.5　小结　　198\n5.4　判断是否配合了音乐点击　Tips　　198\n5.4.1　关联文件　　198\n5.4.2　概要　　198\n5.4.3　得分高低的判断　　198\n5.4.4　避免重复判断　　200\n5.4.5　小结　　205\n5.5　演出数据的管理和执行　Tips　　205\n5.5.1　关联文件　　205\n5.5.2　概要　　205\n5.5.3　事件数据的检索　　205\n5.5.4　定位单元和执行单元　　207\n5.5.5　小结　　211\n5.6　其他调整功能　Tips　　211\n5.6.1　关联文件　　211\n5.6.2　概要　　211\n5.6.3　什么是turn around　　212\n5.6.4　显示时刻的偏移值　　212\n5.6.5　定位条　　214\n5.6.6　显示标记的行号　　216\n5.6.7　小结　　216\n第6章　全方位滚动射击游戏——噬星者　　217\n6.1　玩法介绍　How to Play　　218\n6.2　功能强大的激光制导　Concept　　219\n6.2.1　脚本一览　　220\n6.2.2　本章小节　　220\n6.3　索敌激光的碰撞检测　Tips　　222\n6.3.1　关联文件　　222\n6.3.2　概要　　222\n6.3.3　索敌激光的碰撞检测　　222\n6.3.4　碰撞网格的生成方法　　224\n6.3.5　确认碰撞网格　　229\n6.3.6　小结　　229\n6.4　不会重复的锁定　Tips　　230\n6.4.1　关联文件　　230\n6.4.2　概要　　230\n6.4.3　锁定的管理　　230\n6.4.4　小结　　233\n6.5　制导激光　Tips　　233\n6.5.1　关联文件　　233\n6.5.2　概要　　233\n6.5.3　根据TrailRenderer生成网格　　233\n6.5.4　制导激光的移动　　234\n6.5.5　稍作尝试　　238\n6.5.6　小结　　238\n6.6　消息窗口　Tips　　239\n6.6.1　关联文件　　239\n6.6.2　概要　　239\n6.6.3　消息队列和显示缓冲区　　239\n6.6.4　小结　　244\n第7章　消除动作解谜游戏——吃月亮　　245\n7.1　玩法介绍　How to Play　　246\n7.2　爽快的连锁和有趣的方块移动　Concept　　248\n7.2.1　脚本一览　　248\n7.2.2　本章小节　　250\n7.3　同色方块相邻与否的判断　Tips　　250\n7.3.1　关联文件　　250\n7.3.2　概要　　250\n7.3.3　连结与连锁　　250\n7.3.4　不停地检测相邻方块　　251\n7.3.5　递归调用　　253\n7.3.6　用于测试连结检测的项目　　256\n7.3.7　防止无限循环检测　　257\n7.3.8　小结　　258\n7.4　方块的初始设置　Tips　　259\n7.4.1　关联文件　　259\n7.4.2　概要　　259\n7.4.3　颜色的选择方法　　259\n7.4.4　随机选取方块的摆放位置　　262\n7.4.5　小结　　264\n7.5　动画的父子构造关系　Tips　　264\n7.5.1　关联文件　　264\n7.5.2　概要　　264\n7.5.3　方块的运动　　264\n7.5.4　动画的父子构造——用于测试的项目　　267\n7.5.5　《吃月亮》中面板的位置和角度的计算　　272\n7.5.6　小结　　274\n7.6　方块的平滑移动　Tips　　274\n7.6.1　关联文件　　274\n7.6.2　概要　　274\n7.6.3　数组的索引和画面上的位置　　275\n7.6.4　桶列方法　　277\n7.6.5　小结　　280\n第8章　跳跃动作游戏——猫跳纸窗　　281\n8.1　玩法介绍　How to Play　　282\n8.2　刺激的跳跃　Concept　　284\n8.2.1　脚本一览　　284\n8.2.2　本章小节　　286\n8.3　角色的状态管理　Tips　　286\n8.3.1　关联文件　　286\n8.3.2　概要　　286\n8.3.3　角色的动作　　286\n8.3.4　状态的迁移　　287\n8.3.5　状态管理的流程　　288\n8.3.6　小结　　292\n8.4　可以控制高度的跳跃　Tips　　293\n8.4.1　关联文件　　293\n8.4.2　概要　　293\n8.4.3　跳跃的物理规律　　293\n8.4.4　自由控制跳跃高度的操作　　294\n8.4.5　小结　　297\n8.5　窗户纸的碰撞检测　Tips　　297\n8.5.1　关联文件　　297\n8.5.2　概要　　297\n8.5.3　“碰撞”的内部实现机制　　297\n8.5.4　窗户对象　　299\n8.5.5　矛盾的碰撞结果　　299\n8.5.6　平滑地穿过格子眼　　309\n8.5.7　小结　　312\n第9章　角色扮演游戏——村子里的传说　　313\n9.1　玩法介绍　How to Play　　314\n9.2　移动简单，人人都是主人公　Concept　　316\n9.2.1　脚本一览　　316\n9.2.2　本章小节　　318\n9.3　事件和Actor　Tips　　318\n9.3.1　关联文件　　318\n9.3.2　概要　　318\n9.3.3　事件　　318\n9.3.4　事件的数据结构　　322\n9.3.5　Actor　　324\n9.3.6　事件的执行　　327\n9.3.7　试着执行一个事件　　330\n9.3.8　小结　　332\n9.4　游戏内参数　Tips　　332\n9.4.1　关联文件　　332\n9.4.2　概要　　332\n9.4.3　游戏内参数　　332\n9.4.4　小结　　336\n9.5　事件文件的读取　Tips　　336\n9.5.1　关联文件　　336\n9.5.2　概要　　336\n9.5.3　文件的读取　　336\n9.5.4　小结　　340\n9.6　特殊的事件　Tips　　341\n9.6.1　关联文件　　341\n9.6.2　概要　　341\n9.6.3　选项指令　　341\n9.6.4　宝箱事件　　343\n9.6.5　进入屋子的事件　　345\n9.6.6　小结　　346\n第10章　驾驶游戏——迷踪赛道　　347\n10.1　玩法介绍　How to Play　　348\n10.2　自行创建，即作即用　Concept　　350\n10.2.1　脚本一览　　350\n10.2.2　本章小节　　352\n10.2.3　关于Car Tutorial脚本　　352\n10.3　透视变换和逆透视变换　Tips　　352\n10.3.1　关联文件　　352\n10.3.2　概要　　352\n10.3.3　透视变换　　353\n10.3.4　逆透视变换　　355\n10.3.5　小结　　357\n10.4　多边形网格的生成方法　Tips　　358\n10.4.1　关联文件　　358\n10.4.2　概要　　358\n10.4.3　生成道路的中心线　　359\n10.4.4　多边形的生成方法　　361\n10.4.5　生成道路多边形　　362\n10.4.6　急转弯时的多边形重叠　　367\n10.4.7　用于测试多边形生成的项目　　368\n10.4.8　小结　　368\n10.5　模型的变形　Tips　　368\n10.5.1　关联文件　　368\n10.5.2　概要　　368\n10.5.3　变形后顶点的位置坐标　　369\n10.5.4　小结　　373\n10.6　点缀实例　Tips　　373\n10.6.1　关联文件　　373\n10.6.2　概要　　373\n10.6.3　生成基准线　　374\n10.6.4　把树木设置到基准线上　　378\n10.6.5　小结　　382\n后记　　383","pages":"404","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s29419085.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s29419085.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s29419085.jpg"},"alt":"https:\/\/book.douban.com\/subject\/27013731\/","id":"27013731","publisher":"人民邮电出版社","isbn10":"711544899X","isbn13":"9787115448996","title":"Unity游戏设计与实现","url":"https:\/\/api.douban.com\/v2\/book\/27013731","alt_title":"","author_intro":"作者简介：\n加藤政树<作者>\n就职于日本著名的游戏制造商南梦宫。除产品开发外，还负责公司内部中间件的开发和技术研究、高端项目支持、新游戏的研发等工作。近年来也开始致力于NPR（Non Photorealistic Rendering）的研究。代表作品有Fitness Party、Muscle March。\n译者简介：\n罗水东<译者>\n资深游戏开发工程师。10年软件和游戏开发经验，期间5年时间在日本工作。热爱技术，乐于分享心得。目前主要关注领域为Unity3D游戏开发技术、游戏设计模式。","summary":"本书出自日本知名游戏公司万代南梦宫的资深开发人员之手，面向初级游戏开发人员，通过10个不同类型的游戏实例，展示了真正的游戏设计和实现过程。本书的重点并不在于讲解Unity的各种功能细节，而在于核心玩法的设计和实现思路。每个实例都从一个idea开始，不断丰富，进而自然而然地推出各种概念，引导读者思考必要的数据结构和编程方法。掌握了这些思路，即便换成另外一种引擎，也可以轻松地开发出同类型的游戏。","series":{"id":"660","title":"图灵程序设计丛书"},"price":"79.00元"},{"rating":{"max":10,"numRaters":9,"average":"0.0","min":0},"subtitle":"","author":["阿格佛温"],"pubdate":"2015-3","tags":[{"count":10,"name":"C#","title":"C#"},{"count":6,"name":"多线程","title":"多线程"},{"count":4,"name":".NET","title":".NET"},{"count":3,"name":"计算机","title":"计算机"},{"count":1,"name":"编程","title":"编程"},{"count":1,"name":"架构","title":"架构"},{"count":1,"name":"教材","title":"教材"},{"count":1,"name":"m","title":"m"}],"origin_title":"","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s28258965.jpg","binding":"平装","translator":["黄博文","黄辉兰"],"catalog":"","ebook_url":"https:\/\/read.douban.com\/ebook\/29491940\/","pages":"197","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s28258965.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s28258965.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s28258965.jpg"},"alt":"https:\/\/book.douban.com\/subject\/26574917\/","id":"26574917","publisher":"机械工业出版社","isbn10":"7111493486","isbn13":"9787111493488","title":"C#多线程编程实战","url":"https:\/\/api.douban.com\/v2\/book\/26574917","alt_title":"","author_intro":"","summary":"为了创建这样的应用程序，你需要学习如何在程序中有效地使用多个CPU核心。如果你使用的是Microsoft.NET开发平台以及C#编程语言，那么本书将是一个编写高性能、高响应性的应用程序的完美起点。本书的目的是给你提供C#中多线程以及并行编程的详尽指导。我们将从基本概念开始，每章主题比前一章都有所拔高，最后展示了现实世界中的并行编程模式以及Windows商店应用示例。","ebook_price":"20.00","series":{"id":"12919","title":"华章程序员书库"},"price":"49元"},{"rating":{"max":10,"numRaters":4,"average":"0.0","min":0},"subtitle":"基于ThreadX和ARM","author":["拉姆耶"],"pubdate":"2005-10","tags":[{"count":4,"name":"嵌入式","title":"嵌入式"},{"count":3,"name":"ThreadX","title":"ThreadX"},{"count":2,"name":"计算机","title":"计算机"},{"count":2,"name":"OS","title":"OS"},{"count":2,"name":"Embeded","title":"Embeded"},{"count":1,"name":"linux","title":"linux"}],"origin_title":"","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s5666665.jpg","binding":"简裝本","translator":[],"catalog":"","pages":"328","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s5666665.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s5666665.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s5666665.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1454114\/","id":"1454114","publisher":"北航大学","isbn10":"7810776290","isbn13":"9787810776295","title":"嵌入式实时操作系统的多线程计算","url":"https:\/\/api.douban.com\/v2\/book\/1454114","alt_title":"","author_intro":"","summary":"本书介绍和分析了嵌入式系统的重要概念和应用设计方法，并提供了多个基于ARM平台的多线程应用实例。重点从实时、多线程、ThreadX和ARM处理器结合的角度进行展开，并用实际的案例分析将它们与应用相结合。读者可从中获得完成自己的应用所需的所有细节，包括ARM处理器的概况和ThreadX实时操作系统（RTOS）所提供的所有服务。\n　　本书面向高校计算机专业师生、嵌入式应用的中高级设计开发人员、实时系统的应用与研究人员，也可作为高校计算机及相关专业的嵌入式课程教材。","price":"46.00元"},{"rating":{"max":10,"numRaters":6,"average":"0.0","min":0},"subtitle":"","author":["[黑山共和国]米洛斯 留莫维奇（Milos Ljumovic）"],"pubdate":"2016-5","tags":[{"count":5,"name":"C++","title":"C++"},{"count":3,"name":"多线程","title":"多线程"},{"count":1,"name":"漫步","title":"漫步"},{"count":1,"name":"混口饭吃","title":"混口饭吃"},{"count":1,"name":"教材","title":"教材"}],"origin_title":"C++ Multithreading Cookbook","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28707849.jpg","binding":"平装","translator":["姜佑"],"catalog":"","pages":"320","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s28707849.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s28707849.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28707849.jpg"},"alt":"https:\/\/book.douban.com\/subject\/26789912\/","id":"26789912","publisher":"人民邮电出版社","isbn10":"7115413665","isbn13":"9787115413666","title":"C++多线程编程实战","url":"https:\/\/api.douban.com\/v2\/book\/26789912","alt_title":"C++ Multithreading Cookbook","author_intro":"","summary":"多线程编程领域绝无仅有的实用类C++图书\n掌握C++并发编程技能的必读图书\n涵盖大量源代码\n本书包含以下内容： 使用包含继承、继承和多态的面向对象编程模型； 解决常见的进程间通信问题，避免在开发应用程序中出现死锁和饥饿； 使用CThread类有效地管理线程； 了解.NET CLI\/C++特性，及其同步对象和同步技术； 如何在代码设计中使用并行技术； 如何在并发执行中使用机器资源； 通过消息传递协调程序间的工作； 避免典型的同步问题。","price":"59.00元"},{"rating":{"max":10,"numRaters":1,"average":"0.0","min":0},"subtitle":"","author":["乔林","杨志刚"],"pubdate":"2000-2-1","tags":[{"count":1,"name":"VC","title":"VC"}],"origin_title":"","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s1204977.jpg","binding":"平装(无盘)","translator":[],"catalog":"第1章 按扭控件\n1.1 CButton类和CBitmapButton类\n  1.1.1 CButton类与CBitmapButton类的类声明\n  1.1.2 CButton类与CBitmapButton类的类方法\n  1.1.3 CButton类与CBitmapButton类的按钮样式\n  1.1.4 CButton类与CBitmapButton类的创建与使用\n1.2 设计特殊效果按钮\n  1.2.1设计一个圆形按钮\n  1.2.2设计一个三角形按钮\n  1.2.3设计一个包含图形和文本的按钮\n1.3 程序实例\n1.4小结\n第2章 下拉列表框控件\n2.1设计一个CComboBox颜色拾取器\n2.2扩展CComboColorPicker\n2.3程序实例\n2.4小结\n\n第３章 编辑控件","pages":"447","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s1204977.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s1204977.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s1204977.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1069328\/","id":"1069328","publisher":"中国铁道出版社","isbn10":"7113036570","isbn13":"9787113036577","title":"Visual C++6.0高级编程技术-MFC与多线程篇","url":"https:\/\/api.douban.com\/v2\/book\/1069328","alt_title":"","author_intro":"","summary":"本书是 Visual C＋＋ 6． 0高级编程技术系列丛书之一，讨论如何使用 MFC类库和 VisualC＋＋ 6.0的多线程技术。重点集中在如何扩展MFC类库、如何使用MFC的高级技术开发专仆化的应用程序上。该书结构清晰，内容翔实，各部分均配有程序实例，这些实例可以极大地改进应用程序的外观。\n","price":"45.00"},{"rating":{"max":10,"numRaters":3,"average":"0.0","min":0},"subtitle":"","author":["郝文化"],"pubdate":"2005-10","tags":[{"count":3,"name":"Windows编程","title":"Windows编程"},{"count":1,"name":"多线程","title":"多线程"},{"count":1,"name":"NetWorking","title":"NetWorking"},{"count":1,"name":"(图书馆)","title":"(图书馆)"}],"origin_title":"","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s1539259.jpg","binding":"","translator":[],"catalog":"","pages":"261","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s1539259.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s1539259.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s1539259.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1699685\/","id":"1699685","publisher":"中国水利水电出版社","isbn10":"7508433165","isbn13":"9787508433165","title":"Windows多线程编程技术与实例","url":"https:\/\/api.douban.com\/v2\/book\/1699685","alt_title":"","author_intro":"","summary":"本书通过众多实例介绍了如何实现Windows下的多线程编程，既重点介绍了Win32API下的多线程编程和MFC下的多线程编程，又介绍了多线程机制在网络编程、图形编程和数据库中的应用。本书每一章都从简单的多线程实例出发逐渐深入，紧紧围绕应用程序实例，向读者展示了利用多线程技术来编写高效、友好的Windows应用程序的方法，并对常用的Win32线程函数进行了深入详细的说明。本书共分8章，第l章介绍了多线程编程的基础知识；第2～5章通过实例阐明Win32下多线程的几种不同实现形式及多进程的实现机制，这是本书介绍的重点内容，也是读者学习后面几章内容所必须掌握的基础知识；第6～8章介绍了多线程技术在网络、图形处理和数据库中的应用。\n　　本书语言通俗易懂，内容丰富翔实，突出了以实例为中心的特点，既适合具有一定c++和VC编程基础的高校相关专业学生选作多线程编程的学习用书，也适用于具有一定实际编程经验的中高级开发人员作为学习多线程编程思想的自学用书。","price":"28.00元"},{"rating":{"max":10,"numRaters":4,"average":"0.0","min":0},"subtitle":"","author":[],"pubdate":"","tags":[{"count":1,"name":"java技术","title":"java技术"}],"origin_title":"","image":"https://img1.doubanio.com\/f\/shire\/5522dd1f5b742d1e1394a17f44d590646b63871d\/pics\/book-default-lpic.gif","binding":"","translator":[],"catalog":"","pages":"","images":{"small":"https://img1.doubanio.com\/f\/shire\/5522dd1f5b742d1e1394a17f44d590646b63871d\/pics\/book-default-lpic.gif","large":"https://img1.doubanio.com\/f\/shire\/5522dd1f5b742d1e1394a17f44d590646b63871d\/pics\/book-default-lpic.gif","medium":"https://img1.doubanio.com\/f\/shire\/5522dd1f5b742d1e1394a17f44d590646b63871d\/pics\/book-default-lpic.gif"},"alt":"https:\/\/book.douban.com\/subject\/27001383\/","id":"27001383","publisher":"","isbn10":"7115440360","isbn13":"9787115440365","title":"Java线程与并发编程实践","url":"https:\/\/api.douban.com\/v2\/book\/27001383","alt_title":"","author_intro":"","summary":"","price":""},{"rating":{"max":10,"numRaters":0,"average":"0.0","min":0},"subtitle":"","author":["腾英岩 编"],"pubdate":"2012-8","tags":[],"origin_title":"","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s24964870.jpg","binding":"","translator":[],"catalog":"","pages":"166","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s24964870.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s24964870.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s24964870.jpg"},"alt":"https:\/\/book.douban.com\/subject\/20268231\/","id":"20268231","publisher":"","isbn10":"789436066X","isbn13":"9787894360663","title":"多核多线程技术","url":"https:\/\/api.douban.com\/v2\/book\/20268231","alt_title":"","author_intro":"","summary":"《CDIO工程教育系列教程•计算机软件类•汇博-英特尔系列教材:多核多线程技术》共分四章，各章主要内容如下：第1章简单回顾从流水线、超标量到并行计算对计算能力的提升，详细介绍了多线程技术以及目前多核处理器的架构和多核程序的设计方法。多核程序开发流程为初学者进行多核程序的设计与实现提供了一种有效的方法和思路。第2章系统地介绍了Windows线程库。详细阐述了利用Windows多线程API创建线程、管理线程以及实现线程同步的方法。第3章介绍了OpenMP编程模型的编程方法。包括OpenMP编译环境的搭建，OpenMP编译指导的使用，以及运行时库函数的功能等内容。第4章首先介绍了衡量并行程序性能的指标，以及找到程序瓶颈并改进程序的方法。","price":"50.00元"},{"rating":{"max":10,"numRaters":1,"average":"0.0","min":0},"subtitle":"","author":["Fabio Claudio Ferracchiati","Kourosh Ardestani"],"pubdate":"2002-10-1","tags":[{"count":1,"name":"DotNet","title":"DotNet"}],"origin_title":"","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1326915.jpg","binding":"平装(无盘)","translator":[],"catalog":"第1章 定义线程\n1 线程的定义\n……\n第2章 .NET中的线程\n1 System.Threading命名空间\n……\n第3章 使用线程\n1 为何担心同步\n……\n第4章 设计模式\n1 应用程序中的多线程\n……\n第5章 线程应用程序的伸缩\n1 什么是线程池管理\n……\n第6章 调试与跟踪线程\n1 创建应用程序代码\n……\n第7章 联网与线程\n1 在.NET中的联网\n……\n附录","pages":"248","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s1326915.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s1326915.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1326915.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1101753\/","id":"1101753","publisher":"清华大学","isbn10":"730205925X","isbn13":"9787302059257","title":"Visual Basic.NET线程参考手册","url":"https:\/\/api.douban.com\/v2\/book\/1101753","alt_title":"","author_intro":"","summary":"","price":"32.00"},{"rating":{"max":10,"numRaters":0,"average":"0.0","min":0},"subtitle":"","author":[],"pubdate":"2003-11","tags":[{"count":1,"name":"多线程","title":"多线程"},{"count":1,"name":"c#","title":"c#"}],"origin_title":"","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s25714523.jpg","binding":"","translator":[],"catalog":"","pages":"","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s25714523.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s25714523.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s25714523.jpg"},"alt":"https:\/\/book.douban.com\/subject\/2229760\/","id":"2229760","publisher":"","isbn10":"7302740380","isbn13":"9787302740384","title":"C#线程参考手册","url":"https:\/\/api.douban.com\/v2\/book\/2229760","alt_title":"","author_intro":"","summary":"","price":"33.00元"},{"rating":{"max":10,"numRaters":0,"average":"0.0","min":0},"subtitle":"","author":["\n      "],"pubdate":"2001-01","tags":[{"count":1,"name":"网络编程","title":"网络编程"},{"count":1,"name":"多线程","title":"多线程"},{"count":1,"name":"Java","title":"Java"}],"origin_title":"","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s1035500.jpg","binding":"平装","translator":[],"catalog":"目录\n第一篇Java语言初步\n第1章概述．\n1．1Java的历史\n1．1．l什么是Java\nl．1．2Java带来的影响\nl．l．3Java语言的应用前景\n1．2Java语言的特点\n1．2．1Java是简单的．\n1．2．2Java是面向对象的\n1．2．3Java是静态类型的\n1．2．4JaVa是编译型的\n1．2．5Java是体系结构中立的\n1．2．6Java是健全的\n1．2．7Java是小巧的\n1．2．8Java是多线程的\n1．2．9Java是可收集无用的存储单元的\n1．2．10Java是快速的\n1．2．11Java是安全的\n1．3几种Java语言的开发工具简介\n1．3．1Java如何进行布局管理\n1．3．2Java Workshop 2．0\n1．3．3JBuilder 1.0\n1．3．4VisalAge for Java Enterprise Version 1.0\n1．3．5Visual Cafe for Java Database Development Edition 2.0\n1．4对Java语言的常见误解\n1．4．IJava是HTML的扩充\n1．4．2Java是一种很容易学会的编程语言\n1．4．3Java是一个简单的编程环境\n1．4．4Java将成为所有平台的统一编程语\n1．4．5Java是解释型的，它对于特殊平台的重要应用太慢了\nl。4．6所有的Java程序都在Web页中运行\n1．4．7Java消除了CGI编程的需要\n1．4．8Java将彻底改变客户／服务器计算\n1．4．9使用Java，用户可以用500美元的Internet设备来代替计算机\n1．4．10Java将允许放弃基于部件的计算模式\n1．5简单的Java程序\n第2章Java程序设计基础\n2．1定义常量\n2．1．1常量\n2．1．2整型常量\n2．1．3实型常量\n2．l．4字符型常量\n2．1．5字符串型常量\n2．2定义变量\n2．2．1变量\n2．2．2整型变量\n2．2．3实型变量\n2．2．4字符型变量\n2．2．5布尔型变量\n2．2．6各类数值型数据间的混合运算\n2．3运算符和表达式\n2．3．1算术运算符\n2．3．2关系运算符\n2．3．3布尔逻辑运算符\n2．3．4位运算符\n2．3．5赋值运算符\n2．3．6条件运算符\n2．3．7表达式\n2．4Java流程控制\n\n2．4．1分支语句\n2．4．2循环语句\n第3章Java面向对象程序设计\n3．1面向对象的基本概念\n3．1．1对象\n3．1．2消息\n3．1．3类\n3．2对象及对象的使用\n3．1．1创建对象\n3．2．2引用对象\n3．2．3撤消对象\n3．3类的定义及实现\n3．3．1类说明\n3．3．2类体\n3．4方法的定义和实现\n3．4．l方法的说明\n3．4．2方法体\n3．4．3构造子\n3．4．4析构子\n3．5重用技术\n3．5．1继承\n3．5．2界面\n第4章数组与字符串\n4．l数组\n4．1．1数组的声明及初始化\n4．1．2数组的引用\n4．1．3多维数组\n4．2字符串\n4．2．l不可变字符串\n4．2．2可变字符串\n第5章Java的输入与输出流\n5．1InputStream类\n5．1．1read()方法\n5．1．2available()方法\n5．1．3close()方法\n5．l．4可标记流\n5．1．5skip()方法\n5．2OutputStream类\n5．2．1write()方法\n5．2．2flush()方法\n5．2．3close()方法\n5．3字节数组的输入输出（I／O）\n5．3．1ByteArrayInputStream类\n5．3．2ByteArrayInputStream类\n5．3．3StringBufferInputStream类\n5．4文件输入输出（I／O）\n5．4．1File类\n5．4．2FileDescriptor类\n5．4．3FileInputStream类\n5．4．4FileOutputStream类\n5．5过滤I／O\n5．5．1FilterInputStream类\n5．5．2FilterOuputStream类\n5．5．3缓冲I\/O\n5．5．4数据I\/O\n5．5．5管道I\/O\n5．6随机访问文件\n5．6．1创建随机访问文件\n5．6．2访问信息\n5．6．3增加信息\n5．6．4追加信息例子\n5．7StreamTokenizer类\n5．8URL输入流\n第二篇　IBM VisualAge For Java 3.0程序设计\n第6章VisuaAge　for　Java IDE介绍\n6．1安装IBM VisualAge for Java\n6．1．l运行安装之前\n6．1．2安装步骤\n6．2建立你的第一个Java小程序\n6．2．1创建Java小程序\n6．2．2测试Java小程序\n6．3VisualAge for JavaIDE概述\n\n6．3．1IDE简介\n6．3．2重要概念\n6．4测览VisualAge for Java IDE\n6．4．1工作台窗口\n6．4．2浏览器\n6．4．3VisualAge for Java IDE中的符号\n与快捷键\n6．4．4定制VisualAgeforJavaIDE\n6．4．5IDE失效或工作区毁坏\n6．4．6Applctat览器\n6．4．7查找程序元素\n6．4．8在IDE中打印\n6．4．9访问上下文敏感API帮助\n6．4．10使用快速启动窗口\n6．4．11生成类的HTML文档\n第7章在IDE中开发应用程序\n7．l创建程序和程序元素\n7．1．1创建项目\n7．1．2创建包\n7．1．3Java小程序与Java应用程序\n7．1．4生成类\n7．1．5生成方法存根\n7．1．6创建接口\n7．1．7创建方法\n7．1．8创建字段\n7．1．9生成字段存取方法\n7．1．10编写与格式化源代码\n7．1．11从资源库向工作区添加项目和包\n7．1．12从资源库向工作区添加类和方法\n7．1．13更换工作区的修订版\n7．1．14动态装入外部类\n7．1．15从文件系统导入文件\n7．1．16从另一个资源库中导入\n7．1．17在项目中包含资源文件\n7．2修改程序元素\n7．2．1保存更改的代码\n7．2．2存储工作区\n7．2．3编译代码\n7．2．4查找和修正问题\n7．2．5版本化程序元素\n7．2．6创建开放修订版\n7．2．7从工作区删除程序元素\n7．2．8复制或移动程序元素\n7．2．9重命名程序元素\n7．2．10比较两个程序元素\n7．2．11比较程序元素的修订版\n7．2．12合并类或接日的修订版．\n7．3在代码片段编辑测试窗中组织用户思路\n7．3．1代码片段编辑测试窗\n7．3．2实验代码片段\n7．4管理资源库\n7．4．1备份资源库\n7．4．2从资源库中删除程序元素\n7．4．3恢复程序元素\n7．4．4压缩资源库\n第8章运行和调试程序\n8．1运行程序\n8．1．l在IDE中运行Applet\n8．1．2在IDE中运行应用程序\n8．1．3对Applet作运行时更改\n8．2调试程序\n8．2．1在开发周期中用集成调试器调试\n8．2．2手工启动集成调试器\n8．2．3挂起、恢复和终止线程\n8．2．4在源代码中设置断点\n8．2．5配置并设置断点条件\n8．2．6在外部类中设置断点\n8．2．7选择调试器要捕获的异常\n8．2．8清除并且禁止断点\n8．2．9检查并修改变量值\n8．2．10单步跟踪方法\n8．2．11调试过程中修改代码\n8．2．12在集成调试器中求值表达式\n8．2．13单步执行时监视一个表达式的值\n8．2．14生成类跟踪\n8．2．15设置调试器选项\n8．3导出代码\n8．3．1导出代码\n8．3．2导出字节码\n8．3．3导出资源文件\n8．3．4调试导出\n8．3．5导出到另一个资源库\n第9章异常处理\n9．1异常的概念\n9．1．1采用新的出错处理机制\n9．1．2异常\n9．2异常处理\n9．2．1try／catch块\n9．2．2finally块\n9．2．3try／catch／finally组合使用\n9．3异常类的层次\n9．3．l运行异常\n9．3．2非运行异常\n9．4激反异\n9．5创建自己的异常\n9．5．1定义一个新的异常类\n9．5．2创建程序中的异常\n第10章Java网络编程\n10．l网络基础\n10．1．l计算机网络的概念、特点及功能\n10．1．2网络协议简介\n10．1．3IP地址\n10．2用InetAddress类进行Internet寻址\n10．2．1java．net包\n10．2．2用InetAddress类进行Internet寻址\n10．3用UM类访问网络资源\n10．3．l什么是URL\n10．3．2URL类的创建与地址查询\n10．3．3用URL类访问资源\n10．3．4URL Connection类\n10．3．5AppletContext类\n10．4Java的Socket通讯机制\n10．4．1Socket类\n10．4．2有连接通讯方式的客户／服务器应用工作模式\n10．5Java的数据报通讯机制\n10．5．1数据报简介\n10．5．2数据报方式的通讯过程\n10．5．3数据报的创建\n10．6网络安全措施\n10．6．1网络安全与SecurityManager类\n10．6．2覆盖Security Manager类中的检验方法\n10．6．3安装新的SecurityManager类对象\n第11章多线程程序设计\n11．1线程相关概念\n11．2Java线程的创建\n11．2．l继承Thread父类\n11．2．2实现hanable接日\n11．3线程状态与线程控制\n11．4线程组\n11‘5线程优先级和线程调度\n11．6线程同步和死锁\n第12章图形用户界面构件\n12．1抽象窗口工具集AWT简介\n12．2GUI标准构件的使用方法\n12．2．1Component类提供的方法\n12．2．2添加构件到容器中\n12．2．3改变构件的外观行为\n12．3事件处理机制\n12．3．l键盘事件\n12．3．2鼠标事件\n12．3．3动作（Action）事件\n12．3．4其他事件\n12．4创建用户界面\n12，4．1按钮（Button）\n12．4．2检查盒（Checkbox）\n12．4．3选择框（Choice）\n12．4．4标签（Label）\n12．4．5列表（List）\n12．4．6滚动条（Scrollbar）\n12．4．7文本输入域（TextField ＆TextArea）\n12．4．8框架（Frame）\n12．4．9对话框（Dialog）\n12．5布局控制\n\n12．5．1流控制（FlowLayout）\n12．5．2边界控制（BorderLayout）\n12．5．3栅格控制（GridLayout）\n12．5．4卡片控制（CardLayout）\n12．5．5栅格包控制（GridBagLayout）\n12．6创建和使用菜单．\n12．6．1菜单（Menu）简介\n12．6．2菜单的创建步骤\n12．6．3菜单的事件处理\n12．6．4菜单实例\n第13章图形和图像\n13．1应用components类作图\n13．2应用Graphics类\n13．2．1颜色\n13．2．2作图方法\n13．2．3设置大小\n13．3处理图像\n13．3．l应用MediaTracker\n13．3．2创建脱屏图像板面\n13．3．3producer和consumer\n\n","pages":"344","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s1035500.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s1035500.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s1035500.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1047908\/","id":"1047908","publisher":"北京希望电子出版社","isbn10":"7900056386","isbn13":"9787900056382","title":"网络编程新冲浪Java2.0网络・多线程编程实例教程（含CD）","url":"https:\/\/api.douban.com\/v2\/book\/1047908","alt_title":"","author_intro":"","summary":"Java是Sun公司推出的新一代面向对象程序设计语言，特别适合于Internet应用程序开发。它的跨平台可移植性优势使得 Java语言正如火如茶，风靡计算机世界。而 IBM公司为 Java开发的 VisualAge for Java 30，则以企业的需要为己任，努力实现企业业务的网络化。该开发工具可视化程度较高，编程也极为方便。\n本盘配套书分为两篇，共十三章。第一篇为“Java语言初步”，集中介绍了面向对象编程的基本概念和 Java语言的语法规范。主要内容包括： Java概述、 Java程序设计基础、Java面向对象程序设计、数组与字符串、Java的输入与输出流。第二篇“IBM VsualAge for Java 3．0程序设计”，详细讲解了 IBM VisualAge for Java 3.0开发工具的使用以及 Applet和 Java Application应用程序的编程。主要内容包括： IBM VsualAge for Java IDE介绍、在 IDE中开发应用程序、运行和调试程序、异常处理、 Java网络编程、多线程程序设计、图形用户界面构件、图形和图像。本书还重点介绍了实用性强的网络编程、多线程程序设计和可视化编程基础――图形用户界面（GUI）设计技术。\n本盘配套书内容详实、深入浅出、注重理论与实际的应用，是Java网络开发人员重要的自学指导书，同时也是高等院校相关专业师生教学、自学参考用书和社会相关领域推荐教材。\n本光盘内容包括本版书中的部分实例程序源文件和本版电子书。\n","price":"39.00元"},{"rating":{"max":10,"numRaters":1,"average":"0.0","min":0},"subtitle":"","author":[],"pubdate":"","tags":[],"origin_title":"","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s24991470.jpg","binding":"","translator":[],"catalog":"","pages":"","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s24991470.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s24991470.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s24991470.jpg"},"alt":"https:\/\/book.douban.com\/subject\/2021007\/","id":"2021007","publisher":"","isbn10":"7900031529","isbn13":"9787900031525","title":"SUN 核心技术内幕3-SOLARIS多线程程序设计指南","url":"https:\/\/api.douban.com\/v2\/book\/2021007","alt_title":"","author_intro":"","summary":"","price":"55.00元"},{"rating":{"max":10,"numRaters":3,"average":"0.0","min":0},"subtitle":"","author":["庞永华"],"pubdate":"2019-3","tags":[{"count":7,"name":"Java","title":"Java"},{"count":5,"name":"架构","title":"架构"},{"count":5,"name":"微服务","title":"微服务"},{"count":4,"name":"Socket","title":"Socket"},{"count":1,"name":"java","title":"java"},{"count":1,"name":"IT","title":"IT"}],"origin_title":"","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s32264785.jpg","binding":"平装","translator":[],"catalog":"第1章  多线程基础\n1.1  多线程的概念\n1.1.1  进程与线程\n1.1.2  并发与并行\n1.1.3  线程状态\n1.2  Thread线程类\n1.2.1  基本用法与思考\n1.2.2  常用方法介绍\n1.2.3  wait和sleep的区别\n1.2.4  sleep和yield的区别\n1.3  Runnable接口\n1.4  线程池\n1.4.1  Executors\n1.4.2  ExecutorService\n1.4.3  ThreadPoolExecutor\n1.4.4  基本用法与思考\n1.5  Callable与Future\n1.6  线程安全与效率\n1.6.1  什么是线程安全\n1.6.2  线程同步\n1.6.3  饥饿与公平\n1.6.4  锁与死锁\n1.6.5  线程中断\n1.7  编程进阶\n1.7.1  volatile关键字\n1.7.2  synchronized关键字\n1.7.3  wait\/notify\/notifyAll\n1.7.4  CAS操作\n1.7.5  atomic包\n1.7.6  Lock自旋锁\n1.7.7  Condition条件变量\n1.7.8  线程安全容器\n1.7.9  ThreadLocal类\n1.7.10  CountDownLatch计数器\n1.7.11  CyclicBarrier栅栏\n1.7.12  Semaphore信号量\n1.7.13  fork\/join框架\n第2章  Socket基础\n2.1  TCP与Socket\n2.2  TCP的通信过程\n2.2.1  基本过程\n2.2.2  建立连接\n2.2.3  全双工异步通信\n2.2.4  断开连接\n2.2.5  优雅地断开\n2.2.6  半……连接\n2.3  通信方式\n2.3.1  长连接与短连接\n2.3.2  线程模型\n2.3.3  拆包与组包\n2.3.4  断包与粘包\n2.3.5  数据包的结构\n2.4  BIO\n2.4.1  典型编程模型\n2.4.2  关键API概述\n2.4.3  字符流传输\n2.4.4  字节流传输\n2.4.5  传输多笔数据\n2.5  NIO\n2.5.1  NIO简介\n2.5.2  Buffer\n2.5.3  Channel\n2.5.4  Selector\n2.5.5  Scatter\/Gather\n2.5.6  Pipe\n2.5.7  内存映像文件\n2.5.8  文件传输示例\n2.5.9  “聊天室”示例\n2.6  AIO\n2.6.1  AIO简介\n2.6.2  关键API概述\n2.6.3  示例代码\n第3章  Spring与Spring Cloud\n3.1  Spring简介\n3.2  IoC容器\n3.2.1  IoC的概念\n3.2.2  Spring中的bean\n3.2.3  XML配置方式\n3.2.4  注解配置方式\n3.2.5  用Java类来配置\n3.2.6  BeanFactory与FactoryBean\n3.2.7  ApplicationContext与ApplicationContextAware\n3.2.8  动态注册bean配置\n3.2.9  ApplicationListener与容器事件\n3.3  bean的基本配置\n3.3.1  scope属性\n3.3.2  parent与abstract\n3.3.3  factory-bean与factory-method\n3.3.4  bean的初始化与释放\n3.4  依赖注入\n3.4.1  setter注入\n3.4.2  工厂方式注入\n3.4.3  构造器注入\n3.4.4  注解注入\n3.5  Spring Boot\n3.5.1  快速创建工程\n3.5.2  编码与测试\n3.5.3  打包部署\n3.5.4  辅助开发工具\n3.5.5  监控功能\n3.6  Spring Cloud\n3.6.1  Spring Cloud简介\n3.6.2  架构设计\n3.6.3  创建应用\n3.6.4  服务的注册与发现\n3.6.5  服务配置\n3.6.6  Ribbon负载均衡\n3.6.7  Feign服务调用\n3.6.8  Hystrix\n3.6.9  Zuul服务路由\n3.6.10  服务监控\n第4章  动态代理\n4.1  代理模式\n4.2  静态代理\n4.3  类的装载\n4.4  Java反射\n4.5  JDK动态代理\n4.6  CGLIB动态代理\n4.7  Java Compiler API\n4.8  Javassist动态代理\n第5章  对象序列化\n5.1  什么是序列化\n5.2  Java序列化\n5.2.1  基本用法\n5.2.2  关于serialVersionUID\n5.2.3  自定义序列化\n5.2.4  封装实现代码\n5.3  Hessian序列化\n5.4  Kryo序列化\n5.5  FST序列化\n5.6  其他序列化组件\n5.7  集成与扩展\n5.7.1  优雅地集成\n5.7.2  使用Java SPI\n5.7.3  使用Spring\n第6章  框架设计\n6.1  总体结构\n6.1.1  逻辑架构\n6.1.2  框架设计概述\n6.1.3  RPC原理\n6.1.4  工程结构\n6.1.5  依赖的jar包\n6.1.6  主要的类\n6.2  初始化过程\n6.2.1  Spring配置\n6.2.2  应用节点的启动\n6.2.3  Web容器的启动\n6.2.4  RpcCore的初始化\n6.2.5  RpcContext的初始化\n6.3  服务的暴露\n6.3.1  服务暴露配置\n6.3.2  方法配置与ID\n6.3.3  内置的服务方法\n6.3.4  服务提供方本地调用器\n6.3.5  服务提供方代理生成器\n6.3.6  注册要暴露的服务\n6.4  服务的引用\n6.4.1  服务引用配置\n6.4.2  本地引用工厂类\n6.4.3  注册本地引用工厂\n6.4.4  本地引用与方法ID\n6.5  服务的注册与发现\n6.5.1  注册表集合\n6.5.2  注册表的同步\n6.5.3  注册表的解析\n6.5.4  提交注册表\n6.5.5  注册表推送\n6.5.6  注册表检查\n6.6  优雅地停机\n6.6.1  停机的过程\n6.6.2  停机钩子\n6.6.3  监听Web容器的关闭\n6.6.4  RpcCore的关闭\n6.6.5  停机通知的处理\n第7章  方法调用\n7.1  方法调用类型\n7.2  同步调用\n7.2.1  同步调用的时序\n7.2.2  同步调用的发起\n7.2.3  负载均衡\n7.2.4  指定服务提供者\n7.2.5  失败转移\n7.2.6  发送调用请求\n7.2.7  处理调用请求\n7.2.8  处理调用响应\n7.3  异步调用\n7.3.1  异步调用的时序\n7.3.2  异步调用的发起\n7.3.3  异步调用的执行\n7.3.4  方法调用对象\n7.4  同步\/异步通知\n7.5  异步回调\n7.6  广播调用与广播通知\n7.6.1  广播示例\n7.6.2  广播代码\n第8章  通信层实现\n8.1  Socket通信框架\n8.1.1  Netty与Mina\n8.1.2  为什么要自己写\n8.1.3  是NIO还是AIO\n8.1.4  设计思路\n8.1.5  实际结构\n8.2  通信协议\n8.2.1  传输对象\n8.2.2  数据包结构\n8.2.3  拆包与发送\n8.2.4  接收并组包\n8.3  连接的建立\n8.3.1  工作模型\n8.3.2  开始监听\n8.3.3  发起连接\n8.3.4  绑定连接\n8.3.5  断线检测\n第9章  性能测试与调优\n9.1  性能调优概述\n9.1.1  性能指标\n9.1.2  性能瓶颈\n9.1.3  环境因素\n9.2  压力测试\n9.2.1  测试方法\n9.2.2  场景设计\n9.2.3  测试环境\n9.2.4  Dubbo配置\n9.2.5  测试程序\n9.3  线程池调优\n9.3.1  调整线程池的大小\n9.3.2  选择合适的队列\n9.3.3  线程的管理逻辑\n9.3.4  选择拒绝策略\n9.4  优化线程同步\n9.4.1  减少上下文切换\n9.4.2  避免线程滥用\n9.4.3  避免过多的锁\n9.4.4  synchronized VS Lock\n9.4.5  缩小锁的范围和粒度\n9.4.6  线程分析工具\n9.5  JVM调优\n9.5.1  堆与栈\n9.5.2  JVM内存的分代\n9.5.3  GC分类\n9.5.4  GC算法\n9.5.5  分代GC\n9.5.6  对象的引用\n9.5.7  内存大小设置\n9.5.8  内存调优工具\n9.6  其他优化内容\n9.6.1  避免使用反射\n9.6.2  对象池\n9.6.3  缓冲区队列\n9.6.4  使用直接内存\n9.6.5  缓存其他对象\n9.6.6  协调与平衡\n第10章  服务治理\n10.1  服务治理概述\n10.1.1  什么是服务治理\n10.1.2  服务治理架构\n10.1.3  服务治理接口\n10.2  服务的定义\n10.2.1  服务识别\n10.2.2  接口定义\n10.2.3  版本管理\n10.2.4  协议适配\n10.2.5  服务设计\n10.2.6  服务的实现\n10.2.7  依赖关系管理\n10.3  服务的部署\n10.3.1  服务的部署方式\n10.3.2  自动化部署\n10.3.3  服务的热部署\n10.4  注册与发现\n10.4.1  WSDL与UDDI\n10.4.2  ZooKeeper的方案\n10.4.3  Eureka的方案\n10.4.4  Consul的方案\n10.4.5  etcd的方案\n10.4.6  注册中心集成方案\n10.5  服务的控制\n10.5.1  服务状态\n10.5.2  服务控制\n10.5.3  服务开关\n10.5.4  服务模拟\n10.5.5  黑白名单\n10.5.6  “踢除”服务提供者\n10.6  监控与限流\n10.6.1  TPS监控与限流\n10.6.2  响应时间的监控\n10.6.3  调用链的监控\n10.6.4  资源监控","pages":"452","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s32264785.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s32264785.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s32264785.jpg"},"alt":"https:\/\/book.douban.com\/subject\/32976350\/","id":"32976350","publisher":"电子工业出版社","isbn10":"7121360357","isbn13":"9787121360350","title":"Java多线程与Socket：实战微服务框架","url":"https:\/\/api.douban.com\/v2\/book\/32976350","alt_title":"","author_intro":"IBM高级咨询架构师，拥有16年以上各种类型软件系统的开发经验。擅长分布式与微服务架构的设计和开发。","summary":"本书从实战角度出发，首先介绍Java多线程、Socket、Spring、动态代理、动态字节码、序列化等技术在构建分布式微服务框架中的应用。然后介绍一种微服务框架的架构设计与编程实践，并将这一微服务框架分解为底层Socket通信、服务注册与发现、服务暴露与引用、远程方法调用等层面，逐一深入讲解。这里重点介绍作者如何活用相关技术一步步地构建微服务框架的基础RPC框架并分享了相应的性能调优经验。最后介绍微服务架构中配套的服务治理系统的设计与实现方案，包括服务的设计、配置、管理与监控。","price":"99.00元"},{"rating":{"max":10,"numRaters":0,"average":"0.0","min":0},"subtitle":"","author":["[美]易格恩·阿格佛温"],"pubdate":"2017-2-1","tags":[{"count":1,"name":"编程","title":"编程"},{"count":1,"name":"C#","title":"C#"}],"origin_title":"Multithreading with C# Cookbook Second Edition","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s33507098.jpg","binding":"平装","translator":[],"catalog":"译者序\n前言\n本书内容\n准备事项\n读者对象\n下载示例代码\n第1章 线程基础\n1.1 简介\n1.2 使用C#创建线程\n1.3 暂停线程\n1.4 线程等待\n1.5 终止线程\n1.6 检测线程状态\n1.7 线程优先级\n1.8 前台线程和后台线程\n1.9 向线程传递参数\n1.10 使用C#中的lock关键字\n1.11 使用Monitor类锁定资源\n\n1.12 处理异常\n第2章 线程同步\n2.1 简介\n\n2.2 执行基本的原子操作\n\n2.3 使用Mutex类\n\n2.4 使用SemaphoreSlim类\n\n2.5 使用AutoResetEvent类\n\n2.6 使用ManualResetEventSlim类\n\n2.7 使用CountDownEvent类\n\n2.8 使用Barrier类\n\n2.9 使用ReaderWriterLockSlim类\n\n2.10 使用SpinWait类\n第3章 使用线程池\n3.1 简介\n3.2 在线程池中调用委托\n3.3 向线程池中放入异步操作\n3.4 线程池与并行度\n3.5 实现一个取消选项\n\n3.6 在线程池中使用等待事件处理器及超时\n\n3.7 使用计时器\n\n3.8 使用BackgroundWorker组件\n第4章 使用任务并行库\n4.1 简介\n\n4.2 创建任务\n\n4.3 使用任务执行基本的操作\n\n4.4 组合任务\n\n4.5 将APM模式转换为任务\n\n4.6 将EAP模式转换为任务\n\n4.7 实现取消选项\n\n4.8 处理任务中的异常\n\n4.9 并行运行任务\n\n4.10 使用TaskScheduler配置任务的执行\n第5章 使用C#6.0\n5.1 简介\n\n5.2 使用await操作符获取异步任务结果\n\n5.3 在lambda表达式中使用await操作符\n\n5.4 对连续的异步任务使用await操作符\n\n5.5 对并行执行的异步任务使用await操作符\n\n5.6 处理异步操作中的异常\n\n5.7 避免使用捕获的同步上下文\n\n5.8 使用async void方法\n\n5.9 设计一个自定义的awaitable类型\n\n5.10 对动态类型使用await\n第6章 使用并发集合\n6.1 简介\n\n6.2 使用ConcurrentDictionary\n\n6.3 使用ConcurrentQueue实现异步处理\n\n6.4 改变ConcurrentStack异步处理顺序\n\n6.5 使用ConcurrentBag创建一个可扩展的爬虫\n\n6.6 使用BlockingCollection进行异步处理\n第7章 使用PLINQ\n7.1 简介\n\n7.2 使用Parallel类\n\n7.3 并行化LINQ查询\n\n7.4 调整PLINQ查询的参数\n\n7.5 处理PLINQ查询中的异常\n\n7.6 管理PLINQ查询中的数据分区\n\n7.7 为PLINQ查询创建一个自定义的聚合器\n第8章 使用Reactive Extensions\n8.1 简介\n\n8.2 将普通集合转换为异步的可观察集合\n\n8.3 编写自定义的可观察对象\n\n8.3.1 准备工作\n\n8.3.2 实现方式\n\n8.3.3 工作原理\n\n8.4 使用Subject\n\n8.5 创建可观察的对象\n\n8.6 对可观察的集合使用LINQ查询\n\n8.7 使用Rx创建异步操作\n第9章 使用异步I\/O\n9.1 简介\n\n9.2 异步地使用文件\n\n9.3 编写一个异步的HTTP服务器和客户端\n\n9.4 异步操作数据库\n\n9.5 异步调用WCF服务\n第10章 并行编程模式\n10.1 简介\n\n10.2 实现惰性求值的共享状态\n\n10.3 使用BlockingCollection实现并行管道\n\n10.4 使用TPL数据流实现并行管道\n\n10.5 使用PLINQ实现Map\/Reduce模式\n第11章 更多信息\n11.1 简介\n11.2 在通用Windows平台应用中使用计时器\n\n11.3 在通常的应用程序中使用WinRT\n\n11.4 在通用Windows平台应用中使用BackgroundTask\n\n11.5 在OS X上运行.NET内核应用程序\n\n11.6 在Ubuntu Linux上运行.NET内核应用程序","pages":"","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s33507098.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s33507098.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s33507098.jpg"},"alt":"https:\/\/book.douban.com\/subject\/30361879\/","id":"30361879","publisher":"机械工业出版社","isbn10":"7111561023","isbn13":"9787111561026","title":"C#多线程编程实战(原书第2版)","url":"https:\/\/api.douban.com\/v2\/book\/30361879","alt_title":"Multithreading with C# Cookbook Second Edition","author_intro":"","summary":"为了创建这样的应用程序，你需要学习如何在程序中有效地使用多个CPU核心。如果你使用的是Microsoft.NET开发平台以及C#编程语言，那么本书将是一个编写高性能、高响应性的应用程序的完美起点。本书的目的是给你提供C#中多线程以及并行编程的详尽指导。我们将从基本概念开始，每章主题比前一章都有所拔高，后展示了现实世界中的并行编程模式以及Windows商店应用示例。 为了创建这样的应用程序，你需要学习如何在程序中有效地使用多个CPU核心。如果你使用的是Microsoft.NET发平台以及C#编程语言，那么本书将是一个编写高性能、高响应性的应用程序的完美起。本书的目的是给你提供C#中多线程以及并行编程的详尽指导。我们将从基本概念始，每章主题比前一章都有所拔高，后展示了现实世界中的并行编程模式以及Windows商店应用示例。","price":""},{"rating":{"max":10,"numRaters":0,"average":"0.0","min":0},"subtitle":"","author":["【美】Kay Robbins","Steve Robbins"],"pubdate":"2018-5","tags":[{"count":5,"name":"并发","title":"并发"},{"count":4,"name":"计算机","title":"计算机"},{"count":4,"name":"编程","title":"编程"},{"count":3,"name":"UNIX","title":"UNIX"},{"count":1,"name":"好书","title":"好书"},{"count":1,"name":"lib","title":"lib"},{"count":1,"name":"akb","title":"akb"},{"count":1,"name":"Linux\/Unix","title":"Linux\/Unix"}],"origin_title":"","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s29776916.jpg","binding":"平装","translator":["师蓉"],"catalog":"第一部分  基础知识\n第1章    技术对程序的影响  3\n1.1  术语的变化  3\n1.2  时间和速度  5\n1.3  多道程序设计和分时  6\n1.4  应用层的并发  8\n1.4.1  中断  8\n1.4.2  信号  9\n1.4.3  输入和输出  10\n1.4.4  进程、线程和资源共享  10\n1.4.5  具有共享内存的多个处理器  11\n1.4.6  网络作为计算机  11\n1.5  安全和容错  12\n1.6  非法入侵造成的缓冲区溢出  13\n1.6.1  缓冲区溢出的后果  14\n1.6.2  缓冲区溢出和安全  16\n1.7  UNIX标准  17\n1.8  延伸阅读  19\n第2章    程序、线程和进程  21\n2.1  程序是如何成为进程的  21\n2.2  线程和执行线程  22\n2.3  程序映象的布局  23\n2.4  库函数调用  26\n2.5  函数返回值和错误  29\n2.6  参数数组  31\n2.6.1  用makeargv函数创建一个数组  32\n2.6.2  makeargv函数的实现  34\n2.7  线程安全函数  38\n2.8  静态变量的使用  40\n2.9  静态对象的结构  42\n2.10  进程环境  48\n2.11  进程终止  51\n2.12  练习：一个env实用程序  54\n2.13  练习：消息日志  55\n2.14  延伸阅读  57\n第3章    UNIX中的进程  58\n3.1  进程标识符  58\n3.2  进程状态  60\n3.3  UNIX 进程创建和fork函数  63\n3.4  wait函数  70\n状态值  76\n3.5  exec函数  77\n3.6  后台进程和守护进程  83\n3.7  临界区  86\n3.8  练习：进程链  87\n3.9  练习：进程扇  88\n3.10  延伸阅读  89\n第4章    UNIX I\/O  90\n4.1  设备术语  90\n4.2  读\/写  91\n4.3  打开和关闭文件  102\n4.4  select函数  107\n4.5  poll函数  116\n4.6  文件表示  119\n4.6.1  文件描述符  119\n4.6.2  文件指针和缓冲  122\n4.6.3  文件描述符的继承  124\n4.7  过滤器和重定向  128\n4.8  文件控制  132\n4.9  练习：原子日志  135\n原子日志库  139\n4.10  练习：cat实用程序  141\n4.11  延伸阅读  143\n第5章    文件和目录  144\n5.1  UNIX文件系统导航  144\n5.1.1  当前工作目录  145\n5.1.2  搜索路径  150\n5.2  目录访问  151\n5.2.1  访问文件状态信息  153\n5.2.2  确定文件的类型  156\n5.3  UNIX文件系统实现  157\n5.3.1  UNIX文件实现  158\n5.3.2  目录实现  161\n5.4  硬链接和符号链接  161\n5.4.1  创建或删除一个链接  162\n5.4.2  创建和删除符号链接  167\n5.5  练习：which命令  172\n5.6  练习：邮件通知程序  173\n5.7  练习：新闻通知程序  176\n5.8  练习：遍历目录  177\n5.9  延伸阅读  179\n第6章    UNIX特殊文件  180\n6.1  管道  180\n6.2  流水线  184\n6.3  FIFO  189\n6.4  管道与客户机-服务器模型  193\n6.5  终端控制  200\n规范和非规范的输入处理  208\n6.6  音频设备  212\n6.7  练习：音频  218\n6.8  练习：屏障  220\n6.9  练习：stty命令  221\n6.10  练习：重提客户机-服务器  222\n6.11  延伸阅读  222\n第7章    项目：令牌环  224\n7.1  环形拓扑  224\n7.2  环的形成  226\n7.3  环的探讨  232\n7.4  简单通信  234\n7.5  用令牌环实现互斥  235\n7.6  用投票实现互斥  237\n7.7  匿名环中的领导者选举  238\n7.8  用于通信的令牌环  240\n7.9  流水线预处理机  242\n7.10  并行环算法  244\n7.10.1  图像过滤  244\n7.10.2  矩阵乘法  247\n7.11  弹性环  248\n7.12  延伸阅读  249\n第二部分  异步事件\n第8章    信号  253\n8.1  信号的基本概念  253\n8.2  信号的产生  254\n8.3  对信号掩码和信号集进行操作  259\n8.4  捕获和忽略信号—sigaction  266\n8.5  等待信号—pause、sigsuspend和sigwait  272\n8.5.1  pause函数  272\n8.5.2  sigsuspend函数  274\n8.5.3  sigwait函数  282\n8.6  处理信号：错误和异步信号安全  283\n8.7  用siglongjmp和sigsetjmp进行程序控制  286\n8.8  使用异步I\/O编程  288\n8.9  练习：转储统计  300\n8.10  练习：同时处理慢速设备  301\n8.11  延伸阅读  301\n第9章    时间和定时器  303\n9.1  POSIX时间  303\n9.1.1  用从Epoch开始的秒数表示时间  304\n9.1.2  显示日期和时间  305\n9.1.3  使用struct timeval表示时间  308\n9.1.4  使用实时时钟  311\n9.1.5  耗时和处理器时间的对比  313\n9.2  睡眠函数  316\n9.3  POSIX:XSI间隔定时器  319\n9.4  实时信号  323\n9.5  POSIX:TMR间隔定时器  328\n9.6  定时器漂移、溢出和绝对时间  333\n9.7  延伸阅读  344\n第10章    项目：虚拟定时器  345\n10.1  项目概述  345\n10.2  简单的定时器  348\n10.3  对5个定时器中的一个进行设置  351\n10.3.1  virtualtimers对象  351\n10.3.2  hardwaretimer对象  353\n10.3.3  主程序实现  354\n10.3.4  用show谱写定时器代码  355\n10.4  使用多个定时器  361\n10.4.1  设置多个定时器  364\n10.4.2  用多个定时器进行测试  365\n10.5  多定时器的健壮实现  369\n10.6  POSIX:TMR定时器的实现  371\n10.7  一个小型的cron工具mycron  372\n10.8  延伸阅读  372\n第11章    项目：破解shell  373\n11.1  构建一个简单的shell  373\n11.2  重定向  378\n11.3  流水线  382\n11.4  前台的信号处理  385\n11.5  进程组、会话和控制终端  391\n11.5.1  进程组  391\n11.5.2  会话  393\n11.6  ush中的后台进程  396\n11.7  作业控制  403\n11.8  ush的作业控制  407\n11.8.1  一个作业列表对象  407\n11.8.2  ush中的作业列表  409\n11.8.3  ush中的作业控制  409\n11.8.4  等待流水线时的进程行为  410\n11.9  延伸阅读  411\n第三部分  并  发\n第12章    POSIX线程  415\n12.1  监视文件描述符的方法  415\n12.2  使用线程监视多个文件描述符  417\n12.3  线程管理  420\n12.3.1  用ID引用线程  421\n12.3.2  创建一个线程  422\n12.3.3  分离和连接  423\n12.3.4  退出和取消  426\n12.3.5  向线程传递参数并返回值  429\n12.4  线程安全  438\n12.5  用户级线程 VS 内核级线程  439\n12.6  线程属性  442\n12.6.1  线程状态  443\n12.6.2  线程栈  444\n12.6.3  线程调度  446\n12.7  练习：并行文件复制  450\n12.8  延伸阅读  451\n第13章  线程同步  452\n13.1  POSIX同步函数  452\n13.2  互斥锁  453\n13.2.1  创建并初始化一个互斥量  454\n13.2.2  销毁一个互斥量  455\n13.2.3  锁定和解锁互斥量  456\n13.2.4  保护不安全的库函数  458\n13.2.5  同步标志和全局值  459\n13.2.6  让数据结构成为线程安全的  465\n13.3  最多一次和至少一次的执行  467\n13.4  条件变量  471\n13.4.1  条件变量的创建和销毁  473\n13.4.2  等待并通知条件变量  475\n13.5  信号处理和线程  478\n13.5.1  将信号定向到一个特定的线程中  479\n13.5.2  为线程屏蔽信号  480\n13.5.3  信号处理的专用线程  480\n13.6  读者和写者  484\n13.7  strerror_r实现  489\n13.8  死锁和其他讨厌的问题  491\n13.9  练习：多个屏障  492\n13.10  延伸阅读  492\n第14章  临界区和信号量  493\n14.1  临界区的处理  493\n14.2  信号量  496\n14.3  POSIX:SEM匿名信号量  499\n14.4  POSIX:SEM信号量操作  501\n14.5  POSIX:SEM命名信号量  508\n14.5.1  创建并打开命名信号量  509\n14.5.2  关闭信号量并删除其链接  512\n14.6  练习：许可管理器  514\n14.6.1  license对象  515\n14.6.2  runsim主程序  515\n14.6.3  对许可管理器的扩展  516\n14.7  延伸阅读  516\n第15章  POSIX IPC  517\n15.1  POSIX:XSI进程间通信  517\n15.1.1  标识并访问IPC对象  518\n15.1.2  在shell中访问POSIX:XSI IPC资源  519\n15.2  POSIX:XSI信号量集  520\n15.2.1  信号量的创建  521\n15.2.2  信号量的控制  523\n15.2.3  POSIX信号量集操作  525\n15.3  POSIX:XSI共享内存  532\n15.3.1  访问共享内存段  532\n15.3.2  共享内存段的连接和分离  533\n15.3.3  控制共享内存  534\n15.3.4  共享内存示例  535\n15.4  POSIX:XSI消息队列  541\n访问消息队列  542\n15.5  练习：POSIX匿名信号量  549\n15.6  练习：POSIX命名信号量  550\n15.7  练习：用共享内存实现管道  551\n15.8  练习：用消息队列实现管道  554\n15.9  延伸阅读  554\n第16章  项目：生产者-消费者同步  555\n16.1  生产者-消费者问题  555\n16.2  受互斥锁保护的有界缓冲区  557\n16.3  使用信号量的缓冲区实现  560\n16.4  一个简单的生产者-消费者问题简介  566\n16.5  使用条件变量的有界缓冲区  570\n16.6  带有完成条件的缓冲区  571\n16.7  并行文件复制  580\n16.7.1  并行文件复制的生产者  580\n16.7.2  并行文件复制的消费者  581\n16.7.3  并行文件复制的main程序  582\n16.7.4  并行文件复制的增强  582\n16.8  线程化打印服务器  583\n16.8.1  请求缓冲区  584\n16.8.2  生产者线程  585\n16.8.3  消费者线程  586\n16.8.4  打印服务器  586\n16.8.5  其他增强功能  586\n16.9  延伸阅读  587\n第17章  项目：非完全并行虚拟机  588\n17.1  PVM的历史、术语和结构  588\n17.2  非完全并行虚拟机  591\n17.3  NTPVM项目概述  593\n17.3.1  NEWTASK分组  596\n17.3.2  DATA分组  596\n17.3.3  DONE分组  597\n17.4  调度程序的I\/O和测试  598\n17.4.1  用多个窗口测试  604\n17.4.2  用远程日志测试  605\n17.5  没有输入的单任务  607\n17.6  顺序任务  608\n17.6.1  输入线程  609\n17.6.2  输出线程  610\n17.7  并发任务  611\n17.8  分组通信、广播和屏障  611\n17.9  终止和信号  612\n17.10  有序的消息传递  613\n17.11  延伸阅读  613\n第四部分  通  信\n第18章  面向连接的通信  617\n18.1  客户机-服务器模型  617\n18.2  通信信道  618\n18.3  面向连接的服务器策略  622\n18.4  通用因特网通信接口（UICI）  625\n18.4.1  处理错误  627\n18.4.2  读和写  627\n18.5  不同服务器策略的UICI实现  628\n18.6  UICI客户机  631\n18.7  UICI的套接字实现  637\n18.7.1  socket函数  638\n18.7.2  bind函数  639\n18.7.3  listen函数  641\n18.7.4  u_open函数的实现  642\n18.7.5  accept函数  643\n18.7.6  u_accept函数的实现  645\n18.7.7  connect函数  646\n18.7.8  u_connect函数的实现  647\n18.8  主机名和IP地址  649\n18.9  线程安全的UICI  658\n18.10  练习：ping服务器  661\n18.11  练习：音频的传输  662\n18.12  延伸阅读  664\n第19章  项目：WWW重定向  665\n19.1  万维网  665\n19.2  统一资源定位符（URL）   666\n19.3  HTTP入门  668\n19.3.1  客户端请求  669\n19.3.2  服务器响应  669\n19.3.3  HTTP消息交换  670\n19.4  Web通信模式  673\n19.4.1  隧道  673\n19.4.2  代理  674\n19.4.3  高速缓存和透明性  676\n19.4.4  网关  678\n19.5  单连接的通过型监控  679\n19.6  隧道服务器的实现  682\n19.7  用于测试的服务器驱动程序  682\n19.8  HTTP头解析  684\n19.9  简单的代理服务器  686\n19.10  代理监视器  688\n19.11  代理高速缓存  691\n19.12  门户网站的网关  692\n19.13  用于负载平衡的网关  692\n19.14  事后的调查分析  693\n19.14.1  线程和计时错误  693\n19.14.2  未捕获的错误和错误的退出  694\n19.14.3  书写风格和表示  695\n19.14.4  糟糕的测试和结果表示  696\n19.14.5  编程错误和不好的风格  697\n19.15  延伸阅读  698\n第20章  无连接通信和多播  699\n20.1  无连接通信简介  699\n20.2  无连接通信的简化接口  701\n20.2.1  主机名和u_buf_t结构  703\n20.2.2  UICI UDP的返回错误  703\n20.2.3  UDP缓冲区大小和UICI UDP  703\n20.3  简单-请求协议  704\n20.4  请求-应答协议  710\n20.5  有超时和重试的请求-应答  716\n20.6  请求-应答-确认协议  722\n20.7  UICI UDP的实现  723\n20.7.1  u_openudp函数的实现  723\n20.7.2  sendto函数  725\n20.7.3  u_sendto和 u_sendtohost函数的实现  726\n20.7.4  recvfrom函数  727\n20.7.5  u_recvfrom和u_recvfromtimed函数的实现  728\n20.7.6  主机名和u_buf_t  730\n20.8  UDP和TCP的比较  732\n20.9  多播  733\n20.9.1  多播寻址  733\n20.9.2  u_join函数的实现  735\n20.9.3  u_leave函数的实现  736\n20.10  练习：UDP端口服务器  737\n20.11  练习：无状态文件服务器  738\n远程文件服务  739\n20.12  延伸阅读  740\n第21章  项目：互联网广播  741\n21.1  项目概述  741\n21.2  音频设备模拟  744\n21.3  具有一个节目和一个接收者的UDP实现  744\n21.3.1  简单实现  744\n21.3.2  接收者的终止  747\n21.3.3  接收者缓冲来处理网络延迟  748\n21.3.4  接收者缓冲来处理乱序传递  751\n21.4  具有多个节目和接收者的UDP实现  754\n21.4.1  多个节目和单个接收者  754\n21.4.2  多个节目和多个接收者  755\n21.5  音频广播的UDP实现  756\n21.6  无线电广播的多播实现  758\n21.7  TCP实现的差异  758\n21.7.1  单个节目和单个接收者的TCP实现  759\n21.7.2  多个节目和单个接收者的TCP实现  760\n21.7.3  无线电广播的TCP实现  761\n21.8  通过浏览器接收流式音频  764\n21.8.1  使用浏览器助手应用程序  764\n21.8.2  在你的Web服务器中设置一种新的mime类型  765\n21.8.3  设置你的浏览器来处理新的mime类型  766\n21.8.4  创建Web页面  766\n21.8.5  使用预定义的mime类型  767\n21.9  延伸阅读  767\n第22章  项目：服务器性能  769\n22.1  服务器性能成本  769\n22.2  服务器架构  770\n22.3  项目概述  774\n22.4  单客户端驱动程序  775\n22.4.1  处理一个连接  775\n22.4.2  对响应进行编程  776\n22.4.3  收集统计信息  777\n22.4.4  测试客户端  777\n22.5  多客户端驱动程序  778\n另一种多客户端设计  781\n22.6  实现每个请求一个线程和每个请求一个进程  781\n22.7  线程工作者池策略  782\n22.8  使用有界缓冲区的多线程工作者池  782\n22.9  进程工作者池  783\n22.10  磁盘I\/O的影响  783\n22.11  性能研究  787\n22.11.1  基线测量  787\n22.11.2  波动性的根源  788\n22.11.3  测量错误  789\n22.11.4  同步  792\n22.11.5  普通的错误  793\n22.11.6  要测量什么  794\n22.11.7  数据分析和表示  796\n22.12  报告撰写  797\n22.12.1  引言  797\n22.12.2  设计、实现和测试  798\n22.12.3  实验  798\n22.12.4  结果和分析  799\n22.12.5  结论  799\n22.12.6  参考文献  799\n22.13  延伸阅读  800\n附录A  UNIX基础  801\n附录B  重启库  819\n附录C  UICI实现  829\n附录D  日志函数  846\n附录E  POSIX扩展  864\n参考文献  867","pages":"896","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s29776916.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s29776916.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s29776916.jpg"},"alt":"https:\/\/book.douban.com\/subject\/30231496\/","id":"30231496","publisher":"电子工业出版社","isbn10":"7121340356","isbn13":"9787121340352","title":"UNIX系统编程: 通信、并发与线程","url":"https:\/\/api.douban.com\/v2\/book\/30231496","alt_title":"","author_intro":"Kay Robbins 和 Steve Robbins，是美国麻省理工学院博士，现任德州大学圣安东尼奥分校计算机科学系讲师。《UNIX系统编程: 通信、并发与线程》（UNIX Systems Programming: Communication, Concurrency and Threads）是他们的代表作。\n译者师蓉，译有《完美Java（第6版）》、《信息架构：大型网站Web设计（第4版）》《像富人一样思考》《故事场景摩天楼》《互联网领导思维》《断点:互联网进化启示录》《Unity 3.x游戏开发实例》《iPhone应用用户体验设计实战与案例》《社交网站界面设计》等书。","summary":"《UNIX系统编程: 通信、并发与线程》是一本基于最新UNIX标准的完备的参考书，对UNIX编程的要点进行了清晰易懂的介绍，从一些用于说明如何使用系统调用的短小代码段开始，逐渐过渡到能帮助读者扩展自己技能水平的实际项目中。《UNIX系统编程: 通信、并发与线程》中对通信、并发和线程问题进行了深入探讨，对复杂的概念（如信号和并发）进行了全面且清晰的解释，还覆盖了与文件、信号、信号量、POSIX线程和客户机-服务器通信相关的内容。《UNIX系统编程: 通信、并发与线程》中不仅提供了大量实例和练习，还专门设计了有针对性的项目并给出了参考答案。本书分为4部分，每部分都包含主题章节和项目章节。《UNIX系统编程: 通信、并发与线程》在\"第一部分：基础知识”中介绍了UNIX操作系统的基础知识，包括文件、进程和特殊文件等；\"第二部分：异步事件”主要介绍了信号和定时器；\"第三部分：并发”主要介绍了信号量和进程同步的相关内容；\"第四部分：通信”则主要介绍通信的相关话题。其中，\"第一部分：基础知识”是本书其余部分的基础，读者在阅读完第一部分后，就可以以任意顺序阅读本书其他部分的相关内容。","price":"198"},{"rating":{"max":10,"numRaters":0,"average":"0.0","min":0},"subtitle":"一线程序员撰写，凝聚自己多年开发经验，系统且深入阐释Django开发涉及的方法和实践","author":["李健"],"pubdate":"2018-11","tags":[{"count":1,"name":"Django","title":"Django"}],"origin_title":"","image":"https://img1.doubanio.com\/f\/shire\/5522dd1f5b742d1e1394a17f44d590646b63871d\/pics\/book-default-lpic.gif","binding":"平装","translator":[],"catalog":"","pages":"","images":{"small":"https://img1.doubanio.com\/f\/shire\/5522dd1f5b742d1e1394a17f44d590646b63871d\/pics\/book-default-lpic.gif","large":"https://img1.doubanio.com\/f\/shire\/5522dd1f5b742d1e1394a17f44d590646b63871d\/pics\/book-default-lpic.gif","medium":"https://img1.doubanio.com\/f\/shire\/5522dd1f5b742d1e1394a17f44d590646b63871d\/pics\/book-default-lpic.gif"},"alt":"https:\/\/book.douban.com\/subject\/30474621\/","id":"30474621","publisher":"清华大学出版社","isbn10":"7302513554","isbn13":"9787302513551","title":"Django 2.0 入门与实践","url":"https:\/\/api.douban.com\/v2\/book\/30474621","alt_title":"","author_intro":"","summary":"《Django 2.0 入门与实践》从Web开发初学者的角度出发，循序渐进地讲解Django的相关技术，包括Python语言入门知识、Web相关基础技术，如HTML、CSS、JavaScript，通过《Django 2.0 入门与实践》前两部分的学习，读者可以基本掌握Python语言的应用以及Web相关技术。*后在Django讲解部分针对每一项技术点都编写了实例代码，通过理论与实践相结合的方式对Django开发框架进行讲解。《Django 2.0 入门与实践》内容由浅入深详尽地讲解Django框架的各项知识点，使任何层级的读者都能从中受益；每个技术点都有示例代码，以理论与实践相结合的方式使读者快速理解Django框架；包含基本Web技术介绍，是一本非常适合读者的工具书。 《Django 2.0 入门与实践》可供Web开发初中级读者以及希望使用Python作为编程语言的软件开发工程师参考。","price":"79"},{"rating":{"max":10,"numRaters":11,"average":"8.1","min":0},"subtitle":"A POSIX Standard for Better Multiprocessing","author":["Bradford Nichols","Dick Buttlar","Jacqueline Proulx Farrell"],"pubdate":"1996-9-8","tags":[{"count":17,"name":"Pthreads","title":"Pthreads"},{"count":12,"name":"多线程","title":"多线程"},{"count":8,"name":"并行","title":"并行"},{"count":8,"name":"GNU\/Linux","title":"GNU\/Linux"},{"count":7,"name":"线程","title":"线程"},{"count":6,"name":"计算机","title":"计算机"},{"count":5,"name":"multithreads","title":"multithreads"},{"count":3,"name":"并行程序设计","title":"并行程序设计"}],"origin_title":"","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s26012039.jpg","binding":"Paperback","translator":[],"catalog":"","pages":"286","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s26012039.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s26012039.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s26012039.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1867081\/","id":"1867081","publisher":"O'Reilly Media","isbn10":"1565921151","isbn13":"9781565921153","title":"Pthreads Programming","url":"https:\/\/api.douban.com\/v2\/book\/1867081","alt_title":"","author_intro":"","summary":"POSIX threads, or pthreads, allow multiple tasks to run concurrently within the same program. They can share a single CPU as processes do, or take advantage of multiple CPUs when available. In either case, they provide a clean way to divide the tasks of a program while sharing data. This book thoroughly covers the POSIX threads standard, which is supported by the Distributed Computer Environment (DCE), as well as Solaris, OSF\/1, AIX, and several other UNIX-based operating systems. In this book you will learn not only what the pthread calls are, but when it is a good idea to use threads and how to make them efficient (which is the whole reason for using threads in the first place). The authors delves into performance issues, comparing threads to processes, contrasting kernel threads to user threads, and showing how to measure speed. He also clearly describes all the advanced features and how threads interact with the rest of the UNIX system.","price":"USD 39.99"},{"rating":{"max":10,"numRaters":11,"average":"7.2","min":0},"subtitle":"","author":["Scott Oaks","Henry Wong"],"pubdate":"2004-9-20","tags":[{"count":27,"name":"Java","title":"Java"},{"count":12,"name":"多线程","title":"多线程"},{"count":7,"name":"并发","title":"并发"},{"count":5,"name":"threading","title":"threading"},{"count":4,"name":"计算机","title":"计算机"},{"count":4,"name":"concurrency","title":"concurrency"},{"count":4,"name":"Programming","title":"Programming"},{"count":3,"name":"软件开发","title":"软件开发"}],"origin_title":"","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s27298974.jpg","binding":"Paperback","translator":[],"catalog":"","pages":"362","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s27298974.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s27298974.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s27298974.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1756553\/","id":"1756553","publisher":"O'Reilly Media","isbn10":"0596007825","isbn13":"9780596007829","title":"Java Threads","url":"https:\/\/api.douban.com\/v2\/book\/1756553","alt_title":"","author_intro":"","summary":"Threads are essential to Java programming, but learning to use them effectively is a nontrivial task. This new edition of the classic Java Threads shows you how to take full advantage of Java's threading facilities and brings you up-to-date with the watershed changes in Java 2 Standard Edition version 5.0 (J2SE 5.0). It provides a thorough, step-by-step approach to threads programming. Java's threading system is simple relative to other threading systems. In earlier versions of Java, this simplicity came with tradeoffs: some of the advanced features in other threading systems were not available in Java. J2SE 5.0 changes all that: it provides a large number of new thread-related classes that make the task of writing multithreaded programs that much easier. You'll learn where to use threads to increase efficiency, how to use them effectively, and how to avoid common mistakes. This book discusses problems like deadlock, race conditions, and starvation in detail, helping you to write code without hidden bugs. Java Threads, Third Edition, has been thoroughly expanded and revised. It incorporates the concurrency utilities from java.util.concurrent throughout. New chapters cover thread performance, using threads with Swing, threads and Collection classes, thread pools, and threads and I\/O (traditional, new, and interrupted). Developers who cannot yet deploy J2SE 5.0 can use thread utilities provided in the Appendix to achieve similar functionality with earlier versions of Java. Topics include: Lock starvation and deadlock detection; Atomic classes and minimal synchronization (J2SE 5.0); Interaction of Java threads with Swing, I\/O, and Collection classes; Programmatically controlled locks and condition variables (J2SE 5.0); Thread performance and security; Thread pools (J2SE 5.0); Thread groups; Platform-specific thread scheduling; Task schedulers (J2SE 5.0); Parallelizing loops for multiprocessor machines In short, this new edition of Java Threads covers everything you need to know about threads, from the simplest animation program to the most complex applications. If you plan to do any serious work in Java, you will find this book invaluable.","price":"USD 39.95"},{"rating":{"max":10,"numRaters":7,"average":"0.0","min":0},"subtitle":"","author":["Paul Hyde"],"pubdate":"1999-08-20","tags":[{"count":9,"name":"JAVA","title":"JAVA"},{"count":7,"name":"多线程","title":"多线程"},{"count":3,"name":"线程","title":"线程"},{"count":3,"name":"Thread","title":"Thread"},{"count":2,"name":"并发","title":"并发"},{"count":2,"name":"programming","title":"programming"},{"count":1,"name":"软件开发","title":"软件开发"},{"count":1,"name":"java","title":"java"}],"origin_title":"","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s1797539.jpg","binding":"Paperback","translator":[],"catalog":"","pages":"528","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s1797539.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s1797539.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s1797539.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1864049\/","id":"1864049","publisher":"Sams","isbn10":"0672315858","isbn13":"9780672315855","title":"Java Thread Programming","url":"https:\/\/api.douban.com\/v2\/book\/1864049","alt_title":"","author_intro":"","summary":"<HTML>Java Thread Programming shows you how to take full advantage of Java's thread facilities: when to use threads to increase your program's efficiency, how to use them effectively, and how to avoid common mistakes. There is thorough coverage of the Thread API, ThreadGroup classes, the Runnable interface, and the synchronized operator. Extensive, complete, code examples show programmers the details of creating and managing threads in real-world applications.<\/HTML>","price":"USD 39.99"},{"rating":{"max":10,"numRaters":1,"average":"0.0","min":0},"subtitle":"","author":["Bil Lewis","Daniel J. Berg","Sun Microsystems Press"],"pubdate":"1997-12-19","tags":[{"count":3,"name":"线程","title":"线程"},{"count":3,"name":"multithreads","title":"multithreads"},{"count":2,"name":"programming","title":"programming"},{"count":1,"name":"软件开发","title":"软件开发"},{"count":1,"name":"计算机","title":"计算机"},{"count":1,"name":"编程","title":"编程"},{"count":1,"name":"并行程序设计","title":"并行程序设计"},{"count":1,"name":"并行","title":"并行"}],"origin_title":"","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s2762475.jpg","binding":"Paperback","translator":[],"catalog":"","pages":"432","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s2762475.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s2762475.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s2762475.jpg"},"alt":"https:\/\/book.douban.com\/subject\/2301620\/","id":"2301620","publisher":"Prentice Hall","isbn10":"0136807291","isbn13":"9780136807292","title":"Multithreaded Programming With PThreads","url":"https:\/\/api.douban.com\/v2\/book\/2301620","alt_title":"","author_intro":"","summary":"","price":"USD 34.95"},{"rating":{"max":10,"numRaters":0,"average":"0.0","min":0},"subtitle":"","author":["Hollub, Allen"],"pubdate":"","tags":[{"count":4,"name":"Java","title":"Java"},{"count":3,"name":"多线程","title":"多线程"},{"count":2,"name":"编程","title":"编程"},{"count":1,"name":"线程","title":"线程"},{"count":1,"name":"分布式","title":"分布式"}],"origin_title":"","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s3330507.jpg","binding":"Pap","translator":[],"catalog":"","pages":"300","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s3330507.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s3330507.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s3330507.jpg"},"alt":"https:\/\/book.douban.com\/subject\/2695916\/","id":"2695916","publisher":"Springer-Verlag New York Inc","isbn10":"1893115100","isbn13":"9781893115101","title":"Taming Java Threads","url":"https:\/\/api.douban.com\/v2\/book\/2695916","alt_title":"","author_intro":"","summary":"","price":"389.71元"}]}
