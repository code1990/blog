>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java编程思想 （第4版）
读者评论
前言
简介
第1章 对象导论
1.1 抽象过程
1.2 每个对象都有一个接口
1.3 每个对象都提供服务
1.4 被隐藏的具体实现
1.5 复用具体实现
1.6 继承
1.6.1 “是一个”（is-a）与“像是一个”（is-like-a）关系
1.7 伴随多态的可互换对象
1.8 单根继承结构
1.9 容器
1.9.1 参数化类型（范型）
1.10 对象的创建和生命期
1.11 异常处理：处理错误
1.12 并发编程
1.13 Java与Internet
1.13.1 Web是什么
1.13.2 客户端编程
1.13.3 服务器端编程
1.22 总结
第2章 一切都是对象
2.1 用引用操纵对象
2.2 必须由你创建所有对象
2.2.1 存储到什么地方
2.2.2 特例：基本类型
2.2.3 Java中的数组
2.3 永远不需要销毁对象
2.3.1 作用域
2.3.2 对象的作用域
2.4 创建新的数据类型：类
2.4.1 域和方法
2.4.2 基本成员默认值
2.5 方法、参数和返回值
2.5.1 参数列表
2.6 构建一个Java程序
2.6.1 名字可见性
2.6.2 运用其他构件
2.6.3 static 关键字
2.7 你的第一个Java程序
编译和运行
2.8 注释和嵌入式文档
2.8.1 注释文档
2.8.2 语法
2.8.3 嵌入式HTML
2.8.4 一些标签示例
2.8.5 文档示例
2.9 编码风格
2.10 总结
2.11 练习
第3章 操作符
3.1 更简单的打印语句
3.2 使用Java操作符
3.3 优先级
3.4 赋值
3.4.1 方法调用中的别名问题
3.5 算术操作符
3.5.1 一元加、减操作符
3.6 自动递增和递减
3.7 关系操作符
3.7.1 测试对象的等价性
3.8 逻辑操作符
3.8.1 短路
3.9 直接常量
3.9.1 指数记数法
3.10 按位操作符
3.11 移位操作符
3.12 三元操作符 if-else
3.13 字符串操作符 + 和 +=
3.14 使用操作符时常犯的错误
3.15 类型转换操作符
3.15.1 截尾和舍入
3.15.2提升
3.16 Java没有“sizeof”
3.17 操作符小结
3.18 总结
第4章 控制执行流程
4.1 true和false
4.2 if-else
4.3 迭代
4.3.1 do-while
4.3.2 for
4.3.3 逗号操作符
4.4 Foreach语法
4.5 return
4.6 break和 continue
4.7 臭名昭著的“goto”
4.8 switch
4.9 总结
第5章 初始化与清理
5.1 用构造器确保初始化
5.2 方法重载
5.2.1 区分重载方法
5.2.2 涉及基本类型的重载
5.2.3 以返回值区分重载方法
5.3 缺省构造器
5.4 this关键字
5.4.1 在构造器中调用构造器
5.4.2 static的含义
5.5 清理：终结处理和垃圾回收
5.5.1 finalize()的用途何在
5.5.2 你必须实施清理
5.5.3 终结条件
5.5.4 垃圾回收器如何工作
5.6 成员初始化
5.6.1 指定初始化
5.7 构造器初始化
5.7.1 初始化顺序
5.7.2. 静态数据的初始化
5.7.3. 显式的静态初始化
5.7.4. 非静态实例初始化
5.8 数组初始化
5.8.1 可变参数列表
5.9 枚举类型
5.10 总结
第6章 访问权限控制
第7章 复用类
第8章 多态
第9章 接口
第10章 内部类
第11章 持有对象
第12章 通过异常处理错误
第13章 字符串
第14章 类型信息
第15章 泛型
第16章 数组
第17章 容器深入研究
第18章 Java I/O系统
第19章 枚举类型
第20章 注解
第21章 并发
第22章 图形化用户界面
附录A 补充材料
可下载的补充材料
Thinking in C：Java的基础
Java编程思想 研讨课
Hands-on Java研讨课CD
Thinking in Objects研讨课
Thinking in Enterprise Java
Thinking in Patterns(with Java)
Thinking in Patterns研讨课
设计咨询与复审
附录B 资源
软件
编辑器与IDE
书籍
分析与设计
Python
我的著作列表
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java编程思想 （第4版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java并发编程实战
对本书的赞誉
译者序
前　言
第1章　简介1
1.1　并发简史1
1.2　线程的优势2
1.2.1　发挥多处理器的强大能力2
1.2.2　建模的简单性3
1.2.3　异步事件的简化处理3
1.2.4　响应更灵敏的用户界面4
1.3　线程带来的风险4
1.3.1　安全性问题5
1.3.2　活跃性问题7
1.3.3　性能问题7
1.4　线程无处不在7
第一部分　基础知识
第2章　线程安全性11
2.1　什么是线程安全性13
2.2　原子性14
2.2.1　竞态条件15
2.2.2　示例：延迟初始化中的竞态条件16
2.2.3　复合操作17
2.3　加锁机制18
2.3.1　内置锁20
2.3.2　重入21
2.4　用锁来保护状态22
2.5　活跃性与性能23
第3章　对象的共享27
3.1　可见性27
3.1.1　失效数据28
3.1.2　非原子的64位操作29
3.1.3　加锁与可见性30
3.1.4　Volatile变量 30
3.2　发布与逸出32
3.3　线程封闭35
3.3.1　Ad-hoc线程封闭35
3.3.2　栈封闭36
3.3.3　ThreadLocal类37
3.4　不变性38
3.4.1　Final域39
3.4.2　示例：使用Volatile类型来发布不可变对象40
3.5　安全发布41
3.5.1　不正确的发布：正确的对象被破坏42
3.5.2 　不可变对象与初始化安全性42
3.5.3　安全发布的常用模式43
3.5.4　事实不可变对象44
3.5.5　可变对象44
3.5.6　安全地共享对象44
第4章　对象的组合46
4.1　设计线程安全的类46
4.1.1　收集同步需求47
4.1.2　依赖状态的操作48
4.1.3　状态的所有权48
4.2　实例封闭49
4.2.1　Java监视器模式51
4.2.2　示例：车辆追踪51
4.3　线程安全性的委托53
4.3.1　示例：基于委托的车辆追踪器54
4.3.2　独立的状态变量55
4.3.3　当委托失效时56
4.3.4　发布底层的状态变量57
4.3.5　示例：发布状态的车辆追踪器58
4.4　在现有的线程安全类中添加功能59
4.4.1　客户端加锁机制60
4.4.2　组合62
4.5　将同步策略文档化62
第5章　基础构建模块66
5.1　同步容器类66
5.1.1　同步容器类的问题66
5.1.2　迭代器与Concurrent-ModificationException68
5.1.3　隐藏迭代器69
5.2　并发容器70
5.2.1　ConcurrentHashMap71
5.2.2　额外的原子Map操作72
5.2.3　CopyOnWriteArrayList72
5.3　阻塞队列和生产者-消费者模式73
5.3.1　示例：桌面搜索75
5.3.2　串行线程封闭76
5.3.3　双端队列与工作密取77
5.4　阻塞方法与中断方法77
5.5　同步工具类78
5.5.1　闭锁79
5.5.2　FutureTask80
5.5.3　信号量82
5.5.4　栅栏83
5.6　构建高效且可伸缩的结果缓存85
第二部分　结构化并发应用程序
第6章　任务执行93
6.1　在线程中执行任务93
6.1.1　串行地执行任务94
6.1.2　显式地为任务创建线程94
6.1.3　无限制创建线程的不足95
6.2　Executor框架96
6.2.1　示例：基于Executor的Web服务器97
6.2.2　执行策略98
6.2.3　线程池98
6.2.4　Executor的生命周期99
6.2.5　延迟任务与周期任务101
6.3　找出可利用的并行性102
6.3.1　示例：串行的页面渲染器102
6.3.2　携带结果的任务Callable与Future103
6.3.3　示例：使用Future实现页面渲染器104
6.3.4　在异构任务并行化中存在的局限106
6.3.5　CompletionService:Executor与BlockingQueue106
6.3.6　示例：使用CompletionService实现页面渲染器107
6.3.7　为任务设置时限108
6.3.8　示例：旅行预定门户网站109
第7章　取消与关闭111
7.1　任务取消111
7.1.1　中断113
7.1.2　中断策略116
7.1.3　响应中断117
7.1.4　示例：计时运行118
7.1.5　通过Future来实现取消120
7.1.6　处理不可中断的阻塞121
7.1.7　采用newTaskFor来封装非标准的取消122
7.2　停止基于线程的服务124
7.2.1　示例：日志服务124
7.2.2　关闭ExecutorService127
7.2.3　“毒丸”对象128
7.2.4　示例：只执行一次的服务129
7.2.5　shutdownNow的局限性130
7.3　处理非正常的线程终止132
7.4　JVM关闭135
7.4.1　关闭钩子135
7.4.2　守护线程136
7.4.3　终结器136
第8章　线程池的使用138
8.1　在任务与执行策略之间的隐性耦合138
8.1.1　线程饥饿死锁139
8.1.2　运行时间较长的任务140
8.2　设置线程池的大小140
8.3　配置ThreadPoolExecutor141
8.3.1　线程的创建与销毁142
8.3.2　管理队列任务142
8.3.3　饱和策略144
8.3.4　线程工厂146
8.3.5　在调用构造函数后再定制ThreadPoolExecutor147
8.4　扩展 ThreadPoolExecutor148
8.5　递归算法的并行化149
第9章　图形用户界面应用程序156
9.1　为什么GUI是单线程的156
9.1.1　串行事件处理157
9.1.2　Swing中的线程封闭机制158
9.2　短时间的GUI任务160
9.3　长时间的GUI任务161
9.3.1　取消162
9.3.2　进度标识和完成标识163
9.3.3　SwingWorker165
9.4　共享数据模型165
9.4.1　线程安全的数据模型166
9.4.2　分解数据模型166
9.5　其他形式的单线程子系统167
第三部分　活跃性、性能与测试
第10章　避免活跃性危险169
10.1　死锁169
10.1.1　锁顺序死锁170
10.1.2　动态的锁顺序死锁171
10.1.3　在协作对象之间发生的死锁174
10.1.4　开放调用175
10.1.5　资源死锁177
10.2　死锁的避免与诊断178
10.2.1　支持定时的锁178
10.2.2　通过线程转储信息来分析死锁178
10.3　其他活跃性危险180
10.3.1　饥饿180
10.3.2　糟糕的响应性181
10.3.3　活锁181
第11章　性能与可伸缩性183
11.1　对性能的思考183
11.1.1　性能与可伸缩性184
11.1.2　评估各种性能权衡因素185
11.2　Amdahl定律186
11.2.1　示例：在各种框架中隐藏的串行部分188
11.2.2　Amdahl定律的应用189
11.3　线程引入的开销189
11.3.1　上下文切换190
11.3.2　内存同步190
11.3.3　阻塞192
11.4　减少锁的竞争192
11.4.1　缩小锁的范围（“快进快出”）193
11.4.2　减小锁的粒度195
11.4.3　锁分段196
11.4.4　避免热点域197
11.4.5　一些替代独占锁的方法198
11.4.6　监测CPU的利用率199
11.4.7　向对象池说“不”200
11.5　示例：比较Map的性能200
11.6　减少上下文切换的开销201
第12章　并发程序的测试204
12.1　正确性测试205
12.1.1　基本的单元测试206
12.1.2　对阻塞操作的测试207
12.1.3　安全性测试208
12.1.4　资源管理的测试212
12.1.5　使用回调213
12.1.6　产生更多的交替操作214
12.2　性能测试215
12.2.1　在PutTakeTest中增加计时功能215
12.2.2　多种算法的比较217
12.2.3　响应性衡量218
12.3　避免性能测试的陷阱220
12.3.1　垃圾回收220
12.3.2　动态编译220
12.3.3　对代码路径的不真实采样222
12.3.4　不真实的竞争程度222
12.3.5　无用代码的消除223
12.4　其他的测试方法224
12.4.1　代码审查224
12.4.2　静态分析工具224
12.4.3　面向方面的测试技术226
12.4.4　分析与监测工具226
第四部分　高级主题
第13章　显式锁227
13.1　Lock与 ReentrantLock227
13.1.1　轮询锁与定时锁228
13.1.2　可中断的锁获取操作230
13.1.3　非块结构的加锁231
13.2　性能考虑因素231
13.3　公平性232
13.4　在synchronized和ReentrantLock之间进行选择234
13.5　读-写锁235
第14章　构建自定义的同步工具238
14.1　状态依赖性的管理238
14.1.1　示例：将前提条件的失败传递给调用者240
14.1.2　示例：通过轮询与休眠来实现简单的阻塞241
14.1.3　条件队列243
14.2　使用条件队列244
14.2.1　条件谓词244
14.2.2　过早唤醒245
14.2.3　丢失的信号246
14.2.4　通知247
14.2.5　示例：阀门类248
14.2.6　子类的安全问题249
14.2.7　封装条件队列250
14.2.8　入口协议与出口协议250
14.3　显式的Condition对象251
14.4　Synchronizer剖析253
14.5　AbstractQueuedSynchronizer254
14.6　java.util.concurrent同步器类中的 AQS257
14.6.1　ReentrantLock257
14.6.2　Semaphore与CountDownLatch258
14.6.3　FutureTask259
14.6.4　ReentrantReadWriteLock259
第15章　原子变量与非阻塞同步机制261
15.1　锁的劣势261
15.2　硬件对并发的支持262
15.2.1　比较并交换263
15.2.2　非阻塞的计数器264
15.2.3　JVM对CAS的支持265
15.3　原子变量类265
15.3.1　原子变量是一种“更好的volatile”266
15.3.2　性能比较：锁与原子变量267
15.4　非阻塞算法270
15.4.1　非阻塞的栈270
15.4.2　非阻塞的链表272
15.4.3　原子的域更新器274
15.4.4　ABA问题275
第16章　Java内存模型277
16.1　什么是内存模型，为什么需要它277
16.1.1　平台的内存模型278
16.1.2　重排序278
16.1.3　Java内存模型简介280
16.1.4　借助同步281
16.2　发布283
16.2.1　不安全的发布283
16.2.2　安全的发布284
16.2.3　安全初始化模式284
16.2.4　双重检查加锁286
16.3　初始化过程中的安全性287
附录A　并发性标注289
参考文献291
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java并发编程实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构与算法分析
译者序
前言
第1章 引论
1.1 本书讨论的内容
1.2 数学知识复习
1.2.1 指数
1.2.2 对数
1.2.3 级数
1.2.4 模运算
1.2.5 证明的方法
1.3 递归简论
1.4 实现泛型特性构件pre-Java5
1.4.1 使用Object表示泛型
1.4.2 基本类型的包装
1.4.3 使用接口类型表示泛型
1.4.4 数组类型的兼容性
1.5 利用Java5泛性实现泛型特性成分
1.5.1 简单的泛型类和接口
1.5.2 自动装箱/拆箱
1.5.3 带有限制的通配符
1.5.4 泛型static方法
1.5.5 类型限界
1.5.6 类型擦除
1.5.7 对于泛型的限制
1.6 函数对象
小结
练习
参考文献
第2章 算法分析
2.1 数学基础
2.2 模型
2.3 要分析的问题
2.4 运行时间计算
2.4.1 一个简单的例子
2.4.2 一般法则
2.4.3 最大子序列和问题的求解
2.4.4 运行时间中的对数
2.4.5 检验你的分析
2.4.6 分析结果的准确性
小结
练习
参考文献
第3章 表、栈和队列
3.1 抽象数据类型
3.2 表ADT
3.2.1 表的简单数组实现
3.2.2 简单链表
3.3 Java Collections API中的表
3.3.1 Collection接口
3.3.2 Iterator接口
3.3.3 List接口、ArrayList类和LinkedList类
3.3.4 例：remove方法对LinkedList类的使用
3.3.5 关于ListIterator接口
3.4 ArrayList类的实现
3.4.1 基本类
3.4.2 迭代器、Java嵌套类和内部类
3.5 Linked List类的实现
3.6 栈ADT
3.6.1 栈模型
3.6.2 栈的实现
3.6.3 应用
3.7 队列ADT
3.7.1 队列模型
3.7.2 队列的数组实现
3.7.3 队列的应用
小结
练习
第4章 树
4.1 预备知识
4.1.1 树的实现
4.1.2 树的遍历及应用
4.2 二叉树
4.2.1 实现
4.2.2 例子：表达式树
4.3 查找树ADT——二叉查找树
4.3.1 contains方法
4.3.2 findMin方法和findMax方法
4.3.3 insert方法
4.3.4 remove方法
4.3.5 平均情况分析
4.4 AVL树
4.4.1 单旋转
4.4.2 双旋转
4.5 伸展树
4.5.1 一个简单的想法（不能直接使用）
4.5.2 展开
4.6 树的遍历
4.7 B树
4.8 标准库中的集合与映射
4.8.1 关于Set接口
4.8.2 关于Map接口
4.8.3 TreeSet类和TreeMap类的实现
4.8.4 使用多个映射的例
小结
练习
参考文献
第5章 散列
5.1 一般想法
5.2 散列函数
5.3 分离链接法
5.4 不用链表的散列表
5.4.1 线性探测法
5.4.2 平方探测法
5.4.3 双散列
5.5 再散列
5.6 标准库中的散列表
5.7 可扩散列
小结
练习
参考文献
第6章 优先队列（堆）
6.1 模型
6.2 一些简单的实现
6.3 二叉堆
6.3.1 结构性质
6.3.2 堆序性质
6.3.3 基本的堆操作
6.3.4 其他的堆操作
6.4 优先队列的应用
6.4.1 选择问题
6.4.2 事件模拟
6.5 d-堆
6.6 左式堆
6.6.1 左式堆性质
6.6.2 左式堆操作
6.7 斜堆
6.8 二项队列
6.8.1 二项队列结构
6.8.2 二项队列操作
6.8.3 二项队列的实现
6.9 标准库中的优先队列
小结
练习
参考文献
第7章 排序
7.1 预备知识
7.2 插入排序
7.2.1 算法
7.2.2 插入排序的分析
7.3 一些简单排序算法的下界
7.4 希尔排序
7.5 堆排序
7.6 归并排序
7.7 快速排序
7.7.1 选取枢纽元
7.7.2 分割策略
7.7.3 小数组
7.7.4 实际的快速排序例程
7.7.5 快速排序的分析
7.7.6 选择问题的线性期望时间算法
7.8 排序算法的一般下界
7.9 桶式排序
7.10 外部排序
7.10.1 为什么需要一些新的算法
7.10.2 外部排序模型
7.10.3 简单算法
7.10.4 多路合并
7.10.5 多相合并
7.10.6 替换选择
小结
练习题
参考文献
第8章 不相交集类
8.1 等价关系
8.2 动态等价性问题
8.3 基本数据结构
8.4 灵巧求并算法
8.5 路径压缩
8.6 路径压缩和按秩求并的最坏情形
8.7 一个应用
小结
练习题
参考文献
第9章 图论算法
9.1 若干定义
9.2 拓扑排序
9.3 最短路径算法
9.3.1 无权最短路径
9.3.2 Dijkstra算法
9.3.3 具有负边值的图
9.3.4 无圈图
9.3.5 所有点对最短路径
9.3.6 最短路径的例子
9.4 网络流问题
9.5 最小生成树
9.5.1 Prim算法
9.5.2 Kruskal算法
9.6 深度优先搜索的应用
9.6.1 无向图
9.6.2 双连通性
9.6.3 欧拉回路
9.6.4 有向图
9.6.5 查找强分支
9.7 NP完全性介绍
9.7.1 难与易
9.7.2 NP类
9.7.3 NP完全问题
小结
练习
参考文献
第10章 算法设计技巧
10.1 贪婪算法
10.1.1 一个简单的调度问题
10.1.2 哈夫曼编码
10.1.3 近似装箱问题
10.2 分治算法
10.2.1 分治算法的运行时间
10.2.2 最近点问题
10.2.3 选择问题
10.2.4 一些算术问题的理论改进
10.3 动态规划
10.3.1 用一个表代替递归
10.3.2 矩阵乘法的顺序安排
10.3.3 最优二叉查找树
10.3.4 所有点对最短路径
10.4 随机化算法
10.4.1 随机数发生器
10.4.2 跳跃表
10.4.3 素性测试
10.5 回溯算法
10.5.1 收费公路重建问题
10.5.2 博弈
小结
练习
参考文献
第11章 摊还分析
11.1 一个无关的智力问题
11.2 二项队列
11.3 斜堆
11.4 斐波那契堆
11.4.1 切除左式堆中的节点
11.4.2 二项队列的懒惰合并
11.4.3 斐波那契堆操作
11.4.4 时间界的证明
11.5 伸展树
小结
练习
参考文献
第12章 高级数据结构及其实现
12.1 自顶向下伸展树
12.2 红黑树
12.2.1 自底向上的插入
12.2.2 自顶向下红黑树
12.2.3 自顶向下的删除
12.3 确定性跳跃表
12.4 AA树
12.5 treap树
12.6 k-d树
12.7 配对堆
小结
练习
参考文献
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构与算法分析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java性能优化权威指南
第1章　策略、方法和方法论　　1
1.1 　性能问题的现状　　1
1.2 　性能分析的两种方法：自顶向下和自底向上　　4
1.2.1 　自顶向下　　4
1.2.2 　自底向上　　5
1.3 　选择正确的平台并评估系统性能　　5
1.3.1 　选择正确的CPU架构　　6
1.3.2 　评估系统性能　　7
1.4 　参考资料　　7
第2章　操作系统性能监控　　8
2.1 　定义　　8
2.2 　CPU使用率　　9
2.2.1 　监控CPU使用率：Windows　　9
2.2.2 　监控CPU使用率：Windows typeperf　　12
2.2.3 　监控CPU使用率：Linux　　13
2.2.4 　监控CPU使用率：Solaris　　14
2.2.5 　命令行监控CPU使用率：Linux和Solaris　　16
2.3 　CPU调度程序运行队列　　19
2.3.1 　监控CPU调度程序运行队列：Windows　　19
2.3.2 　监控CPU调度程序运行队列：Solaris　　21
2.3.3 　监控CPU调度程序运行队列：Linux　　21
2.4 　内存使用率　　22
2.4.1 　监控内存利用率：Windows　　22
2.4.2 　监控内存使用率：Solaris　　23
2.4.3 　监控内存使用率：Linux　　24
2.4.4 　监控锁竞争：Solaris　　25
2.4.5 　监控锁竞争：Linux　　26
2.4.6 　监控锁竞争：Windows　　27
2.4.7 　隔离竞争锁　　27
2.4.8 　监控抢占式上下文切换　　27
2.4.9 　监控线程迁移　　28
2.5 　网络I/O使用率　　28
2.5.1 　监控网络I/O使用率：Solaris　　29
2.5.2 　监控网络I/O使用率：Linux　　30
2.5.3 　监控网络I/O使用率：Windows　　30
2.5.4 　应用性能改进的考虑　　31
2.6 　磁盘I/O使用率　　31
2.7 　其他命令行工具　　34
2.8 　监控CPU使用率：SPARC T系列系统　　35
2.9 　参考资料　　36
第3章　JVM概览　　38
3.1 　HotSpot VM的基本架构　　38
3.2 　HotSpot VM运行时　　40
3.2.1 　命令行选项　　40
3.2.2 　VM生命周期　　41
3.2.3 　VM类加载　　44
3.2.4 　字节码验证　　46
3.2.5 　类数据共享　　47
3.2.6 　解释器　　48
3.2.7 　异常处理　　49
3.2.8 　同步　　50
3.2.9 　线程管理　　51
3.2.10 　C++堆管理　　53
3.2.11 　Java本地接口　　54
3.2.12 　VM致命错误处理　　55
3.3 　HotSpot VM垃圾收集器　　56
3.3.1 　分代垃圾收集　　56
3.3.2 　新生代　　58
3.3.3 　快速内存分配　　60
3.3.4 　垃圾收集器　　60
3.3.5 　Serial收集器　　61
3.3.6 　Parallel收集器：吞吐量为先！　　62
3.3.7　　Mostly-Concurrent收集器：低延迟为先！　　62
3.3.8　　Garbage-First收集器：CMS替代者　　64
3.3.9 　垃圾收集器比较　　64
3.3.10 　应用程序对垃圾收集器的影响　　65
3.3.11 　简单回顾收集器历史　　65
3.4 　HotSpot VM JIT编译器　　65
3.4.1 　类型继承关系分析　　67
3.4.2 　编译策略　　67
3.4.3 　逆优化　　68
3.4.4 　Client JIT编译器概览　　69
3.4.5 　Server JIT编译器概览　　69
3.4.6 　静态单赋值——程序依赖图　　69
3.4.7 　未来增强展望　　71
3.5 　HotSpot VM自适应调优　　71
3.5.1 　Java 1.4.2的默认值　　71
3.5.2 　Java 5自动优化的默认值　　71
3.5.3 　Java 6 Update 18更新后的默认优化值　　73
3.5.4 　自适应Java堆调整　　74
3.5.5 　超越自动优化　　75
3.6 　参考资料　　75
第4章　JVM性能监控　　77
4.1 　定义　　77
4.2 　垃圾收集　　78
4.2.1 　重要的垃圾收集数据　　78
4.2.2 　垃圾收集报告　　78
4.2.3 　垃圾收集数据的离线分析　　86
4.2.4 　图形化工具　　89
4.3 　JIT编译器　　103
4.4 　类加载　　104
4.5 　Java应用监控　　106
4.6 　参考资料　　109
第5章　Java应用性能分析　　110
5.1 　术语　　111
5.1.1 　通用性能分析术语　　111
5.1.2 　Oracle Solaris Studio Performance Analyzer术语　　112
5.1.3 　NetBeans Profiler术语　　112
5.2 　Oracle Solaris Studio Performance Analyzer　　112
5.2.1 　支持平台　　113
5.2.2 　下载/安装Oracle Solaris Studio Performance Analyzer　　114
5.2.3 　使用Oracle Solaris Studio Performance Analyzer 抓取性能数据　　114
5.2.4 　查看性能数据　　118
5.2.5 　数据表示　　125
5.2.6 　过滤性能数据　　128
5.2.7 　命令行工具er_print　　129
5.3 　NetBeans Profiler　　135
5.3.1 　支持平台　　136
5.3.2 　下载安装NetBeans Profiler　　136
5.3.3 　开始方法分析会话　　137
5.3.4 　Controls子面板　　143
5.3.5 　Status子面板　　143
5.3.6 　Profiling Results子面板　　143
5.3.7 　Saved Snapshots子面板　　144
5.3.8 　View子面板　　144
5.3.9 　Basic Telemetry子面板　　144
5.3.10 　查看动态结果　　145
5.3.11 　对结果进行快照　　145
5.3.12 　启动内存分析会话　　146
5.3.13 　查看实时结果　　148
5.3.14 　对结果进行快照　　150
5.3.15 　定位内存泄漏　　150
5.3.16 　分析堆转储　　151
5.4 　参考资料　　152
第6章　Java应用性能分析技巧　　153
6.1 　性能优化机会　　153
6.2 　系统或内核态CPU使用　　154
6.3 　锁竞争　　161
6.4 　Volatile的使用　　171
6.5 　调整数据结构的大小　　172
6.5.1 　StringBuilder或StringBuffer大小的调整　　172
6.5.2 　Java Collection类大小调整　　175
6.6 　增加并行性　　179
6.7 　过高的CPU使用率　　181
6.8 　其他有用的分析提示　　182
6.9 　参考资料　　184
第7章　JVM性能调优入门　　185
7.1 　方法　　185
7.1.1 　假设条件　　187
7.1.2 　测试基础设施需求　　188
7.2 　应用程序的系统需求　　188
7.2.1 　可用性　　188
7.2.2 　可管理性　　188
7.2.3 　吞吐量　　189
7.2.4 　延迟及响应性　　189
7.2.5 　内存占用　　189
7.2.6 　启动时间　　189
7.3 　对系统需求分级　　190
7.4 　选择JVM部署模式　　190
7.4.1 　单JVM部署模式　　190
7.4.2 　多JVM部署模式　　190
7.4.3 　通用建议　　191
7.5 　选择JVM运行模式　　191
7.5.1 　Client模式或Server模式　　191
7.5.2 　32位/64位 JVM　　192
7.5.3 　垃圾收集器　　192
7.6 　垃圾收集调优基础　　193
7.6.1 　性能属性　　193
7.6.2 　原则　　193
7.6.3 　命令行选项及GC日志　　194
7.7 　确定内存占用　　197
7.7.1 　约束　　197
7.7.2 　HotSpot VM堆的布局　　197
7.7.3 　堆大小调优着眼点　　200
7.7.4 　计算活跃数据大小　　201
7.7.5 　初始堆空间大小配置　　202
7.7.6 　其他考量因素　　203
7.8 　调优延迟/响应性　　204
7.8.1 　输入　　205
7.8.2 　优化新生代的大小　　205
7.8.3 　优化老年代的大小　　207
7.8.4 　为CMS调优延迟　　210
7.8.5 　Survivor空间介绍　　212
7.8.6 　解析晋升阈值　　214
7.8.7 　监控晋升阈值　　215
7.8.8 　调整Survivor空间的容量　　216
7.8.9 　显式的垃圾收集　　222
7.8.10 　并发永久代垃圾收集　　223
7.8.11 　调优CMS停顿时间　　224
7.8.12 　下一步　　225
7.9 　应用程序吞吐量调优　　225
7.9.1 　CMS吞吐量调优　　225
7.9.2 　Throughput收集器调优　　226
7.9.3 　Survivor空间调优　　228
7.9.4 　调优并行垃圾收集线程　　231
7.9.5 　在NUMA系统上部署　　231
7.9.6 　下一步　　232
7.10 　极端示例　　232
7.11 　其他性能命令行选项　　232
7.11.1 　实验性（最近最大）优化　　232
7.11.2 　逃逸分析　　233
7.11.3 　偏向锁　　233
7.11.4 　大页面支持　　234
7.12 　参考资料　　236
第8章　Java应用的基准测试　　237
8.1 　基准测试所面临的挑战　　237
8.1.1 　基准测试的预热阶段　　238
8.1.2 　垃圾收集　　240
8.1.3 　使用Java Time接口　　240
8.1.4 　剔除无效代码　　241
8.1.5 　内联　　247
8.1.6 　逆优化　　251
8.1.7 　创建微基准测试的注意事项　　256
8.2 　实验设计　　257
8.3 　使用统计方法　　258
8.3.1 　计算均值　　258
8.3.2 　计算标准差　　258
8.3.3 　计算置信区间　　259
8.3.4 　使用假设测试　　260
8.3.5 　使用统计方法的注意事项　　262
8.4 　参考文献　　263
8.5 　参考资料　　263
第9章　多层应用的基准测试　　264
9.1 　基准测试难题　　264
9.2 　企业级应用基准测试的考量　　266
9.2.1 　定义被测系统　　266
9.2.2 　制定微基准测试　　266
9.2.3 　定义用户交互模型　　267
9.2.4 　定义性能指标　　270
9.2.5 　扩展基准测试　　273
9.2.6 　用利特尔法则验证　　274
9.2.7 　思考时间　　275
9.2.8 　扩展性分析　　278
9.2.9 　运行基准测试　　278
9.3 　应用服务器监控　　281
9.3.1 　GlassFish监控　　281
9.3.2 　监控子系统　　286
9.3.3 　Solaris　　287
9.3.4 　Linux　　288
9.3.5 　Windows　　288
9.3.6 　外部系统的性能　　289
9.3.7 　磁盘I/O　　292
9.3.8 　监控和调优资源池　　293
9.4 　企业级应用性能分析　　294
9.5 　参考资料　　295
第10章　Web应用的性能调优　　297
10.1 　Web应用的基准测试　　298
10.2 　Web容器的组件　　298
10.2.1 　HTTP连接器　　299
10.2.2 　Servlet引擎　　300
10.3 　Web容器的监控和性能调优　　300
10.3.1 　容器的开发和生产模式　　300
10.3.2 　安全管理器　　301
10.3.3 　JVM调优　　301
10.3.4 　HTTP服务和Web容器　　303
10.3.5 　HTTP监听器　　303
10.4 　最佳实践　　315
10.4.1 　Servlet和JSP最佳实践　　315
10.4.2 　内容缓存　　324
10.4.3 　会话持久化　　328
10.4.4 　HTTP服务器文件缓存　　329
10.5 　参考资料　　333
第11章　Web Service的性能　　334
11.1 　XML的性能　　334
11.1.1 　XML处理的生命周期　　335
11.1.2 　解析/解编组　　335
11.1.3 　访问　　338
11.1.4 　修改　　338
11.1.5 　序列化/编组　　339
11.2 　验证　　339
11.3 　解析外部实体　　341
11.4 　XML文档的局部处理　　343
11.5 　选择合适的API　　346
11.6 　JAX-WS参考实现栈　　349
11.7 　Web Service基准测试　　350
11.8 　影响Web Service性能的因素　　353
11.8.1 　消息大小的影响　　353
11.8.2 　不同Schema类型的性能特征　　355
11.8.3 　终端服务器的实现　　358
11.8.4 　处理程序的性能　　359
11.9 　最佳性能实践　　361
11.9.1 　二进制负载的处理　　361
11.9.2 　处理XML文档　　365
11.9.3 　使用MTOM发送XML文档　　365
11.9.4 　使用Provider接口　　368
11.9.5 　快速信息集　　370
11.9.6 　HTTP压缩　　372
11.9.7 　Web Service客户端的性能　　373
11.10 　参考资料　　374
第12章　Java持久化及Enterprise Java Bean的性能　　375
12.1 　EJB编程模型　　376
12.2 　Java持久化API及其参考实现　　376
12.3 　监控及调优EJB容器　　379
12.3.1 　线程池　　380
12.3.2 　Bean池和缓存　　382
12.3.3 　EclipseLink会话缓存　　385
12.4 　事务隔离级　　386
12.5 　Enterprise Java Bean的最佳实践　　387
12.5.1 　简要说明使用的EJB基准测试　　387
12.5.2 　EJB 2.1　　388
12.5.3 　EJB 3.0　　400
12.6 　Java持久化最佳实践　　403
12.6.1 　JPA查询语言中的查询　　403
12.6.2 　查询结果缓存　　405
12.6.3 　FetchType　　406
12.6.4 　连接池　　408
12.6.5 　批量更新　　409
12.6.6 　选择正确的数据库锁策略　　411
12.6.7 　不带事务的读取　　411
12.6.8 　继承　　411
12.7 　参考资料　　412
附录A 　重要的HotSpot VM选项　　413
附录B 　性能分析技巧示例源代码　　429
B.1 　锁竞争实现1　　429
B.2 　锁竞争实现2　　439
B.3 　锁竞争实现3　　449
B.4 　锁竞争实现4　　459
B.5 　锁竞争实现5　　469
B.6 　调整容量变化1　　481
B.7 　调整容量变化2　　492
B.8 　增加并发性的单线程实现　　504
B.9 　增加并发性的多线程实现　　514

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java性能优化权威指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Java虚拟机（第2版）
前言
第一部分走近Java
第1章走近Java2
1.1概述2
1.2Java技术体系3
1.3Java发展史5
1.4Java虚拟机发展史9
1.4.1SunClassicExactVM9
1.4.2SunHotSpotVM11
1.4.3SunMobile—EmbeddedVMMeta—CircularVM12
1.4.4BEAJRockitIBMJ9VM13
1.4.5AzulVMBEALiquidVM14
1.4.6ApacheHarmonyGoogleAndroidDalvikVM14
1.4.7MicrosoftJVM及其他15
1.5展望Java技术的未来16
1.5.1模块化17
1.5.2混合语言17
1.5.3多核并行19
1.5.4进一步丰富语法20
1.5.564位虚拟机21
1.6实战：自己编译JDK22
1.6.1获取JDK源码22
1.6.2系统需求24
1.6.3构建编译环境25
1.6.4进行编译26
1.6.5在IDE工具中进行源码调试31
1.7本章小结35
第二部分自动内存管理机制
第2章Java内存区域与内存溢出异常38
2.1概述38
2.2运行时数据区域38
2.2.1程序计数器39
2.2.2Java虚拟机栈39
2.2.3本地方法栈40
2.2.4Java堆41
2.2.5方法区41
2.2.6运行时常量池42
2.2.7直接内存43
2.3HotSpot虚拟机对象探秘43
2.3.1对象的创建44
2.3.2对象的内存布局47
2.3.3对象的访问定位48
2.4实战：OutOfMemoryError异常50
2.4.1Java堆溢出51
2.4.2虚拟机栈和本地方法栈溢出53
2.4.3方法区和运行时常量池溢出56
2.4.4本机直接内存溢出59
2.5本章小结60
第3章垃圾收集器与内存分配策略61
3.1概述61
3.2对象已死吗62
3.2.1引用计数算法62
3.2.2可达性分析算法64
3.2.3再谈引用65
3.2.4生存还是死亡66
3.2.5回收方法区68
3.3垃圾收集算法69
3.3.1标记—清除算法69
3.3.2复制算法70
3.3.3标记—整理算法71
3.3.4分代收集算法72
3.4HotSpot的算法实现72
3.4.1枚举根节点72
3.4.2安全点73
3.4.3安全区域74
3.5垃圾收集器75
3.5.1Serial收集器76
3.5.2ParNew收集器77
3.5.3ParallelScavenge收集器79
3.5.4SerialOld收集器80
3.5.5ParallelOld收集器80
3.5.6CMS收集器81
3.5.7G1收集器84
3.5.8理解GC日志89
3.5.9垃圾收集器参数总结90
3.6内存分配与回收策略91
3.6.1对象优先在Eden分配91
3.6.2大对象直接进入老年代93
3.6.3长期存活的对象将进入老年代95
3.6.4动态对象年龄判定97
3.6.5空间分配担保98
3.7本章小结100
第4章虚拟机性能监控与故障处理工具101
4.1概述101
4.2JDK的命令行工具101
4.2.1jps：虚拟机进程状况工具104
4.2.2jstat：虚拟机统计信息监视工具105
4.2.3jinfo：Java配置信息工具106
4.2.4jmap：Java内存映像工具107
4.2.5jhat：虚拟机堆转储快照分析工具108
4.2.6jstack：Java堆栈跟踪工具109
4.2.7HSDIS：JIT生成代码反汇编111
4.3JDK的可视化工具114
4.3.1JConsole：Java监视与管理控制台115
4.3.2VisualVM：多合一故障处理工具122
4.4本章小结131
第5章调优案例分析与实战132
5.1概述132
5.2案例分析132
5.2.1高性能硬件上的程序部署策略132
5.2.2集群间同步导致的内存溢出135
5.2.3堆外内存导致的溢出错误136
5.2.4外部命令导致系统缓慢137
5.2.5服务器JVM进程崩溃138
5.2.6不恰当数据结构导致内存占用过大139
5.2.7由Windows虚拟内存导致的长时间停顿141
5.3实战：Eclipse运行速度调优142
5.3.1调优前的程序运行状态142
5.3.2升级JDK1.6的性能变化及兼容问题145
5.3.3编译时间和类加载时间的优化150
5.3.4调整内存设置控制垃圾收集频率153
5.3.5选择收集器降低延迟157
5.4本章小结160
第三部分虚拟机执行子系统
第6章类文件结构162
6.1概述162
6.2无关性的基石162
6.3Class类文件的结构164
6.3.1魔数与Class文件的版本166
6.3.2常量池167
6.3.3访问标志173
6.3.4类索引、父类索引与接口索引集合174
6.3.5字段表集合175
6.3.6方法表集合178
6.3.7属性表集合180
6.4字节码指令简介196
6.4.1字节码与数据类型197
6.4.2加载和存储指令199
6.4.3运算指令200
6.4.4类型转换指令202
6.4.5对象创建与访问指令203
6.4.6操作数栈管理指令203
6.4.7控制转移指令204
6.4.8方法调用和返回指令204
6.4.9异常处理指令205
6.4.10同步指令205
6.5公有设计和私有实现206
6.6Class文件结构的发展207
6.7本章小结208
第7章虚拟机类加载机制209
7.1概述209
7.2类加载的时机210
7.3类加载的过程214
7.3.1加载214
7.3.2验证216
7.3.3准备219
7.3.4解析220
7.3.5初始化225
7.4类加载器227
7.4.1类与类加载器228
7.4.2双亲委派模型229
7.4.3破坏双亲委派模型233
7.5本章小结235
第8章虚拟机字节码执行引擎236
8.1概述236
8.2运行时栈帧结构236
8.2.1局部变量表238
8.2.2操作数栈242
8.2.3动态连接243
8.2.4方法返回地址243
8.2.5附加信息244
8.3方法调用244
8.3.1解析244
8.3.2分派246
8.3.3动态类型语言支持258
8.4基于栈的字节码解释执行引擎269
8.4.1解释执行269
8.4.2基于栈的指令集与基于寄存器的指令集270
8.4.3基于栈的解释器执行过程272
8.5本章小结275
第9章类加载及执行子系统的案例与实战276
9.1概述276
9.2案例分析276
9.2.1Tomcat：正统的类加载器架构276
9.2.2OSGi：灵活的类加载器架构279
9.2.3字节码生成技术与动态代理的实现282
9.2.4Retrotranslator：跨越JDK版本286
9.3实战：自己动手实现远程执行功能289
9.3.1目标290
9.3.2思路290
9.3.3实现291
9.3.4验证298
9.4本章小结299
第四部分程序编译与代码优化
第10章早期（编译期）优化302
10.1概述302
10.2Javac编译器303
10.2.1Javac的源码与调试303
10.2.2解析与填充符号表305
10.2.3注解处理器307
10.2.4语义分析与字节码生成307
10.3Java语法糖的味道311
10.3.1泛型与类型擦除311
10.3.2自动装箱、拆箱与遍历循环315
10.3.3条件编译317
10.4实战：插入式注解处理器318
10.4.1实战目标318
10.4.2代码实现319
10.4.3运行与测试326
10.4.4其他应用案例327
10.5本章小结328
第11章晚期（运行期）优化329
11.1概述329
11.2HotSpot虚拟机内的即时编译器329
11.2.1解释器与编译器330
11.2.2编译对象与触发条件332
11.2.3编译过程337
11.2.4查看及分析即时编译结果339
11.3编译优化技术345
11.3.1优化技术概览346
11.3.2公共子表达式消除350
11.3.3数组边界检查消除351
11.3.4方法内联352
11.3.5逃逸分析354
11.4Java与C/C++的编译器对比356
11.5本章小结358
第五部分高效并发
第12章Java内存模型与线程360
12.1概述360
12.2硬件的效率与一致性361
12.3Java内存模型362
12.3.1主内存与工作内存363
12.3.2内存间交互操作364
12.3.3对于volatile型变量的特殊规则366
12.3.4对于long和double型变量的特殊规则372
12.3.5原子性、可见性与有序性373
12.3.6先行发生原则375
12.4Java与线程378
12.4.1线程的实现378
12.4.2Java线程调度381
12.4.3状态转换383
12.5本章小结384
第13章线程安全与锁优化385
13.1概述385
13.2线程安全385
13.2.1Java语言中的线程安全386
13.2.2线程安全的实现方法390
13.3锁优化397
13.3.1自旋锁与自适应自旋398
13.3.2锁消除398
13.3.3锁粗化400
13.3.4轻量级锁400
13.3.5偏向锁402
13.4本章小结403
附录
附录A编译Windows版的OpenJDK406
附录B虚拟机字节码指令表414
附录CHotSpot虚拟机主要参数表420
附录D对象查询语言（OQL）简介424
附录EJDK历史版本轨迹430
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Java虚拟机（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Effective java 中文版（第2版）
译者序
序
前言
致谢
第1章 引言
第2章 创建和销毁对象
第1条：考虑用静态工厂方法代替构造器
第2条：遇到多个构造器参数时要考虑用构建器
第3条：用私有构造器或者枚举类型强化Singleton属性
第4条：通过私有构造器强化不可实例化的能力
第5条：避免创建不必要的对象
第6条：消除过期的对象引用
第7条：避免使用终结方法
第3章 对于所有对象都通用的方法
第8条：覆盖equals时请遵守通用约定
第9条：覆盖equals时总要覆盖hashCode
第10条：始终要覆盖toString
第11条：谨慎地覆盖clone
第12条：考虑实现Comparable接口
第4章 类和接口
第13条：使类和成员的可访问性最小化
第14条：在公有类中使用访问方法而非公有域
第15条：使可变性最小化
第16条：复合优先于继承
第17条：要么为继承而设计，并提供文档说明，要么就禁止继承
第18条：接口优于抽象类
第19条：接口只用于定义类型
第20条：类层次优于标签类
第21条：用函数对象表示策略
第22条：优先考虑静态成员类
第5章 泛型
第23条：请不要在新代码中使用原生态类型
第24条：消除非受检警告
第25条：列表优先于数组
第26条：优先考虑泛型
第27条：优先考虑泛型方法
第28条：利用有限制通配符来提升API的灵活性
第29条：优先考虑类型安全的异构容器
第6章 枚举和注解
第30条：用enum代替int常量
第31条：用实例域代替序数
第32条：用EnumSet代替位域
第33条：用EnumMap代替序数索引
第34条：用接口模拟可伸缩的枚举
第35条：注解优先于命名模式
第36条：坚持使用Override注解
第37条：用标记接口定义类型
第7章 方法
第38条：检查参数的有效性
第39条：必要时进行保护性拷贝
第40条：谨慎设计方法签名
第41条：慎用重载
第42条：慎用可变参数
第43条：返回零长度的数组或者集合，而不是：null
第44条：为所有导出的API元素编写文档注释
第8章 通用程序设计
第45条：将局部变量的作用域最小化
第46条：for-each循环优先于传统的for循环
第47条：了解和使用类库
第48条：如果需要精确的答案，请避免使用float和double
第49条：基本类型优先于装箱基本类型
第50条：如果其他类型更适合，则尽量避免使用字符串
第51条：当心字符串连接的性能
第52条：通过接口引用对象
第53条：接口优先于反射机制
第54条：谨慎地使用本地方法
第55条：谨慎地进行优化
第56条：遵守普遍接受的命名惯例
第9章 异常
第57条：只针对异常的情况才使用异常
第58条：对可恢复的情况使用受检异常，对编程错误使用运行时异常
第59条：避免不必要地使用受检的异常
第60条：优先使用标准的异常
第61条：抛出与抽象相对应的异常
第62条：每个方法抛出的异常都要有文档
第63条：在细节消息中包含能捕获失败的信息
第64条：努力使失败保持原子性
第65条：不要忽略异常
第10章 并发
第66条：同步访问共享的可变数据
第67条：避免过度同步
第68条：executor和task优先干线程
第69条：并发工具优先于wait和notify
第70条：线程安全性的文档化
第71条：慎用延迟初始化
第72条：不要依赖于线程调度器
第73条：避免使用线程组
第11章 序列化
第74条：谨慎地实现Serializable接口
第75条：考虑使用自定义的序列化形式
第76条：保护性地编写readObject方法
第77条：对于实例控制，枚举类型优先于readResolve
第78条：考虑用序列化代理代替序列化实例
附录 第1版与第2版条目对照
中英文术语对照
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Effective java 中文版（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Head First Java（第二版·中文版）
序
1 进入Java的世界
Java的工作方式
Java的程序结构
剖析类
main（）方法
循环
条件分支
设计程序
术语制造机
谈话录
习题
2 拜访对象村
椅子大战
继承
覆盖
什么是类？
创建你的第一个对象
使用main（）
猜数字
习题
3 认识变量
声明变量
Primitive主数据类型
Java关键字
引用变量
对象的声明与赋值
可回收堆空间
数组
习题
4 对象的行为
操作对象状态的方法
方法参数与返回类型
值传递
Getters与Setters
封装
数组中的引用
习题
5 超强力方法
创建战舰游戏
简单版
编写伪码
测试
编写程序
完成版
用Math.random（）产生随机数
预先输入好的程序
循环
类型转换
用Integer.parseInt（）转换字符串
习题
6 使用Java函数库
7 对象村的优质生活
8 深入多态
9 对象的前世今生
10 数字很重要
11 有风险的行为
12 看图说故事
13 使用Swing
14 保存对象
15 网络联机
16 数据结构
17 发布程序
18 分布式计算
附录A：程序料理决定版
附录B：十大遗珠之憾
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Head First Java（第二版·中文版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java核心技术·卷 I（原书第10版）
译者序
前言
致谢
第1章　Java程序设计概述 1
1.1　Java程序设计平台 1
1.2　Java“白皮书”的关键术语 2
1.2.1　简单性 2
1.2.2　面向对象 2
1.2.3　分布式 3
1.2.4　健壮性 3
1.2.5　安全性 3
1.2.6　体系结构中立 4
1.2.7　可移植性 4
1.2.8　解释型 5
1.2.9　高性能 5
1.2.10　多线程 5
1.2.11　动态性 5
1.3　Java applet与Internet 6
1.4　Java发展简史 7
1.5　关于Java的常见误解 9
第2章　Java程序设计环境 12
2.1　安装Java开发工具包 12
2.1.1　下载JDK 12
2.1.2　设置JDK 13
2.1.3　安装库源文件和文档 15
2.2　使用命令行工具 16
2.3　使用集成开发环境 18
2.4　运行图形化应用程序 21
2.5　构建并运行applet 23
第3章　Java的基本程序设计结构 28
3.1　一个简单的Java应用程序 28
3.2　注释 31
3.3　数据类型 32
3.3.1　整型 32
3.3.2　浮点类型 33
3.3.3　char类型 34
3.3.4　Unicode和char类型 35
3.3.5　boolean类型 35
3.4　变量 36
3.4.1　变量初始化 37
3.4.2　常量 37
3.5　运算符 38
3.5.1　数学函数与常量 39
3.5.2　数值类型之间的转换 40
3.5.3　强制类型转换 41
3.5.4　结合赋值和运算符 42
3.5.5　自增与自减运算符 42
3.5.6　关系和boolean运算符 42
3.5.7　位运算符 43
3.5.8　括号与运算符级别 44
3.5.9　枚举类型 45
3.6　字符串 45
3.6.1　子串 45
3.6.2　拼接 46
3.6.3　不可变字符串 46
3.6.4　检测字符串是否相等 47
3.6.5　空串与Null串 48
3.6.6　码点与代码单元 49
3.6.7　String API 50
3.6.8　阅读联机API文档 52
3.6.9　构建字符串 54
3.7　输入输出 55
3.7.1　读取输入 55
3.7.2　格式化输出 58
3.7.3　文件输入与输出 61
3.8　控制流程 63
3.8.1　块作用域 63
3.8.2　条件语句 63
3.8.3　循环 66
3.8.4　确定循环 69
3.8.5　多重选择：switch语句 72
3.8.6　中断控制流程语句 74
3.9　大数值 76
3.10　数组 78
3.10.1　for each循环 79
3.10.2　数组初始化以及匿名数组 80
3.10.3　数组拷贝 81
3.10.4　命令行参数 81
3.10.5　数组排序 82
3.10.6　多维数组 85
3.10.7　不规则数组 88
第4章　对象与类 91
4.1　面向对象程序设计概述 91
4.1.1　类 92
4.1.2　对象 93
4.1.3　识别类 93
4.1.4　类之间的关系 94
4.2　使用预定义类 95
4.2.1　对象与对象变量 95
4.2.2　Java类库中的LocalDate类 98
4.2.3　更改器方法与访问器方法 100
4.3　用户自定义类 103
4.3.1　Employee类 103
4.3.2　多个源文件的使用 105
4.3.3　剖析Employee类 106
4.3.4　从构造器开始 106
4.3.5　隐式参数与显式参数 108
4.3.6　封装的优点 109
4.3.7　基于类的访问权限 111
4.3.8　私有方法 111
4.3.9　final实例域 112
4.4　静态域与静态方法 112
4.4.1　静态域 112
4.4.2　静态常量 113
4.4.3　静态方法 114
4.4.4　工厂方法 115
4.4.5　main方法 115
4.5　方法参数 118
4.6　对象构造 123
4.6.1　重载 123
4.6.2　默认域初始化 123
4.6.3　无参数的构造器 124
4.6.4　显式域初始化 125
4.6.5　参数名 125
4.6.6　调用另一个构造器 126
4.6.7　初始化块 127
4.6.8　对象析构与finalize方法 130
4.7　包 131
4.7.1　类的导入 131
4.7.2　静态导入 133
4.7.3　将类放入包中 133
4.7.4　包作用域 136
4.8　类路径 137
4.8.1　设置类路径 139
4.9　文档注释 140
4.9.1　注释的插入 140
4.9.2　类注释 140
4.9.3　方法注释 141
4.9.4　域注释 142
4.9.5　通用注释 142
4.9.6　包与概述注释 143
4.9.7　注释的抽取 143
4.10　类设计技巧 144
第5章　继承 147
5.1　类、超类和子类 147
5.1.1　定义子类 147
5.1.2　覆盖方法 149
5.1.3　子类构造器 150
5.1.4　继承层次 153
5.1.5　多态 154
5.1.6　理解方法调用 155
5.1.7　阻止继承：final类和方法 157
5.1.8　强制类型转换 158
5.1.9　抽象类 160
5.1.10　受保护访问 165
5.2　Object：所有类的超类 166
5.2.1　equals方法 166
5.2.2　相等测试与继承 167
5.2.3　hashCode方法 170
5.2.4　toString方法 172
5.3　泛型数组列表 178
5.3.1　访问数组列表元素 180
5.3.2　类型化与原始数组列表的兼容性 183
5.4　对象包装器与自动装箱 184
5.5　参数数量可变的方法 187
5.6　枚举类 188
5.7　反射 190
5.7.1　Class类 190
5.7.2　捕获异常 192
5.7.3　利用反射分析类的能力 194
5.7.4　在运行时使用反射分析对象 198
5.7.5　使用反射编写泛型数组代码 202
5.7.6　调用任意方法 205
5.8　继承的设计技巧 208
第6章　接口、lambda表达式与内部类 211
6.1　接口 211
6.1.1　接口概念 211
6.1.2　接口的特性 217
6.1.3　接口与抽象类 218
6.1.4　静态方法 218
6.1.5　默认方法 219
6.1.6　解决默认方法冲突 220
6.2　接口示例 222
6.2.1　接口与回调 222
6.2.2　Comparator接口 224
6.2.3　对象克隆 225
6.3　lambda表达式 231
6.3.1　为什么引入lambda表达式 231
6.3.2　lambda表达式的语法 232
6.3.3　函数式接口 234
6.3.4　方法引用 235
6.3.5　构造器引用 237
6.3.6　变量作用域 237
6.3.7　处理lambda表达式 239
6.3.8　再谈Comparator 242
6.4　内部类 242
6.4.1　使用内部类访问对象状态 244
6.4.2　内部类的特殊语法规则 247
6.4.3　内部类是否有用、必要和安全 248
6.4.4　局部内部类 250
6.4.5　由外部方法访问变量 250
6.4.6　匿名内部类 252
6.4.7　静态内部类 255
6.5　代理 258
6.5.1　何时使用代理 259
6.5.2　创建代理对象 259
6.5.3　代理类的特性 262
第7章　异常、断言和日志 264
7.1　处理错误 264
7.1.1　异常分类 265
7.1.2　声明受查异常 267
7.1.3　如何抛出异常 269
7.1.4　创建异常类 270
7.2　捕获异常 271
7.2.1　捕获异常 271
7.2.2　捕获多个异常 273
7.2.3　再次抛出异常与异常链 274
7.2.4　finally子句 275
7.2.5　带资源的try语句 278
7.2.6　分析堆栈轨迹元素 280
7.3　使用异常机制的技巧 282
7.4　使用断言 285
7.4.1　断言的概念 285
7.4.2　启用和禁用断言 286
7.4.3　使用断言完成参数检查 287
7.4.4　为文档假设使用断言 288
7.5　记录日志 289
7.5.1　基本日志 289
7.5.2　高级日志 289
7.5.3　修改日志管理器配置 291
7.5.4　本地化 292
7.5.5　处理器 293
7.5.6　过滤器 296
7.5.7　格式化器 296
7.5.8　日志记录说明 296
7.6　调试技巧 304
第8章　泛型程序设计 309
8.1　为什么要使用泛型程序设计 309
8.1.1　类型参数的好处 309
8.1.2　谁想成为泛型程序员 310
8.2　定义简单泛型类 311
8.3　泛型方法 313
8.4　类型变量的限定 314
8.5　泛型代码和虚拟机 316
8.5.1　类型擦除 316
8.5.2　翻译泛型表达式 317
8.5.3　翻译泛型方法 318
8.5.4　调用遗留代码 319
8.6　约束与局限性 320
8.6.1　不能用基本类型实例化类型参数 320
8.6.2　运行时类型查询只适用于原始类型 321
8.6.3　不能创建参数化类型的数组 321
8.6.4　Varargs警告 322
8.6.5　不能实例化类型变量 323
8.6.6　不能构造泛型数组 323
8.6.7　泛型类的静态上下文中类型变量无效 325
8.6.8　不能抛出或捕获泛型类的实例 325
8.6.9　可以消除对受查异常的检查 326
8.6.10　注意擦除后的冲突 327
8.7　泛型类型的继承规则 328
8.8　通配符类型 330
8.8.1　通配符概念 330
8.8.2　通配符的超类型限定 331
8.8.3　无限定通配符 334
8.8.4　通配符捕获 334
8.9　反射和泛型 337
8.9.1　泛型Class类 337
8.9.2　使用Class参数进行类型匹配 338
8.9.3　虚拟机中的泛型类型信息 338
第9章　集合 344
9.1　Java集合框架 344
9.1.1　将集合的接口与实现分离 344
9.1.2　Collection接口 346
9.1.3　迭代器 347
9.1.4　泛型实用方法 349
9.1.5　集合框架中的接口 352
9.2　具体的集合 353
9.2.1　链表 355
9.2.2　数组列表 362
9.2.3　散列集 363
9.2.4　树集 366
9.2.5　队列与双端队列 369
9.2.6　优先级队列 371
9.3　映射 372
9.3.1　基本映射操作 372
9.3.2　更新映射项 375
9.3.3　映射视图 376
9.3.4　弱散列映射 377
9.3.5　链接散列集与映射 378
9.3.6　枚举集与映射 379
9.3.7　标识散列映射 380
9.4　视图与包装器 381
9.4.1　轻量级集合包装器 382
9.4.2　子范围 382
9.4.3　不可修改的视图 383
9.4.4　同步视图 384
9.4.5　受查视图 384
9.4.6　关于可选操作的说明 385
9.5　算法 388
9.5.1　排序与混排 389
9.5.2　二分查找 391
9.5.3　简单算法 392
9.5.4　批操作 394
9.5.5　集合与数组的转换 394
9.5.6　编写自己的算法 395
9.6　遗留的集合 396
9.6.1　Hashtable类 397
9.6.2　枚举 397
9.6.3　属性映射 398
9.6.4　栈 399
9.6.5　位集 399
第10章　图形程序设计 403
10.1　Swing概述 403
10.2　创建框架 407
10.3　框架定位 409
10.3.1　框架属性 411
10.3.2　确定合适的框架大小 411
10.4　在组件中显示信息 415
10.5　处理2D图形 419
10.6　使用颜色 426
10.7　文本使用特殊字体 429
10.8　显示图像 435
第11章　事件处理 439
11.1　事件处理基础 439
11.1.1　实例：处理按钮点击事件 441
11.1.2　简洁地指定监听器 445
11.1.3　实例：改变观感 447
11.1.4　适配器类 450
11.2　动作 453
11.3　鼠标事件 459
11.4　AWT事件继承层次 465
11.4.1　语义事件和底层事件 466
第12章　Swing用户界面组件 469
12.1　Swing和模型–视图–控制器设计模式 469
12.1.1　设计模式 469
12.1.2　模型–视图–控制器模式 470
12.1.3　Swing按钮的模型–视图–控制器分析 473
12.2　布局管理概述 474
12.2.1　边框布局 477
12.2.2　网格布局 478
12.3　文本输入 481
12.3.1　文本域 482
12.3.2　标签和标签组件 483
12.3.3　密码域 484
12.3.4　文本区 485
12.3.5　滚动窗格 485
12.4　选择组件 488
12.4.1　复选框 488
12.4.2　单选钮 490
12.4.3　边框 493
12.4.4　组合框 496
12.4.5　滑动条 499
12.5　菜单 504
12.5.1　菜单创建 504
12.5.2　菜单项中的图标 507
12.5.3　复选框和单选钮菜单项 508
12.5.4　弹出菜单 508
12.5.5　快捷键和加速器 510
12.5.6　启用和禁用菜单项 511
12.5.7　工具栏 515
12.5.8　工具提示 516
12.6　复杂的布局管理 518
12.6.1　网格组布局 520
12.6.2　组布局 528
12.6.3　不使用布局管理器 537
12.6.4　定制布局管理器 537
12.6.5　遍历顺序 541
12.7　对话框 541
12.7.1　选项对话框 542
12.7.2　创建对话框 551
12.7.3　数据交换 554
12.7.4　文件对话框 559
12.7.5　颜色选择器 569
12.8　GUI程序排错 573
12.8.1　调试技巧 573
12.8.2　让AWT机器人完成工作 576
第13章　部署Java应用程序 580
13.1　JAR文件 580
13.1.1　创建JAR文件 580
13.1.2　清单文件 581
13.1.3　可执行JAR文件 582
13.1.4　资源 583
13.1.5　密封 585
13.2　应用首选项的存储 586
13.2.1　属性映射 586
13.2.2　首选项API 591
13.3　服务加载器 596
13.4　applet 598
13.4.1　一个简单的applet 599
13.4.2　applet HTML标记和属性 602
13.4.3　使用参数向applet传递信息 603
13.4.4　访问图像和音频文件 608
13.4.5　applet上下文 609
13.4.6　applet间通信 609
13.4.7　在浏览器中显示信息项 610
13.4.8　沙箱 611
13.4.9　签名代码 612
13.5　Java Web Start 614
13.5.1　发布Java Web Start应用 614
13.5.2　JNLP API 617
第14章　并发 624
14.1　什么是线程 624
14.1.1　使用线程给其他任务提供机会 629
14.2　中断线程 632
14.3　线程状态 635
14.3.1　新创建线程 635
14.3.2　可运行线程 635
14.3.3　被阻塞线程和等待线程 636
14.3.4　被终止的线程 636
14.4　线程属性 638
14.4.1　线程优先级 638
14.4.2　守护线程 639
14.4.3　未捕获异常处理器 639
14.5　同步 640
14.5.1　竞争条件的一个例子 641
14.5.2　竞争条件详解 644
14.5.3　锁对象 646
14.5.4　条件对象 648
14.5.5　synchronized关键字 653
14.5.6　同步阻塞 656
14.5.7　监视器概念 657
14.5.8　Volatile域 658
14.5.9　final变量 659
14.5.10　原子性 659
14.5.11　死锁 661
14.5.12　线程局部变量 663
14.5.13　锁测试与超时 665
14.5.14　读/写锁 666
14.5.15　为什么弃用stop和suspend方法 667
14.6　阻塞队列 668
14.7　线程安全的集合 673
14.7.1　高效的映射、集和队列 674
14.7.2　映射条目的原子更新 675
14.7.3　对并发散列映射的批操作 676
14.7.4　并发集视图 678
14.7.5　写数组的拷贝 679
14.7.6　并行数组算法 679
14.7.7　较早的线程安全集合 680
14.8　Callable与Future 681
14.9　执行器 685
14.9.1　线程池 685
14.9.2　预定执行 689
14.9.3　控制任务组 690
14.9.4　Fork-Join框架 691
14.9.5　可完成Future 694
14.10　同步器 696
14.10.1　信号量 696
14.10.2　倒计时门栓 697
14.10.3　障栅 697
14.10.4　交换器 698
14.10.5　同步队列 698
14.11　线程与Swing 698
14.11.1　运行耗时的任务 699
14.11.2　使用Swing工作线程 703
14.11.3　单一线程规则 708
附录A　Java关键字 710
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java核心技术·卷 I（原书第10版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Java虚拟机
前　言
致　谢
第一部分　走近Java
第1章　走近Java / 2
1.1　概述 / 2
1.2　Java技术体系 / 3
1.3　Java发展史 / 5
1.4　展望Java技术的未来 / 9
1.4.1　模块化 / 9
1.4.2　混合语言 / 9
1.4.3　多核并行 / 11
1.4.4　进一步丰富语法 / 12
1.4.5　64位虚拟机 / 13
1.5　实战：自己编译JDK / 13
1.5.1　获取JDK源码 / 13
1.5.2　系统需求 / 14
1.5.3　构建编译环境 / 15
1.5.4　准备依赖项 / 17
1.5.5　进行编译 / 18
1.6　本章小结 / 21
第二部分　自动内存管理机制
第2章　Java内存区域与内存溢出异常 / 24
2.1　概述 / 24
2.2　运行时数据区域 / 25
2.2.1　程序计数器 / 25
2.2.2　Java虚拟机栈 / 26
2.2.3　本地方法栈 / 27
2.2.4　Java堆 / 27
2.2.5　方法区 / 28
2.2.6　运行时常量池 / 29
2.2.7　直接内存 / 29
2.3　对象访问 / 30
2.4　实战：OutOfMemoryError异常 / 32
2.4.1　Java堆溢出 / 32
2.4.2　虚拟机栈和本地方法栈溢出 / 35
2.4.3　运行时常量池溢出 / 38
2.4.4　方法区溢出 / 39
2.4.5　本机直接内存溢出 / 41
2.5　本章小结 / 42
第3章　垃圾收集器与内存分配策略 / 43
3.1　概述 / 43
3.2　对象已死？ / 44
3.2.1　引用计数算法 / 44
3.2.2　根搜索算法 / 46
3.2.3　再谈引用 / 47
3.2.4　生存还是死亡？ / 48
3.2.5　回收方法区 / 50
3.3　垃圾收集算法 / 51
3.3.1　标记 -清除算法 / 51
3.3.2　复制算法 / 52
3.3.3　标记-整理算法 / 54
3.3.4　分代收集算法 / 54
3.4　垃圾收集器 / 55
3.4.1　Serial收集器 / 56
3.4.2　ParNew收集器 / 57
3.4.3　Parallel Scavenge收集器 / 59
3.4.4　Serial Old收集器 / 60
3.4.5　Parallel Old收集器 / 61
3.4.6　CMS收集器 / 61
3.4.7　G1收集器 / 64
3.4.8　垃圾收集器参数总结 / 64
3.5　内存分配与回收策略 / 65
3.5.1　对象优先在Eden分配 / 66
3.5.2　大对象直接进入老年代 / 68
3.5.3　长期存活的对象将进入老年代 / 69
3.5.4　动态对象年龄判定 / 71
3.5.5　空间分配担保 / 73
3.6　本章小结 / 75
第4章　虚拟机性能监控与故障处理工具 / 76
4.1　概述 / 76
4.2　JDK的命令行工具 / 76
4.2.1　jps：虚拟机进程状况工具 / 79
4.2.2　jstat：虚拟机统计信息监视工具 / 80
4.2.3　jinfo：Java配置信息工具 / 82
4.2.4　jmap：Java内存映像工具 / 82
4.2.5　jhat：虚拟机堆转储快照分析工具 / 84
4.2.6　jstack：Java堆栈跟踪工具 / 85
4.3　JDK的可视化工具 / 87
4.3.1　JConsole：Java监视与管理控制台 / 88
4.3.2　VisualVM：多合一故障处理工具 / 96
4.4　本章小结 / 105
第5章　调优案例分析与实战 / 106
5.1　概述 / 106
5.2　案例分析 / 106
5.2.1　高性能硬件上的程序部署策略 / 106
5.2.2　集群间同步导致的内存溢出 / 109
5.2.3　堆外内存导致的溢出错误 / 110
5.2.4　外部命令导致系统缓慢 / 112
5.2.5　服务器JVM进程崩溃 / 113
5.3　实战：Eclipse运行速度调优 / 114
5.3.1　调优前的程序运行状态 / 114
5.3.2　升级JDK 1.6的性能变化及兼容问题 / 117
5.3.3　编译时间和类加载时间的优化 / 122
5.3.4　调整内存设置控制垃圾收集频率 / 126
5.3.5　选择收集器降低延迟 / 130
5.4　本章小结 / 133
第三部分　虚拟机执行子系统
第6章　类文件结构 / 136
6.1　概述 / 136
6.2　无关性的基石 / 136
6.3　Class类文件的结构 / 138
6.3.1　魔数与Class文件的版本 / 139
6.3.2　常量池 / 141
6.3.3　访问标志 / 147
6.3.4　类索引、父类索引与接口索引集合 / 148
6.3.5　字段表集合 / 149
6.3.6　方法表集合 / 153
6.3.7　属性表集合 / 155
6.4　Class文件结构的发展 / 168
6.5　本章小结 / 170
第7章　虚拟机类加载机制 / 171
7.1　概述 / 171
7.2　类加载的时机 / 172
7.3　类加载的过程 / 176
7.3.1　加载 / 176
7.3.2　验证 / 178
7.3.3　准备 / 181
7.3.4　解析 / 182
7.3.5　初始化 / 186
7.4　类加载器 / 189
7.4.1　类与类加载器 / 189
7.4.2　双亲委派模型 / 191
7.4.3　破坏双亲委派模型 / 194
7.5　本章小结 / 197
第8章　虚拟机字节码执行引擎 / 198
8.1　概述 / 198
8.2　运行时栈帧结构 / 199
8.2.1　局部变量表 / 199
8.2.2　操作数栈 / 204
8.2.3　动态连接 / 206
8.2.4　方法返回地址 / 206
8.2.5　附加信息 / 207
8.3　方法调用 / 207
8.3.1　解析 / 207
8.3.2　分派 / 209
8.4　基于栈的字节码解释执行引擎 / 221
8.4.1　解释执行 / 221
8.4.2　基于栈的指令集与基于寄存器的指令集 / 223
8.4.3　基于栈的解释器执行过程 / 224
8.5　本章小结 / 230
第9章　类加载及执行子系统的案例与实战 / 231
9.1　概述 / 231
9.2　案例分析 / 231
9.2.1　Tomcat：正统的类加载器架构 / 232
9.2.2　OSGi：灵活的类加载器架构 / 235
9.2.3　字节码生成技术与动态代理的实现 / 238
9.2.4　Retrotranslator：跨越JDK版本 / 242
9.3　实战：自己动手实现远程执行功能 / 246
9.3.1　目标 / 246
9.3.2　思路 / 247
9.3.3　实现 / 248
9.3.4　验证 / 255
9.4　本章小结 / 256
第四部分　程序编译与代码优化
第10章　早期（编译期）优化 / 258
10.1　概述 / 258
10.2　Javac编译器 / 259
10.2.1　Javac的源码与调试 / 259
10.2.2　解析与填充符号表 / 262
10.2.3　注解处理器 / 264
10.2.4　语义分析与字节码生成 / 264
10.3　Java语法糖的味道 / 268
10.3.1　泛型与类型擦除 / 268
10.3.2　自动装箱、拆箱与遍历循环 / 273
10.3.3　条件编译 / 275
10.4　实战：插入式注解处理器 / 276
10.4.1　实战目标 / 276
10.4.2　代码实现 / 277
10.4.3　运行与测试 / 284
10.4.4　其他应用案例 / 286
10.5　本章小结 / 286
第11章　晚期（运行期）优化 / 287
11.1　概述 / 287
11.2　HotSpot虚拟机内的即时编译器 / 288
11.2.1　解释器与编译器 / 288
11.2.2　编译对象与触发条件 / 291
11.2.3　编译过程 / 294
11.2.4　查看与分析即时编译结果 / 297
11.3　编译优化技术 / 301
11.3.1　优化技术概览 / 301
11.3.2　公共子表达式消除 / 305
11.3.3　数组边界检查消除 / 307
11.3.4　方法内联 / 307
11.3.5　逃逸分析 / 309
11.4　Java与C/C++的编译器对比 / 311
11.5　本章小结 / 313
第五部分　高效并发
第12章　Java内存模型与线程 / 316
12.1　概述 / 316
12.2　硬件的效率与一致性 / 317
12.3　Java内存模型 / 318
12.3.1　主内存与工作内存 / 319
12.3.2　内存间交互操作 / 320
12.3.3　对于volatile型变量的特殊规则 / 322
12.3.4　对于long和double型变量的特殊规则 / 327
12.3.5　原子性、可见性与有序性 / 328
12.3.6　先行发生原则 / 330
12.4　Java与线程 / 333
12.4.1　线程的实现 / 333
12.4.2　Java线程调度 / 337
12.4.3　状态转换 / 339
12.5　本章小结 / 341
第13章　线程安全与锁优化 / 342
13.1　概述 / 342
13.2　线程安全 / 343
13.2.1　Java语言中的线程安全 / 343
13.2.2　线程安全的实现方法 / 348
13.3　锁优化 / 356
13.3.1　自旋锁与自适应自旋 / 356
13.3.2　锁消除 / 357
13.3.3　锁粗化 / 358
13.3.4　轻量级锁 / 358
13.3.5　偏向锁 / 361
13.4　本章小结 / 362
附录A　Java虚拟机家族 / 363
附录B　虚拟机字节码指令表 / 366
附录C　HotSpot虚拟机主要参数表 / 372
附录D　对象查询语言（OQL）简介 / 376
附录E　JDK历史版本轨迹 / 383
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Java虚拟机
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言程序设计
出版者的话
译者序
前言
第1章   计算机、程序和Java概述	1
1.1   引言	1
1.2   什么是计算机	1
1.2.1   中央处理器	2
1.2.2   内存	2
1.2.3   存储设备	3
1.2.4   输入和输出设备	3
1.2.5   通信设备	4
1.3   程序	4
1.4   操作系统	5
1.4.1   控制和监视系统的活动	6
1.4.2   分配和调遣系统资源	6
1.4.3   安排操作的顺序	6
1.5   Java、万维网以及其他	6
1.6   Java语言规范、API、JDK和IDE	8
1.7   一个简单的Java程序	8
1.8   创建、编译和执行Java程序	10
1.9   （GUI）在消息对话框中显示文本	12
关键术语	14
本章小结	15
复习题	15
编程练习题	17
第2章   基本程序设计	18
2.1   引言	18
2.2   编写简单的程序	18
2.3   从控制台读取输入	21
2.4   标识符	22
2.5   变量	23
2.6   赋值语句和赋值表达式	24
2.7   定名常量	24
2.8   数值数据类型及其运算	25
2.8.1   数值运算符	26
2.8.2   数值直接量	27
2.8.3   计算Java表达式	28
2.9   问题：显示当前时间	29
2.10   简捷运算符	31
2.11   数值类型转换	32
2.12   问题：计算贷款支付额	33
2.13   字符数据类型及运算	35
2.13.1   统一码和ASCII码	35
2.13.2   特殊字符的转义序列	36
2.13.3   字符型char数据与数值型数据
之间的转换	37
2.14  问题：整钱兑零	37
2.15   String类型	39
2.16   程序设计风格和文档	41
2.16.1   适当的注释和注释风格	41
2.16.2   命名习惯	41
2.16.3   适当的缩进和空白	41
2.16.4   块的风格	42
2.17   程序设计错误	42
2.17.1   语法错误	42
2.17.2   运行错误	43
2.17.3   逻辑错误	43
2.17.4   调试	43
2.18   （GUI）从输入对话框获取输入	44
2.18.1   将字符串转换为数字	44
2.18.2   使用输入对话框	44
关键术语	46
本章小结	46
复习题	47
编程练习题	50
第3章   选择	55
3.1   引言	55
3.2   boolean数据类型	55
3.3   问题：一个简单的数学学习工具	56
3.4   if语句 	57
3.5   问题：猜生日	58
3.6   双向if语句	61
3.7  嵌套的if语句	62
3.8   选择语句中的常见错误	63
3.9   问题：一个改进的数学学习工具	64
3.10   问题：计算身体质量指数	66
3.11   问题：计算税款	67
3.12   逻辑运算符	69
3.13   问题：判定闰年	71
3.14   问题：彩票	72
3.15   switch语句	74
3.16   条件表达式	75
3.17   格式化控制台输出	76
3.18   运算符的优先级和结合方向	77
3.19   （GUI）确认对话框	78
关键术语	80
本章小结	80
复习题	80
编程练习题	84
第4章   循环	90
4.1   引言	90
4.2   while循环	91
4.2.1   举例：猜数字	92
4.2.2   循环设计策略	94
4.2.3   问题：高级数学学习工具	94
4.2.4   使用标志值控制循环	96
4.2.5   输入和输出重定向	97
4.3   do-while循环	98
4.4   for循环	99
4.5   采用哪种循环	100
4.6   嵌套循环	101
4.7   最小化数值误差	102
4.8   实例学习	103
4.8.1   举例：求最大公约数	104
4.8.2   问题：预测未来学费	105
4.8.3   问题：蒙特卡罗模拟	105
4.9   关键字break和continue	106
4.10   （GUI）使用确认对话框控制循环	110
关键术语	111
本章小结	111
复习题	112
编程练习题	116
第5章   方法	123
5.1   引言	123
5.2   定义方法	124
5.3   调用方法	125
5.4   void方法举例	127
5.5   参数的值传递	129
5.6   模块化代码	130
5.7   问题：将十进制数转换为十六进制数	132
5.8   重载方法	134
5.9   变量的作用域	136
5.10   Math数学类	136
5.10.1   三角函数方法	137
5.10.2   指数函数方法	137
5.10.3   取整方法	138
5.10.4   min、max和abs方法	138
5.10.5   random方法	139
5.11   实例学习：生成随机字符	139
5.12   方法抽象和逐步求精	141
5.12.1   自顶向下的设计	141
5.12.2   自顶向下和自底向上的实现	143
5.12.3   实现细节	144
关键术语	146
本章小结	147
复习题	147
编程练习题	150
第6章   一维数组	157
6.1   引言	157
6.2   数组的基本知识	158
6.2.1   声明数组变量	158
6.2.2   创建数组	158
6.2.3   数组大小和默认值	159
6.2.4   数组下标变量	159
6.2.5   数组初始化语法	160
6.2.6   处理数组	160
6.2.7   for-each循环	161
6.3   问题：乐透号码	162
6.4   问题：一副牌	164
6.5   数组的复制	166
6.6   给方法传递数组	167
6.7   从方法中返回数组	169
6.8   可变长参数列表	172
6.9   数组的查找	172
6.9.1   线性查找法	173
6.9.2   二分查找法	173
6.10   数组的排序	175
6.10.1   选择排序	175
6.10.2   插入排序	177
6.11   Arrays类	178
关键术语	179
本章小结	179
复习题	180
编程练习题	182
第7章   多维数组	188
7.1   引言	188
7.2   二维数组的基础知识	188
7.2.1   声明二维数组变量并创建
二维数组	188
7.2.2   获取二维数组的长度	189
7.2.3   锯齿数组	190
7.3   处理二维数组	190
7.4   给方法传递二维数组	192
7.5   问题：多选题测验评分	192
7.6   问题：找出距离最近的点对	194
7.7   问题：九宫格	195
7.8   多维数组	198
7.8.1   问题：每日温度和湿度	199
7.8.2   问题：猜生日	200
本章小结	201
复习题	201
编程练习题	202
第8章   对象和类	210
8.1   引言	210
8.2   定义对象的类	210
8.3   举例：定义类和创建对象	212
8.4   使用构造方法构造对象	216
8.5   通过引用变量访问对象	216
8.5.1   引用变量和引用类型	216
8.5.2   访问对象的数据和方法	217
8.5.3   引用数据域和null值	217
8.5.4   基本类型变量和引用类型
变量的区别	218
8.6   使用Java库中的类	219
8.6.1   Date类	219
8.6.2   Random类	219
8.6.3   显示GUI组件	220
8.7   静态变量、常量和方法	222
8.8   可见性修饰符	225
8.9   数据域封装	227
8.10   给方法传递对象参数	229
8.11   对象数组	230
关键术语	232
本章小结	232
复习题	233
编程练习题	237
第9章   字符串和文本I/O	241
9.1   引言	241
9.2   字符串类String	241
9.2.1   构造一个字符串	241
9.2.2   不可变字符串与限定字符串	242
9.2.3   字符串的比较	242
9.2.4   字符串长度、字符以及组合
字符串	243
9.2.5   获取子串	244
9.2.6   字符串的转换、替换和分隔	245
9.2.7   依照模式匹配、替换和分隔	246
9.2.8   找出字符串中的某个字符或者
某个子串	246
9.2.9   字符串与数组之间的转换	247
9.2.10   将字符和数值转换成字符串	247
9.2.11   格式化字符串	248
9.2.12   问题：检测回文串	248
9.2.13   问题：将十六进制转换为十进制	249
9.3   字符类Character	250
9.4   StringBuilder/StringBuffer类	252
9.4.1   修改StringBuilder中的字符串	253
9.4.2   toString、capacity、length、setLength和charAt方法	254
9.4.3   问题：忽略既非字母又非数字的
字符，判断回文串	255
9.5   命令行参数	256
9.5.1   向main方法传递字符串	257
9.5.2   问题：计算器	257
9.6   文件类File	258
9.7   文件输入和输出	260
9.7.1   使用PrintWriter写数据	261
9.7.2   使用Scanner读数据	262
9.7.3   Scanner如何工作	263
9.7.4   问题：替换文本	263
9.8   （GUI）文件对话框	264
本章小结	265
复习题	266
编程练习题	270
第10章   关于对象的思考	276
10.1   引言	276
10.2   不可变对象和类	276
10.3   变量的作用域	277
10.4   this引用	278
10.5   类的抽象和封装	279
10.6   面向对象的思考	282
10.7   对象的组合	284
10.8   设计类Course	286
10.9   设计堆栈类	287
10.10   设计GuessDate类	290
10.11   类的设计原则	292
10.11.1   内聚性	292
10.11.2   一致性	292
10.11.3   封装性	292
10.11.4   清晰性	292
10.11.5   完整性	293
10.11.6   实例和静态	293
关键术语	293
本章小结	294
复习题	294
编程练习题	295
第11章   继承和多态	301
11.1   引言	301
11.2   父类和子类	301
11.3   使用super关键字	306
11.3.1   调用父类的构造方法	306
11.3.2   构造方法链	307
11.3.3   调用父类的方法	308
11.4   覆盖方法	309
11.5   覆盖和重载	309
11.6   对象类Object和它的toString()
方法	310
11.7   多态	310
11.8   动态绑定	311
11.9   对象转换和instanceof运算符	312
11.10   Object的equals方法	314
11.11   数组线性表ArrayList类	315
11.12   自定义栈类	318
11.13   protected数据和方法	319
11.14   防止扩展和覆盖	320
关键术语	320
本章小结	321
复习题	321
编程练习题	326
第12章   图形用户界面基础	328
12.1   引言	328
12.2   Swing和AWT 	328
12.3   Java GUI API	329
12.3.1   组件类	329
12.3.2   容器类	329
12.3.3   GUI辅助类	330
12.4   框架	330
12.4.1   创建一个框架	330
12.4.2   向框架中添加组件	331
12.5   布局管理器	332
12.5.1   FlowLayout	333
12.5.2   GridLayout	334
12.5.3   BorderLayout	336
12.5.4   布局管理器的属性	337
12.6   使用面板作为子容器	337
12.7   Color类	339
12.8   Font类	339
12.9   Swing GUI组件的公共特性	340
12.10   图像图标	342
关键术语	343
本章小结	343
复习题	344
编程练习题	346
第13章   异常处理	348
13.1   引言	348
13.2   异常处理概述	348
13.3   异常处理的优势	351
13.4   异常类型	353
13.5   关于异常处理的更多知识	354
13.5.1   声明异常	355
13.5.2   抛出异常	355
13.5.3   捕获异常	355
13.5.4   从异常中获取信息	357
13.5.5   举例：声明、抛出和捕获异常	358
13.6   finally子句	360
13.7   何时使用异常	361
13.8   重新抛出异常	361
13.9   链式异常	362
13.10   创建自定制异常类	362
关键术语	364
本章小结	364
复习题	364
编程练习题	368
第14章   抽象类和接口	370
14.1   引言	370
14.2   抽象类	370
14.2.1   为什么要用抽象方法	372
14.2.2   关于抽象类的几个关注点	374
14.3   举例：日历类Calendar和公历类GregorianCalendar	374
14.4   接口	376
14.5   举例：Comparable接口	378
14.6   举例：ActionListener接口	380
14.7   举例：Cloneable接口	381
14.8   接口与抽象类	384
14.9   将基本数据类型值作为对象处理	386
14.10   举例：对一个对象数组排序	388
14.11   基本类型和包装类类型之间的
自动转换	390
14.12   BigInteger和BigDecimal类	390
14.13   实例学习：Rational类	391
关键术语	395
本章小结	395
复习题	396
编程练习题	399
第15章   图形	402
15.1   引言	402
15.2   图形坐标系	402
15.3   Graphics类	403
15.4   绘制字符串、直线、矩形和椭圆	405
15.5   实例学习：FigurePanel类	406
15.6   绘制弧形	409
15.7   绘制多边形和折线段	410
15.8   使用FontMetrics类居中显示
字符串	413
15.9   实例学习：MessagePanel类	414
15.10   实例学习：StillClock类	418
15.11   显示图像	422
15.12   实例学习：ImageViewer类	423
本章小结	425
复习题	426
编程练习题	427
第16章   事件驱动程序设计	432
16.1   引言	432
16.2   事件和事件源	432
16.3   监听器、注册以及处理事件	434
16.4   内部类	438
16.5   匿名类监听器	439
16.6   定义监听器类的另一种方式	441
16.7   问题：贷款计算器	443
16.8   窗口事件	444
16.9   监听器接口适配器	446
16.10   鼠标事件	447
16.11   按键事件	449
16.12   使用Timer类的动画	451
关键术语	454
本章小结	454
复习题	455
编程练习题	456
第17章   创建图形用户界面	462
17.1   引言	462
17.2   按钮	463
17.2.1   图标、按下图标和翻转图标	463
17.2.2   对齐方式	464
17.2.3   文本位置	465
17.2.4   使用按钮	465
17.3   复选框	467
17.4   单选按钮	470
17.5   标签	472
17.6   文本域	473
17.7   文本区域	475
17.8   组合框	478
17.9   列表框	481
17.10   滚动条	484
17.11   滑块	486
17.12   创建多个窗口	489
本章小结	492
复习题	492
编程练习题	493
第18章   applet和多媒体	498
18.1   引言	498
18.2   开发applet	499
18.3   HTML文件和<applet>标记	499
18.3.1   从Web浏览器查看applet	501
18.3.2   使用applet查看器工具查看applet	501
18.4   applet安全限制	501
18.5   让applet像应用程序一样运行	502
18.6   applet生命周期方法	503
18.6.1   init方法	503
18.6.2   start方法	503
18.6.3   stop方法	503
18.6.4   destroy方法	503
18.7   给applet传递字符串	504
18.8   实例学习：弹跳的小球	507
18.9   实例学习：井字游戏	510
18.10   使用URL类定位资源	513
18.11   在任意Java程序中播放音频	515
18.12   实例学习：多媒体动画	516
关键术语	518
本章小结	518
复习题	519
编程练习题	520
第19章   二进制I/O	527
19.1   引言	527
19.2   在Java中如何处理输入/输出	527
19.3   文本I/O与二进制I/O	528
19.4   二进制I/O类	529
19.4.1   FileInputStream类和FileOutputStream类	530
19.4.2   FilterInputStream类和FilterOutputStream类	532
19.4.3   DataInputStream类和DataOutputStream类	532
19.4.4   BufferedInputStream类和BufferedOutputStream类	535
19.5   问题：复制文件	536
19.6   对象的输入/输出	537
19.6.1   可序列化接口Serializable	539
19.6.2   序列化数组	540
19.7   随机访问文件	541
关键术语	544
本章小结	544
复习题	544
编程练习题	547
第20章   递归	550
20.1   引言	550
20.2   问题：计算阶乘	550
20.3   问题：计算斐波那契数	553
20.4   使用递归解决问题	554
20.5   递归的辅助方法	556
20.5.1   选择排序	556
20.5.2   二分查找	557
20.6   问题：求出目录的大小	558
20.7   问题：汉诺塔	559
20.8   问题：分形	562
20.9   问题：八皇后	564
20.10   递归与迭代	567
20.11   尾递归	567
关键术语	568
本章小结	568
复习题	568
编程练习题	569
附录A   Java关键字	575
附录B   ASCII码字符集	576
附录C   运算符优先级表	577
附录D   Java修饰符	578
附录E   特殊浮点值	579
附录F   数系	580
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JAVA核心技术（卷1）
第1章 Java程序设计概述
1.1 Java程序设计平台
1.2 Java“白皮书”的关键术语
1.2.1 简单性
1.2.2 面向对象
1.2.3 网络技能
1.2.5 安全性
1.2.6 体系结构中立
1.2.7 可移植性
1.2.8 解释型
1.2.9 高性能
1.2.10 多线程
1.2.11 动态性
1.3 Java Appletc与Internet
1.4 Java发展简史
1.5 关于Java的常见误解
第2章 Java程序设计环境
2.1 安装Java开发工具箱
2.1.1 下载JDK
2.1.2 设置执行路径
2.1.3 安装源代码库和文档
2.1.4 安装本书中的示例
2.1.5 导航Java目录
2.2 选择开发环境
2.3 使用命令行工具
2.4 使用集成开发环境
2.5 运行图形化应用程序
2.6 建立并运行appletc
第3章 Java基本的程序设计结构
3.1 一个简单的Java应用程序
3.2 注释
3.3 数据类型
3.3.1 整型
3.3.2 浮点类型
3.3.3 char类型
3.3.4 boolean类型
3.4 变量
3.4.1 变量初始化
3.4.2 常量
3.5 运算符
3.5.1 自增运算符与自减运算符
3.5.2 关系运算符与boolean运算符
3.5.4 数学函数与常量
3.5.5 数值类型之间的转换
3.5.6 强制类型转换
3.5.7 括号与运算符级别
3.5.8 枚举类型
3.6 字符串
3.6.1 子串
3.6.2 拼接
3.6.3 不可变字符串
3.6.4 检测字符串是否相等
3.6.5 代码点与代码单元
3.6.6 字符串API
3.6.7 阅读联机API文档
3.6.8 构建字符串
3.7 输入输出
3.7.1 读取输入
3.7.2 格式化输出
3.7.3 文件输入与输出
3.8 控制流程
3.8.1 块作用域
3.8.2 条件语句
3.8.3 循环
3.8.4 确定循环
3.8.5 多重选择：switch语句
3.8.6 中断控制流程语句
3.9 大数值
3.10 数组
3.10.1 Forceh循环
3.10.2 数组初始化以及匿名数组
3.10.4 命令行参数
3.10.5 数组排序
3.10.6 多维数组
3.10.7 不规则数组
第4章 对象与类
4.1 面向对象程序设计概述
4.1.1 类
4.1.2 对象
4.1.3 识别类
4.1.4 类之间的关系
4.2 使用现有类
4.2.1 对象与对象变量
4.2.2 Java类库中的GregorianCalendar类
4.2.3 更改器方法与访问器方法
4.3 用户自定义类
4.3.1 一个Employee类
4.3.2 多个源文件的使用
4.3.3 解析Employee类
4.3.4 从构造器开始
4.3.5 隐式参数与显式参数
4.3.6 封装的优点
4.3.7 基于类的访问权限
4.3.8 私有方法
4.3.9 Final实例域
4.4 静态域与静态方法
4.4.1 静态域
4.4.2 静态常量
4.4.3 静态方法
4.4.4 Ftory方法
4.4.5 Main方法
4.5 方法参数
4.6 对象构造
4.6.1 重载
4.6.2 默认域初始化
4.6.3 默认构造器
4.6.4 显式域初始化
4.6.5 参数名
4.6.6 调用另一个构造器
4.6.7 初始化块
4.6.8 对象析构与finalize方法
4.7 包
4.7.1 类的导入
4.7.2 静态导入
4.7.3 将类放入包中
4.7.4 包作用域
4.8 类路径
4.9 文档注释
4.9.1 注释的插入
4.9.2 类注释
4.9.3 方法注释
4.9.4 域注释
4.9.5 通用注释
4.9.6 包与概述注释
4.9.7 注释的抽取
4.10 类设计技巧
第5章 继承
5.1 类.c超类和子类
5.1.1 继承层次
5.1.2 多态
5.1.3 动态绑定
5.1.4 阻止继承：final类和方法
5.1.5 强制类型转换
5.1.6 抽象类
5.1.7 受保护访问
5.2 Object：所有类的超类
5.2.1 Equals方法
5.2.2 相等测试与继承
5.2.3 HashCode方法
5.2.4 ToString方法
5.3 泛型数组列表
5.3.1 访问数组列表元素
5.3.2 类型化与原始数组列表的兼容性
5.4 对象包装器与自动打包
5.5 参数数量可变的方法
5.6 枚举类
5.7 反射
5.7.1 Class类
5.7.2 捕获异常
5.7.3 利用反射分析类的能力
5.7.4 在运行时使用反射分析对象
5.7.5 使用反射编写泛型数组代码
5.7.6 方法指针
5.8 继承设计的技巧
第6章 接口与内部类
6.1 接口
6.1.1 接口的特性
6.1.2 接口与抽象类
6.2 对象克隆
6.3 接口与回调
6.4 内部类
6.4.1 使用内部类访问对象状态
6.4.2 内部类的特殊语法规则
6.4.3 内部类是否有用、必要和安全
6.4.4 局部内部类
6.4.5 由外部方法访问final变量
6.4.6 匿名内部类
6.4.7 静态内部类
6.5 代理
第7章 图形程序设计
7.1 Swing概述
7.2 创建框架
7.3 框架定位
7.4 框架属性
7.5 决定框架大小
7.6 在组件中显示信息
7.7 2D图形
7.8 颜色
7.9 为文本设定特殊字体
7.10 图像
第8章 事件处理
8.1 事件处理基础
8.1.1 实例：处理按钮点击事件
8.1.2 建议使用内部类
8.1.3 创建包含一个方法调用的监听器
8.1.4 实例：改变观感
8.1.5 适配器类
8.2 动作
8.3 鼠标事件　8.4 AWT事件继承层次
第9章 Swing用户界面组件
9.1 Swing和模型-视图-控制器设计模式
9.1.1 设计模式
9.1.2 模型-视图-控制器模式
9.1.3 Swing按钮的模型-视图-控制器分析
9.2 布局管理器概述
9.2.1 边框布局
9.2.2 网格布局
9.3 文本输入
9.3.1 文本域
9.3.2 标签和标签组件
9.3.3 密码域
9.3.4 文本区
9.3.5 滚动窗格
9.4 选择组件
9.4.1 复选框
9.4.2 单选按钮
9.4.3 边框
9.4.4 组合框
9.4.5 滑块
9.5 菜单
9.5.1 菜单创建
9.5.2 菜单项中的图标
9.5.3 复选框和单选按钮菜单项
9.5.4 弹出菜单
9.5.5 快捷键和加速器
9.5.6 启用和禁用菜单项
9.5.7 工具栏
9.5.8 工具提示
9.6 复杂的布局管理
9.6.1 网格组布局
9.6.2 组布局
9.6.3 不使用布局管理器
9.6.4 定制布局管理器
9.6.5 遍历顺序
9.7 对话框
9.7.1 选项对话框
9.7.2 创建对话框
9.7.3 数据交换
9.7.4 文件对话框
9.7.5 颜色选择器
第10章 部署应用程序和applet
10.1 JAR文件
10.1.1 清单文件
10.1.2 可运行JAR文件
10.1.3 资源
10.1.4 密封
10.2 Java WebcStart
10.2.1 沙箱
10.2.2 签名代码
10.2.3 JNLPcAPI
10.3 Applet
10.3.1 一个简单的capplet
10.3.2 将应用程序转换为applet
10.3.3 Applet的HTMLc标记和属性
10.3.4 Objectc标记
10.3.5 使用参数向applet传递信息
10.3.6 访问图像和音频文件
10.3.7 Applet上下文
10.4 应用程序存储的配置
10.4.1 属性映射
10.4.2 PreferencescAPI
第11章 异常、日志、断言和调试
11.1 处理异常
11.1.1 异常分类
11.1.2 声明已检查异常
11.1.3 如何抛出异常
11.1.4 创建异常类
11.2 捕获异常
11.2.1 捕获多个异常
11.2.2 再次抛出异常与异常链
11.2.3 Finally子句
11.2.4 分析堆栈跟踪元素
11.3 使用异常机制的建议
11.4 断言
11.4.1 启用和禁用断言
11.4.2 使用断言的建议
11.4.3 为文档使用断言
11.5 记录日志
11.5.1 基本日志
11.5.2 高级日志
11.5.3 修改日志管理器配置
11.5.4 本地化
11.5.5 处理器
11.5.6 过滤器
11.5.7 格式化器
11.5.8 日志记录说明
11.6 调试技术
11.6.1 使用控制台窗口
11.6.2 跟踪AWT事件
11.6.3 AWT的Robot类
11.7 使用调试器
第12章 泛型程序设计
12.1 为什么要使用泛型程序设计
12.2 简单泛型类的定义
12.4 类型变量的限定
12.5 泛型代码和虚拟机
12.5.1 翻译泛型表达式
12.5.2 翻译泛型方法
12.5.3 调用遗留代码
12.6 约束与局限性
12.6.1 不能用基本类型实例化类型参数
12.6.2 运行时类型查询只适用于原始类型
12.6.3 不能抛出也不能捕获泛型类实例
12.6.4 参数化类型的数组不合法
12.6.5 不能实例化类型变量
12.6.6 泛型类的静态上下文中类型变量无效
12.6.7 注意擦除后的冲突
12.7 泛型类型的继承规则
12.8 通配符类型
12.8.1 通配符的超类型限定
12.8.2 无限定通配符
12.8.3 通配符捕获
12.9 反射和泛型
12.9.1 使用ClasscTc参数进行类型匹配
第13章 集合　13.1 集合接口
13.1.1 将集合的接口与实现分离
13.1.2 Java类库中的集合接口和迭代器接口
13.2 具体的集合
13.2.1 链表
13.2.2 数组列表
13.2.3 散列集
13.2.4 树集
13.2.5 对象的比较
13.2.6 队列与双端队列
13.2.7 优先级队列
13.2.8 映射表
13.2.9 专用集与映射表类
13.3 集合框架
13.3.1 视图与包装器
13.3.2 批操作
13.3.3 集合与数组之间的转换
13.4 算法
13.4.1 排序与混排
13.4.2 二分查找
13.4.3 简单算法
13.4.4 编写自己的算法
13.5 遗留的集合
13.5.1 Hashtablec类
13.5.2 枚举
13.5.3 属性映射表
13.5.4 栈
13.5.5 位集
第14章 多线程
14.1 线程的概念
14.2 中断线程
14.3 线程状态
14.3.1 新生线程
14.3.2 可运行线程
14.3.3 被阻塞线程和等待线程
14.3.4 被终止的线程
14.4 线程属性
14.4.1 线程优先级
14.4.2 守护线
14.4.3 未捕获异常处理器
14.5 同步
14.5.1 竞争条件的一个例子
14.5.2 详解竞争条件
14.5.3 锁对象
14.5.4 条件对象
14.5.5 synchronized关键字
14.5.6 同步阻塞
14.5.7 监视器概念
14.5.8 Volatile域
14.5.9 死锁
14.5.10 锁测试与超时
14.5.11 读/写锁
14.5.12 为什么弃用stop和suspend方法
14.7 线程安全的集合
14.7.1 高效的映像.c集合和队列
14.7.2 写数组的拷贝
14.7.3 旧的线程安全的集合
14.8 Callable与Future
14.9 执行器
14.9.1 线程池
14.9.2 预定执行
14.9.3 控制任务组
14.10 同步器
14.10.1 信号量
14.10.2 倒计时门栓
14.10.3 障栅
14.10.4 交换器
14.10.5 同步队列
14.10.6 例子：暂停动画与恢复动画
14.11 线程与Swing
14.11.1 运行耗时的任务
14.11.2 使用Swing工作器
14.11.3 单一线程规则
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JAVA核心技术（卷1）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入Java虚拟机(原书第2版)
译者序
前言
第1章 Java体系结构介绍
第2章 平台无关
第3章 安全
第4章 网络移动性
第5章 Java虚拟机
第6章 Java class文件
第7章 类型的生命周期
第8章 连接模型
第9章 垃圾收集
第10章 栈和局部变量操作
第11章 类型转换
第12章 整数运算
第13章 逻辑运算
第14章 浮点运算
第15章 对象和数组
第16章 控制流
第17章 异常
第18章 finally子句
第19章 方法的调用与返回
第20章 指令invokespecial
第21章 线程同步
附录A 按操作码助记符排列的指令集
附录B 按功能排列的操作码助记符
附录C 按操作码字节值排列的操作码助记符
附录D Java虚拟机的一个模拟：“Slices of Pi”
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入Java虚拟机(原书第2版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java核心技术·卷1：基础知识（原书第9版）
译者序
前言
致谢
第1章 Java程序设计概述
1.1 Java程序设计平台
1.2 Java“白皮书”的关键术语
1.2.1 简单性
1.2.2 面向对象
1.2.3 网络技能
1.2.4 健壮性
1.2.5 安全性
1.2.6 体系结构中立
1.2.7 可移植性
1.2.8 解释型
1.2.9 高性能
1.2.10 多线程
1.2.11 动态性
1.3 Java applet与Internet
1.4 Java发展简史
1.5 关于Java的常见误解
第2章 Java程序设计环境
2.1 安装Java开发工具箱
2.1.1 下载JDK
2.1.2 设置执行路径
2.1.3 安装库源文件和文档
2.1.4 安装本书中的示例
2.1.5 导航Java目录
2.2 选择开发环境
2.3 使用命令行工具
2.4 使用集成开发环境
2.5 运行图形化应用程序
2.6 建立并运行applet
第3章 Java的基本程序设计结构
3.1 一个简单的Java应用程序
3.2 注释
3.3 数据类型
3.3.1 整型
3.3.2 浮点类型
3.3.3 char类型
3.3.4 boolean类型
3.4 变量
3.4.1 变量初始化
3.4.2 常量
3.5 运算符
3.5.1 自增运算符与自减运算符
3.5.2 关系运算符与boolean运算符
3.5.3 位运算符
3.5.4 数学函数与常量
3.5.5 数值类型之间的转换
3.5.6 强制类型转换
3.5.7 括号与运算符级别
3.5.8 枚举类型
3.6 字符串
3.6.1 子串
3.6.2 拼接
3.6.3 不可变字符串
3.6.4 检测字符串是否相等
3.6.5 空串与Null串
3.6.6 代码点与代码单元
3.6.7 字符串API
3.6.8 阅读联机API文档
3.6.9 构建字符串
3.7 输入输出
3.7.1 读取输入
3.7.2 格式化输出
3.7.3 文件输入与输出
3.8 控制流程
3.8.1 块作用域
3.8.2 条件语句
3.8.3 循环
3.8.4 确定循环
3.8.5 多重选择：switch语句
3.8.6 中断控制流程语句
3.9 大数值
3.10 数组
3.10.1 for each循环
3.10.2 数组初始化以及匿名数组
3.10.3 数组拷贝
3.10.4 命令行参数
3.10.5 数组排序
3.10.6 多维数组
3.10.7 不规则数组
第4章 对象与类
4.1 面向对象程序设计概述
4.1.1 类
4.1.2 对象
4.1.3 识别类
4.1.4　类之间的关系
4.2 使用预定义类
4.2.1 对象与对象变量
4.2.2 Java类库中的Gregorian-Calendar类
4.2.3 更改器方法与访问器方法
4.3 用户自定义类
4.3.1 Employee类
4.3.2 多个源文件的使用
4.3.3 剖析Employee类
4.3.4 从构造器开始
4.3.5 隐式参数与显式参数
4.3.6 封装的优点
4.3.7 基于类的访问权限
4.3.8 私有方法
4.3.9 final实例域
4.4 静态域与静态方法
4.4.1 静态域
4.4.2 静态常量
4.4.3 静态方法
4.4.4 工厂方法
4.4.5 main方法
4.5 方法参数
4.6 对象构造
4.6.1 重载
4.6.2 默认域初始化
4.6.3 无参数的构造器
4.6.4 显式域初始化
4.6.5 参数名
4.6.6 调用另一个构造器
4.6.7 初始化块
4.6.8 对象析构与finalize方法
4.7 包
4.7.1 类的导入
4.7.2 静态导入
4.7.3 将类放入包中
4.7.4 包作用域
4.8 类路径
4.9 文档注释
4.9.1 注释的插入
4.9.2 类注释
4.9.3 方法注释
4.9.4 域注释
4.9.5 通用注释
4.9.6 包与概述注释
4.9.7 注释的抽取
4.10 类设计技巧
第5章 继承
5.1 类、超类和子类
5.1.1 继承层次
5.1.2 多态
5.1.3 动态绑定
5.1.4 阻止继承：final类和方法
5.1.5 强制类型转换
5.1.6 抽象类
5.1.7 受保护访问
5.2 Object：所有类的超类
5.2.1 equals方法
5.2.2 相等测试与继承
5.2.3 hashCode方法
5.2.4 toString方法
5.3 泛型数组列表
5.3.1 访问数组列表元素
5.3.2 类型化与原始数组列表的兼容性
5.4 对象包装器与自动装箱
5.5 参数数量可变的方法
5.6 枚举类
5.7 反射
5.7.1 Class类
5.7.2 捕获异常
5.7.3 利用反射分析类的能力
5.7.4 在运行时使用反射分析对象
5.7.5 使用反射编写泛型数组代码
5.7.6 调用任意方法
5.8 继承设计的技巧
第6章 接口与内部类
6.1 接口
6.1.1 接口的特性
6.1.2 接口与抽象类
6.2 对象克隆
6.3 接口与回调
6.4 内部类
6.4.1 使用内部类访问对象状态
6.4.2 内部类的特殊语法规则
6.4.3 内部类是否有用、必要和安全
6.4.4 局部内部类
6.4.5 由外部方法访问final变量
6.4.6 匿名内部类
6.4.7 静态内部类
6.5 代理
第7章 图形程序设计
7.1 Swing概述
7.2 创建框架
7.3 框架定位
7.3.1 框架属性
7.3.2 确定合适的框架大小
7.4 在组件中显示信息
7.5 处理2D图形
7.6 使用颜色
7.7 文本使用特殊字体
7.8 显示图像
第8章 事件处理
8.1 事件处理基础
8.1.1 实例：处理按钮点击事件
8.1.2 建议使用内部类
8.1.3 创建包含一个方法调用的监听器
8.1.4 实例：改变观感
8.1.5 适配器类
8.2 动作
8.3 鼠标事件
8.4 AWT事件继承层次
第9章 Swing用户界面组件
9.1 Swing和模型-视图-控制器设计模式
9.1.1 设计模式
9.1.2 模型-视图-控制器模式
9.1.3 Swing按钮的模型-视图-控制器分析
9.2 布局管理概述
9.2.1 边框布局
9.2.2 网格布局
9.3 文本输入
9.3.1 文本域
9.3.2 标签和标签组件
9.3.3 密码域
9.3.4 文本区
9.3.5 滚动窗格
9.4 选择组件
9.4.1 复选框
9.4.2 单选按钮
9.4.3 边框
9.4.4 组合框
9.4.5 滑动条
9.5 菜单
9.5.1 菜单创建
9.5.2 菜单项中的图标
9.5.3 复选框和单选按钮菜单项
9.5.4 弹出菜单
9.5.5 快捷键和加速器
9.5.6 启用和禁用菜单项
9.5.7 工具栏
9.5.8 工具提示
9.6 复杂的布局管理
9.6.1 网格组布局
9.6.2 组布局
9.6.3 不使用布局管理器
9.6.4 定制布局管理器
9.6.5 遍历顺序
9.7 对话框
9.7.1 选项对话框
9.7.2 创建对话框
9.7.3 数据交换
9.7.4 文件对话框
9.7.5 颜色选择器
第10章 部署应用程序和applet
10.1 JAR文件
10.1.1 清单文件
10.1.2 可运行JAR文件
10.1.3 资源
10.1.4 密封
10.2 Java Web Start
10.2.1 沙箱
10.2.2 签名代码
10.2.3 JNLP API
10.3 applet
10.3.1 一个简单的applet
10.3.2 applet的HTML标记和属性
10.3.3 object标记
10.3.4 使用参数向applet传递信息
10.3.5 访问图像和音频文件
10.3.6 applet上下文
10.4 应用程序首选项存储
10.4.1 属性映射
10.4.2 Preferences API
第11章 异常、断言、日志和调试
11.1 处理错误
11.1.1 异常分类
11.1.2 声明已检查异常
11.1.3 如何抛出异常
11.1.4 创建异常类
11.2 捕获异常
11.2.1 捕获多个异常
11.2.2 再次抛出异常与异常链
11.2.3 finally子句
11.2.4 带资源的try语句
11.2.5 分析堆栈跟踪元素
11.3 使用异常机制的技巧
11.4 使用断言
11.4.1 启用和禁用断言
11.4.2 使用断言完成参数检查
11.4.3 为文档假设使用断言
11.5 记录日志
11.5.1 基本日志
11.5.2 高级日志
11.5.3 修改日志管理器配置
11.5.4 本地化
11.5.5 处理器
11.5.6 过滤器
11.5.7 格式化器
11.5.8 日志记录说明
11.6 调试技巧
11.7 GUI程序排错技巧
11.8 使用调试器
第12章 泛型程序设计
12.1 为什么要使用泛型程序设计
12.2 定义简单泛型类
12.3 泛型方法
12.4 类型变量的限定
12.5 泛型代码和虚拟机
12.5.1 翻译泛型表达式
12.5.2 翻译泛型方法
12.5.3 调用遗留代码
12.6 约束与局限性
12.6.1 不能用基本类型实例化类型参数
12.6.2 运行时类型查询只适用于原始类型
12.6.3 不能创建参数化类型的数组
12.6.4 Varargs警告
12.6.5 不能实例化类型变量
12.6.6 泛型类的静态上下文中类型变量无效
12.6.7 不能抛出或捕获泛型类的实例
12.6.8 注意擦除后的冲突
12.7 泛型类型的继承规则
12.8 通配符类型
12.8.1 通配符的超类型限定
12.8.2 无限定通配符
12.8.3 通配符捕获
12.9 反射和泛型
12.9.1 使用Class参数进行类型匹配
12.9.2 虚拟机中的泛型类型信息
第13章 集合
13.1 集合接口
13.1.1 将集合的接口与实现分离
13.1.2 Java类库中的集合接口和迭代器接口
13.2 具体的集合
13.2.1 链表
13.2.2 数组列表
13.2.3 散列集
13.2.4 树集
13.2.5 对象的比较
13.2.6 队列与双端队列
13.2.7 优先级队列
13.2.8 映射表
13.2.9 专用集与映射表类
13.3 集合框架
13.3.1 视图与包装器
13.3.2 批操作
13.3.3 集合与数组之间的转换
13.4 算法
13.4.1 排序与混排
13.4.2 二分查找
13.4.3 简单算法
13.4.4 编写自己的算法
13.5 遗留的集合
13.5.1 Hashtable类
13.5.2 枚举
13.5.3 属性映射表
13.5.4 栈
13.5.5 位集
第14章 多线程
14.1 什么是线程
14.2 中断线程
14.3 线程状态
14.3.1 新创建线程
14.3.2 可运行线程
14.3.3 被阻塞线程和等待线程
14.3.4 被终止的线程
14.4 线程属性
14.4.1 线程优先级
14.4.2 守护线程
14.4.3 未捕获异常处理器
14.5 同步
14.5.1 竞争条件的一个例子
14.5.2 竞争条件详解
14.5.3 锁对象
14.5.4 条件对象
14.5.5 synchronized关键字
14.5.6 同步阻塞
14.5.7 监视器概念
14.5.8 Volatile域
14.5.9 final变量
14.5.10 原子性
14.5.11 死锁
14.5.12 线程局部变量
14.5.13 锁测试与超时
14.5.14 读/写锁
14.5.15 为什么弃用stop和suspend方法
14.6 阻塞队列
14.7 线程安全的集合
14.7.1 高效的映射表、集合和队列
14.7.2 写数组的拷贝
14.7.3 较早的线程安全集合
14.8 Callable与Future
14.9 执行器
14.9.1 线程池
14.9.2 预定执行
14.9.3 控制任务组
14.9.4 Fork-Join框架
14.10 同步器
14.10.1 信号量
14.10.2 倒计时门栓
14.10.3 障栅
14.10.4 交换器
14.10.5 同步队列
14.11 线程与Swing
14.11.1 运行耗时的任务
14.11.2 使用Swing工作线程
14.11.3 单一线程规则
附录　Java关键字
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java核心技术·卷1：基础知识（原书第9版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大型网站系统与Java中间件开发实践
第1章  分布式系统介绍	1
1.1  初识分布式系统	1
1.1.1  分布式系统的定义	1
1.1.2  分布式系统的意义	3
1.2  分布式系统的基础知识	5
1.2.1  组成计算机的5要素	5
1.2.2  线程与进程的执行模式	6
1.2.3  网络通信基础知识	13
1.2.4  如何把应用从单机扩展到分布式	18
1.2.5  分布式系统的难点	31
第2章  大型网站及其架构演进过程	35
2.1  什么是大型网站	35
2.2  大型网站的架构演进	37
2.2.1  用Java技术和单机来构建的网站	37
2.2.2  从一个单机的交易网站说起	38
2.2.3  单机负载告警，数据库与应用分离	40
2.2.4  应用服务器负载告警，如何让应用服务器走向集群	41
2.2.5  数据读压力变大，读写分离吧	50
2.2.6  弥补关系型数据库的不足，引入分布式存储系统	56
2.2.7  读写分离后，数据库又遇到瓶颈	58
2.2.8  数据库问题解决后，应用面对的新挑战	60
2.2.9  初识消息中间件	63
2.2.10  总结	64
第3章  构建Java中间件	67
3.1  Java中间件的定义	67
3.2  构建Java中间件的基础知识	68
3.2.1  跨平台的Java运行环境——JVM	69
3.2.2  垃圾回收与内存堆布局	70
3.2.3  Java并发编程的类、接口和方法	72
3.2.4  动态代理	89
3.2.5  反射	91
3.2.6  网络通信实现选择	93
3.3  分布式系统中的Java中间件	94
第4章  服务框架	97
4.1  网站功能持续丰富后的困境与应对	97
4.2  服务框架的设计与实现	100
4.2.1  应用从集中式走向分布式所遇到的问题	100
4.2.2  透过示例看服务框架原型	101
4.2.3  服务调用端的设计与实现	107
4.2.4  服务提供端的设计与实现	132
4.2.5  服务升级	137
4.3  实战中的优化	138
4.4  为服务化护航的服务治理	142
4.5  服务框架与ESB的对比	146
4.6  总结	147
第5章  数据访问层	149
5.1  数据库从单机到分布式的挑战和应对	149
5.1.1  从应用使用单机数据库开始	149
5.1.2  数据库垂直/水平拆分的困难	150
5.1.3  单机变为多机后，事务如何处理	152
5.1.4  多机的Sequence问题与处理	165
5.1.5  应对多机的数据查询	168
5.2  数据访问层的设计与实现	174
5.2.1  如何对外提供数据访问层的功能	174
5.2.2  按照数据层流程的顺序看数据层设计	177
5.2.3  独立部署的数据访问层实现方式	192
5.2.4  读写分离的挑战和应对	194
5.3  总结	200
第6章  消息中间件	203
6.1  消息中间件的价值	203
6.1.1  消息中间件的定义	203
6.1.2  透过示例看消息中间件对应用的解耦	204
6.2  互联网时代的消息中间件	208
6.2.1  如何解决消息发送一致性	209
6.2.2  如何解决消息中间件与使用者的强依赖问题	218
6.2.3  消息模型对消息接收的影响	222
6.2.4  消息订阅者订阅消息的方式	229
6.2.5  保证消息可靠性的做法	230
6.2.6  订阅者视角的消息重复的产生和应对	245
6.2.7  消息投递的其他属性支持	249
6.2.8  保证顺序的消息队列的设计	252
6.2.9  Push和Pull方式的对比	257
第7章  软负载中心与集中配置管理	259
7.1  初识软负载中心	259
7.2  软负载中心的结构	261
7.3  内容聚合功能的设计	263
7.4  解决服务上下线的感知	267
7.5  软负载中心的数据分发的特点和设计	269
7.5.1  数据分发与消息订阅的区别	269
7.5.2  提升数据分发性能需要注意的问题	271
7.6  针对服务化的特性支持	272
7.6.1  软负载数据分组	272
7.6.2  提供自动感知以外的上下线开关	273
7.6.3  维护管理路由规则	273
7.7  从单机到集群	274
7.7.1  数据统一管理方案	275
7.7.2  数据对等管理方案	276
7.8  集中配置管理中心	280
7.8.1  客户端实现和容灾策略	282
7.8.2  服务端实现和容灾策略	284
7.8.3  数据库策略	285
第8章  构建大型网站的其他要素	287
8.1  加速静态内容访问速度的CDN	287
8.2  大型网站的存储支持	291
8.2.1  分布式文件系统	292
8.2.2  NoSQL	294
8.2.3  缓存系统	298
8.3  搜索系统	301
8.3.1  爬虫问题	302
8.3.2  倒排索引	302
8.3.3  查询预处理	304
8.3.4  相关度计算	304
8.4  数据计算支撑	304
8.5  发布系统	307
8.6  应用监控系统	310
8.7  依赖管理系统	312
8.8  多机房问题分析	315
8.9  系统容量规划	317
8.10  内部私有云	319
后记	                                                 321
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大型网站系统与Java中间件开发实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程核心技术
前 言
第1章 Java多线程技能，
1.1 进程和多线程的概念及线程的优点
1.2 使用多线程
1.2.1 继承Thread类
1.2.2 实现Runnable接口
1.2.3 实例变量与线程安全
1.2.4 留意i——与System.out.println（）的异常
1.3 currentThread（）方法
1.4 isAlive（）方法
1.5 sleep（）方法
1.6 getId（）方法
1.7 停止线程
1.7.1 停止不了的线程
1.7.2 判断线程是否是停止状态
1.7.3 能停止的线程——异常法
1.7.4 在沉睡中停止
1.7.5 能停止的线程——暴力停止
1.7.6 方法stop（）与java.lang.ThreadDeath异常
1.7.7 释放锁的不良后果
1.7.8 使用return停止线程
1.8 暂停线程
1.8.1 suspend与resume方法的使用
1.8.2 suspend与resume方法的缺点——独占
1.8.3 suspend与resume方法的缺点——不同步
1.9 yield方法
1.10 线程的优先级
1.10.1 线程优先级的继承特性
1.10.2 优先级具有规则性
1.10.3 优先级具有随机性
1.10.4 看谁运行得快
1.11 守护线程
1.12 本章小结
第2章 对象及变量的并发访问
2.1 synchronized同步方法
2.1.1 方法内的变量为线程安全
2.1.2 实例变量非线程安全
2.1.3 多个对象多个锁
2.1.4 synchronized方法与锁对象
2.1.5 脏读
2.1.6 synchronized锁重入
2.1.7 出现异常，锁自动释放
2.1.8 同步不具有继承性
2.2 synchronized同步语句块
2.2.1 synchronized方法的弊端
2.2.2 synchronized同步代码块的使用
2.2.3 用同步代码块解决同步方法的弊端
2.2.4 一半异步，一半同步
2.2.5 synchronized代码块间的同步性
2.2.6 验证同步synchronized（this）代码块是锁定当前对象的
2.2.7 将任意对象作为对象监视器
2.2.8 细化验证3个结论
2.2.9 静态同步synchronized方法与synchronized（class）代码块
2.2.10 数据类型String的常量池特性
2.2.11 同步synchronized方法无限等待与解决
2.2.12 多线程的死锁
2.2.13 内置类与静态内置类
2.2.14 内置类与同步：实验1
2.2.15 内置类与同步：实验2
2.2.16 锁对象的改变
2.3 volatile关键字
2.3.1 关键字volatile与死循环
2.3.2 解决同步死循环
2.3.3 解决异步死循环
2.3.4 volatile非原子的特性
2.3.5 使用原子类进行i++操作
2.3.6 原子类也并不完全安全
2.3.7 synchronized代码块有volatile同步的功能
2.4 本章总结
第3章 线程间通信
3.1 等待/通知机制
3.1.1 不使用等待/通知机制实现线程间通信
3.1.2 什么是等待/通知机制
3.1.3 等待/通知机制的实现
3.1.4 方法wait（）锁释放与notify（）锁不释放
3.1.5 当interrupt方法遇到wait方法
3.1.6 只通知一个线程
3.1.7 唤醒所有线程
3.1.8 方法wait（long）的使用
3.1.9 通知过早
3.1.10 等待wait的条件发生变化
3.1.11 生产者/消费者模式实现
3.1.12 通过管道进行线程间通信：字节流
3.1.13 通过管道进行线程间通信：字符流
3.1.14 实战：等待/通知之交叉备份
3.2 方法join的使用
3.2.1 学习方法join前的铺垫
3.2.2 用join（）方法来解决
3.2.3 方法join与异常
3.2.4 方法join（long）的使用
3.2.5 方法join（long）与sleep（long）的区别
3.2.6 方法join（）后面的代码提前运行：出现意外
3.2.7 方法join（）后面的代码提前运行：解释意外
3.3 类ThreadLocal的使用
3.3.1 方法get（）与null
3.3.2 验证线程变量的隔离性
3.3.3 解决get（）返回null问题
3.3.4 再次验证线程变量的隔离性
3.4 类InheritableThreadLocal的使用
3.4.1 值继承
3.4.2 值继承再修改
3.5 本章总结
第4章 Lock的使用
4.1 使用ReentrantLock类
4.1.1 使用ReentrantLock实现同步：测试1
4.1.2 使用ReentrantLock实现同步：测试2
4.1.3 使用Condition实现等待/通知错误用法与解决
4.1.4 正确使用Condition实现等待/通知
4.1.5 使用多个Condition实现通知部分线程：错误用法
4.1.6 使用多个Condition实现通知部分线程：正确用法
4.1.7 实现生产者/消费者模式：一对一交替打印
4.1.8 实现生产者/消费者模式：多对多交替打印
4.1.9 公平锁与非公平锁
4.1.10 方法getHoldCount（）、getQueueLength（）和getWaitQueueLength（）的测试
4.1.11 方法hasQueuedThread（）、hasQueuedThreads（）和hasWaiters（）的测试
4.1.12 方法isFair（）、isHeldByCurrentThread（）和isLocked（）的测试
4.1.13 方法lockInterruptibly（）、tryLock（）和tryLock（long timeout，TimeUnit unit）的测试
4.1.14 方法awaitUninterruptibly（）的使用
4.1.15 方法awaitUntil（）的使用
4.1.16 使用Condition实现顺序执行
4.2 使用ReentrantReadWriteLock类
4.2.1 类ReentrantReadWriteLock的使用：读读共享
4.2.2 类ReentrantReadWriteLock的使用：写写互斥
4.2.3 类ReentrantReadWriteLock的使用：读写互斥
4.2.4 类ReentrantReadWriteLock的使用：写读互斥
4.3 本章总结
第5章 定时器Timer
5.1 定时器Timer的使用
5.1.1 方法schedule（TimerTask task， Date time）的测试
5.1.2 方法schedule（TimerTask task， Date firstTime， long period）的测试
5.1.3 方法schedule（TimerTask task， long delay）的测试
5.1.4 方法schedule（TimerTask task， long delay， long period）的测试
5.1.5 方法scheduleAtFixedRate（TimerTask task， Date firstTime， long period）的测试
5.2 本章总结
第6章 单例模式与多线程
6.1 立即加载/"饿汉模式"
6.2 延迟加载/"懒汉模式"
6.3 使用静态内置类实现单例模式
6.4 序列化与反序列化的单例模式实现
6.5 使用static代码块实现单例模式
6.6 使用enum枚举数据类型实现单例模式
6.7 完善使用enum枚举实现单例模式
6.8 本章总结
第7章 拾遗增补
7.1 线程的状态
7.1.1 验证NEW、RUNNABLE和TERMINATED
7.1.2 验证TIMED_WAITING
7.1.3 验证BLOCKED
7.1.4 验证WAITING
7.2 线程组
7.2.1 线程对象关联线程组：1级关联
7.2.2 线程对象关联线程组：多级关联
7.2.3 线程组自动归属特性
7.2.4 获取根线程组
7.2.5 线程组里加线程组
7.2.6 组内的线程批量停止
7.2.7 递归与非递归取得组内对象
7.3 使线程具有有序性
7.4 SimpleDateFormat非线程安全
7.4.1 出现异常
7.4.2 解决异常方法1
7.4.3 解决异常方法2
7.5 线程中出现异常的处理
7.6 线程组内处理异常
7.7 线程异常处理的传递
7.8 本章总结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程核心技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Java虚拟机（第3版）
前言
致谢
第一部分　走近Java
第1章　走近Java 2
1.1　概述 2
1.2　Java技术体系 3
1.3　Java发展史 4
1.4　Java虚拟机家族 12
1.4.1　虚拟机始祖：Sun Classic/Exact VM 12
1.4.2　武林盟主：HotSpot VM 13
1.4.3　小家碧玉：Mobile/Embedded VM 14
1.4.4　天下第二：BEA JRockit/IBM J9 VM 15
1.4.5　软硬合璧：BEA Liquid VM/Azul VM 16
1.4.6　挑战者：Apache Harmony/Google Android Dalvik VM 17
1.4.7　没有成功，但并非失败：Microsoft JVM及其他 18
1.4.8　百家争鸣 19
1.5　展望Java技术的未来 21
1.5.1　无语言倾向 21
1.5.2　新一代即时编译器 23
1.5.3　向Native迈进 24
1.5.4　灵活的胖子 26
1.5.5　语言语法持续增强 27
1.6　实战：自己编译JDK 29
1.6.1　获取源码 29
1.6.2　系统需求 31
1.6.3　构建编译环境 33
1.6.4　进行编译 34
1.6.5　在IDE工具中进行源码调试 36
1.7　本章小结 39
第二部分　自动内存管理
第2章　Java内存区域与内存溢出异常 42
2.1　概述 42
2.2　运行时数据区域 42
2.2.1　程序计数器 43
2.2.2　Java虚拟机栈 43
2.2.3　本地方法栈 44
2.2.4　Java堆 44
2.2.5　方法区 46
2.2.6　运行时常量池 47
2.2.7　直接内存 47
2.3　HotSpot虚拟机对象探秘 48
2.3.1　对象的创建 48
2.3.2　对象的内存布局 51
2.3.3　对象的访问定位 52
2.4　实战：OutOfMemoryError异常 53
2.4.1　Java堆溢出 54
2.4.2　虚拟机栈和本地方法栈溢出 56
2.4.3　方法区和运行时常量池溢出 61
2.4.4　本机直接内存溢出 65
2.5　本章小结 66
第3章　垃圾收集器与内存分配策略 67
3.1　概述 67
3.2　对象已死？ 68
3.2.1　引用计数算法 68
3.2.2　可达性分析算法 70
3.2.3　再谈引用 71
3.2.4　生存还是死亡？ 72
3.2.5　回收方法区 74
3.3　垃圾收集算法 75
3.3.1　分代收集理论 75
3.3.2　标记-清除算法 77
3.3.3　标记-复制算法 78
3.3.4　标记-整理算法 79
3.4　HotSpot的算法细节实现 81
3.4.1　根节点枚举 81
3.4.2　安全点 82
3.4.3　安全区域 83
3.4.4　记忆集与卡表 84
3.4.5　写屏障 85
3.4.6　并发的可达性分析 87
3.5　经典垃圾收集器 89
3.5.1　Serial收集器 90
3.5.2　ParNew收集器 92
3.5.3　Parallel Scavenge收集器 93
3.5.4　Serial Old收集器 94
3.5.5　Parallel Old收集器 95
3.5.6　CMS收集器 96
3.5.7　Garbage First收集器 98
3.6　低延迟垃圾收集器 104
3.6.1　Shenandoah收集器 105
3.6.2　ZGC收集器 112
3.7　选择合适的垃圾收集器 121
3.7.1　Epsilon收集器 121
3.7.2　收集器的权衡 121
3.7.3　虚拟机及垃圾收集器日志 122
3.7.4　垃圾收集器参数总结 127
3.8　实战：内存分配与回收策略 129
3.8.1　对象优先在Eden分配 130
3.8.2　大对象直接进入老年代 131
3.8.3　长期存活的对象将进入老年代 132
3.8.4　动态对象年龄判定 134
3.8.5　空间分配担保 135
3.9　本章小结 137
第4章　虚拟机性能监控、故障处理工具 138
4.1　概述 138
4.2　基础故障处理工具 138
4.2.1　jps：虚拟机进程状况工具 141
4.2.2　jstat：虚拟机统计信息监视工具 142
4.2.3　jinfo：Java配置信息工具 143
4.2.4　jmap：Java内存映像工具 144
4.2.5　jhat：虚拟机堆转储快照分析工具 145
4.2.6　jstack：Java堆栈跟踪工具 146
4.2.7　基础工具总结 148
4.3　可视化故障处理工具 151
4.3.1　JHSDB：基于服务性代理的调试工具 152
4.3.2　JConsole：Java监视与管理控制台 157
4.3.3　VisualVM：多合-故障处理工具 164
4.3.4　Java Mission Control：可持续在线的监控工具 171
4.4　HotSpot虚拟机插件及工具 175
4.5　本章小结 180
第5章　调优案例分析与实战 181
5.1　概述 181
5.2　案例分析 181
5.2.1　大内存硬件上的程序部署策略 182
5.2.2　集群间同步导致的内存溢出 184
5.2.3　堆外内存导致的溢出错误 185
5.2.4　外部命令导致系统缓慢 187
5.2.5　服务器虚拟机进程崩溃 187
5.2.6　不恰当数据结构导致内存占用过大 188
5.2.7　由Windows虚拟内存导致的长时间停顿 189
5.2.8　由安全点导致长时间停顿 190
5.3　实战：Eclipse运行速度调优 192
5.3.1　调优前的程序运行状态 193
5.3.2　升级JDK版本的性能变化及兼容问题 196
5.3.3　编译时间和类加载时间的优化 200
5.3.4　调整内存设置控制垃圾收集频率 203
5.3.5　选择收集器降低延迟 206
5.4　本章小结 209
第三部分　虚拟机执行子系统
第6章　类文件结构 212
6.1　概述 212
6.2　无关性的基石 212
6.3　Class类文件的结构 214
6.3.1　魔数与Class文件的版本 215
6.3.2　常量池 218
6.3.3　访问标志 224
6.3.4　类索引、父类索引与接口索引集合 225
6.3.5　字段表集合 226
6.3.6　方法表集合 229
6.3.7　属性表集合 230
6.4　字节码指令简介 251
6.4.1　字节码与数据类型 251
6.4.2　加载和存储指令 253
6.4.3　运算指令 254
6.4.4　类型转换指令 255
6.4.5　对象创建与访问指令 256
6.4.6　操作数栈管理指令 256
6.4.7　控制转移指令 257
6.4.8　方法调用和返回指令 257
6.4.9　异常处理指令 258
6.4.10　同步指令 258
6.5　公有设计，私有实现 259
6.6　Class文件结构的发展 260
6.7　本章小结 261
第7章　虚拟机类加载机制 262
7.1　概述 262
7.2　类加载的时机 263
7.3　类加载的过程 267
7.3.1　加载 267
7.3.2　验证 268
7.3.3　准备 271
7.3.4　解析 272
7.3.5　初始化 277
7.4　类加载器 279
7.4.1　类与类加载器 280
7.4.2　双亲委派模型 281
7.4.3　破坏双亲委派模型 285
7.5　Java模块化系统 287
7.5.1　模块的兼容性 288
7.5.2　模块化下的类加载器 290
7.6　本章小结 292
第8章　虚拟机字节码执行引擎 293
8.1　概述 293
8.2　运行时栈帧结构 294
8.2.1　局部变量表 294
8.2.2　操作数栈 299
8.2.3　动态连接 300
8.2.4　方法返回地址 300
8.2.5　附加信息 301
8.3　方法调用 301
8.3.1　解析 301
8.3.2　分派 303
8.4　动态类型语言支持 315
8.4.1　动态类型语言 316
8.4.2　Java与动态类型 317
8.4.3　java.lang.invoke包 318
8.4.4　invokedynamic指令 321
8.4.5　实战：掌控方法分派规则 324
8.5　基于栈的字节码解释执行引擎 326
8.5.1　解释执行 327
8.5.2　基于栈的指令集与基于寄存器的指令集 328
8.5.3　基于栈的解释器执行过程 329
8.6　本章小结 334
第9章　类加载及执行子系统的案例与实战 335
9.1　概述 335
9.2　案例分析 335
9.2.1　Tomcat：正统的类加载器架构 335
9.2.2　OSGi：灵活的类加载器架构 338
9.2.3　字节码生成技术与动态代理的实现 341
9.2.4　Backport工具：Java的时光机器 345
9.3　实战：自己动手实现远程执行功能 348
9.3.1　目标 348
9.3.2　思路 349
9.3.3　实现 350
9.3.4　验证 355
9.4　本章小结 356
第四部分　程序编译与代码优化
第10章　前端编译与优化 358
10.1　概述 358
10.2　Javac编译器 359
10.2.1　Javac的源码与调试 359
10.2.2　解析与填充符号表 362
10.2.3　注解处理器 363
10.2.4　语义分析与字节码生成 364
10.3　Java语法糖的味道 367
10.3.1　泛型 367
10.3.2　自动装箱、拆箱与遍历循环 375
10.3.3　条件编译 377
10.4　实战：插入式注解处理器 378
10.4.1　实战目标 379
10.4.2　代码实现 379
10.4.3　运行与测试 385
10.4.4　其他应用案例 386
10.5　本章小结 386
第11章　后端编译与优化 388
11.1　概述 388
11.2　即时编译器 389
11.2.1　解释器与编译器 389
11.2.2　编译对象与触发条件 392
11.2.3　编译过程 397
11.2.4　实战：查看及分析即时编译结果 398
11.3　提前编译器 404
11.3.1　提前编译的优劣得失 405
11.3.2　实战：Jaotc的提前编译 408
11.4　编译器优化技术 411
11.4.1　优化技术概览 411
11.4.2　方法内联 415
11.4.3　逃逸分析 417
11.4.4　公共子表达式消除 420
11.4.5　数组边界检查消除 421
11.5　实战：深入理解Graal编译器 423
11.5.1　历史背景 423
11.5.2　构建编译调试环境 424
11.5.3　JVMCI编译器接口 426
11.5.4　代码中间表示 429
11.5.5　代码优化与生成 432
11.6　本章小结 436
第五部分　高效并发
第12章　Java内存模型与线程 438
12.1　概述 438
12.2　硬件的效率与一致性 439
12.3　Java内存模型 440
12.3.1　主内存与工作内存 441
12.3.2　内存间交互操作 442
12.3.3　对于volatile型变量的特殊规则 444
12.3.4　针对long和double型变量的特殊规则 450
12.3.5　原子性、可见性与有序性 450
12.3.6　先行发生原则 452
12.4　Java与线程 455
12.4.1　线程的实现 455
12.4.2　Java线程调度 458
12.4.3　状态转换 460
12.5　Java与协程 461
12.5.1　内核线程的局限 461
12.5.2　协程的复苏 462
12.5.3　Java的解决方案 464
12.6　本章小结 465
第13章　线程安全与锁优化 466
13.1　概述 466
13.2　线程安全 466
13.2.1　Java语言中的线程安全 467
13.2.2　线程安全的实现方法 471
13.3　锁优化 479
13.3.1　自旋锁与自适应自旋 479
13.3.2　锁消除 480
13.3.3　锁粗化 481
13.3.4　轻量级锁 481
13.3.5　偏向锁 483
13.4　本章小结 485
附录A　在Windows系统下编译OpenJDK 6 486
附录B　展望Java技术的未来（2013年版） 493
附录C　虚拟机字节码指令表 499
附录D　对象查询语言（OQL）简介 506
附录E　JDK历史版本轨迹 512
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Java虚拟机（第3版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Effective Java 中文版
译者序
序
前言
第一章 引言
第二章 创建和销毁对象
第1条：考虑用静态工厂方法代替构造函数
第2条：使用私有构造函数强化singleton属性
第3条：通过私有构造函数强化不可实例化属性
第4条：避免创建重复的对象
条5条：消除对期的对象引用
第6条：避免使用终结函数
第三章 对于所有对象都通用的方法
第四章 类和接口
第五章 C语言结构的替代
第六章 方法
第七章 通用程序设计
第八章 异常
第九章 线程
第十章 序列化
中英文术语对照
参考文献
模式和习惯用法索引
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Effective Java 中文版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>疯狂Java讲义
第1章 Java概述
1.1 Java语言的发展简史
1.2 Java的竞争对手及各自优势
1.2.1 C#简介和优势
1.2.2 Ruby简介和优势
1.2.3 Python的简介和优势
1.3 Java程序运行机制
1.3.1 高级语言的运行机制
1.3.2 Java程序的运行机制和JVM
1.4 开发Java的准备
1.4.1 安装JDK
学生提问：不是说JVM是运行Java程序的虚拟机吗？那JRE和JVM的关系是怎样的呢？
学生提问：为什么不安装公共JRE系统呢？
1.4.2 设置PATH环境变量
学生提问：为什么选择设置用户变量，用户变量和系统变量有什么区别呢？
1.5 第一个Java程序
1.5.1 编辑Java源代码
1.5.2 编译Java程序
学生提问：当我们使用编译C程序时，不仅需要指定存放目标文件的位置，也需要指定目标文件的文件名，这里使用javac编译Java程序时怎么不需要指定目标文件的文件名呢？
1.5.3 运行Java程序
1.5.4 根据CLASSPATH环境变量定位类
1.6 Java程序的基本规则
1.6.1 Java程序的组织形式
1.6.2 Java源文件的命名规则
1.6.3 初学者容易犯的错误
1.7 垃圾回收机制
1.8 何时开始使用IDE工具
学生提问：老师，我想学习Java编程，到底是学习Eclipse好呢，还是学习JBuilder好呢？
1.9 本章小结
本章练习
第2章 理解面向对象
2.1 面向对象
2.1.1 结构化程序设计简介
2.1.2 程序的三种基本结构
2.1.3 面向对象程序设计简介
2.1.4 面向对象的基本特征
2.2 UML(统一建模语言)介绍
2.2.1 用例图
2.2.2 类图
2.2.3 组件图
2.2.4 部署图
2.2.5 顺序图
2.2.6 活动图
2.2.7 状态机图
2.3 Java的面向对象特征
2.3.1 一切都是对象
2.3.2 类和对象
2.4 本章小结
第3章 数据类型和运算符
3.1 注释
3.1.1 单行注释和多行注释
3.1.2 文档注释
学生提问：API文档是什么？
学生提问：为什么要掌握查看API文档的方法？
3.2 标识符和关键字
3.2.1 分隔符
3.2.2 标识符规则
3.2.3 Java关键字
3.3 数据类型分类
3.4 基本数据类型
3.4.1 整型
3.4.2 字符型
3.4.3 浮点型
3.4.4 布尔型
3.5 基本类型的类型转换
3.5.1 自动类型转换
3.5.2 强制类型转化
3.5.3 表达式类型的自动提升
3.6 直接量
3.6.1 直接量的类型
3.6.2 直接量的赋值
3.7 运算符
3.7.1 算术运算符
3.7.2 赋值运算符
3.7.3 位运算符
3.7.4 扩展后的赋值运算符
3.7.5 比较运算符
学生提问：Java为什么要对这些数据进行缓存呢？
3.7.6 逻辑运算符
3.7.7 三目运算符
3.7.8 运算符的结合性和优先级
3.8 本章小结
本章练习
第4章 流程控制和数组
4.1 顺序结构
4.2 分支结构
4.2.1 if条件语句
4.2.2 switch分支语句
4.3 循环结构
4.3.1 while循环语句
4.3.2 do while循环语句
4.3.3 for循环
4.3.4 嵌套循环
4.4 控制循环结构
4.4.1 使用break结束循环
4.4.2 使用continue结束本次循环
4.4.3 使用return结束方法
4.5 数组类型
4.5.1 理解数组：数组也是一种类型
学生提问：int[]是一种类型吗？怎么使用这种类型呢？
4.5.2 定义数组
4.5.3 数组的初始化
学生提问：能不能只分配内存空间，不赋初始值呢？
4.5.4 使用数组
学生提问：为什么要我记住这些异常信息？
4.5.5 JDK1.5提供了foreach循环
4.6 深入数组
4.6.1 内存中的数组
学生提问：为什么有栈内存和堆内存之分？
4.6.2 基本类型数组的初始化
4.6.3 引用类型数组的初始化
4.6.4 没有多维数组
学生提问：我是否可以让图4.13中灰色覆盖的数组元素再次指向另一个数组？这样不可以扩展成三维数组吗？甚至扩展到更多维的数组？
4.6.5 操作数组的工具类
4.6.6 数组的应用举例
4.7 本章小结
本章练习
第5章 面向对象(上)
5.1 类和对象
5.1.1 定义类
学生提问：构造器不是没有返回值吗？为什么不能用void修饰呢？
5.1.2 对象的产生和使用
5.1.3 对象、引用和指针
5.1.4 对象的this引用
5.2 方法详解
5.2.1 方法的所属性
5.2.2 方法的参数传递机制
5.2.3 形参长度可变的方法
5.2.4 递归方法
5.2.5 方法重载
学生提问：为什么方法的返回值类型不能用于区分重载的方法？
5.3 成员变量和局部变量
5.3.1 成员变量和局部变量
5.3.2 成员变量的初始化和内存中的运行机制
5.3.3 局部变量的初始化和内存中的运行机制
5.3.4 变量的使用规则
5.4 隐藏和封装
5.4.1 理解封装
5.4.2 使用访问控制符
5.4.3 package和import
5.4.4 Java的常用包
5.5 深入构造器
5.5.1 使用构造器执行初始化
学生提问：构造器是创建Java对象的途径，是不是说构造器完全负责创建Java对象？
5.5.2 构造器的重载
学生提问：为什么要用this来调用另一个重载的构造器？我把另一个构造器里的代码复制、粘贴到这个构造器里不就可以了吗？
5.6 类的继承
5.6.1 继承的特点
5.6.2 重写父类的方法
5.6.3 父类实例的super引用
学生提问：我们只是创建了一个Ostrich对象时，哪来的Bird对象？
5.6.4 调用父类构造器
学生提问：为什么我创建Java对象时从未感觉到java.lang.Object的构造器被调用过？
5.7 多态
5.7.1 多态性
5.7.2 引用变量的强制类型转换
5.7.3 instanceof运算符
5.8 继承与组合
5.8.1 使用继承的注意点
5.8.2 利用组合实现复用
学生提问：使用组合关系来实现复用时，需要创建两个Animal对象，是不是意味着使用组合关系时系统开销更大？
5.9 初始化块
5.9.1 使用初始化块
5.9.2 初始化块和构造器
5.9.3 静态初始化块
5.10 本章小结
本章练习
第6章 面向对象(下)
6.1 基本数据类型的包装类
6.2 处理对象
6.2.1 打印对象和toString方法
6.2.2 ==和equals比较运算符
6.3 类成员
6.3.1 理解类成员
6.3.2 单例(Singleton)类
6.4 final修饰符
6.4.1 final变量
6.4.2 final方法
6.4.3 final类
6.4.4 不可变类
6.4.5 缓存实例的不可变类
6.5 抽象类
6.5.1 抽象方法和抽象类
6.5.2 抽象类的作用
6.6 更彻底的抽象：接口
6.6.1 接口的概念
6.6.2 接口的定义
6.6.3 接口的继承
6.6.4 使用接口
6.6.5 接口和抽象类
6.6.6 面向接口编程
6.7 内部类
6.7.1 非静态内部类
学生提问：非静态内部类对象和外部类对象的关系是怎样的？
6.7.2 静态内部类
学生提问：为什么静态内部类实例方法也不能访问外部类的实例属性呢？
学生提问：接口里是否能定义内部接口？
6.7.3 使用内部类
学生提问：既然内部类是外部类的成员，是否可以为外部类定义子类，在子类中再定义一个内部类来重写其父类中的内部类？
6.7.4 局部内部类
6.7.5 匿名内部类
6.7.6 闭包(Closure)和回调
6.8 枚举类
6.8.1 手动实现枚举类
6.8.2 枚举类入门
6.8.3 枚举类的属性、方法和构造器
6.8.4 实现接口的枚举类
6.8.5 包含抽象方法的枚举类
6.9 对象与垃圾回收
6.9.1 对象在内存中的状态
6.9.2 强制垃圾回收
6.9.3 finalize方法
6.9.4 对象的软、弱和虚引用
6.10 修饰符的适用范围
6.11 使用JAR文件
6.11.1 jar命令详解
6.11.2 创建可执行的JAR包
6.11.3 关于JAR包的技巧
6.12 本章小结
本章练习
第7章 Java集合
7.1 Java集合概述
7.2 Collection和Iterator接口
7.2.1 使用Iterator接口遍历集合元素
7.2.2 使用foreach循环遍历集合元素
7.3 Set接口
7.3.1 HashSet类
学生提问：hashCode方法对于HashSet的作用是什么？
7.3.2 TreeSet类
7.3.3 EnumSet类
7.4 List接口
7.4.1 List接口和ListIterator接口
7.4.2 ArrayList和Vector实现类
7.4.3 固定长度的List
7.5 Queue接口
7.5.1 LinkedList实现类
7.5.2 PriorityQueue实现类
7.6 Map
7.6.1 HashMap和Hashtable实现类
7.6.2 SortedMap接口和TreeMap实现类
7.6.3 WeakHashMap实现类
7.6.4 IdentityHashMap实现类
7.6.5 EnumMap实现类
7.7 HashSet和HashMap的性能选项
7.8 操作集合的工具类：Collections
7.8.1 排序操作
7.8.2 查找，替换操作
7.8.3 同步控制
7.8.4 设置不可变集合
7.9 烦琐的接口：Enumeration
7.10 本章小结
本章练习
第8章 泛型
8.1 泛型入门
8.1.1 编译时不检查类型的异常
8.1.2 手动实现编译时检查类型
8.1.3 使用泛型
8.2 深入泛型
8.2.1 定义泛型接口、类
8.2.2 从泛型类派生子类
8.2.3 并不存在泛型类
8.3 类型通配符
8.3.1 使用类型通配符
8.3.2 设定类型通配符的上限
8.3.3 设定类型形参的上限
8.4 泛型方法
8.4.1 定义泛型方法
8.4.2 泛型方法和类型通配符的区别
8.4.3 设定通配符的下限
8.4.4 泛型方法与方法重载
8.5 擦除和转换
8.6 泛型与数组
8.7 本章小结
第9章 与运行环境交互
9.1 与用户互动
9.1.1 运行Java程序的参数
9.1.2 使用Scanner获取键盘输入
9.1.3 使用BufferedReader获取键盘输入
9.2 系统相关
9.2.1 System类
9.2.2 Runtime类
9.3 常用类
9.3.1 Object类
9.3.2 String、StringBuffer和StringBuilder类
9.3.3 Math类
9.3.4 Random类
9.3.5 BigDecimal类
9.4 处理日期的类
9.4.1 Date类
9.4.2 Calendar类
9.4.3 TimeZone类
9.5 正则表达式
9.5.1 创建正则表达式
9.5.2 使用正则表达式
9.6 程序国际化
9.6.1 Java国际化的思路
9.6.2 Java支持的语言和国家
9.6.3 完成程序国际化
9.6.4 使用MessageFormat处理包含占位符的字符串
9.6.5 使用类文件代替资源文件
9.6.6 使用NumberFormat格式化数字
9.6.7 使用DateFormat格式化日期
9.7 本章小结
本章练习
第10章 异常处理
10.1 异常概述
10.2 异常处理机制
10.2.1 使用try...catch捕获异常
10.2.2 异常类的继承体系
10.2.3 访问异常信息
10.2.4 使用finally回收资源
10.2.5 异常处理的嵌套
10.3 Checked异常和Runtime异常体系
10.3.1 使用throws声明抛出异常
10.4 使用throw抛出异常
10.4.1 抛出异常
10.4.2 自定义异常类
10.4.3 catch和throw同时使用
10.4.4 异常链
10.5 Java的异常跟踪栈
10.6 异常处理规则
10.6.1 不要过度使用异常
10.6.2 不要使用过于庞大的try块
10.6.3 避免使用Catch All语句
10.6.4 不要忽略捕获到的异常
10.7 本章小结
本章练习
第11章 AWT编程
11.1 GUI(图形用户界面)和AWT
11.2 AWT容器
11.3 布局管理器
11.3.1 FlowLayout布局管理器
11.3.2 BorderLayout布局管理器
学生提问：BorderLayout最多只能放置5个组件吗？那它还有什么作用？
11.3.3 GridLayout布局管理器
11.3.4 GridBagLayout布局管理器
11.3.5 CardLayout布局管理器
11.3.6 绝对定位
11.3.7 BoxLayout布局管理器
学生提问：图11.15和图11.16显示的所有按钮都紧挨在一起，如果希望像FlowLayout、GridLayout等布局管理器指定组件的间距该怎么办？
11.4 AWT 常用组件
11.4.1 基本组件
11.4.2 对话框
11.5 事件处理
11.5.1 Java事件模型的流程
11.5.2 事件和事件监听器
11.5.3 事件适配器
11.5.4 事件监听器的实现形式
11.6 AWT的菜单
11.6.1 菜单条、菜单和菜单项
11.6.2 右键菜单
学生提问：为什么即使我没有给多行文本域编写右键菜单，但当我在多行文本域上单击右键时一样会弹出右键菜单？
11.7 在AWT中绘图
11.7.1 画图的实现原理
11.7.2 使用Graphics类
11.8 处理位图
11.8.1 Image抽象类和BufferedImage实现类
11.8.2 使用ImageIO输入/输出位图
11.9 剪贴板
11.9.1 数据传递的类和接口
11.9.2 传递文本
11.9.3 使用系统剪贴板传递图像
11.9.4 使用本地剪贴板来传递对象引用
11.9.5 通过系统剪贴板传递Java对象
11.10 本章小结
本章练习
第12章 Swing编程
12.1 Swing概述
12.2 Swing基本组件的用法
12.2.1 Swing组件层次
12.2.2 AWT组件的Swing实现
学生提问：为什么单击Swing多行文本域时不是弹出像AWT多行文本域中的右键菜单？
12.2.3 使用JToolBar创建工具条
12.2.4 使用JColorChooser和JFileChooser
12.2.5 使用JOptionPane
12.3 Swing中的特殊容器
12.3.1 使用JSplitPane
12.3.2 使用JTabbedPane
12.3.3 使用JLayeredPane、JDesktopPane和JInternalFrame
12.4 Swing拖放功能
12.4.1 拖放目标
12.4.2 拖放源
12.4.3 简化的拖放操作
12.5 Applet和JApplet
12.5.1 Applet简介及其安全性
12.5.2 开发Applet类
12.5.3 使用HTML页面装载Applet
12.5.4 appletviewer简介
12.5.5 Applet的生命周期和动画机制
学生提问：程序中重写paint方法时绘制了一个字符串，但图12.28上则绘制出了如此之多的字符串，这是为什么呢？
12.5.6 使用Applet创建音乐播放器
12.6 使用JProgressBar、ProgressMonitor和BoundedRangeModel创建进度条
12.6.1 创建进度条
12.6.2 创建进度对话框
12.7 使用JSlider和BoundedRangeModel创建滑动条
12.8 使用JSpinner和SpinnerModel创建微调控制器
12.9 使用JList、JComboBox创建列表框
12.9.1 简单列表框
12.9.2 不强制存储列表项的ListModel和ComboBoxModel
12.9.3 强制存储列表项的DefaultListModel和DefaultComboBoxModel
学生提问：为什么JComboBox提供了添加、删除列表项目的方法？而JList没有提供添加、删除列表项的方法呢？
12.9.4 使用ListCellRenderer改变列表项外观
12.10 使用JTree和TreeModel创建树
12.10.1 创建树
12.10.2 拖动、编辑树节点
12.10.3 监听节点事件
12.10.4 使用TreeCellRendering改变节点外观
12.11 使用JTable和TableModel创建表格
12.11.1 创建JTable
学生提问：我们指定的表格数据、表格列标题都是Object类型的数组，JTable如何显示这些Object对象？
12.11.2 TableModel和监听器
12.11.3 TableColumnModel和监听器
12.11.4 实现排序
12.11.5 绘制单元格内容
12.11.6 编辑单元格内容
12.12 使用JFormattedTextField和JTextPane创建格式文本
12.12.1 监听Document的改变
12.12.2 使用JPasswordField
12.12.3 使用JFormattedTextField
12.12.4 使用JEditorPane
12.12.5 使用JTextPane
12.13 本章小结
本章练习
第13章 JDBC编程
13.1 JDBC基础
13.1.1 JDBC简介
13.1.2 JDBC驱动程序类型
13.2 SQL语法介绍
13.2.1 安装数据库
13.2.2 关系数据库基本概念和MySQL基本命令
13.2.3 SQL语句基础
13.2.4 DDL语句
13.2.5 DML语句语法
13.2.6 select语句和SQL函数
13.2.7 分组和组函数
13.2.8 多表连接查询和子查询
13.3 JDBC的典型用法
13.3.1 JDBC常用接口和类简介
13.3.2 JDBC编程步骤
学生提问：前面给出的仅是MySQL和Oracle两种数据库的驱动，我看不出驱动类字符串有什么规律啊。如果我希望使用其他数据库，我怎么用其他数据库的驱动类呢？
13.4 执行SQL语句的方式
13.4.1 使用executeUpdate执行DDL和DML语句
13.4.2 使用execute方法执行SQL语句
13.4.3 使用PreparedStatement执行SQL语句
13.4.4 使用CallableStatement调用存储过程
13.5 管理结果集
13.5.1 可滚动、可更新的结果集
13.5.2 处理Blob类型数据
13.5.3 使用ResultSetMetaData分析结果集
13.6 事务处理
13.6.1 事务的概念和MySQL事务支持
13.6.2 JDBC的事务支持
13.6.3 批量更新
13.7 分析数据库信息
13.7.1 使用DatabaseMetaData分析数据库信息
13.7.2 使用系统表分析数据库信息
13.7.3 选择合适的分析方式
13.8 使用连接池管理连接
13.9 本章小结
本章练习
第14章 Annotation(注释)
14.1 基本Annotation
14.1.1 限定重写父类方法：@Override
14.1.2 标示已过时：@Deprecated 676
14.1.3 抑制编译器警告：@SuppressWarnings
14.2 自定义Annotation
14.2.1 定义Annotation
14.2.2 提取Annotation的信息
14.2.3 使用Annotation的例子
14.3 JDK的元Annotation
14.3.1 使用@Retention
14.3.2 使用@Target
14.3.3 使用@Documented
14.3.4 使用@Inherited
14.4 使用APT处理Annotation
14.5 本章小结
第15章 输入/输出
15.1 File类
15.1.1 访问文件和目录
15.1.2 文件过滤器
15.2 理解Java的IO流
15.2.1 流的分类
15.2.2 流的概念模型
15.3 字节流和字符流
15.3.1 InputStream和Reader
15.3.2 OutputStream和Writer
15.4 输入/输出流体系
15.4.1 处理流的用法
15.4.2 输入/输出流体系
15.4.3 转换流
学生提问：怎么没有把字符流转换成字节流的转换流呢？
15.4.4 推回输入流
15.5 重定向标准输入/输出
15.6 Java虚拟机读写其他进程的数据
15.7 RandomAccessFile
15.8 对象序列化
15.8.1 序列化的含义和意义
15.8.2 使用对象流实现序列化
15.8.3 对象引用的序列化
15.8.4 自定义序列化
15.8.5 另一种自定义序列化机制
15.8.6 版本
15.9 Java新IO
15.9.1 Java新IO概述
15.9.2 使用Buffer
15.9.3 使用Channel
15.9.4 编码集和Charset
15.9.5 文件锁
15.10 本章小结
本章练习
第16章 多线程
16.1 线程概述
16.1.1 线程和进程
16.1.2 多线程的优势
16.2 线程的创建和启动
16.2.1 继承Thread类创建线程类
16.2.2 实现Runnable接口创建线程类
16.2.3 两种方式所创建线程的对比
16.3 线程的生命周期
16.3.1 新建和就绪状态
16.3.2 运行和阻塞状态
16.3.3 线程死亡
16.4 控制线程
16.4.1 join线程
16.4.2 后台线程
16.4.3 线程睡眠：sleep
16.4.4 线程让步：yield
16.4.5 改变线程优先级
16.5 线程的同步
16.5.1 线程安全问题
16.5.2 同步代码块
16.5.3 同步方法
16.5.4 释放同步监视器的锁定
16.5.5 同步锁(Lock)
16.5.6 死锁
16.6 线程通信
16.6.1 线程的协调运行
16.6.2 使用条件变量控制协调
16.6.3 使用管道流
16.7 线程组和未处理的异常
16.8 Callable和Future
16.9 线程池
16.10 线程相关类
16.10.1 ThreadLocal类
16.10.2 包装线程不安全的集合
16.10.3 线程安全的集合类
16.11 本章小结
第17章 网络编程
17.1 网络编程的基础知识
17.1.1 网络基础知识
17.1.2 IP地址和端口号
17.2 Java的基本网络支持
17.2.1 使用InetAddress
17.2.2 使用URLDecoder和URLEncoder
17.2.3 使用URL和URLConnection
17.3 基于TCP协议的网络编程
17.3.1 TCP协议基础
17.3.2 使用ServletSocket创建TCP服务器端
17.3.3 使用Socket进行通信
17.3.4 加入多线程
17.3.5 记录用户信息
17.3.6 使用NIO实现非阻塞Socket通信
17.4 基于UDP协议的网络编程
17.4.1 UDP协议基础
17.4.2 使用DatagramSocket发送、接收数据
17.4.3 使用MulticastSocket实现多点广播
17.5 使用代理服务器
17.5.1 直接使用Proxy创建连接
17.5.2 使用ProxySelector选择代理服务器
17.6 本章小结
本章练习
第18章 类加载和反射
18.1 类的加载、连接和初始化
18.1.1 JVM和类
18.1.2 类的加载
18.1.3 类的连接
18.1.4 类的初始化
18.1.5 类初始化的时机
18.2 类加载器
18.2.1 类加载器简介
18.2.2 类加载机制
18.2.3 创建并使用自定义的类加载器
18.2.4 URLClassLoader类
18.3 通过反射查看类信息
18.3.1 获得Class对象
18.3.2 从Class中获取信息
18.4 使用反射生成并操作对象
18.4.1 创建对象
18.4.2 调用方法
18.4.3 访问属性值
18.4.4 操作数组
18.5 使用反射生成JDK动态代理
18.5.1 使用Proxy和InvocationHandler创建动态代理
18.5.2 动态代理和AOP
18.6 反射和泛型
18.6.1 泛型和Class类
18.6.2 使用反射来获取泛型信息
18.7 本章小结
本章练习
上善若水——兼谈我的创作理念
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>疯狂Java讲义
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 8实战
第一部分 基础知识
第1章　为什么要关心Java 8　　2
1.1　Java怎么还在变　　4
1.1.1　Java在编程语言生态系统中的位置　　4
1.1.2　流处理　　6
1.1.3　用行为参数化把代码传递给方法　　7
1.1.4　并行与共享的可变数据　　7
1.1.5　Java需要演变　　8
1.2　Java中的函数　　8
1.2.1　方法和Lambda作为一等公民　　9
1.2.2　传递代码：一个例子　　11
1.2.3　从传递方法到Lambda　　12
1.3　流　　13
1.4　默认方法　　17
1.5　来自函数式编程的其他好思想　　18
1.6　小结　　19
第2章　通过行为参数化传递代码　　20
2.1　应对不断变化的需求　　21
2.1.1　初试牛刀：筛选绿苹果　　21
2.1.2　再展身手：把颜色作为参数　　21
2.1.3　第三次尝试：对你能想到的每个属性做筛选　　22
2.2　行为参数化　　23
2.3　对付啰嗦　　27
2.3.1　匿名类　　28
2.3.2　第五次尝试：使用匿名类　　28
2.3.3　第六次尝试：使用Lambda表达式　　30
2.3.4　第七次尝试：将List类型抽象化　　31
2.4　真实的例子　　31
2.4.1　用Comparator来排序　　31
2.4.2　用Runnable执行代码块　　32
2.4.3　GUI事件处理　　32
2.5　小结　　33
第3章　Lambda表达式　　34
3.1　Lambda管中窥豹　　35
3.2　在哪里以及如何使用Lambda　　37
3.2.1　函数式接口　　37
3.2.2　函数描述符　　39
3.3　把Lambda付诸实践：环绕执行模式　　41
3.3.1　第1步记得行为参数化　　41
3.3.2　第2步：使用函数式接口来传递行为　　42
3.3.3　第3步：执行一个行为　　42
3.3.4　第4步：传递Lambda　　42
3.4　使用函数式接口　　43
3.4.1　Predicate　　44
3.4.2　Consumer　　44
3.4.3　Function　　45
3.5　类型检查、类型推断以及限制　　49
3.5.1　类型检查　　49
3.5.2　同样的Lambda，不同的函数式接口　　50
3.5.3　类型推断　　51
3.5.4　使用局部变量　　52
3.6　方法引用　　53
3.6.1　管中窥豹　　53
3.6.2　构造函数引用　　55
3.7　Lambda和方法引用实战　　57
3.7.1　第1步：传递代码　　58
3.7.2　第2步：使用匿名类　　58
3.7.3　第3步：使用Lambda表达式　　58
3.7.4　第4步：使用方法引用　　59
3.8　复合Lambda表达式的有用方法　　59
3.8.1　比较器复合　　60
3.8.2　谓词复合　　60
3.8.3　函数复合　　61
3.9　数学中的类似思想　　62
3.9.1　积分　　62
3.9.2　与Java 8的Lambda联系起来　　63
3.10　小结　　64
第二部分 函数式数据处理
第4章　引入流　　68
4.1　流是什么　　68
4.2　流简介　　72
4.3　流与集合　　74
4.3.1　只能遍历一次　　75
4.3.2　外部迭代与内部迭代　　76
4.4　流操作　　78
4.4.1　中间操作　　78
4.4.2　终端操作　　79
4.4.3　使用流　　80
4.5　小结　　81
第5章　使用流　　82
5.1　筛选和切片　　83
5.1.1　用谓词筛选　　83
5.1.2　筛选各异的元素　　83
5.1.3　截短流　　84
5.1.4　跳过元素　　85
5.2　映射　　86
5.2.1　对流中每一个元素应用函数　　86
5.2.2　流的扁平化　　87
5.3　查找和匹配　　90
5.3.1　检查谓词是否至少匹配一个元素　　90
5.3.2　检查谓词是否匹配所有元素　　90
5.3.3　查找元素　　91
5.3.4　查找第一个元素　　92
5.4　归约　　92
5.4.1　元素求和　　93
5.4.2　最大值和最小值　　94
5.5　付诸实践　　97
5.5.1　领域：交易员和交易　　98
5.5.2　解答　　99
5.6　数值流　　101
5.6.1　原始类型流特化　　101
5.6.2　数值范围　　102
5.6.3　数值流应用：勾股数　　103
5.7　构建流　　105
5.7.1　由值创建流　　106
5.7.2　由数组创建流　　106
5.7.3　由文件生成流　　106
5.7.4　由函数生成流：创建无限流　　107
5.8　小结　　110
第6章　用流收集数据　　111
6.1　收集器简介　　112
6.1.1　收集器用作高级归约　　112
6.1.2　预定义收集器　　113
6.2　归约和汇总　　114
6.2.1　查找流中的最大值和最小值　　114
6.2.2　汇总　　115
6.2.3　连接字符串　　116
6.2.4　广义的归约汇总　　117
6.3　分组　　120
6.3.1　多级分组　　121
6.3.2　按子组收集数据　　122
6.4　分区　　126
6.4.1　分区的优势　　126
6.4.2　将数字按质数和非质数分区　　128
6.5　收集器接口　　129
6.5.1　理解Collector接口声明的方法　　130
6.5.2　全部融合到一起　　134
6.6　开发你自己的收集器以获得更好的性能　　135
6.6.1　仅用质数做除数　　136
6.6.2　比较收集器的性能　　139
6.7　小结　　140
第7章　并行数据处理与性能　　141
7.1　并行流　　141
7.1.1　将顺序流转换为并行流　　142
7.1.2　测量流性能　　144
7.1.3　正确使用并行流　　147
7.1.4　高效使用并行流　　148
7.2　分支/合并框架　　149
7.2.1　使用RecursiveTask　　149
7.2.2　使用分支/合并框架的最佳做法　　153
7.2.3　工作窃取　　154
7.3　Spliterator　　155
7.3.1　拆分过程　　155
7.3.2　实现你自己的Spliterator　　157
7.4　小结　　162
第三部分 高效Java 8编程
第8章　重构、测试和调试　　164
8.1　为改善可读性和灵活性重构代码　　164
8.1.1　改善代码的可读性　　165
8.1.2　从匿名类到Lambda表达式的转换　　165
8.1.3　从Lambda表达式到方法引用的转换　　166
8.1.4　从命令式的数据处理切换到Stream　　167
8.1.5　增加代码的灵活性　　168
8.2　使用Lambda重构面向对象的设计模式　　170
8.2.1　策略模式　　171
8.2.2　模板方法　　172
8.2.3　观察者模式　　173
8.2.4　责任链模式　　175
8.2.5　工厂模式　　177
8.3　测试Lambda表达式　　178
8.3.1　测试可见Lambda函数的行为　　179
8.3.2　测试使用Lambda的方法的行为　　179
8.3.3　将复杂的Lambda表达式分到不同的方法　　180
8.3.4　高阶函数的测试　　180
8.4　调试　　181
8.4.1　查看栈跟踪　　181
8.4.2　使用日志调试　　183
8.5　小结　　184
第9章　默认方法　　 185
9.1　不断演进的API　　 187
9.1.1　初始版本的API　　188
9.1.2　第二版API　　188
9.2　概述默认方法　　190
9.3　默认方法的使用模式　　192
9.3.1　可选方法　　192
9.3.2　行为的多继承　　192
9.4　解决冲突的规则　　196
9.4.1　解决问题的三条规则　　196
9.4.2　选择提供了最具体实现的默认方法的接口　　197
9.4.3　冲突及如何显式地消除歧义　　198
9.4.4　菱形继承问题　　200
9.5　小结　　201
第10章　用Optional取代null　　202
10.1　如何为缺失的值建模　　 203
10.1.1　采用防御式检查减少Null-PointerException　　203
10.1.2　null带来的种种问题　　204
10.1.3　其他语言中null的替代品　　205
10.2　Optional类入门　　206
10.3　应用Optional的几种模式　　 207
10.3.1　创建Optional对象　　208
10.3.2　使用map从Optional对象中提取和转换值　　208
10.3.3　使用flatMap链接Optional对象　　209
10.3.4　默认行为及解引用Optional对象　　213
10.3.5　两个Optional对象的组合　　213
10.3.6　使用filter剔除特定的值　　214
10.4　使用Optional的实战示例　　 216
10.4.1　用Optional封装可能为null的值　　216
10.4.2　异常与Optional的对比　　217
10.4.3　把所有内容整合起来　　218
10.5　小结　　219
第11章　CompletableFuture：组合式异步编程　　220
11.1　Future接口　　222
11.1.1　Future接口的局限性　　223
11.1.2　使用CompletableFuture构建异步应用　　223
11.2　实现异步API　　 224
11.2.1　将同步方法转换为异步方法　　225
11.2.2　错误处理　　227
11.3　让你的代码免受阻塞之苦　　228
11.3.1　使用并行流对请求进行并行操作　　229
11.3.2　使用CompletableFuture发起异步请求　　230
11.3.3　寻找更好的方案　　232
11.3.4　使用定制的执行器　　233
11.4　对多个异步任务进行流水线操作　　234
11.4.1　实现折扣服务　　235
11.4.2　使用Discount服务　　236
11.4.3　构造同步和异步操作　　237
11.4.4　将两个Completable-Future对象整合起来，无论它们是否存在依赖　　239
11.4.5　对Future和Completable-Future的回顾　　241
11.5　响应CompletableFuture的completion事件　　242
11.5.1　对最佳价格查询器应用的优化　　243
11.5.2　付诸实践　　244
11.6　小结　　245
第12章　新的日期和时间API　　246
12.1　LocalDate、LocalTime、Instant、Duration以及Period　　247
12.1.1　使用LocalDate和LocalTime　　247
12.1.2　合并日期和时间　　248
12.1.3　机器的日期和时间格式　　249
12.1.4　定义Duration或Period　　249
12.2　操纵、解析和格式化日期　　251
12.2.1　使用TemporalAdjuster　　253
12.2.2　打印输出及解析日期－时间对象　　255
12.3　处理不同的时区和历法　　256
12.3.1　利用和UTC/格林尼治时间的固定偏差计算时区　　257
12.3.2　使用别的日历系统　　258
12.4　小结　　259
第四部分 超越Java 8
第13章　函数式的思考　　262
13.1　实现和维护系统　　262
13.1.1　共享的可变数据　　263
13.1.2　声明式编程　　264
13.1.3　为什么要采用函数式编程　　265
13.2　什么是函数式编程　　265
13.2.1　函数式Java编程　　266
13.2.2　引用透明性　　268
13.2.3　面向对象的编程和函数式编程的对比　　 268
13.2.4　函数式编程实战　　269
13.3　递归和迭代　　271
13.4　小结　　274
第14章　函数式编程的技巧　　275
14.1　无处不在的函数　　275
14.1.1　高阶函数　　275
14.1.2　科里化　　277
14.2　持久化数据结构　　278
14.2.1　破坏式更新和函数式更新的比较　　279
14.2.2　另一个使用Tree的例子　　281
14.2.3　采用函数式的方法　　282
14.3　Stream的延迟计算　　283
14.3.1　自定义的Stream　　 283
14.3.2　创建你自己的延迟列表　　286
14.4　模式匹配　　290
14.4.1　访问者设计模式　　291
14.4.2　用模式匹配力挽狂澜　　292
14.5　杂项　　295
14.5.1　缓存或记忆表　　295
14.5.2　“返回同样的对象”意味着什么　　296
14.5.3　结合器　　296
14.6　小结　　297
第15章　面向对象和函数式编程的混合：Java 8和Scala的比较　　 299
15.1　Scala简介　　300
15.1.1　你好，啤酒　　300
15.1.2　基础数据结构：List、Set、Map、Tuple、Stream以及Option　　302
15.2　函数　　306
15.2.1　Scala中的一等函数　　307
15.2.2　匿名函数和闭包　　307
15.2.3　科里化　　309
15.3　类和trait　　310
15.3.1　更加简洁的Scala类　　310
15.3.2　Scala的trait与Java 8的接口对比　　311
15.4　小结　　312
第16章　结论以及Java的未来　　313
16.1　回顾Java 8的语言特性　　 313
16.1.1　行为参数化（Lambda 以及方法引用）　　314
16.1.2　流　　314
16.1.3　CompletableFuture　　315
16.1.4　Optional　　315
16.1.5　默认方法　　316
16.2　Java 的未来　　316
16.2.1　集合　　316
16.2.2　类型系统的改进　　317
16.2.3　模式匹配　　318
16.2.4　更加丰富的泛型形式　　319
16.2.5　对不变性的更深层支持　　321
16.2.6　值类型　　322
16.3　写在最后的话　　325
附录A　其他语言特性的更新　　326
附录B　类库的更新　　330
附录C　如何以并发方式在同一个流上执行多种操作　　338
附录D　Lambda表达式和JVM 字节码　　346
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 8实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JAVA并发编程实践
目录
代码清单
序
第1章 介绍
1.1 并发的（非常）简短历史
1.2 线程的优点
1.3 线程的风险
1.4 线程无处不在
第1部分 基础
第2章 线程安全
2.1 什么是线程安全性
2.2 原子性
2.3 锁
2.4 用锁来保护状态
2.5 活跃度与性能
第3章 共享对象
3.1 可见性
3.2 发布和逸出
3.3 线程封闭
3.4 不可变性
3.5 安全发布
第4章 组合对象
4.1 设计线程安全的类
4.2 实例限制
4.3 委托线程安全
4.4 向已有的线程安全类添加功能
4.5 同步策略的文档化
第5章 构建块
5.1 同步容器
5.2 发容器
5.3 阻塞队列和生产者一消费者模式
5.4 阻塞和可中断的方法
5.5 Synchronizer
5.6 为计算结果建立高效、可伸缩的高速缓存
第2部分 构建并发应用程序
第6章 任务执行
6.1 在线程中执行任务
6.2 Executor 框架
6.3 寻找可强化的并行性
第7章 取消和关闭
7.1 任务取消
7.2 停止基于线程的服务
7.3 处理反常的线程终止
7.4 JVM关闭
第8章 应用线程池
8.1 任务与执行策略问的隐性耦合
8.2 定制线程池的大小
8.3 配置ThreadPoolExecutor
8.4 扩展ThreadPoolExecutor
8.5 并行递归算法
第9章 GUI应用程序
9.1 为什么GUI是单线程化的
9.2 短期的GUI任务
9.3 耗时GUI任务
9.4 共享数据模型
9.5 其他形式的单线程子系统
第3部分 活跃度，性能和测试
第10章 避免活跃度危险
第11章 性能和可伸缩性
第12章 测试并发程序
第4部分 高级主题
第13章 显示锁
第14章 构建自定义的同步工具
第15章 原子变量与非阻塞同步机制
第16章 Java存储模型
附录A 同步Annotation
参考文献
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JAVA并发编程实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式Java应用
前言
第1章 分布式Java应用
1.1 基于消息方式实现系统间的通信
1.1.1 基于Java自身技术实现消息方式的系统间通信
1.1.2 基于开源框架实现消息方式的系统间通信
1.2 基于远程调用方式实现系统间的通信
1.2.1 基于Java自身技术实现远程调用方式的系统间通信
1.2.2 基于开源框架实现远程调用方式的系统间通信
第2章 大型分布式Java应用与SOA
2.1 基于SCA实现SOA平台
2.2 基于ESB实现SOA平台
2.3 基于Tuscany实现SOA平台
2.4 基于Mule实现SOA平台
第3章 深入理解JVM
3.1 Java代码的执行机制
3.1.1 Java源码编译机制
3.1.2 类加载机制
3.1.3 类执行机制
3.2 JVM内存管理
3.2.1 内存空间
3.2.2 内存分配
3.2.3 内存回收
3.2.4 JVM内存状况查看方法和分析工具
3.3 JVM线程资源同步及交互机制
3.3.1 线程资源同步机制
3.3.2 线程交互机制
3.3.3 线程状态及分析
第4章 分布式应用与Sun JDK类库
4.1 集合包
4.1.1 ArrayList
4.1.2 LinkedList
4.1.3 Vector
4.1.4 Stack
4.1.5 HashSet
4.1.6 TreeSet
4.1.7 HashMap
4.1.8 TreeMap
4.1.9 性能测试
4.1.10 小结
4.2 并发包（java.util.concurrent）
4.2.1 ConcurrentHashMap
4.2.2 CopyOnWriteArrayList
4.2.3 CopyOnWriteArraySet
4.2.4 ArrayBlockingQueue
4.2.5 AtomicInteger
4.2.6 ThreadPoolExecutor
4.2.7 Executors
4.2.8 FutureTask
4.2.9 Semaphore
4.2.10 CountDownLatch
4.2.11 CyclicBarrier
4.2.12 ReentrantLock
4.2.13 Condition
4.2.14 ReentrantReadWriteLock
4.3 序列化/反序列化
4.3.1 序列化
4.3.2 反序列化
第5章 性能调优
5.1 寻找性能瓶颈
5.1.1 CPU消耗分析
5.1.2 文件IO消耗分析
5.1.3 网络IO消耗分析
5.1.4 内存消耗分析
5.1.5 程序执行慢原因分析
5.2 调优
5.2.1 JVM调优
5.2.2 程序调优
5.2.3 对于资源消耗不多，但程序执行慢的情况
第6章 构建高可用的系统
6.1 避免系统中出现单点
6.1.1 负载均衡技术
6.1.2 热备
6.2 提高应用自身的可用性
6.2.1 尽可能地避免故障
6.2.2 及时发现故障
6.2.3 及时处理故障
6.2.4 访问量及数据量不断上涨的应对策略
第7章 构建可伸缩的系统
7.1 垂直伸缩
7.1.1 支撑高访问量
7.1.2 支撑大数据量
7.1.3 提升计算能力
7.2 水平伸缩
7.2.1 支撑高访问量
7.2.2 支撑大数据量
7.2.3 提升计算能力
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式Java应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java并发编程的艺术
前　言
第1章　并发编程的挑战 1
1.1　上下文切换 1
1.1.1　多线程一定快吗 1
1.1.2　测试上下文切换次数和时长 3
1.1.3　如何减少上下文切换 3
1.1.4　减少上下文切换实战 4
1.2　死锁 5
1.3　资源限制的挑战 6
1.4　本章小结 7
第2章　Java并发机制的底层实现原理 8
2.1　volatile的应用 8
2.2　synchronized的实现原理与应用 11
2.2.1　Java对象头 12
2.2.2　锁的升级与对比 13
2.3　原子操作的实现原理 16
2.4　本章小结 20
第3章　Java内存模型 21
3.1　Java内存模型的基础 21
3.1.1　并发编程模型的两个关键问题 21
3.1.2　Java内存模型的抽象结构 22
3.1.3　从源代码到指令序列的重排序 23
3.1.4　并发编程模型的分类 24
3.1.5　happens-before简介 26
3.2　重排序 27
3.2.1　数据依赖性 28
3.2.2　as-if-serial语义 28
3.2.3　程序顺序规则 29
3.2.4　重排序对多线程的影响 29
3.3　顺序一致性 31
3.3.1　数据竞争与顺序一致性 31
3.3.2　顺序一致性内存模型 32
3.3.3　同步程序的顺序一致性效果 34
3.3.4　未同步程序的执行特性 35
3.4　volatile的内存语义 38
3.4.1　volatile的特性 38
3.4.2　volatile写-读建立的happens-before关系 39
3.4.3　volatile写-读的内存语义 40
3.4.4　volatile内存语义的实现 42
3.4.5　JSR-133为什么要增强volatile的内存语义 46
3.5　锁的内存语义 47
3.5.1　锁的释放-获取建立的
happens-before关系 47
3.5.2　锁的释放和获取的内存语义 48
3.5.3　锁内存语义的实现 50
3.5.4　concurrent包的实现 54
3.6　final域的内存语义 55
3.6.1　final域的重排序规则 55
3.6.2　写final域的重排序规则 56
3.6.3　读final域的重排序规则 57
3.6.4　final域为引用类型 58
3.6.5　为什么final引用不能从构造函数内“溢出” 59
3.6.6　final语义在处理器中的实现 61
3.6.7　JSR-133为什么要增强f?inal的语义 62
3.7　happens-before 62
3.7.1　JMM的设计 62
3.7.2　happens-before的定义 64
3.7.3　happens-before规则 65
3.8　双重检查锁定与延迟初始化 67
3.8.1　双重检查锁定的由来 67
3.8.2　问题的根源 69
3.8.3　基于volatile的解决方案 71
3.8.4　基于类初始化的解决方案 72
3.9　Java内存模型综述 78
3.9.1　处理器的内存模型 78
3.9.2　各种内存模型之间的关系 80
3.9.3　JMM的内存可见性保证 80
3.9.4　JSR-133对旧内存模型的修补 81
3.10　本章小结 82
第4章　Java并发编程基础 83
4.1　线程简介 83
4.1.1　什么是线程 83
4.1.2　为什么要使用多线程 84
4.1.3　线程优先级 85
4.1.4　线程的状态 87
4.1.5　Daemon线程 90
4.2　启动和终止线程 91
4.2.1　构造线程 91
4.2.2　启动线程 92
4.2.3　理解中断 92
4.2.4　过期的suspend()、resume()和stop() 93
4.2.5　安全地终止线程 95
4.3　线程间通信 96
4.3.1　volatile和synchronized关键字 96
4.3.2　等待/通知机制 98
4.3.3　等待/通知的经典范式 101
4.3.4　管道输入/输出流 102
4.3.5　Thread.join()的使用 103
4.3.6　ThreadLocal的使用 105
4.4　线程应用实例 106
4.4.1　等待超时模式 106
4.4.2　一个简单的数据库连接池示例 106
4.4.3　线程池技术及其示例 110
4.4.4　一个基于线程池技术的简单Web服务器 114
4.5　本章小结 118
第5章　Java中的锁 119
5.1　Lock接口 119
5.2　队列同步器 121
5.2.1　队列同步器的接口与示例 121
5.2.2　队列同步器的实现分析 124
5.3　重入锁 136
5.4　读写锁 140
5.4.1　读写锁的接口与示例 141
5.4.2　读写锁的实现分析 142
5.5　LockSupport工具 146
5.6　Condition接口 147
5.6.1　Condition接口与示例 148
5.6.2　Condition的实现分析 150
5.7　本章小结 154
第6章　Java并发容器和框架 155
6.1　ConcurrentHashMap的实现原理与使用 155
6.1.1　为什么要使用ConcurrentHashMap 155
6.1.2　ConcurrentHashMap的结构 156
6.1.3　ConcurrentHashMap的初始化 157
6.1.4　定位Segment 159
6.1.5　ConcurrentHashMap的操作 160
6.2　ConcurrentLinkedQueue 161
6.2.1　ConcurrentLinkedQueue的结构 162
6.2.2　入队列 162
6.2.3　出队列 165
6.3　Java中的阻塞队列 167
6.3.1　什么是阻塞队列 167
6.3.2　Java里的阻塞队列 168
6.3.3　阻塞队列的实现原理 172
6.4　Fork/Join框架 175
6.4.1　什么是Fork/Join框架 175
6.4.2　工作窃取算法 176
6.4.3　Fork/Join框架的设计 177
6.4.4　使用Fork/Join框架 177
6.4.5　Fork/Join框架的异常处理 179
6.4.6　Fork/Join框架的实现原理 179
6.5　本章小结 181
第7章　Java中的13个原子操作类 182
7.1　原子更新基本类型类 182
7.2　原子更新数组 184
7.3　原子更新引用类型 185
7.4　原子更新字段类 187
7.5　本章小结 188
第8章　Java中的并发工具类 189
8.1　等待多线程完成的CountDownLatch 189
8.2　同步屏障CyclicBarrier 191
8.2.1　CyclicBarrier简介 191
8.2.2　CyclicBarrier的应用场景 193
8.2.3　CyclicBarrier和CountDownLatch的区别 195
8.3　控制并发线程数的Semaphore 196
8.4　线程间交换数据的Exchanger 198
8.5　本章小结 199
第9章　Java中的线程池 200
9.1　线程池的实现原理 200
9.2　线程池的使用 203
9.2.1　线程池的创建 203
9.2.2　向线程池提交任务 205
9.2.3　关闭线程池 205
9.2.4　合理地配置线程池 206
9.2.5　线程池的监控 206
9.3　本章小结 207
第10章　Executor框架 208
10.1　Executor框架简介 208
10.1.1　Executor框架的两级调度模型 208
10.1.2　Executor框架的结构与成员 208
10.2　ThreadPoolExecutor详解 213
10.2.1　FixedThreadPool详解 213
10.2.2　SingleThreadExecutor详解 214
10.2.3　CachedThreadPool详解 215
10.3　ScheduledThreadPoolExecutor详解 217
10.3.1　ScheduledThreadPoolExecutor的运行机制 217
10.3.2　ScheduledThreadPoolExecutor的实现 218
10.4　FutureTask详解 221
10.4.1　FutureTask简介 222
10.4.2　FutureTask的使用 222
10.4.3　FutureTask的实现 224
10.5　本章小结 227
第11章　Java并发编程实践 228
11.1　生产者和消费者模式 228
11.1.1　生产者消费者模式实战 229
11.1.2　多生产者和多消费者场景 231
11.1.3　线程池与生产消费者模式 234
11.2　线上问题定位 234
11.3　性能测试 236
11.4　异步任务池 238
11.5　本章小结 240
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java并发编程的艺术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实战Java高并发程序设计
第1章　走入并行世界	1
1.1　何去何从的并行计算 	1
1.1.1　忘掉那该死的并行	2
1.1.2　可怕的现实：摩尔定律的失效	4
1.1.3　柳暗花明：不断地前进	5
1.1.4　光明或是黑暗	6
1.2　你必须知道的几个概念	6
1.2.1　同步（Synchronous）和异步（Asynchronous）	7
1.2.2　并发（Concurrency）和并行（Parallelism）	8
1.2.3　临界区	9
1.2.4　阻塞（Blocking）和非阻塞（Non-Blocking）	9
1.2.5　死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）	9
1.3　并发级别	11
1.3.1　阻塞（Blocking）	11
1.3.2　无饥饿（Starvation-Free）	11
1.3.3　无障碍（Obstruction-Free）	12
1.3.4　无锁（Lock-Free）	12
1.3.5　无等待（Wait-Free）	13
1.4　有关并行的两个重要定律	13
1.4.1　Amdahl定律	13
1.4.2　Gustafson定律	16
1.4.3　Amdahl定律和Gustafson定律是否相互矛盾	16
1.5　回到Java：JMM	17
1.5.1　原子性（Atomicity）	18
1.5.2　可见性（Visibility）	20
1.5.3　有序性（Ordering）	22
1.5.4　哪些指令不能重排：Happen-Before规则	27
1.6　参考文献	27
第2章　Java并行程序基础	29
2.1　有关线程你必须知道的事	29
2.2　初始线程：线程的基本操作	32
2.2.1　新建线程	32
2.2.2　终止线程	34
2.2.3　线程中断	38
2.2.4　等待（wait）和通知（notify）	41
2.2.5　挂起（suspend）和继续执行（resume）线程	44
2.2.6　等待线程结束（join）和谦让（yield）	48
2.3　volatile与Java内存模型（JMM）	50
2.4　分门别类的管理：线程组	52
2.5　驻守后台：守护线程（Daemon）	54
2.6　先干重要的事：线程优先级	55
2.7　线程安全的概念与synchronized	57
2.8　程序中的幽灵：隐蔽的错误	61
2.8.1　无提示的错误案例	61
2.8.2　并发下的ArrayList	62
2.8.3　并发下诡异的HashMap	63
2.8.4　初学者常见问题：错误的加锁	66
2.9　参考文献	68
第3章　JDK并发包	70
3.1　多线程的团队协作：同步控制	70
3.1.1　synchronized的功能扩展：重入锁	71
3.1.2　重入锁的好搭档：Condition条件	80
3.1.3　允许多个线程同时访问：信号量（Semaphore）	83
3.1.4　ReadWriteLock读写锁	85
3.1.5　倒计时器：CountDownLatch	87
3.1.6　循环栅栏：CyclicBarrier	89
3.1.7　线程阻塞工具类：LockSupport	92
3.2　线程复用：线程池	95
3.2.1　什么是线程池	96
3.2.2　不要重复发明轮子：JDK对线程池的支持	97
3.2.3　刨根究底：核心线程池的内部实现	102
3.2.4　超负载了怎么办：拒绝策略	106
3.2.5　自定义线程创建：ThreadFactory	109
3.2.6　我的应用我做主：扩展线程池	110
3.2.7　合理的选择：优化线程池线程数量	112
3.2.8　堆栈去哪里了：在线程池中寻找堆栈	113
3.2.9　分而治之：Fork/Join框架	117
3.3　不要重复发明轮子：JDK的并发容器	121
3.3.1　超好用的工具类：并发集合简介	121
3.3.2　线程安全的HashMap	122
3.3.3　有关List的线程安全	123
3.3.4　高效读写的队列：深度剖析ConcurrentLinkedQueue	123
3.3.5　高效读取：不变模式下的CopyOnWriteArrayList	129
3.3.6　数据共享通道：BlockingQueue	130
3.3.7　随机数据结构：跳表（SkipList）	134
3.4　参考资料	136
第4章　锁的优化及注意事项	138
4.1　有助于提高“锁”性能的几点建议	139
4.1.1　减小锁持有时间	139
4.1.2　减小锁粒度	140
4.1.3　读写分离锁来替换独占锁	142
4.1.4　锁分离	142
4.1.5　锁粗化	144
4.2　Java虚拟机对锁优化所做的努力	146
4.2.1　锁偏向	146
4.2.2　轻量级锁	146
4.2.3　自旋锁	146
4.2.4　锁消除	146
4.3　人手一支笔：ThreadLocal	147
4.3.1　ThreadLocal的简单使用	148
4.3.2　ThreadLocal的实现原理	149
4.3.3　对性能有何帮助	155
4.4　无锁	157
4.4.1　与众不同的并发策略：比较交换（CAS）	158
4.4.2　无锁的线程安全整数：AtomicInteger	159
4.4.3　Java中的指针：Unsafe类	161
4.4.4　无锁的对象引用：AtomicReference	162
4.4.5　带有时间戳的对象引用：AtomicStampedReference	165
4.4.6　数组也能无锁：AtomicIntegerArray	168
4.4.7　让普通变量也享受原子操作：AtomicIntegerFieldUpdater	169
4.4.8　挑战无锁算法：无锁的Vector实现	171
4.4.9　让线程之间互相帮助：细看SynchronousQueue的实现	176
4.5　有关死锁的问题	179
4.6　参考文献	183
第5章　并行模式与算法	184
5.1　探讨单例模式	184
5.2　不变模式	187
5.3　生产者-消费者模式	190
5.4　高性能的生产者-消费者：无锁的实现	194
5.4.1　无锁的缓存框架：Disruptor	195
5.4.2　用Disruptor实现生产者-消费者案例	196
5.4.3　提高消费者的响应时间：选择合适的策略	199
5.4.4　CPU Cache的优化：解决伪共享问题	200
5.5　Future模式	204
5.5.1　Future模式的主要角色	206
5.5.2　Future模式的简单实现	207
5.5.3　JDK中的Future模式	210
5.6　并行流水线	212
5.7　并行搜索	216
5.8　并行排序	218
5.8.1　分离数据相关性：奇偶交换排序	218
5.8.2　改进的插入排序：希尔排序	221
5.9　并行算法：矩阵乘法	226
5.10　准备好了再通知我：网络NIO	230
5.10.1　基于Socket的服务端的多线程模式	230
5.10.2　使用NIO进行网络编程	235
5.10.3　使用NIO来实现客户端	243
5.11　读完了再通知我：AIO	245
5.11.1　AIO EchoServer的实现	245
5.11.2　AIO Echo客户端实现	248
5.12　参考文献	249
第6章　Java 8与并发	251
6.1　Java 8的函数式编程简介	251
6.1.1　函数作为一等公民	252
6.1.2　无副作用	252
6.1.3　申明式的（Declarative）	253
6.1.4　不变的对象	254
6.1.5　易于并行	254
6.1.6　更少的代码	254
6.2　函数式编程基础	255
6.2.1　FunctionalInterface注释	255
6.2.2　接口默认方法	256
6.2.3　lambda表达式	259
6.2.4　方法引用	260
6.3　一步一步走入函数式编程	263
6.4　并行流与并行排序	267
6.4.1　使用并行流过滤数据	267
6.4.2　从集合得到并行流	268
6.4.3　并行排序	268
6.5　增强的Future：CompletableFuture	269
6.5.1　完成了就通知我	269
6.5.2　异步执行任务	270
6.5.3　流式调用	272
6.5.4　CompletableFuture中的异常处理	272
6.5.5　组合多个CompletableFuture	273
6.6　读写锁的改进：StampedLock	274
6.6.1　StampedLock使用示例	275
6.6.2　StampedLock的小陷阱	276
6.6.3　有关StampedLock的实现思想	278
6.7　原子类的增强	281
6.7.1　更快的原子类：LongAdder	281
6.7.2　LongAdder的功能增强版：LongAccumulator	287
6.8　参考文献	288
第7章　使用Akka构建高并发程序	289
7.1　新并发模型：Actor	290
7.2　Akka之Hello World	290
7.3　有关消息投递的一些说明	293
7.4　Actor的生命周期	295
7.5　监督策略	298
7.6　选择Actor	303
7.7　消息收件箱（Inbox）	303
7.8　消息路由	305
7.9　Actor的内置状态转换	308
7.10　询问模式：Actor中的Future	311
7.11　多个Actor同时修改数据：Agent	313
7.12　像数据库一样操作内存数据：软件事务内存	316
7.13　一个有趣的例子：并发粒子群的实现	319
7.13.1　什么是粒子群算法	320
7.13.2　粒子群算法的计算过程	320
7.13.3　粒子群算法能做什么	322
7.13.4　使用Akka实现粒子群	323
7.14　参考文献	330
第8章　并行程序调试	331
8.1　准备实验样本	331
8.2　正式起航	332
8.3　挂起整个虚拟机	334
8.4　调试进入ArrayList内部	336
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实战Java高并发程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java性能权威指南
推荐序　　xi
前言　　xii
第1章　导论　　1
1.1　概述　　2
1.2　平台版本约定　　2
1.3　全面的性能调优　　4
1.3.1　编写更好的算法　　4
1.3.2　编写更少的代码　　4
1.3.3　老调重弹的过早优化　　5
1.3.4　其他：数据库很可能就是瓶颈　　6
1.3.5　常见的优化　　7
1.4　小结　　8
第2章　性能测试方法　　9
2.1　原则1：测试真实应用　　9
2.1.1　微基准测试　　9
2.1.2　宏基准测试　　13
2.1.3　介基准测试　　15
2.1.4　代码示例　　16
2.2　原则2：理解批处理流逝时间、吞吐量和响应时间　　19
2.2.1　批处理流逝时间　　19
2.2.2　吞吐量测试　　20
2.2.3　响应时间测试　　20
2.3　原则3：用统计方法应对性能的变化　　23
2.4　原则4：尽早频繁测试　　26
2.5　小结　　28
第3章　Java性能调优工具箱　　29
3.1　操作系统的工具和分析　　29
3.1.1　CPU使用率　　29
3.1.2　CPU运行队列　　32
3.1.3　磁盘使用率　　33
3.1.4　网络使用率　　34
3.2　Java监控工具　　35
3.2.1　基本的VM信息　　36
3.2.2　线程信息　　39
3.2.3　类信息　　39
3.2.4　实时GC分析　　39
3.2.5　事后堆转储　　39
3.3　性能分析工具　　39
3.3.1　采样分析器　　40
3.3.2　探查分析器　　41
3.3.3　阻塞方法和线程时间线　　42
3.3.4　本地分析器　　44
3.4　Java任务控制　　45
3.4.1　Java飞行记录器　　46
3.4.2　开启JFR　　52
3.4.3　选择JFR 事件　　54
3.5　小结　　56
第4章　JIT编译器　　58
4.1　JIT编译器：概览　　58
4.2　调优入门：选择编译器类型（Client、Server或二者同用）　　61
4.2.1　优化启动　　62
4.2.2　优化批处理　　63
4.2.3　优化长时间运行的应用　　64
4.3　Java和JIT编译器版本　　64
4.4　编译器中级调优　　67
4.4.1　调优代码缓存　　67
4.4.2　编译阈值　　68
4.4.3　检测编译过程　　70
4.5　高级编译器调优　　73
4.5.1　编译线程　　73
4.5.2　内联　　74
4.5.3　逃逸分析　　75
4.6　逆优化　　76
4.6.1　代码被丢弃　　77
4.6.2　逆优化僵尸代码　　78
4.7　分层编译级别　　79
4.8　小结　　80
第5章　垃圾收集入门　　81
5.1　垃圾收集概述　　81
5.1.1　分代垃圾收集器　　83
5.1.2　GC算法　　84
5.1.3　选择GC算法　　87
5.2　GC调优基础　　92
5.2.1　调整堆的大小　　92
5.2.2　代空间的调整　　95
5.2.3　永久代和元空间的调整　　96
5.2.4　控制并发　　97
5.2.5　自适应调整　　98
5.3　垃圾回收工具　　99
5.4　小结　　102
第6章　垃圾收集算法　　103
6.1　理解Throughput收集器　　103
6.2　理解CMS收集器　　109
6.2.1　针对并发模式失效的调优　　113
6.2.2　CMS收集器的永久代调优　　116
6.2.3　增量式CMS垃圾收集　　117
6.3　理解G1垃圾收集器　　118
6.4　高级调优　　126
6.4.1　晋升及Survivor空间　　126
6.4.2　分配大对象　　129
6.4.3　AggressiveHeap标志　　136
6.4.4　全盘掌控堆空间的大小　　137
6.5　小结　　138
第7章　堆内存最佳实践　　140
7.1　堆分析　　140
7.1.1　堆直方图　　141
7.1.2　堆转储　　142
7.1.3　内存溢出错误　　146
7.2　减少内存使用　　149
7.2.1　减少对象大小　　149
7.2.2　延迟初始化　　152
7.2.3　不可变对象和标准化对象　　156
7.2.4　字符串的保留　　157
7.3　对象生命周期管理　　160
7.3.1　对象重用　　160
7.3.2　弱引用、软引用与其他引用　　165
7.4　小结　　175
第8章　原生内存最佳实践　　176
8.1　内存占用　　176
8.1.1　测量内存占用　　177
8.1.2　内存占用最小化　　178
8.1.3　原生NIO缓冲区　　178
8.1.4　原生内存跟踪　　179
8.2　针对不同操作系统优化JVM　　182
8.2.1　大页　　182
8.2.2　压缩的oop　　185
8.3　小结　　187
第9章　线程与同步的性能　　188
9.1　线程池与ThreadPoolExecutor　　188
9.1.1　设置最大线程数　　189
9.1.2　设置最小线程数　　192
9.1.3　线程池任务大小　　193
9.1.4　设置ThreadPoolExecutor的大小　　193
9.2　ForkJoinPool　　195
9.3　线程同步　　201
9.3.1　同步的代价　　202
9.3.2　避免同步　　205
9.3.3　伪共享　　208
9.4　JVM线程调优　　211
9.4.1　调节线程栈大小　　211
9.4.2　偏向锁　　212
9.4.3　自旋锁　　212
9.4.4　线程优先级　　213
9.5　监控线程与锁　　213
9.5.1　查看线程　　214
9.5.2　查看阻塞线程　　214
9.6　小结　　217
第10章　Java EE 性能调优　　218
10.1　Web容器的基本性能　　218
10.2　线程池　　222
10.3　EJB会话Bean　　223
10.3.1　调优EJB对象池　　223
10.3.2　调优EJB缓存　　225
10.3.3　本地和远程实例　　226
10.4　XML和JSON处理　　227
10.4.1　数据大小　　227
10.4.2　解析和编组概述　　229
10.4.3　选择解析器　　230
10.4.4　XML验证　　235
10.4.5　文档模型　　237
10.4.6　Java对象模型　　240
10.5　对象序列化　　241
10.5.1　transient字段　　241
10.5.2　覆盖默认的序列化　　241
10.5.3　压缩序列化数据　　244
10.5.4　追踪对象复制　　246
10.6　Java EE网络API　　248
10.7　小结　　250
第11章　数据库性能的最佳实践　　251
11.1　JDBC　　251
11.1.1　JDBC驱动程序　　252
11.1.2　预处理语句和语句池　　253
11.1.3　JDBC连接池　　255
11.1.4　事务　　256
11.1.5　结果集的处理　　262
11.2　JPA　　264
11.2.1　事务处理　　264
11.2.2　对JPA的写性能进行优化　　267
11.2.3　对JPA的读性能进行优化　　268
11.2.4　JPA缓存　　271
11.2.5　JPA的只读实体　　276
11.3　小结　　277
第12章　Java SE API技巧　　278
12.1　缓冲式I/O　　278
12.2　类加载　　280
12.3　随机数　　284
12.4　Java原生接口　　285
12.5　异常　　287
12.6　字符串的性能　　290
12.7　日志　　291
12.8　Java集合类API　　292
12.8.1　同步还是非同步　　293
12.8.2　设定集合的大小　　294
12.8.3　集合与内存使用效率　　295
12.9　AggressiveOpts标志　　296
12.9.1　替代实现　　296
12.9.2　其他标志　　297
12.10　Lambda表达式和匿名类　　297
12.11　流和过滤器的性能　　300
12.12　小结　　302
附录A　性能调优标志摘要　　303
作者简介　　312
关于封面　　312
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java性能权威指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入剖析Tomcat
译者序
前　言
第1章　一个简单的Web服务器1
1.1　HTTP1
1.1.1　HTTP请求1
1.1.2　HTTP响应2
1.2　Socket类3
1.3　应用程序5
1.3.1　HttpServer类5
1.3.2　Request类8
1.3.3　Response类10
1.3.4　运行应用程序12
1.4　小结13
第2章　一个简单的servlet容器14
2.1　javax.servlet.Servlet接口14
2.2　应用程序 116
2.2.1　HttpServer1类17
2.2.2　Request类19
2.2.3　Response类21
2.2.4　 StaticResourceProcessor类23
2.2.5　servletProcessor1类24
2.2.6　运行应用程序27
2.3　应用程序227
2.4　小结30
第3章　连接器31
3.1　StringManager类31
3.2　应用程序33
3.2.1　启动应用程序35
3.2.2　HttpConnector类36
3.2.3　创建HttpRequest对象38
3.2.4　创建HttpResponse对象49
3.2.5　静态资源处理器和servlet处理器50
3.2.6　运行应用程序50
3.3　小结52
第4章　Tomcat的默认连接器53
4.1　HTTP 1.1的新特性54
4.1.1　持久连接54
4.1.2　块编码54
4.1.3　状态码100的使用55
4.2　Connector接口55
4.3　HttpConnector类56
4.3.1　创建服务器套接字56
4.3.2　维护HttpProcessor实例56
4.3.3　提供HTTP请求服务57
4.4　HttpProcessor类58
4.5　Request对象61
4.6　Response对象62
4.7　处理请求62
4.7.1　解析连接65
4.7.2　解析请求65
4.7.3　解析请求头65
4.8　简单的Container应用程序66
4.9　小结70
第5章　servlet容器71
5.1　Container接口71
5.2　管道任务73
5.2.1　Pipeline接口76
5.2.2　Valve接口76
5.2.3　ValveContext接口76
5.2.4　Contained接口77
5.3　Wrapper接口77
5.4　Context接口78
5.5　Wrapper应用程序78
5.5.1　ex05.pyrmont.core.SimpleLoader类78
5.5.2　ex05.pyrmont.core.SimplePipeline类79
5.5.3　ex05.pyrmont.core.SimpleWrapper类79
5.5.4　ex05.pyrmont.core.SimpleWrapperValve类80
5.5.5　ex05.pyrmont.valves.ClientIPLoggerValve类81
5.5.6　ex05.pyrmont.valves.HeaderLoggerValve类81
5.5.7　ex05.pyrmont.startup.Bootstrap182
5.5.8　运行应用程序84
5.6　Context应用程序84
5.6.1　ex05.pyrmont.core.SimpleContextValve类87
5.6.2　ex05.pyrmont.core.SimpleContextMapper类87
5.6.3　ex05.pyrmont.core.SimpleContext类89
5.6.4　ex05.pyrmont.startup.Bootstrap289
5.6.5　运行应用程序91
5.7　小结92
第6章　生命周期93
6.1　Lifecycle接口93
6.2　LifecycleEvent类94
6.3　LifecycleListener接口94
6.4　LifecycleSupport类95
6.5　应用程序97
6.5.1　ex06.pyrmont.core.SimpleContext类97
6.5.2　ex06.pyrmont.core.SimpleContextLifecycleListener类100
6.5.3　ex06.pyrmont.core.SimpleLoader类101
6.5.4　ex06.pyrmont.core.SimplePipeline类101
6.5.5　ex06.pyrmont.core.SimpleWrapper类101
6.5.6　运行应用程序103
6.6　小结104
第7章　日志记录器105
7.1　Logger接口105
7.2　Tomcat的日志记录器106
7.2.1　LoggerBase类106
7.2.2　SystemOutLogger类107
7.2.3　SystemErrLogger类107
7.2.4　FileLogger类108
7.3　应用程序111
7.4　小结112
第8章　载入器113
8.1　Java的类载入器113
8.2　Loader接口114
8.3　Reloader接口116
8.4　WebappLoader类116
8.4.1　创建类载入器117
8.4.2　设置仓库118
8.4.3　设置类路径118
8.4.4　设置访问权限118
8.4.5　开启新线程执行类的重新载入118
8.5　WebappClassLoader类120
8.5.1　类缓存120
8.5.2　载入类121
8.5.3　应用程序121
8.6　运行应用程序124
8.7　小结124
第9章　Session管理125
9.1　Session对象126
9.1.1　Session接口126
9.1.2　StandardSession类127
9.1.3　StandardSessionFacade类129
9.2　Manager130
9.2.1　Manager接口130
9.2.2　ManagerBase类131
9.2.3　StandardManager类132
9.2.4　PersistentManagerBase类133
9.2.5　PersistentManager类135
9.2.6　DistributedManager类135
9.3　存储器136
9.3.1　StoreBase类137
9.3.2　FileStore类138
9.3.3　JDBCStore类139
9.4　应用程序139
9.4.1　Bootstrap类139
9.4.2　SimpleWrapperValve类140
9.4.3　运行应用程序141
9.5　小结142
第10章　安全性143
10.1　领域143
10.2　GenericPrincipal类144
10.3　LoginConfig类145
10.4　Authenticator接口145
10.5　安装验证器阀146
10.6　应用程序147
10.6.1　ex10.pyrmont.core.SimpleContextConfig类147
10.6.2　ex10.pyrmont.realm.SimpleRealm类149
10.6.3　ex10.pyrmont.realm.SimpleUserDatabaseRealm152
10.6.4　ex10.pyrmont.startup.Bootstrap1类154
10.6.5　ex10.pyrmont.startup.Bootstrap2类156
10.6.6　运行应用程序158
10.7　小结158
第11章　StandardWrapper159
11.1　方法调用序列159
11.2　SingleThreadModel160
11.3　StandardWrapper161
11.3.1　分配servlet实例162
11.3.2　载入servlet类164
11.3.3　ServletConfig对象167
11.3.4　servlet容器的父子关系169
11.4　StandardWrapperFacade类170
11.5　StandardWrapperValve类171
11.6　FilterDef类172
11.7　ApplicationFilterConfig类174
11.8　ApplicationFilterChain类175
11.9　应用程序175
11.10　小结177
第12章　StandardContext类178
12.1　StandardContext的配置178
12.1.1　StandardContext类的构造函数179
12.1.2　启动StandardContext实例179
12.1.3　invoke()方法183
12.2　StandardContextMapper类184
12.3　对重载的支持187
12.4　backgroundProcess()方法188
12.5　小结190
第13章　Host和Engine191
13.1　Host接口191
13.2　StandardHost类193
13.3　StandardHostMapper类195
13.4　StandardHostValve类196
13.5　为什么必须要有一个Host容器197
13.6　应用程序1198
13.7　Engine接口199
13.8　StandardEngine类201
13.9　StandardEngineValve类201
13.10　应用程序2202
13.11　小结203
第14章　服务器组件和服务组件204
14.1　服务器组件204
14.2　StandardServer类206
14.2.1　initialize()方法206
14.2.2　start()方法207
14.2.3　stop()方法207
14.2.4　await()方法208
14.3　Service接口209
14.4　StandardService类211
14.4.1　connector和container211
14.4.2　与生命周期有关的方法213
14.5　应用程序215
14.5.1　Bootstrap类215
14.5.2　Stopper类217
14.5.3　运行应用程序218
14.6　小结219
第15章　Digester库220
15.1　Digester库221
15.1.1　Digester类221
15.1.2　Digester库示例1225
15.1.3　Digester库示例2227
15.1.4　Rule类230
15.1.5　Digester库示例3：使用RuleSet232
15.2　ContextConfig类234
15.2.1　defaultConfig()方法236
15.2.2　applicationConfig()方法238
15.2.3　创建Web Digester239
15.3　应用程序243
15.4　小结244
第16章　关闭钩子245
16.1　关闭钩子的例子246
16.2　Tomcat中的关闭钩子250
16.3　小结250
第17章　启动Tomcat251
17.1　Catalina类251
17.1.1　start()方法253
17.1.2　stop()方法256
17.1.3　启动Digester对象256
17.1.4　关闭Digester对象258
17.2　Bootstrap类259
17.3　在Windows平台上运行Tomcat264
17.3.1　如何编写批处理文件264
17.3.2　catalina.bat批处理文件267
17.3.3　在Windows平台上启动Tomcat276
17.3.4　在Windows平台上关闭Tomcat277
17.4　在Linux平台上运行Tomcat278
17.4.1　如何编写UNIX/Linux Shell脚本278
17.4.2　catalina.sh脚本283
17.4.3　在UNIX/Linux平台上启动Tomcat288
17.4.4　在UNIX/Linux平台上关闭Tomcat289
17.5 　小结290
第18章　部署器291
18.1　部署一个Web应用程序291
18.1.1　部署一个描述符294
18.1.2　部署一个WAR文件295
18.1.3　部署一个目录297
18.1.4　动态部署297
18.2　Deploy接口299
18.3　StandardHostDeployer类302
18.3.1　安装一个描述符303
18.3.2　安装一个WAR文件或目录304
18.3.3　启动Context实例305
18.3.4　停止一个Context实例306
18.4　小结306
第19章　Manager应用程序的servlet类307
19.1　使用Manager应用程序307
19.2　Containerservlet接口309
19.3　初始化ManagerServlet309
19.4　列出已经部署的Web应用程序311
19.5　启动Web应用程序312
19.6　关闭Web应用程序313
19.7　小结314
第20章　基于JMX的管理315
20.1　JMX简介315
20.2　JMX API316
20.2.1　MBeanServer类316
20.2.2　ObjectName类317
20.3　标准MBean318
20.4　模型MBean321
20.4.1　MBeanInfo接口与ModelMBeanInfo接口322
20.4.2　ModelMBean示例323
20.5　Commons Modeler库326
20.5.1　MBean描述符327
20.5.2　mbean元素示例328
20.5.3　自己编写一个模型 MBean类329
20.5.4　Registry类329
20.5.5　ManagedBean329
20.5.6　BaseModelMBean329
20.5.7　使用Modeler库API330
20.6　Catalian中的MBean332
20.6.1　ClassNameMBean类333
20.6.2　StandardServerMBean类333
20.6.3　MBeanFactory类334
20.6.4　MBeanUtil335
20.7　创建Catalina的MBean335
20.8　应用程序339
20.9　小结342
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入剖析Tomcat
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构与算法分析
出版者的话
前言
第1章　引论1
1.1　本书讨论的内容1
1.2　数学知识复习2
1.2.1　指数2
1.2.2　对数2
1.2.3　级数2
1.2.4　模运算4
1.2.5　证明的方法4
1.3　递归简论5
1.4　实现泛型构件pre-Java 57
1.4.1　使用Object表示泛型8
1.4.2　基本类型的包装9
1.4.3　使用接口类型表示泛型9
1.4.4　数组类型的兼容性10
1.5　利用Java 5泛型特性实现泛型构件11
1.5.1　简单的泛型类和接口11
1.5.2　自动装箱/拆箱11
1.5.3　菱形运算符12
1.5.4　带有限制的通配符12
1.5.5　泛型static方法14
1.5.6　类型限界14
1.5.7　类型擦除15
1.5.8　对于泛型的限制15
1.6　函数对象16
小结18
练习18
参考文献19
第2章　算法分析20
2.1　数学基础20
2.2　模型22
2.3　要分析的问题22
2.4　运行时间计算24
2.4.1　一个简单的例子24
2.4.2　一般法则24
2.4.3　最大子序列和问题的求解26
2.4.4　运行时间中的对数31
2.4.5　分析结果的准确性33
小结33
练习34
参考文献37
第3章　表、栈和队列39
3.1　抽象数据类型39
3.2　表ADT39
3.2.1　表的简单数组实现40
3.2.2　简单链表40
3.3　Java Collections API中的表41
3.3.1　Collection接口41
3.3.2　Iterator接口42
3.3.3　List接口、ArrayList类和LinkedList类43
3.3.4　例子：remove方法对LinkedList类的使用44
3.3.5　关于ListIterator接口46
3.4　ArrayList类的实现46
3.4.1　基本类46
3.4.2　迭代器、Java嵌套类和内部类49
3.5　LinkedList类的实现52
3.6　栈ADT58
3.6.1　栈模型58
3.6.2　栈的实现59
3.6.3　应用59
3.7　队列ADT65
3.7.1　队列模型65
3.7.2　队列的数组实现65
3.7.3　队列的应用66
小结67
练习67
第4章　树71
4.1　预备知识71
4.1.1　树的实现72
4.1.2　树的遍历及应用72
4.2　二叉树75
4.2.1　实现76
4.2.2　例子：表达式树76
4.3　查找树ADT——二叉查找树78
4.3.1　contains方法79
4.3.2　findMin方法和findMax方法80
4.3.3　insert方法80
4.3.4　remove方法82
4.3.5　平均情况分析83
4.4　AVL树86
4.4.1　单旋转87
4.4.2　双旋转89
4.5　伸展树94
4.5.1　一个简单的想法（不能直接使用）95
4.5.2　展开96
4.6　再探树的遍历100
4.7　B树101
4.8　标准库中的集合与映射105
4.8.1　关于Set接口105
4.8.2　关于Map接口105
4.8.3　TreeSet类和TreeMap类的实现106
4.8.4　使用多个映射的实例106
小结111
练习111
参考文献115
第5章　散列117
5.1　一般想法117
5.2　散列函数117
5.3　分离链接法119
5.4　不用链表的散列表123
5.4.1　线性探测法123
5.4.2　平方探测法124
5.4.3　双散列129
5.5　再散列130
5.6　标准库中的散列表132
5.7　最坏情形下O(1)访问的散列表 133
5.7.1　完美散列133
5.7.2　布谷鸟散列135
5.7.3　跳房子散列143
5.8　通用散列法146
5.9　可扩散列148
小结149
练习150
参考文献153
第6章　优先队列（堆）156
6.1　模型156
6.2　一些简单的实现156
6.3　二叉堆157
6.3.1　结构性质157
6.3.2　堆序性质157
6.3.3　基本的堆操作158
6.3.4　其他的堆操作162
6.4　优先队列的应用164
6.4.1　选择问题164
6.4.2　事件模拟165
6.5　d-堆166
6.6　左式堆167
6.6.1　左式堆性质167
6.6.2　左式堆操作168
6.7　斜堆172
6.8　二项队列173
6.8.1　二项队列结构174
6.8.2　二项队列操作174
6.8.3　二项队列的实现176
6.9　标准库中的优先队列180
小结180
练习181
参考文献184
第7章　排序186
7.1　预备知识186
7.2　插入排序186
7.2.1　算法186
7.2.2　插入排序的分析187
7.3　一些简单排序算法的下界187
7.4　希尔排序188
7.5　堆排序191
7.6　归并排序193
7.7　快速排序198
7.7.1　选取枢纽元199
7.7.2　分割策略200
7.7.3　小数组202
7.7.4　实际的快速排序例程202
7.7.5　快速排序的分析203
7.7.6　选择问题的线性期望时间算法206
7.8　排序算法的一般下界207
7.9　选择问题的决策树下界209
7.10　对手下界210
7.11　线性时间的排序：桶排序和基数排序212
7.12　外部排序216
7.12.1　为什么需要一些新的算法217
7.12.2　外部排序模型217
7.12.3　简单算法217
7.12.4　多路合并218
7.12.5　多相合并219
7.12.6　替换选择219
小结220
练习221
参考文献225
第8章　不相交集类227
8.1　等价关系227
8.2　动态等价性问题227
8.3　基本数据结构229
8.4　灵巧求并算法231
8.5　路径压缩233
8.6　路径压缩和按秩求并的最坏情形234
8.6.1　缓慢增长的函数235
8.6.2　利用递归分解的分析235
8.6.3　O(M log*N)界240
8.6.4　O(Mα(M,N))界240
8.7　一个应用241
小结243
练习243
参考文献244
第9章　图论算法246
9.1　若干定义246
9.2　拓扑排序248
9.3　最短路径算法250
9.3.1　无权最短路径251
9.3.2　Dijkstra算法254
9.3.3　具有负边值的图258
9.3.4　无圈图259
9.3.5　所有点对最短路径261
9.3.6　最短路径的例子261
9.4　网络流问题262
9.5　最小生成树267
9.5.1　Prim算法267
9.5.2　Kruskal算法269
9.6　深度优先搜索的应用270
9.6.1　无向图270
9.6.2　双连通性271
9.6.3　欧拉回路273
9.6.4　有向图275
9.6.5　查找强分支276
9.7　NP-完全性介绍277
9.7.1　难与易278
9.7.2　NP类278
9.7.3　NP-完全问题279
小结280
练习280
参考文献284
第10章　算法设计技巧288
10.1　贪婪算法288
10.1.1　一个简单的调度问题288
10.1.2　哈夫曼编码290
10.1.3　近似装箱问题293
10.2　分治算法298
10.2.1　分治算法的运行时间298
10.2.2　最近点问题300
10.2.3　选择问题302
10.2.4　一些算术问题的理论改进304
10.3　动态规划307
10.3.1　用一个表代替递归307
10.3.2　矩阵乘法的顺序安排309
10.3.3　最优二叉查找树311
10.3.4　所有点对最短路径312
10.4　随机化算法314
10.4.1　随机数发生器315
10.4.2　跳跃表319
10.4.3　素性测试320
10.5　回溯算法322
10.5.1　收费公路重建问题323
10.5.2　博弈326
小结331
练习331
参考文献336
第11章　摊还分析340
11.1　一个无关的智力问题340
11.2　二项队列340
11.3　斜堆344
11.4　斐波那契堆345
11.4.1　切除左式堆中的节点346
11.4.2　二项队列的懒惰合并347
11.4.3　斐波那契堆操作349
11.4.4　时间界的证明350
11.5　伸展树351
小结354
练习354
参考文献355
第12章　高级数据结构及其实现356
12.1　自顶向下伸展树356
12.2　红黑树362
12.2.1　自底向上的插入362
12.2.2　自顶向下红黑树363
12.2.3　自顶向下的删除367
12.3　treap树368
12.4　后缀数组与后缀树370
12.4.1　后缀数组371
12.4.2　后缀树373
12.4.3　线性时间的后缀数组和后缀树的构建375
12.5　k-d树385
12.6　配对堆387
小结392
练习393
参考文献396
索引399
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构与算法分析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入分析Java Web技术内幕（修订版）
第1章  深入Web请求过程	1
1.1  B/S网络架构概述	2
1.2  如何发起一个请求	4
1.3  HTTP解析	6
1.3.1  查看HTTP信息的工具	8
1.3.2  浏览器缓存机制	9
1.4  DNS域名解析	12
1.4.1  DNS域名解析过程	12
1.4.2  跟踪域名解析过程	15
1.4.3  清除缓存的域名	18
1.4.4  几种域名解析方式	19
1.5  CDN工作机制	20
1.5.1  CDN架构	20
1.5.2  负载均衡	21
1.5.3  CDN动态加速	24
1.6  总结	25
第2章  深入分析Java I/O的工作机制	26
2.1  Java的I/O类库的基本架构	26
2.1.1  基于字节的I/O操作接口	27
2.1.2  基于字符的I/O操作接口	28
2.1.3  字节与字符的转化接口	29
2.2  磁盘I/O工作机制	30
2.2.1  几种访问文件的方式	30
2.2.2  Java访问磁盘文件	34
2.2.3  Java序列化技术	35
2.3  网络I/O工作机制	37
2.3.1  TCP状态转化	38
2.3.2  影响网络传输的因素	40
2.3.3  Java Socket的工作机制	40
2.3.4  建立通信链路	41
2.3.5  数据传输	42
2.4  NIO的工作方式	42
2.4.1  BIO带来的挑战	42
2.4.2  NIO的工作机制	43
2.4.3  Buffer的工作方式	46
2.4.4  NIO的数据访问方式	48
2.5  I/O调优	50
2.5.1  磁盘I/O优化	50
2.5.2  TCP网络参数调优	51
2.5.3  网络I/O优化	53
2.6  设计模式解析之适配器模式	57
2.6.1  适配器模式的结构	57
2.6.2  Java I/O中的适配器模式	58
2.7  设计模式解析之装饰器模式	58
2.7.1  装饰器模式的结构	59
2.7.2  Java I/O中的装饰器模式	59
2.8  适配器模式与装饰器模式的区别	60
2.9  总结	60
第3章  深入分析Java Web中的中文编码问题	61
3.1  几种常见的编码格式	61
3.1.1  为什么要编码	61
3.1.2  如何“翻译”	62
3.2  在Java中需要编码的场景	64
3.2.1  在I/O操作中存在的编码	64
3.2.2  在内存操作中的编码	66
3.3  在Java中如何编解码	67
3.3.1  按照ISO-8859-1编码	69
3.3.2  按照GB2312编码	70
3.3.3  按照GBK编码	71
3.3.4  按照UTF-16编码	71
3.3.5  按照UTF-8编码	72
3.3.6  UTF-8编码代码片段	72
3.3.7  对几种编码格式的比较	74
3.4  在Java Web中涉及的编解码	74
3.4.1  URL的编解码	76
3.4.2  HTTP Header的编解码	79
3.4.3  POST表单的编解码	79
3.4.4  HTTP BODY的编解码	80
3.5  在JS中的编码问题	81
3.5.1  外部引入JS文件	81
3.5.2  JS的URL编码	82
3.5.3  其他需要编码的地方	84
3.6  常见问题分析	84
3.6.1  中文变成了看不懂的字符	84
3.6.2  一个汉字变成一个问号	85
3.6.3  一个汉字变成两个问号	85
3.6.4  一种不正常的正确编码	86
3.7  一种繁简转换的实现方式	87
3.8  总结	88
第4章  Javac编译原理	89
4.1  Javac是什么	90
4.2  Javac编译器的基本结构	90
4.3  Javac工作原理分析	92
4.3.1  词法分析器	93
4.3.2  语法分析器	100
4.3.3  语义分析器	105
4.3.4  代码生成器	115
4.4  设计模式解析之访问者模式	118
4.4.1  访问者模式的结构	119
4.4.2  Javac中访问者模式的实现	120
4.5  总结	121
第5章  深入class文件结构	122
5.1  JVM指令集简介	122
5.1.1  与类相关的指令	124
5.1.2  方法的定义	125
5.1.3  属性的定义	126
5.1.4  其他指令集	127
5.2  class文件头的表示形式	135
5.3  常量池	139
5.3.1  UTF8常量类型	142
5.3.2  Fieldref、Methodref常量类型	143
5.3.3  Class常量类型	143
5.3.4  NameAndType常量类型	144
5.4  类信息	144
5.5  Fields和Methods定义	145
5.6  类属性描述	149
5.7  Javap生成的class文件结构	150
5.7.1  LineNumberTable	152
5.7.2  LocalVariableTable	153
5.8  总结	155
第6章  深入分析ClassLoader工作机制	156
6.1  ClassLoader类结构分析	157
6.2  ClassLoader的等级加载机制	158
6.3  如何加载class文件	161
6.3.1  加载字节码到内存	161
6.3.2  验证与解析	163
6.3.3  初始化Class对象	163
6.4  常见加载类错误分析	163
6.4.1  ClassNotFoundException	163
6.4.2  NoClassDefFoundError	164
6.4.3  UnsatisfiedLinkError	165
6.4.4  ClassCastException	166
6.4.5  ExceptionInInitializerError	167
6.5  常用的ClassLoader分析	168
6.6  如何实现自己的ClassLoader	172
6.6.1  加载自定义路径下的class文件	172
6.6.2  加载自定义格式的class文件	174
6.7  实现类的热部署	176
6.8  Java应不应该动态加载类	178
6.9  总结	179
第7章  JVM体系结构与工作方式	180
7.1  JVM体系结构	180
7.1.1  何谓JVM	180
7.1.2  JVM体系结构详解	183
7.2  JVM工作机制	185
7.2.1  机器如何执行代码	185
7.2.2  JVM为何选择基于栈的架构	186
7.2.3  执行引擎的架构设计	187
7.2.4  执行引擎的执行过程	188
7.2.5  JVM方法调用栈	193
7.3  总结	197
第8章  JVM内存管理	198
8.1  物理内存与虚拟内存	199
8.2  内核空间与用户空间	200
8.3  在Java中哪些组件需要使用内存	201
8.3.1  Java堆	201
8.3.2  线程	201
8.3.3  类和类加载器	202
8.3.4  NIO	202
8.3.5  JNI	203
8.4  JVM内存结构	203
8.4.1  PC寄存器	204
8.4.2  Java栈	204
8.4.3  堆	205
8.4.4  方法区	205
8.4.5  运行时常量池	206
8.4.6  本地方法栈	206
8.5  JVM内存分配策略	206
8.5.1  通常的内存分配策略	207
8.5.2  Java中的内存分配详解	207
8.6  JVM内存回收策略	212
8.6.1  静态内存分配和回收	212
8.6.2  动态内存分配和回收	213
8.6.3  如何检测垃圾	213
8.6.4  基于分代的垃圾收集算法	215
8.7  内存问题分析	224
8.7.1  GC日志分析	224
8.7.2  堆快照文件分析	227
8.7.3  JVM Crash日志分析	227
8.8  实例1	233
8.9  实例2	235
8.10  实例3	237
8.11  总结	242
第9章  Servlet工作原理解析	243
9.1  从Servlet容器说起	243
9.1.1  Servlet容器的启动过程	244
9.1.2  Web应用的初始化工作	247
9.2  创建Servlet实例	249
9.2.1  创建Servlet对象	250
9.2.2  初始化Servlet	250
9.3  Servlet体系结构	252
9.4  Servlet如何工作	255
9.5  Servlet中的Listener	257
9.6  Filter如何工作	259
9.7  Servlet中的url-pattern	261
9.8  总结	262
第10章  深入理解Session与Cookie	263
10.1  理解Cookie	264
10.1.1  Cookie属性项	264
10.1.2  Cookie如何工作	265
10.1.3  使用Cookie的限制	268
10.2  理解Session	269
10.2.1  Session与Cookie	269
10.2.2  Session如何工作	270
10.3  Cookie安全问题	273
10.4  分布式Session框架	274
10.4.1  存在哪些问题	274
10.4.2  可以解决哪些问题	275
10.4.3  总体实现思路	275
10.5  Cookie压缩	280
10.6  表单重复提交问题	282
10.7  多终端Session统一	283
10.8  总结	285
第11章  Tomcat的系统架构与设计模式	286
11.1  Tomcat总体设计	286
11.1.1  Tomcat总体结构	287
11.1.2  Connector组件	293
11.1.3  Servlet容器Container	298
11.1.4  Tomcat中的其他组件	309
11.2  Tomcat中的设计模式	309
11.2.1  门面设计模式	309
11.2.2  观察者设计模式	311
11.2.3  命令设计模式	313
11.2.4  责任链设计模式	314
11.3  总结	316
第12章  Jetty的工作原理解析	317
12.1  Jetty的基本架构	317
12.1.1  Jetty基本架构简介	317
12.1.2  Handler的体系结构	319
12.2  Jetty的启动过程	320
12.3  接受请求	321
12.3.1  基于HTTP工作	321
12.3.2  基于AJP工作	323
12.3.3  基于NIO方式工作	326
12.4  处理请求	327
12.5  与JBoss集成	330
12.6  与Tomcat的比较	331
12.6.1  架构比较	331
12.6.2  性能比较	332
12.6.3  特性比较	332
12.7  总结	333
第13章  Spring框架的设计理念与设计模式分析	334
13.1  Spring的骨骼架构	334
13.1.1  Spring的设计理念	335
13.1.2  核心组件如何协同工作	336
13.2  核心组件详解	337
13.2.1  Bean组件	337
13.2.2  Context组件	339
13.2.3  Core组件	340
13.2.4  Ioc容器如何工作	342
13.3  Spring中AOP的特性详解	352
13.3.1  动态代理的实现原理	352
13.3.2  Spring AOP如何实现	355
13.4  设计模式解析之代理模式	358
13.4.1  代理模式原理	358
13.4.2  Spring中代理模式的实现	358
13.5  设计模式解析之策略模式	361
13.5.1  策略模式原理	361
13.5.2  Spring中策略模式的实现	362
13.6  总结	362
第14章  Spring MVC的工作机制与设计模式	364
14.1  Spring MVC的总体设计	364
14.2  Control设计	369
14.2.1  HandlerMapping初始化	370
14.2.2  HandlerAdapter初始化	372
14.2.3  Control的调用逻辑	373
14.3  Model设计	374
14.4  View设计	375
14.5  框架设计的思考	377
14.5.1  为什么需要框架	377
14.5.2  需要什么样的框架	377
14.5.3  框架设计原则	378
14.5.4 “指航灯”	378
14.5.5  最基本的原则	378
14.6  设计模式解析之模板模式	379
14.6.1  模板模式的结构	379
14.6.2  Spring MVC中的模板模式示例	379
14.7  总结	380
第15章  深入分析iBatis框架之系统架构与映射原理	381
15.1  iBatis框架主要的类层次结构	381
15.2  iBatis框架的设计策略	382
15.3  iBatis框架的运行原理	384
15.4  示例	386
15.5  iBatis对SQL语句的解析	388
15.6  数据库字段映射到Java对象	389
15.7  示例运行的结果	391
15.8  设计模式解析之简单工厂模式	391
15.8.1  简单工厂模式的实现原理	391
15.8.2  iBatis中的简单工厂模式示例	392
15.9  设计模式解析之工厂模式	393
15.9.1  工厂模式的实现原理	393
15.9.2  iBatis中的工厂模式示例	394
15.10  总结	395
第16章  Velocity工作原理解析	397
16.1  Velocity总体架构	398
16.2  JJTree渲染过程解析	401
16.2.1  #set语法	405
16.2.2  Velocity的方法调用	406
16.2.3  #if、#elseif和#else语法	409
16.2.4  #foreach语法	410
16.2.5  #parse语法	412
16.3  事件处理机制	413
16.4  常用优化技巧	416
16.4.1  减少树的总节点数量	416
16.4.2  减少渲染耗时的节点数量	416
16.5  与JSP比较	417
16.5.1  JSP渲染机制	417
16.5.2  Velocity与JSP	423
16.6  设计模式解析之合成模式	423
16.6.1  合成模式的结构	423
16.6.2  Velocity中合成模式的实现	424
16.7  设计模式解析之解释器模式	425
16.7.1  解释器模式的结构	425
16.7.2  Velocity中解释器模式的实现	426
16.8  总结	426
第17章  Velocity优化实践	427
17.1  现实存在的问题	427
17.2  优化的理论基础	428
17.2.1  程序语言的三角形结构	428
17.2.2  数据结构减少抽象化	429
17.2.3  简单的程序复杂化	429
17.2.4  减少翻译的代价	430
17.2.5  变的转化为不变的	430
17.3  一个高效的模板引擎实现思路	430
17.3.1  vm模板如何被编译	432
17.3.2  方法调用的无反射优化	439
17.3.3  将字符输出改成字节输出	442
17.4  优化的成果	443
17.4.1  将char转成byte	443
17.4.2  无反射执行	444
17.5  其他优化手段	445
17.6  总结	445
第18章  大浏览量系统的静态化架构设计	446
18.1  淘宝大浏览量商品详情系统简介	446
18.2  系统面临哪些挑战	447
18.3  淘宝前台系统的优化历程	449
18.4  大浏览量系统的静态改造	449
18.4.1  什么是静态化系统	449
18.4.2  为什么要进行静态化架构设计	450
18.4.3  如何改造动态系统	451
18.4.4  几种静态化方案的设计及选择	453
18.4.5  如何解决失效问题	458
18.4.6  服务端静态化方案的演进：CDN化	459
18.5  总结	462
参考资料	463
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入分析Java Web技术内幕（修订版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构探险――从零开始写Java Web框架
第1章 从一个简单的Web应用 1
正所谓“工欲善其事，必先利其器”，在正式开始设计并开发我们的轻量级Java Web框架之前，有必要首先掌握以下技能：
使用IDEA搭建并开发Java项目；
使用Maven自动化构建Java项目；
使用Git管理项目源代码。
1.1 使用IDEA创建Maven项目 3
1.1.1 创建IDEA项目 3
1.1.2 调整Maven配置 3
1.2 搭建Web项目框架 5
1.2.1 转为Java Web项目 5
1.2.2 添加Java Web的Maven依赖 6
1.3 编写一个简单的Web应用 10
1.3.1 编写 Servlet类 10
1.3.2 编写JSP页面 11
1.4 让Web应用跑起来 12
1.4.1 在IDEA中配置Tomcat 12
1.4.2 使用Tomcat的Maven插件 13
1.4.3 以Debug方式运行程序 13
1.5 将代码放入Git仓库中 14
1.5.1 编写.gitignore文件 14
1.5.2 提交本地 Git 仓库 15
1.5.3 推送远程Git仓库 15
1.5.4 总结 16
第2章 为Web应用添加业务功能 17
我们将在这个应用的基础上增加一些业务功能，您将学会更多有关项目实战的技能，具体包括：
如何进行需求分析；
如何进行系统设计；
如何编写应用程序。
2.1 需求分析与系统设计 19
2.1.1 需求分析 19
2.1.2 系统设计 19
2.2 动手开发Web应用 21
2.2.1 创建数据库 22
2.2.2 准备开发环境 22
2.2.3 编写模型层 23
2.2.4 编写控制器层 25
2.2.5 编写服务层 27
2.2.6 编写单元测试 28
2.2.7 编写视图层 31
2.3 细节完善与代码优化 31
2.3.1 完善服务层 32
2.3.2 完善控制器层 59
2.3.3 完善视图层 60
2.4 总结 65
第3章 搭建轻量级Java Web框架 66
我们需要这样的框架，它足够轻量级、足够灵巧，不妨给它取一个优雅的名字——Smart Framework，本章我们就一起来实现这个框架。
您将通过本章的学习，掌握如下技能：
如何快速搭建开发框架；
如何加载并读取配置文件；
如何实现一个简单的IOC容器；
如何加载指定的类；
如何初始化框架。
3.1 确定目标 68
3.2 搭建开发环境 70
3.2.1 创建框架项目 70
3.2.2 创建示例项目 73
3.3 定义框架配置项 74
3.4 加载配置项 75
3.5 开发一个类加载器 78
3.6 实现Bean容器 87
3.7 实现依赖注入功能 90
3.8 加载Controller 93
3.9 初始化框架 97
3.10 请求转发器 98
3.11 总结 109
第4章 使框架具备AOP特性 110
在本章中，读者将学到大量有用的技术，具体包括：
如何理解并使用代理技术；
如何使用Spring提供的AOP技术；
如何使用动态代理技术实现AOP框架；
如何理解并使用ThreadLocal技术；
如何理解数据库事务管理机制；
如何使用AOP框架实现事务控制。
4.1 代理技术简介 112
4.1.1 什么是代理 112
4.1.2 JDK动态代理 114
4.1.3 CGlib动态代理 116
4.2 AOP技术简介 118
4.2.1 什么是AOP 118
4.2.2 写死代码 119
4.2.3 静态代理 120
4.2.4 JDK动态代理 121
4.2.5 CGLib动态代理 122
4.2.6 Spring AOP 124
4.2.7 Spring + AspectJ 136
4.3 开发AOP框架 142
4.3.1 定义切面注解 142
4.3.2 搭建代理框架 143
4.3.3 加载AOP框架 150
4.4 ThreadLocal简介 158
4.4.1 什么是ThreadLocal 158
4.4.2 自己实现ThreadLocal 161
4.4.3 ThreadLocal使用案例 163
4.5 事务管理简介 172
4.5.1 什么是事务 172
4.5.2 事务所面临的问题 173
4.5.3 Spring的事务传播行为 175
4.6 实现事务控制特性 178
4.6.1 定义事务注解 178
4.6.2 提供事务相关操作 181
4.6.3 编写事务代理切面类 182
4.6.4 在框架中添加事务代理机制 184
4.7 总结 185
第5章 框架优化与功能扩展 186
本章将对现有框架进行优化，并提供一些扩展功能。通过本章的学习，读者可以了解到：
如何优化Action参数；
如何实现文件上传功能；
如何与Servlet API完全解耦；
如何实现安全控制框架；
如何实现Web服务框架。
5.1 优化Action参数 188
5.1.1 明确Action参数优化目标 188
5.1.2 动手优化Action参数使用方式 188
5.2 提供文件上传特性 191
5.2.1 确定文件上传使用场景 191
5.2.2 实现文件上传功能 194
5.3 与Servlet API解耦 214
5.3.1 为何需要与Servlet API解耦 214
5.3.2 与Servlet API解耦的实现过程 215
5.4 安全控制框架——Shiro 219
5.4.1 什么是Shiro 219
5.4.2 Hello Shiro 220
5.4.3 在Web开发中使用Shiro 224
5.5 提供安全控制特性 230
5.5.1 为什么需要安全控制 230
5.5.2 如何使用安全控制框架 231
5.5.3 如何实现安全控制框架 242
5.6 Web服务框架——CXF 261
5.6.1 什么是CXF 261
5.6.2 使用CXF开发SOAP服务 262
5.6.3 基于SOAP的安全控制 278
5.6.4 使用CXF开发REST服务 291
5.7 提供Web服务特性 308
5.8 总结 329
附录A Maven快速入门 330
附录B 将构件发布到Maven中央仓库 342
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构探险――从零开始写Java Web框架
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言程序设计（基础篇 原书第10版）
出版者的话
中文版序
译者序
前言
第1章计算机、程序和Java概述1
1.1引言1
1.2什么是计算机2
1.2.1中央处理器2
1.2.2比特和字节3
1.2.3内存3
1.2.4存储设备4
1.2.5输入和输出设备4
1.2.6通信设备5
1.3编程语言6
1.3.1机器语言6
1.3.2汇编语言6
1.3.3高级语言7
1.4操作系统8
1.4.1控制和监视系统的活动8
1.4.2分配和调配系统资源8
1.4.3调度操作8
1.5Java、万维网以及其他9
1.6Java语言规范、API、JDK和IDE10
1.7一个简单的Java程序11
1.8创建、编译和执行Java程序13
1.9程序设计风格和文档16
1.9.1正确的注释和注释风格16
1.9.2正确的缩进和空白16
1.9.3块的风格17
1.10程序设计错误17
1.10.1语法错误17
1.10.2运行时错误18
1.10.3逻辑错误18
1.10.4常见错误19
1.11使用NetBeans开发Java程序20
1.11.1创建Java工程20
1.11.2创建Java类21
1.11.3编译和运行类22
1.12使用Eclipse开发Java程序22
1.12.1创建Java工程22
1.12.2创建Java类24
1.12.3编译和运行类24
关键术语25
本章小结25
测试题26
编程练习题26
第2章基本程序设计28
2.1引言28
2.2编写简单的程序28
2.3从控制台读取输入31
2.4标识符34
2.5变量34
2.6赋值语句和赋值表达式36
2.7命名常量37
2.8命名习惯37
2.9数值数据类型和操作38
2.9.1数值类型38
2.9.2从键盘读取数值39
2.9.3数值操作符39
2.9.4幂运算41
2.10数值型直接量41
2.10.1整型直接量42
2.10.2浮点型直接量42
2.10.3科学记数法42
2.11表达式求值以及操作符优先级43
2.12示例学习：显示当前时间44
2.13增强赋值操作符46
2.14自增和自减操作符47
2.15数值类型转换48
2.16软件开发过程50
2.17示例学习：整钱兑零54
2.18常见错误和陷阱56
关键术语58
本章小结58
测试题59
编程练习题59
第3章选择64
3.1引言64
3.2boolean数据类型64
3.3if语句66
3.4双分支if—else语句68
3.5嵌套的if语句和多分支if—else语句69
3.6常见错误和陷阱71
3.7产生随机数74
3.8示例学习：计算身体质量指数76
3.9示例学习：计算税率77
3.10逻辑操作符80
3.11示例学习：判定闰年83
3.12示例学习：彩票84
3.13switch语句85
3.14条件表达式88
3.15操作符的优先级和结合规则89
3.16调试90
关键术语91
本章小结91
测试题92
编程练习题92
第4章数学函数、字符和字符串100
4.1引言100
4.2常用数学函数101
4.2.1三角函数方法101
4.2.2指数函数方法102
4.2.3取整方法102
4.2.4min、max和abs方法102
4.2.5random方法103
4.2.6示例学习：计算三角形的角度103
4.3字符数据类型和操作105
4.3.1Unicode和ASCII码105
4.3.2特殊字符的转义序列106
4.3.3字符型数据与数值型数据之间的转换107
4.3.4字符的比较和测试107
4.4String类型109
4.4.1求字符串长度110
4.4.2从字符串中获取字符110
4.4.3连接字符串111
4.4.4字符串的转换111
4.4.5从控制台读取字符串112
4.4.6从控制台读取字符112
4.4.7字符串比较112
4.4.8获得子字符串114
4.4.9获取字符串中的字符或者子串115
4.4.10字符串和数字间的转换116
4.5示例学习117
4.5.1猜测生日118
4.5.2将十六进制数转换为十进制数121
4.5.3使用字符串修改彩票程序122
4.6格式化控制台输出123
关键术语126
本章小结127
测试题127
编程练习题127
第5章循环133
5.1引言133
5.2while循环134
5.2.1示例学习：猜数字136
5.2.2循环设计策略138
5.2.3示例学习：多个减法测试题138
5.2.4使用标记值控制循环140
5.2.5输入和输出重定向141
5.3do—while循环143
5.4for循环144
5.5采用哪种循环147
5.6嵌套循环149
5.7最小化数值错误151
5.8示例学习152
5.8.1求最大公约数152
5.8.2预测未来学费154
5.8.3将十进制数转换为
十六进制数155
5.9关键字break和continue156
5.10示例学习：判断回文串159
5.11示例学习：显示素数160
关键术语162
本章小结163
测试题163
编程练习题163
第6章方法171
6.1引言171
6.2定义方法172
6.3调用方法173
6.4void方法示例175
6.5通过传值进行参数传递178
6.6模块化代码181
6.7示例学习：将十六进制数转换为十进制数183
6.8重载方法185
6.9变量的作用域187
6.10示例学习：生成随机字符188
6.11方法抽象和逐步求精190
6.11.1自顶向下的设计191
6.11.2自顶向下和自底向上的实现192
6.11.3实现细节193
6.11.4逐步求精的优势196
关键术语196
本章小结197
测试题197
编程练习题197
第7章一维数组207
7.1引言207
7.2数组的基础知识207
7.2.1声明数组变量208
7.2.2创建数组208
7.2.3数组大小和默认值209
7.2.4访问数组元素209
7.2.5数组初始化语法210
7.2.6处理数组210
7.2.7foreach循环212
7.3示例学习：分析数字214
7.4示例学习：一副牌215
7.5数组的复制217
7.6将数组传递给方法218
7.7从方法中返回数组221
7.8示例学习：统计每个字母出现的次数221
7.9可变长参数列表224
7.10数组的查找225
7.10.1线性查找法225
7.10.2二分查找法226
7.11数组的排序228
7.12Arrays类230
7.13命令行参数232
7.13.1向main方法传递字符串232
7.13.2示例学习：计算器232
关键术语234
本章小结235
测试题235
编程练习题235
第8章多维数组242
8.1引言242
8.2二维数组的基础知识242
8.2.1声明二维数组变量并创建二维数组243
8.2.2获取二维数组的长度244
8.2.3锯齿数组244
8.3处理二维数组245
8.4将二维数组传递给方法247
8.5示例学习：多选题测验评分248
8.6示例学习：找出距离最近的点对249
8.7示例学习：数独251
8.8多维数组254
8.8.1示例学习：每日温度和湿度255
8.8.2示例学习：猜生日256
本章小结258
测试题258
编程练习题258
第9章对象和类270
9.1引言270
9.2为对象定义类270
9.3示例：定义类和创建对象272
9.4使用构造方法构造对象277
9.5通过引用变量访问对象278
9.5.1引用变量和引用类型278
9.5.2访问对象的数据和方法279
9.5.3引用数据域和null值279
9.5.4基本类型变量和引用类型变量的区别280
9.6使用Java库中的类282
9.6.1Date类282
9.6.2Random类283
9.6.3Point2D类283
9.7静态变量、常量和方法284
9.8可见性修饰符289
9.9数据域封装291
9.10向方法传递对象参数294
9.11对象数组297
9.12不可变对象和类299
9.13变量的作用域301
9.14this引用302
9.14.1使用this引用隐藏数据域302
9.14.2使用this调用构造方法303
关键术语304
本章小结304
测试题305
编程练习题305
第10章面向对象思考309
10.1引言309
10.2类的抽象和封装309
10.3面向对象的思考313
10.4类的关系315
10.4.1关联316
10.4.2聚集和组合317
10.5示例学习：设计Course类318
10.6示例学习：设计栈类320
10.7将基本数据类型值作为对象处理322
10.8基本类型和包装类类型之间的自动转换325
10.9BigInteger和BigDecimal类326
10.10String类327
10.10.1构造字符串327
10.10.2不可变字符串与限定字符串328
10.10.3字符串的替换和分隔329
10.10.4依照模式匹配、替换和分隔329
10.10.5字符串与数组之间的转换330
10.10.6将字符和数值转换成字符串331
10.10.7格式化字符串331
10.11StringBuilder和StringBuffer类333
10.11.1修改StringBuilder中的字符串334
10.11.2toString、capacity、length、setLength和charAt方法335
10.11.3示例学习：判断回文串时忽略既非字母又非数字的字符336
关键术语338
本章小结339
测试题339
编程练习题339
第11章继承和多态347
11.1引言347
11.2父类和子类347
11.3使用super关键字353
11.3.1调用父类的构造方法353
11.3.2构造方法链354
11.3.3调用父类的方法355
11.4方法重写356
11.5方法重写与重载357
11.6Object类及其toString（）方法359
11.7多态359
11.8动态绑定360
11.9对象转换和instanceof运算符363
11.10Object类的equals方法367
11.11ArrayList类368
11.12对于列表有用的方法374
11.13示例学习：自定义栈类374
11.14protected数据和方法376
11.15防止扩展和重写378
关键术语378
本章小结379
测试题379
编程练习题380
第12章异常处理和文本I/O384
12.1引言384
12.2异常处理概述385
12.3异常类型389
12.4关于异常处理的更多知识391
12.4.1声明异常392
12.4.2抛出异常392
12.4.3捕获异常393
12.4.4从异常中获取信息394
12.4.5示例学习：声明、抛出和捕获异常396
12.5finally子句399
12.6何时使用异常400
12.7重新抛出异常401
12.8链式异常402
12.9创建自定义异常类403
12.10File类405
12.11文件输入和输出408
12.11.1使用PrintWriter写数据408
12.11.2使用try—with—resources自动关闭资源409
12.11.3使用Scanner读数据410
12.11.4Scanner如何工作411
12.11.5示例学习：替换文本412
12.12从Web上读取数据414
12.13示例学习：Web爬虫416
关键术语418
本章小结418
测试题419
编程练习419
第13章抽象类和接口424
13.1引言424
13.2抽象类424
13.2.1为何要使用抽象方法427
13.2.2抽象类的几点说明428
13.3示例学习：抽象的Number类429
13.4示例学习：Calendar和GregorianCalendar431
13.5接口434
13.6Comparable接口436
13.7Cloneable接口440
13.8接口与抽象类444
13.9示例学习：Rational类447
13.10类的设计原则452
13.10.1内聚性452
13.10.2一致性452
13.10.3封装性452
13.10.4清晰性453
13.10.5完整性453
13.10.6实例和静态453
13.10.7继承与聚合454
13.10.8接口和抽象类454
关键术语454
本章小结455
测试题455
编程练习题455
第14章JavaFX基础459
14.1引言459
14.2JavaFX与Swing以及AWT的比较459
14.3JavaFX程序的基本结构460
14.4面板、UI组件以及形状462
14.5属性绑定465
14.6节点的通用属性和方法468
14.7Color类469
14.8Font类470
14.9Image和ImageView类472
14.10布局面板474
14.10.1FlowPane475
14.10.2GridPane477
14.10.3BorderPane478
14.10.4HBox和VBox480
14.11形状482
14.11.1Text482
14.11.2Line484
14.11.3Rectangle485
14.11.4Circle和Ellipse487
14.11.5Arc488
14.11.6Polygon和Polyline491
14.12示例学习：ClockPane类493
关键术语497
本章小结498
测试题498
编程练习题498
第15章事件驱动编程和动画504
15.1引言504
15.2事件和事件源506
15.3注册处理器和处理事件507
15.4内部类511
15.5匿名内部类处理器512
15.6使用lambda表达式简化事件处理514
15.7示例学习：贷款计算器517
15.8鼠标事件519
15.9键盘事件520
15.10可观察对象的监听器523
15.11动画525
15.11.1PathTransition525
15.11.2FadeTransition528
15.11.3Timeline530
15.12示例学习：弹球532
关键术语535
本章小结535
测试题536
编程练习题536
第16章JavaFXUI组件和多媒体542
16.1引言542
16.2Labeled和Label543
16.3按钮545
16.4复选框547
16.5单选按钮549
16.6文本域551
16.7文本区域553
16.8组合框556
16.9列表视图559
16.10滚动条562
16.11滑动条564
16.12示例学习：开发一个井字游戏567
16.13视频和音频572
16.14示例学习：国旗和国歌575
本章小结577
测试题578
编程练习题578
第17章二进制I/O584
17.1引言584
17.2在Java中如何处理文本I/O584
17.3文本I/O与二进制I/O585
17.4二进制I/O类587
17.4.1FileInputStream和FileOutputStream588
17.4.2FilterInputStream和FilterOutputStream590
17.4.3DataInputStream和DataOutputStream590
17.4.4BufferedInputStream和BufferedOutputStream594
17.5示例学习：复制文件596
17.6对象I/O598
17.6.1Serializable接口600
17.6.2序列化数组601
17.7随机访问文件602
关键术语606
本章小结606
测试题606
编程练习题606
第18章递归609
18.1引言609
18.2示例学习：计算阶乘610
18.3示例学习：计算斐波那契数613
18.4使用递归解决问题615
18.5递归辅助方法617
18.5.1递归选择排序618
18.5.2递归二分查找618
18.6示例学习：得到目录的大小619
18.7示例学习：汉诺塔621
18.8示例学习：分形624
18.9递归与迭代627
18.10尾递归628
关键术语629
本章小结629
测试题630
编程练习题630
附录AJava关键字637
附录BASCII字符集638
附录C操作符优先级表639
附录DJava修饰符640
附录E特殊浮点值641
附录F数系642
附录G位操作646
附录H正则表达式647
附录I枚举类型651
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言程序设计（基础篇 原书第10版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Effective Java中文版（第3版）
推荐序
译者序
前言
致谢
第1章　引言 1
第2章　创建和销毁对象 4
第1条：用静态工厂方法代替构造器 4
第2条：遇到多个构造器参数时要考虑使用构建器 8
第3条：用私有构造器或者枚举类型强化Singleton属性 13
第4条：通过私有构造器强化不可实例化的能力 15
第5条：优先考虑依赖注入来引用资源 16
第6条：避免创建不必要的对象 18
第7条：消除过期的对象引用 20
第8条：避免使用终结方法和清除方法 23
第9条：try-with-resources优先于try-finally 27
第3章　对于所有对象都通用的方法 30
第10条：覆盖equals时请遵守通用约定 30
第11条：覆盖equals时总要覆盖hashCode 40
第12条：始终要覆盖toString 44
第13条：谨慎地覆盖clone 46
第14条：考虑实现Comparable接口 53
第4章　类和接口 59
第15条：使类和成员的可访问性最小化 59
第16条：要在公有类而非公有域中使用访问方法 62
第17条：使可变性最小化 64
第18条：复合优先于继承 70
第19条：要么设计继承并提供文档说明，要么禁止继承 75
第20条：接口优于抽象类 79
第21条：为后代设计接口 83
第22条：接口只用于定义类型 85
第23条：类层次优于标签类 86
第24条：静态成员类优于非静态成员类 88
第25条：限制源文件为单个顶级类 91
第5章　泛型 93
第26条：请不要使用原生态类型 93
第27条：消除非受检的警告 97
第28条：列表优于数组 99
第29条：优先考虑泛型 102
第30条：优先考虑泛型方法 106
第31条：利用有限制通配符来提升API的灵活性 109
第32条：谨慎并用泛型和可变参数 114
第33条：优先考虑类型安全的异构容器 118
第6章　枚举和注解 123
第34条：用enum代替int常量 123
第35条：用实例域代替序数 131
第36条：用EnumSet代替位域 132
第37条：用EnumMap代替序数索引 134
第38条：用接口模拟可扩展的枚举 138
第39条：注解优先于命名模式 140
第40条：坚持使用Override注解 147
第41条：用标记接口定义类型 149
第7章　Lambda和Stream 151
第42条：Lambda优先于匿名类 151
第43条：方法引用优先于Lambda 154
第44条：坚持使用标准的函数接口 156
第45条：谨慎使用Stream 159
第46条：优先选择Stream中无副作用的函数 164
第47条：Stream要优先用Collection作为返回类型 168
第48条：谨慎使用Stream并行 172
第8章　方法 176
第49条：检查参数的有效性 176
第50条：必要时进行保护性拷贝 179
第51条：谨慎设计方法签名 182
第52条：慎用重载 184
第53条：慎用可变参数 189
第54条：返回零长度的数组或者集合，而不是null 190
第55条：谨慎返回optinal 192
第56条：为所有导出的API元素编写文档注释 196
第9章　通用编程 202
第57条：将局部变量的作用域最小化 202
第58条：for-each循环优先于传统的for循环 204
第59条：了解和使用类库 207
第60条：如果需要精确的答案，请避免使用float和double 209
第61条：基本类型优先于装箱基本类型 211
第62条：如果其他类型更适合，则尽量避免使用字符串 213
第63条：了解字符串连接的性能 215
第64条：通过接口引用对象 216
第65条：接口优先于反射机制 218
第66条：谨慎地使用本地方法 220
第67条：谨慎地进行优化 221
第68条：遵守普遍接受的命名惯例 223
第10章　异常 227
第69条：只针对异常的情况才使用异常 227
第70条：对可恢复的情况使用受检异常，对编程错误使用运行时异常 229
第71条：避免不必要地使用受检异常 231
第72条：优先使用标准的异常 232
第73条：抛出与抽象对应的异常 234
第74条：每个方法抛出的所有异常都要建立文档 235
第75条：在细节消息中包含失败-捕获信息 237
第76条：努力使失败保持原子性 238
第77条：不要忽略异常 239
第11章　并发 241
第78条：同步访问共享的可变数据 241
第79条：避免过度同步 245
第80条：executor、task和stream优先于线程 250
第81条：并发工具优先于wait和notify 251
第82条：线程安全性的文档化 256
第83条：慎用延迟初始化 258
第84条：不要依赖于线程调度器 261
第12章　序列化 263
第85条：其他方法优先于Java序列化 263
第86条：谨慎地实现Serializable接口 266
第87条：考虑使用自定义的序列化形式 269
第88条：保护性地编写readObject方法 274
第89条：对于实例控制，枚举类型优先于readResolve 279
第90条：考虑用序列化代理代替序列化实例 282
附录　与第2版中条目的对应关系 286
参考文献 289
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Effective Java中文版（第3版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java与模式
第一部分
第1章 模式的简史和形而上学
……
第二部分
第3章 软件的可维护性与可复用性
……
第三部分
第12章 简单工厂（Simple Factory）模式
……
第四部分
第22章 适配器（Adapter模式）
……
第五部分
第34章 不变（Immutable）模式
……
附录A 设计模式一览表
附录B UML图标及其Java实现一览表
附录C 中英术语对照表

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java与模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构与算法
第1章 java语言的面向对象编程 1
1.1 java入门 1
1.1.1 变量的声明 1
1.1.2 运算符 3
1.1.3 选择语句 3
1.1.4 循环语句 4
1.1.5 异常处理 5
1.2 java面向对象编程 6
1.2.1 封装 6
1.2.2 抽象数据类型 12
1.2.3 继承 13
1.2.4 多态性 16
1.3 输入和输出 19
1.3.1 输入、输出字节 21
1.3.2 行输入 21
1.3.3 标志输入：单词和数字 22
1.3.4 基本数据类型的输入和输出 22
1.3.5 对象的输入和输出 23
1.3.6 随机存取文件 24
1.4 java和指针 24
1.5 java.util中的向量 28
1.6 数据结构和面向对象的编程 32
1.7 示例学习：随机存取文件 32
1.8 习题 39
1.9 编程作业 41
参考文献 42
第2章 复杂性分析 44
2.1 计算复杂性和渐近复杂性 44
2.2 大o表示法 44
2.3 大o表示法的性质 46
2.4 w和q表示法 47
2.5 可能出现的问题 48
2.6 复杂性示例 48
2.7 寻找渐近复杂性：示例 49
2.8 最好的、平均的和最坏的情况 51
2.9 平摊复杂性 53
2.10 np完整性 56
2.11 习题 58
参考文献 60
第3章 链表 62
3.1 单向链表 62
3.1.1 插入 66
3.1.2 删除 67
3.1.3 查找 70
3.2 双向链表 72
3.3 循环链表 74
3.4 跳转表 75
3.5 自组织表 80
3.6 稀疏表 83
3.7 java.util的链表 85
3.7.1 linkedlist 85
3.7.2 arraylist 89
3.8 结论 91
3.9 示例学习：图书馆 92
3.10 习题 99
3.11 编程作业 101
参考文献 103
第4章 堆栈和队列 105
4.1 堆栈 105
4.2 队列 111
4.3 优先级队列 117
4.4 示例学习：脱离迷宫 118
4.5 习题 122
4.6 编程作业 124
参考文献 125
第5章 递归 126
5.1 递归定义 126
5.2 方法调用和递归实现 128
5.3 剖析递归调用 129
5.4 尾递归 132
5.5 非尾递归 133
5.6 间接递归 137
5.7 嵌套递归 139
5.8 过分递归 139
5.9 回溯 142
5.10 小结 147
5.11 示例学习：递归下降解 推?147
5.12 习题 153
5.13 编程作业 155
参考文献 157
第6章 二叉树 158
6.1 树、二叉树和二叉查找树 158
6.2 二叉树实现 161
6.3 搜索二叉查找树 163
6.4 树的遍历 164
6.4.1 广度优先遍历 165
6.4.2 深度优先遍历 165
6.4.3 无堆栈深度优先遍历 171
6.5 插入 175
6.6 删除 178
6.6.1 归并删除法 179
6.6.2 复制删除法 181
6.7 树的平衡 183
6.7.1 dsw算法 185
6.7.2 avl树 187
6.8 自调整树 191
6.8.1 自重构树 192
6.8.2 伸展树 192
6.9 堆 196
6.9.1 堆作为优先级队列 197
6.9.2 以堆的形式组织数组 199
6.10 波兰表示法和表达式树 202
6.11 示例学习：计算单词频率 206
6.12 习题 212
6.13 编程作业 214
参考文献 217
第7章 多分树 220
7.1 b树家族 220
7.1.1 b树 221
7.1.2 b*树 229
7.1.3 b+树 230
7.1.4 前缀b+树 232
7.1.5 比特树 233
7.1.6 r树 235
7.1.7 2-4树 236
7.1.8 java.util中的树 248
7.2 检索树 257
7.3 结论 264
7.4 示例学习：拼写检查程序 264
7.5 习题 273
7.6 编程作业 274
参考文献 277
第8章 图 279
8.1 图的表示法 280 ..
8.2 图的遍历 281
8.3 最短路径 284
8.4 圈检测 291
8.5 生成树 293
8.6 连通性 297
8.6.1 无向图的连通性 297
8.6.2 有向图的连通性 300
8.7 拓扑排序 302
8.8 网络 303
8.8.1 最大流 303
8.8.2 最小代价的最大流量 311
8.9 匹配 313
8.9.1 稳定匹配问题 318
8.9.2 分配问题 319
8.9.3 非二部图中的匹配 321
8.10 欧拉图和哈密顿图 322
8.10.1 欧拉图 322
8.10.2 哈密顿图 324
8.11 图的着色 329
8.12 图论中的np完整性问题 331
8.12.1 团问题 331
8.12.2 3色问题 332
8.12.3 顶点覆盖问题 333
8.12.4 哈密顿回路问题 333
8.13 示例学习：典型代表问题 335
8.14 习题 336
8.15 编程作业 345
参考文献 346
第9章 排序 349
9.1 基本排序算法 350
9.1.1 插入排序 350
9.1.2 选择排序 352
9.1.3 冒泡排序 353
9.2 决策树 355
9.3 高效排序算法 357
9.3.1 shell排序 357
9.3.2 堆排序 360
9.3.3 快速排序 363
9.3.4 归并排序 367
9.3.5 基数排序 370
9.4 java.util中的排序 373
9.5 总结 375
9.6 示例学习：多项式加法 376
9.7 习题 383
9.8 编程作业 384
参考文献 384
第10章 散列 387
10.1 散列函数 387
10.1.1 除法 387
10.1.2 折叠法 388
10.1.3 平方取 泻　?388
10.1.4 提取方法 388
10.1.5 基数变换 388
10.2 冲突解决 389
10.2.1 开放定址法 389
10.2.2 链 393
10.2.3 桶定址法 394
10.3 删除 394
10.4 完全散列函数 395
10.4.1 cichelli方法 396
10.4.2 fhcd算法 398
10.5 可扩展文件的散列函数 400
10.5.1 可扩展散列 400
10.5.2 线性散列 402
10.6 java.util中的散列 404
10.6.1 hashmap 404
10.6.2 hashset 407
10.6.3 hashtable 410
10.7 示例学习：桶散列 414
10.8 习题 421
10.9 编程作业 422
参考文献 423
第11章 数据压缩 425
11.1 数据压缩的条件 425
11.2 赫夫曼编码 426
11.3 顺串长度编码 436
11.4 ziv-lempel编码 437
11.5 示例学习：结合顺串长度编码的 赫夫曼方法 439
11.6 习题 448
11.7 编程作业 448
参考文献 449
第12章 存储管理 451
12.1 顺序适配方法 451
12.2 非顺序适配算法 452
12.3 无用单元收集 459
12.3.1 标记和清除算法 459
12.3.2 复制方法 465
12.3.3 增量式无用单元收集 466
12.4 总结 471
12.5 示例学习：内置无用单元收集器 472
12.6 习题 473
12.7 编程作业 479
参考文献 481
第13章 字符串匹配 484
13.1 精确字符串匹配 484
13.1.1 直接匹配算法 484
13.1.2 knuth-morris-pratt算法 486
13.1.3 boyer-moore算法 492
13.1.4 多路查找 500
13.1.5 面向位方法 501
13.1.6 词匹配集 504
13.1.7 正则表达式匹配 510
13.1.8 后缀检索树和树 513
13.1.9 后缀数组 517
13.2 近似字符串匹配 518
13.2.1 字符串相似度 519
13.2.2 k误配的字符串匹配 524
13.3 示例学习：最长公共子字符串 526
13.4 习题 533
13.5 编程作业 535
参考文献 535
附录a 大o的计算 537
a.1 谐波级数 537
a.2 函数lg (n!) 的近似 537
a.3 快速排序平均情况的大o 538
a.4 随机二叉树中的平均路径长度 540
a.5 avl树中的节点数量 541
附录b np完整性 542
索引 554
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构与算法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java核心技术（卷2）：高级特性（原书第9版）
译者序
前言
第1章　流与文件	1
1.1　流	1
1.1.1　读写字节	1
1.1.2　完整的流家族	3
1.1.3　组合流过滤器	7
1.2　文本输入与输出	10
1.2.1　如何写出文本输出	10
1.2.2　如何读入文本输入	13
1.2.3　以文本格式存储对象	13
1.2.4　字符集	16
1.3　读写二进制数据	20
1.4　ZIP文档	27
1.5　对象流与序列化	29
1.5.1　理解对象序列化的文件格式	34
1.5.2　修改默认的序列化机制	39
1.5.3　序列化单例和类型安全的枚举	40
1.5.4　版本管理	42
1.5.5　为克隆使用序列化	44
1.6　操作文件	46
1.6.1　Path	46
1.6.2　读写文件	48
1.6.3　复制、移动和删除文件	49
1.6.4　创建文件和目录	50
1.6.5　获取文件信息	51
1.6.6　迭代目录中的文件	53
1.6.7　ZIP文件系统	55
1.7　内存映射文件	56
1.7.1　缓冲区数据结构	62
1.7.2　文件加锁机制	64
1.8　正则表达式	66
第2章　XML	76
2.1　XML概述	76
2.2　解析XML文档	81
2.3　验证XML文档	91
2.3.1　文档类型定义	92
2.3.2　XML Schema	98
2.3.3　实用示例	101
2.4　使用XPath来定位信息	113
2.5　使用命名空间	119
2.6　流机制解析器	121
2.6.1　使用SAX解析器	122
2.6.2　使用StAX解析器	126
2.7　生成XML文档	129
2.7.1　不带命名空间的文档	130
2.7.2　带命名空间的文档	130
2.7.3　写出文档	131
2.7.4　示例：生成SVG文件	131
2.7.5　使用StAX写XML文档	133
2.8　XSL转换	140
第3章　网络	151
3.1　连接到服务器	151
3.1.1　套接字超时	155
3.1.2　因特网地址	156
3.2　实现服务器	157
3.2.1　为多个客户端服务	160
3.2.2　半关闭	163
3.3　可中断套接字	164
3.4　获取Web数	171
3.4.1　URL和URI	171
3.4.2　使用URLConnection获取信息	173
3.4.3　提交表单数据	181
3.5　发送E-mail	187
第4章　数据库编程	191
4.1　JDBC的设计	191
4.1.1　JDBC驱动程序类型	192
4.1.2　JDBC的典型用法	193
4.2　结构化查询语言	194
4.3　JDBC配置	198
4.3.1　数据库URL	199
4.3.2　驱动程序JAR文件	199
4.3.3　启动数据库	199
4.3.4　注册驱动器类	200
4.3.5　连接到数据库	201
4.4　执行SQL语句	203
4.4.1　管理连接、语句和结果集	206
4.4.2　分析SQL异常	207
4.4.3　组装数据库	209
4.5　执行查询操作	212
4.5.1　预备语句	212
4.5.2　读写LOB	218
4.5.3　SQL转义	219
4.5.4　多结果集	220
4.5.5　获取自动生成键	221
4.6　可滚动和可更新的结果集	222
4.6.1　可滚动的结果集	222
4.6.2　可更新的结果集	224
4.7　行集	228
4.7.1　构建行集	228
4.7.2　被缓存的行集	229
4.8　元数据	231
4.9　事务	240
4.9.1　保存点	241
4.9.2　批量更新	241
4.9.3　高级SQL类型	243
4.10　Web与企业应用中的连接管理	244
第5章　国际化	246
5.1　Locales 	246
5.2　数字格式	251
5.3　日期和时间	257
5.4　排序	264
5.4.1　排序强度	265
5.4.2　分解	265
5.5　消息格式化	270
选择格式	272
5.6　文本文件和字符集	273
源文件的字符编码	274
5.7　资源包	275
5.7.1　定位资源包	275
5.7.2　属性文件	276
5.7.3　包类	277
5.8　一个完整的例子	278
第6章　高级Swing	293
6.1　列表	293
6.1.1　JList构件	293
6.1.2　列表模式	298
6.1.3　插入和移除值	302
6.1.4　值的绘制	304
6.2　表格	307
6.2.1　简单表格	307
6.2.2　表格模型	310
6.2.3　对行和列的操作	314
6.2.4　单元格的绘制和编辑	328
6.3　树	338
6.3.1　简单的树	339
6.3.2　节点枚举	352
6.3.3　绘制节点	353
6.3.4　监听树事件	356
6.3.5　定制树模型	362
6.4　文本构件	370
6.4.1　文本构件中的修改跟踪	371
6.4.2　格式化的输入框	373
6.4.3　JSpinner构件	388
6.4.4　用JEditorPane显示HTML	395
6.5　进度指示器	401
6.5.1　进度条	401
6.5.2　进度监视器	404
6.5.3　监视输入流的进度	407
6.6　构件组织器和装饰器	411
6.6.1　分割面板	411
6.6.2　选项卡面板	414
6.6.3　桌面面板和内部框体	419
6.6.4　级联与平铺	422
6.6.5　否决属性设置	425
第7章　高级AWT	440
7.1　绘图操作流程	440
7.2　形状	442
7.3　区域	456
7.4　笔划	458
7.5　着色	465
7.6　坐标变换	466
7.7　剪切	471
7.8　透明与组合	473
7.9　绘图提示	481
7.10　图像的读取器和写入器	486
7.10.1　获得图像文件类型的读取器和写入器	487
7.10.2　读取和写入带有多个图像的文件	488
7.11　图像处理	496
7.11.1　构建光栅图像	496
7.11.2　图像过滤	502
7.12　打印	510
7.12.1　图形打印	510
7.12.2　打印多页文件	518
7.12.3　打印预览	520
7.12.4　打印服务程序	528
7.12.5　流打印服务程序	531
7.12.6　打印属性	532
7.13　剪贴板	538
7.13.1　用于数据传递的类和接口	539
7.13.2　传递文本	540
7.13.3　Transferable接口和数据风格	543
7.13.4　构建一个可传递的图像	545
7.13.5　通过系统剪贴板传递Java对象	548
7.13.6　使用本地剪贴板来传递对象引用	552
7.14　拖放操作	552
7.14.1　Swing对数据传递的支持	553
7.14.2　拖曳源	557
7.14.3　放置目标	559
7.15　平台集成	566
7.15.1　闪屏	566
7.15.2　启动桌面应用程序	571
7.15.3　系统托盘	576
第8章　JavaBean构件	581
8.1　为何使用Bean	581
8.2　编写Bean的过程	583
8.3　使用Bean构造应用程序	585
8.3.1　将Bean打包成JAR文件	585
8.3.2　在开发环境中组合Bean	586
8.4　Bean属性与事件的命名模式	591
8.5　Bean属性的类型	594
8.5.1　简单属性	594
8.5.2　索引属性	594
8.5.3　绑定属性	595
8.5.4　约束属性	596
8.6　BeanInfo类	603
8.7　属性编辑器	607
8.8　定制器	616
8.9　JavaBean持久化	624
8.9.1　JavaBean持久化可用于任何数据	628
8.9.2　一个JavaBean持久化的完整示例	633
第9章　安全	644
9.1　类加载器	645
9.1.1　类加载器的层次结构	646
9.1.2　将类加载器作为命名空间	647
9.1.3　编写你自己的类加载器	648
9.2　字节码校验	653
9.3　安全管理器与访问权限	657
9.3.1　Java平台安全性	658
9.3.2　安全策略文件	661
9.3.3　定制权限	667
9.3.4　实现权限类	669
9.4　用户认证	674
9.5　数字签名	687
9.5.1　消息摘要	688
9.5.2　消息签名	691
9.5.3　校验签名	693
9.5.4　认证问题	695
9.5.5　证书签名	697
9.5.6　证书请求	698
9.6　代码签名	699
9.6.1　JAR文件签名	699
9.6.2　软件开发者证书	702
9.7　加密	704
9.7.1　对称密码	705
9.7.2　密钥生成	706
9.7.3　密码流	710
9.7.4　公共密钥密码	711
第10章　脚本、编译与注解处理	716
10.1　Java平台的脚本	716
10.1.1　获取脚本引擎	716
10.1.2　脚本赋值与绑定	717
10.1.3　重定向输入和输出	719
10.1.4　调用脚本的函数和方法	720
10.1.5　编译脚本	722
10.1.6　一个示例：用脚本处理GUI事件	722
10.2　编译器API	727
10.2.1　编译便捷之法	727
10.2.2　使用编译工具	727
10.2.3　一个示例：动态Java代码生成	732
10.3　使用注解	737
10.4　注解语法	743
10.5　标准注解	746
10.5.1　用于编译的注解	747
10.5.2　用于管理资源的注解	748
10.5.3　元注解	748
10.6　源码级注解处理	750
10.7　字节码工程	756
第11章　分布式对象	765
11.1　客户与服务器的角色	765
11.2　远程方法调用	767
11.3　RMI编程模型	769
11.3.1　接口与实现	769
11.3.2　RMI注册表	770
11.3.3　部署程序	774
11.3.4　记录RMI活动的日志	776
11.4　远程方法中的参数和返回值	778
11.4.1　传递远程对象	778
11.4.2　传递非远程对象	779
11.4.3　动态类加载	781
11.4.4　具有多重接口的远程引用	785
11.4.5　远程对象与equals、hashCode和clone方法	786
11.5　远程对象激活	786
第12章　本地方法	792
12.1　从Java程序中调用C函数	793
12.2　数值参数与返回值	797
12.3　字符串参数	799
12.4　访问域	804
12.4.1　访问实例域	804
12.4.2　访问静态域	808
12.5　编码签名	809
12.6　调用Java方法	810
12.6.1　实例方法	810
12.6.2　静态方法	813
12.6.3　构造器	814
12.6.4　替代方法调用	815
12.7　访问数组元素	816
12.8　错误处理	820
12.9　使用调用API	824
12.10　完整的示例：访问Windows注册表	829
12.10.1　Windows注册表概述	829
12.10.2　访问注册表的Java平台接口	830
12.10.3　以本地方法方式实现注册表访问函数	830
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java核心技术（卷2）：高级特性（原书第9版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java编程思想(第2版)
出版者的话
专家指导委员会
读者回应
关于《Thinking in C++》
题献
译序
Java环境设定
序言
简介
第一章 对象导论
第二章 万事万物皆对象
第三章 控制程序流程
第四章 初始化与清理
第五章 隐藏实现细目
第六章 重复运用Classes
第七章 多态
第八章 接口与内隐类
……
附录A 对象的传递和返回
……
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java编程思想(第2版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件框架设计的艺术
第一部分 理论与理由
第1章 软件开发的艺术	4
1.1 理性主义，经验主义以及无绪	4
1.2 软件的演变过程	6
1.3 大型软件	8
1.4 漂亮，真理和优雅	9
1.5 更好的无绪	12
第2章 设计API的动力之源	14
2.1 分布式开发	14
2.2 模块化应用程序	16
2.3 交流互通才是一切	20
2.4 经验主义编程方式	22
2.5 开发第一个版本通常比较容易	24
第3章 评价API好坏的标准	26
3.1 方法和字段签名	26
3.2 文件及其内容	27
3.3 环境变量和命令行选项	29
3.4 文本信息也是API	30
3.5 协议	32
3.6 行为	35
3.7 国际化支持和信息国际化	35
3.8 API的广泛定义	37
3.9 如何检查API的质量	37
3.9.1 可理解性	37
3.9.2 一致性	38
3.9.3 可见性	39
3.9.4 简单的任务应该有简单的方案	40
3.9.5 保护投资	40
第4章 不断变化的目标	42
4.1 第一个版本远非完美	42
4.2 向后兼容	43
4.2.1 源代码兼容	43
4.2.2 二进制兼容	44
4.2.3 功能兼容——阿米巴变形虫效应	50
4.3 面向用例的重要性	52
4.4 API设计评审	55
4.5 一个API的生命周期	56
4.6 逐步改善	60
第二部分 设计实战
第5章 只公开你要公开的内容	67
5.1 方法优于字段	68
5.2 工厂方法优于构造函数	70
5.3 让所有内容都不可更改	71
5.4 避免滥用setter方法	72
5.5 尽可能通过友元的方式来公开功能	73
5.6 赋予对象创建者更多权利	77
5.7 避免暴露深层次继承	82
第6章 面向接口而非实现进行编程	85
6.1 移除方法或者字段	87
6.2 移除或者添加一个类或者接口	88
6.3 向现有的继承体系中添加一个接口或者类	88
6.4 添加方法或者字段	88
6.5 Java中接口和类的区别	90
6.6 弱点背后的优点	91
6.7 添加方法的另一种方案	92
6.8 抽象类有没有用呢	94
6.9 要为增加参数做好准备	95
6.10 接口VS.类	97
第7章 模块化架构	98
7.1 模块化设计的类型	100
7.2 组件定位和交互	103
7.3 编写扩展点	116
7.4 循环依赖的必要性	117
7.5 满城尽是Lookup	121
7.6 Lookup的滥用	126
第8章 设计API时要区分其目标用户群	129
8.1 C和Java语言中如何定义API和SPI	129
8.2 API演进不同于SPI演进	131
8.3	java.io.Writer这个类从JDK 1.4到JDK 5的演进	131
8.4 合理分解API	143
第9章 牢记可测试性	147
9.1 API设计和测试	148
9.2 规范的光环正在褪去	151
9.3 好工具让API设计更简单	153
9.4 兼容性测试套件	155
第10章 与其他API协作	158
10.1 谨慎使用第三方API	158
10.2 只暴露抽象内容	162
10.3 强化API的一致性	164
10.4 代理和组合	168
10.5 避免API的误用	176
10.6 不要滥用JavaBeans那种监听器机制	180
第11章 API具体运行时的一些内容	184
11.1 不要冒险	186
11.2 可靠性与无绪	189
11.3 同步和死锁	191
11.3.1 描述线程模型	192
11.3.2 Java Monitors中的陷阱	193
11.3.3 触发死锁的条件	196
11.3.4 测试死锁	201
11.3.5 对条件竞争进行测试	204
11.3.6 分析随机故障	206
11.3.7 日志的高级用途	208
11.3.8 使用日志记录程序控制流程	210
11.4 循环调用的问题	215
11.5 内存管理	218
第12章 声明式编程	223
12.1 让对象不可变	225
12.2 不可变的行为	229
12.3 文档兼容性	230
第三部分 日常生活
第13章 极端的意见有害无益	236
13.1 API必须是漂亮的	237
13.2 API必须是正确的	237
13.3 API应该尽量简单	240
13.4 API必须是高性能的	242
13.5 API必须绝对兼容	242
13.6 API必须是对称的	245
第14章 API设计中的矛盾之处	247
14.1 API设计中的自相矛盾	248
14.2 背后隐藏的工作	251
14.3 不要害怕发布一个稳定的API	252
14.4 降低维护费用	255
第15章 改进API	258
15.1 让有问题的类库重新焕发活力	259
15.2 自觉地升级与无意识地被迫升级	265
15.3 可选的行为	268
15.4 相似API的桥接和共存	274
第16章 团队协作	286
16.1 在提交代码时进行代码评审	286
16.2 说服开发人员为他们的API提供文档	290
16.3 尽职尽责的监控者	292
16.4 接受API的补丁	297
第17章 利用竞赛游戏来提升API设计技巧	300
17.1 概述	300
17.2 第一天	301
17.2.1 非public类带来的问题	304
17.2.2 不可变性带来的问题	304
17.2.3 遗漏实现的问题	308
17.2.4 返回结果可能不正确的问题	309
17.2.5 第一天的解决方案	310
17.3 第二天	313
17.3.1 我想修正犯下的错误	316
17.3.2 第二天的解决方案	317
17.4 第三天：评判日	320
17.5 也来玩下这个游戏吧	327
第18章 可扩展Visitor模式的案例	328
18.1 抽象类	331
18.2 为改进做好准备	333
18.3 默认的遍历	334
18.4 清楚地定义每个版本	337
18.5 单向改进	339
18.6 使用接口时的数据结构	340
18.7 针对用户和开发商的Visitor模式	341
18.8 三重调度	343
18.9 Visitor模式的圆满结局	345
18.10 语法小技巧	346
第19章 消亡的过程	348
19.1 明确版本的重要性	349
19.2 模块依赖的重要性	349
19.3 被移除的部分需要永久保留吗	352
19.4 分解庞大的API	352
第20章 未来	356
20.1 原则性内容	357
20.2 无绪长存	358
20.3 API设计方法论	360
20.4 编程语言的演变	361
20.5 教育的作用	363
20.6 共享	365
参考书目	366
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件框架设计的艺术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>自己动手写Java虚拟机
前言
第1章　命令行工具 1
1.1　准备工作 1
1.2　java命令 4
1.3　编写命令行工具 5
1.4　测试本章代码 7
1.5　本章小结 8
第2章　搜索class文件 9
2.1　类路径 9
2.2　准备工作 10
2.3　实现类路径 11
2.4　测试本章代码 20
2.5　本章小结 21
第3章　解析class文件 23
3.1　class文件 24
3.2　解析class文件 25
3.3　解析常量池 35
3.4　解析属性表 50
3.5　测试本章代码 61
3.6　本章小结 63
第4章　运行时数据区 65
4.1　运行时数据区概述 66
4.2　数据类型 67
4.3　实现运行时数据区 68
4.4　测试本章代码 81
4.5　本章小结 83
第5章　指令集和解释器 85
5.1　字节码和指令集 86
5.2　指令和指令解码 88
5.2.1　Instruction接口 89
5.2.2　BytecodeReader 91
5.3　常量指令 92
5.3.1　nop指令 92
5.3.2　const系列指令 93
5.3.3　bipush和sipush指令 94
5.4　加载指令 94
5.5　存储指令 95
5.6　栈指令 96
5.6.1　pop和pop2指令 96
5.6.2　dup指令 97
5.6.3　swap指令 98
5.7　数学指令 98
5.7.1　算术指令 98
5.7.2　位移指令 99
5.7.3　布尔运算指令 101
5.7.4　iinc指令 102
5.8　类型转换指令 102
5.9　比较指令 103
5.10　控制指令 108
5.11　扩展指令 111
5.12　解释器 114
5.13　测试本章代码 118
5.14　本章小结 120
第6章　类和对象 121
6.1　方法区 122
6.2　运行时常量池 127
6.3　类加载器 133
6.4　对象、实例变量和类变量 136
6.5　类和字段符号引用解析 141
6.6　类和对象相关指令 144
6.7　测试本章代码 156
6.8　本章小结 160
第7章　方法调用和返回 161
7.1　方法调用概述 161
7.2　解析方法符号引用 163
7.3　方法调用和参数传递 166
7.4　返回指令 169
7.5　方法调用指令 170
7.6　改进解释器 176
7.7　测试方法调用 178
7.8　类初始化 181
7.9　本章小结 185
第8章　数组和字符串 187
8.1　数组概述 187
8.2　数组实现 188
8.3　数组相关指令 191
8.4　测试数组 203
8.5　字符串 204
8.6　测试字符串 207
8.7　本章小结 210
第9章　本地方法调用 211
9.1　注册和查找本地方法 212
9.2　调用本地方法 213
9.3　反射 215
9.4　字符串拼接和String.intern()方法 225
9.5　Object.hashCode()、equals()和toString() 231
9.6　Object.clone() 233
9.7　自动装箱和拆箱 235
9.8　本章小结 238
第10章　异常处理 239
10.1　异常处理概述 239
10.2　异常抛出 240
10.3　异常处理表 241
10.4　实现athrow指令 245
10.5　Java虚拟机栈信息 248
10.6　测试本章代码 251
10.7　本章小结 252
第11章　结束 253
11.1　System类是如何被初始化的 253
11.2　初始化System类 255
11.3　System.out.println()是如何工作的 258
11.4　测试本章代码 260
11.5　总结 260
附录　指令表 263
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>自己动手写Java虚拟机
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 8函数式编程
前言　　IX
第1章　简介　　1
1.1　为什么需要再次修改Java　　1
1.2　什么是函数式编程　　2
1.3　示例　　2
第2章　Lambda 表达式　　5
2.1　第一个Lambda 表达式　　5
2.2　如何辨别Lambda 表达式　　6
2.3　引用值，而不是变量　　8
2.4　函数接口　　9
2.5　类型推断　　10
2.6　要点回顾　　12
2.7　练习　　12
第3章　流　　15
3.1　从外部迭代到内部迭代　　15
3.2　实现机制　　17
3.3　常用的流操作　　19
3.3.1　collect(toList())　　19
3.3.2　map　　19
3.3.3　filter　　21
3.3.4　flatMap　　22
3.3.5　max 和min　　23
3.3.6　通用模式　　24
3.3.7　reduce　　24
3.3.8　整合操作　　26
3.4　重构遗留代码　　27
3.5　多次调用流操作　　30
3.6　高阶函数　　31
3.7　正确使用Lambda 表达式　　31
3.8　要点回顾　　32
3.9　练习　　32
3.10　进阶练习　　33
第4章　类库　　35
4.1　在代码中使用Lambda 表达式　　35
4.2　基本类型　　36
4.3　重载解析　　38
4.4　@FunctionalInterface　　40
4.5　二进制接口的兼容性　　40
4.6　默认方法　　41
4.7　多重继承　　45
4.8　权衡　　46
4.9　接口的静态方法　　46
4.10　Optional　　47
4.11　要点回顾　　48
4.12　练习　　48
4.13　开放练习　　49
第5章　高级集合类和收集器　　51
5.1　方法引用　　51
5.2　元素顺序　　52
5.3　使用收集器　　54
5.3.1　转换成其他集合　　54
5.3.2　转换成值　　55
5.3.3　数据分块　　55
5.3.4　数据分组　　56
5.3.5　字符串　　57
5.3.6　组合收集器　　58
5.3.7　重构和定制收集器　　60
5.3.8　对收集器的归一化处理　　65
5.4　一些细节　　66
5.5　要点回顾　　67
5.6　练习　　67
第6章　数据并行化　　69
6.1　并行和并发　　69
6.2　为什么并行化如此重要　　70
6.3　并行化流操作　　71
6.4　模拟系统　　72
6.5　限制　　75
6.6　性能　　75
6.7　并行化数组操作　　78
6.8　要点回顾　　80
6.9　练习　　80
第7章　测试、调试和重构　　81
7.1　重构候选项　　81
7.1.1　进进出出、摇摇晃晃　　82
7.1.2　孤独的覆盖　　82
7.1.3　同样的东西写两遍　　83
7.2　Lambda 表达式的单元测试　　85
7.3　在测试替身时使用Lambda 表达式　　87
7.4　惰性求值和调试　　89
7.5　日志和打印消息　　89
7.6　解决方案：peak　　90
7.7　在流中间设置断点　　90
7.8　要点回顾　　90
第8章　设计和架构的原则　　91
8.1　Lambda 表达式改变了设计模式　　92
8.1.1　命令者模式　　92
8.1.2　策略模式　　95
8.1.3　观察者模式　　97
8.1.4　模板方法模式　　100
8.2　使用Lambda 表达式的领域专用语言　　102
8.2.1　使用Java 编写DSL　　103
8.2.2　实现　　104
8.2.3　评估　　106
8.3　使用Lambda 表达式的SOLID 原则　　106
8.3.1　单一功能原则　　107
8.3.2　开闭原则　　109
8.3.3　依赖反转原则　　 111
8.4　进阶阅读　　114
8.5　要点回顾　　114
第9章　使用Lambda 表达式编写并发程序　　115
9.1　为什么要使用非阻塞式I/O　　115
9.2　回调　　116
9.3　消息传递架构　　119
9.4　末日金字塔　　120
9.5　Future　　122
9.6　CompletableFuture　　123
9.7　响应式编程　　126
9.8　何时何地使用新技术　　128
9.9　要点回顾　　129
9.10　练习　　129
第10章　下一步该怎么办　　131
封面介绍　　133
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 8函数式编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序员修炼之道
目 录

第一部分　用Java 7做开发
第1章　初识Java 7　　2
1.1 　语言与平台　　2
1.2 　Coin项目：浓缩的都是精华　　4
1.3 　Coin项目中的修改　　7
1.3.1 　switch语句中的String　　7
1.3.2 　更强的数值文本表示法　　8
1.3.3 　改善后的异常处理　　9
1.3.4 　try-with-resources（TWR）　　11
1.3.5 　钻石语法　　13
1.3.6 　简化变参方法调用　　14
1.4 　小结　　15
第2章　新I/O　　17
2.1 　Java I/O简史　　18
2.1.1 　Java 1.0到1.3　　19
2.1.2 　在Java 1.4中引入的NIO　　19
2.1.3 　下一代I/O-NIO.2　　20
2.2 　文件I/O的基石：Path　　20
2.2.1 　创建一个Path　　23
2.2.2 　从Path中获取信息　　23
2.2.3 　移除冗余项　　24
2.2.4 　转换Path　　25
2.2.5 　NIO.2 Path和Java已有的File类　　25
2.3 　处理目录和目录树　　26
2.3.1 　在目录中查找文件　　26
2.3.2 　遍历目录树　　27
2.4 　NIO.2的文件系统I/O　　28
2.4.1 　创建和删除文件　　29
2.4.2 　文件的复制和移动　　30
2.4.3 　文件的属性　　31
2.4.4 　快速读写数据　　34
2.4.5 　文件修改通知　　35
2.4.6 　SeekableByteChannel　　37
2.5 　异步 I/O操作　　37
2.5.1 　将来式　　38
2.5.2 　回调式　　40
2.6 　Socket和Channel的整合　　41
2.6.1 　NetworkChannel　　42
2.6.2 　MulticastChannel　　42
2.7 　小结　　43
第二部分　关键技术
第3章　依赖注入　　46
3.1 　知识注入：理解IoC和DI　　46
3.1.1 　控制反转　　47
3.1.2 　依赖注入　　48
3.1.3 　转成DI　　49
3.2 　Java中标准化的DI　　53
3.2.1 　@Inject注解　　54
3.2.2 　@Qualifier注解　　55
3.2.3 　@Named注解　　57
3.2.4 　@Scope注解　　57
3.2.5 　@Singleton注解　　57
3.2.6 　接口Provider<T>　　58
3.3 　 Java中的DI参考实现：Guice 3　　59
3.3.1 　Guice新手指南　　59
3.3.2 　水手绳结：Guice的各种绑定　　62
3.3.3 　在Guice中限定注入对象的生命周期　　64
3.4 　小结　　66
第4章　现代并发　　67
4.1 　并发理论简介　　68
4.1.1 　解释Java线程模型　　68
4.1.2 　设计理念　　69
4.1.3 　这些原则如何以及为何会相互冲突　　70
4.1.4 　系统开销之源　　71
4.1.5 　一个事务处理的例子　　71
4.2 　块结构并发（Java 5之前）　　72
4.2.1 　同步与锁　　73
4.2.2 　线程的状态模型　　74
4.2.3 　完全同步对象　　74
4.2.4 　死锁　　76
4.2.5 　为什么是synchronized　　77
4.2.6 　关键字volatile　　78
4.2.7 　不可变性　　79
4.3 　现代并发应用程序的构件　　80
4.3.1 　原子类：java.util. concurrent.atomic　　81
4.3.2 　线程锁：java.util. concurrent.locks　　81
4.3.3 　CountDownLatch　　85
4.3.4 　ConcurrentHashMap　　86
4.3.5 　CopyOnWriteArrayList　　87
4.3.6 　Queue　　90
4.4 　控制执行　　95
4.4.1 　任务建模　　96
4.4.2 　ScheduledThread-PoolExecutor　　97
4.5 　分支/合并框架　　98
4.5.1 　一个简单的分支/合并例子　　99
4.5.2 　ForkJoinTask与工作窃取　　101
4.5.3 　并行问题　　102
4.6 　Java内存模型　　103
4.7 　小结　　104
第5章　类文件与字节码　　106
5.1 　类加载和类对象　　107
5.1.1 　加载和连接概览　　107
5.1.2 　验证　　108
5.1.3 　Class对象　　108
5.1.4 　类加载器　　109
5.1.5 　示例：依赖注入中的类加载器　　110
5.2 　使用方法句柄　　111
5.2.1 　MethodHandle　　112
5.2.2 　MethodType　　112
5.2.3 　查找方法句柄　　113
5.2.4 　示例：反射、代理与方法句柄　　114
5.2.5 　为什么选择MethodHandle　　116
5.3 　检查类文件　　117
5.3.1 　介绍javap　　117
5.3.2 　方法签名的内部形式　　118
5.3.3 　常量池　　119
5.4 　字节码　　121
5.4.1 　示例：反编译类　　121
5.4.2 　运行时环境　　123
5.4.3 　操作码介绍　　124
5.4.4 　加载和储存操作码　　125
5.4.5 　数学运算操作码　　125
5.4.6 　执行控制操作码　　126
5.4.7 　调用操作码　　126
5.4.8 　平台操作操作码　　127
5.4.9 　操作码的快捷形式　　127
5.4.10 　示例：字符串拼接　　127
5.5 　invokedynamic　　129
5.5.1 　invokedynamic如何工作　　129
5.5.2 　示例：反编译invokedynamic调用　　130
5.6 　小结　　132
第6章　理解性能调优　　133
6.1 　性能术语　　134
6.1.1 　等待时间　　135
6.1.2 　吞吐量　　135
6.1.3 　利用率　　135
6.1.4 　效率　　135
6.1.5 　容量　　136
6.1.6 　扩展性　　136
6.1.7 　退化　　136
6.2 　务实的性能分析法　　136
6.2.1 　知道你在测量什么　　137
6.2.2 　知道怎么测量　　137
6.2.3 　知道性能目标是什么　　138
6.2.4 　知道什么时候停止优化　　139
6.2.5 　知道高性能的成本　　139
6.2.6 　知道过早优化的危险　　140
6.3 　哪里出错了？我们担心的原因　　140
6.3.1 　过去和未来的性能趋势：摩尔定律　　141
6.3.2 　理解内存延迟层级　　142
6.3.3 　为什么Java性能调优存在困难　　143
6.4 　一个来自于硬件的时间问题　　144
6.4.1 　硬件时钟　　144
6.4.2 　麻烦的nanoTime()　　144
6.4.3 　时间在性能调优中的作用　　146
6.4.4 　案例研究：理解缓存未命中　　147
6.5 　垃圾收集　　149
6.5.1 　基本算法　　149
6.5.2 　标记和清除　　150
6.5.3 　jmap　　152
6.5.4 　与GC相关的JVM参数　　155
6.5.5 　读懂GC日志　　156
6.5.6 　用VisualVM查看内存使用情况　　157
6.5.7 　逸出分析　　159
6.5.8 　并发标记清除　　160
6.5.9 　新的收集器：G1　　161
6.6 　HotSpot的JIT编译　　162
6.6.1 　介绍HotSpot　　163
6.6.2 　内联方法　　164
6.6.3 　动态编译和独占调用　　165
6.6.4 　读懂编译日志　　166
6.7 　小结　　167
第三部分　JVM上的多语言编程
第7章　备选JVM语言　　170
7.1 　Java 太笨？纯粹诽谤　　170
7.1.1 　整合系统　　171
7.1.2 　函数式编程的基本原理　　172
7.1.3 　映射与过滤器　　173
7.2 　语言生态学　　174
7.2.1 　解释型与编译型语言　　175
7.2.2 　动态与静态类型　　175
7.2.3 　命令式与函数式语言　　176
7.2.4 　重新实现的语言与原生语言　　176
7.3 　JVM上的多语言编程　　177
7.3.1 　为什么要用非Java语言　　178
7.3.2 　崭露头角的语言新星　　179
7.4 　如何挑选称心的非Java语言　　180
7.4.1 　低风险　　181
7.4.2 　与Java的交互操作　　181
7.4.3 　良好的工具和测试支持　　182
7.4.4 　备选语言学习难度　　182
7.4.5 　使用备选语言的开发者　　182
7.5 　JVM对备选语言的支持　　183
7.5.1 　非Java语言的运行时环境　　183
7.5.2 　编译器小说　　184
7.6 　小结　　185
第8章　Groovy：Java的动态伴侣　　187
8.1 　Groovy入门　　189
8.1.1 　编译和运行　　189
8.1.2 　Groovy控制台　　190
8.2 　Groovy 101：语法和语义　　191
8.2.1 　默认导入　　192
8.2.2 　数字处理　　192
8.2.3 　变量、动态与静态类型、作用域　　193
8.2.4 　列表和映射语法　　195
8.3 　与Java的差异——新手陷阱　　196
8.3.1 　可选的分号和返回语句　　196
8.3.2 　可选的参数括号　　197
8.3.3 　访问限定符　　197
8.3.4 　异常处理　　198
8.3.5 　Groovy中的相等　　198
8.3.6 　内部类　　199
8.4 　Java不具备的Groovy特性　　199
8.4.1 　GroovyBean　　199
8.4.2 　安全解引用操作符　　200
8.4.3 　猫王操作符　　201
8.4.4 　增强型字符串　　201
8.4.5 　函数字面值　　202
8.4.6 　内置的集合操作　　203
8.4.7 　对正则表达式的内置支持　　204
8.4.8 　简单的XML处理　　205
8.5 　Groovy与Java的合作　　207
8.5.1 　从Groovy调用Java　　207
8.5.2 　从Java调用Groovy　　208
8.6 　小结　　211
第9章　Scala：简约而不简单　　212
9.1 　走马观花Scala　　213
9.1.1 　简约的Scala　　213
9.1.2 　match表达式　　215
9.1.3 　case类　　217
9.1.4 　actor　　218
9.2 　Scala能用在我的项目中吗　　219
9.2.1 　Scala和Java的比较　　219
9.2.2 　何时以及如何开始使用Scala　　220
9.2.3 　Scala可能不适合当前项目的迹象　　220
9.3 　让代码因Scala重新绽放　　221
9.3.1 　使用编译器和REPL　　221
9.3.2 　类型推断　　222
9.3.3 　方法　　223
9.3.4 　导入　　224
9.3.5 　循环和控制结构　　224
9.3.6 　Scala的函数式编程　　225
9.4 　Scala对象模型：相似但不同　　226
9.4.1 　一切皆对象　　226
9.4.2 　构造方法　　228
9.4.3 　特质　　228
9.4.4 　单例和伴生对象　　230
9.4.5 　case类和match表达式　　232
9.4.6 　警世寓言　　234
9.5 　数据结构和集合　　235
9.5.1 　List　　235
9.5.2 　Map　　238
9.5.3 　泛型　　239
9.6 　actor介绍　　242
9.6.1 　代码大舞台　　242
9.6.2 　用mailbox跟actor通信　　243
9.7 　小结　　244
第10章　Clojure：更安全地编程　　245
10.1 　Clojure介绍　　245
10.1.1 　Clojure的Hello World　　246
10.1.2 　REPL入门　　247
10.1.3 　犯了错误　　248
10.1.4 　学着去爱括号　　248
10.2 　寻找Clojure：语法和语义　　249
10.2.1 　特殊形式新手营　　249
10.2.2 　列表、向量、映射和集　　250
10.2.3 　数学运算、相等和其他操作　　252
10.3 　使用函数和循环　　253
10.3.1 　一些简单的Clojure函数　　253
10.3.2 　Clojure中的循环　　255
10.3.3 　读取器宏和派发器　　256
10.3.4 　函数式编程和闭包　　257
10.4 　Clojure序列　　258
10.4.1 　懒序列　　260
10.4.2 　序列和变参函数　　261
10.5 　Clojure与Java的互操作　　262
10.5.1 　从Clojure中调用Java　　262
10.5.2 　Clojure值的Java类型　　263
10.5.3 　使用Clojure代理　　264
10.5.4 　用REPL做探索式编程　　264
10.5.5 　在Java中使用Clojure　　265
10.6 　Clojure并发　　265
10.6.1 　未来式与并行调用　　266
10.6.2 　ref形式　　267
10.6.3 　代理　　271
10.7 　小结　　272
第四部分　多语种项目开发
第11章　测试驱动开发　　274
11.1 　TDD概览　　275
11.1.1 　一个测试用例　　276
11.1.2 　多个测试用例　　280
11.1.3 　深入思考红—绿—重构循环　　282
11.1.4 　JUnit　　283
11.2 　测试替身　　285
11.2.1 　虚设对象　　286
11.2.2 　存根对象　　287
11.2.3 　伪装替身　　290
11.2.4 　模拟对象　　295
11.3 　ScalaTest　　296
11.4 　小结　　298
第12章　构建和持续集成　　300
12.1 　与Maven 3相遇　　302
12.2 　Maven 3入门项目　　303
12.3 　用Maven 3构建Java7developer项目　　305
12.3.1 　POM　　305
12.3.2 　运行示例　　311
12.4 　Jenkins：满足CI需求　　314
12.4.1 　基础配置　　315
12.4.2 　设置任务　　316
12.4.3 　执行任务　　319
12.5 　Maven和Jenkins代码指标　　320
12.5.1 　安装Jenkins插件　　321
12.5.2 　用Checkstyle保持代码一致性　　322
12.5.3 　用FindBugs设定质量标杆　　323
12.6 　Leiningen　　325
12.6.1 　Leiningen入门　　326
12.6.2 　Leiningen的架构　　326
12.6.3 　Hello Lein　　327
12.6.4 　用Leiningen做面向REPL的TDD　　329
12.6.5 　用Leiningen打包和部署　　330
12.7 　小结　　332
第13章　快速Web开发　　333
13.1 　Java Web框架的问题　　334
13.1.1 　Java编译为什么不好　　335
13.1.2 　静态类型为什么不好　　335
13.2 　选择Web框架的标准　　336
13.3 　Grails入门　　338
13.4 　Grails快速启动项目　　338
13.4.1 　创建域对象　　340
13.4.2 　测试驱动开发　　340
13.4.3 　域对象持久化　　342
13.4.4 　创建测试数据　　343
13.4.5 　控制器　　343
13.4.6 　GSP/JSP页面　　344
13.4.7 　脚手架和UI的自动化创建　　346
13.4.8 　快速周转的开发　　347
13.5 　深入Grails　　347
13.5.1 　日志　　347
13.5.2 　GORM：对象关系映射　　348
13.5.3 　Grails插件　　349
13.6 　Compojure入门　　350
13.6.1 　Hello Compojure　　350
13.6.2 　Ring和路由　　352
13.6.3 　Hiccup　　353
13.7 　我是不是一只水獭　　353
13.7.1 　项目设置　　354
13.7.2 　核心函数　　357
13.8 　小结　　359
第14章　保持优秀　　361
14.1 　对Java 8的期待　　361
14.1.1 　lambda表达式（闭包）　　362
14.1.2 　模块化（拼图Jigsaw）　　363
14.2 　多语言编程　　365
14.2.1 　语言的互操作性及元对象协议　　365
14.2.2 　多语言模块化　　366
14.3 　未来的并发趋势　　367
14.3.1 　多核的世界　　367
14.3.2 　运行时管理的并发　　367
14.4 　JVM的新方向　　368
14.4.1 　VM的合并　　368
14.4.2 　协同程序　　369
14.4.3 　元组　　370
14.5 　小结　　372
附录A 　java7developer：源码安装　　373
附录B 　glob模式语法及示例　　380
附录C 　安装备选JVM语言　　382
附录D 　Jenkins的下载和安装　　388
附录E 　java7developer：Maven POM　　390

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序员修炼之道
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java核心技术·卷 II（原书第10版）
译者序
前言
第1章　Java SE 8的流库 1
1.1　从迭代到流的操作 1
1.2　流的创建 3
1.3　f?ilter、map和f?latMap方法 6
1.4　抽取子流和连接流 8
1.5　其他的流转换 8
1.6　简单约简 9
1.7　Optional类型 11
1.7.1　如何使用Optional值 11
1.7.2　不适合使用Optional值的方式 12
1.7.3　创建Optional值 13
1.7.4　用f?latMap来构建Optional值的函数 13
1.8　收集结果 15
1.9　收集到映射表中 19
1.10　群组和分区 23
1.11　下游收集器 24
1.12　约简操作 28
1.13　基本类型流 29
1.14　并行流 34
第2章　输入与输出 39
2.1　输入/输出流 39
2.1.1　读写字节 39
2.1.2　完整的流家族 42
2.1.3　组合输入/输出流过滤器 45
2.2　文本输入与输出 48
2.2.1　如何写出文本输出 49
2.2.2　如何读入文本输入 51
2.2.3　以文本格式存储对象 52
2.2.4　字符编码方式 55
2.3　读写二进制数据 57
2.3.1　DataInput和DataOutput接口 57
2.3.2　随机访问文件 59
2.3.3　ZIP文档 63
2.4　对象输入/输出流与序列化 66
2.4.1　保存和加载序列化对象 66
2.4.2　理解对象序列化的文件格式 70
2.4.3　修改默认的序列化机制 75
2.4.4　序列化单例和类型安全的枚举 77
2.4.5　版本管理 78
2.4.6　为克隆使用序列化 80
2.5　操作文件 83
2.5.1　Path 83
2.5.2　读写文件 85
2.5.3　创建文件和目录 87
2.5.4　复制、移动和删除文件 88
2.5.5　获取文件信息 89
2.5.6　访问目录中的项 91
2.5.7　使用目录流 92
2.5.8　ZIP文件系统 95
2.6　内存映射文件 96
2.6.1　内存映射文件的性能 96
2.6.2　缓冲区数据结构 103
2.6.3　文件加锁机制 105
2.7　正则表达式 106
第3章　XML 117
3.1　XML概述 117
3.1.1　XML文档的结构 119
3.2　解析XML文档 122
3.3　验证XML文档 132
3.3.1　文档类型定义 133
3.3.2　XML Schema 139
3.3.3　实用示例 142
3.4　使用XPath来定位信息 154
3.5　使用命名空间 159
3.6　流机制解析器 162
3.6.1　使用SAX解析器 162
3.6.2　使用StAX解析器 166
3.7　生成XML文档 170
3.7.1　不带命名空间的文档 170
3.7.2　带命名空间的文档 170
3.7.3　写出文档 171
3.7.4　示例：生成SVG文件 172
3.7.5　使用StAX写出XML文档 174
3.8　XSL转换 181
第4章　网络 191
4.1　连接到服务器 191
4.1.1　使用telnet 191
4.1.2　用Java连接到服务器 193
4.1.3　套接字超时 195
4.1.4　因特网地址 196
4.2　实现服务器 198
4.2.1　服务器套接字 198
4.2.2　为多个客户端服务 201
4.2.3　半关闭 204
4.3　可中断套接字 205
4.4　获取Web数 211
4.4.1　URL和URI 211
4.4.2　使用URLConnection获取信息 213
4.4.3　提交表单数据 220
4.5　发送E-mail 228
第5章　数据库编程 232
5.1　JDBC的设计 232
5.1.1　JDBC驱动程序类型 233
5.1.2　JDBC的典型用法 234
5.2　结构化查询语言 234
5.3　JDBC配置 239
5.3.1　数据库URL 240
5.3.2　驱动程序JAR文件 240
5.3.3　启动数据库 240
5.3.4　注册驱动器类 241
5.3.5　连接到数据库 242
5.4　使用JDBC语句 244
5.4.1　执行SQL语句 244
5.4.2　管理连接、语句和结果集 247
5.4.3　分析SQL异常 248
5.4.4　组装数据库 250
5.5　执行查询操作 254
5.5.1　预备语句 254
5.5.2　读写LOB 259
5.5.3　SQL转义 261
5.5.4　多结果集 262
5.5.5　获取自动生成的键 263
5.6　可滚动和可更新的结果集 263
5.6.1　可滚动的结果集 264
5.6.2　可更新的结果集 266
5.7　行集 269
5.7.1　构建行集 270
5.7.2　被缓存的行集 270
5.8　元数据 273
5.9　事务 282
5.9.1　用JDBC对事务编程 282
5.9.2　保存点 283
5.9.3　批量更新 283
5.10　高级SQL类型 285
5.11　Web与企业应用中的连接管理 286
第6章　日期和时间API 288
6.1　时间线 288
6.2　本地时间 291
6.3　日期调整器 294
6.4　本地时间 295
6.5　时区时间 296
6.6　格式化和解析 299
6.7　与遗留代码的互操作 302
第7章　国际化 304
7.1　Locale对象 304
7.2　数字格式 309
7.3　货币 314
7.4　日期和时间 315
7.5　排序和范化 321
7.6　消息格式化 327
7.6.1　格式化数字和日期 327
7.6.2　选择格式 329
7.7　文本文件和字符集 331
7.7.1　文本文件 331
7.7.2　行结束符 331
7.7.3　控制台 331
7.7.4　日志文件 332
7.7.5　UTF-8字节顺序标志 332
7.7.6　源文件的字符编码 333
7.8　资源包 333
7.8.1　定位资源包 334
7.8.2　属性文件 335
7.8.3　包类 335
7.9　一个完整的例子 337
第8章　脚本、编译与注解处理 352
8.1　Java平台的脚本 352
8.1.1　获取脚本引擎 352
8.1.2　脚本赋值与绑定 353
8.1.3　重定向输入和输出 355
8.1.4　调用脚本的函数和方法 356
8.1.5　编译脚本 357
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java核心技术·卷 II（原书第10版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java入门1•2•3
第1篇  Java语言基本语法第1章  让自己的第一个Java程序跑起来  教学视频：19分钟  1.1  想要用Java改变这个世界吗？    1.1.1  Java有什么优势？    1.1.2  Java在哪儿？  1.2  准备好开始Java之旅    1.2.1  下载JDK    1.2.2  安装JDK    1.2.3  配置环境变量    1.2.4  测试环境是否安装成功    1.2.5  如果失败了怎么办？  1.3  让自己的第一个程序运行起来    1.3.1  编写自己的Hello World源程序    1.3.2  编译自己的Hello World程序    1.3.3  让代码运行起来  1.4  初探：Hello World    1.4.1  类(Class)：Java世界中一类物体    1.4.2  方法(Method)：物体的功能    1.4.3  main()方法：所有Java程序执行的起点  1.5  名词解释    1.5.1  JDK和Java平台    1.5.2  Java编译器(Java Compiler)    1.5.3  Java类库(Java Class Librarics)    1.5.4  Java虚拟机(Java Virtual Machine)    1.5.5  HelloWorld的整个流程  1.6  小结：我们学会了编译和运行一个Java程序！  1.7  习题第2章  搭建自己的集成开发环境  教学视频：31分钟  2.1  安装集成开发环境    2.1.1  集成开发环境有哪些    2.1.2  安装Eclipse  2.2  Eclipse界面介绍    2.2.1  启动Eclipse    2.2.2  Eclipse的Perspective    2.2.3  Eclipse的菜单    2.2.4  Eclipse的工具条    2.2.5  Eclipse辅助视图区    2.2.6  Eclipse中Package Explorel    2.2.7  Eclipse中的源代码编辑器    2.2.8  Eclipse的设置窗口    2.2.9  Eclipse中的其他视图  2.3  如何使用Eclipse    2.3.1  在Eclipse中创建自己的第一个项目    2.3.2  在Eclipse中编写HelloWorld程序    2.3.3  通过Eclipse运行HelloWorld  2.4  小结：Eclipse——功能很强大  2.5  习题第3章  Java中的基本数据类型和运算符  教学视频：1小时5分钟  3.1  Java中的基本数据类型    3.1.1  基本数据类型——编程语言中的数据原子    3.1.2  Java中的基本上数据类型介绍    3.1.3  基本数据类型值域  3.2  Java运算符    3.2.1  变量的概念    3.2.2  插曲：Java中的语句    3.2.3  创建一个变量和变量名的规范    3.2.4  Java中的基本运算符和表达式    3.2.5  Java中的布尔运算符  3.3  基本数据类型运算的难点    3.3.1  强制类型转换——小数哪里去了    3.3.2  类型的转换在运算中悄悄进行    3.3.3  强制类型转换最优先    3.3.4  等号其实不简单    3.3.5  小心使用浮点数进行比较    3.3.6  boolean和char    3.3.7  不要使用还没有创建出来的变量    3.3.8  String——char串起的项链    3.3.9  转义符——看不见写得出  3.4  小结：基本数据类型——Java中一切数据和运算的基础  3.5  习题第4章  Java中的程序执行流程  教学视频：1小时57分钟  4.1  顺序执行  ……第5章  数组第2篇  Java语言高级语法第6章  Java的类(Class)和对象(Object)第7章  Java中的方法——给汽车丰富多彩的功能第8章  Java中的包(Package)命名习惯和注释第9章  再看数组、字符串和main()方法第10章  继承和多态第11章  修饰符(Qualifier)第12章  接口第13章  抽象类和内部类第14章  Java的异常处理机制第15章  多线程编程第3篇  Java语言编程进阶第16章  如何学习本篇第17章  编程常用知识第18章  Java文件编程和Java文件I/O第19章  Java Socket编程第20章  Java Swing编程第21章  编程，需要的是想象力和恒心第22章  JDBC入门
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java入门1•2•3
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java解惑
第1 章绪论　　　　1
第2 章表达式之谜　　　　5
谜题1：奇数性　　　　5
谜题2：找零时刻　　　　7
谜题3：长整除　　　　9
谜题4：初级问题　　　　11
谜题5：十六进制的趣事　　　　13
谜题6：多重转型　　　　15
谜题7：互换内容　　　　17
谜题8：Dos Equis 　　　　19
谜题9：半斤　　　　21
谜题10：八两　　　　23
第3 章字符之谜　　　　25
谜题11：最后的笑声　　　　25
谜题12：ABC 　　　　27
谜题13：动物庄园　　　　29
谜题14：转义字符的溃败　　31
谜题15：令人晕头转向的Hello 　　33
谜题16：行打印程序　　　　35
谜题17：嗯？ 　　　　37
谜题18：字符串奶酪　　　　39
谜题19：漂亮的火花（块注释符）　　41
谜题20：我的类是什么　　　　43
谜题21：我的类是什么？镜头2 　　45
谜题22：URL的愚弄　　　　47
谜题23：不劳无获　　　　49
第4 章循环之谜　　　　53
谜题24：尽情享受每一个字节　　53
谜题25：无情的增量操作　　55
谜题26：在循环中　　57
谜题27：变幻莫测的i值　　59
谜题28：循环者　　61
谜题29：循环者的新娘　　63
谜题30：循环者的爱子　　65
谜题31：循环者的鬼魂　　67
谜题32：循环者的诅咒　　69
谜题33：循环者遇到了狼人　　.71
谜题34：被计数击倒了　　73
谜题35：分钟计数器　　.75
第5 章异常之谜　　　　77
谜题36：优柔寡断　　77
谜题37：极端不可思议　　79
谜题38：不受欢迎的宾客　　81
谜题39：您好，再见　　.83
谜题40：不情愿的构造器　　85
谜题41：字段和流　　87
谜题42：异常为循环而抛　　89
谜题43：异常地危险　　93
谜题44：删除类　　97
谜题45：令人疲惫不堪的测验　　101
第6 章类之谜　　　　105
谜题46：令人混淆的构造器案例　　105
谜题47：啊呀！狸猫变犬子　　.107
谜题48：我所得到的都是静态的　　109
谜题49：比生命更大　　.111
谜题50：不是你的类型　　113
谜题51：要点何在　　115
谜题52：总和的玩笑　　.119
谜题53：做你的事吧　　.123
谜题54：Null与Void 　　.125
谜题55：特创论　　127
第7 章库之谜　　　　131
谜题56：大问题　　　　131
谜题57：名字里有什么　　　　133
谜题58：产生它的散列码　　137
谜题59：差是什么　　　　139
谜题60：一行以毙之　　　　141
谜题61：日期游戏　　　　143
谜题62：名字游戏　　　　145
谜题63：更多同样的问题　　147
谜题64：按余数编组　　　　149
谜题65：疑似排序的惊人传奇　　152
第8 章更多类之谜　　　　157
谜题66：一件私事　　　　157
谜题67：对字符串上瘾　　　　161
谜题68：灰色的阴影　　　　163
谜题69：黑色的渐隐　　　　165
谜题70：一揽子交易　　　　167
谜题71：进口税　　　　169
谜题72：终极危难　　　　171
谜题73：隐私在公开　　　　173
谜题74：同一性的危机　　　　175
谜题75：头还是尾？ 　　　　177
名字重用的术语表　　　　180
第9 章更多库之谜　　　　183
谜题76：乒乓　　　　183
谜题77：乱锁之妖　　　　185
谜题78：反射的影响　　　　189
谜题79：狗狗的幸福生活　　193
谜题80：更深层的反射　　　　195
谜题81：无法识别的字符化　　197
谜题82：啤酒爆炸　　　　199
谜题83：诵读困难者的一神论　　201
谜题84：戛然而止　　　　203
谜题85：延迟初始化　　205
第10 章高级谜题　　　　209
谜题86：有害的括号垃圾　　209
谜题87：紧张的关系　　211
谜题88：原始类型的处理　　213
谜题89：泛型迷药　　217
谜题90：荒谬痛苦的超类　　221
谜题91：序列杀手　　224
谜题92：双绞线　　229
谜题93：类的战争　　231
谜题94：迷失在混乱中　　233
谜题95：来份甜点　　237
附录A 陷阱和缺陷的目录　　239
A.1 词汇问题　　240
A.2 整数运算　　241
A.3 浮点运算　　243
A.4 表达式计算　　244
A.5 控制流　　　　245
A.6 类初始化　　246
A.7 实例的创建与销毁　　246
A.8 其他与类和实例相关的主题　　248
A.9 名字重用　　249
A.10 字符串　　　　251
A.11 I/O 　　　　252
A.12 线程　　　　253
A.13 反射　　　　255
A.14 序列化　　　　255
A.15 其他库　　　　257
附录B 书中幻图的注释　　259
参考文献　　　　265
索引　　　　271
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java解惑
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入分析Java Web技术内幕
第1章  深入Web请求过程	1
1.1  B/S网络架构概述	2
1.2  如何发起一个请求	4
1.3  HTTP协议解析	6
1.3.1  查看HTTP信息的工具	8
1.3.2  浏览器缓存机制	9
1.4  DNS域名解析	12
1.4.1  DNS域名解析过程	12
1.4.2  跟踪域名解析过程	15
1.4.3  清除缓存的域名	18
1.4.4  几种域名解析方式	19
1.5  CDN工作机制	20
1.5.1  CDN架构	20
1.5.2  负载均衡	21
1.6  总结	24
第2章  深入分析Java I/O的工作机制	25
2.1  Java的I/O类库的基本架构	25
2.1.1  基于字节的I/O操作接口	26
2.1.2  基于字符的I/O操作接口	27
2.1.3  字节与字符的转化接口	28
2.2  磁盘I/O工作机制	29
2.2.1  几种访问文件的方式	29
2.2.2  Java访问磁盘文件	33
2.2.3  Java序列化技术	34
2.3  网络I/O工作机制	36
2.3.1  TCP状态转化	37
2.3.2  影响网络传输的因素	39
2.3.3  Java Socket的工作机制	39
2.3.4  建立通信链路	40
2.3.5  数据传输	41
2.4  NIO的工作方式	41
2.4.1  BIO带来的挑战	41
2.4.2  NIO的工作机制	42
2.4.3  Buffer的工作方式	45
2.4.4  NIO的数据访问方式	47
2.5  I/O调优	49
2.5.1  磁盘I/O优化	49
2.5.2  TCP网络参数调优	50
2.5.3  网络I/O优化	52
2.6  设计模式解析之适配器模式	56
2.6.1  适配器模式的结构	56
2.6.2  Java I/O中的适配器模式	57
2.7  设计模式解析之装饰器模式	57
2.7.1  装饰器模式的结构	58
2.7.2  Java I/O中的装饰器模式	58
2.8  适配器模式与装饰器模式的区别	59
2.9  总结	59
第3章  深入分析Java Web中的中文编码问题	60
3.1  几种常见的编码格式	60
3.1.1  为什么要编码	60
3.1.2  如何“翻译”	61
3.2  Java中需要编码的场景	63
3.2.1  I/O操作中存在的编码	63
3.2.2  内存操作中的编码	65
3.3  Java中如何编解码	66
3.3.1  按照ISO-8859-1编码	68
3.3.2  按照GB2312编码	69
3.3.3  按照GBK编码	70
3.3.4  按照UTF-16编码	70
3.3.5  按照UTF-8编码	71
3.3.6  UTF-8编码代码片段	71
3.3.7  几种编码格式的比较	73
3.4  Java Web中涉及的编解码	73
3.4.1  URL的编解码	75
3.4.2  HTTP Header的编解码	78
3.4.3  POST表单的编解码	78
3.4.4  HTTP BODY的编解码	79
3.5  JS中的编码问题	80
3.5.1  外部引入JS文件	80
3.5.2  JS的URL编码	81
3.5.3  其他需要编码的地方	83
3.6  常见问题分析	83
3.6.1  中文变成了看不懂的字符	83
3.6.2  一个汉字变成一个问号	84
3.6.3  一个汉字变成两个问号	84
3.6.4  一种不正常的正确编码	85
3.7  总结	86
第4章  Javac编译原理	87
4.1  Javac是什么	88
4.2  Javac编译器的基本结构	88
4.3  Javac工作原理分析	90
4.3.1  词法分析器	91
4.3.2  语法分析器	98
4.3.3  语义分析器	103
4.3.4  代码生成器	113
4.4  设计模式解析之访问者模式	116
4.4.1  访问者模式的结构	117
4.4.2  Javac中访问者模式的实现	118
4.5  总结	119
第5章  深入class文件结构	120
5.1  JVM指令集简介	120
5.1.1  类相关的指令	122
5.1.2  方法的定义	123
5.1.3  属性的定义	124
5.1.4  其他指令集	125
5.2  class文件头的表示形式	133
5.3  常量池	137
5.3.1  UTF8常量类型	140
5.3.2  Fieldref、Methodref常量类型	141
5.3.3  Class常量类型	141
5.3.4  NameAndType常量类型	142
5.4  类信息	142
5.5  Fields和Methods定义	143
5.6  类属性描述	147
5.7  Javap生成的class文件结构	148
5.7.1  LineNumberTable	150
5.7.2  LocalVariableTable	151
5.8  总结	153
第6章  深入分析ClassLoader 工作机制	154
6.1  ClassLoader类结构分析	155
6.2  ClassLoader的等级加载机制	156
6.3  如何加载class文件	159
6.3.1  加载字节码到内存	159
6.3.2  验证与解析	161
6.3.3  初始化Class对象	161
6.4  常见加载类错误分析	161
6.4.1  ClassNotFoundException	161
6.4.2  NoClassDefFoundError	162
6.4.3  UnsatisfiedLinkError	163
6.4.4  ClassCastException	164
6.4.5  ExceptionInInitializerError	165
6.5  常用的ClassLoader分析	166
6.6  如何实现自己的ClassLoader	170
6.6.1  加载自定义路径下的class文件	170
6.6.2  加载自定义格式的class文件	172
6.7  实现类的热部署	174
6.8  Java应不应该动态加载类	176
6.9  总结	177
第7章  JVM体系结构与工作方式	178
7.1  JVM体系结构	178
7.1.1  何谓JVM	178
7.1.2  JVM体系结构详解	181
7.2  JVM工作机制	183
7.2.1  机器如何执行代码	183
7.2.2  JVM为何选择基于栈的架构	184
7.2.3  执行引擎的架构设计	185
7.2.4  执行引擎的执行过程	186
7.2.5  JVM方法调用栈	191
7.3  总结	195
第8章  JVM内存管理	196
8.1  物理内存与虚拟内存	197
8.2  内核空间与用户空间	198
8.3  Java中哪些组件需要使用内存	199
8.3.1  Java堆	199
8.3.2  线程	199
8.3.3  类和类加载器	200
8.3.4  NIO	200
8.3.5  JNI	201
8.4  JVM内存结构	201
8.4.1  PC寄存器	202
8.4.2  Java栈	202
8.4.3  堆	203
8.4.4  方法区	203
8.4.5  运行时常量池	204
8.4.6  本地方法栈	204
8.5  JVM内存分配策略	204
8.5.1  通常的内存分配策略	205
8.5.2  Java中内存分配详解	205
8.6  JVM内存回收策略	210
8.6.1  静态内存分配和回收	210
8.6.2  动态内存分配和回收	211
8.6.3  如何检测垃圾	211
8.6.4  基于分代的垃圾收集算法	213
8.7  内存问题分析	222
8.7.1  GC日志分析	222
8.7.2  堆快照文件分析	225
8.7.3  JVM Crash日志分析	225
8.8  实例1	231
8.9  实例2	233
8.10  实例3	235
8.11  总结	240
第9章  Servlet工作原理解析	241
9.1  从Servlet容器说起	241
9.1.1  Servlet容器的启动过程	242
9.1.2  Web应用的初始化工作	245
9.2  创建Servlet实例	247
9.2.1  创建Servlet对象	248
9.2.2  初始化Servlet	248
9.3  Servlet体系结构	250
9.4  Servlet如何工作	253
9.5  Servlet中的Listener	255
9.6  Filter如何工作	257
9.7  Servlet中的url-pattern	259
9.8  总结	260
第10章  深入理解Session与Cookie	261
10.1  理解Cookie	262
10.1.1  Cookie属性项	262
10.1.2  Cookie如何工作	263
10.1.3  使用Cookie的限制	266
10.2  理解Session	267
10.2.1  Session与Cookie	267
10.2.2  Session如何工作	268
10.3  Cookie安全问题	271
10.4  分布式Session框架	272
10.4.1  存在哪些问题	272
10.4.2  可以解决哪些问题	273
10.4.3  总体实现思路	273
10.5  Cookie压缩	278
10.6  表单重复提交问题	280
10.7  总结	281
第11章  Tomcat的系统架构与 设计模式	282
11.1  Tomcat总体设计	282
11.1.1  Tomcat总体结构	283
11.1.2  Connector组件	289
11.1.3  Servlet容器Container	294
11.1.4  Tomcat中的其他组件	305
11.2  Tomcat中的设计模式	305
11.2.1  门面设计模式	305
11.2.2  观察者设计模式	307
11.2.3  命令设计模式	309
11.2.4  责任链设计模式	310
11.3  总结	312
第12章  Jetty的工作原理解析	313
12.1  Jetty的基本架构	313
12.1.1  Jetty的基本架构简介	313
12.1.2  Handler的体系结构	315
12.2  Jetty的启动过程	316
12.3  接受请求	317
12.3.1  基于HTTP协议工作	317
12.3.2  基于AJP工作	319
12.3.3  基于NIO方式工作	322
12.4  处理请求	323
12.5  与Jboss集成	326
12.6  与Tomcat的比较	327
12.6.1  架构比较	327
12.6.2  性能比较	328
12.6.3  特性比较	328
12.7  总结	329
第13章  Spring框架的设计理念与 设计模式分析	330
13.1  Spring的骨骼架构	330
13.1.1  Spring的设计理念	331
13.1.2  核心组件如何协同工作	332
13.2  核心组件详解	333
13.2.1  Bean组件	333
13.2.2  Context组件	335
13.2.3  Core组件	336
13.2.4  Ioc容器如何工作	338
13.3  Spring中AOP特性详解	348
13.3.1  动态代理的实现原理	348
13.3.2  Spring AOP如何实现	351
13.4  设计模式解析之代理模式	354
13.4.1  代理模式原理	354
13.4.2  Spring中代理模式的实现	354
13.5  设计模式解析之策略模式	357
13.5.1  策略模式原理	357
13.5.2  Spring中策略模式的实现	358
13.6  总结	358
第14章  Spring MVC工作机制与 设计模式	360
14.1  Spring MVC的总体设计	360
14.2  Control设计	365
14.2.1  HandlerMapping初始化	366
14.2.2  HandlerAdapter初始化	368
14.2.3  Control的调用逻辑	369
14.3  Model设计	370
14.4  View设计	371
14.5  框架设计的思考	373
14.5.1  为什么需要框架	373
14.5.2  需要什么样的框架	373
14.5.3  框架设计的原则	374
14.5.4 “指航灯”	374
14.5.5  最基本的原则	374
14.6  设计模式解析之模板模式	375
14.6.1  模板模式的结构	375
14.6.2  Spring MVC中的模板模式示例	376
14.7  总结	377
第15章  深入分析Ibatis框架之系统 架构与映射原理	378
15.1  Ibatis框架主要的类层次结构	378
15.2  Ibatis框架的设计策略	379
15.3  Ibatis框架的运行原理	381
15.4  示例	383
15.5  Ibatis对SQL语句的解析	385
15.6  数据库字段映射到Java对象	386
15.7  示例运行的结果	388
15.8  设计模式解析之简单工厂模式	388
15.8.1  简单工厂模式的实现原理	388
15.8.2  Ibatis中的简单工厂模式示例	389
15.9  设计模式解析之工厂模式	390
15.9.1  工厂模式的实现原理	390
15.9.2  Ibatis中的工厂模式示例	391
15.10  总结	392
第16章  Velocity工作原理解析	394
16.1  Velocity总体架构	395
16.2  JJTree渲染过程解析	398
16.2.1  #set语法	402
16.2.2  Velocity的方法调用	403
16.2.3  #if、#elseif和#else语法	406
16.2.4  #foreach语法	407
16.2.5  #parse语法	409
16.3  事件处理机制	410
16.4  常用优化技巧	413
16.4.1  减少树的总节点数量	413
16.4.2  减少渲染耗时的节点数量	413
16.5  与JSP比较	414
16.5.1  JSP渲染机制	414
16.5.2  Velocity与JSP	420
16.6  设计模式解析之合成模式	420
16.6.1  合成模式的结构	420
16.6.2  Velocity中合成模式的实现	421
16.7  设计模式解析之解释器模式	422
16.7.1  解释器模式的结构	422
16.7.2  Velocity中解释器模式的实现	423
16.8  总结	423
第17章  Velocity优化实践	424
17.1  现实存在的问题	424
17.2  优化的理论基础	425
17.2.1  程序语言的三角形结构	425
17.2.2  数据结构减少抽象化	426
17.2.3  简单的程序复杂化	426
17.2.4  减少翻译的代价	427
17.2.5  变的转化为不变	427
17.3  一个高效的模板引擎的实现思路	427
17.3.1  vm模板如何被编译	429
17.3.2  方法调用的无反射优化	436
17.3.3  字符输出改成字节输出	439
17.4  优化的成果	440
17.4.1  char转成byte	440
17.4.2  无反射执行	441
17.5  其他优化手段	442
17.6  总结	442
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入分析Java Web技术内幕
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java虚拟机规范（Java SE 8版）
译者序
前　言
第1章　引言1
1.1　简史1
1.2　Java虚拟机2
1.3　各章节摘要2
1.4　说明3
1.5　反馈3
第2章　Java虚拟机结构4
2.1　class文件格式4
2.2　数据类型5
2.3　原始类型与值5
2.3.1　整数类型与整型值6
2.3.2　浮点类型、取值集合及浮点值6
2.3.3　returnAddress类型和值8
2.3.4　boolean类型8
2.4　引用类型与值9
2.5　运行时数据区9
2.5.1　pc寄存器9
2.5.2　Java虚拟机栈10
2.5.3　Java堆10
2.5.4　方法区11
2.5.5　运行时常量池11
2.5.6　本地方法栈12
2.6　栈帧12
2.6.1　局部变量表13
2.6.2　操作数栈14
2.6.3　动态链接14
2.6.4　方法调用正常完成15
2.6.5　方法调用异常完成15
2.7　对象的表示15
2.8　浮点算法15
2.8.1　Java虚拟机和IEEE 754中的浮点算法15
2.8.2　浮点模式16
2.8.3　数值集合转换17
2.9　特殊方法18
2.10　异常19
2.11　字节码指令集简介20
2.11.1　数据类型与Java虚拟机21
2.11.2　加载和存储指令23
2.11.3　算术指令24
2.11.4　类型转换指令25
2.11.5　对象的创建与操作27
2.11.6　操作数栈管理指令27
2.11.7　控制转移指令27
2.11.8　方法调用和返回指令28
2.11.9　抛出异常28
2.11.10　同步28
2.12　类库29
2.13　公有设计、私有实现30
第3章　Java虚拟机编译器31
3.1　示例的格式说明31
3.2　常量、局部变量和控制结构的使用32
3.3　算术运算36
3.4　访问运行时常量池36
3.5　与控制结构有关的更多示例37
3.6　接收参数40
3.7　方法调用41
3.8　使用类实例43
3.9　数组44
3.10　编译switch语句46
3.11　使用操作数栈48
3.12　抛出异常和处理异常48
3.13　编译finally语句块51
3.14　同步54
3.15　注解55
第4章　class文件格式56
4.1　ClassFile结构57
4.2　各种名称的内部表示形式61
4.2.1　类和接口的二进制名称61
4.2.2　非限定名61
4.3　描述符62
4.3.1　语法符号62
4.3.2　字段描述符62
4.3.3　方法描述符63
4.4　常量池64
4.4.1　CONSTANT_Class_info结构65
4.4.2　CONSTANT_Fieldref_info、CONSTANT_Methodref_info和CONSTANT_InterfaceMethodref_info结构66
4.4.3　CONSTANT_String_info结构67
4.4.4　CONSTANT_Integer_info和CONSTANT_Float_info结构67
4.4.5　CONSTANT_Long_info和CONSTANT_Double_info结构68
4.4.6　CONSTANT_NameAnd-Type_info结构69
4.4.7　CONSTANT_Utf8_info结构70
4.4.8　CONSTANT_MethodHandle_info结构72
4.4.9　CONSTANT_MethodType_info结构73
4.4.10　CONSTANT_Invoke-Dynamic_info结构74
4.5　字段74
4.6　方法76
4.7　属性78
4.7.1　自定义和命名新的属性82
4.7.2　ConstantValue属性82
4.7.3　Code属性83
4.7.4　StackMapTable属性86
4.7.5　Exceptions属性92
4.7.6　InnerClasses属性93
4.7.7　EnclosingMethod属性95
4.7.8　Synthetic属性96
4.7.9　Signature属性96
4.7.10　SourceFile属性100
4.7.11　SourceDebugExtension属性101
4.7.12　LineNumberTable属性102
4.7.13　LocalVariableTable属性103
4.7.14　LocalVariableTypeTable属性104
4.7.15　Deprecated属性106
4.7.16　RuntimeVisibleAnnota-tions属性106
4.7.17　RuntimeInvisible-Annotations属性110
4.7.18　RuntimeVisibleParameterAnnotations属性111
4.7.19　RuntimeInvisiblePara-meterAnnotations属性112
4.7.20　RuntimeVisibleTypeAnnotations属性114
4.7.21　RuntimeInvisibleType-Annotations属性124
4.7.22　AnnotationDefault属性125
4.7.23　BootstrapMethods属性126
4.7.24　MethodParameters属性127
4.8　格式检查129
4.9　Java虚拟机代码约束129
4.9.1　静态约束130
4.9.2　结构化约束132
4.10　class文件校验135
4.10.1　类型检查验证136
4.10.2　类型推导验证200
4.11　Java虚拟机限制206
第5章　加载、链接与初始化208
5.1　运行时常量池208
5.2　虚拟机启动210
5.3　创建和加载211
5.3.1　使用引导类加载器来加载类型212
5.3.2　使用用户自定义类加载器来加载类型212
5.3.3　创建数组类213
5.3.4　加载限制214
5.3.5　从class文件表示得到类214
5.4　链接215
5.4.1　验证216
5.4.2　准备216
5.4.3　解析217
5.4.4　访问控制225
5.4.5　方法覆盖225
5.5　初始化226
5.6　绑定本地方法实现228
5.7　Java虚拟机退出228
第6章　Java虚拟机指令集229
6.1　设定：“必须”的含义229
6.2　保留操作码229
6.3　虚拟机错误230
6.4　指令描述格式230
6.5　指令集描述232
第7章　操作码助记符320
附录A　Limited License Grant327
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java虚拟机规范（Java SE 8版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web高级编程
第Ⅰ部分 创建企业级应用程序
第1章 介绍Java EE平台 3
1.1 Java平台时间线 3
1.1.1 起始 3
1.1.2 企业级Java的诞生 4
1.1.3 Java SE和Java EE共同发展 5
1.1.4 了解最新的平台特性 7
1.1.5 持续发展 11
1.2 了解基本的Web应用程序结构 11
1.2.1 Servlet、过滤器、监听器和JSP 11
1.2.2 目录结构和WAR文件 12
1.2.3 部署描述符 13
1.2.4 类加载器架构 14
1.2.5 企业级应用程序归档文件 14
1.3 小结 15
第2章 使用Web容器 17
2.1 选择Web容器 17
2.1.1 Apache Tomcat 18
2.1.2 GlassFish 19
2.1.3 JBoss和WildFly 19
2.1.4 其他容器和应用服务器 20
2.1.5 本书使用Tomcat的原因 20
2.2 在个人计算机中安装Tomcat 21
2.2.1 将Tomcat安装为Windows服务 21
2.2.2 将Tomcat安装为命令行应用程序 21
2.2.3 配置自定义的JSP编译器 23
2.3 在Tomcat中部署和卸载应用程序 24
2.3.1 手动部署和卸载 24
2.3.2 使用Tomcat管理器 25
2.4 通过IDE调试Tomcat 26
2.4.1 使用IntelliJ IDEA 27
2.4.2 使用Eclipse 30
2.5 小结 34
第3章 创建第一个Servlet 35
3.1 创建Servlet类 36
3.1.1 选择要继承的Servlet类 36
3.1.2 使用初始化方法和销毁方法 38
3.2 配置可部署的Servlet 39
3.2.1 向描述符中添加Servlet 39
3.2.2 将Servlet映射到URL 40
3.2.3 运行和调试Servlet 42
3.3 了解doGet、doPost和其他方法 44
3.3.1 在service方法执行的过程中 44
3.3.2 使用HttpServletRequest 44
3.3.3 使用HttpServletResponse 47
3.4 使用参数和接受表单提交 49
3.5 使用初始化参数配置应用程序 53
3.5.1 使用上下文初始化参数 53
3.5.2 使用Servlet初始化参数 54
3.6 通过表单上传文件 56
3.6.1 介绍客户支持项目 56
3.6.2 配置Servlet支持文件上传 56
3.6.3 接受文件上传 59
3.7 编写多线程安全的应用程序 60
3.7.1 理解请求、线程和方法执行 60
3.7.2 保护共享资源 61
3.8 小结 62
第4章 使用JSP显示页面内容 63
4.1 使用
替代output.println("
") 64
4.1.1 使用JSP的原因 65
4.1.2 JSP在运行时的处理 66
4.2 创建第一个JSP 67
4.2.1 了解文件结构 67
4.2.2 指令、声明、脚本和表达式 69
4.2.3 注释代码 70
4.2.4 在JSP中导入类 71
4.2.5 使用指令 72
4.2.6 使用标签 75
4.3 在JSP中使用Java(以及不鼓励使用Java的原因) 76
4.3.1 使用JSP中隐式的变量 76
4.3.2 不应该在JSP中使用Java的原因 82
4.4 结合使用Servlet和JSP 82
4.4.1 配置部署描述符中的JSP属性 82
4.4.2 将Servlet中的请求转发给JSP 85
4.5 关于JSP文档(JSPX)的注意事项 89
4.6 小结 91
第5章 使用会话维持状态 93
5.1 需要会话的原因 93
5.1.1 维持状态 94
5.1.2 记住用户 94
5.1.3 启动应用程序工作流 94
5.2 使用会话cookie和URL重写 95
5.2.1 了解会话cookie 96
5.2.2 URL中的会话ID 98
5.2.3 会话的漏洞 100
5.3 在会话中存储数据 102
5.3.1 在部署描述符中配置会话 103
5.3.2 存储和获取数据 105
5.3.3 删除数据 109
5.3.4 在会话中存储更复杂的数据 111
5.4 使用会话 114
5.4.1 为客户支持应用程序添加登录功能 114
5.4.2 使用监听器检测会话的变化 118
5.4.3 维护活跃会话列表 120
5.5 将使用会话的应用程序群集化 124
5.5.1 在群集中使用会话ID 124
5.5.2 了解会话复制和故障恢复 126
5.6 小结 127
第6章 在JSP中使用表达式语言 129
6.1 了解表达式语言 129
6.1.1 表达式语言的用途 130
6.1.2 了解基本语法 130
6.1.3 添加EL表达式 132
6.2 使用EL语法 133
6.2.1 保留关键字 133
6.2.2 操作符优先级 134
6.2.3 对象属性和方法 139
6.2.4 EL函数 140
6.2.5 静态字段和方法访问 141
6.2.6 枚举 142
6.2.7 lambda表达式 142
6.2.8 集合 143
6.3 在EL表达式中使用作用域变量 144
6.3.1 使用隐式的EL作用域 145
6.3.2 使用隐式的EL变量 148
6.4 使用流API访问集合 151
6.4.1 了解中间操作 151
6.4.2 使用终结操作 153
6.4.3 使用流API 154
6.5 使用表达式语言替换Java代码 155
6.6 小结 157
第7章 使用Java标准标签库 159
7.1 JSP标签和JSTL简介 159
7.2 使用核心标签库(C命名空间) 163
7.2.1 163
7.2.2 164
7.2.3 165
7.2.4 、和 166
7.2.5 167
7.2.6 168
7.2.7 168
7.2.8 169
7.2.9 和 170
7.2.10 使用核心库标签 170
7.3 使用国际化和格式化标签库(FMT命名空间) 173
7.3.1 国际化和本地化组件 173
7.3.2 175
7.3.3 176
7.3.4 和 176
7.3.5 177
7.3.6 和 177
7.3.7 和 178
7.3.8 和 179
7.3.9 使用i18n和格式化库标签 180
7.4 使用数据库访问标签库(SQL命名空间) 182
7.5 使用XML处理标签库(X命名空间) 184
7.6 使用JSP标签替换Java代码 184
7.7 小结 186
第8章 编写自定义标签和函数库 189
8.1 了解TLD、标签文件和标签处理器 189
8.1.1 读取Java标准标签库TLD 190
8.1.2 比较JSP指令和标签文件指令 196
8.2 创建标签文件用作HTML模板 198
8.3 创建日期格式化标签处理器 199
8.4 创建EL函数简写字符串 203
8.5 使用自定义JSP标签替换Java代码 204
8.6 小结 210
第9章 使用过滤器改进应用程序 211
9.1 了解过滤器的目的 211
9.1.1 日志过滤器 212
9.1.2 验证过滤器 212
9.1.3 压缩和加密过滤器 212
9.1.4 错误处理过滤器 212
9.2 创建、声明和映射过滤器 213
9.2.1 了解过滤器链 213
9.2.2 映射到URL模式和Servlet名称 213
9.2.3 映射到不同的请求派发器类型 214
9.2.4 使用部署描述符 214
9.2.5 使用注解 215
9.2.6 使用编程式配置 215
9.3 过滤器排序 216
9.3.1 URL模式映射和Servlet名称映射 217
9.3.2 演示过滤器顺序 218
9.3.3 使用过滤器处理异步请求 220
9.4 调查过滤器的实际用例 224
9.4.1 添加简单的日志过滤器 225
9.4.2 使用过滤器压缩响应内容 226
9.5 使用过滤器简化认证 230
9.6 小结 231
第10章 在应用程序中使用WebSocket进行交互 233
10.1 演变：从AJAX到WEBSOCKET 234
10.1.1 问题：从服务器获得新数据到浏览器 234
10.1.2 解决方案1：频繁轮询 235
10.1.3 解决方案2：长轮询 236
10.1.4 解决方案3：分块编码 237
10.1.5 解决方案4：Applet和Adobe Flash 238
10.1.6 WebSocket：一种无人知道但已经存在的解决方案 239
10.2 了解WebSocket API 242
10.2.1 HTML5(JavaScript)客户端API 243
10.2.2 Java WebSocket API 245
10.3 使用WebSocket创建多人游戏 247
10.3.1 实现基本的三连棋游戏策略 247
10.3.2 创建服务器终端 248
10.3.3 编写JavaScript游戏控制台 252
10.3.4 WebSocket三连棋游戏试玩 256
10.4 在群集中使用WebSocket进行通信 257
10.4.1 使用两个Servlet实例模拟简单的群集 257
10.4.2 发送和接收二进制消息 259
10.4.3 测试模拟群集应用程序 261
10.5 在客户支持应用程序中添加"支持与客户聊天"功能 262
10.5.1 使用编码器和解码器转换消息 262
10.5.2 创建聊天服务器终端 264
10.5.3 编写JavaScript聊天应用程序 267
10.6 小结 269
第11章 使用日志监控应用程序 271
11.1 了解日志的概念 272
11.1.1 记录日志的原因 272
11.1.2 在日志中记录的内容 273
11.1.3 日志的写入方式 274
11.2 使用日志级别和分类 276
11.2.1 使用不同日志级别的原因 276
11.2.2 定义的日志级别 276
11.2.3 日志分类的工作方式 277
11.2.4 筛选的工作方式 277
11.3 选择日志框架 277
11.3.1 API和实现 278
11.3.2 性能 278
11.3.3 Apache Commons Logging和SLF4J 279
11.3.4 Log4j 2简介 280
11.4 在应用程序中集成日志 283
11.4.1 创建Log4j 2配置文件 284
11.4.2 在Web过滤器中使用鱼标签 287
11.4.3 在Java代码中编写日志语句 288
11.4.4 在JSP中使用日志标签库 290
11.4.5 客户支持应用程序中的日志 290
11.5 小结 291
第Ⅱ部分 添加Spring Framework
第12章 介绍Spring Framework 295
12.1 Spring Framework简介 296
12.1.1 反转控制和依赖注入 296
12.1.2 面向切面编程 297
12.1.3 数据访问和事务管理 297
12.1.4 应用程序消息 297
12.1.5 Web应用程序的模型-视图-控制器模式 298
12.2 使用Spring Framework的原因 298
12.2.1 逻辑代码分组 298
12.2.2 使用同一代码库的多个用户界面 298
12.3 了解应用上下文 299
12.4 启动Spring Framework 300
12.4.1 使用部署描述符启动Spring 301
12.4.2 在初始化器中使用编程的方式启动Spring 303
12.5 配置Spring Framework 306
12.5.1 创建XML配置 308
12.5.2 创建混合配置 310
12.5.3 使用@Configuration配置Spring 314
12.6 使用bean definition profile 318
12.6.1 了解profile的工作原理 319
12.6.2 考虑反模式和安全问题 321
12.7 小结 322
第13章 使用控制器替代Servlet 323
13.1 了解@RequestMapping 323
13.1.1 使用@RequestMapping特性
缩小请求匹配的范围 324
13.1.2 指定控制器方法参数 328
13.1.3 为控制器方法选择有效的返回类型 335
13.2 使用Spring Framework的模型和视图模式 337
13.2.1 使用显式的视图和视图名称 338
13.2.2 使用含有模型特性的隐式视图 340
13.2.3 返回响应实体 341
13.3 使用表单对象简化开发 346
13.3.1 在模型中添加表单对象 347
13.3.2 使用Spring Framework 标签 347
13.3.3 获得被提交的表单数据 349
13.4 更新客户支持应用程序 350
13.4.1 启用Multipart支持 350
13.4.2 将Servlet转换成Spring MVC控制器 351
13.4.3 创建自定义下载视图 352
13.5 小结 353
第14章 使用服务和仓库支持控制器 355
14.1 了解模型-视图-控制器模式与控制器-服务-仓库模式 355
14.1.1 识别程序逻辑的不同类型 356
14.1.2 使用仓库提供持久化逻辑 357
14.1.3 使用服务提供业务逻辑 357
14.1.4 使用控制器提供用户界面逻辑 358
14.2 使用根应用上下文替代Web应用上下文 359
14.2.1 在多用户界面中重用根应用上下文 359
14.2.2 将业务逻辑从控制器移动到服务 360
14.2.3 使用仓库存储数据 364
14.3 使用异步和计划执行改进服务 368
14.3.1 了解执行器和调度器 369
14.3.2 配置调度器和异步支持 369
14.3.3 创建和使用@Async方法 371
14.3.4 创建和使用@Scheduled方法 372
14.4 使用WebSocket实现逻辑层分离 373
14.4.1 在Spring应用上下文中添加由容器管理的对象 373
14.4.2 使用Spring WebSocket配置器 375
14.4.3 记住：WebSocket只是业务逻辑的另一个界面 376
14.5 小结 380
第15章 使用Spring Framework i18n国际化应用程序 381
15.1 使用Spring Framework i18n的原因 381
15.1.1 使国际化变得更容易 382
15.1.2 直接本地化错误消息 382
15.2 使用基本的国际化和本地化API 382
15.2.1 了解资源包和消息格式 383
15.2.2 使用消息源进行挽救 385
15.2.3 使用消息源国际化JSP 386
15.3 在Spring Framework中配置国际化 387
15.3.1 创建消息源 387
15.3.2 了解区域设置解析器 388
15.3.3 使用处理拦截器修改区域设置 390
15.3.4 提供一个用户Profile区域设置 390
15.3.5 包含时区支持 391
15.3.6 了解主题如何改进国际化 392
15.4 国际化代码 392
15.4.1 使用标签 393
15.4.2 以更干净的方式处理应用程序错误 395
15.4.3 更新客户支持应用程序 398
15.4.4 直接使用消息源 399
15.5 小结 402
第16章 使用JSR 349、Spring Framework和Hibernate Validator执行Bean验证 403
16.1 Bean验证的概念 404
16.1.1 使用Hibernate Validator的原因 405
16.1.2 了解注解元数据模型 406
16.1.3 使用Spring Framework实现Bean验证 406
16.2 在Spring Framework容器中配置验证 406
16.2.1 配置Spring验证Bean 407
16.2.2 创建错误代码本地化 409
16.2.3 使用方法验证Bean后处理器 410
16.2.4 在Spring MVC中使用相同的验证Bean 411
16.3 在Bean中添加约束验证注解 411
16.3.1 了解内建的约束注解 411
16.3.2 了解常见的约束特性 412
16.3.3 使用约束 413
16.3.4 使用@Valid实现递归验证 415
16.3.5 使用验证组 416
16.3.6 在编译时检查约束合法性 417
16.4 为方法验证配置Spring Bean 418
16.4.1 标注接口，而非实现 418
16.4.2 在方法参数上使用限制和递归验证 419
16.4.3 验证方法返回值 420
16.4.4 表示一个类是否适用于方法验证 420
16.4.5 在Spring MVC控制器中使用参数验证 421
16.4.6 为用户显示验证错误 423
16.5 编写自己的验证约束 425
16.5.1 在自定义限制中继承其他限制 425
16.5.2 创建限制验证器 426
16.5.3 了解限制验证器的生命周期 428
16.6 在客户支持应用程序中集成验证 429
16.7 小结 431
第17章 创建RESTful和SOAP Web服务 433
17.1 了解Web服务 433
17.1.1 最初的SOAP 434
17.1.2 RESTful Web服务提供了一种更简单的方式 435
17.2 在Spring MVC中配置RESTful Web服务 442
17.2.1 使用原型注解分离控制器 442
17.2.2 创建单独的Web和REST应用上下文 443
17.2.3 处理RESTful Web服务中的错误条件 446
17.2.4 将RESTful请求映射到控制器方法 449
17.2.5 使用索引终端改进发现机制 453
17.3 测试Web服务终端 454
17.3.1 选择测试工具 454
17.3.2 请求Web服务 455
17.4 使用Spring Web Service创建SOAP Web服务 457
17.4.1 编写契约优先的XSD和WSDL 458
17.4.2 添加SOAP派发器Servlet配置 460
17.4.3 创建SOAP终端 462
17.5 小结 465
第18章 使用消息传送和群集实现灵活性和可靠性 467
18.1 识别需要消息传送和群集的时机 467
18.1.1 应用程序消息传送的定义 468
18.1.2 群集的定义 470
18.1.3 消息传送和群集的协作方式 474
18.2 为应用程序添加消息传送支持 477
18.2.1 创建应用程序事件 477
18.2.2 订阅应用程序事件 478
18.2.3 发布应用程序事件 479
18.3 在群集中分布消息传送 481
18.3.1 更新事件以支持分布 482
18.3.2 创建并配置一个自定义事件多播器 483
18.3.3 使用WebSocket发送和接收事件 485
18.3.4 通过多播数据包发现节点 487
18.3.5 部署多个应用程序模拟群集 489
18.4 使用AMQP分布事件 490
18.4.1 配置AMQP代理 491
18.4.2 创建AMQP多播器 492
18.4.3 运行使用了AMQP的应用程序 494
18.5 小结 495
第Ⅲ部分 使用JPA和Hibernate ORM持久化数据
第19章 介绍Java Persistence API和 Hibernate ORM 499
19.1 数据持久化的定义 499
19.1.1 平面文件实体存储 500
19.1.2 结构化文件存储 500
19.1.3 关系数据库系统 501
19.1.4 面向对象数据库 501
19.1.5 无模式数据库系统 502
19.2 对象-关系映射的定义 502
19.2.1 了解持久化实体的问题 503
19.2.2 O/RM使实体持久化更简单 504
19.2.3 JPA提供了一种标准O/RM API 505
19.3 使用Hibernate ORM的原因 507
19.4 Hibernate ORM简介 507
19.4.1 使用Hibernate映射文件 507
19.4.2 了解会话API 509
19.4.3 从SessionFactory中获得会话 511
19.4.4 使用Spring Framework创建SessionFactory 512
19.5 准备关系数据库 513
19.5.1 安装MySQL和
MySQL Workbench 513
19.5.2 安装MySQL JDBC驱动 515
19.5.3 在Tomcat中创建连接资源 516
19.5.4 注意Maven依赖 517
19.6 小结 517
第20章 使用JPA注解将实体映射到表 519
20.1 使用简单实体 520
20.1.1 创建实体并将它映射到表 521
20.1.2 指示JPA使用实体字段的
方式 523
20.1.3 映射代理键 523
20.1.4 使用基本数据类型 529
20.1.5 指定列名和其他细节 532
20.2 创建和使用持久化单元 534
20.2.1 设计数据库表 534
20.2.2 了解持久化单元作用域 536
20.2.3 创建持久化配置 536
20.2.4 使用持久化API 539
20.3 映射复杂数据类型 543
20.3.1 使用枚举作为实体属性 543
20.3.2 了解JPA如何处理日期和时间 544
20.3.3 将大属性映射为CLOB和BLOB 546
20.4 小结 548
第21章 在Spring Framework仓库中使用JPA 549
21.1 使用Spring仓库和事务 550
21.1.1 了解事务范围 550
21.1.2 为事务和实体管理器使用线程 551
21.1.3 使用异常转换 552
21.2 在Spring Framework中配置持久化 553
21.2.1 查找数据源 553
21.2.2 在代码中创建持久化单元 554
21.2.3 创建事务管理 557
21.3 创建和使用JPA仓库 560
21.3.1 注入持久化单元 560
21.3.2 实现标准CRUD操作 561
21.3.3 为所有的实体创建一个基础仓库 563
21.3.4 在服务中标记事务范围 568
21.3.5 使用事务服务方法 572
21.4 在DTO和实体之间转换数据 573
21.4.1 为客户支持应用程序创建实体 574
21.4.2 使用BCrypt保护用户密码 578
21.4.3 在服务中将数据传输到实体中 579
21.5 小结 581
第22章 使用Spring Data JPA消除公式化的仓库 583
22.1 了解Spring Data的统一数据访问 584
22.1.1 避免代码重复 584
22.1.2 使用Stock仓库接口 587
22.1.3 为搜索实体创建查询方法 588
22.1.4 提供自定义方法实现 591
22.2 配置和创建Spring Data JPA仓库 594
22.2.1 启用仓库自动生成 595
22.2.2 编写和使用Spring Data
JPA接口 601
22.3 重构客户支持应用程序 603
22.3.1 转换现有仓库 603
22.3.2 在支持票据中添加评论 605
22.4 小结 609
第23章 使用JPA和Hibernate Search搜索数据 611
23.1 搜索介绍 612
23.1.1 了解索引的重要性 612
23.1.2 采取三种不同的方式 613
23.2 使用高级条件定位对象 614
23.2.1 创建复杂条件查询 614
23.2.2 在查询中使用OR 621
23.2.3 创建有用的索引改进性能 622
23.3 使用JPA的全文索引 623
23.3.1 在MySQL表中创建全文索引 624
23.3.2 创建和使用可搜索的仓库 625
23.3.3 使全文搜索可迁移 630
23.4 使用Apache Lucene和Hibernate Search索引任意数据 630
23.4.1 了解Lucene全文索引 631
23.4.2 使用索引元数据标注实体 632
23.4.3 结合使用Hibernate Search和JPA 634
23.5 小结 637
第24章 创建高级映射和自定义数据类型 639
24.1 JPA的相关内容 639
24.2 转换非标准数据类型 640
24.2.1 了解特性转换器 641
24.2.2 了解转换注解 642
24.2.3 创建和使用特性转换器 643
24.3 在实体中内嵌POJO 645
24.3.1 表示嵌套的类型 645
24.3.2 使属性成为可嵌入属性 645
24.3.3 覆盖可内嵌列列名 647
24.4 定义实体间的关系 648
24.4.1 了解一对一关系 648
24.4.2 使用一对多和多对一关系 650
24.4.3 创建多对多关系 653
24.5 处理其他常见的情况 654
24.5.1 使用修订和时间戳版本化实体 654
24.5.2 定义公共属性的抽象实体 655
24.5.3 映射基本的和内嵌的集合 656
24.5.4 持久化含有键值对的Map 659
24.5.5 在多个表中存储实体 660
24.6 创建编程式触发器 661
24.6.1 在CRUD操作之前或之后执行 661
24.6.2 使用实体监听器 663
24.7 简化客户支持应用程序 664
24.7.1 映射附件的集合 664
24.7.2 使用加载时织入延迟加载简单属性 666
24.8 小结 669
第Ⅳ部分 使用Spring Security保护应用程序
第25章 介绍Spring Security 673
25.1 认证的概念 673
25.1.1 集成认证 674
25.1.2 了解授权 682
25.2 选择Spring Security的原因 685
25.2.1 了解Spring Security基础 686
25.2.2 使用Spring Security的授权服务 686
25.2.3 配置Spring Security 687
25.3 小结 687
第26章 使用Spring Security验证用户 689
26.1 选择并配置认证提供者 690
26.1.1 配置用户细节提供者 690
26.1.2 使用LDAP和活动目录提供者 700
26.1.3 使用OpenID进行认证 703
26.1.4 remember-me认证 705
26.1.5 学习其他认证提供者 706
26.2 编写自己的认证提供者 707
26.2.1 以正确的顺序启动 707
26.2.2 创建和配置提供者 710
26.2.3 缓解跨站请求伪装攻击 715
26.3 小结 718
第27章 使用授权标签和注解 719
27.1 通过声明进行授权 719
27.1.1 在方法代码中检查权限 720
27.1.2 采用URL安全 722
27.1.3 使用注解声明权限 725
27.1.4 定义方法切点规则 732
27.2 了解授权决策 733
27.2.1 使用访问决策投票者 733
27.2.2 使用访问决策管理器 734
27.3 为对象安全创建访问控制列表 736
27.3.1 了解Spring Security的
ACL 736
27.3.2 配置访问控制列表 738
27.3.3 为实体填充ACL 740
27.4 在客户支持应用程序中添加授权 741
27.4.1 切换到自定义用户细节 742
27.4.2 保护服务方法 746
27.4.3 使用Spring Security的标签库 750
27.5 小结 751
第28章 使用OAuth保护RESTful Web服务 753
28.1 了解Web服务安全 754
28.1.1 比较Web GUI和Web服务安全 754
28.1.2 选择认证机制 754
28.2 介绍OAuth 756
28.2.1 了解关键参与者 756
28.2.2 起始：OAuth 1.0 757
28.2.3 标准：OAuth 1.0a 757
28.2.4 演化：OAuth 2.0 762
28.3 使用Spring Security OAuth 769
28.3.1 创建OAuth 2.0提供者 769
28.3.2 创建OAuth 2.0客户端 773
28.4 完成客户端支持应用程序 775
28.4.1 生成请求随机数和签名 776
28.4.2 实现客户端服务 777
28.4.3 实现随机数服务 780
28.4.4 实现令牌服务 782
28.4.5 自定义资源服务器过滤器 785
28.4.6 重新配置Spring Security 787
28.5 创建OAuth客户端应用程序 791
28.5.1 自定义REST模板 792
28.5.2 配置Spring Security OAuth客户端 793
28.5.3 使用REST模板 795
28.5.4 同时测试提供者和客户端 796
28.6 小结 797
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web高级编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实战Java虚拟机
第1章　初探Java虚拟机	1
1.1  知根知底：追溯Java的发展历程	2
1.1.1  那些依托Java虚拟机的语言大咖们	2
1.1.2  Java发展史上的里程碑	2
1.2  跨平台的真相：Java虚拟机来做中介	4
1.2.1  理解Java虚拟机的原理	4
1.2.2  看清Java虚拟机的种类	5
1.3  一切看我的：Java语言规范	6
1.3.1  词法的定义	6
1.3.2  语法的定义	7
1.3.3  数据类型的定义	8
1.3.4  Java语言规范总结	9
1.4  一切听我的：Java虚拟机规范	9
1.5  数字编码就是计算机世界的水和电	10
1.5.1  整数在Java虚拟机中的表示	10
1.5.2  浮点数在Java虚拟机中的表示	12
1.6  抛砖引玉：编译和调试虚拟机	14
1.7  小结	19
第2章　认识Java虚拟机的基本结构	20
2.1  谋全局者才能成大器：看穿Java虚拟机的架构	20
2.2  小参数能解决大问题：学会设置Java虚拟机的参数	22
2.3  对象去哪儿：辨清Java堆	23
2.4  函数如何调用：出入Java栈	25
2.4.1  局部变量表	27
2.4.2  操作数栈	32
2.4.3  帧数据区	32
2.4.4  栈上分配	33
2.5  类去哪儿了：识别方法区	35
2.6  小结	37
第3章　常用Java虚拟机参数	38
3.1  一切运行都有迹可循：掌握跟踪调试参数	38
3.1.1  跟踪垃圾回收——读懂虚拟机日志	39
3.1.2  类加载/卸载的跟踪	42
3.1.3  系统参数查看	44
3.2  让性能飞起来：学习堆的配置参数	45
3.2.1  最大堆和初始堆的设置	45
3.2.2  新生代的配置	49
3.2.3  堆溢出处理	52
3.3  别让性能有缺口：了解非堆内存的参数配置	54
3.3.1  方法区配置	55
3.3.2  栈配置	55
3.3.3  直接内存配置	55
3.4  Client和Server二选一：虚拟机的工作模式	58
3.5  小结	59
第4章　垃圾回收概念与算法	60
4.1  内存管理清洁工：认识垃圾回收	60
4.2  清洁工具大PK：讨论常用的垃圾回收算法	61
4.2.1  引用计数法（Reference Counting）	62
4.2.2  标记清除法（Mark-Sweep）	63
4.2.3  复制算法（Copying）	64
4.2.4  标记压缩法（Mark-Compact）	66
4.2.5  分代算法（Generational Collecting）	67
4.2.6  分区算法（Region）	68
4.3  谁才是真正的垃圾：判断可触及性	69
4.3.1  对象的复活	69
4.3.2  引用和可触及性的强度	71
4.3.3  软引用——可被回收的引用	72
4.3.4  弱引用——发现即回收	76
4.3.5  虚引用——对象回收跟踪	77
4.4  垃圾回收时的停顿现象：Stop-The-World案例实战	79
4.5  小结	83
第5章　垃圾收集器和内存分配	84
5.1  一心一意一件事：串行回收器	85
5.1.1  新生代串行回收器	85
5.1.2  老年代串行回收器	86
5.2  人多力量大：并行回收器	86
5.2.1  新生代ParNew回收器	87
5.2.2  新生代ParallelGC回收器	88
5.2.3老年代ParallelOldGC回收器	89
5.3  一心多用都不落下：CMS回收器	90
5.3.1  CMS主要工作步骤	90
5.3.2  CMS主要的设置参数	91
5.3.3  CMS的日志分析	92
5.3.4  有关Class的回收	94
5.4  未来我做主：G1回收器	95
5.4.1  G1的内存划分和主要收集过程	95
5.4.2  G1的新生代GC	96
5.4.3  G1的并发标记周期	97
5.4.4  混合回收	100
5.4.5  必要时的Full GC	102
5.4.6  G1日志	102
5.4.7  G1相关的参数	106
5.5  回眸：有关对象内存分配和回收的一些细节问题	107
5.5.1  禁用System.gc()	107
5.5.2  System.gc()使用并发回收	107
5.5.3  并行GC前额外触发的新生代GC	109
5.5.4  对象何时进入老年代	110
5.5.5  在TLAB上分配对象	117
5.5.6  方法finalize()对垃圾回收的影响	120
5.6  温故又知新：常用的GC参数	125
5.7  动手才是真英雄：垃圾回收器对Tomcat性能影响的实验	127
5.7.1  配置实验环境	127
5.7.2  配置进行性能测试的工具JMeter	128
5.7.3  配置Web应用服务器Tomcat	131
5.7.4  实战案例1——初试串行回收器	133
5.7.5  实战案例2——扩大堆以提升系统性能	133
5.7.6  实战案例3——调整初始堆大小	134
5.7.7  实战案例4——使用ParrellOldGC回收器	135
5.7.8  实战案例5——使用较小堆提高GC压力	135
5.7.9  实战案例6——测试ParallelOldGC的表现	135
5.7.10 实战案例7——测试ParNew回收器的表现	136
5.7.11 实战案例8——测试JDK 1.6的表现	136
5.7.12 实战案例9——使用高版本虚拟机提升性能	137
5.8  小结	137
第6章　性能监控工具	138
6.1  有我更高效：Linux下的性能监控工具	139
6.1.1  显示系统整体资源使用情况——top命令	139
6.1.2  监控内存和CPU——vmstat命令	140
6.1.3  监控IO使用——iostat命令	142
6.1.4  多功能诊断器——pidstat工具	143
6.2  用我更高效：Windows下的性能监控工具	148
6.2.1  任务管理器	148
6.2.2  perfmon性能监控工具	150
6.2.3  Process Explorer进程管理工具	153
6.2.4  pslist命令——Windows下也有命令行工具	155
6.3  外科手术刀：JDK性能监控工具	157
6.3.1  查看Java进程——jps命令	158
6.3.2  查看虚拟机运行时信息——jstat命令	159
6.3.3  查看虚拟机参数——jinfo命令	162
6.3.4  导出堆到文件——jmap命令	163
6.3.5  JDK自带的堆分析工具——jhat命令	165
6.3.6  查看线程堆栈——jstack命令	167
6.3.7  远程主机信息收集——jstatd命令	170
6.3.8  多功能命令行——jcmd命令	172
6.3.9  性能统计工具——hprof	175
6.3.10 扩展jps命令	177
6.4  我是你的眼：图形化虚拟机监控工具JConsole	178
6.4.1  JConsole连接Java程序	178
6.4.2  Java程序概况	179
6.4.3  内存监控	180
6.4.4  线程监控	180
6.4.5  类加载情况	182
6.4.6  虚拟机信息	182
6.5  一目了然：可视化性能监控工具Visual VM	183
6.5.1  Visual VM连接应用程序	184
6.5.2  监控应用程序概况	185
6.5.3  Thread Dump和分析	186
6.5.4  性能分析	187
6.5.5  内存快照分析	189
6.5.6  BTrace介绍	190
6.6  来自JRockit的礼物：虚拟机诊断工具Mission Control	198
6.6.1  MBean服务器	198
6.6.2  飞机记录器（Flight Recorder）	200
6.7  小结	203
第7章　分析Java堆	204
7.1  对症才能下药：找到内存溢出的原因	205
7.1.1  堆溢出	205
7.1.2  直接内存溢出	205
7.1.3  过多线程导致OOM	207
7.1.4  永久区溢出	209
7.1.5  GC效率低下引起的OOM	210
7.2  无处不在的字符串：String在虚拟机中的实现	210
7.2.1  String对象的特点	210
7.2.2  有关String的内存泄漏	212
7.2.3  有关String常量池的位置	215
7.3  虚拟机也有内窥镜：使用MAT分析Java堆	217
7.3.1  初识MAT	217
7.3.2  浅堆和深堆	220
7.3.3例解MAT堆分析	221
7.3.4支配树（Dominator Tree）	225
7.3.5  Tomcat堆溢出分析	226
7.4  筛选堆对象：MAT对OQL的支持	230
7.4.1  Select子句	230
7.4.2  From子句	232
7.4.3  Where子句	234
7.4.4  内置对象与方法	234
7.5  更精彩的查找：Visual VM对OQL的支持	239
7.5.1  Visual VM的OQL基本语法	239
7.5.2  内置heap对象	240
7.5.3  对象函数	242
7.5.4  集合/统计函数	247
7.5.5  程序化OQL分析Tomcat堆	252
7.6  小结	255
第8章　锁与并发	256
8.1  安全就是锁存在的理由：锁的基本概念和实现	257
8.1.1  理解线程安全	257
8.1.2  对象头和锁	259
8.2  避免残酷的竞争：锁在Java虚拟机中的实现和优化	260
8.2.1  偏向锁	260
8.2.2  轻量级锁	262
8.2.3  锁膨胀	263
8.2.4  自旋锁	264
8.2.5  锁消除	264
8.3  应对残酷的竞争：锁在应用层的优化思路	266
8.3.1  减少锁持有时间	266
8.3.2  减小锁粒度	267
8.3.3  锁分离	269
8.3.4  锁粗化	271
8.4  无招胜有招：无锁	273
8.4.1  理解CAS	273
8.4.2  原子操作	274
8.4.3  新宠儿LongAddr	277
8.5  将随机变为可控：理解Java内存模型	280
8.5.1  原子性	280
8.5.2  有序性	282
8.5.3  可见性	284
8.5.4  Happens-Before原则	286
8.6  小结	286
第9章　Class文件结构	287
9.1  不仅跨平台，还能跨语言：语言无关性	287
9.2  虚拟机的基石：Class文件	289
9.2.1  Class文件的标志——魔数	290
9.2.2  Class文件的版本	292
9.2.3  存放所有常数——常量池	293
9.2.4  Class的访问标记（Access Flag）	300
9.2.5  当前类、父类和接口	301
9.2.6  Class文件的字段	302
9.2.7  Class文件的方法基本结构	304
9.2.8  方法的执行主体——Code属性	306
9.2.9  记录行号——LineNumberTable属性	307
9.2.10 保存局部变量和参数——LocalVariableTable属性	308
9.2.11 加快字节码校验——StackMapTable属性	308
9.2.12Code属性总结	313
9.2.13 抛出异常——Exceptions属性	314
9.2.14 用实例分析Class的方法结构	315
9.2.15 我来自哪里——SourceFile属性	318
9.2.16 强大的动态调用——BootstrapMethods属性	319
9.2.17内部类——InnerClasses属性	320
9.2.18 将要废弃的通知——Deprecated属性	321
9.2.19Class文件总结	322
9.3  操作字节码：走进ASM	322
9.3.1  ASM体系结构	322
9.3.2  ASM之Hello World	324
9.4  小结	325
第10章　Class装载系统	326
10.1  来去都有序：看懂Class文件的装载流程	326
10.1.1  类装载的条件	327
10.1.2  加载类	330
10.1.3  验证类	332
10.1.4  准备	333
10.1.5  解析类	334
10.1.6  初始化	336
10.2  一切Class从这里开始：掌握ClassLoader	340
10.2.1  认识ClassLoader，看懂类加载	341
10.2.2  ClassLoader的分类	341
10.2.3  ClassLoader的双亲委托模式	343
10.2.4  双亲委托模式的弊端	347
10.2.5  双亲委托模式的补充	348
10.2.6  突破双亲模式	350
10.2.7  热替换的实现	353
10.3  小结	357
第11章　字节码执行	358
11.1  代码如何执行：字节码执行案例	359
11.2  执行的基础：Java虚拟机常用指令介绍	369
11.2.1  常量入栈指令	369
11.2.2  局部变量压栈指令	370
11.2.3  出栈装入局部变量表指令	371
11.2.4  通用型操作	372
11.2.5  类型转换指令	373
11.2.6  运算指令	375
11.2.7  对象/数组操作指令	377
11.2.8  比较控制指令	379
11.2.9  函数调用与返回指令	386
11.2.10 同步控制	389
11.2.11 再看Class的方法结构	391
11.3  更上一层楼：再看ASM	393
11.3.1  为类增加安全控制	393
11.3.2  统计函数执行时间	396
11.4  谁说Java太刻板：Java Agent运行时修改类	399
11.4.1  使用-javaagent参数启动Java虚拟机	400
11.4.2  使用Java Agent为函数增加计时功能	402
11.4.3  动态重转换类	404
11.4.4  有关Java Agent的总结	407
11.5  与时俱进：动态函数调用	407
11.5.1  方法句柄使用实例	407
11.5.2  调用点使用实例	411
11.5.3  反射和方法句柄	412
11.5.4  指令invokedynamic使用实例	414
11.6  跑得再快点：静态编译优化	418
11.6.1  编译时计算	419
11.6.2  变量字符串的连接	421
11.6.3  基于常量的条件语句裁剪	422
11.6.4  switch语句的优化	423
11.7  提高虚拟机的执行效率：JIT及其相关参数	424
11.7.1  开启JIT编译	425
11.7.2  JIT编译阈值	426
11.7.3  多级编译器	427
11.7.4  OSR栈上替换	430
11.7.5  方法内联	431
11.7.6  设置代码缓存大小	432
11.8  小结	436
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实战Java虚拟机
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Tomcat与Java Web开发技术详解（第2版）
第1篇 Java Web开发技术详解
依据SUN的Java Servlet规范和JSP规范，深入介绍了开发Java Web应用的各种技术。
第1章 Web运作原理探析 3
利用Java套接字（Socket）实现了一个简单的基于HTTP协议的客户程序和服务器程序。
1.1 Web的概念 3
1.2 HTML简介 4
1.3 URL简介 7
1.4 HTTP协议简介 7
1.4.1 HTTP请求格式 9
1.4.2 HTTP响应格式 11
1.4.3 正文部分的MIME类型 13
1.5 用Java套接字创建HTTP客户与服务器程序 14
1.5.1 演示异构系统之间用HTTP协议通信 17
1.5.2 演示对网页中的超级链接的处理过程 19
1.5.3 演示对网页中的图片的处理过程 20
1.6 Web发展历程 21
1.6.1 发布静态HTML文档 21
1.6.2 发布静态多媒体信息 22
1.6.3 提供浏览器端与用户的动态交互功能 22
1.6.4 提供服务器端与用户的动态交互功能 24
1.6.5 发布Web应用 29
1.6.6 发布Web服务 30
1.6.7 Web 2.0：全民共建的Web 32
1.7 处理HTTP请求参数及HTML表单 33
1.8 客户端向服务器端上传文件 36
1.9 小结 41
1.10 思考题 42
第2章 Tomcat简介 45
Tomcat除了能够充当运行Servlet的容器，还提供了作为Web服务器的一些实用功能，如Tomcat管理和控制平台、安全域管理和Tomcat阀等。Tomcat已成为目前开发企业JavaWeb应用的最佳Servlet容器选择之一。
2.1 Tomcat概述 46
2.2 Tomcat作为Servlet容器的基本功能 47
2.3 Tomcat的组成结构 48
2.4 Tomcat的工作模式 50
2.5 Tomcat的版本 52
2.6 安装和配置Tomcat所需的资源 53
2.7 安装Tomcat 55
2.8 启动Tomcat并测试Tomcat的安装 57
2.9 Tomcat的运行脚本 58
2.10 小结 59
2.11 思考题 60
第3章 第一个JavaWeb应用 63
以一个简单的helloapp应用为例，让初学者迅速获得开发JavaWeb应用的实际经验。
3.1 JavaWeb应用简介 63
3.2 创建JavaWeb应用 64
3.2.1 JavaWeb应用的目录结构 64
3.2.2 创建HTML文件 65
3.2.3 创建Servlet类 66
3.2.4 创建JSP文件 67
3.2.5 创建web.xml文件 68
3.3 在Tomcat中发布JavaWeb应用 70
3.3.1 Tomcat的目录结构 70
3.3.2 按照默认方式发布JavaWeb应用 71
3.3.3 Web组件的URL 72
3.3.4 配置Tomcat的元素 75
3.3.5 配置Tomcat的虚拟主机 78
3.4 创建、配置和使用自定义JSP标签 80
3.5 用批处理文件或ANT编译范例 84
3.6 小结 85
3.7 思考题 86
第4章 Servlet技术（上） 89
要想精通Servlet编程，不仅要了解Servlet自身的用法，还要了解容器为它提供的十八般武器的用法。
4.1 Servlet API 90
4.1.1 Servlet接口 90
4.1.2 GenericServlet抽象类 91
4.1.3 HttpServlet抽象类 93
4.1.4 ServletRequest接口 96
4.1.5 HttpServletRequest接口 97
4.1.6 ServletResponse接口 100
4.1.7 HttpServletResponse接口 101
4.1.8 ServletConfig接口 104
4.1.9 ServletContext接口 105
4.2 JavaWeb应用的生命周期 108
4.2.1 启动阶段 108
4.2.2 运行时阶段 109
4.2.3 终止阶段 109
4.2.4 用Tomcat的管理平台管理Web应用的生命周期 109
4.3 Servlet的生命周期 111
4.3.1 初始化阶段 111
4.3.2 运行时阶段 112
4.3.3 销毁阶段 112
4.3.4 演示Servlet的生命周期的范例 113
4.4 ServletContext与Web应用范围 115
4.4.1 在Web应用范围内存放共享数据的范例 116
4.4.2 使用ServletContextListener监听器 119
4.5 Servlet的服务方法抛出异常 121
4.6 防止页面被客户端缓存 122
4.7 小结 123
4.8 思考题 124
第5章 Servlet技术（下） 129
进一步介绍Servlet的一些高级用法。
5.1 下载文件 129
5.2 上传文件 130
5.3 动态生成图像 136
5.4 读写Cookie 139
5.5 访问Web应用的工作目录 145
5.6 转发和包含 147
5.6.1 请求转发 148
5.6.2 包含 152
5.6.3 请求范围 154
5.7 重定向 155
5.8 访问Servlet容器内的其他Web应用 158
5.9 避免并发问题 160
5.9.1 合理决定在Servlet中定义的变量的作用域类型 162
5.9.2 使用Java同步机制对多线程同步 164
5.9.3 被废弃的SingleThreadModel接口 165
5.10 小结 166
5.11 思考题 169
第6章 JSP技术 171
包括JSP的运行机制和语法、JSP包含其他Web组件的方法、把请求转发给其他Web组件的方法，以及JSP的异常处理。
6.1 比较HTML、Servlet和JSP 171
6.1.1 静态HTML文件 171
6.1.2 用Servlet动态生成HTML页面 171
6.1.3 用JSP动态生成HTML页面 173
6.2 JSP语法 177
6.2.1 JSP指令（Directive） 178
6.2.2 JSP声明 180
6.2.3 Java程序片段（Scriptlet） 181
6.2.4 Java表达式 182
6.2.5 隐含对象 184
6.3 JSP的生命周期 185
6.4 请求转发 188
6.5 包含 190
6.5.1 静态包含 190
6.5.2 动态包含 192
6.5.3 混合使用静态包含和动态包含 194
6.6 JSP异常处理 200
6.7 再谈发布JSP 202
6.8 预编译JSP 203
6.9 PageContext抽象类 204
6.10 JSP技术的发展趋势 206
6.11 小结 207
6.12 思考题 207
第7章 bookstore应用简介 211
介绍bookstore应用的软件结构、各个JSP网页的功能，以及部分Web组件的实现。
7.1 bookstore应用的软件结构 211
7.1.1 Web服务器层 211
7.1.2 数据库层 212
7.2 浏览bookstore应用的JSP网页 212
7.3 JavaBean和实用类 217
7.3.1 实体类 218
7.3.2 购物车的实现 219
7.4 发布bookstore应用 222
7.5 小结 223
第8章 访问数据库 225
介绍通过JDBC API访问数据库、在Tomcat中配置数据源，以及在Web应用中通过数据源连接数据库的方法。
8.1 安装和配置MySQL数据库 225
8.2 JDBC简介 228
8.2.1 java.sql包中的接口和类 230
8.2.2 编写访问数据库程序的步骤 234
8.2.3 事务处理 236
8.3 通过JDBC API访问数据库的JSP范例程序 237
8.4 bookstore应用通过JDBC API访问数据库 239
8.5 数据源（DataSource）简介 243
8.6 配置数据源 244
8.6.1 在context.xml中加入元素 244
8.6.2 在web.xml中加入元素 245
8.7 程序中访问数据源 246
8.7.1 通过数据源连接数据库的JSP范例程序 246
8.7.2 bookstore应用通过数据源连接数据库 248
8.8 处理中文编码 251
8.9 分页显示批量数据 252
8.10 小结 256
8.11 思考题 257
第9章 HTTP会话的使用与管理 259
介绍如何通过会话来实现服务器对客户的状态的跟踪。
9.1 会话简介 259
9.2 HttpSession的生命周期及会话范围 263
9.3 使用会话的JSP范例程序 265
9.4 使用会话的Servlet范例程序 269
9.5 通过重写URL来跟踪会话 273
9.6 会话的持久化 277
9.6.1 标准会话管理器StandardManager 279
9.6.2 持久化会话管理器PersistentManager 280
9.7 会话的监听 284
9.7.1 用HttpSessionListener统计在线用户人数 289
9.7.2 用HttpSessionBindingListener统计在线用户人数 291
9.8 小结 294
9.9 思考题 295
第10章 JSP访问JavaBean 299
介绍JavaBean的概念和创建方法， JSP访问JavaBean的语法，JavaBean在Web应用中的4种存在范围，如何在bookstore应用中运用JavaBean。
10.1 JavaBean简介 299
10.2 JSP访问JavaBean的语法 300
10.3 JavaBean的范围 302
10.3.1 JavaBean在页面（page）范围内 302
10.3.2 JavaBean在请求（request）范围内 305
10.3.3 JavaBean在会话（session）范围内 306
10.3.4 JavaBean在Web应用（application）范围内 307
10.4 在bookstore应用中访问JavaBean 308
10.4.1 访问BookDB类 308
10.4.2 访问ShoppingCart类 309
10.5 小结 313
10.6 思考题 314
第11章 开发JavaMail Web应用 317
介绍了一个JavaMail Web应用，通过它，客户可以访问邮件服务器上的邮件账号、收发邮件和管理邮件夹。
11.1 E-mail协议简介 317
11.1.1 SMTP简单邮件传输协议 317
11.1.2 POP3邮局协议 318
11.1.3 接收邮件的新协议IMAP 318
11.2 JavaMail API简介 319
11.3 建立JavaMail应用程序的开发环境 321
11.3.1 获得JavaMail API的类库 321
11.3.2 安装和配置邮件服务器 321
11.4 创建JavaMail应用程序 324
11.5 JavaMail Web应用简介 328
11.6 JavaMail Web应用的程序结构 328
11.6.1 重新封装Message数据 329
11.6.2 用于保存邮件账号信息的JavaBean 332
11.6.3 定义所有JSP文件的相同内容 334
11.6.4 登录IMAP服务器上的邮件账号 336
11.6.5 管理邮件夹 339
11.6.6 查看邮件夹中的邮件信息 342
11.6.7 查看邮件内容 345
11.6.8 创建和发送邮件 346
11.6.9 退出邮件系统 348
11.7 在Tomcat中配置邮件会话（Mail Session） 349
11.7.1 在context.xml中配置Mail Session资源 349
11.7.2 在web.xml中加入对JNDI Mail Session资源的引用 350
11.7.3 在javamail应用中获取JNDI Mail Session资源 350
11.8 发布和运行javamail应用 352
11.9 小结 352
11.10 思考题 353
第12章 EL表达式语言 355
EL（Expression Language）表达式语言是在JSP 2.0版本中引入的新特性，它用于JSP文件中的数据访问。
12.1 基本语法 355
12.1.1 访问对象的属性及数组的元素 356
12.1.2 EL运算符 356
12.1.3 隐含对象 357
12.1.4 命名变量 359
12.2 使用EL表达式的JSP范例 360
12.2.1 关于基本语法的例子 360
12.2.2 读取HTML表单数据的例子 362
12.2.3 访问命名变量的例子 363
12.3 定义和使用EL函数 363
12.4 小结 366
12.5 思考题 367
第13章 自定义JSP标签 369
结合具体的范例，进一步介绍自定义标签的创建过程，以及它在JSP文件中的使用方法。
13.1 自定义JSP标签简介 369
13.2 JSP Tag API 370
13.2.1 JspTag接口 370
13.2.2 Tag接口 371
13.2.3 IterationTag接口 373
13.2.4 BodyTag接口 374
13.2.5 TagSupport类和BodyTagSupport类 376
13.3 创建和使用message标签（访问标签属性） 380
13.3.1 创建message标签的处理类MessageTag 382
13.3.2 创建标签库描述文件 385
13.3.3 在Web应用中使用标签 388
13.3.4 发布支持中、英文版本的helloapp应用 390
13.4 创建和使用iterate标签（重复执行标签主体） 391
13.5 创建和使用greet标签（访问标签主体内容） 395
13.6 小结 399
13.7 思考题 400
第14章 采用模板设计网上书店应用 403
以bookstore应用为例，介绍如何通过自定义JSP标签来为网站设计模板，从而使所有在客户端展示的网页都通过模板来生成。
14.1 如何设计网站的模板 403
14.2 创建负责流程控制的Servlet 404
14.3 创建模板标签和模板JSP文件 406
14.3.1 标签和其处理类 408
14.3.2 标签和处理类 411
14.3.3 标签和处理类 413
14.3.4 标签和处理类 417
14.4 修改JSP文件 419
14.5 发布采用模板设计的bookstore应用 420
14.6 小结 423
第15章 JSTL Core标签库 425
本章对JSTL做了概要介绍，并且着重介绍了JSTL中的Core标签库的用法。
15.1 使用第三方提供的标签库的步骤 425
15.2 JSTL标签库简介 426
15.3 一般用途的标签 427
15.3.1 标签 427
15.3.2 标签 428
15.3.3 标签 430
15.3.4 标签 430
15.4 条件标签 431
15.4.1 标签 431
15.4.2 、和标签 432
15.5 迭代标签 433
15.5.1 标签 433
15.5.2 标签 437
15.6 URL相关的标签 437
15.6.1 标签 437
15.6.2 标签 438
15.6.3 标签 440
15.7 小结 440
15.8 思考题 441
第16章 JSTL I18N标签库 443
I18N标签库主要用于编写国际化的Web应用，本章对I18N标签库进行了详细介绍。
16.1 国际化的概念 443
16.2 Java对I18N的支持 444
16.2.1 Locale类 444
16.2.2 ResourceBundle类 448
16.2.3 MessageFormat类和复合消息 449
16.3 国际化标签 452
16.3.1 标签 452
16.3.2 标签 453
16.3.3 标签 453
16.3.4 标签 454
16.3.5 标签 455
16.3.6 标签 455
16.4 创建国际化的Web应用 456
16.4.1 创建支持国际化的网页 456
16.4.2 创建资源文件 459
16.5 格式化标签 460
16.5.1 标签 460
16.5.2 标签 461
16.5.3 标签 461
16.5.4 标签 462
16.5.5 标签 463
16.5.6 标签 465
16.6 小结 465
16.7 思考题 466
第17章 JSTL SQL标签库 469
在JSP中直接通过Java程序代码来访问数据库，会降低JSP页面的可读性和可维护性，为了解决这一问题，可以在JSP中通过JSTL SQL标签库中的标签来访问数据库。
17.1 标签 469
17.2 标签 470
17.2.1 设置数据源 470
17.2.2 设置select查询语句 470
17.2.3 控制实际取出的记录 471
17.2.4 访问查询结果 471
17.2.5 使用标签的范例 472
17.3 标签 474
17.4 标签 475
17.5 标签 475
17.6 标签 476
17.7 小结 478
17.8 思考题 478
第18章 JSTL Functions标签库 481
介绍Functions标签库中常用的16个函数的用法。
18.1 fn:contains函数 481
18.2 fn:containsIgnoreCase函数 481
18.3 fn:startsWith函数 482
18.4 fn:endsWith函数 482
18.5 fn:indexOf函数 482
18.6 fn:replace函数 483
18.7 fn:substring函数 483
18.8 fn:substringBefore函数 483
18.9 fn:substringAfter函数 484
18.10 fn:split函数 484
18.11 fn:join函数 485
18.12 fn:toLowerCase函数 485
18.13 fn:toUpperCase函数 485
18.14 fn:trim函数 486
18.15 fn:escapeXml函数 486
18.16 fn:length函数 487
18.17 小结 488
18.18 思考题 489
第19章 简单标签和标签文件 491
为了简化开发标签的过程，JSP 2.0引入了一种新的标签扩展机制，称为“简单标签扩展”。
19.1 实现SimpleTag接口 491
19.1.1 创建和使用简单标签 493
19.1.2 创建和使用带属性和标签主体的简单标签 494
19.1.3 创建和使用带动态属性的简单标签 495
19.2 使用标签文件 497
19.2.1 标签文件的隐含对象 500
19.2.2 标签文件的指令 501
19.2.3 标签文件的和动作元素 503
19.2.4 创建和使用带属性和标签主体的display标签文件 503
19.2.5 创建和使用带属性和标签主体的welcome标签文件 505
19.2.6 创建和使用带变量的precode标签文件 506
19.3 小结 507
19.4 思考题 507
第20章 过滤器 509
如果在多个Web组件中编写完成同样操作的程序代码，显然会导致重复编码，从而降低开发效率和软件的可维护性，为了解决上述问题，过滤器应运而生。
20.1 过滤器简介 509
20.2 创建过滤器 510
20.3 发布过滤器 513
20.4 串联过滤器 518
20.4.1 包装设计模式简介 519
20.4.2 ServletOutputStream的包装类 521
20.4.3 HttpServletResponse的包装类 524
20.4.4 创建对响应结果进行字符串替换的过滤器 525
20.4.5 ReplaceTextFilter过滤器工作的UML时序图 527
20.4.6 发布和运行包含ReplaceTextFilter过滤器的Web应用 528
20.5 小结 531
20.6 思考题 532
第21章 在Web应用中访问EJB组件 535
首先介绍JavaEE的体系结构；然后以bookstore应用为例，介绍开发EJB组件的过程；最后讲解如何在JBoss服务器上发布JavaEE应用。
21.1 JavaEE体系结构简介 535
21.2 安装和配置JBoss服务器 537
21.3 创建EJB组件 538
21.3.1 编写Remote接口 539
21.3.2 编写Home接口 539
21.3.3 编写Enterprise Java Bean
类 540
21.4 在Web应用中访问EJB组件 543
21.5 发布JavaEE应用 544
21.5.1 在JBoss上发布EJB组件 545
21.5.2 在JBoss上发布Web应用 547
21.5.3 在JBoss上发布JavaEE应用 549
21.6 小结 550
21.7 思考题 551
第22章 在Web应用中访问Web服务 553
介绍利用AXIS来创建SOAP服务和SOAP客户程序的方法，还介绍了在bookstore应用中访问SOAP服务的方法。
22.1 SOAP简介 553
22.2 建立Apache AXIS环境 555
22.3 在Tomcat上发布
Apache-AXIS Web应用 556
22.4 创建SOAP服务 557
22.4.1 创建提供SOAP服务的Java类 557
22.4.2 创建SOAP服务的发布描述符文件 557
22.5 管理SOAP服务 558
22.5.1 发布SOAP服务 558
22.5.2 删除SOAP服务 559
22.6 创建和运行SOAP客户程序 560
22.7 发布JWS服务 563
22.8 在bookstore应用中访问SOAP服务 563
22.8.1 创建BookDB服务类及
BookDBDelegate代理类 564
22.8.2 发布bookdbservice服务和bookstore应用 573
22.9 小结 574
22.10 思考题 575
第23章 Web应用的MVC设计模式 577
首先介绍了MVC设计模式的结构和优点；接着介绍了SUN公司提出的在Java Web开发领域的两种设计模式：JSP Model1和JSP Molde2；然后介绍了Struts实现MVC的机制；最后以helloapp应用为例，简要介绍了在Web应用中使用Struts 2.0的方法。
23.1 MVC设计模式简介 577
23.2 JSP Model 1和
JSP Model 2 579
23.3 Struts概述 581
23.3.1 Struts实现MVC的机制 581
23.3.2 Struts的工作流程 582
23.4 创建采用Struts的Web应用 583
23.4.1 建立Struts的环境 583
23.4.2 创建视图 584
23.4.3 创建模型 585
23.4.4 创建Action类 585
23.4.5 创建web.xml文件和struts.xml文件 586
23.5 运行helloapp应用 587
23.5.1 服务器端装载login.htm的流程 587
23.5.2 用户验证的流程 587
23.6 小结 589
23.7 思考题 589
第2篇 Tomcat配置及第三方实用软件的用法
介绍Tomcat服务器的基本配置和高级配置，从而为Java Web应用创建高效的运行环境；介绍在Java Web应用中运用第三方提供的实用软件（如Velocity和Log4J）的方法。
第24章 Tomcat的控制平台和管理平台 593
Tomcat提供了基于Web方式的管理平台和控制平台，用户通过浏览器，就可以很方便地配置Tomcat服务器，还可以管理运行在Tomcat服务器上的Web应用，如发布、启动、停止或删除Web应用，以及查看Web应用状态。
24.1 访问Tomcat的控制平台和管理平台 593
24.2 Tomcat的控制平台 595
24.2.1 Tomcat控制平台的功能 595
24.2.2 配置元素 597
24.3 Tomcat的管理平台 598
24.4 小结 600
第25章 安全域 601
主要介绍如何通过Tomcat提供的安全域来保护Web应用的资源。
25.1 安全域概述 601
25.2 为Web资源设置安全约束 602
25.2.1 在web.xml中加入元素 603
25.2.2 在web.xml中加入元素 605
25.2.3 在web.xml中加入元素 608
25.3 内存域 608
25.4 JDBC域 610
25.4.1 用户数据库的结构 610
25.4.2 在MySQL中创建和配置用户数据库 611
25.4.3 配置元素 611
25.5 DataSource域 612
25.6 在Web应用中访问用户信息 614
25.7 小结 614
25.8 思考题 615
第26章 Tomcat与其他HTTP 服务器集成 617
首先讨论Tomcat与HTTP服务器集成的一般原理，然后介绍Tomcat与Apache服务器及IIS集成的详细步骤，最后介绍把由多个Tomcat服务器构成的集群系统与Apache服务器集成的方法。
26.1 Tomcat与HTTP服务器集成的原理 617
26.1.1 JK插件 618
26.1.2 AJP协议 618
26.2 在Windows下Tomcat与
Apache服务器集成 618
26.3 在Linux下Tomcat与Apache
服务器集成 621
26.4 Tomcat与IIS服务器集成 623
26.4.1 准备相关文件 624
26.4.2 编辑注册表 624
26.4.3 在IIS中加入“jakarta”虚拟目录 626
26.4.4 把JK插件作为ISAPI筛选器加入到IIS中 627
26.4.5 测试配置 628
26.5 Tomcat集群 628
26.5.1 配置集群系统的负载平衡器 629
26.5.2 配置集群管理器 631
26.6 小结 635
26.7 思考题 636
第27章 在Tomcat中配置SSI 637
首先介绍了SSI的概念及SSI指令的用法，然后介绍了在Tomcat中配置SSI的方法。
27.1 SSI简介 637
27.1.1 #echo指令 638
27.1.2 #include指令 640
27.1.3 #flastmod指令 641
27.1.4 #fsize指令 641
27.1.5 #exec指令 641
27.1.6 #config指令 641
27.1.7 #if、#elif、#else和#endif指令 643
27.2 在Tomcat中配置对SSI的支持 643
27.3 小结 645
27.4 思考题 645
第28章 Tomcat阀 647
介绍Tomcat阀的种类，还将详细介绍各种Tomcat阀的功能和使用方法。
28.1 Tomcat阀简介 647
28.2 客户访问日志阀 648
28.3 远程地址过滤器 650
28.4 远程主机过滤器 651
28.5 客户请求记录器 652
28.6 小结 653
28.7 思考题 653
第29章 在Tomcat中配置SSL 655
SSL（Server Socket Layer）协议，旨在达到在开放网络（Internet）上安全、保密地传输信息的目的，这种协议在Web上获得了广泛的应用。
29.1 SSL简介 655
29.1.1 加密通信 656
29.1.2 安全证书 656
29.1.3 SSL握手 657
29.2 在Tomcat中使用SSL 658
29.2.1 准备安全证书 658
29.2.2 配置SSL连接器 659
29.2.3 访问支持SSL的Web站点 660
29.3 小结 661
29.4 思考题 662
第30章 用ANT工具管理Web应用 663
介绍了ANT的安装和配置，并以bookstore应用为例，介绍了ANT的使用方法。
30.1 安装配置ANT 663
30.2 创建build.xml文件 663
30.3 运行ANT 668
30.4 小结 669
30.5 思考题 669
第31章 使用Log4J进行日志操作 671
首先介绍Log4J的组成，接着介绍如何在程序中使用Log4J，最后介绍如何在Web应用中通过Log4J生成日志。
31.1 Log4J简介 671
31.1.1 Logger组件 672
31.1.2 Appender组件 673
31.1.3 Layout组件 673
31.1.4 Logger组件的继承性 674
31.2 Log4J的基本使用方法 675
31.2.1 定义配置文件 675
31.2.2 在程序中使用Log4J 677
31.3 在helloapp应用中使用Log4J 680
31.3.1 创建用于配置Log4J环境的Servlet 680
31.3.2 在login.jsp中输出日志 681
31.3.3 发布和运行使用Log4J的helloapp应用 681
31.4 小结 683
31.5 思考题 683
第32章 Velocity模板语言 685
首先通过一个简单的Velocity例子来讲解创建基于Velocity的Web应用的步骤，然后详细介绍Velocity模板语言的各个要素。
32.1 安装Velocity 685
32.2 Velocity的简单例子 685
32.2.1 创建Velocity模板 685
32.2.2 创建扩展VelocityServlet的Servlet类 686
32.2.3 发布和运行基于Velocity的Web应用 688
32.3 注释 689
32.4 引用 689
32.4.1 变量引用 689
32.4.2 属性引用 690
32.4.3 方法引用 692
32.4.4 正式引用符 693
32.4.5 安静引用符 693
32.4.6 转义符 694
32.4.7 大小写替换 694
32.5 指令 695
32.5.1 #set指令 695
32.5.2 字面字符串 696
32.5.3 #if指令 697
32.5.4 比较运算 697
32.5.5 #foreach循环指令 698
32.5.6 #include指令 700
32.5.7 #parse指令 700
32.5.8 #macro指令 701
32.5.9 转义VTL指令 702
32.5.10 VTL的格式 702
32.6 其他特征 703
32.6.1 数学运算 703
32.6.2 范围操作符 703
32.6.3 字符串的连接 704
32.7 小结 705
32.8 思考题 705
第33章 创建嵌入式Tomcat服务器 707
介绍如何把Tomcat嵌入到Java应用程序中，以及在程序中配置Tomcat的组件，并控制Tomcat服务器的启动和关闭。
33.1 将Tomcat嵌入到Java应用中 707
33.2 创建嵌入了Tomcat的
Java示范程序 708
33.3 运行嵌入式Tomcat
服务器 711
33.4 小结 713
附录A server.xml文件 715
对server.xml文件的一些常用的元素进行了介绍。
A.1 配置Server元素 716
A.2 配置Service元素 717
A.3 配置Engine元素 717
A.4 配置Host元素 718
A.5 配置Context元素 718
A.6 配置Connector元素 719
附录B web.xml文件 721
介绍了Web应用的配置文件web.xml文件。
B.1 配置过滤器 723
B.2 配置Servlet 724
B.3 配置Servlet映射 725
B.4 配置Session 725
B.5 配置Welcome文件清单 725
B.6 配置Tag Library 726
B.7 配置资源引用 726
B.8 配置安全约束 727
B.9 配置安全验证登录界面 727
B.10 配置对安全验证角色的引用 728
附录C XML简介 729
XML，即可扩展标记语言（Extensible Markup Language），是一种可以用来创建自定义标记的标记语言。
C.1 SGML、HTML 与XML的比较 729
C.2 DTD文档类型定义 730
C.3 有效XML文档以及简化格式的XML文档 731
C.4 XML中的常用术语 732
C.4.1 URL、URN和URI 733
C.4.2 XML命名空间 733
附录D 书中涉及软件获取途径 735
为了便于读者在本地机器上搭建运行范例的环境，列出了书中涉及的软件的获取途径。
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Tomcat与Java Web开发技术详解（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>图解Java多线程设计模式
序章1　Java线程　　1
I1.1　Java线程　　2
I1.2　何谓线程　　2
明为跟踪处理流程，实为跟踪线程　　2
单线程程序　　3
多线程程序　　4
Thread类的run方法和start方法　　5
I1.3　线程的启动　　9
线程的启动（1）——利用Thread类的子类　　9
线程的启动（2）——利用Runnable接口　　10
I1.4　线程的暂停　　12
I1.5　线程的互斥处理　　13
synchronized方法　　14
synchronized代码块　　17
I1.6　线程的协作　　18
等待队列——线程休息室　　19
wait方法——将线程放入等待队列　　19
notify方法——从等待队列中取出线程　　21
notifyAll方法——从等待队列中取出所有线程　　23
wait、notify、notifyAll是Object类的方法　　24
I1.7　线程的状态迁移　　24
I1.8　线程相关的其他话题　　26
I1.9　本章所学知识　　26
I1.10　　练习题　　26
序章2　多线程程序的评价标准　　31
I2.1　多线程程序的评价标准　　32
安全性——不损坏对象　　32
生存性——必要的处理能够被执行　　32
可复用性——类可重复利用　　33
性能——能快速、大批量地执行处理　　33
评价标准总结　　33
I2.2　本章所学知识　　34
I2.3　练习题　　34
第1章　　Single Threaded Execution模式——能通过这座桥的只有一个人　　35
1.1　Single Threaded Execution模式　　36
1.2　示例程序1：不使用Single Threaded Execution模式的程序　　36
Main类　　37
非线程安全的Gate类　　37
UserThread类　　38
执行起来看看……出错了　　39
为什么会出错呢　　40
1.3　示例程序2：使用Single Threaded Execution模式的程序　　41
线程安全的Gate类　　41
synchronized的作用　　42
1.4　Single Threaded Execution模式中的登场角色　　43
1.5　拓展思路的要点　　44
何时使用（可使用Single Threaded Execution模式的情况）　　44
生存性与死锁　　45
可复用性和继承反常　　46
临界区的大小和性能　　46
1.6　相关的设计模式　　47
Guarded Suspension模式　　47
Read-Write Lock模式　　47
Immutable模式　　47
Thread-Specific Storage模式　　48
1.7　延伸阅读1：关于synchronized　　48
synchronized语法与Before/After模式　　48
synchronized在保护着什么　　49
该以什么单位来保护呢　　50
使用哪个锁保护　　50
原子操作　　51
long与double的操作不是原子的　　51
1.8　延伸阅读2：java.util.concurrent包和计数信号量　　52
计数信号量和Semaphore类　　52
使用Semaphore类的示例程序　　52
1.9　本章所学知识　　55
1.10　　练习题　　55
第2章　　Immutable模式——想破坏也破坏不了　　61
2.1　Immutable模式　　62
2.2　示例程序　　62
使用Immutable模式的Person类　　62
Main类　　63
PrintPersonThread类　　63
2.3　Immutable模式中的登场角色　　65
2.4　拓展思路的要点　　66
何时使用（可使用Immutable模式的情况）　　66
考虑成对的mutable类和immutable类 [性能]　　66
为了确保不可变性 [可复用性]　　67
标准类库中用到的Immutable模式　　67
2.5　相关的设计模式　　69
Single Threaded Execution模式　　69
Read-Write Lock模式　　69
Flyweight模式　　69
2.6　延伸阅读1：final　　69
final的含义　　69
2.7　延伸阅读2：集合类与多线程　　71
示例1：非线程安全的java.util.ArrayList类　　71
示例2：利用Collections.synchronizedList方法所进行的同步　　74
示例3：使用copy-on-write的java.util.concurrent.CopyOnWriteArrayList类　　75
2.8　本章所学知识　　76
2.9　练习题　　77
第3章　　Guarded Suspension模式——等我准备好哦　　81
3.1　Guarded Suspension模式　　82
3.2　示例程序　　82
Request类　　83
RequestQueue类　　84
ClientThread类　　85
ServerThread类　　85
Main类　　86
java.util.Queue与java.util.LinkedList的操作　　87
getRequest详解　　87
putRequest详解　　89
synchronized的含义　　89
wait与锁　　89
3.3　Guarded Suspension模式中的登场角色　　90
3.4　拓展思路的要点　　91
附加条件的synchronized　　91
多线程版本的if　　91
忘记改变状态与生存性　　91
wait与notify/notifyAll的责任 [可复用性]　　91
各种称呼　　91
使用java.util.concurrent.LinkedBlockingQueue的示例程序　　93
3.5　相关的设计模式　　94
Single Threaded Execution模式　　94
Balking模式　　94
Producer-Consumer模式　　94
Future模式　　94
3.6　本章所学知识　　95
3.7　练习题　　95
第4章　　Balking模式——不需要就算了　　99
4.1　Balking模式　　100
4.2　示例程序　　100
Data类　　100
SaverThread类　　102
ChangerThread类　　102
Main类　　103
4.3　Balking模式中的登场角色　　105
4.4　拓展思路的要点　　106
何时使用（可使用Balking模式的情况）　　106
balk结果的表示方式　　107
4.5　相关的设计模式　　107
Guarded Suspension模式　　107
Observer模式　　107
4.6　延伸阅读：超时　　108
Balking模式和Guarded Suspension模式之间　　108
wait何时终止呢　　108
guarded timed的实现（使用wait）　　109
synchronized中没有超时，也不能中断　　110
java.util.concurrent中的超时　　111
4.7　本章所学知识　　111
4.8　练习题　　112
第5章　　Producer-Consumer模式——我来做，你来用　　115
5.1　Producer-Consumer模式　　116
5.2　示例程序　　116
Main类　　116
MakerThread类　　117
EaterThread类　　118
Table类　　118
解读put方法　　120
解读take方法　　121
5.3　Producer-Consumer模式中的登场角色　　122
5.4　拓展思路的要点　　123
守护安全性的Channel角色（可复用性）　　123
不可以直接传递吗　　124
Channel角色的剩余空间所导致的问题　　124
以什么顺序传递Data角色呢　　125
“存在中间角色”的意义　　125
Consumer角色只有一个时会怎么样呢　　126
5.5　相关的设计模式　　126
Mediator模式　　126
Worker Thread模式　　126
Command模式　　126
Strategy模式　　127
5.6　延伸阅读1：理解InterruptedException异常　　127
可能会花费时间，但可以取消　　127
加了throws InterruptedException的方法　　127
sleep方法和interrupt方法　　128
wait方法和interrupt方法　　128
join方法和interrupt方法　　129
interrupt方法只是改变中断状态　　129
isInterrupted方法——检查中断状态　　130
Thread.interrupted方法——检查并清除中断状态　　130
不可以使用Thread类的stop方法　　130
5.7　延伸阅读2：java.util.concurrent包和Producer-Consumer模式　　131
java.util.concurrent包中的队列　　131
使用java.util.concurrent.ArrayBlockingQueue的示例程序　　132
使用java.util.concurrent.Exchanger类交换缓冲区　　133
5.8　本章所学知识　　136
5.9　练习题　　137
第6章　　Read-Write Lock模式——大家一起读没问题，但读的时候不要写哦　　141
6.1　Read-Write Lock模式　　142
6.2　示例程序　　142
Main类　　143
Data类　　143
WriterThread类　　146
ReaderThread类　　146
ReadWriteLock类　　147
执行起来看看　　149
守护条件的确认　　150
6.3　Read-Write Lock模式中的登场角色　　151
6.4　拓展思路的要点　　153
利用“读取”操作的线程之间不会冲突的特性来提高程序性能　　153
适合读取操作繁重时　　153
适合读取频率比写入频率高时　　153
锁的含义　　153
6.5　相关的设计模式　　154
Immutable模式　　154
Single Threaded Execution模式　　154
Guarded Suspension模式　　154
Before/After模式　　154
Strategized Locking模式　　154
6.6　延伸阅读：java.util.concurrent.locks包和Read-Write Lock模式　　154
java.util.concurrent.locks包　　154
使用java.util.concurrent.locks的示例程序　　155
6.7　本章所学知识　　156
6.8　练习题　　157
第7章　　Thread-Per-Message模式——这项工作就交给你了　　163
7.1　Thread-Per-Message模式　　164
7.2　示例程序　　164
Main类　　164
Host类　　165
Helper类　　166
7.3　Thread-Per-Message模式中的登场角色　　168
7.4　拓展思路的要点　　169
提高响应性，缩短延迟时间　　169
适用于操作顺序没有要求时　　169
适用于不需要返回值时　　169
应用于服务器　　169
调用方法＋启动线程→发送消息　　170
7.5　相关的设计模式　　170
Future模式　　170
Worker Thread模式　　170
7.6　延伸阅读1：进程与线程　　171
7.7　延伸阅读2：java.util.concurrent包和Thread-Per-Message模式　　171
java.lang.Thread类　　171
java.lang.Runnable接口　　172
java.util.concurrent.ThreadFactory接口　　173
java.util.concurrent.Executors类获取的ThreadFactory　　174
java.util.concurrent.Executor接口　　175
java.util.concurrent.ExecutorService接口　　176
java.util.concurrent.ScheduledExecutorService类　　177
总结　　178
7.8　本章所学知识　　180
7.9　练习题　　180
第8章　　Worker Thread模式——工作没来就一直等，工作来了就干活　　187
8.1　Worker Thread模式　　188
8.2　示例程序　　188
Main类　　189
ClientThread类　　190
Request类　　190
Channel类　　191
WorkerThread类　　192
8.3　Worker Thread模式中的登场角色　　193
8.4　拓展思路的要点　　195
提高吞吐量　　195
容量控制　　195
调用与执行的分离　　196
Runnable接口的意义　　197
多态的Request角色　　198
独自一人的Worker角色　　199
8.5　相关的设计模式　　199
Producer-Consumer模式　　199
Thread-Per-Message模式　　199
Command模式　　199
Future模式　　199
Flyweight模式　　199
Thread-Specific Storage模式　　200
Active Ojbect模式　　200
8.6　延伸阅读1：Swing事件分发线程　　200
什么是事件分发线程　　200
事件分发线程只有一个　　200
事件分发线程调用监听器　　201
注册监听器的意义　　201
事件分发线程也负责绘制界面　　201
javax.swing.SwingUtilities类　　202
Swing的单线程规则　　203
8.7　延伸阅读2：java.util.concurrent包和Worker Thread模式　　204
ThreadPoolExecutor类　　204
通过java.util.concurrent包创建线程池　　205
8.8　本章所学知识　　207
8.9　练习题　　208
第9章　　Future模式——先给您提货单　　211
9.1　Future模式　　212
9.2　示例程序　　212
Main类　　214
Host类　　214
Data接口　　215
FutureData类　　216
RealData类　　217
9.3　Future模式中的登场角色　　218
9.4　拓展思路的要点　　219
吞吐量会提高吗　　219
异步方法调用的“返回值”　　220
“准备返回值”和“使用返回值”的分离　　220
变种——不让主线程久等的Future角色　　220
变种——会发生变化的Future角色　　221
谁会在意多线程呢？“可复用性”　　221
回调与Future模式　　221
9.5　相关的设计模式　　222
Thread-Per-Message模式　　222
Builder模式　　222
Proxy模式　　222
Guarded Suspension模式　　222
Balking模式　　222
9.6　延伸阅读：java.util.concurrent包与Future模式　　222
java.util.concurrent包　　222
使用了java.util.concurrent包的示例程序　　223
9.7　本章所学知识　　226
9.8　练习题　　226
第10章　　Two-Phase Termination模式——先收拾房间再睡觉　　231
10.1　Two-Phase Termination模式　　232
10.2　示例程序　　233
CountupThread类　　234
Main类　　236
10.3　Two-Phase Termination模式中的登场角色　　237
10.4　拓展思路的要点　　238
不能使用Thread类的stop方法　　238
仅仅检查标志是不够的　　239
仅仅检查中断状态是不够的　　239
在长时间处理前检查终止请求　　239
join方法和isAlive方法　　240
java.util.concurrent.ExecutorService接口与Two-Phase Termination模式　　240
要捕获程序整体的终止时　　241
优雅地终止线程　　243
10.5　相关的设计模式　　243
Before/After模式　　243
Multiphase Cancellation模式　　243
Multi-Phase Startup模式　　244
Balking模式　　244
10.6　延伸阅读1：中断状态与InterruptedException异常的相互转换　　244
中断状态→InterruptedException异常的转换　　244
InterruptedException异常→中断状态的转换　　245
InterruptedException异常→InterruptedException异常的转换　　245
10.7　延伸阅读2：java.util.concurrent包与线程同步　　246
java.util.concurrent.CountDownLatch类　　246
java.util.concurrent.CyclicBarrier类　　249
10.8　本章所学知识　　253
10.9　练习题　　253
第11章　　Thread-Specific Storage模式——一个线程一个储物柜　　263
11.1　Thread-Specific Storage模式　　264
11.2　关于java.lang.ThreadLocal类　　264
java.lang.ThreadLocal就是储物间　　264
java.lang.ThreadLocal与泛型　　265
11.3　示例程序1：不使用Thread-Specific Storage模式的示例　　265
Log类　　266
Main类　　266
11.4　示例程序2：使用了Thread-Specific Storage模式的示例　　267
线程特有的TSLog类　　268
Log类　　269
ClientThread类　　270
Main类　　271
11.5　Thread-Specific Storage模式中的登场角色　　272
11.6　拓展思路的要点　　274
局部变量与java.lang.ThreadLocal类　　274
保存线程特有的信息的位置　　275
不必担心其他线程访问　　275
吞吐量的提高很大程序上取决于实现方式　　276
上下文的危险性　　276
11.7　相关的设计模式　　277
Singleton模式　　277
Worker Thread模式　　277
Single Threaded Execution模式　　277
Proxy模式　　277
11.8　延伸阅读：基于角色与基于任务　　277
主体与客体　　277
基于角色的考虑方式　　278
基于任务的考虑方式　　278
实际上两种方式是综合在一起的　　279
11.9　本章所学知识　　279
11.10　　练习题　　280
第12章　　Active Object模式——接收异步消息的主动对象　　283
12.1　Active Object模式　　284
12.2　示例程序1　284
调用方：Main类　　287
调用方：MakerClientThread类　　288
调用方：DisplayClientThread类　　289
主动对象方：ActiveObject接口　　289
主动对象方：ActiveObjectFactory类　　290
主动对象方：Proxy类　　290
主动对象方：SchedulerThread类　　291
主动对象方：ActivationQueue类　　292
主动对象方：MethodRequest类　　293
主动对象方：MakeStringRequest类　　294
主动对象方：DisplayStringRequest类　　295
主动对象方：Result类　　295
主动对象方：FutureResult类　　296
主动对象方：RealResult类　　296
主动对象方：Servant类　　297
示例程序1的运行　　297
12.3　ActiveObject模式中的登场角色　　298
12.4　拓展思路的要点　　304
到底做了些什么事情　　304
运用模式时需要考虑问题的粒度　　304
关于并发性　　304
增加方法　　305
Scheduler角色的作用　　305
主动对象之间的交互　　306
通往分布式——从跨越线程界线变为跨越计算机界线　　306
12.5　相关的设计模式　　306
Producer-Consumer模式　　306
Future模式　　307
Worker Thread模式　　307
Thread-Specific Storage模式　　307
12.6　延伸阅读：java.util.concurrent包与Active Object模式　　307
类与接口　　307
调用方：Main类　　309
调用方：MakerClientThread类　　309
调用方：DisplayClientThread类　　310
主动对象方：ActiveObject接口　　311
主动对象方：ActiveObjectFactory类　　311
主动对象：ActiveObjectImpl类　　312
示例程序2的运行　　313
12.7　本章所学知识　　314
12.8　练习题　　315
第13章　　总结——多线程编程的模式语言　　321
13.1　多线程编程的模式语言　　322
模式与模式语言　　322
13.2　Single Threaded Execution模式
——能通过这座桥的只有一个人　　323
13.3　Immutable模式
——想破坏也破坏不了　　324
13.4　Guarded Suspension模式
——等我准备好哦　　325
13.5　Balking模式
——不需要就算了　　326
13.6　Producer-Consumer模式
——我来做，你来用　　327
13.7　Read-Write Lock模式
——大家一起读没问题，但读的时候不要写哦　　328
13.8　Thread-Per-Message模式
——这项工作就交给你了　　329
13.9　Worker Thread模式
——工作没来就一直等，工作来了就干活　　330
13.10　　Future模式
——先给您提货单　　330
13.11　Two-Phase Termination模式
——先收拾房间再睡觉　　331
13.12　Thread-Specific Storage模式
——一个线程一个储物柜　　332
13.13　Active Object模式
——接收异步消息的主动对象　　333
13.14　写在最后　　335
附录　　337
附录A　习题解答　　338
附录B　Java内存模型　　447
附录C　Java线程的优先级　　467
附录D　线程相关的主要API　　469
附录E　java.util.concurrent包　　475
附录F　示例程序的运行步骤　　483
附录G　参考文献　　485
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>图解Java多线程设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java网络编程
前言
第1章基本网络概念
网络
网络的分层
IP、TCP和UDP
Internet
客户／服务器模型
Internet标准
第2章流
输出流
输入流
过滤器流
阅读器和书写器
第3章线程
运行线程
从线程返回信息
同步
死锁
线程调度
线程池干DExecutor
第4章Internet地址
InetAddress类
Inet4Address和Inet6Address
NetworkInterface类
一些有用的程序
第5章URL和URI
URI
URL类
URI类
X—WWW—form—urlencoded
代理
通过GET与服务器端程序通信
访问口令保护的网站
第6章HTTP
HTTP协议
HTTP方法
请求主体
Cookie
第7章URLConnection
打开URLConnecUon
读取服务器的数据
读取首部
缓存
配置连接
配置客户端请求HTTP首部
向服务器写入数据
uRLConnection的安全考虑
猜测MIME媒体类型
HttDURLConnection
第8章客户端Socket
使用Socket
用Telnet研究协议
构造和连接Socket
设置Socket选项
Socket异常
GUl应用中的Socket
第9章服务器Socket
使用ServerSocket
日志
构造服务器Socket
获得服务器Socket的有关信息
Socket选项
HTTP月E务器
第10章安全Socket
保护通信
创建安全客户端Sl3cket.
选择密码组
事件处理器
会话管理
客户端模式
创建安全服务器Socket
配置SSLServerSocket
第11章非阻塞I／O
一个示例客户端
一个示例服务器
缓冲区
通道
就绪选择
第1 2章UDP
UDP协议
UDP客户端
uDP服务器
DatagramPacket类
DatagramSocket类
一些有用的应用程序
DatagramChannel
第1 3章IP组播
组播
使用组播Socket
两个简单示例
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java网络编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java核心技术·卷 I（原书第11版）
译者序
前言
致谢
第1章　Java程序设计概述  1
1.1　Java程序设计平台  1
1.2　Java“白皮书”的关键术语  2
1.2.1　简单性  2
1.2.2　面向对象  3
1.2.3　分布式  3
1.2.4　健壮性  3
1.2.5　安全性  3
1.2.6　体系结构中立  4
1.2.7　可移植性  4
1.2.8　解释型  5
1.2.9　高性能  5
1.2.10　多线程  5
1.2.11　动态性  6
1.3　Java applet与Internet  6
1.4　Java发展简史  7
1.5　关于Java的常见误解  10
第2章　Java程序设计环境  12
2.1　安装Java开发工具包  12
2.1.1　下载JDK  12
2.1.2　设置JDK  14
2.1.3　安装库源文件和文档  16
2.2　使用命令行工具  16
2.3　使用集成开发环境  20
2.4　JShell  23
第3章　Java的基本程序设计结构  26
3.1　一个简单的Java应用程序  26
3.2　注释  29
3.3　数据类型  29
3.3.1　整型  30
3.3.2　浮点类型  31
3.3.3　char类型  32
3.3.4　Unicode和char类型  33
3.3.5　boolean类型  34
3.4　变量与常量  34
3.4.1　声明变量  34
3.4.2　变量初始化  35
3.4.3　常量  36
3.4.4　枚举类型  37
3.5　运算符  37
3.5.1　算术运算符  37
3.5.2　数学函数与常量  38
3.5.3　数值类型之间的转换  40
3.5.4　强制类型转换  41
3.5.5　结合赋值和运算符  41
3.5.6　自增与自减运算符  41
3.5.7　关系和boolean运算符  42
3.5.8　位运算符  43
3.5.9　括号与运算符级别  43
3.6　字符串  44
3.6.1　子串  45
3.6.2　拼接  45
3.6.3　不可变字符串  45
3.6.4　检测字符串是否相等  47
3.6.5　空串与Null串  48
3.6.6　码点与代码单元  48
3.6.7　String API  49
3.6.8　阅读联机API文档  51
3.6.9　构建字符串  54
3.7　输入与输出  55
3.7.1　读取输入  55
3.7.2　格式化输出  57
3.7.3　文件输入与输出  61
3.8　控制流程  62
3.8.1　块作用域  63
3.8.2　条件语句  63
3.8.3　循环  66
3.8.4　确定循环  69
3.8.5　多重选择：switch语句  72
3.8.6　中断控制流程的语句  74
3.9　大数  76
3.10　数组  79
3.10.1　声明数组  79
3.10.2　访问数组元素  80
3.10.3　for each循环  81
3.10.4　数组拷贝  82
3.10.5　命令行参数  82
3.10.6　数组排序  83
3.10.7　多维数组  86
3.10.8　不规则数组  88
第4章　对象与类  92
4.1　面向对象程序设计概述  92
4.1.1　类  93
4.1.2　对象  94
4.1.3　识别类  94
4.1.4　类之间的关系  95
4.2　使用预定义类  96
4.2.1　对象与对象变量  96
4.2.2　Java类库中的LocalDate类  99
4.2.3　更改器方法与访问器方法  100
4.3　用户自定义类  103
4.3.1　Employee类  104
4.3.2　多个源文件的使用  106
4.3.3　剖析Employee类  107
4.3.4　从构造器开始  107
4.3.5　用var声明局部变量  109
4.3.6　使用null引用  109
4.3.7　隐式参数与显式参数  110
4.3.8　封装的优点  111
4.3.9　基于类的访问权限  113
4.3.10　私有方法  114
4.3.11　f?inal实例字段  114
4.4　静态字段与静态方法  115
4.4.1　静态字段  115
4.4.2　静态常量  116
4.4.3　静态方法  116
4.4.4　工厂方法  117
4.4.5　main方法  118
4.5　方法参数  121
4.6　对象构造  126
4.6.1　重载  126
4.6.2　默认字段初始化  127
4.6.3　无参数的构造器  127
4.6.4　显式字段初始化  128
4.6.5　参数名  129
4.6.6　调用另一个构造器  129
4.6.7　初始化块  130
4.6.8　对象析构与f?inalize方法  134
4.7　包  134
4.7.1　包名  134
4.7.2　类的导入  135
4.7.3　静态导入  136
4.7.4　在包中增加类  137
4.7.5　包访问  139
4.7.6　类路径  140
4.7.7　设置类路径  142
4.8　JAR文件  143
4.8.1　创建JAR文件  143
4.8.2　清单文件  144
4.8.3　可执行JAR文件  145
4.8.4　多版本JAR文件  145
4.8.5　关于命令行选项的说明  146
4.9　文档注释  148
4.9.1　注释的插入  148
4.9.2　类注释  149
4.9.3　方法注释  149
4.9.4　字段注释  150
4.9.5　通用注释  150
4.9.6　包注释  151
4.9.7　注释抽取  151
4.10　类设计技巧  152
第5章　继承  155
5.1　类、超类和子类  155
5.1.1　定义子类  155
5.1.2　覆盖方法  157
5.1.3　子类构造器  158
5.1.4　继承层次  162
5.1.5　多态  162
5.1.6　理解方法调用  163
5.1.7　阻止继承：f?inal类和方法  165
5.1.8　强制类型转换  166
5.1.9　抽象类  168
5.1.10　受保护访问  173
5.2　Object：所有类的超类  174
5.2.1　Object类型的变量  174
5.2.2　equals方法  175
5.2.3　相等测试与继承  176
5.2.4　hashCode方法  179
5.2.5　toString方法  181
5.3　泛型数组列表  186
5.3.1　声明数组列表  187
5.3.2　访问数组列表元素  189
5.3.3　类型化与原始数组列表的
兼容性  191
5.4　对象包装器与自动装箱  192
5.5　参数数量可变的方法  195
5.6　枚举类  196
5.7　反射  198
5.7.1　Class类  199
5.7.2　声明异常入门   201
5.7.3　资源  202
5.7.4　利用反射分析类的能力  203
5.7.5　使用反射在运行时分析
对象  208
5.7.6　使用反射编写泛型数组
代码  213
5.7.7　调用任意方法和构造器  216
5.8　继承的设计技巧  219
第6章　接口、lambda表达式与
内部类  222
6.1　接口  222
6.1.1　接口的概念  222
6.1.2　接口的属性  228
6.1.3　接口与抽象类  229
6.1.4　静态和私有方法  230
6.1.5　默认方法  230
6.1.6　解决默认方法冲突  231
6.1.7　接口与回调  233
6.1.8　Comparator接口  235
6.1.9　对象克隆  236
6.2　lambda表达式  242
6.2.1　为什么引入lambda表达式  242
6.2.2　lambda表达式的语法  243
6.2.3　函数式接口  245
6.2.4　方法引用  247
6.2.5　构造器引用  250
6.2.6　变量作用域  250
6.2.7　处理lambda表达式  252
6.2.8　再谈Comparator  254
6.3　内部类  255
6.3.1　使用内部类访问对象状态  256
6.3.2　内部类的特殊语法规则  259
6.3.3　内部类是否有用、必要和
安全  260
6.3.4　局部内部类  262
6.3.5　由外部方法访问变量  263
6.3.6　匿名内部类  264
6.3.7　静态内部类  267
6.4　服务加载器  270
6.5　代理  273
6.5.1　何时使用代理  273
6.5.2　创建代理对象  273
6.5.3　代理类的特性  277
第7章　异常、断言和日志  279
7.1　处理错误  279
7.1.1　异常分类  280
7.1.2　声明检查型异常  282
7.1.3　如何抛出异常  284
7.1.4　创建异常类  285
7.2　捕获异常  286
7.2.1　捕获异常  286
7.2.2　捕获多个异常  288
7.2.3　再次抛出异常与异常链  289
7.2.4　f?inally子句  290
7.2.5　try-with-Resources语句  292
7.2.6　分析堆栈轨迹元素  294
7.3　使用异常的技巧  297
7.4　使用断言  300
7.4.1　断言的概念  300
7.4.2　启用和禁用断言  301
7.4.3　使用断言完成参数检查  302
7.4.4　使用断言提供假设文档  303
7.5　日志  304
7.5.1　基本日志  305
7.5.2　高级日志  305
7.5.3　修改日志管理器配置  307
7.5.4　本地化  308
7.5.5　处理器  309
7.5.6　过滤器  312
7.5.7　格式化器  313
7.5.8　日志技巧  313
7.6　调试技巧  321
第8章　泛型程序设计  326
8.1　为什么要使用泛型程序设计  326
8.1.1　类型参数的好处  326
8.1.2　谁想成为泛型程序员  328
8.2　定义简单泛型类  328
8.3　泛型方法  330
8.4　类型变量的限定  331
8.5　泛型代码和虚拟机  333
8.5.1　类型擦除  333
8.5.2　转换泛型表达式  335
8.5.3　转换泛型方法  335
8.5.4　调用遗留代码  337
8.6　限制与局限性  338
8.6.1　不能用基本类型实例化类型参数  338
8.6.2　运行时类型查询只适用于原始类型  338
8.6.3　不能创建参数化类型的数组  338
8.6.4　Varargs警告  339
8.6.5　不能实例化类型变量  340
8.6.6　不能构造泛型数组  341
8.6.7　泛型类的静态上下文中类型变量无效  342
8.6.8　不能抛出或捕获泛型类的实例  343
8.6.9　可以取消对检查型异常的检查  343
8.6.10　注意擦除后的冲突  345
8.7　泛型类型的继承规则  346
8.8　通配符类型  348
8.8.1　通配符概念  348
8.8.2　通配符的超类型限定  349
8.8.3　无限定通配符  351
8.8.4　通配符捕获  352
8.9　反射和泛型  354
8.9.1　泛型Class类  354
8.9.2　使用Class<T>参数进行类型匹配  355
8.9.3　虚拟机中的泛型类型信息  356
8.9.4　类型字面量  359
第9章　集合  365
9.1　Java集合框架  365
9.1.1　集合接口与实现分离  365
9.1.2　Collection接口  368
9.1.3　迭代器  368
9.1.4　泛型实用方法  370
9.2　集合框架中的接口  373
9.3　具体集合  375
9.3.1　链表  375
9.3.2　数组列表  384
9.3.3　散列集  385
9.3.4　树集  388
9.3.5　队列与双端队列  391
9.3.6　优先队列  392
9.4　映射  394
9.4.1　基本映射操作  394
9.4.2　更新映射条目  397
9.4.3　映射视图  398
9.4.4　弱散列映射  399
9.4.5　链接散列集与映射  400
9.4.6　枚举集与映射  401
9.4.7　标识散列映射  402
9.5　视图与包装器  403
9.5.1　小集合  404
9.5.2　子范围  405
9.5.3　不可修改的视图  405
9.5.4　同步视图  406
9.5.5　检查型视图  407
9.5.6　关于可选操作的说明  407
9.6　算法  411
9.6.1　为什么使用泛型算法  411
9.6.2　排序与混排  412
9.6.3　二分查找  414
9.6.4　简单算法  415
9.6.5　批操作  417
9.6.6　集合与数组的转换  418
9.6.7　编写自己的算法  418
9.7　遗留的集合  419
9.7.1　Hashtable类  419
9.7.2　枚举  419
9.7.3　属性映射  421
9.7.4　栈  424
9.7.5　位集  424
第10章　图形用户界面程序设计  429
10.1　Java用户界面工具包简史  429
10.2　显示窗体  430
10.2.1　创建窗体  431
10.2.2　窗体属性  433
10.3　在组件中显示信息  435
10.3.1　处理2D图形  439
10.3.2　使用颜色  445
10.3.3　使用字体  446
10.3.4　显示图像  452
10.4　事件处理  453
10.4.1　基本事件处理概念  453
10.4.2　实例：处理按钮点击事件  454
10.4.3　简洁地指定监听器  457
10.4.4　适配器类  458
10.4.5　动作  460
10.4.6　鼠标事件  464
10.4.7　AWT事件继承层次  469
10.5　首选项API  472
第11章　Swing用户界面组件  478
11.1　Swing和模型–视图–控制器设计模式  478
11.2　布局管理概述  481
11.2.1　布局管理器  482
11.2.2　边框布局  483
11.2.3　网格布局  484
11.3　文本输入  485
11.3.1　文本域  486
11.3.2　标签和标签组件  487
11.3.3　密码域  488
11.3.4　文本区  489
11.3.5　滚动窗格  489
11.4　选择组件  491
11.4.1　复选框  492
11.4.2　单选按钮  494
11.4.3　边框  497
11.4.4　组合框  499
11.4.5　滑动条  502
11.5　菜单  507
11.5.1　菜单构建  507
11.5.2　菜单项中的图标  509
11.5.3　复选框和单选按钮菜单项  510
11.5.4　弹出菜单  511
11.5.5　键盘助记符和加速器  512
11.5.6　启用和禁用菜单项  514
11.5.7　工具条  518
11.5.8　工具提示  519
11.6　复杂的布局管理  520
11.6.1　网格包布局  520
11.6.2　定制布局管理器  529
11.7　对话框  532
11.7.1　选项对话框  533
11.7.2　创建对话框  536
11.7.3　数据交换  540
11.7.4　文件对话框  545
第12章　并发  552
12.1　什么是线程  552
12.2　线程状态  555
12.2.1　新建线程  556
12.2.2　可运行线程  556
12.2.3　阻塞和等待线程  556
12.2.4　终止线程  558
12.3　线程属性  558
12.3.1　中断线程  558
12.3.2　守护线程  561
12.3.3　线程名  561
12.3.4　未捕获异常的处理器  561
12.3.5　线程优先级  563
12.4　同步  563
12.4.1　竞态条件的一个例子  563
12.4.2　竞态条件详解  567
12.4.3　锁对象  568
12.4.4　条件对象  571
12.4.5　synchronized关键字  576
12.4.6　同步块  579
12.4.7　监视器概念  580
12.4.8　volatile字段  581
12.4.9　final变量  582
12.4.10　原子性  582
12.4.11　死锁  584
12.4.12　线程局部变量  586
12.4.13　为什么废弃stop和suspend方法  587
12.5　线程安全的集合  589
12.5.1　阻塞队列  589
12.5.2　高效的映射、集和队列  595
12.5.3　映射条目的原子更新  596
12.5.4　对并发散列映射的批操作  599
12.5.5　并发集视图  600
12.5.6　写数组的拷贝  601
12.5.7　并行数组算法  601
12.5.8　较早的线程安全集合  602
12.6　任务和线程池  603
12.6.1　Callable与Future  603
12.6.2　执行器  605
12.6.3　控制任务组  607
12.6.4　fork-join框架  612
12.7　异步计算  615
12.7.1　可完成Future  615
12.7.2　组合可完成Future  616
12.7.3　用户界面回调中的长时间运行任务  622
12.8　进程  628
12.8.1　建立一个进程  628
12.8.2　运行一个进程  630
12.8.3　进程句柄  631
附录　Java关键字  634
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java核心技术·卷 I（原书第11版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构与算法经典问题解析
译者序
前言
第1章绪论1
1.1变量1
1.2数据类型1
1.3数据结构2
1.4抽象数据类型2
1.5什么是算法3
1.6为什么需要算法分析3
1.7算法分析的目的3
1.8什么是运行时间分析4
1.9如何比较算法4
1.10什么是增长率4
1.11常用的增长率4
1.12分析的类型5
1.13渐近表示6
1.14大O表示法6
1.15Ω表示法7
1.16Θ表示法8
1.17重要说明9
1.18为什么称为渐近分析9
1.19渐近分析指南9
1.20渐近表示法的性质11
1.21常用的对数和累加公式11
1.22分治法主定理12
1.23分治法主定理的相关问题12
1.24问题规模减小和递归求解主定理13
1.25问题规模减小和递归求解主定理的变型13
1.26猜测和确认的方法14
1.27平摊分析15
1.28算法分析的相关问题15
第2章递归和回溯28
2.1引言28
2.2什么是递归28
2.3为什么要用递归28
2.4递归函数的格式28
2.5递归和内存（可视化）29
2.6递归与迭代30
2.7递归说明30
2.8递归算法的经典用例30
2.9递归的相关问题31
2.10什么是回溯32
2.11回溯算法的经典用例32
2.12回溯的相关问题32
第3章链表34
3.1什么是链表34
3.2链表抽象数据类型34
3.3为什么要用链表35
3.4数组概述35
3.5链表、数组和动态数组的比较36
3.6单向链表36
3.7双向链表41
3.8循环链表46
3.9一种存储高效的双向链表51
3.10松散链表52
3.11链表的相关问题55
第4章栈72
4.1什么是栈72
4.2如何使用栈72
4.3栈抽象数据类型73
4.4异常73
4.5应用73
4.6实现73
4.7栈的各种实现方法比较77
4.8栈的相关问题78
第5章队列98
5.1什么是队列98
5.2如何使用队列98
5.3队列抽象数据类型99
5.4异常99
5.5应用99
5.6实现99
5.7队列的相关问题104
第6章树110
6.1什么是树110
6.2术语110
6.3二叉树111
6.4二叉树的遍历114
6.5通用树（N叉树）135
6.6线索（无栈或无队列结构）二叉树遍历141
6.7表达式树147
6.8异或树149
6.9二叉搜索树150
6.10平衡二叉搜索树164
6.11AVL树165
6.12树的其他形式178
6.12.1红黑树178
6.12.2伸展树179
6.12.3增强树179
6.12.4替罪羊树179
6.12.5区间树180
第7章优先队列和堆181
7.1什么是优先队列181
7.2优先队列ADT181
7.3优先队列的应用182
7.4优先队列的实现182
7.5堆和二叉堆183
7.6二叉堆184
7.7优先队列（堆）的相关问题190
第8章并查集ADT201
8.1引言201
8.2等价关系和等价类201
8.3并查集ADT202
8.4应用202
8.5并查集ADT实现中的权衡202
8.6快速UNION实现（慢FIND）203
8.7快速UNION实现（快速FIND）206
8.8路径压缩208
8.9小结209
8.10并查集的相关问题209
第9章图算法211
9.1引言211
9.2术语211
9.3图的应用214
9.4图的表示214
9.5图的遍历217
9.6拓扑排序225
9.7最短路径算法226
9.8最小生成树231
9.9图算法的相关问题235
第10章排序256
10.1什么是排序256
10.2为什么需要排序256
10.3排序的分类256
10.4其他分类方法257
10.5冒泡排序257
10.6选择排序258
10.7插入排序259
10.8希尔排序261
10.9归并排序262
10.10堆排序264
10.11快速排序264
10.12树排序266
10.13排序算法比较267
10.14线性排序算法267
10.15计数排序267
10.16桶排序268
10.17基数排序268
10.18拓扑排序269
10.19外部排序269
10.20排序的相关问题270
第11章查找279
11.1什么是查找279
11.2为什么需要查找279
11.3查找的类型279
11.4符号表和散列281
11.5字符串查找算法281
11.6查找的相关问题281
第12章选择算法(中位数)304
12.1什么是选择算法304
12.2基于排序的选择算法304
12.3基于划分的选择算法304
12.4线性选择算法——中位数的中位数算法305
12.5按照排序顺序查找K个最小元素305
12.6选择算法的相关问题305
第13章符号表314
13.1引言314
13.2什么是符号表314
13.3符号表的实现315
13.4符号表实现方法的比较315
第14章散列317
14.1什么是散列317
14.2为什么用散列317
14.3散列表ADT317
14.4散列的例子317
14.5散列的组成部分319
14.6散列表319
14.7散列函数319
14.8负载因子320
14.9冲突320
14.10冲突解决技术320
14.11分离链接法320
14.12开放定址法321
14.13冲突解决技术的比较322
14.14散列如何达到O(1)的时间复杂度322
14.15散列技术323
14.16不适用散列表的问题323
14.17布鲁姆过滤器323
14.18散列的相关问题325
第15章字符串算法335
15.1引言335
15.2字符串匹配算法335
15.3蛮力法336
15.4RobinKarp字符串匹配算法336
15.5基于有限自动机的字符串匹配算法337
15.6KMP算法338
15.7BoyceMoore算法342
15.8存储字符串的数据结构342
15.9字符串的散列表实现342
15.10字符串的二叉搜索树实现343
15.11键树343
15.12三叉搜索树345
15.13二叉搜索树、键树和三叉搜索树的比较349
15.14后缀树349
15.15字符串的相关问题353
第16章算法设计技术361
16.1引言361
16.2分类361
16.3按实现方法分类361
16.4按设计方法分类362
16.5其他分类法363
第17章贪婪算法364
17.1引言364
17.2贪婪策略的定义364
17.3贪婪算法的要素364
17.4贪婪算法的适用范围365
17.5贪婪算法的优缺点365
17.6贪婪算法的应用365
17.7贪婪思想365
17.8贪婪算法的相关问题368
第18章分治算法375
18.1引言375
18.2分治策略的定义375
18.3分治法的适用范围375
18.4分治法的图形化描述375
18.5分治思想376
18.6主定理377
18.7分治法的应用377
18.8分治法的相关问题378
第19章动态规划算法390
19.1引言390
19.2动态规划策略的定义390
19.3动态规划策略的性质390
19.4动态规划的适用范围390
19.5动态规划的实现方法391
19.6动态规划算法的例子391
19.7动态规划思想391
19.8动态规划的相关问题396
第20章复杂度类型425
20.1引言425
20.2多项式/指数时间425
20.3决策问题的定义426
20.4决策过程426
20.5复杂度类型的定义426
20.6复杂度类型426
20.7归约428
20.8复杂度类型的相关问题430
第21章杂谈433
21.1引言433
21.2位运算的使用433
21.2.1按位与操作433
21.2.2按位或操作434
21.2.3按位异或操作434
21.2.4按位左移操作434
21.2.5按位右移操作434
21.2.6按位补操作434
21.2.7检测第K位是否置位434
21.2.8第K位置位435
21.2.9第K位清零435
21.2.10切换第K位435
21.2.11切换值为1的最右位435
21.2.12隔离值为1的最右位435
21.2.13隔离值为0的最右位435
21.2.14检查某个数是否是2的幂436
21.2.15将某个数乘以2的幂436
21.2.16将某个数除以2的幂436
21.2.17找到给定操作数的模436
21.2.18反转二进制数436
21.2.19位值1的计数436
21.2.20创建末尾位为0的掩码437
21.2.21交换奇偶位438
21.2.22不使用除法来计算平均数438
21.3其他编程问题438
参考文献442
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构与算法经典问题解析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JAVA核心技术卷2
译者序前言第1章  流与文件          1.1  流            1.1.1  读写字节            1.1.2  完整的流家族            1.1.3  组合流过滤器          1.2  文本输入与输出            1.2.1  如何写出文本输出            1.2.2  如何读入文本输入            1.2.3  以文本格式存储对象            1.2.4  字符集          1.3  读写二进制数据          1.4  ZIP文档          1.5  对象流与序列化            1.5.1  理解对象序列化的文件格式            1.5.2  修改默认的序列化机制            1.5.3  序列化单例和类型安全的枚举            1.5.4  版本管理            1.5.5  为克隆使用序列化          1.6  文件管理          1.7  新I/O            1.7.1  内存映射文件            1.7.2  缓冲区数据结构            1.7.3  文件加锁机制          1.8  正则表达式     ……   第2章  XML  第3章  网络 第4章  数据库编程第5章  国际化 第6章  高级Swing第7章  高级AWT 第8章  JavaBean构件第9章  安全 第10章  分布式对象 第11章  脚本、编译与注解处理 第12章  本地方法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JAVA核心技术卷2
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>写给大忙人看的Java SE 8
第1章  lambda表达式	0
1.1  为什么要使用lambda表达式	2
1.2  lambda表达式的语法	4
1.3  函数式接口	6
1.4  方法引用	8
1.5  构造器引用	10
1.6  变量作用域	10
1.7  默认方法	14
1.8  接口中的静态方法	17
练习	18
第2章  Stream API	20
2.1  从迭代器到Stream操作	22
2.2  创建Stream	23
2.3  filter、map和flatMap方法	25
2.4  提取子流和组合流	26
2.5  有状态的转换	27
2.6  简单的聚合方法	28
2.7  Optional类型	29
2.7.1  使用Optional值	29
2.7.2  创建可选值	30
2.7.3  使用flatMap来组合可选值函数	31
2.8  聚合操作	32
2.9  收集结果	33
2.10  将结果收集到Map中	35
2.11  分组和分片	37
2.12  原始类型流	40
2.13  并行流	42
2.14  函数式接口	44
练习	45
第3章使用lambda编程	48
3.1  延迟执行	50
3.2  lambda表达式的参数	51
3.3  选择一个函数式接口	52
3.4  返回函数	55
3.5  组合	56
3.6  延迟	58
3.7  并行操作	59
3.8  处理异常	60
3.9  lambda表达式和泛型	63
3.10  一元操作	65
练习	67
第4章  JavaFX	72
4.1  Java GUI编程简史	74
4.2  你好，JavaFX！	75
4.3  事件处理	76
4.4  JavaFX属性	77
4.5  绑定	80
4.6  布局	85
4.7  FXML	91
4.8  CSS	95
4.9  动画和特殊效果	97
4.10  不寻常的控件	100
练习	103
第5章新的日期和时间API	106
5.1  时间线	108
5.2  本地日期	110
5.3  日期校正器	113
5.4  本地时间	114
5.5  带时区的时间	115
5.6  格式化和解析	119
5.7  与遗留代码互操作	122
练习	123
第6章并发增强	126
6.1  原子值	128
6.2  ConcurrentHashMap改进	131
6.2.1  更新值	132
6.2.2  批量数据操作	134
6.2.3  Set视图	136
6.3  并行数组操作	137
6.4  可完成的Future	138
6.4.1  Future	138
6.4.2  编写Future	139
6.4.3  Future流水线	139
6.4.4  编写异步操作	141
练习	143
第7章  JavaScript引擎——Nashorn	146
7.1  从命令行运行Nashorn	148
7.2  从Java运行Nashorn	149
7.3  调用方法	150
7.4  构造对象	151
7.5  字符串	153
7.6  数字	153
7.7  使用数组	154
7.8  列表和映射	155
7.9  lambda表达式	156
7.10  继承Java类及实现Java接口	157
7.11  异常	158
7.12  Shell脚本	159
7.12.1  执行Shell命令	159
7.12.2  字符串插值	160
7.12.3  脚本输入	161
7.13  Nashorn和JavaFX	162
练习	164
第8章杂项改进	166
8.1  字符串	168
8.2  数字类	168
8.3  新的数学函数	169
8.4  集合	170
8.4.1  集合类中添加的方法	170
8.4.2  比较器	171
8.4.3  Collections类	173
8.5  使用文件	173
8.5.1  读取文件行的流	173
8.5.2  遍历目录项的流	175
8.5.3  Base64编码	176
8.6  注解	177
8.6.1  可重复的注解	177
8.6.2  可用于类型的注解	179
8.6.3  方法参数反射	181
8.7  其他一些细微的改进	182
8.7.1  Null检查	182
8.7.2  延迟消息	182
8.7.3  正则表达式	183
8.7.4  语言环境	183
8.7.5  JDBC	185
练习	185
第9章你可能错过的Java 7特性	188
9.1  异常处理改进	190
9.1.1  try-with-resources语句	190
9.1.2  忽略异常	191
9.1.3  捕获多个异常	192
9.1.4  更简单地处理反射方法的异常	193
9.2  使用文件	193
9.2.1  Path	194
9.2.2  读取和写入文件	196
9.2.3  创建文件和目录	197
9.2.4  复制、移动和删除文件	198
9.3  实现equals、hashCode和compareTo方法	198
9.3.1  安全的Null值相等测试	198
9.3.2  计算哈希码	199
9.3.3  比较数值类型对象	200
9.4  安全需要	201
9.5  其他改动	204
9.5.1  将字符串转换为数字	204
9.5.2  全局Logger	204
9.5.3  Null检查	205
9.5.4  ProcessBuilder	205
9.5.5  URLClassLoader	206
9.5.6  BitSet	206
练习	207
索引	209
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>写给大忙人看的Java SE 8
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java TCP/IP Socket编程
译者序
前言
第1章 简介
1.1 计算机网络、分组报文和协议
1.2 关于地址
1.3 关于名字
l.4 客户端和服务器
1.5 什么是套接字
1.6 练习
第2章 基本套接字
2.1 套接字地址
2.2 TCP套接字
2.2.1 TCP客户端
2.2.2 TCP服务器端
2.2.3 输入输出流
2.3 UDP套接字
2.3.1 Datagram Packet类
2.3.2 UDP客户端
2.3.3 UDP服务器端
2.3.4 使用UDP套接字发送和接收信息
2.4 练习
第3章 发送和接收数据
3.1 信息编码
3.1.1 基本整型
3.1.2 字符串和文本
3.1.3 位操作：布尔值编码
3.2 组合输入输出流
3.3 成帧与解析
3.4 Java特定编码
3.5 构建和解析协议消息
3.5.1 基于文本的表示方法
3.5.2 二进制表示方法
3.5.3 发送和接收
3.6 结束
3.7 练习
第4章 进阶
4.1 多任务处理
4.1.1 Java多线程
4.1.2 服务器协议
4.1.3 一客户一线程
4.1.4 线程池
4.1.5 系统管理调度：Executor接口
4.2 阻塞和超时
4.2.1 accept()、read()和receive()
4.2.2 连接和写数据
4.2.3 限制每个客户端的时间
4.3 多接收者
4.3.1 广播
4.3.2 多播
4.4 控制默认行为
4.4.1 Keep-Alive。
4.4.2 发送和接收缓存区的大小
4.4.3 超时
4.4.4 地址重用
4.4.5 消除缓冲延迟
4.4.6 紧急数据
4.4.7 关闭后停留
4.4.8 广播许可
4.4.9 通信等级
4.4.10基于性能的协议选择
4.5 关闭连接
4.6 Applet
4.7 结束
4.8 练习
第5章 NIO
5.1 为什么需要NIO
5.2 与Buffer一起使用Channel
5.3 Selector
5.4 Buffer详解
5.4.1 Buffet索引
5.4.2 创建Buffer
5.4.3 存储和接收数据
5.4.4 准备Buffer：clear()、flip()和rewind()
5.4.5 压缩Buffer中的数据
5.4.6 Buffer透视：duplicate()和slice()等
5.4.7 字符编码
5.5 流（TCP）信道详解
5.6 Selector详解
5.6.1 在信道中注册
5.6.2 选取和识别准备就绪的信道
5.6.3 信道附件
5.6.4 Selector小结
5.7 数据报（UDP）信道
5.8 练习
第6章 深入剖析
6.1 缓冲和TCP
6.2 死锁风险
6.3 性能相关
6.4 TCP套接字的生存周期
6.4.1 连接
6.4.2 关闭TCP连接
6.5 解调多路复用揭秘
6.6 练习
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java TCP/IP Socket编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java加密与解密的艺术
第一部分  基础篇第1章  企业应用安全  1.1  我们身边的安全问题  1.2  拿什么来拯救你，我的应用  1.3  捍卫企业应用安全的银弹  1.4  为你的企业应用上把锁  1.5  小结第2章  企业应用安全的银弹—密码学  2.1  密码学的发家史  2.2  密码学定义、术语及其分类  2.3  保密通信模型  2.4  古典密码  2.5  对称密码体制  2.6  非对称密码体制  2.7  散列函数  2.8  数字签名  2.9  密码学的未来  2.10  小结第3章  Java加密利器  3.1  Java与密码学  3.2  java.security包详解  3.3  javax.crypto包详解  3.4  java.security.spec包和javax.crypto.spec包详解  3.5  java.security.cert包详解  3.6  javax.net.ssl包详解  3.7  小结第4章  他山之石，可以攻玉  4.1  加固你的系统  4.2  加密组件Bouncy Castle  4.3  辅助工具Commons Codec  4.4  小结    第二部分  实践篇第5章  电子邮件传输算法—Base64  5.1  Base64算法的由来  5.2  Base64算法的定义  5.3  Base64算法与加密算法的关系  5.4  实现原理  5.5  模型分析  5.6  Base64算法实现  5.7  Url Base64算法实现  5.8  应用举例  5.9  小结第6章  验证数据完整性—消息摘要算法  6.1  消息摘要算法简述  6.2  MD算法家族  6.3  SHA算法家族  6.4  MAC算法家族  6.5  其他消息摘要算法  6.6  循环冗余校验算法—CRC算法  6.7  实例：文件校验  6.8  小结第7章  初等数据加密—对称加密算法  7.1  对称加密算法简述  7.2  数据加密标准—DES  7.3  三重DES—DESede  7.4  高级数据加密标准—AES  7.5  国际数据加密标准—IDEA  7.6  基于口令加密—PBE  7.7  实例：对称加密网络应用  7.8  小结第8章  高等数据加密—非对称加密算法  8.1  非对称加密算法简述  8.2  密钥交换算法—DH  8.3  典型非对称加密算法—RSA  8.4  常用非对称加密算法—ElGamal  8.5  实例：非对称加密网络应用  8.6  小结第9章  带密钥的消息摘要算法—数字签名算法  9.1  数字签名算法简述  9.2  模型分析  9.3  经典数字签名算法—RSA  9.4  数字签名标准算法—DSA  9.5  椭圆曲线数字签名算法—ECDSA  9.6  实例：带有数字签名的加密网络应用  9.7  小结    第三部分  综合应用篇第10章  终极武器—数字证书  10.1  数字证书详解  10.2  模型分析  10.3  证书管理  10.4  证书使用  10.5  应用举例  10.6  小结第11章  终极装备—安全协议  11.1  安全协议简述  11.2  模型分析  11.3  单向认证服务  11.4  双向认证服务  11.5  应用举例  11.6  小结第12章  量体裁衣—为应用选择合适的装备  12.1  实例：常规Web应用开发安全  12.2  实例：IM应用开发安全  12.3  实例：Web Service应用开发安全  12.4  小结附录A  Java 6支持的算法附录B  Bouncy Castle支持的算法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java加密与解密的艺术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>疯狂Java讲义
第1章  Java语言概述与开发环境	1
1.1  Java语言的发展简史	2
1.2  Java的竞争对手及各自优势	4
1.2.1  C#简介和优势	4
1.2.2  Ruby简介和优势	5
1.2.3  Python简介和优势	5
1.3  Java程序运行机制	6
1.3.1  高级语言的运行机制	6
1.3.2  Java程序的运行机制和JVM	6
1.4  开发Java的准备	8
1.4.1  下载和安装Java 8的JDK	8
不是说JVM是运行Java程序的虚拟机吗？那JRE和JVM的关系是怎样的呢？	8
为什么不安装公共JRE呢？	9
1.4.2  设置PATH环境变量	10
为什么选择用户变量？用户变量与系统变量有什么区别？	11
1.5  第一个Java程序	12
1.5.1  编辑Java源代码	12
1.5.2  编译Java程序	12
当编译C程序时，不仅需要指定存放目标文件的位置，也需要指定目标文件的文件名，这里使用javac编译Java程序时怎么不需要指定目标文件的文件名呢？	13
1.5.3  运行Java程序	13
1.5.4  根据CLASSPATH环境变量定位类	14
1.6  Java程序的基本规则	15
1.6.1  Java程序的组织形式	15
1.6.2  Java源文件的命名规则	16
1.6.3  初学者容易犯的错误	17
1.7  垃圾回收机制	19
1.8  何时开始使用IDE工具	20
我想学习Java编程，到底是学习Eclipse好，还是学习NetBeans好呢？	21
1.9  本章小结	21
第2章　理解面向对象	22
2.1  面向对象	23
2.1.1  结构化程序设计简介	23
2.1.2  程序的三种基本结构	24
2.1.3  面向对象程序设计简介	26
2.1.4  面向对象的基本特征	27
2.2  UML（统一建模语言）介绍	28
2.2.1  用例图	30
2.2.2  类图	30
2.2.3  组件图	32
2.2.4  部署图	33
2.2.5  顺序图	33
2.2.6  活动图	34
2.2.7  状态机图	35
2.3  Java的面向对象特征	36
2.3.1  一切都是对象	36
2.3.2  类和对象	36
2.4  本章小结	37
第3章　数据类型和运算符	38
3.1  注释	39
3.1.1  单行注释和多行注释	39
3.1.2  文档注释	40
API文档是什么?	40
为什么要学习查看API文档的方法？
3.2  标识符和关键字	46
3.2.1  分隔符	46
3.2.2  标识符规则	47
3.2.3  Java关键字	47
3.3  数据类型分类	48
什么是变量？变量有什么用？	48
3.4  基本数据类型	49
3.4.1  整型	49
3.4.2  字符型	51
什么是字符集？	51
3.4.3  浮点型	53
3.4.4  数值中使用下画线分隔	54
3.4.5  布尔型	54
3.5  基本类型的类型转换	55
3.5.1  自动类型转换	55
3.5.2  强制类型转换	56
3.5.3  表达式类型的自动提升	58
3.6  直接量	59
3.6.1  直接量的类型	59
3.6.2  直接量的赋值	59
3.7  运算符	60
3.7.1  算术运算符	60
3.7.2  赋值运算符	63
3.7.3  位运算符	63
3.7.4  扩展后的赋值运算符	66
3.7.5  比较运算符	66
3.7.6  逻辑运算符	67
3.7.7  三目运算符	68
3.7.8  运算符的结合性和优先级	69
3.8  本章小结	70
第4 章　流程控制与数组	71
4.1  顺序结构	72
4.2  分支结构	72
4.2.1  if条件语句	72
4.2.2  Java 7增强后的switch分支语句	76
4.3  循环结构	78
4.3.1  while循环语句	78
4.3.2  do while循环语句	79
4.3.3  for循环	80
4.3.4  嵌套循环	83
4.4  控制循环结构	84
4.4.1  使用break结束循环	84
4.4.2  使用continue忽略本次循环剩下语句	85
4.4.3  使用return结束方法	86
4.5  数组类型	86
4.5.1  理解数组：数组也是一种类型	86
int[]是一种类型吗？怎么使用这种类型呢？	87
4.5.2  定义数组	87
4.5.3  数组的初始化	88
能不能只分配内存空间，不赋初始值呢？	88
4.5.4  使用数组	89
为什么要我记住这些异常信息？	89
4.5.5  foreach循环	90
4.6  深入数组	91
4.6.1  内存中的数组	91
为什么有栈内存和堆内存之分？	92
4.6.2  基本类型数组的初始化	94
4.6.3  引用类型数组的初始化	95
4.6.4  没有多维数组	97
我是否可以让图4.13中灰色覆盖的数组元素再次指向另一个数组？这样不就可以扩展成三维数组，甚至扩展成更多维的数组吗？	98
4.6.5  Java 8增强的工具类：Arrays	99
4.6.6  数组的应用举例	102
4.7  本章小结	105
本章练习	105
第5 章　面向对象（上）	106
5.1  类和对象	107
5.1.1  定义类	107
构造器不是没有返回值吗？为什么不能用void声明呢？	109
5.1.2  对象的产生和使用	110
5.1.3  对象、引用和指针	110
5.1.4  对象的this引用	111
5.2  方法详解	115
5.2.1  方法的所属性	115
5.2.2  方法的参数传递机制	116
5.2.3  形参个数可变的方法	119
5.2.4  递归方法	120
5.2.5  方法重载	122
为什么方法的返回值类型不能用于区分重载的方法？	122
5.3  成员变量和局部变量	123
5.3.1  成员变量和局部变量	123
5.3.2  成员变量的初始化和内存中的运行机制	126
5.3.3  局部变量的初始化和内存中的
运行机制	128
5.3.4  变量的使用规则	129
5.4  隐藏和封装	130
5.4.1  理解封装	130
5.4.2  使用访问控制符	130
5.4.3  package、import和import static	133
5.4.4  Java的常用包	138
5.5  深入构造器	138
5.5.1  使用构造器执行初始化	138
构造器是创建Java对象的途径，是不是说构造器完全负责创建Java对象？	139
5.5.2  构造器重载	139
为什么要用this来调用另一个重载的构造器？我把另一个构造器里的代码复制、粘贴到这个构造器里不就可以了吗？	141
5.6  类的继承	141
5.6.1  继承的特点	141
5.6.2  重写父类的方法	142
5.6.3  super限定	144
5.6.4  调用父类构造器	146
为什么我创建Java对象时从未感觉到java.lang. Object类的构造器被调用过？	148
5.7  多态	148
5.7.1  多态性	148
5.7.2  引用变量的强制类型转换	150
5.7.3  instanceof运算符	151
5.8  继承与组合	152
5.8.1  使用继承的注意点	152
5.8.2  利用组合实现复用	153
使用组合关系来实现复用时，需要创建两个Animal对象，是不是意味着使用组合关系时系统开销更大？	156
5.9  初始化块	156
5.9.1  使用初始化块	156
5.9.2  初始化块和构造器	158
5.9.3  静态初始化块	159
5.10  本章小结	161
第6 章　面向对象（下）	162
6.1  Java 8增强的包装类	163
Java为什么要对这些数据进行缓存呢?	166
6.2  处理对象	167
6.2.1  打印对象和toString方法	167
6.2.2  ==和equals方法	169
上面程序中判断obj是否为Person类的实例时，为何不用obj instanceof Person来判断呢？	172
6.3  类成员	172
6.3.1  理解类成员	172
6.3.2  单例（Singleton）类	173
6.4  final修饰符	174
6.4.1  final成员变量	175
6.4.2  final局部变量	176
6.4.3  final修饰基本类型变量和引用类型变量的区别	177
6.4.4  可执行“宏替换”的final变量	178
6.4.5  final方法	180
6.4.6  final类	180
6.4.7  不可变类	181
6.4.8  缓存实例的不可变类	183
6.5  抽象类	186
6.5.1  抽象方法和抽象类	186
6.5.2  抽象类的作用	189
6.6  Java 8改进的接口	190
6.6.1  接口的概念	190
6.6.2  Java 8中接口的定义	190
6.6.3  接口的继承	193
6.6.4  使用接口	193
6.6.5  接口和抽象类	195
6.6.6  面向接口编程	195
6.7  内部类	199
6.7.1  非静态内部类	199
非静态内部类对象和外部类对象的关系是怎样的？	203
6.7.2  静态内部类	203
为什么静态内部类的实例方法也不能访问外部类的实例属性呢？	204
接口里是否能定义内部接口？	205
6.7.3  使用内部类	205
既然内部类是外部类的成员，那么是否可以为外部类定义子类，在子类中再定义一个内部类来重写其父类中的内部类呢？	208
6.7.4  局部内部类	208
6.7.5  Java 8改进的匿名内部类	209
6.8  Java 8新增的Lambda表达式	212
6.8.1  Lambda表达式入门	212
6.8.2  Lambda表达式与函数式接口	214
6.8.3  方法引用与构造器引用	216
6.8.4  Lambda表达式与匿名内部类的联系和区别	218
6.8.5  使用Lambda表达式调用Arrays的类方法	219
6.9  枚举类	220
6.9.1  手动实现枚举类	220
6.9.2  枚举类入门	221
6.9.3  枚举类的成员变量、方法和构造器	222
6.9.4  实现接口的枚举类	224
枚举类不是用final修饰了吗？怎么还能派生子类呢？	225
6.9.5  包含抽象方法的枚举类	225
6.10  对象与垃圾回收	226
6.10.1  对象在内存中的状态	227
6.10.2  强制垃圾回收	227
6.10.3  finalize方法	229
6.10.4  对象的软、弱和虚引用	230
6.11  修饰符的适用范围	233
6.12  使用JAR文件	234
6.12.1  jar命令详解	235
6.12.2  创建可执行的JAR包	236
6.12.3  关于JAR包的技巧	237
6.13  本章小结	238
本章练习	238
第7 章　Java基础类库	239
7.1  与用户互动	240
7.1.1  运行Java程序的参数	240
7.1.2  使用Scanner获取键盘输入	241
7.2  系统相关	243
7.2.1  System类	243
7.2.2  Runtime类	245
7.3  常用类	246
7.3.1  Object类	246
7.3.2  Java 7新增的Objects类	247
7.3.3  String、StringBuffer和
StringBuilder类	248
7.3.4  Math类	251
7.3.5  Java 7的ThreadLocalRandom与Random	253
7.3.6  BigDecimal类	255
7.4  Java 8的日期、时间类	257
7.4.1  Date类	257
7.4.2  Calendar类	258
7.4.3  Java 8新增的日期、时间包	261
7.5  正则表达式	263
7.5.1  创建正则表达式	263
7.5.2  使用正则表达式	266
7.6  国际化与格式化	270
7.6.1  Java国际化的思路	270
7.6.2  Java支持的国家和语言	270
7.6.3  完成程序国际化	271
7.6.4  使用MessageFormat处理包含占位符的字符串	273
7.6.5  使用类文件代替资源文件	274
7.6.6  使用NumberFormat格式化数字	274
7.6.7  使用DateFormat格式化日期、时间	276
7.6.8  使用SimpleDateFormat格式化日期	277
7.7  Java 8新增的日期、时间格式器	278
7.7.1  使用DateTimeFormatter完成格式化	278
7.7.2  使用DateTimeFormatter解析字符串	279
7.8  本章小结	280
本章练习	280
第8 章　Java集合	281
8.1  Java集合概述	282
8.2  Collection和Iterator接口	283
8.2.1  使用Lambda表达式遍历集合	285
8.2.2  使用Java 8增强的Iterator遍历集合元素	286
8.2.3  使用Lambda表达式遍历Iterator	287
8.2.4  使用foreach循环遍历集合元素	288
8.2.5  使用Java 8新增的Predicate操作集合	288
8.2.6  使用Java 8新增的Stream操作集合	289
8.3  Set集合	291
8.3.1  HashSet类	292
hashCode()方法对于HashSet是不是十分重要？	293
8.3.2  LinkedHashSet类	295
8.3.3  TreeSet类	296
8.3.4  EnumSet类	302
8.3.5  各Set实现类的性能分析	303
8.4  List集合	304
8.4.1  Java 8改进的List接口和ListIterator接口	304
8.4.2  ArrayList和Vector实现类	307
8.4.3  固定长度的List	308
8.5  Queue集合	308
8.5.1  PriorityQueue实现类	309
8.5.2  Deque接口与ArrayDeque实现类	309
8.5.3  LinkedList实现类	311
8.5.4  各种线性表的性能分析	312
8.6  Java 8增强的Map集合	313
8.6.1  Java 8为Map新增的方法	315
8.6.2  Java 8改进的HashMap和Hashtable实现类	316
8.6.3  LinkedHashMap实现类	319
8.6.4  使用Properties读写属性文件	319
8.6.5  SortedMap接口和TreeMap实现类	320
8.6.6  WeakHashMap实现类	323
8.6.7  IdentityHashMap实现类	323
8.6.8  EnumMap实现类	324
8.6.9  各Map实现类的性能分析	325
8.7  HashSet和HashMap的性能选项	325
8.8  操作集合的工具类：Collections	326
8.8.1  排序操作	326
8.8.2  查找、替换操作	329
8.8.3  同步控制	330
8.8.4  设置不可变集合	330
8.9  烦琐的接口：Enumeration	331
8.10  本章小结	332
本章练习	332
第9 章　泛型	333
9.1  泛型入门	334
9.1.1  编译时不检查类型的异常	334
9.1.2  使用泛型	334
9.1.3  Java 7泛型的“菱形”语法	335
9.2  深入泛型	336
9.2.1　定义泛型接口、类	336
9.2.2  从泛型类派生子类	338
9.2.3  并不存在泛型类	339
9.3  类型通配符	339
9.3.1  使用类型通配符	341
9.3.2  设定类型通配符的上限	341
9.3.3  设定类型形参的上限	343
9.4  泛型方法	344
9.4.1  定义泛型方法	344
9.4.2  泛型方法和类型通配符的区别	346
9.4.3  Java 7的“菱形”语法与泛型构造器	347
9.4.4  设定通配符下限	348
9.4.5  泛型方法与方法重载	350
9.4.6  Java 8改进的类型推断	351
9.5  擦除和转换	352
9.6  泛型与数组	353
9.7  本章小结	355
第10 章　异常处理	356
10.1  异常概述	357
10.2  异常处理机制	358
10.2.1  使用try...catch捕获异常	358
10.2.2  异常类的继承体系	360
10.2.3  Java 7提供的多异常捕获	362
10.2.4  访问异常信息	363
10.2.5  使用finally回收资源	364
10.2.6  异常处理的嵌套	366
10.2.7  Java 7的自动关闭资源的try语句	366
10.3  Checked异常和Runtime异常体系	368
10.3.1  使用throws声明抛出异常	368
10.4  使用throw抛出异常	370
10.4.1  抛出异常	370
10.4.2  自定义异常类	371
10.4.3  catch和throw同时使用	372
10.4.4  Java 7增强的throw语句	373
10.4.5  异常链	374
10.5  Java的异常跟踪栈	376
10.6  异常处理规则	377
10.6.1  不要过度使用异常	378
10.6.2  不要使用过于庞大的try块	379
10.6.3  避免使用Catch All语句	379
10.6.4  不要忽略捕获到的异常	379
10.7  本章小结	380
本章练习	380
第11 章　AWT编程	381
11.1  GUI（图形用户界面）和AWT	382
11.2  AWT容器	383
11.3  布局管理器	386
11.3.1  FlowLayout布局管理器	386
11.3.2  BorderLayout布局管理器	387
BorderLayout最多只能放置5个组件吗？那它也太不实用了吧？	388
11.3.3  GridLayout布局管理器	389
11.3.4  GridBagLayout布局管理器	390
11.3.5  CardLayout布局管理器	392
11.3.6  绝对定位	394
11.3.7  BoxLayout布局管理器	395
图11.15和图11.16显示的所有按钮都紧挨在一起，如果希望像FlowLayout、GridLayout等布局管理器那样指定组件的间距应该怎么办？	396
11.4  AWT常用组件	397
11.4.1  基本组件	397
11.4.2  对话框（Dialog）	399
11.5  事件处理	401
11.5.1  Java事件模型的流程	401
11.5.2  事件和事件监听器	403
11.5.3  事件适配器	407
11.5.4  使用内部类实现监听器	408
11.5.5  使用外部类实现监听器	408
11.5.6  类本身作为事件监听器类	409
11.5.7  匿名内部类实现监听器	410
11.6  AWT菜单	410
11.6.1  菜单条、菜单和菜单项	410
11.6.2  右键菜单	412
为什么即使我没有给多行文本域编写右键菜单，但当我在多行文本域上单击右键时也一样会弹出右键菜单？	414
11.7  在AWT中绘图	414
11.7.1  画图的实现原理	414
11.7.2  使用Graphics类	415
11.8  处理位图	419
11.8.1  Image抽象类和BufferedImage实现类	419
11.8.2  使用ImageIO输入/输出位图	421
11.9  剪贴板	425
11.9.1  数据传递的类和接口	426
11.9.2  传递文本	426
11.9.3  使用系统剪贴板传递图像	428
11.9.4  使用本地剪贴板传递对象引用	430
11.9.5  通过系统剪贴板传递Java对象	433
11.10  拖放功能	435
11.10.1  拖放目标	436
11.10.2  拖放源	439
11.11  本章小结	440
本章练习	440
第12 章　Swing编程	441
12.1  Swing概述	442
12.2  Swing基本组件的用法	443
12.2.1  Java 7 的Swing组件层次	443
12.2.2  AWT组件的Swing实现	444
为什么单击Swing多行文本域时不是弹出像AWT多行文本域中的右键菜单？	450
12.2.3  为组件设置边框	450
12.2.4  Swing组件的双缓冲和键盘驱动	452
12.2.5  使用JToolBar创建工具条	453
12.2.6  使用JFileChooser和Java 7增强的JColorChooser	455
12.2.7  使用JOptionPane	462
12.3  Swing中的特殊容器	467
12.3.1  使用JSplitPane	467
12.3.2  使用JTabbedPane	469
12.3.3  使用JLayeredPane、JdesktopPane和JInternalFrame	473
12.4  Swing简化的拖放功能	480
12.5  Java 7新增的Swing功能	481
12.5.1  使用JLayer装饰组件	481
12.5.2  创建透明、不规则形状窗口	487
12.6  使用JProgressBar、ProgressMonitor和BoundedRangeModel创建进度条	489
12.6.1  创建进度条	489
12.6.2  创建进度对话框	492
12.7  使用JSlider和BoundedRangeModel创建滑动条	494
12.8  使用JSpinner和SpinnerModel创建微调控制器	497
12.9  使用JList、JComboBox创建列表框	500
12.9.1  简单列表框	500
12.9.2  不强制存储列表项的ListModel和ComboBoxModel	503
12.9.3  强制存储列表项的DefaultListModel和DefaultComboBoxModel	506
为什么JComboBox提供了添加、删除列表项的方法？而JList没有提供添加、删除列表项的方法呢？	508
12.9.4  使用ListCellRenderer改变列表项外观	508
12.10  使用JTree和TreeModel创建树	510
12.10.1  创建树	511
12.10.2  拖动、编辑树节点	513
12.10.3  监听节点事件	517
12.10.4  使用DefaultTreeCellRenderer改变节点外观	519
12.10.5  扩展DefaultTreeCellRenderer改变节点外观	520
12.10.6  实现TreeCellRenderer改变节点外观	523
12.11  使用JTable和TableModel创建表格	524
12.11.1  创建表格	525
我们指定的表格数据、表格列标题都是Object类型的数组，JTable如何显示这些Object对象？	525
12.11.2  TableModel和监听器	530
12.11.3  TableColumnModel和监听器	534
12.11.4  实现排序	537
12.11.5  绘制单元格内容	540
12.11.6  编辑单元格内容	543
12.12  使用JFormattedTextField和JtextPane创建格式文本	546
12.12.1  监听Document的变化	547
12.12.2  使用JPasswordField	549
12.12.3  使用JFormattedTextField	549
12.12.4  使用JEditorPane	557
12.12.5  使用JTextPane	557
12.13  本章小结	564
本章练习	564
第13 章　MySQL数据库与JDBC编程	565
13.1  JDBC基础	566
13.1.1  JDBC简介	566
13.1.2  JDBC驱动程序	567
13.2  SQL语法	568
13.2.1  安装数据库	568
13.2.2  关系数据库基本概念和MySQL基本命令	570
13.2.3  SQL语句基础	572
13.2.4  DDL语句	573
13.2.5  数据库约束	577
13.2.6  索引	584
13.2.7  视图	585
13.2.8  DML语句语法	585
13.2.9  单表查询	588
13.2.10  数据库函数	592
13.2.11  分组和组函数	594
13.2.12  多表连接查询	596
13.2.13  子查询	599
13.2.14  集合运算	601
13.3  JDBC的典型用法	602
13.3.1  JDBC 4.2常用接口和类简介	602
13.3.2  JDBC编程步骤	604
前面给出的仅仅是MySQL和Oracle两种数据库的驱动，我看不出驱动类字符串有什么规律啊。如果我希望使用其他数据库，那怎么找到其他数据库的驱动类呢？	604
13.4  执行SQL语句的方式	607
13.4.1  使用Java 8新增的executeLargeUpdate方法执行DDL和DML语句	607
13.4.2  使用execute方法执行SQL语句	608
13.4.3  使用PreparedStatement执行SQL语句	610
13.4.4  使用CallableStatement调用存储过程	614
13.5  管理结果集	615
13.5.1  可滚动、可更新的结果集	615
13.5.2  处理Blob类型数据	617
13.5.3  使用ResultSetMetaData分析结果集	622
13.6  Java 7的RowSet 1.1	624
13.6.1  Java 7新增的RowSetFactory与RowSet	625
13.6.2  离线RowSet	627
13.6.3  离线RowSet的查询分页	629
13.7  事务处理	630
13.7.1  事务的概念和MySQL事务支持	630
13.7.2  JDBC的事务支持	632
13.7.3  Java 8增强的批量更新	634
13.8  分析数据库信息	635
13.8.1  使用DatabaseMetaData分析数据库信息	635
13.8.2  使用系统表分析数据库信息	636
13.8.3  选择合适的分析方式	637
13.9  使用连接池管理连接	638
13.9.1  DBCP数据源	638
13.9.2  C3P0数据源	639
13.10  本章小结	640
本章练习	640
第14 章　Annotation（注释）	641
14.1  基本Annotation	642
14.1.1  限定重写父类方法：@Override	642
14.1.2  标示已过时：@Deprecated	643
14.1.3  抑制编译器警告：@SuppressWarnings	644
14.1.4  Java 7的“堆污染”警告与@SafeVarargs	644
14.1.5  Java 8的函数式接口与@FunctionalInterface	645
14.2  JDK的元Annotation	646
14.2.1  使用@Retention	646
14.2.2  使用@Target	647
14.2.3  使用@Documented	647
14.2.4  使用@Inherited	648
14.3  自定义Annotation	649
14.3.1  定义Annotation	649
14.3.2  提取Annotation信息	650
14.3.3  使用Annotation的示例	652
14.3.4  Java 8新增的重复注解	656
14.3.5  Java 8新增的Type Annotation	658
14.4  编译时处理Annotation	659
14.5  本章小结	663
第15 章　输入/输出	664
15.1  File类	665
15.1.1  访问文件和目录	665
15.1.2  文件过滤器	667
15.2  理解Java的IO流	668
15.2.1  流的分类	668
15.2.2  流的概念模型	669
15.3  字节流和字符流	670
15.3.1  InputStream和Reader	670
15.3.2  OutputStream和Writer	672
15.4  输入/输出流体系	673
15.4.1  处理流的用法	674
15.4.2  输入/输出流体系	674
15.4.3  转换流	677
怎么没有把字符流转换成字节流的转换流呢？	677
15.4.4  推回输入流	678
15.5  重定向标准输入/输出	679
15.6  Java虚拟机读写其他进程的数据	680
15.7  RandomAccessFile	682
15.8  对象序列化	686
15.8.1  序列化的含义和意义	686
15.8.2  使用对象流实现序列化	686
15.8.3  对象引用的序列化	688
15.8.4  自定义序列化	692
15.8.5  另一种自定义序列化机制	696
15.8.6  版本	698
15.9  NIO	699
15.9.1  Java新IO概述	699
15.9.2  使用Buffer	699
15.9.3  使用Channel	702
15.9.4  字符集和Charset	705
二进制序列与字符之间如何对应呢？	706
15.9.5  文件锁	707
15.10  Java 7的NIO.2	709
15.10.1  Path、Paths和Files核心API	709
15.10.2  使用FileVisitor遍历文件和目录	710
15.10.3  使用WatchService监控文件变化	711
15.10.4  访问文件属性	712
15.11  本章小结	714
本章练习	714
第16 章　多线程	715
16.1  线程概述	716
16.1.1  线程和进程	716
16.1.2  多线程的优势	717
16.2  线程的创建和启动	718
16.2.1  继承Thread类创建线程类	718
16.2.2  实现Runnable接口创建线程类	719
16.2.3  使用Callable和Future创建线程	720
16.2.4  创建线程的三种方式对比	722
16.3  线程的生命周期	722
16.3.1  新建和就绪状态	722
16.3.2  运行和阻塞状态	724
16.3.3  线程死亡	725
16.4  控制线程	726
16.4.1  join线程	726
16.4.2  后台线程	727
16.4.3  线程睡眠：sleep	728
16.4.4  线程让步：yield	729
16.4.5  改变线程优先级	730
16.5  线程同步	731
16.5.1  线程安全问题	731
16.5.2  同步代码块	733
16.5.3  同步方法	735
16.5.4  释放同步监视器的锁定	737
16.5.5  同步锁（Lock）	737
16.5.6  死锁	739
16.6  线程通信	741
16.6.1  传统的线程通信	741
16.6.2  使用Condition控制线程通信	744
16.6.3  使用阻塞队列（BlockingQueue）控制线程通信	746
16.7  线程组和未处理的异常	749
16.8  线程池	752
16.8.1  Java 8改进的线程池	752
16.8.2  Java 8增强的ForkJoinPool	754
16.9  线程相关类	757
16.9.1  ThreadLocal类	757
16.9.2  包装线程不安全的集合	759
16.9.3  线程安全的集合类	759
16.10  本章小结	760
第17 章　网络编程	761
17.1  网络编程的基础知识	762
17.1.1  网络基础知识	762
17.1.2  IP地址和端口号	763
17.2  Java的基本网络支持	764
17.2.1  使用InetAddress	764
17.2.2  使用URLDecoder和URLEncoder	765
17.2.3  URL、URLConnection和URLPermission	766
17.3  基于TCP协议的网络编程	772
17.3.1  TCP协议基础	772
17.3.2  使用ServerSocket创建TCP服务器端	773
17.3.3  使用Socket进行通信	773
17.3.4  加入多线程	776
17.3.5  记录用户信息	778
17.3.6  半关闭的Socket	785
17.3.7  使用NIO实现非阻塞Socket通信	786
17.3.8  使用Java 7的AIO实现非阻塞通信	792
上面程序中好像没用到④⑤号代码的get()方法的返回值，这两个地方不调用get()方法行吗？	795
17.4  基于UDP协议的网络编程	798
17.4.1  UDP协议基础	799
17.4.2  使用DatagramSocket发送、接收数据	799
17.4.3  使用MulticastSocket实现多点广播	803
17.5  使用代理服务器	813
17.5.1  直接使用Proxy创建连接	813
17.5.2  使用ProxySelector自动选择代理服务器	814
17.6  本章小结	817
本章练习	817
第18 章　类加载机制与反射	818
18.1  类的加载、连接和初始化	819
18.1.1  JVM和类	819
18.1.2  类的加载	820
18.1.3  类的连接	821
18.1.4  类的初始化	821
18.1.5  类初始化的时机	822
18.2  类加载器	823
18.2.1  类加载器简介	823
18.2.2  类加载机制	824
18.2.3  创建并使用自定义的类加载器	826
18.2.4  URLClassLoader类	829
18.3  通过反射查看类信息	830
18.3.1  获得Class对象	830
18.3.2  从Class中获取信息	831
18.3.3  Java 8新增的方法参数反射	835
18.4  使用反射生成并操作对象	836
18.4.1  创建对象	836
18.4.2  调用方法	838
18.4.3  访问成员变量值	840
18.4.4  操作数组	841
18.5  使用反射生成JDK动态代理	842
18.5.1  使用Proxy和InvocationHandler创建动态代理	843
18.5.2  动态代理和AOP	844
18.6  反射和泛型	848
18.6.1  泛型和Class类	848
18.6.2  使用反射来获取泛型信息	850
18.7  本章小结	851
本章练习	851
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>疯狂Java讲义
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java学习笔记
Chapter 1 Java平台概论 1
1.1 Java不只是语言 2
1.1.1 前世今生 2
1.1.2 三大平台 5
1.1.3 JCP与JSR 6
1.1.4 Oracle JDK与OpenJDK 7
1.1.5 建议的学习路径 9
1.2 JVM/JRE/JDK 12
1.2.1 什么是JVM 13
1.2.2 区分JRE与JDK 15
1.2.3 下载、安装JDK 16
1.2.4 认识JDK安装内容 19
1.3 重点复习 20
1.4 课后练习 21
Chapter 2 从JDK到IDE 22
2.1 从Hello World开始 23
2.1.1 撰写Java原始码 23
2.1.2 PATH是什么 25
2.1.3 JVM(java)与
CLASSPATH 28
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java学习笔记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程实战指南（核心篇）
第一部分  多线程编程基础
第1章  走近Java世界中的线程	2
1.1  进程、线程与任务	2
1.2  多线程编程简介	4
1.2.1  什么是多线程编程	4
1.2.2  为什么使用多线程	4
1.3  Java线程API简介	5
1.3.1  线程的创建、启动与运行	5
1.3.2  Runnable接口	9
1.3.3  线程属性	12
1.3.4  Thread类的常用方法	14
1.3.5  Thread类的一些废弃方法	16
1.4  无处不在的线程	17
1.5  线程的层次关系	19
1.6  线程的生命周期状态	21
1.7  线程的监视	22
1.8  多线程编程简单运用实例	26
*1.9  多线程编程的优势和风险	27
1.10  本章小结	29
第2章  多线程编程的目标与挑战	31
2.1  串行、并发与并行	31
2.2  竞态	33
2.2.1  二维表分析法：解释竞态的结果	37
2.2.2  竞态的模式与竞态产生的条件	39
2.3  线程安全性	42
2.4  原子性	43
2.5  可见性	49
2.6  有序性	56
2.6.1  重排序的概念	56
2.6.2  指令重排序	57
2.6.3  存储子系统重排序	63
2.6.4  貌似串行语义	66
2.6.5  保证内存访问的顺序性	68
2.7  上下文切换	69
2.7.1  上下文切换及其产生原因	69
2.7.2  上下文切换的分类及具体诱因	70
2.7.3  上下文切换的开销和测量	71
2.8  线程的活性故障	73
2.9  资源争用与调度	74
2.10  本章小结	77
第3章  Java线程同步机制	80
3.1  线程同步机制简介	80
3.2  锁概述	81
3.2.1  锁的作用	82
3.2.2  与锁相关的几个概念	84
3.2.3  锁的开销及其可能导致的问题	86
3.3  内部锁：synchronized关键字	86
3.4  显式锁：Lock接口	89
3.4.1  显式锁的调度	91
3.4.2  显式锁与内部锁的比较	92
3.4.3  内部锁还是显式锁：锁的选用	95
*3.4.4  改进型锁：读写锁	95
3.5  锁的适用场景	99
3.6  线程同步机制的底层助手：内存屏障	99
*3.7  锁与重排序	102
3.8  轻量级同步机制：volatile关键字	105
3.8.1  volatile的作用	105
3.8.2  volatile变量的开销	111
3.8.3  volatile的典型应用场景与实战案例	111
3.9  实践：正确实现看似简单的单例模式	120
3.10  CAS与原子变量	126
3.10.1  CAS	127
3.10.2  原子操作工具：原子变量类	129
3.11  对象的发布与逸出	135
3.11.1  对象的初始化安全：重访final与static	137
3.11.2  安全发布与逸出	142
3.12  本章小结	143
第4章  牛刀小试：玩转线程	148
4.1  挖掘可并发点	148
4.2  新战场上的老武器：分而治之	148
4.3  基于数据的分割实现并发化	149
4.4  基于任务的分割实现并发化	158
4.4.1  按任务的资源消耗属性分割	159
4.4.2  实战案例的启发	169
4.4.3  按处理步骤分割	171
4.5  合理设置线程数	172
4.5.1  Amdahl's定律	172
4.5.2  线程数设置的原则	173
4.6  本章小结	177
第5章  线程间协作	179
5.1  等待与通知：wait/notify	179
5.1.1  wait/notify的作用与用法	180
5.1.2  wait/notify的开销及问题	188
5.1.3  Object.notify()/notifyAll()的选用	191
*5.1.4  wait/notify与Thread.join()	191
5.2  Java条件变量	192
5.3  倒计时协调器：CountDownLatch	198
5.4  栅栏（CyclicBarrier）	203
5.5  生产者—消费者模式	210
5.5.1  阻塞队列	213
5.5.2  限购：流量控制与信号量（Semaphore）	216
*5.5.3  管道：线程间的直接输出与输入	218
5.5.4  一手交钱，一手交货：双缓冲与Exchanger	221
5.5.5  一个还是一批：产品的粒度	223
5.5.6  再探线程与任务之间的关系	224
5.6  对不起，打扰一下：线程中断机制	225
5.7  线程停止：看似简单，实则不然	228
5.7.1  生产者—消费者模式中的线程停止	233
5.7.2  实践：Web应用中的线程停止	233
5.8  本章小结	236
第6章  保障线程安全的设计技术	240
*6.1  Java运行时存储空间	240
6.2  大公无私：无状态对象	243
6.3  以“不变”应万变：不可变对象	248
6.4  我有我地盘：线程特有对象	254
6.4.1  线程特有对象可能导致的问题及其规避	258
6.4.2  线程特有对象的典型应用场景	264
6.5  装饰器模式	265
6.6  并发集合	267
6.7  本章小结	270
第7章  线程的活性故障	273
7.1  鹬蚌相争：死锁	273
7.1.1  死锁的检测	274
7.1.2  死锁产生的条件与规避	283
7.1.3  死锁的恢复	296
7.2  沉睡不醒的睡美人：锁死	301
7.2.1  信号丢失锁死	301
7.2.2  嵌套监视器锁死	301
7.3  巧妇难为无米之炊：线程饥饿	307
7.4  屡战屡败，屡败屡战：活锁	307
7.5  本章小结	308
第8章  线程管理	310
8.1  线程组	310
8.2  可靠性：线程的未捕获异常与监控	311
8.3  有组织有纪律：线程工厂	316
8.4  线程的暂挂与恢复	318
8.5  线程的高效利用：线程池	320
8.5.1  任务的处理结果、异常处理与取消	326
8.5.2  线程池监控	329
8.5.3  线程池死锁	330
8.5.4  工作者线程的异常终止	330
8.6  本章小结	331
第9章  Java异步编程	333
9.1  同步计算与异步计算	333
9.2  Java Executor框架	336
9.2.1  实用工具类Executors	337
9.2.2  异步任务的批量执行：CompletionService	339
9.3  异步计算助手：FutureTask	344
9.3.1  实践：实现XML文档的异步解析	345
9.3.2  可重复执行的异步任务	349
9.4  计划任务	352
9.5  本章小结	358
第10章  Java多线程程序的调试与测试	360
10.1  多线程程序的调试技巧	360
10.1.1  使用监视点	360
10.1.2  设置暂挂策略	361
10.2  多线程程序的测试	363
10.2.1  可测试性	364
10.2.2  静态检查工具：FindBugs	369
10.2.3  多线程程序的代码复审	370
10.2.4  多线程程序的单元测试：JCStress	372
10.3  本章小结	375
第二部分  多线程编程进阶
第11章  多线程编程的硬件基础与Java内存模型	378
11.1  填补处理器与内存之间的鸿沟：高速缓存	378
11.2  数据世界的交通规则：缓存一致性协议	382
11.3  硬件缓冲区：写缓冲器与无效化队列	386
11.3.1  存储转发	388
11.3.2  再探内存重排序	388
11.3.3  再探可见性	391
11.4  基本内存屏障	392
11.5  Java同步机制与内存屏障	395
11.5.1  volatile关键字的实现	395
11.5.2  synchronized关键字的实现	397
11.5.3  Java虚拟机对内存屏障使用的优化	398
11.5.4  final关键字的实现	398
11.6  Java内存模型	399
11.6.1  什么是Java内存模型	400
11.6.2  happen(s)-before关系	401
11.6.3  再探对象的安全发布	407
11.6.4  JSR 133	411
11.7  共享变量与性能	411
11.8  本章小结	411
第12章  Java多线程程序的性能调校	415
12.1  Java虚拟机对内部锁的优化	415
12.1.1  锁消除	415
12.1.2  锁粗化	417
12.1.3  偏向锁	419
12.1.4  适应性锁	420
12.2  优化对锁的使用	421
12.2.1  锁的开销与锁争用监视	421
12.2.2  使用可参数化锁	424
12.2.3  减小临界区的长度	428
12.2.4  减小锁的粒度	432
12.2.5  考虑锁的替代品	438
12.3  减少系统内耗：上下文切换	438
12.4  多线程编程的“三十六计”：多线程设计模式	440
12.5  性能的隐形杀手：伪共享	441
12.5.1  Java对象内存布局	442
12.5.2  伪共享的侦测与消除	445
12.6  本章小结	454
Web参考资源	457
参考文献	463
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程实战指南（核心篇）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE互联网轻量级框架整合开发
第1部分  入门和技术基础
第1章  认识SSM框架和Redis	2
1.1  Spring框架	2
1.1.1  Spring IoC简介	2
1.1.2  Spring AOP	4
1.2  MyBatis简介	6
1.2.1  Hibernate简介	7
1.2.2  MyBatis	8
1.2.3  Hibernate和MyBatis的区别	11
1.3  Spring MVC简介	11
1.4  最流行的NoSQL——Redis	12
1.5  SSM+Redis结构框图及概述	13
第2章  Java设计模式	15
2.1  Java反射技术	15
2.1.1  通过反射构建对象	15
2.1.2  反射方法	17
2.1.3  实例	18
2.2  动态代理模式和责任链模式	19
2.2.1  JDK动态代理	20
2.2.2  CGLIB动态代理	22
2.2.3  拦截器	24
2.2.4  责任链模式	28
2.3  观察者（Observer）模式	30
2.3.1  概述	31
2.3.2  实例	32
2.4  工厂模式和抽象工厂模式	35
2.4.1  普通工厂（Simple Factory）模式	35
2.4.2  抽象工厂（Abstract Factory）模式	36
2.5  建造者（Builder）模式	38
2.5.1  概述	38
2.5.2  Builder模式实例	39
2.6  总结	41
第2部分  互联网持久框架——MyBatis
第3章  认识MyBatis核心组件	44
3.1  持久层的概念和MyBatis的特点	44
3.2  准备MyBatis环境	45
3.3  MyBatis的核心组件	46
3.4  SqlSessionFactory（工厂接口）	47
3.4.1  使用XML构建SqlSessionFactory	48
3.4.2  使用代码创建SqlSessionFactory	50
3.5  SqlSession	50
3.6  映射器	51
3.6.1  用XML实现映射器	52
3.6.2  注解实现映射器	53
3.6.3  SqlSession发送SQL	54
3.6.4  用Mapper接口发送SQL	55
3.6.5  对比两种发送SQL方式	55
3.7  生命周期	55
3.7.1  SqlSessionFactoryBuilder	56
3.7.2  SqlSessionFactory	56
3.7.3  SqlSession	56
3.7.4  Mapper	56
3.8  实例	57
第4章  MyBatis配置	63
4.1  概述	63
4.2  properties属性	64
4.2.1  property子元素	64
4.2.2  使用properties文件	65
4.2.3  使用程序传递方式传递参数	66
4.2.4  总结	66
4.3  settings设置	66
4.4  typeAliases别名	69
4.4.1  系统定义别名	69
4.4.2  自定义别名	72
4.5  typeHandler类型转换器	72
4.5.1  系统定义的typeHandler	73
4.5.2  自定义typeHandler	78
4.5.3  枚举typeHandler	81
4.5.4  文件操作	86
4.6  ObjectFactory（对象工厂）	87
4.7  插件	89
4.8  environments（运行环境）	89
4.8.1  transactionManager（事务管理器）	90
4.8.2  environment数据源环境	92
4.9  databaseIdProvider数据库厂商标识	95
4.9.1  使用系统默认的databaseIdProvider	95
4.9.2  不使用系统规则	98
4.10  引入映射器的方法	99
第5章  映射器	102
5.1  概述	102
5.2  select元素——查询语句	103
5.2.1  简单的select元素的应用	104
5.2.2  自动映射和驼峰映射	105
5.2.3  传递多个参数	106
5.2.4  使用resultMap映射结果集	109
5.2.5  分页参数RowBounds	110
5.3  insert元素——插入语句	112
5.3.1  概述	112
5.3.2  简单的insert语句的应用	113
5.3.3  主键回填	113
5.3.4  自定义主键	114
5.4  update元素和delete元素	114
5.5  sql元素	115
5.6  参数	116
5.6.1  概述	116
5.6.2  存储过程参数支持	117
5.6.3  特殊字符串的替换和处理（#和$）	117
5.7  resultMap元素	118
5.7.1  resultMap元素的构成	118
5.7.2  使用map存储结果集	119
5.7.3  使用POJO存储结果集	119
5.8  级联	120
5.8.1  MyBatis中的级联	121
5.8.2  建立POJO	124
5.8.3  配置映射文件	127
5.8.4  N+1问题	133
5.8.5  延迟加载	133
5.8.6  另一种级联	137
5.8.7  多对多级联	140
5.9  缓存	143
5.9.1  一级缓存和二级缓存	144
5.9.2  缓存配置项、自定义和引用	147
5.10  存储过程	149
5.10.1  IN和OUT参数存储过程	150
5.10.2  游标的使用	152
第6章  动态SQL	155
6.1  概述	155
6.2  if元素	156
6.3  choose、when、otherwise元素	156
6.4  trim、where、set元素	157
6.5  foreach元素	159
6.6  用test的属性判断字符串	159
6.7  bind元素	160
第7章  MyBatis的解析和运行原理	162
7.1  构建SqlSessionFactory过程	163
7.1.1  构建Configuration	165
7.1.2  构建映射器的内部组成	165
7.1.3  构建SqlSessionFactory	167
7.2  SqlSession运行过程	168
7.2.1  映射器（Mapper）的动态代理	168
7.2.2  SqlSession下的四大对象	172
7.2.3  SqlSession运行总结	179
第8章  插件	181
8.1  插件接口	181
8.2  插件的初始化	182
8.3  插件的代理和反射设计	183
8.4  常用的工具类——MetaObject	186
8.5  插件开发过程和实例	187
8.5.1  确定需要拦截的签名	187
8.5.2  实现拦截方法	189
8.5.3  配置和运行	191
8.5.4  插件实例——分页插件	192
8.6  总结	205
第3部分  Spring基础
第9章  Spring IoC的概念	208
9.1  Spring的概述	208
9.2  Spring IoC概述	210
9.2.1  主动创建对象	211
9.2.2  被动创建对象	213
9.2.3  Spring IoC阐述	214
9.3  Spring IoC容器	215
9.3.1  Spring IoC容器的设计	215
9.3.2  Spring IoC容器的初始化和依赖注入	218
9.3.3  Spring Bean的生命周期	219
9.4  小结	223
第10章  装配Spring Bean	224
10.1  依赖注入的3种方式	224
10.1.1  构造器注入	224
10.1.2  使用setter注入	225
10.1.3  接口注入	226
10.2  装配Bean概述	227
10.3  通过XML配置装配Bean	228
10.3.1  装配简易值	228
10.3.2  装配集合	229
10.3.3  命名空间装配	233
10.4  通过注解装配Bean	235
10.4.1  使用@Component装配Bean	236
10.4.2  自动装配——@Autowired	239
10.4.3  自动装配的歧义性（@Primary和@Qualifier）	241
10.4.4  装载带有参数的构造方法类	244
10.4.5  使用@Bean装配Bean	245
10.4.6  注解自定义Bean的初始化和销毁方法	245
10.5  装配的混合使用	246
10.6  使用Profile	249
10.6.1  使用注解@Profile配置	249
10.6.2  使用XML定义Profile	250
10.6.3  启动Profile	252
10.7  加载属性（properties）文件	254
10.7.1  使用注解方式加载属性文件	254
10.7.2  使用XML方式加载属性文件	257
10.8  条件化装配Bean	258
10.9  Bean的作用域	259
10.10  使用Spring表达式（Spring EL）	261
10.10.1  Spring EL相关的类	261
10.10.2  Bean的属性和方法	264
10.10.3  使用类的静态常量和方法	265
10.10.4  Spring EL运算	265
第11章  面向切面编程	267
11.1  一个简单的约定游戏	267
11.1.1  约定规则	267
11.1.2  读者的代码	269
11.1.3  笔者的代码	271
11.2  Spring AOP的基本概念	274
11.2.1  AOP的概念和使用原因	274
11.2.2  面向切面编程的术语	278
11.2.3  Spring对AOP的支持	280
11.3  使用@AspectJ注解开发Spring AOP	280
11.3.1  选择切点	281
11.3.2  创建切面	281
11.3.3  连接点	283
11.3.4  测试AOP	285
11.3.5  环绕通知	287
11.3.6  织入	289
11.3.7  给通知传递参数	289
11.3.8  引入	290
11.4  使用XML配置开发Spring AOP	293
11.4.1  前置通知、后置通知、返回通知和异常通知	294
11.4.2  环绕通知	296
11.4.3  给通知传递参数	297
11.4.4  引入	298
11.5  经典Spring AOP应用程序	299
11.6  多个切面	301
11.7  小结	306
第12章  Spring和数据库编程	307
12.1  传统的JDBC代码的弊端	307
12.2  配置数据库资源	309
12.2.1  使用简单数据库配置	309
12.2.2  使用第三方数据库连接池	310
12.2.3  使用JNDI数据库连接池	310
12.3  JDBC代码失控的解决方案——jdbcTemplate	311
12.3.1  jdbcTemplate的增、删、查、改	312
12.3.2  执行多条SQL	314
12.3.3  jdbcTemplate的源码分析	315
12.4  MyBatis-Spring项目	317
12.4.1  配置SqlSessionFactoryBean	318
12.4.2  SqlSessionTemplate组件	322
12.4.3  配置MapperFactoryBean	324
12.4.4  配置MapperScannerConfigurer	324
12.4.5  测试Spring+MyBatis	327
第13章  深入Spring数据库事务管理	330
13.1  Spring数据库事务管理器的设计	331
13.1.1  配置事务管理器	333
13.1.2  用Java配置方式实现Spring数据库事务	334
13.2  编程式事务	336
13.3  声明式事务	337
13.3.1  Transactional的配置项	337
13.3.2  使用XML进行配置事务管理器	339
13.3.3  事务定义器	340
13.3.4  声明式事务的约定流程	341
13.4  数据库的相关知识	343
13.4.1  数据库事务ACID特性	343
13.4.2  丢失更新	343
13.4.3  隔离级别	344
13.5  选择隔离级别和传播行为	347
13.5.1  选择隔离级别	347
13.5.2  传播行为	348
13.6  在Spring+MyBatis组合中使用事务	350
13.7  @Transactional的自调用失效问题	358
13.8  典型错误用法的剖析	363
13.8.1  错误使用Service	363
13.8.2  过长时间占用事务	364
13.8.3  错误捕捉异常	366
第4部分  Spring MVC框架
第14章  Spring MVC的初始化和流程	370
14.1  MVC设计概述	370
14.1.1  Spring MVC的架构	372
14.1.2  Spring MVC组件与流程	372
14.1.3  Spring MVC入门的实例	374
14.2  Spring MVC初始化	378
14.2.1  初始化Spring IoC上下文	378
14.2.2  初始化映射请求上下文	379
14.2.3  使用注解配置方式初始化	386
14.3  Spring MVC开发流程详解	389
14.3.1  配置@RequestMapping	390
14.3.2  控制器的开发	391
14.3.3  视图渲染	396
14.4  小结	398
第15章  深入Spring MVC组件开发	399
15.1  控制器接收各类请求参数	399
15.1.1  接收普通请求参数	401
15.1.2  使用@RequestParam注解获取参数	402
15.1.3  使用URL传递参数	403
15.1.4  传递JSON参数	404
15.1.5  接收列表数据和表单序列化	406
15.2  重定向	409
15.3  保存并获取属性参数	412
15.3.1  注解@RequestAttribute	412
15.3.2  注解@SessionAttribute和注解@SessionAttributes	414
15.3.3  注解@CookieValue和注解@RequestHeader	417
15.4  拦截器	417
15.4.1  拦截器的定义	418
15.4.2  拦截器的执行流程	419
15.4.3  开发拦截器	419
15.4.4  多个拦截器执行的顺序	421
15.5  验证表单	424
15.5.1  使用JSR 303注解验证输入内容	425
15.5.2  使用验证器	429
15.6  数据模型	432
15.7  视图和视图解析器	434
15.7.1  视图	434
15.7.2  视图解析器	436
15.7.3  实例：Excel视图的使用	438
15.8  上传文件	441
15.8.1  MultipartResolver概述	442
15.8.2  提交上传文件表单	446
第16章  Spring MVC高级应用	449
16.1  Spring MVC的数据转换和格式化	449
16.1.1  HttpMessageConverter和JSON消息转换器	451
16.1.2  一对一转换器（Converter）	455
16.1.3  数组和集合转换器GenericConverter	458
16.1.4  使用格式化器（Formatter）	463
16.2  为控制器添加通知	466
16.3  处理异常	470
16.4  国际化	471
16.4.1  概述	471
16.4.2  MessageSource接口	473
16.4.3  CookieLocaleResolver和SessionLocaleResolver	475
16.4.4  国际化拦截器（LocaleChangeInterceptor）	477
16.4.5  开发国际化	477
第5部分  Redis应用
第17章  Redis概述	480
17.1  Redis在Java Web中的应用	481
17.1.1  缓存	481
17.1.2  高速读/写场合	482
17.2  Redis基本安装和使用	483
17.2.1  在Windows下安装Redis	483
17.2.2  在Linux下安装Redis	485
17.3  Redis的Java API	486
17.3.1  在Java程序中使用Redis	487
17.3.2  在Spring中使用Redis	488
17.4  简介Redis的6种数据类型	494
17.5  Redis和数据库的异同	495
第18章  Redis数据结构常用命令	496
18.1  Redis数据结构——字符串	497
18.2  Redis数据结构——哈希	502
18.3  Redis数据结构——链表（linked-list）	506
18.4  Redis数据结构——集合	513
18.5  Redis数据结构——有序集合	516
18.5.1  Redis基础命令	516
18.5.2  spring-data-redis对有序集合的封装	518
18.5.3  使用Spring操作有序集合	520
18.6  基数——HyperLogLog	522
18.7  小结	524
第19章  Redis的一些常用技术	525
19.1  Redis的基础事务	526
19.2  探索Redis事务回滚	528
19.3  使用watch命令监控事务	529
19.4  流水线（pipelined）	532
19.5  发布订阅	534
19.6  超时命令	538
19.7  使用Lua语言	540
19.7.1  执行输入Lua程序代码	541
19.7.2  执行Lua文件	544
19.8  小结	547
第20章  Redis配置	548
20.1  Redis基础配置文件	548
20.2  Redis备份（持久化）	549
20.3  Redis内存回收策略	552
20.4  复制	553
20.4.1  主从同步基础概念	553
20.4.2  Redis主从同步配置	554
20.4.3  Redis主从同步的过程	555
20.5  哨兵（Sentinel）模式	556
20.5.1  哨兵模式概述	557
20.5.2  搭建哨兵模式	558
20.5.3  在Java中使用哨兵模式	559
20.5.4  哨兵模式的其他配置项	563
第21章  Spring缓存机制和Redis的结合	565
21.1  Redis和数据库的结合	565
21.1.1  Redis和数据库读操作	566
21.1.2  Redis和数据库写操作	567
21.2  使用Spring缓存机制整合Redis	568
21.2.1  准备测试环境	568
21.2.2  Spring的缓存管理器	573
21.2.3  缓存注解简介	575
21.2.4  注解@Cacheable和@CachePut	576
21.2.5  注解@CacheEvict	580
21.2.6  不适用缓存的方法	581
21.2.7  自调用失效问题	582
21.3  RedisTemplate的实例	582
第6部分  SSM框架+Redis实践应用
第22章  高并发业务	586
22.1  互联系统应用架构基础分析	586
22.2  高并发系统的分析和设计	588
22.2.1  有效请求和无效请求	588
22.2.2  系统设计	590
22.2.3  数据库设计	591
22.2.4  动静分离技术	593
22.2.5  锁和高并发	594
22.3  搭建抢红包开发环境和超发现象	595
22.3.1  搭建Service层和DAO层	595
22.3.2  使用全注解搭建SSM开发环境	602
22.3.3  开发控制器和超发现象测试	609
22.4  悲观锁	611
22.5  乐观锁	614
22.5.1  CAS原理概述	614
22.5.2  ABA问题	615
22.5.3  乐观锁实现抢红包业务	616
22.5.4  乐观锁重入机制	618
22.6  使用Redis实现抢红包	621
22.6.1  使用注解方式配置Redis	621
22.6.2  数据存储设计	622
22.6.3  使用Redis实现抢红包	627
22.7  各类方式的优缺点	631
附录A  数据库表模型	633
附录B  DispatcherServlet流程源码分析	637
附录C  JSTL常用标签	648
附录D  spring data redis项目分析	660
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE互联网轻量级框架整合开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实战Java高并发程序设计（第2版）
第1章  走入并行世界  1
1.1  何去何从的并行计算  1
1.1.1  忘掉那该死的并行  2
1.1.2  可怕的现实：摩尔定律的失效  4
1.1.3  柳暗花明：不断地前进  5
1.1.4  光明或是黑暗  6
1.2  你必须知道的几个概念  7
1.2.1  同步（Synchronous）和异步（Asynchronous）  7
1.2.2  并发（Concurrency）和并行（Parallelism）  8
1.2.3  临界区  9
1.2.4  阻塞（Blocking）和非阻塞（Non-Blocking）  9
1.2.5  死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock）  10
1.3  并发级别  11
1.3.1  阻塞  11
1.3.2  无饥饿（Starvation-Free）  11
1.3.3  无障碍（Obstruction-Free）  12
1.3.4  无锁（Lock-Free）  13
1.3.5  无等待（Wait-Free）  13
1.4  有关并行的两个重要定律  14
1.4.1  Amdahl定律  14
1.4.2  Gustafson定律  16
1.4.3  是否相互矛盾  17
1.5  回到Java：JMM  18
1.5.1  原子性（Atomicity）  18
1.5.2  可见性（Visibility）  20
1.5.3  有序性（Ordering）  22
1.5.4  哪些指令不能重排：Happen-Before规则  27
第2章  Java并行程序基础  29
2.1  有关线程你必须知道的事  29
2.2  初始线程：线程的基本操作  32
2.2.1  新建线程  32
2.2.2  终止线程  34
2.2.3  线程中断  38
2.2.4  等待（wait）和通知（notify）  41
2.2.5  挂起（suspend）和继续执行（resume）线程  45
2.2.6  等待线程结束（join）和谦让（yeild）  49
2.3  volatile与Java内存模型（JMM）  50
2.4  分门别类的管理：线程组  53
2.5  驻守后台：守护线程（Daemon）  54
2.6  先做重要的事：线程优先级  56
2.7  线程安全的概念与关键字synchronized  57
2.8  程序中的幽灵：隐蔽的错误  61
2.8.1  无提示的错误案例  62
2.8.2  并发下的ArrayList  63
2.8.3  并发下诡异的HashMap  64
2.8.4  初学者常见的问题：错误的加锁  67
第3章  JDK并发包  71
3.1  多线程的团队协作：同步控制  71
3.1.1  关键字synchronized的功能扩展：重入锁  72
3.1.2  重入锁的好搭档：Condition  81
3.1.3  允许多个线程同时访问：信号量（Semaphore）  85
3.1.4  ReadWriteLock读写锁  86
3.1.5  倒计数器：CountDownLatch  89
3.1.6  循环栅栏：CyclicBarrier  91
3.1.7  线程阻塞工具类：LockSupport  94
3.1.8  Guava和RateLimiter限流  98
3.2  线程复用：线程池  101
3.2.1  什么是线程池  102
3.2.2  不要重复发明轮子：JDK对线程池的支持  102
3.2.3  刨根究底：核心线程池的内部实现  108
3.2.4  超负载了怎么办：拒绝策略  112
3.2.5  自定义线程创建：ThreadFactory  115
3.2.6  我的应用我做主：扩展线程池  116
3.2.7  合理的选择：优化线程池线程数量  119
3.2.8  堆栈去哪里了：在线程池中寻找堆栈  120
3.2.9  分而治之：Fork/Join框架  124
3.2.10  Guava中对线程池的扩展  128
3.3  不要重复发明轮子：JDK的并发容器  130
3.3.1  超好用的工具类：并发集合简介  130
3.3.2  线程安全的HashMap  131
3.3.3  有关List的线程安全  132
3.3.4  高效读写的队列：深度剖析ConcurrentLinkedQueue类  132
3.3.5  高效读取：不变模式下的CopyOnWriteArrayList类  138
3.3.6  数据共享通道：BlockingQueue  139
3.3.7  随机数据结构：跳表（SkipList）  144
3.4  使用JMH进行性能测试  146
3.4.1  什么是JMH  147
3.4.2  Hello JMH  147
3.4.3  JMH的基本概念和配置  150
3.4.4  理解JMH中的Mode  151
3.4.5  理解JMH中的State  153
3.4.6  有关性能的一些思考  154
3.4.7  CopyOnWriteArrayList类与ConcurrentLinkedQueue类  157
第4章  锁的优化及注意事项  161
4.1  有助于提高锁性能的几点建议  162
4.1.1  减少锁持有时间  162
4.1.2  减小锁粒度  163
4.1.3  用读写分离锁来替换独占锁  165
4.1.4  锁分离  165
4.1.5  锁粗化  168
4.2  Java虚拟机对锁优化所做的努力  169
4.2.1  锁偏向  169
4.2.2  轻量级锁  169
4.2.3  自旋锁  170
4.2.4  锁消除  170
4.3  人手一支笔：ThreadLocal  171
4.3.1  ThreadLocal的简单使用  171
4.3.2  ThreadLocal的实现原理  173
4.3.3  对性能有何帮助  179
4.4  无锁  182
4.4.1  与众不同的并发策略：比较交换  182
4.4.2  无锁的线程安全整数：AtomicInteger  183
4.4.3  Java中的指针：Unsafe类  185
4.4.4  无锁的对象引用：AtomicReference  187
4.4.5  带有时间戳的对象引用：AtomicStampedReference  190
4.4.6  数组也能无锁：AtomicIntegerArray  193
4.4.7  让普通变量也享受原子操作：AtomicIntegerFieldUpdater  194
4.4.8  挑战无锁算法：无锁的Vector实现  196
4.4.9  让线程之间互相帮助：细看SynchronousQueue的实现  201
4.5  有关死锁的问题  205
第5章  并行模式与算法  209
5.1  探讨单例模式  209
5.2  不变模式  213
5.3  生产者-消费者模式  215
5.4  高性能的生产者-消费者模式：无锁的实现  220
5.4.1  无锁的缓存框架：Disruptor  221
5.4.2  用Disruptor框架实现生产者-消费者模式的案例  222
5.4.3  提高消费者的响应时间：选择合适的策略  225
5.4.4  CPU Cache的优化：解决伪共享问题  226
5.5  Future模式  230
5.5.1  Future模式的主要角色  232
5.5.2  Future模式的简单实现  233
5.5.3  JDK中的Future模式  236
5.5.4  Guava对Future模式的支持  238
5.6  并行流水线  240
5.7  并行搜索  244
5.8  并行排序  246
5.8.1  分离数据相关性：奇偶交换排序  246
5.8.2  改进的插入排序：希尔排序  250
5.9  并行算法：矩阵乘法  254
5.10  准备好了再通知我：网络NIO  258
5.10.1  基于Socket的服务端多线程模式  259
5.10.2  使用NIO进行网络编程  264
5.10.3  使用NIO来实现客户端  272
5.11  读完了再通知我：AIO  274
5.11.1  AIO EchoServer的实现  275
5.11.2  AIO Echo客户端的实现  277
第6章  Java 8/9/10与并发  281
6.1  Java 8的函数式编程简介  281
6.1.1  函数作为一等公民  282
6.1.2  无副作用  283
6.1.3  声明式的（Declarative）  283
6.1.4  不变的对象  284
6.1.5  易于并行  284
6.1.6  更少的代码  284
6.2  函数式编程基础  285
6.2.1  FunctionalInterface注释  285
6.2.2  接口默认方法  286
6.2.3  lambda表达式  290
6.2.4  方法引用  291
6.3  一步一步走入函数式编程  293
6.4  并行流与并行排序  298
6.4.1  使用并行流过滤数据  298
6.4.2  从集合得到并行流  299
6.4.3  并行排序  299
6.5  增强的Future：CompletableFuture  300
6.5.1  完成了就通知我  300
6.5.2  异步执行任务  301
6.5.3  流式调用  303
6.5.4  CompletableFuture中的异常处理  303
6.5.5  组合多个CompletableFuture  304
6.5.6  支持timeout的 CompletableFuture  306
6.6  读写锁的改进：StampedLock  306
6.6.1  StampedLock使用示例  307
6.6.2  StampedLock的小陷阱  308
6.6.3  有关StampedLock的实现思想  310
6.7  原子类的增强  313
6.7.1  更快的原子类：LongAdder  314
6.7.2  LongAdder功能的增强版：LongAccumulator  320
6.8  ConcurrentHashMap的增强  321
6.8.1  foreach操作  321
6.8.2  reduce操作  321
6.8.3  条件插入  322
6.8.4  search操作  323
6.8.5  其他新方法  324
6.9  发布和订阅模式  324
6.9.1  简单的发布订阅例子  326
6.9.2  数据处理链  328
第7章  使用Akka构建高并发程序  331
7.1  新并发模型：Actor  332
7.2  Akka之Hello World  332
7.3  有关消息投递的一些说明  336
7.4  Actor的生命周期  337
7.5  监督策略  341
7.6  选择Actor  346
7.7  消息收件箱（Inbox）  346
7.8  消息路由  348
7.9  Actor的内置状态转换  351
7.10  询问模式：Actor中的Future  354
7.11  多个Actor同时修改数据：Agent  356
7.12  像数据库一样操作内存数据：软件事务内存  359
7.13  一个有趣的例子：并发粒子群的实现  363
7.13.1  什么是粒子群算法  364
7.13.2  粒子群算法的计算过程  364
7.13.3  粒子群算法能做什么  366
7.13.4  使用Akka实现粒子群  367
第8章  并行程序调试  375
8.1  准备实验样本  375
8.2  正式起航  376
8.3  挂起整个虚拟机  379
8.4  调试进入ArrayList内部  380
第9章  多线程优化示例—Jetty核心代码分析  385
9.1  Jetty简介与架构  385
9.2  Jetty服务器初始化  387
9.2.1  初始化线程池  387
9.2.2  初始化ScheduledExecutorScheduler  389
9.2.3  初始化ByteBufferPool  390
9.2.4  维护ConnectionFactory  393
9.2.5  计算ServerConnector的线程数量  394
9.3  启动Jetty服务器  394
9.3.1  设置启动状态  394
9.3.2  注册ShutdownMonitor  395
9.3.3  计算系统的线程数量  395
9.3.4  启动QueuedThreadPool  396
9.3.5  启动Connector  396
9.4  处理HTTP请求  399
9.4.1  Accept成功  399
9.4.2  请求处理  401
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实战Java高并发程序设计（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程实战指南（设计模式篇）
1章  Java多线程编程实战基础	1
1.1  无处不在的线程	1
1.2  线程的创建与运行	2
1.3  线程的状态与上下文切换	5
1.4  线程的监视	7
1.5  原子性、内存可见性和重排序——重新认识synchronized和volatile	10
1.6  线程的优势和风险	11
1.7  多线程编程常用术语	13
第2章  设计模式简介	17
2.1  设计模式及其作用	17
2.2  多线程设计模式简介	20
2.3  设计模式的描述	21
第3章  Immutable Object（不可变对象）模式	23
3.1  Immutable Object模式简介	23
3.2  Immutable Object模式的架构	25
3.3  Immutable Object模式实战案例	27
3.4  Immutable Object模式的评价与实现考量	31
3.5  Immutable Object模式的可复用实现代码	32
3.6  Java标准库实例	32
3.7  相关模式	34
3.7.1  Thread Specific Storage模式（第10章）	34
3.7.2  Serial Thread Confinement模式（第11章）	34
3.8  参考资源	34
第4章  Guarded Suspension（保护性暂挂）模式	35
4.1  Guarded Suspension模式简介	35
4.2  Guarded Suspension模式的架构	35
4.3  Guarded Suspension模式实战案例解析	39
4.4  Guarded Suspension模式的评价与实现考量	45
4.4.1  内存可见性和锁泄漏（Lock Leak）	46
4.4.2  线程过早被唤醒	46
4.4.3  嵌套监视器锁死	47
4.5  Guarded Suspension模式的可复用实现代码	50
4.6  Java标准库实例	50
4.7  相关模式	51
4.7.1  Promise模式（第6章）	51
4.7.2  Producer-Consumer模式（第7章）	51
4.8  参考资源	51
第5章  Two-phase Termination（两阶段终止）模式	52
5.1  Two-phase Termination模式简介	52
5.2  Two-phase Termination模式的架构	53
5.3  Two-phase Termination模式实战案例	56
5.4  Two-phase Termination模式的评价与实现考量	63
5.4.1  线程停止标志	63
5.4.2  生产者-消费者问题中的线程停止	64
5.4.3  隐藏而非暴露可停止的线程	65
5.5  Two-phase Termination模式的可复用实现代码	65
5.6  Java标准库实例	66
5.7  相关模式	66
5.7.1  Producer-Consumer模式（第7章）	66
5.7.2  Master-Slave模式（第12章）	66
5.8  参考资源	66
第6章  Promise（承诺）模式	67
6.1  Promise模式简介	67
6.2  Promise模式的架构	68
6.3  Promise模式实战案例解析	70
6.4  Promise模式的评价与实现考量	74
6.4.1  异步方法的异常处理	75
6.4.2  轮询（Polling）	75
6.4.3  异步任务的执行	75
6.5  Promise模式的可复用实现代码	77
6.6  Java标准库实例	77
6.7  相关模式	78
6.7.1  Guarded Suspension模式（第4章）	78
6.7.2  Active Object模式（第8章）	78
6.7.3  Master-Slave模式（第12章）	78
6.7.4  Factory Method模式	78
6.8  参考资源	79
第7章  Producer-Consumer（生产者/消费者）模式	80
7.1  Producer-Consumer模式简介	80
7.2  Producer-Consumer模式的架构	80
7.3  Producer-Consumer模式实战案例解析	83
7.4  Producer-Consumer模式的评价与实现考量	87
7.4.1  通道积压	87
7.4.2  工作窃取算法	88
7.4.3  线程的停止	92
7.4.4  高性能高可靠性的Producer-Consumer模式实现	92
7.5  Producer-Consumer模式的可复用实现代码	92
7.6  Java标准库实例	93
7.7  相关模式	93
7.7.1  Guarded Suspension模式（第4章）	93
7.7.2  Thread Pool模式（第9章）	93
7.8  参考资源	93
第8章  Active Object（主动对象）模式	94
8.1  Active Object模式简介	94
8.2  Active Object模式的架构	95
8.3  Active Object模式实战案例解析	98
8.4  Active Object模式的评价与实现考量	105
8.4.1  错误隔离	107
8.4.2  缓冲区监控	108
8.4.3  缓冲区饱和处理策略	108
8.4.4  Scheduler空闲工作者线程清理	109
8.5  Active Object模式的可复用实现代码	109
8.6  Java标准库实例	111
8.7  相关模式	112
8.7.1  Promise模式（第6章）	112
8.7.2  Producer-Consumer模式（第7章）	112
8.8  参考资源	112
第9章  Thread Pool（线程池）模式	113
9.1  Thread Pool模式简介	113
9.2  Thread Pool模式的架构	114
9.3  Thread Pool模式实战案例解析	116
9.4  Thread Pool模式的评价与实现考量	117
9.4.1  工作队列的选择	118
9.4.2  线程池大小调校	119
9.4.3  线程池监控	121
9.4.4  线程泄漏	122
9.4.5  可靠性与线程池饱和处理策略	122
9.4.6  死锁	125
9.4.7  线程池空闲线程清理	126
9.5  Thread Pool模式的可复用实现代码	127
9.6  Java标准库实例	127
9.7  相关模式	127
9.7.1  Two-phase Termination模式（第5章）	127
9.7.2  Promise模式（第6章）	127
9.7.3  Producer-Consumer模式（第7章）	127
9.8  参考资源	128
第10章  Thread Specific Storage（线程特有存储）模式	129
10.1  Thread Specific Storage模式简介	129
10.2  Thread Specific Storage模式的架构	131
10.3  Thread Specific Storage模式实战案例解析	133
10.4  Thread Specific Storage模式的评价与实现考量	135
10.4.1  线程池环境下使用Thread Specific Storage模式	138
10.4.2  内存泄漏与伪内存泄漏	139
10.5  Thread Specific Storage模式的可复用实现代码	145
10.6  Java标准库实例	146
10.7  相关模式	146
10.7.1  Immutable Object模式（第3章）	146
10.7.2  Proxy（代理）模式	146
10.7.3  Singleton（单例）模式	146
10.8  参考资源	147
第11章  Serial Thread Confinement（串行线程封闭）模式	148
11.1  Serial Thread Confinement模式简介	148
11.2  Serial Thread Confinement模式的架构	148
11.3  Serial Thread Confinement模式实战案例解析	151
11.4  Serial Thread Confinement模式的评价与实现考量	155
11.4.1  任务的处理结果	155
11.5  Serial Thread Confinement模式的可复用实现代码	156
11.6  Java标准库实例	160
11.7  相关模式	160
11.7.1  Immutable Object模式（第3章）	160
11.7.2  Promise模式（第6章）	160
11.7.3  Producer-Consumer模式（第7章）	160
11.7.4  Thread Specific Storage（线程特有存储）模式 （第10章）	161
11.8  参考资源	161
第12章  Master-Slave（主仆）模式	162
12.1  Master-Slave模式简介	162
12.2  Master-Slave模式的架构	162
12.3  Master-Slave模式实战案例解析	164
12.4  Master-Slave模式的评价与实现考量	171
12.4.1  子任务的处理结果的收集	172
12.4.2  Slave参与者实例的负载均衡与工作窃取	173
12.4.3  可靠性与异常处理	173
12.4.4  Slave线程的停止	174
12.5  Master-Slave模式的可复用实现代码	174
12.6  Java标准库实例	186
12.7  相关模式	186
12.7.1  Two-phase Termination模式（第5章）	186
12.7.2  Promise模式（第6章）	186
12.7.3  Strategy（策略）模式	186
12.7.4  Template（模板）模式	186
12.7.5  Factory Method（工厂方法）模式	186
12.8  参考资源	187
第13章  Pipeline（流水线）模式	188
13.1  Pipeline模式简介	188
13.2  Pipeline模式的架构	189
13.3  Pipeline模式实战案例解析	194
13.4  Pipeline模式的评价与实现考量	208
13.4.1  Pipeline的深度	209
13.4.2  基于线程池的Pipe	209
13.4.3  错误处理	212
13.4.4  可配置的Pipeline	212
13.5  Pipeline模式的可复用实现代码	212
13.6  Java标准库实例	222
13.7  相关模式	222
13.7.1  Serial Thread Confinement模式（第11章）	222
13.7.2  Master-Slave模式（第12章）	222
13.7.3  Composite模式	223
13.8  参考资源	223
第14章  Half-sync/Half-async（半同步/半异步）模式	224
14.1  Half-sync/Half-async模式简介	224
14.2  Half-sync/Half-async模式的架构	224
14.3  Half-sync/Half-async模式实战案例解析	226
14.4  Half-sync/Half-async模式的评价与实现考量	234
14.4.1  队列积压	235
14.4.2  避免同步层处理过慢	235
14.5  Half-sync/Half-async模式的可复用实现代码	236
14.6  Java标准库实例	240
14.7  相关模式	240
14.7.1  Two-phase Termination模式（第5章）	240
14.7.2  Producer-Consumer模式（第7章）	241
14.7.3  Active Object模式（第8章）	241
14.7.4  Thread Pool模式（第9章）	241
14.8  参考资源	241
第15章  模式语言	242
15.1  模式与模式间的联系	242
15.2  mmutable Object（不可变对象）模式	244
15.3  Guarded Suspension（保护性暂挂）模式	244
15.4  Two-phase Termination（两阶段终止）模式	245
15.5  Promise（承诺）模式	246
15.6  Producer-Consumer（生产者/消费者）模式	247
15.7  Active Object（主动对象）模式	248
15.8  Thread Pool（线程池）模式	249
15.9  Thread Specific Storage（线程特有存储）模式	250
15.10  Serial Thread Confinement（串行线程封闭）模式	251
15.11  Master-Slave（主仆）模式	252
15.12  Pipeline（流水线）模式	253
15.13  Half-sync/Half-async（半同步/半异步）模式	254
附录  本书常用UML图指南	255
A.1  UML简介	255
A.2  类图（Class Diagram）	256
A.1.1  类的属性、方法和立体型（Stereotype）	256
A.1.2  类与类之间的关系	258
A.3  序列图（Sequence Diagram）	261
参考文献	263
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程实战指南（设计模式篇）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java数据结构和算法
出版说明
献
词
简
介
第1章  综述
数据结构和算法能起到什么作用
数据结构的概述
算法的概述

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java数据结构和算法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala程序设计
第1章 简介	1
1.1 为何选择Scala	1
1.2 何为Scala	3
1.3 函数式编程	7
1.4 本书的内容	9
1.5 本书面向的读者	11
1.6 致谢	11
第2章 起步	13
2.1 下载Scala	13
2.2 安装Scala	13
2.2.1 在Windows上安装Scala	14
2.2.2 在类UNIX系统上安装Scala	14
2.3 让Scala跑起来	15
2.4 命令行上的Scala	16
2.5 把Scala代码当作脚本运行	17
2.5.1 在类UNIX系统上作为脚本运行	17
2.5.2 在Windows上作为脚本运行	18
2.6 在IDE里面运行Scala	18
2.7 编译Scala	19
第3章 Scala步入正轨	20
3.1 把Scala当作简洁的Java	20
3.2 Java基本类型对应的Scala类	23
3.3 元组与多重赋值	23
3.4 字符串与多行原始字符串	25
3.5 自适应的默认做法	26
3.6 运算符重载	27
3.7 Scala带给Java程序员的惊奇	29
3.7.1 赋值的结果	29
3.7.2 Scala的==	30
3.7.3 分号是半可选的	31
3.7.4 默认的访问修饰符	32
3.7.5 默认的访问修饰符以及如何修改	32
3.7.6 Scala的Protected	33
3.7.7 细粒度访问控制	34
3.7.8 避免显式return	35
第4章 Scala的类	37
4.1 创建类	37
4.2 定义字段、方法和构造函数	38
4.3 类继承	41
4.4 单例对象	42
4.5 独立对象和伴生对象	43
4.6 Scala中的static	44
第5章 自适应类型	46
5.1 容器和类型推演	47
5.2 Any类型	49
5.3 关于Nothing的更多情况	50
5.4 Option类型	50
5.5 方法返回类型推演	51
5.6 传递变参	52
5.7 参数化类型的可变性	53
第6章 函数值和闭包	57
6.1 从普通函数迈向高阶函数	57
6.2 函数值	58
6.3 具有多参数的函数值	59
6.4 Curry化	61
6.5 重用函数值	62
6.6 参数的位置记法	64
6.7 Execute Around Method模式	65
6.8 偏应用函数	67
6.9 闭包	68
第7章 Trait和类型转换	70
7.1 Trait	70
7.2 选择性混入	72
7.3 以trait进行装饰	74
7.4 Trait方法的延迟绑定	75
7.5 隐式类型转换	77
第8章 使用容器	81
8.1 常见的Scala容器	81
8.2 使用Set	82
8.3 使用Map	83
8.4 使用List	85
8.5 for表达式	90
第9章 模式匹配和正则表达式	93
9.1 匹配字面量和常量	93
9.2 匹配通配符	94
9.3 匹配元组和列表	94
9.4 类型和卫述句的匹配	96
9.5 case表达式里的模式变量和常量	96
9.6 对XML片段进行模式匹配	98
9.7 使用case类进行模式匹配	98
9.8 使用提取器进行匹配	100
9.9 正则表达式	103
9.10 把正则表达式当做提取器	104
第10章 并发编程	106
10.1 促进不变性	106
10.2 使用Actor的并发	107
10.3 消息传递	110
10.4 Actor类	113
10.5 actor方法	115
10.6 receive和receiveWithin方法	117
10.7 react和reactWithin方法	120
10.8 loop和loopWhile	124
10.9 控制线程执行	125
10.10 在各种接收方法中选择	127
第11章 与Java互操作	128
11.1 在Scala里使用Scala类	128
11.2 在Scala里使用Java类	130
11.3 在Java里使用Scala类	132
11.3.1 有普通函数和高阶函数的Scala类	132
11.3.2 同trait一起工作	134
11.3.3 单例对象和伴生对象	134
11.4 继承类	136
第12章 用Scala做单元测试	138
12.1 使用JUnit	138
12.2 使用ScalaTest	139
12.3 以Canary测试开始	140
12.4 使用Runner	140
12.5 Asserts	142
12.6 异常测试	144
12.7 在测试间共享代码	146
12.7.1 用BeforeAndAfter共享代码	146
12.7.2 用闭包共享代码	147
12.8 FunSuite的函数式风格	148
12.9 用JUnit运行ScalaTest	149
第13章 异常处理	152
13.1 异常处理	152
13.2 注意catch顺序	154
第14章 使用Scala	156
14.1 净资产应用实例	156
14.2 获取用户输入	156
14.3 读写文件	157
14.4 XML，作为一等公民	159
14.5 读写XML	161
14.6 从Web获取股票价格	164
14.7 让净资产应用并发	167
14.8 为净资产应用增加GUI	168
附录A Web资源	178
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序性能优化
第1章 Java性能调优概述
1.1 性能概述
1.1.1 看懂程序的性能
1.1.2 性能的参考指标
1.1.3 木桶原理与性能瓶颈
1.1.4 Amdahl定律
1.2 性能调优的层次
1.2.1 设计调优
1.2.2 代码调优
1.2.3 JVM调优
1.2.4 数据库调优
1.2.5 操作系统调优
1.3 基本调优策略和手段
1.3.1 优化的一般步骤
1.3.2 系统优化注意事项
1.4 小结
第2章 设计优化
2.1 善用设计模式
2.1.1 单例模式
2.1.2 代理模式
2.1.3 享元模式
2.1.4 装饰者模式
2.1.5 观察者模式
2.1.6 Value Object模式
2.1.7 业务代理模式
2.2 常用优化组件和方法
2.2.1 缓冲（Buffer）
2.2.2 缓存（Cache）
2.2.3 对象复用——“池”
2.2.4 并行替代串行
2.2.5 负载均衡
2.2.6 时间换空间
2.2.7 空间换时间
2.3 小结
第3章 Java程序优化
3.1 字符串优化处理
3.1.1 String对象及其特点
3.1.2 subString()方法的内存泄漏
3.1.3 字符串分割和查找
3.1.4 StringBuffer和StringBuilder
3.2 核心数据结构
3.2.1 List接口
3.2.2 Map接口
3.2.3 Set接口
3.2.4 优化集合访问代码
3.2.5 RandomAccess接口
3.3 使用NIO提升性能
3.3.1 NIO的Buffer类族和Channel
3.3.2 Buffer的基本原理
3.3.3 Buffer的相关操作
3.3.4 MappedByteBuffer性能评估
3.3.5 直接内存访问
3.4 引用类型
3.4.1 强引用
3.4.2 软引用
3.4.3 弱引用
3.4.4 虚引用
3.4.5 WeakHashMap类及其实现
3.5 有助于改善性能的技巧
3.5.1 慎用异常
3.5.2 使用局部变量
3.5.3 位运算代替乘除法
3.5.4 替换switch
3.5.5 一维数组代替二维数组
3.5.6 提取表达式
3.5.7 展开循环
3.5.8 布尔运算代替位运算
3.5.9 使用arrayCopy ()
3.5.10 使用Buffer进行I/O操作
3.5.11 使用clone()代替new
3.5.12 静态方法替代实例方法
3.6 小结
第4章 并行程序开发及优化
4.1 并行程序设计模式
4.1.1 Future模式
4.1.2 Master-Worker模式
4.1.3 Guarded Suspension模式
4.1.4 不变模式
4.1.5 生产者-消费者模式
4.2 JDK多任务执行框架
4.2.1 无限制线程的缺陷
4.2.2 简单的线程池实现
4.2.3 Executor框架
4.2.4 自定义线程池
4.2.5 优化线程池大小
4.2.6 扩展ThreadPoolExecutor
4.3 JDK并发数据结构
4.3.1 并发List
4.3.2 并发Set
4.3.3 并发Map
4.3.4 并发Queue
4.3.5 并发Deque
4.4 并发控制方法
4.4.1 Java内存模型与volatile
4.4.2 同步关键字synchronized
4.4.3 ReentrantLock重入锁
4.4.4 ReadWriteLock读写锁
4.4.5 Condition对象
4.4.6 Semaphore信号量
4.4.7 ThreadLocal线程局部变量
4.5 “锁”的性能和优化
4.5.1 线程的开销
4.5.2 避免死锁
4.5.3 减小锁持有时间
4.5.4 减小锁粒度
4.5.5 读写分离锁来替换独占锁
4.5.6 锁分离
4.5.7 重入锁ReentrantLock和内部锁synchronized
4.5.8 锁粗化(Lock Coarsening)
4.5.9 自旋锁（Spinning Lock）
4.5.10 锁消除（Lock Elimination）
4.5.11 锁偏向(Biased Lock)
4.6 无锁的并行计算
4.6.1 非阻塞的同步/无锁
4.6.2 原子操作
4.6.3 Amino框架介绍
4.6.4 Amino集合
4.6.5 Amino树
4.6.6 Amino图
4.6.7 Amino简单调度模式
4.7 协程
4.7.1 协程的概念
4.7.2 Kilim框架简介
4.7.3 Task及其状态
4.7.4 Fiber及其状态
4.7.5 Kilim开发环境配置
4.7.6 Kilim之Hello World
4.7.7 多任务通信
4.7.8 Kilim实例及性能评估
4.8 小结
第5章 JVM调优
5.1 Java虚拟机内存模型
5.1.1 程序计数器
5.1.2 Java虚拟机栈
5.1.3 本地方法栈
5.1.4 Java堆
5.1.5 方法区
5.2 JVM内存分配参数
5.2.1 设置最大堆内存
5.2.2 设置最小堆内存
5.2.3 设置新生代
5.2.4 设置持久代
5.2.5 设置线程桟
5.2.6 堆的比例分配
5.2.7 堆分配参数总结
5.3 垃圾收集基础
5.3.1 垃圾收集的作用
5.3.2 垃圾回收算法与思想
5.3.3 垃圾收集器的类型
5.3.4 评价GC策略的指标
5.3.5 新生代串行收集器
5.3.6 老年代串行收集器
5.3.7 并行收集器
5.3.8 新生代并行回收（Parallel Scavenge）收集器
5.3.9 老年代并行回收收集器
5.3.10 CMS收集器
5.3.11 G1收集器（Garbage First）
5.3.12 Stop the World案例
5.3.13 收集器对系统性能的影响
5.3.14 GC相关参数总结
5.4 常用调优案例和方法
5.4.1 将新对象预留在新生代
5.4.2 大对象进入老年代
5.4.3 设置对象进入老年代的年龄
5.4.4 稳定与震荡的堆大小
5.4.5 吞吐量优先案例
5.4.6 使用大页案例
5.4.7 降低停顿案例
5.5 实用JVM参数
5.5.1 JIT编译参数
5.5.2 堆快照（堆Dump）
5.5.3 错误处理
5.5.4 取得GC信息
5.5.5 类和对象跟踪
5.5.6 控制GC
5.5.7 选择类校验器
5.5.8 Solaris下线程控制
5.5.9 使用大页
5.5.10 压缩指针
5.6 实战JVM调优
5.6.1 Tomcat简介与启动加速
5.6.2 Web应用程序介绍
5.6.3 JMeter介绍与使用
5.6.4 调优前Web应用运行状况
5.6.5 调优过程
5.7 总结
第6章 Java性能调优工具
6.1 Linux命令行工具
6.1.1 top命令
6.1.2 sar命令
6.1.3 vmstat命令
6.1.4 iostat命令
6.1.5 pidstat工具
6.2 Windows工具
6.2.1 任务管理器
6.2.2 perfmon性能监控工具
6.2.3 Process Explorer
6.2.4 pslist命令行
6.3 JDK命令行工具
6.3.1 jps命令
6.3.2 jstat命令
6.3.3 jinfo命令
6.3.4 jmap命令
6.3.5 jhat命令
6.3.6 jstack命令
6.3.7 jstatd命令
6.3.8 hprof工具
6.4 JConsole工具
6.4.1 JConsole连接Java程序
6.4.2 Java程序概况
6.4.3 内存监控
6.4.4 线程监控
6.4.5 类加载情况
6.4.6 虚拟机信息
6.4.7 MBean管理
6.4.8 使用插件
6.5 Visual VM多合一工具
6.5.1 Visual VM连接应用程序
6.5.2 监控应用程序概况
6.5.3 Thread Dump和分析
6.5.4 性能分析
6.5.5 快照
6.5.6 内存快照分析
6.5.7 MBean管理
6.5.8 TDA使用
6.5.9 BTrace介绍
6.6 Visual VM对OQL的支持
6.6.1 Visual VM的OQL基本语法
6.6.2 内置heap对象
6.6.3 对象函数
6.6.4 集合/统计函数
6.6.5 程序化OQL
6.7 MAT内存分析工具
6.7.1 初识MAT
6.7.2 浅堆和深堆
6.7.3 支配树（Dominator Tree）
6.7.4 垃圾回收根
6.7.5 内存泄露检测
6.7.6 最大对象报告
6.7.7 查找支配者
6.7.8 线程分析
6.7.9 集合使用情况分析
6.7.10 扩展MAT
6.8 MAT对OQL的支持
6.8.1 Select子句
6.8.2 From子句
6.8.3 Where子句
6.8.4 内置对象与方法
6.9 JProfile简介
6.9.1 JProfile使用配置
6.9.2 内存视图
6.9.3 堆快照
6.9.4 CPU视图
6.9.5 线程视图
6.9.6 JVM统计信息
6.9.7 触发器
6.10 小结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序性能优化
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Clojure编程
第1章  进入Clojure仙境	1
为什么要选择Clojure?	1
获取Clojure	3
Clojure REPL	3
不！括号真的不会让你瞎了眼	6
表达式、操作符、语法以及优先级	7
同像性	10
Clojure Reader	12
命名空间	21
符号解析	23
特殊形式	24
小结	46
这只是开始	48
第1部分 	49
第2章   函数式编程	51
所谓函数式编程，到底意味着什么？	52
谈谈值的重要性	52
作为头等公民的函数以及高阶函数	59
函数（功能）的组合	68
纯函数	76
现实生活中的函数式编程	80
第3章  集合类与数据结构	83
抽象优于实现	84
访问集合元素的简洁方式	111
数据结构的类型	115
不可变性和持久性	123
元数据	136
用Clojure的集合来小试牛刀	137
总结	159
第4章  多线程和并发	161
计算在时间和空间内的转换	162
简单的并行化	168
状态和标识	170
Clojure的引用类型	172
并发操作的分类	174
原子类型（Atom）	176
通知和约束	179
ref	182
var	200
Agent	211
使用Java的并发原语	227
总结	228
第2部分 	229
第5 章  宏	231
宏到底是什么？	231
编写你的第一个宏	237
调试宏	239
语法	242
什么时候使用宏	245
宏卫生	247
宏的常见用法和模式	253
隐藏参数：&env 和 &form	255
深入 -> 和 ->>	263
总结	266
第6章  数据类型和协议	267
协议（Protocol）	268
扩展已有的类型	270
定义你自己的类型	274
实现协议	284
协议自省	293
协议函数分派的边界场景	295
自己实现一个set	296
总结	304
第7章  多重方法	305
多重方法基础	305
通往层级之路	308
层级	310
真正实现多重！	315
还有几件事	317
最后的思考	321
第3 部分 	323
第8章  Clojure项目的组织与构建	325
项目布局	325
构建	339
最后的思考	355
第9章  Java及JVM互操作	357
JVM是Clojure的基础	358
Java类、方法和字段的使用	358
便利的互操作工具	361
异常与错误处理	363
为了效率进行类型提示	367
定义类、实现接口	372
在Java里使用Clojure	386
乐于合作的伙伴	393
第10章  面向REPL的编程	395
交互式开发	395
工具集	400
在REPL里调试、监测和打补丁	412
重定义结构的限制	416
小结	418
第4部分 	419
第11章  数字与数学	421
Clojure的数字	421
Clojure数学	427
相等与等值	432
优化数值效率	436
用Clojure可视化芒德布罗集	448
第12章  设计模式	457
依赖注入	459
策略模式	462
责任链	463
面向方面的编程	466
最后的思考	470
第13章  测试	471
不可变值与纯函数	471
clojure.test	473
HTML DSL的成长	482
依赖断言	486
第14章  使用关系数据库	491
clojure.java.jdbc	491
Korma	498
Hibernate	503
最后的思考	510
第15章  使用非关系型数据库	511
安装CouchDB和Clutch	512
基本的CRUD操作	512
视图	513
_changes: 把CouchDB滥用做消息队列	519
可随意点选的消息队列	521
最后的思考	524
第16章  Clojure与Web	525
Clojure栈	525
基石：Ring	526
用Compojure路由请求	533
使用模板	543
最后的思考	552
第17章  布署Clojure Web应用程序	553
Java与Clojure Web架构	553
在本地运行Web应用	561
Web应用程序布署	562
超越简单Web应用程序布署	565
第5部分 	567
第18章  明智地选择Clojure类型定义形式	569
第19章  在工作场所引进Clojure	573
只是事实…	573
强调生产效率	574
强调社群	576
审慎	577
第20章  下一步？	579
(dissoc Clojure ‘JVM)	579
4Clojure	580
Overtone	581
core.logic	581
Pallet	582
Avout	582
Heroku上的Clojure	583
关于作者	585
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Clojure编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>编写高质量代码
前言
第1章　Java开发中通用的方法和准则/1
建议1： 不要在常量和变量中出现易混淆的字母/2
建议2： 莫让常量蜕变成变量/2
建议3： 三元操作符的类型务必一致/3
建议4： 避免带有变长参数的方法重载/4
建议5： 别让null值和空值威胁到变长方法/6
建议6： 覆写变长方法也循规蹈矩/7
建议7： 警惕自增的陷阱/8
建议8： 不要让旧语法困扰你/10
建议9： 少用静态导入/11
建议10： 不要在本类中覆盖静态导入的变量和方法/13
建议11： 养成良好习惯，显式声明UID/14
建议12： 避免用序列化类在构造函数中为不变量赋值/17
建议13： 避免为final变量复杂赋值/19
建议14： 使用序列化类的私有方法巧妙解决部分属性持久化问题/20
建议15： break万万不可忘/23
建议16： 易变业务使用脚本语言编写/25
建议17： 慎用动态编译/27
建议18： 避免instanceof非预期结果/29
建议19： 断言绝对不是鸡肋/31
建议20： 不要只替换一个类/33
第2章　基本类型/35
建议21： 用偶判断，不用奇判断/36
建议22： 用整数类型处理货币/37
建议23： 不要让类型默默转换/38
建议24： 边界，边界，还是边界/39
建议25： 不要让四舍五入亏了一方/41
建议26： 提防包装类型的null值/43
建议27： 谨慎包装类型的大小比较/45
建议28： 优先使用整型池/46
建议29： 优先选择基本类型/48
建议30： 不要随便设置随机种子/49
第3章　类、对象及方法/52
建议31： 在接口中不要存在实现代码/53
建议32： 静态变量一定要先声明后赋值/54
建议33： 不要覆写静态方法/55
建议34： 构造函数尽量简化/57
建议35： 避免在构造函数中初始化其他类/58
建议36： 使用构造代码块精炼程序/60
建议37： 构造代码块会想你所想/61
建议38： 使用静态内部类提高封装性/63
建议39： 使用匿名类的构造函数/65
建议40： 匿名类的构造函数很特殊/66
建议41： 让多重继承成为现实/68
建议42： 让工具类不可实例化/70
建议43： 避免对象的浅拷贝/71
建议44： 推荐使用序列化实现对象的拷贝/73
建议45： 覆写equals方法时不要识别不出自己/74
建议46： equals应该考虑null值情景/76
建议47： 在equals中使用getClass进行类型判断/77
建议48： 覆写equals方法必须覆写hashCode方法/78
建议49： 推荐覆写toString方法/80
建议50： 使用package-info类为包服务/81
建议51： 不要主动进行垃圾回收/82
第4章　字符串/83
建议52： 推荐使用String直接量赋值/84
建议53： 注意方法中传递的参数要求/85
建议54： 正确使用String、StringBuffer、StringBuilder/86
建议55： 注意字符串的位置/87
建议56： 自由选择字符串拼接方法/88
建议57： 推荐在复杂字符串操作中使用正则表达式/90
建议58： 强烈建议使用UTF编码/92
建议59： 对字符串排序持一种宽容的心态/94
第5章　数组和集合/97
建议60： 性能考虑，数组是首选/98
建议61： 若有必要，使用变长数组/99
建议62： 警惕数组的浅拷贝/100
建议63： 在明确的场景下，为集合指定初始容量/101
建议64： 多种最值算法，适时选择/104
建议65： 避开基本类型数组转换列表陷阱/105
建议66： asList方法产生的List对象不可更改/107
建议67： 不同的列表选择不同的遍历方法/108
建议68： 频繁插入和删除时使用LinkedList/112
建议69： 列表相等只需关心元素数据/115
建议70：子列表只是原列表的一个视图/117
建议71： 推荐使用subList处理局部列表/119
建议72： 生成子列表后不要再操作原列表/120
建议73： 使用Comparator进行排序/122
建议74： 不推荐使用binarySearch对列表进行检索/125
建议75： 集合中的元素必须做到compareTo和equals同步/127
建议76： 集合运算时使用更优雅的方式/129
建议77： 使用shuffle打乱列表/131
建议78： 减少HashMap中元素的数量/132
建议79： 集合中的哈希码不要重复/135
建议80： 多线程使用Vector或HashTable/139
建议81： 非稳定排序推荐使用List/141
建议82： 由点及面，一叶知秋—集合大家族/143
第6章　枚举和注解/145
建议83： 推荐使用枚举定义常量/146
建议84： 使用构造函数协助描述枚举项/149
建议85： 小心switch带来的空值异常/150
建议86： 在switch的default代码块中增加AssertionError错误/152
建议87： 使用valueOf前必须进行校验/152
建议88： 用枚举实现工厂方法模式更简洁/155
建议89： 枚举项的数量限制在64个以内/157
建议90： 小心注解继承/160
建议91： 枚举和注解结合使用威力更大/162
建议92： 注意@Override不同版本的区别/164
第7章　泛型和反射/166
建议93： Java的泛型是类型擦除的/167
建议94： 不能初始化泛型参数和数组/169
建议95： 强制声明泛型的实际类型/170
建议96： 不同的场景使用不同的泛型通配符/172
建议97： 警惕泛型是不能协变和逆变的/174
建议98： 建议采用的顺序是List<T>、List<?>、List<Object>/176
建议99： 严格限定泛型类型采用多重界限/177
建议100： 数组的真实类型必须是泛型类型的子类型/179
建议101： 注意Class类的特殊性/181
建议102： 适时选择getDeclared×××和get×××/181
建议103： 反射访问属性或方法时将Accessible设置为true /182
建议104： 使用forName动态加载类文件/184
建议105： 动态加载不适合数组/186
建议106： 动态代理可以使代理模式更加灵活/188
建议107： 使用反射增加装饰模式的普适性/190
建议108： 反射让模板方法模式更强大/192
建议109： 不需要太多关注反射效率/194
第8章　异常/197
建议110： 提倡异常封装/198
建议111： 采用异常链传递异常/200
建议112： 受检异常尽可能转化为非受检异常/202
建议113： 不要在finally块中处理返回值/204
建议114： 不要在构造函数中抛出异常/207
建议115： 使用Throwable获得栈信息/210
建议116： 异常只为异常服务/212
建议117： 多使用异常，把性能问题放一边/213
第9章　多线程和并发/215
建议118： 不推荐覆写start方法/216
建议119： 启动线程前stop方法是不可靠的/218
建议120： 不使用stop方法停止线程/220
建议121： 线程优先级只使用三个等级/224
建议122： 使用线程异常处理器提升系统可靠性/226
建议123： volatile不能保证数据同步/228
建议124： 异步运算考虑使用Callable接口/232
建议125： 优先选择线程池/233
建议126： 适时选择不同的线程池来实现/237
建议127： Lock与synchronized是不一样的/240
建议128： 预防线程死锁/245
建议129： 适当设置阻塞队列长度/250
建议130： 使用CountDownLatch协调子线程/252
建议131： CyclicBarrier让多线程齐步走/254
第10章　性能和效率/256
建议132： 提升Java性能的基本方法/257
建议133： 若非必要，不要克隆对象/259
建议134： 推荐使用“望闻问切”的方式诊断性能/261
建议135： 必须定义性能衡量标准/263
建议136： 枪打出头鸟—解决首要系统性能问题/264
建议137： 调整JVM参数以提升性能/266
建议138： 性能是个大“咕咚”/268
第11章　开源世界/271
建议139： 大胆采用开源工具/272
建议140： 推荐使用Guava扩展工具包/273
建议141： Apache扩展包/276
建议142： 推荐使用Joda日期时间扩展包/280
建议143： 可以选择多种Collections扩展/282
第12章　思想为源/285
建议144： 提倡良好的代码风格/286
建议145： 不要完全依靠单元测试来发现问题/287
建议146： 让注释正确、清晰、简洁/290
建议147： 让接口的职责保持单一/294
建议148： 增强类的可替换性/295
建议149： 依赖抽象而不是实现/298
建议150： 抛弃7条不良的编码习惯/299
建议151： 以技术员自律而不是工人/301
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>编写高质量代码
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>明解Java
第 1章 在画面上显示字符　　1
1-1　关于Java　　2
Java的诞生　　2
Java的特点　　2
Java的发展　　4
学前准备　　4
1-2　在画面上显示字符　　5
创建和运行程序　　5
注释　　8
程序结构　　10
字符串常量　　11
在画面上输出和流　　12
字符串的拼接　　13
换行　　13
符号的称呼　　14
自由书写　　15
缩进　　16
小结　　19
第2章　使用变量　　21
2-1　变量　　22
输出运算结果　　22
变量　　25
变量和初始化　　28
2-2　通过键盘输入　　31
通过键盘输入　　31
运算符和操作数　　33
final变量　　36
生成随机数　　38
字符串的读入　　40
小结　　43
第3章　程序流程之分支　　45
3-1　if语句　　46
if-then语句　　46
关系运算符　　47
if-then-else语句　　47
相等运算符　　50
逻辑非运算符　　50
嵌套的if语句　　51
表达式和求值　　55
表达式语句和空语句　　57
逻辑与运算符和逻辑或运算符　　58
条件运算符　　62
三个值中的最大值　　64
程序块　　66
两个值的排序　　67
3-2　switch语句　　70
switch语句　　70
选择语句　　74
3-3　关键字、标识符、运算符　　75
关键字　　75
分隔符　　75
标识符　　75
常量　　76
运算符　　76
小结　　81
第4章　程序流程之循环　　83
4-1　do语句　　84
do语句　　84
4-2　while语句　　90
while语句　　90
递增运算符和递减运算符　　91
while语句和do语句　　97
复合赋值运算符　　98
4-3　for语句　　103
for语句　　103
流程图　　105
4-4　多重循环　　110
九九乘法表　　110
直角三角形的显示　　111
4-5　break语句和continue语句　　114
break语句　　114
continue语句　　115
带标签的break语句　　117
带标签的continue语句　　119
4-6　printf方法　　121
printf方法　　121
小结　　125
第5章　基本类型和运算　　127
5-1　基本类型　　128
基本类型　　128
整型　　129
浮点型　　137
布尔型（boolean型）　　141
5-2　运算和类型　　144
运算和类型　　144
造型运算符　　146
基本类型的缩小转换　　148
基本类型的放大转换　　150
基本类型的放大转换和缩小转换　　151
循环的控制　　152
5-3　转义字符　　154
转义字符　　154
小结　　157
第6章　数组　　159
6-1　数组　　160
数组　　160
数组的构成元素　　163
数组的初始化和赋值　　169
使用数组处理成绩　　170
计算数组元素中的最大值　　171
线性查　　172
扩展for语句　　176
对数组进行倒序排列　　178
数组的复制　　180
字符串数组　　184
引用类型和对象　　185
final数组　　187
6-2　多维数组　　188
多维数组　　188
多维数组的内部　　191
不规则二维数组的内部　　193
初始值　　195
小结　　197
第7章　方法　　199
7-1　方法　　200
方法　　200
return语句　　205
值传递　　207
void方法　　208
方法的通用性　　209
其他方法的调用　　210
作用域　　212
不接收参数的方法　　214
7-2　窥探整数内部　　217
位运算　　217
移位运算　　219
7-3　操作数组的方法　　225
计算最大值的方法　　225
线性查找　　226
对数组中的元素进行倒序排列　　228
比较两个数组　　230
返回数组的方法　　232
多维数组的传递　　235
7-4　重载　　237
方法的重载　　237
小结　　241
第8章　类的基础知识　　243
8-1类　　244
数据操作　　244
类　　245
构造函数　　254
方法　　256
8-2　汽车类　　260
类的独立　　260
标识符的命名　　267
小结　　69
第9章　创建日期类　　271
9-1　创建日期类　　272
日期类　　272
构造函数和方法　　272
访问器　　274
类类型变量的赋值　　275
类类型变量的比较　　277
作为参数的类类型变量　　279
类类型实例的数组　　281
日期类的改进　　285
9-2　类类型的字段　　295
类类型的字段　　295
返回引用的方法　　296
汽车类的使用示例　　298
has-A　　300
小结　　302
第10章　类变量和类方法　　305
10-1　类变量　　306
类变量（静态字段）　　306
类变量的访问　　309
库中提供的类变量　　311
10-2　类方法　　314
类方法　　314
类变量和类方法　　317
Math类的类方法　　320
工具类　　322
10-3　类初始化器和实例初始化器　　323
类初始化器（静态初始化器）　　323
实例初始化器　　326
小结　　329
第11章 包　　331
11-1　包和导入声明　　332
包　　332
类型导入声明　　333
静态导入声明　　337
11-2　包的声明　　340
包　　340
包和目录　　341
唯一的包名　　345
11-3　类和成员的访问属性　　347
类的访问控制　　347
成员的访问控制　　348
小结　　351
第12章　类的派生和多态　　353
12-1　继承　　354
银行账户类　　354
派生和继承　　355
派生和构造函数　　357
类层次　　362
Object类　　364
增量编程　　365
is-A关系和实例的引用　　366
12-2　多态　　370
方法的重写　　370
多态　　371
面向对象的三大要素　　375
引用类型的转型　　375
instanceof运算符　　376
@Override注解　　377
12-3　继承和访问属性　　379
成员　　379
final类和方法　　380
重写和方法的访问属性　　380
小结　　385
第13章　抽象类　　387
13-1　抽象类　　388
抽象类　　388
13-2　具有抽象性的非抽象方法的设计　　393
图形类群的改进　　393
文档注释和javadoc　　404
小结　　411
第14章　接口　　413
14-1　接口　　414
接口　　414
类的派生和接口的实现　　420
多个接口的实现　　422
14-2　接口的派生　　424
接口的派生　　424
小结　　426
第15章　字符和字符串　　429
15-1　字符　　430
字符　　430
char型　　432
15-2　字符串和String　　434
字符串和字符串常量　　434
String型　　434
构造函数　　437
方法　　440
字符串的比较　　446
format方法　　448
15-3　字符串数组和命令行参数　　450
字符串数组　　450
命令行参数　　453
小结　　457
第16章　异常处理　　459
16-1　什么是异常　　460
什么是异常　　460
捕获异常　　461
try语句　　463
传递异常　　465
16-2　异常处理　　467
异常类　　467
检查异常和非检查异常　　468
Throwable类　　468
抛出和捕获异常　　470
检查异常的处理　　471
创建异常类　　473
委托异常　　475
再次抛出异常　　477
小结　　479
后记　　481
参考文献　　484
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>明解Java
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Hibernate
第1章 Java对象持久化技术概述
1.1 应用程序的分层体系结构
1.2 软件的模型
1.3 直接通过JDBC API来持久化实体域对象
1.4 ORM简介
1.5 实体域对象的其他持久化模式
1.6 Hibernate API简介
1.7 小结
第2章 Hibernate入门
2.1 创建Hibernate的配置文件46
2.2 创建持久化类
2.3 创建数据库Schema
2.4 创建对象-关系映射文件
2.5 通过HibernateAPI操纵数据库
2.6 运行helloapp应用
2.7 小结
第3章 hbm2java和hbm2ddl工具
3.1 创建对象-关系映射文件
3.2 建立项目的目录结构
3.3 运行hbm2java工具
3.4 运行hbm2ddl工具
3.5 小结
第4章 对象-关系映射基础
4.1 持久化类的属性及访问方法
4.2 处理SQL引用标识符
4.3 创建命名策略
4.4 设置命名Schema
4.5 设置类的包名
4.6 运行本章的范例程序
4.7 小结
第5章 映射对象标识符
5.1 关系数据库按主键区分不同的记录
5.2 Java语言按内存地址区分不同的对象
5.3 Hibernate用对象标识符（OID）来区分对象
5.4 Hibernate的内置标识符生成器的用法
5.5 映射自然主键
5.6 小结
第6章 映射一对多关联关系
……
第7章 操纵持久化对象
第8章 映射组成关系
第9章 Hibernate的映射类型
第10章 Hibernate的检索策略
第11章 Hibernate的检索方式
第12章 数据库事务与并发
第13章 管理Hibernate的缓存
第14章 映射继承关系
第15章 Java集合类
第16章 映射值类型集合
第17章 映射实体关联关系
第18章 Hibernate高级配置
第19章 Hibernate与Struts框架
第20章 Hibernate与EJB组件
附录A 标准SQL语言的用法
附录B Java语言的反射机制
附录C 用XDoclet工具生成映射文件
附录D 发布和运行netstore应用
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Hibernate
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务架构设计模式
目　　录
写给中文版读者的话
译者序
中文版序一
中文版序二
前言
引言
第1章　逃离单体地狱   / 1
1.1　迈向单体地狱的漫长旅程   / 2
1.1.1　FTGO应用程序的架构   / 3
1.1.2　单体架构的好处   / 4
1.1.3　什么是单体地狱   / 4
1.2　为什么本书与你有关   / 7
1.3　你会在本书中学到什么   / 8
1.4　拯救之道：微服务架构   / 8
1.4.1　扩展立方体和服务   / 9
1.4.2　微服务架构作为模块化的一种形式   / 11
1.4.3　每个服务都拥有自己的数据库   / 12
1.4.4　FTGO的微服务架构   / 12
1.4.5　微服务架构与SOA的异同   / 14
1.5　微服务架构的好处和弊端   / 15
1.5.1　微服务架构的好处   / 15
1.5.2　微服务架构的弊端   / 17
1.6　微服务架构的模式语言   / 19
1.6.1　微服务架构并不是“银弹”   / 20
1.6.2　模式和模式语言   / 21
1.6.3　微服务架构的模式语言概述   / 24
1.7　微服务之上：流程和组织   / 29
1.7.1　进行软件开发和交付的组织   / 30
1.7.2　进行软件开发和交付的流程   / 31
1.7.3　采用微服务架构时的人为因素   / 32
第2章　服务的拆分策略   / 34
2.1　微服务架构到底是什么   / 35
2.1.1　软件架构是什么，为什么它如此重要   / 35
2.1.2　什么是架构的风格   / 37
2.1.3　微服务架构是一种架构风格   / 40
2.2　为应用程序定义微服务架构   / 43
2.2.1　识别系统操作   / 45
2.2.2　根据业务能力进行服务拆分   / 50
2.2.3　根据子域进行服务拆分   / 53
2.2.4　拆分的指导原则   / 54
2.2.5　拆分单体应用为服务的难点   / 56
2.2.6　定义服务API   / 59
第3章　微服务架构中的进程间通信   / 63
3.1　微服务架构中的进程间通信概述   / 64
3.1.1　交互方式   / 64
3.1.2　在微服务架构中定义API   / 66
3.1.3　API的演化   / 67
3.1.4　消息的格式   / 69
3.2　基于同步远程过程调用模式的通信   / 70
3.2.1　使用REST   / 71
3.2.2　使用gRPC   / 74
3.2.3　使用断路器模式处理局部故障   / 75
3.2.4　使用服务发现   / 78
3.3　基于异步消息模式的通信   / 82
3.3.1　什么是消息传递   / 83
3.3.2　使用消息机制实现交互方式   / 84
3.3.3　为基于消息机制的服务API创建API规范   / 86
3.3.4　使用消息代理   / 87
3.3.5　处理并发和消息顺序   / 91
3.3.6　处理重复消息   / 92
3.3.7　事务性消息   / 93
3.3.8　消息相关的类库和框架   / 97
3.4　使用异步消息提高可用性   / 99
3.4.1　同步消息会降低可用性   / 99
3.4.2　消除同步交互   / 101
第4章　使用Saga管理事务　   / 106
4.1　微服务架构下的事务管理   / 107
4.1.1　微服务架构对分布式事务的需求   / 108
4.1.2　分布式事务的挑战   / 109
4.1.3　使用Saga模式维护数据一致性   / 109
4.2　Saga的协调模式   / 113
4.2.1　协同式Saga   / 113
4.2.2　编排式Saga   / 117
4.3　解决隔离问题   / 121
4.3.1　缺乏隔离导致的问题   / 122
4.3.2　Saga模式下实现隔离的对策   / 123
4.4　Order Service和Create Order Saga的设计   / 127
4.4.1　OrderService类   / 128
4.4.2　Create Order Saga的实现   / 129
4.4.3　OrderCommandHandlers类   / 136
4.4.4　OrderServiceConfiguration类   / 138
第5章　微服务架构中的业务逻辑设计   / 141
5.1　业务逻辑组织模式   / 142
5.1.1　使用事务脚本模式设计业务逻辑   / 143
5.1.2　使用领域模型模式设计业务逻辑   / 144
5.1.3　关于领域驱动设计   / 146
5.2　使用聚合模式设计领域模型   / 146
5.2.1　模糊边界所带来的问题   / 147
5.2.2　聚合拥有明确的边界   / 149
5.2.3　聚合的规则   / 150
5.2.4　聚合的颗粒度   / 152
5.2.5　使用聚合设计业务逻辑   / 153
5.3　发布领域事件   / 154
5.3.1　为什么需要发布变更事件   / 154
5.3.2　什么是领域事件   / 155
5.3.3　事件增强   / 155
5.3.4　识别领域事件   / 156
5.3.5　生成和发布领域事件   / 157
5.3.6　消费领域事件   / 161
5.4　Kitchen Service的业务逻辑   / 162
5.5　Order Service的业务逻辑   / 167
5.5.1　Order聚合   / 169
5.5.2　 OrderService类   / 173
第6章　使用事件溯源开发业务逻辑   / 176
6.1　使用事件溯源开发业务逻辑概述   / 177
6.1.1　传统持久化技术的问题   / 177
6.1.2　什么是事件溯源   / 179
6.1.3　使用乐观锁处理并发更新   / 186
6.1.4　事件溯源和发布事件   / 186
6.1.5　使用快照提升性能   / 188
6.1.6　幂等方式的消息处理   / 189
6.1.7　领域事件的演化   / 190
6.1.8　事件溯源的好处   / 192
6.1.9　事件溯源的弊端   / 193
6.2　实现事件存储库   / 194
6.2.1　Eventuate Local事件存储库的工作原理   / 195
6.2.2　Eventuate的Java客户端框架   / 198
6.3　同时使用Saga和事件溯源   / 201
6.3.1　使用事件溯源实现协同式Saga   / 203
6.3.2　创建编排式Saga   / 203
6.3.3　实现基于事件溯源的Saga参与方   / 205
6.3.4　实现基于事件溯源的Saga编排器   / 208
第7章　在微服务架构中实现查询   / 212
7.1　使用API组合模式进行查询   / 213
7.1.1　findOrder()查询操作   / 213
7.1.2　什么是API组合模式   / 214
7.1.3　使用API组合模式实现findOrder()查询操作   / 215
7.1.4　API组合模式的设计缺陷   / 216
7.1.5　API组合模式的好处和弊端   / 219
7.2　使用CQRS模式   / 220
7.2.1　为什么要使用CQRS   / 220
7.2.2　什么是CQRS   / 223
7.2.3　CQRS的好处   / 226
7.2.4　CQRS的弊端   / 227
7.3　设计CQRS视图   / 228
7.3.1　选择视图存储库   / 229
7.3.2　设计数据访问模块   / 230
7.3.3　添加和更新CQRS视图   / 232
7.4　实现基于AWS DynamoDB的CQRS视图   / 233
7.4.1　OrderHistoryEventHandlers模块   / 234
7.4.2　DynamoDB中的数据建模和查询设计   / 235
7.4.3　OrderHistoryDaoDynamoDb类   / 239
第8章　外部API模式   / 244
8.1　外部API的设计难题   / 245
8.1.1　FTGO移动客户端API的设计难题   / 246
8.1.2　其他类型客户端API的设计难题   / 248
8.2　API Gateway模式   / 250
8.2.1　什么是API Gateway模式   / 250
8.2.2　API Gateway模式的好处和弊端   / 256
8.2.3　以Netflix为例的API Gateway   / 257
8.2.4　API Gateway的设计难题   / 258
8.3　实现一个API Gateway   / 260
8.3.1　使用现成的API Gateway产品或服务   / 261
8.3.2　开发自己的API Gateway   / 262
8.3.3　使用GraphQL实现API Gateway   / 269
第9章　微服务架构中的测试策略（上）   / 282
9.1　微服务架构中的测试策略概述   / 284
9.1.1　什么是测试   / 284
9.1.2　微服务架构中的测试挑战   / 289
9.1.3　部署流水线   / 295
9.2　为服务编写单元测试   / 296
9.2.1　为实体编写单元测试   / 298
9.2.2　为值对象编写单元测试   / 299
9.2.3　为Saga编写单元测试   / 300
9.2.4　为领域服务编写单元测试   / 302
9.2.5　为控制器编写单元测试   / 303
9.2.6　为事件和消息处理程序编写单元测试   / 305
第10章　微服务架构中的测试策略（下）   / 308
10.1　编写集成测试   / 308
10.1.1　针对持久化层的集成测试   / 311
10.1.2　针对基于REST的请求/响应式交互的集成测试   / 312
10.1.3　针对发布/订阅式交互的集成测试   / 316
10.1.4　针对异步请求/响应式交互的集成契约测试   / 320
10.2　编写组件测试   / 324
10.2.1　定义验收测试   / 325
10.2.2　使用Gherkin编写验收测试   / 326
10.2.3　设计组件测试   / 328
10.2.4　为FTGO的Order Service编写组件测试   / 330
10.3　端到端测试   / 334
10.3.1　设计端到端测试   / 335
10.3.2　编写端到端测试   / 335
10.3.3　运行端到端测试   / 336
第11章　开发面向生产环境的微服务应用   / 338
11.1　开发安全的服务   / 339
11.1.1　传统单体应用程序的安全性   / 340
11.1.2　在微服务架构中实现安全性   / 343
11.2　设计可配置的服务   / 349
11.2.1　使用基于推送的外部化配置   / 350
11.2.2　使用基于拉取的外部化配置   / 352
11.3　设计可观测的服务   / 353
11.3.1　使用健康检查API模式   / 355
11.3.2　使用日志聚合模式   / 357
11.3.3　使用分布式追踪模式   / 358
11.3.4　使用应用程序指标模式   / 361
11.3.5　使用异常追踪模式   / 364
11.3.6　使用审计日志模式   / 365
11.4　使用微服务基底模式开发服务   / 367
11.4.1　使用微服务基底   / 368
11.4.2　从微服务基底到服务网格   / 368
第12章　部署微服务应用   / 371
12.1　部署模式：编程语言特定的发布包格式   / 374
12.1.1　使用编程语言特定的发布包格式进行部署的好处   / 376
12.1.2　使用编程语言特定的发布包格式进行部署的弊端   / 377
12.2　部署模式：将服务部署为虚拟机   / 378
12.2.1　将服务部署为虚拟机的好处   / 380
12.2.2　将服务部署为虚拟机的弊端   / 380
12.3　部署模式：将服务部署为容器   / 381
12.3.1　使用Docker部署服务   / 383
12.3.2　将服务部署为容器的好处   / 385
12.3.3　将服务部署为容器的弊端   / 386
12.4　使用Kubernetes部署FTGO应用程序   / 386
12.4.1　什么是Kubernetes   / 386
12.4.2　在Kubernetes上部署Restaurant Service   / 389
12.4.3　部署API Gateway   / 392
12.4.4　零停机部署   / 393
12.4.5　使用服务网格分隔部署与发布流程   / 394
12.5　部署模式：Serverless部署   / 402
12.5.1　使用AWS Lambda进行Serverless部署   / 403
12.5.2　开发Lambda函数   / 404
12.5.3　调用Lambda函数   / 404
12.5.4　使用Lambda函数的好处   / 405
12.5.5　使用Lambda函数的弊端   / 406
12.6　使用AWS Lambda和AWS Gateway部署RESTful服务   / 406
12.6.1　AWS Lambda版本的Restaurant Service   / 407
12.6.2　把服务打包为ZIP文件   / 411
12.6.3　使用Serverless框架部署Lambda函数   / 412
第13章　微服务架构的重构策略   / 415
13.1　重构到微服务需要考虑的问题   / 416
13.1.1　为什么要重构单体应用   / 416
13.1.2　绞杀单体应用   / 417
13.2　将单体应用重构为微服务架构的若干策略   / 420
13.2.1　将新功能实现为服务   / 420
13.2.2　隔离表现层与后端   / 422
13.2.3　提取业务能力到服务中   / 423
13.3　设计服务与单体的协作方式   / 429
13.3.1　设计集成胶水   / 430
13.3.2　在服务和单体之间维持数据一致性   / 434
13.3.3　处理身份验证和访问授权   / 438
13.4　将新功能实现为服务：处理错误配送订单   / 440
13.4.1　Delayed Delivery Service的设计   / 441
13.4.2　为Delayed Delivery Service设计集成胶水   / 442
13.5　从单体中提取送餐管理功能   / 444
13.5.1　现有的送餐管理功能   / 444
13.5.2　Delivery Service概览   / 446
13.5.3　设计Delivery Service的领域模型   / 447
13.5.4　Delivery Service集成胶水的设计   / 450
13.5.5　修改FTGO单体使其能够与Delivery Service交互   / 451
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务架构设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>爪哇夜未眠（第二版）
1 生涯篇
2 程序设计学习篇
3 REBOL篇
4 牢骚篇
5 励志篇
6 系统篇
7 软件工程篇
8 杂感篇
9 图书篇
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>爪哇夜未眠（第二版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>项目自动化之道
关于程序员修炼三部曲
前言
第1章 序言
1.1 瞧，不用手就能搞定
1.2 自动化的类型
1.3 关于自动化的问题
1.4 路线图
第2章 单步建构
2.1 建构软件很像做香肠
2.2 选择项目目录结构
2.3 生成你的首个建构
2.4 用 Ant 建构
2.5 对建构进行“口味测试”
2.6 打扫战场
2.7 脚本化建构
2.8 提早开始
2.9 小结
第3章 定时建构
3.1 定时首个建构
3.2 将建构置于 CruiseControl
3.3 运行 CruiseControl
3.4 发表建构状态
3.5 更上一层楼
3.6 小结
第4章 按键发布
4.1 早日并频繁地产生发布
4.2 准备第一款发布
4.3 对发布打包
4.4 产生发布
4.5 对发布打标
4.6 提交发布
4.7 发布流程的自动化
4.8 每日产生发布
4.9 小结
第5章 安装与部署
5.1 呈交产品
5.2 安装标准分发文件
5.3 通过电话排除故障
5.4 用诊断测试排除故障
5.5 增强安装形象
5.6 部署托管应用
5.7 自动更新已安装的应用
5.8 小结
第6章 监控
6.1 监控定时建构
6.2 从可视装置取得反馈信息
6.3 监控 Java 进程
6.4 对 Web 应用“体检”
6.5 监视日志文件
6.6 用 log4j 监控
6.7 用 RSS 建构“遥感线”
6.8 用调试命令监控健康状况
6.9 生成崩溃报告
6.10 3-2-1
6.11 自动化
附录A 资源
A.1 网络资源
A.2 参考书目
附录B 项目自动化之道：概要
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>项目自动化之道
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言规范
出版者的话
译者序
前言
第1章　概述 1
1.1　本书结构 1
1.2　样例程序 4
1.3　表示法 4
1.4　与预定义的类和接口的关系 4
1.5　反馈 5
1.6　参考文献 5
第2章　文法 6
2.1　上下文无关文法 6
2.2　词法 6
2.3　句法 6
2.4　文法表示法 6
第3章　词法结构 9
3.1　Unicode 9
3.2　词法翻译 10
3.3　Unicode转义字符 10
3.4　行终止符 11
3.5　输入元素和符号 12
3.6　空白字符 12
3.7　注释 13
3.8　标识符 14
3.9　关键字 15
3.10　字面常量 15
3.10.1　整数字面常量 15
3.10.2　浮点数字面常量 19
3.10.3　布尔字面常量 21
3.10.4　字符字面常量 21
3.10.5　字符串字面常量 22
3.10.6　字符和字符串字面常量的
转义序列 23
3.10.7　空字面常量 24
3.11　分隔符 24
3.12　操作符 24
第4章　类型、值和变量 25
4.1　类型和值的种类 25
4.2　简单类型和值 25
4.2.1　整数类型和值 26
4.2.2　整数操作 26
4.2.3　浮点数类型、格式和值 27
4.2.4　浮点数操作 29
4.2.5　boolean类型和布尔值 31
4.3　引用类型和值 32
4.3.1　对象 33
4.3.2　Object类 35
4.3.3　String类 35
4.3.4　当引用类型相同时 35
4.4　类型变量 36
4.5　参数化类型 37
4.5.1　参数化类型的类型引元 38
4.5.2　参数化类型的成员和构造器 40
4.6　类型擦除 40
4.7　可具化类型 41
4.8　原生类型 42
4.9　交集类型 45
4.10　子类型化 45
4.10.1　简单类型之间的子类型化 46
4.10.2　类与接口类型之间的子类型化 46
4.10.3　数组类型之间的子类型化 47
4.10.4　最低上边界 47
4.11　使用类型之处 49
4.12　变量 52
4.12.1　简单类型的变量 52
4.12.2　引用类型的变量 52
4.12.3　变量的种类 54
4.12.4　final变量 55
4.12.5　变量的初始值 56
4.12.6　类型、类和接口 57
第5章　类型转换与上下文 59
5.1　转换的种类 61
5.1.1　标识转换 61
5.1.2　拓宽简单类型转换 61
5.1.3　窄化简单类型转换 62
5.1.4　拓宽和窄化简单类型转换 64
5.1.5　拓宽引用类型转换 64
5.1.6　窄化引用类型转换 64
5.1.7　装箱转换 65
5.1.8　拆箱转换 66
5.1.9　非受检转换 67
5.1.10　捕获转换 67
5.1.11　字符串转换 69
5.1.12　被禁止的转换 69
5.1.13　值集转换 70
5.2　赋值上下文 70
5.3　方法调用上下文 74
5.4　字符串上下文 75
5.5　强制类型转换上下文 75
5.5.1　引用类型强制类型转换 77
5.5.2　受检强制类型转换和非受检强制类型转换 79
5.5.3　运行时的受检强制类型转换 80
5.6　数字上下文 81
5.6.1　一元数字提升 82
5.6.2　二元数字提升 83
第6章　名字 84
6.1　声明 84
6.2　名字与标识符 89
6.3　声明的作用域 91
6.4　遮蔽和遮掩 93
6.4.1　遮蔽 94
6.4.2　遮掩 96
6.5　确定名字的含义 97
6.5.1　根据上下文的名字的句法分类 98
6.5.2　对上下文歧义名字的重分类 100
6.5.3　包名的含义 101
6.5.4　PackageOrTypeNames的含义 102
6.5.5　类型名的含义 102
6.5.6　表达式名的含义 103
6.5.7　方法名的含义 105
6.6　访问控制 106
6.6.1　确定可访问性 107
6.6.2　受保护访问权限的细节 110
6.7　完全限定名和规范名 111
第7章　包 113
7.1　包成员 113
7.2　主机对包的支持 114
7.3　编译单元 115
7.4　包声明 116
7.4.1　具名包 116
7.4.2　不具名包 116
7.4.3　包的可观察性 117
7.5　导入声明 117
7.5.1　单类型导入声明 118
7.5.2　按需类型导入声明 119
7.5.3　单静态导入声明 120
7.5.4　按需静态导入声明 120
7.6　顶层类型声明 121
第8章　类 123
8.1　类声明 124
8.1.1　类修饰符 124
8.1.2　泛化类和类型参数 126
8.1.3　内部类和包围实例 128
8.1.4　超类和子类 130
8.1.5　超接口 132
8.1.6　类体和成员声明 134
8.2　类成员 135
8.3　域声明 138
8.3.1　域修饰符 141
8.3.2　域的初始化 145
8.3.3　在域初始化过程中的向前引用 146
8.4　方法声明 148
8.4.1　形参 149
8.4.2　方法签名 152
8.4.3　方法修饰符 152
8.4.4　泛化方法 156
8.4.5　方法的结果 157
8.4.6　方法抛出异常 157
8.4.7　方法体 158
8.4.8　继承、覆盖和隐藏 159
8.4.9　重载 166
8.5　成员类型声明 168
8.5.1　静态成员类型声明 169
8.6　实例初始化器 169
8.7　静态初始化器 169
8.8　构造器声明 170
8.8.1　形参 170
8.8.2　构造器签名 171
8.8.3　构造器修饰符 171
8.8.4　泛化构造器 172
8.8.5　构造器抛出异常 172
8.8.6　构造器的类型 172
8.8.7　构造器体 172
8.8.8　构造器重载 176
8.8.9　缺省构造器 176
8.8.10　阻止类的实例化 177
8.9　枚举类型 177
8.9.1　枚举常量 178
8.9.2　枚举体声明 178
8.9.3　枚举成员 180
第9章　接口 184
9.1　接口声明 184
9.1.1?接口修饰符 185
9.1.2　泛化接口和类型参数 185
9.1.3　超接口和子接口 186
9.1.4　接口体和成员声明 187
9.2　接口成员 187
9.3　域（常量）声明 187
9.3.1　接口中域的初始化 189
9.4　方法声明 189
9.4.1　继承和覆盖 190
9.4.2　重载 193
9.4.3　接口方法体 193
9.5　成员类型声明 193
9.6　注解类型 194
9.6.1　注解类型元素 195
9.6.2　注解类型元素的缺省值 197
9.6.3　可重复的注解类型 198
9.6.4　预定义的注解类型 200
9.7　注解 204
9.7.1　普通注解 205
9.7.2　标记注解 207
9.7.3　单元素注解 207
9.7.4　注解可以出现在何处 208
9.7.5　同种类型的多重注解 211
9.8　函数型接口 212
9.9 　函数类型 214
第10章　数组 218
10.1　数组类型 218
10.2　数组变量 219
10.3　数组创建 220
10.4　数组访问 220
10.5　数组存储异常 220
10.6　数组初始化器 221
10.7　数组成员 222
10.8　数组的Class对象 223
10.9　字符数组不是String 224
第11章　异常 225
11.1　异常的种类和成因 225
11.1.1　异常的种类 225
11.1.2　异常的成因 226
11.1.3　异步异常 226
11.2　异常的编译时检查 227
11.2.1　表达式异常分析 228
11.2.2　语句异常分析 228
11.2.3　异常检查 229
11.3　异常的运行时处理 230
第12章　执行 233
12.1　Java虚拟机启动 233
12.1.1　加载Test类 233
12.1.2　链接Test：校验、准备、（可选的）解析 233
12.1.3　初始化Test：执行初始化器 234
12.1.4　调用Test.main 234
12.2　加载类和接口 235
12.2.1　加载过程 235
12.3　链接类和接口 236
12.3.1　二进制表示的校验 236
12.3.2　类或接口类型的准备 236
12.3.3　符号引用的解析 237
12.4　初始化类和接口 237
12.4.1　当初始化发生时 238
12.4.2　详细的初始化过程 239
12.5　创建新的类实例 241
12.6　类实例的终结 243
12.6.1　实现终结 244
12.6.2　与内存模型的交互 245
12.7　卸载类和接口 246
12.8　程序退出 247
第13章　二进制兼容性 248
13.1　二进制形式 249
13.2　二进制兼容性到底是什么 252
13.3　包的演化 252
13.4　类的演化 253
13.4.1　abstract类 253
13.4.2　final类 253
13.4.3　public类 253
13.4.4　超类和超接口 253
13.4.5　类的类型参数 254
13.4.6　类体和成员声明 255
13.4.7　对成员和构造器的访问权限 256
13.4.8　域声明 257
13.4.9　final域和static
常量变量 258
13.4.10　static域 260
13.4.11　transient域 260
13.4.12　方法和构造器声明 260
13.4.13　方法和构造器的类型参数 261
13.4.14　方法和构造器的形式参数 261
13.4.15　方法返回类型 262
13.4.16　abstract方法 262
13.4.17　final方法 262
13.4.18　native方法 263
13.4.19　static方法 263
13.4.20　synchronized方法 263
13.4.21　方法和构造器的抛出物 263
13.4.22　方法和构造器体 263
13.4.23　方法和构造器的重载 264
13.4.24　方法覆盖 264
13.4.25　静态初始化器 264
13.4.26　枚举的演化 265
13.5　接口的演化 265
13.5.1　public接口 265
13.5.2　超接口 265
13.5.3　接口成员 265
13.5.4　接口的类型参数 266
13.5.5　域声明 266
13.5.6　接口方法声明 266
13.5.7　注解类型的演化 267
第14章　块和语句 268
14.1　语句的正常结束和猝然结束 268
14.2　块 269
14.3　局部类声明 269
14.4　局部变量声明语句 270
14.4.1　局部变量声明符和类型 271
14.4.2　局部变量声明的执行 271
14.5　语句 271
14.6　空语句 272
14.7　标号语句 273
14.8　表达式语句 274
14.9　if语句 274
14.9.1　if-then语句 274
14.9.2　if-then-else语句 275
14.10　assert语句 275
14.11　switch语句 277
14.12　while语句 280
14.12.1　while语句的猝然结束 280
14.13　do语句 281
14.13.1　do语句的猝然结束 281
14.14　for语句 282
14.14.1　基本for语句 282
14.14.2　增强for语句 284
14.15　break语句 285
14.16　continue语句 287
14.17　return语句 288
14.18　throw语句 289
14.19　synchronized语句 290
14.20　try语句 291
14.20.1　try-catch的执行 293
14.20.2　try-finally和try-catch-finally的执行 294
14.20.3　带资源的try 296
14.21　不可达语句 299
第15章　表达式 303
15.1　计算、表示和结果 303
15.2　表达式的形式 303
15.3　表达式的类型 304
15.4　FP-严格的表达式 304
15.5　表达式和运行时检查 305
15.6　计算的正常和猝然结束 306
15.7　计算顺序 307
15.7.1　首先计算左操作数 307
15.7.2　在操作之前计算操作数 308
15.7.3　计算遵循括号和优先级 309
15.7.4　引元列表是自左向右计算的 310
15.7.5　其他表达式的计算顺序 310
15.8　基本表达式 311
15.8.1　词法上的字面常量 312
15.8.2　类字面常量 312
15.8.3　this 313
15.8.4　限定的this 313
15.8.5　带括号的表达式 314
15.9　类实例创建表达式 314
15.9.1　确定要实例化的类 315
15.9.2　确定包围实例 316
15.9.3　选择构造器及其引元 317
15.9.4　类实例创建表达式的运行时计算 319
15.9.5　匿名类声明 320
15.10　数组创建和访问表达式 321
15.10.1　数组创建表达式 321
15.10.2　数组创建表达式的运行时执行 322
15.10.3　数组访问表达式 324
15.10.4　数组访问表达式的运行时计算 324
15.11　域访问表达式 326
15.11.1　使用基本表达式访问域 326
15.11.2　使用super访问超类成员 328
15.12　方法调用表达式 329
15.12.1　编译时的步骤1：确定要搜索的类或接口 330
15.12.2　编译时的步骤2：确定方法签名 332
15.12.3　编译时的步骤3：选中的方法是否合适 342
15.12.4　方法调用的运行时计算 343
15.13　方法引用表达式 350
15.13.1　方法引用的编译时声明 352
15.13.2　方法引用的类型 355
15.13.3　方法引用的运行时计算 356
15.14　后缀表达式 359
15.14.1　表达式名字 359
15.14.2　后缀递增操作符++ 359
15.14.3　后缀递减操作符-- 359
15.15　一元操作符 360
15.15.1　前缀递增操作符++ 361
15.15.2　前缀递减操作符-- 361
15.15.3　一元加号操作符+ 362
15.15.4　一元减号操作符- 362
15.15.5　按位取反操作符~ 362
15.15.6　逻辑取反操作符! 362
15.16　强制类型转换表达式 363
15.17　乘除操作符 364
15.17.1　乘法操作符* 364
15.17.2　除法操作符/ 365
15.17.3　取余操作符% 366
15.18　加减操作符 367
15.18.1　字符串连接操作符+ 368
15.18.2　用于数字类型的加减操作符　（+和-） 369
15.19　移位操作符 371
15.20　关系操作符 371
15.20.1　数字比较操作符<、<=、>和>= 372
15.20.2　类型比较操作符instanceof 372
15.21　判等操作符 373
15.21.1　数字判等操作符==和!= 373
15.21.2　布尔判等操作符==和!= 374
15.21.3　引用判等操作符==和!= 374
15.22　位操作符与逻辑操作符 375
15.22.1　整数位操作符&、^和| 375
15.22.2　布尔逻辑操作符&、^和| 376
15.23　条件与操作符&& 376
15.24　条件或操作符|| 376
15.25　条件操作符? : 377
15.25.1　布尔条件表达式 381
15.25.2　数字型条件表达式 381
15.25.3　引用条件表达式 382
15.26　赋值操作符 383
15.26.1　简单赋值操作符= 383
15.26.2　复合赋值操作符 387
15.27　lambda表达式 391
15.27.1　lambda参数 393
15.27.2　lambda体 394
15.27.3　lambda表达式的类型 397
15.27.4　lambda表达式的运行时计算 398
15.28　常量表达式 399
第16章　明确赋值 400
16.1　明确赋值和表达式 404
16.1.1　布尔常量表达式 404
16.1.2　条件与操作符&& 404
16.1.3　条件或操作符|| 404
16.1.4　逻辑取反操作符! 405
16.1.5　条件操作符? : 405
16.1.6　其他boolean类型的表达式 405
16.1.7　赋值表达式 406
16.1.8　操作符++和-- 406
16.1.9　其他表达式 406
16.2　明确赋值与语句 407
16.2.1　空语句 407
16.2.2　块 407
16.2.3　局部类声明语句 408
16.2.4　局部变量声明语句 408
16.2.5　标号语句 409
16.2.6　表达式语句 409
16.2.7　if语句 409
16.2.8　assert语句 409
16.2.9　switch语句 410
16.2.10　while语句 410
16.2.11　do语句 410
16.2.12　for语句 411
16.2.13　break、continue、return和throw语句 412
16.2.14　synchronized语句 412
16.2.15　try语句 412
16.3　明确赋值与参数 413
16.4　明确赋值与数组初始化器 413
16.5　明确赋值与枚举常量 413
16.6　明确赋值与匿名类 414
16.7　明确赋值与成员类型 414
16.8　明确赋值与静态初始化器 414
16.9　明确赋值、构造器和实例初始化器 415
第17章　线程与锁 416
17.1　同步 416
17.2　等待集和通知 417
17.2.1　等待 417
17.2.2　通知 418
17.2.3　中断 418
17.2.4　等待、通知和中断的交互 418
17.3　睡眠和让步 419
17.4　内存模型 419
17.4.1　共享变量 421
17.4.2　动作 421
17.4.3　程序和程序顺序 422
17.4.4　同步顺序 422
17.4.5　“之前发生”顺序 423
17.4.6　执行 425
17.4.7　良构执行 425
17.4.8　执行和因果关系要求 426
17.4.9　可观察的行为和不终止的执行 428
17.5　final域的语义 429
17.5.1　final域的语义 430
17.5.2　在构造阶段读final域 430
17.5.3　对final域的后续修改 431
17.5.4　写受保护的域 432
17.6　字撕裂 432
17.7　double和long的非原子化处理 433
第18章　类型推断 434
18.1　概念与表示法 435
18.1.1　推断变量 435
18.1.2　约束公式 435
18.1.3　边界 435
18.2　归纳 436
18.2.1　表达式可兼容性约束 437
18.2.2　类型可兼容性约束 440
18.2.3　子类型化约束 440
18.2.4　类型相等性约束 442
18.2.5　受检异常约束 442
18.3　合并 443
18.3.1　互补的边界对 444
18.3.2　涉及捕获转换的边界 444
18.4　解析 445
18.5　推断的使用 446
18.5.1　调用可应用性的推断 447
18.5.2　调用类型的推断 448
18.5.3　函数型接口的参数化版本推断 451
18.5.4　更具体方法的推断 452
第19章　语法 454
索引 470
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言规范
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java编程思想
《java编程思想(第4版)(评注版)》
第1部分 基本语法
operators（新增批注30条） 1
simpler print statements 1
using java operators 2
precedence 2
assignment 3
mathematical operators 4
unary minus and plus operators 6
auto increment and decrement 6
relational operators 7
testing object equivalence 7
logical operators 9
literals 10
exponential notation 11
bitwise operators 12
shift operators 13
ternary if-else operator 16
string operator + and += 17
common pitfalls when using
.operators 18
casting operators 18
truncation and rounding 19
promotion 20
java has no “sizeof ” 20
summary 20
controlling execution
（新增批注21条） 21
true and false 21
if-else 21
iteration 22
do-while 23
for 23
the comma operator 24
foreach syntax 25
return 27
break and continue 27
the infamous “goto” 29
switch 32
summary 34
第2部分 面向对象
initialization & cleanup
（新增批注55条） 35
guaranteed initialization with
the constructor 35
method overloading 37
distinguishing overloaded
methods 39
overloading with primitives 39
overloading on return values 42
default constructors 43
the this keyword 44
calling constructors from
constructors 46
the meaning of static 47
cleanup: finalization and
garbage collection 47
what is finalize() for? 48
you must perform cleanup 49
the termination condition 50
how a garbage collector works 51
member initialization 54
specifying initialization 55
constructor initialization 56
order of initialization 56
static data initialization 57
explicit static initialization 59
non-static instance initialization 61
array initialization 62
variable argument lists 65
enumerated types 70
summary 72
access control
（新增批注21条） 73
package: the library unit 74
code organization 75
creating unique package names 76
a custom tool library 79
java access specifiers 80
package access 80
public: interface access 81
private: you can’t touch that! 82
protected: inheritance access 83
interface and implementation 85
class access 86
summary 87
reusing classes
（新增批注35条） 89
composition syntax 89
inheritance syntax 92
initializing the base class 94
delegation 96
combining composition and
inheritance 97
guaranteeing proper cleanup 99
name hiding 101
choosing composition vs.
inheritance 103
protected 104
upcasting 105
why “upcasting”? 106
composition vs. inheritance
revisited 106
the final keyword 107
final data 107
final methods 110
final classes 112
final caution 113
initialization and class
loading 113
initialization with inheritance 114
summary 115
interfaces
（新增批注16条） 117
abstract classes and methods 117
interfaces 120
“multiple inheritance” in java 123
extending an interface with
inheritance 125
name collisions when combining
interfaces 127
fields in interfaces 127
initializing fields in interfaces 128
interfaces and factories 129
summary 130
inner classes
（新增批注32条） 131
creating inner classes 131
the link to the outer class 133
using .this and .new 134
inner classes and upcasting 135
anonymous inner classes 137
factory method revisited 140
nested classes 142
classes inside interfaces 143
reaching outward from a
multiply nested class 145
why inner classes? 145
closures & callbacks 148
inheriting from inner classes 150
can inner classes be
overridden? 150
local inner classes 152
inner-class identifiers 153
summary 154
error handling with excep- tions（新增批注52条） 155
basic exceptions 155
exception arguments 156
catching an exception 157
the try block 157
exception handlers . 157
creating your own
exceptions 159
exceptions and logging 161
the exception specification 164
catching any exception 164
the stack trace 166
rethrowing an exception 167
exception chaining 169
standard java exceptions 172
special case: runtimeexception 172
performing cleanup with
finally 174
what’s finally for? 175
using finally during return 177
pitfall: the lost exception 178
exception restrictions 180
constructors 182
exception matching 187
alternative approaches 188
passing exceptions to the console 189
summary 189
第3部分 数据存储
strings（新增批注53条） 191
immutable strings 191
overloading ‘+’ vs.
stringbuilder 192
unintended recursion 195
operations on strings 196
formatting output 199
printf() 199
system.out.format() 199
the formatter class 200
format specifiers 200
formatter conversions 202
string.format() 204
regular expressions 205
basics 206
creating regular expressions 208
quantifiers 210
pattern and matcher 211
split() 218
replace operations 218
reset() 220
regular expressions and java i/o 221
scanning input 222
scanner delimiters 224
scanning with regular
expressions 225
stringtokenizer 225
summary 226
arrays（新增批注36条） 227
why arrays are special 227
arrays are first-class objects 228
returning an array 231
multidimensional arrays 232
arrays and generics 235
creating test data 237
arrays.fill() 238
data generators 239
arrays utilities 243
copying an array 243
comparing arrays 244
array element comparisons 245
sorting an array 248
searching a sorted array 249
summary 251
holding your objects
（新增批注35条） 253
generics and type-safe
containers 254
basic concepts 256
adding groups of elements 258
printing containers 259
list 261
iterator 263
listiterator 266
linkedlist 267
stack 268
set 270
map 273
queue 276
priorityqueue 277
collection vs. iterator 279
foreach and iterators 281
the adapter method idiom 283
summary 286
containers in depth
（新增批注102条） 289
full container taxonomy 289
filling containers 290
a generator solution 291
map generators 292
collection functionality 294
optional operations 297
unsupported operations 298
list functionality 300
sets and storage order 302
sortedset 306
queues 307
priority queues 308
deques 309
understanding maps 310
performance 311
sortedmap 314
linkedhashmap 315
hashing and hash codes 316
understanding hashcode() 319
hashing for speed 321
overriding hashcode() 324
choosing an implementation 329
a performance test framework 330
choosing between lists 333
microbenchmarking dangers 338
choosing between sets 339
choosing between maps 341
utilities 344
sorting and searching lists 347
making a collection or map
unmodifiable 349
synchronizing a collection or
map 350
holding references 351
the weakhashmap 353
java 1.0/1.1 containers 355
vector & enumeration 355
hashtable 356
stack 356
bitset 357
summary 359
第4部分 核心功能
i/o（新增批注89条） 361
the file class 361
a directory lister 361
directory utilities 364
checking for and creating
directories 369
input and output 370
types of inputstream 371
types of outputstream 372
adding attributes and useful
interfaces 373
reading from an inputstream
with filterinputstream 374
writing to an outputstream
with filteroutputstream 375
readers & writers 376
sources and sinks of data 377
modifying stream behavior 377
unchanged classes 378
off by itself:
randomaccessfile 379
typical uses of i/o streams 379
buffered input file 379
input from memory 380
formatted memory input 381
basic file output 382
storing and recovering data 383
reading and writing
random-access files 385
piped streams 386
file reading &
writing utilities 386
reading binary files 389
standard i/o 389
reading from standard input 389
changing system.out to a
printwriter 390
redirecting standard i/o 391
process control 391
new i/o 393
converting data 396
fetching primitives 398
view buffers 399
data manipulation with buffers 403
buffer details 404
memory-mapped files 406
file locking 409
compression 411
simple compression with gzip 412
multifile storage with zip 413
java archives (jars) 415
object serialization 416
finding the class 419
controlling serialization 420
using persistence 427
xml 432
summary 434
concurrency
（新增批注117条） 435
basic threading 435
defining tasks 435
the thread class 436
using executors 438
producing return values from
tasks 440
sleeping 442
priority 443
yielding 444
daemon threads 445
coding variations 446
joining a thread 450
catching exceptions 451
sharing resources 454
resolving shared resource
contention 454
atomicity and volatility 457
atomic classes 460
critical sections 462
synchronizing on other objects 462
thread local storage 463
terminating tasks 464
the ornamental garden 465
terminating when blocked 467
interruption 469
cooperation between tasks 475
wait() and notifyall() 475
notify() vs. notifyall() 479
producers and consumers 482
producer-consumers and queues 486
using pipes for i/o between tasks 491
deadlock 492
new library components 497
countdownlatch 497
cyclicbarrier 499
delayqueue 501
priorityblockingqueue 503
the greenhouse controller with
scheduledexecutor 505
semaphore 508
exchanger 511
simulation 513
bank teller simulation 513
the restaurant simulation 517
distributing work 521
performance tuning 526
comparing mutex technologies 526
lock-free containers 532
readwritelocks 533
active objects 535
summary 537
第5部分 高级特性
type information
（新增批注59条） 539
the need for rtti 539
the class object 541
class literals 545
generic class references 547
new cast syntax 549
checking before a cast 550
using class literals 555
a dynamic instanceof 557
counting recursively 558
registered factories 559
instanceof vs. class
equivalence 562
reflection: runtime class
information 563
a class method extractor 564
dynamic proxies 566
null objects 570
mock objects & stubs 575
interfaces and type
information 576
summary 580
generics
（新增批注126条） 583
comparison with c++ 584
simple generics 584
a tuple library 586
a stack class 588
randomlist 589
generic interfaces 590
generic methods 593
leveraging type argument
inference 594
varargs and generic methods 596
a generic method to use with
generators 596
a general-purpose generator 597
simplifying tuple use 598
a set utility 600
anonymous inner classes 603
building complex models 604
the mystery of erasure 606
the c++ approach 607
migration compatibility 609
the problem with erasure 611
the action at the boundaries 612
compensating for erasure 615
creating instances of types 616
arrays of generics 618
bounds 622
wildcards 625
how smart is the compiler? 628
contravariance 629
unbounded wildcards 632
capture conversion 636
issues 637
no primitives as type parameters 637
implementing parameterized
interfaces 639
casting and warnings 640
overloading 641
base class hijacks an interface 642
self-bounded types 642
curiously-recurring generics 643
self-bounding 644
argument covariance 646
dynamic type safety 649
exceptions 650
mixins 651
mixins in c++ 651
mixing with interfaces 653
using the decorator pattern 654
mixins with dynamic proxies 655
latent typing 657
compensating for the lack of
latent typing 660
reflection 661
applying a method to a sequence 662
when you don’t happen
to have the right interface 664
simulating latent typing
with adapters 665
using function objects as
strategies 668
summary: is casting really
so bad? 672
enumerated types
（新增批注55条） 675
basic enum features 675
using static imports with enums 676
adding methods to an enum 677
overriding enum methods 678
enums in switch statements 678
the mystery of values() 679
implements, not inherits 681
random selection 682
using interfaces for
organization 683
using enumset instead of
flags 686
using enummap 688
constant-specific methods 689
chain of responsibility with
enums 692
state machines with enums 695
multiple dispatching 700
dispatching with enums 702
using constant-specific methods 704
dispatching with enummaps 705
using a 2-d array 706
summary 707
annotations
（新增批注51条） 709
basic syntax 710
defining annotations 710
meta-annotations 712
writing annotation processors 712
annotation elements 713
default value constraints 713
generating external files 714
annotations don’t
support inheritance 717
implementing the processor 717
using apt to process
annotations 719
using the visitor pattern with
apt 723
annotation-based unit testing 726
using @unit with generics 733
no “suites” necessary 735
implementing @unit 735
removing test code 741
sum
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java编程思想
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java异步编程实战
前言
第1章　认识异步编程1
1.1　异步编程概念与作用1
1.2　异步编程场景2
1.3　总结9
第2章　显式使用线程和线程池实现异步编程10
2.1　显式使用线程实现异步编程10
2.2　显式使用线程池实现异步编程14
2.2.1　如何显式使用线程池实现异步编程14
2.2.2　线程池ThreadPoolExecutor原理剖析17
2.3　总结34
第3章　基于JDK中的Future实现异步编程35
3.1　JDK 中的Future35
3.2　JDK中的FutureTask37
3.2.1　FutureTask 概述37
3.2.2　FutureTask的类图结构41
3.2.3　FutureTask的run() 方法45
3.2.4　FutureTask的get()方法48
3.2.5　FutureTask的cancel(boolean mayInterruptIfRunning)方法50
3.2.6　FutureTask的局限性52
3.3　JDK中的CompletableFuture52
3.3.1　CompletableFuture 概述52
3.3.2　显式设置CompletableFuture结果54
3.3.3　基于CompletableFuture实现异步计算与结果转换56
3.3.4　多个CompletableFuture进行组合运算65
3.3.5　异常处理68
3.3.6　CompletableFuture概要原理70
3.4　JDK8 Stream & CompletableFuture76
3.4.1　JDK8 Stream76
3.4.2　当Stream遇见CompletableFuture79
3.5　总结81
第4章　Spring框架中的异步执行82
4.1　Spring中对TaskExecutor的抽象82
4.2　如何在Spring中使用异步执行84
4.2.1　使用TaskExecutor实现异步执行84
4.2.2　使用注解@Async实现异步执行89
4.3　@Async注解异步执行原理96
4.4　总结109
第5章　基于反应式编程实现异步编程110
5.1　反应式编程概述110
5.2　Reactive Streams规范120
5.3　基于RxJava实现异步编程123
5.4　基于Reactor实现异步编程133
5.5　总结136
第6章　Web Servlet的异步非阻塞处理137
6.1　Servlet概述137
6.2　Servlet 3.0 提供的异步处理能力138
6.3　Servlet 3.1 提供的非阻塞IO能力145
6.4　Spring Web MVC 的异步处理能力153
6.4.1　基于DeferredResult的异步处理154
6.4.2　基于Callable实现异步处理155
6.5　总结157
第7章　Spring WebFlux的异步非阻塞处理158
7.1　Spring WebFlux概述158
7.2　Reactive编程 & Reactor库159
7.3　WebFlux服务器160
7.4　WebFlux的并发模型163
7.5　WebFlux对性能的影响164
7.6　WebFlux的编程模型164
7.6.1　WebFlux注解式编程模型165
7.6.2　WebFlux函数式编程模型168
7.7　WebFlux原理浅尝171
7.7.1　Reactor Netty概述171
7.7.2　WebFlux服务器启动流程173
7.7.3　WebFlux一次服务调用流程182
7.8　WebFlux的适用场景185
7.9　总结186
第8章　高性能异步编程框架和中间件187
8.1　异步、基于事件驱动的网络编程框架—Netty187
8.1.1　Netty概述187
8.1.2　Netty的线程模型190
8.1.3　TCP半包与粘包问题196
8.1.4　基于Netty与CompletableFuture实现RPC异步调用198
8.2　高性能RPC框架—Apache Dubbo209
8.2.1　Apache Dubbo概述209
8.2.2　Dubbo的异步调用210
8.2.3　Dubbo的异步执行214
8.3　高性能线程间消息传递库—Disruptor217
8.3.1　Disruptor概述217
8.3.2　Disruptor的特性详解220
8.3.3　基于Disruptor实现异步编程223
8.4　异步、分布式、基于消息驱动的框架—Akka227
8.4.1　Akka概述227
8.4.2　传统编程模型存在的问题228
8.4.3　Actor模型解决了传统编程模型的问题232
8.4.4　基于Akka实现异步编程237
8.5　高性能分布式消息框架—Apache RocketMQ244
8.5.1　Apache RocketMQ概述244
8.5.2　基于Apache RocketMQ实现系统间异步解耦246
8.6　总结254
第9章　Go语言的异步编程能力255
9.1　Go语言概述255
9.2　Go语言的线程模型256
9.2.1　一对一模型256
9.2.2　多对一模型257
9.2.3　多对多模型258
9.2.4　Go语言的线程模型259
9.3　goroutine与channel261
9.3.1　goroutine261
9.3.2　channel265
9.3.3　构建管道实现异步编程269
9.4　总结273
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java异步编程实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java技术手册（第6版）
序 xv
前言 xvi
第一部分　Java 介绍
第1 章　Java 环境介绍 2
1．1　Java 语言、JVM 和生态系统 2
1．1．1　Java 语言是什么 3
1．1．2　JVM 是什么 4
1．1．3　Java 生态系统是什么 5
1．2　Java 和JVM 简史 6
1．3　Java 程序的生命周期 7
1．4　Java 的安全性 9
1．5　Java 和其他语言比较 9
1．5．1　Java 和C 语言比较 9
1．5．2　Java 和C++ 比较 10
1．5．3　Java 和PHP 比较 10
1．5．4　Java 和JavaScript 比较 10
1．6　回应对Java 的一些批评 10
1．6．1　过度复杂 10
1．6．2　变化慢 11
1．6．3　性能问题 12
1．6．4　不安全 12
1．6．5　太注重企业 12
第2 章　Java 基本句法 13
2．1　Java 程序概览 14
2．2　词法结构 14
2．2．1　Unicode 字符集 14
2．2．2　区分大小写与空白 14
2．2．3　注释 15
2．2．4　保留字 16
2．2．5　标识符 16
2．2．6　字面量 17
2．2．7　标点符号 17
2．3　基本数据类型 17
2．3．1　布尔类型 18
2．3．2　字符类型 18
2．3．3　整数类型 20
2．3．4　浮点数类型 21
2．3．5　基本类型之间的转换 22
2．4　表达式和运算符 24
2．4．1　运算符概述 25
2．4．2　算术运算符 28
2．4．3　字符串连接运算符 30
2．4．4　递增和递减运算符 30
2．4．5　比较运算符 31
2．4．6　逻辑运算符 32
2．4．7　位运算符和位移运算符 33
2．4．8　赋值运算符 35
2．4．9　条件运算符 36
2．4．10　instanceof 操作符 36
2．4．11　特殊运算符 37
2．5　语句 38
2．5．1　表达式语句 39
2．5．2　复合语句 39
2．5．3　空语句 39
2．5．4　标注语句 40
2．5．5　局部变量声明语句 40
2．5．6　if/else 语句 41
2．5．7　switch 语句 43
2．5．8　while 语句 45
2．5．9　do 语句 45
2．5．10　for 语句 46
2．5．11　遍历语句 47
2．5．12　break 语句 48
2．5．13　continue 语句 49
2．5．14　return 语句 49
2．5．15　synchronized 语句 50
2．5．16　throw 语句 50
2．5．17　try/catch/finally 语句 51
2．5．18　处理资源的try 语句 53
2．5．19　assert 语句 54
2．6　方法 55
2．6．1　定义方法 55
2．6．2　方法修饰符 57
2．6．3　已检异常和未检异常 59
2．6．4　变长参数列表 60
2．7　介绍类和对象 61
2．7．1　定义类 62
2．7．2　创建对象 62
2．7．3　使用对象 63
2．7．4　对象字面量 63
2．7．5　lambda 表达式 64
2．8　数组 65
2．8．1　数组的类型 65
2．8．2　创建和初始化数组 67
2．8．3　使用数组 68
2．8．4　多维数组 70
2．9　引用类型 72
2．9．1　引用类型与基本类型比较 72
2．9．2　处理对象和引用副本 73
2．9．3　比较对象 74
2．9．4　装包和拆包转换 75
2．10　包和Java 命名空间 76
2．10．1　声明包 76
2．10．2　全局唯一的包名 77
2．10．3　导入类型 77
2．10．4　导入静态成员 79
2．11　Java 文件的结构 80
2．12　定义并运行Java 程序 81
2．13　小结 82
第3 章　Java 面向对象编程 83
3．1　类简介 83
3．1．1　面向对象的基本概念 83
3．1．2　其他引用类型 84
3．1．3　定义类的句法 85
3．2　字段和方法 85
3．2．1　声明字段的句法 86
3．2．2　类字段 87
3．2．3　类方法 88
3．2．4　实例字段 89
3．2．5　实例方法 89
3．2．6　this 引用的工作方式 90
3．3　创建和初始化对象 91
3．3．1　定义构造方法 91
3．3．2　定义多个构造方法 92
3．3．3　在一个构造方法中调用另一个构造方法 92
3．3．4　字段的默认值和初始化程序 93
3．4　子类和继承 95
3．4．1　扩展类 95
3．4．2　超类、对象和类层次结构 97
3．4．3　子类的构造方法 98
3．4．4　构造方法链和默认构造方法 98
3．4．5　遮盖超类的字段 100
3．4．6　覆盖超类的方法 101
3．5　数据隐藏和封装 104
3．5．1　访问控制 105
3．5．2　数据访问器方法 110
3．6　抽象类和方法 111
3．7　修饰符总结 115
第4 章　Java 类型系统 117
4．1　接口 118
4．1．1　定义接口 118
4．1．2　扩展接口 119
4．1．3　实现接口 119
4．1．4　实现多个接口 121
4．1．5　默认方法 121
4．1．6　标记接口 123
4．2　Java 泛型 123
4．2．1　介绍泛型 124
4．2．2　泛型和类型参数 125
4．2．3　菱形句法 126
4．2．4　类型擦除 126
4．2．5　通配符 127
4．2．6　编译时和运行时类型 131
4．3　枚举和注解 131
4．3．1　枚举 131
4．3．2　注解 133
4．3．3　自定义注解 134
4．3．4　类型注解 135
4．4　嵌套类型 135
4．4．1　静态成员类型 136
4．4．2　非静态成员类 138
4．4．3　局部类 141
4．4．4　词法作用域和局部变量 144
4．4．5　匿名类 145
4．4．6　嵌套类型的运作方式 147
4．5　lambda 表达式 148
4．5．1　转换lambda 表达式 150
4．5．2　方法引用 150
4．5．3　函数式编程 151
4．6　小结 152
第5 章　Java 的面向对象设计 154
5．1　Java 的值 154
5．2　java．lang．Object 类的重要方法 155
5．2．1　toString() 方法 157
5．2．2　equals() 方法 157
5．2．3　hashCode() 方法 158
5．2．4　Comparable：：compareTo() 方法 158
5．2．5　clone() 方法 159
5．3　面向对象设计要略 159
5．3．1　常量 159
5．3．2　用接口还是抽象类 160
5．3．3　实例方法还是类方法 161
5．3．4　合成还是继承 163
5．3．5　字段继承和访问器 165
5．3．6　单例 167
5．4　异常和异常处理 168
5．5　Java 编程的安全性 170
第6 章　Java 实现内存管理和并发编程的方式 172
6．1　Java 内存管理的基本概念 172
6．1．1　Java 中的内存泄露 173
6．1．2　标记清除算法简介 173
6．1．3　基本标记清除算法 174
6．2　JVM 优化垃圾回收的方式 175
6．3　HotSpot 堆 178
6．3．1　回收老年代 178
6．3．2　其他回收程序 179
6．4　终结机制 180
6．5　Java 对并发编程的支持 181
6．5．1　线程的生命周期 182
6．5．2　可见性和可变性 184
6．5．3　互斥和状态保护 185
6．5．4　volatile 关键字 187
6．5．5　Thread 类中有用的方法 188
6．6　使用线程 190
6．7　小结 192
第二部分　使用Java 平台
第7 章　编程和文档约定 194
7．1　命名和大小写约定 194
7．2　实用的命名方式 196
7．3　Java 文档注释 197
7．3．1　文档注释的结构 198
7．3．2　文档注释标签 198
7．3．3　行内文档注释标签 201
7．3．4　文档注释中的交叉引用 203
7．3．5　包的文档注释 204
7．4　可移植程序的约定 205
第8 章　使用Java 集合 208
8．1　介绍集合API 208
8．1．1　Collection 接口 209
8．1．2　Set 接口 211
8．1．3　List 接口 213
8．1．4　Map 接口 217
8．1．5　Queue 接口和BlockingQueue 接口 220
8．1．6　实用方法 222
8．1．7　数组和辅助方法 224
8．2　在Java 集合框架中使用lambda 表达式 225
8．2．1　函数式方式 226
8．2．2　流API 229
8．3　小结 232
第9 章　处理常见的数据格式 233
9．1　文本 233
9．1．1　字符串的特殊句法 233
9．1．2　字符串的不可变性 235
9．1．3　正则表达式 237
9．2　数字和数学运算 240
9．2．1　Java 表示整数类型的方式 240
9．2．2　Java 中的浮点数 241
9．2．3　Java 的数学函数标准库 243
9．3　在Java 8 中处理日期和时间 245
9．3．1　介绍Java 8 的日期和时间API 245
9．3．2　查询 248
9．3．3　调节器 249
9．3．4　过时的日期和时间API 250
9．4　小结 251
第10 章　处理文件和I/O 252
10．1　Java 处理I/O 的经典方式 252
10．1．1　文件 253
10．1．2　流 254
10．1．3　Reader 和Writer 类 255
10．1．4　再次介绍TWR 256
10．1．5　I/O 经典处理方式的问题 257
10．2　Java 处理I/O 的现代方式 257
10．2．1　文件 258
10．2．2　路径 259
10．3　NIO 中的通道和缓冲区 261
10．3．1　ByteBuffer 对象 261
10．3．2　映射字节缓冲区 263
10．4　异步I/O 263
10．4．1　基于Future 接口的方式 264
10．4．2　基于回调的方式 264
10．4．3　监视服务和目录搜索 265
10．5　网络 266
10．5．1　HTTP 266
10．5．2　TCP 268
10．5．3　IP 270
第11 章　类加载、反射和方法句柄 271
11．1　类文件、类对象和元数据 271
11．1．1　类对象示例 271
11．1．2　类对象和元数据 272
11．2　类加载的各个阶段 273
11．2．1　加载 273
11．2．2　验证 274
11．2．3　准备和解析 274
11．2．4　初始化 275
11．3　安全的编程和类加载 276
11．4　应用类加载知识 277
11．5　反射 280
11．5．1　什么时候使用反射 280
11．5．2　如何使用反射 280
11．6　动态代理 284
11．7　方法句柄 285
11．7．1　MethodType 对象 285
11．7．2　方法查找 286
11．7．3　调用方法句柄 287
第12 章　Nashorn 289
12．1　介绍Nashorn 289
12．1．1　在JVM 中运行Java 之外的语言 289
12．1．2　目的 290
12．2　在Nashorn 中执行JavaScript 代码 290
12．2．1　在命令行中运行 291
12．2．2　使用Nashorn shell 291
12．2．3　在jjs 中编写脚本 293
12．3　Nashorn 和javax．script 包 297
12．4　Nashorn 的高级用法 299
12．4．1　在Nashorn 中调用Java 代码 299
12．4．2　Nashorn 对JavaScript 语言所做的扩展 302
12．4．3　实现细节 303
12．5　小结 304
第13 章　平台工具和配置 306
13．1　命令行工具 306
13．1．1　javac 307
13．1．2　java 309
13．1．3　jar 310
13．1．4　javadoc 312
13．1．5　jdeps 313
13．1．6　jps 314
13．1．7　jstat 315
13．1．8　jstatd 315
13．1．9　jinfo 316
13．1．10　jstack 317
13．1．11　jmap 317
13．1．12　javap 318
13．2　VisualVM 318
13．3　Java 8 配置 324
13．3．1　目的 324
13．3．2　紧凑配置 325
13．4　小结 328
作者简介 329
封面介绍 329
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java技术手册（第6版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Hibernate（第2版）
目录
第1章 Java应用分层架构及软件模型	1
1.1 应用程序的分层体系结构	1
1.1.1 区分物理层和逻辑层	2
1.1.2 软件层的特征	3
1.1.3 软件分层的优点	4
1.1.4 软件分层的缺点	4
1.1.5 Java应用的持久化层	5
1.2 软件的模型	6
1.2.1 概念模型	7
1.2.2 关系数据模型	8
1.2.3 域模型	10
1.2.4 域对象	10
1.2.5 域对象之间的关系	11
1.2.6 域对象的持久化概念	17
1.3 小结	19
1.4 思考题	19
第2章 Java对象持久化技术概述	21
2.1 直接通过JDBC API来持久化实体域对象	21
2.2 ORM简介	27
2.2.1 对象-关系映射的概念	29
2.2.2 ORM中间件的基本使用方法	31
2.2.3 常用的ORM中间件	33
2.3 实体域对象的其他持久化模式	34
2.3.1 主动域对象模式	35
2.3.2 JDO模式	37
2.3.3 CMP模式	37
2.4 Hibernate API简介	38
2.4.1 Hibernate的核心接口	39
2.4.2 事件处理接口	41
2.4.3 Hibernate映射类型接口	41
2.4.4 可供扩展的接口	42
2.5 小结	43
2.6 思考题	45
第3章 第一个Hibernate应用	47
3.1 创建Hibernate的配置文件	47
3.2 创建持久化类	48
3.3 创建数据库Schema	51
3.4 创建对象-关系映射文件	52
3.4.1 映射文件的文档类型定义（DTD）	52
3.4.2 把Customer持久化类映射到CUSTOMERS表	54
3.5 通过Hibernate API操纵数据库	58
3.5.1 Hibernate的初始化	61
3.5.2 访问Hibernate的Session接口	63
3.6 运行helloapp应用	67
3.6.1 创建运行本书范例的系统环境	67
3.6.2 创建helloapp应用的目录结构	72
3.6.3 把helloapp应用作为独立应用程序运行	73
3.6.4 把helloapp应用作为Java Web应用运行	77
3.7 小结	78
3.8 思考题	80
第4章 hbm2java和hbm2ddl工具	83
4.1 创建对象-关系映射文件	83
4.1.1 定制持久化类	85
4.1.2 定制数据库表	88
4.2 建立项目的目录结构	90
4.3 运行hbm2java工具	93
4.4 运行hbm2ddl工具	94
4.5 使用XML格式的配置文件	96
4.6 小结	97
4.7 思考题	98
第5章 对象-关系映射基础	101
5.1 持久化类的属性及访问方法	101
5.1.1 基本类型属性和包装类型属性	102
5.1.2 Hibernate访问持久化类属性的策略	104
5.1.3 在持久化类的访问方法中加入程序逻辑	104
5.1.4 设置派生属性	107
5.1.5 控制insert和update语句	108
5.2 处理SQL引用标识符	109
5.3 创建命名策略	110
5.4 设置数据库Schema	112
5.5 设置类的包名	113
5.6 运行本章的范例程序	114
5.7 小结	120
5.8 思考题	121
第6章 映射对象标识符	123
6.1 关系数据库按主键区分不同的记录	123
6.1.1 把主键定义为自动增长标识符类型	123
6.1.2 从序列（Sequence）中获取自动增长的标识符	124
6.2 Java语言按内存地址区分不同的对象	125
6.3 Hibernate用对象标识符（OID）来区分对象	126
6.4 Hibernate的内置标识符生成器的用法	128
6.4.1 increment标识符生成器	131
6.4.2 identity标识符生成器	133
6.4.3 sequence标识符生成器	134
6.4.4 hilo标识符生成器	135
6.4.5 native标识符生成器	137
6.5 映射自然主键	138
6.5.1 映射单个自然主键	138
6.5.2 映射复合自然主键	140
6.6 小结	143
6.7 思考题	144
第7章 映射一对多关联关系	147
7.1 建立多对一的单向关联关系	148
7.1.1 <many-to-one>元素的not-null属性	153
7.1.2 级联保存和更新	155
7.2 映射一对多双向关联关系	156
7.2.1 <set>元素的inverse属性	161
7.2.2 级联删除	163
7.2.3 父子关系	164
7.3 映射一对多双向自身关联关系	165
7.4 改进持久化类	171
7.5 小结	175
7.6 思考题	176
第8章 通过Hibernate操纵对象（上）	179
8.1 Java对象在JVM中的生命周期	179
8.2 理解Session的缓存	181
8.2.1 Session的缓存的作用	182
8.2.2 脏检查及清理缓存的机制	184
8.3 Java对象在Hibernate持久化层的状态	187
8.3.1 临时对象的特征	188
8.3.2 持久化对象的特征	189
8.3.3 被删除对象的特征	190
8.3.4 游离对象的特征	191
8.4 Session接口的详细用法	191
8.4.1 Session的save()和persist()方法	191
8.4.2 Session的load()和get()方法	194
8.4.3 Session的update()方法	195
8.4.4 Session的saveOrUpdate()方法	197
8.4.5 Session的merge()方法	198
8.4.6 Session的delete()方法	200
8.4.7 Session的replicate()方法	201
8.5 级联操纵对象图	202
8.5.1 级联保存临时对象	206
8.5.2 更新持久化对象	207
8.5.3 持久化临时对象	207
8.5.4 更新游离对象	209
8.5.5 遍历对象图	210
8.6 小结	211
8.7 思考题	211
第9章 通过Hibernate操纵对象（下）	215
9.1 与触发器协同工作	215
9.2 利用拦截器（Interceptor）生成审计日志	217
9.3 Hibernate的事件处理机制	224
9.4 批量处理数据	226
9.4.1 通过Session来进行批量操作	227
9.4.2 通过StatelessSession来进行批量操作	229
9.4.3 通过HQL来进行批量操作	230
9.4.4 直接通过JDBC API来进行批量操作	232
9.5 使用元数据	233
9.6 通过Hibernate调用存储过程	234
9.7 小结	234
9.8 思考题	235
第10章 映射组成关系	237
10.1 建立精粒度对象模型	238
10.2 建立粗粒度关系数据模型	239
10.3 映射组成关系	240
10.3.1 区分值（Value）类型和实体（Entity）类型	242
10.3.2 在应用程序中访问具有组成关系的持久化类	244
10.4 映射复合组成关系	247
10.5 小结	248
10.6 思考题	249
第11章 Hibernate的映射类型	251
11.1 Hibernate的内置映射类型	251
11.1.1 Java基本类型的Hibernate映射类型	251
11.1.2 Java时间和日期类型的Hibernate映射类型	252
11.1.3 Java大对象类型的Hibernate映射类型	253
11.1.4 JDK自带的个别Java类的Hibernate映射类型	253
11.1.5 使用Hibernate内置映射类型	254
11.2 客户化映射类型	256
11.2.1 用客户化映射类型取代Hibernate组件	260
11.2.2 用UserType映射枚举类型	263
11.2.3 实现CompositeUserType接口	266
11.2.4 运行本节范例程序	271
11.3 操纵Blob和Clob类型数据	279
11.4 小结	284
11.5 思考题	284
第12章 映射继承关系	287
12.1 继承关系树的每个具体类对应一个表	288
12.1.1 创建映射文件	289
12.1.2 操纵持久化对象	290
12.2 继承关系树的根类对应一个表	293
12.2.1 创建映射文件	294
12.2.2 操纵持久化对象	296
12.3 继承关系树的每个类对应一个表	297
12.3.1 创建映射文件	298
12.3.2 操纵持久化对象	300
12.4 选择继承关系的映射方式	302
12.5 映射多对一多态关联	305
12.6 小结	308
12.7 思考题	309
第13章 Java集合类	311
13.1 Set（集）	312
13.1.1 Set的一般用法	312
13.1.2 HashSet类	313
13.1.3 TreeSet类	315
13.1.4 向Set中加入持久化类的对象	319
13.2 List（列表）	320
13.3 Map（映射）	321
13.4 小结	325
13.5 思考题	326
第14章 映射值类型集合	327
14.1 映射Set（集）	327
14.2 映射Bag（包）	331
14.3 映射List（列表）	334
14.4 映射Map	337
14.5 对集合排序	339
14.5.1 在数据库中对集合排序	340
14.5.2 在内存中对集合排序	341
14.6 映射组件类型集合	345
14.7 小结	350
14.8 思考题	351
第15章 映射实体关联关系	353
15.1 映射一对一关联	353
15.1.1 按照外键映射	354
15.1.2 按照主键映射	358
15.2 映射单向多对多关联	361
15.3 映射双向多对多关联关系	365
15.3.1 关联两端使用<set>元素	366
15.3.2 在inverse端使用<bag>元素	367
15.3.3 使用组件类集合	371
15.3.4 把多对多关联分解为两个一对多关联	376
15.4 小结	378
15.5 思考题	379
第16章 Hibernate的检索策略	381
16.1 Hibernate的检索策略简介	383
16.2 类级别的检索策略	386
16.2.1 立即检索	387
16.2.2 延迟检索	387
16.3 一对多和多对多关联的检索策略	390
16.3.1 立即检索（lazy属性为“false”）	392
16.3.2 延迟检索（lazy属性为默认值“true”）	392
16.3.3 增强延迟检索（lazy属性为“extra”）	393
16.3.4 批量延迟检索和批量立即检索（使用batch-size属性）	393
16.3.5 用带子查询的select语句整批量初始化orders集合（fetch属性为“subselect”）	396
16.3.6 迫切左外连接检索（fetch属性为“join”）	397
16.4 多对一和一对一关联的检索策略	398
16.4.1 迫切左外连接检索（fetch属性为“join”）	398
16.4.2 延迟检索（lazy属性为默认值“proxy”）	400
16.4.3 无代理延迟检索（lazy属性为“no-proxy”）	401
16.4.4 立即检索（lazy属性为“false”）	401
16.4.5 批量延迟检索和批量立即检索（使用batch-size属性）	402
16.5 控制迫切左外连接检索的深度	405
16.6 在应用程序中显式指定迫切左外连接检索策略	408
16.7 属性级别的检索策略	408
16.8 小结	409
16.9 思考题	411
第17章 Hibernate的检索方式（上）	413
17.1 Hibernate的检索方式简介	413
17.1.1 HQL检索方式	416
17.1.2 QBC检索方式	417
17.1.3 本地SQL检索方式	419
17.1.4 关于本章范例程序	420
17.1.5 使用别名	421
17.1.6 多态查询	421
17.1.7 对查询结果排序	422
17.1.8 分页查询	423
17.1.9 检索单个对象（uniqueResult()方法）	424
17.1.10 按主键逐个处理查询结果（iterate()方法）	425
17.1.11 可滚动的结果集	426
17.1.12 在HQL查询语句中绑定参数	428
17.1.13 设置查询附属事项	433
17.1.14 在映射文件中定义命名查询语句	436
17.1.15 在HQL查询语句中调用函数	438
17.2 设定查询条件	439
17.2.1 比较运算	440
17.2.2 范围运算	441
17.2.3 字符串模式匹配	442
17.2.4 逻辑运算	443
17.2.5 集合运算	444
17.3 小结	445
17.4 思考题	446
第18章 Hibernate的检索方式（下）	449
18.1 连接查询	449
18.1.1 默认情况下关联级别的运行时检索策略	450
18.1.2 迫切左外连接	451
18.1.3 左外连接	453
18.1.4 内连接	457
18.1.5 迫切内连接	461
18.1.6 隐式内连接	463
18.1.7 右外连接	464
18.1.8 使用SQL风格的交叉连接和隐式内连接	466
18.1.9 关联级别运行时的检索策略	467
18.2 投影查询	468
18.3 报表查询	471
18.3.1 使用聚集函数	471
18.3.2 分组查询	472
18.3.3 优化报表查询的性能	475
18.4 高级查询技巧	475
18.4.1 动态查询	476
18.4.2 集合过滤	478
18.4.3 子查询	480
18.4.4 本地SQL查询	482
18.4.5 查询结果转换器	484
18.5 查询性能优化	486
18.5.1 iterate()方法	486
18.5.2 查询缓存	487
18.6 小结	488
18.7 思考题	489
第19章 Hibernate高级配置	491
19.1 配置数据库连接池	491
19.1.1 使用默认的数据库连接池	494
19.1.2 使用配置文件指定的数据库连接池	495
19.1.3 从容器中获得数据源	495
19.1.4 由Java应用本身提供数据库连接	497
19.2 配置事务类型	497
19.3 把SessionFactory与JNDI绑定	500
19.4 配置日志	502
19.5 使用XML格式的配置文件	505
19.6 小结	507
19.7 思考题	508
第20章 声明数据库事务	511
20.1 数据库事务的概念	511
20.2 声明事务边界的方式	513
20.3 在mysql.exe程序中声明事务	515
20.4 Java应用通过JDBC API声明JDBC事务	517
20.5 Java应用通过Hibernate API声明JDBC事务	518
20.5.1 处理异常	520
20.5.2 Session与事务的关系	522
20.5.3 设定事务超时	525
20.6 Java应用通过Hibernate API声明JTA事务	525
20.7 Java应用通过JTA API声明JTA事务	526
20.8 小结	529
20.9 思考题	530
第21章 处理并发问题	533
21.1 多个事务并发运行时的并发问题	533
21.1.1 第一类丢失更新	534
21.1.2 脏读	535
21.1.3 虚读	535
21.1.4 不可重复读	536
21.1.5 第二类丢失更新	536
21.2 数据库系统的锁的基本原理	537
21.2.1 锁的多粒度性及自动锁升级	538
21.2.2 锁的类型和兼容性	538
21.2.3 死锁及其防止办法	540
21.3 数据库的事务隔离级别	541
21.3.1 在mysql.exe程序中设置隔离级别	543
21.3.2 在应用程序中设置隔离级别	543
21.4 在应用程序中采用悲观锁	544
21.4.1 利用数据库系统的独占锁来实现悲观锁	544
21.4.2 由应用程序实现悲观锁	550
21.5 利用Hibernate的版本控制来实现乐观锁	550
21.5.1 使用<version>元素	551
21.5.2 使用<timestamp>元素	556
21.5.3 对游离对象进行版本检查	558
21.5.4 强制更新版本	559
21.6 实现乐观锁的其他方法	559
21.7 小结	560
21.8 思考题	561
第22章 管理Hibernate的缓存	563
22.1 缓存的基本原理	563
22.1.1 持久化层的缓存的范围	564
22.1.2 持久化层的缓存的并发访问策略	566
22.2 Hibernate的二级缓存结构	568
22.3 管理Hibernate的第一级缓存	569
22.4 管理Hibernate的第二级缓存	570
22.4.1 配置进程范围内的第二级缓存	571
22.4.2 配置集群范围内的第二级缓存	575
22.4.3 在应用程序中管理第二级缓存	578
22.4.4 Session与第二级缓存的交互模式	578
22.5 运行本章的范例程序	579
22.6 小结	583
22.7 思考题	584
第23章 管理Session和实现对话	587
23.1 管理Session对象的生命周期	587
23.1.1 Session对象的生命周期与本地线程绑定	590
23.1.2 Session对象的生命周期与JTA事务绑定	592
23.2 实现对话	593
23.2.1 使用游离对象	595
23.2.2 使用手工清理缓存模式下的Session	597
23.3 小结	603
23.4 思考题	605
第24章 Hibernate与Struts框架	607
24.1 实现业务数据	609
24.2 实现业务逻辑	612
24.3 netstore应用的订单业务	622
24.4 小结	626
第25章 Hibernate与EJB组件 	629
25.1 创建EJB组件 	629
25.1.1 编写Remote接口	629
25.1.2 编写Home接口	631
25.1.3 编写Enterprise Java Bean类	631
25.2 在业务代理类中访问EJB组件 	633
25.3 发布J2EE应用 	638
25.3.1 在JBoss上部署EJB组件 	638
25.3.2 在JBoss上部署Web应用 	639
25.3.3 在JBoss上部署J2EE应用 	640
25.4 小结 	642
附录A 标准SQL语言的用法 	643
A.1 数据完整性 	644
A.1.1 实体完整性 	644
A.1.2 域完整性 	644
A.1.3 参照完整性 	644
A.2 DDL数据定义语言 	644
A.3 DML数据操纵语言 	646
A.4 DQL数据查询语言 	647
A.4.1 简单查询 	648
A.4.2 连接查询 	648
A.4.3 子查询 	651
A.4.4 联合查询 	652
A.4.5 报表查询 	652
附录B Java语言的反射机制 	655
B.1 Java Reflection API简介 	655
B.2 运用反射机制来持久化Java对象 	658
附录C 用XDoclet工具生成映射文件 	665
C.1 创建带有@hibernate标记的Java源文件 	665
C.2 建立项目的目录结构 	669
C.3 运行XDoclet工具 	672
附录D 发布和运行netstore应用 	675
D.1 运行netstore所需的软件 	675
D.2 netstore应用的目录结构 	676
D.3 安装SAMPLEDB数据库 	677
D.4 安装和配置JBoss服务器 	677
D.5 发布netstore应用 	679
D.5.1 在工作模式1下发布netstore应用 	679
D.5.2 在工作模式2下发布netstore应用 	679
D.6 运行netstore应用 	680
附录E Hibernate 3升级指南 	685
E.1 Hibernate API 变化 	685
E.1.1 包名 	685
E.1.2 org.hibernate.classic包 	685
E.1.3 Hibernate所依赖的第三方软件包 	686
E.1.4 异常模型 	686
E.1.5 Session接口 	686
E.1.6 createSQLQuery()	687
E.1.7 Lifecycle 和 Validatable 接口 	687
E.1.8 Interceptor接口 	687
E.1.9 UserType和CompositeUserType接口 	687
E.1.10 FetchMode类 	688
E.1.11 PersistentEnum类 	688
E.1.12 对Blob 和Clob的支持 	688
E.1.13 Hibernate中供扩展的API的变化 	688
E.2 元数据的变化 	688
E.2.1 检索策略 	688
E.2.2 对象标识符的映射 	688
E.2.3 集合映射 	689
E.2.4 DTD 	689
E.3 查询语句的变化 	689
E.4 把Hibernate 2应用升级到Hibernate 3应用 	690
附录F 思考题答案 	691
参考文献 	693
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Hibernate（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java解惑
第1章 绪论
第2章 表达式之谜
谜题1：奇数性.
谜题2：找零时刻
谜题3：长整除
谜题4：初级问题
谜题5：十六进制的趣事
谜题6：多重转型
谜题7：互换内容
谜题8：Dos Equis
谜题9：半斤
谜题10：八两
第3章 字符之谜
谜题11：最后的笑声
谜题12：ABC
谜题13：动物庄园
谜题14：转义字符的溃败
谜题15：令人晕头转向的Hello
谜题16：行打印程序
谜题17：嗯?
谜题18：字符串奶酪
谜题19：漂亮的火花(块注释符)
谜题20：我的类是什么
谜题21：我的类是什么?镜头2
谜题22：URL的愚弄
谜题23：不劳无获
第4章 循环之谜
谜题24：尽情享受每一个字节
谜题25：无情的增量操作
谜题26：在循环中
谜题27：变幻莫测的i值
谜题28：循环者
谜题29：循环者的新娘
谜题30：循环者的爱子
谜题31：循环者的鬼魂
谜题32：循环者的诅咒
谜题33：循环者遇到了狼人
谜题34：被计数击倒了
谜题35：分分钟
第5章 异常之谜
谜题36：优柔寡断
谜题37：极端不可思议
谜题38：不受欢迎的宾客
谜题39：您好，再见
谜题40：不情愿的构造器
谜题41：域和流
谜题42：异常为循环而抛
谜题43：异常地危险
谜题44：删除类..
谜题45：令人疲惫不堪的测验
第6章 类之谜
谜题46：令人混淆的构造器案例
谜题47：啊呀!狸猫变犬子
谜题48：我所得到的都是静态的
谜题49：比生命更大
谜题50：不是你的类型
谜题51：要点何在
谜题52：总和的玩笑
谜题53：做你的事吧
谜题54：Null与Void
谜题55：特创论
箔7章 库之谜
谜题56：大问题
谜题57：名字里有什么
谜题58：产生它的散列码
谜题59：差是什么
谜题60：一行以毙之
谜题61：日期游戏
谜题62：名字游戏
谜题63：更多同样的问题
谜题64：按余数编组
谜题65：疑似排序的惊人传奇
第8章 更多类之谜
谜题66：一件私事
谜题67：对字符串上瘾
谜题68：灰色的阴影
谜题69：黑色的渐隐
谜题70：一揽子交易
谜题71：进口税
谜题72：终极危难
谜题73：隐私在公开
谜题74：同一性的危机
谜题75：头还是尾?
名字重用的术语表
第9章 更多库之谜
谜题76：乒乓
谜题77：乱锁之妖
谜题78：反射的污染
谜题79：狗狗的幸福生活
谜题80：更深层的反射
谜题81：无法识别的字符化
谜题82：啤酒爆炸
谜题83：诵读困难者的一神论
谜题84：戛然而止
谜题85：惰性初始化
第10章 高级谜题
谜题86：有害的括号垃圾
谜题87：紧张的关系
谜题88：原生类型的处理
谜题89：泛型迷药
谜题90：荒谬痛苦的超类
谜题91：序列杀手
谜题92：双绞线
谜题93：类的战争
谜题94：迷失在混乱中
谜题95：来份甜点
附录A 陷阱和缺陷的目录
A．1 词汇问题
A．2 整数运算
A．3 浮点运算
A．4 表达式计算
A．5 控制流
A．6 类初始化
A．7 实例的创建与销毁
A．8 其他与类和实例相关的主题
A．9 名字重用
A．10 字符串
A．11 I/O
A．12 线程
A．13 反射
A．14 序列化
A．15 其他库...
附录B 书中幻图的注释
索引
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java解惑
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java夜未眠
[励志篇]
1 学习，是一条漫长的道路
2 写程式，好好玩
3 如何进入程式设计的领域
4 职业敏感度
5 从美丽的菲奥莉娜说起
6 走出你的成功之路
7 从 a 到 e+
[牢骚篇]
8 香鸡排首部曲：程式与香鸡排
9 香鸡排二部曲：再论香鸡排
10 香鸡排三部曲：完结篇
11 software rush
12 ain't no sunshine anymore?
13 e化声声催，e化路迢迢
14 我的座右铭
15 一个java信仰者的告解
[生涯篇]
.16 程式员的生涯规划
17 软体人才何处寻？
18 软体产业的知识经济
19 认证无用论？
20 认证有用论？
21 软体与性
[图书篇]
22 你说挑书就像挑老师一样，我说你乱有思想的
23 苦恨年年压金线，为他人作嫁衣裳
24 必也正名乎
25 偶像崇拜（一）
26 偶像崇拜（二）
27 偶像崇拜（三）
偶像崇拜（四）
[程序设计学习篇]
28 java标准简介
29 java学习之道
30 摩登原始人
31 你该学什么程序语言？
32 语言、平台、程式库
34 oooo
35 debug
[软体工程篇]
36 design pattern新解
37 软体产业的大洪水
38 没人在乎软体工程
39 软体工程的吊诡
40 版本控制
[系统篇]
41 不可能的任务
42 垃圾！
43 java相关的编译技术
44 实现java平台的三种方式
45 变数的种类
46 shit happens, part i
47 shit happens, part ii
48 用xml设计一个你自己的程式语言
49 java繁体中文处理完全攻略
50 编译、反编译、反反编译
51 static 的意义与实作方式
[杂感]
52 an open e-mail
53 散文随笔系列文章暂停
54 极短篇：王伯伯启示录
55 叫专家，太沈重
56 比赛杂感
[书评]
java in a nutshell a desktop quick reference
java examples in a nutshell
java threads, 2nd ed.
database programming with jdbc and java, 2nd edtion
java swing, 2nd ed.
java 2d graphics
java virtual machine
enterprise javabeans, 2nd edition
java internationalization
java message service
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java夜未眠
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>操作系统概念——Java 实现（第七版）
第一部分 概述
第1章 导论
第2章 操作系统结构
第二部分 进程管理
第3章 进程
第4章 线程
第5章 CPU调度
第6章 进程同步
第7章 死锁
第三部分 内存管理
第8章 内存管理
第9章 虚拟内存
第四部分 存储管理
第10章 文件系统接口
第11章 文件系统实现
第12章 大容量存储器的结构
第13章 I／O输入系统
第五部分 保护与安全
第14章 保护
第15章 安全
第六部分 分布式系统
第16章 分布式系统结构
第17章 分布式文件系统
第18章 分布式协调
第七部分 特殊用途系统
第19章 实时系统
第20章 多媒体系统
第八部分 案例研究
第21章 Linux系统
第22章 Windows XP
第23章 有影响的操作系统
参考文献
原版相关内容引用表
英汉名词对照表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>操作系统概念——Java 实现（第七版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>全端Web开发
前言　　xiii
第1章　因变而变　　1
1.1　Web用户　　2
1.2　技术　　2
1.3　软件开发　　3
1.4　哪些没变　　4
1.4.1　Web 的本质　　5
1.4.2　为什么说服务器驱动的Web开发有害　　6
1.5　为什么需要客户端- 服务器端的Web应用　　7
1.5.1　代码组织结构/ 软件架构　　7
1.5.2　“设计的灵活性”与“使用开源API”　　7
1.5.3　原型　　7
1.5.4　开发者的效率　　8
1.5.5　应用性能　　8
1.6　小结　　9
第2章　JavaScript和JavaScript工具　　11
2.1　学习JavaScript　　12
2.2　JavaScript的历史　　13
2.3　一门函数式语言　　14
2.3.1　作用域　　15
2.3.2　一级函数　　16
2.3.3　函数声明和表达式　　17
2.3.4　函数调用　　19
2.3.5　函数参数　　19
2.3.6　对象　　20
2.4　面向Java开发者的JavaScript　　20
2.4.1　HelloWord.java　　20
2.4.2　带变量的HelloWord.java　　23
2.5　最佳开发实践　　25
2.5.1　编码规范和约定　　25
2.5.2　浏览器　　26
2.5.3　集成开发环境　　26
2.5.4　单元测试　　27
2.5.5　文档　　27
2.6　项目　　27
第3章 　REST和JSON　　33
3.1　什么是REST　　34
3.1.1　资源　　34
3.1.2　动词（HTTP请求）　　34
3.1.3　统一资源标识符　　35
3.2　REST约束　　36
3.2.1　客户端- 服务器端　　36
3.2.2　无状态　　36
3.2.3　可缓存　　37
3.2.4　统一接口　　37
3.2.5　分层　　38
3.2.6　按需交付代码　　38
3.3　HTTP响应代码　　38
3.4　JSON　　39
3.5　HATEOAS　　40
3.6　API衡量和分类　　43
3.7　函数式编程和REST　　43
3.8　项目　　44
3.9　其他Web API工具　　48
3.10　约束回顾　　48
第4章　Java工具　　49
4.1　Java语言　　49
4.2　Java虚拟机　　50
4.3　Java工具　　51
4.4　构建工具　　52
4.4.1　Maven的优点　　54
4.4.2　Maven的功能　　54
4.4.3　版本控制　　55
4.4.4　单元测试　　56
4.5　处理JSON的Java 类库　　56
4.6　项目　　57
4.6.1　用Java处理JSON　　57
4.6.2　用JVM上的脚本语言处理JSON　　59
4.7　小结　　62
第5章　客户端框架　　65
5.1　概述　　65
5.2　起点一：响应式Web设计　　67
5.2.1　HTML5 Boilerplate　　68
5.2.2　Bootstrap　　68
5.3　起点二：JavaScript库和框架　　69
5.3.1　浏览器兼容性　　69
5.3.2　框架　　69
5.3.3　功能　　70
5.3.4　流行程度　　70
5.4　获取起始项目　　71
5.4.1　直接从仓库下载　　71
5.4.2　从入门网站下载　　71
5.4.3　IDE生成的起始项目　　72
5.5　前端工程师的崛起　　72
5.5.1　客户端模板　　72
5.5.2　资源管道　　73
5.5.3　开发流程　　74
5.6　项目　　74
5.7　小结　　76
第6章　Java Web API服务器　　77
6.1　更简单的服务器端解决方案　　77
6.2　基于Java的服务器　　79
6.2.1　Java HTTP服务器　　79
6.2.2　Jetty嵌入式服务器　　81
6.2.3　Restlet　　82
6.2.4　Roo　　83
6.2.5　Netty嵌入式服务器　　87
6.2.6　Play服务器　　89
6.2.7　其他轻量级服务器　　92
6.3　基于JVM的服务器　　92
6.4　Web应用服务器　　93
6.5　如何在开发中使用　　94
6.6　小结　　94
第7章 　快速开发实践　　95
7.1　开发者的生产率　　95
7.2　优化开发者和团队的工作流程　　98
7.2.1　例子：修复Web应用　　99
7.2.2　例子：测试集成　　100
7.2.3　例子：绿地开发　　101
7.3　生产率和软件开发生命周期　　101
7.3.1　管理方式和企业文化　　102
7.3.2　技术架构　　102
7.3.3　软件工具　　103
7.3.4　性能　　104
7.3.5　测试　　104
7.3.6　底层平台　　105
7.4　小结　　106
第8章　API设计　　107
8.1　设计的起点　　108
8.2　实用的Web API与REST API　　109
8.3　指引　　110
8.3.1　名词即资源，动词即HTTP 行为　　110
8.3.2　请求参数作为修饰符　　 111
8.3.3　Web API版本　　112
8.3.4　HTTP 标头　　113
8.3.5　链接　　113
8.3.6　响应　　113
8.3.7　文档　　113
8.3.8　格式约定　　114
8.3.9　安全性　　114
8.4　项目　　114
8.4.1　运行项目　　114
8.4.2　服务端代码　　115
8.4.3　Curl和jQuery　　117
8.5　实践理论　　118
第9章　jQuery和Jython　　119
9.1　服务端：Jython　　120
9.1.1　Python Web服务器　　120
9.1.2　Jython Web服务器　　120
9.1.3　Mock API　　121
9.2　客户端：jQuery　　122
9.2.1　DOM遍历和操作　　122
9.2.2　实用函数　　123
9.2.3　效果　　124
9.2.4　事件处理　　124
9.2.5　Ajax　　124
9.3　jQuery和更高级的抽象　　125
9.4　项目　　125
9.4.1　基础HTML　　126
9.4.2　JavaScript和jQuery　　126
9.5　小结　　128
第10章　JRuby和Angular　　129
10.1　服务器端：JRuby和Sinatra　　130
10.1.1　工作流　　130
10.1.2　交互式Ruby shell　　131
10.1.3　Ruby版本管理器　　131
10.1.4　包　　132
10.1.5　Sinatra　　133
10.1.6　JSON处理　　134
10.2　客户端：AngularJS　　135
10.2.1　模型　　135
10.2.2　视图　　135
10.2.3　控制器　　136
10.2.4　服务　　136
10.3　比较jQuery和Angular　　136
10.3.1　DOM和模型操作　　136
10.3.2　Angular的不可见性　　137
10.4　项目　　137
10.5　小结　　143
第11章　打包和部署　　145
11.1　打包Java和JEE 应用　　145
11.2　JEE 应用的部署　　147
11.2.1　图形界面管理　　148
11.2.2　命令行管理　　150
11.3　非JEE应用的部署　　151
11.3.1　服务器在应用之外　　152
11.3.2　服务器和应用并行　　152
11.3.3　服务器在应用里面　　154
11.4　不同部署方式带来的影响　　154
11.4.1　负载均衡　　155
11.4.2　自动化应用部署　　156
11.5　项目　　157
11.5.1　客户端　　157
11.5.2　服务器端　　158
11.6　小结　　158
第12章　虚拟化　　159
12.1　全虚拟化　　159
12.2　虚拟机的实现　　161
12.2.1　VMWare　　161
12.2.2　VirtualBox　　161
12.2.3　Amazon EC2　　161
12.3　虚拟机的管理　　162
12.3.1　Vagrant　　162
12.3.2　Packer　　162
12.3.3　DevOps配置管理　　163
12.4　容器　　163
12.4.1　LXC　　164
12.4.2　Docker　　164
12.5　项目　　165
12.5.1　Docker帮助　　166
12.5.2　镜像和容器的维护　　166
12.5.3　在Docker里使用Java　　167
12.5.4　Docker和Vagrant 的网络设置　　169
12.6　小结　　170
第13章　测试和文档　　171
13.1　测试的种类　　172
13.1.1　“正式”与“非正式”　　172
13.1.2　测试范围　　172
13.1.3　谁来测？测什么？为谁测　　173
13.2　测试反映了组织的成熟度　　173
13.2.1　使用软件能力成熟度模型评价流程　　173
13.2.2　使用Maven促进流程统一　　174
13.2.3　使用行为驱动开发促进流程统一　　176
13.3　测试框架　　176
13.3.1　JUnit　　177
13.3.2　Jasmine　　177
13.3.3　Cucumber　　178
13.4　项目　　179
13.4.1　JUnit　　180
13.4.2　Jasmine　　180
13.4.3　Cucumber　　181
13.4.4　Maven报告　　181
13.5　小结　　182
第14章　总结　　183
14.1　社区　　183
14.2　历史　　184
14.3　尾声　　184
附录A　JRuby IRB及Java API　　185
附录B　REST式的Web API总结　　191
附录C　参考文献　　196
关于作者　　197
关于封面图　　197
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>全端Web开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序员，上班那点事儿
第一篇 生存法则
第1章 知己知彼，百战不殆
1.1 问题1：这个职业赚钱吗？赚多少钱
1.1.1 修炼第一层境界：剑指四方，试问天下谁与争锋
1.1.2 修炼第二层境界：世界如此之大，要学的东西很多
1.1.3 修炼第三层境界：最深即最浅，最浅即最深，不过如此
1.1.4 点评“修炼三层境界”
1.1.5 回答这个问题
1.2 问题2：大学毕业生找不到职业入口
1.2.1 工作经验都是什么经验
1.2.2 他们为什么面试的时候这么问？
1.2.3 程序员的笔试
1.2.4 回答这个问题
1.3 问题3：跨行业真的这么难吗？
1.3.1 跨行业最难的是什么
1.3.2 跨行业的入口——原来从事行业的业务知识
1.3.3 农民造出了飞机，为什么他还是农民
1.3.4 回答这个问题
1.4 秘诀：经营自己的优势
1.4.1 善于发掘和积累自己的优势
1.4.2 善于展示与利用自己的优势
1.5 点评“经营自我”
第2章 软件开发职业的误区
2.1 误区1：软件开发职业是青春饭
2.1.1 不必为30岁以后烦恼
2.1.2 岁以后照样可以编程序
2.1.3 多岁的程序员多的是
2.1.4 点评“青春饭”
2.2 误区2：做软件开发必须要加班熬夜的工作
2.2.1 程序员们熬夜工作的借口
2.2.2 常态加班的危害
2.2.3 控制好工作的一日时间表才是关键
2.2.4 “偏执与狂热”不等于加班加点
2.2.5 程序员的大脑与第二大脑
2.2.6 点评“加班熬夜”
2.3 误区3：开发一个软件产品一定是集团作战
2.3.1 几百人的公司其他人都在干什么
2.3.2 需要较全的人员配置的项目
2.3.3 坚信，只要是“人”做到的我就能做到
2.3.4 点评“集团作战”
2.4 误区4：程序员不是一般人
2.4.1 程序员的与众不同与平凡
2.4.2 程序员们就是一般人
2.4.3 点评“一般人”
2.5 误区5：存在“软件蓝领”岗位
2.5.1 “软件蓝领”是个“美梦”
2.5.2 “让程序员放弃思考？”是个“噩梦”
2.5.3 软件开发流程“理想”的“不理想”
2.5.4 “软件蓝领概念”忽略的东西
2.5.5 现实中的软件开发团队
2.5.6 点评“拧螺丝”
2.6 关于误区
第3章 程序员的“菜鸟心态综合症”
3.1 症状1：指望着公司里有一个老师
3.1.1 临床表现
3.1.2 治疗1：弄明白她为什么辞职
3.1.3 治疗2：理解公司的本质是什么
3.1.4 治疗3：要搞清楚你的主管是你的老板，他绝对不是你的老师
3.2 症状2：不知道怎么让自己前进
3.2.1 临床表现
3.2.2 治疗1：你只管低着头上山，暂时不要向山上看
3.2.3 治疗2：明知山有虎，偏向虎山行
3.2.4 治疗3：没有过不去的火焰山
3.2.5 治疗4：虚心使人进步，骄傲自满要不得
3.3 症状3：想做圈养的羊，不想做野生的狼
3.3.1 临床表现
3.3.2 治疗1：理解“丛林法则”生存的法则
3.3.3 治疗2：向掠食动物学习如何生存
3.4 症状4：缺乏自信，总对自己说No
3.4.1 临床表现
3.4.2 治疗1：生活取决于自己
3.4.3 治疗2：找到通往高楼的那扇门
3.4.4 治疗3：逐个排除你恐惧的理由
3.5 症状5：缺少幸福感，内心总在跳跃
3.5.1 临床表现
3.5.2 治疗1：比一比到底谁最幸福
3.5.3 治疗2：要努力进取也要找到幸福的理由
3.6 症状6：困兽心态，焦躁与不安
3.6.1 临床表现
3.6.2 治疗1：像猴子一样生活
3.6.3 治疗2：多和团队成员沟通
3.7 症状7：缺少感激心，心存感激让你受益匪浅
3.7.1 临床表现
3.7.2 治疗1：心存感激不等于低人一等
3.7.3 治疗2：首先应该对你的领导心存感激
3.7.4 真心换真心
3.8 症状8：不知道什么是“团队合作”
3.8.1 临床表现
3.8.2 治疗1：分析在公司上班的三个目标
3.8.3 治疗2：团队合作——就是团队主管的目标
3.9 点评“心态”
第4章 换位思考，项目主管的招聘技巧
4.1 招聘就像大海捞针
4.2 技巧1：是否有独立完成项目的经验
4.2.1 独立完成一个项目的经验是什么经验
4.2.2 没有独立生存的能力不能有最佳团队合作
4.2.3 测试手段
4.2.4 锻炼攻略：需要主动寻找独立工作的机会
4.3 技巧2：是否有独立解决问题的能力
4.3.1 见招拆招的能力
4.3.2 程序员的韧性
4.3.3 测试手段
4.3.4 锻炼攻略：训练创意思维
4.4 技巧3：评价程序员的思考方式
4.4.1 一切皆程序
4.4.2 找到规律
4.4.3 锻炼攻略：抓住中心把复杂的事情变简单
4.5 点评“换位思考”
第5章 程序员，保持你前进的步伐
5.1 程序员前进的四个阶段
5.1.1 第一阶段，找到一个编程语言去入门
5.1.2 第二阶段，用所这门语言去分析和推理
5.1.3 第三个阶段，新知识新技术的积累
5.1.4 第四个阶段，大道无形
5.2 学习与积累
5.2.1 找到好书，相当于找到一个好老师
5.2.2 每本书都没有从头看到尾是不是等于不用功？
5.2.3 学会建立沉淀目录
第二卷 制胜法宝
第6章 Java程序员的七种武器
6.1 武器1：编程IDE开发工具
6.1.1 Team Leader的嗜好
6.1.2 什么功能是程序员最需要的
6.1.3 下面这些IDE你都用得到
6.1.4 点评“开发工具”
6.2 武器2：数据库系统
6.2.1 广告与市场的力量
6.2.2 不要盲目选择数据库，根据用途选择合适的数据库
6.2.3 以下这些数据库绝不能仅仅是“眼熟”
6.2.4 研究一下JDBC源程序
6.2.5 不熟悉数据库就会“绕远”
6.2.6 点评“真相”
6.3 武器3：Web服务器软件
6.3.1 Web服务器是如何工作的
6.3.2 支持JSP的Web服务器的原理
6.3.3 常用的WebServer
6.3.4 研究一下Web Server的源程序
6.3.5 点评“深入研究”
6.4 武器4：操作系统
6.4.1 让我们看看这个招聘启事
6.4.2 Java程序员为什么需要研究操作系统
6.4.3 我们应该更关心操作系统的哪些方面
6.4.4 哪些操作系统我们要重点关注
6.4.5 点评“Linux”
6.5 武器5：编程语言
6.5.1 Java程序员只会Java语言行吗
6.5.2 各个编程语言的特长
6.5.3 点评“第二门语言”
6.6 武器6：辅助设计工具
6.6.1 UML图设计工具
6.6.2 常用UML设计工具
6.6.3 UML要“灵活”的掌握
6.7 武器7：版本控制工具
6.7.1 工作原理
6.7.2 常用版本控制工具
6.7.3 融入团队的开发氛围
6.8 点评“武器”
第7章 破除Java开发中的封建迷信
7.1 迷信1：Java占内存到底大不大
7.1.1 测试一：让程序去裸奔
7.1.2 测试二：针尖对麦芒
7.1.3 让人不再“迷信”的测试结果
7.1.4 先天与后天
7.2 迷信2：Java和C到底谁快
7.2.1 测试一：让程序转起来
7.2.2 测试二：读取个大文件吧
7.2.3 测试三：内存处理的速度
7.2.4 测试结果分析
7.2.5 也不要过于迷信C语言
7.2.6 Java语言与C语言之间的应用比较
7.3 迷信3：Java就等于JSP吗
7.3.1 一个面试的现象
7.3.2 JSP开发时间长了的误解
7.3.3 Java的纯真年代
7.3.4 Java绝对不等于JSP
7.3.5 努力保持一个纯真的心态
7.3.6 点评“纯真”
7.4 迷信5：C/S与B/S相比一无是处
7.4.1 B/S是一个很好的创意
7.4.2 B/S程序本身也是一个C/S程序
7.4.3 C/S程序的优势——速度
7.4.4 C/S程序的应用领域
7.5 迷信6：J2EE的开发必须用EJB
7.5.1 EJB真人真事
7.5.2 我们不禁要问，什么是“服务集群”？什么是“企业级开发”？
7.5.3 把EJB掰开了揉碎了
7.5.4 EJB的最底层究竟是什么
7.5.5 EJB中所谓的“服务群集”
7.5.6 这种部署难道是无懈可击
7.5.7 EJB活学活用，J2EE不是必须使用EJB
7.5.8 “技术”不是神，不要动不动就“崇拜”
7.6 点评“迷信”
第8章 揭秘中大型应用系统
8.1 何谓“中大型应用系统”？
8.2 无法学习与模拟
8.3 资深程序员的“经验”
8.4 为什么要熟悉系统的运行环境
8.5 带你进机房里去看看硬件设备
8.5.1 机房的基本情况
8.5.2 U的概念
8.5.3 机房中的设备
8.5.4 在机房里发现了什么
8.6 安全与效率——永恒的主题
8.6.1 绝对安全是不存在的
8.6.2 RAID
8.6.3 负载均衡
8.6.4 双机、集群的配置模式
8.6.5 网络流量与速率
8.6.6 带宽
8.7 一个软硬件部署方案实例
8.8 点评“经验”
第9章 为什么要学习用框架开发
9.1 学习框架是因为它“火”
9.2 使用框架开发的好处
9.2.1 框架的目的是简化编程工作
9.2.2 框架是一个应用程序的半成品
9.2.3 框架的好处是代码重用
9.3 框架不仅仅只有“SSH”
9.3.1 WebWork
9.3.2 EasyJWeb
9.3.3 Click
9.3.4 JBlooming
9.4 用框架的思想去“自由思考”
9.5 自己也可以试着做一个
9.5.1 先看看不用框架怎么编写程序
9.5.2 从应用程序中找到共性的东西
9.5.3 我们试着做一个最简单的框架
9.5.4 有了这个框架开发工作被简化
9.6 点评“自由思考”
第三卷 达人策略
第10章 高手有多高菜鸟有多菜
10.1 五年工作经验的“菜鸟”
10.2 高手是怎样炼成的
10.2.1 修炼1：Java悟道
10.2.2 修炼2：关注程序的品质
10.2.3 修炼3：“技术”与“技巧”都很重要
10.2.4 修炼4：走入Java的底层程序开发
10.2.5 修炼5：从Worker到Maker
10.3 点评“高手有多高，菜鸟有多菜”
第11章 控制内存的功力
11.1 别指望Java和内存无关
11.2 容易被搞晕的——堆和栈
11.2.1 堆——用new建立，垃圾自动回收负责回收
11.2.2 栈——存放基本数类型，速度快
11.2.3 何谓栈的“数据共享”
11.2.4 实例化对象的两种方法
11.3 内存控制心中有数
11.3.1 两个读取内存信息函数
11.3.2 开发Java程序内存看的见
11.3.3 必须要介绍的虚拟机的参数“-Xmx”
11.4 内存控制效率优化的启示
11.4.1 启示1：String和StringBuffer的不同之处
11.4.2 启示2：用“-Xmx”参数来提高内存可控制量
11.4.3 启示3：二维数组比一维数组占用更多内存空间
11.4.4 启示4：用HashMap提高内存查询速度
11.4.5 启示5：用“arrayCopy()”提高数组截取速度
11.5 内存垃圾回收问题
11.5.1 什么是内存垃圾，哪些内存符合垃圾的标准
11.5.2 JVM垃圾回收的相关知识
11.6 点评“功力”
第12章 产品和项目是程序员永恒的主题
12.1 项目和产品
12.1.1 “产品”的定义
12.1.2 “项目”的定义
12.1.3 “产品”和“项目”的区别
12.2 软件产品开发是“艺术”
12.2.1 软件产品开发需要灵感
12.2.2 程序作品是你的一个传世的艺术作品
12.2.3 软件产品开发需要“前瞻性”
12.3 软件项目开发是“军事行动”
12.3.1 开发者就是这个程序的“三军统帅”
12.3.2 “项目”开发需要“运筹帷幄”
12.3.3 项目控制，一艘船的故事
12.3.4 点评“军事行动”
第13章 非技术知识对工作的辅助
13.1 辅助1：“英语”不需要专业，因为它只是工具
13.1.1 英语与编程序无关
13.1.2 用英语可以看一些英文文档
13.1.3 掌握基本的工作交流时的英语词汇
13.2 辅助2：“Google”不是万能的，但不会用万万不能
13.2.1 在网页标题中搜索关键字：intitle
13.2.2 在特定站点中搜索关键字：site
13.2.3 在url链接中搜索关键字：inurl
13.2.4 精确匹配搜索：双引号
13.2.5 搜索结果中不希望含某特定查询词：减号
13.3 辅助3：程序员的常用文档写作
13.3.1 程序员在软件开发过程中需要提交的文档
13.3.2 程序员在日常工作中需要提交的文档
13.4 点评“非技术”
结束语
致谢
读者来信选登
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序员，上班那点事儿
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java入门经典
第1章　成为程序员
1.1　选择编程语言
1.2　告诉计算机做什么
1.3　程序的工作原理
1.4　为什么程序不能正常工作
1.5　选择Java编程工具
1.6　安装Java开发工具
1.7　总结
1.8　问与答
1.9　测验
1.9.1　问题
1.9.2　答案
1.10　练习
第2章　编写第一个程序
2.1　编写程序所需的工具
2.2　创建Saluton程序
2.3　开始输入程序
2.3.1　class语句
2.3.2　main语句的作用
2.3.3　大括号
2.4　在变量中存储信息
2.5　保存编写好的程序
2.6　将程序编译为class文件
2.7　修复错误
2.8　运行Java程序
2.9　总结
2.10　问与答
2.11　测验
2.11.1　问题
2.11.2　答案
2.12　练习
第3章　Java之旅
3.1　第一站：Oracle
3.2　去Java学校
3.3　在JavaWorld用午餐
3.4　在NASA仰望天穹
3.5　回归正题
3.6　到Java Boutique去问路
3.7　在手机上运行Java
3.8　总结
3.9　问与答
3.10　测验
3.10.1　问题
3.10.2　答案
3.11　练习
第4章　理解Java程序的工作原理
4.1　创建应用程序
4.2　向应用程序传递参数
4.3　创建applet
4.4　总结
4.5　问与答
4.6　测验
4.6.1　问题
4.6.2　答案
4.7　练习
第5章　在程序中存储和修改信息
5.1　语句和表达式
5.2　指定变量类型
5.2.1　整数和浮点数
5.2.2　字符和字符串
5.2.3　其他数值类型的变量
5.2.4　布尔型变量
5.3　给变量命名
5.4　在变量中存储信息
5.5　运算符
5.5.1　变量的递增与递减
5.5.2　运算符优先级
5.6　使用表达式
5.7　总结
5.8　问与答
5.9　测验
5.9.1　问题
5.9.2　答案
5.10　练习
第6章　使用字符串来交流
6.1　在字符串中存储文本
6.2　在程序中显示字符串
6.3　在字符串中使用特殊字符
6.4　拼接字符串
6.5　将其他变量用于字符串中
6.6　字符串的高级处理
6.6.1　比较两个字符串
6.6.2　确定字符串的长度
6.6.3　改变字符串的大小写
6.6.4　查找字符串
6.7　导演及演员名单
6.8　总结
6.9　问与答
6.10　测验
6.10.1　问题
6.10.2　答案
6.11　练习
第7章　使用条件测试进行判断
7.1　if语句
7.1.1　小于和大于的比较
7.1.2　相等和不等
7.1.3　使用块语句组织程序
7.2　if-else语句
7.3　switch语句
7.4　条件运算符
7.5　观察时钟
7.6　总结
7.7　问与答
7.8　测验
7.8.1　问题
7.8.2　答案
7.9　练习
第8章　使用循环重复执行操作
8.1　for循环
8.2　while循环
8.3　do-while循环
8.4　退出循环
8.5　给循环命名
8.6　测试计算机的运行速度
8.7　总结
8.8　问与答
8.9　测验
8.9.1　问题
8.9.2　答案
8.10　练习
第9章　使用数组存储信息
9.1　创建数组
9.2　使用数组
9.3　多维数组
9.4　对数组进行排序
9.5　对字符串中的字符计数
9.6　总结
9.7　问与答
9.8　测验
9.8.1　问题
9.8.2　答案
9.9　练习
第10章　创建第一个对象
10.1　面向对象编程的工作原理
10.2　对象示例
10.3　什么是对象
10.4　理解继承
10.5　建立继承层次
10.6　转换对象和简单变量
10.6.1　简单变量的类型转换
10.6.2　对象类型转换
10.6.3　在简单变量和对象之间进行转换
10.6.4　自动封装和拆封
10.7　创建对象
10.8　总结
10.9　问与答
10.10　测验
10.10.1　问题
10.10.2　答案
10.11　练习
第11章　描述对象
11.1　创建变量
11.2　创建类变量
11.3　用方法来创建行为
11.3.1　声明方法
11.3.2　参数不同的类似方法
11.3.3　构造函数
11.3.4　类方法
11.3.5　方法中变量的作用域
11.4　将一个类放在另一个类中
11.5　使用关键字this
11.6　使用类方法和类变量
11.7　总结
11.8　问与答
11.9　　测验
11.9.1　问题
11.9.2　答案
11.10　练习
第12章　充分利用现有对象
12.1　继承的威力
12.1.1　继承行为和属性
12.1.2　覆盖方法
12.2　建立继承
12.3　使用现有的对象
12.4　将相同类型的对象存储到Vector中
12.5　创建子类
12.6　总结
12.7　问与答
12.8　测验
12.8.1　问题
12.8.2　答案
12.9　练习
第13章　创建简单的用户界面
13.1　Swing和抽象窗口工具包
13.2　使用组件
13.2.1　窗口和框架
13.2.2　按钮
13.2.3　标签和文本框
13.2.4　复选框
13.2.5　组合框
13.2.6　文本区域
13.2.7　面板
13.3　创建自己的组件
13.4　总结
13.5　问与答
13.6　测验
13.6.1　问题
13.6.2　答案
13.7　练习
第14章　用户界面的布局
14.1　使用布局管理器
14.1.1　GridLayout管理器
14.1.2　BorderLayout管理器
14.1.3　BoxLayout管理器
14.1.4　使用Insets将组件隔开
14.2　应用程序的界面布局
14.3　总结
14.4　问与答
14.5　测验
14.5.1　问题
14.5.2　答案
14.6　练习
第15章　响应用户输入
15.1　让程序监听
15.2　设置要监听的组件
15.3　处理用户事件
15.3.1　复选框和组合框事件
15.3.2　键盘事件
15.3.3　启用和禁用组件
15.4　完善图形应用程序
15.5　总结
15.6　问与答
15.7　测验
15.7.1　问题
15.7.2　答案
15.8　练习
第16章　创建复杂的用户界面
16.1　滚动窗格
16.2　滑块
16.3　变更监听器
16.4　使用图像图标和工具栏
16.5　总结
16.6　问与答
16.7　测验
16.7.1　问题
16.7.2　答案
16.8　练习
第17章　创建交互式Web程序
17.1　标准applet方法
17.1.1　在applet窗口中绘画
17.1.2　初始化applet
17.1.3　启动和停止applet
17.1.4　销毁applet
17.2　将applet放到Web页面中
17.3　创建applet
17.3.1　在applet窗口中绘画
17.3.2　测试SalutonApplet程序
17.4　从Web页面传递参数
17.5　在applet中接收参数
17.6　在applet中处理参数
17.7　使用object标记
17.8　总结
17.9　问与答
17.10　测验
17.10.1　问题
17.10.2　答案
17.11　练习
第18章　处理程序中的错误
18.1　异常
18.1.1　在try-catch块中捕获异常
18.1.2　捕获多种不同的异常
18.1.3　出现异常后进行处理
18.1.4　抛出异常
18.1.5　忽略异常
18.2　抛出和捕获异常
18.3　总结
18.4　问与答
18.5　测验
18.5.1　问题
18.5.2　答案
18.6　练习
第19章　创建线程程序
19.1　线程
19.1.1　降低程序的速度
19.1.2　创建线程
19.2　使用线程
19.2.1　声明类
19.2.2　创建变量
19.3　从init()开始
19.4　在创建URL时捕获错误
19.5　在paint()方法中处理屏幕更新
19.6　启动线程
19.6.1　运行线程
19.6.2　停止线程
19.7　处理鼠标单击
19.8　循环显示链接
19.9　总结
19.10　问与答
19.11　测验
19.11.1　问题
19.11.2　答案
19.12　练习
第20章　读写文件
20.1　流
20.1.1　文件
20.1.2　从流中读取数据
20.1.3　缓冲输入流
20.2　将数据写入流中
20.3　读写配置属性
20.4　总结
20.5　问与答
20.6　测验
20.6.1　问题
20.6.2　答案
20.7　练习
第21章　读写XML数据
21.1　创建XML文件
21.2　读取XML文件
21.3　读取RSS聚合内容(Syndication Feeds)
21.4　总结
21.5　问与答
21.6　测验
21.6.1　问题
21.6.2　答案
21.7　练习
第22章　利用JAX-WS开发Web服务
22.1　定义服务端点接口
使用注解来简化Java代码
22.2　创建服务实现Bean
22.3　发布Web服务
22.4　使用Web服务描述语言文件
22.5　创建Web服务客户端
22.6　总结
22.7　问与答
22.8　测验
22.8.1　问题
22.8.2　答案
22.9　练习
第23章　创建Java2D图形
23.1　使用Font类
23.2　使用Color类
23.3　创建自定义颜色
23.4　绘制直线和形状
23.4.1　绘制直线
23.4.2　绘制矩形
23.4.3　绘制椭圆和圆
23.4.4　绘制弧线
23.5　绘制饼图
23.6　总结
23.7　问与答
23.8　测验
23.8.1　问题
23.8.2　答案
23.9　练习
第24章　编写Android app
24.1　Android简介
24.2　创建Android app
24.2.1　剖析一个Android新项目
24.2.2　创建app
24.2.3　安装Android模拟器
24.2.4　创建调试配置
24.3　运行app
24.4　设计真实的app
24.4.1　组织资源
24.4.2　配置app的Manifest文件
24.4.3　设计用户界面
24.4.4　编写Java代码
24.5　总结
24.6　问与答
24.7　测验
24.7.1　问题
24.7.2　答案
24.8　练习
附录A　使用NetBeans IDE
A.1　安装NetBeans
A.2　创建新项目
A.3　创建新的Java类
A.4　运行应用程序
A.5　修复错误
附录B　Java资源
B.1　可以考虑的其他书
B.2　Oracle公司的Java官方站点
B.3　其他Java站点
B.3.1　本书英文版的配套网站
B.3.2　Caféau Lait
B.3.3　Workbench
B.3.4　Java 7Developer Blog
B.3.5　其他Java博客
B.3.6　InformIT
B.3.7　Stack Overflow
B.3.8　Java Review Service
B.3.9　JavaWorld杂志
B.3.10　Developer.com’s Java Directory
附录C　本书站点
附录D　设置Android开发环境
D.1　起步
D.2　安装Eclipse
D.3　安装Android SDK
D.4　安装在Eclipse中使用的 Android插件
D.5　设置你的手机
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java入门经典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>单元测试之道Java版
关于程序员修炼三部曲
前言
第1章 序言
1.1 自信地编码
1.2 什么是单元测试
1.3 为什么要使用单元测试
1.4 我需要做什么呢
1.5 如何进行单元测试
1.6 不写测试的借口
1.7 本书概要
第2章 你的首个单元测试
2.1 计划你的测试
2.2 测试一个简单的方法
2.3 更多的测试
第3章 使用JUnit编写测试
3.1 构建单元测试
3.2 JUnit的各种断言
3.3 JUnit框架
3.4 JUnit测试的组成
3.5 自定义JUnit断言
3.6 JUnit和异常
3.7 关于命名的更多说明
3.8 JUnit测试骨架
第4章 测试哪些内容：Right-BICEP
4.1 结果是否正确
4.2 边界条件
4.3 检查反向关联
4.4 使用其他手段来实现交叉检查
4.5 强制产生错误条件
4.6 性能特性
第5章 CORRECT边界条件
5.1 一致性
5.2 有序性
5.3 区间性
5.4 引用/耦合性
5.5 存在性
5.6 基数性
5.7 时间性
5.8 自己动手尝试
第6章 使用Mock对象
6.1 简单的替换
6.2 Mock对象
6.3 测试Servlet
6.4 Easy Mock对象
第7章 好的测试所具的品质
7.1 自动化
7.2 彻底的
7.3 可重复
7.4 独立的
7.5 专业的
7.6 对测试进行测试
第8章 在项目中进行测试
8.1 把测试代码放到哪
8.2 测试的礼貌
8.3 测试的频率
8.4 测试与遗留代码
8.5 测试与评审
第9章 设计话题
9.1 面向测试的设计
9.2 为测试而重构
9.3 测试类的不变性
9.4 测试驱动的设计
9.5 测试无效的参数
附录A Gotchas
A.1 只要代码能工作就可以
A.2 “冒烟”测试
A.3 “请让我的机器来运行”
A.4 浮点数问题
A.5 测试耗费的时间太多了
A.6 测试总是失败
A.7 在某些机器上测试失败
A.8 我的main没有被运行
附录B 安装JUnit
B.1 命令行安装
B.2 管理用吗
附录C JUnit
C.1 辅助类
C.2 基本模板
附录D 资源
D.1 网络资源
D.2 参考书目
附录E 注重实效的单元测试：总结
附录F 习题答案
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>单元测试之道Java版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java面向对象编程
第1章 面向对象开发方法概述.
1.1 结构化的软件开发方法简介
1.2 面向对象的软件开发方法简介
1.2.1 对象模型
1.2.2 UML：可视化建模语言
1.2.3 Rational Rose：可视化建模工具
1.3 面向对象开发中的核心思想和概念
1.3.1 问题领域、对象、属性、状态、行为、方法、实现
1.3.2 类、类型
1.3.3 消息、服务
1.3.4 接口
1.3.5 封装、透明
1.3.6 抽象
1.3.7 继承、扩展、覆盖
1.3.8 组合
1.3.9 多态、动态绑定
1.4 UML语言简介
1.4.1 用例图
1.4.2 类框图
1.4.3 时序图
1.4.4 协作图
1.4.5 状态转换图
1.4.6 组件图
1.4.7 部署图
1.5 类之间的关系
1.5.1 关联（Association）
1.5.2 依赖（Dependency）
1.5.3 聚集（Aggregation）
1.5.4 泛化（Generalization）
1.5.5 实现（Realization）
1.5.6 区分依赖、关联和聚集关系
1.6 实现Panel系统
1.6.1 扩展Panel系统
1.6.2 用配置文件进一步提高Panel系统的可维护性
1.6.3 运行Panel系统
1.7 小结
1.8 思考题
第2章 第一个Java应用
2.1 创建Java源文件
2.1.1 Java源文件结构
2.1.2 包声明语句
2.1.3 包引入语句
2.1.4 方法的声明
2.1.5 程序入口main()方法的声明
2.1.6 给main()方法传递参数
2.1.7 注释语句
2.1.8 关键字
2.1.9 标识符
2.1.10 编程规范
2.2 用JDK管理Java应用
2.2.1 JDK简介
2.2.2 编译Java源文件
2.2.3 运行Java程序
2.2.4 给Java应用打包
2.3 JavaDoc文档
2.3.1 JavaDoc标记
2.3.2 javadoc命令的用法
2.4 Java虚拟机的运行时数据区
2.5 小结
2.6 思考题
第3章 数据类型和变量
3.1 基本数据类型
3.1.1 boolean类型
3.1.2 byte、short、int和long类型
3.1.3 char类型与字符编码
3.1.4 float和double类型
3.2 引用类型
3.2.1 基本类型与引用类型的区别
3.2.2 用new关键字创建对象
3.3 变量的作用域
3.3.1 静态变量和实例变量的生命周期
3.3.2 局部变量的生命周期
3.3.3 成员变量和局部变量同名
3.3.4 将局部变量的作用域最小化
3.4 对象的默认引用：this
3.5 参数传递
3.6 变量的初始化及默认值
3.6.1 成员变量的初始化
3.6.2 局部变量的初始化
3.7 直接数
3.7.1 直接数的类型
3.7.2 直接数的赋值
3.8 小结
3.9 思考题
第4章 操 作 符
4.1 操作符简介
4.2 整型操作符
4.2.1 一元整型操作符
4.2.2 二元整型操作符
4.3 浮点型操作符
4.4 比较操作符和逻辑操作符
4.5 三元操作符“?:”
4.6 字符串连接操作符“+”
4.7 操作符“==”与对象的equals()方法
4.7.1 操作符“==”
4.7.2 对象的equals()方法
4.8 instanceof 操作符
4.9 变量的赋值和类型转换
4.9.1 基本数据类型转换
4.9.2 引用类型的类型转换
4.10 小结
4.11 思考题
第5章 流 程 控 制
5.1 分支语句
5.1.1 if…else语句
5.1.2 switch语句
5.2 循环语句
5.2.1 while语句
5.2.2 do…while语句
5.2.3 for语句
5.2.4 多重循环
5.3 流程跳转语句
5.4 综合例子：八皇后问题
5.5 小结
5.6 思考题
第6章 继 承
6.1 继承的基本语法
6.2 方法重载（Overload）
6.3 方法覆盖（Override）
6.4 方法覆盖与方法重载的异同
6.5 super关键字
6.6 多态
6.7 继承的利弊和使用原则
6.7.1 继承树的层次不可太多
6.7.2 继承树的上层为抽象层
6.7.3 继承关系最大的弱点：打破封装
6.7.4 精心设计专门用于被继承的类
6.7.5 区分对象的属性与继承
6.8 比较组合与继承
6.8.1 组合关系的分解过程对应继承关系的抽象过程
6.8.2 组合关系的组合过程对应继承关系的扩展过程
6.9 小结
6.9 思考题
第7章 Java语言中的修饰符
7.1 访问控制修饰符
7.2 abstract修饰符
7.3 final修饰符
7.3.1 final类
7.3.2 final方法
7.3.3 final变量
7.4 static修饰符
7.4.1 static变量
7.4.2 static方法
7.4.3 static代码块
7.5 小结
7.6 思考题
第8章 接 口
8.1 接口的概念和基本特征
8.2 比较抽象类与接口
8.3 与接口相关的设计模式
8.3.1 定制服务模式
8.3.2 适配器模式
8.3.3 默认适配器模式
8.3.4 代理模式
8.3.5 标识类型模式
8.3.6 常量接口模式
8.4 小结
8.5 思考题
第9章 异 常 处 理
9.1 Java异常处理机制概述
9.1.1 Java异常处理机制的优点
9.1.2 Java虚拟机的方法调用栈
9.1.3 异常处理对性能的影响
9.2 运用Java异常处理机制
9.2.1 try…catch语句：捕获异常
9.2.2 finally语句：任何情况下必须执行的代码
9.2.3 throws子句：声明可能会出现的异常
9.2.4 throw语句：抛出异常
9.2.5 异常处理语句的语法规则
9.2.6 异常流程的运行过程
9.3 Java异常类
9.3.1 运行时异常
9.3.2 受检查异常
9.3.3 区分运行时异常和受检查异常
9.4 用户定义异常
9.4.1 异常转译和异常链
9.4.2 处理多样化异常
9.5 异常处理原则
9.5.1 异常只能用于非正常情况
9.5.2 为异常提供说明文档
9.5.3 尽可能地避免异常
9.5.4 保持异常的原子性
9.5.5 避免过于庞大的try代码块
9.5.6 在catch子句中指定具体的异常类型
9.5.7 不要在catch代码块中忽略被捕获的异常
9.6 小结
9.7 思考题
第10章 类的生命周期
10.1 Java虚拟机及程序的生命周期
10.2 类的加载、连接和初始化
10.2.1 类的加载
10.2.2 类的验证
10.2.3 类的准备
10.2.4 类的解析
10.2.5 类的初始化
10.2.6 类的初始化的时机
10.3 类加载器
10.3.1 类加载的父亲委托（Parent Delegation）机制
10.3.2 创建用户自定义的类加载器
10.3.3 URLClassLoader类
10.4 类的卸载
10.5 小结
10.6 思考题
第11章 对象的生命周期
11.1 创建对象的方式
11.2 构造方法
11.2.1 重载构造方法
11.2.2 默认构造方法
11.2.3 子类调用父类的构造方法
11.2.4 构造方法的作用域
11.2.5 构造方法的访问级别
11.3 静态工厂方法
11.3.1 单例（Singleton）类
11.3.2 枚举类
11.3.3 不可变（immutable）类与可变类
11.3.4 具有实例缓存的不可变类
11.3.5 松耦合的系统接口
11.4 垃圾回收
11.4.1 对象的可触及性
11.4.2 垃圾回收的时间
11.4.3 对象的finalize()方法简介
11.4.4 对象的finalize()方法的特点
11.4.5 比较finalize()方法和finally代码块..
11.5 清除过期的对象引用
11.6 对象的强、软、弱和虚引用
11.7 小结
11.8 思考题
第12章 内 部 类
12.1 内部类的基本语法
12.1.1 实例内部类
12.1.2 静态内部类
12.1.3 局部内部类
12.2 内部类的继承
12.3 子类与父类中的内部类同名
12.4 匿名类
12.5 内部接口及接口中的内部类
12.6 内部类的用途
12.6.1 封装类型
12.6.2 直接访问外部类的成员
12.6.3 回调（CallBack）
12.7 内部类的类文件
12.8 小结
12.9 思考题
第13章 多 线 程
13.1 Java线程的运行机制
13.2 线程的创建和启动
13.2 线程的创建和启动
13.2.1 扩展java.lang.Thread类
13.2.2 实现Runnable接口
13.3 线程的状态转换
13.3.1 新建状态（New）
13.3.2 就绪状态（Runnable）
13.3.3 运行状态（Running）
13.3.4 阻塞状态（Blocked ）
13.3.5 死亡状态（Dead）
13.4 线程调度
13.4.1 调整各个线程的优先级
13.4.2 线程睡眠：Thread.sleep()方法
13.4.3 线程让步：Thead.yield()方法
13.4.4 等待其他线程结束：join()
13.5 获得当前线程对象的引用
13.6 后台线程
13.7 定时器Timer
13.8 线程的同步
13.8.1 同步代码块
13.8.2 线程同步的特征
13.8.3 同步与并发
13.8.4 线程安全的类
13.8.5 释放对象的锁
13.8.6 死锁
13.9 线程通信
13.10 中断阻塞
13.11 线程控制
13.11.1 被废弃的suspend()和resume()方法
13.11.2 被废弃的stop()方法
13.11.3 以编程的方式控制线程
13.12 线程组
13.13 处理线程未捕获的异常
13.14 ThreadLocal类
13.15 小结
13.16 思考题
第14章 数 组
14.1 数组变量的声明
14.2 创建数组对象
14.3 访问数组的元素和长度
14.4 数组的初始化
14.5 多维数组
14.6 调用数组对象的方法
14.7 把数组作为方法参数或返回值
14.8 数组排序
14.9 数组的二叉查找算法
14.10 哈希表
14.11 数组实用类：Arrays
14.12 小结
14.13 思考题
第15章 Java集合
15.1 Collection和Iterator接口
15.2 Set（集）
15.2.1 Set的一般用法
15.2.2 HashSet类
15.2.3 TreeSet类
15.3 List（列表）
15.3.1 访问列表的元素
15.3.2 为列表排序
15.3.3 ListIterator接口
15.3.4 获得固定长度的List对象
15.3.5 比较Java数组和各种List的性能
15.4 Map（映射）
15.5 HashSet和HashMap的负载因子
15.6 集合的编译时类型检查
15.7 用for循环遍历集合
15.8 集合实用类：Collections
15.9 历史集合类
15.10 小结
15.11 思考题
第16章 Java I/O系统
16.1 输入流和输出流概述
16.2 输入流
16.2.1 字节数组输入流：ByteArrayInputStream类
16.2.2 文件输入流：FileInputStream类
16.2.3 字符串输入流：StringBufferInputStream
16.2.4 管道输入流：PipedInputStream
16.2.5 顺序输入流：SequenceInputStream类
16.3 过滤输入流：FilterInputStream
16.3.1 装饰器设计模式
16.3.2 过滤输入流的种类
16.3.3 DataInputStream类
16.3.4 LineNumberInputStream类
16.3.5 BufferedInputStream类
16.3.6 PushbackInputStream类
16.4 输出流
16.4.1 字节数组输出流：ByteArrayOutputStream类
16.4.2 文件输出流：FileOutputStream
16.5 过滤输出流：FilterOutputStream
16.5.1 DataOutputStream
16.5.2 BufferedOutputStream
16.5.3 PrintStream类
16.6 Reader/Writer概述
16.7 Reader类
16.7.1 字符数组输入流：CharArrayReader类
16.7.2 字符串输入流：StringReader类
16.7.3 InputStreamReader类
16.7.4 FileReader类
16.7.5 BufferedReader类
16.8 Writer类
16.8.1 字符数组输出流：CharArrayWriter类
16.8.2 OutputStreamWriter类
16.8.3 FileWriter类
16.8.4 BufferedWriter类
16.8.5 PrintWriter类
16.9 标准I/O
16.9.1 重新包装标准输入和输出
16.9.2 标准I/O重定向
16.10 随机访问文件类：RandomAccessFile
16.11 新I/O类库
16.11.1 缓冲器Buffer概述
16.11.2 通道Channel概述
16.11.3 字符编码Charset类概述
16.11.4 用FileChannel读写文件
16.11.5 控制缓冲区
16.11.6 字符编码转换
16.11.7 缓冲区视图
16.11.8 文件映射缓冲区：MappedByteBuffer
16.11.9 文件加锁
16.12 对象的序列化与反序列化
16.13 File类
16.13.1 查看、创建和删除文件或目录
16.13.2 文件过滤器
16.14 小结
16.15 思考题
第17章 图形用户界面
17.1 AWT容器
17.2 布局管理器
17.2.1 FlowLayout流式布局管理器
17.2.2 BorderLayout边界布局管理器
17.2.3 GridLayout网格布局管理器
17.2.4 CardLayout卡片布局管理器
17.2.5 GridBagLayout网格包布局管理器
17.3 事件处理
17.3.1 事件处理的软件实现
17.3.2 事件源﹑事件和监听器的类层次和关系
17.4 AWT绘图
17.5 Graphics类
17.6 小结
17.7 思考题
第18章 Swing组件
18.1 Swing组件的基本用法
18.2 边框
18.3 按钮组件
18.4 文本框
18.5 文本区域与滚动面板
18.6 复选框与单选按钮
18.7 下拉列表
18.8 列表框
18.9 页签面板
18.10 菜单
18.11 对话框
18.12 文件对话框
18.13 消息框
18.14 绘图
18.15 JApplet
18.16 在JApplet中播放声音
18.17 BoxLayout布局管理器
18.18 设置Swing界面的外观和感觉
18.19 小结
18.20 思考题
第19章 Java常用类
19.1 Object 类
19.2 String类和StringBuffer类
19.2.1 String类
19.2.2 “hello”与new String("hello")的区别
19.2.3 StringBuffer类
19.2.4 比较String类与StringBuffer类
19.2.5 正则表达式
19.3 包装类
19.3.1 包装类的构造方法
19.3.2 包装类的常用方法
19.3.3 包装类的特点
19.4 Math类
19.5 Random类
19.6 处理日期的类
19.6.1 Date类
19.6.2 DateFormat类
19.6.3 Calendar类
19.7 BigDecimal类
19.8 小结
19.9 思考题
参考文献...
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java面向对象编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java虚拟机规范(Java SE 7版)
《java虚拟机规范(java se 7版)》
译者序
前言
第2版前言
第1版前言
第1章　引言1
1.1　简史1
1.2　java虚拟机2
1.3　各章节摘要2
1.4　说明3
第2章　java虚拟机结构4
2.1　class文件格式4
2.2　数据类型5
2.3　原始类型与值5
2.3.1　整数类型与整型值6
2.3.2　浮点类型、取值集合及浮点值6
2.3.3　returnaddress类型和值8
2.3.4　boolean类型8
2.4　引用类型与值9
2.5　运行时数据区9
.2.5.1　pc寄存器9
2.5.2　java虚拟机栈9
2.5.3　java堆10
2.5.4　方法区11
2.5.5　运行时常量池11
2.5.6　本地方法栈11
2.6　栈帧12
2.6.1　局部变量表13
2.6.2　操作数栈13
2.6.3　动态链接14
2.6.4　方法正常调用完成14
2.6.5　方法异常调用完成15
2.7　对象的表示15
2.8　浮点算法15
2.8.1　java虚拟机和ieee 754中的浮点算法15
2.8.2　浮点模式16
2.8.3　数值集合转换16
2.9　特殊方法17
2.10　异常18
2.11　字节码指令集简介20
2.11.1　数据类型与java虚拟机21
2.11.2　加载和存储指令23
2.11.3　算术指令23
2.11.4　类型转换指令24
2.11.5　对象创建与操作26
2.11.6　操作数栈管理指令26
2.11.7　控制转移指令27
2.11.8　方法调用和返回指令27
2.11.9　抛出异常28
2.11.10　同步28
2.12　类库28
2.13　公有设计，私有实现29
第3章　java虚拟机编译器30
3.1　示例的格式说明30
3.2　常量、局部变量和控制结构的使用31
3.3　算术运算35
3.4　访问运行时常量池35
3.5　更多控制结构示例36
3.6　接收参数39
3.7　方法调用39
3.8　使用类实例42
3.9　数组43
3.10　编译switch语句45
3.11　使用操作数栈46
3.12　抛出异常和处理异常47
3.13　编译finally语句块50
3.14　同步53
3.15　注解54
第4章　class文件格式55
4.1　classfile结构56
4.2　各种内部表示名称60
4.2.1　类和接口的二进制名称60
4.2.2　非全限定名60
4.3　描述符和签名61
4.3.1　语法符号61
4.3.2　字段描述符61
4.3.3　方法描述符63
4.3.4　签名63
4.4　常量池66
4.4.1　constant_class_info结构67
4.4.2　constant_fieldref_info、constant_methodref_info和constant_interface methodref_info结构67
4.4.3　constant_string_info结构69
4.4.4　constant_integer_info和constant_float_info结构69
4.4.5　constant_long_info和constant_double_info结构70
4.4.6　constant_nameandtype_info结构71
4.4.7　constant_utf8_info结构72
4.4.8　constant_methodhandle_info结构74
4.4.9　constant_methodtype_info结构74
4.4.10　constant_invokedynamic_info结构75
4.5　字段75
4.6　方法77
4.7　属性80
4.7.1　自定义和命名新的属性81
4.7.2　constantvalue属性81
4.7.3　code属性82
4.7.4　stackmaptable属性85
4.7.5　exceptions属性91
4.7.6　innerclasses属性92
4.7.7　enclosingmethod属性94
4.7.8　synthetic属性94
4.7.9　signature属性95
4.7.10　sourcefile属性96
4.7.11　sourcedebugextension属性96
4.7.12　linenumbertable属性97
4.7.13　localvariabletable属性98
4.7.14　localvariabletypetable属性99
4.7.15　deprecated属性101
4.7.16　runtimevisibleannotations属性101
4.7.17　runtimeinvisible annotations属性105
4.7.18　runtimevisibleparameter annotations属性106
4.7.19　runtimeinvisibleparameter annotations属性107
4.7.20　annotationdefault属性108
4.7.21　bootstrapmethods属性108
4.8　格式检查110
4.9　java虚拟机代码约束110
4.9.1　静态约束110
4.9.2　结构化约束113
4.10　class文件校验115
4.10.1　类型检查验证116
4.10.2　类型推导验证178
4.11　java虚拟机限制184
第5章　加载、链接与初始化186
5.1　运行时常量池186
5.2　虚拟机启动188
5.3　创建和加载188
5.3.1　使用引导类加载器来加载类型190
5.3.2　使用用户自定义类加载器来加载类型190
5.3.3　创建数组类191
5.3.4　加载限制191
5.3.5　从class文件表示得到类192
5.4　链接193
5.4.1　验证194
5.4.2　准备194
5.4.3　解析195
5.4.4　访问控制201
5.4.5　方法覆盖201
5.5　初始化202
5.6　绑定本地方法实现203
5.7　java虚拟机退出203
第6章　java虚拟机指令集204
6.1　设定：“必须”的含义204
6.2　保留操作码204
6.3　虚拟机错误205
6.4　指令描述格式205
6.5　指令集描述207
第7章　操作码助记符293
附录a　limited license grant300
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java虚拟机规范(Java SE 7版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java线程
前言
第一章 Thread导论
Java术语
关于范例
为何要用Thread？
总结
第二章 Thread的创建与管理
什么是Thread？
创建Thread
Thread的生命周期
两种停止Thfead的方式
Runnable工nterface
Thread与对象
总结
第三章 数据同步
Synchronized关键字
Volatile关键字
更多RaceCOnd“iOn的讨论
明确的 (explicit)Locking
Lock Scope
选择Locking机制
Nested Lock
死锁
Lock公平 (Fairness)
总结
第四章 Thread NOtification
等待与通知
条件变量
总结
第五章 极简同步技巧
能避免同步吗？
Atomic变量
Thread局部变量
总结
第六章 高级同步议题
同步术语
J2SE 5.0中加入的同步Class
防止死锁
死锁检测
Lock饥饿
总结
第七章 Thread与Swing
Swing Threading的限制
事件派发Thread的处理
使用invokeLater()与invokeAndWait()
长时间运行的事件回调
总结
第八章 Thread与Collection Class
Collection Class的概述
同步与Collection Class
生产者/肖费者模式
使用CollectionClass
总结
第九章 Thread调度
Thread调度的概述
以Thread优先级来调度
常见Threading的实现
总结
第十章 Thread Pool
为何要用Thread Pool？
Executor
使用Thread Pool
Queue与大小
创建Thread
Callable Task与Future结果
单一Thread化的访问
总结
第十一章 Task的调度
Task调度的概述
java.util.Timer Class
javax.Swing.Timer Class
SCheduledThreadPoolExecutor Class
总结
第十二章 Thread与I／O
传统的I／O服务器
新的I／O服务器
被中断的I／O
总结
第十三章 各种Thread议题
Thread Group
Thread与Java安全性
Daemon Thread
Thread与C1ass的力口载
Thread与异常处理
Thread、Stack、 内存的使用
总结
第十四章 Thread性能
性能的概述
同步的Collection
Atomic变量与有竞争的同步
Thread的创建与Thread Pool
总结
第十五章 多处理器计算机的并行化循环
对单一Threaded程序的并行化
多处理器扩大(scaling)
总结
附录 被撤换的Threading功能
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java线程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java加密与解密的艺术(第2版)
前言
第一部分 基础篇
第1章 企业应用安全 2
1.1 我们身边的安全问题 2
1.2 拿什么来拯救你，我的应用 3
1.2.1 安全技术目标 3
1.2.2 OSI安全体系结构 4
1.2.3 TCP/IP安全体系结构 6
1.3 捍卫企业应用安全的银弹 8
1.3.1 密码学在安全领域中的身影 8
1.3.2 密码学与Java EE 8
1.4 为你的企业应用上把锁 9
1.5 小结 10
第2章 企业应用安全的银弹—密码学 11
2.1 密码学的发家史 11
2.1.1 手工加密阶段 11
2.1.2 机械加密阶段 12
2.1.3 计算机加密阶段 13
2.2 密码学定义、术语及其分类 15
2.2.1 密码学常用术语 15
2.2.2 密码学分类 16
2.3 保密通信模型 17
2.4 古典密码 18
2.5 对称密码体制 19
2.5.1 流密码 20
2.5.2 分组密码 21
2.6 非对称密码体制 27
2.7 散列函数 28
2.8 数字签名 29
2.9 公钥基础设施 31
2.9.1 PKI的标准 31
2.9.2 PKI系统的组成 32
2.9.3 数字证书 33
2.10 PGP、OpenPGP与GPG 34
2.11 密码学的未来 34
2.11.1 密码算法的破解 35
2.11.2 密码学的明天 36
2.12 小结 36
第3章 Java加密利器 38
3.1 Java与密码学 38
3.1.1 Java安全领域组成部分 38
3.1.2 安全提供者体系结构 39
3.1.3 关于出口的限制 40
3.1.4 关于本章内容 40
3.2 java.security包详解 40
3.2.1 Provider类 41
3.2.2 Security类 44
3.2.3 MessageDigest类 46
3.2.4 DigestInputStream类 49
3.2.5 DigestOutputStream类 49
3.2.6 Key接口 52
3.2.7 AlgorithmParameters类 53
3.2.8 AlgorithmParameterGenerator类 55
3.2.9 KeyPair类 56
3.2.10 KeyPairGenerator类 57
3.2.11 KeyFactory类 59
3.2.12 SecureRandom类 61
3.2.13 Signature类 62
3.2.14 SignedObject类 65
3.2.15 Timestamp类 66
3.2.16 CodeSigner类 67
3.2.17 KeyStore类 69
3.3 javax.crypto包详解 73
3.3.1 Mac类 73
3.3.2 KeyGenerator类 75
3.3.3 KeyAgreement类 77
3.3.4 SecretKeyFactory类 78
3.3.5 Cipher类 80
3.3.6 CipherInputStream类 84
3.3.7 CipherOutputStream类 83
3.3.8 SealedObject类 86
3.4 java.security.spec包和javax.crypto.spec包详解 88
3.4.1 KeySpec和Algorithm-ParameterSpec接口 88
3.4.2 EncodedKeySpec类 89
3.4.3 SecretKeySpec类 92
3.4.4 DESKeySpec类 93
3.5 java.security.cert包详解 94
3.5.1 Certificate类 94
3.5.2 CertificateFactory类 95
3.5.3 X509Certificate类 97
3.5.4 CRL类 98
3.5.5 X509CRLEntry类 99
3.5.6 X509CRL类 100
3.5.7 CertPath类 102
3.6 javax.net.ssl包详解 103
3.6.1 KeyManagerFactory类 103
3.6.2 TrustManagerFactory类 105
3.6.3 SSLContext类 106
3.6.4 HttpsURLConnection类 109
3.6.5 SSLSession接口 111
3.6.6 SSLSocketFactory类 111
3.6.7 SSLSocket类 112
3.6.8 SSLServerSocketFactory类 114
3.6.9 SSLServerSocket类 114
3.7 小结 117
第4章 他山之石，可以攻玉 119
4.1 加固你的系统 119
4.1.1 获得权限文件 120
4.1.2 配置权限文件 120
4.1.3 验证配置 121
4.2 加密组件Bouncy Castle 121
4.2.1 获得加密组件 122
4.2.2 扩充算法支持 122
4.2.3 相关API 126
4.3 辅助工具Commons Codec 130
4.3.1 获得辅助工具 130
4.3.2 相关API 131
4.4 小结 141
第二部分 实践篇
第5章 电子邮件传输算法—Base64 144
5.1 Base64算法的由来 144
5.2 Base64算法的定义 144
5.3 Base64算法与加密算法的关系 145
5.4 实现原理 146
5.4.1 ASCII码字符编码 146
5.4.2 非ASCII码字符编码 147
5.5 模型分析 147
5.6 Base64算法实现 148
5.6.1 Bouncy Castle 148
5.6.2 Commons Codec 150
5.6.3 两种实现方式的差异 154
5.6.4 不得不说的问题 154
5.7 Url Base64算法实现 157
5.7.1 Bouncy Castle 157
5.7.2 Commons Codec 159
5.7.3 两种实现方式的差异 160
5.8 应用举例 161
5.8.1 电子邮件传输 161
5.8.2 网络数据传输 161
5.8.3 密钥存储 162
5.8.4 数字证书存储 162
5.8.5 OpenSSL操作Base 64编码 163
5.9 小结 163
第6章 验证数据完整性—消息摘要算法 165
6.1 消息摘要算法简述 165
6.1.1 消息摘要算法的由来 165
6.1.2 消息摘要算法的家谱 166
6.2 MD算法家族 167
6.2.1 简述 167
6.2.2 模型分析 168
6.2.3 实现 170
6.3 SHA算法家族 177
6.3.1 简述 177
6.3.2 模型分析 178
6.3.3 实现 179
6.4 MAC算法家族 191
6.4.1 简述 191
6.4.2 模型分析 192
6.4.3 实现 192
6.5 其他消息摘要算法 205
6.5.1 简述 205
6.5.2 实现 205
6.6 循环冗余校验算法—CRC算法 216
6.6.1 简述 216
6.6.2 模型分析 217
6.6.3 实现 217
6.7 实例：文件校验 219
6.8 小结 222
第7章 初等数据加密—对称加密算法 224
7.1 对称加密算法简述 224
7.1.1 对称加密算法的由来 224
7.1.2 对称加密算法的家谱 225
7.2 数据加密标准—DES 225
7.2.1 简述 225
7.2.2 模型分析 226
7.2.3 实现 227
7.3 三重DES—DESede 233
7.3.1 简述 233
7.3.2 实现 233
7.4 高级数据加密标准—AES 238
7.4.1 简述 238
7.4.2 实现 239
7.5 国际数据加密标准—IDEA 243
7.5.1 简述 243
7.5.2 实现 243
7.6 基于口令加密—PBE 247
7.6.1 简述 247
7.6.2 模型分析 247
7.6.3 实现 248
7.7 实例：对称加密网络应用 253
7.8 小结 265
第8章 高等数据加密—非对称加密算法 267
8.1 非对称加密算法简述 267
8.1.1 非对称加密算法的由来 267
8.1.2 非对称加密算法的家谱 268
8.2 密钥交换算法—DH&ECDH 269
8.2.1 简述 269
8.2.2 模型分析 269
8.2.3 DH实现 270
8.2.4 ECDH实现 280
8.3 典型非对称加密算法—RSA 289
8.3.1 简述 289
8.3.2 模型分析 290
8.3.3 实现 291
8.4 常用非对称加密算法—ElGamal 298
8.4.1 简述 298
8.4.2 模型分析 298
8.4.3 实现 299
8.5 实例：非对称加密网络应用 305
8.6 小结 317
第9章 带密钥的消息摘要算法—数字签名算法 319
9.1 数字签名算法简述 319
9.1.1 数字签名算法的由来 319
9.1.2 数字签名算法的家谱 320
9.2 模型分析 320
9.3 经典数字签名算法—RSA 321
9.3.1 简述 322
9.3.2 实现 322
9.4 数字签名标准算法—DSA 328
9.4.1 简述 328
9.4.2 实现 328
9.5 椭圆曲线数字签名算法—ECDSA 333
9.5.1 简述 333
9.5.2 实现 333
9.6 实例：带有数字签名的加密网络应用 341
9.7 小结 352
第三部分 综合应用篇
第10章 终极武器—数字证书 356
10.1 数字证书详解 356
10.2 模型分析 359
10.2.1 证书签发 359
10.2.2 加密交互 360
10.3 证书管理 361
10.3.1 KeyTool证书管理 361
10.3.2 OpenSSL证书管理 368
10.4 证书文件操作 379
10.4.1 JKS文件操作 379
10.4.2 PFX文件操作 388
10.4.3 PEM文件操作 390
10.5 应用举例 394
10.6 小结 394
第11章 终极装备—安全协议 396
11.1 安全协议简述 396
11.1.1 HTTPS协议 396
11.1.2 SSL/TLS协议 397
11.2 模型分析 398
11.2.1 协商算法 399
11.2.2 验证证书 399
11.2.3 产生密钥 400
11.2.4 加密交互 402
11.3 单向认证服务 403
11.3.1 准备工作 403
11.3.2 服务验证 408
11.3.3 代码验证 410
11.4 双向认证服务 415
11.4.1 准备工作 415
11.4.2 服务验证 418
11.4.3 代码验证 420
11.5 应用举例 421
11.6 实例 422
11.6.1 SSLSocket获取数字证书 422
11.6.2 SSLSocket加密交互 425
11.7 小结 429
第12章 量体裁衣—为应用选择合适的装备 431
12.1 实例：常规Web应用开发安全 431
12.1.1 常规Web应用基本实现 431
12.1.2 安全升级1—摘要处理 436
12.1.3 安全升级2—加盐处理 438
12.2 实例：IM应用开发安全 441
12.2.1 IM应用开发基本实现 441
12.2.2 安全升级1—隐藏数据 454
12.2.3 安全升级2—加密数据 457
12.3 实例：Web Service应用开发安全 462
12.3.1 Web Service应用基本实现 462
12.3.2 安全升级1—单向认证服务 469
12.3.3 安全升级2—双向认证服务 480
12.4 小结 485
附录A Java 7支持的算法 487
附录B Bouncy Castle支持的算法 490
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java加密与解密的艺术(第2版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring+MyBatis企业应用实战
第1章　Java EE应用	1
1.1　Java EE应用概述	2
1.1.1　Java EE应用的分层模型	2
1.1.2　Java EE应用的组件	3
1.1.3　Java EE应用的结构和优势	4
1.2　轻量级Java EE应用相关技术	4
1.2.1　JSP、Servlet和JavaBean及替代技术	4
1.2.2　MyBatis3及替代技术	5
1.2.3　Spring4及替代技术	6
1.2.4　使用开源框架的好处	7
1.3　本章小结	7
第2章　Spring MVC简介	8
2.1　MVC思想概述	9
2.1.1　传统Model1和Model2	9
2.1.2　MVC思想及其优势	10
2.2　Struts2和Spring MVC	11
2.3　开发第一个Spring MVC应用	11
2.3.1　Spring的下载和安装	11
2.3.2　Spring MVC的DispatcherServlet	12
2.3.3　基于Controller接口的控制器	13
示例：第一个Spring MVC应用	13
示例：基于注解的控制器	17
2.4　详解DispatcherServlet	19
2.5　Spring MVC执行的流程	21
2.5.1　Spring MVC应用的开发步骤	22
2.5.2　Spring MVC执行的流程	23
2.6　本章小结	24
第3章　Spring MVC的常用注解	25
3.1　@Controller注解	26
示例：@Controller注解的使用	26
3.2　@RequestMapping注解	28
3.2.1　@RequestMapping注解	28
3.2.2　请求处理方法可出现的参数类型	30
3.2.3　请求处理方法可返回的类型	31
3.2.4　Model和ModelAndView	31
示例：Model和ModelMap的使用	32
示例：ModelAndView的使用	33
3.3　参数绑定注解	33
3.3.1　@RequestParam注解	33
示例：@RequestMapping和@RequestParam注解的使用	34
3.3.2　@PathVariable注解	38
3.3.3　@RequestHeader注解	38
3.3.4　@CookieValue注解	39
示例：@PathVariable、@RequestHeader和@CookieValue注解的使用	39
3.3.5　@SessionAttributes注解	41
示例：@SessionAttributes注解的使用	41
3.3.6　@ModelAttribute注解	42
示例：@ModelAttribute注解的使用	43
3.4　信息转换	49
3.4.1　HttpMessageConverter＜T＞接口	49
3.4.2　转换JSON数据	51
示例：接收JSON格式的数据	51
示例：自定义HttpMessageConverter接收JSON格式的数据	55
示例：返回JSON格式的数据	57
示例：自定义HttpMessageConverter返回JSON格式的数据	58
3.4.3　转换XML数据	59
示例：接收XML格式的数据	59
示例：返回XML格式的数据	61
3.5　本章小结	62
第4章　Spring MVC的标签库	64
4.1　表单标签库	65
4.1.1　form标签	65
4.1.2　input标签	66
示例：form和input标签的使用	66
4.1.3　password标签	68
4.1.4　hidden标签	69
4.1.5　textarea标签	69
4.1.6　checkbox标签	70
示例：checkbox标签的使用	70
4.1.7　checkboxes标签	71
示例：checkboxes标签的使用	72
4.1.8　radiobutton标签	76
示例：radiobutton标签的使用	76
4.1.9　radiobuttons标签	77
示例：radiobuttons标签的使用	77
4.1.10　select标签	79
4.1.11　option标签	79
4.1.12　options标签	79
示例：select、option和options标签的使用	80
4.1.13　errors标签	83
示例：errors标签的使用	84
4.2　本章小结	86
第5章　Spring MVC的国际化	87
5.1　Spring MVC国际化的相关知识	88
5.1.1　messageSource	88
5.1.2　localeResolver	88
5.1.3　message标签	89
5.2　AcceptHeaderLocaleResolver国际化	89
示例：基于浏览器请求的国际化实现	89
5.3　SessionLocaleResolver国际化	92
示例：基于HttpSession的国际化实现	93
5.4　CookieLocaleResolver国际化	95
示例：基于Cookie的国际化实现	95
5.5　本章小结	96
第6章　Spring MVC的数据转换、格式化和数据校验	97
6.1　数据绑定流程	98
6.2　数据转换	98
6.2.1　ConversionService	98
6.2.2　Spring支持的转换器	99
示例：使用ConversionService转换数据	100
示例：使用@InitBinder添加自定义编辑器转换数据	103
示例：使用WebBindingInitializer注册全局自定义编辑器转换数据	103
6.2.3 多种转换器的优先顺序	104
6.3　数据格式化	104
示例：使用Formatter格式化数据	105
示例：使用FormatterRegistrar注册Formatter	107
示例：使用AnnotationFormatterFactory＜A extends Annotation＞格式化数据	108
6.4　数据校验	110
6.4.1　Spring的Validation校验框架	111
示例：测试Spring的Validation校验	112
6.4.2　JSR 303校验	114
示例：测试JSR 303校验	115
6.5　本章小结	120
第7章　Spring MVC的文件上传和下载	121
7.1　文件上传	122
示例：Spring MVC的文件上传	122
示例：使用对象接收上传文件	124
7.2　文件下载	125
示例：Spring MVC的文件下载	125
7.3　拦截器	126
7.3.1　HandlerInterceptor接口	127
示例：拦截器实现用户权限验证	127
7.4　本章小结	131
第8章　MyBatis简介	132
8.1　ORM和MyBatis	133
8.1.1　对象/关系数据库映射（ORM）	133
8.1.2　基本映射方式	134
8.1.3　流行的ORM框架简介	135
8.1.4　MyBatis概述	135
8.2　MyBatis入门	136
8.2.1　MyBatis下载和安装	136
8.2.2　MyBatis的数据库操作	137
8.3　本章小结	142
第9章　MyBatis的基本用法	143
9.1　MyBatis的体系结构	144
9.1.1　SqlSessionFactory	144
9.1.2　SqlSession	144
9.2　深入MyBatis的配置文件	146
9.2.1　MyBatis的配置文件结构	147
9.2.2　properties属性	147
9.2.3　settings设置	148
9.2.4　typeAliases类型命名	150
9.2.5　typeHandlers类型处理器	151
9.2.6　objectFactory对象工厂	152
9.2.7　environments配置环境	152
9.2.8　mapper映射器	154
9.3　深入Mapper XML映射文件	155
9.3.1　select	155
9.3.2　insert、update和delete	157
9.3.3　sql	158
9.3.4　参数（Parameters）	159
示例：测试select、insert、update和delete操作	159
9.3.5　ResultMaps	163
示例：测试ResultMaps	163
9.4　本章小结	169
第10章　MyBatis的关联映射和动态SQL	170
10.1　MyBatis的关联映射	171
10.1.1　一对一	171
示例：OneToOneTest	171
10.1.2　一对多	174
示例：OneToManyTest	174
10.1.3　多对多	179
示例：ManyToManyTest	179
10.2　动态SQL	185
示例：DynamicSQLTest	185
10.2.1　if	186
10.2.2　choose（when、otherwise）	188
10.2.3　where	190
10.2.4　set	191
10.2.5　foreach	192
10.2.6　bind	193
10.3　本章小结	194
第11章　MyBatis的事务管理和缓存机制	195
11.1　MyBatis的事务管理	196
11.1.1　事务的概念	196
11.1.2　Transaction接口	196
11.1.3　事务的配置创建和使用	197
11.2　MyBatis的缓存机制	201
11.2.1　一级缓存（SqlSession级别）	201
示例OneLevelCacheTest	201
11.2.2　二级缓存（mapper级别）	204
示例：TwoLevelCacheTest	204
11.3　本章小结	207
第12章　MyBatis的注解配置	208
12.1　常用Annotation注解	209
12.2　Annotation注解的使用	209
示例：测试select、insert、update和delete操作	210
示例：AOneToOneTest	213
示例：AOneToManyTest	215
示例：AManyToManyTest	216
示例：ADynamicSQLTest	218
12.3　本章小结	224
第13章　Spring4整合MyBatis3	225
13.1　开发环境搭建	226
13.2　准备所需的jar包	226
13.3　准备数据库资源	226
13.4　完成配置文件	227
13.5　持久层功能实现	229
13.6　服务层功能实现	230
13.7　控制层功能实现	232
13.8　jsp页面	233
13.9　测试Spring4整合MyBatis3	234
13.10　本章小结	235
第14章　实战项目：人事管理系统	236
14.1　项目简介及系统结构	237
14.1.1　系统功能介绍	237
14.1.2　相关技术介绍	238
14.1.3　系统结构	238
14.1.4　系统的功能模块	239
14.2　数据表和持久化类	239
14.2.1　设计数据库表	239
14.2.2　设计持久化实体	241
14.2.3　创建持久化实体类	242
14.3　实现DAO持久层	248
14.3.1　公共常量类	249
14.3.2　定义DAO接口	249
14.3.3　部署DAO层	263
14.4　实现Service持久层	264
14.4.1　业务逻辑组件的设计	264
14.4.2　实现业务逻辑组件	264
14.4.3　事务管理	279
14.4.4　部署业务逻辑组件	279
14.5　实现Web层	280
14.5.1　控制器的处理顺序	280
14.5.2　用户管理	283
14.5.3　部门管理	287
14.5.4　职位管理	290
14.5.5　员工管理	292
14.5.6　公告管理	296
14.5.7　下载中心	299
14.6　本章小结	303
附录A　EL表达式和JSTL标签库	304
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring+MyBatis企业应用实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java设计模式
第1章 设计模式介绍 1
1.1 为什么使用模式 1
1.2 为什么使用设计模式 2
1.3 为什么使用Java 2
1.4 UML 3
1.5 自我突破 3
1.6 本书的组织方式 3
1.7 欢迎来到Oozinoz公司 4
1.8 小结 5
第一部分 接口型模式
第2章 接口型模式介绍 8
2.1 接口和抽象类 8
2.2 接口和责任 9
2.3 小结 10
2.4 超越普通接口 10
第3章 Adapter (适配器) 模式 11
3.1 接口适配 11
3.2 类和对象适配器 14
3.3 为JTable适配数据 16
3.4 标识适配器 20
3.5 小结 20
第4章 Facade (外观) 模式 21
4.1 外观类、工具类和示例类 21
4.2 重构为Facade模式 22
4.3 小结 29
第5章 Composite (组合) 模式 30
5.1 常见的组合 30
5.2 Composite模式的递归特性 31
5.3 组合、树和环 32
5.4 含有环的Composite模式 35
5.5 环的影响 38
5.6 小结 39
第6章 Bridge (桥接) 模式 40
6.1 经典范例：普通抽象 40
6.2 从抽象到Bridge模式 42
6.3 应用Bridge模式的驱动程序 43
6.4 数据库驱动程序 44
6.5 小结 45
第二部分 责任型模式
第7章 责任型模式介绍 48
7.1 常见的责任型模式 48
7.2 通过可见性属性控制责任 49
7.3 小结 50
7.4 超越普通责任型模式 50
第8章 Singleton (单例) 模式 51
8.1 Singleton模式机制 51
8.2 单例和线程 52
8.3 识别单例 53
8.4 小结 54
第9章 Observer (观察者) 模式 55
9.1 经典范例：GUI中的Observer模式 55
9.2 模型/视图/控制器 58
9.3 维护Observable类对象 62
9.4 小结 64
第10章 Mediator (中介者) 模式 65
10.1 经典范例：GUI的Mediator模式 65
10.2 利用Mediator模式管理关系完整性 68
10.3 小结 73
第11章 Proxy (代理) 模式 74
11.1 经典范例：图像代理 74
11.2 重新思考图像代理 78
11.3 远程代理 79
11.4 动态代理 84
11.5 小结 87
第12章 Chain of Responsibility (责任链) 模式 88
12.1 常见的责任链 88
12.2 重构为Chain of Responsibility模式 89
12.3 固定责任链 91
12.4 不带组合结构的Chain of Responsibility模式 92
12.5 小结 93
第13章 Flyweight (享元) 模式 94
13.1 不变性 94
13.2 提取享元中不可变的部分 95
13.3 共享享元 96
13.4 小结 99
第三部分 构造型模式
第14章 构造型模式介绍 102
14.1 普通构造的挑战 102
14.2 小结 103
14.3 超越普通构造 103
第15章 Builder (生成器) 模式 105
15.1 常见的生成器 105
15.2 根据约束构造对象 107
15.3 根据不完整信息构造符合约束的对象 109
15.4 小结 109
第16章 Factory Method (工厂方法) 模式 110
16.1 经典范例：迭代器 110
16.2 识别Factory Method模式 111
16.3 决定要实例化的对象 111
16.4 并行层次结构中的Factory Method模式 112
16.5 小结 114
第17章 Abstract Factory (抽象工厂) 模式 115
17.1 经典范例：GUI工具包 115
17.2 抽象工厂和工厂方法 118
17.3 包和抽象工厂 121
17.4 小结 122
第18章 Prototype (原型) 模式 123
18.1 作为工厂的原型 123
18.2 利用克隆进行原型化 124
18.3 小结 126
第19章 Memento (备忘录) 模式 127
19.1 经典范例：使用备忘录实现撤销操作 127
19.2 备忘录的持久性 132
19.3 跨越会话的持久性备忘录 132
19.4 小结 135
第四部分 操作型模式
第20章 操作型模式介绍 138
20.1 操作和方法 138
20.2 签名 139
20.3 异常 139
20.4 算法和多态性 140
20.5 小结 141
20.6 超越普通操作 141
第21章 Template Method (模板方法) 模式 142
21.1 经典范例：排序 142
21.2 完成算法 145
21.3 Template Method模式钩子 147
21.4 重构为Template Method模式 148
21.5 小结 149
第22章 State (状态) 模式 150
22.1 状态建模 150
22.2 重构为State模式 153
22.3 使状态成为常量 156
22.4 小结 157
第23章 Strategy (策略) 模式 158
23.1 策略建模 158
23.2 重构为Strategy模式 160
23.3 比较Strategy模式和State模式 163
23.4 比较Strategy模式和Template Method模式 164
23.5 小结 164
第24章 Command (命令) 模式 165
24.1 经典范例：菜单命令 165
24.2 使用Command模式提供服务 167
24.3 Command模式钩子 168
24.4 Command模式与其他模式的关系 169
24.5 小结 170
第25章 Interpreter (解释器) 模式 171
25.1 Interpreter模式范例 171
25.2 解释器、语言和解析器 180
25.3 小结 180
第五部分 扩展型模式
第26章 扩展型模式介绍 184
26.1 面向对象设计原则 184
26.2 Liskov替换原则 (LSP) 184
26.3 Demeter法则 185
26.4 消除代码坏味 186
26.5 超越普通的扩展 187
26.6 小结 187
第27章 Decorator (装饰器) 模式 188
27.1 经典范例：流和输出器 188
27.2 函数包装器 193
27.3 与其他模式相关的Decorator模式 199
27.4 小结 199
第28章 Iterator (迭代器) 模式 200
28.1 常规迭代 200
28.2 线程安全的迭代 201
28.3 对组合结构进行迭代 206
28.3.1 组合枚举器的深度 211
28.3.2 枚举叶节点 212
28.4 小结 213
第29章 Visitor (访问者) 模式 214
29.1 Visitor模式机制 214
29.2 常见的Visitor模式 216
29.3 Visitor模式循环 220
29.4 Visitor模式危机 223
29.5 小结 224
第六部分 附录
附录A 指南 226
A.1 从本书中学到更多 226
A.2 理解设计模式的典型范例 226
A.3 在实践中应用设计模式 227
A.4 不断地学习 228
附录B 参考答案 229
B.1 接口型模式介绍 (第2章) 229
B.2 Adapter (适配器) 模式 (第3章) 230
B.3 Fa?ade (外观) 模式 (第4章) 233
B.4 Composite (组合) 模式 (第5章) 235
B.5 Bridge (桥接) 模式 (第6章) 237
B.6 责任型模式介绍 (第7章) 239
B.7 Singleton (单例) 模式 (第8章) 240
B.8 Observer (观察者) 模式 (第9章) 241
B.9 Mediator (中介者) 模式 (第10章) 245
B.10 Proxy (代理) 模式 (第11章) 248
B.11 Chain of Responsibility (责任链) 模式 (第12章) 249
B.12 Flyweight (享元) 模式 (第13章) 252
B.13 构造型模式介绍 (第14章) 254
B.14 Builder (生成器) 模式 (第15章) 255
B.15 Factory Method (工厂方法) 模式(第16章) 257
B.16 Abstract Factory (抽象工厂) 模式 (第17章) 260
B.17 Prototype (原型) 模式 (第18章) 262
B.18 Memento (备忘录) 模式 (第19章) 264
B.19 操作模式介绍 (第20章) 266
B.20 Template Method (模板方法) 模式 (第21章) 267
B.21 State (状态) 模式 (第22章) 268
B.22 Strategy (策略) 模式 (第23章) 270
B.23 Command (命令) 模式 (第24章) 271
B.24 Interpreter (解释器) 模式 (第25章) 274
B.25 扩展型模式介绍 (第26章) 275
B.26 Decorator (装饰器) 模式 (第27章) 276
B.27 Iterator (迭代器) 模式 (第28章) 278
B.28 Visitor (访问者) 模式 (第29章) 279
附录C Oozinoz源代码 282
C.1 获取和使用源代码 282
C.2 构建Oozinoz源代码 282
C.3 使用JUnit测试代码 282
C.4 自己查找文件 283
C.5 小结 283
附录D UML概览 284
D.1 类 284
D.2 类间关系 285
D.3 接口 286
D.4 对象 287
D.5 状态 288
词汇表 289
参考文献 294
索引 296
设计模式列表 308
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>算法（第4版）
目录
第1章　 基础　　1
1.1　基础编程模型　　4
1.1.1　Java程序的基本结构　　4
1.1.2　原始数据类型与表达式　　6
1.1.3　 语句　　8
1.1.4　 简便记法　　9
1.1.5　 数组　　10
1.1.6　 静态方法　　12
1.1.7　 API　　16
1.1.8　 字符串　　20
1.1.9　 输入输出　　21
1.1.10　 二分查找　　28
1.1.11　 展望　　30
1.2　 数据抽象　　38
1.2.1　 使用抽象数据类型　　38
1.2.2　 抽象数据类型举例　　45
1.2.3　 抽象数据类型的实现　　52
1.2.4　 更多抽象数据类型的实现　　55
1.2.5　 数据类型的设计　　60
1.3　 背包、队列和栈　　74
1.3.1　 API　　74
1.3.2　 集合类数据类型的实现　　81
1.3.3　 链表　　89
1.3.4　 综述　　98
1.4　 算法分析　　108
1.4.1　 科学方法　　108
1.4.2　 观察　　108
1.4.3　 数学模型　　112
1.4.4　 增长数量级的分类　　117
1.4.5　 设计更快的算法　　118
1.4.6　 倍率实验　　121
1.4.7　 注意事项　　123
1.4.8　 处理对于输入的依赖　　124
1.4.9　 内存　　126
1.4.10　 展望　　129
1.5　 案例研究：union-find算法　　136
1.5.1　 动态连通性　　136
1.5.2　 实现　　140
1.5.3　 展望　　148
第2章　 排序　　152
2.1　 初级排序算法　　153
2.1.1　 游戏规则　　153
2.1.2　 选择排序　　155
2.1.3　 插入排序　　157
2.1.4　 排序算法的可视化　　159
2.1.5　 比较两种排序算法　　159
2.1.6　 希尔排序　　162
2.2　 归并排序　　170
2.2.1　 原地归并的抽象方法　　170
2.2.2　 自顶向下的归并排序　　171
2.2.3　 自底向上的归并排序　　175
2.2.4　 排序算法的复杂度　　177
2.3　 快速排序　　182
2.3.1　 基本算法　　182
2.3.2　 性能特点　　185
2.3.3　 算法改进　　187
2.4　 优先队列　　195
2.4.1　 API　　195
2.4.2　 初级实现　　197
2.4.3　 堆的定义　　198
2.4.4　 堆的算法　　199
2.4.5　 堆排序　　205
2.5　 应用　　214
2.5.1　 将各种数据排序　　214
2.5.2　 我应该使用哪种排序算法　　218
2.5.3　 问题的归约　　219
2.5.4　 排序应用一览　　221
第3章　查找　　227
3.1　符号表　　228
3.1.1　API　　228
3.1.2　有序符号表　　230
3.1.3　用例举例　　233
3.1.4　无序链表中的顺序查找　　235
3.1.5　有序数组中的二分查找　　238
3.1.6　对二分查找的分析　　242
3.1.7　预览　　244
3.2　二叉查找树　　250
3.2.1　基本实现　　250
3.2.2　分析　　255
3.2.3　有序性相关的方法与删除操作　　257
3.3　平衡查找树　　269
3.3.1　2-3查找树　　269
3.3.2　红黑二叉查找树　　275
3.3.3　实现　　280
3.3.4　删除操作　　282
3.3.5　红黑树的性质　　284
3.4　散列表　　293
3.4.1　散列函数　　293
3.4.2　基于拉链法的散列表　　297
3.4.3　基于线性探测法的散列表　　300
3.4.4　调整数组大小　　304
3.4.5　内存使用　　306
3.5　应用　　312
3.5.1　我应该使用符号表的哪种实现　　312
3.5.2　集合的API　　313
3.5.3　字典类用例　　315
3.5.4　索引类用例　　318
3.5.5　稀疏向量　　322
第4章　 图　　329
4.1　 无向图　　331
4.1.1　 术语表　　331
4.1.2　 表示无向图的数据类型　　333
4.1.3　 深度优先搜索　　338
4.1.4　 寻找路径　　342
4.1.5　 广度优先搜索　　344
4.1.6　 连通分量　　349
4.1.7　 符号图　　352
4.1.8　 总结　　358
4.2　 有向图　　364
4.2.1　 术语　　364
4.2.2　 有向图的数据类型　　365
4.2.3　 有向图中的可达性　　367
4.2.4　 环和有向无环图　　369
4.2.5　 有向图中的强连通性　　378
4.2.6　 总结　　385
4.3　 最小生成树　　390
4.3.1　 原理　　391
4.3.2　 加权无向图的数据类型　　393
4.3.3　 最小生成树的API和测试用例　　396
4.3.4　 Prim算法　　398
4.3.5　 Prim算法的即时实现　　401
4.3.6　 Kruskal算法　　404
4.3.7　 展望　　407
4.4　 最短路径　　412
4.4.1　 最短路径的性质　　413
4.4.2　 加权有向图的数据结构　　414
4.4.3　 最短路径算法的理论基础　　420
4.4.4　 Dijkstra算法　　421
4.4.5　 无环加权有向图中的最短路径算法　　425
4.4.6　 一般加权有向图中的最短路径问题　　433
4.4.7　 展望　　445
第5章　 字符串　　451
5.1　 字符串排序　　455
5.1.1　 键索引计数法　　455
5.1.2　 低位优先的字符串排序　　458
5.1.3　 高位优先的字符串排序　　461
5.1.4　 三向字符串快速排序　　467
5.1.5　 字符串排序算法的选择　　470
5.2　 单词查找树　　474
5.2.1　 单词查找树　　475
5.2.2　 单词查找树的性质　　483
5.2.3　 三向单词查找树　　485
5.2.4　 三向单词查找树的性质　　487
5.2.5　 应该使用字符串符号表的哪种实现　　489
5.3　 子字符串查找　　493
5.3.1　 历史简介　　493
5.3.2　 暴力子字符串查找算法　　494
5.3.3　 Knuth-Morris-Pratt子字符串查找算法　　496
5.3.4　 Boyer-Moore字符串查找算法　　502
5.3.5　 Rabin-Karp指纹字符串查找算法　　505
5.3.6　 总结　　509
5.4　 正则表达式　　514
5.4.1　 使用正则表达式描述模式　　514
5.4.2　 缩略写法　　516
5.4.3　 正则表达式的实际应用　　517
5.4.4　 非确定有限状态自动机　　518
5.4.5　 模拟NFA的运行　　520
5.4.6　 构造与正则表达式对应的
5.5　 数据压缩　　529
5.5.1　 游戏规则　　529
5.5.2　 读写二进制数据　　530
5.5.3　 局限　　533
5.5.4　 热身运动：基因组　　534
5.5.5　 游程编码　　537
5.5.6　 霍夫曼压缩　　540
第6章　 背景　　558
索引　　611
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>算法（第4版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>测试驱动开发的艺术
第一部分 TDD入门
第1章 综述	2
1.1 挑战：用正确的方法解决正确的问题	3
1.1.1 糟糕的代码质量	3
1.1.2 不能满足客户需求	4
1.2 解决方案：测试驱动	4
1.2.1 高质量的TDD	5
1.2.2 用ATDD满足客户需求	6
1.2.3 这对我有什么好处	7
1.3 正确地做事：TDD	9
1.3.1 测试—编码—重构	9
1.3.2 增量式开发	12
1.3.3 重构以保持代码的健康	16
1.3.4 保证软件正常运行	18
1.4 做正确的事：ATDD	20
1.4.1 名字的含义	20
1.4.2 紧密协作	21
1.4.3 把测试作为沟通的共同语言	22
1.5 TDD工具	23
1.5.1 使用xUnit做单元测试	23
1.5.2 支持ATDD的测试框架	23
1.5.3 持续集成及构建	24
1.5.4 代码覆盖率	25
1.6 小结	26
第2章 TDD入门	28
2.1 从需求到测试	29
2.1.1 分解需求	29
2.1.2 什么是好的测试	30
2.1.3 依照测试的列表工作	30
2.1.4 意图编程	30
2.2 选择第一个测试	31
2.2.1 创建测试列表	31
2.2.2 写第一个失败的测试	32
2.2.3 通过第一个测试	34
2.2.4 再加一个测试	36
2.3 广度优先，深度优先	38
2.3.1 继续使用伪实现	39
2.3.2 清除掉伪实现	39
2.4 别忘了重构	41
2.4.1 测试代码中的可重构之处	42
2.4.2 移除多余的测试	43
2.5 添加错误处理	44
2.5.1 验证异常	44
2.5.2 把方法重构得更短些	45
2.5.3 保持方法平衡	46
2.5.4 验证异常中的详细信息	47
2.6 无穷尽的测试	48
2.6.1 性能测试	48
2.6.2 有些失望的结局	49
2.7 小结	50
第3章 小步重构	51
3.1 探寻解决方案	51
3.1.1 用Spike开发原型	52
3.1.2 写测试学知识	52
3.1.3 学习API的Spike样例	52
3.2 以受控的方式修改设计	54
3.3 进一步延伸新设计	61
3.3.1 保持兼容	62
3.3.2 替换实现	66
3.4 小结	68
第4章 TDD的概念与模式	69
4.1 如何编写及通过测试	70
4.1.1 测试选择技巧	70
4.1.2 实现技巧	72
4.1.3 测试驱动的基本准则	73
4.2 重要的测试概念	74
4.2.1 夹具是测试的上下文	74
4.2.2 用测试替身替换依赖	76
4.2.3 基于状态及基于交互的的测试	76
4.3 近处观察测试替身	78
4.3.1 测试替身的例子	78
4.3.2 伪实现、测试桩和模拟对象	79
4.3.3 模拟对象实战	80
4.4 提高设计的可测试性的准则	81
4.4.1 尽量使用组合而非继承	82
4.4.2 避免使用static关键字以及Singleton模式	83
4.4.3 隔离依赖	84
4.4.4 注入依赖	86
4.5 单元测试模式	88
4.5.1 断言模式	89
4.5.2 夹具模式	92
4.5.3 测试模式	95
4.6 在遗留代码基础上工作	101
4.6.1 测试驱动遗留开发	101
4.6.2 分析变化	102
4.6.3 准备好变化	103
4.6.4 测试驱动变更	103
4.7 小结	104
第二部分 针对特定技术应用TDD
第5章 测试驱动Web组件	106
5.1 在60秒内介绍Web应用中的MVC	107
5.2 控制器	107
5.2.1 测试驱动Java Servlets	108
5.2.2 测试驱动Spring控制器	117
5.3 用测试先行的方法构建视图	120
5.3.1 用JspTest测试驱动JSP	121
5.3.2 测试驱动Velocity模板	125
5.4 在基于控件的Web框架基础上TDD	129
5.4.1 剖析典型框架	130
5.4.2 用测试先行的方法开发Wicket页面	130
5.5 小结	135
第6章 测试驱动数据访问	137
6.1 探索问题领域	137
6.1.1 跨越边界的数据访问	138
6.1.2 用DAO模式分层	138
6.2 用单元测试驱动数据访问	139
6.2.1 JDBC API的缺点	140
6.2.2 用Spring的JdbcTemplate简化开发	144
6.2.3 用Hibernate轻松地做TDD	149
6.3 编码前写集成测试	155
6.3.1 什么是集成测试	155
6.3.2 选择数据库	157
6.4 集成测试实战	159
6.4.1 第一个Hibernate集成测试	159
6.4.2 创建数据库模式	162
6.4.3 实现产品代码	164
6.4.4 用事务夹具保持数据清洁	165
6.5 为集成测试填充数据	166
6.5.1 用Hibernate填充对象	167
6.5.2 用DbUnit填充数据	168
6.6 使用单元测试还是集成测试	172
6.6.1 在TDD周期中使用集成测试	172
6.6.2 两全其美	173
6.7 文件系统访问	173
6.7.1 项目中实际遇到的一个问题	174
6.7.2 提高文件访问可测试性的实践	174
6.8 小结	175
第7章 测试驱动不可预测功能	177
7.1 测试驱动时间相关功能	177
7.1.1 例子：日志和时间戳	177
7.1.2 抽象出系统时间	179
7.1.3 用虚设的系统时间测试日志输出	181
7.2 测试驱动多线程代码	184
7.2.1 该测什么	184
7.2.2 线程安全	185
7.2.3 阻塞操作	189
7.2.4 启动及中止线程	191
7.2.5 异步执行	193
7.2.6 线程同步	195
7.3 标准同步对象	196
7.3.1 信号量	196
7.3.2 latche	196
7.3.3 barrier	196
7.3.4 futures	197
7.4 小结	197
第8章 测试驱动Swing代码	198
8.1 Swing UI中该测试什么	198
8.1.1 内部基础设施及实用程序	199
8.1.2 渲染及布局	199
8.1.3 交互	199
8.2 可测试UI代码的模式	200
8.2.1 经典MVP	201
8.2.2 Supervising Controller	201
8.2.3 Passive View	203
8.3 测试视图控件的工具	205
8.3.1 为什么要用工具	205
8.3.2 TDD友好的工具	206
8.4 测试驱动视图组件	210
8.4.1 着手设计	211
8.4.2 添加及操作标准控件	212
8.4.3 绘图	216
8.4.4 给点添加行为	224
8.5 小结	227
第三部分 基于ATDD构建产品
第9章 解析验收测试驱动开发	230
9.1 用户故事介绍	231
9.1.1 故事的格式	231
9.1.2 讲故事的力量	231
9.1.3 用户故事的例子	232
9.2 验收测试	232
9.2.1 故事的样例测试	232
9.2.2 验收测试的特征	233
9.2.3 实现验收测试	236
9.3 理解过程	237
9.3.1 ATDD周期	237
9.3.2 迭代内的ATDD	242
9.4 作为团队活动的ATDD	245
9.4.1 客户角色定义	245
9.4.2 客户与谁一起写测试	246
9.4.3 需要多少测试人员	247
9.5 ATDD的好处	247
9.5.1 “完成”的定义	247
9.5.2 协作	248
9.5.3 信任及承诺	249
9.5.4 通过例子验收	249
9.5.5 弥合差距	249
9.6 我们究竟要测试什么	250
9.6.1 应该针对UI测试吗	250
9.6.2 可以使用部分系统的伪实现吗	251
9.6.3 应该直接测试领域逻辑吗	251
9.7 工具概览	252
9.7.1 基于表格的框架	252
9.7.2 基于文本的框架	253
9.7.3 基于脚本语言的框架	254
9.7.4 自制工具	254
9.8 小结	254
第10章 用Fit创建验收测试	256
10.1 Fit是什么	256
10.1.1 用Fit进行ATDD	257
10.1.2 包含夹具表的测试文档	259
10.1.3 夹具：表格和类的结合	260
10.2 三个内建夹具	261
10.2.1 ColumnFixture	261
10.2.2 RowFixture	263
10.2.3 ActionFixture	266
10.2.4 扩展内建夹具	268
10.3 FitLibrary对内建夹具的扩展	269
10.3.1 DoFixture	269
10.3.2 SetUpFixture	272
10.3.3 还有更多功能	273
10.4 执行Fit测试	273
10.4.1 单个测试文档	274
10.4.2 把所有测试放在一个目录结构中	274
10.4.3 把测试整合进自动化测试中	275
10.5 小结	276
第11章 执行验收测试的策略	277
11.1 验收测试该检测什么	277
11.1.1 抓住问题本质	278
11.1.2 避免波动频繁界面	278
11.1.3 在技术障碍最小的地方越过	279
11.2 实现方式	279
11.2.1 端到端	280
11.2.2 绕过UI进行测试	281
11.2.3 直接测试内部逻辑	284
11.2.4 替换无关组件	285
11.2.5 测试后门	286
11.3 技术相关考虑	287
11.3.1 库	287
11.3.2 无界面的分布式系统	288
11.3.3 控制台应用	289
11.3.4 GUI应用	290
11.3.5 Web应用	293
11.4 常见问题的处理技巧	295
11.4.1 加快测试执行速度	296
11.4.2 减少测试的复杂度	299
11.4.3 管理测试数据	300
11.5 小结	301
第12章 TDD应用	302
12.1 成功采用TDD的必要条件	302
12.1.1 理解本质	302
12.1.2 紧迫感	303
12.1.3 成就感	303
12.1.4 表现诚实	304
12.1.5 变革的时机	304
12.2 让其他人参与进来	305
12.2.1 引导变革的角色和能力	305
12.2.2 改变需要时间	307
12.3 如何应对阻力	307
12.3.1 识别阻力	307
12.3.2 应对阻力的三种常见方法	309
12.3.3 应对阻力的技巧	310
12.3.4 挑选战场	312
12.4 如何推进变革	313
12.4.1 造势	313
12.4.2 降低门槛	314
12.4.3 培训	315
12.4.4 共享及感染	316
12.4.5 指导和督促	317
12.4.6 通过分配角色让人们参与进来	318
12.4.7 打破稳定状态	319
12.4.8 迟后的奖励	319
12.5 小结	319
附录A  JUnit 4简明教程	321
附录B  JUnit 3.8简明教程	323
附录C  EasyMock简明教程	325
附录D  通过Ant运行测试	327
相关资源	331
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>测试驱动开发的艺术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计语言
第1章 快速浏览 1
1.1 开始 1
1.2 变量 2
1.3 代码中的注释 4
1.4 具名常量 5
1.5 Unicode字符 6
1.6 控制流 6
1.7 类和对象 8
1.7.1 创建对象 9
1.7.2 静态字段 (类字段) 10
1.7.3 垃圾回收器 10
1.8 方法和参数 10
1.8.1 调用方法 11
1.8.2 this引用 11
1.8.3 静态方法 (类方法) 12
1.9 数组 12
1.10 字符串对象 14
1.11 扩展一个类 16
1.11.1 调用超类的方法 17
1.11.2 Object类 18
1.11.3 类型强制转换 18
1.12 接口 18
1.13 泛型类型 20
1.14 异常 22
1.15 注解 23
1.16 包 24
1.17 Java平台 25
1.18 其他主题概述 26
第2章 类与对象 27
2.1 一个简单的类 27
2.1.1 类成员 28
2.1.2 类修饰符 28
2.2 字段 28
2.2.1 字段的初始化 29
2.2.2 静态字段 29
2.2.3 final字段 30
2.3 访问控制 31
2.4 创建对象 32
2.5 构造与初始化 32
2.5.1 构造器 33
2.5.2 初始化块 35
2.5.3 静态初始化 36
2.6 方法 37
2.6.1 静态方法 37
2.6.2 方法调用 38
2.6.3 引元数量可变的方法 39
2.6.4 方法异常与返回 40
2.6.5 参数值 41
2.6.6 使用方法来控制访问 43
2.7 this 45
2.8 重载方法 45
2.9 导入静态成员名 47
2.10 main方法 48
2.11 本地方法 49
第3章 类的扩展 50
3.1 扩展类 50
3.2 扩展类的构造器 53
3.3 继承与重定义成员 56
3.3.1 覆盖 56
3.3.2 隐藏字段 57
3.3.3 访问继承的成员 57
3.3.4 可访问性与覆盖 59
3.3.5 隐藏静态成员 59
3.3.6 super关键字 59
3.4 类型兼容与转换 60
3.4.1 兼容性 60
3.4.2 显式的类型强制转换 61
3.4.3 类型检测 61
3.5 protected的真正含义 62
3.6 将方法与类标记为final 64
3.7 抽象类与抽象方法 65
3.8 Object类 66
3.9 克隆对象 68
3.9.1 克隆的策略 68
3.9.2 正确克隆 69
3.9.3 浅克隆与深克隆 71
3.10 扩展类： 如何扩展以及何时扩展 72
3.11 设计一个可扩展的类 73
3.12 单重继承与多重继承 77
第4章 接口 79
4.1 一个简单的接口示例 79
4.2 接口声明 81
4.2.1 接口常量 81
4.2.2 接口方法 82
4.2.3 接口修饰符 82
4.3 扩展接口 83
4.3.1 继承和隐藏常量 83
4.3.2 继承、覆盖和重载方法 84
4.4 使用接口 85
4.4.1 实现接口 86
4.4.2 使用实现 87
4.5 标记接口 88
4.6 何时使用接口 88
第5章 嵌套类和接口 90
5.1 静态嵌套类型 90
5.1.1 静态嵌套类 90
5.1.2 嵌套接口 92
5.2 内部类 92
5.2.1 访问包围对象 93
5.2.2 扩展内部类 94
5.2.3 继承、作用字段和隐藏 95
5.3 局部内部类 96
5.4 匿名内部类 98
5.5 继承嵌套类型 99
5.6 接口中的嵌套 100
5.7 嵌套类型的实现 101
第6章 枚举类型 102
6.1 一个简单的枚举类型的例子 102
6.2 枚举声明 103
6.3 枚举常量的声明 104
6.3.1 构造 104
6.3.2 常量相关的行为 105
6.4 java.lang.Enum 107
6.5 是否应该使用枚举 108
第7章 语言符号、值和变量 109
7.1 词法元素 109
7.1.1 字符集 109
7.1.2 注释 110
7.1.3 语言符号 111
7.1.4 标识符 111
7.1.5 关键字 112
7.2 类型和字面常量 112
7.2.1 引用型字面常量 113
7.2.2 布尔型字面常量 113
7.2.3 字符型字面常量 113
7.2.4 整型字面常量 113
7.2.5 浮点型字面常量 113
7.2.6 字符串型字面常量 114
7.2.7 类字面常量 114
7.3 变量 115
7.3.1 字段和局部变量的声明 115
7.3.2 参数变量 116
7.3.3 final变量 116
7.4 数组变量 117
7.4.1 数组修饰符 118
7.4.2 数组的数组 118
7.4.3 数组初始化 118
7.4.4 数组和类型 119
7.5 名字的意义 120
第8章 包装器类 123
8.1 通用字段和方法 124
8.1.1 构造 124
8.1.2 常量 124
8.1.3 公共方法 125
8.2 Void类 126
8.3 Boolean类 126
8.4 Number类 126
8.4.1 整型包装器 126
8.4.2 浮点型包装器类 128
8.5 Character类 129
8.6 装箱转换 133
第9章 运算符和表达式 135
9.1 算术运算 135
9.1.1 整数运算 135
9.1.2 浮点运算 136
9.1.3 严格浮点运算和非严格浮点运算 137
9.2 通用运算符 137
9.2.1 递增运算符和递减运算符 137
9.2.2 关系运算符和判等运算符 138
9.2.3 逻辑运算符 139
9.2.4 instanceof 140
9.2.5 位操作运算符 140
9.2.6 条件运算符?:  141
9.2.7 赋值运算符 142
9.2.8 字符串连接运算符 143
9.2.9 new 144
9.3 表达式 144
9.3.1 计算顺序 144
9.3.2 表达式类型 145
9.4 类型转换 145
9.4.1 隐式类型转换 145
9.4.2 显式类型强制转换 147
9.4.3 字符串转换 148
9.5 运算符优先级和结合性 148
9.6 成员访问 150
第10章 控制流 154
10.1 语句和块 154
10.2 if-else 155
10.3 switch 156
10.4 while和do-while 158
10.5 for 159
10.5.1 基本的for语句 159
10.5.2 增强的for语句 161
10.6 标号 162
10.7 break 162
10.8 continue 164
10.9 return 165
10.10 什么？没有goto？ 165
第11章 泛型类型 167
11.1 泛型类型声明 169
11.1.1 有界类型参数 170
11.1.2 嵌套泛型类型 171
11.2 使用泛型类型 173
11.3 泛型方法和泛型构造器 176
11.4 通配符捕获 179
11.5 揭秘：擦除与原始类型 181
11.5.1 运行时擦除 181
11.5.2 重载与覆盖 183
11.6 再谈寻找正确的方法 184
11.7 类的扩展与泛型类型 187
第12章 异常与断言 189
12.1 创建异常类型 189
12.2 throw 191
12.2.1 控制的转移 191
12.2.2 异步异常 191
12.3 throws子句 192
12.3.1 throws子句和方法覆盖 193
12.3.2 throws子句和本地方法 193
12.4 try、catch和finally 194
12.5 异常链 197
12.6 栈轨迹 199
12.7 什么时候使用异常 199
12.8 断言 200
12.9 什么时候使用断言 201
12.9.1 状态断言 201
12.9.2 控制流断言 202
12.10 打开和关闭断言 203
12.10.1 为什么要开关断言？ 203
12.10.2 在命令行控制断言 203
12.10.3 彻底移除 204
12.10.4 使断言成为必需的 204
第13章 字符串与正则表达式 206
13.1 字符序列 206
13.2 String类 206
13.2.1 基本的String操作 207
13.2.2 字符串比较 208
13.2.3 字符串字面常量、等同性和内存限定 210
13.2.4 创建相关字符串 211
13.2.5 字符串转换 214
13.2.6 字符串和char数组 215
13.2.7 字符串和byte数组 215
13.2.8 字符集编码方式 216
13.3 正则表达式的匹配 217
13.3.1 正则表达式 217
13.3.2 正则表达式的编译和匹配 218
13.3.3 替换 220
13.3.4 区域 222
13.3.5 效率 223
13.4 StringBuilder类 223
13.4.1 修改缓冲区 224
13.4.2 取出数据 225
13.4.3 容量管理 226
13.4.4 StringBuffer类 227
13.5 使用UTF-16 227
第14章 线程 229
14.1 创建线程 230
14.2 使用Runnable 232
14.3 同步 235
14.3.1 synchronized方法 235
14.3.2 静态synchronized方法 237
14.3.3 synchronized语句 237
14.3.4 同步设计 240
14.4 wait、notifyAll和notify 241
14.5 等待和通知的详细介绍 243
14.6 线程调度 244
14.7 死锁 247
14.8 结束线程的执行 248
14.8.1 取消线程 249
14.8.2 等待线程结束 250
14.9 结束应用程序的执行 251
14.10 内存模型： 同步和volatile 252
14.10.1 同步动作 253
14.10.2 final字段和安全 254
14.10.3 “之前发生”关系 254
14.11 线程管理、线程安全和ThreadGroup 255
14.12 线程和异常 258
14.12.1 不要使用stop 259
14.12.2 栈轨迹 260
14.13 ThreadLocal变量 260
14.14 调试线程 261
第15章 注解 263
15.1 一个简单的注解实例 263
15.2 注解类型 264
15.3 注解元素 266
15.4 限制注解的适用性 267
15.5 保存策略 268
15.6 使用注解 268
第16章 反射 270
16.1 Class类 272
16.1.1 类型符号 272
16.1.2 类检查 273
16.1.3 检查类成员 277
16.1.4 命名类 279
16.1.5 通过名字获取Class对象 281
16.1.6 运行时类型查询 281
16.2 注解查询 282
16.3 Modifier类 283
16.4 成员类 283
16.5 访问检查和AccessibleObject 284
16.6 Field类 284
16.7 Method类 286
16.8 创建新对象和Constructor类 288
16.9 泛型类型检查 290
16.9.1 类型变量 290
16.9.2 参数化类型 291
16.9.3 通配符 291
16.9.4 泛型数组 291
16.9.5 Type对象的字符串表示 292
16.10 数组 292
16.11 包 294
16.12 Proxy类 295
16.13 加载类 297
16.13.1 ClassLoader类 298
16.13.2 为类的使用做准备 300
16.13.3 加载相关资源 301
16.14 在运行时控制断言 302
第17章 垃圾回收与内存 304
17.1 垃圾回收 304
17.2 一个简单的模型 305
17.3 终结 305
17.4 与垃圾回收器交互 308
17.5 可达性状态和引用对象 309
17.5.1 Reference类 309
17.5.2 引用和可达性强度 310
17.5.3 引用队列 312
17.5.4 终结和可达性 316
第18章 包 317
18.1 包的命名 317
18.2 类型导入 318
18.3 包的访问 319
18.4 包的内容 322
18.5 包的注解 323
18.6 包对象和规范 323
第19章 文档注释 326
19.1 剖析文档注释 326
19.2 标签 327
19.2.1 @see 327
19.2.2 {@link}和{@linkplain} 328
19.2.3 @param 328
19.2.4 @return 328
19.2.5 @throws和@exception 328
19.2.6 @deprecated 329
19.2.7 @author 329
19.2.8 @version 329
19.2.9 @since 330
19.2.10 {@literal}和{@code} 330
19.2.11 {@value} 330
19.2.12 {@docRoot} 330
19.2.13 {@inheritDoc} 331
19.3 继承方法的文档注释 331
19.4 一个简单示例 332
19.5 外部规范 334
19.5.1 包文档和概述文档 334
19.5.2 doc-files目录 337
19.6 使用说明 337
第20章 I/O包 338
20.1 流的概述 338
20.2 字节流 339
20.2.1 InputStream 340
20.2.2 OutputStream 342
20.3 字符流 343
20.3.1 Reader 344
20.3.2 Writer 345
20.3.3 字符流与标准流 346
20.4 InputStreamReader与OutputStreamWriter 346
20.5 流类简介 348
20.5.1 同步与并发 348
20.5.2 Filter流 349
20.5.3 Buffered流 351
20.5.4 Piped流 352
20.5.5 ByteArray字节流 353
20.5.6 CharArray字符流 354
20.5.7 String字符流 354
20.5.8 Print流 355
20.5.9 LineNumberReader 357
20.5.10 SequenceInputStream 358
20.5.11 Pushback流 359
20.5.12 StreamTokenizer 360
20.6 数据字节流 363
20.6.1 DataInput与DataOutput 364
20.6.2 Data流类 365
20.7 文件操作 366
20.7.1 File流与FileDescriptor 366
20.7.2 RandomAccessFile 367
20.7.3 File类 368
20.7.4 FilenameFilter与FileFilter 371
20.8 对象序列化 372
20.8.1 Object字节流 372
20.8.2 让我们的类成为可序列化的(Serializable) 373
20.8.3 序列化和反序列化顺序 375
20.8.4 定制序列化 375
20.8.5 对象版本机制 378
20.8.6 序列化字段 379
20.8.7 Externalizable接口 381
20.8.8 文档注释标签 381
20.9 IOException类 382
20.10 体验新I/O 383
第21章 集合 385
21.1 集合 385
21.2 迭代 387
21.3 使用Comparable和Comparator排序 389
21.4 Collection接口 390
21.5 Set和SortedSet 391
21.5.1 HashSet 392
21.5.2 LinkedHashSet 393
21.5.3 TreeSet 393
21.6 List 393
21.6.1 ArrayList 394
21.6.2 LinkedList 395
21.6.3 RandomAccess列表 396
21.7 Queue 396
21.8 Map和SortedMap 398
21.8.1 HashMap 400
21.8.2 LinkedHashMap 400
21.8.3 IdentityHashMap 401
21.8.4 WeakHashMap 401
21.8.5 TreeMap 402
21.9 enum集合 402
21.9.1 EnumSet 402
21.9.2 EnumMap 403
21.10 包装集合和Collections类 404
21.10.1 Collections工具 404
21.10.2 不可修改的包装器 407
21.10.3 检查型包装器 407
21.11 同步包装和并发集合 407
21.11.1 同步包装器 408
21.11.2 并发集合 409
21.12 Arrays工具类 411
21.13 编写迭代器实现 412
21.14 编写集合实现 413
21.15 遗留集合类型 417
21.15.1 Enumeration 417
21.15.2 Vector 418
21.15.3 Stack 419
21.15.4 Dictionary 419
21.15.5 Hashtable 419
21.16 Properties 419
第22章 各种常用工具 421
22.1 Formatter 421
22.1.1 格式说明符 422
22.1.2 整型转换 423
22.1.3 浮点转换 424
22.1.4 字符转换 425
22.1.5 通用转换 425
22.1.6 自定义格式化 425
22.1.7 格式控制异常 426
22.1.8 Formatter类 426
22.2 BitSet 427
22.3O bserver/Observable 429
22.4 Random 432
22.5 Scanner 433
22.5.1 数值流 433
22.5.2 扫描行 435
22.5.3 使用Scanner 437
22.5.4 本地化 440
22.6 StringTokenizer 440
22.7 Timer和TimerTask 441
22.8 UUID 444
22.9 Math和StrictMath 444
第23章 系统编程 447
23.1 System类 447
23.1.1 标准I/O流 447
23.1.2 系统属性 448
23.1.3 工具方法 449
23.2 创建进程 450
23.2.1 Process 451
23.2.2 进程环境 452
23.2.3 ProcessBuilder 453
23.2.4 可移植性 454
23.3 关闭 454
23.3.1 关闭挂钩 454
23.3.2 关闭序列 455
23.3.3 关闭策略 456
23.4 Runtime的其他部分 456
23.4.1 加载本地代码 457
23.4.2 调试 457
23.5 安全 457
23.5.1 SecurityManager类 458
23.5.2 权限 459
23.5.3 安全策略 460
23.5.4 访问控制器和特权执行 460
第24章 国际化与本地化 462
24.1 区域 462
24.2 资源束 464
24.2.1 ListResourceBundle 466
24.2.2 PropertyResourceBundle 467
24.2.3 子类化ResourceBundle 467
24.3 货币 468
24.4 时间、日期和日历 468
24.4.1 日历 469
24.4.2 时区 472
24.4.3 GregorianCalendar和SimpleTimeZone 473
24.5 格式化和解析日期与时间 474
24.6 文本的国际化和本地化 477
24.6.1 对照 477
24.6.2 格式化和解析 478
24.6.3 文本边界 480
第25章 标准包 482
25.1 java.awt——抽象窗口工具箱 483
25.2 java.applet——小应用程序 485
25.3 java.beans——构件 486
25.4 java.math——数学 486
25.5 java.net——网络 488
25.6 java.rmi——远程方法调用 490
25.7 java.security与相关的包——安全工具 493
25.8 java.sql——关系数据库访问 494
25.9 工具子包 494
25.9.1 并发工具java.util.concurrent 494
25.9.2 压缩文件工具java.util.jar 496
25.9.3 ZIP压缩文件工具java.util.zip 496
25.10 javax.*标准扩展 497
25.11 javax.accessibility——GUI的易用性 497
25.12 javax.naming——目录与命名服务 497
25.13 javax.sound——音频操作 498
25.14 javax.swing——Swing GUI构件 498
25.15 org.omg.CORBA--CORBA API 499
附录A 应用演化 500
附录B 常用表格 505
进阶读物 510
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计语言
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入体验Java Web开发内幕
第1章 XML基础
指点迷津：什么是配置文件
1.1 XML技术概述
1.1.1 XML的起源与作用
1.1.2 XML文档结构
1.1.3 XML与HTML的比较
1.1.4 XML与数据库的比较
1.2 XML的基本语法
1.2.1 文档声明
动手体验：加深对encoding属性的理解
1.2.2 元素定义
1.2.3 属性定义
1.2.4 注释
1.2.5 空格和换行的处理
1.2.6 CDATA区
1.2.7 特殊字符
动手体验：加深对特殊字符的了解
1.2.8 处理指令
动手体验：使用CSS控制XML文档的显示
1.3 XML的约束模式
1.3.1 格式良好的（Well-formed）XML
1.3.2 XML的约束模式
1.3.3 XML的约束模式语言
1.3.4 有效的（Valid）XML
1.4 DTD
1.4.1 对DTD的初步认识
1.4.2 在XML文档中引入外部DTD文件
1.4.3 在XML文档中直接嵌入DTD定义语句
1.5 DTD的语法细节
1.5.1 元素定义
1.5.2 属性定义
1.5.3 实体定义
动手体验：加深对引用实体的了解
1.6 XML Schema
1.6.1 XML Schema与DTD的比较
1.6.2 一个XML Schema例子
1.7 名称空间
1.7.1 名称空间的概念
1.7.2 名称空间声明
1.7.3 默认名称空间
1.7.4 属性的名称空间
1.7.5 xml:space和xml:lang属性
1.8 引入XML Schema文档
1.8.1 使用名称空间引入XML Schema文档
1.8.2 不使用名称空间引入XML Schema文档
1.9 思考与实践
第2章 用Tomcat构建Web站点
2.1 Web应用的相关知识
2.2 安装Tomcat
2.3 Tomcat的启动与停止
2.4 配置Web站点的虚拟目录
2.5 配置虚拟主机
2.6 与专用Web服务器的集成
2.7 思考与实践
第3章 HTTP协议详解
第4章 Servlet开发基础
第5章 HttpServletResponse的应用
第6章 HttpServletRequest的应用
第7章 会话与状态管理
第8章 JSP
第9章 JavaBean在JSP中的应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入体验Java Web开发内幕
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>超越 Java
前言
第一章 猫头鹰与鸵鸟
忽略是一种美德
水煮青蛙
新的水平线
预告
第二章 完美的风暴
风暴警告
C++的经验
拨云见日
暴怒的释放
事过境迁
向前走
第三章 皇冠上的宝石
语言和JVM的设计
因特网
企业集成
社区
打破迷思
第四章 打破玻璃
Java的新工作描述
基本的Java限制
类型
基本类型
分手时的刻薄话
为什么不直接修改Java？
第五章 游戏规则
Java提高竞争门槛
企业集成
产生话题
语言特色
几个有潜力的语言
第六章 Ruby简介
关于Ruby
应用某些结构
Breaking It Down
第七章 Ruby on Rails
数字游戏
Rails范例
查看内部
精华
第八章 延续服务器
问题
延续
延续服务器
Seaside
一个Seaside范例
那又怎样？
第九章 竞争者
主要竞争者
较小的竞争者
“下一个大东西”
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>超越 Java
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Head First 设计模式（中文版）
引子
谁适合读这本书?
我们知道你的大脑在想什么
元认知
让你的大脑就范
技术审校
致谢
1　欢迎来到设计模式世界：设计模式入门
模拟鸭子应用
Joe想到继承
利用接口如何？
软件开发的不变真理
分开变化和不变部分
设计鸭子的行为
测试鸭子的代码
动态地设置行为
封装行为的大局观
“有一个”比“是一个”更好
策略模式
共享模式词汇的威力
我如何使用设计模式？
设计箱内的工具
习题解答
2　让你的对象知悉现况
气象观测站
认识观察者模式
出版者＋订阅者＝观罕者模式
五分钟短剧：观察主题
定义观察者模式
松耦合的威力
设计气象站
实现气象站
使用Java内建的观察者模式
java.util.Observable的黑暗面
设计箱内的工具
习题解答
……
3　装饰者模式：装饰对象
4　工厂模式：烘烤OO的精华
5　单件模式：独一无二的对象
6　命令模式：封装调用
7　适配器模式与外观模式：随遇而安
8　模板方法模式：封装算法
9　送代器与组合模式：管理良好的集合
10　状态模式：事物的状态
11　代理模式：控制对象访问
12　复合模式：模式中的模式
13　与设计模式相处：真实世界中的模式
A　附录A：剩下的模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Head First 设计模式（中文版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java虚拟机并发编程
译者序
前言
第1章 并发的威力与风险 1
1.1 线程：程序的执行流程 1
1.2 并发的威力 1
1.3 并发的风险 4
1.4 小结 9
第一部分 并发策略
第2章 分工原则 11
2.1 从顺序到并发 11
2.2 在IO密集型应用程序中使用并发技术 13
2.3 并发方法对IO密集型应用程序的加速效果 19
2.4 在计算密集型应用程序中使用并发技术 20
2.5 并发方法对于计算密集型应用程序的加速效果 25
2.6 有效的并发策略 26
2.7 小结 27
第3章 设计方法 28
3.1 处理状态 28
3.2 探寻设计选项 29
3.3 共享可变性设计 29
3.4 隔离可变性设计 30
3.5 纯粹不可变性设计 30
3.6 持久的/不可变的数据结构 31
3.7 选择一种设计方法 34
3.8 小结 34
第二部分 现代Java/JDK并发模型
第4章 可扩展性和线程安全 37
4.1 用ExecutorService管理线程 37
4.2 使线程协作 38
4.3 数据交换 47
4.4 Java 7 Fork-Join API 49
4.5 可扩展集合类 51
4.6 Lock和Synchronized 54
4.7 小结 58
第5章 驯服共享可变性 59
5.1 共享可变性 != Public 59
5.2 定位并发问题 59
5.3 保持不变式 61
5.4 管理好资源 62
5.5 保证可见性 64
5.6 增强并发性 65
5.7 保证原子性 67
5.8 小结 70
第三部分 软件事务内存
第6章 软件事务内存导论 71
6.1 同步与并发水火不容 71
6.2 对象模型的缺陷 72
6.3 将实体与状态分离 73
6.4 软件事务内存 74
6.5 STM中的事务 77
6.6 用STM实现并发 77
6.7 用Akka/Multiverse STM实现并发 82
6.8 创建事务 84
6.9 创建嵌套事务 90
6.10 配置Akka事务 97
6.11 阻塞事务—有意识地等待 100
6.12 提交和回滚事件 103
6.13 集合与事务 106
6.14 处理写偏斜异常 110
6.15 STM的局限性 112
6.16 小结 116
第7章 在Clojure、Groovy、Java、JRuby和Scala中使用STM 117
7.1 Clojure STM 117
7.2 Groovy集成 118
7.3 Java集成 122
7.4 JRuby集成 124
7.5 Scala中的可选方案 130
7.6 小结 133
第四部分 基于角色的并发模型
第8章 讨喜的隔离可变性 135
8.1 用角色实现隔离可变性 136
8.2 角色的特性 137
8.3 创建角色 138
8.4 收发消息 144
8.5 同时使用多个角色 148
8.6 多角色协作 152
8.7 使用类型化角色 159
8.8 类型化角色和murmurs 163
8.9 混合使用角色和STM 169
8.10 使用transactor 169
8.11 调和类型化角色 176
8.12 远程角色 182
8.13 基于角色模型的局限性 184
8.14 小结 184
第9章 在Groovy、Java、JRuby和Scala中使用角色 186
9.1 在Groovy中使用GPars提供的角色实现 186
9.2 在Java中使用Akka提供的角色实现 199
9.3 在JRuby中使用Akka提供的Actor实现 199
9.4 在Scala中使用角色 202
9.5 小结 202
第五部分 后记
第10章 并发编程之禅 205
10.1 慎重选择 205
10.2 并发：程序员指南 206
10.3 并发：架构师指南 207
10.4 明智地进行选择 208
附录1 Clojure agent 210
附录2 一些网络资源 214
参考文献 216
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java虚拟机并发编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java开发实战经典
第1部分 Java基础程序设计.
第1章 Java概述及开发环境搭建2
视频讲解：35分钟
1.1 认识Java2
1.1.1 什么是Java2
1.1.2 Java语言的特点3
1.1.3 Java程序的运行机制和Java虚拟机5
1.2 Java开发环境搭建6
1.2.1 JDK的安装与配置7
1.2.2 编写第1个Java程序8
1.2.3 classpath属性的作用9
1.3 本章要点10
1.4 习题10
第2章 简单的Java程序11
视频讲解：20分钟
2.1 一个简单的Java范例11
2.2 Java程序的注释13
2.3 Java中的标识符13
2.4 Java中的关键字14
2.5 变量和常量14
2.6 本章要点15
2.7 习题15
第3章 Java基础程序设计16
视频讲解：2小时09分钟
3.1 数据类型划分16
3.2 基本数据类型17
3.2.1 整数类型17
3.2.2 数据的溢出18
3.2.3 字符类型19
3.2.4 浮点数类型与双精度浮点数类型21
3.2.5 布尔类型22
3.2.6 基本数据类型的默认值22
3.3 数据类型的转换23
3.3.1 数据类型的自动转换23
3.3.2 数据类型的强制转换25
3.4 运算符.表达式与语句26
3.4.1 运算符26
3.4.2 简洁表达式41
3.5 选择与循环语句43
3.5.1 程序的结构43
3.5.2 选择结构45
3.5.3 循环结构51
3.5.4 循环的中断56
3.6 本章要点58
3.7 习题59
第4章 数组与方法60
视频讲解：1小时48分钟
4.1 数组的定义及使用60
4.1.1 一维数组60
4.1.2 数组中元素的表示方法62
4.1.3 数组的静态初始化65
4.1.4 数组应用范例66
4.1.5 二维数组68
4.1.6 多维数组71
4.2 方法的声明及使用72
4.2.1 方法的定义72
4.2.2 方法的重载74
4.2.3 使用return结束一个方法76
4.2.4 方法的递归调用76
4.3 数组的引用传递77
4.3.1 传递及返回数组77
4.3.2 范例——数组排序79
4.3.3 范例——数组复制81
4.4 Java新特性对数组的支持82
4.4.1 Java新特性——可变参数82
4.4.2 Java新特性——foreach输出83
4.5 本章要点84
4.6 习题84
第2部分 Java面向对象程序设计
第5章 面向对象（基础篇）88
视频讲解：6小时34分钟
5.1 面向对象的基本概念88
5.2 类与对象90
5.2.1 类与对象的关系90
5.2.2 类的定义91
5.2.3 对象的创建及使用92
5.2.4 创建多个对象94
5.3 封装性98
5.4 构造方法102
5.5 匿名对象106
5.6 实例讲解——类设计分析107
5.7 String111
5.7.1 实例化String对象111
5.7.2 String的内容比较112
5.7.3 String两种实例化方式的区别114
5.7.4 字符串的内容不可改变116
5.7.5 String类中常用方法117
5.8 引用传递及基本应用123
5.8.1 引用传递123
5.8.2 接收本类的引用126
5.8.3 范例——一对一关系127
5.8.4 范例——进一步深入一对一关系129
5.9 this关键字131
5.9.1 使用this调用本类中的属性131
5.9.2 使用this调用构造方法134
5.9.3 this表示当前对象136
5.10 static关键字140
5.10.1 使用static声明属性140
5.10.2 使用static声明方法143
5.10.3 static的相关应用145
5.10.4 理解main方法146
5.11 代码块148
5.11.1 普通代码块148
5.11.2 构造块148
5.11.3 静态代码块149
5.12 构造方法私有化151
5.12.1 问题的引出151
5.12.2 问题的解决152
5.12.3 程序的意义153
5.13 对象数组154
5.14 内部类156
5.14.1 内部类的基本定义156
5.14.2 使用static定义内部类157
5.14.3 在外部访问内部类158
5.14.4 在方法中定义内部类159
5.15 实例讲解160
5.15.1 系统登录160
5.15.2 单向链表实现（1）163
5.15.3 单向链表实现（2）165
5.16 本章要点168
5.17 习题168
第6章 面向对象（高级篇）170
视频讲解：4小时20分钟
6.1 继承的基本概念170
6.2 继承的进一步研究176
6.2.1 子类对象的实例化过程176
6.2.2 方法的覆写178
6.2.3 super关键字的作用182
6.3 范例——继承的应用183
6.4 final关键字186
6.5 抽象类的基本概念187
6.6 接口的基本概念192
6.7 对象的多态性197
6.8 instanceof关键字202
6.9 抽象类与接口的应用204
6.9.1 为抽象类与接口实例化204
6.9.2 抽象类的实际应用——模板设计206
6.9.3 接口的实际应用——制定标准208
6.9.4 设计模式——工厂设计209
6.9.5 设计模式——代理设计213
6.9.6 设计模式——适配器设计214
6.9.7 内部类的扩展216
6.9.8 抽象类与接口之间的关系217
6.10 实例分析：宠物商店218
6.11 Object类224
6.11.1 基本作用224
6.11.2 主要方法224
6.11.3 接收任意引用类型的对象227
6.12 包装类228
6.12.1 包装类介绍228
6.12.2 装箱与拆箱229
6.12.3 包装类应用230
6.13 匿名内部类231
6.14 本章要点233
6.15 习题234
第7章 异常的捕获及处理235
视频讲解：1小时18分钟
7.1 异常的基本概念235
7.1.1 为什么需要异常处理235
7.1.2 在程序中使用异常处理236
7.1.3 异常类的继承结构241
7.1.4 Java的异常处理机制242
7.2 throws与throw关键字245
7.2.1 throws关键字245
7.2.2 throw关键字246
7.2.3 范例——throw与throws的应用247
7.3 Exception类与RuntimeException类248
7.4 自定义异常类249
7.5 断言250
7.6 本章要点251
7.7 习题251
第8章 包及访问控制权限252
视频讲解：55分钟
8.1 包的概念及使用252
8.1.1 包的基本概念252
8.1.2 import语句254
8.1.3 系统常见包257
8.1.4 Java新特性——静态导入258
8.2 jar命令的使用259
8.3 访问控制权限261
8.4 Java命名规范263
8.5 本章要点263
8.6 习题263
第3部分 Java应用程序设计
第9章 多线程266
视频讲解：2小时36分钟
9.1 进程与线程266
9.2 Java中线程的实现267
9.2.1 继承Thread类267
9.2.2 实现Runnable接口271
9.2.3 Thread类和Runnable接口273
9.3 线程的状态276
9.4 线程操作的相关方法277
9.4.1 取得和设置线程名称277
9.4.2 判断线程是否启动280
9.4.3 线程的强制运行281
9.4.4 线程的休眠282
9.4.5 中断线程282
9.4.6 后台线程283
9.4.7 线程的优先级284
9.4.8 线程的礼让286
9.5 线程操作范例287
9.5.1 实现一——继承Thread类287
9.5.2 实现二——实现Runnable接口288
9.6 同步与死锁289
9.6.1 问题的引出289
9.6.2 使用同步解决问题291
9.6.3 死锁293
9.7 线程操作案例——生产者及消费者296
9.7.1 程序的基本实现296
9.7.2 问题解决1——加入同步299
9.7.3 Object类对线程的支持——等待与唤醒301
9.7.4 问题解决2——加入等待与唤醒302
9.8 线程的生命周期303
9.9 本章要点305
9.10 习题306
第10章 泛型307
视频讲解：1小时52分钟
10.1 为什么要使用泛型307
10.2 泛型应用310
10.2.1 泛型的基本应用310
10.2.2 使用泛型修改代码313
10.2.3 泛型应用中的构造方法314
10.2.4 指定多个泛型类型315
10.3 泛型的安全警告316
10.4 通配符318
10.4.1 匹配任意类型的通配符318
10.4.2 受限泛型320
10.5 泛型与子类继承的限制323
10.6 泛型接口324
10.6.1 定义泛型接口324
10.6.2 泛型接口的两种实现方式325
10.7 泛型方法326
10.7.1 定义泛型方法327
10.7.2 通过泛型方法返回泛型类实例327
10.7.3 使用泛型统一传入的参数类型328
10.8 泛型数组329
10.9 泛型的嵌套设置330
10.1 0范例——泛型应用331
10.1 1本章要点335
10.1 2习题335
第11章 Java常用类库336
视频讲解：5小时38分钟
11.1 StringBuffer类336
11.1.1 认识StringBuffer类336
11.1.2 StringBuffer类的应用341
11.2 Runtime类342
11.2.1 认识Runtime类342
11.2.2 得到JVM的内存空间信息343
11.2.3 Runtime类与Process类344
11.3 国际化程序345
11.3.1 国际化程序的实现思路345
11.3.2 Locale类346
11.3.3 ResourceBundle类347
11.3.4 Java国际化程序实现348
11.3.5 处理动态文本349
11.3.6 使用类代替资源文件352
11.4 System类353
11.4.1 认识System类353
11.4.2 垃圾对象的回收356
11.4.3 对象的生命周期358
11.5 日期操作类358
11.5.1 Date类358
11.5.2 Calendar类359
11.5.3 DateFormat类360
11.5.4 SimpleDateFormat类362
11.5.5 实例操作——取得完整日期364
11.6 Math类367
11.7 Random类368
11.8 NumberFormat类369
11.8.1 NumberFormat类的基本使用369
11.8.2 DecimalFormat类370
11.9 BigInteger类371
11.10 BigDecimal类373
11.11 对象克隆技术374
11.12 Arrays类375
11.13 Comparable接口377
11.13.1 比较器的基本应用377
11.13.2 分析比较器的排序原理379
11.14 另一种比较器Comparator381
11.15 观察者设计模式384
11.15.1 什么叫观察者384
11.15.2 观察者模式实现384
11.16 正则表达式386
11.16.1 认识正则表达式386
11.16.2 Pattern类和Matcher类387
11.16.3 String类对正则表达式的支持..3 90
11.17 定时调度392
11.17.1 Timer类392
11.17.2 TimerTask类393
11.17.3 范例——定时操作394
11.18 本章要点395
11.19 习题395
第12章 Java IO
第13章 Java类集
第14章 枚举
第15章 Java反射机制
第16章 Annotation
第17章 Java数据库编程
第18章 图形界面
第19章 Java网络编程
第20章 Java新IO
第21章 Eclipse开发工具
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java开发实战经典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Pro JPA2中文版
第1章 简介 1
1.1 对象-关系映射 1
1.2 java持久化支持 7
1.2.1 专用解决方案 7
1.2.2 jdbc 7
1.2.3 企业javabean 8
1.2.4 java数据对象 8
1.3 为什么需要另一种标准 9
1.4 java持久化api 10
1.4.1 规范的历史 10
1.4.2 概述 11
1.5 本章小结 13
第2章 入门 14
2.1 实体概述 14
2.1.1 持久性 14
2.1.2 标识 15
2.1.3 事务性 15
2.1.4 粒度 15
2.2 实体元数据 16
.2.2.1 注解 16
2.2.2 xml 16
2.2.3 异常配置 16
2.3 创建实体 17
2.4 实体管理器 19
2.4.1 获取实体管理器 20
2.4.2 持久化实体 20
2.4.3 寻找实体 21
2.4.4 删除实体 22
2.4.5 更新实体 22
2.4.6 事务 23
2.4.7 查询 24
2.5 汇总 25
2.6 组装 27
2.6.1 持久化单元 27
2.6.2 持久化存档文件 28
2.7 本章小结 28
第3章 企业应用程序 30
3.1 应用程序组件模型 30
3.2 会话bean 31
3.2.1 无状态会话bean 32
3.2.2 有状态会话bean 35
3.2.3 单例会话bean 38
3.3 消息驱动bean 41
3.4 servlet 42
3.5 依赖性管理 43
3.5.1 依赖性查找 43
3.5.2 依赖性注入 45
3.5.3 声明依赖性 47
3.6 事务管理 49
3.6.1 事务概述 50
3.6.2 java中的企业事务 50
3.7 使用java ee组件 55
3.7.1 使用无状态会话bean 55
3.7.2 使用有状态会话bean 56
3.7.3 使用单例会话bean 57
3.7.4 使用消息驱动bean 57
3.7.5 添加实体管理器 58
3.8 汇总 59
3.8.1 定义组件 59
3.8.2 定义用户接口 61
3.8.3 组装 61
3.9 本章小结 62
第4章 对象-关系映射 64
4.1 持久化注解 64
4.2 访问实体状态 65
4.2.1 字段访问 65
4.2.2 属性访问 66
4.2.3 混合访问 66
4.3 映射到表 68
4.4 映射简单类型 69
4.4.1 列映射 70
4.4.2 延迟提取 71
4.4.3 大型对象 72
4.4.4 枚举类型 73
4.4.5 时间类型 74
4.4.6 瞬态 75
4.5 映射主键 76
4.5.1 重写主键列 76
4.5.2 主键类型 76
4.5.3 标识符生成 76
4.6 关系 81
4.6.1 关系概念 81
4.6.2 映射概述 84
4.6.3 单值关联 84
4.6.4 集合值关联 88
4.6.5 延迟关系 94
4.7 嵌入对象 94
4.8 本章小结 98
第5章 集合映射 99
5.1 关系和元素集合 99
5.2 使用不同的集合类型 102
5.2.1 set或者collection 102
5.2.2 list 103
5.2.3 map 106
5.2.4 重复 117
5.2.5 null值 118
5.3 最佳实践 119
5.4 本章小结 120
第6章 实体管理器 121
6.1 持久化上下文 121
6.2 实体管理器 122
6.2.1 容器托管的实体管理器 122
6.2.2 应用程序托管的实体管理器 126
6.3 事务管理 128
6.3.1 jta事务管理 129
6.3.2 资源本地的事务 137
6.3.3 事务回滚和实体状态 139
6.4 选择实体管理器 140
6.5 实体管理器操作 140
6.5.1 持久化实体 140
6.5.2 寻找实体 142
6.5.3 删除实体 142
6.5.4 级联操作 143
6.5.5 清除持久化上下文 146
6.6 与数据库同步 147
6.7 分离和合并 149
6.7.1 分离 149
6.7.2 合并分离的实体 151
6.7.3 与分离实体一起工作 154
6.8 本章小结 166
第7章 使用查询 167
7.1 java持久化查询语言 167
7.1.1 入门 168
7.1.2 筛选结果 169
7.1.3 投影结果 169
7.1.4 实体之间的联接 169
7.1.5 聚合查询 170
7.1.6 查询参数 170
7.2 定义查询 171
7.2.1 动态查询定义 171
7.2.2 命名查询定义 173
7.3 参数类型 175
7.4 执行查询 177
7.4.1 使用查询结果 178
7.4.2 查询分页 182
7.4.3 查询与未提交的更改 184
7.4.4 查询超时 186
7.5 批量更新和删除 187
7.5.1 使用批量更新和删除 187
7.5.2 批量删除和关系 189
7.6 查询提示 190
7.7 查询的最佳实践 191
7.7.1 命名查询 191
7.7.2 报告查询 192
7.7.3 供应商提示 192
7.7.4 无状态会话bean 192
7.7.5 批量更新和删除 193
7.7.6 提供程序的区别 193
7.8 本章小结 193
第8章 查询语言 195
8.1 简介 195
8.1.1 术语 195
8.1.2 示例数据模型 196
8.1.3 示例应用程序 197
8.2 选择查询 199
8.2.1 select子句 200
8.2.2 from 子句 203
8.2.3 where子句 210
8.2.4 标量表达式 215
8.2.5 order by子句 219
8.3 聚合查询 220
8.3.1 聚合函数 222
8.3.2 group by子句 222
8.3.3 having子句 223
8.4 更新查询 223
8.5 删除查询 224
8.6 本章小结 225
第9章 条件api 226
9.1 概述 226
9.1.1 条件api 226
9.1.2 参数化类型 227
9.1.3 动态查询 228
9.2 构建条件api查询 231
9.2.1 创建查询定义 231
9.2.2 基本结构 232
9.2.3 条件对象和可变性 233
9.2.4 查询根和路径表达式 233
9.2.5 select子句 235
9.2.6 from子句 238
9.2.7 where子句 240
9.2.8 构建表达式 240
9.2.9 order by子句 251
9.2.10 group by和having子句 251
9.3 强类型查询定义 251
9.3.1 元模型api 252
9.3.2 强类型的api概述 253
9.3.3 规范化元模型 254
9.3.4 选择正确的查询类型 256
9.4 本章小结 257
第10章 高级对象-关系映射 258
10.1 表和列名 258
10.2 复杂的嵌入对象 259
10.2.1 高级嵌入映射 260
10.2.2 重写嵌入关系 261
10.3 复合主键 262
10.3.1 id类 263
10.3.2 嵌入id类 264
10.4 派生标识符 266
10.4.1 派生标识符的基本规则 267
10.4.2 共享主键 267
10.4.3 多个映射特性 269
10.4.4 使用embeddedid 270
10.5 高级映射元素 272
10.5.1 只读映射 272
10.5.2 可选性 273
10.6 高级关系 274
10.6.1 使用联接表 274
10.6.2 避免联接表 275
10.6.3 复合联接列 276
10.6.4 孤儿删除 278
10.6.5 映射关系状态 279
10.7 多个表 281
10.8 继承 284
10.8.1 类层次结构 284
10.8.2 继承模型 288
10.8.3 混合继承 294
10.9 本章小结 296
第11章 高级主题 298
11.1 sql查询 298
11.1.1 本地查询与jdbc 299
11.1.2 定义和执行sql查询 301
11.1.3 sql结果集映射 303
11.1.4 参数绑定 309
11.2 生命周期回调 309
11.2.1 生命周期事件 309
11.2.2 回调方法 310
11.2.3 实体侦听器 312
11.2.4 继承和生命周期事件 314
11.3 验证 319
11.3.1 使用约束 319
11.3.2 调用验证 321
11.3.3 验证组 321
11.3.4 创建新的约束 323
11.3.5 jpa中的验证 325
11.3.6 启用验证 326
11.3.7 设置生命周期的验证组 326
11.4 并发性 327
11.4.1 实体操作 327
11.4.2 实体访问 328
11.5 刷新实体状态 328
11.6 锁定 331
11.6.1 乐观锁定 331
11.6.2 悲观锁定 341
11.7 缓存 344
11.7.1 通过层排序 344
11.7.2 共享缓存 346
11.8 utility类 350
11.8.1 persistenceutil 351
11.8.2 persistenceunitutil 351
11.9 本章小结 352
第12章 xml映射文件 353
12.1 元数据困惑 354
12.2 映射文件 354
12.2.1 禁用注解 355
12.2.2 持久化单元默认值 357
12.2.3 映射文件默认值 360
12.2.4 查询和生成器 362
12.2.5 托管类和映射 366
12.3 本章小结 387
第13章 包装和部署 388
13.1 配置持久化单元 388
13.1.1 持久化单元的名称 389
13.1.2 事务类型 389
13.1.3 持久化提供程序 389
13.1.4 数据源 390
13.1.5 映射文件 391
13.1.6 托管类 392
13.1.7 共享缓存模式 394
13.1.8 验证架构 395
13.1.9 添加供应商属性 395
13.2 构建和部署 396
13.2.1 部署类路径 396
13.2.2 包装选项 397
13.2.3 持久化单元的范围 401
13.3 服务器外部 402
13.3.1 配置持久化单元 402
13.3.2 在运行时指定属性 404
13.3.3 系统类路径 404
13.4 架构生成 405
13.4.1 唯一约束 405
13.4.2 null约束 406
13.4.3 基于字符串的列 406
13.4.4 浮点列 407
13.4.5 定义列 407
13.5 本章小结 408
第14章 测试 410
14.1 测试企业应用程序 410
14.1.1 术语 411
14.1.2 在服务器外部测试 412
14.1.3 测试架构 413
14.2 单元测试 413
14.2.1 测试实体 414
14.2.2 测试组件中的实体 415
14.2.3 单元测试中的实体管理器 417
14.3 集成测试 420
14.3.1 使用实体管理器 420
14.3.2 组件和持久化 426
14.4 最佳实践 436
14.5 本章小结 436
第15章 迁移 438
15.1 从cmp实体bean迁移 438
15.1.1 划定挑战的范围 439
15.1.2 实体bean转换 440
15.2 从jdbc迁移 448
15.3 从其他的orm解决方案迁移 449
15.4 利用设计模式 449
15.4.1 传输对象 450
15.4.2 会话外观 453
15.4.3 数据访问对象 455
15.4.4 业务对象 459
15.4.5 快车道读者 459
15.4.6 活动记录 460
15.5 本章小结 460
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Pro JPA2中文版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java特种兵（上册）
第1篇  Java功底篇
第1章  扎马：看看功底如何	2
1.1  String的例子，见证下我们的功底	2
1.1.1  关于“==”	3
1.1.2  关于“equals()”	3
1.1.3  编译时优化方案	6
1.1.4  补充一个例子	6
1.1.5  跟String较上劲了	8
1.1.6  intern()/equals()	9
1.1.7  StringBuilder.append()与String“+”的PK	11
1.2  一些简单算法，你会如何理解	15
1.2.1  从一堆数据中找max和min	16
1.2.2  从100万个数字中找最大的10个数字	17
1.2.3  关于排序，实际场景很重要	17
1.2.4  数据库是怎么找数据的	18
1.2.5  Hash算法的形象概念	18
1.3  简单数字游戏玩一玩	20
1.3.1  变量A、B交换有几种方式	20
1.3.2  将无序数据Hash到指定的板块	20
1.3.3  大量判定“是|否”的操作	21
1.3.4  简单的数据转换	22
1.3.5  数字太大，long都存放不下	23
1.4  功底概述	25
1.4.1  什么是功底	25
1.4.2  功底有何用途	25
1.4.3  如何磨练功底	26
1.5  功底补充	27
1.5.1  原生态类型	27
1.5.2  集合类	30
1.6  常见的目录与工具包	32
1.7  面对技术，我们纠结的那些事儿	34
1.7.1  为什么我这里好用，哪里不好用	34
1.7.2  你的程序不好用，你会不会用，环境有问题	35
1.7.3  经验是否能当饭吃	36
1.8  老A是在逆境中迎难而上者	37
第2章  Java程序员要知道计算机工作原理	41
2.1  Java程序员需要知道计算机工作原理吗	41
2.2  CPU的那些事儿	42
2.2.1  从CPU联系到Java	42
2.2.2  多核	46
2.2.3  Cache line	47
2.2.4  缓存一致性协议	49
2.2.5  上下文切换	50
2.2.6  并发与征用	51
2.3  内存	54
2.4  磁盘	57
2.5  缓存	60
2.5.1  缓存的相对性	60
2.5.2  缓存的用途和场景	62
2.6  关于网络与数据库	63
2.6.1  Java基本I/O	63
2.6.2  Java的网络基本原则	64
2.6.3  Java与数据库的交互	71
2.7  总结	72
第3章  JVM，Java程序员的OS	73
3.1  学习Java虚拟机对我们有什么好处	73
3.2  跨平台与字节码基本原理	74
3.2.1  javap命令工具	74
3.2.2  Java字节码结构	85
3.2.3  Class字节码的加载	93
3.2.4  字节码增强	98
3.3  从虚拟机的板块开始	108
3.3.1  Hotspot VM板块划分	108
3.3.2  “对象存放位置”小总结	114
3.3.3  关于永久代	115
3.4  常见的虚拟机回收算法	116
3.4.1  串行GC	117
3.4.2  ParallelGC与ParallelOldGC	118
3.4.3  CMS GC与未来的G1	121
3.4.4  简单总结	124
3.4.5  小小补充	125
3.5  浅析Java对象的内存结构	126
3.5.1  原始类型与对象的自动拆装箱	126
3.5.2  对象内存结构	127
3.5.3  对象嵌套	130
3.5.4  常见类型 & 集合类的内存结构	131
3.5.5  程序中内存拷贝和垃圾	134
3.5.6  如何计算对象大小	134
3.5.7  轻松玩一玩int[2][100] PK int[100][2]	135
3.6  常见的OOM现象	136
3.6.1  HeapSize OOM	136
3.6.2  PermGen OOM	139
3.6.3  DirectBuffer OOM	142
3.6.4  StackOverflowError	144
3.6.5  其他的一些内存溢出现象	146
3.7  常见的Java工具	146
3.7.1  jps	147
3.7.2  jstat	147
3.7.3  jmap	148
3.7.4  jstack	148
3.7.5  jinfo	149
3.7.6  JConsole	150
3.7.7  Visual VM	154
3.7.8  MAT（Memory Analyzer Tool）	156
3.7.9  BTrace	160
3.7.10  HSDB	165
3.7.11  工具总结	166
3.8  总结	167
3.8.1  写代码	167
3.8.2  心理上战胜虚拟机带来的恐惧	170
第4章  Java通信，交互就需要通信	171
4.1  通信概述	171
4.1.1  Java通信的基本过程	171
4.1.2  Java通信的协议包装	173
4.1.3  编写自定义通信协议	173
4.1.4  Java的I/O流是不是很难学	186
4.2  Java I/O与内存的那些事	191
4.2.1  常规I/O操作的运作过程	191
4.2.2  DirectBuffer的使用	191
4.2.3  关于Buffer	195
4.2.4  FileChannel的加锁	197
4.3  通信调度方式	197
4.3.1  同步与异步	197
4.3.2  阻塞与非阻塞	198
4.3.3  Linux OS调度IO模型	199
4.3.4  Java中的BIO、NIO	199
4.3.5  Java AIO	210
4.4  Tomcat中对I/O的请求处理	214
4.4.1  Tomcat的配置&一个请求的响应	214
4.4.2  Request、Response对象生成	221
4.4.3 拉与推	226
第5章  Java并发，你会遇到吗	228
5.1  基础介绍	228
5.1.1  线程基础	228
5.1.2  多线程	231
5.1.3  线程状态	231
5.1.4  反面教材suspend()、
resume()、stop()	236
5.1.5  调度优先级	238
5.1.6  线程合并（Join）	239
5.1.7  线程补充小知识	241
5.2  线程安全	243
5.2.1  并发内存模型概述	243
5.2.2  一些并发问题描述	246
5.2.3  volatile	248
5.2.4  final	251
5.2.5  栈封闭	254
5.2.6  ThreadLocal	255
5.3  原子性与锁	261
5.3.1  synchronized	261
5.3.2  什么是乐观锁	262
5.3.3  并发与锁	263
5.3.4  Atomic	264
5.3.5  Lock	272
5.3.6  并发编程核心AQS原理	273
5.3.7  锁的自身优化方法	281
5.4  JDK 1.6并发编程的一些集合类	282
5.5  常见的并发编程工具	284
5.5.1  CountDownLatch	284
5.5.2  CyclicBarrier	286
5.5.3  Semaphor	288
5.5.4  其他工具简介	290
5.6  线程池&调度池	293
5.6.1  阻塞队列模型	293
5.6.2  ThreadPoolExecutor	294
5.6.3  调度器ScheduleThread PoolExecutor	306
5.7  总结：编写并发程序要注意些什么	317
5.7.1  锁粒度	317
5.7.2  死锁	321
5.7.3 “坑”很多	323
5.7.4  并发效率一定高吗	329
5.8  其他的并发编程知识	330
5.8.1  ShutdownHook（钩子线程）	330
5.8.2  Future	332
5.8.3  异步并不等价于多线程	333
第6章  好的程序员应当知道数据库基本原理	335
6.1  开发人员为什么要知道数据库原理	335
6.2  从开发人员角度看数据库原理	337
6.2.1  实例与存储	338
6.2.2  数据库基本原理	339
6.2.3  索引基本原理	348
6.2.4  数据库主从基本原理	354
6.2.5  我们经常相信的那些经验	354
6.3  从程序员角度看数据库优化方法	355
6.3.1  不同领域的SQL区别	355
6.3.2  执行计划	356
6.3.3  SQL逻辑的例子	365
6.3.4  模型结构设计的优化	366
6.3.5  临时表	367
6.3.6  分页知识补充	368
6.3.7  计算count值	369
6.3.8  分布式事务探讨	369
6.3.9  其他	371
6.4  学会最基本的性能诊断	372
6.4.1  进入云数据库时代	372
6.4.2  从程序员角度关注的数据库诊断信息	373
6.5  数风流存储，还看今朝	373
第2篇  源码篇
第7章  源码基础	380
7.1  为何会出现框架	380
7.2  阅读框架前的技术储备	384
7.2.1  反射基础知识	384
7.2.2  AOP基础	390
7.2.3  ORM基础	395
7.2.4  Annotation与配置文件	398
第8章  部分JDBC源码讲解	403
8.1  JDBC通用接口规范	403
8.2  JDBC Driver注册	404
8.3  创建Connection	411
8.4  SQL执行及处理	417
8.4.1  创建Statement	417
8.4.2  Batch设置批处理	419
8.4.3  fetchSize与maxRows	424
8.4.4  setQueryTimeout()与cancel()	429
第9章  部分Spring源码讲解	433
9.1  Spring MVC	433
9.1.1  Spring加载	433
9.1.2  Spring MVC处理一个简单请求	443
9.2  Spring事务管理器	447
9.2.1  JDBC事务的基本思想	447
9.2.2  Spring事务管理器的基本架构	448
9.2.3  Spring如何保存Connection	449
9.2.4  Spring如何保证程序中多次获取到的连接是同一个	451
9.3  思考：自己做框架有眉目了吗	454
第10章  看源码的一些总结	457
10.1  高手看API的能力	457
10.2  通过源码能否量化性能与稳定性	461
10.3  思考相似方案和技术的优缺点	463
10.4  明确场景和业务，不做技术控	464
10.4.1  谈谈技术控的那些事	464
10.4.2  明确业务背景的例子	466
10.5  胖哥对框架的浅析	468
10.5.1  框架由来的一个补充	468
10.5.2  开源框架与扩展	469
10.5.3  框架与解决问题	473
10.6  学海无涯，心境无限	474
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java特种兵（上册）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java与XML
前言第1章　介绍　XML 1.0  XML 1.1　XML文档转换　更多内容第2章　约束　DTDs　XML Schema　RELAX NG第3章　SAX　安装SAX　使用SAX解析文档　内容处理类　错误处理类第4章　SAX高级技术　属性和特征　解析实体　符号与非解析实体　DefaultHandler类　扩展接口　Filters与Writers第5章　DOM　文档对象模型（Document Object Model）　序列化　修改和创建XML　名称空间第6章　DOM模块　检验支持的模块　DOM Level 2模块　DOM Level 3模块第7章　JAXP　不仅仅是APl　解析XML　处理XSL　XPath　XML验证第8章　使用StAX进行拉式解析　StAX基础　StAX工厂　使用StAX解析　使用StAX输出文档　工厂属性　StAX的基本问题　XmlPull第9章　JDOM　基础知识  PropsTbXML  XMLProperties  更多的JDOM类  JDOM和工厂类  JDOM的常见问题第10章  dom4j  概述  使用dom4j读和写文档  遍历文档  TransfOrmations  专用工厂第11章  使用JAXB实现数据绑定  数据绑定基础  介绍JAxB  使用JAxB  其他的绑定框架第12章  使用RSS的内容聚合  RSS是什么？  创建一个RSS文档  读取RSs订阅源  ROME模块第13章  XML呈现  XML和模型一视图一控制器模式  使用JSP转换HTML  XSLT的使用  Ajax  Flash第14章  展望  XML应用机  XQuery  快速信息集  更多内容附录  SAX特征和属性
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java与XML
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web整合开发王者归来
第1篇  入门篇第2章  搭建Java Web开发环境  第2篇  基础篇第3章  深入Servlet技术第4章  深入JSP技术第5章  会话跟踪	第6章  过滤器Filter第7章  监听器Listener  第3篇  高级篇第8章  JSTL标签库第9章  自定义标签第10章  资源国际化第11章  数据库概述第12章  JDBC详解第13章  XML概述  第4篇  Struts框架篇第14章  Struts 1.x概述第15章  Struts 1.x高级应用第16章  Struts 2.x概述第17章  Struts 2.x高级应用第18章  Struts 2.x标签第19章  Struts 2.x拦截器与文件上传  第5篇  Hibernate框架篇第20章  Hibernate入门第21章  从宏观上把握Hibernate第23章  Hibernate实体关系映射第24章  Hibernate查询语言HQL第25章  Hibernate高级查询  第6篇  Spring框架篇第26章  Spring概述第27章  Spring的Core模块第28章  Spring的AOP模块第29章  Spring的DAO模块第30章  Spring的ORM模块第31章  Spring的Web模块第32章  Spring的MVC模块第33章  Spring开发实例（SSH、SSJ）  第7篇  EJB与Web服务篇第34章  EJB 3概述第35章  JPA规范第36章  Web Service框架XFire  第8篇  工具篇第37章  版本管理工具SVN第38章  日志工具commons- logging与Log4J第39章  报表图形引擎JFreeChart第40章  PDF组件iText  第9篇  实战篇第41章  论坛系统（Spring+Struts+ Hibernate）第42章  分布式宠物商店（EJB 3+JPA+ Struts 2）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web整合开发王者归来
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>疯狂Java讲义
第1章 Java语言概述  1.1 Java语言的发展简史  1.2 Java的竞争对手及各自优势    1.2.1 C#简介和优势    1.2.2 Ruby简介和优势    1.2.3 Python简介和优势  1.3 Java程序运行机制    1.3.1 高级语言的运行机制    1.3.2 Java程序的运行机制和JVM  1.4 开发Java的准备    1.4.1 下载和安装Java 7的JDK    学生提问 不是说JVM是运行Java程序的虚拟机吗？那JRE和JVM的关系是怎样的呢？    学生提问 为什么不安装公共JRE呢？    1.4.2 设置PATH环境变量    学生提问 为什么选择用户变量？用户变量与系统变量有什么区别？  1.5 第一个Java程序    1.5.1 编辑Java源代码    1.5.2 编译Java程序    学生提问 当我们编译C程序时，不仅需要指定存放目标文件的位置,也需要指定目标文件的文件名,这里使用javac编译Java程序时怎么不需要指定目标文件的文件名呢？    1.5.3 运行Java程序    1.5.4 根据CLASSPATH环境变量定位类  1.6 Java程序的基本规则    1.6.1 Java程序的组织形式    1.6.2 Java源文件的命名规则    1.6.3 初学者容易犯的错误  1.7 垃圾回收机制  1.8 何时开始使用IDE工具    学生提问 我想学习Java编程，到底是学习Eclipse好呢,还是学习NetBeans好呢？  1.9 本章小结  本章练习第2章  理解面向对象第3章  数据类型和运算符第4章  流程控制与数组第5章  面向对象（上）第6章  面向对象（下）第7章  与运行环境交互第8章  Java集合第9章  泛型第10章  异常处理第11章  AWT编程第12章  Swing编程第13章  MySQL数据库与JDBC编程第14章  Annotation（注释）第15章  输入/输出第16章  多线程第17章  网络编程第18章  类加载机制与反射
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>疯狂Java讲义
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言程序设计
第21章    泛型	1
21.1   引言	1
21.2   动机和优点	1
21.3   定义泛型类和接口	3
21.4   泛型方法	4
21.5   原始类型和向后兼容	5
21.6   通配泛型	6
21.7   消除泛型和对泛型的限制	8
21.8   实例学习：泛型矩阵类	10
关键术语	14
本章小结	14
复习题	15
编程练习题	16
第22章   Java集合框架	17
22.1   引言	17
22.2   集合	17
22.3   Collection接口和Abstract-Collection类	18
22.4   规则集	19
22.4.1   散列集HashSet	19
22.4.2   链式散列集LinkedHashSet	23
22.4.3   树形集TreeSet	23
22.5   比较器接口Comparator	25
22.6   线性表	26
22.7   线性表和集合的静态方法	30
22.8   规则集和线性表的性能	32
22.9   向量类Vector和栈类Stack	33
22.10   队列和优先队列	35
22.11   图	37
22.12   单元素和不可变的集合和图	42
关键术语	42
本章小结	42
复习题	43
编程练习题	46
第23章   算法效率	49
23.1   引言	49
23.2   大O符号	49
23.3   举例：确定大O	50
23.4   分析算法的时间复杂度	52
23.4.1   分析二分查找算法	52
23.4.2   分析选择排序算法	52
23.4.3   分析插入排序算法	53
23.4.4   分析汉诺塔问题	53
23.4.5   比较常用的增长函数	53
23.5   实例学习：找出斐波那契数	54
23.6   实例学习：求最大公约数	56
23.7   实例学习：找出素数	59
23.8   实例学习：最近的点对	64
23.9   预览其他算法	66
关键术语	66
本章小结	66
复习题	67
编程练习题 	68
第24章   排序	71
24.1   引言	71
24.2   冒泡排序	71
24.3   归并排序	73
24.4   快速排序	76
24.5   堆排序	79
24.5.1   对堆排序	79
24.5.2   添加一个新结点	80
24.5.3   删除根结点	80
24.5.4   Heap类	81
24.5.5   使用Heap类排序	83
24.5.6   堆排序的时间复杂度	84
24.6   桶排序和基数排序	84
24.7   外部排序	85
24.7.1   实现第Ⅰ步	86
24.7.2   实现第Ⅱ步	87
24.7.3   合并两步	89
24.7.4   外部排序分析	91
关键术语	92
本章小结	92
复习题	92
编程练习题 	93
第25章   线性表、栈、队列和优先队列	95
25.1   引言	95
25.2   线性表的一般特性	95
25.3   数组线性表	98
25.4   链表	102
25.4.1   结点	103
25.4.2   LinkedList类	104
25.4.3   实现MyLinkedList	105
25.4.4   MyArrayList和MyLinkedList	112
25.5   链表的变体	112
25.6   栈和队列	113
25.7   优先队列	116
25.8   实例学习：计算表达式	117
本章小结	121
复习题	121
编程练习题   	122
第26章   二叉查找树	125
26.1   引言	125
26.2   二叉查找树	125
26.2.1   表示二叉查找树	126
26.2.2   查找一个元素	127
26.2.3   在BST中插入一个元素	127
26.2.4   树的遍历	128
26.2.5   BinaryTree类	129
26.3   删除BST中的一个元素   	137
26.4   Tree的可视化	141
26.5   迭代器	144
26.6   实例学习：数据压缩	146
关键术语	150
本章小结	150
复习题	150
编程练习题	150
第27章   图及其应用	154
27.1   引言	154
27.2   基本的图术语	155
27.3   图的表示	156
27.3.1   顶点的表示	156
27.3.2   边的表示：边的数组	157
27.3.3   边的表示：Edge对象	157
27.3.4   边的表示：邻接矩阵	157
27.3.5   边的表示：邻接线性表	158
27.4   图建模	159
27.5   图的可视化	168
27.6   图的遍历	171
27.7   深度优先搜索	171
27.7.1   深度优先搜索算法	171
27.7.2   深度优先搜索的实现	172
27.7.3   深度优先搜索的应用	174
27.8   广度优先搜索	174
27.8.1   广度优先搜索算法	174
27.8.2   广度优先搜索的实现	175
27.8.3   广度优先搜索的应用	177
27.9   实例学习：九个硬币反面的问题	177
27.10   实例学习：骑士旅行问题	181
关键术语	187
本章小结	187
复习题	188
编程练习题 	188
第28章   加权图及其应用	193
28.1   引言	193
28.2   加权图的表示	193
28.2.1   加权边的表示：边数组	193
28.2.2   加权邻接矩阵	194
28.2.3   优先邻接链表	194
28.3   WeightedGraph类	195
28.4   最小生成树	201
28.4.1   最小生成树算法	201
28.4.2   MST算法的实现	203
28.5   寻找最短路径	206
28.5.1   最短路径算法	206
28.5.2   最短路径算法的实现	209
28.6   实例学习：加权的九枚硬币反面问题	212
关键术语	215
本章小结	215
复习题	215
编程练习题 	216
第29章   多线程	220
29.1   引言	220
29.2   线程的概念	220
29.3   创建任务和线程	221
29.4   Thread类	223
29.5   举例：闪烁文本	225
29.6   GUI事件分发线程	226
29.7   实例学习：带音频的时钟	227
29.8   线程池	230
29.9   线程同步	232
29.9.1   synchronized关键字	234
29.9.2   同步语句	234
29.10   利用加锁同步	235
29.11   线程间协作	236
29.12   实例学习：生产者/消费者	240
29.13   阻塞队列	242
29.14   信号量	244
29.15   避免死锁	245
29.16   线程的状态	245
29.17   同步集合	246
29.18   SwingWorker	247
29.19   使用JProgressBar显示进度	250
关键术语	253
本章小结	253
复习题	253
编程练习题	255
第30章   网络	258
30.1   引言	258
30.2   客户端/服务器计算	258
30.2.1   服务器套接字	259
30.2.2   客户端套接字	259
30.2.3   通过套接字进行数据传输	260
30.2.4   客户端/服务器举例	260
30.3   InetAddress类	264
30.4   服务多个客户	265
30.5   applet客户端	268
30.6   发送和接收对象	270
30.7   从Web服务器上读取文件	274
30.8   JEditorPane类	276
30.9   实例学习：分布式井字游戏	278
本章小结	288
复习题	289
编程练习题	289
第31章    国际化	292
31.1   引言	292
31.2   Locale类	292
31.3   显示日期和时间	294
31.3.1   TimeZone类	294
31.3.2   DateFormat类	294
31.3.3   SimpleDateFormat类	295
31.3.4   DateFormatSymbols类	295
31.3.5   举例：显示国际时钟	296
31.3.6   举例：显示日历	299
31.4   格式化数字	304
31.4.1   普通数字格式	304
31.4.2   货币格式	305
31.4.3   百分比格式	305
31.4.4   转换数字	306
31.4.5   DecimalFormat类	306
31.4.6   举例：格式化数字	306
31.5   资源包	309
31.6   字符编码	315
关键术语	316
本章小结	316
复习题	317
编程练习题	317
第32章   JavaBeans和bean事件 	320
32.1   引言	320
32.2   JavaBeans	320
32.3   bean属性	321
32.3.1   属性的命名方式	321
32.3.2   属性和数据域	321
32.4   Java事件模型回顾 	322
32.4.1   事件类和事件监听器接口	322
32.4.2   源组件	323
32.4.3   监听器组件	323
32.5   创建自定义源组件	324
32.6   创建自定义事件组	328
关键术语	332
本章小结	332
复习题	332
编程练习题	333
第33章   容器、布局管理器和边框	336
33.1   引言	336
33.2   Swing容器的结构	336
33.2.1   JFrame	337
33.2.2   JApplet	337
33.2.3   JPanel	338
33.3   布局管理器	338
33.3.1   CardLayout	339
33.3.2   BoxLayout	341
33.3.3   使用null布局管理器	344
33.4   创建自定义布局管理器	345
33.5   JScrollPane	350
33.6   JTabbedPane	353
33.7   JSplitPane	355
33.8   Swing边框	357
本章小结	364
复习题	364
编程练习题	365
第34章   菜单、工具栏和对话框	368
34.1   引言	368
34.2   菜单	368
34.2.1   创建菜单	368
34.2.2   图标、热键和快捷键	370
34.2.3   举例：使用菜单	371
34.3   弹出式菜单	373
34.4   JToolBar	375
34.5   使用Action接口处理动作事件	377
34.6   JOptionPane对话框	380
34.6.1   消息对话框	381
34.6.2   确认对话框	382
34.6.3   输入对话框	382
34.6.4   选项对话框	383
34.6.5   举例：创建JOptionPane
对话框	384
34.7   创建自定义对话框	386
34.8   JColorChooser	389
34.9   JFileChooser	390
本章小结	394
复习题	395
编程练习题	395
第35章   MVC和Swing模型	398
35.1   引言	398
35.2   MVC	398
35.3   MVC的变体	404
35.4   Swing的模型-视图-控件体系结构	404
35.5   JSpinner	406
35.6   微调文本域模型和编辑器	407
35.6.1   SpinnerListModel	408
35.6.2   SpinnerNumberModel	408
35.6.3   SpinnerDateModel	409
35.6.4   微调文本域编辑器	410
35.6.5   举例：使用微调文本域模型和编辑器	410
35.7   JList及其模型	412
35.7.1   JList的构造方法、属性和方法	413
35.7.2   列表框布局方向	413
35.7.3   列表框选择模式和列表框选择模型	414
35.7.4   举例：列表框属性演示	414
35.8   列表模型	416
35.9   列表框单元格绘制器	419
35.10   JComboBox及其模型	422
关键术语	425
本章小结	425
复习题	426
编程练习题	426
第36章   JTable和JTree	430
36.1   引言	430
36.2   JTable	430
36.3   表格模型和表格列模型	435
36.4   自动排序和过滤	438
36.5   实例学习：修改表格的行和列	440
36.6   表格绘制器和编辑器	445
36.7   自定义表格绘制器和编辑器	447
36.8   表格模型事件	449
36.9   JTree	452
36.10   TreeModel和DefaultTreeModel	455
36.11   TreeNode、MutableTreeNode和DefaultMutableTreeNode	457
36.12   TreePath和TreeSelection-Model	460
36.13   实例学习：修改树	462
36.14   树结点的绘制和编辑	465
36.15   树事件	467
本章小结	467
复习题	467
编程练习题 	468
第37章   Java数据库程序设计	471
37.1   引言	471
37.2   关系数据库系统	471
37.2.1   关系结构	472
37.2.2   完整性约束	473
37.3   SQL	474
37.3.1   在MySQL上创建用户账户	475
37.3.2   创建数据库	476
37.3.3   创建和删除表	476
37.3.4   简单插入、更新和删除	477
37.3.5   简单查询	478
37.3.6   比较运算符和布尔运算符	479
37.3.7   运算符like、between-and和
is null	479
37.3.8   列的别名	480
37.3.9   算术运算符	480
37.3.10   显示互不相同的元组	480
37.3.11   显示有序元组	481
37.3.12   联结表	481
37.4    JDBC	482
37.4.1   使用JDBC开发数据库应用程序	483
37.4.2   通过Java applet访问数据库	486
37.5   PreparedStatement	488
37.6   CallableStatement	491
37.7   获取元数据	493
37.7.1   数据库元数据	493
37.7.2   获取数据库表	494
37.7.3   结果集元数据	495
关键术语	496
本章小结	496
复习题	497
编程练习题	498
附录A   Java关键字	500
附录B   ASCII码字符集	501
附录C   运算符优先级表	502
附录D   Java修饰符	503
附录E   特殊浮点值	504
附录F   数系	505
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分形算法与程序设计
第1章 分形简介
第2章 分形图的递归算法
第3章 文法构图算法
第4章 迭代函数系统算法
第5章 逃逸时间算法
第6章 分形显微镜
第7章 分形演化算法
第8章 分形动画
第9章 三维空间中的分形
第10章 分形自然景物模拟算法
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分形算法与程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java JDK 7学习笔记
Chapter1  Java平台概论	1
1.1　Java不只是语言	2
1.1.1　前世今生	2
1.1.2　三大平台	5
1.1.3　JCP与JSR	6
1.1.4　建议的学习路径	7
1.2　JVM/JRE/JDK	11
1.2.1　什么是JVM	11
1.2.2　区分JRE与JDK	14
1.2.3　下载、安装JDK	15
1.2.4　认识JDK安装内容	18
1.3　重点复习	19
1.4　课后练习	20
Chapter2  从JDK到IDE	21
2.1　从Hello World开始	22
2.1.1　撰写Java原始码	22
2.1.2　PATH是什么	24
2.1.3　JVM(java)与CLASSPATH	27
2.1.4　编译程序(javac)与
CLASSPATH	30
2.2　管理原始码与位码文档	31
2.2.1　编译程序(javac)与SOURCEPATH	31
2.2.2　使用package管理类	33
2.2.3　使用import偷懒	36
2.3　使用IDE	38
2.3.1　IDE项目管理基础	38
2.3.2　使用了哪个JRE	43
2.3.3　类文档版本	45
2.4　重点复习	48
2.5　课后练习	49
Chapter3  基础语法	53
3.1　类型、变量与运算符	54
3.1.1　类型	54
3.1.2　变量	57
3.1.3　运算符	60
3.1.4　类型转换	66
3.2　流程控制	69
3.2.1　if...else条件式	69
3.2.2　switch条件式	72
3.2.3　for循环	74
3.2.4　while循环	75
3.2.5　break、continue	77
3.3　重点复习	78
3.4　课后练习	79
Chapter4  认识对象	83
4.1　类与对象	84
4.1.1　定义类	84
4.1.2　使用标准类	87
4.1.3　对象指定与相等性	90
4.2　基本类型打包器	91
4.2.1　打包基本类型	91
4.2.2　自动装箱、拆箱	92
4.2.3　装箱的内幕	93
4.3　数组对象	96
4.3.1　数组基础	96
4.3.2　操作数组对象	99
4.3.3　数组复制	105
4.4　字符串对象	108
4.4.1　字符串基础	108
4.4.2　字符串特性	111
4.4.3　字符串编码	115
4.5　查询Java API文件	117
4.6　重点复习	119
4.7　课后练习	120
Chapter5  对象封装	125
5.1　何谓封装	126
5.1.1　封装对象初始流程	126
5.1.2　封装对象操作流程	128
5.1.3　封装对象内部数据	131
5.2　类语法细节	134
5.2.1　public权限修饰	134
5.2.2　关于构造函数	136
5.2.3　构造函数与方法重载	137
5.2.4　使用this	139
5.2.5　static类成员	142
5.2.6　不定长度自变量	148
5.2.7　内部类	150
5.2.8　传值调用	151
5.3　重点复习	154
5.4　课后练习	155
Chapter6  继承与多态	161
6.1　何谓继承	162
6.1.1　继承共同行为	162
6.1.2　多态与is-a	166
6.1.3　重新定义行为	170
6.1.4　抽象方法、抽象类	173
6.2　继承语法细节	174
6.2.1　protected成员	174
6.2.2　重新定义的细节	176
6.2.3　再看构造函数	178
6.2.4　再看final关键字	180
6.2.5　java.lang.Object	181
6.2.6　关于垃圾收集	186
6.2.7　再看抽象类	189
6.3　重点复习	191
6.4　课后练习	192
Chapter7  接口与多态	199
7.1　何谓接口	200
7.1.1　接口定义行为	200
7.1.2　行为的多态	204
7.1.3　解决需求变化	206
7.2　接口语法细节	213
7.2.1　接口的默认	213
7.2.2　匿名内部类	217
7.2.3　使用enum枚举常数	221
7.3　重点复习	224
7.4　课后练习	224
Chapter8  异常处理	231
8.1　语法与继承架构	232
8.1.1　使用try、catch	232
8.1.2　异常继承架构	235
8.1.3　要抓还是要抛	238
8.1.4　认识堆栈追踪	241
8.1.5　关于assert	245
8.2　异常与资源管理	247
8.2.1　使用finally	247
8.2.2　自动尝试关闭资源	249
8.2.3　java.lang.AutoCloseable
接口	251
8.3　重点复习	255
8.4　课后练习	256
Chapter8  Collection与Map	261
9.1　使用Collection收集对象	262
9.1.1　认识Collection架构	262
9.1.2　具有索引的List	263
9.1.3　内容不重复的Set	266
9.1.4　支持队列操作的Queue	270
9.1.5　访问对象的Iterator	273
9.1.6　排序收集的对象	276
9.1.7　使用泛型	280
9.2　键值对应的Map	284
9.2.1　常用Map操作类	284
9.2.2　访问Map键值	288
9.3　重点复习	291
9.4　课后练习	292
Chapter10  输入输出	299
10.1　InputStream与
OutputStream	300
10.1.1　串流设计的概念	300
10.1.2　串流继承架构	303
10.1.3　串流处理装饰器	306
10.2　字符处理类	311
10.2.1　Reader与Writer继承
架构	311
10.2.2　字符处理装饰器	313
10.3　重点复习	315
10.4　课后练习	316
10.4.1　选择题	316
10.4.2　操作题	317
Chapter11  线程与并行API	319
11.1　线程	320
11.1.1　线程简介	320
11.1.2　Thread与Runnable	323
11.1.3　线程生命周期	324
11.1.4　关于ThreadGroup	331
11.1.5　synchronized与volatile	334
11.1.6　等待与通知	345
11.2　并行API	349
11.2.1　Lock、ReadWriteLock与
Condition	349
11.2.2　使用Executor	357
11.2.3　并行Collection简介	370
11.3　重点复习	373
11.4　课后练习	375
Chapter12  通用API	377
12.1　日志	378
12.1.1　日志API简介	378
12.1.2　指定日志层级	380
12.1.3　使用Handler与Formatter	382
12.1.4　自定义Handler、Formatter与
Filter	383
12.1.5　使用logging.properties	385
12.2　国际化基础、日期	387
12.2.1　关于i18n	387
12.2.2　使用Date与DateFormat	390
12.2.3　使用Calendar	393
12.3　规则表示式	395
12.3.1　定义规则表示式	396
12.3.2　Pattern与Matcher	403
12.4　NIO2文件系统	405
12.4.1　API架构概述	405
12.4.2　操作路径	406
12.4.3　属性读取与设定	409
12.4.4　操作文档与目录	412
12.4.5　读取、访问目录	414
12.4.6　过滤、搜索文档	418
12.5　重点复习	421
12.6　课后练习	422
Chapter12  窗口程序设计	425
13.1　Swing入门	426
13.1.1　简易需求分析	426
13.1.2　Swing组件简介	427
13.1.3　设计主窗口与菜单列	429
13.1.4　关于版面管理	433
13.1.5　事件处理	436
13.2　文档打开、存储与编辑	442
13.2.1　操作打开文档	442
13.2.2　制作存储、关闭文档	445
13.2.3　文字区编辑、剪切、复制、
粘贴	448
13.3　重点复习	449
13.4　课后练习	451
Chapter14  整合数据库	444
14.1  JDBC入门	454
14.1.1　JDBC简介	454
14.1.2　连接数据库	458
14.1.3　使用Statement、
ResultSet	464
14.1.4　使用PreparedStatement、
CallableStatement	469
14.2　JDBC进阶	472
14.2.1　使用DataSource取得
联机	472
14.2.2　使用ResultSet卷动、
更新数据	476
14.2.3　批次更新	479
14.2.4　Blob与Clob	480
14.2.5　交易简介	481
14.2.6　metadata简介	489
14.2.7　RowSet简介	492
14.3　重点复习	496
14.4　课后练习	497
Chapter15  反射与类加载器	499
15.1　运用反射	500
15.1.1　Class与.class文档	500
15.1.2　使用Class.forName()	502
15.1.3　从Class获得信息	503
15.1.4　从Class建立对象	506
15.1.5　操作对象方法与成员	509
15.1.6　动态代理	512
15.2　了解类加载器	515
15.2.1　类加载器层级架构	515
15.2.2　建立ClassLoader实例	518
15.3　重点复习	520
15.4　课后练习	521
Chapter16  自定义泛型、枚举与标注	523
16.1　自定义泛型	524
16.1.1　定义泛型方法	524
16.1.2　使用extends与?	525
16.1.3　使用super与?	530
16.2　自定义枚举	533
16.2.1　了解java.lang.Enum类	533
16.3　关于注释	542
16.3.1　常用标准注释	542
16.3.2　自定义注释类型	545
16.3.3　执行时期读取注释信息	549
16.4　重点复习	551
16.5　课后练习	551
AppendixA　如何使用本书项目	553
A.1　项目环境配置	554
A.2　打开案例	554
AppendixB　MySQL入门	557
B.1　安装、设定MySQL	558
B.2　MySQL的数据类型	560
B.3　建立数据库、数据表	561
B.4　进行CRUD操作	562
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java JDK 7学习笔记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java设计模式
序	xv
第1章  绪论	1
为何需要模式	1
为何需要设计模式	2
为何选择Java	3
UML	3
挑战	4
本书的组织	4
欢迎来到Oozinoz公司	6
小结	6
第1部分  接口型模式
第2章  接口型模式介绍	8
接口与抽象类	8
接口与职责	10
小结	11
超越普通接口	12
第3章  适配器（Adapter）模式	13
接口适配	13
类与对象适配器	17
JTable对数据的适配	20
识别适配器	24
小结	25
第4章  外观（Facade）模式	27
外观类、工具类和示例类	27
重构到外观模式	29
小结	38
第5章  合成（Composite）模式	39
常规组合	39
合成模式中的递归行为	40
组合、树与环	42
含有环的合成模式	47
环的影响	50
小结	51
第6章  桥接（Bridge）模式	52
常规抽象：桥接模式的一种方法	52
从抽象到桥接模式	54
使用桥接模式的驱动器	57
数据库驱动	57
小结	59
第2部分  职责型模式
第7章  职责型模式介绍	62
常规的职责型模式	62
根据可见性控制职责	64
小结	65
超越普通职责	65
第8章  单例（Singleton）模式	67
单例模式机制	67
单例和线程	68
识别单例	70
小结	71
第9章  观察者（Observer）模式	72
经典范例：GUI中的观察者模式	72
模型/视图/控制器	76
维护Observable对象	82
小结	84
第10章  调停者（Mediator）模式	85
经典范例：GUI调停者（Mediator）	85
关系一致性中的调停者模式	89
小结	96
第11章  代理（Proxy）模式	97
经典范例：图像代理	97
重新思考图片代理	102
远程代理	104
动态代理	109
小结	114
第12章  职责链（Chain of Responsibility）模式	115
现实中的职责链模式	115
重构为职责链模式	117
固定职责链	119
没有组合结构的职责链模式	121
小结	121
第13章  享元（Flyweight）模式	122
不变性	122
抽取享元中不可变的部分	123
共享享元	125
小结	128
第3部分  构造型模式
第14章  构造型模式介绍	130
构造函数的挑战	130
小结	132
超出常规的构造函数	132
第15章  构建者（Builder）模式	134
常规的构建者	134
在约束条件下构建对象	137
可容错的构建者	139
小结	140
第16章  工厂方法（Factory Method）模式	141
经典范例：迭代器	141
识别工厂方法	142
控制要实例化的类	143
并行层次结构中的工厂方法模式	145
小结	147
第17章  抽象工厂（Abstract Factory）模式	148
经典范例：图形用户界面工具箱	148
抽象工厂和工厂方法	153
包和抽象工厂	157
小结	157
第18章  原型（Prototype）模式	158
作为工厂的原型	158
利用克隆进行原型化	159
小结	162
第19章  备忘录（Memento）模式	163
经典范例：使用备忘录模式执行撤销操作	163
备忘录的持久性	170
跨会话的持久性备忘录	170
小结	174
第4部分  操作型模式
第20章  操作型模式介绍	176
操作和方法	176
签名	177
异常	178
算法和多态	179
小结	180
超越常规的操作	181
第21章  模板方法（Template Method）模式	182
经典范例：排序	182
完成一个算法	186
模板方法钩子	188
重构为模板方法模式	189
小结	191
第22章  状态（State）模式	193
对状态进行建模	193
重构为状态模式	197
使状态成为常量	201
小结	203
第23章  策略（Strategy）模式	204
策略建模	204
重构到策略模式	207
比较策略模式与状态模式	211
比较策略模式和模板方法模式	211
小结	212
第24章  命令（Command）模式	213
经典范例：菜单命令	213
使用命令模式来提供服务	216
命令钩子	217
命令模式与其他模式的关系	219
小结	220
第25章  解释器（Interpreter）模式	221
一个解释器示例	221
解释器、语言和解析器	233
小结	234
第5部分  扩展型模式
第26章  扩展型模式介绍	236
面向对象设计的原则	236
Liskov替换原则	237
迪米特法则	238
消除代码的坏味道	239
超越常规的扩展	240
小结	241
第27章  装饰器（Decorator）模式	242
经典范例：流和输出器	242
函数包装器	250
装饰器模式和其他设计模式的关系	257
小结	258
第28章  迭代器（Iterator）模式	259
普通的迭代	259
线程安全的迭代	261
基于合成结构的迭代	267
小结	277
第29章  访问者（Visitor）模式	278
访问者模式机制	278
常规的访问者模式	280
Visitor环	286
访问者模式的危机	290
小结	292
附录A  指南	293
附录B  答案	297
附录C  Oozinoz源代码	366
附录D  UML概览	369
参考文献	375
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 2 参考大全
第一部分
Java语言 第1章
Java的起源	2 1.1
Java与其他语言的关系	2 1.2
Java的创立	4 1.3
为什么Java对Internet是非常重要的	6 1.4
Java的魔力：字节码	7 1.5
Java 的专门用语	8 1.6
继续发展	10 第2章
Java语言概述	12 2.1
面向对象的编程	12 2.2

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 2 参考大全
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序员面试笔试宝典
前言
上篇面试笔试经验技巧篇
第1章面试官箴言
1.1有道无术，术可求；有术无道，止于术
1.2求精不求全
1.3脚踏实地，培养多种技能
1.4保持空杯心态
1.5职场是能者的舞台
1.6学会“纸上谈兵”
1.7小结
第2章面试心得交流
2.1心态决定一切
2.2假话全不说，真话不全说
2.3走自己的路，让别人去说吧
2.4夯实基础谋出路
2.5书中自有编程法
2.6笔试成绩好，不会被鄙视
2.7不要一厢情愿做公司的“备胎”
2.8小结
第3章企业面试笔试攻略
3.1互联网企业
3.2网络设备提供商
3.3外企
3.4国企
3.5研究所
3.6创业型企业
3.7如何抉择
下篇面试笔试技术攻克篇
第4章Java基础知识
4.1基本概念
4.1.1 Java语言有哪些优点
4.1.2 Java与C／C++有什么异同
4.1.3为什么需要public static void main （String（） args）这个方法
4.1.4如何实现在main（）方法执行前输出“Hello World”
4.1.5 Java程序初始化的顺序是怎样的
4.1.6 Java中的作用域有哪些
4.1.7一个Java文件中是否可以定义多个类
4.1.8什么是构造函数
4.1.9为什么Java中有些接口没有 任何方法
4.1.10 Java中的clone方法有什么作用
4.1.11什么是反射机制
4.1.12 package有什么作用
4.1.13如何实现类似于C语言中函数指针的功能
4.2面向对象技术
4.2.1面向对象与面向过程有什么区别
4.2.2面向对象有哪些特征
4.2.3面向对象的开发方式有什么优点
4.2.4什么是继承
4.2.5组合和继承有什么区别
4.2.6多态的实现机制是什么
4.2.7重载和覆盖有什么区别
4.2.8抽象类（abstract class）与接口（interface）有什么异同
4.2.9内部类有哪些
4.2.10如何获取父类的类名
4.2.11this与super有什么区别
4.3关键字
4.3.1变量命名有哪些规则
4.3.2break、continue以及retum有什么区别
4.3.3final、fmally和finalize有什么区别
4.3.4 assert有什么作用
4.3.5 static关键字有哪些作用
4.3.6使用switch时有哪些注意事项
4.3.7 volatile有什么作用
4.3.8 instanceof有什么作用
4.3.9tritfp有什么作用
4.4基本类型与运算
4.4.1 Java提供了哪些基本数据类型
4.4.2什么是不可变类
4.4.3值传递与引用传递有哪些区别
4.4.4不同数据类型的转换有哪些规则
4.4.5强制类型转换的注意事项有哪些
4.4.6运算符优先级是什么？
4.4.7 Math类中round、ceil和floor方法的
功能各是什么
4.4.8++i与i++有什么区别
4.4.9如何实现无符号数的右移操作
4.4.10char型变量中是否可以存储一个
中文汉字
4.5字符串与数组
4.5.1字符串创建与存储的机制是什么
4.5.2“==”、equals和hashCode有什么区别
4.5.3String、StringBuffer、StringBuilder和StringTokenizer有什么区别
4.5.4 Ja，a中数组是不是对象
4.5.5数组的初始化方式有哪几种
4.5.6 length属性与length（）方法
有什么区别
4.6异常处理
4.6.1finally块中的代码什么时候被执行
4.6.2异常处理的原理是什么
4.6.3运行时异常和普通异常有什么区别
4.7输入输出流
4.7.1 Java IO流的实现机制是什么
4.7.2管理文件和目录的类是什么
4.7.3 Java Socket是什么
4.7.4 Java NIO是什么
4.7.5什么是Java序列化
4.7.6 System.out.println（）方法使用需要注意哪些问题
4.8 Java平台与内存管理
4.8.1为什么说Java是平台独立性语言
4.8.2 Java平台与其他语言平台有哪些区别
4.8.3 JVM加载class文件的原理机制是什么
4.8.4什么是CC
4.8.5 Java是否存在内存泄露问题
4.8.6 Java中的堆和栈有什么区别
4.9容器
4.9.1 Java CoUections框架是什么
4.9.2什么是迭代器
4.9.3ArrayList、Vector和LinkedList有什么区别
4.9.4HashMap、HashTable、TreeMap和WeakHashMap有哪些区别
4.9.5用自定义作为HashMap或HashTable的key需要注意哪些问题
4.9.6Collection和Collections有什么区别
4.10多线程
4.10.1什么是线程？它与进程有什么区别？为什么要使用多线程
4.10.2同步和异步有什么区别
4.10.3如何实现Java多线程
4.10.4 run（）方法与start（）方法有什么区别
4.10.5多线程同步的实现方法有哪些
4.10.6 sleep（）方法与wait（）方法有什么区别
4.10.7终止线程的方法有哪些
4.10.8 synchronized与Lock有什么异同
4.10.9什么是守护线程
4.10.10 join（）方法的作用是什么
4.11 Java数据库操作
4.11.1如何通过JDBC访问数据库
4.11.2 JDBC处理事务采用什么方法
4.11.3 Class.forName的作用是什么
4.11.4 Statement、PreparedStatement和CallableStatement有什么区别
4.11.5 getString（）方法与getObject（）方法有什么区别
4.11.6使用JDBC时需要注意哪些问题
4.11.7什么是JD0
4， 11.8 JDBC与Hibernate有什么区别
第5章Java Web
5.1 Servlet与JSP
5.1.1页面请求的工作流程是怎样的
5.1.2HTTP中GET与POST方法有什么区别
5.1.3什么是Servlet
5.1.4 doPost（）方法与doGet（）方法怎么选择
5.1.5什么是Servlet的生命周期
5.1.6 JSP有哪些优点
5.1.7 JSP与Servlet有何异同
5.1.8如何使用JSP与Servlet实现MVC模型
5.1.9Servlet中forward和redirect有什么区别
5.1.10 JSP的内置对象有哪些
5.1.11 request对象主要有哪些方法
5.1.12 JSP有哪些动作
5.1.13 JSP中mclude指令和include动作有什么区别
5.1.14会话跟踪技术有哪些
5.1.15 Web开发中如何指定字符串的编码
5.1.16什么是Ajax
5.1.17 cookie和session有什么区别
5.2 J2EE与EJB
5.2.1什么是J2EE
5.2.2 J2EE中常用的术语有哪些
5.2.3 EJB有哪些不同的类别
5.2.4 EJB与JavaBean有什么异同
5.2.5 EJB有哪些生命周期
5.2.6 EJB的角色有哪几种
5.2.7 EJB的开发流程是怎样的
5.2.8 EJB 3.0与EJB 2.0有哪些不同之处
5.2.9 EJB容器有哪些作用
5.2.10 EJB规范规定EJB中禁止的操作有哪些
5.2.11 Web服务器与Web应用服务器有什么区别
5.2.12什么是Web SeⅣice
5.2.13SOAP与REST有什么区别
5.2.14什么是XML
5.2.15数据库连接池的工作机制是怎样的
5.2.16 J2EE开发有哪些调优的方法
5.3框架
5.3.1什么是Struts框架
5.3.2 Struts框架响应客户请求的工作流程是什么
5.3.3 Struts框架的数据验证可分为几种类型
5.3.4Form Bean的表单验证流程是什么
5.3.5在Struts配置文件中，＜action＞元素包含哪些属性和子元素
5.3.6ActionForm Bean的作用有哪些
5.3.7 ActionForm的执行步骤有哪些
5.3.8forward与global—forward有什么区别
5.3.9 Struts如何实现国际化
5.3.10 Struts 1与Struts 2有哪些区别
5.3.11什么是IoC
5.3.12什么是AOP
5.3.13什么是Spring框架
5.3.14什么是Hibemate
5.3.15什么是Hibernate的二级缓存
5.3.16 Hibernate中session的update（）和saveOrUpdate（）、load（）和get（）有什么区别
5.3.17 Hibernate有哪些主键生成策略
5.3.18如何实现分页机制
5.3.19什么是SSH
第6章数据库原理
6.1 SQL语言的功能有哪些
6.2内连接与外连接有什么区别
6.3什么是事务
6.4什么是存储过程？它与函数有什么区别与联系
6.5各种范式有什么区别
6.6什么是触发器
6.7什么是游标
6.8如果数据库日志满了，会出现什么情况
6.9 union和union all有什么区别
6.10什么是视图
第7章设计模式
7.1什么是单例模式
7.2什么是工厂模式
7.3什么是适配器模式
7.4什么是观察者模式
第8章数据结构与算法
8.1链表
8.1.1如何实现单链表的增删操作
8.1.2如何从链表中删除重复数据
8.1.3如何找出单链表中的倒数第1个元素
8.1.4如何实现链表的反转
8.1.5如何从尾到头输出单链表
8.1.6如何寻找单链表的中间结点
8.1.7如何检测一个链表是否有环
8.1.8如何在不知道头指针的情况下删除指定结点
8.1.9如何判断两个链表是否相交
8.2栈与队列
8.2.1栈与队列有哪些区别
8.2.2如何实现栈
8.2.3如何用0（1）的时间复杂度求栈中最小元素
8.2.4如何实现队列
8.2.5如何用两个栈模拟队列操作
8.3排序
8.3.1如何进行选择排序
8.3.2如何进行插入排序
8.3.3如何进行冒泡排序
8.3.4如何进行归并排序
8.3.5如何进行快速排序
8.3.6如何进行希尔排序
8.3.7如何进行堆排序
8.3.8各种排序算法有什么优劣
8.4位运算
8.4.1如何用移位操作实现乘法运算
8.4.2如何判断一个数是否为2的n次方
8.4.3如何求二进制数中1的个数
8.5数组
8.5.1如何寻找数组中的最小值与最大值
8.5.2如何找出数组中第二大的数
8.5.3如何求最大子数组之和
8.5.4如何找出数组中重复元素最多的数
8.5.5如何求数组中两两相加等于20的组合种数
8.5.6如何把一个数组循环右移k位
8.5.7如何找出数组中第k个最小的数
8.5.8如何找出数组中只出现一次的数字
8.5.9如何找出数组中唯一的重复元素
8.5.10如何用递归方法求一个整数数组的最大元素
8.5.11如何求数对之差的最大值
8.5.12如何求绝对值最小的数
8.5.13如何求数组中两个元素的最小距离
8.5.14如何求指定数字在数组中第一次出现的位置
8.5.15如何对数组的两个子有序段进行合并
8.5.16如何计算两个有序整型数组的交集
8.5.17如何判断一个数组中数值是否连续相邻
8.5.18如何求解数组中反序对的个数
8.5.19如何求解最小三元组距离
8.6字符串
8.6.1如何实现字符串的反转
8.6.2如何判断两个字符串是否由相同的字符组成
8.6.3如何删除字符串中重复的字符
8.6.4如何统计一行字符中有多少个单词
8.6.5如何按要求打印数组的排列情况
8.6.6如何输出字符串的所有组合
8.7二叉树
8.7.1二叉树基本概念
8.7.2如何实现二叉排序树
8.7.3如何层序遍历二叉树
8.7.4已知先序遍历和中序遍历，如何求后序遍历
8.7.5如何求二叉树中结点的最大距离
8.8其他
8.8.1如何消除嵌套的括号
8.8.2如何不使用比较运算就可以求出两个数的最大值与最小值
第9章海量数据处理
9.1问题分析
9.2基本方法
9.3经典实例分析
9.3.1 top K问题
9.3.2重复问题
9.3.3排序问题
附录
附录A软件企业Java笔试真题1
附录B软件企业Java笔试真题2
附录C软件企业Java笔试真题3
附录D求职有用网站及QQ群一览表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序员面试笔试宝典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言精粹
第1章 java简介 1
java好在哪里 2
第2章 类型系统 7
类型系统概述 7
为何有三种 9
内在和外表 15
使用须知 16
真实问题 18
第3章 异常 21
导常概述 21
设计理念 25
工作原理 26
使用和滥用 30
异常的另一面 33
第4章 包 37
包概述 37
包和访问控制 40
一个例子 41
包和文件系统 44
.第5章 垃圾回收 47
垃圾回收概述 47
垃圾回收和引用 49
内存泄露 50
其他资源 53
第6章 java虚拟机 61
java虚拟机概述 61
安全性 63
可移植性 64
可移植陷阱 66
第7章 javadoc 73
javadoc概述 73
一个例子 75
实现文档 80
包文档 81
有关文档注释风格、编辑器的争论 83
第8章 集合 85
集合概述 85
参数化类型 92
高级话题 98
随机访问 108
结束语 112
第9章 远程方法调用和对象序列化 115
概述 116
对象序列化 127
rpc系统中的子类型 132
第10章 并发 137
并发概述 139
同步 144
原子数据 150
第11章 开发者生态环境 153
ide 154
junit 156
findbugs 160
其他工具 161
索引 163
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言精粹
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java网络编程精解
第1章 Java网络编程入门 1
1.1 进程之间的通信 1
1.2 计算机网络的概念 3
1.3 OSI参考模型 5
1.4 TCP/IP参考模型和TCP/IP协议 8
1.4.1 IP协议 11
1.4.2 TCP协议及端口 14
1.4.3 RFC简介 15
1.4.4 客户/服务器通信模式 16
1.5 用Java编写客户/服务器程序 17
1.5.1 创建EchoServer 18
1.5.2 创建EchoClient 20
1.6 小结 22
1.7 练习题 23
第2章 Socket用法详解 25
2.1 构造Socket 25
2.1.1 设定等待建立连接的超时时间 26
2.1.2 设定服务器的地址 26
2.1.3 设定客户端的地址 27
2.1.4 客户连接服务器时可能抛出的异常 27
2.2 获取Socket的信息 30
2.3 关闭Socket 32
2.4 半关闭Socket 33
2.5 设置Socket的选项 38
2.5.1 TCP_NODELAY选项 38
2.5.2 SO_RESUSEADDR选项 38
2.5.3 SO_TIMEOUT选项 39
2.5.4 SO_LINGER选项 42
2.5.5 SO_RCVBUF选项 44
2.5.6 SO_SNDBUF选项 45
2.5.7 SO_KEEPALIVE选项 45
2.5.8 OOBINLINE选项 45
2.5.9 服务类型选项 45
2.5.10 设定连接时间、延迟和带宽的相对重要性 46
2.6 发送邮件的SMTP客户程序 47
2.7 小结 51
2.8 练习题 52
第3章 ServerSocket用法详解 55
3.1 构造ServerSocket 55
3.1.1 绑定端口 55
3.1.2 设定客户连接请求队列的长度 56
3.1.3 设定绑定的IP地址 58
3.1.4 默认构造方法的作用 58
3.2 接收和关闭与客户的连接 59
3.3 关闭ServerSocket 60
3.4 获取ServerSocket的信息 60
3.5 ServerSocket选项 62
3.5.1 SO_TIMEOUT选项 62
3.5.2 SO_REUSEADDR选项 63
3.5.3 SO_RCVBUF选项 64
3.5.4 设定连接时间、延迟和带宽的相对重要性 64
3.6 创建多线程的服务器 65
3.6.1 为每个客户分配一个线程 65
3.6.2 创建线程池 67
3.6.3 使用JDK类库提供的线程池 72
3.6.4 使用线程池的注意事项 74
3.7 关闭服务器 76
3.8 小结 80
3.9 练习题 81
第4章 非阻塞通信 83
4.1 线程阻塞的概念 83
4.1.1 线程阻塞的原因 83
4.1.2 服务器程序用多线程处理阻塞通信的局限 84
4.1.3 非阻塞通信的基本思想 85
4.2 java.nio包中的主要类 87
4.2.1 缓冲区Buffer 88
4.2.2 字符编码Charset 90
4.2.3 通道Channel 90
4.2.4 SelectableChannel类 92
4.2.5 ServerSocketChannel类 93
4.2.6 SocketChannel类 93
4.2.7 Selector类 96
4.2.8 SelectionKey类 97
4.3 服务器编程范例 100
4.3.1 创建阻塞的EchoServer 100
4.3.2 创建非阻塞的EchoServer 103
4.3.3 在EchoServer中混合用阻塞模式与非阻塞模式 110
4.4 客户端编程范例 114
4.4.1 创建阻塞的EchoClient 114
4.4.2 创建非阻塞的EchoClient 116
4.4.3 创建非阻塞的PingClient 120
4.5 小结 126
4.6 练习题 127
第5章 创建非阻塞的HTTP服务器 129
5.1 HTTP协议简介 129
5.1.1 HTTP请求格式 129
5.1.2 HTTP响应格式 132
5.1.3 测试HTTP请求 133
5.2 创建非阻塞的HTTP服务器 137
5.2.1 服务器主程序：
HttpServer类 137
5.2.2 具有自动增长的缓冲区的ChannelIO类 138
5.2.3 负责处理各种事件的
Handler接口 140
5.2.4 负责处理接收连接就绪
事件的AcceptHandler类 140
5.2.5 负责接收HTTP请求和发送HTTP响应的RequestHandler类 141
5.2.6 代表HTTP请求的Request类 143
5.2.7 代表HTTP响应的Response类 145
5.2.8 代表响应正文的Content接口及其实现类 147
5.2.9 运行HTTP服务器 149
5.3 小结 150
5.4 练习题 151
第6章 客户端协议处理框架 153
6.1 客户端协议处理框架的主要类 153
6.2 在客户程序中运用协议处理框架 154
6.2.1 URL类的用法 154
6.2.2 URLConnection类的用法 156
6.3 实现协议处理框架 160
6.3.1 创建EchoURLConnection类 161
6.3.2 创建EchoURLStreamHandler及工厂类 162
6.3.3 创建EchoContentHandler类及工厂类 163
6.3.4 在EchoClient类中运用ECHO协议处理框架 165
6.4 小结 166
6.5 练习题 167
第7章 用Swing组件展示HTML文档 169
7.1 在按钮等组件上展示HTML文档 170
7.2 用JEditorPane组件创建简单的浏览器 171
7.3 小结 179
7.4 练习题 179
第8章 基于UDP的
数据报和套接字 181
8.1 UDP协议简介 181
8.2 DatagramPacket类 184
8.2.1 选择数据报的大小 185
8.2.2 读取和设置DatagramPacket的属性 185
8.2.3 数据格式的转换 186
8.2.4 重用DatagramPacket 187
8.3 DatagramSocket类 189
8.3.1 构造DatagramSocket 189
8.3.2 接收和发送数据报 190
8.3.3 管理连接 190
8.3.4 关闭DatagramSocket 191
8.3.5 DatagramSocket的选项 191
8.3.6 IP服务类型选项 193
8.4 DatagramChannel类 193
8.4.1 创建DatagramChannel 194
8.4.2 管理连接 194
8.4.3 用send()方法发送数据报 194
8.4.4 用receive()方法接收数据报 195
8.4.5 用write()方法发送数据报 198
8.4.6 用read()方法接收数据报 199
8.5 组播Socket 202
8.5.1 MulticastSocket类 205
8.5.2 组播Socket的范例 207
8.6 小结 209
8.7 练习题 210
第9章 对象的序列化与反序列化 213
9.1 JDK类库中的序列化API 213
9.2 实现Serializable接口 218
9.2.1 序列化对象图 220
9.2.2 控制序列化的行为 222
9.2.3 readResolve()方法在单例类中的运用 229
9.3 实现Externalizable接口 231
9.4 可序列化类的不同版本的序列化兼容性 233
9.5 小结 235
9.6 练习题 236
第10章 Java语言的反射机制 239
10.1 Java Reflection API简介 239
10.2 在远程方法调用中运用反射机制 244
10.3 代理模式 248
10.3.1 静态代理类 248
10.3.2 动态代理类 250
10.3.3 在远程方法调用中
运用代理类 253
10.4 小结 258
10.5 练习题 259
第11章 RMI框架 261
11.1 RMI的基本原理 262
11.2 创建第一个RMI应用 264
11.2.1 创建远程接口 264
11.2.2 创建远程类 265
11.2.3 创建服务器程序 267
11.2.4 创建客户程序 269
11.2.5 运行RMI应用 270
11.3 远程对象工厂设计模式 272
11.4 远程方法中的参数与返回值传递 277
11.5 回调客户端的远程对象 281
11.6 远程对象的并发访问 286
11.7 分布式垃圾收集 289
11.8 远程对象的equals()、hashCode()和clone()方法 294
11.9 使用安全管理器 294
11.10 RMI应用的部署及类的动态加载 295
11.11 远程激活 297
11.12 小结 303
11.13 练习题 304
第12章 通过JDBC API访问数据库 305
12.1 JDBC的实现原理 306
12.2 安装和配置MySQL数据库 308
12.3 JDBC API简介 310
12.4 JDBC API的基本用法 314
12.4.1 处理字符编码的转换 317
12.4.2 把连接数据库的各种属性放在配置文件中 318
12.4.3 管理Connection、Statement和ResultSet对象的生命周期 321
12.4.4 执行SQL脚本文件 326
12.4.5 处理SQLException 328
12.4.6 输出JDBC日志 329
12.4.7 获得新插入记录的主键值 329
12.4.8 设置批量抓取属性 330
12.4.9 检测驱动器使用的JDBC版本 330
12.4.10 元数据 331
12.5 可滚动及可更新的结果集 333
12.6 行集 339
12.7 调用存储过程 346
12.8 处理Blob和Clob类型数据 347
12.9 控制事务 351
12.9.1 事务的概念 351
12.9.2 声明事务边界的概念 353
12.9.3 在mysql.exe程序中声明事务 354
12.9.4 通过JDBC API声明事务边界 356
12.9.5 保存点 357
12.9.6 批量更新 358
12.9.7 设置事务隔离级别 360
12.10 数据库连接池 362
12.10.1 创建连接池 363
12.10.2 DataSource数据源 369
12.11 小结 371
12.12 练习题 372
第13章 基于MVC和RMI的分布式应用 375
13.1 MVC设计模式简介 375
13.2 store应用简介 377
13.3 创建视图 381
13.4 创建控制器 389
13.5 创建模型 390
13.6 创建独立应用 394
13.7 创建分布式应用 395
13.8 小结 398
13.9 练习题 398
第14章 通过JavaMail API收发邮件 401
14.1 E-mail协议简介 401
14.1.1 SMTP简单邮件传输协议 401
14.1.2 POP3邮局协议 402
14.1.3 接收邮件的新协议IMAP 402
14.1.4 MIME简介 403
14.2 JavaMail API简介 403
14.3 建立JavaMail应用程序的开发环境 405
14.3.1 获得JavaMail API的类库 405
14.3.2 安装和配置邮件服务器 406
14.4 创建JavaMail应用程序 408
14.5 身份验证 412
14.6 URLName类 416
14.7 创建和读取复杂电子邮件 418
14.7.1 邮件地址 419
14.7.2 邮件头部 420
14.7.3 邮件标记 421
14.7.4 邮件正文 422
14.8 操纵邮件夹 427
14.9 小结 432
14.10 练习题 433
第15章 安全网络通信 435
15.1 SSL简介 435
15.1.1 加密通信 436
15.1.2 安全证书 436
15.1.3 SSL握手 437
15.1.4 创建自我签名的安全证书 438
15.2 JSSE简介 439
15.2.1 KeyStore、KeyManager与TrustManager类 442
15.2.2 SSLContext类 443
15.2.3 SSLServerSocketFactory类 444
15.2.4 SSLSocketFactory类 444
15.2.5 SSLSocket类 444
15.2.6 SSLServerSocket类 447
15.2.7 SSLEngine类 448
15.3 创建基于SSL的安全服务器和安全客户 453
15.4 小结 457
15.5 练习题 457
第16章 CORBA简介 459
16.1 创建IDL接口 460
16.2 创建IDL接口的实现类 460
16.3 创建服务器程序 461
16.4 创建客户程序 462
16.5 运行CORBA程序 463
16.6 小结 464
16.7 练习题 465
第17章 Web服务简介 467
17.1 SOAP简介 467
17.2 建立Apache AXIS环境 469
17.3 在Tomcat上发布
Apache-AXIS Web应用 470
17.4 创建SOAP服务 471
17.4.1 创建提供SOAP
服务的Java类 471
17.4.2 创建SOAP服务的
发布描述符文件 471
17.5 管理SOAP服务 472
17.5.1 发布SOAP服务 472
17.5.2 删除SOAP服务 473
17.6 创建和运行SOAP
客户程序 473
17.7 发布JWS服务 476
17.8 小结 476
17.9 练习题 477
附录A 本书范例的运行方法 479
A.1 本书所用软件的下载地址 479
A.2 部分软件的安装 479
A.2.1 安装JDK 480
A.2.2 安装ANT 480
A.2.3 安装Tomcat 481
A.3 编译源程序 481
A.4 运行客户/服务器程序 482
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java网络编程精解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>阿里巴巴Java开发手册
序 V
前言 XI
第1章  编程规约  1
1.1  命名风格 2
1.2  常量定义 7
1.3  代码格式 9
1.4  OOP规约 14
1.5  集合处理 21
1.6  并发处理 28
1.7  控制语句 33
1.8  注释规约 38
1.9  其他 41
第2章  异常日志  43
2.1  异常处理 44
2.2  日志规约 49
第3章  单元测试  53
第4章  安全规约  59
第5章  MySQL数据库 63
5.1  建表规约 64
5.2  索引规约 68
5.3  SQL语句 72
5.4  ORM映射 75
第6章  工程结构  79
6.1  应用分层 80
6.2  二方库依赖 83
6.3  服务器 87
第7章  设计规约  89
附  录  专有名词 94
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>阿里巴巴Java开发手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻量级Java EE企业应用实战
第1章  Java EE应用和开发环境  1.1  Java EE应用概述    1.1.1  Java EE应用的分层模型    1.1.2  Java EE应用的组件    1.1.3  Java EE应用结构和优势    1.1.4  常用的Java EE服务器  1.2  轻量级Java EE应用相关技术    1.2.1  JSP、Servlet 3.0和JavaBean及替代技术    1.2.2  Struts 2.2及替代技术    1.2.3  Hibernate 3.6及替代技术    1.2.4  Spring 3.0及替代技术  1.3  Tomcat的下载和安装    1.3.1  安装Tomcat服务器    1.3.2  配置Tomcat的服务端口    1.3.3  进入控制台    1.3.4  部署Web应用    1.3.5  配置Tomcat的数据源  1.4  Eclipse的安装和使用    1.4.1  Eclipse的下载和安装    1.4.2  在线安装Eclipse插件    1.4.3  从本地压缩包安装插件    1.4.4  手动安装Eclipse插件    1.4.5  使用Eclipse开发Java EE应用    1.4.6  导入Eclipse项目    1.4.7  导入非Eclipse项目  1.5  Ant的安装和使用    1.5.1  Ant的下载和安装    1.5.2  使用Ant工具    1.5.3  定义生成文件    1.5.4  Ant的任务(task)  1.6  使用CVS进行协作开发    1.6.1  安装CVS服务器    1.6.2  配置CVS资源库    1.6.3  安装CVS客户端    1.6.4  发布项目到服务器    1.6.5  从服务器下载项目    1.6.6  同步(Update)本地文件    1.6.7  提交(Commit)修改    1.6.8  添加文件和目录    1.6.9  删除文件和目录    1.6.10  查看文件的版本变革    1.6.11  提取文件以前版本的内容    1.6.12  从以前版本重新开始    1.6.13  创建标签    1.6.14  创建分支    1.6.15  沿着分支开发    1.6.16  使用Eclipse作为CVS客户端  1.7  本章小结第2章  JSP/Servlet及相关技术详解  ……第3章  Struts 2的基本用法第4章  深入使用Struts 2第5章  Hibernate的基本用法第6章  深入使用Hibernate第7章  Spring的基本用法第8章  深入使用Spring第10章  简单工作流系统
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻量级Java EE企业应用实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 7基础教程
第1章 　编写第一个Java程序　　1
1.1 　安装JDK　　1
1.2 　安装Eclipse　　2
1.3 　创建第一个Java项目　　2
1.4 　创建程序　　4
1.4.1 　为程序添加更多功能　　6
1.4.2 　进一步开发　　7
1.4.3 　关于Java对象　　8
1.5 　小结　　9
第2章 　Java语法　　10
2.1 　样例　　10
2.1.1 　代码行　　13
2.1.2 　包声明　　15
2.1.3 　import导入　　16
2.1.4 　类　　17
2.1.5 　字段　　18
2.1.6 　方法　　19
2.1.7 　构造方法　　21
2.1.8 　访问修饰符　　21
2.1.9 　接口　　22
2.1.10 　异常　　23
2.1.11 　代码块　　25
2.1.12 　注释　　26
2.2 　小结　　28
第3章 　数据类型　　29
3.1 　基本数据类型　　29
3.1.1 　整型数据　　29
3.1.2 　实型数据　　30
3.1.3 　布尔型数据　　30
3.1.4 　字符型数据　　31
3.1.5 　特别的数据类型：字符串　　31
3.1.6 　字面常量　　32
3.2 　包装类　　34
3.3 　数组　　36
3.4 　不存在的类型：null　　37
3.5 　枚举　　38
3.6 　小结　　41
第4章 　运算符　　42
4.1 　Java运算符　　42
4.1.1 　运算符的优先级　　42
4.1.2 　被遗忘的运算符：小括号　　43
4.1.3 　后缀运算符　　43
4.1.4 　一元运算符　　44
4.1.5 　强制类型转换运算　　45
4.1.6 　乘法类运算符　　47
4.1.7 　加法类运算符　　48
4.1.8 　移位运算符　　49
4.1.9 　关系运算符　　50
4.1.10 　相等运算符　　52
4.1.11 　按位与运算符（&）　　53
4.1.12 　按位异或运算符（^）　　54
4.1.13 　按位或运算符（|）　　54
4.1.14 　逻辑与运算符（&&）　　54
4.1.15 　逻辑或运算符（||）　　55
4.1.16 　赋值运算符　　56
4.2 　对象的比较和排序　　57
4.2.1 　实现equals方法　　57
4.2.2 　用于排序的比较　　60
4.3 　小结　　65
第5章 　流程控制、循环以及分支　　66
5.1 　流程控制　　66
5.1.1 　if和if-else语句　　66
5.1.2 　switch语句　　68
5.2 　循环　　71
5.2.1 　for循环　　71
5.2.2 　while循环　　74
5.2.3 　do-while循环　　76
5.3 　分支　　77
5.3.1 　break语句　　77
5.3.2 　continue语句　　78
5.3.3 　return语句　　80
5.4 　小结　　81
第6章 　面向对象编程　　82
6.1 　对象　　82
6.2 　封装　　83
6.3 　继承　　83
6.3.1 　多重继承　　84
6.3.2 　通过接口为行为建模　　85
6.3.3 　抽象类　　85
6.3.4 　静态成员　　87
6.4 　多态　　88
6.5 　用Java语言为动物建模　　89
6.6 　建模粒度的经验　　93
6.7 　传引用和传值　　94
6.8 　小结　　96
第7章 　开发用户界面　　97
7.1 　Java Swing基础　　97
7.2 　大一些的Swing应用　　105
7.3 　小结　　133
第8章 　读写文件　　135
8.1 　使用File对象　　135
8.1.1 　打开文件　　137
8.1.2 　删除文件　　138
8.1.3 　使用临时文件　　139
8.1.4 　创建目录　　141
8.1.5 　删除目录　　143
8.1.6 　删除多个目录　　143
8.2 　读写文件内容　　145
8.2.1 　流　　145
8.2.2 　文件内容的读取　　145
8.2.3 　文件内容的写入　　147
8.3 　小结　　150
第9章 　读写XML 　　152
9.1 　XML的结构　　152
9.2 　XML和流　　155
9.3 　DOM和SAX　　156
9.4 　写XML　　157
9.4.1 　用DOM写XML文件　　158
9.4.2 　用String写XML文件　　161
9.5 　读取XML文件　　162
9.5.1 　用DOM读取XML文件　　162
9.5.2 　用SAX读取XML文件　　164
9.6 　工厂类浅谈　　167
9.7 　小结　　167
第10章 　动画　　168
10.1 　时序就是一切　　168
10.2 　动画：一个简单的例子　　169
10.3 　让多个项目同时动起来　　173
10.4 　精灵动画　　178
10.5 　小结　　184
第11章 　用Eclipse调试程序　　186
11.1 　调试流程　　187
11.2 　没有调试器的调试方法　　187
11.3 　启动Eclipse调试器　　188
11.4 　断点和变量　　189
11.4.1 　设置行断点　　189
11.4.2 　关于作用域　　190
11.4.3 　删除行断点　　192
11.4.4 　禁止行断点　　192
11.4.5 　设置条件断点　　192
11.5 　调试小贴士和技巧　　194
11.6 　修复Fireworks程序　　195
11.7 　小结　　197
第12章 　电子游戏　　198
12.1 　电子游戏原理　　198
12.1.1 　用户界面　　198
12.1.2 　游戏逻辑　　199
12.1.3 　游戏循环　　199
12.2 　TargetClick游戏　　199
12.3 　靶场射击游戏　　207
12.3.1 　扩展ShootingGallery游戏　　221
12.3.2 　限制条件的说明　　221
12.4 　游戏设计资源　　222
12.5 　小结　　222
第13章 　垃圾回收　　224
13.1 　内存分配　　224
13.1.1 　Java垃圾回收算法：标记清除法　　226
13.1.2 　内存设定　　227
13.2 　垃圾回收　　228
13.2.1 　代的概念　　229
13.2.2 　部分回收和完全回收　　230
13.2.3 　垃圾回收是基于事件驱动的　　230
13.2.4 　垃圾回收的有关设定　　230
13.3 　优化垃圾回收　　231
13.4 　回收提示　　233
13.5 　阻止垃圾回收　　233
13.6 　一种新型的垃圾回收器　　234
13.7 　小结　　235
第14章 　递归　　236
14.1 　递归是语言的基本特征　　236
14.2 　递归无处不在　　237
14.3 　明确终止条件　　237
14.4 　何时避免递归　　238
14.5 　何时使用递归　　239
14.6 　计算斐波那契序列　　239
14.7 　计算分形图形　　240
14.7.1 　绘制谢尔宾斯基三角形　　240
14.7.2 　绘制分形树　　244
14.8 　小结　　247
第15章 　泛型和正则表达式　　249
15.1 　泛型　　249
15.2 　正则表达式　　253
15.3 　小结　　259
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 7基础教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>码出高效：Java开发手册
第1 章 计算机基础
2 1.1 走进0 与1 的世界
6 1.2 浮点数
6 1.2.1 科学计数法
7 1.2.2 浮点数表示
9 1.2.3 加减运算
1.2.4 浮点数使用
1.3 字符集与乱码
1.4 CPU 与内存
1.5 TCP/IP
1.5.1 网络协议
1.5.2 IP
1.5.3 TCP 建立连接
1.5.4 TCP 断开连接
1.5.5 连接池
1.6 信息安全
1.6.1 黑客与安全
1.6.2 SQL 注入
1.6.3 XSS 与CSRF
1.6.4 CSRF
1.6.5 HTTPS
1.7 编程语言的发展
第2 章 面向对象
2.1 OOP 理念
2.2 初识Java
2.3 类
2.3.1 类的定义
2.3.2 接口与抽象类
2.3.3 内部类
2.3.4 访问权限控制
2.3.5 this 与 super
2.3.6 类关系
2.3.7 序列化
2.4 方法
2.4.1 方法签名
2.4.2 参数
2.4.3 构造方法
2.4.4 类内方法
2.4.5 getter 与setter
2.4.6 同步与异步
2.4.7 覆写
2.5 重载
2.6 泛型
2.7 数据类型
2.7.1 基本数据类型
2.7.2 包装类型
2.7.3 字符串
第3 章 代码风格
3.1 命名规约
3.1.1 常量
3.1.2 变量
3.2 代码展示风格
3.2.1 缩进、空格与空行
3.2.2 换行与高度
3.2.3 控制语句
3.3 代码注释
3.3.1 注释三要素
3.3.2 注释格式
第4 章 走进JVM
4.1 字节码
4.2 类加载过程
4.3 内存布局
4.4 对象实例化
4.5 垃圾回收
第5 章 异常与日志
5.1 异常分类
5.2 try 代码块
5.3 异常的抛与接
5.4 日志
5.4.1 日志规范
5.4.2 日志框架
第6 章 数据结构与集合
6.1 数据结构
6.2 集合框架图
6.2.1 List 集合
6.2.2 Queue 集合
6.2.3 Map 集合
6.2.4 Set
6.3 集合初始化
6.4 数组与集合
6.5 集合与泛型
6.6 元素的比较
6.6.1 Comparable 和Comparator
6.6.2 hashCode 和equals
6.7 fail-fast 机制
6.8 Map 类集合
6.8.1 红黑树
6.8.2 TreeMap
6.8.3 HashMap
6.8.4 ConcurrentHashMap
第7 章 并发与多线程
7.1 线程安全
7.2 什么是锁
7.3 线程同步
7.3.1 同步是什么
7.3.2 volatile
7.3.3 信号量同步
7.4 线程池
7.4.1 线程池的好处
7.4.2 线程池源码详解
7.5 ThreadLocal
7.5.1 引用类型
7.5.2 ThreadLocal 价值
7.5.3 ThreadLocal 副作用
第8 章 单元测试
8.1 单元测试的基本原则
8.2 单元测试覆盖率
8.3 单元测试编写
8.3.1 JUnit 单元测试框架
8.3.2 命名
8.3.3 断言与假设
第9 章 代码规约
9.1 代码规约的意义
9.2 如何推动落地
9.3 手册纵览
9.4 聊聊成长
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>码出高效：Java开发手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构与抽象（原书第4版）
出版者的话
译者序
前言
引言组织数据
序言设计类
P.1封装
P.2说明方法
P.2.1注释
P.2.2前置条件和后置条件
P.2.3断言
P.3Java接口
P.3.1写一个接口
P.3.2实现一个接口
P.3.3接口作为数据类型
P.3.4派生一个接口
P.3.5接口内命名常量
P.4选择类
P.4.1标识类
P.4.2CRC卡
P.4.3统一建模语言
P.5重用类
第1章包
1.1什么是包
1.2说明一个包
1.3使用ADT包
1.4像使用自动贩卖机一样使用ADT
1.5ADT集合
1.6Java类库：接口set
Java插曲1泛型
第2章使用数组实现包
2.1使用固定大小的数组实现ADT包
2.1.1类比
2.1.2一组核心方法
2.1.3实现核心方法
2.1.4让实现安全
2.1.5测试核心方法
2.1.6实现更多的方法
2.1.7删除项的方法
2.2使用可变大小的数组实现ADT包
2.2.1可变大小数组
2.2.2包的新实现
2.3使用数组实现ADT包的优缺点
Java插曲2异常
第3章使用链式数据实现包
3.1链式数据
3.2ADT包的链式实现
3.2.1私有类Node
3.2.2类LinkedBag的框架
3.2.3定义一些核心方法
3.2.4测试核心方法
3.2.5方法getFrequencyOf
3.2.6方法contalns
3.3从链中删除一项
3.4有设置和获取方法的类Node
3.5使用链实现ADT包的优缺点
第4章算法的效率
4.1动机
4.2测量算法的效率
4.2.1计数基本操作
4.2.2最优、最差和平均情形
4.3大O表示
4.4描述效率
4.5实现ADT包的效率
4.5.1基于数组的实现
4.5.2链式实现
4.5.3两种实现的比较
第5章栈
5.1ADT栈的规格说明
5.2使用栈来处理代数表达式
5.2.1问题求解：检查中缀代数表达式中平衡的分隔符
5.2.2问题求解：将中缀代数表达式转换为后缀表达式
5.2.3问题求解：计算后缀表达式的值
5.2.4问题求解：计算中缀表达式的值
5.3程序栈
5.4Java类库：类stack
第6章栈的实现
6.1链式实现
6.2基于数组的实现
6.3基于向量的实现
6.3.1Java类库：类Vector
6.3.2使用向量实现ADT栈
第7章递归
7.1什么是递归
7.2跟踪递归方法
7.3返回一个值的递归方法
7.4递归处理数组
7.5递归处理链
7.6递归方法的时间效率
7.6.1countDown的时间效率
7.6.2计算xn的时间效率
7.7困难问题的简单求解方案
7.8简单问题的低劣求解方案
7.9尾递归
7.10间接递归
7.11使用栈来替代递归
Java插曲3再谈泛型
第8章排序简介
8.1对数组进行排序的Java方法的组织
8.2选择排序
8.2.1迭代选择排序
8.2.2递归选择排序
8.2.3选择排序的效率
8.3插入排序
8.3.1迭代插入排序
8.3.2递归插入排序
8.3.3插入排序的效率
8.3.4链式结点链的插入排序
8.4希尔排序
8.4.1算法
8.4.2希尔排序的效率
8.5算法比较
第9章更快的排序方法
9.1归并排序
9.1.1归并数组
9.1.2递归归并排序
9.1.3归并排序的效率
9.1.4迭代归并排序
9.1.5Java类库中的归并排序
9.2快速排序
9.2.1快速排序的效率
9.2.2创建划分
9.2.3实现快速排序
9.2.4Java类库中的快速排序
9.3基数排序
9.3.1基数排序的伪代码
9.3.2基数排序的效率
9.4算法比较
Java插曲4再谈异常
第10章队列、双端队列和优先队列
10.1ADT队列
10.1.1问题求解：模拟排队
10.1.2问题求解：计算出售股票的资本收益
10.1.3Java类库：接口Queue
10.2ADT双端队列
10.2.1问题求解：计算出售股票的资本收益
10.2.2Java类库：接口Deque
10.2.3Java类库：类ArrayDeque
10.3ADT优先队列
10.3.1问题求解：跟踪任务分配
10.3.2Java类库：类PriorityQueue
第11章队列、双端队列和优先队列的实现
11.1队列的链式实现
11.2基于数组实现队列
11.2.1循环数组
11.2.2带一个不用位置的循环数组
11.3队列的循环链式实现
11.4Java类库：类AbstractQueue
11.5双端队列的双向链式实现
11.6优先队列的町能实现方案
第12章线性表
12.1ADT线性表的规格说明
12.2使用ADT线性表
12.3Java类库：接口List
12.4Java类库：类ArrayList
第13章使用数组实现线性表
13.1使用数组实现ADT线性表
13.1.1类比
13.1.2Java实现
13.1.3使用数组实现ADT线性袁的效率
第14章使用链式数据实现线性表
14.1链式结点链上的操作
14.1.1在不同的位置添加结点
14.1.2从不同的位置删除鲒点
14.1.3私有方法getNodeAt
14.2开始实现
14.2.1数据域和构造方法
14.2.2添加到线性表的表尾
14.2.3在线性表的给定位置添加力，
14.2.4方法isEmpty和toArray
14.2.5测试核心方法
14.3继续实现
14.4细化实现
14.5使用链实现ADT线性表的效率
14.6Java类库：类LinkedList
Java插曲5迭代器
第15章ADT线性表的迭代器
15.1实现迭代器的方法
15.2独立类迭代器
15.3内层类迭代器
15.3.1链式实现
15.3.2基于教组的实现
15.4为什么迭代器方法在它自己的类中
15.5基于数组实现接门ListIterator
Java插曲6可变及不可变对象
第16章有序表
16.1ADT有序表的规格说明
16.2链式实现
16.2.1方法add
16.2.2链式实现的效率
16.3使用ADT线性表实现
Java插曲7继承和多态
第17章继承和线性表
17.1使用继承实现有序表
17.2设计一个基类
17.3有序表的高效实现
第18章查找
18.1问题
18.2在无序数组中查找
18.2.1无序数组上的迭代顺序查找
18.2.2无序数组上的递归顺序查找
18.2.3顺序查找数组的效率
18.3有序数组上的查找
18.3.1有序数组上的顺序查找
18.3.2有序数组上的二分查找
18.3.3Java类库：方法binarySearch
18.3.4数组上的二分查找的效率425
184无序链上的查找
18.4.1无序链上的迭代顺序查找
18.4.2无序链上的递归顺序查找
18.4.3链上查找的效率
18.5有序链上的查找
18.5.1有序链上的顺序查找
18.5.2有序链上的二分查找
18.6查找方法的选掸
Java插曲8再论泛型
第19章字典
19.1ADT字典的规格说明
19.1.1Java接口
19.1.2迭代器
19.2使用ADT字典
19.2.1问题求解：电话号码簿
19.2.2问题求解：字的频度
19.2.3问题求解：字的词汇索引
19.3Java类库：接口Hap
第20章字典的实现
20.1基于数组的实现
20.1.1基于数组的无序字典
20.1.2基于数组的有序字典
20.2链式实现
20.2.1无序链式字典
20.2.2有序链式字典
第21章散列简介
21.1什么是散列
21.2散列函数
21.2.1计算散列码
21.2.2将散列码压缩为散列表的下标
21.3解决冲突
21.3.1开放地址的线性探查
21.3.2开放地址的二次探查
21.3.3开放地址的双散列
21.3.4开放地址的潜在问题
21.3.5拉链法
第22章使用散列实现字典
22.1散列的效率
22.1.1装填因子
22.1.2开放地址法的代价
22.1.3拉链法的代价
22.2冉散列
22.3冲突解决方案的比较
22.4字典的散列实现
22.4.1散列表中的项
22.4.2数据域和构造方法
22.4.3方法getValue、remove和add
22.4.4迭代器
22.5Java类库：类HashMap
22.6Java类库：类HashSet
第23章树
23.1树的概念
23.1.1层次结构
23.1.2树的术语
23.2树的遍历
23.2.1二又树的遍历
23.2.2一般树的遍历
23.3树的Java接口
23.3.1所有树的接口
23.3.2二叉树的接口
23.4二叉树的示例
23.4.1表达式树
23.4.2决策树
23.4.3二叉查找树
23.4.4堆
23.5一般树的示例
23.5.1语法树
23.5.2游戏树
……
第24章树的实现
第25章二叉查找树的实现
第26章堆的实现
第27章平衡查找树
第28章图
第29章图的实现
附录A文档和程序设计风格
附录BJava基础（在线）
附录CJava类（在线）
附录D从其他类创建类
附录E文件输入和输出（在线）
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构与抽象（原书第4版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hibernate实战
第一部分 从Hibernate和EJB 3.0开始
第1章 理解对象/关系持久化
1.1 什么是持久化
1.1.1 关系数据库
1.1.2 理解SQL
1.1.3 在Java中使用SQL
1.1.4 面向对象应用程序中的持久化
1.2 范式不匹配
1.2.1 粒度问题
1.2.2 子类型问题
1.2.3 同一性问题
1.2.4 与关联相关的问题
1.2.5 数据导航的问题
1.2.6 不匹配的代价
1.3 持久层和其他层
1.3.1 分层架构
1.3.2 用SQL/JDBC手工编写持久层
1.3.3 使用序列化
1.3.4 面向对象的数据库系统
1.3.5 其他选项
1.4 ORM
1.4.1 什么是ORM
1.4.2 一般的ORM问题
1.4.3 为什么选择ORM
1.4.4 Hibernate、EJB 3和JPA简介
1.5 小结
第2章 启动项目
2.1 启动Hibernate项目
2.1.1 选择开发过程
2.1.2 建立项目
2.1.3 Hibernate配置和启动
2.1.4 运行和测试应用程序
2.2 启动Java Persistence项目
2.2.1 使用Hibernate Annotations
2.2.2 使用Hibernate EntityManager
2.2.3 引入EJB组件
2.2.4 切换到Hibernate接口
2.3 反向工程遗留数据库
2.3.1 创建数据库配置
2.3.2 定制反向工程
2.3.3 生成Java源代码
2.4 与Java EE服务整合
2.4.1 与JTA整合
2.4.2 JNDI绑定的SessionFactory
2.4.3 JMX服务部署
2.5 小结
第3章 领域模型和元数据
3.1 CaveatEmptor应用程序
3.1.1 分析业务领域
3.1.2 CaveatEmptor领域模型
3.2 实现领域模型
3.2.1 处理关注点渗漏
3.2.2 透明和自动持久化
3.2.3 编写POJO和持久化实体类
3.2.4 实现POJO关联
3.2.5 把逻辑添加到访问方法
3.3 ORM元数据
3.3.1 XML中的元数据
3.3.2 基于注解的元数据
3.3.3 使用XDoclet
3.3.4 处理全局的元数据
3.3.5 运行时操作元数据
3.4 其他实体表示法
3.4.1 创建动态的应用程序
3.4.2 表示XML中的数据
3.5 小结
第二部分　映射概念和策略
第4章 映射持久化类
4.1 理解实体和值类型
4.1.1 细粒度的领域模型
4.1.2 定义概念
4.1.3 识别实体和值类型
4.2 映射带有同一性的实体
4.2.1 理解Java同一性和等同性
4.2.2 处理数据库同一性
4.2.3 数据库主键
4.3 类映射选项
4.3.1 动态的SQL生成
4.3.2 使实体不可变
4.3.3 给查询命名实体
4.3.4 声明包名称
4.3.5 用引号把SQL标识符括起来
4.3.6 实现命名约定
4.4 细粒度的模型和映射
4.4.1 映射基础属性
4.4.2 映射组件
4.5 小结
第5章 继承和定制类型
5.1 映射类继承
5.1.1 每个带有隐式多态的具体类一张表
5.1.2 每个带有联合的具体类一张表
5.1.3 每个类层次结构一张表
5.1.4 每个子类一张表
5.1.5 混合继承策略
5.1.6 选择策略
5.2 Hibernate类型系统
5.2.1 概述实体和值类型
5.2.2 内建的映射类型
5.2.3 使用映射类型
5.3 创建定制的映射类型
5.3.1 考虑定制的映射类型
5.3.2 扩展点
5.3.3 定制映射类型的案例
5.3.4 创建UserType
5.3.5 创建CompositeUserType
5.3.6 参数化定制类型
5.3.7 映射枚举
5.4 小结
第6章 映射集合和实体关联
6.1 值类型的set、bag、list和map
6.1.1 选择集合接口
6.1.2 映射set
6.1.3 映射标识符bag
6.1.4 映射list
6.1.5 映射map
6.1.6 排序集合和有序集合
6.2 组件的集合
6.2.1 编写组件类
6.2.2 映射集合
6.2.3 启用双向导航
6.2.4 避免非空列
6.3 用注解映射集合
6.3.1 基本的集合映射
6.3.2 排序集合和有序集合
6.3.3 映射嵌入式对象的集合
6.4 映射父/子关系
6.4.1 多样性
6.4.2 最简单的可能关联
6.4.3 使关联双向
6.4.4 级联对象状态
6.5 小结
第7章 高级实体关联映射
7.1 单值的实体关联
7.1.1 共享的主键关联
7.1.2 一对一的外键关联
7.1.3 用联结表映射
7.2 多值的实体关联
7.2.1 一对多关联
7.2.2 多对多关联
7.2.3 把列添加到联结表
7.2.4 映射map
7.3 多态关联
7.3.1 多态的多对一关联
7.3.2 多态集合
7.3.3 对联合的多态关联
7.3.4 每个具体类一张多态表
7.4 小结
第8章 遗留数据库和定制SQL
8.1 整合遗留数据库
8.1.1 处理主键
8.1.2 带有公式的任意联结条件
8.1.3 联结任意的表
8.1.4 使用触发器
8.2 定制SQL
8.2.1 编写定制CRUD语句
8.2.2 整合存储过程和函数
8.3 改进Schema DDL
8.3.1 定制SQL名称和数据类型
8.3.2 确保数据一致性
8.3.3 添加领域约束和列约束
8.3.4 表级约束
8.3.5 数据库约束
8.3.6 创建索引
8.3.7 添加辅助的DDL
8.4 小结
第三部分　会话对象处理
第9章 使用对象
9.1 持久化生命周期
9.1.1 对象状态
9.1.2 持久化上下文
9.2 对象同一性和等同性
9.2.1 引入对话
9.2.2 对象同一性的范围
9.2.3 脱管对象的同一性
9.2.4 扩展持久化上下文
9.3 Hibernate接口
9.3.1 保存和加载对象
9.3.2 使用脱管对象
9.3.3 管理持久化上下文
9.4 JPA
9.4.1 保存和加载对象
9.4.2 使用脱管的实体实例
9.5 在EJB组件中使用Java Persistence
9.5.1 注入EntityManager
9.5.2 查找EntityManager
9.5.3 访问EntityManagerFactory
9.6 小结
第10章 事务和并发
10.1 事务本质
10.1.1 数据库和系统事务
10.1.2 Hibernate应用程序中的事务
10.1.3 使用Java Persistence的事务
10.2 控制并发访问
10.2.1 理解数据库级并发
10.2.2 乐观并发控制
10.2.3 获得额外的隔离性保证
10.3 非事务数据访问
10.3.1 揭开自动提交的神秘面纱
10.3.2 使用Hibernate非事务地工作
10.3.3 使用JTA的可选事务
10.4 小结
第11章 实现对话
11.1 传播Hibernate Session
11.1.1 Session传播的用例
11.1.2 通过线程局部传播
11.1.3 利用JTA传播
11.1.4 利用EJB传播
11.2 利用Hibernate的对话
11.2.1 提供对话保证
11.2.2 利用脱管对象的对话
11.2.3 给对话扩展Session
11.3 使用JPA的对话
11.3.1 Java SE中的持久化上下文传播
11.3.2 在对话中合并脱管对象
11.3.3 在Java SE中扩展持久化上下文
11.4 使用EJB 3.0的对话
11.4.1 使用EJB的上下文传播
11.4.2 利用EJB扩展持久化上下文
11.5 小结
第12章 有效修改对象
12.1 传播性持久化
12.1.1 按可到达性持久化
12.1.2 把级联应用到关联
12.1.3 使用传播性状态
12.1.4 利用JPA的传播性关联
12.2 大批量和批量操作
12.2.1 使用HQL和JPA QL的大批量语句
12.2.2 利用批量处理
12.2.3 使用无状态的会话
12.3 数据过滤和拦截
12.3.1 动态数据过滤
12.3.2 拦截Hibernate事件
12.3.3 内核事件系统
12.3.4 实体监听器和回调
12.4 小结
第13章 优化抓取和高速缓存
13.1 定义全局抓取计划
13.1.1 对象获取选项
13.1.2 延迟的默认抓取计划
13.1.3 理解代理
13.1.4 禁用代理生成
13.1.5 关联和集合的即时加载
13.1.6 通过拦截延迟加载
13.2 选择抓取策略
13.2.1 批量预抓取数据
13.2.2 通过子查询预抓取集合
13.2.3 通过联结即时抓取
13.2.4 给二级表优化抓取
13.2.5 优化指导方针
13.3 高速缓存基本原理
13.3.1 高速缓存策略和范围
13.3.2 Hibernate高速缓存架构
13.4 高速缓存实践
13.4.1 选择并发控制策略
13.4.2 理解高速缓存区域
13.4.3 设置本地的高速缓存提供程序
13.4.4 设置重复的高速缓存
13.4.5 控制二级高速缓存
13.5 小结
第14章 利用HQL和JPA QL查询
14.1 创建和运行查询
14.1.1 准备查询
14.1.2 执行查询
14.1.3 使用具名查询
14.2 基本的HQL和JPA QL查询
14.2.1 选择
14.2.2 限制
14.2.3 投影
14.3 联结、报表查询和子查询
14.3.1 联结关系和关联
14.3.2 报表查询
14.3.3 利用子查询
14.4 小结
第15章 高级查询选项
15.1 利用条件和示例查询
15.1.1 基本的条件查询
15.1.2 联结和动态抓取
15.1.3 投影和报表查询
15.1.4 按示例查询
15.2 利用原生的SQL查询
15.2.1 自动的结果集处理
15.2.2 获取标量值
15.2.3 Java Persistence中的原生SQL
15.3 过滤集合
15.4 高速缓存查询结果
15.4.1 启用查询结果高速缓存
15.4.2 理解查询高速缓存
15.4.3 什么时候使用查询高速缓存
15.4.4 自然标识符高速缓存查找
15.5 小结
第16章 创建和测试分层的应用程序
16.1 Web应用程序中的Hibernate
16.1.1 用例简介
16.1.2 编写控制器
16.1.3 OSIV模式
16.1.4 设计巧妙的领域模型
16.2 创建持久层
16.2.1 泛型的数据访问对象模式
16.2.2 实现泛型CRUD接口
16.2.3 实现实体DAO
16.2.4 利用数据访问对象
16.3 命令模式简介
16.3.1 基础接口
16.3.2 执行命令对象
16.3.3 命令模式的变形
16.4 利用EJB 3.0设计应用程序
16.4.1 利用有状态的bean实现会话
16.4.2 利用EJB编写DAO
16.4.3 利用依赖注入
16.5 测试
16.5.1 理解不同种类的测试
16.5.2 TestNG简介
16.5.3 测试持久层
16.5.4 考虑性能基准
16.6 小结
第17章 JBoss Seam简介
17.1 Java EE 5.0编程模型
17.1.1 JSF详解
17.1.2 EJB 3.0详解
17.1.3 用JSF和EJB 3.0编写Web应用程序
17.1.4 分析应用程序
17.2 用Seam改善应用程序
17.2.1 配置Seam
17.2.2 将页面绑定到有状态的Seam组件
17.2.3 分析Seam应用程序
17.3 理解上下文组件
17.3.1 编写登录页面
17.3.2 创建组件
17.3.3 给上下文变量起别名
17.3.4 完成登录/注销特性
17.4 验证用户输入
17.4.1 Hibernate Validator简介
17.4.2 创建注册页面
17.4.3 用Seam实现国际化
17.5 利用Seam简化持久化
17.5.1 实现对话
17.5.2 让Seam管理持久化上下文
17.6 小结
附录A SQL基础知识
附录B 映射快速参考
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hibernate实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>OSGi与Equinox
第一部分　简介
第1章　OSGi、Equinox和Eclipse　　2
1.1 　简史　　2
1.2 　合作　　3
1.3 　实战的模块性和自由性　　4
1.4 　平台　　4
1.5 　生态系统　　5
1.6 　OSGi的来龙去脉　　5
1.6.1 　Java的谎言　　5
1.6.2 　现状核实　　6
1.6.3 　OSGi的寿命　　6
1.7 　实践中的OSGi和Equinox　　7
1.8 　总结　　8
第2章　OSGi基本概念　　9
2.1 　bundle环境　　9
2.2 　为何选择OSGi　　10
2.3 　bundle剖析　　13
2.4 　模块化　　14
2.4.1 　导出包　　14
2.4.2 　导入包　　14
2.4.3 　需要的bundle　　15
2.4.4 　强化模块化特性　　16
2.5 　模块化设计概念　　16
2.6 　生命周期　　17
2.7 　协作　　18
2.7.1 　服务　　18
2.7.2 　扩展和扩展点　　19
2.8 　OSGi框架　　20
2.9 　安全性　　20
2.10 　OSGi框架实现　　21
2.11 　总结　　21
第二部分　OSGi示例
第3章　教程介绍　　24
3.1 　何为Toast　　24
3.2 　Toast的演变　　26
3.3 　开发环境安装　　27
3.4 　示例代码　　28
3.4.1 　在章与章之间切换　　28
3.4.2 　比较　　29
3.5 　目标平台设置　　30
3.5.1 　预定义的目标　　31
3.5.2 　定义目标平台　　32
3.6 　通过示例进行学习　　35
3.7 　总结　　36
第4章　你好，Toast　　37
4.1 　简单的场景　　37
4.1.1 　创建工程　　37
4.1.2 　Gps　　38
4.1.3 　Airbag和IAirbagListener　　40
4.1.4 　EmergencyMonitor　　41
4.1.5 　Main　　43
4.1.6 　运行　　43
4.1.7 　检查点　　43
4.2 　将Toast划分为Bundle　　43
4.2.1 　GPS bundle　　45
4.2.2 　安全气囊bundle　　47
4.2.3 　紧急情况监视器bundle　　47
4.2.4 　启动　　49
4.3 　总结　　50
第5章　服务　　52
5.1 　转移到服务　　52
5.2 　注册GPS服务　　54
5.3 　注册安全气囊服务　　58
5.4 　获取服务示例代码　　61
5.5 　启动　　64
5.6 　故障排解　　64
5.7 　总结　　65
第6章　动态服务　　66
6.1 　动态服务简介　　66
6.2 　使用服务追踪器　　67
6.2.1 　修改bundle激活器　　67
6.2.2 　启动　　70
6.2.3 　服务追踪器小结　　72
6.3 　使用服务激活器工具包　　73
6.3.1 　在目标平台上安装SAT　　73
6.3.2 　修改GPS bundle激活器　　73
6.3.3 　修改安全气囊bundle激活器　　74
6.3.4 　修改紧急情况监视器bundle激活器　　74
6.3.5 　启动　　75
6.3.6 　SAT小结　　76
6.4 　使用声明式服务　　76
6.4.1 　修改GPS bundle　　77
6.4.2 　修改安全气囊bundle　　79
6.4.3 　修改紧急情况监视器bundle　　80
6.4.4 　运行　　82
6.4.5 　声明式服务总结　　83
6.5 　总结　　83
第7章　客户端/服务器端交互　　84
7.1 　后台　　84
7.1.1 　核心bundle　　84
7.1.2 　后台应急bundle　　85
7.2 　客户端　　88
7.2.1 　信道bundle　　88
7.2.2 　紧急情况监视器bundle　　92
7.3 　工具类　　94
7.3.1 　常量　　94
7.3.2 　属性　　94
7.3.3 　日志　　95
7.4 　运行Toast　　95
7.4.1 　运行后台　　96
7.4.2 　运行客户端　　97
7.5 　总结　　97
第8章　测试　　99
8.1 　使Toast具备可测试性　　99
8.2 　对Toast进行单元测试　　100
8.2.1 　测试方案　　100
8.2.2 　编写测试用例　　101
8.2.3 　运行单元测试　　103
8.3 　系统测试Toast　　104
8.3.1 　测试规划　　104
8.3.2 　创建测试工具　　105
8.3.3 　编写测试用例　　107
8.3.4 　运行系统测试　　110
8.4 　总结　　111
第9章　打包　　112
9.1 　定义Toast产品　　112
9.1.1 　创建产品配置　　112
9.1.2 　概述页　　114
9.1.3 　依赖页　　115
9.1.4 　配置页　　116
9.1.5 　启动页　　116
9.1.6 　运行产品　　118
9.1.7 　产品化客户端　　118
9.2 　导出Toast　　118
9.3 　为其他平台打包　　121
9.4 　认真考虑组件定义　　123
9.4.1 　版本和版本范围　　123
9.4.2 　导出包和友元　　124
9.5 　总结　　126
第10章　插件化服务　　127
10.1 　分离接口与接口的实现　　127
10.1.1 　将Fake Airbag与其接口相互分离　　128
10.1.2 　将模拟GPS与其接口相分离　　129
10.1.3 　回归测试　　129
10.2 　设备模拟　　130
10.2.1 　概念　　130
10.2.2 　设备模拟器框架　　131
10.3 　作为插件式服务的模拟设备　　131
10.3.1 　模拟安全气囊　　131
10.3.2 　模拟GPS　　133
10.4 　运行模拟设备　　134
10.5 　总结　　135
第11章　可扩展的用户界面　　136
11.1 　Crust　　136
11.1.1 　Crust shell　　136
11.1.2 　Crust工具　　137
11.2 　紧急情况处理　　138
11.2.1 　创建可插拔的用户界面　　138
11.2.2 　重构紧急情况处理业务逻辑　　139
11.2.3 　紧急情况处理用户界面　　140
11.2.4 　运行用户界面　　141
11.3 　车载气候系统和音响系统　　142
11.3.1 　车载气候系统与音响设备　　142
11.3.2 　空调和音响屏幕　　144
11.3.3 　运行用户界面　　144
11.4 　OSGi应用模型　　145
11.5 　导航和地图　　148
11.5.1 　谷歌地球集成　　148
11.5.2 　地图支持　　151
11.5.3 　应用可扩展性和导航支持　　152
11.5.4 　运行用户界面　　152
11.6 　总结　　154
第12章　动态配置　　155
12.1 　跟踪场景　　155
12.2 　安装跟踪代码　　156
12.2.1 　Core Tracking Bundle　　156
12.2.2 　后台跟踪bundle　　157
12.2.3 　客户端跟踪bundle　　157
12.3 　运行基本的跟踪场景　　158
12.4 　配置　　159
12.4.1 　OSGi的管理控制　　159
12.4.2 　客户端跟踪bundle　　159
12.4.3 　运行可配置的Toast　　161
12.4.4 　具备持久化配置的运行　　162
12.5 　总结　　162
第13章　Web门户　　163
13.1 　门户　　163
13.2 　PortalServlet　　164
13.3 　使用服务进行操作查询　　165
13.4 　声明门户操作　　168
13.5 　白板模式的利与弊　　170
13.6 　总结　　170
第14章　使用p2进行系统开发　　171
14.1 　Equinox p2 简介　　171
14.1.1 　架构　　172
14.1.2 　p2元数据——可安装的单元　　172
14.1.3 　组件　　173
14.1.4 　仓库　　173
14.1.5 　模式　　174
14.1.6 　指挥者　　174
14.1.7 　引擎　　174
14.2 　细化Toast结构　　174
14.2.1 　使用特性定义产品　　175
14.2.2 　后台特性　　175
14.2.3 　客户端特性　　177
14.2.4 　重构小结　　180
14.3 　编写一个配置器　　180
14.3.1 　配置器　　181
14.3.2 　配置后台　　184
14.3.3 　后台小结　　184
14.4 　增加一个Web部署页面　　184
14.4.1 　创建动作　　185
14.4.2 　管理动作　　185
14.4.3 　安装卸载动作　　186
14.4.4 　安装配置UI　　186
14.5 　导出、运行以及配置　　186
14.5.1 　引入一个p2仓库　　186
14.5.2 　运行Toast后台　　189
14.5.3 　创建并配置汽车　　190
14.6 　客户端动态部署　　191
14.7 　总结　　192
第三部分　进阶篇
第15章　声明式服务　　194
15.1 　声明式服务模型　　194
15.2 　常见场景　　195
15.2.1 　最简单的组件　　195
15.2.2 　引用服务　　197
15.2.3 　提供服务　　198
15.2.4 　引用和提供服务　　199
15.2.5 　立刻激活组件　　201
15.2.6 　白板模式　　202
15.2.7 　工厂组件　　207
15.3 　启动和调试DS应用　　213
15.4 　PDE工具　　214
15.5 　总结　　216
第16章　扩展　　217
16.1 　扩展注册　　217
16.2 　扩展点　　219
16.3 　扩展　　221
16.4 　高级扩展主题　　222
16.4.1 　扩展ID　　222
16.4.2 　命名扩展和匿名扩展　　222
16.4.3 　扩展工厂　　223
16.5 　扩展注册机制的生命周期　　223
16.6 　动态扩展的应用场景　　224
16.6.1 　场景一：没有缓存　　225
16.6.2 　场景二：缓存扩展　　225
16.6.3 　场景三：缓存对象　　227
16.7 　服务与扩展　　229
16.8 　扩展注册的神话　　231
16.9 　总结　　231
第17章　日志　　232
17.1 　日志服务规范　　232
17.1.1 　日志级别　　232
17.1.2 　记录日志　　233
17.1.3 　读取日志　　233
17.1.4 　监听日志　　234
17.2 　在Toast中使用LogService　　234
17.3 　使用LogReaderService　　237
17.4 　Toast的LogUtility类　　239
17.5 　Equinox的LogService实现　　240
17.6 　总结　　242
第18章　HTTP支持　　243
18.1 　HttpService　　243
18.2 　注册和注销Servlet　　245
18.3 　声明式HTTP内容注册　　248
18.4 　使用Jetty　　248
18.5 　HTTP上下文和JAAS集成　　249
18.5.1 　基于HTTP的认证和登录　　249
18.5.2 　运行具备安全机制的客户端　　252
18.6 　疑难解答　　253
18.6.1 　BindException　　253
18.6.2 　HttpService在监听哪个端口　　253
18.7 　总结　　254
第19章　服务器端　　255
19.1 　服务器端和OSGi　　255
19.2 　在Web应用中嵌入Toast后台系统　　257
19.2.1 　更新产品　　257
19.2.2 　Web应用的Root文件　　259
19.2.3 　构建Web应用　　261
19.2.4 　运行Web应用　　262
19.2.5 　疑难解答　　264
19.2.6 　<init-param>参数说明　　265
19.3 　OSGi中的远程服务　　265
19.3.1 　Eclipse通信框架　　266
19.3.2 　远程服务　　266
19.3.3 　分布式Toast　　266
19.3.4 　远程服务主机　　267
19.3.5 　远程服务客户端　　268
19.3.6 　服务发现　　269
19.3.7 　运行分布式系统　　270
19.4 　总结　　271
第20章　发布工程　　272
20.1 　什么是PDE构建　　272
20.2 　build.properties bundle　　273
20.2.1 　控制属性　　274
20.2.2 　使用自定义构建脚本　　275
20.3 　创建构建器　　275
20.3.1 　调整PDE构建的目标　　276
20.3.2 　build.properties　　276
20.4 　运行构建器　　279
20.5 　调整构建　　282
20.5.1 　自定义构建脚本　　282
20.5.2 　仓库和附加依赖项　　283
20.5.3 　从SCM（软件配置管理）系统中提取内容　　283
20.5.4 　获取map文件　　285
20.5.5 　自动替换版本号　　286
20.5.6 　设定版本号　　286
20.5.7 　定位和放置根目录文件　　287
20.6 　构建附加特征　　288
20.6.1 　创建特征构建器　　288
20.6.2 　build.properties　　288
20.6.3 　运行特征构建　　290
20.7 　构建WAR包　　291
20.8 　总结　　291
第四部分　参考篇
第21章　动态性的最佳实践　　294
21.1 　动态性与你　　294
21.2 　Toast的动态性　　295
21.3 　动态性的挑战　　296
21.4 　动态性意识　　297
21.4.1 　对象处理　　298
21.4.2 　bundle监听器　　299
21.5 　扩展者模式和BundleTracker　　300
21.6 　动态性启用　　300
21.7 　启动和停止的动态性　　302
21.7.1 　启动级别　　303
21.7.2 　正确使用服务　　304
21.7.3 　关闭也不总是易事　　304
21.8 　总结　　305
第22章　整合代码库　　306
22.1 　bundle形式的JAR　　306
22.2 　采用注入的方式进行bundle化　　307
22.3 　通过包装的方式进行bundle化　　309
22.4 　通过引用的方式进行bundle化　　310
22.5 　使用bnd进行bundle化　　312
22.6 　解决类加载问题　　312
22.6.1 　Class.forName()　　312
22.6.2 　与上下文类加载器有关的问题　　316
22.6.3 　管理JRE类　　317
22.6.4 　序列化　　318
22.7 　总结　　318
第23章　高级主题　　319
23.1 　Equinox控制台　　319
23.2 　OSGi中的角色　　322
23.3 　bundle的形态　　323
23.4 　片段　　325
23.5 　单例　　327
23.6 　bundle生命周期　　328
23.6.1 　生命周期状态　　328
23.6.2 　BundleActivator　　329
23.6.3 　激活器的弊端　　330
23.6.4 　激活器的使用　　330
23.7 　bundle激活策略　　331
23.8 　控制bundle启动　　332
23.8.1 　持久化启动　　332
23.8.2 　启用激活策略　　333
23.8.3 　osgi.bundles　　333
23.9 　类加载　　334
23.9.1 　类查找算法　　334
23.9.2 　声明导入和导出　　335
23.9.3 　导入包与需要的bundle　　335
23.9.4 　可选性　　336
23.9.5 　use指令　　336
23.9.6 　再导出　　337
23.9.7 　x-internal和x-friends　　337
23.9.8 　引导代理　　337
23.10 　配置和运行Equinox　　338
23.10.1 　config.ini　　338
23.10.2 　可执行程序　　339
23.11 　数据区　　341
23.12 　总结　　343
第24章　声明式服务引用　　344
24.1 　组件XML模式v1.0.0　　344
24.1.1 　声明XML的命名空间和模式　　344
24.1.2 　<component>元素　　345
24.1.3 　<implementation>元素　　347
24.1.4 　<property>元素　　347
24.1.5 　<properties>元素　　348
24.1.6 　<service>元素　　349
24.1.7 　<provide>元素　　349
24.1.8 　<reference>元素　　349
24.2 　组件的生命周期　　351
24.2.1 　满足组件的配置　　351
24.2.2 　组件的激活、注销与修改　　353
24.2.3 　访问引用服务　　355
24.2.4 　组件的即时性　　357
24.2.5 　组件属性　　357
24.3 　总结　　359
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>OSGi与Equinox
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java虚拟机精讲
第1 章  Java体系结构 / 1
1.1   认识 Java / 1
1.1.1   与生俱来的优点 / 2
1.1.2   语法结构和对象模型 / 4
1.1.3   历史版本追溯 / 5
1.2  Java重要概念 / 7
1.2.1  Java 编程语言 / 7
1.2.2   字节码 / 7
1.2.3  Java API / 8
1.2.4  Java 虚拟机 / 8
1.3   安装与配置 Java 运行环境 / 10
1.3.1  Windows 环境下的安装与 配置 / 10
1.3.2  Linux 环境下的安装与配置 / 11
1.3.3   编写Java 程序 / 12
1.3.4   编译与运行 / 13
1.3.5   关键字与标示符 / 13
1.4  Java技术的新特性 / 14
1.4.1  Java 模块化与 OSGi技术 / 14
1.4.2   语言无关性 / 15
1.4.3   使用Fork/Join 框架实现多核并行 / 16
1.4.4   丰富的语法特性 / 17
1.4.5   过渡到64 位虚拟机 / 18
1.5   实战：玩转 OpenJDK / 19
1.5.1  JDK 与OpenJDK 的关系 / 19
1.5.2   基于OpenJDK 深度定制的 淘宝JVM（TaobaoVM ） / 20
1.5.3   下载OpenJDK 源代码 / 22
1.5.4   构建编译环境 / 22
1.5.5   执行整个 OpenJDK的编译 / 23
1.5.6   执行单独 HotSpot的编译 / 26
1.5.7   导致编译失败的一些疑难 杂症 / 29
1.5.8   使用GDB工具Debug  HotSpot. / 30
1.6   本章小结 / 36
第2 章   字节码的编译原理 / 37
2.1  javac 编译器简介 / 37
2.1.1  javac与Eclipse Compiler for   Java 编译器 / 38
2.1.2  javac的使用与标准选项配置 / 39
2.1.3   编译原理 / 40
2.1.4   下载javac 编译器源码 / 41
2.1.5   调用compile() 方法执行编译 / 41
2.2   词法解析步骤 / 43
2.2.1  Token 序列 / 45
2.2.2   源码字符集合与 Token 之间 的对应关系 / 47
2.2.3   调用key()方法获取指定Token / 48
2.2.4   调用nextToken() 方法计算Token 的获取规则 / 48
2.2.5   调用parseCompilationUnit() 方法执行词法解 / 49
2.3   语法解析步骤 / 51
2.3.1   调用qualident()方法解析 package 语法节点 / 52
2.3.2   调用importDeclaration()
方法解析import 语法树 / 54
2.3.3   调用classDeclaration() 方法解析class 语法树 / 56
2.4   语义解析步骤 / 59
2.5   生成字节码 / 61
2.6   实战：使用 javap 工具分析字节码 / 62
2.7   实战：使用 GCJ 编译器将Java源码直接编译为本地机器指令 / 64
2.8   本章小结 / 66
第3 章   字节码文件 / 67
3.1   字节码文件的内部组成结构 / 67
3.2   符号引用 / 73
3.2.1   类或者接口的全限定名 / 74
3.2.2   简单名称 / 74
3.2.3   描述符 / 74
3.3   常量池 / 76
3.3.1  CONSTANT_Utf8_info 常量项 / 77
3.3.2  CONSTANT_Integer_info 常量项 / 77
3.3.3  CONSTANT_Float_info 常量项 / 78
3.3.4  CONSTANT_Long_info 常量项 / 78
3.3.5  CONSTANT_Double_info 常量项 / 79
3.3.6  CONSTANT_Class_info 常量项 / 79
3.3.7  CONSTANT_String_info 常量项 / 80
3.3.8  CONSTANT_Fieldref_info 常量项 / 81
3.3.9  CONSTANT_Methodref_info 常量项 / 81
3.3.10  CONSTANT_I nterfaceMethodref _info常量项 / 82
3.3.11  CONSTANT_NameAndType _info常量项 / 82
3.3.12  CONSTANT_MethodHandle _info常量项 / 83
3.3.13  CONSTANT_MethodType _info常量项 / 84
3.3.14  CONSTANT_InvokeDynamic _info常量项 / 84
3.4   字段表 / 85
3.5   方法表 / 86
3.6   属性表 / 88
3.6.1  Code属性 / 89
3.6.2  ConstantValue 属性 / 90
3.6.3  Exceptions 属性 / 91
3.6.4  LineNumberTable 属性 / 92
3.6.5  SourceFile 属性 / 93
3.6.6  LocalVariableTable属性 / 93
3.6.7  InnerClasses属性 / 94
3.6.8  BootstrapMethods 属性 / 95
3.7   本章小结 / 96

第4 章   剖析HotSpot 的Launcher / 97
4.1  HotSpot 的源码目录结构 / 97
4.2  Launcher简介 / 99
4.3   跟踪 Launcher 的执行过程 / 101
4.3.1   使用Launcher 启动JVM / 101
4.3.2   启动函数 main() / 102
4.3.3   在主线程中执行 JavaMain() 函数 / 106
4.3.4   调用JNI_CreateJavaVM() 函数初始化HotSpot / 114
4.3.5   调用LoadClass() 函数获取 Java 启动类 / 115
4.3.6   调用GetStaticMethodId() 函数获取Java 启动方法 / 116
4.3.7   调用CallStaticVoidMethod() 函数执行Java 启动方法 / 116
4.3.8   调用jni_DestroyJavaVM 函数销毁HotSpot / 119
4.4   实战：在 Launcher 中添加 自定义函数模块 / 120
4.5   本章小结 / 121
第5 章   剖析HotSpot 的初始化过程 / 122
5.1  HotSpot 的构成模块 / 122
5.2  Prims 模块 / 124
5.2.1  JNI 子模块 / 124
5.2.2  JVM子模块 / 125
5.2.3  JVMTI 子模块 / 128
5.2.4  Perf 子模块 / 129
5.3  Runtime 模块 / 129
5.3.1  Thread 子模块 / 131
5.3.2   调用create_vm() 函数完成 HotSpot的最终初始化 / 131
5.4   跟踪 HotSpot的初始化过程 / 140
5.4.1   调用init() 和init_2()函数 初始化os 模块 / 141
5.4.2   调用vm_init_globals()函数 初始化全局数据结构 / 144
5.4.3   调用init_globals() 函数 初始化全局模块 / 144
5.5   本章小结 / 146
第6 章   内存分配与垃圾回收 / 147
6.1  JVM的运行时内存区结构 / 147
6.2   线程共享内存区 / 148
6.2.1  Java 堆区 / 148
6.2.2   方法区 / 150
6.2.3   运行时常量池 / 150
6.3   线程私有内存区 / 150
6.3.1  PC寄存器 / 151
6.3.2  Java 栈 / 151
6.3.3   本地方法栈 / 152
6.4   性能监控区 / 152
6.5   自动内存管理 / 152
6.5.1   内存分配原理 / 153
6.5.2   逃逸分析与栈上分配 / 157
6.5.3   对象内存布局与 OOP-Klass 模型 / 158
6.5.4  GC 的作用 / 159
6.5.5   垃圾标记：根搜索算法 / 160
6.5.6   垃圾回收：分代收集算法 / 161
6.6   垃圾收集器 / 164
6.6.1   串行回收：Serial 收集器 / 165
6.6.2   并行回收：ParNew收集器 / 166
6.6.3   程序吞吐量优先：Parallel 收集器 / 166
6.6.4   低延迟：CMS（Concurrent- Mark-Sweep）收集器 / 167
6.6.5   区域化分代式：G1（Garbage- First ）收集器 / 170
6.6.6   垃圾收集的相关选项配置 / 172
6.7   实战：GC日志分析 / 175
6.7.1   不同GC日志的展示形式 / 175
6.7.2   使用GCHisto 工具分析离线 日志 / 179
6.8   实战：分析 dump 文件 / 181
6.8.1   使用jmap 工具生成dump 文件 / 181
6.8.2   使用MAT（Memory Analyzer Tool ）工具分析 dump 文件 / 182
6.9   本章小结 / 184
第7 章   类加载机制 / 185
7.1   类加载器 / 185
7.1.1   抽象类ClassLoader / 187
7.1.2   双亲委派模型 / 188
7.1.3   自定义类加载器 / 191
7.1.4   定位ClassNotFoundException 异常 / 193
7.1.5   定位NoClassDefFoundError 异常 / 194
7.2   类的加载过程 / 195
7.2.1   加载字节码 / 198
7.2.2   验证阶段 / 199
7.2.3   准备阶段 / 200
7.2.4   解析阶段 / 201
7.2.5   初始化阶段 / 201
7.3   实战：字节码文件的加密与 解密 / 204
7.4   本章小结 / 208
第8 章   剖析HotSpot 的架构模型与 执行引擎 / 209
8.1   栈帧的组成结构 / 209
8.1.1   局部变量表 / 211
8.1.2   操作数栈 / 212
8.1.3   动态链接 / 214
8.1.4   方法返回值 / 216
8.2  HotSpot 中执行引擎的架构 模型 / 216
8.2.1   本地机器指令 / 217
8.2.2   寄存器架构与栈式架构之间 的区别 / 218
8.2.3   基于栈式架构的设计 / 221
8.2.4   调用call_stub()函数执行Java 方法 / 222
8.2.5   栈顶缓存（Top-of-Stack Cashing ） 技术 / 225
8.2.6   实战：跟踪字节码解释器的 执行步骤 / 227
8.3   解释器与 JIT 编译器 / 230
8.3.1   查阅HotSpot的运行时执 行模式 / 231
8.3.2   解释器的工作机制与构成模块 / 232
8.3.3  JIT 编译器的工作机制与构成模块 / 234
8.3.4   分层编译策略 / 235
8.3.5   热点探测功能 / 236
8.4   本章小结 / 239
附录A  Java7新增语法特性 / 241
A.1  try-with-resources 语句 / 241
A.2  泛型的“<>”类型推断运算符 / 245
A.3  声明二进制字面值 / 247
A.4  字面值下画线支持 / 248
A.5  switch表达式支持 String 类型 / 250
A.6  mutil-catch特性 / 251
A.7  NIO2.0 文件系统的改变 / 255
附录B  指令助记符 / 262
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java虚拟机精讲
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java深度历险
第一章 深入Java2 SDK
第二章 深入类装载器
第三章 Java与Microsoft Office 
第四章 用Visual Studio.net来操纵Java虚拟机
第五章 package与import机制
第六章 Ant
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java深度历险
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言程序设计基础篇
出版者的话.
译者序
前言
第1篇 程序设计基础
第1章 计算机、程序和Java概述 2
1.1 引言 2
1.2 什么是计算机 2
1.2.1 中央处理器 3
1.2.2 内存 3
1.2.3 存储设备 3
1.2.4 输入输出设备 4
1.2.5 通信设备 5
1.3 程序 5
1.4 操作系统 6
1.4.1 控制和监视系统的活动 7
1.4.2 分配系统资源 7
1.4.3 安排操作的顺序 7
1.5 数系（可选） 7
1.5.1 二进制数与十进制数的转换 8
1.5.2 十六进制数与十进制数的转换 8
1.5.3 二进制数与十六进制数的转换 9
1.6 Java、万维网及其他 10
1.7 Java语言规范、API、JDK和IDE 12
1.8 一个简单的Java程序 12
1.9 创建、编译和运行Java程序 13
1.10 Java程序剖析 15
1.10.1 注释 15
1.10.2 保留字 15
1.10.3 修饰符 15
1.10.4 语句 16
1.10.5 块 16
1.10.6 类 16
1.10.7 方法 16
1.10.8 main方法 16
1.11 用消息对话框显示文本信息 16
第2章 基本数据类型和基本操作 21
2.1 引言 21
2.2 编写简单的程序 21
2.3 标识符 23
2.4 变量 24
2.5 赋值语句和赋值表达式 24
2.6 常量 25
2.7 数值数据类型及其运算 26
2.7.1 算术运算符 27
2.7.2 数值直接量 28
2.7.3 算术表达式 29
2.7.4 简捷赋值运算符 29
2.8 数值类型转换 31
2.9 字符数据类型及其运算 32
2.9.1 统一码和ASCⅡ码 32
2.9.2 特殊字符的转义序列表示 33
2.9.3 字符型char数据与数值型数据之间的转换 33
2.10 字符串类型String 34
2.11 从输入对话框获取输入 35
2.12 实例学习 36
2.12.1 举例：计算贷款支付额 36
2.12.2 举例：整钱兑零 38
2.12.3 举例：显示当前时间 40
2.13 从控制台获取输入 41
2.14 编程风格和文档 43
2.14.1 适当的注释和注释风格 44
2.14.2 命名习惯 44
2.14.3 适当的缩进和空白 44
2.14.4 块的对齐方式 44
2.15 编程错误 45
2.15.1 语法错误 45
2.15.2 运行错误 45
2.15.3 逻辑错误 46
2.16 调试 46
第3章 条件语句 53
3.1 引言 53
3.2 boolean数据类型及其运算 53
3.2.1 条件和无条件布尔运算符 55
3.2.2 举例：决定闰年 56
3.2.3 举例：简单的算术学习工具 56
3.3 if语句 57
3.3.1 简单if语句 57
3.3.2 if...else语句 59
3.3.3 if语句的嵌套 60
3.3.4 举例：税款计算问题 61
3.3.5 举例：改进的算术学习工具 63
3.4 switch语句 64
3.5 条件表达式 66
3.6 格式化控制台输出与字符串 66
3.7 运算符的优先级和结合方向 68
3.8 运算对象的计算顺序 69
第4章 循环 75
4.1 引言 75
4.2 while循环 75
4.2.1 举例：高级算术学习工具 76
4.2.2 使用确认对话框控制循环 77
4.2.3 使用标志值控制循环 78
4.3 do-while循环 79
4.4 for循环 80
4.5 采用哪种循环 81
4.6 嵌套循环 82
4.7 最小化数值误差 83
4.8 实例学习 84
4.8.1 举例：求最大公约数 84
4.8.2 举例：计算销售额 86
4.8.3 举例：显示数字构成的金字塔 88
4.9 关键字break和continue 89
4.9.1 语句标号以及利用标号中止循环（可选） 91
4.9.2 举例：显示素数（可选） 91
第5章 方法 101
5.1 引言 101
5.2 创建方法 101
5.3 调用方法 102
5.4 void方法举例 104
5.5 参数的值传递 105
5.6 重载方法 107
5.7 实例学习：使用方法计算税款 108
5.8 变量的作用域 110
5.9 数学类Math 111
5.9.1 三角函数方法 111
5.9.2 指数函数方法 111
5.9.3 取整方法 112
5.9.4 min、max和abs方法 112
5.9.5 random方法 113
5.10 实例学习：生成随机字符 113
5.11 方法抽象和逐步求精 115
5.11.1 自顶向下的设计 115
5.11.2 自顶向下和自底向上的实现 117
5.11.3 实现细节 118
5.12 包（可选） 121
5.12.1 包的命名习惯 121
5.12.2 包的目录 121
5.12.3 在包中添加类 122
5.12.4 使用包中的类 123
第6章 数组 132
6.1　引言 132
6.2　数组基本知识 132
6.2.1　声明数组变量 132
6.2.2　创建数组 133
6.2.3　数组的大小和默认值 133
6.2.4　数组下标变量 134
6.2.5　数组初始化 134
6.2.6　处理数组 134
6.2.7　foreach循环 135
6.2.8　举例：测试数组 136
6.2.9　举例：划分成绩等级 137
6.3　数组的复制 138
6.4　给方法传递数组参数 139
6.5　从方法中返回数组 142
6.6　变长参数列表（可选） 144
6.7　数组的查找 145
6.7.1　线性查找法 145
6.7.2　二分查找法 146
6.8　数组的排序 147
6.8.1　选择排序 147
6.8.2　插入排序（可选） 149
6.9　Arrays类 150
6.10　二维数组 151
6.10.1　声明二维数组变量和创建二维数组 151
6.10.2　求二维数组的长度 152
6.10.3　锯齿数组 153
6.10.4　处理二维数组 153
6.10.5　举例：多选题评分 154
6.10.6　举例：计算税款（可选） 156
6.11　多维数组（可选） 157
第2篇　面向对象程序设计
第7章　对象和类 168
7.1　引言 168
7.2　定义对象的类 168
7.3　构造方法 170
7.4　通过引用变量来访问对象 170
7.4.1　引用变量和引用类型 170
7.4.2　访问对象的数据和方法 171
7.4.3　举例：声明类并创建对象 171
7.4.4　数据域引用和空值null 174
7.4.5　基本数据类型变量和引用类型变量的区别 ..174
7.5　使用Java类库中的类 175
7.5.1　Date类 175
7.5.2　Random类 176
7.6　静态变量、常量和静态方法 176
7.7　可见性修饰符 180
7.8　数据域封装 181
7.9　不可变对象和类 183
7.10　给方法传递对象参数 184
7.11　变量的作用域 185
7.12　关键字this 186
7.13　对象数组 187
7.14　类的抽象和封装 189
7.15　实例学习：贷款类Loan 189
7.16　实例学习：课程类Course 193
7.17　实例学习：整数栈类StackOfIntegers（可选） 194
7.18　创建窗口（可选 GUI） 196
第8章　字符串和文本I/O 206
8.1　引言 206
8.2　字符串类String 206
8.2.1　构造一个字符串 206
8.2.2　不可变字符串与限定字符串 207
8.2.3　字符串的比较 208
8.2.4　字符串长度以及提取单个字符 209
8.2.5　字符串的连接 210
8.2.6　提取子串 210
8.2.7　字符串的转换 210
8.2.8　获取字符串中的一个字符或子串 211
8.2.9　字符串与数组之间的转换 211
8.2.10　将字符值和数值转换成字符串 212
8.2.11　举例：检测回文串 212
8.3　字符类Character 213
8.4　StringBuilder/StringBuffer类 215
8.4.1　修改缓冲区中的字符串 216
8.4.2　toString、capacity、length、setLength和charAt方法 217
8.4.3　举例：忽略既非字母又非数字的字符，判断回文串 217
8.5　命令行参数 219
8.5.1　向main方法传递字符串 219
8.5.2　举例：处理命令行参数 220
8.6　正则表达式（可选） 221
8.6.1　字符串匹配 221
8.6.2　正则表达式语法 221
8.6.3　字符串的替换和分解 223
8.7　文件类File 224
8.8　文本I/O 226
8.8.1　使用PrintWriter写数据 226
8.8.2　使用Scanner读数据 227
8.8.3　举例：替换文本 228
8.9　容器和布局管理器（可选GUI） 229
第9章　继承和多态 239
9.1　引言 239
9.2　父类和子类 239
9.3　使用关键字super 243
9.3.1　调用父类的构造方法 244
9.3.2　构造方法链 244
9.3.3　调用父类的方法 245
9.4　方法覆盖 245
9.5　覆盖和重载 246
9.6　对象类Object和它的toString()方法 246
9.7　多态性、动态绑定和一般程序设计 247
9.8　对象转换和instanceof运算符 248
9.9　数组线性表ArrayList类 251
9.10　自定义栈类 253
9.11　protected数据和方法 254
9.12　final类、方法和变量 255
9.13　对象类Object中的方法（可选） 256
9.13.1　equals方法 256
9.13.2　hashCode方法 257
9.13.3　finalize方法 257
9.13.4　clone方法 258
9.13.5　getClass方法 258
9.14　数据域和静态方法的隐藏（可选） 259
9.15　初始化模块（可选） 260
9.16　GUI组件的继承（可选 GUI） 262
第10章　抽象类和接口 271
10.1　引言 271
10.2　抽象类 271
10.3　日历类Calendar和公历类GregorianCalendar 275
10.4　接口 276
10.4.1　声明类以实现Comparable接口 277
10.4.2　接口与抽象类 278
10.4.3　创建自定义接口 280
10.4.4　可克隆接口Cloneable（可选） 281
10.5　将基本数据类型值处理为对象 283
10.5.1　数值包装类的构造方法 284
10.5.2　数值包装类的常量 285
10.5.3　转换方法 285
10.5.4　静态方法valueOf 285
10.5.5　将字符串转换为数值的方法 285
10.5.6　BigInteger和BigDecimal类（可选） 286
10.5.7　举例：对一个对象数组排序 286
10.6　基本类型和包装类之间的自动转换 288
10.7　处理GUI事件（可选GUI） 288
第11章　面向对象设计 295
11.1　引言 295
11.2　软件开发过程 295
11.3　分析类之间的关系 296
11.3.1　关联 296
11.3.2　聚集和组合 297
11.3.3　依赖 298
11.3.4　继承 298
11.4　实例学习：面向对象的设计 299
11.5　实例学习：有理数类Rational 304
11.6　类的设计原则 308
11.6.1　内聚性 308
11.6.2　一致性 308
11.6.3　封装性 308
11.6.4　清晰性 308
11.6.5　完整性 309
11.6.6　实例Instance和静态修饰符Static 309
11.6.7　继承和聚集 310
11.6.8　接口和抽象类 310
11.7　用顺序图和状态图模拟动态行为（可选） 310
11.7.1　顺序图 310
11.7.2　状态图 311
11.8　使用Java API在架构基础上编程 311
第3篇 图形用户界面程序设计
第12章　图形用户界面程序设计入门 316
12.1　引言 316
12.2　GUI组件 316
12.3　Java GUI API 317
12.3.1　Swing GUI组件 318
12.3.2　容器类 319
12.3.3　GUI辅助类 319
12.4　框架 319
12.4.1　创建框架 319
12.4.2　在框架中添加组件 320
12.5　布局管理器 321
12.5.1　FlowLayout 322
12.5.2　GridLayout 323
12.5.3　BorderLayout 325
12.5.4　布局管理器的属性 326
12.5.5　validate和doLayout方法（可选） 326
12.6　Color类 327
12.7　Font类 327
12.8　使用面板作子容器 328
12.9　Swing GUI组件的一般特性 329
12.10　图像图标 331
第13章　图形 338
13.1　引言 338
13.2　图形坐标系 338
13.3　Graphics类 339
13.4　paintComponent方法 340
13.5　在面板上绘图 342
13.6　绘制字符串、直线、矩形和椭圆 343
13.7　实例学习：FigurePanel类 344
13.8　绘制弧形 347
13.9　Polygon类以及绘制多边形和折线段 348
13.10　利用FontMetrics类居中显示 350
13.11　实例学习：MessagePanel类 352
13.12　实例学习：StillClock类（可选） 356
13.13　显示图像（可选） 359
13.14　实例学习：ImageViewer类（可选） 361
第14章　事件驱动程序设计 369
14.1　引言 369
14.2　事件和事件源 370
14.3　事件的监听、注册和处理 370
14.3.1　内部类监听器 373
14.3.2　匿名内部类监听器 375
14.3.3　举例：处理简单行为的事件 376
14.3.4　举例：处理窗口事件 377
14.3.5　监听器接口适配器 379
14.4　鼠标事件 380
14.5　键盘事件 382
14.6　使用Timer类的动画（可选） 384
第15章　创建图形用户界面 391
15.1　引言 391
15.2　按钮 391
15.2.1　图标、按下图标和翻转图标 392
15.2.2　对齐方式 393
15.2.3　文本位置 394
15.2.4　举例：使用按钮 394
15.3　复选框 396
15.4　单选按钮 399
15.5　标签 401
15.6　文本域 402
15.7　文本区域 404
15.8　组合框 407
15.9　列表框 410
15.10　滚动条 413
15.11　滑动块 415
15.12　创建多个窗口 417
第16章　applet和多媒体 428
16.1　引言 428
16.2　Applet类 428
16.2.1　init方法 429
16.2.2　start方法 430
16.2.3　stop方法 430
16.2.4　destroy方法 430
16.3　JApplet类 430
16.4　HTML文件和applet标记 431
16.4.1　使用applet浏览工具浏览applet 432
16.4.2　在Web浏览器中浏览applet 432
16.4.3　举例：贷款applet 433
16.5　让applet像应用程序一样运行 436
16.6　向applet传递字符串参数 437
16.7　实例学习：三子棋游戏（可选） 440
16.8　实例学习：跳动的小球（可选） 444
16.9　使用URL类定位资源（可选） 447
16.10　播放音频（可选） 448
16.11　实例学习：多媒体动画（可选） 449
16.12　Java工程的打包和发行（可选） 452
16.12.1　清单文件Manifest 452
16.12.2　运行存档项目 452
第4篇 异常处理、I/O和递归
第17章　异常和断言 462
17.1　引言 462
17.2　异常处理概述 462
17.3　异常和异常类型 464
17.4　理解异常处理 466
17.4.1　声明异常 466
17.4.2　抛出异常 466
17.4.3　捕获异常 467
17.4.4　从异常获取信息 468
17.4.5　举例：声明、抛出和捕获异常 470
17.5　finally子句 472
17.6　何时使用异常 473
17.7　重新抛出异常 473
17.8　链式异常（可选） 473
17.9　创建自定义异常类（可选） 474
17.10　断言（可选） 475
17.10.1　声明断言 475
17.10.2　运行带断言的程序 476
17.10.3　使用异常处理或断言 476
第18章　二进制I/O 485
18.1　引言 485
18.2　在Java中如何处理输入输出 485
18.3　文本I/O与二进制I/O 486
18.4　二进制I/O类 487
18.4.1　FileInputStream类和FileOutputStream类 488
18.4.2　FilterInputStream类和FilterOutputStream类 490
18.4.3　DataInputStream类和DataOutputStream类 490
18.4.4　BufferedInputStream类和BufferedOutputStream类 492
18.5　实例学习：文件复制 493
18.6　对象输入输出 495
18.6.1　可序列化接口Serializable 497
18.6.2　序列化数组 497
18.7　随机读写文件（可选） 498
18.8　实例学习：地址簿（可选） 501
第19章　递归 511
19.1　引言 511
19.2　举例：阶乘 511
19.3　举例：斐波那契数 513
19.4　使用递归解决问题 515
19.5　递归辅助方法 516
19.5.1　选择排序 516
19.5.2　二分查找 517
19.6　汉诺塔问题 517
19.7　分形 520
19.8　递归与迭代 522
附录A　Java关键字 528
附录B　ASCII码字符集 529
附录C　运算符优先级表 530
附录D　Java修饰符 531
附录E　特殊浮点值 532
附录F　位运算符 533
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言程序设计基础篇
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java深入解析
第1 章 基本概念....................................................................................................... 1
话题1 开门见山——测试你的Java 水平.................................................... 1
话题2 世外隐者——隐居深山的“关键字” .................................................. 2
话题3 疑团满腹——标识符更深层的思考............................................................ 6
话题4 鞭长莫及——我的特殊字符，你不能用！............................................ 10
话题5 移星换斗——从byte b = 1 谈类型转换的神秘........................................... 16
话题6 扑朔迷离——浮点类型的种种悬疑......................................................... 22
话题7 水落石出——浮点结构的最终解密......................................................... 31
话题8 龙虎争霸——基本for 循环与加强型for 循环的对比.................................. 45
第2 章 运算符与表达式........................................................................................ 52
话题9 莫衷一是——i+++j 该如何计算？.............................................................. 52
话题10 千差万别——++i 与i++仅是“先加”与“后加”的差别吗？....................... 56
话题11 大相径庭——相除与求余在Java 中的具体表现.......................................... 61
话题12 移形换位——移位运算的真实剖析............................................................ 75
话题13 鞭辟近里——条件运算符（？:）的类型深入.......................................... 81
话题14 井然有序——运算顺序的详细挖掘.................................................... 86
话题15 异曲同工——交换变量的3 种方式..................................................... 90
话题16 择木而栖——开关选择表达式switch 的类型内幕...................................... 95
第3 章 String 类................................................................................................... 103
话题17 来龙去脉——“+”是怎样连接字符串的？............................................. 103
话题18 一成不变——不可修改的String 对象........................................................... 107
话题19 钩深索隐——String 字符最大长度的探索...................................111
话题20 追本溯源——追寻String 字面常量的“极限”................................ 116
话题21 旧调重弹——再论equals 方法与“==”的 区别.................................. 122
话题22 顺藤摸瓜——从字面常量到String 常量池....................................... 136
第4 章 方法、构造器与变量........................................................................ 143
话题23 相差无几——main 方法很“特殊”吗？............................................... 143
话题24 一词多义——方法重载的详细说明.............................................................. 150
话题25 踵事增华——方法重写的真正条件........................................................ 166
话题26 一叶障目——方法与成员变量的隐藏...................................................... 177
话题27 发轫之始——执行初始化的构造器.................................................... 182
话题28 殊途同归——成员变量不同的初始化方式.............................................. 193
话题29 按部就班——初始化顺序与向前引用............................................. 206
第5 章 类与接口........................................................................................................... 220
话题30 相辅相成——基本数据类型与包装类................................................... 220
话题31 分门别类——数组的阐述........................................................................ 232
话题32 规矩方圆——定义规范的接口类型.............................................................. 242
话题33 彻里至外——嵌套类型........................................................................... 248
话题34 不胜枚举——枚举的神秘............................................................... 258
话题35 按部就班——加载、链接与初始化....................................................... 265
话题36 择优录取——类型及其成员的选择...................................................... 283
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java深入解析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通lambda表达式：Java多核编程
目    录
第1章  走进新生代的Java	1
1.1  从外部迭代到内部迭代	2
1.1.1  内部迭代	4
1.1.2  命令模式	6
1.1.3  lambda表达式	8
1.2  从集合到流	11
1.3  从串行到并行	15
1.4  组合行为	18
1.5  小结	22
第2章  Java lambda表达式的基础知识	23
2.1  lambda表达式的定义	24
2.2  lambda与匿名内部类	26
2.2.1  无标识性问题	26
2.2.2  lambda的作用域规则	27
2.3  变量捕获	29
2.4  函数式接口	32
2.5  使用lambda表达式	37
2.6  方法与构造器引用	39
2.6.1  静态方法引用	40
2.6.2  实例方法引用	41
2.6.3  构造器引用	44
2.7  类型检查	44
2.7.1  何为函数类型	45
2.7.2  匹配函数类型	46
2.8  重载解析	48
2.8.1  lambda表达式的重载	49
2.8.2  方法引用的重载	52
2.9  小结	54
第3章  流与管道介绍	55
3.1  流基础	56
3.1.1  面向并行的代码	59
3.1.2  原生流	61
3.2  剖析管道	63
3.2.1  开始管道	63
3.2.2  转换管道	64
3.2.3  非侵入性	75
3.2.4  终止管道	78
3.3  小结	90
第4章  终止流：收集与汇聚	91
4.1  使用收集器	94
4.1.1  独立的预定义收集器	94
4.1.2  组合收集器	99
4.1.3  链接管道	104
4.1.4  示例说明：最流行的主题	106
4.2  剖析收集器	108
4.3  编写收集器	111
4.3.1  完成器	115
4.3.2  示例说明：找到我的书	118
4.3.3  收集器的规则	122
4.4  汇聚	124
4.4.1  对原生值的汇聚	124
4.4.2  对引用流的汇聚	126
4.4.3  通过汇聚来组合收集器	131
4.5  小结	132
第5章  起始流：源与分割迭代器	135
5.1  创建流	136
5.2  分割迭代器与Fork/Join	145
5.3  异常	149
5.4  示例说明：递归grep	155
5.5  小结	166
第6章  流的性能	167
6.1  微基准度量	170
6.1.1  度量动态运行时	171
6.1.2  Java Microbenchmarking Harness	173
6.1.3  试验方法	174
6.2  选择执行模式	178
6.3  流的特性	181
6.4  排序	184
6.5  有状态操作与无状态操作	187
6.6  装箱与拆箱	188
6.7  分割迭代器性能	189
6.8  收集器性能	190
6.8.1  并发Map的合并	190
6.8.2  性能分析：对点进行分组	192
6.8.3  性能分析：找到我的书	192
6.9  小结	194
第7章  使用默认方法演化API	195
7.1  使用默认方法	199
7.2  抽象类的角色是什么	201
7.3  默认方法的语法	203
7.4  默认方法与继承	204
7.5  接口中的静态方法	211
7.6  小结	213
本书总结	215
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通lambda表达式：Java多核编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java并发编程之美
第一部分  Java 并发编程基础篇
第1 章  并发编程线程基础  2
1.1  什么是线程  2
1.2  线程创建与运行  3
1.3  线程通知与等待  6
1.4  等待线程执行终止的join 方法  16
1.5  让线程睡眠的sleep 方法  19
1.6  让出CPU 执行权的yield 方法  23
1.7  线程中断  24
1.8  理解线程上下文切换  30
1.9  线程死锁  30
1.9.1  什么是线程死锁  30
1.9.2  如何避免线程死锁  33
1.10  守护线程与用户线程  35
1.11  ThreadLocal  39
1.11.1  ThreadLocal 使用示例  40
1.11.2  ThreadLocal 的实现原理  42
1.11.3  ThreadLocal 不支持继承性  45
1.11.4  InheritableThreadLocal 类  46
第2 章  并发编程的其他基础知识  50
2.1  什么是多线程并发编程  50
2.2  为什么要进行多线程并发编程  51
2.3  Java 中的线程安全问题  51
2.4  Java 中共享变量的内存可见性问题  52
2.5  Java 中的synchronized 关键字  54
2.5.1  synchronized 关键字介绍  54
2.5.2  synchronized 的内存语义  55
2.6  Java 中的volatile 关键字  55
2.7  Java 中的原子性操作  57
2.8  Java 中的CAS 操作  59
2.9  Unsafe 类  59
2.9.1  Unsafe 类中的重要方法  59
2.9.2  如何使用Unsafe 类  61
2.10  Java 指令重排序  65
2.11  伪共享  67
2.11.1  什么是伪共享  67
2.11.2  为何会出现伪共享  68
2.11.3  如何避免伪共享  70
2.11.4  小结  72
2.12  锁的概述  72
2.12.1  乐观锁与悲观锁  72
2.12.2  公平锁与非公平锁  75
2.12.3  独占锁与共享锁  75
2.12.4  什么是可重入锁  76
2.12.5  自旋锁  77
2.13  总结  77
第二部分  Java 并发编程高级篇
第3 章  Java 并发包中ThreadLocalRandom 类原理剖析  80
3.1  Random 类及其局限性  80
3.2  ThreadLocalRandom  82
3.3  源码分析  84
3.4  总结  87
第4 章  Java 并发包中原子操作类原理剖析  88
4.1  原子变量操作类  88
4.2  JDK 8 新增的原子操作类LongAdder  93
4.2.1  LongAdder 简单介绍  93
4.2.2  LongAdder 代码分析  95
4.2.3  小结  101
4.3  LongAccumulator 类原理探究  102
4.4  总结  104
第5 章  Java 并发包中并发List 源码剖析  105
5.1  介绍  105
5.2  主要方法源码解析  106
5.2.1  初始化  106
5.2.2  添加元素  106
5.2.3  获取指定位置元素  108
5.2.4  修改指定元素  109
5.2.5  删除元素  110
5.2.6  弱一致性的迭代器  111
5.3  总结  114
第6 章  Java 并发包中锁原理剖析  115
6.1  LockSupport 工具类  115
6.2  抽象同步队列AQS 概述  122
6.2.1  AQS——锁的底层支持  122
6.2.2  AQS——条件变量的支持  128
6.2.3  基于AQS 实现自定义同步器  131
6.3  独占锁ReentrantLock 的原理  136
6.3.1  类图结构  136
6.3.2  获取锁  137
6.3.3  释放锁  142
6.3.4  案例介绍  143
6.3.5  小结  145
6.4  读写锁ReentrantReadWriteLock 的原理  145
6.4.1  类图结构  145
6.4.2  写锁的获取与释放  147
6.4.3  读锁的获取与释放  151
6.4.4  案例介绍  156
6.4.5  小结  158
6.5  JDK 8 中新增的StampedLock 锁探究  158
6.5.1  概述  158
6.5.2  案例介绍  160
6.5.3  小结  164
第7 章  Java 并发包中并发队列原理剖析  165
7.1  ConcurrentLinkedQueue 原理探究  165
7.1.1  类图结构  165
7.1.2  ConcurrentLinkedQueue 原理介绍  166
7.1.3  小结  181
7.2  LinkedBlockingQueue 原理探究  182
7.2.1  类图结构  182
7.2.2  LinkedBlockingQueue 原理介绍  185
7.2.3  小结  194
7.3  ArrayBlockingQueue 原理探究  195
7.3.1  类图结构  195
7.3.2  ArrayBlockingQueue 原理介绍  197
7.3.3  小结  202
7.4  PriorityBlockingQueue 原理探究  203
7.4.1  介绍  203
7.4.2  PriorityBlockingQueue 类图结构  203
7.4.3  原理介绍  205
7.4.4  案例介绍  214
7.4.5  小结  216
7.5  DelayQueue 原理探究  217
7.5.1  DelayQueue 类图结构  217
7.5.2  主要函数原理讲解  219
7.5.3  案例介绍  222
7.5.4  小结  224
第8 章  Java 并发包中线程池ThreadPoolExecutor 原理探究  225
8.1  介绍  225
8.2  类图介绍  225
8.3  源码分析  230
8.3.1  public void execute(Runnable command)  230
8.3.2  工作线程Worker 的执行  235
8.3.3  shutdown 操作  238
8.3.4  shutdownNow 操作  240
8.3.5  awaitTermination 操作  241
8.4  总结  242
第9 章  Java 并发包中ScheduledThreadPoolExecutor 原理探究  243
9.1  介绍  243
9.2  类图介绍  243
9.3  原理剖析  245
9.3.1  schedule(Runnable command, long delay,TimeUnit unit) 方法  246
9.3.2  scheduleWithFixedDelay(Runnable command,long initialDelay, long delay,TimeUnit unit) 方法  252
9.3.3  scheduleAtFixedRate(Runnable command,long initialDelay,long period,TimeUnit unit) 方法  254
9.4  总结  255
第10 章  Java 并发包中线程同步器原理剖析  256
10.1  CountDownLatch 原理剖析  256
10.1.1  案例介绍  256
10.1.2  实现原理探究  259
10.1.3  小结  263
10.2  回环屏障CyclicBarrier 原理探究  264
10.2.1  案例介绍  264
10.2.2  实现原理探究  268
10.2.3  小结  272
10.3  信号量Semaphore 原理探究  272
10.3.1  案例介绍  272
10.3.2  实现原理探究  276
10.3.3  小结  281
10.4  总结  281
第三部分  Java 并发编程实践篇
第11 章  并发编程实践  284
11.1  ArrayBlockingQueue 的使用  284
11.1.1  异步日志打印模型概述  284
11.1.2  异步日志与具体实现  285
11.1.3  小结  293
11.2  Tomcat 的NioEndPoint 中ConcurrentLinkedQueue 的使用  293
11.2.1  生产者——Acceptor 线程  294
11.2.2  消费者——Poller 线程  298
11.2.3  小结  300
11.3  并发组件ConcurrentHashMap 使用注意事项  300
11.4  SimpleDateFormat 是线程不安全的  304
11.4.1  问题复现  304
11.4.2  问题分析  305
11.4.3  小结  309
11.5  使用Timer 时需要注意的事情  309
11.5.1  问题的产生  309
11.5.2  Timer 实现原理分析  310
11.5.3  小结  313
11.6  对需要复用但是会被下游修改的参数要进行深复制  314
11.6.1  问题的产生  314
11.6.2  问题分析  316
11.6.3  小结  318
11.7  创建线程和线程池时要指定与业务相关的名称  319
11.7.1  创建线程需要有线程名  319
11.7.2  创建线程池时也需要指定线程池的名称  321
11.7.3  小结  325
11.8  使用线程池的情况下当程序结束时记得调用shutdown 关闭线程池  325
11.8.1  问题复现  325
11.8.2  问题分析  327
11.8.3  小结  329
11.9  线程池使用FutureTask 时需要注意的事情  329
11.9.1  问题复现  329
11.9.2  问题分析  332
11.9.3  小结  335
11.10  使用ThreadLocal 不当可能会导致内存泄漏  336
11.10.1  为何会出现内存泄漏  336
11.10.2  在线程池中使用ThreadLocal 导致的内存泄漏  339
11.10.3  在Tomcat 的Servlet 中使用ThreadLocal 导致内存泄漏  341
11.10.4  小结  344
11.11  总结  344
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java并发编程之美
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java测试新技术TestNG和高级概念
译者序序前言致谢第1章  起步  1.1 超越JUnit 3      1.1.1 有状态的类    1.1.2 参数    1.1.3 基类    1.1.4 异常并非偶然    1.1.5 执行测试    1.1.6 真实世界中的测试    1.1.7 配置方法    1.1.8 依赖关系    1.1.9 领悟  1.2 JUnit 4  1.3 针对可测试性而设计    1.3.1 面向对象编程和封装    1.3.2 设计模式革命    1.3.3 确定问题    1.3.4 推荐阅读  1.4 TestNG    1.4.1 annotation    1.4.2 测试、套件和配置annotation    1.4.3 分组    1.4.4 testng.xml  1.5 本章小结第2章  测试设计模式第3章  企业级测试第4章  Java EE测试第5章  集成第6章  扩展TestNG附录A  IDE集成附录B  TestNG Javadocs附录C  testng.xml附录D  从JUnit迁移
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java测试新技术TestNG和高级概念
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 7并发编程实战手册
第1章 线程管理 1
1.1 简介 1
1.2 线程的创建和运行 2
1.3 线程信息的获取和设置 5
1.4 线程的中断 9
1.5 线程中断的控制 11
1.6 线程的休眠和恢复 15
1.7 等待线程的终止 17
1.8 守护线程的创建和运行 20
1.9 线程中不可控异常的处理 24
1.10 线程局部变量的使用 26
1.11 线程的分组 30
1.12 线程组中不可控异常的处理 34
1.13 使用工厂类创建线程 37
第2章 线程同步基础 41
2.1 简介 41
2.2 使用synchronized实现同步方法 42
2.3 使用非依赖属性实现同步 47
2.4 在同步代码中使用条件 53
2.5 使用锁实现同步 57
2.6 使用读写锁实现同步数据访问 61
2.7 修改锁的公平性 65
2.8 在锁中使用多条件(Multiple Condition) 69
第3章 线程同步辅助类 77
3.1 简介 77
3.2 资源的并发访问控制 78
3.3 资源的多副本的并发访问控制 83
3.4 等待多个并发事件的完成 87
3.5 在集合点的同步 91
3.6 并发阶段任务的运行 100
3.7 并发阶段任务中的阶段切换 109
3.8 并发任务间的数据交换 115
第4章 线程执行器 120
4.1 简介 120
4.2 创建线程执行器 121
4.3 创建固定大小的线程执行器 126
4.4 在执行器中执行任务并返回结果 129
4.5 运行多个任务并处理第一个结果 134
4.6 运行多个任务并处理所有结果 139
4.7 在执行器中延时执行任务 144
4.8 在执行器中周期性执行任务 147
4.9 在执行器中取消任务 151
4.10 在执行器中控制任务的完成 154
4.11 在执行器中分离任务的启动与结果的处理 158
4.12 处理在执行器中被拒绝的任务 164
第5章 Fork/Join框架 168
5.1 简介 168
5.2 创建Fork/Join线程池 170
5.3 合并任务的结果 178
5.4 异步运行任务 187
5.5 在任务中抛出异常 194
5.6 取消任务 199
第6章 并发集合 206
6.1 简介 206
6.2 使用非阻塞式线程安全列表 207
6.3 使用阻塞式线程安全列表 212
6.4 使用按优先级排序的阻塞式线程安全列表 215
6.5 使用带有延迟元素的线程安全列表 221
6.6 使用线程安全可遍历映射 226
6.7 生成并发随机数 231
6.8 使用原子变量 233
6.9 使用原子数组 237
第7章 定制并发类 242
7.1 简介 242
7.2 定制ThreadPoolExecutor类 243
7.3 实现基于优先级的Executor类 248
7.4 实现ThreadFactory接口生成定制线程 252
7.5 在Executor对象中使用ThreadFactory 257
7.6 定制运行在定时线程池中的任务 259
7.7 通过实现ThreadFactory接口为Fork/Join框架生成定制线程 267
7.8 定制运行在Fork/Join框架中的任务 273
7.9 实现定制Lock类 278
7.10 实现基于优先级的传输队列 284
7.11 实现自己的原子对象 294
第8章 测试并发应用程序 300
8.1 简介 300
8.2 监控Lock接口 301
8.3 监控Phaser类 305
8.4 监控执行器框架 309
8.5 监控Fork/Join池 312
8.6 输出高效的日志信息 317
8.7 使用FindBugs分析并发代码 323
8.8 配置Eclipse调试并发代码 327
8.9 配置NetBeans调试并发代码 330
8.10 使用MultithreadedTC测试并发代码 335
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 7并发编程实战手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java编程思想
前言
第1章 对象入门
1.1 抽象的进步
1.2对象的接口
1.3实现方案的隐藏
1.4方案的重复使用
1.5继承：重新使用接口
1.5.1改善基础类
1.5.2等价与类似关系
1.6多形对象的互换使用
1.6.1动态绑定
1.6.2抽象的基础类和接口
1.7 对象的创建和存在时间
1.7.1集合与继承器
1.7.2单根结构
1.7.3集合库与方便使用集合
1.7.4清除时的困境：由谁负责清除？
1.8违例控制：解决错误
1.9多线程
1.10永久性
1.11Java和因特网
1.11.1什么是Web
1.11.2客户端编程
1.11.3服务器端编程
1.11.4一个独立的领域：应用程序
1.12分析和设计
1.12.1不要迷失
1.12.2阶段0：拟出一个计划
1.12.3阶段1：要制作什么
1.12.4阶段2：如何构建
1.12.5阶段3：开始创建
1.12.6阶段4：校订
1.12.7计划的回报
1.13Java还是C＋＋
第2章 一切都是对象
2.1用句柄操纵对象
2.2所有对象都必须创建
2.2.1保存到什么地方
2.2.2特殊情况：主要类型
2.2.3Java的数组
2.3绝对不要清除对象
2.3.1作用域
2.3.2对象的作用域
2.4新建数据类型：类
2.5方法、自变量和返回值
2.6构建Java程序
2.6.1名字的可见性
2.6.2使用其他组件
2.6.3static关键字
2.7我们的第一个Java程序
2.8注释和嵌入文档
2.8.1注释文档
2.8.2具体语法
2.8.3嵌入HTML
2.8.4＠see：引用其他类
2.8.5类文档标记
2.8.6变量文档标记
2.8.7方法文档标记
2.8.8文档示例
2.9编码样式
2.10总结
2.11练习
第3章 控制程序流程
3.1使用Java运算符
3.1.1优先级
3.1.2赋值
3.1.3算术运算符
3.1.4自动递增和递减
3.1.5关系运算符
3.1.6逻辑运算符
3.1.7按位运算符
3.1.8移位运算符
3.1.9三元if－else运算符
3.1.10逗号运算符
3.1.11字串运算符＋
3.1.12运算符常规操作规则
3.1.13造型运算符
3.1.14 Java没有“sizeof”
3.1.15复习计算顺序
3.1.16运算符总结
3.2执行控制
3.2.1真和假
3.2.2if－else
3.2.3反复
3.2.4do－while
3.2.5for
3.2.6中断和继续
3.2.7开关
3.3总结
3.4练习
第4章 初始化和清除
4.1用构建器自动初始化
4.2方法过载
4.2.1区分过载方法
4.2.2主类型的过载
4.2.3返回值过载
4.2.4默认构建器
4.2.5 this关键字
4.3清除：收尾和垃圾收集
4.3.1 finalize（）用途何在
4.3.2必须执行清除
4.4成员初始化
4.4.1规定初始化
4.4.2构建器初始化
4.5数组初始化
4.6总结
4.7 练习
第5章 隐藏实施过程
5.1包：库单元
5.1.1创建独一无二的包名
5.1.2自定义工具库
5.1.3利用导入改变行为
5.1.4包的停用
5.2Java访问指示符
5.2.1“友好的”
5.2.2public：接口访问
5.2.3private：不能接触
5.2.4protected：“友好的一种”
5.3接口与实现
5.4类访问
5.5总结
5.6练习
第6章 类再生
6.1合成的语法
6.2继承的语法
6.3合成与继承的结合
6.3.1确保正确的清除
6.3.2名字的隐藏
6.4到底选择合成还是继承
6.5protected
6.6累积开发
6.7上溯造型
6.8final关键字
6.8.1final数据
6.8.2final方法
6.8.3final类
6.8.4final的注意事项
6.9初始化和类装载
6.10总结
6.11练习
第7章 多形性
7.1上溯造型
7.2深入理解
7.2.1方法调用的绑定
7.2.2产生正确的行为
7.2.3扩展性
7.3覆盖与过载
7.4抽象类和方法
7.5接口
7.5.1Java的“多重继承”
7.5.2通过继承扩展接口
7.5.3常数分组
7.5.4初始化接口中的字段
7.6 内部类
7.6.1内部类和上溯造型
7.6.2方法和作用域中的内部类
7.6.3链接到外部类
7.6.4static内部类
7.6.5引用外部类对象
7.6.6从内部类继承
7.6.7内部类可以覆盖吗？
7.6.8内部类标识符
7.6.9为什么要用内部类：控制框架
7.7构建器和多形性
7.7.1构建器的调用顺序
7.7.2继承和finalize（）
7.7.3构建器内部的多形性方法的行为
7.8通过继承进行设计
7.8.1纯继承与扩展
7.8.2下溯造型与运行期类型标识
7.9 总结
7.10 练习
第8章 对象的容纳
8.1数组
8.1.1数组和第一类对象
8.1.2数组的返回
8.2集合
8.3枚举器（反复器）
8.4集合的类型
8.4.1Vector
8.4.2BitSet
8.4.3Stack
8.4.4Hashtable
8.4.5再论枚举器
8.5排序
8.6通用集合库
8.7新集合
8.7.1使用Collections
8.7.2使用Lists
8.7.3使用Sets
8.7.4使用Maps
8.7.5决定实施方案
8.7.6未支持的操作
8.7.7排序和搜索
8.7.8实用工具
8.8总结
8.9练习
第9章 违例差错控制
9.1基本违例
9.2违例的捕获
9.2.1try块
9.2.2违例控制器
9.2.3违例规范
9.2.4捕获所有违例
9.2.5重新“掷”出违例
9.3标准Java违例
9.4创建自己的违例
9.5违例的限制
9.6用finally清除
9.6.1用finally做什么？
9.6.2缺点：丢失的违例
9.7构建器
9.8违例匹配
9.9总结
9.10练习
第10章 JavaIO系统
10.1输入和输出
10.1.1InputStream的类型
10.1.2OutputStream的类型
10.2增添属性和有用的接口
10.2.1通过FilterInputStream从InputStream里读人数据
10.2.2通过FilterOutputStream向Output Strea－m里写入数据
10.3本身的缺陷：RandomAccessFile
10.4File类
10.4.1目录列表器
10.4.2检查与创建目录
10.5IO流的典型应用
10.5.1输入流
10.5.2输出流
10.5.3快捷文件处理
10.5.4从标准输入中读取数据
10.5.5管道数据流
10.6StreamTokenizer
10.7Java1.1的IO流
10.7.1数据的发起与接收
10.7.2修改数据流的行为
10.7.3未改变的类
10.7.4 一个例子
10.7.5重导向标准IO
10.8压缩
10.8.1用GZIP进行简单压缩
10.8.2用Zip进行多文件保存
10.8.3Java归档（jar）实用程序
10.9对象序列化
10.9.1寻找类
10.9.2序列化的控制
10.9.3利用“持久性”
10.10 总结
10.11练习
第11章 运行期类型鉴定
11.1对RTTI的需要
11.1.1Class对象
11.1.2造型前的检查
11.2RTTI语法
11.3反射：运行期类信息
11.4总结
11.5练习
第12章 传递和返回对象
12.1传递句柄
12.2制作本地副本
12.2.1按值传递
12.2.2克隆对象
12.2.3使类具有克隆能力
12.2.4成功的克隆
12.2.5Object.clone（）的效果
12.2.6克隆合成对象
12.2.7用Vector进行深层复制
12.2.8通过序列化进行深层复制
12.2.9使克隆具有更大的深度
12.2.10为什么有这个奇怪的设计
12.3克隆的控制
12.4只读类
12.4.1创建只读类
12.4.2“一成不变”的弊端
12.4.3不变字串
12.4.4String和String Buffer类
12.4.5字串的特殊性
12.5总结
12.6练习
第13章 创建窗口和程序片
13.1为何要用AWT？
13.2基本程序片
13.2.1程序片的测试
13.2.2一个更图形化的例子
13.2.3框架方法的演示
13.3制作按钮
13.4捕获事件
13.5文本字段
13.6文本区域
13.7标签
13.8复选框
13.9单选钮
13.10下拉列表
13.11列表框
13.12布局的控制
13.12.1FlowLayout
13.12.2BorderLayout
13.12.3GridLayout
13.12.4CardLayout
13.12.5GridBagLayout
13.13action的替代品
13.14程序片的局限
13.15视窗化应用
13.15.1菜单
13.15.2对话框
13.16新型AWT
13.16.1新的事件模型
13.16.2事件和接收者类型
13.16.3用Java1.1AWT制作窗口和程序片
13.16.4再研究一下以前的例子
13.16.5动态绑定事件
13.16.6将事务逻辑与UI逻辑区分开
13.16.7推荐编码方法
13.17Java1.1用户接口API
13.17.1桌面颜色
13.17.2打印
13.17.3剪贴板
13.18可视编程和Beans
13.18.1什么是Bean？
13.18.2用Introspector提取BeanInfo
13.18.3一个更复杂的Bean
13.18.4Bean的封装
13.18.5更复杂的Bean支持
13.18.6Bean更多的知识
13.19Swing入门
13.19.1Swing有哪些优点
13.19.2方便的转换
13.19.3功能框架
13.19.4功能提示
13.19.5边框
13.19.6按钮
13.19.7按钮组
13.19.8图标
13.19.9菜单
13.19.10弹出式菜单
13.19.11列表框和组合框
13.19.12滑块和进程条
13.19.13树
13.19.14表格
13.19.15卡片式对话框
13.19.16Swing消息框
13.19.17Swing更多的知识
13.20 总结
13.21 练习
第14章 多线程
14.1反应灵敏的用户界面
14.1.1从线程继承
14.1.2针对用户界面的多线程
14.1.3用主类合并线程
14.1.4制作多个线程
14.1.5Daemon线程
14.2共享有限的资源
14.2.1资源访问的错误方法
14.2.2Java如何共享资源
14.2.3回顾JavaBeans
14.3堵塞
14.3.1为何会堵塞
14.3.2死锁
14.4优先级
14.5回顾runnable
14.6总结
14.7练习
第15章 网络编程
15.1机器的标识
15.1.1服务器和客户机
15.1.2端口：机器内独一无二的场所
15.2套接字
15.3服务多个客户
15.4数据报
15.5一个Web应用
15.5.1服务器应用
15.5.2NameSender程序片
15.5.3要注意的问题
15.6Java与CGI的沟通
15.6.1CGI数据的编码
15.6.2程序片
15.6.3用C＋＋写的CGI程序
15.6.4POST的概念
15.7用JDBC连接数据库
15.7.1让示例运行起来
15.7.2查找程序的GUI版本
15.7.3JDBCAPI为何如此复杂
15.8远程方法
15.8.1远程接口概念
15.8.2远程接口的实施
15.8.3创建根与干
15.8.4使用远程对象
15.8.5RMI的替选方案
15.9总结
15.10练习
第16章 设计范式
16.1范式的概念
16.1.1单子
16.1.2范式分类
16.2观察器范式
16.3模拟垃圾回收站
16.4改进设计
16.4.1“制作更多的对象”
16.4.2用于原型创建的一个范式
16.5抽象的应用
16.6多重派遣
16.7访问器范式
16.8RTTI真的有害吗？
16.9总结
16.10练习
第17章 项目
17.1文字处理
17.1.1提取代码列表
17.1.2检查大小写样式
17.2方法查找工具
17.3复杂性理论
17.4总结
17.5练习
附录A 使用非Java代码
附录B C＋＋和Java的对比
附录CJava编程规则
附录D 性能
附录E 关于垃圾收集的一些话
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java编程思想
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web开发实战经典（基础篇）
第1部分Web开发前奏
第1章Java Web开发简介 2
1.1Web发展历程 2
1.2企业开发架构 6
1.3Java EE架构 7
1.4Java EE核心设计模式 10
1.5Struts开发框架 11
1.6本章摘要 12
第2章HTML、JavaScript简介 13
视频讲解：1小时45分钟
2.1服务器与浏览器 13
2.2HTML简介 14
2.2.1HTML元素概览 14
2.2.2创建显示Web页 16
2.2.3创建表单Web页 19
2.3JavaScript简介 21
2.3.1JavaScript的基本语法 21
2.3.2事件处理 29
2.3.3window对象 35
2.4本章摘要 40
.2.5开发实战练习 40
第3章XML简介 41
视频讲解：2小时16分钟
3.1认识XML 41
3.2XML解析 48
3.2.1DOM解析操作 48
3.2.2SAX解析操作 57
3.2.3XML解析的好帮手：JDOM 60
3.2.4最出色的解析工具：DOM4J 64
3.3使用JavaScript操作DOM 67
3.4本章摘要 72
3.5开发实战练习（基于Oracle
数据库） 73
第4章Tomcat服务器的安装及配置 75
视频讲解：1小时04分钟
4.1Web容器简介 75
4.2Tomcat简介 76
4.3Tomcat服务器的下载及配置 77
4.3.1Tomcat下载 77
4.3.2Tomcat安装 77
4.3.3服务器配置 80
4.4编写第一个JSP文件 84
4.5交互性 87
4.6本章摘要 88
第2部分Web基础开发
第5章JSP基础语法 90
视频讲解：2小时11分钟
5.1JSP注释 90
5.2Scriptlet 91
5.2.1第一种Scriptlet：(%%) 91
5.2.2第二种Scriptlet：(%!%) 92
5.2.3第三种Scriptlet：(%=%) 93
5.3scriptlet标签 97
5.4page指令 97
5.4.1设置页面的MIME 98
5.4.2设置文件编码 102
5.4.3错误页的设置 103
5.4.4数据库连接操作 105
5.5包含指令 109
5.5.1静态包含 109
5.5.2动态包含 111
5.6跳转指令 115
5.7实例操作：用户登录程序
实现 （JSP+JDBC实现） 116
5.7.1创建数据库表 117
5.7.2程序实现思路 117
5.7.3程序实现 118
5.8本章摘要 121
5.9开发实战练习（基于Oracle
数据库） 122
第6章JSP内置对象 123
视频讲解：3小时42分钟
6.1JSP内置对象概览 123
6.24种属性范围 124
6.2.1page属性范围（pageContext） 125
6.2.2request属性范围 127
6.2.3session属性范围 129
6.2.4application属性范围 131
6.2.5深入研究page属性范围 133
6.3request对象 134
6.3.1乱码解决 135
6.3.2接收请求参数 137
6.3.3显示全部的头信息 143
6.3.4角色验证 144
6.3.5其他操作 146
6.4response对象 147
6.4.1设置头信息 148
6.4.2页面跳转 150
6.4.3操作Cookie 152
6.5session对象 156
6.5.1取得Session Id 157
6.5.2登录及注销 159
6.5.3判断新用户 162
6.5.4取得用户的操作时间 163
6.6application对象 164
6.6.1取得虚拟目录对应的绝对路径 164
6.6.2范例讲解：网站计数器 167
6.6.3查看application范围的属性 169
6.7Web安全性及config对象 170
6.7.1Web安全性 170
6.7.2config对象 172
6.8out对象 173
6.9pageContext对象 174
6.10本章摘要 176
6.11开发实战练习（基于Oracle数据库） 177
第7章JavaBean 184
视频讲解：2小时11分钟
7.1JavaBean简介 184
7.2在JSP中使用JavaBean 186
7.2.1Web开发的标准目录结构 186
7.2.2使用JSP的page指令导入所需要的JavaBean 187
7.2.3使用(jsp:useBean)指令 188
7.3JavaBean与表单 190
7.4设置属性：(jsp:setProperty) 192
7.4.1设置指定的属性 193
7.4.2指定设置属性的参数 194
7.4.3为属性设置具体内容 194
7.5取得属性：(jsp:getProperty) 195
7.6JavaBean的保存范围 196
7.6.1page范围的JavaBean 196
7.6.2request范围的JavaBean 197
7.6.3session范围的JavaBean 198
7.6.4application范围的JavaBean 199
7.7JavaBean的删除 199
7.8实例操作：注册验证 200
7.9DAO设计模式 204
7.9.1DAO设计模式简介 204
7.9.2DAO开发 206
7.9.3JSP调用DAO 216
7.10本章摘要 219
7.11开发实战练习（基于Oracle数据库） 220
第8章文件上传 225
视频讲解：1小时30分钟
8.1SmartUpload上传组件 225
8.1.1上传单个文件 226
8.1.2混合表单 227
8.1.3为上传文件自动命名 228
8.1.4批量上传 231
8.2FileUpload 232
8.2.1使用FileUpload接收上传内容 234
8.2.2保存上传内容 237
8.2.3开发FileUpload组件的专属操作类 239
8.3本章摘要 244
8.4开发实战练习（基于Oracle数据库） 245
第3部分Web高级开发
第9章Servlet程序开发 250
视频讲解：4小时08分钟
9.1Servlet简介 250
9.2永远的“HelloWorld”：第一个Servlet程序 251
9.3Servlet与表单 255
9.4Servlet生命周期 257
9.5取得初始化配置信息 261
9.6取得其他内置对象 262
9.6.1取得HttpSession实例 262
9.6.2取得ServletContext实例 263
9.7Servlet跳转 265
9.7.1客户端跳转 265
9.7.2服务器端跳转 266
9.8Web开发模式：Mode I与Mode II 268
9.8.1Mode I 268
9.8.2Mode II：Model-View-Controller 269
9.9实例操作：MVC设计模式应用 271
9.10过滤器 279
9.10.1过滤器的基本概念 279
9.10.2实现过滤器 280
9.10.3过滤器的应用 283
9.11监听器 285
9.11.1对application监听 286
9.11.2对session监听 289
9.11.3对request监听 294
9.11.4监听器实例——在线人员统计 297
9.12本章摘要 300
9.13开发实战练习（基于Oracle数据库） 300
第10章表达式语言 307
视频讲解：1小时07分钟
10.1表达式语言简介 307
10.2表达式语言的内置对象 308
10.2.1访问4种属性范围的内容 309
10.2.2调用内置对象操作 310
10.2.3接收请求参数 311
10.3集合操作 313
10.4在MVC中应用表达式语言 315
10.5运算符 320
10.6本章摘要 324
10.7开发实战练习（基于Oracle数据库） 324
第11章Tomcat数据源 328
视频讲解：23分钟
11.1数据源操作原理 328
11.2在Tomcat中使用数据库连接池 329
11.3查找数据源 331
11.4本章摘要 333
第12章JSP标签编程 334
视频讲解：2小时04分钟
12.1标签编程简介 334
12.2定义一个简单的标签——空标签 335
12.3定义有属性的标签 338
12.4TagSupport类 341
12.5定义有标签体的标签库 344
12.6开发迭代标签 347
12.7BodyTagSupport类 350
12.8TagExtraInfo类和VariableInfo类 352
12.9使用BodyTagSupport开发迭代输出 354
12.10简单标签 357
12.11DynamicAttributes接口 363
12.12本章摘要 365
第13章JSP标准标签库 366
视频讲解：2小时04分钟
13.1JSTL简介 366
13.2安装JSTL 1.2 367
13.3核心标签库 369
13.3.1(c:out)标签 370
13.3.2(c:set)标签 371
13.3.3(c:remove)标签 373
13.3.4(c:catch)标签 374
13.3.5(c:if)标签 375
13.3.6(c:choose)、(c:when)、
(c:otherwise)标签 376
13.3.7(c:forEach)标签 378
13.3.8(c:forTokens)标签 381
13.3.9(c:import)标签 382
13.3.10(c:url)标签 383
13.3.11(c:redirect)标签 384
13.4国际化标签库 385
13.4.1(fmt:setLocale)标签 386
13.4.2(fmt:requestEncoding)标签 387
13.4.3读取资源文件 388
13.4.4数字格式化标签 391
13.4.5日期时间格式化标签 394
13.4.6设置时区 397
13.5SQL标签库 398
13.5.1(sql:setDataSource)标签 398
13.5.2数据库操作标签 399
13.5.3事务处理 404
13.6XML标签库 405
13.6.1XPath简介 406
13.6.2(x:parse)标签 407
13.6.3(x:out)标签 407
13.6.4(x:set)标签 408
13.6.5(x:if)标签 409
13.6.6(x:choose)、(x:when)、(x:otherwise)标签 410
13.6.7(x:forEach)标签 412
13.7函数标签库 413
13.8本章摘要 415
13.9开发实战练习（基于Oracle数据库） 415
第14章Ajax开发技术 417
视频讲解：1小时21分钟
14.1Ajax技术简介 417
14.2XMLHttpRequest对象 418
14.3第一个Ajax程序 420
14.4异步验证 421
14.5返回XML数据 425
14.6本章摘要 427
14.7开发实战练习（基于Oracle数据库） 428
第4部分框架开发
第15章Struts基础开发 436
视频讲解：42分钟
15.1Struts简介 436
15.2配置Struts开发环境 437
15.3开发第一个Struts程序 441
15.4Struts工作原理 446
15.5深入Struts应用 447
15.6本章摘要 450
15.7开发实战练习（基于Oracle
数据库） 451
第16章Struts常用标签库 453
视频讲解：1小时26分钟
16.1Struts标签库简介 453
16.2Bean标签 454
16.2.1(bean:define)标签 454
16.2.2(bean:size)标签 456
16.2.3资源访问标签 457
16.2.4(bean:write)标签 460
16.2.5(bean:include)标签 461
16.2.6(bean:resource)标签 462
16.2.7国际化与(bean:message)标签 463
16.3Logic标签 465
16.3.1(logic:present)和
(logic:notPresent)标签 466
16.3.2(logic:empty)和
(logic:notEmpty)标签 467
16.3.3关系运算标签 468
16.3.4(logic:iterate)标签 470
16.3.5重定向标签：(logic:redirect) 472
16.4Html标签 474
16.4.1(html:form)标签 474
16.4.2(html:text)与
(html:password)标签 475
16.4.3(html:radio)标签 476
16.4.4(html:textarea)标签 476
16.4.5(html:hidden)标签 477
16.4.6按钮标签 477
16.4.7实例：编写基本表单 477
16.4.8复选框标签 480
16.4.9下拉列表框 484
16.5本章摘要 487
16.6开发实战练习（基于Oracle数据库） 487
第17章Struts高级开发 489
视频讲解：1小时32分钟
17.1Struts多人开发 489
17.2Token 490
17.3文件上传 495
17.4动态ActionForm 498
17.5Action深入 500
17.5.1ForwardAction 500
17.5.2IncludeAction 502
17.5.3DispatchAction 502
17.6验证框架 504
17.7本章摘要 510
17.8开发实战练习（基于Oracle数据库） 510
第5部分附录
附录A实用工具 524
视频讲解：1小时09分钟
A.1JavaMail 524
A.1.1James邮件服务器的下载及配置 524
A.1.2JavaMail简介及配置 529
A.1.3发送普通邮件 531
A.1.4发送带附件的HTML风格邮件 535
A.2操作Excel文件 538
A.2.1JExcelAPI简介 538
A.2.2创建一个Excel文件 540
A.2.3读取Excel文件 541
A.2.4格式化文本 542
A.3本章摘要 544
附录BMyEclipse开发工具 545
视频讲解：15分钟
B.1MyEclipse简介 545
B.2MyEclipse的安装 546
B.3MyEclipse的使用 546
B.4配置Tomcat服务器 549
B.5MyEclipse卸载 552
B.6本章摘要 552
附录CHTTP状态码及头信息 553
C.1HTTP状态码 553
C.2HTTP头信息 554
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web开发实战经典（基础篇）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>网络机器人Java编程指南
第1章
Java套接字编程技术
套接字家族
网络编程
Java I/O编程技术
代理的问题
Java中的套接字编程
客户端套接字

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>网络机器人Java编程指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java就业培训教程
第1章 Java开发前奏
1.1 Java虚拟机及Java的跨平台原理
1.2 Java开发环境的搭建
1.3 体验Java编程的过程
1.4 classpath的设置
1.5 有效利用Java的文档帮助
1.6 JVM（虚拟机）的运行过程
1.7 垃圾回收器
1.8 反编译工具的介绍
第2章 Java编程基础
2.1 Java基本语法格式
2.2 变量及变量的作用域
2.3 函数与函数的重载
2.4 Java中的运算符
2.5 程序的流程控制
2.6 数组
第3章 面向对象（上）
3.1 面向对象的概念
3.2 类与对象
3.3 构造函数
3.4 this引用句柄
3.5 与垃圾回收有关的知识
3.6 函数的参数传递
3.7 Static关键字
3.8 内部类
3.9 使用Java的文档注释
第4章 面向对象（下）
4.1 类的继承
4.2 抽象类与接口
4.3 对象的多态性
4.4 异常
4.5 包
4.6 访问控制
4.7 使用jar文件
第5章 多线程
5.1 如何创建与理解线程
5.2 多线程的同步
5.3 线程间的通信
5.4 线程生命的控制
第6章 Java API
6.1 理解API的概念
6.2 工具软件的介绍与使用
6.3 String类和StringBuffer类
6.4 基本数据类型的对象包装类
6.5 集合类
6.6 Hashtable与Properties类
6.7 System类与Runtime类
6.8 Date与Calendar，DateFormat类
6.9 Math与Random类
6.10 学习API的方法
第7章 IO/输入输出
7.1 File类
7.2 RandomAccessFile类
7.3 节点流
7.4 过滤流与包装类
7.5 IO中的高级应用
第8章 图形用户界面GUI（一）
8.1 初识AWT
8.2 AWT线程
8.3 AWT事件处理
8.4 GUI组件上的图形操作
第9章 图形用户界面GUI（二）
9.1 常用AWT组件
9.2 布局管理器
9.3 Swing
第10章 Applet
10.1 浏览器怎样显示网页
10.2 浏览器处理网页脚本代码的过程
10.3 浏览器怎么处理Applet
10.4 Applet类及其方法
10.5 一个显示动画的Applet的程序
10.6 关于Java的一些细节
10.7 验证Applet对象在客户端如何存在
第11章 网络编程
11.1 网络编程的基础知识
11.2 Java编写UDP网络程序
11.3 Java编写TCP网络程序
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java就业培训教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>现代编译器的Java实现(第2版)
第一部分 编译基础
第1章 概述
第2章 词法分析
第3章 语法分析
第4章 抽象语法
第5章 语义分析
第6章 活动纪录
第7章 翻译成中间代码
第8章 基本块和轨迹
第9章 指令选择
第10章 活性分析
第11章 寄存器分配
第12章 使之成为整体
第二部分 高级课题
……
附录 MiniJava语言参考手册
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>现代编译器的Java实现(第2版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java应用架构设计
本书赞誉
译者序
序
序
前言
第一部分 模块化的理由
第1章 模块定义
1.1 定义模块
1.1.1 可部署
1.1.2 可管理
1.1.3 可测试
1.1.4 原生可重用
1.1.5 可组合
1.1.6 无状态
1.2 软件模块的简洁定义
1.3 结论
第2章 模块化的两个方面
2.1 运行时模型
2.2 开发模型
2.2.1 编程模型
2.2.2 设计范式
2.3 模块化现状
2.4 结论
第3章 架构与模块化
3.1 定义架构
3.2 关于软件架构的一个故事
3.2.1 象牙塔
3.2.2 乌龟和塔
3.3 架构的目标
3.3.1 悖论
3.3.2 消除架构
3.4 模块化：被忽视的部分
3.5 回答我们的问题
3.6 结论
3.7 参考文献
第4章 征服复杂性
4.1 企业级复杂性
4.2 技术债
4.3 设计腐化
4.3.1 干扰可维护性
4.3.2 阻止可扩展性
4.3.3 抑制可重用性
4.3.4 限制可测试性
4.3.5 妨碍集成
4.3.6 阻碍理解
4.4 循环依赖
4.4.1 循环类型
4.4.2 悄然引入的循环
4.4.3 管理循环
4.4.4 循环总是不好的吗
4.5 结合点、模块和SOLID
4.6 管理复杂性
4.7 模块化的益处
4.8 结论
4.9 参考文献
第5章 实现重用
5.1 可用重用悖论
5.2 关于重用的免责声明
5.2.1 粒度
5.2.2 重量级
5.3 重用还是可用
5.4 模块化权衡
5.5 模块化设计
5.6 结论
5.7 参考文献
第6章 模块化与SOA
6.1 重新审视“自上而下”
6.2 粒度——架构师的强大对手
6.2.1 现实世界的一个例子
6.2.2 提升一个等级
6.2.3 另一个维度
6.2.4 全景图
6.2.5 服务样例
6.3 另一个视图
6.4 结论
第7章 参考实现
7.1 为什么不用OSGi
7.2 这个练习的背景：构建系统
7.3 初始版本
7.4 第一次重构
7.5 第二次重构
7.6 第三次重构
7.7 第四次重构
7.7.1 关于OSGi的好处
7.7.2 小结并准备下一次重构
7.8 第五次重构
7.9 第六次重构
7.10 第七次重构
7.11 事后剖析
7.11.1 关于模块测试
7.11.2 关于管理模块依赖
7.11.3 关于模块重用
7.11.4 关于构建
7.11.5 关于面向对象
7.12 结论
7.13 参考文献
第二部分 模 式
第8章 基本模式
8.1 管理关系
8.1.1 表述
8.1.2 描述
8.1.3 多种实现
8.1.4 影响
8.1.5 样例
8.1.6 小结
8.2 模块重用
8.2.1 表述
8.2.2 描述
8.2.3 多种实现
8.2.4 效果
8.2.5 样例
8.2.6 小结
8.3 模块内聚
8.3.1 表述
8.3.2 描述
8.3.3 多种实现
8.3.4 效果
8.3.5 样例
8.3.6 小结
第9章 依赖模式
9.1 非循环关系
9.1.1 表述
9.1.2 描述
9.1.3 多种实现
9.1.4 效果
9.1.5 样例
9.1.6 小结
9.2 等级化模块
9.2.1 表述
9.2.2 描述
9.2.3 多种实现
9.2.4 效果
9.2.5 样例
9.2.6 小结
9.3 物理分层
9.3.1 表述
9.3.2 描述
9.3.3 多种实现
9.3.4 效果
9.3.5 样例
9.3.6 小结
9.4 容器独立
9.4.1 表述
9.4.2 描述
9.4.3 多种实现
9.4.4 效果
9.4.5 样例
9.4.6 小结
9.5 独立部署
9.5.1 表述
9.5.2 描述
9.5.3 多种实现
9.5.4 效果
9.5.5 样例
9.5.6 小结
9.6 参考文献
第10章 可用性模式
10.1 发布接口
10.1.1 表述
10.1.2 描述
10.1.3 多种实现
10.1.4 效果
10.1.5 样例
10.1.6 小结
10.2 外部配置
10.2.1 表述
10.2.2 描述
10.2.3 多种实现
10.2.4 效果
10.2.5 样例
10.2.6 小结
10.3 默认实现
10.3.1 表述
10.3.2 描述
10.3.3 多种实现
10.3.4 效果
10.3.5 样例
10.3.6 小结
10.4 模块门面
10.4.1 表述
10.4.2 描述
10.4.3 多种实现
10.4.4 效果
10.4.5 样例
10.4.6 小结
第11章 扩展性模式
11.1 抽象化模块
11.1.1 表述
11.1.2 描述
11.1.3 多种实现
11.1.4 效果
11.1.5 样例
11.1.6 小结
11.2 实现工厂
11.2.1 表述
11.2.2 描述
11.2.3 多种实现
11.2.4 效果
11.2.5 样例
11.2.6 小结
11.3 分离抽象
11.3.1 表述
11.3.2 描述
11.3.3 多种实现
11.3.4 效果
11.3.5 样例
11.3.6 小结
11.4 参考文献
第12章 通用模式
12.1 就近异常
12.1.1 表述
12.1.2 描述
12.1.3 多种实现
12.1.4 效果
12.1.5 样例
12.1.6 小结
12.2 等级化构建
12.2.1 表述
12.2.2 描述
12.2.3 多种实现
12.2.4 效果
12.2.5 样例
12.2.6 小结
12.3 测试模块
12.3.1 表述
12.3.2 描述
12.3.3 多种实现
12.3.4 效果
12.3.5 样例
12.3.6 小结  201
第三部分 模块化架构模式与OSGi
第13章 OSGi简介
13.1 一点历史
13.2 OSGi所能带来的收益
13.2.1 模块化开发
13.2.2 管理依赖
13.2.3 模块平台
13.2.4 版本化的bundle
13.2.5 动态（重）部署
13.2.6 环境相关的控制
13.3 深入理解OSGi
13.4 OSGi bundle
13.4.1 bundle状态
13.4.2 OSGi Service
13.5 OSGi运行时管理
13.6 重新查看模块化的两个方面
13.7 OSGi与模式
13.7.1 管理依赖
13.7.2 动态性
13.7.3 Blueprint规范
第14章 贷款样例与OSGi
14.1 起步
14.2 清单文件
14.3 Service
14.3.1 Blueprint服务
14.3.2 贷款样例配置
14.3.3 OSGi Service声明
14.4 安装与执行
14.5 结论
第15章 OSGi与Scala
15.1 起步
15.2 Scala代码
15.3 Scala bean配置
15.4 Scala Service配置
15.5 构建Scala模块
15.6 安装与执行
15.7 结论
第16章 OSGi与Groovy
16.1 起步
16.2 Groovy代码
16.3 Groovy bean配置
16.4 Groovy Service配置
16.5 构建Groovy模块
16.6 安装与执行
16.7 结论
第17章 OSGi的未来
17.1 将OSGi作为推动者
17.2 颠覆性
17.3 生态系统的威力
17.3.1 生态系统与模块化的两个方面
17.3.2 基于组件的开发（CBD）不是已经成功了吗
17.4 生态系统
17.5 结论
附录A 类设计的SOLID原则
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java应用架构设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java开发超级工具集
第一部分 构建工具
第1章 使用Ant设置项目
1.1 构建过程中的Ant
1.2 安装Ant
1.3 Ant概述
1.4 在Ant中编译Java代码
1.5 使用属性自定义构建脚本
1.6 在Ant中运行单元测试
1.7 用Javadoc生成文档
1.8 将应用程序打包
1.9 部署应用程序
1.10 引导构建脚本
1.11 用Maven任务在Ant中使用Maven依赖
1.12 在Eclipse中使用Ant
1.13 在NetBeans中使用Ant
1.14 用XMLTask操作XML
1.15 小结
第2章 使用Maven 2设置项目
2.1 Maven和开发构建过程
2.2 Maven和Ant
2.3 安装Maven
2.4 声明式构建和Maven项目对象模型
2.5 理解Maven 2的生命周期
2.6 Maven目录结构
2.7 根据环境配置Maven
2.8 Maven 2中的依赖管理
2.9 用MvnRepository查找依赖
2.10 项目继承和聚合（Aggregation）
2.11 使用原型（Archetype）创建项目模板
2.12 编译代码
2.13 测试代码
2.14 打包和部署应用程序
2.15 使用Cargo部署应用程序
2.16 在Eclipse中使用Maven
2.17 在NetBeans中使用Maven
2.18 使用插件定制构建过程
2.19 用Archiva设置企业存储库
2.20 使用Artifactory设置企业存储库
2.21 在Maven中使用Ant
2.22 高级原型
2.23 使用组件（Assembly）
第二部分 版本控制工具
第3章 使用CVS设置版本控制
3.1 CVS概述
3.2 设置CVS仓库
3.3 在CVS中创建新项目
3.4 检出项目
3.5 处理文件－－更新和提交
3.6 解决仓库锁定问题
3.7 使用关键字替换
3.8 处理二进制文件
3.9 CVS标记
3.10 在CVS中创建分支
3.11 从分支中合并更改
3.12 查看更改历史
3.13 还原更改
3.14 在Windows中使用CVS
第4章 用Subversion设置版本控制
4.1 Subversion概述
4.2 安装Subversion
4.3 Subversion仓库类型
4.4 设置Subversion仓库
4.5 设置新的Subversion项目
4.6 检出工作副本
4.7 将现有文件导入到Subversion
4.8 理解Subversion仓库的URL
4.9 使用文件
4.10 查看当前状态：Status命令
4.11 解决冲突
4.12 使用标记、分支和合并
4.13 回滚到以前的修订版本
4.14 对二进制文件使用文件锁定
4.15 打破和窃取锁定
4.16 用svn：needs-lock属性使锁定文件成为只读
4.17 使用属性
4.18 Subversion中的更改历史记录：日志和Blaming
4.19 用svnserve设置Subversion服务器
4.20 设置安全的svnserve服务器
4.21 设置支持WebDAV/DeltaV的Subversion服务器
4.22 设置安全的WebDAV/DeltaV服务器
4.23 用钩子脚本定制Subversion
4.24 将Subversion安装为Windows服务
4.25 备份和还原Subversion仓库
4.26 在Eclipse中使用Subversion
4.27 在NetBeans中使用Subversion
4.28 在Windows中使用Subversion
4.29 缺陷跟踪和变更控制
4.30 在Ant中使用Subversion
4.31 小结
第三部分 持续集成
第5章 用Continuum设置持续集成服务器
5.1 Continuum概述
5.2 安装Continuum服务器
5.3 手工启动和停止服务器
5.4 检查服务器状态
5.5 以Verbose模式运行Continuum服务器
5.6 添加项目组
5.7 添加Maven项目
5.8 添加Ant项目
5.9 添加外壳脚本项目
5.10 管理项目构建
5.11 管理用户
5.12 设置通知方法（Notifier）
5.13 配置和制订构建计划
5.14 调试构建
5.15 配置Continuum邮件服务器
5.16 配置Continuum网站端口
5.17 用Continuum自动生成Maven网站
5.18 配置手工构建任务
5.19 小结
第6章 用CruiseControl设置持续集成服务器
6.1 CruiseControl概述
6.2 安装CruiseControl
6.3 配置Ant项目
6.4 用Publisher（发布器）通知开发人员
6.5 在CruiseControl中设置Maven 2项目
6.6 CruiseControl操作面板
6.7 第三方工具
6.8 小结
第7章 LuntBuild－－基于Web的持续集成服务器
7.1 LuntBuild概述
7.2 安装LuntBuild
7.3 配置LuntBuild服务器
7.4 添加项目
7.5 为版本编号使用项目变量
7.6 构建结果诊断
7.7 与Eclipse一起使用LuntBuild
7.8 在Luntbuild中使用Cobertura报告测试覆盖
7.9 将Luntbuild与Maven集成
7.10 小结
第8章 使用Hudson进行持续集成
8.1 Hudson概述
8.2 安装Hudson
8.3 管理Hudson的主目录
8.4 安装升级
8.5 配置Hudson
8.6 添加新构建任务
8.7 组织任务
8.8 监控构建
8.9 查看和提升特定构建
8.10 管理用户
8.11 认证与安全
8.12 查看更改
8.13 Hudson插件
8.14 记录测试结果
8.15 记录代码度量
8.16 报告代码覆盖
第9章 用Openfire设置即时消息平台
9.1 开发项目中的即时消息软件
9.2 安装Openfire
9.3 在Openfire上设置用户账户
9.4 认证外部数据库中的用户
9.5 针对POP3服务器认证用户
9.6 用群聊天召开虚拟团队会议
9.7 用Openfire插件扩展功能
9.8 与Continuum一起使用Openfire
9.9 与CruiseControl一起使用Openfire
9.10 与Luntbuild一起使用Openfire
9.11 使用Smack API从Java应用程序中发送Jabber消息
9.12 用Smack API检测用户是否在线
9.13 使用Smack API接收消息
第四部分 单元测试
第10章 用JUnit测试代码
10.1 JUnit 3.8和JUnit 4
10.2 用JUnit 4进行单元测试
10.3 设置和优化单元测试用例
10.4 用Timeout进行简单的性能测试
10.5 轻松地检查异常
10.6 使用带参数的测试
10.7 使用assertThat和Hamcrest库
10.8 JUnit 4的理论机制
10.9 与Maven 2一起使用JUnit 4
10.10 与Ant一起使用JUnit 4
10.11 在Ant中有选择地运行JUnit 4测试
10.12 集成测试
10.13 在Eclipse中使用JUnit 4
第11章 用TestNG进行下一代测试
11.1 TestNG概述
11.2 用TestNG创建简单单元测试
11.3 定义TestNG测试套件
11.4 Eclipse的TestNG插件
11.5 在Ant中使用TestNG
11.6 与Maven 2一起使用TestNG
11.7 管理测试生命周期
11.8 使用测试组
11.9 管理依赖
11.10 并行测试
11.11 测试参数和数据驱动的测试
11.12 检查异常
11.13 处理部分失败
11.14 重新运行失败的测试
第12章 用Cobertura 最大化测试覆盖
12.1 测试覆盖
12.2 从Ant中运行Cobertura
12.3 检查TestNG测试的代码覆盖
12.4 理解Cobertura报告
12.5 实施高水平代码覆盖
12.6 在Maven中生成Cobertura报告
12.7 将覆盖测试集成到Maven构建过程中
12.8 Eclipse中的代码覆盖
12.9 小结
第五部分 集成、功能、负载和性能测试
第13章 用StrutsTestCase测试Struts应用程序
13.1 概述
13.2 测试Struts应用程序
13.3 StrutsTestCase概述
13.4 使用StrutsTestCase 进行模拟测试
13.5 测试Struts错误处理
13.6 定制测试环境
13.7 一级（First-level）性能测试
13.8 小结
第14章 用DbUnit进行数据库集成测试
14.1 引言
14.2 概述
14.3 DbUnit的结构
14.4 示例应用程序
14.5 准备数据库
14.6 验证数据库
14.7 替换值
14.8 其他数据集格式
14.9 处理自定义数据类型
14.10 其他应用
第15章 用JUnitPerf进行性能测试
15.1 JUnitPerf概述
15.2 用TimedTest测量性能
15.3 用LoadTest模拟负载
15.4 对非线程安全的测试进行负载测试
15.5 在Ant中分离性能测试和单元测试
15.6 在Maven中分离性能测试和单元测试
第16章 用JMeter进行负载和性能测试
16.1 概述
16.2 安装JMeter
16.3 测试简单的web应用程序
16.4 组织测试用例
16.5 记录和显示测试结果
16.6 使用JMeter代理服务器记录测试用例
16.7 使用变量进行测试
16.8 在多台计算机上进行测试
第17章 用SoapUI测试Web服务
17.1 概述
17.1 SoapUI概述
17.2 安装SoapUI
17.3 安装本地web服务
17.4 用SoapUI测试web服务
17.5 用SoapUI进行负载测试
17.6 从命令行运行SoapUI
17.7 从Ant中运行SoapUI
17.8 从Maven中运行SoapUI
17.9 持续测试
17.10 小结
第18章 用Sun JDK工具监视和分析Java应用程序的性能
18.1 Sun JDK性能分析和监视工具
18.2 用jConsole连接并监视Java应用程序
18.3 用jConsole监视远程Tomcat应用程序
18.4 用JDK工具检测和识别内存泄露
18.5 用堆转储、jmap和jhat诊断内存泄露
18.6 检测死锁
第19章 在Eclipse中分析Java应用程序的性能
19.1 在集成开发环境中分析应用程序的性能
19.2 Eclipse测试和性能工具平台
19.3 安装TPTP
19.4 TPTP和Java 6
19.5 使用TPTP进行基本性能分析
19.6 用基本内存分析结果分析内存使用
19.7 分析执行时间
19.8 显示代码覆盖统计
19.9 使用过滤器优化结果
19.10 分析web应用程序的性能
19.11 小结
第20章 测试用户界面
20.1 概述
20.2 用Selenium测试web应用程序
20.3 用FEST测试Swing图形用户界面
20.4 小结
第六部分 质量度量工具
第21章 用Checkstyle检测和实施编码标准
21.1 用Checkstyle实施编码标准
21.2 在Eclipse中使用Checkstyle
21.3 在Eclipse中定制Checkstyle规则
21.4 使用XML配置文件定制Checkstyle规则
21.5 定制Checkstyle：可以舍弃和使用的常见规则
21.6 用Checkstyle定义源代码文件头规则
21.7 禁用Checkstyle测试
21.8 与Ant一起使用Checkstyle
21.9 与Maven一起使用Checkstyle
第22章 用PMD预先检测错误
22.1 PMD和静态代码分析
22.2 在Eclipse中使用PMD
22.3 在Eclipse中配置PMD规则
22.4 PMD规则集
22.5 编写自己的PMD规则集
22.6 在Eclipse中生成PMD报告
22.7 禁用PMD规则
22.8 用CPD检测剪切和粘贴
22.9 在Ant中使用PMD
22.10 在Maven中使用PMD
第23章 用FindBugs预先检测错误
23.1 FindBugs：专业的程序错误检测工具
23.2 在Eclipse中使用FindBugs
23.3 用FindBugs过滤器有选择地禁用规则
23.4 使用FindBugs注释
23.5 在Ant中使用FindBugs
23.6 在Maven中使用FindBugs
23.7 小结
第24章 检查结果－－用Jupiter进行半自动化代码评审
24.1 Jupiter概述－－用于Eclipse的代码评审工具
24.2 在Eclipse中安装Jupiter
24.3 理解Jupiter的代码评审流程
24.4 进行个人代码审查
24.5 配置
24.6 设置默认配置值
24.7 单独评审
24.8 团队评审
24.9 返工阶段
24.10 Jupiter的后台处理
24.11 小结
第25章 用Mylyn突出工作重点
25.1 Mylyn概述
25.2 安装Mylyn
25.3 跟踪任务和问题
25.4 与任务仓库进行交互
25.5 用上下文管理将工作重点集中在任务上
25.6 使用Eclipse更改集
25.7 与其他开发人员共享上下文
25.8 小结
第26章 监视构建统计信息
26.1 概述
26.2 QALab
26.3 用StatSCM度量源代码管理
26.4 在Ant中用StatSVN提供统计信息
第七部分 问题管理工具
第27章 Bugzilla
27.1 Bugzilla概述
27.2 安装Bugzilla
27.3 设置Bugzilla环境
27.4 管理用户账户
27.5 使用用户组来限制访问
27.6 配置产品
27.7 用里程碑跟踪进度
27.8 用分类管理产品组
27.9 搜索程序错误
27.10 创建新程序错误
27.11 Bugzilla程序错误的生命周期
27.12 安排通知（Whining）
27.13 在Bugzilla中定制字段
27.14 小结
第28章 Trac－轻量级项目管理
28.1 Trac概述
28.2 安装Trac
28.3 设置Trac项目
28.4 在独立服务器上运行Trac
28.5 将Tracd设置为Windows服务
28.6 在Apache服务器上安装Trac
28.7 管理Trac网站
28.8 管理用户账户
28.9 剪裁Trac网站：使用Wiki功能
28.10 使用Trac Ticket管理系统
28.11 从Subversion中更新Trac问题
28.12 定制Trac Ticket的字段
28.13 设置电子邮件通知
28.14 使用Trac查询和报告
28.15 用Trac路线图（Roadmap）和时间线（Timeline）管理进度
28.16 浏览源代码库
28.17 使用RSS和ICalendar
28.18 使用Python定制wiki页面
28.19 小结
第八部分 技术文档工具
第29章 用Maven 2项目网站进行团队沟通
29.1 作为沟通工具的Maven 2项目网站
29.2 设置Maven网站项目
29.3 将报告集成到网站中
29.4 创建专用Maven网站项目
29.5 定义网站框架
29.6 Maven网站生成架构
29.7 使用代码片断（Snippet）
29.8 定制网站外观
29.9 发布网站
第30章 自动生成技术文档
30.1 概述
30.2 用SchemaSpy直观查看数据库结构
30.3 用Doxygen生成源代码文档
30.4 用UmlGraph在Javadoc中嵌入UML图表
30.5 小结
参考资料
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java开发超级工具集
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java从入门到精通
目  录
第1篇　基础知识
第1章　初识Java	2
视频讲解：34分钟
1.1　Java简介	3
1.1.1　什么是Java语言	3
1.1.2　Java的应用领域	3
1.1.3　Java的版本	4
1.1.4　怎样学好Java	5
1.1.5　JavaAPI文档	6
1.2　Java语言的特性	7
1.2.1　简单	7
1.2.2　面向对象	7
1.2.3　分布性	7
1.2.4　可移植性	7
1.2.5　解释型	8
1.2.6　安全性	8
1.2.7　健壮性	8
1.2.8　多线程	8
1.2.9　高性能	8
1.2.10　动态	8
1.3　搭建Java环境	9
1.3.1　JDK下载	9
1.3.2　Windows系统的JDK环境	11
1.4　第一个Java程序	15
1.5　小结	17
1.6　实践与练习	17
第2章　熟悉Eclipse开发工具	18
视频讲解：35分钟
2.1　熟悉Eclipse	19
2.1.1　Eclipse简介	19
2.1.2　下载Eclipse	19
2.1.3　安装Eclipse的中文语言包	21
2.1.4　Eclipse的配置与启动	23
2.1.5　Eclipse工作台	24
2.1.6　透视图与视图	25
2.1.7　菜单栏	25
2.1.8　工具栏	28
2.1.9　“包资源管理器”视图	29
2.1.10　“控制台”视图	30
2.2　使用Eclipse	30
2.2.1　创建Java项目	30
2.2.2　创建Java类文件	30
2.2.3　使用编辑器编写程序代码	31
2.2.4　运行Java程序	34
2.3　程序调试	34
2.4　小结	36
2.5　实践与练习	36
第3章　Java语言基础	37
视频讲解：37分钟
3.1　Java主类结构	38
3.1.1　包声明	38
3.1.2　声明成员变量和局部变量	39
3.1.3　编写主方法	39
3.1.4　导入API类库	39
3.2　基本数据类型	39
3.2.1　整数类型	40
3.2.2　浮点类型	41
3.2.3　字符类型	42
3.2.4　布尔类型	43
3.3　变量与常量	43
3.3.1　标识符和关键字	44
3.3.2　声明变量	44
3.3.3　声明常量	45
3.3.4　变量的有效范围	46
3.4　运算符	47
3.4.1　赋值运算符	48
3.4.2　算术运算符	49
3.4.3　自增和自减运算符	50
3.4.4　比较运算符	50
3.4.5　逻辑运算符	51
3.4.6　位运算符	52
3.4.7　三元运算符	54
3.4.8　运算符优先级	54
3.5　数据类型转换	55
3.5.1　隐式类型转换	56
3.5.2　显式类型转换	57
3.6　代码注释与编码规范	58
3.6.1　代码注释	58
3.6.2　编码规范	59
3.7　小结	60
3.8　实践与练习	60
第4章　流程控制	61
视频讲解：25分钟
4.1　复合语句	62
4.2　条件语句	62
4.2.1　if条件语句	63
4.2.2　switch多分支语句	67
4.3　循环语句	69
4.3.1　while循环语句	69
4.3.2　do…while循环语句	70
4.3.3　for循环语句	71
4.4　小结	74
4.5　实践与练习	74
第5章　字符串	75
视频讲解：38分钟
5.1　String类	76
5.1.1　声明字符串	76
5.1.2　创建字符串	76
5.2　连接字符串	77
5.2.1　连接多个字符串	78
5.2.2　连接其他数据类型	78
5.3　获取字符串信息	79
5.3.1　获取字符串长度	80
5.3.2　字符串查找	80
5.3.3　获取指定索引位置的字符	81
5.4　字符串操作	82
5.4.1　获取子字符串	82
5.4.2　去除空格	83
5.4.3　字符串替换	84
5.4.4　判断字符串的开始与结尾	85
5.4.5　判断字符串是否相等	86
5.4.6　按字典顺序比较两个字符串	87
5.4.7　字母大小写转换	88
5.4.8　字符串分割	89
5.5　格式化字符串	91
5.5.1　日期和时间字符串格式化	91
5.5.2　常规类型格式化	94
5.6　使用正则表达式	95
5.7　字符串生成器	97
5.8　小结	99
5.9　实践与练习	100
第6章　数组	101
视频讲解：51分钟
6.1　数组概述	102
6.2　一维数组的创建及使用	102
6.2.1　创建一维数组	102
6.2.2　初始化一维数组	103
6.2.3　使用一维数组	104
6.3　二维数组的创建及使用	104
6.3.1　二维数组的创建	105
6.3.2　二维数组初始化	106
6.3.3　使用二维数组	106
6.4　数组的基本操作	107
6.4.1　遍历数组	107
6.4.2　填充替换数组元素	108
6.4.3　对数组进行排序	110
6.4.4　复制数组	111
6.4.5　数组查询	112
6.5　数组排序算法	114
6.5.1　冒泡排序	114
6.5.2　直接选择排序	116
6.5.3　反转排序	118
6.6　小结	120
6.7　实践与练习	121
第7章　类和对象	122
视频讲解：57分钟
7.1　面向对象概述	123
7.1.1　对象	123
7.1.2　类	124
7.1.3　封装	125
7.1.4　继承	125
7.1.5　多态	126
7.2　类	127
7.2.1　成员变量	127
7.2.2　成员方法	128
7.2.3　权限修饰符	129
7.2.4　局部变量	130
7.2.5　局部变量的有效范围	130
7.2.6　this关键字	131
7.3　类的构造方法	132
7.4　静态变量、常量和方法	133
7.5　类的主方法	135
7.6　对象	137
7.6.1　对象的创建	137
7.6.2　访问对象的属性和行为	138
7.6.3　对象的引用	140
7.6.4　对象的比较	141
7.6.5　对象的销毁	142
7.7　小结	143
7.8　实践与练习	143
第8章　包装类	144
视频讲解：19分钟
8.1　Integer	145
8.2　Boolean	147
8.3　Byte	149
8.4　Character	150
8.5　Double	151
8.6　Number	153
8.7　小结	153
8.8　实践与练习	153
第9章　数字处理类	154
视频讲解：21分钟
9.1　数字格式化	155
9.2　数学运算	157
9.2.1　Math类	158
9.2.2　常用数学运算方法	158
9.3　随机数	162
9.3.1　Math.random()方法	162
9.3.2　Random类	164
9.4　大数字运算	165
9.4.1　BigInteger	166
9.4.2　BigDecimal	168
9.5　小结	171
9.6　实践与练习	171


第2篇　核心技术
第10章　接口、继承与多态	174
视频讲解：36分钟
10.1　类的继承	175
10.2　Object类	178
10.3　对象类型的转换	180
10.3.1　向上转型	180
10.3.2　向下转型	181
10.4　使用instanceof操作符判断
对象类型	182
10.5　方法的重载	184
10.6　多态	187
10.7　抽象类与接口	189
10.7.1　抽象类	189
10.7.2　接口	190
10.8　小结	193
10.9　实践与练习	193
第11章　类的高级特性	194
视频讲解：29分钟
11.1　Java类包	195
11.1.1　类名冲突	195
11.1.2　完整的类路径	195
11.1.3　创建包	196
11.1.4　导入包	197
11.2　final变量	199
11.3　final方法	202
11.4　final类	203
11.5　内部类	204
11.5.1　成员内部类	204
11.5.2　局部内部类	208
11.5.3　匿名内部类	209
11.5.4　静态内部类	210
11.5.5　内部类的继承	211
11.6　小结	211
11.7　实践与练习	211
第12章　异常处理	212
视频讲解：23分钟
12.1　异常概述	213
12.2　处理程序异常错误	213
12.2.1　错误	214
12.2.2　捕捉异常	214
12.3　Java常见异常	216
12.4　自定义异常	217
12.5　在方法中抛出异常	218
12.5.1　使用throws关键字抛出异常	218
12.5.2　使用throw关键字抛出异常	219
12.6　运行时异常	221
12.7　异常的使用原则	221
12.8　小结	222
12.9　实践与练习	222
第13章　Swing程序设计	223
视频讲解：1小时2分钟
13.1　Swing概述	224
13.1.1　Swing特点	224
13.1.2　Swing包	224
13.1.3　常用Swing组件概述	225
13.2　常用窗体	225
13.2.1　JFrame窗体	225
13.2.2　JDialog窗体	227
13.3　标签组件与图标	229
13.3.1　标签的使用	229
13.3.2　图标的使用	230
13.4　常用布局管理器	232
13.4.1　绝对布局	233
13.4.2　流布局管理器	234
13.4.3　边界布局管理器	235
13.4.4　网格布局管理器	237
13.5　常用面板	238
13.5.1　JPanel面板	238
13.5.2　JScrollPane面板	239
13.6　按钮组件	240
13.6.1　提交按钮组件	240
13.6.2　单选按钮组件	242
13.6.3　复选框组件	243
13.7　列表组件	244
13.7.1　下拉列表框组件	244
13.7.2　列表框组件	246
13.8　文本组件	248
13.8.1　文本框组件	248
13.8.2　密码框组件	249
13.8.3　文本域组件	249
13.9　常用事件监听器	250
13.9.1　监听事件简介	251
13.9.2　动作事件监听器	251
13.9.3　焦点事件监听器	253
13.10　小结	254
13.11　实践与练习	254
第14章　集合类	255
视频讲解：24分钟
14.1　集合类概述	256
14.2　Collection接口	256
14.3　List集合	257
14.3.1　List接口	257
14.3.2　List接口的实现类	258
14.4　Set集合	259
14.5　Map集合	261
14.5.1　Map接口	261
14.5.2　Map接口的实现类	262
14.6　小结	264
14.7　实践与练习	264
第15章　I/O（输入/输出）	265
视频讲解：39分钟
15.1　流概述	266
15.2　输入/输出流	266
15.2.1　输入流	266
15.2.2　输出流	268
15.3　File类	269
15.3.1　文件的创建与删除	269
15.3.2　获取文件信息	270
15.4　文件输入/输出流	272
15.4.1　FileInputStream与FileOutputStream类	272
15.4.2　FileReader和FileWriter类	273
15.5　带缓存的输入/输出流	275
15.5.1　BufferedInputStream与
BufferedOutputStream类	276
15.5.2　BufferedReader与BufferedWriter类	276
15.6　数据输入/输出流	278
15.7　ZIP压缩输入/输出流	279
15.7.1　压缩文件	280
15.7.2　解压缩ZIP文件	281
15.8　小结	283
15.9　实践与练习	283
第16章　反射	284
视频讲解：48分钟
16.1　Class类与Java反射	285
16.1.1　访问构造方法	286
16.1.2　访问成员变量	289
16.1.3　访问方法	291
16.2　使用Annotation功能	294
16.2.1　定义Annotation类型	294
16.2.2　访问Annotation信息	297
16.3　小结	300
16.4　实践与练习	300
第17章　枚举类型与泛型	301
视频讲解：22分钟
17.1　枚举类型	302
17.1.1　使用枚举类型设置常量	302
17.1.2　深入了解枚举类型	304
17.1.3　使用枚举类型的优势	309
17.2　泛型	310
17.2.1　回顾“向上转型”与“向下转型”	310
17.2.2　定义泛型类	311
17.2.3　泛型的常规用法	312
17.2.4　泛型的高级用法	316
17.2.5　泛型总结	318
17.3　小结	318
17.4　实践与练习	318
第18章　多线程	319
视频讲解：20分钟
18.1　线程简介	320
18.2　实现线程的两种方式	320
18.2.1　继承Thread类	321
18.2.2　实现Runnable接口	322
18.3　线程的生命周期	324
18.4　操作线程的方法	326
18.4.1　线程的休眠	326
18.4.2　线程的加入	328
18.4.3　线程的中断	329
18.4.4　线程的礼让	331
18.5　线程的优先级	332
18.6　线程同步	334
18.6.1　线程安全	334
18.6.2　线程同步机制	335
18.7　小结	337
18.8　实践与练习	338
第19章　网络通信	339
视频讲解：24分钟
19.1　网络程序设计基础	340
19.1.1　局域网与因特网	340
19.1.2　网络协议	340
19.1.3　端口和套接字	341
19.2　TCP程序设计基础	342
19.2.1　InetAddress类	342
19.2.2　ServerSocket类	343
19.2.3　TCP网络程序	344
19.3　UDP程序设计基础	348
19.3.1　DatagramPacket类	348
19.3.2　DatagramSocket类	349
19.3.3　UDP网络程序	349
19.4　小结	352
19.5　实践与练习	353
第20章　数据库操作	354
视频讲解：30分钟
20.1　数据库基础知识	355
20.1.1　什么是数据库	355
20.1.2　数据库的种类及功能	356
20.1.3　SQL语言	356
20.2　JDBC概述	358
20.2.1　JDBC-ODBC桥	358
20.2.2　JDBC技术	359
20.2.3　JDBC驱动程序的类型	359
20.3　JDBC中常用的类和接口	359
20.3.1　Connection接口	360
20.3.2　Statement接口	360
20.3.3　PreparedStatement接口	361
20.3.4　DriverManager类	361
20.3.5　ResultSet接口	361
20.4　数据库操作	362
20.4.1　连接数据库	363
20.4.2　向数据库发送SQL语句	364
20.4.3　处理查询结果集	364
20.4.4　顺序查询	365
20.4.5　模糊查询	366
20.4.6　预处理语句	367
20.4.7　添加、修改、删除记录	369
20.5　小结	371
20.6　实践与练习	371

第3篇　高级应用
第21章  Swing表格组件	374
视频讲解：59分钟
21.1　利用JTable类直接创建表格	375
21.1.1　创建表格	375
21.1.2　定制表格	377
21.1.3　操纵表格	381
21.2　表格模型与表格	383
21.2.1　利用表格模型创建表格	383
21.2.2　维护表格模型	385
21.3　提供行标题栏的表格	387
21.4　小结	392
21.5　实践与练习	392
第22章　Swing树组件	393
视频讲解：1小时4分钟
22.1　简单的树	394
22.2　处理选中节点事件	395
22.3　遍历树节点	397
22.4　定制树	399
22.5　维护树模型	402
22.6　处理展开节点事件	404
22.7　小结	406
22.8　实践与练习	406
第23章　Swing其他高级组件	407
视频讲解：1小时35分钟
23.1　高级组件面板	408
23.1.1　分割面板	408
23.1.2　选项卡面板	411
23.1.3　桌面面板和内部窗体	413
23.2　菜单	417
23.2.1　创建菜单栏	417
23.2.2　创建弹出式菜单	419
23.2.3　定制个性化菜单	420
23.3　工具栏	424
23.4　文件选择器	426
23.4.1　文件选择对话框	426
23.4.2　使用文件过滤器	427
23.5　进度条	428
23.6　系统托盘	430
23.7　桌面集成控件	431
23.8　小结	432
23.9　实践与练习	432
第24章　高级布局管理器	433
视频讲解：1小时40分钟
24.1　箱式布局管理器	434
24.2　卡片布局管理器	436
24.3　网格组布局管理器	439
24.4　弹簧布局管理器	445
24.4.1　使用弹簧布局管理器	445
24.4.2　使用弹簧和支柱	448
24.4.3　利用弹簧控制组件大小	449
24.5　小结	450
24.6　实践与练习	450
第25章　高级事件处理	451
视频讲解：33分钟
25.1　键盘事件	452
25.2　鼠标事件	454
25.3　窗体事件	456
25.3.1　捕获窗体焦点变化事件	456
25.3.2　捕获窗体状态变化事件	457
25.3.3　捕获其他窗体事件	459
25.4　选项事件	461
25.5　表格模型事件	462
25.6　小结	465
25.7　实践与练习	465
第26章　AWT绘图与音频播放	466
视频讲解：34分钟
26.1　Java绘图	467
26.1.1　Graphics	467
26.1.2　Graphics2D	467
26.2　绘制图形	467
26.3　绘图颜色与笔画属性	471
26.3.1　设置颜色	471
26.3.2　笔画属性	472
26.4　绘制文本	473
26.4.1　设置字体	474
26.4.2　显示文字	474
26.5　绘制图片	475
26.6　图像处理	477
26.6.1　放大与缩小	477
26.6.2　图像翻转	479
26.6.3　图像旋转	481
26.6.4　图像倾斜	482
26.7　播放音频文件	484
26.8　小结	486
26.9　实践与练习	486
第27章　打印技术	487
视频讲解：32分钟
27.1　打印控制类	488
27.2　“打印”对话框	489
27.3　打印页面	491
27.4　多页打印	493
27.5　打印预览	495
27.6　小结	497
27.7　实践与练习	497

第4篇　项目实战
第28章　企业进销存管理系统	500
视频讲解：1小时37分钟
28.1　系统分析	501
28.1.1　需求分析	501
28.1.2　可行性分析	501
28.1.3　编写项目计划书	502
28.2　系统设计	504
28.2.1　系统目标	504
28.2.2　系统功能结构	504
28.2.3　系统业务流程图	505
28.2.4　系统编码规范	506
28.3　开发环境	507
28.4　数据库与数据表设计	508
28.4.1　数据库分析	508
28.4.2　创建数据库	509
28.4.3　创建数据表	510
28.5　创建项目	513
28.6　系统文件夹组织结构	514
28.7　公共类设计	515
28.7.1　Item公共类	515
28.7.2　数据模型公共类	516
28.7.3　Dao公共类	518
28.8　系统登录模块设计	524
28.8.1　设计登录窗体	524
28.8.2　“密码”文本框的回车事件	525
28.8.3　“登录”按钮的事件处理	526
28.9　系统主窗体设计	527
28.9.1　设计菜单栏	527
28.9.2　设计工具栏	530
28.9.3　设计状态栏	531
28.10　进货单模块设计	531
28.10.1　设计进货单窗体	532
28.10.2　添加进货商品	533
28.10.3　进货统计	534
28.10.4　商品入库	536
28.11　销售单模块设计	538
28.11.1　设计销售单窗体	538
28.11.2　添加销售商品	539
28.11.3　销售统计	540
28.11.4　商品销售	541
28.12　库存盘点模块设计	542
28.12.1　设计库存盘点窗体	542
28.12.2　读取库存商品	543
28.12.3　统计损益数量	544
28.13　数据库备份与恢复模块设计	545
28.13.1　设计窗体	545
28.13.2　文件浏览	546
28.13.3　备份数据库	547
28.13.4　恢复数据库	548
28.14　运行项目	549
28.15　系统打包发行	551
28.16　开发常见问题与解决	553
28.16.1　数据库无法访问	553
28.16.2　打包的JAR文件无法登录	554
28.16.3　数据库还原不成功	555
28.16.4　数据库只读	555
28.16.5　无法打开内部窗体	555
28.16.6　“关于”界面被其他窗体覆盖	556
28.16.7　打包JAR文件之后无法运行	556
28.16.8　程序运行后没有出现闪屏界面	556
28.17　小结	557
附录A　JDK 7改进的功能	558
A.1　语法	558
A.1.1　switch语句允许使用字符串	558
A.1.2　整型数据支持二进制形式	559
A.1.3　数值型数据中可以出现下划线	559
A.1.4　泛型实例的创建可以通过类型
推断来简化	559
A.1.5　try-with-resources语句	560
A.1.6　改进了捕获多个异常时的类型检查	560
A.1.7　在可变参数方法中传递非具体化参数
时，改进编译警告和错误	561
A.2　网络	562
A.3　Java2D	562
A.4　Swing	563
A.5　JavaI/O	563
A.6　并发	563
A.7　安全性	563
A.8　JavaXML	564
A.9　Java虚拟器（JVM）	564
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java从入门到精通
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java RESTful Web Service实战
第一篇　够用就好--JAX-RS 2.0 基础
第1 章　JAX-RS 2.0 入门
1.1　解读REST
1.1.1　一种架构风格
1.1.2　基本实现形式
1.2　解读REST 服务
1.3　解读JAX-RS
1.4　Jersey 项目概要
1.5　Java 领域的其他REST 实现
1.5.1　其他JAX-RS 实现
1.5.2　其他REST 实现
1.6　本章小结
第2 章　JAX-RS 2.0 快速实现
2.1　第一个Java REST 服务
2.1.1　环境准备
2.1.2　创建服务
2.1.3　扩展服务
2.1.4　测试和运行服务
2.2　第一个Servlet 容器服务
2.2.1　创建和分析Web 服务
2.2.2　Jetty 插件与REST 服务
2.2.3　运行在Servlet 容器
2.2.4　运行在Java EE 容器
2.3　REST 服务类型
2.4　REST 应用描述
2.4.1　应用的描述
2.4.2　资源的描述
2.4.3　WADL 的配置
2.5　第一个完整的REST 服务
2.5.1　定义资源
2.5.2　集成Spring
2.5.3　集成JPA
2.5.4　集成jQuery
2.5.5　请求处理流程分析
2.6　REST 调试工具
2.6.1　命令行调试工具cURL
2.6.2　基于浏览器的图形化调试插件
2.7　本章小结
第3 章　REST API 设计
3.1　REST 统一接口
3.1.1　GET 方法
3.1.2　PUT 方法
3.1.3　DELETE 方法
3.1.4　POST 方法
3.1.5　WebDAV 扩展方法
3.2　REST 资源定位
3.2.1　资源地址设计
3.2.2　@QueryParam 注解
3.2.3　@PathParam 注解
3.2.4　@FormParam 注解
3.2.5　@BeanParam 注解
3.2.6　@CookieParam 注解
3.2.7　@Context 注解
3.3　REST 传输格式
3.3.1　基本类型
3.3.2　文件类型
3.3.3　InputStream 类型
3.3.4　Reader 类型
3.3.5　XML 类型
3.3.6　JSON 类型
3.4　REST 连通性
3.4.1　过渡型链接
3.4.2　结构型链接
3.5　REST 响应处理
3.5.1　返回类型
3.5.2　处理异常
3.6　REST 内容协商
3.6.1 @Produces 注解
3.6.2 @Consumes 注解
3.7　本章小结
第4 章　REST 请求处理
4.1　REST 和AOP
4.2　Providers 详解
4.2.1　实体Providers
4.2.2　上下文Providers
4.3　REST 请求流程
4.4　REST 过滤器
4.4.1　ClientRequestFilter
4.4.2　ContainerRequestFilter
4.4.3　ContainerResponseFilter
4.4.4　ClientResponseFilter
4.4.5　访问日志
4.5　REST 拦截器
4.6　绑定机制
4.7　优先级
4.8　本章小结
第5 章　REST 客户端
5.1　客户端接口
5.1.1　Client 接口
5.1.2　WebTarget 接口
5.1.3　Invocation 接口
5.2　资源释放
5.3　连接器
5.4　封装Client
5.5　本章小结
第二篇　全面掌握--JAX-RS 2.0 进阶
第6 章　REST 安全
6.1　身份认证
6.1.1　基本认证
6.1.2　摘要认证
6.1.3　表单认证
6.1.4　证书认证
6.2　资源授权
6.2.1　容器管理权限
6.2.2　应用管理权限
6.3　认证与授权实现
6.3.1　基本认证与JDBCRealm
6.3.2　摘要认证与UserDatabase-Realm
6.3.3　表单认证与DataSource-Realm
6.3.4　表单认证与JAASRealm
6.3.5　证书认证与UserDatabase-Realm
6.4　JAX-RS 2.0 实现
6.5　其他安全考虑
6.6　本章小结
第7 章　REST 测试
7.1　Jersey 测试框架
7.2　单元测试
7.2.1　集成Spring 的单元测试
7.2.2　异步测试
7.3　集成测试
7.4　日志增强
7.5　本章小结
第8 章　REST 推送与异步通信
8.1　服务器-浏览器通信
8.1.1　Polling 技术
8.1.2　Comet 技术
8.1.3　SSE 技术
8.1.4　WebSocket 技术
8.2　SSE 详述
8.2.1　Java 并发
8.2.2　SSE 流程
8.2.3　SSE 实现
8.3　异步通信
8.4　JAX-RS 2.0 实现异步通信
8.4.1　服务端实现
8.4.2　客户端实现和测试
8.5　本章小结
第9 章　Jersey 1.x 迁移
9.1　变更Maven 依赖定义
9.2　客户端迁移
9.2.1　Client 接口迁移
9.2.2　WebTarget 接口迁移
9.2.3　QueryParam
9.3　服务器端迁移
9.4　本章小结
第10 章　JAX-RS 调优
10.1　使用缓存优化负载
10.1.1　缓存协商
10.1.2　条件GET
10.1.3　REST 缓存实践
10.1.4　ab 测试
10.2　使用版本号优化服务
10.2.1　何时使用版本号
10.2.2　如何使用版本号
10.3　使用参数配置优化服务
10.3.1　通用配置
10.3.2　服务器端配置
10.3.3　客户端配置
10.4　Java 虚拟机调优
10.4.1　虚拟机概述
10.4.2　内存溢出与内存泄漏
10.5　本章小结
第三篇　实践分享--JAX-RS 2.0 综合
第11 章　统一自动化测试平台
11.1　ATUP 的定义
11.1.1　需求仓库
11.1.2　需求分析
11.1.3　迭代规划
11.2　ATUP 的设计
11.2.1　开发和部署环境
11.2.2　模块定义和拓扑
11.2.3　持续集成流程
11.3　ATUP 的实现
11.3.1　Sprint1 核心功能
11.3.2　Sprint2 模块功能
11.3.3　Iteration1 的演示和回顾
11.3.4　Sprint3 持续交付
11.3.5　交付和总结
11.4　本章小结
附录　Web 简史
参考资料
后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java RESTful Web Service实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java项目开发案例全程实录
目  录

第1章  进销存管理系统（Swing+SQL Server
2000实现）	1
视频讲解：1小时42分钟
1.1  开发背景	2
1.2  系统分析	2
1.2.1  需求分析	2
1.2.2  可行性分析	2
1.2.3  编写项目计划书	4
1.3  系统设计	6
1.3.1  系统目标	6
1.3.2  系统功能结构	6
1.3.3  业务逻辑编码规则	7
1.3.4  系统流程图	8
1.3.5  构建开发环境	8
1.3.6  系统预览	9
1.3.7  文件夹组织结构	10
1.4  数据库设计	10
1.4.1  数据库分析	10
1.4.2  进销存管理系统的E-R图	10
1.4.3  使用PowerDesigner建模	12
1.4.4  创建数据库	15
1.5  主窗体设计	16
1.5.1  创建主窗体	17
1.5.2  创建导航面板	18
1.6  公共模块设计	21
1.6.1  编写Dao公共类	22
1.6.2  编写Item类	25
1.7  基础信息模块设计	26
1.7.1  基础信息模块概述	26
1.7.2  基础信息模块技术分析	27
1.7.3  供应商添加实现过程	27
1.7.4  供应商修改与删除实现过程	30
1.7.5  单元测试	32
1.8  进货管理模块设计	36
1.8.1  进货管理模块概述	36
1.8.2  进货管理模块技术分析	38
1.8.3  进货单实现过程	38
1.9  查询统计模块设计	42
1.9.1  查询统计模块概述	42
1.9.2  查询统计模块技术分析	43
1.9.3  销售查询实现过程	43
1.10  库存管理模块设计	45
1.10.1  库存管理模块概述	45
1.10.2  库存管理模块技术分析	46
1.10.3  价格调整实现过程	46
1.10.4  单元测试	48
1.11  系统打包发布	49
1.12  开发技巧与难点分析	51
1.13  使用PowerDesigner逆向生成
数据库E-R图	52
1.14  本章小结	54
第2章  企业内部通信系统（Swing+JavaDB
实现）	55
视频讲解：1小时40分钟
2.1  开发背景	56
2.2  系统分析	56
2.2.1  需求分析	56
2.2.2  可行性分析	56
2.2.3  编写项目计划书	58
2.3  系统设计	60
2.3.1  系统目标	60
2.3.2  系统功能结构	60
2.3.3  数据库设计	60
2.3.4  系统预览	62
2.3.5  文件夹组织结构	63
2.4  主窗体设计	64
2.4.1  创建主窗体	64
2.4.2  记录窗体位置	68
2.5  公共模块设计	69
2.5.1  数据库操作类	69
2.5.2  系统工具类	74
2.6  系统托盘模块设计	79
2.6.1  系统托盘模块概述	79
2.6.2  系统托盘模块技术分析	79
2.6.3  系统托盘模块实现过程	80
2.7  系统工具模块设计	82
2.7.1  系统工具模块概述	82
2.7.2  系统工具模块技术分析	82
2.7.3  系统工具模块实现过程	83
2.8  用户管理模块设计	87
2.8.1  用户管理模块概述	87
2.8.2  用户管理模块技术分析	87
2.8.3  用户管理模块实现过程	88
2.8.4  单元测试	93
2.9  通信模块设计	94
2.9.1  通信模块概述	94
2.9.2  通信模块技术分析	95
2.9.3  通信模块实现过程	95
2.10  开发技巧与难点分析	99
2.11  使用JDK 6新增的系统托盘	99
2.12  本章小结	100
第3章  企业人事管理系统（Swing+
Hibernate+Oracle实现）	101
视频讲解：2小时53分钟
3.1  开发背景	102
3.2  系统分析	102
3.3  系统设计	102
3.3.1  系统目标	102
3.3.2  系统功能结构	102
3.3.3  系统预览	104
3.3.4  业务流程图	105
3.3.5  文件夹结构设计	106
3.4  数据库设计	107
3.4.1  数据库分析	107
3.4.2  数据库概念设计	107
3.4.3  数据库逻辑结构设计	109
3.5  主窗体设计	110
3.5.1  导航栏的设计	110
3.5.2  工具栏的设计	112
3.6  公共模块设计	114
3.6.1  编写Hibernate配置文件	114
3.6.2  编写Hibernate持久化类和映射文件	115
3.6.3  编写通过Hibernate操作持久化对象的
常用方法	116
3.6.4  创建用于特殊效果的部门树对话框	117
3.6.5  创建通过部门树选取员工的面板和
对话框	119
3.7  人事管理模块设计	120
3.7.1  人事管理模块功能概述	120
3.7.2  人事管理模块技术分析	122
3.7.3  人事管理模块实现过程	122
3.7.4  单元测试	127
3.8  待遇管理模块设计	128
3.8.1  待遇管理模块功能概述	128
3.8.2  待遇管理模块技术分析	129
3.8.3  待遇管理模块实现过程	129
3.9  系统维护模块设计	133
3.9.1  系统维护模块功能概述	134
3.9.2  系统维护模块技术分析	136
3.9.3  系统维护模块实现过程	136
3.9.4  单元测试	140
3.10  开发技巧与难点分析	140
3.11  Hibernate关联关系的建立方法	141
3.11.1  建立一对一关联	141
3.11.2  建立一对多关联	142
3.12  本章小结	144
第4章  酒店管理系统（Swing+SQL Server
2005实现）	145
视频讲解：2小时39分钟
4.1  概述	146
4.2  系统分析	146
4.3  系统设计	146
4.3.1  系统目标	146
4.3.2  系统功能结构	147
4.3.3  系统预览	147
4.3.4  业务流程图	149
4.3.5  文件夹结构设计	149
4.4  数据库设计	150
4.4.1  数据库分析	150
4.4.2  数据库概念设计	150
4.4.3  数据库逻辑结构设计	151
4.4.4  视图设计	151
4.5  公共模块设计	152
4.5.1  编写数据库连接类	152
4.5.2  封装常用的操作数据库的方法	153
4.5.3  自定义表格组件	154
4.5.4  编写利用正则表达式验证数据合法性
的方法	156
4.6  主窗体设计	156
4.7  用户登录窗口设计	158
4.8  开台签单工作区设计	164
4.8.1  开台签单工作区功能概述	164
4.8.2  开台签单工作区技术分析	165
4.8.3  开台签单工作区实现过程	165
4.8.4  单元测试	170
4.9  自动结账工作区设计	171
4.9.1  自动结账工作区功能概述	171
4.9.2  自动结账工作区技术分析	172
4.9.3  自动结账工作区实现过程	172
4.10  结账报表工作区设计	173
4.10.1  结账报表工作区功能概述	173
4.10.2  结账报表工作区技术分析	175
4.10.3  结账报表工作区实现过程	175
4.10.4  单元测试	179
4.11  后台管理工作区设计	180
4.11.1  后台管理工作区功能概述	180
4.11.2  后台管理工作区技术分析	181
4.11.3  后台管理工作区实现过程	181
4.11.4  单元测试	188
4.12  开发技巧与难点分析	188
4.13  使用Visio逆向生成数据库E-R图	190
4.14  本章小结	192
第5章  图书馆管理系统（Swing+SQL Server
2000实现）	193
视频讲解：2小时14分钟
5.1  开发背景	194
5.2  需求分析	194
5.3  系统设计	194
5.3.1  系统目标	194
5.3.2  系统功能结构	195
5.3.3  系统流程图	195
5.3.4  系统预览	196
5.3.5  构建开发环境	196
5.3.6  文件夹组织结构	197
5.4  数据库设计	197
5.4.1  数据库分析	197
5.4.2  数据库概念设计	197
5.4.3  使用PowerDesigner建模	200
5.5  公共模块设计	201
5.5.1  数据库连接及操作类的编写	201
5.5.2  MenuActions类的编写	203
5.5.3  限制文本框长度类的编写	205
5.5.4  描述组合框索引与内容类的编写	206
5.5.5  在JLable上添加图片类的编写	208
5.6  主窗体设计	208
5.6.1  主窗体概述	208
5.6.2  主窗体技术分析	209
5.6.3  主窗体的实现过程	211
5.7  登录模块设计	214
5.7.1  登录模块概述	214
5.7.2  登录模块技术分析	215
5.7.3  登录模块实现过程	216
5.8  图书信息管理模块设计	219
5.8.1  图书信息管理模块概述	219
5.8.2  图书信息管理模块技术分析	220
5.8.3  图书信息管理模块实现过程	221
5.8.4  单元测试	229
5.9  图书借阅、归还模块设计	230
5.9.1  图书借阅、归还模块概述	230
5.9.2  图书借阅、归还模块技术分析	231
5.9.3  图书借阅、归还模块实现过程	232
5.9.4  单元测试	238
5.10  图书查询模块设计	239
5.10.1  图书查询模块概述	239
5.10.2  图书查询模块技术分析	239
5.10.3  图书查询模块实现过程	240
5.11  开发技巧与难点分析	242
5.11.1  级联删除	242
5.11.2  窗体中单选按钮即时显示	243
5.12  格式化的文本框	243
5.12.1  使用JFormattedTextField限制整型
数字输入	244
5.12.2  使用JFormattedTextField限制日期
输入	244
5.13  本章小结	245
第6章  企业快信（Swing+JavaDB
实现）	246
视频讲解：1小时35分钟
6.1  企业快信概述	247
6.2  系统分析	247
6.2.1  需求分析	247
6.2.2  可行性研究	247
6.3  系统设计	248
6.3.1  系统目标	248
6.3.2  系统功能结构	248
6.3.3  业务流程图	248
6.3.4  系统预览	249
6.3.5  构建开发环境	251
6.3.6  文件夹组织结构	252
6.4  数据库设计	253
6.4.1  数据库分析	253
6.4.2  数据库概念设计	253
6.4.3  数据库逻辑结构设计	254
6.4.4  视图设计	255
6.5  主窗体设计	255
6.6  公共模块设计	258
6.6.1  编写数据库连接类	258
6.6.2  封装常用的操作数据库的方法	260
6.7  资源管理模块设计	261
6.7.1  名片夹管理模块概述	261
6.7.2  名片夹管理模块技术分析	262
6.7.3  名片夹管理模块实现过程	262
6.8  发送短信模块设计	270
6.8.1  发送短信模块功能概述	270
6.8.2  发送短信模块技术分析	271
6.8.3  发送短信模块实现过程	272
6.9  发送邮件模块设计	276
6.9.1  发送邮件模块功能概述	276
6.9.2  发送邮件模块技术分析	277
6.9.3  发送邮件模块实现过程	277
6.10  系统设置模块设计	282
6.10.1  系统设置模块功能概述	282
6.10.2  系统设置模块技术分析	283
6.10.3  短信设置实现过程	283
6.10.4  邮箱设置实现过程	285
6.11  开发技巧与难点分析	287
6.12  使用短信猫和Java Mail组件	288
6.12.1  使用短信猫	288
6.12.2  使用Java Mail组件	290
6.13  本章小结	295
第7章  欣想电子商城（Spring+Hibernate+
SQL Server实现）	296
视频讲解：1小时53分钟
7.1  开发背景	297
7.2  系统分析	297
7.2.1  需求分析	297
7.2.2  可行性分析	297
7.3  系统设计	298
7.3.1  系统目标	298
7.3.2  系统功能结构	298
7.3.3  购物流程图	298
7.3.4  系统预览	300
7.3.5  构建开发环境	301
7.3.6  文件夹组织结构	304
7.4  数据库设计	304
7.4.1  数据库分析	305
7.4.2  数据库概念设计	305
7.4.3  PowerDesigner数据库建模	306
7.4.4  数据库创建	307
7.5  网站首页设计	308
7.5.1  首页布局	308
7.5.2  创建首页控制器	311
7.5.3  配置控制器	312
7.6  公共模块设计	314
7.6.1  编写Dao公共类	314
7.6.2  配置数据库连接和事务管理器	316
7.6.3  配置Spring控制器的请求映射	317
7.7  会员管理模块设计	319
7.7.1  会员管理模块概述	319
7.7.2  会员管理模块技术分析	320
7.7.3  会员注册的实现过程	321
7.7.4  会员登录的实现过程	324
7.8  购物模块设计	327
7.8.1  购物模块概述	327
7.8.2  购物模块技术分析	328
7.8.3  购物车的实现过程	328
7.8.4  收银台的实现过程	332
7.8.5  单元测试	335
7.9  商品管理模块设计	336
7.9.1  商品管理模块概述	336
7.9.2  商品管理模块技术分析	337
7.9.3  商品列表的实现过程	338
7.9.4  商品添加的实现过程	340
7.9.5  单元测试	343
7.10  发布与运行	344
7.11  开发技巧与难点分析	346
7.11.1  为Spring的数据源配置正确的URL	346
7.11.2  为Tiles指定错误页面	347
7.12  使用MyEclipse生成Hibernate实体类
和映射文件	347
7.13  本章小结	351
第8章  医药管理系统（Struts+Hibernate+
MySQL实现）	352
视频讲解：1小时9分钟
8.1  开发背景	353
8.2  系统分析	353
8.2.1  需求分析	353
8.2.2  可行性分析	353
8.3  系统设计	354
8.3.1  系统目标	354
8.3.2  系统功能结构	354
8.3.3  系统流程图	354
8.3.4  逻辑分层结构设计	355
8.3.5  系统预览	356
8.3.6  文件夹组织结构	357
8.4  数据库设计	358
8.4.1  数据库分析	358
8.4.2  数据库概念设计	358
8.4.3  数据库创建	360
8.5  配置文件	360
8.5.1  配置web.xml	360
8.5.2  配置struts-config.xml	362
8.5.3  配置hibernate.cfg.xml	364
8.6  公共类设计	365
8.6.1  SuperDao类	365
8.6.2  BaseAction类	369
8.6.3  DeleteAction类	372
8.6.4  字符串工具类	373
8.7  系统登录模块设计	374
8.7.1  查询用户	375
8.7.2  登录请求	375
8.7.3  登录页面	376
8.7.4  单元测试	377
8.8  药品类别信息管理	378
8.8.1  药品类别持久层设计	378
8.8.2  药品类别的添加	379
8.8.3  分页查看类别信息	381
8.8.4  类别的修改与删除	383
8.8.5  药品类别统计	384
8.9  药品信息管理	386
8.9.1  药品对象持久层设计	386
8.9.2  药品信息的添加与修改	387
8.9.3  分页查看所有药品	389
8.9.4  查看药品详细信息	390
8.9.5  模糊查询药品	391
8.9.6  高级查询	393
8.9.7  查看库存	394
8.9.8  药品批量删除	395
8.10  购买药品	396
8.10.1  选购药品	396
8.10.2  结账	398
8.11  销售管理	399
8.11.1  明细信息查询	399
8.11.2  销售排行统计	400
8.12  进货及需求管理	401
8.13  系统管理	402
8.13.1  添加管理员	402
8.13.2  修改密码	403
8.13.3  系统初始化	404
8.14  开发技巧与难点解析	404
8.15  运行项目	407
8.16  使用native2ascii.exe命令实现
国际化	408
8.16.1  国际化资源文件	408
8.16.2  国际化实现	409
8.17  本章小结	410
第9章  企业门户网站（JSP+JavaBean+
SQL Server 2000实现）	411
视频讲解：1小时9分钟
9.1  开发背景	412
9.2  需求分析	412
9.3  系统设计	412
9.3.1  系统目标	412
9.3.2  系统功能结构	413
9.3.3  业务流程图	414
9.3.4  系统预览	414
9.3.5  构建开发环境	415
9.3.6  文件夹组织结构	417
9.4  数据库设计	418
9.4.1  数据库需求分析	418
9.4.2  数据库概念设计	418
9.4.3  数据库逻辑结构设计	419
9.5  公共模块设计	420
9.5.1  定义connsqlserver类	420
9.5.2  创建Web应用过滤器	422
9.5.3  构建转码类	423
9.6  网站首页设计	424
9.6.1  首页概述	424
9.6.2  首页技术分析	424
9.6.3  首页的实现过程	426
9.7  产品介绍模块设计	428
9.7.1  产品介绍模块概述	428
9.7.2  产品介绍模块技术分析	428
9.7.3  产品介绍模块实现过程	429
9.8  后台登录模块设计	430
9.8.1  后台登录模块概述	430
9.8.2  后台登录模块技术分析	431
9.8.3  后台登录模块实现过程	432
9.8.4  单元测试	434
9.9  商品管理模块设计	435
9.9.1  商品管理模块概述	435
9.9.2  商品管理模块技术分析	436
9.9.3  商品管理模块实现过程	437
9.9.4  单元测试	447
9.10  新闻管理模块设计	448
9.10.1  新闻管理模块概述	448
9.10.2  新闻管理模块技术分析	448
9.10.3  新闻管理模块实现过程	450
9.11  开发技巧与难点分析	456
9.11.1  页面弹出窗口控制	456
9.11.2  FileUpload组件获取表单中的值	458
9.11.3  配置全局Tomcat连接池	458
9.12  Proxool连接池	459
9.12.1  Proxool安装	459
9.12.2  Proxool使用	459
9.13  本章小结	461
第10章  BBS系统（Struts+MySQL
实现）	462
视频讲解：1小时46分钟
10.1  开发背景	463
10.2  需求分析	463
10.3  系统设计	463
10.3.1  系统目标	463
10.3.2  系统功能结构	464
10.3.3  业务流程图	464
10.3.4  系统预览	465
10.3.5  构建开发环境	466
10.3.6  文件夹组织结构	467
10.4  数据库设计	468
10.4.1  数据库分析	468
10.4.2  数据库概念设计	468
10.4.3  PowerDesigner数据库建模	469
10.4.4  创建数据库	470
10.5  论坛首页设计	471
10.5.1  创建首页视图组件	471
10.5.2  创建首页配置文件	475
10.5.3  创建首页控制器	475
10.5.4  创建首页业务逻辑类	476
10.6  公共模块设计	478
10.6.1  数据库连接	478
10.6.2  配置消息资源文件	481
10.6.3  创建转码类	482
10.7  用户登录模块设计	483
10.7.1  用户登录概述	483
10.7.2  用户登录技术分析	483
10.7.3  用户登录实现过程	484
10.7.4  单元测试	488
10.8  用户注册模块设计	489
10.8.1  用户注册概述	489
10.8.2  用户注册技术分析	489
10.8.3  用户注册实现过程	489
10.9  用户发布主题模块设计	495
10.9.1  发布主题概述	495
10.9.2  发布主题技术分析	496
10.9.3  发布主题实现过程	496
10.9.4  单元测试	502
10.10  后台栏目管理模块设计	504
10.10.1  栏目管理概述	504
10.10.2  栏目管理技术分析	505
10.10.3  栏目管理实现过程	505
10.11  开发技巧与难点分析	508
10.12  Struts框架与日志	509
10.13  本章小结	511
第11章  手机网络游戏（J2ME+Servlet
实现）	512
视频讲解：1小时15分钟
11.1  开发背景	513
11.2  系统分析	513
11.2.1  需求分析	513
11.2.2  可行性分析	513
11.3  系统设计	513
11.3.1  系统目标	513
11.3.2  系统功能结构	514
11.3.3  构建开发环境（根据语言的实际
情况写）	514
11.3.4  系统预览	515
11.3.5  文件夹组织结构	516
11.4  主程序设计	517
11.5  公共模块设计	521
11.5.1  创建Player公共类	521
11.5.2  创建Queue公共类	522
11.5.3  创建Umpire公共类	524
11.5.4  创建Desk公共类	525
11.6  游戏模块设计	528
11.6.1  游戏模块概述	528
11.6.2  游戏模块技术分析	529
11.6.3  棋盘绘制模块实现过程	529
11.6.4  按键处理模块实现过程	537
11.6.5  游戏信息处理模块实现过程	540
11.6.6  客户端信息处理模块概述	541
11.7  服务器模块设计	543
11.7.1  服务器模块概述	543
11.7.2  服务器模块技术分析	544
11.7.3  服务器模块实现过程	544
11.7.4  单元测试	549
11.8  发布与运行	550
11.8.1  服务器端的发布与运行	550
11.8.2  客户端的运行	552
11.9  开发技巧与难点分析	552
11.10  使用EclipseMe工具编写手机
程序	553
11.10.1  EclipseMe的安装	553
11.10.2  配置EclipseMe插件	554
11.10.3  创建J2ME项目	555
11.11  本章小结	556
第12章  棋牌游戏系统之网络五子棋
（Swing+Socket实现）	557
视频讲解：2小时6分钟
12.1  开发背景	558
12.2  需求分析	558
12.3  系统设计	558
12.3.1  系统目标	558
12.3.2  系统功能结构	559
12.3.3  系统流程图	559
12.3.4  构建开发环境	560
12.3.5  系统预览	560
12.3.6  文件夹组织结构	562
12.4  公共模块设计	563
12.4.1  绑定属性的JavaBean	563
12.4.2  在棋盘中绘制棋子	564
12.4.3  实现动态调整棋盘大小	565
12.4.4  游戏悔棋	567
12.4.5  游戏回放	568
12.5  实现登录界面	569
12.6  编写游戏主窗体	572
12.7  编写下棋面板	576
12.8  编写棋盘面板	585
12.9  实现游戏规则算法	590
12.10  编写棋盘模型	594
12.11  编写联机通信类	597
12.12  系统打包发布	600
12.13  开发技巧与难点分析	602
12.14  安装SWT-Designer界面设计器	603
12.15  本章小结	605

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java项目开发案例全程实录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java编程规范
前言
第二版 前言
第三版 前言
第1章 简介
1.1 示例程序
1.2 符号
1.3 预定义类和接口的关系
1.4 参考文献
第2章 语法
2.1 与环境无关的语法
2.2 词法语法
2.3 语义语法
2.4 .语法符号
第3章 词法结构
3.1 Unicode
3.2 词法转换
3.3 Unicode转义符
3.4 行终止符
3.5 输入元素和标记
3.6 空白
3.7 注释
3.8 标识符
3.9 关键字
3.10 字面值
3.11 分隔符
3.12 运算符
第4章 类型、值和变量
4.1 各种类型和值
4.2 基本类型和值
4.3 引用类型和值
4.4 类型变量
4.5 参数化类型
4.6 类型擦除
4.7 可具体化的类型
4.8 原生类型
4.9 交集类型
4.10 子类型化
4.11 在何处使用类型
4.12 变量
第5章 转换和提升
5.1 转换的种类
5.2 赋值转换
5.3 方法调用转换
5.4 字符串转换
5.5 强制转换
5.6 数值提升
第6章 名称
6.1 声明
6.2 名称和标识符
6.3 声明的作用域
6.4 成员和继承
6.5 确定名称的含义
6.6 访问控制
6.7 完全限定的名称和规范名称
6.8 命名约定
第7章 包
7.1 包成员
7.2 包的主机支持
7.3 编译单元
7.4 包声明
7.5 导入声明
7.6 顶级类型声明
7.7 惟一的包名称
第8章 类
8.1 类声明
8.2 类成员
8.3 字段声明
8.4 方法声明
8.5 成员类型声明
8.6 实例初始化语句
8.7 静态初始化语句
8.8 构造函数声明
8.9 枚举
第9章 接口
9.1 接口声明
9.2 接口成员
9.3 字段(常量）声明
9.4 抽象方法声明
9.5 成员类型声明
9.6 注释类型
9.7 注释
第10章 数组
10.1 数组类型
10.2 数组变量
10.3 数组创建
10.4 数组访问
10.5 数组：一个简单的示例
10.6 数组初始化语句
10.7 数组成员
10.8 数组的Class对象
10.9 字符的数组不是一个String
10.10 数组存储异常
第11章 异常
11.1 异常的起因
11.2 异常的编译时检查
11.3 异常处理
11.4 异常的示例
11.5 异常层次结构
第12章 执行
12.1 虚拟机启动
12.2 加载类和接口
12.3 链接类和接口
12.4 初始化类和接口
12.5 创建新的类实例
12.6 类实例的终结
12.7 卸载类和接口
12.8 程序退出
第13章 二进制兼容性
13.1 二进制的形式
13.2 二进制兼容性是什么，不是什么
13.3 包的演变
13.4 类的演变
13.5 接口的演变
第14章 块和语句
14.1 语句的正常结束和突然结束
14.2 块
14.3 本地类声明
14.4 局部变量声明语句
14.5 语句
14.6 空语句
14.7 标签语句
14.8 表达式语句
14.9 if语句
14.10 assert语句
14.11 SWitch语句
14.12 while语句
14.13 do语句
14.14 for语句
14.15 break语句
14.16 continue语句
14.17 return语句
14.18 throw语句
14.19 synchronized语句
14.20 try语句
14.21 不可到达语句
第15章 表达式
15.1 计算、表示和结果
15.2 变量作为值
15.3 表达式的类型
15.4 精确浮点数表达式
15.5 表达式和运行时检查
15.6 计算的正常和突然结束
15.7 求值顺序
15.8 主表达式
15.9 类实例创建表达式
15.10 数组创建表达式
15.11 字段访问表达式
15.12 内存调用表达式
15.13 数组访问表达式
15.14 后缀表达式
15.15 一元运算符
15.16 强制转换表达式
15.17 乘法运算符
15.18 加运算符
15.19 移位运算符
15.20 关系运算符
15.21 相等运算符
15.22 位和逻辑运算符
15.23 条件与运算符&&
15.24 条件或运算符2
15.25 条件运算符?
15.26 赋值运算符
15.27 表达式
15.28 常量表达式
第16章 明确赋值
16.1 明确赋值和表达式
16.2 语明确赋值和语句
16.3 明确赋值和参数
16.4 明确赋值和数组初始化方法
16.5 明确赋值和枚举常量
16.6 明确赋值和匿名类
16.7 明确赋值和成员类型
16.8 明确赋值和静态初始化方法
16.9 明确赋值、构造函数和实例初始化方法
第17章 线程和锁
17.1 锁
17.2 示例中的符号
17.3 不正确同步的程序出现意外行为
17.4 内存模型
17.5 Final字段语义
17.6 字分开
17.7 double和long的非原子处理
17.8 等待集合和通知
17.9 休眠和转交
第18章 语法
18.1 Java编程语言的语法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java编程规范
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 8编程入门官方教程
目录
第1章 Java基础 1
1.1 Java的起源 2
1.1.1 Java与C和C++的关系 3
1.1.2 Java与C#的关系 3
1.2 Java对Internet的贡献 4
1.2.1 Java applet 4
1.2.2 安全性 4
1.2.3 可移植性 5
1.3 Java的魔法：字节码 5
1.4 Java的主要术语 6
1.5 面向对象程序设计 7
1.5.1 封装 8
1.5.2 多态性 8
1.5.3 继承 9
1.6 获得Java开发工具包 9
1.7 第一个简单的程序 10
1.7.1 输入程序 10
1.7.2 编译程序 11
1.7.3 逐行分析第一个程序 11
1.8 处理语法错误 13
1.9 第二个简单程序 14
1.10 另一种数据类型 16
1.11 两条控制语句 18
1.11.1 if语句 18
1.11.2 for循环语句 20
1.12 创建代码块 21
1.13 分号和定位 22
1.14 缩进原则 23
1.15 Java关键字 25
1.16 Java标识符 25
1.17 Java类库 26
第2章 数据类型与运算符 29
2.1 数据类型为什么重要 30
2.2 Java的基本类型 30
2.2.1 整数类型 31
2.2.2 浮点型 32
2.2.3 字符型 33
2.2.4 布尔类型 34
2.3 字面值 36
2.3.1 十六进制、八进制和二进制字面值 36
2.3.2 字符转义序列 37
2.3.3 字符串字面值 37
2.4 变量详解 38
2.4.1 初始化变量 39
2.4.2 动态初始化 39
2.5 变量的作用域和生命期 39
2.6 运算符 42
2.7 算术运算符 42
2.8 关系运算符和逻辑运算符 44
2.9 短路逻辑运算符 46
2.10 赋值运算符 47
2.11 速记赋值 47
2.12 赋值中的类型转换 48
2.13 不兼容类型的强制转换 50
2.14 运算符优先级 51
2.15 表达式 53
2.15.1 表达式中的类型转换 53
2.15.2 间距和圆括号 55
第3章 程序控制语句 57
3.1 从键盘输入字符 58
3.2 if语句 59
3.2.1 嵌套if语句 60
3.2.2 if-else-if阶梯状结构 61
3.3 switch语句 62
3.4 for循环 68
3.4.1 for循环的一些变体 69
3.4.2 缺失部分要素的for循环 70
3.4.3 无限循环 71
3.4.4 没有循环体的循环 72
3.4.5 在for循环内部声明循环控制变量 72
3.4.6 增强型for循环 73
3.5 while循环 73
3.6 do-while循环 75
3.7 使用break语句退出循环 79
3.8 将break语句作为一种goto语句使用 81
3.9 使用continue语句 85
3.10 嵌套循环 89
第4章 类、对象和方法 93
4.1 类的基础知识 94
4.1.1 类的基本形式 94
4.1.2 定义类 95
4.2 如何创建对象 98
4.3 引用变量和赋值 98
4.4 方法 99
4.5 从方法返回值 101
4.6 返回值 102
4.7 使用形参 104
4.8 构造函数 112
4.9 带形参的构造函数 113
4.10 深入介绍new运算符 115
4.11 垃圾回收 115
4.12 this关键字 119
第5章 其他数据类型与运算符 123
5.1 数组 124
5.2 多维数组 129
5.3 不规则数组 130
5.3.1 三维或更多维的数组 131
5.3.2 初始化多维数组 131
5.4 另一种声明数组的语法 132
5.5 数组引用赋值 133
5.6 使用length成员 134
5.7 for-each形式的循环 139
5.7.1 迭代多维数组 142
5.7.2 应用增强型for循环 143
5.8 字符串 144
5.8.1 构造字符串 144
5.8.2 操作字符串 145
5.8.3 字符串数组 147
5.8.4 字符串是不可变的 148
5.8.5 使用String控制switch语句 149
5.9 使用命令行实参 150
5.10 位运算符 151
5.10.1 位运算符的与、或、异
或和非 151
5.10.2 移位运算符 155
5.10.3 位运算符的赋值速记符 157
5.11 ?运算符 160
第6章 方法和类详解 163
6.1 控制对类成员的访问 164
6.2 向方法传递对象 169
6.3 返回对象 173
6.4 方法重载 174
6.5 重载构造函数 179
6.6 递归 184
6.7 理解static关键字 186
6.8 嵌套类和内部类 192
6.9 varargs(可变长度实参) 195
6.9.1 varargs基础 195
6.9.2 重载varargs方法 198
6.9.3 varargs和歧义 199
第7章 继承 203
7.1 继承的基础知识 204
7.2 成员访问与继承 207
7.3 构造函数和继承 209
7.4 使用super调用超类构造函数 211
7.5 使用super访问超类成员 215
7.6 创建多级层次结构 218
7.7 何时调用构造函数 221
7.8 超类引用和子类对象 222
7.9 方法重写 227
7.10 重写的方法支持多态性 229
7.11 为何使用重写方法 231
7.12 使用抽象类 235
7.13 使用final 239
7.13.1 使用final防止重写 239
7.13.2 使用final防止继承 239
7.13.3 对数据成员使用final 240
7.14 Object类 241
第8章 包和接口 243
8.1 包 244
8.1.1 定义包 244
8.1.2 寻找包和CLASSPATH 245
8.1.3 一个简短的包示例 245
8.2 包和成员访问 247
8.3 理解被保护的成员 249
8.4 导入包 251
8.5 Java的类库位于包中 252
8.6 接口 253
8.7 实现接口 254
8.8 使用接口引用 257
8.9 接口中的变量 264
8.10 接口能够被扩展 265
8.11 默认接口方法 266
8.11.1 默认方法的基础知识 266
8.11.2 默认方法的实际应用 268
8.11.3 多继承问题 269
8.12 在接口中使用静态方法 270
8.13 有关包和接口的最后思考 271
第9章 异常处理 273
9.1 异常的层次结构 274
9.2 异常处理基础 274
9.2.1 使用关键字try和catch 275
9.2.2 一个简单的异常示例 276
9.3 未捕获异常的结果 277
9.4 使用多个catch语句 280
9.5 捕获子类异常 281
9.6 try代码块可以嵌套 282
9.7 抛出异常 283
9.8 Throwable详解 285
9.9 使用finally 286
9.10 使用throws语句 288
9.11 新增的3种异常功能 289
9.12 Java的内置异常 291
9.13 创建异常子类 293
第10章 使用I/O 299
10.1 Java的I/O基于流 300
10.2 字节流和字符流 300
10.3 字节流类 301
10.4 字符流类 301
10.5 预定义流 302
10.6 使用字节流 302
10.6.1 读取控制台输入 303
10.6.2 写入控制台输出 304
10.7 使用字节流读写文件 305
10.7.1 从文件输入 305
10.7.2 写入文件 309
10.8 自动关闭文件 311
10.9 读写二进制数据 313
10.10 随机访问文件 317
10.11 使用Java字符流 319
10.11.1 使用字符流的控制台输入 320
10.11.2 使用字符流的控制台输出 323
10.12 使用字符流的文件I/O 324
10.12.1 使用FileWriter 324
10.12.2 使用FileReader 325
10.13 使用Java的类型封装器转换数值字符串 326
第11章 多线程程序设计 337
11.1 多线程的基础知识 338
11.2 Thread类和Runnable接口 339
11.3 创建一个线程 339
11.4 创建多个线程 346
11.5 确定线程何时结束 348
11.6 线程的优先级 351
11.7 同步 354
11.8 使用同步方法 354
11.9 同步语句 357
11.10 使用notify( )、wait( )和notifyAll( )的线程通信 360
11.11 线程的挂起、继续执行和停止 365
第12章 枚举、自动装箱、静态导入和注释 371
12.1 枚举 372
12.2 Java语言中的枚举是类类型 374
12.3 values( )和valueOf( )方法 374
12.4 构造函数、方法、实例变量和枚举 376
12.5 枚举继承enum 378
12.6 自动装箱 384
12.7 类型封装器 385
12.8 自动装箱的基础知识 386
12.9 自动装箱和方法 387
12.10 发生在表达式中的自动装箱/自动拆箱 388
12.11 静态导入 390
12.12 注解(元数据) 393
第13章 泛型 397
13.1 泛型的基础知识 398
13.2 一个简单的泛型示例 399
13.2.1 泛型只能用于引用类型 402
13.2.2 泛型类型是否相同基于其类型实参 402
13.2.3 带有两个类型形参的泛型类 402
13.2.4 泛型类的一般形式 404
13.3 约束类型 404
13.4 使用通配符实参 407
13.5 约束通配符 410
13.6 泛型方法 413
13.7 泛型构造函数 415
13.8 泛型接口 416
13.9 原类型和遗留代码 422
13.10 使用菱形运算符进行类型推断 425
13.11 擦除特性 426
13.12 歧义错误 426
13.13 一些泛型限制 427
13.13.1 类型形参不能实例化 427
13.13.2 对静态成员的限制 428
13.13.3 泛型数组限制 428
13.13.4 泛型异常限制 429
13.14 继续学习泛型 429
第14章 lambda表达式和方法引用 431
14.1 lambda表达式简介 432
14.1.1 lambda表达式的基础知识 432
14.1.2 函数式接口 433
14.1.3 几个lambda表达式示例 435
14.2 块lambda表达式 440
14.3 泛型函数式接口 441
14.4 lambda表达式和变量捕获 447
14.5 从 lambda表达式中抛出异常 448
14.6 方法引用 449
14.6.1 静态方法的方法引用 449
14.6.2 实例方法的方法引用 451
14.7 构造函数引用 455
14.8 预定义的函数式接口 457
第15章 applet、事件和其他主题 461
15.1 applet的基础知识 462
15.2 applet的组织和基本构件 465
15.3 applet架构 465
15.4 完整的applet框架 465
15.5 applet的初始化与终止 467
15.6 请求重绘 467
15.7 使用状态窗口 472
15.8 向applet传递形参 473
15.9 Applet类 474
15.10 事件处理 476
15.11 委派事件模型 476
15.12 事件 476
15.12.1 事件源 476
15.12.2 事件侦听器 477
15.12.3 事件类 477
15.12.4 事件侦听器接口 478
15.13 使用委派事件模型 479
15.13.1 处理鼠标事件和鼠标移动事件 479
15.13.2 一个简单的鼠标事件applet 480
15.14 其他Java关键字 482
15.14.1 transient和volatile修饰符 483
15.14.2 instanceof 483
15.14.3 strictfp 483
15.14.4 assert 483
15.14.5 native方法 484
第16章 Swing介绍 487
16.1 Swing的起源和设计原则 488
16.2 组件和容器 490
16.2.1 组件 490
16.2.2 容器 491
16.2.3 顶级容器窗格 491
16.3 布局管理器 491
16.4 第一个简单的Swing程序 492
16.5 使用JButton 497
16.6 使用JTextField 500
16.7 使用JCheckBox 504
16.8 使用JList 507
15.9 使用匿名内部类或lambda表达式来处理事件 515
16.10 创建Swing applet 517
第17章 JavaFX简介 521
17.1 JavaFX的基本概念 522
17.1.1 JavaFX包 522
17.1.2 Stage和Scene类 523
17.1.3 节点和场景图 523
17.1.4 布局 523
17.1.5 Application类和生命周期方法 523
17.1.6 启动JavaFX应用程序 524
17.2 JavaFX应用程序的骨架 524
17.3 编译和运行JavaFX程序 527
17.4 应用程序线程 527
17.5 使用简单的JavaFX控件Label 528
17.6 使用按钮和事件 530
17.6.1 事件基础 530
17.6.2 按钮控件简介 531
17.6.3 演示事件处理和按钮 531
17.7 其他3个JavaFX控件 534
17.7.1 CheckBox 534
17.7.2 ListView 538
17.7.3 TextField 543
17.8 效果和变换简介 546
17.8.1 效果 546
17.8.2 变换 548
17.8.3 演示效果和变换 549
17.9 进一步学习 552
附录A 自测题答案 555
附录B 使用Java的文档注释 599
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 8编程入门官方教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web服务：构建与运行
前言	I
第1章 Java Web服务快速入门	1
1.1 什么是Web服务	1
1.2 第一个例子	4
1.3 由Perl和Ruby语言实现的Web服务客户端	10
1.4 了解SOAP	11
1.5 Java语言实现Web服务请求	13
1.6 基于通信层的HTTP和SOAP消息跟踪	14
1.7 目前为止还有什么不清楚	16
1.8 Java SOAP编程API	18
1.9 带有复杂数据类型的Web服务	23
1.10 多线程端点服务发布程序	27
1.11 下一章	30
第2章 全面了解WSDL	31
2.1 WSDL在Web服务中的作用	31
2.2 WSDL文档结构	36
2.3 Amazon E-Commerce Web服务	46
2.4 wsgen工具与JAX-B工件（Artifacts）	59
2.5 WSDL总结	69
2.6 下一章	80
第3章 SOAP消息编程	81
3.1 SOAP是否真地不可见	81
3.2 在SOAP 1.2下实现RabbitCounter服务	102
3.3 MessageContext和传输头	104
3.4 Web服务与二进制数据传输	109
3.5 下一章	119
第4章 REST风格的Web服务	121
4.1 什么是Rest	121
4.2 从@WebService到@WebServiceProvider	125
4.3 RESTful版本的Teams服务	126
4.4 Provider和Dispatch	148
4.5 利用HttpServlets实现RESTful Web服务	159
4.6 基于现实世界中RESTful服务编写的Java客户端..	167
4.7 基于Java的RESTful服务的WADL支持	177
4.8 JAX-RS：利用Jersey生成WADL	182
4.9 Restlet框架	186
4.10 下一章	191
第5章 Web服务安全	193
5.1 Web服务安全概述	193
5.2 线路级（Wire-Level）安全	194
5.3 为RabbitCounter服务添加安全支持	203
5.4 Web服务容器管理的安全	212
5.5 WS-Security	227
5.6 下一章	238
第6章 Java应用服务器中的JAX-WS	239
6.1 Java应用服务器概述	239
6.2 部署@WebServices和@WebServiceProviders	244
6.3 整合一个交互式网站和Web服务	250
6.4 将@WebService作为一个EJB实现	252
6.5 Java Web服务和Java消息服务	262
6.6 基于GlassFish WS-Security	265
6.7 JAS部署所带来的好处	280
6.8 下一章	281
第7章 除了争论，还有什么	283
7.1 Web服务发展的简短历程	283
7.2 SOAP-Based Web服务对比Distributed Objects	287
7.3 SOAP和REST的融合	288
索引	 291
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web服务：构建与运行
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE设计模式
第1章　企业级java应用程序架构和设计
简介	1
1.1　分布式计算的发展历程	1
1.1.1　单层架构	2
1.1.2　两层架构	2
1.1.3　三层架构	2
1.1.4　多层架构	4
1.1.5　java ee架构	4
1.2　java ee应用程序设计	8
1.3　java ee设计模式目录	9
1.4　使用uml描述java ee架构和设计	10
1.4.1　类图	10
1.4.2　序列图	12
1.5　小结	13
第2章　使用spring框架简化企业级java
应用程序	14
2.1　什么是spring	14
2.2　为什么spring很重要	14
2.3　spring框架的组成部分	16
2.3.1　spring core	16
.2.3.2　spring aop	22
2.3.3　spring dao	23
2.3.4　spring orm	23
2.3.5　jee	23
2.3.6　web mvc	23
2.4　使用spring构建分层应用程序	23
2.4.1　表现层	24
2.4.2　业务层	25
2.4.3　集成层	25
2.5　spring java设计模式讲解模板	26
2.5.1　名称	26
2.5.2　问题描述	26
2.5.3　模式目的	26
2.5.4　解决方案	26
2.5.5　模式评价	26
2.6　小结	26
第3章　表现层设计模式	27
3.1　前端控制器	28
3.1.1　问题描述	28
3.1.2　模式目的	30
3.1.3　解决方案	30
3.1.4　模式评价	33
3.2　应用程序控制器	33
3.2.1　问题描述	33
3.2.2　模式目的	34
3.2.3　解决方案	34
3.2.4　模式评价	46
3.3　页面控制器	47
3.3.1　问题描述	47
3.3.2　模式目的	47
3.3.3　解决方案	47
3.3.4　模式评价	63
3.4　上下文对象模式	64
3.4.1　问题描述	64
3.4.2　模式目的	64
3.4.3　解决方案	64
3.4.4　模式评价	70
3.5　拦截过滤器模式	70
3.5.1　问题描述	70
3.5.2　模式目的	70
3.5.3　解决方案	71
3.5.4　模式评价	76
3.6　视图助手模式	76
3.6.1　问题描述	76
3.6.2　模式目的	76
3.6.3　解决方案	77
3.6.4　模式评价	84
3.7　组合视图模式	85
3.7.1　问题描述	85
3.7.2　模式目的	85
3.7.3　解决方案	85
3.7.4　模式评价	89
3.8　分发者视图模式	89
3.8.1　问题描述	89
3.8.2　模式目的	89
3.8.3　解决方案	90
3.8.4　模式评价	94
3.9　服务到工作者模式	94
3.9.1　问题描述	94
3.9.2　模式目的	94
3.9.3　解决方案	95
3.9.4　模式评价	95
3.10　小结	96
第4章　业务层设计模式	97
4.1　服务定位器模式	97
4.1.1　问题描述	97
4.1.2　模式目的	100
4.1.3　解决方案	100
4.1.4　模式评价	109
4.2　业务代理模式	109
4.2.1　问题描述	109
4.2.2　模式目的	109
4.2.3　解决方案	109
4.2.4　模式评价	111
4.3　会话外观模式	112
4.3.1　问题描述	112
4.3.2　模式目的	112
4.3.3　解决方案	112
4.3.4　模式评价	116
4.4　应用程序服务模式	117
4.4.1　问题描述	117
4.4.2　模式目的	117
4.4.3　解决方案	118
4.4.4　模式评价	120
4.5　业务接口模式	121
4.5.1　问题描述	121
4.5.2　模式目的	121
4.5.3　解决方案	121
4.5.4　模式评价	127
4.6　小结	127
第5章　集成层设计模式	128
5.1　数据访问对象模式	128
5.1.1　问题描述	128
5.1.2　模式目的	131
5.1.3　解决方案	131
5.1.4　模式评价	140
5.2　过程访问对象模式	140
5.2.1　问题描述	140
5.2.2　模式目的	140
5.2.3　解决方案	140
5.2.4　模式评价	143
5.3　服务触发器模式	143
5.3.1　问题描述	143
5.3.2　模式目的	144
5.3.3　解决方案	144
5.3.4　模式评价	151
5.4　web服务代理模式	151
5.4.1　问题描述	151
5.4.2　模式目的	151
5.4.3　解决方案	152
5.4.4　模式评价	161
5.5　小结	161
第6章　横切设计模式	162
6.1　验证和授权实施者模式	163
6.1.1　问题描述	163
6.1.2　模式目的	164
6.1.3　解决方案	164
6.1.4　模式评价	182
6.2　审核拦截器模式	182
6.2.1　问题描述	182
6.2.2　模式目的	182
6.2.3　解决方案	183
6.2.4　模式评价	189
6.3　域服务所有者事务模式	189
6.3.1　问题描述	189
6.3.2　模式目的	189
6.3.3　解决方案	190
6.3.4　模式评价	197
6.4　小结	197
第7章　案例研究：构建订单管理系统	198
7.1　需求	198
7.1.1　用户故事卡：用户登录	199
7.1.2　用户故事卡：查询服务	199
7.1.3　用户故事卡：保存订单	199
7.2　迭代规划	199
7.3　架构	200
7.3.1　表现层	200
7.3.2　业务层	201
7.3.3　集成层	202
7.4　设计	202
7.5　安全机制	203
7.5.1　问题描述	203
7.5.2　模式目的	203
7.5.3　解决方案	203
7.6　jsp	203
7.6.1　问题描述	203
7.6.2　模式目的	204
7.6.3　解决方案	204
7.7　页面控制器	204
7.7.1　问题描述	204
7.7.2　模式目的	204
7.7.3　解决方案	204
7.8　开发	205
7.8.1　创建工作区	206
7.8.2　创建项目	207
7.8.3　添加依赖关系	208
7.8.4　构建项目	210
7.8.5　部署项目	219
7.9　小结	227
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>经典Java EE企业应用实战
第0章 学习Java的正确方法 1
0.1 我适合不适合编程 2
0.2 走出象牙塔 4
0.3 学习Java，应该如此疯狂 7
第1篇 基础知识
第1章 经典Java EE应用和开发环境 9
1.1 经典Java EE应用概述 10
1.1.1 Java EE 6相关规范 10
1.1.2 经典Java EE应用的分层模型 11
1.1.3 经典Java EE应用的组件 13
1.1.4 经典Java EE应用架构的优势 13
1.1.5 常用的企业服务器 14
1.2 经典Java EE应用相关技术 14
1.2.1 JSP、Servlet和JavaBean及替代技术 14
1.2.2 JSF及替代技术 15
1.2.3 EJB组件技术简介 15
1.3 JBoss的下载和安装 15
1.3.1 下载和安装JBoss服务器 16
1.3.2 配置JBoss的服务端口 18
1.3.3 进入控制台 19
.1.3.4 部署Web应用 22
1.4 WebLogic的下载和安装 24
1.4.1 WebLogic的下载和安装 24
1.4.2 WebLogic的基本配置 25
1.4.3 修改WebLogic的服务端口 29
1.4.4 部署Web应用 30
1.5 NetBeans的安装和使用 32
1.5.1 NetBeans的下载和安装 32
1.5.2 使用NetBeans开发Java EE应用 33
1.5.3 打开NetBeans项目 36
1.5.4 导入Eclipse项目 37
1.6 使用SVN进行协作开发 38
1.6.1 下载和安装SVN服务器 39
1.6.2 配置SVN资源库 39
1.6.3 下载和安装SVN客户端 41
1.6.4 发布项目到服务器 41
1.6.5 从服务器下载项目 42
1.6.6 提交（Commit）修改 42
1.6.7 同步（Update）本地文件 43
1.6.8 添加文件和目录 44
1.6.9 删除文件和目录 45
1.6.10 查看文件或目录的版本变革 45
1.6.11 从以前版本重新开始 46
1.6.12 创建分支 46
1.6.13 沿着分支开发 46
1.6.14 合并分支 47
1.6.15 使用NetBeans作为SVN客户端 48
1.7 本章小结 50
第2篇 整合开发
第2章 JSF的基本用法 51
2.1 MVC和JSF 52
2.1.1 MVC和常见MVC框架 52
2.1.2 JSF的优势 56
2.2 下载和安装JSF 57
2.3 JSF使用入门 60
2.3.1 从输入页面开始 60
2.3.2 开发托管Bean 61
2.3.3 定义导航规则 63
2.4 解读JSF配置 65
2.4.1 配置核心控制器（FacesServlet） 65
2.4.2 JSF配置文件结构 68
2.5 托管Bean和表达式语言 69
2.5.1 托管Bean的属性和表达式语言 69
2.5.2 托管Bean的方法 78
2.5.3 托管Bean的分类 80
2.5.4 初始化托管Bean的属性 85
2.5.5 通过FacesContext访问应用环境 89
2.6 导航模型 91
2.6.1 静态导航 93
2.6.2 动态导航 93
2.7 使用UI标签创建视图页面 94
2.7.1 UI标签概述 94
2.7.2 UI标签的通用属性 97
2.7.3 表单相关标签 98
2.7.4 其他标签 103
2.8 JSF的运行流程和生命周期 109
2.8.1 恢复视图阶段 110
2.8.2 应用请求值阶段 110
2.8.3 处理输入校验阶段 111
2.8.4 更新模型的值阶段 111
2.8.5 调用应用阶段 111
2.8.6 生成响应阶段 111
2.9 利用JSF的消息 112
2.10 本章小结 116
第3章 深入使用JSF 117
3.1 JSF事件机制 118
3.1.1 Java事件模型概述 118
3.1.2 Java事件模型示例 119
3.1.3 JSF事件模型 120
3.1.4 Action事件 122
3.1.5 值改变事件 125
3.1.6 生命周期事件 128
3.1.7 将监听器绑定到Bean属性 130
3.2 JSF的国际化支持 132
3.2.1 加载国际化资源文件 132
3.2.2 使用国际化消息 134
3.2.3 动态数据国际化 137
3.2.4 让用户选择语言 142
3.3 使用转换器完成类型转换 143
3.3.1 转换器概述、用途 144
3.3.2 JSF内建转换器 144
3.3.3 使用转换器 145
3.3.4 转换失败后的错误消息 149
3.4 自定义转换器 154
3.4.1 实现转换器类 154
3.4.2 注册转换器 156
3.4.3 使用自定义转换器 159
3.4.4 绑定到Bean属性的转换器 159
3.5 使用验证器进行输入校验 161
3.5.1 输入校验概述 161
3.5.2 JSF内置校验器 162
3.5.3 校验失败后的错误消息 163
3.5.4 必填校验器 165
3.6 自定义校验器 166
3.6.1 开发自定义校验器 166
3.6.2 注册校验器 167
3.6.3 使用自定义校验器 168
3.6.4 为自定义校验器开发专用标签 169
3.6.5 使用托管Bean的方法执行校验 173
3.6.6 绑定到Bean属性的校验器 175
3.7 本章小结 177
第4章 利用JDBC和JTA访问数据库和管理全局事务 178
4.1 JDBC和容器管理的数据源 179
4.1.1 JDBC概述 179
4.1.2 使用JDBC执行数据库访问 180
4.1.3 使用WebLogic服务器管理的数据源 182
4.1.4 使用JBoss服务器管理的数据源 187
4.2 事务和JTA 191
4.2.1 事务的基本概念 191
4.2.2 分布式事务处理、XA规范和
2PC协议 192
4.2.3 使用JTA全局事务保证多数据库的一致性 193
4.3 事务隔离、传播属性的设置 198
4.3.1 并发访问和隔离 198
4.3.2 事务属性 199
4.4 EJB的事务管理 201
4.4.1 容器管理事务（CMT） 201
4.4.2 Bean管理事务（BMT） 201
4.5 事务超时设置 201
4.6 本章小结 203
第5章 JNDI和远程方法调用 204
5.1 JNDI的概念 205
5.1.1 命名服务 205
5.1.2 目录服务 206
5.1.3 JNDI的优点 206
5.2 JNDI编程入门 207
5.2.1 文件系统的命名服务 207
5.2.2 JNDI编程 208
5.3 服务器提供的JNDI支持 212
5.3.1 WebLogic的JNDI支持 212
5.3.2 JBoss的JNDI支持 215
5.4 RMI概述 216
5.4.1 RMI的相关概念 216
5.4.2 RMI的作用和意义 217
5.5 RMI编程 217
5.5.1 开发RMI服务器 217
5.5.2 开发RMI客户端 220
5.5.3 RMI的基本原理 220
5.6 同时作为客户端和服务器的RMI程序 222
5.6.1 开发客户端程序 222
5.6.2 开发服务器端程序 223
5.7 本章小结 225
第6章 利用JMS实现企业消息处理 226
6.1 面向消息的架构和JMS概述 227
6.1.1 面向消息的应用架构 227
6.1.2 JMS的基础知识和优势 228
6.1.3 JMS的两个重要版本 229
6.2 PTP类型的JMS 230
6.2.1 配置PTP的JMS服务器 231
6.2.2 PTP消息的发送 241
6.2.3 PTP消息的同步接收 244
6.2.4 PTP消息的异步接收 246
6.3 Pub-Sub类型的JMS 248
6.3.1 配置Pub-Sub模型的JMS服务器 248
6.3.2 消息的生产、消费 250
6.3.3 可靠的JMS订阅 251
6.4 JMS消息 253
6.4.1 JMS消息类型 253
6.4.2 JMS消息头和消息属性 253
6.4.3 重用消息对象 254
6.4.4 JMS传递方式和有效时间 255
6.4.5 设置消息的优先级 256
6.4.6 消息的确认方式 256
6.4.7 消息选择器 257
6.4.8 消息的临时目的 261
6.5 使用队列浏览器查看全部消息 264
6.6 JMS和事务 265
6.6.1 使用事务性Session 265
6.6.2 利用JTA全局事务 267
6.7 JMS服务器的异常监听 268
6.8 JMS集群 269
6.9 本章小结 270
第7章 利用JavaMail实现E-mail 271
7.1 E-mail简介 272
7.1.1 SMTP协议简介 272
7.1.2 POP3协议简介 272
7.1.3 IMAP4协议简介 273
7.1.4 E-mail的用途 273
7.2 JavaMail介绍 274
7.2.1 JavaMail下载和安装 274
7.2.2 JavaMail的常用API 275
7.2.3 使用JavaMail发送邮件 277
7.2.4 使用JavaMail接收邮件 281
7.3 应用服务器的JavaMail支持 287
7.3.1 在WebLogic中配置JavaMail 288
7.3.2 通过WebLogic的邮件支持来发送邮件 290
7.3.3 在JBoss中配置JavaMail 292
7.4 本章小结 294
第8章 会话EJB 295
8.1 EJB概述 296
8.1.1 EJB的概念和意义 296
8.1.2 EJB的发展历史 298
8.1.3 EJB的优势和使用场景 299
8.2 EJB的分类 301
8.2.1 Session Bean的概念和作用 302
8.2.2 Message Driven Bean的概念和作用 303
8.2.3 实体和JPA 303
8.3 开发无状态的Session Bean 304
8.3.1 开发远程调用的无状态Session Bean 304
8.3.2 开发本地调用的无状态Session Bean 311
8.4 发布Session Bean 314
8.4.1 打包EJB-JAR 315
8.4.2 Annotation与部署描述文件 315
8.5 开发有状态的Session Bean 318
8.6 Session Bean的生命周期 321
8.6.1 无状态Session Bean的生命周期 321
8.6.2 有状态Session Bean的生命周期 322
8.6.3 定制Session Bean的生命周期行为 323
8.7 在Session Bean中使用事务 327
8.7.1 容器管理事务 327
8.7.2 Bean管理事务 330
8.8 拦截器 332
8.9 依赖注入 335
8.9.1 EJB注入 336
8.9.2 资源注入 339
8.10 配置EJB引用 340
8.11 使用计时器进行任务调度 342
8.12 本章小结 345
第9章 消息驱动EJB 346
9.1 JMS和EJB 347
9.1.1 为什么使用MDB 347
9.1.2 使用MDB的设计原则 348
9.2 使用消息驱动Bean 349
9.2.1 使用@MessageDriven和@ActivationConfigProperty 350
9.2.2 实现MessageListener 352
9.2.3 MDB的生命周期 353
9.2.4 MDB中的依赖注入 356
9.2.5 事务管理和异常处理 359
9.3 使用NetBeans开发EJB 359
9.3.1 使用NetBeans开发Session Bean 359
9.3.2 使用NetBeans开发MDB 362
9.4 本章小结 363
第10章 Java持久化API（JPA） 364
10.1 实体简介 365
10.1.1 对象/关系数据库映射（ORM） 365
10.1.2 JPA的映射规则 367
10.1.3 JPA规范简介 368
10.2 实体入门 368
10.2.1 开发实体 369
10.2.2 在Java SE环境下使用Hibernate JPA实现 370
10.2.3 在Java SE环境下使用TopLink JPA实现 374
10.2.4 在Java SE环境下使用EntityManager 377
10.2.5 使用orm.xml管理O/R映射 379
10.3 理解实体 382
10.3.1 持久化上下文和持久化单元 382
10.3.2 实体类的要求 382
10.3.3 实体的状态 383
10.3.4 管理实体的方法 384
10.4 实体的基本映射 387
10.4.1 映射实体类的属性 387
10.4.2 将实体映射到多个表 394
10.4.3 映射复合类型的属性 396
10.4.4 映射实体类的主键 398
10.5 关联关系映射 402
10.5.1 单向N－1关联 403
10.5.2 单向1－1关联 406
10.5.3 单向1－N关联 409
10.5.4 单向N－N关联 411
10.5.5 双向1－1关联 414
10.5.6 双向1－N关联 417
10.5.7 双向N－N关联 420
10.5.8 使用Map集合记录关联实体 423
10.5.9 对关联实体进行排序 424
10.6 继承关系映射 426
10.6.1 整个类层次对应一张表的映射策略 427
10.6.2 连接子类的映射策略 430
10.6.3 每个具体类对应一张表的映射策略 434
10.7 使用抽象实体和非实体父类 436
10.7.1 抽象实体 436
10.7.2 非实体父类 438
10.7.3 重定义子类实体的外键列 440
10.8 实体的生命周期和监听器 444
10.8.1 实体的生命周期与回调事件 444
10.8.2 使用专门的监听器实现回调 448
10.8.3 为全部实体配置默认监听器 450
10.8.4 排除监听器 452
10.9 本章小结 455
第11章 JPA的查询支持 456
11.1 查询API 457
11.1.1 面向对象的JPQL 457
11.1.2 查询API简介 457
11.2 执行查询 459
11.2.1 使用Query创建查询 459
11.2.2 设置查询参数 459
11.2.3 取得查询结果 460
11.3 JPQL语法 461
11.3.1 使用from子句 462
11.3.2 使用select子句 463
11.3.3 查询部分属性 463
11.3.4 查询中使用构造器 464
11.3.5 使用distinct排除相同的记录 465
11.3.6 where子句和条件表达式 466
11.3.7 使用JPQL函数 466
11.3.8 多态查询 467
11.3.9 关联和连接 469
11.3.10 使用order by进行结果排序 473
11.3.11 JPQL查询的聚集函数 473
11.3.12 使用group by进行分组 474
11.3.13 结果集分页 475
11.3.14 使用子查询 475
11.3.15 命名查询 476
11.4 批量更新和批量删除 478
11.4.1 批量更新 479
11.4.2 批量删除 480
11.5 原生SQL查询 481
11.5.1 使用原生SQL查询 481
11.5.2 结果集映射和实体查询 482
11.5.3 使用命名的原生SQL查询 486
11.5.4 调用存储过程 488
11.6 本章小结 490
第12章 Web层和EJB的整合 491
12.1 Java EE应用的架构 492
12.1.1 SSH架构的复习和应用架构的思考 492
12.1.2 MVC层和业务层整合 494
12.1.3 DAO模式和EAO模式 495
12.1.4 使用Session Facade模式 499
12.2 从Web层访问Session Bean 500
12.2.1 使用依赖注入访问无状态Session Bean 501
12.2.2 通过EJB引用访问有状态Session Bean 507
12.2.3 在工具类中调用Session Bean 509
12.3 在Web层使用JPA 511
12.3.1 使用容器管理的EntityManager 512
12.3.2 在容器内使用应用程序管理的EntityManager 516
12.3.3 通过ThreadLocal在容器外使用安全的EntityManager 518
12.4 基于JBoss的JSF+EJB 3+JPA整合 522
12.4.1 开发JPA实体 522
12.4.2 开发EAO对象 524
12.4.3 开发业务逻辑组件 526
12.4.4 定义JSF的托管Bean来处理请求 527
12.5 基于WebLogic的Struts 2+EJB 3+JPA整合 531
12.5.1 开发实体并配置持久化单元 531
12.5.2 开发EAO组件和业务逻辑组件 532
12.5.3 配置EJB引用 532
12.5.4 定义Action来处理用户请求 532
12.6 本章小结 536
第13章 EJB和Web Service 537
13.1 Web Service概述 538
13.1.1 Web Service概述 538
13.1.2 Web Service平台概述 539
13.1.3 Web Service的广泛应用 542
13.2 JAX-WS：Java EE 5 Web Service平台 543
13.2.1 Java EE的Web Service支持 543
13.2.2 为什么选择EJB开发Web Service 544
13.3 使用JAX-WS 2.0开发Web Service 545
13.3.1 使用@WebService 545
13.3.2 使用@WebMethod 551
13.3.3 使用@SOAPBinding指定Web Service风格 553
13.3.4 使用@WebParam 555
13.3.5 使用@WebResult 556
13.3.6 使用@OneWay 558
13.4 客户端调用Web Service 558
13.5 本章小结 559
第14章 利用JAAS开发安全的应用 560
14.1 JAAS概述 561
14.1.1 Java EE应用的安全概述 561
14.1.2 安全域、用户、组和角色概念 561
14.1.3 JAAS的基本流程 563
14.2 管理服务器的用户和组 565
14.2.1 管理WebLogic服务器上的用户和组 565
14.2.2 管理JBoss服务器上的用户和角色 573
14.2.3 使用RDBMS管理Jboss服务器上的用户和角色 574
14.3 开发安全的Web应用 576
14.3.1 声明安全性 576
14.3.2 映射安全角色 579
14.3.3 基于JBoss服务器的表单登录 580
14.3.4 基于WebLogic服务器的安全角色映射 583
14.3.5 基于WebLogic服务器的表单登录 583
14.3.6 Web应用中编程式安全 584
14.4 开发安全的Java EE应用 585
14.4.1 为EJB声明安全性 585
14.4.2 应用客户端访问被保护的方法 587
14.4.3 使用Web组件调用EJB被保护的方法 588
14.4.4 EJB中编程式安全 592
14.5 使用SSL建立安全连接 592
14.5.1 SSL基础知识 593
14.5.2 安装和配置SSL支持 593
14.5.3 在配置描述符中指定安全连接 595
14.6 本章小结 597
第3篇 应用实践
第15章 电子拍卖系统 598
15.1 系统功能简介和架构设计 599
15.1.1 系统功能简介 599
15.1.2 系统架构设计 599
15.2 持久层设计 600
15.2.1 系统实体 601
15.2.2 系统E-R图和数据表 601
15.2.3 实现JPA 实体 603
15.2.4 管理持久化单元 612
15.3 实现系统EAO层 614
15.3.1 实现EAO基类 615
15.3.2 实现系统EAO组件 618
15.4 实现业务逻辑层 622
15.4.1 定义业务逻辑组件接口 622
15.4.2 依赖注入EAO组件 624
15.4.3 业务逻辑组件中的异常处理 625
15.4.4 处理用户竞价 627
15.4.5 判断拍卖物品状态 631
15.4.6 事务管理 633
15.5 实现系统Web层 633
15.5.1 安装JSF 633
15.5.2 处理用户登录 634
15.5.3 图形验证码 639
15.5.4 登录控制 642
15.5.5 添加物品 643
15.5.6 处理用户竞价 650
15.6 使用SiteMesh页面装饰 656
15.6.1 在Web应用中安装SiteMesh 656
15.6.2 定义页面装饰 657
15.7 本章小结 659
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>经典Java EE企业应用实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻快的Java
前言
第一章 不可避免的膨胀
膨胀的缘由
选项
对抗膨胀的五个基本法则
小结
第二章 保持简单
简单化的价值
过程与简单化
你的安全网
小结
第三章 一次做好一件事
了解问题
抽出问题
将框架分层
重构以降低耦合
小结
第四章 力求透明
透明的好处
谁在做主？
透明性的替代方案
反射
注入（Injecting）代码
生成代码
高级主题
小结
第五章 吃什么像什么
黄金槌
了解全貌
技术需求的考虑
小结
第六章 允许扩展
扩展的基础
扩展工具
plug-in模型
谁是客户？
小结
第七章 Hibernate
谎言
Hibernate是什么？
运用持久模型
评估Hibernate
小结
第八章 Spring
Spring是什么？
Pet Store：一个相反的例子
域模型
加入持久化
表示层
小结
第九章 Simple Spider
Spider是什么？
检查需求
计划开发
设计
配置服务
爬站/索引服务
搜索服务
控制台接口
Web服务接口
Spider的扩展
第十章 扩展JPetStore
现有搜索功能的概观
替换控制器
用户界面（JSP）
设置索引程序
运用配置服务
加入Hibernate
小结
第十一章 迈步向前
技术
过程
挑战
结论
参考资料
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻快的Java
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 7入门经典
第1章  Java简介	1
1.1  Java概览	1
1.2  Java语言的特性	2
1.3  学习Java	2
1.3.1  Java程序	3
1.3.2  Java学习路线图	3
1.4  Java环境	4
1.5  Java中的面向对象编程	11
1.5.1  什么是对象	12
1.5.2  如何定义对象类	13
1.5.3  对象操作	15
1.5.4  Java程序语句	17
1.5.5  封装	17
1.5.6  类与数据类型	18
1.5.7  类与子类	18
1.5.8  使用对象的优势	18
1.5.9  标记	18
1.5.10  泛型类	19
1.6  Java程序结构	19
1.6.1  Java的类库	19
1.6.2  Java应用程序	21
1.7  Java和Unicode	23
1.8  小结	24
1.9  资源	25
第2章  程序、数据、变量和计算	27
2.1  数据和变量	27
2.1.1  变量的命名	28
2.1.2  变量名与Unicode	28
2.1.3  变量与类型	29
2.2  整数数据类型	29
2.3  浮点数数据类型	33
2.3.1  浮点数字面量	33
2.3.2  声明浮点型变量	34
2.4  固定变量的值	34
2.5  算术运算	35
2.5.1  整数计算	35
2.5.2  整数除法和余数	40
2.5.3  增量与减量运算符	40
2.5.4  短整数类型的计算	42
2.5.5  整数算术中的错误	43
2.5.6  浮点计算	43
2.5.7  其他浮点算术运算符	44
2.5.8  浮点算术中的错误情况	44
2.5.9  混合算术表达式	45
2.5.10  显式转换	45
2.5.11  赋值中的自动类型转换	46
2.6  op=运算符	46
2.7  数学函数和常量	47
2.8  存储字符	51
2.8.1  字符转义序列	51
2.8.2  字符算术	52
2.9  位运算	54
2.9.1  使用AND和OR运算符	55
2.9.2  使用异或运算符	58
2.9.3  位移操作	59
2.9.4  位操作方法	62
2.10  取值范围为固定整数值集合的
变量	64
2.11  布尔变量	66
2.12  运算符的优先级	67
2.13  程序注释	68
2.14  小结	70
第3章  循环与逻辑	73
3.1  决策	73
3.1.1  比较	74
3.1.2  if语句	74
3.1.3  嵌套的if语句	78
3.1.4  比较枚举值	81
3.2  逻辑运算符	81
3.2.1  逻辑与操作	82
3.2.2  逻辑或操作	84
3.2.3  异或操作	84
3.2.4  布尔非操作	84
3.2.5  使用标准库方法测试字符	85
3.3  条件运算符	86
3.4  switch语句	88
3.5  变量的作用域	94
3.6  循环	96
3.6.1  循环的种类	97
3.6.2  使用浮点值计数	103
3.6.3  嵌套循环	103
3.6.4  continue语句	105
3.6.5  带标签的continue语句	105
3.6.6  在循环中使用break语句	107
3.7  断言	112
3.8  小结	114
第4章  数组与字符串	117
4.1  数组	117
4.1.1  数组变量	118
4.1.2  定义数组	118
4.1.3  数组长度	119
4.1.4  访问数组元素	119
4.1.5  重用数组变量	119
4.1.6  初始化数组	120
4.1.7  使用数组	123
4.1.8  二维数组	126
4.1.9  字符数组	130
4.2  字符串	131
4.2.1  字符串字面量	131
4.2.2  创建String对象	132
4.2.3  字符串数组	134
4.3  字符串操作	135
4.3.1  连接字符串	135
4.3.2  比较字符串	139
4.3.3  字符串排序	144
4.3.4  访问字符串中的字符	146
4.3.5  在字符串中查找字符	148
4.3.6  查找子字符串	149
4.3.7  提取子字符串	152
4.3.8  String对象的修改版本	156
4.3.9  从String对象创建字符
数组	157
4.3.10  使用字符串执行基于集合
的for循环	157
4.3.11  在字符串中获取字节数组
形式的字符	158
4.3.12  从字符数组中创建String
对象	158
4.4  可变字符串	159
4.4.1  创建StringBuffer对象	160
4.4.2  StringBuffer对象的容量	160
4.4.3  为StringBuffer对象修改字
符串的长度	162
4.4.4  增长StringBuffer对象	162
4.4.5  寻找子字符串的位置	164
4.4.6  替换缓冲区中的子字符串	165
4.4.7  插入字符串	165
4.4.8  从可变字符串中提取字符	166
4.4.9  可变字符串的其他操作	167
4.4.10  从StringBuffer对象创建
String对象	167
4.5  小结	169
第5章  定义类	173
5.1  类的定义	173
5.1.1  类定义中的域	174
5.1.2  类定义中的方法	175
5.1.3  访问变量和方法	176
5.1.4  Final域	177
5.2  定义类	177
5.3  定义方法	178
5.3.1  方法的返回值	179
5.3.2  参数列表	179
5.3.3  定义类方法	181
5.3.4  访问方法中的类数据成员	182
5.3.5  变量this	182
5.3.6  初始化数据成员	183
5.4  构造函数	186
5.4.1  默认构造函数	187
5.4.2  创建类的对象	188
5.5  定义和使用类	190
5.6  方法重载	192
5.6.1  多个构造函数	193
5.6.2  使用构造函数复制对象	196
5.7  使用对象	196
5.8  递归	202
5.9  理解包	204
5.9.1  对类打包	204
5.9.2  将类从包添加到程序中	207
5.9.3  程序中的包和名称	208
5.9.4  导入静态类成员	208
5.9.5  标准包	209
5.10  类成员的访问控制	212
5.10.1  使用访问属性	212
5.10.2  设定访问属性	214
5.10.3  选择访问属性	215
5.11  嵌套类	220
5.11.1  静态嵌套类	221
5.11.2  使用非静态嵌套类	225
5.11.3  使用非顶级类的嵌套类	227
5.11.4  本地嵌套类	228
5.12  小结	228
第6章  扩展类与继承	231
6.1  使用已有的类	231
6.2  类继承	233
6.2.1  继承数据成员	233
6.2.2  继承方法	234
6.2.3  覆盖基类方法	237
6.3  @Override标记	239
6.4  选择基类访问属性	239
6.5  多态	240
6.6  多级继承	246
6.7  抽象类	246
6.8  通用超类	247
6.8.1  toString()方法	249
6.8.2  判定对象的类型	249
6.8.3  复制对象	250
6.9  接受可变数目参数的方法	255
6.10  转换对象	256
6.10.1  转换对象的时机	258
6.10.2  识别对象	259
6.11  枚举进阶	260
6.12  设计类	264
6.13  使用final修饰符	274
6.14  接口	275
6.14.1  在程序中封装常量	275
6.14.2  用接口声明方法	278
6.14.3  扩展接口	281
6.14.4  使用接口	282
6.14.5  将接口类型作为方法的
参数使用	288
6.14.6  在接口定义中嵌套类	289
6.14.7  接口与真实环境	289
6.15  匿名类	289
6.16  小结	290
第7章  异常	293
7.1  异常的基本思想	293
7.2  异常类型	294
7.2.1  Error类型的异常	295
7.2.2  RuntimeException类型的
异常	295
7.2.3  Exception类的其他子类	295
7.3  处理异常	295
7.3.1  设定方法能够抛出的异常	296
7.3.2  处理异常	296
7.3.3  try代码块	296
7.3.4  catch代码块	297
7.3.5  在一个代码块中捕获多种
异常类型	301
7.3.6  finally代码块	301
7.3.7  构造方法	302
7.3.8  执行顺序	303
7.3.9  嵌套的try代码块	309
7.3.10  重新抛出异常	309
7.4  异常对象	310
7.4.1  Throwable类	310
7.4.2  标准异常	313
7.5  定义自己的异常	313
7.5.1  定义异常类	313
7.5.2  抛出自己的异常	315
7.5.3  异常的抛出策略	315
7.6  小结	320
第8章  理解流	323
8.1  流与输入输出操作	323
8.2  流的概念	324
8.2.1  输入流与输出流	324
8.2.2  二进制流与字符流	325
8.3  输入输出类	326
8.3.1  基本的输入流操作	327
8.3.2  缓冲输入流	327
8.3.3  基本的输出流操作	328
8.3.4  流读取器和编写器	329
8.4  标准流	332
8.4.1  从键盘读入数据	333
8.4.2  写到命令行中	340
8.4.3  printf()方法	340
8.4.4  将数据格式化为字符串	345
8.5  小结	346
第9章  访问文件与目录	349
9.1  访问文件系统	349
9.2  使用Path对象	351
9.2.1  访问系统属性	353
9.2.2  设置系统属性	355
9.2.3  测试和检查Path对象	355
9.2.4  查询文件和目录	356
9.2.5  获取文件属性	357
9.2.6  其他的路径操作	360
9.3  创建与删除目录和文件	361
9.3.1  创建目录	361
9.3.2  创建文件	363
9.3.3  删除文件和目录	364
9.4  获取目录内容	365
9.5  关闭流	366
9.6  移动与复制文件和目录	368
9.6.1  对文件或目录重命名	369
9.6.2  复制文件和目录	370
9.6.3  遍历文件树	375
9.7  小结	378
第10章  写文件	381
10.1  文件I/O基础	381
10.2  文件输出	382
10.3  通过输出流写文件	383
10.4  使用Writer写文件	386
10.5  缓冲区	389
10.5.1  缓冲区的容量	389
10.5.2  缓冲区的位置和限制	390
10.5.3  设置位置和限制	391
10.5.4  创建缓冲区	392
10.5.5  标记缓冲区	396
10.5.6  缓冲区数据传输	397
10.5.7  使用视图缓冲区	399
10.5.8  准备缓冲区以输出到
文件中	400
10.6  使用通道写文件	401
10.6.1  通道接口	402
10.6.2  通道操作	403
10.6.3  为文件获取通道	403
10.6.4  通道写操作	404
10.7  文件写操作	406
10.7.1  将缓冲区的一部分写入
到文件中	406
10.7.2  文件的位置	409
10.7.3  使用视图缓冲区加载字
节缓冲区	410
10.7.4  将变长字符串写入到
文件中	410
10.7.5  直接和间接缓冲区	416
10.7.6  使用通道写入数值
数据	417
10.7.7  将混合数据写入到
文件中	421
10.7.8  从多个缓冲区写入	427
10.8  强制将数据写入到设备中	430
10.9  小结	431
第11章  读文件	433
11.1  文件读取操作	433
11.1.1  使用输入流读取文件	434
11.1.2  使用缓冲读取器读取
文件	437
11.2  使用通道读取文件	439
11.2.1  读取文本文件	441
11.2.2  从缓冲区获取数据	442
11.2.3  读取二进制数据	444
11.2.4  读取混合数据	446
11.2.5  压缩缓冲区	449
11.3  复制文件	452
11.4  随机访问文件	455
11.5  内存映射文件	460
11.5.1  锁住文件	463
11.5.2  锁住文件的特定部分	465
11.5.3  实用的文件加锁考量	465
11.6  小结	468
第12章  序列化对象	471
12.1  在文件中存储对象	471
12.2  将对象写入到文件中	472
12.2.1  将基本类型数据写入到
对象流中	474
12.2.2  实现Serializable接口	475
12.3  从文件读取对象	478
12.3.1  判定反序列化对象所属
的类	481
12.3.2  使用对象序列化	482
12.3.3  手动序列化类	485
12.3.4  序列化问题和困难	486
12.4  小结	488
第13章  泛型	491
13.1  什么是泛型	491
13.2  定义泛型类	492
13.2.1  实现泛型类	493
13.2.2  实例化泛型类	495
13.2.3  泛型类实例在运行时
的类型	500
13.2.4  泛型类实例之间的
关系	502
13.2.5  多个类型参数	502
13.2.6  类型参数的作用域	503
13.2.7  泛型类的静态域	504
13.2.8  类型参数的边界	504
13.3  泛型类和泛型接口	508
13.3.1  实现针对容器类的基于
集合的循环	508
13.3.2  实现迭代器的功能	510
13.3.3  二叉树的参数化类型	512
13.4  原生类型的变量	523
13.5  使用通配符类型参数	524
13.5.1  针对通配符的约束	526
13.5.2  深入Class类	529
13.6  数组与参数化类型	530
13.7  参数化方法	533
13.8  参数化类型及继承	539
13.9  总结	540
第14章  集合框架	543
14.1  理解集合框架	543
14.2  对象集合	544
14.2.1  集	544
14.2.2  序列	545
14.2.3  地图	546
14.3  迭代器	547
14.4  集合类	549
14.5  使用EnumSet	552
14.6  数组集合类	554
14.6.1  创建矢量	554
14.6.2  存储对象	557
14.6.3  检索对象	558
14.6.4  移除对象	560
14.6.5  搜索对象	561
14.6.6  应用矢量	562
14.6.8  对集合中的元素进行
排序	566
14.6.9  堆栈存储器	567
14.7  链表	573
14.8  使用地图	575
14.8.1  散列过程	575
14.8.2  把自己的类用作键	576
14.8.3  创建HashMap容器	577
14.8.4  存储、检索和移除
对象	578
14.8.5  处理地图中的所有
元素	579
14.9  小结	589
14.10  练习	589
第15章   一组有用的类	591
15.1  数组的实用方法	591
15.1.1  填充数组	591
15.1.2  复制数组	593
15.1.3  比较数组	593
15.1.4  数组的排序	594
15.1.5  搜索数组	598
15.1.6  将数组的内容用作
字符串	600
15.2  Observable和Observer
对象	601
15.2.1  定义Observable对象的
类	602
15.2.2  Observable类的方法	602
15.3  生成随机数	605
15.4  日期和时间	608
15.4.1  Date类	608
15.4.2  解释Date对象	609
15.4.3  公历	612
15.5  正则表达式	618
15.6  使用Scanner对象	637
15.6.1  创建Scanner对象	637
15.6.2  从Scanner对象获取
输入	638
15.6.3  测试标记	640
15.6.4  为标记定义自己的
模式	641
15.7 小结	642
15.8 练习	642
第16章  线程	645
16.1  理解线程	645
16.1.1  创建线程	647
16.1.2  停止线程	652
16.1.3  连接线程	653
16.1.4  线程的调度	654
16.1.5  实现Runnable接口	654
16.2  管理线程	656
16.2.1  同步	657
16.2.2  死锁	672
16.3  使用执行器	674
16.3.1  使用执行器	674
16.3.2  执行Callable<V>任务	675
16.3.3  Future<V>对象方法	675
16.3.4  关闭线程池	676
16.4  线程优先级	685
16.5  小结	687
16.6  练习	687
第17章  创建窗口	689
17.1  Java中的图形用户界面	689
17.2  创建窗口	691
17.2.1  设计窗口	692
17.2.2  在GUI代码中禁止
死锁	692
17.3  组件和容器	696
17.3.1  Window和Frame组件	697
17.3.2  Window面板	698
17.4  组件的基础知识	699
17.4.1  组件的属性	699
17.4.2  组件的大小和位置	700
17.4.2  点和矩形	703
17.4.3  组件的可视化特性	706
17.4.4  Swing 组件	714
17.5  使用Swing容器	716
17.6  容器的布局管理器	718
17.6.1  流布局管理器	719
17.6.2  使用边界布局管理器	724
17.6.3  使用卡片布局管理器	726
17.6.4  使用网格布局管理器	728
17.6.5  使用BoxLayout管理器	730
17.6.7  使用GridBagLayout
管理器	736
17.6.8  使用SpringLayout
管理器	743
17.7  向窗口中添加菜单	750
17.7.1  创建JMenu和
JmenuItem对象	750
17.7.2  创建菜单	751
17.7.3  为菜单添加菜单项	753
17.7.4  添加菜单快捷键和
加速器	757
17.8  小结	759
17.9  练习	759
第18章  处理事件	761
18.1  交互式Java程序	761
18.2  事件处理过程	763
18.3  事件类	764
18.3.1  低级事件类	764
18.3.2  使窗口处理自己的
事件	766
18.3.3  允许其他低级事件	768
18.3.4  低级事件监听器	769
18.3.5  使用适配器类	774
18.3.6  语义事件	776
18.3.7  语义事件监听器	776
18.4  applet中语义事件的处理	777
18.4.1  其他事件处理方式	785
18.4.2  处理低级事件和
语义事件	787
18.5  应用程序中的语义事件
监听器	788
18.6  使用动作	794
18.6.1  Action接口	794
18.6.2  Action方法	795
18.6.3  把动作用作菜单项	796
18.6.4  定义Action类	797
18.7  添加工具栏	803
18.8  添加菜单图标	812
18.9  添加工具提示	813
18.10  禁用动作	815
18.11  小结	815
18.12  练习	815
第19章  在窗口中绘图	817
19.1  使用模型/视图体系结构	817
19.2  组件坐标系统	821
19.3  在组件上绘图	822
19.3.1  图形环境	822
19.3.2  绘图过程	825
19.3.3  渲染操作	826
19.4  形状	826
19.4.1  定义点的类	826
19.4.2  直线和矩形	827
19.4.3  圆弧和椭圆	832
19.4.4  曲线	835
19.4.5  复杂路径	843
19.5  填充图形	848
19.6  管理图形	853
19.6.1  存储模型中的图形	854
16.6.2  绘制图形	856
19.7  用鼠标绘图	857
19.7.1  处理鼠标事件	857
19.8  定义自己的图形类	864
19.8.1  定义直线	865
19.8.2  定义矩形	866
19.8.3  定义圆	868
19.8.4  绘制曲线	871
19.9  修改光标	873
19.10  小结	874
19.11  练习	874
第20章  扩展GUI	875
20.1  创建状态栏	875
20.1.1  用于Sketcher的
状态栏类	876
20.1.2  更新面板	878
20.2  使用对话框	880
20.2.1  模态对话框和非模态
对话框	881
20.2.2  一个简单的模态
对话框	882
20.2.3  即时消息对话框	885
20.2.4  即时输入对话框	887
20.3  使用对话框创建文本
元素	889
20.3.1  为文本定义菜单项和
工具栏按钮	889
20.3.2  定义文本类	891
20.3.3  创建文本元素	892
20.4  字体选择对话框	895
20.4.1  FontDialog类	896
20.4.2  创建字体对话框按钮	896
20.4.3  添加数据面板	898
20.4.4  实现字体列表	899
20.4.5  显示所选的字体	901
20.4.6  使用分隔面板	902
20.4.7  使用微调按钮	903
20.4.8  使用单选按钮来选择
字体样式	905
20.4.9  监听单选按钮	906
20.5  弹出式菜单	908
20.5.1  显示弹出式菜单	910
20.5.2  实现上下文菜单	913
20.7  变换用户坐标系统	921
20.8  选择自定义颜色	937
20.8.1  使用缓存的图像	938
20.8.2  使用JColorChooser
对话框	938
20.8.3  添加自定义颜色GUI	939
20.8.4  显示颜色选择对话框	941
20.9  小结	942
20.10  练习	943
第21章  填充和打印文档	945
21.1  串行化草图	945
21.1.1  实现串行化	946
21.1.2  串行化元素列表	946
21.2  用来保存草图的基本架构	946
21.2.1  指定文件名	946
21.2.1  验证草图的目录	947
21.2.3  记录草图是否修改	948
21.2.4  处理File菜单事件	949
21.3  使用文件选择器	950
21.3.1  显示文件保存对话框	950
21.3.2  显示文件打开对话框	951
21.3.3  定制文件选择对话框	951
21.4  实现文件操作	953
21.4.1  创建定制的文件
对话框	954
21.4.2  实现保存操作	955
21.4.3  实现Save As操作	959
21.4.4  实现文件打开操作	961
21.4.5  启动新草图	963
21.4.6  禁止在关闭时丢失
数据	964
21. 5  在Java中打印	966
21.5.1  创建和使用PrinterJob
对象	967
21.5.2  打印页面	970
21.5.3  打印整个草图	974
21.5.4  横向打印	978
21.5.5  提高打印性能	980
21.2.6  实现页面设置	981
21.5.7  使用Java打印对话框	984
21.5.8  多页面文档的打印	987
21.5.9  使用Book对象进行
打印	995
21.5.10  打印Swing组件	997
21.6  小结	999
21.7  练习	1000
第22章  Java和XML	1001
22.1  XML	1001
22.1.1  XML的作用	1002
22.1.2  在Java中处理XML	1002
22.2  XML文档结构	1002
22.2.1  结构良好的XML
文档	1003
22.2.2  有效的XML文档	1004
22.2.3  XML文档中的元素	1004
22.2.4  元素的属性	1008
22.3  XML中的数据结构	1011
22.4  文档类型定义	1011
22.4.1  声明DTD	1012
22.4.2  定义DTD	1013
22.4.3  Sketcher的DTD	1019
22.5  结构良好的文档的规则	1023
22.6  XML名称空间	1024
22.6.1  名称空间声明	1024
22.6.2  XML名称空间和
DTD	1026
22.7  XML 模式	1026
22.7.1  定义模式	1027
22.7.2  定义模式元素	1028
22.7.3  指定数据类型	1029
22.7.4  定义复杂元素的属性	1029
22.7.5  值的限制	1030
22.7.6  定义属性组	1031
22.7.7  指定一组元素选项	1031
22.8  Sketcher模式	1032
22.8.1  定义直线元素	1033
22.8.2  定义矩形元素类型	1035
22.8.3  定义圆元素类型	1035
22.8.4  定义曲线元素类型	1036
22.8.5  定义文本元素类型	1037
22.8.6  完整的Sketcher模式	1037
22.8.7  使用模式的文档	1041
22.9  用XML文档编程	1041
22.9.1  SAX 处理	1042
22.9.2  DOM 处理	1043
22.10  访问解析器	1043
22.11  使用SAX	1044
22.11.1  解析器的属性和
特征	1046
22.11.2  用SAX解析文档	1048
22.11.3  实现SAX处理
程序	1049
22.11.4  处理其他解析事件	1058
22.11.5  解析模式实例文档	1059
22.12  小结	1064
22.13  练习	1064
第23章  创建和修改XML文档	1067
23.1  文档对象模型	1067
23.2  设置DOM解析器的
特征	1069
23.3  解析文档	1070
23.4  导航Document对象树	1071
23.4.1  节点类型	1072
23.4.2  可忽略的空白和元素
内容	1077
23.4.3  访问属性	1078
23.5  转换XML	1081
23.6  创建Document对象	1085
23.7  把草图存储为XML
文档	1089
23.7.1  添加元素节点	1090
23.7.2  为完成的草图创建
Document对象	1097
23.7.3  把草图保存为XML
文件	1099
23.8  读取草图的XML表示	1103
23.8.1  从XML中创建基类
对象	1103
23.8.2  从XML节点中创建
元素	1105
23.8.3  处理Import XML
事件	1109
23.8.4  读取XML文件	1110
23.8.5  创建模型	1111
23.9  小结	1114
23.10  练习	1114
附录A  关键字	1117
附录B  计算机的算术	1119
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 7入门经典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>写给大忙人看的Java核心技术
第1章　基本的编程结构............................................................................................. 1
1.1　第一个程序 ............................................................................................... 2
1.1.1　“Hello，World”程序解析 ............................................................................. 2
1.1.2　编译与运行Java程序 ......................................................................................... 3
1.1.3　方法调用 ............................................................................................................ 5
1.2　基本类型 ................................................................................................. 7
1.2.1　整型 .................................................................................................................... 7
1.2.2　浮点类型 ............................................................................................................ 8
1.2.3　char型 ................................................................................................................. 9
1.2.4　布尔型 .............................................................................................................. 10
1.3　变量 .......................................................................................... 10
1.3.1　变量的声明 ...................................................................................................... 10
1.3.2　名称 .................................................................................................................. 10
1.3.3　初始化 ...............................................................................................................11
1.3.4　常量 ...................................................................................................................11
1.4　算术操作 .................................................................................................... 13
1.4.1　赋值 .................................................................................................................. 13
1.4.2　基本运算 .......................................................................................................... 14
1.4.3　数学方法 .......................................................................................................... 15
1.4.4　数字类型转换 .................................................................................................. 16
1.4.5　关系和逻辑操作符 .......................................................................................... 17
1.4.6　大数 .................................................................................................................. 19
1.5　字符串 ................................................................................................. 19
1.5.1　字符串连接 ...................................................................................................... 20
1.5.2　子字符串 .......................................................................................................... 21
1.5.3　字符串比较 ...................................................................................................... 21
1.5.4　数字与字符串转换 .......................................................................................... 23
1.5.5　String类API ...................................................................................................... 24
1.5.6　编码点（code point）和编码单元（code unit） ........................................... 25
1.6　输入与输出 .......................................................................................... 26
1.6.1　读取输入 .......................................................................................................... 27
1.6.2　格式化输出 ...................................................................................................... 28
1.7　控制流 ........................................................................................................... 30
1.7.1　分支 .................................................................................................................. 30
1.7.2　循环 .................................................................................................................. 32
1.7.3　跳出循环与继续循环 ...................................................................................... 34
1.7.4　局部变量作用域 .............................................................................................. 36
1.8　数组和数组列表 ................................................................................. 38
1.8.1　使用数组 .......................................................................................................... 38
1.8.2　构造数组 .......................................................................................................... 39
1.8.3　数组列表 .......................................................................................................... 39
1.8.4　基本类型包装类 .............................................................................................. 41
1.8.5　增强的for循环 ................................................................................................. 41
1.8.6　数组与数组列表的复制 .................................................................................. 42
1.8.7　数组算法 .......................................................................................................... 43
1.8.8　命令行参数 ...................................................................................................... 44
1.8.9　多维数组 .......................................................................................................... 45
1.9　功能分解 ............................................................................................. 48
1.9.1　静态方法的声明与调用 .................................................................................. 48
1.9.2　数组参数与返回值 .......................................................................................... 48
1.9.3　可变参数 .......................................................................................................... 49
练习 ..................................................................................................................... 50
第2章　面向对象编程............................................................................................... 53
2.1　使用对象 .............................................................................................. 54
2.1.1　Accessor（访问器）和Mutator（更改器）方法 ........................................... 56
2.1.2　对象引用 .......................................................................................................... 56
2.2　实现类 ............................................................................................... 58
2.2.1　实例变量 .......................................................................................................... 58
2.2.2　方法头 .............................................................................................................. 59
2.2.3　方法体 .............................................................................................................. 59
2.2.4　实例方法调用 .................................................................................................. 60
2.2.5　this引用 ............................................................................................................ 61
2.2.6　值调用 .............................................................................................................. 62
2.3　构造对象 .......................................................................................... 63
2.3.1　实现构造函数 .................................................................................................. 64
2.3.2　重载 .................................................................................................................. 64
2.3.3　调用另一个构造函数 ...................................................................................... 65
2.3.4　默认初始化 ...................................................................................................... 66
2.3.5　实例变量初始化 .............................................................................................. 66
2.3.6　final实例变量 ................................................................................................... 67
2.3.7　无参构造函数 .................................................................................................. 68
2.4　静态变量和方法 ...................................................................... 69
2.4.1　静态变量 .......................................................................................................... 69
2.4.2　静态常量 .......................................................................................................... 70
2.4.3　静态初始块 ...................................................................................................... 71
2.4.4　静态方法 .......................................................................................................... 71
2.4.5　工厂方法 .......................................................................................................... 73
2.5　包 ........................................................................................................ 73
2.5.1　包的声明 .......................................................................................................... 74
2.5.2　类路径 .............................................................................................................. 75
2.5.3　包作用域 .......................................................................................................... 77
2.5.4　导入包 .............................................................................................................. 78
2.5.5　静态导入 .......................................................................................................... 79
2.6　嵌套类 .............................................................................................. 80
2.6.1　静态嵌套类 ...................................................................................................... 80
2.6.2　内部类 .............................................................................................................. 82
2.6.3　内部类的特殊语法 .......................................................................................... 85
2.7　文档注释 ......................................................................................... 86
2.7.1　插入注释 .......................................................................................................... 86
2.7.2　类注释 .............................................................................................................. 87
2.7.3　方法注释 .......................................................................................................... 88
2.7.4　变量注释 .......................................................................................................... 88
2.7.5　通用注释 .......................................................................................................... 89
2.7.6　链接 .................................................................................................................. 89
2.7.7　包和概述注释 .................................................................................................. 90
2.7.8　注释的提取 ...................................................................................................... 90
练习 ................................................................................................................. 91
第3章　接口和lambda表达式................................................................................... 95
3.1　接口 ....................................................................................................... 96
3.1.1　声明接口 .......................................................................................................... 96
3.1.2　实现接口 .......................................................................................................... 97
3.1.3　转换为接口类型 .............................................................................................. 99
3.1.4　强制类型转换（cast）和instanceof操作符 ................................................... 99
3.1.5　继承接口 ........................................................................................................ 100
3.1.6　实现多个接口 ................................................................................................ 101
3.1.7　常量 ................................................................................................................ 101
3.2　静态方法和默认方法 ....................................................................... 101
3.2.1　静态方法 ........................................................................................................ 102
3.2.2　默认方法 ........................................................................................................ 102
3.2.3　解决默认方法冲突 ........................................................................................ 103
3.3　接口示例 ........................................................................................ 105
3.3.1　Comparable接口 ............................................................................................. 105
3.3.2　Comparator接口 ............................................................................................. 107
3.3.3　Runable接口 ................................................................................................... 108
3.3.4　UI（User Interface）回调 ............................................................................. 109
3.4　lambda表达式 .........................................................................................110
3.4.1　lambda表达式语法 .........................................................................................110
3.4.2　函数式接口 .....................................................................................................111
3.5　方法引用和构造函数引用 .........................................................112
3.5.1　方法引用 .........................................................................................................113
3.5.2　构造函数引用 ......................................................................114
3.6　使用lambda表达式 ...............................................................................115
3.6.1　实现延迟执行 .................................................................................................115
3.6.2　选择函数式接口 .............................................................................................116
3.6.3　实现自己的函数式接口 .................................................................................118
3.7　lambda表达式和变量作用域 .....................................................119
3.7.1　lambda表达式的作用域 .................................................................................119
3.7.2　访问来自闭合作用域的变量 ........................................................................ 120
3.8　高阶函数 .......................................................................................... 123
3.8.1　返回函数的方法 ............................................................................................ 123
3.8.2　修改函数的方法 ............................................................................................ 123
3.8.3　Comparator方法 ............................................................................................. 124
3.9　局部内部类 ....................................................................... 125
3.9.1　局部类 ............................................................................................................ 125
3.9.2　匿名类 ............................................................................................................ 126
练习 .................................................................................................................................... 127
第4章　继承与反射................................................................................................ 131
4.1　继承一个类 ......................................................................................... 132
4.1.1　父类与子类 .................................................................................................... 132
4.1.2　定义和继承子类方法 .................................................................................... 132
4.1.3　方法覆盖 ........................................................................................................ 133
4.1.4　子类的构造 .................................................................................................... 134
4.1.5　父类赋值 ........................................................................................................ 135
4.1.6　转换 ................................................................................................................ 136
4.1.7　final方法和类 ................................................................................................. 136
4.1.8　抽象方法和类 ................................................................................................ 137
4.1.9　受保护访问 .................................................................................................... 138
4.1.10　匿名子类 ...................................................................................................... 139
4.1.11　继承和默认方法 .......................................................................................... 140
4.1.12　带super的方法表达式 ................................................................................. 141
4.2　Object：终极父类...................................................................................................... 141
4.2.1　toString方法 ................................................................................................... 142
4.2.2　equals方法 ...................................................................................................... 144
4.2.3　hashCode方法 ................................................................................................ 147
4.2.4　克隆对象 ........................................................................................................ 148
4.3　枚举 ...................................................................................................... 151
4.3.1　枚举方法 ........................................................................................................ 152
4.3.2　构造函数、方法和域 .................................................................................... 153
4.3.3　实例的实现体 ................................................................................................ 153
4.3.4　静态成员 ........................................................................................................ 154
4.3.5　switch枚举对象 .............................................................................................. 155
4.4　运行时类型信息和资源 ........................................................................... 156
4.4.1　Class类 ........................................................................................................... 156
4.4.2　资源加载 ........................................................................................................ 160
4.4.3　类加载器 ........................................................................................................ 160
4.4.4　上下文类加载器 ............................................................................................ 162
4.4.5　服务加载器 .................................................................................................... 164
4.5　反射 .............................................................................................. 165
4.5.1　枚举类成员 .................................................................................................... 165
4.5.2　对象检查 ........................................................................................................ 167
4.5.3　方法调用 ........................................................................................................ 167
4.5.4　对象构造 ........................................................................................................ 168
4.5.5　JavaBeans ....................................................................................................... 169
4.5.6　使用数组 ........................................................................................................ 170
4.5.7　代理 ................................................................................................................ 172
练习 .................................................................................................................................... 174
第5章　异常、断言和日志处理.............................................................................. 177
5.1　异常处理 ............................................................................................. 178
5.1.1　异常抛出 ........................................................................................................ 178
5.1.2　异常继承层次 ................................................................................................ 179
5.1.3　已检查异常的声明 ........................................................................................ 181
5.1.4　异常捕获 ........................................................................................................ 182
5.1.5　try-with-resources语句 ................................................................................... 183
5.1.6　finally子句 ...................................................................................................... 185
5.1.7　异常重抛和链接 ............................................................................................ 186
5.1.8　堆栈踪迹 ........................................................................................................ 188
5.1.9　Objects.requireNonNull方法 .......................................................................... 189
5.2　断言 ........................................................................................................ 189
5.2.1　使用断言 ........................................................................................................ 190
5.2.2　启用和禁用断言 ............................................................................................ 191
5.3　记录日志 .................................................................................... 191
5.3.1　采用Logger ..................................................................................................... 192
5.3.2　日志记录器 .................................................................................................... 192
5.3.3　日志级别 ........................................................................................................ 192
5.3.4　其他日志记录方法 ........................................................................................ 193
5.3.5　日志记录的配置项 ........................................................................................ 195
5.3.6　日志处理器 .................................................................................................... 196
5.3.7　过滤器和格式化器 ........................................................................................ 199
练习 ......................................................................................................... 199
第6章　泛型编程.................................................................................................... 203
6.1　泛型类 ...................................................................................................... 204
6.2　泛型方法 ................................................................................................. 205
6.3　类型限定 .................................................................................................................. 206
6.4　类型变异和通配符 ................................................................................................. 207
6.4.1　子类型通配符 ................................................................................................ 208
6.4.2　父类型通配符 ................................................................................................ 209
6.4.3　带类型变量的通配符 .................................................................................... 210
6.4.4　无限定通配符 ................................................................................................ 212
6.4.5　通配符捕获 .................................................................................................... 212
6.5　Java虚拟机中的泛型 ............................................................................................ 213
6.5.1　类型擦除 ........................................................................................................ 213
6.5.2　转换插入 ........................................................................................................ 214
6.5.3　桥方法 ............................................................................................................ 215
6.6　泛型约束 .............................................................................................................. 216
6.6.1　无基本类型参数 ............................................................................................ 217
6.6.2　所有类型在运行时都是原始的 .................................................................... 217
6.6.3　不能实例化类型变量 .................................................................................... 218
6.6.4　不能构造参数化类型的数组 ........................................................................ 220
6.6.5　静态上下文中的类类型变量不是有效的 .................................................... 221
6.6.6　类型擦除后的方法可能不冲突 .................................................................... 222
6.6.7　异常与泛型 .................................................................................................... 223
6.7　反射与泛型 .................................................................................................. 224
6.7.1　Class<T>类 .................................................................................................... 224
6.7.2　虚拟机中的泛型类型信息 ............................................................................ 225
练习 .................................................................................................................................... 227
第7章　集合........................................................................................................... 233
7.1　集合类框架概要 ........................................................................................ 234
7.2　迭代器 ............................................................................................... 238
7.3　set ............................................................................................................................... 240
7.4　map .......................................................................................................................... 241
7.5　其他集合 ......................................................................................................... 245
7.5.1　Properties ........................................................................................................ 245
7.5.2　位组 ................................................................................................................ 247
7.5.3　枚举set和枚举map ......................................................................................... 248
7.5.4　栈、队列、双端队列、优先级队列 ............................................................ 249
7.5.5　弱哈希映射表 ................................................................................................ 250
7.6　视图 ......................................................................................................................... 251
7.6.1　范围（range） ............................................................................................... 251
7.6.2　空视图和单例视图 ........................................................................................ 252
7.6.3　不可修改的视图 ............................................................................................ 252
练习 ................................................................................................................................. 253
第8章　Stream....................................................................................................... 257
8.1　从迭代到Stream操作 .............................................................................................. 258
8.2　创建Stream .............................................................................................................. 259
8.3　filter、map和flatMap方法 ...................................................................................... 261
8.4　提取子流和组合流 ......................................................................................... 262
8.5　其他流转换 ................................................................................................... 263
8.6　简单归约 .................................................................................................... 264
8.7　Optional类型 ................................................................................................. 265
8.7.1　如何使用Optional类型值 .............................................................................. 265
8.7.2　如何不使用Optional类型值 .......................................................................... 266
8.7.3　创建Optional类型值 ...................................................................................... 267
8.7.4　使用flatMap来组合可选值函数 .................................................................... 267
8.8　收集结果 ................................................................................................... 268
8.9　将结果收集到map中 ................................................................................... 270
8.10　分组和分片 ........................................................................................... 271
8.11　下游收集器 .............................................................................................. 272
8.12　归约操作 ............................................................................................................... 274
8.13　基本类型流 ........................................................................................................... 276
8.14　并行流 ................................................................................................................... 278
练习 .................................................................................................................................. 280
第9章　输入与输出处理......................................................................................... 285
9.1　输入/输出流：Reader和Writer ................................................................................. 286
9.1.1　获取流对象 .................................................................................................... 286
9.1.2　读取字节 ........................................................................................................ 287
9.1.3　写字节 ............................................................................................................ 288
9.1.4　字符集编码 .................................................................................................... 288
9.1.5　文本输入 ........................................................................................................ 291
9.1.6　文本输出 ........................................................................................................ 292
9.1.7　读写二进制数据 ............................................................................................ 294
9.1.8　随机存取文件 ................................................................................................ 295
9.1.9　内存映射文件 ................................................................................................ 295
9.1.10　文件锁 .......................................................................................................... 296
9.2　路径、文件和目录 ............................................................................................... 297
9.2.1　路径 ................................................................................................................ 297
9.2.2　创建文件和目录 ............................................................................................ 299
9.2.3　复制、移动和删除文件 ................................................................................ 300
9.2.4　访问目录内容 ................................................................................................ 301
9.2.5　ZIP文件系统 .................................................................................................. 304
9.3　URL连接 ................................................................................................................ 305
9.4　正则表达式 ............................................................................................................ 307
9.4.1　正则表达式语法 ............................................................................................ 307
9.4.2　匹配一个或多个 .............................................................................................311
9.4.3　分组 ................................................................................................................ 312
9.4.4　消除或替换匹配结果 .................................................................................... 313
9.4.5　标记 ................................................................................................................ 314
9.5　序列化 ..................................................................................................... 315
9.5.1　Serializable接口 ............................................................................................. 315
9.5.2　瞬态实例变量 ................................................................................................ 317
9.5.3　readObject和writeObject方法 ........................................................................ 317
9.5.4　readResolve和writeReplace方法 ................................................................... 319
9.5.5　版本化 ............................................................................................................ 320
练习 ..................................................................................................................... 321
第10章　并发编程.................................................................................................. 325
10.1　并发任务 ................................................................................................. 326
10.1.1　运行任务 .................................................................................................... 326
10.1.2　Future和Executor服务 ............................................................................... 328
10.2　线程安全 ................................................................................................. 331
10.2.1　可见性 ........................................................................................................ 331
10.2.2　竞争条件 .................................................................................................... 333
10.2.3　安全并发的策略 ........................................................................................ 336
10.2.4　不可变类 .................................................................................................... 336
10.3　并行算法 ............................................................................................ 337
10.3.1　并行流 ........................................................................................................ 338
10.3.2　并行数组操作 ............................................................................................ 338
10.4　线程安全的数据结构 .............................................................................. 339
10.4.1　ConcurrentHashMap .................................................................................. 340
10.4.2　阻塞队列 .................................................................................................... 341
10.4.3　其他线程安全的数据结构 ........................................................................ 343
10.5　原子值 ................................................................................................... 344
10.6　锁 ........................................................................................................ 346
10.6.1　可重入锁（ReentrantLock） .................................................................... 347
10.6.2　synchronized关键字................................................................................... 348
10.6.3　条件等待 .................................................................................................... 350
10.7　线程 ...................................................................................................... 352
10.7.1　启动线程 .................................................................................................... 352
10.7.2　线程中断 .................................................................................................... 353
10.7.3　线程变量 .................................................................................................... 355
10.7.4　线程的其他属性 ........................................................................................ 356
10.8　异步计算 ....................................................................................................... 356
10.8.1　UI回调中的长期运行任务 ........................................................................ 356
10.8.2　可完成的future .......................................................................................... 358
10.9　进程 .............................................................................................. 361
10.9.1　构建进程 .................................................................................................... 361
10.9.2　运行进程 .................................................................................................... 363
练习 .................................................................................................. 364
第11章　注解......................................................................................................... 371
11.1　使用注解 ......................................................................................... 372
11.1.1　注解元素 .................................................................................................... 372
11.1.2　多注解和重复注解 .................................................................................... 373
11.1.3　注解声明 .................................................................................................... 374
11.1.4　注解类型用途 ............................................................................................ 375
11.1.5　明确接收者 ................................................................................................ 376
11.2　定义注解 ......................................................................................... 378
11.3　标准注解 ................................................................................................ 380
11.3.1　编译相关的注解 ........................................................................................ 381
11.3.2　资源管理相关的注解 ................................................................................ 382
11.3.3　元注解 ........................................................................................................ 382
11.4　运行时注解处理 ................................................................................. 384
11.5　源码级注解处理 .................................................................................. 387
11.5.1　注解处理器 ................................................................................................ 388
11.5.2　语言模型API.............................................................................................. 388
11.5.3　使用注解生成源码 .................................................................................... 389
练习 ............................................................................................. 392
第12章　日期和时间API......................................................................................... 395
12.1　时间线 ....................................................................................................... 396
12.2　本地日期 ........................................................................................... 398
12.3　日期调整器 ............................................................................................. 401
12.4　本地时间 ................................................................................................. 402
12.5　时区时间 ................................................................................ 403
12.6　格式化和解析 .............................................................................. 406
12.7　应对遗留代码 ................................................................................. 409
练习 ............................................................................................................411
第13章　国际化...................................................................................................... 413
13.1　本地化 ............................................................................................ 414
13.1.1　指定本地化 ................................................................................................ 414
13.1.2　默认locale .................................................................................................. 417
13.1.3　显示名称 .................................................................................................... 418
13.2　数字格式化 ........................................................................................... 418
13.3　货币符号 ................................................................................................. 419
13.4　日期和时间格式化 ......................................................................... 420
13.5　排序和规格化 ........................................................................................... 422
13.6　消息格式化 ........................................................................................ 424
13.7　资源束 ................................................................................................... 426
13.7.1　组织资源束 ................................................................................................ 426
13.7.2　资源束类 .................................................................................................... 428
13.8　字符集编码 ................................................................................. 429
13.9　首选项 ............................................................................................... 430
练习 ................................................................................................................ 432
第14章　编译与脚本.............................................................................................. 435
14.1　编译器API ................................................................................................................ 435
14.1.1　调用编译器 ................................................................................................ 436
14.1.2　启动编译任务 ............................................................................................ 436
14.1.3　从内存读取源文件 .................................................................................... 437
14.1.4　向内存写入字节码 .................................................................................... 438
14.1.5　捕获诊断信息 ............................................................................................ 440
14.2　脚本API .................................................................................................................... 440
14.2.1　获取脚本引擎 ............................................................................................ 440
14.2.2　绑定 ............................................................................................................ 441
14.2.3　重定向输入与输出 .................................................................................... 442
14.2.4　调用脚本函数和方法 ................................................................................ 443
14.2.5　编译脚本 .................................................................................................... 444
14.3　Nashorn脚本引擎 .............................................................................. 445
14.3.1　从命令行运行Nashorn .............................................................................. 445
14.3.2　调用get、set和重载方法 .......................................................................... 446
14.3.3　构造Java对象 ............................................................................................. 447
14.3.4　JavaScript和Java中的字符串 .................................................................... 449
14.3.5　数字 ............................................................................................................ 449
14.3.6　使用数组 .................................................................................................... 450
14.3.7　列表与映射 ................................................................................................ 451
14.3.8　lambda表达式 ............................................................................................ 452
14.3.9　继承Java类与实现Java接口 ...................................................................... 453
14.3.10　异常 .......................................................................................................... 455
14.4　shell脚本与Nashorn .............................................................................. 455
14.4.1　执行shell命令 ............................................................................................ 456
14.4.2　字符串插值 ................................................................................................ 456
14.4.3　脚本输入 .................................................................................................... 457
练习 .................................................................................................... 458
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>写给大忙人看的Java核心技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JavaEE开发的颠覆者: Spring Boot实战
第一部分 点睛Spring 4.x
第1 章 Spring 基础 2
1.1 Spring 概述  2
1.1.1 Spring 的简史  2
1.1.2 Spring 概述  3
1.2 Spring 项目快速搭建 5
1.2.1 Maven 简介  6
1.2.2 Maven 安装  6
1.2.3 Maven 的pom.xml 7
1.2.4 Spring 项目的搭建  9
1.3 Spring 基础配置 17
1.3.1 依赖注入  18
1.3.2 Java 配置  21
1.3.3 AOP 24
第2 章 Spring 常用配置 30
2.1 Bean 的Scope  30
2.1.1 点睛 30
2.1.2 示例 31
2.2 Spring EL 和资源调用. 33
2.2.1 点睛 33
2.2.2 示例 33
2.3 Bean 的初始化和销毁 37
2.3.1 点睛 37
2.3.2 演示 38
2.4 Profile  40
2.4.1 点睛 40
2.4.2 演示 41
2.5 事件（Application Event）  44
2.5.1 点睛 44
2.5.2 示例 44
第3 章 Spring 高级话题 48
3.1 Spring Aware 48
3.1.1 点睛 48
3.1.2 示例 49
3.2 多线程  51
3.2.1 点睛 51
3.2.2 示例 51
3.3 计划任务 54
3.3.1 点睛 54
3.3.2 示例 54
3.4 条件注解@Conditional  56
3.4.1 点睛 56
3.4.2 示例 57
3.5 组合注解与元注解  60
3.5.1 点睛 60
3.5.2 示例 60
3.6 @Enable*注解的工作原理  63
3.6.1 第一类：直接导入配置类 63
3.6.2 第二类：依据条件选择配置类  64
3.6.3 第三类：动态注册Bean 65
3.7 测试  66
3.7.1 点睛 66
3.7.2 示例 67
第二部分 点睛Spring MVC 4.x
第4 章 Spring MVC 基础  72
4.1 Spring MVC 概述  73
4.2 Spring MVC 项目快速搭建 74
4.2.1 点睛 74
4.2.2 示例 74
4.3 Spring MVC 的常用注解  82
4.3.1 点睛 82
4.3.2 示例 83
4.4 Spring MVC 基本配置  87
4.4.1 静态资源映射  88
4.4.2 拦截器配置 89
4.4.3 @ControllerAdvice 91
4.4.4 其他配置  94
4.5 Spring MVC 的高级配置  98
4.5.1 文件上传配置  98
4.5.2 自定义HttpMessageConverter  101
4.5.3 服务器端推送技术  106
4.6 Spring MVC 的测试  113
4.6.1 点睛  113
4.6.2 示例  114
第三部分 实战Spring Boot
第5 章 Spring Boot 基础 122
5.1 Spring Boot 概述  122
5.1.1 什么是Spring Boot  122
5.1.2 Spring Boot 核心功能 122
5.1.3 Spring Boot 的优缺点 124
5.1.4 关于本书的Spring Boot 版本  124
5.2 Spring Boot 快速搭建  124
5.2.1 http://start.spring.io  124
5.2.2 Spring Tool Suite  127
5.2.3 IntelliJ IDEA  129
5.2.4 Spring Boot CLI 132
5.2.5 Maven 手工构建  134
5.2.6 简单演示  136
第6 章 Spring Boot 核心 138
6.1 基本配置  138
6.1.1 入口类和@SpringBootApplication 138
6.1.2 关闭特定的自动配置 139
6.1.3 定制Banner 139
6.1.4 Spring Boot 的配置文件  140
6.1.5 starter pom 141
6.1.6 使用xml 配置 143
6.2 外部配置  143
6.2.1 命令行参数配置  143
6.2.2 常规属性配置 144
6.2.3 类型安全的配置（基于properties）  145
6.3 日志配置  148
6.4 Profile 配置 148
实战  148
6.5 Spring Boot 运行原理  150
6.5.1 运作原理  153
6.5.2 核心注解  154
6.5.3 实例分析  157
6.5.4 实战  160
第7 章 Spring Boot 的Web 开发  170
7.1 Spring Boot 的Web 开发支持 170
7.2 Thymeleaf 模板引擎  171
7.2.1 Thymeleaf 基础知识  171
7.2.2 与Spring MVC 集成  174
7.2.3 Spring Boot 的Thymeleaf 支持  175
7.2.4 实战  177
7.3 Web 相关配置  182
7.3.1 Spring Boot 提供的自动配置 182
7.3.2 接管Spring Boot 的Web 配置  185
7.3.3 注册Servlet、Filter、Listener  186
7.4 Tomcat 配置  187
7.4.1 配置Tomcat 187
7.4.2 代码配置Tomcat  188
7.4.3 替换Tomcat 190
7.4.4 SSL 配置  191
7.5 Favicon 配置  196
7.5.1 默认的Favicon  196
7.5.2 关闭Favicon  196
7.5.3 设置自己的Favicon  197
7.6 WebSocket  197
7.6.1 什么是WebSocket  197
7.6.2 Spring Boot 提供的自动配置 197
7.6.3 实战  198
7.7 基于Bootstrap 和AngularJS 的现代Web 应用 212
7.7.1 Bootstrap  213
7.7.2 AngularJS  216
7.7.3 实战  222
第8 章 Spring Boot 的数据访问  233
8.1 引入Docker  237
8.1.1 Docker 的安装  238
8.1.2 Docker 常用命令及参数  242
8.1.3 下载本书所需的Docker 镜像  247
8.1.4 异常处理  247
8.2 Spring Data JPA  248
8.2.1 点睛Spring Data JPA  248
8.2.2 Spring Boot 的支持  258
8.2.3 实战  260
8.3 Spring Data REST  284
8.3.1 点睛Spring Data REST 284
8.3.2 Spring Boot 的支持  285
8.3.3 实战  286
8.4 声名式事务 297
8.4.1 Spring 的事务机制  297
8.4.2 声名式事务  298
8.4.3 注解事务行为 299
8.4.4 类级别使用@Transactional 300
8.4.5 Spring Data JPA 的事务支持  300
8.4.6 Spring Boot 的事务支持  302
8.4.7 实战  303
8.5 数据缓存Cache  309
8.5.1 Spring 缓存支持  309
8.5.2 Spring Boot 的支持  310
8.5.3 实战  312
8.5.4 切换缓存技术 319
8.6 非关系型数据库NoSQL 320
8.6.1 MongoDB  320
8.6.2 Redis 329
第9 章 Spring Boot 企业级开发  340
9.1 安全控制Spring Security  340
9.1.1 Spring Security 快速入门 340
9.1.2 Spring Boot 的支持  347
9.1.3 实战  348
9.2 批处理Spring Batch  362
9.2.1 Spring Batch 快速入门  362
9.2.2 Spring Boot 的支持  370
9.2.3 实战  371
9.3 异步消息  385
9.3.1 企业级消息代理  386
9.3.2 Spring 的支持 386
9.3.3 Spring Boot 的支持  386
9.3.4 JMS 实战  387
9.3.5 AMQP 实战 391
9.4 系统集成Spring Integration  395
9.4.1 Spring Integration 快速入门  395
9.4.2 Message  395
9.4.3 Channel  395
9.4.4 Message EndPoint 398
9.4.5 Spring Integration Java DSL  400
9.4.6 实战  400
第10 章 Spring Boot 开发部署与测试  407
10.1 开发的热部署 407
10.1.1 模板热部署  407
10.1.2 Spring Loaded  407
10.1.3 JRebel  409
10.1.4 spring-boot-devtools  413
10.2 常规部署  413
10.2.1 jar 形式 413
10.2.2 war 形式  417
10.3 云部署——基于Docker 的部署 419
10.3.1 Dockerfile  419
10.3.2 安装Docker  421
10.3.3 项目目录及文件 421
10.3.4 编译镜像 423
10.3.5 运行  424
10.4 Spring Boot 的测试  424
10.4.1 新建Spring Boot 项目 425
10.4.2 业务代码 425
10.4.3 测试用例 427
10.4.4 执行测试 429
第11 章 应用监控  431
11.1 http 431
11.1.1 新建Spring Boot 项目 432
11.1.2 测试端点 432
11.1.3 定制端点 439
11.1.4 自定义端点  440
11.1.5 自定义HealthIndicator  444
11.2 JMX  447
11.3 SSH  449
11.3.1 新建Spring Boot 项目 449
11.3.2 运行  449
11.3.3 常用命令 451
11.3.4 定制登录用户  452
11.3.5 扩展命令 452
第12 章 分布式系统开发  456
12.1 微服务、原生云应用 456
12.2 Spring Cloud 快速入门  457
12.2.1 配置服务 457
12.2.2 服务发现 457
12.2.3 路由网关 457
12.2.4 负载均衡 457
12.2.5 断路器  458
12.3 实战  458
12.3.1 项目构建 458
12.3.2 服务发现——Discovery（Eureka Server）  459
12.3.3 配置——Config（Config Server）  461
12.3.4 服务模块——Person 服务  463
12.3.5 服务模块——Some 服务  466
12.3.6 界面模块——UI（Ribbon,Feign） 468
12.3.7 断路器监控——Monitor（DashBoard） 473
12.3.8 运行  474
12.4 基于Docker 部署 478
12.4.1 Dockerfile 编写  478
12.4.2 Docker Compose 480
12.4.3 Docker-compose.yml 编写 481
12.4.4 运行  483
附录A 485
A.1 基于JHipster 的代码生成 485
A.2 常用应用属性配置列表 488
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JavaEE开发的颠覆者: Spring Boot实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web入门经典
前言
第一篇起步篇
第1章开启JaveWeb之门
视频讲解：19分钟
1.1初识JavaW曲
1.1.1Java概述
1.1.2Java语言的主要特点
1.1.3JavaWeb概述
1.1.4JavaWeb成功案例
1.2Web应用技术
1.2.1客户端应用技术
1.2.2服务器端应用技术
1.3Web应用程序的工作原理
1.4网络程序开发体系结构
1.4.1什么是C／S结构
1.4.2什么是B／S结构
1.4.3B／S与C／S的区别
1.5JavaWeb网站的基本构建流程
1.6常用网上资源
1.6.1常用资源下载网
1.6.2技术社区
1.7小结
1.8习题
第2章不可不知的客户端应用技术
视频讲解：113分钟
2.1构建页面内容的HTML5标记语言
2.1.1了解HTML5文档结构
2.1.2HTML文字排版标记
2.1.3图片与超链接标记
2.1.4HTML5新增的语义元素
2.1.5制作表格
2.1.6播放音频和视频
2.1.7表单标记
2.2美化页面的CSS样式表
2.2.1样式表的定义与引用
2.2.2CSS规则
2.2.3CSS选择器
2.2.4CSS常用属性
2.3客户端交互的JaVaScript
2.3.1JavaScript的语言基础
2.3.2JavaScript的流程控制语句
2.3.3JavaScript函数的定义及调用
2.3.4事件处理
2.3.5常用对象
2.3.6DOM技术
2.4上机实践
2.4.1使用删除线样式标注商品特价
2.4.2将小写金额转换为大写金额
2.4.3验证用户注册信息的合法性
2.5小结
2.6习题
第3章驾驭JavaWeb开发环境
视频讲解：25分钟
3.1JavaWeb所需要的开发环境
3.1.1开发工具包JDK
3.1.2Web服务器
3.1.3数据库
3.1.4Web浏览器
3.2安装和配置JDK
3.2.1下载JDK
3.2.2安装JDK
3.2.3在Windows系统下配置和测试JDK
3.3安装和配置Tomcat
3.3.1获取Tomcat
3.3.2熟悉Tomcat
3.3.3修改Tomcat的默认端口
3.4Eclipse开发工具的安装与使用
3.4.1Eclipse的下载与安装
3.4.2启动Eclipse
3.4.3安装Eclipse中文语言包
3.4.4Eclipse工作台
3.5做好项目开发的准备工作
3.5.1集成Eclipse与Tomcat
3.5.2完善Web项目开发所需配置
3.6使用Eclipse开发一个JSP网站
3.7小结
3.8习题
第4章JavaWeb开发必修课之JSP语法
视频讲解：55分钟
4.1了解JSP页面的基本构成
4.2使用JSP指令标识
4.2.1使用页面指令page
4.2.2使用文件包含指令include
4.2.3使用引用标签库指令taglib
4.3使用JSP脚本
4.3.1在JSP中应用代码片段
4.3.2使用JSP表达式
4.3.3使用声明标识
4.4巧用注释
4.4.1基本HTML注释
4.4.2隐藏注释
4.4.3代码片段中的注释
4.5常用JSP动作标识
4.5.1使用包含动作标识勺sp=include)
4.5.2使用请求转发的动作标识(jsp：forward)
4.5.3使用子动作标识(jsp：param)
4.5.4使用动作标识(jsp：useBean)
4.5.5使用动作标识(jsp：getProperty)
4.5.6使用动作标识(jsp：setProperty)
4.6上机实践
4.6.1应用Java程序片段动态生成表格
4.6.2将页面转发到用户登录页面
4.6.3应用JavaBean保存图片信息
4.7小结
4.8习题
第二篇核心篇
第5章程序开发效率之利器——内置对象
视频讲解：69分钟
5.1JSP内置对象概述
5.1.1内置对象的作用
5.1.2内置对象及其应用场合
5.2request请求对象
5.2.1获取请求参数
5.2.2解决中文乱码问题
5.2.3获取客户端数据
5.2.4应用request对象域
5.3response响应对象
5.3.1操作HTTP头信息
5.3.2设置MIME类型
5.3.3实现页面重定向
5.40ut输出对象
5.4.1向客户端输出数据
5.4.2管理缓冲区
5.5session会话对象
5.5.1session的生命周期
5.5.2创建与获取会话
5.5.3移除对话中的数据
5.5.4设置会话的有效时间
5.5.5应用session对象模拟用户登录
5.6应用application对象
5.6.1application对象的生命周期
5.6.2操作application对象中数据
5.6.3配置Web应用的初始化参数
5.6.4应用application对象实现网页计数器
5.7其他内置对象
5.7.1应答与请求的page对象
5.7.2页面上下文的pageContext对象
5.7.3获取web.xml配置信息的config对象
5.7.4获取异常信息的exception对象
5.8上机实践
5.8.1通过request对象获取用户注册信息
5.8.2防止表单在网站外部提交
5.8.3通过cookie保存并读取用户登录信息
5.9小结
5.10习题
第6章完美的“咖啡豆”——JavaBean技术
视频讲解：26分钟
6.1JavaBean概述
6.1.1JavaBean的产生背景
6.1.2JavaBean的作用
6.1.3JavaBean的规范
6.1.4JavaBean的种类
6.2Eclipse对JavaBean方法的支持
6.3JavaBean的应用
6.3.1获取JavaBean的属性
6.3.2对JavaBean的属性赋值
6.3.3如何在JSP页面中应用JavaBean
6.4上机实践
6.4.1判断用户名是否有效
6.4.2计算两个日期相差的天数
6.4.3随机生成指定位数的验证码
6.5小结
6.6习题
第7章Web应用的缔造者——Servlet
视频讲解：46分钟
7.1Servlet技术
7.1.1Servlet概述
7.1.2Servlet功能
7.1.3Servlet特点
7.1.4Servlet的生命周期
7.2Servlet技术开发
7.2.1Servlet在JavaEE中的结构体系
7.2.2Servlet核心API
7.2.3创建第一个Servlet类
7.2.4Servlet配置
7.2.5使用Servlet处理业务逻辑
7.2.6使用Eclipse快速创建Servlet
7.3Servlet的典型应用
7.3.1处理表单数据
7.3.2页面转发
7.3.3获取当前页的绝对路径
7.4配置并使用Servlet过滤器
7.4.1过滤器的处理方式
7.4.2过滤器的核心对象
7.4.3创建并配置过滤器
7.4.4字符编码过滤器
7.5Servlet监听器
7.5.1Servlet监听器简介
7.5.2Servlet监听器的工作原理
7.5.3监听Servlet上下文
7.5.4监听HTTP会话
7.5.5监听Servlet请求
7.5.6使用监听器查看在线用户
7.6上机实践
7.6.1记录用户访问次数
7.6.2防盗链过滤器
7.6.3敏感词过滤器
7.7小结
7.8习题
……
第8章使用表达式语言（EL）
第9章页面控制利器——JSTL标签库
第10章数据库应用开发
第三篇高级篇
第四篇项目实战篇
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web入门经典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Servlet&JSP经典实例
前言
第1章 编写servlet和JSP 6 ～19
1.0 引言
1.1 编写Servlet
1.2 编写JSP
1.3 编译Servlet
1.4 将Servlet和JSP打包
1.5 创建部署描述文件
第2章 部署servlet和JSP 20 ～41
2.0 引言
2.1 在Tomcat中部署独立的Servlet
2.2 在Tomcat的server.xml中使用Context元素
2.3 在WebLogic中部署独立的Servlet
2.4 在Tomcat中部署独立的JSP
2.5 在WebLogic中部署独立的JSP
2.6 在Tomcat中部署Web应用程序
2.7 在WebLogic中使用Ant部署Web应用程序
2.8 使用WebLogic管理控制台
2.9 使用WebLogic Builder部署Web应用程序
2.10 使用weblogic.Deployer命令行工具
第3章 为Servlet命名 42 ～63
3.0 引言
3.1 在web.xml中将Servlet映射为名
3.2 为一个Servlet创建多个映射
3.3 为Servlet创建JSP风格的URL
3.4 将静态内容映射到Servlet
3.5 不使用web.xml映射而调用Servlet
3.6 将所有Web应用程序的请求映射到一个Servlet
3.7 将请求映射到控制器并保留Servlet映射
3.8 为Web应用程序创建欢迎文件
3.9 限制对某些Servlet的请求
3.10 仅赋予控制器对某些Servlet的访问权限
第4章 使用Apache Ant 65 ～85
4.0 引言
4.1 获取和安装Ant
4.2 使用Ant目标
4.3 在构建文件类路径中包括Tomcat JAR文件
4.4 用Ant构建文件编译Servlet
4.5 用Ant创建WAR文件
4.6 用Ant创建JAR文件
4.7 用Ant启动Tomcat应用程序
4.8 用Ant停止Tomcat应用程序
第5章 转换JSP格式 86 ～103
5.0 引言
5.1 在Tomcat中预编译JSP
5.2 在WebLogic中预编译JSP
5.3 使用预编译协议预编译JSP
5.4 将JSP映射为页面实现类
5.5 从头开始创建JSP文档格式的JSP
5.6 从JSP中生成XML视图
第6章 在Servlet和JSP中动态地导入内容 104 ～127
6.0 引言
6.1 在Servlet每次处理请求时导入资源
6.2 在Servlet中使用外部配置导入资源
6.3 在Servlet中导入嵌套多层的资源
6.4 在JSP中导入很少改变的资源
6.5 在JSP每次处理请求时导入内容
6.6 使用外部配置文件在JSP中导入资源
6.7 在JSP文档中导入XML代码段
6.8 在JSP导入上下文之外的内容
第7章 在Servlet和JSP中处理Web表单数据 128 ～151
7.0 引言
7.1 在Servlet中处理POST HTTP请求
7.2 在JSP中处理POST HTTP请求
7.3 在JSP中设置JavaBean的特性
7.4 在JSP中设置表单参数值的作用范围
7.5 从Servlet中发送数据
7.6 从JSP中发送数据
7.7 使用Servlet向查询字符串添加参数
7.8 使用JSP向查询字符串添加参数
7.9 使用过滤器读取参数值
第8章 上传文件 152 ～168
8.0 引言
8.1 准备文件上传的HTML页面
8.2 使用com.oreilly.servlet库
8.3 一次上传一个文件
8.4 上传多个文件
8.5 文件重命名
8.6 使用JSP处理文件上传
第9章 在Web应用程序中处理异常 169 ～182
9.0 引言
9.1 在web.xml中声明异常处理器
9.2 创建处理异常的Servlet
9.3 从Servlet中发出错误
9.4 从JSP中发出错误
9.5 创建处理错误的JSP
9.6 声明为其他JSP处理异常的特殊JSP
第10章 读取和设置Cookie 183 ～198
10.0 引言
10.1 使用Servlet设置Cookie
10.2 创建请求中所有Cookie的数组
10.3 使用JSP设置Cookie
10.4 使用Servlet读取Cookie的值
10.5 使用JSP读取Cookie的值
10.6 修改或移除已经设置的Cookie
第11章 跟踪会话 198 ～229
11.0 引言
11.1 在web.xml中设置会话超时时间
11.2 在所有Tomcat Web应用程序中设置会话超时时间
11.3 以编程方式设置会话超时时间
11.4 检查会话是否存在于HttpServletRequest
11.5 在Servlet中跟踪会话的活动
11.6 在JSP中跟踪会话的活动
11.7 在JSP中使用URL重写
11.8 在Servlet中使用URL重写
11.9 使用监听器跟踪会话的生命周期
11.10 使用监听器监视会话属性
11.11 使用过滤器监视会话属性
第12章 在Servlet和JSP中集成JavaScript 230 ～243
12.0 引言
12.1 在Servlet中包括JavaScript模块
12.2 在JSP中包括JavaScript模块
12.3 在Sevlet中使用JavaScript创建新窗口
12.4 在JSP中使用JavaScript创建新窗口
12.5 在Servlet中使用JavaScript验证表单值
12.6 在JSP中使用JavaScript验证表单值
第13章 发送非HTML内容 244 ～260
13.0 引言
13.1 发送PDF文件
13.2 发送字处理文件
13.3 发送XML文件
13.4 发送音频文件
13.5 在Servlet中查看内部资源
第14章 记录Servlet和JSP中的消息日志 261 ～285
14.0 引言
14.1 不通过Log4j记录日志
14.2 设置Log4j
14.3 不通过配置文件使用日志记录器
14.4 向Root日志记录器添加日志存储器
14.5 在日志记录器的存储器中使用模式
14.6 在JSP中使用log4j
14.7 使用Servlet上下文事件监听器记录消息日志
14.8 使用会话事件监听器记录消息日志
第15章 客户端认证 286 ～312
15.0 引言
15.1 用Tomcat创建用户和口令
15.2 在Tomcat中建立SSL
15.3 使用BASIC认证
15.4 使用基于表单的认证
15.5 注销用户
15.6 使用JAAS创建LoginModule
15.7 创建JAAS配置文件
15.8 在Servlet中使用JAAS
15.9 在JSP中使用JAAS
第16章 在Web应用程序中绑定、访问和移除属性 313 ～334
16.0 引言
16.1 在Servlet中设置ServletContext属性
16.2 在JSP中设置ServletContext属性
16.3 在Servlet中访问或移除ServletContext属性
16.4 在JSP中访问或移除ServletContext属性
16.5 在Servlet中设置会话属性
16.6 在JSP中设置会话属性
16.7 在Servlet中访问或移除会话属性
16.8 在JSP中访问或移除会话属性
16.9 在Servlet中设置请求属性
16.10 在JSP中设置请求属性
16.11 在Servlet中访问或移除请求属性
16.12 在JSP中访问或移除请求属性
第17章 在JSP中嵌入多媒体 335 ～350
17.0 引言
17.1 使用jsp:plugin在JSP中嵌入Applet
17.2 使用HTML Converter在JSP中嵌入Applet
17.3 自动创建包括Flash文件的HTML模板
17.4 编写嵌入Flash文件的HTML模板
17.5 在Servlet中嵌入Flash
17.6 在JSP中嵌入QuickTime影片
17.7 在JSP中嵌入SVG文件
17.8 在JSP中嵌入背景音乐
第18章 处理客户请求 351 ～362
18.0 引言
18.1 检查servlet中的HTTP请求首部
18.2 检查JSP中的HTTP请求首部
18.3 使用过滤器修改请求首部
18.4 自动刷新Servlet
18.5 自动刷新JSP
18.6 Web应用程序请求的计数
第19章 过滤请求和响应 363 ～388
19.0 引言
19.1 将过滤器映射到Servlet
19.2 将过滤器映射到JSP
19.3 将多个过滤器映射到一个Servlet
19.4 改变应用于Servlet的过滤器的顺序
19.5 为过滤器配置初始参数
19.6 可选择地使用过滤器阻塞请求
19.7 过滤HTTP响应
19.8 使用过滤器操作RequestDispatcher对象
19.9 使用过滤器检查表单参数
19.10 使用过滤器阻塞IP地址
第20章 在Servlet和JSP中操纵电子邮件 389 ～420
20.0 引言
20.1 将电子邮件有关的类放置于类路径中
20.2 在servlet中发送电子邮件
20.3 使用JavaBean在Servlet中发送电子邮件
20.4 在Servlet中访问电子邮件
20.5 使用JavaBean在Servlet中访问电子邮件
20.6 在Servlet中处理所接收电子邮件的附件
20.7 在Servlet中向电子邮件添加附件
20.8 在Servlet中读取所接收电子邮件的首部
第21章 访问数据库 421 ～465
21.0 引言
21.1 不用DataSource在servlet中访问数据库
21.2 在Tomcat中配置DataSource
21.3 在Tomcat的Servlet中使用DataSource
21.4 在WebLogic中创建DataSource
21.5 在WebLogic使用 JNDI查找来获取DataSource
21.6 在WebLogic的JSP中使用DataSource
21.7 在Servlet中调用存储过程
21.8 在JSP中调用存储过程
21.9 将ResultSet to转换为Result对象
21.10 在一个事务中执行多个SQL语句
21.11 在JSP中使用事务
21.12 查询ResultSet的有关信息
第22章 使用定制标记库 466 ～493
22.0 引言
22.1 创建典型标记处理器
22.2 为典型标记处理器创建JSP 1.2 TLD
22.3 为典型标记处理器创建JSP 2.0 TLD
22.4 在Web应用程序中打包标记库
22.5 将标记库打包在JAR文件中
22.6 在JSP中使用定制标记
22.7 在定制标记类中处理异常
22.8 创建简单标记处理器
22.9 为简单标记处理器创建TLD
22.10 在JSP中使用简单标记处理器
22.11 创建JSP标记文件
22.12 在Web应用程序中打包JSP标记文件
22.13 将JSP标记文件打包在JAR中
22.14 使用与标记文件关联的定制标记
22.15 向标记库添加监听器类
第23章 使用JSTL 494 ～527
23.0 引言
23.1 下载JSTL 1.0并在JSP中使用JSTL标记
23.2 下载Java Web服务开发者包
23.3 使用核心JSTL标记
23.4 使用XML核心JSTL标记
23.5 使用XML转换标记
23.6 使用格式化JSTL标记
23.7 通过DataSource配置使用SQL JSTL标记
23.8 不通过DataSource配置使用SQL JSTL标记
23.9 用EL访问作用范围内的变量
23.10 用EL访问请求参数
23.11 使用EL访问请求首部
23.12 使用EL访问一个请求首部
23.13 使用EL访问Cookie
23.14 使用EL访问JavaBean特性
23.15 使用JSTL函数
第24章 国际化 528 ～549
24.0 引言
24.1 在Servlet中检测客户区域
24.2 在JSP中检测客户区域
24.3 以特性文件方式创建一个ResourceBundle
24.4 以Java类方式创建ResourceBundle
24.5 在Servlet中使用ResourceBundle
24.6 在JSP中使用ResourceBundle
24.7 在Servlet中格式化日期
24.8 在JSP中格式化日期
24.9 在Servlet中格式化货币
24.10 在JSP中格式化货币
24.11 在Servlet中格式化百分数
24.12 在JSP中格式化百分数
24.13 在部署描述文件中设置区域化上下文
第25章 使用JNDI和企业级JavaBean 550 ～579
25.0 引言
25.1 在Tomcat中配置JNDI对象
25.2 在Servlet中访问Tomcat JNDI资源
25.3 在JSP中访问Tomcat JNDI资源
25.4 在WebLogic中配置JNDI资源
25.5 在WebLogic中查看JNDI树
25.6 在Servlet中访问WebLogic JNDI资源
25.7 在JSP中访问WebLogic JNDI资源
25.8 使用WebLogic JNDI树访问EJB
第26章 收集Web信息 580 ～595
26.0 引言
26.1 使用javax.swing.text子包解析HTML页面
26.2 使用Servlet收集Web数据
26.3 创建作为Web页面解析器的JavaBean
26.4 在Servlet中使用Web页面解析JavaBean
26.5 在JSP中使用Web页面解析JavaBean
第27章 使用Google和Amazon Web API 596 ～619
27.0 引言
27.1 准备使用Google的Web API
27.2 创建连接Google的JavaBean
27.3 使用Servlet连接Google
27.4 使用JSP连接Google
27.5 准备使用Amazon的Web服务API
27.6 创建连接Amazon的JavaBean
27.7 使用Servlet连接Amazon
27.8 使用JSP连接Amazon
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Servlet&JSP经典实例
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入嵌入式Java虚拟机
第一章 Java与KVM的关系
第二章 Java类文件格式
第三章 KVM执行时所用的class与instance结构
第四章 KVM执行时所用的数据结构
第五章 KVM内部的Interpreter
第六章 Methods invokation
第七章 Exceptions
第八章 Garbage Collection
第九章 编写KVM的native methods
第十章 The Technology Compatibility Kit(TCK)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入嵌入式Java虚拟机
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入体验Java Web开发内幕
第1章 文件上传组件的应用与编写
1.1 准备实验环境
1.2 Apache文件上传组件的应用
1.3 Apache文件上传组件的源码赏析
第2章 Fiter（过滤器）
第3章 Servlet事件监听器
第4章 开发国际化的Web程序
第5章 表达式语言（EL）
第6章 自定义标签的开发与使用
第7章 简单标签与标签文件
第8章 标准标签库（JSTL）
第9章 Web安全域
第10章 Tomcat的配置和管理平台
第11章 JSP文档
附录A 应用程序部署描述符
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入体验Java Web开发内幕
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring揭秘
第一部分 掀起Spring的盖头来
第1章 Spring框架的由来 2
1.1 Spring之崛起 2
1.2 Spring框架概述 3
1.3 Spring大观园 5
1.4 小结 8
第二部分 Spring的IoC容器
第2章 IoC的基本概念 10
2.1 我们的理念是：让别人为你服务 10
2.2 手语，呼喊，还是心有灵犀 13
2.2.1 构造方法注入 13
2.2.2 setter方法注入 13
2.2.3 接口注入 14
2.2.4 三种注入方式的比较 15
2.3 IoC的附加值 15
2.4 小结 17
第3章 掌管大局的IoC Service Provider 18
3.1 IoC Service Provider的职责 18
3.2 运筹帷幄的秘密——IoC Service Provider如何管理对象间的依赖关系 19
3.2.1 直接编码方式 19
3.2.2 配置文件方式 20
3.2.3 元数据方式 21
3.3 小结 21
第4章 Spring的IoC容器之BeanFactory 22
4.1 拥有BeanFactory之后的生活 24
4.2 BeanFactory的对象注册与依赖绑定方式 26
4.2.1 直接编码方式 26
4.2.2 外部配置文件方式 28
4.2.3 注解方式 31
4.3 BeanFactory的XML之旅 33
4.3.1 beans和bean 33
4.3.2 孤孤单单一个人 35
4.3.3 Help Me， Help You 36
4.3.4 继承？我也会！ 50
4.3.5 bean的scope 51
4.3.6 工厂方法与FactoryBean 56
4.3.7 偷梁换柱之术 61
4.4 容器背后的秘密 66
4.4.1 “战略性观望” 66
4.4.2 插手“容器的启动” 67
4.4.3 了解bean的一生 74
4.5 小结 85
第5章 Spring IoC容器ApplicationContext 86
5.1 统一资源加载策略 86
5.1.1 Spring中的Resource 87
5.1.2 ResourceLoader，“更广义的URL” 88
5.1.3 ApplicationContext与ResourceLoader 91
5.2 国际化信息支持(I18n MessageSource) 97
5.2.1 Java SE提供的国际化支持 97
5.2.2 MessageSource与ApplicationContext 98
5.3 容器内部事件发布 102
5.3.1 自定义事件发布 102
5.3.2 Spring的容器内事件发布类结构分析 105
5.3.3 Spring容器内事件发布的应用 107
5.4 多配置模块加载的简化 109
5.5 小结 110
第6章 Spring IoC容器之扩展篇 111
6.1 Spring 2.5的基于注解的依赖注入 111
6.1.1 注解版的自动绑定(@Autowired) 111
6.1.2 @Autowired之外的选择——使用JSR250标注依赖注入关系 115
6.1.3 将革命进行得更彻底一些(class-path-scanning功能介绍) 116
6.2 Spring 3.0展望 119
6.3 小结 120
第三部分 Spring AOP框架
第7章 一起来看AOP 122
7.1 AOP的尴尬 124
7.2 AOP走向现实 125
7.2.1 静态AOP时代 125
7.2.2 动态AOP时代 126
7.3 Java平台上的AOP实现机制 126
7.3.1 动态代理 126
7.3.2 动态字节码增强 126
7.3.3 Java代码生成 127
7.3.4 自定义类加载器 127
7.3.5 AOL扩展 127
7.4 AOP国家的公民 128
7.4.1 Joinpoint 128
7.4.2 Pointcut 130
7.4.3 Advice 131
7.4.4 Aspect 133
7.4.5 织入和织入器 133
7.4.6 目标对象 133
7.5 小结 134
第8章 Spring AOP概述及其实现机制 135
8.1 Spring AOP概述 135
8.2 Spring AOP的实现机制 136
8.2.1 设计模式之代理模式 136
8.2.2 动态代理 139
8.2.3 动态字节码生成 141
8.3 小结 142
第9章 Spring AOP一世 143
9.1 Spring AOP中的Joinpoint 143
9.2 Spring AOP中的Pointcut 144
9.2.1 常见的Pointcut 146
9.2.2 扩展Pointcut(Customize Pointcut) 151
9.2.3 IoC容器中的Pointcut 152
9.3 Spring AOP中的Advice 153
9.3.1 per-class类型的Advice 153
9.3.2 per-instance类型的Advice 159
9.4 Spring AOP中的Aspect 163
9.4.1 PointcutAdvisor家族 164
9.4.2 IntroductionAdvisor分支 167
9.4.3 Ordered的作用 168
9.5 Spring AOP的织入 170
9.5.1 如何与ProxyFactory打交道 170
9.5.2 看清ProxyFactory的本质 175
9.5.3 容器中的织入器——ProxyFactoryBean 179
9.5.4 加快织入的自动化进程 185
9.6 TargetSource 190
9.6.1 可用的TargetSource实现类 191
9.6.2 自定义TargetSource 195
9.7 小结 197
第10章 Spring AOP二世 198
10.1 @AspectJ形式的Spring AOP 198
10.1.1 @AspectJ形式AOP使用之先睹为快 199
10.1.2 @AspectJ形式的Pointcut 201
10.1.3 @AspectJ形式的Advice 211
10.1.4 @AspectJ中的Aspect更多话题 220
10.2 基于Schema的AOP 223
10.2.1 基于Schema的AOP配置概览 223
10.2.2 向基于Schema的AOP迁移 225
10.2.3 @AspectJ到“基于Schema的AOP”迁移 227
10.3 小结 235
第11章 AOP应用案例 237
11.1 异常处理 237
11.1.1 Java异常处理 237
11.1.2 Fault Barrier 238
11.2 安全检查 239
11.3 缓存 240
11.4 小结 240
第12章 Spring AOP之扩展篇 241
12.1 有关公开当前调用的代理对象的探讨 241
12.1.1 问题的现象 241
12.1.2 原因的分析 242
12.1.3 解决方案 243
12.2 小结 245
第四部分 使用Spring访问数据
第13章 统一的数据访问异常层次体系 249
13.1 DAO模式的背景 249
13.2 梦想照进现实 251
13.3 发现问题，解决问题 252
13.4 不重新发明轮子 254
13.5 小结 257
第14章 JDBC API的最佳实践 258
14.1 基于Template的JDBC使用方式 258
14.1.1 JDBC的尴尬 258
14.1.2 JdbcTemplate的诞生 261
14.1.3 JdbcTemplate和它的兄弟们 274
14.1.4 Spring中的DataSource 296
14.1.5 JdbcDaoSupport 301
14.2 基于操作对象的JDBC使用方式 302
14.2.1 基于操作对象的查询 303
14.2.2 基于操作对象的更新 310
14.2.3 基于操作对象的存储过程调用 313
14.3 小结 316
第15章 Spring对各种ORM的集成 317
15.1 Spring对Hibernate的集成 318
15.1.1 旧日“冬眠”时光 318
15.1.2 “春天”里的“冬眠” 321
15.2 Spring对iBATIS的集成 329
15.2.1 iBATIS实践之“前生”篇 329
15.2.2 iBATIS实践之“今世”篇 331
15.3 Spring中对其他ORM方案的集成概述 337
15.3.1 Spring对JDO的集成 337
15.3.2 Spring对TopLink的集成 340
15.3.3 Spring对JPA的集成 341
15.4 小结 344
第16章 Spring数据访问之扩展篇 345
16.1 活用模板方法模式及Callback 345
16.1.1 FTPClientTemplate 345
16.1.2 HttpClientTemplate 349
16.2 数据访问中的多数据源 350
16.2.1 “主权独立”的多数据源 350
16.2.2 “合纵连横”的多数据源 352
16.2.3 结束语 354
16.3 Spring 3.0展望 356
16.4 小结 356
第五部分 事务管理
第17章 有关事务的楔子 358
17.1 认识事务本身 358
17.2 初识事务家族成员 360
17.3 小结 362
第18章 群雄逐鹿下的Java事务管理 363
18.1 Java平台的局部事务支持 363
18.2 Java平台的分布式事务支持 365
18.2.1 基于JTA的分布式事务管理 366
18.2.2 基于JCA的分布式事务管理 367
18.3 继续前行之前的反思 367
18.4 小结 369
第19章 Spring事务王国的架构 370
19.1 统一中原的过程 371
19.2 和平年代 376
19.2.1 TransactionDefinition 376
19.2.2 TransactionStatus 382
19.2.3 PlatformTransac-tionManager 382
19.3 小结 392
第20章 使用Spring进行事务管理 393
20.1 编程式事务管理 393
20.1.1 直接使用PlatformTran-sactionManager进行编程式事务管理 393
20.1.2 使用TransactionTemp-late进行编程式事务管理 394
20.1.3 编程创建基于Savepoint的嵌套事务 396
20.2 声明式事务管理 397
20.2.1 引子 397
20.2.2 XML元数据驱动的声明式事务 399
20.2.3 注解元数据驱动的声明式事务 410
20.3 小结 413
第21章 Spring事务管理之扩展篇 414
21.1 理解并活用ThreadLocal 414
21.1.1 理解ThreadLocal的存在背景 414
21.1.2 理解ThreadLocal的实现 415
21.1.3 ThreadLocal的应用场景 416
21.1.4 使用ThreadLocal管理多数据源切换的条件 417
21.2 谈Strategy模式在开发过程中的应用 420
21.3 Spring与JTA背后的奥秘 423
21.4 小结 427
第六部分 Spring的Web MVC框架
第22章 迈向Spring MVC的旅程 430
22.1 Servlet独行天下的时代 430
22.2 繁盛一时的JSP时代 433
22.3 Servlet与JSP的联盟 436
22.4 数英雄人物，还看今朝 438
22.5 小结 440
第23章 Spring MVC初体验 441
23.1 鸟瞰Spring MVC 442
23.2 实践出真知 446
23.2.1 Spring MVC应用的物理结构 447
23.2.2 按部就班地开始工作 451
23.3 小结 459
第24章 近距离接触Spring MVC主要角色 460
24.1 忙碌的协调人HandlerMapping 460
24.1.1 可用的HandlerMapping 461
24.1.2 HandlerMapping执行序列(Chain Of HandlerMapping) 463
24.2 我们的亲密伙伴Controller 464
24.2.1 AbstractController 465
24.2.2 MultiActionController 468
24.2.3 SimpleFormController 476
24.2.4 AbstractWizard-FormController 496
24.2.5 其他可用的Controller实现 503
24.3 ModelAndView 505
24.3.1 ModelAndView中的视图信息 505
24.3.2 ModelAndView中的模型数据 506
24.4 视图定位器ViewResolver 506
24.4.1 可用的ViewResolver实现类 507
24.4.2 ViewResolver查找序列(Chain Of ViewResolver) 511
24.5 各司其职的View 511
24.5.1 View实现原理回顾 512
24.5.2 可用的View实现类 515
24.5.3 自定义View实现 521
24.6 小结 523
第25章 认识更多Spring MVC家族成员 524
25.1 文件上传与MultipartResolver 525
25.1.1 使用MultipartResolver进行文件上传的简单分析 526
25.1.2 文件上传实践 527
25.2 Handler与HandlerAdaptor 530
25.2.1 问题的起源 530
25.2.2 深入了解Handler 531
25.2.3 近看HandlerAdaptor的奥秘 533
25.2.4 告知Handler与Handler-Adaptor的存在 535
25.3 框架内处理流程拦截与Handler-Interceptor 536
25.3.1 可用的Handler-Interceptor实现 537
25.3.2 自定义实现Handler-Interceptor 538
25.3.3 HandlerInterceptor寻根 540
25.3.4 HandlerInterceptor之外的选择 541
25.4 框架内的异常处理与Handler-ExceptionResolver 544
25.5 国际化视图与LocalResolver 548
25.5.1 可用的LocaleResolver 549
25.5.2 LocaleResolver的足迹 550
25.5.3 Locale的变更与LocaleChangeHandler 551
25.6 主题(Theme)与ThemeResolver 552
25.6.1 提供主题资源的ThemeSource 552
25.6.2 管理主题的ThemeResolver 554
25.6.3 切换主题的ThemeChange-Interceptor 555
25.7 小结 556
第26章 Spring MVC中基于注解的Controller 557
26.1 初识基于注解的Controller 557
26.2 基于注解的Controller原型分析 558
26.2.1 自定义用于基于注解的Contro-ller的HandlerMapping 558
26.2.2 自定义用于基于注解的Contro-ller的HandlerAdaptor 560
26.3 近看基于注解的Controller 563
26.3.1 声明基于注解的Controller 563
26.3.2 请求参数到方法参数的绑定 569
26.3.3 使用@ModelAttribute访问模型数据 572
26.3.4 通过@SessionAttribute管理Session数据 574
26.4 小结 576
第27章 Spring MVC之扩展篇 577
27.1 Spring MVC也Convention Over Configuration 577
27.1.1 Convention Over Configuration简介 577
27.1.2 Spring MVC中的Convention Over Configuration 578
27.2 Spring 3.0展望 581
27.3 小结 582
第七部分 Spring框架对J2EE服务的集成和支持
第28章 Spring框架内的JNDI支持 584
28.1 JNDI简单回顾 584
28.2 Spring框架内JNDI访问的基石——JndiTemplate 585
28.3 JNDI对象的依赖注入——JndiObjectFactoryBean 587
28.4 小结 588
第29章 Spring框架对JMS的集成 589
29.1 说说JMS的身世 589
29.2 使用JMS API进行应用开发的传统套路 590
29.3 Spring改进后的JMS实战格斗术 592
29.3.1 消息发送和同步接收 592
29.3.2 异步消息接收 601
29.3.3 JMS相关异常处理 607
29.3.4 框架内的事务管理支持 608
29.4 小结 609
第30章 使用Spring发送E-mail 610
30.1 思甜前，先忆苦 610
30.2 Spring的E-mail抽象层分析 612
30.2.1 直接创建邮件消息并发送 614
30.2.2 使用MimeMessage-Preparator发送邮件 615
30.3 Spring的E-mail支持在实际开发中的应用 616
30.4 小结 622
第31章 Spring中的任务调度和线程池支持 623
31.1 Spring与Quartz 623
31.1.1 初识Quartz 623
31.1.2 融入Spring大家庭的Quartz 626
31.2 Spring对JDK Timer的集成 631
31.2.1 JDK Timer小记 631
31.2.2 Spring集成后的JDK Timer 632
31.3 Executor的孪生兄弟TaskExecutor 634
31.3.1 可用的TaskExecutor 635
31.3.2 TaskExecutor使用实例 637
31.4 小结 639
第32章 Spring框架对J2EE服务的集成之扩展篇 640
32.1 MailMonitor的延伸 640
32.2 Spring 3.0展望 642
32.3 小结 642
第33章 Spring远程方案 643
33.1 从“对面交谈”到“千里传声” 643
33.2 Spring Remoting架构分析 645
33.2.1 Spring Remoting之远程访问异常体系 645
33.2.2 统一风格的远程服务公开与访问方式 646
33.3 Spring Remoting提供的远程服务支持 648
33.3.1 基于RMI的Remoting方案 648
33.3.2 基于HTTP的轻量级Remoting方案 651
33.3.3 基于Web服务的远程方案 655
33.3.4 基于JMS的远程方案 658
33.4 扩展Spring Remoting 660
33.5 Spring Remoting之扩展篇 663
33.5.1 拉开JMX演出的序幕 663
33.5.2 Spring 3.0展望 664
参考文献 665
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring揭秘
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>第一行代码 Java 视频讲解版
第一部分　Java基础知识
第1章　Java简介　2
（视频107分钟，例题2个，提示9个，注意6个，问答2个，技术穿越1个，面试题2个）
1.1　Java简介　2
1.2　JDK的安装与配置　8
1.3　第一个Java程序：永远的“Hello World !”　11
1.4　第一个程序解释　12
1.5　CLASSPATH　14
本章小结　15
课后习题　16
第2章　程序基本概念　17
（视频244分钟，例题66个，提示20个，注意12个，问答3个，技术穿越8个，面试题2个）
2.1　Java的注释　17
2.2　标识符与关键字　19
2.3　数据类型划分　20
2.3.1　整型　22
2.3.2　浮点数　27
2.3.3　字符型　29
2.3.4　布尔型　31
2.3.5　String型数据　31
2.4　运算符　33
2.4.1　关系运算符　36
2.4.2　数学运算符　37
2.4.3　三目运算　40
2.4.4　逻辑运算　41
2.4.5　位运算　44
2.5　程序逻辑控制　46
2.5.1　分支结构　47
2.5.2　循环结构　52
2.5.3　循环控制　58
2.6　方法的定义及使用　59
2.6.1　方法的基本概念　59
2.6.2　方法的重载　63
2.6.3　方法的递归调用　65
本章小结　66
课后习题　66
第二部分　面向对象
第3章　面向对象基本概念　70
（视频898分钟，例题135个，提示37个，注意12个，问答10个，技术穿越17个，面试题3个）
3.1　面向对象简介　70
3.2　类与对象　72
3.2.1　类与对象的基本概念　72
3.2.2　类与对象的基本定义　73
3.2.3　引用数据的初步分析　78
3.3　封装性初步分析　82
3.4　构造方法　85
3.5　匿名对象　90
3.6　简单Java类　91
3.7　数组　93
3.7.1　数组的基本概念　93
3.7.2　二维数组　97
3.7.3　数组与方法参数的传递　98
3.7.4　数组操作方法　108
3.7.5　对象数组　109
3.8　String类的基本概念　111
3.8.1　String类的两种实例化方式　111
3.8.2　字符串的比较1　112
3.8.3　字符串常量就是String的匿名
对象　114
3.8.4　两种实例化方式的区别　115
3.8.5　字符串一旦定义则不可改变　118
3.9　String类的常用方法　120
3.9.1　字符与字符串　122
3.9.2　字节与字符串　125
3.9.3　字符串的比较2　126
3.9.4　字符串的查找　127
3.9.5　字符串的替换　129
3.9.6　字符串的截取　130
3.9.7　字符串的拆分　130
3.9.8　其他方法　133
3.10　this关键字　136
3.10.1　调用本类属性　136
3.10.2　调用本类方法　138
3.10.3　表示当前对象　143
3.11　引用传递　144
3.11.1　引用传递基本概念　144
3.11.2　引用传递实际应用　148
3.12　数据表与简单Java类映射　153
3.13　对象比较　156
3.14　static关键字　160
3.14.1　static定义属性　160
3.14.2　static定义方法　162
3.14.3　主方法　164
3.14.4　static的实际应用　165
3.15　代码块　167
3.15.1　普通代码块　167
3.15.2　构造块　168
3.15.3　静态块　168
3.16　内部类　170
3.16.1　基本概念　170
3.16.2　使用static定义内部类　174
3.16.3　在方法中定义内部类　175
3.17　链表　177
3.17.1　链表的基本形式　178
3.17.2　链表的基本雏形　181
3.17.3　开发可用链表　184
3.17.4　使用链表　194
本章小结　200
课后习题　201
第4章　面向对象高级知识　204
（视频373分钟，例题96个，提示23个，注意9个，问答9个，技术穿越6个，面试题4个）
4.1　继承性　204
4.1.1　继承问题的引出　204
4.1.2　继承的实现　205
4.1.3　继承的限制　207
4.2　覆写　211
4.2.1　方法的覆写　211
4.2.2　属性的覆盖　217
4.3　继承案例　218
4.3.1　开发数组的父类　219
4.3.2　开发排序类　221
4.3.3　开发反转类　222
4.4　final关键字　223
4.5　多态性　224
4.6　抽象类　230
4.6.1　抽象类定义　230
4.6.2　抽象类的相关限制　232
4.6.3　抽象类应用——模板设计模式　236
4.7　接口　240
4.7.1　接口的基本定义　240
4.7.2　接口的实际应用——标准　245
4.7.3　接口的应用——工厂设计模式（Factory）　247
4.7.4　接口的应用——代理设计模式（Proxy）　250
4.7.5　抽象类与接口的区别　252
4.8　Object类　254
4.8.1　Object类的基本定义　254
4.8.2　取得对象信息：toString()　255
4.8.3　对象比较：equals()　256
4.8.4　Object类与引用数据类型　257
4.8.5　修改链表　259
4.9　综合练习：宠物商店　264
4.10　匿名内部类　269
4.11　基本数据类型的包装类　270
4.11.1　装箱与拆箱操作　271
4.11.2　数据类型转换　274
本章小结　277
课后习题　278
第5章　包及访问控制权限　282
（视频89分钟，例题22个，提示8个，注意2个，问答2个，技术穿越1个，面试题1个）
5.1　包的定义　282
5.2　包的导入　283
5.3　系统常见包　287
5.4　jar命令　288
5.5　访问控制权限　289
5.6　命名规范　291
5.7　单例设计模式（Singleton）　291
5.8　多例设计模式　295
本章小结　297
课后习题　297
第6章　异常的捕获及处理　298
（视频83分钟，例题18个，提示5个，注意1个，问答4个，技术穿越2个，面试题2个）
6.1　认识异常　299
6.2　处理异常　300
6.3　异常的处理流程　304
6.4　throws关键字　308
6.5　throw关键字　309
6.6　异常处理的标准格式　310
6.7　RuntimeException类　312
6.8　assert关键字　313
6.9　自定义异常　314
本章小结　315
课后习题　315
第7章　Eclipse开发工具　317
（视频75分钟，例题5个，提示6个，注意1个）
7.1　Eclipse简介　317
7.2　JDT的使用　319
7.3　JUnit的使用　329
本章小结　331
第8章　Java新特性　332
（视频175分钟，例题56个，提示13个，注意1个，问答2个，技术穿越5个，面试题1个）
8.1　可变参数　333
8.2　foreach循环　335
8.3　静态导入　335
8.4　泛型　337
8.4.1　泛型的引出　337
8.4.2　通配符　342
8.4.3　泛型接口　346
8.4.4　泛型方法　347
8.5　枚举　348
8.5.1　认识枚举　348
8.5.2　定义其他结构　351
8.5.3　枚举的实际作用　354
8.6　Annotation　356
8.6.1　准确的覆写：@Override　357
8.6.2　声明过期操作：@Deprecated　358
8.6.3　压制警告：@Suppress Warnings　359
8.7　接口定义加强　359
8.8　Lambda表达式　361
8.9　方法引用　365
8.10　内建函数式接口　368
本章小结　370
课后习题　371
第三部分　Java高级编程
第9章　多线程　373
（视频167分钟，例题24个，提示10个，注意2个，问答2个，技术穿越1个，面试题6个）
9.1　线程与进程　373
9.2　多线程实现　374
9.2.1　继承Thread类　374
9.2.2　实现Runnable接口　377
9.2.3　多线程两种实现方式的区别　378
9.2.4　利用Callable接口实现多线程　382
9.2.5　线程的操作状态　384
9.3　多线程常用操作方法　385
9.3.1　线程的命名与取得　385
9.3.2　线程的休眠　387
9.3.3　线程优先级　388
9.4　线程的同步与死锁　390
9.4.1　同步问题的引出　390
9.4.2　同步操作　392
9.4.3　死锁　395
9.5　线程间的经典操作案例——生产者与消费者案例　397
9.5.1　问题的引出　397
9.5.2　解决数据错乱问题　399
9.5.3　解决数据重复问题　401
9.6　线程的生命周期　403
本章小结　405
课后习题　405
第10章　Java常用类库　407
（视频364分钟，例题60个，提示25个，注意6个，问答8个，技术穿越2个，面试题4个）
10.1　StringBuffer类　407
10.2　Runtime类　412
10.3　System类　416
10.4　对象克隆　419
10.5　数字操作类　420
10.5.1　Math类　420
10.5.2　Random类　421
10.5.3　大数字操作类　423
10.6　日期处理类　425
10.6.1　Date类　426
10.6.2　日期格式化：SimpleDateFormat　427
10.6.3　Calendar类　429
10.7　比较器　430
10.7.1　Arrays类　430
10.7.2　比较器：Comparable　432
10.7.3　数据结构——BinaryTree　434
10.7.4　挽救的比较器：Comparator　437
10.8　正则表达式　440
10.8.1　问题引出　440
10.8.2　正则标记　442
10.8.3　String类对正则的支持　443
10.8.4　java.util.regex包支持　447
10.9　反射机制　449
10.9.1　认识反射　449
10.9.2　Class类对象实例化　450
10.9.3　反射实例化对象　451
10.9.4　使用反射调用构造　454
10.9.5　反射调用方法　457
10.9.6　反射调用成员　459
10.10　国际化　461
10.10.1　使用Locale类定义语言环境　462
10.10.2　利用ResourceBundle读取资源文件　463
10.10.3　多资源读取　465
本章小结　466
课后习题　467
第11章　Java IO编程　469
（视频307分钟，例题42个，提示27个，注意2个，问答4个，技术穿越4个）
11.1　文件操作类：File　469
11.2　字节流与字符流　474
11.2.1　字节输出流：OutputStream　475
11.2.2　字节输入流：InputStream　479
11.2.3　字符输出流：Writer　484
11.2.4　字符输入流：Reader　486
11.2.5　字节流与字符流的区别　488
11.3　转换流　489
11.4　案例：文件复制　491
11.5　字符编码　493
11.6　内存流　495
11.7　打印流　498
11.7.1　打印流设计思想　499
11.7.2　打印流　501
11.7.3　PrintStream类的改进　502
11.8　System类对IO的支持　503
11.8.1　错误输出：System.err　504
11.8.2　信息输出：System.out　505
11.8.3　系统输入：System.in　506
11.9　字符缓冲流：BufferedReader　508
11.10　扫描流：Scanner　511
11.11　对象序列化　514
11.11.1　序列化接口：Serializable　515
11.11.2　实现序列化与反序列化　515
11.11.3　transient关键字　517
本章小结　518
课后习题　519
第12章　Java网络编程　521
（视频43分钟，例题5个，提示1个，技术穿越1个）
12.1　网络编程　521
12.2　开发第一个网络程序　522
12.3　网络开发的经典模型——Echo程序　524
本章小结　527
课后习题　528
第13章　Java类集框架　529
（视频204分钟，例题34个，提示15个，注意3个，问答3个，技术穿越2个，面试题5个）
13.1　类集框架简介　529
13.2　单对象保存父接口：Collection　530
13.3　List子接口　531
13.3.1　新的子类：ArrayList　532
13.3.2　旧的子类：Vector　535
13.4　Set子接口　536
13.4.1　关于数据排序的说明　537
13.4.2　关于重复元素的说明　539
13.5　集合输出　541
13.5.1　迭代输出：Iterator　541
13.5.2　双向迭代：ListIterator　544
13.5.3　foreach输出　545
13.5.4　Enumeration输出　546
13.6　偶对象保存：Map接口　547
13.6.1　利用Iterator输出Map集合　550
13.6.2　自定义Map集合的key类型　551
13.7　Stack子类　553
13.8　Properties子类　554
13.9　Collections工具类　556
13.10　数据流　557
13.10.1　数据流基础操作　557
13.10.2　MapReduce　564
本章小结　567
课后习题　568
第14章　Java数据库编程　569
（视频121分钟，例题15个，提示3个，注意3个）
14.1　JDBC简介　569
14.2　连接Oracle数据库　570
14.3　Statement接口　572
14.3.1　数据更新操作　573
14.3.2　数据查询　576
14.4　PreparedStatement接口　578
14.4.1　Statement接口问题　578
14.4.2　PreparedStatement操作　579
14.5　批处理与事务处理　585
本章小结　587
课后习题　587
第四部分　设计开发
第15章　DAO设计模式　590
（视频163分钟，例题11个，提示10个，技术穿越1个）
15.1　程序设计分层　590
15.2　实例分析　592
15.3　项目准备　593
15.3.1　数据库连接类　594
15.3.2　开发Value Object　596
15.4　开发数据层　598
15.4.1　开发数据层操作标准　598
15.4.2　数据层实现类　601
15.4.3　定义数据层工厂类——DAOFactory　605
15.5　开发业务层　606
15.5.1　开发业务层标准——IEmpService　606
15.5.2　业务层实现类　609
15.5.3　定义业务层工厂类——ServiceFactory　612
15.6　代码测试　613
15.6.1　调用测试　613
15.6.2　利用JUnit进行测试　614
本章小结　617
附录　综合测试　618
测试试卷一　618
测试试卷二　623
测试试卷三　631
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>第一行代码 Java 视频讲解版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻量级Java EE企业应用实战（第4版）
第1章　Java EE应用和开发环境	1
1.1　Java EE应用概述	2
1.1.1　Java EE应用的分层模型	2
1.1.2　Java EE应用的组件	3
1.1.3　Java EE应用的结构和优势	4
1.1.4　常用的Java EE服务器	4
1.2  轻量级Java EE应用相关技术	5
1.2.1  JSP、Servlet 3.x和JavaBean及替代技术	5
1.2.2  Struts 2.3及替代技术	5
1.2.3  Hibernate 4.3及替代技术	6
1.2.4  Spring 4.0及替代技术	6
1.3  Tomcat的下载和安装	7
1.3.1  安装Tomcat服务器	7
1.3.2  配置Tomcat的服务端口	9
1.3.3  进入控制台	9
1.3.4  部署Web应用	12
1.3.5  配置Tomcat的数据源	12
1.4  Eclipse的安装和使用	14
1.4.1  Eclipse的下载和安装	14
1.4.2  在线安装Eclipse插件	14
1.4.3  从本地压缩包安装插件	16
1.4.4  手动安装Eclipse插件	17
1.4.5  使用Eclipse开发Java EE应用	17
1.4.6  导入Eclipse项目	20
1.4.7  导入非Eclipse项目	21
1.5  Ant的安装和使用	22
1.5.1  Ant的下载和安装	22
1.5.2  使用Ant工具	23
1.5.3  定义生成文件	24
1.5.4  Ant的任务（task）	29
1.6  Maven的安装和使用	31
1.6.1  下载和安装Maven	31
1.6.2  设置Maven	32
1.6.3  创建、构建简单的项目	33
1.6.4  Maven的核心概念	36
1.6.5  依赖管理	41
1.6.6  POM文件的元素	44
1.7  使用SVN进行协作开发	44
1.7.1  下载和安装SVN服务器	45
1.7.2  配置SVN资源库	46
1.7.3  下载和安装SVN客户端	47
1.7.4  将项目发布到服务器	48
1.7.5  从服务器下载项目	48
1.7.6  提交（Commit）修改	49
1.7.7  同步（Update）本地文件	49
1.7.8  添加文件和目录	50
1.7.9  删除文件和目录	50
1.7.10 查看文件或目录的版本变革	51
1.7.11 从以前版本重新开始	51
1.7.12 创建分支	52
1.7.13 沿着分支开发	52
1.7.14 合并分支	53
1.7.15 使用Eclipse作为SVN客户端	54
1.8  本章小结	57
第2章　JSP/Servlet及相关技术详解	58
2.1  Web应用和web.xml文件	59
2.1.1  构建Web应用	59
2.1.2  配置描述符web.xml	60
2.2  JSP的基本原理	61
2.3  JSP的4种基本语法	65
2.3.1  JSP注释	65
2.3.2  JSP声明	66
2.3.3  输出JSP表达式	67
2.3.4  JSP脚本	68
2.4  JSP的3个编译指令	70
2.4.1  page指令	70
2.4.2  include指令	74
2.5  JSP的7个动作指令	75
2.5.1  forward指令	75
2.5.2  include指令	77
2.5.3  useBean、setProperty、getProperty指令	79
2.5.4  plugin指令	81
2.5.5  param指令	81
2.6  JSP脚本中的9个内置对象	82
2.6.1  application对象	83
2.6.2  config对象	88
2.6.3  exception对象	90
2.6.4  out对象	92
2.6.5  pageContext对象	93
2.6.6  request对象	95
2.6.7  response对象	102
2.6.8  session对象	106
2.7  Servlet介绍	108
2.7.1  Servlet的开发	108
2.7.2  Servlet的配置	110
2.7.3  JSP/Servlet的生命周期	111
2.7.4  load-on-startup Servlet	112
2.7.5  访问Servlet的配置参数	113
2.7.6  使用Servlet作为控制器	115
2.8  JSP 2的自定义标签	119
2.8.1  开发自定义标签类	120
2.8.2  建立TLD文件	120
2.8.3  使用标签库	121
2.8.4  带属性的标签	122
2.8.5  带标签体的标签	125
2.8.6  以页面片段作为属性的标签	128
2.8.7  动态属性的标签	129
2.9  Filter介绍	131
2.9.1  创建Filter类	132
2.9.2  配置Filter	133
2.9.3  使用URL Rewrite实现网站伪静态	136
2.10  Listener介绍	137
2.10.1 实现Listener类	138
2.10.2 配置Listener	139
2.10.3 使用ServletContextAttributeListener	140
2.10.4 使用ServletRequestListener和ServletRequestAttributeListener	141
2.10.5 使用HttpSessionListener和HttpSessionAttributeListener	142
2.11  JSP 2特性	147
2.11.1 配置JSP属性	147
2.11.2 表达式语言	149
2.11.3  Tag File支持	157
2.12  Servlet 3.0新特性	159
2.12.1  Servlet 3.0的注解	159
2.12.2  Servlet 3.0的Web模块支持	160
2.12.3  Servlet 3.0提供的异步处理	162
2.12.4改进的Servlet API	165
2.13  Servlet 3.1新增的非阻塞式IO	167
2.14  Tomcat 8的WebSocket支持	170
2.15 本章小结	174
第3章　Struts 2的基本用法	175
3.1  MVC思想概述	176
3.1.1  传统Model 1和Model 2	176
3.1.2  MVC思想及其优势	177
3.2  Struts 2的下载和安装	178
3.2.1  为Web应用增加Struts 2支持	178
3.2.2  在Eclipse中使用Struts 2	179
3.2.3  增加登录处理	180
3.3  Struts 2的流程	183
3.3.1  Struts 2应用的开发步骤	183
3.3.2  Struts 2的流程	184
3.4  Struts 2的常规配置	185
3.4.1  常量配置	185
3.4.2  包含其他配置文件	191
3.5  实现Action	191
3.5.1  Action接口和ActionSupport基类	193
3.5.2  Action访问Servlet API	195
3.5.3  Action直接访问Servlet API	197
3.5.4  使用ServletActionContext访问Servlet API	199
3.6  配置Action	200
3.6.1  包和命名空间	200
3.6.2  Action的基本配置	203
3.6.3  使用Action的动态方法调用	204
3.6.4  指定method属性及使用通配符	205
3.6.5  配置默认Action	211
3.6.6  配置Action的默认处理类	211
3.7  配置处理结果	212
3.7.1  理解处理结果	212
3.7.2  配置结果	213
3.7.3  Struts 2支持的结果类型	214
3.7.4  plainText结果类型	215
3.7.5  redirect结果类型	217
3.7.6  redirectAction结果类型	218
3.7.7  动态结果	219
3.7.8  Action属性值决定物理视图资源	219
3.7.9  全局结果	221
3.7.10  使用PreResultListener	222
3.8  配置Struts 2的异常处理	223
3.8.1  Struts 2的异常处理机制	223
3.8.2  声明式异常捕捉	225
3.8.3  输出异常信息	226
3.9  Convention插件与“约定”支持	227
3.9.1  Action的搜索和映射约定	228
3.9.2  按约定映射Result	230
3.9.3  Action链的约定	233
3.9.4  自动重加载映射	234
3.9.5  Convention插件的相关常量	234
3.9.6  Convention插件相关Annotation	235
3.10  使用Struts 2的国际化	235
3.10.1  视图页面的国际化	235
3.10.2  Action的国际化	236
3.10.3  使用包范围的国际化资源	238
3.10.4  使用全局国际化资源	239
3.10.5  输出带占位符的国际化消息	241
3.10.6  加载资源文件的顺序	243
3.11  使用Struts 2的标签库	243
3.11.1  Struts 2标签库概述	243
3.11.2  使用Struts 2标签	244
3.11.3  Struts 2的OGNL表达式语言	245
3.11.4  OGNL中的集合操作	247
3.11.5  访问静态成员	248
3.11.6  Lambda（）表达式	248
3.11.7  控制标签	249
3.11.8  数据标签	259
3.11.9  主题和模板	268
3.11.10  自定义主题	270
3.11.11  表单标签	271
3.11.12  非表单标签	284
3.12  本章小结	287
第4章　深入使用Struts 2	288
4.1  详解Struts 2的类型转换	289
4.1.1  Struts 2内建的类型转换器	290
4.1.2  基于OGNL的类型转换	290
4.1.3  指定集合元素的类型	292
4.1.4  自定义类型转换器	294
4.1.5  注册类型转换器	297
4.1.6  基于Struts 2的自定义类型转换器	298
4.1.7  处理Set集合	299
4.1.8  类型转换中的错误处理	301
4.2  使用Struts 2的输入校验	307
4.2.1  编写校验规则文件	307
4.2.2  国际化提示信息	310
4.2.3  使用客户端校验	311
4.2.4  字段校验器配置风格	312
4.2.5  非字段校验器配置风格	313
4.2.6  短路校验器	315
4.2.7  校验文件的搜索规则	316
4.2.8  校验顺序和短路	318
4.2.9  内建校验器	318
4.2.10  基于注解的输入校验	329
4.2.11  手动完成输入校验	330
4.3  使用Struts 2控制文件上传	334
4.3.1  Struts 2的文件上传	334
4.3.2  实现文件上传的Action	335
4.3.3  配置文件上传的Action	337
4.3.4  手动实现文件过滤	338
4.3.5  拦截器实现文件过滤	340
4.3.6  输出错误提示	341
4.3.7  文件上传的常量配置	342
4.4  使用Struts 2控制文件下载	343
4.4.1  实现文件下载的Action	343
4.4.2  配置Action	343
4.4.3  下载前的授权控制	344
4.5  详解Struts 2的拦截器机制	345
4.5.1  拦截器在Struts 2中的作用	346
4.5.2  Struts 2内建的拦截器	346
4.5.3  配置拦截器	348
4.5.4  使用拦截器的配置语法	349
4.5.5  配置默认拦截器	350
4.5.6  实现拦截器类	351
4.5.7  使用拦截器	353
4.5.8  拦截方法的拦截器	354
4.5.9  拦截器的执行顺序	356
4.5.10 拦截结果的监听器	358
4.5.11 覆盖拦截器栈里特定拦截器的参数	359
4.5.12 使用拦截器完成权限控制	360
4.6  使用Struts 2的Ajax支持	362
4.6.1  使用stream类型的Result实现Ajax	363
4.6.2  JSON的基本知识	365
4.6.3  实现Action逻辑	367
4.6.4  JSON插件与json类型的Result	368
4.6.5  实现JSP页面	370
4.7  本章小结	371
第5章　Hibernate的基本用法	372
5.1  ORM和Hibernate	373
5.1.1  对象/关系数据库映射（ORM）	373
5.1.2  基本映射方式	374
5.1.3  流行的ORM框架简介	375
5.1.4  Hibernate概述	376
5.2  Hibernate入门	376
5.2.1  Hibernate下载和安装	376
5.2.2  Hibernate的数据库操作	377
5.2.3  在Eclipse中使用Hibernate	381
5.3  Hibernate的体系结构	386
5.4  深入Hibernate配置文件	388
5.4.1  创建Configuration对象	388
5.4.2  hibernate.properties文件与hibernate.cfg.xml文件	390
5.4.3  JDBC连接属性	390
5.4.4  数据库方言	391
5.4.5  JNDI数据源的连接属性	393
5.4.6  Hibernate事务属性	393
5.4.7  二级缓存相关属性	393
5.4.8  外连接抓取属性	394
5.4.9  其他常用的配置属性	394
5.5  深入理解持久化对象	394
5.5.1  持久化类的要求	395
5.5.2  持久化对象的状态	396
5.5.3  改变持久化对象状态的方法	397
5.6  深入Hibernate映射	399
5.6.1  映射属性	402
5.6.2  映射主键	409
5.6.3  使用Hibernate的主键生成策略	411
5.6.4  映射集合属性	412
5.6.5  集合属性的性能分析	419
5.6.6  有序集合映射	420
5.6.7  映射数据库对象	422
5.7　映射组件属性	424
5.7.1　组件属性为集合	426
5.7.2　集合属性的元素为组件	427
5.7.3  组件作为Map的索引	429
5.7.4  组件作为复合主键	430
5.7.5  多列作为联合主键	432
5.8  使用传统的映射文件	433
5.8.1  增加XML映射文件	433
5.8.2  注解，还是XML映射文件	436
5.9  本章小结	436
第6章　深入使用Hibernate	437
6.1  Hibernate的关联映射	438
6.1.1  单向N－1关联	438
6.1.2  单向1－1关联	443
6.1.3  单向1－N关联	444
6.1.4  单向N－N关联	448
6.1.5  双向1－N关联	449
6.1.6  双向N－N关联	452
6.1.7  双向1－1关联	454
6.1.8  组件属性包含的关联实体	456
6.1.9  基于复合主键的关联关系	458
6.1.10 复合主键的成员属性为关联实体	460
6.1.11 持久化的传播性	463
6.2  继承映射	464
6.2.1  整个类层次对应一个表的映射策略	466
6.2.2  连接子类的映射策略	468
6.2.3  每个具体类对应一个表的映射策略	471
6.3  Hibernate的批量处理	473
6.3.1  批量插入	473
6.3.2  批量更新	474
6.3.3  DML风格的批量更新/删除	475
6.4  使用HQL查询	476
6.4.1  HQL查询	476
6.4.2  HQL查询的from子句	478
6.4.3  关联和连接	479
6.4.4  HQL查询的select子句	482
6.4.5  HQL查询的聚集函数	482
6.4.6  多态查询	483
6.4.7  HQL查询的where子句	483
6.4.8  表达式	484
6.4.9  order by子句	486
6.4.10  group by子句	486
6.4.11  子查询	487
6.4.12  命名查询	487
6.5  条件查询	489
6.5.1  关联和动态关联	491
6.5.2  投影、聚合和分组	493
6.5.3  离线查询和子查询	496
6.6  SQL查询	497
6.6.1  标量查询	497
6.6.2  实体查询	499
6.6.3  处理关联和继承	501
6.6.4  命名SQL查询	502
6.6.5  调用存储过程	504
6.6.6  使用定制SQL	505
6.7  数据过滤	507
6.8  事务控制	510
6.8.1  事务的概念	510
6.8.2  Session与事务	511
6.8.3  上下文相关的Session	513
6.9  二级缓存和查询缓存	514
6.9.1  开启二级缓存	514
6.9.2  管理缓存和统计缓存	517
6.9.3  使用查询缓存	518
6.10  事件机制	520
6.10.1  拦截器	521
6.10.2  事件系统	523
6.11  本章小结	525
第7章　Spring的基本用法	526
7.1  Spring简介和Spring 4.0的变化	527
7.1.1  Spring简介	527
7.1.2  Spring 4.0的变化	528
7.2  Spring入门	528
7.2.1  Spring下载和安装	528
7.2.2  使用Spring管理Bean	529
7.2.3  在Eclipse中使用Spring	532
7.3  Spring的核心机制：依赖注入	535
7.3.1  理解依赖注入	536
7.3.2  设值注入	538
7.3.3  构造注入	541
7.3.4  两种注入方式的对比	543
7.4  使用Spring容器	543
7.4.1  Spring容器	544
7.4.2  使用ApplicationContext	545
7.4.3  ApplicationContext的国际化支持	546
7.4.4  ApplicationContext的事件机制	548
7.4.5  让Bean获取Spring容器	551
7.5  Spring容器中的Bean	552
7.5.1  Bean的基本定义和Bean别名	553
7.5.2  容器中Bean的作用域	554
7.5.3  配置依赖	557
7.5.4  设置普通属性值	559
7.5.5  配置合作者Bean	560
7.5.6  使用自动装配注入合作者Bean	561
7.5.7  注入嵌套Bean	563
7.5.8  注入集合值	564
7.5.9  组合属性	568
7.5.10  Spring的Bean和JavaBean	569
7.6  Spring 3.0提供的Java配置管理	571
7.7  创建Bean的3种方式	573
7.7.1  使用构造器创建Bean实例	574
7.7.2  使用静态工厂方法创建Bean	574
7.7.3  调用实例工厂方法创建Bean	576
7.8  深入理解容器中的Bean	578
7.8.1  抽象Bean与子Bean	578
7.8.2  Bean继承与Java继承的区别	580
7.8.3  容器中的工厂Bean	580
7.8.4  获得Bean本身的id	582
7.8.5  强制初始化Bean	583
7.9  容器中Bean的生命周期	584
7.9.1  依赖关系注入之后的行为	584
7.9.2  Bean销毁之前的行为	586
7.9.3  协调作用域不同步的Bean	589
7.10  高级依赖关系配置	592
7.10.1 获取其他Bean的属性值	592
7.10.2 获取Field值	595
7.10.3 获取方法返回值	596
7.11  基于XML Schema的简化配置方式	599
7.11.1 使用p:命名空间简化配置	599
7.11.2 使用c:命名空间简化配置	601
7.11.3 使用util:命名空间简化配置	602
7.12  Spring 3.0提供的表达式语言（SpEL）	604
7.12.1 使用Expression接口进行表达式求值	604
7.12.2  Bean定义中的表达式语言支持	606
7.12.3  SpEL语法详述	607
7.13  本章小结	612
第8章　深入使用Spring	613
8.1  两种后处理器	614
8.1.1  Bean后处理器	614
8.1.2  Bean后处理器的用处	617
8.1.3  容器后处理器	618
8.1.4  属性占位符配置器	619
8.1.5  重写占位符配置器	620
8.2  Spring的“零配置”支持	622
8.2.1  搜索Bean类	622
8.2.2  指定Bean的作用域	625
8.2.3  使用@Resource配置依赖	625
8.2.4  使用@PostConstruct和@PreDestroy定制生命周期行为	626
8.2.5  Spring 3.0新增的注解	627
8.2.6  Spring 4.0增强的自动装配和精确装配	627
8.3  资源访问	631
8.3.1  Resource实现类	632
8.3.2  ResourceLoader接口和ResourceLoaderAware接口	636
8.3.3  使用Resource作为属性	639
8.3.4  在ApplicationContext中使用资源	640
8.4  Spring的AOP	643
8.4.1  为什么需要AOP	643
8.4.2  使用AspectJ实现AOP	644
8.4.3  AOP的基本概念	651
8.4.4  Spring的AOP支持	652
8.4.5  基于注解的“零配置”方式	653
8.4.6  基于XML配置文件的管理方式	667
8.5  Spring 3.1新增的缓存机制	673
8.5.1  启用Spring缓存	674
8.5.2  使用@Cacheable执行缓存	676
8.5.3  使用@CacheEvict清除缓存	680
8.6  Spring的事务	681
8.6.1  Spring支持的事务策略	681
8.6.2  使用XML Schema配置事务策略	686
8.6.3  使用@Transactional	692
8.7  Spring整合Struts 2	693
8.7.1  启动Spring容器	693
8.7.2  MVC框架与Spring整合的思考	694
8.7.3  让Spring管理控制器	695
8.7.4  使用自动装配	699
8.8  Spring整合Hibernate	701
8.8.1  Spring提供的DAO支持	701
8.8.2  管理Hibernate的SessionFactory	702
8.8.3  实现DAO组件的基类	703
8.8.4  传统的HibernateTemplate和HibernateDaoSupport	706
8.8.5  实现DAO组件	709
8.8.6  使用IoC容器组装各种组件	709
8.8.7  使用声明式事务	712
8.9  Spring整合JPA	713
8.9.1  管理EntityManagerFactory	713
8.9.2  实现DAO组件基类	715
8.9.3  使用声明式事务	718
8.10  本章小结	719
第9章　企业应用开发的思考和策略	720
9.1  企业应用开发面临的挑战	721
9.1.1  可扩展性、可伸缩性	721
9.1.2  快捷、可控的开发	722
9.1.3  稳定性、高效性	722
9.1.4  花费最小化，利益最大化	723
9.2  如何面对挑战	723
9.2.1  使用建模工具	723
9.2.2  利用优秀的框架	723
9.2.3  选择性地扩展	725
9.2.4  使用代码生成器	726
9.3  常见设计模式精讲	726
9.3.1  单例模式	727
9.3.2  简单工厂	728
9.3.3  工厂方法和抽象工厂	734
9.3.4  代理模式	737
9.3.5  命令模式	742
9.3.6  策略模式	745
9.3.7  门面模式	748
9.3.8  桥接模式	750
9.3.9  观察者模式	754
9.4  常见的架构设计策略	757
9.4.1  贫血模型	757
9.4.2  领域对象模型	760
9.4.3  合并业务逻辑对象与DAO对象	762
9.4.4  合并业务逻辑对象和Domain Object	763
9.4.5  抛弃业务逻辑层	764
9.5  本章小结	765
第10章　简单工作流系统	766
10.1  项目背景及系统结构	767
10.1.1  应用背景	767
10.1.2  系统功能介绍	767
10.1.3  相关技术介绍	768
10.1.4  系统结构	768
10.1.5  系统的功能模块	769
10.2  Hibernate持久层	770
10.2.1  设计持久化实体	770
10.2.2  创建持久化实体类	771
10.3  实现DAO层	777
10.3.1  DAO组件的定义	778
10.3.2  实现DAO组件	780
10.3.3  部署DAO层	783
10.4  实现Service层	784
10.4.1  业务逻辑组件的设计	785
10.4.2  实现业务逻辑组件	785
10.4.3  事务管理	790
10.4.4  部署业务逻辑组件	791
10.5  实现任务的自动调度	791
10.5.1  使用Quartz	791
10.5.2  在Spring中使用Quartz	795
10.6  实现系统Web层	798
10.6.1  Struts 2和Spring的整合	798
10.6.2  控制器的处理顺序图	799
10.6.3  员工登录	799
10.6.4  进入打卡	802
10.6.5  处理打卡	803
10.6.6  进入申请	805
10.6.7  提交申请	806
10.6.8  使用拦截器完成权限管理	808
10.7  本章小结	809
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻量级Java EE企业应用实战（第4版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java JDK 5.0学习笔记
目录
第1章 了解Java	1
1.1　什么是Java	2
1.2　Java的特性	4
1.2.1　语言特性	4
1.2.2　应用平台	7
1.2.3　活跃的论坛与丰富
的资源	9
1.3　如何学习Java	9
1.4　接下来的主题	10
1.5　网络资源	11
第2章 入门准备	13
2.1　下载、安装和了解JDK	14
2.1.1　下载JDK	14
2.1.2　安装JDK	16
2.1.3　了解JDK	17
2.2　设置Path与Classpath	19
2.2.1　设置Path	19
2.2.2　设置Classpath	21
2.3　第一个Java程序	22
2.3.1　编写和编译Java程序	22
2.3.2　执行Java程序	24
2.4　选择开发工具	25
2.5　接下来的主题	27
2.6　网络资源	27
第3章 语法入门	29
3.1　第一个Java程序	30
3.1.1　解释第一个Java程序	30
3.1.2　给C使用者的第一个
Java 程序	32
3.1.3　为程序加入注释	34
3.2　在命令行模式下与程序互动	35
3.2.1　使用Scanner取得输入	35
3.2.2　使用BufferedReader
取得输入	37
3.2.3　标准输入/输出串	39
3.2.4　输出格式控制	40
3.3　数据和运算	43
3.3.1　数据类型	43
3.3.2　变量和常量	45
3.3.3　算术运算	47
3.3.4　比较和条件运算	49
3.3.5　逻辑和位运算	52
3.3.6　递增和递减运算	57
3.4　流程控制	60
3.4.1　if条件式	60
3.4.2　switch条件式	64
3.4.3　for循环	66
3.4.4　while循环	68
3.4.5　break和continue	71
3.5　接下来的主题	72
3.6　网络资源	73
第4章 从autoboxing和unboxing
认识对象	75
4.1　关于对象	76
4.1.1　使用对象	76
4.1.2　打包(Wrap)基本数据类型	79
4.2　自动装箱和拆箱	81
4.2.1　autoboxing和unboxing	81
4.2.2　小心使用boxing	83
4.3　接下来的主题	85
4.4　网络资源	85
第5章 数组	87
5.1　一维数组和二维数组	88
5.1.1　一维数组对象	88
5.1.2　二维数组对象	92
5.2　高级数组概念	95
5.2.1　高级的数组操作	96
5.2.2　Arrays类	99
5.2.3　foreach与数组	102
5.3　接下来的主题	103
5.4　网络资源	104
第6章 字符串	105
6.1　认识字符串	106
6.1.1　String类	106
6.1.2　不可变(Immutable)字符串	110
6.1.3　StringBuilder类	114
6.2　字符串高级运用	116
6.2.1　命令行变量	116
6.2.2　分离字符串	118
6.2.3　使用正则表示式
(Regular Expression)	119
6.2.4　Pattern和Matcher	123
6.3　接下来的主题	125
6.4　网络资源	125
第7章 封装	127
7.1　定义类	128
7.1.1　以对象思考问题	128
7.1.2　使用class定义类	130
7.1.3　类成员(Class Member)	134
7.1.4　构造函数(Constructor)	137
7.1.5　关于this	140
7.1.6　关于static	142
7.2　关于方法	145
7.2.1　重载(Overload)方法	145
7.2.2　不定长度参数	147
7.2.3　递归方法	149
7.2.4　垃圾收集	150
7.3　接下来的主题	153
7.4　网络资源	153
第8章 继承和多态	155
8.1　继承	156
8.1.1　扩展(Extends)父类	156
8.1.2　受保护的(Protected)成员	158
8.1.3　重写(Override)方法	160
8.1.4　Object类	163
8.1.5　toString()、equals()和
hashCode()方法	166
8.1.6　clone()方法	168
8.1.7　final关键词	171
8.2　多态	172
8.2.1　多态导论	172
8.2.2　抽象类(Abstract Class)	174
8.2.3　抽象类应用	176
8.2.4　接口(Interface)	179
8.3　接下来的主题	183
8.4　网络资源	183
第9章 管理类文件	185
9.1　内嵌类	186
9.1.1　成员内嵌类和区域内嵌类	186
9.1.2　匿名内嵌类	188
9.2　package与import	190
9.2.1　设定包(Package)	190
9.2.2　import的意义	192
9.2.3　public与包	195
9.2.4　import静态成员	196
9.3　接下来的主题	198
9.4　网络资源	199
第10章 异常处理	201
10.1 异常处理入门	202
10.2 可控式异常(Checked
Exception)和执行时异常(Runtime Exception)	204
10.3 throw和throws	205
10.4 异常的继承架构	209
10.5 接下来的主题	212
10.6 网络资源	212
第11章 枚举类型	215
11.1 常数设置与枚举类型	216
11.1.1　常数设置	216
11.1.2　枚举类型入门	217
11.2 定义枚举类型	220
11.2.1　深入枚举类型	221
11.2.2　枚举上的方法	223
11.2.3　因值而异的类实现(Value- Specific Class Bodies)	225
11.3 接下来的主题	227
11.4 网络资源	228
第12章 泛型	229
12.1 泛型入门	230
12.1.1　没有泛型之前	230
12.1.2　定义泛型类	232
12.1.3　几个定义泛型的例子	234
12.2 泛型高级语法	236
12.2.1　限制泛型可用类型	237
12.2.2　类型通配字符(Wildcard)	239
12.2.3　扩充泛型类和实现
泛型接口	241
12.3 接下来的主题	243
12.4 网络资源	243
第13章 对象容器	245
13.1 Collection类	246
13.1.1　简介List接口	246
13.1.2　ArrayList	248
13.1.3　LinkedList	251
13.1.4　HashSet	256
13.1.5　TreeSet	258
13.1.6　EnumSet	260
13.2 Map类	263
13.2.1　HashMap	263
13.2.2　TreeMap	266
13.3 接下来的主题	269
13.4 网络资源	269
第14章 输入/输出	271
14.1 文件	272
14.1.1　File类	272
14.1.2　RandomAccessFile类	274
14.2 位流	278
14.2.1　InputStream和
OutputStream	278
14.2.2　FileInputStream和
FileOutputStream	280
14.2.3　BufferedInputStream和
BufferedOutputStream	283
14.2.4　DataInputStream和
DataOutputStream	285
14.2.5　ObjectInputStream和
ObjectOutputStream	288
14.2.6　SequenceInputStream	294
14.2.7　PrintStream	297
14.2.8　ByteArrayInputStream和
ByteArrayOutputStream	299
14.2.9　PushbackInputStream	301
14.3 字符流	303
14.3.1　Reader和Writer	304
14.3.2　InputStreamReader和OutputStreamWriter	305
14.3.3　FileReader和FileWriter	307
14.3.4　BufferedReader和BufferedWriter	308
14.3.5　PrintWriter	310
14.3.6　CharArrayReader和CharArrayWriter	312
14.3.7　PushbackReader	314
14.4 接下来的主题	316
14.5 网络资源	317
第15章 线程	319
15.1 线程入门	320
15.1.1　继承Thread	320
15.1.2　实现 Runnable接口	322
15.1.3　Daemon 线程	325
15.1.4　线程生命周期	326
15.1.5　线程的加入(Join)	329
15.1.6　线程的停止	331
15.1.7　ThreadGroup	333
15.1.8　UncaughtExceptionHandler	335
15.2 同步化(Synchronized)主题	336
15.2.1　同步化	336
15.2.2　wait()和notify()	341
15.2.3　容器类的线程安全(Thread-Safe)	346
15.2.4　ThreadLocal类	347
15.3 接下来的主题	351
15.4 网络资源	352
第16章 反射	353
16.1 类加载与查看	354
16.1.1　简介Class与类加载	354
16.1.2　使用Class.forName()
加载类	357
16.1.3　从Class中获取信息	360
16.1.4　简介类加载器	363
16.1.5　使用自己的ClassLoader	368
16.2 使用反射生成与操作对象	372
16.2.1　生成对象	372
16.2.2　调用方法	375
16.2.3　修改成员值	380
16.2.4　再看数组对象	382
16.2.5　Proxy类	385
16.3 接下来的主题	388
16.4 网络资源	388
第17章 Annotation	389
17.1 Annotation概述	390
17.1.1　限定Override父类方法 @Override	390
17.1.2　标示方法为Deprecated @Deprecated	391
17.1.3　抑制编译器警告 @SuppressWarnings	393
17.1.4　自定义Annotation类型	394
17.2 meta-annotation	397
17.2.1　告知编译器如何处理annotation @Retention	397
17.2.2　限定annotation 使用
对象@Target	400
17.2.3　要求为API文件的
一部分@Documented	401
17.2.4　子类是否继承父类的annotation @Inherited	403
17.3 接下来的主题	404
17.4 网络资源	404
第18章 拾遗补缺	405
18.1 日期和时间	406
18.1.1　使用 Date	406
18.1.2　使用 Calendar	410
18.2 日志(Logging)	414
18.2.1　简介Logging	414
18.2.2　Logging 的等级	416
18.2.3　Handler和Formatter	419
18.2.4　自定义 Formatter	421
18.2.5　Logger层次关系	423
18.3 信息绑定	424
18.3.1　使用ResourceBundle	424
18.3.2　格式化信息	426
18.3.3　国际化信息	428
18.4 接下来的主题	430
第19章 专题制作—— 文字编辑器	431
19.1　产品生命周期	432
19.1.1　分析(Analysis)	432
19.1.2　设计(Design)	435
19.1.3　开发(Development)	435
19.1.4　测试(Testing)	435
19.1.5　完成(Implementation)	435
19.1.6　维护(Maintenance)	436
19.1.7　结束生命周期
(End-of-Life，EOL)	436
19.2　Swing入门	436
19.2.1　Swing简介	436
19.2.2　设计主窗口与菜单栏	438
19.2.3　版面管理	443
19.3　事件处理	447
19.3.1　Java事件模型	448
19.3.2　文字编辑器的事件处理	448
19.4　文字编辑与保存	455
19.4.1　打开文件的流程处理	455
19.4.2　保存文件的流程处理	458
19.4.3　关闭文件的流程处理	459
19.4.4　文字区的编辑、剪切、
复制和粘贴	460
19.5　接下来的主题	461
附录A　Ant简介	463
A.1　Ant设置	464
A.2　第一个Ant构建	465
A.3　任务(Target)	468
A.4　属性(Property)	470
A.5　路径(Path)	471
A.6　常用任务(Task)	472
A.7　一个简单的buildfile	475
附录B　JUnit简介	477
B.1　单元测试(Unit Test)	478
B.2　JUnit设置	480
B.3　第一个JUnit测试	480
B.4　自动构建与测试	483
B.5　自动生成测试报告	484
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java JDK 5.0学习笔记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻松学Java
概  述  篇
第1章  Java入门	2
1.1  Java简介	2
1.1.1  Java语言的发展	2
1.1.2  Java语言的特点	2
1.1.3  Java的应用领域	3
1.2  JDK的下载与安装	3
1.2.1  JDK的下载	3
1.2.2  JDK的安装	5
1.2.3  环境变量的设置	5
1.3  开发工具Eclipse的安装	6
1.3.1  Eclipse下载方法	6
1.3.2  Eclipse的初次启动	7
1.4  第一个Java程序HelloWorld	8
1.4.1  Eclipse工程创建	8
1.4.2  HelloWorld的创建与运行	9
1.5  第一个Java图形界面程序FirstDialog	11
1.6  Java程序运行过程	12
1.7  小结	13
1.8  本章习题	13
面向对象篇
第2章  类和对象	16
2.1  面向对象的基本概念	16
2.2  类	17
2.2.1  类的定义	17
2.2.2  标识符	18
2.2.3  关键字	18
2.2.4  分隔符和注释	19
2.3  类的实例化——对象	19
2.3.1  对象的声明	20
2.3.2  对象的使用	20
2.4  小结	20
2.5  本章习题	21
第3章  成员字段	22
3.1  定义成员字段	22
3.2  Java基本数据类型	23
3.3  数值的表达	26
3.3.1  整型数据	26
3.3.2  浮点型数据	27
3.3.3  字符型数据	27
3.3.4  布尔型数据	29
3.4  赋值	29
3.4.1  直接赋值	30
3.4.2  字段的作用域	30
3.4.3  非直接赋值	30
3.4.4  数据类型转换	32
3.4.5  Java数据的输入与输出	33
3.5  特殊类型字段	36
3.5.1  在类中可直接运用的字段——static关键字	36
3.5.2  禁止被修改的字段	37
3.6  小结	38
3.7  本章习题	38
第4章  方法	40
4.1  什么是方法	40
4.1.1  方法的运用原理	40
4.1.2  定义方法	40
4.1.3  调用方法	41
4.1.4  方法返回	42
4.2  参数	43
4.2.1  参数的声明	43
4.2.2  参数的分类	44
4.3  方法的构成	45
4.3.1  常量与变量	45
4.3.2  语句	47
4.3.3  this关键字	48
4.4  静态方法与非静态方法	49
4.5  特殊的方法	51
4.5.1  构造方法	51
4.5.2  main()方法	52
4.6  小结	53
4.7  本章习题	53
第5章  流程控制	55
5.1  顺序结构	55
5.2  选择结构	56
5.2.1  选择执行条件之一——关系运算	56
5.2.2  选择执行条件之二——逻辑运算	57
5.2.3  选择执行条件之三——条件运算	57
5.2.4  if语句	58
5.2.5  if-else语句	59
5.2.6  if-else if-else语句	60
5.2.7  switch语句	61
5.3  循环结构	63
5.3.1  while循环	64
5.3.2  do-while循环	65
5.3.3  for循环	65
5.3.4  循环嵌套	67
5.4  跳转语句	69
5.4.1  break语句	69
5.4.2  continue语句	69
5.5  小结	70
5.7  本章习题	71
第6章  数组和字符串	72
6.1  一维数组	72
6.1.1  一维数组的声明	73
6.1.2  数组元素的表示方法	73
6.1.3  一维数组的初始化	74
6.1.4  一维数组的赋值	75
6.1.5  数组的使用	76
6.1.6  Java为数组提供的一些常用方法	79
6.2  多维数组	81
6.2.1  二维数组的声明和初始化	82
6.2.2  二维数组的赋值	82
6.2.3  二维数组的使用	83
6.2.4  多维数组	84
6.3  字符串	85
6.3.1  String字符串的声明	85
6.3.2  创建字符串	85
6.3.3  字符串连接	86
6.3.4  字符串的比较	86
6.3.5  字符串方法	89
6.3.6  StringBuffer类的声明和创建	94
6.3.7  StringBuffer类的方法	95
6.4  小结	98
6.5  本章习题	98
第7章  对对象的进一步讨论	100
7.1  使用对象作为成员字段	100
7.1.1  定义对象字段	100
7.1.2  对象字段的实例化	101
7.1.3  对象字段与方法的访问	101
7.2  使用对象作为方法参数进行传递	102
7.3  使用对象作为方法的返回值	103
7.4  嵌套类	103
7.4.1  定义嵌套类	103
7.4.2  嵌套类的使用	104
7.5  内部类	104
7.5.1  静态内部类的定义	105
7.5.2  静态内部类的使用	105
7.5.3  成员内部类的定义	105
7.5.4  成员内部类的使用	106
7.5.5  局部内部类的定义	108
7.5.6  局部内部类的使用	108
7.6  小结	108
7.7  本章习题	109
第8章  继承与多态	111
8.1  继承的概念	111
8.1.1  继承的实现	111
8.1.2  成员方法的继承	112
8.1.3  成员字段的继承	113
8.2  访问修饰符	113
8.2.1  public访问修饰符	114
8.2.2  private访问修饰符	114
8.2.3  protected访问修饰符	115
8.2.4  default访问修饰符	116
8.3  方法的覆盖	116
8.3.1  方法的覆盖格式	116
8.3.2  super关键字	117
8.3.3  几种不能使用方法覆盖的情况	119
8.4  多层继承	121
8.5  多态	122
8.5.1  多态的基本概念	122
8.5.2  方法的覆盖	123
8.5.3  方法的重载	123
8.5.4  对象引用实现多态	124
8.6  小结	126
8.7  本章习题	126
第9章  抽象类、接口和包	128
9.1  抽象类的基本概念	128
9.2  抽象类的使用	129
9.3  接口的基本概念	132
9.4  接口的使用	134
9.5  匿名内部类	135
9.5.1  匿名内部类的语法	136
9.5.2  通过接口使用匿名类	136
9.5.3  通过抽象类使用匿名类	137
9.6  包的概念和使用	138
9.6.1  包的基本概念	139
9.6.2  包的使用	140
9.6.3  JDK中常见的包	142
9.7  小结	143
9.8  本章习题	143
应  用  篇
第10章  Java的异常处理	146
10.1  异常的基本概念	146
10.2  Java异常处理机制	147
10.3  异常类的层次结构	148
10.3.1  运行时异常	148
10.3.2  检查型异常	150
10.4  异常处理	151
10.5  抛出异常	154
10.5.1  程序中抛出异常	155
10.5.2  指定方法抛出异常	155
10.6  try-catch-finally语句的嵌套	156
10.7  用户自定义的异常	158
10.8  小结	159
10.9  本章习题	159
第11章  多线程	162
11.1  线程的基本概念	162
11.1.1  进程和线程	162
11.1.2  进程与线程的区别	163
11.1.3  认识多线程	163
11.2  创建多线程	164
11.2.1  通过继承Thread类创建多线程	164
11.2.2  通过实现Runnable接口创建多线程	165
11.3  运行线程	166
11.3.1  启动线程	166
11.3.2  同时运行多个线程	168
11.4  线程的生命周期	168
11.5  操作线程的方法	170
11.5.1  取得和设置线程的名称	170
11.5.2  判断线程是否启动	172
11.5.3  后台线程与setDaemon()方法	172
11.6  线程的调度	173
11.6.1  线程优先级	173
11.6.2  线程的睡眠方法	174
11.6.3  线程的让步方法	175
11.6.4  线程的等待方法	176
11.6.5  线程的中断	176
11.7  多线程的同步	177
11.8  死锁	179
11.9  线程间通信	181
11.10  小结	181
11.11  本章习题	182
第12章  枚举	184
12.1  枚举简介	184
12.2  枚举的使用	184
12.2.1  常见的枚举定义方法	184
12.2.2  在程序中使用枚举	185
12.2.3  在switch语句中使用枚举	185
12.3  枚举类和枚举关键字	186
12.3.1  枚举类	186
12.3.2  枚举关键字	187
12.4  类集对于枚举的支持	188
12.4.1  EnumMap	188
12.4.2  EnumSet	189
12.5  枚举的构造方法、接口和抽象方法	189
12.5.1  枚举的构造方法	189
12.5.2  枚举的接口	190
12.5.3  枚举的抽象方法	191
12.6  小结	191
12.7  本章习题	192
第13章  集合框架	194
13.1  集合框架概述	194
13.2  Collection接口	195
13.3  列表	196
13.3.1  ArrayList类	197
13.3.2  LinkedList类	198
13.4  集合	200
13.4.1  HashSet类	200
13.4.2  TreeSet类	202
13.5  通过迭代方法访问类集	202
13.6  映射	205
13.6.1  映射接口	205
13.6.2  HashMap类	206
13.6.3  TreeMap类	207
13.7  比较方法	208
13.8  以前版本的类和接口	209
13.8.1  Vector类	210
13.8.2  Stack类	211
13.8.3  Dictionary类	212
13.8.4  Hashtable类	213
13.8.5  Properties类	213
13.9  小结	214
13.10  本章习题	214
第14章  泛型	217
14.1  为什么使用泛型	217
14.2  泛型集合	218
14.3  泛型类和泛型方法	219
14.3.1  泛型类	219
14.3.2  泛型方法	221
14.4  使用多个泛型	221
14.5  泛型通配符	222
14.5.1  无界通配符“？”	222
14.5.2  上限通配符extends	223
14.5.3  下限通配符super	224
14.6  定义泛型异常	225
14.7  小结	226
14.8  本章习题	226
第15章  Java的输入/输出流	228
15.1  输入/输出流概述	228
15.2  文件	229
15.2.1  File类	229
15.2.2  文件的创建、修改与删除	230
15.2.3  获取文件属性	233
15.2.4  RandomAccessFile类	233
15.3  字节输入流	235
15.3.1  字节输入流InputStream	235
15.3.2  字节文件输入流FileInputStream	235
15.3.3  输入流过滤器FilterInputStream	236
15.3.4  字节缓冲区输入流BufferedInputStream	237
15.3.5  数据输入流DataInputStream	238
15.4  字节输出流	239
15.4.1  字节输出流	239
15.4.2  字节文件输出流FileOutputStream	240
15.4.3  字节缓冲区输出流BufferedOutputStream	240
15.4.4  数据输出流DataOutputStream	241
15.4.5  字节打印流PrintStream	242
15.5  字符输入流	243
15.5.1  字符输入流Reader	243
15.5.2  字符文件输入流FileReader	244
15.5.3  字符缓冲区输入流BufferedReader	244
15.6  字符输出流	245
15.6.1  字符输出流Writer	246
15.6.2  字符文件输出流FileWriter	246
15.6.3  字符缓冲区输出流BufferedWriter	247
15.6.4  字符打印流PrintWriter	247
15.7  小结	249
15.8  本章习题	249
开  发  篇
第16章  图形界面编程	254
16.1  AWT简介	254
16.2  Swing简介	255
16.3  容器类	256
16.3.1  JFrame类	256
16.3.2  JDialog类	257
16.3.3  JPanel类	258
16.4  Swing常用基本组件	259
16.4.1  常用组件的共性操作	259
16.4.2  按钮（JButton）	260
16.4.3  文本框（JTextField）与密码输入框（JPasswordField）	260
16.4.4  文本域（JTextArea）	261
16.4.5  标签（JLabel）	262
16.4.6  单选按钮（JRadioButton）	263
16.4.7  复选框（JCheckBox）	263
16.4.8  下拉列表（JComboBox）	264
16.4.9  列表（JList）	265
16.4.10  滚动条（JScrollPane）	266
16.5  Swing高级组件	267
16.5.1  表格（JTable）	267
16.5.2  树（JTree）	268
16.5.3  菜单（JMenu）	269
16.5.4  工具栏（JToolBar）	271
16.5.5  进程条（JprogressBar）	272
16.5.6  对话框（JDialog）	272
16.6  布局管理器	274
16.6.1  BorderLayout管理器	274
16.6.2  FlowLayout管理器	275
16.6.3  CridLayout管理器	277
16.6.4  GridBagLayout管理器	278
16.6.5  CardLayout管理器	279
16.6.6  不使用布局管理器定位组件	281
16.7  Swing的事件处理	282
16.7.1  事件处理机制概述	282
16.7.2  事件监听器	282
16.7.3  焦点事件	283
16.7.4  键盘事件	284
16.7.5  鼠标事件	285
16.7.6  窗口事件	287
16.7.7  事件适配器	288
16.8  小结	289
16.9  本章习题	289
第17章  JDBC数据库编程	293
17.1  数据库简介	293
17.1.1  数据库简介	293
17.1.2  SQL语句简介	296
17.1.3  JDBC简介	296
17.2  JDBC数据库的连接	298
17.3  数据库的操作	302
17.3.1  创建、修改和删除表	302
17.3.2  查询数据	304
17.3.3  条件查询	307
17.3.4  连接查询	310
17.3.5  集合查询	312
17.3.6  增加数据	315
17.3.7  修改数据	315
17.3.8  删除数据	317
17.3.9  视图	318
17.4  处理结果集	320
17.4.1  ResultSet对象处理结果集	320
17.4.2  滚动结果集	321
17.4.3  更新结果集	324
17.5  小结	324
17.6  本章习题	324
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻松学Java
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java基础入门
第1章Java开发入门
1．1Java概述
1．1．1什么是Java
1．1．2Java语言的特点
1．2JDK的使用
1．2．1什么是JDK
1．2．2安装JDK
1．2．3JDK目录介绍
1．3第一个Java程序
1．4系统环境变量
1．4．1path环境变量
1．4．2classpath环境变量
1．5Java的运行机制
1．6本章小结
1．7习题第1章Java开发入门
1．1Java概述
1．1．1什么是Java
1．1．2Java语言的特点
1．2JDK的使用
1．2．1什么是JDK
1．2．2安装JDK
1．2．3JDK目录介绍
1．3第一个Java程序
1．4系统环境变量
1．4．1path环境变量
1．4．2classpath环境变量
1．5Java的运行机制
1．6本章小结
1．7习题
第2章Java编程基础
2．1Java的基本语法
2．1．1Java代码的基本格式
2．1．2Java中的注释
2．1．3Java中的标识符
2．1．4Java中的关键字
2．1．5Java中的常量
2．2Java中的变量
2．2．1变量的定义
2．2．2变量的数据类型
2．2．3变量的类型转换
2．2．4变量的作用域
2．3Java中的运算符
2．3．1算术运算符
2．3．2赋值运算符
2．3．3比较运算符
2．3．4逻辑运算符
2．3．5位运算符
2．3．6运算符的优先级
2．4选择结构语句
2．4．1if条件语句
2．4．2switch条件语句
2．5循环结构语句
2．5．1While循环语句
2．5．2dowhile循环语句
2．5．3for循环语句
2．5．4循环嵌套
2。5．5跳转语句(break、continue)
2．6方法
2．6．1什么是方法
2．6．2方法的重载
2．6．3方法的递归
2．7数组
2．7．1数组的定义
2．7．2数组的常见操作
2．7．3多维数组
2．8本章小结
2．9习题
第3章面向对象(上)
3．1面向对象的概念
3．2类与对象
3．2．1类的定义
3．2．2对象的创建与使用
3．2．3类的设计
3．2．4类的封装
3．3构造方法
3．3．1构造方法的定义
3．3．2构造方法的重载
..
第4章面向对象（下）
第5章多线程
第6章javaAPI
第7章集合类
第8章IO（输入输出）
第9章GUI(国产用户界面)
第10章网络编程
第11章Eclipse开发工具
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java基础入门
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Offer来了：Java面试核心知识点精讲（原理篇）
第1章  JVM	1
1.1  JVM的运行机制 1
1.2  多线程	2
1.3  JVM的内存区域	3
1.3.1  程序计数器：线程私有，无内存溢出问题	4
1.3.2  虚拟机栈：线程私有，描述Java方法的执行过程	4
1.3.3  本地方法区：线程私有	5
1.3.4  堆：也叫作运行时数据区，线程共享	5
1.3.5  方法区：线程共享	5
1.4  JVM的运行时内存	6
1.4.1  新生代：Eden区、ServivorTo区和ServivorFrom区	7
1.4.2  老年代	8
1.4.3  永久代	8
1.5  垃圾回收与算法	9
1.5.1  如何确定垃圾	9
1.5.2  Java中常用的垃圾回收算法	10
1.6  Java中的4种引用类型	13
1.7  分代收集算法和分区收集算法	14
1.7.1  分代收集算法	14
1.7.2  分区收集算法	15
1.8  垃圾收集器	15
1.8.1  Serial垃圾收集器：单线程，复制算法	16
1.8.2  ParNew垃圾收集器：多线程，复制算法	16
1.8.3  Parallel Scavenge垃圾收集器：多线程，复制算法	16
1.8.4  Serial Old垃圾收集器：单线程，标记整理算法	16
1.8.5  Parallel Old垃圾收集器：多线程，标记整理算法	17
1.8.6  CMS垃圾收集器	18
1.8.7  G1垃圾收集器	18
1.9  Java网络编程模型	19
1.9.1  阻塞I/O模型	19
1.9.2  非阻塞I/O模型	19
1.9.3  多路复用I/O模型	20
1.9.4  信号驱动I/O模型	21
1.9.5  异步I/O模型	21
1.9.6  Java I/O	21
1.9.7  Java NIO	22
1.10  JVM的类加载机制	28
1.10.1  JVM的类加载阶段	28
1.10.2  类加载器	29
1.10.3  双亲委派机制	30
1.10.4  OSGI	32
第2章  Java基础	33
2.1  集合	33
2.1.1  List：可重复	34
2.1.2  Queue	34
2.1.3  Set：不可重复	35
2.1.4  Map	36
2.2  异常分类及处理	39
2.2.1  异常的概念	39
2.2.2  异常分类	40
2.2.3  异常处理方式：抛出异常、使用try catch捕获并处理异常	41
2.3  反射机制	42
2.3.1  动态语言的概念	42
2.3.2  反射机制的概念	43
2.3.3  反射的应用	43
2.3.4  Java的反射API	43
2.3.5  反射的步骤	43
2.3.6  创建对象的两种方式	45
2.3.7  Method的invoke方法	45
2.4  注解	46
2.4.1  注解的概念	46
2.4.2  标准元注解：@Target、@Retention、@Documented、@Inherited	46
2.4.3  注解处理器	47
2.5  内部类	49
2.5.1  静态内部类	49
2.5.2  成员内部类	50
2.5.3  局部内部类	51
2.5.4  匿名内部类	51
2.6  泛型	52
2.6.1  泛型标记和泛型限定：E、T、K、V、N、?	53
2.6.2  泛型方法	53
2.6.3  泛型类	54
2.6.4  泛型接口	55
2.6.5  类型擦除	56
2.7  序列化	56
2.7.1  Java序列化API的使用	57
2.7.2  序列化和反序列化	58
第3章  Java并发编程	59
3.1  Java线程的创建方式	59
3.1.1  继承Thread类	59
3.1.2  实现Runnable接口	60
3.1.3  通过ExecutorService和Callable<Class>实现有返回值的线程	61
3.1.4  基于线程池	62
3.2  线程池的工作原理	62
3.2.1  线程复用	63
3.2.2  线程池的核心组件和核心类	63
3.2.3  Java线程池的工作流程	65
3.2.4  线程池的拒绝策略	66
3.3  5种常用的线程池	68
3.3.1  newCachedThreadPool	68
3.3.2  newFixedThreadPool	68
3.3.3  newScheduledThreadPool	69
3.3.4  newSingleThreadExecutor	69
3.3.5  newWorkStealingPool	69
3.4  线程的生命周期	70
3.4.1  新建状态：New	71
3.4.2  就绪状态：Runnable	71
3.4.3  运行状态：Running	71
3.4.4  阻塞状态：Blocked	71
3.4.5  线程死亡：Dead	72
3.5  线程的基本方法	72
3.5.1  线程等待：wait方法	72
3.5.2  线程睡眠：sleep方法	73
3.5.3  线程让步：yield方法	73
3.5.4  线程中断：interrupt方法	73
3.5.5  线程加入：join方法	74
3.5.6  线程唤醒：notify方法	75
3.5.7  后台守护线程：setDaemon方法	75
3.5.8  sleep方法与wait方法的区别	76
3.5.9  start方法与run方法的区别	76
3.5.10  终止线程的4种方式	77
3.6  Java中的锁	79
3.6.1  乐观锁	79
3.6.2  悲观锁	79
3.6.3  自旋锁	80
3.6.4  synchronized	81
3.6.5  ReentrantLock	89
3.6.6  synchronized和ReentrantLock的比较	94
3.6.7  Semaphore	95
3.6.8  AtomicInteger	96
3.6.9  可重入锁	97
3.6.10  公平锁与非公平锁	97
3.6.11  读写锁：ReadWriteLock	98
3.6.12  共享锁和独占锁	98
3.6.13  重量级锁和轻量级锁	99
3.6.14  偏向锁	99
3.6.15  分段锁	100
3.6.16  同步锁与死锁	100
3.6.17  如何进行锁优化	100
3.7  线程上下文切换	101
3.7.1  上下文切换	102
3.7.2  引起线程上下文切换的原因	102
3.8  Java阻塞队列	103
3.8.1  阻塞队列的主要操作	104
3.8.2  Java中的阻塞队列实现	108
3.9  Java并发关键字	113
3.9.1  CountDownLatch	113
3.9.2  CyclicBarrier	114
3.9.3  Semaphore	116
3.9.4  volatile关键字的作用	117
3.10  多线程如何共享数据	119
3.10.1  将数据抽象成一个类，并将对这个数据的操作封装在类的方法中	119
3.10.2  将Runnable对象作为一个类的内部类，将共享数据作为这个类的成员变量	121
3.11  ConcurrentHashMap并发	122
3.11.1  减小锁粒度	122
3.11.2  ConcurrentHashMap的实现	123
3.12  Java中的线程调度	123
3.12.1  抢占式调度	123
3.12.2  协同式调度	124
3.12.3  Java线程调度的实现：抢占式	124
3.12.4  线程让出CPU的情况	125
3.13  进程调度算法	125
3.13.1  优先调度算法	125
3.13.2  高优先权优先调度算法	126
3.13.3  时间片的轮转调度算法	127
3.14  什么是CAS	128
3.14.1  CAS的概念：比较并交换	128
3.14.2  CAS的特性：乐观锁	128
3.14.3  CAS自旋等待	129
3.15  ABA问题	129
3.16  什么是AQS	130
3.16.1  AQS的原理	130
3.16.2  state：状态	131
3.16.3  AQS共享资源的方式：独占式和共享式	131
第4章  数据结构	133
4.1  栈及其Java实现	133
4.2  队列及其Java实现	136
4.3  链表	138
4.3.1  链表的特点	139
4.3.2  单向链表的操作及其Java实现	139
4.3.3  双向链表及其Java实现	143
4.3.4  循环链表	146
4.4  散列表	146
4.4.1  常用的构造散列函数	147
4.4.2  Hash的应用	148
4.5  二叉排序树	148
4.5.1  插入操作	149
4.5.2  删除操作	149
4.5.3  查找操作	151
4.5.4  用Java实现二叉排序树	151
4.6  红黑树	155
4.6.1  红黑树的特性	156
4.6.2  红黑树的左旋	156
4.6.3  红黑树的右旋	157
4.6.4  红黑树的添加	157
4.6.5  红黑树的删除	158
4.7  图	159
4.7.1  无向图和有向图	159
4.7.2  图的存储结构：邻接矩阵	160
4.7.3  图的存储结构：邻接表	161
4.7.4  图的遍历	162
4.8  位图	164
4.8.1  位图的数据结构	164
4.8.2  位图的Java实现	165
第5章  Java中的常用算法	167
5.1  二分查找算法	167
5.1.1  二分查找算法的原理	168
5.1.2  二分查找算法的Java实现	168
5.2  冒泡排序算法	169
5.2.1  冒泡排序算法的原理	169
5.2.2  冒泡排序算法的Java实现	170
5.3  插入排序算法	171
5.3.1  插入排序算法的原理	171
5.3.2  插入排序算法的Java实现	172
5.4  快速排序算法	173
5.4.1  快速排序算法的原理	173
5.4.2  快速排序算法的Java实现	174
5.5  希尔排序算法	175
5.5.1  希尔排序算法的原理	176
5.5.2  希尔排序算法的Java实现	177
5.6  归并排序算法	178
5.6.1  归并排序算法的原理	178
5.6.2  归并排序算法的Java实现	178
5.7  桶排序算法	180
5.7.1  桶排序算法的原理	180
5.7.2  桶排序算法的Java实现	181
5.8  基数排序算法	182
5.8.1  基数排序算法的原理	182
5.8.2  基数排序算法的Java实现	183
5.9  其他算法	184
5.9.1  剪枝算法	184
5.9.2  回溯算法	186
5.9.3  最短路径算法	186
第6章  网络与负载均衡	188
6.1  网络	188
6.1.1  OSI七层网络模型	188
6.1.2  TCP/IP四层网络模型	189
6.1.3  TCP三次握手/四次挥手	190
6.1.4  HTTP的原理	195
6.1.5  CDN的原理	199
6.2  负载均衡	201
6.2.1  四层负载均衡与七层负载均衡的对比	201
6.2.2  负载均衡算法	203
6.2.3  LVS的原理及应用	205
6.2.4  Nginx反向代理与负载均衡	211
第7章  数据库及分布式事务	214
7.1  数据库的基本概念及原则	214
7.1.1  存储引擎	214
7.1.2  创建索引的原则	216
7.1.3  数据库三范式	217
7.1.4  数据库事务	218
7.1.5  存储过程	219
7.1.6  触发器	219
7.2  数据库的并发操作和锁	220
7.2.1  数据库的并发策略	220
7.2.2  数据库锁	220
7.2.3  数据库分表	223
7.3  数据库分布式事务	223
7.3.1  CAP	223
7.3.2  两阶段提交协议	224
7.3.3  三阶段提交协议	225
7.3.4  分布式事务	227
第8章  分布式缓存的原理及应用	230
8.1  分布式缓存介绍	230
8.2  Ehcache的原理及应用	231
8.2.1  Ehcache的原理	231
8.2.2  Ehcache的应用	234
8.3  Redis的原理及应用	235
8.3.1  Redis的原理	235
8.3.2  Redis的应用	249
8.4  分布式缓存设计的核心问题	252
8.4.1  缓存预热	253
8.4.2  缓存更新	253
8.4.3  缓存淘汰策略	253
8.4.4  缓存雪崩	253
8.4.5  缓存穿透	254
8.4.6  缓存降级	255
第9章  设计模式	256
9.1  设计模式简介	256
9.2  工厂模式的概念及Java实现	259
9.3  抽象工厂模式的概念及Java实现	261
9.4  单例模式的概念及Java实现	265
9.5  建造者模式的概念及Java实现	268
9.6  原型模式的概念及Java实现	271
9.7  适配器模式的概念及Java实现	274
9.8  装饰者模式的概念及Java实现	280
9.9  代理模式的概念及Java实现	282
9.10  外观模式的概念及Java实现	284
9.11  桥接模式的概念及Java实现	288
9.12  组合模式的概念及Java实现	291
9.13  享元模式的概念及Java实现	293
9.14  策略模式的概念及Java实现	296
9.15  模板方法模式的概念及Java实现	299
9.16  观察者模式的概念及Java实现	302
9.17  迭代器模式的概念及Java实现	305
9.18  责任链模式的概念及Java实现	308
9.19  命令模式的概念及Java实现	312
9.20  备忘录模式的概念及Java实现	315
9.21  状态模式的概念及Java实现	317
9.22  访问者模式的概念及Java实现	320
9.23  中介者模式的概念及Java实现	324
9.24  解释器模式的概念及Java实现
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Offer来了：Java面试核心知识点精讲（原理篇）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala与Clojure函数式编程模式
第1章　模式和函数式编程　　1
1.1　什么是函数式编程　　2
1.2　模式词汇表　　4
第2章　TinyWeb：让模式协同工作　　7
2.1　TinyWeb简介　　7
2.2　采用Java来编写TinyWeb　　7
2.3　采用Scala来编写TinyWeb 　　17
2.4　采用Clojure来编写TinyWeb　　25
第3章　替代面向对象模式　　35
简介　　35
模式1　替代函数式接口　　35
模式2　替代承载状态的函数式接口　　42
模式3　替代命令模式　　48
模式4　替代生成器模式来获得不可变对象　　55
模式5　替代迭代器模式　　64
模式6　替代模板方法模式　　73
模式7　替代策略模式　　81
模式8　替代空对象　　87
模式9　替代装饰器模式　　95
模式10　替代访问者模式　　99
模式11　替代依赖注入　　113
第4章　函数式模式　　121
简介　　121
模式12　尾递归模式　　121
模式13　相互递归模式　　128
模式14　Filter-Map-Reduce模式　　136
模式15　操作链模式　　139
模式16　函数生成器模式　　146
模式17　记忆模式　　159
模式18　惰性序列模式　　163
模式19　集中的可变性　　172
模式20　自定义控制流　　180
模式21　领域特定语言　　191
第5章　结束语　　201
参考文献　　202
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala与Clojure函数式编程模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 企业设计模式
目录:
第1章 软件模式介绍 1
第2章 UML概述 5
第3章 软件生命周期 24
第4章 事务处理模式 26
第5章 分布式体系结构模式 59
第6章 分布式计算模式 96
第7章 并发模式 228
第8章 时间模式 289
第9章 数据库模式 329
附录A 持久框架 375
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 企业设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java安全编码标准
《java安全编码标准》
译者序
序
前言
致谢
第1章　概述1
1.1 错位的信任1
1.2 注入攻击2
1.3 敏感数据泄露3
1.4 效能泄露5
1.5 拒绝服务6
1.6 序列化8
1.7 并发性、可见性和内存8
1.8 最低权限原则14
1.9 安全管理器15
1.10　类装载器16
1.11　小结16
第2章　输入验证和数据净化（ids）17
规则17
风险评估概要17
.2.1　ids00-j净化穿越受信边界的非受信数据18
2.2　ids01-j验证前标准化字符串26
2.3　ids02-j在验证之前标准化路径名28
2.4　ids03-j不要记录未经净化的用户输入31
2.5　ids04-j限制传递给zipinputstream的文件大小33
2.6　ids05-j使用ascii字符集的子集作为文件名和路径名35
2.7　ids06-j从格式字符串中排除用户输入37
2.8　ids07-j不要向runtime.exec()?方法传递非受信、未净化的数据38
2.9　ids08-j净化传递给正则表达式的非受信数据41
2.10　ds09-j如果没有指定适当的locale，不要使用locale相关方法处理与locale相关的数据44
2.11　ids10-j不要拆分两种数据结构中的字符串45
2.12　ids11-j在验证前去掉非字符码点50
2.13　ids12-j在不同的字符编码中无损转换字符串数据51
2.14　ids13-j在文件或者网络i/o两端使用兼容的编码方式53
第3章　声明和初始化（dcl）56
规则56
风险评估概要56
3.1　dcl00-j防止类的循环初始化56
3.2　dcl01-j不要重用java标准库的已经公开的标识59
3.3　dcl02-j将所有增强for语句的循环变量声明为final类型60
第4章　表达式（exp）63
规则63
风险评估概要63
4.1　exp00-j不要忽略方法的返回值63
4.2　exp01-j不要解引用空指针65
4.3　exp02-j使用两个参数的arrays.equals()方法来比较两个数组的内容67
4.4　exp03-j不要用相等操作符来比较两个基础数据类型的值67
4.5　exp04-j确保使用正确的类型来自动封装数值72
4.6　exp05-j不要在一个表达式中对同一变量进行多次写入73
4.7　exp06-j不要在断言中使用有副作用的表达式76
第5章　数值类型与运算（num）78
规则78
风险评估概要78
5.1　num00-j检测和避免整数溢出79
5.2　num01-j不要对同一数据进行位运算和数学运算85
5.3　num02-j确保除法运算和模运算中的除数不为088
5.4　num03-j使用可容纳无符号数据合法取值范围的整数类型89
5.5　num04-j不要使用浮点数进行精细计算90
5.6　num05-j不要使用非标准化数92
5.7　num06-j使用strictfp修饰符确保跨平台浮点运算的一致性94
5.8　num07-j不要尝试与nan进行比较97
5.9　num08-j检查浮点输入特殊的数值98
5.10　num09-j不要使用浮点变量作为循环计数器100
5.11　num10-j不要从浮点字元构造bigdecimal对象101
5.12　num11-j不要比较或者审查以字符串表达的浮点数值102
5.13　num12-j确保将数值转换成较小类型时不会产生数据丢失或曲解103
5.14　num13-j转换基本整数类型至浮点类型时应避免精度损失107
第6章　面向对象（obj）110
规则110
风险评估概要110
6.1　obj00-j只有受信子类能对具有不变性的类和方法进行扩展111
6.2　obj01-j声明数据成员为私有并提供可访问的封装器方法116
6.3　obj02-j当改变基类时，保存子类之间的依赖关系118
6.4　obj03-j在新代码中，不要混用具有泛型和非泛型的原始数据类型124
6.5　obj04-j为可变类提供复制功能，并通过此功能允许将实例传递给非受信代码128
6.6　obj05-j在返回引用之前，防御性复制私有的可变的类成员132
6.7　obj06-j对可变输入和可变的内部组件创建防御性复制136
6.8　obj07-j不允许敏感类复制其自身138
6.9　obj08-j不要在嵌套类中暴露外部类的私有字段141
6.10　obj09-j比较类而不是类名称143
6.11　obj10-j不要使用公有静态的非final变量144
6.12　obj11-j小心处理构造函数抛出异常的情况146
第7章　方法（met）153
规则153
风险评估概要153
7.1　met00-j验证方法参数154
7.2　met01-j不要使用断言验证方法参数156
7.3　met02-j不要使用弃用的或过时的类和方法157
7.4　met03-j进行安全检测的方法必须声明为private或final158
7.5　met04-j不要增加被覆写方法和被隐藏方法的可访问性160
7.6　met05-j确保构造函数不会调用可覆写的方法161
7.7　met06-j不要在clone()中调用可覆写的方法163
7.8　met07-j不要定义类方法来隐藏基类或基类接口中声明的方法165
7.9　met08-j确保比较等同的对象能得到相等的结果167
7.10　met09-j定义了equlas()方法的类必须定义hashcode()方法174
7.11　met10-j实现compareto()方法时遵守常规合约176
7.12　met11-j确保比较中的关键码是不可变的178
7.13　met12-j不要使用析构函数182
第8章　异常行为（err）187
规则187
风险评估概要187
8.1　err00-j不要消除或忽略可检查的异常187
8.2　err01-j不能允许异常泄露敏感信息192
8.3　err02-j记录日志时应避免异常196
8.4　err03-j在方法失败时恢复对象先前的状态197
8.5　err04-j不要在finally程序段非正常退出201
8.6　err05-j不要在finally程序段中遗漏可检查异常202
8.7　err06-j不要抛出未声明的可检查异常205
8.8　err07-j不要抛出runtimeexception、exception或throwable209
8.9　err08-j不要捕捉nullpointerexception或任何它的基类210
8.10　err09-j禁止非受信代码终止jvm216
第9章　可见性和原子性（vna）219
规则219
风险评估概要219
9.1　vna00-j当需要读取共享基础数据类型变量时，需要保证其可见性219
9.2　vna01-j保证对一个不可变对象的共享引用的可见性222
9.3　vna02-j保证对于共享变量的组合操作是原子性的225
9.4　vna03-j即使每一个方法都是相互独立并且是原子性的，也不要假设一组调用是原子性的230
9.5　vna04-j保证串联在一起的方法调用是原子性的235
9.6　vna05-j保证在读写64位的数值时的原子性239
第10章　锁（lck）241
规则241
风险评估概要241
10.1　lck00-j通过私有final锁对象可以同步那些与非受信代码交互的类242
10.2　lck01-j不要基于那些可能被重用的对象进行同步246
10.3　lck02-j不要基于那些通过getclass()返回的类对象来实现同步249
10.4　lck03-j不要基于高层并发对象的内置锁来实现同步252
10.5　lck04-j即使集合是可访问的，也不要基于集合视图使用同步253
10.6　lck05-j对那些可以被非受信代码修改的静态字段，需要同步进入255
10.7　lck06-j不要使用一个实例锁来保护共享静态数据256
10.8　lck07-j使用相同的方式请求和释放锁来避免死锁258
10.9　lck08-j在异常条件时，保证释放已经持有的锁266
10.10　lck09-j不要执行那些持有锁时会阻塞的操作270
10.11　lck10-j不要使用不正确形式的双重锁定检查惯用法273
10.12　lck11-j当使用那些不能对锁策略进行承诺的类时，避免使用客户端锁定277
第11章　线程api（thi）282
规则282
风险评估概要282
11.1 thi00-j不要调用thread.run()282
11.2 thi01-j不能调用threadgroup方法284
11.3 thi02-j通知所有等待中的线程而不是单一线程287
11.4 thi03-j始终在循环中调用wait()和await()方法292
11.5 thi04-j确保可以终止受阻线程295
11.6 thi05-j不要使用thread.stop()来终止线程300
第12章　线程池（tps）304
规则304
风险评估概要304
12.1 tps00-j使用线程池处理流量突发以实现降低性能运行304
12.2 tps01-j不要使用有限的线程池来执行相互依赖的任务307
12.3 tps02-j确保提交至线程池的任务是可中断的312
12.4 tps03-j确保线程池中正在执行的任务不会失败而不给出任何提示315
12.5 tps04-j使用线程池时，确保threadlocal变量可以重新初始化318
第13章　与线程安全相关的其他规则（tsm）323
规则323
风险评估概要323
13.1 tsm00-j不要使用非线程安全方法来覆写线程安全方法323
13.2 tsm01-j不要让this引用在创建对象时泄漏326
13.3 tsm02-j不要在初始化类时使用后台线程332
13.4 tsm03-j不要发布部分初始化的对象336
第14章　输入输出（fio）342
规则342
风险评估概要342
14.1 fio00-j不要操作共享目录中的文件343
14.2 fio01-j使用合适的访问权限创建文件351
14.3 fio02-j发现并处理与文件相关的错误352
14.4 fio03-j在终止前移除临时文件354
14.5 fio04-j在不需要时关闭资源357
14.6 fio05-j不要使用wrap()或duplicate()创建缓存，并将这些缓存暴露给非受信代码361
14.7 fio06-j不能在一个单独的inputstream上创建多个缓存区封装器364
14.8 fio07-j不要让外部进程阻塞输入和输出流367
14.9 fio08-j对读取一个字符或者字节的方法，使用int类型的返回值370
14.10 fio09-j不要使用write()方法输出超过0～255的整数372
14.11 fio10-j使用read()方法保证填充一个数组373
14.12 fio11-j不要将原始的二进制数据作为字符数据读入375
14.13 fio12-j为小端数据的读写提供方法376
14.14 fio13-j不要在受信边界之外记录敏感信息379
14.15 fio14-j在程序终止时执行正确的清理动作381
第15章　序列化（ser）387
规则387
风险评估概要387
15.1 ser00-j在类的演化过程中维护其序列化的兼容性388
15.2 ser01-j不要偏离序列化方法的正确签名390
15.3 ser02-j在将对象向信任边界之外发送时，需要签名并且封装敏感对象392
15.4 ser03-j不要序列化未经加密的敏感数据397
15.5 ser04-j不要允许序列化和反序列化绕过安全管理器401
15.6 ser05-j不要序列化内部类实例404
15.7 ser06-j在反序列化时，对私有的可变的组件进行防御性复制405
15.8 ser07-j不要对实现定义的不可变因素使用默认的序列化格式406
15.9 ser08-j在从拥有特性的环境中进行反序列化之前最小化特权410
15.10 ser09-j不要从readobject()方法中调用可以被覆写的方法413
15.11 ser10-j在序列化时，避免出现内存和资源泄漏414
15.12 ser11-j防止覆盖外部化的对象415
第16章　平台安全性（sec）417
规则417
风险评估概要417
16.1 sec00-j不要允许特权代码块越过受信边界泄露敏感信息417
16.2 sec01-j不要在特权代码块中使用污染过的变量420
16.3 sec02-j不要基于非受信源进行安全检查422
16.4 sec03-j不要在允许非受信代码装载任意类之后装载受信类424
16.5 sec04-j使用安全管理器检查来保护敏感操作426
16.6 sec05-j不要使用反射来增加类、方法和字段的可访问性429
16.7 sec06-j不要依赖于默认的由urlclassloader和java.util.jar提供的自动化签名检查434
16.8 sec07-j当编写一个自定义的类装载器时调用基类的getpermissions()方法437
16.9 sec08-j定义基于原生方法的封装器438
第17章　运行环境（env）441
规则441
风险评估概要441
17.1 env00-j不要签名只执行非特权操作的代码441
17.2 env01-j将所有安全敏感的代码置于单独一个jar包中，并且在签名之后封装它443
17.3 env02-j不要信任环境变量的值446
17.4 env03-j不要赋予危险的权限组合448
17.5 env04-j不要关闭字节码验证功能451
17.6 env05-j不要部署一个被远程监视的应用452
第18章　其他（msc）457
规则457
风险评估概要457
18.1 msc00-j在交换安全数据时使用sslsocket而不是socket457
18.2 msc01-j不要使用空的无限循环461
18.3 msc02-j生成强随机数462
18.4 msc03-j不要硬编码敏感信息464
18.5 msc04-j防止内存泄漏466
18.6 msc05-j不要耗尽堆空间473
18.7 msc06-j当一个遍历正在进行时，不要修改它对应的集合477
18.8 msc07-j防止多次实例化单例对象481
术语表490
参考资源497
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java安全编码标准
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计教程实验手册
第二章  JAVA应用程序介绍
第三章  JAVA APPLET介绍
第四章  控制结构（一）
第五章  控制结构（二）
第六章  方法
第七章  数组
第八章  基于对象编程
第九章  面向对象编程：继承
第十章  面向对象编程：多态性
第十二章  图形和JAVA2D
第十三章  图形用户界面组件（一）
第十五章  异常处理
第十七章  文件和流
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计教程实验手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Ant极限编程
第1章 XP和Ant
第2章 建立初始Spike
第3章 第一次迭代
第4章 第一个完整的创建过程
第5章 建立自动每日创建
……
附录A 安装Ant
附录B 扩展Ant
附录C Ant2
附录D 完整的buidfile清单
附录E 工具版本
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Ant极限编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java开发实战1200例（第I卷）
第1篇　Java语法与面向对象技术
第1章　开发环境的应用
1.1　Java环境
实例001　下载JDK开发工具包
实例002　把JDK工具包安装到指定磁盘
实例003　设置JDK的环境变量
实例004　验证Java开发环境
实例005　下载并安装JRE执行环境
实例006　编程输出星号组成的等腰三角形
1.2　开发工具
实例007　下载最新的Eclipse
实例008　为最新的Eclipse安装中文语言包
实例009　活用Eclipse的工作空间
实例010　在Eclipse项目中编程输出字符表情
实例011　为Eclipse添加新的JDK环境
实例012　设置Eclipse中文API提示信息
实例013　为项目添加类库
实例014　使当前项目依赖另一个项目
1.3　界面设计器
实例015　安装界面设计器
实例016　设计Windows系统的运行对话框界面
实例017　设计计算器程序界面
实例018　设计关于进销存管理系统的界面
第2章　Java基础应用
2.1　基本语法
实例019　输出错误信息与调试信息
实例020　从控制台接收输入字符
实例021　重定向输出流实现程序日志
实例022　自动类型转换与强制类型转换
2.2　运算符
实例023　加密可以这样简单（位运算）
实例024　用三元运算符判断奇数和偶数
实例025　更精确地使用浮点数
实例026　不用乘法运算符实现2×16
实例027　实现两个变量的互换（不借助第3个变量）
2.3　条件语句
实例028　判断某一年是否为闰年
实例029　验证登录信息的合法性
实例030　为新员工分配部门
实例031　用Switch语句根据消费金额计算折扣
实例032　判断用户输入月份的季节
2.4　循环控制
实例033　使用while与自增运算符循环遍历数组
实例034　使用for循环输出杨辉三角
实例035　使用嵌套循环在控制台上输出九九乘法表
实例036　用while循环计算1+1/2!+1/3!…1/20!
实例037　for循环输出空心的菱形
实例038　foreach循环优于for循环
实例039　终止循环体
实例040　循环体的过滤器
实例041　循环的极限
第3章　数组与集合的应用
3.1　数组演练
实例042　获取一维数组最小值
实例043　将二维数组中的行列互换
实例044　利用数组随机抽取幸运观众
实例045　用数组设置JTable表格的列名与列宽
3.2　数组操作
实例046　数组的下标界限
实例047　按钮控件数组实现计数器界面
实例048　复选框控件数组
实例049　用数组反转字符串
3.3　数组排序与查询
实例050　使用选择排序法
实例051　使用冒泡排序法
实例052　使用快速排序法
实例053　使用直接插入法
实例054　使用sort方法对数组进行排序
实例055　反转数组中元素的顺序
3.4　常用集合的使用
实例056　用动态数组保存学生姓名
实例057　用List集合传递学生信息
实例058　用TreeSet生成不重复自动排序随机数组
实例059　Map映射集合实现省市级联选择框
第4章　字符串处理技术
4.1　格式化字符串
实例060　把数字格式化为货币字符串
实例061　格式化当前日期
实例062　货币金额大写格式
实例063　String类格式化当前日期
实例064　字符串大小写转换
实例065　字符与Unicode码的转换
4.2　辨别字符串
实例066　判断用户名是否正确
实例067　用户名排序
实例068　判断网页请求与FTP请求
实例069　判断文件类型
实例070　判断字符串是否为数字
实例071　验证IP地址的有效性
实例072　鉴别非法电话号码
4.3　操作字符串
实例073　根据标点符号对字符串进行分行
实例074　将字符串的每个字符进行倒序输出
实例075　获取字符串中汉字的个数
实例076　批量替换某一类字符串
实例077　把异常与错误信息显示到窗体中
实例078　从字符串中分离文件路径、文件名及扩展名
实例079　判断手机号的合法性
实例080　用字符串构建器追加字符
实例081　去掉字符串中的所有空格
实例082　汉字与区位码的转换
第5章　面向对象技术应用
5.1　Java中类的定义
实例083　自定义图书类
实例084　温度单位转换工具
实例085　域的默认初始化值
实例086　编写同名的方法
实例087　构造方法的应用
5.2　修饰符的使用
实例088　单例模式的应用
实例089　祖先的止痒药方
实例090　统计图书的销售量
实例091　汉诺塔问题求解
实例092　不能重写的方法
5.3　包装类的使用
实例093　将字符串转换成整数
实例094　整数进制转换器
实例095　查看数字的取值范围
实例096　ASCII编码查看器
实例097　Double类型的比较
5.4　面向对象的特征
实例098　经理与员工的差异
实例099　重写父类中的方法
实例100　计算几何图形的面积
实例101　提高产品质量的方法
实例102　简单的汽车销售商场
5.5　Object类的应用
实例103　两只完全相同的宠物
实例104　简化equals()方法的重写
实例105　重新计算对象的哈希码
实例106　简化hashCode()方法的重写
实例107　使用字符串输出对象
实例108　简化toString()方法的重写
5.6　克隆与序列化
实例109　Java对象的假克隆
实例110　Java对象的浅克隆
实例111　Java对象的深克隆
实例112　序列化与对象克隆
实例113　深克隆效率的比较
实例114　transient关键字的应用
5.7　接口和内部类
实例115　使用sort()方法排序
实例116　简化compareTo()方法的重写
实例117　策略模式的简单应用
实例118　适配器模式的简单应用
实例119　普通内部类的简单应用
实例120　局部内部类的简单应用
实例121　匿名内部类的简单应用
实例122　静态内部类的简单应用
第2篇　Java高级应用
第6章　多线程技术
6.1　线程的基础
实例123　新建无返回值的线程
实例124　查看线程的运行状态
实例125　查看JVM中的线程名
实例126　查看和修改线程名称
实例127　查看和修改线程优先级
实例128　使用守护线程
实例129　休眠当前线程
实例130　终止指定线程
实例131　线程的插队运行
6.2　线程的同步
实例132　非同步的数据读写
实例133　使用方法实现线程同步
实例134　使用代码块实现线程同步
实例135　使用特殊域变量实现线程同步
实例136　使用重入锁实现线程同步
实例137　使用线程局部变量实现线程同步
实例138　简单的线程通信
实例139　简单的线程死锁
实例140　解决线程的死锁问题
6.3　线程的进阶
实例141　使用阻塞队列实现线程同步
实例142　新建有返回值的线程
实例143　使用线程池优化多线程编程
实例144　Object类中线程相关的方法
实例145　哲学家就餐问题
实例146　使用信号量实现线程同步
实例147　使用原子变量实现线程同步
实例148　使用事件分配线程更新Swing控件
实例149　使用SwingWorker类完成耗时操作
第7章　反射与异常处理
7.1　反射的基础
实例150　实例化Class类的5种方式
实例151　获得Class对象表示实体的名称
实例152　查看类的声明
实例153　查看类的成员
实例154　按继承层次对类排序
实例155　查看内部类信息
7.2　反射的进阶
实例156　动态设置类的私有域
实例157　动态调用类中的方法
实例158　动态实例化类
实例159　创建长度可变的数组
实例160　利用反射重写toString()方法
实例161　反射与动态代理
7.3　常见的未检查型异常
实例162　算数异常
实例163　数组存值异常
实例164　数组下标越界异常
实例165　空指针异常
7.4　常见的已检查型异常
实例166　类未发现异常
实例167　非法访问异常
实例168　文件未发现异常
实例169　数据库操作异常
7.5　处理异常
实例170　方法中抛出异常
实例171　方法上抛出异常
实例172　自定义异常类
实例173　捕获单个异常
实例174　捕获多个异常
第8章　枚举与泛型的应用
8.1　枚举使用的简介
实例175　查看枚举类型的定义
实例176　枚举类型的基本特性
实例177　增加枚举元素的信息
实例178　选择合适的枚举元素
实例179　高效的枚举元素集合
实例180　高效的枚举元素映射
实例181　遍历枚举接口的元素
实例182　简单的文件合并工具
8.2　泛型使用的简介
实例183　自定义非泛型栈结构
实例184　使用泛型实现栈结构
实例185　自定义泛型化数组类
实例186　泛型方法与数据查询
实例187　泛型化方法与最小值
实例188　泛型化接口与最大值
实例189　使用通配符增强泛型
实例190　泛型化的折半查找法
第9章　编程常用类
9.1　Calendar类的使用
实例191　简单的数字时钟
实例192　简单的电子时钟
实例193　简单的模拟时钟
实例194　简单的公历万年历
实例195　查看生日相关信息
9.2　SimpleDateFormat与TimeZone类的使用
实例196　日期格式有效性判断
实例197　常见日期格式使用
实例198　查看本地时区
实例199　简单的时区转换工具
9.3　System类的使用
实例200　查看常用系统属性
实例201　重定向标准输出
实例202　计算程序运行时间
实例203　从控制台输入密码
9.4　Math类的使用
实例204　角度和弧度的转换
实例205　三角函数的使用
实例206　反三角函数的使用
实例207　双曲函数的使用
实例208　指数与对数运算
9.5　其他常用类的使用
实例209　高精度整数运算
实例210　高精度浮点运算
实例211　七星彩号码生成器
实例212　大乐透号码生成器
实例213　监视JVM内存状态
实例214　启动默认文本工具
实例215　简单的截图软件
第10章　Commons组件
10.1　Commons Lang组件简介 273
实例216　数组元素的增加
实例217　数组元素的删除
实例218　生成随机字符串
实例219　序列化与反序列化
实例220　分数的常见运算
实例221　整数取值范围判断
10.2　Commons Math组件简介 280
实例222　描述统计学应用
实例223　绘制简单直方图
实例224　一元线性回归计算
实例225　实数矩阵的运算
实例226　复数的常见运算
实例227　T分布常用计算
10.3　Commons IO组件简介 286
实例228　简化文件（夹）删除
实例229　简化文件（夹）复制
实例230　简化文件（夹）排序
实例231　简化文件（夹）过滤
实例232　简化文件的读写操作
10.4　Commons BeanUtils组件简介 291
实例233　设置JavaBean简单属性
实例234　设置JavaBean级联属性
实例235　动态生成JavaBean
实例236　复制JavaBean属性
实例237　动态排序JavaBean
10.5　其他Commons组件简介
实例238　优雅的JDBC代码
实例239　结果集与Bean列表
实例240　编写MD5查看器
实例241　基于Base64编码
实例242　基于Base64解码
实例243　发送简单的Email
实例244　发送带附件的Email
实例245　读取XML文件属性
第3篇　窗体与控件应用
第11章　窗体设计
11.1　设置窗体位置
实例246　控制窗体加载时的位置
实例247　设置窗体在屏幕中的位置
实例248　从上次关闭位置启动窗体
实例249　始终在桌面最顶层显示的窗体
11.2　设置窗体大小
实例250　设置窗体大小
实例251　根据桌面大小调整窗体大小
实例252　自定义最大化、最小化和关闭按钮
实例253　禁止改变窗体的大小
11.3　设置窗体的标题栏
实例254　指定窗体标题栏图标
实例255　拖动没有标题栏的窗体
实例256　取消窗体标题栏与边框
实例257　设置闪烁的标题栏
11.4　设置窗体的背景
实例258　设置窗体背景颜色为淡蓝色
实例259　实现带背景图片的窗体
实例260　使背景图片自动适应窗体的大小
实例261　背景为渐变色的主界面
实例262　随机更换窗体背景
11.5　窗体形状及应用
实例263　椭圆形窗体界面
实例264　钻石形窗体
实例265　创建透明窗体
11.6　对话框
实例266　模态对话框与非模态对话框
实例267　信息提示对话框
实例268　设置信息提示对话框的图标
实例269　文件选择对话框指定数据库备份文件
实例270　指定打开对话框的文件类型
实例271　文件的保存对话框
实例272　为保存对话框设置默认文件名
实例273　支持图片预览的文件选择对话框
实例274　颜色选择对话框
实例275　信息输入对话框
实例276　定制信息对话框
11.7　MDI窗体的使用
实例277　创建内部子窗体
实例278　使子窗体最大化显示
实例279　对子窗体进行平铺排列
实例280　禁用MDI窗体控制栏中的“最大化”按钮
第12章　窗体特效
12.1　让窗体更有活力
实例281　右下角弹出信息窗体
实例282　淡入淡出的窗体
实例283　窗体顶层的进度条
实例284　设置窗体的鼠标光标
实例285　窗体抖动
实例286　窗体标题显示计时器
实例287 动态展开窗体 365
实例288　仿QQ隐藏窗体
实例289　窗体百叶窗登场特效
实例290　关闭窗体打开网址
12.2　窗体与控件外观
实例291　Nimbus外观
实例292 本地系统外观 370
实例293　分割的窗体界面
实例294　圆周运动的窗体
第13章　基本控件应用
13.1　顶层容器的应用
实例295　框架容器的背景图片
实例296　更多选项的框架容器
实例297　拦截事件的玻璃窗格
实例298　简单的每日提示信息
实例299　震动效果的提示信息
13.2　布局管理器应用
实例300　边框布局的简单应用
实例301　流式布局的简单应用
实例302　网格布局的简单应用
实例303　制作圆形布局管理器
实例304　制作阶梯布局管理器
13.3　输入控件的应用
实例305　可以打开网页的标签
实例306　密码域控件的简单应用
实例307　给文本域设置背景图片
实例308　给文本区设置背景图片
实例309　简单的字符统计工具
13.4　选择控件的应用
实例310　能预览图片的复选框
实例311　简单的投票计数软件
实例312　单选按钮的简单应用
实例313　能显示图片的组合框
实例314　使用滑块来选择日期
13.5　菜单控件的应用
实例315　模仿记事本的菜单栏
实例316　自定义纵向的菜单栏
实例317　复选框与单选按钮菜单
实例318　包含图片的弹出菜单
实例319　工具栏的实现与应用
13.6　其他技术的应用
实例320　自定义软件安装向导
实例321　查看系统支持的外观
实例322　制作软件的闪屏界面
实例323　自定义系统托盘图标
实例324　使用撤销与重做功能
第14章　复合数据类型控件应用
14.1　列表的简单应用
实例325　修改列表项显示方式
实例326　修改列表项选择模式
实例327　列表项的全选与不选
实例328　列表元素与提示信息
实例329　监听列表项单击事件
实例330　监听列表项双击事件
14.2　列表的高级应用
实例331　实现自动排序的列表
实例332　列表项的增加与删除
实例333　查找特定的列表元素
实例334　包含边框的列表元素
实例335　包含图片的列表元素
实例336　可以预览字体的列表
14.3　表格的简单应用
实例337　表头与列的高度设置
实例338　调整表格各列的宽度
实例339　设置表格的选择模式
实例340　为表头增添提示信息
实例341　单元格的粗粒度排序
实例342　实现表格的查找功能
14.4　表格的高级应用
实例343　在表格中应用组合框
实例344　删除表格中选中的行
实例345　实现表格的分页技术
实例346　为单元格绘制背景色
实例347　实现表格的栅栏效果
实例348　单元格的细粒度排序
14.5　树控件简单应用
实例349　编写中国省市信息树
实例350　树控件常用遍历方式
实例351　自定义树节点的图标
实例352　监听节点的选择事件
实例353　设置树控件选择模式
实例354　查看节点的各种状态
14.6　树控件高级应用
实例355　在树控件中增加节点
实例356　在树控件中删除节点
实例357　在树控件中查找节点
实例358　自定义树节点的外观
实例359　为树节点增加提示信息
实例360　双击编辑树节点功能
第15章　其他高级控件应用
15.1　JTextPane控件的应用
实例361　自定义文档标题的样式
实例362　文档中显示自定义图片
实例363　检查代码中的括号是否匹配
实例364　描红显示100以内的质数
15.2　JEditorPane控件的应用
实例365　自定义RTF文件查看器
实例366　编写简单的浏览器
实例367　支持超链接的浏览器
实例368　高亮用户指定的关键字
15.3　其他文本控件的应用
实例369　只能输入整数的文本域
实例370　强制输入合法的整数
实例371　使用微调控件调整时间
实例372　使用微调控件浏览图片
15.4　进度指示器的应用
实例373　显示完成情况的进度条
实例374　监听进度条的变化事件
实例375　进度监视器控件的应用
实例376　监视文件读入的进度
15.5　控件组织器的应用
实例377　分割面板的简单应用
实例378　为选项卡增加快捷键
实例379　为选项卡标题设置图标
实例380　记录选项卡的访问状态
第16章　控件特效与自定义控件
16.1　控件边框效果
实例381　实现标签控件的立体边框
实例382　实现按钮控件边框留白
实例383　实现文本域控件的浮雕化边框
实例384　为文本框控件添加LineBorder线形边框
实例385　控件的纯色边框与图标边框
实例386　实现带标题边框的面板容器
实例387　指定字体的标题边框
实例388　嵌套的标题边框
实例389　带图标边框的标题边框
实例390　文本框的下划线边框
16.2　控件渲染让界面UI更灵活
实例391　支持图标的列表控件
实例392　在列表控件中显示单选按钮
实例393　列表控件折行显示列表项
实例394　使用图片制作绚丽按钮
实例395　实现按钮关键字描红
实例396　忙碌的按钮控件
实例397　实现透明效果的表格控件
实例398　在表格中显示工作进度百分比
实例399　在表格中显示图片
16.3　让控件活起来
实例400　鼠标经过时按钮放大效果
实例401　迟到的登录按钮
实例402　焦点按钮的缩放
实例403　标签文本的跑马灯特效
实例404　延迟生效的按钮
实例405　动态加载表格数据
16.4　自定义控件
实例406　石英钟控件
实例407　IP输入文本框控件
实例408　日历控件
实例409　平移面板控件
实例410　背景图面板控件
第4篇　文件操作典型应用
第17章　文件与文件夹操作
17.1　文件操作
实例411　修改文件属性
实例412　显示指定类型的文件
实例413　以树结构显示文件路径
实例414　查找替换文本文件内容
实例415　支持图片预览的文件选择对话框
实例416　设置Windows的文件属性
实例417　文件批量重命名
实例418　快速批量移动文件
实例419　删除磁盘中所有的.tmp临时文件
17.2　文件与数据库
实例420　提取数据库内容到文件
实例421　提取文本文件的内容到MySQL数据库
实例422　将图片文件保存到SQL Server数据库 556
实例423　显示数据库中的图片信息
实例424　提取技术网站数据到文件夹
实例425　读取文件路径到数据库
实例426　在数据库中建立磁盘文件索引
17.3　操作磁盘文件夹
实例427　窗体动态加载磁盘文件
实例428　删除文件夹中所有文件
实例429　创建磁盘索引文件
实例430　快速全盘查找文件
实例431　获取磁盘所有文本文件
实例432　网络文件夹备份
第18章　文件的读取、写入、整理和控制
18.1　文件的读取与写入
实例433　键盘录入内容保存到文本文件
实例434　将数组写入到文件中并逆序输出
实例435　利用StringBuffer避免文件的多次写入
实例436　合并多个txt文件
实例437　实现文件简单加密与解密
实例438　对大文件实现分割处理
实例439　将分割后的文件重新合并
实例440　读取属性文件的单个属性值
实例441　向属性文件中添加信息
实例442　在复制文件时使用进度条
实例443　从XML文件中读取数据
实例444　读取Jar文件属性
实例445　电子通讯录
18.2　实现文件整理
实例446　批量复制指定扩展名的文件
实例447　计数器小程序
实例448　将某文件夹中的文件进行分类存储
18.3　文件控制
实例449　利用StreamTokenizer统计文件的字符数
实例450　在指定目录下搜索文件
实例451　序列化和反序列化对象
实例452　文件锁定
实例453　投票统计
第19章　文件压缩
19.1　Java实现文件压缩
实例454　压缩所有文本文件
实例455　压缩包解压到指定文件夹
实例456　压缩所有子文件夹
实例457　深层文件夹压缩包的释放
实例458　解决压缩包中文乱码
实例459　Apache实现文件解压缩
实例460　把窗体压缩成ZIP文件
实例461　解压缩Java对象
19.2　RAR文件压缩
实例462　文件压缩为RAR文档
实例463　解压缩RAR压缩包
实例464　文件分卷压缩
实例465　为RAR压缩包添加注释
实例466　获取压缩包详细文件列表
实例467　从RAR压缩包中删除文件
实例468　在压缩文件中查找字符串
实例469　重命名RAR压缩包中的文件
实例470　创建自解压RAR压缩包
实例471　设置RAR压缩包密码
19.3　数据压缩的网络应用
实例472　以压缩格式传输网络数据
实例473　压缩远程文件夹
实例474　压缩存储网页
第20章　操作办公文档
20.1　操作Word
实例475　把文本文件导入到Word中
实例476　浏览本地Word文件
实例477　将员工表插入到Word文档中
实例478　将员工照片插入到Word简历
实例479　将Word文档保存为HTML格式
20.2　操作Excel
实例480　将员工信息保存到Excel表中
实例481　通过Excel公式计算出商品表中的总售价
实例482　将数据库表中的内容写入到Excel
实例483　将Excel表中的内容保存到数据库
实例484　将Excel文件转换为HTML格式
20.3　操作PDF
实例485　应用iText组件生成PDF
实例486　在窗体中显示PDF文件
实例487　应用PDF Renderer组件实现放大PDF文件 658
实例488　应用PDF Renderer组件实现缩小PDF文件 660
实例489　应用PDF Renderer组件实现抓手功能 661
实例490　全屏显示PDF文件
第5篇　数据库应用
第21章　SQL应用
21.1　排序和分组函数应用
实例491　对数据进行降序查询
实例492　对数据进行多条件排序查询
实例493　对统计结果进行排序
实例494　查询SQL Server数据库中的前3条数据 671
实例495　查询SQL Server数据库中的后3条数据 672
实例496　查询MySQL数据库中的前3条数据
实例497　查询MySQL数据库中的后3条数据
实例498　按照字母顺序对留学生表进行排序
实例499　按姓氏笔画排序
实例500　将汉字按音序排序
实例501　按列的编号排序
实例502　从表中随机返回记录
实例503　使用GROUP BY子句实现对数据的分组统计 681
实例504　使用GROUP BY子句实现多表分组统计 682
21.2　聚集函数与日期查询
实例505　利用SUM函数实现数据汇总
实例506　利用AVG函数实现计算平均值
实例507　利用MIN函数求数据表中的最小值
实例508　利用MAX函数求数据表中的最大值
实例509　利用COUNT函数求销售额大于某值的图书种类
实例510　查询编程词典6月的销售量
实例511　查询与张静同一天入司的员工信息
实例512　使用IN谓词查询某几个时间的数据
实例513　日期查询中避免千年虫问题
21.3　大小比较与逻辑应用
实例514　在查询结果中不显示重复记录
实例515　使用NOT查询不满足条件的记录
实例516　使用between进行区间查询
实例517　列出销量表中的重复记录和记录条数
实例518　使用关系运算符查询某一时间段数据
实例519　计算两个日期之间的月份数
实例520　格式化金额
实例521　在查询语句中过滤掉字符串中的空格
第22章　数据库操作
22.1　通过JDBC-ODBC桥连接数据库
实例522　通过JDBC-ODBC桥连接SQL Server 2000数据库 706
实例523　JDBC-ODBC桥连接Access数据库
实例524　JDBC-ODBC桥与Oracle数据库建立连接
22.2　JDBC技术连接数据库
实例525　通过JDBC连接SQL Server 2000数据库 711
实例526　JDBC连接MySQL数据库
实例527　JDBC连接SQL Server 2005数据库 714
实例528　JDBC技术连接Oracle数据库
实例529　JDBC连接JavaDB数据库
22.3　数据库与数据表
实例530　列举SQL Server数据库下的数据表 717
实例531　列举MySQL数据库下的数据表
实例532　查看数据表结构
实例533　动态维护投票数据库
实例534　SQL Server数据备份 722
实例535　SQL Server数据恢复 725
实例536　MySQL数据备份
实例537　MySQL数据恢复
实例538　动态附加数据库
实例539　生成SQL数据库脚本
实例540　获取SQL Server数据表字段的描述信息 734
22.4　数据增加、更新与删除操作
实例541　将员工信息添加到数据表
实例542　添加数据时使用数据验证
实例543　插入用户登录日志信息
实例544　生成有规律的编号
实例545　生成无规律的编号
实例546　在插入数据时过滤掉危险字符
实例547　将用户选择的爱好以字符串形式保存到数据库
实例548　将数据从一张表复制到另一张表
实例549　使用UNION ALL语句批量插入数据 746
实例550　更新指定记录
实例551　在删除数据时给出提示信息
实例552　将数据表清空
实例553　字符串大小写转换
第23章　数据查询
23.1　使用子查询
实例554　将子查询作为表达式
实例555　用子查询作为派生表
实例556　通过子查询关联数据
实例557　使用IN谓词限定查询范围
实例558　使用NOT IN子查询实现差集运算 758
实例559　使用NOT IN子查询实现反向查询 759
实例560　返回笛卡尔乘积
实例561　比较运算符引入子查询
实例562　在子查询中使用聚集函数
实例563　在删除数据时使用子查询
23.2　嵌套查询
实例564　查询平均成绩在85分以上的学生信息
实例565　查询本科部门经理月收入情况
实例566　在嵌套中使用EXISTS关键字
实例567　动态指定查询条件
23.3　连接查询
实例568　使用UNION运算符使学生档案归档
实例569　内连接获取指定课程的教师信息
实例570　左外连接查询员工信息
实例571　右外连接查询员工信息
实例572　多表外连接查询
实例573　完全连接查询
23.4　函数查询
实例574　在查询中使用patindex()函数进行模糊查询
实例575　对查询结果进行格式化
实例576　在查询中使用字符串函数
实例577　在查询中使用ALL谓词
实例578　在查询中使用ANY谓词
实例579　使用UNION运算符消除重复的行
实例580　使用UNION ALL运算符保留重复的行
实例581　计算商品销售额所占的百分比
第24章　数据库高级应用
24.1　在Java程序中使用存储过程
实例582　调用存储过程实现用户身份验证
实例583　应用存储过程添加数据
实例584　调用加密存储过程
实例585　获取数据库中所有存储过程
实例586　修改存储过程
实例587　删除存储过程
24.2　使用触发器
实例588　应用触发器添加日志信息
实例589　在删除成绩表时将学生表中的数据删除
实例590　在程序中调用UPDATE触发器
实例591　获取数据库中的触发器名称
实例592　创建带有触发条件的触发器
24.3　使用批处理
实例593　使用批处理删除数据
实例594　使用批处理提升部门员工工资
实例595　将教师表中的数据全部添加到选课表
实例596　在批处理中使用事务
24.4　使用视图
实例597　创建视图
实例598　使用视图过滤不想要的数据
实例599　使用视图与计算数据
实例600　使用视图重新格式化检索出来的数据
实例601　获取数据库中的全部用户视图
实例602　修改视图
实例603　删除视图
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java开发实战1200例（第I卷）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java微服务
前言	XV
1  一种解决方法	1
微服务的演变	2
整体式架构概述	3
整体式架构的局限性与它的微服务解决方案的对比	3
一维的可扩展性	6
在出故障时回滚版本	7
采用新技术时的问题	7
与敏捷实践的契合	8
减轻开发工作量——可以做得更好	9
微服务的构建管道	10
使用诸如Docker的容器部署	11
容器	11
Docker	12
Docker的架构	13
Docker容器	14
部署	14
小结	14
2  设置开发环境	17
Spring Boot配置	18
Spring Boot概述	18
把Spring Boot添加至REST示例	19
添加一个嵌入式Jetty服务器	21
示例REST程序	22
编写REST控制器类	24
@RestController	25
@RequestMapping	25
@RequestParam	25
@PathVariable	26
制作一个示例REST可执行应用程序	29
设置应用程序构建	30
运行Maven工具	30
用Java命令执行	31
使用Postman Chrome扩展测试REST API	31
更多的正向测试场景	34
反向的测试场景	35
NetBeans IDE安装和设置	37
参考资料	42
小结	42
3  领域驱动设计	43
领域驱动设计基本原理	44
组成部分	45
普遍存在的语言	45
多层架构	45
表示层	46
应用程序层	46
领域层	46
基础架构层	47
领域驱动设计的工件	47
实体	47
值对象	48
服务	49
聚合	50
存储库	52
工厂	53
模块	54
战略设计和原则	55
有界上下文	55
持续集成	56
上下文映射	57
共享内核模式	58
客户和供应商模式	58
顺从者模式	59
反腐层	59
独立方法	59
开放主机服务	60
精馏	60
示例领域服务	60
实体的实现	61
存储库的实现	63
服务的实现	66
小结	67
4  实现微服务	69
OTRS概述	70
开发和实现微服务	71
餐馆微服务	72
控制器类	73
服务类	76
存储库类	79
实体类	82
预订和用户服务	85
注册和发现服务（Eureka服务）	85
执行	87
测试	87
参考资料	92
小结	92
5  部署和测试	93
使用Netflix OSS的微服务架构概述	93
负载均衡	95
客户端的负载均衡	95
服务器端的负载均衡	98
电路断路器与监控	102
使用Hystrix的回退方法	102
监控	103
设置Hystrix仪表板	105
设置Turbine	107
使用容器部署微服务	109
安装和配置	109
具有4 GB内存的Docker机器	110
使用Maven构建Docker映像	110
使用 Maven 运行Docker	114
使用Docker执行集成测试	115
把映像推送到注册表	118
管理Docker容器	119
参考资料	121
小结	121
6  实现微服务的安全性	123
启用安全套接字层	123
身份验证和授权	127
OAuth 2.0	127
OAuth的用法	128
OAuth 2.0规范——简明详细信息	128
OAuth 2.0角色	129
OAuth 2.0客户端注册	131
OAuth 2.0协议端点	135
OAuth 2.0授权类型	137
使用Spring Security的OAuth实现	144
授权码许可	150
隐式许可	153
资源所有者密码凭据许可	154
客户端凭据许可	155
参考资料	155
小结	156
7  利用微服务Web应用程序来使用服务	157
AngularJS框架概述	157
MVC	158
MVVM	158
模块	158
提供程序和服务	160
作用域	161
控制器	161
过滤器	161
指令	162
UI-Router	162
OTRS 功能的开发	163
主页/餐馆列表页	163
index.html	164
app.js	169
restaurants.js	172
restaurants.html	179
搜索餐馆	180
餐馆详细信息与预订选项	181
restaurant.html	181
登录页面	183
login.html	184
login.js	185
预订确认	186
设置web应用程序	187
小结	201
8  最佳做法和一般原则	203
概述和心态	203
最佳做法和原则	205
Nanoservice（不推荐）、规模和整体性	205
持续集成和部署	206
系统/端到端测试自动化	207
自我监控和记录	207
每个微服务都使用独立的数据存储区	209
事务边界	210
微服务框架和工具	210
Netflix开放源码软件（OSS）	210
构建——Nebula	211
部署和交付——Spinnaker与Aminator	211
服务注册和发现——Eureka	211
服务沟通——Ribbon	212
电路断路器——Hystrix	212
边缘（代理）服务器——Zuul	212
业务监控——Atlas	213
可靠性监控服务——Simian Army	213
AWS资源监控——Edda	214
主机性能监控——Vector	215
分布式配置管理——Archaius	215
Apache Mesos调度器——Fenzo	215
成本和云利用率——Ice	216
其他安全工具——Scumblr和FIDO	216
参考资料	217
小结	218
9  故障排除指南	219
日志记录和ELK环境	219
简要概述	221
Elasticsearch	221
Logstash	221
Kibana	222
ELK环境安装	222
安装Elasticsearch	223
安装Logstash	224
安装Kibana	225
服务调用关联ID的使用	226
让我们看看怎样解决这个问题	226
依赖项和版本	227
循环依赖关系及其影响	227
设计系统时需要分析它	227
维护不同版本	227
让我们了解更多	228
参考资料	228
小结	228
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java微服务
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>解析Java虚拟机开发
第1章一起走进Java世界
1.1 Java的优势
1.1.1 排名第一的编程语言
1.1.2 提供给我们美好的就业前景
1.2 学习Java需要了解的那些事
1.2.1 品Java语言的发展历史
1.2.2 Java的特点
1.3 剖析Java的运行机制
1.3.1 高级语言的运行机制
1.3.2 Java的运行机制
1.3.3 Java虚拟机ⅧIVM
1.3.4 独特的垃圾回收机制
1.4 剖析Java语言体系
1.4.1 Java程序员的6个级别
1.4.2 分析Java体系的构成
1.5 Java虚拟机家族
1.5.1 虚拟机的用途
1.5.2 理解Iava虚拟机
1.5.3 Java虚拟机的数据类型
1.5.4 Java虚拟机体系结构
1.5.5 探索Java虚拟机家族成员的发展史
1.6 Java的最大优势——平台无关性
1.6.1 平台无关性的好处
1.6.2 Java对平台无关性的支持
1.6.3 分析影响Java平台无关性的因素
1.6.4 实现平台无关性的策略
第2章 JDK编译测试
第3章 安全性的考虑
第4章 通过网络实现移动性
第5章 浅谈Java虚拟机的内部机制
第6章 详解Class文件
第7章 栈和局部变量操作
第8章 内存异常和垃圾处理
第9章 高效手段之性能监控工具和优化部署
第10章 JVM参数分析和调优实战
第11章 虚拟机类的加载机制
第12章 研究高效之魂
第13章 类加载器和执行子系统
第14章 编译优化
第15章 运行期优化
第16章 内存模型和线程
第17章 安全和优化合二为一
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>解析Java虚拟机开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java从入门到精通
如何学习Java　Ⅰ
第1篇 基础知识
第1章　初识庐山真面目——Java 6　2
视频教学录像：1小时21分钟
千里之行，始于足下。掌握一门编程语言的最好方法就是——亲自体验，本章将从零开始带领你一步步走进Java编程世界，指导你编写出第1个Java程序。
1.1　Java的历史　3
1.2　Java的现状　4
1.2.1　Java技术分支　4
1.2.2　Java语言的跨平台性　5
1.3　Java的特点　5
1.3.1　Java语言的优点　5
1.3.2　Java语言的关键特性　6
要进行Java开发，首先就要安装好开发工具，本节将讲解最新开发工具——JDK 1.6.0_17多国语言版的安装。
1.4　安装Java开发工具箱——JDK 1.6.0_17多国语言版　7
1.5　磨刀不误砍柴工——配置开发环境　8
1.6　享受安装成果——编写第1个Java程序　9
1.7　classpath的指定　10
1.8　探秘Java虚拟机(JVM)　11
1.9　练一练　11
1.10　跟我上机　12
第2章　再识庐山真面目——简单的Java程序　13
视频教学录像：8分钟
Java的基本框架部分可以由一个简单而完整的例子来讲解，通过这个例子你将会对Java的开发有更切身的体会。
2.1　一个简单的例子　14
2.2　感性认识Java程序　15
2.2.1　认识Java程序的框架　16
2.2.2　认识标识符　17
2.2.3　认识关键字　17
2.2.4　认识注释　18
2.2.5　认识变量　18
2.2.6　认识数据类型　19
2.2.7　认识运算符和表达式　19
2.2.8　认识类　20
2.3　程序的检测　20
2.3.1　语法错误　20
2.3.2　语义错误　21
2.4　提高程序的可读性　22
要想成为一名专业的开发人员，一开始就要养成良好的开发风格，遵循代码书写规则可以使你事半功倍。
2.5　练一练　23
2.6　跟我上机　24
第3章　最流行的Java开发工具——Eclipse　25
视频教学录像：38分钟
图形界面的开发工具使开发过程变得更有趣和直观，而附加的功能强大的插件使我们有更多理由选择Eclipse作为Java开发工具。
3.1　认识Eclipse开发工具　26
3.1.1　Eclipse概述　26
3.1.2　Eclipse的安装、设置与启动　26
3.1.3　Eclipse 工作台　28
3.1.4　Eclipse 菜单栏　28
3.2　使用Eclipse开始工作　30
3.2.1　创建Java项目　31
3.2.2　创建Java类文件　31
3.2.3　在代码编辑器中编写Java程序代码　33
3.2.4　运行Java程序　34
3.3　在Eclipse中调试程序　35
在Eclipse中调试程序将变得再简单不过，一旦程序出错，你可以直接定位到出错行，快速清除程序bug。
3.4　练一练　37
3.5　跟我上机　37
第4章　最常用的编程元素——常量与变量　38
视频教学录像：14分钟
在程序运行过程中，有两种数据——固定的和变化的，就是常量与变量。掌握本章讲到的最常用的编程元素将有助于接下来的学习。
4.1　常量　39
4.1.1　声明常量　39
4.1.2　常量应用示例　39
4.2　变量　39
在Java中对变量的命名有相应的规则，按照本节讲到的命名规则可以使你更容易编写出成功的程序，少走许多弯路。
4.2.1　声明变量　40
4.2.2　变量的命名规则　41
4.2.3　变量的作用范围　41
4.3　练一练　42
4.4　跟我上机　43
第5章　不可不知的数据分类法——数据类型　44
视频教学录像：21分钟
熟练使用数据类型是学好Java语言的基础，掌握数据类型后才能以此为工具实现更高级的功能。
5.1　整数类型　45
5.1.1　byte类型　45
5.1.2　short类型　46
5.1.3　int类型　47
5.1.4　long类型　47
5.2　浮点类型　48
5.2.1　float类型　48
5.2.2　double类型　49
5.3　字符类型　50
5.4　布尔类型　51
5.5　数据类型的转换　52
5.5.1　自动类型转换　52
5.5.2　强制类型转换　53
5.6　专题研究——基本数据类型的默认值　54
本书专门归纳出所有基本数据的默认值，供开发人员参考使用。
5.7　练一练　55
5.8　跟我上机　55
第6章　最重要的编程部件——运算符、表达式与语句　56
视频教学录像：1小时18分钟
由运算符、表达式到语句，构成了Java语言的最基本部分，无论多么大型的软件，都是由这些重要的编程部件组成。
6.1　运算符　57
6.1.1　赋值运算符　57
6.1.2　一元运算符　58
6.1.3　算术运算符　59
6.1.4　关系运算符与if语句　61
6.1.5　递增与递减运算符　62
6.1.6　逻辑运算符　63
6.1.7　括号运算符　65
6.1.8　运算符的优先级　65
6.2　表达式　66
6.2.1　算术表达式　68
6.2.2　关系表达式　69
6.2.3　逻辑表达式　69
6.2.4　条件表达式　70
6.2.5　赋值表达式　71
6.2.6　表达式的类型转换　71
6.3　语句　72
语句是程序的最小单位，程序由一条条语句组成，本节将讲解几条在Java中特殊的语句。
6.3.1　语句中的空格　73
6.3.2　空语句　73
6.3.3　声明语句　73
6.3.4　赋值语句　74
6.4　练一练　74
6.5　跟我上机　74
第7章　改变程序执行方向——程序控制结构　75
视频教学录像：35分钟
灵活使用程序控制语句是一个成功Java开发人员的必备技能，本章将循序渐进讲解在Java中程序控制的方法。
7.1　程序的结构设计　76
7.1.1　顺序结构　76
7.1.2　选择结构　76
7.1.3　循环结构　78
7.2　选择结构　78
7.2.1　if语句　78
7.2.2　if...else语句　79
7.2.3　if...else if...else语句　80
7.2.4　条件运算符　82
7.2.5　多重选择——switch语句　83
7.3　循环结构　85
合理使用循环结构将大大减轻程序工作量，并使程序代码简洁易懂。
7.3.1　while循环　86
7.3.2　do...while循环　87
7.3.3　for循环　89
7.3.4　循环嵌套　91
7.4　循环的跳转　92
7.4.1　break语句　92
7.4.2　continue语句　93
7.5　练一练　95
7.6　跟我上机　95
第8章　常用的数据结构——数组　96
视频教学录像：1小时2分钟
数组可以模拟生活中的很多模型，比如排序、队列问题等，使用数组可以使程序的编写更科学合理。
8.1　一维数组　97
8.1.1　一维数组的声明与内存的分配　97
8.1.2　数组中元素的表示方法　98
8.1.3　数组初值的赋值　100
8.1.4　数组应用范例　101
8.1.5　与数组操作有关的API方法　102
8.2　二维数组　104
学习的过程应该由简入繁，掌握一维数组后，二维数组可以看做一维数组的衍生应用，多维数组与此类似。
8.2.1　二维数组的声明与分配内存　104
8.2.2　二维数组元素的引用及访问　105
8.3　多维数组　106
8.4　练一练　107
8.5　跟我上机　108
第2篇 核心技术
第9章　面向对象设计——类和对象　110
视频教学录像：2小时13分钟
Java是面向对象的编程语言，类和对象是面向对象编程的重要概念。一个人如果不了解类和对象，就不能说会使用Java语言。
9.1　面向对象程序设计的基本概念　111
9.1.1　对象　111
9.1.2　类　111
9.1.3　封装性　112
9.1.4　继承性　112
9.1.5　多态性　113
9.2　类　113
9.2.1　类的声明　114
9.2.2　类的定义　115
9.3　对象　116
对象的使用让Java程序在处理现实问题时更加人性化，使用对象可以用“进化”的方式衍生出具有更多特性的模型。
9.3.1　对象的声明　116
9.3.2　对象的使用　117
9.3.3　对象的比较　119
9.3.4　对象数组的使用　121
9.4　类的属性　123
9.4.1　属性的定义　123
9.4.2　属性的使用　123
9.5　类的方法　125
9.5.1　方法的定义　125
9.5.2　方法的使用　126
9.5.3　构造方法　126
9.5.4　构造方法的重载　128
9.5.5　构造方法的私有　131
9.5.6　在类内部调用方法　134
9.6　练一练　136
9.7　跟我上机　136
第10章　类的封装、继承与多态　137
视频教学录像：1小时38分钟
封装、继承与多态是类的高级应用，使用这些特性可以使Java程序更加“面向对象”。
10.1　类的封装　138
10.1.1　封装的基本概念　138
10.1.2　类的封装实例　139
10.2　类的继承　144
继承是面向对象语言的必备功能，而且是面向对象的另一个重要特性——多态的基础，所以理解继承以及如何实现继承相当重要。
10.2.1　继承的基本概念　144
10.2.2　类的继承实例　145
10.3　类的继承专题研究　147
10.3.1　子类对象的实例化过程　147
10.3.2　super关键字的使用　149
10.3.3　限制子类的访问　152
10.3.4　覆写　153
10.4　类的多态　156
10.4.1　多态的基本概念　156
10.4.2　类的多态实例　158
10.5　练一练　160
10.6　跟我上机　160
第11章　抽象类与接口　161
视频教学录像：1小时27分钟
抽象类可以理解为“模板”，在Java中设计者可以使用抽象类的格式创建新的类。
11.1　抽象类的基本概念　162
11.2　抽象类实例　162
11.3　接口的基本概念　166
11.4　接口实例　167
接口与抽象类十分相似，但又有所不同，本节将以实例讲解接口的具体使用。
11.5　练一练　170
11.6　跟我上机　170
第12章　关于类的专题研究　171
视频教学录像：3小时26分钟
关于Java的类，每个Java编程人员都需要花很多时间领悟。本章通过对类的专题研究，总结出众多编程人员的宝贵经验，使你快速步入高手行列。
12.1　众类鼻祖——Object类　172
12.2　内部类　174
12.2.1　在类外部引用内部类　178
12.2.2　在方法中定义内部类　179
12.3　匿名内部类　182
12.4　匿名对象　185
12.5　再谈方法　186
方法可以简化程序的结构，把具有特定功能的程序代码独立起来，节省编写相同代码的时间，使程序模块化。
12.5.1　方法的参数与返回值　188
12.5.2　方法的重载　190
12.5.3　将数组传递到方法里　191
12.6　引用数据类型的传递　194
12.7　覆写Object类中的equals方法　197
12.8　接口对象的实例化　200
12.9　this关键字的使用　203
12.10 static关键字的使用　207
12.10.1　静态变量　207
12.10.2　静态方法　211
12.10.3　理解main()方法　213
12.10.4　静态代码块　214
12.11　final关键字的使用　216
12.12　instanceof关键字的使用　217
12.13　练一练　219
12.14　跟我上机　219
第13章　储存类的仓库——Java常用类库　220
视频教学录像：5小时6分钟
Java类库是JDK中提供的已实现的标准类的集合，使用Java类库可以完成涉及字符串处理、图形、网络等方面的操作。
13.1　API概念　221
13.2　String类和StringBuffer类　221
13.3　基本数据类型的包装类　222
13.4　System类与Runtime类　223
13.4.1　System类　223
13.4.2　Runtime类　224
13.5　Date与Calendar、DateFormat类　225
13.6　Math与Random类　228
13.7　hashCode()方法　228
13.8　对象克隆　230
“对象克隆”就是把现存对象重新复制一份，应该怎样使用克隆技术呢，本节将为你具体讲解。
13.9　练一练　232
13.10 跟我上机　232
第14章　包及访问权限　233
视频教学录像：43分钟
包是类的一种特殊性质，在管理大型项目时一定要使用到包。利用包可以合理地管理大量的类文件，还可以设置他人对类成员的访问权等。本章将详细讲解包及访问权限的使用。
14.1　包的概念及使用　234
14.1.1　包(package)的基本概念　234
14.1.2　import语句的使用　235
14.1.3　JDK中常见的包　237
14.2　类成员的访问控制权限　237
14.3　Java的命名习惯　240
14.4　打包工具——Jar命令的使用　240
Jar文件是一种压缩文件，习惯称为“Jar包”，如果开发了许多类，提供给用户时一般会将类压缩到一个Jar文件中。本节将讲解打包工具——Jar命令的使用方法。
14.5　练一练　241
14.6　跟我上机　241
第15章　异常处理　242
视频教学录像：43分钟
程序出错不可避免，Java提供了强大的异常处理机制，所有的异常都被封装到一个类中，在程序出错时会将异常抛出。
15.1　异常的基本概念　243
15.1.1　为何需要异常处理　243
15.1.2　简单的异常范例　243
15.1.3　异常的处理　244
15.1.4　异常处理机制的回顾　247
15.2　异常类的继承架构　248
15.3　抛出异常　249
15.3.1　在程序中抛出异常　249
15.3.2　指定方法抛出异常　250
15.4　编写自己的异常类　251
面对各种各样的异常，Java可以通过继承的方式编写自己的异常类。本节教你在Java中如何编写自己的异常类。
15.5　练一练　253
15.6　跟我上机　253
第16章　Java类集框架　254
视频教学录像：1小时49分钟
Java类集框架可以使程序在处理对象时的方法更加标准化，类集接口是构造类集框架的基础。
16.1　类集接口　255
16.1.1　类集接口　256
16.1.2　List接口　257
16.1.3　集合接口　258
16.1.4　SortedSet接口　258
16.2　Collection接口　258
16.2.1　ArrayList类　259
16.2.2　LinkedList类　262
16.2.3　HashSet类　264
16.2.4　TreeSet类　265
16.3　通过迭代方法访问类集　266
16.4　处理映射　269
Java 2中增加了映射，映射是一个储存关键字和值的关联，或者说是给定一个关键字，可以得到它的值。
16.4.1　映射接口　269
16.4.2　映射类　271
16.4.3　比较方法　274
16.5　从以前版本遗留下来的类和接口　277
16.5.1　Enumeration接口　278
16.5.2　Vector类　278
16.5.3　Stack类　281
16.5.4　Dictionary类　282
16.5.5　Hashtable类　283
16.5.6　Properties类　285
16.5.7　Properties类中使用store()和load()方法　287
16.6　练一练　288
16.7　跟我上机　288
第17章　JDK 1.5以上版本的新功能——枚举　289
视频教学录像：49分钟
枚举是被命名的整型常数的集合，枚举在生活中具有很大的实际意义，比如枚举一星期的Sunday、Monday和Tuesday等。
17.1　枚举简介　290
17.2　枚举的作用　290
17.3　枚举的用法　292
17.3.1　常见的枚举定义方法　292
17.3.2　在程序中使用枚举　293
17.3.3　在switch语句中使用枚举　294
17.4　枚举类和枚举关键字　295
17.4.1　枚举类　295
17.4.2　枚举关键字　297
17.4.3　枚举类与枚举关键字的区别　297
17.5　类集对于枚举的支持　298
17.5.1　EnumMap　298
17.5.2　EnumSet　299
17.6　深入了解枚举　301
枚举的作用在Java中，甚至在所有的计算机语言中，都占有举足轻重的地位。了解枚举，不能够浅尝辄止。本节将带领你一起将枚举熟练化，提高工程水平及工程逻辑度。
17.6.1　枚举的构造方法　301
17.6.2　枚举的接口　302
17.6.3　在枚举中定义抽象方法　303
17.7　练一练　304
17.8　跟我上机　305
第18章　给编译器看的注释——Annotation　306
视频教学录像：1小时6分钟
Annotation是建立在反射机制之上的功能，通过Annotation可以方便地对程序进行注释操作。
18.1　Annotation　307
18.2　系统内建的Annotation　307
18.2.1　@Override　307
18.2.2　@Deprecated　308
18.2.3　@SuppressWarnings　308
18.3　自定义Annotation　309
18.4　Retention和RetentionPolicy　311
18.5　反射与Annotation　311
18.5.1　取得全部的Annotation　312
18.5.2　加入自定义的Annotation　312
18.6　深入Annotation　314
Annotation要起作用，必须要依靠反射机制，通过反射可以取得在一个方法上声明的Annotation的全部内容。
18.6.1　Target　314
18.6.2　Documented注释　315
18.6.3　Inherited　316
18.7　练一练　316
第3篇 高级应用
第19章　齐头并进完成任务——多线程　318
视频教学录像：2小时
多线程机制可以使计算机资源得到更充分的利用，可以让程序在同一时间内完成很多任务。
19.1　进程与线程　319
19.2　认识线程　319
19.2.1　通过继承Thread类实现多线程　321
19.2.2　通过实现Runnable接口实现多线程　322
19.2.3　两种多线程实现机制的比较　324
19.3　线程的状态　328
19.4　线程操作的一些方法　329
19.4.1　取得和设置线程的名称　330
19.4.2　判断线程是否启动　332
19.4.3　后台线程与setDaemon()方法　334
19.4.4　线程的强制运行　335
19.4.5　线程的休眠　337
19.4.6　线程的中断　338
19.5　多线程的同步　340
使用线程就一定要考虑到多线程的同步问题，因为如果线程不同步，将会引发很多意想不到的后果，本节将讲解多线程的同步方法。
19.5.1　同步问题的引出　341
19.5.2　同步代码块　342
19.5.3　同步方法　343
19.5.4　死锁　344
19.6　线程间通信　347
19.6.1　问题的引出　347
19.6.2　问题如何解决　347
19.7　线程生命周期的控制　355
19.8　练一练　357
19.9　跟我上机　357
第20章　文件IO操作　358
视频教学录像：4小时40分钟
程序运行的数据要保存到文件中，就一定要用到I/O输入输出技术。Java提供的I/O操作能把数据保存到多种类型的文件中。
20.1　File类　359
20.2　RandomAccessFile类　361
20.3　流类　363
20.3.1　字节流　364
20.3.2　字符流　368
20.3.3　管道流　372
20.3.4　ByteArrayInputStream与ByteArrayOutputStream　375
20.3.5　System.in和System.out　376
20.3.6　打印流　376
20.3.7　DataInputStream与DataOutputStream　378
20.3.8　合并流　382
20.3.9　字节流与字符流的转换　384
20.3.10　IO包中的类层次关系图　387
20.4　字符编码　388
20.5　对象序列化　392
对象序列化是指把对象转换为数据流的一种实现手段，是文件操作的一个重要概念，通过将对象序列化，可以方便地实现对象的传输及保存。
20.6　练一练　394
20.7　跟我上机　394
第21章　Java网页小程序——Java Applet　395
视频教学录像：7分钟
Java Applet是经过编译的Java程序，能够在所有支持Java的浏览器中运行。Java Applet跨平台、操作系统，具有广泛的使用。
21.1　Applet程序简介　396
21.2　Applet程序中使用的几个基本方法　397
21.3　在HTML中嵌入Applet程序　399
21.3.1　HTML代码的基本结构　399
21.3.2　Applet标记　400
21.3.3　在HTML中传递Applet程序使用的参数　401
21.4　练一练　403
21.5　跟我上机　403
第22章　Java 网络程序设计　404
视频教学录像：39分钟
网络程序设计是Java程序设计的一个重要应用，使用Java可以轻松地开发出各种类型的网络程序。
22.1　Socket介绍　405
22.2　Socket程序　405
22.3　DatagramSocket程序　413
22.4　网络编程的基本概念　416
22.5　TCP程序实现　416
TCP/IP协议是广泛使用的网络协议，本节将指导你利用Java开发出一个简单的TCP程序实现通讯功能。
22.5.1　简单的TCP程序　417
22.5.2　Echo程序　418
22.5.3　加入多线程　420
22.6　UDP程序实现　421
22.7　练一练　422
22.8　跟我上机　422
第23章　Java数据库编程　423
视频教学录像：1小时36分钟
在已有的Java函数库中，有一组专门处理数据库连接的API：JDBC。本章将带领大家学会如何使用来自Java的数据精华——JDBC。
23.1　数据库连接的基本概念　424
23.2　使用数据库的准备工作　425
23.2.1　Oracle数据库的安装　425
23.2.2　数据库连接驱动程序设置　427
23.2.3　数据库表的准备　428
23.3　连接数据库的步骤　430
23.4　数据库连接的详细步骤　430
23.5　数据维护　432
23.5.1　增加数据　432
23.5.2　更新数据　433
23.5.3　删除数据　435
23.6　查询数据库中的内容　437
23.7　查询信息实例　439
23.8　与数据库相关的接口　442
23.8.1　完成增加操作　442
23.8.2　完成查询操作　444
23.8.3　完成模糊查询操作　446
23.9　批处理　447
23.10 事务处理　449
23.11 MySQL数据库　451
MySQL是免费的数据库软件，最新版本的MySQL功能已经十分强大，掌握MySQL对于进行在Java下的数据库程序开发会有很大帮助。
23.11.1　MySQL数据库的安装　451
23.11.2　MySQL数据库的基本命令　453
23.11.3　使用MySQL数据库　454
23.12　练一练　455
23.13　跟我上机　455
第4篇 项目实战
第24章　Java项目开发实战——五子棋游戏　458
视频教学录像：4小时39分钟
本章将带领读者使用Java语言，从无到有设计出一款有趣好玩的五子棋游戏，所用到的知识包括但不限于之前章节讲到的内容。希望大家一定要亲自动手打造这款小游戏，体验编程的乐趣。
24.1　系统概述　459
24.1.1　运行本系统　459
24.1.2　本系统的开发步骤　459
24.1.3　五子棋游戏的功能　460
24.1.4　主要技术　460
24.2　开发前的知识准备之一——Swing编程　460
24.2.1　与窗体相关的类——JFrame　461
24.2.2　与对话框相关的类——JOptionPane　466
24.2.3　与监听鼠标相关的类——MouseListener　469
24.2.4　确定鼠标坐标的类——MouseEvent　471
24.3　开发前的知识准备之二——显示图片的类ImageIO　472
24.4　开发前的知识准备之三——图形的绘制类Graphics　472
24.5　游戏界面开发　472
24.6　绘制棋子　474
24.7　保存棋局　474
24.8　判断游戏胜负　474
24.9　处理屏幕闪烁问题　475
24.10 实现各个功能按钮　475
24.11 完整代码　475
24.11.1　导入部分　475
24.11.2　属性设置　476
24.11.3　主类的构造函数　477
24.11.4　Paint方法　477
24.11.5　监控鼠标　479
24.11.6　判断胜负　483
24.11.7　判断有几个棋子已经连接起来　485
第25章　Java项目开发实战——人事管理　487
视频教学录像：1小时8分钟
通过前面章节的学习，相信读者已经对在Java中开发应用程序的过程比较熟悉了，本章将通过一个人事管理系统的设计，深入学习Java的实际应用项目开发。
25.1　系统概述　488
25.1.1　运行系统　488
25.1.2　系统的开发步骤　491
25.2　系统需求分析　493
25.3　综合描述　493
25.3.1　关键技术　493
25.3.2　名词解释　493
25.3.3　运行环境　493
25.4　概要设计　494
25.4.1　数据库设计　494
25.4.2　接口设计　494
25.4.3　代理　496
25.5　代码实现　497
25.5.1　Person.java　497
25.5.2　IPersonDAO.java　498
25.5.3　DatabaseConnection.java　499
25.5.4　IPersonDAOProxy.java　501
25.5.5　IPersonDAOImpl.java　503
25.5.6　DAOFactory.java　506
25.5.7　Menu.java　507
25.5.8　InputData.java　508
25.5.9　PersonOperate.java　509
25.5.10　Test.java　512
第5篇 王牌资源
王牌资源一览　514
王牌1　Java SE类库查询手册(光盘中)　514
索引　521
java.applet　525
接口　525
AppletContext接口　525
AppletStub接口　529
AudioClip接口　531
类　532
Applet类　532
java.lang　543
接口　543
Appendable接口　543
runnable接口　545
Cloneable接口　546
类　546
Boolean类　546
Byte类　547
Character类　555
Double类　601
Float类　616
Integer类　633
Long类　652
Math类　670
Number类　700
Object类　702
Package类　712
Process类　719
Runtime类　722
String类　737
System类　781
java.io　800
接口　800
Closeable接口　800
DataInput接口　800
DataOutput接口　809
Externalizable接口　817
FileFilter接口　818
FilenameFilter接口　818
Flushable接口　819
ObjectInput接口　820
ObjectInputValidation接口　822
ObjectOutput接口　823
ObjectStreamConstants接口　825
Serializable接口　833
类　835
BufferedInputStream类　835
BufferedOutputStream类　841
ByteArrayInputStream类　844
ByteArrayOutputStream类　850
DataInputStream类　855
File类　867
FileInputStream类　897
FileOutputStream类　904
FilterInputStream类　910
FilterOutputStream类　916
LineNumberInputStream类　920
PipedInputStream类　925
PipedOutputStream类　931
PrintStream类　934
java.awt　951
接口　951
ActiveEvent接口　951
Adjustable接口　952
Composite接口　956
CompositeContext接口　957
ItemSelectable接口　958
KeyEventDispatcher接口　959
KeyEventPostProcessor接口　960
LayoutManager接口　961
LayoutManager2接口　962
MenuContainer接口　964
Paint接口　964
PaintContext接口　965
PrintGraphics接口　967
Shape接口　967
Stroke接口　973
Transparency接口　974
类　976
AlphaComposite类　976
BorderLayout类　990
Button类　1003
CheckboxMenuItem类　1010
Choice类　1018
Dialog类　1028
Dimension类　1045
Event类　1050
FileDialog类　1072
FlowLayout类　1079
Font类　1088
Frame类　1125
GridBagLayout类　1144
GridLayout类　1161
Label类　1168
List类　1173
Menu类　1194
Panel类　1201
Point类　1203
Polygon类　1208
Rectangle类　1220
Scrollbar类　1240
TextArea类　1259
TextComponent类　1271
TextField类　1283
Toolkit类　1295
Window类　1336
王牌2　学习成果检测——本书【练一练】答案(光盘中)　1376
王牌3　Eclipse常用快捷键(光盘中)　1387
A　窗口类快捷键　1387
B　文本编辑类快捷键　1396
C　Java源代码编辑类快捷键　1397
D　调试类快捷键　1398
E　对话框及窗口类快捷键　1399
王牌4　Eclipse提示与技巧(光盘中)　1401
王牌5　Java程序员职业规划(光盘中)　1412
王牌6　Java程序员面试技巧(光盘中)　1414
王牌7　Java常见面试题(光盘中)　1416
王牌8　扫雷英雄榜——Java常见错误及解决方案(光盘中)　1433
王牌9　优秀程序员之路——Java开发经验及技巧大汇总(光盘中)　1444
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java从入门到精通
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring实战（第4版）
第1部分　Spring的核心
第1章　Spring之旅　3
1.1　简化Java开发　4
1.1.1　激发POJO的潜能　5
1.1.2　依赖注入　5
1.1.3　应用切面　11
1.1.4　使用模板消除样板式代码　16
1.2　容纳你的Bean　18
1.2.1　使用应用上下文　19
1.2.2　bean的生命周期　20
1.3　俯瞰Spring风景线　21
1.3.1　Spring模块　22
1.3.2　Spring Portfolio　24
1.4　Spring的新功能　27
1.4.1　Spring 3.1新特性　27
1.4.2　Spring 3.2新特性　28
1.4.3　Spring 4.0新特性　30
1.5　小结　30
第2章　装配Bean　33
2.1　Spring配置的可选方案　34
2.2　自动化装配bean　35
2.2.1　创建可被发现的bean　35
2.2.2　为组件扫描的bean命名　38
2.2.3　设置组件扫描的基础包　39
2.2.4　通过为bean添加注解实现自动装配　40
2.2.5　验证自动装配　42
2.3　通过Java代码装配
bean　44
2.3.1　创建配置类　44
2.3.2　声明简单的bean　45
2.3.3　借助JavaConfig实现注入　46
2.4　通过XML装配bean　48
2.4.1　创建XML配置规范　48
2.4.2　声明一个简单的
[bean]　49
2.4.3　借助构造器注入初始化bean　50
2.4.4　设置属性　56
2.5　导入和混合配置　61
2.5.1　在JavaConfig中引用XML配置　61
2.5.2　在XML配置中引用JavaConfig　63
2.6　小结　65
第3章　高级装配　67
3.1　环境与profile　67
3.1.1　配置profile bean　69
3.1.2　激活profile　73
3.2　条件化的bean　75
3.3　处理自动装配的歧义性　78
3.3.1　标示首选的bean　79
3.3.2　限定自动装配的bean　80
3.4　bean的作用域　84
3.4.1　使用会话和请求作用域　86
3.4.2　在XML中声明作用域代理　88
3.5　运行时值注入　88
3.5.1　注入外部的值　89
3.5.2　使用Spring表达式语言进行装配　93
3.6　小结　99
第4章　面向切面的Spring　101
4.1　什么是面向切面编程？　102
4.1.1　定义AOP术语　103
4.1.2　Spring对AOP的支持　105
4.2　通过切点来选择连接点　107
4.2.1　编写切点　108
4.2.2　在切点中选择bean　109
4.3　使用注解创建切面　109
4.3.1　定义切面　110
4.3.2　创建环绕通知　114
4.3.3　处理通知中的参数　115
4.3.4　通过注解引入新功能　118
4.4　在XML中声明切面　120
4.4.1　声明前置和后置通知　122
4.4.2　声明环绕通知　124
4.4.3　为通知传递参数　125
4.4.4　通过切面引入新的功能　127
4.5　注入AspectJ切面　128
4.5　小结　131
第２部分　Web中的Spring
第5章　构建Spring Web应用程序　135
5.1　Spring MVC起步　136
5.1.1　跟踪Spring MVC的请求　136
5.1.2　搭建Spring MVC　138
5.1.3　Spittr应用简介　142
5.2　编写基本的控制器　143
5.2.1　测试控制器　145
5.2.2　定义类级别的请求处理　146
5.2.3　传递模型数据到视图中　147
5.3　接受请求的输入　153
5.3.1　处理查询参数　153
5.3.2　通过路径参数接受输入　155
5.4　处理表单　157
5.4.1　编写处理表单的控制器　160
5.4.2　校验表单　163
5.5　小结　166
第6章　渲染Web视图　167
6.1　理解视图解析　167
6.2　创建JSP视图　170
6.2.1　配置适用于JSP的视图解析器　170
6.2.2　使用Spring的JSP库　172
6.3　使用Apache Tiles视图定义布局　184
6.3.1　配置Tiles视图解析器　185
6.4　使用Thymeleaf　190
6.4.1　配置Thymeleaf视图解析器　190
6.4.2　定义Thymeleaf模板　192
6.5　小结　196
第7章　Spring MVC的高级技术　197
7.1　Spring MVC配置的替代方案　198
7.1.1　自定义DispatcherServlet配置　198
7.1.2　添加其他的Servlet和Filter　199
7.1.3　在web.xml中声明DispatcherServlet　201
7.2　处理multipart形式的数据　204
7.2.1　配置multipart解析器　205
7.2.2　处理multipart请求　208
7.3　处理异常　212
7.3.1　将异常映射为HTTP状态码　213
7.3.2　编写异常处理的方法　214
7.4　为控制器添加通知　216
7.5　跨重定向请求传递数据　217
7.5.1　通过URL模板进行重定向　218
7.5.2　使用flash属性　219
7.6　小结　221
第8章　使用Spring WebFlow　223
8.1　在Spring中配置Web　Flow　224
8.1.1　装配流程执行器　224
8.1.2　配置流程注册表　224
8.1.3　处理流程请求　225
8.2　流程的组件　226
8.2.1　状态　226
8.2.2　转移　230
8.2.3　流程数据　231
8.3　组合起来：披萨流程　232
8.3.1　定义基本流程　233
8.3.2　收集顾客信息　236
8.3.2　构建订单　242
8.3.2　支付　244
8.4　保护Web流程　246
8.5　小结　246
第9章　保护Web应用　249
9.1　Spring Security简介　250
9.1.1　理解Spring Security的模块　250
9.1.2　过滤Web请求　251
9.1.3　编写简单的安全性配置　252
9.2　选择查询用户详细信息的服务　255
9.2.1使用基于内存的用户存储　255
9.2.2　基于数据库表进行认证　257
9.2.3　基于LDAP进行认证　259
9.2.4　配置自定义的用户服务　263
9.3　拦截请求　265
9.3.1　使用Spring表达式进行安全保护　267
9.3.2　强制通道的安全性　269
9.3.3　防止跨站请求伪造　270
9.4　认证用户　271
9.4.1　添加自定义的登录页　272
9.4.2　启用HTTP Basic认证　274
9.4.3　启用Remember-me功能　274
9.4.4　退出　275
9.5　保护视图　276
9.5.1　使用Spring Security的JSP标签库　276
9.5.2　使用Thymeleaf的SpringSecurity方言　280
9.6　小结　281
第3部分　后端中的Spring
第10章　通过Spring和JDBC征服数据库　285
10.1　Spring的数据访问哲学　286
10.1.1　了解Spring的数据访问异常体系　287
10.1.2　数据访问模板化　289
10.2　配置数据源　291
10.2.1　使用JNDI数据源　292
10.2.2　使用数据源连接池　292
10.2.3　基于JDBC驱动的数据源　294
10.2.4　使用嵌入式的数据源　295
10.2.5　使用profile选择数据源　296
10.3　在Spring中使用
JDBC　298
10.3.1　应对失控的JDBC代码　299
10.3.2　使用JDBC模板　302
10.4　小结　307
第11章　使用对象-关系映射持久化数据　309
11.1　在Spring中集成Hibernate　310
11.1.1　声明Hibernate的Session工厂　311
11.1.2　构建不依赖于Spring的Hibernate代码　313
11.2　Spring与Java持久化API　315
11.2.1　配置实体管理器工厂　315
11.2.2　编写基于JPA的Repository　320
11.3　借助Spring Data实现自动化的JPA　Repository　322
11.3.1　定义查询方法　325
11.3.2　声明自定义查询　328
11.3.3　混合自定义的功能　329
11.4　小结　330
第12章　使用NoSQL数据库　333
12.1　使用MongoDB持久化文档数据　334
12.1.1　启用MongoDB　335
12.1.2　为模型添加注解，实现MongoDB持久化　338
12.1.3　使用MongoTemplate访问MongoDB　341
12.1.4　编写MongoDBRepository　342
12.2　使用Neo4j操作图数据　347
12.2.1　配置Spring DataNeo4j　347
12.2.2　使用注解标注图实体　350
12.2.3　使用Neo4jTemplate　353
12.2.4　创建自动化的Neo4j　Repository　354
12.3　使用Redis操作key-value数据　359
12.3.1　连接到Redis　359
12.3.2　使用RedisTemplate　360
12.3.3　使用key和value的序列化器　364
12.4　小结　365
第13章　缓存数据　367
13.1　启用对缓存的支持　368
13.1.1　配置缓存管理器　369
13.2　为方法添加注解以支持缓存　373
13.2.1　填充缓存　374
13.2.2　移除缓存条目　378
13.3　使用XML声明缓存　379
13.4　小结　383
第14章　保护方法应用　385
14.1　使用注解保护方法　386
14.1.1　使用@Secured注解限制方法调用　386
14.1.2　在Spring Security中使用
JSR-250的@RolesAllowed注解　387
14.2　使用表达式实现方法级别的安全性　388
14.2.1　表述方法访问规则　389
14.2.2　过滤方法的输入和输出　391
14.3　小结　395
第4部分　Spring集成
第15章　使用远程服务　399
15.1　Spring远程调用概览　400
15.2　使用RMI　402
15.2.1　导出RMI服务　403
15.2.2　装配RMI服务　405
15.3　使用Hessian和Burlap发布远程服务　407
15.3.1　使用Hessian和Burlap导出bean的功能　408
15.3.2　访问Hessian/Burlap服务　411
15.4　使用Spring的HttpInvoker　413
15.4.1　将bean导出为HTTP服务　413
15.4.2　通过HTTP访问服务　414
15.5　发布和使用Web服务　416
15.5.1　创建基于Spring的JAX-WS端点　416
15.5.2　在客户端代理JAX-WS服务　419
15.6　小结　421
第16章　使用Spring MVC创建REST API　423
16.1　了解REST　424
16.1.1　REST的基础知识　424
16.1.2　Spring是如何支持REST的　425
16.2　创建第一个REST端点　426
16.2.1　协商资源表述　428
16.2.2　使用HTTP信息转换器　433
16.3　提供资源之外的其他内容　438
16.3.1　发送错误信息到客户端　438
16.3.2　在响应中设置头部信息　443
16.4　编写REST客户端　445
16.4.1　了解RestTemplate的操作　446
16.4.2　GET资源　447
16.4.3　检索资源　448
16.4.4　抽取响应的元数据　449
16.4.5　PUT资源　450
16.4.6　DELETE资源　451
16.4.7　POST资源数据　452
16.4.8　在POST请求中获取响应对象　452
16.4.9　在POST请求后获取资源位置　453
16.4.10　交换资源　454
16.5　小结　456
第17章　Spring消息　457
17.1　异步消息简介　458
17.1.1　发送消息　459
17.1.2　评估异步消息的优点　461
17.2　使用JMS发送消息　463
17.2.1　在Spring中搭建消息代理　463
17.2.2　使用Spring的JMS模板　465
17.2.3　创建消息驱动的POJO　474
17.2.4　使用基于消息的RPC　477
17.3　使用AMQP实现消息功能　479
17.3.1　AMQP简介　480
17.3.2　配置Spring支持AMQP消息　481
17.3.3　使用RabbitTemplate发送消息　484
17.3.4　接收AMQP消息　486
17.4　小结　489
第18章　使用WebSocket和STOMP实现消息功能　491
18.1　使用Spring的低层级WebSocket　API　492
18.2　应对不支持WebSocket的场景　497
18.3　使用STOMP消息　500
18.3.1　启用STOMP消息功能　501
18.3.2　处理来自客户端的STOMP消息　504
18.3.3　发送消息到客户端　507
18.4　为目标用户发送消息　511
18.4.1　在控制器中处理用户的消息　512
18.4.2　为指定用户发送消息　514
18.5　处理消息异常　515
18.6　小结　516
第19章　使用Spring发送Email　517
19.1　配置Spring发送邮件　518
19.1.1　配置邮件发送器　518
19.1.2　装配和使用邮件发送器　520
19.2　构建丰富内容的Email消息　521
19.2.1　添加附件　521
19.2.2　发送富文本内容的Email　522
19.3　使用模板生成Email　524
19.3.1　使用Velocity构建Email消息　524
19.3.2　使用Thymeleaf构建Email消息　526
19.4　小结　528
第20章　使用JMX管理Spring　Bean　529
20.1　将Spring bean导出为MBean　530
20.1.1　通过名称暴露方法　533
20.1.2　使用接口定义MBean的操作和属性　535
20.1.3　使用注解驱动的MBean　536
20.1.4　处理MBean冲突　538
20.2　远程MBean　539
20.2.1　暴露远程MBean　539
20.2.2　访问远程MBean　540
20.2.3　代理MBean　542
20.3　处理通知　543
20.3.1　监听通知　544
20.4　小结　545
第21章　借助Spring Boot简化Spring开发　547
21.1　Spring Boot简介　548
21.1.1　添加Starter依赖　548
21.1.2　自动配置　552
21.1.3　Spring Boot CLI　552
21.1.4　Actuator　553
21.2　使用Spring Boot构建应用　553
21.2.1　处理请求　556
21.2.2　创建视图　558
21.2.3　添加静态内容　560
21.2.4　持久化数据　561
21.2.5　尝试运行　563
21.3　组合使用Groovy与SpringBoot　CLI　566
21.3.1　编写Groovy控制器　566
21.3.2　使用Groovy Repository实现数据持久化　569
21.3.3　运行Spring Boot CLI　570
21.4　通过Actuator获取了解应用内部状况　571
21.5　小结　574
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring实战（第4版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 语言导学
前言
第1章 起步
第2章 面向对象的编程概念
第3章 语言基础
第4章 对象基础和简单数据对象
第5章 类和继承
第6章 接口和包
第7章 使用异常处理错误
第8章 线程：同时执行多个任务
第9章 I/O：读和写
第10章 Swing用户界面
附录A 常见问题及其解决方案
附录B 用于Internet的applet
附录C 集合
附录D 被废弃的线程方法
附录E 参考信息
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 语言导学
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻量级Java EE企业应用实战
第1章  Java EE应用和开发环境	1
1.1  Java EE应用概述	2
1.1.1  Java EE应用的分层模型	2
1.1.2  Java EE应用的组件	3
1.1.3  Java EE应用的结构和优势	4
1.1.4  常用的Java EE服务器	4
1.2  轻量级Java EE应用相关技术	5
1.2.1  JSP、Servlet 3.0和JavaBean及替代技术	5
1.2.2  Struts 2.2及替代技术	5
1.2.3  Hibernate 3.6及替代技术	6
1.2.4  Spring 3.0及替代技术	6
1.3  Tomcat的下载和安装	7
1.3.1  安装Tomcat服务器	8
1.3.2  配置Tomcat的服务端口	9
1.3.3  进入控制台	10
1.3.4  部署Web应用	12
1.3.5  配置Tomcat的数据源	13
1.4  Eclipse的安装和使用	15
1.4.1  Eclipse的下载和安装	15
1.4.2  在线安装Eclipse插件	15
1.4.3  从本地压缩包安装插件	17
1.4.4  手动安装Eclipse插件	17
1.4.5  使用Eclipse开发Java EE应用	18
1.4.6  导入Eclipse项目	21
1.4.7  导入非Eclipse项目	22
1.5  Ant的安装和使用	23
1.5.1  Ant的下载和安装	23
1.5.2  使用Ant工具	24
1.5.3  定义生成文件	25
1.5.4  Ant的任务（task）	29
1.6  使用CVS进行协作开发	31
1.6.1  安装CVS服务器	32
1.6.2  配置CVS资源库	34
1.6.3  安装CVS客户端	35
1.6.4  发布项目到服务器	35
1.6.5  从服务器下载项目	37
1.6.6  同步（Update）本地文件	38
1.6.7  提交（Commit）修改	39
1.6.8  添加文件和目录	39
1.6.9  删除文件和目录	40
1.6.10  查看文件的版本变革	41
1.6.11  提取文件以前版本的内容	42
1.6.12  从以前版本重新开始	42
1.6.13  创建标签	43
1.6.14  创建分支	43
1.6.15  沿着分支开发	44
1.6.16  使用Eclipse作为CVS客户端	44
1.7  本章小结	46
第2章  JSP/Servlet及相关技术详解	47
2.1  Web应用和web.xml文件	48
2.1.1  构建Web应用	48
2.1.2  配置描述符web.xml	49
2.2  JSP的基本原理	50
2.3  JSP注释	54
2.4  JSP声明	54
2.5  输出JSP表达式	56
2.6  JSP脚本	56
2.7  JSP的3个编译指令	59
2.7.1  page指令	59
2.7.2  include指令	63
2.8  JSP的7个动作指令	63
2.8.1  forward指令	64
2.8.2  include指令	66
2.8.3  useBean、setProperty、getProperty指令	67
2.8.4  plugin指令	70
2.8.5  param指令	70
2.9  JSP脚本中的9个内置对象	70
2.9.1  application对象	72
2.9.2  config对象	77
2.9.3  exception对象	79
2.9.4  out对象	81
2.9.5  pageContext对象	82
2.9.6  request对象	84
2.9.7  response对象	91
2.9.8  session对象	95
2.10  Servlet介绍	97
2.10.1  Servlet的开发	97
2.10.2  Servlet的配置	99
2.10.3  JSP/Servlet的生命周期	101
2.10.4  load-on-startup Servlet	101
2.10.5  访问Servlet的配置参数	102
2.10.6  使用Servlet作为控制器	104
2.11  JSP 2的自定义标签	108
2.11.1  开发自定义标签类	109
2.11.2  建立TLD文件	109
2.11.3  使用标签库	110
2.11.4  带属性的标签	111
2.11.5  带标签体的标签	115
2.11.6  以页面片段作为属性的标签	117
2.11.7  动态属性的标签	118
2.12  Filter介绍	120
2.12.1  创建Filter类	120
2.12.2  配置Filter	121
2.12.3  使用URL Rewrite实现网站伪静态	125
2.13  Listener介绍	126
2.13.1  实现Listener类	127
2.13.2  配置Listener	128
2.13.3  使用ServletContextAttribute-Listener	129
2.13.4  使用ServletRequestListener和ServletRequestAttributeListener	130
2.13.5  使用HttpSessionListener和HttpSessionAttributeListener	131
2.14  JSP 2特性	136
2.14.1  配置JSP属性	136
2.14.2  表达式语言	138
2.14.3  Tag File支持	146
2.15  Servlet 3.0新特性	148
2.15.1  Servlet 3.0的Annotation	148
2.15.2  Servlet 3.0的Web模块支持	149
2.15.3  Servlet 3.0提供的异步处理	151
2.15.4  改进的Servlet API	154
2.16  本章小结	156
第3章  Struts 2的基本用法	157
3.1  MVC思想概述	158
3.1.1  传统Model 1和Model 2	158
3.1.2  MVC思想及其优势	159
3.2  Struts 2的下载和安装	160
3.2.1  为Web应用增加Struts 2支持	160
3.2.2  在Eclipse中使用Struts 2	161
3.2.3  增加登录处理	162
3.3  Struts 2的流程	165
3.3.1  Struts 2应用的开发步骤	165
3.3.2  Struts 2的流程	166
3.4  Struts 2的常规配置	167
3.4.1  常量配置	167
3.4.2  包含其他配置文件	173
3.5  实现Action	174
3.5.1  Action接口和ActionSupport基类	175
3.5.2  Action访问Servlet API	177
3.5.3  Action直接访问Servlet API	179
3.5.4  使用ServletActionContext访问Servlet API	181
3.6  配置Action	182
3.6.1  包和命名空间	182
3.6.2  Action的基本配置	185
3.6.3  使用Action的动态方法调用	186
3.6.4  指定method属性及使用通配符	188
3.6.5  配置默认Action	194
3.6.6  配置Action的默认处理类	194
3.7  配置处理结果	195
3.7.1  理解处理结果	195
3.7.2  配置结果	195
3.7.3  Struts 2支持的结果类型	197
3.7.4  plainText结果类型	198
3.7.5  redirect结果类型	200
3.7.6  redirectAction结果类型	201
3.7.7  动态结果	202
3.7.8  Action属性值决定物理视图资源	202
3.7.9  全局结果	204
3.7.10  使用PreResultListener	205
3.8  配置Struts 2的异常处理	206
3.8.1  Struts 2的异常处理机制	207
3.8.2  声明式异常捕捉	208
3.8.3  输出异常信息	210
3.9  Convention插件与“约定”支持	211
3.9.1  Action的搜索和映射约定	211
3.9.2  按约定映射Result	214
3.9.3  Action链的约定	216
3.9.4  自动重加载映射	218
3.9.5  Convention插件的相关常量	218
3.9.6  Convention插件相关Annotation	219
3.10  使用Struts 2的国际化	219
3.10.1  Struts 2中加载全局资源文件	219
3.10.2  访问国际化消息	220
3.10.3  输出带占位符的国际化消息	222
3.10.4  加载资源文件的方式	224
3.10.5  加载资源文件的顺序	228
3.11  使用Struts 2的标签库	228
3.11.1  Struts 2标签库概述	228
3.11.2  使用Struts 2标签	229
3.11.3  Struts 2的OGNL表达式语言	230
3.11.4  OGNL中的集合操作	232
3.11.5  访问静态成员	233
3.11.6  Lambda（）表达式	234
3.11.7  控制标签	234
3.11.8  数据标签	244
3.11.9  主题和模板	254
3.11.10  自定义主题	256
3.11.11  表单标签	257
3.11.12  非表单标签	270
3.12  本章小结	273
第4章  深入使用Struts 2	274
4.1  详解Struts 2的类型转换	275
4.1.1  Struts 2内建的类型转换器	276
4.1.2  基于OGNL的类型转换	276
4.2.3  指定集合元素的类型	279
4.1.4  自定义类型转换器	280
4.1.5  注册类型转换器	283
4.1.6  基于Struts 2的自定义类型转换器	284
4.1.7  处理Set集合	285
4.1.8  类型转换中的错误处理	288
4.2  使用Struts 2的输入校验	293
4.2.1  编写校验规则文件	294
4.2.2  国际化提示信息	296
4.2.3  使用客户端校验	298
4.2.4  字段校验器配置风格	300
4.2.5  非字段校验器配置风格	301
4.2.6  短路校验器	302
4.2.7  校验文件的搜索规则	304
4.2.8  校验顺序和短路	305
4.2.9  内建校验器	306
4.2.10  基于Annotation的输入校验	316
4.2.11  手动完成输入校验	318
4.3  使用Struts 2控制文件上传	322
4.3.1  Struts 2的文件上传	322
4.3.2  实现文件上传的Action	322
4.3.3  配置文件上传的Action	325
4.3.4  手动实现文件过滤	326
4.3.5  拦截器实现文件过滤	328
4.3.6  输出错误提示	329
4.3.7  文件上传的常量配置	330
4.4  使用Struts 2控制文件下载	330
4.4.1  实现文件下载的Action	330
4.4.2  配置Action	332
4.4.3  下载前的授权控制	332
4.5  详解Struts 2的拦截器机制	334
4.5.1  拦截器在Struts 2中的作用	334
4.5.2  Struts 2内建的拦截器	334
4.5.3  配置拦截器	336
4.5.4  使用拦截器	338
4.5.5  配置默认拦截器	338
4.5.6  实现拦截器类	340
4.5.7  使用拦截器	342
4.5.8  拦截方法的拦截器	343
4.5.9  拦截器的执行顺序	345
4.5.10  拦截结果的监听器	347
4.5.11  覆盖拦截器栈里特定拦截器的参数	348
4.5.12  使用拦截器完成权限控制	349
4.6  使用Struts 2的Ajax支持	351
4.6.1  使用stream类型的Result实现Ajax	352
4.6.2  JSON的基本知识	354
4.6.3  实现Action逻辑	356
4.6.4  JSON插件与json类型的Result	357
4.6.5  实现JSP页面	359
4.7  本章小结	361
第5章  Hibernate的基本用法	362
5.1  ORM和Hibernate	363
5.1.1  对象/关系数据库映射（ORM）	363
5.1.2  基本映射方式	364
5.1.3  流行的ORM框架简介	365
5.1.4  Hibernate概述	366
5.2  Hibernate入门	366
5.2.1  Hibernate下载和安装	366
5.2.2  Hibernate的数据库操作	367
5.2.3  在Eclipse中使用Hibernate	371
5.3  Hibernate的体系结构	376
5.4  深入Hibernate的配置文件	377
5.4.1  创建Configuration对象	377
5.4.2  hibernate.properties文件与hibernate.cfg.xml文件	380
5.4.3  JDBC连接属性	380
5.4.4  数据库方言	381
5.4.5  JNDI数据源的连接属性	382
5.4.6  Hibernate事务属性	382
5.4.7  二级缓存相关属性	383
5.4.8  外连接抓取属性	383
5.4.9  其他常用的配置属性	383
5.5  深入理解持久化对象	384
5.5.1  持久化类的要求	384
5.5.2  持久化对象的状态	385
5.5.3  改变持久化对象状态的方法	386
5.6  深入Hibernate的映射文件	389
5.6.1  映射文件结构	389
5.6.2  映射主键	392
5.6.3  映射普通属性	393
5.6.4  映射集合属性	398
5.6.5  集合属性的性能分析	407
5.6.6  有序集合映射	409
5.6.7  映射数据库对象	411
5.7  映射组件属性	414
5.7.1  组件属性为集合	416
5.7.2  集合属性的元素为组件	418
5.7.3  组件作为Map的索引	420
5.7.4  组件作为复合主键	422
5.7.5  多列作为联合主键	425
5.8  使用JPA Annotation标注实体	426
5.8.1  增加JPA Annotation支持	426
5.8.2  Annotation？还是XML映射文件	429
5.9  本章小结	429
第6章  深入使用Hibernate	430
6.1  Hibernate的关联映射	431
6.1.1  单向N－1关联	431
6.1.2  单向1－1关联	436
6.1.3  单向1－N关联	439
6.1.4  单向N－N关联	443
6.1.5  双向1－N关联	443
6.1.6  双向N－N关联	448
6.1.7  双向1－1关联	450
6.1.8  组件属性包含的关联实体	453
6.1.9  基于复合主键的关联关系	456
6.1.10  复合主键的成员属性为关联实体	458
6.1.11  持久化的传播性	461
6.2  继承映射	462
6.2.1  采用subclass元素的继承映射	466
6.2.2  采用joined-subclass元素的继承映射	467
6.2.3  采用union-subclass元素的继承映射	470
6.3  Hibernate的批量处理	472
6.3.1  批量插入	473
6.3.2  批量更新	474
6.3.3  DML风格的批量更新/删除	474
6.4  使用HQL查询	476
6.4.1  HQL查询	476
6.4.2  HQL查询的from子句	478
6.4.3  关联和连接	478
6.4.4  HQL查询的select子句	481
6.4.5  HQL查询的聚集函数	482
6.4.6  多态查询	483
6.4.7  HQL查询的where子句	483
6.4.8  表达式	484
6.4.9  order by子句	486
6.4.10  group by子句	486
6.4.11  子查询	487
6.4.12  命名查询	488
6.5  条件查询	488
6.5.1  关联和动态关联	491
6.5.2  投影、聚合和分组	492
6.5.3  离线查询和子查询	495
6.6  SQL查询	496
6.6.1  标量查询	496
6.6.2  实体查询	498
6.6.3  处理关联和继承	500
6.6.4  命名SQL查询	501
6.6.5  调用存储过程	502
6.6.6  使用定制SQL	503
6.7  数据过滤	505
6.8  事务控制	508
6.8.1  事务的概念	508
6.8.2  Session与事务	509
6.8.3  上下文相关的Session	511
6.9  二级缓存和查询缓存	511
6.9.1  开启二级缓存	512
6.9.2  管理缓存和统计缓存	515
6.9.3  使用查询缓存	516
6.10  事件机制	518
6.10.1  拦截器	519
6.10.2  事件系统	521
6.11  本章小结	525
第7章  Spring的基本用法	526
7.1  Spring简介和Spring 3.0的变化	527
7.1.1  Spring简介	527
7.1.2  Spring 3.0的变化	528
7.2  Spring的下载和安装	528
7.2.1  在Java SE应用中使用Spring	528
7.2.2  在Web应用中使用Spring	529
7.2.3  在Eclipse中开发Spring应用	530
7.3  Spring的核心机制：依赖注入	533
7.3.1  理解依赖注入	533
7.3.2  设值注入	534
7.3.3  构造注入	538
7.3.4  两种注入方式的对比	539
7.4  使用Spring容器	539
7.4.1  Spring容器	540
7.4.2  使用ApplicationContext	541
7.4.3  ApplicationContext的国际化支持	542
7.4.4  ApplicationContext的事件机制	544
7.4.5  让Bean获取Spring容器	546
7.5  Spring容器中的Bean	548
7.5.1  Bean的基本定义	548
7.5.2  容器中Bean的作用域	551
7.5.3  配置依赖	553
7.5.4  设置普通属性值	555
7.5.5  配置合作者Bean	557
7.5.6  使用自动装配注入合作者Bean	557
7.5.7  注入嵌套Bean	560
7.5.8  注入集合值	561
7.5.9  组合属性名称	565
7.5.10  Spring的Bean和JavaBean	566
7.6  Spring 3.0提供的Java配置管理	567
7.7  Bean实例的创建方式及依赖配置	570
7.7.1  使用构造器创建Bean实例	570
7.7.2  使用静态工厂方法创建Bean	572
7.7.3  调用实例工厂方法创建Bean	575
7.8  深入理解容器中的Bean	577
7.8.1  使用抽象Bean	577
7.8.2  使用子Bean	578
7.8.3  Bean继承与Java继承的区别	579
7.8.4  容器中的工厂Bean	580
7.8.5  获得Bean本身的id	582
7.8.6  强制初始化Bean	583
7.9  容器中Bean的生命周期	583
7.9.1  依赖关系注入之后的行为	584
7.9.2  Bean销毁之前的行为	585
7.9.3  协调作用域不同步的Bean	588
7.10  深入理解依赖关系配置	591
7.10.1  注入其他Bean的属性值	592
7.10.2  注入其他Bean的Field值	594
7.10.3  注入其他Bean的方法返回值	595
7.11  基于XML Schema的简化配置方式	598
7.11.1  使用p名称空间配置属性	599
7.11.2  使用util Schema	600
7.12  Spring 3.0提供的表达式语言（SpEL）	602
7.12.1  使用Expression接口进行表达式求值	603
7.12.2  Bean定义中的表达式语言支持	604
7.12.3  SpEL语法详述	606
7.13  本章小结	611
第8章  深入使用Spring	612
8.1  两种后处理器	613
8.1.1  Bean后处理器	613
8.1.2  Bean后处理器的用处	617
8.1.3  容器后处理器	617
8.1.4  属性占位符配置器	619
8.1.5  重写占位符配置器	620
8.2  Spring的“零配置”支持	621
8.2.1  搜索Bean类	621
8.2.2  指定Bean的作用域	624
8.2.3  使用@Resource配置依赖	625
8.2.4  使用@PostConstruct和@PreDestroy定制生命周期行为	626
8.2.5  Spring 3.0新增的Annotation	626
8.2.6  自动装配和精确装配	627
8.3  资源访问	629
8.3.1  Resource实现类	630
8.3.2  ResourceLoader接口和ResourceLoaderAware接口	635
8.3.3  使用Resource作为属性	638
8.3.4  在ApplicationContext中使用资源	639
8.4  Spring的AOP	643
8.4.1  为什么需要AOP	643
8.4.2  使用AspectJ实现AOP	644
8.4.3  AOP的基本概念	649
8.4.4  Spring的AOP支持	650
8.4.5  基于Annotation的“零配置”方式	651
8.4.6  基于XML配置文件的管理方式	666
8.5  Spring的事务	672
8.5.1  Spring支持的事务策略	673
8.5.2  使用TransactionProxyFactoryBean创建事务代理	678
8.5.3  Spring 2.X的事务配置策略	681
8.5.4  使用@Transactional	685
8.6  Spring整合Struts 2	686
8.6.1  启动Spring容器	686
8.6.2  MVC框架与Spring整合的思考	688
8.6.3  让Spring管理控制器	689
8.6.4  使用自动装配	692
8.7  Spring整合Hibernate	695
8.7.1  Spring提供的DAO支持	695
8.7.2  管理Hibernate的SessionFactory	696
8.7.3  使用HibernateTemplate	697
8.7.4  使用HibernateCallback	701
8.7.5  实现DAO组件	703
8.7.6  使用IoC容器组装各种组件	705
8.7.7  使用声明式事务	707
8.8  Spring整合JPA	708
8.8.1  管理EntityManager	709
8.8.2  使用JpaTemplate	711
8.8.3  使用JpaCallback	713
8.8.4  借助JpaDaoSupport实现DAO组件	714
8.8.5  使用声明式事务	714
8.9  本章小结	715
第9章  企业应用开发的思考和策略	716
9.1  企业应用开发面临的挑战	717
9.1.1  可扩展性、可伸缩性	717
9.1.2  快捷、可控的开发	718
9.1.3  稳定性、高效性	719
9.1.4  花费最小化，利益最大化	719
9.2  如何面对挑战	719
9.2.1  使用建模工具	719
9.2.2  利用优秀的框架	720
9.2.3  选择性地扩展	722
9.2.4  使用代码生成器	722
9.3  常见设计模式精讲	722
9.3.1  单例模式	723
9.3.2  简单工厂	724
9.3.3  工厂方法和抽象工厂	730
9.3.4  代理模式	733
9.3.5  命令模式	739
9.3.6  策略模式	741
9.3.7  门面模式	743
9.3.8  桥接模式	746
9.3.9  观察者模式	750
9.4  常见的架构设计策略	753
9.4.1  贫血模型	753
9.4.2  领域对象模型	756
9.4.3  合并业务逻辑对象与DAO对象	758
9.4.4  合并业务逻辑对象和Domain Object	759
9.4.5  抛弃业务逻辑层	761
9.5  本章小结	762
第10章  简单工作流系统	763
10.1  项目背景及系统结构	764
10.1.1  应用背景	764
10.1.2  系统功能介绍	764
10.1.3  相关技术介绍	765
10.1.4  系统结构	766
10.1.5  系统的功能模块	766
10.2  Hibernate持久层	767
10.2.1  设计持久化实体	767
10.2.2  创建持久化实体类	768
10.2.3  映射持久化实体	772
10.3  实现DAO层	777
10.3.1  DAO组件的定义	778
10.3.2  实现DAO组件	783
10.3.3  部署DAO层	787
10.4  实现Service层	789
10.4.1  业务逻辑组件的设计	789
10.4.2  实现业务逻辑组件	789
10.4.3  事务管理	795
10.4.4  部署业务逻辑组件	795
10.5  实现任务的自动调度	797
10.5.1  使用Quartz	797
10.5.2  在Spring中使用Quartz	802
10.6  实现系统Web层	804
10.6.1  Struts 2和Spring的整合	804
10.6.2  控制器的处理顺序	805
10.6.3  员工登录	806
10.6.4  进入打卡	808
10.6.5  处理打卡	810
10.6.6  进入申请	811
10.6.7  提交申请	812
10.6.8  使用拦截器完成权限管理	814
10.7  本章小结	816
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻量级Java EE企业应用实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计教程
第1章绪论
1.1历史简介
1.2特点
1.3开发环境的建立
1.4Java程序及其执行过程
1.4.1开发Java程序的工作流程
1.4.2Java程序的工作原理
1.5本章小结
习题
第2章结构化程序设计
2.1标识符和关键字
2.2基本数据类型、直接量和变量
2.2.1基本数据类型
2.2.2直接量
2.2.3变量
2.3运算符
2.3.1算术运算符
2.3.2关系运算符
2.3.3布尔逻辑运算符
2.3.4位运算符
2.3.5赋值类运算符
2.3.6条件运算符
2.3.7其他运算符
2.4控制结构
2.4.1if语句和if-else语句
2.4.2switch语句
2.4.3for语句
2.4.4while语句
2.4.5do—while语句
2.4.6break语句
2.4.7continue语句
2.5结构化程序设计
2.6本章小结
习题
第3章面向对象程序设计
3.1类、域、方法和实例对象
3.2继承性
3.3多态性
3.3.1静态多态性
3.3.2动态多态性
3.4包(package)
3.5封装性
3.6修饰词abstract、static和final
3.6.1修饰词abstract
3.6.2修饰词static
3.6.3修饰词final
3.7接口
3.8内部类
3.9变量作用域范围与参数传递方式
3.9.1变量作用域范围
3.9.2方法调用的值传递方式
3.10面向对象程序设计基本思想
3.11本章小结
习题
第4章数组、字符串、向量与哈希表
4.1数组
4.1.1一维数组
4.1.2多维数组
4.2字符串和字符串缓冲区
4.2.1String
4.2.2StringBuffer
4.3向量
4.4哈希表
……
第5章泛型、枚举与for语句的简化写法
第6章异常处理、递归和单体程序设计方法
第7章文件与数据流
第8章Swing图形用户界面程序设计
第9章小应用程序（Applet）
第10章编程规范和程序调试
第11章多线程程序设计
第12章网络程序设计
第13章多媒体与图形学程序设计
第14章数据库程序设计
附录一图的索引
附录二表的索引
附录三例程索引
附录四类和接口索引
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>像计算机科学家一样思考Java
第1章　程序之道
1.1　什么是编程语言
1.2　什么是程序
1.3　什么是调试
1.4　形式语言和自然语言
1.5　第一个程序
1.6　术语表
1.7　练习
第2章　变量和类型
2.1　更多打印
2.2　变量
2.3　赋值
2.4　打印变量
2.5　关键字
2.6　运算符
2.7　运算符优先级
2.8　字符串运算符
2.9　组合
2.10　术语表
2.11　练习
第3章　无返回值方法
3.1　浮点数
3.2　双精度型转整型
3.3　数学函数
3.4　组合
3.5　添加新方法
3.6　类和方法
3.7　为程序添加多个方法
3.8　形参和实参
3.9　栈帧图
3.10　多参数方法
3.11　有返回值的方法
3.12　术语表
3.13　练习
第4章　条件语句和递归
4.1　模运算符
4.2　条件执行
4.3　选择性执行
4.4　条件判断链
4.5　嵌套条件
4.6　返回语句
4.7　类型转换
4.8　递归
4.9　递归方法的栈帧图
4.10　术语表
4.11　练习
第5章　GridWorld(第一部分)
5.1　入门
5.2　BugRunner
5.3　练习
第6章　有返回值方法
6.1　返回值
6.2　程序开发
6.3　组合
6.4　重载
6.5　布尔表达式
6.6　逻辑运算符
6.7　布尔方法
6.8　更多递归
6.9　飞跃的信心
6.10　另一个例子
6.11　术语表
6.12　练习
第7章　迭代和循环
7.1　多次赋值
7.2　迭代
7.3　while语句
7.4　表格
7.5　二维表格
7.6　封装与泛化
7.7　方法
7.8　更多的封装
7.9　局部变量
7.10　更多的泛化
7.11　术语表
7.12　练习
第8章　字符串
8.1　调用对象上的方法
8.2　字符串长度
8.3　遍历
8.4　运行时错误
8.5　阅读文档
8.6　indexOf方法
8.7　循环和计数
8.8　自增和自减运算符
8.9　字符串是不可变的
8.10　字符串是不可比较的
8.11　术语表
8.12　练习
第9章　可变对象
9.1　Point对象和Rectangle对象
9.2　包
9.3　Point对象
9.4　实例变量
9.5　对象作为方法参数
9.6　Rectangle对象
9.7　对象作为返回类型
9.8　对象是可变的
9.9　别名
9.10　null
9.11　垃圾回收
9.12　对象类型和原始类型
9.13　术语表
9.14　练习
第10章　GridWorld(第二部分)
10.1　Termite类
10.2　Langton白蚁
10.3　练习
第11章　创建对象
11.1　类定义与对象类型
11.2　Time类
11.3　构造函数
11.4　更多构造函数
11.5　创建新对象
11.6　打印对象
11.7　操作对象
11.8　纯函数
11.9　修改器
11.10　填值方法
11.11　渐进式开发
11.12　泛化
11.13　算法
11.14　术语表
11.15　练习
第12章　数组
12.1　访问数组元素
12.2　拷贝数组
12.3　for循环
12.4　数组和对象
12.5　数组长度
12.6　随机数
12.7　随机数数组
12.8　计数
12.9　直方图
12.10　单次遍历
12.11　术语表
12.12　练习
第13章　对象数组
13.1　内容前瞻
13.2　Card对象
13.3　printCard方法
13.4　sameCard方法
13.5　compareCard方法
13.6　扑克牌数组
13.7　printDeck方法
13.8　查找
13.9　整体与部分
13.10　术语表
13.11　练习
第14章　数组对象
14.1　Deck类
14.2　洗牌
14.3　排序
14.4　子集
14.5　洗牌和发牌
14.6　合并排序法
14.7　类变量
14.8　术语表
14.9　练习
第15章　面向对象编程
15.1　编程语言和风格
15.2　对象方法和类方法
15.3　toString方法
15.4　equals方法
15.5　错误
15.6　继承
15.7　类的层级结构
15.8　面向对象设计
15.9　术语表
15.10　练习
第16章　GridWorld(第三部分)
16.1　ArrayList
16.2　接口
16.3　public和private
16.4　生命游戏
16.5　LifeRunner
16.6　LifeRock
16.7　同步更新
16.8　初始条件
16.9　练习
附录A　图形
A.1　Java二维图形
A.2　Graphics方法
A.3　坐标
A.4　颜色
A.5　米老鼠
A.6　练习
附录B　Java中的输入和输出
B.1　System对象
B.2　键盘输入
B.3　文件输入
B.4　捕获异常
附录C　程序开发
C.1　策略
C.2　失败的开发模式
附录D　调试
D.1　语法错误
D.2　运行时错误
D.3　逻辑错误
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>像计算机科学家一样思考Java
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 8编程参考官方教程
第Ⅰ部分 Java 语言
第1章 Java的历史和演变
1.1 Java的家世
1.1.1 现代编程语言的诞生：C语言
1.1.2 C++：下一个阶段
1.1.3 Java出现的时机已经成熟
1.2 Java的诞生
1.3 Java改变Internet的方式
1.3.1 Java
1.3.2 安全性
1.3.3 可移植性
1.4 Java的魔力：字节码
1.5 servlet：服务器端的
1.6 Java的关键特性
1.6.1 简单性
1.6.2 面向对象
1.6.3 健壮性
1.6.4 多线程
1.6.5 体系结构中立
1.6.6 解释执行和高性能
1.6.7 分布式
1.6.8 动态性
1.7 Java的演变历程
1.8 Java
1.9 文化革新
第2章 Java综述
2.1 面向对象编程
2.1.1 两种范式
2.1.2 抽象
2.1.3 OOP三原则
2.2第一个简单程序
2.2.1 输入程序
2.2.2 编译程序
2.2.3 深入分析第一个示例程序
2.3第二个简短程序
2.4 两种控制语句
2.4.1 if语句
2.4.2 for循环
2.5 使用代码块
2.6 词汇问题
2.6.1 空白符
2.6.2 标识符
2.6.3 字面值
2.6.4 注释
2.6.5 分隔符
2.6.6 Java关键字
2.7 Java类库
第3章 数据类型、变量和数组
3.1 Java是强类型化的语言
3.2 基本类型
3.3 整型
3.3.1
3.3.2
3.3.
3.3.4
3.4 浮点型
3.4.1
3.4.2
3.5 字符型
3.6 布尔型
3.7 深入分析字面值
3.7.1 整型字面值
3.7.2 浮点型字面值
3.7.3 布尔型字面值
3.7.4 字符型字面值
3.7.5 字符串字面值
3.8 变量
3.8.1 变量的声明
3.8.2 动态初始化
3.8.3 变量的作用域和生存期
3.9 类型转换和强制类型转换
3.9.1 Java的自动类型转换
3.9.2 强制转换不兼容的类型
3.10 表达式中的自动类型提升
3.11 数组
3.11.1 一维数组
3.11.2 多维数组
3.11.3 另一种数组声明语法
3.12 关于字符串的一些说明
3.13 向C/C++程序员提供指针方面的说明
第4章 运算符
4.1 算术运算符
4.1.1 基本算术运算符
4.1.2 求模运算符
4.1.3 算术与赋值复合运算符
4.1.4 自增与自减运算符
4.2 位运算符
4.2.1 位逻辑运算符
4.2.2 左移
4.2.3 右移
4.2.4 无符号右移
4.2.5 位运算符与赋值的组合
4.3 关系运算符
4.4 布尔逻辑运算符
4.5 赋值运算符
4.6 “？”运算符
4.7 运算符的优先级
4.8 使用圆括号
第5章 控制语句
5.1 Java的选择语句
19.18.2 java.util.fun
19.18.3 java.uti
19.18.4 java.util.lo
19.18.5 java.util.
19.18.6 java.util.
19.18.7 java.uti
19.18.8 java.util.s
19.18.9 java.uti
第20章 输入/输出：探究ja
20.1 I/O类和接口
20.2 File类
20.2.1 目录
20.2.2 使用FilenameFilter接口
20.2.3 listFiles（）方法
20.2.4 创建目录
20.3 AutoCloseable、Closeable和Flushable接口
20.4 I/O异常
20.5 关闭流的两种方式
20.6 流类
20.7 字节流
20.7.1 InputStream类
20.7.2 OutputStream类
20.7.3 FileInputStream类
20.7.4 FileOutputStream类
20.7.5 ByteArrayInputStream类
20.7.6 ByteArrayOutputStream类
20.7.7 过滤的字节流
20.7.8 缓冲的字节流
20.7.9 SequenceInputStream类
20.7.10 PrintStream类
20.7.11 DataOutputStream和DataInputStream类
20.7.12 RandomAccessFile类
20.8 字符流
20.8.1 Reader类
20.8.2 Writer类
20.8.3 FileReader类
20.8.4 FileWriter类
20.8.5 CharArrayReader类
20.8.6 CharArrayWriter类
20.8.7 BufferedReader类
20.8.8 BufferedWriter类
20.8.9 PushbackReader类
20.8.10 PrintWriter类
20.9 Console类
20.10 串行化
20.10.1 Serializable接口
20.10.2 Externalizable接口
20.10.3 ObjectOutput接口
20.10.4 ObjectOutputStream类
20.10.5 ObjectInput接口
20.10.6 ObjectInputStream类
20.10.7 串行化示例
20.11 流的优点
第21章 探究
21.1 NIO类
21.2 NIO的基础知识
21.2.1 缓冲区
21.2.2 通道
21.2.3 字符集和选择器
21.3 JDK 7对NIO的增强
21.3.1 Path接口
21.3.2 Files类
21.3.3 Path接口
21.3.4 文件属性接口
21.3.5 FileSystem、FileSystems和FileStore类
21.4 使用NIO系统
21.4.1 为基于通道的I/O使用
21.4.2 为基于流的I/O使用
21.4.3 为路径和文件系统操作使用
21.5 JDK 7之前基于通道的例子
21.5.1 读文件（JDK 7之前
21.5.2 写文件（JDK 7之前
第22章 联网
22.1 联网的基础知识
22.2 联网类和接口
22.3 InetAddress类
22.3.1 工厂方法
22.3.2 实例方法
22.4 Inet4Address类和Inet6Address类
22.5 TCP/IP客户端套接字
22.6 URL类
22.7 URLConnection类
22.8 HttpURLConnection类
22.9 URI类
22.10 c
22.11 TCP/IP服务器套接字
22.12 数据报
22.12.1 DatagramSocket类
22.12.2 DatagramPacket类
22.12.3 数据报示例
第23章 Applet类
23.1 applet的两种类型
23.2 applet的基础知识
23.3 applet的架构
23.4 applet的骨架
23.4.1 applet的初始化和终止
23.4.2 重写update（）方法
23.5 简单的applet显示方法
23.6 请求重画
23.7 使用状态栏窗口
23.8 HTML APPLET标记
23.9 向applet传递参数
23.10 getDocumentBase（）和getCodeB
23.11 AppletContext接口和showDocument（）方法
23.12 AudioClip接口
23.13 AppletStub接口
23.14 向控制台输出
第24章 事件处理
24.1 两种事件处理机制
24.2 委托事件模型
24.2.1 事件
24.2.2 事件源
24.2.3 事件监听器
24.3 事件类
24.3.1 ActionEvent类
24.3.2 AdjustmentEvent类
24.3.3 ComponentEvent类
24.3.4 ContainerEvent类
24.3.5 FocusEvent类
24.3.6 InputEvent类
24.3.7 ItemEvent类
24.3.8 KeyEvent类
24.3.9 MouseEvent类
24.3.10 MouseWheelEvent类
24.3.11 TextEvent类
24.3.12 WindowEvent类
24.4 事件源
24.5 事件监听器接口
24.5.1 ActionListener接口
24.5.2 AdjustmentListener接口
24.5.3 ComponentListener接口
24.5.4 ContainerListener接口
24.5.5 FocusListener接口
24.5.6 ItemListener接口
24.5.7 KeyListener接口
24.5.8 MouseListener接口
24.5.9 MouseMotionListener接口
24.5.10 MouseWheelListener接口
24.5.11 TextListener接口
24.5.12 WindowFocusListener接口
24.5.13 WindowListener接口
24.6 使用委托事件模型
24.6.1 处理鼠标事件
24.6.2 处理键盘事件
24.7 适配器类
24.8 内部类
第25章 AWT介绍：使用窗口、图形和文本
25.1 AWT类
25.2 窗口基本元素
25.2.1 Component类
25.2.2 Container类
25.2.3 Panel类
25.2.4 Window类
25.2.5 Frame类
25.2.6 Canvas类
25.3 使用框架窗口
25.3.1 设置窗口的尺寸
25.3.2 隐藏和显示窗口
25.3.3 设置窗口的标题
25.3.4 关闭框架窗口
25.4 在基于AWT的applet中创建框架窗口
25.5 创建基于窗口的程序
25.6 在窗口中显示信息
25.7 使用图形
25.7.1 绘制直线
25.7.2 绘制矩形
25.7.3 绘制椭圆和圆
25.7.4 绘制弧形
25.7.5 绘制多边形
25.7.6 演示绘制方法
25.7.7 改变图形的大小
25.8 使用颜色
25.8.1 Color类的方法
25.8.2 设置当前图形的颜色
25.8.3 一个演示颜色的a
25.9 设置绘图模式
25.10 使用字体
25.10.1 确定可用字体
25.10.2 创建和选择字体
25.10.3 获取字体信息
25.11 使用FontMetrics管理文本输出
25.11.1 显示多行文本
25.11.2 居中显示文本
25.11.3 对齐多行文本
第26章 使用AWT控件、布局管理器和菜单
26.1 AWT控件的基础知识
26.1.1 添加和移除控件
26.1.2 响应控件
26.1.3 HeadlessException异常
26.2 使用标签
26.3 使用命令按钮
26.4 使用复选框
26.5 使用复选框组
26.6 使用下拉列表
26.7 使用列表框
26.8 管理滚动条
26.9 使用Text
26.10 使用Tex
26.11 理解布局管理器
26.11.1 FlowLayout布局管理器
26.11.2 BorderLayout布局管理器
26.11.3 使用I
26.11.4 GridLayout布局管理器
26.11.5 CardLayout布局管理器
26.11.6 GridBagLayout布局管理器
26.12 菜单栏和菜单
26.13 对话框
26.14 FileDialog类
26.15 关于重写paint（）方法
第27章 图像
27.1 文件格式
27.2 图像基础：创建、加载与显示
27.2.1 创建Image对象
27.2.2 加载图像
27.2.3 显示图像
27.3 ImageObserver接口
27.4 双缓冲
27.5 MediaTracker类
27.6 ImageProducer接口
27.7 ImageConsumer接口
27.8 ImageFilter类
27.8.1 CropImageFilter类
27.8.2 RGBImageFilter类
27.9 其他图像类
第28章 并发实用工具
28.1 并发API包
28.1.1 java.util.concurrent包
28.1.2 java.util.concurrent.atomic包
28.1.3 java.util.concurrent.locks包
28.2 使用同步对象
28.2.1 Semaphore类
28.2.2 CountDownLatch类
28.2.3 CyclicBarrier类
28.2.4 Exchanger类
28.2.5 Phaser类
28.3 使用执行器
28.3.1 一个简单的执行器示例
28.3.2 使用Callable和Future接口
28.4 TimeUnit枚举
28.5 并发集合
28.6 锁
28.7 原子操作
28.8 通过Fork/Join框架进行并行编程
28.8.1 主要的Fork/Join类
28.8.2 分而治之的策略
28.8.3 一个简单的Fork/Join示例
28.8.4 理解并行级别带来的影响
28.8.5 一个使用RecursiveTask[V]的例子
28.8.6 异步执行任务
28.8.7 取消任务
28.8.8 确定任务的完成状态
28.8.9 重新启动任务
28.8.10 深入研究
28.8.11 关于Fork/Join框架的一些提示
28.9 并发实用工具与Java传统方式的比较
第29章 流
29.1 流的基础知识
29.1.1 流接口
29.1.2 如何获得流
29.1.3 一个简单的流示例
29.2 缩减操作
29.3 使用并行流
29.4 映射
29.5 收集
29.6 迭代器和流
29.6.1 对流使用迭代器
29.6.2 使用Splite
29.7 流API中更多值得探究的地方
第30章 正则表达式和其他包
30.1 核心Java API包
30.2 正则表达式处理
30.2.1 Pattern类
30.2.2 Matcher类
30.2.3 正则表达式的语法
30.2.4 演示模式匹配
30.2.5 模式匹配的两个选项
30.2.6 探究正则表达式
30.3 反射
30.4 远程方法调用
30.5 使用java.text格式化日期和时间
30.5.1 DateFormat类
30.5.2 SimpleDateFormat类
30.6 JDK 8新增的时间和日？
30.6.1 时间和日期的基础知识
30.6.2 格式化日期和时间
30.6.3 解析日期和时间字符串
30.7 探究java.time包的其他方面
第Ⅲ部分 使用Swing进行 GUI编程
第31章 Swing简介
31.1 Swing的起源
31.2 Swing以AWT为基础
31.3 两个关键的Swing特性
31.3.1 Swing组件是轻量级的
31.3.2 Swing支持可插入外观
31.4 MVC连接
31.5 组件与容器
31.5.1 组件
31.5.2 容器
31.5.3 顶级容器窗格
31.6 Swing包
31.7 一个简单的Swing应用程序
31.8 事件处理
31.9 创建Swing ap
31.10 在Swing中绘图
31.10.1 绘图的基础知识
31.10.2 计算可绘制区域
31.10.3 一个绘图示例
第32章 探究S
32.1 JLabel与Image
32.2 JTextF
32.3 Swing按钮
32.3.1 JBu
32.3.2 JToggleBu
32.3.3 复选框
32.3.4 单选按钮
32.4 JTabbed
32.5 JScroll
32.6 J
32.7 JComb
32.8 树
32.9 JT
第33章 Swing菜单简介
33.1 菜单的基础知识
33.2 JMenuBar、JMenu和JMenuItem概述
33.2.1 JMen
33.2.2 J
33.2.3 JMenu
33.3 创建主菜单
33.4 向菜单项添加助记符和加速键
33.5 向菜单项添加图片和工具提示
33.6 使用JRadioButtonMenuItem和JCheckBoxMenu
33.7 创建弹出菜单
33.8 创建工具栏
33.9 使用动作
33.10 完整演示MenuDemo程序
33.11 继续探究S
第Ⅳ部分 使用JavaFX进行GUI编程
第34章 JavaFX GUI编程简介
34.1 JavaFX的基础概念
34.1.1 JavaFX包
34.1.2 Stage和Scene类
34.1.3 节点和场景图
34.1.4 布局
34.1.5 Application类和生命周期方法
34.1.6 启动JavaFX应用程序
34.2 JavaFX应用程序的骨架
34.3 编译和运行JavaFX程序
34.4 应用程序线程
34.5 一个简单的JavaFX控件：L
34.6 使用按钮和事件
34.6.1 事件的基础知识
34.6.2 按钮控件简介
34.6.3 演示事件处理和按钮
34.7 直接在画布上绘制
第35章 探究JavaFX控件
35.1 使用Image和Image
35.1.1 向标签添加图片
35.1.2 在按钮中使用图片
35.2 ToggleBu
35.3 RadioBu
35.3.1 处理开关组中的变化事件
35.3.2 处理单选按钮的另一种方式
35.4 Chec
35.5 List
35.5.1 ListView的滚动条
35.5.2 启用多项选择
35.6 Comb
35.7 TextF
35.8 Scroll
35.9 Tree
35.10 效果和变换简介
35.10.1 效果
35.10.2 变换
35.10.3 演示效果和变换
35.11 添加工具提示
35.12 禁用控件
第36章 JavaFX菜单简介
36.1 菜单的基础知识
36.2 MenuBar、Menu和MenuItem概述
36.2.1 Men
36.2.2
36.2.3 Menu
36.3 创建主菜单
36.4 向菜单项添加助记符和加速键
36.5 向菜单项添加图片
36.6 使用RadioMenuItem和CheckMenu
36.7 创建上下文菜单
36.8 创建工具栏
36.9 完整的MenuDemo程序
36.10 继续探究Ja
第Ⅴ部分 应用
第37章 Java
37.1 Java Bean是什么
37.2 Java Bean的优势
37.3 内省
37.3.1 属性的设计模式
37.3.2 事件的设计模式
37.3.3 方法与设计模式
37.3.4 使用BeanInfo接口
37.4 绑定属性与约束属性
37.5 持久性
37.6 定制器
37.7 Java Bean
37.7.1 Introspector类
37.7.2 PropertyDescriptor类
37.7.3 EventSetDescriptor类
37.7.4 MethodDescriptor类
37.8 一个Bean示例
第38章 ser
38.1 背景
38.2 servelet的生命周期
38.3 servlet开发选项
38.4 使用To
38.5 一个简单的ser
38.5.1 创建和编译servlet源代码
38.5.2 启动To
38.5.3 启动Web浏览器并请求ser
38.6 Servlet
38.7 javax.servlet包
38.7.1 Servlet接口
38.7.2 ServletConfig接口
38.7.3 ServletContext接口
38.7.4 ServletRequest接口
38.7.5 ServletResponse接口
38.7.6 GenericServlet类
38.7.7 ServletInputStream类
38.7.8 ServletOutputStream类
38.7.9 servlet异常类
38.8 读取servlet参数
38.9 javax.servlet.http包
38.9.1 HttpServletRequest接口
38.9.2 HttpServletResponse接口
38.9.3 HttpSession接口
38.9.4 Cookie类
38.9.5 HttpServlet类
38.10 处理HTTP请求和响应
38.10.1 处理HTTP GET请求
38.10.2 处理HTTP POST请求
38.11 使用co
38.12 会话跟踪
附录 使用Java的文档注释
5.1.1 if语句
5.1.2 switch语句
5.2 迭代语句
5.2.1 while语句
5.2.2 do-while语句
5.2.3 for语句
5.2.4 for循环的for-each版本
5.2.5 嵌套的循环
5.3 跳转语句
5.3.1 使用break语句
5.3.2 使用continue语句
5.3.3 return语句
第6章 类
6.1 类的基础知识
6.1.1 类的一般形式
6.1.2 一个简单的类
6.2 声明对象
6.3 为对象引用变量赋值
6.4 方法
6.4.1 为Box类添加方法
6.4.2 返回值
6.4.3 添加带参数的方法
6.5 构造函数
6.6 this关键字
6.7 垃圾回收
6.8 finalize（）方法
6.9 堆栈类
第7章 方法和类的深入分析
7.1 重载方法
7.2 将对象用作参数
7.3 参数传递的深入分析
7.4 返回对象
7.5 递归
7.6 访问控制
7.7 理解st
7.8 final介绍
7.9 重新审视数组
7.10 嵌套类和内部类
7.11 String类介绍
7.12 使用命令行参数
7.13 varargs：可变长度参数
7.13.1 重载varargs方法
7.13.2 varargs方法与模糊性
第8章 继承
8.1 继承的基础知识
8.1.1 成员访问与继承
8.1.2 一个更实际的例子
8.1.3 超类变量可以引用子类对象
8.2 使用super关键字
8.2.1 使用super调用超类的构造函数
8.2.2 super的另一种用法
8.3 创建多级继承层次
8.4 构造函数的调用时机
8.5 方法重写
8.6 动态方法调度
8.6.1 重写方法的目的
8.6.2 应用方法重写
8.7 使用抽象类
8.8 在继承中使用final关键字
8.8.1 使用final关键字阻止重写
8.8.2 使用final关键字阻止继承
8.9 Object类
第9章 包和接口
9.1 包
9.1.1 定义包
9.1.2 包查找与CLAS
9.1.3 一个简短的包示例
9.2 访问保护
9.3 导入包
9.4 接口
9.4.1 定义接口
9.4.2 实现接口
9.4.3 嵌套接口
9.4.4 应用接口
9.4.5 接口中的变量
9.4.6 接口可以扩展
9.5 默认接口方法
9.5.1 默认方法的基础知识
9.5.2 一个更加实用的例子
9.5.3 多级继承的问题
9.6 在接口中使用静态方法
9.7 关于包和接口的最后说明
第10章 异常处理
10.1 异常处理的基础知识
10.2 异常类型
10.3 未捕获的异常
10.4 使用try和
10.5 多条catch子句
10.6 嵌套的try语句
10.7
10.8 t
10.9 fi
10.10 Java的内置异常
10.11 创建自己的异常子类
10.12 链式异常
10.13 3个近期添加的异常特性
10.14 使用异常
第11章 多线程编程
11.1 Java线程模型
11.1.1 线程优先级
11.1.2 同步
11.1.3 消息传递
11.1.4 Thread类和Runnable接口
11.2 主线程
11.3 创建线程
11.3.1 实现Runnable接口
11.3.2 扩展Thread类
11.3.3 选择一种创建方式
11.4 创建多个线程
11.5 使用isAlive（）和join（）方法
11.6 线程优先级
11.7 同步
11.7.1 使用同步方法
11.7.2 synchronized语句
11.8 线程间通信
11.9 挂起、恢复与停止线程
11.10 获取线程的状态
11.11 使用多线程
第12章 枚举、自动装箱与注解（元数据
12.1 枚举
12.1.1 枚举的基础知识
12.1.2 values（）和valueOf（）方法
12.1.3 Java枚举是类类型
12.1.4 枚举继承自Enum类
12.1.5 另一个枚举示例
12.2 类型封装器
12.2.1 Character封装器
12.2.2 Boolean封装器
12.2.3 数值类型封装器
12.3 自动装箱
12.3.1 自动装箱与方法
12.3.2 表达式中发生的自动装箱/拆箱
12.3.3 布尔型和字符型数值的自动装箱/拆箱
12.3.4 自动装箱/拆箱有助于防止错误
12.3.5 一些警告
12.4 注解（元数据
12.4.1 注解的基础知识
12.4.2 指定保留策略
12.4.3 在运行时使用反射获取注解
12.4.4 AnnotatedElement接口
12.4.5 使用默认值
12.4.6 标记注解
12.4.7 单成员注解
12.4.8 内置注解
12.5 类型注解
12.6 重复注解
第13章 I/O、applet以及其他主题
13.1 I/O的基础知识
13.1.1 流
13.1.2 字节流和字符流
13.1.3 预定义流
13.2 读取控制台输入
13.2.1 读取字符
13.2.2 读取字符串
13.3 向控制台写输出
13.4 PrintWriter类
13.5 读/写文件
13.6 自动关闭文件
13.7 applet的基础知识
13.8 transient和volatile修饰符
13.9 使用instanceof运算符
13.10 str
13.11 本地方法
13.12 使用a
13.13 静态导入
13.14 通过this（）调用重载的构造函数
13.15 紧凑API配置文件
第14章 泛型
14.1 什么是泛型
14.2 一个简单的泛型示例
14.2.1 泛型只使用引用类型
14.2.2 基于不同类型参数的泛型类型是不同的
14.2.3 泛型提升类型安全性的原理
14.3 带两个类型参数的泛型类
14.4 泛型类的一般形式
14.5 有界类型
14.6 使用通配符参数
14.7 创建泛型方法
14.8 泛型接口
14.9 原始类型与遗留代码
14.10 泛型类层次
14.10.1 使用泛型超类
14.10.2 泛型子类
14.10.3 泛型层次中的运行时类型比较
14.10.4 强制转换
14.10.5 重写泛型类的方法
14.11 泛型的类型推断
14.12 擦除
14.13 模糊性错误
14.14 使用泛型的一些限制
14.14.1 不能实例化类型参数
14.14.2 对静态成员的一些限制
14.14.3 对泛型数组的一些限制
14.14.4 对泛型异常的限制
第15章 lambda表达式
15.1 lambda表达式简介
15.1.1 lambda表达式的基础知识
15.1.2 函数式接口
15.1.3 几个lambda表达式示例
15.2 块lambda表达式
15.3 泛型函数式接口
15.4 作为参数传递lambda表达式
15.5 lambda表达式与异常
15.6 lambda表达式和变量捕获
15.7 方法引用
15.7.1 静态方法的方法引用
15.7.2 实例方法的方法引用
15.7.3 泛型中的方法引用
15.8 构造函数引用
15.9 预定义的函数式接口
第Ⅱ部分 Java库
第16章 字符串处理
16.1 String类的构造函数
16.2 字符串的长度
16.3 特殊的字符串操作
16.3.1 字符串字面值
16.3.2 字符串连接
16.3.3 字符串和其他数据类型的连接
16.3.4 字符串转换和toString（）方法
16.4 提取字符
16.4.1 cha
16.4.2 getCh
16.4.3 getBy
16.4.4 toCharAr
16.5 比较字符串
16.5.1 equals（）和equalsIgnoreC
16.5.2 regionMatc
16.5.3 startsWith（）和endsW
16.5.4 equals（）与
16.5.5 compar
16.6 查找字符串
16.7 修改字符串
16.7.1 substr
16.7.2 con
16.7.3 repl
16.7.4 t
16.8 使用valueOf（）转换数据
16.9 改变字符串中字符的大小写
16.10 连接字符串
16.11 其他String方法
16.12 StringBuffer类
16.12.1 StringBuffer类的构造函数
16.12.2 length（）与capac
16.12.3 ensureCapac
16.12.4 setLen
16.12.5 charAt（）与setCha
16.12.6 getCh
16.12.7 app
16.12.8 ins
16.12.9 reve
16.12.10 delete（）与deleteCha
16.12.11 repl
16.12.12 substr
16.12.13 其他StringBuffer方法
16.13 StringBuilder类
第17章 探究java
17.1 基本类型封装器
17.1.1 N
17.1.2 Double与
17.1.3 理解isInfinite（）与is
17.1.4 Byte、Short、Integer？
17.1.5 Char
17.1.6 对Unicode代码点的附加支持
17.1.7 Bo
17.2 Void类
17.3 Process类
17.4 Runtime类
17.4.1 内存管理
17.4.2 执行其他程序
17.5 ProcessBuilder类
17.6 System类
17.6.1 使用currentTimeMillis（）计时程序的执行
17.6.2 使用arrayc
17.6.3 环境属性
17.7 Object类
17.8 使用clone（）方法和Cloneable接口
17.9 Class类
17.10 ClassLoader类
17.11 Math类
17.11.1 三角函数
17.11.2 指数函数
17.11.3 舍入函数
17.11.4 其他数学方法
17.12 StrictMath类
17.13 Compiler类
17.14 Thread类、ThreadGroup类和Runnable接口
17.14.1 Runnable接口
17.14.2 Thread类
17.14.3 ThreadGroup类
17.15 ThreadLocal和
InheritableThreadLocal类
17.16 Package类
17.17 RuntimePermission类
17.18 Throwable类
17.19 SecurityManager类
17.20 StackTraceElement类
17.21 Enum类
17.22 ClassValue类
17.23 CharSequence接口
17.24 Comparable接口
17.25 Appendable接口
17.26 Iterable接口
17.27 Readable接口
17.28 AutoCloseable接口
17.29 Thread.UncaughtExceptionHandler接口
17.30 java.lang子包
17.30.1 java.lang.annot
17.30.2 java.lang.instr
17.30.3 java.lang.i
17.30.4 java.lang.manag
17.30.5 java.lan
17.30.6 java.lang.re
第18章 java.util第1部分：集合框架
18.1 集合概述
18.2 JDK 5对集合框架的修改
18.2.1 泛型从根本上改变了集合框架
18.2.2 自动装箱使得使用基本类型更加容易
18.2.3 for-each风格的for循环
18.3 集合接口
18.3.1 Collection接口
18.3.2 List接口
18.3.3 Set接口
18.3.4 SortedSet接口
18.3.5 NavigableSet接口
18.3.6 Queue接口
18.3.7 Deque接口
18.4 集合类
18.4.1 ArrayList类
18.4.2 LinkedList类
18.4.3 HashSet类
18.4.4 LinkedHashSet类
18.4.5 TreeSet类
18.4.6 PriorityQueue类
18.4.7 ArrayDeque类
18.4.8 EnumSet类
18.5 通过迭代器访问集合
18.5.1 使用迭代器
18.5.2 使用for-each循环替代迭代器
18.6 Splite
18.7 在集合中存储用户定义的类
18.8 RandomAccess接口
18.9 使用映射
18.9.1 映射接口
18.9.2 映射类
18.10 比较器
18.11 集合算法
18.12 Arrays类
18.13 遗留的类和接口
18.13.1 Enumeration接口
18.13.2 Vector类
18.13.3 Stack类
18.13.4 Dictionary类
18.13.5 Hashtable类
18.13.6 Properties类
18.13.7 使用store（）和l
18.14 集合小结
第19章 java.util第2部分：更多实用工具类
19.1 StringTokenizer类
19.2 BitSet类
19.3 Optional、OptionalDouble、OptionalInt和Optiona
19.4 Date类
19.5 Calendar类
19.6 GregorianCalendar类
19.7 TimeZone类
19.8 SimpleTimeZone类
19.9 Locale类
19.10 Random类
19.11 Observable类
19.11.1 Observer接口
19.11.2 Observer示例
19.12 Timer和TimerTask类
19.13 Currency类
19.14 Formatter类
19.14.1 Formatter类的构造函数
19.14.2 Formatter类的方法
19.14.3 格式化的基础知识
19.14.4 格式化字符串和字符
19.14.5 格式化数字
19.14.6 格式化时间和日期
19.14.7 %n和%%说明符
19.14.8 指定最小字段宽度
19.14.9 指定精度
19.14.10 使用格式标志
19.14.11 对齐输出
19.14.12 空格、“+”、“0”以及“（”标志
19.14.13 逗号标志
19.14.14 “#”标志
19.14.15 大写选项
19.14.16 使用参数索引
19.14.17 关闭Formatter对象
19.14.18 printf（）方法
19.15 Scanner类
19.15.1 Scanner类的构造函数
19.15.2 扫描的基础知识
19.15.3 一些Scanner示例
19.15.4 设置定界符
19.15.5 其他Scanner特性
19.16 ResourceBundle、ListResourceBundle和
19.17 其他实用工具类和接口
19.18 java.util子包
19.18.1 java.util.concurrent、java.util.concurrent.atomic和 java.util.concurrent.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 8编程参考官方教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java基础教程
第1章 Java语言简介
第2章 基本数据类型和数组
第3章 运算符、表达式和语句
第4章 类、对象和接口
第5章 常用实用类
第6章 常用组件及事件处理
第7章 建立对话框
第8章 Java APPLET基础
第9章 图形与图像
第10章 Java多线程机制
第11章 输入/输出流
第12章 Java网络的基本知识
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java基础教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java开放源码编程
第一部分 介绍
第一章 本书概述
第二章 应用概况
第二部分 建立开放源码工具箱
第三章 用JUnit进行单元测试
第四章 用Mocks测试对象的交互作用
第五章 用Hibernate存储对象
第六章 使用WebWork实现MVC模式
第七章 用SiteMesh简化布局
第八章 用Lucene添加搜索能力
第九章 用XDoclet生成配置文件
第十章 交流与工具
第十一章 省时工具
第三部分 开发应用
第十二章 建立开发环境
第十三章 了解测试驱动开发
第十四章 管理生命周期和组件依赖
第十五章 定义域模型
第十六章 创建基于Web的界面
第十七章 定义导航、布局、视觉和感觉
第十八章 实现浏览和查询功能
第十九章 增加购物车
第二十章 保护应用

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java开放源码编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java核心技术
preface xviii
acknowledgements xxiv
chapter 1 an introduction to java（新增批注共25条） 1
java as a programming platform 2
the java “white paper” buzzwords 3
simple 3
object oriented 4
network-savvy 5
robust 5
secure 6
architecture neutral 7
portable 8
interpreted 9
high performance 9
multithreaded 10
dynamic 10
java applets and the internet 11
a short history of java 12
common misconceptions about java 15
.chapter 2 the java programming environment
（新增批注共20条） 21
installing the java development kit 22
downloading the jdk 22
setting the execution path 26
installing the library source and documentation 28
installing the core java program examples 28
navigating the java directories 29
choosing a development environment 32
using the command-line tools 33
troubleshooting hints 43
using an integrated development environment 45
locating compilation errors 49
running a graphical application 55
building and running applets 58
chapter 3 fundamental programming structures in java
（新增批注共44条） 63
a simple java program 64
comments 68
data types 70
integer types 70
floating-point types 71
the char type 72
the boolean type 74
variables 74
initializing variables 76
constants 76
operators 77
increment and decrement operators 78
relational and boolean operators 79
bitwise operators 81
mathematical functions and constants 81
conversions between numeric types 83
casts 84
parentheses and operator hierarchy 84
enumerated types 85
strings 86
substrings 86
concatenation 86
strings are immutable 87
testing strings for equality 88
code points and code units 89
the string api 90
reading the on-line api documentation 92
building strings 95
input and output 96
reading input 96
formatting output 98
file input and output 103
control flow 105
block scope 105
conditional statements 106
loops 109
determinate loops 113
multiple selections—the switch statement 117
statements that break control flow 119
big numbers 122
arrays 124
the “for each” loop 125
array initializers and anonymous arrays 126
array copying 126
command-line parameters 128
array sorting 129
multidimensional arrays 132
ragged arrays 135
chapter 4 objects and classes（新增批注共55条） 139
introduction to object-oriented programming 140
classes 142
objects 143
identifying classes 143
relationships between classes 144
using predefined classes 146
objects and object variables 146
the gregoriancalendar class of the java library 150
mutator and accessor methods 152
defining your own classes 158
an employee class 158
use of multiple source files 162
dissecting the employee class 163
first steps with constructors 164
implicit and explicit parameters 166
benefits of encapsulation 167
class-based access privileges 170
private methods 171
final instance fields 171
static fields and methods 172
static fields 172
static constants 173
static methods 174
factory methods 175
the main method 175
method parameters 178
object construction 185
overloading 185
default field initialization 185
default constructors 186
explicit field initialization 187
parameter names 188
calling another constructor 188
initialization blocks 189
object destruction and the finalize method 193
packages 194
class importation 195
static imports 196
addition of a class into a package 197
package scope 200
the class path 201
setting the class path 203
documentation comments 204
comment insertion 204
class comments 205
method comments 205
field comments 206
general comments 206
package and overview comments 207
comment extraction 207
class design hints 208
chapter 5 inheritance（新增批注共42条） 213
classes, superclasses, and subclasses 214
inheritance hierarchies 222
polymorphism 222
dynamic binding 224
preventing inheritance: final classes and methods 226
casting 227
abstract classes 229
protected access 234
object: the cosmic superclass 235
the equals method 236
equality testing and inheritance 238
the hashcode method 240
the tostring method 243
generic array lists 248
accessing array list elements 250
compatibility between typed and raw array lists 254
object wrappers and autoboxing 256
methods with a variable number of parameters 259
enumeration classes 260
reflection 263
the class class 263
a primer on catching exceptions 266
using reflection to analyze the capabilities of classes 268
using reflection to analyze objects at runtime 273
using reflection to write generic array code 277
method pointers! 281
design hints for inheritance 284
chapter 6 interfaces and inner classes（新增批注共24条） 289
interfaces 290
properties of interfaces 296
interfaces and abstract classes 297
object cloning 298
interfaces and callbacks 305
inner classes 307
use of an inner class to access object state 309
special syntax rules for inner classes 312
are inner classes useful? actually necessary? secure? 313
local inner classes 316
accessing final variables from outer methods 316
anonymous inner classes 319
static inner classes 322
proxies 325
properties of proxy classes 333
chapter 7 exceptions, logging, assertions, and debugging
（新增批注共38条） 335
dealing with errors 336
the classification of exceptions 338
declaring checked exceptions 340
how to throw an exception 342
creating exception classes 343
catching exceptions 344
catching multiple exceptions 346
rethrowing and chaining exceptions 348
the finally clause 349
analyzing stack trace elements 352
tips for using exceptions 357
using assertions 361
assertion enabling and disabling 361
using assertions for parameter checking 362
using assertions for documenting assumptions 363
logging 364
basic logging 364
advanced logging 365
changing the log manager configuration 367
localization 368
handlers 369
filters 373
formatters 373
a logging recipe 373
debugging tips 381
using a console window 387
tracing awt events 389
letting the awt robot do the work 393
using a debugger 396
chapter 8 generic programming（新增批注共22条） 401
why generic programming? 402
who wants to be a generic programmer? 403
definition of a simple generic class 404
generic methods 406
bounds for type variables 407
generic code and the virtual machine 409
translating generic expressions 411
translating generic methods 411
calling legacy code 413
restrictions and limitations 414
type parameters cannot be instantiated with primitive types 414
runtime type inquiry only works with raw types 415
you cannot throw or catch instances of a generic class 415
arrays of parameterized types are not legal 416
you cannot instantiate type variables 416
type variables are not valid in static contexts of generic classes 418
beware of clashes after erasure 418
inheritance rules for generic types 419
wildcard types 421
supertype bounds for wildcards 423
unbounded wildcards 424
wildcard capture 425
reflection and generics 430
using class[t] parameters for type matching 431
generic type information in the virtual machine 431
chapter 9 collections（新增批注共55条） 437
collection interfaces 438
separating collection interfaces and implementation 439
collection and iterator interfaces in the java library 441
concrete collections 447
linked lists 448
array lists 459
hash sets 459
tree sets 463
object comparison 464
queues and deques 469
priority queues 471
maps 472
specialized set and map classes 476
the collections framework 481
views and wrappers 487
bulk operations 493
converting between collections and arrays 494
algorithms 494
sorting and shuffling 496
binary search 498
simple algorithms 499
writing your own algorithms 500
legacy collections 502
the hashtable class 502
enumerations 502
property maps 503
stacks 504
bit sets 504
chapter 10 multithreading（新增批注共24条） 509
what are threads? 511
using threads to give other tasks a chance 517
interrupting threads 524
thread states 528
new threads 529
runnable threads 529
blocked and waiting threads 530
terminated threads 530
thread properties 531
thread priorities 531
daemon threads 533
handlers for uncaught exceptions 534
synchronization 535
an example of a race condition 536
the race condition explained 540
lock objects 541
condition objects 544
the synchronized keyword 549
synchronized blocks 553
the monitor concept 554
volatile fields 555
deadlocks 556
lock testing and timeouts 559
read/write locks 560
why the stop and suspend methods are deprecated 561
blocking queues 563
thread-safe collections 570
efficient maps, sets, and queues 570
copy on write arrays 572
older thread-safe collections 572
callables and futures 573
executors 577
thread pools 578
scheduled execution 582
controlling groups of tasks 583
synchronizers 584
semaphores 585
countdown latches 585
barriers 585
exchangers 586
synchronous queues 586
example: pausing and resuming an animation 586
threads and swing 592
running time-consuming tasks 594
using the swing worker 598
the single-thread rule 604
index 607
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java核心技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java高并发编程详解
推荐序一
推荐序二
推荐序三
推荐序四
前言
第一部分 多线程基础
第1章 快速认识线程 3
1.1 线程的介绍 3
1.2 快速创建并启动一个线程 3
1.2.1 尝试并行运行 4
1.2.2 并发运行交替输出 5
1.2.3 使用Jconsole观察线程 6
1.3 线程的生命周期详解 7
1.3.1 线程的NEW状态 8
1.3.2 线程的RUNNABLE状态 8
1.3.3 线程的 RUNNING状态 8
1.3.4 线程的BLOCKED状态 8
1.3.5 线程的TERMINATED状态 9
1.4 线程的start方法剖析：模板设计模式在Thread中的应用 9
1.4.1 Thread start方法源码分析以及注意事项 9
1.4.2 模板设计模式在Thread中的应用 11
1.4.3 Thread模拟营业大厅叫号机程序 13
1.5 Runnable接口的引入以及策略模式在Thread中的使用 16
1.5.1 Runnable的职责 16
1.5.2 策略模式在Thread中的应用 16
1.5.3 模拟营业大厅叫号机程序 18
1.6 本章总结 19
第2章 深入理解Thread构造函数 20
2.1 线程的命名 20
2.1.1 线程的默认命名 21
2.1.2 命名线程 21
2.1.3 修改线程的名字 22
2.2 线程的父子关系 22
2.3 Thread与ThreadGroup 23
2.4 Thread与Runnable 24
2.5 Thread与JVM虚拟机栈 25
2.5.1 Thread与Stacksize 25
2.5.2 JVM内存结构 27
2.5.3 Thread与虚拟机栈 30
2.6 守护线程 33
2.6.1 什么是守护线程 33
2.6.2 守护线程的作用 34
2.7 本章总结 34
第3章 Thread API的详细介绍 35
3.1 线程sleep 35
3.1.1 sleep方法介绍 35
3.1.2 使用TimeUnit替代Thread.sleep 36
3.2 线程yield 37
3.2.1 yield方法介绍 37
3.2.2 yield和sleep 37
3.3 设置线程的优先级 38
3.3.1 线程优先级介绍 38
3.3.2 线程优先级源码分析 39
3.3.3 关于优先级的一些总结 40
3.4 获取线程ID 40
3.5 获取当前线程 41
3.6 设置线程上下文类加载器 41
3.7 线程interrupt 42
3.7.1 interrupt 42
3.7.2 isInterrupted 43
3.7.3 interrupted 45
3.7.4 interrupt注意事项 46
3.8 线程join 47
3.8.1 线程join方法详解 48
3.8.2 join方法结合实战 50
3.9 如何关闭一个线程 53
3.9.1 正常关闭 54
3.9.2 异常退出 56
3.9.3 进程假死 56
3.10 本章总结 58
第4章 线程安全与数据同步 59
4.1 数据同步 59
4.1.1 数据不一致问题的引入 59
4.1.2 数据不一致问题原因分析 61
4.2 初识 synchronized关键字 62
4.2.1 什么是synchronized 63
4.2.2 synchronized关键字的用法 63
4.3 深入synchronized关键字 65
4.3.1 线程堆栈分析 65
4.3.2 JVM指令分析 67
4.3.3 使用synchronized需要注意的问题 70
4.4 This Monitor和Class Monitor的详细介绍 72
4.4.1 this monitor 72
4.4.2 class monitor 74
4.5 程序死锁的原因以及如何诊断 77
4.5.1 程序死锁 77
4.5.2 程序死锁举例 77
4.5.3 死锁诊断 80
4.6 本章总结 81
第5章 线程间通信 82
5.1 同步阻塞与异步非阻塞 82
5.1.1 同步阻塞消息处理 82
5.1.2 异步非阻塞消息处理 83
5.2 单线程间通信 84
5.2.1 初识wait和notify 84
5.2.2 wait和notify方法详解 87
5.2.3 关于wait和notify的注意事项 89
5.2.4 wait和sleep 90
5.3 多线程间通信 90
5.3.1 生产者消费者 90
5.3.2 线程休息室wait set 93
5.4 自定义显式锁BooleanLock 94
5.4.1 synchronized关键字的缺陷 94
5.4.2 显式锁BooleanLock 95
5.5 本章总结 104
第6章 ThreadGroup详细讲解 105
6.1 ThreadGroup与Thread 105
6.2 创建ThreadGroup 105
6.3 复制Thread数组和ThreadGroup数组 106
6.3.1 复制Thread数组 106
6.3.2 复制ThreadGroup数组 109
6.4 ThreadGroup操作 109
6.4.1 ThreadGroup的基本操作 110
6.4.2 ThreadGroup的interrupt 113
6.4.3 ThreadGroup的destroy 114
6.4.4 守护ThreadGroup 115
6.5 本章总结 116
第7章 Hook线程以及捕获线程执行异常 117
7.1 获取线程运行时异常 117
7.1.1 UncaughtExceptionHandler的介绍 117
7.1.2 UncaughtExceptionHandler实例 118
7.1.3 UncaughtExceptionHandler源码分析 119
7.2 注入钩子线程 121
7.2.1 Hook线程介绍 121
7.2.2 Hook线程实战 122
7.2.3 Hook线程应用场景以及注意事项 124
7.3 本章总结 124
第8章 线程池原理以及自定义线程池 125
8.1 线程池原理 125
8.2 线程池实现 126
8.2.1 线程池接口定义 127
8.2.2 线程池详细实现 131
8.3 线程池的应用 139
8.4 本章总结 142
第二部分 Java ClassLoader
第9章 类的加载过程 144
9.1 类的加载过程简介 144
9.2 类的主动使用和被动使用 145
9.3 类的加载过程详解 148
9.3.1 类的加载阶段 148
9.3.2 类的连接阶段 149
9.3.3 类的初始化阶段 154
9.4 本章总结 156
第10章 JVM类加载器 158
10.1 JVM内置三大类加载器 158
10.1.1 根类加载器介绍 159
10.1.2 扩展类加载器介绍 159
10.1.3 系统类加载器介绍 160
10.2 自定义类加载器 161
10.2.1 自定义类加载器，问候世界 161
10.2.2 双亲委托机制详细介绍 165
10.2.3 破坏双亲委托机制 167
10.2.4 类加载器命名空间、运行时包、类的卸载等 170
10.3 本章总结 175
第11章 线程上下文类加载器 177
11.1 为什么需要线程上下文类加载器 177
11.2 数据库驱动的初始化源码分析 178
11.3 本章总结 180
第三部分 深入理解volatile关键字
第12章 volatile关键字的介绍 182
12.1 初识volatile关键字 182
12.2 机器硬件CPU 184
12.2.1 CPU Cache模型 184
12.2.2 CPU缓存一致性问题 186
12.3 Java内存模型 187
12.4 本章总结 188
第13章 深入volatile关键字 189
13.1 并发编程的三个重要特性 189
13.1.1 原子性 189
13.1.2 可见性 190
13.1.3 有序性 190
13.2 JMM如何保证三大特性 191
13.2.1 JMM与原子性 192
13.2.2 JMM与可见性 193
13.2.3 JMM与有序性 194
13.3 volatile关键字深入解析 195
13.3.1 volatile关键字的语义 195
13.3.2 volatile的原理和实现机制 197
13.3.3 volatile的使用场景 198
13.3.4 volatile和synchronized 199
13.4 本章总结 200
第14章 7种单例设计模式的设计 201
14.1 饿汉式 201
14.2 懒汉式 202
14.3 懒汉式+同步方法 203
14.4 Double-Check 204
14.5 Volatile+Double-Check 206
14.6 Holder方式 206
14.7 枚举方式 207
14.8 本章总结 208
第四部分 多线程设计架构模式
第15章 监控任务的生命周期 212
15.1 场景描述 212
15.2 当观察者模式遇到Thread 212
15.2.1 接口定义 212
15.2.2 ObservableThread实现 215
15.3 本章总结 217
15.3.1 测试运行 217
15.3.2 关键点总结 219
第16章 Single Thread Execution设计模式 220
16.1 机场过安检 220
16.1.1 非线程安全 221
16.1.2 问题分析 223
16.1.3 线程安全 225
16.2 吃面问题 225
16.2.1 吃面引起的死锁 226
16.2.2 解决吃面引起的死锁问题 228
16.2.3 哲学家吃面 229
16.3 本章总结 230
第17章 读写锁分离设计模式 231
17.1 场景描述 231
17.2 读写分离程序设计 232
17.2.1 接口定义 232
17.2.2 程序实现 234
17.3 读写锁的使用 239
17.4 本章总结 242
第18章 不可变对象设计模式 244
18.1 线程安全性 244
18.2 不可变对象的设计 244
18.2.1 非线程安全的累加器 245
18.2.2 方法同步增加线程安全性 247
18.2.3 不可变的累加器对象设计 248
18.3 本章总结 249
第19章 Future设计模式 251
19.1 先给你一张凭据 251
19.2 Future设计模式实现 251
19.2.1 接口定义 252
19.2.2 程序实现 253
19.3 Future的使用以及技巧总结 256
19.4 增强FutureService使其支持回调 257
19.5 本章总结 258
第20章 Guarded Suspension设计模式 259
20.1 什么是Guarded Suspension设计模式 259
20.2 Guarded Suspension的示例 259
20.3 本章总结 261
第21章 线程上下文设计模式 262
21.1 什么是上下文 262
21.2 线程上下文设计 263
21.3 ThreadLocal详解 264
21.3.1 ThreadLocal的使用场景及注意事项 265
21.3.2 ThreadLocal的方法详解及源码分析 265
21.3.3 ThreadLocal的内存泄漏问题分析 270
21.4 使用ThreadLocal设计线程上下文 274
21.5 本章总结 276
第22章 Balking设计模式 277
22.1 什么是Balking设计 277
22.2 Balking模式之文档编辑 278
22.2.1 Document 278
22.2.2 AutoSaveThread 280
22.2.3 DocumentEditThread 281
22.3 本章总结 283
第23章 Latch设计模式 284
23.1 什么是Latch 284
23.2 CountDownLatch程序实现 285
23.2.1 无限等待的Latch 285
23.2.2 有超时设置的Latch 289
23.3 本章总结 291
第24章 Thread-Per-Message设计模式 293
24.1 什么是Thread-Per-Message模式 293
24.2 每个任务一个线程 293
24.3 多用户的网络聊天 296
24.3.1 服务端程序 296
24.3.2 响应客户端连接的Handler 297
24.3.3 聊天程序测试 299
24.4 本章总结 300
第25章 Two Phase Termination设计模式 301
25.1 什么是Two Phase Termination模式 301
25.2 Two Phase Termination的示例 302
25.2.1 线程停止的Two Phase Termination 302
25.2.2 进程关闭的Two Phase Termination 303
25.3 知识扩展 304
25.3.1 Strong Reference及LRUCache 304
25.3.2 Soft Reference及SoftLRUCache 308
25.3.3 Weak Reference 311
25.3.4 Phantom Reference 312
25.4 本章总结 314
第26章 Worker-Thread设计模式 315
26.1 什么是Worker-Thread模式 315
26.2 Worker-Thread模式实现 315
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java高并发编程详解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java游戏编程
第一部分 Java游戏基础
第1章 Java线程
第2章 二维图形与动画
第3章 交互性与用户界面
第4章 声效与音乐
第5章 创建二维平台游戏
第6章 多人游戏
第二部分 三维图形与高级技术
第7章 三维图形
第8章 纹理贴图与照明
第9章 三维对象
第10章 用BSP树管理三维视景
第11章 碰撞探测
……
第三部分 调整与完成游戏
……

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java游戏编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java邮件开发详解
第1章 电子邮件技术基础
第2章 邮件传输协议
第3章 邮件的组织结构
第4章 javamail开发概述
第5章 创建邮件内容
第6章 发送邮件
第7章 jaf框架及其在javamail中的应用
第8章 使用javamail接收邮件
第9章 邮件的解析与显示
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java邮件开发详解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java编程的逻辑
Contents 目录
读者评论
前言
第一部分　编程基础与二进制
第1章　编程基础2
1.1　数据类型和变量3
1.2　赋值4
1.2.1　基本类型4
1.2.2　数组类型6
1.3　基本运算8
1.3.1　算术运算8
1.3.2　比较运算10
1.3.3　逻辑运算10
1.3.4　小结11
1.4　条件执行11
1.4.1　语法和陷阱11
1.4.2　实现原理14
1.5　循环16
1.5.1　循环的4种形式16
1.5.2　循环控制19
1.5.3　实现原理20
1.5.4　小结20
1.6　函数的用法21
1.6.1　基本概念21
1.6.2　进一步理解函数23
1.6.3　小结27
1.7　函数调用的基本原理27
1.7.1　栈的概念27
1.7.2　函数执行的基本原理28
1.7.3　数组和对象的内存分配29
1.7.4　递归调用的原理30
1.7.5　小结31
第2章　理解数据背后的二进制33
2.1　整数的二进制表示与位运算33
2.1.1　正整数的二进制表示33
2.1.2　负整数的二进制表示34
2.1.3　十六进制35
2.1.4　位运算36
2.2　小数的二进制表示37
2.2.1　小数计算为什么会出错37
2.2.2　二进制表示38
2.3　字符的编码与乱码39
2.3.1　常见非Unicode编码39
2.3.2　Unicode编码42
2.3.3　编码转换44
2.3.4　乱码的原因45
2.3.5　从乱码中恢复46
2.4　char的真正含义49
第二部分　面向对象
第3章　类的基础52
3.1　类的基本概念52
3.1.1　函数容器52
3.1.2　自定义数据类型53
3.1.3　定义第一个类55
3.1.4　使用第一个类55
3.1.5　变量默认值57
3.1.6　private变量57
3.1.7　构造方法58
3.1.8　类和对象的生命周期60
3.1.9　小结61
3.2　类的组合61
3.2.1　String和Date61
3.2.2　图形类62
3.2.3　用类描述电商概念63
3.2.4　用类描述人之间的血缘关系65
3.2.5　目录和文件66
3.2.6　一些说明67
3.2.7　小结68
3.3　代码的组织机制68
3.3.1　包的概念68
3.3.2　jar包71
3.3.3　程序的编译与链接71
3.3.4　小结72
第4章　类的继承73
4.1　基本概念73
4.1.1　根父类Object74
4.1.2　方法重写74
4.1.3　图形类继承体系75
4.1.4　小结80
4.2　继承的细节80
4.2.1　构造方法81
4.2.2　重名与静态绑定82
4.2.3　重载和重写83
4.2.4　父子类型转换85
4.2.5　继承访问权限protected85
4.2.6　可见性重写86
4.2.7　防止继承final87
4.3　继承实现的基本原理88
4.3.1　示例88
4.3.2　类加载过程90
4.3.3　对象创建的过程91
4.3.4　方法调用的过程92
4.3.5　变量访问的过程93
4.4　为什么说继承是把双刃剑94
4.4.1　继承破坏封装94
4.4.2　封装是如何被破坏的94
4.4.3　继承没有反映is-a关系97
4.4.4　如何应对继承的双面性97
第5章　类的扩展100
5.1　接口的本质100
5.1.1　接口的概念101
5.1.2　定义接口101
5.1.3　实现接口102
5.1.4　使用接口103
5.1.5　接口的细节105
5.1.6　使用接口替代继承106
5.1.7　Java 8和Java 9对接口的增强106
5.1.8　小结108
5.2　抽象类108
5.2.1　抽象方法和抽象类108
5.2.2　为什么需要抽象类109
5.2.3　抽象类和接口109
5.2.4　小结110
5.3　内部类的本质111
5.3.1　静态内部类111
5.3.2　成员内部类113
5.3.3　方法内部类115
5.3.4　匿名内部类117
5.4　枚举的本质119
5.4.1　基础120
5.4.2　典型场景122
第6章　异常125
6.1　初识异常125
6.1.1　NullPointerException（空指针异常）125
6.1.2　NumberFormatException（数字格式异常）126
6.2　异常类128
6.2.1　Throwable128
6.2.2　异常类体系129
6.2.3　自定义异常130
6.3　异常处理131
6.3.1　catch匹配131
6.3.2　重新抛出异常131
6.3.3　finally132
6.3.4　try-with-resources133
6.3.5　throws134
6.3.6　对比受检和未受检异常135
6.4　如何使用异常135
6.4.1　异常应该且仅用于异常情况136
6.4.2　异常处理的目标136
6.4.3　异常处理的一般逻辑137
第7章　常用基础类138
7.1　包装类138
7.1.1　基本用法139
7.1.2　共同点140
7.1.3　剖析Integer与二进制算法144
7.1.4　剖析Character149
7.2　剖析String155
7.2.1　基本用法156
7.2.2　走进String内部157
7.2.3　编码转换157
7.2.4　不可变性158
7.2.5　常量字符串159
7.2.6　hashCode160
7.2.7　正则表达式161
7.3　剖析StringBuilder162
7.3.1　基本用法162
7.3.2　基本实现原理162
7.3.3　String的+和+ =运算符165
7.4　剖析Arrays166
7.4.1　用法166
7.4.2　多维数组171
7.4.3　实现原理172
7.4.4　小结174
7.5　剖析日期和时间174
7.5.1　基本概念174
7.5.2　日期和时间API175
7.5.3　局限性182
7.6　随机183
7.6.1　Math.random183
7.6.2　Random184
7.6.3　随机的基本原理185
7.6.4　随机密码187
7.6.5　洗牌189
7.6.6　带权重的随机选择189
7.6.7　抢红包算法191
7.6.8　北京购车摇号算法192
7.6.9　小结193
第三部分　泛型与容器
第8章　泛型196
8.1　基本概念和原理196
8.1.1　一个简单泛型类197
8.1.2　容器类199
8.1.3　泛型方法201
8.1.4　泛型接口202
8.1.5　类型参数的限定202
8.1.6　小结205
8.2　解析通配符205
8.2.1　更简洁的参数类型限定205
8.2.2　理解通配符206
8.2.3　超类型通配符208
8.2.4　通配符比较211
8.3　细节和局限性211
8.3.1　使用泛型类、方法和接口211
8.3.2　定义泛型类、方法和接口213
8.3.3　泛型与数组214
8.3.4　小结217
第9章　列表和队列218
9.1　剖析ArrayList218
9.1.1　基本用法218
9.1.2　基本原理219
9.1.3　迭代221
9.1.4　ArrayList实现的接口225
9.1.5　ArrayList的其他方法227
9.1.6　ArrayList特点分析229
9.1.7　小结229
9.2　剖析LinkedList229
9.2.1　用法230
9.2.2　实现原理232
9.2.3　LinkedList特点分析238
9.3　剖析ArrayDeque239
9.3.1　实现原理239
9.3.2　ArrayDeque特点分析244
第10章　Map和Set245
10.1　剖析HashMap245
10.1.1　Map接口245
10.1.2　HashMap247
10.1.3　实现原理247
10.1.4　小结256
10.2　剖析HashSet256
10.2.1　用法256
10.2.2　实现原理258
10.2.3　小结259
10.3　排序二叉树260
10.3.1　基本概念260
10.3.2　基本算法261
10.3.3　平衡的排序二叉树263
10.3.4　小结264
10.4　剖析TreeMap264
10.4.1　基本用法265
10.4.2　实现原理267
10.4.3　小结273
10.5　剖析TreeSet274
10.5.1　基本用法274
10.5.2　实现原理275
10.5.3　小结276
10.6　剖析LinkedHashMap276
10.6.1　基本用法276
10.6.2　实现原理279
10.6.3　LinkedHashSet282
10.6.4　小结282
10.7　剖析EnumMap283
10.7.1　基本用法283
10.7.2　实现原理285
10.7.3　小结287
10.8　剖析EnumSet287
10.8.1　基本用法287
10.8.2　应用场景288
10.8.3　实现原理291
10.8.4　小结294
第11章　堆与优先级队列295
11.1　堆的概念与算法296
11.1.1　基本概念296
11.1.2　堆的算法298
11.1.3　小结302
11.2　剖析PriorityQueue302
11.2.1　基本用法302
11.2.2　实现原理304
11.2.3　小结309
11.3　堆和PriorityQueue的应用309
11.3.1　求前K个最大的元素309
11.3.2　求中值311
11.3.3　小结314
第12章　通用容器类和总结315
12.1　抽象容器类315
12.1.1　AbstractCollection316
12.1.2　AbstractList319
12.1.3　AbstractSequentialList321
12.1.4　AbstractMap323
12.1.5　AbstractSet325
12.1.6　AbstractQueue325
12.1.7　小结326
12.2　Collections326
12.2.1　查找和替换327
12.2.2　排序和调整顺序329
12.2.3　添加和修改332
12.2.4　适配器333
12.2.5　装饰器338
12.2.6　小结342
12.3　容器类总结342
12.3.1　用法和特点342
12.3.2　数据结构和算法344
12.3.3　设计思维和模式344
第四部分　文件
第13章　文件基本技术348
13.1　文件概述348
13.1.1　基本概念和常识348
13.1.2　Java文件概述352
13.2　二进制文件和字节流355
13.2.1　InputStream/OutputStream355
13.2.2　FileInputStream/File-OutputStream357
13.2.3　ByteArrayInputStream/ByteArrayOutputStream359
13.2.4　DataInputStream/Data-OutputStream361
13.2.5　BufferedInputStream/BufferedOutputStream363
13.2.6　实用方法364
13.2.7　小结365
13.3　文本文件和字符流365
13.3.1　基本概念366
13.3.2　Reader/Writer368
13.3.3　InputStreamReader/Output-StreamWriter368
13.3.4　FileReader/FileWriter369
13.3.5　CharArrayReader/Char-ArrayWriter370
13.3.6　StringReader/StringWriter370
13.3.7　BufferedReader/Buffered-Writer371
13.3.8　PrintWriter372
13.3.9　Scanner374
13.3.10　标准流374
13.3.11　实用方法376
13.3.12　小结377
13.4　文件和目录操作378
13.4.1　构造方法378
13.4.2　文件元数据378
13.4.3　文件操作379
13.4.4　目录操作380
第14章　文件高级技术383
14.1　常见文件类型处理384
14.1.1　属性文件384
14.1.2　CSV文件385
14.1.3　Excel388
14.1.4　HTML389
14.1.5　压缩文件391
14.2　随机读写文件394
14.2.1　用法394
14.2.2　设计一个键值数据库BasicDB396
14.2.3　BasicDB的实现397
14.2.4　小结401
14.3　内存映射文件402
14.3.1　基本概念402
14.3.2　用法403
14.3.3　设计一个消息队列BasicQueue404
14.3.4　实现消息队列406
14.3.5　小结409
14.4　标准序列化机制409
14.4.1　基本用法409
14.4.2　复杂对象411
14.4.3　定制序列化411
14.4.4　序列化的基本原理413
14.4.5　版本问题414
14.4.6　序列化特点分析414
14.5　使用Jackson序列化为JSON/XML/MessagePack415
14.5.1　基本概念415
14.5.2　基本用法415
14.5.3　容器对象418
14.5.4　复杂对象419
14.5.5　定制序列化420
14.5.6　Jackson对XML支持的局限性428
14.5.7　小结428
第五部分　并发
第15章　并发基础知识430
15.1　线程的基本概念430
15.1.1　创建线程430
15.1.2　线程的基本属性和方法432
15.1.3　共享内存及可能存在的问题435
15.1.4　线程的优点及成本438
15.2　理解synchronized439
15.2.1　用法和基本原理439
15.2.2　进一步理解synchronized443
15.2.3　同步容器及其注意事项445
15.3　线程的基本协作机制450
15.3.1　协作的场景450
15.3.2　wait/notify450
15.3.3　生产者/消费者模式453
15.3.4　同时开始455
15.3.5　等待结束456
15.3.6　异步结果458
15.3.7　集合点461
15.3.8　小结462
15.4　线程的中断463
15.4.1　取消/关闭的场景463
15.4.2　取消/关闭的机制463
15.4.3　线程对中断的反应464
15.4.4　如何正确地取消/关闭线程467
15.4.5　小结467
第16章　并发包的基石468
16.1　原子变量和CAS468
16.2　显式锁473
16.3　显式条件483
第17章　并发容器490
17.1　写时复制的List和Set490
17.2　ConcurrentHashMap493
17.3　基于跳表的Map和Set498
17.4　并发队列501
第18章　异步任务执行服务505
18.1　基本概念和原理505
18.2　线程池513
18.3　定时任务的那些陷阱518
第19章　同步和协作工具类527
19.1　读写锁ReentrantReadWrite-Lock527
19.2　信号量Semaphore529
19.3　倒计时门栓CountDownLatch531
19.4　循环栅栏CyclicBarrier533
19.5　理解ThreadLocal535
第20章　并发总结541
20.1　线程安全的机制541
20.2　线程的协作机制543
20.3　容器类544
20.4　任务执行服务546
第六部分　动态与函数式编程
第21章　反射550
21.1　Class类551
21.2　应用示例559
21.3　反射与泛型561
第22章　注解564
22.1　内置注解564
22.2　框架和库的注解566
22.3　创建注解568
22.4　查看注解信息570
22.5　注解的应用：定制序列化571
22.6　注解的应用：DI容器573
第23章　动态代理577
23.1　静态代理577
23.2　Java SDK动态代理579
23.3　cglib动态代理584
23.4　Java SDK代理与cglib代理比较585
23.5　动态代理的应用：AOP585
第24章　类加载机制592
24.1　类加载的基本机制和过程593
24.2　理解ClassLoader594
24.3　类加载的应用：可配置的策略597
24.4　自定义ClassLoader598
24.5　自定义ClassLoader的应用：热部署599
第25章　正则表达式603
25.1　语法603
25.2　Java API612
25.3　模板引擎618
25.4　剖析常见表达式619
第26章　函数式编程628
26.1　Lambda表达式628
26.2　函数式数据处理：基本用法637
26.3　函数式数据处理：强大方便的收集器647
26.4　组合式异步编程658
26.5　Java 8的日期和时间API668
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java编程的逻辑
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java线程
前言
第一章 线程简介
java术语
线程概述
为什么要使用线程？
总结
第二章 java线程api
通过thread类创建线程
使用runable接口的线程
线程的生命周期
线程命名
访问线程
线程的启动、停止和连接
总结
第三章 同步技术
银行的例子
异步读取数据
.一个进行同步操作的类
同步块
嵌套锁
死锁
返回到银行的例子
同步静态方法
总结
第四章 等待和通知
返回到银行的例子
等待和通知
wait（）、notify（）和notifyall（）
wait（）和sleep（）
线程中断
静态方法（有关同步的细节）
总结
第五章 java线程编程的例子
数据结构和容器
简单的同步例子
一个网络服务器类
asyncinputstream类
使用tcpserver和asynclnputstream
总结
第六章 java线程调度
线程调度概述
何时调度是重要的
调度和线程优先级
常见的调度实现
本地调度支持
其他线程调度方法
总结
第七章 java线程调度例子
线程池
循环调度
作业调度
总结
第八章 和同步相关的高级主题
同步术语
预防死锁
锁饥饿
非线程安全的类
总结
第九章 多处理器机器上的并行化
单线程程序并行化
内层循环线程化
循环输出
多处理器扩展
总结
第十章 线程组
线程组概念
创建线程组
线程组方法
操作线程组
线程组、线程和安全
总结
附录一 其他主题
附录二 异常和错误
词汇表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java线程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java编程那些事儿
第1章  计算机基础    1.1  计算机软件的基本概念      1.1.1  软件的概念      1.1.2  计算机为什么使用二进制数据      1.1.3  计算机存储单位    1.2  进制的概念      1.2.1  二进制      1.2.2  二进制和十进制之间的转换      1.2.3  二进制和八进制、十六进制之间的转换    1.3  计算机内部的数据表达      1.3.1  整数的表达      1.3.2  字符的表达      1.3.3  小结    1.4  网络编程基础      1.4.1  网络编程是什么      1.4.2  IP地址和域名      1.4.3  端口的概念      1.4.4  数据传输方式      1.4.5  协议的概念      1.4.6  小结    1.5  Java语言简介      1.5.1  Java语言历史      1.5.2  Java程序开发过程      1.5.3  Java虚拟机介绍      1.5.4  其他  第2章  建立开发环境第3章  Java基础语法第4章  运算符  第5章  流程控制  第6章  数组  第7章  方法  第8章  面向对象  第9章  JDK文档使用  第10章  异常处理  第11章  I/O处理  第12章  多线程  第13章  网络编程  第14章  GUI界面编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java编程那些事儿
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 2图形设计――卷Ⅱ：SWING（附CD）
译者序
序
前言
第一部分 Swing基础
第1章 简介
1.1Swing的历史
1.2轻量组件与重量组件的比较
1.3Swing组件
1.3.1AWT的替代组件
1.3.2Swing增加的组件
1.4J组件
1.5Swing包概览
1.6Swing与AWT
1.7开始学习
1.8Swing资源
1.9本章回顾
第2章 Swing的基本知识
2.1小应用程序与应用程序
2.1.1小应用程序
2.1.2JApplet类
2.1.3应用程序
2.1.4JFrame类
2.1.5小应用程序/应用程序的组合
2.2GJApp
2.3混合使用Swing组件和AWT组件
2.3.1层序
2.3.2Swing弹出式菜单
2.3.3滚动
2.3.4内部窗体
2.4Swing和线程
2.4.1Swing单线程设计的结果
2.4.2SwingUtilities 类的invokeLater
和invokeAndWait方法
2.5本章回顾
第3章 Swing组件的体系结构
3.1典型的“模型－视图－控制器”体系
结构
3.1.1插入式视图和控制器
3.1.2视图更新
3.2SwingMVC
3.2.1Swing组件
3.2.2静态认识
3.2.3动态认识
3.2.4模型
3.2.5UI代表
3.2.6组件UI的案例
3.2.7监听器
3.3本章回顾
第4章 JComponent类
4.1JComponent类概览
4.1.1边框
4.1.2可访问性
4.1.3双缓存
4.1.4调试图形
4.1.5自动滚动
4.1.6工具提示
4.1.7键击处理和客户属性
4.2JComponent类结构
4.2.1Swing组件是AWT容器
4.2.2最小尺寸 最大尺寸和首选
尺寸
4.3绘制JComponent组件
4.3.1Swing组件中的定制绘制
4.3.2在AWT组件中重载绘制方法
4.3.3在Swing组件中重载绘制方法
4.3.4painT、repaint和update方法
4.3.5validate、invalidate和revalidate
方法
4.3.6不透明组件与透明组件的比较
4.3.7立即绘制Swing组件
4.4双缓存
4.5调试图形
4.6自动滚动
4.7工具提示
4.7.1基于鼠标位置的工具提示
4.7.2工具提示的首选位置
4.7.3定制工具提示的行为
4.7.4定制工具提示的界面样式
4.8键击处理
4.9客户属性
4.10焦点管理
4.10.1JComponent的焦点属性
4.10.2焦点管理器
4.11支持可访问性
4.12本章回顾
第5章 边框、图标和动作
5.1边框
5.1.1边框和边衬
5.1.2Swing的边框类型
5.1.3不透明与透明之间的比较
5.1.4边框包
5.1.5边框接口
5.1.6AbstracBorder类
5.1.7边框库――共享边框
5.1.8替换内置边框
5.1.9实现定制边框
5.2图标
5.2.1把图标与组件相关联
5.2.2在组件中共享图标
5.2.3图像图标
5.2.4动画的图像图标
5.3动作
5.3.1作为控制中心点的动作
5.3.2动作常量
5.4本章回顾
第6章 实用工具
6.1计时器
6.2事件监听器列表
6.3Swing实用工具
6.4Swing常量
6.5BoxLayout和Box 类
6.5.1BoxLayout类
6.5.2Box类
6.6进度监视器
6.6.1ProgressMonitor
6.6.2Progress MonitorInputStream
6.7撤消/重复
6.7.1一个简单的撤消/重复样例
6.7.2UndoableEditSupport
6.7.3组合编辑
6.7.4UndoManager
6.7.5状态编辑
6.8本章回顾
第7章 插入式界面样式
7.1界面样式结构
7.1.1界面样式
7.1.2界面样式缺省值
7.1.3UI管理器
7.1.4UI资源
7.2Java界面样式
7.2.1客户属性
7.2.2主题
7.3附加UI
7.4本章回顾
第二部分Swing组件
第8章 标签与按钮
8.1JLabel与JButton
8.2JLabel
8.2.1内容排列
8.2.2文本的位置
8.2.3图标/文本间隙
8.2.4许可状态
8.2.5JLabel属 性
8.2.6JLabel事件
8.2.7JLabel类总结
8.3按钮
8.4JButton
8.4.1JButton属性
8.4.2JButton事件
8.4.3JButton类总结
8.4.4AWT兼容
8.5本章回顾
第9章 反转按钮、复选框和单选钮
9.1JToggleButton类
9.1.1JToggleButton属性
9.1.2JToggleButton事件
9.1.3JToggleButton类总结
9.1.4AWT兼容
9.2按钮组
9.3复选框
9.3.1JCheckBox属性
9.3.2JCheckBox事件
9.3.3JCheckBox类总结
9.4单选钮
9.4.1JRadioButton属性
9.4.2JRadioButton 事件
9.4.3JRadioButton类总结
9.4.4AWT兼容
9.5本章回顾
第10章 菜单和工具条
10.1菜单、菜单栏和工具条
10.2菜单和弹出式菜单
10.3JMenuItem
10.3.1菜单项快捷键和助记符键
10.3.2JMenuItem属性
10.3.3JMenuItem事件
10.3.4JMenuItem类总结
10.3.5AWT兼容
10.4JCheckBoxMenuItem
10.4.1JCheckBoxMenuItem属性
10.4.2JCheckBoxMenuItem事件
10.4.3JCheckBoxMenuItem类总结
10.4.4AWT兼容
10.5JRadioButtonMenuItem
10.5.1JRadioButt onMe nuItem 属性
10.5.2JRadioButtonMenuItem事件
10.5.3JRadioButtonMenuItem类
总结
10.5.4AWT兼容
10.6JMenu
10.6.1动态修改菜单
10.6.2右拉式菜单
10.6.3JMenu属性
10.6.4JMenu事件
10.6.5JMenu类总结
10.6.6AWT兼容
10.7菜单元素
10.8JPopu pMe nu
10.8.1弹出式菜单触发器
10.8.2轻量/中量/重量弹出式
菜单
10.8.3弹出式菜单调用者
10.8.4JPopupMenu属性
10.8.5JPopupMenu事件
10.8.6JPopupMenu类总结
10.8.7AWT兼容
10.9JMenuBar
10.9.1菜单栏菜单和组件
10.9.2JMenuBar属性
10.9.3JMenuBar事件
10.9.4JMenuBar类总结
10.9.5AWT兼容
10.10JToolBar
10.10.1滚过式工具条
10.10.2在工具条中使用动作
10.10.3浮动工具条
10.10.4位置固定的工具提示
10.10.5JToolBar属性
10.10.6JToolBar事件
10.10.7JToolBar类总结
10.10.8AWT兼容
10.11本章回顾
第11章 进度条、滑杆和分隔条
11.1JProgessBar
11.1.1进度条与线程
11.1.2JProges sBar属性
11.1.3JProgessBar事件
11.1.4JProgessBar类总结
11.1.5AWT兼容
11.2JSlider
11.2.1填充的滑杆
11.2.2滑杆间隔标记
11.2.3滑杆标签
11.2.4反转滑杆值
11.2.5滑杆的外延值
11.2.6JSlider属性
11.2.7JSlider事件
11.2.8JSlider类总结
11.2.9AWT兼容
11.3JSeparator
11.3.1分隔条与框
11.3.2JSeparator 属性
11.3.3JSeparator事件
11.3.4AWT兼容
11.4本章回顾
第12章 轻量容器
12.1JPan el
12.1.1JPanel的属性
12.1.2JPanel的事件
12.1.3JPanel类总结
12.1.4AWT兼容
12.2JRootPane
12.2.1RootPaneCotainer接口
12.2.2玻璃窗格
12.2.3内容窗格
12.2.4JRootPane属性
12.2.5JRooPane事件
12.2.6JRootPane类总结
12.2.7AWT兼容
12.3JLaye redPane
12.3.1回顾轻量组件的层序
12.3.2为组件分配层
12.3.3指定同一层中组件的位置
12.3.4使用拖动层
12.3.5JLay eredPane属性
12.3.6JLayeredPane类总结
12.3.7AWT兼容
12.4JTabbedPane
12.4.1选项卡的位置
12.4.2JTabbedPane的属性
12.4.3JTabbedPane事件
12.4.4JTabbedPane类总结
12.5JSplitPane类
12.5.1JSplitPane属性
12.5.2JSplitPane事件
12.5.3JSplitPane类总结
12.5.4AWT兼容
12.6本章回顾
第13章 滚动
13.1JViewport
13.1.1拖动视口中的视图
13.1.2使用scrollRectToV isible
方法
13.1.3JViewport属性
13.1.4JViewport事件
13.1.5JViewport类总结
13.1.6AWT兼容
13.2JScrollPane
13.2.1滚动窗格的头部
13.2.2滚动窗格的角部
13.2.3JScrollPane属性
13.2.4JScrollPane事件
13.2.5JScrollPane类总结
13.2.6AWT兼容
13.3Scrollable接口
13.4JScrollBar
13.4.1使用Swing的JScrollBar类进
行手动滚动
13.4.2块增量和单元增量
13.4.3JScrollBar属性
13.4.4JScrollBar事件
13.4.5JScrollBar类总结
13.4.6AWT兼容
13.5本章回顾
第14章 窗口和对话框
14.1JWindow
14.1.1JWindow属性
14.1.2JWindow类总结
14.1.3AWT兼容
14.2JDialog
14.2.1JDialog属性
14.2.2JDialog类总结
14.2.3AWT兼容
14.3JOptionPane
14.3.1内部窗体
14.3.2用JOptionPane静态方法创建
对话框
14.3.3消息对话框
14.3.4确认对话框
14.3.5输入对话框
14.3.6选项对话框
14.3.7JOptionPane属性
14.3.8JOptionPane事件
14.3.9JOptionPane类总结
14.3.10AWT兼容
14.4本章回顾
第15章 内部窗体和桌面窗格
15.1JInternalFrame
15.1.1jintertnalFrame属性
15.1.2JInternalFrame事件
15.1.3AWT兼容
15.2JDesktopPane
15.2.1JDesktopPane属性
15.2.2JDesktopPane事件
15.2.3JDesktopPane类总结
15.2.4AWT兼容
15.3DesktopManager
15.4本章回顾
第16章 选取器
16.1JFileChooser
16.1.1文件选取器类型
16.1.2可访问组件
16.1.3过滤文件类型
16.1.4文件视图
16.1.5多文件选取
16.1.6JFileCHOoser属性
16.1.7JFileChooser事件
16.1.8JFileChooser类总结
16.1.9AWT兼容
16.2JColorChooser
16.2.1在对话框中显示颜色
选取器
16.2.2定制颜色选取器
16.2.3JColorChooser属性
16.2.4JColorChooser事件
16.2.5JColorChooser类总结
16.2.6AWT兼容
16.3本章回顾
第17章 列表
17.1列表模型
17.1.1AbstractListModel
17.1.2DefaultListModel
17.2列表选取
17.3列表单元绘制器
17.3.1JList属性
17.3.2JList事件
17.3.3JList类总结
17.3.4AWT兼容
17.4本章回顾
第18章 组合框
181JComboBox与JList的比较
18.2JComboBox组件
18.3组合框模型
18.3.1ComboBoxModel
18.3.2MutableComboBoxModel
18.3.3DefaultComboBoxModel
18.4组合框单元绘制器
18.5组合框键选取管理器
18.5.1使用缺省键选取管理器
18.5.2定制键选取管理器
18.5.3程序式的键选取
18.6组合框编辑器
18.6.1JComboBox属性
18.6.2JCombo Box 事件
18.6.3JComboBox类总结
18.6.4AWT兼容
18.7本章回顾
第19章 表格
19.1表格和滚动
19.2表格模型
19.2.1表格数据模型
19.2.2TableModel接口
19.2.3AbstractTableModel
19.2.4DefaultTableModel
19.2.5表格模型、缺省绘制器
和缺省编辑器
19.3表格列
19.3.1列调整大小模式
19.3.2列宽度
19.4表格列模型
19.4.1DefaultTableColumnModel类
19.4.2列边距
19.4.3隐藏列
19.4.4锁定左边列
19.5表格选取
19.6绘制和编辑
19.6.1使用表格单元绘制器和编
辑器
19.6.2表格单元绘制器
19.6.31DefaultTableCellRenderer
类
19.6.4表格格式化绘制器
19.6.5单元编辑器
19.6.6表格单元编辑器
19.6.7实现TableCellEditor接口
19.7表格行
19.7.1行高
19.7.2绘制行
19.8表格装饰器
19.9表格头部
19.9.1JTableHeader
19.9.2列头部绘制器和头部工具
提示
19.9.3JTable属性
19.9.4表格事件
19.9.5表格模型事件
19.9.6TableColumnModel事件
19.9.7列表选取事件
19.9.8JTable类总结
19.9.9AWT兼容
19.10本章回顾
第20章 树
20.1创建树
20.2树节点
20.2.1TreeNode接口
20.2.2MutableTreeNode接口
20.2.3DefaultMutableTreeNode类
20.3树路径
20.4树模型
20.5树选取
20.6树单元绘制
20.6.1DefaultTreeCellRenderer
20.6.2Metal界面样式
20.6.3根节点和根句柄
20.7树单元编辑
20.7.1扩展DefaultCellEditor
20.7.2DefaultTreeCellEditor
20.8绘制和编辑：学习一个样例
20.8.1Test类
20.8.2SelectableFile类和FileNode
类
20.8.3绘制器
20.8.4编辑器
20.8.5JTree属性
20.8.6树事件
20.8.7JTree类总结
20.8.8AWT兼容
20.9本章回顾
第21章 文本基础
21.1Swing文本组件
21.2动作
21.2.1文本动作
21.2.2动作和编辑工具包
21.3键映射
21.4文档
21.4.1定制文档
21.4.2文档监听器
21.5加字符与加重器
21.5.1加字符
21.5.2加字符监听器
21.5.3定制加字符
21.5.4加重器
21.6撤销/恢复
21.7JTextComponent
21.8本章回顾
第22章 文本组件
22.1JTexlField
22.1.1水平可视性和滚动偏移
22.1.2布局单行文本域
22.1.3使单行文本域有效
22.1.4JTextField组件总结
22.1.5JTextField属性
22.1.6JTextField事件
22.1.7JTextField类总结
22.1.8AWT兼容
22.2JPasswordField
22.2.1JPasswordField组件总结
22.2.2JPasswordFi eld属性
22.2.3JPasswordField类总结
22.3JTextArea
22.3.1JTextArea组件总结
22.3.2JTextArea属性
22.3.3JTextArea类总结
22.3.4AWT兼容
22.4JEditorPane
22.4.1JEditorPane属性
22.4.2JEditorPane事件
22.4.3JEditorPane类总结
22.5JTextPane
22.5.1嵌入图标和组件
22.5.2用属性标记内容
22.5.3JTextPane属性
22.5.4JTextPane类总结
22.6AWT兼容
22.7本章回顾
第23章 定制文本组件
23.1概览
23.2属性集和风格常量
23.3定制动作
23.4视图
23.5风格和风格的相关内容
23.6元素
23.7本章回顾
第三部分 附录
附录A 类图
附录B 插入式界面样式常量

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 2图形设计――卷Ⅱ：SWING（附CD）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java教程(第4版)
第1章 入门
1.1 Java技术现象
1.2 “Hello World!”应用程序
1.3 分析“Hello World!”应用程序
1.4 常见问题（和解决方案）
问题和练习：入门
第2章 面向对象的编程概念
2.1 对象是什么
2.2 类是什么
2.3 继承是什么
2.4 接口是什么
2.5 包是什么
问题和练习：面向对象的编程概念
第3章 语言基础
3.1 变量
问题和练习：变量
3.2 操作符
问题和练习：操作符
3.3 表达式、语句和块
问题和练习：表达式、语句和块
3.4 控制流语句
问题和练习：控制流语句
第4章 类和对象
4.1 类
4.2 对象
4.3 关于类的更多介绍
问题和练习：类
问题和练习：对象
4.4 嵌套类
问题和练习：嵌套类
4.5 枚举类型
问题和练习：枚举类型
4.6 注解
问题和练习：注解
第5章 接口和继承
5.1 接口
问题和练习：接口
5.2 继承
问题和练习：继承
第6章 泛型
6.1 简介
6.2 泛型类型
6.3 泛型方法和构造器
6.4 受限类型参数
6.5 子类型化
6.6 通配符
6.7 类型擦除
6.8 泛型小结
问题和练习：泛型
第7章 包
7.1 创建和使用包
问题和练习：创建和使用包
第8章 数字和字符串
8.1 数字
问题和练习：数字
8.2 字符
8.3 字符串
问题和练习：字符和字符串
第9章 异常
9.1 异常是什么
9.2 捕获或者指定需求
9.3 捕获和处理异常
9.4 指定方法抛出的异常
9.5 如何抛出异常
9.6 关于不可控异常的争论
9.7 异常的优点
9.8 小结
问题和练习：异常
第10章 基本I/O
10.1 I/O流
10.2 文件I/O
10.3 新I/O包
10.4 小结
问题和练习：基本I/O
第11章 集合
11.1 集合简介
11.2 接口
问题和练习：接口
11.3 实现
问题和练习：实现
11.4 算法
11.5 定制集合实现
11.6 互操作性
第12章 并发
12.1 进程和线程
12.2 Thread对象
12.3 同步
12.4 活性
12.5 保护块
12.6 不可变对象
12.7 高级并发对象
12.8 推荐阅读
问题和练习：并发
第13章 正则表达式
13.1 简介
13.2 测试示例
13.3 字符串字面量
13.4 字符类
13.5 预定义字符类
13.6 量词
13.7 捕获组
13.8 边界匹配器
13.9 Pattern类的方法
13.10 Matcher类的方法
13.11 PatternSyntaxException类的方法
13.12 小结
13.13 附加资源
问题和练习：正则表达式
第14章 平台环境
14.1 配置工具
14.2 系统工具
14.3 PATH和CLASSPATH
问题和练习：平台环境
第15章 Swing
15.1 Swing包概述
15.2 Swing的特性
问题和练习：图形化用户界面
第16章 把程序打包到JAR文件中
16.1 使用JAR文件：基础
16.2 处理清单文件：基础
16.3 JAR文件的签名和验证
16.4 使用和JAR相关的API
问题和练习：JAR文件
第17章 Java Web Start
17.1 运行Java Web Start应用程序
17.2 部署Java Web Start应用程序
17.3 开发Java Web Start应用程序
17.4 JNLP API
17.5 Java Web Start和安全
17.6 常见的Java Web Start问题
问题和练习：Java Web Start
第18章 applet
18.1 applet入门
18.2 利用applet API的优势
18.3 编写applet时的考虑事项
18.4 完成applet
18.5 部署applet
18.6 解决常见的applet问题
问题和练习：Java applet
附录A Java语言关键字
附录B Java编程语言认证考试的准备
索引
本书配套资源
问题和练习答案（图灵网站下载）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java教程(第4版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE 6权威指南
目 　录
第一部分 　简介
第1章 　综述　　2
1.1 　Java EE 6平台新特性　　3
1.2 　Java EE应用模型　　3
1.3 　分布式多层应用　　4
1.3.1 　安全　　5
1.3.2 　Java EE组件　　5
1.3.3 　Java EE客户端　　5
1.3.4 　Web 组件　　7
1.3.5 　业务组件　　8
1.3.6 　企业信息系统层　　9
1.4 　Java EE容器　　9
1.4.1 　容器服务　　10
1.4.2 　容器类型　　10
1.5 　Web服务支持　　11
1.5.1 　XML　　12
1.5.2 　SOAP传输协议　　12
1.5.3 　WSDL标准格式　　12
1.6 　Java EE应用程序装配与部署　　13
1.7 　打包应用程序　　13
1.8 　开发中的角色分工　　14
1.8.1 　Java　EE产品提供商　　15
1.8.2 　工具提供商　　15
1.8.3 　应用组件提供商　　15
1.8.4 　应用程序装配者　　15
1.8.5 　应用程序部署者和管理员　　16
1.9 　Java EE 6 API　　 　16
1.9.1 　企业JavaBeans技术　　19
1.9.2 　Java Servlet 技术　　20
1.9.3 　JavaServer Faces 技术　　20
1.9.4 　JavaServer Pages 技术　　20
1.9.5 　JavaServer Pages 标准标签库　　21
1.9.6 　Java Persistence API　　 　21
1.9.7 　Java Transaction API　　21
1.9.8 　支持REST 式Web 服务的Java 　API　　 　21
1.9.9 　Managed Beans　　 　21
1.9.10 　Java EE 平台（JSR 299）的上下文与依赖注入　　22
1.9.11 　Java Dependency Injection（JSR 330）　　 　22
1.9.12 　Bean Validation　　22
1.9.13 　Java Message Service 　API　　22
1.9.14 　Java EE Connector 　架构　　22
1.9.15 　JavaMail API　　23
1.9.16 　Java 容器授权合约　　23
1.9.17 　Java 容器认证服务提供商接口　　23
1.10 　Java 标准版6.0中的Java EE6 API　　23
1.10.1 　Java Database ConnectivityAPI　　24
1.10.2 　Java 命名和目录接口API　　24
1.10.3 　JavaBeans ActivationFramework　　 　24
1.10.4 　Java XML API　　 　24
1.10.5 　Java XML 绑定架构　　25
1.10.6 　支持带附件的SOAP　消息API　　25
1.10.7 　基于XML 的Java WebServices 　API　　 　25
1.10.8 　Java 认证与授权服务　　25
1.11 　GlassFish 服务器工具　　26
第2章 　使用教程示例　　27
2.1 　必备软件　27
2.1.1 　Java 平台标准版（J2SE）　　27
2.1.2 　Java EE 6 SDK　　28
2.1.3 　Java EE 6教程组件　　28
2.1.4 　NetBeans 集成开发环境　　29
2.1.5 　Apache Ant　　 　30
2.2 　启动和关闭GlassFish服务器　　30
2.3 　启动管理控制台　　31
2.4 　启动和关闭Java DB服务器　　32
2.5 　构建示例　　32
2.6 　教程示例的目录结构　　32
2.7 　获取最新版的教程　　33
2.8 　调试Java EE应用　　33
2.8.1 　服务器日志　　33
2.8.2 　调试器　　34
第二部分 　Web层
第3章 　Web应用初步　　36
3.1 　Web应用　　36
3.2 　Web应用的生命周期　　37
3.3 　Web模块示例——hello1　　39
3.3.1 　hello1 Web模块分析　　40
3.3.2 　打包Web模块　　42
3.3.3 　部署Web模块　　43
3.3.4 　运行已部署的Web模块　　44
3.3.5 　查看已部署的Web模块　　44
3.3.6 　更新Web模块　　45
3.3.7 　动态加载　　45
3.3.8 　卸载Web模块　　46
3.4 　配置Web应用之hello2示例　　46
3.4.1 　映射URL到Web组件　　46
3.4.2 　hello2Web模块分析　　47
3.4.3 　构建、打包、部署以及运行
hello2 　应用　　48
3.4.4 　设置welcome文件　　 　49
3.4.5 　设置上下文以及初始化参数　　 　49
3.4.6 　映射错误信息到出错页面　　 　50
3.4.7 　资源引用声明　　 　51
3.5 　Web应用的更多信息　　 　52
第4章 　JSF技术　　 　54
4.1 　什么是JSF应用　　 　54
4.2 　JSF技术的优势　　 　55
4.3 　创建简单的JSF应用　　 　56
4.3.1 　开发后台bean　　　　57
4.3.2 　创建网页　　 　57
4.3.3 　映射FacesServlet实例　　 　58
4.3.4 　hello应用程序的生命周期　　 　58
4.4 　有关JSF技术的更多信息　　 　59
第5章 　Facelets介绍　　 　60
5.1 　什么是Facelets　　　　60
5.2 　开发简单的Facelets 　应用　　 　61
5.2.1 　创建Facelets 　应用　　 　61
5.2.2 　配置应用　　 　64
5.2.3 　构建、打包、部署以及运行guessnumber Facelets示例　　 　65
5.3 　模板化　　 　66
5.4 　复合组件　　 　68
5.5 　资源　　 　70
第6章 　表达式语言　　 　72
6.1 　EL综述　　 　72
6.2 　即时求值和延后求值语法　　 　73
6.2.1 　即时求值　　 　73
6.2.2 　延后求值　　 　73
6.3 　值表达式和方法表达式　　 　74
6.3.1 　值表达式　　 　74
6.3.2 　方法表达式　　 　77
6.4 　定义标签属性类型　　 　79
6.5 　文本表达式　　 　80
6.6 　运算符　　 　80
6.7 　保留字　　 　81
6.8 　EL 　表达式的例子　　 　81
第7章 　在网页中使用JSF技术　　83
7.1 　设置页面　　83
7.2 　使用HTML标签为页面添加组件　　84
7.2.1 　组件标签的通用属性　　85
7.2.2 　添加HTML 的head和body标签　　87
7.2.3 　添加表单组件　　88
7.2.4 　文本组件　　88
7.2.5 　使用命令型组件标签执行动作和导航　　92
7.2.6 　用h:graphicImage添加图像和图形　　93
7.2.7 　用h:panelGrid和h:panelGroup实现组件布局　　93
7.2.8 　显示选项组件　　94
7.2.9 　显示多项选择组件　　96
7.2.10 　使用f:selectItem和f:selectItems标签　　97
7.2.11 　使用数据绑定表组件　　98
7.2.12 　使用h:message和h:messages显示出错信息　　101
7.2.13 　使用h:button和h:link标签创建可加入收藏夹的URL　　 　102
7.2.14 　使用视图参数配置可加入收藏夹的URL　　 　102
7.2.15 　使用h:output标签实现资源再定位　　103
7.3 　核心标签　　104
第8章 　转换器、监听器和验证器　　106
8.1 　标准转换器　　106
8.1.1 　转换组件的值　　107
8.1.2 　DateTimeConverter　　 　108
8.1.3 　NumberConverter　　109
8.2 　为组件注册监听器　　110
8.2.1 　为组件注册一个值变更监听器　　110
8.2.2 　为组件注册动作监听器　　111
8.3 　标准验证器　　111
8.3.1 　验证组件的值　　112
8.3.2 　LongRange Validator　　 　112
8.4 　引用后台bean的方法　　112
8.4.1 　引用执行页面导航的方法　　113
8.4.2 　引用处理动作事件的方法　　113
8.4.3 　引用执行验证逻辑的方法　　114
8.4.4 　引用处理值变更事件的方法　　114
第9章 　用JSF技术开发Web 　应用　　115
9.1 　后台bean　　115
9.1.1 　创建后台bean　　115
9.1.2 　使用EL引用后台bean　　 　116
9.2 　为后台bean的属性编写代码　　117
9.2.1 　为绑定到组件值的属性编写代码　　118
9.2.2 　为绑定到组件实例的属性编写代码　　122
9.2.3 　为绑定到转换器、监听器以及验证器的属性编写代码　　123
9.3 　为后台bean的方法编写代码　　124
9.3.1 　编写处理导航的方法　　124
9.3.2 　编写处理动作事件的方法　　125
9.3.3 　编写执行验证的方法　　126
9.3.4 　编写处理值变更事件的方法　　126
9.4 　使用Bean验证　　127
第10章 　Java Servlet 技术　　130
10.1 　什么是servlet　　 　130
10.2 　servlet 生命周期　　131
10.2.1 　处理servlet 生命周期内的事件　　131
10.2.2 　处理servlet 错误　　132
10.3 　共享信息　　132
10.3.1 　有作用域的对象　　133
10.3.2 　控制对共享资源的并发访问　　133
10.4 　创建以及初始化servlet　　133
10.5 　编写service方法　　134
10.5.1 　从请求里提取信息　　134
10.5.2 　构造应答信息　　135
10.6 　过滤请求和应答　　136
10.6.1 　编程实现过滤器　　136
10.6.2 　通过编程定制请求和应答　　137
10.6.3 　设定过滤器映射　　138
10.7 　调用其他Web资源　　139
10.7.1 　在应答里包含其他资源　　139
10.7.2 　转交控制权给其他Web组件　　140
10.8 　访问Web上下文　　140
10.9 　维护客户端状态　　140
10.9.1 　访问会话　　141
10.9.2 　把对象关联到会话　　141
10.9.3 　会话管理　　141
10.9.4 　会话追踪　　142
10.10 　结束servlet　　142
10.10.1 　追踪服务请求　　142
10.10.2 　将关闭事件通知方法　　143
10.10.3 　妥善处理长时方法　　143
10.11 　mood示例应用　　144
10.11.1 　mood示例应用里的组件　　144
10.11.2 　构建、打包、部署以及运行mood 　示例　　144
10.12 　有关Java Servlet 技术的更多信息　　145
第三部分 　Web服务
第11 章 　Web服务简介　　148
11.1 　什么是Web服务　　148
11.2 　Web服务的类型　　148
11.2.1 　“重量级”的Web服务　　148
11.2.2 　REST式Web服务　　149
11.3 　Web服务类型的选用　　150
第12章 　用JAX-WS构建Web服务　　151
12.1 　用JAX-WS开发简单的Web服务和客户端　　152
12.1.1 　对JAX-WS端点的要求　　152
12.1.2 　编写服务端点实现类　　153
12.1.3 　构建、打包及部署服务　　153
12.1.4 　测试Web服务端点中的方法　　154
12.1.5 　简单的JAX-WS应用客户端　　 　155
12.1.6 　简单的JAX-WSWeb客户端　　 　156
12.2 　JAX-WS支持的类型　　 　159
12.3 　Web服务的互操作性与JAX-WS　　 　159
12.4 　有关JAX-WS的更多信息　　 　159
第13章 　用JAX-RS构建REST式Web服务　　 　160
13.1 　什么是REST式Web服务　　 　160
13.2 　创建一个REST 式根资源类　　 　161
13.2.1 　用JAX-RS开发REST式Web服务　　 　161
13.2.2 　JAX-RS应用概述　　 　162
13.2.3 　@Path注解和URI路径模板　　 　163
13.2.4 　响应HTTP资源　　 　165
13.2.5 　使用@Consumes和@Produces定制请求和应答　　 　167
13.2.6 　从请求里提取参数　　 　169
13.3 　JAX-RS的示例应用　　 　172
13.3.1 　REST式Web服务　　 　172
13.3.2 　rsvp示例应用　　 　174
13.3.3 　真实示例　　 　176
13.4 　有关JAX-RS的更多信息　　 　176
第四部分 　企业bean
第14章 　企业bean　　 　180
14.1 　什么是企业bean　　　　180
14.1.1 　使用企业bean的好处　　 　180
14.1.2 　何时使用企业bean　　 　181
14.1.3 　企业bean的类型　　 　181
14.2 　什么是会话bean　　　　181
14.2.1 　会话bean的类型　　 　181
14.2.2 　何时使用会话bean　　 　182
14.3 　什么是消息驱动bean　　 　183
14.3.1 　消息驱动bean与会话bean的区别　　 　183
14.3.2 　何时使用消息驱动bean　　184
14.4 　访问企业bean　　184
14.4.1 　在客户端中使用企业bean　　185
14.4.2 　远程还是本地访问　　185
14.4.3 　本地客户端　　186
14.4.4 　远程客户端　　187
14.4.5 　Web服务客户端　　188
14.4.6 　方法的参数和方法的访问　　189
14.5 　企业bean的内容　　189
14.5.1 　在EJB的JAR模块中打包企业bean　　189
14.5.2 　在WAR模块中打包企业bean　　190
14.6 　企业bean的命名规范　　191
14.7 　企业bean的生命周期　　191
14.7.1 　有状态会话bean的生命周期　　191
14.7.2 　无状态会话bean的生命周期　　192
14.7.3 　单件会话bean的生命周期　　193
14.7.4 　消息驱动bean的生命周期　　193
14.8 　有关企业bean的更多信息　　194
第15章 　企业bean应用初步　　195
15.1 　创建企业bean　　195
15.1.1 　编写企业bean 　的类　　195
15.1.2 　创建converter的Web客户端　　196
15.1.3 　构建、打包、部署及运行converter示例　　197
15.2 　修改Java EE应用　　198
第16章 　运行企业bean示例　　200
16.1 　cart 示例　　200
16.1.1 　业务接口　　201
16.1.2 　会话bean 类　　201
16.1.3 　@Remove 方法　　204
16.1.4 　辅助类　　204
16.1.5 　构建、打包、部署及运行cart示例　　204
16.2 　单件会话bean示例counter　　 　206
16.2.1 　创建单件会话bean　　 　206
16.2.2 　counter示例的架构　　209
16.2.3 　构建、打包、部署及运行counter示例　　211
16.3 　Web服务示例helloservice　　212
16.3.1 　Web服务端点的实现类　　212
16.3.2 　无状态会话bean的实现类　　213
16.3.3 　构建、打包、部署及测试helloservice示例　　213
16.4 　使用定时器服务　　214
16.4.1 　创建日历型定时器表达式　　215
16.4.2 　可编程定时器　　217
16.4.3 　自动定时器　　218
16.4.4 　取消及保存定时器　　219
16.4.5 　获得定时器的信息　　219
16.4.6 　事务和定时器　　219
16.4.7 　timersession示例　　219
16.4.8 　构建、打包、部署及运行timersession示例　　221
16.5 　处理异常　　222
第五部分 　Java EE 平台的上下文与依赖注入
第17章 　Java EE 平台的上下文与依赖注入入门　　226
17.1 　CDI概述　　227
17.2 　关于bean　　 　227
17.3 　关于托管bean　　 　228
17.4 　可注入对象bean　　 　228
17.5 　使用限定词　　229
17.6 　注入bean　　 　230
17.7 　使用作用域　　230
17.8 　为bean设定EL名称　　231
17.9 　增加存取方法　　232
17.10 　在Facelets页面中使用托管bean　　 　232
17.11 　使用Producer方法注入对象　　233
17.12 　配置CDI应用　　233
17.13 　有关CDI的更多信息　　234
第18 章 　运行简单的上下文与依赖注入示例　　235
18.1 　CDI示例simplegreeting　　 　235
18.1.1 　simplegreeting的源文件　　235
18.1.2 　Facelets模板和页面　　236
18.1.3 　配置文件　　237
18.1.4 　构建、打包、部署及运行CDI示例simplegreeting　　 　237
18.2 　CDI 示例guessnumber　　239
18.2.1 　guessnumber的源文件　　239
18.2.2 　Facelets页面　　243
18.2.3 　构建、打包、部署及运行CDI 示例guessnumber　　 　244
第六部分 　持久化
第19章 　Java Persistence API简介　　248
19.1 　实体　　248
19.1.1 　实体类的需求　　248
19.1.2 　实体类的持久化字段和属性　　249
19.1.3 　实体里的主键　　253
19.1.4 　实体关系的多样性　　254
19.1.5 　实体关系的方向性　　255
19.1.6 　实体里的可嵌入类　　256
19.2 　实体继承　　257
19.2.1 　抽象实体　　257
19.2.2 　映射超类　　258
19.2.3 　非实体超类　　258
19.2.4 　实体继承映射策略　　259
19.3 　管理实体　　261
19.3.1 　EntityManager接口　　261
19.3.2 　持久化单元　　264
19.4 　查询实体　　265
19.5 　有关Persistence的更多信息　　266
第20章 　运行Persistence示例　　267
20.1 　order应用　　267
20.1.1 　order示例中的实体关系　　267
20.1.2 　order应用里的主键　　269
20.1.3 　映射多个数据库表的实体　　 　272
20.1.4 　order应用里的级联操作　　 　272
20.1.5 　order应用里的BLOB和CLOB类型　　 　273
20.1.6 　order应用里的时间类型　　 　273
20.1.7 　管理order应用里的实体　　 　273
20.1.8 　构建、打包、部署以及运行order应用　　 　275
20.2 　roster应用　　 　276
20.2.1 　roster应用里的关系　　 　276
20.2.2 　roster应用里的实体继承关系　　 　277
20.2.3 　roster里的Criteria查询　　 　278
20.2.4 　roster应用里的自动建表特性　　 　280
20.2.5 　构建、打包、部署以及运行roster应用　　 　280
20.3 　address-book应用　　 　282
20.3.1 　address-book应用里的Bean验证约束　　 　282
20.3.2 　为address-book应用里的约束指定出错信息　　 　283
20.3.3 　验证JSF应用中输入的Contact数据　　 　283
20.3.4 　构建、打包、部署以及运行address-book应用　　 　284
第21章 　Java Persistence查询语言　　 　286
21.1 　查询语言术语　　 　286
21.2 　使用Java Persistence查询语言创建查询　　 　287
21.2.1 　查询里的命名参数　　 　287
21.2.2 　查询里的位置参数　　 　288
21.3 　查询语言的简要语法　　 　288
21.3.1 　选择语句　　 　288
21.3.2 　更新和删除语句　　 　289
21.4 　查询示例　　 　289
21.4.1 　简单查询　　 　289
21.4.2 　需定位到相关实体的查询　　 　290
21.4.3 　使用其他条件表达式的查询　　 　291
21.4.4 　批量更新和删除　　292
21.5 　查询语言语法全本　　293
21.5.1 　BNF 符号　　293
21.5.2 　Java Persistence查询语言的BNF 　语法　　293
21.5.3 　FROM语句　　297
21.5.4 　路径表达式　　300
21.5.5 　WHERE语句　　301
21.5.6 　SELECT语句　　309
21.5.7 　ORDER BY 语句　　310
21.5.8 　GROUP BY和HAVING语句　　311
第22章 　使用Criteria API构造查询　　312
22.1 　Criteria和Metamodel API概述　　312
22.2 　使用Metamodel API为实体类建模　　313
22.3 　使用Criteria API和Metamodel API创建类型安全的基本查询　　314
22.3.1 　创建Criteria查询　　315
22.3.2 　查询根　　315
22.3.3 　使用join查询关联关系　　316
22.3.4 　Criteria查询中的路径定位　　316
22.3.5 　过滤Criteria查询结果　　317
22.3.6 　处理Criteria查询结果　　319
22.3.7 　查询执行　　320
第七部分 　安全
第23章 　Java EE平台安全入门　　322
23.1 　Java EE安全性概述　　322
23.1.1 　简单的安全应用示例　　323
23.1.2 　安全机制的特性　　325
23.1.3 　应用安全的特征　　325
23.2 　安全机制　　326
23.2.1 　Java SE安全机制　　326
23.2.2 　Java EE安全机制　　327
23.3 　为容器增加安全性　　329
23.3.1 　用注解为应用增加安全性　　329
23.3.2 　用部署描述文件为应用增加安全性　　329
23.3.3 　使用编程式的安全机制　　330
23.4 　为GlassFish服务器增加安全性　　330
23.5 　使用域、用户、用户组和角色　　330
23.5.1 　什么是域、用户、用户组和角色　　331
23.5.2 　在GlassFish服务器中管理用户和用户组　　333
23.5.3 　设置安全角色　　334
23.5.4 　将角色映射至用户和用户组　　335
23.6 　使用SSL建立安全连接　　336
23.6.1 　验证及配置SSL　　337
23.6.2 　使用数字证书　　337
23.7 　有关安全性的更多信息　　339
第24章 　Web应用安全化入门　　341
24.1 　Web应用安全性概述　　341
24.2 　为Web应用增加安全性　　342
24.2.1 　设定安全限制　　343
24.2.2 　设定认证机制　　345
24.2.3 　声明安全角色　　350
24.3 　在Web应用中使用编程式安全机制　　351
24.3.1 　以编程方式实现用户认证　　351
24.3.2 　以编程方式检查发起者身份　　353
24.3.3 　编程安全性的代码示例　　353
24.3.4 　声明并关联角色引用　　354
24.4 　为Web应用增加安全性的示例　　355
24.4.1 　在servlet中使用基本认证的示例　　356
24.4.2 　在JSF中使用表单认证机制的示例　　359
第25章 　企业应用安全化入门　　363
25.1 　为企业bean增加安全性　　363
25.1.1 　使用声明方式为企业bean增加安全性　　365
25.1.2 　使用编程方式为企业bean增加安全性　　369
25.1.3 　用于身份传播的安全标识（run-as）　　370
25.1.4 　部署经过安全加固的企业bean　　371
25.2 　为企业bean增加安全性的一组示例　　371
25.2.1 　使用声明方式为企业bean增加安全性的示例　　371
25.2.2 　使用编程方式为企业bean增加安全性的示例　　375
25.3 　为应用客户端增加安全性　　377
25.3.1 　使用登录模块　　377
25.3.2 　使用编程式用户登录　　378
25.4 　为企业信息系统应用增加安全性　　378
25.4.1 　容器管理登录　　378
25.4.2 　组件管理登录　　379
25.4.3 　配置资源适配器安全性　　379
第八部分 　Java EE支持技术
第26章 　Java EE支持技术简介　　384
26.1 　事务　　384
26.2 　资源　　384
26.2.1 　Java EE连接器架构和资源适配器　　384
26.2.2 　Java Message Service API　　385
26.2.3 　Java数据库连接软件　　385
第27章 　事务　　386
27.1 　什么是事务　　386
27.2 　容器托管的事务　　387
27.2.1 　事务属性　　 　387
27.2.2 　回滚容器托管的事务　　 　390
27.2.3 　同步会话bean 的实例变量　　 　390
27.2.4 　容器托管事务里不允许使用的方法　　 　391
27.3 　bean托管事务　　 　391
27.3.1 　JTA事务　　 　392
27.3.2 　不提交的返回　　 　392
27.3.3 　bean托管事务里不允许使用的方法　　 　392
27.4 　事务超时　　 　392
27.5 　更新多个数据库中的数据　　 　393
27.6 　Web组件里的事务　　 　394
27.7 　有关事务的更多信息　　 　394
第28章 　资源连接　　 　395
28.1 　资源和JNDI命名　　 　395
28.2 　DataSource对象和连接池　　 　396
28.3 　资源注入　　 　397
28.3.1 　字段级别的注入方式　　 　398
28.3.2 　方法级别的注入方式　　 　398
28.3.3 　类级别的注入方式　　 　399
28.4 　资源适配器和契约　　 　399
28.4.1 　管理契约　　 　400
28.4.2 　通用工作上下文契约　　 　401
28.4.3 　外向型和内向型契约　　 　401
28.5 　元数据注解　　 　402
28.6 　公共客户端接口　　 　404
28.7 　参考资源　　 　404
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE 6权威指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java应用程序设计接口(下册)--窗口工具箱和applet
（下册）
前言
简短历史
关于Java丛书
API工作成员
关于Java包
参考资料
类层次图

第一章 java．awt包类
1．1 BorderLayout类
1．2 Button类
1．3 Canvas类
1．4 CardLayout类
1．5 Checkbox类
1．6 CheckboxGroup类
1．7 CheckboxMenuItem类
1．8 Choice类
1．9 Color类
1．10 Component类
l．11 Container类
1．12 Dialog类
1．13 Dimension类
1．14 Event类
1．15 FileDialog类
1．16 FlowLayout类
1．17 Font类
l．18 FontMetrics类
1．19 Frame类
1．20 Graphics类
l．21 GridBagConstraints类
1．22 GridBagLayout类
1．23 GridLayout类
1．24 Image类
1．25 Insets类
1．26 Label类
1．27 List类
1．28 MediaTracker类
1．29 Menu类
1．30 MenuBar类
l．31 MenuComponent类
1．32 MenuItem类
1．33 Panel类
1．34 Point类
l．35 Polygon类
l．36 Rectangle类
1．37 Scrollbar类
1．38 TextArea类
1．39 TextComponent类
1．40 TextField类
1．41 Toolkit类
1．42 Window类
接口（Interface）
1．43 LayoutManager接口
1．44 MenuContalner接口
异常（Exception）
1．45 AWTException类
错误（Error）
1．46 AWTError类

第二章 java．awt．image包类
2．1 ColorModel类
2．2 CropImageFilter类
2．3 DirectColorModel类
2．4 FilteredImageSource类
2．5 ImageFilter类
2．6 IndexColorModel类
2．7 MemoryImageSource类
2．8 PixelGrabber类
2．9 RGBImageFilter类
接口
2．10 ImageConsumer接口
2．11 ImageObserver接口
2．12 ImageProducer接口

第三章 java．awt．peer包接口
3．1 ButtonPeer接口
3．2 CanvasPeer接口
3．3 CheckboxMenuItemPeer接口
3．4 CheckboxPeer接口
3．5 CholcePeer接口
3．6 ComponentPeer接口
3．7 ContainerPeer接口
3．8 DlaglogPeer接口
3．9 FileDialogPeer接口
3．10 FramePeer接口
3．11 LabelPeer接口
3．12 ListPeer接口
3．13 MenuBarPeer接口
3．14 MenuComponentPeer接口
3．15 MenultemPeer接口
3．16 MenuPeer接口
3．17 PanelPeer接口
3．18 ScrollbarPeer接口
3．19 TextAreaPeer接口
3．20 TextComponentPeer接口
3．21 TextFieldPeer接口
3．22 WindowPeer接口

第四章 java．applet包类
4．1 Applet类接口
4．2 AppletContext接口
4．3 AppletStub接口
4．4 AudioClip接口



>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java应用程序设计接口(下册)--窗口工具箱和applet
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Maven实战
1. Maven简介
1.1 何为Maven
1.2 为什么需要Maven
1.3 Maven与极限编程
1.4 被误解的Maven
2. Maven安装
2.1 在Windows上安装Maven
2.2 在基于Unix的系统上安装Maven
2.3 安装目录分析
2.4 设置HTTP代理
2.5 安装m2eclipse
2.6 安装NetBeans Maven插件
2.7 Maven安装最佳实践
3. Hello World
3.1 编写POM
3.2 编写主代码
3.3 编写测试代码
3.4 打包和运行
3.5 使用Archetype生成项目骨架
3.6 m2eclipse简单使用
3.7 NetBeans Maven插件简单使用
4. 背景案例
4.1 简单的账户注册服务
4.2 需求阐述
4.3 简要设计
5. 坐标和依赖
5.1 何为Maven坐标
5.2 坐标详解
5.3 account-email
5.4 依赖的配置
5.5 依赖范围
5.6 传递性依赖
5.7 依赖调解
5.8 可选依赖
5.9 最佳实践
6. 仓库
6.1 何为Maven仓库
6.2 仓库的布局
6.3 仓库的分类
6.4 远程仓库的配置
6.5 快照版本
6.6 从仓库解析依赖的机制
6.7 镜像
6.8 仓库搜索服务
7. 生命周期和插件
7.1 何为生命周期
7.2 生命周期详解
7.3 插件目标
7.4 插件绑定
7.5 插件配置
7.6 获取插件信息
7.7 从命令行调用插件
7.8 插件解析机制
8. 聚合与继承
8.1 account-persist
8.2 聚合
8.3 继承
8.4 聚合与继承的关系
8.5 约定优于配置
8.6 反应堆
9. 使用 Nexus 创建私服
9.1 Nexus简介
9.2 安装Nexus
9.3 Nexus的仓库与仓库组
9.4 Nexus的索引与构件搜索
9.5 配置Maven从Nexus下载构件
9.6 部署构件至Nexus
9.7 Nexus的权限管理
9.8 Nexus的调度任务
9.9 其他私服软件
10. 使用 Maven 进行测试
10.1 account-captcha
10.2 maven-surefire-plugin简介
10.3 跳过测试
10.4 动态指定要运行的测试用例
10.5 包含与排除测试用例
10.6 测试报告
10.7 运行TestNG测试
10.8 重用测试代码
11. 使用 Hudson 进行持续集成
11.1 持续集成的作用、过程和优势
11.2 Hudson简介
11.3 安装Hudson
11.4 准备Subversion仓库
11.5 Hudson的基本系统设置
11.6 创建Hudson任务
11.7 监视Hudson任务状态
11.8 Hudson用户管理
11.9 邮件反馈
11.10 Hudson工作目录
12. 构建 Web 应用
12.1 Web项目的基本结构
12.2 account-service
12.3 account-web
12.4 使用jetty-maven-plugin进行测试
12.5 使用Cargo实现自动化部署
13. 版本管理
13.1 何为版本管理
13.2 Maven的版本号定义约定
13.3 主干、标签与分支
13.4 自动化版本发布
13.5 自动化创建分支
13.6 GPG签名
14. 灵活的构建
14.1 Maven属性
14.2 构建环境的差异
14.3 资源过滤
14.4 Maven Profile
14.5 Web资源过滤
14.6 在Profile中激活集成测试
15. 生成项目站点
15.1 最简单的站点
15.2 丰富项目信息
15.3 项目报告插件
15.4 自定义站点外观
15.5 创建自定义页面
15.6 国际化
15.7 部署站点
16. m2eclipse
16.1 m2eclipse简介
16.2 安装m2eclipse
16.3 新建Maven项目
16.4 导入Maven项目
16.5 执行mvn命令
16.6 访问Maven仓库
16.7 管理项目依赖
16.8 其它实用功能
17. 编写 Maven 插件
17.1 编写Maven插件的一般步骤
17.2 代码行统计Maven插件
17.3 Mojo标注
17.4 Mojo参数
17.5 错误处理和日志
17.6 测试Maven插件
18. Archetype
18.1 Archetype使用再叙
18.2 编写Archetype
18.3 Archetype Catalog
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Maven实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大话Java性能优化
第1章　性能调优策略概述	1
1.1　为什么需要调优	1
1.2　性能优化的参考因素	5
1.2.1　传统计算机体系的分歧	5
1.2.2　导致系统瓶颈的计算资源	7
1.2.3　程序性能衡量指标	8
1.2.4　性能优化目标	9
1.2.5　性能优化策略	10
1.3　性能调优分类方法	11
1.3.1　业务方面	12
1.3.2　基础技术方面	12
1.3.3　组件方面	17
1.3.4　架构方面	19
1.3.5　层次方面	20
1.4　本章小结	21
第2章　优化前的准备知识	22
2.1　服务器知识	23
2.1.1　内存	23
2.1.2　GPU/CPU	44
2.1.3　硬盘	49
2.1.4　网络架构	51
2.2　新兴技术	53
第3章　Java API调用优化建议	54
3.1　面向对象及基础类型	55
3.1.1　采用Clone()方式创建对象	55
3.1.2　避免对boolean判断	55
3.1.3　多用条件操作符	56
3.1.4　静态方法代替实例方法	56
3.1.5　有条件地使用final关键字	58
3.1.6　避免不需要的instanceof操作	58
3.1.7　避免子类中存在父类转换	59
3.1.8　建议多使用局部变量	60
3.1.9　运算效率最高的方式——位运算	60
3.1.10　用一维数组代替二维数组	62
3.1.11　布尔运算代替位运算	64
3.1.12　提取表达式优化	65
3.1.13　不要总是使用取反操作符(!)	66
3.1.14　不要重复初始化变量	66
3.1.15　变量初始化过程思考	66
3.1.16　对象的创建、访问过程	69
3.1.17　在switch语句中使用字符串	70
3.1.18　数值字面量的改进	73
3.1.19　优化变长参数的方法调用	74
3.1.20　针对基本数据类型的优化	75
3.1.21　空变量	76
3.2　集合类概念	77
3.2.1　快速删除List里面的数据	78
3.2.2　集合内部避免返回null	80
3.2.3　ArrayList、LinkedList比较	82
3.2.4　Vector、HashTable比较	85
3.2.5　HashMap使用经验	87
3.2.6　EnumSet、EnumMap	91
3.2.7　HashSet使用经验	92
3.2.8　LinkedHashMap、TreeMap比较	96
3.2.9　集合处理优化新方案	99
3.2.10　优先考虑并行计算	107
3.3　字符串概念	108
3.3.1　String对象	108
3.3.2　善用String对象的SubString方法	111
3.3.3　用charat()代替startswith()	113
3.3.4　在字符串相加的时候，使用' '代替" "	114
3.3.5　字符串切割	114
3.3.6　字符串重编码	117
3.3.7　合并字符串	118
3.3.8　正则表达式不是万能的	122
3.4　引用类型概念	123
3.4.1　强引用（Strong Reference）	126
3.4.2　软引用（Soft Reference）	131
3.4.3　弱引用（Weak Reference）	135
3.4.4　引用队列	141
3.4.5　虚引用（Phantom Reference）	142
3.5　其他相关概念	146
3.5.1　JNI技术提升	146
3.5.2　异常捕获机制	150
3.5.3　ExceptionUtils类	154
3.5.4　循环技巧	155
3.5.5　替换switch	157
3.5.6　优化循环	158
3.5.7　使用arrayCopy()	159
3.5.8　使用Buffer进行I/O操作	161
3.5.9　使用clone()代替new	164
3.5.10　I/O速度	166
3.5.11　Finally方法里面释放或者关闭资源占用	167
3.5.12　资源管理机制	167
3.5.13　牺牲CPU时间	169
3.5.14　对象操作	172
3.5.15　正则表达式	172
3.5.16　压缩文件处理	174
3.6　本章小结	175
第4章　程序设计优化建议	176
4.1　算法优化概述	176
4.1.1　常用算法逻辑描述	177
4.1.2　多核算法优化原理	186
4.1.3　Java算法优化实践	188
4.2　设计模式	196
4.2.1　设计模式的六大准则	196
4.2.2　单一对象控制	200
4.2.3　并行程序设计模式	202
4.2.4　接口适配	205
4.2.5　访问方式隔离	219
4.3　I/O及网络相关优化	225
4.3.1　I/O操作优化	225
4.3.2　Socket编程	231
4.3.3　NIO2.0文件系统	235
4.4　数据应用优化	236
4.4.1　关系型数据库优化	236
4.4.2　向HBase插入大量数据	240
4.4.3　解决海量数据缓存	251
4.5　其他优化	256
4.5.1　Web系统性能优化建议	256
4.5.2　死锁情况解决方案	259
4.5.3　JavaBeans组件	268
4.6　本章小结	269
第5章　Java并行程序优化建议	270
5.1　并行程序优化概述	270
5.1.1　资源限制带来的挑战	271
5.1.2　进程、线程、协程	272
5.1.3　使用多线程的原因	281
5.1.4　线程不安全范例	282
5.1.5　重排序机制	284
5.1.6　实例变量的数据共享	286
5.1.7　生产者与消费者模式	288
5.1.8　线程池的使用	290
5.2　锁机制对比	296
5.2.1　锁机制概述	296
5.2.2　Synchronized使用技巧	298
5.2.3　Volatile的使用技巧	303
5.2.4　队列同步器	304
5.2.5　可重入锁	307
5.2.6　读写锁	308
5.2.7　偏向锁和轻量级锁	309
5.3　增加程序并行性	310
5.3.1　并发计数器	311
5.3.2　减少上下文切换次数	312
5.3.3　针对Thread类的更新	314
5.3.4　Fork/Join框架	314
5.3.5　Executor框架	318
5.4　JDK类库使用	319
5.4.1　原子值	320
5.4.2　并行容器	324
5.4.3　非阻塞队列	332
5.4.4　阻塞队列	338
5.4.5　并发工具类	365
5.5　本章小结	376
第6章　JVM性能测试及监控	377
6.1　监控计算机设备层	378
6.1.1　监控CPU	380
6.1.2　监控内存	405
6.1.3　监控磁盘	417
6.1.4　监控网络	423
6.2　监控JVM活动	428
6.2.1　监控垃圾收集目的	429
6.2.2　GC垃圾回收报告分析	430
6.2.3　图形化工具	431
6.2.4　GC跟踪示例	437
6.3　本章小结	438
第7章　JVM性能调优建议	439
7.1　JVM相关概念	439
7.1.1　内存使用相关概念	440
7.1.2　字节码相关知识	443
7.1.3　自动内存管理	448
7.2　JVM系统架构	451
7.2.1　JVM的基本架构	451
7.2.2　JVM初始化过程	453
7.2.3　JVM架构模型与执行引擎	456
7.2.4　解释器与JIT编译器	456
7.2.5　类加载机制	457
7.2.6　虚拟机	458
7.3　垃圾回收机制相关	459
7.3.1　GC相关概念	459
7.3.2　垃圾回收算法	468
7.3.3　垃圾收集器	476
7.4　实用JVM实验	490
7.4.1　将新对象预留在年轻代	490
7.4.2　大对象进入年老代	494
7.4.3　设置对象进入年老代的年龄	495
7.4.4　稳定与震荡的堆大小	497
7.4.5　吞吐量优先案例	498
7.4.6　使用大页案例	499
7.4.7　降低停顿案例	499
7.4.8　设置最大堆内存	499
7.4.9　设置最小堆内存	500
7.4.10　设置年轻代	503
7.4.11　设置持久代	504
7.4.12　设置线程栈	504
7.4.13　堆的比例分配	505
7.4.14　堆分配参数总结	508
7.4.15　垃圾回收器相关参数总结	509
7.4.16　查询GC命令	515
7.5　本章小结	515
第8章　其他优化建议	516
8.1　Java现有机制及未来发展	516
8.1.1　Java体系结构变化历史	516
8.1.2　Java语言面临的挑战	520
8.1.3　Java8的新特性	522
8.1.4　Java语言前景	523
8.1.5　物联网：Java和你是一对	524
8.1.6　Java模块化发展	525
8.1.7　OpenJDK的发展	527
8.2　系统架构优化建议	528
8.2.1　系统架构调优	528
8.2.2　Java项目优化方式分享	530
8.2.3　面向服务架构	534
8.2.4　程序隔离技术	538
8.2.5　团队并行开发准则	544
8.3　与编程无关	546
8.3.1　工程师品格	546
8.3.2　如何成为技术大牛	547
8.3.3　编程方法分享	548
8.4　本章小结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大话Java性能优化
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 7编程高级进阶
第1章　Java简介
1.1　为什么使用Java
1.2　什么是Java
1.3　Java虚拟机
1.4　Java特性
1.4.1　体积小
1.4.2　简单.易学
1.4.3　面向对象
1.4.4　兼具编译与解释特性
1.4.5　平台无关
1.4.6　鲁棒且安全
1.4.7　支持多线程
1.4.8　动态特性
1.5　Java的演变过程
1.5.1　JDK　1.0（1996年1月23日）：代号0ak
1.5.2　JDK　1.1（1997年2月19日）
1.5.3　JDK　1.2（1998年12月8日）：代号Playground
1.5.4　JDK　1.3（2000年5月8日）：代号Kestre1
1.5.5　JDK　1.4（2002年2月6日）：代号Merlin
1.5.6　JDK　5.0（2004年9月30日）：代号Tiger
1.5.7　JDK　SE　6（2006年12月11日）：代号Mustang
1.5.8　JDK　SE　7（2011年7月7日）：代号Dolphin
1.6　小结

第2章　数组
2.1　数组
2.1.1　声明数组
2.1.2　创建数组
2.1.3　访问和修改数组元素
2.2　初始化数组
2.2.1　在运行时初始化
2.2.2　使用数组字面量初始化
2.3　for-each循环
2.4　多维数组
2.4.1　二维数组
2.4.2　初始化二维??br /> 　2.4.3　使用for-each结构进行循环
2.5　n维数组
2.6　非矩形数组
2.7　几样好东西
2.7.1　确定数组长度
2.7.2　复制数组
2.7.3　找出数组的类表示
2.8　小结

第3章　类
3.1　面向对象的概念
3.1.1　面向对象编程的特性
3.1.2　面向对象编程的好处
3.2　类
3.2.1　定义类
3.2.2　定义Point类
3.2.3　使用类
3.2.4　访问／修改字段
3.2.5　类的示例程序
3.2.6　声明方法
3.2.7　对象的内存表示
3.3　信息隐藏
3.4　封装
3.5　声明构造函数
3.5.1　默认构造函数
3.5.2　构造函数的定义规则
3.6　源文件布局
3.6.1　package语句
3.6.2　import语句
3.7　目录布局和包
3.8　小结

第4章　继承
4.1　为什么需要继承
4.2　什么是继承
4.3　定义单级继承
4.3.1　多级继承介绍
4.3.2　编写多级继承程序
4.4　多态
4.4.1　创建异构对象集合
4.4.2　展示异构集合的程序示例
4.4.3　检测对象类型
4.4.4　继承层次结构中的类型转换规则
4.4.5　防止方法重写
4.4.6　防止子类化
4.5　小结

第5章　对象创建与成员可见性
5.1　实例化子类
5.1.1　对象的创建过程
5.1.2　调用超类构造函数
5.1.3　方法重载
5.1.4　方法重载的规则
5.2　创建复制构造函数
5.3　final关键字
5.3.1　final类
5.3.2　final方法
5.3.3　final变量
5.3.4　final类变量
5.4　理解对象可见性规则
5.4.1　public修饰符
5.4.2　private修饰符
5.4.3　protected修饰符
5.4.4　默认修饰符
5.4.5　关于继承的一些规则
5.5　小结

第6章　static修饰符和接口
6.1　static关键字
6.1.1　静态字段
6.1.2　静态方法
6.1.3　静态初始化器
6.2　接口
6.2.1　现实生活中的接口示例
6.2.2　理解接口语法
6.2.3　通过示例理解接口
……
第7章　嵌套类
第8章　异常处理
第9章　Java　I／O
第10章　高级I／O
第11章　枚举、自动装箱和注解
第12章　泛型
第13章　事件处理和构建GUI
第14章　创建布局
第15章　图形和用户手势处理
第16章　集合框架
第17章　线程
第18章　阻塞队列和同步器
第19章　Callable.　Future.　Executors与分支，合并框架
第20章　网络编程
第21章　工具类
附录　Java标准语法参考——Java语言结构操作符、控制流
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 7编程高级进阶
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web从入门到精通
目  录
第1篇  Web开发基础
第1章  Java Web应用开发概述	3
视频讲解：18分钟
1.1  程序开发体系结构	4
1.1.1  C/S体系结构介绍	4
1.1.2  B/S体系结构介绍	4
1.1.3  两种体系结构的比较	5
1.2  Web应用程序的工作原理	5
1.3  Web应用技术	6
1.3.1  客户端应用的技术	7
1.3.2  服务器端应用的技术	9
1.4  了解Java Web成功案例	10
1.5  常用网上资源	11
1.5.1  常用资源下载网	11
1.5.2  技术社区	12
1.6  小结	12
第2章  HTML与CSS网页开发基础	13
视频讲解：1小时2分钟
2.1  HTML标记语言	14
2.1.1  创建第一个HTML文件	14
2.1.2  HTML文档结构	15
2.1.3  HTML常用标记	16
2.1.4  表格标记	19
2.1.5  HTML表单标记	21
2.1.6  超链接与图片标记	26
2.2  HTML5新增内容	28
2.2.1  新增的元素	28
2.2.2  新增的input元素类型	29
2.3  CSS样式表	30
2.3.1  CSS规则	30
2.3.2  CSS选择器	31
2.3.3  在页面中包含CSS	33
2.4  CSS 3的新特征	35
2.4.1  模块与模块化结构	35
2.4.2  一个简单的CSS 3实例	36
2.5  小结	38
2.6  实践与练习	38
第3章  JavaScript脚本语言	39
视频讲解：1小时39分钟
3.1  了解JavaScript	40
3.1.1  什么是JavaScript	40
3.1.2  JavaScript的主要特点	40
3.2  JavaScript语言基础	41
3.2.1  JavaScript的语法	41
3.2.2  JavaScript中的关键字	42
3.2.3  JavaScript的数据类型	42
3.2.4  变量的定义及使用	45
3.2.5  运算符的应用	46
3.3  流程控制语句	49
3.3.1  if条件语句	49
3.3.2  switch多分支语句	52
3.3.3  for循环语句	54
3.3.4  while循环语句	55
3.3.5  do…while循环语句	57
3.3.6  break与continue语句	58
3.4  函数	59
3.4.1  函数的定义	59
3.4.2  函数的调用	60
3.5  事件处理	61
3.5.1  什么是事件处理程序	61
3.5.2  JavaScript常用事件	61
3.5.3  事件处理程序的调用	62
3.6  常用对象	63
3.6.1  Window对象	63
3.6.2  String对象	67
3.6.3  Date对象	71
3.7  DOM技术	73
3.7.1  DOM的分层结构	73
3.7.2  遍历文档	74
3.7.3  获取文档中的指定元素	76
3.7.4  操作文档	77
3.8  小结	79
3.9  实践与练习	79
第4章  搭建开发环境	81
视频讲解：19分钟
4.1  Java Web应用的开发环境概述	82
4.2  Tomcat的安装与配置	82
4.2.1  下载Tomcat	82
4.2.2  Tomcat的目录结构	84
4.2.3  修改Tomcat的默认端口	84
4.2.4  部署Web应用	84
4.3  Eclipse的下载与使用	85
4.3.1  Eclipse的下载与安装	85
4.3.2  启动Eclipse	87
4.3.3  Eclipse工作台	87
4.3.4  使用Eclipse开发Web应用	88
4.4  小结	93
4.5  实践与练习	93
第2篇  JSP语言基础
第5章  JSP基本语法	97
视频讲解：30分钟
5.1  了解JSP页面	98
5.2  指令标识	99
5.2.1  page指令	100
5.2.2  include指令	102
5.2.3  taglib指令	104
5.3  脚本标识	104
5.3.1  JSP表达式	105
5.3.2  声明标识	105
5.3.3  代码片段	106
5.4  JSP注释	107
5.4.1  HTML中的注释	107
5.4.2  带有JSP表达式的注释	108
5.4.3  隐藏注释	110
5.4.4  动态注释	111
5.5  动作标识	111
5.5.1  包含文件标识<jsp:include>	111
5.5.2  请求转发标识<jsp:forward>	114
5.5.3  传递参数标识<jsp:param>	116
5.6  小结	116
5.7  实践与练习	117
第6章  JSP内置对象	119
视频讲解：1小时18分钟
6.1  JSP内置对象的概述	120
6.2  request对象	120
6.2.1  访问请求参数	120
6.2.2  在作用域中管理属性	122
6.2.3  获取cookie	123
6.2.4  解决中文乱码	125
6.2.5  获取客户端信息	126
6.2.6  显示国际化信息	127
6.3  response对象	128
6.3.1  重定向网页	128
6.3.2  处理HTTP文件头	129
6.3.3  设置输出缓冲	130
6.4  session对象	131
6.4.1  创建及获取客户的会话	131
6.4.2  从会话中移动指定的绑定对象	132
6.4.3  销毁session	132
6.4.4  会话超时的管理	132
6.4.5  session对象的应用	133
6.5  application对象	135
6.5.1  访问应用程序初始化参数	135
6.5.2  管理应用程序环境属性	136
6.6  out对象	136
6.6.1  向客户端输出数据	137
6.6.2  管理响应缓冲	138
6.7  其他内置对象	138
6.7.1  获取会话范围的pageContext对象	138
6.7.2  读取web.xml配置信息的config对象	139
6.7.3  应答或请求的page对象	139
6.7.4  获取异常信息的exception对象	140
6.8  小结	142
6.9  实践与练习	142
第7章  JavaBean技术	143
视频讲解：42分钟
7.1  JavaBean介绍	144
7.1.1  JavaBean概述	144
7.1.2  JavaBean种类	145
7.2  JavaBean的应用	148
7.2.1  获取JavaBean属性信息	148
7.2.2  对JavaBean属性赋值	150
7.2.3  如何在JSP页面中应用JavaBean	151
7.3  在JSP中应用JavaBean	154
7.3.1  解决中文乱码的JavaBean	155
7.3.2  在JSP页面中用来显示时间的JavaBean	158
7.3.3  数组转换成字符串	160
7.4  小结	164
7.5  实践与练习	164
第8章  Servlet技术	165
视频讲解：28分钟
8.1  Servlet基础	166
8.1.1  Servlet结构体系	166
8.1.2  Servlet技术特点	166
8.1.3  Servlet与JSP的区别	167
8.1.4  Servlet代码结构	168
8.2  Servlet API编程常用接口和类	169
8.2.1  Servlet接口	169
8.2.2  ServletConfig接口	170
8.2.3  HttpServletRequest接口	170
8.2.4  HttpServletResponse接口	171
8.2.5  GenericServlet类	171
8.2.6  HttpServlet类	172
8.3  Servlet开发	172
8.3.1  Servlet创建	172
8.3.2  Servlet配置	173
8.4  小结	175
8.5  实践与练习	175
第9章  过滤器和监听器	177
视频讲解：44分钟
9.1  Servlet过滤器	178
9.1.1  什么是过滤器	178
9.1.2  过滤器核心对象	179
9.1.3  过滤器创建与配置	180
9.1.4  字符编码过滤器	183
9.2  Servlet监听器	188
9.2.1  Servlet监听器简介	188
9.2.2  Servlet监听器的原理	188
9.2.3  Servlet上下文监听	188
9.2.4  HTTP会话监听	189
9.2.5  Servlet请求监听	190
9.2.6  Servlet监听器统计在线人数	191
9.3  Servlet 3.0新特性	194
9.3.1  新增注释	194
9.3.2  对文件上传的支持	199
9.3.3  异步处理	201
9.4  小结	201
9.5  实践与练习	202


第3篇  JSP高级内容
第10章  Java Web的数据库操作	205
视频讲解：1小时1分钟
10.1  JDBC技术	206
10.1.1  JDBC简介	206
10.1.2  JDBC连接数据库的过程	206
10.2  JDBC API	208
10.2.1  Connection接口	208
10.2.2  DriverManager类	209
10.2.3  Statement接口	210
10.2.4  PreparedStatement接口	211
10.2.5  ResultSet接口	212
10.3  JDBC操作数据库	213
10.3.1  添加数据	213
10.3.2  查询数据	216
10.3.3  修改数据	220
10.3.4  删除数据	222
10.3.5  批处理	224
10.3.6  调用存储过程	227
10.4  JDBC在Java Web中的应用	230
10.4.1  开发模式	230
10.4.2  分页查询	231
10.5  小结	237
10.6  实践与练习	237
第11章  EL（表达式语言）	239
视频讲解：53分钟
11.1  EL（表达式语言）概述	240
11.1.1  EL的基本语法	240
11.1.2  EL的特点	240
11.2  与低版本的环境兼容——禁用EL	241
11.2.1  使用斜杠“\”符号	241
11.2.2  使用page指令	241
11.2.3  在web.xml文件中配置<el-ignored>
元素	242
11.3  保留的关键字	242
11.4  EL的运算符及优先级	243
11.4.1  通过EL访问数据	244
11.4.2  在EL中进行算术运算	245
11.4.3  在EL中判断对象是否为空	246
11.4.4  在EL中进行逻辑关系运算	246
11.4.5  在EL中进行条件运算	248
11.5  EL的隐含对象	249
11.5.1  页面上下文对象	249
11.5.2  访问作用域范围的隐含对象	251
11.5.3  访问环境信息的隐含对象	253
11.6  定义和使用EL函数	255
11.6.1  定义和使用函数	255
11.6.2  定义和使用EL函数时常见的错误	257
11.7  小结	259
11.8  实践与练习	259
第12章  JSTL标签	261
视频讲解：1小时2分钟
12.1  JSTL标签库简介	262
12.2  JSTL的配置	263
12.3  表达式标签	265
12.3.1  <c:out>输出标签	265
12.3.2  <c:set>变量设置标签	267
12.3.3  <c:remove>变量移除标签	269
12.3.4  <c:catch>捕获异常标签	271
12.4  URL相关标签	272
12.4.1  <c:import>导入标签	272
12.4.2  <c:url>动态生成URL标签	274
12.4.3  <c:redirect>重定向标签	276
12.4.4  <c:param>传递参数标签	276
12.5  流程控制标签	277
12.5.1  <c:if>条件判断标签	278
12.5.2  <c:choose>条件选择标签	279
12.5.3  <c:when>条件测试标签	280
12.5.4  <c:otherwise>其他条件标签	282
12.6  循环标签	283
12.6.1  <c:forEach>循环标签	283
12.6.2  <c:forTokens>迭代标签	286
12.7  小结	287
12.8  实践与练习	287
第13章  Ajax技术	289
视频讲解：1小时3分钟
13.1  当下谁在用Ajax	290
13.1.1  百度搜索提示	290
13.1.2  淘宝新会员免费注册	290
13.1.3  明日科技编程词典服务网	290
13.2  Ajax开发模式与传统开发模式的
比较	291
13.3  Ajax使用的技术	292
13.4  使用XMLHttpRequest对象	294
13.4.1  初始化XMLHttpRequest对象	294
13.4.2  XMLHttpRequest对象的常用方法	295
13.4.3  XMLHttpRequest对象的常用属性	297

13.5  与服务器通信——发送请求与处理
响应	298
13.5.1  发送请求	298
13.5.2  处理服务器响应	300
13.5.3  一个完整的实例——检测用户名是否
唯一	301
13.6  解决中文乱码问题	304
13.6.1  发送请求时出现中文乱码	304
13.6.2  获取服务器的响应结果时出现中文
乱码	305
13.7  Ajax重构	305
13.7.1  Ajax重构的步骤	305
13.7.2  应用Ajax重构实现实时显示公告信息	307
13.8  Ajax常用实例	308
13.8.1  级联下拉列表	308
13.8.2  显示进度条	312
13.9  小结	315
13.10  实践与练习	315
第4篇  流行框架与XML技术
第14章  Struts2基础	319
视频讲解：1小时5分钟
14.1  Struts2概述	320
14.1.1  理解MVC原理	320
14.1.2  Struts2框架的产生	321
14.1.3  Struts2的结构体系	321
14.2  Struts2入门	322
14.2.1  Struts2的获取与放置	322
14.2.2  第一个Struts2程序	323
14.3  Action对象	326
14.3.1  认识Action对象	326
14.3.2  请求参数的注入原理	327
14.3.3  Action的基本流程	327
14.3.4  什么是动态Action	328
14.3.5  动态Action的应用	329
14.4  Struts2的配置文件	331
14.4.1  Struts2的配置文件类型	331
14.4.2  Struts2的包配置	332
14.4.3  名称空间配置	332
14.4.4  Action相关配置	333
14.4.5  通配符实现简化配置	335
14.4.6  返回结果的配置	335
14.5  Struts2的开发模式	336
14.5.1  实现与Servlet API的交互	336
14.5.2  域模型DomainModel	337
14.5.3  驱动模型ModelDriven	338
14.6  典型应用	340
14.6.1  Struts2处理表单数据	340
14.6.2  使用Map类型的request、session和
application	343
14.7  小结	345
14.8  实践与练习	346
第15章  Struts2高级技术	347
视频讲解：54分钟
15.1  OGNL表达式语言	348
15.1.1  认识OGNL	348
15.1.2  Struts2框架中的OGNL	348
15.1.3  操作普通的属性与方法	350
15.1.4  访问静态方法与属性	353
15.1.5  访问数组	353
15.1.6  访问List、Set、Map集合	354
15.1.7  投影与选择	354
15.2  Struts2的标签库	355
15.2.1  数据标签的应用	355
15.2.2  控制标签的应用	359
15.2.3  表单标签的应用	361
15.3  拦截器的使用	362
15.3.1  了解拦截器	362
15.3.2  拦截器API	364
15.3.3  使用拦截器	365
15.4  数据验证机制	366
15.4.1  手动验证的实现	366
15.4.2  验证文件的命名规则	367
15.4.3  验证文件的编写风格	367
15.5  典型应用	369
15.5.1  Struts2标签下的用户注册	369
15.5.2  使用验证框架对数据校验	371
15.6  小结	373
15.7  实践与练习	373
第16章  Hibernate技术	375
视频讲解：42分钟
16.1  初识Hibernate	376
16.1.1  理解ORM原理	376
16.1.2  Hibernate简介	376
16.2  Hibernate入门	377
16.2.1  获取Hibernate	377
16.2.2  Hibernate配置文件	378
16.2.3  了解并编写持久化类	379
16.2.4  Hibernate映射	380
16.2.5  Hibernate主键策略	381
16.3  Hibernate数据持久化	382
16.3.1  Hibernate实例状态	382
16.3.2  Hibernate初始化类	383
16.3.3  保存数据	384
16.3.4  查询数据	385
16.3.5  删除数据	387
16.3.6  修改数据	388
16.3.7  关于延迟加载	388
16.4  使用Hibernate的缓存	389
16.4.1  一级缓存的使用	389
16.4.2  配置并使用二级缓存	390
16.5  小结	392
16.6  实践与练习	392
第17章  Hibernate高级应用	393
视频讲解：1小时12分钟
17.1  实体关联关系映射	394
17.1.1  数据模型与领域模型	394
17.1.2  理解并配置多对一单向关联	394
17.1.3  理解并配置多对一双向关联	396
17.1.4  理解并配置一对一主键关联	398
17.1.5  理解并配置一对一外键关联	399
17.1.6  理解并配置多对多关联关系	401
17.1.7  了解级联操作	403
17.2  实体继承关系映射	404
17.2.1  类继承树映射成一张表	404
17.2.2  每个子类映射成一张表	406
17.2.3  每个具体类映射成一张表	407
17.3  Hibernate查询语言	408
17.3.1  了解HQL语言	408
17.3.2  实体对象查询	409
17.3.3  条件查询	410
17.3.4  HQL参数绑定机制	410
17.3.5  排序查询	411
17.3.6  聚合函数的应用	411
17.3.7  分组方法	412
17.3.8  联合查询	412
17.3.9  子查询	413
17.4  小结	414
17.5  实践与练习	414
第18章  Spring核心之IoC	415
视频讲解：45分钟
18.1  Spring概述	416
18.1.1  初识Spring	416
18.1.2  Spring的获取	417
18.1.3  简单配置Spring	417
18.1.4  使用BeanFactory管理bean	418
18.1.5  ApllicationContext的应用	419
18.2  依赖注入	420
18.2.1  什么是控制反转与依赖注入	420
18.2.2  bean的配置	421
18.2.3  Setter注入	422
18.2.4  构造器注入	423
18.2.5  引用其他的bean	424
18.2.6  匿名内部JavaBean的创建	426
18.3  自动装配	426
18.3.1  按bean名称装配	426
18.3.2  按bean类型装配	427
18.3.3  自动装配的其他方式	428
18.4  bean的作用域	429
18.4.1  了解Spring中的bean	429
18.4.2  singleton的作用域	430
18.4.3  prototype的作用域	431
18.5  对bean的特殊处理	432
18.5.1  初始化与销毁	432
18.5.2  自定义属性编辑器	433
18.6  小结	435
18.7  实践与练习	435
第19章  Spring核心之AOP	437
视频讲解：37分钟
19.1  AOP概述	438
19.1.1  了解AOP	438
19.1.2  AOP的简单实现	439
19.2  Spring的切入点	441
19.2.1  静态切入点与动态切入点	441
19.2.2  深入静态切入点	442
19.2.3  深入切入点底层	442
19.2.4  Spring中其他切入点	443
19.3  Aspect对AOP的支持	444
19.3.1  了解Aspect	444
19.3.2  Spring中的Aspect	444
19.3.3  DefaultPointcutAdvisor切入点配
置器	445
19.3.4  NameMatchMethodPointcutAdvisor切入
点配置器	446
19.4  Spring持久化	446
19.4.1  DAO模式介绍	446
19.4.2  Spring的DAO理念	447
19.4.3  事务应用的管理	449
19.4.4  应用JdbcTemplate操作数据库	453
19.4.5  与Hibernate整合	454
19.5  小结	456
19.6  实践与练习	456
第20章  JSP操作XML	457
视频讲解：50分钟
20.1  XML简介	458
20.1.1  XML文档结构	458
20.1.2  XML语法要求	459
20.1.3  为XML文档中的元素定义属性	460
20.1.4  XML的注释	460
20.1.5  处理字符数据	461
20.2  dom4j概述	462
20.2.1  dom4j简介	462
20.2.2  dom4j的下载与配置	463
20.3  创建XML文档	464
20.3.1  创建XML文档对象	464
20.3.2  创建根节点	465
20.3.3  添加注释	465
20.3.4  添加属性	466
20.3.5  创建子节点	466
20.3.6  设置节点的内容	466
20.3.7  设置编码	467
20.3.8  设置输出格式	468
20.3.9  输出XML文档	468
20.4  解析XML文档	469
20.4.1  构建XML文档对象	469
20.4.2  获取根节点	470
20.4.3  获取子节点	470
20.5  修改XML文档	471

20.5.1  修改节点	471
20.5.2  删除节点	472
20.6  典型应用	473
20.6.1  保存公告信息到XML文件	473
20.6.2  对保存到XML文件中的公告信息进行
管理	476
20.7  小结	483
20.8  实践与练习	483
第5篇  项 目 实 战
第21章  清爽夏日九宫格日记网	487
视频讲解：1小时35分钟
21.1  项目设计思路	488
21.1.1  功能阐述	488
21.1.2  系统预览	488
21.1.3  功能结构	489
21.1.4  文件夹组织结构	490
21.2  数据库和数据表设计	491
21.2.1  数据库设计	491
21.2.2  数据表设计	491
21.3  公共模块设计	492
21.3.1  编写数据库连接及操作的类	492
21.3.2  编写保存分页代码的JavaBean	495
21.3.3  配置解决中文乱码的过滤器	497
21.3.4  编写实体类	498
21.4  主界面设计	499
21.4.1  主界面概述	499
21.4.2  让采用DIV+CSS布局的页面内容
居中	500
21.4.3  主界面的实现过程	501
21.5  用户模块设计	502
21.5.1  用户模块概述	502

21.5.2  实现Ajax重构	503
21.5.3  用户注册的实现过程	505
21.5.4  用户登录的实现过程	515
21.5.5  退出登录的实现过程	518
21.5.6  找回密码的实现过程	519
21.6  显示九宫格日记列表模块设计	522
21.6.1  显示九宫格日记列表概述	522
21.6.2  展开和收缩图片	522
21.6.3  查看日记原图	525
21.6.4  对日记图片进行左转和右转	525
21.6.5  显示全部九宫格日记的实现过程	528
21.6.6  我的日记的实现过程	532
21.6.7  删除我的日记的实现过程	533
21.7  写九宫格日记模块设计	534
21.7.1  写九宫格日记模块概述	534
21.7.2  应用jQuery让PNG图片在IE 6下
背景透明	535
21.7.3  填写日记信息的实现过程	536
21.7.4  预览生成的日记图片的实现过程	541
21.7.5  保存日记图片的实现过程	545
21.8  项目发布	546
21.9  小结	547
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web从入门到精通
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web服务：构建与运行（第2版）
前言 ............................................................................... v
第1 章 Web 服务快速入门 ............................................. 1
1.1 Web 服务杂项 .................................................................................................3
1.2 Web 服务有什么好处 ......................................................................................4
1.3 Web 服务和面向服务的架构 ...........................................................................6
1.4 Web 服务简史 .................................................................................................8
1.4.1 从DCE/RPC 到XML-RPC ....................................................................8
1.4.2 分布式对象架构：Java 示例 ...............................................................10
1.4.3 用Web 服务来救援 .............................................................................12
1.5 什么是REST .................................................................................................13
1.5.1 动词和不透明名词 ...............................................................................16
1.6 回顾HTTP 请求和响应 .................................................................................17
1.7 HTTP 作为API .............................................................................................19
1.7.1 用Java 编写的两个HTTP 客户端 .......................................................20
1.8 第一个REST 式的例子 .................................................................................23
1.8.1 Predictions Web 服务的工作原理 .......................................................24
1.8.2 针对Predictions Web 服务的客户端 ....................................................32
1.9 为什么REST 式Web 服务要使用servlet ................................................... 33
1.10 下一步是什么 ..............................................................................................35
第2 章 REST 式的Web 服务：服务端 ......................... 39
2.1 REST 式服务作为一个HttpServlet 类 ..........................................................40
2.1.1 实现细节 .............................................................................................41
2.1.2 针对predictions2 服务的示例客户端调用 ...........................................52
2.2 REST 式 Web 服务作为一个JAX-RS 资源 ...................................................53
2.2.1 第一个使用Jersey 的JAX-RS Web 服务 .............................................54
2.2.2 用Java 应用程序发布JAX-RS 资源....................................................55
2.2.3 用Tomcat 发布JAX-RS 资源 ..............................................................56
2.2.4 Adage 类 ..............................................................................................58
2.2.5 JAX-RS 生成的XML 和JSON 响应 ...................................................62
2.2.6 将Predictions Web 服务移植到JAX -RS ............................................66
2.3 REST 式 Web 服务作为Restlet 的资源 .........................................................75
2.3.1 对adages2 服务的示例调用 ................................................................83
2.3.2 在不使用Web 服务器的情况下发布adages2 Restlet 服务 ..................84
2.3.3 REST 式服务作为一个@WebServiceProvider ....................................85
2.4 下一步是什么 ................................................................................................94
第3 章 REST 式的Web 服务：客户端 ......................... 95
3.1 针对Java REST 式Web 服务的Perl 客户端 .................................................96
3.2 针对亚马逊电子商务服务的客户端 ............................................................ 101
3.3 一个独立的JAX -B 示例 ............................................................................ 110
3.3.1 XStream 选项 .................................................................................... 114
3.4 针对亚马逊电子商务服务的另一个客户端 ................................................. 119
3.5 CTA 公共汽车跟踪服务 .............................................................................. 123
3.6 REST 式客户端和WADL 文档 ................................................................... 126
3.7 JAX-RS 客户端API .................................................................................... 132
3.8 用于JavaScript 客户端的JSON .................................................................. 134
3.8.1 JSONP 和Web 服务 .......................................................................... 135
3.8.2 使用jQuery 编写的组合REST 式服务 .............................................. 136
3.8.3 一个Ajax 轮询的例子 ....................................................................... 139
3.9 下一步是什么 .............................................................................................. 142
第4 章 基于SOAP 的Web 服务 ................................ 145
4.1 一个基于SOAP 的Web 服务 ...................................................................... 146
4.2 在两个文件中的RandService ..................................................................... 151
4.3 针对RandService 的客户端 ........................................................................ 152
4.3.1 针对RandService 的Java 客户端 ...................................................... 153
4.3.2 针对RandService 的C# 客户端 ........................................................ 156
4.3.3 针对RandService 的Perl 客户端 ....................................................... 157
4.4 WSDL 服务合同详解 .................................................................................. 159
4.4.1 types 部分 .......................................................................................... 162
4.4.2 message 部分 ..................................................................................... 163
4.4.3 portType 部分 .................................................................................... 163
4.4.4 binding 部分 ...................................................................................... 164
4.4.5 service 部分 ....................................................................................... 165
4.4.6 Java 和XML 模式的数据类型绑定 ................................................... 165
4.4.7 包装和解包的文档风格 ..................................................................... 168
4.4.8 用于服务端的wsimport 构件 ............................................................ 170
4.5 针对亚马逊的电子商务服务的基于SOAP 的客户端 .................................. 172
4.5.1 针对基于SOAP 的服务的异步客户端 .............................................. 178
4.6 下一步是什么 .............................................................................................. 181
第5 章 SOAP 处理程序和错误 ................................... 183
5.1 基于SOAP 的服务和客户端中的处理程序层 ............................................. 184
5.2 在predictionsSOAP 服务中的处理程序和错误 ........................................... 192
5.2.1 后台支持类 ........................................................................................ 196
5.2.2 从客户端到服务 ................................................................................ 199
5.2.3 签名验证 ........................................................................................... 208
5.2.4 来自应用层和处理程序层的错误 ...................................................... 208
5.2.5 链接服务端处理程序的服务 .............................................................. 209
5.3 有两个处理程序的处理程序链 .................................................................... 210
5.4 基于SOAP 的Web 服务和二进制数据 ....................................................... 215
5.5 传输层 ......................................................................................................... 221
5.6 Axis2 ........................................................................................................... 224
5.7 下一步是什么 .............................................................................................. 227
第6 章 Web 服务安全性 ............................................ 229
6.1 线路层安全 ................................................................................................. 230
6.1.1 HTTPS 基础 ...................................................................................... 231
6.1.2 对称和非对称加密/ 解密 .................................................................. 232
6.1.3 HTTPS 如何提供三种安全服务 ......................................................... 233
6.1.4 HTTPS 握手 ...................................................................................... 234
6.1.5 HttpsURLConnection 类 .................................................................... 236
6.2 一个非常轻量级的HTTPS 服务器和客户端 ............................................... 241
6.3 在生产级Web 服务器中的HTTPS ............................................................. 250
6.3.1 强制使用HTTPS 访问Web 服务 ....................................................... 252
6.3.2 一个针对predictions2 服务的HTTPS 客户端 ................................... 254
6.4 容器管理的安全性 ...................................................................................... 257
6.4.1 用Tomcat 安全领域链接服务的web.xml .......................................... 259
6.4.2 在用户/ 角色安全性中的客户端 ....................................................... 261
6.4.3 使用curl 实用程序用于HTTPS 测试 ................................................ 264
6.4.4 在HTTPS 与用户/ 角色的安全性下的@WebService ....................... 266
6.4.5 使用摘要的密码替代密码 ................................................................. 269
6.5 WS-Security ................................................................................................ 271
6.5.1 使用WS-Security 保护一个@WebService ........................................ 273
6.6 下一步是什么 .............................................................................................. 285
第7 章 Web 服务和Java 应用程序服务器................... 287
7.1 Web 容器 ..................................................................................................... 288
7.1.1 面向消息的中间件 ............................................................................. 289
7.1.2 企业Java Bean 容器 .......................................................................... 289
7.1.3 命名和查找服务 ................................................................................ 291
7.1.4 安全提供者 ........................................................................................ 291
7.1.5 客户端容器 ........................................................................................ 292
7.1.6 数据库系统 ........................................................................................ 292
7.2 通向一个轻量级的JAS ............................................................................... 292
7.3 GlassFish 基础 ............................................................................................ 292
7.4 在GlassFish 中基于Servlet 的Web 服务.................................................... 295
7.4.1 具有混合API 的例子 ........................................................................ 298
7.5 一个互动网站和基于SOAP 的Web 服务 ................................................... 303
7.6 一个作为@Stateless 会话EJB 的@WebService ........................................ 308
7.6.1 包装和部署predictionsEJB 服务 ....................................................... 313
7.6.2 针对predictionsEJB 服务的客户端 ................................................... 315
7.7 TomEE ：带有Java EE 扩展的Tomcat ........................................................ 317
7.7.1 将predictionsEJB Web 服务移植到TomEE....................................... 318
7.7.2 将EJB 部署在一个WAR 文件中 ....................................................... 319
7.8 Java Web 服务最适合用在什么地方............................................................ 320
7.8.1 回到手头的问题 ................................................................................ 323
索引 ........................................................................... 325
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web服务：构建与运行（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>疯狂Java程序员的基本修养
第1章  数组及其内存管理	1
1.1  数组初始化	2
1.1.1  Java数组是静态的	2
1.1.2  数组一定要初始化吗	5
1.1.3  基本类型数组的初始化	7
1.1.4  引用类型数组的初始化	9
1.2  使用数组	12
1.2.1  数组元素就是变量	12
1.2.2  没有多维数组	14
1.3  本章小结	20
第2章  对象及其内存管理	21
2.1  实例变量和类变量	22
2.1.1  实例变量和类变量的属性	23
2.1.2  实例变量的初始化时机	26
2.1.3  类变量的初始化时机	30
2.2  父类构造器	32
2.2.1  隐式调用和显式调用	32
2.2.2  访问子类对象的实例变量	34
2.2.3  调用被子类重写的方法	37
2.3  父子实例的内存控制	39
2.3.1  继承成员变量和继承方法的区别	39
2.3.2  内存中子类实例	42
2.3.3  父、子类的类变量	47
2.4  final修饰符	48
2.4.1  final修饰的变量	48
2.4.2  执行“宏替换”的变量	53
2.4.3  final方法不能被重写	57
2.4.4  内部类中的局部变量	59
2.5  本章小结	62
第3章  常见Java集合的实现细节	63
3.1  Set和Map	64
3.1.1  Set和Map的关系	64
3.1.2  HashMap和HashSet	69
3.1.3  TreeMap和TreeSet	79
3.2  Map和List	85
3.2.1  Map的values()方法	85
3.2.2  Map和List的关系	91
3.3  ArrayList和LinkedList	92
3.3.1  Vector和ArrayList的区别	94
3.3.2  ArrayList和LinkedList的实现差异	97
3.3.3  ArrayList和LinkedList的性能分析及适用场景	101
3.4  Iterator迭代器	101
3.4.1  Iterator实现类与迭代器模式	102
3.4.2  迭代时删除指定元素	103
3.5  本章小结	106
第4章  Java的内存回收	107
4.1  Java引用的种类	108
4.1.1  对象在内存中的状态	108
4.1.2  强引用	111
4.1.3  软引用	111
4.1.4  弱引用	114
4.1.5  虚引用	118
4.2  Java的内存泄漏	119
4.3  垃圾回收机制	123
4.3.1  垃圾回收的基本算法	123
4.3.2  堆内存的分代回收	125
4.3.3  与垃圾回收相关的附加选项	127
4.3.4  常见的垃圾回收器	127
4.4  内存管理小技巧	131
4.4.1  尽量使用直接量	132
4.4.2  使用StringBuilder和StringBuffer进行字符串连接	132
4.4.3  尽早释放无用对象的引用	132
4.4.4  尽量少用静态变量	133
4.4.5  避免在经常调用的方法、循环中创建Java对象	133
4.4.6  缓存经常使用的对象	134
4.4.7  尽量不要使用finalize方法	134
4.4.8  考虑使用SoftReference	135
4.5  本章小结	135
第5章  表达式中的陷阱	136
5.1  关于字符串的陷阱	137
5.1.1  JVM对字符串的处理	137
5.1.2  不可变的字符串	140
5.1.3  字符串比较	142
5.2  表达式类型的陷阱	144
5.2.1  表达式类型的自动提升	144
5.2.2  复合赋值运算符的陷阱	145
5.2.3  Java 7新增的二进制整数	147
5.3  输入法导致的陷阱	148
5.4  注释字符必须合法	149
5.5  转义字符的陷阱	149
5.5.1  慎用字符的Unicode转义形式	149
5.5.2  中止行注释的转义字符	150
5.6  泛型可能引起的错误	151
5.6.1  原始类型变量的赋值	151
5.6.2  原始类型带来的擦除	153
5.6.3  创建泛型数组的陷阱	155
5.7  正则表达式的陷阱	157
5.8  多线程的陷阱	158
5.8.1  不要调用run方法	158
5.8.2  静态的同步方法	160
5.8.3  静态初始化块启动新线程执行初始化	162
5.8.4  注意多线程执行环境	167
5.9  本章小结	171
第6章  流程控制的陷阱	172
6.1  switch语句陷阱	173
6.1.1  default分支永远会执行吗	173
6.1.2  break的重要性	174
6.1.3  Java 7增强的switch表达式	176
6.2  标签引起的陷阱	177
6.3  if语句的陷阱	178
6.3.1  else隐含的条件	178
6.3.2  小心空语句	181
6.4  循环体的花括号	182
6.4.1  什么时候可以省略花括号	182
6.4.2  省略花括号的危险	183
6.5  for循环的陷阱	185
6.5.1  分号惹的祸	185
6.5.2  小心循环计数器的值	188
6.5.3  浮点数作循环计数器	188
6.6  foreach循环的循环计数器	190
6.7  本章小结	192
第7章  面向对象的陷阱	193
7.1  instanceof运算符的陷阱	194
7.2  构造器的陷阱	198
7.2.1  构造器之前的void	198
7.2.2  构造器创建对象吗	199
7.2.3  无限递归的构造器	203
7.3  持有当前类的实例	205
7.4  到底调用哪个重载的方法	206
7.5  方法重写的陷阱	209
7.5.1  重写private方法	209
7.5.2  重写其他访问权限的方法	210
7.6  非静态内部类的陷阱	211
7.6.1  非静态内部类的构造器	211
7.6.2  非静态内部类不能拥有静态成员	213
7.6.3  非静态内部类的子类	214
7.7  static关键字	215
7.7.1  静态方法属于类	215
7.7.2  静态内部类的限制	217
7.8  native方法的陷阱	217
7.9  本章小结	219
第8章  异常处理的陷阱	220
8.1  正确关闭资源的方式	221
8.1.1  传统关闭资源的方式	221
8.1.2  使用Java 7增强的try语句关闭资源	224
8.2  finally块的陷阱	226
8.2.1  finally的执行规则	226
8.2.2  finally块和方法返回值	227
8.3  catch块的用法	229
8.3.1  catch块的顺序	229
8.3.2  不要用catch代替流程控制	231
8.3.3  只有catch可能抛出的异常	232
8.3.4  做点实际的修复	235
8.4  继承得到的异常	237
8.5  Java 7增强的throw语句	238
8.6  本章小结	240
第9章  线性表	241
9.1  线性表概述	242
9.1.1  线性表的定义及逻辑结构	242
9.1.2  线性表的基本操作	243
9.2  顺序存储结构	243
9.3  链式存储结构	248
9.3.1  单链表上的基本运算	249
9.3.2  循环链表	255
9.3.3  双向链表	256
9.4  线性表的分析	262
9.4.1  线性表的实现分析	262
9.4.2  线性表的功能	263
9.5  本章小结	264
第10章  栈和队列	265
10.1  栈	266
10.1.1  栈的基本定义	266
10.1.2  栈的常用操作	267
10.1.3  栈的顺序存储结构及实现	267
10.1.4  栈的链式存储结构及实现	272
10.1.5  Java集合中的栈	275
10.2  队列	275
10.2.1  队列的基本定义	275
10.2.2  队列的常用操作	276
10.2.3  队列的顺序存储结构及实现	276
10.2.4  循环队列	280
10.2.5  队列的链式存储结构及实现	284
10.2.6  Java集合中的队列	287
10.3  双端队列	288
10.4  本章小结	289
第11章  树和二叉树	290
11.1  树的概述	291
11.1.1  树的定义和基本术语	291
11.1.2  树的基本操作	292
11.1.3  父节点表示法	293
11.1.4  子节点链表示法	296
11.2  二叉树	301
11.2.1  二叉树的定义和基本概念	301
11.2.2  二叉树的基本操作	302
11.2.3  二叉树的顺序存储	303
11.2.4  二叉树的二叉链表存储	306
11.2.5  二叉树的三叉链表存储	310
11.3  遍历二叉树	313
11.3.1  先序遍历	314
11.3.2  中序遍历	314
11.3.3  后序遍历	315
11.3.4  广度优先（按层）遍历	316
11.4  转换方法	316
11.4.1  森林、树和二叉树的转换	317
11.4.2  树的链表存储	318
11.5  哈夫曼树	318
11.5.1  哈夫曼树的定义和基本概念	319
11.5.2  创建哈夫曼树	319
11.5.3  哈夫曼编码	322
11.6  排序二叉树	323
11.7  红黑树	331
11.7.1  插入操作	332
11.7.2  删除操作	335
11.8  本章小结	344
第12章  常用的内部排序	345
12.1  排序的基本概念	346
12.1.1  排序概述	346
12.1.2  内部排序的分类	347
12.2  选择排序法	347
12.2.1  直接选择排序	347
12.2.2  堆排序	351
12.3  交换排序	356
12.3.1  冒泡排序	356
12.3.2  快速排序	358
12.4  插入排序	360
12.4.1  直接插入排序	360
12.4.2  折半插入排序	362
12.4.3  Shell排序	364
12.5  归并排序	367
12.6  桶式排序	370
12.7  基数排序	372
12.8  本章小结	375
第13章  程序开发经验谈	376
13.1  扎实的基本功	377
13.1.1  快速的输入能力	377
13.1.2  编程实现能力	379
13.1.3  快速排错	379
13.2  程序开发之前	380
13.2.1  分析软件的组件模型	380
13.2.2  建立软件的数据模型	383
13.3  理清程序的实现流程	384
13.3.1  各组件如何通信	384
13.3.2  人机交互的实现	386
13.3.3  复杂算法的分析	388
13.4  编写开发文档	391
13.4.1  绘制建模图、流程图	391
13.4.2  提供简要说明	393
13.4.3  编写伪码实现	393
13.5  编码实现和开发心态	394
13.5.1  开发是复杂的	394
13.5.2  开发过程是漫长的	394
13.6  本章小结	395
第14章  程序调试经验谈	396
14.1  程序的可调试性	397
14.1.1  增加注释	397
14.1.2  使用log	397
14.2  程序调试的基本方法	405
14.2.1  借助编译器的代码审查	405
14.2.2  跟踪程序执行流程	408
14.2.3  断点调试	409
14.2.4  隔离调试	411
14.2.5  错误重现	412
14.3  记录常见错误	414
14.3.1  常见异常可能的错误原因	414
14.3.2  常见运行时异常可能的错误原因	416
14.4  程序调试的整体思路	417
14.4.1  分段调试	418
14.4.2  分模块调试	419
14.5  调试心态	419
14.5.1  谁都会出错	420
14.5.2  调试比写程序更费时	420
14.6  本章小结	420
第15章  IDE工具心法谈	421
15.1  何时开始利用IDE工具	422
15.2  IDE工具概述	423
15.2.1  IDE工具的基本功能	424
15.2.2  常见的Java IDE工具	425
15.3  项目管理	428
15.3.1  建立项目	428
15.3.2  自动编译	434
15.3.3  自动部署、运行	435
15.4  代码管理	436
15.4.1  向导式的代码生成	436
15.4.2  代码生成器	438
15.4.3  代码提示	439
15.4.4  自动代码补齐	441
15.4.5  实时错误提示	441
15.5  项目调试	442
15.5.1  设置断点	442
15.5.2  单步调试	444
15.5.3  步入、步出	445
15.6  团队协作功能	446
15.7  本章小结	450
第16章  软件测试经验谈	451
16.1  软件测试概述	452
16.1.1  软件测试的概念和目的	452
16.1.2  软件测试的分类	454
16.1.3  开发活动和测试活动	454
16.1.4  常见的Bug管理工具	455
16.2  单元测试	456
16.2.1  单元测试概述	456
16.2.2  单元测试的逻辑覆盖	458
16.2.3  JUnit介绍	461
16.2.4  JUnit的用法	461
16.3  系统测试和自动化测试	467
16.3.1  系统测试概述	467
16.3.2  自动化测试	468
16.3.3  常见的自动化测试工具	469
16.4  性能测试	470
16.4.1  性能测试概述	470
16.4.2  性能测试的相关概念	471
16.4.3  常见的性能测试工具	472
16.5  本章小结	472
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>疯狂Java程序员的基本修养
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>揭秘Java虚拟机
第1章 Java虚拟机概述	1
1.1 从机器语言到Java——詹爷，你好	1
1.2 兼容的选择：一场生产力的革命	6
1.3 中间语言翻译	10
1.3.1 从中间语言翻译到机器码	11
1.3.2 通过C程序翻译	11
1.3.3 直接翻译为机器码	13
1.3.4 本地编译	16
1.4 神奇的指令	18
1.4.1 常见汇编指令	20
1.4.2 JVM指令	21
1.5 本章总结	24
第2章 Java执行引擎工作原理：方法调用	25
2.1 方法调用	26
2.1.1 真实的机器调用	26
2.1.2 C语言函数调用	41
2.2 JVM的函数调用机制	47
2.3 函数指针	53
2.4 CallStub函数指针定义	60
2.5 _call_stub_entry例程	72
2.6 本章总结	115
第3章 Java数据结构与面向对象	117
3.1 从Java算法到数据结构	118
3.2 数据类型简史	122
3.3 Java数据结构之偶然性	129
3.4 Java类型识别	132
3.4.1 class字节码概述	133
3.4.2 魔数与JVM内部的int类型	136
3.4.3 常量池与JVM内部对象模型	137
3.5 大端与小端	143
3.5.1 大端和小端的概念	146
3.5.2 大小端产生的本质原因	148
3.5.3 大小端验证	149
3.5.4 大端和小端产生的场景	151
3.5.5 如何解决字节序反转	154
3.5.6 大小端问题的避免	156
3.5.7 JVM对字节码文件的大小端处理	156
3.6 本章总结	159
第4章 Java字节码实战	161
4.1 字节码格式初探	161
4.1.1 准备测试用例	162
4.1.2 使用javap命令分析字节码文件	162
4.1.3 查看字节码二进制	165
4.2 魔数与版本	166
4.2.1 魔数	168
4.2.2 版本号	168
4.3 常量池	169
4.3.1 常量池的基本结构	169
4.3.2 JVM所定义的11种常量	170
4.3.3 常量池元素的复合结构	170
4.3.4 常量池的结束位置	172
4.3.5 常量池元素总数量	172
4.3.6 第一个常量池元素	173
4.3.7 第二个常量池元素	174
4.3.8 父类常量	174
4.3.9 变量型常量池元素	175
4.4 访问标识与继承信息	177
4.4.1 access_flags	177
4.4.2 this_class	178
4.4.3 super_class	179
4.4.4 interface	179
4.5 字段信息	180
4.5.1 fields_count	180
4.5.2 field_info fields[fields_count]	181
4.6 方法信息	185
4.6.1 methods_count	185
4.6.2 method_info methods[methods_count]	185
4.7 本章回顾	205
第5章 常量池解析	206
5.1 常量池内存分配	208
5.1.1 常量池内存分配总体链路	209
5.1.2 内存分配	215
5.1.3 初始化内存	223
5.2 oop-klass模型	224
5.2.1 两模型三维度	225
5.2.2 体系总览	227
5.2.3 oop体系	229
5.2.4 klass体系	231
5.2.5 handle体系	234
5.2.6 oop、klass、handle的相互转换	239
5.3 常量池klass模型（1）	244
5.3.1 klassKlass实例构建总链路	246
5.3.2 为klassOop申请内存	249
5.3.3 klassOop内存清零	253
5.3.4 初始化mark	253
5.3.5 初始化klassOop._metadata	258
5.3.6 初始化klass	259
5.3.7 自指	260
5.4 常量池klass模型（2）	261
5.4.1 constantPoolKlass模型构建	261
5.4.2 constantPoolOop与klass	264
5.4.3 klassKlass终结符	267
5.5 常量池解析	267
5.5.1 constantPoolOop域初始化	268
5.5.2 初始化tag	269
5.5.3 解析常量池元素	271
5.6 本章总结	279
第6章 类变量解析	280
6.1 类变量解析	281
6.2 偏移量	285
6.2.1 静态变量偏移量	285
6.2.2 非静态变量偏移量	287
6.2.3 Java字段内存分配总结	312
6.3 从源码看字段继承	319
6.3.1 字段重排与补白	319
6.3.2 private字段可被继承吗	325
6.3.3 使用HSDB验证字段分配与继承	329
6.3.4 引用类型变量内存分配	338
6.4 本章总结	342
第7章 Java栈帧	344
7.1 entry_point例程生成	345
7.2 局部变量表创建	352
7.2.1 constMethod的内存布局	352
7.2.2 局部变量表空间计算	356
7.2.3 初始化局部变量区	359
7.3 堆栈与栈帧	368
7.3.1 栈帧是什么	368
7.3.2 硬件对堆栈的支持	387
7.3.3 栈帧开辟与回收	390
7.3.4 堆栈大小与多线程	391
7.4 JVM的栈帧	396
7.4.1 JVM栈帧与大小确定	396
7.4.2 栈帧创建	399
7.4.3 局部变量表	421
7.5 栈帧深度与slot复用	433
7.6 最大操作数栈与操作数栈复用	436
7.7 本章总结	439
第8章 类方法解析	440
8.1 方法签名解析与校验	445
8.2 方法属性解析	447
8.2.1 code属性解析	447
8.2.2 LVT&LVTT	449
8.3 创建methodOop	455
8.4 Java方法属性复制	459
8.5 与	461
8.6 查看运行时字节码指令	482
8.7 vtable	489
8.7.1 多态	489
8.7.2 C++中的多态与vtable	491
8.7.3 Java中的多态实现机制	493
8.7.4 vtable与invokevirtual指令	500
8.7.5 HSDB查看运行时vtable	502
8.7.6 miranda方法	505
8.7.7 vtable特点总结	508
8.7.8 vtable机制逻辑验证	509
8.8 本章总结	511
第9章 执行引擎	513
9.1 执行引擎概述	514
9.2 取指	516
9.2.1 指令长度	519
9.2.2 JVM的两级取指机制	527
9.2.3 取指指令放在哪	532
9.2.4 程序计数器在哪里	534
9.3 译码	535
9.3.1 模板表	535
9.3.2 汇编器	540
9.3.3 汇编	549
9.4 栈顶缓存	558
9.5 栈式指令集	565
9.6 操作数栈在哪里	576
9.7 栈帧重叠	581
9.8 entry_point例程机器指令	586
9.9 执行引擎实战	588
9.9.1 一个简单的例子	588
9.9.2 字节码运行过程分析	590
9.10 字节码指令实现	597
9.10.1 iconst_3	598
9.10.2 istore_0	599
9.10.3 iadd	600
9.11 本章总结	601
第10章 类的生命周期	602
10.1 类的生命周期概述	602
10.2 类加载	605
10.2.1 类加载——镜像类与静态字段	611
10.2.2 Java主类加载机制	617
10.2.3 类加载器的加载机制	622
10.2.4 反射加载机制	623
10.2.5 import与new指令	624
10.3 类的初始化	625
10.4 类加载器	628
10.4.1 类加载器的定义	628
10.4.2 系统类加载器与扩展类加载器创建	634
10.4.3 双亲委派机制与破坏	636
10.4.4 预加载	638
10.4.5 引导类加载	640
10.4.6 加载、链接与延迟加载	641
10.4.7 父加载器	645
10.4.8 加载器与类型转换	648
10.5 类实例分配	649
10.5.1 栈上分配与逃逸分析	652
10.5.2 TLAB	655
10.5.3 指针碰撞与eden区分配	657
10.5.4 清零	658
10.5.5 偏向锁	658
10.5.6 压栈与取指	659
10.6 本章总结	661
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>揭秘Java虚拟机
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java核心技术 卷I 基础知识 第10版 英文版
Chapter 1: An Introduction to Java / Java概述 1
1.1　Java as a Programming Platform / Java程序设计平台 1
1.2　The Java“White Paper”Buzzwords / Java“白皮书”中的口号 2
1.2.1　Simple / 简单 3
1.2.2　Object-Oriented / 面向对象 4
1.2.3　Distributed / 分布式 4
1.2.4　Robust / 健壮 4
1.2.5　Secure / 安全 4
1.2.6　Architecture-Neutral / 体系结构中立 5
1.2.7　Portable / 可移植 6
1.2.8　Interpreted / 解释型 7
1.2.9　High-Performance / 高性能 7
1.2.10　Multithreaded / 多线程 7
1.2.11　Dynamic / 动态 8
1.3　Java Applets and the Internet / Java Applet与Internet 8
1.4　A Short History of Java / Java简史 10
1.5　Common Misconceptions about Java / 对Java的常见误解 13
Chapter 2: The Java Programming Environment / Java编程环境 17
2.1　Installing the Java Development Kit / 安装Java开发包（JDK） 18
2.1.1　Downloading the JDK / 下载JDK 18
2.1.2　Setting up the JDK / 设置JDK 20
2.1.3　Installing Source Files and Documentation /源文件与文档的下载与设置 22
2.2　Using the Command-Line Tools / 使用命令行工具 23
2.3　Using an Integrated Development Environment / 使用集成开发环境 26
2.4　Running a Graphical Application / 运行图形化应用程序 30
2.5　Building and Running Applets / 构建并运行Applet 33
Chapter 3: Fundamental Programming Structures in Java / Java的基本编程结构 41
3.1　A Simple Java Program / 一个简单的Java程序 42
3.2　Comments / 注释 46
3.3　Data Types / 数据类型 47
3.3.1　Integer Types / 整型 47
3.3.2　Floating-Point Types / 浮点型 48
3.3.3　The char Type / char类型 50
3.3.4　Unicode and the char Type / Unicode与char类型 51
3.3.5　The boolean Type / boolean类型 52
3.4　Variables / 变量 53
3.4.1　Initializing Variables / 初始化变量 54
3.4.2　Constants / 常量 55
3.5　Operators / 运算符 56
3.5.1　Mathematical Functions and Constants / 数学函数与常量 57
3.5.2　Conversions between Numeric Types / 数值类型之间的转换 59
3.5.3　Casts / 强制类型转换 60
3.5.4　Combining Assignment with Operators / 组合赋值运算符 61
3.5.5　Increment and Decrement Operators / 自增运算符与自减运算符 61
3.5.6　Relational and Boolean Operators / 关系与boolean运算符 62
3.5.7　Bitwise Operators / 位运算符 63
3.5.8　Parentheses and Operator Hierarchy / 括号与运算符优先级 64
3.5.9　Enumerated Types / 枚举类型 65
3.6　Strings / 字符串 65
3.6.1　Substrings / 子串 66
3.6.2　Concatenation / 拼接 66
3.6.3　Strings Are Immutable / String是不可变的 67
3.6.4　Testing Strings for Equality / 测试字符串是否相等 68
3.6.5　Empty and Null Strings / 空串与null串 69
3.6.6　Code Points and Code Units / 码位与编码单元 70
3.6.7　The String API / String 类的API 71
3.6.8　Reading the Online API Documentation / 阅读在线API文档 74
3.6.9　Building Strings / 构建字符串 77
3.7　Input and Output / 输入输出 78
3.7.1　Reading Input / 读取输入 79
3.7.2　Formatting Output / 格式化输出 82
3.7.3　File Input and Output / 文件输入输出 87
3.8　Control Flow / 控制流 89
3.8.1　Block Scope / 块作用域 89
3.8.2　Conditional Statements / 条件语句 90
3.8.3　Loops / 循环 94
3.8.4　Determinate Loops / 确定性循环 99
3.8.5　Multiple Selections—The switch Statement / 多重选择：switch语句 103
3.8.6　Statements That Break Control Flow / 用于跳出控制流的语句 106
3.9　Big Numbers / 大数 108
3.10 Arrays / 数组 111
3.10.1　The “for each” Loop / “for each”循环 113
3.10.2　Array Initializers and Anonymous Arrays / 数组初始化与匿名数组 114
3.10.3　Array Copying / 数组复制 114
3.10.4　Command-Line Parameters / 命令行参数 116
3.10.5　Array Sorting / 数组排序 117
3.10.6　Multidimensional Arrays / 多维数组 120
3.10.7　Ragged Arrays / 不规则数组 124
Chapter 4: Objects and Classes /对象与类 129
4.1　Introduction to Object-Oriented Programming / 面向对象编程简介 130
4.1.1　Classes / 类 131
4.1.2　Objects / 对象 132
4.1.3　Identifying Classes / 识别类 133
4.1.4　Relationships between Classes / 类之间的关系 133
4.2　Using Predefined Classes / 使用预定义类 135
4.2.1　Objects and Object Variables / 对象与对象变量 136
4.2.2　The LocalDate Class of the Java Library / Java 库中的LocalDate类 139
4.2.3　Mutator and Accessor Methods / 更改器方法与访问器方法 141
4.3　Defining Your Own Classes / 定义自己的类 145
4.3.1　An Employee Class / Employee类 145
4.3.2　Use of Multiple Source Files / 使用多个源文件 149
4.3.3　Dissecting the Employee Class / 分析Employee类 149
4.3.4　First Steps with Constructors / 从构造器开始 150
4.3.5　Implicit and Explicit Parameters / 隐式参数与显式参数 152
4.3.6　Benefits of Encapsulation / 封装的好处 153
4.3.7　Class-Based Access Privileges / 基于类的访问权限 156
4.3.8　Private Methods / 私有方法 156
4.3.9　Final Instance Fields / final实例字段 157
4.4　Static Fields and Methods / 静态字段与静态方法 158
4.4.1　Static Fields / 静态字段 158
4.4.2　Static Constants / 静态常量 159
4.4.3　Static Methods / 静态方法 160
4.4.4　Factory Methods / 工厂方法 161
4.4.5　The main Method / main方法 161
4.5　Method Parameters / 方法参数 164
4.6　Object Construction / 对象构建 171
4.6.1　Overloading / 重载 172
4.6.2　Default Field Initialization / 默认字段初始化 172
4.6.3　The Constructor with No Arguments / 无参构造器 173
4.6.4　Explicit Field Initialization / 显式字段初始化 174
4.6.5　Parameter Names / 参数名 175
4.6.6　Calling Another Constructor / 调用另一个构造器 176
4.6.7　Initialization Blocks / 初始化块 177
4.6.8　Object Destruction and the finalize Method / 对象析构与finalize方法 181
4.7　Packages / 包 182
4.7.1　Class Importation / 导入类 183
4.7.2　Static Imports / 静态导入 185
4.7.3　Addition of a Class into a Package / 将类添加到某个包中 185
4.7.4　Package Scope / 包作用域 189
4.8　The Class Path / 类路径 190
4.8.1　Setting the Class Path / 设置类路径 193
4.9　Documentation Comments / 文档注释 194
4.9.1　Comment Insertion / 插入注释 194
4.9.2　Class Comments / 类注释 195
4.9.3　Method Comments / 方法注释 195
4.9.4　Field Comments / 字段注释 196
4.9.5　General Comments / 通用注释 196
4.9.6　Package and Overview Comments / 包与概述注释 198
4.9.7　Comment Extraction / 提取注释 198
4.10 Class Design Hints / 类设计建议 200
Chapter 5: Inheritance / 继承 203
5.1　Classes, Superclasses, and Subclasses / 类、超类与子类 204
5.1.1　Defining Subclasses / 定义子类 204
5.1.2　Overriding Methods / 覆盖方法 206
5.1.3　Subclass Constructors / 子类构造器 207
5.1.4　Inheritance Hierarchies / 继承层次 212
5.1.5　Polymorphism / 多态 213
5.1.6　Understanding Method Calls / 理解方法调用 214
5.1.7　Preventing Inheritance: Final Classes and Methods / 阻止继承：final修饰的类和方法 217
5.1.8　Casting / 强制类型转换 219
5.1.9　Abstract Classes / 抽象类 221
5.1.10　Protected Access / 受保护访问 227
5.2　Object: The Cosmic Superclass / Object：所有类的超类 228
5.2.1　The equals Method / equals方法 229
5.2.2　Equality Testing and Inheritance / 相等测试与继承 231
5.2.3　The hashCode Method / hashCode方法 235
5.2.4　The toString Method / toString方法 238
5.3　Generic Array Lists / 泛型数组列表 244
5.3.1　Accessing Array List Elements / 访问泛型数组列表的元素 247
5.3.2　Compatibility between Typed and Raw Array Lists / 泛型数组列表与原始数组列表的兼容性 251
5.4　Object Wrappers and Autoboxing / 对象包装器与自动装箱 252
5.5　Methods with a Variable Number of Parameters / 参数数量可变的方法 256
5.6　Enumeration Classes / 枚举类 258
5.7　Reflection / 反射 260
5.7.1　The Class Class / Class类 261
5.7.2　A Primer on Catching Exceptions / 捕获异常简介 263
5.7.3　Using Reflection to Analyze the Capabilities of Classes / 使用反射分析类的能力 265
5.7.4　Using Reflection to Analyze Objects at Runtime / 在运行时使用反射分析对象 271
5.7.5　Using Reflection to Write Generic Array Code / 使用反射编写泛型数组代码 276
5.7.6　Invoking Arbitrary Methods / 调用任意方法 279
5.8　Design Hints for Inheritance / 继承的设计建议 283
Chapter 6: Interfaces, Lambda Expressions, and Inner Classes / 接口、Lambda表达式和内部类 287
6.1　Interfaces / 接口 288
6.1.1　The Interface Concept / 接口的概念 288
6.1.2　Properties of Interfaces / 接口的特性 295
6.1.3　Interfaces and Abstract Classes / 接口与抽象类 297
6.1.4　Static Methods / 静态方法 298
6.1.5　Default Methods / 默认方法 298
6.1.6　Resolving Default Method Conflicts / 解决默认方法的冲突 300
6.2　Examples of Interfaces / 接口示例 302
6.2.1　Interfaces and Callbacks / 接口与回调 302
6.2.2　The Comparator Interface / Comparator接口 305
6.2.3　Object Cloning / 对象克隆 306
6.3　Lambda Expressions / Lambda表达式 314
6.3.1　Why Lambdas? / 为什么引入Lambda表达式 314
6.3.2　The Syntax of Lambda Expressions / Lambda表达式的语法 315
6.3.3　Functional Interfaces / 函数式接口 318
6.3.4　Method References / 方法引用 319
6.3.5　Constructor References / 构造器引用 321
6.3.6　Variable Scope / 变量作用域 322
6.3.7　Processing Lambda Expressions / 处理Lambda表达式 324
6.3.8　More about Comparators / 再谈Comparator 328
6.4　Inner Classes / 内部类 329
6.4.1　Use of an Inner Class to Access Object State / 使用内部类访问对象状态 331
6.4.2　Special Syntax Rules for Inner Classes /
内部类的特殊语法规则 334
6.4.3　Are Inner Classes Useful? Actually Necessary? Secure? / 内部类是否有用、必要和安全 335
6.4.4　Local Inner Classes / 局部内部类 339
6.4.5　Accessing Variables from Outer Methods / 从外部方法访问变量 339
6.4.6　Anonymous Inner Classes / 匿名内部类 342
6.4.7　Static Inner Classes / 静态内部类 346
6.5　Proxies / 代理 350
6.5.1　When to Use Proxies / 何时使用代理 350
6.5.2　Creating Proxy Objects / 创建代理对象 350
6.5.3　Properties of Proxy Classes / 代理类的特性 355
Chapter 7: Exceptions, Assertions, and Logging /异常、断言与日志 357
7.1　Dealing with Errors / 处理错误 358
7.1.1　The Classification of Exceptions / 异常分类 359
7.1.2　Declaring Checked Exceptions / 声明检查型异常 361
7.1.3　How to Throw an Exception / 如何抛出异常 364
7.1.4　Creating Exception Classes / 创建异常类 365
7.2　Catching Exceptions / 捕获异常 367
7.2.1　Catching an Exception / 捕获一个异常 367
7.2.2　Catching Multiple Exceptions / 捕获多个异常 369
7.2.3　Rethrowing and Chaining Exceptions / 再次抛出异常与异常链 370
7.2.4　The finally Clause / finally子句 372
7.2.5　The Try-with-Resources Statement / try-with-resources语句 376
7.2.6　Analyzing Stack Trace Elements / 分析栈轨迹元素 377
7.3　Tips for Using Exceptions / 异常使用技巧 381
7.4　Using Assertions / 使用断言 384
7.4.1　The Assertion Concept / 断言的概念 384
7.4.2　Assertion Enabling and Disabling / 启用和禁用断言 385
7.4.3　Using Assertions for Parameter Checking / 使用断言检查参数 386
7.4.4　Using Assertions for Documenting Assumptions / 使用断言保证文档中假定成立的条件 387
7.5　Logging / 日志 389
7.5.1　Basic Logging / 基本日志 389
7.5.2　Advanced Logging / 高级日志 390
7.5.3　Changing the Log Manager Configuration / 修改日志管理器配置 392
7.5.4　Localization / 本地化 393
7.5.5　Handlers / 处理器 394
7.5.6　Filters / 过滤器 398
7.5.7　Formatters / 格式化器 399
7.5.8　A Logging Recipe / 常见日志操作总结 399
7.6　Debugging Tips / 调试技巧 409
Chapter 8: Generic Programming /泛型编程 415
8.1　Why Generic Programming? / 为什么要使用泛型编程 416
8.1.1　The Advantage of Type Parameters / 类型参数的好处 416
8.1.2　Who Wants to Be a Generic Programmer? / 哪些人想成为泛型程序员 417
8.2　Defining a Simple Generic Class / 定义简单的泛型类 418
8.3　Generic Methods / 泛型方法 421
8.4　Bounds for Type Variables / 类型变量的绑定 422
8.5　Generic Code and the Virtual Machine / 泛型代码与虚拟机 425
8.5.1　Type Erasure / 类型擦除 425
8.5.2　Translating Generic Expressions / 翻译泛型表达式 426
8.5.3　Translating Generic Methods / 翻译泛型方法 427
8.5.4　Calling Legacy Code / 调用遗留代码 429
8.6　Restrictions and Limitations / 约束与局限性 430
8.6.1　Type Parameters Cannot Be Instantiated with Primitive Types / 类型参数不能用基本类型来实例化 430
8.6.2　Runtime Type Inquiry Only Works with Raw Types / 运行时类型查询只适用于原始类型 431
8.6.3　You Cannot Create Arrays of Parameterized Types / 不能创建参数化类型的数组 431
8.6.4　Varargs Warnings / 注意变长参数情况 432
8.6.5　You Cannot Instantiate Type Variables / 不能实例化类型变量 433
8.6.6　You Cannot Construct a Generic Array / 不能构造泛型数组 434
8.6.7　Type Variables Are Not Valid in Static Contexts of Generic Classes / 类型变量在泛型类的静态上下文中无效 436
8.6.8　You Cannot Throw or Catch Instances of a Generic Class / 不能抛出或捕获泛型类的实例 436
8.6.9　You Can Defeat Checked Exception Checking / 可以打破“检查型异常必须检查”的规则 437
8.6.10　Beware of Clashes after Erasure / 注意类型擦除后的冲突 439
8.7　Inheritance Rules for Generic Types / 泛型类型的继承规则 440
8.8　Wildcard Types / 通配符类型 442
8.8.1　The Wildcard Concept / 通配符的概念 442
8.8.2　Supertype Bounds for Wildcards / 通配符的超类型限定 444
8.8.3　Unbounded Wildcards / 无限定通配符 447
8.8.4　Wildcard Capture / 通配符捕获 448
8.9　Reflection and Generics / 反射与泛型 450
8.9.1　The Generic Class Class / 泛型的Class类 450
8.9.2　Using Class Parameters for Type Matching / 使用Class参数进行类型匹配 452
8.9.3　Generic Type Information in the Virtual Machine / 虚拟机中的泛型类型信息 452
Chapter 9: Collections /集合类 459
9.1　The Java Collections Framework / Java 集合类框架 460
9.1.1　Separating Collection Interfaces and Implementation / 将集合类的接口与实现分离 460
9.1.2　The Collection Interface / Collection接口 463
9.1.3　Iterators / 迭代器 463
9.1.4　Generic Utility Methods / 泛型的实用方法 466
9.1.5　Interfaces in the Collections Framework / 集合类框架中的接口 469
9.2　Concrete Collections / 具体的集合类 472
9.2.1　Linked Lists / 链表 474
9.2.2　Array Lists / 数组列表 484
9.2.3　Hash Sets / 散列集 485
9.2.4　Tree Sets / 树形集 489
9.2.5　Queues and Deques / 队列与双端队列 494
9.2.6　Priority Queues / 优先级队列 495
9.3　Maps / 映射 497
9.3.1　Basic Map Operations / 基本映射操作 497
9.3.2　Updating Map Entries / 更新映射表项 500
9.3.3　Map Views / 映射视图 502
9.3.4　Weak Hash Maps / 弱散列映射 504
9.3.5　Linked Hash Sets and Maps / LinkedHashSet与LinkedHashMap 504
9.3.6　Enumeration Sets and Maps / EnumSet与EnumMap 506
9.3.7　Identity Hash Maps / IdentityHashMap 507
9.4　Views and Wrappers / 视图与包装器 509
9.4.1　Lightweight Collection Wrappers / 轻量级集合包装器 509
9.4.2　Subranges / 子范围 510
9.4.3　Unmodifiable Views / 不可修改视图 511
9.4.4　Synchronized Views / 同步视图 512
9.4.5　Checked Views / 检查用视图 513
9.4.6　A Note on Optional Operations / 可选操作说明 514
9.5　Algorithms / 算法 517
9.5.1　Sorting and Shuffiing / 排序与混排 518
9.5.2　Binary Search / 二分查找 521
9.5.3　Simple Algorithms / 简单算法 522
9.5.4　Bulk Operations / 主要操作 524
9.5.5　Converting between Collections and Arrays / 集合与数组之间的转换 525
9.5.6　Writing Your Own Algorithms / 编写自己的算法 526
9.6　Legacy Collections / 遗留的集合类 528
9.6.1　The Hashtable Class / Hashtable类 528
9.6.2　Enumerations / Enumeration 528
9.6.3　Property Maps / 属性映射 530
9.6.4　Stacks / 栈 531
9.6.5　Bit Sets / 位集 532
Chapter 10: Graphics Programming /图形界面编程 537
10.1　Introducing Swing / Swing简介 538
10.2　Creating a Frame / 创建框架 543
10.3　Positioning a Frame / 设定框架的显示位置 546
10.3.1　Frame Properties / 框架属性 549
10.3.2　Determining a Good Frame Size / 确定合适的框架大小 549
10.4　Displaying Information in a Component / 在组件中显示信息 554
10.5　Working with 2D Shapes / 处理2D图形 560
10.6　Using Color / 使用颜色 569
10.7　Using Special Fonts for Text / 使用特殊的文本字体 573
10.8　Displaying Images / 显示图片 582
Chapter 11: Event Handling /事件处理 587
11.1　Basics of Event Handling / 事件处理基础 587
11.1.1　Example: Handling a Button Click / 示例：处理按钮点击事件 591
11.1.2　Specifying Listeners Concisely / 设置监听器的简洁方法 595
11.1.3　Example: Changing the Look-and-Feel / 示例：修改观感 598
11.1.4　Adapter Classes / 适配器类 603
11.2　Actions / 动作 607
11.3　Mouse Events / 鼠标事件 616
11.4　The AWT Event Hierarchy / AWT事件层次 624
11.4.1　Semantic and Low-Level Events / 语义与底层事件 626
Chapter 12: User Interface Components with Swing / Swing用户界面组件 629
12.1　Swing and the Model-View-Controller Design Pattern / Swing与模型-视图-控制器设计模式 630
12.1.1　Design Patterns / 设计模式 630
12.1.2　The Model-View-Controller Pattern / 模型-视图-控制器模式 632
12.1.3　A Model-View-Controller Analysis of Swing Buttons / Swing按钮的模型-视图-控制器分析 636
12.2　Introduction to Layout Management / 布局管理简介 638
12.2.1　Border Layout / 边框布局 641
12.2.2　Grid Layout / 网格布局 644
12.3　Text Input / 文本输入 648
12.3.1　Text Fields / 文本框 649
12.3.2　Labels and Labeling Components / 标签与标签组件 651
12.3.3　Password Fields / 密码框 652
12.3.4　Text Areas / 文本区域 653
12.3.5　Scroll Panes / 滚动窗格 654
12.4　Choice Components / 选择组件 657
12.4.1　Checkboxes / 复选框 657
12.4.2　Radio Buttons / 单选按钮 660
12.4.3　Borders / 边框 664
12.4.4　Combo Boxes / 组合框 668
12.4.5　Sliders / 滑动条 672
12.5　Menus / 菜单 678
12.5.1　Menu Building / 菜单构建 679
12.5.2　Icons in Menu Items / 菜单项中的图标 682
12.5.3　Checkbox and Radio Button Menu Items / 复选框和单选按钮菜单项 683
12.5.4　Pop-Up Menus / 弹出菜单 684
12.5.5　Keyboard Mnemonics and Accelerators / 键盘助记符与快捷键 686
12.5.6　Enabling and Disabling Menu Items / 启用和禁用菜单项 689
12.5.7　Toolbars / 工具栏 694
12.5.8　Tooltips / 工具提示 696
12.6　Sophisticated Layout Management / 复杂的布局管理 699
12.6.1　The Grid Bag Layout / 网格布局管理 701
12.6.2　Group Layout / 组布局 713
12.6.3　Using No Layout Manager / 不使用布局管理器 723
12.6.4　Custom Layout Managers / 定制布局管理器 724
12.6.5　Traversal Order / 遍历顺序 729
12.7　Dialog Boxes / 对话框 730
12.7.1　Option Dialogs / 选项对话框 731
12.7.2　Creating Dialogs / 创建对话框 741
12.7.3　Data Exchange / 数据交换 746
12.7.4　File Dialogs / 文件对话框 752
12.7.5　Color Choosers / 颜色选择器 764
12.8　Troubleshooting GUI Programs / GUI程序的问题定位 770
12.8.1　Debugging Tips / 调试技巧 770
12.8.2　Letting the AWT Robot Do the Work / 把工作交给AWT Robot 774
Chapter 13: Deploying Java Applications / 部署Java应用程序 779
13.1　JAR Files / JAR文件 780
13.1.1　Creating JARfiles / 创建JAR文件 780
13.1.2　The Manifest / 清单文件 781
13.1.3　Executable JAR Files / 可执行的JAR文件 782
13.1.4　Resources / 资源 783
13.1.5　Sealing / 封闭 787
13.2　Storage of Application Preferences / 应用偏好信息的存储 788
13.2.1　Property Maps / 属性映射 788
13.2.2　The Preferences API / Properties API 794
13.3　Service Loaders / 服务加载器 800
13.4　Applets / Applet 802
13.4.1　A Simple Applet / 一个简单的Applet 803
13.4.2　The applet HTML Tag and Its Attributes / applet HTML标记及其属性 808
13.4.3　Use of Parameters to Pass Information to Applets / 使用参数向Applet传递信息 810
13.4.4　Accessing Image and Audio Files / 访问图片和音频文件 816
13.4.5　The Applet Context / Applet上下文 818
13.4.6　Inter-Applet Communication / Applet间的通信 818
13.4.7　Displaying Items in the Browser / 在浏览器中显示信息 819
13.4.8　The Sandbox / 沙箱 820
13.4.9　Signed Code / 签名代码 822
13.5　Java Web Start / Java Web Start 824
13.5.1　Delivering a Java Web Start Application / 交付一个Java Web Start应用 824
13.5.2　The JNLP API / JNLP API 829
Chapter 14: Concurrency /并发 839
14.1　What Are Threads? / 什么是线程 840
14.1.1　Using Threads to Give Other Tasks a Chance / 使用线程为其他任务提供执行机会 846
14.2　Interrupting Threads / 中断线程 851
14.3　Thread States / 线程状态 855
14.3.1　New Threads / 新创建线程 855
14.3.2　Runnable Threads / 可运行线程 855
14.3.3　Blocked and Waiting Threads / 被阻塞线程与等待线程 856
14.3.4　Terminated Threads / 被终止的线程 857
14.4　Thread Properties / 线程属性 858
14.4.1　Thread Priorities / 线程优先级 858
14.4.2　Daemon Threads / 守护线程 859
14.4.3　Handlers for Uncaught Exceptions / 未捕获异常的处理器 860
14.5　Synchronization / 同步 862
14.5.1　An Example of a Race Condition / 竞争条件的一个案例 862
14.5.2　The Race Condition Explained / 竞争条件详解 866
14.5.3　Lock Objects / 锁对象 868
14.5.4　Condition Objects / 条件对象 872
14.5.5　The synchronized Keyword / synchronized关键字 878
14.5.6　Synchronized Blocks / 同步块 882
14.5.7　The Monitor Concept / 监视器概念 884
14.5.8　Volatile Fields / volatile字段 885
14.5.9　Final Variables / final变量 886
14.5.10　Atomics / 原子 886
14.5.11　Deadlocks / 死锁 889
14.5.12　Thread-Local Variables / 线程局部变量 892
14.5.13　Lock Testing and Timeouts / 锁测试与超时 893
14.5.14　Read / Write Locks / 读/写锁 895
14.5.15　Why the stop and suspend Methods Are Deprecated / 为什么弃用stop和suspend方法 896
14.6　Blocking Queues / 阻塞队列 898
14.7　Thread-Safe Collections / 线程安全的集合 905
14.7.1　Efficient Maps, Sets, and Queues / 高效的映射、集和队列 905
14.7.2　Atomic Update of Map Entries / 映射表项的原子更新 907
14.7.3　Bulk Operations on Concurrent Hash Maps / 并发散列映射上的主要操作 909
14.7.4　Concurrent Set Views / 并发的集视图 912
14.7.5　Copy on Write Arrays / 写时复制的数组 912
14.7.6　Parallel Array Algorithms / 并行数组算法 912
14.7.7　Older Thread-Safe Collections / 较早的线程安全的集合 914
14.8　Callables and Futures / Callable与Future 915
14.9　Executors / 执行器 920
14.9.1　Thread Pools / 线程池 921
14.9.2　Scheduled Execution / 预订执行 926
14.9.3　Controlling Groups of Tasks / 控制任务组 927
14.9.4　The Fork-Join Framework / Fork-Join框架 928
14.9.5　Completable Futures / CompletableFuture 931
14.10　Synchronizers / 同步器 934
14.10.1　Semaphores / 信号量 935
14.10.2　Countdown Latches / 倒计时门栓 936
14.10.3　Barriers / 障栅 936
14.10.4　Exchangers / 交换器 937
14.10.5　Synchronous Queues / 同步队列 937
14.11　Threads and Swing / 线程与Swing 937
14.11.1　Running Time-Consuming Tasks / 运行耗时任务 939
14.11.2　Using the Swing Worker / 使用Swing工作线程 943
14.11.3　The Single-Thread Rule / 单线程规则 951
Appendix / 附录 953
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java核心技术 卷I 基础知识 第10版 英文版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web开发实战1200例（第Ⅱ卷）
第1篇  流行组件应用篇第1章  操作XML文件第2章  发送与接收邮件第2篇  数据库应用篇第3章  数据库操作技术第4章  SQL语句应用技术第5章  复杂查询技术第6章  数据库高级应用第3篇  图表统计篇第7章  JFreeChart绘图基础第8章  基础图表技术第9章  扩展图表技术第10章  基于Cewolf组件的图表编程第4篇  Ajax框架应用篇第11章  Prototype框架第12章  jQuery框架第13章  Dojo框架第5篇  流行框架篇第14章  Struts2框架应用第15章  Struts2框架标签应用第16章  Hibernate框架基础第17章  Hibernate高级话题第18章  Spring框架基础第19章  Spring的Web MVC框架第6篇  网站安全与架构模式篇第20章  网站性能优化与安全策略第21章  设计模式与架构第7篇  综合应用篇第22章  网站设计与网页配色第23章  Java Web典型项目开发案例
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web开发实战1200例（第Ⅱ卷）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序员生存手册
第1部分　求职过程篇
第1章　职业规划
第2章　简历撰写
第3章　面试
第2部分　Java试题篇
第4章　Java编程基础
第5章　Java语言基础
第6章　运算符和类型转换
第7章　声明和访问控制
第8章　深入理解面向对象的精髓
第9章　流程控制、异常处理和断言
第10章　对象生存期
第11章　线程
第12章　基础类
第13章　Servlet/JSP基础
第14章　数据库技术
第15章　软件工程和UML
第3部分　思维拓展篇
第16章　思维拓展面试题
第4部分　职场生涯篇
第17章　踏上征途
第18章　渐入佳境
第19章　风雨江湖
第20章　更上层楼
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序员生存手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.NET程序设计
第一部分  C#基础
1  NET Framework
2  C#起步
3  C#和Java的区别
4  对象
5  继承和多态性
6  接口
7  数据类型
8  运算符
9  基本控制流
10  异常
11  数组
12  字符串
13  格式化数字、字符串和日期
14  集合
15  C#的I/O API
16  线程编程
17  C#的属性、索引器和特性
18  委托和事件编程
第二部分  高级C#
19  访问数据库
20  处理XML
21  C#中的GUI程序设计
22  反射
23  程序集、应用程序配置和进程管理
附录  Java与C#中API的比较
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.NET程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java完全参考手册
目 录
第Ⅰ部分 Java语言
第1章 Java的历史和演变 .................... 3
1.1 Java的家世 ................................. 4
1.1.1 现代编程语言的诞生：
C语言 ...................................... 4
1.1.2 C++：下一个阶段 ................... 5
1.1.3 Java出现的时机已经成熟 ..... 6
1.2 Java的诞生 ................................. 6
1.3 Java改变Internet的方式 ........... 8
1.3.1 Java applet ................................ 8
1.3.2 安全性 ...................................... 8
1.3.3 可移植性 .................................. 9
1.4 Java的魔力：字节码 ................. 9
1.5 servlet：服务器端的Java ......... 10
1.6 Java的关键特性 ....................... 10
1.6.1 简单性 ................................... 10
1.6.2 面向对象 ............................... 11
1.6.3 健壮性 ................................... 11
1.6.4 多线程 ................................... 11
1.6.5 体系结构中立 ....................... 11
1.6.6 解释执行和高性能................ 12
1.6.7 分布式 ................................... 12
1.6.8 动态性 ................................... 12
1.7 Java的演变历程 ....................... 12
1.8 文化革新 ................................... 15
Java 完全参考手册(第 8 版)
VIII
第2章 Java综述 ................................ 17
2.1 面向对象编程 ........................... 17
2.1.1 两种范式 ................................ 18
2.1.2 抽象........................................ 18
2.1.3 OOP三原则 ........................... 19
2.2 第一个简单程序 ....................... 23
2.2.1 输入程序 ................................ 23
2.2.2 编译程序 ................................ 23
2.2.3 深入分析第一个示例程序 .... 24
2.3 第二个简短程序 ....................... 26
2.4 两种控制语句 ........................... 28
2.4.1 if语句 .................................... 28
2.4.2 for循环 .................................. 29
2.5 使用代码块 ............................... 30
2.6 词汇问题 ................................... 32
2.6.1 空白符 .................................... 32
2.6.2 标识符 .................................... 32
2.6.3 字面值 .................................... 32
2.6.4 注释........................................ 32
2.6.5 分隔符 .................................... 33
2.6.6 Java关键字 ............................ 33
2.7 Java类库 ................................... 34
第3章 数据类型、变量和数组 ............ 35
3.1 Java是强类型化的语言 ........... 35
3.2 基本类型 ................................... 36
3.3 整型 ........................................... 36
3.3.1 byte ......................................... 37
3.3.2 short........................................ 37
3.3.3 int ........................................... 37
3.3.4 long ........................................ 37
3.4 浮点型 ....................................... 38
3.4.1 float ........................................ 38
3.4.2 double ..................................... 39
3.5 字符型 ....................................... 39
3.6 布尔型 ....................................... 41
3.7 深入分析字面值 ....................... 42
3.7.1 整型字面值 ............................ 42
3.7.2 浮点型字面值 ....................... 43
3.7.3 布尔型字面值 ....................... 44
3.7.4 字符型字面值 ....................... 44
3.7.5 字符串字面值 ....................... 44
3.8 变量 ........................................... 45
3.8.1 变量的声明 ........................... 45
3.8.2 动态初始化 ........................... 45
3.8.3 变量的作用域和生命周期.... 46
3.9 类型转换和强制类型转换 ........ 48
3.9.1 Java的自动类型转换 ........... 49
3.9.2 强制转换不兼容的类型 ........ 49
3.10 表达式中的自动类型提升 ...... 50
3.11 数组 .......................................... 52
3.11.1 一维数组 ............................ 52
3.11.2 多维数组 ............................ 54
3.11.3 另一种数组声明语法 ........ 58
3.12 关于字符串的一些说明 .......... 59 3.13 向C/C++程序员提供指针
方面的注解 ............................. 60
第4章 运算符 ...................................... 61
4.1 算术运算符................................ 61
4.1.1 基本算术运算符 ................... 62
4.1.2 求模运算符 ........................... 63
4.1.3 算术与赋值复合运算符 ........ 64
4.1.4 自增与自减运算符................ 65
4.2 位运算符 ................................... 66
4.2.1 位逻辑运算符 ....................... 68
4.2.2 左移 ....................................... 70
4.2.3 右移 ....................................... 71
4.2.4 无符号右移 ........................... 73
4.2.5 位运算符与赋值的组合 ........ 74
4.3 关系运算符................................ 75
4.4 布尔逻辑运算符 ........................ 76
4.5 赋值运算符................................ 78
4.6 “?”运算符 .............................. 78
4.7 运算符的优先级 ........................ 79
4.8 使用圆括号................................ 80
目 录
IX
第5章 控制语句 .................................. 83
5.1 Java的选择语句 ....................... 83
5.1.1 if语句 .................................... 84
5.1.2 switch语句 ............................ 87
5.2 迭代语句 ................................... 91
5.2.1 while语句 .............................. 92
5.2.2 do-while语句......................... 93
5.2.3 for语句 .................................. 96
5.2.4 for循环的for-each版本 .... 100
5.2.5 嵌套的循环 ......................... 105
5.3 跳转语句 ................................. 106
5.3.1 使用break语句 .................. 106
5.3.2 使用continue语句 .............. 110
5.3.3 return语句 ........................... 111
第6章 类........................................... 113
6.1 类的基础知识 ......................... 114
6.1.1 类的一般形式 ...................... 114
6.1.2 一个简单的类 ...................... 115
6.2 声明对象 ................................. 117
6.3 为对象引用变量赋值 ............. 119
6.4 方法 ......................................... 120
6.4.1 为Box类添加方法 ............ 120
6.4.2 返回值 ................................. 122
6.4.3 添加带参数的方法 ............. 124
6.5 构造函数 ................................. 126
6.6 this关键字 .............................. 129
6.7 垃圾回收 ................................. 130
6.8 finalize()方法 ........................... 130
6.9 堆栈类 ..................................... 131
第7章 方法和类的深入分析.............. 135
7.1 重载方法 ................................. 135
7.2 将对象用作参数 ..................... 140
7.3 参数传递的深入分析 ............. 143
7.4 返回对象 ................................. 145
7.5 递归 ......................................... 146
7.6 访问控制 ................................. 148
7.7 理解static ................................ 151
7.8 final介绍 ................................. 153
7.9 重新审视数组.......................... 154
7.10 嵌套类和内部类 .................... 156
7.11 String类介绍 ......................... 158
7.12 使用命令行参数 .................... 161
7.13 varargs：可变长度参数 ........ 162
7.13.1 重载varargs方法 ............ 165
7.13.2 varargs方法与模糊性 ..... 166
第8章 继承 ....................................... 169
8.1 继承的基础知识 ...................... 169
8.1.1 成员访问与继承 ................. 171
8.1.2 一个更实际的例子.............. 172 8.1.3 超类变量可以引用子类
对象 ..................................... 174
8.2 使用super关键字 ................... 175 8.2.1 使用super调用超类的
构造函数 ............................. 176
8.2.2 super的另一种用法 ............ 179
8.3 创建多级继承层次 .................. 180
8.4 构造函数的调用时机 .............. 183
8.5 方法重写 ................................. 184
8.6 动态方法调度.......................... 187
8.6.1 重写方法的目的 ................. 189
8.6.2 应用方法重写 ..................... 189
8.7 使用抽象类.............................. 191
8.8 在继承中使用final关键字 .... 193 8.8.1 使用final关键字阻止
重写 ..................................... 194 8.8.2 使用final关键字阻止
继承 ..................................... 194
8.9 Object类 .................................. 195
第9章 包和接口 ............................... 197
9.1 包 ............................................. 198
9.1.1 定义包 ................................. 198
9.1.2 包查找与CLASSPATH....... 199
9.1.3 一个简短的包示例.............. 199
9.2 访问保护 ................................. 200
Java 完全参考手册(第 8 版)
X
9.3 导入包 ..................................... 204
9.4 接口 ......................................... 206
9.4.1 定义接口 ............................. 207
9.4.2 实现接口 ............................. 207
9.4.3 嵌套接口 ............................. 210
9.4.4 应用接口 .............................. 211
9.4.5 接口中的变量 ..................... 214
9.4.6 接口可以扩展 ..................... 216
第10章 异常处理 .............................. 219
10.1 异常处理的基础知识 ........... 219
10.2 异常类型 ............................... 220
10.3 未捕获的异常 ....................... 221
10.4 使用try和catch ................... 222
10.5 多条catch子句 ..................... 224
10.6 嵌套的try语句 ..................... 226
10.7 throw ...................................... 228
10.8 throws .................................... 229
10.9 finally ..................................... 230
10.10 Java的内置异常 ................. 232
10.11 创建自己的异常子类 ......... 233
10.12 链式异常 ............................. 235 10.13 JDK 7中3个新的
异常特性 ............................. 237
10.14 使用异常 ............................. 238
第11章 多线程编程 .......................... 239
11.1 Java线程模型 ....................... 240
11.1.1 线程优先级 ..................... 241
11.1.2 同步 ................................. 242
11.1.3 消息传递 ......................... 242 11.1.4 Thread类和Runnable
接口 ................................. 242
11.2 主线程 ................................... 243
11.3 创建线程 ............................... 244
11.3.1 实现Runnable接口 ........ 245
11.3.2 扩展Thread类 ............... 247
11.3.3 选择一种创建方式 ......... 248
11.4 创建多个线程 ....................... 248
11.5 使用isAlive()和join()方法 .... 250
11.6 线程优先级 ............................ 252
11.7 同步 ........................................ 253
11.7.1 使用同步方法 ................. 253
11.7.2 synchronized语句 ........... 255
11.8 线程间通信 ............................ 257
11.9 挂起、恢复与停止线程 ........ 263 11.9.1 Java 1.1以前使用的挂起、
恢复和停止线程的方式 .... 264 11.9.2 挂起、恢复与停止线程的
现代方式.......................... 266
11.10 获取线程的状态 .................. 268
11.11 使用多线程 .......................... 270 第12章 枚举、自动装箱与注解
(元数据) ............................... 271
12.1 枚举 ....................................... 271
12.1.1 枚举的基础知识 ............. 272 12.1.2 values()和valueOf()
方法 ................................. 274
12.1.3 Java枚举是类类型 ......... 275
12.1.4 枚举继承自Enum类 ...... 278
12.1.5 另一个枚举示例 ............. 279
12.2 类型封装器............................ 281
12.2.1 Character封装器 ............. 281
12.2.2 Boolean封装器 ............... 282
12.2.3 数值类型封装器 ............. 282
12.3 自动装箱 ............................... 283
12.3.1 自动装箱与方法 ............. 284 12.3.2 表达式中发生的
自动装箱/拆箱................. 285 12.3.3 布尔型和字符型数值的
自动装箱/拆箱................. 287 12.3.4 自动装箱/拆箱有助于
防止错误.......................... 287
12.3.5 一些警告 ......................... 288
12.4 注解(元数据) ......................... 289
12.4.1 注解的基础知识 ............. 289
目 录
XI
12.4.2 指定保留策略 ................. 289 12.4.3 在运行时使用反射获取
注解 ................................. 290
12.4.4 AnnotatedElement接口 .... 296
12.4.5 使用默认值 ..................... 296
12.4.6 标记注解......................... 297
12.4.7 单成员注解 ..................... 298
12.4.8 内置注解......................... 300
12.4.9 一些限制......................... 301
第13章 I/O、applet以及其他主题 ...... 303
13.1 I/O的基础知识 ..................... 304
13.1.1 流 .................................... 304
13.1.2 字节流和字符流 ............. 304
13.1.3 预定义流......................... 306
13.2 读取控制台输入 ................... 307
13.2.1 读取字符......................... 307
13.2.2 读取字符串 ..................... 308
13.3 向控制台写输出 ................... 310
13.4 PrintWriter类 ........................ 311
13.5 读/写文件 .............................. 312
13.6 自动关闭文件 ....................... 318
13.7 applet的基础知识................. 321
13.8 transient和volatile修饰符 .... 324
13.9 使用instanceof运算符 ......... 324
13.10 strictfp .................................. 327
13.11 本地方法 ............................. 327
13.12 使用断言 ............................. 331
13.13 静态导入 ............................. 334 13.14 通过this()调用重载的
构造函数 ............................. 336
第14章 泛型 ..................................... 339
14.1 什么是泛型 ........................... 340
14.2 一个简单的泛型示例 ........... 340
14.2.1 泛型只使用对象 ............. 344 14.2.2 基于不同类型参数的
泛型类型是不同的 ......... 344 14.2.3 泛型提升类型安全性的
原理 ................................. 344
14.3 带两个类型参数的泛型类 .... 347
14.4 泛型类的一般形式 ................ 348
14.5 有界类型 ............................... 349
14.6 使用通配符参数 .................... 351
14.7 创建泛型方法........................ 359
14.8 泛型接口 ............................... 362
14.9 原始类型与遗留代码 ............ 364
14.10 泛型类层次.......................... 367
14.10.1 使用泛型超类 ............. 367
14.10.2 泛型子类 ..................... 369 14.10.3 泛型层次中的运行时
类型比较 ..................... 370
14.10.4 强制转换 ..................... 373
14.10.5 重写泛型类的方法 ..... 373
14.11 泛型的类型推断 .................. 374
14.12 擦拭 ..................................... 376
14.13 模糊性错误.......................... 379
14.14 使用泛型的一些限制 .......... 381
14.14.1 不能实例化类型参数 ... 381 14.14.2 对静态成员的一些
限制 ............................. 381 14.14.3 对泛型数组的一些
限制 ............................. 382
14.14.4 对泛型异常的限制 ..... 383 第Ⅱ部分 Java库
第15章 字符串处理 .......................... 387
15.1 String类的构造函数 ............. 388
15.2 字符串的长度........................ 390
15.3 特殊的字符串操作 ................ 391
15.3.1 字符串字面值 ................. 391
15.3.2 字符串连接 ..................... 391 15.3.3 字符串和其他数据
类型的连接 ..................... 392 15.3.4 字符串转换和toString()
方法 ................................. 393
Java 完全参考手册(第 8 版)
XII
15.4 提取字符 ............................... 394
15.4.1 charAt() ........................... 394
15.4.2 getChars() ........................ 394
15.4.3 getBytes() ........................ 395
15.4.4 toCharArray() .................. 395
15.5 比较字符串 ........................... 395 15.5.1 equals()和
equalsIgnoreCase() .......... 395
15.5.2 regionMatches() .............. 396 15.5.3 startsWith()和
endsWith() ....................... 397
15.5.4 equals()与== ................... 397
15.5.5 compareTo() .................... 398
15.6 查找字符串 ........................... 399
15.7 修改字符串 ........................... 401
15.7.1 substring() ....................... 401
15.7.2 concat() ........................... 402
15.7.3 replace() .......................... 402
15.7.4 trim() ............................... 403
15.8 使用valueOf()转换数据 ....... 404 15.9 改变字符串中字符的
大小写 ................................... 404
15.10 其他String方法 .................. 405
15.11 StringBuffer类 .................... 406 15.11.1 StringBuffer类的
构造函数 .................... 406
15.11.2 length()与capacity() ... 407
15.11.3 ensureCapacity() ......... 407
15.11.4 setLength() .................. 408 15.11.5 charAt()与
setCharAt() ................. 408
15.11.6 getChars() ................... 409
15.11.7 append() ...................... 409
15.11.8 insert() ......................... 409
15.11.9 reverse() ...................... 410 15.11.10 delete()与
deleteCharAt()............ 411
15.11.11 replace() ..................... 411
15.11.12 substring() .................. 412 15.11.13 其他StringBuffer
方法 ........................... 412
15.12 StringBuilder类 ................... 413
第16章 探究java.lang ..................... 415
16.1 基本类型封装器 .................... 416
16.1.1 Number ............................ 416
16.1.2 Double与Float ............... 417 16.1.3 理解isInfinite()与
isNaN() ............................ 420 16.1.4 Byte、Short、Integer和
Long ................................. 420
16.1.5 Character .......................... 427 16.1.6 对Unicode代码点的
附加支持 ......................... 430
16.1.7 Boolean ............................ 431
16.2 Void类 ................................... 432
16.3 Process类 .............................. 432
16.4 Runtime类 ............................. 433
16.4.1 内存管理 ......................... 434
16.4.2 执行其他程序 ................. 435
16.5 ProcessBuilder类 .................. 436
16.6 System类 ............................... 439 16.6.1 使用currentTimeMillis()
计时程序的执行 ............. 440
16.6.2 使用arraycopy() .............. 441
16.6.3 环境属性 ......................... 442
16.7 Object类 ................................ 442 16.8 使用clone()方法和Cloneable
接口 ....................................... 443
16.9 Class类 .................................. 445
16.10 ClassLoader类 ..................... 448
16.11 Math类 ................................ 448
16.11.1 三角函数 ..................... 448
16.11.2 指数函数 ..................... 449
16.11.3 舍入函数 ..................... 449
16.11.4 其他数学方法 ............. 450
目 录
XIII
16.12 StrictMath类 ....................... 452
16.13 Compiler类 ......................... 452 16.14 Thread类、ThreadGroup类
和Runnable接口 ................ 452
16.14.1 Runnable接口 ............ 452
16.14.2 Thread类 .................... 452
16.14.3 ThreadGroup类 .......... 454 16.15 ThreadLocal和
InheritableThreadLocal类 .... 459
16.16 Package类 ........................... 459
16.17 RuntimePermission类 ......... 460
16.18 Throwable类 ....................... 460
16.19 SecurityManager类 ............. 460
16.20 StackTraceElement类 ......... 460
16.21 Enum类 ............................... 461
16.22 ClassValue类 ...................... 462
16.23 CharSequence接口 ............. 462
16.24 Comparable接口 ................. 462
16.25 Appendable接口 ................. 463
16.26 Iterable接口 ........................ 463
16.27 Readable接口 ..................... 464
16.28 AutoCloseable接口 ............. 464 16.29 Thread.UncaughtException-
Handler接口 ....................... 464
16.30 java.lang子包 ...................... 464
16.30.1 java.lang.annotation .... 465
16.30.2 java.lang.instrument .... 465
16.30.3 java.lang.invoke .......... 465
16.30.4 java.lang.management ... 465
16.30.5 java.lang.ref ................ 465
16.30.6 java.lang.reflect........... 465 第17章 java.util第1部分：
集合框架 .............................. 467
17.1 集合概述 ............................... 468
17.2 JDK 5对集合框架的修改 .... 469 17.2.1 泛型从根本上改变了
集合框架 ......................... 470 17.2.2 自动装箱使得使用基本
类型更加容易 ................. 470
17.2.3 for-each风格的循环 ....... 470
17.3 集合接口 ............................... 470
17.3.1 Collection接口 ................ 471
17.3.2 List接口 .......................... 473
17.3.3 Set接口 ........................... 474
17.3.4 SortedSet接口 ................. 474
17.3.5 NavigableSet接口 ........... 475
17.3.6 Queue接口 ...................... 476
17.3.7 Deque接口 ...................... 477
17.4 集合类 ................................... 479
17.4.1 ArrayList类 ..................... 480
17.4.2 LinkedList类 ................... 483
17.4.3 HashSet类 ....................... 484
17.4.4 LinkedHashSet类 ............ 486
17.4.5 TreeSet类 ........................ 486
17.4.6 PriorityQueue类 .............. 487
17.4.7 ArrayDeque类 ................. 488
17.4.8 EnumSet类 ...................... 489
17.5 通过迭代器访问集合 ............ 490
17.5.1 使用迭代器 ..................... 491 17.5.2 使用for-each循环替代
迭代器 ............................. 493 17.6 在集合中存储用户
定义的类................................ 494
17.7 RandomAccess接口 .............. 495
17.8 使用映射 ............................... 496
17.8.1 映射接口 ......................... 496
17.8.2 映射类 ............................. 500
17.9 比较器 ................................... 505
17.10 集合算法.............................. 508
17.11 Arrays类 .............................. 513
17.12 需要泛型集合的原因 .......... 518
17.13 遗留的类和接口 .................. 521
17.13.1 Enumeration接口 ....... 521
17.13.2 Vector类 ..................... 521
17.13.3 Stack类 ....................... 525
Java 完全参考手册(第 8 版)
XIV
17.13.4 Dictionary类 .............. 527
17.13.5 Hashtable类 ............... 528
17.13.6 Properties类 ............... 532
17.13.7 使用store()和load() .... 535
17.14 集合小结 ............................. 537 第18章 java.util第2部分：更多实用
工具类 ................................. 539
18.1 StringTokenizer类 ................. 539
18.2 BitSet类 ................................ 541
18.3 Date类 ................................... 544
18.4 Calendar类 ............................ 546
18.5 GregorianCalendar类 ............ 549
18.6 TimeZone类 .......................... 550
18.7 SimpleTimeZone类 .............. 551
18.8 Locale类 ............................... 552
18.9 Random类 ............................. 554
18.10 Observable类 ...................... 555
18.10.1 Observer接口 ............. 556
18.10.2 Observer示例 ............. 556
18.11 Timer和TimerTask类 ........ 559
18.12 Currency类 ......................... 561
18.13 Formatter类 ........................ 562 18.13.1 Formatter类的
构造函数 .................... 563
18.13.2 Formatter类的方法 .... 563
18.13.3 格式化的基础知识 .... 564
18.13.4 格式化字符串和字符 ... 566
18.13.5 格式化数字 ................ 566
18.13.6 格式化时间和日期 .... 567
18.13.7 %n和%%说明符 ....... 569
18.13.8 指定最小字段宽度 .... 569
18.13.9 指定精度 .................... 571
18.13.10 使用格式标志 .......... 572
18.13.11 对齐输出 .................. 572 18.13.12 空格、“+”、“0”以及
“(”标志 ................... 573
18.13.13 逗号标志 .................. 574
18.13.14 “#：”标志 ............... 574
18.13.15 大写选项 ................... 574
18.13.16 使用参数索引 ........... 575
18.13.17 关闭Formatter对象 ... 577
18.13.18 printf()方法 ............... 577
18.14 Scanner类 ............................ 577 18.14.1 Scanner类的
构造函数 ..................... 577
18.14.2 扫描的基础知识 ......... 578
18.14.3 一些Scanner示例 ...... 581
18.14.4 设置定界符 ................. 585
18.14.5 其他Scanner特性 ...... 587 18.15 ResourceBundle、 ListResourceBundle和
PropertyResourceBundle类.... 588
18.16 其他实用工具类和接口 ...... 592
18.17 java.util子包........................ 593 18.17.1 java.util.concurrent、 java.util.concurrent.atomic 和java.util.concurrent.
locks ............................ 593
18.17.2 java.util.jar ................... 593
18.17.3 java.util.logging ........... 593
18.17.4 java.util.prefs ............... 593
18.17.5 java.util.regex .............. 594
18.17.6 java.util.spi .................. 594
18.17.7 java.util.zip .................. 594
第19章 输入/输出：探究Java.io ...... 595
19.1 I/O类和接口 ......................... 596
19.2 File类 .................................... 597
19.2.1 目录 ................................. 600 19.2.2 使用FilenameFilter
接口 ................................. 601
19.2.3 listFiles()方法 .................. 602
19.2.4 创建目录 ......................... 602 19.3 AutoCloseable、Closeable和
Flushable接口 ....................... 602
目 录
XV
19.4 I/O异常 ................................. 603
19.5 关闭流的两种方式 ............... 604
19.6 流类 ....................................... 605
19.7 字节流 ................................... 605
19.7.1 InputStream类 ................ 605
19.7.2 OutputStream类 ............. 606
19.7.3 FileInputStream类 .......... 606
19.7.4 FileOutputStream类 ....... 609 19.7.5 ByteArrayInputStream
类 ..................................... 611 19.7.6 ByteArrayOutputStream
类 .................................... 613
19.7.7 过滤的字节流 ................. 614
19.7.8 缓存的字节流 ................. 614
19.7.9 SequenceInputStream类 .... 618
19.7.10 PrintStream类 ............... 620 19.7.11 DataOutputStream和
DataInputStream类 ...... 622
19.7.12 RandomAccessFile类 ... 624
19.8 字符流 ................................... 625
19.8.1 Reader类 ........................ 625
19.8.2 Writer类 ......................... 626
19.8.3 FileReader类 .................. 627
19.8.4 FileWriter类 ................... 627
19.8.5 CharArrayReader类 ....... 628
19.8.6 CharArrayWriter类 ........ 630
19.8.7 BufferedReader类 .......... 631
19.8.8 BufferedWriter类 ........... 633
19.8.9 PushbackReader类 ......... 633
19.8.10 PrintWriter类 ................ 634
19.9 Console类 ............................. 635
19.10 串行化 ................................. 637
19.10.1 Serializable接口 ........ 637
19.10.2 Externalizable接口 .... 637
19.10.3 ObjectOutput接口 ...... 638 19.10.4 ObjectOutputStream
类 ................................ 638
19.10.5 ObjectInput接口 ........ 639
19.10.6 ObjectInputStream类 .... 640
19.10.7 串行化示例 ................. 641
19.11 流的优点 .............................. 642
第20章 探究NIO ............................. 643
20.1 NIO类 ................................... 643
20.2 NIO的基础知识 ................... 644
20.2.1 缓存 ................................. 644
20.2.2 通道 ................................. 646
20.2.3 字符集和选择器 ............. 647
20.3 JDK 7对NIO的增强 ........... 648
20.3.1 Path接口 ......................... 648
20.3.2 Files类 ............................ 649
20.3.3 Path接口 ......................... 651
20.3.4 文件属性接口 ................. 652 20.3.5 FileSystem、FileSystems
和FileStore类 ................ 654
20.4 使用NIO系统 ...................... 654 20.4.1 为基于通道的I/O使用
NIO .................................. 654 20.4.2 为基于流的I/O
使用NIO ......................... 663 20.4.3 为路径和文件系统操作
使用NIO ......................... 666 20.5 JDK 7之前基于通道的
例子 ....................................... 674
20.5.1 读文件(JDK 7之前) ....... 674
20.5.2 写文件(JDK 7之前) ....... 677
第21章 联网 ..................................... 681
21.1 联网的基础知识 .................... 682
21.2 联网类和接口........................ 683
21.3 InetAddress类 ....................... 683
21.3.1 工厂方法 ......................... 684
21.3.2 实例方法 ......................... 685 21.4 Inet4Address类和
Inet6Address类...................... 685
21.5 TCP/IP客户端套接字 ........... 686
21.6 URL类 .................................. 689
Java 完全参考手册(第 8 版)
XVI
21.7 URLConnection类 ................ 691
21.8 HttpURLConnection类 ......... 694
21.9 URI类 ................................... 696
21.10 cookie................................... 696
21.11 TCP/IP服务器套接字 ........ 696
21.12 数据报 ................................. 697
21.12.1 DatagramSocket类 ..... 697
21.12.2 DatagramPacket类 ..... 698
21.12.3 数据报示例 ................ 699
第22章 Applet类 ............................. 701
22.1 applet的两种类型................. 701
22.2 applet的基础知识................. 702
22.3 applet的架构 ........................ 704
22.4 applet的骨架 ........................ 705
22.4.1 applet的初始化和终止 ... 706
22.4.2 重写update()方法 .......... 707
22.5 简单的applet显示方法 ........ 707
22.6 请求重画 ............................... 709
22.7 使用状态栏窗口 ................... 712
22.8 HTML APPLET标签 ............ 713
22.9 向applet传递参数................ 714 22.10 getDocumentBase()和
getCodeBase() ...................... 718 22.11 AppletContext接口和
showDocument()方法 .......... 718
22.12 AudioClip接口 ................... 720
22.13 AppletStub接口 .................. 720
22.14 向控制台输出 ..................... 720
第23章 事件处理 .............................. 721
23.1 两种事件处理机制 ............... 722
23.2 委托事件模型 ....................... 722
23.2.1 事件 ................................ 722
23.2.2 事件源 ............................ 723
23.2.3 事件监听器 ..................... 723
23.3 事件类 ................................... 724
23.3.1 ActionEvent类 ............... 725
23.3.2 AdjustmentEvent类 ........ 726
23.3.3 ComponentEvent类 ........ 726
23.3.4 ContainerEvent类 ........... 727
23.3.5 FocusEvent类 ................. 727
23.3.6 InputEvent类................... 728
23.3.7 ItemEvent类 .................... 729
23.3.8 KeyEvent类 .................... 730
23.3.9 MouseEvent类 ................ 730
23.3.10 MouseWheelEvent类 .... 732
23.3.11 TextEvent类 .................. 733
23.3.12 WindowEvent类 ........... 733
23.4 事件源 ................................... 734
23.5 事件监听器接口 .................... 735
23.5.1 ActionListener接口 ........ 736 23.5.2 AdjustmentListener
接口 ................................. 736 23.5.3 ComponentListener
接口 ................................. 736
23.5.4 ContainerListener接口 .... 736
23.5.5 FocusListener接口 .......... 736
23.5.6 ItemListener接口 ............ 736
23.5.7 KeyListener接口 ............. 737
23.5.8 MouseListener接口 ........ 737 23.5.9 MouseMotionListener
接口 ................................. 737 23.5.10 MouseWheelListener
接口 ............................... 737
23.5.11 TextListener接口 .......... 738 23.5.12 WindowFocusListener
接口 ............................... 738
23.5.13 WindowListener接口 .... 738
23.6 使用委托事件模型 ................ 738
23.6.1 处理鼠标事件 ................. 739
23.6.2 处理键盘事件 ................. 741
23.7 适配器类 ............................... 744
23.8 内部类 ................................... 746 第24章 AWT介绍：使用窗口、
图形和文本 .......................... 749
24.1 AWT类 .................................. 750
24.2 窗口基本元素........................ 752
24.2.1 Component类 .................. 752
目 录
XVII
24.2.2 Container类 .................... 753
24.2.3 Panel类 ........................... 753
24.2.4 Window类 ...................... 753
24.2.5 Frame类 ......................... 753
24.2.6 Canvas类 ........................ 753
24.3 使用框架窗口 ....................... 753
24.3.1 设置窗口的尺寸 ............. 754
24.3.2 隐藏和显示窗口 ............. 754
24.3.3 设置窗口的标题 ............. 754
24.3.4 关闭框架窗口 ................. 754
24.4 在applet中创建框架窗口 .... 755
24.5 创建基于窗口的程序 ........... 761
24.6 在窗口中显示信息 ............... 763
24.7 使用图形 ............................... 763
24.7.1 绘制直线......................... 764
24.7.2 绘制矩形......................... 765
24.7.3 绘制椭圆和圆 ................. 765
24.7.4 绘制弧形......................... 766
24.7.5 绘制多边形 ..................... 767
24.7.6 改变图形的大小 ............. 767
24.8 使用颜色 ............................... 768
24.8.1 Color类的方法 ............... 769
24.8.2 设置当前图形的颜色 ..... 770
24.8.3 一个演示颜色的applet ... 770
24.9 设置绘图模式 ....................... 771
24.10 使用字体 ............................. 773
24.10.1 确定可用字体 ............ 774
24.10.2 创建和选择字体 ........ 775
24.10.3 获取字体信息 ............ 777 24.11 使用FontMetrics管理文本
输出 ...................................... 778
24.11.1 显示多行文本 ............ 779
24.11.2 居中显示文本 ............ 781
24.11.3 对齐多行文本 ............ 782 第25章 使用AWT控件、布局
管理器和菜单 ...................... 787
25.1 控件的基础知识 ................... 788
25.1.1 添加和移除控件 ............. 788
25.1.2 响应控件 ......................... 788
25.1.3 HeadlessException异常 ... 788
25.2 使用标签 ............................... 789
25.3 使用命令按钮........................ 790
25.4 使用复选框............................ 793
25.5 使用复选框组........................ 795
25.6 使用下拉列表........................ 796
25.7 使用列表框............................ 798
25.8 管理滚动条............................ 801
25.9 使用TextField ....................... 804
25.10 使用TextArea ...................... 807
25.11 理解布局管理器 .................. 808 25.11.1 FlowLayout布局
管理器 ......................... 809 25.11.2 BorderLayout布局
管理器 ......................... 811
25.11.3 使用Insets ................... 812 25.11.4 GridLayout布局
管理器 ......................... 814 25.11.5 CardLayout布局
管理器 ......................... 815 25.11.6 GridBagLayout布局
管理器 ......................... 818
25.12 菜单栏和菜单 ...................... 823
25.13 对话框 ................................. 829
25.14 FileDialog类 ....................... 834 25.15 扩展AWT控件以处理
事件 ..................................... 835
25.15.1 扩展按钮 ..................... 836
25.15.2 扩展复选框 ................. 837
25.15.3 扩展复选框组 ............. 838
25.15.4 扩展下拉列表 ............. 839
25.15.5 扩展列表框 ................. 840
25.15.6 扩展滚动条 ................. 841
25.16 关于重载paint()方法 .......... 842
Java 完全参考手册(第 8 版)
XVIII
第26章 图像 ..................................... 843
26.1 文件格式 ............................... 844 26.2 图像基础：创建、加载与
显示 ....................................... 844
26.2.1 创建Image对象 ............. 844
26.2.2 加载图像......................... 845
26.2.3 显示图像......................... 845
26.3 ImageObserver接口 .............. 846
26.4 双缓存 ................................... 848
26.5 MediaTracker类 .................... 850
26.6 ImageProducer接口 .............. 853
26.7 ImageConsumer接口 ............ 855
26.8 ImageFilter类 ........................ 857
26.8.1 CropImageFilter类 ......... 858
26.8.2 RGBImageFilter类 ......... 860
26.9 单元格动画 ........................... 870
26.10 其他图像类 ......................... 873
第27章 并发实用工具 ...................... 875
27.1 并发API包 ........................... 876
27.1.1 java.util.concurrent包 ..... 876 27.1.2 java.util.concurrent.atomic
包 .................................... 877 27.1.3 java.util.concurrent.locks
包 .................................... 877
27.2 使用同步对象 ....................... 877
27.2.1 Semaphore类 .................. 878
27.2.2 CountDownLatch类 ....... 884
27.2.3 CyclicBarrier类 .............. 885
27.2.4 Exchanger类................... 888
27.2.5 Phaser类 ......................... 890
27.3 使用执行器 ........................... 898 27.3.1 一个简单的执行器
示例 ............................ 898 27.3.2 使用Callable和Future
接口 ................................ 900
27.4 TimeUnit枚举 ....................... 903
27.5 并发集合 ............................... 904
27.6 锁 ........................................... 905
27.7 原子操作 ............................... 908 27.8 通过Fork/Join Framework
进行并行编程 ........................ 909
27.8.1 主要的Fork/Join类 ........ 909
27.8.2 分而治之的策略 ............. 912 27.8.3 一个简单的Fork/Join
示例 ................................. 913 27.8.4 理解并行级别带来的
影响 ................................. 915 27.8.5 一个使用RecursiveTask<V>
的例子 ............................. 918
27.8.6 异步执行任务 ................. 921
27.8.7 取消任务 ......................... 921
27.8.8 确定任务的完成状态 ..... 921
27.8.9 重新启动任务 ................. 922
27.8.10 深入研究 ....................... 922 27.8.11 关于Fork/Join Framework
的一些提示 ................... 923 27.9 并发实用工具与Java传统
方式的比较............................ 924
第28章 正则表达式和其他包 ........... 925
28.1 核心Java API包 ................... 926
28.2 正则表达式处理 .................... 927
28.2.1 Pattern类 ......................... 928
28.2.2 Matcher类 ....................... 928
28.2.3 正则表达式的语法 ......... 929
28.2.4 演示模式匹配 ................. 929
28.2.5 模式匹配的两个选项 ..... 935
28.2.6 探究正则表达式 ............. 935
28.3 反射 ....................................... 936
28.4 远程方法调用........................ 939
28.5 文本格式化............................ 943
28.5.1 DateFormat类 ................. 943
28.5.2 SimpleDateFormat类 ...... 945
目 录
XIX
第Ⅲ部分 使用Java开发软件
第29章 Java Bean ............................. 951
29.1 Java Bean是什么 .................. 952
29.2 Java Bean的优势 .................. 952
29.3 反省 ....................................... 952
29.3.1 属性的设计模式 ............. 952
29.3.2 事件的设计模式 ............. 954
29.3.3 方法与设计模式 ............. 954
29.3.4 使用BeanInfo接口 ........ 955
29.4 绑定属性与约束属性 ........... 955
29.5 持久性 ................................... 955
29.6 定制器 ................................... 956
29.7 Java Bean API ........................ 956
29.7.1 Introspector类 ................ 958
29.7.2 PropertyDescriptor类 ..... 958
29.7.3 EventSetDescriptor类 .... 958
29.7.4 MethodDescriptor类 ...... 958
29.8 一个Bean示例 ..................... 958
第30章 Swing简介 .......................... 963
30.1 Swing的起源 ........................ 964
30.2 Swing以AWT为基础 ......... 964
30.3 两个关键的Swing特性 ....... 964
30.3.1 Swing组件是轻量级的 ... 964
30.3.2 Swing支持可插入外观 ... 965
30.4 MVC连接 ............................. 965
30.5 组件与容器 ........................... 966
30.5.1 组件 ................................ 966
30.5.2 容器 ................................ 967
30.5.3 顶级容器窗格 ................. 967
30.6 Swing包 ................................ 967 30.7 一个简单的Swing
应用程序 ............................... 968
30.8 事件处理 ............................... 972
30.9 创建Swing applet ................. 975
30.10 在Swing中绘图 ................. 977
30.10.1 绘图的基础知识 ........ 977
30.10.2 计算可绘制区域 ........ 978
30.10.3 一个绘图示例 ............. 979
第31章 探究Swing .......................... 983
31.1 JLabel与ImageIcon .............. 984
31.2 JTextField ............................... 985
31.3 Swing按钮 ............................ 987
31.3.1 JButton ............................. 988
31.3.2 JToggleButton .................. 990
31.3.3 复选框 ............................. 992
31.3.4 单选按钮 ......................... 994
31.4 JTabbedPane .......................... 996
31.5 JScrollPane ............................. 998
31.6 JList ...................................... 1000
31.7 JComboBox.......................... 1003
31.8 树 ......................................... 1006
31.9 JTable ................................... 1009
31.10 继续研究Swing ................ 1011
第32章 servlet ............................... 1013
32.1 背景 ..................................... 1013
32.2 sevelet的生命周期 ............. 1014
32.3 Servlet开发选项 ................. 1015
32.4 使用Tomcat ......................... 1015
32.5 一个简单的servlet .............. 1017 32.5.1 创建和编译servlet
源代码 .......................... 1017
32.5.2 启动Tomcat ................. 1018 32.5.3 启动Web浏览器并
请求servlet ................... 1018
32.6 servlet API ............................ 1018
32.7 javax.servlet包 .................... 1018
32.7.1 Servlet接口 .................. 1019
32.7.2 ServletConfig接口 ....... 1020
32.7.3 ServletContext接口 ..... 1020
32.7.4 ServletRequest接口 ..... 1020
32.7.5 ServletResponse接口 ... 1021
32.7.6 GenericServlet类 ......... 1022
32.7.7 ServletInputStream类 ... 1022
32.7.8 ServletOutputStream类 ... 1022
Java 完全参考手册(第 8 版)
XX
32.7.9 servlet异常类 ............... 1022
32.8 读取servlet参数 ................. 1022
32.9 javax.servlet.http包 ............. 1024 32.9.1 HttpServletRequest
接口 .............................. 1025 32.9.2 HttpServletResponse
接口 .............................. 1025
32.9.3 HttpSession接口 .......... 1026 32.9.4 HttpSessionBindingListener
接口 .............................. 1027
32.9.5 Cookie类 ...................... 1027
32.9.6 HttpServlet类 ............... 1028
32.9.7 HttpSessionEvent类 ..... 1029 32.9.8 HttpSessionBindingEvent
类 .................................. 1030
32.10 处理HTTP请求和响应 ... 1030 32.10.1 处理HTTP GET
请求 .......................... 1030 32.10.2 处理HTTP POST
请求 .......................... 1032
32.11 使用cookie ........................ 1033
32.12 会话跟踪 ........................... 1035 第Ⅳ部分 Java应用
第33章 applet和servlet在金融领域的 应用 ................................... 1039
33.1 计算贷款的还款额 ............. 1040
33.1.1 RegPay中声明的变量 ... 1044
33.1.2 init()方法....................... 1044
33.1.3 makeGUI()方法 ............ 1044
33.1.4 actionPerformed()方法 .... 1047
33.1.5 compute()方法 .............. 1048
33.2 计算投资的未来收益 ......... 1048 33.3 计算为达到未来收益所需
要的初始投资额 ................. 1052 33.4 计算为拿到期望的养老金
所需要的初始投资额 ......... 1056
33.5 计算给定投资的最大收益 ... 1060
33.6 计算贷款余额 ..................... 1064 33.7 创建应用于金融领域的
servlet ................................... 1068 33.7.1 将RegPay applet转换为
servlet............................ 1069
33.7.2 RegPayS servlet ............ 1069
33.8 一些尝试 ............................. 1072
第34章 使用Java创建下载管理器 ... 1073
34.1 理解Internet下载 ............... 1074
34.2 下载管理器概述 .................. 1074
34.3 DownLoad类....................... 1075
34.3.1 DownLoad类的变量 ... 1079 34.3.2 DownLoad类的
构造函数 ...................... 1079
34.3.3 download()方法 ............ 1079
34.3.4 run()方法 ...................... 1079
34.3.5 stateChanged()方法 ...... 1083
34.3.6 动作和访问器方法 ...... 1083
34.4 ProgressRenderer类 ............ 1083
34.5 DownloadsTableModel类 ... 1084
34.5.1 addDownload()方法 ..... 1086
34.5.2 clearDownload()方法 ... 1087
34.5.3 getColumnClass()方法 ... 1087
34.5.4 getValueAt()方法 .......... 1087
34.5.5 update()方法 ................. 1088
34.6 DownloadManager类 .......... 1088 34.6.1 DownloadManager类的
变量 .............................. 1094 34.6.2 DownloadManager类的
构造函数 ...................... 1095
34.6.3 verifyUrl()方法 ............. 1095 34.6.4 tableSelectionChanged()
方法 .............................. 1096
34.6.5 updateButtons()方法 ..... 1096
34.6.6 处理动作事件 .............. 1097
34.7 编译和运行下载管理器 ...... 1098
34.8 进一步完善下载管理器 ...... 1098
附录 使用Java的文档注释 ............. 1099
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java完全参考手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言与面向对象程序设计
目录
第1章 面向对象软件开发概述
1.1 面向对象问题求解的提出
1.2 面向对象问题求解概述
1.3 对象、类与实体
1.4 对象的属性与相互关系
1.4.1 象的属性
1.4.2 对象的关系
1.5 面向对象的软件开发过程
1.5.1 面向对象的分析
1.5.2 面向对象的设计
1.5.3 面向对象的实现
1.6 面向对象程序设计方法的优点
1.6.1 可重用性
1.6.2 可扩展性
1.6.3 可管理性
1.7 小结
习题
第2章 Java概述
2.1 第一个Java Application程序
2.1.1 源程序编辑
2.1.2 字节码的编译生成
2.1.3 字节码的解释与运行
2.2 第一个Java Applet程序
2.2.1 源程序的编辑与编译
2.2.2 代码嵌入
2.2.3 Applet的运行
2.3 图形界面的输入输出
2.3.1 Java Applet图形界面输入输出
2.3.2 Java Application图形界面输入输出
2.4 字符界面的输入输出
2.5 Java语言的特点
2.6 小结
习题
第3章 Java语言基础
3.1 Java程序的构成
3.2 数据类型、变量与常量
3.2.1 数据类型
3.2.2 标识符
3.2.3 常量
3.2.4 变量
3.3 表达式
3.3.1 赋值与强制类型转换
3.3.2 算术运算
3.3.3 关系运算
3.3.4 逻辑运算
3.3.5 位运算
3.3.6 其他运算符
3.3.7 运算符的优先级与结合性
3.3.8 注释
3.4 流程控制语句
3.4.1 结构化程序设计的三种基本流程
3.4.2 分支语句
3.4.3 循环语句
3.4.4 跳转语句
3.5 小结
习题
第4章 抽象、封装与类
4.1 抽象与封装
4.1.1 抽象
4.1.2 封装
4.2 Java的类
4.2.1 系统定义的类
4.2.2 用户程序自定义类
4.2.3 创建对象与定义构造函数
4.3 类的修饰符
4.3.1 抽象类
4.3.2 最终类
4.4 域
4.5 方法
4.6 访问控制符
4.7 小结
习题
第5章 继承与多态
5.1 继承
5.2 Java的继承
5.2.1 派生子类
5.2.2 域的继承与隐藏
5.2.3 方法的继承与覆盖
5.2.4 this与super
5.3 多态
5.4 Java的重载
5.5 构造函数的继承与重载
5.6 包
5.6.1 创建包
5.6.2 包的引用
5.7 接口
5.7.1 接口概述
5.7.2 声明接口
5.7.3 实现接口
5.8 小结
习题
第6章 工具类与算法
6.1 语言基础类库
6.1.1 Object类
6.1.2 数据类型类
6.1.3 Math类
6.1.4 System类
6.2 Applet类与Applet小程序
6.2.1 Applet的基本工作原理
6.2.2 Applet类
6.2.3 HTML文件参数传递
6.3 数组
6.4 向量
6.5 字符串
6.5.1 String类
6.5.2 StringBuffer类
6.5.3 Java Application命令行参数
6.6 递归
6.7 排序
6.7.1 冒泡排序
6.7.2 选择排序
6.7.3 插入排序
6.7.4 桶排序
6.8 查找
6.9 链表
6.9.1 链表的节点
6.9.2 创建链表
6.9.3 遍历链表
6.9.4 链表的插人操作
6.9.5 链表的删除操作
6.10 队列
6.11 堆栈
6.12 二叉树
6.13 小结
习题
第7章 图形用户界面的设计与实现
7.1 图形用户界面概述
7.2 用户自定义成分
7.2.1 绘制图形
7.2.2 显示文字
7.2.3 控制颜色
7.2.4 显示图像
7.2.5 实现动画效果
7.3 Java的事件处理
7.4 GUI标准组件概述
7.5 标签、按钮与动作事件
7.6 文本框、文本区域与文本事件
7.7 单、复选按钮，列表与选择事件
7.8 滚动条与调整事件
7.9 画布与鼠标、键盘事件
7.10 布局设计
7.10.1 FlowLayout
7.10.2 BorderLayout
7.10.3 CardLayout
7.10.4 GrldLayout
7.11 Panel与容器事件
7.12 Frame与窗口事件
7.13 菜单的定义与使用
7.14 对话框、组件事件与焦点事件
7.15 小结
习题
第8章 Java高级编程
8.1 异常处理
8.1.1 异常与异常类
8.1.2 抛出异常
8.1.3 异常的处理
8.2 Java多线程机制
8.2.1 Java中的线程
8.2.2 Java的线程类与Runnable接口
8.2.3 如何在程序中实现多线程
8.3 Swing GUI组件
8.3.1 JApplet
8.3.2 JButton
8.3.3 JSlider
8.3.4 JPasswordField
8.3.5 JTabbedPane
8.4 流式输入输出与文件处理
8.4.1 Java输入输出类库
8.4.2 文件的处理与随机访问
8.5 用Java实现底层网络通信
8.5.1 基于连接的流式套接字
8.5.2 无连接的数据报
8.6 Java程序对网上资源的访问
8.7 小结
习题
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言与面向对象程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>代码不朽：编写可维护软件的10大要则（Java版）
关于作者 ...................................................................................... xi
前言 ........................................................................................... xiii
第1 章 简介 .................................................................................1
1.1 什么是可维护性？ ..........................................................................................1
1.2 为什么可维护性很重要？ ...............................................................................2
1.3 本书的三个基本理论 ......................................................................................4
1.4 对可维护性的误解 ..........................................................................................5
1.5 评价可维护性 ..................................................................................................7
1.6 可维护性原则的概述 ......................................................................................8
第2 章 编写短小的代码单元 ........................................................11
2.1 动机 ...............................................................................................................13
2.2 如何使用本原则 ............................................................................................14
2.3 常见的反对意见 ............................................................................................21
2.4 参考 ...............................................................................................................24
第3 章 编写简单的代码单元 ........................................................27
3.1 动机 ...............................................................................................................32
3.2 如何使用本原则 ............................................................................................33
3.3 常见的反对意见 ............................................................................................37
3.4 参考 ...............................................................................................................38
第4 章 不写重复代码 ..................................................................41
4.1 动机 ...............................................................................................................45
4.2 如何使用本原则 ............................................................................................45
4.3 常见的反对意见 ............................................................................................50
4.4 参考 ...............................................................................................................52
第5 章 保持代码单元的接口简单 .................................................55
5.1 动机 ...............................................................................................................57
5.2 如何使用本原则 ............................................................................................58
5.3 常见的反对意见 ............................................................................................62
5.4 参考 ...............................................................................................................63
第6 章 分离模块之间的关注点 ....................................................65
6.1 动机 ...............................................................................................................68
6.2 如何使用本原则 ............................................................................................69
6.3 常见的反对意见 ............................................................................................72
第7 章 架构组件松耦合 ..............................................................75
7.1 动机 ...............................................................................................................76
7.2 如何使用本原则 ............................................................................................79
7.3 常见的反对意见 ............................................................................................81
7.4 参考 ...............................................................................................................82
第8 章 保持架构组件之间的平衡 .................................................85
8.1 动机 ...............................................................................................................86
8.2 如何使用本原则 ............................................................................................88
8.3 常见的反对意见 ............................................................................................89
8.4 参考 ...............................................................................................................89
第9 章 保持小规模代码库 ...........................................................93
9.1 动机 ...............................................................................................................93
9.2　如何使用本原则 ..........................................................................................96
9.3 常见的反对意见 ............................................................................................98
第10 章 自动化开发部署和测试 ................................................103
10.1 动机 ........................................................................................................... 104
10.2 如何使用本原则 ........................................................................................ 106
10.3 常见的反对意见 ........................................................................................ 114
10.4 参考 ........................................................................................................... 115
第11 章 编写简洁的代码 ...........................................................117
11.1 不留痕迹 ................................................................................................... 117
11.2 如何使用本原则 ........................................................................................ 117
11.3 常见的反对意见 ........................................................................................ 123
第12 章 后续事宜 .....................................................................125
12.1 将原则变成实践 ........................................................................................ 125
12.2 低层级（代码单元）原则要优先于高层级（组件）原则 ......................... 125
12.3 对每次提交负责 ........................................................................................ 126
12.4 下一本书会讨论开发流程的最佳实践 ...................................................... 126
附录A SIG 如何来评估可维护性 ...............................................127
索引 ..........................................................................................131
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>代码不朽：编写可维护软件的10大要则（Java版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java脚本编程
译者序
前言
致谢
第一部分
第1章 脚本简介  1
1.1 背景  1
1.2 脚本语言的定义  3
1.2.1 编译器与解释器  3
1.2.2 产品中的源代码  5
1.2.3 类型策略  6
1.2.4 数据结构  8
1.2.5 代码作为数据  9
1.2.6 小结  11
1.3 脚本语言和虚拟机  12
1.4 脚本和系统编程的对比  12
1.4.1 运行时性能  13
1.4.2 开发速度  13
1.4.3 健壮性  14
1.4.4 维护  16
1.4.5 极限编程  16
1.5 混合法  17
1.6 一个脚本案例  18
1.7 小结  18
第2章 适用脚本语言的应用程序  19
2.1 组装  19
2.1.1 UNIX Shell语言  20
2.1.2 Perl  20
2.1.3 Tcl  21
2.2 原型  21
2.3 定制  23
2.4 软件开发支持  24
2.4.1 项目构建  25
2.4.2 测试  26
2.5 运维与管理  27
2.6 用户界面编程  28
2.7 用例  29
2.7.1 Web应用程序  29
2.7.2 脚本和UNIX  33
2.7.3 游戏中的脚本  33
2.8 其他特征  34
2.8.1 可嵌入  34
2.8.2 可扩展  34
2.8.3 易于学习和使用  34
2.9 小结  35
第二部分
第3章 JVM内部的脚本语言  37
3.1 帽底乾坤  38
3.2 脚本语言概念  40
3.3 BeanShell  40
3.3.1 入门  40
3.3.2 基本语法  42
3.3.3 松类型的语法  42
3.3.4 语法风格  43
3.3.5 命令  45
3.3.6 方法  45
3.3.7 对象  46
3.3.8 实现接口  46
3.3.9 嵌入Java  47
3.4 Jython  50
3.4.1 入门  50
3.4.2 基本语法  52
3.4.3 使用Java  53
3.4.4 实现接口  54
3.4.5 异常处理  56
3.4.6 嵌入Java  56
3.4.7 小结  57
3.5 Rhino  58
3.5.1 入门  58
3.5.2 使用Java  59
3.5.3 实现接口  59
3.5.4 JavaAdapter  60
3.5.5 嵌入Java  60
3.5.6 Host Object  63
3.5.7 小结  65
3.6 Groovy  65
3.7 其他脚本语言  65
3.7.1 JRuby  65
3.7.2 Tcl/Java  66
3.7.3 JudoScript  66
3.7.4 ObjectScript  66
3.8 小结  66
第4章 Groovy  67
4.1 为什么需要Groovy  67
4.2 安装  67
4.3 运行Groovy脚本  68
4.3.1 用交互式的Shell  68
4.3.2 用交互式的控制台  69
4.3.3 执行脚本文件  69
4.4 编译Groovy脚本  70
4.4.1 依赖  70
4.4.2 Classpath  70
4.4.3 Ant Task  71
4.5 脚本结构  72
4.6 语言语法  74
4.6.1 Java兼容性  74
4.6.2 语句  74
4.6.3 松类型  75
4.6.4 类型技巧  76
4.6.5 String  78
4.6.6 GString  79
4.6.7 正则表达式  80
4.6.8 集合  81
4.6.9 逻辑分支  84
4.6.10 循环  86
4.6.11 类  88
4.6.12 操作符重载  90
4.6.13 GroovyBean  92
4.6.14 闭包  94
4.7 系统操作  101
4.7.1 文件  101
4.7.2 进程  104
4.8 嵌入Java  105
4.9 安全性  109
4.10 小结  112
第5章 高级的Groovy编程  113
5.1 GroovySQL  113
5.1.1 groovy.sql.Sql  115
5.1.2 groovy.sql.DataSet  122
5.2 Groovlet  124
5.3 Groovy模板  129
5.4 GroovyMarkup  131
5.4.1 groovy.xml.MarkupBuilder  132
5.4.2 groovy.util.NodeBuilder  134
5.4.3 groovy.xml.SaxBuilder  136
5.4.4 groovy.xml.DomBuilder  137
5.4.5 groovy.xml.Namespace  139
5.4.6 groovy.util.BuilderSupport  139
5.5 Groovy和Swing  141
5.5.1 TableLayout  142
5.5.2 TableModel  144
5.6 小结  145
第6章 Bean Scripting Framework  146
6.1 Bean Scripting Framework简介  146
6.2 入门  147
6.3 基本概念  147
6.3.1 架构  147
6.3.2 脚本语言的注册  148
6.3.3 管理器和引擎初始化  149
6.3.4 使用脚本  150
6.4 使用脚本文件  153
6.5 方法和函数  154
6.5.1 call()  154
6.5.2 apply()  156
6.6 数据绑定  158
6.6.1 注册Bean  158
6.6.2 声明Bean  160
6.7 编译  161
6.8 应用程序  165
6.8.1 JSP  166
6.8.2 Xalan-J（XSLT）  169
6.9 小结  174
第三部分
第7章 在Java实践脚本  175
7.1 单元测试  175
7.1.1 JUnit基础知识  176
7.1.2 GroovyTestCase类  178
7.1.3 断言方法  179
7.1.4 测试套件  181
7.1.5 用脚本作为单元测试案例  183
7.1.6 小结  183
7.2 交互式调试  183
7.3 构建工具  186
7.3.1 BSF支持  189
7.3.2 GroovyMarkup（AntBuilder）  191
7.3.3 小结  195
7.4 Shell Scripting  196
7.4.1 Classpath  196
7.4.2 实例  197
7.5 管控和管理  199
7.6 小结  204
第8章 脚本模式  205
8.1 脚本化组件模式  206
8.1.1 问题  206
8.1.2 解决方案  206
8.1.3 结果  207
8.1.4 范例代码  207
8.1.5 相关模式  208
8.2 中介者模式（胶合代码模式）  208
8.2.1 问题  208
8.2.2 解决方案  209
8.2.3 结果  210
8.2.4 范例代码  210
8.2.5 相关模式  217
8.3 脚本对象工厂模式  217
8.3.1 问题  217
8.3.2 解决方案  218
8.3.3 结果  218
8.3.4 范例代码  218
8.3.5 相关模式  220
8.4 观察者（广播）模式  220
8.4.1 问题  220
8.4.2 解决方案  221
8.4.3 结果  221
8.4.4 范例代码  222
8.4.5 相关模式  227
8.5 扩展点模式  227
8.5.1 问题  227
8.5.2 解决方案  227
8.5.3 结果  228
8.5.4 范例代码  228
8.5.5 相关模式  231
8.6 Active File模式  231
8.6.1 问题  231
8.6.2 解决方案  231
8.6.3 结果  231
8.6.4 范例代码  231
8.7 小结  235
第四部分
第9章 Scripting API   237
9.1 动机和历史  237
9.2 简介  238
9.3 入门  239
9.4 架构  239
9.5 发现机制  240
9.6 引擎元数据  241
9.7 创建和注册脚本引擎  242
9.7.1 创建方法  243
9.7.2 注册方法  245
9.8 执行求值  245
9.9 ScriptException  248
9.10 绑定  249
9.10.1 引擎范围  249
9.10.2 全局范围  253
9.10.3 脚本上下文  256
9.11 代码生成  265
9.11.1 输出语句  265
9.11.2 方法调用语法  266
9.11.3 程序  267
9.12 其他引擎接口  268
9.12.1 可调用  268
9.12.2 可编译  271
9.13 线程  273
9.14 动态绑定  274
9.15 小结  276
第10章 Web Scripting Framework  277
10.1 架构  277
10.1.1 上下文  277
10.1.2 Servlet  278
10.1.3 交互  279
10.2 入门  280
10.3 配置  282
10.3.1 取消脚本  282
10.3.2 脚本路径  283
10.3.3 脚本方法  283
10.3.4 语言许可  284
10.3.5 显示结果  284
10.4 绑定  286
10.4.1 应用程序  286
10.4.2 请求  287
10.4.3 响应  289
10.4.4 Servlet  290
10.5 include方法  290
10.6 forward方法  292
10.7 会话共享  293
10.8 语言标签  296
10.9 线程问题  298
10.10 架构挑战  298
10.10.1 Java与PHP应用程序的整合  299
10.10.2 PHP Web应用程序中的Java业务逻辑  299
10.10.3 Java Web应用程序中的PHP视图  301
10.11 小结  302
第五部分
附录A Groovy的安装  303
附录B Groovy的IDE支持   305
附录C 安装JSR 223   307
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java脚本编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云原生Java
目录
前言（James Watters）.......................................................xv
前言（Rod Johnson）........................................................ xvii
前言................................................................................ xix
第Ⅰ部分　基础知识
第1 章　云原生应用程序.......................................................... 3
亚马逊的故事 ........................................................................................................ 3
平台的承诺 ............................................................................................................ 5
模式 ........................................................................................................................ 7
可扩展性 ................................................................................................................. 7
可靠性 .................................................................................................................... 8
敏捷性 ..................................................................................................................... 8
Netflix 的故事 ......................................................................................................... 9
微服务 ................................................................................................................. 11
拆分单体系统 ...................................................................................................... 12
Netflix OSS ......................................................................................................... 13
云原生Java ......................................................................................................... 14
十二要素原则 ....................................................................................................... 14
代码库 ................................................................................................................. 15
依赖 ..................................................................................................................... 15
配置 ..................................................................................................................... 16
x ｜ 目录
后端服务 ............................................................................................................. 17
构建、发布、运行 .............................................................................................. 17
进程 ..................................................................................................................... 17
端口绑定 ............................................................................................................. 18
并发 ..................................................................................................................... 18
易处理 ................................................................................................................. 18
开发/ 生产环境一致 ........................................................................................... 19
日志 ..................................................................................................................... 19
管理进程 ............................................................................................................. 19
总结 ........................................................................................................................ 20
第2 章　训练营：Spring Boot 和Cloud Foundry......................21
什么是Spring Boot ................................................................................................ 21
Spring Initializr 入门 .............................................................................................. 21
Spring Tool Suite 入门 ............................................................................................ 30
安装Spring Tool Suite（STS）............................................................................. 30
使用Spring Initializr 创建一个新项目 ................................................................ 31
Spring 指南大全 ................................................................................................... 36
遵循STS 中的指南 ............................................................................................. 38
配置 ....................................................................................................................... 40
Cloud Foundry 平台 ............................................................................................... 52
总结 ....................................................................................................................... 66
第3 章　符合十二要素程序风格的配置....................................... 67
令人迷惑的“配置”合并 ........................................................................................... 67
Spring 框架对配置的支持 .................................................................................... 67
PropertyPlaceholderConfigurer ............................................................................ 68
Environment 接口和@Value 注解 ....................................................................... 69
Profile .................................................................................................................. 71
启动配置 ............................................................................................................. 73
使用Spring Cloud Config Server 进行中心化、日志型的配置................................... 76
Spring Cloud Config Server ................................................................................. 76
Spring Cloud Config 客户端 ................................................................................ 78
安全 ..................................................................................................................... 79
目录 ｜ xi
可刷新的配置 ....................................................................................................... 79
总结 ...................................................................................................................... 83
第４章　测试..................................................................... 85
测试的构成 ........................................................................................................... 86
在Spring Boot 中进行测试 ................................................................................... 86
集成测试 ............................................................................................................. 88
测试切片 ............................................................................................................. 89
测试中的Mock ................................................................................................... 89
使用@SpringBootTest 中的Servlet 容器 ............................................................ 93
测试分片 ............................................................................................................. 94
端到端测试 ......................................................................................................... 102
测试分布式系统 ................................................................................................ 102
消费者驱动的契约测试 ..................................................................................... 104
Spring Cloud Contract ....................................................................................... 105
总结 .................................................................................................................... 113
第5 章　迁移遗留的应用程序................................................. 115
契约 .................................................................................................................... 115
迁移应用程序环境 ................................................................................................ 116
开箱即用的构建包（Buildpacks） ..................................................................... 116
自定义的构建包 ................................................................................................ 117
容器化的应用程序 ............................................................................................ 118
将应用程序迁移到云上的微重构 ........................................................................ 119
连接后端服务 .................................................................................................... 120
用Spring 实现服务平等 .................................................................................... 121
总结 .................................................................................................................... 133
第Ⅱ部分　Web 服务
第6 章　REST API........................................................... 137
伦纳德· 理查森的成熟模型 .................................................................................. 137
使用Spring MVC 实现简单的REST API ................................................................. 139
内容协商 .............................................................................................................. 142
xii ｜ 目录
读写二进制数据 ................................................................................................ 142
Google Protocol Buffers .................................................................................... 145
错误处理 ............................................................................................................. 150
超媒体 ................................................................................................................. 152
媒体类型和模式 ................................................................................................ 158
API 版本 ............................................................................................................. 159
编写REST API 文档 ........................................................................................... 162
客户端 ................................................................................................................ 167
用于临时浏览和交互的REST 客户端 ............................................................... 167
RestTemplate ..................................................................................................... 171
总结 ................................................................................................................... 177
第7 章　路由.................................................................... 179
DiscoveryClient 接口 .......................................................................................... 180
Cloud Foundry Route 服务 .................................................................................. 190
总结 ...................................................................................................................... 195
第8 章　边缘服务............................................................... 197
Greetings 服务 ...................................................................................................... 198
一个简单的边缘服务 ........................................................................................... 200
Netflix Feign ........................................................................................................ 202
使用Netflix Zuul 进行过滤和代理 ........................................................................... 204
自定义Zuul 过滤器 ........................................................................................... 214
边缘服务的安全 .................................................................................................... 218
OAuth ................................................................................................................... 219
服务端应用程序 ................................................................................................ 220
HTML5 和JavaScript 单页面应用程序 ............................................................. 221
没有用户的应用 ................................................................................................ 221
受信任的客户端 ................................................................................................ 221
Spring Security .................................................................................................... 222
Spring Cloud Security ........................................................................................... 227
一个Spring Security OAuth 授权服务器 ........................................................... 227
保护Greetings 资源服务器的安全 .................................................................... 232
创建一个受OAuth 保护的单页面应用程序 ...................................................... 238
总结 ..................................................................................................................... 247
目录 ｜ xiii
第Ⅲ部分　数据整合
第9 章　数据管理............................................................... 251
数据建模 ............................................................................................................... 251
关系数据库管理系统（RDBMS） ...................................................................... 252
NoSQL............................................................................................................... 253
Spring Data ......................................................................................................... 253
Spring Data 应用程序的结构 ............................................................................. 254
域类 ................................................................................................................... 254
库 ...................................................................................................................... 254
为领域数据组织Java 包 .................................................................................... 255
使用JDBC 访问RDBMS 数据 ............................................................................... 258
Spring 的JDBC 支持 ........................................................................................... 259
Spring Data 示例 ................................................................................................. 261
Spring Data JPA.................................................................................................... 264
Account Service ................................................................................................. 264
集成测试 ........................................................................................................... 274
Spring Data MongoDB ......................................................................................... 275
Order Service ..................................................................................................... 275
集成测试 ........................................................................................................... 282
Spring Data Neo4j ............................................................................................... 284
Inventory Service ............................................................................................... 284
集成测试 ........................................................................................................... 294
Spring Data Redis ................................................................................................ 297
高速缓存 ........................................................................................................... 298
总结 .................................................................................................................... 302
第10 章　消息系统............................................................. 303
Spring Integration 的事件驱动架构 ..................................................................... 304
消息端点 ........................................................................................................... 305
使用简单的组件构建复杂的系统 ...................................................................... 306
消息代理、桥接、竞争消费者模式和事件溯源 ................................................... 314
发布—订阅目的地 ............................................................................................ 314
点对点目的地 .................................................................................................... 315
xiv ｜ 目录
Spring Cloud Stream .......................................................................................... 315
流生产者 ........................................................................................................... 316
流消费者 ........................................................................................................... 321
总结 .................................................................................................................... 323
第11 章　批处理和任务........................................................ 325
批处理工作 ........................................................................................................ 325
Spring Batch ....................................................................................................... 326
我们的第一个批处理作业 ................................................................................. 327
调度 .................................................................................................................... 336
通过消息传递远程分区Spring 批处理作业 ............................................................. 337
任务管理 ............................................................................................................. 346
通过Workflow 进行的以工作流为中心的整合 ........................................................ 348
使用消息传递的分布式......................................................................................... 362
总结 ..................................................................................................................... 362
第12 章　数据集成............................................................. 363
分布式事务 .......................................................................................................... 364
故障隔离和优雅的降级........................................................................................ 364
saga 模式 ............................................................................................................. 369
CQRS（命令查询责任分离） .............................................................................. 369
投诉API ............................................................................................................ 371
投诉统计API .................................................................................................... 383
Spring Cloud Data Flow ...................................................................................... 385
Stream ............................................................................................................... 387
任务 ................................................................................................................... 390
REST API .......................................................................................................... 391
实现Data Flow 客户端 ...................................................................................... 392
总结 .................................................................................................................... 407
第IV 部分　生产
第13 章　可观测的系统....................................................... 411
你构建，你运行 ................................................................................................. 412
目录 ｜ xv
谋杀神秘微服务 .................................................................................................. 413
十二要素运维 ..................................................................................................... 413
新方式 ................................................................................................................. 414
可观测性 ............................................................................................................ 416
推与拉的可观测性和解析率 ................................................................................ 416
使用Spring Boot Actuator 捕获应用程序的当前状态 .......................................... 417
度量 ...................................................................................................................... 418
通过/info 端点识别服务 ......................................................................................... 431
健康检查 ............................................................................................................. 432
审计事件 .............................................................................................................. 436
应用程序日志 ...................................................................................................... 439
指定日志输出 .................................................................................................... 440
指定日志级别 .................................................................................................... 441
分布式跟踪 ......................................................................................................... 445
用Spring Cloud Sleuth 寻找线索 ...................................................................... 446
多少数据是足够的 ............................................................................................ 447
OpenZipkin ：一张图片胜过千丝万缕 ............................................................... 448
跟踪其他平台和技术 ......................................................................................... 454
仪表板 ................................................................................................................ 455
使用Hystrix 仪表板监控下游服务 .................................................................... 455
Codecentric 的Spring Boot Admin .................................................................... 459
Ordina Microservices 仪表板 ............................................................................. 462
Pivotal Cloud Foundry 的AppsManager ............................................................ 463
修复 .................................................................................................................. 465
总结 ................................................................................................................... 467
第14 章　服务代理.............................................................................................469
创建后台服务 .................................................................................................. 470
平台视图 ............................................................................................................ 472
使用Spring Cloud Cloud Foundry Service Broker 实现服务代理 ........................ 473
简单的Amazon S3 服务代理 ............................................................................ 473
服务目录 ........................................................................................................... 474
管理服务实例 .................................................................................................... 476
服务绑定 ........................................................................................................... 482
保护服务代理 .................................................................................................... 486
xvi ｜ 目录
部署 ................................................................................................................... 487
使用BOSH 发布 ............................................................................................... 487
使用Cloud Foundry 发布 .................................................................................. 488
注册Amazon S3 Service Broker ....................................................................... 489
创建Amazon S3 服务实例 ................................................................................ 490
消费服务实例 .................................................................................................... 491
S3 客户端应用程序 ........................................................................................... 493
运行测试 ........................................................................................................... 496
总结 .................................................................................................................. 496
第15 章　持续交付.............................................................497
持续集成之外 .................................................................................................. 497
John Allspaw 在Flickr 以及后来的Etsy ........................................................... 498
Netflix 的Adrian Cockroft ................................................................................ 499
亚马逊的持续交付 ............................................................................................ 500
流水线 ................................................................................................................ 500
测试 .................................................................................................................... 501
持续交付微服务 ................................................................................................502
工具 .................................................................................................................. 503
Concourse ......................................................................................................... 503
容器 ................................................................................................................... 504
持续交付微服务 ................................................................................................. 504
安装Concourse ................................................................................................. 505
基本的管道设计 ................................................................................................ 506
持续集成 ........................................................................................................... 518
消费者驱动的协约测试......................................................................................  518
User 微服务流水线 ............................................................................................ 519
数据 ................................................................................................................... 522
生产 ................................................................................................................... 523
第V 部分　附录
附录A　在Java EE 中使用Spring Boot................................527
索引............................................................................... 552
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云原生Java
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>解密搜索引擎技术实战：Lucene &Java精华版(第2版)
Lucene开发实践	1
第1章 搜索引擎总体结构	2
1.1 为什么要做搜索引擎	2
1.1.1 比价搜索	3
1.2 搜索引擎基本模块	3
1.3 开发环境	4
1.4 搜索引擎工作原理	5
1.4.1 网络爬虫	6
1.4.2 全文索引	6
1.4.3 搜索用户界面	8
1.4.4 计算框架	9
1.4.5 文本挖掘	10
1.5 算法基础	11
1.5.1 折半查找	11
1.5.2 排序	11
1.6 软件工具	14
1.7 本章小结	14
1.8 术语表	14
第2章 自己动手写全文检索	18
2.1 构建索引	18
2.2 生成索引文件	19
2.3 读入索引文件	19
2.4 查询	19
2.4.1 按相关度排序	21
2.5 有限状态机	23
2.5.1 运算	23
2.5.2 编辑距离有限状态机	24
2.6 本章小结	25
第3章 Lucene原理与应用	26
3.1 Lucene快速入门	26
3.1.1 创建索引	26
3.1.2 查询索引库	27
3.1.3 创建文档索引	29
3.1.4 查询文档索引	29
3.2 创建和维护索引库	30
3.2.1 设计索引库结构	30
3.2.2 创建索引库	31
3.2.3 向索引库中添加索引文档	33
3.2.4 删除索引库中的索引文档	36
3.2.5 更新索引库中的索引文档	37
3.2.6 关闭索引库	38
3.2.7 索引的优化与合并	38
3.2.8 灵活索引	39
3.2.9 索引文件格式	40
3.2.10 定制索引存储结构	43
3.2.11 写索引集成到爬虫	48
3.2.12 多线程写索引	51
3.2.13 分发索引	54
3.2.14 修复索引	57
3.3 查找索引库	57
3.3.1 查询过程	57
3.3.2 常用查询	60
3.3.3 基本词查询	61
3.3.4 模糊匹配	62
3.3.5 布尔查询	63
3.3.6 短语查询	65
3.3.7 跨度查询	66
3.3.8 FieldScoreQuery	70
3.3.9 排序	74
3.3.10 使用Filter筛选搜索结果	79
3.3.11 使用Collector筛选搜索结果	80
3.3.12 遍历索引库	82
3.3.13 关键词高亮显示	86
3.3.14 列合并	88
3.3.15 关联内容(BlockJoinQuery)	90
3.3.16 查询大容量索引	95
3.4 读写并发	96
3.5 Lucene深入介绍	97
3.5.1 整体结构	97
3.5.2 索引原理	98
3.5.3 文档值	103
3.6 查询语法与解析	106
3.6.1 JavaCC	107
3.6.2 简单的查询解析器	119
3.6.3 灵活的查询解析器	120
3.7 查询原理	126
3.7.1 布尔匹配	126
3.7.2 相关性	127
3.8 分析文本	130
3.8.1 Analyzer	130
3.8.2 TokenStream	137
3.8.3 定制Tokenizer	139
3.8.4 重用Tokenizer	141
3.8.5 有限状态转换	141
3.8.6 索引数值列	142
3.8.7 检索结果排序	145
3.8.8 处理价格	146
3.9 Lucene中的压缩算法	146
3.9.1 变长压缩	147
3.9.2 PForDelta	149
3.9.3 VSEncoding	152
3.9.4 前缀压缩	153
3.9.5 差分编码	155
3.9.6 静态索引裁剪	157
3.10 搜索中文	157
3.10.1 Lucene切分原理	160
3.10.2 Lucene中的Analyzer	161
3.10.3 自己写Analyzer	164
3.10.4 Lietu中文分词	167
3.10.5 字词混合索引	167
3.11 索引数据库中的文本	172
3.12 优化使用Lucene	174
3.12.1 系统优化	174
3.12.2 查询优化	175
3.12.3 实现时间加权排序	178
3.12.4 词性标注	182
3.13 检索模型	185
3.13.1 向量空间模型	186
3.13.2 DFR	192
3.13.3 BM25概率模型	199
3.13.4 统计语言模型	205
3.13.5 隐含语义索引	206
3.13.6 学习评分	207
3.13.7 查询与相关度	208
3.13.8 提高相关度	208
3.13.9 使用Payload调整相关性	209
3.13.10 索引统计	214
3.14 实时搜索	216
3.15 概念搜索	218
3.15.1 发现同义词	219
3.15.2 垂直领域同义词	223
3.15.3 同义词扩展	224
3.16 本章小结	228
3.17 术语表	228
第4章 搜索引擎用户界面	230
4.1 实现Lucene搜索	230
4.1.1 测试搜索功能	230
4.1.2 加载索引	232
4.2 手机搜索界面	233
4.3 搜索页面设计	236
4.3.1 Struts2实现的搜索界面	236
4.3.2 实现翻页	239
4.4 实现搜索接口	241
4.4.1 编码识别	241
4.4.2 布尔搜索	245
4.4.3 指定范围搜索	245
4.4.4 搜索结果排序	247
4.4.5 索引缓存与更新	248
4.5 实现分类统计视图	255
4.5.1 单值列分类统计	262
4.6 实现相似文档搜索	263
4.7 实现AJAX搜索联想词	265
4.7.1 估计查询词的文档频率	265
4.7.2 搜索联想词总体结构	266
4.7.3 服务器端处理	267
4.7.4 浏览器端处理	272
4.7.5 拼音提示	274
4.7.6 部署总结	275
4.8 推荐搜索词	276
4.8.1 挖掘相关搜索词	276
4.8.2 使用多线程计算相关搜索词	278
4.9 拼音搜索	280
4.10 集成其他功能	280
4.10.1 拼写检查	280
4.10.2 分类统计	285
4.10.3 相关搜索	292
4.10.4 再次查找	295
4.10.5 搜索日志	295
4.11 查询分析	297
4.11.1 历史搜索词记录	297
4.11.2 日志信息过滤	298
4.11.3 信息统计	299
4.11.4 挖掘日志信息	301
4.11.5 查询词意图分析	302
4.12 部署网站	302
4.12.1 部署到Web服务器	302
4.12.2 防止攻击	305
4.13 本章小结	309
第5章 使用Solr实现企业搜索	311
5.1 Solr简介	312
5.1.1 使用Solr	312
5.2 Solr基本用法	313
5.2.1 Solr服务器端的配置与中文支持	313
5.2.2 数据类型	319
5.2.3 解析器	320
5.2.4 把数据放进Solr	320
5.2.5 删除数据	325
5.2.6 查询语法	326
5.3 使用SolrJ	327
5.3.1 Solr客户端与搜索界面	327
5.3.2 Solr索引库的查找	329
5.3.3 分类统计	333
5.3.4 高亮	335
5.3.5 同义词	337
5.3.6 嵌入式Solr	337
5.3.7 索引分发	338
5.3.8 Solr搜索优化	341
5.4 Solritas	344
5.5 从FAST Search移植到Solr	344
5.6 简单应用	346
5.7 Solr扩展与定制	346
5.7.1 插件	346
5.7.2 Solr中字词混合索引	346
5.7.3 相关检索	348
5.7.4 搜索结果去重	350
5.7.5 定制输入输出	354
5.7.6 聚类	359
5.7.7 分布式搜索	360
5.7.8 分布式索引	364
5.7.9 SolrJ查询分析器	366
5.7.10 扩展SolrJ	375
5.7.11 扩展Solr	376
5.7.12 日文搜索	379
5.7.13 查询Web图	380
5.8 SolrNet	383
5.8.1 使用SolrNet实现全文搜索	383
5.8.2 实现原理	387
5.8.3 扩展SolrNet	388
5.9 Solr的其它客户端	393
5.9.1 Solr的PHP客户端	394
5.10 为网站增加搜索功能	397
5.11 手机客户端	397
5.12 Solr原理	398
5.12.1 支持Solr的中文分词	398
5.12.2 缓存技术	399
5.13 本章小结	399
第6章 地图搜索	401
6.1 Solr	401
第7章 视频搜索	402
第8章 垂直搜索	403
8.1 自动化网站	403
8.2 招聘行业网站	403
8.2.1 网络爬虫	403
8.2.2 全文中文引擎	403
8.2.3 Email地址人工添加简易工具	404
8.2.4 职位推荐	404
8.2.5 用户权限	404
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>解密搜索引擎技术实战：Lucene &Java精华版(第2版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 实时编程
译者序前言致谢作者简介第一部分  实时计算概念  第1章  实时系统概述    1.1 实时系统质量    1.2 可预见性和确定性      1.2.1 确定延迟      1.2.2 确定抖动      1.2.3 硬实时与软实时      1.2.4 等时实时      1.2.5 实时与实快      1.2.6 实时与吞吐量      1.2.7 任务完成价值    1.3 实时计算      1.3.1 高速公路类比      1.3.2 高速公路类比——添加优先车道    1.4 实时调度      1.4.1 调度约束      1.4.2 调度算法      1.4.3 实时操作系统      1.4.4 RT-POSIX操作系统扩展    1.5 参考资料  第2章  实时与Java SE    2.1 Java是实时语言吗      2.1.1 无界定延迟和抖动的来源      2.1.2 缺乏严格的线程优先级    2.2 垃圾回收      2.2.1 究竟什么是垃圾回收      2.2.2 常见的垃圾回收算法    2.3 Sun Java SE 6 HotSpot中的垃圾回收      2.3.1 Java对象世代      2.3.2 回收器      2.3.3 内存分配      2.3.4 安全点      2.3.5 未来：垃圾优先( G1)    2.4 实时垃圾回收算法      2.4.1 基于工作的垃圾回收      2.4.2 基于时间的垃圾回收      2.4.3 汉瑞克森的垃圾回收      2.4.4 Sun公司的Java实时系统中的RTGC    2.5 Java的困境  第3章  Java实时规范    3.1 实时 Java 基础    3.2 RTSJ内部机制      3.2.1 调度      3.2.2 内存管理      3.2.3 资源共享      3.2.4 异步事件处理(AEH)      3.2.5 控制的异步转移      3.2.6 物理内存访问    3.3 可选的RTSJ工具    3.4 实时Java 的未来  第4章  Sun Java实时系统    4.1 Java RTS程序设计的前奏      4.1.1 操作系统支持      4.1.2 Solaris与实时      4.1.3 Linux与实时    4.2 安装Java RTS      4.2.1 Solaris 上的安装      4.2.2 Linux上的安装    4.3 确定性指南      4.3.1 使用实时线程      4.3.2 调整实时垃圾回收器      4.3.3 关键预留内存      4.3.4 处理器绑定      4.3.5 编译Java RTS代码      4.3.6 解释RTGC统计      4.3.7 使用RTSJ的时钟 API    4.4 命令行选项      4.4.1 RTGC相关选项      4.4.2 与内存相关的选项      4.4.3 线程相关的选项      4.4.4 异步相关选项      4.4.5 编译器和解释器选项      4.4.6 Java RTS优化选项第二部分  高级Java RTS  第5章  线程、调度与新内存模型    5.1 可调度对象      5.1.1 实时调度器      5.1.2 SchedulingParameters      5.1.3 发布参数    5.2 实时线程      5.2.1 使用RealtimeThread      5.2.2 使用NoHeapRealtimeThread      5.2.3 实现周期线程      5.2.4 错过最后期限处理程序      5.2.5 实现非周期性线程    5.3 内存模型      5.3.1 内存访问规则      5.3.2 作用域内存      5.3.3 物理内存  第6章  同步    6.1 资源共享      6.1.1 优先级倒置控制      6.1.2 行动中的优先级继承    6.2 非等待线程通信      6.2.1 使用WaitFreeWriteQueue      6.2.2 使用WaitFreeReadQueue  第7章  实时时钟API    7.1 Clock API    7.2 Java RTS高精度时间操作    7.3 叠加的股票数据提供的例子  第8章  异步事件    8.1 异步事件处理    8.2 创建一个异步事件处理程序      8.2.1 内部应用程序事件      8.2.2 约束异步事件处理程序      8.2.3 与事件触发计数一起工作      8.2.4 处理POSIX事件      8.2.5 指定内存区域    8.3 基于时间的事件      8.3.1 一次性定时器      8.3.2 周期定时器  第9章  异步控制转移和线程终止    9.1 异步控制转移      9.1.1 实现可中断代码      9.1.2 实现Timed操作    9.2 异步线程终止  第10章  实时垃圾回收器内部机制    10.1 RTGC操作理论      10.1.1 并发标记      10.1.2 并发清扫      10.1.3 并发清零    10.2 RTGC内存分配      10.2.1 堆布局      10.2.2 线程局部分配缓冲器      10.2.3 对象分裂      10.2.4 数组分裂和缓存    10.3 RTGC策略      10.3.1 全时RTGC策略      10.3.2 隔离的RTGC策略      10.3.3 基于时间的RTGC策略      10.3.4 孤立的RTGC策略第三部分  使用Java RTS  第11章  证券交易系统    11.1 股票市场      11.1.1 限价订单      11.1.2 止损订单    11.2 交易系统实现      11.2.1 系统架构      11.2.2 交易引擎    11.3 Java SE版本      11.3.1 MarketManager类      11.3.2 OrderManager类    11.4 Java RTS 版本    11.5 Java RTS 没有堆的版本      11.5.1 OrderManager类      11.5.2 MarketManager类    11.6 应用程序配置  第12章  Java RTS工具    12.1 Java RTS开发      12.1.1 使用NetBeans插件进行远程调试      12.1.2 替代的开发环境    12.2 线程调度展示台(TSV)      12.2.1 TSV日志文件格式      12.2.2 使用TSV日志文件      12.2.3 记录应用程序的事件      12.2.4 用TSV查看器工作    12.3 Java RTS DTrace探针      12.3.1 用于Schedulable的DTrace探针      12.3.2 用于内存的DTrace探针      12.3.3 用于线程的DTrace探针      12.3.4 用于AsyncEventHandlers的DTrace探针      12.3.5 用于编译的DTrace探针      12.3.6 用于RTGC的DTrace探针      12.3.7 用于类加载的DTrace探针      12.3.8 用于VM活动的DTrace探针      12.3.9 特定应用程序的DTrace探针参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 实时编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Boot实战
第1章　入门　　1
1.1　Spring风云再起　　1
1.1.1　重新认识Spring　　2
1.1.2　Spring Boot精要　　3
1.1.3　Spring Boot不是什么　　6
1.2　Spring Boot入门　　6
1.2.1　安装Spring Boot CLI　　7
1.2.2　使用Spring Initializr初始化Spring Boot项目　　10
1.3　小结　　18
第2章　开发第一个应用程序　　19
2.1　运用Spring Boot　　19
2.1.1　查看初始化的Spring Boot新项目　　21
2.1.2　Spring Boot项目构建过程解析　　24
2.2　使用起步依赖　　27
2.2.1　指定基于功能的依赖　　28
2.2.2　覆盖起步依赖引入的传递依赖　　29
2.3　使用自动配置　　30
2.3.1　专注于应用程序功能　　31
2.3.2　运行应用程序　　36
2.3.3　刚刚发生了什么　　38
2.4　小结　　41
第3章　自定义配置　　42
3.1　覆盖Spring Boot自动配置　　42
3.1.1　保护应用程序　　43
3.1.2　创建自定义的安全配置　　44
3.1.3　掀开自动配置的神秘面纱　　48
3.2　通过属性文件外置配置　　49
3.2.1　自动配置微调　　50
3.2.2　应用程序Bean的配置外置　　55
3.2.3　使用Profile进行配置　　59
3.3　定制应用程序错误页面　　62
3.4　小结　　64
第4章　测试　　66
4.1　集成测试自动配置　　66
4.2　测试Web应用程序　　68
4.2.1　模拟Spring MVC　　69
4.2.2　测试Web安全　　72
4.3　测试运行中的应用程序　　74
4.3.1　用随机端口启动服务器　　75
4.3.2　使用Selenium测试HTML页面　　76
4.4　小结　　78
第5章　Groovy与Spring Boot CLI　　80
5.1　开发Spring Boot CLI应用程序　　80
5.1.1　设置CLI项目　　81
5.1.2　通过Groovy消除代码噪声　　81
5.1.3　发生了什么　　85
5.2　获取依赖　　86
5.2.1　覆盖默认依赖版本　　87
5.2.2　添加依赖仓库　　88
5.3　用CLI运行测试　　89
5.4　创建可部署的产物　　91
5.5　小结　　91
第6章　在Spring Boot中使用Grails　　93
6.1　使用GORM进行数据持久化　　93
6.2　使用Groovy Server Pages定义视图　　98
6.3　结合Spring Boot与Grails 3　　100
6.3.1　创建新的Grails项目　　100
6.3.2　定义领域模型　　103
6.3.3　开发Grails控制器　　104
6.3.4　创建视图　　105
6.4　小结　　107
第7章　深入Actuator　　108
7.1　揭秘Actuator的端点　　108
7.1.1　查看配置明细　　109
7.1.2　运行时度量　　115
7.1.3　关闭应用程序　　121
7.1.4　获取应用信息　　121
7.2　连接Actuator的远程shell　　122
7.2.1　查看autoconfig报告　　123
7.2.2　列出应用程序的Bean　　124
7.2.3　查看应用程序的度量信息　　124
7.2.4　调用Actuator端点　　125
7.3　通过JMX监控应用程序　　126
7.4　定制Actuator　　128
7.4.1　修改端点ID　　128
7.4.2　启用和禁用端点　　129
7.4.3　添加自定义度量信息　　129
7.4.4　创建自定义跟踪仓库　　132
7.4.5　插入自定义健康指示器　　134
7.5　保护Actuator端点　　136
7.6　小结　　138
第8章　部署Spring Boot应用程序　　139
8.1　衡量多种部署方式　　139
8.2　部署到应用服务器　　140
8.2.1　构建WAR文件　　141
8.2.2　创建生产Profile　　142
8.2.3　开启数据库迁移　　145
8.3　推上云端　　150
8.3.1　部署到Cloud Foundry　　150
8.3.2　部署到Heroku　　153
8.4　小结　　155
附录A　Spring Boot开发者工具　　157
附录B　Spring Boot起步依赖　　163
附录C　配置属性　　169
附录D　Spring Boot依赖　　202
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Boot实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JAVA与XML
第1章 XML简介 1.1 XM

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JAVA与XML
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>21天学通Java
第一篇  基础篇第1章  Java简介(精彩视频：33分钟)  1.1  Java的平台简介  1.2  安装工具包    1.2.1  下载JDK    1.2.2  安装JDK    1.2.3  查看与设置环境变量    1.2.4  JDK常用命令    1.2.5  Java各个目录含义    1.2.6  要善于使用JDK的帮助文件  1.3  程序开发过程  1.4  编码规范  1.5  HelloWorld：第一个Java程序    1.5.1  编写程序代码    1.5.2  编译程序代码并运行    1.5.3  注意事项  1.6  使用Eclipse集成开发工具开发  1.7  综合练习  1.8  小结  1.9  习题第2章  Java的基本数据类型(精彩视频：38分钟)  2.1  数据类型    2.1.1  整型    2.1.2  浮点型    2.1.3  字符型(char)    2.1.4  布尔型(boolean)  2.2  数据类型间的转换    2.2.1  自动转换    2.2.2  强制转换    2.2.3  隐含转换  2.3  标识符的命名    2.3.1  标识符的命名规则    2.3.2  代码演示如何定义标识符    2.3.3  不好的标识符命名    2.3.4  良好的标识符命名  2.4  关键字  2.5  代码注释    2.5.1  行注释    2.5.2  块注释    2.5.3  文档注释用户自定义类型  2.6  综合练习  2.7  小结  2.8  习题第3章  运算符(精彩视频：43分钟)  3.1  算术运算符    3.1.1 “+”：加法运算符    3.1.2 “-”：减法运算符    3.1.3 “*”：乘法运算符    3.1.4 “/”：除法运算符    3.1.5 “%”：求余运算符  3.2  自增自减运算符  3.3  关系运算符    3.3.1 “==”、“！=”    3.3.2 “>”、“<”、“>=”、“<=”  3.4  逻辑运算符    3.4.1 “&&”：与运算符    3.4.2 “||”：或运算符    3.4.3 “!”：非运算符    3.4.4  逻辑运算符总结  3.5  三元运算符  3.6  位运算符    3.6.1 “&”：按位与运算符    3.6.2 “|”：按位或运算符    3.6.3 “^”：按位异或运算符  3.7  位移运算符    3.7.1 “>>”：带符号右移运算符    3.7.2 “<<”：带符号左移运算符    3.7.3 “>>>”：无符号右移运算符  3.8  赋值运算符    3.8.1  一般赋值运算符    3.8.2  运算赋值运算符  3.9  运算符之间的优先级  ……第4章  流程控制(精彩视频：58分钟)第5章  数组(精彩视频：52分钟)第二篇  面向对象篇第6章  类与对象(精彩视频：48分钟)第7章  控制逻辑(精彩视频：50分钟)第8章  继承(精彩视频：72分钟)第9章  接口(精彩视频：47分钟)第10章  构造器(精彩视频：46分钟)第11章  异常处理(精彩视频：60分钟)第12章  内部类(精彩视频：71分钟)第13章  多线程(精彩视频：55分钟)第三篇  应用篇第14章  Swing桌面程序开发(精彩视频：70分钟)第15章  布局管理器(精彩视频：62分钟)第16章  Swing常用控件(精彩视频：90分钟)第17章  JDBC数据库编程(精彩视频：63分钟)第18章  Java中输入/输出流(精彩视频：55分钟)第19章  集合框架(精彩视频：65分钟)第20章  网络编程(精彩视频：58分钟)第四篇  综合案例篇第21章  学生管理系统(精彩视频：54分钟)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>21天学通Java
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java P2P技术内幕
第一部分  P2P简介
第1章  P2P的基本概念　3
1.1  P2P发展简史　3
1.2  P2P应用程序的用武之地　5
1.3  采用P2P的目的　5
1.3.1  分散化　6
1.3.2  费用和有效的资源分配　7
1.3.3  普及应用的计算和边缘服务　7
1.4  商业和实现方面的考虑　7
1.5  P2P体系结构　8
1.5

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java P2P技术内幕
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java SOA Cookbook中文版
第1部分  SOA基础第1章  SOA入门  1.1  概述  1.2  定义服务  1.3  定义SOA  1.4  识别服务候选对象  1.5  识别不同种类的服务  1.6  为服务建模  1.7  使服务可组合  1.8  支持SOA工作  1.9  选择试验项目  1.10  建立治理机制  本章小结第2章  XML Schema和SOA数据模型  2.1  概述  2.2  为SOA设计Schema  2.3  创建规范的数据模型  2.4  使用Chameleon命名空间设计  2.5  对Schema进行版本控制  2.6  参考Schema  2.7  常见Schema类型  2.8  根据单个Schema验证XML文档  2.9  根据多个Schema验证XML文档  2.10  使用正则表达式限制Schema类型  2.11  使用Schema枚举  2.12  从Schema生成Java类  2.13  从Java生成Schema  2.14  在ant中从XML Schema生成Java源文件  2.15  从Schema生成XML文档实例  2.16  定制从Schema生成Java类的方式  2.17  在编组和解组过程中根据Schema进行验证  2.18  在编组和解组过程中收集Schema验证事件  本章小结第3章  使用XML和Java  3.1  概述  3.2  读取XML数据流  3.3  编写XML数据流  3.4  过滤XML流中的数据  3.5  从XML文档选择值  3.6  更新XML文档中的值  3.7  将Java对象转换成XML文档实例  3.8  将XML文档实例转换成Java对象  3.9  从XML文档生成Schema  3.10  不使用Jaxb将XML转换成Java  3.11  在Jaxb中自定义代码生成  3.12  在Linux上查找包含给定类的Jar  3.13  透明替换XML文件  ……第二部分  Web服务第4章  准备工作第5章  基于SAAJ的Web服务第6章  用JAX-WS创建Web服务应用程序第7章  提供基于SOAP的Web服务第8章  REST式Web服务第三部分  业务流程第9章  使用BPEL编排服务第10章  高级BPEL编排第11章  SOA管理第四部  分互操作性和服务质量第12章  Web服务的互操作性第13章  服务质量第14章  企业服务总线
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java SOA Cookbook中文版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java虚拟机规范
目录
前言
1 Introduction
1.1 A Bit of History
1.2 The Java Virtual Machine
1.3 Organization of the Specification
1.4 Notation
1.5 Feedback
2 The Structure of the Java Virtual Machine
2.1 The  class File Format
2.2 Data Types
2.3 Primitive Types and Values
2.3.1 Integral Types and Values
2.3.2 Floating-Point Types, Value Sets, and Values
2.3.3 The  returnAddress Type and Values
2.3.4 The  boolean Type
2.4 Reference Types and Values
2.5 Run-Time Data Areas
2.5.1 The  pc Register
2.5.2 Java Virtual Machine Stacks
2.5.3 Heap
2.5.4 Method Area
2.5.5 Run-Time Constant Pool
2.5.6 Native Method Stacks
2.6 Frames
2.6.1 Local Variables
2.6.2 Operand Stacks
2.6.3 Dynamic Linking
2.6.4 Normal Method Invocation Completion
2.6.5 Abrupt Method Invocation Completion
2.7 Representation of Objects
2.8 Floating-Point Arithmetic
2.8.1 Java Virtual Machine Floating-Point Arithmetic and IEEE 754
2.8.2 Floating-Point Modes
2.8.3 Value Set Conversion
2.9 Special Methods
2.10 Exceptions
2.11 Instruction Set Summary
2.11.1 Types and the Java Virtual Machine
2.11.2 Load and Store Instructions
2.11.3 Arithmetic Instructions
2.11.4 Type Conversion Instructions
2.11.5 Object Creation and Manipulation
2.11.6 Operand Stack Management Instructions
2.11.7 Control Transfer Instructions
2.11.8 Method Invocation and Return Instructions
2.11.9 Throwing Exceptions
2.11.10 Synchronization
2.12 Class Libraries
2.13 Public Design, Private Implementation
3 Compiling for the Java Virtual Machine
3.1 Format of Examples
3.2 Use of Constants, Local Variables, and Control Constructs
3.3 Arithmetic
3.4 Accessing the Run-Time Constant Pool
3.5 More Control Examples
3.6 Receiving Arguments
3.7 Invoking Methods
3.8 Working with Class Instances
3.9 Arrays
3.10 Compiling Switches
3.11 Operations on the Operand Stack
3.12 Throwing and Handling Exceptions
3.13 Compiling finally
3.14 Synchronization
3.15 Annotations
4 The class File Format
4.1 The ClassFile Structure
4.2 The Internal Form of Names
4.2.1 Binary Class and Interface Names
4.2.2 Unqualified Names
4.3 Descriptors
4.3.1 Grammar Notation
4.3.2 Field Descriptors
4.3.3 Method Descriptors
4.4 The Constant Pool
4.4.1 The CONSTANT_Class_info Structure
4.4.2 The CONSTANT_Fieldref_info, CONSTANT_Methodref_info, and CONSTANT_InterfaceMethodref_info Structures
4.4.3 The CONSTANT_String_info Structure
4.4.4 The CONSTANT_Integer_info and CONSTANT_Float_info Structures
4.4.5 The CONSTANT_Long_info and CONSTANT_Double_info Structures
4.4.6 The CONSTANT_NameAndType_info Structure
4.4.7 The CONSTANT_Utf8_info Structure
4.4.8 The CONSTANT_MethodHandle_info Structure
4.4.9 The CONSTANT_MethodType_info Structure
4.4.10 The CONSTANT_InvokeDynamic_info Structure
4.5 Fields
4.6 Methods
4.7 Attributes
4.7.1 Defining and Naming New Attributes
4.7.2 The ConstantValue Attribute
4.7.3 The Code Attribute
4.7.4 The StackMapTable Attribute
4.7.5 The Exceptions Attribute
4.7.6 The InnerClasses Attribute
4.7.7 The EnclosingMethod Attribute
4.7.8 The Synthetic Attribute
4.7.9 The Signature Attribute
4.7.9.1 Signatures
4.7.10 The SourceFile Attribute
4.7.11 The SourceDebugExtension Attribute
4.7.12 The LineNumberTable Attribute
4.7.13 The LocalVariableTable Attribute
4.7.14 The LocalVariableTypeTable Attribute
4.7.15 The Deprecated Attribute
4.7.16 The RuntimeVisibleAnnotations Attribute
4.7.16.1 The element_value structure
4.7.17 The RuntimeInvisibleAnnotations Attribute
4.7.18 The RuntimeVisibleParameterAnnotations Attribute
4.7.19 The RuntimeInvisibleParameterAnnotations Attribute
4.7.20 The RuntimeVisibleTypeAnnotations Attribute
4.7.20.1 The target_info union
4.7.20.2 The type_path structure
4.7.21 The RuntimeInvisibleTypeAnnotations Attribute
4.7.22 The AnnotationDefault Attribute
4.7.23 The BootstrapMethods Attribute
4.7.24 The MethodParameters Attribute
4.8 Format Checking
4.9 Constraints on Java Virtual Machine Code
4.9.1 Static Constraints
4.9.2 Structural Constraints
4.10 Verification of class Files
4.10.1 Verification by Type Checking
4.10.1.1 Accessors for Java Virtual Machine Artifacts
4.10.1.2 Verification Type System
4.10.1.3 Instruction Representation
4.10.1.4 Stack Map Frame Representation
4.10.1.5 Type Checking Abstract and Native Methods
4.10.1.6 Type Checking Methods with Code
4.10.1.7 Type Checking Load and Store Instructions
4.10.1.8 Type Checking for protected Members
4.10.1.9 Type Checking Instructions
4.10.2 Verification by Type Inference
4.10.2.1 The Process of Verification by Type Inference
4.10.2.2 The Bytecode Verifier
4.10.2.3 Values of Types long and double
4.10.2.4 Instance Initialization Methods and Newly Created Objects
4.10.2.5 Exceptions and finally
4.11 Limitations of the Java Virtual Machine
5 Loading, Linking, and Initializing
5.1 The Run-Time Constant Pool
5.2 Java Virtual Machine Startup
5.3 Creation and Loading
5.3.1 Loading Using the Bootstrap Class Loader
5.3.2 Loading Using a User-defined Class Loader
5.3.3 Creating Array Classes
5.3.4 Loading Constraints
5.3.5 Deriving a Class from a class File Representation
5.4 Linking
5.4.1 Verification
5.4.2 Preparation
5.4.3 Resolution
5.4.3.1 Class and Interface Resolution
5.4.3.2 Field Resolution
5.4.3.3 Method Resolution
5.4.3.4 Interface Method Resolution
5.4.3.5 Method Type and Method Handle Resolution
5.4.3.6 Call Site Specifier Resolution
5.4.4 Access Control
5.4.5 Overriding
5.5 Initialization
5.6 Binding Native Method Implementations
5.7 Java Virtual Machine Exit
6 The Java Virtual Machine Instruction Set
6.1 Assumptions: The Meaning of "Must"
6.2 Reserved Opcodes
6.3 Virtual Machine Errors
6.4 Format of Instruction Descriptions
mnemonic
6.5 Instructions
aaload
aastore
aconst_null
aload
aload_<n>
anewarray
areturn
arraylength
astore
astore_<n>
athrow
baload
bastore
bipush
caload
castore
checkcast
d2f
d2i
d2l
dadd
daload
dastore
dcmp<op>
dconst_<d>
ddiv
dload
dload_<n>
dmul
dneg
drem
dreturn
dstore
dstore_<n>
dsub
dup
dup_x1
dup_x2
dup2
dup2_x1
dup2_x2
f2d
f2i
f2l
fadd
faload
fastore
fcmp<op>
fconst_<f>
fdiv
fload
fload_<n>
fmul
fneg
frem
freturn
fstore
fstore_<n>
fsub
getfield
getstatic
goto
goto_w
i2b
i2c
i2d
i2f
i2l
i2s
iadd
iaload
iand
iastore
iconst_<i>
idiv
if_acmp<cond>
if_icmp<cond>
if<cond>
ifnonnull
ifnull
iinc
iload
iload_<n>
imul
ineg
instanceof
invokedynamic
invokeinterface
invokespecial
invokestatic
invokevirtual
ior
irem
ireturn
ishl
ishr
istore
istore_<n>
isub
iushr
ixor
jsr
jsr_w
l2d
l2f
l2i
ladd
laload
land
lastore
lcmp
lconst_<l>
ldc
ldc_w
ldc2_w
ldiv
lload
lload_<n>
lmul
lneg
lookupswitch
lor
lrem
lreturn
lshl
lshr
lstore
lstore_<n>
lsub
lushr
lxor
monitorenter
monitorexit
multianewarray
new
newarray
nop
pop
pop2
putfield
putstatic
ret
return
saload
sastore
sipush
swap
tableswitch
wide
7 Opcode Mnemonics by Opcode
Index
A Limited License Grant
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java虚拟机规范
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java线程编程
第一部分  线
程
第1章  线程简介　3
1.1  什么是线程　4
1.2  为什么使用多线程　4
1.2.1  与用户的更佳交互　4
1.2.2  同步动作的模拟　5

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java线程编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>解密搜索引擎技术实战
第1章 搜索引擎总体结构	1
1.1 搜索引擎基本模块	2
1.2 开发环境	3
1.3 搜索引擎工作原理	4
1.3.1 网络爬虫	5
1.3.2 全文索引结构与Lucene实现	5
1.3.3 搜索用户界面	10
1.3.4 计算框架	10
1.3.5 文本挖掘	11
1.4 本章小结	12
第2章 网络爬虫的原理与应用	13
2.1 爬虫的基本原理	13
2.2 爬虫架构	16
2.2.1 基本架构	16
2.2.2 分布式爬虫架构	19
2.2.3 垂直爬虫架构	20
2.3 抓取网页	20
2.3.1 下载网页的基本方法	21
2.3.2 网页更新	25
2.3.3 抓取限制应对方法	27
2.3.4 URL地址提取	29
2.3.5 抓取JavaScript动态页面	29
2.3.6 抓取即时信息	32
2.3.7 抓取暗网	33
2.3.8 信息过滤	34
2.3.9 最好优先遍历	41
2.4 存储URL地址	42
2.4.1 BerkeleyDB	43
2.4.2 布隆过滤器	45
2.5 并行抓取	47
2.5.1 多线程爬虫	48
2.5.2 垂直搜索的多线程爬虫	50
2.5.3 异步IO	52
2.6 RSS抓取	56
2.7 抓取FTP	58
2.8 下载图片	59
2.9 图像的OCR识别	59
2.9.1 图像二值化	60
2.9.2 切分图像	63
2.9.3 SVM分类	67
2.10 Web结构挖掘	71
2.10.1 存储Web图	72
2.10.2 PageRank算法	76
2.10.3 HITs算法	84
2.10.4 主题相关的PageRank	88
2.11 部署爬虫	90
2.12 本章小结	90
第3章 索引内容提取	93
3.1 从HTML文件中提取文本	93
3.1.1 字符集编码	93
3.1.2 识别网页的编码	96
3.1.3 网页编码转换为字符串编码	98
3.1.4 使用HTMLParser实现定向抓取	99
3.1.5 使用正则表达式提取数据	104
3.1.6 结构化信息提取	106
3.1.7 网页的DOM结构	109
3.1.8 使用NekoHTML提取信息	111
3.1.9 网页去噪	117
3.1.10 网页结构相似度计算	122
3.1.11 提取标题	124
3.1.12 提取日期	126
3.2 从非HTML文件中提取文本	126
3.2.1 提取标题的一般方法	127
3.2.2 PDF文件	132
3.2.3 Word文件	135
3.2.4 Rtf文件	137
3.2.5 Excel文件	149
3.2.6 PowerPoint文件	152
3.3 提取垂直行业信息	153
3.3.1 医疗行业	153
3.3.2 旅游行业	153
3.4 流媒体内容提取	154
3.4.1 音频流内容提取	154
3.4.2 视频流内容提取	158
3.5 存储提取内容	159
3.6 本章小结	160
第4章 中文分词原理与实现	162
4.1 Lucene中的中文分词	162
4.1.1 Lucene切分原理	162
4.1.2 Lucene中的Analyzer	164
4.1.3 自己写Analyzer	167
4.1.4 Lietu中文分词	170
4.2 查找词典算法	170
4.2.1 标准Trie树	171
4.2.2 三叉Trie树	174
4.3 中文分词的原理	179
4.4 中文分词流程与结构	183
4.5 形成切分词图	184
4.6 概率语言模型的分词方法	191
4.7 N元分词方法	195
4.8 新词发现	198
4.9 未登录词识别	199
4.10 词性标注	200
4.10.1 隐马尔可夫模型	204
4.10.2 基于转换的错误学习方法	214
4.11 平滑算法	216
4.12 机器学习的方法	220
4.12.1 最大熵	221
4.12.2 条件随机场	224
4.13 有限状态机	224
4.14 本章小结	232
第5章 让搜索引擎理解自然语言	233
5.1 停用词表	233
5.2 句法分析树	235
5.3 相似度计算	240
5.4 文档排重	244
5.4.1 语义指纹	245
5.4.2 SimHash	248
5.4.3 分布式文档排重	259
5.5 中文关键词提取	260
5.5.1 关键词提取的基本方法	260
5.5.2 HITS算法应用于关键词提取	262
5.5.3 从网页中提取关键词	265
5.6 相关搜索词	265
5.6.1 挖掘相关搜索词	265
5.6.2 使用多线程计算相关搜索词	268
5.7 信息提取	269
5.8 拼写检查与建议	274
5.8.1 模糊匹配问题	276
5.8.2 英文拼写检查	279
5.8.3 中文拼写检查	281
5.9 自动摘要	284
5.9.1 自动摘要技术	284
5.9.2 自动摘要的设计	285
5.9.3 基于篇章结构的自动摘要	291
5.9.4 Lucene中的动态摘要	291
5.10 文本分类	295
5.10.1 特征提取	297
5.10.2 中心向量法	300
5.10.3 朴素贝叶斯	303
5.10.4 支持向量机	313
5.10.5 多级分类	322
5.10.6 规则方法	324
5.10.7 网页分类	327
5.11 自动聚类	327
5.11.1 聚类的定义	327
5.11.2 K均值聚类方法	327
5.11.3 K均值实现	329
5.11.4 深入理解DBScan算法	335
5.11.5 使用DBScan算法聚类实例	336
5.12 拼音转换	338
5.13 概念搜索	339
5.14 多语言搜索	348
5.15 跨语言搜索	349
5.16 情感识别	350
5.16.1 确定词语的褒贬倾向	353
5.16.2 实现情感识别	355
5.16.3 用户协同过滤	356
5.17 本章小结	358
第6章 Lucene原理与应用	359
6.1 Lucene深入介绍	359
6.1.1 常用查询	359
6.1.2 查询语法与解析	361
6.1.3 查询原理	365
6.1.4 使用Filter筛选搜索结果	366
6.1.5 索引库中的高频成分	367
6.1.6 索引数值列	367
6.2 Lucene中的压缩算法	370
6.2.1 变长压缩	370
6.2.2 PForDelta	372
6.2.3 前缀压缩	375
6.2.4 差分编码	376
6.2.5 设计索引库结构	379
6.3 创建和维护索引库	380
6.3.1 创建索引库	380
6.3.2 向索引库中添加索引文档	380
6.3.3 删除索引库中的索引文档	384
6.3.4 更新索引库中的索引文档	384
6.3.5 索引的合并	385
6.3.6 索引文件格式	386
6.3.7 分发索引	388
6.3.8 修复索引	391
6.4 查找索引库	391
6.4.1 排序	392
6.5 读写并发控制	392
6.6 优化使用Lucene	393
6.6.1 索引优化	393
6.6.2 查询优化	394
6.6.3 实现时间加权排序	397
6.6.4 实现字词混合索引	400
6.6.5 重用Tokenizer	405
6.6.6 定制Tokenizer	405
6.7 检索模型	407
6.7.1 向量空间模型	408
6.7.2 BM25概率模型	412
6.7.3 统计语言模型	418
6.8 查询大容量索引	419
6.9 实时搜索	420
6.10 本章小结	421
第7章 搜索引擎用户界面	422
7.1 实现Lucene搜索	422
7.2 搜索页面设计	423
7.2.1 Struts2实现的搜索界面	424
7.2.2 翻页组件	424
7.3 实现搜索接口	425
7.3.1 编码识别	425
7.3.2 布尔搜索	429
7.3.3 指定范围搜索	429
7.3.4 搜索结果排序	430
7.3.5 搜索页面的索引缓存与更新	431
7.4 历史搜索词记录	432
7.5 实现关键词高亮显示	433
7.6 实现分类统计视图	435
7.7 实现相似文档搜索	441
7.8 实现AJAX搜索联想词	443
7.8.1 估计查询词的文档频率	443
7.8.2 搜索联想词总体结构	444
7.8.3 服务器端处理	444
7.8.4 浏览器端处理	446
7.8.5 服务器端改进	451
7.8.6 拼音提示	454
7.8.7 部署总结	455
7.9 集成其他功能	455
7.9.1 拼写检查	455
7.9.2 分类统计	456
7.9.3 相关搜索	458
7.9.4 再次查找	462
7.9.5 搜索日志	462
7.10 搜索日志分析	464
7.10.1 日志信息过滤	464
7.10.2 信息统计	465
7.10.3 挖掘日志信息	468
7.11 本章小结	469
第8章 使用Solr实现企业搜索	470
8.1 Solr简介	470
8.2 Solr基本用法	471
8.2.1 Solr服务器端的配置与中文支持	472
8.2.2 把数据放进Solr	477
8.2.3 删除数据	479
8.2.4 Solr客户端与搜索界面	480
8.2.5 Solr索引库的查找	482
8.2.6 索引分发	486
8.2.7 Solr搜索优化	489
8.3 从FAST Search移植到Solr	492
8.4 Solr扩展与定制	493
8.4.1 Solr中字词混合索引	493
8.4.2 相关检索	496
8.4.3 搜索结果去重	498
8.4.4 定制输入输出	501
8.4.5 分布式搜索	506
8.4.6 SolrJ查询分析器	508
8.4.7 扩展SolrJ	517
8.4.8 扩展Solr	518
8.4.9 查询Web图	522
8.5 Solr的.net客户端	525
8.6 Solr的PHP客户端	527
8.7 本章小结	530
第9章 地理信息系统案例分析	531
9.1 新闻提取	531
9.2 POI信息提取	536
9.2.1 提取主体	537
9.2.2 提取地区	538
9.2.3 指代消解	540
9.3 本章小结	542
第10章 户外活动搜索案例分析	543
10.1 爬虫	543
10.2 信息提取	544
10.3 搜索	547
10.4 本章小结	547
参考资源	548
书籍	548
网址	548
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>解密搜索引擎技术实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 2图形设计――卷Ⅰ：AWT（附CD）
前言
第一部分 入门
第1章 绪论
1.1Java基本类
1.2抽象窗口工具集
1.3同位体和平台独立
1.3.1轻量构件
1.3.2AWT和Swing构件
1.3.3AWT和2DAPI
1.4构件：AWT的基础
1.5构件、容器和布局管理器
1.5.1构件
1.5.2基本构件工具
1.5.3容器
1.5.4布局管理器
1.6小结
第2章 applet和应用程序
2.1 Java appl et
2.1.1使用appletv iewer
2.1.2浏览器的基础结构
2.1.3java.awt.Applet类
2.1.4关键Applet方法
2.1.5java.awv.Comoo nent显示方法
2.2Java应用程序
2.2.1 设置应用程序
2.2.2显示应用程序
2.3组合applet 和应用程序代码
2.4小结
第二部分 图形和图像
第3章 图形
3.1 java.awt.Graphics
3.2Graphics参数
3.3图形坐标系
3.3.1绘制图形形状
3.3.2绘制构件的四周边界
3.3.3填充形状
3.4Graphics引用
3.4.1引用副本的Graphics引用
3.4.2Graphics引用的寿命
3.4.3处理Graphics
3.5绘制和填充形状
3.5.1画直线
3.5.2画折线
3.5.3绘制矩形
3.5.4画弧
3.5.5绘制椭圆
3.5.6绘制多边形
3.5.7绘制文本
3.6转换坐标系原点
3.7剪贴
3.8图形模式
3.9创建图形
3.10小结
第4章 颜色和字体
4.1颜色模式
4.1.1索引颜色模式
4.1.2直接颜色模式
4.2java.awt.Color类
4.3系统颜色
4.4字体和字体度量
4.4.1Font类
4.4.2FontMetrics类
4.5小结
第5章 加载和显示图像
5.1Image 类和Image包
5.2图像生产者和图像消费者
5.2.1异步图像生产
5.2.2ImageProducer
5.2.3ImageObserver
5.3加载和显示图像
5.4applet 和应用程序之间的区别
5.5等待图像加载
5.6一次绘制图像的一行扫描线
5.7MediaTracker
5.8动画GIF
5.9AWT构件作为图像观察者
5.10创建图像
5.11加载图像作为资源
5.12小结
第6章 图像过滤
6.1Image Producer接口
6.2 mageC onsume r接口
6.3图像生产者和图像消费者之间的关系
6.4AWT图像过滤器
6.4.1CropImageFilter
6.4.2使用常规图像过滤器
6.4.3ReplicateScal eFilter和AreaAveraging
ScaleFilter
6.4.4组合图像过滤器
6.5ImageConsumer 属性
6.6实现自定义图像过滤器
6.7扩展RGBImageFilter
6.7.1DissolveFilter
6.7.2DissolveEdgeFilter
6.8扩展ImageFilter
6.8.1ImageFilter类
6.8.2向图像过滤器传输图像位
6.8.3用于传输像素的ColorModel
6.8.4扩展ImageFilter的溶解过滤器
6.8.5波形过滤器
6.9实现ImageConsumer接口
6.9.1图像溶解
6.9.2Dissolver类的实现
6.10双缓冲入门
6.11小结
第7章 无过滤图像处理
7.1缩放和闪烁图像
7.2抓取像素
7.3内存图像源
7.3.1使用MemoryImageSource
裁剪图像
7.3.2内存图像源和动画
7.4小结
第三部分 事件和布局管理器
第8章 基于继承的事件处理
8.1旧AWT事件模型
8.1.1覆盖事件处理方法
8.1.2被传播的事件
8.1.3事件类型常量
8.1.4事件的向外传播
8.1.5覆盖被传播的事件的处理
8.2事件修饰常数
8.3鼠标按钮事件
8.4关于鼠标和按钮
8.5监控鼠标事件
8.6检测双击
8.7动作事件
8.8标识构件
8.9基于继承的事件模型的缺点
8.9.1事件的传播
8.9.2继承的要求
8.9.3将事件处理插入到构件类中
8.9.4传送事件的责任
8.9.5handleEvent（）转换语句
8.10小结
第9章 授权事件模型
9.1授权事件模型
9.1.1构件、事件和监听者
9.1.2过滤事件
9.2结构概述
9.2.1事件
9.2.2构件作为事件源
9.2.3多点传送事件源
9.2.4 单点传送事件源
9.2.5事件源接口
9.2.6监听者
9.2.7事件处理方法的JavaBeans设计模式
9.3AWT适配器
9.4构件事件
9.4.1构件和容器事件
9.4.2焦点事件
9.4.3键盘事件
9.4.4鼠标和鼠标移动事件
9.4.5窗口事件
9.4.6画布和面板的焦点和键盘事件
9.4.7消耗输人事件
9.4.8绘制事件
9.5语义事件
9.5.1动作事件
9.5.2可调事件
9.5.3项目事件
9.5.4 文本事件
9.6事件适配器
9.6.1处理没有适配器的多点
事件源事件
9.6.2 类型安全的多路处理适配器
9.6.3一般的多路处理适配器
9.7内部类
9.7.1三维按钮
9.7.2 在单独的监听者类中封装事件处理
代码
9.7.3监听自己
9.7.4 命名内部类
9.7.5匿名内部类
9.7.6 修改默认的事件处理行为
9.8 从自定义构件中激发AWT事件
9.9 从自定义构件中激发自定义事件
9.9.1一个未经专门设计的方案
9.9.2 有关步骤
9.9.3开发自定义事件类
9.9.4 开发监听者接口
9.9.5 为注册监听者定义接口
9.9.6 开发可以激发自定义事件的自定义
构件
9.10 调度事件和AWT事件队列
9.11有效事件
9.12基于继承的机制
9.13 事件处理设计
9.13.1使用基于继承的事件模型
9.13.2 监听自己
9.13.3 在单独的类中封装事件
处理代码
9.13.4 使用内部类
9.13.5 命名内部类与匿名内部类相比
9.13.6 向容器传播事件
9.14 小结
第10章 构件、容器和布局管理器
10.1最大的三种AWT构件
10.2布局管理器
10.2.1两种类型的布局管理器
10.2.2布局管理器和容器空白区
10.2.3同位体和空白区
10.2.4布局管理器和构件首选尺寸
10.3绘制一个容器的构件
10.4强制一个容器布置它的构件
10.5标准AWT布局管理器
10.5.1使用何种布局管理器
10.5.2BorderLayout布局管理器
10.5.3CardLayout布局管理器
10.5.4 FlowLayout布局管理器
10.5.5GridLayout布局管理器
10.6GridBagLayout布局管理器
10.6.1GrdBaglayout和GridBag
Constraints
10.6.2网格单元和显示区
10.6.3与构件比较的显示区
10.6.4GridBagConstraints. anchor
10.6.5GridBagConstraints. fill
10.6.6GridBagConstraints.gridx和GridBag－
Constraints.gridy
10.6.7GridBagConstraints.gridwidth和GridBa g－
Constraints.gridheight
10.6.8GridBagConstraints.weightx和GridBag－
Constraints.weighty
10.6.9Grid BagC onstra ints.i nsets
10.6.10 GridBagConst raint s.ip adx 和GridBag－
Constraints.ipady
10.6.11Grid BagLab
10.6.12 GridBagLayout和输入表单
10.6.13在嵌套的面板中布置构件
10.6.14嵌套面板之间的通信
10.6.15GridLabApplet的实现
10.7 null 布局管理器
10.8自定义布局管理器
10.8.1BulletinLayout
10.8.2运行BulletinLayout自定义布局管
理器
10.8.3Row Layout
10.8.4 运行RowLayout自定义布局管
理器
10.8.5RowLayoutApplet的实现
10.8.6ColumnLayout
10.8.7运行ColumnLayout 自定义布局管
理器
10.9 小结
第四部分 AWT构件
第1章 AWTComponent类
11.1构件
11.2java.awt.Component
11.3构件属性
11.4不赞成的方法
11.5构件的位置、边界和坐标
11.6构件的首选、最小和最大尺寸
11.7构件的可见性和响应
11.8构件和同位体
11.9显示构件
11.10 构件和zorder
11.11构件和光标
11.12构件和串行化
11.13构件和国际化
11.13.1Locale
11.13.2资源包
11.13.3Simplel18Ntestapplet
11.13.4资源包属性
11.13.5从国际化代码中分离出GUI
11.13.6 可用地区和两个字符的编码
11.14 构件和JavaBeans
11.14.1约束属性
11.14.2在自定义构件中实现
约束属性
11.15构件和树锁定
11.16小结
第12章 基本构件：标签、按钮、画布
和面板
12.1标签和按钮
12.1.1 java.awt.Label
12.1.2java.awt.Button
12.2 画布和面板
12.2.1java.awt.Canvas
12.2.2java.awt.Panel
12.3小结
第13章 项目选择：复选框 选择框和
列表
13.1复选框
13.1.1java .awt.ItemSel ectable接口
13.1.2java.awt.Checkbox
13.1.3相容的复选框
13.1.4 相互排斥的复选框
13.2选择框和列表
13.2.1是采用列表还是选择框
13.2.2java.awt.Choice
13.2.3java.awt.list
13.2.4 双列表构件
13.3小结
第14章 文本构件
14.1java.awt.TextCompone nt
14.1.1文本选择
14.1.2TextComponent监听者
14.2java.awt.TextField
14.2.1输入的有效性
14.2.2 退出有效性
14.2.3过程中确认
14.3java.awt.TextArea
14.4 小结
第15章 滚动：滚动条与滚动框
15.1java.awt.Scrollbar
15.2java.awt.ScrollPane
15.2.1滚动构件
15.2.2滚动图像
15.2.3程序控制滚动
15.3小结
第16章 窗口、框架与对话框
16.1java.awt.Window
16.1.1快闪屏
16.1.2提示框帮助
16.2 java.awt.Frame
16.3java.awt.Dialog
16.3.1模式对话框与多线程
16.3.2java.awt.FileDialog
16.4 小结
第17章 菜单
17.1菜单类
17.2文件菜单
17.3处理菜单事件
17.4拖离菜单
17.5MenuBarPrinter
17.6FrameWithMenuBar类
17.7帮助菜单
17.8复选框菜单项
17.9级联菜单
17.10动态更改菜单
17.11弹出式菜单
17.11.1弹出式菜单与构件
17.11.2处理弹出式菜单事件
17.11.3 显示与构件相关的弹出式菜单
17.12小结
第18章 无鼠标操作与打印
18.1无鼠标操作
18.2键盘遍历
18.2.1标准AWT构件与键盘遍历
18.2.2 自定义构件及其键盘遍历
18.3菜单快捷键
18.3.1菜单类与快捷键
18.3.2菜单快捷键示例
18.4打印
18.4.1获取PrintGraphics的引用
18.4.2打印自身的applet
18.4.3打印对话框及其属性
18.4.4 页码设置
18.5 小结
第19章 轻量构件
19.1引入轻量构件
19.1.1AWT：重量构件的世界
19.1.2轻量构件与重量构件
19.2简单的轻量构件
19.2.1简单的重量构件
19.2.2从重量构件到轻量构件
19.3轻量容器
19.4轻量构件与zorder
19.5轻量构件及其Graphics
19.6轻量构件与首选尺寸
19.7小结
第五部分 高级主题
第20章 剪贴板与数据传输
20.1java.awt.datatransfe r软件包
20.2Clipboard类
20.2.1将数据复制到剪贴板及从剪贴板
取出数据
20.2.2ClipboardOwner类
20.3系统剪贴板
20.4 局部剪贴板
20.5数据传送机制
20.5.1数据格式
20.5.2Transferable对象与数据格式
20.5.3StringSelection
20.6 将图像复制到剪贴板
20.6.1ImageSelection――封装图像的
Transferable对象
20.6.2使用ImageSelection类
20.6.3增加另外一种数据格式
20.7传递自定义AWT构件
20.7.1封装自定义AWT构件的可传递
对象
20.7.2图像按钮传送applet
20.8小结
第21章 拖放技术
21.1j四a.awt dnd 软件包
21.2拖动源与放置目标
21.2.1简单的拖放程序范例
21.2.2拖动意图
21.2.3拖动源
21.2.4放置目标
21.2.5事件
21.2.6DragSourceDragEvent与DragSource
DropEvent
21.2.7DropTargetDragE vent与 DropTarget
DropEvent
21.2.8特定的拖动源与放置目标
21.2.9继承与授权
21.2.10映射
21.2.11自动滚动
21.3小结
第22章 自定义对话框
22.1对话框类
22.1.1 GJTDialog
22.1.2非模式对话框和DialogClient接口
22.1.3再论GJTDialog
22.2WorkDialog
22.3ButtonPanel
22.4Postcard
22.5MessageDialog
22.6YesNoDialog
22.7QuestionDialog
22.8小结
第23章 橡皮带技术
23.1橡皮带类
23.2Rubberband基本类
23.2.1Rubberband方法及类成员
23.2.2以XOR模式绘图
23.2.3绘制橡皮带线条
23.2.4绘制橡皮带矩形与椭圆形
23.3橡皮带面板
23.4使用DrawingPanel类
23.5重分解单元测试
23.6小结
第24章 双缓冲技术
24.1双缓冲技术与动画
24.2双缓冲如何工作
24.3可拖动轻量构件与双缓冲容器
24.3.1Util类
24.3.2BackingStore类
24.3.3DoubleBufferedContainer类
24.3.4Lightweight类
24.4小结
第25章 子图形动画
25.1构成
25.2序列与子图形
25.2.1Sequence
25.2.2子图形
25.3Playfield与DoubleBufferedContainer
25.4冲突检测
25.4.1CollisionArena
25.4.2CollisionDetector
25.4.3SpriteCollisionDe tector
25.4.4EdgeCollision
25.5使用animation软件包
25.5.1简单的动画
25.5.2碰撞动画
25.5.3两个子图形之间的冲突
25.6小结
附录A AwT类框图
附录B 关于本书的CD－ROM

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 2图形设计――卷Ⅰ：AWT（附CD）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java实用系统开发指南
前言
第1章 高性能聊天系统
1 系统需求
2 架构设计
3 Socket核心设计和实现
4 Socket接口设计和实现
5 应用接口设计和实现
6 应用层设计和实现
7 性能测试
8 小结
第2章 简单的用户注册系统
……
第3章 Jive论坛系统
……
第4章 网站内容管理系统
……
第5章 订阅信息系统
……
第6章 用户安全管理系统
……
第7章 EJB方法调用框架
……
第8章 网上商店系统
……

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java实用系统开发指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java性能调优指南
前言	VII
致谢	IX
作者介绍	XII
第1章  Garbage First综述	1
术语	1
并行垃圾收集器	2
串行垃圾收集器	4
并发标记清除（CMS）垃圾收集器	5
收集器的概括总结	7
Garbage First（G1）垃圾收集器	8
G1设计	10
巨型（Humongous）对象	12
Full垃圾收集	12
并发周期	13
堆空间调整	13
引用	14
第2章  深入Garbage First垃圾收集器	15
背景	15
G1中的垃圾收集	16
年轻代	17
年轻代收集暂停	18
对象老化与老年代	19
巨型分区	19
混合收集	22
收集集合及其重要性	24
已记忆集合及其重要性	24
并发优化线程以及栅栏	28
G1 GC的并发标记	30
并发标记阶段	34
初始标记	34
根分区扫描	34
并发标记	34
重新标记	36
清除	36
转移失败与Full收集	37
引用	38
第3章  Garbage First垃圾收集器性能优化	39
年轻代收集的各阶段	39
所有并行活动的开始	41
外部根分区	42
已记忆集合和已处理缓冲区	42
已记忆集合总结	44
转移和回收	47
终止	47
GC外部的并行活动	48
所有并行活动总结	48
所有串行活动的启动	48
其他串行活动	49
年轻代调优	50
并发标记阶段调优	52
混合垃圾收集阶段回顾	54
混合垃圾收集阶段调优	56
避免转移失败	59
引用处理	60
观察引用处理	60
引用处理调优	62
引用	65
第4章  The Serviceability Agent	67
SA是什么	67
为什么要用SA	68
SA组件	68
JDK中的SA二进制文件	69
SA的JDK版本说明	69
SA如何获得Hotspot虚拟机的内部数据结构	70
SA版本对照	71
SA调试工具	72
HSDB	72
HSDB工具	80
命令行Hotspot调试器CLHSDB	100
其他工具	103
CoreDump和崩溃Dump文件	109
调试非本地生成的Core文件	109
SA的共享库问题	110
消除共享库问题	110
SA的系统属性	111
SA的环境变量	113
JDI实现	114
扩展SA工具	115
VisualVM的SA插件	118
VisualVM中怎样安装SA插件	119
SA插件使用	119
SA插件功能	120
用SA做故障分析	124
内存溢出错误分析	124
诊断语言层死锁	132
事后分析Hotspot虚拟机崩溃	137
附录  虚拟机命令行附加参数探秘	145
索引	155
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java性能调优指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java就该这样学
第1部分  认识Java程序	1
1.1  写代码前的准备	1
1.1.1  程序的入口	2
1.1.2  初步理解类和对象	4
1.2  画王八	5
1.2.1  运行Java程序	8
1.2.2  绘图	11
1.3  满天星星	19
1.4  飞行的小球	24
1.4.1  使用线程	25
1.4.2  线程的生命周期	29
1.5  小球撞墙	31
1.6  下大雪	35
1.7  键盘控制小球	40
1.8  打字母的游戏	48
1.9  鼠标控制小球	59
1.10  第一阶段总结	61
第2部分  认识Java程序	63
2.1  聊天界面	63
2.1.1  任务描述	63
2.1.2  做按钮	64
2.1.3  Java的布局思想	66
2.1.4  登录界面	71
2.1.5  主界面	72
2.2  响应用户输入	75
2.2.1  任务描述	75
2.2.2  事件响应	75
2.2.3  关于字符串内容的比较	78
2.2.4  取得用户名和密码	80
2.2.5  用面向对象的思想重写	82
2.2.6  上溯和下溯的讨论	83
2.3  IO流	85
2.3.1  任务描述	86
2.3.2  读一个字符	87
2.3.3  读整个文件	90
2.3.4  复制文件	93
2.3.5  复制大文件	93
2.3.6  文件的加密/解密	96
2.3.7  异常的干扰	101
2.3.8  字符流	103
2.3.9  实现聊天记录	106
2.4  建立网络通信	110
2.4.1  什么是网络	110
2.4.2  在网络上传消息	113
2.4.3  到服务器验证用户名和密码	119
2.4.4  将聊天信息发送到服务器	122
2.5  数据库访问	130
2.5.1  接触MySQL	133
2.5.2  创建和删除数据库	135
2.5.3  创建、修改和删除表	136
2.5.4  关于数据库设计	139
2.5.5  学习添加、删除和修改数据	141
2.5.6  查询数据	143
2.5.7  SQL复习	148
2.5.8  用Java访问数据库	149
2.5.9  用户身份验证	157
2.5.10  将代码融入项目中	160
2.5.11  讨论反射	162
2.6  应对多用户访问	168
第3部分  获得逻辑能力	172
3.1  用数组实现的记事本	172
3.2  使用链表的记事本	178
3.3  让Java系统库帮助你	184
3.4  思考面向对象和面向过程的不同	187
3.5  深入学习ArrayList和LinkedList	188
3.5.1  泛型	190
3.6  Set集合	193
3.7  试试二分查找法，理解二叉树	199
3.8  复制一个目录的内容	201
3.9  Map	211
3.10  保存用户的Socket	212
3.11  同步用户名	215
3.12  多用户转发逻辑	219
第4部分  理解面向对象	230
4.1  用面向对象的思想重写聊天程序	230
4.2  做一个数据库的管理工具	238
4.3  驾驭JTable	243
4.4  有更好的方法驾驭JTable	247
4.5  用面向对象的方法驾驭JTable	248
4.6  完成资源管理器	256
4.7  有没有更好的参数传递方式	275
附录A  准备编程环境	276
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java就该这样学
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java从入门到精通
第1篇　基础知识　第1章　初识Java3　视频讲解：34分钟　第2章　熟悉Eclipse开发工具　视频讲解：35分钟　第3章　Java语言基础　视频讲解：37分钟　第4章　流程控制　视频讲解：25分钟　第5章　字符串　视频讲解：38分钟　第6章　数组　视频讲解：51分钟　第7章　类和对象　视频讲解：57分钟　第8章　包装类141　视频讲解：19分钟　第9章　数字处理类　视频讲解：21分钟第2篇　核心技术　第10章　接口、继承与多态　视频讲解：36分钟　第11章　类的高级特性　视频讲解：29分钟　第12章　异常处理　视频讲解：23分钟　第13章　Swing程序设计　视频讲解：1小时2分钟　第14章　集合类　视频讲解：24分钟　第15章　I/O输入输出　视频讲解：39分钟　第16章　反射　视频讲解：48分钟　第17章　枚举类型与泛型　视频讲解：22分钟　第18章　多线程　视频讲解：20分钟　第19章　网络通信　视频讲解：24分钟　第20章　数据库操作第3篇　高级应用　第21章　Swing表格组件　视频讲解：59分钟　第22章　Swing树组件　视频讲解：1小时4分钟　第23章　Swing其他高级组件　视频讲解：1小时35分钟　第24章　高级布局管理器　视频讲解：1小时40分钟　第25章　高级事件处理　视频讲解：33分钟　第26章　AWT绘图与音频播放　视频讲解：34分钟　第27章　打印技术　视频讲解：32分钟　第28章　企业进销存管理系统　视频讲解：1小时37分钟
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java从入门到精通
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java就该这样学
第1部分认识Java程序	1
1.1  写代码前的准备	1
1.1.1  程序的入口	2
1.1.2  初步理解类和对象	4
1.2  画王八	5
1.2.1  运行Java程序	8
1.2.2  绘图	11
1.3  满天星星	19
1.4  飞行的小球	24
1.4.1  使用线程	25
1.4.2  线程的生命周期	29
1.5  小球撞墙	31
1.6  下大雪	35
1.7  键盘控制小球	40
1.8  打字母的游戏	48
1.9  鼠标控制小球	59
1.10  第一阶段总结	61
第2部分认识Java程序	63
2.1  聊天界面	63
2.1.1  任务描述	63
2.1.2  做按钮	64
2.1.3  Java的布局思想	66
2.1.4  登录界面	71
2.1.5  主界面	72
2.2  响应用户输入	75
2.2.1  任务描述	75
2.2.2  事件响应	75
2.2.3  关于字符串内容的比较	78
2.2.4  取得用户名和密码	80
2.2.5  用面向对象的思想重写	82
2.2.6  上溯和下溯的讨论	83
2.3  IO流	85
2.3.1  任务描述	86
2.3.2  读一个字符	87
2.3.3  读整个文件	90
2.3.4  复制文件	93
2.3.5  复制大文件	93
2.3.6  文件的加密/解密	96
2.3.7  异常的干扰	101
2.3.8  字符流	103
2.3.9  实现聊天记录	106
2.4  建立网络通信	110
2.4.1  什么是网络	110
2.4.2  在网络上传消息	113
2.4.3  到服务器验证用户名和密码	119
2.4.4  将聊天信息发送到服务器	122
2.5  数据库访问	130
2.5.1  接触MySQL	133
2.5.2  创建和删除数据库	135
2.5.3  创建、修改和删除表	136
2.5.4  关于数据库设计	139
2.5.5  学习添加、删除和修改数据	141
2.5.6  查询数据	143
2.5.7  SQL复习	148
2.5.8  用Java访问数据库	149
2.5.9  用户身份验证	157
2.5.10  将代码融入项目中	160
2.5.11  讨论反射	162
2.6  应对多用户访问	168
第3部分获得逻辑能力	172
3.1  用数组实现的记事本	172
3.2  使用链表的记事本	178
3.3  让Java系统库帮助你	184
3.4  思考面向对象和面向过程的不同	187
3.5  深入学习ArrayList和LinkedList	188
3.5.1  泛型	190
3.6  Set集合	193
3.7  试试二分查找法，理解二叉树	199
3.8  复制一个目录的内容	201
3.9  Map	211
3.10  保存用户的Socket	212
3.11  同步用户名	215
3.12  多用户转发逻辑	219
第4部分理解面向对象	230
4.1  用面向对象的思想重写聊天程序	230
4.2  做一个数据库的管理工具	238
4.3  驾驭JTable	243
4.4  有更好的方法驾驭JTable	247
4.5  用面向对象的方法驾驭JTable	248
4.6  完成资源管理器	256
4.7  有没有更好的参数传递方式	275
附录A  准备编程环境	276
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java就该这样学
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>最新Java 2核心技术卷I:原理（原书第5版）
译者序
前言
第1章 Java简介
第2章 Java编程环境
第3章 Java基本编程结构
第4章 对象和类
第5章 继承
第6章 接口和内部类
第7章 图形编程
第8章 事件处理
第9章 Swing用户界面组件
第10章 applet
第11章 异常和调试
第12章 流和文件
附录A Java关键字
附录B 关于光盘
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>最新Java 2核心技术卷I:原理（原书第5版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java大学教程
第1章 计算机和Java applet简介
第2章 控制结构（一）
第3章 控制结构（二）
第4章 方法
第5章 数组
第6章 基于对象的编程
第7章 面向对象的编程
第8章 字符串和字符
第9章 图形
第10章 图形用户界面组件（一）
第11章 图形用户界面组件（二）
第12章 异常处理
第13章 多线程
……
附录A 运算符优先级表
……
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java大学教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>21天学通Java
第1周课程 Java语言
第1章 Java基础
1.1 Java语言
1.1.1 Java的历史
1.1.2 Java概述
1.1.3 选择开发工具
1.2 面向对象编程
1.3 对象和类
1.4 属性和行为
1.4.1 属性
1.4.2 行为
1.4.3 创建类
1.4.4 运行程序
1.5 组织类和类行为
1.5.1 继承
1.5.2 创建类层次结构
1.5.3 使用继承
1.5.4 接口
1.5.6 包
1.6 总结
1.7 问与答
1.8 小测验
1.9 认证练习
1.10 练习
第2章 Java编程基础
2.1 语句和表达式
2.2 变量和数据类型
2.2.1 创建变量
2.2.2 给变量命名
2.2.3 变量类型
2.2.4 给变量赋值
2.2.5 常量
2.3 注释
2.4 字面量
2.4.1 数字字面量
2.4.2 布尔字面量
2.4.3 字符字面量
2.4.4 字符串字面量
2.5 表达式和运算符
2.5.1 算术运算符
2.5.2 再谈赋值
2.5.3 递增和递减运算符
2.5.4 比较运算符
2.5.5 逻辑运算符
2.5.6 运算符优先级
2.6 字符串运算
2.7 总结
2.8 问与答
2.9 小测验
2.10 认证练习
2.11 练习
第3章 对象
3.1 创建新对象
3.1.1 使用new
3.1.2 对象是如何创建的
3.1.3 内存管理
3.2 使用类变量和实例变量
3.2.1 获取值
3.2.2 设置值
3.2.3 类变量
3.3 调用方法
3.3.1 设置字符串的格式
3.3.2 嵌套方法调用
3.3.3 类方法
3.4 对象的引用
3.5 对象和基本数据类型的强制类型转换
3.5.1 强制转换基本类型
3.5.2 强制转换对象
3.5.3 基本类型和对象之间的转换
3.6 比较对象值和类
3.6.1 比较对象
3.6.2 判断对象所属的类
3.7 总结
3.8 问与答
3.9 小测验
3.10 认证练习
3.11 练习
第4章 数组、逻辑和循环
4.1 数组
4.1.1 声明数组变量
4.1.2 创建数组对象
4.1.3 访问数组元素
4.1.4 修改数组元素
4.1.5 多维数组
4.2 块语句
4.3 if条件语句
4.4 switch条件语句
4.5 三目运算符
4.6 for循环
4.7 while和do循环
4.7.1 while循环
4.7.2 do...while循环
4.8 跳出循环
4.9 总结
4.10 问与答
4.10 小测验
4.12 认证练习
4.13 练习
第5章 创建类和方法
5.1 定义类
5.2 创建实例变量和类变量
5.2.1 定义实例变量
5.2.2 类变量
5.3 创建方法
5.3.1 定义方法
5.3.2 关键字this
5.3.3 变量作用域和方法定义
5.3.4 将参数传递给方法
5.3.5 类方法
5.4 创建Java应用程序
5.5 Java应用程序和命令行参数
5.5.1 将参数传递给Java应用程序
5.5.2 在Java程序中处理参数
5.6 创建同名方法
5.7 构造函数
5.7.1 基本的构造函数
5.7.2 调用另一个构造函数
5.7.3 重载构造函数
5.8 覆盖方法
5.8.1 创建覆盖现有方法的方法
5.8.2 调用原来的方法
5.8.3 覆盖构造函数
5.9 总结
5.10 问与答
5.11 小测验
5.12 认证练习
5.14 练习
第6章 包、接口和其他类特性
6.1 限定符
6.2 静态变量和方法
6.3 Final类、方法和变量
6.3.1 变量
6.3.2 方法
6.3.3 类
6.4 抽象类和方法
6.5 包
6.5.1 import声明
6.5.2 类名冲突
6.6 创建自己的包
6.6.1 选择包名
6.6.2 创建文件夹结构
6.6.3 将类加入到包中
6.6.4 包和类访问控制
6.7 接口
6.7.1 单继承存在的问题
6.7.2 接口和类
6.7.3 实现和使用接口
6.7.4 实现多个接口
6.7.5 接口的其他用途
6.8 创建和扩展接口
6.8.1 新接口
6.8.2 接口中的方法
6.8.3 扩展接口
6.8.4 创建网上商店
6.9 内部类
6.10 总结
6.11 问与答
6.12 小测验
6.13 认证练习
6.14 练习
第7章 异常和线程
7.1 异常
7.2 管理异常
7.2.1 异常一致性检测
7.2.2 保护代码和捕获异常
7.2.3 finally子句
7.3 声明可能引发异常的方法
7.3.1 throws子句
7.3.2 应引发哪些异常
7.3.3 传递异常
7.3.4 throws和继承
7.4 创建并引发自己的异常
7.4.1 引发异常
7.4.2 创建自己的异常
7.4.3 结合使用throws、try和throw
7.5 何时使用和不使用异常
7.5.1 什么时候使用异常
7.5.2 什么时候不使用异常
7.5.3 糟糕的异常使用方式
7.6 线程
7.6.1 编写线程化程序
7.6.2 线程化应用程序
7.6.3 终止线程
7.7 总结
7.8 问与答
7.9 小测验
7.10 认证练习
7.11 练习
第2周课程 Java类库
第8章 数据结构
8.1 超越数组
8.2 Java数据结构
8.2.1 Iterator
8.2.2 位组
8.2.3 链表
8.2.4 遍历数据结构
8.2.5 堆栈
8.2.6 Map
8.2.7 散列映射
8.3 泛型
8.4 总结
8.5 问与答
8.6 小测验
8.7 认证练习
8.8 练习
第9章 使用Swing
9.1 创建应用程序
9.1.1 创建界面
9.1.2 开发框架
9.1.3 创建组件
9.1.4 将组件加入到容器中
9.2 使用组件
9.2.1 图标
9.2.2 标签
9.2.3 文本框
9.2.4 文本区域
9.2.5 可滚动窗格
9.2.6 复选框和单选按钮
9.2.7 组合框
9.2.8 列表
9.3 总结
9.4 问与答
9.5 小测验
9.6 认证练习
9.7 练习
第10章 创建Swing界面
10.1 Swing的特性
10.1.1 标准对话框
10.1.2 使用对话框
10.1.3 滑块
10.1.4 滚动窗格
10.1.5 工具栏
10.1.6 进度条
10.1.7 菜单
10.1.8 选项卡窗格
10.2 总结
10.3 问与答
10.4 小测验
10.5 认证练习
10.6 练习
第11章 在用户界面上排列组件
11.1 基本的界面布局
11.1.1 布置界面
11.1.2 顺序布局
11.1.3 方框布局
11.1.4 网格布局
11.1.5 边框布局
11.2 使用多个布局管理器
11.3 卡片布局
11.4 网格袋布局
11.4.1 设计网格
11.4.2 创建网格
11.4.3 单元格padding和insets
11.5 总结
11.6 问与答
11.7 小测验
11.8 认证练习
11.9 练习
第12章 响应用户输入
12.1 事件监听器
12.1.1 设置组件
12.1.2 事件处理方法
12.2 使用方法
12.2.1 行为事件
12.2.2 焦点事件
12.2.3 选项事件
12.2.4 键盘事件
12.2.5 鼠标事件
12.2.6 鼠标移动事件
12.2.7 窗口事件
12.2.8 使用适配器类
12.2.9 使用内部类
12.3 总结
12.4 问与答
12.5 小测验
12.6 认证练习
12.7 练习
第13章 创建Java2D图形
13.1 Graphics2D类
13.2 绘制文本
13.2.1 使用防锯齿改善字体和图形的质量
13.2.2 获取字体的信息
13.3 颜色
13.3.1 使用Color对象
13.3.2 检测和设置当前颜色
13.4 绘制直线和多边形
13.4.1 用户坐标空间和设备坐标空间
13.4.2 指定渲染属性
13.4.3 创建要绘制的对象
13.4.4 绘制对象
13.5 总结
13.6 问与答
13.7 小测验
13.8 认证练习
13.9 练习
第14章 开发Swing应用程序
14.1 Java Web Start
14.2 使用Java Web Start
14.2.1 创建JNLP文件
14.2.2 在服务器上支持Web Start
14.2.3 其他JNLP元素
14.3 使用SwingWorker改善性能
14.4 总结
14.5 问与答
14.6 小测验
14.7 认证练习
14.8 练习
第3周课程 Java编程
第15章 输入和输出
15.1 流简介
15.1.1 使用流
15.1.2 过滤流
15.1.3 处理异常
15.2 字节流
15.3 过滤流
15.4 字符流
15.4.1 读取文本文件
15.4.2 写文本文件
15.5 文件和路径
15.6 总结
15.7 问与答
15.8 小测验
15.9 认证练习
15.10 练习
第16章 序列化和查看对象
16.1 对象序列化
16.1.1 对象输出流
16.1.2 对象输入流
16.1.3 暂态变量
16.1.4 检查对象的序列化字段
16.2 使用反射检查类和方法
16.2.1 检查和创建类
16.2.2 处理类的各个部分
16.2.3 检查类
16.3 总结
16.4 问与答
16.5 小测验
16.6 认证练习
16.7 练习
第17章 通过Internet进行通信
17.1 Java联网技术
17.1.1 打开跨越网络的流
17.1.2 套接字
17.1.3 Socket服务器
17.1.4 设计服务器应用程序
17.1.5 测试服务器
17.2 java.nio包
17.2.1 缓冲区
17.2.2 字符集
17.2.3 通道
17.2.4 网络通道
17.3 总结
17.4 问与答
17.5 小测验
17.6 认证练习
17.7 练习
第18章 使用JDBC访问数据库
18.1 JDBC
18.1.1 数据库驱动程序
18.1.2 查看数据库
18.1.3 读取数据库记录
18.1.4 将记录写入数据库
18.1.5 遍历结果集
18.2 总结
18.3 问与答
18.4 小测验
18.5 认证练习
18.6 练习
第19章 读写RSS Feed
19.1 使用XML
19.2 设计XML语言
19.3 使用Java处理XML
19.4 使用XOM处理XML
19.4.1 创建XML文档
19.4.2 修改MXL文档
19.4.3 格式化XML文档
19.4.4 评估XOM
19.5 总结
19.6 问与答
19.7 小测验
19.8 认证练习
19.9 练习
第20章 XML Web服务
20.1 XML-RPC简介
20.2 使用XML-RPC进行通信
20.2.1 发送请求
20.2.2 响应请求
20.3 选择XML-RPC实现
20.4 使用XML-RPC Web服务
20.5 创建XML-RPC Web服务
20.6 总结
20.7 问与答
20.8 小测验
20.9 认证练习
20.10 练习
第21章 使用Java编写Android应用
21.1 Android的历史
21.2 编写Android应用
21.2.1 组织Android项目
21.2.2 创建程序
21.2.3 使用Android模拟器
21.2.4 创建调试配置
21.3 运行应用
21.4 设计Android应用
21.4.1 准备资源
21.4.2 配置清单文件
21.4.3 设计图形用户界面
21.4.4 编写代码
21.5 总结
21.6 问与答
21.7 小测验
21.8 认证练习
21.9 练习
附录
附录A 使用集成开发环境NetBeans
A.1 安装NetBeans
A.2 新建项目
A.3 新建Java类
A.4 运行应用程序
A.5 修复错误
附录B 配套网站
附录C 搭建Android开发环境
C.1 简介
C.2 安装Eclipse
C.3 安装Android SDK
C.4 安装Android插件
C.5 设置手机
附录D 使用Java开发包
D.1 选择Java开发工具
D.2 配置JDK
D.2.1 使用命令行界面
D.2.2 切换文件夹
D.2.3 在MS-DOS中创建文件夹
D.2.4 在MS-DOS中运行程序
D.2.5 修复配置错误
D.3 使用文本编辑器
D.4 创建示例程序
D.5 设置CLASSPATH变量
D.5.1 在Windows 98/Me中设置CLASSPATH
D.5.2 在Windows 7/NT/XP/2000/2003中设置CLASSPATH
附录E 使用Java开发包编程
E.1 JDK概览
E.2 Java虚拟机
E.3 编译器javac
E.4 浏览器appletviewer
E.5 文档工具javadoc
E.6 Java文件存档工具jar
E.7 调试器jdb
E.7.1 调试应用程序
E.7.2 调试小程序
E.7.3 高级调试命令
E.8 使用系统属性
附录F 测验题答案
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>21天学通Java
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>More Java Pitfalls中文版
第一部分&nbsp;&nbsp;客户层	1&nbsp;Item&nbsp;1：当Runtime.exec()运行出错时	4&nbsp;Item&nbsp;2：NIO的效率和陷阱	16&nbsp;Item&nbsp;3：我宁愿不使用属性	31&nbsp;Item&nbsp;4：当信息隐藏得太多时	35&nbsp;Item&nbsp;5：避免java.util.logging中的粒度陷阱	41&nbs

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>More Java Pitfalls中文版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web Services教程
第1章 web服务介绍	1
1.1 xml和java平台的角色	1
1.2 什么是xml	2
1.3 java api for xml概述	4
1.4 jaxp	5
1.5 jax-rpc	10
1.6 jaxm	11
1.7 jaxr	16
1.8 示例	18
第2章 了解xml	20
2.1 xml介绍	20
2.2 xml 和相关规范	26
2.3 设计xml数据结构	33
第3章 从tomcat开始	38
3.1 设置	38
3.2 创建getting started应用程序	39
3.3 使用ant连编和部署getting started 应用程序	41
3.4 运行getting started应用程序	43
3.5 修改应用程序	44
3.6 常见问题及其解决方案	45
.第4章 jaxp	47
4.1 jaxp api	47
4.2 程序包概述	47
4.3 sax api	48
4.4 dom api	50
4.5 xslt api	51
4.6 编译并运行程序	52
4.7 进一步的阅读	52
第5章 sax	54
5.1 编写一个简单的xml文件	55
5.2 定义根元素	55
5.3 使用sax解析器回显一个xml文件	58
5.4 添加额外的事件处理程序	68
5.5 使用非验证型解析器处理错误	70
5.6 替代和插入文本	76
5.7 创建一个dtd	79
5.8 dtd对非验证型解析器的影响	82
5.9 定义dtd中的属性和实体	84
5.10 引用二进制实体	89
5.11 使用验证型解析器	90
5.12 定义参数实体和条件段	93
5.13 对参数化dtd进行解析	95
5.14 处理词法事件	97
5.15 使用dtdhandler 和entityresolver	102
第6章 文档对象模型	104
6.1 把xml数据读取到dom中	104
6.2 显示dom层次结构	109
6.3 检查dom的结构	120
6.4 从dom创建一个用户友好的jtree 124
6.5 创建并操作dom	135
6.6 使用名字空间	139
第7章 xslt	142
7.1 介绍xslt 和xpath	142
7.2 将dom作为xml文件写出	148
7.3 从数据结构生成xml 153
7.4 使用xslt转换xml数据	162
7.5 使用一个过滤器链串接xslt转换	179
第8章 jaxm	185
8.1 jaxm概述	185
8.2 运行示例	190
8.3 教程	192
8.4 代码示例	204
第9章 jax-rpc	213
9.1 什么是jax-rpc	213
9.2 一个简单示例: helloworld	214
9.3 动态调用接口	221
第10章 jaxr	225
10.1 jaxr概述	225
10.2 实现一个jaxr客户	227
10.3 使用注册表浏览器	235
第11章 java wsdp 注册表服务器	239
11.1 设置注册表服务器	239
11.2 通过注册表浏览器使用注册表服务器	240
11.3 通过注册表服务器使用命令行客户脚本	240
11.4 使用jaxr api访问注册表服务器	241
11.5 使用indri工具访问注册表服务器数据库	242
第12章 web应用程序	244
12.1 web应用程序的生命周期	244
12.2 web应用程序档案	246
12.3 web应用程序部署描述符	246
12.4 部署web应用程序	249
12.5 运行web应用程序	250
12.6 更新web应用程序	250
12.7 对web应用程序进行国际化和本地化	251
12.8 从web应用程序访问数据库	252
第13章 java servlet技术	255
13.1 什么是servlet	255
13.2 示例servlet	256
13.3 servlet的生命周期	257
13.4 共享信息	259
13.5 初始化servlet	261
13.6 编写服务方法	262
13.7 过滤请求和响应	266
13.8 调用其他web资源	270
13.9 访问web上下文环境	273
13.10 维护客户状态	273
13.11 结束一个servlet	275
第14章 jsp技术	278
14.1 什么是jsp页面	278
14.2 jsp页面示例	280
14.3 jsp页面的生命周期	281
14.4 初始化和结束jsp页面	283
14.5 创建静态内容	284
14.6 创建动态内容	284
14.7 在jsp页面中包括内容	288
14.8 将控制权转移到其他web组件	289
14.9 包括小应用程序	289
14.10 扩展jsp语言	291
第15章 jsp页面中的javabeans组件	293
15.1 javabeans组件设计约定	293
15.2 为什么使用javabeans组件	294
15.3 创建和使用javabeans组件	294
15.4 设置javabeans 组件属性 295
15.5 获取javabeans 组件属性	297
第16章 jsp页面中的自定义标签	299
16.1 什么是自定义标签	299
16.2 jsp页面示例	300
16.3 使用标签	301
16.4 定义标签	304
16.5 示例	314
第17章 jsp标准标签库	323
17.1 jsp页面示例	323
17.2 使用jstl	324
17.3 表达式语言支持	326
17.4 核心标签	328
17.5 xml 标签	331
17.6 国际化标签	333
17.7 sql标签	334
第18章 xrpcc工具	337
18.1 语法	337
18.2 配置文件	338
第19章 http概述	341
19.1 http请求	341
19.2 http 响应	341
附录 java编码方案	343
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web Services教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java完全自学手册
写给自学编程的人员前言第一篇 Java技术入门  第0章 Java技术概述    0.1 Java技术      0.1.1 Java编程语言      0.1.2 Java语言平台      0.1.3 Java语言的功能      0.1.4 Java语言的优点    0.2 Windows下的“HelloWorld”应用程序      0.2.1 创建应用程序的软件环境      0.2.2 创建“HelloWorld”应用程序的步骤    0.3 深入探讨“HelloWorld”应用程序      0.3.1 注释源代码      0.3.2 实现类定义      0.3.3 详解main()方法    0.4 常见编译错误      0.4.1 环境变量设置错误      0.4.2 语法错误      0.4.3 语义错误      0.4.4 运行时错误    0.5 本章习题  第1章 Java开发工具及环境设置  第2章 Java语言基础  第3章 程序流程控制  第4章 数组  第5章 字符串操作  第6章 容器类简介第二篇 面向对象技术  第7章 面向对象技术导论  第8章 对象的初始化和清理第三篇 Java编程提高篇  第9章 多线程编程  第10章 JDBC链接数据库  第11章 Java异常处理  第12章 I/O处理  第13章 Swing编程第四篇 Java分布式计算技术  第14章 Java网络编程  第15章 RMI技术  第16章 JSP技术  第17章 Java Bean技术  第18章 Servlet技术  第19章 Java与XML技术第五篇 Java编程实例篇  第20章 Java编程实例
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java完全自学手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>疯狂Java讲义精粹（第2版）
第1章　Java语言概述与开发环境	1
1.1  Java语言的发展简史	2
1.2  Java程序运行机制	4
1.2.1  高级语言的运行机制	4
1.2.2  Java程序的运行机制和JVM	4
1.3  开发Java的准备	5
1.3.1  下载和安装Java 8的JDK	5
不是说JVM是运行Java程序的虚拟机吗？那JRE和JVM的关系是怎样的呢？	6
1.3.2  设置PATH环境变量	8
为什么不安装公共JRE呢？	7
为什么选择用户变量？用户变量与系统变量有什么区别？	9
1.4  第一个Java程序	9
1.4.1  编辑Java源代码	9
1.4.2  编译Java程序	10
当编译C程序时，不仅需要指定存放目标文件的位置，也需要指定目标文件的文件名，这里使用javac编译Java程序时怎么不需要指定目标文件的文件名呢？	10
1.4.3  运行Java程序	11
1.4.4  根据CLASSPATH环境变量定位类	11
1.5  Java程序的基本规则	12
1.5.1  Java程序的组织形式	12
1.5.2  Java源文件的命名规则	13
1.5.3  初学者容易犯的错误	13
1.6  何时开始使用IDE工具	15
我想学习Java编程，到底是学习Eclipse好，还是学习NetBeans好呢？	16
1.7  本章小结	16
本章练习	16
第2章　数据类型和运算符	17
2.1  注释	18
2.1.1  单行注释和多行注释	18
2.1.2  文档注释	19
API文档是什么?	19
为什么要学习查看API文档的方法？	21
2.2  标识符和关键字	24
2.2.1  分隔符	24
2.2.2  标识符规则	25
2.2.3  Java关键字	26
2.3  数据类型分类	26
什么是变量？变量有什么用？	26
2.4  基本数据类型	27
2.4.1  整型	27
2.4.2  字符型	29
什么是字符集？	29
2.4.3  浮点型	31
2.4.4  数值中使用下画线分隔	32
2.4.5  布尔型	32
2.5  基本类型的类型转换	33
2.5.1  自动类型转换	33
2.5.2  强制类型转换	34
2.5.3  表达式类型的自动提升	35
2.6  直接量	36
2.6.1  直接量的类型	36
2.6.2  直接量的赋值	37
2.7  运算符	38
2.7.1  算术运算符	38
2.7.2  赋值运算符	40
2.7.3  位运算符	41
2.7.4  扩展后的赋值运算符	43
2.7.5  比较运算符	43
2.7.6  逻辑运算符	44
2.7.7  三目运算符	45
2.7.8  运算符的结合性和优先级	46
2.8  本章小结	47
本章练习	47
第3章　流程控制与数组	48
3.1  顺序结构	49
3.2  分支结构	49
3.2.1  if条件语句	49
3.2.2  增强后的switch分支语句	53
3.3  循环结构	54
3.3.1  while循环语句	55
3.3.2  do while循环语句	56
3.3.3  for循环	57
3.3.4  嵌套循环	59
3.4  控制循环结构	60
3.4.1  使用break结束循环	60
3.4.2  使用continue忽略本次循环剩下语句	61
3.4.3  使用return结束方法	62
3.5  数组类型	63
3.5.1  理解数组：数组也是一种类型	63
int[]是一种类型吗？怎么使用这种类型呢？	63
3.5.2  定义数组	63
3.5.3  数组的初始化	64
能不能只分配内存空间，不赋初始值呢？	64
3.5.4  使用数组	65
为什么要我记住这些异常信息？	66
3.5.5  foreach循环	66
3.6  深入数组	68
3.6.1  没有多维数组	68
我是否可以让图3.3中灰色覆盖的数组元素再次指向另一个数组？这样不就可以扩展成三维数组，甚至扩展成更多维的数组吗？	69
3.6.2  Java 8增强的工具类：Arrays	70
3.7  本章小结	73
本章练习	73
第4章　面向对象（上）	74
4.1  类和对象	75
4.1.1  定义类	75
构造器不是没有返回值吗？为什么不能用void声明呢？	77
4.1.2  对象的产生和使用	77
4.1.3  对象、引用和指针	78
4.1.4  对象的this引用	79
4.2  方法详解	83
4.2.1  方法的所属性	83
4.2.2  方法的参数传递机制	83
4.2.3  形参个数可变的方法	87
4.2.4  递归方法	88
4.2.5  方法重载	89
为什么方法的返回值类型不能用于区分重载的方法？	90
4.3  成员变量和局部变量	90
4.3.1  成员变量和局部变量	90
4.3.2  成员变量的初始化和内存中的运行机制	94
4.3.3  局部变量的初始化和内存中的运行机制	95
4.3.4  变量的使用规则	96
4.4  隐藏和封装	97
4.4.1  理解封装	97
4.4.2  使用访问控制符	97
4.4.3  package、import和import static	100
4.4.4  Java的常用包	104
4.5  深入构造器	105
4.5.1  使用构造器执行初始化	105
构造器是创建Java对象的途径，是不是说构造器完全负责创建Java对象？	106
4.5.2  构造器重载	106
为什么要用this来调用另一个重载的构造器？我把另一个构造器里的代码复制、粘贴到这个构造器里不就可以了吗？	107
4.6  类的继承	108
4.6.1  继承的特点	108
4.6.2  重写父类的方法	109
4.6.3  super限定	110
4.6.4  调用父类构造器	112
为什么我创建Java对象时从未感觉到java.lang. Object类的构造器被调用过？	114
4.7  多态	115
4.7.1  多态性	115
4.7.2  引用变量的强制类型转换	116
4.7.3  instanceof运算符	117
4.8  初始化块	118
4.8.1  使用初始化块	118
4.8.2  初始化块和构造器	120
4.8.3  静态初始化块	120
4.9  本章小结	123
本章练习	123
第5章　面向对象（下）	124
5.1  Java 8增强的包装类	125
Java为什么要对这些数据进行缓存呢?	128
5.2  处理对象	129
5.2.1  打印对象和toString方法	129
5.2.2  ==和equals方法	130
上面程序中判断obj是否为Person类的实例时，为何不用obj instanceof Person来判断呢？	134
5.3  类成员	134
5.3.1  理解类成员	134
5.3.2  单例（Singleton）类	135
5.4  final修饰符	136
5.4.1  final成员变量	136
5.4.2  final局部变量	138
5.4.3  final修饰基本类型变量和引用类型变量的区别	139
5.4.4  可执行“宏替换”的final变量	139
5.4.5  final方法	141
5.4.6  final类	142
5.5  抽象类	142
5.5.1  抽象方法和抽象类	142
5.5.2  抽象类的作用	145
5.6  Java 8改进的接口	146
5.6.1  接口的概念	146
5.6.2  Java 8中接口的定义	147
5.6.3  接口的继承	149
5.6.4  使用接口	149
5.6.5  接口和抽象类	151
5.7  内部类	152
5.7.1  非静态内部类	152
非静态内部类对象和外部类对象的关系是怎样的？	155
5.7.2  静态内部类	156
为什么静态内部类的实例方法也不能访问外部类的实例属性呢？	157
接口里是否能定义内部接口？	158
5.7.3  使用内部类	158
既然内部类是外部类的成员，那么是否可以为外部类定义子类，在子类中再定义一个内部类来重写其父类中的内部类呢？	160
5.7.4  局部内部类	160
5.7.5  Java 8改进的匿名内部类	161
5.8  Java 8新增的Lambda表达式	164
5.8.1  Lambda表达式入门	164
5.8.2  Lambda表达式与函数式接口	166
5.8.3  方法引用与构造器引用	168
5.8.4  Lambda表达式与匿名内部类的联系和区别	171
5.8.5  使用Lambda表达式调用Arrays的类方法	172
5.9  枚举类	172
5.9.1  手动实现枚举类	173
5.9.2  枚举类入门	173
5.9.3  枚举类的成员变量、方法和构造器	175
5.9.4  实现接口的枚举类	177
枚举类不是用final修饰了吗？怎么还能派生子类呢？	178
5.9.5  包含抽象方法的枚举类	178
5.10  修饰符的适用范围	179
5.11  本章小结	180
本章练习	180
第6章　Java基础类库	181
6.1  与用户互动	182
6.1.1  运行Java程序的参数	182
6.1.2  使用Scanner获取键盘输入	183
6.2  系统相关	185
6.2.1  System类	185
6.2.2  Runtime类	187
6.3  常用类	188
6.3.1  Object类	188
6.3.2  Objects类	189
6.3.3  String、StringBuffer和StringBuilder类	190
6.3.4  Math类	193
6.3.5  ThreadLocalRandom与Random	195
6.3.6  BigDecimal类	196
6.4  Java 8的日期、时间类	199
6.4.1  Date类	199
6.4.2  Calendar类	199
6.4.3  Java 8新增的日期、时间包	202
6.5  Java 8新增的日期、时间格式器	204
6.5.1  使用DateTimeFormatter完成格式化	205
6.5.2  使用DateTimeFormatter解析字符串	206
6.6  本章小结	206
本章练习	206
第7章　Java集合	207
7.1  Java集合概述	208
7.2  Collection和Iterator接口	209
7.2.1  使用Lambda表达式遍历集合	211
7.2.2  使用Java 8增强的Iterator遍历集合元素	211
7.2.3  使用Lambda表达式遍历Iterator	213
7.2.4  使用foreach循环遍历集合元素	213
7.2.5  使用Java 8新增的Predicate操作集合	214
7.2.6  使用Java 8新增的Stream操作集合	215
7.3  Set集合	217
7.3.1  HashSet类	217
hashCode()方法对于HashSet是不是十分重要？	219
7.3.2  LinkedHashSet类	221
7.3.3  TreeSet类	222
7.4  List集合	227
7.4.1  Java 8改进的List接口和ListIterator接口	227
7.4.2  ArrayList和Vector实现类	231
7.4.3  固定长度的List	231
7.5  Queue集合	232
7.5.1  PriorityQueue实现类	232
7.5.2  Deque接口与ArrayDeque实现类	233
7.5.3  LinkedList实现类	235
7.5.4  各种线性表的性能分析	236
7.6  Java 8增强的Map集合	236
7.6.1  Java 8为Map新增的方法	238
7.6.2  Java 8改进的HashMap和Hashtable实现类	239
7.6.3  LinkedHashMap实现类	242
7.6.4  使用Properties读写属性文件	243
7.6.5  SortedMap接口和TreeMap实现类	244
7.6.6  各Map实现类的性能分析	246
7.7  HashSet和HashMap的性能选项	246
7.8  操作集合的工具类：Collections	247
7.8.1  排序操作	247
7.8.2  查找、替换操作	250
7.8.3  同步控制	251
7.8.4  设置不可变集合	251
7.9  烦琐的接口：Enumeration	252
7.10  本章小结	253
本章练习	253
第8章　泛型	254
8.1  泛型入门	255
8.1.1  编译时不检查类型的异常	255
8.1.2  使用泛型	255
8.1.3  泛型的“菱形”语法	256
8.2  深入泛型	257
8.2.1　定义泛型接口、类	257
8.2.2  从泛型类派生子类	259
8.2.3  并不存在泛型类	260
8.3  类型通配符	260
8.3.1  使用类型通配符	262
8.3.2  设定类型通配符的上限	262
8.3.3  设定类型形参的上限	264
8.4  泛型方法	264
8.4.1  定义泛型方法	265
8.4.2  泛型方法和类型通配符的区别	267
8.4.3  “菱形”语法与泛型构造器	268
8.4.4  设定通配符下限	269
8.4.5  泛型方法与方法重载	271
8.4.6  Java 8改进的类型推断	272
8.5  擦除和转换	272
8.6  泛型与数组	274
8.7  本章小结	275
第9章　异常处理	276
9.1  异常概述	277
9.2  异常处理机制	278
9.2.1  使用try...catch捕获异常	278
9.2.2  异常类的继承体系	279
9.2.3  多异常捕获	282
9.2.4  访问异常信息	282
9.2.5  使用finally回收资源	283
9.2.6  异常处理的嵌套	285
9.2.7  自动关闭资源的try语句	286
9.3  Checked异常和Runtime异常体系	287
9.3.1  使用throws声明抛出异常	287
9.4  使用throw抛出异常	289
9.4.1  抛出异常	289
9.4.2  自定义异常类	290
9.4.3  catch和throw同时使用	291
9.4.4  增强的throw语句	292
9.4.5  异常链	293
9.5  Java的异常跟踪栈	294
9.6  异常处理规则	296
9.6.1  不要过度使用异常	296
9.6.2  不要使用过于庞大的try块	297
9.6.3  避免使用Catch All语句	298
9.6.4  不要忽略捕获到的异常	298
9.7  本章小结	298
本章练习	298
第10章　Annotation（注解）	299
10.1  基本Annotation	300
10.1.1  限定重写父类方法：@Override	300
10.1.2  标示已过时：@Deprecated	301
10.1.3  抑制编译器警告：@SuppressWarnings	302
10.1.4  “堆污染”警告与@SafeVarargs	302
10.1.5  Java 8的函数式接口与@FunctionalInterface	303
10.2  JDK的元Annotation	304
10.2.1  使用@Retention	304
10.2.2  使用@Target	305
10.2.3  使用@Documented	305
10.2.4  使用@Inherited	306
10.3  自定义Annotation	307
10.3.1  定义Annotation	307
10.3.2  提取Annotation信息	308
10.3.3  使用Annotation的示例	310
10.3.4  Java 8新增的重复注解	314
10.3.5  Java 8新增的Type Annotation	316
10.4  编译时处理Annotation	317
10.5  本章小结	320
第11章　输入/输出	321
11.1  File类	322
11.1.1  访问文件和目录	322
11.1.2  文件过滤器	324
11.2  理解Java的IO流	324
11.2.1  流的分类	325
11.2.2  流的概念模型	326
11.3  字节流和字符流	327
11.3.1  InputStream和Reader	327
11.3.2  OutputStream和Writer	329
11.4  输入/输出流体系	330
11.4.1  处理流的用法	330
11.4.2  输入/输出流体系	331
11.4.3  转换流	333
怎么没有把字符流转换成字节流的转换流呢？	334
11.4.4  推回输入流	334
11.5  重定向标准输入/输出	336
11.6  RandomAccessFile	337
11.7  NIO.2	340
11.7.1  Path、Paths和Files核心API	341
11.7.2  使用FileVisitor遍历文件和目录	342
11.7.3  使用WatchService监控文件变化	343
11.7.4  访问文件属性	344
11.8  本章小结	346
本章练习	346
第12章　多线程	347
12.1  线程概述	348
12.1.1  线程和进程	348
12.1.2  多线程的优势	349
12.2  线程的创建和启动	349
12.2.1  继承Thread类创建线程类	350
12.2.2  实现Runnable接口创建线程类	351
12.2.3  使用Callable和Future创建线程	352
12.2.4  创建线程的三种方式对比	354
12.3  线程的生命周期	354
12.3.1  新建和就绪状态	354
12.3.2  运行和阻塞状态	356
12.3.3  线程死亡	357
12.4  控制线程	358
12.4.1  join线程	358
12.4.2  后台线程	359
12.4.3  线程睡眠：sleep	360
12.4.4  线程让步：yield	360
12.4.5  改变线程优先级	362
12.5  线程同步	363
12.5.1  线程安全问题	363
12.5.2  同步代码块	365
12.5.3  同步方法	366
12.5.4  释放同步监视器的锁定	368
12.5.5  同步锁（Lock）	369
12.5.6  死锁	371
12.6  线程通信	372
12.6.1  传统的线程通信	372
12.6.2  使用Condition控制线程通信	376
12.6.3  使用阻塞队列（BlockingQueue）控制线程通信	378
12.7  线程池	380
12.7.1  Java 8改进的线程池	381
12.7.2  Java 8增强的ForkJoinPool	382
12.8  线程相关类	386
12.8.1  ThreadLocal类	386
12.8.2  包装线程不安全的集合	387
12.8.3  线程安全的集合类	388
12.9  本章小结	389
本章练习	389
第13章　网络编程	390
13.1  网络编程的基础知识	391
13.1.1  网络基础知识	391
13.1.2  IP地址和端口号	392
13.2  Java的基本网络支持	393
13.2.1  使用InetAddress	393
13.2.2  使用URLDecoder和URLEncoder	393
13.2.3  URL、URLConnection和URLPermission	395
13.3  基于TCP协议的网络编程	401
13.3.1  TCP协议基础	401
13.3.2  使用ServerSocket创建TCP服务器端	401
13.3.3  使用Socket进行通信	402
13.3.4  加入多线程	404
13.3.5  记录用户信息	407
13.3.6  半关闭的Socket	414
13.3.7  使用NIO实现非阻塞Socket通信	415
13.3.8  使用AIO实现非阻塞通信	420
上面程序中好像没用到④⑤号代码的get()方法的返回值，这两个地方不调用get()方法行吗？	424
13.4  使用代理服务器	427
13.4.1  直接使用Proxy创建连接	427
13.4.2  使用ProxySelector自动选择代理服务器	428
13.5  本章小结	431
本章练习	431
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>疯狂Java讲义精粹（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>疯狂Java实战演义
第1章 控制台五子棋 1
1.1 引言 2
1.1.1 五子棋介绍 2
1.1.2 输入输出约定 2
1.2 游戏流程描述 3
1.2.1 玩家输入坐标 3
1.2.2 “电脑”下棋 4
1.3 创建游戏的各个对象 4
1.3.1 Chessboard类 5
1.3.2 Chessman类 6
1.3.3 GobangGame类 6
1.4 棋盘类实现 7
1.4.1 初始化棋盘 7
1.4.2 输出棋盘 8
1.4.3 获取棋盘 9
1.5 棋子枚举类实现 9
1.6 游戏类实现 11
1.6.1 使用BufferedReader获取键盘输入 11
1.6.2 验证玩家输入字符串的合法性 12
1.6.3 判断输赢 13
.1.6.4 “电脑”随机下棋 15
1.6.5 是否重新游戏 16
1.6.6 游戏过程实现 16
1.7 本章小结 18
第2章 仿Windows计算器 19
2.1 仿Windows计算器概述 20
2.1.1 数学符号与其他符号介绍 20
2.1.2 界面说明 21
2.2 流程描述 21
2.3 建立计算器对象 22
2.3.1 MyMath工具类 22
2.3.2 CalService类 23
2.3.3 CalFrame类 24
2.4 MyMath工具类实现 24
2.5 计算器主界面 25
2.5.1 初始化界面（initialize()方法） 26
2.5.2 创建运算键 28
2.5.3 创建操作按键 29
2.5.4 增加事件监听器 30
2.6 计算业务处理 31
2.6.1 计算四则运算结果 31
2.6.2 存储操作 33
2.6.3 实现开方、求倒数等 34
2.6.4 实现回退操作 35
2.6.5 清除计算结果 35
2.6.6 实现中转方法（callMethod） 35
2.7 本章小结 36
第3章 图片浏览器 37
3.1 图片浏览器概述 38
3.2 创建图片浏览器的相关对象 38
3.2.1 文件过滤器 39
3.2.2 文件对话框 39
3.2.3 主界面类 40
3.2.4 业务处理类 40
3.2.5 操作处理类 40
3.3 创建主界面 41
3.3.1 初始化界面（init()方法） 41
3.3.2 创建菜单栏 41
3.3.3 创建工具栏 43
3.4 实现图片浏览的操作 44
3.4.1 实现工具栏单击 44
3.4.2 实现菜单的单击 47
3.4.3 打开图片 48
3.4.4 放大或者缩小图片 49
3.4.5 浏览“上一张”或“下一张”
1.6.1 图片 49
3.5 文件选择与过滤 50
3.6 本章小结 51
第4章 桌面弹球 52
4.1 桌面弹球概述 53
4.1.1 动画原理 53
4.1.2 小球反弹的方向 53
4.2 流程描述 54
4.3 创建游戏对象 54
4.3.1 基类BallComponent 55
4.3.2 砖块类（Brick） 56
4.3.3 道具类及其子类（Magic） 57
4.3.4 挡板类（Stick） 57
4.3.5 小球类（Ball） 57
4.3.6 业务处理类（BallService） 58
4.3.7 主界面类（BallFrame） 59
4.4 主界面实现 59
4.4.1 初始化界面（initialize()方法） 60
4.4.2 单态模式简介 61
4.4.3 运行效果 61
4.4.4 监听器与Timer 62
4.5 挡板、小球、砖块、道具 63
4.5.1 挡板（Stick类） 63
4.5.2 小球（Ball类） 65
4.5.3 道具（Magic及其子类） 66
4.5.4 砖块（Brick类） 67
4.6 BallService类实现 68
4.6.1 创建与设置砖块 68
4.6.2 设置挡板的位置（移动挡板） 70
4.6.3 小球与砖块碰撞 71
4.6.4 小球、道具与挡板碰撞 73
4.6.5 道具的移动 73
4.6.6 改变挡板的长度（道具的作用） 74
4.6.7 判断是否已经通关 75
4.7 功能改进设计 76
4.7.1 关卡 77
4.7.2 计分 77
4.7.3 道具 77
4.8 本章小结 78
第5章 单机俄罗斯方块 79
5.1 俄罗斯方块简介 80
5.2 建立界面 80
5.2.1 方块堆砌界面 80
5.2.2 游戏界面 80
5.3 创建游戏对象 82
5.3.1 设计小方块对象 82
5.3.2 设计大方块对象 83
5.4 创建与显示大方块 86
5.4.1 随机读取小方块图片 86
5.4.2 创建大方块对象 87
5.4.3 显示当前方块 89
5.5 处理方块的行为 91
5.5.1 方块变化 91
5.5.2 方块的左移和右移 93
5.5.3 方块下降 94
5.5.4 方块快速下降 95
5.5.5 判断是否停止下降 96
5.5.6 创建界面的二维数组 96
5.5.7 判断是否遇到障碍 98
5.5.8 方块结束下降 100
5.6 消除行、计分与级别的提升 100
5.6.1 消除行 100
5.6.2 加入分数计算与级别提升 102
5.7 游戏操作 103
5.7.1 游戏的暂停 103
5.7.2 游戏的继续 104
5.7.3 判断游戏失败 104
5.8 本章小结 104
第6章 仿Windows画图 105
6.1 画图软件概述 106
6.2 画图工具原理 106
6.2.1 画线 106
6.2.2 其他画图功能 107
6.2.3 保存图片功能 107
6.3 创建画图工具的各个对象 107
6.3.1 工具接口Tool 108
6.3.2 Tool的实现类AbstractTool 109
6.3.3 AbstractTool的子类 110
6.3.4 界面类ImageFrame 110
6.3.5 业务逻辑类ImageService 111
6.3.6 文件选择类
6.3.6 ImageFileChooser 111
6.4 主界面实现 112
6.4.1 初始化界面（init()方法） 112
6.4.2 获取画板 114
6.4.3 创建菜单 114
6.4.4 创建画图工具栏 116
6.4.5 创建颜色选择面板 118
6.5 工具实现 119
6.5.1 实现拖动边框改变画布大小 120
6.5.2 实现父类的画图方法 121
6.5.3 鼠标移动时改变指针 122
6.5.4 记录鼠标按下的位置 123
6.5.5 重绘图片 123
6.5.6 铅笔工具 124
6.5.7 直线工具、矩形工具、椭圆工具和圆角矩形工具 124
6.5.8 多边形工具 126
6.5.9 刷子与橡皮擦 128
6.5.10 喷枪工具 129
6.6 ImageService类的实现 130
6.6.1 打开图片文件 130
6.6.2 保存图片 131
6.6.3 新建图片 132
6.6.4 颜色剪辑器 133
6.6.5 文件过滤 133
6.6.6 根据对菜单的单击调用相应
1.6.1 的方法 134
6.6.7 判断图片是否已经保存 135
6.7 本章小结 135
第7章 单机连连看 136
7.1 连连看游戏简介 137
7.2 连连看游戏原理 137
7.3 创建游戏界面与游戏区域 137
7.3.1 创建游戏界面 137
7.3.2 游戏区域实现原理 138
7.3.3 创建图片方块对象 138
7.3.4 创建游戏处理类 140
7.3.5 图片的读取 140
7.3.6 创建游戏区域图片数组 143
7.3.7 根据数组画游戏区域 144
7.3.8 随机初始化游戏 145
7.4 实现连接程序 147
7.4.1 图片选择 147
7.4.2 创建连接的相关对象 149
7.4.3 准备获取通道的工具方法 151
7.4.4 没有转折点的横向连接 152
7.4.5 没有转折点的纵向连接 154
7.4.6 一个转折点的连接 155
7.4.7 两个转折点的连接 157
7.4.8 找出最短距离 162
7.4.9 画上连接线 164
7.5 加入计分与计时功能 165
7.5.1 加入计分功能 165
7.5.2 加入计时功能与游戏的胜利、失败 166
7.6 本章小结 168
第8章 简单Java IDE工具 169
8.1 IDE工具简介 170
8.2 Java IDE的主要功能 170
8.3 建立界面 170
8.3.1 建立主编辑区和信息显示区 171
8.3.2 建立项目显示区 172
8.3.3 添加菜单和工具栏 173
8.3.4 建立工作空间选择界面 176
8.3.5 建立文件、目录和项目添加界面 177
8.4 实现工作空间选择功能 178
8.4.1 实现目录选择功能 178
8.4.2 实现工作空间选择的确定按钮 181
8.5 创建项目树 182
8.5.1 创建树的各个对象 182
8.5.2 实现创建项目树的功能 184
8.5.3 设置树的外观 188
8.5.4 实现树节点的选择事件 190
8.6 实现文件操作功能 192
8.6.1 新建文件 192
8.6.2 新建目录 197
8.6.3 新建项目 198
8.6.4 策略模式 201
8.6.5 文件打开 201
8.6.6 显示行数与高亮 211
8.6.7 文件的保存功能 216
8.6.8 运行Java文件 221
8.7 实现文本操作 223
8.8 本章小结 223
第9章 图书进销存系统 224
9.1 项目简介 225
9.2 建立界面 225
9.2.1 登录界面 225
9.2.2 销售管理界面 225
9.2.3 入库管理界面 227
9.2.4 书本管理界面 227
9.2.5 种类管理界面 228
9.2.6 出版社管理界面 229
9.2.7 修改界面代码 230
9.3 设计系统数据库 233
9.3.1 设计出版社表 233
9.3.2 设计种类表 234
9.3.3 设计书表 234
9.3.4 设计入库记录表 235
9.3.5 设计销售记录表 236
9.4 开发前的准备工作 237
9.4.1 设计表的对应类 237
9.4.2 编写配置读取类 239
9.4.3 编写JDBC操作类 240
9.4.4 创建数据转换工具类 243
9.5 出版社管理功能 244
9.5.1 分层结构 244
9.5.2 获取全部出版社 245
9.5.3 模糊查询 248
9.5.4 查看出版社 250
9.5.5 新增出版社 252
9.5.6 修改出版社 255
9.6 书本管理功能 256
9.6.1 获取全部书 256
9.6.2 查看书本 258
9.6.3 新增书本 260
9.6.4 图片上传功能 261
9.7 销售管理功能 264
9.7.1 销售记录列表 264
9.7.2 查看交易记录 267
9.7.3 实现新增交易记录功能 270
9.8 本章小结 273
第10章 事务跟踪系统 274
10.1 确定系统需求 275
10.2 建立界面 275
10.2.1 登录界面 275
10.2.2 我的事务界面 276
10.2.3 事务的完成、暂时不做、不做
10.2.3 的处理界面 277
10.2.4 事务转发界面 278
10.2.5 事务管理界面 278
10.2.6 新建事务界面 279
10.2.7 用户选择界面 280
10.2.8 用户管理界面 281
10.2.9 新建用户界面 282
10.3 开发准备 282
10.3.1 数据转换工具类 282
10.3.2 数据库执行类 284
10.3.3 DAO层的基类 285
10.3.4 值对象基类 285
10.4 用户管理 286
10.4.1 设计用户管理的相关对象 286
10.4.2 用户登录 287
10.4.3 查找全部用户 290
10.4.4 新增用户功能 292
10.4.5 删除用户 293
10.4.6 查询用户 293
10.5 事务管理 294
10.5.1 设计事务对象 294
10.5.2 根据发起人查找事务 295
10.5.3 新建事务 297
10.5.4 催办事务 298
10.5.5 将事务置为无效 300
10.6 我的事务 301
10.6.1 设计其他对象 301
10.6.2 将事务设为“暂时不做”状态 302
10.6.3 将事务置为“不做”状态 305
10.6.4 完成事务 306
10.6.5 转发事务 307
10.6.6 查看事务 308
10.6.7 查询事务 310
10.7 本章小结 311
第11章 多线程下载工具 312
11.1 多线程下载工具简介 313
11.2 建立下载工具的界面 313
11.2.1 主界面 313
11.2.2 导航树 314
11.2.3 资源列表 316
11.2.4 资源信息显示 318
11.2.5 新建下载任务界面 319
11.2.6 悬浮窗口 319
11.2.7 任务栏图标 322
11.3 设计下载的相关对象 322
11.3.1 资源状态对象 322
11.3.2 块对象 323
11.3.3 资源对象 324
11.3.4 上下文对象 327
11.4 下载资源 329
11.4.1 界面新增下载资源 329
11.4.2 建立下载线程 331
11.4.3 进行文件分割 333
11.4.4 文件合并 336
11.4.5 暂停下载 337
11.4.6 继续下载 337
11.5 保存下载信息 339
11.5.1 进行序列化保存对象 339
11.5.2 反序列化 340
11.6 其他操作 341
11.6.1 查看任务 341
11.6.2 删除任务 342
11.6.3 删除已经完成的任务 343
11.6.4 开始全部任务 343
11.6.5 暂停全部任务 344
11.6.6 节点的单击 344
11.6.7 打开/关闭主窗口 345
11.7 本章小结 345
第12章 邮件客户端 346
12.1 本章涉及的技术 347
12.1.1 JavaMail简介 347
12.1.2 SMTP简介 347
12.1.3 POP3简介 347
12.1.4 XStream简介 347
12.2 建立界面 348
12.2.1 登录界面 348
12.2.2 客户端主界面 348
12.2.3 配置界面 352
12.2.4 邮件编写界面 353
12.3 创建客户端的基础对象 354
12.3.1 创建邮箱上下文对象 355
12.3.2 创建邮件对象 356
12.4 用户登录与用户配置 358
12.4.1 实现用户登录 358
12.4.2 实现用户信息配置 360
12.5 接收邮件 362
12.5.1 接收邮件 362
12.5.2 获取邮件的正文 364
12.5.3 获取邮件的收件人 365
12.5.4 获取邮件的发件人 365
12.5.5 获取邮件的发送日期 366
12.5.6 获取邮件的大小 366
12.5.7 获取邮件的抄送地址 366
12.5.8 获取附件并存放到本地的目录中 367
12.5.9 将Message封装为Mail 368
12.5.10 对邮件进行排序 369
12.5.11 删除邮件服务器上的邮件 370
12.5.12 将Mail对象转换成XML
12.5.11 文件并保存到本地目录中 371
12.5.13 在界面中显示邮件 372
12.5.14 编写任务调度器接收邮件 375
12.6 初始化界面数据 376
12.6.1 将XML文件转换为Mail对象 376
12.6.2 在各个Box间切换 378
12.7 操作邮件 380
12.7.1 查看邮件 380
12.7.2 查看附件 382
12.7.3 删除邮件 385
12.7.4 彻底删除邮件 385
12.7.5 还原邮件 386
12.8 发送邮件 387
12.8.1 实现发送邮件的功能 388
12.8.2 界面封装Mail对象进行发送 390
12.8.3 处理邮件附件 391
12.8.4 测试发送邮件功能 392
12.8.5 处理邮件的其他功能 393
12.9 本章小结 393
第13章 MySQL管理器 394
13.1 MySQL管理器原理 395
13.2 建立界面 395
13.2.1 MySQL安装目录选择界面 396
13.2.2 主界面 396
13.2.3 数据显示界面 401
13.2.4 创建连接界面 403
13.2.5 创建表界面 404
13.2.6 视图界面 407
13.2.7 存储过程界面 407
13.2.8 查询界面 408
13.2.9 树节点右键菜单 408
13.2.10 数据列表右键菜单 408
13.3 实现MySQL安装目录选择功能 410
13.3.1 实现目录选择 410
13.3.2 读取和保存安装目录路径 411
13.3.3 读取连接信息 411
13.4 连接管理 413
13.4.1 创建连接节点 413
13.4.2 打开连接 414
13.4.3 新建连接 417
13.4.4 删除连接 419
13.4.5 关闭连接 420
13.5 数据库管理 420
13.5.1 打开数据库 421
13.5.2 新建数据库 422
13.5.3 删除数据库 423
13.5.4 关闭数据库 423
13.6 视图管理 424
13.6.1 读取视图列表 424
13.6.2 新建视图 426
13.6.3 修改视图与删除视图 427
13.7 存储过程与函数管理 427
13.7.1 新增存储过程和函数 427
13.7.2 修改存储过程与函数 428
13.8 表管理 429
13.8.1 新字段 430
13.8.2 插入字段与删除字段 431
13.8.3 编辑字段 432
13.8.4 设置默认值与自动增长 434
13.8.5 新外键 435
13.8.6 删除一个外键 436
13.8.7 查询字段信息 436
13.8.8 查询外键信息 437
13.8.9 新建表 439
13.8.10 修改表 440
13.8.11 删除表 442
13.9 数据浏览 442
13.9.1 浏览数据 443
13.9.2 刷新数据 445
13.9.3 数据排序 445
13.10 执行SQL语句 446
13.10.1 运行SQL语句 446
13.10.2 保存SQL语句 447
13.11 SQL文件的导入与导出 447
13.11.1 执行SQL文件 447
13.11.2 导出数据库与表 448
13.12 本章小结 449
第14章 自己开发IoC容器 450
14.1 IoC简介 451
14.2 使用技术简介 451
14.2.1 Java反射简介 451
14.2.2 Dom4j 452
14.2.3 JUnit 452
14.3 确定配置文件内容、编写DTD 452
14.3.1 声明bean 452
14.3.2 声明单态的bean 453
14.3.3 声明延迟加载 453
14.3.4 声明设值注入到bean的属性 453
14.3.5 声明构造注入到bean的属性 454
14.3.6 自动装配 455
14.3.7 准备DTD文件 455
14.4 读取XML文件 457
14.4.1 加载XML文件 457
14.4.2 读取Element 460
14.4.3 解析Element 462
14.4.4 实现isLazy方法 464
14.4.5 实现getConstructorElements方法 465
14.4.6 实现getAttribute和isSingleton方法 465
14.4.7 实现getAutowire方法 466
14.4.8 实现getConstructorValue和getPropertyValue方法 466
14.5 使用构造注入创建实例 468
14.5.1 构造注入简介 468
14.5.2 使用无参数的构造器创建实例 468
14.5.3 使用有参数的构造器创建实例 469
14.6 实现设值注入 473
14.6.1 实现非自动装配的设值注入 473
14.6.2 实现根据名字自动装配 478
14.7 实现IoC容器 480
14.7.1 定义接口方法 481
14.7.2 实现containsBean方法和isSingleton方法 482
14.7.3 实现getBean方法 483
14.7.4 为AbstractApplicationContext添加子类 488
14.7.5 测试IoC容器的创建 490
14.8 IoC与图书进销存系统的整合 495
14.8.1 需要管理的对象 495
14.8.2 创建数据访问层的bean 496
14.8.3 创建业务层的bean 497
14.8.4 创建视图层的bean 499
14.9 本章小结 502
第15章 仿QQ游戏大厅 503
15.1 游戏大厅简介 504
15.2 编写游戏大厅框架 504
15.2.1 确定传输格式 504
15.2.2 建立处理类接口 506
15.2.3 建立玩家类与游戏接口 506
15.2.4 编写框架服务器 507
15.2.5 编写框架客户端 509
15.2.6 建立登录界面 509
15.2.7 实现登录功能 511
15.3 建立五子棋游戏大厅 512
15.3.1 编写游戏大厅的对象 512
15.3.2 服务器创建游戏大厅数组 514
15.3.3 玩家进入游戏大厅 515
15.3.4 创建游戏大厅界面 516
15.3.5 创建玩家列表与聊天界面 519
15.3.6 使用服务器的数据创建游戏大厅 520
15.4 实现聊天功能 522
15.4.1 发送聊天信息 522
15.4.2 接收聊天信息 524
15.5 启动游戏 524
15.5.1 建立游戏界面 525
15.5.2 玩家坐下 526
15.5.3 实现游戏聊天 531
15.6 开始游戏 532
15.6.1 游戏准备 532
15.6.2 玩家下棋 536
15.6.3 逃跑与认输 539
15.6.4 请求和棋 540
15.7 五子棋游戏大厅总结 541
15.8 编写一个测试聊天室 542
15.8.1 建立聊天室界面 542
15.8.2 实现聊天室 543
15.8.3 将聊天室放置到框架中测试 543
15.9 本章小结 544
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>疯狂Java实战演义
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE 7权威指南：卷1
译者序
前 言
第一部分 引言
第1章 概述 2
1.1 Java EE 7平台新增特性 3
1.2 Java EE应用模型 3
1.3 分布式多层应用 4
1.3.1 安全 4
1.3.2 Java EE组件 5
1.3.3 Java EE客户端 6
1.3.4 Web组件 7
1.3.5 业务组件 8
1.3.6 企业信息系统层 8
1.4 Java EE容器 9
1.4.1 容器服务 9
1.4.2 容器类型 10
1.5 Web服务支持 11
1.5.1 XML 12
1.5.2 SOAP传输协议 12
1.5.3 WSDL标准格式 12
1.6 Java EE应用装配与部署 12
1.7 开发角色 13
1.7.1 Java EE产品提供商 13
1.7.2 工具提供商 13
1.7.3 应用组件提供商 13
1.7.4 应用装配人员 14
1.7.5 应用部署人员和管理员 14
1.8 Java EE 7 API 15
1.8.1 EJB技术 15
1.8.2 Java Servlet技术 17
1.8.3 JSF技术 18
1.8.4 JSP技术 19
1.8.5 JSP标准标记库 19
1.8.6 Java持久化API 19
1.8.7 Java事务API 20
1.8.8 RESTful Web服务Java API 20
1.8.9 托管bean 20
1.8.10 Java EE 的上下文和依赖注入 20
1.8.11 Java的依赖注入 21
1.8.12 bean验证 21
1.8.13 Java消息服务API 21
1.8.14 Java EE连接器架构 21
1.8.15 JavaMail API 22
1.8.16 Java容器授权契约 22
1.8.17 Java容器认证服务提供者接口 22
1.8.18 WebSocket Java API 22
1.8.19 JSON处理Java API 22
1.8.20 Java EE的并发工具 23
1.8.21 Java平台的批处理应用 23
1.9 Java平台标准版7的Java EE 7 API 23
1.9.1 Java数据库互连API 23
1.9.2 Java命名和目录接口API 23
1.9.3 JavaBeans激活框架 24
1.9.4 XML处理Java API 24
1.9.5 Java XML绑定架构 24
1.9.6 XML Web服务Java API 25
1.9.7 带附件SOAP Java API 25
1.9.8 Java认证和授权服务 25
1.9.9 Java平台的公共注解 25
1.10 GlassFish服务器工具 25
第2章 使用教程示例 27
2.1 必要软件 27
2.1.1 Java EE 7软件开发包 28
2.1.2 Java平台标准版 28
2.1.3 Java EE 7教程组件 28
2.1.4 NetBeans IDE 29
2.1.5 Apache Maven 30
2.2 启动和停止GlassFish服务器 30
2.2.1 使用NetBeans IDE启动GlassFish服务器 30
2.2.2 使用NetBeans IDE停止GlassFish服务器 30
2.2.3 使用命令行启动GlassFish服务器 30
2.2.4 使用命令行停止GlassFish服务器 31
2.3 启动管理控制台 31
2.3.1 使用NetBeans IDE启动管理控制台 31
2.4 启动和停止Java DB服务器 31
2.4.1 使用NetBeans IDE启动数据库服务器 32
2.5 构建示例 32
2.6 教程示例目录结构 32
2.7 教程中的Java EE 7 Maven原型 33
2.7.1 安装教程Maven原型 33
2.8 获取教程最新更新 33
2.8.1 使用NetBeans IDE更新教程 33
2.8.2 使用命令行更新教程 34
2.9 调试Java EE应用 34
2.9.1 使用服务器日志 34
2.9.2 使用调试器 35
第二部分 平台基础知识
第3章 资源创建 38
3.1 资源和JNDI命名 38
3.2 数据源对象和连接池 39
3.3 以管理方式创建资源 40
第4章 注入 41
4.1 资源注入 41
4.2 依赖注入 42
4.3 资源注入和依赖注入的主要区别 43
第5章 打包 44
5.1 打包应用 44
5.2 打包企业bean 46
5.2.1 企业bean打包到EJB JAR模块中 46
5.2.2 企业bean打包到WAR模块中 46
5.3 打包Web归档 47
5.4 打包资源适配器归档 48
第三部分 Web层
第6章 Web应用入门 50
6.1 Web应用 50
6.2 Web应用生命周期 51
6.3 使用JSF技术的Web模块：hello1示例 52
6.3.1 使用NetBeans IDE查看hello1 Web模块 52
6.3.2 打包和部署hello1 Web模块 56
6.3.3 查看已部署的Web模块 56
6.3.4 运行已部署的hello1 Web模块 57
6.3.5 取消部署hello1 Web模块 57
6.4 使用Java Servlet技术的Web模块：hello2示例 58
6.4.1 URL映射到Web组件 58
6.4.2 检查hello2 Web模块 59
6.4.3 运行hello2示例 60
6.5 配置Web应用 61
6.5.1 设置上下文参数 61
6.5.2 声明欢迎文件 62
6.5.3 将错误映射到错误屏幕 63
6.5.4 声明资源引用 64
6.6 关于Web应用的更多信息 65
第7章 JSF技术 66
7.1 什么是JSF应用 67
7.2 JSF技术优势 68
7.3 一个简单的JSF应用 68
7.4 用户界面组件模型 70
7.4.1 用户界面组件类 70
7.4.2 组件呈现模型 72
7.4.3 转换模型 72
7.4.4 事件和监听器模型 73
7.4.5 验证模型 74
7.5 导航模型 74
7.6 JSF应用的生命周期 77
7.6.1 JSF生命周期概述 77
7.6.2 恢复视图阶段 79
7.6.3 应用请求值阶段 80
7.6.4 处理验证阶段 80
7.6.5 更新模型值阶段 80
7.6.6 调用应用阶段 81
7.6.7 呈现响应阶段 81
7.7 部分处理和部分呈现 81
7.8 关于JSF技术的更多信息 82
第8章 Facelets介绍 83
8.1 什么是Facelets 83
8.2 Facelets应用的生命周期 85
8.3 开发一个简单的Facelets应用：guessnumber-jsf示例应用 85
8.3.1 创建Facelets应用 86
8.3.2 配置应用 89
8.3.3 运行guessnumber-jsf Facelets示例 90
8.4 使用Facelets模板 91
8.5 复合组件 93
8.6 Web资源 95
8.7 可重定位资源 96
8.8 资源库契约 96
8.8.1 hello1-rlc示例应用 97
8.9 HTML5友好的标记 99
8.9.1 使用直通元素 100
8.9.2 使用直通属性 101
8.9.3 reservation示例应用 102
第9章 表达式语言 105
9.1 EL概述 105
9.2 直接和延迟计算语法 106
9.2.1 直接计算 106
9.2.2 延迟计算 107
9.3 值表达式和方法表达式 107
9.3.1 值表达式 107
9.3.2 方法表达式 111
9.3.3 lambda表达式 112
9.4 集合对象操作 112
9.5 操作符 114
9.6 保留字 115
9.7 EL表达式示例 115
9.8 关于表达式语言的更多信息 116
第10章 在Web页面中使用JSF技术 117
10.1 建立页面 117
10.2 使用HTML标记库标记为页面增加组件 118
10.2.1 常用组件标记属性 120
10.2.2 增加HTML Head和Body标记 122
10.2.3 增加表单组件 123
10.2.4 使用文本组件 123
10.2.5 使用命令组件标记完成动作和导航 127
10.2.6 使用h:graphicImage标记增加图形图像 128
10.2.7 使用h:panelGrid和h:panelGroup标记放置组件 129
10.2.8 显示选择单个值的组件 131
10.2.9 显示选择多个值的组件 132
10.2.10 使用f:selectItem和f:selectItems标记 133
10.2.11 显示选择组件的结果 135
10.2.12 使用数据绑定表组件 135
10.2.13 使用h:message和h:messages标记显示错误消息 138
10.2.14 使用h:button和h:link标记创建书签式URL 139
10.2.15 使用视图参数配置书签式URL 139
10.2.16 bookmarks示例应用 140
10.2.17 使用h:outputScript和h:outputStylesheet标记实现资源重定位 141
10.3 使用核心标记 143
第11章 使用转换器、监听器和验证器 146
11.1 使用标准转换器 146
11.1.1 转换组件值 147
11.1.2 使用DateTimeConverter 148
11.1.3 使用NumberConverter 149
11.2 在组件上注册监听器 150
11.2.1 在组件上注册值改变监听器 151
11.2.2 在组件上注册动作监听器 151
11.3 使用标准验证器 153
11.3.1 验证组件值 154
11.3.2 使用验证器标记 154
11.4 引用托管bean方法 155
11.4.1 引用完成导航的方法 156
11.4.2 引用处理动作事件的方法 156
11.4.3 引用完成验证的方法 156
11.4.4 引用处理值改变事件的方法 157
第12章 使用JSF技术开发应用 158
12.1 JSF技术中的托管bean 158
12.1.1 创建托管bean 158
12.1.2 使用EL引用托管bean 159
12.2 编写bean属性 160
12.2.1 编写绑定到组件值的属性 161
12.2.2 编写绑定到组件实例的属性 166
12.2.3 编写绑定到转换器、监听器或验证器的属性 167
12.3 编写托管bean方法 168
12.3.1 编写处理导航的方法 168
12.3.2 编写处理动作事件的方法 169
12.3.3 编写完成验证的方法 170
12.3.4 编写处理值改变事件的方法 170
第13章 结合使用Ajax和JSF技术 172
13.1 Ajax概述 173
13.2 结合JSF技术使用Ajax功能 173
13.3 结合Facelets使用Ajax 174
13.3.1 使用f:ajax标记 174
13.4 发送Ajax请求 175
13.4.1 使用event属性 175
13.4.2 使用execute属性 176
13.4.3 使用immediate属性 176
13.4.4 使用listener属性 177
13.5 在客户端监视事件 177
13.6 处理错误 177
13.7 接收Ajax响应 178
13.8 Ajax请求生命周期 179
13.9 组件分组 179
13.10 加载JavaScript资源 180
13.10.1 在Facelets应用中使用 JavaScript API  180
13.10.2 bean类中使用@Resource-Dependency注解 181
13.11 ajaxguessnumber示例应用 181
13.11.1 ajaxguessnumber源文件 181
13.11.2 运行ajaxguessnumber示例 183
13.12 关于JSF技术中Ajax的更多信息 184
第14章 复合组件：高级主题与示例 185
14.1 复合组件的属性 185
14.2 调用托管bean 186
14.3 验证复合组件值 186
14.4 compositecomponentexample示例应用 187
14.4.1 复合组件文件 187
14.4.2 使用页面 188
14.4.3 托管bean 189
14.4.4 运行compositecomponen-texample示例 189
第15章 创建定制UI组件和其他定制对象 191
15.1 确定是否需要定制组件或呈现器 192
15.1.1 何时使用定制组件 192
15.1.2 何时使用定制呈现器 193
15.1.3 组件、呈现器和标记组合 194
15.2 了解图像地图示例 195
15.2.1 为什么使用JSF技术实现图像地图 195
15.2.2 了解呈现的HTML 195
15.2.3 了解Facelets页面 196
15.2.4 配置模型数据 197
15.2.5 图像地图应用类总结 198
15.3 创建定制组件的步骤 199
15.4 创建定制组件类 199
15.4.1 指定组件族 202
15.4.2 完成编码 202
15.4.3 完成解码 204
15.4.4 允许组件属性接受表达式 204
15.4.5 保存和恢复状态 205
15.5 将呈现委托到呈现器 207
15.5.1 创建呈现器类 207
15.5.2 标识呈现器类型 208
15.6 实现事件监听器 209
15.6.1 实现值改变监听器 209
15.6.2 实现动作监听器 210
15.7 处理定制组件的事件 210
15.8 在标记库描述文件中定义定制组件标记 211
15.9 使用定制组件 212
15.10 创建和使用定制转换器 214
15.10.1 创建定制转换器 214
15.10.2 使用定制转换器 216
15.11 创建和使用定制验证器 218
15.11.1 实现验证器接口 219
15.11.2 指定定制标记 220
15.11.3 使用定制验证器 221
15.12 将组件值和实例绑定到托管bean属性 222
15.12.1 将组件值绑定到属性 223
15.12.2 将组件值绑定到隐式对象 224
15.12.3 将组件实例绑定到bean属性 225
15.13 将转换器、监听器和验证器绑定到托管bean属性 226
第16章 配置JSF应用 227
16.1 使用注解配置托管bean 228
16.1.1 使用托管bean作用域 228
16.2 应用配置资源文件 229
16.2.1 配置eager应用作用域托管bean 230
16.2.2 应用配置资源文件的顺序 230
16.3 使用Faces流 231
16.3.1 应用中打包流 233
16.3.2 最简单的流：simple-flow示例应用 233
16.3.3 checkout-module示例应用 235
16.4 配置托管bean 241
16.4.1 使用managed-bean元素 242
16.4.2 使用managed-property元素初始化属性 243
16.4.3 初始化映射和列表 248
16.5 注册应用消息 248
16.5.1 使用FacesMessage创建消息 249
16.5.2 引用错误消息 250
16.6 使用默认验证器 250
16.7 注册定制验证器 251
16.8 注册定制转换器 251
16.9 配置导航规则 252
16.10 向呈现包注册定制呈现器 254
16.11 注册定制组件 256
16.12 JSF应用的基本需求 257
16.12.1 使用Web部署描述文件配置应用 257
16.12.2 配置工程阶段 260
16.12.3 包含类、页面和其他资源 260
第17章 Java Servlet技术 261
17.1 什么是servlet 262
17.2 servlet生命周期 262
17.2.1 处理servlet生命周期事件 262
17.2.2 处理servlet错误 263
17.3 共享信息 264
17.3.1 使用作用域对象 264
17.3.2 控制对共享资源的并发访问 264
17.4 创建和初始化servlet 265
17.5 编写服务方法 265
17.5.1 从请求获取信息 266
17.5.2 构造响应 266
17.6 过滤请求和响应 267
17.6.1 编写过滤器 268
17.6.2 编写定制请求和响应 269
17.6.3 指定过滤器映射 269
17.7 调用其他Web资源 270
17.7.1 在响应中包含其他资源 271
17.7.2 控制转移到另一个Web组件 271
17.8 访问Web上下文 272
17.9 维护客户端状态 272
17.9.1 访问会话 272
17.9.2 将对象与会话关联 272
17.9.3 会话管理 272
17.9.4 会话跟踪 273
17.10 终结servlet 273
17.10.1 跟踪服务请求 274
17.10.2 通知方法关闭 274
17.10.3 创建周到的长时间运行方法 275
17.11 使用Java Servlet技术上传文件 276
17.11.1 @MultipartConfig注解 276
17.11.2 getParts和getPart方法 277
17.12 异步处理 277
17.12.1 servlet中的异步处理 277
17.12.2 等待资源 278
17.13 非阻塞I/O 280
17.13.1 使用非阻塞I/O读取大HTTP POST请求 281
17.14 协议升级处理 282
17.15 mood示例应用 284
17.15.1 mood示例应用的组件 284
17.15.2 运行mood示例 284
17.16 fileupload示例应用 285
17.16.1 fileupload示例应用的体系架构 285
17.16.2 运行fileupload示例 288
17.17 dukeetf示例应用 289
17.17.1 dukeetf示例应用的体系架构 289
17.17.2 运行dukeetf示例应用 293
17.18 关于Java Servlet技术的更多信息 294
第18章 WebSocket Java API 295
18.1 WebSocket介绍 296
18.2 在Java EE平台中创建WebSocket应用 297
18.3 可编程端点 297
18.4 注解端点 298
18.5 发送和接收消息 299
18.5.1 发送消息 299
18.5.2 接收消息 300
18.6 维护客户端状态 301
18.7 使用编码器和解码器 301
18.7.1 实现编码器将Java对象转换为WebSocket消息 301
18.7.2 实现解码器将WebSocket消息转换为Java对象 303
18.8 路径参数 304
18.9 处理错误 305
18.10 指定端点配置器类 305
18.11 dukeetf2示例应用 306
18.11.1 dukeetf2示例应用的体系架构 306
18.11.2 运行dukeetf2示例应用 309
18.12 websocketbot示例应用 310
18.12.1 websocketbot示例应用的体系架构 310
18.12.2 运行websocketbot示例应用 314
18.13 关于WebSocket的更多信息 315
第19章 JSON处理 316
19.1 JSON简介 316
19.1.1 JSON语法 316
19.1.2 JSON的使用 317
19.1.3 生成和解析JSON数据 317
19.2 Java EE平台中的JSON处理 318
19.3 使用对象模型API 319
19.3.1 从JSON数据创建对象模型 319
19.3.2 从应用代码创建对象模型 319
19.3.3 导航对象模型 320
19.3.4 将对象模型写至一个流 321
19.4 使用流API 322
19.4.1 使用解析器读取JSON数据 322
19.4.2 使用生成器写JSON数据 324
19.5 Java EE RESTful Web服务中的JSON 324
19.6 jsonpmodel示例应用 325
19.6.1 jsonpmodel示例应用的组成 325
19.6.2 运行jsonpmodel示例应用 325
19.7 jsonpstreaming示例应用 326
19.7.1 jsonpstreaming示例应用的组成 326
19.7.2 运行jsonpstreaming示例应用 326
19.8 关于JSON处理Java API的更多信息 327
第20章 Web应用国际化和本地化 328
20.1 Java平台本地化类 328
20.2 提供本地化消息和标签 329
20.2.1 建立本地化环境 329
20.2.2 设置资源包 330
20.2.3 获取本地化环消息 331
20.3 日期和数字格式化 331
20.4 字符集和编码 332
20.4.1 字符集 332
20.4.2 字符编码 332
第四部分 bean验证
第21章 bean验证介绍 334
21.1 使用bean验证约束 334
21.2 验证Null和空串 336
21.3 验证构造函数和方法 337
21.3.1 跨参数约束 338
21.3.2 标识违反参数约束 338
21.3.3 为方法返回值增加约束 338
21.4 关于bean验证的更多信息 339
第22章 bean验证：高级主题 340
22.1 创建定制约束 340
22.1.1 使用内置约束建立一个新约束 340
22.1.2 去除约束目标的二义性 341
22.2 定制验证器消息 342
22.2.1 ValidationMessages资源包 342
22.3 组合约束 342
22.3.1 定制组验证顺序 342
22.4 在类型层次体系中使用方法约束 343
22.4.1 在类型层次体系中使用方法约束的规则 344
第五部分 Java EE的上下文和依赖注入
第23章 Java EE的上下文和依赖注入介绍 346
23.1 入门 347
23.2 CDI概述 348
23.3 关于bean 349
23.4 关于CDI托管bean 350
23.5 bean作为可注入的对象 350
23.6 使用限定符 351
23.7 注入bean 352
23.8 使用作用域 352
23.9 提供bean EL名 354
23.10 增加设置和获取方法 354
23.11 Facelets页面中使用托管bean 355
23.12 使用生成器方法注入对象 355
23.13 配置CDI应用 356
23.14 对CDI托管bean使用@Post-Construct和@PreDestroy注解 356
23.14.1 使用@PostConstruct 初始化托管bean 356
23.14.2 使用@PreDestroy注解准备撤销托管bean 357
23.15 关于CDI的更多信息 357
第24章 运行基本上下文和依赖注入示例 358
24.1 simplegreeting CDI示例 358
24.1.1 simplegreeting源文件 358
24.1.2 Facelets模板和页面 359
24.1.3 运行simplegreeting示例 360
24.2 guessnumber-cdi CDI示例 361
24.2.1 guessnumber-cdi源文件 362
24.2.2 Facelets页面 366
24.2.3 运行guessnumber-CDI示例 367
第25章 Java EE的上下文和依赖注入：高级主题 369
25.1 打包CDI应用 369
25.2 CDI应用中使用替代对象 370
25.2.1 使用特殊化 371
25.3 CDI应用中使用生成器方法、生成器字段和清除器方法 372
25.3.1 使用生成器方法 372
25.3.2 使用生成器字段生成资源 373
25.3.3 使用清除器方法 373
25.4 CDI应用中使用预定义bean 374
25.5 CDI应用中使用事件 375
25.5.1 定义事件 375
25.5.2 使用观察者方法处理事件 376
25.5.3 触发事件 377
25.6 CDI应用中使用拦截器 378
25.7 CDI应用中使用装饰器 379
25.8 CDI应用中使用构造型 380
第26章 运行高级上下文和依赖注入示例 382
26.1 encoder示例：使用替代对象 382
26.1.1 Coder接口和实现 383
26.1.2 encoder Facelets页面和托管bean 383
26.1.3 运行encoder示例 385
26.2 producermethods示例：使用生成器方法选择bean实现 387
26.2.1 producermethods示例的组成 387
26.2.2 运行producermethods示例 388
26.3 producerfields示例：使用生成器字段生成资源 389
26.3.1 producerfields示例的生成器字段 389
26.3.2 producerfields实体和会话bean 391
26.3.3 producerfields Facelets页面和托管bean 392
26.3.4 运行producerfields示例 394
26.4 billpayment示例：使用事件和拦截器 395
26.4.1 PaymentEvent事件类 395
26.4.2 PaymentHandler事件监听器 396
26.4.3 billpayment Facelets页面和托管bean 396
26.4.4 LoggedInterceptor拦截器类 399
26.4.5 运行billpayment示例 400
26.5 decorators示例：装饰bean 401
26.5.1 decorators示例的组成 401
26.5.2 运行decorators示例 402
第六部分 Web服务
第27章 Web服务介绍 406
27.1 什么是Web服务 406
27.2 Web服务类型 406
27.2.1 大 Web服务 407
27.2.2 RESTful Web服务 407
27.3 确定使用何种类型的Web服务 408
第28章 用JAX-WS构建Web服务 409
28.1 使用JAX-WS创建一个简单的Web服务和客户端 410
28.1.1 JAX-WS端点的需求 411
28.1.2 编写服务端点实现类 411
28.1.3 构建、打包和部署服务 412
28.1.4 测试Web服务端点的方法 412
28.1.5 一个简单的JAX-WS应用客户端 413
28.1.6 一个简单的JAX-WS Web客户端 414
28.2 JAX-WS支持的类型 417
28.2.1 模式-Java映射 417
28.2.2 Java-模式映射 418
28.3 Web服务互操作性和JAX-WS 419
28.4 关于JAX-WS的更多信息 419
第29章 用JAX-RS构建RESTful Web服务 420
29.1 什么是RESTful Web服务 420
29.2 创建RESTful根资源类 421
29.2.1 用JAX-RS开发RESTful Web服务  421
29.2.2 JAX-RS应用概览 422
29.2.3 @Path注解和URI路径模板 424
29.2.4 响应HTTP方法和请求 425
29.2.5 使用@Consumes和@Produces定制请求和响应 428
29.2.6 抽取请求参数 430
29.2.7 配置JAX-RS应用 433
29.3 JAX-RS示例应用 434
29.3.1 创建一个简单的RESTful Web服务 434
29.3.2 rsvp示例应用 435
29.3.3 真实示例 438
29.4 关于JAX-RS的更多信息 438
第30章 用JAX-RS客户端API访问REST资源 439
30.1 客户端API概述 439
30.1.1 使用客户端API创建一个基本的客户端请求  439
30.2 JAX-RS示例应用中使用客户端API 442
30.2.1 rsvp示例应用中的客户端API 442
30.2.2 customer示例应用中的客户端API 443
30.3 客户端API的高级特性 445
30.3.1 配置客户端请求 445
30.3.2 客户端API中的异步调用 447
第31章 JAX-RS：高级主题与示例 449
31.1 资源类字段和bean属性的注解 449
31.1.1 抽取路径参数 450
31.1.2 抽取查询参数 450
31.1.3 抽取表单数据 451
31.1.4 抽取请求或响应的Java类型 451
31.2 用bean验证来验证资源数据 452
31.2.1 对资源方法使用约束注解 452
31.2.2 验证实体数据 453
31.2.3 验证异常处理和响应码 455
31.3 子资源和运行时资源解析 455
31.3.1 子资源方法 455
31.3.2 子资源定位符 456
31.4 JAX-RS与EJB技术和CDI集成 457
31.5 条件HTTP请求 458
31.6 运行时内容协商 459
31.7 结合使用JAX-RS和JAXB 460
31.7.1 使用Java对象为数据建模 462
31.7.2 从现有的XML模式定义开始 463
31.7.3 结合JAX-RS和JAXB使用JSON 465
31.8 customer示例应用 466
31.8.1 customer示例应用概述 466
31.8.2 Customer和Address实体类 466
31.8.3 CustomerService类 469
31.8.4 CustomerBean类中使用JAX-RS客户端 470
31.8.5 运行customer示例 472
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE 7权威指南：卷1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 实例技术手册
前言
第一部分 Java核心API
第一章 Java基础
第二章  对象、类和接口
第三章 输入/输出
第四章 线程
……
第二部分 图形和GUI
第十章 GUI
第十一章 图形
第十二章 打印
……
第三部分 企业级Java
第十六章 RMI
第十七章 用SQL访问数据库
第十八章 servlet和JSP
词汇表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 实例技术手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java高手真经（高级编程卷）
第1部分  准备篇第1课  构建Eclipse集成开发环境第2课  创建企业信息管理系统数据库  第2部分  Java Web企业级开发技术EJB第3课  EJB快速入门第4课  会话Bean(Session Bean)——发布JNDI服务第5课  消息驱动Bean(Message-Driven Bean)——接收JMS消息第6课  实体Bean(Entity Bean) ——Java持久化JPA第7课  实体关系映射(ORM)第8课  实体查询(JPQL和SQL查询)第9课  企业信息管理系统服务器端——开发EJB+MySQL服务器端组件	第10课  企业信息管理系统客户端——开发Struts 2+Spring+EJB架构系统  第3部分  Java Web分布式技术第11课  Java事务管理(JTA)第12课  Java验证和授权服务(JAAS)第13课  Java命名和目录服务(JNDI)第14课  Java消息服务(JMS)第15课  Java邮件服务(JavaMail)第16课  Web服务(Web Service)第17课  Java管理体系(JMX)第18课  Java连接器架构(JCA)  第4部分  Java Web开源技术与框架第19课  工作流引擎——jBPM开源工作流的使用第20课  规则引擎——Drools开源规则引擎的使用第21课  搜索引擎——Lucene开源搜索引擎的使用第22课  缓存引擎——OSChache和 Ehcache缓存引擎的使用第23课  任务调度——Quartz任务调度框架的使用第24课  身份认证——Acegi身份认证框架的使用第25课  报表服务——Eclipse BIRT、JFreeChart和Cewolf的使用第26课  系统测试——代码质量检查、单元测试、性能测试、自动构建、项目管理第27课  系统集群——集群、负载均衡和故障转移
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java高手真经（高级编程卷）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高质量Java程序设计
第1章 异常
条款1 [规则]用时间频度来确定异常情况
条款2 [规则]用不需查异常来强化方法的约定
……
第2章 代码风格
条款7 [建议]将类的属性按种类分块
条款8 [建议]将方法的实现代码按功能分块
……
第3章 内存管理
条款14 [规则]为内存分配做好准备
……
第4章 面向对象的设计
条款18 [规则]用接口代替抽象类
……
第5章 集合
条款25 [规则]通过Iterator，使用for或while循环来访问集合的元素
……
第6章 性能调整
条款30 [建议]定义完整的性能调整过程
……
附录 你是哪一类Java程序员
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高质量Java程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web 2.0架构开发与项目实战
第1部分 基础应用篇
第01章 J2EE技术框架
第02章 Java Web开发过程中实用工具的使用
第03章 Java与XML编程
第2部分 Ajax/Web 2.0应用篇
第04章 Java Script高级应用
第05章 Ajax与Web 2.0应用架构
第06章 A4J框架
第07章 DWR框架
第08章 Dojo框架
第3部分 SSH架构篇
第09章 Struts 2.1框架
第10章 Struts 2.1注解及应用整合
第11章 Spring 2框架
第12章 Hibernate 3框架
第13章 SSH构架应用整合
第4部分 Java EE篇
第14章 Java EE架构技术
第15章 EJB 3
第16章 JMS（Java Message Service）
第17章 实体Bean
第18章 JSF框架
第5部分 项目实战篇
第19章 基于JSF+EJB 3+A4J框架的网上定餐系统
第20章 飞机零部件电子商务交易平台（BCP）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web 2.0架构开发与项目实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web项目开发案例精粹
第1章　企业日常事务管理系统  1.1　开发背景  1.2　系统分析    1.2.1　需求分析    1.2.2　功能分析  1.3　系统设计    1.3.1　绘制用例图设计系统功能    1.3.2　绘制系统流程图    1.3.3　系统演示    1.3.4　开发工具和开发技术的选择    1.3.5　文件夹组织结构    1.3.6　系统相关编码规则  1.4　数据库分析与设计    1.4.1　数据库分析    1.4.2　数据库概念设计    1.4.3　数据库逻辑结构设计    1.4.4　绘制表之间关系E-R图  1.5　公共类设计    1.5.1　封装数据库操作JavaBean开发    1.5.2　分页信息类开发    1.5.3　分页辅助类开发    1.5.4　员工信息类    1.5.5　消息信息类    1.5.6　回复信息类    1.5.7　批复信息类  1.6　员工身份识别模块    1.6.1　员工身份识别表单    1.6.2　员工信息DA0层    1.6.3　完成员工身份识别    1.6.4　在首页上显示员工身份信息  1.7　消息发布模块    1.7.1　消息发布表单    1.7.2　消息信息DA0层    1.7.3　完成消息发布  1.8　消息显示模块    1.8.1 实现消息查询方法    1.8.2　显示消息列表    1.8.3　显示消息详细内容  1.9　消息回复模块    1.9.1　消息回复表单    1.9.2　回复信息DA0层    1.9.3　完成消息回复    1.9.4　显示消息回复列表  1.10　项目部署和发布    1.10.1　导入项目到MyEclipse    1.10.2　为MyEclipse整合Tomcat服务器    1.10.3　发布项目  1.11　开发技巧和难点分析    1.11.1　显示错误提示信息    1.11.2　生成分页跳转链接第2章　投票系统第3章　在线考试系统第4章　博客网站系统第5章　人力资源管理系统第6章　报价管理系统第7章　网络商城系统第8章　企业论坛系统第9章　酒店管理系统第10章　客户关系管理系统第11章　在线音乐网站第12章　商场VIP消费查询系统第13章　仓库管理系统第14章　新闻发布系统第15章　个人理财管理系统第16章　图书馆管理系统第17章　学生信息管理系统第18章　航空订票系统第19章　网上订餐系统第20章　办公自动化系统
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web项目开发案例精粹
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java项目开发案例精粹
第1章  图书馆管理系统  1.1 开发背景  1.2 系统分析  1.3 系统设计  1.4 数据库分析与设计  1.5 公共类设计  1.6 系统登录模块  1.7 主窗体模块  1.8 图书信息管理模块  1.9 开发技巧和难点分析第2章  固定资产管理系统  2.1 开发背景  2.2 系统分析  2.3 系统设计  2.4 数据库分析与设计  2.5 公共类设计  2.6 主窗体模块  2.7 资产类别管理模块  2.8 资产信息管理模块  2.9 开发技巧和难点分析第3章  超市管理系统  3.1 开发背景  3.2 系统分析  3.3 系统设计  3.4 数据库分析和设计  3.5 公共类设计  3.6 商品管理模块  3.7 仓库管理模块  3.8 销售管理模块  3.9 开发技巧和难点分析第4章  企业人事管理系统  4.1 开发背景  4.2 系统分析  4.3 系统设计  4.4 数据库分析与设计  4.5 员工日常管理  4.6 员工待遇管理  4.7 开发技巧和难点分析第5章  酒店管理系统  5.1 开发背景  5.2 系统分析  5.3 系统设计  5.4 数据库分析与设计  5.5 酒店房间管理  5.6 酒店客户入住  5.7 房间预订管理  5.8 酒店营业查询  5.9 开发技巧和难点分析第6章  小区物业管理系统  6.1 开发背景  6.2 系统分析  6.3 系统设计  6.4 数据库分析与设计  6.5 物业信息模块  6.6 物业收费录入模块  6.7 查询报表模块  6.8 开发技巧和难点分析第7章  航空票务管理系统  7.1 开发背景  7.2 系统分析  7.3 系统设计  7.4 数据库分析与设计  7.5 航班管理模块  7.6 营业网点管理模块  7.7 订单管理模块  7.8 客户端模块  7.9 开发技巧和难点分析第8章  CMS内容管理系统  8.1 开发背景  8.2 系统分析  8.3 系统设计  8.4 数据库分析与设计  8.5 文章栏目管理”  8.6 文章内容管理  8.7 文档维护管理  8.8 辅助系统功能  8.9 开发技巧和难点分析第9章  OA办公自动化系统  9.1 开发背景  9.2 系统分析  9.3 系统设计  9.4 数据库分析与设计  9.5 即时消息管理模块  9.6 日程管理模块  9.7 公告信息发布模块  9.8 通信录管理模块  9.9 开发技巧和难点分析第10章  网络商城  10.1 开发背景  10.2 系统分析  10.3 系统设计  10.4 数据库分析与设计  10.5 产品管理模块  10.6 订单管理模块  10.7 前台购买模块  10.8 发技巧和难点分析第11章  学生管理系统  11.1 需求分析  11.2 功能分析  11.3 数据库分析与设计  11.4 系统演示第12章  CRM客户管理系统  12.1 需求分析  12.2 功能分析  12.3 数据库分析与设计  12.4 系统演示第13章  进销存管理系统  13.1 需求分析  13.2 功能分析  13.3 数据库分析与设计  13.4 系统演示第14章  局域网聊天系统  14.1 需求分析  14.2 功能分析  14.3 数据库分析与设计  14.4 系统演示第15章  租赁管理系统  15.1 需求分析  15.2 功能分析  15.3 数据库分析与设计  15.4 系统演示第16章  财务管理系统  16.1 需求分析  16.2 功能分析  16.3 数据库分析与设计  16.4 系统演示第17章  公交查询管理系统  17.1 需求分析  17.2 功能分析  17.3 数据库分析与设计  17.4 系统演示第18章  公寓管理系统  18.1 需求分析  18.2 功能分析  18.3 数据库分析与设计  18.4 系统演示第19章  爱家租房信息网  19.1 需求分析  19.2 功能分析  19.3 数据库分析与设计  19.4 系统演示第20章  自助旅游信息网  20.1 需求分析  20.2 功能分析  20.3 数据库分析与设计  20.4 系统演示
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java项目开发案例精粹
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 2 核心技术 卷Ⅰ--基础知识
目 录
前言
第1章 Java入门
1.1 作为编程工具的Java
1.2Java的优点
1.3Java的关键特点
1.3.1简单
1.3.2面向对象
1.3.3分布式
1.3.4健壮
1.3.5安全
1.3.6中性结构
1.3.7可移植
1.3.8解释型
1.3.9高性能
1.3.10 多线程
1.3.11 动态
1.4Java和Internet
1.5Java简史
1.6对Java的常见误解
第2章 Java编程环境
2.1安装Java编译器及工具
2.1.1Windows用户的开发环境
2.1.2在集成开发环境中加入Core
Java文件
2.2在Java目录中游历
2.3Windows95/98/NT编程环境
2.3.1长文件名
2.3.2多窗口
2.3.3快捷键
2.3.4深入DOS外壳
2.3.5EDIT程序
2.4Java程序的编译与运行
2.5TextPad的使用
2.5.1编译和运行程序
2.5.2查找编程错误
2.6图形应用
2.7小应用程序
第3章 Java的基本编程结构
3.1 一个简单的Java程序
3.2注释
3.3数据类型
3.3.1整数
3.3.2浮点
3.3.3字符类型
3.3.4布尔类型
3.4 变量
3.5赋值和初始化
3.5.1数值类型的相互转换
3.5.2常数
3.6运算符
3.6.1幂
3.6.2递增和递减运算符
3.6.3关系和布尔运算符
3.6.4按位运算符
3.6.5括号和运算符分级
3.7字串
3.7.1连结
3.7.2子串
3.7.3字串编辑
3.7.4测试字串的相等性
3.7.5读取输入
3.7.6格式化输出
3.7.7一个抵押计算器
3.8控制流程
3.8.1块作用域
3.8.2条件语句
3.8.3不确定循环
3.8.4确定循环
3.8.5多重选择
3.8.6标签中断
3.9类方法
3.9.1类变量
3.9.2递归
3.10数组
3.10.1数组的复制
3.10.2数组作为参数使用
3.10.3数组作为返回值使用
3.10.4多维数组
第4章 对象和类
4.1面向对象编程简介
4.1.1OOP术语
4.1.2对象
4.1.3类与类的关系
4.1.4OOP与传统面向过程编程技术的对比
4.2使用现成的类
4.2.1对象变量
4.2.2Java库的GregorianCalendar类
4.2.3转换器和访问器方法
4.2.4Day类的使用
4.2.5一个日历程序
4.2.6对象作为函数参数使用
4.3开始构建自己的类
4.3.1一个Employee类
4.3.2分析Employee类
4.3.3开始使用构建器
4.3.4Employee类的方法
4.3.5访问私有数据的方法
4.3.6私有方法
4.3.7深入对象构建
4.3.8静态方法和字段
4.3.9CardDeck类
4.4 封装
4.4.1封装的使用
4.4.2编译器如何定位封装
4.4.3封装范围
4.5类设计建议
第5章 继承
5.1 继承的初期步骤
5.1.1 继承结构
5.1.2子类的使用
5.1.3具有自主性的对象：多形性
5.1.4 禁止继承：最后的类和方法
5.2造型
5.3抽象类
5.4保护访问
5.5Object： 终极超类
5.5.1矢量
5.5.2对象封装器
5.5.3大数字
5.5.4阅读HTML文档中的一个页
5.6Class类
5.7 反射
5.7.1利用反射分析类的能力
5.7.2在运行期间用反射来分析对象
5.7.3利用反射机制编写常规数组代码
5.7.4方法指针
5.8继承设计建议
第6章 接口和内部类
6.1接口
6.1.1抽象超类的使用
6.1.2接口的使用
6.1.3接口的属性
6.1.4Cloneable接口
6.1.5接口和回调
6.2内部类
6.2.1Property接口
6.2.2访问本地变量的本地类
6.2.3静态内部类
第7章 图形编程
7.1简介
7.2创建一个封闭帧
7.3终止图形程序
7.4帧布局
7.5在帧内显示信息
7.6图形对象和paintComponent方法
7.7文本与字体
7.8颜色
7.9用线描绘形状
7.10描绘矩形和椭圆
7.11填充图形
7.12绘图模式
7.13图像
第8章 事件控制
8.1事件控制基础
8.1.1示例：按的是哪个按钮？
8.1.2示例：捕获窗口事件
8.1.3适配器类
8.2AWT事件结构
8.3AWT中的语义和低级事件
8.4事件控制总结
8.5独立事件
8.5.1焦点事件
8.5.2窗口事件
8.5.3键盘事件
8.5.4鼠标事件
8.6分隔GUI和应用代码
8.7多点传送
8.8高级事件控制
8.8.1事件的消灭
8.8.2事件队列
8.8.3增添自定义事件
第9章 Swing的用户界面组件
9.1模型、视图、控制器设计范式
9.2布局管理入门
9.2.1边框布局
9.2.2面板
9.3文字输入
9.3.1文本域
9.3.2输入校验
9.3.3密码域
9.3.4文本区
9.3.5标签和标签组件
9.3.6文字选定
9.3.7文字编辑
9.4作出选择
9.4.1复选框
9.4.2单选钮
9.4.3边框
9.4.4列表
9.4.5组合框
9.5滚动条
9.5.1滚动窗格
9.5.2窗口的滚动
9.6高级布局管理
9.6.1网格布局
9.6.2框布局
9.6.3网袋布局
9.6.4gridx、gridygridwidth和gridheight
参数
9.6.5加权字段
9.6.6fill和anchor参数
9.6.7填充
9.6.8指定gridx、gridy、gridwidth和
gridheight参数的另一种方法
9.6.9不使用布局管理器
9.6.10 自定义布局管理器
9.6.11 通过顺序
9.7菜单
9.7.1菜单的构建
9.7.2响应菜单事件
9.7.3菜单项中的图标
9.7.4复选框和单选钮菜单项
9.7.5弹出式菜单
9.7.6助记符键和快捷键
9.7.7启用和禁用菜单项
9.8对话框
9.8.1选项对话框
9.8.2创建对话框
9.8.3数据交换
9.8.4文件对话框
第10章 小应用程序基础
10.1小应用程序入门
10.1.1 基础知识
10.1.2 一个简单的小应用程序
10.1.3小应用程序的测试
10.1.4 安全基础
10.1.5将应用程序转换成小应用程序
10.1.6小应用程序的存在时间
10.2 小应用程序的HTML标记及属性
10.2.1用于定位的小应用程序属性
10.2.2用于编码的小应用程序属性
10.2.3用于非Java兼容浏览器小应用程序
属性
10.2.4对象标记
10.2.5Java插件标记
10.2.6向小应用程序传递信息
10.3小应用程序中的弹出式窗口
10.4多媒体
10.4.1URL
10.4.2获取多媒体文件
10.5小应用程序的工作环境
10.5.1小应用程序之间的通信
10.5.2在浏览器中显示项目
10.5.3一个书签小应用程序
10.5.4 JAR文件
10.5.5资源
10.6Java程序
第11章 违例和调试
11.1处理错误
11.1.1违例分类
11.1.2通告由一个方法产生的违例
11.1.3如何生成违例
11.1.4创建违例类
11.2捕捉违例
11.2.1捕捉多个违例
11.2.2重新产生违例
11.2.3finally从句
11.2.4Java错误和违例控制总结
11.3使用违例时的一些建议
11.4调试技术
11.4.1一些有用的调试技巧
11.4.2断定
11.4.3捕捉AWT事件
11.4.4在图形程序中显示调试消息
11.5JDB调试工具的使用
第12章 流与文件
12.1流
12.2完整的流理论
12.2.1流过滤器的分层
12.2.2数据流
12.2.3随机存取文件流
12.2.4文本流
12.2.5写文本输出
12.2.6读文本输入
12.3ZIP文件流
12.4流在实际中的运用
12.4.1写入定界输出
12.4.2字串记号器和定界文字
12.4.3读取定界输入
12.4.4随机存取流
12.5对象流
12.5.1保存“可变类型”的对象
12.5.2对象序列文件格式
12.5.3保存对象引用的问题
12.5.4用于对象引用的输出格式
12.5.5安全问题
12.5.6版本定义
12.6文件管理
附录A Java关键字
附录B jaVadoc工具
附录C 配套光盘的安装及使用

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 2 核心技术 卷Ⅰ--基础知识
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言与XML处理教程
第一部分  XML
第一章  XML与数据
第二章  XML协议：XML-RPC与SOAP
第三章  使用XML与Java
第四章  将平面文件转换成XML 
第五章  读取XML
第二部分  SAX
第六章  SAX 
第七章  XML READER接口
第八章  SAX过滤器
第三部分  DOM
第九章  文档对象模型
第十章  用DOM建立XML文档
第十一章  DOM核心
第十二章  DOM遍历模块
第十三章  DOM输出
第四部分  JDOM
第十四章  JDOM
第十五章  JDOM模块
第五部分  XPATH/XSLT
第十六章  XPATH
第十七章  XSLT
第六部分  附录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言与XML处理教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java编程艺术
第1章 JAVA精髓
第2章 递归下降的表达式解析器
第3章 使用JAVA实现语言解释器
第4章 使用JAVA创建下载管理器
第5章 用JAVA实现E-mail客户端
第6章 使用JAVA搜索Internet
第7章 使用JAVA提交HTML
第8章 统计、图表与JAVA
第9章 金融应用中的Applet和Servlet
第10章 基于AI的问题求解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java编程艺术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JAVA无难事
CD1：Java的一些基本概念,

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JAVA无难事
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web开发实战宝典
第1部分　JSP基础　　第1章　走进JSP    1.1 JSP概述       1.1.1 什么是JSP       1.1.2 项目成功案例       1.1.3 如何学好JSP     1.2 JSP技术特征       1.2.1 跨平台       1.2.2 业务代码分离       1.2.3 组件重用       1.2.4 继承Java Servlet功能       1.2.5 预编译     1.3 Java Web服务器       1.3.1 Tomcat服务器       1.3.2 Resin服务器       1.3.3 JBoss服务器       1.3.4 WebSphere服务器       1.3.5 WebLogic服务器     1.4 MySQL数据库的下载与安装       1.4.1 下载MySQL       1.4.2 安装与配置MySQL       1.4.3 下载并安装GUI工具     1.5 MyEclipse的下载、安装与配置       1.5.1 下载MyEclipse       1.5.2 安装MyEclipse       1.5.3 配置MyEclipse       1.5.4 修改JSP编辑器编码格式       1.5.5 设置JSP文件关联编辑器       1.5.6 配置外置服务器     1.6 开发第一个JSP程序       1.6.1 编写JSP程序       1.6.2 运行JSP程序     1.7 JSP常用资源       1.7.1 JSP资源       1.7.2 Eclipse资源     1.8 本章小结 ……　第2章　掌握JSP语法　第3章　JSP内置对象　第4章　Servlet技术　第5章　JSP使用Model2实现登录模块　第2部分　高级技术　第6章　EL表达式语言　第7章　JSTL核心标签库　第8章　结合JSTL与EL技术开发通讯录模块　　第9章　JSP操作XML　第10章　JavaScript脚本语言　第11章　Ajax实现用户注册模块　第3部分　框架技术　第12章　Struts框架　　第13章　应用Struts实现网站流量　第14章　Hibernate框架　第15章　Hibernate高级应用　第16章　JSP＋Hibernate实现留言模块　　第17章　Spring框架　第18章　Spring　MVC框架　第19章　Spring＋Hibernate实现用户第4部分　实用技术　第20章　数据分页　第21章　文件上传与下载　第22章　PDF与Excel组件　第23章　E-mail组件　第24章　动态图表第5部分　项目实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web开发实战宝典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Eclipse3高级编程
第1章 Eclipse简介
1.1 安装Eclipse
1.2 第一个应用程序：Hello World
1.2.1 透视图
1.2.2 项目
1.2.3 新建一个类
1.2.4 启动
1.3 Java开发中重要的首选项
1.3.1 工作台首选项
1.3.2 已安装的JRE
1.3.3 编译器首选项
1.3.4 格式化代码
1.3.5 模板
1.4 任务和问题
1.4.1 问题
1.4.2 通用任务
1.4.3 书签
1.5 代码片断编辑测试窗
1.6 本章小结
第2章 使用Eclipse高效编程
2.1 小型帮助系统
2.1.1 系统信息
2.1.2 帮助与悬浮式帮助
2.1.3 Java信息视图
2.1.4 代码自动补全
2.1.5 修正辅助
2.1.6 Java编辑器中的简易功能
2.2 源代码导航
2.3 代码重构
2.3.1 修改类型
2.3.2 代码重构
2.4 撤销和重做
2.5 本地历史记录
2.5.1 资源比较
2.5.2 替换为历史版本
2.5.3 恢复已删除资源
2.6 本章小结
第3章 (可视化)组合艺术
3.1 安装
3.2 使用
3.3 首选项
3.4 组合
3.5 Bean及Bean属性
3.5.1 通用Bean
3.5.2 属性
3.6 布局
3.7 事件处理
3.8 本章小结
第4章 组织代码
4.1 工作台
4.2 资源
4.2.1 资源类型
4.2.2 资源存储
4.2.3 资源同步
4.2.4 导航
4.3 关联
4.4 包
4.4.1 文件夹和包
4.4.2 导航
4.4.3 层次结构
4.5 大纲视图
4.5.1 表示
4.5.2 上下文功能
4.6 搜索
4.6.1 搜索功能
4.6.2 查找和替换
4.6.3 标记
4.7 部署编辑器和视图
4.7.1 停放窗口
4.7.2 叠放窗口
……
第5章 项目1：Duke Speaks
第6章 项目开发
第7章 项目开发高级专题
第8章 SWT 库
第9章 JFace
第10章 项目2：Jukebox
第11章 Eclipse平台的插件开发
第12章 开发自己的Eclipse产品
第13章 项目3： Eclipse插件——Spell Checker
第15章 项目4：胖客户端应用程序——Hex游戏
第16章 总结与展望
附录A 一些有用的Eclipse插件
附录B 移植项目到新版本Eclipse
附录C 重要下载
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Eclipse3高级编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web开发实战1200例（第Ⅰ卷）
第1篇　基础篇　第1章　开发环境搭建　第2章　Java语言基础　第3章　HTML/CSS技术　第4章　JSP基础与内置对象　第5章　JavaBean技术　第6章　Servlet技术　第7章　过滤器与监听器技术　第8章　JSTL标签库　第9章　JavaScript技术　第10章　Ajax技术第2篇　文件管理篇　第11章　文件基本操作及文件上传下载　第12章　文件的批量管理第3篇　图像与多媒体篇　第13章　图像生成　第14章　图像操作　第15章　多媒体应用第4篇　窗体应用篇　第16章　窗口的应用　第17章　导航条的应用　第18章　表单的应用　第19章　表格的操作第5篇　操作Word、Excel、报表与打印篇　第20章　JSP操作Word　第21章　JSP操作Excel　第22章　报表与打印第6篇　综合应用篇　第23章　综合应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web开发实战1200例（第Ⅰ卷）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java核心技术(卷Ⅱ高级特性上下第10版英文版)
Chapter 1： The Java SE 8 Stream Library / Java SE 8流库　　1
1．1　From Iterating to Stream Operations / 从迭代到流操作　　2
1．2　Stream Creation / 创建流　　5
1．3　The filter， map， and flatMap Methods / filter、map和flatMap方法　　 9
1．4　Extracting Substreams and Concatenating Streams / 提取子流和连接流　　10
1．5　Other Stream Transformations / 其他流变换　　11
1．6　Simple Reductions / 简单规约　　12
1．7　The Optional Type / Optional类型　　13
1．7．1　How to Work with Optional Values / 如何使用Optional值　　14
1．7．2　How Not to Work with Optional Values / 不使用Optional值会有什么问题　　15
1．7．3　Creating Optional Values / 创建Optional值　　16
1．7．4　Composing Optional Value Functions with flatMap / 使用flatMap组合Optional值函数　　16
1．8　Collecting Results / 收集结果　　19
1．9　Collecting into Maps / 收集到Map中　　24
1．10　Grouping and Partitioning / 分组与分区　　28
1．11　Downstream Collectors / 下游的收集器　　29
1．12　Reduction Operations / 规约操作　　33
1．13　Primitive Type Streams / 基本类型的流　　36
1．14　Parallel Streams / 并行流　　41
Chapter 2： Input and Output / 输入与输出　　47
2．1　Input/Output Streams / 输入/输出流　　48
2．1．1　Reading and Writing Bytes / 读写字节　　 48
2．1．2　The Complete Stream Zoo / 流谱系概览　　51
2．1．3　Combining Input/Output Stream Filters / 组合输入/输出流过滤器　　 55
2．2　Text Input and Output / 文本输入与输出　　60
2．2．1　How to Write Text Output / 输出文本　　 60
2．2．2　How to Read Text Input / 输入文本　　62
2．2．3　Saving Objects in Text Format / 以文本格式保存对象　　63
2．2．4　Character Encodings / 字符编码　　67
2．3　Reading and Writing Binary Data / 读写二进制数据　　69
2．3．1　The DataInput and DataOutput interfaces / DataInput和DataOutput接口　　69
2．3．2　Random-Access Files / 随机访问文件　　72
2．3．3　ZIP Archives / ZIP文档　　77
2．4　Object Input/Output Streams and Serialization / 对象输入/输出流与序列化　　80
2．4．1　Saving and Loading Serializable Objects / 序列化对象的保存与加载　　80
2．4．2　Understanding the Object Serialization File Format / 理解对象序列化文件格式　　 85
2．4．3　Modifying the Default Serialization Mechanism / 修改默认的序列化机制　　92
2．4．4　Serializing Singletons and Typesafe Enumerations / 序列化单例和类型安全的枚举　　94
2．4．5　Versioning / 版本管理　　95
2．4．6　Using Serialization for Cloning / 将序列化用于克隆　　98
2．5　Working with Files / 处理文件　　100
2．5．1　Paths / 路径　　101
2．5．2　Reading and Writing Files / 读写文件　　104
2．5．3　Creating Files and Directories / 创建文件与目录　　105
2．5．4　Copying， Moving， and Deleting Files / 复制、移动和删除文件　　 106
2．5．5　Getting File Information / 获取文件信息　　108
2．5．6　Visiting Directory Entries / 访问目录条目　　 110
2．5．7　Using Directory Streams / 使用目录流　　 111
2．5．8　ZIP File Systems / ZIP文件系统　　115
2．6　Memory-Mapped Files / 内存映射文件　　116
2．6．1　Memory-Mapped File Performance / 内存映射文件的性能　　 116
2．6．2　The Buffer Data Structure / 缓冲区数据结构　　124
2．6．3　File Locking / 文件锁　　126
2．7　Regular Expressions / 正则表达式　　128
Chapter 3： XML　　143
3．1　Introducing XML / XML简介　　144
3．1．1　The Structure of an XML Document / XML文档的结构　　146
3．2　Parsing an XML Document / 解析XML文档　　149
3．3　Validating XML Documents / 验证XML文档　　162
3．3．1　Document Type Definitions / 文档类型定义　　163
3．3．2　XML Schema / XML模式　　172
3．3．3　A Practical Example / 实用示例　　175
3．4　Locating Information with XPath / 使用XPath定位信息　　 190
3．5　Using Namespaces / 使用命名空间　　196
3．6　Streaming Parsers / 流解析器　　199
3．6．1　Using the SAX Parser / 使用SAX解析器　　199
3．6．2　Using the StAX Parser / 使用StAX解析器　　205
3．7　Generating XML Documents / 生成XML文档　　208
3．7．1　Documents without Namespaces / 不带命名空间的文档　　 209
3．7．2　Documents with Namespaces / 带命名空间的文档　　 209
3．7．3　Writing Documents / 写文档　　210
3．7．4　An Example： Generating an SVG File / 示例：生成SVG文件　　 211
3．7．5　Writing an XML Document with StAX / 使用StAX写XML文档　　214
3．8　XSL Transformations / XSL转换　　222
Chapter 4： Networking / 网络　　233
4．1　Connecting to a Server / 连接到服务器　　233
4．1．1　Using Telnet / 使用Telnet　　233
4．1．2　Connecting to a Server with Java / 使用Java连接到服务器　　236
4．1．3　Socket Timeouts / 套接字超时　　238
4．1．4　Internet Addresses / 因特网地址　　239
4．2　Implementing Servers / 实现服务器　　241
4．2．1　Server Sockets / 服务器套接字　　242
4．2．2　Serving Multiple Clients / 为多个客户端服务　　245
4．2．3　Half-Close / 半关闭　　249
4．3　Interruptible Sockets / 可中断套接字　　250
4．4　Getting Web Data / 获取Web数据　　257
4．4．1　URLs and URIs / URL和URI　　257
4．4．2　Using a URLConnection to Retrieve Information / 使用URLConnection获取信息　　259
4．4．3　Posting Form Data / 提交表单数据　　267
4．5　Sending E-Mail / 发送电子邮件　　277
Chapter 5： Database Programming / 数据库编程　　281
5．1　The Design of JDBC / JDBC的设计　　282
5．1．1　JDBC Driver Types / JDBC驱动程序分类　　283
5．1．2　Typical Uses of JDBC / JDBC的典型用法　　284
5．2　The Structured Query Language / 结构化查询语言　　285
5．3　JDBC Configuration / JDBC配置　　291
5．3．1　Database URLs / 数据库URL　　292
5．3．2　Driver JAR Files / 驱动程序JAR文件　　292
5．3．3　Starting the Database / 启动数据库　　293
5．3．4　Registering the Driver Class / 注册驱动程序类　　294
5．3．5　Connecting to the Database / 连接到数据库　　294
5．4　Working with JDBC Statements / 使用JDBC语句　　297
5．4．1　Executing SQL Statements / 执行SQL语句　　298
5．4．2　Managing Connections， Statements， and Result Sets / 管理连接、语句和结果集　　301
5．4．3　Analyzing SQL Exceptions / 分析SQL异常　　302
5．4．4　Populating a Database / 填充数据库　　 305
5．5　Query Execution / 执行查询　　309
5．5．1　Prepared Statements / 预备语句　　309
5．5．2　Reading and Writing LOBs / 读写LOB　　 316
5．5．3　SQL Escapes / SQL转义　　318
5．5．4　Multiple Results / 多结果集　　319
5．5．5　Retrieving Autogenerated Keys / 获取自动生成的主键　　320
5．6　Scrollable and Updatable Result Sets / 可滚动和可更新的结果集　　321
5．6．1　Scrollable Result Sets / 可滚动的结果集　　321
5．6．2　Updatable Result Sets / 可更新的结果集　　324
5．7　Row Sets / 行集　　328
5．7．1　Constructing Row Sets / 构建行集　　 329
5．7．2　Cached Row Sets / 缓存的行集　　329
5．8　Metadata / 元数据　　333
5．9　Transactions / 事务　　344
5．9．1　Programming Transactions with JDBC / 使用JDBC编程实现事务　　 344
5．9．2　Save Points / 保存点　　345
5．9．3　Batch Updates / 批量更新　　345
5．10　Advanced SQL Types / 高级SQL类型　　347
5．11　Connection Management in Web and Enterprise Applications / Web与企业应用中的连接管理　　349
Chapter 6： The Date and Time API / 日期与时间API　　351
6．1　The Time Line / 时间线　　352
6．2　Local Dates / 本地日期　　355
6．3　Date Adjusters / 日期调整　　358
6．4　Local Time / 本地时间　　360
6．5　Zoned Time / 时区时间　　361
6．6　Formatting and Parsing / 格式化与解析　　365
6．7　Interoperating with Legacy Code / 与遗留代码互操作　　 369
Chapter 7： Internationalization / 国际化　　371
7．1　Locales / 地域　　372
7．2　Number Formats / 数字格式　　378
7．3　Currencies / 货币　　384
7．4　Date and Time / 日期与时间　　385
7．5　Collation and Normalization / 排序规则与标准化　　393
7．6　Message Formatting / 消息格式化　　400
7．6．1　Formatting Numbers and Dates / 格式化数字和日期　　 400
7．6．2　Choice Formats / choice格式化选项　　402
7．7　Text Input and Output / 文本输入与输出　　404
7．7．1　Text Files / 文本文件　　405
7．7．2　Line Endings / 文本行结尾符号　　405
7．7．3　The Console / 控制台　　405
7．7．4　Log Files / 日志文件　　406
7．7．5　The UTF-8 Byte Order Mark / UTF-8字节顺序标记　　406
7．7．6　Character Encoding of Source Files / 源文件的字符编码　　407
7．8　Resource Bundles / 资源包　　408
7．8．1　Locating Resource Bundles / 定位资源包　　409
7．8．2　Property Files / 属性文件　　410
7．8．3　Bundle Classes / 包类　　411
7．9　A Complete Example / 完整示例　　413
Chapter 8： Scripting， Compiling， and Annotation Processing / 脚本、编译与注解处理　　429
8．1　Scripting for the Java Platform / Java平台的脚本　　430
8．1．1　Getting a Scripting Engine / 获得脚本引擎　　430
8．1．2　Script Evaluation and Bindings / 脚本求值与绑定　　431
8．1．3　Redirecting Input and Output / 重定向输入与输出　　434
8．1．4　Calling Scripting Functions and Methods / 调用脚本函数和方法　　435
8．1．5　Compiling a Script / 编译脚本　　437
8．1．6　An Example： Scripting GUI Events / 示例：用脚本处理GUI事件　　 437
8．2　The Compiler API / 编译器API　　443
8．2．1　Compiling the Easy Way / 编译的简单使用方法　　443
8．2．2　Using Compilation Tasks / 使用编译任务　　 443
8．2．3　An Example： Dynamic Java Code Generation / 示例：动态Java代码生成　　 449
8．3　Using Annotations / 使用注解　　455
8．3．1　An Introduction into Annotations / 注解简介　　455
8．3．2　An Example： Annotating Event Handlers 示例：注解事件处理程序　　457
8．4　Annotation Syntax / 注解语法　　462
8．4．1　Annotation Interfaces / 注解接口　　462
8．4．2　Annotations / 注解　　464
8．4．3　Annotating Declarations / 在声明的地方使用注解　　466
8．4．4　Annotating Type Uses / 在类型使用的地方使用注解　　 467
8．4．5　Annotating 　this / 对this做注解　　468
8．5　Standard Annotations / 标准注解　　470
8．5．1　Annotations for Compilation / 用于编译的注解　　471
8．5．2　Annotations for Managing Resources / 用于管理资源的注解　　 472
8．5．3　Meta-Annotations / 元注解　　472
8．6　Source-Level Annotation Processing / 源码级注解处理　　475
8．6．1　Annotation Processors / 注解处理器　　476
8．6．2　The Language Model API / 语言模型API　　476
8．6．3　Using Annotations to Generate Source Code / 使用注解生成源代码　　 477
8．7　Bytecode Engineering / 字节码引擎　　481
8．7．1　Modifying Class Files / 修改类文件　　481
8．7．2　Modifying Bytecodes at Load Time / 在加载时修改字节码　　486
Chapter 9： Security / 安全　　491
9．1　Class Loaders / 类加载器　　492
9．1．1　The Class Loading Process / 类加载流程　　492
9．1．2　The Class Loader Hierarchy / 类加载器层次结构　　494
9．1．3　Using Class Loaders as Namespaces / 将类加载器作为命名空间　　496
9．1．4　Writing Your Own Class Loader / 编写自己的类加载器　　 497
9．1．5　Bytecode Verification / 字节码验证　　504
9．2　Security Managers and Permissions / 安全管理器与权限　　509
9．2．1　Permission Checking / 权限检查　　509
9．2．2　Java Platform Security / Java平台安全　　510
9．2．3　Security Policy Files / 安全策略文件　　514
9．2．4　Custom Permissions / 定制权限　　522
9．2．5　Implementation of a Permission Class / 实现权限类　　524
9．3　User Authentication / 用户认证　　530
9．3．1　The JAAS Framework / JAAS框架　　531
9．3．2　JAAS Login Modules / JAAS登录模块　　537
9．4　Digital Signatures / 数字签名　　546
9．4．1　Message Digests / 消息摘要　　547
9．4．2　Message Signing / 消息签名　　550
9．4．3　Verifying a Signature / 验证签名　　553
9．4．4　The Authentication Problem / 认证问题　　556
9．4．5　Certificate Signing / 证书签名　　558
9．4．6　Certificate Requests / 证书请求　　560
9．4．7　Code Signing / 代码签名　　561
9．5　Encryption / 加密　　567
9．5．1　Symmetric Ciphers / 对称密码　　567
9．5．2　Key Generation / 生成密钥　　569
9．5．3　Cipher Streams / 加密流　　574
9．5．4　Public Key Ciphers / 公钥密码　　575
Chapter 10： Advanced Swing / 高级Swing　　581
10．1　Lists / 列表　　582
10．1．1　The JList Component / JList组件　　582
10．1．2　List Models / 列表模式　　588
10．1．3　Inserting and Removing Values / 插入和移除值　　593
10．1．4　Rendering Values / 值的绘制　　595
10．2　Tables / 表　　599
10．2．1　A Simple Table / 简单表　　600
10．2．2　Table Models / 表模式　　604
10．2．3　Working with Rows and Columns / 行列操作　　608
10．2．3．1　Column Classes / 列类　　 609
10．2．3．2　Accessing Table Columns / 访问表列　　610
10．2．3．3　Resizing Columns / 调整列　　611
10．2．3．4　Resizing Rows / 调整行　　612
10．2．3．5　Selecting Rows， Columns， and Cells / 选择行、列和单元格　　612
10．2．3．6　Sorting Rows / 对行进行排序　　614
10．2．3．7　Filtering Rows / 对行进行过滤　　 615
10．2．3．8　Hiding and Displaying Columns / 隐藏或显示列　　617
10．2．4　Cell Rendering and Editing / 单元格的绘制与编辑　　626
10．2．4．1　Rendering Cells / 绘制单元格　　626
10．2．4．2　Rendering the Header / 绘制表头　　627
10．2．4．3　Editing Cells / 编辑单元格　　628
10．2．4．4　Custom Editors / 定制编辑器　　629
10．3　Trees / 树　　639
10．3．1　Simple Trees / 简单的树　　640
10．3．2　Editing Trees and Tree Paths / 编辑树和树路径　　650
10．3．3　Node Enumeration / 节点枚举　　659
10．3．4　Rendering Nodes / 渲染节点　　661
10．3．5　Listening to Tree Events / 监听树事件　　664
10．3．6　Custom Tree Models / 定制树模型　　671
10．4　Text Components / 文本组件　　681
10．4．1　Change Tracking in Text Components / 跟踪文本组件的内容修改　　682
10．4．2　Formatted Input Fields / 将输入的信息格式化　　 685
10．4．2．1　Integer Input / 整型输入　　686
10．4．2．2　Behavior on Loss of Focus / 丢失焦点时行为　　687
10．4．2．3　Filters / 过滤器　　688
10．4．2．4　Verifiers / 验证器　　690
10．4．2．5　Other Standard Formatters / 其他标准的格式化器　　691
10．4．2．6　Custom Formatters / 定制格式化器　　693
10．4．3　The JSpinner Component / JSpinner组件　　703
10．4．4　Displaying HTML with the JEditorPane / 使用JEditorPane显示HTML　　712
10．5　Progress Indicators / 进度指示器　　719
10．5．1　Progress Bars / 进度条　　719
10．5．2　Progress Monitors / 进度监视器　　722
10．5．3　Monitoring the Progress of Input Streams / 监视输入流的进度　　 726
10．6　Component Organizers and Decorators / 组件组织器和装饰器　　 731
10．6．1　Split Panes / 分割面板　　732
10．6．2　Tabbed Panes / 选项卡面板　　735
10．6．3　Desktop Panes and Internal Frames / 桌面面板与内部框体　　 741
10．6．3．1　Displaying Internal Frames / 显示内部框体　　 741
10．6．3．2　Cascading and Tiling / 级联与平铺　　 744
10．6．3．3　Vetoing Property Settings / 否决属性设置　　748
10．6．3．4　Dialogs in Internal Frames / 内部框体中的对话框　　 750
10．6．3．5　Outline Dragging / 拖曳概述　　 751
10．6．4　Layers / 层次　　760
Chapter 11： Advanced AWT /高级AWT　　765
11．1　The Rendering Pipeline / 绘制图形的流程　　766
11．2　Shapes / 形状　　769
11．2．1　The Shape Class Hierarchy / Shape类层次结构　　769
11．2．2　Using the Shape Classes / 使用各种Shape类　　772
11．3　Areas / 区域　　786
11．4　Strokes / 画笔　　788
11．5　Paint / 着色　　797
11．6　Coordinate Transformations / 坐标变换　　799
11．7　Clipping / 剪切　　805
11．8　Transparency and Composition / 透明与组合　　 807
11．9　Rendering Hints / 绘图提示　　817
11．10　Readers and Writers for Images / 图像的读者类和写者类　　823
11．10．1　Obtaining Readers and Writers for Image File Types / 获得图像文件类型的读者类和写者类　　 824
11．10．2　Reading and Writing Files with Multiple Images / 多图文件的读写　　825
11．11　Image Manipulation / 图像处理　　834
11．11．1　Constructing Raster Images / 构建光栅图像　　835
11．11．2　Filtering Images / 图像过滤　　842
11．12　Printing / 打印　　851
11．12．1　Graphics Printing / 图形打印　　852
11．12．2　Multiple-Page Printing / 打印多页文件　　 862
11．12．3　Print Preview / 打印预览　　864
11．12．4　Print Services / 打印服务　　874
11．12．5　Stream Print Services / 流打印服务　　878
11．12．6　Printing Attributes / 打印属性　　879
11．13　The Clipboard / 剪贴板　　887
11．13．1　Classes and Interfaces for Data Transfer / 用于数据传输的类和接口　　 888
11．13．2　Transferring Text / 传输文本　　888
11．13．3　The Transferable Interface and Data Flavors / Transferable接口和数据的类型　　892
11．13．4　Building an Image Transferable / 构建可传输的图像　　894
11．13．5　Transferring Java Objects via the System Clipboard / 通过系统剪贴板传输Java对象　　 898
11．13．6　Using a Local Clipboard to Transfer Object References / 使用本地剪贴板传输对象引用　　 902
11．14　Drag and Drop / 拖放　　903
11．14．1　Data Transfer Support in Swing / Swing对数据传输的支持　　 904
11．14．2　Drag Sources / 拖曳源　　909
11．14．3　Drop Targets / 放置目标　　912
11．15　Platform Integration / 平台集成　　921
11．15．1　Splash Screens / 闪屏　　921
11．15．2　Launching Desktop Applications / 启动桌面应用程序　　 927
11．15．3　The System Tray / 系统托盘　　932
Chapter 12： Native Methods / 本地方法　　939
12．1　Calling a C Function from a Java Program / 从Java程序中调用C函数　　 940
12．2　Numeric Parameters and Return Values / 数值参数与返回值　　947
12．3　String Parameters / 字符串参数　　949
12．4　Accessing Fields / 访问字段　　956
12．4．1　Accessing Instance Fields / 访问实例字段　　 956
12．4．2　Accessing Static Fields / 访问静态字段　　 960
12．5　Encoding Signatures / 编码签名　　961
12．6　Calling Java Methods / 调用Java方法　　963
12．6．1　Instance Methods / 实例方法　　963
12．6．2　Static Methods / 静态方法　　964
12．6．3　Constructors / 构造器　　965
12．6．4　Alternative Method Invocations / 其他调用方法的手段　　966
12．7　Accessing Array Elements / 访问数组元素　　970
12．8　Handling Errors / 处理错误　　974
12．9　Using the Invocation API / 使用Invocation API　　980
12．10　A Complete Example： Accessing the Windows Registry / 完整示例：访问Windows注册表　　985
12．10．1　Overview of the Windows Registry / Windows注册表简介　　 985
12．10．2　A Java Platform Interface for Accessing the Registry / 访问注册表的Java平台接口　　987
12．10．3　Implementation of Registry Access Functions as Native Methods / 以本地方法方式实现注册表访问功能　　988
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java核心技术(卷Ⅱ高级特性上下第10版英文版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java高级编程
第一部分　像Java开发人员一样思考第2章　用于开发Java解决方案的各种工具和技术第3章　Java开发模式第二部分　对Java API、工具和技术的广泛理解第4章　使用JFC开发高效的用户界面第5章　使用文件持久保存应用程序第6章　使用数据库持久保存应用程序第7章　使用模型1体系结构开发Web应用程序第8章　使用模型2体系结构开发Web应用程序第9章　使用Java本机接口与C/C++交互第10章　EJB 3和Java持久性API第11章　在Java组件和其他平台的组件之间通信第12章　面向服务的集成第13章　Java安全性第14章　打包和部署Java应用程序
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java高级编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计教程（上册 基础篇）
出版者的话
专家指导委员会
译者序
前言
第1章 计算机、Internet和Web
第2章 Java应用程序
第3章 Java applet
第4章 控制结构（第1部分）
第5章 控制结构（第2部分）
第6章 方法
第7章 数组
第8章 基于对象的编程
第9章 面向对象的编程
第10章 字符串
第11章 图形和Java2D
第12章 基本图形用户界面构件
第13章 高级图形用户界面构件
第14章 例外处理
第15章 多线程
附录
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计教程（上册 基础篇）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE 7精粹
目录
第1章 Java EE	1
1.1 简介	1
1.1.1 拥抱HTML5	2
1.1.2 更高的生产力	2
1.1.3 企业级需求	3
1.2 可交付成果	3
1.2.1 规范（Specification）	3
1.2.2 参考实现（RI）	3
1.2.3 技术兼容包（TCK）	3
1.2.4 Web技术	3
1.2.5 企业技术	4
1.2.6 平台1.1	4
1.2.7 Web服务技术	5
1.2.8 管理和安全技术	5
1.3 Java EE 7有什么新功能	7
1.3.1 新的规范	7
1.3.2 更新的规范	8
第2章 Servlets	12
2.1 WebServlet	12
2.2 Servlet过滤器	17
2.3 事件监听器	18
2.4 异步支持	21
2.5 非阻塞I/O	23
2.6 Web Fragment	24
2.7 安全	26
2.8 资源打包	29
2.9 错误映射	30
2.10 Handling Multipart Requests	31
2.11 Upgrade Processing	32
第3章 JSF	34
3.1 Facelets	35
3.2 资源处理	38
3.3 复合组件	39
3.4 请求处理生命周期阶段	42
3.4.1 恢复视图	42
3.4.2 接受请求值	43
3.4.3 处理验证	43
3.4.4 更新模型值	43
3.4.5 调用应用	43
3.4.6 渲染响应	43
3.5 Ajax	44
3.6 HTTP GET	47
3.7 服务器和客户端扩展点	48
3.7.1 转换器	48
3.7.2 校验器	49
3.7.3 监听器	50
3.7.4 行为	50
3.8 验证数据	51
3.9 导航规则	52
3.10 Faces Flow	52
3.11 资源库契约	58
3.12 Passthrough属性和HTML5友好的标记	60
3.13 组件标签	61
第4章 REST式的Web服务	74
4.1 资源	74
4.2 绑定HTTP方法	78
4.3 多种资源表述	80
4.4 绑定请求到资源	81
4.5 实体Provider	83
4.6 客户端API	85
4.7 映射异常	88
4.8 过滤器和实体拦截器	89
4.8.1 过滤器	89
4.8.2 实体拦截器	93
4.9 资源验证	94
第5章 基于SOAP的Web服务	97
5.1 Web服务端点	98
5.2 基于Provider的动态端点	101
5.3 基于端点的端点	102
5.4 Web服务客户端	103
5.5 基于Dispatch的动态客户端	105
5.6 Handler	106
第6章 JSON-P	110
6.1 流式API	111
6.1.1 使用流式API消费JSON	111
6.1.2 使用流式API生产JSON	113
6.2 对象模型API	115
6.2.1 使用对象模型API消费JSON	115
6.2.2 使用对象模型API生产JSON	116
第7章 WebSocket	119
7.1 注解式服务器端点	120
7.2 编程式服务器端点	125
7.3 注释式客户端端点	130
7.4 编程式客户端端点	132
7.5 JavaScriptWebSocket客户端	134
7.6 编码器和解码器	136
7.7 与Java EE安全集成	139
第8章 EJB	141
8.1 有状态会话Bean	141
8.2 无状态会话Bean	144
8.3 单例会话Bean	146
8.4 生命周期事件回调	147
8.5 消息驱动Bean	150
8.6 可移植的全局JNDI名称	152
8.7 事务	153
8.8 异步调用	154
8.9 定时器	155
8.10 嵌入式API	159
8.11 EJB精简版	160
第9章 上下文和依赖注入	162
9.1 探测Bean	162
9.2 注入点	165
9.3 Qualifier和Alternative	166
9.4 生产者和处置者	168
9.5 拦截器	169
9.6 装饰器	173
9.7 作用域和上下文	174
9.8 构造型	175
9.9 事件	177
9.10 可移植的扩展	178
9.11 内置Bean	180
9.12 生命周期回调	181
第10章 并发工具包	182
10.1 异步任务	182
10.2 计划任务	187
10.3 托管线程	190
10.4 动态上下文对象	191
第11章 Bean验证	195
11.1 内置的约束	195
11.2 自定义的约束	199
11.3 验证组	202
11.4 方法和构造子约束	203
第12章 Java事务	206
12.1 用户管理的事务	206
12.2 容器管理事务	207
12.3 @TransactionScoped	209
第13章 Java持久化	210
13.1 实体	210
13.2 持久化单元、持久化上下文和实体管理器	213
13.3 生成Schema	217
13.4 创建、读取、更新和删除实体	220
13.5 实体监听器	223
13.6 存储过程	226
13.7 验证实体	227
13.8 事务和锁	230
13.9 缓存	232
第14章 消息服务	234
14.1 发送消息	237
14.2 同步接收消息	241
14.3 异步接收消息	243
14.4 服务的质量	244
14.5 临时Destination	245
第15章 批处理	246
15.1 面向块的处理	247
15.1.1 自定义检查点	252
15.1.2 异常处理	253
15.2 Batchlet处理	253
15.3 监听器	254
15.4 作业顺序	256
15.4.1 Flow	257
15.4.2 Split	257
15.4.3 Decision	258
15.5 作业分区	259
第16章 构建端到端的应用	263
16.1 介绍	263
16.2 问题陈述	264
16.3 示例走查	266
16.4 显示订票（JSF）	270
16.5 聊天室（WebSocket的Java API）	277
16.6 查看和删除影片（JAX-RS）	283
16.7 添加电影（JSON-P）	288
16.8 售票（Java平台的批处理应用）	294
16.9 电影点（Java消息服务2）	301
16.10 结论	306
16.11 故障排除	308
16.12 完整的解决方案	308
附录A 补充书目	309
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE 7精粹
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 2入门经典
译者序
原作者序
前言
1 介绍Java
2 程序、数据、变量和计算
3 循环与逻辑
4 数组和字符串
5 定义类
6 扩展类和继承
7 异常
8 流、文件和流输出
9 流输入与对象流
10 实用类
11 线程
……
附录A 安装
附录B Java文档――JAR文件
……
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 2入门经典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计经典300例
第一篇 基 础 篇
第1 章 Java 语言基础...............................................................................................1
实例001 输出“HelloWorld”语句...........................................................1
难度指数 ★☆☆☆☆☆ 占用时间 􀁪○○
实例002 用“*”直接输出三角形......................................................3
难度指数 ★☆☆☆☆☆ 占用时间 􀁪○○
实例003 可爱的符号表情................................................................3
难度指数 ★☆☆☆☆☆ 占用时间 􀁪○○
实例004 计算机支持的最大整数值是多少..........................................4
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例005 获取浮点类型的最大最小值.......................................................5
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例006 常见字母的大小写转换.........................................................7
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例007 实现基本类型的类型转换........................................................9
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例008 判断一个数字的奇偶性....................................................... 11
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例009 不借助第三者实现两个变量值的互换................................................ 12
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例010 实现输入字符的加密和解密..................................................... 13
难度指数 ★★★★☆☆ 占用时间 􀁪○○
第2 章 Java 流程控制................................................................15
实例011 判断某一年是否为闰年...................................................... 15
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例012 验证用户登录信息....................................................................... 17
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例013 QQ 等级活跃天数计算器...................................................... 18
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例014 根据收入情况计算个人所得税...................................................... 20
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例015 你的公司有多少奖金........................................................................ 22
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例016 判断用户输入月份的季节............................................................. 23
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例017 根据消费金额计算折扣............................................................... 25
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例018 招聘计算机语言程序员................................................................... 26
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例019 计算1+1/2!+1/3!+…+1/10！的值................................................... 27
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例020 实现输出杨辉三角............................................................................... 29
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例021 空心菱形如何表示............................................................................ 30
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例022 打印九九乘法表..................................................................................... 33
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例023 猴子分桃问题....................................................................................... 34
难度指数 ★★★★☆☆ 占用时间 􀁪○○
第3 章 数组............................................................................................................36
实例024 获取一维数组中的最大最小值..................................................... 36
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例025 实现矩阵的转置...................................................................... 38
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例026 求矩阵的迹（主对角线之和）............................................................... 40
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例027 1、2、3、4 能组成多少个互不相同的三位数........................................ 41
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例028 统计出数组中各种字符的个数........................................................ 42
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例029 使用最简单的for 循环对数组进行排序................................................. 44
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例030 使用选择排序法对数组进行排序................................................................ 45
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例031 使用冒泡排序法对数组进行排序..................................................... 47
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例032 使用快速排序法对数组进行排序........................................................ 48
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例033 使用直接插入法对数组进行排序...................................................... 50
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例034 使用sort()方法对数组进行排序........................................................... 53
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例035 猴子选大王................................................................................................. 54
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例036 九宫格问题........................................................................................... 56
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例037 使用数组实现电话号码加密................................................. 57
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例038 幸运观众是如何产生的............................................................... 58
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例039 使用数组来实现计算器页面....................................................... 61
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例040 使用数组实现复选框设置................................................................. 63
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例041 反转输出数组元素............................................................................ 65
难度指数 ★★★★★☆ 占用时间 􀁪○○
第4 章 字符串....................................................................68
实例042 输入的用户名找回用户密码................................................... 68
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例043 将数字货币金额转换为大写格式............................................ 69
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例044 将数字格式化为货币字符串........................................................ 72
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例045 实现不同字符串的连接................................................................. 73
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例046 字符串大小写转换................................................................ 74
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例047 计算字符串中子串出现的次数.................................................... 76
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例048 当前日期的格式化............................................................................... 77
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例049 判断字符串是否为数字...................................................................... 78
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例050 判断网页请求和FTP 请求..................................................................... 79
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例051 验证IP 地址的有效性........................................................ 80
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例052 鉴别非法的电话号码................................................................ 82
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例053 ASCII 编码查看器............................................................................ 83
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例054 对用户名进行比较排序............................................................................... 84
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例055 批量替换特定的字符串..................................................................... 85
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例056 去掉字符串中的空格.............................................................................. 87
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例057 获取字符串中汉字的个数.................................................................... 89
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例058 字符串的编码转换............................................................................ 90
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例059 海量字符串的快速操作................................................................ 91
难度指数 ★★★★★★ 占用时间 􀁪○○
第5 章 面向对象........................................................................................................94
实例060 自定义学生类...................................................................................... 94
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例061 成员变量的默认初始化值.......................................................... 96
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例062 查看类的声明.......................................................................................... 97
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
示例063 查看类的成员.......................................................................................... 99
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例064 查看内部类信息....................................................................................... 101
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例065 同名方法的使用............................................................................ 102
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例066 动态调用类中的方法...................................................................... 103
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例067 实现类的动态实例化........................................................................... 105
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例068 摄氏温度与华氏温度的转换......................................................... 106
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例069 统计商品销售量............................................................................ 107
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例070 汉诺塔问题的解决............................................................................... 108
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例071 领导和员工的差异.................................................................................... 110
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例072 重写（覆盖）父类中的方法................................................................... 112
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例073 计算几何图形的面积............................................................................... 114
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例074 简单的长度单位转换器............................................................................ 116
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例075 使用字符串输出对象................................................................. 118
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例076 使用策略模式保存图片类型......................................................... 120
难度指数 ★★★★★★ 占用时间 􀁪○○
实例077 使用局部内部类实现闹钟的应用........................................................... 121
难度指数 ★★★★★★ 占用时间 􀁪○○
实例078 使用静态内部类获取数组中的最大和最小值............................................. 123
难度指数 ★★★★★★ 占用时间 􀁪○○
实例079 创建长度可变的数组............................................................................. 125
难度指数 ★★★★★★ 占用时间 􀁪○○
实例080 简单的手机销售流程.................................................................................... 126
难度指数 ★★★★★★ 占用时间 􀁪○○
第二篇 应 用 篇
第6 章 Java 集合类...................................................................................................... 128
实例081 不重复地进行随机数组排序.................................................................... 128
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例082 实现List 集合中数组的自动排序........................................................... 129
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例083 使用动态数组保存用户名..................................................................... 131
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例084 使用For 循环遍历ArrayList .................................................................. 133
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例085 使用Iterator 遍历ArrayList ................................................................. 134
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例086 使用ListIterator 逆序遍历ArrayList........................................................ 135
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例087 简单的电子词典............................................................................... 137
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例088 猴子选大王2.............................................................................................. 138
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例089 使用HashSet 实现学生信息管理.......................................................... 139
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例090 使用TreeSet 管理学生成绩信息....................................................... 141
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例091 二分查找字符串中指定关键字......................................................... 144
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例092 使用HashMap 实现常用的查找功能........................................................ 146
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例093 使用TreeMap 实现学生成绩的查找功能.................................................... 147
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例094 使用Vector 类管理图书书目信息....................................................... 150
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例095 使用Stack 栈实现字符串的逆序输出................................................... 151
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例096 读写Properties 文件................................................................................ 152
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
第7 章 多线程............................................................................................................... 154
实例097 线程的启动与结束......................................................................................... 154
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例098 查看线程的运行状态..................................................................................... 157
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例099 设置线程优先级分配CPU 运行时间.................................................... 159
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例100 篮球运动员的比赛安排（线程的休眠和唤醒） ................................ 161
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例101 CSDN 资源搜索与下载（线程等待和通报）.................................... 163
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例102 非诚勿扰，爱情对对碰（线程join()等待方法） ..................................... 165
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例103 诺贝尔奖莫言作品集的获取（yield()让步方法） ................................. 167
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例104 ATM 存取机的实现（线程的同步）.......................................................... 169
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例105 模拟淘宝网购物买卖双方交易..................................................................... 172
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例106 房门终于被打开了（解决死锁的方法） ................................................... 175
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例107 创建自己的任务定时器......................................................... 178
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例108 医院手术任务（线程池任务）................................................. 179
难度指数 ★★★★★☆ 占用时间 􀁪○○
第8 章 Java 异常处理.................................................................................... 183
实例109 算数异常（ArithmeticException）......................................................... 183
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例110 数组下标越界异常（ArrayIndexOutOfBoundsException）................... 184
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例111 数组元素类型不匹配异常（ArrayStoreException） .................................... 185
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例112 强制类型转换异常（ClassCastException） ............................................ 186
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例113 空指针异常（NullPointerException） ........................................................ 187
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例114 数字格式转换异常（NumberFormatException） .................................... 188
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例115 字符串索引越界异常（StringIndexOutOfBoundsException）........................ 189
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例116 操作错误异常（UnsupportedOperationException） ................................... 190
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例117 找不到指定类时异常（ClassNotFoundException）.................................. 191
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例118 try-catch 捕获异常.......................................................................... 192
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例119 try-catch-finally 捕获异常.................................................................. 193
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例120 嵌套try-catch-finally 捕获异常......................................................... 195
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例121 非法访问异常（IllegalAccessException） ..................................... 196
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例122 未发现文件异常（FileNotFoundException） .................................. 197
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例123 throws 抛出异常.................................................................... 198
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例124 throw 抛出异常....................................................................... 199
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例125 自定义异常............................................................................... 200
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例126 数据库操作异常（SQLException） ......................................................... 202
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例127 同时捕获多个异常.......................................................................... 203
难度指数 ★★★★★☆ 占用时间 􀁪○○
第9 章 Java 常用工具类.................................................................................... 205
实例128 求圆周率π 的近似值............................................................................. 205
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例129 四舍五入运算器.......................................................................... 206
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例130 高精度整数的运算............................................................................. 207
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例131 高精度浮点运算............................................................................ 208
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例132 指数与对数函数的使用方法...................................................... 209
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例133 三角函数和反三角函数的使用方法........................................................... 210
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例134 生成任意类型的随机数..................................................................... 211
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例135 随机生成不同格式的验证码........................................................... 214
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例136 使用Date 类获取当前系统时间....................................................... 215
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例137 使用SimpleDateFormat 类格式化输出时间............................................ 217
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例138 使用Calendar 显示当前的时间和日期...................................................... 219
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例139 使用GregorianCalendar 类输出日历........................................................... 220
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例140 显示某年某月某一周的信息............................................................. 222
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例141 Formatter 类的格式化输出...................................................................... 223
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例142 使用时间格式转换符输出时间和日期................................................... 224
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例143 记录程序执行的时间................................................................................ 226
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例144 获取程序运行环境的信息...................................................................... 227
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例145 简单的计时器............................................................................... 229
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例146 Java 内存管理..................................................................................... 231
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例147 正则表达式匹配方法的应用................................................................ 232
难度指数 ★★★★★★ 占用时间 􀁪○○
实例148 正则表达式替换方法的应用............................................................. 234
难度指数 ★★★★★★ 占用时间 􀁪○○
实例149 E-mail 格式合法性验证与自动修改................................................... 235
难度指数 ★★★★★★ 占用时间 􀁪○○
第10 章 枚举和泛型............................................................................................ 238
实例150 查看枚举类型定义................................................................................ 238
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例151 同一服装不同尺寸的价格查询............................................................ 240
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例152 使用枚举进行数据库连接................................................................ 241
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例153 枚举元素集合的应用......................................................................... 243
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例154 枚举元素映射的应用.............................................................................. 244
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例155 使用泛型实现栈结构.................................................................... 245
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例156 带两个类型参数的泛型的应用....................................................... 247
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例157 使用通配符增强泛型.................................................................. 248
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例158 使用泛型方法获得对象类型................................................................... 250
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例159 使用泛型接口获得数组的最大和最小值........................................ 251
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例160 泛型类的继承应用........................................................................... 253
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例161 泛型的强制类型转换................................................................................... 254
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例162 泛型的集合类应用....................................................................................... 255
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
第11 章 Java 的输入/输出及文件操作......................................................................... 257
实例163 创建文件和目录..................................................................................... 257
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例164 显示文件的基本信息.................................................................. 259
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例165 显示目录的基本信息......................................................................... 261
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例166 创建、修改与删除文件的综合操作........................................................... 263
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例167 以字节为单位读取文件内容.................................................................. 264
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例168 以字符为单位读取文件内容............................................................... 267
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例169 以行为单位读取文件内容....................................................................... 269
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例170 以字节为单位写文件................................................................................ 271
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例171 以字符为单位写文件.................................................................. 273
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例172 以行为单位写文件................................................................. 274
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例173 按顺序创建文件.................................................................. 276
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例174 按顺序读取文件....................................................................... 277
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例175 移动指定目录下的文件和目录..................................................... 278
难度指数 ★★★★★★ 占用时间 􀁪○○
实例176 快速查找指定类型的文件...................................................... 281
难度指数 ★★★★★★ 占用时间 􀁪○○
实例177 复制指定目录下的文件.................................................................. 283
难度指数 ★★★★★★ 占用时间 􀁪○○
实例178 以遍历方式显示文件中的字符....................................................... 285
难度指数 ★★★★★★ 占用时间 􀁪○○
实例179 将数据保存到指定的文件中.......................................................... 286
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例180 将一个大文件分割为多个小文件.......................................................... 287
难度指数 ★★★★★★ 占用时间 􀁪○○
实例181 将多个小文件合并为一个大文件............................................................ 289
难度指数 ★★★★★★ 占用时间 􀁪○○
实例182 统计指定文件中的字符个数...................................................................... 291
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例183 使用I/O 流生成Word 文件................................................................ 293
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例184 使用I/O 流读取Word 文件............................................................... 295
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例185 使用I/O 流生成Excel 文件................................................................. 296
难度指数 ★★★★★★ 占用时间 􀁪○○
实例186 使用I/O 流读取Excel 文件.................................................................... 299
难度指数 ★★★★★★ 占用时间 􀁪○○
实例187 使用I/O 流生成PDF 文件..................................................................... 301
难度指数 ★★★★★★ 占用时间 􀁪○○
实例188 使用I/O 流读取PDF 文件..................................................................... 303
难度指数 ★★★★★★ 占用时间 􀁪○○
实例189 生成ZIP 压缩文件.................................................................................. 304
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例190 解压缩ZIP 文件............................................................................... 307
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例191 读取JAR 包文件...................................................................................... 309
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例192 文件的加密/解密操作.............................................................................. 311
难度指数 ★★★★☆ 占用时间 􀁪○○
第三篇 开 发 篇
第12 章 Swing 基础入门............................................................................................ 313
实例193 创建一个窗口及面板....................................................................... 313
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例194 设置窗体的大小........................................................................................ 315
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例195 动态的窗体大小调整............................................................................... 316
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例196 创建对话框........................................................................................ 317
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例197 设置窗体标签........................................................................................ 319
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例198 同一按钮实现不同功能................................................................... 320
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例199 文本框和密码框的创建......................................................................... 322
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例200 多行文本框的创建............................................................................ 324
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例201 创建单选按钮..................................................................................... 326
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例202 复选框的使用.............................................................................. 328
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例203 列表框使用实例......................................................................... 331
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例204 组合框应用实例.................................................................................... 333
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例205 滚动条应用实例................................................................................. 335
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例206 进度条应用实例............................................................................... 337
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例207 表格的使用................................................................................................ 339
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例208 树形结构的创建...................................................................................... 340
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例209 创建菜单................................................................................................ 342
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例210 创建弹出式菜单........................................................................................ 345
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例211 工具栏的使用............................................................................. 348
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例212 FlowLayout 布局管理......................................................... 350
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例213 边框布局BorderLayout 布局设计.................................................................. 351
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例214 网格布局GridLayout 版面设计........................................................ 353
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例215 如何使用卡片布局管理器........................................................................ 355
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例216 应用网格包布局GridBagLayout 设计版面.............................................. 358
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例217 用户对话框JOptionPane 的使用..................................................... 360
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例218 文件选择对话框JFileChooser 的使用................................................... 363
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例219 颜色选择对话框JColorChooser 的使用............................................... 366
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例220 使用ActionEvent 监听组件............................................................ 368
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例221 使用MouseListener 监听鼠标事件............................................ 370
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例222 使用MouseMotionListener 监听鼠标移动.............................................. 371
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例223 使用KeyListener 监听键盘.......................................................................... 373
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例224 使用WindowListener 监听窗口事件.......................................................... 375
难度指数 ★★★★★☆ 占用时间 􀁪○○
第13 章 Swing 应用进阶............................................................................................. 378
实例225 设置闪烁的标题栏............................................................................. 378
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例226 实现带背景图片的窗体.......................................................................... 379
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例227 对窗体背景进行随机更换.................................................................. 381
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例228 建立钻石型窗体.......................................................................... 383
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例229 打开指定类型的文件......................................................................... 385
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例230 震动效果的提示信息....................................................................... 387
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例231 建立简单的时钟布局................................................................ 388
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例232 文本区设置背景图片....................................................................... 391
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例233 简单的字符统计工具............................................................................. 392
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例234 我最喜爱的小品演员投票.................................................................... 394
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例235 快捷的日期显示器.................................................................................. 397
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例236 包含图片的弹出菜单............................................................................... 400
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例237 文本框内容的显示方法设定................................................... 402
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例238 设置表格的列的高度.................................................................................... 404
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例239 对于表格中列的宽度设置....................................................................... 405
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例240 快速查找表格记录............................................................................... 407
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例241 提示信息的应用.................................................................................... 409
难度指数 ★★★★☆☆ 占用时间 􀁪○○
第14 章 Java Applet 小应用程序.............................................................................. 412
实例242 不断逼近的文字....................................................................... 412
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例243 舞动的彩文................................................................................... 414
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例244 文字的3D 效果.......................................................................... 416
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例245 绚烂的字体闪烁.......................................................................... 419
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例246 闪亮登场的文字............................................................... 422
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例247 简易图片放大镜............................................................. 424
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例248 带波纹的水面倒影................................................................... 426
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例249 夜空中璀璨的烟火.............................................................................. 428
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例250 百叶窗翻页效果........................................................................... 432
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例251 自制QQ 空间欢迎界面.......................................................... 434
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例252 雷电中的纽约市.................................................................................... 436
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例253 动态边框图片............................................................................. 439
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例254 我的风景相册薄.......................................................................... 441
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例255 遥远的星球.................................................................................... 443
难度指数 ★★★★★☆ 占用时间 􀁪○○
第15 章 网络通信编程........................................................................................... 446
实例256 获取自己的计算机名与IP 地址................................................ 446
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例257 获得特定网站的IP 地址.......................................................... 447
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例258 使用URL 访问网页......................................................... 449
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例259 根据URL 获取因特网上的图像........................................................ 451
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例260 根据URL 获取因特网网页源文件...................................................... 452
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例261 根据URL 获取因特网上的音频.................................................... 453
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例262 自制浏览器.................................................................................. 455
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例263 实现网络文件的下载.................................................................. 457
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例264 实现网络的一对一通讯................................................................... 459
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例265 实现网络的一对多通讯...................................................................... 461
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例266 实现网络的图片传输........................................................................ 463
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例267 实现网络的音频传输................................................................... 466
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例268 实现网络的视频传输................................................................ 469
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例269 模仿QQ 创建实时聊天室.................................................. 471
难度指数 ★★★★★☆ 占用时间 􀁪○○
第16 章 Java 安全机制......................................................................................... 475
实例270 加密解密的始祖——凯撒密码.............................................................. 475
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例271 密钥的创建..................................................................... 477
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例272 对称加密................................................................................. 479
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例273 非对称加密................................................................................. 480
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例274 CBC 方式的加密................................................................ 482
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例275 CBC 方式的解密.................................................................. 483
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例276 数字签名.......................................................................................... 484
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例277 使用消息保存口令........................................................................... 486
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例278 使用消息验证口令........................................................................... 487
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例279 破解简单的加密口令...................................................................... 488
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例280 输入流的加密算法.............................................................................. 490
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例281 输入流的解密算法.............................................................. 492
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例282 输出流的加密算法........................................................................... 493
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例283 输出流的解密算法............................................................................ 494
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例284 使用RSA 算法进行加密...................................................... 495
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例285 使用RSA 算法进行解密........................................................... 497
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例286 使用公钥计算消息验证码...................................................... 498
难度指数 ★★★★★☆ 占用时间 􀁪○○
第17 章 Java 多媒体程序设计............................................................................ 501
实例287 常用图形的绘制.................................................................................... 501
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例288 不规则图形的绘制................................................................................ 506
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例289 图片的旋转................................................................................... 507
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例290 图片缩放.......................................................................................... 509
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例291 图像的模糊与锐化............................................................................ 513
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例292 光照特效实例............................................................................ 516
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例293 创建动画图片............................................................................. 519
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例294 图片的合成........................................................................... 520
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例295 音频播放程序.............................................................................. 523
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例296 利用JavaSound API 播放音频........................................................ 525
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例297 视频文件的播放...................................................................................... 528
难度指数 ★★★★☆☆ 占用时间 􀁪○○
第18 章 Java 数据库操作............................................................................. 533
实例298 JDBC 连接MySQL 数据库............................................................ 533
难度指数 ★★☆☆☆☆ 占用时间 􀁪○○
实例299 查询数据库中表的名称........................................................................ 535
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例300 动态添加数据库字段信息............................................................ 538
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例301 获取数据库中表的字段信息........................................................... 541
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例302 动态添加学生信息到学生表中............................................................... 546
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例303 对添加数据进行数据验证....................................................................... 548
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例304 MySQL 数据库备份.............................................................................. 554
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例305 MySQL 数据恢复........................................................................... 556
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例306 向数据库中批量插入数据..................................................... 558
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例307 修改数据库表内信息.............................................................. 559
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例308 将数据表中的信息复制到其他表中.................................................... 562
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例309 保存用户登录信息......................................................................................... 566
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例310 将图片文件存入数据库............................................................................ 569
难度指数 ★★★★★★ 占用时间 􀁪○○
实例311 将数据库中的图片输出.................................................................. 571
难度指数 ★★★★★★ 占用时间 􀁪○○
实例312 生成有规律的编号........................................................................................ 573
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例313 生成无规律编号...................................................................................... 576
难度指数 ★★★★★☆ 占用时间 􀁪○○
（以下内容见图书配套光盘中文件夹“第19 章”）
第19 章 Java 小游戏合集及应用工具示例.................................................................. 579
实例314 欢乐斗地主..................................................................................................... 579
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例315 打豆豆游戏................................................................................................... 585
难度指数 ★★★☆☆☆ 占用时间 􀁪○○
实例316 动感魔方游戏.......................................................................................... 588
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例317 俄罗斯方块游戏............................................................................................. 592
难度指数 ★★★★★★ 占用时间 􀁪○○
实例318 贪吃蛇游戏................................................................................................. 598
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例319 拼图游戏............................................................................................. 605
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例320 寻找宝藏游戏........................................................................................ 610
难度指数 ★★★★★★ 占用时间 􀁪○○
实例321 开窗游戏................................................................................................. 614
难度指数 ★★★★☆☆ 占用时间 􀁪○○
实例322 猜价格游戏................................................................................................. 617
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例323 中国象棋游戏........................................................................................... 620
难度指数 ★★★★★★ 占用时间 􀁪○○
实例324 Java 身份证信息解读................................................................................ 624
难度指数 ★★★★★☆ 占用时间 􀁪○○
实例325 Java 万年历..................................................................................... 627
难度指数 ★★★★★☆ 占用时间 􀁪○○
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计经典300例
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 2从入门到精通
第一部分 Java基础
第1章 Java 简介
第2章 小程序、应用程序与Java开发工具库
第3章 使用Java对象
第4章 数据类型、修饰符和表达式
第5章 Java类、接口和包
第6章 数组与流程控制语句
第7章 异常处理
第8章 线程与多线程
第二部分 采用标准Java类

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 2从入门到精通
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言程序设计
第1章 Java概述
1.1 程序设计语言
1.1.1 机器语言
1.1.2 汇编语言
1.1.3 高级语言
1.2 面向对象的程序设计语言——Java
1.2.1 Java的发展历史
1.2.2 Java的特点
1.2.3 Java与C/C++的比较
1.3 Java的开发和运行环境
1.3.1 JDK的安装
1.3.2 JDK的设置
1.4 开发和运行Java程序的步骤
1.4.1 选择编辑工具
1.4.2 编译和运行Java程序
1.5 JCreator
习题
第2章 Java基础
2.1 标识符和关键字
2.2 数据类型与常量、变量
2.2.1 数据类型的分类
2.2.2 基本数据类型
2.2.3 常量
2.2.4 变量
2.3 运算符和表达式
2.3.1 运算符
2.3.2 表达式
习题
第3章 基本控制结构
3.1 语句及程序结构
3.2 顺序结构
3.3 选择结构
3.3.1 if语句
3.3.2 swish语句
3.4 循环结构
3.4.1 while语句
3.4.2 dowhile语句
3.4.3 for语句
3.4.4 多重循环
3.5 跳转语句
习题
第4章 方法
4.1 方法声明
4.2 方法调用
4.3 参数传递
4.4 递归
习题
第5章 数组
5.1 一维数组
5.1.1 一维数组的声明
5.1.2 一维数组的初始化
5.2 多维数组
5.2.1 二维数组的声明
5.2.2 二维数组的初始化
5.3 数组的基本操作
5.3.1 数组的引用
5.3.2 数组的复制
5.3.3 数组的输出
5.4 数组应用举例
5.5 数组参数
5.6 字符串
5.6.1 字符数组与字符串
5.6.2 字符串
5.6.3 字符串操作
5.6.4 字符串数组
习题
第6章 类和对象
6.1 类和对象概述
6.1.1 面向对象的基本概念
6.1.2 类的声明
6.1.3 对象的创建和使用
6.1.4 构造方法和对象的初始化
6.1.5 对象销毁
6.2 类的封装
6.2.1 访问权限
6.2.2 类成员
习题
第7章 类的继承和多态机制
7.1 类的继承
7.1.1 继承的基本概念
7.1.2 继承的实现
7.1.3 super和this引用
7.2 类的多态性
7.2.1 方法重载
7.2.2 方法覆盖
7.3 final类和final成员
习题
第8章 接口和包
8.1 抽象类和方法
8.2 接口
8.2.1 声明接口
8.2.2 实现接口
8.3 包
8.3.1 包的概念
8.3.2 包的声明和导入
习题
第9章 异常处理
9.1 Java异常处理机制
9.2 异常处理方式
9.2.1 bycatchfinally结构
9.2.2 抛出异常
9.2.3 自定义异常类
习题
第10章 输入与输出
10.1 输入/输出类库
10.1.1 流
10.1.2 输入/输出流类
10.2 标准输入/输出及标准错误
10.2.1 标准输入
10.2.2 标准输出
10.2.3 标准错误
10.3 文件操作
10.3.1 建立File对象
10.3.2 File对象的属性和操作
习题
第11章 图形用户界面设计
11.1 AWT组件概述
11.2 布局管理
11.2.1 BorderLayout类
11.2.2 FlowLayout类
11.2.3 GridLayout类
11.3 事件处理
11.3.1 委托事件模型
11.3.2 事件类和监听器接口
11.3.3 处理ActionEvent事件
11.3.4 处理ItemEvent事件
11.3.5 处理TextEvent事件
11.3.6 处理KeyEvent事件
11.3.7 处理MouseEvent事件
11.3.8 处理WindowEvent事件
11.4 绘图
习题
第12章 Swing组件
12.1 Swing组件概述
12.2 窗口
12.3 标签
12.4 按钮
12.5 单选按钮和复选框
12.6 文本编辑组件
12.7 列表框和组合框
12.8 菜单
习题
第13章 Applet程序
13.1 Applet简介
13.1.1 Applet类
13.1.2 Applet程序的运行过程
13.1.3 Applet程序的建立和运行
13.2 Applet程序举例
习题
第14章 多线程
14.1 Java的多线程机制
14.1.1 线程的生命周期
14.1.2 多线程的实现方法
14.2 通过Tharead类实现多线程
14.3 通过Runnable接口实现多线程
14.4 线程等待
14.5 线程同步
习题
第15章 数据库编程
15.1 数据库简介
15.1.1 关系型数据库
15.1.2 SQL简介
15.2 使用JDBC连接数据库
]5.2.1 JDBC简介
15.2.2 JDBC驱动程序
15.3 建立数据源
15.3.1 建立数据库
15.3.2 建立数据源
15.4 Java数据库编程
15.4.1 数据库编程的一般过程
15.4.2 数据库编程实例
习题
第16章 网络编程
16.1 网络基础
16.2 URL
16.2.1 URL类
16.2.2 URLConnection类
16.3 Socket通信
16.3.1 Socket概念
16.3.2 Socket的通信机制
16.3.3 Socket类与ServerSocket类
16.3.4 URL与Socket通信的区别
16.3.5 UDP通信
习题
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 7程序设计
译者序
前　言
第1章　初识Java1
1.1　第一个Java程序1
1.1.1　编写Java程序1
1.1.2　编译Java程序1
1.1.3　运行Java程序2
1.2　Java编码规范2
1.3　集成开发环境（IDE）3
1.4　小结4
习题4
第2章　语言基础5
2.1　ASCII和Unicode5
2.2　分隔符7
2.3　基本类型7
2.4　变量8
2.5　常量10
2.6　字面量11
2.6.1　整数字面量11
2.6.2　浮点字面量12
2.6.3　布尔字面量13
2.6.4　字符字面量13
2.7　基本类型转换14
2.7.1　扩大转换14
2.7.2　缩小转换15
2.8　操作符15
2.8.1　一元操作符16
2.8.2　算术操作符18
2.9　注解24
2.10　小结25
习题25
第3章　语句26
3.1　Java语句概述26
3.2　if语句27
3.3　while语句29
3.4　do-while语句30
3.5　for语句31
3.6　break语句34
3.7　continue语句35
3.8　switch语句35
3.9　小结36
习题36
第4章　对象和类38
4.1　什么是Java对象38
4.2　Java类39
4.2.1　域40
4.2.2　方法40
4.2.3　UML类图中的类成员42
4.3　创建对象42
4.4　关键字null43
4.5　内存中的对象43
4.6　Java包46
4.7　封装和访问控制47
4.7.1　类访问控制修饰符47
4.7.2　类成员访问控制修饰符49
4.8　关键字this51
4.9　使用其他类52
4.10　final变量53
4.11　静态成员54
4.12　静态final变量55
4.13　静态导入56
4.14　变量作用域57
4.15　方法重载58
4.16　赋值传递还是引用传递59
4.17　加载、链接和初始化59
4.17.1　加载60
4.17.2　链接60
4.17.3　初始化60
4.18　对象创建初始化61
4.19　对象的比较64
4.20　垃圾回收器64
4.21　小结64
习题65
第5章　核心类66
5.1　java.lang.Object66
5.2　java.lang.String67
5.2.1　比较两个String对象68
5.2.2　字符串字面量69
5.2.3　字符转义69
5.2.4　switch中的String 69
5.2.5　String类的构造器70
5.2.6　String类的方法71
5.3　java.lang.StringBuffer和java.lang.StringBuilder73
5.3.1　StringBuilder类的构造器73
5.3.2　StringBuilder类的方法74
5.4　基本类型包装74
5.4.1　java.lang.Integer75
5.4.2　java.lang.Boolean75
5.4.3　java.lang.Character76
5.5　数组76
5.5.1　迭代数组78
5.5.2　修改数组大小78
5.5.3　将String数组传递给main80
5.6　java.lang.Class80
5.7　java.lang.System81
5.8　java.util.Scanner85
5.9　装箱和拆箱85
5.10　可变参数85
5.11　格式和printf方法86
5.12　小结87
习题87
第6章　继承88
6.1　继承概述88
6.1.1　关键字extends88
6.1.2　is-a关系89
6.2　可访问性90
6.3　方法覆盖91
6.4　调用超类的构造器92
6.5　调用超类的隐藏成员94
6.6　类型转换94
6.7　Final类95
6.8　关键字instanceof95
6.9　小结96
习题96
第7章　错误处理97
7.1　捕捉异常97
7.2　没有catch的try99
7.3　捕捉多个异常99
7.4　try-with-resources语句99
7.5　java.lang.Exception类100
7.6　从方法抛出异常101
7.7　用户自定义的异常102
7.8　异常处理总结103
7.9　小结104
习题104
第8章　数字和日期105
8.1　数字解析105
8.2　数字格式化106
8.3　用java.text.NumberFormat解析数字107
8.4　java.lang.Math类107
8.5　java.util.Date类108
8.6　java.util.Calendar类109
8.7　用DateFormat进行日期解析和格式化110
8.7.1　DateFormat110
8.7.2　SimpleDateFormat111
8.8　小结112
习题112
第9章　接口和抽象类113
9.1　接口的概念113
9.2　从技术角度看接口114
9.2.1　接口中的域115
9.2.2　方法115
9.3　基类116
9.4　抽象类117
9.5　小结118
习题118
第10章　枚举119
10.1　枚举概述119
10.2　类中的枚举120
10.3　java.lang.Enum类121
10.4　迭代枚举值121
10.5　枚举在switch中的应用121
10.6　小结122
习题122
第11章　集合框架123
11.1　集合框架概述123
11.2　Collection接口124
11.3　List和ArrayList124
11.4　用Iterator和for迭代集合126
11.5　Set和HashSet127
11.6　Queue和LinkedList128
11.7　集合转换129
11.8　Map和HashMap129
11.9　对象比较和排序130
11.9.1　使用java.lang.Comparable130
11.9.2　使用Comparable和Comparator133
11.10　小结136
习题136
第12章　泛型137
12.1　没有泛型的生活137
12.2　泛型类型简介138
12.3　使用没有类型参数的泛型类型140
12.4　使用“?”通配符141
12.5　在方法中使用有界通配符143
12.6　编写泛型类型144
12.7　小结145
习题145
第13章　输入／输出146
13.1　文件系统和路径147
13.2　文件和目录的处理及操作148
13.2.1　创建和删除文件及目录148
13.2.2　获取目录的对象149
13.3.3　复制和移动文件149
13.2.4　文件读取和写入150
13.3　输入／输出流152
13.4　读取二进制数据152
13.5　写入二进制数据156
13.6　写入文本（字符）159
13.6.1　Writer159
13.6.2　OutputStreamWriter160
13.6.3　PrintWriter161
13.7　读取文本（字符）163
13.7.1　Reader163
13.7.2　InputStreamReader163
13.7.3　BufferedReader165
13.8　用PrintStream记录日志166
13.9　随机访问文件167
13.10　对象序列化171
13.11　小结173
习题173
第14章　嵌套类和内部类174
14.1　嵌套类概述174
14.2　静态的嵌套类175
14.3　成员内部类176
14.4　局部内部类178
14.5　匿名内部类179
14.6　深入嵌套类和内部类180
14.7　小结182
习题183
第15章　Swing基础知识184
15.1　AWT组件185
15.2　有用的AWT类187
15.2.1　java.awt.Color187
15.2.2　java.awt.Font187
15.2.3　java.awt.Point187
15.2.4　java.awt.Dimension188
15.2.5　java.awt.Rectangle188
15.2.6　java.awt.Graphics188
15.2.7　java.awt.Toolkit188
15.3　基础的Swing组件189
15.3.1　JFrame189
15.3.2　调整尺寸和定位192
15.3.3　扩展JFrame194
15.3.4　JComponent195
15.3.5　Icon和ImageIcon196
15.3.6　JLabel196
15.3.7　JButton198
15.3.8　JTextField和JPasswordField199
15.3.9　JTextArea201
15.3.10　JCheckbox202
15.3.11　JRadioButton203
15.3.12　JList205
15.3.13　JComboBox206
15.3.14　JDialog207
15.3.15　JOptionPane210
15.3.16　JFileChooser214
15.4　小结216
习题217
第16章　Swing高级知识218
16.1　布局管理器218
16.1.1　BorderLayout219
16.1.2　FlowLayout221
16.1.3　BoxLayout222
16.1.4　GridLayout223
16.1.5　不用LayoutManager224
16.2　事件处理225
16.2.1　Java事件模型225
16.2.2　Swing事件处理226
16.2.3　AWT事件API228
16.3　使用菜单239
16.4　外观240
16.5　快速启动画面242
16.6　系统托盘支持244
16.7　桌面助手应用程序246
16.8　小结250
习题250
第17章　多态251
17.1　定义多态251
17.2　多态实战254
17.3　绘图应用程序中的多态254
17.4　多态和反射259
17.5　小结261
习题261
第18章　注解262
18.1　注解概述262
18.1.1　注解和注解类型262
18.1.2　注解语法263
18.1.3　注解接口263
18.2　标准注解264
18.2.1　Override264
18.2.2　Deprecated264
18.2.3　SuppressWarnings266
18.3　一般注解267
18.4　标准元注解267
18.4.1　Documented267
18.4.2　Inherited268
18.4.3　Retention268
18.4.4　Target268
18.5　定制注解类型269
18.5.1　编写自己的定制注解类型269
18.5.2　使用定制注解类型269
18.5.3　用反射查询注解270
18.6　小结271
习题271
第19章　国际化272
19.1　Locale272
19.2　应用程序国际化274
19.2.1　将文本组件单独放进属性文件274
19.2.2　用ResourceBundle读取属性文件275
19.3　将Swing应用程序国际化275
19.4　小结277
习题277
第20章　Applet278
20.1　Applet历史简介278
20.2　Applet API279
20.2.1　Applet类279
20.2.2　AppletContext接口281
20.2.3　AudioClip接口281
20.2.4　AppletStub接口282
20.3　安全限制282
20.4　编写和部署applet282
20.5　AppletViewer工作原理284
20.6　将参数传递给Applet285
20.7　SoundPlayerApplet288
20.8　JApplet289
20.9　在JAR文件中部署Applet290
20.10　更快速加载290
20.11　小结291
习题291
第21章　Java网络292
21.1　网络概述292
21.2　超文本转移协议（HTTP）293
21.2.1　HTTP请求293
21.2.2　HTTP响应294
21.3　java.net.URL295
21.3.1　解析URL295
21.3.2　读取Web资源296
21.4　java.net.URLConnection297
21.4.1　读取Web资源298
21.4.2　把数据写入Web服务器300
21.5　java.net.Socket300
21.6　java.net.ServerSocket302
21.7　一个Web服务器应用程序303
21.7.1　HttpServer类303
21.7.2　Request类306
21.7.3　Response类308
21.7.4　运行应用程序310
21.8　小结311
习题311
第22章　JDBC312
22.1　JDBC简介312
22.2　数据访问的4个步骤313
22.2.1　加载JDBC驱动程序313
22.2.2　获得数据库连接314
22.2.3　创建Statement对象315
22.2.4　创建一个ResultSet对象316
22.3　关闭JDBC对象317
22.4　读取元数据318
22.5　SQLTool示例318
22.6　小结323
习题323
第23章　Java线程324
23.1　Java线程简介324
23.2　创建线程324
23.2.1　扩展线程326
23.2.2　实现Runnable接口327
23.3　使用多线程327
23.4　线程优先级329
23.5　停止线程330
23.6　同步333
23.6.1　线程冲突333
23.6.2　方法同步334
23.6.3　块同步 335
23.7　可见性336
23.8　线程协调338
23.9　使用Timer342
23.10　Swing Timer344
23.11　小结346
习题346
第24章　并发工具347
24.1　原子变量347
24.2　Executor和ExecutorService348
24.3　Callable和Future351
24.4　Swing Worker354
24.5　锁357
24.6　小结359
习题359
第25章　安全360
25.1　Java安全概述360
25.2　使用安全管理器361
25.3　策略文件362
25.3.1　keystore363
25.3.2　grant363
25.4　权限364
25.4.1　java.io.FilePermission365
25.4.2　java.security.BasicPermission365
25.4.3　java.util.PropertyPermission365
25.4.4　java.net.SocketPermission365
25.4.5　java.security.Unresolved-Permission366
25.4.6　java.lang.RuntimePermission366
25.4.7　java.awt.AWTPermission366
25.4.8　java.net.NetPermission367
25.4.9　java.lang.reflect.Reflect-Permission367
25.4.10　java.io.Serializable-Permission367
25.4.11　java.security.Security-Permission367
25.4.12　java.security.AllPermission367
25.4.13　javax.security.auth.Auth-Permission367
25.5　使用Policy Tool368
25.6　Applet安全369
25.7　安全编程370
25.8　加密概述370
25.8.1　加密／解密371
25.8.2　验证372
25.8.3　数据完整性374
25.8.4　SSL工作原理374
25.9　创建证书375
25.10　KeyTool程序375
25.10.1　生成配对的密钥376
25.10.2　进行认证377
25.10.3　将证书导入密钥库377
25.10.4　从密钥库中导出证书378
25.10.5　列出密钥库条目378
25.11　JarSigner工具378
25.11.1　签署JAR文件378
25.11.2　验证已签署的JAR文件379
25.11.3　范例：签署一个Applet379
25.12　Java Cryptography API382
25.13　小结382
习题382
第26章　Java Web应用程序383
26.1　Servlet应用程序架构383
26.2　Servlet API概述384
26.3　Servlet385
26.4　编写基础的Servlet应用程序386
26.4.1　安装Tomcat386
26.4.2　编写和编译Servlet类386
26.4.3　应用程序目录结构388
26.4.4　访问Servlet389
26.5　ServletRequest389
26.6　ServletResponse390
26.7　ServletConfig390
26.8　ServletContext393
26.9　GenericServlet393
26.10　HTTP Servlet395
26.10.1　HttpServlet395
26.10.2　HttpServletRequest396
26.10.3　HttpServletResponse397
26.10.4　编写一个Http Servlet397
26.11　使用部署描述符401
26.12　小结403
习题404
第27章　JavaServer Pages405
27.1　JSP概述405
27.2　jspInit、jspDestroy及其他方法407
27.3　隐式对象408
27.4　JSP语法元素409
27.4.1　指令409
27.4.2　脚本元素411
27.5　处理错误413
27.6　小结414
习题414
第28章　Javadoc415
28.1　在Java类中编写文档416
28.1.1　@author416
28.1.2　{@code}417
28.1.3　{@docRoot}417
28.1.4　@deprecated417
28.1.5　@exception417
28.1.6　{@inheritDoc}417
28.1.7　{@link}418
28.1.8　{@linkplain}418
28.1.9　{@literal}418
28.1.10　@param418
28.1.11　@return419
28.1.12　@see419
28.1.13　@serial419
28.1.14　@serialData420
28.1.15　@serialField420
28.1.16　@since420
28.1.17　@throws420
28.1.18　{@value}420
28.1.19　@version421
28.2　Javadoc语法421
28.2.1　Javadoc选项422
28.2.2　标准Doclet选项423
28.2.3　生成文档424
28.3　小结425
习题425
第29章　应用程序部署426
29.1　JWS概述426
29.2　JNLP文件语法426
29.2.1　jnlp元素427
29.2.2　information元素428
29.2.3　security元素429
29.2.4　resources元素429
29.2.5　application-desc元素429
29.2.6　applet-desc元素429
29.3　部署范例430
29.4　安全关注点432
29.5　小结433
习题433
附录A　javac434
附录B　java439
附录C　jar444
附录D　NetBeans448
附录E　Eclipse452
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 7程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>从Paxos到Zookeeper
第1章分布式架构	1
1.1  从集中式到分布式	1
1.1.1  集中式的特点	2
1.1.2  分布式的特点	2
1.1.3  分布式环境的各种问题	4
1.2  从ACID到CAP/BASE	5
1.2.1  ACID	5
1.2.2  分布式事务	8
1.2.3  CAP和BASE理论	9
小结	15
第2章一致性协议	17
2.1  2PC与3PC	17
2.1.1  2PC	17
2.1.2  3PC	21
2.2  Paxos算法	24
2.2.1  追本溯源	25
2.2.2  Paxos理论的诞生	26
2.2.3  Paxos算法详解	27
小结	37
第3章Paxos的工程实践	39
3.1  Chubby	39
3.1.1  概述	39
3.1.2  应用场景	40
3.1.3  设计目标	40
3.1.4  Chubby技术架构	43
3.1.5  Paxos协议实现	52
3.2  Hypertable	55
3.2.1  概述	55
3.2.2  算法实现	57
小结	58
第4章ZooKeeper与Paxos	59
4.1  初识ZooKeeper	59
4.1.1  ZooKeeper介绍	59
4.1.2  ZooKeeper从何而来	62
4.1.3  ZooKeeper的基本概念	62
4.1.4  为什么选择ZooKeeper	64
4.2  ZooKeeper的ZAB协议	65
4.2.1  ZAB协议	65
4.2.2  协议介绍	66
4.2.3  深入ZAB协议	71
4.2.4  ZAB与Paxos算法的联系与区别	77
小结	78
第5章使用ZooKeeper	79
5.1  部署与运行	79
5.1.1  系统环境	79
5.1.2  集群与单机	80
5.1.3  运行服务	84
5.2  客户端脚本	88
5.2.1  创建	88
5.2.2  读取	89
5.2.3  更新	90
5.2.4  删除	91
5.3  Java客户端API使用	91
5.3.1  创建会话	91
5.3.2  创建节点	95
5.3.3  删除节点	99
5.3.4  读取数据	100
5.3.5  更新数据	109
5.3.6  检测节点是否存在	113
5.3.7  权限控制	115
5.4  开源客户端	120
5.4.1  ZkClient	120
5.4.2  Curator	130
小结	162
第6章ZooKeeper的典型应用场景	163
6.1  典型应用场景及实现注	163
6.1.1  数据发布/订阅	164
6.1.2  负载均衡	166
6.1.3  命名服务	170
6.1.4  分布式协调/通知	173
6.1.5  集群管理	179
6.1.6  Master选举	185
6.1.7  分布式锁	188
6.1.8  分布式队列	194
小结	197
6.2  ZooKeeper在大型分布式系统中的应用	197
6.2.1  Hadoop	198
6.2.2  HBase	203
6.2.3  Kafka	207
6.3  ZooKeeper在阿里巴巴的实践与应用	213
6.3.1  案例一消息中间件：Metamorphosis	213
6.3.2  案例二  RPC服务框架：Dubbo	217
6.3.3  案例三基于MySQL Binlog的增量订阅和消费组件：Canal	219
6.3.4  案例四分布式数据库同步系统：Otter	223
6.3.5  案例五轻量级分布式通用搜索平台：终搜	226
6.3.6  案例六实时计算引擎：JStorm	238
小结	242
第7章ZooKeeper技术内幕	243
7.1  系统模型	243
7.1.1  数据模型	243
7.1.2  节点特性	244
7.1.3  版本——保证分布式数据原子性操作	246
7.1.4  Watcher——数据变更的通知	249
7.1.5  ACL——保障数据的安全	265
7.2  序列化与协议	272
7.2.1  Jute介绍	272
7.2.2  使用Jute进行序列化	273
7.2.3  深入Jute	275
7.2.4  通信协议	277
7.3  客户端	284
7.3.1  一次会话的创建过程	286
7.3.2  服务器地址列表	289
7.3.3  ClientCnxn：网络I/O	295
7.4  会话	298
7.4.1  会话状态	298
7.4.2  会话创建	299
7.4.3  会话管理	304
7.4.4  会话清理	307
7.4.5  重连	309
7.5  服务器启动	311
7.5.1  单机版服务器启动	312
7.5.2  集群版服务器启动	315
7.6  Leader选举	321
7.6.1  Leader选举概述	321
7.6.2  Leader选举的算法分析	323
7.6.3  Leader选举的实现细节	328
7.7  各服务器角色介绍	335
7.7.1  Leader	335
7.7.2  Follower	338
7.7.3  Observer	339
7.7.4  集群间消息通信	339
7.8  请求处理	342
7.8.1  会话创建请求	343
7.8.2  SetData请求	351
7.8.3  事务请求转发	354
7.8.4  GetData请求	355
7.9  数据与存储	356
7.9.1  内存数据	356
7.9.2  事务日志	358
7.9.3  snapshot——数据快照	364
7.9.4  初始化	368
7.9.5  数据同步	372
小结	376
第8章ZooKeeper运维	379
8.1  配置详解	379
8.1.1  基本配置	379
8.1.2  高级配置	380
8.2  四字命令	384
8.3  JMX	390
8.3.1  开启远程JMX	390
8.3.2  通过JConsole连接ZooKeeper	391
8.4  监控	397
8.4.1  实时监控	397
8.4.2  数据统计	398
8.5  构建一个高可用的集群	398
8.5.1  集群组成	398
8.5.2  容灾	399
8.5.3  扩容与缩容	402
8.6  日常运维	402
8.6.1  数据与日志管理	402
8.6.2  Too many connections	404
8.6.3  磁盘管理	405
小结	405
附录AWindows平台上部署ZooKeeper	406
附录B从源代码开始构建	409
附录C各发行版本重大更新记录	414
附录DZooKeeper源代码阅读指引	418
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>从Paxos到Zookeeper
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web开发从初学到精通
第1篇  Web基础概述  第1章  Java Web开发概述  第2章  构建开发环境  第3章  Java Web开发基础知识第2篇  Servlet基础和JSP应用  第4章  JDBC基础  第5章  Servlet基础  第6章  JSP语言基础  第7章  EL表达式  第8章  JSTL标签库  第9章  JSP的JavaBean实现第3篇  Struts、Hibernate、Spring详解  第10章  Struts2入门  第11章  Hibernate详解  第12章  Spring基础第4篇  Ajax详解  第13章  认识Ajax  第14章  Ajax实战第5篇  案例应用  第15章  应用Struts2+Hibernate的论坛系统附录A  Java Server Face(JSF)基础附录B  Java Server Face(JSF)高级编程附录C  JDK命令详解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web开发从初学到精通
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>编译器构造
第1章 字符串、语言和编译器
1.1 概述
1.2 语言的基本概念
1.3 编译器的基本概念
1.4 集合论中的基本概念
1.5 空串
1.6 连接
1.7 指数记法
1.8 星运算符（也称为0次或多次运算符）
1.9 串集合的连接
1.10 加运算符（也称为1次或多次运算符）
1.11 问号运算符（也称为0次或1次运算符）
1.12 包含单独一个串的集合的简便记法
1.13 运算符优先级
1.14 正规表达式
1.15 正则表达式的局限性
问题
第2章 上下文无关文法（一）
2.1 概述
2.2 什么是上下文无关文法
2.3 基于上下文无关文法的推导
2.4 由上下文无关文法定义的语言
2.5 上下文无关文法的不同表示方法
2.6 一些简单文法
2.7 基于上下文无关文法的语言生成技术
2.8 正规文法和右线性文法
2.9 基于正规文法的计数
2.10 表的文法
2.11 一个不是上下文无关的重要语言
问题
第3章 上下文无关文法（二）
3.1 概述
3.2 语法分析树
3.3 最左和最右推导
3.4 替换
3.5 二义文法
3.6 确定可致空的非终结符
3.7 消除 （ 产生式
3.8 消除unit产生式
3.9 消除无用非终结符
3.10 递归转换
3.11 增加空串到语言
问题
第4章 上下文无关文法（三）
4.1 概述
4.2 算术表达式文法
4.3 文法中结合性和优先级的描述
4.4 Backus-Naur范式
4.5 语法图
4.6 抽象语法树和三地址码
4.7 非收缩文法
4.8 基本非收缩文法
4.9 上下文无关文法到基本非收缩文法的转换
4.10 上下文无关语言的pumping特性
问题
第5章 Chomsky层次（选讲）
5.1 概述
5.2 上下文有关产生式
5.3 上下文有关文法
5.4 非受限文法
问题
第6章 自上而下语法分析
6.1 概述
6.2 自上而下构造语法分析树
6.3 失败的语法分析
6.4 不适合自上而下语法分析的文法
6.5 确定的语法分析器
6.6 借助栈的语法分析器
6.7 用表来表示栈式语法分析器
6.8 处理不以终结符领头的产生式
6.9 用Java写一个栈式语法分析器
问题
第7章 LL（1）文法
7.1 概述
7.2 产生式右端的FIRST集合
7.3 确定操作序列
7.4 确定 （ 产生式的选择集合
7.5 后跟-左端-后跟-最右规则
7.6 右端可致空的产生式的选择集合
7.7 包含输入结束符的选择集合
7.8 针对含lambda产生式文法的栈式语法分析器
7.9 将非LL（1）文法转换为LL（1）文法
7.10 用二义文法进行分析
7.11 计算FIRST和FOLLOW集合
问题
第8章 表驱动的栈式语法分析器（选讲）
8.1 概述
8.2 统一栈式语法分析器的操作
8.3 实现表驱动的栈式语法分析器
8.4 表驱动栈式语法分析器的改进
8.5 不确定的语法分析器--偏向理论的内容（选讲）
问题
第9章 递归-下降语法分析
9.1 概述
9.2 一个简单的递归-下降语法分析器
9.3 处理lambda产生式
9.4 一个公共错误
9.5 产生式的Java代码
9.6 递归-下降语法分析器中提取左公因子
9.7 消除尾递归
9.8 翻译星号、加号和问号算符
9.9 反向动作
问题
第10章 递归-下降翻译
10.1 概述
10.2 一个简单的翻译文法
10.3 转换翻译文法到Java代码
10.4 翻译文法的描述
10.5 在语法分析过程中传递信息
10.6 L-属性文法
10.7 一个新的单词符号管理器
10.8 解决单词符号向前一个字符看问题
10.9 新单词符号管理器的代码
10.10 前缀表达式编译器的翻译文法
10.11 趣用递归（选讲）
问题
第11章 汇编语言
11.1 概述
11.2 J1计算机的结构
11.3 机器语言指令
11.4 汇编语言指令
11.5 压入字符
11.6 aout指令
11.7 使用标号
11.8 使用汇编器
11.9 stav指令
11.10 编译赋值语句
11.11 编译print和println
11.12 输出字符串
11.13 输入十进制数
11.14 入口指导语句
11.15 更多的汇编语言内容
问题
第12章 一个简单的编译器S1
12.1 概述
12.2 源语言
12.3 源语言的文法
12.4 目标语言
12.5 符号表
12.6 代码生成器
12.7 token类
12.8 写出翻译文法
12.9 实现S1编译器
12.10 使用
12.11 关于扩展S1编译器的忠告
12.11.1 更新单词符号管理器
12.11.2 先调试单词符号管理器
12.11.3 选择集合
12.11.4 使用必要的break语句
12.11.5 使用必要的Consume方法调用
12.11.6 正确地解释翻译文法
12.12 对于S2的描述
问题
第13章 JavaCC（选讲）
13.1 概述
13.2 JavaCC中扩展的正规表达式
13.3 JavaCC输入文件
13.4 正规表达式动作描述
13.5 S1j的JavaCC输入文件
13.6 JavaCC产生的文件
13.7 使用星号和加号操作
13.8 选择点和向前看
13.9 JavaCC的选择算法
13.10 语法和语义的向前看描述（选讲）
13.11 用JavaCC仅生成单词符号管理器
13.12 使用单词符号链
13.13 抑制警告信息
问题
第14章 在S2基础上构造
14.1 概述
14.2 扩展println和print
14.3 级联赋值语句
14.4 一元加和减
14.5 readint语句
14.6 从命令行控制单词符号踪迹的生成
14.7 S3的规范
问题
第15章 编译控制结构
15.1 概述
15.2 while语句
15.3 if语句
15.4 do-while语句
15.5 数字常量的范围检查
15.6 处理字符串中的反斜线-引号
15.7 用JavaCC处理反斜线（选讲）
15.8 JavaCC中的全局块（选讲）
15.9 处理跨行字符串
15.10 用JavaCC处理跨行字符串（选讲）
15.11 JavaCC中的SPECIAL_TOKEN块（选讲）
15.12 错误恢复
15.13 JavaCC中的错误恢复（选讲）
15.14 S4的规范
问题
第16章 编译函数形式的程序
16.1 概述
16.2 分别汇编和连接
16.3 调用函数和从函数返回
16.4 S5的源语言
16.5 S5的符号表
16.6 S5的代码生成器
16.7 S5的翻译文法
16.8 与库连接
16.9 S5规范
16.10 扩展S5（选讲）
问题
第17章 有限自动机
17.1 概述
17.2 确定有限自动机
17.3 转换DFA到正规表达式
17.4 DFA的Java代码
17.5 非确定有限自动机
17.6 使用NFA作为一个算法
17.7 利用子集算法转换NFA到DFA
17.8 转换DFA到正规文法
17.9 转换正规文法到
17.10 转换正规表达式到NFA
17.11 求出最小的NFA
17.12 正规语言的泵理论
问题
第18章 课程设计项目：用编译技术实现grep
18.1 概述
18.2 grep程序的正规表达式
18.3 针对正规表达式的单词符号管理器
18.4 正规表达式的文法
18.5 正规表达式编译器的目标语言
18.6 用NFA进行模式匹配
问题
第19章 编译到面向寄存器的结构
19.1 概述
19.2 使用寄存器指令集
19.3 修改R1符号表
19.4 R1的语法分析器和代码生成器
问题
第20章 优化
20.1 概述
20.2 使用ldc指令
20.3 重用临时变量
20.4 常量合并
20.5 寄存器分配
20.6 窥孔优化
问题
第21章 解释器
21.1 概述
21.2 转换S1到I1
21.3 解释转移控制的语句
21.4 实现编译：解释器CI1
21.5 解释器的优点
问题
第22章 自下而上语法分析
22.1 概述
22.2 自下而上语法分析原理
22.3 语法分析：右递归文法对比左递归文法
22.4 用二义文法进行自下而上语法分析
22.5 不归约规则
22.6 SLR（1）语法分析
22.7 移进/归约冲突
22.8 归约/归约冲突
22.9 LR（1）语法分析
问题
第23章 yacc
23.1 概述
23.2 yacc输入和输出文件
23.3 一个yacc-生成的简单语法分析器
23.4 用取值栈传递值
23.5 对二义文法使yacc
23.6 在语法分析树中传递值
23.7 实现Sly
23.8 jflex
问题
附录A 栈指令集
附录B 寄存器指令集
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>编译器构造
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE 6开发手册•高级篇（第4版）
第Ⅰ部分 简介
第1 章 概述 2
1.1  Java EE 6 平台的亮点 3
1.2  Java EE 应用程序模型 4
1.3  分布式多层应用程序4
1.3.1  安全 5
1.3.2  Java EE 组件5
1.3.3  Java EE 客户端6
1.3.4  Web 组件8
1.3.5  业务组件8
1.3.6  企业信息系统层9
1.4  Java EE 容器9
1.4.1  容器服务9
1.4.2  容器类型10
1.5  Web Service 支持11
1.5.1  XML 12
1.5.2  SOAP 传输协议12
1.5.3  WSDL 标准格式12
1.6  Java EE 应用程序的装配和部署12
1.7  打包应用程序13
1.8.1  开发角色14
1.8.2  Java EE 产品提供方14
1.8.3  工具提供方15
1.8.4  应用程序组件提供方15
1.8.5  应用程序装配方15
1.8.6  应用程序部署方和管理方16
1.9   Java EE 6 API 16
1.9.1  Enterprise JavaBean 技术19
1.9.2  Java Servlet 技术19
1.9.3  JavaServer Faces 技术20
1.9.4  JavaServer Pages 技术20
1.9.5  JavaServer Pages 标准标签库21
1.9.6  Java 持久化API21
1.9.7  Java 事务API 21
1.9.8  支持RESTful Web Service 的Java API21
1.9.9  Managed Beans22
1.9.10 Java EE 平台上下文和依赖注入（JSR 299）22
1.9.11 Java 依赖注入（JSR 330）22
1.9.12 Bean Validation  22
1.9.13 Java 消息服务API 23
1.9.14 Java EE 连接器架构23
1.9.15 JavaMail API23
1.9.16 Java Authorization Contract for Containers 23
1.9.17 Java Authentication Service Provider Interface for Containers 24
1.10在Java 平台标准版6 和7 中的Java EE 6 API 24
1.10.1 Java 数据库连接API 24
1.10.2 Java 命名和目录接口API 24
1.10.3 JavaBeans Activation Framework  25
1.10.4 Java XML 处理API  25
1.10.5 Java XML 绑定架构 25
1.10.6 SOAP with Attachments API for Java 26
1.10.7 Java API for XML Web Services 26
1.10.8 Java 认证和授权服务 26
1.10.9 GlassFish Server 工具  26
第2 章 使用本教程的示例程序 28
2.1  所需软件 28
2.1.1  Java 平台标准版本 28
2.1.2 Java EE 6 软件开发工具集29
2.1.3 Java EE 6 教程组件 29
2.1.4 NetBeans IDE 30
2.1.5 Apache Ant 31
2.2  启动及停止GlassFish Serv er 32
2.3  启动管理控制台  33
2.4  启动和停止Java DB 服务 33
2.5  构建示例程序 34
2.6  本教程示例程序的目录结构 34
2.7  获取示例程序的最新更新  35
2.8  调试Java EE 应用程序 35
2.8.1 使用服务器日志  35
2.8.2 使用调试器  36
第Ⅱ部分 Web 层
第3 章 JavaServer Faces 技术：高级概念 38
3.1  JavaServer Faces 应用程序的生命周期 8
3.1.1 JavaServer Faces 生命周期概述  39
3.1.2 恢复视图阶段 41
3.1.3应用请求值阶段 42
3.1.4处理校验阶段 42
3.1.5更新模型值阶段 43
3.1.6调用应用程序阶段 43
3.1.7渲染响应阶段 43
3.2  局部处理和局部渲染. 44
3.3  Facelets 应用程序的生命周期 44
3.4  用户界面组件模型 45
3.4.1 用户界面组件类 45
3.4.2组件渲染模型 47
3.4.3 转换模型  48
3.4.4事件和监听器模型 49
3.4.5校验模型 50
3.4.6导航模型 51
第4 章 在JavaServer Faces 技术中使用Ajax  54
4.1  Ajax 概述  55
4.2  在JavaServer Faces 技术中使用Ajax 功能 55
4.3  在Facelets 中使用Ajax  56
4.3.1使用f:ajax 标签56
4.3.2发送一个Ajax 请求58
4.3.3使用event 属性 58
4.3.4使用execute 属性  59
4.3.5使用immediate 属性 59
4.3.6使用listener 属性 59
4.4  监视客户端事件 60
4.5  处理错误  60
4.6  接收Ajax 响应  61
4.7  Ajax 请求生命周期 62
4.8  对组件进行分组  62
4.9  以资源形式加载JavaScript 63
4.9.1在Facelets 应用程序中使用JavaScript API 63
4.9.2在Bean 类中使用@ResourceDependency 注解 64
4.10  ajaxguessnumber 示例应用程序65
4.10.1 ajaxguessnumber 源文件 65
4.10.2运行ajaxguessnumber 示例程序 67
4.10.3更多有关JavaServer Faces 技术中Ajax 的信息68
第5 章 复合组件：高级主题及示例程序69
复合组件的属性 69
调用Managed Bean 70
校验复合组件的值 70
compositecomponentlogin 示例程序 71
复合组件文件 71
调用 Managed Bean 70
校验复合组件的值70
compositecomponentlogin 示例程序 71
复合组件文件 71
用到的页面 72
Managed Bean 72
运行 compositecomponentlogin 示例程序 74
第6 章 创建自定义UI 组件以及其他自定义对象 . 76
决定你是否需要一个自定义组件或者渲染器 78
何时使用自定义组件 78
何时使用自定义渲染器 79
组件、渲染器和标签的组合80
理解图像映射示例程序 80
为什么使用JavaServer Faces 技术来实现图像映射 81
理解渲染的HTML  81
理解Facelets 页面 82
配置模型数据 83
Image Map 应用程序类总结85
创建自定义组件的步骤 85
创建自定义组件类 86
指定组件类族 88
执行编码 89
执行解码 91
允许组件属性接受表达式  91
保存及恢复状态  93
将渲染工作委托给渲染器  94
创建渲染器类 94
标识渲染器类型 96
实现事件监听器 96
实现值改变监听器实现动作监听器 98
处理自定义组件的事件98
在标签库描述符中定义自定义组件标签 100
使用自定义组件  101
创建和使用自定义转换器 102
创建自定义转换器 103
使用自定义转换器105
创建和使用自定义校验器  107
实现校验器接口 108
指定自定义标签 110
使用自定义校验器 111
将组件值和实例与Managed Bean 属性绑定112
将组件值与bean 属性绑定 113
将组件值与隐式对象绑定114
将组件实例与bean 属性绑定 115
将转换器、监听器以及校验器与Managed Bean 属性绑定 116
第7 章 配置JavaServer Faces 应用程序 118
使用注解来配置Managed Bean 119
使用Managed Bean 作用域 119
应用程序配置资源文件 120
应用程序配置资源文件的顺序 121
配置Managed Bean  123
使用managed-bean 元素 123
使用managed-property 元素来初始化属性 126
初始化Map 和List 131
注册应用程序消息  132
使用FacesMessage 来创建消息 133
引用错误消息 133
使用默认校验器  134
注册自定义校验器 135
注册自定义转换器 135
配置导航规则 136
隐式的导航规则 139
使用渲染套件来注册自定义渲染器. 139
注册自定义组件  141
JavaServer Faces 应用程序的基本要求 142
使用web 部署描述符来配置应用程序 143
配置项目阶段 146
包含类、页面和其他资源 147
第8 章 使用Java Servlet 技术上传文件148
@MultipartConfig 注解  148
getParts 和getPart 方法 149
fileupload 示例程序 150
fileupload 示例程序的架构  150
运行fileupload 示例 153
第9 章 国际化和本地化Web 应用程序. 155
Java 平台本地化类  155
提供本地化的消息和标签（label） 156
建立语言环境 157
设置资源绑定 157
获取本地化消息 158
日期和数字格式化 159
字符集和编码  159
字符集 159
字符编码 160
第Ⅲ部分 Web Service
第10 章 JAX-RS：高级主题和示例162
用于资源类字段和Bean 属性的注解 162
提取路径参数 163
提取查询参数 164
提取表单数据 164
提取请求或响应中的Java 类型 165
子资源和运行时资源解决方案165
子资源方法 165
子资源定位符 166
整合JAX-RS、EJB 技术和CDI 167
条件性HTTP 请求 168
运行时内容协商169
在JAX-RS 中使用JAXB 171
使用Java 对象为数据建模从已有的XML schema 定义开始 174
在JAX-RS 和JAXB 中使用JSON  176
customer 示例程序  177
customer 示例程序概述177
Customer 和Address 实体类 178
CustomerService 类 181
CustomerClientXML 和CustomerClientJSON 类 184
修改示例，根据已有的schema 生成实体类 186
运行customer 示例 188
第Ⅳ部分 Enterprise Beans
第11 章 Message-Driven Bean 示例 196
simplemessage 示例概述  196
simplemessage 应用程序客户端  197
Message-Driven Bean 类  197
onMessage 方法 199
运行simplemessage 示例程序  200
simplemessage 示例的被管理对象 200
删除simplemessage 示例的被管理对象 202
第12 章 使用嵌入式Enterprise Bean 容器  203
嵌入式enterprise bean 容器概述  203
开发嵌入式enterprise bean 应用程序  203
运行嵌入式应用程序 204
创建enterprise bean 容器 204
查找session bean 引用 205
关闭enterprise bean 容器 206
standalone 示例程序206
第13 章 在Session Bean 中使用异步方法调用208
异步方法调用 208
创建异步的业务方法209
从enterprise bean 客户端调用异步方法 210
async 示例程序211
async 示例程序的架构 211
运行async 示例  212
第Ⅴ部分 Java EE 平台上下文和依赖注入
第14 章 Java EE 平台上下文和依赖注入：高级篇 218
在CDI 应用程序中使用替代类 218
使用特例 219
在CDI 应用程序中使用生产者方法、生产者字段以及清理方法 220
使用生产者方法221
使用生产者字段来生成资源 222
使用清理方法222
在CDI 应用程序中使用预定义的Bean223
在CDI 应用程序中使用事件 224
定义事件 224
使用观察者方法来处理事件触发事件 225
在CDI 应用程序中使用拦截器 226
在CDI 应用程序中使用装饰器  228
在CDI 应用程序中使用模板229
第15 章 运行上下文和依赖注入的高级示例程序 231
encoder 示例：使用替代类231
Coder 接口和实现 232
encoder 示例中的Facelets 页面和managed bean 232
运行encoder 示例 234
producermethods 示例：使用生产者方法来选择bean 实现236
producermethods 示例的组件 237
运行producermethods 示例 238
producerfields 示例：使用生产者字段来生成资源 239
producerfields 示例的生产者字段 239
producerfields 实体和session bean 241
producerfields 示例的Facelets 页面和managed bean 242
运行producerfields 示例244
billpayment 示例：使用事件和拦截器 246
PaymentEvent 事件类246
PaymentHandler 事件监听器 247
billpayment 示例的Facelets 页面和managed bean 247
LoggedInterceptor 拦截器类 250
运行billpayment 示例 251
decorators 示例：装饰bean 252
decorators 示例的组件 253
运行decorators 示例 254
第Ⅵ部分 持久化
第16 章 创建并使用基于字符串的条件（Criteria）查询 258
基于字符串的Criteria API 查询概述  258
创建基于字符串的查询  259
执行基于字符串的查询 260
第17 章 使用锁来控制对实体数据的并发访问261
实体锁和并发概述261
使用乐观锁262
锁模式262
设置锁模式 263
使用悲观锁264
第18 章 在Java 持久化 API 应用程序中使用二级缓存 266
二级缓存概述 266
控制实体是否可能被缓存 267
指定缓存模式设置以提高性能268
设置缓存读取和存储模式用编程方式控制二级缓存270
第Ⅶ部分 安全
第19 章 Java EE 安全：高级篇 274
使用数字签名  274
创建服务器证书275
将用户添加到证书域中 277
在GlassFish Server 中使用不同的服务器证书  277
认证机制  278
客户端认证 279
双向认证279
在JavaServer Faces Web 应用程序中使用基于表单的登录  283
在JavaServer Faces 表单中使用j_security_check 283
在JavaServer Faces 应用程序中使用managed bean 进行认证284
使用JDBC 域进行用户认证286
保护HTTP 资源的安全290
保护应用程序客户端的安全 293
使用登录模块 294
使用编程式登录 294
保护企业信息系统应用程序的安全  295
由容器管理的登录 295
由组件管理的登录 295
配置资源适配器安全296
使用部署描述符来配置安全选项 298
在部署描述符中指定基本认证在部署描述符中覆盖默认的用户-角色映射299
关于安全的更多信息 299
第Ⅷ部分 Java EE 的其他技术
第20 章 Java 消息服务概念 302
JMS API 概述 302
什么是消息传递 302
什么是JMS API 303
什么时候可以使用JMS API 303
JMS API 如何与Java EE 平台一起工作  304
JMS API 基础概念 305
JMS API 架构消息传递域 306
消息接收 308
JMS API 编程模型 308
JMS 管理对象 309
JMS 连接 310
JMS 会话 311
JMS 消息生产者 311
JMS 消息消费者 312
JMS 消息 314
JMS 队列浏览器316
JMS 异常处理 316
创建健壮的JMS 应用程序  317
使用基础的可靠性机制 318
使用高级的可靠性机制321
在Java EE 应用程序中使用JMS API 325
在enterprise bean 或web 容器中使用@Resource 注解 325
使用session bean 来生产和同步接收消息 326
使用Message-Driven Bean 来异步接收消息 326
管理分布式事务 329
在应用程序客户端和web 组件中使用JMS API 330
关于JMS 的更多信息  331
第21 章 Java 消息服务示例  332
编写简单的JMS 应用程序  333
同步消息接收的简单示例  333
异步消息接收的简单示例 343
浏览队列中消息的简单示例348
在多个系统上运行JMS 客户端 353
取消部署并清理JMS 示例 359
编写健壮的JMS 应用程序  359
消息应答示例 359
可持续订阅示例 362
本地事务示例 364
使用JMS API 和Session Bean 的应用程序 370
为clientsessionmdb 示例编写应用程序组件370
为clientsessionmdb 示例创建资源 372
运行 clientsessionmdb 示例 372
使用JMS API 和实体的应用程序 374
clientmdbentity 示例程序概述 374
为clientmdbentity 示例编写应用程序组件375
为clientmdbentity 示例创建资源378
运行 clientmdbentity 示例 378
从远程服务器接收消息的应用程序示例 381
consumeremote 示例模块概述 382
为consumeremote 示例编写模块组件 383
为consumeremote 示例创建资源 383
为consumeremote 示例使用两个应用程序服务器 383
运行consumeremote 示例 384
在两个服务器上部署Message-Driven Bean 的应用程序示例 387
sendremote 示例模块概述 388
编写sendremote 示例的模块组件 389
为sendremote 示例创建资源 390
运行sendremote 示例 392
第22 章 Bean Validation：高级主题 398
创建自定义约束 398
使用内置约束来创建新的约束 398
自定义校验器消息 399
ValidationMessages 资源绑定 399
约束分组 400
自定义组校验顺序 400
第23 章 使用Java EE 拦截器 402
拦截器概述 402
拦截器类 403
拦截器的生命周期 403
拦截器和CDI 403
使用拦截器 403
拦截方法调用 404
拦截生命周期回调事件 406
拦截超时事件 407
interceptor 示例程序  408
运行interceptor 示例 409
第24 章 资源适配器示例 410
资源适配器 410
Message-Driven Bean 411
Web 应用程序  411
运行mailconnector 示例 411
第Ⅸ部分 案例研究
第25 章 Duke’s Bookstore 案例研究示例 416
Duke’s Bookstore 的设计和架构 416
Duke’s Bookstore 的接口 417
Java 持久化API 实体Book 417
Duke’s Bookstore 中使用的Enterprise beans  418
Duke’s Bookstore 中使用的Facelets 页面和Managed Beans 418
Duke’s Bookstore 中使用的自定义组件和其他自定义对象420
Duke’s Bookstore 中使用的属性文件 420
Duke’s Bookstore 中使用的部署描述符  421
运行 Duke’s Bookstore 案例研究应用程序 422
第26 章 Duke’s Tutoring 案例研究示例424
Duke’s Tutoring 的设计和架构 424
主界面 426
主界面中使用的Java 持久化API 实体 426
主界面中使用的enterprise bean 426
主界面中使用的Facelets 文件 427
主界面中使用的辅助类 428
属性文件 429
Duke’s Tutoring 中使用的部署描述符 429
管理界面  430
管理界面中使用的enterprise bean 430
管理界面中使用的Facelets 文件 430
运行Duke’s Tutoring 案例研究应用程序 431
设置GlassFish Server 431
运行Duke’s Tutoring 432
第27 章 Duke’s Forest 案例研究示例434
Duke’s Forest 的设计和架构 435
events 项目 437
entities 项目 438
dukes-payment 项目440
dukes-resource 项目 440
Duke’s Store 项目 440
Duke’s Shipment 项目 445
构建并部署Duke’s Forest 案例研究应用程序 447
前提条件447
运行Duke’s Forest 应用程序 450
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE 6开发手册•高级篇（第4版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE设计模式解析与应用
目    录
第Ⅰ部分  Java EE设计模式介绍
第1章  设计模式概览	3
1.1  何为设计模式	4
1.1.1  如何检测模式，为何需要模式	6
1.1.2  现实世界中的模式	6
1.2  设计模式基础	8
1.3  企业模式	8
1.3.1  从Java到企业级Java	9
1.3.2  企业Java模式的出现	10
1.3.3  设计模式与企业模式	11
1.3.4  当传统设计模式遇到Java EE	12
1.3.5  当模式变成反模式	13
1.4  小结	14
1.5  相关资料	14
第2章  Java EE基础	17
2.1  多层架构	19
2.2  客户端层	20
2.3  中间层	21
2.3.1  Web层	21
2.3.2  业务层	22
2.4  EIS层	23
2.5  Java EE服务器	24
2.6  Java EE Web Profile	25
2.7  Java EE核心原则	25
2.8  约定优于配置	26
2.9  上下文与依赖注入	26
2.10  拦截器	28
2.11  小结	30
2.12  本章练习	30
第Ⅱ部分  实现Java EE设计模式
第3章  门面模式	33
3.1  何为门面	34
3.2  使用普通代码实现门面模式	36
3.3  使用Java EE实现门面模式	38
3.3.1  使用无状态Bean实现门面	38
3.3.2  使用有状态Bean实现门面	41
3.4  何时以及何处该使用门面模式	42
3.5  小结	43
3.6  本章练习	43
3.7  相关资料	43
第4章  单例模式	45
4.1  何为单例？	46
4.1.1  单例模式类图	47
4.1.2  使用普通代码实现单例模式	48
4.2  使用Java EE实现单例模式	53
4.2.1  单例Bean	53
4.2.2  在启动时使用单例	54
4.2.3  确定启动顺序	56
4.2.4  管理并发	59
4.3  何处以及何时该使用单例模式	63
4.4  小结	63
4.5  本章练习	64
4.6  相关资料	65
第5章  依赖注入与CDI	67
5.1  何为依赖注入？	68
5.2  使用普通代码实现DI	69
5.3  使用Java EE实现DI	73
5.3.1  @Named注解	75
5.3.2  上下文与依赖注入(CDI)	76
5.3.3  CDI与EJB	77
5.3.4  CDI Bean	77
5.3.5  @Inject注解	79
5.3.6  上下文与作用域	79
5.3.7  命名与EL	80
5.3.8  用于Backing JSF的CDI Bean	81
5.3.9  限定符	81
5.3.10  Alternatives	82
5.3.11  Stereotypes	83
5.3.12  通过CDI实现的其他模式	84
5.4  小结	84
5.5  本章练习	85
5.6  相关资料	85
第6章  工厂模式	87
6.1  何为工厂？	88
6.2  工厂方法	89
6.3  抽象工厂	94
6.4  使用Java EE实现工厂模式	96
6.5  何处以及何时该使用工厂模式	110
6.6  小结	111
6.7  本章练习	111
6.8  相关资料	111
第7章  装饰模式	113
7.1  何为装饰器？	114
7.2  使用普通代码实现装饰模式	116
7.3  使用Java EE实现装饰模式	121
7.4  何处以及何时该使用装饰模式	129
7.5  小结	130
7.6  本章练习	130
7.7  相关资料	131
第8章  面向方面编程(拦截器)	133
8.1  何为面向方面编程？	134
8.2  使用普通代码实现AOP	137
8.3  Java EE中的方面—— 拦截器	140
8.3.1  拦截器生命周期	145
8.3.2  默认级别的拦截器	146
8.3.3  拦截器顺序	147
8.3.4  CDI拦截器	150
8.4  何处以及何时该使用拦截器	153
8.5  小结	154
8.6  相关资料	155
第9章  异步	157
9.1  何为异步编程	158
9.2  使用普通代码实现异步模式	161
9.3  Java EE中的异步编程	164
9.3.1  异步Bean	164
9.3.2  异步Servlet	167
9.4  何处以及何时该使用异步编程	172
9.5  小结	174
9.6  本章练习	174
9.7  相关资料	175
第10章  定时器服务	177
10.1  何为定时器服务	178
10.2  使用Java EE实现定时器	181
10.2.1  自动化定时器	181
10.2.2  编程式定时器	183
10.2.3  定时器表达式	187
10.2.4  事务	190
10.3  小结	191
10.4  本章练习	192
10.5  相关资料	192
第11章  观察者模式	193
11.1  何为观察者？	194
11.1.1  说明	195
11.1.2  观察者类图	197
11.2  使用普通代码实现观察者模式	197
11.3  使用Java EE实现观察者模式	200
11.4  何处以及何时该使用观察者模式	209
11.5  小结	210
11.6  本章练习	211
11.7  相关资料	211
第12章  数据访问模式	213
12.1  何为数据访问模式？	214
12.2  数据访问模式概览	216
12.2.1  数据传输对象模式	216
12.2.2  Java持久化架构API与对象关系映射	217
12.3  使用Java EE实现数据访问模式	218
12.4  何处以及何时该使用数据访问模式	227
12.5  小结	227
12.6  本章练习	228
12.7  相关资料	228
第13章  REST风格的Web Service	229
13.1  何为REST？	230
13.2  REST的6个约束	232
13.2.1  客户端-服务器	233
13.2.2  统一接口	233
13.2.3  无状态	233
13.2.4  可缓存	233
13.2.5  分层系统	234
13.2.6  按需编码	234
13.3  REST API的理查森能力成熟度模型	234
13.3.1  级别0：POX(Plain Old XML)沼泽	235
13.3.2  级别1：资源	235
13.3.3  级别2：HTTP动词	235
13.3.4  级别3：超媒体控件	235
13.4  设计REST风格的API	235
13.4.1  资源命名	236
13.4.2  名词而非动词	237
13.4.3  自说明	237
13.4.4  复数而非单数	237
13.4.5  HTTP方法	238
13.4.6  GET	238
13.4.7  POST	239
13.4.8  PUT	239
13.4.9  DELETE	240
13.5  REST实战	240
13.5.1  users名词	240
13.5.2  topics名词与posts名词	242
13.6  使用Java EE实现REST	244
13.7  HATEOAS	249
13.8  何处以及何时该使用REST	253
13.9  小结	253
13.10  本章练习	254
13.11  相关资料	254
第14章  模型、视图与控制器模式	255
14.1  何为MVC设计模式？	256
14.2  使用普通代码实现MVC模式	260
14.3  使用Java EE实现MVC模式	265
14.4  FacesServlet	265
14.5  使用FacesServlet实现MVC	266
14.6  何处以及何时该使用MVC模式	269
14.7  小结	269
14.8  本章练习	270
14.9  相关资料	270
第15章  Java EE中的其他模式	271
15.1  何为WebSockets？	272
15.2  何为面向消息的中间件	275
15.3  何为微服务架构？	277
15.3.1  单块架构	278
15.3.2  可伸缩性	279
15.3.3  分解为服务	280
15.3.4  微服务的好处	281
15.3.5  天下没有免费的午餐	282
15.3.6  结论	283
15.4  一些反模式	284
15.4.1  超级类	284
15.4.2  面条架构	284
15.4.3  哥伦布先生	285
15.4.4  利益之交	285
15.4.5  前沿技术	286
15.4.6  辅助类	286
15.5  相关资料	287
第Ⅲ部分  总    结
第16章  设计模式：好处、坏处与丑陋之处	291
16.1  好处：通往成功之路的模式	292
16.2  坏处：模式的过度使用与滥用	294
16.3  丑陋之处	296
16.4  小结	298
16.5  相关资料	298
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE设计模式解析与应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JavaScript高级程序设计（第3版）
目　　录
第1章　JavaScript简介　　1
1.1　JavaScript简史　　1
1.2　JavaScript实现　　2
1.2.1　ECMAScript　　3
1.2.2　文档对象模型（DOM）　　5
1.2.3　浏览器对象模型（BOM）　　8
1.3　JavaScript版本　　8
1.4　小结　　9
第2章　在HTML中使用JavaScript　　10
2.1　<script>元素　　10
2.1.1　标签的位置　　12
2.1.2　延迟脚本　　13
2.1.3　异步脚本　　13
2.1.4　在XHTML中的用法　　14
2.1.5　不推荐使用的语法　　16
2.2　嵌入代码与外部文件　　16
2.3　文档模式　　16
2.4　<noscript>元素　　18
2.5　小结　　18
第3章　基本概念　　19
3.1　语法　　19
3.1.1　区分大小写　　19
3.1.2　标识符　　19
3.1.3　注释　　20
3.1.4　严格模式　　20
3.1.5　语句　　20
3.2　关键字和保留字　　21
3.3　变量　　22
3.4　数据类型　　23
3.4.1　typeof操作符　　23
3.4.2　Undefined类型　　24
3.4.3　Null类型　　25
3.4.4　Boolean类型　　26
3.4.5　Number类型　　27
3.4.6　String类型　　32
3.4.7　Object类型　　35
3.5　操作符　　36
3.5.1　一元操作符　　36
3.5.2　位操作符　　39
3.5.3　布尔操作符　　44
3.5.4　乘性操作符　　47
3.5.5　加性操作符　　48
3.5.6　关系操作符　　50
3.5.7　相等操作符　　51
3.5.8　条件操作符　　53
3.5.9　赋值操作符　　53
3.5.10　逗号操作符　　54
3.6　语句　　54
3.6.1　if语句　　54
3.6.2　do-while语句　　55
3.6.3　while语句　　55
3.6.4　for语句　　56
3.6.5　for-in语句　　57
3.6.6　label语句　　58
3.6.7　break和continue语句　　58
3.6.8　with语句　　60
3.6.9　switch语句　　60
3.7　函数　　62
3.7.1　理解参数　　64
3.7.2　没有重载　　66
3.8　小结　　67
第4章　变量、作用域和内存问题　　68
4.1　基本类型和引用类型的值　　68
4.1.1　动态的属性　　68
4.1.2　复制变量值　　69
4.1.3　传递参数　　70
4.1.4　检测类型　　72
4.2　执行环境及作用域　　73
4.2.1　延长作用域链　　75
4.2.2　没有块级作用域　　76
4.3　垃圾收集　　78
4.3.1　标记清除　　78
4.3.2　引用计数　　79
4.3.3　性能问题　　80
4.3.4　管理内存　　81
4.4　小结　　81
第5章　引用类型　　83
5.1　Object类型　　83
5.2　Array类型　　86
5.2.1　检测数组　　88
5.2.2　转换方法　　89
5.2.3　栈方法　　90
5.2.4　队列方法　　91
5.2.5　重排序方法　　92
5.2.6　操作方法　　94
5.2.7　位置方法　　95
5.2.8　迭代方法　　96
5.2.9　缩小方法　　97
5.3　Date类型　　98
5.3.1　继承的方法　　100
5.3.2　日期格式化方法　　101
5.3.3　日期/时间组件方法　　102
5.4　RegExp类型　　103
5.4.1　RegExp实例属性　　105
5.4.2　RegExp实例方法　　106
5.4.3　RegExp构造函数属性　　107
5.4.4　模式的局限性　　109
5.5　Function类型　　110
5.5.1　没有重载（深入理解）　　111
5.5.2　函数声明与函数表达式　　111
5.5.3　作为值的函数　　112
5.5.4　函数内部属性　　113
5.5.5　函数属性和方法　　116
5.6　基本包装类型　　118
5.6.1　Boolean类型　　120
5.6.2　Number类型　　120
5.6.3　String类型　　122
5.7　单体内置对象　　130
5.7.1　Global对象　　131
5.7.2　Math对象　　134
5.8　小结　　137
第6章　面向对象的程序设计　　138
6.1　理解对象　　138
6.1.1　属性类型　　139
6.1.2　定义多个属性　　142
6.1.3　读取属性的特性　　143
6.2　创建对象　　144
6.2.1　工厂模式　　144
6.2.2　构造函数模式　　144
6.2.3　原型模式　　147
6.2.4　组合使用构造函数模式和原型模式　　159
6.2.5　动态原型模式　　159
6.2.6　寄生构造函数模式　　160
6.2.7　稳妥构造函数模式　　161
6.3　继承　　162
6.3.1　原型链　　162
6.3.2　借用构造函数　　167
6.3.3　组合继承　　168
6.3.4　原型式继承　　169
6.3.5　寄生式继承　　171
6.3.6　寄生组合式继承　　172
6.4　小结　　174
第7章　函数表达式　　175
7.1　递归　　177
7.2　闭包　　178
7.2.1　闭包与变量　　181
7.2.2　关于this对象　　182
7.2.3　内存泄漏　　183
7.3　模仿块级作用域　　184
7.4　私有变量　　186
7.4.1　静态私有变量　　188
7.4.2　模块模式　　189
7.4.3　增强的模块模式　　191
7.5　小结　　192
第8章　BOM　　193
8.1　window对象　　193
8.1.1　全局作用域　　193
8.1.2　窗口关系及框架　　194
8.1.3　窗口位置　　197
8.1.4　窗口大小　　198
8.1.5　导航和打开窗口　　199
8.1.6　间歇调用和超时调用　　203
8.1.7　系统对话框　　205
8.2　location对象　　207
8.2.1　查询字符串参数　　207
8.2.2　位置操作　　208
8.3　navigator对象　　210
8.3.1　检测插件　　211
8.3.2　注册处理程序　　213
8.4　screen对象　　214
8.5　history对象　　215
8.6　小结　　216
第9章　客户端检测　　217
9.1　能力检测　　217
9.1.1　更可靠的能力检测　　218
9.1.2　能力检测，不是浏览器检测　　220
9.2　怪癖检测　　220
9.3　用户代理检测　　221
9.3.1　用户代理字符串的历史　　222
9.3.2　用户代理字符串检测技术　　228
9.3.3　完整的代码　　242
9.3.4　使用方法　　245
9.4　小结　　246
第10章　DOM　　247
10.1　节点层次　　247
10.1.1　Node类型　　248
10.1.2　Document类型　　253
10.1.3　Element类型　　261
10.1.4　Text类型　　270
10.1.5　Comment类型　　273
10.1.6　CDATASection类型　　274
10.1.7　DocumentType类型　　274
10.1.8　DocumentFragment类型　　275
10.1.9　Attr类型　　276
10.2　DOM操作技术　　277
10.2.1　动态脚本　　277
10.2.2　动态样式　　279
10.2.3　操作表格　　281
10.2.4　使用NodeList　　283
10.3　小结　　284
第11章　DOM扩展　　286
11.1　选择符API　　286
11.1.1　querySelector()方法　　286
11.1.2　querySelectorAll()
方法　　287
11.1.3　matchesSelector()
方法　　288
11.2　元素遍历　　288
11.3　HTML5　　289
11.3.1　与类相关的扩充　　289
11.3.2　焦点管理　　291
11.3.3　HTMLDocument的变化　　292
11.3.4　字符集属性　　293
11.3.5　自定义数据属性　　293
11.3.6　插入标记　　294
11.3.7　scrollIntoView()方法　　298
11.4　专有扩展　　298
11.4.1　文档模式　　298
11.4.2　children属性　　299
11.4.3　contains()方法　　300
11.4.4　插入文本　　301
11.4.5　滚动　　303
11.5　小结　　304
第12章　DOM2和DOM3　　305
12.1　DOM变化　　305
12.1.1　针对XML命名空间的变化　　306
12.1.2　其他方面的变化　　309
12.2　样式　　312
12.2.1　访问元素的样式　　313
12.2.2　操作样式表　　317
12.2.3　元素大小　　320
12.3　遍历　　326
12.3.1　NodeIterator　　328
12.3.2　TreeWalker　　330
12.4　范围　　332
12.4.1　DOM中的范围　　332
12.4.2　IE8及更早版本中的范围　　340
12.5　小结　　343
第13章　事件　　345
13.1　事件流　　345
13.1.1　事件冒泡　　346
13.1.2　事件捕获　　346
13.1.3　DOM事件流　　347
13.2　事件处理程序　　348
13.2.1　HTML事件处理程序　　348
13.2.2　DOM0级事件处理程序　　350
13.2.3　DOM2级事件处理程序　　351
13.2.4　IE事件处理程序　　352
13.2.5　跨浏览器的事件处理程序　　353
13.3　事件对象　　355
13.3.1　DOM中的事件对象　　355
13.3.2　IE中的事件对象　　358
13.3.3　跨浏览器的事件对象　　360
13.4　事件类型　　362
13.4.1　UI事件　　362
13.4.2　焦点事件　　367
13.4.3　鼠标与滚轮事件　　368
13.4.4　键盘与文本事件　　379
13.4.5　复合事件　　384
13.4.6　变动事件　　385
13.4.7　HTML5事件　　388
13.4.8　设备事件　　395
13.4.9　触摸与手势事件　　399
13.5　内存和性能　　402
13.5.1　事件委托　　402
13.5.2　移除事件处理程序　　404
13.6　模拟事件　　405
13.6.1　DOM中的事件模拟　　405
13.6.2　IE中的事件模拟　　410
13.7　小结　　411
第14章　表单脚本　　412
14.1　表单的基础知识　　412
14.1.1　提交表单　　413
14.1.2　重置表单　　414
14.1.3　表单字段　　414
14.2　文本框脚本　　419
14.2.1　选择文本　　420
14.2.2　过滤输入　　423
14.2.3　自动切换焦点　　426
14.2.4　HTML5约束验证API　　427
14.3　选择框脚本　　431
14.3.1　选择选项　　432
14.3.2　添加选项　　434
14.3.3　移除选项　　435
14.3.4　移动和重排选项　　435
14.4　表单序列化　　436
14.5　富文本编辑　　438
14.5.1　使用contenteditable
属性　　438
14.5.2　操作富文本　　439
14.5.3　富文本选区　　441
14.5.4　表单与富文本　　443
14.6　小结　　443
第15章　使用Canvas绘图　　445
15.1　基本用法　　445
15.2　2D上下文　　446
15.2.1　填充和描边　　446
15.2.2　绘制矩形　　447
15.2.3　绘制路径　　449
15.2.4　绘制文本　　451
15.2.5　变换　　453
15.2.6　绘制图像　　456
15.2.7　阴影　　457
15.2.8　渐变　　458
15.2.9　模式　　460
15.2.10　使用图像数据　　460
15.2.11　合成　　462
15.3　WebGL　　463
15.3.1　类型化数组　　463
15.3.2　WebGL上下文　　468
15.3.3　支持　　478
15.4　小结　　478
第16章　HTML5脚本编程　　480
16.1　跨文档消息传递　　480
16.2　原生拖放　　481
16.2.1　拖放事件　　482
16.2.2　自定义放置目标　　482
16.2.3　dataTransfer对象　　483
16.2.4　dropEffect与effectAllowed　　484
16.2.5　可拖动　　485
16.2.6　其他成员　　485
16.3　媒体元素　　486
16.3.1　属性　　487
16.3.2　事件　　488
16.3.3　自定义媒体播放器　　488
16.3.4　检测编解码器的支持情况　　489
16.3.5　Audio类型　　490
16.4　历史状态管理　　491
16.5　小结　　492
第17章　错误处理与调试　　493
17.1　浏览器报告的错误　　493
17.1.1　IE　　493
17.1.2　Firefox　　494
17.1.3　Safari　　496
17.1.4　Opera　　497
17.1.5　Chrome　　498
17.2　错误处理　　499
17.2.1　try-catch语句　　500
17.2.2　抛出错误　　503
17.2.3　错误（error）事件　　505
17.2.4　处理错误的策略　　506
17.2.5　常见的错误类型　　507
17.2.6　区分致命错误和非致命
错误　　510
17.2.7　把错误记录到服务器　　511
17.3　调试技术　　512
17.3.1　将消息记录到控制台　　512
17.3.2　将消息记录到当前页面　　515
17.3.3　抛出错误　　515
17.4　常见的IE错误　　516
17.4.1　操作终止　　516
17.4.2　无效字符　　518
17.4.3　未找到成员　　518
17.4.4　未知运行时错误　　519
17.4.5　语法错误　　519
17.4.6　系统无法找到指定资源　　519
17.5　小结　　520
第18章　JavaScript与XML　　521
18.1　浏览器对XML DOM的支持　　521
18.1.1　DOM2级核心　　521
18.1.2　DOMParser类型　　522
18.1.3　XMLSerializer类型　　523
18.1.4　IE8及之前版本中的XML　　523
18.1.5　跨浏览器处理XML　　527
18.2　浏览器对XPath的支持　　529
18.2.1　DOM3级XPath　　529
18.2.2　IE中的XPath　　534
18.2.3　跨浏览器使用XPath　　535
18.3　浏览器对XSLT的支持　　537
18.3.1　IE中的XSLT　　537
18.3.2　XSLTProcessor类型　　541
18.3.3　跨浏览器使用XSLT　　543
18.4　小结　　544
第19章　E4X　　546
19.1　E4X的类型　　546
19.1.1　XML类型　　546
19.1.2　XMLList类型　　547
19.1.3　Namespace类型　　548
19.1.4　QName类型　　549
19.2　一般用法　　550
19.2.1　访问特性　　551
19.2.2　其他节点类型　　552
19.2.3　查询　　553
19.2.4　构建和操作XML　　555
19.2.5　解析和序列化　　557
19.2.6　命名空间　　558
19.3　其他变化　　559
19.4　全面启用E4X　　560
19.5　小结　　561
第20章　JSON　　562
20.1　语法　　562
20.1.1　简单值　　562
20.1.2　对象　　563
20.1.3　数组　　564
20.2　解析与序列化　　565
20.2.1　JSON对象　　565
20.2.2　序列化选项　　566
20.2.3　解析选项　　569
20.3　小结　　570
第21章　Ajax与Comet　　571
21.1　XMLHttpRequest对象　　571
21.1.1　XHR的用法　　573
21.1.2　HTTP头部信息　　575
21.1.3　GET请求　　576
21.1.4　POST请求　　577
21.2　XMLHttpRequest 2级　　578
21.2.1　FormData　　578
21.2.2　超时设定　　579
21.2.3　overrideMimeType()
方法　　580
21.3　进度事件　　580
21.3.1　load事件　　580
21.3.2　progress事件　　581
21.4　跨源资源共享　　582
21.4.1　IE对CORS的实现　　582
21.4.2　其他浏览器对CORS的
实现　　584
21.4.3　Preflighted Reqeusts　　584
21.4.4　带凭据的请求　　585
21.4.5　跨浏览器的CORS　　585
21.5　其他跨域技术　　586
21.5.1　图像Ping　　586
21.5.2　JSONP　　587
21.5.3　Comet　　588
21.5.4　服务器发送事件　　590
21.5.5　Web Sockets　　591
21.5.6　SSE与Web Sockets　　593
21.6　安全　　593
21.7　小结　　594
第22章　高级技巧　　596
22.1　高级函数　　596
22.1.1　安全的类型检测　　596
22.1.2　作用域安全的构造函数　　597
22.1.3　惰性载入函数　　600
22.1.4　函数绑定　　602
22.1.5　函数柯里化　　604
22.2　防篡改对象　　606
22.2.1　不可扩展对象　　606
22.2.2　密封的对象　　607
22.2.3　冻结的对象　　608
22.3　高级定时器　　609
22.3.1　重复的定时器　　610
22.3.2　Yielding Processes　　612
22.3.3　函数节流　　614
22.4　自定义事件　　616
22.5　拖放　　618
22.5.1　修缮拖动功能　　620
22.5.2　添加自定义事件　　622
22.6　小结　　624
第23章　离线应用与客户端存储　　626
23.1　离线检测　　626
23.2　应用缓存　　627
23.3　数据存储　　628
23.3.1　Cookie　　629
23.3.2　IE用户数据　　637
23.3.3　Web存储机制　　638
23.3.4　IndexedDB　　643
23.4　小结　　654
第24章　最佳实践　　656
24.1　可维护性　　656
24.1.1　什么是可维护的代码　　656
24.1.2　代码约定　　657
24.1.3　松散耦合　　659
24.1.4　编程实践　　662
24.2　性能　　666
24.2.1　注意作用域　　666
24.2.2　选择正确方法　　667
24.2.3　最小化语句数　　672
24.2.4　优化DOM交互　　673
24.3　部署　　676
24.3.1　构建过程　　676
24.3.2　验证　　677
24.3.3　压缩　　679
24.4　小结　　681
第25章　新兴的API　　682
25.1　requestAnimationFrame()　　682
25.1.1　早期动画循环　　682
25.1.2　循环间隔的问题　　683
25.1.3　mozRequestAnimation-Frame　　683
25.1.4　webkitRequestAnima-tionFrame与msRequest-AnimationFrame　　685
25.2　Page Visibility API　　686
25.3　Geolocation API　　687
25.4　File API　　689
25.4.1　FileReader类型　　690
25.4.2　读取部分内容　　692
25.4.3　对象URL　　693
25.4.4　读取拖放的文件　　694
25.4.5　使用XHR上传文件　　695
25.5　Web计时　　696
25.6　Web Workers　　697
25.6.1　使用Worker　　697
25.6.2　Worker全局作用域　　698
25.6.3　包含其他脚本　　699
25.6.4　Web Workers的未来　　700
25.7　小结　　700
附录A　ECMAScript Harmony　　701
附录B　严格模式　　717
附录C　JavaScript库　　723
附录D　JavaScript工具　　727

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JavaScript高级程序设计（第3版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE WEB开发与项目实战
第1章  Web开发基础	1
1.1  服务器及开发环境配置	1
1.1.1  Tomcat服务器安装	1
1.1.2  Apache+Tomcat整合	4
1.1.3  开发工具的使用	10
1.2  XHTML网站开发案例	17
1.2.1  静态网站开发流程简介	17
1.2.2  Web标准	20
1.2.3  赛车主题网制作	22
第2章  Java EE Web开发技术要点案例	26
2.1  验证码的使用	26
2.1.1  验证码原理及生成方法	26
2.1.2  JSP验证码	28
2.1.3  Servlet验证码	31
2.2  数据库连接	34
2.2.1  JavaBean/JDBC	34
2.2.2  数据库连接池	40
2.3  密码的加密与解密	46
2.3.1  密码加密基础	46
2.3.2  密码的MD5加密	48
2.4  过滤器的使用	55
2.4.1  过滤器概述	55
2.4.2  Filter用户权限控制	59
2.4.3  解决中文乱码问题	61
2.5  用户登录(身份认证)	64
2.5.1  Servlet身份验证	64
2.5.2  Ajax/Servlet身份验证	76
2.6  邮件收发	88
2.6.1  JavaMail API下载与安装	89
2.6.2  JavaMail API邮件发送	89
2.7  Web在线编辑器的使用	97
2.7.1  Web在线编辑器简介	97
2.7.2  CKeditor在线编辑器的配置与使用	97
2.8  在Web应用中实现文件上传	100
2.8.1  JspSmartUpload组件简介	100
2.8.2  利用JspSmartUpload组件上传	107
2.9  Java EE开发框架	110
2.9.1  Struts	111
2.9.2  JSF	119
2.9.3  Spring	131
2.9.4  Hibernate	136
2.10  Ajax框架	144
第3章  文章管理系统	148
3.1  系统分析和设计	148
3.1.1  文章管理系统简要需求	148
3.1.2  系统体系设计	149
3.2  数据库设计	150
3.2.1  E-R图	150
3.2.2  数据库表结构	151
3.3  系统主要功能实现	152
3.3.1  文章管理主调度Ajax程序	153
3.3.2  文章管理主Servlet程序	169
3.4  小结	177
第4章  文件收发在线管理系统	178
4.1  系统分析和设计	178
4.1.1  文件收发管理系统需求	178
4.1.2  系统体系设计	179
4.2  数据库设计	179
4.2.1  E-R图	179
4.2.2  数据库表结构	180
4.3  系统主要功能实现	183
4.3.1  系统主体结构	183
4.3.2  发文	187
4.3.3  文档在线自动格式转换为Flash预览	196
4.4  小结	200
第5章  图片网站	201
5.1  系统分析和设计	201
5.1.1  系统分析	201
5.1.2  系统设计	201
5.2  数据库设计	204
5.2.1  数据库需求分析	204
5.2.2  数据库逻辑设计	204
5.2.3  数据库脚本文件	208
5.2.4  数据库的链接	210
5.3  站点模块具体设计	212
5.3.1  前台浏览模块	212
5.3.2  后台管理模块	223
5.4  缩略图的生成	234
5.5  小结	241
第6章  交友网站	242
6.1  系统分析与设计	242
6.1.1  功能说明	242
6.1.2  系统体系设计	243
6.2  数据库设计	244
6.3  系统主要功能实现	248
6.3.1  JavaBean	248
6.3.2  JSP页面	253
6.3.3  登录模块	271
6.3.4  配置文件	279
6.4  小结	280
第7章  美容行业门户网站	281
7.1  系统分析和设计	281
7.1.1  系统分析	281
7.1.2  系统设计	282
7.2  数据库设计	286
7.2.1  数据库需求分析	286
7.2.2  数据库逻辑设计	286
7.2.3  数据库脚本文件	297
7.2.4  数据库的链接	304
7.3  站点模块具体设计	306
7.3.1  前台操作模块	306
7.3.2  后台管理模块	315
7.4  小结	325
第8章  物流服务管理系统	326
8.1  系统分析和设计	326
8.1.1  用例模型	326
8.1.2  领域模型	329
8.1.3  系统活动图	330
8.2  数据库设计	331
8.3  系统主要功能实现	333
8.3.1  JSP页面	335
8.3.2  ActionForm	336
8.3.3  Action的实现	339
8.3.4  业务处理类	346
8.3.5  域模型	351
8.3.6  映射文件	351
8.3.7  Hibernate的配置文件及DAO的实现	353
8.4  小结	355
第9章  基于Web的通用在线题库管理系统	356
9.1  系统体系结构分析和设计	356
9.1.1  背景	356
9.1.2  题库系统体系结构设计	357
9.2  系统分析和设计	357
9.2.1  系统设计原则	357
9.2.2  系统工作流程分析	359
9.2.3  总体模块及关键问题分析	360
9.2.4  CI设计	362
9.3  数据库设计	364
9.3.1  E-R图	364
9.3.2  表设计	365
9.4  系统主要功能实现	370
9.4.1  系统实现应遵循的原则	370
9.4.2  共用信息处理	371
9.4.3  系统管理模块	374
9.4.4  题目管理模块	376
9.5  系统测试及结果分析	378
9.6  小结	380
第10章  FTP文件搜索服务系统	381
10.1  系统分析和设计	381
10.1.1  背景	381
10.1.2  系统体系结构设计	381
10.2  数据库设计	383
10.3  系统主要功能实现	383
10.3.1  爬虫程序模块	384
10.3.2  FTP索引Web模块	396
10.4  小结	412
参考文献	414
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE WEB开发与项目实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Effective Java（第2版）英文版
推荐序
前言
1 Introduction
2 Creating and Destroying Objects
Item 1: Consider static factory methods instead of constructors
Item 2: Consider a builder when faced with many constructor parameters
Item 3: Enforce the singleton property with a private constructor or an enum type
Item 4: Enforce noninstantiability with a private constructor
Item 5: Avoid creating unnecessary objects
Item 6: Eliminate obsolete object references
Item 7: Avoid finalizers
3 Methods Common to All Objects
Item 8: Obey the general contract when overriding  equals
Item 9: Always override  hashCode when you override  equals
Item 10: Always override  toString
Item 11: Override  clone judiciously
Item 12: Consider implementing  Comparable
4 Classes and Interfaces
Item 13: Minimize the accessibility of classes and members
Item 14: In public classes, use accessor methods, not public fields
Item 15: Minimize mutability
Item 16: Favor composition over inheritance
Item 17: Design and document for inheritance or else prohibit it
Item 18: Prefer interfaces to abstract classes
Item 19: Use interfaces only to define types
Item 20: Prefer class hierarchies to tagged classes
Item 21: Use function objects to represent strategies
Item 22: Favor static member classes over nonstatic
5 Generics
Item 23: Don’t use raw types in new code
Item 24: Eliminate unchecked warnings
Item 25: Prefer lists to arrays
Item 26: Favor generic types
Item 27: Favor generic methods
Item 28: Use bounded wildcards to increase API flexibility
Item 29: Consider typesafe heterogeneous containers
6 Enums and Annotations
Item 30: Use enums instead of  int constants
Item 31: Use instance fields instead of ordinals
Item 32: Use  EnumSet instead of bit fields
Item 33: Use  EnumMap instead of ordinal indexing
Item 34: Emulate extensible enums with interfaces
Item 35: Prefer annotations to naming patterns
Item 36: Consistently use the  Override annotation
Item 37: Use marker interfaces to define types
7 Methods
Item 38: Check parameters for validity
Item 39: Make defensive copies when needed
Item 40: Design method signatures carefully
Item 41: Use overloading judiciously
Item 42: Use varargs judiciously
Item 43: Return empty arrays or collections, not nulls
Item 44: Write doc comments for all exposed API elements
8 General Programming
Item 45: Minimize the scope of local variables
Item 46: Prefer for-each loops to traditional  for loops
Item 47: Know and use the libraries
Item 48: Avoid  float and  double if exact answers are required
Item 49: Prefer primitive types to boxed primitives
Item 50: Avoid strings where other types are more appropriate
Item 51: Beware the performance of string concatenation
Item 52: Refer to objects by their interfaces
Item 53: Prefer interfaces to reflection
Item 54: Use native methods judiciously
Item 55: Optimize judiciously
Item 56: Adhere to generally accepted naming conventions
9 Exceptions
Item 57: Use exceptions only for exceptional conditions
Item 58: Use checked exceptions for recoverable conditions and runtime exceptions for programming errors
Item 59: Avoid unnecessary use of checked exceptions
Item 60: Favor the use of standard exceptions
Item 61: Throw exceptions appropriate to the abstraction
Item 62: Document all exceptions thrown by each method
Item 63: Include failure-capture information in detail messages
Item 64: Strive for failure atomicity
Item 65: Don’t ignore exceptions
10 Concurrency
Item 66: Synchronize access to shared mutable data
Item 67: Avoid excessive synchronization
Item 68: Prefer executors and tasks to threads
Item 69: Prefer concurrency utilities to  wait and  notify
Item 70: Document thread safety
Item 71: Use lazy initialization judiciously
Item 72: Don’t depend on the thread scheduler
Item 73: Avoid thread groups
11 Serialization
Item 74: Implement  Serializable judiciously
Item 75: Consider using a custom serialized form
Item 76: Write  readObject methods defensively
Item 77: For instance control, prefer enum types to  readResolve
Item 78: Consider serialization proxies instead of serialized instances
Appendix: Items Corresponding to First Edition
References
Index
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Effective Java（第2版）英文版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>21天学通Java Web开发
第一篇 Java Web基础篇	23
第1章 搭建开发环境（教学视频：53分钟）	23
1.1 下载并安装JDK	23
1.1.1 下载JDK	23
1.1.2 安装JDK	25
1.1.3 配置环境变量	26
1.1.4 一个简单的Java程序	27
1.2 下载并安装Tomcat	28
1.2.1 下载Tomcat	28
1.2.2 安装Tomcat	28
1.2.3 配置虚拟目录	30
1.2.4 一个简单的JSP程序	30
1.3 下载并安装Eclipse	30
1.3.1 下载Eclipse	31
1.3.2 安装Eclipse	31
1.4 下载并安装MyEclipse	31
1.4.1 下载MyEclipse	32
1.4.2 安装MyEclipse	32
1.5 使用MyEclipse进行Web开发	33
1.5.1 使用MyEclipse新建Web项目	33
1.5.2 MyEclipse中新建JSP页面	34
1.5.3 MyEclipse整合Tomcat	35
1.5.4 MyEclipse部署项目	38
1.6 小结	39
第2章 JSP的基础语法（教学视频：27分钟）	40
2.1 JSP简介	40
2.2 JSP运行机制	41
2.3 JSP脚本元素	42
2.3.1 JSP声明语句	43
2.3.2 JSP Scriptlets	43
2.3.3 JSP表达式	44
2.4 注释	45
2.5 综合练习	46
2.6 小结	48
2.7 习题	48
第二篇 JSP 2.0开发篇	50
第3章 JSP指令元素（教学视频：37分钟）	50
3.1 page指令	50
3.1.1 language属性	50
3.1.2 extends属性	51
3.1.3 import属性	51
3.1.4 session属性	52
3.1.5 buffer属性	52
3.1.6 autoFlush属性	52
3.1.7 isThreadSafe属性	52
3.1.8 info属性	52
3.1.9 errorPage属性	53
3.1.10 isErrorPage属性	53
3.1.11 contentType属性	53
3.1.12 pageEncoding属性	54
3.1.13 isELIgnored属性	55
3.2 include指令	55
3.2.1 包含文本文件	55
3.2.2 包含HTML文件	57
3.2.3 包含JSP文件	58
3.3 taglib指令	59
3.4 综合练习	60
3.5 小结	61
3.6 习题	61
第4章 JSP动作元素（教学视频：31分钟）	63
4.1 JSP动作元素分类	63
4.2 [jsp:include]动作元素	63
4.2.1 使用[jsp:include]动作元素包含静态的文件	64
4.2.2 使用[jsp:include]动作元素包含动态的文件	64
4.2.3 [jsp:include]和[%@ include%]的区别	65
4.3 [jsp:forward]动作元素	67
4.3.1 使用[jsp: forward ]动作元素实现页面跳转	67
4.3.2 跳转执行流程	68
4.4 [jsp:param]动作元素	69
4.4.1 [jsp:include]动作元素搭配[jsp:param]动作元素	69
4.4.2 [jsp:forward]动作元素搭配[jsp:param]动作元素	71
4.5 [jsp:plugin]、[jsp:params]和[jsp:fallback]	73
4.5.1 [jsp:plugin]动作元素	73
4.5.2 [jsp:params]动作元素	75
4.5.3 [jsp:fallback]动作元素	76
4.6 综合练习	77
4.7 小结	78
4.8 习题	78
第5章 JSP内置对象（教学视频：51分钟）	80
5.1 JSP内置对象分类	80
5.2 属性保存范围	81
5.2.1 page范围	81
5.2.2 request范围	82
5.2.3 session范围	84
5.2.4 application范围	86
5.2.5 移除属性	87
5.3 request对象	88
5.3.1 获得客户端请求参数	88
5.3.2 获得所有的参数名称	90
5.3.3 获得参数的所有参数值	92
5.3.4 获得封装所有参数值的Map	93
5.3.5 request对象的其他方法	94
5.4 response对象	95
5.4.1 实现页面跳转	95
5.4.2 实现页面自动刷新	96
5.4.3 实现页面自动跳转	96
5.5 out对象	97
5.5.1 使用out对象进行页面输出	97
5.5.2 使用out对象求得缓冲区使用大小	98
5.6 session对象	99
5.6.1 设置并获得session生命周期	99
5.6.2 获得session的其他信息	100
5.7 application对象	101
5.7.1 通过application对象获得服务器版本	101
5.7.2 通过application对象获得其他信息	102
5.8 pageContext对象	103
5.9 page对象	104
5.10 config对象	105
5.11 exception对象	105
5.12 综合练习	107
5.13 小结	109
5.14 习题	109
第6章 数据库操作（教学视频：9分钟）	111
6.1 下载并安装MySQL	111
6.1.1 下载MySQL	111
6.1.2 安装MySQL	112
6.2 JDBC驱动程序	112
6.2.1 下载并安装MySQL的JDBC驱动程序	112
6.2.2 加载JDBC驱动程序	113
6.3 JDBC连接MySQL数据库	114
6.3.1 创建数据库和数据表	114
6.3.2 连接MySQL数据库	115
6.4 语句对象Statement	116
6.4.1 添加记录	117
6.4.2 更新记录	118
6.4.3 删除记录	119
6.5 ResultSet结果集	120
6.5.1 获得所有记录	120
6.5.2 获得指定字段记录	122
6.5.3 获得指定起始位置和条数的记录	123
6.6 数据库的关闭操作	124
6.7 预处理语句对象PreparedStatement	125
6.7.1 添加记录	126
6.7.2 更新记录	127
6.7.3 删除记录	129
6.7.4 获得指定记录	130
6.8 综合练习	132
6.9 小结	134
6.10 习题	134
第7章 JSP和JavaBean（教学视频：34分钟）	135
7.1 JavaBean简单使用	135
7.1.1 JavaBean简介	135
7.1.2 定义JavaBean	135
7.1.3 在JSP中调用JavaBean	136
7.2 设置JavaBean属性	137
7.2.1 根据所有参数设置JavaBean属性	137
7.2.2 根据指定参数设置JavaBean属性	139
7.2.3 根据指定参数设置指定JavaBean属性	140
7.2.4 设置指定JavaBean属性为指定值	141
7.3 获得JavaBean属性	142
7.4 设置JavaBean的范围	143
7.4.1 设置page范围的JavaBean	143
7.4.2 设置request范围的JavaBean	144
7.4.3 设置session范围的JavaBean	145
7.4.4 设置application范围的JavaBean	147
7.5 移除JavaBean	148
7.6 综合练习	150
7.7 小结	151
7.8 习题	151
第8章 EL表达式（教学视频：49分钟）	153
8.1 EL运算符	153
8.1.1 算术运算符	153
8.1.2 关系运算符	154
8.1.3 逻辑运算符	155
8.1.4 条件运算符	157
8.1.5 验证运算符	158
8.1.6 括号运算符及运算符的优先级	159
8.2 EL内置对象	160
8.2.1 .与[ ]运算符	160
8.2.2 与存储有关的内置对象	161
8.2.3 与输入有关的内置对象	162
8.2.4 cookie内置对象	163
8.2.5 header内置对象	165
8.2.6 initParam内置对象	165
8.2.7 pageContext内置对象	166
8.3 EL存取器	167
8.3.1 使用存取器读取JavaBean中的数据	167
8.3.2 使用存取器读取Map中的数据	170
8.3.3 使用存取器读取数组中的数据	171
8.3.4 存取器复杂应用	172
8.4 综合练习	173
8.5 小结	175
8.6 习题	175
第9章 JSTL标签库（教学视频：75分钟）	177
9.1 JSTL核心标签	177
9.1.1 [c:set]标签	177
9.1.2 [c:out]标签	177
9.1.3 [c:remove]标签	178
9.1.4 [c:if]标签	179
9.1.5 [c:choose]、[c:when]、[c:otherwise]标签	179
9.1.6 [c:forEach]标签	180
9.1.7 [c:forTokens]标签	181
9.1.8 [c:import]标签	181
9.1.9 [c:param]标签	181
9.1.10 [c:url]标签	182
9.1.11 [c:redirect]标签	182
9.2 数据库标签库	182
9.2.1 [sql:setDataSource]标签	183
9.2.2 [sql:update]标签	183
9.2.3 [sql:query]标签	184
9.2.4 [sql:param]和[sql:dateParam]标签	186
9.2.5 [sql:transaction ]标签	187
9.3 I18N格式化标签库	188
9.3.1 [fmt: formatNumber]标签	188
9.3.2 [fmt: parseNumber]标签	190
9.3.3 [fmt: formatDate]标签	190
9.3.4 [fmt: parseDate]标签	191
9.3.5 [fmt: setTimeZone]标签	191
9.3.6 [fmt: timeZone]标签	192
9.3.7 [fmt: setLocale]标签	192
9.3.8 [fmt: requestEncoding]标签	193
9.3.9 [fmt: setBundle]标签	193
9.3.10 [fmt: message]标签	193
9.3.11 [fmt: param]	194
9.3.12 [fmt: bundle]	194
9.4 XML标签库	194
9.4.1 下载并安装进行XML操作必需的JAR文件	194
9.4.2 [x:parse]标签	195
9.4.3 [x:out]标签	196
9.4.4 [x:set]标签	197
9.4.5 [x:if]标签	197
9.4.6 [x:choose]标签	198
9.4.7 [x:forEach]标签	199
9.5 综合练习	199
9.6 小结	200
9.7 习题	200
第三篇 Servlet开发篇	202
第10章 Servlet开发基础（ 教学视频：41分钟）	202
10.1 Servlet基础	202
10.1.1 Servlet简介	202
10.1.2 第一个Servlet程序	202
10.1.3 Servlet生命周期	203
10.2 HttpServlet常用方法	204
10.2.1 doGet方法	204
10.2.2 doPost方法	206
10.2.3 service方法..	207
10.3 Servlet常用接口	209
10.3.1 HttpServletRequest接口	209
10.3.2 HttpServletResponse接口	211
10.3.3 HttpSession接口	212
10.3.4 ServletContext接口	214
10.4 综合练习	216
10.5 小结	217
10.6 习题	217
第11章 Filter开发（教学视频：41分钟）	219
11.1 Filter基础	219
11.1.1 Filter简介	219
11.1.2 第一个Filter程序	219
11.1.3 Filter生命周期	220
11.2 常用Filter	221
11.2.1 非法文字过滤器	222
11.2.2 字符编码过滤器	224
11.2.3 登录验证过滤器	226
11.3 综合练习	229
11.4 小结	230
11.5 习题	230
第12章 Listener开发（ 教学视频：26分钟）	231
12.1 Listener简介	231
12.2 ServletContext Listener	231
12.2.1 ServletContextListener接口	231
12.2.2 ServletContextAttributeListener接口	232
12.3 HttpSession Listener	234
12.3.1 HttpSessionListener接口	234
12.3.2 HttpSessionAttributeListener接口	235
12.4 综合练习	236
12.5 小结	239
12.6 习题	239
第四篇 使用设计模式篇	241
第13章 DAO设计模式（教学视频：21分钟）	241
13.1 DAO简介	241
13.2 DAO各部分详解	241
13.2.1 数据库连接类	241
13.2.2 VO类	242
13.2.3 DAO接口	243
13.2.4 DAO实现类	244
13.2.5 DAO工厂类	246
13.3 使用DAO完成数据库操作	247
13.3.1 添加记录	247
13.3.2 更新记录	248
13.3.3 删除记录	248
13.3.4 按ID查询记录	249
13.4 综合练习	250
13.5 小结	251
13.6 习题	251
第14章 MVC设计模式（教学视频：22分钟）	252
14.1 MVC简介	252
14.2 Model 1和Model 2	252
14.3 使用MVC模式改进用户登录案例	254
14.3.1 用户登录页面	254
14.3.2 用户登录成功和失败页面	255
14.3.3 业务逻辑组件	256
14.3.4 Servlet控制器	256
14.4 综合练习	258
14.5 小结	260
14.6 习题	260
第五篇 框架技术篇	261
第15章 Struts 2基础（教学视频：41分钟）	261
15.1 Struts 2简介	261
15.2 Struts 2框架的下载和安装	262
15.2.1 下载Struts 2框架	262
15.2.2 安装Struts 2框架	263
15.3 基于Struts 2框架实现登录案例	264
15.3.1 准备工作	264
15.3.2 新建控制类Action	264
15.3.3 配置Action	265
15.3.4 程序执行流程	266
15.4 改进控制器	266
15.4.1 实现Action接口	267
15.4.2 配置Action	268
15.5 完成输入校验	268
15.5.1 使用Struts 2标签库简化表单	268
15.5.2 继承ActionSupport完成输入校验	270
15.6 程序国际化	272
15.6.1 输出中文的校验错误信息	272
15.6.2 国际化资源文件	273
15.6.3 加载资源文件	275
15.6.4 输出国际化信息	275
15.6.5 输出国际化的校验错误信息	277
15.7 综合练习	278
15.8 小结	279
15.9 习题	279
第16章 Struts 2高级应用（教学视频：51分钟）	281
16.1 Struts 2内建的类型转换器	281
16.1.1 内建转换器介绍	281
16.1.2 基本数据类型转换器	281
16.1.3 基本数据类型的封装类转换器	285
16.1.4 数组类型转换器	287
16.1.5 集合类型转换器	289
16.2 服务器端校验	290
16.2.1 服务器端校验的重要性	290
16.2.2 完成服务器端输入校验	291
16.2.3 使页面保留提交信息	295
16.2.4 使用addFieldError来添加错误信息	297
16.2.5 输入校验与类型转换关系	300
16.3 使用校验框架完成输入校验	301
16.3.1 完成输入校验	301
16.3.2 增加客户端校验	306
16.3.3 国际化提示信息	308
16.3.4 客户端校验与国际化问题	310
16.3.5 校验短路	313
16.3.6 校验规则文件搜索规则	315
16.4 综合练习	316
16.5 小结	316
16.6 习题	317
第17章 持久化框架Hibernate（教学视频：35分钟）	318
17.1 初涉Hibernate	318
17.1.1 ORM简介	318
17.1.2 Hibernate框架的优势	319
17.1.3 下载和安装Hibernate	319
17.1.4 Hibernate架构概述	319
17.2 Hibernate的配置和相关类	321
17.2.1 Configuration类	321
17.2.2 Hibernate配置文件	321
17.2.3 SessionFactory类	322
17.3 Hibernate中的对象	322
17.3.1 对象在Hibernate中的状态	323
17.3.2 持久化类	324
17.3.3 对象识别	325
17.4 Hibernate开发	325
17.4.1 创建Hibernate配置文件	325
17.4.2 创建持久化类	326
17.4.3 创建对象关系映射文件	327
17.4.4 创建数据库表	328
17.4.5 插入数据	329
17.4.6 更新数据	330
17.4.7 删除数据	331
17.4.8 查询数据	332
17.4.9 使用Hibernate工具类	334
17.5 综合练习	335
17.6 小结	336
17.7 习题	336
第18章 Struts 2整合Hibernate开发（教学视频：28分钟）	337
18.1 Struts 2和Hibernate的整合策略	337
18.2 持久层设计	338
18.2.1 DAO接口	338
18.2.2 DAO实现类	338
18.2.3 DAO工厂类	340
18.3 业务逻辑组件	340
18.3.1 业务逻辑组件接口	341
18.3.2 业务逻辑组件实现类	341
18.3.3 业务逻辑组件工厂类	342
18.4 整合应用	343
18.4.1 查询所有产品	343
18.4.2 添加产品	345
18.4.3 删除产品	347
18.4.4 更新产品	348
18.5 小结	350
18.6 习题	350
第19章 Spring开发（教学视频：39分钟）	351
19.1 初探Spring	351
19.1.1 Spring简介	351
19.1.2 下载和安装Spring	352
19.1.3 Spring的IoC应用	353
19.2 Spring的依赖注入	356
19.2.1 通过Set方法注入依赖	356
19.2.2 引用其他的Bean	358
19.2.3 使用构造函数注入依赖	360
19.3 Spring的自动装配	361
19.3.1 自动装配分类	362
19.3.2 byName自动装配	362
19.3.3 byType自动装配	363
19.3.4 constructor自动装配	363
19.4 Spring核心理论：面向切面编程介绍	364
19.4.1 面向切面编程基础知识	364
19.4.2 在Spring中创建前置通知	365
19.4.3 在Spring中创建后置通知	367
19.4.4 在Spring中创建拦截通知	369
19.4.5 在Spring中创建异常通知	371
19.4.6 使用Spring静态切入点	373
19.5 综合练习	373
19.6 小结	375
19.7 习题	375
第20章 Struts 2整合Spring开发（教学视频：32分钟）	376
20.1 安装Spring插件完成整合	376
20.2 整合策略	376
20.3 整合Spring完成登录案例	378
20.3.1 修改控制器Action及配置	378
20.3.2 依赖注入业务逻辑组件	378
20.4 整合Spring完成产品管理案例	379
20.4.1 使用Spring容器管理SessionFactory	379
20.4.2 使用HibernateTemplate进行数据库操作	380
20.4.3 依赖注入DAO组件	381
20.4.4 依赖注入业务逻辑组件	382
20.4.5 完成Action配置	385
20.5 小结	385
20.6 习题	386
第六篇 项目实战篇	387
第21章 SSH整合开发用户管理系统	387
21.1 系统分析	387
21.1.1 应用背景及系统功能介绍	387
21.1.2 系统结构	387
21.1.3 系统功能模块	388
21.2 Hibernate持久层设计	388
21.2.1 创建持久化PO类	388
21.2.2 创建映射文件	389
21.3 DAO层设计	390
21.3.1 Spring管理SessionFactory	390
21.3.2 创建DAO接口	391
21.3.3 创建DAO实现类	391
21.3.4 配置DAO组件	392
21.4 业务逻辑层设计	392
21.4.1 创建业务逻辑组件接口	392
21.4.2 创建业务逻辑组件实现类	392
21.4.3 配置业务逻辑组件	393
21.5 完成查看所有用户信息模块	394
21.5.1 整合Struts 2和Spring	394
21.5.2 创建查看全部用户信息控制器	394
21.5.3 创建全部用户信息显示页	395
21.5.4 配置查看全部用户信息控制器	395
21.5.5 测试查看所有用户信息	396
21.6 完成查看用户详细信息模块	396
21.6.1 创建查看用户详细信息控制器	396
21.6.2 创建查看用户详细信息显示页	397
21.6.3 配置用户详细信息控制器	398
21.6.4 测试查看用户详细信息	398
21.7 完成添加用户模块	398
21.7.1 创建用户添加页	398
21.7.2 创建用户添加控制器	399
21.7.3 配置用户添加控制器	400
21.7.4 创建校验规则文件	400
21.7.5 测试添加用户	402
21.8 完成删除用户模块	403
21.8.1 创建用户删除控制器	403
21.8.2 配置用户删除控制器	403
21.8.3 测试删除用户	404
21.9 完成更新用户模块	404
21.9.1 创建用户更新页	404
21.9.2 创建用户更新控制器	405
21.9.3 配置用户更新控制器	406
21.9.4 创建校验规则文件	406
21.9.5 测试更新用户	406
21.10 小结	407
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>21天学通Java Web开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>SOA与Java：用Java技术实现面向服务
序
作者及贡献者简介
第1章 概述 .1
1.1 关于本书 .1
1.1.1　本书目标 1
1.1.2 本书面向的读者 .1
1.1.3 本书特征 2
1.2 必要阅读 .2
1.3 本书结构 .2
1.4 本书使用原则和模式的方式 4
1.5 符号和图形 .4
第2章 案例分析示例 5
2.1 案例分析示例的使用 5
2.1.1 风格特点 .5
2.1.2 案例与抽象内容的关系 .5
2.1.3 代码示例 5
2.2 案例分析背景：NovoBank 6
2.2.1 技术基础设施 .6
2.2.2 自动化解决方案 6
2.2.3 业务阻碍和目标 7
2.2.4 未来IT路线图 7
2.3 案例分析背景：SmartCredit公司 .8
2.3.1 技术基础设施 .8
2.3.2 自动化解决方案 .8
2.3.3 业务目标 9
2.3.4 未来的IT路线图 .9
第一部分 基 础
第3章 SOA基本概念 .13
3.1 基本术语和概念 .13
3.1.1 面向服务计算 .13
3.1.2 面向服务 15
3.1.3 面向服务架构 .15
3.1.4 SOA宣言 17
3.1.5 服务 .18
3.1.6 云计算 18
3.1.7 IT资源 19
3.1.8 服务模型 19
3.1.9 服务库存 20
3.1.10 服务组合 20
3.1.11 服务候选.21
3.1.12 服务契约 21
3.1.13 服务相关的粒度 .21
3.1.14 服务概要 22
3.1.15 SOA设计模式 22
3.2 延伸阅读 .24
第4章 基本的Java分布式技术 .26
4.1 Java分布式计算的基础知识 .26
4.1.1 Java SE的架构 .27
4.1.2 Java EE的架构 .27
4.1.3 应用程序的打包和部署 .28
4.1.4 Java EE架构的各层 .29
4.2 Java分布式技术和API 30
4.2.1 Java SE API .30
4.2.2 Java EE API 32
4.3 XML标准和Java API 38
4.3.1 XML .39
4.3.2 XML模式定义 .40
4.3.3 XSLT 41
4.3.4 JAXP 41
4.3.5 JAXB 42
4.4 使用Java组件构建服务 42
4.4.1 组件作为服务 42
4.4.2 应用程序协议 42
4.4.3 服务契约 44
4.4.4 组件作为服务和面向服务 .46
4.5 Java供应商平台 47
4.5.1 GlassFish企业服务器 47
4.5.2 IBM WebSphere Application Server 48
4.5.3 IBM WebSphere Application Server Community Edition 50
4.5.4 Oracle WebLogic Server .50
第5章 基于Web的服务技术 52
5.1 基于SOAP的Web服务 .52
5.1.1 Web服务标准的扩展（WS-*） .56
5.1.2 常用Web服务中间件 .61
5.2 REST服务 .64
5.2.1 HTTP响应代码 65
5.2.2 资源和地址 .66
5.2.3 HTTP方法 68
5.2.4 资源表示 69
5.2.5 accept头部 70
第6章 使用Java构建基于Web的服务 .71
6.1 JAX-WS 71
6.1.1 SAAJ 73
6.1.2 处理程序 76
6.1.3 Web服务引擎和工具包 .76
6.1.4 JAXR 77
6.2 WS-*标准的Java实现 78
6.2.1 高级Web服务标准和框架 78
6.2.2 服务组件架构 79
6.2.3 Spring-WS 79
6.3 JAX-RS .80
6.3.1 实现JAX-RS .80
6.3.2 实现REST服务 83
6.3.3 可扩展性 84
6.3.4 安全性 86
6.3.5 REST服务支持 87
第二部分 服 务
第7章 Java基于Web服务中的面向服务原则 91
7.1 服务可重用性 .91
7.1.1 无关功能性上下文 91
7.1.2 高度泛型的服务逻辑 92
7.1.3 泛型可扩展服务契约 94
7.1.4 并发访问服务逻辑 .95
7.2 标准服务契约 .99
7.2.1 自顶向下和自底向上 99
7.2.2 在Java和WSDL之间映射 .100
7.2.3 包装文档/字面值契约 100
7.2.4 隐式和显式头部 .101
7.2.5 REST中的数据映射 .105
7.2.6 使用行业标准 .117
7.3 服务松散耦合 .118
7.3.1 分离契约和实现 .118
7.3.2 独立功能性上下文 .119
7.3.3 服务消费者耦合 .120
7.4 服务抽象 .123
7.4.1 抽象技术细节 .123
7.4.2 隐藏服务细节 .123
7.4.3 文档约束 .126
7.5 服务可组合性 .126
7.5.1 运行时环境的效率 .127
7.5.2 服务契约的灵活性 .128
7.5.3 基于标准的运行时 .128
7.6 服务自治 .129
7.6.1 定义明确的功能边界 .129
7.6.2 控制运行时环境 .129
7.6.3 高并发性 .130
7.7 服务无状态性 .131
7.7.1 编制基础设施 131
7.7.2 会话状态 .132
7.7.3 存储状态 .132
7.8 服务可发现性 .136
7.8.1 设计时的可发现性 .136
7.8.2 运行时的可发现性 .137
7.8.3 服务注册中心 .138
第8章 使用Java构建实用服务 .140
8.1 Java实用服务的原理 140
8.1.1 架构考虑 .140
8.1.2 实用服务分类 .145
8.2 实用服务的设计和实现 146
8.2.1 实用服务的设计 .146
8.2.2 实用服务和Java版本 149
8.2.3 实用服务和开源框架 .150
8.2.4 将实用服务作为基于Web的服务 152
8.2.5 测试考虑 157
8.2.6 打包考虑 157
8.3 实用服务的类型 158
8.3.1 公共实用服务 .158
8.3.2 资源实体服务 .163
8.3.3 微实用服务 .167
8.3.4 包装器实用服务 .169
第9章 使用Java构建实体服务 .173
9.1 Java实体服务的内部原理 .174
9.1.1 架构考虑 .174
9.1.2 域实体与消息实体 .175
9.1.3 数据聚合 .176
9.1.4 数据访问模式 .177
9.1.5 修改通知 .178
9.2 Java实体服务的设计和实现 .179
9.2.1 实体服务设计 .179
9.2.2 实体服务实现 .184
9.2.3 将实体服务作为基于Web的服务 187
9.2.4 使用SOAP的实体Web服务 .187
9.2.5 REST实体服务 .193
9.2.6 测试考虑 201
9.2.7 Java打包考虑 201
第三部分 服务组合与基础设施
第10章 使用Java构建任务服务 .205
10.1 任务服务的内部原理 205
10.2 构建任务服务 .211
10.2.1 实现考虑 .212
10.2.2 基于Web的任务服务 213
10.2.3 测试考虑 .223
10.2.4 打包考虑 .224
第11章 使用Java进行服务组合 .225
11.1 服务组合的内部原理 225
11.1.1 服务组合角色 .225
11.1.2 组合与MEP .226
11.1.3 同步和异步调用 .226
11.1.4 服务水平协议 .227
11.2 Java服务组合的设计和实现 .228
11.2.1 组合逻辑：编码和编制 228
11.2.2 REST服务组合考虑229
11.2.3 组合成员端点 .230
11.2.4 错误处理.231
11.2.5 模式类型重用 .238
11.2.6 基于Web的服务与Java组件 242
11.2.7 打包、测试和部署被组合服务 .244
11.3 服务和服务组合性能指导原则 .248
11.3.1 测量性能.248
11.3.2 测试性能.249
11.3.3 缓存 .249
11.3.4 使用状态扩展服务 .252
11.3.5 处理失败.252
11.3.6 解析和编组 .253
第12章 使用ESB作为SOA基础设施 255
12.1 基本的传统消息框架 .255
12.2 基本的服务消息框架 .261
12.2.1 不使用ESB时的基本服务消息处理 .261
12.2.2 使用ESB时的基本服务消息处理 263
12.3 与SOA相关的常用ESB特性 .267
12.3.1 服务查找和调用 .267
12.3.2 服务处理 .269
12.3.3 服务组合支持 .270
12.3.4 REST API管理支持 270
第四部分 附 录
附录A 案例分析结论 273
附录B 面向服务原则参考 275
附录C SOA设计模式参考 280
附录D 带注释的SOA宣言 312
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>SOA与Java：用Java技术实现面向服务
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大规模Java平台虚拟化与调优
Contents 目 录
译者序
前 言
第1章 大规模Java平台简介1
1.1 大规模Java平台的分类1
1.2 大规模Java平台的趋势与需求2
1.2.1 计算资源合并2
1.2.2 JVM实例合并2
1.2.3 弹性与灵活性3
1.2.4 性能3
1.3 大规模Java平台的技术因素3
1.3.1 Java平台在理论和实际中的限制3
1.3.2 NUMA7
1.3.3 在生产环境中，最为常见的JVM规模13
1.3.4 JVM和VM的水平扩展与垂直扩展13
1.4 本章小结17
第2章 现代化可扩展的数据平台18
2.1 SQLFire的拓扑结构20
2.1.1 客户端/服务器拓扑结构21
2.1.2 端到端拓扑结构23
2.1.3 冗余区23
2.1.4 全球的多点拓扑结构23
2.2 SQLFire特性25
2.2.1 服务器分组27
2.2.2 分区29
2.2.3 冗余31
2.2.4 位置协同32
2.2.5 磁盘持久化33
2.2.6 事务35
2.2.7 缓存插件39
2.2.8 监听器41
2.2.9 writer43
2.2.10 异步监听器44
2.2.11 DBSynchronizer46
2.2.12 SQLF命令与DDLUtils48
2.3 Active-Active架构与现代化数据平台 49
2.4 本章小结52
第3章 大规模Java平台调优53
3.1 GC调优方法58
3.1.1 步骤A：新生代调优58
3.1.2 步骤B：老年代调优62
3.1.3 步骤C：Survivor 空间调优63
3.2 本章小结65
第4章 设计和划分大规模Java平台66
4.1 为虚拟化大规模Java平台设计和划分新环境66
4.1.1 步骤1：建立生产环境下的负载Profile67
4.1.2 步骤2：建立基准67
4.1.3 步骤3：划分生产环境77
4.2 划分vFabric SQLFire Java平台：第二类工作负载78
4.2.1 步骤A：确定实体分组78
4.2.2 步骤B：确定数据Fabric的内存大小81
4.2.3 步骤C：确定模板VM和JVM的大小以及所需的vFabric SQLFire成员数量84
4.2.4 理解HotSpot JVM内部的内存分区 85
4.2.5 理解划分大型VM和JVM时NUMA的影响86
4.2.6 vFabric SQLFire大小划分样例90
4.3 本章小结96
第5章 性能研究97
5.1SQLFire和RDBMS性能研究97
5.1.1性能结果98
5.1.2 结果总结 101
5.2 Olio工作负载运行在tc Server和vSphere上的性能研究101
5.3 SpringTrader性能研究105
5.3.1vSphere应用层和数据层配置107
5.3.2 SpringTrader性能研究结果 110
5.4 ESXi 3、ESXi 4.1和ESXi 5的性能差异111
5.4.1CPU调度改进 111
5.4.2内存增强112
5.5vSphere 5性能提升113
5.6 本章小结114
第6章 最佳实践115
6.1vSphere上企业级Java应用的最佳实践（第一类）117
6.1.1VM规模大小以及配置的最佳实践117
6.1.2VM vCPU的最佳实践118
6.1.3 VM内存划分的最佳实践119
6.1.4 VM时间同步最佳实践122
6.1.5 垂直扩展性的最佳实践122
6.2 水平可扩展性、集群以及池的最佳实践123
6.2.1 分层之间配置的最佳实践124
6.2.2 vSphere的最佳实践126
6.3 SQLFire最佳实践以及vSphere上SQLFire的最佳实践（第二类JVM工作负载的最佳实践）128
6.3.1 SQLFire最佳实践129
6.3.2 在vSphere上vFabric SQLFire的最佳实践131
6.4 第三类工作负载的最佳实践136
6.5 GC策略选择138
6.5.1 IBM GC可选方案139
6.5.2 Oracle jRockit GC策略140
6.6 本章小结140
第7章 监控与故障排除141
7.1 开启请求支持的Ticket142
7.2 通过vCenter收集指标143
7.3 借助esxtop排查vSphere问题的技术146
7.4 Java问题排除指导148
7.4.1 排查Java内存问题150
7.4.2 排查Java线程竞争的问题151
7.5 本章小结152
附录FAQ153
术语表170
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大规模Java平台虚拟化与调优
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>21天学通Java 2 (第二版)
第一部分 第1周课程：java的基本概念
第1章 第1天课程：21世纪的java
1.1 探索java 2
1.1.1 java的过去、现在和未来
1.1.2 交互式web编程
1.1.3 java来自小型的oak语言
1.1.4 java语言的版本
1.1.5 java的前景
1.2 选择java的原因
1.2.1 面向对象
1.2.2 易于学习
1.2.3 平台无关性
1.3 进入java编程
1.3.1 选择java开发工具
1.3.2 安装软件开发工具包
1.4 第1个java程序
1.4.1 创建源文件
1.5 小结
1.6 问题和解答
1.7 小测验
1.7.1 问题
1.7.2 答案
1.8 练习
第2章 第2天课程：面向对象编程
2.1 以对象的形式思考
2.2 对象和类
2.2.1 对象重用
2.3 属性和行为
2.3.1 对象的类的属性
2.3.2 对象的类的行为
2.3.3 创建类
2.3.4 运行程序
2.4 组织类和类行为
2.4.1 继承
2.4.2 创建类层次结构
2.4.3 继承性的使用
2.4.4 单重继承和多重继承
2.4.5 接口
2.4.6 包
2.5 小结
2.6 问题和解答
2.7 小测验
2.7.1 问题
2.7.2 答案
2.8 练习
第3章 第3天课程：java基础
3.1 语句和表达式
3.2 变量和数据类型
3.2.1 创建变量
3.2.2 命名变量
3.2.3 变量类型
3.2.4 数据类型
3.2.5 类的类型
3.2.6 变量赋值
3.2.7 常量
3.3 注释
3.4 文字
3.4.1 数字文字
3.4.2 布尔文字
3.4.3 字符文字
3.4.4 字符串文字
3.5 表达式和运算符
3.5.1 算术运算
3.5.2 赋值的更多内容
3.5.3 加1和减1
3.5.4 比较
3.5.5 逻辑运算符
3.5.6 运算符优先级
3.6 字符串算术运算
3.7 小结
3.8 问题和解答
3.9 小测验
3.9.1 问题
3.9.2 答案
3.10 练习
第4章 第4天课程：使用对象
4.1 创建新对象
4.1.1 使用new
4.1.2 new的功能
4.1.3 内存管理说明
4.2 访问并设置类和实例变量
4.2.1 获得值
4.2.2 修改值
4.2.3 类变量
4.3 调用方法
4.3.1 嵌套方法调用
4.3.2 类方法
4.4 引用对象
4.5 强制转换及转换对象和原始类型
4.5.1 原始类型的强制转换
4.5.2 对象的强制转换
4.5.3 原始类型转换为对象及反过程
4.6 比较对象值和类
4.6.1 比较对象
4.6.2 确定对象的类
4.7 小结
4.8 问题和解答
4.9 小测验
4.9.1 问题
4.9.2 答案
4.10 练习
第5章 第5天课程：列表、逻辑和循环
5.1 数组
5.1.1 严明数组变量
5.1.2 创建数组对象
5.1.3 访问数组元素
5.1.4 修改数组元素
5.1.5 多维数组
5.2 块语句
5.3 证条件
5.4 switch条件
5.5 for循环
5.6 while和do循环
5.6.1 while循环
5.6.2 do…while循环
5.7 跳出循环
5.7.1 标记循环
5.7.2 条件运算符
5.8 小结
5.9 问题和解答
5.10 小测验
5.10.1 问题
5.10.2 答案
5.11 练习
第6章 第6天课程：创建类和方法
6.1 定义类
6.2 创建实例和类变量
6.2.1 定义实例变量
6.2.2 类变量
6.3 创建方法
6.3.1 定义方法
6.3.2 this关键字
6.3.3 变量作用域和方法定义
6.3.4 参数传递给方法
6.3.5 类方法
6.4 创建java应用程序
6.4.1 辅助类
6.5 java应用程序和命令行参数
6.5.1 向java应用程序传递参数
6.5.2 在java应用程序中处理参数
6.6 创建名称相同、参数不同的方法
6.7 构造函数方法
6.7.1 基本构造函数方法
6.7.2 调用另一个构造函数方法
6.7.3 重载构造函数方法
6.8 重载方法
6.8.1 创建重载现存方法的方法
6.8.2 调用初始方法
6.8.3 重载构造函数
6.9 终结方法
6.10 小结
6.11 问题和解答
6.12 小测验
6.12.1 问题
6.12.2 答案
6.13 练习
第7章 第7天课程：编写java小程序
7.1 小程序与应用程序的区别
7.2 小程序安全限制
7.2.1 选择java版本
7.3 创建小程序
7.3.1 主要的小程序活动
7.3.2 示例小程序
7.4 网页上包含小程序
7.4.1 [applet]标记
7.4.2 测试结果
7.4.3 在web上安排小程序
7.5 [applet]标记的其他内容
7.5.1 align
7.5.2 hspace和vspace
7.5.3 code和codebase
7.5.4 [object]标记
7.6 java存档
7.7 向小程序传递参数
7.8 开发java 2小程序
7.8.1 在网页上使用plug－in
7.8.2 运行plug－in
7.9 小结
7.10 问题和解答
7.10.1 问题
7.10.2 解答
7.11 练习
第二部分 第2周课程：swing和其他可视化java编程
第8章 第8天课程：使用swing
8.1 创建应用程序
8.1.1 创建接口
8.1.2 开发框架
8.1.3 关闭窗口
8.1.4 创建组件
8.1.5 在容器中添加组件
8.1.6 在小程序中添加组件
8.2 使用组件
8.2.1 图像图标
8.2.2 标签
8.2.3 文本域
8.2.4 文本区域
8.2.5 滚动窗格
8.2.6 滚动条
8.2.7 复选框和单选按钮
8.2.8 下拉列表和组合框
8.3 小结
8.4 问题和解答
8.4.1 问题
8.4.2 解答
8.5 练习
第9章 第9天课程：建立swing接口
9.1 swing的特征
9.1.1 设置外观和感觉
9.1.2 标准对话框
9.1.3 示例：info应用程序
9.1.4 滑决
9.1.5 滚动窗格
9.1.6 工具栏
9.1.7 进度条
9.2 小结
9.3 问题和解答
9.3.1 问题
9.3.2 答案
9.4 练习
第10章 第10天课程：在用户界面上安排组件
10.1 基本界面布局
10.1.1 安排界面
10.1.2 流动布局
10.1.3 网格布局
10.1.4 边界布局
10.2 混合布局管理器
10.3 卡片布局
10.4 网格袋布局
10.4.1 设计网格
10.4.2 创建网格
10.4.3 确定比例
10.4.4 添加和安排组件
10.4.5 调整
10.5 单元填充和边距
10.6 小结
10.7 问题和解答
10.7.1 问题
10.7.2 答案
10.8 练习
第11章 第11天课程：响应用户输入
11.1 事件监听器
11.1.1 设置组件
11.1.2 事件处理方法
11.2 使用方法
11.2.1 动作事件
11.2.2 调整事件
11.2.3 焦点事件
11.2.4 项目事件
11.2.5 按键事件
11.2.6 鼠标事件
11.2.7 鼠标移动事件
11.2.8 窗口事件
11.2.9 实例：rgb到hsb的转换器
11.2.10 设计布局
11.2.11 定义子面板
11.2.12 在srgb和hsb之间转换
11.2.13 处理用户事件
11.3 小结
11.4 问题和解答
11.4.1 问题
11.4.2 答案
11.5 练习
第12章 第12天课程：颜色、字体和图形
12.1 图形类
12.2 创建绘图接口
12.2.1 转换graphics2d对象
12.2.2 创建应用程序
12.2.3 图形坐标系统
12.3 绘图和填充
12.3.1 线条
12.3.2 拒形
12.3.3 多边形
12.3.4 椭圆形
12.3.5 圆弧
12.3.6 复制和清除
12.4 文本和字体
12.4.1 创建font对象
12.4.2 绘制字符和字符串
12.4.3 查找字体信息
12.5 颜色
12.5.1 使用color对象
12.5.2 测试和设置当前颜色
12.6 使用java2d的高级图形操作
12.6.1 用户和设备坐标空间
12.6.2 指定渲染属性
12.6.3 创建要绘制对象
12.6.4 绘制对象
12.6.5 2d绘图示例
12.7 小结
12.8 问题和解答
12.8.1 问题
12.8.2 答案
12.9 练习
第13章 第13天课程：线程和动画
13.1 在java中创建动画
13.1.1 绘图和重新绘图
13.1.2 动画显示组件
13.1.3 通过线程控制动画
13.1.4 编写线程程序
13.1.5 使用线程的时钟应用程序
13.1.6 停止线程
13.2 检索和使用图像
13.2.1 得到图像
13.2.2 绘制图像
13.2.3 图像观察器
13.3 使用图像创建动画
13.3.1 pixel pete
13.3.2 跟踪图像加载
13.4 小结
13.5 问题和解答
13.5.1 问题
13.5.2 答案
13.6 练习
第14章 第14天课程：javasound
14.1 检索和使用声音
14.2 jaavsound
14.2.1 mid文件
14.2.2 播放midi文件
14.2.3 处理声音文件
14.3 小结
14.4 问题和解答
14.4.1 问题
14.4.2 答案
14.5 练习
第三部分 第3周课程：java高级功能
第15章 第15天课程：包、接口和其他类功能
15.1 修饰符
15.1.1 方法和变量的访问控制
15.2 静态变量和方法
15.3 final类、方法和变量
15.3.1 变量
15.3.2 方法
15.3.3 类
15.4 抽象类和方法
15.5 包
15.5 使用包
15.6.1 完整包和类名称
15.6.2 import声明
15.6.3 名称冲突
15.6.4 classpath和类的位置
15.7 创建包
15.7.1 挑选包名称
15.7.2 创建文件夹结构
15.7.3 在包中添加类
15.7.4 包和类访问控制
15.8 接口
15.8.l 单继承问题
15.8.2 接口和类
15.8.3 实现和使用接口
15.8.4 实现多个接口
15.8.5 接口的其他用途
15.9 创建和扩展接口
15.9.1 新接口
15.9.2 接口内的方法
15.9.3 扩展接口
15.9.4 创建在线storefront程序
15.10 内部类
15.11 小结
15.12 问题和解答
15.12.1 问题
15.12.2 答案
15.13 练习
第16章 第16天课程：错误处理和安全性
16.1 异常——陈旧而令人费解的方法
16.2 java异常
16.3 管理异常
16.3.1 异常一致性检查
16.3.2 保护代码和捕获异常
16.3.3 finally子句
16.4 声明引发异常的方法
16.4.1 throws子句
16.4.2 引发哪个异常
16.4.3 传递异常
16.4.4 thorws和继承
16.5 创建和引发异常
16.5.1 引发异常
16.5.2 创建异常
16.5.3 组合throws、try和throw
16.6 确定使用异常的时机
16.6.1 何时使用异常
16.6.2 何时不使用异常
16.6.3 使用异常的糟糕样式
16.7 用数字签名标识小程序
16.7.1 数字签名示例
16.7.2 测览器的特定签名
16.7.3 安全规则
16.8 小结
16.9 问题和解答
16.9.1 问题
16.9.2 答案
16.10 练习
第17章 第17天课程：通过java流处理数据
17.1 流的基础知识
17.1.1 使用流
17.1.2 过滤流
17.2 字节流
17.2.1 文件流
17.2.2 文件输入流
17.2.3 文件输出流
17.3 过滤流
17.3.1 字节过滤器
17.4 字符流
17.4.1 读取文本文件
17.4.2 写入文本文件
17.5 文件和文件名过滤器
17.6 小结
17.7 问题和解答
17.7.1 问题
17.7.2 答案
17.8 练习
第18章 第18天课程：对象串行化和反射
18.1 对象串行化
18.1.1 对象输出流
18.1.2 对象输入流
18.1.3 过渡变量
18.2 用反射检测类和方法
18.2.1 检测和创建类
18.2.2 使用类的每部分
18.2.3 检测类
18.3 远程方法调用
18.3.1 rmi体系结构
18.3.2 创建rmi应用程序
18.3.3 rmi和安全性
18.4 小结
18.5 问题和解答
18.5.1 问题
18.5.2 答案
18.6 练习
第19章 第19天课程：跨越internet通信
19.1 java连网
19.1.1 在小程序java内创建链接
19.1.2 打开web连接
19.1.3 通过net打开流
19.1.4 套接口
19.1.5 套接口服务器
19.1.6 设计服务器应用程序
19.1.7 实现服务器
19.1.8 测试服务器
19.2 小结
19.3 问题和解答
19.3.1 问题
19.3.2 答案
19.4 练习
第20章 第20天课程：使用javabeans
20.1 可重用软件组件
20.1.1 javabeans的目标
20.1.2 javabeans和java的关系
20.1.3 javabeans api
20.2 开发工具
20.2.1 javabeans development kit
20.3 使用javabeans
20.3.1 bean容器
20.3.2 放置beau
20.3.3 调整bean属性
20.3.4 在beaus之间创建交互
20.3.5 创建javabeans程序
20.3.6 使用其他javabeans
20.4 小结
20.5 问题和解答
20.5.1 问题
20.5.2 答案
20.6 练习
第21章 第21天课程：java数据库连接和数据结构
21.1 java数据库连接
21.1.1 数据库驱动程序
21.1.2 jdbc——odbc桥
21.1.3 连接到odbc数据源
21.1.4 jdbc驱动程序
21.2 数据结构
21.3 java数据结构
21.3.1 iterator
21.3.2 bitset
21.3.3 vector
21.3.4 stack
21.3.5 map
21.3.6 hashtable
21.4 小结
21.5 问题和解答
21.5.1 问题
21.5.2 答案
21.6 练习
附录a 配置sdk
a.1 使用命令行接口
a.1.1 在ms－dos中打开文件夹
a.1.2 在ms-dos中创建文件夹
a.1.3 在ms-dos内运行程序
a.2 配置sdk
a.2.1 设置patm
a.2.2 设置classpath 命令
a.3 unix配置
a.3.1 解决其他平台上的class not found错误
附录b 在sdk中使用文本编辑器
b.1 选择文本编辑器
b.2 在windows中创建文件关联
b.2.1 删除现存的文件关联
b.2.2 创建新关联
b.2.3 建立图标和文件类型的关系
附录c sdk
c.1 sdk概述
c.2 java解释程序
c.3 javac编译器
c.4 appletviewer浏览器
c.5 javadoc文档说明工具
c.6 jdb调试程序
c.6.1 调试应用程序
c.6.2 调试小程序
c.6.3 高级调试命令
c.7 使用系统属性
c.8 小结
c.9 问题和解答
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>21天学通Java 2 (第二版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言程序设计
第1章 Java语言基础知识
1.1 Java语言与面向对象的程序设计
1.1.1 面向对象的程序设计思想
1.1.2 Java语言的特点
1.1.3 Java类库
1.2 Java程序概述
1.2.1 Java开发环境
1.2.2 Application举例
1.2.3 Applet举例
1.2.4 Servlet举例
1.2.5 JSP和JavaBean举例
1.3 基本数据类型与表达式
1.3.1 变量与常量
1.3.2 基本数据类型
1.3.3 表达式与运算符
1.3.4 类型转换
1.4 数组的概念
1.5 数组的创建和引用
1.5.1 数组的声明
1.5.2 数组的创建
1.5.3 数组元素的初始化
1.5.4 数组的引用
1.5.5 多维数组
1.6 本章小结
习题
第2章 类与对象的基本概念
2.1 面向对象的程序设计方法概述
2.1.1 抽象
2.1.2 封装
2.1.3 继承
2.1.4 多态
2.2 类与对象
2.2.1 类的声明
2.2.2 对象的声明与引用
2.2.3 数据成员
2.2.4 方法成员
2.2.5 类的组织——包的概念
2.2.6 类的访问控制
2.2.7 类成员的访问控制
2.3 对象初始化和回收
2.3.1 构造方法
2.3.2 内存回收技术
2.4 应用举例
2.4.1 声明BankAccount类
2.4.2 声明toString()方法
2.4.3 声明存取款方法
2.4.4 使用DecimalFormat类
2.4.5 声明类方法生成特殊的实例
2.4.6 声明类变量
2.5 UML简介
2.5.1 类图
2.5.2 对象图
2.6 本章小结
习题
第3章 类的方法
3.1 方法的控制流程
3.1.1 if选择结构
3.1.2 switch选择结构
3.1.3 for循环结构
3.1.4 while语句
3.1.5 do while语句
3.1.6 break语句
3.1.7 continue语句
3.2 异常处理简介
3.2.1 异常处理的意义
3.2.2 错误的分类
3.2.3 异常的处理
3.2.4 生成异常对象
3.2.5 声明自己的异常类
3.3 方法的重载
3.4 本章小结
习题
第4章 类的重用
第5章 接口与多态
第6章 输入输出流
第7章 对象群体的组织
第8章 多线程
第9章 图形用户界面
第10章 JDBC与数据库访问
第11章 Servlet程序设计
第12章 JSP程序设计
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入体验Java项目开发
第1章 超市管理系统  1.1 第一个项目    1.1.1 项目来源    1.1.2 准备工作  1.2 系统概述和总体设计    1.2.1 系统需求分析    1.2.2 系统demo流程  1.3 数据库设计    1.3.1 选择数据库    1.3.2 数据库结构的设计  1.3 系统框架设计    1.3.1 创建工程及设计主界面    1.3.2 为数据库表添加抽象类    1.3.3 系统登录模块设计  1.4 商品信息管理模块    1.4.1 商品信息管理    1.4.2 采购信息管理    1.4.3 付款信息管理  1.5 用户管理模块    1.5.1 用户添加管理    1.5.2 用户信息查询  1.6 仓库管理模块    1.6.1 进/出库管理    1.6.2 进/出货管理  1.7 销售管理模块    1.7.1 商品销售管理    1.7.2 商品销售查询  1.8 测试  1.9 项目总结第2章 航空订票管理系统  2.1 航空订票管理系统    2.1.1 项目来源    2.1.2 组建团队    2.1.3 小会议  2.2 系统概述和总体设计    2.2.1 系统需求分析    2.2.2 系统demo流程  2.3 数据库设计    2.3.1 选择数据库    2.3.2 数据库结构的设计  2.4 系统框架设计    2.4.1 创建工程及设计主界面    2.4.2 配置hibernate访问类    2.4.3 系统登录模块设计  2.5 航班信息管理模块    2.5.1 添加飞机管理    2.5.2 添加航班管理    2.5.3 添加航班计划  2.6 网点管理模块    2.6.1 网点添加管理    2.6.2 删除网点管理  2.7 订票管理模块    2.7.1 网点登录管理    2.7.2 订票信息管理  2.8 测试    2.8.1 系统运行    2.8.2 验收    2.8.3 自己做得总结  2.9 后话第3章 酒店管理系统  3.1 踏上求职路    3.1.1 写求职信    3.1.2 随遇而安  3.2 开始试用期  3.3 我的考核新任务    3.3.1 我的任务    3.3.2 规划流程  3.4 系统概述和总体设计    3.4.1 系统需求分析    3.4.2 系统demo流程  3.5 数据库设计    3.5.1 选择数据库    3.5.2 数据库结构的设计  3.6 系统框架设计    3.6.1 创建工程及设计主界面    3.6.2 为数据库建立连接类    3.6.3 系统登录模块设计  3.7 基本信息管理模块    3.7.1 房间信息管理    3.7.2 旅客类型管理    3.7.3 收费信息管理  3.8 订房、查询管理    3.8.1 个人订房管理    3.8.2 多人订房管理    3.8.3 营业查询管理  3.9 旅客信息管理    3.9.1 旅客信息查询    3.9.2 会员信息管理  3.10 测试    3.10.1 系统运行预览    3.10.2 项目验收  3.11 和HR的谈话  3.12 自己的总结第4章 物业管理系统  4.1 了解公司的组织结构    4.1.1 公司的现状    4.1.2 我的开发部  4.2 新的项目    4.2.1 早会的任务    4.2.2 初见客户    4.2.3 我们的团队    4.2.4 小会议  4.3 系统概述和总体设计    4.3.1 系统需求分析    4.3.2 系统demo流程    4.3.3 系统实现流程  4.4 数据库设计    4.4.1 选择数据库    4.4.2 数据库结构的设计  4.5 系统框架设计    4.5.1 创建工程及设计主界面    4.5.2 数据库ADO访问类    4.5.3 系统登录模块设计  4.6 基本信息管理模块    4.6.1 小区信息管理    4.6.2 楼宇信息管理    4.6.3 业主信息管理    4.6.4 收费项目管理    4.6.5 查询单价清单  4.7 消费指数管理模块    4.7.1 业主消费录入    4.7.1 物业消费录入  4.8 各项费用管理模块    4.8.1 业主费用查询    4.8.2 物业费用查询  4.9 测试    4.9.1 系统运行    4.9.2 项目验收  4.10 谈客户的那些事  4.11 我的总结第5章 商品进销存管理系统  5.1 同事们的聚会  5.2 新的项目    5.2.1 休假失败    5.2.2 新的项目    5.2.3 我们的团队  5.3 系统概述和总体设计    5.3.1 系统需求分析    5.3.2 系统demo流程    5.3.3 规划的流程  5.4 数据库设计    5.4.1 选择数据库    5.4.2 数据库结构的设计  5.5 系统框架设计    5.5.1 创建工程及设计主界面    5.5.2 为数据库建立连接类    5.5.3 系统登录模块设计    5.5.3 布局基类设计    5.5.3 系统框架设计  5.6 商家信息管理模块    5.6.1 商家信息管理    5.6.2 商品信息查询  5.7 商品种类、商家管理    5.7.1 商品种类管理    5.7.2 商家信息管理  5.8 商品销售、库存信息管理    5.8.1 商品销售信息管理    5.8.2 商品库存信息管理  5.9 测试    5.9.1 系统运行    5.9.2 验收  5.10 同事之间的那些事第6章 学校图书馆管理系统  6.1 庆功晚会  6.2 前方路漫漫    6.2.1 新招的实习生    6.2.2 新的项目    6.2.3 我们的团队    6.2.4 群组讨论  6.3 系统概述和总体设计    6.3.1 系统需求分析    6.3.2 系统demo流程  6.4 数据库设计    6.4.1 选择数据库    6.4.2 数据库结构的设计  6.5 系统框架设计    6.5.1 创建工程及设计主界面    6.5.2 为数据库表添加对应的类    6.5.3 系统登录模块设计  6.6 基本信息管理模块    6.6.1 读者信息管理    6.6.2 图书类别管理    6.6.3 图书信息管理    6.6.4 新书订购管理  6.7 用户管理模块    6.7.1 用户添加管理    6.7.2 用户修改删除    6.7.3 用户密码修改    6.7.4 图书借阅和归还模块  6.8 测试    6.8.1 系统运行    6.8.2 验收  6.9 我的总结——上下级相处的那些事第7章 OA办公系统  7.1 生活的压力  7.2 同学来访    7.2.1 新的项目    7.2.2 我们的团队    7.2.3 流程分析  7.3 系统概述和总体设计    7.3.1 系统需求分析    7.3.2 系统demo流程  7.4 数据库设计    7.4.1 选择数据库    7.4.2 数据库结构的设计  7.5 系统框架设计    7.5.1 创建工程及设计主界面    7.5.2 为数据库表配置hibernate    7.5.3 为数据库表建立对应类    7.5.4 系统登录模块设计  7.6 基本管理模块    7.6.1 权限信息管理    7.6.2 日程信息管理  7.7 员工和部门管理    7.7.1 员工信息管理    7.7.2 部门信息管理  7.8 通信录和发布管理    7.8.1 通信录管理    7.8.2 信息发布管理  7.9 测试    7.9.1 系统运行    7.9.2 验收  7.10 我的总结——谈私活的那些事第8章 网吧管理系统  8.1 客户的来访  8.2 一个私单说起  8.3 系统概述和总体设计    8.3.1 系统需求分析    8.3.2 系统demo流程  8.4 数据库设计    8.4.1 选择数据库    8.4.2 数据库结构的设计  8.5 系统框架设计    8.5.1 创建工程及设计主界面    8.5.2 建立数据库连接类    8.5.3 系统登录模块设计    8.5.3 普通用户登录设计  8.6 系统管理模块    8.6.1 用户信息类    8.6.2 用户信息管理窗体    8.6.3 用户信息添加    8.6.4 用户信息删除    8.6.5 用户信息修改    8.6.5 用户信息查询  8.7 基本信息管理    8.7.1 计算机信息管理    8.7.2 上网卡信息管理  8.8 高级功能管理    8.8.1 会员信息管理    8.8.2 消费信息管理  8.9 测试    8.9.1 系统运行    8.9.2 验收  8.10 我的总结——爱拼才会赢  8.11 今天你跳槽了吗？第9章 任务管理系统  9.1 很累的地下工作  9.2 成立自己的团队  9.3 第一个单子  9.4 系统概述和总体设计    9.4.1 系统需求分析    9.4.2 系统demo流程  9.5 数据库设计    9.5.1 选择数据库    9.5.2 数据库结构的设计  9.6 系统框架设计    9.6.1 创建工程及设计主界面    9.6.2 建立数据库连接类    9.6.3 系统登录模块设计    9.6.4 数据获取基类    9.6.5 系统框架设计  9.7 用户管理模块    9.7.1 用户信息添加    9.7.2 用户信息维护窗体  9.8 我的任务管理    9.8.1 我的任务类添加    9.8.2 我的任务维护窗体  9.9 公司任务管理    9.9.1 公司任务类添加    9.9.2 公司任务维护窗体  9.10 测试  9.11 创业的艰苦第10章 Android地图系统  10.1 程序员很不容易  10.2 艰巨的项目  10.3 系 统分析    10.3.1 背景    10.3.2 Android技术分析    10.3.3 可行性分析    10.3.4 编写项目计划书  10.4 系统设计    10.4.1 流程分析    10.4.2 规划UI界面  10.5 数据库设计  10.6 我的编码工作    10.6.1 新建工程    10.6.2 主界面    10.6.3 新建界面    10.6.4 设置界面    10.6.5 帮助界面    10.6.6 地图界面    10.6.7 数据存取    10.6.8 实现Service服务  10.7 项目调试    10.7.1 系统调试    10.7.2 验收  10.8 升职的惊喜  10.9 升职的原因  10.10 压力依旧，拼搏继续
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入体验Java项目开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java网络编程指南
第一章 Java 网络编程简介
第二章 网络基础
第三章 网络应用程序模型
第四章 Web基础
第五章 JavaI/O
第六章 线程
第七章 Java安全模型
第八章 Internet寻址与命名
第九章 TCP编程
第十章 UDP编程
第十一章 组播
第十二章 JavaURL处理器体系结构
第十三章 实现HTTP服务器
……
附录A Java网络连接异常
附录B 安装与配置Tomcat 4.0
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java网络编程指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java手机/PDA程序设计入门
第零部分  概论
第一章  J2ME概论
第二章  J2ME程序的撰写
第三章  Personal Java概论
第一部分  MIDP入门
第四章  MIDP程序设计基础――谈生命周期
第五章  MIDP程序设计进阶――CLDC与MIDP工具类
第二部分  开发工具
第六章  手动开发MIDP应用程序――使用Ant
第七章  MIDP for Palm
第八章  高级开发工具
第九章  集成开发工具
第三部分  用户界面
第十章  LCDUI――简介
第十一章  LCDUI入门――高级API
第十二章  LCDUI入门――低级API
第十三章  LCDUI进阶――高级API
第十四章  LCDUI进阶――低级API
第十五章  流程控制的设计模式
第四部分  游戏设计
第十六章  Game API入门
第十七章  Game API进阶
第五部分  数据库程序设计
第十八章  MIDP数据库程序设计入门
第十九章  MIDP数据库程序设计进阶
第六部分  与外界联系
第二十章  Generic Connection Framework
第二十一章  与企业系统衔接
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java手机/PDA程序设计入门
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深度解析Java游戏服务器开发
CONTENTS
基础篇 走进游戏开发
第1章 认识游戏	2
1.1 什么是游戏	2
1.1.1 游戏的定义	2
1.1.2 游戏的分类	3
1.2 游戏开发及分工	7
1.3 游戏行业现状分析	12
1.4 游戏服务器开发要点	15
总结	17
第2章 环境搭建	18
2.1 Windows开发环境搭建	18
2.1.1 安装JDK	18
2.1.2 安装Eclipse	20
2.1.3 安装数据库客户端工具	21
2.1.4 安装SSH工具	21
2.1.5 安装其他工具	22
2.2 Mac OS X开发环境搭建	22
2.2.1 安装JDK	23
2.2.2 安装Eclipse	23
2.2.3 安装数据库客户端工具	24
2.2.4 安装SSH工具	24
2.2.5 安装其他工具	24
2.3 Linux服务器环境搭建	25
2.3.1 安装JDK	25
2.3.2 安装Tomcat	26
2.3.3 安装MySQL	26
2.3.4 安装Mongo	28
2.3.5 安装Redis	29
2.3.6 安装Memcache	32
2.4 总结	33
入门篇 游戏开发
第3章 网络通信	36
3.1 通信协议	36
3.1.1 面向连接的TCP	37
3.1.2 面向数据报的UDP	38
3.1.3 HTTP编程	39
3.1.4 Socket编程	46
3.1.5 WebSocket编程	54
3.2 Java NIO基础	58
3.2.1 BIO编程（Blocking-IO，阻塞式IO）	59
3.2.2 NIO编程（Non-Blocking IO，非阻塞式IO）	61
3.2.3 AIO编程（Async IO/NIO.2，异步IO）	68
3.3 Mina的介绍及其使用	75
3.3.1 总体架构	76
3.3.2 IoService	77
3.3.3 IoFilterChain	77
3.3.4 IoHandler	77
3.3.5 IoSession	77
3.3.6 工作原理	78
3.3.7 Acceptor与Connector线程	78
3.3.8 Processor线程	78
3.3.9 线程模型	79
3.3.10 请求的处理顺序	80
3.3.11 Mina编程	81
3.4 Netty的介绍及其使用	88
3.4.1 总体架构	88
3.4.2 零拷贝	89
3.4.3 Codec框架	90
3.4.4 Channel	90
3.4.5 ChannelEvent	91
3.4.6 ChannelPipeline	91
3.4.7 Netty编程	91
总结	100
第4章 数据交互	101
4.1 数据传输格式	101
4.2 JSON的使用及解析	103
4.2.1 JSON语法	103
4.2.2 JSON对象	104
4.2.3 JSON数组	104
4.2.4 Java中的JSON解析	105
4.3 XML的使用及解析	110
4.3.1 XML的特征	111
4.3.2 数据共享	111
4.3.3 数据传输	111
4.3.4 平台兼容	111
4.3.5 JSON与XML的比较	112
4.3.6 Java中的XML解析	112
4.4 Google Protocol Buffer的介绍及使用	128
4.4.1 Protobuffer的安装与编译	128
4.4.2 Protobuffer的语法	129
4.4.3 生成Java类	130
4.4.4 Eclipse的protobuf-dt插件	131
4.4.5 示例程序	132
总结	134
第5章 数据缓存与持久化	135
5.1 游戏数据存储	135
5.1.1 数据分类	136
5.1.2 数据缓存方式	136
5.1.3 数据持久化方式	137
5.1.4 数据库的比较	137
5.2 MySQL的介绍及使用	138
5.2.1 特点	138
5.2.2 数据类型	139
5.2.3 MySQL的使用	139
5.2.4 在Java中使用MySQL	142
5.3 MongoDB的介绍及使用	157
5.3.1 MongoDB的主要特点	157
5.3.2 了解API	159
5.3.3 Mongo的使用	162
5.4 Memcache的介绍及使用	174
5.4.1 Memcache的特点	175
5.4.2 Memcache的使用场景	176
5.4.3 在Java中使用Memcache	177
5.4.4 客户端使用要点	182
5.5 Redis的介绍及使用	183
5.5.1 Redis的特点	183
5.5.2 Redis的持久化	184
5.5.3 Redis的主从复制	184
5.5.4 在Java中使用Redis	185
总结	199
第6章 游戏逻辑	200
6.1 逻辑架构	200
6.1.1 项目目录	200
6.1.2 模块介绍	202
6.2 逻辑流程	212
6.2.1 网络模块	212
6.2.2 线程池	221
6.2.3 启动服务器	222
6.2.4 逻辑请求处理	223
6.2.5 关闭服务器	228
6.3 事件处理器	229
6.4 定时任务	236
6.5 RPC框架	244
6.5.1 Json-rpc	244
6.5.2 Motan	253
总结	264
第7章 游戏安全	265
7.1 游戏安全的必要性	265
7.2 登录安全	266
7.3 游戏充值	266
7.4 SQL注入	267
7.5 通信协议与消息格式	268
7.6 整型溢出	269
7.7 并发请求	269
7.8 逻辑漏洞	270
7.9 日志系统	271
总结	271
高级篇 游戏服务器的设计及优化
第8章 服务器架构分析	274
8.1 服务器架构的演变过程	274
8.2 全区同服架构分析	277
8.2.1 COC架构模型分析	278
8.2.2 COK架构模型分析	279
8.3 分区分服架构分析	281
8.4 弱联网类游戏架构分析	282
8.5 MMORPG类游戏架构分析	283
总结	285
第9章 《皇室战争》游戏开发实战	286
9.1 微竞技游戏介绍	286
9.2 架构分析及搭建	287
9.2.1 功能分析	287
9.2.2 服务器部署架构	288
9.2.3 系统架构	289
9.3 数据持久化方案	290
9.3.1 数据结构分析	290
9.3.2 使用Morphia操作MongoDB	295
9.4 Netty网络框架的使用	300
9.4.1 Netty实现的HTTP服务器	300
9.4.2 Netty实现的TCP服务器	309
9.5 账号系统	316
9.6 个人信息	323
9.7 英雄卡牌系统	327
9.8 宝箱系统	334
9.9 战斗系统	339
9.10 客户端模拟	349
9.10.1 登录界面	349
9.10.2 选服界面	354
9.10.3 主逻辑界面	358
9.10.4 对战界面	363
总结	372
第10章 游戏开发技术前景	373
10.1 Egret	373
10.2 Cocos 2D	374
10.3 Unity	375
10.4 Unreal	376
10.5 Java	376
10.6 Node.js	377
总结	378
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深度解析Java游戏服务器开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序员面试宝典(第4版)
第1部分求职过程
第1章应聘求职
1.1应聘渠道
1.2应聘流程
第2章简历书写
2.1书写简历注意事项
2.2简历模板
第3章求职五步曲
3.1笔试
3.2电话面试
3.3面试
3.4签约
3.5违约
第4章职业生涯发展规划
4.1缺乏工作经验的应届毕业生
4.2更换工作的程序员们
4.3快乐地工作
第2部分Java程序设计
第5章Java程序设计基本概念
5.1JVM
5.2i++
5.3类型转换
5.4程序结构
5.5运算符
5.6异常
5.7反射
第6章传递与引用
6.1传值与传引用
6.2静态变量与私有变量
6.3输入／输出流
6.4序列化
第7章循环、条件、概率
7.1典型递归问题
7.2循环与条件
第8章Java内存管理
8.1垃圾收集
8.2内存管理
8.3ClOne
第9章面向对象
9.1面向对象的基本概念
9.2类和对象
9.3嵌套类
9.4集合类
9.5构造函数和析构函数
9.6复制构造函数和赋值函数
9.7多态的概念
第10章继承与接口
10.1基础知识
10.2Super
10.3thiS
10.4不能继承的情况
10.5抽象类与接口
第3部分数据结构和设计模式
第11章数据结构基础
11.1堆栈
11.2链表、哈希表
11.3树、图
11.4排序基础知识
第12章字符串、数组、范型
12.1字符串基础问题
12.2StringBuffer
12.3正则表达式
12.4数字流和数组
12.5字符串其他问题
12.6范型与容器
第13章设计模式
13.1UML
13.2常见设计模式
13.3软件工程
……
第4部分操作系统、数据库、网络
第5部分Java开源
第6部分综合面试题
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序员面试宝典(第4版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Java Swing程序设计
第0章  关于本书与随书光盘
第1章  Swing简介
第2章  Swing的基本概念与使用
第3章  使用版面管理器（Layout Managers）
第4章  事件处理（Event Handling）
第5章  窗口与面版（Frame、Pane与Panel）的使用与介绍
第6章  标签与按钮的使用与介绍
第7章  复选框、选项按钮、列表方框、下拉式列表的使用与介绍
第8章  表格（Table）的使用与介绍
第9章  文字输入组件的使用与介绍
第10章  树（Tree）的使用与介绍
第11章  对话框（Option Pane与Dialog）的使用与介绍
第12章  菜单与工具栏的使用与介绍
第13章  文件选择对话框、颜色选择对话框、分隔线的使用与介绍
第14章  滑动杆（Slider）、时间控制（Timer）、进度元件（Progress）的使用与介绍
第15章  创造用户最熟悉的环境（Look and Feel）
第16章  整合范例
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Java Swing程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JAVA WEB整合开发实例精通
丛书序 前言 第1章  Struts概述 第2章  Web基础技术概述第3章  Struts 2核心技术第4章  Struts 2的另一核心技术——拦截器第5章  Struts 2标签库第6章  Struts 2非JSP视图技术第7章  Struts 2类型转换技术第8章  Struts 2输入校验第9章  Struts 2国际化第10章  Struts 2页面布局实现第11章  Hibernate技术简介第12章  Hibernate入门第13章  Hibernate核心API第14章  Hibernate集合映射第15章  Hibernate关系映射第16章  Criteria条件查询第17章  HQL查询第18章  Spring入门第19章  为什么要使用控制反转第20章  IOC容器的反射机制和装载机制第21章  DI注入方式第22章  如何合理地编写配置文件第23章  使用AOP第24章  在Spring环境中实现AOP第25章  Spring与Hibernate结合第26章  Spring与Struts结合
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JAVA WEB整合开发实例精通
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java学习指南(第4版)(上下册)
第1章　一种现代语言　1
1.1　进入Java世界　2
1.1.1　Java的起源　2
1.1.2　成长　3
1.2　虚拟机　4
1.3　Java与其他语言的比较　7
1.4　设计安全　10
1.4.1　语法简单性　10
1.4.2　类型安全和方法绑定　11
1.4.3　递增开发　12
1.4.4　动态内存管理　13
1.4.5　错误处理　14
1.4.6　线程　14
1.4.7　可伸缩性　15
1.5　实现安全　15
1.5.1　校验器　17
1.5.2　类加载器　18
1.5.3　安全管理器　18
1.6　应用和用户级安全性　19
1.7　Java路线图　20
1.7.1　过去：Java 1.0到Java 1.6　20
1.7.2　如今：Java 7　21
1.7.3　将来　23
1.7.4　可用性　24
第2章　第一个应用　25
2.1　Java工具和环境　25
2.2　配置Eclipse并且创建项目　26
2.2.1　导入本书示例　28
2.3　HelloJava　29
2.3.1　类　32
2.3.2　main()方法　32
2.3.3　类和对象　34
2.3.4　变量与类类型　34
2.3.5　HelloComponent　35
2.3.6　继承　36
2.3.7　JComponent类　37
2.3.8　关系与指向　38
2.3.9　包与导入　39
2.3.10　paintComponent() 方法　40
2.4　HelloJava2：余波未平　41
2.4.1　实例变量　43
2.4.2　构造函数　43
2.4.3　事件　45
2.4.4　repaint()方法　47
2.4.5　接口　48
2.5　HelloJava3：按钮的震撼　49
2.5.1　方法重载　51
2.5.2　组件　52
2.5.3　容器　52
2.5.4　布局　53
2.5.5　派生子类与子类型　53
2.5.6　更多事件和接口　54
2.5.7　颜色的说明　55
2.5.8　静态成员　55
2.5.9　数组　56
2.5.10　颜色的相关方法　56
2.6　HelloJava4：Netscape的反戈一击　58
2.6.1　线程　60
2.6.2　Thread类　60
2.6.3　Runnable接口　61
2.6.4　启动线程　62
2.6.5　在线程中运行代码　62
2.6.6　异常　63
2.6.7　同步　64
第3章　使用工具　66
3.1　JDK环境　66
3.2　Java虚拟机　67
3.3　运行Java应用程序　67
3.4　类路径　69
3.5　Java编译器　71
3.6　JAR Files　73
3.6.1　文件压缩　73
3.6.2　jar工具　74
3.6.3　Pack200工具　77
3.7　策略文件　78
3.7.1　默认的安全性管理器　78
3.7.2　policytool工具　79
3.7.3　通过默认的安全管理器使用策略文件　81
第4章　Java语言　82
4.1　文本编码　82
4.2　注释　83
4.3　类型　85
4.3.1　基本类型　86
4.3.2　引用类型　89
4.3.3　字符串的有关问题　91
4.4　语句和表达式　92
4.4.1　语句　93
4.4.2　表达式　99
4.5　异常　103
4.5.1　异常和错误类　104
4.5.2　异常处理　106
4.5.3　逐级上浮　108
4.5.4　栈轨迹　109
4.5.5　受查和非受查异常　110
4.5.6　抛出异常　111
4.5.7　try的“潜伏”功用　114
4.5.8　finally子句　115
4.5.9　带有资源的Try　116
4.5.10　性能问题　118
4.6　断言　118
4.6.1　启用和禁用断言　119
4.6.2　使用断言　120
4.7　数组　121
4.7.1　数组类型　122
4.7.2　数组的创建和初始化　122
4.7.3　使用数组　124
4.7.4　匿名数组　126
4.7.5　多维数组　126
4.7.6　深入数组　128
第5章　Java中的对象　129
5.1　类　130
5.1.1　访问字段和方法　132
5.1.2　静态成员　133
5.2　方法　136
5.2.1　局部变量　137
5.2.2　遮蔽　137
5.2.3　静态方法　138
5.2.4　初始化局部变量　139
5.2.5　参数传递与引用　140
5.2.6　基本类型的包装器　142
5.2.7　基本类型的自动装箱和拆箱　144
5.2.8　可变长度的参数列表　145
5.2.9　方法重载　146
5.3　对象创建　148
5.3.1　构造函数　148
5.3.2　使用重载构造函数　149
5.3.3　静态和非静态初始化块　151
5.4　对象销毁　152
5.4.1　垃圾回收　152
5.4.2　最终化　153
5.4.3　弱引用和软引用　154
5.5　枚举　155
5.5.1　枚举值　156
5.5.2　定制化枚举　156
第6章　类之间的关系　158
6.1　派生子类和继承　158
6.1.1　被遮蔽变量　160
6.1.2　覆盖方法　162
6.1.3　特殊引用：this和super　169
6.1.4　类型强制转换　170
6.1.5　使用超类构造函数　172
6.1.6　完全揭密：构造函数和初始化　173
6.1.7　抽象方法和类　173
6.2　接口　174
6.2.1　作为回调的接口　176
6.2.2　接口变量　177
6.2.3　子接口　178
6.3　包与编译单元　179
6.3.1　编译单元　179
6.3.2　包名　180
6.3.3　类可见性　180
6.3.4　导入类　181
6.4　变量和方法的可见性　183
6.4.1　基本访问修饰符　184
6.4.2　子类和可见性　185
6.4.3　接口和可见性　186
6.5　数组和类的层次体系结构　186
6.6　内部类　188
6.6.1　内部类作为适配器　190
6.6.2　方法中的内部类　192
第7章　使用对象和类　198
7.1　Object类　198
7.1.1　相等性与等价　199
7.1.2　散列码　200
7.1.3　复制对象　200
7.2　Class类　203
7.3　反射　205
7.3.1　安全性　208
7.3.2　访问字段　209
7.3.3　访问方法　210
7.3.4　访问构造函数　212
7.3.5　关于数组　213
7.3.6　访问泛型类型信息　213
7.3.7　访问注解数据　214
7.3.8　动态接口适配器　214
7.3.9　反射适用之处　215
7.4　注解　216
7.4.1　使用注解　217
7.4.2　标准注解　218
7.4.3　Apt工具　219
第8章　泛型　220
8.1　容器：构建一个更好的捕鼠器　221
8.2　走进泛型　222
8.3　根本就没有勺子　226
8.3.1　擦除　226
8.3.2　原始类型　228
8.4　参数化类型关系　229
8.5　类型转换　232
8.6　编写泛型类　233
8.6.1　类型变量　233
8.6.2　子类化泛型　234
8.6.3　异常和泛型　235
8.6.4　参数类型限制　236
8.7　边界　237
8.8　通配符　239
8.8.1　所有实例化的超类型　240
8.8.2　有界限通配符　240
8.8.3　思考容器　240
8.8.4　下边界　241
8.8.5　读、写和算术　242
8.8.6　、和原始类型　243
8.8.7　通配符类型关系　244
8.9　泛型方法　245
8.9.1　泛型方法的引入　246
8.9.2　根据参数进行类型推断　247
8.9.3　根据赋值环境做类型推断　248
8.9.4　显示类型调用　249
8.9.5　通配符捕获　249
8.9.6　通配符类型和泛型方法　249
8.10　参数化类型的数组　250
8.10.1　使用数组类型　251
8.10.2　泛型类型的数组有何优点　252
8.10.3　数组类型中的通配符　252
8.11　案例学习：Enum类　253
8.12　案例学习：sort()方法　254
8.13　结论　255
第9章　线程　256
9.1　线程简介　257
9.1.1　Thread类和Runnable接口　258
9.1.2　控制线程　262
9.1.3　线程的消亡　264
9.2　applet中线程的实现　266
9.3　同步　268
9.3.1　对方法的串行化访问　269
9.3.2　访问多线程中的类和实例变量　271
9.3.3　wait()和notify()方法　272
9.3.4　传递消息　274
9.3.5　ThreadLocal对象　278
9.4　调度和优先级　279
9.4.1　线程状态　280
9.4.2　时间片划分　281
9.4.3　优先级　282
9.4.4　让步　283
9.5　线程组　283
9.5.1　使用ThreadGroup类　284
9.5.2　未捕获的异常　284
9.6　线程性能　285
9.6.1　同步的开销　285
9.6.2　线程资源消费　286
9.7　并发工具　287
9.7.1　执行器　288
9.7.2　锁　300
9.7.3　同步构造　303
9.7.4　原子操作　308
9.8　结论　310
第10章　文本处理　311
10.1　其他与文本相关的API　312
10.2　String　312
10.2.1　String构造函数　313
10.2.2　事物的字符串表示　314
10.2.3　字符串比较　315
10.2.4　查找　317
10.2.5　编辑　318
10.2.6　String方法小结　319
10.2.7　StringBuilder和StringBuffer　320
10.3　国际化　321
10.3.1　java.util.Locale类　321
10.3.2　资源包　322
10.4　解析与格式化文本　324
10.4.1　解析基本数字　325
10.4.2　文本分词　326
10.5　Printf式格式化　328
10.5.1　Formatter　329
10.5.2　格式字符串　329
10.5.3　字符串转换　330
10.5.4　基本类型和数字转换　332
10.5.5　标志　334
10.5.6　其他　334
10.6　用java.text包格式化　334
10.7　正则表达式　338
10.7.1　regex记法　339
10.7.2　java.util.regex API　349
第11章　核心实用工具　356
11.1　数学实用工具　356
11.1.1　java.lang.Math类　357
11.1.2　Big/Precise Numbers　359
11.1.3　浮点数组成部分　359
11.1.4　随机数　360
11.2　日期和时间　361
11.2.1　使用日历　362
11.2.2　Time Zones　363
11.2.3　解析和格式化日期　365
11.2.4　Printf式的日期和时间格式化　367
11.3　定时器　368
11.4　集合　370
11.4.1　Collection接口　371
11.4.2　迭代器　374
11.4.3　Collection类型　375
11.4.4　Map接口　378
11.4.5　集合实现　380
11.4.6　哈希码和键值　385
11.4.7　同步和只读集合　386
11.4.8　同步和只读集合　387
11.4.9　WeakHashMap　388
11.4.10　EnumSet和EnumMap　388
11.4.11　排序的集合　389
11.4.12　一个令人激动的例子　389
11.5　特性　391
11.5.1　加载和存储　392
11.5.2　系统特性　393
11.6　首选项API　394
11.6.1　类的首选项　395
11.6.2　首选项存储　395
11.6.3　修改通知　396
11.7　日志API　397
11.7.1　概述　397
11.7.2　日志级别　399
11.7.3　一个简单的例子　400
11.7.4　日志建立特性　401
11.7.5　记录器　403
11.7.6　性能　404
11.8　Observers和Observables　404
第12章　输入/输出功能　406
12.1　流　406
12.1.1　终端I/O　409
12.1.2　字符流　411
12.1.3　流包装器　413
12.1.4　管道　416
12.1.5　流与String的转换　418
12.1.6　Implementing a Filter Stream　420
12.2　文件　421
12.2.1　java.io.File类　422
12.2.2　文件流　427
12.2.3　Random AccessFile　429
12.2.4　Resource Paths　430
12.3　NIO File API　432
12.3.1　FileSystem和Path　433
12.3.2　NIO文件操作　435
12.3.3　目录操作　438
12.3.4　监控路径　440
12.4　串行化　441
12.4.1　使用readObject()初始化　443
12.4.2　SerialVersionUID　443
12.5　数据压缩　444
12.5.1　压缩数据　445
12.5.2　解压缩数据　446
12.5.3　作为文件系统的Zip归档文件　448
12.6　NIO包　449
12.6.1　异步I/O　450
12.6.2　性能　450
12.6.3　映射和加锁文件　450
12.6.4　通道　451
12.6.5　缓冲区　451
12.6.6　字符编码器和解码器　455
12.6.7　FileChannel　457
12.6.8　利用NIO实现可伸缩I/O　463
第13章　网络编程　464
13.1　套接字　466
13.1.1　客户端和服务器　467
13.1.2　DateAtHost客户端　471
13.1.3　TinyHttpd服务器　473
13.1.4　套接字选项　478
13.1.5　代理和防火墙　479
13.2　数据报套接字　481
13.2.1　The HeartBeat Applet　482
13.2.2　InetAddress　486
13.3　简单串行化对象协议　487
13.4　远程方法调用　491
13.4.1　现实的用法　492
13.4.2　远程和非远程对象　492
13.4.3　一个RMI示例　495
13.4.4　RMI and CORBA　504
13.5　使用NIO的可伸缩I/O　504
13.5.1　可选择通道　505
13.5.2　使用select　506
13.5.3　LargerHttpd　508
13.5.4　非阻塞客户端端操作　512
第14章　Web编程　514
14.1　统一资源定位器(URL)　514
14.2　URL类　515
14.2.1　流数据　516
14.2.2　将内容获取为对象　517
14.2.3　Managing Connections　518
14.2.4　实用的处理器　519
14.2.5　其他处理器框架　519
14.3　与Web应用通信　520
14.3.1　使用GET方法　521
14.3.2　使用POST方法　521
14.3.3　The HttpURLConnection　524
14.3.4　SSL和安全Web通信　525
14.3.5　URL、URN和URI　525
14.4　Web Services　526
14.4.1　XML-RPC　527
14.4.2　WSDL　527
14.4.3　工具　527
14.4.4　Weather Service客户端　528
第15章　Web应用与Web服务　530
15.1　Web应用技术　531
15.1.1　面向页面的应用和单页应用　531
15.1.2　JSP　532
15.1.3　XML和XSL　533
15.1.4　Web应用框架　533
15.1.5　Google Web Toolkit　534
15.1.6　HTML5、AJAX以及更多　534
15.2　Java Web应用　534
15.2.1　servlet生命期　535
15.2.2　Servlets　536
15.2.3　The HelloClient Servlet　537
15.2.4　servlet响应　538
15.2.5　servlet参数　540
15.2.6　The ShowParameters Servlet　541
15.2.7　用户会话管理　543
15.2.8　ShowSession Servlet　543
15.2.9　ShoppingCart Servlet　545
15.2.10　Cookies　548
15.2.11　ServletContext API　549
15.2.12　异步Servlets　550
15.3　WAR文件和部署　554
15.3.1　使用web.xml和注解配置　555
15.3.2　URL模式映射　557
15.3.3　部署HelloClient　558
15.3.4　错误和索引页面　559
15.3.5　安全性和鉴别　561
15.3.6　为用户指定角色　561
15.3.7　安全数据传输　562
15.3.8　用户鉴别　563
15.3.9　过程性安全　565
15.4　servlet过滤器　566
15.4.1　一个简单的过滤器　567
15.4.2　一个测试servlet　568
15.4.3　声明和映射过滤器　569
15.4.4　过滤servlet请求　570
15.4.5　过滤servlet响应　572
15.5　使用Ant构建WAR文件　575
15.5.1　面向开发的目录布局　575
15.5.2　使用Ant部署和重新部署WAR　577
15.6　实现Web Services　577
15.6.1　定义服务　578
15.6.2　回显服务　578
15.6.3　使用服务　579
15.6.4　数据类型　581
15.7　结论　582
第16章　Swing　583
16.1　组件　586
16.1.1　对等对象　588
16.1.2　模型-视图-控制器框架　589
16.1.3　绘制　590
16.1.4　启用和禁用组件　591
16.1.5　焦点　591
16.1.6　其他组件方法　592
16.1.7　布局管理器　594
16.1.8　边距　594
16.1.9　Z顺序(组件入栈)　595
16.1.10　revalidate()和doLayout()方法　595
16.1.11　管理组件　596
16.1.12　监听组件　596
16.1.13　窗口和框架　596
16.1.14　控制框架的其他方法　598
16.1.15　使用内容格　598
16.1.16　桌面集成　599
16.2　事件　601
16.2.1　事件接收者和监听者接口　602
16.2.2　事件源　603
16.2.3　事件发送　605
16.2.4　事件类型　606
16.2.5　java.awt.event.InputEvent类　606
16.2.6　InputEvent中的鼠标和按键修饰符　606
16.2.7　焦点事件　608
16.3　事件总结　609
16.3.1　适配器类　612
16.3.2　哑适配器　615
16.4　AWT Robot　615
16.5　Swing中的多线程　616
第17章　使用Swing组件　620
17.1　按钮和标签　620
17.1.1　按钮和标签中的HTML文本　623
17.2　复选框和单选钮　624
17.3　列表框和组合框　626
17.4　增减器　629
17.5　边框　632
17.6　菜单　635
17.7　PopupMenu类　638
17.8　JScrollPane类　642
17.9　JSplitPane类　644
17.10　JTabbedPane类　646
17.11　滚动条和滑块　650
17.12　对话框　652
17.12.1　文件选择对话框　654
17.12.2　颜色选择器　657
第18章　再谈Swing组件　658
18.1　文本组件　658
18.1.1　TextEntryBox应用　659
18.1.2　格式化文本　661
18.1.3　过滤输入　662
18.1.4　验证数据　664
18.1.5　有关密码的问题　665
18.1.6　共享数据模型　666
18.1.7　自由地使用HTML和RTF　667
18.1.8　自行管理文本　670
18.2　焦点导航　673
18.2.1　树　674
18.2.2　节点和模型　675
18.2.3　保存树　675
18.2.4　树事件　675
18.2.5　一个完整的例子　676
18.3　表　679
18.3.1　第一步：不劳而获　679
18.3.2　第二步：创建一个表模型　681
18.3.3　第三步：一个简单的电子表格应用　684
18.3.4　排序和过滤　687
18.3.5　打印JTables　689
18.4　桌面　690
18.5　可插拔观感　691
18.6　创建定制组件　694
18.6.1　生成事件　694
18.6.2　Dial组件　695
第19章　布局管理器　700
19.1　FlowLayout　702
19.2　GridLayout　703
19.3　BorderLayout　704
19.4　BoxLayout　707
19.5　CardLayout　708
19.6　GridBagLayout　710
19.6.1　GridBagConstraints类　710
19.6.2　表格坐标　712
19.6.3　填充约束　713
19.6.4　行跨度和列跨度　715
19.6.5　权值　716
19.6.6　锚定　718
19.6.7　间距和边距　719
19.6.8　相对定位　720
19.6.9　组合布局　721
19.7　非标准布局管理器　725
19.8　绝对定位　725
第20章　使用2D API绘图　727
20.1　整体结构　727
20.2　表现通道　729
20.3　2D API快速浏览　732
20.3.1　填充形状　732
20.3.2　绘制形状轮廓　732
20.3.3　便利方法　733
20.3.4　绘制文本　734
20.3.5　绘制图像　734
20.3.6　完整的Iguana　735
20.4　填充形状　738
20.4.1　纯色　738
20.4.2　颜色渐变　739
20.4.3　纹理　739
20.4.4　桌面颜色　739
20.5　描画形状轮廓　740
20.6　使用字体　741
20.7　显示图像　746
20.7.1　Image类　746
20.7.2　图像观察者　748
20.7.3　缩放和大小　749
20.8　绘制技术　750
20.8.1　双缓冲　752
20.8.2　使用剪裁的有限绘制　753
20.8.3　屏幕外绘制　756
20.9　打印　759
第21章　使用图像及其他媒体　761
21.1　Loading Images　762
21.1.1　ImageObserver　762
21.1.2　MediaTracker　764
21.1.3　ImageIcon　766
21.1.4　ImageIO　767
21.2　生成图像数据　768
21.2.1　绘制动画　768
21.2.2　BufferedImage剖析　771
21.2.3　颜色模型　773
21.2.4　创建图像　774
21.2.5　更新BufferedImage　776
21.3　过滤图像数据　779
21.3.1　ImageProcessor如何工作　781
21.3.2　将Image转换为BufferedImage　782
21.3.3　使用RescaleOp类　782
21.3.4　使用Affine TransformOp类　783
21.4　保存图像数据　784
21.5　简单音频　784
21.6　Java媒体框架　786
第22章　JavaBeans　789
22.1　什么是Bean　789
22.2　The NetBeans IDE　791
22.3　特性和定制器　795
22.4　事件关联和适配器　797
22.4.1　控制Juggler　798
22.4.2　分子运动　800
22.5　绑定特性　801
22.6　构建Bean　803
22.6.1　The Dial Bean　803
22.6.2　特性的设计模式　806
22.7　可视化设计的限制　807
22.8　串行化与代码生成　808
22.9　使用BeanInfo进行定制　809
22.10　用手写代码使用Bean　813
22.10.1　Bean实例化和类型管理　813
22.10.2　使用串行化Bean　814
22.10.3　使用反射完成运行时事件关联　816
22.11　BeanContext和BeanContextService　818
22.12　Java激活框架　818
22.13　Enterprise JavaBeans和POJO-Based Enterprise Frameworks　819
第23章　Applets　820
23.1　基于浏览器的应用政治　820
23.2　Applet支持和Java插件　822
23.3　JApplet类　822
23.3.1　Applet生命期　824
23.3.2　Applet安全沙箱　826
23.3.3　获得Applet资源　827
23.3.4　标签　831
23.3.5　属性　832
23.3.6　参数　832
23.3.7　Applet的替代品　833
23.3.8　完整的标签　833
23.3.9　加载类文件　835
23.3.10　包　835
23.3.11　查看applet　836
23.4　Java Web Start　836
23.5　结论　837
第24章　XML　838
24.1　本章主题　838
24.2　背景知识点拨　839
24.2.1　文本与二进制　840
24.2.2　通用解析器　840
24.2.3　XML的状态　840
24.2.4　The XML APIs　841
24.2.5　XML和Web浏览器　841
24.3　XML基础　841
24.3.1　属性　842
24.3.2　XML文档　843
24.3.3　编码　843
24.3.4　命名空间　844
24.3.5　验证　845
24.3.6　HTML向XHTML的转换　845
24.4　SAX　845
24.4.1　The SAX API　846
24.4.2　使用SAX构建模型　847
24.4.3　XML编码器/ 解码器　853
24.5　DOM　854
24.5.1　DOM API　854
24.5.2　试验DOM　855
24.5.3　用DOM生成XML　856
24.5.4　JDOM　857
24.6　XPath　858
24.6.1　节点　859
24.6.2　谓词　860
24.6.3　函数　861
24.6.4　XPath API　861
24.6.5　XMLGrep　862
24.7　XInclude　863
24.8　验证文档　865
24.8.1　使用文档验证　866
24.8.2　DTDs　866
24.8.3　XML Schema　868
24.8.4　验证API　872
24.9　JAXB和代码生成　874
24.9.1　注解我们的模型　874
24.9.2　从一个XML架构生成一个Java模型　880
24.9.3　从Java模型生成一个XML架构　880
24.10　用XSL/XSLT转换文档　880
24.10.1　XSL基础知识　881
24.10.2　转换动物园名册　883
24.10.3　XSLTransform　885
24.10.4　浏览器中的XSL　886
24.11　Web服务　886
24.12　本书的结尾　887
附录A　Eclipse IDE　888
A.1　IDE战争　889
A.2　Eclipse入门　889
A.3　使用Eclipse　890
A.3.1　获取源代码　891
A.3.2　布局　892
A.3.3　运行示例　893
A.3.4　构建基于Ant的示例　894
A.3.5　独特示例　894
A.4　Eclipse功能　894
A.4.1　编码快捷　894
A.4.2　自动更正　895
A.4.3　重构　896
A.4.4　区分文件　897
A.4.5　组织导入　897
A.4.6　格式化源代码　897
A.5　结语　897
附录B　BeanShell：简单Java脚本　898
B.1　运行BeanShell　898
B.2　Java语句和表达式　899
B.3　BeanShell命令　900
B.4　脚本化方法和对象　901
B.5　修改类路径　903
B.6　更多内容　903
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java学习指南(第4版)(上下册)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 2 参考大全
第1部分 Java语言
第1章 Java的起源
第2章 Java语言概述
第3章 数据类型、变量、数组
……
第2部分 Java库
第13章 字符串处理
第14章 java.lang研究
第15章 java.util第1部分：类集框架
……
第3部分 Java软件开发技术
第24章 附加的包
第25章 Java Beans
第26章 Swing
……
第4部分 应用Java
第28章 DynamicBillboard小应用程序
第29章 ImageMenu:一个基于图像的Web菜单
第30章 Lavatron小应用程序：运动竞技场的显示牌
……
附录 使用Java的文档注释

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 2 参考大全
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java服务器高级编程
译者序
作者简介
前言
第1章 Web应用开发
第2章 servlet简介
第3章 错误处理和事件记录
第4章 会话与会话跟踪
第5章 使用servlet环境
第6章 生成动态内容
第7章 JavaServer Pages介绍
第8章 连接数据库
第9章 连接池
第10章 servlet链接
第11章 servlet通信
第12章 利用servlet进行分布式计算
……
附录A HTTP
……
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java服务器高级编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java轻松入门
第1篇　筑基
第1章　java初体验　3
1.1　为什么是java　3
1.2　java怎么改变我的生活　4
1.3　打开大门前的准备　5
1.3.1　下载jdk　5
1.3.2　安装jdk　6
1.3.3　jdk的配置　7
1.3.4　测试jdk配置是否成功　8
1.4　java世界的风俗　9
1.4.1　命名规范　9
1.4.2　代码编写常见规则　9
1.4.3　java注释要求　11
1.5　站在门口说hello　13
1.5.1　编写hello world代码　13
1.5.2　编译和运行hello world　14
1.5.3　如何获取在线帮助　16
1.6　小结　17
1.7　习题　17
第2章　java江湖的宝剑eclipse　18
2.1　eclipse的获取与安装　18
2.1.1　下载与安装eclipse　18
2.1.2　启动eclipse　19
2.1.3　汉化eclipse　20
2.2　eclipse使用说明　23
2.2.1　什么是工作空间　23
2.2.2　eclipse工作界面概述　23
2.2.3　什么是透视图　24
2.2.4　什么是视图　25
2.2.5　熟悉eclipse的菜单栏和工具栏　25
2.2.6　先人一手，掌握快捷键　26
2.3　手把手hello world　27
2.3.1　起式，创建新的java项目　28
2.3.2　出招，创建可执行java类　28
2.3.3　不一样的hello world　29
2.4　eclipse进阶　30
2.4.1　导入已有项目　30
2.4.2　插件机制简介　31
2.5　小结　31
2.6　习题　31
第3章　java功法之数据类型　32
3.1　生来不变的常量　32
3.2　为变而生的变量　33
3.3　数据类型　34
3.3.1　常用基础类型　34
3.3.2　对象类型　37
3.3.3　string详解　37
3.3.4　高精度数据类型　39
3.3.5　数组基础　40
3.4　数据类型间的转换　42
3.5　java中的常用运算符　43
3.5.1　赋值运算符　43
3.5.2　算术运算符　43
3.5.3　运算符的优先级别与结合特性　45
3.6　java的自留地——关键字　46
3.7　小结　47
3.8　习题　48
第4章　用如果造句——条件语句　49
4.1　如果…　49
4.1.1　关系条件　49
4.1.2　逻辑条件　52
4.1.3　用问号写最简洁的如果句子　53
4.2　否则…　54
4.2.1　如果与否则if…else…　54
4.2.2　如果里的如果——if 嵌套　54
4.3　开关switch　56
4.3.1　switch怎么用　56
4.3.2　switch与if的比较　58
4.3.3　用switch写个红绿灯开关　59
4.4　小结　60
4.5　习题　60
第5章　减轻重复劳动——循环语句　62
5.1　三千米的跑圈运动　62
5.1.1　用for语句跑圈　62
5.1.2　圈数加加，体力减减　66
5.1.3　什么时候用for　66
5.2　跑不动了怎么办　66
5.2.1　跳出比赛用break　67
5.2.2　偷工减料直接下一圈continue　67
5.3　圈圈的其他跑法　68
5.3.1　边跑边看终点的while　68
5.3.2　先跑一圈再说的do…while…　70
5.3.3　圈套圈——循环嵌套　71
5.4　各种跑圈方法的特点比较　75
5.5　小结　75
5.6　习题　76
第6章　对象是什么　77
6.1　一切都是对象　77
6.1.1　什么是对象　77
6.1.2　为什么要面向对象　79
6.2　包　80
6.2.1　包是什么　80
6.2.2　包起到什么作用　81
6.2.3　容易出错的包路径　82
6.2.4　使用包中的类　83
6.3　类　84
6.3.1　什么是类　84
6.3.2　类的结构　85
6.3.3　成员方法　86
6.3.4　成员变量和局部变量　87
6.3.5　公用还是私用　87
6.3.6　static关键字的使用　88
6.3.7　构造方法的意义　89
6.4　使用对象　90
6.4.1　创建对象　90
6.4.2　使用对象　92
6.4.3　对象的作用域　93
6.4.4　垃圾回收　93
6.5　小结　93
6.6　习题　94
第7章　对象深入　95
7.1　父子传承——继承　95
7.1.1　继承概念　95
7.1.2　继承的代码实现　96
7.1.3　继承中的类型转换　98
7.1.4　继承中的子类可以做些什么　98
7.1.5　单根继承　99
7.1.6　哪些遗产可以继承　99
7.1.7　继承后的初始化顺序　100
7.2　一名多用与青出于蓝　102
7.2.1　一名多用——方法的重载　102
7.2.2　青出于蓝——方法的覆写　103
7.3　抽象类与final类　105
7.3.1　我是模板之抽象类　105
7.3.2　巧用抽象类　106
7.3.3　我不要后代之final类　107
7.4　向世界说我能做到——接口　108
7.4.1　接口是什么　108
7.4.2　兑现承诺实现接口　109
7.4.3　面向接口编程　110
7.4.4　用接口实现多重继承特性　111
7.5　一切的根java.lang.object　112
7.6　小结　117
7.7　习题　118
第8章　形形色色的对象仓库　119
8.1　有序但容量有限的仓库——数组　119
8.1.1　单列门的床头柜——一维数组　119
8.1.2　分格书橱——二维数组　120
8.1.3　立体仓库——多维数组　122
8.1.４　经常出错之数组越界　122
8.2　不限容的大仓库arraylist　122
8.2.1　arraylist的定义..　123
8.2.2　添加对象到arraylist　123
8.2.3　从arraylist中获取对象　124
8.2.4　从arraylist中移除对象　124
8.2.5　arraylist其他常用方法　124
8.2.6　迭代器iterator实现arraylist的迭代　125
8.2.7　arraylist的自定义排序　127
8.3　不允许重复的仓库set　129
8.3.1　使用hashset类　129
8.3.2　使用treeset类　130
8.4　易于检索的仓库hashmap　130
8.4.1　hashmap的定义　131
8.4.2　hashmap优点　131
8.4.3　hashmap的数据存取　131
8.4.4　hashmap的迭代　132
8.5　其他仓库　133
8.5.1　hashtable的简介　133
8.5.2　vector的简介　133
8.5.3　treemap的简介　133
8.5.4　linkedlist的简介　134
8.6　让仓库更安全——泛型　135
8.7　小结　136
8.8　习题　136
第2篇　进阶
第9章　不当甩手掌柜——异常处理　141
9.1　出异常了　141
9.1.1　异常是什么　141
9.1.2　异常的分类　142
9.1.3　常见异常列表　143
9.2　捕捉捣蛋鬼之try…catch…　144
9.3　抓异常的处理策略　147
9.3.1　抓了不管的unchecked异常　147
9.3.2　两手硬抓的checked异常　150
9.4　自定义异常　151
9.5　抓住捣蛋鬼后的清场行动之finally使用　151
9.6　小结　153
9.7　习题　153
第10章　进出之道java输入输出系统　155
10.1　java i/o简介　155
10.1.1　流的概念　155
10.1.2　字节数据流　156
10.1.3　字符数据流　159
10.1.4　缓冲数据流　163
10.2　到命令行的输入输出　163
10.2.1　标准流　163
10.2.2　命令行上的输入输出　164
10.2.3　格式化输出　165
10.3　一步一步学文件操作　167
10.3.1　文件夹操作　167
10.3.2　文件操作　169
10.3.3　文件内容的读写　170
10.4　properties类文件的操作　170
10.4.1　读取properties文件　170
10.4.2　写入properties文件　171
10.4.3　properties类详解　173
10.5　serializable接口的使用　173
10.5.1　serializable概念　173
10.5.2　把对象写到硬盘上　174
10.6　小结　176
10.7　习题　176
第11章　榨干cpu之多线程　177
11.1　线程起步　177
11.1.1　进程与线程　177
11.1.2　可恶的排队　178
11.1.3　造个分身去排队　179
11.2　怎么创建线程　180
11.2.1　通过继承thread类创建线程　180
11.2.2　通过实现runnable接口创建线程　181
11.2.3　怎么选择最符合的创建方式　182
11.3　我想排到前面去　183
11.3.1　调整线程的优先级　183
11.3.2　线程的执行顺序　183
11.4　维持排队秩序——线程的控制　184
11.4.1　中断线程　184
11.4.2　join方法　185
11.4.3　sleep()方法　187
11.4.4　yield()方法　187
11.5　默默地做任务——守护线程　187
11.6　重要共享资源管理——线程的同步　188
11.6.1　多线程同写一块数据　188
11.6.2　线程同步方法　190
11.6.3　将代码块设为同步　191
11.6.4　线程死锁　191
11.7　线程间通信　192
11.7.1　线程的状态　192
11.7.2　wait()、notify()与notifyall()　192
11.7.3　几个不再被使用的方法　193
11.8　小结　193
11.9　习题　193
第12章　通往数据库的桥(jdbc)　194
12.1　什么是jdbc　195
12.1.1　jdbc简介　195
12.1.2　关系型数据库的常见操作　196
12.1.3　怎样获取正确的jdbc驱动程序　198
12.2　必须会使用的jdbc类　200
12.2.1　打开数据库的connection　200
12.2.2　执行指令的statement　203
12.2.3　查询结果集resultset　204
12.3　一步一步学查数据库　205
12.3.1　执行查询sql语句　205
12.3.2　处理查询结果　207
12.3.3　完整的查询示例　208
12.4　一步一步学各种数据库操作　210
12.4.1　怎么插入数据到数据库　210
12.4.2　怎么更新数据到数据库　211
12.4.3　怎么从数据库删除数据　211
12.5　jdbc处理事务　212
12.6　小结　212
12.7　习题　213
第13章　窗体程序开发技术(swing)　214
13.1　swing简介　214
13.2　跟我学用窗体说hello world　215
13.2.1　创建主窗体　215
13.2.2　创建菜单　217
13.2.3　创建工具栏　218
13.2.4　创建文本框　218
13.2.5　创建按钮　219
13.2.6　添加消息框　219
13.2.7　添加事件　220
13.2.8　完整代码　221
13.3　常用布局管理器　223
13.3.1　flowlayout布局　223
13.3.2　borderlayout布局　224
13.3.3　gridbaglayout布局　225
13.4　所见即所得的jigloo　226
13.4.1　jigloo的获得　227
13.4.2　jigloo的创建向导　227
13.4.3　jigloo的操作界面简介　227
13.5　小结　229
13.6　习题　229
第3篇　实战讲解
第14章　轻轻松松黑杰克(21点)　233
14.1　21点游戏的需求分析　233
14.1.1　需求用例分析　233
14.1.2　玩法分析　234
14.2　代码实现　234
14.2.1　card扑克牌　234
14.2.2　player玩家　235
14.2.3　dealer荷官　236
14.2.4　cardsinhand一手好牌　237
14.2.5　blackjack游戏开始　237
14.3　小结　241
第15章　应用实战之实用个人通讯册(c/s)　242
15.1　需求分析　242
15.2　数据库设计　243
15.3　界面设计　244
15.3.1　主界面设计　244
15.3.2　添加联系人界面　244
15.3.3　修改联系人界面　244
15.3.4　删除联系人界面　245
15.4　功能实现　245
15.4.1　工具代码　245
15.4.2　数据库表访问类　247
15.4.3　主界面代码　252
15.4.4　添加与修改界面代码　256
15.5　小结　259
附录　jdk命令详解.　260
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java轻松入门
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java编程思维
前言　　xi
第1章　编程之道　　1
1.1　何为编程　　1
1.2　何为计算机科学　　2
1.3　编程语言　　2
1.4　Hello World程序　　4
1.5　显示字符串　　5
1.6　转义序列　　5
1.7　设置代码格式　　6
1.8　调试代码　　7
1.9　术语表　　8
1.10　练习　　9
第2章　变量和运算符　　12
2.1　声明变量　　12
2.2　赋值　　13
2.3　状态图　　14
2.4　显示变量　　14
2.5　算术运算符　　15
2.6　浮点数　　16
2.7　舍入误差　　17
2.8　字符串运算符　　18
2.9　组合　　19
2.10　错误类型　　20
2.11　术语表　　22
2.12　练习　　24
第3章　输入和输出　　26
3.1　System类　　26
3.2　Scanner类　　27
3.3　程序结构　　28
3.4　英寸到厘米的转换　　29
3.5　字面量和常量　　30
3.6　设置输出的格式　　30
3.7　厘米到英寸的转换　　31
3.8　求模运算符　　32
3.9　整合　　33
3.10　Scanner类的bug　　34
3.11　术语表　　35
3.12　练习　　36
第4章　void方法　　38
4.1　Math类的方法　　38
4.2　再谈组合　　39
4.3　添加方法　　40
4.4　执行流程　　41
4.5　形参和实参　　42
4.6　多个形参　　43
4.7　栈图　　44
4.8　阅读文档　　45
4.9　编写文档　　47
4.10　术语表　　48
4.11　练习　　49
第5章　条件和逻辑　　51
5.1　关系运算符　　51
5.2　逻辑运算符　　52
5.3　条件语句　　53
5.4　串接和嵌套　　54
5.5　标志变量　　54
5.6　return语句　　55
5.7　验证输入　　56
5.8　递归方法　　56
5.9　递归栈图　　58
5.10　二进制数　　59
5.11　术语表　　60
5.12　练习　　61
第6章　值方法　　64
6.1　返回值　　64
6.2　编写方法　　66
6.3　方法组合　　68
6.4　重载　　69
6.5　boolean方法　　70
6.6　Javadoc标签　　70
6.7　再谈递归　　71
6.8　姑且相信　　73
6.9　再举一个例子　　74
6.10　术语表　　74
6.11　练习　　75
第7章　循环　　79
7.1　while语句　　79
7.2　生成表格　　80
7.3　封装和泛化　　82
7.4　再谈泛化　　84
7.5　for语句　　86
7.6　do-while循环　　87
7.7　break和continue　　87
7.8　术语表　　88
7.9　练习　　89
第8章　数组　　92
8.1　创建数组　　92
8.2　访问元素　　93
8.3　显示数组　　94
8.4　复制数组　　95
8.5　数组的长度　　96
8.6　数组遍历　　96
8.7　随机数　　97
8.8　遍历和计数　　98
8.9　生成直方图　　99
8.10　改进的for循环　　99
8.11　术语表　　100
8.12　练习　　101
第9章　字符串　　104
9.1　字符　　104
9.2　字符串是不可修改的　　105
9.3　字符串遍历　　106
9.4　子串　　107
9.5　方法indexOf　　107
9.6　字符串比较　　108
9.7　设置字符串的格式　　109
9.8　包装类　　110
9.9　命令行实参　　110
9.10　术语表　　111
9.11　练习　　112
第10章　对象　　116
10.1　Point对象　　116
10.2　属性　　117
10.3　将对象用作参数　　117
10.4　将对象作为返回类型　　118
10.5　可修改的对象　　119
10.6　指定别名　　120
10.7　关键字null　　121
10.8　垃圾收集　　122
10.9　类图　　122
10.10　Java类库的源代码　　123
10.11　术语表　　124
10.12　练习　　124
第11章　类　　128
11.1　Time类　　128
11.2　构造函数　　129
11.3　再谈构造函数　　130
11.4　获取方法和设置方法　　131
11.5　显示对象　　133
11.6　方法toString　　134
11.7　方法equals　　134
11.8　时间相加　　136
11.9　纯方法和非纯方法　　137
11.10　术语表　　138
11.11　练习　　139
第12章　对象数组　　142
12.1　Card对象　　142
12.2　方法toString　　144
12.3　类变量　　145
12.4　方法compareTo　　146
12.5　Card对象是不可修改的　　147
12.6　Card数组　　148
12.7　顺序查找　　149
12.8　二分法查找　　150
12.9　跟踪代码　　151
12.10　递归版本　　151
12.11　术语表　　152
12.12　练习　　152
第13章　数组对象　　155
13.1　Deck类　　155
13.2　洗牌　　156
13.3　选择排序　　157
13.4　合并排序　　158
13.5　方法subdeck　　158
13.6　方法merge　　159
13.7　添加递归　　160
13.8　术语表　　161
13.9　练习　　161
第14章　包含其他对象的对象　　163
14.1　Deck和手里的牌　　163
14.2　CardCollection　　164
14.3　继承　　166
14.4　发牌　　168
14.5　Player类　　169
14.6　Eights类　　171
14.7　类之间的关系　　174
14.8　术语表　　175
14.9　练习　　176
附录A　开发工具　　177
附录B　Java 2D图形　　186
附录C　调试　　192
作者简介　　202
封面简介　　202
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java编程思维
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE 核心技术与应用
第1章  走进Java EE	1
1.1  引言	1
1.2  为什么需要Java EE	1
1.2.1  企业级应用特征	1
1.2.2  企业级应用架构体系	2
1.3  什么是Java EE	3
1.4  Java EE设计思想	4
1.4.1  容器	4
1.4.2  组件	5
1.4.3  容器与组件的交互	5
1.5  Java EE 技术架构	5
1.5.1  组件技术	5
1.5.2  服务技术	7
1.5.3  通信技术	8
1.5.4  框架技术	9
1.6  Java EE核心开发模式	9
1.7  Java EE优点	10
1.8  小结	11
第2章  搭建开发环境	12
2.1  引言	12
2.2  安装JDK	12
2.3  安装NetBeans IDE	13
2.4  测试开发环境	14
2.5  小结	16
第3章  基于JSF构建表示逻辑层	17
3.1  引言	17
3.2  什么是JSF	17
3.2.1  什么是框架	17
3.2.2  为什么需要框架	17
3.2.3  JSF是什么样的框架	18
3.2.4  为什么学习JSF	19
3.3  第一个JSF应用	19
3.3.1  创建JSF项目	19
3.3.2  模型组件	21
3.3.3  视图组件	22
3.3.4  控制组件	22
3.3.5  运行演示	23
3.3.6  总结思考	23
3.4  利用JSF组件构建视图	24
3.4.1  JSF标记库	24
3.4.2  HTML标记	25
3.4.3  Core标记	39
3.4.4  使用JSTL标记	40
3.5  在视图中访问Web资源	41
3.6  利用页面模板提高视图可维护性	43
3.6.1  布局	43
3.6.2  装饰	48
3.7  利用Managed Bean封装业务逻辑	51
3.7.1  定义Managed Bean	51
3.7.2  生命周期范围	53
3.7.3  Bean之间的依赖	56
3.7.4  生命周期回调方法	58
3.8  使用EL访问服务器端数据	59
3.8.1  范围	59
3.8.2  访问对象	59
3.8.3  值表达式和方法表达式	60
3.8.4  延迟计算	61
3.9  实现灵活的导航控制	61
3.9.1  视图ID	61
3.9.2  利用Post请求实现导航	62
3.9.3  导航约定	66
3.9.4  导航规则	67
3.9.5  重定向	69
3.9.6  利用Get请求实现导航	71
3.9.7  JSF框架外导航	74
3.9.8  导航中的参数传递	74
3.9.9  导航总结	77
3.10  实现国际化支持	77
3.10.1  准备资源包	77
3.10.2  配置资源包	79
3.10.3  在JSF视图中使用资源	79
3.10.4  设置应用程序本地属性	80
3.11  使用Ajax获得更好的用户体验	81
3.12  小结	83
第4章  扩展JSF	84
4.1  引言	84
4.2  JSF请求处理过程	84
4.2.1  常规流程	84
4.2.2  示例分析	85
4.2.3  特殊流程	88
4.2.4  异常处理	89
4.2.5  总结思考	92
4.3  利用监听器实现事件处理	93
4.3.1  Value Change事件	93
4.3.2  Action事件	96
4.3.3  Phase事件	98
4.3.4  System事件	99
4.4  自定义类型转换	101
4.4.1  标准转换器	102
4.4.2  自定义转换器	102
4.5  自定义输入校验	105
4.5.1  标准校验器	105
4.5.2  自定义校验器	106
4.5.3  Bean方法校验	107
4.5.4  异常信息本地化	108
4.6  自定义复合组件	108
4.6.1  复合组件标记库	108
4.6.2  定制简单的复合组件	109
4.6.3  开发复杂的复合组件	111
4.7  自定义非UI组件	116
4.8  自定义UI组件	119
4.8.1  创建一个简单的UI组件	119
4.8.2  利用属性控制自定义组件行为	121
4.8.3  使用单独的渲染器	123
4.8.4  获取用户输入信息	125
4.8.5  保存组件状态	127
4.9  使用第三方组件	129
4.10  小结	130
第5章  利用Servlet处理复杂Web请求	131
5.1  引言	131
5.2  Servlet基础	131
5.2.1  什么是Servlet	131
5.2.2  Servlet工作流程	131
5.2.3  Servlet API	132
5.3  第一个Servlet	133
5.4  处理请求	138
5.5  生成响应	141
5.6  在JSF应用中处理非JSF请求	142
5.7  支撑自定义JSF组件	146
5.8  利用Filter过滤请求	149
5.9  小结	152
第6章  利用JPA访问企业信息	153
6.1  引言	153
6.2  数据库驱动与JDBC	153
6.3  连接池和数据源	154
6.3.1  基本概念	154
6.3.2  创建MySQL连接池	156
6.3.3  创建数据源	157
6.4  第一个JPA应用	158
6.4.1  持久化单元	158
6.4.2  Entity	159
6.4.3  EntityManager	161
6.4.4  运行演示	162
6.5  ORM	163
6.5.1  Entity	163
6.5.2  主键	164
6.5.3  复合主键	164
6.5.4  属性	167
6.5.5  关联映射	170
6.5.6  加载方式	173
6.5.7  顺序	174
6.5.8  继承映射	174
6.6  Entity管理	175
6.6.1  获取EntityManager	175
6.6.2  持久化上下文	176
6.6.3  Entity操作	176
6.6.4  级联操作	183
6.7  JPQL	184
6.7.1  动态查询	185
6.7.2  参数设置	186
6.7.3  命名查询	186
6.7.4  属性查询	187
6.7.5  使用构造器	187
6.8  基于Criteria API的安全查询	188
6.9  缓存	190
6.10  并发控制	192
6.11  生命周期回调方法	194
6.12  小结	195
第7章  使用会话Bean实现业务逻辑	196
7.1  引言	196
7.2  EJB基础	196
7.2.1  为什么需要EJB	196
7.2.2  EJB容器	197
7.2.3  EJB组件	198
7.2.4  EJB接口	199
7.2.5  EJB分类	199
7.2.6  部署EJB	200
7.2.7  EJB优点	200
7.3  无状态会话Bean	200
7.3.1  什么是无状态会话Bean	201
7.3.2  开发一个无状态会话Bean	202
7.3.3  利用Servlet测试无状态会话Bean	205
7.3.4  利用远程客户端测试无状态会话Bean	207
7.4  有状态会话Bean	208
7.4.1  基本原理	208
7.4.2  实现有状态会话Bean	209
7.5  单例会话Bean	213
7.5.1  基本原理	213
7.5.2  利用JSF访问单例会话Bean	213
7.5.3  并发控制	215
7.5.4  依赖管理	216
7.6  Time服务	217
7.7  拦截器	219
7.8  事务支持	221
7.9  异步方法	222
7.10  小结	227
第8章  利用CDI实现组件间低耦合	228
8.1  引言	228
8.2  CDI概述	228
8.3  CDI下的受控Bean	228
8.4  Bean的生命周期范围	232
8.5  使用限定符注入动态类型	237
8.6  使用替代组件实现部署时动态注入	239
8.7  使用生产方法注入动态内容	241
8.8  使用拦截器绑定类型注入功能服务	243
8.9  利用构造型封装注入操作	246
8.10  小结	247
第9章  使用Bean Validation校验数据	248
9.1  引言	248
9.2  Bean Validation概述	248
9.3  使用默认约束器	248
9.4  实现自定义约束器	251
9.5  约束的传递	254
9.5.1  继承	254
9.5.2  级联	255
9.6  小结	256
第10章  确保企业应用安全	257
10.1  引言	257
10.2  认证	257
10.2.1  配置文件安全域	257
10.2.2  配置JDBC安全域	258
10.2.3  声明认证配置	260
10.3  授权	260
10.3.1  授权声明	260
10.3.2  角色映射	261
10.4  测试Java EE容器的安全服务	262
10.5  定制FORM方式认证界面	262
10.6  在代码中获取用户身份信息	264
10.7  EJB安全控制	265
10.8  小结	267
第11章  为应用添加邮件发送功能	268
11.1  引言	268
11.2  JavaMail基础	268
11.2.1  JavaMail体系	268
11.2.2  JavaMail规范组成	269
11.3  配置JavaMail会话	270
11.4  发送邮件	270
11.5  发送带附件的邮件	272
11.6  小结	275
第12章  利用Web服务集成应用	276
12.1  引言	276
12.2  Web服务概述	276
12.2.1  什么是Web服务	276
12.2.2  Web服务技术体系	276
12.2.3  Web服务工作模型	278
12.3  Java EE平台下的Web服务实现	278
12.4  开发Web服务实例	278
12.4.1  创建Web服务组件	279
12.4.2  为Web服务组件添加业务逻辑	280
12.4.3  部署Web服务	280
12.4.4  测试Web服务	280
12.5  调用Web服务	282
12.5.1  添加Web服务客户端	282
12.5.2  调用Web服务	283
12.6  将会话Bean发布为Web 服务	285
12.7  RESTful Web服务	286
12.7.1  什么是REST	286
12.7.2  利用JAX-RS开发RESTful Web服务	287
12.7.3  与SOAP对比	290
12.8  Web服务的优缺点	291
12.9  小结	292
第13章  利用消息服务实现应用间异步交互	293
13.1  引言	293
13.2  JMS概述	293
13.2.1  JMS消息模型	293
13.2.2  JMS消息服务接口	293
13.2.3  消息传递模式	294
13.3  配置消息服务资源和连接工厂	294
13.4  发送JMS消息	295
13.5  利用MDB处理消息	296
13.6  小结	298
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE 核心技术与应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程核心技术（第2版）
前言
第1章　Java多线程技能1
1.1　进程和多线程概述1
1.2　使用多线程5
1.2.1　继承Thread类5
1.2.2　使用常见命令分析线程的信息8
1.2.3　线程随机性的展现11
1.2.4　执行start()的顺序不代表执行run()的顺序12
1.2.5　实现Runnable接口13
1.2.6　使用Runnable接口实现多线程的优点14
1.2.7　实现Runnable接口与继承Thread类的内部流程16
1.2.8　实例变量共享造成的非线程安全问题与解决方案17
1.2.9　Servlet技术造成的非线程安全问题与解决方案21
1.2.10　留意i--与System.out.println()出现的非线程安全问题24
1.3　currentThread()方法26
1.4　isAlive()方法29
1.5　sleep(long millis)方法31
1.6　sleep(long millis, int nanos)方法33
1.7　StackTraceElement[] getStackTrace()方法33
1.8　static void dumpStack()方法35
1.9　static Map<Thread, StackTrace-Element[]> getAllStackTraces()方法36
1.10　getId()方法38
1.11　停止线程38
1.11.1　停止不了的线程39
1.11.2　判断线程是否为停止状态41
1.11.3　能停止的线程—异常法43
1.11.4　在sleep状态下停止线程47
1.11.5　用stop()方法暴力停止线程49
1.11.6　stop()方法与java.lang.ThreadDeath异常51
1.11.7　使用stop()释放锁给数据造成不一致的结果52
1.11.8　使用“return;”语句停止线程的缺点与解决方案54
1.12　暂停线程57
1.12.1　suspend()方法与resume()方法的使用57
1.12.2　suspend()方法与resume()方法的缺点—独占58
1.12.3　suspend()方法与resume()方法的缺点—数据不完整62
1.13　yield()方法63
1.14　线程的优先级64
1.14.1　线程优先级的继承特性65
1.14.2　优先级的规律性66
1.14.3　优先级的随机性68
1.14.4　优先级对线程运行速度的影响70
1.15　守护线程71
1.16　本章小结73
第2章　对象及变量的并发访问74
2.1　synchronized同步方法74
2.1.1　方法内的变量为线程安全74
2.1.2　实例变量非线程安全问题与解决方案77
2.1.3　同步synchronized在字节码指令中的原理80
2.1.4　多个对象多个锁81
2.1.5　将synchronized方法与对象作为锁84
2.1.6　脏读89
2.1.7　synchronized锁重入91
2.1.8　锁重入支持继承的环境93
2.1.9　出现异常，锁自动释放94
2.1.10　重写方法不使用synchronized96
2.1.11　public static boolean holdsLock(Object obj)方法的使用99
2.2　synchronized同步语句块99
2.2.1　synchronized方法的弊端99
2.2.2　synchronized同步代码块的使用102
2.2.3　用同步代码块解决同步方法的弊端104
2.2.4　一半异步，一半同步105
2.2.5　synchronized代码块间的同步性108
2.2.6　println()方法也是同步的110
2.2.7　验证同步synchronized(this)代码块是锁定当前对象的110
2.2.8　将任意对象作为锁113
2.2.9　多个锁就是异步执行116
2.2.10　验证方法被调用是随机的118
2.2.11　不同步导致的逻辑错误及其解决方法121
2.2.12　细化验证3个结论124
2.2.13　类Class的单例性129
2.2.14　静态同步synchronized方法与synchronized(class)代码块130
2.2.15　同步syn static方法可以对类的所有对象实例起作用135
2.2.16　同步syn(class)代码块可以对类的所有对象实例起作用137
2.2.17　String常量池特性与同步相关的问题与解决方案138
2.2.18　同步synchronized方法无限等待问题与解决方案141
2.2.19　多线程的死锁143
2.2.20　内置类与静态内置类146
2.2.21　内置类与同步：实验1149
2.2.22　内置类与同步：实验2151
2.2.23　锁对象改变导致异步执行153
2.2.24　锁对象不改变依然同步执行156
2.2.25　同步写法案例比较158
2.3　volatile关键字159
2.3.1　可见性的测试159
2.3.2　原子性的测试168
2.3.3　禁止代码重排序的测试176
2.4　本章小结187
第3章　线程间通信188
3.1　wait/notify机制188
3.1.1　不使用wait/notify机制实现线程间通信188
3.1.2　wait/notify机制191
3.1.3　wait/notify机制的原理192
3.1.4　wait()方法的基本使用192
3.1.5　完整实现wait/notify机制194
3.1.6　使用wait/notify机制实现list.size()等于5时的线程销毁195
3.1.7　对业务代码进行封装198
3.1.8　线程状态的切换201
3.1.9　wait()方法：立即释放锁202
3.1.10　sleep()方法：不释放锁203
3.1.11　notify()方法：不立即释放锁204
3.1.12　interrupt()方法遇到wait()方法206
3.1.13　notify()方法：只通知一个线程208
3.1.14　notifyAll()方法：通知所有线程211
3.1.15　wait(long)方法的基本使用212
3.1.16　wait(long)方法自动向下运行需要重新持有锁214
3.1.17　通知过早问题与解决方法217
3.1.18　wait条件发生变化与使用while的必要性220
3.1.19　生产者/消费者模式的实现224
3.1.20　通过管道进行线程间通信—字节流250
3.1.21　通过管道进行线程间通信—字符流253
3.1.22　实现wait/notify的交叉备份256
3.2　join()方法的使用259
3.2.1　学习join()方法前的铺垫259
3.2.2　join()方法和interrupt()方法出现异常261
3.2.3　join(long)方法的使用263
3.2.4　join(long)方法与sleep(long)方法的区别264
3.2.5　join()方法后面的代码提前运行—出现意外 268
3.2.6　join()方法后面的代码提前运行—解释意外270
3.2.7　join(long millis, int nanos)方法的使用273
3.3　类ThreadLocal的使用273
3.3.1　get()方法与null274
3.3.2　类ThreadLocal存取数据流程分析275
3.3.3　验证线程变量的隔离性277
3.3.4　解决get()方法返回null的问题282
3.3.5　验证重写initialValue()方法的隔离性283
3.4　类InheritableThreadLocal的使用284
3.4.1　类ThreadLocal不能实现值继承285
3.4.2　使用InheritableThreadLocal体现值继承特性286
3.4.3　值继承特性在源代码中的执行流程288
3.4.4　父线程有最新的值，子线程仍是旧值291
3.4.5　子线程有最新的值，父线程仍是旧值293
3.4.6　子线程可以感应对象属性值的变化294
3.4.7　重写childValue()方法实现对继承的值进行加工297
3.5　本章小结298
第4章　Lock对象的使用299
4.1　使用ReentrantLock类299
4.1.1　使用ReentrantLock实现同步299
4.1.2　验证多代码块间的同步性301
4.1.3　await()方法的错误用法与更正304
4.1.4　使用await()和signal()实现wait/notify机制307
4.1.5　await()方法暂停线程运行的原理309
4.1.6　通知部分线程—错误用法312
4.1.7　通知部分线程—正确用法314
4.1.8　实现生产者/消费者模式一对一交替输出317
4.1.9　实现生产者/消费者模式多对多交替输出319
4.1.10　公平锁与非公平锁321
4.1.11　public int getHoldCount()方法的使用324
4.1.12　public final int getQueue Length()方法的使用325
4.1.13　public int getWaitQueue-Length (Condition condition)方法的使用327
4.1.14　public final boolean has-QueuedThread (Thread thread)方法的使用328
4.1.15　public final boolean has-QueuedThreads()方法的使用329
4.1.16　public boolean hasWaiters (Con-dition condition)方法的使用331
4.1.17　public final boolean isFair()方法的使用332
4.1.18　public boolean isHeldBy-CurrentThread()方法的使用333
4.1.19　public boolean isLocked()方法的使用334
4.1.20　public void lockInterruptibly()方法的使用335
4.1.21　public boolean tryLock()方法的使用336
4.1.22　public boolean tryLock (long timeout, TimeUnit unit)方法的使用338
4.1.23　public boolean await (long time, TimeUnit unit)方法的使用339
4.1.24　public long awaitNanos(long nanosTimeout)方法的使用341
4.1.25　public boolean awaitUntil(Date deadline)方法的使用342
4.1.26　public void awaitUninterru-ptibly()方法的使用344
4.1.27　实现线程按顺序执行业务346
4.2　使用ReentrantReadWriteLock类349
4.2.1　ReentrantLock类的缺点349
4.2.2　ReentrantReadWriteLock类的使用—读读共享351
4.2.3　ReentrantReadWriteLock类的使用—写写互斥352
4.2.4　ReentrantReadWriteLock类的使用—读写互斥352
4.2.5　ReentrantReadWriteLock类的使用—写读互斥354
4.3　本章小结355
第5章　定时器Timer356
5.1　定时器Timer的使用356
5.1.1　schedule(TimerTask task, Datetime)方法的测试356
5.1.2　schedule(TimerTask task, Date firstTime, long period)方法的测试366
5.1.3　schedule(TimerTask task, long delay)方法的测试374
5.1.4　schedule(TimerTask task, long delay, long period)方法的测试374
5.1.5　scheduleAtFixedRate (TimerTask task, Date firstTime, long period)方法的测试375
5.2　本章小结384
第6章　单例模式与多线程385
6.1　立即加载/饿汉模式385
6.2　延迟加载/懒汉模式387
6.2.1　延迟加载/懒汉模式解析387
6.2.2　延迟加载/懒汉模式的缺点388
6.2.3　延迟加载/懒汉模式的解决方案390
6.3　使用静态内置类实现单例模式399
6.4　序列化与反序列化的单例模式实现400
6.5　使用static代码块实现单例模式402
6.6　使用enum枚举数据类型实现单例模式404
6.7　完善使用enum枚举数据类型实现单例模式405
6.8　本章小结407
第7章　拾遗增补408
7.1　线程的状态408
7.1.1　验证NEW、RUNNABLE和TERMINATED410
7.1.2　验证TIMED_WAITING411
7.1.3　验证BLOCKED412
7.1.4　验证WAITING414
7.2　线程组415
7.2.1　线程对象关联线程组：一级关联416
7.2.2　线程对象关联线程组：多级关联417
7.2.3　线程组自动归属特性418
7.2.4　获取根线程组419
7.2.5　线程组中加线程组420
7.2.6　组内的线程批量停止421
7.2.7　递归取得与非递归取得组内对象422
7.3　Thread.activeCount()方法的使用423
7.4　Thread.enumerate(Thread tarray[])方法的使用423
7.5　再次实现线程执行有序性424
7.6　SimpleDateFormat非线程安全426
7.6.1　出现异常426
7.6.2　解决异常的方法1428
7.6.3　解决异常的方法2430
7.7　线程中出现异常的处理431
7.7.1　线程出现异常的默认行为431
7.7.2　使用setUncaughtException-Handler()方法进行异常处理432
7.7.3　使用setDefaultUncaughtExce-ptionHandler()方法进行异常处理433
7.8　线程组内处理异常434
7.9　线程异常处理的优先性437
7.10　本章小结442
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程核心技术（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JAVA 2实用教程（第二版）
第一章  Java语言入门
第二章  标识符、关键字和数据类型
第三章  运算符、表达式和语句
第四章  类、对象和接口
第五章  数组与字符串
第六章  时间、日期和数字
第七章  AWT工具集简介
第八章  Java Applet基础
第九章  文本框和文本区
第十章  按钮与标签
第十一章  面板和画布
第十二章  布局设计
第十三章  选择型组件
第十四章  Component类的常用方法
第十五章  建立窗口和菜单
第十六章  建立对话框
第十七章  Java与图形
第十八章  Java中的鼠标事件和键盘事件
第十九章  Java多线程机制
第二十章  输入输出流
第二十一章  Java网络的基本知识
第二十二章  Java与图像
第二十三章  Java数据库连接（JDBC）
第二十四章  Java与多媒体
第二十五章  Java Swing基础
第二十六章  常见数据结构的Java实现
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JAVA 2实用教程（第二版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java逍遥游记
第1章 第一个、Java程序
1.1 程序的基本概念
1.2.Java程序的基本运行原理
1.3 创建面向对象的Java源程序
1.3.1 定义Monkey类
1.3.2 创建Monkey对象
1.3.3 程序入口main（）方法
1.4 编译和运行Java程序
1.4.1 JDK简介
1.4.2 本范例的目录结构
1.4.3 编译Java源程序
1.4.4 运行Java程序
1.4.5 创建用于编译和运行Java程序的批处理文件
1.5 小结
第2章 Java语言的基本语法
2.1 Java源文件结构
2.2 关键字
2.3 标识符
2.4 Java语言大小写敏感
2.5 包声明语句
2.6 包引入语句
2.7 方法的声明
2.8 注释语句
2.9 编程规范
2.10 Java.Doc文档
2.11 编译和运行本章 范例.
2.12 小结
第3章 数据类型
3.1 基本数据类型
3.1.1 boolean类型
3.1.2 byte、short、int和long类型
3.1.3 char类型与字符编码
3.1.4 floatdouble类型
3.2 引用类型
3.3 基本类型与引用类型的区别
3.4 直接数
3.4.1 直接数的类型
3.4.2 直接数的赋值
3.5 小结
第4章 变量
4.1 变量的作用域
4.1.1 实例变量和静态变量
4.1.2 静态变量的作用
4.1.3 成员变量和局部变量同名
4.2 对象的默认引用：this
4.3 参数传递
4.4 变量的初始化及默认值
4.4.1 成员变量的初始化
4.4.2 局部变量的初始化
4.4.3 new关键字创建对象
4.5 小结
第5章 基本类型操作符
5.1 操作符的优先级
5.2 整型操作符
5.2.1 一元整型操作符
5.2.2 元整型操作符
5.3 浮点型操作符
5.4 比较操作符和逻辑操作符
5.4.1 比较操作符
5.4.2 逻辑操作符
5.5 特殊操作符
5.6 变量的赋值
5.7 基本数据类型转换
5.7.1 自动类型转换
5.7.2 强制类型转换
5.8 小结
第6章 流程控制
6.1 分支语句
6.1.1 if.else语句
6.1.2 switch语句
6.2 循环语句
6.2.1 while语句
6.2.2 do.while语句
6.2.3 for语句
6.3 流程跳转语句
6.4.小结
第7章 继承
7.1 继承的基本语法
7.2 方法重载（Overload）
7.3 方法覆盖（Override）
7.4 方法覆盖与方法重载的异同
7.5 super关键字
7.6 多态
7.7 小结
第8章 引用类型操作符
8.1 字符串连接操作符“+”
8.2 操作符“==”与对象的equals（）方法
8.2.1 操作符“==”
8.2.2 对象equals（）方法
8.3 操作符“！＝”
8.4 引用变量的赋值和类型转换
8.5 instanceof操作符
8.6 小结
第9章 访问控制修饰符
9.1 封装类的部分属性和方法
9.2 4种访问控制级别
9.3 小结
第10章 abstract（抽象）修饰符
10.1 abstract修饰符的修饰内容
10.2 abstract修饰符的语法规则
10.3 抽象类不能被实例化
10.4 小结
第11章 final（不可改变）修饰符
11.1 final类
11.2 final方法
11.3 final变量
11.4 小结
第12章 static（静态）修饰符
12.1 static变量
12.2 static方法
12.2.1 静态方法可访问的内容
12.2.2 实例方法可访问的内容
12.2.3 静态方法必须被实现
12.2.4 作为程序入口的main（）方法是静态方法
12.3 static代码块
12.4 小结
第13章 接口
13.1 接口的概念和语法规则
13.2 比较抽象类与接口
13.3 小结
第14章 对象的生命周期
14.1 对象的构造方法
14.1.1 重载构造方法
14.1.2 默认构造方法
14.1.3 子类调用父类的构造方法
14.2 垃圾回收
14.2.1 垃圾回收的时机
14.2.2 对象的finalize（）方法
14.3 小结
第15章 内部类
15.1 内部类的种类
15.2 成员内部类
15.2.1 实例内部类
15.2.2 静态内部类
……
第16章 异常处理
第17章 数组
第18章 输入/输出
第19章 多线程(上)
第20章 多线程(下)
第21章 图形用户界面
第22章 Swing组件
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java逍遥游记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java改错学习法
1．动手才是硬道理
2．从简单的程序开始
3．如何设置路径
4．正确引用对象
5．调试一个简单的程序
6．正确区分基本类型变量和引用类型变量
7．破坏性地阅读程序
8．正确区分String和StringBuffer
9．什么时候使用String或StringBuffer
10．认清逻辑操作符和短路逻辑操作符
11．弄清Iength和length()的使用场合
12．学会用数据测试程序
13．Java语言中有无穷大这个数
14．编译和执行带Package语句的Java文件
15．运行时需要命令行参数的程序
16．实例变量与类变量
17．实例方法和类方法
18．实参与形参的传递问题
19．默认的构造方法
20．修饰符之间的搭配
21．变量的作用域
22．不要破坏封装性
23．利用finaI修饰的成员变量
24．正确使用main方法
25．子类、父类的继承与覆盖问题
26．类的继承技巧
27．类的设计技巧
28．抽象类如何创建对象
29．如何判断两个对象相等
30．继承的设计技巧
31．对象的克隆
32．接口是一种约定
33．从字符界面到图形界面
34．内部类、适配器类和匿名内部类
35．在面板中显示信息
36．如何将AWT程序改成Swing程序
37．了解事件的响应过程
38．掌握MVC设计模式
39．使用参数向Applet传递信息
40．一个双用的Java程序
41．找出线程中的陷阱
42．如何捕获异常
43．如何深度地调试程序
44．在Eclipse中使用JUnit调试程序
45．路漫漫其修远兮

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java改错学习法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java高效编程指南
第1章 绪论第2章 创建及销毁对

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java高效编程指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web开发详解
第I篇 XML篇
第1章 XML
第2章 DTD
第3章 XML名称空间
第4章 XMLSchema
第5章 使用DOM、SAX和JAXP解析XML文档
第6章 使用JDOM解析XML文档
第7章 使用dom4j解析XML文档
第8章 解析名称空间
第9章 XSLT1.0
第10章 XSLT2.0
第II篇 Servlet篇
第11章 Servlet与Tomcat
第12章 Servlet技术
第13章 Web应用程序的部署
第14章 数据库访问
第15章 会话跟踪
第16章 Servlet的异常处理机制
第17章 开发线程安全的Servlet
第III篇 JSP篇
第18章 JSP技术
第19章 JSP与JavaBean
第20章 JSP开发的两种模型
第21章 标签库（TagLibrary）
第22章 表达式语言（EL）
第23章 JSP标准标签库（JSTL）
第24章 标签文件（TagFiles）
第IV篇 应用篇
第25章 Servlet监听器
第26章 Filter在Web开发中的应用
第27章 中文乱码问题与国际化
第28章 开发安全的Web应用程序
第29章 使用Eclipse开发Web应用
第30章 Web应用程序开发实例
第31章 使用Log4j进行日志操作
第32章 使用Ant辅助Web应用程序开发
第33章 Servlet3.0新特性详解
第34章 XML和XSLT在Web开发中的应用
（以下内容见配书光盘）
附录A快速掌握HTML
附录B解析HTTP
附录Cserver.xml文件
附录Dweb.xml文件
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web开发详解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>程序员代码面试指南：IT名企算法与数据结构题目最优解
第1章栈和队列 1
设计一个有getMin功能的栈（士★☆☆☆） 1
由两个栈组成的队列（尉★★☆☆） 5
如何仅用递归函数和栈操作逆序一个栈（尉★★☆☆） 8
猫狗队列（士★☆☆☆）10
用一个栈实现另一个栈的排序（士★☆☆☆） 13
用栈来求解汉诺塔问题（校★★★☆） 14
生成窗口最大值数组（尉★★☆☆） 19
构造数组的MaxTree（校★★★☆） 22
求最大子矩阵的大小（校★★★☆） 26
最大值减去最小值小于或等于num的子数组数量（校★★★☆） 31
第2章链表问题34
打印两个有序链表的公共部分（士★☆☆☆） 34
在单链表和双链表中删除倒数第K 个节点（士★☆☆☆） 35
删除链表的中间节点和a/b 处的节点（士★☆☆☆） 38
反转单向和双向链表（士★☆☆☆） 40
反转部分单向链表（士★☆☆☆） 42
环形单链表的约瑟夫问题（原问题：士★☆☆☆进阶：校★★★☆）43
判断一个链表是否为回文结构（普通解法士★☆☆☆）（进阶解法尉★★☆☆） 48
将单向链表按某值划分成左边小、中间相等、右边大的形式（尉★★☆☆） 52
复制含有随机指针节点的链表（尉★★☆☆） 56
两个单链表生成相加链表（士★☆☆☆） 59
两个单链表相交的一系列问题（将★★★★） 62
将单链表的每K个节点之间逆序（尉★★☆☆） 68
删除无序单链表中值重复出现的节点（士★☆☆☆） 71
在单链表中删除指定值的节点（士★☆☆☆） 73
将搜索二叉树转换成双向链表（尉★★☆☆） 74
单链表的选择排序（士★☆☆☆） 79
一种怪异的节点删除方式（士★☆☆☆） 81
向有序的环形单链表中插入新节点（士★☆☆☆） 82
合并两个有序的单链表（士★☆☆☆） 84
按照左右半区的方式重新组合单链表（士★☆☆☆） 86
第3章二叉树问题 88
分别用递归和非递归方式实现二叉树先序、中序和后序遍历（校★★★☆） 88
打印二叉树的边界节点（尉★★☆☆） 95
如何较为直观地打印二叉树（尉★★☆☆） 100
二叉树的序列化和反序列化（士★☆☆☆） 103
遍历二叉树的神级方法（将★★★★） 107
在二叉树中找到累加和为指定值的最长路径长度（尉★★☆☆） 115
找到二叉树中的最大搜索二叉子树（尉★★☆☆） 117
找到二叉树中符合搜索二叉树条件的最大拓扑结构（校★★★☆）119
二叉树的按层打印与ZigZag打印（尉★★☆☆） 129
调整搜索二叉树中两个错误的节点（原问题：尉★★☆☆）（进阶问题：将★★★★） 134
判断t1树是否包含t2 树全部的拓扑结构（士★☆☆☆） 140
判断t1树中是否有与t2 树拓扑结构完全相同的子树（校★★★☆）141
判断二叉树是否为平衡二叉树（士★☆☆☆） 144
根据后序数组重建搜索二叉树（士★☆☆☆） 145
判断一棵二叉树是否为搜索二叉树和完全二叉树（士★☆☆☆） 147
通过有序数组生成平衡搜索二叉树（士★☆☆☆） 150
在二叉树中找到一个节点的后继节点（尉★★☆☆） 151
在二叉树中找到两个节点的最近公共祖先（原问题：士★☆☆☆）（进阶问题：尉★★☆☆再进阶问题：校★★★☆）153
Tarjan算法与并查集解决二叉树节点间最近公共祖先的批量查询问题（校★★★☆） 159
二叉树节点间的最大距离问题（尉★★☆☆） 169
先序、中序和后序数组两两结合重构二叉树（先序与中序结合士★☆☆☆）（中序与后序结合士★☆☆☆先序与后序结合尉★★☆☆）171
通过先序和中序数组生成后序数组（士★☆☆☆） 174
统计和生成所有不同的二叉树（尉★★☆☆） 175
统计完全二叉树的节点数（尉★★☆☆） 178
第4章递归和动态规划181
斐波那契系列问题的递归和动态规划（将★★★★） 181
矩阵的最小路径和（尉★★☆☆） 187
换钱的最少货币数（尉★★☆☆） 191
换钱的方法数（尉★★☆☆） 196
最长递增子序列（校★★★☆） 202
汉诺塔问题（校★★★☆） 206
最长公共子序列问题（尉★★☆☆） 210
最长公共子串问题（校★★★☆） 213
最小编辑代价（校★★★☆） 217
字符串的交错组成（校★★★☆） 220
龙与地下城游戏问题（尉★★☆☆） 223
数字字符串转换为字母组合的种数（尉★★☆☆） 225
表达式得到期望结果的组成种数（校★★★☆） 228
排成一条线的纸牌博弈问题（尉★★☆☆） 233
跳跃游戏（士★☆☆☆）235
数组中的最长连续序列（尉★★☆☆） 236
N皇后问题（校★★★☆） 238
第5章字符串问题 242
判断两个字符串是否互为变形词（士★☆☆☆） 242
字符串中数字子串的求和（士★☆☆☆） 243
去掉字符串中连续出现k 个0 的子串（士★☆☆☆） 245
判断两个字符串是否互为旋转词（士★☆☆☆） 247
将整数字符串转成整数值（尉★★☆☆） 248
替换字符串中连续出现的指定字符串（士★☆☆☆） 251
字符串的统计字符串（士★☆☆☆） 253
判断字符数组中是否所有的字符都只出现过一次（按要求1 实现的方法士★☆☆☆）（按要求2 实现的方法尉★★☆☆） 255
在有序但含有空的数组中查找字符串（尉★★☆☆） 258
字符串的调整与替换（士★☆☆☆） 260
翻转字符串（士★☆☆☆） 262
数组中两个字符串的最小距离（尉★★☆☆） 266
添加最少字符使字符串整体都是回文字符串（校★★★☆） 269
括号字符串的有效性和最长有效长度（原问题士★☆☆☆）（补充问题尉★★☆☆） 273
公式字符串求值（校★★★☆） 276
0 左边必有1 的二进制字符串数量（校★★★☆） 278
拼接所有字符串产生字典顺序最小的大写字符串（校★★★☆）281
找到字符串的最长无重复字符子串（尉★★☆☆） 284
找到被指的新类型字符（士★☆☆☆） 286
最小包含子串的长度（校★★★☆） 288
回文最少分割数（尉★★★☆） 292
字符串匹配问题（校★★★☆） 294
字典树（前缀树）的实现（尉★★☆☆） 299
第6章大数据和空间限制 303
认识布隆过滤器（尉★★☆☆） 303
只用2GB 内存在20 亿个整数中找到出现次数最多的数（士★☆☆☆） . 308
40 亿个非负整数中找到没出现的数（尉★★☆☆） 309
找到100 亿个URL 中重复的URL 以及搜索词汇的top K 问题（士★☆☆☆） 311
40 亿个非负整数中找到出现两次的数和所有数的中位数（尉★★☆☆） 312
一致性哈希算法的基本原理（尉★★☆☆） 313
第7章位运算 317
不用额外变量交换两个整数的值（士★☆☆☆） 317
不用任何比较判断找出两个数中较大的数（校★★★☆） 318
只用位运算不用算术运算实现整数的加减乘除运算（尉★★☆☆） 319
整数的二进制表达中有多少个1（尉★★☆☆） 325
在其他数都出现偶数次的数组中找到出现奇数次的数（尉★★☆☆） 327
在其他数都出现k 次的数组中找到只出现一次的数（尉★★☆☆） 329
第8章数组和矩阵问题331
转圈打印矩阵（士★☆☆☆） 331
将正方形矩阵顺时针转动90°（士★☆☆☆） 333
"之"字形打印矩阵（士★☆☆☆） 335
找到无序数组中最小的k 个数（O(Nlogk)的方法尉★★☆☆）（O(N)的方法将★★★★） 336
需要排序的最短子数组长度（士★☆☆☆） 342
在数组中找到出现次数大于N/K 的数（校★★★☆）343
在行列都排好序的矩阵中找数（士★☆☆☆） 347
最长的可整合子数组的长度（尉★★☆☆） 349
不重复打印排序数组中相加和为给定值的所有二元组和三元组（尉★★☆☆） 351
未排序正数数组中累加和为给定值的最长子数组长度（尉★★☆☆）354
未排序数组中累加和为给定值的最长子数组系列问题（尉★★☆☆）355
未排序数组中累加和小于或等于给定值的最长子数组长度（校★★★☆） 358
计算数组的小和（校★★★☆） 361
自然数数组的排序（士★☆☆☆） 364
奇数下标都是奇数或者偶数下标都是偶数（士★☆☆☆）366
子数组的最大累加和问题（士★☆☆☆） 367
子矩阵的最大累加和问题（尉★★☆☆） 368
在数组中找到一个局部最小的位置（尉★★☆☆） 371
数组中子数组的最大累乘积（尉★★☆☆） 373
打印N 个数组整体最大的Top K（尉★★☆☆） 374
边界都是1 的最大正方形大小（尉★★☆☆） 377
不包含本位置值的累乘数组（士★☆☆☆） 380
数组的partition 调整（士★☆☆☆） 382
求最短通路值（尉★★☆☆） 384
数组中未出现的最小正整数（尉★★☆☆） 386
数组排序之后相邻数的最大差值（尉★★☆☆） 388
第9章其他题目390
从5 随机到7 随机及其扩展（原问题尉★★☆☆补充问题尉★★☆☆）（进阶问题校★★★☆）390
一行代码求两个数的最大公约数（士★★☆☆） 394
有关阶乘的两个问题（原问题尉★★☆☆进阶问题校★★★☆）395
判断一个点是否在矩形内部（尉★★☆☆） 398
判断一个点是否在三角形内部（尉★★☆☆） 399
折纸问题（尉★★☆☆）402
蓄水池算法（尉★★☆☆） 404
设计有setAll功能的哈希表（士★☆☆☆） 406
最大的leftMax与rightMax之差的绝对值（校★★★☆）408
设计可以变更的缓存结构（尉★★☆☆） 410
设计RandomPool结构（尉★★☆☆） 414
调整[0,x)区间上的数出现的概率（士★☆☆☆） 416
路径数组变为统计数组（校★★★☆） 417
正数数组的最小不可组成和（尉★★☆☆） 422
一种字符串和数字的对应关系（校★★★☆） 426
1 到n 中1 出现的次数（校★★★☆） 429
从N 个数中等概率打印M 个数（士★☆☆☆） 431
判断一个数是否是回文数（士★☆☆☆） 433
在有序旋转数组中找到最小值（尉★★☆☆） 434
在有序旋转数组中找到一个数（尉★★☆☆） 436
数字的英文表达和中文表达（校★★★☆） 439
分糖果问题（校★★★☆） 444
一种消息接收并打印的结构设计（尉★★☆☆） 448
设计一个没有扩容负担的堆结构（将★★★★） 451
随时找到数据流的中位数（将★★★★） 462
在两个长度相等的排序数组中找到上中位数（尉★★☆☆） 465
在两个排序数组中找到第K 小的数（将★★★★） 468
两个有序数组间相加和的TOP K 问题（尉★★☆☆）471
出现次数的TOP K 问题（原问题尉★★☆☆进阶问题校★★★☆） 474
Manacher算法（将★★★★） 483
KMP 算法（将★★★★） 491
丢棋子问题（校★★★☆） 498
画匠问题（校★★★☆）505
邮局选址问题（校★★★☆） 509
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>程序员代码面试指南：IT名企算法与数据结构题目最优解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web开发实战
目    录
第1篇  JSP基础
第1章  走进JSP	2
视频讲解：3分钟
1.1  JSP概述	3
1.1.1  什么是JSP	3
1.1.2  项目成功案例	3
1.1.3  如何学好JSP	4
1.2  JSP技术特征	5
1.2.1  跨平台	5
1.2.2  业务代码分离	5
1.2.3  组件重用	5
1.2.4  继承Java Servlet功能	5
1.2.5  预编译	6
1.3  搭建JSP开发环境	6
1.3.1  安装Java开发工具包JDK	6
1.3.2  安装和配置Web服务器	7
1.3.3  安装与使用数据库	9
1.4  Eclipse开发工具的安装与使用	12
1.4.1  Eclipse的下载与安装	13
1.4.2  启动Eclipse	13
1.4.3  安装Eclipse中文语言包	13
1.4.4  Eclipse工作台	14
1.4.5  配置服务器	14
1.4.6  指定Web浏览器	15
1.4.7  设置JSP页面的编码格式	16
1.5  开发第一个JSP程序	16
1.5.1  编写JSP程序	16
1.5.2  运行JSP程序	17
1.6  JSP常用资源	18
1.6.1  JSP资源	18
1.6.2  Eclipse资源	18
1.7  实战	19
1.7.1  修改Tomcat服务器的端口号	19
1.7.2  通过复制Web应用到Tomcat部署Web
应用	19
1.7.3  通过在server.xml文件中配置<Context>
元素部署Web应用	19
1.7.4  设置Eclipse工作空间的字符编码	19
1.7.5  为项目导入所需的Jar包	20
1.8  本章小结	20
第2章  掌握JSP语法	21
视频讲解：50分钟
2.1  了解JSP的基本构成	22
2.2  指令标签	22
2.2.1  page指令	22
2.2.2  include指令	24
2.2.3  taglib指令	25
2.3  嵌入Java代码	26
2.3.1  代码片段	26
2.3.2  声明	27
2.3.3  JSP表达式	27
2.4  注释	27
2.4.1  HTML注释	27
2.4.2  JSP注释	28
2.4.3  动态注释	28
2.4.4  代码注释	28
2.5  JSP动作标签	28
2.5.1  <jsp:include>	29
2.5.2  <jsp:forward>	30
2.5.3  <jsp:param>	31
2.5.4  操作JavaBean的动作标签	31
2.6  实战	31
2.6.1  连接数据库并将数据显示在页面表格中	31
2.6.2  根据数据表动态生成下拉列表	32
2.6.3  将3个页面组成一个新的页面	33
2.6.4  导入页面头部和版权信息页	34
2.6.5  在JSP页面中输出星号组成的金字塔	35
2.7  本章小结	36
2.8  学习成果检验	36
第3章  JSP内置对象	37
视频讲解：90分钟
3.1  JSP内置对象的概述	38
3.2  request对象	38
3.2.1  获取请求参数值	38
3.2.2  解决中文乱码	38
3.2.3  获取Form表单的信息	39
3.2.4  获取请求客户端信息	41
3.2.5  在作用域中管理属性	42
3.2.6  cookie管理	42
3.2.7  获取浏览器使用的语言	44
3.3  response对象	44
3.3.1  重定向网页	44
3.3.2  处理HTTP文件头	44
3.3.3  设置输出缓冲	45
3.4  session对象	45
3.4.1  创建及获取session信息	46
3.4.2  从会话中移除指定的绑定对象	46
3.4.3  销毁session	47
3.4.4  会话超时的管理	47
3.4.5  session对象的应用	47
3.5  application对象	49
3.5.1  访问应用程序初始化参数	49
3.5.2  管理应用程序环境属性	50
3.6  out对象	50
3.6.1  管理响应缓冲	51
3.6.2  向客户端输出数据	51
3.7  其他内置对象	51
3.7.1  获取会话范围的pageContext对象	51
3.7.2  读取web.xml配置信息的config对象	52
3.7.3  应答或请求的page对象	52
3.7.4  获取异常信息的exception对象	52
3.8  实战	53
3.8.1  application对象实现网页计数器	53
3.8.2  在提交表单时加入验证码	54
3.8.3  实现自动登录	56
3.8.4  定时刷新页面	57
3.8.5  统计用户在某页停留时间	58
3.9  本章小结	59
3.10  学习成果检验	59
第4章  Servlet技术	60
视频讲解：88分钟
4.1  Servlet基础	61
4.1.1  Servlet与Servlet容器	61
4.1.2  Servlet技术特点	61
4.1.3  Servlet技术功能	62
4.1.4  Servlet与JSP的区别	62
4.1.5  Servlet代码结构	62
4.1.6  简单的Servlet程序	63
4.2  Servlet开发	64
4.2.1  Servlet的创建	64
4.2.2  Servlet配置的相关元素	65
4.3  Servlet API编程常用的接口和类	67
4.3.1  Servlet接口	67
4.3.2  ServletConfig接口	67
4.3.3  HttpServletRequest接口	67
4.3.4  HttpServletResponse接口	68
4.3.5  GenericServlet类	69
4.3.6  HttpServlet类	69
4.4  Servlet过滤器	70
4.4.1  过滤器概述	70
4.4.2  Filter API	70
4.4.3  过滤器的配置	71
4.4.4  过滤器典型应用	72
4.5  实战	74
4.5.1  JSP与Servlet实现用户注册	74
4.5.2  过滤非法文字	77
4.5.3  统计网站的访问量	80
4.5.4  利用Servlet实现个人所得税计算器	81
4.5.5  生成网站表单的验证码	82
4.6  本章小结	84
4.7  学习成果检验	84
第5章  综合实验（一）--JSP使用Model2
实现登录模块	85
视频讲解：58分钟
5.1  JavaBean	86
5.1.1  JavaBean简介	86
5.1.2  <jsp:useBean>	86
5.1.3  <jsp:setProperty>	87
5.1.4  <jsp:getProperty>	89
5.1.5  JavaBean的作用域	90
5.2  Model1模式	92
5.3  Model2模式	94
5.3.1  MVC原理	94
5.3.2  JSP+Servlet+JavaBean	95
5.4  两种模式的比较	96
5.5  登录模块的实现	97
5.5.1  模块介绍	97
5.5.2  关键技术	97
5.5.3  数据库设计	98
5.5.4  JavaBean设计	98
5.5.5  实现过程	102
5.6  运行项目	107
5.7  本章小结	108
5.8  学习成果检验	108
第2篇  高 级 技 术
第6章  EL表达式语言	110
视频讲解：73分钟
6.1  EL概述	111
6.1.1  使用EL表达式的前提条件	111
6.1.2  EL表达式的基本语法	112
6.1.3  EL表达式的特点	112
6.2  EL表达式的存取范围	112
6.3  EL表达式的运算符	113
6.3.1  存取数据运算符"[]"和"."	113
6.3.2  算术运算符	114
6.3.3  关系运算符	114
6.3.4  逻辑运算符	115
6.3.5  empty运算符	116
6.3.6  条件运算符	116
6.3.7  运算符的优先级	116
6.4  EL表达式中的保留字	117
6.5  EL表达式中的隐含对象	117
6.5.1  PageContext对象的应用	117
6.5.2  param和paramValues对象的应用	117
6.5.3  header和headerValues对象的应用	118
6.5.4  访问作用域范围的隐含对象	118
6.5.5  cookie对象的应用	119
6.5.6  initParam对象的应用	119
6.6  实战	119
6.6.1  应用EL表达式访问JavaBean的属性	119
6.6.2  应用EL表达式显示投票结果	121
6.6.3  判断用户名是否为空，空则显示相应的
提示信息	123
6.6.4  显示客户端使用的浏览器	123
6.6.5  判断用户是否登录，并显示不同
提示信息	123
6.7  本章小结	124
6.8  学习成果检验	124
第7章  JSTL核心标签库	125
视频讲解：94分钟
7.1  JSTL简介	126
7.1.1  下载和配置JSTL	126
7.1.2  JSTL标签库简介	128
7.2  表达式标签	128
7.2.1  <c:out>输出标签	128
7.2.2  <c:set>设置标签	129
7.2.3  <c:remove>移除标签	131
7.2.4  <c:catch>捕获异常标签	131
7.3  条件标签	132
7.3.1  <c:if>标签	132
7.3.2  <c:choose>、<c:when>和<c:otherwise>
标签	133
7.4  循环标签	135
7.4.1  <c:forEach>标签	135
7.4.2  <c:forTokens>标签	137
7.5  URL操作标签	138
7.5.1  <c:import>文件导入标签	138
7.5.2  <c:redirect>重定向标签	140
7.5.3  <c:url>生成URL地址标签	140
7.5.4  <c:param>参数传递标签	141
7.6  实战	141
7.6.1  应用JSTL显示数据库中的
商品信息	141
7.6.2  JSTL在电子商城网站中的应用	146
7.6.3  JSTL导入网站注册协议	148
7.6.4  JSTL标签实现网站计数器	149
7.6.5  应用<c:if>标签判断用户最喜爱的
水果	149
7.7  本章小结	150
7.8  学习成果检验	150
第8章  综合实验（二）--结合JSTL与EL
技术开发通讯录模块	151
视频讲解：73分钟
8.1  模块概述	152
8.1.1  功能描述	152
8.1.2  系统流程	152
8.1.3  主页预览	153
8.2  关键技术	153
8.3  数据库设计	153
8.4  实现过程	154
8.4.1  搭建开发环境	154
8.4.2  编写数据库连接及操作的公共类	154
8.4.3  实现用户注册	157
8.4.4  实现用户登录	160
8.4.5  实现通讯录模块主页	162
8.4.6  实现添加联系人	165
8.4.7  实现修改联系人	168
8.4.8  实现删除联系人	170
8.5  运行项目	170
8.6  本章小结	171
第9章  JSP操作XML	172
视频讲解：110分钟
9.1  XML简介	173
9.1.1  XML文档结构	173
9.1.2  XML语法要求	174
9.1.3  为XML文档中的元素定义属性	174
9.1.4  XML的注释	175
9.1.5  处理字符数据	175
9.2  dom4j概述	177
9.2.1  dom4j简介	177
9.2.2  dom4j的下载与配置	177
9.3  创建XML文档	178
9.3.1  创建XML文档对象	178
9.3.2  创建根节点	178
9.3.3  添加注释	179
9.3.4  添加属性	179
9.3.5  创建子节点	179
9.3.6  设置节点的内容	179
9.3.7  设置编码	180
9.3.8  设置输出格式	180
9.3.9  输出XML文档	181
9.4  解析XML文档	182
9.4.1  构建XML文档对象	182
9.4.2  获取根节点	182
9.4.3  获取子节点	182
9.5  修改XML文档	183
9.5.1  修改节点	183
9.5.2  删除节点	184
9.6  实战	185
9.6.1  保存公告信息到XML文件	185
9.6.2  对保存到XML文件中的公告信息进行
管理	187
9.6.3  创建以当前日期为名称的XML文件	193
9.6.4  让XML文件动态显示数据	195
9.6.5  在控制台上显示XML文档内容	196
9.7  本章小结	197
9.8  学习成果检验	197
第10章  JavaScript脚本语言	198
视频讲解：216分钟
10.1  了解JavaScript	199
10.1.1  什么是JavaScript	199
10.1.2  JavaScript的主要特点	199
10.1.3  JavaScript与Java的区别	199
10.2  在Web页面中使用JavaScript	200
10.2.1  在页面中直接嵌入JavaScript	200
10.2.2  链接外部JavaScript	200
10.3  JavaScript语言基础	201
10.3.1  JavaScript的语法	201
10.3.2  JavaScript中的关键字	202
10.3.3  了解JavaScript的数据类型	203
10.3.4  变量的定义及使用	204
10.3.5  运算符的应用	205
10.4  流程控制语句	208
10.4.1  if条件判断语句	208
10.4.2  switch多路分支语句	210
10.4.3  for循环语句	212
10.4.4  while循环语句	213
10.4.5  do...while循环语句	214
10.4.6  break语句	215
10.4.7  continue语句	215
10.5  使用正则表达式	216
10.5.1  正则表达式的语法	216
10.5.2  创建正则表达式（RegExp）对象	218
10.5.3  使用RegExp对象执行模式匹配	219
10.6  函数	221
10.6.1  函数的定义	221
10.6.2  函数的调用	222
10.6.3  匿名函数	223
10.7  事件和事件处理程序	223
10.7.1  什么是事件和事件处理程序	223
10.7.2  JavaScript的常用事件	223
10.7.3  事件处理程序的调用	224
10.8  常用对象	225
10.8.1  String对象	225
10.8.2  Math对象	229
10.8.3  Date对象	230
10.8.4  Window对象	233
10.9  DOM技术	236
10.9.1  DOM概述	236
10.9.2  DOM的分层结构	236
10.9.3  遍历文档	237
10.9.4  获取文档中的指定元素	239
10.9.5  操作文档	239
10.9.6  与DHTML相对的DOM	241
10.10  实战	242
10.10.1  检测表单元素是否为空	242
10.10.2  屏蔽鼠标右键和键盘相关事件	243
10.10.3  验证E-mail地址是否合法	244
10.10.4  验证手机号码是否正确	244
10.10.5  计算两个日期相差的天数	245
10.11  本章小结	246
10.12  学习成果检验	246
第11章  综合实验（三）--Ajax实现用户
注册模块	247
视频讲解：94分钟
11.1  Ajax简介	248
11.1.1  什么是Ajax	248
11.1.2  Ajax的开发模式	248
11.1.3  Ajax的优点	248
11.2  Ajax使用的技术	249
11.2.1  XMLHttpRequest	249
11.2.2  JavaScript脚本语言	251
11.2.3  DOM	251
11.2.4  XML语言	252
11.2.5  CSS	252
11.3  传统Ajax工作流程	252
11.3.1  发送请求	252
11.3.2  处理服务器响应	253
11.3.3  一个完整的实例	255
11.4  jQuery实现Ajax	256
11.4.1  jQuery简介	256
11.4.2  发送GET和POST请求	258
11.4.3  服务器返回的数据格式	261
11.4.4  使用$.ajax()方法	264
11.5  Ajax开发需要注意的几个问题	266
11.5.1  浏览器兼容性问题	266
11.5.2  安全问题	266
11.5.3  性能问题	267
11.5.4  中文编码问题	267
11.6  开发用户注册模块	268
11.6.1  模块概述	268
11.6.2  系统流程	268
11.6.3  关键技术	269
11.6.4  数据库设计	270
11.6.5  实现过程	270
11.7  本章小结	280
11.8  学习成果检验	280

第3篇  框 架 技 术
第12章  Struts 2框架	282
视频讲解：62分钟
12.1  MVC设计模式	283
12.2  Struts 2框架概述	283
12.2.1  Struts 2框架的产生	283
12.2.2  Struts 2的结构体系	284
12.3  Struts 2 入门	284
12.3.1  获取与配置Struts 2	284
12.3.2  创建第一个Struts 2程序	285
12.4  Action对象	287
12.4.1  认识Action对象	287
12.4.2  请求参数的注入原理	288
12.4.3  Action的基本流程	288
12.4.4  动态Action	289
12.4.5  应用动态Action	289
12.5  Struts 2的配置文件	291
12.5.1  Struts 2的配置文件类型	291
12.5.2  配置Struts 2包	291
12.5.3  配置名称空间	292
12.5.4  Action的相关配置	292
12.5.5  使用通配符简化配置	294
12.5.6  配置返回结果	294
12.6  Struts 2的标签库	295
12.6.1  数据标签	295
12.6.2  控制标签	297
12.6.3  表单标签	298
12.7  Struts 2的开发模式	300
12.7.1  实现与Servlet API的交互	300
12.7.2  域模型DomainModel	300
12.7.3  驱动模型ModelDriven	301
12.8  Struts 2的拦截器	302
12.8.1  拦截器概述	302
12.8.2  拦截器API	303
12.8.3  使用拦截器	304
12.9  数据验证机制	305
12.9.1  手动验证	305
12.9.2  验证文件的命名规则	306
12.9.3  验证文件的编写风格	306
12.10  实战	307
12.10.1  实现用户登录	307
12.10.2  实现简单的计算器	308
12.10.3  Struts 2标签实现的用户注册	309
12.10.4  XML中配置数据验证器验证表
单元素	310
12.10.5  级联下拉列表框	311
12.11  本章小结	312
12.12  学习成果检验	312
第13章  Hibernate框架	313
视频讲解：65分钟
13.1  Hibernate简介	314
13.1.1  理解ORM原理	314
13.1.2  Hibernate的结构体系	314
13.1.3  Hibernate实例状态	315
13.1.4  Hibernate的适用性	316
13.2  Hibernate入门	316
13.2.1  Hibernate包的下载与放置	316
13.2.2  Hibernate配置文件	317
13.2.3  编写持久化类	318
13.2.4  编写映射文件	319
13.2.5  编写Hibernate的初始化类	321
13.3  自动建表技术	323
13.4  Hibernate持久化对象	324
13.4.1  添加数据	325
13.4.2  查询数据	325
13.4.3  删除数据	327
13.4.4  修改数据	328
13.5  Hibernate缓存及延迟加载	330
13.5.1  一级缓存	330
13.5.2  二级缓存	331
13.5.3  Lazy策略	333
13.6  实战	334
13.6.1  用户注册	334
13.6.2  修改数据	337
13.6.3  将实体对象保存到数据库	340
13.6.4  更新实体对象	342
13.6.5  批量删除数据	344
13.7  本章小结	345
13.8  学习成果检验	345
第14章  Hibernate高级应用	346
视频讲解：105分钟
14.1  关联关系映射	347
14.1.1  单向关联与双向关联	347
14.1.2  多对一单向关联映射	347
14.1.3  多对一双向关联映射	349
14.1.4  一对一主键关联映射	351
14.1.5  一对一外键关联映射	352
14.1.6  多对多关联映射	353
14.1.7  级联操作在关联中的使用	354
14.2  HQL检索方式	356
14.2.1  HQL的基本语法	356
14.2.2  实体对象与动态实例化对象查询	356
14.2.3  条件查询与别名的使用	357
14.2.4  HQL语句的动态赋值	357
14.2.5  对象导航查询	358
14.2.6  排序查询	358
14.2.7  聚合函数	359
14.2.8  分组操作	359
14.2.9  对日期时间的处理	359
14.2.10  联合查询	360
14.2.11  子查询	361
14.3  实战	362
14.3.1  多对一数据的添加与查询	362
14.3.2  模糊查询药品信息	365
14.3.3  内连接查询图书信息	368
14.3.4  利用多态查询判断用户登录身份	370
14.3.5  HQL排序查询订单信息	372
14.4  本章小结	373
14.5  学习成果检验	373
第15章  综合实验（四）--JSP+Hibernate
实现留言模块	374
视频讲解：72分钟
15.1  实例说明	375
15.1.1  实现功能	375
15.1.2  系统流程	375
15.1.3  逻辑分层结构	376
15.2  技术要点	376
15.2.1  确定实体及关系	376
15.2.2  ThreadLocal的使用	376
15.3  实现过程	377
15.3.1  搭建开发环境	377
15.3.2  实体类与映射	379
15.3.3  注册模块	382
15.3.4  用户登录	385
15.3.5  实现留言	387
15.3.6  分页查看留言信息	390
15.3.7  管理员相关操作	395
15.4  运行项目	399
15.5  本章小结	399
第16章  Spring框架	400
视频讲解：92分钟
16.1  Spring概述	401
16.1.1  Spring组成	401
16.1.2  下载Spring	402
16.1.3  配置Spring	402
16.1.4  使用BeanFactory管理Bean	403
16.1.5  应用ApllicationContext	403
16.2  Spring IoC	404
16.2.1  控制反转与依赖注入	404
16.2.2  配置Bean	405
16.2.3  Setter注入	406
16.2.4  构造器注入	406
16.2.5  引用其他Bean	408
16.2.6  创建匿名内部JavaBean	409
16.3  AOP概述	409
16.3.1  AOP术语	410
16.3.2  AOP的简单实现	411
16.4  Spring的切入点	412
16.4.1  静态与动态切入点	412
16.4.2  深入静态切入点	413
16.4.3  深入切入点底层	413
16.4.4  Spring中的其他切入点	414
16.5  Aspect对AOP的支持	414
16.5.1  Aspect概述	414
16.5.2  Spring中的Aspect	415
16.5.3  DefaultPointcutAdvisor切入点配置器	415
16.5.4  NameMatchMethodPointcutAdvisor切入点
配置器	416
16.6  Spring持久化	416
16.6.1  DAO模式	416
16.6.2  Spring的DAO理念	417
16.6.3  事务管理	419
16.6.4  应用JdbcTemplate操作数据库	422
16.6.5  与Hibernate整合	423
16.6.6  整合Spring与Hibernate在tb_user表中
添加信息	424
16.7  实战	425
16.7.1  使用Spring对员工表进行增、删、改、
查操作	425
16.7.2  使用Spring整合Hibernate操作商品
库存表	432
16.7.3  利用DAO模式向商品信息表中添加
数据	438
16.7.4  Spring AOP实现用户注册	439
16.7.5  利用JdbcTemplate向员工信息表中添加
数据	441
16.8  本章小结	443
16.9  学习成果检验	443
第17章  Spring MVC框架	444
视频讲解：88分钟
17.1  Spring MVC简介	445
17.1.1  Spring MVC的特点	445
17.1.2  Spring MVC的不足	445
17.2  Spring MVC中的组件	445
17.2.1  核心控制器	445
17.2.2  业务控制器	446
17.2.3  控制器映射	446
17.2.4  模型与视图	446
17.2.5  视图解析器	446
17.2.6  Command对象	446
17.3  Spring MVC核心控制器	446
17.4  Spring MVC控制器映射	447
17.4.1  配置BeanNameUrlHandlerMapping	447
17.4.2  配置SimpleUrlHandlerMapping	448
17.4.3  多个控制器映射	448
17.5  Spring MVC业务控制器	448
17.5.1  简单控制器	448
17.5.2  参数映射控制器	450
17.5.3  文件名映射控制器	451
17.5.4  表单控制器	451
17.5.5  Spring编码过滤器解决中文乱码	454
17.5.6  多动作控制器	454
17.6  视图解析器	456
17.6.1  视图解析器介绍	456
17.6.2  配置InternalResourceViewResolver	457
17.7  常见的其他第三方MVC框架	457
17.7.1  Struts	458
17.7.2  JSF	458
17.7.3  Struts 2	458
17.8  实战	458
17.8.1  应用参数映射控制器映射JSP页面	458
17.8.2  利用向导控制器实现分步用户注册	459
17.8.3  利用表单控制器实现验证处理	462
17.8.4  利用多动作控制器实现数据查询和删除
操作	463
17.8.5  使用Spring MVC编写在线通讯录	465
17.9  本章小结	470
17.10  学习成果检验	470
第18章  综合实验（五）--Spring+Hibernate
实现用户管理模块	471
视频讲解：62分钟
18.1  系统功能模块设计	472
18.2  数据库设计	472
18.3  技术要点	472
18.4  文件夹结构设计	473
18.5  实体映射	473
18.5.1  部门信息	473
18.5.2  用户信息	474
18.6  设计操作数据库的接口与类	475
18.6.1  部门信息DAO接口IDeptInfoDao	475
18.6.2  部门信息DAO实现类DeptInfoDao	475
18.6.3  用户信息DAO接口IUserInfoDao	476
18.6.4  用户信息DAO实现类IUserInfoDao	476
18.7  登录子模块	478
18.7.1  登录子模块控制器	478
18.7.2  登录子模块JSP页面	479
18.8  部门管理子模块	481
18.8.1  部门管理子模块控制器	482
18.8.2  部门管理子模块JSP页面	483
18.9  用户管理子模块	484
18.9.1  用户管理子模块文件上传类	485
18.9.2  用户管理子模块控制器类	486
18.9.3  用户管理子模块JSP页面	488

18.10  配置文件	491
18.10.1  在src文件内编写log4j.properties	491
18.10.2  创建Spring配置文件
applicationContext.xml	491
18.10.3  配置web.xml	494
18.11  运行项目	494
18.12  本章小结	494
第4篇  实 用 技 术
第19章  数据分页	496
视频讲解：46分钟
19.1  SQL Server数据库分页	497
19.1.1  获取前n条记录	497
19.1.2  获取分页数据	497
19.2  MySQL数据库分页	498
19.2.1  LIMIT函数	498
19.2.2  获取分页数据	498
19.2.3  获取总页数	499
19.3  Hibernate分页	499
19.3.1  HQL分页	499
19.3.2  QBC分页	500
19.4  分页商品信息查询模块	500
19.4.1  模块介绍	500
19.4.2  系统流程	500
19.4.3  关键技术	501
19.4.4  数据库设计	501
19.4.5  实现过程	502
19.5  实战	508
19.5.1  对SQL Server 2008数据库进行分页	508
19.5.2  转到指定页的分页	509
19.5.3  具有页码跳转功能的分页	510
19.5.4  分栏显示	512
19.5.5  应用Hibernate分页	513
19.6  本章小结	516
19.7  学习成果检验	516
第20章  文件上传与下载	517
视频讲解：50分钟
20.1  使用Servlet 3.0的新特性实现文件
上传	518
20.2  使用Commons-FileUpload组件实现
文件上传	519
20.2.1  添加表单及表单元素	519
20.2.2  创建上传对象	519
20.2.3  解析上传请求	520
20.3  Spring文件上传	522
20.3.1  配置文件上传解析器	522
20.3.2  编写文件上传表单页面	523
20.3.3  编写文件上传控制器	523
20.4  实现文件下载	524
20.4.1  文件类	524
20.4.2  文件字节输入流	525
20.4.3  字节输出流	525
20.5  MP3乐园	527
20.5.1  模块介绍	527
20.5.2  系统流程	527
20.5.3  关键技术	528
20.5.4  数据库设计	528
20.5.5  公共类编写	528
20.5.6  实现系统登录	530
20.5.7  实现用户注册	531
20.5.8  实现文件上传	532
20.5.9  文件下载	535
20.6  本章小结	536
20.7  学习成果检验	536
第21章  PDF与Excel组件	537
视频讲解：64分钟
21.1  PDF概述	538
21.1.1  PDF的优点	538
21.1.2  PDF阅读工具	538
21.2  PDF组件简介	538
21.2.1  iText组件简介	538
21.2.2  iText组件的获取	538
21.2.3  iText组件关键类简介	539
21.3  应用iText组件生成PDF文档	539
21.3.1  创建Document对象的实例	540
21.3.2  获取PdfWrite实例	540
21.3.3  为PDF文档添加内容	540
21.3.4  字体与中文字符的显示	541
21.3.5  创建表格	541
21.3.6  插入图像	542
21.4  应用PDFBox组件解析PDF文档	543
21.4.1  PDFBox组件简介	543
21.4.2  PDFBox组件的获取	543
21.4.3  应用PDFBox组件解析PDF文档	544
21.5  Excel组件简介	545
21.5.1  常用Excel组件	545
21.5.2  POI组件简介	545
21.5.3  POI组件的获取	545
21.5.4  POI组件关键类简介	546
21.6  应用POI组件读写Excel文档	546
21.6.1  创建一个Excel文档	546
21.6.2  设置字体样式	547
21.6.3  合并单元格	548
21.6.4  读取Excel文档内容	549
21.7  实战	550
21.7.1  将数据库中的内容导出为PDF文档	550
21.7.2  将数据库中的内容导出为Excel文档	553
21.7.3  设置Excel文档中的字体样式	554
21.7.4  读取Excel文件的数据到数据库	555
21.7.5  设置Excel文件的打印属性	556
21.8  本章小结	557
21.9  学习成果检验	557
第22章  动态图表	558
视频讲解：75分钟
22.1  JFreeChart简介	559
22.1.1  认识JFreeChart组件	559
22.1.2  JFreeChart的下载与使用	559
22.2  JFreeChart的核心对象	560
22.2.1  制图对象	560
22.2.2  制图工厂对象	560
22.2.3  数据集合对象	561
22.2.4  绘图区对象	562
22.2.5  坐标轴对象	563
22.2.6  图片渲染对象	565
22.3  JFreeChart的应用	565
22.3.1  如何获取图片	565
22.3.2  创建数据集合与JFreeChart实例	566
22.3.3  图表相关属性的设置	568
22.3.4  JFreeChart内置JDBC的使用	569
22.3.5  中文乱码的解决方案	571
22.4  实战	572
22.4.1  JFreeChart绘制折线图	572
22.4.2  JFreeChart绘制区域图	575
22.4.3  JFreeChart绘制时序图	577
22.4.4  利用柱状图显示某网站的访问量	579
22.4.5  利用饼图显示不同编程语言的市场
占有率	580
22.5  本章小结	581
22.6  学习成果检验	581
第23章  综合实验（六）--在线投票
统计模块	582
视频讲解：64分钟
23.1  系统功能模块设计	583
23.1.1  功能描述	583
23.1.2  系统流程	583
23.2  数据库设计	583
23.3  关键技术	584
23.3.1  双击鼠标展开图片技术	584
23.3.2  判断IP所属地区技术	585
23.4  公共模块设计	586
23.4.1  数据库操作类的设计与实现	586
23.4.2  投票过滤器类的设计与实现	589
23.5  实现投票功能	590
23.6  实现柱形图统计功能	591
23.7  实现饼形图统计功能	594
23.8  运行项目	596
23.9  本章小结	596

第5篇  项 目 实 战
第24章  基于SSH2的电子商城网站	598
视频讲解：48分钟
24.1  需求分析	599
24.2  系统设计	599
24.2.1  系统目标	599
24.2.2  系统功能结构	599
24.2.3  系统流程图	600
24.3  项目开发及运行环境	600
24.3.1  服务器最低配置	600
24.3.2  客户端最低配置	600
24.4  系统文件夹组织结构	601
24.5  数据库与数据表设计	601
24.5.1  E-R图设计	601
24.5.2  创建数据库及数据表	602
24.6  搭建项目环境	604
24.6.1  配置Struts 2	604
24.6.2  配置Hibernate	606
24.6.3  配置Spring	607
24.6.4  配置web.xml	608
24.7  公共类设计	609
24.7.1  泛型工具类	609
24.7.2  数据持久化类	610
24.7.3  分页设计	612
24.7.4  字符串工具类	615
24.8  登录与注册模块设计	616
24.8.1  注册	616
24.8.2  登录	618
24.9  前台商品信息查询模块设计	620
24.9.1  商品类别分级查询	620
24.9.2  商品搜索	621
24.9.3  前台查询其他商品	622
24.10  购物车模块设计	624
24.10.1  购物车的基本功能	624
24.10.2  订单的相关功能	627
24.11  后台商品管理模块设计	629
24.11.1  商品管理功能	629
24.11.2  实现商品类别管理功能	632
24.12  后台订单管理模块设计	635
24.12.1  实现后台订单查询	635
24.12.2  实现后台订单状态管理	637
24.13  运行项目	639
24.14  本章小结	639
第25章  基于SSH2的明日论坛	640
视频讲解：32分钟
25.1  开发背景	641
25.2  系统设计	641
25.2.1  系统目标	641
25.2.2  系统功能结构	641
25.2.3  系统流程图	641
25.3  项目开发及运行环境	642
25.3.1  服务器最低配置	642
25.3.2  客户端最低配置	642
25.4  系统文件夹组织结构	642
25.5  数据库与数据表设计	643
25.5.1  E-R图设计	643
25.5.2  数据库表设计	644
25.6  公共类设计	645
25.6.1  Spring+Hibernate组合实现持久层	645
25.6.2  使用Struts 2标签分页	647
25.7  主页面设计	648
25.7.1  文章搜索首页设计	649
25.7.2  论坛页设计	650
25.8  文章维护模块设计	651
25.8.1  添加文章模块	651
25.8.2  浏览文章	653
25.8.3  文章回复	654
25.8.4  修改文章	655
25.8.5  删除文章	655
25.9  文章搜索模块设计	656
25.9.1  搜索我的文章	656
25.9.2  根据关键字搜索文章	657
25.9.3  热门搜索	659
25.9.4  搜索文章作者的所有文章	659
25.9.5  搜索回复作者的所有文章	661
25.10  运行项目	661
25.11  本章小结	661
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web开发实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JXTA-Java P2P网络编程技术
第一章 P2P介绍
第二章 JXTA概述
第三章 JXTA标准应用
第四章 JXTA Shell
第五章 JXTA深入编程
第六章 JXTA Content Manage Service(CMS)
第七章 JXTA核心协议（一）
第八章 JXTA核心协议（二）
第九章 JXTA发展方向
JXTA术语表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JXTA-Java P2P网络编程技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 2编程详解
第一部分 Java概述
第1章

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 2编程详解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java面向对象程序设计
第1章进入Java
第2章发送消息和执行操作
第3章应用对象和基本类型
第4章定义类
第5章高级类定义
第6章方法内核，命令式程序设计
第7章类设计
第8章验证对象的行为
第9章多个对象的处理
第10章设计选化
第11章维护对象集合
第12章扩展类的行为
第13章 异常
第14章 递归
第15章 客户－服务器计算
附录A 三个Java环境
附录B AWIO
附录C 使用Enumeration遍历集合
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java面向对象程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java编码指南
第1章 安全
指南1：限制敏感数据的生命周期
指南2：不要在客户端存储未经加密的敏感数据
指南3：为敏感可变类提供不可修改的包装器
指南4：确保安全敏感方法被调用时参数经过验证
指南5：防止任意文件上传
指南6：正确地编码或转义输出
指南7：防止代码注入
指南8：防止XPath注入
指南9：防止LDAP注入
指南10：不要使用clone()方法来复制不可信的方法参数
指南11：不要使用Object.equals()来比较密钥
指南12：不要使用不安全的弱加密算法
指南13：使用散列函数存储密码
指南14：确保SecureRandom正确地选择随机数种子
指南15：不要依赖可以被不可信代码覆盖的方法
指南16：避免授予过多特权
指南17：最小化特权代码
指南18：不要将使用降低安全性检查的方法暴露给不可信代码
指南19：对细粒度的安全定义自定义安全权限
指南20：使用安全管理器创建一个安全的沙盒
指南21：不要让不可信代码误用回调方法的特权
第2章 防御式编程
指南22：最小化变量的作用域
指南23：最小化@SuppressWarnings注解的作用域
指南24：最小化类及其成员的可访问性
指南25：文档化代码的线程安全性
指南26：为方法的结果值提供反馈
指南27：使用多个文件属性识别文件
指南28：不要赋予枚举常量的序号任何特殊意义
指南29：注意数字提升行为
指南30：对可变参数的类型做编译时类型检查
指南31：不要把其值在以后版本里可能会发生变化的常量设置为public final
指南32：避免包之间的循环依赖
指南33：使用用户自定义的异常而非宽泛的异常类型
指南34：尽量从系统错误中优雅恢复
指南35：发布接口前请谨慎设计
指南36：编写对垃圾收集机制友好的代码
第3章 可靠性
指南37：不要在子作用域里遮蔽或者掩盖标识符
指南38：不要在一个声明里声明多个变量
指南39：在程序逻辑中用有意义的符号常量代表文字值
指南40：在常量定义中恰当地表示相互之间的关系
指南41：对于返回数组或者集合的方法，用返回一个空数组或者集合来替代返回一个空值
指南42：只在异常的情况下使用异常
指南43：使用try—with—resources语句安全处理可关闭的资源
指南44：不要使用断言来验证不存在的运行时错误
指南45：在条件表达式中，第二个和第三个操作数应使用相同类型
指南46：不要序列化直接指向系统资源的句柄
指南47：更倾向于使用迭代器而不是列举
指南48：对于短生存周期、不常用的对象不要使用直接缓冲区
指南49：从长生存周期容器对象中移除短生存周期对象
第4章 程序的可理解性
指南50：谨慎使用视觉上有误导性的标识符和文字
指南51：避免歧义重载变参方法
指南52：要避免使用带内错误指示器
指南53：不要在条件表达式中进行赋值
指南54：请使用大括号把if、for或while代码体括起来
指南55：不要直接在if、for或while条件语句后面加分号
指南56：在每一个case分支的代码块中加上break语句
指南57：避免不当的计算循环计数器
指南58：使用括号表示操作的优先级
指南59：不要对文件的创建做任何假设
指南60：做浮点运算前把整数转换为浮点数
指南61：确保对象的clone()方法中有调用super.clone()
指南62：保持注释的一致性和可读性
指南63：检测并移除冗余的代码和值
指南64：尽量保证逻辑完备
指南65：避免有歧义的重载或者误导性的重载
第5章 程序员的常见误解
指南66：不要假设使用volatile关键字声明引用可以保证引用所指对象的安全发布
指南67：不要假设sleep()、yield()或getState()方法提供了同步语义
指南68：不要假设对整数做取余运算总是返回正整数
指南69：不要弄混抽象对象的相等性和引用的相等性
指南70：理解按位运算符和逻辑运算符之间的差异
指南71：理解加载字符串时如何做特殊字符转义
指南72：不要使用重载的方法来区分运行时类型
指南73：不要弄混引用的不可变性和对象的不可变性
指南74：谨慎使用序列化方法writeUnshared()和readUnshared()
指南75：不要试图通过把本地引用变量设置为null来帮助垃圾收集器
附录 Android
术语表
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java编码指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序员成功面试秘籍
目    录
第Ⅰ部分  面试流程概述
第1章  面试类型分析	3
1.1  电话面试流程	4
1.2  技术测试	5
1.3  应对面对面的现场面试	7
1.4  最终的决定	8
1.5  本章小结	8
第2章  撰写引人入胜的简历	11
2.1  如何撰写简历和求职信	11
2.2  撰写求职信	14
2.3  本章小结	14
第3章  技术测试和面试基础知识	17
3.1  书面技术测试	17
3.2  上机测试	18
3.3  面对面的技术面试	19
3.4  本章小结	20
第4章  编写核心算法	23
4.1  关于大O符号	23
4.2  列表排序	24
4.3  列表搜索	32
4.4  本章小结	34
第5章  数据结构	35
5.1  列表	35
5.2  树	39
5.3  映射	45
5.4  集合	48
5.5  本章小结	49
第6章  设计模式	51
6.1  考察示例模式	51
6.2  常用模式	60
6.3  本章小结	64
第7章  常见面试算法的实现	67
7.1  实现FizzBuzz	67
7.2  生成斐波那契数列	69
7.3  实现阶乘	73
7.4  实现库的功能	74
7.5  使用泛型	82
7.6  本章小结	85
第Ⅱ部分  核心Java
第8章  Java基础	89
8.1  原始类型	90
8.2  使用对象	92
8.3  Java数组	99
8.4  String的使用	100
8.5  理解泛型	103
8.6  自动装箱和拆箱	109
8.7  使用注记	110
8.8  命名约定	112
8.8.1  类		113
8.8.2  变量和方法	113
8.8.3  常量	113
8.9  处理异常	113
8.10  使用Java标准库	117
8.11  期待Java 8	120
8.12  本章小结	122
第9章  基于JUnit的测试	123
9.1  JUnit测试的生命周期	125
9.2  使用JUnit的最佳实践	127
9.3  通过Mock消除依赖	138
9.4  通过行为驱动的开发进行系统测试	144
9.5  本章小结	146
第10章  理解Java虚拟机	149
10.1  垃圾回收	149
10.2  内存调优	151
10.3  JVM和Java语言之间的互操作性	154
10.4  本章小结	159
第11章  并发	161
11.1  使用线程	161
11.2  使用并发	167
11.3  actor	171
11.4  本章小结	176
第III部分  组件和框架
第12章  Java应用程序和数据库的整合	179
12.1  SQL简介	179
12.2  JDBC：整合Java和数据库	193
12.3  利用内存数据库进行测试	199
12.4  本章小结	200
第13章  创建Web应用程序	203
13.1  Tomcat和Servlet API	203
13.2  Jetty	209
13.3  Play框架	215
13.4  本章小结	220
第14章  HTTP和REST	223
14.1  HTTP方法	223
14.2  HTTP客户端	226
14.3  通过REST创建HTTP服务	228
14.4  本章小结	232
第15章  序列化	233
15.1  读写Java对象	233
15.2  使用XML	236
15.3  JSON	242
15.4  本章小结	245
第16章  Spring框架	247
16.1  Spring核心及应用上下文	247
16.2  Spring JDBC	257
16.3  集成测试	261
16.4  Spring MVC	264
16.5  本章小结	271
第17章  使用Hibernate	273
17.1  使用Hibernate	273
17.2  本章小结	286
第18章  有用的库	289
18.1  通过Apache Commons去除样板化的代码	289
18.2  利用Guava集合进行开发	292
18.3  使用Joda Time库	298
18.4  本章小结	302
第19章  利用构建工具进行开发	303
19.1  通过Maven构建应用程序	303
19.2  Ant	311
19.3  本章小结	313
第20章  Android开发	315
20.1  基础知识	316
20.1.1  组件	316
20.1.2  Intent	317
20.1.3  Activity	320
20.1.4  BroadcastReceiver	323
20.1.5  Service	324
20.2  用户界面	328
20.3  持久化	336
20.4  Android硬件	339
20.5  本章小结	343
附录A  Scala简介	345
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序员成功面试秘籍
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java SOAP编程指南
第1章  分布式应用协议
文档与过程
CORBA
COM／DCOM
RMI
XML-RPC
SOAP 7
Web服务

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java SOAP编程指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java开发手册
第1篇  Java基础
第1章  初步认识Java	1
1.1  Java的概念	1
1.1.1  Java是什么	1
1.1.2  Java平台	1
1.1.3  Java的操作系统	2
1.1.4  Java的优点	2
1.2  Java的历史	3
1.2.1  Java的由来	3
1.2.2  Java的发展	4
1.3  如何配置Java开发环境	4
1.3.1  开发工具包	4
1.3.2  运行环境	4
1.3.3  JDK的安装和下载	5
1.3.4  环境变量的设置	6
1.3.5  环境变量的测试	7
1.4  第一个应用程序——HelloWorld	7
1.4.1  HelloWorld程序	7
1.4.2  编译与运行	8
1.4.3  编译和运行命令	9
1.5  小结	12
第2章  基本数据类型	13
2.1  数据类型	13
2.1.1  整型	13
2.1.2  浮点型	16
2.1.3  字符型	19
2.1.4  布尔型	20
2.2  常量	21
2.2.1  标识符	21
2.2.2  常量	22
2.3  变量	24
2.3.1  声明变量及初始化	24
2.3.2  变量的作用域	26
2.3.3  数据类型的自动转换	28
2.4  基本数据类型之间的转换	29
2.4.1  自动转换类型	29
2.4.2  强制转换类型	31
2.5  基本数据类型的对象包装类	34
2.6  注释	35
2.6.1  单行注释	36
2.6.2  区域注释	36
2.6.3  文档注释	36
2.7  小结	38
第3章  运算符详解	39
3.1  算术运算符	39
3.1.1  加法运算符	39
3.1.2  减法运算符	42
3.1.3  乘法运算符	43
3.1.4  除法运算符	43
3.1.5  取余运算符	44
3.1.6  自增、自减运算	44
3.2  关系与逻辑运算	46
3.2.1  等于/不等于运算	46
3.2.2  比较大小运算	47
3.2.3 “与”运算	48
3.2.4 “或”运算	49
3.2.5 “非”运算	50
3.3  三元运算符	50
3.4  位运算	51
3.5  移位运算	53
3.5.1 “<<”左移运算	53
3.5.2 “>>”右移运算	53
3.5.3 “>>>”无符号右移运算	54
3.5.4  具体实例	55
3.6  赋值运算	55
3.6.1  普通赋值运算	56
3.6.2  运算赋值运算	56
3.6.3  括号及运算符间的优先级关系	57
3.7  java.lang.Math类	57
3.7.1  数学常量	57
3.7.2  常用数学函数方法	58
3.8  小结	60
第4章  流程控制语句	61
4.1  if语句	61
4.1.1  常用语句形式	61
4.1.2  完整语句形式	62
4.2  if语句的嵌套	63
4.3  switch语句	65
4.3.1  switch判断语法	65
4.3.2  判断表达式	67
4.3.3  case表达式	68
4.4  switch实例	69
4.5  while循环语句	71
4.6  do-while循环语句	73
4.7  for循环语句	74
4.7.1  for循环语法	74
4.7.2  for循环实例	76
4.7.3  for实现其他循环	77
4.8  break语句	78
4.9  continue语句	79
4.10  小结	81
第5章  不可或缺的数组	82
5.1  数组的概念	82
5.2  一维数组	83
5.2.1  数组的声明	83
5.2.2  创建数组及初始化	83
5.2.3  数组的结构	84
5.2.4  数组长度及越界	84
5.2.5  数组程序实例	85
5.3  多维数组	86
5.3.1  多维数组的声明	86
5.3.2  创建多维数组	86
5.3.3  多维数组结构及初始化	87
5.4  访问多维数组	88
5.5  数组的相关用法	90
5.5.1  复制数组	90
5.5.2  数组修饰符	92
5.5.3  搜索数组	93
5.5.4  排序数组	95
5.5.5  Arrays类的sort方法	98
5.5.6  数组的比较	99
5.6  小结	100
第2篇  面向对象
第6章  对象和类的“二人转”	101
6.1  什么是面向对象	101
6.1.1  面向对象的由来	101
6.1.2  面向过程与面向对象思想的碰撞	102
6.1.3  面向对象的背景及特点	104
6.2  类与对象	104
6.2.1  成员变量	105
6.2.2  成员变量的默认值	107
6.2.3  对象引用变量	108
6.3  类的方法	110
6.4  方法和变量引用	111
6.4.1  调用不存在的方法或成员变量	111
6.4.2  用空引用进行调用	112
6.4.3  数组的空引用问题	113
6.5  局部变量	113
6.5.1  局部变量的作用域	113
6.5.2  局部变量的初始化	114
6.6  变长参数	117
6.7  this对象引用	118
6.8  系统常用类	120
6.8.1  Date类	120
6.8.2  GregorianCalendar类	122
6.8.3  常用系统已有类	124
6.9  小结	125
第7章  Java中的访问控制符	126
7.1  类的访问控制	126
7.1.1  public级别	126
7.1.2  默认访问级别	128
7.2  成员的访问控制	130
7.2.1  公共访问	131
7.2.2  保护访问	132
7.2.3  默认访问	133
7.2.4  私有访问	134
7.2.5  访问级别与数据封装	136
7.3  static关键字	137
7.3.1  静态成员变量	138
7.3.2  静态最终成员变量	139
7.3.3  static方法	140
7.3.4  static代码块	140
7.4  final的变量	141
7.4.1  final成员变量	141
7.4.2  final局部变量	144
7.5  package的使用	146
7.5.1  package的声明与创建	146
7.5.2  引入package资源	147
7.5.3  静态引入package	150
7.6  小结	152
第8章  父与子的继承	153
8.1  什么是继承	153
8.1.1  类和类的关系	153
8.1.2  继承性	156
8.1.3  类的继承	156
8.2  继承与隐藏	157
8.2.1  成员变量的继承	157
8.2.2  成员变量的隐藏	160
8.3  对象	162
8.3.1  对象引用类型	162
8.3.2  强制类型转换	162
8.3.3  对象调用成员	164
8.3.4  对象赋值和比较	165
8.4  方法的继承	167
8.5  方法的重写	168
8.5.1  重写的条件	170
8.5.2  返回类型的规则	171
8.5.3  访问级别	173
8.6  重写与继承的关系	174
8.6.1  静态方法没有重写	175
8.6.2  重写扩展父类功能	177
8.6.3  替代性	178
8.7  方法的重载	178
8.7.1  重载的规则	178
8.7.2  重载方法的匹配	179
8.7.3  重写与重载	183
8.8  final与继承	183
8.8.1  最终的类	183
8.8.2  最终的方法	184
8.9  abstract与继承	185
8.9.1  抽象类	185
8.9.2  抽象方法	186
8.10  继承的多态	189
8.11  小结	191
第9章  接口的世界	192
9.1  接口的概述	192
9.2  接口中的成员变量	193
9.3  接口中的方法	195
9.4  接口引用的使用	198
9.4.1  可以指向的对象类型	198
9.4.2  接口引用间的赋值	198
9.4.3  类引用与接口引用间的赋值	200
9.4.4  接口中方法无法使用的修饰符	201
9.5  接口与抽象类	203
9.6  接口的多态	205
9.7  接口回调	207
9.8  instanceof的使用	208
9.8.1  基本语法使用	208
9.8.2  不允许进行测试的情况	211
9.9  小结	212
第10章  构造器应用	213
10.1  构造器的概念	213
10.2  访问限制修饰符与构造器	213
10.2.1  公有类型构造器	213
10.2.2  默认与保护类型构造器	214
10.2.3  私有类型构造器以及静态工厂方法	215
10.3  构造器与返回类型	216
10.4  创建对象	218
10.5  重载构造器	219
10.6  级联调用的构造器	220
10.6.1  如何调用构造器	220
10.6.2  级联调用	221
10.6.3  默认构造器	223
10.7  自定义构造器	224
10.8  构造器不能继承	225
10.9  调用兄弟构造器	226
10.9.1  调用语法	226
10.9.2  注意事项	227
10.10  单列模式	229
10.11  程序的加载	230
10.12  小结	232
第11章  迷惑的封装类	233
11.1  封装类是什么	233
11.2  字符串与基本数据类型值的转换	235
11.3  封装类与基本数据类型的转换	238
11.4  字符串与封装类的转换	239
11.5  其他常用方法	239
11.5.1  静态工厂方法	239
11.5.2  isNaN()方法	241
11.5.3  equals()方法	242
11.5.4  toString()方法	244
11.5.5  进制转换方法	244
11.6  自动打包/解包	245
11.7  特殊数值计算	247
11.7.1  计算特大整数	248
11.7.2  精确计算浮点型	250
11.8  小结	251
第12章  如何处理异常	252
12.1  异常处理	252
12.1.1  捕获异常的try和catch	252
12.1.2  finally语句	256
12.1.3  try、catch和finally语句	259
12.2  捕获异常	261
12.3  未捕获异常	263
12.4  再次抛出异常	264
12.4.1  异常的再抛出	264
12.4.2  显性再抛出	265
12.4.3  隐性再抛出	268
12.5  方法重写对抛出异常的限制	269
12.6  自定义异常	271
12.6.1  自己创建异常类	271
12.6.2  使用自定义异常	273
12.6.3  显性再抛出异常的作用	274
12.7  异常的匹配	277
12.8  断言	279
12.8.1  为什么要引入断言	279
12.8.2  断言的语法规则	280
12.8.3  断言与编译	280
12.8.4  启动断言执行代码	281
12.8.5  防止滥用断言	282
12.9  小结	283
第3篇  Java常用技术
第13章  字符串应用	284
13.1  String类	284
13.2  String对象的内存机制	289
13.3  String内存机制的优势	290
13.4  String对象特殊机制的劣势	294
13.5  StringBuffer类	295
13.5.1  StringBuffer类的优势	295
13.5.2  编写方法链	297
13.5.3  StringBuffer类的重要方法	298
13.6  StringBuilder类	300
13.7  正则表达式	301
13.7.1  正则表达式的语法	302
13.7.2  Pattern与Matcher类的综合实例	304
13.8  在String类中使用正则表达式	308
13.8.1  匹配检查	308
13.8.2  查找替换	310
13.8.3  对字符串进行分析	311
13.9  小结	312
第14章  集合的使用	313
14.1  集合框架的结构	313
14.2  Object类	314
14.2.1  toString方法的重写	314
14.2.2  equals方法	315
14.2.3  hashCode方法	317
14.3  equals与hashCode方法的重写	318
14.4  Ordered与Sorted的接口	322
14.5  列表	323
14.5.1  List接口	323
14.5.2  数组实现列表	324
14.6  向量	326
14.7  链接实现列表	327
14.7.1  依赖性倒置原理	328
14.7.2  将数组转换为列表	329
14.8  集合	330
14.8.1  Set接口	330
14.8.2  HashSet类	331
14.8.3  equals与hashCode方法重写的作用	332
14.8.4  LinkedHashSet类的使用	335
14.9  SortedSet接口与TreeSet类	336
14.10  自定义Sorted集合的类	338
14.10.1  定制SortedSet的排序规则	340
14.10.2  集合的遍历	343
14.10.3  使用for-each循环遍历集合	345
14.11  映射	346
14.11.1  Map接口	346
14.11.2  HashMap类	347
14.11.3  Hashtable类	348
14.11.4  LinkedHashMap类	349
14.12  SortedMap接口与TreeMap类	351
14.13  映射的遍历实例	353
14.14  栈的实现	355
14.14.1  Stack类	355
14.14.2  Deque接口	356
14.14.3  栈计算数学表达式	358
14.15  集合元素的常用操作	361
14.16  小结	368
第15章  内部类应用	369
15.1  非静态内部类	369
15.2  在外部类中创建内部类	369
15.3  在外部类外创建内部类	371
15.4  内部类与外部类之间的成员互访	373
15.4.1  在内部类中访问外部类的成员	373
15.4.2  在外部类中访问内部类的成员	374
15.5  预定义对象引用this	375
15.6  局部内部类	376
15.6.1  定义局部内部类及创建	376
15.6.2  局部变量与局部内部类	377
15.6.3  静态方法中的局部内部类	380
15.7  静态内部类	381
15.8  静态/非静态内部类的区别	383
15.9  匿名内部类	383
15.10  内部类的理解	389
15.11  内部接口	390
15.12  小结	393
第16章  多线程的功力	394
16.1  线程的概念	394
16.2  自定义线程	395
16.2.1  继承Thread类	395
16.2.2  实现Runnable接口	395
16.2.3  两种方式的比较	396
16.3  创建线程对象	396
16.3.1  继承Thread类方式	396
16.3.2  实现Runnable接口方式	397
16.4  启动线程	398
16.5  同时使用多个线程	400
16.6  线程的状态	401
16.7  线程的使用	403
16.7.1  睡眠使用	403
16.7.2  线程的优先级	405
16.7.3  线程的让步	407
16.7.4  守护线程	410
16.8  同步线程	411
16.8.1  使用同步	412
16.8.2  同步调度方法	415
16.9 “生产者—消费者”案例	415
16.10  notify方法	420
16.11  同步语句块	421
16.12  线程的死锁	424
16.13  注意事项	426
16.14  获取运行线程	427
16.15  volatile关键字	428
16.16  小结	429
第17章  高级线程	430
17.1  线程池	430
17.2  固定尺寸线程池	430
17.2.1  自定义尺寸固定线程池实例	431
17.2.2  单任务线程池实例	433
17.2.3  可变尺寸线程池实例	434
17.2.4  延迟线程池的实例	436
17.3  使用自定义线程池	437
17.4  有返回值的线程调用	440
17.4.1  Callable接口	440
17.4.2  Future接口	440
17.4.3  Callable与Future接口的使用实例	441
17.5  封锁资源	442
17.5.1  Lock接口与ReentrantLock类	443
17.5.2  ReentrantLock锁使用实例	443
17.5.3  ReadWriteLock接口与ReentrantReadWriteLock类	446
17.5.4  ReentrantReadWriteLock读/写锁使用实例	447
17.6  信号量	450
17.6.1  Semaphore类	450
17.6.2  Semaphore类使用实例	451
17.7  队列	453
17.8  阻塞栈	459
17.8.1  BlockingDeque接口与LinkedBlockingDeque类	459
17.8.2  LinkedBlockingDeque类的使用实例	460
17.9  线程安全的单变量操作	461
17.9.1  atomic包	461
17.9.2  atomic包中类的使用实例	462
17.10  障碍器	463
17.10.1  CyclicBarrier类	464
17.10.2  CyclicBarrier类的使用实例	464
17.11  小结	466
第18章  内存管理技术	467
18.1  程序中的“垃圾”是什么	467
18.2 “垃圾”收集器	470
18.3  如何收集“垃圾”	472
18.3.1  finalize重写	472
18.3.2  finalize安全问题	474
18.4  最终守护者实例	476
18.5  非线程“垃圾”	477
18.6  线程“垃圾”	479
18.7  三种特殊的引用	481
18.7.1  弱引用实例	481
18.7.2  软引用实例	483
18.7.3  幻影引用实例	485
18.8  小结	485
第19章  数据结构和算法	486
19.1  栈和队列	486
19.1.1  栈的应用	486
19.1.2  队列的应用	489
19.2  三种排序	492
19.2.1  冒泡排序	492
19.2.2  选择排序	495
19.2.3  插入排序	498
19.3  小结	501
第4篇  界面编程
第20章  Swing编程	502
20.1  Swing是什么	502
20.2  第一个Swing小程序	502
20.3  JFrame类	504
20.4  事件处理	508
20.4.1  事件处理模型	509
20.4.2  事件层次结构	510
20.5  窗体事件	511
20.6  事件适配器	514
20.7  容器	516
20.8  JPanel类	517
20.9  JLabel类	518
20.10  JButton类	521
20.11  监听器与事件源对应关系的研究	524
20.12  小结	527
第21章  布局流行设计	528
21.1  布局管理器概述	528
21.2  常用布局管理器	528
21.3  FlowLayout流布局的使用	529
21.3.1  流布局简介	529
20.3.2  流布局使用实例	531
21.4  GridLayout网格布局	532
21.4.1  网格布局简介	532
21.4.2  网格布局使用实例	533
21.5  BorderLayout边框布局	535
21.5.1  边框布局简介	536
21.5.2  边框布局使用实例	537
21.6  空布局	539
21.6.1  空布局简介	539
21.6.2  空布局使用实例	540
21.7  CardLayout卡片布局	541
21.7.1  卡片布局简介	541
21.7.2  卡片布局使用实例	543
21.8  BoxLayout箱式布局	545
21.8.1  箱式布局简介	545
21.8.2  Box容器简介	547
21.8.3  Box容器与BoxLayout布局管理器使用实例	548
21.9  弹簧布局	551
21.9.1  弹簧布局简介	551
21.9.2  控件与容器边框之间使用支架	551
21.9.3  控件与容器边框之间使用弹簧	552
21.10  SpringLayout类	554
21.11  SpringLayout.Constraints内部类	555
21.12  Spring类	556
21.13  弹簧布局使用实例	557
21.14  弹簧布局描述法使用实例	558
21.15  小结	561
第22章  各种Swing控件	562
22.1  控件类	562
22.2  文本框与密码框的使用实例	565
22.3  文本区使用实例	569
22.4  开关按钮使用实例	574
22.5  单选按钮与复选框	577
22.5.1  JRadioButton类	577
22.5.2  ButtonGroup类	578
22.5.3  JCheckBox类	578
22.6  ItemEvent事件	579
22.7  ItemEvent事件实例	579
22.8  单选按钮与复选框的
综合实例	582
22.9  小结	585
第23章  菜单、工具栏和对话框的使用	586
23.1  菜单	586
23.2  JMenuBar类	587
23.2.1  使用窗体提供的setJMenuBar方法	588
23.2.2  使用传统的add()方法	588
23.3  JMenuItem类	589
23.3.1  为菜单项添加助记符	590
23.3.2  为菜单项设置快捷键	590
23.4  JMenu类	591
23.5  JRadioButtonMenuItem类	593
23.6  JCheckBoxMenuItem类	593
23.7  菜单使用实例	594
23.8  弹出式菜单实例	597
23.9  鼠标事件使用实例	598
23.10  工具栏的开发使用实例	602
23.11  对话框使用实例	606
23.11.1  JDialog类简介	606
23.11.2  JOptionPane类简介	607
23.11.3  JOptionPane对话框使用实例	609
23.12  文件选择器	611
23.13  颜色选择器	614
23.14  文件、颜色对话框使用实例	615
23.15  小结	617
第24章  经典的树状列表	618
24.1  树的专有名词	618
24.2  JTree类	619
24.3  树模型	623
24.4  树的节点	625
24.5  树的路径	628
24.6  树的相关事件	629
24.6.1  TreeSelectionEvent事件	629
24.6.2  TreeExpansionEvent事件	630
24.6.3  TreeModelEvent事件	631
24.7  树节点的绘制	632
24.7.1  TreeCellRenderer接口	632
24.7.2  DefaultTreeCellRenderer类	632
24.7.3  自定义绘制器实例	633
24.8  树状列表的综合实例	635
24.8.1  实例概述	635
24.8.2  搭建界面	636
24.8.3  信息提示功能	638
24.8.4  节点增删功能	640
24.8.5  图标更改功能	643
24.9  小结	646
第25章  表格制造	647
25.1  表格简介	647
25.2  JTable类	648
25.2.1  使用JTable的简单实例	650
25.2.2  表格的数据模型	652
25.2.3  表格模型的使用实例	655
25.3  表格列	657
25.3.1  TableColumnModel接口	658
25.3.2  DefaultTableColumnModel类	659
25.4  表格的相关事件	661
25.4.1  TableColumnModelEvent事件	661
25.4.2  TableModelEvent事件	662
25.4.3  ListSelectionEvent事件简介	662
25.4.4  表格事件使用实例	663
25.5  表格绘制器	665
25.5.1  TableCellRenderer接口	666
25.5.2  DefaultTableCellRenderer类简介	666
25.5.3  自定义表格绘制器	667
25.6  表格编辑器	668
25.6.1  TableCellEditor接口	668
25.6.2  AbstractCellEditor类	668
25.6.3  DefaultCellEditor类	669
25.6.4  为特定的类型指定编辑器	669
25.7  自定义表格编辑器与绘制器的使用实例	670
25.7.1  实例概述	670
25.7.2  界面框架的搭建	670
25.7.3  自定义表格以及表格控件的添加	671
25.7.4  自定义绘制器	673
25.7.5  自定义编辑器的添加	674
25.8  表格中的排序	677
25.8.1  RowSorter类	678
25.8.2  DefaultRowSorter类	678
25.8.3  TableRowSorter类简介	679
25.9  表格中的过滤	680
25.10  表格排序与过滤的使用实例	682
25.10.1  实例概述	682
25.10.2  搭建界面框架	683
25.10.3  添加表格	684
25.10.4  添加排序器	685
25.10.5  添加设置过滤条件的控件	686
25.10.6  表格设置过滤器	688
25.11  小结	691
第26章  图形绘制与动画	692
26.1  绘制简单图形	692
26.1.1  可以充当画布的控件	692
26.1.2  绘图的paint方法	692
26.2  画笔	693
26.2.1  Graphics对象的获取	694
26.2.2  坐标系统	694
26.3  调配颜色	696
26.4  图形绘制的使用实例	697
26.5  绘制文本	698
26.5.1  drawString方法	698
26.5.2  控制字体	698
26.5.3  文本绘制使用实例	700
26.6  Java 2D	701
26.7  线条的粗细控制	702
26.8  渐变颜色	704
26.9  图形变换	706
26.10  异或模式绘图	708
26.11  抗锯齿	709
26.12  动画	710
26.12.1  编写动画的原理	710
26.12.2  重新绘制	710
26.13  Timer类	711
26.14  简单动画使用实例	712
26.15  小结	714
第27章  处理图像	715
27.1  加载与绘制	715
27.2  图标	718
27.2.1  Icon接口	719
27.2.2  ImageIcon类	721
27.3  处理图像编码	723
27.3.1  JPEG编码器	723
27.3.2  GifEncoder编码器	724
27.4  图像抓取	726
27.4.1  createScreenCapture方法	726
27.4.2  抓屏功能使用实例	726
27.5  图像滤镜的开发	730
27.6  图像灰度处理使用实例	731
27.7  RGB色彩通道过滤	734
27.8  RGB色彩通道过滤使用实例	735
27.9  卷积滤镜	738
27.10  卷积滤镜使用实例	740
27.11  小结	743
第5篇  高级技术
第28章  网络编程的世界	744
28.1  网络编程简介	744
28.2  网络传输协议	745
28.3  Internet地址（InetAddress类）	746
28.3.1  创建InetAddress对象的方法	746
28.3.2  InetAddress的其他方法	746
28.4  Socket（套接字）	747
28.5  Socket使用实例	748
28.5.1  客户端	748
28.5.2  服务器端	749
28.5.3  程序运行结果	751
28.6  UDP协议网络通信（Datagram）	752
28.7  面向无连接的使用实例	752
28.7.1  发送端程序示例	752
28.7.2  接收端程序示例	754
28.7.3  程序运行结果	755
28.8  URL的网络编程	756
28.8.1  URL类与URL的解析	756
28.8.2  URLConnection类	757
28.8.3  获取远程图像	758
28.8.4  获取远程文档	759
28.8.5  获取远程音频	761
28.9  小结	762
第29章  你来我往的I/O流	763
29.1  流的简介	763
29.2  文件File	764
29.2.1  文件或目录的生成	764
29.2.2  文件名的处理	764
29.2.3  文件属性测试	765
29.2.4  普通文件信息和工具	765
29.2.5  目录操作	765
29.3  File类使用实例	765
29.4  RandomAccessFile类	767
29.4.1  构造方法	767
29.4.2  文件指针的操作	767
29.5  RandomAccessFile使用实例	767
29.6  字节流InputStream、OutputStream	770
29.6.1  输入、输出流	770
29.6.2  文件输入、输出流	772
29.6.3  缓冲输入、输出流	773
29.6.4  数据输入、输出流	775
29.6.5  对象输入、输出流	776
29.7  字符流Reader、Writer	780
29.7.1  字符读、写流	780
29.7.2  输入、输出流	781
29.7.3  文件读、写字符流	782
29.7.4  字符缓冲区读、写流	783
29.8  小结	784
第30章  JDBC数据库应用技术	785
30.1  数据库应用架构模型	785
30.1.1  两层结构模型	785
30.1.2  三层结构模型	786
30.2  JDBC的层次结构	787
30.3  JDBC编程入门	788
30.3.1  数据库的创建	788
30.3.2  JDBC-ODBC连接桥	789
30.3.3  加载JDBC驱动	792
30.4  建立数据库连接	793
30.5  SQL命令	794
30.6  结果集	795
30.7  连接数据库使用实例	796
30.8  预编译	797
30.9  访问其他数据库	800
30.9.1  MySQL数据库的访问	800
30.9.2  Oracle数据库的访问	802
30.10  事务	804
30.10.1  编写事务	804
30.10.2  批处理	807
30.11  可滚动结果集	809
30.12  可滚动与不可滚动结果集的比较	810
30.13  控制游标移动	810
30.14  元数据	813
30.15  数据库综合实例	817
30.16  小结	834
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java开发手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java大学教程
第一篇
第1章  步入Java世界
第2章  选择
第3章  迭代
第4章  方法的实现
第5章  数组
第6章  类和对象
第7章  类的实现
第8章  通过继承扩展类
第9章  软件质量
第10章 图形和事件驱动程序
第11章 案例研究--第1部分
第12章 案例研究--第2部分
第二篇
第13章 程序包
第14章 抽象、继承和接口
第15章 异常
第16章 二维数组
第17章 Java聚集类框架
第18章 高级图形编程
第19章 改进用户界面
第20章 文件处理
第21章 高级案例研究
第22章 多线程程序
第23章 Java网络编程
第24章 Java的背景
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java大学教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计完全自学手册
出版说明
前言
第1章 初识Java 1
1.1 Java语言的诞生和发展 2
1.1.1 Java语言的诞生 2
1.1.2 Java语言的发展 2
1.2 Java语言的特点 2
1.2.1 简单性 2
1.2.2 面向对象 2
1.2.3 分布式 3
1.2.4 解释型 3
1.2.5 健壮安全性 3
1.2.6 体系结构中立 3
1.2.7 可移植性 3
1.2.8 高性能 3
1.2.9 多线程 3
1.3 搭建Java语言的开发环境 3
1.3.1 JDK简介 4
1.3.2 安装JDK 6.0 4
1.3.3 配置环境变量 6
1.3.4 测试配置环境变量 7
第2章 简单了解Java程序 9
2.1 认识Java程序 10
2.2 第一个Java程序 10
2.2.1 解释第一个Java程序 10
2.2.2 在EditPlus 3中编写第一个Java程序 10
2.2.3 在DOS窗口中编译与运行 11
2.2.4 在EditPlus 3中编译与运行 13
2.3 Java 标识符 14
2.4 Java关键字 15
2.5 为Java程序添加注释 16
2.5.1 单行注释 16
2.5.2 多行注释 16
2.5.3 文档注释 17
2.6 初学者编写Java程序应注意的问题 18
2.7 本章实例 18
2.8 小结 20
第3章 Java语法基础 21
3.1 编码规范 22
3.1.1 Java命名规范 22
3.1.2 代码编写规则 22
3.2 数据类型 22
3.2.1 整数数据类型 23
3.2.2 浮点数据类型 23
3.2.3 字符数据类型 24
3.2.4 布尔数据类型 24
3.2.5 基本数据类型的应用 24
3.3 Java的常量与变量 25
3.3.1 常量 25
3.3.2 变量 26
3.3.3 变量的作用域 28
3.4 Java中的运算符 28
3.4.1 赋值运算符 28
3.4.2 算术运算符 29
3.4.3 比较运算符 29
3.4.4 逻辑运算符 29
3.4.5 位运算符 30
3.4.6 三元（目）运算符 31
3.4.7 自增和自减运算符 31
3.4.8 表达式 33
3.4.9 运算符优先级 33
3.5 基本数据类型之间的转换 34
3.5.1 自动类型转换 34
3.5.2 强制类型转换 35
3.5.3 表达式的数据类型自动提升 36
3.6 本章实例 36
3.7 小结 39
第4章 算法和流程控制语句 41
4.1 算法 42
4.1.1 什么是算法 42
4.1.2 算法的特性 42
4.1.3 算法的描述 42
4.1.4 程序的3种控制结构 45
4.2 分支语句 46
4.2.1 简单的if条件语句 46
4.2.2 if...else条件语句 47
4.2.3 if...else if多分支语句 49
4.2.4 switch多分支语句 51
4.2.5 if语句和switch语句的区别 53
4.3 循环语句 53
4.3.1 for循环语句 54
4.3.2 while循环语句 55
4.3.3 do...while循环语句 56
4.3.4 循环的嵌套 58
4.3.5 各种循环语句的区别 59
4.4 跳转语句 60
4.4.1 break跳转语句 60
4.4.2 continue跳转语句 61
4.4.3 return跳转语句 62
4.5 本章实例 63
4.6 小结 65
第5章 开发工具MyEclipse 6.0 67
5.1 安装与启动MyEclipse 6.0 68
5.1.1 安装MyEclipse 6.0 68
5.1.2 启动MyEclipse 6.0 70
5.2 MyEclipse 6.0工作平台 71
5.2.1 常用工具栏介绍 71
5.2.2 视图 72
5.2.3 透视图 72
5.2.4 编辑器 73
5.3 使用MyEclipse 6.0 73
5.3.1 认识Java项目 73
5.3.2 新建Java项目 74
5.3.3 创建与编写一个Java类 75
5.3.4 编译Java类 75
5.3.5 运行Java类 76
5.4 MyEclipse 6.0资源管理 77
5.4.1 导入与删除Java类 77
5.4.2 导入Java项目 77
5.4.3 导出Java项目 78
5.4.4 删除Java项目 79
5.5 用断点调试程序 80
5.6 小结 81
第6章 数 组 83
6.1 数组的概念 84
6.2 一维数组 84
6.2.1 一维数组的声明与创建 84
6.2.2 一维数组的初始化 85
6.2.3 一维数组的访问 85
6.2.4 一维数组的操作 86
6.2.5 foreach语句 88
6.2.6 内存中的一维数组 89
6.2.7 一维数组的应用举例 89
6.3 二维数组 91
6.3.1 二维数组的声明与创建 91
6.3.2 二维数组的初始化 92
6.3.3 二维数组的访问 92
6.3.4 内存中的二维数组 93
6.3.5 二维数组的应用举例 94
6.4 多维数组 95
6.4.1 多维数组的声明与创建 95
6.4.2 多维数组的初始化 96
6.4.3 多维数组的访问 96
6.4.4 使用多维数组 96
6.4.5 内存中的三维数组 97
6.5 本章实例 97
6.6 小结 100
第7章 字符串处理 101
7.1 字符串 102
7.1.1 声明字符串 102
7.1.2 创建字符串 102
7.2 连接字符串 103
7.2.1 字符串与字符串的连接 103
7.2.2 字符串与其他类型数据的连接 105
7.3 字符串常用操作 106
7.3.1 比较字符串是否相等 106
7.3.2 获取字符串的长度 106
7.3.3 字符串的大小写转换 107
7.3.4 查找字符串 108
7.3.5 获取字符串的子字符串 110
7.3.6 替换字符串与除去字符串中的空格 111
7.3.7 分割字符串 112
7.4 格式化字符串 113
7.4.1 常规类型的格式化 113
7.4.2 日期和时间字符串格式化 115
7.5 StringBuilder类 119
7.5.1 创建字符串生成器 119
7.5.2 字符串生成器的应用 120
7.6 本章实例 122
7.7 小结 125
第8章 面向对象编程 127
8.1 面向对象程序设计 128
8.1.1 面向对象程序设计的概述 128
8.1.2 面向对象程序设计的特点 129
8.2 类 129
8.2.1 类的结构 129
8.2.2 成员变量 130
8.2.3 成员方法 130
8.2.4 访问修饰符 131
8.3 类的对象 132
8.3.1 创建与使用对象 132
8.3.2 实现类的封装 134
8.3.3 构造方法（函数） 136
8.3.4 this、static关键字 138
8.4 方法 141
8.4.1 方法的参数传递机制 141
8.4.2 方法的重载 144
8.5 垃圾回收 145
8.5.1 垃圾回收原理 145
8.5.2 finalize( )方法 146
8.5.3 垃圾回收的本质 146
8.6 本章实例 147
8.7 小结 150
第9章 Java的继承与多态 151
9.1 继承 152
9.1.1 继承的概念与特点 152
9.1.2 访问父类的成员变量和方法 153
9.1.3 子类的构造函数 154
9.1.4 子类的构造过程 155
9.2 方法的重写和字段隐藏 157
9.2.1 方法的重写 157
9.2.2 字段的隐藏 159
9.3 多态 160
9.3.1 多态的含义 160
9.3.2 抽象方法与抽象类 161
9.4 final关键字的使用 164
9.4.1 最终方法 164
9.4.2 最终类 165
9.5 本章实例 165
9.6 小结 172
第10章 类的高级应用 173
10.1 接口 174
10.1.1 接口的含义 174
10.1.2 创建接口 174
10.1.3 接口的使用 175
10.1.4 接口的继承 176
10.1.5 接口的多态 177
10.2 内部类 180
10.2.1 在类中定义内部类 180
10.2.2 内部类的使用 181
10.2.3 在方法中定义内部类 183
10.3 包 184
10.3.1 包的描述 184
10.3.2 创建包 184
10.3.3 包的使用 184
10.4 本章实例 188
10.5 小结 191
第11章 Java中的异常处理 193
11.1 异常处理概述 194
11.2 Java常见异常及产生原因 194
11.2.1 空指针异常 194
11.2.2 没有找到具有指定名称的类 195
11.2.3 算术异常 195
11.2.4 数组越界异常 195
11.2.5 非法参数异常 196
11.3 异常的处理机制 196
11.3.1 使用try...catch捕获异常 197
11.3.2 使用throws声明抛出异常 198
11.3.3 自定义异常与throw关键字 199
11.4 本章实例 201
11.5 小结 209
第12章 泛型和集合 211
12.1 引出泛型的原因 212
12.2 理解泛型 213
12.2.1 泛型的定义1 213
12.2.2 泛型的定义2 216
12.2.3 泛型的定义3 218
12.3 集合概述 220
12.4 List集合 220
12.4.1 List集合的性质 220
12.4.2 ArrayList类的使用 221
12.4.3 使用泛型 223
12.5 Set集合 225
12.5.1 Set集合的性质 225
12.5.2 HashSet类的使用 226
12.5.3 TreeSet类的使用 228
12.6 Map集合 230
12.6.1 Map集合的性质 230
12.6.2 HashMap类的使用 230
12.7 本章实例 232
12.8 小结 239
第13章 I/O处理 241
13.1 Java I/O体系结构 242
13.2 Java提供的流类 242
13.2.1 I/O中的输入字节流 242
13.2.2 I/O中的输出字节流 244
13.2.3 字节流与字符流 246
13.2.4 I/O中的输入字符流 246
13.2.5 I/O中的输出字符流 248
13.3 File类 250
13.3.1 文件类的构造方法 250
13.3.2 获取文件信息 251
13.3.3 复制文件中的内容 253
13.3.4 压缩文件 254
13.3.5 分行写入文件 255
13.4 本章实例 257
13.5 小结 261
第14章 线 程 263
14.1 线程概述 264
14.1.1 线程的定义 264
14.1.2 线程与进程 264
14.2 线程的创建 264
14.2.1 通过继承Thread类来创建 264
14.2.2 通过实现Runnable接口来创建 266
14.3 线程的控制 268
14.3.1 线程的让步 268
14.3.2 线程优先级的改变 269
14.4 线程的同步 270
14.4.1 线程同步所引发的安全问题 271
14.4.2 线程的同步机制 272
14.5 线程之间的通信 274
14.5.1 监视器的概念 274
14.5.2 一些基本的线程通信方法 274
14.6 本章实例 276
14.7 小结 278
第15章 自动装箱、拆箱与反射 279
15.1 自动装箱与拆箱 280
15.1.1 自动装箱 280
15.1.2 拆箱 281
15.2 装箱与拆箱所带来的问题 282
15.2.1 “==”的问题 282
15.2.2 拆箱带来的异常问题 283
15.3 反射 284
15.3.1 Java反射机制概述 284
15.3.2 加载类 285
15.3.3 通过反射查看类信息 285
15.3.4 使用反射生成与操作对象 287
15.4 本章实例 289
15.5 小结 292
第16章 Java Web应用程序开发环境 293
16.1 Tomcat 6.0的使用 294
16.1.1 Tomcat 6.0简介 294
16.1.2 安装与启动Tomcat 6.0 294
16.1.3 在MyEclipse 6.0中配置与测试Tomcat 6.0 296
16.2 Dreamweaver CS3的使用 299
16.2.1 Dreamweaver CS3简介 299
16.2.2 Dreamweaver CS3安装 299
16.3 MySQL 5.1数据库基础 301
16.3.1 MySQL 5.1数据库简介 301
16.3.2 安装MySQL 5.1 301
16.3.3 安装MySQL Administrator 1.1插件 306
16.3.4 安装MySQL Query Browser 1.1插件 308
16.4 MySQL 5.1数据库的基本操作 310
16.4.1 创建数据库 310
16.4.2 在数据库中创建表 311
16.4.3 插入数据 313
16.4.4 MySQL 5.1数据库的备份 314
16.4.5 MySQL 5.1数据库还原 315
第17章 Servlet和Web应用体系 317
17.1 C/S模式与B/S模式 318
17.1.1 C/S模式 318
17.1.2 B/S模式 318
17.2 Http请求和响应模式 319
17.2.1 超文件传输协议Http 319
17.2.2 Http请求 319
17.2.3 Http响应 321
17.3 HTML简介 322
17.4 Servlet简介 324
17.4.1 什么是Servlet 324
17.4.2 认识Servlet 324
17.5 Web应用体系 325
17.5.1 Servlet容器的概念 326
17.5.2 编写一个简单的Servlet 326
17.5.3 在MyEclipse6.0中编写Servlet 327
17.5.4 配置web.xml 329
17.5.5 部署到Tomcat 6.0服务器上运行 330
17.6 Servlet高级应用 333
17.6.1 Servlet生命周期 333
17.6.2 ServletContext与ServletConfig对象 336
17.6.3 在MyEclipse中创建JSP 339
17.6.4 Servlet重定向 340
17.7 小结 344
第18章 学习JSP 345
18.1 JSP概述 346
18.1.1 JSP简介 346
18.1.2 JSP的优势 346
18.1.3 JSP的处理过程 346
18.1.4 了解JSP页面基本结构 346
18.1.5 JSP注释 351
18.2 HttpSession接口 352
18.2.1 JSP Session机制 352
18.2.2 HttpSession的使用 353
18.3 监听器Listener 353
18.3.1 什么是监听器 353
18.3.2 ServletContext事件监听器 353
18.3.3 HttpSession事件监听器 357
18.3.4 ServletRequest的事件监听器 361
18.4 过滤器 364
18.4.1 过滤器的原理 364
18.4.2 过滤器的创建 365
18.4.3 过滤器的顺序 367
18.5 小结 369
第19章 JSP语法 371
19.1 Cookie的应用 372
19.1.1 什么是Cookie 372
19.1.2 Cookie的好处 372
19.1.3 创建Cookie 372
19.2 JSP的内置对象 372
19.2.1 request对象 373
19.2.2 response对象 374
19.2.3 out对象 374
19.2.4 session对象 375
19.2.5 application对象 380
19.2.6 page和pageContext对象 381
19.2.7 exception对象 381
19.2.8 config对象 382
19.3 JavaBean简介 387
19.3.1 什么是JavaBean 388
19.3.2 为什么使用JavaBean 389
19.4 JSP动作元素 389
19.4.1 动作 389
19.4.2 动作 389
19.4.3 动作 390
19.4.4 动作 390
19.4.5 与动作 391
19.5 EL表达式 396
19.5.1 EL表达式的形式 396
19.5.2 EL表达式功能 397
19.6 JSTL基础知识 397
19.6.1 JSTL简介 397
19.6.2 JSTL的核心标签库 397
19.7 小结 405
第20章 访问数据库 407
20.1 JDBC技术简介 408
20.2 JDBC连接方式 408
20.2.1 JDBC驱动介绍 408
20.2.2 安装MySQL驱动 409
20.2.3 JDBC连接数据库的步骤 409
20.3 JDBC的API 411
20.3.1 驱动程序管理类DriverManager 411
20.3.2 数据库连接类Connection 412
20.3.3 SQL声明类Statement 413
20.3.4 SQL声明类
PreparedStatement 413
20.3.5 查询结果集类ResultSet 414
20.4 连接MySQL数据库实例 414
20.4.1 创建数据库连接实例 415
20.4.2 操作MySQL数据库实例 416
20.5 数据库连接池 421
20.5.1 多用户数据库连接方法 421
20.5.2 在Tomcat 6.0下配置MySQL 5.1连接池 422
20.5.3 测试连接池设置是否生效 422
20.6 小结 424
第21章 远程教学系统的实现 425
21.1 远程教学系统的系统分析 426
21.1.1 可行性分析 426
21.1.2 需求分析 426
21.2 远程教学系统的总体设计 427
21.2.1 以教师身份登录的功能模块 428
21.2.2 以学生身份登录的功能模块 428
21.2.3 以管理员身份登录的功能模块 428
21.3 远程教学系统的数据库设计 429
21.3.1 远程教学系统的数据库的E-R图设计 429
21.3.2 数据表设计 430
21.4 Java Web应用配置文件web.xml 431
21.5 学生身份登录的模块设计与实现 436
21.5.1 学生模块JavaBean的设计与实现 436
21.5.2 学生模块操作数据库方法的设计与实现 438
21.5.3 学生模块Servlet的设计与实现 445
21.5.4 学生模块主页面的设计与实现 448
21.6 教师身份登录的模块设计与实现 450
21.6.1 教师模块操作数据库方法的设计与实现 450
21.6.2 教师模块Servlet的设计与实现 458
21.7 管理员身份登录的后台模块设计与实现 461
21.7.1 管理员模块数据库底层方法的设计与实现 461
21.7.2 管理员模块Servlet的设计与实现 464
第22章 Struts应用 469
22.1 Struts简介 470
22.2 为什么要用Struts框架 470
22.3 Struts的核心—MVC 470
22.4 Struts的工作原理 471
22.5 Struts的工作流程 471
22.6 Struts的基本配置 472
22.6.1 web.xml配置文件 472
22.6.2 struts-config.xml配置文件 473
22.7 表单处理器ActionForm 475
22.7.1 ActionForm类 475
22.7.2 编写FormBean 477
22.8 Struts中的控制器Action 478
22.8.1 Action类 478
22.8.2 Action的代码实现 478
22.9 Struts标签库 479
22.9.1 导入Struts的标签库 479
22.9.2 Struts的HTML标签 479
22.9.3 Struts的Bean标签 483
22.9.4 Struts的Logic标签 485
22.10 小结 487
第23章 在线投票系统的实现 489
23.1 需求分析 490
23.1.1 用例分析 490
23.1.2 数据流分析 490
23.1.3 数据字典分析 491
23.2 总体设计 491
23.2.1 前台功能设计 491
23.2.2 后台功能设计 491
23.2.3 系统的数据库设计 492
23.3 系统架构设计 492
23.4 创建基于Struts框架的项目包 493
23.5 创建数据库连接 494
23.6 编写系统配置文件 495
23.7 后台模块的设计与实现 497
23.7.1 标题及内容管理模块JavaBean的设计与实现 497
23.7.2 标题及内容管理模块FormBean的设计与实现 498
23.7.3 标题及内容管理模块底层方法的设计与实现 499
23.7.4 标题及内容管理模块Action的设计与实现 502
23.7.5 后台登录页面和主页面的设计与实现 504
23.8 前台用户投票模块的设计与实现 506
23.8.1 用户投票模块底层方法的设计与实现 506
23.8.2 用户投票模块Action的设计与实现 507
23.8.3 用户投票模块的页面设计 508
第24章 Hibernate应用 513
24.1 Hibernate简介 514
24.2 Hibernate框架概述 514
24.2.1 Hibernate的优势 514
24.2.2 Hibernate架构 514
24.3 Hibernate 框架主要的API 514
24.3.1 Configuration类 515
24.3.2 SessionFactory接口 515
24.3.3 Session接口 516
24.3.4 Query接口 517
24.3.5 Transaction接口 517
24.4 Hibernate的持久化技术 517
24.4.1 什么是持久化 517
24.4.2 持久化的意义 517
24.4.3 持久化类 517
24.4.4 Hibernate中的对象状态 518
24.5 Hibernate框架中的ORM技术 519
24.5.1 持久化类 519
24.5.2 映射文件 519
24.5.3 Hibernate的配置文件 520
24.6 Hibernate框架查询语言 521
24.6.1 HQL中的from子句 521
24.6.2 HQL中的属性查询 521
24.6.3 HQL中的更新和删除 522
24.6.4 HQL中的order by子句 522
24.6.5 HQL中的group by子句 522
24.6.6 HQL中的连接 523
24.7 HQL中的参数绑定 523
24.7.1 按参数名称绑定 523
24.7.2 按参数位置绑定 523
24.7.3 使用setParameter( )方法来绑定参数 524
24.7.4 使用setProperties( )方法来绑定参数 524
24.8 Hibernate反向工程 524
24.8.1 在MyEclipse 6.0中创建数据库连接 524
24.8.2 在Java Web项目中加入Hibernate架包 526
24.8.3 在MyEclipse 6.0中生成代码 528
24.9 小结 529
第25章 制作精美的留言板 531
25.1 需求分析 532
25.1.1 用例分析 532
25.1.2 数据流分析 532
25.1.3 数据字典分析 533
25.2 详细设计 533
25.2.1 前台功能设计 533
25.2.2 后台功能设计 533
25.2.3 系统的类图设计 534
25.2.4 系统的数据库设计 534
25.3 系统总体设计 535
25.3.1 系统的设计思想 535
25.3.2 系统中的过滤器 535
25.3.3 后台管理留言模块设计 536
25.4 创建数据库连接 537
25.4.1 系统O/R Mapping映射文件的设计与实现 537
25.4.2 Hibernate.cfg.xml的配置 539
25.5 系统struts-config.xml配置文件 540
25.6 系统web.xml设计与实现 542
25.7 系统JavaBean设计与实现 543
25.8 后台模块的设计与实现 546
25.8.1 管理员登录模块的设计与实现 547
25.8.2 回复留言模块的设计与实现 551
25.8.3 查询留言模块的设计与实现 554
25.8.4 删除留言模块的设计与实现 559
25.9 前台模块的设计与实现 564
25.9.1 用户留言模块FormBean的设计与实现 564
25.9.2 用户留言模块底层方法的设计与实现 565
25.9.3 用户留言模块Action的设计与实现 566
25.9.4 用户留言模块的页面设计与实现 567
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计完全自学手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JavaScript语言精粹
前言	I
第1章 精华	1
为什么是JAVASCRIPT?	2
分析JAVASCRIPT	3
一个简单的试验场	4
第2章 语法	5
空白	5
标识符	6
数字	7
字符串	8
语句	10
表达式	15
字面量	17
函数	19
第3章 对象	20
对象字面量	20
检索	21
更新	22
引用	22
原型	22
反射	23
枚举	24
删除	24
减少全局变量污染	25
第4章 函数	26
函数对象	26
函数字面量	27
调用	27
参数	31
返回	31
异常	32
给类型增加方法	32
递归	34
作用域	36
闭包	37
回调	40
模块	40
级联	42
套用	43
记忆	44
第5章 继承..	46
伪类	47
对象说明符	50
原型	50
函数化	52
部件	55
第6章 数组	58
数组字面量	58
长度	59
删除	60
枚举	60
混淆的地方	61
方法	62
维度	63
第7章 正则表达式	65
一个例子	66
结构	70
元素	72
第8章 方法	78
第9章 代码风格	94
第10章 优美的特性	98
附录A：糟粕	101
附录B：鸡肋	109
附录C：JSLINT	115
附录D：语法图	125
附录E：JSON	136
索引	147
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JavaScript语言精粹
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java面向对象编程指南
第一部分 对象入门
第1章 Java基础知识
第2章 抽象和建模
……
第二部分 对象建模
第8章 核心对象建模过程
第9章 通过使用案例说明需求
……
第三部分 将对象“蓝图”转换为Java代码
第13章 深入了解Java
第14章 将模型转换为Java代码
……
第四部分 附录
附录A 关于将本书作为教科书的建议
附录B 选择的案例研究
……
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java面向对象编程指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序调试实用手册
第一部分 从编写没有漏洞的代码开始

第1章 完全没有漏洞是不可能的
l．l 证据
1．2 调试或者测试都无法找到所有漏洞
1．3 这样将变得更糟
1．4 开始就必须去除代码漏洞

第2章 使用Hatching预防Java漏洞
2．1 开发哲学
2．1．l 左脑＜＝＞右脑
2．1．2 如何更加富有创造力
2．1．3 如何更好地组织
2．1．4 程序员创建而测试员破坏
2．2 首先编写文档
2．2．l 首先是用户手册
2．2．2 强有力的结束工作
2．2．3 用户手册成为编程规范
2．3 学着喜欢Javadoc
2．4 危险元素在安全元素之前
2．4．l 尽早处理例外
2．4．2 避免限期压力

第3章 设置Java漏洞中断
3．l 指导代码
3．1．l 代码工具
3.1.2 Java例外的细节
3．1．3 例外提高了艺术的境界
3．1．4 处理例外的编码
3．1．5 嵌套使用try模块
3．2 throw模块
3．2．l theows关键词
3．3 隐藏在幻象漏洞之后的漏洞
3．3．l 练习生成漏洞
3．4 自动记录结果

第4章 千万不要错过另一个限期！危险因子分析
4．l 使用危险因子分析（RFA）
4．1．l 如何开始 RFA
4．l. 2 如何使用RFA
4．1．3 为什么使用 RFA
4.2 为什么RFA对于调试Java非常重要？

第5章 编写代码避开漏洞
5．l 通用文字处理器．
5．1．l 使用 Microsoft Word
5．2 使用最好的 Java编辑器．
5．3 编辑窍门
5．3．l 使笔误自我显露
5．3．2 扩展拷贝／粘贴缓冲区
5．3．3 使用自动更正功能清除错误和保存输入
5．4 练习拼写检查器
5．5 按照先头后尾再中间的顺序书写
5．6 QQQ书签
5．7 3X5的打孔卡片
5．8 使用已知的Java子集
5．9 先注释后代码
5．10 牢记语言之间的区别
5．10．1 Java和C／C＋＋
5．10．2 Java和 Vsual Basic（VB）之间的主要区别
5．11 集成开发环境（IDE）
5．11．1 JBuilder
5．11．2 JDK Commander
5．11．3 Mojo
5．14．4 Visualcafe
5．12 漏洞类别

第二部分 清除Java漏洞

第6章 漏洞类别
6．l 设计漏洞
6．1．l 条件总是以2的幂数成对出现
6．2 语法漏洞
6.2．l 代码生成器
6．2．2 代码生成器的特性
6．2．3 类似Lint的检验程序
6．3 逻辑漏洞
6．3．l 逻辑性实际错误
6.4 解决神秘之处
6．5 数学漏洞
6．5．l 接近边界值的数学问题
6．5．2 布尔变量
6．5．3 不常用的操作符：移位
6．6 罕见的漏洞
6．6．l 数据导致的漏洞
6.7 副作用漏洞
6．8 优化引起的漏洞
6．9 假冒的漏洞

第7章 心理训练．
7．l 如何保持思维的一贯性
7．1．l 使用纯粹的个人习惯
7．2 不要混合使用深度搜索和广度搜索
7．3 何时调试
7．4 环境

第8章 Debugger的可怕威力
8．l 免费的JavaDebugger（JDB）
8．1．1 安装
8．1．2 简介
8．l．3 命令参考
8．2 第三方Debugger
8．2．1 Assure
8．2．2 JBuilder
8．2．3 JProbe
8．2．4 Visual Cafe

第9章 调试策略
9．1 集成最好资源
9．2 分解漏洞
9．2．1 开始修改
9．2．2 猎枪的方法
9．2．3 根据推论调试
9．2．4 二进制漏洞搜索
9．2．5 测试
9．3 卡住时问些问题

第10章 测试
10．l 定位后击垮漏洞
10．1．l 武装你的代码
10．1．2 条件编译
10．1．3 漏洞在何处？
10．1．4 黑盒测试
10．1．5 白盒测试
10．1．6 全逻辑测试
10．2 制造更好的苍蝇拍
10．2．1 Macro Recorder
10．2．2 Best Practices Analyzer
10.2.3 Static Coverage Analyzer
10．2．4 Dynamic Coverage Analyzer
10．2．5 Bug Tracker
10．2．6 Test Data Assistant
10．2．7 何时停止测试
10．2．8 播撒错误的种子
10．2．9 你需要第二台计算机
10．3 Java的商业软件工具

第11章线程化环境
11．l 回顾古老的并行算法
11．2 并行计算漏洞
11．2．1 Daemon和 user线程
11．2．2 Java本身的防护
11．2．3 循环并行化
11．2．4 处理输入和输出
11．2．5 异步任务
11．2．6 定时程序
11．2．7 对时间敏感的线程漏洞
11．3 预防线程崩溃
11．3．l 使用循环锁解救
11．3．2 使用监督程序和信号量锁定
11．3．3 监督程序和信号量的详细内容
11．3．4 一些线程使用经验
11．3．5 性能问题
11．4 线程安全
11．5 预防措施

第12章 走开的人
12．l 用户如何查觉漏洞
12．1．l 让你的客户喜欢你
12．2 定义造成的漏洞混乱
12．3 还有什么可能出错？
12．4 组成完美错误信息的元素
12．4．l 使用用户的语言描述
12．4．2 不要过于简洁
12．4．3 小心选择词汇
12．4．4 确认是否拼写错误
12．4．5 道歉永de不会有害
12．4．6 最好完全解密
12．4．7 你的用户正处在接近恐慌的状态
12．4．8 错误消息必须可以缓和情绪
12．4．9 避免使用任何屈尊的语气
12．4．10 标准化步骤
12．4．11 按钮标题
12．5 格式化错误消息
12．6 错误消息的内容
12．6．1 发生了什么事？
12．6．2 为什么发生？
12．6．3 其后将发生什么现象？
12．6．4 现在用户可做什么？
12．6．5 将来用户能做什么？
12．6．6 现在用户从何处可以得到帮助？
12．6．7 用户如何才能帮助开发人员改善情况？
12．6．8 最近在用户的软件中发生过类似问题否？
12．6．9 用户应该如何向技术人员描述问题？
12．6．10 聊天室和帮助室
12．6．11 软件开发人员将为用户提供什么补偿？
12．6．12 问题发生时计算机的状态如何？
12．6．13 漏洞在客户端还是在服务器端？
12．6．14 打开了哪个数据库、表和字段？
12．6．15 哪个程序、哪个模块、哪种方法以及哪一行触发了错误？
12．6．16 当时哪个线程正在活动？
12．6．17 按照计算机支持的精度，问题究竟在何时发生？
12．6．18 登录用户是哪一位？
12．6．19 屏幕或者报告中应该显示什么内容
12．7 永远按照规范保证自己的软件

第三部分 性能

第13章 使用最佳的测试策略
13．l 递增与模块测试
13．1．l 递增测试的优点
13．1．2 传统模块测试的优点
13．l．3 综合测试
13．2 从上至下测试与从下至上测试
13．2．l 从上至下测试
13．2．2 流程图为什么有缺陷
13，2．3 从下至上测试
13．2．4 协议
13．3 原理测试
13．4 测试流程图的空白处
13．5 自动测试程序
13．5．l 自动黑盒测试
13．5．2 自动白盒测试
13．5．3 自动回归测试
13．5．4 自动静态分析
13．5．5 自动覆盖分析
13．5 石幻想和神话
13．6 清除漏洞所需的费用
13．7 其他种类的测试
13．8 还剩下多少漏洞？

附录A 商业设计
A．l 附加项类库
A．2 人工智能
A．3 济览器及测览器工具
A．4 代码生成器
A．5 协作者
A．6 编译程序和解释程序
A．7 数据和网络数据
A．8 调试程序
A．9 文档编写器
A．10 电子商务
A．11 编辑器
A．12 图形开发
A．13 帮助文档编写器
A．14 IDE和开发工具
A．15 安装与配置
A．16 国际化
A．17 Internet
A．18 Java Beans和企业版的JavaBeans（EJB）
A．19 Java虚拟机
A．20 JAR自解压程序
A．21 制图程序
A．22 消息程序
A．23 建模，UML，和 CASE工具
A．24 Obfuscator和优化程序
A．25 对象请求代理程序（ORBs）
A．26 Profiler
A．27 报表制作程序
A．28 安全
A．29 服务器和Servlet
A．30 软件开反工具包
A．31 电子制表软件
A．32 测试工具和套件
A．33 跟踪器，工程管理器
A．34 语音识别
A．35 Java文字处理器
A．36 XML

附录B Java资源
B．l 书籍
B．2 杂志
B．3 电子杂志
B．4 新闻组
B．5 Web站点
B．6 培训

附录C 计算机编程的24条法规

附录 D Java术语表

附录E Word宏
E．l 书签和跳转
E．2 隐藏的文本
E．3 个人注释
E．4 绿色的关键字
E．5 编程帮助
E．6 更多的宏







>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序调试实用手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hibernate 3和Java Persistence API 程序开发从入门到精通
第1章  对象映射  1.1  信息持久化    1.1.1  使用文件系统    1.1.2  使用对象序列化    1.1.3  使用数据库  1.2  对象持久化    1.2.1  软件的三层结构（Three-Layer Architecture）    1.2.2  对象持久化解决方案  1.3  对象关系映射（ORM）    1.3.1  ORM面对的问题    1.3.2  Hibernate的优势    1.3.3  Hibernate3与Java Persistence API(JPA)  1.4  小结第2章  JAVA SE 5的新特性第3章  使用工具软件进行项目开发第4章  Hibernate应用实例第5章  配置Hibernate第6章  基本实体类映射第7章  高级实体类映射第8章  Hibernate映射信息扩展第9章  持久化对象、事务和缓存第10章  Hibernate Session，事件和拦截器第11章  Criterion框架第12章  HQL和Hibernate Query 接口第13章  以JPA方式使用Hibernate附录A  使用Hudson持续集成附录B  使用随书所附源代码专业词汇翻译（按英文字母排序）参考书目网上资料
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hibernate 3和Java Persistence API 程序开发从入门到精通
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构Java语言描述
第1章 面向对象的方法
第2章 注释、条件和断言
第3章 向量
第4章 设计基础
第5章 排序
第6章 一种设计方法
第7章 迭代器
第8章 列表
……
附录A 答案
附录B JAVA入门
附录C 集合
附录D 文档
附录E 环境
附录F 深入阅读
附录G 术语表

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构Java语言描述
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C/C++/Java 程序设计经典教程
第一部分 C语言编程
第一章 计算机、Internet和万维网入门
第二章 C程序设计入门
第三章 C语言结构化程序开发
第四章 C程序控制
……
第二部分 C++编程
第十五章 C的增强版本C++
第十六章 C++类和数据抽象
第十七章 C++类：第二部分
……
第三部分 Java编程
第二十四章 Java应用程序与小程序入门
第二十五章 独特的Java运算符、方法与数组
第二十六章 基于对象的Java编程
……
第四部分 附录
附录A Internet与Web资源
附录B C99 Internet与Web资源
……
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C/C++/Java 程序设计经典教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计基础
第1章 程序设计概述
第2章 Java语言基础
第3章 流程控制
第4章 方法
第5章 类与对象
第6章 继承与多态
第7章 例外处理
第8章 Java基本类库介绍
第9章 Java的集合类
第10章 输入输出系统
第11章 图形界面和Applet
第12章 多线程处理
第13章 JSP技术基础
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计基础
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>学通Java的24堂课
第1部分 基础篇  第1堂课 Java概述    视频讲解：31分钟    1.1 Java简介      1.1.1 Java发展历史      1.1.2 Java的几个版本      1.1.3 Java应用领域      1.1.4 Java项目成功案例      1.1.5 怎样学好Java    1.2 环境搭建      1.2.1 JDK下载      1.2.2 JDK安装      1.2.3 配置环境变量    1.3 编写第一个Java程序      1.3.1 在记事本中输入代码      1.3.2 保存代码为源代码文件      1.3.3 编译并运行Java文件    1.4 照猫画虎——基本功训练      1.4.1 基本功训练1——更换JAVA_HOME环境变量      1.4.2 基本功训练2——提取path变量值创建新环境变量      1.4.3 基本功训练3——输出字符表情      1.4.4 基本功训练4——输出“*”字符组成的三角形    1.5 情景应用——拓展与实践      1.5.1 情景应用1——计算两个整数的和      1.5.2 情景应用2——输出当前日期      1.5.3 情景应用3——在控制台接收用户输入数字      1.5.4 情景应用4——计算用户输入数字的乘积    1.6 自我测试    1.7 行动指南    1.8 成功可以复制——“盖茨第二”  第2堂课 使用IDE集成开发工具  第3堂课 Java语言基础知识  第4堂课 流程控制语句  第5堂课 数组应用  第6堂课 面向对象编程  第7堂课 字符串处理第2部分 提高篇  第8堂课 类的继承与多态特性  第9堂课 其他类特性与异常处理  第10堂课 Swing编程基础  第11堂课 多线程编程  第12堂课 事件处理的应用  第13堂课 常用工具类  第14堂课 常用集合类第3部分 高级篇  第15堂课 数据库编程应用  第16堂课 输入输出流与文件  第17堂课 网络程序设计  第18堂课 表格控件的应用  第19堂课 树控件的应用  第20堂课 其他高级控件  第21堂课 图形绘制技术第4部分 实战篇  第22堂课 进销存管理系统  第23堂课 企业内部通讯管理系统  第24堂课 图书馆管理系统附录A Java程序编码规范
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>学通Java的24堂课
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web 开发就该这样学
第1 章 认识Tomcat....................................................................................................1
1.1 什么是Web Server..........................................................................................................1
1.2 选择Tomcat 来学习.......................................................................................................2
1.3 安装Tomcat ....................................................................................................................2
1.4 MyTomcat.......................................................................................................................6
1.5 MyIE ..............................................................................................................................10
1.6 再谈Tomcat .................................................................................................12
第2 章 学习HTML.....................................................................................14
2.1 认识HTML...................................................................................................................14
2.2 做百度的首页................................................................................................................15
2.3 搜狐邮箱的用户登录....................................................................................................24
2.4 京东的购物车................................................................................................................28
2.5 用表格定位搜狐邮箱的用户登录界面........................................................................32
2.6 使用CSS 实现搜狐邮箱的用户登录...........................................................................41
2.6.1 绝对定位............................................................................................................41
2.6.2 div.......................................................................................................................43
2.6.3 级联样式............................................................................................................44
2.7 在网页上显示时间........................................................................................................49
2.7.1 为什么要学习JavaScript ..................................................................................49
2.7.2 获取时间............................................................................................................50
2.7.3 定义函数............................................................................................................54
2.7.4 js 文件................................................................................................................55
2.7.5 显示到其他地方................................................................................................57
2.7.6 能动的时间........................................................................................................58
2.7.7 漂浮的时间显示................................................................................................60
2.8 再看搜狐邮箱的用户登录............................................................................................63
2.9 京东商城的新用户注册................................................................................................67
2.9.1 String 对象操作.................................................................................................73
2.9.2 正则表达式........................................................................................................74
2.9.3 密码框验证........................................................................................................78
2.9.4 邮箱地址验证....................................................................................................84
2.10 搜狐首页的菜单条......................................................................................................85
2.11 QQ 空间的设置...........................................................................................................89
第3 章 Servlet............................................................................................................94
3.1 Servlet 怎么运行...........................................................................................................94
3.1.1 编写第一个Servlet............................................................................................96
3.1.2 部署..................................................................................................................100
3.2 用户登录.....................................................................................................................104
3.3 重要的XML................................................................................................................111
3.3.1 XML.................................................................................................................112
3.3.2 DTD..................................................................................................................113
3.3.3 Schema .............................................................................................................117
3.3.4 CSS 和XSL .....................................................................................................122
3.3.5 DOM.................................................................................................................126
3.3.6 SAX..................................................................................................................131
3.3.7 XML 总结........................................................................................................132
3.4 购物网站的商品展示..................................................................................................133
3.4.1 数据库设计......................................................................................................133
3.4.2 展示页面程序..................................................................................................134
3.4.3 查询评论数量..................................................................................................141
3.4.4 分离数据库连接..............................................................................................141
3.4.5 分页显示..........................................................................................................144
3.4.6 在每个页面上都显示用户名..........................................................................149
3.5 用户注册.....................................................................................................................151
3.5.1 生成验证码图片..............................................................................................152
3.5.2 绘制干扰线......................................................................................................154
3.5.3 更新验证码......................................................................................................156
3.5.4 注册处理程序..................................................................................................157
3.5.5 使用AJAX 验证用户名是否冲突..................................................................159
3.5.6 用AJAX 实现分页显示..................................................................................162
第4 章 JSP ...........................................................................................................177
4.1 用户登录.....................................................................................................................178
4.1.1 设置中文编码..................................................................................................180
4.1.2 编写脚本..........................................................................................................180
4.1.3 连接数据库......................................................................................................181
4.1.4 跳转..................................................................................................................182
4.2 购物网站的商品展示..................................................................................................185
4.3 将用户登录结合到商品展示页面中..........................................................................190
4.3.1 使用Cookie .....................................................................................................192
4.3.2 将两个网页合并..............................................................................................195
4.4 购物车.........................................................................................................................196
4.4.1 实现加减按钮和删除商品的功能..................................................................201
第5 章 使用JavaBean..............................................................................205
5.1 使用JavaBean 实现用户验证....................................................................................205
5.1.1 定义JavaBean..................................................................................................205
5.1.2 运用JavaBean..................................................................................................208
5.1.3 JavaBean 的作用域..........................................................................................209
5.1.4 在JavaBean 中使用内置对象.........................................................................210
5.2 使用JavaBean 来实现商品展示................................................................................212
5.2.1 规划和设计JavaBean......................................................................................212
5.2.2 改造JSP...........................................................................................................214
5.2.3 将数据库和页面彻底分离开..........................................................................216
5.3 实现购物车逻辑..........................................................................................................221
第6 章 使用自定义标记TAG........................................226
6.1 使用JSP、JavaBean 和TAG 实现商品显示............................................................229
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web 开发就该这样学
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java架构师指南
第　1章 编程基础　1
1．1　程序员进阶　1
1．2　选择开发工具　3
1．3　安装JDK　5
1．4　安装Tomcat服务器　6
1．5　Hello World程序　8
1．6　小结　9
第　2章 需求调研　10
2．1　搭建关系　10
2．2　正式立项　11
2．3　需求调研　11
2．4　输出文档　12
2．5　技术选型　16
2．6　数据流图　16
2．7　UML建模　16
2．8　项目开工会　17
2．9　小结　18
第3章　项目开发　19
3．1　定义范围和WBS分解　19
3．2　企业管理系统框架搭建　20
3．3　Servlet方式开发　20
3．3．1　前端验证　22
3．3．2　后端验证　25
3．3．3　注册功能　28
3．3．4　综合调试　39
3．3．5　Servlet注解　43
3．4　不依赖框架的开发　45
3．4．1　销售数据导入报表　46
3．4．2　销售数据查询报表　53
3．5　月度版本　57
3．6　小结　57
第4章　项目部署　58
4．1　项目打包　58
4．2　项目发布　62
4．3　构建工具　63
4．3．1　Ant环境搭建　63
4．3．2　Ant经典实例　64
4．3．3　Maven环境搭建　66
4．3．4　Maven经典实例　66
4．4　部署工具　70
4．4．1　mstsc　71
4．4．2　VMware　71
4．4．3　Xmanager　75
4．4．4　WinSCP　79
4．4．5　JD-GUI　80
4．5　小结　81
第5章　编程环境　82
5．1　Linux系统介绍　82
5．2　Linux系统安装　83
5．3　Linux常用命令　84
5．3．1　基本命令　84
5．3．2　高级命令　90
5．3．3　部署命令　93
5．3．4　shell脚本入门　100
5．4　DOS介绍　101
5．4．1　基本命令　102
5．4．2　高级命令　104
5．5　SVN与Git版本控制　105
5．5．1　SVN常用操作　106
5．5．2　Git常用操作　110
5．6　Visio画图　114
5．7　Axure原型设计　115
5．8　代码编辑器　116
5．9　小结　119
第6章　架构师思想　120
6．1　数据类型　120
6．1．1　Object　121
6．1．2　byte和Byte　122
6．1．3　short和Short　122
6．1．4　int和Integer　122
6．1．5　long和Long　123
6．1．6　float和Float　123
6．1．7　char和Character　124
6．1．8　double和Double　124
6．1．9　boolean和Boolean　125
6．2　类与对象　125
6．2．1　三大特性　126
6．2．2　属性和方法　126
6．2．3　抽象类和接口　128
6．3　数组　129
6．3．1　创建数组　129
6．3．2　数组的初始化　130
6．3．3　数组的排序　130
6．4　集合类　130
6．4．1　Collection接口　131
6．4．2　Set接口　132
6．4．3　List接口　134
6．4．4　Queue接口　135
6．4．5　Map接口　136
6．4．6　HashMap实现类　136
6．4．7　TreeMap实现类　137
6．4．8　Hashtable实现类　137
6．4．9　Iterator迭代器　137
6．5　文件与流　139
6．5．1　File类　139
6．5．2　字节流　140
6．5．3　字符流　142
6．6　异常处理　145
6．6．1　try catch捕获　145
6．6．2　throw throws抛出　147
6．6．3　自定义异常　147
6．7　代码调试　148
6．7．1　Web调试方式　148
6．7．2　Java调试方式　149
6．8　多线程　150
6．8．1　线程创建　150
6．8．2　线程调度　152
6．8．3　线程同步　152
6．9　监听器　155
6．9．1　实现Listener　155
6．9．2　配置Listener　155
6．9．3　测试Listener　156
6．10　过滤器　157
6．10．1　实现Filter　157
6．10．2　配置Filter　158
6．10．3　测试Filter　159
6．11　反射机制　160
6．11．1　ReflectDemo　160
6．11．2　InvokeDemo　162
6．12　XML　163
6．12．1　创建XML　163
6．12．2　解析XML　164
6．13　WebService　166
6．13．1　实现服务端　167
6．13．2　实现客户端　168
6．14　Ajax传递　169
6．14．1　Ajax是什么　169
6．14．2　Ajax的JavaScript语法　171
6．14．3　Ajax的jQuery语法　174
6．15　JSP内置对象　175
6．15．1　request　175
6．15．2　response　176
6．15．3　session　177
6．15．4　application　179
6．15．5　out　180
6．15．6　pageContext　180
6．15．7　config　181
6．15．8　page　182
6．15．9　exception　183
6．16　Log4j配置　184
6．16．1　配置Log4j　184
6．16．2　配置Logback　186
6．17　小结　188
第7章　数据库　189
7．1　MySQL　189
7．1．1　安装　189
7．1．2　命令　191
7．1．3　profiling　196
7．1．4　SQLyog　198
7．2　Oralce　199
7．2．1　安装　200
7．2．2　命令　202
7．2．3　PLSQL　205
7．3　NoSQL　207
7．3．1　MongoDB　207
7．3．2　Redis　210
7．4　MyBatis　212
7．4．1　MyBatis环境搭建　212
7．4．2　MyBatis配置参数　215
7．5　Hibernate　219
7．5．1　Hibernate环境搭建　219
7．5．2　Hibernate配置参数　222
7．6　函数　222
7．7　游标　223
7．8　存储过程　224
7．9　小结　225
第8章　Struts Spring Hibernate　226
8．1　框架搭建　226
8．1．1　整体规划　226
8．1．2　MVC理念　227
8．2　框架集成　233
8．2．1　Struts 2的集成　233
8．2．2　Spring 3的集成　234
8．2．3　Hibernate的集成　235
8．2．4　前端插件的集成　236
8．3　权限管理　236
8．3．1　业务设计　237
8．3．2　程序设计　238
8．3．3　数据库设计　247
8．4　架构设计　250
8．4．1　逻辑层　250
8．4．2　业务层　255
8．4．3　持久层　256
8．4．4　架构优化　258
8．4．5　架构拓展　259
8．4．6　配置文件　268
8．5　报表导出　282
8．5．1　POI介绍　282
8．5．2　POI导出前端实现　283
8．5．3　POI导出后端实现　284
8．5．4　下载Excel文件　289
8．5．5　CSV介绍　290
8．5．6　CSV导出前端实现　291
8．5．7　CSV导出后端实现　292
8．5．8　下载CSV文件　295
8．5．9　导出功能XML文件配置　297
8．6　加入缓存机制　297
8．6．1　Ehcache的搭建　297
8．6．2　Ehcache的使用　300
8．7　解决并发问题　301
8．7．1　连接池　301
8．7．2　Nginx　302
8．8　小结　306
第9章　Spring MVC　307
9．1　框架搭建　307
9．1．1　整体规划　307
9．1．2　技术选型　308
9．1．3　项目结构　309
9．2　详细设计　309
9．2．1　业务设计　310
9．2．2　原型设计　310
9．2．3　数据库设计　310
9．3　架构设计　311
9．3．1　逻辑层　311
9．3．2　业务层　315
9．3．3　持久层　316
9．3．4　配置文件　323
9．4　POI导入　334
9．4．1　POI导入前端实现　334
9．4．2　POI导入后端实现　336
9．5　小结　342
第　10章 电商平台　343
10．1　框架搭建　343
10．1．1　整体规划　343
10．1．2　技术选型　344
10．2　详细设计　344
10．2．1　业务设计　344
10．2．2　原型设计　344
10．2．3　数据库设计　345
10．3　架构设计　346
10．3．1　逻辑层　346
10．3．2　业务层　348
10．3．3　持久层　349
10．3．4　数据通道　350
10．4　支付接口　352
10．4．1　开发账号　352
10．4．2　支付接口集成　354
10．4．3　支付接口调试　357
10．5　JDBC连接类　361
10．6　小结　364
第　11章 产品思维　365
11．1　何谓产品化　365
11．1．1　三个标准　365
11．1．2　软件服务　366
11．2　软件产品化　368
11．2．1　开发文档　368
11．2．2　产品风格　368
11．2．3　前端框架　369
11．2．4　后端框架　371
11．3　图表项目　372
11．3．1　Bootstrap插件　372
11．3．2　ECharts图表　374
11．4　小结　376
第　12章 项目运维　377
12．1　平台维护　377
12．1．1　系统上线　378
12．1．2　运维报告　380
12．2　SonarQube代码扫描　381
12．2．1　环境搭建　381
12．2．2　PMD模板方式　381
12．2．3　Java自定义规则　386
12．3　Jenkins自动化部署　394
12．3．1　部署介绍　394
12．3．2　搭配使用　394
12．4　数据迁移　397
12．4．1　场景分析　397
12．4．2　ETL工具　397
12．5　小结　399
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java架构师指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>测试驱动开发
第一部分  资金实例
第一章  多币种资金
第二章  变质的对象
第三章  一切均等
第四章  私有性
第五章  法郎在诉说
第六章  再谈一切均等
第七章  苹果和桔子
第八章  制造对象
第九章  我们所处的时代
第十章  有趣的TIMES方法
……
第二部分  xUNIT实例
第十八章  步入xUNIT
第十九章  设置表格
第二十章  后期整理
第二十一章  计数
第二十二章  失败处理
第二十三章  如何组成一组测试
第二十四章  xUNIT回顾
第三部分  测试驱动开发的模式
第二十五章  测试驱动开发模式
第二十六章  不可运行状态模式
第二十七章  测试模式
第二十八章  可运行模式
第二十九章  xUNIT模式
第三十章  设计模式
第三十一章  重构
第三十二章  掌握TDD
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>测试驱动开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE 7权威指南：卷2
译者序
前 言
第一部分 引言
第1章 概述 2
1.1 Java EE 7平台新增特性 3
1.2 Java EE应用模型 3
1.3 分布式多层应用 4
1.3.1 安全 4
1.3.2 Java EE组件 5
1.3.3 Java EE客户端 6
1.3.4 Web组件 7
1.3.5 业务组件 8
1.3.6 企业信息系统层 8
1.4 Java EE容器 9
1.4.1 容器服务 9
1.4.2 容器类型 10
1.5 Web服务支持 11
1.5.1 XML 11
1.5.2 SOAP传输协议 12
1.5.3 WSDL标准格式 12
1.6 Java EE应用装配与部署 12
1.7 开发角色 13
1.7.1 Java EE产品提供商 13
1.7.2 工具提供商 13
1.7.3 应用组件提供商 13
1.7.4 应用装配人员 14
1.7.5 应用部署人员和管理员 14
1.8 Java EE 7 API 14
1.8.1 EJB技术 16
1.8.2 Java servlet技术 17
1.8.3 JSF技术 18
1.8.4 JSP技术 18
1.8.5 JSP标准标记库 19
1.8.6 Java持久化API 19
1.8.7 Java事务API 19
1.8.8 RESTful Web服务Java API 19
1.8.9 托管bean 20
1.8.10 Java EE 的上下文和依赖注入 20
1.8.11 Java的依赖注入 20
1.8.12 bean验证 20
1.8.13 Java消息服务API 20
1.8.14 Java EE连接器架构 21
1.8.15 JavaMail API 21
1.8.16 Java容器授权契约 21
1.8.17 Java容器认证服务提供者接口 21
1.8.18 WebSocket Java API 22
1.8.19 JSON处理Java API 22
1.8.20 Java EE的并发工具 22
1.8.21 Java平台的批处理应用 22
1.9 Java平台标准版7的Java EE 7 API 23
1.9.1 Java数据库互连API 23
1.9.2 Java命名和目录接口API 23
1.9.3 JavaBeans激活框架 24
1.9.4 XML处理Java API 24
1.9.5 Java XML绑定架构 24
1.9.6 XML Web服务Java-API 24
1.9.7 带附件SOAP Java API 25
1.9.8 Java认证和授权服务 25
1.9.9 Java平台的公共注解 25
1.10 GlassFish服务器工具 25
第2章 使用教程示例 27
2.1 必要软件 27
2.1.1 Java EE 7软件开发包 28
2.1.2 Java平台标准版 28
2.1.3 Java EE 7教程组件 28
2.1.4 NetBeans IDE 29
2.1.5 Apache Maven 30
2.2 启动和停止GlassFish服务器 30
2.2.1 使用NetBeans IDE启动GlassFish服务器 30
2.2.2 使用NetBeans IDE停止GlassFish服务器 30
2.2.3 使用命令行启动GlassFish服务器 30
2.2.4 使用命令行停止GlassFish服务器 31
2.3 启动管理控制台 31
2.3.1 使用NetBeans IDE启动管理控制台 31
2.4 启动和停止Java DB服务器 32
2.4.1 使用NetBeans IDE启动数据库服务器 32
2.5 构建示例 32
2.6 教程示例目录结构 32
2.7 教程中的Java EE 7 Maven原型 33
2.7.1 安装教程Maven原型 33
2.8 获取教程最新更新 34
2.8.1 使用NetBeans IDE更新教程 34
2.8.2 使用命令行更新教程 34
2.9 调试Java EE应用 34
2.9.1 使用服务器日志 34
2.9.2 使用调试器 35
第二部分 企业bean
第3章 企业bean 38
3.1 什么是企业bean 38
3.1.1 企业bean的好处 39
3.1.2 何时使用企业bean 39
3.1.3 企业bean类型 39
3.2 什么是会话bean 39
3.2.1 会话bean类型 40
3.2.2 何时使用会话bean 41
3.3 什么是消息驱动bean 41
3.3.1 消息驱动bean与会话bean的区别 41
3.3.2 何时使用消息驱动bean 42
3.4 访问企业bean 42
3.4.1 在客户端使用企业bean 43
3.4.2 确定远程或本地访问 44
3.4.3 本地客户端 45
3.4.4 远程客户端 46
3.4.5 Web服务客户端 47
3.4.6 方法参数和访问 47
3.5 企业bean的内容 48
3.6 企业bean的命名约定 48
3.7 企业bean的生命周期 48
3.7.1 有状态会话bean的生命周期 48
3.7.2 无状态会话bean的生命周期 49
3.7.3 单例会话bean的生命周期 50
3.7.4 消息驱动bean的生命周期 50
3.8 有关企业bean的更多信息 51
第4章 企业bean入门 52
4.1 创建企业bean 52
4.1.1 编写企业bean类 53
4.1.2 创建converter Web客户端 53
4.1.3 运行converter示例 54
4.2 修改Java EE应用 55
4.2.1 修改类文件 55
第5章 运行企业bean示例 56
5.1 cart示例 56
5.1.1 业务接口 57
5.1.2 会话bean类 57
5.1.3 @Remove方法 61
5.1.4 辅助类 61
5.1.5 运行cart示例 61
5.2 一个单例会话bean示例：counter 62
5.2.1 创建一个单例会话bean 63
5.2.2 counter示例的架构 67
5.2.3 运行counter示例 69
5.3 一个Web服务示例：helloservice 69
5.3.1 Web服务端点实现类 69
5.3.2 无状态会话bean实现类 70
5.3.3 运行helloservice示例 71
5.4 使用定时器服务 72
5.4.1 创建基于日历的定时器表达式 72
5.4.2 编程定时器 74
5.4.3 自动定时器 76
5.4.4 取消和保存定时器 76
5.4.5 获得定时器信息 77
5.4.6 事务和定时器 77
5.4.7 timersession示例 77
5.4.8 运行timersession示例 80
5.5 处理异常 81
第6章 使用嵌入式企业bean容器 82
6.1 嵌入式企业bean容器概述 82
6.2 开发嵌入式企业bean应用 82
6.2.1 运行嵌入式应用 83
6.2.2 创建企业bean容器 83
6.2.3 查找会话bean引用 84
6.2.4 关闭企业bean容器 85
6.3 standalone示例应用 85
6.3.1 使用NetBeans IDE运行standalone示例应用 86
6.3.2 使用Maven运行standalone示例应用 87
第7章 在会话bean中使用异步方法调用 88
7.1 异步方法调用 88
7.1.1 创建异步业务方法 88
7.1.2 从企业bean客户端调用异步方法 89
7.2 async示例应用 90
7.2.1 async-war模块的架构 91
7.2.2 运行async示例 92
第三部分 持久化
第8章 Java持久化API介绍 96
8.1 实体 96
8.1.1 实体类的需求 97
8.1.2 实体类中的持久化字段和属性 97
8.1.3 实体的主键 101
8.1.4 实体关系中的多重性 103
8.1.5 实体关系中的方向 103
8.1.6 实体中的可嵌入类 105
8.2 实体继承 106
8.2.1 抽象实体 106
8.2.2 映射超类 106
8.2.3 非实体超类 107
8.2.4 实体继承映射策略 107
8.3 管理实体 109
8.3.1 EntityManager接口 109
8.3.2 持久化单元 113
8.4 查询实体 114
8.5 数据库模式创建 114
8.5.1 配置应用以创建或删除数据库表 115
8.5.2 使用SQL脚本加载数据 116
8.6 有关持久化的更多信息 116
第9章 运行持久化示例 118
9.1 order应用 118
9.1.1 order应用中的实体关系 119
9.1.2 order应用中的主键 121
9.1.3 实体映射到多个数据库表 125
9.1.4 order应用中的层叠操作 125
9.1.5 order应用中的BLOB和CLOB数据库类型 126
9.1.6 order应用中的时态类型 126
9.1.7 管理order应用的实体 127
9.1.8 运行order示例 129
9.2 roster应用 129
9.2.1 roster应用中的关系 130
9.2.2 roster应用中的实体继承 131
9.2.3 roster应用中的Criteria查询 132
9.2.4 roster应用中的自动表生成 134
9.2.5 运行roster示例 135
9.3 address-book应用 136
9.3.1 address-book中的bean验证约束 136
9.3.2 在address-book中为约束指定错误消息 137
9.3.3 验证JSF应用的联系信息输入 138
9.3.4 运行address-book示例 139
第10章 Java持久化查询语言 140
10.1 查询语言术语 140
10.2 使用Java持久化查询语言创建查询 141
10.2.1 查询中的命名参数 142
10.2.2 查询中的位置参数 142
10.3 简化的查询语言语法 142
10.3.1 选择语句 142
10.3.2 更新和删除语句 143
10.4 示例查询 143
10.4.1 简单查询 143
10.4.2 导航到相关实体的查询 144
10.4.3 包含其他条件表达式的查询 146
10.4.4 批处理更新和删除 147
10.5 完整的查询语言语法 148
10.5.1 BNF符号 148
10.5.2 Java持久化查询语言的BNF文法 148
10.5.3 FROM子句 152
10.5.4 路径表达式 157
10.5.5 WHERE子句 158
10.5.6 SELECT子句 165
10.5.7 ORDER BY子句 167
10.5.8 GROUP BY和HAVING子句 167
第11章 使用Criteria API创建查询 168
11.1 Criteria和Metamodel API概述 168
11.2 使用Metamodel API为实体类建模 170
11.2.1 使用元模型类 170
11.3 使用Criteria API和Metamodel API创建基本的类型安全查询 171
11.3.1 创建Criteria查询 171
11.3.2 查询根 172
11.3.3 使用联接查询关系 172
11.3.4 Criteria查询中的路径导航 173
11.3.5 限制Criteria查询结果 173
11.3.6 管理Criteria查询结果 175
11.3.7 执行查询 176
第12章 创建和使用基于字符串的Criteria查询 178
12.1 基于字符串的Criteria API查询概述 178
12.2 创建基于字符串的查询 178
12.3 执行基于字符串的查询 179
第13章 使用锁定控制对实体数据的并发访问 180
13.1 实体锁定和并发概述 180
13.1.1 使用乐观锁定 181
13.2 锁模式 181
13.2.1 设置锁模式 182
13.2.2 使用悲观锁定 183
第14章 用实体图创建获取计划 185
14.1 实体图基础 185
14.1.1 默认实体图 186
14.1.2 在持久化操作中使用实体图 186
14.2 使用命名实体图 187
14.2.1 对实体类应用命名实体图注解 187
14.2.2 从命名实体图获得EntityGraph实例 188
14.3 在查询操作中使用实体图 189
第15章 对Java持久化API应用使用二级缓存 190
15.1 二级缓存概述 190
15.1.1 控制实体是否可以缓存 191
15.2 指定缓存模式设置来提高性能 192
15.2.1 设置缓存获取和存储模式 192
15.2.2 通过编程方式控制二级缓存 194
第四部分 消息传送
第16章 Java消息服务概念 198
16.1 JMS API概述 198
16.1.1 什么是消息传送 198
16.1.2 什么是JMS API 199
16.1.3 何时使用JMS API 199
16.1.4 Java EE平台如何使用JMS API 200
16.2 基本JMS API概念 201
16.2.1 JMS API架构 201
16.2.2 消息传送方式 201
16.2.3 消息使用 203
16.3 JMS API编程模型 204
16.3.1 JMS受管理对象 205
16.3.2 连接 206
16.3.3 会话 206
16.3.4 JMSContext对象 207
16.3.5 JMS消息生产者 208
16.3.6 JMS消息消费者 208
16.3.7 JMS消息 213
16.3.8 JMS队列浏览器 215
16.3.9 JMS异常处理 216
16.4 使用高级JMS特性 216
16.4.1 控制消息确认 217
16.4.2 为发送消息指定选项 218
16.4.3 创建临时目的地 220
16.4.4 使用JMS本地事务 221
16.4.5 异步发送消息 223
16.5 在Java EE应用中使用JMS API 223
16.5.1 为Java EE应用创建资源 223
16.5.2 在企业bean或Web组件中使用资源注入 225
16.5.3 使用Java EE组件生成和同步接收消息 226
16.5.4 使用消息驱动bean异步接收消息 227
16.5.5 管理JTA事务 229
16.6 关于JMS的更多信息 231
第17章 Java消息服务示例 232
17.1 JMS示例概述 233
17.2 编写简单的JMS应用 233
17.2.1 启动JMS提供者 234
17.2.2 创建JMS受管理对象 234
17.2.3 构建所有简单示例 235
17.2.4 发送消息 235
17.2.5 同步接收消息 238
17.2.6 使用消息监听器完成异步消息传送 240
17.2.7 浏览队列中的消息 242
17.2.8 在同一个目的地运行多个消费者 245
17.2.9 确认消息 245
17.3 编写更高级的JMS应用 247
17.3.1 使用持久订阅 247
17.3.2 使用本地事务 249
17.4 编写高性能和可扩展的JMS应用 254
17.4.1 使用共享非持久订阅 254
17.4.2 使用共享持久订阅 256
17.5 使用一个简单Web应用发送和接收消息 257
17.5.1 websimplemessage Facelets页面 257
17.5.2 websimplemessage托管bean 258
17.5.3 运行websimplemessage示例 259
17.6 使用消息驱动bean异步接收消息 261
17.6.1 simplemessage示例概述 261
17.6.2 simplemessage应用客户端 261
17.6.3 simplemessage消息驱动bean类 262
17.6.4 运行simplemessage示例 263
17.7 从会话bean向MDB发送消息 264
17.7.1 为clientsessionmdb示例编写应用组件 265
17.7.2 运行clientsessionmdb示例 267
17.8 使用实体联接两个MDB的消息 268
17.8.1 clientmdbentity示例应用概述 269
17.8.2 为clientmdbentity示例编写应用组件 270
17.8.3 运行clientmdbentity示例 272
17.9 使用NetBeans IDE创建JMS资源 274
17.9.1 使用NetBeans IDE创建JMS资源 274
17.9.2 使用NetBeans IDE删除JMS资源 275
第五部分 安全
第18章 Java EE平台安全介绍 278
18.1 Java EE安全概述 278
18.1.1 简单的应用安全演示 279
18.1.2 安全机制特性 281
18.1.3 应用安全特点 281
18.2 安全机制 282
18.2.1 Java SE安全机制 282
18.2.2 Java EE安全机制 283
18.3 保护容器安全 285
18.3.1 使用注解指定安全信息 285
18.3.2 使用部署描述文件提供声明式安全 285
18.3.3 使用编程式安全 286
18.4 保护GlassFish服务器安全 286
18.5 使用安全域、用户、组和角色 286
18.5.1 什么是安全域、用户、组和角色 287
18.5.2 在GlassFish服务器中管理用户和组 289
18.5.3 建立安全角色 290
18.5.4 角色映射到用户和组 291
18.6 使用SSL建立安全连接 292
18.6.1 验证和配置SSL支持 293
18.7 有关安全的更多信息 293
第19章 Web应用安全入门 295
19.1 Web应用安全概述 295
19.2 保护Web应用安全 296
19.2.1 指定安全约束 297
19.2.2 指定认证机制 300
19.2.3 在部署描述文件中指定认证机制 302
19.2.4 声明安全角色 303
19.3 Web应用使用编程式安全 304
19.3.1 通过编程方式认证用户 304
19.3.2 通过编程方式检查调用者身份 306
19.3.3 编程式安全的示例代码 306
19.3.4 声明和链接角色引用 308
19.4 示例：保护Web应用安全 309
19.4.1 设置系统来运行安全示例 309
19.4.2 hello2-basicauth示例：对servlet使用基本认证 310
19.4.3 hello1-formauth示例：对JSF应用使用基于表单的认证 312
第20章 企业应用安全入门 316
20.1 企业应用的基本安全任务 316
20.2 保护企业bean安全 316
20.2.1 使用声明式安全保护企业bean安全 318
20.2.2 通过编程方式保护企业bean安全 321
20.2.3 传播安全身份（Run-As） 323
20.2.4 部署安全企业bean 324
20.3 示例：保护企业bean安全 324
20.3.1 cart-secure示例：使用声明式安全保护企业bean安全 324
20.3.2 converter-secure示例：使用编程式安全保护企业bean安全 328
第21章 Java EE安全：高级主题 331
21.1 使用数字证书 331
21.1.1 创建服务器证书 332
21.1.2 向证书安全域增加用户 334
21.1.3 为GlassFish服务器使用一个不同的服务器证书 334
21.2 认证机制 335
21.2.1 客户端认证 335
21.2.2 相互认证 335
21.3 使用JDBC安全域完成用户认证 338
21.3.1 配置JDBC认证安全域 339
21.4 保护HTTP资源安全 340
21.5 保护应用客户端安全 343
21.5.1 使用登录模块 343
21.5.2 使用编程式登录 344
21.6 保护企业信息系统应用安全 344
21.6.1 容器托管登录 344
21.6.2 组件托管登录 345
21.6.3 配置资源适配器安全 345
21.6.4 将应用主体映射到EIS主体 346
21.7 使用部署描述文件配置安全 347
21.7.1 在部署描述文件中指定基本认证安全 347
21.7.2 在部署描述文件中指定非默认主体-角色映射 348
21.8 关于高级安全主题的更多信息 348
第六部分 Java EE支持技术
第22章 事务 352
22.1 Java EE应用中的事务 352
22.2 什么是事务 353
22.3 容器托管事务 353
22.3.1 事务属性 354
22.3.2 回滚容器托管事务 357
22.3.3 同步会话bean的实例变量 357
22.3.4 容器托管事务中不允许的方法 358
22.4 bean托管事务 358
22.4.1 JTA事务 358
22.4.2 不提交返回 359
22.4.3 bean托管事务中不允许的方法 359
22.5 事务超时 359
22.5.1 设置事务超时 359
22.6 更新多个数据库 360
22.7 Web组件中的事务 361
22.8 关于事务的更多信息 361
第23章 资源适配器和契约 362
23.1 什么是资源适配器 362
23.1.1 管理契约 363
23.1.2 通用工作上下文契约 364
23.1.3 出站和入站契约 364
23.2 元数据注解 365
23.3 公共客户端接口 366
23.4 对Java EE上下文和依赖注入（CDI）使用资源适配器 367
23.5 关于资源适配器的更多信息 368
第24章 资源适配器示例 369
24.1 trading示例 369
24.1.1 使用出站资源适配器 370
24.1.2 实现出站资源适配器 372
24.1.3 运行trading示例 373
24.2 traffic示例 374
24.2.1 使用入站资源适配器 375
24.2.2 实现入站资源适配器 376
24.2.3 运行traffic示例 378
第25章 使用Java EE拦截器 380
25.1 拦截器概述 380
25.1.1 拦截器类 381
25.1.2 拦截器生命周期 381
25.1.3 拦截器和CDI 381
25.2 使用拦截器 381
25.2.1 拦截方法调用 382
25.2.2 拦截生命周期回调事件 384
25.2.3 拦截超时事件 385
25.2.4 为组件绑定拦截器 386
25.2.5 拦截器排序 387
25.3 interceptor示例应用 388
25.3.1 运行interceptor示例 389
第26章 批处理 390
26.1 批处理介绍 391
26.1.1 批处理作业中的步骤 391
26.1.2 并行处理 392
26.1.3 状态和判定元素 392
26.1.4 批处理框架功能 393
26.2 Java EE中的批处理 394
26.2.1 批处理框架 394
26.2.2 创建批处理应用 394
26.2.3 批处理作业的元素 395
26.2.4 属性和参数 395
26.2.5 作业实例和作业执行 395
26.2.6 批处理和退出状态 395
26.3 简单用例 396
26.3.1 块步骤 397
26.3.2 任务步骤 399
26.4 使用作业规范语言 399
26.4.1 job元素 400
26.4.2 step元素 401
26.4.3 flow元素 406
26.4.4 split元素 406
26.4.5 decision元素 406
26.5 创建批处理工件 407
26.5.1 批处理工件接口 407
26.5.2 批处理工件中的依赖注入 409
26.5.3 从批处理运行时环境使用上下文对象 410
26.6 向批处理运行时环境提交作业 411
26.6.1 开始作业 411
26.6.2 检查作业的状态 411
26.6.3 在应用中调用批处理运行时环境 412
26.7 打包批处理应用 412
26.8 webserverlog示例应用 412
26.8.1 webserverlog示例应用架构 412
26.8.2 运行webserverlog示例应用 418
26.9 phonebilling示例应用 419
26.9.1 phonebilling示例应用架构 419
26.9.2 运行phonebilling示例应用 425
26.10 关于批处理的更多信息 426
第27章 Java EE的并发工具 427
27.1 并发基础 427
27.1.1 线程和进程 428
27.2 并发工具的主要组件 428
27.3 并发和事务 429
27.4 并发和安全 430
27.5 jobs并发示例 430
27.5.1 运行jobs示例 430
27.6 taskcreator并发示例 433
27.6.1 运行taskcreator示例 435
27.7 关于并发工具的更多信息 436
第七部分 案例研究
第28章 Duke书店案例研究示例 438
28.1 Duke书店的设计和架构 438
28.2 Duke书店接口 439
28.2.1 Book Java持久化API实体 439
28.2.2 Duke书店中使用的企业bean 440
28.2.3 Duke书店中使用的Facelets页面和托管bean 440
28.2.4 Duke书店中使用的定制组件和其他定制对象 441
28.2.5 Duke书店中使用的属性文件 442
28.2.6 Duke书店中使用的部署描述文件 443
28.3 运行Duke书店案例研究应用 443
28.3.1 使用NetBeans IDE构建和部署Duke书店 443
28.3.2 使用Maven构建和部署Duke书店 443
28.3.3 运行Duke书店应用 444
第29章 Duke辅导案例研究示例 445
29.1 Duke辅导应用的设计和架构 445
29.2 主界面 447
29.2.1 主界面中使用的Java持久化API实体 447
29.2.2 主界面中使用的企业bean 448
29.2.3 主界面中使用的WebSocket端点 448
29.2.4 主界面中使用的Facelets文件 448
29.2.5 主界面中使用的辅助类 449
29.2.6 属性文件 449
29.2.7 Duke辅导应用中使用的部署描述文件 450
29.3 管理界面 450
29.3.1 管理界面中使用的企业bean 450
29.3.2 管理界面中使用的Facelets文件 451
29.3.3 管理界面中使用的CDI托管bean 451
29.3.4 管理界面中使用的辅助类 451
29.4 运行Duke辅导案例研究应用 452
29.4.1 运行Duke辅导应用 452
第30章 Duke综合案例研究示例 455
30.1 Duke综合应用的设计和架构 456
30.1.1 events工程 458
30.1.2 entities工程 459
30.1.3 dukes-payment工程 461
30.1.4 dukes-resources工程 461
30.1.5 Duke商店工程 461
30.1.6 Duke货运工程 465
30.2 构建和部署Duke综合案例研究应用 467
30.2.1 使用NetBeans IDE构建和部署Duke综合应用 467
30.2.2 使用Maven构建和部署Duke综合应用 467
30.3 运行Duke综合应用 467
30.3.1 注册为Duke商店顾客 468
30.3.2 购买产品 468
30.3.3 批准产品发货 468
30.3.4 创建新产品 469
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE 7权威指南：卷2
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java数据库编程宝典
前言
第一部分 介绍数据库、SQL和JDBC
第1章 关系型数据库
……
第二部分 在两层客户/服务器结构中使用JDBC和SQL
第5章 使用JDBC和SQL创建表
……
第三部分 三层Web站点与JDBC
第11章 构建会员Web站点
……
第四部分 数据库、JDBC和XML
第17章 XML文档对象模型和JDBC
……
第五部分 EJB、数据库和持久性
第20章 EJB
……
第六部分 数据库管理
第24章 用户管理和数据库的安全性
……
附录A SQL语法简明指南
附录B 安装Apache和Tomcat
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java数据库编程宝典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Servlet 开发人员指南
第1章  servlet体系结构和环境
l. l  什么是 servlet
1. 2  使用servlet的原因
l. 3  Servlet API的背景
1. 4  开始时您需要什么
1. 5  什么是 A

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Servlet 开发人员指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Servlets 2.3编程指南
第1章  企业中的servlet
企业应用程序的结构
J2EE容器结构
J2EE Web组件
利用其他的J2EE API使用servlet
Web应用程序中的servl

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Servlets 2.3编程指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web开发实例大全（基础卷）
第1篇  基础篇
第1章  开发环境搭建
1.1  JDK开发工具包
实例001  JDK的下载
实例002  JDK的安装
实例003  设置Java环境变量
实例004  使用命令行工具测试JDK
实例005  在命令行编译Java源码
1.2  Tomcat服务器
实例006  下载Tomcat服务器
实例007  安装Tomcat服务器
实例008  启动Tomcat并测试
实例009  通过Eclipse部署与发布Web应用
实例010  修改Tomcat服务器的端口号
实例011  配置Tomcat的虚拟主机
实例012  在Tomcat下如何手动部署Web应用
实例013  Tomcat如何制定主机访问
实例014  Tomcat如何添加管理员
实例015  Tomcat常用的优化技巧
1.3  Linux系统配置JDK与Tomcat服务器
实例016  在Linux系统下安装配置JDK
实例017  在Linux系统下安装配置Tomcat
第2章  Java语言基础
2.1  基本语法
实例018  输出错误信息与调试信息
实例019  从控制台接收输入字符
实例020  重定向输出流实现程序日志
实例021  自动类型转换与强制类型转换
2.2  运算符
实例022  加密可以这样简单（位运算）
实例023  用三元运算符判断奇数和偶数
实例024  更精确地使用浮点数
实例025  不用乘法运算符实现2×16
实例026  实现两个变量的互换（不借助第3个变量）
2.3  条件语句
实例027  判断某一年是否为闰年
实例028  验证登录信息的合法性
实例029  为新员工分配部门
实例030  用switch语句根据消费金额计算折扣
实例031  判断用户输入月份的季节
2.4  循环控制
实例032  使用while与自增运算符循环遍历数组
实例033  使用for循环输出杨辉三角
实例034  使用嵌套循环在控制台上输出九九乘法表
实例035  用while循环计算1+1/2!+1/3!…1/20!
实例036  用for循环输出空心的菱形
实例037  foreach循环优于for循环
实例038  终止循环体
实例039  循环体的过滤器
实例040  循环的极限
2.5  常用排序
实例041  冒泡排序法
实例042  快速排序法
实例043  选择排序法
实例044  插入排序法
实例045  归并排序法
2.6  算法应用
实例046  算法应用——百钱买百鸡
实例047  算法应用——韩信点兵
实例048  算法应用——斐波那契数列
实例049  算法应用——水仙花数
实例050  算法应用——素数
实例051  算法应用——汉诺塔
第3章  HTML/CSS技术
3.1  页面效果
实例052  统一站内网页风格
实例053  设置超链接文字的样式
实例054  网页换肤
实例055  滚动文字
实例056  制作渐变背景
实例057  CSS控制绝对定位
实例058  CSS控制垂直居中
实例059  CSS实现的图文混排
3.2  表格样式
实例060  只有外边框的表格
实例061  彩色外边框的表格
实例062  单元格的边框变色
实例063  表格外边框具有霓虹灯效果
实例064  控制表格指定外边框不显示
实例065  背景颜色渐变的表格
实例066  表格隔行变色
实例067  表格隔列变色
实例068  鼠标经过表格时，显示提示信息
3.3  鼠标样式
实例069  显示自定义的鼠标形状
实例070  动画光标
3.4  文字及列表样式
实例071  应用删除线样式标记商品特价
实例072  在文字上方标注说明标记
实例073  改变首行文字的样式
实例074  使文字具有下划线效果
实例075  指定图标的列表项
3.5  文字特效
实例076  文字的发光效果
实例077  文字的阴影效果
实例078  文字的渐变阴影效果
实例079  文字的图案填充效果
实例080  文字的探照灯效果
实例081  文字的闪烁效果
实例082  文字的空心效果
实例083  文字的浮雕效果
实例084  文字的阳文效果
实例085  文字的雪雕效果
实例086  文字的火焰效果
实例087  文字的扭曲动画
实例088  输出文字
3.6  图片滤镜特效
实例089  图片的半透明效果
实例090  图片的模糊效果
实例091  图片的渐隐渐现效果
实例092  图片的水波纹效果
实例093  图片的灰度效果
实例094  图片的动态说明文字
第4章  JSP基础与内置对象
4.1  JSP的基本应用
实例095  自定义错误页面
实例096  导入版权信息
实例097  应用Java程序片段动态生成表格
实例098  应用Java程序片段动态生成下拉列表
实例099  同一页面中的多表单提交
实例100  在JSP脚本中插入JavaScript代码
实例101  将页面转发到用户登录页面
4.2  JSP内置对象
实例102  获取表单提交的信息
实例103  获取访问请求参数
实例104  将表单请求提交到本页
实例105  通过request对象进行数据传递
实例106  通过cookie保存并读取用户登录信息
实例107  实现重定向页面
实例108  防止表单在网站外部提交
实例109  通过Application对象实现网站计数器
实例110  记录用户IP地址的计数器
实例111  只对新用户计数的计数器
实例112  统计用户在某一页停留的时间
实例113  应用session对象实现用户登录
实例114  统计用户在站点停留的时间
实例115  判断用户是否在线
实例116  实时统计在线人数
4.3  JSP的自定义标签
实例117  带标签体的自定义标签
实例118  自定义多次执行的循环标签
实例119  自定义显示版权信息标签
实例120  自定义图片浏览标签
实例121  自定义文件下载的标签
实例122  自定义数据查询的标签
实例123  自定义生成随机数的标签
实例124  自定义生成系统菜单的标签
第5章  JavaBean技术
5.1  字符串处理
实例125  小写金额转换成大写金额
实例126  转换输入文本中的回车和空格
实例127  计算字符串的实际长度
实例128  字符串截取
实例129  字符串转换成数组
实例130  数组转换为字符串
实例131  将整型值转换为字符串
实例132  将字符串型转换为整型
实例133  把整型数据格式化为指定长度的字符串
实例134  将长整型的数字分位显示
实例135  过滤输入字符串中的危险字符
实例136  过滤字符串中的空格与NULL值
实例137  获得汉字的拼音简码
5.2  数据验证
实例138  判断字符串是否以指定字符开头
实例139  检查字符串是否包含英文字母
实例140  检查字符串是否包含数字
实例141  判断用户输入的日期是否为当前日期
实例142  判断是否为数字
实例143  判断用户名是否有效
5.3  日期时间处理
实例144  将指定日期字符串转换为Calendar对象
实例145  将Calendar对象转换为日期时间字符串
实例146  获得系统当前时间的字符串格式
实例147  计算出两个日期相差的天数
5.4  输出实用的HTML代码
实例148  输出提示信息的方法
实例149  输出分页导航的方法
实例150  版权信息的生成方法
5.5  窗口与对话框
实例151  弹出提示对话框并重定向网页
实例152  打开指定大小的新窗口
5.6  对数据库操作的JavaBean
实例153  连接数据库的方法
实例154  数据库查询的方法
实例155  带参数的数据查询
实例156  向数据表中插入数据的方法
实例157  数据修改的方法
实例158  数据删除的方法
实例159  数据分页的方法
实例160  对结果集进行分页的方法
实例161  关闭数据库的方法
实例162  数据库事务处理的方法
实例163  调用数据库存储过程的方法
第6章  Servlet技术
6.1  Servlet基础
实例164  动态生成HTML文档
实例165  在Servlet中实现页面转发
实例166  在Servlet中实现页面重定向
实例167  在Servlet中处理表单提交的数据
实例168  在Servlet中向客户端写Cookie信息
实例169  在Servlet中将JavaBean对象传递到JSP页
实例170  在Servlet中获取Web路径和文件真实路径
实例171  在Servlet中访问Web应用的工作目录
6.2  Servlet应用
实例172  记录用户访问次数
实例173  将数据导出到Excel
实例174  利用Servlet生成动态验证码
实例175  避免客户端访问的并发问题
实例176  在Servlet中使用JDBC访问数据库
实例177  利用Servlet访问数据库连接池
实例178  Servlet实现的个人所得税计算器
实例179  利用Servlet实现用户永久登录
第7章  过滤器与监听器技术
7.1  Servlet过滤器
实例180  创建过滤器
实例181  防盗链过滤器
实例182  日志记录过滤器
实例183  字符替换过滤器
实例184  异常捕获过滤器
实例185  验证用户身份Filter过滤器
实例186  字符编码过滤器
实例187  使用过滤器监控网站流量
实例188  防止页面缓存的过滤器
实例189  通过过滤器控制页面输出内容
实例190  使用过滤器自动生成静态页面
实例191  文件上传过滤器
实例192  权限验证过滤器
7.2  监听器的应用
实例193  监听在线用户
实例194  应用监听器使服务器端免登录
第8章  JSTL标签库
8.1  JSTL Core标签库
实例195  利用JSTL标签实现网站计数器
实例196  根据参数请求显示到不同的页面
实例197  利用<c:forTokens>标签遍历字符串
实例198  利用JSTL选取随机数给予不同的提示信息
实例199  利用<c:forEach>标签遍历List集合的元素
实例200  利用JSTL标签导入用户注册协议
8.2  JSTL I18N标签库
实例201  利用JSTL标签设置请求的字符编码
实例202  利用JSTL标签实现国际化
实例203  利用<fmt:setLocale>显示所有地区的数据格式
实例204  利用<fmt:timeZone>显示不同地区的时间
实例205  利用<fmt:formatDate>标签对日期格式化
第9章  JavaScript技术
9.1  数据验证
实例206  通过正则表达式验证日期
实例207  验证输入的日期是否正确
实例208  检查表单元素的值是否为空
实例209  验证是否为数字
实例210  验证E-mail是否正确
实例211  验证电话号码是否正确
实例212  验证手机号码是否正确
实例213  验证字符串是否为汉字
实例214  验证身份证号码是否有效
实例215  验证车牌号码是否有效
实例216  验证网站地址是否有效
实例217  验证数量和金额
实例218  验证字符串是否以指定字符开头
实例219  限制输入字符串的长度
实例220  验证输入字符串是否包含特殊字符
实例221  限制用户不允许输入中文字符
9.2  字符串处理
实例222  小写金额转换为大写金额
实例223  去掉字符串左右空格
实例224  将数字字符串格式化为指定长度
实例225  限制Textarea文本域内容的长度
实例226  将长数字分位显示
实例227  将RGB格式的颜色值转换为十六进制
实例228  从指定URL中提取文件名
9.3  日期时间处理
实例229  计算两个日期相差的天数
实例230  计算两个日期相差的小时数
实例231  计算某一天是星期几
实例232  显示长日期格式的系统时间
实例233  实时显示系统时间
实例234  倒计时
9.4  使用JavaScript控制DOM
实例235  创建节点
实例236  添加节点
实例237  为下拉列表增加选项
实例238  删除下拉列表的选项
实例239  可编辑表格
第10章  Ajax技术
10.1  定时业务
实例240  考试计时并自动提交试卷
实例241  自动保存草稿
10.2  改善用户体验
实例242  检查用户名是否重复
实例243  验证用户登录
实例244  限时竞拍
实例245  带进度条的文件上传
实例246  仿Google Suggest自动完成
实例247  实现无刷新分页
实例248  实时弹出气泡提示窗口
10.3  动态加载数据
实例249  实时显示最新商品及报价
实例250  实时显示聊天内容
实例251  实现快速浏览
实例252  动态多级联下拉列表
第2篇  文件管理篇
第11章  文件基本操作及文件上传下载
11.1  文件的基本操作
实例253  查看文件是否存在
实例254  重命名文件
实例255  复制文件夹
实例256  获取文件信息
实例257  获取驱动器信息
实例258  读取属性文件
实例259  显示指定类型的文件
实例260  查找替换文本文件内容
实例261  对文件夹创建、删除的操作
实例262  设置Windows的文件属性
实例263  访问类路径上的资源文件
实例264  实现永久计数器
实例265  从文本文件中读取注册服务条款
实例266  提取文本文件内容保存到数据库
实例267  将图片文件保存到数据库
实例268  备份数据库文件
实例269  显示数据库中的图片信息
实例270  读取文件路径到数据库
实例271  在数据库中建立磁盘文件索引
实例272  实现文件简单的加密与解密
实例273  从XML文件中读取数据
实例274  对大文件实现分割处理
实例275  将分割后的文件重新合并
实例276  利用StreamTokenizer统计文件的字符数
实例277  序列化与反序列化对象
11.2  无组件的文件上传
实例278  单表单元素上传文件到数据库
实例279  多表单元素上传文件到数据库
实例280  上传文件到服务器
实例281  限制文件大小的文件上传
11.3  通过组件实现文件上传
实例282  使用jspSmartUpload组件实现文件上传
实例283  使用jspSmartUpload组件实现中文名文件上传
实例284  应用jspSmartUpload组件处理文件上传漏洞
实例285  使用commons-fileUpload组件实现文件上传
实例286  通过commons-fileUpload组件获取其他表单元素
实例287  通过commons-fileUpload组件限制上传文件类型
11.4  文件下载
实例288  利用响应输出流实现文件下载
实例289  防止网站文件盗链下载
实例290  隐藏文件下载的真实路径
实例291  应用jspSmartUpload组件实现文件下载
实例292  处理jspSmartUpload组件下载文件名乱码问题
第12章  文件的批量管理
12.1  文件的批量操作
实例293  文件批量重命名
实例294  快速批量移动文件
实例295  删除指定磁盘所有.tmp临时文件
实例296  动态加载磁盘文件
实例297  删除文件夹中所有文件
实例298  创建磁盘索引文件
实例299  快速全盘查找文件
实例300  获取磁盘所有文本文件
实例301  合并多个txt文件
实例302  批量复制指定扩展名的文件
实例303  将某文件夹中的文件进行分类存储
实例304  在指定目录下搜索文件
实例305  网络文件夹备份
12.2  文件的压缩与解压缩
实例306  压缩所有文本文件
实例307  压缩包解压到指定文件夹
实例308  压缩所有子文件夹
实例309  深层文件夹压缩包的释放
实例310  解决压缩包中文乱码
实例311  Apache实现文件解压缩
实例312  解压缩Java对象
实例313  文件压缩为RAR文档
实例314  解压缩RAR压缩包
实例315  文件分卷压缩
实例316  为RAR压缩包添加注释
实例317  获取压缩包详细文件列表
实例318  从RAR压缩包中删除文件
实例319  在压缩文件中查找字符串
实例320  重命名RAR压缩包中的文件
实例321  创建自解压RAR压缩包
实例322  设置RAR压缩包密码
实例323  压缩远程文件夹
实例324  压缩存储网页
12.3  文件的批量上传
实例325  使用jspSmartUpload实现文件批量上传
实例326  使用commons-fileUpload实现文件批量上传
第3篇  图像与多媒体篇
第13章  图像生成
13.1  绘制图形和文本
实例327  绘制直线
实例328  绘制矩形
实例329  绘制正方形
实例330  绘制椭圆
实例331  绘制圆弧
实例332  绘制指定角度的填充扇形
实例333  绘制多边形
实例334  绘制二次曲线
实例335  绘制三次曲线
实例336  绘制文本
实例337  设置文本的字体
实例338  设置文本和图形的颜色
13.2  绘制图案
实例339  绘制五环图案
实例340  绘制艺术图案
实例341  绘制花瓣
实例342  绘制公章
13.3  图形的合并运算
实例343  图形的加运算
实例344  图形的减运算
实例345  图形的交运算
实例346  图形的异或运算
13.4  文字特效
实例347  立体效果的文字
实例348  阴影效果的文字
实例349  倾斜效果的文字
实例350  渐变效果的文字
实例351  水印文字特效
13.5  图片特效
实例352  以椭圆形显示图像
实例353  图片百叶窗特效
实例354  图片马赛克特效
实例355  图片的模糊效果
实例356  图片的锐化效果
实例357  图片的半透明效果
实例358  图片的溶合效果
实例359  光栅图像
13.6  简单的验证码应用
实例360  生成中文验证码
实例361  随机生成数字的验证码
实例362  生成中文、英文和数字混合的验证码
13.7  复杂的验证码应用
实例363  设置验证码的字体颜色
实例364  具有背景颜色的验证码
实例365  随机缩放文字并将文字旋转指定角度的验证码
实例366  随机生成带有干扰线的验证码
实例367  随机生成多条干扰线的验证码
实例368  随机生成关键字验证码
实例369  利用Ajax实现无刷新的彩色验证码
实例370  生成带雪花的验证码
实例371  生成带背景的验证码
13.8  生成条形码
实例372  利用组件生成条形码
第14章  图像操作
14.1  图片的大小
实例373  打开自定义大小的图片
14.2  图片与鼠标相关的操作
实例374  当鼠标经过图片时显示图片
实例375  当鼠标经过图像时给予文字提示
实例376  图片的预装载
实例377  按时间随机变化的网页背景
实例378  左右循环滚动效果的图片
实例379  浮动广告图片
实例380  进度条的显示
实例381  缩小与放大图片的效果
实例382  通过鼠标滚轮放大与缩小图片
实例383  随鼠标移动的图片
实例384  左右拖动图片的效果
实例385  随意拖动图片
实例386  改变图片获取焦点时的状态
实例387  抖动的图片
实例388  鼠标移动放大图片
14.3  图片与时间相关的操作
实例389  定时隐藏图片
实例390  根据时间变换页面背景
实例391  使图片不停闪烁
实例392  上下跳动的图片
实例393  左右晃动的图片
实例394  移动变形的图片
14.4  图片的动画效果
实例395  图片翻转效果
实例396  图片的水波倒影效果
实例397  图片渐隐渐现
实例398  图片的探照灯效果
实例399  雷达扫描式图片效果
实例400  在页面中旋转的图片效果
实例401  改变形状的图片
14.5  选择头像图片
实例402  在列表中选择图片头像
实例403  在弹出的新窗口中选择图片
14.6  图片的其他效果
实例404  页面中播放图片
实例405  导航地图
第15章  多媒体应用
15.1  播放音乐
实例406  为网页设置背景音乐
实例407  随机播放背景音乐
实例408  MIDI音乐选择
实例409  在线连续播放音乐
实例410  同步显示LRC歌词
实例411  把显示后的LRC歌词变换颜色
15.2  插入Flash动画
实例412  插入Flash动画
实例413  插入背景透明的Flash动画
15.3  播放视频
实例414  播放视频文件
实例415  自制视频播放器
实例416  在线播放FLV视频
第4篇  窗体应用篇
第16章  窗口的应用
16.1  弹出窗口控制
实例417  打开网页显示广告信息
实例418  定时关闭广告窗口
实例419  弹出窗口的居中显示
实例420  通过按钮创建窗口
实例421  为弹出的窗口加入关闭按钮
实例422  定时打开窗口
实例423  关闭弹出窗口时刷新父窗口
实例424  关闭窗口时不弹出询问对话框
实例425  弹出窗口的Cookie控制
16.2  弹出网页对话框
实例426  弹出网页模式对话框
实例427  全屏显示网页模式对话框
实例428  实现网页日期选择
实例429  网页拾色器
16.3  窗口的动画效果
实例430  页面自动滚动
实例431  动态显示网页
实例432  指定窗口的扩展大小
实例433  实现空降窗口
实例434  慢慢变大窗口
实例435  移动的窗口
实例436  震颤窗口
实例437  旋转的窗口
16.4  窗口控制
实例438  始终将窗口居上显示
实例439  窗口全屏显示
实例440  自动最大化窗口
实例441  按钮实现最大和最小化
实例442  频道方式的窗口
实例443  根据用户分辨率自动调整窗口
实例444  使窗口背景透明
16.5  框架的应用
实例445  框架集的嵌套
实例446  在网页中应用浮动框架
实例447  创建空白框架
实例448  居中显示框架
16.6  无边框窗口
实例449  全屏显示无边框有滚动条的窗口
实例450  应用CSS实现指定尺寸无边框无滚动条窗口
实例451  应用JavaScript实现指定尺寸无边框无滚动条窗口
第17章  导航条的应用
17.1  水平导航条的应用
实例452  带图标的文字导航条
实例453  Flash导航条
实例454  图片按钮导航条
实例455  导航条的动画效果
实例456  动态改变导航菜单的背景颜色
实例457  不用图片实现质感导航条
实例458  标签页导航条
17.2  下拉菜单式导航条
实例459  二级导航菜单
实例460  半透明背景的下拉菜单
实例461  弹出式下拉菜单
实例462  弹出式悬浮菜单
实例463  应用setTimeout()函数实现展开式导航条
实例464  应用setInterval()函数实现展开式导航条
实例465  用层制作下拉菜单1
实例466  用层制作下拉菜单2
17.3  侧导航条设计
实例467  收缩式导航菜单
实例468  树状导航菜单
实例469  自动隐藏的弹出式菜单
第18章  表单的应用
18.1  文本框/编辑框/隐藏域组件
实例470  获取文本框/编辑框/隐藏域的值
实例471  自动预算
实例472  设置文本框为只读属性
实例473  限制文本域字符个数
实例474  自动选择文本框和编辑框的文字
实例475  按Enter键时自动切换焦点
18.2  下拉列表与菜单的应用
实例476  获取下拉列表、菜单的值
实例477  遍历多选下拉列表
实例478  在下拉列表中进行多选择移除
实例479  将数组中的数据添加到下拉菜单中
实例480  下拉菜单选择所要联机的网站
实例481  多级级联菜单
实例482  分级下拉列表
18.3  单选按钮
实例483  不提交表单获取单选按钮的值
实例484  选中单选按钮后显示其他表单元素
实例485  通过单选按钮控制其他表单元素是否可用
18.4  复选框
实例486  只有一个复选框时控制复选框的全选或反选
18.5  密码域
实例487  让密码域更安全
实例488  不提交表单自动检测密码域是否相同
18.6  表单的应用
实例489  通过JavaScript控制表单的提交与重置
实例490  带记忆功能的表单
实例491  防止表单重复提交
实例492  自动提交表单
实例493  通过for循环获取表单元素的中文名称
实例494  可以提交到不同处理页的表单
第19章  表格的操作
19.1  应用JavaScript操作表格
实例495  动态制作表格
实例496  删除表中的行
实例497  动态生成行或列
实例498  合并单元格
实例499  在表格中添加行及单元格
实例500  删除表中的单元格
实例501  从表格最下面向上删除单元格
实例502  在表格的右侧动态添加列
实例503  从表格的右侧依次删除所有列
实例504  在表格中动态添加行
19.2  对单元格进行控制
实例505  选定表格中的单元格
实例506  可左右移动单元格的信息
实例507  使用键盘使单元格焦点随意移动
实例508  隐藏及显示单元格
实例509  编辑单元格中的文本信息
实例510  单元格外边框加粗
19.3  表格的特殊效果
实例511  闪烁的表格边框
实例512  选中行的变色
实例513  表格中表元内部空白
实例514  表格中表元间隙
实例515  对表格内文字进行对齐
实例516  对表格内信息进行布局
实例517  对表格的大小进行设置
实例518  透明表格
实例519  限制表格的宽度
实例520  表格的标题
实例521  表格的外阴影
实例522  立体表格
实例523  虚线边框表格
实例524  表格作为分割线
实例525  表格向下展开
实例526  表格向右拉伸
第5篇  操作Word、Excel、报表与打印篇
第20章  JSP操作Word
20.1  应用JavaScript导出到Word
实例527  将JSP页面的信息在Word中打开
20.2  应用响应流导出到Word
实例528  将表单数据输出到Word中
实例529  将查询结果输出到Word中
实例530  将页面中的学生表以Word表格保存
20.3  应用POI组件导出到Word
实例531  将数据库中的数据写入到Word中
第21章  JSP操作Excel
21.1  应用JXL组件操作Excel
实例532  创建Excel工作表
实例533  将表单信息导出到Excel
实例534  向Excel工作表中添加数值
实例535  向Excel工作表中添加格式化数值
实例536  向Excel工作表中添加boolean值
实例537  向Excel工作表中添加日期时间
实例538  向Excel工作表中添加格式化日期时间
实例539  设置Excel工作表字体样式
实例540  合并Excel工作表的单元格
实例541  设置Excel工作表的单元格内容水平居中
实例542  设置Excel工作表的行高
实例543  设置Excel工作表的列宽
实例544  设置Excel工作表的单元格内容垂直居中
实例545  设置Excel工作表的单元格内容自动换行
实例546  设置Excel工作表的单元格样式
实例547  向Excel工作表中插入图片
实例548  将数据库数据导出到Excel
实例549  读取Excel中的数据和图片并保存到数据库
实例550  设置Excel工作表简单的打印属性
实例551  设置Excel工作表详细的打印属性
21.2  应用POI组件操作Excel
实例552  创建Excel文档
实例553  在Excel工作表中创建单元格
实例554  向Excel单元格中添加不同类型的数据
实例555  创建指定格式的单元格
实例556  设置单元格内容的水平对齐方式
实例557  设置单元格内容的垂直对齐方式
实例558  合并单元格
实例559  设置单元格的边框样式
实例560  设置字体样式
实例561  向Excel文件中插入图片
实例562  将数据库数据导出到Excel文件
实例563  读取Excel文件的数据到数据库
实例564  设置Excel文件的打印属性
第22章  报表与打印
22.1  Web打印
实例565  利用JavaScript调用IE自身的打印功能
实例566  利用WebBrowser打印
实例567  打印分组报表
22.2  利用Word打印报表
实例568  将页面中的客户列表导出到Word并打印
实例569  利用Word自动打印指定格式的会议记录
实例570  利用Word生成的HTML实现打印
22.3  利用Excel打印报表
实例571  利用Excel打印工作报表
实例572  将页面数据导出到Excel并自动打印
22.4  应用WebBrowser+CSS套打邮寄产品单
实例573  打印汇款单
实例574  打印信封
22.5  打印库存报表
实例575  打印库存明细表
实例576  打印库存盘点报表
实例577  打印库存汇总报表
实例578  打印指定条件的库存报表
22.6  高级报表
实例579  应用iReport+JasperReport生成主从报表
实例580  应用iReport+JasperReport生成分栏报表
第6篇  综合应用篇
第23章  综合应用
23.1  在线投票系统
实例581  禁止重复投票的在线投票系统
实例582  每个IP一个月只能投票一次的投票系统
23.2  用户注册
实例583  带检测用户名的用户注册
实例584  分步用户注册
实例585  通过E-mail激活的用户注册
23.3  论坛
实例586  查看帖子信息
实例587  发表主题信息
实例588  回复主题信息
实例589  删除主题及回复信息
实例590  注销用户
23.4  购物车
实例591  添加至购物车
实例592  查看购物车
实例593  修改商品购买数量及从购物车中移除指定商品
实例594  清空购物车
实例595  收银台结账
23.5  聊天室
实例596  Application形式的聊天室
实例597  带私聊的聊天室
实例598  XML形式的聊天室
23.6  万年历
实例599  简易万年历
实例600  带阴历的万年历
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web开发实例大全（基础卷）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java从入门到精通
目  录
第1篇  基  础  篇
第1章  初识Java	3
视频讲解：20分钟
1.1  Java语言概述	4
1.1.1  Java语言的历史	4
1.1.2  Java语言的现状	4
1.1.3  Java语言的面向对象特性	4
1.2  JDK的下载和安装	6
1.2.1  JDK下载	6
1.2.2  JDK安装	7
1.2.3  配置JDK	9
1.2.4  测试开发环境	11
1.3  第一个Java程序	11
1.4  本章小结	14
第2章  熟悉Eclipse开发工具	15
视频讲解：22分钟
2.1  熟悉Eclipse	16
2.1.1  Eclipse简介	16
2.1.2  Eclipse的下载与安装	16
2.1.3  Eclipse汉化	17
2.1.4  Eclipse工作台	21
2.1.5  透视图与视图	22
2.1.6  菜单栏	23
2.1.7  工具栏	27
2.1.8  “包资源管理器”视图	28
2.1.9  “控制台”视图	28
2.2  使用Eclipse	28
2.2.1  创建Java项目	29
2.2.2  创建Java类文件	29
2.2.3  使用编辑器编写程序代码	30
2.2.4  运行Java程序	32
2.3  程序调试	32
2.4  本章小结	33
第3章  Java语言基础	35
视频讲解：58分钟
3.1  Java程序的基本结构	36
3.2  标识符和关键字	37
3.2.1  标识符	37
3.2.2  关键字	38
3.3  基本数据类型	38
3.3.1  整数类型	39
3.3.2  浮点类型	40
3.3.3  字符类型	42
3.3.4  布尔类型	43
3.4  变量与常量	43
3.4.1  声明变量	44
3.4.2  声明常量	45
3.4.3  变量的有效范围	45
3.5  运算符	47
3.5.1  赋值运算符	47
3.5.2  算术运算符	48
3.5.3  自增和自减运算符	49
3.5.4  比较运算符	49
3.5.5  逻辑运算符	50
3.5.6  位运算符	51
3.5.7  三元运算符	53
3.5.8  运算符优先级	54
3.5.9  范例1：不用其他变量实现两变量互换	55
3.5.10  范例2：判断数字的奇偶性	56
3.6  类型转换	56
3.6.1  自动类型转换	56
3.6.2  强制类型转换	57
3.6.3  范例3：类型转换实战	58
3.7  代码注释和编码规范	59
3.7.1  代码注释	59
3.7.2  编码规范	60
3.8  经典范例	61
3.8.1  经典范例1：判断某一年是否是闰年	61
3.8.2  经典范例2：求球形的体积	61
3.9  本章小结	62
3.10  实战练习	62
第4章  流程控制	63
视频讲解：31分钟
4.1  复合语句	64
4.2  条件语句	65
4.2.1  if条件语句	65
4.2.2  switch多分支语句	69
4.2.3  范例1：验证登录信息的合法性	71
4.2.4  范例2：为新员工分配部门	71
4.3  循环语句	73
4.3.1  while循环语句	73
4.3.2  do…while循环语句	74
4.3.3  for循环语句	75
4.3.4  范例3：使用while循环遍历数组	77
4.3.5  范例4：使用for循环输出九九乘法表	77
4.4  跳转语句	78
4.4.1  break语句	78
4.4.2  continue语句	79
4.4.3  return语句	80
4.4.4  范例5：终止循环体	80
4.4.5  范例6：循环体的过滤器	81
4.5  经典范例	82
4.5.1  经典范例1：使用for循环输出空心的
菱形	82
4.5.2  经典范例2：使用for循环输出杨辉三角	84
4.6  本章小结	84
4.7  实战练习	85
第5章  数组	87
视频讲解：31分钟
5.1  数组概述	88
5.2  一维数组	88
5.2.1  创建一维数组	89
5.2.2  初始化一维数组	90
5.2.3  范例1：求一维数组各元素的和	90
5.2.4  范例2：获取一维数组的最小值	91
5.3  多维数组	92
5.3.1  二维数组	92
5.3.2  三维数组	94
5.3.3  范例3：对矩阵进行转置运算	95
5.3.4  范例4：求方阵的迹	96
5.4  数组的基本操作	96
5.4.1  遍历数组	97
5.4.2  填充替换数组元素	98
5.4.3  对数组进行排序	99
5.4.4  复制数组	100
5.4.5  范例5：对比一维、二维数组所占内存	102
5.4.6  范例6：使用直接插入排序法排序	103
5.5  经典范例	104
5.5.1  经典范例1：使用冒泡排序法排序	104
5.5.2  经典范例2：输出九宫格	105
5.6  本章小结	105
5.7  实战练习	106
第6章  字符串  	107
视频讲解：48分钟
6.1  创建字符串	108
6.2  字符串操作	108
6.2.1  字符串连接	108
6.2.2  获取字符串信息	110
6.2.3  去除字符串中的空格	112
6.2.4  字符串替换	114
6.2.5  判断字符串	115
6.2.6  字母大小写转换	117
6.2.7  字符串分割	118
6.2.8  范例1：根据指定分割符把字符串分行	119
6.2.9  范例2：判断字符串是否是数字格式	120
6.3  格式化字符串	121
6.3.1  格式化方法	121
6.3.2  日期格式化	122
6.3.3  时间格式化	123
6.3.4  日期时间组合格式化	124
6.3.5  常规类型格式化	125
6.3.6  范例3：将金额格式化成大写	126
6.3.7  范例4：将数字格式化成货币格式	128
6.4  正则表达式	128
6.4.1  判断是否符合正则表达式的方法	128
6.4.2  正则表达式的元字符	129
6.4.3  正则表达式的限定符	130
6.4.4  方括号中元字符的含义	131
6.4.5  范例5：验证IP地址的合法性	132
6.4.6  范例6：计算文章中汉字的个数	133
6.5  字符串生成器	134
6.5.1  StringBuilder类	134
6.5.2  StringBuilder类的常用方法	135
6.5.3  范例7：将汉字和字母
转换成Unicode码	138
6.5.4  范例8：去掉字符串中重复的字符	138
6.6  经典范例	139
6.6.1  经典范例1：实现字符串加密	139
6.6.2  经典范例2：验证字符串是否回文	140
6.7  本章小结	141
6.8  实战练习	141
第7章  类和对象	143
视频讲解：46分钟
7.1  面向对象概述	144
7.1.1  什么是对象	144
7.1.2  什么是类	145
7.1.3  面向对象的特点	146
7.2  类	148
7.2.1  类的构造方法	148
7.2.2  类的主方法	149
7.2.3  成员变量	150
7.2.4  成员方法	151
7.2.5  局部变量	152
7.2.6  局部变量的有效范围	152
7.2.7  静态变量、常量和方法	153
7.2.8  权限修饰符	155
7.2.9  this关键字	156
7.2.10  范例1：自定义图书类	157
7.2.11  范例2：温度单位转换工具	158
7.3  对象	158
7.3.1  对象的创建	159
7.3.2  访问对象的属性和行为	160
7.3.3  对象的引用	162
7.3.4  对象的比较	162
7.3.5  对象的销毁	163
7.3.6  范例3：统计图书销量	164
7.3.7  范例4：重新计算对象的哈希码	165
7.4  经典范例	166
7.4.1  经典范例1：汉诺塔问题求解	166
7.4.2  经典范例2：单例模式的应用	167
7.5  本章小结	168
7.6  实战练习	168
第2篇  技  术  篇
第8章  接口、继承与多态	171
视频讲解：18分钟
8.1  接口的使用	172
8.1.1  接口的定义	172
8.1.2  接口的实现	172
8.1.3  范例1：图片的不同格式保存	173
8.1.4  范例2：为汽车增加GPS定位功能	174
8.2  类的继承	175
8.2.1  继承的实现	175
8.2.2  继承中的重写	176
8.2.3  使用super关键字	177
8.2.4  范例3：经理与员工的差异	179
8.2.5  范例4：重写父类中的方法	180
8.3  多态	181
8.3.1  什么是多态	181
8.3.2  范例5：计算几何图形的面积	183
8.3.3  范例6：简单的汽车销售商场	184
8.4  经典范例	185
8.4.1  经典范例1：使用Comparable接口
自定义排序	185
8.4.2  经典范例2：动态设置类的私有域	187
8.5  本章小结	188
8.6  实战练习	188
第9章  类的高级特性	189
视频讲解：34分钟
9.1  抽象类	190
9.2  内部类	192
9.2.1  成员内部类	192
9.2.2  局部内部类	195
9.2.3  匿名内部类	195
9.2.4  静态内部类	197
9.2.5  内部类的继承	198
9.2.6  范例1：局部内部类设置闹钟	198
9.2.7  范例2：静态内部类求极值	199
9.3  Class类与Java反射	200
9.3.1  访问构造方法	201
9.3.2  访问成员变量	204
9.3.3  访问方法	206
9.3.4  范例3：运用反射查看类的成员	209
9.3.5  范例4：动态调用类中方法	210
9.4  经典范例	211
9.4.1  经典范例1：利用反射重写
toString()方法	211
9.4.2  经典范例2：普通内部类的简单应用	212
9.5  本章小结	213
9.6  实战练习	213
第10章  Java集合类	215
视频讲解：45分钟
10.1  集合类概述	216
10.2  集合类接口的常用方法	216
10.2.1  List接口的常用方法	216
10.2.2  Set接口的常用方法	218
10.2.3  Map接口的常用方法	219
10.2.4  范例1：用List集合传递学生信息	220
10.2.5  范例2：Map集合二级联动	222
10.3  集合类接口的实现类	223
10.3.1  List接口的实现类	223
10.3.2  Set接口的实现类	224
10.3.3  Map接口的实现类	226
10.3.4  范例3：for循环遍历ArrayList	227
10.3.5  范例4：用动态数组保存学生姓名	228
10.4  迭代器	229
10.4.1  迭代器的创建和使用	229
10.4.2  范例5：Iterator遍历ArrayList	230
10.4.3  范例6：ListIterator遍历ArrayList	231
10.5  经典范例	232
10.5.1  经典范例1：制作电子词典	232
10.5.2  经典范例2：制作手机电话本	234
10.6  本章小结	235
10.7  实战练习	235
第11章  异常处理	237
视频讲解：49分钟
11.1  异常概述	238
11.2  异常的分类	238
11.2.1  可控式异常	238
11.2.2  运行时异常	240
11.2.3  范例1：算术异常	241
11.2.4  范例2：数组下标越界异常	242
11.3  获取异常信息	243
11.4  处理异常	244
11.4.1  使用try…catch处理异常	244
11.4.2  使用try…catch…finally处理异常	245
11.4.3  使用try…finally处理异常	246
11.5  抛出异常	248
11.5.1  使用throws声明抛出异常	248
11.5.2  使用throw语句抛出异常	250
11.5.3  范例3：方法中抛出异常	251
11.5.4  范例4：方法上抛出异常	251
11.6  自定义异常	252
11.6.1  创建自定义异常类	252
11.6.2  使用自定义异常类	253
11.7  异常的使用原则	254
11.8  经典范例	254
11.8.1  经典范例1：捕获单个异常	254
11.8.2  经典范例2：数据库操作异常	255
11.9  本章小结	256
11.10  实战练习	256
第12章  输入/输出	257
视频讲解：30分钟
12.1  流概述	258
12.2  输入/输出流	258
12.2.1  输入流	258
12.2.2  输出流	260
12.2.3  范例1：显示指定类型的文件	261
12.2.4  范例2：查找替换文本文件内容	262
12.3  File类	263
12.3.1  文件的创建与删除	263
12.3.2  获取文件信息	264
12.3.3  范例3：文件批量重命名	265
12.3.4  范例4：快速批量移动文件	266
12.4  文件输入/输出流	267
12.4.1  FileInputStream与FileOutputStream类	267
12.4.2  FileReader类和FileWriter类	268
12.4.3  范例5：窗体动态加载磁盘文件	270
12.4.4  范例6：删除文件夹中所有文件	272
12.5  带缓存的输入/输出流	272
12.5.1  BufferedInputStream类与
BufferedOutputStream类	272
12.5.2  BufferedReader类与BufferedWriter类	273
12.5.3  范例7：读取属性文件单个属性值	275
12.5.4  范例8：合并多个TXT文件	276
12.6  数据输入/输出流	277
12.7  ZIP压缩输入/输出流	278
12.7.1  压缩文件	278
12.7.2  解压缩ZIP文件	280
12.7.3  范例9：压缩包解压到指定文件夹	281
12.7.4  范例10：压缩所有子文件夹	283
12.8  经典范例	284
12.8.1  经典范例1：简单的投票软件	284
12.8.2  经典范例2：电子通讯录	284
12.9  本章小结	285
12.10  实战练习	286
第13章  Swing程序设计	287
视频讲解：51分钟
13.1  Swing概述	288
13.2  Swing常用窗体	288
13.2.1  JFrame框架窗体	288
13.2.2  JDialog窗体	290
13.2.3  范例1：设置窗体大小	291
13.2.4  范例2：禁止改变窗体的大小	292
13.3  标签组件与图标	292
13.3.1  标签的使用	292
13.3.2  图标的使用	293
13.3.3  范例3：为图片添加说明	295
13.4  常用布局管理器	296
13.4.1  绝对布局	297
13.4.2  流布局管理器	297
13.4.3  边界布局管理器	299
13.4.4  网格布局管理器	300
13.5  常用面板	301
13.5.1  JPanel面板	301
13.5.2  JScrollPane面板	302
13.6  按钮组件	303
13.6.1  提交按钮组件	303
13.6.2  单选按钮组件	304
13.6.3  复选框组件	305
13.7  列表组件	306
13.7.1  下拉列表框组件	306
13.7.2  列表框组件	308
13.8  文本组件	310
13.8.1  文本框组件	310
13.8.2  密码框组件	311
13.8.3  文本域组件	311
13.8.4  范例4：给文本域设置背景图片	312
13.8.5  范例5：给文本区设置背景图片	313
13.9  经典范例	313
13.9.1  经典范例1：设置窗体标题栏图标	313
13.9.2  经典范例2：随机更换窗体背景	314
13.10  本章小结	315
13.11  实战练习	315

第3篇  高  级  篇
第14章  高级事件处理	319
视频讲解：30分钟
14.1  键盘事件	320
14.2  鼠标事件	322
14.3  窗体事件	324
14.3.1  捕获窗体焦点变化事件	324
14.3.2  捕获窗体状态变化事件	325
14.3.3  捕获其他窗体事件	326
14.4  选项事件	328
14.5  表格模型事件	329
14.6  经典范例	332
14.6.1  经典范例1：模拟相机拍摄	332
14.6.2  经典范例2：打地鼠游戏	333
14.7  本章小结	335
14.8  实战练习	335
第15章  多线程	337
视频讲解：41分钟
15.1  线程简介	338
15.2  实现线程的两种方式	338
15.2.1  继承Thread类	339
15.2.2  实现Runnable接口	340
15.2.3  范例1：查看线程的运行状态	342
15.2.4  范例2：查看JVM中的线程名	344
15.3  线程的生命周期	345
15.4  操作线程的方法	346
15.4.1  线程的休眠	347
15.4.2  线程的加入	348
15.4.3  线程的中断	350
15.4.4  线程的礼让	351
15.4.5  范例3：查看和修改线程优先级	351
15.4.6  范例4：休眠当前线程	353
15.5  线程的优先级	354
15.6  线程同步	356
15.6.1  线程安全	356
15.6.2  线程同步机制	357
15.7  线程间的通信	359
15.8  经典范例	361
15.8.1  经典范例1：查看JVM中的线程名	361
15.8.2  经典范例2：查看和修改线程名称	362
15.9  本章小结	364
15.10  实战练习	364
第16章  网络通信	365
视频讲解：33分钟
16.1  网络程序设计基础	366
16.1.1  局域网与因特网	366
16.1.2  网络协议	366
16.1.3  端口和套接字	367
16.1.4  范例1：获得内网的所有IP地址	368
16.1.5  范例2：解析网页中的内容	369
16.2  TCP程序设计基础	370
16.2.1  InetAddress类	371
16.2.2  ServerSocket类	372
16.2.3  TCP网络程序	373
16.2.4  范例3：设置等待连接的超时时间	376
16.2.5  范例4：获得Socket信息	377
16.3  UDP程序设计基础	378
16.3.1  DatagramPacket类	379
16.3.2  DatagramSocket类	379
16.3.3  UDP网络程序	379
16.4  经典范例	383
16.4.1  经典范例1：聊天室服务器端	383
16.4.2  经典范例2：聊天室客户端	385
16.5  本章小结	387
16.6  实战练习	387
第17章  JDBC操作数据库	389
视频讲解：1小时25分钟
17.1  JDBC概述	390
17.1.1  数据库概述	390
17.1.2  JDBC技术	391
17.2  JDBC的常用类和接口	391
17.2.1  DriverManager类	391
17.2.2  Connection接口	392
17.2.3  Statement接口	393
17.2.4  PreparedStatement接口	393
17.2.5  ResultSet接口	393
17.3  通过JDBC操作数据库	394
17.3.1  加载数据库驱动	394
17.3.2  建立连接	395
17.3.3  向数据库添加数据	396
17.3.4  获得查询结果集	397
17.3.5  更改数据库中的数据	398
17.3.6  删除数据库中的数据	399
17.3.7  模糊查询	400
17.3.8  范例1：将复选框内容存到数据库	401
17.3.9  范例2：查询三年二班的学生信息	403
17.4  经典范例	404
17.4.1  经典范例1：管理学生信息	404
17.4.2  经典范例2：权限管理	410
17.5  本章小结	415
17.6  实战练习	415
第18章  Swing高级组件	417
视频讲解：48分钟
18.1  利用JTable类直接创建表格	418
18.1.1  创建表格	418
18.1.2  定制表格	420
18.1.3  操纵表格	423
18.1.4  范例1：列表元素与提示信息	425
18.1.5  范例2：监听列表单击事件	426
18.2  表格模型与表格	427
18.2.1  利用表格模型创建表格	427
18.2.2  维护表格模型	429
18.2.3  范例3：实现自动排序列表	431
18.2.4  范例4：可以预览字体的列表	432
18.3  提供行标题栏的表格	433
18.3.1  提供行标题栏的表格	433
18.3.2  范例5：提供行标题栏的表格	433
18.4  Swing树组件	437
18.4.1  简单的树	437
18.4.2  处理选中节点事件	438
18.4.3  遍历树节点	440
18.4.4  定制树	442
18.4.5  维护树模型	444
18.4.6  处理展开节点事件	446
18.4.7  范例6：为树节点增加提示信息	448
18.4.8  范例7：双击编辑树节点功能	449
18.5  经典范例	450
18.5.1  经典范例1：编写中国省市信息树	450
18.5.2  经典范例2：监听节点的选择事件	451
18.6  本章小结	452
18.7  实战练习	452
第19章  高级布局管理器	453
视频讲解：39分钟
19.1  箱式布局管理器	454
19.2  卡片布局管理器	456
19.3  网格组布局管理器	458
19.4  弹簧布局管理器	464
19.4.1  使用弹簧布局管理器	464
19.4.2  使用弹簧和支柱	467
19.4.3  利用弹簧控制组件大小	468
19.5  经典范例	469
19.5.1  经典范例1：制作圆形布局管理器	469
19.5.2  经典范例2：制作阶梯布局管理器	470
19.6  本章小结	471
19.7  实战练习	471
第20章  AWT绘图技术	473
视频讲解：33分钟
20.1  绘制图形	474
20.1.1  Graphics	474
20.1.2  Graphics2D	476
20.1.3  范例1：绘制指定角度的填充扇形	478
20.1.4  范例2：绘制多边形	478
20.2  绘图颜色与笔画属性	479
20.2.1  设置颜色	479
20.2.2  笔画属性	481
20.2.3  范例3：为图形填充渐变色	482
20.2.4  范例4：设置笔画的粗细	482
20.3  绘制文本	483
20.3.1  设置字体	483
20.3.2  显示文字	484
20.3.3  范例5：设置文本的字体	485
20.3.4  范例6：设置文本的图形和颜色	486
20.4  图片处理	487
20.4.1  绘制图片	487

20.4.2  放大与缩小	488
20.4.3  图片翻转	490
20.4.4  图片旋转	492
20.4.5  图片倾斜	493
20.4.6  范例7：图形的交运算	495
20.4.7  范例8：图形的异或运算	495
20.5  经典范例	496
20.5.1  经典范例1：绘制花瓣	496
20.5.2  经典范例2：绘制艺术图案	497
20.6  本章小结	498
20.7  实战练习	499
第4篇  项  目  篇
第21章  酒店管理系统	503
视频讲解：1小时21分钟
21.1  概述	504
21.2  系统分析	504
21.3  系统设计	504
21.3.1  系统目标	504
21.3.2  系统功能结构	505
21.3.3  系统预览	505
21.3.4  业务流程图	506
21.3.5  文件夹结构设计	507
21.4  数据库设计	508
21.4.1  数据库分析	508
21.4.2  数据库概念设计	508
21.4.3  数据库逻辑结构设计	509
21.4.4  视图设计	509
21.5  公共模块设计	510
21.5.1  编写数据库连接类	510
21.5.2  封装常用的操作数据库的方法	511
21.5.3  自定义表格组件	512
21.5.4  编写利用正则表达式验证数据
合法性的方法	513
21.6  主窗体设计	514
21.7  用户登录窗口设计	516
21.8  开台签单工作区设计	521
21.8.1  开台签单工作区功能概述	521
21.8.2  开台签单工作区技术分析	522
21.8.3  开台签单工作区实现过程	522
21.8.4  单元测试	527
21.9  自动结账工作区设计	528
21.9.1  自动结账工作区功能概述	528
21.9.2  自动结账工作区技术分析	528
21.9.3  自动结账工作区实现过程	529
21.10  结账报表工作区设计	530
21.10.1  结账报表工作区功能概述	530
21.10.2  结账报表工作区技术分析	531
21.10.3  结账报表工作区实现过程	531
21.10.4  单元测试	535
21.11  后台管理工作区设计	536
21.11.1  后台管理工作区功能概述	536
21.11.2  后台管理工作区技术分析	537
21.11.3  后台管理工作区实现过程	537
21.11.4  单元测试	544
21.12  开发技巧与难点分析	544
21.13  使用Visio逆向生成
数据库E-R图	546
21.14  本章小结	548
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java从入门到精通
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式之禅
前 言
第一部分 大旗不挥，谁敢
冲锋—热身篇
第1章 单一职责原则
1.1 我是“牛”类，我可以担任多职吗
1.2 绝杀技，打破你的传统思维
1.3 我单纯，所以我快乐
1.4 最佳实践
第2章 里氏替换原则
2.1 爱恨纠葛的父子关系
2.2 纠纷不断，规则压制
2.3 最佳实践
第3章 依赖倒置原则
3.1 依赖倒置原则的定义
3.2 言而无信，你太需要契约
3.3 依赖的三种写法
3.4 最佳实践
第4章 接口隔离原则
4.1 接口隔离原则的定义
4.2 美女何其多，观点各不同
.4.3 保证接口的纯洁性
4.4 最佳实践
第5章 迪米特法则
5.1 迪米特法则的定义
5.2 我的知识你知道得越少越好
5.3 最佳实践
第6章 开闭原则
6.1 开闭原则的定义
6.2 开闭原则的庐山真面目
6.3 为什么要采用开闭原则
6.4 如何使用开闭原则
6.5 最佳实践
第二部分 我惹了谁—
真刀实枪篇
第7章 单例模式
7.1 我是皇帝我独苗
7.2 单例模式的定义
7.3 单例模式的应用
7.4 单例模式的扩展
7.5 最佳实践
第8章 工厂方法模式
8.1 女娲造人的故事
8.2 工厂方法模式的定义
8.3 工厂方法模式的应用
8.3.1 工厂方法模式的优点
8.3.2 工厂方法模式的使用场景
8.4 工厂方法模式的扩展
8.5 最佳实践
第9章 抽象工厂模式
9.1 女娲的失误
9.2 抽象工厂模式的定义
9.3 抽象工厂模式的应用
9.3.1 抽象工厂模式的优点
9.3.2 抽象工厂模式的缺点
9.3.3 抽象工厂模式的使用场景
9.3.4 抽象工厂模式的注意事项
9.4 最佳实践
第10章 模板方法模式
10.1 辉煌工程—制造悍马
10.2 模板方法模式的定义
10.3 模板方法模式的应用
10.4 模板方法模式的扩展
10.5 最佳实践
第11章 建造者模式
11.1 变化是永恒的
11.2 建造者模式的定义
11.3 建造者模式的应用
11.4 建造者模式的扩展
11.5 最佳实践
第12章 代理模式
12.1 我是游戏至尊
12.2 代理模式的定义
12.3 代理模式的应用
12.3.1 代理模式的优点
12.3.2 代理模式的应用
12.4 代理模式的扩展
12.4.1 普通代理
12.4.2 强制代理
12.4.3 代理是有个性的
12.4.4 虚拟代理
12.4.5 动态代理
12.5 最佳实践
第13章 原型模式
13.1 个性化电子账单
13.2 原型模式的定义
13.3 原型模式的应用
13.3.1 原型模式的优点
13.3.2 原型模式的使用场景
13.4 原型模式的注意事项
13.4.1 构造函数不会被执行
13.4.2 浅拷贝和深拷贝
13.4.3 clone与final两个冤家
13.5 最佳实践
第14章 中介者模式
14.1 进销存管理是这个样子的吗？
14.2 中介者模式的定义
14.3 中介者模式的应用
14.4 中介者模式的实际应用
14.5 最佳实践
第15章 命令模式
15.1 项目经理也难当
15.2 命令模式的定义
15.3 命令模式的应用
15.3.1 命令模式的优点
15.3.2 命令模式的缺点
15.3.3 命令模式的使用场景
15.4 命令模式的扩展
15.4.1 未讲完的故事
15.4.2 反悔问题
15.5 最佳实践
第16章 责任链模式
16.1 古代妇女的枷锁—“三从四德”
16.2 责任链模式的定义
16.3 责任链模式的应用
16.3.1 责任链模式的优点
16.3.2 责任链模式的缺点
16.3.3 责任链模式的注意事项
16.4 最佳实践
第17章 装饰模式
17.1 罪恶的成绩单
17.2 装饰模式的定义
17.3 装饰模式应用
17.3.1 装饰模式的优点
17.3.2 装饰模式的缺点
17.3.3 装饰模式的应用
17.4 最佳实践
第18章 策略模式
18.1 刘备江东娶妻，赵云他容易吗
18.2 策略模式的定义
18.3 策略模式的应用
18.3.1 策略模式的优点
18.3.2 策略模式的缺点
18.3.3 策略模式的应用
18.3.4 策略模式的注意事项
18.4 策略模式的扩展
18.5 最佳实践
第19章 适配器模式
19.1 业务发展—上帝才能控制
19.2 适配器模式的定义
19.3 适配器模式的应用
19.3.1 适配器模式的优点
19.3.2 适配器模式的应用
19.3.3 适配器模式的注意事项
19.4 适配器模式的扩展
19.5 最佳实践
第20章 迭代器模式
20.1 整理项目信息—苦差事
20.2 迭代器模式的定义
20.3 迭代器模式的应用
20.4 最佳实践
第21章 组合模式
21.1 公司的人事架构是这样的吗
21.2 组合模式的定义
21.3 组合模式的应用
21.3.1 组合模式的优点
21.3.2 组合模式的缺点
21.3.3 组合模式的应用
21.3.4 组合模式的注意事项
21.4 组合模式的扩展
21.4.1 真实的组合模式
21.4.2 透明的组合模式
21.4.3 组合模式的遍历
21.5 最佳实践
第22章 观察者模式
22.1 韩非子身边的卧底是谁派来的
22.2 观察者模式的定义
22.3 观察者模式的应用
22.3.1 观察者模式的优点
22.3.2 观察者模式的缺点
22.3.3 观察者模式的应用
22.3.4 观察者模式的注意事项
22.4 观察者模式的扩展
22.4.1 java世界中的观察者模式
22.4.2 项目中真实观察者模式
22.4.3 订阅发布模型
22.5 最佳实践
第23章 门面模式
23.1 我要投递信件
23.2 门面模式的定义
23.3 门面模式的应用
23.3.1 门面模式的优点
23.3.2 门面模式的缺点
23.3.3 门面模式的应用
23.4 门面模式的注意事项
23.4.1 一个子系统可以有多个
门面
23.4.2 门面不参与子系统内的
业务逻辑
23.5 最佳实践
第24章 备忘录模式
24.1 如此追女孩子，你还不乐
24.2 备忘录模式的定义
24.3 备忘录模式的应用
24.3.1 备忘录模式的应用
24.3.2 备忘录模式的注意事项
24.4 备忘录模式的扩展
24.4.1 clone方式的备忘录
24.4.2 多状态的备忘录模式
24.4.3 多备份的备忘录
24.4.4 封装得更好一点
24.5 最佳实践
第25章 访问者模式
25.1 员工的隐私何在？
25.2 访问者模式的定义
25.3 访问者模式的应用
25.3.1 访问者模式的优点
25.3.2 访问者模式的缺点
25.3.3 访问者模式的应用
25.4 访问者模式的扩展
25.4.1 统计功能
25.4.2 多个访问者
25.4.3 双分派
25.5 最佳实践
第26章 状态模式
26.1 城市的纵向发展功臣—电梯
26.2 状态模式的定义
26.3 状态模式的应用
26.3.1 状态模式的优点
26.3.2 状态模式的缺点
26.3.3 状态模式的应用
26.3.4 状态模式的注意事项
26.4 最佳实践
第27章 解释器模式
27.1 四则运算你会吗
27.2 解释器模式的定义
27.3 解释器模式的应用
27.3.1 解释器模式的优点
27.3.2 解释器模式的缺点
27.3.3 解释器模式使用的场景
27.3.4 解释器模式的注意事项
27.4 最佳实践
第28章 享元模式
28.1 内存溢出，司空见惯
28.2 享元模式的定义
28.3 享元模式的应用
28.3.1 享元模式优点和缺点
28.3.2 享元模式的应用
28.4 享元模式的扩展
28.4.1 线程安全的问题
28.4.2 性能平衡
28.5 最佳实践
第29章 桥梁模式
29.1 我有一个梦想……
29.2 桥梁模式的定义
29.3 桥梁模式的应用
29.3.1 桥梁模式的优点
29.3.2 桥梁模式的应用
29.3.3 桥梁模式的注意事项
29.4 最佳实践
第三部分 谁的地盘谁做主—模式pk篇
第30章 创建类模式大pk
30.1 工厂方法模式vs建造者模式
30.1.1 按工厂方法建造超人
30.1.2 按建造者模式建造超人
30.1.3 最佳实践
30.2 抽象工厂模式vs建造者模式
30.2.1 按抽象工厂模式生产车辆
30.2.2 按建造者模式生产车辆
30.2.3 最佳实践
第31章 结构类模式大pk
31.1 代理模式vs装饰模式
31.1.1 代理模式
31.1.2 装饰模式
31.1.3 最佳实践
31.2 装饰模式vs适配器模式
31.2.1 按装饰模式描述丑小鸭
31.2.2 按适配器模式实现丑小鸭
31.2.3 最佳实践
第32章 行为类模式大pk
32.1 命令模式vs策略模式
32.1.1 策略模式实现压缩算法
32.1.2 命令模式实现压缩算法
32.1.3 小结
32.2 策略模式vs状态模式
32.2.1 策略模式实现人生
32.2.2 状态模式实现人生
32.2.3 小结
32.3 观察者模式vs责任链模式
32.3.1 责任链模式实现dns
解析过程
32.3.2 触发链模式实现dns解析过程
32.3.3 小结
第33章 跨战区pk
33.1 策略模式vs桥梁模式
33.1.1 策略模式实现邮件发送
33.1.2 桥梁模式实现邮件发送
33.1.3 最佳实践
33.2 门面模式vs中介者模式
33.2.1 中介者模式实现工资计算
33.2.2 门面模式实现工资计算
33.2.3 最佳实践
33.3 包装模式群pk
33.3.1 代理模式
33.3.2 装饰模式
33.3.3 适配器模式
33.3.4 桥梁模式
33.3.5 最佳实践
第四部分 完美世界—混编模式
第34章 命令模式+责任链模式
34.1 搬移unix的命令
34.2 混编小结
第35章 工厂方法模式+策略模式
35.1 迷你版的交易系统
35.2 混编小结
第36章 观察者模式+中介者模式
36.1 事件触发器的开发
36.2 混编小结
第37章 规格模式
37.1 规格模式的实现
37.2 最佳实践
第38章 mvc框架
38.1 mvc框架的实现
38.1.1 mvc的系统架构
38.1.2 模型管理器
38.1.3 值栈
38.1.4 视图管理器
38.1.5 工具类
38.2 最佳实践
附录：23个设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式之禅
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>用J2EE和UML开发Java企业级应用程序
第1章  企业级软件概述
1. 1  什么是企业级软件
1. 2  企业级软件的演变
1. 3  企业级软件和基于组件的软件
1. 4  小结
第2章  J2EE简介
2.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>用J2EE和UML开发Java企业级应用程序
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件工程--Java语言实现
目 录
译者序
前言
第3版ClassicalandObject－Oriented Software Engineering序言
第一部分 软件过程
第1章 软件工程的范围
1.1历史方面
1.2经济方面
1.3维护方面
1.4规格说明和设计方面
1.5群体编程方面
1.6面向对象的范型
1.7常用术语
本章回顾
进一步阅读
问题
第2章 软件过程及问题
2.1客户、开发人员和用户
2.2需求阶段
2.3规格说明阶段
2.4计划阶段
2.5设计阶段
2.6实现阶段
2.7集成阶段
2.8维护阶段
2.9退役
2.10软件产品中的问题：本质问题和非本质问题
2.10.1复杂性
2.10.2一致性
2.10.3可变性
2.10.4不可见NTG
2.10.5没有银弹吗
本章回顾
进一步阅读
问题
第3章 软件生命周期模型
3.1边做边改模型
3.2瀑布模型
3.3快速原型模型
3.4增量模型
3.5螺旋模型
3.6各种生命周期模型的比较
3.7能力成熟度模型
3.8ISO9000
本章回顾
进一步阅读
问题
第4章 逐步求精、CASE和其他商用工具
4.1逐步求精
4.2成本效益分析
4.3计算机辅助软件工程CASE
4.4CASE的范围
4.5软件版本
4.5.1修订版本
4.5.2变体版本
4.6配置控制
4.6.1产品维护期间的配置控制
4.6.2基线版本
4.6.3产品开发期间的配置控制
4.7构造工具
4.8CASE技术提高了生产力
4.9软件度量
本章回顾
进一步阅读
问题
第5章 测试原理
5.1质量问题
5.1.1软件质量保证
5.1.2管理的独立性
5.2基于非执行的测试
5.2.1走查
5.2.2走查的管理
5.2.3审查
5.2.4审查和走查的比较
5.2.5审查的尺度
5.3基于执行的测试
5.4需要测试些什么
5.4.1实用性
5.4.2可靠性
5.4.3健壮性
5.4.4性能
5.4.5正确性
5.5 测试与正确性证明的比较
5.5.1正确性证明的举例
5.5.2正确性证明的事例研究
5.5.3正确性证明和软件工程
5.6由谁来执行基于执行的测试
5.7何时结束测试
本章回顾
进一步阅读
问题
第6章 对象
6.1什么是模块
6.2内聚性
6.2.1偶然内聚性
6.2.2逻辑内聚性
6.2.3暂时内聚性
6.2.4过程内聚性
6.2.5通信内聚性
6.2.6信息内聚性
6.2.7功能内聚性
6.2.8内聚性举例
6.3耦合
6.3.1内容耦合
6.3.2共用耦合
6.3.3控制耦合
6.3.4特征耦合
6.3.5数据耦合
6.3.6耦合举例
6.4数据封装
6.4.1数据封装和产品开发
6.4.2数据封装和产品维护
6.5抽象数据类型
6.6信息隐藏
6.7对象的概念
6.8多态性和动态联编
6.9对象的内聚性和耦合
6.10重用
6.11重用实例研究
6.11.1Raytheon的导弹系统部
6.11.2东芝软件工厂
6.11.3NASA软件
6.11.4GTEDataServices
6.11.5HP公司
6.12重用和维护
6.13对象和生产率
本章回顾
进一步阅读
问题
第二部分 软件过程的各个阶段
第7章 需求阶段
7.1需求分析技术
7.2快速原型
7.3人的因素
7.4作为一种规格说明技术的快速原型
7.5快速原型的重用
7.6快速原型的其他用途
7.7快速原型的管理意义
7.8有关快速原型的经验
7.9联合式应用设计
7.10需求分析技术的比较
7.11需求阶段的测试
7.12需求阶段的CASE工具
7.13需求阶段的度量
7.14MSG实例研究：需求阶段
7.15MSG实例研究：快速原型
本章回顾
进一步阅读
问题
第8章 规格说明阶段
8.1规格说明文档
8.2非形式化规格说明
8.3结构化系统分析
8.4其他的半形式化技术
8.5实体关系模型
8.6有穷状态机
8.7Petri网
8.8Z
8.8.1电梯问题：Z
8.8.2对Z的分析
8.9其他的形式化技术
8.10规格说明技术的比较
8.11规格说明阶段的测试
8.12规格说明阶段的CASE工具
8.13规格说明阶段的度量
8.14MSG实例研究：结构化系统分析
本章回顾
进一步阅读
问题
第9章 面向对象的分析阶段
9.1面向对象范型与结构化范型的比较
9.2面向对象的分析
9.3电梯问题：面向对象的分析
9.3.1类模型
9.3.2动态建模
9.3.3功能建模
9.4 面向对象的生命周期模型
9.5面向对象分析阶段中的CASE工具
9.6MSG实例研究：面向对象的分析
本章回顾
进一步阅读
问题
第10章 计划阶段
10.1项目开发周期和开发成本估计
10.1.1产品规模的度量
10.1.2成本估计技术
10.1.3中级COCOMO
10.1.4跟踪开发周期和成本估计
10.2软件项目管理计划的组成部分
10.3软件项目管理计划的结构
10.4IEEE软件项目管理计划
10.5测试计划
10.6面向对象项目的规划
10.7培训需求
10.8文档标准
10.9计划阶段的CASE工具
10.10计划阶段的测试
10.11MSG实例研究：计划阶段
本章回顾
进一步阅读
问题
第11章 设计阶段
11.1设计和抽象
11.2面向行为的设计
11.3数据流分析
11.3.1数据流分析的例子
11.3.2扩展
11.4事务分析
11.5面向数据的设计
11.6Jackson系统开发
11.6.1JSD概述
11.6.2为什么要在本章介绍Jackson系统开发
11.6.3电梯问题：Jackson系统开发
11.6.4JSD分析
11.7Jackson、Warnier和Orr的技术
11.8面向对象的设计
11.9详细设计
11.10面向行为的设计、面向数据的设计
和面向对象的设计之比较
11.11与实时系统有关的困难
11.12实时系统设计技术
11.13设计阶段的测试
11.14设计阶段的CASE工具
11.15设计阶段的度量
11.16MSG实例研究：面向对象的设计
本章回顾
进一步阅读
问题
第12章 实现阶段
12.1编程语言的选择
12.2第四代语言
12.3结构化程序设计
12.3.1结构化程序设计的历史
12.3.2为什么goto语句是有害的
12.4良好的编程习惯
12.5编码标准
12.6程序员组的组织
12.7民主制程序员组方法
12.8典型的主席制程序员组方法
12.8.1NewYorkTimes项目
12.8.2典型的主席制程序员组方法的不切实际性
12.9超越主席制程序员组和民主制程序员组的方法
12.10可移植性
12.10.1硬件的不兼容性
12.10.2操作系统的不兼容性
12.10.3数值软件的不兼容性
12.10.4编译器的不兼容性
12.11为什么要支持可移植性
12.12获得可移植性的技术
12.12.1可移植的系统软件
12.12.2可移植的应用软件
12.12.3可移植的数据
12.13模块重用
12.14模块测试事例的选择
12.14.1规格说明测试与代码测试的比较
12.14.2规格说明测试的可行性
12.14.3代码测试的可行性
12.15黑盒模块测试技术
12.15.1等价测试和边界值分析
12.15.2功能测试
12.16玻璃盒模块测试技术
12.16.1结构化测试：语句、分支、路径覆盖
12.16.2复杂性度量
12.17代码走查和审查
12.18模块测试技术的比较
12.19Cleanroom
12.20测试对象
12.21模块测试的管理方面
12.22测试分布式软件
12.23实时软件的测试
12.24实现阶段的CASE工具
12.25MSG实例研究：黑盒测试事例
本章回顾
进一步阅读
问题
第13章 实现和集成阶段
13.1实现和集成
13.1.1自顶向下的实现和集成方法
13.1.2自底而上的实现和集成方法
13.1.3三明治式实现和集成方法
13.1.4面向对象产品的实现和集成方法
13.1.5实现和集成阶段的管理问题
13.2实现和集成阶段的测试
13.3用户图形界面的集成阶段测试
13.4产品测试
13.5验收测试
13.6实现和集成阶段的CASE工具
13.7整个软件过程的CASE工具
13.8基于编程语言的环境
13.9面向结构的环境
13.10工具箱环境
13.11集成环境
13.11.1过程集成
13.11.2工具集成
13.11.3其他形式的集成
13.12商业应用的开发环境
13.13公用工具的基础结构
13.14各类环境的比较
13.15实现和集成阶段的度量
13.16MSG实例研究：实现和集成阶段
本章回顾
进一步阅读
问题
第14章 维护阶段
14.1为什么维护是必须的
14.2维护人员需要什么
14.3维护实例研究
14.4维护管理
14.4.1错误报告
14.4.2授权产品更改
14.4.3确保可维护性
14.4.4反复维护的问题
14.5面向对象的软件维护
14.6开发技能与维护技能之比较
14.7逆向工程
14.8维护阶段的测试
14.9维护阶段的CASE工具
14.10维护阶段的度量
本章回顾
进一步阅读
问题
结束语――JAVA：软件工程的实例研究
第三部分 附 录
附录A 艺术商人OsbertOglesby
附录B 软件工程资源
附录C MSG实例研究：快速原型模型
附录D MSG实例研究：结构化系统分析
附录E MSG实例研究：软件项目管理计划
附录F MSG实例研究：设计
附录G MSG实例研究：黑箱测试用例
附录H MSG实例研究：源代码
参考文献索引

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件工程--Java语言实现
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java课程设计
第一章  记忆测试系统
第二章  计算器
第三章  HANNOI塔
第四章  JPEG图像生成器
第五章  标准化考试系统（单机版）
第六章  标准化考试系统（C/S网络版）
第七章  标准化考试系统（B/S网络版）
第八章  日历记事本
第九章  学籍管理系统
第十章  图书查询系统（B/S网络版）
第十一章  中国象棋打谱系统
第十二章  魔板游戏
第十三章  挖雷游戏
第十四章  网络聊天室（B/S模式）
第十五章  局域网广播系统
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java课程设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 2 Web开发认证学习指南
第1章  Web Client模型
J2EE模型简介
HTML
HTTP
小结
考试要点
关键术语

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 2 Web开发认证学习指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>java web 程序开发入门
略
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>java web 程序开发入门
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>零基础学Java 第4版
前言
第一篇Java语言语法基础--面向过程知识
第1章Java技术概览
1.1Java技术
1.1.1认识Java语言
1.1.2认识Java平台
1.1.3Java语言的功能
1.1.4Java语言的优点
1.1.5Java分布式应用和多线程的特点
1.1.6Java程序的可靠性、安全性
1.1.7Java小程序和应用程序
1.2Windows下的"HelloWorld"应用程序
1.2.1创建应用程序的软件环境
1.2.2创建"HelloWorld"应用程序的步骤
1.3深入探讨"HelloWorld"应用程序
1.3.1注释源代码
1.3.2实现类定义
1.3.3详解main()方法
1.4常见疑难解答
1.4.1环境变量设置错误
1.4.2语法错误
1.4.3语义错误
1.4.4运行时错误
1.4.5初学者如何选择Java参考书
1.5小结
1.6习题
第2章Java开发工具及环境设置
2.1Java开发工具简介
2.1.1下载并安装JDK
2.1.2设定环境变量
2.1.3验证JDK环境是否配置成功
2.2JDK内置工具
2.2.1JDK常用工具
2.2.2JDK常用工具的使用实例
2.2.3Java应用程序的发布工具
2.3一个简单的Java应用程序
2.4一个简单的JavaApplet应用程序
2.4.1编写一个JavaApplet
2.4.2编写承载JavaApplet的HTML文件
2.4.3JavaApplet运行过程
2.5Java程序员的编码规则
2.6常见疑难解答
2.6.1Java文件扩展名是否区分大小写
2.6.2Javacxxx.java顺利通过，但Javaxxx显示"NoClassDefFoundError"
2.6.3导致错误"Exceptioninthreadmainjava.lang.NoSuchMethodError:main"的原因
2.7小结
2.8习题
第3章Java语言中的数据类型与运算符
3.1数制
3.1.1基本概念
3.1.2Java语言中的数制表现形式
3.2数据类型
3.2.1整型
3.2.2字符型
3.2.3浮点型
3.2.4布尔型
3.3变量
3.3.1变量的声明
3.3.2变量的含义
3.3.3变量的分类
3.4变量如何初始化
3.5常量
3.6运算符
3.6.1算术运算符
3.6.2关系运算符
3.6.3逻辑运算符
3.6.4位运算符
3.6.5移位运算符
3.6.6赋值运算符
3.6.7三元运算符
3.6.8逗号运算符
3.6.9转型运算符
3.6.10运算符的优先级别
3.7常见疑难解答
3.7.1如何将十进制转换成二进制
3.7.2转型运算符会引起精度问题，为什么还要使用它
3.8小结
3.9习题
第4章程序设计中的流程控制
4.1编程风格
4.2条件语句
4.2.1简单条件语句
4.2.2最简单的条件语句
4.2.3适应多条件的条件语句
4.2.4嵌套条件语句
4.2.5如何使用条件语句
4.3循环语句
4.3.1for循环语句
4.3.2while循环
4.3.3do…while语句
4.4中断与继续语句
4.4.1中断控制语句
4.4.2继续语句
4.5分支语句
4.6返回语句
4.7常见疑难解答
4.7.1普通循环是使用for语句还是while语句
4.7.2一般的程序可否用分支语句来代替条件语句
4.8小结
4.9习题
第二篇Java语言语法进阶--面向对象知识
第5章数组
5.1数组概念的引入
5.1.1实例的引入
5.1.2数组的概念
5.1.3用实例说明数组的用处
5.2基本数据类型的数组
5.2.1基本类型数组的声明
5.2.2基本类型数组的初始化
5.3由实例引出不同数组种类及其使用
5.3.1认识一维数组
5.3.2由实例引出一维数组及其使用
5.3.3由实例引出二维数组及其使用
5.4多维数组
5.4.1多维数组的声明
5.4.2初始化多维数组
5.4.3使用多维数组
5.5数组的综合实例
5.6常见疑难解答
5.6.1声明数组需要注意什么
5.6.2数组在平时的程序代码中使用是否频繁
5.7小结
5.8习题
第6章字符串的处理
6.1认识字符串
6.1.1代码中的字符串
6.1.2String类和StringBuffer类的比较
6.2字符串处理的类库种类
6.2.1字符串的赋值
6.2.2字符串处理类--String
6.2.3字符串处理的方法
6.2.4缓冲字符串处理类--StringBuffer
6.2.5缓冲字符串StringBuffer类的构造器
6.2.6缓冲字符串的处理
6.2.7缓冲字符串类的特点
6.3用实例演示如何处理字符串
6.4如何格式化输出字符串
6.5常见疑难解答
6.5.1equals和"＝＝"的区别
6.5.2String类为何被定义成final约束
6.5.3char类型如何转换成int类型，int类型如何转换成字符串
6.6小结
6.7习题
第7章类和对象
7.1面向对象开发中的类
7.1.1在Java中类的定义
7.1.2Java中的类与现实世界的类
7.2万事万物皆对象
7.2.1什么是对象
7.2.2操作对象
7.2.3初始化对象
7.2.4对象的成员方法
7.2.5对象的成员变量
7.3对象中访问控制符的重要性
7.3.1什么是访问控制符
7.3.2如何使用访问控制符及其重要性
7.4Java中的基础类
7.4.1Java的数学运算处理类Math
7.4.2测试时间和日期的类Date
7.4.3测试日历的类GregorianCalendar
7.4.4日历处理的实例解析
7.5用实例分析设计一个类的流程
7.5.1如何在现实程序设计中提取一个类
7.5.2设置器和访问器
7.5.3总结
7.6常见疑难解答
7.6.1类在程序语言中起到了什么作用
7.6.2设置器和访问器的作用
7.7小结
7.8习题
第8章重载和包
8.1重载
8.1.1什么是重载
8.1.2用实例来说明重载的意义
8.2包
8.2.1什么是Java中的包
8.2.2如何实现包
8.2.3什么是类路径和默认包
8.2.4包的作用域
8.2.5静态导入
8.3包的注释及嵌入文档
8.3.1如何添加注释
8.3.2类、方法、字段等注释的方法
8.4常见疑难解答
8.4.1包在实际编程中究竟有什么作用
8.4.2一个文件中定义了两个class类是否生成一个.class文件
8.5小结
8.6习题
第9章继承和多态
9.1什么是继承
9.1.1继承的引出
9.1.2继承的概念
9.1.3如何实现继承
9.1.4如何设计继承
9.2构造函数的使用
9.2.1什么是构造函数
9.2.2继承中构造函数的初始化
9.2.3替代父类和本身的方式
9.2.4Java中的单继承性
9.3继承中的覆盖现象
9.4类之间的关系
9.4.1依赖
9.4.2聚合
9.4.3继承
9.5继承层次图
9.6多态
9.6.1多态的产生
9.6.2多态的概念
9.6.3使用多态编写程序
9.6.4覆盖的应用
9.6.5重载与覆盖的实例对比
9.6.6覆盖的多态性
9.6.7传值引用和传址引用
9.7通过实例熟悉多态用法
9.8绑定
9.8.1静态绑定
9.8.2动态绑定
9.9超类
9.9.1什么是超类
9.9.2equals方法的使用
9.9.3通用编程
9.10常见疑难解答
9.10.1Java不支持多继承，如何处理一个类继承多个父类的情况
9.10.2如果出现了带参数的构造函数，可否不在代码中写出来
9.10.3动态和静态编译是什么
9.10.4绑定与多态的联系是什么
9.10.5多态与重载的区别是什么
9.11小结
9.12习题
第10章接口与内部类
10.1接口
10.1.1接口概念的引入
10.1.2接口的声明
10.1.3接口的实现
10.1.4接口的多重实现
10.1.5接口的属性
10.1.6接口的继承
10.2内部类
10.2.1使用内部类来访问对象
10.2.2局部内部类
10.2.3静态内部类
10.2.4匿名内部类
10.3常见疑难解答
10.3.1匿名类如何在程序中使用
10.3.2接口与继承有什么区别
10.4小结
10.5习题
第11章抽象和封装
11.1抽象的概念
11.1.1什么是抽象
11.1.2抽象的综合实例
11.2抽象类
11.2.1什么是抽象类
11.2.2抽象类的实例
11.3抽象与接口的区别
11.4枚举
11.4.1关于枚举的实现原理
11.4.2枚举的简单应用
11.4.3关于枚举的高级特性
11.5反射
11.5.1关于反射的基石--Class类
11.5.2关于反射的基本应用
11.5.3关于反射的高级应用
11.6标注
11.6.1标注的简单使用
11.6.2关于JDK的内置标注
11.7泛型
11.7.1为什么要使用泛型
11.7.2关于泛型的一些特性
11.7.3关于泛型的通配符
11.8类加载器
11.8.1什么是类加载器
11.8.2什么是类加载器的委派模型
11.9动态代理
11.9.1什么是代理
11.9.2关于动态代理基础类
11.9.3关于InvocationHandler接口
11.9.4动态代理类的设计模式
11.10封装的概念
11.10.1一个封装的例子
11.10.2在程序设计中为什么要使用封装
11.10.3在程序设计中设计封装的注意点
11.11结合实例讲述如何设计封装
11.12常见疑难解答
11.12.1抽象类和接口在概念上有什么区别
11.12.2如何从设计理念上看待抽象类和接口
11.12.3封装在现实开发中给程序员带来什么启发
11.12.4封装在实际开发中的应用有哪些
11.13小结
11.14习题
第三篇Java语言编程主题
第12章线程
12.1线程的基本概念
12.1.1进程及其使用环境
12.1.2线程及其使用环境
12.2线程的创建
12.2.1如何创建线程
12.2.2通过实例熟悉如何创建线程
12.2.3线程的状态
12.3线程的使用
12.3.1线程的优先级
12.3.2线程的休眠与唤醒
12.3.3线程让步
12.3.4线程同步
12.3.5同步块
12.3.6同步化方法
12.4实例分析
12.4.1生产者与消费者的程序设计及分析
12.4.2多消费者的程序设计及分析
12.4.3多生产者的程序设计及分析
12.5常见疑难解答
12.5.1Java中线程与线程之间怎么通信
12.5.2什么是进程的死锁和饥饿
12.5.3什么时候会涉及线程程序
12.5.4多线程的死锁问题
12.5.5多线程的缺点
12.6小结
12.7习题
第13章异常的处理与内存的管理
13.1异常的概念
13.1.1异常的分类
13.1.2异常的声明
13.1.3异常的抛出throw
13.2异常的捕获
13.2.1捕获多个异常
13.2.2自定义异常
13.2.3运行期异常
13.2.4执行finally子句
13.2.5finally子句的必要性
13.3内存的管理和回收
13.4常见疑难解答
13.4.1为什么要声明方法抛出异常
13.4.2为什么抛出的异常一定是检查异常
13.5小结
13.6习题
第14章Java输入与输出
14.1输入与输出的重要性
14.2Java重要的输入输出类
14.3文件或目录信息的处理
14.3.1File类常用的操作方法
14.3.2文件处理方法的应用
14.3.3文件和目录的操作
14.4读取数据的媒介之一--流
14.4.1什么是流
14.4.2什么是输入流和输出流
14.4.3字节输入流及输出流
14.4.4使用文件字节输入流读取文件
14.4.5使用文件字节输出流输出文件
14.5多字节数据读取类--Filter类
14.5.1Filter流的概念
14.5.2处理字节类型以外的文件输入
14.5.3处理字节类型以外的文件输出
14.5.4增强的多字节输出流DataOutput
14.5.5增强的多字节输入流DataInput
14.6读取数据的媒介之二--字符流
14.6.1字符流的概念
14.6.2抽象字符输入流Reader类的使用
14.6.3抽象字符输出流Writer类的使用
14.6.4读取带缓存的BufferedReader字符流
14.6.5带缓存的字符输出流BufferedWriter类
14.6.6字符输入流FileReader类和FileWriter类的使用
14.6.7如何用标准输入流System.in来获取数据
14.6.8打印输入流PrintWriter类与PrintStream类的区别
14.6.9随机文件访问RandomAccessFile类
14.7利用对象序列化控制输入输出
14.7.1什么是对象序列化
14.7.2基本数据和对象数据读写ObjectInput接口与ObjectOutput接口
14.7.3对象序列化处理ObjectOutputStream类
14.7.4对象序列化处理ObjectInputStream类
14.8常见疑难解答
14.8.1字节流与字符流的主要区别
14.8.2输入流与输出流如何区分，各有什么作用
14.8.3什么是管道流
14.9小结
14.10习题
第15章Java中对数据的处理
15.1如何将基本数据类型转换为对象
15.1.1为什么要将基本数据转换为对象
15.1.2Wrapper类的构造函数
15.1.3包装类的常用函数
15.1.4基本数据的拆装箱操作
15.2如何处理随机性的数据
15.2.1Random类的基础知识
15.2.2通过实例熟悉Random类的常用方法
15.3如何对数据进行排列、整理
15.3.1Arrays类的常用方法
15.3.2实例分析
15.4常见疑难解答
15.4.1Random类函数在现实生活中有什么用处
15.4.2数组的排列和整理数据在实际应用中有什么用处
15.5小结
15.6习题
第16章数据结构接口
16.1数据结构接口及实现
16.1.1数据结构接口的实质
16.1.2用实例来熟悉数据结构接口的实现
16.2Collection集合接口与Iterator迭代器接口
16.2.1熟悉Collection集合接口
16.2.2List接口和Set接口
16.2.3Map映射接口
16.2.4Iterator迭代器接口
16.2.5通过实例来认识迭代器的实现
16.3常见疑难解答
16.3.1Collection集合接口和Collections集合类的区别
16.3.2ArrayList数组列表类和Vector存储类的区别
16.3.3HashMap散列映射和Hashtable散列表的区别
16.3.4数据结构的种类有哪些
16.3.5List接口和Set接口的区别
16.4小结
16.5习题
第17章Java中的数据结构
17.1链表
17.1.1什么是Java中的链表
17.1.2用程序代码段实现对链表的添加
17.1.3用程序代码段实现对链表的删除
17.2数组列表类
17.2.1什么是数组列表类
17.2.2通过实例熟悉数组列表如何存储数据
17.3散列表
17.3.1什么是散列表
17.3.2通过实例熟悉散列表如何存储数据
17.4散列集
17.4.1什么是散列集
17.4.2通过实例熟悉散列集如何存储数据
17.5树集
17.5.1什么是树集
17.5.2通过实例熟悉树集如何存储数据
17.6映像
17.6.1什么是映像
17.6.2通过实例熟悉映像如何存储数据
17.7常见疑难解答
17.7.1哪些是线程安全的数据结构
17.7.2Vector是什么样的数据结构
17.8小结
17.9习题
第18章XML基础
18.1XML和HTML
18.1.1XML的产生
18.1.2XML与HTML的比较
18.2XML的编辑工具
18.3创建XML文档
18.3.1XML的声明
18.3.2文档类型的声明
18.3.3元素
18.3.4注释
18.3.5处理指令
18.3.6空白处理
18.3.7行尾处理
18.3.8语言标识
18.3.9一个简单的有关XML的实例
18.4关于XML的高级知识
18.4.1什么才是格式良好的XML文档
18.4.2DTD文档的作用
18.4.3DTD的结构
18.4.4几个有关DTD的简单实例
18.5关于XML文档的操作
18.5.1下载Dom4J组件
18.5.2安装和配置Dom4J组件
18.5.3Dom4J组件的简单使用--解析XML文件
18.5.4Dom4J组件的简单使用--创建XML文件
18.6关于XML文档的高级操作
18.6.1下载Sax类库
18.6.2安装和配置Sax组件
18.6.3Sax组件的简单使用--解析XML文件
18.7常见疑难解答
18.7.1XML与HTML的区别
18.7.2XML有哪些显示数据的方式
18.8小结
18.9习题
第19章开发工具的使用
19.1Eclipse简介
19.1.1下载并安装Eclipse
19.1.2Eclipse界面介绍
19.2如何使用Eclipse进行开发
19.2.1如何新建一个Java工程
19.2.2如何新建一个Java类
19.2.3编写代码
19.3如何使用MyEclipse进行开发
19.3.1下载并安装MyEclipse
19.3.2关于MyEclipse的一些常用操作
19.4常见疑难解答
19.4.1Eclipse和UltraEdit两个开发工具的优缺点
19.4.2什么是IDE环境
19.4.3有关Eclipse的编译报错的原因
19.5小结
19.6习题
第20章Swing组件与布局管理器
20.1什么是Swing编程
20.2MVC设计模式基础
20.3简单框架设计及实例
20.3.1创建一个空白的框架
20.3.2创建框架的其他工作
20.4简单图形按钮控件的设计及实例
20.4.1Swing中的按钮控件
20.4.2按钮的模型
20.4.3添加普通按钮
20.4.4添加单选按钮
20.4.5添加复选框
20.4.6ToggleButton按钮
20.5简单文本输入组件的设计及实例
20.5.1文本域
20.5.2密码域
20.5.3文本区域
20.6展示类组件的设计及实例
20.6.1标签组件
20.6.2选择组件
20.6.3菜单组件
20.6.4对话框的种类及用法
20.7复杂布局管理器的种类及用法
20.7.1箱式布局的设计
20.7.2网格组布局的设计
20.7.3流布局的设计
20.7.4边界布局的设计
20.8通过实例熟悉Swing编程
20.9常见疑难解答
20.9.1如何处理菜单的启用和禁用功能
20.9.2如何编写快捷键的程序
20.10小结
20.11习题
第21章JDBC及其应用
21.1数据库基础知识
21.1.1什么是数据库
21.1.2数据库的分类及功能
21.1.3关系数据库的设计
21.1.4数据库设计技巧
21.2JDBC的基础概念
21.2.1JDBC驱动程序的分类
21.2.2利用Java到数据库协议方式连接数据库
21.2.3利用Java到本地API方式连接数据库
21.2.4利用JDBC-ODBC方式连接数据库
21.3关于SQLServer数据库基础操作
21.3.1什么是支持SQL语言的数据库
21.3.2通过SQL语言如何操作数据库
21.3.3安装SQLServer
21.3.4高级SQL类型
21.3.5使用SQL创建数据库
21.4JDBC基本编程
21.4.1如何建立数据库
21.4.2如何操作数据库
21.4.3加载合适的数据库驱动程序
21.5关于JDBC的高级操作
21.5.1什么是事务处理
21.5.2事务处理的过程演练
21.5.3预查询
21.5.4使用JDBC的注意事项
21.6常见疑难解答
21.6.1操作数据库的具体步骤是什么
21.6.2数据库中的视图、图表、缺省值、规则、触发器、存储过程的意义
21.7小结
21.8习题
第22章Applet设计
22.1Applet的基本概念及生命周期
22.2Applet的多媒体处理
22.2.1声音处理
22.2.2图像处理
22.3浏览器与Applet的设计
22.3.1如何将Applet嵌入浏览器
22.3.2如何使用Applet类编程
22.3.3如何用Applet控制浏览器
22.4Applet的安全
22.5一个Applet的综合实例分析
22.6常见疑难解答
22.6.1浏览器如何运行Applet
22.6.2有关Applet无法在IE中显示问题的解答
22.7小结
22.8习题
第23章网络编程基础
23.1网络基础知识
23.2TCP/IP协议和UDP协议
23.2.1IP协议和IP地址
23.2.2TCP协议和端口
23.2.3客户端/服务器通信模型
23.2.4UDP协议
23.3端口与套接字
23.4TCP程序设计基础
23.4.1如何设计TCP程序
23.4.2一个简单的例子
23.5UDP程序设计基础
23.5.1如何设计UDP程序
23.5.2一个简单的例子
23.6如何设计网络程序
23.6.1单向通信综合实例
23.6.2双向通信综合实例
23.7常见疑难解答
23.7.1TCP和UDP的区别
23.7.2什么是TCP/IP协议，分为几层，什么功能
23.8小结
23.9习题
第四篇Java语言程序设计实例与面试题剖析
第24章学校管理系统
24.1开发背景
24.2需求分析
24.3登录界面的设计
24.3.1登录界面的分析
24.3.2登录界面的代码实现
24.3.3登录界面的运行
24.4主菜单界面的设计
24.4.1主菜单界面的分析
24.4.2主菜单界面的代码实现
24.4.3主菜单界面的运行
24.5数据库系统的设计
24.5.1数据库中表的创建
24.5.2数据库中的代码段
24.6学生信息系统界面的设计
24.6.1学生类的设计
24.6.2存储类的设计
24.6.3学生信息系统界面的代码实现
24.7教师信息系统界面的设计
24.7.1教师类的设计
24.7.2存储类的设计
24.7.3教师信息系统界面的代码实现
24.8领导信息系统界面的设计
24.8.1领导类的设计
24.8.2存储类的设计
24.8.3领导信息系统界面的代码实现
24.9小结
第25章面试题
面试题1Java的引用和C++的指针有什么区别
面试题2类和对象有什么区别
面试题3说明private、protected、public和default的区别
面试题4Java可以用非0来代表true吗
面试题5StringBuffer和StringBuilder存在的作用是什么
面试题6二维数组的长度是否固定
面试题7符合什么条件的数据集合可以使用foreach循环
面试题8如何序列化和反序列化一个Java对象
面试题9如何使用Java的线程池
面试题10如何利用反射实例化一个类
面试题11TCP协议的通信特点是什么
面试题12请简述JDBC操作数据库的编程步骤
面试题13如何使用连接池技术
面试题14简述接口和抽象类的区别
面试题15如何理解Java中的装箱和拆箱
面试题16根据代码判断创建的对象个数
面试题17分析循环程序的运行结果
面试题18可以返回最大值的方法
面试题19关于垃圾回收的疑问
面试题20线程问题：找出代码中的错误
面试题21关于ArrayList、Vector、LinkedList的问答题
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>零基础学Java 第4版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java编程指南
前 言
第1章 初识Java
1.1 第一个Java程序
1.1.1 编写Java程序
1.1.2 编译Java程序
1.1.3 运行Java程序
1.2 Java编码规范
1.3 集成开发环境
1.4 小结
习题
第2章 语言基础
2.1 ASCII和Unicode
2.2 分隔符
2.3 基本类型
2.4 变量
2.4.1 Java字母和Java数字
2.4.2 Sun公司的变量命名规范
2.5 常量
2.6 字面量
2.6.1 整数字面量
2.6.2 浮点字面量
2.6.3 布尔字面量
2.6.4 字符字面量
2.7 基本类型转换
2.7.1 扩大转换
2.7.2 缩小转换
2.8 运算符
2.8.1 一元运算符
2.8.2 算术运算符
2.8.3 相等运算符
2.8.4 关系运算符
2.8.5 条件运算符
2.8.6 移位运算符
2.8.7 赋值运算符
2.8.8 整数按位运算符
2.8.9 逻辑运算符
2.8.10 运算符优先级
2.8.11 升级
2.9 注释
2.10 小结
习题
第3章 语句
3.1 Java语句概述
3.2 if语句
3.3 while语句
3.4 do-while语句
3.5 for语句
3.6 break语句
3.7 continue语句
3.8 switch语句
3.9 小结
习题
第4章 对象和类
4.1 什么是Java对象
4.2 Java类
4.2.1 域
4.2.2 方法
4.2.3 UML类图中的类成员
4.3 创建对象
4.4 关键字null
4.5 内存中的对象
4.6 Java包
4.7 封装和存取控制
4.7.1 类访问控制修饰符
4.7.2 类成员访问控制修饰符
4.8 关键字this
4.9 使用其他类
4.10 final变量
4.11 静态成员
4.12 静态final变量
4.13 静态导入
4.14 变量作用域
4.15 方法重载
4.16 传值还是传引用
4.17 加载、连接和初始化
4.17.1 加载
4.17.2 链接
4.17.3 初始化
4.18 对象创建的初始化
4.19 对象的比较
4.20 垃圾回收器
4.21 小结
习题
第5章 核心类
5.1 java.lang.Object
5.2 java.lang.String
5.2.1 比较两个String
5.2.2 字符串字面量
5.2.3 特定字符转义
5.2.4 对String使用switch语句
5.2.5 String类的构造器
5.2.6 String类的方法
5.3 StringBuffer和StringBuilder
5.3.1 StringBuilder类的构造器
5.3.2 StringBuilder类的方法
5.4 基本类型封装
5.4.1 java.lang.Integer
5.4.2 java.lang.Boolean
5.4.3 java.lang.Character
5.5 数组
5.5.1 迭代数组
5.5.2 修改数组大小
5.5.3 将String数组传递给main
5.6 java.lang.Class
5.7 java.lang.System
5.8 java.util.Scanner
5.9 装箱和拆箱
5.10 可变参数
5.11 格式和printf方法
5.12 小结
习题
第6章 继承
6.1 继承概述
6.1.1 关键字extends
6.1.2 is-a关系
6.2 可访问性
6.3 方法覆盖
6.4 调用超类的构造器
6.5 调用超类的隐藏成员
6.6 类型转换
6.7 final类
6.8 关键字instanceof
6.9 小结
习题
第7章 错误处理
7.1 捕捉异常
7.2 没有catch块的try词句
7.3 捕捉多个异常
7.4 try-with-resource语句
7.5 java.lang.Exception类
7.6 从方法抛出异常
7.7 用户自定义异常
7.8 异常处理总结
7.9 小结
习题
第8章 数字和日期
8.1 数字解析
8.2 数字格式化
8.3 用java.text.NumberFormat
进行数字解析
8.4 java.lang.Math类
8.5 java.util.Date类
8.6 java.util.Calendar类
8.7 用DateFormat进行日期解析和格式化
8.7.1 DateFormat
8.7.2 SimpleDateFormat类
8.8 小结
习题
第9章 接口和抽象类
9.1 接口的概念
9.2 从技术上来看的接口
9.2.1 接口中的域
9.2.2 方法
9.3 基类
9.4 抽象类
9.5 小结
习题
第10章 枚举
10.1 枚举概述
10.2 类中的枚举
10.3 java.lang.Enum类
10.4 迭代枚举值
10.5 switch中的枚举
10.6 小结
习题
第11章 集合框架
11.1 集合框架概述
11.2 Collection接口
11.3 List和ArrayList
11.4 用Iterator和for迭代集合
11.5 Set和HashSet
11.6 Queue和LinkedList
11.7 集合转换
11.8 Map和HashMap
11.9 对象的比较和排序
11.9.1 使用java.lang.Comparable
11.9.2 使用Comparable和Comparator
11.10 小结
习题
第12章 泛型
12.1 没有泛型的生活
12.2 泛型类型简介
12.3 使用没有类型参数的泛型类型
12.4 使用通配符
12.5 在方法中使用有界通配符
12.6 编写泛型类型
12.7 小结
习题
第13章 输入 / 输出
13.1 文件系统和路径
13.2 文件和目录的处理与操作
13.2.1 创建和删除文件与目录
13.2.2 检索目录的对象
13.2.3 复制和移动文件
13.2.4 文件的读取和写入
13.3 输入/输出流
13.4 读取二进制数据
13.5 写入二进制数据
13.6 写入文本（字符）
13.6.1 Writer
13.6.2 OutputStreamWriter
13.6.3 PrintWriter
13.7 读取文本（字符）
13.7.1 Reader
13.7.2 InputStreamReader
13.7.3 BufferedReader
13.8 用PrintStream记录日志
13.9 随机访问文件
13.10 对象序列化
13.11 小结
习题
第14章 嵌套类和内部类
14.1 嵌套类概述
14.2 静态嵌套类
14.3 成员内部类
14.4 局部内部类
14.5 匿名内部类
14.6 深入嵌套类和内部类
14.7 小结
习题
第15章 Swing基础
15.1 AWT组件
15.2 有用的AWT类
15.2.1 java.awt.Color
15.2.2 java.awt.Font
15.2.3 java.awt.Point
15.2.4 java.awt.Dimension
15.2.5 java.awt.Rectangle
15.2.6 java.awt.Graphics
15.2.7 java.awt.Toolkit
15.3 基本Swing组件
15.3.1 JFrame
15.3.2 调整大小和定位
15.3.3 扩展JFrame
15.3.4 JComponent
15.3.5 Icon和ImageIcon
15.3.6 JLabel
15.3.7 JButton
15.3.8 JTextField和JPasswordField
15.3.9 JTextArea
15.3.10 JCheckbox
15.3.11 JRadioButton
15.3.12 Jlist
15.3.13 JComboBox
15.3.14 JDialog
15.3.15 JOptionPane
15.3.16 JFileChooser
15.4 小结
习题
第16章 Swing进阶
16.1 布局管理器
16.1.1 BorderLayout
16.1.2 FlowLayout
16.1.3 BoxLayout
16.1.4 GridLayout
16.1.5 不使用LayoutManager
16.2 事件处理
16.2.1 Java事件模型
16.2.2 Swing事件处理
16.2.3 AWT事件API
16.2.4 处理ActionEvent
16.2.5 处理MouseEvent
16.2.6 将监听器写成匿名类
16.2.7 处理JRadioButton的ActionEvent
16.2.8 处理KeyEvent
16.2.9 处理WindowListener
16.3 使用菜单
16.4 界面外观
16.5 快速启动画面
16.6 系统托盘支持
16.7 桌面帮助程序
16.8 小结
习题
第17章 多态
17.1 定义多态
17.2 多态的作用
17.3 绘图应用程序中的多态
17.4 多态和反射
17.5 小结
习题
第18章 注解
18.1 注解概述
18.1.1 注解和注解类型
18.1.2 注解语法
18.1.3 注解接口
18.2 标准注解
18.2.1 Override
18.2.2 Deprecated
18.2.3 SuppressWarnings
18.3 通用注解
18.4 标准元注解
18.4.1 Documented
18.4.2 Inherited
18.4.3 Retention
18.4.4 Target
18.5 定制注解类型
18.5.1 编写自己的定制注解类型
18.5.2 使用定制注解类型
18.5.3 用反射查询注解
18.6 小结
习题
第19章 国际化
19.1 Locales
19.2 国际化应用程序
19.2.1 将文本组件单独放进属性文件
19.2.2 用ResourceBundle读取属性文件
19.3 国际化的Swing应用程序
19.4 小结
习题
第20章 Applet
20.1 Applet简史
20.2 Applet API
20.2.1 Applet类
20.2.2 AppletContext接口
20.2.3 AudioClip接口
20.2.4 AppletStub接口
20.3 安全限制
20.4 编写和部署Applet
20.5 AppletViewer工作原理
20.6 将参数传递给Applet
20.7 SoundPlayerApplet
20.8 JApplet
20.9 JAR文件中的Applet部署
20.10 更快速加载
20.11 小结
习题
第21章 Java网络
21.1 网络概述
21.2 超文本传输协议（HTTP）
21.2.1 HTTP请求
21.2.2 HTTP响应
21.3 java.net.URL
21.3.1 解析URL
21.3.2 读取Web资源
21.4 java.net.URLConnection
21.4.1 读取Web资源
21.4.2 写入Web服务器
21.5 java.net.Socket
21.6 java.net.ServerSocket
21.7 Web服务器应用程序
21.7.1 HttpServer类
21.7.2 Request类
21.7.3 Response类
21.7.4 运行应用程序
21.8 小结
习题
第22章 Java数据库连接
22.1 JDBC简介
22.2 数据访问的四个步骤
22.2.1 加载JDBC驱动程序
22.2.2 获得数据库连接
22.2.3 创建Statement对象
22.2.4 创建ResultSet对象
22.3 关闭JDBC对象
22.4 读取元数据
22.5 SQL Tool示例
22.5.1 准备MySQL
22.5.2 SQL Tool类
22.6 小结
习题
第23章 Java线程
23.1 Java线程简介
23.2 创建线程
23.2.1 扩展线程
23.2.2 实现Runnable
23.3 使用多线程
23.4 线程优先级
23.5 停止线程
23.6 同步
23.6.1 线程冲突
23.6.2 方法同步
23.6.3 块同步
23.7 可见性
23.8 线程协调
23.9 使用Timer
23.10 Swing Timer
23.11 小结
习题
第24章 并发工具
24.1 原子变量
24.2 Executor和ExecutorService
24.3 Callable和Future
24.4 Swing Worker
24.5 锁
习题
第25章 安全
25.1 Java安全概述
25.2 使用安全管理器
25.3 策略文件
25.3.1 keystore
25.3.2 grant
25.4 权限
25.4.1 java.io.FilePermission
25.4.2 java.security.BasicPermission
25.4.3 java.util.Property-Permission
25.4.4 java.net.SocketPermission
25.4.5 java.security.Unresolve-Permission
25.4.6 java.lang.Runtime-Permission
25.4.7 java.awt.AWTPermission
25.4.8 java.net.NetPermission
25.4.9 java.lang.reflect.ReflectPermission
25.4.10 java.io.Serializable-Permission
25.4.11 java.security.Security-Permission
25.4.12 java.security.AllPermission
25.4.13 javax.security.auth.AuthPermission
25.5 使用Policy Tool
25.6 Applet安全
25.7 安全编程
25.8 加密概述
25.8.1 加密/解密
25.8.2 认证
25.8.3 数据完整性
25.8.4 SSL工作原理
25.9 创建证书
25.10 KeyTool程序
25.10.1 生成密钥对
25.10.2 认证
25.10.3 将证书导入密钥库
25.10.4 从密钥库导出证书
25.10.5 列出密钥库条目
25.11 JarSigner工具
25.11.1 签署JAR文件
25.11.2 验证已签署的JAR文件
25.11.3 范例：签署Applet
25.12 Java Cryptography API
25.13 小结
习题
第26章 Java Web应用程序
26.1 Servlet应用程序架构
26.2 Servlet API概述
26.3 Servlet
26.4 编写基本Servlet应用程序
26.4.1 安装Tomcat
26.4.2 编写和编译Servlet类
26.4.3 应用程序的目录结构
26.4.4 调用Servlet
26.5 ServletRequest
26.6 ServletResponse
26.7 ServletConfig
26.8 ServletContext
26.9 GenericServlet
26.10 HTTP Servlet
26.10.1 HttpServlet
26.10.2 HttpServletRequest
26.10.3 HttpServletResponse
26.10.4 编写Http Servlet
26.11 使用部署描述符
26.12 小结
习题
第27章 JavaServer Pages
27.1 JSP概述
27.2 jspInit、jspDestroy以及其他方法
27.3 隐式对象
27.4 JSP语法元素
27.4.1 指令
27.4.2 脚本元素
27.5 处理错误
27.6 小结
习题
第28章 Javadoc
28.1 在Java类中编写文档
28.1.1 @author
28.1.2 {@code}
28.1.3 {@docRoot}
28.1.4 @deprecated
28.1.5 @exception
28.1.6 {@inheritDoc}
28.1.7 {@link}
28.1.8 {@linkplain}
28.1.9 {@literal}
28.1.10 {@param}
28.1.11 @return
28.1.12 @see
28.1.13 @serial
28.1.14 @serialData
28.1.15 @serialField
28.1.16 @since
28.1.17 @throws
28.1.18 {@value}
28.1.19 @version
28.2 Javadoc语法
28.2.1 Javadoc选项
28.2.2 标准doclet选项
28.2.3 生成文档
28.3 小结
习题
第29章 应用程序部署
29.1 JWS 概述
29.2 JNLP文件语法
29.2.1 jnlp元素
29.2.2 information元素
29.2.3 security元素
29.2.4 resources元素
29.2.5 application-desc元素
29.2.6 applet-desc元素
29.3 部署范例
29.4 安全关注
29.5 小结
习题
第30章 反射
30.1 概述
30.2 java.lang.Class
30.3 创建对象
30.4 创建数组
30.5 域操作
30.6 方法操作
30.7 调用方法
30.8 小结
习题
第31章 JavaFX概述
31.1 概述
31.2 安装
31.3 第一个JavaFX应用程序
31.4 Application、Stage和Scene
31.4.1 Application类
31.4.2 Stage类
31.4.3 Scene类
31.5 UI组件
31.6 控件
31.7 Region
31.8 事件处理
31.9 CSS样式
31.10 小结
习题
第32章 使用FXML的JavaFX
32.1 概述
32.2 一个基于FXML的简单应用程序
32.3 用FXML进行事件处理
32.4 小结
习题
第33章 Android编程介绍
33.1 概述
33.2 下载安装Android开发工具
33.3 第一个Android应用程序
33.4 Android清单
33.5 在仿真器上运行应用程序
33.6 应用程序结构
33.7 替换应用程序图标
33.8 日志记录
33.9 调试应用程序
33.10 在实际设备上运行
33.11 更新SDK
33.12 小结
习题
第34章 创建Android应用程序
34.1 概述
34.2 活动的生命周期
34.3 Android UI组件
34.3.1 使用ADT Eclipse UI工具
34.3.2 示例：使用Basic Components
34.4 布局组件
34.5 监听器
34.6 启动另一个活动
34.7 小结
习题
第35 章 更多的Android应用程序
35.1 处理Handler
35.2 MediaRecorder
35.3 异步任务
35.4 小结
习题
附录 A javac
附录 B java
附录 C jar
附录 D NetBeans
附录 E Eclipse
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java编程指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java应用程序设计接口(上册)--核心包
（上册）

前言
简短历史
关于Java丛书
API工作成员
关于Java包
参考资料
类层次图

第一章 java．lang包类
1．1 Boolean类
1．2 character类
1．3 Class类
l．4 ClassLoader类
l．5 Compiler类
1．6 Double类
1．7 Float类
1．8 Integer类
1．9 Long类
1．10 Math类
1．11 Number类
1．12 Object类
l．13 Process类
1．14 Runtlme类
1．15 SecurltyManager类
1．16 String类
l．17 StringBuffer类
1．18 System类
1．19 Thread类
l．20 ThreadGroup类
1．21 Throwable类

接口
1．22 Cloneable类
1．23 Runnable类
1．24 ArithmeticException类
l．25 ArrayIndexOutOfBoundsExecption类
1．26 ArrayStoreException类
l．27 ClassCastException类
1．28 ClassNotFoundException类
l．29 CloneNotSupporedException类
l．30 Exception类
1．31 IllegalAccessException类
1．32 IllegalArgumentExcePtion类
1．33 IllegalMonitorStateException类
1．34 IllegalThreadStateException类
1．35 IndexOutOfBoundsException类
l．36 InstantiationException类
l．37 InterrupedException类
l．38 NegativeArraySizeException类
1．39 NoSuchMethodException类
1．40 NullPointerException类
1．41 NumberFormatException类
l．42 RuntimeException类
l．43 SecurityException类
1．44 StringIndexOutOfBoundsException类

错误
1．45 AbstractMethodError类
1．46 ClassCircularityError类
1．47 ClassFormatError类
1．48 Error类
1．49 IllegalAccessError类
1．50 IncompatibleClassChangeError类
1．51 InstantiationError类
l．52 InternalError类
1．53 LinkageError类
l．54 NoClassDefFoundError类
1．55 NoSuchFieldError类
l．56 NoSuchMethodError类
1．57 OutOfMemoryError类
1．58 StackOverflowError类
l．59 ThreadDeath类
1．60 UnknownError类
l．61 UnsatisfiedLinkError类
l．62 VerifyError类
1．63 VirtualMachineError类

第二章 java・io包类
2．1 BufferedInputStream类
2．2 BufferedOutputStream类
2．3 ByteArrayInputStream类
2．4 ByteArrayOutputStream类
2．5 DataInputStream类
2．6 DataOutputStream类
2．7 File类
2．8 FileDescriptor类
2．9 FileInputStream类
2．10 FileOutputStream类
2．11 FilterInputstream类
2．12 FilterOutputStream类
2．13 InputStream类
2．14 LineNumberInputStream类
2．15 OutputStream类
2．16 PlpedInputStream类
2．17 PipedOutPutStream类
2．18 PrintStream类
2．19 PushbackInputStream类
2．20 RandomAccessFile类
2．21 SequenceInpoutStream类
2．22 StreamTokenizer类
2．23 StringBufferInnutStream类

接口
2．24 DataInput接口
2．25 DataOutput接口
2．26 FilenameFilter接口类
2．27 EOFException类
2．28 FileNotFoundException类
2．29 IOException类
2．30 InterruptedIOException类
2．31 UTFDataFormatException类

第三章 java．util包类
3．1 BitSet类
3．2 Date类
3．3 Dictionary类
3．4 Hashtable类
3．5 Observable类
3．6 Properties类
3．7 Random类
3．8 Stack类
3．9 StringTokenizer类
3．10 Vector类

接口
3．11 Enumeration接口
3．12 Observer接口

异常
3．13 EmptyStackException类
3．14 NoSuchElementException类

第四章 java．net包类
4．1 ContentHandler类
4．2 DatagramPacket类
4．3 DatagramSocket类
4．4 InetAddress类
4．5 ServerSocket类
4．6 Socket类
4．7 SocketImpl类
4．8 URL类
4．9 URLConnection类
4．10 URLEncoder类
4．11 URLStreamHandler类

接口
4．12 ContenthandlerFactory接口
4．13 SocketImplFactory接口
4．14 URLStreamHandlerFactory接口

异常
4．15 MalformedURLException类
4．16 ProtocolException类
4．17 SocketException类
4．18 UnknownHostException类
4．19 UnknownServlceException类







>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java应用程序设计接口(上册)--核心包
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java GUI 程序设计
目录
第一部分 JavaGUI程序设计基础
第1章 JavaGUI程序设计基本原理
1.1 AWT组件类
1.2 其他AWT 类
1.3 组件体系结构
1.3.1 peer的生成
1.3.2 peer的事件处理
1.4 AWT显示机制
1.5 JavaGUI程序结构及示例
1.5.1 例子
1.5.2 程序源代码
1.5.3 程序中用到的类
1.5.4 组件层次
1.5.5 界面显示过程
1.5.6 事件处理
1.6 小结
第2章 AWT组件类及其使用
2.1 使用组件的一般规则
2.1.1 如何向容器中加入组件
2.1.2 Component类的功能
2.1.3 如何改变组件的显示特性和行为
2.2 按钮
2.3 画布
2.4 复选钮
2.5 选择列表
2.6 对话框
2.7 独立窗口
2.8 标签
2.9 列表
2.10 菜单
2.11 底板
2.12 滚动条
2.13 文本区和文本域
2.14 小结
第3章 组件的布局
3.1 布局管理器使用规则
3.1.1 如何选择布局管理器
3.1.2 如何生成一个布局管理器并将它同容器链接
3.1.3 布局管理器的调用
3.2 BorderLayout布局管理器
3.3 CardLayout布局管理器
3.4 FlowLayout布局管理器
3.5 GridLayout布局管理器
3.6 GridBagLayout布局管理器
3.6.1 GridBagLayout布局管理器
3.6.2 指定限制参数
3.6.3 一个applet例子
3.7 生成定制布局管理器
3.8 绝对定位方法
3.9 小结
第二部分 图形和图像处理
第4章 图形处理
4.1 AWT图形支持
4.1.1 Graphics对象
4.1.2 坐标系
4.1.3 repaint（）方法的四种形式
4.2 绘制图形
4.2.1 例1：绘制简单矩形
4.2.2 例2；使用矩形指示选择的区域
4.2.3 例3：图形采样器
4.3 使用文本
4.3.1 绘制文本
4.3.2 获取字体信息：FontMetrics
4.4 小结
第5章 图像处理
5.1 加载图像
5.1.1 使用getImage（）方法
5.1.2 请求并跟踪图像的加载：MediaTracker和ImageObserver
5.1.3 使用MemoryImageSource生成图像
5.2 显示图像
5.3 处理图像
5.3.1 图像过滤器的使用
5.3.2 编写图像过滤器
5.4 小结
第6章 实现动画功能
6.1 生成动画循环
6.1.1 初始化实例变量
6.1.2 动画循环
6.1.3 确保稳定的帧速率
6.1.4 灵活的功能
6.2 图形动画
6.3 消除闪烁
6.3.1 覆盖update（）方法
6.3.2 实现双缓冲区
6.4 在屏幕上移动图像
6.5 动态显示图像序列
6.6 改进图像动画的显示效果和性能
6.6.1 使用MediaTracker加载图像并延迟图像的显示
6.6.2 加速图像加载
6.7 小结
第三部分 高级JavaGUI 程序设计
第7章 高级事件处理
7.1 高级事件处理模型概论
7.1.1 一个简单的例子
7.1.2 一个复杂的例子
7.1.3 处理其他事件类型的例子
7.1.4 使用适配器（Adapters）和内部类（InnerClass）处理事件
7.2 标准AWT事件概述
7.3 动作事件反应器
7.3.1 动作事件方法
7.3.2 处理动作事件的例子
7.3.3 ActionEvent类
7.4 调整事件反应器
7.4.1 调整事件的方法
7.4.2 AdjustmentEvent类
7.5 组件事件反应器
7.5.1 组件事件反应器的方法
7.5.2 处理组件事件的例子
7.5.3 Compon entE vent类
7.6 容器事件反应器
7.6.1 容器事件反应器方法
7.6.2 处理容器事件的例子
7.6.3 ContainerEvent类
7.7 输入焦点事件反应器
7.7.1 输入焦点事件反应器方法
7.7.2 处理输入焦点事件的例子
7.7.3 FocusEvent类
7.8 项事件反应器
7.8.1 项事件方法
7.8.2 ItemEvent类
7.9 键事件反应器
7.9.1 键事件类
7.9.2 处理键事件的例子
7.9.3 KeyEvent类
7.10 鼠标事件反应器
7.10.1 鼠标事件反应器方法
7.10.2 鼠标事件处理的例子
7.10.3 MouseEvent类
7.11 鼠标移动事件反应器
7.12 文本事件反应器
7.12.1 文本事件方法
7.12.2 处理文本事件的例子
7.13 窗口事件反应器
7.14 小结
第8章 JFC－SWing程序设计
8.1 JFC－Swing介绍
8.1.1 IFC、AWT和Swing
8.1.2 Swing包概述
8.1.3 组件层次
8.2 Swing组件的使用
8.2.1 JPanel
8.2.2 Icon
8.2.3 JLabel
8.2.4 JButton
8.2.5 AbstractButton
8.2.6 JCheckBox
8.2.7 JRadioButton
8.2.8 JToggleButton
8.2.9 JText Compon ets
8.2.10 JTextField&JTextArea
8.2.11 JTextPan e
8.2.12 JPasswordField
8.2.13 JScrollBar
8.2.14 JSlider
8.2.15 JProgressBar
8.2.16 JComboBox
8.2.17 JList
8.2.18 Border
8.2.19 JScrollPane
8.2.20 JViewPort
8.2.21 Menu
8.2.22 JSeparator
8.2.23 JPopupMenu
8.2.24 JFrame
8.2.25 JRoo tPane
8.2.26 JLaye redPane
8.2.27 Tooltip
8.2.28 Toolbar
8.2.29 JTabbedPane
8.2.30 JSPlitPane
8.3 Swing布局
8.3.1 BoxLayout布局管理器
8.3.2 Box
8.3.3 Scroll PaneLayout
8.3.4 Viewpo rtLayout
8.4 Swing事件处理
8.4.1 Swing事件对象
8.4.2 Swing事件反应器
8.4.3 Swing事件源
8.5 小结
第9章 其他高级功能
9.1 无鼠标操作
9.1.1 输入焦点的转移
9.1.2 菜单快捷键
9.2 打印
9.2.1 打印API
9.2.2 打印图形现场
9.2.3 分页
9.2.4 打印组件层次
9.2.5 例子
9.3 桌面颜色控制
9.3.1 桌面颜色控制API
9.3.2 颜色范围
9.3.3 例子
9.4 小结

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java GUI 程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java测试驱动开发
第1章　为何要关心测试驱动开发　　1
1.1　为何要使用TDD　　1
1.1.1　理解TDD　　3
1.1.2　红灯?绿灯?重构　　3
1.1.3　速度是关键　　4
1.1.4　TDD并非测试方法　　4
1.2　测试　　5
1.2.1　黑盒测试　　5
1.2.2　白盒测试　　5
1.2.3　质量检查和质量保证的差别　　6
1.2.4　更好的测试　　6
1.3　模拟　　7
1.4　可执行的文档　　7
1.5　无需调试　　9
1.6　小结　　9
第2章　工具、框架和环境　　10
2.1　Git　　10
2.2　虚拟机　　11
2.2.1　Vagrant　　11
2.2.2　Docker　　13
2.3　构建工具　　14
2.4　集成开发环境　　15
2.5　单元测试框架　　16
2.5.1　JUnit　　17
2.5.2　TestNG　　19
2.6　Hamcrest和AssertJ　　21
2.6.1　Hamcrest　　21
2.6.2　AssertJ　　22
2.7　代码覆盖率工具　　23
2.8　模拟框架　　24
2.8.1　Mockito　　26
2.8.2　EasyMock　　28
2.8.3　PowerMock　　29
2.9　用户界面测试　　29
2.9.1　Web测试框架　　30
2.9.2　Selenium　　30
2.9.3　Selenide　　31
2.10　行为驱动开发　　33
2.10.1　JBehave　　33
2.10.2　Cucumber　　35
2.11　小结　　37
第3章　红灯?绿灯?重构——从失败到成功再到完美　　38
3.1　使用Gradle和JUnit搭建环境　　39
3.2  “红灯?绿灯?重构”过程　　41
3.2.1　编写一个测试　　41
3.2.2　运行所有测试并确认最后一个未通过　　41
3.2.3　编写实现代码　　42
3.2.4　运行所有测试　　42
3.2.5　重构　　42
3.2.6　重复　　43
3.3  “井字游戏”的需求　　43
3.4　开发“井字游戏”　　43
3.4.1　需求1　　44
3.4.2　需求2　　49
3.4.3　需求3　　52
3.4.4　需求4　　57
3.5　代码覆盖率　　58
3.6　更多练习　　59
3.7　小结　　60
第4章　单元测试——专注于当下而非过往　　61
4.1　单元测试　　61
4.1.1　何为单元测试　　62
4.1.2　为何要进行单元测试　　62
4.1.3　代码重构　　62
4.1.4　为何不只使用单元测试　　63
4.2　TDD中的单元测试　　64
4.3　TestNG　　64
4.3.1　注解@Test　　64
4.3.2　注解@BeforeSuite、@Be- foreTest、@BeforeGroups、 @After Groups、@AfterTest和@AfterSuite　　65
4.3.3　注解@BeforeClass和@AfterClass　　65
4.3.4　注解@BeforeMethod和@AfterMethod　　66
4.3.5　注解参数@Test(enable = false)　　66
4.3.6　注解参数@Test(expected- Exceptions = SomeClass. class)　　66
4.3.7　TestNG和JUnit差别小结　　66
4.4　“遥控军舰”的需求　　66
4.5　开发“遥控军舰”　　67
4.5.1　创建项目　　67
4.5.2　辅助类　　69
4.5.3　需求1　　69
4.5.4　需求2　　72
4.5.5　需求3　　74
4.5.6　需求4　　75
4.5.7　需求5　　77
4.5.8　需求6　　80
4.6　小结　　81
第5章　设计——难以测试说明设计不佳　　82
5.1　为何要关心设计　　82
5.2　Connect4　　84
5.3　完成Connect4实现后再测试　　85
5.3.1　需求1　　85
5.3.2　需求2　　86
5.3.3　需求3　　87
5.3.4　需求4　　88
5.3.5　需求5　　89
5.3.6　需求6　　89
5.3.7　需求7　　90
5.3.8　需求8　　91
5.4　使用TDD实现Connect4　　92
5.4.1　Hamcrest　　92
5.4.2　需求1　　93
5.4.3　需求2　　93
5.4.4　需求3　　96
5.4.5　需求4　　97
5.4.6　需求5　　99
5.4.7　需求6　　99
5.4.8　需求7　　100
5.4.9　需求8　　101
5.5　小结　　103
第6章　模拟——消除外部依赖　　104
6.1　模拟　　104
6.1.1　为何使用模拟对象　　105
6.1.2　术语　　106
6.1.3　模拟对象　　106
6.2　Mockito　　107
6.3  “井字游戏”第二版的需求　　107
6.4　开发“井字游戏”第二版　　107
6.4.1　需求1　　108
6.4.2　需求2　　118
6.5　集成测试　　124
6.5.1　分离测试　　124
6.5.2　集成测试　　125
6.6　小结　　127
第7章　BDD——与整个团队协作　　128
7.1　不同规范　　128
7.1.1　文档　　129
7.1.2　供程序员使用的文档　　129
7.1.3　供非程序员使用的文档　　130
7.2　行为驱动开发　　130
7.2.1　叙述　　131
7.2.2　场景　　132
7.3　书店应用程序的BDD故事　　133
7.4　JBehave　　136
7.4.1　JBehave运行器　　136
7.4.2　待定步骤　　137
7.4.3　Selenium和Selenide　　138
7.4.4　JBehave步骤　　139
7.4.5　最后的验证　　144
7.5　小结　　146
第8章　重构遗留代码——使其重焕青春　　147
8.1　遗留代码　　147
8.2　编码套路　　156
8.2.1　遗留代码处理套路　　157
8.2.2　描述　　157
8.2.3　技术说明　　157
8.2.4　添加新功能　　157
8.2.5　黑盒测试还是尖峰冲击测试　　157
8.2.6　初步调查　　158
8.2.7　应用遗留代码修改算法　　161
8.2.8　提取并重写调用　　166
8.2.9　消除状态的“基本类型偏执”坏味　　170
8.3　小结　　173
第9章　功能开关——将未完成的功能部署到生成环境　　175
9.1　持续集成、持续交付和持续部署　　175
9.2　功能开关　　177
9.3　功能开关示例　　178
9.3.1　实现fibonacci服务　　181
9.3.2　使用模版引擎　　184
9.4　小结　　187
第10章　综述　　188
10.1　TDD概要　　188
10.2　最佳实践　　189
10.2.1　命名约定　　189
10.2.2　流程　　191
10.2.3　开发实践　　192
10.2.4　工具　　195
10.3　这只是开始　　196
10.4　这并非终点　　196

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java测试驱动开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>VRML与Java编程技术
第1章  VRML简介
第2章  VRML文件
第3章  基本造型
第4章  造型的空间变换
第5章  文本造型的创建
第6章  空间效果设定
第7章  添加声音
第8章  造型的外观控制
第9章  用点线面构造造型
第10章  复杂造型
第11章  纹理映射
第12章  光照效果
……
附录
附录A  节点参考
附录B  类的层次结构
……
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>VRML与Java编程技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java宝典
前言
第1部分 介绍Java
第1章 Java语言概貌
第2章 面向对象的编程和技术
第3章 小应用程序设计基础知识
……
第2部分 开始加速速度
第5章 HelloWorld 应用程序和HelloWorld小应用程序
第6章 扩展、增强、调试和上载
第7章 命令行参数和小应用程序标记属性
……
第3部分 编程元素和技术
第9章 标记、类型和值
第10章 语言基础
第11章 类、接口和包
……
第4部分 抽象窗口工具包
第16章 抽象窗口工具包综述
第17章 图形、字体、颜色和图象
第18章 小部件
……
第5部分 高级Java
第26章 JavaBeans
第27章 联网
第28章 JDBC：Java与数据库连接的API
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java宝典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>直達Java虛擬機器
第1章 走近 Java
1.1 概述
1.2 Java 技術體系
1.3 Java 發展史
1.4 展望 Java 技術的未來
1.4.1 模組化
1.4.2 混合語言
1.4.3 多核心平行
1.4.4 進一步豐富語法
1.4.5 64 位元虛擬機器
1.5  實戰 ：自己編譯 JDK
1.5.1 獲取 JDK 原始碼
1.5.2 系統需求
1.5.3 構建編譯環境
1.5.4 準備依賴項
1.5.5 進行編譯
1.6  本章小結
第2章 Java 記憶體區域與記憶體溢出異常
2.1 概述
2.2 執行時資料區域
2.2.1 程式計數器
2.2.2 Java 虛擬機器堆疊
2.2.3 本地方法堆疊
2.2.4 Java堆
2.2.5 方法區
2.2.6 執行時常數池
2.2.7 直接記憶體
2.3 對象訪問
2.4  實戰：OutOfMemoryError異常
2.4.1 Java 堆溢出
2.4.2 虛擬機器堆疊和本地方法堆疊溢出 .
2.4.3 執行時常數池溢出
2.4.4 方法區溢出
2.4.5 本機直接記憶體溢出
2.5  本章小結
第3章垃圾收集器與記憶體分配策略
3.1  概述
3.2  物件已死？
3.2.1 參考計數演算法
3.2.2 根搜尋演算法
3.2.3 再談參考
3.2.4 生存還是死亡？
3.2.5 回收方法區
3.3  垃圾收集演算法
3.3.1 標記 — 清除演算法
3.3.2 複製演算法
3.3.3 標記 — 整理演算法
3.3.4 分代收集演算法
3.4  垃圾收集器
3.4.1 Serial 收集器
3.4.2 ParNew 收集器
3.4.3 Parallel Scavenge 收集器
3.4.4 Serial Old 收集器
3.4.5 Parallel Old 收集器
3.4.6 CMS 收集器
3.4.7 G1 收集器
3.4.8 垃圾收集器參數總結
3.5 記憶體分配與回收策略
3.5.1 對象優先在 Eden 分配
3.5.2 大物件直接進入老年代
3.5.3 長期存活的物件將進入老年代
3.5.4 動態物件年齡判定
3.5.5 空間分配擔保
3.6  本章小結
第4章 虛擬機器性能監控與故障處理工具
4.1  概述
4.2 JDK 的命令列工具
4.2.1 jps ：虛擬機器進程狀況工具
4.2.2 jstat ：虛擬機器統計資訊監視工具
4.2.3 jinfo ：Java 設定資訊工具
4.2.4 jmap ：Java 記憶體對應工具
4.2.5 jhat ：虛擬機器堆轉儲存快照分析工具
4.2.6 jstack ：Java 堆疊跟蹤工具
4.3  JDK 的視覺化工具
4.3.1 JConsole ：Java 監視與管理主控台
4.3.2 VisualVM ：多合一故障處理工具
4.4  本章小結
第5章 調教優化案例分析與實戰
5.1 概述
5.2 案例分析
5.2.1 高性能硬體上的程式部署策略
5.2.2 叢集間同步導致的記憶體溢出
5.2.3 堆外記憶體導致的溢出錯誤
5.2.4 外部命令導致系統緩慢
5.2.5 伺服器JVM進程崩潰
5.3 實戰：Eclipse執行速度調教優化
5.3.1 調教優化前的程式執行狀態
5.3.2 升級JDK 1.6的性能變化及相容問題
5.3.3 編譯時間和類別載入時間的優化
5.3.4 調整記憶體設置控制垃圾收集頻率
5.3.5 選擇收集器降低延遲
5.4 本章小結
第6章 類別檔結構
6.1 概述
6.2 無關性的基石
6.3 Class類別檔的結構
6.3.1魔數與Class檔的版本
6.3.2 常數池
6.3.3 訪問標誌
6.3.4 類別索引、父類別索引與介面索引集合
6.3.5 欄位表集合
6.3.6 方法表集合
6.3.7 屬性工作表集合
6.4 Class檔結構的發展
6.5 本章小結
第7章 虛擬機器類別載入機制
7.1 概述
7.2 類別載入的時機
7.3 類別載入的過程
7.3.1 載入
7.3.2 驗證
7.3.3 準備
7.3.4 解析
7.3.5 初始化
7.4 類別載入器
7.4.1 類別與類別載入器
7.4.2 雙親委派模型
7.4.3 破壞雙親委派模型
7.5 本章小結
第8章虛擬機器位元組編碼執行引擎
8.1 概述
8.2 執行時堆疊結構結構
8.2.1 區域變數表
8.2.2 運算元堆疊
8.2.3 動態連接
8.2.4 方法返回位址
8.2.5 附加資訊
8.3 方法呼叫
8.3.1 解析
8.3.2 分派
8.4 基於堆疊的位元組編碼解譯執行引擎
8.4.1 解譯執行
8.4.2 基於堆疊的指令集與基於暫存器的指令集
8.4.3 基於堆疊的解譯器執行過程
8.5 本章小結
第9章 類別載入及執行子系統的案例與實戰
9.1 概述
9.2 案例分析
9.2.1 Tomcat：正統的類別載入器架構
9.2.2 OSGi：靈活的類別載入器架構
9.2.3 位元組編碼產生技術與動態代理的實現
9.2.4 Retrotranslator：跨越JDK版本
9.3 實戰：自己動手實現遠端執行功能
9.3.1 目標
9.3.2 思路
9.3.3 實現
9.3.4 驗證
9.4 本章小結
第10章 早期（編譯期）優化
10.1 概述
10.2 Javac編譯器.
10.2.1 Javac的原始碼與偵錯
10.2.2 解析與填充符號表
10.2.3 注解處理器
10.2.4 語義分析與位元組編碼產生
10.3 Java 語法糖的味道
10.3.1 泛用型與類型刪除
10.3.2 自動打包、拆箱與遍歷迴圈
10.3.3 條件編譯
10.4 實戰：插入式注解處理器
10.4.1 實戰目標
10.4.2 程式碼實現
10.4.3 執行與測試
10.4.4 其他應用案例
10.5 本章小結.
第11章 晚期（執行期）優化
11.1 概述
11.2 HotSpot虛擬機器內的即時編譯器
11.2.1 解譯器與編譯器
11.2.2 編譯物件與觸發條件
11.2.3 編譯過程 .
11.2.4 查看與分析即時編譯結果
11.3 編譯優化技術
11.3.1 優化技術概覽
11.3.2 公共子運算式消除
11.3.3 陣列邊界檢查消除
11.3.4 方法內聯
11.3.5 逃逸分析
11.4 Java與C/C++的編譯器對比
11.5 本章小結
第12章 Java記憶體模型與執行緒
12.1 概述
12.2 硬體的效率與一致性
12.3 Java記憶體模型
12.3.1 主記憶體與工作記憶體
12.3.2 記憶體間互動操作
12.3.3 對於volatile型變數的特殊規則.
12.3.4 對於long和double型變數的特殊規則
12.3.5 原子性、可見性與有序性
12.3.6 先行發生原則
12.4 Java與執行緒
12.4.1 執行緒的實現
12.4.2 Java執行緒調度
12.4.3 狀態轉換
12.5 本章小結
第13章 執行緒安全與鎖優化
13.1 概述
13.2 執行緒安全
13.2.1 Java語言中的執行緒安全
13.2.2 執行緒安全的實現方法
13.3 鎖優化
13.3.1 自旋鎖與自我調整自旋
13.3.2 鎖消除
13.3.3 鎖粗化
13.3.4 輕量化鎖
13.3.5 偏向鎖
13.4 本章小結
附錄A Java虛擬機器家族
A.1 商用高性能虛擬機器
A.2 其他影響較大的虛擬機器
A.3 嵌入式虛擬機器
A.4 其他虛擬機器實現
附錄B 虛擬機器位元組編碼指令表
附錄C HotSpot虛擬機器主要參數表
C.1 記憶體管理參數
C.2 即時編譯參數
C.3 類型載入參數
C.4 多執行緒相關參數
C.5 性能參數
C.6 偵錯參數
附錄D 物件查詢語言（OQL）簡介
D.1 SELECT子句
D.1.1 選擇特定的顯示列
D.1.2 使用列別名
D.1.3 合併成為一個物件清單選擇專案
D.1.4 排除重複物件
D.2 FROM子句
D.2.1 FROM子句指定需要查詢的類別
D.2.2 包含子類別
D.2.3 禁止查詢類別實例
D.3 WHERE子句
D.3.1 >=、<=、>、<、[NOT] LIKE、[NOT] IN（關係操作）
D.3.2 =、!=（等於操作）
D.3.3 AND（條件與操作）
D.3.4 OR（條件或操作）
D.3.5 文字運算式
D.4 屬性訪問器
D.4.1 訪問堆轉儲快照中對象的欄位
D.4.2 訪問Java Bean屬性
D.4.3 呼叫OQL Java方法
D.4.4 OQL 的內建函數
D.5 OQL 語言的 BNF 範式
附錄E JDK 歷史版本軌
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>直達Java虛擬機器
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java网络编程实用精解
前言
第一篇 预备篇
第1章 HTML与表单1
1．1 HTML基础1
1．1．1 制作HTML文件的工具1
1．1．2 HTML文件结构1
1．1．3 HTML链接3
1．1．4 制作HTML表格4
1．1．5 HTML文件包括图像5
1．1．6 样式表6
1．2 创建HTML表单7
1．2．1 创建表单7
1．2．2 文本框．密码框和隐藏域8
1．2．3 编写按钮8
1．2．4 复选框和单选钮9
1．2．5 组合框和列表框10
1．2．6 文本区域11
1．2．7 设置控制的tab顺序12
本章小结14
第2章 Servlet和JSP概述15
2．1 Servlet和JSP15
2．1．1 Servlet15
2．1．2 JSP16
2．2 为什么要创建动态网页17
2．3 Servlet的优势18
2．4 下载和安装Java19
2．5 下载和配置服务器20
2．5．1 SJSAS9．1 20
2．5．2 Tomcat6．0．1 822
2．6 Web应用25
2．6．1 Web应用的目的25
2．6．2 Web应用结构26
2．7 创建一个简单的Web应用28
2．7．1 使用了包的Servlet28
2．7．2 使用包和辅助类的Servlet29
2．7．3 web．xml文件32
2．8 NetBean33
本章小结39
第3章 XML与web．xml40
3．1 XML引论40
3．1．1 XML基本语法40
3．1．2 XMLSchema43
3．1．3 XSLT47
3．1．4 DTD50
3．2 部署描述文件（web．xml）52
3．3 举例说明web．xml文件中的元素54
3．3．1 给Servlet或JSP命名并定制URL54
3．3．2 禁止激活器Servlet56
本章小结58
第二篇 Servlet技术
第4章 Servlet基础59
4．1 Servlet的基本结构59
4．1．1 Servlet概述59
4．1．2 Servlet的基本结构60
4．1．3 输出HTML文本61
4．1．4 Servlet包61
4．1．5 Servlet配置和运行62
4．2 几个HTML工具函数63
4．3 Servlet生命史64
4．3．1 service方法64
4．3．2 doGet．doPost和doXxx方法65
4．3．3 init方法65
4．3．4 destroy方法67
4．4 Servlet查错68
4．5 实例：emailList应用69
本章小结73
第5章 Servlet处理请求：表单数据和请求头74
5．1 表单数据的作用74
5．2 Servlet怎样读取表单数据74
5．2．1 读取表单数据的各种方法75
5．2．2 实例：读取3个表单变量76
5．2．3 实例：读取所有表单数据79
5．3 使用默认值处理参数遗漏或畸形82
5．4 过滤HTML中的特殊字符89
5．5 请求参数自动填入Java对象：表单Bean94
5．6 遗漏数据或畸形数据重新显示表单98
5．6．1 重新显示的各种选项98
5．6．2 处理拍卖出价的Servlet99
5．7 在Servlet中读请求头105
5．7．1 HTTP请求头概念105
5．7．2 在Servlet中读请求头方法106
5．7．3 制作所有请求头的表格107
5．8 了解HTTP1．1 请求头意义108
5．9 送压缩网页110
5．10 区分不同浏览器类型113
5．11 根据用户所到达网址来改变网页115
本章小结117
第6章 HTTP响应，状态码和响应头118
6．1 设置状态码118
6．1．1 状态码概述118
6．1．2 设置任意状态码：setStatus119
6．1．3 设置302和404状态码：sendRedirct和sendError119
6．2 HTTP1．1 状态码及其含义119
6．3 将用户重定向到指定浏览器主页的Servlet123
6．4 各种搜索引擎124
6．5 设置响应头129
6．6 常见响应头及其含义129
6．7 创建ExcelSpreadsheets133
6．8 持久Servlet状态和自动刷新页面134
6．9 用Servlet生成JPEG图像142
6．10 下载MP3文件146
本章小结147
第7章 cookies和session148
7．1 cookies概述148
7．1．1 cookies的功能148
7．1．2 使用cookies应该注意的问题149
7．1．3 删除cookies150
7．2 发送和接收cookies151
7．2．1 发送cookies给用户151
7．2．2 读取保存在客户端的cookies153
7．3 用cookies监测第一次到访者153
7．4 区分会话cookies与持久cookies155
7．5 cookies的基本辅助工具157
7．5．1 获取指定名字的cookies值157
7．5．2 自动保存cookies157
7．5．3 举例说明使用cookies辅助工具158
7．6 cookies的两个用途160
7．6．1 修正cookies值来追踪用户访问次数160
7．6．2 用cookies记住用户喜好161
7．7 session概述164
7．8 会话状态跟踪基础167
7．9 会话状态跟踪API169
7．10 会话状态跟踪的3种方法170
7．11 可变对象与不可变对象172
7．11．1 不可变对象172
7．11．2 可变对象174
7．12 用购物车和会话状态跟踪建在线商店176
7．12．1 创建前台176
7．12．2 处理订单178
7．12．3 后台工作：实现购物车和商品分类182
本章小结186
第三篇 JSP技术
第8章 JSP基本语法187
8．1 JSP引论187
8．2 用脚本元素调用Java程序188
8．2．1 JSP模板文本189
8．2．2 JSP表达式189
8．2．3 scriptlets191
8．2．4 JSP声明193
8．3 JSP指令：page．include和taglib195
8．3．1 page指令195
8．3．2 include指令200
8．4 动作元素202
8．4．1 jsp：include动作202
8．4．2 jsp：param203
8．4．3 jsp：forward动作204
8．4．4 jsp：plugin动作205
8．4．5 jsp：fallback205
8．5 JSP预定义变量209
本章小结211
第9章 在JSP中使用JavaBean212
9．1 何谓JavaBean212
9．2 JSP使用JavaBean的基本方法213
9．2．1 jsp：useBean动作213
9．2．2 jsp：getProperty动作214
9．2．3 jsp：setProperty动作216
9．3 利用表单参数设置bean特性218
9．3．1 特性类型为String218
9．3．2 个别特性与请求参数联系起来221
9．3．3 把所有bean特性与请求参数联系起来223
9．4 共享bean224
9．4．1 scope属性224
9．4．2 条件创建bean225
9．5 4种不同方式共享bean227
9．5．1 把bean类作为辅助类227
9．5．2 本页共享（scope="page"）228
9．5．3 请求共享（scope="request"）230
9．5．4 会话共享（scope="session"）231
9．5．5 应用共享（scope="application"）232
本章小结233
第10章 整合Servlet和JSP（MVC）234
10．1 MVC模型概述234
10．1．1 为什么需要MVC234
10．1．2 MVC框架235
10．2 用RequestDispatcher来实现MVC235
10．3 MVC程序总结并举例说明238
10．3．1 请求共享238
10．3．2 会话共享240
10．3．3 应用共享243
10．4 有关MVC模型的3个问题247
10．4．1 最后网页怎样解释相对URL247
10．4．2 从JSP页面发出请求248
10．4．3 包含网页248
10．5 应用MVC模型：银行账户结余249
本章小结255
第11章 JSP的表达式语言256
11．1 表达式语言的概述256
11．1．1 为什么要引进表达式语言256
11．1．2 表达式语言的功能256
11．1．3 访问表达式语言257
11．2 忽略表达式语言估值257
11．3 访问作用域变量259
11．3．1 何谓作用域变量259
11．3．2 怎样访问作用域变量259
11．3．3 属性名的限制259
11．3．4 例题260
11．4 访问bean特性261
11．4．1 访问嵌套bean特性261
11．4．2 点操作符与数组操作符262
11．4．3 举例说明访问嵌套bean特性263
11．5 访问集合类数据266
11．5．1 访问数组．列表和映射266
11．5．2 举例说明访问集合类数据267
11．6 表达式语言的隐式对象268
11．7 运算操作符270
11．7．1 算术运算符270
11．7．2 关系运算符271
11．7．3 逻辑运算符271
11．7．4 空操作符271
11．8 条件估计表达式值272
本章小结275
第12章 自制标签276
12．1 自制标签库的3个成员276
12．1．1 自制标签句柄类276
12．1．2 TLD文件277
12．1．3 JSP文件278
12．2 给标签指定属性279
12．2．1 在句柄类中添加设置属性方法279
12．2．2 如何在TLD文件中声明属性280
12．2．3 JSP页面应用属性280
12．2．4 举例说明使用标签属性280
12．3 带标签体的自制标签284
12．4 创建Tag文件287
12．4．1 基于JSP的自制标签287
12．4．2 举例说明用标签文件创建简单自制标签287
12．4．3 举例说明用标签文件创建带有属性的自制标签288
12．4．4 举例说明用标签文件创建带有标签体的自制标签289
12．5 操作标签体290
12．5．1 如何操作标签体290
12．5．2 过滤HTML的标签290
12．5．3 迭代自制标签体295
12．6 给标签属性赋动态值300
12．6．1 动态值为字符串301
12．6．2 动态值为复杂对象301
12．6．3 表格式标签301
12．7 创建表达式语言函数305
12．7．1 如何创建EL函数306
12．7．2 举例说明EL函数306
本章小结309
第13章 JSP标准标签库310
13．1 JSTL安装310
13．2 一般用途标签（c：out．c：set．c：remove和c：catch）311
13．2．1 c：out311
13．2．2 c：set和c：remove标签312
13．2．3 c：catch标签313
13．3 循环标签（c：forEach．c：forTokens）314
13．4 条件标签316
13．4．1 c：if316
13．4．2 c：choose316
13．5 与URL相关的标签（c：import．c：url．c：param和c：redirect）318
13．5．1 c：import318
13．5．2 c：url和c：param标签320
13．5．3 c：redirect标签321
13．6 JSTL在购物篮中的应用322
13．6．1 顾客界面322
13．6．2 业务逻辑（JavaBean）322
13．6．3 Servlet控制器326
13．6．4 JSP文件329
本章小结333
第四篇 高级篇
第14章 数据库JDBC335
14．1 JDBC基础335
14．2 用JDBC-ODBC桥示例338
14．2．1 Northwind数据库准备338
14．2．2 NorthwindTest339
14．2．3 NorthwindServlet341
14．3 Derby数据库引擎344
14．3．1 设置环境变量（Windows）344
14．3．2 测试Derby数据库引擎345
14．4 使用Derby数据库引擎347
14．4．1 准备数据库347
14．4．2 MetaData350
14．4．3 操作数据库351
14．5 安装与测试MySQL352
14．5．1 安装MySQL352
14．5．2 测试MySQL352
14．5．3 通过JDBC连接来测试MySQL数据库354
14．6 用预先准备好的查询语句355
14．6．1 辅助类355
14．6．2 用预先准备好的查询语句360
14．6．3 建立和使用存储过程364
14．7 商务交易366
14．8 数据库连接池370
14．8．1 为什么要创建数据库连接池370
14．8．2 怎样实现数据库连接池371
14．8．3 举例说明数据库连接池应用373
本章小结379
第15章 网络安全380
15．1 网络安全概述380
15．1．1 安全概述380
15．1．2 SJSAS9．1 几个重要的术语381
15．1．3 Tomcat怎样实现安全领域382
15．2 表单认证384
15．2．1 表单认证的8个步骤384
15．2．2 表单的认证各步细节385
15．2．3 举例说明表单认证391
15．3 BASIC认证398
15．3．1 BASIC认证概述398
15．3．2 举例说明BASIC认证400
15．4 配置SSL403
15．4．1 SSL引论403
15．4．2 配置SSL404
15．5 声明安全与编程安全相结合406
15．6 全部用编程处理安全408
15．6．1 编程安全概述408
15．6．2 举例说明编程安全409
15．7 编程安全使用SSL412
15．7．1 编程安全使用SSL概况412
15．7．2 举例说明编程安全使用SSL412
本章小结415
第16章 Servlet和JSP的过滤器416
16．1 建立基本的过滤器416
16．1．1 建立一个实现filter接口的类417
16．1．2 doFilter方法417
16．1．3 调用FilterChain对象的doFilter方法418
16．1．4 对有关的Servlet和JSP页面注册过滤器418
16．1．5 禁用Servlet激活器420
16．2 举例说明（报告过滤器）420
16．3 记录访问日志423
16．3．1 从过滤器来访问Servlet上下文423
16．3．2 记录访问日志的过滤器424
16．4 用过滤器初始化参数425
16．4．1 操作初始化参数425
16．4．2 访问时间过滤器426
16．5 禁止网站访问的过滤器428
16．5．1 中断响应428
16．5．2 禁止网站访问的过滤器429
16．6 修改响应432
16．6．1 HttpServletResponseWrapper432
16．6．2 可重用响应封装包433
16．6．3 替代过滤器434
16．6．4 压缩过滤器437
16．7 填补潜在的安全漏洞441
16．7．1 用dispatcher元素来配置过滤器441
16．7．2 填补潜在的安全漏洞442
本章小结446
第17章 Web应用事件监听器447
17．1 事件监听器概述447
17．2 监测Servlet上下文的建立和销毁448
17．3 监测Servlet上下文属性的变化452
17．4 监听会话创建和销毁458
17．4．1 概述458
17．4．2 举例说明：统计会话的监听器458
17．5 监视会话属性变化462
17．5．1 监视会话属性变化概述462
17．5．2 举例说明：监视iPhone订单463
17．6 对请求的监听器467
17．6．1 计算服务器请求的负荷467
17．6．2 终止请求频率收集471
17．7 使用多个监听器472
本章小结477
第18章 在线手机商店478
18．1 在线手机商店概况478
18．1．1 主页478
18．1．2 Web结构479
18．1．3 业务逻辑482
18．1．4 数据库484
18．1．5 处理数据库的Java类485
18．2 下载应用489
18．2．1 下载用户界面489
18．2．2 下载应用结构489
18．2．3 下载应用程序490
18．3 购物车应用494
18．3．1 购物车用户界面494
18．3．2 购物车结构495
18．3．3 购物车应用程序495
18．4 管理应用504
18．4．1 管理应用引论504
18．4．2 处理购物清单应用505
18．4．3 报告应用510
本章小结514
附录缩写词列表515
参考文献517
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java网络编程实用精解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java面向对象程序设计基础教程
第1章  Java语言概述1  1.1  Java语言的起源及发展1    1.1.1  起源1    1.1.2  发展2  1.2  Java语言的特点2  1.3  Java程序是如何在系统中运行的5  1.4  Java开发环境5  1.5  编写、编译与运行Java程序7  1.6  包10  1.7  应用Eclipse开发项目13    1.7.1  Eclipse开发环境13    1.7.2  创建Java项目并运行14    1.7.3  程序调试技术17第2章  Java基本语法规则20  2.1  标识符与保留字20    2.1.1  标识符20    2.1.2  保留字20    2.1.3  分隔符21    2.1.4  注释21  2.2  数据类型22    2.2.1  整数类型22    2.2.2  浮点数类型23    2.2.3  布尔类型23    2.2.4  字符类型24    2.2.5  数据类型之间的相互转换24    2.2.6  变量与常量25  2.3  运算符和表达式27    2.3.1  运算符27    2.3.2  表达式33    2.3.3  运算符优先级33    2.3.4  编程风格34第3章  Java中的面向对象技术36  3.1  现实世界由对象组成36  3.2  人类的思维方式37  3.3  对象模型的特点37  3.4  过程模型的特点39  3.5  类及其成员39    3.5.1  类40    3.5.2  对象41    3.5.3  成员变量44    3.5.4  成员方法45    3.5.5  构造方法49    3.5.6  方法的重载50    3.5.7  this引用51    3.5.8  static成员53    3.5.9  成员的访问权限55    3.5.10  类的访问权限58  3.6  类的继承59    3.6.1  继承60    3.6.2  对象的赋值相容性与上转型62    3.6.3  隐藏、覆盖与动态绑定63    3.6.4  super引用65    3.6.5  对象初始化顺序66  3.7  方法调用的优先顺序71  3.8  abstract修饰的类73  3.9  final  修饰74  3.10  接口76    3.10.1  接口与实现接口的类76    3.10.2  编程中选择抽象类还是接口78  3.11  多态80    3.11.1  多态的3种情形80    3.11.2  多态的具体实现82    3.11.3  总结83  3.12  继承与多态的综合用例84  3.13  内部类89    3.13.1  实例成员内部类89    3.13.2  局部内部类92    3.13.3  匿名内部类93    3.13.4  静态成员内部类94    3.13.5  内部类的继承95    3.13.6  内部类的两种特殊用法95    3.13.7  内部类总结97  3.14  设计原则99第4章  Java基本结构程序112  4.1  流程控制语句112    4.1.1  顺序结构112    4.1.2  分支语句112    4.1.3  循环语句117    4.1.4  跳转语句120  4.2  递归123第5章  Java基本类125  5.1  java.lang语言包125    5.1.1  Object类125    5.1.2  字符串类126    5.1.3  数组129    5.1.4  基本数据类型的包装类134    5.1.5  Math数学类135  5.2  java.util实用包136    5.2.1  日期类136    5.2.2  集合API138    5.2.3  随机数类Random141第6章  图形用户界面143  6.1  概述143  6.2  容器和布局145    6.2.1  容器组件145    6.2.2  框架JFrame147    6.2.3  布局管理器148  6.3  常用组件152    6.3.1  标签组件152    6.3.2  文本编辑组件153    6.3.3  按钮组件154    6.3.4  列表框和组合框156    6.3.5  对话框156    6.3.6  菜单组件158  6.4  事件处理机制161    6.4.1  基本概念161    6.4.2  委托模型162    6.4.3  Java中常用的事件、监听器及事件处理方法163    6.4.4  事件处理机制的编程方法164    6.4.5  几个事件处理的例子167第7章  异常处理181  7.1  异常处理概述181    7.1.1  程序中常见的错误181    7.1.2  Java中的异常类182    7.1.3  异常处理过程182  7.2  Java的异常处理183    7.2.1  try…catch…finally异常处理语句183    7.2.2  用throw抛出自定义异常对象186    7.2.3  用throws将异常抛给上级调用方法处理186    7.2.4  自定义异常类187第8章  多线程189  8.1  创建线程189    8.1.1  继承Thread类创建线程189    8.1.2  实现Runnable接口创建线程192    8.1.3  线程状态和线程控制194  8.2  线程间的同步机制198    8.2.1  同步机制解决资源竞争问题198    8.2.2  同步机制与线程通信202第9章  Java Applet程序207  9.1  初识Applet207  9.2  Applet的生命周期208  9.3  Applet中的方法209  9.4  Applet和Web页面210  9.5  Applet播放声音211  9.6  Applet实现动画212  9.7  Application与Applet的关系214第10章  输入输出流与文件处理215  10.1  输入输出流概述215  10.2  字节流类216    10.2.1  字节输入输出流217    10.2.2  文件字节输入输出流类220    10.2.3  过滤输入输出流222    10.2.4  对象输入输出流类225  10.3  字符流类228    10.3.1  字符输入输出流229    10.3.2  文件字符输入输出流类230    10.3.3  字符缓冲流类231  10.4  文件处理233    10.4.1  文件的基本概念233    10.4.2  File类234    10.4.3  文件过滤器接口236    10.4.4  随机存取文件类239第11章  Java网络编程242  11.1  网络编程基本概念242    11.1.1  网络基础知识242    11.1.2  HTTP简介243    11.1.3  两类传输协议TCP和UDP243  11.2  使用URL访问网络资源244    11.2.1  统一资源定位符URL244    11.2.2  URL类244    11.2.3  URLConnection类247  11.3  Socket通信249    11.3.1  套接字249    11.3.2  Socket通信249  11.4  UDP数据报254    11.4.1  数据报254    11.4.2  UDP通信255第12章  数据库应用260  12.1  数据库技术260  12.2  初识JDBC程序261    12.2.1  建立student表261    12.2.2  新建first_v1.0项目261  12.3  创建数据库应用程序263    12.3.1  数据库驱动263    12.3.2  URL264    12.3.3  建立连接266    12.3.4  建立会话266    12.3.5  操作数据库267  12.4  JDBC综合应用举例268
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java面向对象程序设计基础教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>疯狂Java讲义（第4版）
第1章　Java语言概述与开发环境 1
1.1　Java语言的发展简史 2
1.2　Java程序运行机制 4
1.2.1　高级语言的运行机制 4
1.2.2　Java程序的运行机制和JVM 5
1.3　开发Java的准备 6
1.3.1　下载和安装Java 9的JDK 6
不是说JVM是运行Java程序的虚拟机吗？那JRE和JVM的关系是怎样的呢？ 6
为什么不安装公共JRE呢？ 8
1.3.2　设置PATH环境变量 9
为什么选择用户变量？用户变量与系统变量有什么区别？ 10
1.4　第一个Java程序 11
1.4.1　编辑Java源代码 11
1.4.2　编译Java程序 11
当编译C程序时，不仅需要指定存放目标文件的位置，也需要指定目标文件的文件名，这里使用javac编译Java程序时怎么不需要指定目标文件的文件名呢？ 12
1.4.3　运行Java程序 12
1.4.4　根据CLASSPATH环境变量定位类 13
1.5　Java程序的基本规则 14
1.5.1　Java程序的组织形式 14
1.5.2　Java源文件的命名规则 15
1.5.3　初学者容易犯的错误 15
1.6　JDK 9新增的jshell工具 17
1.7　Java 9的G1垃圾回收器 18
1.8　何时开始使用IDE工具 20
我想学习Java编程，到底是学习Eclipse好，还是学习NetBeans好呢？ 21
1.9　本章小结 21
本章练习 21
第2章　理解面向对象 22
2.1  面向对象 23
2.1.1  结构化程序设计简介 23
2.1.2  程序的三种基本结构 24
2.1.3  面向对象程序设计简介 26
2.1.4  面向对象的基本特征 27
2.2  UML（统一建模语言）介绍 28
2.2.1  用例图 30
2.2.2  类图 30
2.2.3  组件图 32
2.2.4  部署图 33
2.2.5  顺序图 33
2.2.6  活动图 34
2.2.7  状态机图 35
2.3  Java的面向对象特征 36
2.3.1  一切都是对象 36
2.3.2  类和对象 36
2.4  本章小结 37
第3章　数据类型和运算符 38
3.1  注释 39
3.1.1  单行注释和多行注释 39
3.1.2  Java 9增强文档注释 40
API文档是什么? 40
为什么要学习查看API文档的方法？ 42
3.2  标识符和关键字 46
3.2.1  分隔符 46
3.2.2  Java 9的标识符规则 48
3.2.3  Java关键字 48
3.3  数据类型分类 48
什么是变量？变量有什么用？ 49
3.4  基本数据类型 49
3.4.1  整型 50
3.4.2  字符型 52
什么是字符集？ 52
3.4.3  浮点型 53
3.4.4  数值中使用下画线分隔 54
3.4.5  布尔型 55
3.5  基本类型的类型转换 55
3.5.1  自动类型转换 56
3.5.2  强制类型转换 57
3.5.3  表达式类型的自动提升 58
3.6  直接量 59
3.6.1  直接量的类型 59
3.6.2  直接量的赋值 60
3.7  运算符 61
3.7.1  算术运算符 61
3.7.2  赋值运算符 63
3.7.3  位运算符 64
3.7.4  扩展后的赋值运算符 66
3.7.5  比较运算符 67
3.7.6  逻辑运算符 68
3.7.7  三目运算符 69
3.7.8  运算符的结合性和优先级 69
3.8  本章小结 71
本章练习 71
第4章　流程控制与数组 72
4.1  顺序结构 73
4.2  分支结构 73
4.2.1  if条件语句 73
4.2.2  Java 7增强后的switch分支语句 77
4.3  循环结构 79
4.3.1  while循环语句 79
4.3.2  do while循环语句 80
4.3.3  for循环 81
4.3.4  嵌套循环 84
4.4  控制循环结构 85
4.4.1  使用break结束循环 85
4.4.2  使用continue忽略本次循环剩下语句 86
4.4.3  使用return结束方法 87
4.5  数组类型 87
4.5.1  理解数组：数组也是一种类型 87
int[]是一种类型吗？怎么使用这种类型呢？ 88
4.5.2  定义数组 88
4.5.3  数组的初始化 89
能不能只分配内存空间，不赋初始值呢？ 89
4.5.4  使用数组 90
为什么要我记住这些异常信息？ 90
4.5.5  foreach循环 91
4.6  深入数组 92
4.6.1  内存中的数组 92
为什么有栈内存和堆内存之分？ 93
4.6.2  基本类型数组的初始化 95
4.6.3  引用类型数组的初始化 96
4.6.4  没有多维数组 98
我是否可以让图4.13中灰色覆盖的数组元素再次指向另一个数组？这样不就可以扩展成三维数组，甚至扩展成更多维的数组吗？ 99
4.6.5  Java 8增强的工具类：Arrays 100
4.6.6  数组的应用举例 103
4.7  本章小结 106
本章练习 106
第5章　面向对象（上） 107
5.1  类和对象 108
5.1.1  定义类 108
构造器不是没有返回值吗？为什么不能用void声明呢？ 110
5.1.2  对象的产生和使用 111
5.1.3  对象、引用和指针 111
5.1.4  对象的this引用 112
5.2  方法详解 116
5.2.1  方法的所属性 116
5.2.2  方法的参数传递机制 117
5.2.3  形参个数可变的方法 120
5.2.4  递归方法 121
5.2.5  方法重载 123
为什么方法的返回值类型不能用于区分重载的方法？ 123
5.3  成员变量和局部变量 124
5.3.1  成员变量和局部变量是什么 124
5.3.2  成员变量的初始化和内存中的运行机制 127
5.3.3  局部变量的初始化和内存中的运行机制 129
5.3.4  变量的使用规则 130
5.4  隐藏和封装 131
5.4.1  理解封装 131
5.4.2  使用访问控制符 131
5.4.3  package、import和import static 134
5.4.4  Java的常用包 139
5.5  深入构造器 139
5.5.1  使用构造器执行初始化 139
构造器是创建Java对象的途径，是不是说构造器完全负责创建Java对象？ 140
5.5.2  构造器重载 140
为什么要用this来调用另一个重载的构造器？我把另一个构造器里的代码复制、粘贴到这个构造器里不就可以了吗？ 142
5.6  类的继承 142
5.6.1  继承的特点 142
5.6.2  重写父类的方法 143
5.6.3  super限定 145
5.6.4  调用父类构造器 147
为什么我创建Java对象时从未感觉到java.lang. Object类的构造器被调用过？ 149
5.7  多态 149
5.7.1  多态性 149
5.7.2  引用变量的强制类型转换 151
5.7.3  instanceof运算符 152
5.8  继承与组合 153
5.8.1  使用继承的注意点 153
5.8.2  利用组合实现复用 154
使用组合关系来实现复用时，需要创建两个Animal对象，是不是意味着使用组合关系时系统开销更大？ 157
5.9  初始化块 157
5.9.1  使用初始化块 157
5.9.2  初始化块和构造器 159
5.9.3  静态初始化块 160
5.10  本章小结 162
本章练习 162
第6章　面向对象（下） 164
6.1  Java 8增强的包装类 165
Java为什么要对这些数据进行缓存呢? 168
6.2  处理对象 169
6.2.1  打印对象和toString方法 169
6.2.2  ==和equals方法 171
上面程序中判断obj是否为Person类的实例时，为何不用obj instanceof Person来判断呢？ 174
6.3  类成员 174
6.3.1  理解类成员 174
6.3.2  单例（Singleton）类 175
6.4  final修饰符 176
6.4.1  final成员变量 177
6.4.2  final局部变量 179
6.4.3  final修饰基本类型变量和引用类型变量的区别 179
6.4.4  可执行“宏替换”的final变量 180
6.4.5  final方法 182
6.4.6  final类 182
6.4.7  不可变类 183
6.4.8  缓存实例的不可变类 185
6.5  抽象类 188
6.5.1  抽象方法和抽象类 188
6.5.2  抽象类的作用 191
6.6  Java 9改进的接口 192
6.6.1  接口的概念 192
6.6.2  Java 9中接口的定义 193
6.6.3  接口的继承 195
6.6.4  使用接口 196
6.6.5  接口和抽象类 197
6.6.6  面向接口编程 198
6.7  内部类 202
6.7.1  非静态内部类 202
非静态内部类对象和外部类对象的关系是怎样的？ 205
6.7.2  静态内部类 206
为什么静态内部类的实例方法也不能访问外部类的实例属性呢？ 207
学生提问：接口里是否能定义内部接口？ 208
6.7.3  使用内部类 208
既然内部类是外部类的成员，那么是否可以为外部类定义子类，在子类中再定义一个内部类来重写其父类中的内部类呢？ 210
6.7.4  局部内部类 210
6.7.5  Java 8改进的匿名内部类 211
6.8  Java 8新增的Lambda表达式 214
6.8.1  Lambda表达式入门 214
6.8.2  Lambda表达式与函数式接口 217
6.8.3  方法引用与构造器引用 218
6.8.4  Lambda表达式与匿名内部类的联系和区别 221
6.8.5  使用Lambda表达式调用Arrays的类方法 222
6.9  枚举类 223
6.9.1  手动实现枚举类 223
6.9.2  枚举类入门 223
6.9.3  枚举类的成员变量、方法和构造器 225
6.9.4  实现接口的枚举类 227
枚举类不是用final修饰了吗？怎么还能派生子类呢？ 228
6.9.5  包含抽象方法的枚举类 228
6.10  对象与垃圾回收 229
6.10.1  对象在内存中的状态 229
6.10.2  强制垃圾回收 230
6.10.3  finalize方法 231
6.10.4  对象的软、弱和虚引用 233
6.11  修饰符的适用范围 236
6.12  Java 9的多版本JAR包 237
6.12.1  jar命令详解 237
6.12.2  创建可执行的JAR包 240
6.12.3  关于JAR包的技巧 241
6.13  本章小结 242
本章练习 242
第7章　Java基础类库 243
7.1  与用户互动 244
7.1.1  运行Java程序的参数 244
7.1.2  使用Scanner获取键盘输入 245
7.2  系统相关 247
7.2.1  System类 247
7.2.2  Runtime类与Java 9的ProcessHandle 249
7.3  常用类 250
7.3.1  Object类 250
7.3.2  Java 7新增的Objects类 252
7.3.3  Java 9改进的String、StringBuffer和StringBuilder类 253
7.3.4  Math类 256
7.3.5  Java 7的ThreadLocalRandom与Random 258
7.3.6  BigDecimal类 260
7.4  日期、时间类 262
7.4.1  Date类 262
7.4.2  Calendar类 263
7.4.3  Java 8新增的日期、时间包 266
7.5  正则表达式 268
7.5.1  创建正则表达式 268
7.5.2  使用正则表达式 271
7.6  变量处理和方法处理 274
7.6.1  Java 9增强的MethodHandle 274
7.6.2  Java 9增加的VarHandle 275
7.7  Java 9改进的国际化与格式化 276
7.7.1  Java国际化的思路 277
7.7.2  Java支持的国家和语言 277
7.7.3  完成程序国际化 278
7.7.4  使用MessageFormat处理包含占位符的字符串 279
7.7.5  使用类文件代替资源文件 280
7.7.6  Java 9新增的日志API 281
7.7.7  使用NumberFormat格式化数字 283
7.7.8  使用DateFormat格式化日期、时间 284
7.7.9  使用SimpleDateFormat格式化日期 286
7.8  Java 8新增的日期、时间格式器 286
7.8.1  使用DateTimeFormatter完成格式化 287
7.8.2  使用DateTimeFormatter解析字符串 288
7.9  本章小结 289
本章练习 289
第8章　Java集合 290
8.1  Java集合概述 291
8.2  Collection和Iterator接口 292
8.2.1  使用Lambda表达式遍历集合 294
8.2.2  使用Java 8增强的Iterator遍历集合元素 295
8.2.3  使用Lambda表达式遍历Iterator 296
8.2.4  使用foreach循环遍历集合元素 297
8.2.5  使用Java 8新增的Predicate操作集合 297
8.2.6  使用Java 8新增的Stream操作集合 298
8.3  Set集合 300
8.3.1  HashSet类 301
hashCode()方法对于HashSet是不是十分重要？ 302
8.3.2  LinkedHashSet类 304
8.3.3  TreeSet类 305
8.3.4  EnumSet类 311
8.3.5  各Set实现类的性能分析 312
8.4  List集合 313
8.4.1  Java 8改进的List接口和ListIterator接口 313
8.4.2  ArrayList和Vector实现类 316
8.4.3  固定长度的List 317
8.5  Queue集合 317
8.5.1  PriorityQueue实现类 318
8.5.2  Deque接口与ArrayDeque实现类 318
8.5.3  LinkedList实现类 320
8.5.4  各种线性表的性能分析 321
8.6  Java 8增强的Map集合 322
8.6.1  Java 8为Map新增的方法 324
8.6.2  Java 8改进的HashMap和Hashtable实现类 325
8.6.3  LinkedHashMap实现类 328
8.6.4  使用Properties读写属性文件 328
8.6.5  SortedMap接口和TreeMap实现类 329
8.6.6  WeakHashMap实现类 332
8.6.7  IdentityHashMap实现类 333
8.6.8  EnumMap实现类 333
8.6.9  各Map实现类的性能分析 334
8.7  HashSet和HashMap的性能选项 334
8.8  操作集合的工具类：Collections 335
8.8.1  排序操作 335
8.8.2  查找、替换操作 338
8.8.3  同步控制 339
8.8.4  设置不可变集合 339
8.8.5  Java 9新增的不可变集合 340
8.9  烦琐的接口：Enumeration 341
8.10  本章小结 342
本章练习 342
第9章　泛型 343
9.1  泛型入门 344
9.1.1  编译时不检查类型的异常 344
9.1.2  使用泛型 344
9.1.3  Java 9增强的“菱形”语法 345
9.2  深入泛型 347
9.2.1　定义泛型接口、类 347
9.2.2  从泛型类派生子类 348
9.2.3  并不存在泛型类 349
9.3  类型通配符 350
9.3.1  使用类型通配符 352
9.3.2  设定类型通配符的上限 352
9.3.3  设定类型通配符的下限 354
9.3.4  设定泛型形参的上限 356
9.4  泛型方法 356
9.4.1  定义泛型方法 356
9.4.2  泛型方法和类型通配符的区别 359
9.4.3  Java 7的“菱形”语法与泛型构造器 360
9.4.4  泛型方法与方法重载 361
9.4.5  Java 8改进的类型推断 362
9.5  擦除和转换 362
9.6  泛型与数组 364
9.7  本章小结 365
第10章　异常处理 366
10.1  异常概述 367
10.2  异常处理机制 368
10.2.1  使用try...catch捕获异常 368
10.2.2  异常类的继承体系 370
10.2.3  Java 7新增的多异常捕获 373
10.2.4  访问异常信息 373
10.2.5  使用finally回收资源 374
10.2.6  异常处理的嵌套 376
10.2.7  Java 9增强的自动关闭资源的try语句 377
10.3  Checked异常和Runtime异常体系 378
10.3.1  使用throws声明抛出异常 379
10.3.2  方法重写时声明抛出异常的限制 380
10.4  使用throw抛出异常 380
10.4.1  抛出异常 380
10.4.2  自定义异常类 382
10.4.3  catch和throw同时使用 382
10.4.4  Java 7增强的throw语句 384
10.4.5  异常链 385
10.5  Java的异常跟踪栈 386
10.6  异常处理规则 388
10.6.1  不要过度使用异常 388
10.6.2  不要使用过于庞大的try块 389
10.6.3  避免使用Catch All语句 390
10.6.4  不要忽略捕获到的异常 390
10.7  本章小结 390
本章练习 390
第11章　AWT编程 391
11.1  Java 9改进的GUI（图形用户界面）和AWT 392
11.2  AWT容器 393
11.3  布局管理器 396
11.3.1  FlowLayout布局管理器 396
11.3.2  BorderLayout布局管理器 397
BorderLayout最多只能放置5个组件吗？那它也太不实用了吧？ 398
11.3.3  GridLayout布局管理器 399
11.3.4  GridBagLayout布局管理器 400
11.3.5  CardLayout布局管理器 402
11.3.6  绝对定位 404
11.3.7  BoxLayout布局管理器 405
图11.15和图11.16显示的所有按钮都紧挨在一起，如果希望像FlowLayout、GridLayout等布局管理器那样指定组件的间距应该怎么办？ 406
11.4  AWT常用组件 407
11.4.1  基本组件 407
11.4.2  对话框（Dialog） 409
11.5  事件处理 411
11.5.1  Java事件模型的流程 411
11.5.2  事件和事件监听器 413
11.5.3  事件适配器 417
11.5.4  使用内部类实现监听器 418
11.5.5  使用外部类实现监听器 418
11.5.6  类本身作为事件监听器类 419
11.5.7  匿名内部类实现监听器 420
11.6  AWT菜单 421
11.6.1  菜单条、菜单和菜单项 421
11.6.2  右键菜单 423
为什么即使我没有给多行文本域编写右键菜单，但当我在多行文本域上单击右键时也一样会弹出右键菜单？ 424
11.7  在AWT中绘图 425
11.7.1  画图的实现原理 425
11.7.2  使用Graphics类 425
11.8  处理位图 430
11.8.1  Image抽象类和BufferedImage实现类 430
11.8.2  Java 9增强的ImageIO 432
11.9  剪贴板 436
11.9.1  数据传递的类和接口 436
11.9.2  传递文本 437
11.9.3  使用系统剪贴板传递图像 438
11.9.4  使用本地剪贴板传递对象引用 441
11.9.5  通过系统剪贴板传递Java对象 443
11.10  拖放功能 446
11.10.1  拖放目标 446
11.10.2  拖放源 449
11.11  本章小结 451
本章练习 451
第12章　Swing编程 452
12.1  Swing概述 453
12.2  Swing基本组件的用法 454
12.2.1  Java的Swing组件层次 454
12.2.2  AWT组件的Swing实现 455
为什么单击Swing多行文本域时不是弹出像AWT多行文本域中的右键菜单？ 461
12.2.3  为组件设置边框 461
12.2.4  Swing组件的双缓冲和键盘驱动 463
12.2.5  使用JToolBar创建工具条 464
12.2.6  使用JFileChooser和Java 7增强的JColorChooser 466
12.2.7  使用JOptionPane 473
12.3  Swing中的特殊容器 478
12.3.1  使用JSplitPane 478
12.3.2  使用JTabbedPane 480
12.3.3  使用JLayeredPane、JDesktopPane和JInternalFrame 484
12.4  Swing简化的拖放功能 491
12.5  Java 7新增的Swing功能 492
12.5.1  使用JLayer装饰组件 492
12.5.2  创建透明、不规则形状窗口 498
12.6  使用JProgressBar、ProgressMonitor和BoundedRangeModel创建进度条 500
12.6.1  创建进度条 500
12.6.2  创建进度对话框 503
12.7  使用JSlider和BoundedRangeModel创建滑动条 505
12.8  使用JSpinner和SpinnerModel创建微调控制器 508
12.9  使用JList、JComboBox创建列表框 511
12.9.1  简单列表框 511
12.9.2  不强制存储列表项的ListModel和ComboBoxModel 514
12.9.3  强制存储列表项的DefaultListModel和 DefaultComboBoxModel 517
为什么JComboBox提供了添加、删除列表项的方法？而JList没有提供添加、删除列表项的方法呢？ 519
12.9.4  使用ListCellRenderer改变列表项外观 519
12.10  使用JTree和TreeModel创建树 521
12.10.1  创建树 522
12.10.2  拖动、编辑树节点 524
12.10.3  监听节点事件 528
12.10.4  使用DefaultTreeCellRenderer改变节点外观 530
12.10.5  扩展DefaultTreeCellRenderer改变节点外观 531
12.10.6  实现TreeCellRenderer改变节点外观 534
12.11  使用JTable和TableModel创建表格 535
12.11.1  创建表格 536
我们指定的表格数据、表格列标题都是Object类型的数组，JTable如何显示这些Object对象？ 536
12.11.2  TableModel和监听器 541
12.11.3  TableColumnModel和监听器 545
12.11.4  实现排序 548
12.11.5  绘制单元格内容 551
12.11.6  编辑单元格内容 554
12.12  使用JFormattedTextField和JTextPane创建格式文本 557
12.12.1  监听Document的变化 558
12.12.2  使用JPasswordField 560
12.12.3  使用JFormattedTextField 560
12.12.4  使用JEditorPane 568
12.12.5  使用JTextPane 568
12.13  本章小结 575
本章练习 575
第13章　MySQL数据库与JDBC编程 576
13.1  JDBC基础 577
13.1.1  JDBC简介 577
13.1.2  JDBC驱动程序 578
13.2  SQL语法 579
13.2.1  安装数据库 579
13.2.2  关系数据库基本概念和MySQL基本命令 581
13.2.3  SQL语句基础 583
13.2.4  DDL语句 584
13.2.5  数据库约束 588
13.2.6  索引 595
13.2.7  视图 596
13.2.8  DML语句语法 597
13.2.9  单表查询 599
13.2.10  数据库函数 603
13.2.11  分组和组函数 605
13.2.12  多表连接查询 607
13.2.13  子查询 611
13.2.14  集合运算 612
13.3  JDBC的典型用法 613
13.3.1  JDBC 4.2常用接口和类简介 613
13.3.2  JDBC编程步骤 615
前面给出的仅仅是MySQL和Oracle两种数据库的驱动，我看不出驱动类字符串有什么规律啊。如果我希望使用其他数据库，那怎么找到其他数据库的驱动类呢？ 616
13.4  执行SQL语句的方式 618
13.4.1  使用Java 8新增的executeLargeUpdate方法执行DDL和DML语句 618
13.4.2  使用execute方法执行SQL语句 620
13.4.3  使用PreparedStatement执行SQL语句 621
13.4.4  使用CallableStatement调用存储过程 626
13.5  管理结果集 627
13.5.1  可滚动、可更新的结果集 627
13.5.2  处理Blob类型数据 629
13.5.3  使用ResultSetMetaData分析结果集 634
13.6  Javar的RowSet 636
13.6.1  Java 7新增的RowSetFactory与RowSet 637
13.6.2  离线RowSet 638
13.6.3  离线RowSet的查询分页 640
13.7  事务处理 641
13.7.1  事务的概念和MySQL事务支持 641
13.7.2  JDBC的事务支持 643
13.7.3  Java 8增强的批量更新 645
13.8  分析数据库信息 646
13.8.1  使用DatabaseMetaData分析数据库信息 646
13.8.2  使用系统表分析数据库信息 648
13.8.3  选择合适的分析方式 649
13.9  使用连接池管理连接 649
13.9.1  DBCP数据源 650
13.9.2  C3P0数据源 651
13.10  本章小结 651
本章练习 651
第14章　注解（Annotation） 652
14.1  基本注解 653
14.1.1  限定重写父类方法：@Override 653
14.1.2  Java 9增强的@Deprecated 654
14.1.3  抑制编译器警告：@SuppressWarnings 655
14.1.4  “堆污染”警告与Java 9增强的@SafeVarargs 655
14.1.5  Java 8的函数式接口与@FunctionalInterface 656
14.2  JDK的元注解 657
14.2.1  使用@Retention 657
14.2.2  使用@Target 658
14.2.3  使用@Documented 658
14.2.4  使用@Inherited 659
14.3  自定义注解 660
14.3.1  定义注解 660
14.3.2  提取注解信息 661
14.3.3  使用注解的示例 663
14.3.4  Java 8新增的重复注解 667
14.3.5  Java 8新增的类型注解 669
14.4  编译时处理注解 670
14.5  本章小结 674
第15章　输入/输出 675
15.1  File类 676
15.1.1  访问文件和目录 676
15.1.2  文件过滤器 678
15.2  理解Java的IO流 679
15.2.1  流的分类 679
15.2.2  流的概念模型 680
15.3  字节流和字符流 681
15.3.1  InputStream和Reader 681
15.3.2  OutputStream和Writer 683
15.4  输入/输出流体系 685
15.4.1  处理流的用法 685
15.4.2  输入/输出流体系 686
15.4.3  转换流 688
怎么没有把字符流转换成字节流的转换流呢？ 688
15.4.4  推回输入流 689
15.5  重定向标准输入/输出 690
15.6  Java虚拟机读写其他进程的数据 691
15.7  RandomAccessFile 694
15.8  Java 9改进的对象序列化 697
15.8.1  序列化的含义和意义 697
15.8.2  使用对象流实现序列化 697
15.8.3  对象引用的序列化 699
15.8.4  Java 9增加的过滤功能 703
15.8.5  自定义序列化 704
15.8.6  另一种自定义序列化机制 709
15.8.7  版本 710
15.9  NIO 711
15.9.1  Java新IO概述 711
15.9.2  使用Buffer 712
15.9.3  使用Channel 715
15.9.4  字符集和Charset 717
二进制序列与字符之间如何对应呢？ 718
15.9.5  文件锁 720
15.10  Java 7的NIO.2 721
15.10.1  Path、Paths和Files核心API 721
15.10.2  使用FileVisitor遍历文件和目录 723
15.10.3  使用WatchService监控文件变化 724
15.10.4  访问文件属性 725
15.11  本章小结 726
本章练习 727
第16章　多线程 728
16.1  线程概述 729
16.1.1  线程和进程 729
16.1.2  多线程的优势 730
16.2  线程的创建和启动 731
16.2.1  继承Thread类创建线程类 731
16.2.2  实现Runnable接口创建线程类 732
16.2.3  使用Callable和Future创建线程 733
16.2.4  创建线程的三种方式对比 735
16.3  线程的生命周期 735
16.3.1  新建和就绪状态 735
16.3.2  运行和阻塞状态 737
16.3.3  线程死亡 738
16.4  控制线程 739
16.4.1  join线程 739
16.4.2  后台线程 740
16.4.3  线程睡眠：sleep 741
16.4.4  改变线程优先级 742
16.5  线程同步 743
16.5.1  线程安全问题 743
16.5.2  同步代码块 745
16.5.3  同步方法 747
16.5.4  释放同步监视器的锁定 749
16.5.5  同步锁（Lock） 749
16.5.6  死锁 751
16.6  线程通信 753
16.6.1  传统的线程通信 753
16.6.2  使用Condition控制线程通信 756
16.6.3  使用阻塞队列（BlockingQueue）控制线程通信 758
16.7  线程组和未处理的异常 761
16.8  线程池 764
16.8.1  Java 8改进的线程池 764
16.8.2  Java 8增强的ForkJoinPool 766
16.9  线程相关类 769
16.9.1  ThreadLocal类 769
16.9.2  包装线程不安全的集合 771
16.9.3  线程安全的集合类 771
16.9.4  Java 9新增的发布-订阅框架 772
16.10  本章小结 774
本章练习 775
第17章　网络编程 776
17.1  网络编程的基础知识 777
17.1.1  网络基础知识 777
17.1.2  IP地址和端口号 778
17.2  Java的基本网络支持 779
17.2.1  使用InetAddress 779
17.2.2  使用URLDecoder和URLEncoder 780
17.2.3  URL、URLConnection和URLPermission 781
17.3  基于TCP协议的网络编程 787
17.3.1  TCP协议基础 787
17.3.2  使用ServerSocket创建TCP服务器端 788
17.3.3  使用Socket进行通信 788
17.3.4  加入多线程 791
17.3.5  记录用户信息 793
17.3.6  半关闭的Socket 801
17.3.7  使用NIO实现非阻塞Socket通信 802
17.3.8  使用Java 7的AIO实现非阻塞通信 807
上面程序中好像没用到④⑤号代码的get()方法的返回值，这两个地方不调用get()方法行吗？ 810
17.4  基于UDP协议的网络编程 814
17.4.1  UDP协议基础 814
17.4.2  使用DatagramSocket发送、接收数据 814
17.4.3  使用MulticastSocket实现多点广播 818
17.5  使用代理服务器 828
17.5.1  直接使用Proxy创建连接 829
17.5.2  使用ProxySelector自动选择代理服务器 830
17.6  本章小结 832
本章练习 832
第18章　类加载机制与反射 833
18.1  类的加载、连接和初始化 834
18.1.1  JVM和类 834
18.1.2  类的加载 835
18.1.3  类的连接 836
18.1.4  类的初始化 836
18.1.5  类初始化的时机 837
18.2  类加载器 838
18.2.1  类加载机制 838
18.2.2  创建并使用自定义的类加载器 840
18.2.3  URLClassLoader类 843
18.3  通过反射查看类信息 844
18.3.1  获得Class对象 845
18.3.2  从Class中获取信息 845
18.3.3  Java 8新增的方法参数反射 849
18.4  使用反射生成并操作对象 850
18.4.1  创建对象 850
18.4.2  调用方法 852
18.4.3  访问成员变量值 854
18.4.4  操作数组 855
18.5  使用反射生成JDK动态代理 857
18.5.1  使用Proxy和InvocationHandler创建动态代理 857
18.5.2  动态代理和AOP 859
18.6  反射和泛型 862
18.6.1  泛型和Class类 862
18.6.2  使用反射来获取泛型信息 864
18.7  本章小结 865
本章练习 866
附录A　Java 9的模块化系统 867
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>疯狂Java讲义（第4版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言程序设计
第1章 Java概述
第2章 Java语言基础
第3章 类与对象
第4章 继承与多态
第5章 Java的图形用户界面
第6章 流和文件
第7章 多线程与异常处理
第8章 APPLET
第9章 网络编程
第10章 Java与数据库的连接
第11章 Java远程方法调用
附录 JDK环境工具及其参数补充说明

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计入门
第1章 Java语言综述
第2章 Java编程环境
第3章 第一个程序分析
第4章 Java编程基本结构
第5章 流程控制
第6章 对象、包、类
第7章 数组和字符串
第8章 继承
第9章 多态
……
附录 HTML与APPLET初步

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计入门
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入浅出Java 2面向对象程序设计
第1章 认识Java
第2章 简单的Java程序
第3章 变量与数据类型
第4章 运算符、表达式与语句
第5章 循环与选择性语句
第6章 数组与函数
第7章 类的基本架构
第8章 类的其他功能
第9章 继承
第10章 抽象类与接口
……
附录A 下载与安装JDK 1.4
附录B JCreator LE的使用
附录C ASCII码表
中文索引
英文索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入浅出Java 2面向对象程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java数值方法
第一部分  正确的运算公式却导致出现错误的结果
第1章  浮点数而非实数
1.1  舍入误差
1.2  误差放大
1.3  实数和浮点数的比较
1.4  精度和准确度
1.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java数值方法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java大学教程
前言
第1章 计算机、Internet和Web简介
第2章 Jave应用程序简介
第3章 Jave小程序简介
第4章 控制结构：第一部分
第5章 控制结构：第二部分
第6章 方法
第7章 数组
第8章 基于对象的编程
第9章 面向对象的编程
第10章 串和字符
第11章 图形和Java2D
第12章 图形用户界面：第一部分
第13章 图形用户界面：第二部分
第14章 导常处理
第15章 多线程
……
附录A Java演示
附录B Java资源
附录C 操作符优先级表
……
参考文献
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java大学教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java项目开发实践
第一章  JAVA语言与面向对象设计基础
第二章  JAVA项目开发基础
第三章  自制网络聊天室
第四章  网上购物系统的JSP实现
第五章  图像编辑器
第六章  简单媒体播放器
第七章  个人日常事务管理系统
第八章  商场VIP消费情况查询系统
第九章  公司资源预约系统
第十章  图书管理系统
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java项目开发实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>从零开始学Java
第1篇 初识Java  第1章 Java语言简介    1.1 Java的起源和发展      1.1.1 Java的起源      1.1.2 Java的发展      1.1.3 Java的特性    1.2 Java的技术构成      1.2.1 Java的工作方式      1.2.2 Java开发系统的构成    1.3 Java技术的应用    1.4 小结    1.5 习题  第2章 开始Java之旅    2.1 安装和配置JDK      2.1.1 安装JDK      2.1.2 配置JDK    2.2 HelloWorld程序      2.2.1 编写源程序      2.2.2 编译源文件      2.2.3 运行程序      2.2.4 详解第一个程序    2.3 字节码的解释与执行    2.4 Java基本词汇    2.5 小结    2.6 习题  第3章 Eclipse简介    3.1 Eclipse发展历史    3.2 Eclipse的下载与安装    3.3 Eclipse基本使用      3.3.1 Eclipse界面简介      3.3.2 Eclipse的简单使用      3.3.3项目文件结构    3.4 小结    3.5 习题第2篇 Java基础知识第3篇 Java的面向对象性第4篇 实践应用第5篇 实例
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>从零开始学Java
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业级Java EE架构设计精深实践
第1章  虚拟文件系统实践
1.1  背景介绍
1.2  什么是VFS
1.3  VFS对比
1.3.1  Apache VFS
1.3.2  Tiny VFS
1.4  VFS框架设计思想
1.5  VFS实现讲解
1.5.1  VFS管理器
1.5.2  SchemaProvider模式提供者
1.5.3  FileObject虚拟文件
1.5.4  FileObjectFilter过滤接口
1.6  VFS应用示例
1.6.1  本地文件
1.6.2  Jar文件
1.6.3  FTP文件
1.6.4  ZIP文件
1.7  本章总结
第2章  缓存实践
2.1  缓存简介
2.1.1  问题的提出及其解决方案分析
2.1.2  用户需求
2.1.3  Tiny缓存解决思路
2.2  字节码缓存设计
2.2.1  字节码操作工程
2.2.2  预编译工程
2.2.3  缓存实现工程
2.2.4  技术特点
2.3  动态代理缓存设计
2.3.1  缓存接口定义
2.3.2  切面缓存工程
2.3.3  技术特点
2.4  缓存方案实践
2.4.1  字节码方案配置
2.4.2  字节码方案示例
2.4.3  动态代理方案配置
2.4.4  动态代理方案示例
2.5  本章总结
2.5.1  关键点：缓存实现方案的可替换性
2.5.2  关键点：缓存代码与业务代码的解耦
2.5.3  关键点：模板语言的应用
第3章  文件处理框架实践
3.1  概述
3.1.1  FileProcessor接口
3.1.2  FileResolver接口
3.1.3  FileMonitorProcessor类
3.2  基础文件扫描器
3.2.1  XStreamFileProcessor类
3.2.2  I18nFileProcessor类
3.2.3  Annotation扫描器
3.2.4  SpringBeansFileProcessor类
3.3  完整示例
3.3.1  单独使用
3.3.2  通过配置文件配置
3.4  本章总结
第4章  模板语言实践
4.1  模板语言简介
4.1.1  模板语言构成
4.1.2  模板语言应用场景
4.2  常见的模板语言
4.2.1  Velocity模板语言
4.2.2  FreeMarker模板语言
4.2.3  Tiny模板语言
4.3  Tiny模板语言设计
4.3.1  Tiny模板语言的构建原因
4.3.2  模板语言执行方式
4.3.3  模板语言架构
4.3.4  Tiny模板语言实现与扩展
4.3.5  模板语言语法解析
4.3.6  模板语言渲染机制
4.4  模板语言的使用
4.4.1  依赖配置
4.4.2  模板语言的配置
4.4.3  模板语言的Eclipse插件
4.4.4  Hello,TinyTemplate
4.5  模板语言语法介绍
4.5.1  变量
4.5.2  取值表达式
4.5.3  Map常量
4.5.4  数组常量
4.5.5  其他表达式
4.5.6  索引表达式
4.5.7  #set指令
4.5.8  条件判断
4.5.9  ==相等运算
4.5.10  AND运算
4.5.11  OR运算
4.5.12  NOT运算
4.5.13  循环语句
4.5.14  循环状态变量
4.5.15  循环中断：#break
4.5.16  循环继续：# continue
4.5.17  while循环
4.5.18  模板嵌套语句#include
4.5.19  宏定义语句#macro
4.5.20  宏引入语句#import
4.5.21  布局重写语句#layout #@layout
4.5.22  停止执行#stop
4.5.23  返回指令#return
4.5.24  行结束指令
4.5.25  读取文本资源函数read和readContent
4.5.26  解析模板parser
4.5.27  格式化函数fmt、format和formatter
4.5.28  宏调用方法call和callMacro
4.5.29  实例判断函数is、instanceOf和instance
4.5.30  求值函数eval和evaluate
4.5.31  随机数函数rand和random
4.5.32  类型转换函数
4.5.33  日期格式转换formatDate
4.6  模板语言扩展
4.6.1  资源加载器的使用
4.6.2  宏的使用
4.6.3  函数的使用
4.6.4  国际化的使用
4.6.5  静态类和静态方法的使用
4.6.6  Servlet集成
4.6.7  SpringMVC集成
4.7  本章总结
第5章  数据库访问层实践
5.1  数据访问层简介
5.2  常见数据库访问层介绍
5.2.1  Hibernate简介
5.2.2  Ibatis简介
5.2.3  JPA简介
5.2.4  DSL数据库访问层简介
5.3  TinyDsl设计方案
5.3.1  SQL抽象化设计
5.3.2  DSL风格SQL设计
5.3.3  SQL执行接口设计
5.3.4  执行接口实现介绍
5.4  数据库访问层示例
5.4.1  工程创建
5.4.2  准备工作
5.4.3  Hibernate示例
5.4.4  Ibatis示例
5.4.5  JPA示例
5.4.6  TinyDsl示例
5.5  本章总结
第6章  数据库扩展实践
6.1  数据库扩展简介
6.2  常见数据库扩展方案
6.2.1  DAO层
6.2.2  DataSource层
6.2.3  JDBC层
6.2.4  Proxy层
6.3  读写分离
6.3.1  读写分离
6.3.2  负载均衡
6.3.3  数据同步
6.4  分库分表
6.4.1  同库分表
6.4.2  不同库分表
6.5  开源方案介绍
6.5.1  TDDL
6.5.2  Routing4DB
6.5.3  TinyDbRouter
6.5.4  开源方案的对比
6.6  TinyDbRouter的设计和实现
6.6.1  设计目标
6.6.2  设计原理之接入层设计
6.6.3  设计原理之SQL解析层设计
6.6.4  设计原理之路由决策层设计
6.6.5  设计原理之执行层设计
6.6.6  实现
6.7  应用实践
6.7.1  读写分离示例
6.7.2  分库分表示例
6.7.3  集群事务示例
6.7.4  元数据示例
6.7.5  自定义扩展
6.7.6  常见FAQ
6.8  本章总结
第7章  服务层实践
7.1  服务层简介
7.1.1  传统服务层
7.1.2  Tiny服务层
7.2  Tiny服务层介绍
7.2.1  服务声明
7.2.2  服务注册
7.2.3  小结
7.3  本地服务层实践
7.3.1  服务描述
7.3.2  服务定义
7.3.3  服务收集与注册
7.3.4  服务执行
7.3.5  小结
7.4  远程服务实践
7.4.1  传统的远程服务
7.4.2  新的远程服务模式
7.4.3  多服务中心支持
7.4.4  新的远程服务实现
7.4.5  小结
7.5  本地服务调用示例
7.5.1  非Tiny框架调用示例
7.5.2  Tiny框架应用调用
7.6  远程服务配置示例
7.6.1  非Tiny框架配置示例
7.6.2  Tiny框架应用配置
7.7  本章总结
第8章  流程引擎实践
8.1  流程引擎简介
8.1.1  流程引擎的来历
8.1.2  解决方案
8.1.3  特性简介
8.2  流程引擎实现
8.2.1  流程组件
8.2.2  流程组件配置
8.2.3  流程组件管理
8.2.4  流程配置
8.2.5  流程管理
8.2.6  流程执行
8.3  流程引擎特性
8.3.1  流程可继承性
8.3.2  灵活的EL表达式
8.3.3  流程可重入
8.3.4  流程可转出
8.3.5  强大异常处理
8.4  流程编辑器
8.4.1  创建流程
8.4.2  界面说明
8.4.3  操作说明
8.5  本章总结
第9章  元数据实践
9.1  元数据简介
9.1.1  问题背景
9.1.2  解决途径
9.2  基础元数据设计
9.2.1  支持语言类型
9.2.2  标准数据类型
9.2.3  业务数据类型
9.2.4  标准字段
9.3  数据库元数据设计
9.3.1  表及索引
9.3.2  视图
9.4  元数据开发指南
9.4.1  元数据加载机制
9.4.2  元数据处理器
9.5  元数据开发实践
9.5.1  Eclipse插件
9.5.2  应用配置
9.5.3  生成方言模板
9.5.4  生成标准数据类型
9.5.5  生成业务数据类型
9.5.6  生成标准字段
9.5.7  生成数据库表
9.5.8  定义元数据
9.5.9  生成Java代码
9.5.10  生成SQL
9.6  本章总结
第10章  展现层开发实践
10.1  展示层简介
10.1.1  Servlet
10.1.2  JSP
10.1.3  模板语言
10.1.4  展示层常见问题
10.2  展示层方案设计
10.2.1  UI组件包开发
10.2.2  资源合并实践
10.2.3  避免重复代码
10.2.4  国际化问题
10.3  前端访问方案实践
10.3.1  组件包封装
10.3.2  宏接口定义
10.3.3  页面和布局编写
10.3.4  前端参数配置
10.4  本章总结
10.4.1  关键点：DRY原则的实现
10.4.2  关键点：JS文件的合并
10.4.3  关键点：CSS文件的合并
第11章  Web扩展实践
11.1  背景简介
11.2  监听器设计原理
11.2.1  应用配置管理
11.2.2  应用处理器（ApplicationProcessor）
11.2.3  Web监听器
11.2.4  监听器配置管理
11.3  过滤器设计原理
11.3.1  请求上下文（WebContext）
11.3.2  TinyFilter介绍
11.4  处理器设计原理
11.4.1  过滤器配置（TinyProcessorConfig）
11.4.2  过滤器配置管理（TinyProcessorConfigManager）
11.4.3  处理器管理接口（TinyProcessorManager)
11.5  BasicTinyFilter类
11.5.1  拦截器接口
11.5.2  默认拦截器
11.6  SetLocaleTinyFilter类
11.6.1  Locale基础
11.6.2  Charset编码基础
11.6.3  Locale和charset的关系
11.6.4  设置locale和charset
11.6.5  使用方法
11.7  ParserTinyFilter类
11.7.1  基本使用方法
11.7.2  上传文件
11.7.3  高级选项
11.8  BufferedTinyFilter类
11.8.1  实现原理
11.8.2  使用方法
11.8.3  关闭buffer机制
11.9  LazyCommitTinyFilter类
11.9.1  什么是提交
11.9.2  实现原理
11.9.3  使用方法
11.10  RewriteTinyFilter类
11.10.1  概述
11.10.2  取得路径
11.10.3  匹配rules
11.10.4  匹配conditions
11.10.5  替换路径
11.10.6  替换参数
11.10.7  后续操作
11.10.8  重定向
11.10.9  自定义处理器
11.11  SessionTinyFilter类
11.11.1  概述
11.11.2  Session框架
11.11.3  Cookie Store
11.11.4  总结
11.12  SpringMVCTinyProcessor介绍
11.12.1  基于扩展协议的内容协商
11.12.2  约定开发
11.12.3  扩展协议
11.13  TinyWeb实践
11.13.1  准备工作
11.13.2  使用TinyHttpFilter
11.13.3  使用TinyProcessor
11.14  本章总结
第12章  Tiny统一界面框架实践
12.1  UIML简介
12.2  UIML开发指南
12.3  UIML使用实践
12.4  常见FAQ
12.5  本章总结
第13章  RESTful实践
13.1  RESTful简介
13.2  Spring RESTful实践
13.3  Tiny RESTful风格实践
13.4  Tiny RESTful实践
13.5  本章总结
附录A  相关资源
附录B  配置运行指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业级Java EE架构设计精深实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java开发实例大全（基础卷）
第1篇  Java语法与面向对象技术
第1章  开发环境的应用
1.1  Java环境
实例001  下载JDK开发工具包
实例002  把JDK工具包安装到指定磁盘
实例003  设置JDK的环境变量
实例004  验证Java开发环境
实例005  下载并安装JRE执行环境
实例006  编程输出星号组成的等腰三角形
1.2  开发工具
实例007  下载最新的Eclipse
实例008  为最新的Eclipse安装中文语言包
实例009  活用Eclipse的工作空间
实例010  在Eclipse项目中编程输出字符表情
实例011  为Eclipse添加新的JDK环境
实例012  将已有项目导入到Eclipse
实例013  为项目添加类库
实例014  使当前项目依赖另一个项目
1.3  界面设计器
实例015  安装界面设计器
实例016  设计Windows系统的运行对话框界面
实例017  设计计算器程序界面
实例018  设计关于进销存管理系统的界面
第2章  Java基础应用
2.1  基本语法
实例019  输出错误信息与调试信息
实例020  从控制台接收输入字符
实例021  重定向输出流实现程序日志
实例022  自动类型转换与强制类型转换
2.2  运算符
实例023  加密可以这样简单（位运算）
实例024  用三元运算符判断奇数和偶数
实例025  更精确地使用浮点数
实例026  不用乘法运算符实现2×16
实例027  实现两个变量的互换（不借助第3个变量）
2.3  条件语句
实例028  判断某一年是否为闰年
实例029  验证登录信息的合法性
实例030  为新员工分配部门
实例031  使用Switch语句根据消费金额计算折扣
实例032  判断用户输入月份的季节
2.4  循环控制
实例033  使用while与自增运算符循环遍历数组
实例034  使用for循环输出杨辉三角
实例035  使用嵌套循环在控制台上输出九九乘法表
实例036  用while循环计算1+1/2!+1/3!…1/20!
实例037  for循环输出空心的菱形
实例038  foreach循环优于for循环
实例039  终止循环体
实例040  循环体的过滤器
实例041  循环的极限
第3章  数组与集合的应用
3.1  数组演练
实例042  获取一维数组最小值
实例043  将二维数组中的行列互换
实例044  利用数组随机抽取幸运观众
实例045  用数组设置JTable表格的列名与列宽
3.2  数组操作
实例046  数组的下标界限
实例047  按钮控件数组实现计数器界面
实例048  复选框控件数组
实例049  用数组反转字符串
3.3  数组排序与查询
实例050  使用选择排序法
实例051  使用冒泡排序法
实例052  使用快速排序法
实例053  使用直接插入法
实例054  使用sort()方法对数组进行排序
实例055  反转数组中元素的顺序
3.4  常用集合的使用
实例056  用动态数组保存学生姓名
实例057  用List集合传递学生信息
实例058  用TreeSet生成不重复自动排序的随机数组
实例059  Map映射集合实现省市级联选择框
第4章  字符串处理技术
4.1  格式化字符串
实例060  把数字格式化为货币字符串
实例061  格式化当前日期
实例062  货币金额大写格式
实例063  String类格式化当前日期
实例064  字符串大小写转换
实例065  字符与Unicode码的转换
4.2  辨别字符串
实例066  判断用户名是否正确
实例067  用户名排序
实例068  判断网页请求与FTP请求
实例069  判断文件类型
实例070  判断字符串是否为数字
实例071  验证IP地址的有效性
实例072  鉴别非法电话号码
4.3  操作字符串
实例073  根据标点符号对字符串进行分行
实例074  将字符串的每个字符进行倒序输出
实例075  获取字符串中汉字的个数
实例076  批量替换某一类字符串
实例077  把异常与错误信息显示到窗体中
实例078  从字符串中分离文件路径、文件名及扩展名
实例079  判断手机号的合法性
实例080  用字符串构建器追加字符
实例081  去掉字符串中的所有空格
实例082  汉字与区位码的转换
第5章  面向对象技术应用
5.1  Java中类的定义
实例083  自定义图书类
实例084  温度单位转换工具
实例085  域的默认初始化值
实例086  编写同名的方法
实例087  构造方法的应用
5.2  修饰符的使用
实例088  单例模式的应用
实例089  祖先的止痒药方
实例090  统计图书的销售量
实例091  汉诺塔问题求解
实例092  不能重写的方法
5.3  包装类的使用
实例093  将字符串转换成整数
实例094  整数进制转换器
实例095  查看数字的取值范围
实例096  ASCII编码查看器
实例097  Double类型的比较
5.4  面向对象的特征
实例098  经理与员工的差异
实例099  重写父类中的方法
实例100  计算几何图形的面积
实例101  提高产品质量的方法
实例102  简单的汽车销售商场
5.5  Object类的应用
实例103  两只完全相同的宠物
实例104  简化equals()方法的重写
实例105  重新计算对象的哈希码
实例106  简化hashCode()方法的重写
实例107  使用字符串输出对象
实例108  简化toString()方法的重写
5.6  克隆与序列化
实例109  Java对象的假克隆
实例110  Java对象的浅克隆
实例111  Java对象的深克隆
实例112  序列化与对象克隆
实例113  深克隆效率的比较
实例114  transient关键字的应用
5.7  接口和内部类
实例115  使用sort()方法排序
实例116  简化compareTo()方法的重写
实例117  策略模式的简单应用
实例118  适配器模式的简单应用
实例119  普通内部类的简单应用
实例120  局部内部类的简单应用
实例121  匿名内部类的简单应用
实例122  静态内部类的简单应用
第2篇  Java高级应用
第6章  枚举与泛型的应用
6.1  枚举使用简介
实例123  查看枚举类型的定义
实例124  枚举类型的基本特性
实例125  增加枚举元素的信息
实例126  选择合适的枚举元素
实例127  高效的枚举元素集合
实例128  高效的枚举元素映射
实例129  遍历枚举接口的元素
实例130  简单的文件合并工具
6.2  泛型使用简介
实例131  自定义非泛型栈结构
实例132  使用泛型实现栈结构
实例133  自定义泛型化数组类
实例134  泛型方法与数据查询
实例135  泛型化方法与最小值
实例136  泛型化接口与最大值
实例137  使用通配符增强泛型
实例138  泛型化的折半查找法
第7章  反射与异常处理
7.1  反射的基础
实例139  实例化Class类的5种方式
实例140  获得Class对象表示实体的名称
实例141  查看类的声明
实例142  查看类的成员
实例143  按继承层次对类排序
实例144  查看内部类信息
7.2  反射的进阶
实例145  动态设置类的私有域
实例146  动态调用类中的方法
实例147  动态实例化类
实例148  创建长度可变的数组
实例149  利用反射重写toString()方法
实例150  反射与动态代理
7.3  常见的未检查型异常
实例151  算数异常
实例152  数组存值异常
实例153  数组下标越界异常
实例154  空指针异常
7.4  常见的已检查型异常
实例155  类未发现异常
实例156  非法访问异常
实例157  文件未发现异常
实例158  数据库操作异常
7.5  处理异常
实例159  方法中抛出异常
实例160  方法上抛出异常
实例161  自定义异常类
实例162  捕获单个异常
实例163  捕获多个异常
第8章  多线程技术
8.1  线程的基础
实例164  新建无返回值的线程
实例165  查看线程的运行状态
实例166  查看JVM中的线程名
实例167  查看和修改线程名称
实例168  查看和修改线程优先级
实例169  使用守护线程
实例170  休眠当前线程
实例171  终止指定线程
实例172  线程的插队运行
8.2  线程的同步
实例173  非同步的数据读写
实例174  使用方法实现线程同步
实例175  使用代码块实现线程同步
实例176  使用特殊域变量实现线程同步
实例177  使用重入锁实现线程同步
实例178  使用线程局部变量实现线程同步
实例179  简单的线程通信
实例180  简单的线程死锁
实例181  解决线程的死锁问题
8.3  线程的进阶
实例182  使用阻塞队列实现线程同步
实例183  新建有返回值的线程
实例184  使用线程池优化多线程编程
实例185  Object类中线程相关的方法
实例186  哲学家就餐问题
实例187  使用信号量实现线程同步
实例188  使用原子变量实现线程同步
实例189  使用事件分配线程更新Swing控件
实例190  使用SwingWorker类完成耗时操作
第9章  编程常用类
9.1  Calendar类的使用
实例191  简单的数字时钟
实例192  简单的电子时钟
实例193  简单的模拟时钟
实例194  简单的公历万年历
实例195  查看生日相关信息
9.2  SimpleDateFormat与TimeZone类的使用
实例196  日期格式有效性判断
实例197  常见日期格式使用
实例198  查看本地时区
实例199  简单的时区转换工具
9.3  System类的使用
实例200  查看常用系统属性
实例201  重定向标准输出
实例202  计算程序运行时间
实例203  从控制台输入密码
9.4  Math类的使用
实例204  角度和弧度的转换
实例205  三角函数的使用
实例206  反三角函数的使用
实例207  双曲函数的使用
实例208  指数与对数运算
9.5  其他常用类的使用
实例209  高精度整数运算
实例210  高精度浮点运算
实例211  七星彩号码生成器
实例212  大乐透号码生成器
实例213  监视JVM内存状态
实例214  启动默认文本工具
实例215  简单的截图软件
第10章  Commons组件
10.1  Commons Lang组件简介
实例216  数组元素的增加
实例217  数组元素的删除
实例218  生成随机字符串
实例219  序列化与反序列化
实例220  分数的常见运算
实例221  整数取值范围判断
10.2  Commons Math组件简介
实例222  描述统计学应用
实例223  绘制简单直方图
实例224  一元线性回归计算
实例225  实数矩阵的运算
实例226  复数的常见运算
实例227  T分布常用计算
10.3  Commons IO组件简介
实例228  简化文件（夹）删除
实例229  简化文件（夹）复制
实例230  简化文件（夹）排序
实例231  简化文件（夹）过滤
实例232  简化文件的读写操作
10.4  Commons BeanUtils组件简介
实例233  设置JavaBean简单属性
实例234  设置JavaBean级联属性
实例235  动态生成JavaBean
实例236  复制JavaBean属性
实例237  动态排序JavaBean
10.5  其他Commons组件简介
实例238  优雅的JDBC代码
实例239  结果集与Bean列表
实例240  编写MD5查看器
实例241  基于Base64编码
实例242  基于Base64解码
实例243  发送简单的E-mail
实例244  发送带附件的E-mail
实例245  读取XML文件属性
第3篇  窗体与控件应用
第11章  窗体设计
11.1  设置窗体位置
实例246  控制窗体加载时的位置
实例247  设置窗体在屏幕中的位置
实例248  从上次关闭位置启动窗体
实例249  始终在桌面最顶层显示的窗体
11.2  调整窗体大小
实例250  设置窗体大小
实例251  根据桌面大小调整窗体大小
实例252  自定义最大化、最小化和关闭按钮
实例253  禁止改变窗体的大小
11.3  设置窗体的标题栏
实例254  指定窗体标题栏图标
实例255  拖动没有标题栏的窗体
实例256  取消窗体标题栏与边框
实例257  设置闪烁的标题栏
11.4  设置窗体的背景
实例258  设置窗体背景颜色为淡蓝色
实例259  实现带背景图片的窗体
实例260  使背景图片自动适应窗体的大小
实例261  背景为渐变色的主界面
实例262  随机更换窗体背景
11.5  窗体形状及应用
实例263  椭圆形窗体界面
实例264  钻石形窗体
实例265  创建透明窗体
11.6  对话框
实例266  模态对话框与非模态对话框
实例267  信息提示对话框
实例268  设置信息提示对话框的图标
实例269  文件选择对话框指定数据库备份文件
实例270  指定打开对话框的文件类型
实例271  文件的保存对话框
实例272  为保存对话框设置默认文件名
实例273  支持图片预览的文件选择对话框
实例274  颜色选择对话框
实例275  信息输入对话框
实例276  定制信息对话框
11.7  MDI窗体的使用
实例277  创建内部子窗体
实例278  使子窗体最大化显示
实例279  对子窗体进行平铺排列
实例280  禁用MDI窗体控制栏中的“最大化”按钮
第12章  窗体特效
12.1  让窗体更有活力
实例281  右下角弹出信息窗体
实例282  淡入淡出的窗体
实例283  窗体顶层的进度条
实例284  设置窗体的鼠标光标
实例285  窗体抖动
实例286  窗体标题显示计时器
实例287  动态展开窗体
实例288  仿QQ隐藏窗体
实例289  窗体百叶窗登场特效
实例290  关闭窗体打开网址
12.2  窗体与控件外观
实例291  Nimbus外观
实例292  本地系统外观
实例293  分割的窗体界面
实例294  圆周运动的窗体
第13章  基本控件应用
13.1  顶层容器的应用
实例295  框架容器的背景图片
实例296  更多选项的框架容器
实例297  拦截事件的玻璃窗格
实例298  简单的每日提示信息
实例299  震动效果的提示信息
13.2  布局管理器应用
实例300  边框布局的简单应用
实例301  流式布局的简单应用
实例302  网格布局的简单应用
实例303  制作圆形布局管理器
实例304  制作阶梯布局管理器
13.3  输入控件的应用
实例305  可以打开网页的标签
实例306  密码域控件的简单应用
实例307  给文本域设置背景图片
实例308  给文本区设置背景图片
实例309  简单的字符统计工具
13.4  选择控件的应用
实例310  能预览图片的复选框
实例311  简单的投票计数软件
实例312  单选按钮的简单应用
实例313  能显示图片的组合框
实例314  使用滑块来选择日期
13.5  菜单控件的应用
实例315  模仿记事本的菜单栏
实例316  自定义纵向的菜单栏
实例317  复选框与单选按钮菜单
实例318  包含图片的弹出菜单
实例319  工具栏的实现与应用
13.6  其他技术的应用
实例320  自定义软件安装向导
实例321  查看系统支持的外观
实例322  制作软件的闪屏界面
实例323  自定义系统托盘图标
实例324  使用撤销与重做功能
第14章  复合数据类型控件应用
14.1  列表的简单应用
实例325  修改列表项显示方式
实例326  修改列表项选择模式
实例327  列表项的全选与不选
实例328  列表元素与提示信息
实例329  监听列表项单击事件
实例330  监听列表项双击事件
14.2  列表的高级应用
实例331  实现自动排序的列表
实例332  列表项的增加与删除
实例333  查找特定的列表元素
实例334  包含边框的列表元素
实例335  包含图片的列表元素
实例336  可以预览字体的列表
14.3  表格的简单应用
实例337  表头与列的高度设置
实例338  调整表格各列的宽度
实例339  设置表格的选择模式
实例340  为表头增添提示信息
实例341  单元格的粗粒度排序
实例342  实现表格的查找功能
14.4  表格的高级应用
实例343  在表格中应用组合框
实例344  删除表格中选中的行
实例345  实现表格的分页技术
实例346  为单元格绘制背景色
实例347  实现表格的栅栏效果
实例348  单元格的细粒度排序
14.5  树控件简单应用
实例349  编写中国省市信息树
实例350  树控件常用遍历方式
实例351  自定义树节点的图标
实例352  监听节点的选择事件
实例353  设置树控件选择模式
实例354  查看节点的各种状态
14.6  树控件高级应用
实例355  在树控件中增加节点
实例356  在树控件中删除节点
实例357  在树控件中查找节点
实例358  自定义树节点的外观
实例359  为树节点增加提示信息
实例360  双击编辑树节点功能
第15章  其他高级控件应用
15.1  JTextPane控件的应用
实例361  自定义文档标题的样式
实例362  文档中显示自定义图片
实例363  检查代码中的括号是否匹配
实例364  描红显示100以内的质数
15.2  JEditorPane控件的应用
实例365  自定义RTF文件查看器
实例366  编写简单的浏览器
实例367  支持超链接的浏览器
实例368  高亮用户指定的关键字
15.3  其他文本控件的应用
实例369  只能输入整数的文本域
实例370  强制输入合法的整数
实例371  使用微调控件调整时间
实例372  使用微调控件浏览图片
15.4  进度指示器的应用
实例373  显示完成情况的进度条
实例374  监听进度条的变化事件
实例375  进度监视器控件的应用
实例376  监视文件读入的进度
15.5  控件组织器的应用
实例377  分割面板的简单应用
实例378  为选项卡增加快捷键
实例379  为选项卡标题设置图标
实例380  记录选项卡的访问状态
第16章  控件特效与自定义控件
16.1  控件边框效果
实例381  实现标签控件的立体边框
实例382  实现按钮控件边框留白
实例383  实现文本域控件的浮雕化边框
实例384  为文本框控件添加LineBorder线形边框
实例385  控件的纯色边框与图标边框
实例386  实现带标题边框的面板容器
实例387  指定字体的标题边框
实例388  嵌套的标题边框
实例389  带图标边框的标题边框
实例390  文本框的下划线边框
16.2  控件渲染让界面UI更灵活
实例391  支持图标的列表控件
实例392  在列表控件中显示单选按钮
实例393  列表控件折行显示列表项
实例394  使用图片制作绚丽按钮
实例395  实现按钮关键字描红
实例396  忙碌的按钮控件
实例397  实现透明效果的表格控件
实例398  在表格中显示工作进度百分比
实例399  在表格中显示图片
16.3  让控件活起来
实例400  鼠标经过时按钮放大效果
实例401  迟到的登录按钮
实例402  焦点按钮的缩放
实例403  标签文本的跑马灯特效
实例404  延迟生效的按钮
实例405  动态加载表格数据
16.4  自定义控件
实例406  石英钟控件
实例407  IP输入文本框控件
实例408  日历控件
实例409  平移面板控件
实例410  背景图面板控件
第4篇  文件操作典型应用
第17章  文件与文件夹操作
17.1  文件操作
实例411  修改文件属性
实例412  显示指定类型的文件
实例413  以树结构显示文件路径
实例414  查找替换文本文件内容
实例415  支持图片预览的文件选择对话框
实例416  设置Windows的文件属性
实例417  文件批量重命名
实例418  快速批量移动文件
实例419  删除磁盘中所有的.tmp临时文件
17.2  文件与数据库
实例420  提取数据库内容到文件
实例421  提取文本文件的内容到MySQL数据库
实例422  将图片文件保存到SQL Server数据库
实例423  显示数据库中的图片信息
实例424  提取技术网站数据到文件夹
实例425  读取文件路径到数据库
实例426  在数据库中建立磁盘文件索引
17.3  操作磁盘文件夹
实例427  窗体动态加载磁盘文件
实例428  删除文件夹中的所有文件
实例429  创建磁盘索引文件
实例430  快速全盘查找文件
实例431  获取磁盘所有文本文件
实例432  网络文件夹备份
第18章  文件的读取、写入、整理和控制
18.1  文件的读取与写入
实例433  将键盘录入内容保存到文本文件中
实例434  将数组写入文件中并逆序输出
实例435  利用StringBuffer避免文件的多次写入
实例436  合并多个txt文件
实例437  实现文件简单加密与解密
实例438  对大文件实现分割处理
实例439  将分割后的文件重新合并
实例440  读取属性文件的单个属性值
实例441  向属性文件中添加信息
实例442  在复制文件时使用进度条
实例443  从XML文件中读取数据
实例444  读取Jar文件属性
实例445  电子通讯录
18.2  实现文件整理
实例446  批量复制指定扩展名的文件
实例447  计数器小程序
实例448  将某文件夹中的文件进行分类存储
18.3  文件控制
实例449  利用StreamTokenizer统计文件的字符数
实例450  在指定目录下搜索文件
实例451  序列化与反序列化对象
实例452  文件锁定
实例453  投票统计
第19章  文件压缩
19.1  Java实现文件压缩
实例454  压缩所有文本文件
实例455  压缩包解压到指定文件夹
实例456  压缩所有子文件夹
实例457  深层文件夹压缩包的释放
实例458  解决压缩包中文乱码
实例459  Apache实现文件解压缩
实例460  把窗体压缩成ZIP文件
实例461  解压缩Java对象
19.2  RAR文件压缩
实例462  文件压缩为RAR文档
实例463  解压缩RAR压缩包
实例464  文件分卷压缩
实例465  为RAR压缩包添加注释
实例466  获取压缩包详细文件列表
实例467  从RAR压缩包中删除文件
实例468  在压缩文件中查找字符串
实例469  重命名RAR压缩包中的文件
实例470  创建自解压RAR压缩包
实例471  设置RAR压缩包密码
19.3  数据压缩的网络应用
实例472  以压缩格式传输网络数据
实例473  压缩远程文件夹
实例474  压缩存储网页
第20章  操作办公文档
20.1  操作Word
实例475  将文本文件导入Word中
实例476  浏览本地Word文件
实例477  将员工表插入Word文档中
实例478  将员工照片插入Word简历中
实例479  将Word文档保存为HTML格式
20.2  操作Excel
实例480  将员工信息保存到Excel表中
实例481  通过Excel公式计算出商品表中的总售价
实例482  将数据库表中的内容写入Excel中
实例483  将Excel表中的内容保存到数据库
实例484  将Excel文件转换为HTML格式
20.3  操作PDF
实例485  应用iText组件生成PDF
实例486  在窗体中显示PDF文件
实例487  应用PDF Renderer组件实现放大PDF文件
实例488  应用PDF Renderer组件实现缩小PDF文件
实例489  应用PDF Renderer组件实现抓手功能
实例490  全屏显示PDF文件
第5篇  数据库应用
第21章  数据库操作
21.1  通过JDBC-ODBC桥连接数据库
实例491  通过JDBC-ODBC桥连接SQL Server2000数据库
实例492  JDBC-ODBC桥连接Access数据库
实例493  JDBC-ODBC桥与Oracle数据库建立连接
21.2  JDBC技术连接数据库
实例494  通过JDBC连接SQL Server 2000数据库
实例495  JDBC连接MySQL数据库
实例496  JDBC连接SQL Server 2005数据库
实例497  JDBC技术连接Oracle数据库
实例498  JDBC连接JavaDB数据库
21.3  数据库与数据表
实例499  列举SQL Server数据库下的数据表
实例500  列举MySQL数据库下的数据表
实例501  查看数据表结构
实例502  动态维护投票数据库
实例503  SQL Server数据备份
实例504  SQL Server数据恢复
实例505  MySQL数据备份
实例506  MySQL数据恢复
实例507  动态附加数据库
实例508  生成SQL数据库脚本
实例509  获取SQL Server数据表字段的描述信息
21.4  数据增加、更新与删除操作
实例510  将员工信息添加到数据表
实例511  添加数据时使用数据验证
实例512  插入用户登录日志信息
实例513  生成有规律的编号
实例514  生成无规律的编号
实例515  在插入数据时过滤掉危险字符
实例516  将用户选择的爱好以字符串形式保存到数据库
实例517  将数据从一张表复制到另一张表
实例518  使用UNION ALL语句批量插入数据
实例519  更新指定记录
实例520  在删除数据时给出提示信息
实例521  将数据表清空
实例522  字符串大小写转换
第22章  SQL应用
22.1  排序和分组函数应用
实例523  对数据进行降序查询
实例524  对数据进行多条件排序查询
实例525  对统计结果进行排序
实例526  查询SQL Server数据库中的前3条数据
实例527  查询SQL Server数据库中的后3条数据
实例528  查询MySQL数据库中的前3条数据
实例529  查询MySQL数据库中的后3条数据
实例530  按照字母顺序对留学生表进行排序
实例531  按姓氏笔画排序
实例532  将汉字按音序排序
实例533  按列的编号排序
实例534  从表中随机返回记录
实例535  使用GROUP BY子句实现对数据的分组统计
实例536  使用GROUP BY子句实现多表分组统计
22.2  聚集函数与日期查询
实例537  利用SUM()函数实现数据汇总
实例538  利用AVG()函数实现计算平均值
实例539  利用MIN()函数求数据表中的最小值
实例540  利用MAX()函数求数据表中的最大值
实例541  利用COUNT()函数求销售额大于某值的图书种类
实例542  查询编程词典6月的销售量
实例543  查询与张静同一天入职的员工信息
实例544  使用IN谓词查询某几个时间的数据
实例545  日期查询中避免千年虫问题
22.3  大小比较与逻辑应用
实例546  在查询结果中不显示重复记录
实例547  使用NOT查询不满足条件的记录
实例548  使用between进行区间查询
实例549  列出销量表中的重复记录和记录条数
实例550  使用关系运算符查询某一时间段数据
实例551  计算两个日期之间的月份数
实例552  格式化金额
实例553  在查询语句中过滤掉字符串中的空格
第23章  数据查询
23.1  使用子查询
实例554  将子查询作为表达式
实例555  用子查询作为派生表
实例556  通过子查询关联数据
实例557  使用IN谓词限定查询范围
实例558  使用NOT IN子查询实现差集运算
实例559  使用NOT IN子查询实现反向查询
实例560  返回笛卡儿乘积
实例561  比较运算符引入子查询
实例562  在子查询中使用聚集函数
实例563  在删除数据时使用子查询
23.2  嵌套查询
实例564  查询平均成绩在85分以上的学生信息
实例565  查询本科部门经理月收入情况
实例566  在嵌套中使用EXISTS关键字
实例567  动态指定查询条件
23.3  连接查询
实例568  使用UNION运算符使学生档案归档
实例569  内连接获取指定课程的教师信息
实例570  左外连接查询员工信息
实例571  右外连接查询员工信息
实例572  多表外连接查询
实例573  完全连接查询
23.4  函数查询
实例574  在查询中使用patindex()函数进行模糊查询
实例575  对查询结果进行格式化
实例576  在查询中使用字符串函数
实例577  在查询中使用ALL谓词
实例578  在查询中使用ANY谓词
实例579  使用UNION运算符消除重复的行
实例580  使用UNION ALL运算符保留重复的行
实例581  计算商品销售额所占的百分比
第24章  数据库高级应用
24.1  在Java程序中使用存储过程
实例582  调用存储过程实现用户身份验证
实例583  应用存储过程添加数据
实例584  调用加密存储过程
实例585  获取数据库中所有存储过程
实例586  修改存储过程
实例587  删除存储过程
24.2  使用触发器
实例588  应用触发器添加日志信息
实例589  在删除成绩表时将学生表中的数据删除
实例590  在程序中调用UPDATE触发器
实例591  获取数据库中的触发器名称
实例592  创建带有触发条件的触发器
24.3  使用批处理
实例593  使用批处理删除数据
实例594  使用批处理提升部门员工工资
实例595  将教师表中的数据全部添加到选课表
实例596  在批处理中使用事务
24.4  使用视图
实例597  创建视图
实例598  使用视图过滤不想要的数据
实例599  使用视图与计算数据
实例600  使用视图重新格式化检索出来的数据
实例601  获取数据库中的全部用户视图
实例602  修改视图
实例603  删除视图
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java开发实例大全（基础卷）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE 7 & HTML5应用开发
《Java EE 7 & HTML5应用开发——构建和部署同时支持桌面和移动设备的动态、高性能企业级应用》
第1章 Java EE和HTML5企业开发简介	1
1.1 开发工具	2
1.1.1 NetBeans	2
1.1.2 Java EE 7	3
1.1.3 HTML5	7
1.2 本章小结	14
第2章 持久性	15
2.1 JPA实体	17
2.2 封装实体	24
2.3 管理实体	27
2.3.1 Java持久性查询语言	31
2.3.2 条件查询	33
2.3.3 本地SQL	34
2.3.4 模式生成	38
2.4 本章小结	41
第3章 RESTful资源	43
3.1 REST原则	44
3.2 用于RESTful Web服务的Java API	45
3.2.1 JAX-RS客户端API	52
3.2.2 SSE	54
3.3 本章小结	58
第4章 WebSocket	61
4.1 什么是WebSocket	63
4.1.1 WebSocket握手	63
4.1.2 WebSocket API	65
4.2 WebSocket的Java API	66
4.3 用于WebSocket的HTML5客户端应用	73
4.3.1 HTML5应用设置	73
4.3.2 用于WebSocket的JavaScript API	79
4.4 本章小结	91
第5章 HTML5、JavaScript和CSS	93
5.1 HTML5项目设置	94
5.2 REST	98
5.2.1 读取，使用GET请求(R of CRUD)	99
5.2.2 创建，使用POST请求(C of CRUD)	106
5.2.3 更新，使用PUT请求(U of CRUD)	113
5.2.4 删除，使用DELETE请求(D of CRUD)	120
5.3 SSE	122
5.4 WebSocket	126
5.5 响应设计	126
5.6 SASS	130
5.7 本章小结	135
第6章 HTML5和Java应用安全	137
6.1 客户端安全	138
6.1.1 跨站脚本	138
6.1.2 跨站请求伪造	142
6.1.3 点击劫持	144
6.1.4 身份验证与授权	146
6.1.5 客户端安全常识	148
6.2 服务器端安全	149
6.2.1 身份验证	150
6.2.2 REST资源安全	155
6.2.3 WebSocket安全	155
6.3 本章小结	157
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE 7 & HTML5应用开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE核心框架实战
第1章 MyBatis3操作数据库 1
1.1 MyBatis介绍 1
1.2 MyBatis操作数据库的步骤 2
1.2.1 使用XML配置文件创建SqlSessionFactory对象 3
1.2.2 SqlSessionFactoryBuilder和SqlSessionFactory类的结构 4
1.2.3 使用MyBatisGenerator工具逆向 5
1.2.4 使用SqlSession对象在MsSql数据库中新建记录 7
1.2.5 使用SqlSession对象在Oracle数据库中新建记录 10
1.3 使用MyBatis针对3种数据库（Oracle、MSSQL和MySQL）实现CURD 10
1.3.1 针对Oracle的CURD 10
1.3.2 针对MSSQL的CURD 17
1.3.3 针对MySQL的CURD 20
1.4 MyBatis核心对象的生命周期与封装 22
1.4.1 创建GetSqlSessionFactory.java类 23
1.4.2 创建GetSqlSession.java类 24
1.4.3 创建DBOperate.java类 25
1.4.4 创建userinfoMapping.xml映射文件 25
1.4.5 创建连接数据库的mybatis—config.xml配置文件 26
1.4.6 创建名为test的Servlet对象 26
1.4.7 添加记录及异常回滚的测试 27
1.4.8 删除记录 29
1.4.9 更改记录 30
1.4.10 查询单条记录 31
1.4.11 查询多条记录 32
第2章 MyBatis3常用技能 33
2.1 MyBatis3的SQL映射文件 33
2.2 连接DB数据库的参数来自于Properties对象 33
2.3 ＜resultMap＞标签 34
2.4 ＜sql＞标签 35
2.5 将SQL语句作为字符串变量传入 37
2.6 动态SQL的使用 38
2.6.1 插入null值时的处理第1种方法——jdbcType 38
2.6.2 插入null值时的处理第2种方法——＜if＞ 39
2.6.3 ＜choose＞标签的使用 40
2.6.4 ＜set＞标签的使用 42
2.6.5 ＜foreach＞标签的使用 43
2.7 插入超大的字符串文本内容 45
2.8 分页 46
第3章 Struts2必备开发技能 48
3.1 使用Struts2进行登录功能的开发 48
3.1.1 为什么要使用MVC 48
3.1.2 准备JAR文件 54
3.1.3 创建Web项目、添加jar文件及配置web.xml文件 55
3.1.4 创建控制层Controller文件——Login.java 56
3.1.5 创建业务逻辑层Model文件——UserinfoService.java 57
3.1.6 创建视图层View文件——login.jsp 57
3.1.7 添加核心配置文件struts.xml及解释 58
3.1.8 添加ok.jsp和no.jsp登录结果文件 59
3.1.9 运行项目 59
3.1.10 Struts2的拦截器 60
3.1.11 Struts2的数据类型自动转换 64
3.2 MVC框架的开发模型 71
3.2.1 基础知识准备1——解析并创建xml文件 71
3.2.2 基础知识准备2——Java的反射 74
3.2.3 实现MVC模型——自定义配置文件 77
3.2.4 实现MVC模型——ActionMapping.java封装＜action＞信息 78
3.2.5 实现MVC模型——ResultMapping.java以封装＜result＞信息 78
3.2.6 实现MVC模型——管理映射信息的ActionMappingManager.java对象 79
3.2.7 实现MVC模型——创建反射Action的ActionManager.java对象 81
3.2.8 实现MVC模型——创建核心控制器ActionServlet.java 81
3.2.9 实现MVC模型——创建Action接口及控制层Controller实现类 83
3.2.10 实现MVC模型——创建视图层V对应的JSP文件 84
3.2.11 实现MVC模型——在web.xml中配置核心控制器 86
3.2.12 实现MVC模型——运行结果 86
3.3 Struts2的刷新验证功能 86
3.3.1 Action接口 87
3.3.2 Validateable和ValidationAware接口 88
3.3.3 TextProvider和LocaleProvider接口 88
3.3.4 使用ActionSupport实现有刷新的验证 89
3.4 对Struts2有刷新验证的示例进行升级 91
3.4.1 加入xml配置来屏蔽自动生成的table/tr/td代码 92
3.4.2 解决“出错信息不能自动显示”的问题 93
3.5 用＜s：actionerror＞标签显示全部出错信息 96
3.6 出错信息进行传参及国际化 98
3.6.1 创建info_en_US.properties和info_zh_CN.properties属性文件 98
3.6.2 在JSP文件中显示国际化的静态文本 101
3.6.3 在JSP文件中显示国际化的静态文本时传递参数 102
3.6.4 在Action中使用国际化功能 103
3.7 用实体类封装URL中的参数——登录功能的URL封装 105
3.8 Struts2中的转发操作 107
3.8.1 Servlet中的转发操作 107
3.8.2 Struts2中的转发操作 107
3.9 由Action重定向到Action——无参数 109
3.9.1 何种情况下使用重定向 109
3.9.2 新建起始控制层Login.java 109
3.9.3 新建目的控制层List.java 110
3.9.4 在struts.xml文件中配置重定向的重点 110
3.9.5 新建显示列表的JSP文件 111
3.10 由Action重定向到Action——有参数 112
3.10.1 何种情况下需要重定向传递参数 112
3.10.2 新建起始控制层Login.java文件 112
3.10.3 更改struts.xml配置文件 113
3.10.4 新建目的控制层List.java文件 113
3.10.5 用JSTL和EL在JSP文件中输出数据 114
3.11 让Struts2支持多模块多配置文件开发 115
3.11.1 新建4个模块的控制层 115
3.11.2 新建3个模块的配置文件 116
3.11.3 使用include标记导入多个配置文件 118
3.11.4 创建各模块使用的JSP文件 118
3.11.5 运行各模块的结果 119
3.12 在Action中有多个业务方法时的处理 120
3.12.1 第一种实现方式——通过url叹号“！”参数 120
3.12.2 第二种实现方式——在action标记中加入method属性 122
3.13 自定义全局result 124
3.13.1 新建全局result实例和控制层代码 124
3.13.2 声明全局result对象 125
3.13.3 部署项目并运行 126
3.14 在Action中使用Servlet的API（紧耦版） 126
3.14.1 将数据放到不同的作用域中 126
3.14.2 从不同作用域中取值 128
3.15 在Action中使用Servlet的API（松耦版） 128
3.15.1 新建控制层 128
3.15.2 新建JSP视图 129
3.16 Session与Cookie在request与response对象中的运行机制 130
3.17 在MyEclipse中使用WebService 135
第4章 Struts2文件的上传与下载 141
4.1 使用Struts2进行单文件上传 141
4.1.1 Struts2上传功能的底层依赖 141
4.1.2 新建上传文件的JSP文件 141
4.1.3 新建上传文件的控制层Register.java文件 142
4.1.4 Action中File实例的命名规则 143
4.1.5 设置上传文件的大小 143
4.1.6 设计struts.xml配置文件 143
4.1.7 成功上传单个文件 144
4.2 使用Struts2进行多文件上传 145
4.2.1 新建上传多个文件的JSP 145
4.2.2 设计上传的控制层代码 145
4.2.3 成功上传多个文件 147
4.3 使用属性驱动形式的文件上传 148
4.3.1 创建上传多个文件的JSP 148
4.3.2 设计上传文件的控制层 149
4.3.3 新建上传文件的封装类 150
4.3.4 将JSP文件中s：file标签的name属性进行更改 151
4.3.5 以属性驱动方式成功上传多个文件 152
4.4 用Struts2实现下载文件的功能（支持中文文件名） 153
4.4.1 新建下载文件的JSP文件 153
4.4.2 新建下载文件的控制层文件 154
4.4.3 更改struts.xml配置文件 155
4.4.4 成功下载中文文件名的文件 155
第5章 JSON、Ajax、jQuery与Struts2联合使用 156
5.1 JSON介绍 156
5.2 用JSON创建对象 157
5.2.1 用JSON创建对象的语法格式 157
5.2.2 在JSP中用JSON创建对象 157
5.2.3 运行结果 157
5.3 用JSON创建字符串的限制 158
5.3.1 需要转义的特殊字符 158
5.3.2 在JSP中对JSON特殊字符进行转义 158
5.3.3 运行结果 159
5.4 用JSON创建数字类型的语法格式 159
5.4.1 在JSP中用JSON创建数字类型 160
5.4.2 运行结果 160
5.5 用JSON创建数组对象的语法格式 160
5.5.1 在JSP中用JSON创建数组对象 161
5.5.2 运行结果 161
5.6 用JSON创建嵌套的对象类型 161
5.7 将对象转换成JSON字符串 162
5.7.1 什么情况下需要将对象转换成JSON字符串 162
5.7.2 在JSP中用stringify方法将对象转换成JSON字符串 163
5.8 将对象转换成JSON字符串提交到Action并解析（以post方式提交） 164
5.8.1 在JSP中创建JSON和Ajax对象 164
5.8.2 用Action控制层接收通过Ajax传递过来的JSON字符串 165
5.8.3 运行结果 166
5.8.4 在控制台输出的数据 166
5.9 将对象转换成JSON字符串提交到Action并解析（以get方式提交） 167
5.9.1 新建创建JSON字符串的JSP文件 167
5.9.2 新建接收JSON字符串的Action控制层 168
5.9.3 运行结果 168
5.9.4 在控制台输出的数据 169
5.10 将数组转换成JSON字符串提交到Action并解析（以get和post方式提交） 169
5.10.1 在服务器端用get方法解析JSON字符串 171
5.10.2 在服务器端用post方法解析JSON字符串 171
5.10.3 运行结果 172
5.10.4 在控制台输出的数据 172
5.11 使用Ajax调用Action并生成JSON再传递到客户端（以get和post方式提交） 173
5.11.1 新建具有Ajax提交功能的JSP 173
5.11.2 在Action控制层创建List中存放的String 176
5.11.3 在Action控制层创建List中存放的Bean 177
5.11.4 在Action控制层创建Map中存放的String 178
5.11.5 在Action控制层创建Map中存放的Bean 178
5.11.6 单击不同的button按钮调用不同的Action 179
5.12 jQuery、JSON和Struts2 181
5.12.1 jQuery框架的Ajax功能介绍 181
5.12.2 用jQuery的Ajax功能调用远程action（无返回结果） 181
5.12.3 jQuery的Ajax方法的结构 183
5.12.4 用jQuery的Ajax功能调用远程action（有返回结果） 184
5.12.5 用jQuery的Ajax功能调用远程action并且传递JSON格式参数（有返回值） 185
5.12.6 用jQuery解析从action返回List中存放String的JSON字符串 188
第6章 Spring4MVC实用开发 191
6.1 Spring4MVC介绍 191
6.1.1 Spring4MVC核心控制器 191
6.1.2 基于注解的Spring4MVC开发 192
6.2 Spring4MVC的第一个登录测试 193
6.2.1 添加Spring4MVC的依赖jar文件 193
6.2.2 在web.xml中配置核心控制器 193
6.2.3 新建springMVC—servlet.xml配置文件 193
6.2.4 新建相关的JSP文件 194
6.2.5 新建控制层Java类文件 195
6.2.6 部署项目并运行 195
6.2.7 第一个示例的总结 196
6.2.8 Spring更加方便的参数获取方法 196
6.3 执行Controller控制层与限制提交的method方式 197
6.3.1 新建控制层ListUsername.java文件 197
6.3.2 新建登录及显示数据的JSP文件 198
6.3.3 部署项目并测试 199
6.4 解决多人开发路径可能重复的问题 200
6.4.1 错误的情况 200
6.4.2 解决办法 201
6.5 在控制层中使用指定方式处理get或post提交方式 203
6.5.1 控制层代码 203
6.5.2 新建JSP文件并运行 204
6.6 控制层重定向到控制层——无参数传递 205
6.6.1 新建控制层Java文件 205
6.6.2 创建JSP文件并运行项目 206
6.7 控制层重定向到控制层——有参数传递 206
6.7.1 创建两个控制层Java文件 207
6.7.2 部署项目并运行 207
6.8 匹配URL路径执行指定Controller 208
6.8.1 新建控制层文件 208
6.8.2 部署项目并运行 209
6.9 在服务器端获取JSON字符串并解析——方式1 210
6.9.1 在web.xml中配置字符编码过滤器 210
6.9.2 新建JSP文件 211
6.9.3 新建控制层Java文件 212
6.9.4 添加依赖的jar包文件 212
6.9.5 运行项目 213
6.10 在服务器端获取JSON字符串并解析——方式2 213
6.10.1 新建封装JSON对象属性的实体类 213
6.10.2 新建控制层 214
6.10.3 在配置文件中添加＜mvc：annotation—driven/＞注解 214
6.10.4 新建JSP文件 215
6.10.5 添加jacksonJSON解析处理类库并运行 215
6.10.6 解析不同格式的JSON字符串示例 216
6.11 将URL中的参数转成实体的示例 218
6.11.1 新建控制层文件 218
6.11.2 新建登录用途的JSP文件 219
6.11.3 在web.xml中注册编码过滤器 219
6.11.4 运行结果 219
6.12 在控制层传回JSON对象示例 220
6.12.1 新建控制层文件 220
6.12.2 新建JSP文件 220
6.12.3 部署项目并运行 222
6.13 在控制层传回JSON字符串示例 222
6.13.1 新建控制层文件 222
6.13.2 新建JSP文件及在配置文件中注册utf——8编码处理 223
6.13.3 运行项目 224
6.14 在控制层获取HttpServletRequest和HttpServletResponse对象 224
6.14.1 新建控制层 224
6.14.2 JSP文件中的EL代码及运行结果 225
6.14.3 直接使用HttpServletResopnse对象输出响应字符 225
6.15 通过URL参数访问指定的业务方法 227
6.15.1 新建控制层文件List.java 227
6.15.2 运行结果 227
6.16 Spring4MVC单文件上传——写法1 228
6.16.1 新建控制层 228
6.16.2 在配置文件springMVC—servlet.xml中声明上传请求 229
6.16.3 创建前台JPS文件 229
6.16.4 运行结果 230
6.17 Spring4MVC单文件上传——写法2 230
6.18 Spring4MVC多文件上传 231
6.18.1 新建控制层及JSP文件 231
6.18.2 运行结果 232
6.19 Spring4MVC支持下载文件名为中文的文件 232
6.20 控制层返回List对象及实体的结果 233
6.20.1 新建控制层文件 233
6.20.2 新建JSP文件 234
6.20.3 更改springMVC—servlet.xml配置文件 234
6.20.4 运行结果 235
6.21 控制层ModelMap对象 236
6.21.1 新建控制层 236
6.21.2 JSP文件代码 236
6.21.3 运行结果 237
6.22 对Spring4MVC提交的表单进行手动数据验证 237
6.22.1 创建控制层文件 237
6.22.2 创建JSP文件 238
6.22.3 运行结果 238
第7章 Spring4MVC必备知识 239
7.1 web.xml中的不同配置方法 239
7.1.1 将配置文件存放于src路径中 239
7.1.2 指定存放路径 240
7.1.3 指定多个配置文件 240
7.2 路径中添加通配符的功能 241
7.3 Service业务逻辑层在Controller中进行注入 241
7.3.1 新建业务逻辑层 241
7.3.2 创建控制层文件 242
7.3.3 设计springMVC—servlet.xml配置文件 242
7.3.4 运行结果 242
7.3.5 多个实现类的情况 243
7.4 对象ModelAndView的使用 244
7.4.1 创建控制层及JSP文件 244
7.4.2 程序运行结果 244
7.5 控制层返回void数据的情况 245
7.5.1 创建控制层及index.jsp文件 245
7.5.2 更改配置文件 246
7.5.3 部署项目并运行程序 246
7.6 使用Spring4MVC中的注解来操作HttpSession中的对象 247
7.6.1 创建控制层文件PutGetSession.java 247
7.6.2 创建显示不同作用域中值的JSP文件 247
7.6.3 部署项目并运行程序 248
第8章 Spring4MVC+MyBatis3+Spring4整合 249
8.1 准备Spring4的jar包文件 249
8.2 准备MyBatis的jar包文件 250
8.3 准备MyBatis3与Spring4整合的jar文件 250
8.4 创建Web项目 250
8.5 配置web.xml文件 251
8.6 配置springMVC—servlet.xml文件 252
8.7 配置MyBatis配置文件 252
8.8 创建MyBatis与映射有关文件 253
8.9 配置applicationContext.xml文件 254
8.10 创建DAO对象 255
8.11 创建Service对象 256
8.12 创建Controller对象 257
8.13 测试整合效果 258
8.14 回滚的测试 258
第9章 用Hibernate4操作数据库 260
9.1 Hibernate概述与优势 260
9.2 持久层与持久化与ORM 261
9.3 用MyEclipse开发第一个Hibernate示例 262
9.3.1 用MyEclipseDatabaseExplorer工具连接Oracle11g数据库 263
9.3.2 创建一个支持Hibernate4环境的Web项目 265
9.3.3 对数据表进行Hibernate逆向工程 267
9.3.4 逆向工程后的项目orm结构 270
9.3.5 使用Hibernate进行持久化 273
第10章 Hibernate4核心技能 274
10.1 Configuration介绍 274
10.2 SessionFactory介绍 275
10.3 Session介绍 275
10.4 使用Session实现CURD操作 275
10.4.1 Session操作目标表USERINFO 276
10.4.2 逆向工程后的项目结构 276
10.4.3 新建添加记录的Servlet 277
10.4.4 新建查询记录的Servlet 278
10.4.5 新建更改记录的Servlet 279
10.4.6 新建删除记录的Servlet 280
10.5 在Hibernate中使用JNDI技术 281
10.5.1 备份Tomcat/conf路径下的配置文件 281
10.5.2 更改配置文件context.xml 281
10.5.3 更改配置文件web.xml 281
10.5.4 添加Hibernate框架配置的关键步骤 282
10.5.5 逆向工程 282
10.5.6 支持JNDI的hibernate.cfg.xml配置文件内容 282
10.5.7 创建查询数据的Servlet 283
10.5.8 部署项目并验证结果 283
10.6 缓存与实体状态 283
10.6.1 Hibernate的OID与缓存 283
10.6.2 Hibernate中的对象状态：瞬时状态、持久化状态和游离状态 285
10.7 双向一对多在MyEclipse中的实现 285
10.7.1 创建主表MAIN 285
10.7.2 创建子表SUB 285
10.7.3 添加主外键约束对象 286
10.7.4 设置主外键关系 286
10.7.5 逆向主从表外键关系 287
10.7.6 集合与多对一 288
10.7.7 新建主表main数据 289
10.7.8 新建子表SUB数据 290
10.7.9 删除子表SUB数据 292
10.7.10 删除主表MAIN数据 293
10.8 Hibernate备忘知识点 294
10.9 对主从表结构中的HashSet进行排序 295
10.10 Hibernate中延迟加载的调试实验 295
10.10.1 主从表表结构的设计 295
10.10.2 对省表和市表内容的填充 295
10.10.3 更改映射文件 295
10.10.4 新建测试用的Servlet对象 296
10.10.5 更改映射文件Sheng.hbm.xml 296
10.11 Hibernate中对Oracle中CLOB字段类型的读处理 297
10.12 Hibernate中的inverse与cascade的测试 297
第11章 在Hibernate4中使用HQL语言进行检索 302
11.1 Hibernate的检索方式 302
11.2 HQL表别名 305
11.3 HQL对结果进行排序与list（）和iterator（）方法的区别 306
11.4 HQL索引参数绑定 309
11.5 HQL命名参数绑定与安全性 309
11.6 HQL方法链的使用 311
11.7 HQL中的uniqueResult（）方法的使用 311
11.8 HQL中的Where子句与查询条件 312
11.9 HQL中的聚集函数：distinct、count、min、max、sum和avg 314
11.10 HQL中的分组查询 316
第12章 Spring4的AOP和IOC 318
12.1 Spring介绍 318
12.2 Spring架构 318
12.3 IOC的介绍 319
12.4 AOP的介绍 319
12.5 IOC容器 320
12.6 使用传统方式保存数据功能的测试 320
12.7 使用Spring的IOC方式保存数据功能的测试 321
12.8 BeanFactory与ApplicationContext 327
12.9 Spring的IOC容器的注入类型 327
12.9.1 通过IOC容器注入基本数据类型 327
12.9.2 通过IOC容器注入引用数据类型 330
12.9.3 通过IOC容器注入null类型 330
12.9.4 通过IOC容器注入Properties类型 332
12.9.5 通过IOC容器对构造方法进行注入 333
12.10 Spring中Bean在Singleton和Prototype中的作用域 335
12.11 Spring中注入外部属性文件的属性值 337
12.12 Spring中多个applicationContext.xml配置文件的使用 339
12.13 AOP的概念与介绍 342
12.13.1 静态代理的实现 342
12.13.2 动态代理的实现 344
12.14 实现MethodBeforeAdvice接口——方法执行前增强 345
12.15 实现AfterReturningAdvice接口——方法执行后增强 348
12.16 实现MethodInterceptor接口——方法执行前后环绕增强 350
第13章 Struts2+Hibernate4+Spring4整合 353
13.1 目的 353
13.2 新建Oracle数据表userinfo 353
13.2.1 新建数据表userinfo 353
13.2.2 创建序列对象 354
13.3 新建整合用的Web项目 354
13.4 添加Struts2框架支持环境 354
13.4.1 添加Struts2框架 354
13.4.2 在web.xml文件中注册Struts2的过滤器 355
13.4.3 在项目的src目录下创建struts.xml配置文件 355
13.4.4 添加Struts2框架后的项目文件结构图 356
13.5 添加HibernateDatabaseExplorer数据库连接 356
13.6 添加Hibernate4框架支持 357
13.7 添加Spring4框架支持文件 357
13.8 创建的applicationContext.xml文件 358
13.9 在web.xml文件中添加Spring的utf—8编码过滤器和Spring监听器 359
13.10 添加Spring4框架后的Web项目结构 360
13.11 对Oracle11g数据表userinfo进行Hibernate逆向工程 361
13.12 创建Hibernate4的DAO类 362
13.13 创建All_DAO对象 363
13.14 创建UserinfoService.java服务对象 364
13.15 创建AllService服务对象 364
13.16 继续更改applicationContext.xml和hibernate.cfg.xml 365
13.17 新建自定义action的父类BaseAction 367
13.18 新建操作userinfo表中数据的Action 367
13.19 在applicationContext.xml中配置／base和/test 368
13.20 部署到Tomcat容器 370
第14章 有状态／无状态会话Bean和消息驱动Bean 373
14.1 EJB3概述 373
14.1.1 JavaEE体系结构 374
14.1.2 容器的概念 374
14.2 有状态会话Bean和无状态会话Bean 375
14.2.1 会话Bean的作用 375
14.2.2 会话Bean的种类 375
14.2.3 在MyEclipse中无状态会话Bean的创建 376
14.2.4 用Web方式调用本地SayHello接口 390
14.2.5 本地和远程无状态会话Bean的区别 394
14.2.6 EJB组件接口无注解时的默认情况 395
14.2.7 调用远程类型的无状态会话Bean 396
14.2.8 无状态会话Bean的回调函数和生命周期 401
14.2.9 无状态会话Bean实例变量值保留的问题与无状态会话Bean实例池 404
14.2.10 有状态会话Bean 409
14.2.11 有状态会话Bean的创建与状态特性 409
14.2.12 将远程无状态会话Bean共享的服务重命名 416
14.2.13 使用注解声明会话Bean的第2种写法 418
14.2.14 有状态会话Bean的钝化与激活 419
14.2.15 有状态会话Bean的回调函数和生命周期 420
14.2.16 有状态会话Bean的@Remove回调函数的使用 425
14.2.17 注入其他本地类型的EJB对象 428
14.3 消息驱动JavaBean（MDB）和在WebLogic中创建消息目的 430
14.3.1 创建持久性存储对象 431
14.3.2 创建JMS服务器 433
14.3.3 创建JMS模块 435
14.3.4 在JMS模块中创建子部署 437
14.3.5 在JMS模块中创建资源 439
14.3.6 点对点式消息驱动JavaBean 441
14.3.7 发布—订阅式消息驱动JavaBean 445
14.4 WebService与在EJB3中创建基于WebService的业务服务 450
14.5 计时器与作业调度 463
第15章 实体Bean 466
15.1 实体Bean概述 466
15.2 持久层、持久化与ORM 466
15.2.1 在WebLogic的JNDI树中创建节点与对象 469
15.2.2 在WebLogic的JNDI树中创建子节点 475
15.2.3 在WebLogic的JNDI树中查找节点 477
15.2.4 在WebLogic的JNDI树中删除节点 478
15.3 从保存记录开始 479
15.3.1 安装Oracle11g数据库 479
15.3.2 使用Toad管理Oracle数据库 479
15.3.3 使用MyEclipseDatabaseExplorer工具连接Oracle11G数据库 486
15.3.4 创建EJB3项目 489
15.3.5 更改实体的主键与序列映射 492
15.3.6 创建调用外观的Serlvet 493
15.3.7 更改persistence.xml配置文件 493
15.3.8 KODO的简要介绍 494
15.3.9 部署到WebLogic中并且运行 494
15.3.10 使用JPA技术向Oracle11g数据库成功添加记录 494
15.3.11 改成JNDI连接池的示例 495
15.4 解析实体类所使用的注解 501
15.5 在SQL2005数据库中插入记录 501
15.6 在MySQL数据库中插入记录 504
15.7 使用表在Oracle数据库中生成主键 505
15.8 使用EJB3在Oracle中插入Date时间类型 508
15.9 处理CLOB数据类型 510
15.10 在WebLogic中实现JDBC+JNDI全局性分布式事务实验 510
15.10.1 JTA和2PC的概述 510
15.10.2 进入WebLogic控制台 511
15.10.3 配置数据源名称 511
15.10.4 配置数据源属性 512
15.10.5 设置数据源连接数据库的详细信息 513
15.10.6 测试是否连接到数据库 513
15.10.7 将数据源归属到AdminServer服务器 514
15.10.8 新建名为b_jndi的数据源 514
15.10.9 数据源列表 514
15.10.10 SQL在正确的情况下实现多数据源提交事务 515
15.10.11 SQL在错误的情况下实现多数据源回滚事务 518
第16章 JPA核心技能 521
16.1 EntityManager类的概述 521
16.1.1 实体类的状态 522
16.1.2 EJB3中的事务 522
16.2 EntityManager类的方法使用 522
16.2.1 persist（Object）方法 525
16.2.2 merge（T）方法和find（Class＜T＞，Object）方法 526
16.2.3 remove（Object）方法 528
16.2.4 getReference（Class＜T＞，Object）方法 530
16.2.5 createNativeQuery（）方法 533
16.2.6 close（）和isOpen（）方法 538
16.2.7 refresh（Object）方法 538
16.2.8 clear（）和contains（Object）方法 542
16.2.9 createQuery（String）方法 543
16.2.10 createNamedQuery（String）方法 545
16.3 EntityManagerFactory对象介绍 546
16.4 用JavaSE客户端调用远程EJB3组件（使用逆向DAO） 547
16.5 在JavaSE客户端使用EntityManagerFactory实现持久化（手动配置） 550
16.6 在JavaSE客户端使用EntityManagerFactory实现持久化（自动配置） 552
16.7 在会话Bean中生成EntityManagerFactory 557
16.8 双向一对多的CURD实战 559
16.8.1 新建数据表Sheng 559
16.8.2 新建数据表Shi 559
16.8.3 配置主从键约束关系 559
16.8.4 创建企业项目 561
16.8.5 逆向EJB实体 561
16.8.6 添加主键生成策略的注解 562
16.8.7 配置persistence.xml文件 563
16.8.8 persistence.xml配置文件再次提醒 563
16.8.9 生成的Sheng.java和Shi.java代码引用 563
16.8.10 创建Sheng的Servlet 564
16.8.11 创建Shi的Servlet 565
16.8.12 更新Sheng的Servlet 566
16.8.13 更新Shi的Servlet 566
16.8.14 删除没有市的省 571
16.8.15 删除有市的省 571
第17章 JPQL必备技能 573
17.1 JPQL介绍 573
17.2 命名参数和索引式参数及实体参数式查询 573
17.2.1 参数索引式查询 574
17.2.2 命名式参数查询 575
17.2.3 为实现主从关联示例创建sheng表和shi表 576
17.2.4 sheng表和shi表两种关联查询的方式 577
17.3 JPQL支持的运算符 578
17.3.1 +、—、*、/、=、＞=、＞、＜、＜=、＜＞、between、like、in运算符的使用 578
17.3.2 not运算符的使用 581
17.3.3 isnull运算符的使用 582
17.3.4 isempty运算符的使用 582
17.4 orderby的使用 583
17.5 查询指定字段的示例 584
17.6 聚合函数avg、count、max、min、sum的使用 586
17.7 groupby和having的使用 587
17.8 左外连接的使用 588
17.9 通过distinct去除重复记录 590
17.10 JPQL的字符串操作函数 590
17.11 通过JPQL取得当前的日期和日期时间 594
17.12 JPQL语言对日期的判断 595
17.13 JPQL的数学函数 598
17.14 JPQL中的分页功能 599
第18章 FreeMarker模板引擎的使用 600
18.1 输出8种简单数据类型 600
18.2 简单数据类型的计算 603
18.3 输出复杂数据类型——数组 604
18.4 输出集合对象——List 605
18.5 输出集合对象——Set 606
18.6 输出集合对象——Map 606
18.7 输出嵌套类型——List中有Map 607
18.8 输出嵌套类型——Map中有List 608
18.9 判断#if和#else标签的使用 609
18.10 输出实体类的属性及boolean类型注意事项 609
18.11 FreeMarker中的注释 611
18.12 FreeMarker中的导入 611
18.13 FreeMarker中对不存在的变量或null值的处理 612
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE核心框架实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java机器学习
第1章　机器学习应用快速入门　　1
1.1　机器学习与数据科学　　1
1.1.1　机器学习能够解决的问题　　2
1.1.2　机器学习应用流程　　3
1.2　数据与问题定义　　4
1.3　数据收集　　5
1.3.1　发现或观察数据　　5
1.3.2　生成数据　　6
1.3.3　采样陷阱　　7
1.4　数据预处理　　7
1.4.1　数据清洗　　8
1.4.2　填充缺失值　　8
1.4.3　剔除异常值　　8
1.4.4　数据转换　　9
1.4.5　数据归约　　10
1.5　无监督学习　　10
1.5.1　查找相似项目　　10
1.5.2　聚类　　12
1.6　监督学习　　13
1.6.1　分类　　14
1.6.2　回归　　16
1.7　泛化与评估　　18
1.8　小结　　21
第2章　面向机器学习的Java库与平台　　22
2.1　Java环境　　22
2.2　机器学习库　　23
2.2.1　Weka　　23
2.2.2　Java机器学习　　25
2.2.3　Apache Mahout　　26
2.2.4　Apache Spark　　27
2.2.5　Deeplearning4j　　28
2.2.6　MALLET　　29
2.2.7　比较各个库　　30
2.3　创建机器学习应用　　31
2.4　处理大数据　　31
2.5　小结　　33
第3章　基本算法——分类、回归和聚类　　34
3.1　开始之前　　34
3.2　分类　　35
3.2.1　数据　　35
3.2.2　加载数据　　36
3.2.3　特征选择　　37
3.2.4　学习算法　　38
3.2.5　对新数据分类　　40
3.2.6　评估与预测误差度量　　41
3.2.7　混淆矩阵　　41
3.2.8　选择分类算法　　42
3.3　回归　　43
3.3.1　加载数据　　43
3.3.2　分析属性　　44
3.3.3　创建与评估回归模型　　45
3.3.4　避免常见回归问题的小技巧　　48
3.4　聚类　　49
3.4.1　聚类算法　　49
3.4.2　评估　　50
3.5　小结　　51
第4章　利用集成方法预测客户关系　　52
4.1　客户关系数据库　　52
4.1.1　挑战　　53
4.1.2　数据集　　53
4.1.3　评估　　54
4.2　最基本的朴素贝叶斯分类器基准　　55
4.2.1　获取数据　　55
4.2.2　加载数据　　56
4.3　基准模型　　58
4.3.1　评估模型　　58
4.3.2　实现朴素贝叶斯基准线　　59
4.4　使用集成方法进行高级建模　　60
4.4.1　开始之前　　60
4.4.2　数据预处理　　61
4.4.3　属性选择　　62
4.4.4　模型选择　　63
4.4.5　性能评估　　66
4.5　小结　　66
第5章　关联分析　　67
5.1　购物篮分析　　67
5.2　关联规则学习　　69
5.2.1　基本概念　　69
5.2.2　Apriori算法　　71
5.2.3　FP-增长算法　　71
5.2.4　超市数据集　　72
5.3　发现模式　　73
5.3.1　Apriori算法　　73
5.3.2　FP-增长算法　　74
5.4　在其他领域中的应用　　75
5.4.1　医疗诊断　　75
5.4.2　蛋白质序列　　75
5.4.3　人口普查数据　　76
5.4.4　客户关系管理　　76
5.4.5　IT运营分析　　76
5.5　小结　　77
第6章　使用Apache Mahout制作推荐引擎　　78
6.1　基本概念　　78
6.1.1　关键概念　　79
6.1.2　基于用户与基于项目的分析　　79
6.1.3　计算相似度的方法　　80
6.1.4　利用与探索　　81
6.2　获取Apache Mahout　　81
6.3　创建一个推荐引擎　　84
6.3.1　图书评分数据集　　84
6.3.2　加载数据　　84
6.3.3　协同过滤　　89
6.4　基于内容的过滤　　97
6.5　小结　　97
第7章　欺诈与异常检测　　98
7.1　可疑与异常行为检测　　98
7.2　可疑模式检测　　99
7.3　异常模式检测　　100
7.3.1　分析类型　　100
7.3.2　事务分析　　101
7.3.3　规划识别　　101
7.4　保险理赔欺诈检测　　101
7.4.1　数据集　　102
7.4.2　为可疑模式建模　　103
7.5　网站流量异常检测　　107
7.5.1　数据集　　107
7.5.2　时序数据中的异常检测　　108
7.6　小结　　113
第8章　利用Deeplearning4j进行图像识别　　114
8.1　图像识别简介　　114
8.2　图像分类　　120
8.2.1　Deeplearning4j　　120
8.2.2　MNIST数据集　　121
8.2.3　加载数据　　121
8.2.4　创建模型　　122
8.3　小结　　128
第9章　利用手机传感器进行行为识别　　129
9.1　行为识别简介　　129
9.1.1　手机传感器　　130
9.1.2　行为识别流水线　　131
9.1.3　计划　　132
9.2　从手机收集数据　　133
9.2.1　安装Android Studio　　133
9.2.2　加载数据采集器　　133
9.2.3　收集训练数据　　136
9.3　创建分类器　　138
9.3.1　减少假性转换　　140
9.3.2　将分类器嵌入移动应用　　142
9.4　小结　　143
第10章　利用Mallet进行文本挖掘——主题模型与垃圾邮件检测　　144
10.1　文本挖掘简介　　144
10.1.1　主题模型　　145
10.1.2　文本分类　　145
10.2　安装Mallet　　146
10.3　使用文本数据　　147
10.3.1　导入数据　　149
10.3.2　对文本数据做预处理　　150
10.4　为BBC新闻做主题模型　　152
10.4.1　BBC数据集　　152
10.4.2　建模　　153
10.4.3　评估模型　　155
10.4.4　重用模型　　156
10.5　垃圾邮件检测　　157
10.5.1　垃圾邮件数据集　　158
10.5.2　特征生成　　159
10.5.3　训练与测试模型　　160
10.6　小结　　161
第11章　机器学习进阶　　162
11.1　现实生活中的机器学习　　162
11.1.1　噪声数据　　162
11.1.2　类不平衡　　162
11.1.3　特征选择困难　　163
11.1.4　模型链　　163
11.1.5　评价的重要性　　163
11.1.6　从模型到产品　　164
11.1.7　模型维护　　164
11.2　标准与标记语言　　165
11.2.1　CRISP-DM　　165
11.2.2　SEMMA方法　　166
11.2.3　预测模型标记语言　　166
11.3　云端机器学习　　167
11.4　Web资源与比赛　　168
11.4.1　数据集　　168
11.4.2　在线课程　　169
11.4.3　比赛　　170
11.4.4　网站与博客　　170
11.4.5　场馆与会议　　171
11.5　小结　　171
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java机器学习
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>java语言袖珍指南
前言
第1部分 语言
第1章 命名约定
类名
接口名称
方法名称
实例和静态变量名称
参数和局部变量名
泛型类型参数名称
常量名
枚举名称
包名称
首字母缩写词
第2章 词法
Unicode字符和ASCII码
不可打印的ASCII码字符
注释
关键字
标识符
分隔符
运算符
转义序列
Unicode货币符号
第3章 基本类型
基本类型
基本类型的常量
浮点实体
涉及特殊实体的操作
基本类型的数值提升
包装类
自动打包和解包
第4章 引用类型
引用类型与基本类型的比较
默认值
引用类型的转换
基本类型和引用类型之间的转换
向方法传递引用类型
比较引用类型
复制引用类型
内存分配和引用类型的垃圾收集
第5章 面向对象编程
类和对象
可变长度参数列表
抽象类和抽象方法
静态数据成员，静态方法，静态常量和静态初始化
接口
枚举
注解类型
第6章 语句和块
表达式语句
空语句
块
条件语句
迭代语句
控制转移
同步语句
断言语句
异常处理语句
第7章 异常处理
异常层次结构
捕获/未捕获异常和错误
常见的捕获/未捕获异常和错误
异常处理关键词
异常处理流程
定义自己的异常类
打印关于异常的信息
第8章 Java的修饰符
访问修饰符
其他（不可访问）修饰符
第2部分 平台
第9章 Java平台标准版
常见的Java SE API库
第10章 开发基础
Java运行时环境
Java开发工具包
Java程序结构
命令行工具
第11章 内存管理
垃圾收集
内存管理工具
命令行选项
重新调整JVM堆
与GC接口
第12章 基本输入和输出
标准流in，out和err
基本输入和输出的类层次结构
文件读/写
套接字的读取与写入
序列化
压缩和解压文件
文件和目录处理
第13章 快速查看NIO2.0
Path接口
Files类
附加功能
第14章 并发
创建线程
线程状态
线程的优先级
常用方法
同步
并发实用程序
第15章 Java集合框架
集合接口
实现
集合框架方法
集合类方法
算法效率
比较器接口
第16章 泛型框架
泛型类和接口
泛型的构造函数
替代原则
类型参数，通配符和边界
Get和Put原则
泛型具体化
原始类型中的泛型方法
第17章 Java脚本API
脚本语言
脚本引擎实现
设置脚本语言和引擎
第3部分 附录
附录A 第三方工具
附录B UML基础知识
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>java语言袖珍指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java函数式编程
第1章　什么是函数式编程  1
1.1　函数式编程是什么  2
1.2　编写没有副作用的程序  4
1.3　引用透明如何让程序更安全  6
1.4　函数式编程的优势  7
1.5　用代换模型来推断程序  8
1.6　将函数式原则应用于一个简单的例子  9
1.7　抽象到极致  15
1.8　总结  16
第2章　在Java中使用函数  17
2.1　什么是函数 .18
2.1.1　现实世界里的函数  18
2.2　Java中的函数  24
2.2.1　函数式的方法  24
2.2.2　Java的函数式接口与匿名类  30
2.2.3　复合函数  31
2.2.4　多态函数  32
2.2.5　通过 lambda简化代码  33
2.3　高级函数特性  36
2.3.1　多参函数怎么样  36
2.3.2　应用柯里化函数  37
2.3.3　高阶函数  38
2.3.4　多态高阶函数  39
2.3.5　使用匿名函数  43
2.3.6　局部函数  45
2.3.7　闭包 .46
2.3.8　部分函数应用和自动柯里化  48
2.3.9　交换部分应用函数的参数  53
2.3.10　递归函数  54
2.3.11　恒等函数  56
2.4　Java 8的函数式接口  58
2.5　调试lambda ..59
2.6　总结  62
第3章　让Java更加函数式  63
3.1　使标准控制结构具有函数式风格  64
3.2　抽象控制结构  65
3.2.1　清理代码  69
3.2.2　if … else的另一种方式  73
3.3　抽象迭代  78
3.3.1　使用映射抽象列表操作  79
3.3.2　创建列表  80
3.3.3　使用 head和 tail操作  81
3.3.4　函数式地添加列表元素  83
3.3.5　化简和折叠列表  83
3.3.6　复合映射和映射复合  90
3.3.7　对列表应用作用  91
3.3.8　处理函数式的输出  92
3.3.9　构建反递归列表  93
3.4　使用正确的类型  97
3.4.1　标准类型的问题  97
3.4.2　定义值类型  99
3.4.3　值类型的未来  103
3.5　总结  103
第4章　递归、反递归和记忆化  104
4.1　理解反递归和递归  105
4.1.1　探讨反递归和递归的加法例子  105
4.1.2　在 Java中实现递归  106
4.1.3　使用尾调用消除  107
4.1.4　使用尾递归方法和函数  107
4.1.5　抽象递归  108
4.1.6　为基于栈的递归方法使用一个直接替代品  112
4.2　使用递归函数  115
4.2.1　使用局部定义的函数  115
4.2.2　使函数成为尾递归  116
4.2.3　双递归函数：斐波那契数列示例  117
4.2.4　让列表的方法变成栈安全的递归  120
4.3　复合大量函数  123
4.4　使用记忆化  127
4.4.1　命令式编程中的记忆化  127
4.4.2　递归函数的记忆化  128
4.4.3　自动记忆化  130
4.5　总结  136
第5章　用列表处理数据  138
5.1　如何对数据集合进行分类  138
5.1.1　不同的列表类型  139
5.1.2　对列表性能的相对期望  140
5.1.3　时间与空间，时间与复杂度的取舍 .141
5.1.4　直接修改  142
5.1.5　持久化数据结构  143
5.2　一个不可变、持久化的单链表实现  144
5.3　在列表操作中共享数据  148
5.3.1　更多列表操作  150
5.4　使用高阶函数递归折叠列表  155
5.4.1　基于堆的 foldRight递归版  162
5.4.2　映射和过滤列表  164
5.5　总结  167
第6章　处理可选数据  168
6.1　空指针的问题  169
6.2　空引用的替代方案  171
6.3　Option数据类型  174
6.3.1　从 Option中取值  176
6.3.2　将函数应用于可选值  178
6.3.3　复合 Option处理  179
6.3.4　Option的用例  181
6.3.5　复合 Option的其他方法  186
6.3.6　复合 Option和 List  189
6.4　Option的其他实用程序  191
6.4.1　检查是 Some还是 None  191
6.4.2　equals和 hashcode  192
6.5　如何及何时使用Option  193
6.6　总结  195
第7章　处理错误和异常  197
7.1　待解决的问题  197
7.2　Either类型 ..199
7.2.1　复合 Either  200
7.3　Result类型 .203
7.3.1　为 Result类添加方法  204
7.4　Result模式 .206
7.5　Result处理进阶  213
7.5.1　应用断言  214
7.5.2　映射 Failure  215
7.5.3　增加工厂方法  218
7.5.4　应用作用  220
7.5.5　Result复合进阶  222
7.6　总结  226
第8章　列表处理进阶  228
8.1　length的问题  229
8.1.1　性能问题  229
8.1.2　记忆化的优点  230
8.1.3　记忆化的缺点  230
8.1.4　实际性能  232
8.2　复合List和Result  233
8.2.1　List中返回 Result的方法  233
8.2.2　将 List<Result>转换为 Result<List> 235
8.3　抽象常见列表用例  238
8.3.1　压缩和解压缩列表  238
8.3.2　通过索引访问元素  241
8.3.3　拆分列表  244
8.3.4　搜索子列表  248
8.3.5　使用列表的其他函数  249
8.4　自动并行处理列表  254
8.4.1　并非所有的计算都可以并行化  254
8.4.2　将列表拆分为子列表  254
8.4.3　并行处理子列表  256
8.5　总结  258
第9章　使用惰性  259
9.1　理解严格和惰性  259
9.1.1　Java是一门严格的语言  260
9.1.2　严格带来的问题  261
9.2　实现惰性 ...263
9.3　只有惰性才能做到的事  264
9.4　为何不要用Java 8中的Stream  265
9.5　创建一个惰性列表数据结构  266
9.5.1　记忆已计算的值  268
9.5.2　对流的操作  271
9.6　惰性的真正本质  274
9.6.1　折叠流  277
9.7　处理无限流  282
9.8　避免null引用和可变字段  285
9.9　总结  287
第10章　用树进行更多数据处理  289
10.1　二叉树  290
10.1.1　平衡树和非平衡树  291
10.1.2　大小、高度和深度  291
10.1.3　叶树  292
10.1.4　有序二叉树或二叉搜索树  292
10.1.5　插入顺序  293
10.1.6　树的遍历顺序  294
10.2　实现二叉搜索树  297
10.3　从树中删除元素  303
10.4　合并任意树  304
10.5　折叠树  310
10.5.1　用两个函数折叠  311
10.5.2　用一个函数折叠  313
10.5.3　选择哪种折叠的实现  314
10.6　映射树  316
10.7　平衡树  317
10.7.1　旋转树  317
10.7.2　使用 DSW算法平衡树  320
10.7.3　自动平衡树  322
10.7.4　解决正确的问题  323
10.8　总结  324
第11章　用高级树来解决真实问题  325
11.1　性能更好且栈安全的自平衡树  326
11.1.1　树的基本结构  326
11.1.2　往红黑树中插入元素  331
11.2　红黑树的用例：map  337
11.2.1　实现 map  337
11.2.2　扩展 map  340
11.2.3　使用键不可比较的 map  341
11.3　实现函数式优先队列  344
11.3.1　优先队列访问协议  344
11.3.2　优先队列使用案例  344
11.3.3　实现需求  345
11.3.4　左倾堆数据结构  345
11.3.5　实现左倾堆  346
11.3.6　实现像队列一样的接口  351
11.4　元素不可比较的优先队列  352
11.5　总结  358
第12章　用函数式的方式处理状态改变  359
12.1　一个函数式的随机数发生器  360
12.1.1　随机数发生器接口  361
12.1.2　实现随机数发生器  362
12.2　处理状态的通用API  366
12.2.1　使用状态操作  367
12.2.2　复合状态操作  368
12.2.3　递归状态操作  370
12.3　通用状态处理  372
12.3.1　状态模式  374
12.3.2　构建一个状态机  375
12.3.3　何时使用状态和状态机  381
12.4　总结  381
第13章　函数式输入/输出  382
13.1　在上下文中应用作用  383
13.1.1　作用是什么  384
13.1.2　实现作用  384
13.1.3　用于失败情况的更强大的作用  387
13.2　读取数据 .390
13.2.1　从控制台读取  390
13.2.2　从文件中读取  395
13.2.3　检查输入  396
13.3　真正的函数式输入/输出  398
13.3.1　怎样才能让输入 /输出是完全函数式的  398
13.3.2　实现纯函数式的输入 /输出  399
13.3.3　合并 IO  400
13.3.4　用 IO处理输入  402
13.3.5　扩展 IO类型  404
13.3.6　使 IO类型栈安全  407
13.4　总结  413
第14章　通过actor共享可变状态  414
14.1　actor模型 .415
14.1.1　异步消息  416
14.1.2　处理并行  416
14.1.3　处理 actor状态变化  417
14.2　构建actor框架  418
14.2.1　actor框架的限制  418
14.2.2　设计 actor框架接口  418
14.2.3　AbstractActor的实现  420
14.3　开始使用actor  422
14.3.1　实现乒乓示例  422
14.3.2　一个更严谨的例子：并行运行一个计算  424
14.3.3　重新排序结果  430
14.3.4　解决性能问题  433
14.4　总结  439
第15章　以函数式的方式解决常见问题  440
15.1　使用断言来校验数据  441
15.2　从文件中读取属性  446
15.2.1　载入属性文件  446
15.2.2　将属性读取为字符串  447
15.2.3　生成更好的错误消息  448
15.2.4　像列表那样读取属性  451
15.2.5　读取枚举值  453
15.2.6　读取任意类型的属性  454
15.3　转换命令式程序：XML读取器  457
15.3.1　列出必需的函数  459
15.3.2　复合函数并应用作用  460
15.3.3　实现函数  461
15.3.4　让程序更加函数式  462
15.3.5　修复参数类型问题  466
15.3.6　以处理元素的函数为参数  467
15.3.7　处理元素名称错误  468
15.4　总结  470
附录A　使用Java 8的函数式特性  471
附录B　Monad  479
附录C　敢问路在何方  485
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java函数式编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring源码深度解析
第一部分　核心实现
第1章　Spring整体架构和环境搭建　2
1.1　Spring的整体架构　2
1.2　环境搭建　4
1.2.1　安装GitHub　4
1.2.2　安装Gradle　5
1.2.3　下载Spring　6
第2章　容器的基本实现　10
2.1　容器基本用法　10
2.2　功能分析　11
2.3　工程搭建　12
2.4　Spring的结构组成　13
2.4.1　beans包的层级结构　13
2.4.2　核心类介绍　13
2.5　容器的基础XmlBeanFactory　17
2.5.1　配置文件封装　18
2.5.2　加载Bean　21
2.6　获取XML的验证模式　24
2.6.1　DTD与XSD区别　24
2.6.2　验证模式的读取　26
2.7　获取Document　28
2.7.1　EntityResolver用法　29
2.8　解析及注册BeanDefinitions　31
2.8.1　profile属性的使用　32
2.8.2　解析并注册BeanDefinition　33
第3章　默认标签的解析　35
3.1　bean标签的解析及注册　35
3.1.1　解析BeanDefinition　37
3.1.2　AbstractBeanDefinition属性　55
3.1.3　解析默认标签中的自定义标签元素　58
3.1.4　注册解析的BeanDefinition　60
3.1.5　通知监听器解析及注册完成　63
3.2　alias标签的解析　63
3.3　import标签的解析　65
3.4　嵌入式beans标签的解析　67
第4章　自定义标签的解析　68
4.1　自定义标签使用　69
4.2　自定义标签解析　71
4.2.1　获取标签的命名空间　72
4.2.2　提取自定义标签处理器　72
4.2.3　标签解析　74
第5章　bean的加载　78
5.1　FactoryBean的使用　83
5.2　缓存中获取单例bean　85
5.3　从bean的实例中获取对象　86
5.4　获取单例　90
5.5　准备创建bean　92
5.5.1　处理ovverride属性　93
5.5.2　实例化的前置处理　94
5.6　循环依赖　96
5.6.1　什么是循环依赖　96
5.6.2　Spring如何解决循环依赖　96
5.7　创建bean　100
5.7.1　创建bean的实例　103
5.7.2　记录创建bean的ObjectFactory　112
5.7.3　属性注入　115
5.7.4　初始化bean　124
5.7.5　注册DisposableBean　128
第6章　容器的功能扩展　129
6.1　设置配置路径　130
6.2　扩展功能　130
6.3　环境准备　132
6.4　加载BeanFactory　133
6.4.1　定制BeanFactory　135
6.4.2　加载BeanDefinition　136
6.5　功能扩展　137
6.5.1　增加SPEL语言的支持　138
6.5.2　增加属性注册编辑器　139
6.5.3　添加ApplicationContext AwareProcessor处理器　144
6.5.4　设置忽略依赖　146
6.5.5　注册依赖　146
6.6　BeanFactory的后处理　146
6.6.1　激活注册的BeanFactory PostProcessor　147
6.6.2　注册BeanPostProcessor　153
6.6.3　初始化消息资源　156
6.6.4　初始化ApplicationEvent Multicaster　159
6.6.5　注册监听器　161
6.7　初始化非延迟加载单例　162
6.8　finishRefresh　165
第7章　AOP　167
7.1　动态AOP使用示例　167
7.2　动态AOP自定义标签　169
7.2.1　注册AnnotationAwareAspectJ AutoProxyCreator　170
7.3　创建AOP代理　173
7.3.1　获取增强器　176
7.3.2　寻找匹配的增强器　186
7.3.3　创建代理　187
7.4　静态AOP使用示例　201
7.5　创建AOP静态代理　203
7.5.1　Instrumentation使用　203
7.5.2　自定义标签　207
7.5.3　织入　209
第二部分　企业应用
第8章　数据库连接JDBC　214
8.1　Spring连接数据库程序实现(JDBC)　215
8.2　save/update功能的实现　217
8.2.1　基础方法execute　219
8.2.2　Update中的回调函数　223
8.3　query功能的实现　225
8.4　queryForObject　229
第9章　整合MyBatis　231
9.1　MyBatis独立使用　231
9.2　Spring整合MyBatis　235
9.3　源码分析　237
9.3.1　sqlSessionFactory创建　237
9.3.2　MapperFactoryBean的创建　241
9.3.3　MapperScannerConfigurer　244
第10章　事务　254
10.1　JDBC方式下的事务使用 示例　254
10.2　事务自定义标签　257
10.2.1　注册InfrastructureAdvisor AutoProxyCreator　257
10.2.2　获取对应class/method的增强器　261
10.3　事务增强器　269
10.3.1　创建事务　271
10.3.2　回滚处理　281
10.3.3　事务提交　287
第11章　SpringMVC　291
11.1　SpringMVC快速体验　291
11.2　ContextLoaderListener　295
11.2.1　ServletContextListener的使用　295
11.2.2　Spring中的ContextLoader Listener　296
11.3　DispatcherServlet　300
11.3.1　servlet的使用　301
11.3.2　DispatcherServlet的初始化　302
11.3.3　WebApplicationContext的初始化　304
11.4　DispatcherServlet的逻辑处理　320
11.4.1　MultipartContent类型的request处理　326
11.4.2　根据request信息寻找对应的Handler　327
11.4.3　没找到对应的Handler的错误处理　331
11.4.4　根据当前Handler寻找对应的HandlerAdapter　331
11.4.5　缓存处理　332
11.4.6　HandlerInterceptor的处理　333
11.4.7　逻辑处理　334
11.4.8　异常视图的处理　334
11.4.9　根据视图跳转页面　335
第12章　远程服务　340
12.1　RMI　340
12.1.1　使用示例　340
12.1.2　服务端实现　342
12.1.3　客户端实现　350
12.2　HttpInvoker　355
12.2.1　使用示例　356
12.2.2　服务端实现　357
12.2.3　客户端实现　361
第13章　Spring消息　367
13.1　JMS的独立使用　367
13.2　Spring整合ActiveMQ　369
13.3　源码分析　371
13.3.1　JmsTemplate　372
13.3.2　监听器容器　376
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring源码深度解析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Expert One-on-One J2EE Development without EJB中文版
第1章 为什么要“j2ee without ejb”
聚光灯下的ejb
j2ee还剩什么？
站在十字路口的j2ee
前行的路
主旋律
轻量级框架和容器
我们还应该使用ejb吗？
小结
第2章 目标
生产率
问题
传统j2ee方案解决生产率问题的办法
提升生产率更好的办法
oo
业务需求的重要性
经验过程的重要性
小结
第3章 各种架构
架构性构件
.业务服务层
向外部暴露业务对象
数据访问层，或eis层
j2ee架构
两种ejb架构
两种非ejb架构
j2ee架构实例
“经典的”j2ee远程ejb架构
本地ejb架构
特制的非ejb架构
“轻量级容器架构”：示例应用系统
确定是否采用应用服务器
小结
第4章 简单性的红利
复杂性的代价
在j2ee应用系统中，导致复杂性产生的原因
导致复杂性的架构性原因
导致复杂性的文化性原因：一个依靠复杂性为生的产业
复杂到什么地步就是过度了？
简单还是幼稚？
刚刚够好就行吗？
变化的趋势
总结
第5章 ejb，五年间
炒作和经验
ejb和j2ee行业
实践中的ejb
一个过时的组件模型
java语言的进步
.net的挑战
web service
敏捷方法学的兴起
关于ejb目标的混淆
从未出现的组件市场
方兴未艾的新范式：aop
ejb, 我们真正需要什么？为什么无状态session bean如此流行？
声明性事务管理
远程调用
集群
线程管理
ejb实例池
资源池
安全
业务对象管理
总结：ejb的服务
ejb，我们不想要什么？
容器的锁定
丑陋的结构，泛滥的类
部署描述文件的地狱
类加载器的地狱
测试
ejb的滥用
复杂的编程模型
简单的事情会变得困难
“让开发人员忽略企业应用的复杂性”，这个目标现实吗？
生产率的损失
可移植性的问题
ejb能浴火重生吗？
工具支持
ejb 3.0
神话与谬论
jee == ejb
使用ejb的可疑论据
继续前进
moving forward
选择是否使用ejb
传统的知识
今天的选择
后ejb时代的舆论
标准，创新，和开源
小结
第6章 轻量级容器与控制反转
轻量级容器
什么是轻量级容器？
我们到底为什么需要容器？
轻量级容器 vs. ejb容器
ejb的好处
管理业务对象
接口与实现的分离
ejb：不完善的解决方案
控制反转
ioc实现策略
ioc容器
ioc容器间的移植
对代码风格、测试以及开发过程的影响
代码风格
可测试性
开发过程
使用企业级服务
小结
第7章 spring框架简介
来历与动机
一个分层的应用框架
基础构建模块
j2ee之上的spring
web应用中的spring
核心bean工厂
基础接口
通过xml组装bean
非xml格式的bean声明
组装应用对象
自动装配和依赖检查
构造子决议
生命周期回调
复杂的属性值
资源设置
典型的java/j2ee资源访问
bean容器中的资源声明
工厂bean
spring应用上下文
生命周期回调
信息源
文件资源
bean factory 后处理
小结
第8章 基于aop概念的声明性中间件
aop 101
动机
j2ee中的aop
定义
历史
作为aop子集的ejb
aop实现策略
动态代理
动态字节码生成
java代码生成
使用定制的类加载器
语言扩展
aop实现
aspectj
aspectwerkz
jboss4
spring
nanning
aop联盟
aop设计问题
aop的危险性
aop设计的建议
随意点菜的j2ee
spring中的aop实践
使用proxyfactorybean
便利的factorybean
自动代理
编程用法
使用源码级元数据提供aop之上的抽象
.net范例
概念级元数据 vs. 实现级元数据
编程访问上下文信息
spring范例
ejb 3.0
编程风格的暗含意味
前后一致的命名规范
避免依赖aop基础设施
受控异常和增强
参考资料
书籍
论文
文章和在线资源
小结
第9章 事务管理
上层（high-level）事务管理
传统的j2ee事务管理
j2ee容器作为事务协调器
人见人爱的cmt
直接使用jta
插曲：远程事务传播
轻量级事务基础设施
spring framework的事务管理
事务声明
编程式事务处理
声明式事务管理
事务管理策略
选择j2ee服务器的提示
小结
第10章 持久化
常见持久化策略
持久化模式概览
流行的j2ee数据访问解决方案
选择一种持久化策略
透明持久化和领域对象的行为
java持久化技术简史
java o/r映射解决方案的缓慢成长
entity bean的败笔
实践中的数据访问技术
资源管理
jdbc
ibatis sql映射
jdo
hibernate
数据访问对象（dao）模式
业务对象与数据访问对象
dao和透明持久化
数据访问对象的种类
dao设计中的问题
dao基础设施的问题
使用spring框架进行数据访问
通用的数据访问异常
再论业务对象与数据访问对象的关系
jdbc
ibatis sql映射
jdo
hibernate
小结
第11章 远程调用
经典的j2se远程方案：rmi
访问和暴露rmi服务
用rmi调用器实现透明远程调用
经典的j2ee远程机制：ejb
通信协议
状态管理
访问远程ejb
部署远程ejb
基于wsdl的web services：jax-rpc
访问web services
servlet和ejb端点
轻量级远程方案：hessian和burlap
访问和暴露hessian和burlap服务
小结
第12章 替换其它的ejb服务
线程管理
线程神话
ejb线程模型
ejb实例池
何时需要实例池？
何时不需要实例池
ejb线程机制和缓冲池的替代方案
线程模型
实例池概述
声明性安全
ejb安全模型
ejb模型的缺陷
借助aop的声明式安全
jms和消息驱动bean
小结
第13章 web层设计
目标和体系结构的讨论
web层设计目标
用servlet和jsp定制的mvc
融入整体架构
请求驱动的web mvc框架
struts 1.1
webwork2
spring的web mvc框架
适宜的视图技术
web mvc的其它实现方式
portals和portlets
事件驱动的web mvc框架
小论asp.net
总结
第14章 单元测试与可测试性
为何测试很重要？
单元测试的目标
确保可测试性
编程风格
如何让你的代码难于测试
来自标准库的难题
提高可测试性的技巧
依赖倒置
aop
单元测试技巧
替换
模仿对象
编写有效测试
测试驱动开发（tdd）
好处
对tdd的反对意见
tdd实践
学习tdd
案例研究：spring的经验
测试spring应用程序
对pojo进行测试
spring的抽象带来的好处
何时需要依赖spring api
使用替换配置进行测试
覆盖率分析和其他测试工具
测试生成器
覆盖分析工具
突变测试工具
资源
小结
第15章 性能与可伸缩性
定义
设置清晰的目标
体系结构的选择：影响性能和可伸缩性的关键因素
对象分布、集群和农场
数据访问
其他体系结构方面的问题
不同实现的选择
摆脱ejb服务设施对性能的影响
结果总结
摆脱ejb服务设施对性能的影响
缓存的代码优化
调优和部署
jvm
应用服务器
框架配置
数据库配置
一种循证的性能策略
基准测试
采样（profiling）
诊断
资源
小结
第16章 示例应用系统
pet store（宠物店）业务需求
ibatis jpetstore 3.1
中间层
远程调用机制
可改进的空间
spring jpetstore
中间层
数据访问层
web层
远程机制
编译和部署
war部署中的一些问题
部署spring jpetstore
小结
第17章 结语
回顾
前行
为你的应用选择最佳架构
轻量级容器架构
标准关键词
指导方针
编程风格
控制反转（ioc）和依赖注入
aop
测试
写在最后
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Expert One-on-One J2EE Development without EJB中文版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>解密搜索引擎技术实战
第1章  搜索引擎总体结构	1
1.1  搜索引擎基本模块	1
1.2  开发环境	2
1.3  搜索引擎工作原理	3
1.3.1  网络爬虫	4
1.3.2  全文索引结构与Lucene实现	4
1.3.3  搜索用户界面	7
1.3.4  计算框架	8
1.3.5  文本挖掘	9
1.4  本章小结	9
第2章  网络爬虫的原理与应用	11
2.1  爬虫的基本原理	11
2.2  爬虫架构	14
2.2.1  基本架构	14
2.2.2  分布式爬虫架构	16
2.2.3  垂直爬虫架构	17
2.3  抓取网页	18
2.3.1  下载网页的基本方法	19
2.3.2  网页更新	23
2.3.3  抓取限制应对方法	25
2.3.4  URL地址提取	28
2.3.5  抓取JavaScript动态页面	28
2.3.6  抓取即时信息	31
2.3.7  抓取暗网	32
2.3.8  信息过滤	33
2.3.9  最好优先遍历	39
2.4  存储URL地址	40
2.4.1  BerkeleyDB	40
2.4.2  布隆过滤器	42
2.5  并行抓取	45
2.5.1  多线程爬虫	46
2.5.2  垂直搜索的多线程爬虫	48
2.5.3  异步I/O	49
2.6  RSS抓取	53
2.7  抓取FTP	55
2.8  下载图片	55
2.9  图像的OCR识别	56
2.9.1  图像二值化	57
2.9.2  切分图像	60
2.9.3  SVM分类	63
2.10  Web结构挖掘	67
2.10.1  存储Web图	67
2.10.2  PageRank算法	71
2.10.3  HITs算法	77
2.10.4  主题相关的PageRank	81
2.11  部署爬虫	83
2.12  本章小结	83
第3章  索引内容提取	86
3.1  从HTML文件中提取文本	86
3.1.1  识别网页的编码	86
3.1.2  网页编码转换为字符串编码	89
3.1.3  使用正则表达式提取数据	89
3.1.4  结构化信息提取	91
3.1.5  网页的DOM结构	94
3.1.6  使用NekoHTML提取信息	95
3.1.7  使用Jsoup提取信息	101
3.1.8  网页去噪	105
3.1.9  网页结构相似度计算	110
3.1.10  提取标题	112
3.1.11  提取日期	113
3.2  从非HTML文件中提取文本	113
3.2.1  提取标题的一般方法	114
3.2.2  PDF文件	118
3.2.3  Word文件	122
3.2.4  Rtf文件	123
3.2.5  Excel文件	134
3.2.6  PowerPoint文件	137
3.3  流媒体内容提取	137
3.3.1  音频流内容提取	138
3.3.2  视频流内容提取	140
3.4  存储提取内容	142
3.5  本章小结	143
第4章  中文分词的原理与实现	144
4.1  Lucene中的中文分词	145
4.1.1  Lucene切分原理	145
4.1.2  Lucene中的Analyzer	146
4.1.3  自己写Analyzer	148
4.1.4  Lietu中文分词	150
4.2  查找词典算法	151
4.2.1  标准Trie树	151
4.2.2  三叉Trie树	154
4.3  中文分词的原理	159
4.4  中文分词流程与结构	162
4.5  形成切分词图	164
4.6  概率语言模型的分词方法	169
4.7  N元分词方法	173
4.8  新词发现	178
4.9  未登录词识别	179
4.10  词性标注	180
4.10.1  隐马尔可夫模型	183
4.10.2  基于转换的错误学习方法	191
4.11  平滑算法	193
4.12  本章小结	198
第5章  让搜索引擎理解自然语言	199
5.1  停用词表	200
5.2  句法分析树	201
5.3  相似度计算	205
5.4  文档排重	209
5.4.1  语义指纹	210
5.4.2  SimHash	213
5.4.3  分布式文档排重	223
5.5  中文关键词提取	223
5.5.1  关键词提取的基本方法	223
5.5.2  HITS算法应用于关键词提取	226
5.5.3  从网页中提取关键词	228
5.6  相关搜索词	228
5.6.1  挖掘相关搜索词	229
5.6.2  使用多线程计算相关搜索词	231
5.7  信息提取	232
5.8  拼写检查与建议	237
5.8.1  模糊匹配问题	240
5.8.2  英文拼写检查	242
5.8.3  中文拼写检查	244
5.9  自动摘要	247
5.9.1  自动摘要技术	247
5.9.2  自动摘要的设计	247
5.9.3  Lucene中的动态摘要	254
5.10  文本分类	257
5.10.1  特征提取	259
5.10.2  中心向量法	262
5.10.3  朴素贝叶斯	265
5.10.4  支持向量机	272
5.10.5  规则方法	279
5.10.6  网页分类	282
5.11  拼音转换	283
5.12  概念搜索	284
5.13  多语言搜索	292
5.14  跨语言搜索	293
5.15  情感识别	295
5.15.1  确定词语的褒贬倾向	298
5.15.2  实现情感识别	300
5.16  本章小结	301
第6章  Lucene原理与应用	303
6.1  Lucene深入介绍	304
6.1.1  常用查询对象	304
6.1.2  查询语法与解析	304
6.1.3  查询原理	308
6.1.4  分析文本	309
6.1.5  使用Filter筛选搜索结果	316
6.1.6  遍历索引库	317
6.1.7  索引数值列	318
6.2  Lucene中的压缩算法	322
6.2.1  变长压缩	322
6.2.2  PForDelta	324
6.2.3  前缀压缩	326
6.2.4  差分编码	328
6.3  创建和维护索引库	330
6.3.1  创建索引库	330
6.3.2  向索引库中添加索引文档	331
6.3.3  删除索引库中的索引文档	334
6.3.4  更新索引库中的索引文档	334
6.3.5  索引的合并	335
6.3.6  索引文件格式	335
6.4  查找索引库	338
6.4.1  查询过程	338
6.4.2  常用查询	342
6.4.3  基本词查询	343
6.4.4  模糊匹配	343
6.4.5  布尔查询	345
6.4.6  短语查询	347
6.4.7  跨度查询	349
6.4.8  FieldScoreQuery	353
6.5  读写并发控制	356
6.6  检索模型	356
6.6.1  向量空间模型	357
6.6.2  BM25概率模型	361
6.6.3  统计语言模型	367
6.7  本章小结	369
第7章  搜索引擎用户界面	370
7.1  实现Lucene搜索	370
7.2  实现搜索接口	372
7.2.1  编码识别	372
7.2.2  布尔搜索	375
7.2.3  指定范围搜索	375
7.2.4  搜索结果排序	376
7.2.5  搜索页面的索引缓存与更新	377
7.3  历史搜索词记录	380
7.4  实现关键词高亮显示	381
7.5  实现分类统计视图	383
7.6  实现Ajax搜索联想词	388
7.6.1  估计查询词的文档频率	388
7.6.2  搜索联想词总体结构	389
7.6.3  服务器端处理	389
7.6.4  浏览器端处理	390
7.6.5  服务器端改进	395
7.6.6  拼音提示	398
7.6.7  部署总结	399
7.7  集成其他功能	399
7.7.1  拼写检查	399
7.7.2  分类统计	400
7.7.3  相关搜索	402
7.7.4  再次查找	405
7.7.5  搜索日志	405
7.8  搜索日志分析	407
7.8.1  日志信息过滤	407
7.8.2  信息统计	409
7.8.3  挖掘日志信息	411
7.9  本章小结	412
第8章  使用Solr实现企业搜索	413
8.1  Solr简介	413
8.2  Solr基本用法	414
8.2.1  Solr服务器端的配置与中文支持	415
8.2.2  把数据放进Solr	421
8.2.3  删除数据	423
8.2.4  Solr客户端与搜索界面	424
8.2.5  Spring实现的搜索界面	425
8.2.6  Solr索引库的查找	436
8.2.7  索引分发	440
8.2.8  Solr搜索优化	442
8.3  Solr扩展与定制	445
8.3.1  Solr中字词混合索引	445
8.3.2  相关检索	447
8.3.3  搜索结果去重	449
8.3.4  定制输入输出	453
8.3.5  分布式搜索	457
8.3.6  SolrJ查询分析器	458
8.3.7  扩展SolrJ	466
8.3.8  扩展Solr	467
8.3.9  查询Web图	471
8.4  本章小结	473
第9章  地理信息系统案例分析	474
9.1  新闻提取	474
9.2  POI信息提取	479
9.2.1  提取主体	484
9.2.2  提取地区	485
9.2.3  指代消解	487
9.3  机器翻译	489
9.3.1  词对齐	490
9.3.2  翻译公司名	491
9.3.3  调整语序	493
9.4  本章小结	494
第10章  户外活动搜索案例分析	495
10.1  爬虫	495
10.2  信息提取	497
10.3  活动分类	501
10.4  搜索	501
10.5  本章小结	502
参考资料	503
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>解密搜索引擎技术实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java常用数值算法集（含CD-ROM光盘一张）——常用数值算法丛书
序
前言
第1章  线性代数方程组的解法
  1.1 全主元高斯-约当(Gauss-Jordan)消去法
  1.2 LU分解法
  1.3 追赶法
  1.4 五对角线性方程组解法
  1.5 线性方程组解的迭代改善
  1.6 范德蒙(Vandermonde)方程组解法
  1.7 托伯利兹(Toeplitz)方程组解法
  1.8 奇异值分解
  1.9 线性方程组的共轭梯度法
  1.10 对称方程组的乔列斯基(Cholesky)分解法
  1.11 矩阵的QR分解
  1.12 松弛迭代法
第2章 插值
  2.1 拉格朗日插值
  2.2 有理函数插值
  2.3 三次样条插值
  2.4 有序表的检索法
  2.5 插值多项式
  2.6 二元拉格朗日插值
  2.7 双三次样条插值
第3章 数值积分
  3.1 梯形求积法
  3.2 辛普森(Simpson)求积法
  3.3 龙贝格(Romberg)求积法
  3.4 反常积分
  3.5 高斯(Gauss)求积法
  3.6 三重积分
第4章 特殊函数
  4.1 T函数、贝塔函数、阶乘及二项式系数
  4.2 不完全函数、误差函数
  4.3 不完全T贝塔函数
  4.4 零阶、一阶和任意整数阶的第一、二类贝塞尔函数
  4.5 零阶、一阶和任意整数阶的第一、二类变形贝塞尔函数
  4.6 分数阶第一类贝塞尔函数和变形贝塞尔函数
  4.7 指数积分和定指数积分
  4.8 连带勒让德函数
第5章 函数逼近
  5.1 级数求和
  5.2 多项式和有理函数
  5.3 切比雪夫逼近
  5.4 积分和导数的切比雪夫逼近
  5.5 用切比雪夫逼近求函数的多项式逼近
第6章 随机数
  6.1 均匀分布随机数
  6.2 变换方法指数分布和正态分布随机数
  6.3 舍选法-T分布、泊松分布和二项式分布随机数
  6.4 随机位的产生
  6.5 蒙特卡罗积分法
第7章 排序
  7.1 直接插入法和Shell方法
  7.2 堆排序
  7.3 索引表和等级表
  7.4 快速排序
  7.5 等价类的确定
第8章 特征值问题
  8.1 对称矩阵的雅可比变换
  8.2 变实对称矩阵为三对角对称矩阵
  8.3 三对角矩阵的特征值和特征向量
  8.4 变一般矩阵为赫申伯格矩阵
  8.5 实赫申伯格矩阵的QR算法
第9章 数据拟合
  9.1 直线拟合
  9.2 线性最小二乘法
  9.3 非线性最小二乘法
  9.4 绝对值偏差最小的直线拟合
第10章 方程求根和非线性方程组的解法
  10.1 图解法
  10.2 逐步扫描法和二分法
  10.3 割线法和试位法
  10.4 布伦特(Brent)方法
  10.5 牛顿-拉裴森(Newton-Raphson)法
  10.6 求复系数多项式根的拉盖尔(Laguerre)方法
  10.7 求实系数多项式根的贝尔斯托(Bairstou)方法
  10.8 非线性方程组的牛顿-拉裴森方法'
第11章 函数的极值和最优化
  11.1 黄金分割搜索法
  11.2 不用导数的布伦特(Brent)法
  11.3 用导数的布伦特(Brent)法
  11.4 多元函数的下山单纯形法
  11.5 多元函数的包维尔(Powell)法
  11.6 多元函数的共轭梯度法
  11.7 多元函数的变尺度法
第12章 傅里叶变换谱方法
  12.1 复数据快速傅里叶变换算法
  12.2 实数据快速傅里叶变换算法(一)
  12.3 实数据快速傅里叶变换算法(二)
  12.4 快速正弦变换和余弦变换
  12.5 卷积和逆卷积的快速算法
  12.6 离散相关和自相关的快速算法
  12.7 多维快速傅里叶变换算法
第13章 数据的统计描述
  13.1 分布的矩-均值、平均差、标准差、方差、斜差和峰态
  13.2 中位数的搜索
  13.3 均值与方差的显著性检验
  13.4 分布拟合的X检验
  13.5 分布拟合的K-S检验法
第14章 解常微分方程组
  14.1 定步长四阶龙格-库塔(Runge-Kutta)法
  14.2 自适应变步长的龙格-库塔法
  14.3 改进的中点法
  14.4 外推法
第15章 两点边值问题的解法
  15.1 打靶法(一)
  15.2 打靶法(二)
  15.3 松弛法
第16章 偏微分方程的解法
  16.1 解边值问题的松弛法
  16.2 交替方向隐式方法(ADI)
参考文献
编后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java常用数值算法集（含CD-ROM光盘一张）——常用数值算法丛书
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java专业编程指南
一, JAVA内幕
二, 库, 类与方法设计
三, 在应用程序中使用线程
四, 应用程序中的事务处理
五, 使用布局管理器
六, swing组件－JTable
七, swi

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java专业编程指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 2实用教程
第一章  JAVA基础
第二章  数据类型与运算符
第三章  程序控制语句
第四章  类、对象和方法
第五章  其他数据类型与运算符
第六章  方法和类详解
第七章  继承
第八章  包和接口
第九章  异常处理
第十章  使用I/O
第十一章  多线程程序设计
第十二章  APPLET、事件和其他议题
附录A  思考与练习答案
附录B  使用JAVA的文档注释

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 2实用教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java实用教程
第1章  Java程序设计语言概述第2章  Java语言的基本语法第3章  程序流程控制语句第4章  面向对象基础第5章  集合第6章  Java输入与输出（I/O）第7章  多线程与异常处理第8章  Swing程序设计第9章  Applet程序设计第10章  网络程序设计第11章  JDBC数据库编程第12章  Java Web程序设计附录 上机实验
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java实用教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java函数实用手册
第1章 概述 1
1.1 Java简介 1
1.2 Java的特点 1
1.2.1 平台无关性 1
1.2.2 安全性 1
1.2.3 面向对象 1
1.2.4 分布式 1
1.2.5 健壮性 1
1.3 Java环境设定 1
1.4 Java常用开发工具 2
1.4.1 集成开发工具 2
1.4.2 应用服务器 3
1.4.3 Java类库 4

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java函数实用手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JAVA图形用户界面设计与实例
第一章
Java语言基础 第二章
基本的用户界面构件及设计 第三章
事件处理与窗口构造构件 第四章
JFC/Swing简介 第五章
图标、标签与边框 第六章
按钮、单选按钮和复选框 第七章
列表和组合框 第八章
文本编辑组件 第九章
菜单和工具条 第十章
简单文本编辑器实例 第十一章
简单浏览器实例 第十二章
围棋程序实例 第十三章
Java开发时钟实例 第十四章
俄罗

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JAVA图形用户界面设计与实例
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>妙用Java及VRML开发三维图形
第一章  实现电脑空间的梦想
1. 1  本章主要内容
1. 2  VRMLl. 0的起源
1. 2. 1  科学幻想的遗产
1. 2. 2  虚拟现实
1. 2. 3  全球计算机网络

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>妙用Java及VRML开发三维图形
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>XML与JAVA程序设计大全
第1章　本书导读与随书光盘介绍

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>XML与JAVA程序设计大全
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>java 7程序设计入门经典
译者序
前言
第一部分 Java语言
第1章 Java编程基础2
1.1 计算基础3
1.1.1 计算机的硬件组成3
1.1.2 位、字节和二进制4
1.1.3 操作系统5
1.2 程序5
1.3 编程语言6
1.4 Java语言7
1.4.1 Java的起源7
1.4.2 Java对互联网的贡献9
1.4.3 Java applet9
1.4.4 安全性9
1.4.5 可移植性9
1.4.6 Java的解决方案：字节码10
1.4.7 Java的演进10
1.5 面向对象编程的关键特性11
1.5.1 封装12
1.5.2 多态12
1.5.3 继承13
1.6 Java开发工具包13
1.7 第一个简单的程序14
1.7.1 输入程序15
1.7.2 编译程序15
1.7.3 运行程序15
1.7.4 逐行解析第一个简单的程序16
1.8 处理语法错误18
1.9 第二个简单的程序18
1.10 另一种数据类型20
1.11 两种控制语句23
1.11.1 if语句23
1.11.2 for循环25
1.12 创建代码块26
1.13 分号和语句的位置27
1.14 关于缩进28
1.15 Java关键字30
1.16 Java中的标识符30
1.17 Java类库31
1.18 习题32
第2章 数据类型和运算符34
2.1 为什么数据类型很重要34
2.2 Java的基本数据类型34
2.2.1 整数35
2.2.2 浮点类型36
2.2.3 字符37
2.2.4 布尔类型38
2.3 字面量40
2.3.1 十六进制、八进制和二进制字面量41
2.3.2 转义字符序列41
2.3.3 字符串字面量42
2.4 深入解析变量43
2.4.1 初始化变量43
2.4.2 动态初始化44
2.5 变量的作用域和生命周期44
2.6 运算符47
2.7 算术运算符47
2.8 关系运算符和逻辑运算符49
2.9 具有“短路”功能的逻辑运算符50
2.10 赋值运算符52
2.11 速记赋值运算符53
2.12 赋值中的类型转换53
2.13 使用强制类型转换55
2.14 运算符的优先级56
2.15 表达式58
2.15.1 表达式中的类型转换58
2.15.2 空白和圆括号60
2.16 习题60
第3章 程序控制语句63
3.1 从键盘输入字符63
3.2 if语句65
3.3 嵌套的if语句66
3.4 if-else-if梯队67
3.5 switch语句68
3.6 嵌套的switch语句71
3.7 for循环74
3.8 for循环中的一些特殊情况76
3.8.1 缺少部分76
3.8.2 无限循环77
3.8.3 没有循环体的循环78
3.9 在for语句内部声明循环控制变量78
3.10 增强的for循环79
3.11 while循环80
3.12 do-while循环81
3.13 使用break语句退出循环86
3.14 像使用goto语句一样使用break语句88
3.15 使用continue语句91
3.16 嵌套的循环96
3.17 习题97
第4章 类、对象和方法初探100
4.1 类的基础知识100
4.1.1 类的一般形式101
4.1.2 定义类101
4.2 如何创建对象104
4.3 变量引用和赋值语句105
4.4 方法106
4.5 从方法返回108
4.6 返回值109
4.7 使用形参111
4.8 构造函数119
4.9 含有形参的构造函数120
4.10 new运算符再探123
4.11 垃圾回收和终结器123
4.12 使用this关键字126
4.13 习题128
第5章 更多数据类型和运算符131
5.1 数组131
5.2 多维数组136
5.2.1 二维数组136
5.2.2 不规则数组137
5.2.3 三维或多维数组139
5.2.4 初始化多维数组139
5.3 其他声明数组的语法140
5.4 对数组的引用赋值141
5.5 使用成员length142
5.6 for-each风格的for循环149
5.6.1 遍历多维数组152
5.6.2 应用增强for循环153
5.7 字符串154
5.7.1 构造字符串154
5.7.2 操作字符串155
5.7.3 字符串数组156
5.7.4 字符串是不可改变的157
5.7.5 使用字符串控制switch语句158
5.8 使用命令行参数159
5.9 按位运算161
5.9.1 按位与、按位或、按位异或、按位非运算符161
5.9.2 移位运算符165
5.9.3 位速记赋值运算符167
5.10 问号运算符170
5.11 习题171
第6章 深入解析类和方法174
6.1 控制对类成员的访问174
6.2 向方法传递对象180
6.3 如何传递实参181
6.4 返回对象183
6.5 重载方法185
6.6 重载构造函数189
6.7 递归195
6.8 理解关键字static199
6.8.1 静态变量199
6.8.2 静态方法201
6.8.3 静态代码块203
6.9 嵌套类和内部类207
6.10 长度可变的实参vararg210
6.10.1 vararg基础210
6.10.2 重载varargs方法213
6.10.3 vararg和二义性214
6.11 习题215
第7章 继承220
7.1 继承基础220
7.2 成员访问和继承223
7.3 构造函数和继承226
7.4 用super关键字调用超类的构造函数227
7.5 用super关键字访问超类成员232
7.6 创建多层层次结构235
7.7 执行构造函数的时机238
7.8 超类引用与子类对象239
7.9 方法重写244
7.10 用重写方法支持多态246
7.11 为什么要重写方法248
7.12 使用抽象类252
7.13 使用final关键字256
7.13.1 用final关键字防止方法重写256
7.13.2 用final关键字防止继承257
7.13.3 对数据成员使用final关键字257
7.14 Object类258
7.15 习题259
第8章 接口261
8.1 接口的基础知识261
8.2 创建接口262
8.3 实现接口263
8.4 使用接口引用266
8.5 实现多个接口268
8.6 接口中的常量276
8.7 可扩展的接口277
8.8 嵌套的接口278
8.9 关于接口的最后思考279
8.10 习题279
第9章 包281
9.1 包的基础知识281
9.1.1 定义包282
9.1.2 寻找包与环境变量CLASSPATH282
9.1.3 一个短小的包例子283
9.2 包与成员访问284
9.2.1 一个包访问的例子285
9.2.2 受保护的成员287
9.3 导入包289
9.4 静态导入293
9.5 习题295
第10章 异常处理298
10.1 异常层次结构298
10.2 异常处理基础299
10.2.1 使用关键字try和catch299
10.2.2 一个简单的异常处理例子300
10.3 未捕获异常的后果302
10.4 异常可以优雅地处理错误303
10.5 使用多个catch子句305
10.6 捕获子类异常306
10.7 嵌套的try块307
10.8 抛出异常309
10.9 进一步解读Throwable类311
10.10 使用finally块312
10.11 使用throws关键字314
10.12 Java的内置异常315
10.13 JDK 7中新添加的异常特性317
10.14 创建异常子类319
10.15 习题325
第11章 使用输入/输出329
11.1 Java的输入/输出是建立在流上的330
11.2 字节流和字符流330
11.3 字节流类330
11.4 字符流类331
11.5 预定义的流331
11.6 使用字节流332
11.6.1 读控制台输入333
11.6.2 写控制台输出334
11.7 使用字节流读写文件335
11.7.1 从文件中输入335
11.7.2 写文件339
11.8 自动关闭文件340
11.9 读写二进制数据343
11.10 随机访问文件347
11.11 使用Java字符流350
11.11.1 用控制台获得字符流输入351
11.11.2 使用字符流进行控制台输出353
11.12 使用字符流进行文件输入/输出354
11.12.1 使用FileWriter类355
11.12.2 使用FileReader类356
11.12.3 File类357
11.12.4 获得文件属性357
11.12.5 获得目录列表359
11.12.6 使用FilenameFilter接口360
11.12.7 listFiles()方法361
11.12.8 多种文件实用方法361
11.13 使用Java的类型包装器来转换数值字符串363
11.14 习题371
第12章 多线程编程375
12.1 多线程基础375
12.2 Thread类和Runnable接口376
12.3 创建线程376
12.4 创建多个线程384
12.5 判定线程终止的时间386
12.6 线程的优先级389
12.7 同步390
12.8 使用同步方法390
12.9 synchronized语句393
12.10 使用方法notify()、wait()和notifyAll()进行线程通信396
12.11 线程挂起、恢复和终止402
12.12 习题406
第13章 枚举、自动装箱和注解410
13.1 枚举410
13.2 Java的枚举是类类型413
13.3 values()方法和valueOf()方法413
13.4 构造函数、方法、实例变量和枚举415
13.5 从Enum类继承枚举416
13.6 自动装箱423
13.6.1 类型包装器和装箱424
13.6.2 自动装箱基础425
13.6.3 装箱与方法426
13.6.4 表达式中的自动装箱和自动拆箱427
13.6.5 警告429
13.7 注解（元数据）430
13.7.1 创建和使用注解430
13.7.2 内置注解431
13.8 习题432
第14章 泛型436
14.1 泛型基础436
14.1.1 一个简单的泛型例子437
14.1.2 泛型只能用于对象440
14.1.3 基于不同类型实参的不同泛型类型440
14.1.4 有两个类型形参的泛型类441
14.1.5 泛型类的一般形式442
14.2 有界的类型443
14.3 使用有通配符的实参446
14.4 有界的通配符449
14.5 泛型方法452
14.6 泛型构造函数454
14.7 泛型的类层次结构454
14.8 泛型接口458
14.9 原始类型和遗留代码464
14.10 带有菱形运算符的类型推断467
14.11 清除468
14.12 二义性错误469
14.13 泛型的一些限制470
14.13.1 不能实例化类型形参470
14.13.2 对静态成员的限制470
14.13.3 泛型数组的限制470
14.13.4 泛型异常的限制471
14.14 习题472
第15章 applet与剩余的Java关键字475
15.1 applet基础475
15.2 applet的完整骨架478
15.3 applet的初始化和终止479
15.4 applet架构的关键点480
15.5 请求重绘480
15.6 使用状态窗口485
15.7 向applet传递形参486
15.8 剩余的Java关键字488
15.8.1 修饰符volatile488
15.8.2 修饰符transient488
15.8.3 关键字instanceof488
15.8.4 关键字strictfp489
15.8.5 关键字assert489
15.8.6 原生方法489
15.9 习题491
第16章 面向对象设计介绍493
16.1 优雅的软件及其重要性493
16.2 优雅的方法496
16.2.1 命名约定497
16.2.2 方法的内聚497
16.2.3 形式良好的对象499
16.2.4 内部文档500
16.2.5 外部文档501
16.3 优雅的类503
16.3.1 类的内聚和专家模式503
16.3.2 避免重复505
16.3.3 完整的接口507
16.3.4 设计时要考虑变化507
16.3.5 最少知识原则510
16.4 继承与委托的比较511
16.4.1 UML类图512
16.4.2 从代码重用的角度看513
16.4.3 is-a关系514
16.4.4 类似的行为516
16.4.5 多态518
16.4.6 继承的代价519
16.5 设计模式521
16.5.1 适配者模式522
16.5.2 观察者模式525
16.6 习题529
第二部分 利用Swing工具箱进行GUI编程
第17章 Swing基础534
17.1 Swing的起源和设计理念534
17.2 组件和容器536
17.2.1 组件536
17.2.2 容器537
17.2.3 顶级容器窗格537
17.3 布局管理器538
17.4 第一个简单的Swing程序539
17.5 事件处理544
17.5.1 事件544
17.5.2 事件源544
17.5.3 事件侦听器545
17.5.4 事件类和侦听器接口545
17.5.5 适配器类546
17.6 使用按钮547
17.7 JTextField类介绍554
17.8 使用匿名内部类来处理事件564
17.9 习题565
第18章 探索Swing控件567
18.1 JLabel类和ImageIcon类567
18.2 Swing按钮570
18.2.1 处理动作事件571
18.2.2 处理项事件571
18.2.3 JButton类572
18.2.4 JToggleButton类574
18.2.5 复选框576
18.2.6 单选按钮579
18.3 JTextField类581
18.4 JScrollPane类590
18.5 JList类597
18.6 JComboBox类601
18.7 树603
18.8 JTable类606
18.9 模型简介609
18.10 习题609
第19章 使用菜单612
19.1 菜单基础612
19.2 JMenuBar类、JMenu类和JMenuItem类概览613
19.2.1 JMenuBar类613
19.2.2 JMenu类614
19.2.3 JMenuItem类615
19.3 创建主菜单616
19.4 为菜单项添加助记键和快捷键620
19.5 为菜单项添加图像和工具提示622
19.6 使用JRadioButtonMenuItem类和JCheckBoxMenuItem类629
19.7 习题632
第20章 对话框634
20.1 JOptionPane类634
20.2 showMessageDialog()方法636
20.3 showConfirmDialog()方法640
20.4 showInputDialog()方法644
20.5 showOptionDialog()方法648
20.6 JDialog类652
20.7 创建无模式的对话框656
20.8 用JFileChooser类选择文件657
20.9 习题667
第21章 线程、applet和绘图670
21.1 Swing中的多线程670
21.2 使用Timer类676
21.3 创建Swing的applet681
21.4 绘图689
21.4.1 绘图基础689
21.4.2 图形上下文689
21.4.3 计算可绘图区域690
21.4.4 请求绘图691
21.4.5 绘图的例子691
21.5 习题695
第三部分 畅游Java API库
第22章 处理字符串698
22.1 字符串的基础知识698
22.2 字符串的构造函数699
22.3 三个与字符串有关的语言特性701
22.3.1 字符串字面量701
22.3.2 字符串拼接702
22.3.3 字符串与其他数据类型拼接702
22.3.4 重写toString()方法703
22.4 length()方法707
22.5 获得字符串中的字符708
22.5.1 charAt()方法708
22.5.2 getChars()方法708
22.5.3 toCharArray()方法709
22.6 字符串比较710
22.6.1 equals()方法和equalsIgnoreCase()方法710
22.6.2 equals()方法与“==”运算符的比较711
22.6.3 regionMatches()方法712
22.6.4 startsWith()方法和endsWith()方法712
22.6.5 compareTo()方法和compareToIgnoreCase()方法713
22.7 使用indexOf()方法和lastIndexOf()方法715
22.8 获得修改的字符串716
22.8.1 substring()方法716
22.8.2 replace()方法718
22.8.3 trim()方法719
22.9 改变字符串中字符的大小写720
22.10 StringBuffer类和StringBuilder类722
22.11 习题723
第23章 探索java.lang包725
23.1 基本类型包装器726
23.1.1 Number类726
23.1.2 Double类和Float类726
23.1.3 Byte类、Short类、Integer类和Long类728
23.1.4 Character类731
23.1.5 Boolean类734
23.1.6 自动装箱和类型包装器734
23.2 Math类735
23.3 Process类738
23.4 ProcessBuilder类738
23.5 Runtime类740
23.6 System类742
23.6.1 使用currentTimeMillis()方法测量程序执行的时间743
23.6.2 使用arraycopy()方法744
23.6.3 获得属性值744
23.6.4 重定向标准输入流和标准输出流745
23.7 Object类746
23.8 Class类747
23.9 Enum类749
23.10 与线程有关的类和Runnable接口749
23.11 其他类749
23.12 java.lang包中的接口750
23.12.1 Comparable接口750
23.12.2 Appendable接口752
23.12.3 Iterable接口752
23.12.4 Readable接口753
23.12.5 CharSequence接口753
23.12.6 AutoCloseable接口753
23.13 习题754
第24章 探索java.util包756
24.1 Locale类757
24.2 使用日期和时间760
24.2.1 Date类760
24.2.2 Calendar类和GregorianCalendar类761
24.3 用Formatter类格式化输出766
24.3.1 Formatter类的构造函数766
24.3.2 格式化基础768
24.3.3 格式化字符串和字符769
24.3.4 格式化数字769
24.3.5 格式化日期和时间770
24.3.6 说明符%n和说明符%%772
24.3.7 指定最小的域宽度772
24.3.8 指定精度773
24.3.9 使用格式标志774
24.3.10 大写字母选项776
24.3.11 使用实参索引777
24.3.12 为不同的地区设置格式化778
24.3.13?关闭Formatter对象778
24.4 格式化和printf()方法781
24.5 Scanner类783
24.5.1?Scanner类的构造函数783
24.5.2?Scanner类的基础知识783
24.5.3?Scanner类的例子785
24.5.4?Scanner类的其他特性789
24.6 Random类790
24.7 使用Observable类和Observer接口792
24.8 Timer类和TimerTask类795
24.9 其他混杂的应用类和接口797
24.10 习题798
第25章 使用集合框架中的数据结构800
25.1 数据结构概览800
25.1.1?栈和队列801
25.1.2?链表801
25.1.3?树802
25.1.4?散列表803
25.1.5?选择数据结构803
25.2 集合概览804
25.3 集合接口805
25.3.1?Collection接口806
25.3.2?List接口807
25.3.3?Set接口808
25.3.4?SortedSet接口809
25.3.5?NavigableSet接口809
25.3.6?Queue接口810
25.3.7?Deque接口811
25.4 集合类813
25.4.1?ArrayList类814
25.4.2?LinkedList类817
25.4.3?HashSet类820
25.4.4?TreeSet类822
25.4.5?LinkedHashSet类824
25.4.6?ArrayDeque类825
25.4.7?PriorityQueue类827
25.5 通过迭代器访问集合828
25.5.1?使用迭代器829
25.5.2?用for-each风格的循环代替迭代器831
25.6 使用映射832
25.6.1?映射接口832
25.6.2?映射类835
25.7 比较器840
25.8 集合算法842
25.9 Arrays类845
25.10 遗留类和遗留接口846
25.10.1?Enumeration接口846
25.10.2?Vector类846
25.10.3?Stack类846
25.10.4?Dictionary类846
25.10.5?Hashtable类846
25.10.6?Properties类847
25.11 习题847
第26章 使用java.net包进行网络编程849
26.1 网络基础849
26.2 网络类和网络接口850
26.3 InetAddress类851
26.4 Socket类853
26.5 URL类856
26.6 URLConnection类858
26.7 HttpURLConnection类862
26.8 数据报865
26.8.1?DatagramSocket类865
26.8.2?DatagramPacket类865
26.8.3 数据报的例子866
26.9 习题869
第27章 并发实用工具870
27.1 并发API包871
27.1.1 java.util.concurrent包871
27.1.2 java.util.concurrent.atomic包872
27.1.3 java.util.concurrent.locks包872
27.2 使用同步对象872
27.2.1 Semaphore类872
27.2.2 CountDownLatch类876
27.2.3 CyclicBarrier类878
27.2.4 Exchanger类881
27.2.5 Phaser类883
27.3 使用执行器890
27.4 使用Callable接口和Future接口892
27.5 TimeUnit枚举895
27.6 并发集合896
27.7 锁897
27.8 原子操作900
27.9 通过Fork/Join框架并行编程900
27.10 主要的Fork/Join类901
27.10.1 ForkJoinTask类901
27.10.2 RecursiveAction类902
27.10.3 RecursiveTask类902
27.10.4 ForkJoinPool类903
27.11 分治策略904
27.11.1 第一个简单的Fork/Join示例904
27.11.2 理解并行度的影响906
27.11.3 使用RecursiveTask类的一个例子910
27.11.4 异步执行任务912
27.12 并发实用工具与Java的传统方法的比较912
27.13 习题913
附录A 使用Java文档注释915
附录B 正则表达式介绍921
附录C 部分习题的参考答案928
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>java 7程序设计入门经典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序开发大全
第1章 初识myeclipse 1
1.1 myeclipse简介 1
1.2 myeclipse的安装 1
1.2.1 jdk的安装与配置 1
1.2.2 myeclipse 7.0的安装和运行 4
1.3 获取和阅读myeclipse帮助文档 5
1.4 本章小结 5
第2章 myeclipse集成开发环境的使用 6
2.1 myeclipse集成开发工具界面 6
2.1.1 myeclipse的菜单栏 7
2.1.2 myeclipse的工具栏 13
2.1.3 myeclipse的透视图 14
2.1.4 myeclipse的视图 17
2.1.5 myeclipse的编辑器 20
2.1.6 myeclipse的tasks视图 22
2.1.7 myeclipse的bookmarks视图 24
2.2 myeclipse中的资源管理 26
2.2.1 myeclipse中的工作空间 26
2.2.2 myeclipse中的navigator视图 27
2.3 定制myeclipse的工作台 33
.2.3.1 定制工作台外观 34
2.3.2 定制快捷键 35
2.3.3 定制编辑器 36
2.3.4 定制工作台公共设置 36
2.4 myeclipse中常用操作 36
2.4.1 配置jre 36
2.4.2 设置编译路径 37
2.4.3 设置项目属性 38
2.5 本章小结 39
第3章 java程序的开发 40
3.1 使用jdt编写java项目 40
3.2 myeclipse中的java代码编辑器 43
3.2.1 java代码编辑器基本功能 43
3.2.2 自定义java代码编辑器 45
3.2.3 java代码编辑器相关视图 50
3.3 myeclipse中的java代码编译器 51
3.4 myeclipse中的java代码调试器 52
3.4.1 java项目的运行 52
3.4.2 java项目的调试 53
3.5 myeclipse中的java代码搜索器 57
3.5.1 搜索功能 57
3.5.2 查找功能 58
3.6 myeclipse中的java代码重构支持 59
3.6.1 java元素重命名 59
3.6.2 java元素移动 60
3.6.3 java元素复制 61
3.7 本章小结 61
第4章 java开发的版本控制及svn 62
4.1 版本控制与svn 62
4.2 svn服务器的安装与配置 62
4.3 myeclipse连接svn服务器 63
4.3.1 配置myeclipse连接svn服务器 63
4.3.2 将svn服务器中的项目导入到myeclipse 64
4.3.3 将myeclipse中的项目提交到svn服务器 65
4.4 本章小结 67
第5章 java开发项目的软件测试工具——junit 68
5.1 软件测试简介 68
5.2 junit简介 68
5.2.1 junit的特点 69
5.2.2 junit的常用类和接口 69
5.3 在myeclipse中设置junit 71
5.4 junit测试 72
5.4.1 junit测试用例 72
5.4.2 junit测试套件 75
5.5 junit应用实例：数据库程序单元测试 77
5.6 本章小结 80
第6章 java web应用程序的开发 81
6.1 java web应用程序概述 81
6.2 tomcat服务器的安装和配置 82
6.2.1 tomcat服务器的下载 82
6.2.2 tomcat服务器的安装与配置 83
6.2.3 myeclipse中集成tomcat服务器 85
6.3 使用myeclipse开发web应用程序 86
6.3.1 创建web项目 87
6.3.2 创建html静态页面 88
6.3.3 创建jsp页面 90
6.3.4 创建servlet 91
6.3.5 创建web项目中的java类文件 92
6.3.6 发布和运行web项目 94
6.4 web应用实例：登录系统 96
6.5 本章小结 102
第7章 数据库应用程序的开发及应用 103
7.1 mysql数据库的安装与配置 103
7.2 myeclipse中的database explorer透视图 106
7.2.1 切换到database explorer透视图 107
7.2.2 连接到mysql数据库 107
7.2.3 打开数据库连接 108
7.2.4 关闭数据库连接 108
7.2.5 浏览数据库结构 109
7.2.6 编辑和执行sql语句 110
7.2.7 生成实体关系图 111
7.2.8 编辑和清除数据表中的数据 112
7.2.9 创建和删除数据表 112
7.2.10 创建和删除外键 113
7.2.11 自动生成sql语句 113
7.3 jdbc应用实例：登录系统 114
7.4 本章小结 116
第8章 struts框架的开发及应用 117
8.1 struts框架概述 117
8.1.1 mvc设计模式 117
8.1.2 struts框架工作原理 118
8.1.3 struts框架执行流程 118
8.2 myeclipse创建基于struts框架的项目 119
8.2.1 创建struts项目 119
8.2.2 struts组件向导 121
8.2.3 struts配置文件编辑器 124
8.3 struts应用实例：登录系统 125
8.4 本章小结 133
第9章 hibernate框架的开发及应用 134
9.1 hibernate框架概述 134
9.1.1 o/r mapping（对象/关系映射）技术 134
9.1.2 hibernate框架的作用 135
9.1.3 hibernate框架与jdbc技术的比较 135
9.1.4 hibernate框架工作流程 137
9.2 myeclipse创建基于hibernate框架的项目 138
9.2.1 创建hibernate项目 139
9.2.2 创建hibernate配置文件 140
9.2.3 创建hibernate使用的数据库连接 140
9.2.4 创建sessionfactory类 140
9.2.5 使用hibernate配置文件编辑器 141
9.2.6 使用反向工程生成持久化对象、映射文件和dao类 143
9.2.7 使用hibernate功能 151
9.3 myeclipse中hibernate框架的高级操作 152
9.3.1 在hibernate反向工程中定制映射关系 153
9.3.2 使用hql编辑器 154
9.4 hibernate应用实例：基于struts+hibernate的登录系统 155
9.5 本章小结 160
第10章 spring框架的开发及应用 161
10.1 spring框架概述 161
10.2 spring框架中的ioc编程 162
10.2.1 控制反转的原理 163
10.2.2 控制反转中的主要组件 163
10.2.3 控制反转中的依赖注入方式 164
10.3 spring框架中的aop编程 165
10.3.1 面向切面编程的原理 165
10.3.2 面向切面编程中的主要概念 166
10.4 使用myeclipse实现spring框架中的ioc编程 166
10.4.1 创建spring项目 166
10.4.2 创建bean类 167
10.4.3 配置bean类 168
10.4.4 编写测试代码 171
10.5 使用myeclipse实现spring框架中的aop编程 173
10.5.1 向项目添加aop支持包 173
10.5.2 创建bean类 173
10.5.3 创建前置通知类 174
10.5.4 装配拦截器和配置bean类 175
10.5.5 编写测试代码 176
10.6 spring整合struts框架 177
10.6.1 使用actionsupport类整合struts 177
10.6.2 覆盖requestprocessor类整合struts 178
10.6.3 将action管理委托给spring框架 180
10.7 spring整合hibernate框架 182
10.7.1 创建hibernate+spring项目 182
10.7.2 反向工程生成spring整合hibernate的dao 184
10.7.3 spring实现事务自动提交 188
10.8 基于spring与struts、hibernate整合的登录系统 194
10.9 本章小结 199
第11章 jsf框架的开发与应用 200
11.1 jsf框架概述 200
11.1.1 jsf框架工作方式 200
11.1.2 jsf框架的请求处理生命周期 201
11.1.3 jsf应用程序结构 202
11.2 myeclipse创建基于jsf框架的项目 202
11.2.1 创建jsf项目 202
11.2.2 jsf配置文件编辑器 203
11.2.3 创建managed bean 204
11.2.4 创建jsp页面 206
11.2.5 创建导航规则 207
11.3 jsf应用实例：登录系统 207
11.4 本章小结 213
第12章 struts 2.0的开发及应用 214
12.1 struts 2.0框架概述 214
12.1.1 struts 2.0框架工作流程 214
12.1.2 struts 2.0与struts 1.x框架的区别 215
12.2 myeclipse创建基于struts 2.0框架的项目 215
12.2.1 下载struts 2.0开发包 216
12.2.2 创建struts 2.0项目 216
12.2.3 配置struts 2.0项目 217
12.2.4 创建struts 2.0的action类 218
12.2.5 struts 2.0中的国际化编程 221
12.2.6 创建基于pojo的action 223
12.3 spring整合struts 2.0框架 224
12.4 struts 2.0应用实例：登录系统 227
12.5 本章小结 231
第13章 jpa的开发与应用 232
13.1 jpa规范概述 232
13.2 myeclipse创建基于jpa规范的项目 233
13.2.1 创建jpa项目 233
13.2.2 使用反向工程生成jpa实体类和dao类 234
13.2.3 调整生成的实体类标注 237
13.2.4 使用jpa功能 238
13.3 myeclipse中支持jpa规范的工具 238
13.3.1 jpa透视图 239
13.3.2 jpa标注配置视图 239
13.3.3 jpa代码编辑辅助功能 240
13.4 spring整合jpa框架 240
13.4.1 向项目添加spring框架功能支持 241
13.4.2 反向工程生成jpa 实体类和spring dao类 242
13.4.3 创建测试类 243
13.5 本章小结 243
第14章 web service的开发及应用 244
14.1 web service概述 244
14.2 使用myeclipse创建web service项目 245
14.2.1 创建web service项目 245
14.2.2 开发web service服务器端 247
14.2.3 发布和运行web service 249
14.2.4 使用web services explorer访问web service 250
14.2.5 使用java客户端访问web service 251
14.3 向现有web项目加入web service功能 252
14.4 创建直接调用internet中的web service的客户端 252
14.4.1 创建客户端weatherwsclient项目 253
14.4.2 使用wsdl生成客户端代码 253
14.4.3 创建web service客户端测试代码 255
14.5 本章小结 255
第15章 java ee中ejb的开发 256
15.1 ejb概述 256
15.2 weblogic服务器的安装与配置 257
15.2.1 weblogic服务器的安装 257
15.2.2 weblogic服务器的配置 258
15.2.3 myeclipse中集成weblogic服务器 260
15.3 使用myeclipse开发ejb 261
15.3.1 开发session bean 261
15.3.2 开发entity bean 267
15.3.3 开发message driven bean 275
15.4 本章小结 277
第16章 java me的开发及应用 278
16.1 java me概述 278
16.2 wireless toolkit的安装和配置 279
16.3 myeclipse中java me开发环境的搭建 280
16.3.1 搭建myeclipse+eclipseme开发平台 281
16.3.2 myeclipse+eclipseme开发平台集成wtk 283
16.4 使用myeclipse开发java me应用 284
16.5 java me应用实例：吃豆游戏 286
16.6 本章小结 289
第17章 swt的开发及应用 290
17.1 swt简介 290
17.1.1 swt概述 290
17.1.2 swt的包结构 290
17.2 swt中的常用类 291
17.2.1 widget类 291
17.2.2 display类 292
17.2.3 shell类 292
17.3 swt中的基本组件 294
17.3.1 标签（label）组件 294
17.3.2 按钮（button）组件 295
17.3.3 文本框（text）组件 295
17.3.4 列表框（list）组件 297
17.3.5 组合框（combo）组件 298
17.3.6 菜单栏（menu）和菜单项（menuitem） 299
17.4 swt中的布局管理器 302
17.4.1 rowlayout布局管理器 302
17.4.2 filllayout布局管理器 304
17.4.3 gridlayout布局管理器 305
17.4.4 formlayout布局管理器 308
17.5 swt中的事件模型 309
17.6 本章小结 313
第18章 uml建模 314
18.1 uml概述 314
18.2 myeclipse中的uml支持 314
18.3 使用myeclipse创建uml模型仓库 315
18.4 使用myeclipse创建uml图 316
18.4.1 创建uml图 316
18.4.2 设计uml图 317
18.5 使用myeclipse实现正向工程和反向工程 324
18.5.1 myeclipse中实现正向工程 324
18.5.2 myeclipse中实现反向工程 324
18.6 本章小结 326
第19章 使用myeclipse开发插件 327
19.1 myeclipse中的插件机制 327
19.2 myeclipse使用pde开发插件 328
19.2.1 简单的插件开发 328
19.2.2 创建一个空白的插件项目 331
19.3 rcp应用程序的开发 333
19.3.1 rcp应用开发初步 333
19.3.2 创建用户自定义的菜单和工具条 338
19.4 本章小结 341
第20章 网上宠物商店（jsp+javabean） 342
20.1 系统需求分析与概要设计 342
20.1.1 系统需求分析 342
20.1.2 系统模块划分 342
20.2 数据库设计 344
20.3 使用myeclipse创建项目 347
20.4 系统公共模块的实现 348
20.4.1 建立数据库连接的dbconnection类 348
20.4.2 格式化处理时间的strformat类 350
20.5 登录和注册模块的实现 351
20.5.1 对应用户的实体类user 351
20.5.2 用户注册页面register.jsp 354
20.5.3 负责用户注册的servlet类reg 356
20.5.4 生成随机验证码的imgnum类 358
20.5.5 用户登录页面index.jsp 359
20.5.6 验证用户登录信息的servlet类login 360
20.6 显示宠物信息模块的实现 363
20.6.1 对应宠物的实体类user 363
20.6.2 定义对宠物信息进行数据库操作的业务逻辑类petbuy 363
20.6.3 分页显示系统中销售的所有宠物信息的页面newpet.jsp 366
20.6.4 显示销售的每个宠物详细信息的页面petinfo.jsp 368
20.7 显示宠物商品模块的实现 370
20.7.1 显示商品页面 370
20.7.2 定义对宠物商品信息进行数据库操作的业务逻辑类thingsbuy 370
20.8 显示宠物新闻模块的实现 373
20.8.1 对应宠物新闻的实体类news 374
20.8.2 定义对宠物新闻进行数据库操作的业务逻辑类newsbuy 374
20.8.3 分页显示宠物新闻的页面petnews.jsp 375
20.8.4 显示宠物新闻详细内容的页面newsinfo.jsp 377
20.9 显示宠物知识模块的实现 378
20.10 留言模块的实现 379
20.10.1 发表留言评论的页面comment.jsp 379
20.10.2 将用户评论信息插入到数据库中的servlet类comment 381
20.11 后台管理模块的实现 384
20.11.1 后台管理模块的用户登录页面index.jsp 384
20.11.2 后台管理模块的首页面default.jsp 385
20.11.3 输入要添加的宠物信息的页面addpet.jsp 386
20.11.4 将宠物添加到系统中的页面addpet_do.jsp 387
20.11.5 显示系统全部宠物信息的页面petlist.jsp 389
20.11.6 显示出售的宠物信息的页面petnote.jsp 392
20.11.7 后台管理模块的业务逻辑处理类ctrladmin 393
20.12 项目发布与执行 397
20.13 本章小结 397
第21章 新闻管理系统（struts+hibernate） 398
21.1 系统需求分析与概要设计 398
21.1.1 系统需求分析 398
21.1.2 系统模块划分 398
21.2 数据库设计 399
21.3 使用myeclipse创建项目 400
21.3.1 创建web项目 400
21.3.2 向项目添加struts框架 401
21.3.3 向项目添加hibernate框架 402
21.3.4 向项目添加数据库驱动程序jar包 403
21.3.5 项目中的包组织结构 403
21.3.6 项目中的系统配置文件 404
21.4 系统公共模块的实现 411
21.4.1 实现字符集转换的过滤器类setcharacterencodingfilter 411
21.4.2 实现页面分页功能的pager和pagerhelper类 412
21.4.3 实现md5加密算法的md5类 413
21.5 管理员登录模块的实现 413
21.5.1 管理员登录页面adminlogin.jsp 414
21.5.2 管理员登录的actionform类adminloginform 416
21.2.3 管理员登录的action类adminloginaction 417
21.5.4 创建系统中各个业务逻辑类的工厂类managerfactory 419
21.4.5 定义管理员信息业务逻辑操作方法的接口adminmanager 419
21.4.6 adminmanager接口的实现类adminmanagerimpl 420
21.4.7 定义管理员dao操作方法的接口admindao 421
21.4.8 admindao接口的实现类admindaoimpl 421
21.4.9 管理员实体类admin和实体映射文件 426
21.4.10 系统中的dao配置类daoconfig 428
21.6 新闻类别管理模块的实现 429
21.6.1 生成添加新闻类别页面中新闻类别层次树的action类addsortaction 430
21.6.2 添加新闻类别的页面addsort.jsp 430
21.6.3 添加新闻类别的actionform类和action类 431
21.6.4 定义新闻类别信息业务逻辑操作方法的接口sortmanager 432
21.6.5 sortmanager接口的实现类sortmanagerimpl 433
21.6.6 定义新闻类别dao操作方法的接口sortdao 434
21.6.7 sortdao接口的实现类sortdaoimpl 434
21.6.8 新闻类别实体类sort和实体映射文件 445
21.7 新闻管理模块的实现 447
21.7.1 返回到添加新闻页面的action类addnewsaction 447
21.7.2 添加新闻的页面addnews.jsp 448
21.7.3 定义新闻业务逻辑操作方法的接口newsmanager 448
21.7.4 newsdao接口的实现类newsdaoimpl 449
21.8 自动生成页面模块的实现 453
21.8.1 生成前台页面 454
21.8.2 生成首页面的模板页面 457
21.9 管理员账户管理模块的实现 458
21.10 项目发布与执行 460
21.11 本章小节
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序开发大全
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>01OCA Java SE 7 Programmer I认证学习指南
目    录


第1章　分包、编译和解释Java代码	1
1.1  理解包	2
1.1.1  包设计	2
1.1.2  包和import语句	3
1.2  理解包派生类	7
1.2.1  Java 实用工具API	7
1.2.2  Java基本输入/输出API	9
1.2.3  Java网络API	9
1.2.4  Java抽象窗口工具API	9
1.2.5  Java Swing API	10
1.3  理解类结构	13
1.3.1  命名规范	13
1.3.2  分隔符和其他Java源符号	14
1.3.3  Java类结构	14
1.4  编译和解释Java代码	16
1.4.1  Java编译器	16
1.4.2  Java解释器	18
1.5  认证小结	22
1.6  知识点回顾	22
1.6.1  理解包	22
1.6.2  理解包派生类	23
1.6.3  理解类结构	23
1.6.4  编译和解释Java代码	23
1.7  自测题	24
1.7.1  理解包	24
1.7.2  理解包派生类	24
1.7.3  理解类结构	25
1.7.4  编译和解释Java代码	26
1.8  自测题答案	26
1.8.1  理解包	26
1.8.2  理解包派生类	27
1.8.3  理解类结构	27
1.8.4  编译和解释Java代码	27
第2章　Java语句编程	29
2.1  理解赋值语句	31
2.2  创建和使用条件语句	32
2.2.1  if条件语句	33
2.2.2  if-then条件语句	34
2.2.3  if-then-else条件语句	35
2.2.4  switch条件语句	36
2.3  创建和使用迭代语句	39
2.3.1  for循环迭代语句	39
2.3.2  增强的for循环迭代语句	40
2.3.3  while迭代语句	41
2.3.4  do-while迭代语句	42
2.4  创建和使用控制转换语句	44
2.4.1  break控制转换语句	44
2.4.2  continue控制转换语句	44
2.4.3  return控制转换语句	45
2.4.4  标记语句	46
2.5  认证小结	47
2.6  知识点回顾	48
2.6.1  理解赋值语句	48
2.6.2  创建和使用条件语句	48
2.6.3  创建和使用迭代语句	48
2.6.4  创建和使用控制转换语句	48
2.7  自测题	48
2.7.1  理解赋值语句	49
2.7.2  创建和使用条件语句	49
2.7.3  创建和使用迭代语句	50
2.7.4  创建和使用控制转换语句	50
2.8  自测题答案	50
2.8.1  理解赋值语句	50
2.8.2  创建和使用条件语句	51
2.8.3  创建和使用迭代语句	51
2.8.4  创建和使用控制转换语句	52
第3章　Java运算符和字符串编程	53
3.1  理解基本运算符	54
3.1.1  赋值运算符	54
3.1.2  算术运算符	57
3.1.3  关系运算符	58
3.1.4  逻辑运算符	61
3.2  理解运算符优先级	63
3.2.1  运算符优先级	63
3.2.2  重写运算符优先级	64
3.3  使用String对象及其方法	65
3.3.1  字符串	65
3.3.2  String连接运算符	66
3.3.3  String类的方法	70
3.4  使用StringBuilder对象及
其方法	75
3.5  测试字符串和其他对象之间的
相等性	79
3.6  认证小结	81
3.7  知识点回顾	81
3.7.1  理解基本运算符	81
3.7.2  理解运算符优先级	82
3.7.3  使用String对象及其方法	82
3.7.4  使用StringBuilder对象及
其方法	83
3.7.5  String和其他对象间的相等
性测试	83
3.8  自测题	83
3.8.1  理解基本运算符	83
3.8.2  理解运算符优先级	86
3.8.3  使用String对象及其方法	86
3.8.4  使用StringBuilder对象及其
方法	88
3.8.5  字符串和其他对象间的相等性
测试	88
3.9  自测题答案	88
3.9.1  理解基本运算符	88
3.9.2  理解运算符优先级	89
3.9.3  使用String对象及其方法	89
3.9.4  使用StringBuilder对象及其
方法	90
3.9.5  字符串和其他对象的相等性
测试	90
第4章　使用基本类和变量	91
4.1  理解基本数据类型、枚举和
对象	92
4.1.1  基本数据类型变量	92
4.1.2  对象	98
4.1.3  数组	101
4.1.4  枚举	101
4.1.5  Java是强类型	102
4.1.6  命名规范	103
4.2  使用基本数据类型、枚举和
对象	103
4.2.1  字面值	104
4.2.2  基本数据类型、枚举和对象的
示例	104
4.3  认证小结	107
4.4  知识点回顾	107
4.4.1  理解基本数据类型、枚举和
对象	107
4.4.2  使用基本数据类型、枚举和
对象	108
4.5  自测题	108
4.5.1  理解基本数据类型、枚举和
对象	108
4.5.2  使用基本数据类型、枚举和
对象	110
4.6  自测题答案	112
4.6.1  理解基本数据类型、枚举和
对象	112
4.6.2  使用基本数据类型，枚举和
对象	112
第5章　理解方法和变量的作用域	115
5.1  创建和使用方法	116
5.1.1  使用方法语法	116
5.1.2　创建和调用方法	118
5.1.3　重载方法	119
5.2　通过引用和值传递对象	121
5.2.1　通过值传递基本数据类型给
方法	121
5.2.2　通过引用传递对象给方法	121
5.3  理解变量的作用域	123
5.3.1  局部变量	123
5.3.2  方法参数	125
5.3.3  实例变量	125
5.3.4  对象的生命周期	127
5.4  创建和使用构造函数	127
5.4.1  创建构造函数	127
5.4.2  重载构造函数	128
5.4.3  使用默认构造函数	129
5.5  使用this和super关键字	129
5.5.1  this关键字	129
5.5.2  super关键字	131
5.6  创建静态方法和实例变量	133
5.6.1  静态方法	133
5.6.2  静态变量	134
5.6.3  常量	135
5.7  认证小结	135
5.8  知识点回顾	136
5.8.1  创建和使用方法	136
5.8.2  通过引用和值传递对象	136
5.8.3  理解变量的作用域	136
5.8.4  创建和使用构造函数	136
5.8.5  使用this和super关键字	137
5.8.6  创建静态方法和实例变量	137
5.9  自测题	137
5.9.1  创建和使用方法	137
5.9.2  通过引用和值传递对象	138
5.9.3  理解变量的作用域	139
5.9.4  创建和使用构造函数	140
5.9.5  使用this和super关键字	141
5.9.6  创建静态方法和实例变量	141
5.10  自测题答案	143
5.10.1  创建和使用类	143
5.10.2  通过引用和值传递对象	143
5.10.3  理解变量的作用域	143
5.10.4  创建和使用构造函数	143
5.10.5  使用this和super关键字	144
5.10.6  创建静态方法和实例
变量	144
第6章　数组编程	145
6.1　使用Java数组	146
6.1.1　一维数组	146
6.1.2  多维数组	149
6.2  使用ArrayList对象及其方法	151
6.2.1  使用ArrayList类	151
6.2.2  ArrayList与标准数组的
比较	153
6.3  认证小结	154
6.4  知识点回顾	155
6.4.1  使用Java数组	155
6.4.2  使用ArrayList对象及其
方法	155
6.5  自测题	156
6.5.1  使用Java数组	156
6.5.2  使用ArrayList对象及其
方法	158
6.6  自测题答案	160
6.6.1  使用Java数组	160
6.6.2  使用ArrayList对象及其
方法	160
第7章　理解类继承	163
7.1  实现并使用继承和类类型	164
7.1.1  继承	164
7.1.2  重写方法	166
7.1.3  抽象类	167
7.1.4  接口	168
7.1.5  继承的高级概念	169
7.2  理解封装原则	170
7.2.1  使用封装的良好设计	170
7.2.2  访问修饰符	171
7.2.3  setter和getter方法	173
7.3  类继承和封装的高级应用	174
7.3.1  Java访问修饰符示例	174
7.3.2  具体类继承的示例	175
7.3.3  抽象类继承的示例	178
7.3.4  接口示例	182
7.4  认证小结	184
7.5  知识点回顾	184
7.5.1  实现并使用继承和类类型	184
7.5.2  理解封装原则	185
7.5.3  类继承和封装的高级应用	185
7.6  自测题	185
7.6.1  实现并使用继承和类类型	185
7.6.2  理解封装原则	186
7.6.3  类继承和封装的高级应用	187
7.7  自测题答案	188
7.7.1  实现并使用继承和类类型	188
7.7.2  理解封装原则	188
7.7.3  类继承和封装的高级应用	189
第8章  理解多态和类型转换	191
8.1  理解多态	192
8.1.1  多态的概念	192
8.1.2  多态的实践示例	195
8.2  理解类型转换	203
8.3  认证小结	207
8.4  知识点回顾	208
8.4.1  理解多态	208
8.4.2  理解类型转换	208
8.5  自测题	208
8.5.1  理解多态	208
8.5.2  理解类型转换	211
8.6  自测题答案	212
8.6.1  理解多态	212
8.6.2  理解类型转换	212
第9章  异常处理	213
9.1  理解异常的基本原理和类型	214
9.1.1  Java中异常的层次结构	214
9.1.2  已检查的异常	215
9.1.3  未检查的异常	215
9.1.4  (未检查的)错误	216
9.2  理解异常的本质	216
9.2.1  定义异常	217
9.2.2  抛出异常	217
9.2.3  传递异常	217
9.3  改变程序流程	219
9.3.1  try-catch语句	219
9.3.2  try-finally语句	221
9.3.3  try-catch-finally语句	222
9.3.4  try-with-resources语句	222
9.3.5  multi-catch子句	223
9.4  识别常见异常	224
9.4.1  常见的已检查的异常	225
9.4.2  常见的未检查的异常	226
9.4.3  常见的错误	228
9.5  认证小结	230
9.6  知识点回顾	231
9.6.1  理解异常的基本原理和
类型	231
9.6.2  理解异常的本质	231
9.6.3  改变程序流程	231
9.6.4  识别常见异常	231
9.7  自测题	232
9.7.1  理解异常的基本原理和
类型	232
9.7.2  理解异常的本质	232
9.7.3  改变程序流程	233
9.7.4  识别常见异常	234
9.8  自测题答案	235
9.8.1  理解异常的基本原理和
类型	235
9.8.2  理解异常的本质	235
9.8.3  改变程序流程	235
9.8.4  识别常见异常	235
第10章　使用类及其关系	237
10.1  理解类的组合与关联	238
10.1.1  类的组合与关联	238

10.1.2  类关系	239
10.1.3  多重性	240
10.1.4  关联导航	241
10.2  类的组合与关联的实践	242
10.2.1  类关联关系的示例	242
10.2.2  类组合关系的示例	244
10.2.3  关联导航的示例	245
10.3  认证小结	245
10.4  知识点回顾	246
10.4.1  理解类的组合与关联	246
10.4.2  类的组合与关联的实践	247
10.5  自测题	247
10.5.1  理解类的组合与关联	247
10.5.2  类的组合与关联的实践	248
10.6  自测题答案	249
10.6.1  理解类的组合与关联	249
10.6.2  类的组合与关联的实践	250
附录A  Java平台	251
附录B　Java SE 7的包	259
附录C　Java关键字	269
附录D　括号规范	271
附录E　Unicode标准	273
附录F　伪代码算法	275
附录G　统一建模语言	279
术语表……………………………………..287






>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>01OCA Java SE 7 Programmer I认证学习指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>第一行代码：Android（第2版）
第1章　开始启程——你的第一行Android代码　　1
1.1　了解全貌——Android王国简介　　2
1.1.1　Android系统架构　　2
1.1.2　Android已发布的版本　　3
1.1.3　Android应用开发特色　　4
1.2　手把手带你搭建开发环境　　5
1.2.1　准备所需要的工具　　5
1.2.2　搭建开发环境　　5
1.3　创建你的第一个Android项目　　9
1.3.1　创建HelloWorld项目　　9
1.3.2　启动模拟器　　12
1.3.3　运行HelloWorld　　15
1.3.4　分析你的第一个Android程序　　16
1.3.5　详解项目中的资源　　22
1.3.6　详解build.gradle文件　　23
1.4　前行必备——掌握日志工具的使用　　26
1.4.1　使用Android的日志工具Log　　26
1.4.2　为什么使用Log而不使用System.out　　27
1.5　小结与点评　　29
第2章　先从看得到的入手——探究活动　　30
2.1　活动是什么　　30
2.2　活动的基本用法　　30
2.2.1　手动创建活动　　31
2.2.2　创建和加载布局　　32
2.2.3　在AndroidManifest文件中注册　　35
2.2.4　在活动中使用Toast　　37
2.2.5　在活动中使用Menu　　38
2.2.6　销毁一个活动　　40
2.3　使用Intent在活动之间穿梭　　41
2.3.1　使用显式Intent　　41
2.3.2　使用隐式Intent　　44
2.3.3　更多隐式Intent的用法　　46
2.3.4　向下一个活动传递数据　　50
2.3.5　返回数据给上一个活动　　51
2.4　活动的生命周期　　53
2.4.1　返回栈　　53
2.4.2　活动状态　　54
2.4.3　活动的生存期　　55
2.4.4　体验活动的生命周期　　56
2.4.5　活动被回收了怎么办　　62
2.5　活动的启动模式　　63
2.5.1　standard　　64
2.5.2　singleTop　　65
2.5.3　singleTask　　67
2.5.4　singleInstance　　68
2.6　活动的最佳实践　　71
2.6.1　知晓当前是在哪一个活动　　71
2.6.2　随时随地退出程序　　72
2.6.3　启动活动的最佳写法　　74
2.7　小结与点评　　75
第3章　软件也要拼脸蛋——UI开发的点点滴滴　　76
3.1　如何编写程序界面　　76
3.2　常用控件的使用方法　　77
3.2.1　TextView　　77
3.2.2　Button　　80
3.2.3　EditText　　82
3.2.4　ImageView　　86
3.2.5　ProgressBar　　88
3.2.6　AlertDialog　　91
3.2.7　ProgressDialog　　93
3.3　详解4种基本布局　　94
3.3.1　线性布局　　94
3.3.2　相对布局　　100
3.3.3　帧布局　　103
3.3.4　百分比布局　　105
3.4　系统控件不够用？创建自定义控件　　108
3.4.1　引入布局　　109
3.4.2　创建自定义控件　　111
3.5　最常用和最难用的控件——ListView　　113
3.5.1　ListView的简单用法　　114
3.5.2　定制ListView的界面　　115
3.5.3　提升ListView的运行效率　　119
3.5.4　ListView的点击事件　　120
3.6　更强大的滚动控件——RecyclerView　　122
3.6.1　RecyclerView的基本用法　　122
3.6.2　实现横向滚动和瀑布流布局　　125
3.6.3　RecyclerView的点击事件　　130
3.7　编写界面的最佳实践　　132
3.7.1　制作Nine-Patch图片　　132
3.7.2　编写精美的聊天界面　　135
3.8　小结与点评　　141
第4章　手机平板要兼顾——探究碎片　　142
4.1　碎片是什么　　142
4.2　碎片的使用方式　　144
4.2.1　碎片的简单用法　　144
4.2.2　动态添加碎片　　147
4.2.3　在碎片中模拟返回栈　　150
4.2.4　碎片和活动之间进行通信　　151
4.3　碎片的生命周期　　151
4.3.1　碎片的状态和回调　　151
4.3.2　体验碎片的生命周期　　153
4.4　动态加载布局的技巧　　156
4.4.1　使用限定符　　156
4.4.2　使用最小宽度限定符　　159
4.5　碎片的最佳实践——一个简易版的新闻应用　　160
4.6　小结与点评　　169
第5章　全局大喇叭——详解广播机制　　170
5.1　广播机制简介　　170
5.2　接收系统广播　　171
5.2.1　动态注册监听网络变化　　171
5.2.2　静态注册实现开机启动　　174
5.3　发送自定义广播　　177
5.3.1　发送标准广播　　177
5.3.2　发送有序广播　　179
5.4　使用本地广播　　183
5.5　广播的最佳实践——实现强制下线功能　　185
5.6　Git时间——初识版本控制工具　　192
5.6.1　安装Git　　192
5.6.2　创建代码仓库　　193
5.6.3　提交本地代码　　195
5.7　小结与点评　　195
第6章　数据存储全方案——详解持久化技术　　196
6.1　持久化技术简介　　196
6.2　文件存储　　197
6.2.1　将数据存储到文件中　　197
6.2.2　从文件中读取数据　　201
6.3　SharedPreferences存储　　203
6.3.1　将数据存储到SharedPreferences中　　203
6.3.2　从SharedPreferences中读取数据　　206
6.3.3　实现记住密码功能　　208
6.4　SQLite数据库存储　　211
6.4.1　创建数据库　　211
6.4.2　升级数据库　　216
6.4.3　添加数据　　219
6.4.4　更新数据　　222
6.4.5　删除数据　　224
6.4.6　查询数据　　225
6.4.7　使用SQL操作数据库　　228
6.5　使用LitePal操作数据库　　229
6.5.1　LitePal简介　　229
6.5.2　配置LitePal　　230
6.5.3　创建和升级数据库　　231
6.5.4　使用LitePal添加数据　　236
6.5.5　使用LitePal更新数据　　237
6.5.6　使用LitePal删除数据　　240
6.5.7　使用LitePal查询数据　　241
6.6　小结与点评　　243
第7章　跨程序共享数据——探究内容提供器　　244
7.1　内容提供器简介　　244
7.2　运行时权限　　245
7.2.1　Android权限机制详解　　245
7.2.2　在程序运行时申请权限　　249
7.3　访问其他程序中的数据　　254
7.3.1　ContentResolver的基本用法　　254
7.3.2　读取系统联系人　　256
7.4　创建自己的内容提供器　　260
7.4.1　创建内容提供器的步骤　　261
7.4.2　实现跨程序数据共享　　265
7.5　Git时间——版本控制工具进阶　　275
7.5.1　忽略文件　　275
7.5.2　查看修改内容　　276
7.5.3　撤销未提交的修改　　278
7.5.4　查看提交记录　　279
7.6　小结与点评　　280
第8章　丰富你的程序——运用手机多媒体　　281
8.1　将程序运行到手机上　　281
8.2　使用通知　　283
8.2.1　通知的基本用法　　283
8.2.2　通知的进阶技巧　　289
8.2.3　通知的高级功能　　291
8.3　调用摄像头和相册　　293
8.3.1　调用摄像头拍照　　294
8.3.2　从相册中选择照片　　298
8.4　播放多媒体文件　　303
8.4.1　播放音频　　303
8.4.2　播放视频　　307
8.5　小结与点评　　311
第9章　看看精彩的世界——使用网络技术　　312
9.1　WebView的用法　　312
9.2　使用HTTP协议访问网络　　314
9.2.1　使用HttpURLConnection　　315
9.2.2　使用OkHttp　　319
9.3　解析XML格式数据　　321
9.3.1　Pull解析方式　　324
9.3.2　SAX解析方式　　326
9.4　解析JSON格式数据　　329
9.4.1　使用JSONObject　　330
9.4.2　使用GSON　　331
9.5　网络编程的最佳实践　　334
9.6　小结与点评　　338
第10章　后台默默的劳动者——探究服务　　339
10.1　服务是什么　　339
10.2　Android多线程编程　　340
10.2.1　线程的基本用法　　340
10.2.2　在子线程中更新UI　　341
10.2.3　解析异步消息处理机制　　345
10.2.4　使用AsyncTask　　347
10.3　服务的基本用法　　349
10.3.1　定义一个服务　　349
10.3.2　启动和停止服务　　352
10.3.3　活动和服务进行通信　　355
10.4　服务的生命周期　　359
10.5　服务的更多技巧　　359
10.5.1　使用前台服务　　359
10.5.2　使用IntentService　　361
10.6　服务的最佳实践——完整版的下载示例　　365
10.7　小结与点评　　378
第11章　Android特色开发——基于位置的服务　　379
11.1　基于位置的服务简介　　379
11.2　申请API Key　　380
11.3　使用百度定位　　384
11.3.1　准备LBS SDK　　384
11.3.2　确定自己位置的经纬度　　386
11.3.3　选择定位模式　　391
11.3.4　看得懂的位置信息　　393
11.4　使用百度地图　　395
11.4.1　让地图显示出来　　395
11.4.2　移动到我的位置　　397
11.4.3　让“我”显示在地图上　　400
11.5　Git时间——版本控制工具的高级用法　　402
11.5.1　分支的用法　　403
11.5.2　与远程版本库协作　　404
11.6　小结与点评　　406
第12章　最佳的UI体验——MaterialDesign实战　　407
12.1　什么是Material Design　　407
12.2　Toolbar　　408
12.3　滑动菜单　　415
12.3.1　DrawerLayout　　415
12.3.2　NavigationView　　418
12.4　悬浮按钮和可交互提示　　423
12.4.1　FloatingActionButton　　424
12.4.2　Snackbar　　427
12.4.3　CoordinatorLayout　　428
12.5　卡片式布局　　430
12.5.1　CardView　　431
12.5.2　AppBarLayout　　437
12.6　下拉刷新　　440
12.7　可折叠式标题栏　　443
12.7.1　CollapsingToolbarLayout　　443
12.7.2　充分利用系统状态栏空间　　453
12.8　小结与点评　　456
第13章　继续进阶——你还应该掌握的高级技巧　　457
13.1　全局获取Context的技巧　　457
13.2　使用Intent传递对象　　461
13.2.1　Serializable方式　　461
13.2.2　Parcelable方式　　463
13.3　定制自己的日志工具　　464
13.4　调试Android程序　　466
13.5　创建定时任务　　469
13.5.1　Alarm机制　　469
13.5.2　Doze模式　　471
13.6　多窗口模式编程　　472
13.6.1　进入多窗口模式　　473
13.6.2　多窗口模式下的生命周期　　475
13.6.3　禁用多窗口模式　　479
13.7　Lambda表达式　　481
13.8　总结　　485
第14章　进入实战——开发酷欧天气　　486
14.1　功能需求及技术可行性分析　　486
14.2　Git时间——将代码托管到GitHub上　　489
14.3　创建数据库和表　　494
14.4　遍历全国省市县数据　　499
14.5　显示天气信息　　509
14.5.1　定义GSON实体类　　509
14.5.2　编写天气界面　　514
14.5.3　将天气显示到界面上　　520
14.5.4　获取必应每日一图　　526
14.6　手动更新天气和切换城市　　532
14.6.1　手动更新天气　　532
14.6.2　切换城市　　535
14.7　后台自动更新天气　　540
14.8　修改图标和名称　　542
14.9　你还可以做的事情　　543
第15章　最后一步——将应用发布到360应用商店　　545
15.1　生成正式签名的APK文件　　545
15.1.1　使用Android Studio生成　　546
15.1.2　使用Gradle生成　　548
15.1.3　生成多渠道APK文件　　551
15.2　申请360开发者账号　　554
15.3　发布应用程序　　556
15.4　嵌入广告进行盈利　　560
15.4.1　注册腾讯广告联盟账号　　560
15.4.2　新建媒体和广告位　　562
15.4.3　接入广告SDK　　564
15.4.4　重新发布应用程序　　569
15.5　结束语　　570
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>第一行代码：Android（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>七周七并发模型
译者序
推荐序
致谢
前言
第1章 概述
1.1 并发？还是并行？
1.2 并行架构
1.3 并发：不只是多核
1.4 七个模型
第2章 线程与锁
2.1 简单粗暴
2.2 第一天 互斥和内存模型
2.3 第二天 超越内置锁
2.4 第三天 站在巨人的肩膀上
2.5 复习
第3章 函数式编程
3.1 若不爽，就另辟蹊径
3.2 第一天 抛弃可变状态
3.3 第二天 函数式并行
3.4 第三天 函数式并发
3.5 复习
第4章 Clojure之道——分离标识与状态
4.1 混搭的力量
4.2 第一天 原子变量与持久数据结构
4.3 第二天 代理和软件事务内存
4.4 第三天 深入学习
4.5 复习
第5章 Actor
5.1 更加面向对象
5.2 第一天 消息和信箱
5.3 第二天 错误处理和容错性
5.4 第三天 分布式
5.5 复习
第6章 通信顺序进程
6.1 万物皆通信
6.2 第一天 channel和go块
6.3 第二天 多个channel与IO
6.4 第三天 客户端CSP
6.5 复习
第7章 数据并行
7.1 隐藏在笔记本电脑中的超级计算机
7.2 第一天 GPGPU编程
7.3 第二天 多维空间与工作组
7.4 第三天 OpenCL和OpenGL——全部在GPU上运行
7.5 复习
第8章 Lambda架构
8.1 并行计算搞定大数据
8.2 第一天 MapReduce
8.3 第二天 批处理层
8.4 第三天 加速层
8.5 复习
第9章 圆满结束
9.1 君欲何往
9.2 未尽之路
9.3 越过山丘
参考书目
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>七周七并发模型
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>java语言导学（原书第5版）
出版者的话
译者序
前言
第1 章　快速入门·····1
1.1　关于Java 技术 ·················1
1.1.1　Java 程序语言 ·············1
1.1.2　Java 平台 ····················2
1.1.3　Java 技术的功能 ·········3
1.1.4　Java 技术的优势 ·········3
1.2　“Hello World!”实例程序 ···············4
1.2.1　用NetBeans IDE 开发“Hello World ！” ···············4
1.2.2　在Microsoft Windows 中开发“Hello World ！” ·········9
1.2.3　在Solaris 和Linux 中开发“Hello World ！” ·······12
1.3　“Hello World ！”实例程序剖析 ····14
1.3.1　源码注释 ··················15
1.3.2　HelloWorldApp 类定义 ·············15
1.3.3　main 方法 ·················16
1.4　常见问题（及其解决方案） ·············16
1.4.1　编译器问题 ···············16
1.4.2　运行时问题 ···············18
1.5　问题和练习：快速入门 ··················19
第2 章　面向对象的编程概念 ··············20
2.1　对象 ···············20
2.2　类 ···················22
2.3　继承 ···············23
2.4　接口 ···············23
2.5　包 ···················24
2.6　问题和练习：面向对象的编程概念················24
第3 章　语言基础···················26
3.1　变量 ···············26
3.1.1　命名 ··········27
3.1.2　基本数据类型 ···········27
3.1.3　数组 ··········30
3.1.4　小结 ··········33
3.1.5　问题和练习：变量 ····················34
3.2　运算符 ············34
3.2.1　赋值运算符、算术运算符和一元运算符 ··············35
3.2.2　等式运算符、关系运算符和条件运算符 ··············37
3.2.3　位运算符和移位运算符 ············39
3.2.4　小结 ··········39
3.2.5　问题和练习：运算符 ················40
3.3　表达式、语句和块 ·········41
3.3.1　表达式 ······41
3.3.2　语句 ··········42
3.3.3　块 ··············42
3.3.4　问题和练习：表达式、语句和块·················43
3.4　控制流语句 ····················43
3.4.1　if-then 语句和if-then-else语句··············43
3.4.2　switch 语句 ···············44
3.4.3　while 语句和do-while 语句 ······48
3.4.4　for 语句·····49
3.4.5　分支语句 ··················50
3.4.6　小结 ··········52
3.4.7　问题和练习：控制流语句 ········53
第4 章　类和对象···················54
4.1　类 ···················54
4.1.1　声明类 ······55
4.1.2　声明成员变量 ···········56
4.1.3　定义方法 ··················57
4.1.4　构建构造器 ···············58
4.1.5　将消息传给方法或构造器 ········59
4.2　对象 ···············62
4.2.1　创建对象 ··················63
4.2.2　使用对象 ··················65
4.3　类的更多细节·················67
4.3.1　从方法返回值 ···········67
4.3.2　使用this 关键字 ·······68
4.3.3　控制对类成员的访问 ················69
4.3.4　实例和类成员 ···········70
4.3.5　初始化字段 ···············73
4.3.6　小结 ··········74
4.3.7　问题和练习：类 ·······75
4.3.8　问题和练习：对象 ····················76
4.4　嵌套类 ············76
4.4.1　为什么使用嵌套类 ····················77
4.4.2　静态嵌套类 ···············77
4.4.3　内部类 ······77
4.4.4　内部类实例 ···············78
4.4.5　小结 ··········79
4.4.6　问题和练习：嵌套类 ················79
4.5　枚举类型 ········80
4.5.1　问题和练习：枚举类型 ············82
4.6　注解 ···············82
4.6.1　文档 ··········82
4.6.2　编译器使用的注解 ····················83
4.6.3　注解的处理 ···············84
4.6.4　问题和练习：注解 ····················85
第5 章　接口与继承 ··············86
5.1　接口 ···············86
5.1.1　Java 语言的接口 ·······86
5.1.2　将接口用作API ········87
5.1.3　接口和多重继承 ·······87
5.1.4　定义接口 ··················87
5.1.5　实现接口 ··················88
5.1.6　将接口用作类型 ·······89
5.1.7　重写接口 ··················90
5.1.8　小结 ··········90
5.1.9　问题和练习：接口 ····················91
5.2　继承 ···············91
5.2.1　Java 平台中类的层次结构 ········91
5.2.2　继承实例 ··················92
5.2.3　子类能做什么 ···········93
5.2.4　超类的私有成员 ·······93
5.2.5　转换对象 ··················93
5.2.6　覆盖和屏蔽方法 ·······94
5.2.7　多态性 ······95
5.2.8　屏蔽字段 ··················97
5.2.9　使用super 关键字 ·····97
5.2.10　将对象用作超类 ·····98
5.2.11　编写final 类和方法 ··············101
5.2.12　抽象方法和类 ·······101
5.2.13　小结 ······103
5.2.14　问题和练习：继承 ················103
第6 章　泛型 ·····105
6.1　为什么用泛型···············105
6.2　泛型类型 ······106
6.2.1　一个简单的Box 类 ·················106
6.2.2　Box 类的泛型版本 ··················106
6.2.3　类型参数命名约定 ··················107
6.2.4　泛型类型的调用和实例化 ······107
6.2.5　钻石运算符 ·············107
6.2.6　多个类型参数 ·········108
6.2.7　参数化类型 ·············108
6.2.8　原生类型 ················108
6.3　泛型方法 ······ 110
6.4　受限类型形式参数 ······· 110
6.4.1　多重限制 ················ 111
6.4.2　泛型方法和受限类型形式参数············· 112
6.5　泛型、继承和子类型 ··················· 112
6.5.1　泛型类和子类型 ····· 113
6.6　类型推导 ······ 114
6.6.1　类型推导和泛型方法 ·············· 114
6.6.2　类型推导和泛型类的实例化 ··············· 115
6.6.3　类型推导与泛型类和非泛型类的泛型构造函数 ··········· 115
6.7　通配符 ······ 116
6.7.1　上界通配符 ············· 116
6.7.2　无界通配符 ············· 117
6.7.3　下界通配符 ············· 118
6.7.4　通配符和子类型 ····· 118
6.7.5　通配符匹配和辅助方法 ·········· 119
6.7.6　通配符使用指南 ·····121
6.8　类型擦除 ······122
6.8.1　泛型类型的擦除 ·····122
6.8.2　泛型方法的擦除 ·····123
6.8.3　类型擦除效果和桥方法 ··········124
6.8.4　不可具体化类型 ·····125
6.9　泛型的局限性···············128
6.9.1　不能用基本数据类型实例化泛型类型 ················128
6.9.2　不能创建类型参数实例 ··········128
6.9.3　不能声明类型为“类型参数”的静态字段 ·····128
6.9.4　对参数化类型不能用类型转换或instanceof 运算符 ·······129
6.9.5　不能创建参数化类型数组 ······129
6.9.6　不能创建、捕获或抛出参数化类型的对象 ·········130
6.9.7　每次重载时其形式参数类型都被擦为相同的原生类型的方法不能重载 ·········130
6.10　问题和练习：泛型 ·····130
第7 章　程序包 ·····133
7.1　程序包的创建···············134
7.2　程序包的命名···············135
7.2.1　命名约定 ················135
7.3　程序包成员的使用 ·······136
7.3.1　用完全限定名指代程序包成员········136
7.3.2　导入包成员 ·············136
7.3.3　导入整个程序包 ·····136
7.3.4　包的表面层次结构 ··················137
7.3.5　命名歧义性 ·············137
7.3.6　静态import 语句 ····················137
7.4　源文件和类文件的管理 ················138
7.4.1　设置CLASSPATH 系统变量········139
7.5　小结 ·············140
7.6　问题和练习：创建和使用包 ········140
第8 章　数字和字符串 ········141
8.1　数字 ·············141
8.1.1　Number 类 ··············141
8.1.2　格式化数字打印输出 ··············143
8.1.3　其他数学运算方法 ··················146
8.1.4　自动装箱和拆箱 ·····149
8.1.5　小结 ········150
8.1.6　问题和练习：数字 ··················151
8.2　字符 ·············151
8.2.1　转义字符 ················152
8.3　字符串 ··········153
8.3.1　创建字符串 ·············153
8.3.2　字符串长度 ·············153
8.3.3　字符串连接 ·············154
8.3.4　创建格式字符串 ·····155
8.3.5　数字和字符串之间的转换 ······155
8.3.6　操作字符串中的字符 ··············157
8.3.7　比较字符串和字符串的子串··················160
8.3.8　StringBuilder 类 ······161
8.3.9　小结 ········164
8.3.10　问题和练习：字符和字符串 ······165
第9 章　异常 ·········166
9.1　什么是异常 ··················166
9.2　捕获或指明规定 ···········167
9.2.1　三类异常 ················167
9.2.2　绕过捕获或指明 ·····168
9.3　捕获和处理异常 ···········168
9.3.1　try 块 ······169
9.3.2　catch 块 ···················169
9.3.3　finally 块 ·················170
9.3.4　try-with-resources 语句 ···········171
9.3.5　汇总 ········174
9.4　指明一个方法抛出的异常 ············176
9.5　如何抛出异常···············176
9.5.1　throw 语句 ··············177
9.5.2　Throwable 类及其子类 ···········177
9.5.3　Error 类 ···················178
9.5.4　Exception 类 ···········178
9.5.5　链式异常 ················178
9.5.6　创建异常类 ·············179
9.6　未检查异常：争议 ·······180
9.7　异常的优点 ··················180
9.7.1　优点1：把错误处理代码和“正规”代码分离开 ·······181
9.7.2　优点2：根据调用栈上传错误 ···182
9.7.3　优点3：对错误类型进行分组和加以区分 ···········183
9.8　小结 ·············184
9.9　问题和练习：异常 ·······184
第10 章　基本I/O 和NIO.2 ···············186
10.1　I/O 流 ·········186
10.1.1　字节流 ··················187
10.1.2　字符流 ··················188
10.1.3　缓冲流 ··················190
10.1.4　扫描和格式化 ·······191
10.1.5　命令行I/O ············195
10.1.6　数据流 ··················197
10.1.7　对象流 ··················198
10.2　文件I/O（以NIO.2 为特征） ·······199
10.2.1　什么是路径（以及其他文件系统情况） ···············200
10.2.2　Path 类 ··················201
10.2.3　文件操作 ···············206
10.2.4　检查文件或目录 ···················209
10.2.5　删除文件或目录 ···················210
10.2.6　复制文件或目录 ···················210
10.2.7　移动文件或目录 ··················· 211
10.2.8　管理元数据（文件和文件存储属性） ············· 211
10.2.9　读取、写入和创建文件 ········216
10.2.10　随机存取文件 ····················221
10.2.11　创建和读取目录 ··················222
10.2.12　符号链接或其他方式的链接····················224
10.2.13　遍历文件树 ·········226
10.2.14　查找文件 ·············229
10.2.15　监视目录的变化 ·················232
10.2.16　其他有用的方法 ·················236
10.2.17　遗留文件的 I/O 代码 ··········237
10.3　小结············239
10.4　问题和练习：基本I/O 和　　　NIO.2 ·········239
第11 章　集合 ·······240
11.1　集合简介 ····················240
11.1.1　集合框架是什么····················241
11.1.2　Java 集合框架的好处 ············241
11.2　接口 ············241
11.2.1　Collection 接口 ·····243
11.2.2　遍历集合 ···············244
11.2.3　Collection 接口的批量操作 ···244
11.2.4　Collection 接口的数组操作 ···245
11.2.5　Set 接口 ················245
11.2.6　List 接口 ···············248
11.2.7　Queue 接口 ···········255
11.2.8　Map 接口 ··············257
11.2.9　对象排序 ···············262
11.2.10　SortedSet 接口 ····················267
11.2.11　SortedMap 接口 ··················269
11.2.12　小结 ····················270
11.2.13　问题和练习：接口 ··············270
11.3　实现 ············271
11.3.1　Set 实现 ················273
11.3.2　List 实现 ···············274
11.3.3　Map 实现 ··············274
11.3.4　Queue 实现 ···········276
11.3.5　封装实现 ···············277
11.3.6　简单实现 ···············278
11.3.7　小结 ······279
11.3.8　问题和练习：实现 ················280
11.4　算法 ············280
11.4.1　排序 ······280
11.4.2　混排 ······282
11.4.3　常规数据操作 ·······282
11.4.4　查询 ······282
11.4.5　组合 ······283
11.4.6　查找极值 ···············283
11.5　自定义集合实现 ·········283
11.5.1　编写实现的原因····················283
11.5.2　如何编写自定义实现 ············284
11.6　互操作性 ····················285
11.6.1　兼容性 ··················285
11.6.2　API 设计 ···············287
第12 章　并发 ······289
12.1　进程和线程 ················289
12.1.1　进程 ······289
12.1.2　线程 ······290
12.2　线程对象 ····················290
12.2.1　定义和启动一个线程 ············290
12.2.2　使用sleep 方法暂停执行 ······291
12.2.3　中断 ······292
12.2.4　联合 ······293
12.2.5　SimpleThreads 实例 ··············293
12.3　同步············294
12.3.1　线程冲突 ···············294
12.3.2　内存一致性错误 ···················295
12.3.3　同步方法 ···············296
12.3.4　内部锁和同步 ·······297
12.3.5　原子访问 ···············298
12.4　活性············298
12.4.1　死锁 ······299
12.4.2　饥饿和活锁 ···········299
12.5　保护块 ········300
12.6　不可变对象 ················303
12.6.1　同步类实例 ···········303
12.6.2　定义不可变对象的一种策略 ···304
12.7　高级并发对象 ·············305
12.7.1　锁对象 ··················305
12.7.2　执行器 ··················307
12.7.3　并发集合 ··············· 311
12.7.4　原子变量 ··············· 311
12.7.5　并发随机数 ···········312
12.8　问题和练习：并发 ·····313
第13 章　正则表达式 ··········314
13.1　简介············315
13.1.1　什么是正则表达式 ················315
13.1.2　包中的正则表达式如何表示······315
13.2　测试工具 ····················315
13.3　字符串文字 ················316
13.3.1　元字符 ··················317
13.4　字符类 ········317
13.4.1　简单类 ··················318
13.5　预定义字符类 ·············320
13.6　量词············322
13.6.1　零长度匹配 ···········323
13.6.2　捕捉组和拥有量词的字符类 ··················325
13.6.3　贪婪型、勉强型和占有型量词之间的区别 ··············325
13.7　捕捉组 ········326
13.7.1　编号 ······326
13.7.2　反向引用 ···············327
13.8　边界匹配器 ················327
13.9　模式类方法 ················329
13.9.1　使用标记创建模式 ················329
13.9.2　嵌套标记表达式 ···················330
13.9.3　使用matches (String,CharSequence) 方法 ·············331
13.9.4　使用split (String) 方法 ·········331
13.9.5　其他实用方法 ·······332
13.9.6　java.lang.String 中模式方法的等价 ··············332
13.10　匹配类方法 ··············332
13.10.1　索引方法 ·············332
13.10.2　学习方法 ·············333
13.10.3　替换方法 ·············333
13.10.4　使用start 和end 方法 ·········333
13.10.5　使用matches 和lookingAt方法 ····················334
13.10.6　使用replaceFirst (String)和replaceAll (String) ··········335
13.10.7　使用appendReplacement(StringBuffer, String) 和appendTail (StringBuffer) ···336
13.10.8　Matcher 方法在java.lang.String中的等价 ··········336
13.11　模式语法异常类方法 ················336
13.12　Unicode 支持 ············338
13.12.1　匹配特定代码点 ·················338
13.12.2　Unicode 字符属性 ···············338
13.13　附加资源 ··················338
13.14　问题和练习：正则表达式 ········339
第14 章　平台环境 ··············340
14.1　配置工具 ····················340
14.1.1　属性 ······340
14.1.2　命令行参数 ···········343
14.1.3　环境变量 ···············344
14.1.4　其他配置工具 ·······345
14.2　系统工具 ····················345
14.2.1　命令行I/O 对象 ····················345
14.2.2　系统属性 ···············346
14.2.3　安全管理器 ···········348
14.2.4　系统的其他方法 ···················349
14.3　路径和类路径 ·············349
14.3.1　更新PATH 环境变量（Microsoft Windows） ···········349
14.3.2　更新PATH 变量（Solaris 和Linux） ··················351
14.3.3　检查CLASSPATH 变量（所有平台） ··········351
14.4　问题和练习：平台环境 ··············352
第15 章　JAR 文件··············353
15.1　JAR 文件使用入门 ·····353
15.1.1　创建JAR 文件 ······354
15.1.2　查看JAR 文件内容 ···············356
15.1.3　抽取JAR 文件内容 ···············357
15.1.4　更新JAR 文件 ······358
15.1.5　运行打包为JAR 的软件 ·······359
15.2　清单文件使用入门 ·····360
15.2.1　理解默认的清单文件 ············361
15.2.2　修改清单文件 ·······361
15.2.3　设置应用程序的入口点 ········362
15.2.4　将类文件加入JAR 文件的类路径 ··················363
15.2.5　设置包版本信息 ···················363
15.2.6　用JAR 文件封装包 ···············364
15.2.7　封装JAR 文件 ······365
15.3　JAR 文件的签名和验证 ·············365
15.3.1　理解签名和验证 ···················365
15.3.2　对JAR 文件签名 ··················367
15.3.3　验证签名的JAR 文件 ···········369
15.4　使用JAR 相关API ····················369
15.4.1　实例：JarRunner 应用 ··········369
15.5　问题：JAR 文件 ·········373
第16 章　Java Web Start ··················374
16.1　开发Java Web Start 应用程序 ····375
16.1.1　创建顶层JPanel 类 ···············375
16.1.2　创建应用程序 ·······376
16.1.3　从最后部署机制中分离出核心方法的好处 ··········376
16.1.4　获取资源 ···············376
16.2　部署Java Web Start 应用 ···········377
16.2.1　设置Web 服务器 ··················378
16.3　显示自定义的加载进度指示器···378
16.3.1　开发自定义的加载进度指示器 ·············378
16.3.2　为Java Web Start 应用指定自定义的加载进度指示器 ····380
16.4　运行Java Web Start 应用 ···········381
16.4.1　通过浏览器运行Java Web Start 应用 ··············381
16.4.2　通过Java Cache Viewer 运行Java Web Start 应用 ······381
16.4.3　从桌面运行Java Web Start 应用 ······381
16.5　Java Web Start 与安全 ················382
16.5.1　动态下载HTTPS 认证 ··········382
16.6　Java Web Start 常见问题 ············382
16.7　问题和练习：Java Web Start ······383
第17 章　applet ···················384
17.1　开始使用applet ··········384
17.1.1　定义Applet 类的子类 ···········385
17.1.2　Milestones 方法 ···············385
17.1.3　applet 的生命周期 ················386
17.1.4　applet 执行环境 ····················387
17.1.5　开发applet ············388
17.1.6　部署applet ············390
17.2　applet 更多功能 ··········392
17.2.1　查找和加载数据文件 ············392
17.2.2　定义和使用applet 参数 ······392
17.2.3　显示简短的状态字符串 ········394
17.2.4　在浏览器中显示文档 ············395
17.2.5　从applet 调用JavaScript代码 ······396
17.2.6　从JavaScript 代码中调用applet 方法 ············397
17.2.7　通过事件句柄处理初始化状态 ······400
17.2.8　操纵applet 网页的DOM ······401
17.3　显示自定义的加载进度指示器···402
17.3.1　开发自定义的加载进度指示器 ···············402
17.3.2　为applet 指定加载进度指示器 ··············405
17.3.3　将加载进度指示器和applet 用户界面结合 ··········405
17.3.4　将诊断写入标准输出和错误流 ···············405
17.3.5　开发可拖动的applet ·············406
17.3.6　和其他applet 交互 ················408
17.3.7　与服务器端应用交互 ············409
17.3.8　applet 能做什么和不能做什么 ··················410
17.4　applet 常见问题及解决方案 ······· 411
17.5　问题和练习：applet ···················412
第18 章　 Java 富互联网应用系统 ·······413
18.1　设置可信参数和安全属性 ··········413
18.1.1　系统属性 ···············414
18.2　JNLP API ···················415
18.2.1　通过JNLP API 获取客户端 ···416
18.3　cookie ·········418
18.3.1　cookie 的类型 ·······419
18.3.2　RIA 中的cookie 支持 ···········419
18.3.3　获取cookie ···········419
18.4　自定义加载体验 ·········420
18.5　RIA 中的安全 ·············421
18.6　 问题和练习：Java 富互联网应用系统 ········421
第19 章　深入理解部署 ······423
19.1　部署工具 ····················423
19.1.1　部署工具脚本所在位置 ········423
19.1.2　部署applet ············424
19.1.3　部署Java Web Start 应用 ······427
19.1.4　检查客户端的JRE 软件版本 ······428
19.2　Java 网络加载协议 ·····429
19.2.1　JNLP 文件结构 ·····429
19.3　部署的最佳实践 ·········433
19.3.1　减少下载时间 ·······433
19.3.2　避免不必要的更新检查 ········435
19.3.3　只有必要时才签名JAR文件 ······436
19.3.4　确保JRE 软件存在 ···············436
19.4　问题和练习：深入理解部署 ······437
附录　Java 程序语言认证考试复习大纲 ·····438
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>java语言导学（原书第5版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hadoop权威指南:大数据的存储与分析(第4版)(修订版)(升级版)
第Ⅰ部分 Hadoop基础知识
第1章 初识Hadoop 3
1.1 数据！数据！ 3
1.2 数据的存储与分析 5
1.3 查询所有数据 6
1.4 不仅仅是批处理 7
1.5 相较于其他系统的优势 8
1.5.1 关系型数据库管理系统 8
1.5.2 网格计算 10
1.5.3 志愿计算 11
1.6 Apache Hadoop发展简史 12
1.7 本书包含的内容 16
第2章 关于MapReduce 19
2.1 气象数据集 19
2.2 使用Unix工具来分析数据 21
2.3 使用Hadoop来分析数据 22
2.3.1 map和reduce 23
2.3.2 Java MapReduce 24
2.4 横向扩展 31
2.4.1 数据流 31
2.4.2 biner函数 35
2.4.3 运行分布式的MapReduce作业 37
2.5 Hadoop Streaming 37
2.5.1 Ruby版本 38
2.5.2 Python版本 40
第3章 Hadoop分布式文件系统 42
3.1 HDFS的设计 42
3.2 HDFS的概念 44
3.2.1 数据块 44
3.2.2 namenode和datanode 45
3.2.3 块缓存 46
3.2.4 联邦HDFS 47
3.2.5 HDFS的高可用性 47
3.3 命令行接口 50
3.4 Hadoop文件系统 52
3.5 Java接口 56
3.5.1 从Hadoop URL读取数据 56
3.5.2 通过FileSystem API读取数据 58
3.5.3 写入数据 61
3.5.4 目录 63
3.5.5 查询文件系统 63
3.5.6 删除数据 68
3.6 数据流 68
3.6.1 剖析文件读取 68
3.6.2 剖析文件写入 71
3.6.3 一致模型 74
3.7 通过distcp并行复制 76
第4章 关于YARN 78
4.1 剖析YARN应用运行机制 79
4.1.1 资源请求 80
4.1.2 应用生命期 81
4.1.3 构建YARN应用 81
4.2 YARN与MapReduce 1相比 82
4.3 YARN中的调度 85
4.3.1 调度选项 85
4.3.2 容量调度器配置 87
4.3.3 公平调度器配置 89
4.3.5 延迟调度 93
4.3.5 主导资源公平性 94
4.4 延伸阅读 95
第5章 Hadoop的I／O操作 96
5.1 数据完整性 96
5.1.1 HDFS的数据完整性 97
5.1.2 LocalFileSystem 98
5.1.3 ChecksumFileSystem 98
5.2 压缩 99
5.2.1 codec 100
5.2.2 压缩和输入分片 105
5.2.3 在MapReduce中使用压缩 106
5.3 序列化 109
5.3.1 Writable接口 110
5.3.2 Writable类 112
5.3.3 实现定制的Writable集合 121
5.3.4 序列化框架 125
5.4 基于文件的数据结构 127
5.4.1 关于SequenceFile 127
5.4.2 关于MapFile 135
5.4.3 其他文件格式和面向列的格式 136
第Ⅱ部分 关于MapReduce
第6章 MapReduce应用开发 141
6.1 用于配置的API 142
6.1.1 资源合并 143
6.1.2 变量扩展 144
6.2 配置开发环境 144
6.2.1 管理配置 146
6.2.2 辅助类GenericOptionsParser，Tool和ToolRunner 149
6.3 用MRUnit来写单元测试 152
6.3.1 关于Mapper 152
6.3.2 关于Reducer 156
6.4 本地运行测试数据 156
6.4.1 在本地作业运行器上运行作业 156
6.4.2 测试驱动程序 158
6.5 在集群上运行 160
6.5.1 打包作业 160
6.5.2 启动作业 162
6.5.3 MapReduce的Web界面 165
6.5.4 获取结果 167
6.5.5 作业调试 168
6.5.6 Hadoop日志 171
6.5.7 远程调试 173
6.6 作业调优 174
6.7 MapReduce的工作流 176
6.7.1 将问题分解成MapReduce作业 177
6.7.2 关于JobControl 178
6.7.3 关于Apache Oozie 179
第7章 MapReduce的工作机制 184
7.1 剖析MapReduce作业运行机制 184
7.1.1 作业的提交 185
7.1.2 作业的初始化 186
7.1.3 任务的分配 187
7.1.4 任务的执行 188
7.1.5 进度和状态的更新 189
7.1.6 作业的完成 191
7.2 失败 191
7.2.1 任务运行失败 191
7.2.2 application master运行失败 193
7.2.3 节点管理器运行失败 193
7.2.4 资源管理器运行失败 194
7.3 shuffle和排序 195
7.3.1 map端 195
7.3.2 reduce端 197
7.3.3 配置调优 199
7.4 任务的执行 201
7.4.1 任务执行环境 201
7.4.2 推测执行 202
7.4.3 关于OutputCommitters 204
第8章 MapReduce的类型与格式 207
8.1 MapReduce的类型 207
8.1.1 默认的MapReduce作业 212
8.1.2 默认的Streaming作业 216
8.2 输入格式 218
8.2.1 输入分片与记录 218
8.2.2 文本输入 229
8.2.3 二进制输入 233
8.2.4 多个输入 234
8.2.5 数据库输入（和输出） 235
8.3 输出格式 236
8.3.1 文本输出 236
8.3.2 二进制输出 237
8.3.3 多个输出 237
8.3.4 延迟输出 242
8.3.5 数据库输出 242
第9章 MapReduce的特性 243
9.1 计数器 243
9.1.1 内置计数器 243
9.1.2 用户定义的Java计数器 248
9.1.3 用户定义的Streaming计数器 251
9.2 排序 252
9.2.1 准备 252
9.2.2 部分排序 253
9.2.3 全排序 255
9.2.4 辅助排序 259
9.3 连接 264
9.3.1 map端连接 266
9.3.2 reduce端连接 266
9.4 边数据分布 270
9.4.1 利用JobConf来配置作业 270
9.4.2 分布式缓存 270
9.5 MapReduce库类 276
第Ⅲ部分 Hadoop的操作
第10章 构建Hadoop集群 279
10.1 集群规范 280
10.1.1 集群规模 281
10.1.2 网络拓扑 282
10.2 集群的构建和安装 284
10.2.1 安装Java 284
10.2.2 创建Unix 用户账号 284
10.2.3 安装Hadoop 284
10.2.4 SSH配置 285
10.2.5 配置Hadoop 286
10.2.6 格式化HDFS 文件系统 286
10.2.7 启动和停止守护进程 286
10.2.8 创建用户目录 288
10.3 Hadoop配置 288
10.3.1 配置管理 289
10.3.2 环境设置 290
10.3.3 Hadoop守护进程的关键属性 293
10.3.4 Hadoop守护进程的地址和端口 300
10.3.5 Hadoop的其他属性 303
10.4 安全性 305
10.4.1 Kerberos和Hadoop 306
10.4.2 委托令牌 308
10.4.3 其他安全性改进 309
10.5 利用基准评测程序测试Hadoop集群 311
10.5.1 Hadoop基准评测程序 311
10.5.2 用户作业 313
第11章 管理Hadoop 314
11.1 HDFS 314
11.1.1 永久性数据结构 314
11.1.2 安全模式 320
11.1.3 日志审计 322
11.1.4 工具 322
11.2 监控 327
11.2.1 日志 327
11.2.2 度量和JMX（Java管理扩展） 328
11.3 维护 329
11.3.1 日常管理过程 329
11.3.2 委任和解除节点 331
11.3.3 升级 334
第Ⅳ部分 Hadoop相关开源项目
第12章 关于Avro 341
12.1 Avro数据类型和模式 342
12.2 内存中的序列化和反序列化特定API 347
12.3 Avro数据文件 349
12.4 互操作性 351
12.4.1 Python API 351
12.4.2 Avro工具集 352
12.5 模式解析 352
12.6 排列顺序 354
12.7 关于Avro MapReduce 356
12.8 使用Avro MapReduce进行排序 359
12.9 其他语言的Avro 362
第13章 关于Parquet 363
13.1 数据模型 364
13.2 Parquet文件格式 367
13.3 Parquet的配置 368
13.4 Parquet文件的读／写 369
13.4.1 Avro、Protocol Buffers和Thrift 371
13.4.2 投影模式和读取模式 373
13.5 Parquet MapReduce 374
第14章 关于Flume 377
14.1 安装Flume 378
14.2 示例 378
14.3 事务和可靠性 380
14.4 HDFS Sink 382
14.5 扇出 385
14.5.1 交付保证 386
14.5.2 复制和复用选择器 387
14.6 通过代理层分发 387
14.7 Sink组 391
14.8 Flume与应用程序的集成 395
14.9 组件编目 395
14.10 延伸阅读 397
第15章 关于Sqoop 398
15.1 获取Sqoop 398
15.2 Sqoop连接器 400
15.3 一个导入的例子 401
15.4 生成代码 404
15.5 深入了解数据库导入 405
15.5.1 导入控制 407
15.5.2 导入和一致性 408
15.5.3 增量导入 408
15.5.4 直接模式导入 408
15.6 使用导入的数据 409
15.7 导入大对象 412
15.8 执行导出 414
15.9 深入了解导出功能 416
15.9.1 导出与事务 417
15.9.2 导出和SequenceFile 418
15.10 延伸阅读 419
第16章 关于Pig 420
16.1 安装与运行Pig 421
16.1.1 执行类型 422
16.1.2 运行Pig程序 423
16.1.3 Grunt 424
16.1.4 Pig Latin编辑器 424
16.2 示例 425
16.3 与数据库进行比较 428
16.4 PigLatin 429
16.4.1 结构 430
16.4.2 语句 431
16.4.3 表达式 436
16.4.4 类型 437
16.4.5 模式 438
16.4.6 函数 443
16.4.7 宏 445
16.5 用户自定义函数 446
16.5.1 过滤UDF 447
16.5.2 计算UDF 450
16.5.3 加载UDF 452
16.6 数据处理操作 455
16.6.1 数据的加载和存储 455
16.6.2 数据的过滤 455
16.6.3 数据的分组与连接 458
16.6.4 数据的排序 463
16.6.5 数据的组合和切分 465
16.7 Pig实战 465
16.7.1 并行处理 465
16.7.2 匿名关系 466
16.7.3 参数代换 467
16.8 延伸阅读 468
第17章 关于Hive 469
17.1 安装Hive 470
Hive的shell环境 471
17.2 示例 472
17.3 运行Hive 473
17.3.1 配置Hive 473
17.3.2 Hive服务 476
17.3.3 Metastore 478
17.4 Hive与传统数据库相比 480
17.4.1 读时模式vs.写时模式 480
17.4.2 更新、事务和索引 481
17.4.3 其他SQL—on—Hadoop技术 482
17.5 HiveQL 483
17.5.1 数据类型 484
17.5.2 操作与函数 487
17.6 表 488
17.6.1 托管表和外部表 488
17.6.2 分区和桶 490
17.6.3 存储格式 494
17.6.4 导入数据 498
17.6.5 表的修改 500
17.6.6 表的丢弃 501
17.7 查询数据 501
17.7.1 排序和聚集 501
17.7.2 MapReduce脚本 502
17.7.3 连接 503
17.7.4 子查询 506
17.7.5 视图 507
17.8 用户定义函数 508
17.8.1 写UDF 510
17.8.2 写UDAF 512
17.9 延伸阅读 516
第18章 关于Crunch 517
18.1 示例 518
18.2 Crunch核心API 521
18.2.1 基本操作 522
18.2.2 类型 527
18.2.3 源和目标 530
18.2.4 函数 532
18.2.5 物化 535
18.3 管线执行 537
18.3.1 运行管线 538
18.3.2 停止管线 539
18.3.3 查看Crunch计划 540
18.3.4 迭代算法 543
18.3.5 给管线设置检查点 544
18.4 Crunch库 545
18.5 延伸阅读 547
第19章 关于Spark 548
19.1 安装Spark 549
19.2 示例 549
19.2.1 Spark应用、作业、阶段和任务 551
19.2.2 Scala独立应用 552
19.2.3 Java示例 553
19.2.4 Python示例 554
19.3 弹性分布式数据集 555
19.3.1 创建 555
19.3.2 转换和动作 557
19.3.3 持久化 561
19.3.4 序列化 563
19.4 共享变量 564
19.4.1 广播变量 564
19.4.2 累加器 565
19.5 剖析Spark作业运行机制 565
19.5.1 作业提交 566
19.5.2 DAG的构建 566
19.5.3 任务调度 569
19.5.4 任务执行 570
19.6 执行器和集群管理器 570
19.7 延伸阅读 574
第20章 关于HBase 575
20.1 HBase基础 575
20.2 概念 576
20.2.1 数据模型的“旋风之旅” 576
20.2.2 实现 578
20.3 安装 581
20.4 客户端 584
20.4.1 Java 584
20.4.2 MapReduce 588
20.4.3 REST和Thrift 589
20.5 创建在线查询应用 589
20.5.1 模式设计 590
20.5.2 加载数据 591
20.5.3 在线查询 595
20.6 HBase和RDBMS的比较 598
20.6.1 成功的服务 599
20.6.2 HBase 600
20.7 Praxis 601
20.7.1 HDFS 601
20.7.2 用户界面 602
20.7.3 度量 602
20.7.4 计数器 602
20.8 延伸阅读 602
第21章 关于ZooKeeper 604
21.1 安装和运行ZooKeeper 605
21.2 示例 607
21.2.1 ZooKeeper中的组成员关系 608
21.2.2 创建组 608
21.2.3 加入组 611
21.2.4 列出组成员 612
21.2.5 删除组 614
21.3 ZooKeeper服务 615
21.3.1 数据模型 615
21.3.2 操作 618
21.3.3 实现 622
21.3.4 一致性 624
21.3.5 会话 626
21.3.6 状态 628
21.4 使用ZooKeeper来构建应用 629
21.4.1 配置服务 629
21.4.2 可复原的ZooKeeper应用 633
21.4.3 锁服务 637
21.4.4 更多分布式数据结构和协议 639
21.5 生产环境中的ZooKeeper 640
21.5.1 可恢复性和性能 641
21.5.2 配置 642
21.6 延伸阅读 643
第Ⅴ部分 案例学习
第22章 医疗公司塞纳（Cerner）的可聚合数据 647
22.1 从多CPU到语义集成 647
22.2 进入Apache Crunch 648
22.3 建立全貌 649
22.4 集成健康医疗数据 651
22.5 框架之上的可组合性 654
22.6 下一步 655
第23章 生物数据科学：用软件拯救生命 657
23.1 DNA的结构 659
23.2 遗传密码：将DNA字符转译为蛋白质 660
22.3 将DNA想象成源代码 661
23.4 人类基因组计划和参考基因组 663
22.5 DNA测序和比对 664
23.6 ADAM，一个可扩展的基因组分析平台 666
23.7 使用Avro接口描述语言进行自然语言编程 666
23.8 使用Parquet进行面向列的存取 668
23.9 一个简单例子：用Spark和ADAM做k—mer计数 669
23.10 从个性化广告到个性化医疗 672
23.11 联系我们 673
第24章 开源项目Cascading 674
24.1 字段、元组和管道 675
24.2 操作 678
24.3 Taps，Schemes和Flows 680
24.4 Cascading实践应用 681
24.5 灵活性 684
24.6 ShareThis中的Hadoop和Cascading 685
24.7 总结 689
附录A 安装Apache Hadoop 691
附录B 关于CDH 697
附录C 准备NCDC气象数据 699
附录D 新版和旧版JavaMapReduce API 702
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hadoop权威指南:大数据的存储与分析(第4版)(修订版)(升级版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 小程序设计从入门到精通
目录
第一部分 引言
第1章Internet
1.1网络
1.2网络协议
1.3OSI/ISO参考模型
1.4TCP/IP协议簇
1.5Internet
第2章 WWW
2.1起源
2.2工作模式
2.3特点
2.4Web浏览器
2.5统一资源定位器（URL）
2.6Http
2.7主页
2.8HTML
2.9主页设计
2.10网址资源
第3章 Java
3.1产生背景
3.2基本特点
3.3发展方向
3.4应用前景
3.5网址资源
第4章 OoP
4.1两种范式
4.2抽象
4.3三个基本原则
第5章 SymantecCafe1.51
5.1选择SymantecCafe
5.2安装SymantecCafe
5.3工程管理
5.4源代码编辑
5.5资源编辑器
5.6网址资源
第6章 用Cafe开发小程序
6.1Java程序
6.2Helloworld：播放动画
6.3Cafe：Java集成开发平台
6.4IE：支持Java的浏览器
第7章 用Cafe开发应用程序
7.1Java应用程序的两种形式
7.2第一种形式：Helloworld
7.3第二种形式：JavaWorkShop
7.4网址资源
第8章 MicrosoftVisualJ＋＋1.0
8.1选择Visual　J＋＋
8.2安装VisualJ＋＋
8.3MicrosoftDeveloperStudio
8.4项目工作空间
8.5项目工作空间窗口
8.6项目工作空间窗口中的视
8.7Infoviewer
8.8网址资源
第9章 用VisualJ十十开发小程序
9.1Appletl：播放动画
9.2Applet2：文本输出
9.3Applet3：添加鼠标事件处理
9.4Applet4：自己添加源代码
第二部分 Java 语言
第10章 数据类型
10.1Java是一种强类型的语言
10.2基本数据类型
10.3整数类型
10.4浮点数类型
10.5字符类型
10.6布尔
10.7网址资源
第11章 常量
11.1整数常量
11.2浮点常量
11.3布尔常量
11.4字符常量
11.5字符串常量
第12章 变量
12.1声明一个变量
12.2动态初始化
12.3变量的作用域和生命期
12.4类型自动转换和强制转换
12.5表达式的自动类型提升
第13章 数组
13.1一维数组
13.2多维数组
13.3其他数组声明句法
13.4指针：一个过时的概念
第14章 运算符
14.1算术运算符
14.2位运算符
14.3关系运算符
14.4“？”运算符
14.5运算符优先级
第15章 控制语句
15.1选择语句
15.2迭代语句
15.3跳转语句
第16章 类
16.1类的一般形式
16.2一个简单的类：Box
16.3方法
16.4构造器
16.5This
16.6重载
16.7用对象作为参数
16.8返回对象
16.9递归
16.10访问控制
16.11Static
16.12Final
16.13再论数组
第17章 继承
17.1继承
17.2访问控制
17.3实例
17.4Super
17.5方法重载
17.6动态方法派遣
17.7Abstract
17.8再论Final
第18章 包
18.1定义包
18.2访问保护
18.3Import
第19章 接口
19.1定义一个接口
19.2实现接口
19.3接口中的变量
19.4接口继承
第20章 异常
20.1异常处理
20.2异常类型
20.3未捕获的异常
20.4使用Try和Catch
20.5显示异常的描述
20.6多个Catch语句
20.7Throw
20.8Throws
20.9FinalLY
第三部分 java.lang包
第21章 字符串类
21.1何以两个类
21.2格式化字符串
21.3从路径获取文件名
21.4进一步参考
第22章 包裹类
22.1彻底的面向对象
22.2从变量构造实例对象
22.3从实例对象获取变量
22.4包裹类与String之间的转换
22.5Wrapperdemo
第23章 数学类
23.1概述
23.2MathDemo
23.3进一步参考
第24章 Thread类
24.1概述
24.2创建线程
24.3线程优先级
24.4ThreadDemo
第四部分java.util包
第25章 Vector类
25.1概述
25.2 VectorDemo
第26章 Date类
26.1概述
26.2DateDemo
26.3Java也有2000年问题
第27章 Hashtable类
27.1散表
27.2Hashtable类
27.3HashtableDemo
第五部分java.io包
第28章 控制台的输入/输出
28.1System类
28.2ConsoleDemo
第29章 文件的输入/输出
29.1一般文件输入/输出
29.2FileIODemo
29.3缓冲输入/输出
29.4DataIODemo
第30章 文件与目录
30.1File
30.2FileDemo
第六部分java.net包
第31章 网址
31.1概述
31.21netaddress
31.3InetAddressDenmo
第32章 URL
32.1概述
32.2格式
32.3URL
32.4URLDemo
32.5URLCONNECTION
32.6UCDe mo
第33章 TCP/IPSocket
33.1概述
33.2Socket
33.3SocketDemo
33.4ServerSocket
第34章 UDP和数据包
34.1概述
34.2DatagramPacket
34.3DatagramDemo
第七部分 java.applet包
第35章 小程序类
35.1概述
35.2创建AppletDemo工程
35.3用CafeStudio添加组件
35.4显示图片和绘制图形
35.5播放音频
35.6显示状态信息和调试信息
35.7从HTML获取参数
第八部分 java.awt 包
第36章 图形用户界面
36.1GUI类
36.2组件
36.3窗口
36.4包容器
36.5布局管理器
第37章 组件
37.1组件一览
37.2组件应用环境
37.3添加组件的方式
37.4对组件事件的响应
第38章 窗口系统
38.1Java的窗口系统
38.2Window
38.3菜单
38.4Frame
38.5Dialog
38.6FileDialog
38.7WindowDemo
38.8创建工程
38.9用CafeStudio制作资缘
38.10对事件进行处理
38.11结果演示
第39章 布局管理器（一）：FlowLayout和BorderLayout类
39.1布局管理器
39.2FlowLayout
39.3borderLayout
39.4LayoutManagerIDemo1
39.5构造画布对象
39.6构造面板
39.7构造小程序
第40章 布局管理器（二）：GridLayout和CardLavout
40.1GridLayout
40.2CardLayout
40.3小程序演示
40.4Keypad
40.5PhoneCard
40.6LayoutManagerDemo2
第41章 绘图综述
41.1分类
41.2原理
第42章 绘制几何图形
42.1基本的几何元素
42.2绘制方法
42.3GeometryDemo
42.4几点看法
第43章 显示图象
43.1Java的图象处理
43.2ImageDemo
43.3ImageDemo简版：ImageDemo2
第44章 实现动画
44.1动画原理
44.2AnimationDemo1：直接调用Thread.Sleep
44.3AnimationDemo2：从Thread派生
44.4AnimationDemo3：实现接口Runnable
第九部分 小程序集锦
第45章 食物链模拟
45.1动态、可交互的食物链
45.2设计思路
45.3类构造
45.4FoodChainPanel
45.5FoodChain
第46章 绘制统计曲线
46.1在Web上发布统计曲线
46.2实现要点和基本功能
46.3类的构造
46.4Curve
46.5Plot
第47章 计算器
47.1计算器：Java版
47.2实现要点
47.3类构造
47.4Calculator
第48章 时钟
48.1在Web页面上嵌入一个时钟
48.2实现要点
第49章 三维图形和动画
49.1三维图形和动画：Java高级应用
49.2基本功能和实现要点
49.3FileFormatException
49.4Matrix3D
49.5Mode13D
49.6GraphicsPane1
49.7Graphics3D
第50章 希望电台
50.1在Web上建造电台
50.2实现要点
50.3BackGround
50.4RadioButton
50.5HopeRadio
第十部分 附录
附录1JavaAPI第一部分：核心包
附录2JavaAPI第二部分：窗口工具集和小程序

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 小程序设计从入门到精通
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java技术内幕
前言
第1章 Java的本质
第2章 变量、数组和字符串
第3章 操作符、条件和循环
第4章 面向对象编程
第5章 继承、内部类和接口
第6章 applet、应用程序和事件处理
第7章 AWT：文本域、按钮、复选框、单远按钮和布局
第8章 AWT：列表、选择框、文本区域、滚动条和滚动板
第9章 AWT：图形、图像、文本和字体
第10章 AWT：窗口、菜单和对话框
第11章 Swing：applet、应用程序和可插入的外观
第12章 Swing：文本域、按钮、切换按钮、复选框和单选按钮
第13章 Swing：视口、滚动、滑动条和列表
第14章 组合框、进度条、工具提示、分隔线和选择器
第15章 Swing：层板、选项卡板、分割板和布局
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java技术内幕
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web开发学习手册
第1篇 起步篇
第1章 Java Web概述
第2章 搭建开发环境
第3章 数据库基础
第4章 Java语言基础
第5章 JavaScrip语言
第6章 初识XML
第7章 JSP语法
第2篇 核心篇
第8章 JSP内置对象
第9章 JavaBean技术
第10章 Servlet技术
第11章 EL表达式
第12章 JSTL标签库
第13章 数据库应用开发
第3篇 高级篇
第14章 文件上传组件
第15章 解析XML
第16章 应用Ajax技术
第17章 Struts 2框架
第18章 Hibernate技术
第19章 Spring技术
第4篇 实战篇
第20章 技术交流平台——论坛
第21章 GO购网络商城
附录A 术语解释
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web开发学习手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>持续轻量级Java EE开发
第1 章持续性1
预防的真理1
被动的错误处理1
主动的质量策略2
软件开发流程2
串行模型3
迭代模型3
测试即开发5
测试的分级5
单元测试6
集成测试7
基础测试框架8
JUnit 9
TestNG 11
持续开发13
第2 章启动技术15
Bootstrapping 15
Apache Maven 16
JBoss Forge 17
版本控制18
Git 19
Java EE 的测试平台20
Arquillian 20
ShrinkWrap 21
ShrinkWrap Resolvers 27
实验性功能35
运行时36
WildFly 36
OpenShi 37
进入编程37
第3 章从零到生产39
开发环境39
一个新项目40
用Arquillian 编写第一个集成测试48
在本地运行应用程序51
运行Arquillian 集成测试53
通过JBoss Developer Studio 部署到OpenShi 上55
第4 章需求和示例应用程序63
GeekSeek 介绍63
功能集64
概念数据模型65
逻辑数据模型66
获得，构建，测试和运行GeekSeek 68
用例和章节指南73
第5 章Java 持久化和关系型数据75
关系型数据模型77
Java 持久化API 79
POJO 实体80
用例和需求81
用户角度81
技术考虑82
实现82
实体对象83
存储库EJB 88
需求测试场景91
测试搭建91
CRUD 测试93
第6 章NoSQL：数据网格和图数据库99
RDBMS：不擅长处理二进制数据100
数据网格100
RDBMS：不擅长处理关系102
图论103
用例和需求104
实现104
Attachment 105
Relation 109
需求测试场景118
Attachment CRUD 测试118
Attachment 持久化的事务完整性122
验证关系126
第7 章业务逻辑和服务层129
用例和需求130
新用户注册时发送邮件130
实现131
需求测试场景137
仅供测试所用的SMTP 服务器137
测试140
第8 章REST 和可寻址服务147
企业Java 里的REST：JAX-RS 规范150
用例和需求153
实现155
存储库资源156
描述转换器160
@ResourceModel 162
LinkableRepresentation 163
ResourceLink 166
需求测试场景168
黑盒测试168
验证支持Warp 的HTTP 协定171
Arquillian Warp 171
测试装置搭建173
HTTP 协定测试173
第9 章安全性177
用例和需求178
实现178
支撑软件178
需求测试场景187
综述187
搭建187
安全测试188
第10 章用户界面197
用例和需求197
实现198
需求测试场景200
纯JavaScript 201
功能性行为203
第11 章组装及部署211
获得JBoss EAP 211
在JBoss EAP 上运行213
使用EAP 远程容器213
使用EAP 托管容器215
持续集成和授权Build 服务器218
在CloudBees 上配置GeekSeek Build 218
使用EAP 存储库布局CloudBees Jenkins 220
Git Push 事件的自动构建223
推送到过渡和生产环境224
搭建OpenShi 应用程序224
移除默认OpenShi 应用程序226
从CI Build 推送Job 到OpenShi 227
第12 章结语231
索引233
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>持续轻量级Java EE开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web程序设计教程
第1章  Web应用开发简介  1.1  何为Web应用    1.1.1  Web的概念及发展    1.1.2  Web应用程序  1.2  使用Java开发Web应用    1.2.1  面向对象的编程语言    1.2.2  丰富的框架技术    1.2.3  XML、CSS的应用    1.2.4  使用JavaScript与Ajax提升用户体验  1.3  多种集成开发环境    1.3.1  集成开发环境简介    1.3.2  Web应用服务器说明  本章小结  课后练习第2章　Java EE运行及开发环境  ……第3章  JSP和Servlet第4章  SQL与JDBC第5章  Struts 2框架基础第6章  Struts 2高级应用第7章　Struts 2中应用模板语言第8章  Hibernate框架基础第9章  Hibernate查询第10章  Hibernate性能优化第11章  Spring框架基础第12章  Spring AOP第13章　Spring与Java EE持久化数据访问第14章  Spring与Struts 2、Hibernate框架的整合基础第15章  图书馆管理系统
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web程序设计教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java设计模式
目录



第1章设计模式概述

1.1设计模式的诞生与发展

1.1.1模式的诞生与定义

1.1.2软件模式概述

1.1.3设计模式的发展

1.2设计模式的定义与分类

1.2.1设计模式的定义

1.2.2设计模式的基本要素

1.2.3设计模式的分类

1.3GoF设计模式简介

1.4设计模式的优点

1.5本章小结

1.6习题

第2章面向对象设计原则

2.1面向对象设计原则概述

2.2单一职责原则

2.3开闭原则

2.4里氏代换原则

2.5依赖倒转原则

2.6接口隔离原则

2.7合成复用原则

2.8迪米特法则

2.9本章小结

2.10习题

第3章简单工厂模式

3.1创建型模式

3.2简单工厂模式概述

3.3简单工厂模式结构与实现

3.3.1简单工厂模式结构

3.3.2简单工厂模式实现

3.4简单工厂模式应用实例

3.5关于创建对象与使用对象

3.6简单工厂模式的简化

3.7简单工厂模式优/缺点与适用环境

3.7.1简单工厂模式优点

3.7.2简单工厂模式缺点

3.7.3简单工厂模式适用环境

3.8本章小结

3.9习题

第4章工厂方法模式

4.1工厂方法模式概述

4.2工厂方法模式结构与实现

4.2.1工厂方法模式结构

4.2.2工厂方法模式实现

4.3工厂方法模式应用实例

4.4反射机制与配置文件

4.5工厂方法的重载

4.6工厂方法的隐藏

4.7工厂方法模式优/缺点与适用环境

4.7.1工厂方法模式优点

4.7.2工厂方法模式缺点

4.7.3工厂方法模式适用环境

4.8本章小结

4.9习题

第5章抽象工厂模式

5.1产品等级结构与产品族

5.2抽象工厂模式概述

5.3抽象工厂模式结构与实现

5.3.1抽象工厂模式结构

5.3.2抽象工厂模式实现

5.4抽象工厂模式应用实例

5.5开闭原则的倾斜性

5.6抽象工厂模式优/缺点与适用环境

5.6.1抽象工厂模式优点

5.6.2抽象工厂模式缺点

5.6.3抽象工厂模式适用环境

5.7本章小结

5.8习题

第6章建造者模式

6.1建造者模式概述

6.2建造者模式结构与实现

6.2.1建造者模式结构

6.2.2建造者模式实现

6.3建造者模式应用实例

6.4指挥者类的深入讨论

6.5建造者模式优/缺点与适用环境

6.5.1建造者模式优点

6.5.2建造者模式缺点

6.5.3建造者模式适用环境

6.6本章小结

6.7习题

第7章原型模式

7.1原型模式概述

7.2原型模式结构与实现

7.2.1原型模式结构

7.2.2浅克隆与深克隆

7.2.3原型模式实现

7.3原型模式应用实例

7.4原型管理器

7.5原型模式优/缺点与适用环境

7.5.1原型模式优点

7.5.2原型模式缺点

7.5.3原型模式适用环境

7.6本章小结

7.7习题

第8章单例模式

8.1单例模式概述

8.2单例模式结构与实现

8.2.1单例模式结构

8.2.2单例模式实现

8.3单例模式应用实例

8.4饿汉式单例与懒汉式单例

8.5单例模式优/缺点与适用环境

8.5.1单例模式优点

8.5.2单例模式缺点

8.5.3单例模式适用环境

8.6本章小结

8.7习题

第9章适配器模式

9.1结构型模式

9.2适配器模式概述

9.3适配器模式结构与实现

9.3.1适配器模式结构

9.3.2适配器模式实现

9.4适配器模式应用实例

9.5缺省适配器模式

9.6双向适配器

9.7适配器模式优/缺点与适用环境

9.7.1适配器模式优点

9.7.2适配器模式缺点

9.7.3适配器模式适用环境

9.8本章小结

9.9习题

第10章桥接模式

10.1桥接模式概述

10.2桥接模式结构与实现

10.2.1桥接模式结构

10.2.2桥接模式实现

10.3桥接模式应用实例

10.4桥接模式与适配器模式的联用

10.5桥接模式优/缺点与适用环境

10.5.1桥接模式优点

10.5.2桥接模式缺点

10.5.3桥接模式适用环境

10.6本章小结

10.7习题

第11章组合模式

11.1组合模式概述

11.2组合模式结构与实现

11.2.1组合模式结构

11.2.2组合模式实现

11.3组合模式应用实例

11.4透明组合模式与安全组合模式

11.5组合模式优/缺点与适用环境

11.5.1组合模式优点

11.5.2组合模式缺点

11.5.3组合模式适用环境

11.6本章小结

11.7习题

第12章装饰模式

12.1装饰模式概述

12.2装饰模式结构与实现

12.2.1装饰模式结构

12.2.2装饰模式实现

12.3装饰模式应用实例

12.4透明装饰模式与半透明装饰模式

12.5装饰模式优/缺点与适用环境

12.5.1装饰模式优点

12.5.2装饰模式缺点

12.5.3装饰模式适用环境

12.6本章小结

12.7习题

第13章外观模式

13.1外观模式概述

13.2外观模式结构与实现

13.2.1外观模式结构

13.2.2外观模式实现

13.3外观模式应用实例

13.4抽象外观类

13.5外观模式优/缺点与适用环境

13.5.1外观模式优点

13.5.2外观模式缺点

13.5.3外观模式适用环境

13.6本章小结

13.7习题

第14章享元模式

14.1享元模式概述

14.2享元模式结构与实现

14.2.1享元模式结构

14.2.2享元模式实现

14.3享元模式应用实例

14.4有外部状态的享元模式

14.5单纯享元模式与复合享元模式

14.6享元模式与String类

14.7享元模式优/缺点与适用环境

14.7.1享元模式优点

14.7.2享元模式缺点

14.7.3享元模式适用环境

14.8本章小结

14.9习题

第15章代理模式

15.1代理模式概述

15.2代理模式结构与实现

15.2.1代理模式结构

15.2.2代理模式实现

15.3代理模式应用实例

15.4远程代理

15.5虚拟代理

15.6Java动态代理

15.7代理模式优/缺点与适用环境

15.7.1代理模式优点

15.7.2代理模式缺点

15.7.3代理模式适用环境

15.8本章小结

15.9习题

第16章职责链模式

16.1行为型模式

16.2职责链模式概述

16.3职责链模式结构与实现

16.3.1职责链模式结构

16.3.2职责链模式实现

16.4职责链模式应用实例

16.5纯与不纯的职责链模式

16.6职责链模式优/缺点与适用环境

16.6.1职责链模式优点

16.6.2职责链模式缺点

16.6.3职责链模式适用环境

16.7本章小结

16.8习题

第17章命令模式

17.1命令模式概述

17.2命令模式结构与实现

17.2.1命令模式结构

17.2.2命令模式实现

17.3命令模式应用实例

17.4实现命令队列

17.5记录请求日志

17.6实现撤销操作

17.7宏命令

17.8命令模式优/缺点与适用环境

17.8.1命令模式优点

17.8.2命令模式缺点

17.8.3命令模式适用环境

17.9本章小结

17.10习题

第18章解释器模式

18.1解释器模式概述

18.2文法规则和抽象语法树

18.3解释器模式结构与实现

18.3.1解释器模式结构

18.3.2解释器模式实现

18.4解释器模式应用实例

18.5解释器模式优/缺点与适用环境

18.5.1解释器模式优点

18.5.2解释器模式缺点

18.5.3解释器模式适用环境

18.6本章小结

18.7习题

第19章迭代器模式

19.1迭代器模式概述

19.2迭代器模式结构与实现

19.2.1迭代器模式结构

19.2.2迭代器模式实现

19.3迭代器模式应用实例

19.4使用内部类实现迭代器

19.5Java内置迭代器

19.6迭代器模式优/缺点与适用环境

19.6.1迭代器模式优点

19.6.2迭代器模式缺点

19.6.3迭代器模式适用环境

19.7本章小结

19.8习题

第20章中介者模式

20.1中介者模式概述

20.2中介者模式结构与实现

20.2.1中介者模式结构

20.2.2中介者模式实现

20.3中介者模式应用实例

20.4扩展中介者与同事类

20.5中介者模式优/缺点与适用环境

20.5.1中介者模式优点

20.5.2中介者模式缺点

20.5.3中介者模式适用环境

20.6本章小结

20.7习题

第21章备忘录模式

21.1备忘录模式概述

21.2备忘录模式结构与实现

21.2.1备忘录模式结构

21.2.2备忘录模式实现

21.3备忘录模式应用实例

21.4实现多次撤销

21.5备忘录模式优/缺点与适用环境

21.5.1备忘录模式优点

21.5.2备忘录模式缺点

21.5.3备忘录模式适用环境

21.6本章小结

21.7习题

第22章观察者模式

22.1观察者模式概述

22.2观察者模式结构与实现

22.2.1观察者模式结构

22.2.2观察者模式实现

22.3观察者模式应用实例

22.4JDK对观察者模式的支持

22.5观察者模式与Java事件处理

22.6观察者模式与MVC

22.7观察者模式优/缺点与适用环境

22.7.1观察者模式优点

22.7.2观察者模式缺点

22.7.3观察者模式适用环境

22.8本章小结

22.9习题

第23章状态模式

23.1状态模式概述

23.2状态模式结构与实现

23.2.1状态模式结构

23.2.2状态模式实现

23.3状态模式应用实例

23.4共享状态

23.5使用环境类实现状态转换

23.6状态模式优/缺点与适用环境

23.6.1状态模式优点

23.6.2状态模式缺点

23.6.3状态模式适用环境

23.7本章小结

23.8习题

第24章策略模式

24.1策略模式概述

24.2策略模式结构与实现

24.2.1策略模式结构

24.2.2策略模式实现

24.3策略模式应用实例

24.4Java SE中的布局管理

24.5策略模式优/缺点与适用环境

24.5.1策略模式优点

24.5.2策略模式缺点

24.5.3策略模式适用环境

24.6本章小结

24.7习题

第25章模板方法模式

25.1模板方法模式概述

25.2模板方法模式结构与实现

25.2.1模板方法模式结构

25.2.2模板方法模式实现

25.3模板方法模式应用实例

25.4钩子方法的使用

25.5模板方法模式优/缺点与适用环境

25.5.1模板方法模式优点

25.5.2模板方法模式缺点

25.5.3模板方法模式适用环境

25.6本章小结

25.7习题

第26章访问者模式

26.1访问者模式概述

26.2访问者模式结构与实现

26.2.1访问者模式结构

26.2.2访问者模式实现

26.3访问者模式应用实例

26.4访问者模式与组合模式联用

26.5访问者模式优/缺点与适用环境

26.5.1访问者模式优点

26.5.2访问者模式缺点

26.5.3访问者模式适用环境

26.6本章小结

26.7习题

附录AUML类图

A.1UML概述

A.2类与类的UML表示

A.3类之间的关系

附录B设计模式模拟试题

B.1模拟试题一

B.2模拟试题二

B.3模拟试题三

参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java从小白到大牛
第1章 开篇综述
1.1 Java语言历史
1.2 Java语言特点
1.3 Java平台
1.4 Java虚拟机
第2章 开发环境搭建
2.1 JDK工具包
JDK下载和安装
设置环境变量
2.2 Eclipse开发工具
Eclipse下载和安装
安装中文语言包
Eclipse界面
Windows系统中常用快捷键
2.3 其他开发工具
IntelliJ IDEA
NetBeans IDE
文本编辑工具
第3章 第一个Java程序
3.1 使用Eclipse实现
创建项目
创建类
运行程序
3.2 文本编辑工具+JDK实现
编写源代码文件
编译程序
运行程序
3.3 代码解释
第4章 Java语法基础
4.1 标识符、关键字和保留字
标识符
关键字
保留字
4.2 Java分隔符
4.3 变量
4.4 常量
第5章 Java编码规范
5.1 命名规范
5.2 注释规范
文件注释
文档注释
代码注释
使用地标注释
5.3 代码排版
空行
空格
缩进
断行
5.4 其他规范
第6章 数据类型
6.1 基本数据类型
6.2 整型类型
6.3 浮点类型
6.4 数字表示方式
进制数字表示
指数表示
6.5 字符类型
6.6 布尔类型
6.7 数值类型相互转换
自动类型转换
强制类型转换
6.8 引用数据类型
第7章 运算符
7.1 算术运算符
7.2 关系运算符
7.3 逻辑运算符
7.4 位运算符
7.5 其他运算符
7.6 运算符优先级
第8章 控制语句
8.1 分支语句
if语句
switch语句
8.2 循环语句
while语句
do-while语句
for语句
增强for语句
8.3 跳转语句
break语句
continue语句
第9章 数组
9.1 一维数组
数组声明
数组初始化
案例：数组合并
9.2 多维数组
二维数组声明
二维数组的初始化
不规则数组
第10章 字符串
10.1 Java中的字符串
10.2 使用API文档
10.3 不可变字符串
String
字符串池
字符串拼接
字符串查找
字符串比较
字符串截取
10.4 可变字符串
StringBuffer和StringBuilder
字符串追加
字符串插入、删除和替换
第11章 面向对象基础
11.1 面向对象概述
11.2 面向对象三个基本特性
11.3 类
11.4 包
11.5 方法重载（Overload）
11.6 封装性与访问控制
11.7 静态变量和静态方法
11.8 静态代码块
第12章 对象
12.1 创建对象
12.2 空对象
12.3 构造方法
12.4 this关键字
12.5 对象销毁
第13章 继承与多态
13.1 Java中的继承
13.2 调用父类构造方法
13.3 变量隐藏和方法覆盖
13.4 多态
13.5 再谈final关键字
第14章 抽象类与接口
14.1 抽象类
14.2 使用接口
Java 8新特性默认方法和静态方法
14.3 抽象类与接口区别
第15章 枚举类
15.1 枚举概述
15.2 枚举类声明
15.3 枚举常用方法
第16章 Java常用类
16.1 Java根类——Object
16.2 包装类
16.3 Math类
16.4 大数值
16.5 日期时间相关类
16.6 Java 8新日期时间相关类
第17章 内部类
17.1 内部类概述
17.2 成员内部类
17.3 局部内部类
17.4 匿名内部类
第18章 Java 8函数式编程基础——Lambda表达式
18.1 Lambda表达式概述
从一个示例开始
Lambda表达式实现
函数式接口
18.2 Lambda表达式简化形式
省略参数类型
省略参数小括号
省略return和大括号
18.3 作为参数使用Lambda表达式
18.4 访问变量
访问成员变量
捕获局部变量
18.5 方法引用
第19章 异常处理
19.1 从一个问题开始
19.2 异常类继承层次
19.3 捕获异常
19.4 释放资源
19.5 throws与声明方法抛出异常
19.6 自定义异常类
19.7 throw与显式抛出异常
第20章 对象容器——集合
20.1 集合概述
20.2 List集合
20.3 Set集合
20.4 Map集合
第21章 泛型
21.1 一个问题的思考
21.2 使用泛型
21.3 自定义泛型类
21.4 自定义泛型接口
21.5 泛型方法
第22章 文件管理与I/O流
22.1 文件管理
22.2 I/O流概述
22.3 字节流
22.4 字符流
第23章 多线程编程
23.1 基础知识
23.2 创建子线程
23.3 线程的状态
23.4 线程管理
23.5 线程安全
23.6 线程间通信
第24章 网络编程
24.1 网络基础
24.1.4 端口
24.2 TCP Socket低层次网络编程
24.3 UDP Socket低层次网络编程
24.4 数据交换格式
24.5 访问互联网资源
第25章 Swing图形用户界面编程
25.1 Java图形用户界面技术
25.2 Swing技术基础
25.3 事件处理模型
25.4 布局管理
25.5 Swing组件
25.6 案例：图书库存
第26章 反射
26.1 Java反射机制API
26.2 创建对象
26.3 调用方法
26.4 调用成员变量
第27章 注解（Annotation）
27.1 基本注解
27.2 元注解
27.3 自定义注解
第28章 数据库编程
28.1 数据持久技术概述
28.2 MySQL数据库管理系统
28.3 JDBC技术
28.4 案例：数据CRUD操作
第29章 项目实战1：开发PetStore宠物商店项目
29.1 系统分析与设计
项目概述
需求分析
原型设计
数据库设计
架构设计
系统设计
29.2 任务1：创建数据库
迭代1.1：安装和配置MySQL数据库
迭代1.2：编写数据库DDL脚本
迭代1.3：插入初始数据到数据库
29.3 任务2：应用并初始化项目
29.4 任务3：编写数据持久层代码
29.5 任务4：编写表示层代码
29.6 任务5：应用程序打包发布
第30章 项目实战2：开发Java版QQ2006聊天工具
30.1 系统分析与设计
项目概述
需求分析
原型设计
数据库设计
网络拓扑图
系统设计
30.2 任务1：创建服务器端数据库
迭代1.1：安装和配置MySQL数据库
迭代1.2：编写数据库DDL脚本
迭代1.3：插入初始数据到数据库
30.3 任务2：应用并初始化项目
30.4 任务3：编写服务器端外围代码
30.5 任务4：客户端UI实现
30.6 任务5：用户登录过程实现
30.7 任务6：用户登录刷新好友列表
30.8 任务7：聊天过程实现
30.9 任务8：用户下线刷新好友列表过程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java从小白到大牛
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java面向对象程序设计教程
第1章
基本概念1.1
引言

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java面向对象程序设计教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java XML编程指南
第1章  三层Web应用程序
三层应用程序
一个简单的范例
客户机端
小型服务程序基础
JDBC基础
更好的电话簿

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java XML编程指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言程序设计基础
第1章 Java发展概述 ----------------10
1.1 程序设计语言的发展 ----------------10

1.2 Java语言 ----------------10
1.2.1 Java语言的发展历史 ----------------10

1.2.2 Java语言的特点 ----------------11


1.3 Java的开发与运行环境 ----------------13
1.3.1 J2SDK的安装 ----------------13

1.3.2 J2SDK的设置 ----------------14


1.4 开发与运行Java程序的步骤 ----------------14
1.4.1 选择编辑工具 ----------------14

1.4.2 编译与运行Java程序 ----------------14



第2章 Java语言程序和HTML简介 ----------------16
2.1 Java语言的Application程序 ----------------16
2.1.1 源代码的编辑 ----------------16

2.1.2 字节码文件的生成 ----------------17

2.1.3 字节码文件的解释执行 ----------------18


2.2 HTML简介 ----------------19
2.2.1 HTML的基本要素 ----------------21

2.2.2 HTML文件的结构 ----------------22

2.2.3 在HTML文件中加入图像、链接和声音 ----------------22

2.2.4 Applet标记 ----------------24

2.2.5 常用的HTML标记 ----------------24

2.2.6 HTML文件的编辑 ----------------25


2.3 Java语言的Applet程序 ----------------26
2.3.1 源代码的编辑 ----------------26

2.3.2 代码的嵌入 ----------------27

2.3.3 Applet程序的运行 ----------------27


2.4 Java语言字符界面的输入输出 ----------------29

2.5 Java语言图形界面的输入输出 ----------------30
2.5.1 Java Applet图形界面的输入输出 ----------------31

2.5.2 Java Application图形界面的输入输出 ----------------32



第3章 Java语言的数据类型 ----------------35
3.1 Java的标识符 ----------------35

3.2 Java的关键字 ----------------35

3.3 Java的常量和变量 ----------------37
3.3.1 常量和符号常量 ----------------37

3.3.2 变量 ----------------39

3.3.3 变量作用域 ----------------39


3.4 Java的基本数据类型 ----------------39
3.4.1 整型 ----------------39

3.4.2 实型 ----------------40

3.4.3 字符型 ----------------41

3.4.4 布尔型 ----------------41


3.5 变量的初始化 ----------------41

3.6 简单程序举例 ----------------42


第4章 Java语言的运算符和表达式 ----------------46
4.1 赋值、算术运算符及其表达式 ----------------46
4.1.1 赋值运算符及其表达式 ----------------46

4.1.2 算术运算符及其表达式 ----------------47


4.2 关系、逻辑运算符及其表达式 ----------------49
4.2.1 关系运算符及其表达式 ----------------49

4.2.2 逻辑运算符及其表达式 ----------------51


4.3 位运算符和表达式 ----------------52
4.3.1 计算机内数据的表示 ----------------52

4.3.2 位运算符及其表达式 ----------------53


4.4 其他运算符 ----------------56

4.5 Java语言运算符的优先级和结合性 ----------------57

4.6 数据类型的转换 ----------------58
4.6.1 数据类型的自动转换 ----------------58

4.6.2 数据类型的强制转换 ----------------58



第5章 Java语言的基本语句 ----------------60
5.1 Java语言的3种基本结构 ----------------60

5.2 顺序结构语句 ----------------60
5.2.1 变量声明语句和表达式语句 ----------------60

5.2.2 复合语句和分程序 ----------------61


5.3 选择结构语句 ----------------62
5.3.1 条件运算符 ----------------62

5.3.2 if～else语句 ----------------63

5.3.3 switch～case语句 ----------------69


5.4 循环结构语句 ----------------71
5.4.1 while语句 ----------------71

5.4.2 for语句 ----------------72

5.4.3 do～while语句 ----------------73

5.4.4 循环嵌套 ----------------74


5.5 转移控制语句 ----------------75
5.5.1 break语句 ----------------75

5.5.2 continue语句 ----------------77



第6章 数组、字符串和向量 ----------------82
6.1 一维数组 ----------------82
6.1.1 一维数组的声明 ----------------82

6.1.2 创建一维数组 ----------------82

6.1.3 一维数组的初始化 ----------------83

6.1.4 一维数组应用举例 ----------------83


6.2 多维数组 ----------------84
6.2.1 多维数组声明 ----------------84

6.2.2 创建多维数组 ----------------84

6.2.3 多维数组的初始化 ----------------85

6.2.4 多维数组应用举例 ----------------85


6.3 字符数组 ----------------86
6.3.1 字符数组声明 ----------------87

6.3.2 创建字符数组 ----------------87

6.3.3 字符数组初始化及其举例 ----------------87


6.4 不变字符串String类 ----------------89
6.4.1 String类的构造方法 ----------------89

6.4.2 字符串的常用方法 ----------------91

6.4.3 字符串与子字符串的操作 ----------------91

6.4.4 toString方法及其他方法 ----------------93


6.5 可变字符串StringBuffer类 ----------------93
6.5.1 StringBuffer类的构造方法 ----------------93

6.5.2 StringBuffer类的常用方法 ----------------94


6.6 向量 ----------------95
6.6.1 向量的声明 ----------------95

6.6.2 Vector类的常用方法 ----------------96



第7章 Java语言的方法 ----------------98
7.1 return语句 ----------------98

7.2 Java语言方法的定义、返值和调用 ----------------99
7.2.1 Java语言方法的修饰符 ----------------99

7.2.2 Java语言方法的定义 ----------------100

7.2.3 Java语言方法的调用 ----------------102

7.2.4 Java语言方法的返值 ----------------103


7.3 方法之间的数据传递 ----------------104
7.3.1 方法间的数值传递 ----------------105

7.3.2 方法间的引用传递 ----------------105


7.4 Java语言方法的递归调用 ----------------107

7.5 Java语言方法的命令行参数 ----------------112


第8章 类的声明和对象的实例化 ----------------114
8.1 Java的类 ----------------114
8.1.1 类的定义 ----------------114

8.1.2 类的修饰符 ----------------115

8.1.3 类的类体 ----------------116

8.1.4 类的构造方法 ----------------117


8.2 类的成员变量 ----------------118
8.2.1 类成员变量的声明 ----------------118

8.2.2 类成员变量的修饰 ----------------120


8.3 类的成员方法 ----------------122
8.3.1 成员方法的设计 ----------------122

8.3.2 成员方法的声明和修饰 ----------------124

8.3.3 方法体 ----------------126

8.3.4 消息的传递 ----------------127


8.4 Java对象的实例化 ----------------128
8.4.1 创建对象 ----------------128

8.4.2 使用对象 ----------------128

8.4.3 清除对象 ----------------129


8.5 Java类的继承 ----------------129
8.5.1 继承的概念 ----------------129

8.5.2 继承的实现 ----------------130



第9章 接口和包 ----------------134
9.1 抽象类和方法 ----------------134
9.1.1 定义抽象类 ----------------134

9.1.2 抽象类的实现 ----------------135


9.2 接口 ----------------137
9.2.1 接口的概念 ----------------137

9.2.2 定义接口 ----------------137

9.2.3 接口的特点和实现 ----------------138


9.3 包 ----------------143
9.3.1 包的概念 ----------------143

9.3.2 包的定义 ----------------144

9.3.3 存放的位置 ----------------144

9.3.4 包的引用 ----------------145

9.3.5 将多个独立的类放入同一个包中 ----------------145



第10章 异常处理 ----------------150
10.1 Java的异常处理机制 ----------------151

10.2 异常处理方法 ----------------152
10.2.1 try…catch…finally结构 ----------------153

10.2.2 抛出异常 ----------------158

10.2.3 自定义异常 ----------------161



第11章 输入和输出 ----------------165
11.1 输入输出类库 ----------------165

11.2 标准输入输出 ----------------169

11.3 文件操作 ----------------170


第12章 图形用户界面GUI ----------------181
12.1 AWT包 ----------------181
12.1.1 屏幕坐标体系 ----------------182

12.1.2 建立窗口的Frame类 ----------------184

12.1.3 使用基本组件 ----------------186

12.1.4 AWT图形用户界面的深入学习 ----------------198


12.2 Java语言中的事件处理 ----------------203
12.2.1 事件处理机制 ----------------203

12.2.2 可用的事件监听者和它们处理的事件类型 ----------------204

12.2.3 事件及其响应 ----------------205

12.2.4 在Java中的事件处理方式 ----------------208


12.3 swing包 ----------------212
12.3.1 Swing 的层次结构及具体组件 ----------------213

12.3.2 创建JFrame窗口 ----------------214

12.3.3 窗口事件 ----------------215

12.3.4 swing包中常用的组件 ----------------217



第13章 高级用户界面GUI设计 ----------------226
13.1 布局管理器 ----------------226
13.1.1 布局管理器的概念 ----------------226

13.1.2 Border布局管理器 ----------------227

13.1.3 Flow布局管理器 ----------------229

13.1.4 Card布局管理器 ----------------230

13.1.5 Grid布局管理器 ----------------232

13.1.6 Box布局管理器 ----------------233


13.2 键盘和鼠标事件的处理 ----------------234
13.2.1 键盘事件 ----------------234

13.2.2 鼠标事件 ----------------235


13.3 菜单设计 ----------------237

13.4 对话框设计 ----------------260
13.4.1 JoptionPane ----------------260

13.4.2 Dialog ----------------261


13.5 窗口 ----------------263
13.5.1 JPanel容器 ----------------263

13.5.2 JscrollPane ----------------264

第14章 多线程技术 ----------------266
14.1 多线程的基本概念 ----------------266
14.1.1 多线程 ----------------266
14.1.2 Windows平台上线程的运行机制 ----------------266
14.2 线程的状态 ----------------268
14.2.1 线程的生命周期 ----------------268
14.2.2 线程类 ----------------269
14.3 线程体及其构造 ----------------270
14.3.1 线程体 ----------------270
14.3.2 采用直接继承构造线程体 ----------------270
14.3.3 采用实现Runnable接口构造线程体 ----------------271
14.4 线程同步控制 ----------------272
14.4.1 synchronized关键字 ----------------272
14.4.2 wait( )、notify( )/notifyall( ) ----------------274
14.4.3 同步控制的信号量 ----------------275
14.4.4 线程同步的示例 ----------------276
参考资料 ----------------283
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言程序设计基础
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java软件开发
译者序
前言
致谢
第1章 软件开发
1.1 开发活动
1.2 软件描述
1.3 设计

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java软件开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 实用编程100例
第一部分 基础知识
第二部分 图形界面
第三部分 图形处理
第四部分 I/O操作
第五部分 网络编程
第六部分 数据库
第七部分 多线程
第八部分 JAVA与XML
第九部分 APPLET应用
第十部分 SERVLET和JSP技术
第十一部分 企业EJB
第十二部分 JAVA应用框架
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 实用编程100例
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java编程模式与范例
出版说明
前言
第一章 Java基本编程模式
第二章 Java基本编程构件
第三章 使用对象工作的模式与范例
第四章 控制流结构的模式与范例
第五章 数组对象的模式与范例
第六章 Java类与应用程序的模式与范例
第七章 Java小应用程序的模式与范例
第八章 字符串处理的模式与范例
附录 TextPad与JDK工具的使用步骤
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java编程模式与范例
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java网络程序设计
Java网络程序设计――上篇
一 TCP/IP与Internet程序设计篇
第1章 Java简介
第2章 网络概论
第3章 Socket
第4章 SMTP通信协议
第5章 POP3通信协议
……
Java网络程序设计――下篇 
二 企业网络技术篇
第13章 企业解决方案
第14章 Java档案
第15章 Java Plug-in与HTML Converter 
第16章 Java安全性原则
第17章 三层体系结构Socket与JDBC
……
附录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java网络程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>増補改訂版 Java言語で学ぶデザインパターン入門 マルチスレッド編
Java言語のスレッド
マルチスレッドプログラムの評価基準
Single Threaded Execution―この橋を渡れるのは、たった1人
Immutable―壊したくとも、壊せない
Guarded Suspension―用意できるまで、待っててね
Balking―必要なかったら、やめちゃおう
Producer‐Consumer―わたしが作り、あなたが使う
Read‐Write Lock―みんなで読んでもいいけれど、読んでる間は書いちゃだめ
Thread‐Per‐Message―この仕事、やっといてね
Worker Thread―仕事がくるまで待ち、仕事がきたら働く
Future―引換券を、お先にどうぞ
Two‐Phase Termination―あとかたづけしてから、おやすみなさい
Thread‐Specific Strage―スレッドごとのコインロッカー
Active Object―非同期メッセージを受け取る、能動的なオブジェクト
マルチスレッドプログラミングのパターン・ランゲージ
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>増補改訂版 Java言語で学ぶデザインパターン入門 マルチスレッド編
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>学通Java Web的24堂课
第1部分 基础篇
第1堂课 搭建开发环境	3
1.1 Java web应用的开发环境概述	4
1.1.1 开发工具包jdk	4
1.1.2 web服务器	4
1.1.3 web浏览器	5
1.2 jdk的安装与配置	5
1.2.1 下载jdk	5
1.2.2 安装jdk	6
1.2.3 windows系统下配置和测试jdk	7
1.3 tomcat的安装与配置	9
1.3.1 下载tomcat	9
1.3.2 tomcat的目录结构	11
1.3.3 修改tomcat的默认端口	11
1.3.4部署web应用	11
1.4 eclipse的安装与使用	12
1.4.1 eclipse的下载与安装	12
1.4.2 启动eclipse	13
1.4.3 eclipse工作台	14
1.4.4 使用eclipse开发web应用	14
1.4.5 eclipse的常用快捷键	18
1.5 照猫画虎——基本功训练	20
1.5.1 基本功训练1——配置jdk的环境变量	20
1.5.2 基本功训练2——在dos环境中测试jdk	21
1.5.3 基本功训练3——在dos环境中编译Java源文件	21
1.5.4 基本功训练4——在tomcat中手动部署web应用	23
1.5.5 基本功训练5——手动启动与关闭tomcat服务器	24
1.6 情景应用——拓展与实践	25
1.6.1 情景应用1——在eclipse中配置tomcat服务器	25
1.6.2 情景应用2——创建第一个web项目	26
1.6.3 情景应用3——设置eclipse工作空间的字符编码	27
1.6.4 情景应用4——设置代码提示的快捷键	28
1.6.5 情景应用5——为项目导入所需的jar包	29
1.7 自我测试	29
1.8 行动指南	30
1.9 成功可以复制——80后新贵、泡泡网ceo李想	31
第2堂课 jsp中的Java程序	33
视频讲解：205 分钟
2.1 Java数据类型	34
2.1.1 Java基本数据类型	34
2.1.2 变量与常量	34
2.1.3 对应基本数据类型的内置类	36
2.2 运算符和表达式	36
2.2.1 算术运算符	36
2.2.2 关系运算符	37
2.2.3 逻辑运算符	37
2.2.4 三元运算符	38
2.2.5 表达式	39
2.3 流程控制语句	39
2.3.1 条件语句	39
2.3.2 循环语句	42
2.3.3 跳转语句	44
2.4 面向对象编程基础	44
2.4.1 Java中的类和对象	44
2.4.2 Java中的修饰符	45
2.4.3 抽象类和接口	46
2.4.4 Java中的代码注释	49
2.4.5 异常处理技术	50
2.5 照猫画虎——基本功训练	52
2.5.1 基本功训练1——判断变量的奇偶性	52
2.5.2 基本功训练2——输出大于1的40个素数	53
2.5.3 基本功训练3——定义包含属性和方法的汽车类	54
2.5.4 基本功训练4——输出空心的菱形	55
2.5.5 基本功训练5——抛出“除数不能为负数”异常信息	56
2.6 情景应用——拓展与实践	57
2.6.1 情景应用1——输出长方形的面积	57
2.6.2 情景应用2——switch语句实现生肖查询	57
2.6.3 情景应用3——统计图书的销售量	59
2.6.4 情景应用4——输出数字对应的金字塔	60
2.6.5 情景应用5——实现温度单位转换	60
2.7 自我测试	61
2.8 行动指南	63
2.9 成功可以复制——Java技术之父james gosling	63
第3堂课 html语言与css样式	65
3.1 xhtml基础	66
3.1.1 xhtml语言的语法	66
3.1.2 xhtml文件的结构	68
3.1.3 编辑文字版面	70
3.1.4 插入图像与链接	72
3.1.5 编写xhtml表格	73
3.1.6 设计xhtml表单	74
3.2 css样式应用	78
3.2.1 将css样式嵌入到html中	78
3.2.2 css选择符	79
3.2.3 常见的css样式属性	81
3.3 设计页面布局	86
3.3.1 [div]和[span]标签	86
3.3.2 区块模型	87
3.3.3 区块浮动	87
3.4 照猫画虎——基本功训练	90
3.4.1 基本功训练1——制作可以输入密码的文本框	90
3.4.2 基本功训练2——应用删除线样式标注商品特价	91
3.4.3 基本功训练3——鼠标经过表格时显示提示信息	91
3.4.4 基本功训练4——显示自定义的鼠标形状	92
3.4.5 基本功训练5——css控制绝对定位	94
3.5 情景应用——拓展与实践	95
3.5.1 情景应用1——编写用户注册表单页	95
3.5.2 情景应用2——为网页添加背景音乐	96
3.5.3 情景应用3——插入flash动画	96
3.5.4 情景应用4——文字的发光特效	97
3.5.5 情景应用5——打造经典的导航栏	98
3.6 自我测试	100
3.7 行动指南	101
3.8 成功可以复制——杀毒王王江民	102
第4堂课 Javascript脚本语言	105
4.1 了解Javascript	106
4.1.1 什么是Javascript	106
4.1.2 Javascript的主要特点	106
4.1.3 Javascript与Java的区别	106
4.2 在web页面中使用Javascript	107
4.2.1 在页面中直接嵌入Javascript	107
4.2.2 链接外部Javascript	107
4.3 Javascript语言基础	108
4.3.1 Javascript的语法	108
4.3.2 Javascript中的关键字	109
4.3.3 了解Javascript的数据类型	110
4.3.4 变量的定义及使用	112
4.3.5 运算符的应用	113
4.3.6 应用流程控制语句	115
4.4 使用正则表达式	118
4.4.1 正则表达式的语法	118
4.4.2 创建正则表达式对象（regexp）	120
4.4.3 应用regexp对象执行模式匹配	121
4.5 函数	123
4.5.1 函数的定义	123
4.5.2 函数的调用	123
4.5.3 匿名函数	124
4.6 事件和事件处理程序	125
4.6.1 什么是事件和事件处理程序	125
4.6.2 Javascript的常用事件	125
4.6.3 事件处理程序的调用	126
4.7 常用对象	127
4.7.1 string对象	127
4.7.2 math对象	130
4.7.3 date对象	131
4.7.4 window对象	134
4.8 dom技术	137
4.8.1 dom概述	137
4.8.2 dom的分层结构	137
4.8.3 遍历文档	138
4.8.4 获取文档中的指定元素	140
4.8.5 操作文档	140
4.9 照猫画虎——基本功训练	142
4.9.1 基本功训练1——通过switch语句根据当前日期弹出不同的提示信息	142
4.9.2 基本功训练2——通过for循环计算10以内（不包括10）所有偶数的和	143
4.9.3 基本功训练3——验证用户输入的年龄是否为数字	144
4.9.4 基本功训练4——去掉字符串左右空格	145
4.9.5 基本功训练5——限制输入字符串的长度	145
4.10 情景应用——拓展与实践	147
4.10.1 情景应用1——验证e-mail是否正确	147
4.10.2 情景应用2——验证手机号码是否正确	148
4.10.3 情景应用3——计算两个日期相差的天数	148
4.10.4 情景应用4——将某地区的人口总数分位显示	150
4.10.5 情景应用5——实现可编辑的表格	151
4.11 自我测试	152
4.12 行动指南	154
4.13 成功可以复制——缔造华人的硅谷传奇杨致远	155
第5堂课 掌握jsp语法	157
5.1 jsp页面的基本构成	158
5.2 jsp指令标签	159
5.2.1 页码指令page	159
5.2.2 文件包含指令include	161
5.2.3 引用标签库指令taglib	162
5.3 嵌入Java代码	163
5.3.1 代码片段	163
5.3.2 jsp表达式	163
5.4 巧用注释	163
5.4.1 html注释	163
5.4.2 jsp注释	164
5.4.3 代码注释	164
5.4.4 动态注释	164
5.5 jsp动作标签	165
5.5.1 包含外部文件的[jsp:include]动作标签	165
5.5.2 请求转发的[jsp:forward]动作标签	166
5.5.3 设置参数的[jsp:param]动作标签	167
5.6 照猫画虎——基本功训练	167
5.6.1 基本功训练1——自定义错误提示页面	167
5.6.2 基本功训练2——在页面中动态添加表格	167
5.6.3 基本功训练3——将请求转发至登录页面	168
5.6.4 基本功训练4——导入版权信息页	170
5.6.5 基本功训练5——在jsp页面中输出星号组成的金字塔	171
5.7 情景应用——拓展与实践	172
5.7.1 情景应用1——根据数据表动态生成下拉列表	172
5.7.2 情景应用2——jsp脚本嵌入Javascript代码	173
5.7.3 情景应用3——定义可输入文字的下拉列表	174
5.7.4 情景应用4——在页面中引入一个html文件	175
5.7.5 情景应用5——将3个页面组成一个新的页面	176
5.8 自我测试	178
5.9 行动指南	178
5.10 成功可以复制——全球最大中间件公司bea创始人之一庄思浩	179
第6堂课 使用jsp内置对象	181
6.1 jsp内置对象概述	182
6.2 页面请求对象request	182
6.2.1 获取请求参数值	182
6.2.2 获取表单提交的信息	183
6.2.3 解决中文乱码	184
6.2.4 获取客户端信息	185
6.2.5 在作用域中管理属性	186
6.2.6 获取cookie	187
6.2.7 显示国际化信息	188
6.3 客户端响应对象response	189
6.3.1 重定向网页	189
6.3.2 设置输出缓冲	189
6.3.3 处理http文件头	190
6.4 session会话对象	191
6.4.1 创建及获取session会话	191
6.4.2 从会话中移除指定的对象	192
6.4.3 设置会话的有效时间	192
6.4.4 销毁session	192
6.4.5 session对象的应用	193
6.5 application对象	195
6.5.1 应用程序初始化参数	195
6.5.2 管理应用程序环境属性	196
6.6 输出对象out	196
6.6.1 向客户端输出数据	196
6.6.2 管理相应缓冲区	196
6.7 其他内置对象	197
6.7.1 获取会话范围的pagecontext对象	197
6.7.2 读取web.xml配置信息的config对象	197
6.7.3 应答或请求的page对象	198
6.7.4 获取异常信息的exception对象	198
6.8 照猫画虎——基本功训练	200
6.8.1 基本功训练1——application实现网页计数器	200
6.8.2 基本功训练2——获取用户ip地址	201
6.8.3 基本功训练3——显示留言信息	201
6.8.4 基本功训练4——给出session超时提示	203
6.8.5 基本功训练5——获取传输数据的协议名	204
6.9 情景应用——拓展与实践	205
6.9.1 情景应用1——在登录页面中添加验证码	205
6.9.2 情景应用2——实现自动登录	207
6.9.3 情景应用3——定时刷新页面	208
6.9.4 情景应用4——统计用户在某页停留时间	209
6.9.5 情景应用5——将表单请求提交至本页	210
6.10 自我测试	212
6.11 行动指南	213
6.12 成功可以复制——让下载迅雷不及掩耳邹胜龙	213
第2部分 提高篇
第7堂课 Javabean技术	217
7.1 Javabean技术介绍	218
7.1.1 Javabean简介	218
7.1.2 Javabean规范	219
7.2 Javabean在jsp中的应用	220
7.2.1 [jsp:usebean]标签	220
7.2.2 [jsp:setproperty]标签	221
7.2.3 [jsp:getproperty]标签	223
7.2.4 Javabean的作用域	225
7.3 照猫画虎——基本功训练	226
7.3.1 基本功训练1——定义获取当前年份方法	226
7.3.2 基本功训练2——判断用户是否输入指定字符开头的字符串	228
7.3.3 基本功训练3——定义数据查询方法	230
7.3.4 基本功训练4——将长整型数字分位显示	232
7.3.5 基本功训练5——判断字符串是否包含数字	234
7.4 情景应用——拓展与实践	236
7.4.1 情景应用1——应用Javabean处理中文	236
7.4.2 情景应用2——将用户选择内容转换为字符串	239
7.4.3 情景应用3——小写金额转换成大写金额	241
7.4.4 情景应用4——过滤非法字符	244
7.4.5 情景应用5——实现数据分页	246
7.5 自我测试	249
7.6 行动指南	249
7.7 成功可以复制——软件业的华人教父王嘉廉	250
第8堂课 servlet技术	253
8.1 servlet基础	254
8.1.1 初步认识servlet	254
8.1.2 servlet技术功能	254
8.1.3 servlet技术特点	255
8.2 servlet开发	256
8.2.1 创建servlet	256
8.2.2 配置servlet的相关元素	256
8.3 servlet核心api	258
8.3.1 servlet接口	258
8.3.2 genericservlet抽象类	258
8.3.3 httpservlet抽象类	259
8.3.4 httpservletrequest接口	259
8.3.5 httpservletresponse接口	260
8.3.6 servletconfig接口	261
8.4 理解servlet的生命周期	261
8.5 servlet过滤器	262
8.5.1 过滤器概述	263
8.5.2 过滤器api	263
8.5.3 配置过滤器	264
8.5.4 编写字符编码过滤器	265
8.6 照猫画虎——基本功训练	267
8.6.1 基本功训练1——在servlet中实现请求转发	267
8.6.2 基本功训练2——在servlet中处理表单提交的数据	269
8.6.3 基本功训练3——在servlet中实现页面重定向	270
8.6.4 基本功训练4——动态生成html文档	271
8.6.5 基本功训练5——在servlet中向客户端写cookie信息	272
8.7 情景应用——拓展与实践	274
8.7.1 情景应用1——统计网站的访问量	274
8.7.2 情景应用2——生成网站表单的验证码	275
8.7.3 情景应用3——将用户信息导出到excel	277
8.7.4 情景应用4——利用servlet实现个人所得税计算器	278
8.7.5 情景应用5——过滤用户输入的敏感文字	280
8.8 自我测试	283
8.9 行动指南	284
8.10 成功可以复制——图文世界的缔造者约翰·沃洛克	285
第9堂课 使用el表达式	287
9.1 el概述	288
9.1.1 使用el表达式的前提条件	288
9.1.2 el表达式的基本语法	289
9.1.3 el表达式的特点	289
9.2 el表达式的存取范围	289
9.3 el表达式的运算符	290
9.3.1 存取数据运算符	290
9.3.2 算术运算符	291
9.3.3 关系运算符	291
9.3.4 逻辑运算符	292
9.3.5 empty运算符	293
9.3.6 条件运算符	293
9.3.7 运算符的优先级	293
9.4 el表达式中的保留字	294
9.5 el表达式中的隐含对象	295
9.5.1 pagecontext对象的应用	295
9.5.2 param和paramvalues对象的应用	295
9.5.3 header和headervalues对象的应用	296
9.5.4 访问作用域范围的隐含对象	296
9.5.5 cookie对象的应用	297
9.5.6 initparam对象的应用	297
9.6 照猫画虎——基本功训练	297
9.6.1 基本功训练1——实现计算卡	297
9.6.2 基本功训练2——el实现数字比较卡	298
9.6.3 基本功训练3——网页中获取cookie的值	298
9.6.4 基本功训练4——显示表单信息	299
9.6.5 基本功训练5——访问Javabean的属性	300
9.7 情景应用——拓展与实践	302
9.7.1 情景应用1——如何禁用el表达式	302
9.7.2 情景应用2——显示客户端使用的浏览器	303
9.7.3 情景应用3——显示客户端能接收的内容类型	303
9.7.4 情景应用4——判断用户是否登录，并显示不同提示信息	304
9.7.5 情景应用5——判断用户名和密码是否为空，空则显示相应提示信息	305
9.8 自我测试	305
9.9 行动指南	306
9.10 成功可以复制——微型博客twitter创始人埃文·威廉姆斯	307
第10堂课 jstl核心标签库	309
10.1 jstl技术简介	310
10.2 表达式标签	310
10.2.1 [c:out]输出标签	310
10.2.2 [c:set]设置标签	311
10.2.3 [c:remove]移除标签	313
10.2.4 [c:catch]捕获异常标签	314
10.3 流程控制标签	314
10.3.1 [c:if]条件判断标签	314
10.3.2 [c:choose]、[c:when]和[c:otherwise]标签	316
10.4 循环标签	317
10.4.1 [c:foreach]循环标签	317
10.4.2 [c:fortokens]迭代标签	318
10.5 url操作标签	319
10.5.1 [c:import]文件导入标签	320
10.5.2 [c:redirect]重定向标签	321
10.5.3 [c:url]生成url地址标签	322
10.5.4 [c:param]参数传递标签	323
10.6 照猫画虎——基本功训练	323
10.6.1 基本功训练1——[c:foreach]标签遍历数组	323
10.6.2 基本功训练2——[c:redirect]标签实现重定向页面	324
10.6.3 基本功训练3——应用jstl标签显示数据库中商品信息	324
10.6.4 基本功训练4——[c:set]设置对象属性值	327
10.6.5 基本功训练5——[c:choose]保留登录信息	328
10.7 情景应用——拓展与实战	329
10.7.1 情景应用1——jstl标签实现国际化	329
10.7.2 情景应用2——应用jstl导入网站注册协议	330
10.7.3 情景应用3——jstl标签实现网站计数器	331
10.7.4 情景应用4——[c:if]标签判断用户最喜爱的水果	332
10.7.5 情景应用5——屏蔽页面中出现的错误	333
10.8 自我测试	333
10.9 行动指南	334
10.10 成功可以复制——不断挑战自己的成功徐少春	335
第11堂课 使用ajax技术	337
11.1 ajax简介	338
11.1.1 什么是ajax	338
11.1.2 ajax开发模式	338
11.1.3 ajax的优点	338
11.2 ajax基础知识	339
11.2.1 xmlhttprequest对象	339
11.2.2 Javascript脚本语言	341
11.2.3 文档对象模型dom	342
11.2.4 xml语言	342
11.2.5 css样式表	342
11.3 发送请求与处理响应	342
11.3.1 发送请求	342
11.3.2 处理服务器响应	343
11.3.3 一个完整的实例	345
11.4 ajax重构	347
11.5 ajax开发需要注意的几个问题	348
11.5.1 浏览器兼容性问题	348
11.5.2 性能问题	348
11.5.3 中文编码问题	349
11.5.4 安全问题	349
11.6 照猫画虎——基本功训练	350
11.6.1 基本功训练1——显示公告信息	350
11.6.2 基本功训练2——验证用户身份	351
11.6.3 基本功训练3——创建工具提示	353
11.6.4 基本功训练4——在网页中添加实时走动的系统时钟	354
11.6.5 基本功训练5——实现自动保存草稿	355
11.7 情景应用——拓展与实战	356
11.7.1 情景应用1——自动提交考卷	356
11.7.2 情景应用2——ajax验证用户名是否被注册	360
11.7.3 情景应用3——ajax实现聊天室	362
11.7.4 情景应用4——仿百度搜索引擎	364
11.7.5 情景应用5——级联选择框	366
11.8 自我测试	370
11.9 行动指南	371
11.10 可功可以复制——为编程事业而奋斗终生安德斯·海尔斯伯格	371
第3部分 框架篇
第12堂课 struts2基础	375
12.1 struts2简介	376
12.1.1 struts2的产生	376
12.1.2 struts2的结构	376
12.2 第一个struts2实例	377
12.2.1 获取struts2以及相关类库	377
12.2.2 jsp登录页面的创建	377
12.2.3 action的实现	378
12.2.4 struts2的配置文件	378
12.2.5 web.xml的配置	379
12.3 struts2的配置文件	379
12.3.1 全局配置文件struts.properties	380
12.3.2 核心配置文件struts.xml	380
12.3.3 配置package和名称空间	381
12.4 action的应用	381
12.4.1 action简介	381
12.4.2 action中的方法	382
12.4.3 action中方法的执行	382
12.5 struts2的零配置	383
12.5.1 通过@注解实现零配置	383
12.5.2 零配置时web.xml中的配置	383
12.6 照猫画虎——基本功训练	384
12.6.1 基本功训练1——通过url执行action方法	384
12.6.2 基本功训练2——在action中配置执行方法	385
12.6.3 基本功训练3——通过struts2注解实现的零配置	386
12.6.4 基本功训练4——零配置下访问action	387
12.7 情景应用——拓展与实践	387
12.7.1 情景应用1——实现用户登录	387
12.7.2 情景应用2——实现简单计算器	389
12.7.3 情景应用3——实现成绩显示器	390
12.7.4 情景应用4——实现简单投票器	391
12.8 自我测试	392
12.9 行动指南	393
12.10 成功可以复制——因特网的点火人安德森	393
第13堂课 深入struts2	395
13.1 struts2标签	396
13.1.1 控制标签	396
13.1.2 数据标签	399
13.1.3 表单ui标签	403
13.2 struts2数据验证机制	406
13.2.1 手动验证的实现	407
13.2.2 validate()方法的使用	407
13.2.3 struts2验证框架	409
13.2.4 验证文件的命名规则	410
13.2.5 了解struts2的内置验证器	411
13.3 数据类型转换器	414
13.3.1 配置转换器	414
13.3.2 在struts.xml中配置转换器	414
13.4 struts2拦截器	415
13.4.1 了解拦截器	415
13.4.2 内置拦截器	416
13.4.3 拦截器的配置	417
13.4.4 拦截器api	417
13.4.5 带有参数的拦截器	418
13.5 照猫画虎——基本功训练	419
13.5.1 基本功训练1——数据转换器	419
13.5.2 基本功训练2——使用数据标签进行日期输出	420
13.5.3 基本功训练3——表单标签实现数据提交	421
13.5.4 基本功训练4——xml中配置的数据检验器	422
13.6 情景应用——拓展与实践	423
13.6.1 情景应用1——显示注册时间	423
13.6.2 情景应用2——用户信息的表格输出	424
13.6.3 情景应用3——联动选择框	425
13.6.4 情景应用4——防止网页数据的重复提交	425
13.7 自我测试	426
13.8 行动指南	427
13.9 成功可以复制——知识改变命运、科技改变生活李彦宏	428
第14堂课 hibernate框架基础	429
14.1 hibernate简介	430
14.1.1 jdbc劣势	430
14.1.2 orm中间件	430
14.1.3 hibernate结构体系	430
14.2 hibernate入门	431
14.2.1 hibernate配置文件解析	431
14.2.2 编写持久化类	432
14.2.3 编写映射文件	433
14.2.4 hibernate基本数据类型的映射	435
14.3 自动建表技术	435
14.4 hibernate持久化对象	436
14.4.1 编写hibernate的初始化类	437
14.4.2 添加数据	438
14.4.3 删除数据	439
14.4.4 修改数据	440
14.4.5 查询数据	441
14.5 hibernate缓存及延迟加载	442
14.5.1 一级缓存	442
14.5.2 二级缓存	443
14.5.3 lazy策略	444
14.6 照猫画虎——基本功训练	444
14.6.1 基本功训练1——录入图书信息	444
14.6.2 基本功训练2——应用get()方法查询商品信息	446
14.6.3 基本功训练3——应用load()方法查询药品信息	447
14.6.4 基本功训练4——删除编号为1的学生信息	448
14.7 情景应用——拓展与实践	449
14.7.1 情景应用1——延迟加载查询药品信息	449
14.7.2 情景应用2——hibernate实现用户注册	450
14.7.3 情景应用3——修改学生信息	451
14.7.4 情景应用4——批量添加药品信息	453
14.8 自我测试	454
14.9 行动指南	454
14.10 成功可以复制——中国通信设备行业的领跑者任正非	455
第15堂课 hibernate高级应用	457
15.1 关联关系映射	458
15.1.1 单向关联与双向关联	458
15.1.2 多对一单向关联映射	458
15.1.3 多对一双向关联映射	459
15.1.4 一对一主键关联映射	460
15.1.5 一对一外键关联映射	461
15.1.6 多对多关联映射	462
15.2 继承映射	464
15.2.1 类继承树映射成一张表	464
15.2.2 每个具体类映射成一张表	465
15.2.3 每个子类映射成一张表	466
15.3 hql检索方式	467
15.3.1 hql基本语法	467
15.3.2 实例对象与动态实例化对象查询	468
15.3.3 hql语句的动态赋值	468
15.3.4 条件查询与使用别名	469
15.4 照猫画虎——基本功训练	469
15.4.1 基本功训练1——hql排序查询订单信息	469
15.4.2 基本功训练2——hql查询订单总金额	471
15.4.3 基本功训练3——hql实现统计各部门人数	471
15.4.4 基本功训练4——查询某日期出生的用户	472
15.5 情景应用——拓展与实践	473
15.5.1 情景应用1——多对一映射添加与查询图书信息	473
15.5.2 情景应用2——模糊查询药品信息	476
15.5.3 情景应用3——内连接查询图书信息	478
15.5.4 情景应用4——利用多态查询判断用户登录身份	480
15.6 自我测试	482
15.7 行动指南	483
15.8 成功可以复制——通往成功的桥梁陈天桥	483
第16堂课 spring框架	485
16.1 spring概述	486
16.1.1 初识spring	486
16.1.2 spring的获取	487
16.1.3 简单配置spring	487
16.1.4 使用beanfactory管理bean	488
16.1.5 applicationcontext的应用	488
16.2 依赖注入	489
16.2.1 控制反转与依赖注入	489
16.2.2 bean的配置	490
16.2.3 setter注入	491
16.2.4 构造器注入	492
16.2.5 引用其他的bean	493
16.2.6 匿名内部Javabean的创建	494
16.3 spring aop概述	495
16.3.1 了解aop	495
16.3.2 aop的简单实现	496
16.4 spring的切入点	497
16.4.1 静态切入点与动态切入点	498
16.4.2 深入静态切入点	499
16.4.3 深入切入点底层	499
16.4.4 spring中其他切入点	500
16.5 aspect对aop的支持	500
16.5.1 了解aspect	500
16.5.2 spring中的aspect	501
16.5.3 defaultpointcutadvisor切入点配置器	501
16.5.4 namematchmethodpointcutadvisor切入点配置器	502
16.6 spring持久化	502
16.6.1 dao模式介绍	502
16.6.2 spring的dao理念	503
16.6.3 事务应用的管理	505
16.6.4 应用jdbctemplate操作数据库	506
16.6.5 与hibernate整合	507
16.7 照猫画虎——基本功训练	508
16.7.1 基本功训练1——应用ioc实现的第一个spring实例	508
16.7.2 基本功训练2——验证用户登录	510
16.7.3 基本功训练3——登录页面国际化	512
16.7.4 基本功训练4——利用transactiontemplate实现编程式事务管理	513
16.7.5 基本功训练5——transactionproxyfactorybean实现声明式事务管理	515
16.8 情景应用——拓展与实践	516
16.8.1 情景应用1——在spring中利用dao模式向商品信息表中添加数据	516
16.8.2 情景应用2——spring aop实现用户注册	518
16.8.3 情景应用3——利用jdbctemplate向员工信息表中添加数据	521
16.8.4 情景应用4——整合spring和hibernate向员工信息表添加数据	523
16.8.5 情景应用5——整合spring和hibernate操作商品库存表	525
16.9 自我测试	531
16.10 行动指南	532
16.11 成功可以复制——中国第一程序员求伯君	533
第17堂课 spring mvc框架	535
17.1 spring mvc简介	536
17.1.1 spring mvc的特点	536
17.1.2 spring mvc的不足	536
17.2 spring mvc中的组件	536
17.2.1 核心控制器	536
17.2.2 业务控制器	537
17.2.3 控制器映射	537
17.2.4 模型与视图	537
17.2.5 视图解析器	537
17.2.6 command对象	537
17.3 spring mvc核心控制器	537
17.4 spring mvc控制器映射	538
17.4.1 配置beannameurlhandlermapping	538
17.4.2 配置simpleurlhandlermapping	539
17.4.3 多个控制器映射	539
17.5 spring mvc业务控制器	539
17.5.1 简单控制器	540
17.5.2 参数映射控制器	542
17.5.3 文件名映射控制器	542
17.5.4 表单控制器	543
17.5.5 多动作控制器	545
17.6 视图解析器	548
17.6.1 视图解析器介绍	548
17.6.2 配置internalresourceviewresolver	549
17.7 常见的其他第三方mvc框架	549
17.7.1 struts	549
17.7.2 jsf	550
17.7.3 struts2	550
17.8 照猫画虎——基本功训练	550
17.8.1 基本功训练1——参数映射控制器映射jsp页面	550
17.8.2 基本功训练2——利用命令控制器获取url中的参数查询信息	551
17.8.3 基本功训练3——利用表单控制器实现添加数据的操作	554
17.8.4 基本功训练4——利用表单控制器实现验证处理	555
17.8.5 基本功训练5——spring编码过滤器解决中文乱码	557
17.9 情景应用——拓展与实践	558
17.9.1 情景应用1——利用spring生成excel工作表	558
17.9.2 情景应用2——利用spring生成pdf文件	561
17.9.3 情景应用3——利用spring的多动作控制器实现数据查询和删除操作	562
17.9.4 情景应用4——利用spring向导控制器实现分步用户注册	565
17.9.5 情景应用5——使用spring mvc编写在线通讯录	567
17.10 自我测试	573
17.11 行动指南	574
17.12 成功可以复制——征途巨人史玉柱	575
第4部分 实用技术篇
第18堂课 jsp操作xml	579
18.1 xml简介	580
18.1.1 xml文档结构	580
18.1.2 xml语法要求	581
18.1.3 为xml文档中的元素定义属性	581
18.2 dom4j创建xml文档	582
18.2.1 创建xml文档对象	582
18.2.2 创建根节点	582
18.2.3 添加注释	583
18.2.4 创建子节点	583
18.2.5 添加属性	583
18.2.6 设置节点内容	584
18.2.7 设置输出格式	584
18.2.8 设置编码	584
18.2.9 输出xml文档	585
18.3 解析xml文件	585
18.3.1 构建xml文档对象	586
18.3.2 获取根节点	586
18.3.3 获取子节点	586
18.3.4 删除节点	587
18.4 照猫画虎——基本功训练	587
18.4.1 基本功训练1——在控制台上显示xml文档内容	587
18.4.2 基本功训练2——在浏览器上显示xml文档内容	588
18.4.3 基本功训练3——修改xml文件中的公告信息	589
18.4.4 基本功训练4——删除公告信息	592
18.5 情景应用——拓展与实践	594
18.5.1 情景应用1——保存公告信息到xml文件	594
18.5.2 情景应用2——将数据表导入到xml文件	596
18.5.3 情景应用3——以xml文档显示jsp文件	599
18.5.4 情景应用4——使用sax读取xml文件	600
18.6 自我测试	601
18.7 行动指南	602
18.8 成功可以复制——创造互联网搜索时代谢尔盖·布林	603
第19堂课 文件上传与下载	605
19.1 文件上传	606
19.2 common-fileupload组件核心	608
19.2.1 添加表单及表单元素	608
19.2.2 创建上传对象	608
19.2.3 解析上传请求	608
19.3 文件下载	609
19.3.1 文件类	609
19.3.2 文件字节输入流	610
19.3.3 字节输出流	610
19.4 照猫画虎——基本功训练	611
19.4.1 基本功训练1——文件的简单上传	611
19.4.2 基本功训练2——读取表单信息	612
19.4.3 基本功训练3——限制上传文件的类型	615
19.4.4 基本功训练4——文件的简单下载	616
19.5 情景应用——拓展与实践	618
19.5.1 情景应用1——隐藏文件下载真实路径	618
19.5.2 情景应用2——显示上传文件的格式	619
19.5.3 情景应用3——文件的下载	620
19.5.4 情景应用4——批量文件上传	623
19.6 自我测试	624
19.7 行动指南	625
19.8 成功可以复制——初中站长的创业故事李兴平	626
第20堂课 动态图表	627
20.1 jfreechart简介	628
20.1.1 认识jfreechart组件	628
20.1.2 jfreechart的下载与使用	628
20.2 jfreechart的核心对象	629
20.2.1 制图对象	629
20.2.2 制图工厂对象	630
20.2.3 数据集合对象	630
20.2.4 绘图区对象	631
20.2.5 坐标轴对象	633
20.2.6 图片渲染对象	634
20.3 jfreechart的应用	635
20.3.1 如何获取图片	635
20.3.2 创建数据集合与jfreechart实例	636
20.3.3 图表相关属性的设置	638
20.3.4 jfreechart内置jdbc的使用	639
20.3.5 中文乱码的解决方案	641
20.4 照猫画虎——基本功训练	642
20.4.1 基本功训练1——绘制饼状图	642
20.4.2 基本功训练2——生成柱状图	643
20.4.3 基本功训练3——绘制折线图	644
20.4.4 基本功训练4——生成区域图表	646
20.4.5 基本功训练5——生成时序图表	647
20.5 情景应用——拓展与实践	649
20.5.1 情景应用1——利用柱状图显示某网站的访问量	649
20.5.2 情景应用2——利用饼图显示不同编程语言的市场占有率	650
20.5.3 情景应用3——利用折线图显示气温变化情况	652
20.5.4 情景应用4——利用区域图对比分析员工业绩	653
20.5.5 情景应用5——利用时序图分析商品月销售收益	655
20.6 自我测试	656
20.7 行动指南	657
20.8 成功可以复制——暴雪公司的领航者迈克·莫汉	658
第21堂课 Java mail组件	659
21.1 电子邮件协议简介	660
21.1.1 smtp简单邮件传输	660
21.1.2 pop3邮局协议	660
21.1.3 imap接收邮件协议	660
21.1.4 mime邮件扩充协议	660
21.2 建立Java mail开发环境	661
21.2.1 获取Java mail api	661
21.2.2 获取Java mail api的激活框架	661
21.2.3 安装和配置邮件服务器	661
21.3 发送邮件的api	663
21.3.1 session类	664
21.3.2 message类中与发送邮件相关的方法	665
21.3.3 address类	667
21.3.4 authenticator类	667
21.3.5 transport类	667
21.4 接收邮件的api	669
21.4.1 store类	669
21.4.2 folder类	669
21.4.3 flags类	670
21.4.4 message类中与接收邮件相关的方法	671
21.5 照猫画虎——基本功训练	671
21.5.1 基本功训练1——实现邮箱登录的功能	671
21.5.2 基本功训练2——发送普通文本邮件	672
21.5.3 基本功训练3——发送html格式的邮件	674
21.5.4 基本功训练4——邮件群发	677
21.6 情景应用——拓展与实践	678
21.6.1 情景应用1——发送带附件的邮件	678
21.6.2 情景应用2——群发html格式的邮件	681
21.6.3 情景应用3——获取邮件总数	683
21.6.4 情景应用4——通过邮箱激活用户注册	684
21.7 自我测试	687
21.8 行动指南	688
21.9 成功可以复制——it大王王志东	689
第5部分 实战篇
第22堂课 博客系统	693
22.1 系统概述	694
22.1.1 开发背景	694
22.1.2 系统功能结构	694
22.1.3 系统流程	695
22.2 技术要点	695
22.2.1 整合struts2与hibernate3	695
22.2.2 应用Javascript对复选框进行操作	696
22.3 设计数据库	697
22.3.1 设计e-r图	697
22.3.2 设计数据库表	698
22.4 设计公共模块	699
22.4.1 编写hibernate配置文件	699
22.4.2 编写数据持久化类	700
22.5 设计首页面	703
22.5.1 首页操作实现类	703
22.5.2 首页显示的实现	704
22.6 设计用户管理模块	705
22.6.1 用户实体类	705
22.6.2 用户的实现类	706
22.6.3 实现用户注册	706
22.6.4 推荐博客操作	709
22.7 设计文章模块	710
22.7.1 文章实体类	710
22.7.2 文章的实现类	711
22.7.3 操作文章类型	711
22.7.4 添加文章	713
22.7.5 查询文章	714
22.7.6 文章的详细查询	716
22.7.7 推荐文章的操作	716
22.8 疑难问题	717
22.8.1 struts2的中文乱码问题	717
22.8.2 关于重写模板的问题	718
22.9 本堂课小结	718
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>学通Java Web的24堂课
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>由浅入深学Java
第1篇 语言基础篇
第1章 java入门（ 教学视频：18分钟）
第2章 java基本数据类型（ 教学视频：46分钟）
第3章 数组（ 教学视频：31分钟）
第4章 字符串（ 教学视频：27分钟）
第5章 程序控制语句（ 教学视频：24分钟）
第6章 面向对象程序设计（ 教学视频：10分钟）
第7章 继承（ 教学视频：13分钟）
第8章 多态（ 教学视频：15分钟）
第9章 接口（ 教学视频：20分钟）
第2篇 高级编程篇
第10章 图形界面开发基础（ 教学视频：43分钟）
第11章 swing（ 教学视频：42分钟）
第12章 事件处理（ 教学视频：33分钟）
第13章 数字处理（ 教学视频：21分钟）
第14章 异常处理（ 教学视频：12分钟）
第15章 文件的输入与输出（ 教学视频：30分钟）
第16章 反射（ 教学视频：20分钟）
第17章 线程（ 教学视频：35分钟）
第18章 正则表达式（ 教学视频：17分钟）
第19章 封装类（ 教学视频：21分钟）
第20章 容器（ 教学视频：23分钟）
第21章 泛型（ 教学视频：15分钟）
第22章 数据结构（ 教学视频：39分钟）
第23章 数据库（ 教学视频：20分钟）
第24章 applet编程（ 教学视频：15分钟）
第3篇 网络编程篇
第25章 网络编程（ 教学视频：30分钟）
第26章 jsp（ 教学视频：31分钟）
第27章 servlet（ 教学视频：37分钟）
第4篇 综合案例篇
第28章 智达图书馆管理系统
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>由浅入深学Java
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>java游戏程序设计教程
第1章计算机游戏概述
1.1计算机游戏的发展历史
1.2计算机游戏的基本类型
1.3计算机游戏的本质及特征
1.4计算机游戏的主要功能
习题
第2章游戏设计的基本流程
2.1游戏策划
2.2游戏美术设计
2.3游戏音频设计
2.4游戏程序设计
2.5游戏测试
习题
第3章游戏程序的基本框架
3.1Java2D图形绘制简介
3.1.1坐标系统
3.1.2图形处理类
3.1.3绘制几何图形
3.1.4填充图形
3.1.5图形变换
3.2构建游戏循环
3.3双缓冲机制
3.3.1离屏绘制
3.3.2前屏显示
3.4游戏的运行框架
3.5设置帧速率
3.6Applet游戏程序框架
习题
第4章游戏的运行机制
4.1游戏中的物体运动
4.1.1模拟匀速直线运动
4.1.2模拟加速直线运动
4.2碰撞检测
4.3传递控制命令
4.4游戏设计案例一：《贪食蛇》游戏
4.4.1游戏整体设计
4.4.2贪食蛇的表示
4.4.3绘制贪食蛇
4.4.4食物类的实现
4.5游戏设计案例二：《打砖块》游戏
4.5.1游戏整体设计
4.5.2挡板类的实现
4.5.3砖块类的实现
4.5.4小球类的实现
习题
第5章游戏场景设定
5.1Java2D图像绘制简介
5.2绘制卷轴型图像
5.2.1基本绘制方法
5.2.2滚动显示
5.2.3创建Ribbon类
5.3绘制砖块型图像
5.3.1基本绘制方法
5.3.2创建TileMap类
5.3.3滚动显示
5.4创建完整的游戏场景
习题
第6章游戏角色设定
6.1精灵的图像绘制
6.2精灵的移动控制
6.3创建精灵类
习题
第7章角色与场景的交互
7.1概述
7.2玩家角色的运动及控制
7.3玩家角色与游戏场景的碰撞检测
7.3.1基本原理
7.3.2创建GameWorldManager类
7.3.3调用碰撞检测方法
7.4电脑角色的运动及碰撞检测
7.4.1定义电脑角色的行为
7.4.2设置电脑角色的初始位置
7.5玩家角色与电脑角色的碰撞检测
习题
第8章声音效果设定
8.1播放音效
8.2播放音乐
8.3为游戏添加动作音效和场景音乐
习题
第9章完善游戏规则
9.1有限状态机模型
9.2玩家角色跳起来"踩"电脑角色
9.3玩家角色发射子弹攻击电脑角色
9.4增加玩家角色生命值
9.5显示玩家生命及游戏分数
9.6实现简单的游戏人工智能
习题
第10章游戏关卡设计
10.1完善游戏关卡
10.1.1完善场景的滚动
10.1.2添加敌人和道具
10.1.3添加新的关卡
10.2添加游戏菜单
10.2.1游戏菜单设计
10.2.2游戏菜单的显示
10.2.3游戏的保存与恢复
10.3设计关卡地图编辑器
10.3.1地图编辑器总体设计
10.3.2地图编辑器详细设计
习题
第11章手机游戏设计简介
11.1手机游戏概述
11.2手机游戏开发平台简介
11.3手机游戏的程序框架
11.3.1使用WTK设计手机游戏
11.3.2使用NetBeans设计手机游戏
11.4设计《打砖块》手机游戏
11.5使用游戏生成器创建手机游戏
习题
第12章游戏设计工具Greenfoot
12.1概述
12.2基本操作方法
12.2.1打开游戏场景
12.2.2添加游戏角色
12.2.3运行游戏
12.3相关API简介
12.4编写游戏程序
12.4.1创建游戏世界
12.4.2创建游戏角色
12.4.3让游戏角色运动起来
12.4.4处理游戏中的图像
12.4.5碰撞检测
12.4.6键盘控制
12.4.7鼠标控制
12.4.8播放声音
12.4.9控制游戏的运行
12.4.10导出游戏场景
12.5编程示例
习题
第13章游戏设计案例详解
13.1模拟钢琴游戏
13.1.1基本功能设计
13.1.2添加更多琴键
13.2太空射击游戏
13.2.1构建游戏框架
13.2.2程序结构优化
13.3点灯游戏
13.3.1游戏整体设计
13.3.2各个类的具体实现
习题
附录Java类库引用参考
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>java游戏程序设计教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>网站开发非常之旅Java Web开发技术详解
第1篇　基  础  篇
第1章  Java Web网站开发基础	2
1.1  认识网页和网站	2
1.1.1  网页	2
1.1.2  网站	4
1.1.3  网站制作流程	4
1.1.4  网页设计流程	4
1.1.5  发布站点	5
1.2  Web开发技术介绍和工作原理	5
1.2.1  本地计算机和远程服务器	6
1.2.2  Web应用程序的工作原理	6
1.2.3  常用的Web开发技术	6
1.3  初识Java Web	8
1.3.1  Java语言基础	8
1.3.2  Java Web体系介绍	9
1.4  搭建开发环境	9
1.4.1  安装JDK	9
1.4.2  配置开发环境	12
1.5  Tomcat的安装与配置	13
1.5.1  获取Tomcat	13
1.5.2  配置Tomcat的服务端口	16
1.5.3  登录控制台	16
1.5.4  设置虚拟目录	19
第2章  HTML技术介绍	20
2.1  创建基本静态页面	20
2.1.1  设置网页头部和标题	20
2.1.2  设置页面正文和注释	21
2.1.3  文字和段落处理	22
2.1.4  超链接处理	24
2.1.5  插入图片	26
2.1.6  列表处理	28
2.2  HTML页面布局	30
2.2.1  使用表格标记	30
2.2.2  使用框架标记	33
2.3  表单处理	35
2.3.1  表单标记介绍	35
2.3.2  使用form标记	35
2.3.3  使用文本域	36
2.3.4  使用文本区域和按钮	36
2.3.5  使用单选按钮和复选框	37
2.3.6  使用列表菜单	37
2.3.7  使用文件域、图像域和隐藏域	37
2.4  特效和多媒体处理	39
2.4.1  实现滚动效果	39
2.4.2  设置背景音乐	40
2.4.3  插入Flash	40
2.4.4  使用ActiveX控件	41
第3章  CSS技术基础	43
3.1  CSS技术介绍	43
3.1.1  CSS概述	43
3.1.2  CSS的特点和意义	44
3.2  CSS的语法结构	44
3.3  CSS选择符	45
3.4  调用方式	47
3.5  定位布局	47
3.5.1  元素排列	48
3.5.2  浮动属性定位	49
3.6  使用CSS属性	50
3.6.1  属性类别	50
3.6.2  定位属性	52
3.6.3  内容控制属性	53
3.6.4  浮动属性	55
3.6.5  列表属性	55
3.6.6  补白属性	56
3.6.7  边框属性	57
3.6.8  边界属性	59
3.7  CSS修饰	60
3.7.1  文本修饰	60
3.7.2  图片修饰	60
3.7.3  修饰表单	61
第4章  JavaScript脚本语言基础	63
4.1  JavaScript简介	63
4.1.1  运行环境	63
4.1.2  JavaScript格式	63
4.1.3  一个典型的JavaScript文件	63
4.2  数据类型	64
4.2.1  数据类型概述	65
4.2.2  JavaScript常量	65
4.2.3  JavaScript变量	66
4.3  表达式和运算符	66
4.3.1  JavaScript表达式	67
4.3.2  JavaScript运算符	67
4.4  JavaScript循环语句	69

4.4.1  if条件语句	70
4.4.2  for循环语句	71
4.4.3  while循环语句	72
4.4.4  do...while循环语句	73
4.4.5  break控制	73
4.4.6  switch循环语句	74
4.5  JavaScript函数	74
4.5.1  JavaScript函数的构成	74
4.5.2  JavaScript常用函数	75
4.6  JavaScript对象	76
4.6.1  对象基础知识	76
4.6.2  JavaScript常用对象和方法	78
4.7  JavaScript事件	81
4.7.1  JavaScript常用事件	81
4.7.2  事件处理程序	82
4.8  JavaScript窗口对象	82
4.8.1  窗口对象	83
4.8.2  窗口对象的事件驱动	83
4.8.3  窗口对象中的属性	83
4.8.4  窗口对象的方法	84
4.8.5  JavaScript窗口对象的应用	84
第2篇　核心技术篇
第5章  JSP基础	86
5.1  JSP概述	86
5.1.1  JSP简介	86
5.1.2  JSP的优缺点	87
5.2  构建Web应用	87
5.3  配置描述符web.xml	88
5.4  JSP需要Servlet	89
5.5  JSP的基本语法	91
5.5.1  基本语法介绍	91
5.5.2  JSP的注释	92
5.5.3  JSP的声明	94
5.5.4  输出表达式	95
5.5.5  脚本	96
5.6  编译指令	98
5.6.1  page指令	99
5.6.2  include指令	100
第6章  动作指令和内置对象	102
6.1  JSP的动作指令	102
6.1.1  响应转发指令forward	102
6.1.2  动态include指令	103
6.1.3  下载指令plugin	104
6.1.4  设置参数值指令param	104
6.1.5  useBean、setProperty和getProperty
指令	105
6.2  JSP的内置对象	107
6.2.1  九大内置对象简介	107
6.2.2  使用application对象	109
6.2.3  使用config对象	110
6.2.4  使用exception对象	111
6.2.5  使用pageContext对象	113
6.2.6  使用out对象	114
6.2.7  使用request对象	116
6.2.8  使用response对象	121
6.2.9  使用session对象	125
第7章  自定义标签和新特性	129
7.1  自定义JSP标签	129
7.1.1  自定义标签基础	129
7.1.2  开发自定义标签类	129
7.1.3  编写TLD文件	130
7.1.4  使用标签库里的标签	132
7.1.5  修改web.xml	133
7.1.6  应用自定义标签	134
7.1.7  将页面片段作为属性的标签	139
7.1.8  动态属性的标签	139
7.2  JSP 2.0的新特性	140
7.2.1  JSP 2.0新特性概述	140
7.2.2  配置JSP属性	140
7.2.3  JSP的表达式	142
7.2.4  自定义标签Tag File	149
第8章  Servlet详解	150
8.1  Servlet是什么	150
8.1.1  Servlet介绍	150
8.1.2  Servlet技术的优越性	151
8.1.3  Servlet持久性	151
8.2  Servlet开发基础	152
8.3  配置Servlet	154
8.4  Servlet接口和类	161
8.4.1  与Servlet配置相关的接口	161
8.4.2  Servlet编程接口	161
8.4.3  使用Httpservlet类	162
8.4.4  用HttpSession接口实现会话	165
8.5  Servlet过滤器	167
8.5.1  配置过滤器	167
8.5.2  使用过滤器	168
8.6  Filter详解	170
8.6.1  Filter基础	170
8.6.2  创建Filter	170
8.6.3  配置Filter	172
8.7  使用Listener类	173
8.7.1  Listener类基础	173
8.7.2  实现Listener类	173
8.7.3  接口ServletContextAttributeListener	175
8.8  全新的Servlet 3.0	175
8.8.1  新的Annotation	175
8.8.2  对Web模块的支持	176
8.8.3  新引入的异步处理	177
8.8.4  改进的Servlet API	178
第9章  深入详解JavaBean	180
9.1  JavaBean基础	180
9.1.1  JavaBean介绍	180
9.1.2  使用JavaBean	181
9.2  JSP和JavaBean	182
9.2.1  JSP访问JavaBean	182
9.2.2  在JSP中调用JavaBean	184
9.3  设置JavaBean属性	187
9.3.1  简单属性Simple	187
9.3.2  数组值属性Indexed	188
9.3.3  通知属性Bound	189
9.3.4  否决属性Constrained	190
9.3.5  JSP设置属性	191
9.4  JavaBean方法	196
9.5  JavaBean的作用范围	201
9.5.1  Page的作用域	201
9.5.2  Request的作用域	202
9.5.3  Session的作用域	204
9.5.4  Application的作用域	205
9.6  JavaBean的移除	206
第10章  JSTL标签库	210
10.1  JSTL基础	210
10.1.1  使用第三方提供的标签库	210
10.1.2  JSTL标签的构成	211
10.2  JSTL Core标签库	212
10.2.1  一般用途的标签	213
10.2.2  条件标签	216
10.2.3  迭代标签	218
10.2.4  和URL相关的标签	223
10.3  I18N标签库	226
10.3.1  <fmt:formatNumber>标签	226
10.3.2  <fmt:parseNumber>标签	229
10.3.3  <fmt:formatDate>标签	231
10.3.4  <fmt:parseDate>标签	233
10.3.5  <fmt:setTimeZone>标签	235
10.3.6  <fmt:timeZone>标签	236
10.3.7  <fmt:setLocale>标签	237
10.3.8  <fmt:requestEncoding>标签	239
10.3.9  <fmt:setBundle>标签	239
10.3.10  <fmt:message>标签	239
10.3.11  <fmt:param>标签	241
10.3.12  <fmt:bundle>标签	242
10.4  使用SQL标签库	242
10.4.1  <sql:setDataSource>标签	243
10.4.2  <sql:query>标签和<sql:param>标签	244
10.4.3  <sql:update>标签	245
10.4.4  <sql:dateParam>标签	246
10.4.5  <sql:transaction>标签	247
10.5  函数标签	247
10.5.1  求长度函数	248
10.5.2  大小写转换函数	249
10.5.3  求子串函数	249
10.5.4  去空白函数	250
10.5.5  替换函数	250
10.5.6  查找函数	250
10.5.7  拆分与组合函数	251
10.5.8  函数escapeXml()	251
第11章  Ajax技术	252
11.1  Ajax技术基础	252
11.1.1  Ajax技术介绍	252
11.1.2  Ajax开发模式与传统开发模式的比较	253
11.1.3  提高用户体验的技术	254
11.1.4  Ajax需要注意的几个问题	255
11.2  XMLHttpRequest对象	256
11.2.1  创建XMLHttpRequest对象	256
11.2.2  XMLHttpRequest对象的方法	257
11.2.3  XMLHttpRequest对象的属性	259
11.2.4  XMLHttpRequest对象的事件
句柄函数	260
11.3  与服务器通信--发送请求与
处理响应	261
11.3.1  发送请求	261
11.3.2  处理服务器响应	262
11.4  解决中文乱码问题	264
11.4.1  发送请求时出现中文乱码	264
11.4.2  获取服务器的响应结果时出现
中文乱码	264
11.5  Ajax重构	264
11.6  使用Ajax技术	266
11.6.1  一个简单的Ajax程序	266
11.6.2  分析Ajax的步骤	268
11.7  表单验证实例	272
第12章  数据库编程	278
12.1  数据库基础知识	278
12.1.1  数据库概述	278
12.1.2  数据库的几个概念	279
12.2  SQL语言	281
12.2.1  数据定义	281
12.2.2  数据操纵	283
12.2.3  视图	285
12.2.4  SQL高级操作	286
12.3  常用的几种数据库	288
12.3.1  Access数据库	288
12.3.2  SQL Server数据库	293
12.3.3  MySQL数据库	296
第13章  JDBC详解	303
13.1  初识JDBC	303
13.1.1  JDBC API	303
13.1.2  JDBC驱动类型	303
13.1.3  选择什么方式	305
13.1.4  JDBC的常用接口和类	305
13.1.5  JDBC编程步骤	307
13.2  使用PreparedStatement和
CallableStatement	310
13.3  执行SQL语句的方式	313
13.3.1  使用executeUpdate	313
13.3.2  使用execute()方法	316
13.4  事务处理	318
13.4.1  JDBC中的事务控制	318
13.4.2  JDBC事务控制的流程	319
13.5  存储过程	322
13.5.1  存储过程基础	322
13.5.2  创建存储过程	323
13.5.3  调用创建存储过程	325
第14章  JSF介绍	327
14.1  JSF简介	327
14.2  下载并安装JSF	328
14.2.1  下载JSF	328
14.2.2  配置JSF	328
14.2.3  JSF的环境配置	333
14.3  详解JSF配置文件的说明和
常用配置元素	334
14.3.1  在文件web.xml中配置FacesServlet
核心控制器	335
14.3.2  JSF的配置文件faces-config.xml	336
14.4  使用JSF	336
14.5  导航	340
14.5.1  静态导航	340
14.5.2  动态导航	341
14.5.3  通配符	347
14.5.4  使用from-action	347
14.6  JSF的核心标签	347
14.6.1  JSF核心标签概述	348
14.6.2  JSF HTML标签	349
14.6.3  表单	354
14.6.4  文本字段和文本区域	355
14.6.5  按钮和链接	356
14.7  数据转换与数据验证	357
14.7.1  Faces转换器系统	358
14.7.2  DateTimeConverter	359
14.7.3  NumberConverter	359
14.7.4  Faces验证系统	360
第15章  使用JavaMail发送邮件	361
15.1  邮件是一种全新的通信方式	361
15.1.1  电子邮件原理	361
15.1.2  JavaMail介绍	362
15.2  邮件协议介绍	362
15.2.1  SMTP协议	362
15.2.2  POP协议	363
15.2.3  IMAP协议	363
15.2.4  MIME协议	363
15.2.5  NNTP和其他协议	363
15.3  JavaMail基础	364
15.3.1  JavaMail简介	364
15.3.2  安装JavaMail	364
15.4  JavaMail核心类详解	366
15.4.1  java.util.Properties类	366
15.4.2  会话类javax.mail.Session	367
15.4.3  身份认证类javax.mail.Authenticator	368
15.4.4  消息类型类javax.mail.Message	369
15.4.5  javax.mail.Address类	372
15.4.6  协议类javax.mail.Transport	373
15.4.7  javax.mail.Store类和javax.mail.
Folder类	373
15.5  使用JavaMail API	374
15.5.1  发送消息	374
15.5.2  获取消息	375
15.5.3  删除消息和标志	376
15.5.4  自我验证	377
15.5.5  回复消息	378
15.5.6  转发消息	378
15.5.7  操作附件	379
15.5.8  处理HTML消息	381
15.5.9  用SearchTerm搜索	382
15.6  JavaMail的常见应用	383
15.6.1  Gmail收发信	383
15.6.2  JavaMail收取邮件属性配置	386

第3篇　提  高  篇
第16章  Struts 2基础	390
16.1  MVC思想	390
16.1.1  什么是MVC思想	390
16.1.2  MVC思想及其优势	391
16.1.3  Struts MVC思想	391
16.2  下载、安装Struts 2	392
16.2.1  获得并设置Struts 2	392
16.2.2  在Eclipse中使用Struts 2	394
16.2.3  使用Struts 2的流程	395
16.3  配置Struts 2	396
16.3.1  配置常量	396
16.3.2  包含其他配置文件	400
16.4  实现Action	401
16.4.1  基础知识	401
16.4.2  标准Action类	402
16.4.3  访问Servlet API	402
16.4.4  直接访问Servlet API	409
16.4.5  用ServletActionContext访问
Servlet API	409
16.5  配置Action	411
16.5.1  命名空间和包	412
16.5.2  基本配置	415
16.6  处理结果	415
16.6.1  配置处理结果	416
16.6.2  处理结果类型	416
16.6.3  动态返回结果	416
第17章  Hibernate基础	419
17.1  Hibernate基础	419
17.1.1  认识ORM	419
17.1.2  Hibernate概述	425
17.1.3  Hibernate API简介	425
17.1.4  Hibernate的核心接口	426
17.1.5  Hibernate的体系结构	426
17.2  Hibernate的下载和安装	426
17.2.1  下载Hibernate	427
17.2.2  为Eclipse安装插件	428
17.3  几种简单配置Hibernate的方式	429
17.3.1  配置数据源	429
17.3.2  配置c3p0连接池	430
17.3.3  配置proxool连接池	431
17.3.4  MySQL连接配置	432
17.3.5  SQL Server连接配置	433
17.3.6  Oracle连接配置	433
17.4  Hibernate配置	434
17.4.1  持久化操作实例	434
17.4.2  创建Configuration对象	438
17.4.3  Hibernate的JDBC连接	440
17.4.4  数据库方言	441
17.4.5  和Hibernate相关的常用属性	441
17.5  SessionFactory接口	443
17.6  Session接口	444
17.6.1  save()方法	445
17.6.2  get()方法	445
17.6.3  load()方法	446
17.6.4  update()方法	446
17.6.5  delete()方法	447
第18章  Spring技术	448
18.1  Spring技术介绍	448
18.1.1  Spring的优点	448
18.1.2  Spring将改变Java EE	448
18.2  下载并安装Spring	448
18.2.1  获取Spring压缩包	449
18.2.2  在Eclipse中使用Spring	450
18.2.3  在Web项目中使用Spring	452
18.3  依赖注入	455
18.3.1  依赖注入基础	455
18.3.2  设置注入	456
18.4  Spring容器	459
18.4.1  Spring的IoC容器	460
18.4.2  BeanFactory对IoC容器的功能
定义	461
18.4.3  XmlBeanFactory的工作原理	461
18.4.4  ApplicationContext的国际化	463
18.4.5  ApplicationContext的事件机制	465
18.4.6  Bean获取Spring容器	469
18.5  Spring中的Bean	471
18.5.1  定义Bean	471
18.5.2  Spring中Bean的作用域	473
18.5.3  配置依赖	475
18.6  Java配置管理	476
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>网站开发非常之旅Java Web开发技术详解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java编程兵书
第一篇　环境准备篇
第1章  初出茅庐：走进Java
1.1  Java是什么	2
1.2  Java历史背景	2
1.3  Java平台的3个版本	2
1.4  Java语言特点	2
1.5  Java类库概述	3
1.6  Java的工作方式	4
1.7  Java语言的前景	4
1.8  小结	5
1.9  习题	5
第2章  拨云见日：Java语言的环境配置
2.1  操作系统要求	7
2.2  下载与安装JDK 7	7
2.2.1  JDK 7的下载	7
2.2.2  JDK 7的安装	9
2.2.3  设置环境变量	10
2.2.4  测试环境变量是否配置成功	12
2.3  第一个Java程序——HelloWorld	12
2.3.1  编写HelloWorld	12
2.3.2  编译运行	13
2.3.3  分析结构	14
2.4  小结	14
2.5  习题	14
第3章	见龙在田：开发工具介绍
3.1  UltraEdit和EditPlus编辑器	17
3.2  集成开发工具介绍	17
3.2.1  JBuilder简介	17
3.2.2  NetBeans简介	17
3.2.3  Eclipse简介	17
3.2.4  下载Eclipse	18
3.3  使用Eclipse开发第一个程序——HelloWorld	19
3.4  小结	22
3.5  习题	23
第二篇　Java语法篇
第4章  稳扎马步：Java编程基础
4.1  注释	25
4.2  标识符和关键字	26
4.2.1  命名标识符的规则	26
4.2.2  关键字	26
4.3  变量和常量	27
4.3.1  变量	27
4.3.2  常量	27
4.4  数据基本类型	28
4.4.1  整型	28
4.4.2  浮点型	29
4.4.3  字符型	29
4.4.4  逻辑型	30
4.5  数据类型之间的转换	30
4.5.1  自动类型转换	31
4.5.2  强制类型转换	31
4.6  JAVA中的运算符	32
4.6.1  算术运算符	32
4.6.2  关系运算符	34
4.6.3  逻辑运算符	34
4.6.4  赋值运算符	35
4.6.5  位运算符	35
4.6.6  移位运算符	37
4.6.7  三元运算符	38
4.6.8  对象运算符	39
4.7  运算符的优先级	39
4.8  Java语言的编码规范	40
4.8.1  语法规范	40
4.8.2  代码编写规范	40
4.9  本章知识点综合应用	41
4.9.1  转换基本数据类型	41
4.9.2  Java的运算符	43
4.10  小结	50
4.11  习题	50
第5章  白鹤亮翅：程序控制语句
5.1  条件语句	52
5.1.1  if语句	52
5.1.2  switch语句	55
5.1.3  if与switch的区别	56
5.2  循环语句	57
5.2.1  for循环结构	57
5.2.2  while循环结构	58
5.2.3  do-while循环结构	59
5.2.4  while与do-while的区别	60
5.3  break和continue语句	61
5.3.1  break语句	61
5.3.2  continue语句	62
5.3.3  break与continue的区别	63
5.4  本章知识点综合应用	63
5.4.1  控制程序的流程	63
5.4.2  计算阶乘	66
5.5  小结	67
5.6  习题	67
第6章  知己知彼：面向对象程序设计
6.1  面向对象的基本概念	69
6.1.1  面向过程与和面向对象的程序设计	69
6.1.2  对象和封装	69
6.1.3  类和实例	70
6.2  类	71
6.2.1  类的定义	71
6.2.2  成员变量	72
6.2.3  成员方法	74
6.2.4  构造方法	76
6.2.5  main()方法	76
6.2.6  参数的传递	77
6.2.7  类对象的创建、使用和清除	78
6.3  包	80
6.3.1  包的作用	80
6.3.2  包的定义	80
6.3.3  运行包中的类	81
6.3.4  引入包中的类	81
6.4  类中变量和方法的访问权限	82
6.4.1  公有类型变量和方法	83
6.4.2  受保护类型变量和方法	83
6.4.3  私有类型变量和方法	84
6.5  类的继承	85
6.5.1  继承的概念	86
6.5.2  继承的实现—创建子类	86
6.5.3  继承数据成员和方法	87
6.5.4  覆盖	88
6.5.5  继承中要注意的问题	90
6.6  类的多态性	90
6.7  抽象类	92
6.7.1  抽象类的定义	92
6.7.2  抽象类实例	92
6.8  接口	93
6.8.1  接口的定义	93
6.8.2  接口的使用	94
6.8.3  接口的继承	95
6.9  内部类	96
6.9.1  匿名类（anonymous class）	96
6.9.2  静态类（static class）	97
6.9.3  成员类（member class）	97
6.9.4  局部类（local class）	98
6.10  类相关关键字	99
6.10.1  this关键字	99
6.10.2  static修饰符	99
6.10.3  final修饰符	101
6.10.4  super关键字	103
6.11  本章知识点综合应用	104
6.11.1  Java的参数传递	104
6.11.2  自定义形状类	105
6.11.3  方法和变量在继承时的覆盖与隐藏	110
6.12  小结	114
6.13  习题	114
第7章  稳扎稳打：数组
7.1  一维数组	116
7.1.1  一维数组的声明	116
7.1.2  一维数组的创建	116
7.1.3  一维数组的初始化	116
7.1.4  一维数组元素的使用	117
7.1.5  一维数组元素的默认值	118
7.2  二维数组	119
7.2.1  二维数组声明	119
7.2.2  二维数组的创建	119
7.2.3  二维数组的初始化	120
7.2.4  二维数组的遍历	120
7.3  数组的相关操作	121
7.3.1  数组长度	121
7.3.2  数组填充	121
7.3.3  数组复制	122
7.3.4  数组比较	123
7.4  数组排序	123
7.4.1  sort函数排序	123
7.4.2  冒泡排序	124
7.5  本章知识点综合应用	125
7.5.1  使用Arrays	125
7.5.2  求质数	127
7.5.3  动态调整数组长度	129
7.6  小结	130
7.7  习题	131
第8章  借花献佛：集合
8.1  Java集合框架	133
8.2  Collection接口	133
8.2.1  转换构造方法	133
8.2.2  Collection接口的定义	133
8.2.3  Collection接口的基本操作	134
8.2.4  遍历Collection接口	134
8.2.5  Collection接口的批量操作	135
8.2.6  Collection接口的数组操作	136
8.3  Set接口	136
8.3.1  Set接口的定义	136
8.3.2  Set接口的基本操作	137
8.3.3  Set接口的批量操作	138
8.3.4  Set接口的数组操作	139
8.4  List接口	139
8.4.1  List接口的定义	140
8.4.2  从Collection继承的操作	140
8.4.3  按位置访问和查找操作	141
8.4.4  List迭代方法	142
8.5  Map接口	143
8.5.1  Map接口的定义	143
8.5.2  Map接口的基本操作	144
8.5.3  Map接口的批量操作	145
8.6  实现	145
8.6.1  实现的类型	146
8.6.2  Set接口的实现	147
8.6.3  List接口的实现	148
8.6.4  Map接口的实现	148
8.7  本章知识点综合应用	149
8.7.1  ArrayList、Vector和LinkedList	149
8.7.2  对List排序	154
8.7.3  对Map排序	156
8.8  小结	158
8.9  习题	158
第9章  点石成金：字符串处理
9.1  字符类	160
9.1.1  Character字符包装器类	160
9.1.2  转义字符序列	161
9.1.3  常用构造函数	161
9.1.4  字符的比较	162
9.1.5  取字符对象的值	162
9.2  字符串String	163
9.2.1  字符串声明与赋值	163
9.2.2  常用构造函数	163
9.2.3  获取字符串长度	165
9.3  字符串常用操作	166
9.3.1  字符串连接	166
9.3.2  字符串比较	167
9.3.3  字符串截取	168
9.3.4  字符串查找	169
9.3.5  字符串大小写转换	170
9.3.6  字符串内容的替换	171
9.3.7  获取字符串某位置的字符	172
9.4  字符串其他操作	172
9.5  字符串数组	173
9.5.1  字符串数组的构造函数	174
9.5.2  字符串数组的属性及常用方法	174
9.6  字符串缓存类StringBuffer	175
9.6.1  常用构造函数	175
9.6.2  字符串缓存与字符串的转化	176
9.6.3  字符串缓存扩充	177
9.6.4  字符串缓存插入	177
9.7  字符串缓存的其他操作	178
9.8  字符串标记类	179
9.8.1  常用构造函数	179
9.8.2  常用方法	179
9.9  本章知识点综合应用	180
9.9.1  使用String	180
9.9.2  基本数据类型与字符串的转化	184
9.9.3  使用StringBuffer	186
9.10  小结	190
9.11  习题	190
第三篇　Java编程提高篇
第10章  云行雨施：Java Swing编程
10.1  Swing的特点	192
10.2  Swing容器	192
10.2.1  JFrame容器	192
10.2.2  JPanel容器	195
10.3  创建图形界面程序	196
10.4  Swing常用组件	197
10.4.1  按钮组件JButton	197
10.4.2  复选框组件JCheckBox	198
10.4.3  单选按钮组件JRadioButton	198
10.4.4  文本框组件JTextField	198
10.4.5  密码框组件JPasswordField	199
10.4.6  组合框组件JComboBox	199
10.4.7  滑块组件JSlider	199
10.4.8  微调组制组件JSpinner	199
10.4.9  菜单组件JMenu	200
10.5  不可编辑的信息显示组件	200
10.5.1  标签组件JLabel	200
10.5.2  进度条组件JProgressBar	201
10.5.3  工具提示组件JToolTip	201
10.6  Swing高级组件	202
10.6.1  颜色选择器JColorChooser	202
10.6.2  文件选择器JFileChooser	202
10.6.3  文本编辑组件JEditorPane和JTextPane	203
10.6.4  文本区组件JTextArea	204
10.6.5  表组件JTable	204
10.6.6  树组件JTree	205
10.6.7  面板组件JPanel	206
10.6.8  滚动面板JScrollPane	207
10.6.9  拆分面板JSplitPane	207
10.6.10  选项卡面板JTabbedPane	208
10.6.11  工具栏JToolBar	208
10.7  本章知识点综合应用	209
10.7.1  一个圆形的按钮	209
10.7.2  捕捉屏幕	211
10.7.3  缩放图片	214
10.8  小结	219
10.9  习题	219
第11章  十拿九稳：标准布局
11.1  标准布局管理器简介	222
11.1.1  BorderLayout边框布局	222
11.1.2  BoxLayout盒状布局	223
11.1.3  CardLayout卡片布局	224
11.1.4  FlowLayout流动布局	225
11.1.5  GridLayout网格布局	226
11.1.6  GridBagLayout网格包布局	227
11.2  使用布局管理器技巧	228
11.2.1  设置布局管理器	228
11.2.2  向容器中添加组件	229
11.2.3  提供组件大小和排列策略	229
11.2.4  设置组件之间的间隙	229
11.2.5  设置容器的语言方向	230
11.3  本章知识点应用	231
11.3.1  设计用户登录界面	231
11.3.2  日历	235
11.4  小结	241
11.5  习题	242
第12章  料事如神：Java异常处理
12.1  Java中的异常	244
12.2  异常处理	245
12.2.1  try语句	246
12.2.2  catch语句	247
12.2.3  异常类型	247
12.2.4  异常处理原则	248
12.3  Throwable类	249
12.3.1  Throwable类的定义和方法	249
12.3.2  异常类的继承关系	250
12.3.3  使用throws抛出异常	251
12.3.4  使用throw抛出异常	252
12.3.5  运行期异常	252
12.4  自定义异常	253
12.4.1  创建自定义异常类	253
12.4.2  处理自定义异常	254
12.5  finally子句	255
12.6  异常的几个问题	256
12.6.1  异常丢失	256
12.6.2  构造函数中的异常处理	257
12.6.3  异常匹配	258
12.7  异常的优点	260
12.8  本章知识点综合应用	262
12.8.1  throw、throws、try和catch	262
12.8.2  自定义异常类	264
12.8.3  使用finally	266
12.9  小结	269
12.10  习题	270
第13章  棒打双狗：Java的输入/输出处理
13.1  什么是流	272
13.2  字节流	272
13.2.1  输入流类InputStream	272
13.2.2  输出流类OutputStream	274
13.3  字符流	275
13.3.1  Writer类	275
13.3.2  Reader类	277
13.3.3  读取Unicode字符	278
13.3.4  读取字符文件	279
13.4  File类	281
13.4.1  创建文件夹	281
13.4.2  创建文件	282
13.4.3  复制文件	283
13.4.4  删除文件	284
13.4.5  删除文件夹	284
13.5  流的运用	286
13.5.1  文件流	286
13.5.2  管道流	287
13.5.3  I/O重定向	287
13.5.4  过滤流	288
13.5.5  序列化对象	289
13.6  本章知识点综合应用	290
13.6.1  获取文件的属性信息	290
13.6.2  创建文件和目录	292
13.6.3  删除文件和目录	296
13.7  小结	299
13.8  习题	299
第14章  以柔克刚：多线程编程
14.1  线程	301
14.1.1  线程的组成	301
14.1.2  多线程概念	301
14.1.3  Java中的多线程	302
14.2  创建线程	302
14.2.1  继承Thread类创建线程	302
14.2.2  实现Runnable接口创建线程	303
14.3  线程的状态	305
14.4  线程的优先级	306
14.5  线程的同步	307
14.5.1  同步方法	307
14.5.2  固定锁和同步	308
14.6  线程的控制	310
14.6.1  启动线程	310
14.6.2  挂起和恢复线程	310
14.6.3  线程的休眠方法	310
14.6.4  线程的加入方法	312
14.6.5  中断线程	314
14.6.6  结束线程	314
14.7  线程间通信	315
14.7.1  PipedWriter类详解	315
14.7.2  PipedReader类详解	316
14.7.3  管道通信实例	317
14.8  多线程的死锁问题	318
14.9  多线程的缺点	319
14.10  本章知识点综合应用	319
14.10.1  定义和启动线程	319
14.10.2  线程的协作	321
14.10.3  线程优先级	324
14.11  小结	325
14.12  习题	325
第15章  李代桃僵：网络编程
15.1  网络编程基础	327
15.1.1  什么是TCP协议	327
15.1.2  什么是IP协议	327
15.1.3  什么是TCP/IP	327
15.1.4  什么是UDP协议	328
15.1.5  什么是端口	328
15.1.6  什么是套接字	328
15.1.7  java.net包	328
15.2  InetAddress类	329
15.3  URL网络编程	330
15.3.1  URL	330
15.3.2  符语法	331
15.3.3  URLConnection类	332
15.4  TCP的网络编程	332
15.4.1  Socket	332
15.4.2  重要的Socket API	333
15.4.3  服务器端程序设计	334
15.4.4  客户端程序设计	336
15.5  UDP网络编程	336
15.5.1  UDP通信概念	337
15.5.2  UDP的特性	337
15.5.3  UDP的应用	338
15.5.4  UDP与TCP的区别	338
15.6  本章知识点综合应用	339
15.6.1  获取URL的信息	339
15.6.2  HTTP客户端	341
15.6.3  基本的Socket编程	343
15.7  小结	348
15.8  习题	349
第16章  一箭双雕：内存管理技术
16.1  程序中“垃圾”是什么	351
16.2  “垃圾”收集器	354
16.3  如何收集“垃圾”	356
16.3.1  finalize重写	357
16.3.2  finalize安全问题	358
16.4  非线程“垃圾”	361
16.5  线程“垃圾”	362
16.6  本章知识点综合应用	365
16.6.1  弱引用实例	365
16.6.2  软引用实例	367
16.6.3  最终守护者实例	369
16.7  小结	371
16.8  习题	371
第17章  成人之美：处理图像
17.1 加载与绘制	373
17.2  图标	376
17.2.1  Icon接口	376
17.2.2  ImageIcon类	379
17.3  处理图像编码	380
17.3.1  JPEG编码器	381
17.3.2  GifEncoder编码器	382
17.4  图像抓取	384
17.4.1  createScreenCapture方法	384
17.4.2  抓屏功能使用实例	384
17.5  图像滤镜的开发	388
17.6  RGB色彩通道过滤	390
17.7  卷积滤镜	391
17.8  本章知识点综合应用	393
17.9  小结	402
17.10  习题	402
第18章  里应外合：反射与注解的应用
18.1  反射概念	404
18.2  Class类的使用实例	404
18.3  数组与Class类	408
18.4  精确判断对象类型	409
18.4.1  Field类的知识与使用	410
18.4.2  Method类的知识与使用	412
18.4.3  Constructor类的知识与使用	414
18.5  反射与修饰符	416
18.6  取消访问限制	420
18.7  利用反射动态创建数组对象	422
18.8  本章知识点综合应用	423
18.8.1  instanceof操作符	423
18.8.2  获取类的信息	424
18.9  小结	431
18.10  习题	431
第19章  如虎添翼：使用JDBC连接数据库
19.1  数据库	433
19.1.1  数据库简介	433
19.1.2  SQL语句	433
19.2  JDBC简介	435
19.2.1  什么是JDBC	435
19.2.2  JDBC与Java结合	435
19.2.3  JDBC如何实现数据库的平台无关性	435
19.3  JDBC中的常用类和接口	436
19.3.1  驱动程序管理类（DriverManager）	436
19.3.2  声明类（Statement）	436
19.3.3  数据库连接类（Connection）	437
19.3.4  结果集合类（ResultSet）	437
19.4  如何实现数据库的连接	438
19.4.1  加载合适的数据库驱动程序	438
19.4.2  数据库配置问题	438
19.4.3  建立数据库连接并获得Statement对象	440
19.4.4  执行数据库查询语句	440
19.4.5  获得查询结果	441
19.4.6  关闭数据库连接	441
19.4.7  完整的示例程序	441
19.5  元数据	442
19.5.1  数据库的DatabaseMetaData元数据	443
19.5.2  结果集的ResultSetMetaData元数据	443
19.6  批处理	444
19.6.1  批处理规范	444
19.6.2  批处理举例	444
19.7  本章知识点综合应用	445
19.7.1  访问数据库	445
19.7.2  对数据库进行查询	446
19.7.3  增加、修改、删除数据库中的数据	447
19.8  小结	448
19.9  习题	448
第20章  同甘共苦：使用Swing组件创建数据库应用程序
20.1  JComboBox组件创建数据库应用程序	450
20.1.1  创建JComboBox	450
20.1.2  DefaultComboBoxModel创建JComboBox	452
20.2  JList组件创建数据库应用程序	453
20.2.1  DefaultListModel创建JList	453
20.2.2  ListModel创建JList	454
20.3  JTable组件创建数据库应用程序	456
20.3.1  JTable相关的类	456
20.3.2  DefaultTableModel创建JTable	457
20.4  本章知识点综合应用	458
20.4.1  使用ResultSet更新数据库	458
20.4.2  使用RowSet	462
20.5  小结	472
20.6  习题	473
第21章  明修栈道：JSP技术
21.1  JSP简介	475
21.1.1  MVC模式	475
21.1.2  JSP技术的优点	476
21.2  基本语法	476
21.2.1  注释	476
21.2.2  JSP指令	477
21.3  JSP脚本元素	480
21.3.1  JSP声明	480
21.3.2  JSP表达式	481
21.4  JSP动作	481
21.4.1  include动作元素	482
21.4.2  forword动作元素	482
21.4.3  plugin动作元素	483
21.4.4  param动作元素	483
21.4.5  useBean、setProperty和getProperty动作元素	484
21.5  JSP内置对象	486
21.5.1  request对象	486
21.5.2  response对象	488
21.5.3  session对象	488
21.5.4  application对象	489
21.5.5  out对象	491
21.5.6  config对象	491
21.5.7  exception对象	492
21.5.8  pageContext对象	492
21.6  本章知识点综合应用	493
21.6.1  获取客户端的真实IP地址	493
21.6.2  设置和读取Cookie	495
21.6.3  JSP无刷新聊天室	499
21.7  小结	505
21.8  习题	505
第22章  暗度陈仓：Servlet技术
22.1  Servlet简介	507
22.1.1  什么是Servlet	507
22.1.2  Servlet的生命周期	507
22.1.3  Servlet的基本结构	508
22.2  HTTPServlet应用编程接口	508
22.2.1  init()方法	509
22.2.2  service()方法	509
22.2.3  doGet()方法	509
22.2.4  doPost()方法	509
22.2.5  destroy()方法	509
22.2.6  GetServletConfig()方法	510
22.2.7  GetServletInfo()方法	510
22.3  创建HttpServlet	510
22.4  调用HttpServlet	512
22.4.1  由URL调用Servlet	512
22.4.2  在<FORM>标记中指定Servlet	512
22.4.3  在<SERVLET>标记中指定Servlet	513
22.4.4  在ASP文件中调用Servlet	513
22.5  Servlet之间的跳转	514
22.5.1  转向Forward	514
22.5.2  重定向Redirect	515
22.6  本章知识点综合应用	515
22.6.1  用Servlet生成图形验证码	515
22.6.2  用Servlet实现分页查看数据库	520
22.7  小结	534
22.8  习题	534
第四篇　开发实战篇
第23章  小试牛刀：界面游戏拼图
23.1  游戏简介	536
23.2  素材准备	537
23.3  游戏设计	537
23.3.1  加载和拆分图片	537
23.3.2  实现图片的随机排列	538
23.3.3  实现图片的移动	538
23.3.4  参考图像的缩放	539
23.4  开发步骤	539
23.4.1  自定义按钮类设计：ImageButton类	540
23.4.2  游戏界面布局：构造窗体类PuzzleGame	540
23.4.3  加载和拆分图像	541
23.4.4  创建拼接图面板	542
23.4.5  创建显示参考图像的面板	543
23.4.6  创建菜单栏	545
23.4.7  实现按钮事件监听器类	547
23.4.8  设置窗体在屏幕中出现的位置	547
23.4.9  编写main()方法	548
23.4.10  运行测试	548
23.5  打包部署	548
23.6  小结	549
第24章  鹤啸九天：学生信息管理系统
24.1  需求分析	551
24.2  系统设计	551
24.3  登录模块	551
24.3.1  设计构想	551
24.3.2  实现登录模块	552
24.4  学生信息模块相关流程	554
24.4.1  设计构想	554
24.4.2  实现学生信息主界面	554
24.4.3  增加学生信息	557
24.4.4  删除学生信息	560
24.4.5  修改学生信息	563
24.4.6  基本学生信息查询	567
24.4.7  成绩查询	571
24.4.8  退出系统	575
24.5  教师信息模块相关流程	576
24.5.1  主界面	576
24.5.2  增加老师信息	579
24.5.3  删除老师信息	583
24.5.4  修改老师信息	586
24.5.5  录入成绩	590
24.5.6  删除成绩	593
24.5.7  修改成绩	596
24.5.8  基本信息查询	600
24.5.9  退出系统	604
24.6  小结	606
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java编程兵书
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web编程技术
第1章 Web应用概述 第2章 Servlet技术模型 第3章 Servlet容器模型 第4章 会话管理 第5章 JSP技术模型 第6章 Web组件重用与JavaBeans 第7章 JDBC数据库访问 第8章 使用表达式语言 第9章 自定义标签的开发 第10章 JSTL与标签文件 第11章 Web事件处理与过滤器 第12章 Web应用的安全性 第13章 Struts框架基础 第14章 Ajax技术基础 参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web编程技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java RESTful Web Service实战 (第2版)
第2版序一
第2版序二
第1版序一
第1版序二
前言
第1章　JAX-RS2入门 1
1.1　解读REST 1
1.1.1　一种架构风格 2
1.1.2　基本实现形式 2
1.2　解读REST服务 3
1.2.1　REST式的Web服务 3
1.2.2　对比RPC风格 3
1.2.3　对比MVC风格 4
1.3　解读JAX-RS标准 5
1.3.1　JAX-RS2标准 5
1.3.2　JAX-RS2的目标 5
1.3.3　非JAX-RS2的目标 6
1.3.4　解读JAX-RS元素 7
1.4　Jersey项目概要 7
1.4.1　获得Jersey 8
1.4.2　Jersey问答 8
1.4.3　Jersey项目管理 8
1.4.4　Jersey许可 9
1.4.5　Jersey的模块 10
1.4.6　GlashFish项目 10
1.5　快速实现Java REST服务 12
1.5.1　第一个REST服务 13
1.5.2　第一个Servlet容器服务 17
1.6　快速了解Java REST服务 19
1.6.1　REST工程类型 19
1.6.2　REST应用描述 24
1.7　Java领域的其他REST实现 27
1.7.1　JAX-RS的其他实现 27
1.7.2　其他的REST实现 31
1.8　REST调试工具 33
1.8.1　命令行调试工具 33
1.8.2　基于浏览器的图形化调试插件 34
1.9　本章小结 37
第2章　REST API设计 38
2.1　统一接口 38
2.1.1　GET方法 39
2.1.2　PUT方法 41
2.1.3　DELETE方法 43
2.1.4　POST方法 44
2.1.5　WebDAV扩展方法 45
2.2　资源定位 47
2.2.1　资源地址设计 48
2.2.2　@QueryParam注解 50
2.2.3　@PathParam注解 52
2.2.4　@FormParam注解 55
2.2.5　@BeanParam注解 57
2.2.6　@CookieParam注解 58
2.2.7　@Context注解 58
2.3　传输格式 59
2.3.1　基本类型 59
2.3.2　文件类型 60
2.3.3　InputStream类型 61
2.3.4　Reader类型 62
2.3.5　XML类型 62
2.3.6　JSON类型 66
2.4　连通性 82
2.4.1　过渡型链接 82
2.4.2　结构型链接 83
2.5　处理响应 84
2.5.1　返回类型 85
2.5.2　处理异常 86
2.6　内容协商 89
2.6.1　@Produces注解 89
2.6.2　@Consumes注解 91
2.7　本章小结 92
第3章　REST请求处理 93
3.1　Jersey的AOP机制 93
3.2　Providers详解 94
3.3　REST请求流程 100
3.4　REST过滤器 102
3.5　REST拦截器 109
3.6　绑定机制 111
3.7　优先级 115
3.8　本章小结 116
第4章　REST服务与异步 117
4.1　为什么使用异步机制 117
4.2　JAX-RS2的异步机制 119
4.3　基于HTTP1.1的异步通信 124
4.4　基于HTML5的异步通信 129
4.5　本章小节 138
第5章　REST客户端 139
5.1　客户端接口 140
5.2　连接池 142
5.3　封装Client 147
5.4　请求Spring Boot微服务 148
5.5　JavaScript客户端 150
5.6　本章小结 152
第6章　REST测试 153
6.1　Jersey测试框架 153
6.2　单元测试 156
6.3　集成测试 158
6.4　日志增强 159
6.5　本章小结 160
第7章　微服务 161
7.1　微服务技术栈 162
7.2　REST服务与Spring Boot 165
7.3　REST服务与Spring Cloud 172
7.4　本章小结 193
第8章　容器化 195
8.1　容器技术 195
8.2　REST服务与容器 201
8.3　容器化微服务 206
8.4　本章小结 220
第9章　JAX-RS调优 223
9.1　使用缓存优化负载 223
9.2　使用版本号优化服务 229
9.3　使用参数配置优化服务 232
9.4　Java虚拟机调优 234
9.5　本章小结 238
第10章　REST安全 239
10.1　身份认证 240
10.2　资源授权 244
10.3　认证与授权实现 247
10.4　JAX-RS2实现 270
10.5　REST服务与OAuth2 273
10.6　本章小结 280
参考资料 282
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java RESTful Web Service实战 (第2版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JAVA程序设计语言
目录
绪论
Java的诞生
什么是Java语言？
获取Java资源
内容安排
基础篇
第1章 Java语言的基本表示法
1.1 标识符
1.2 注释
1.3 关键字
1.4 基本数据类型
1.5 运算符及其执行顺序
1.5.1 运算符总览
1.5.2 算术运算符
1.5.3 自增、自减运算符
1.5.4 关系运算符
1.5.5 逻辑运算符
1.5.6 位运算符
1.5.7 条件运算符
1.5.8 赋值运算符
1.6 程序流程控制――基本语句
1.6.1 选择语句
1.6.2 循环语句
1.6.3 控制转移语句
第2章 数组与字符串
2.1 数组
2.1.1 数组的说明与产生
2.1.2 一维数组
2.1.3 数组的数组
2.1.4 数组小结
2.2 字符串与字符串缓冲区
第3章 面向对象的程序设计基础
3.1 历史的发展
3.2 抽象
3.3 封装
3.4 继承
3.5 多态
第4章 Java语言的组成结构
4.1 程序结构
4.2 类及其域
4.2.1 类
4.2.2 变量
4.2.3 方法
4.3 继承与多态
4.3.1 构造方法（C0nstructor）
4.3.2 类的继承
4.3.3 界面（interface）
4.4 类库
第5章 例外
5.1 例外及其目的
5.2 例外的触发
5.2.1 隐式触发
5.2.2 显式触发
5.3 例外的捕获与处理
5.4 例外声明
第6章 线 程
6.1 线程的基本概念
6.2 创建线程
6.3 线程的状态及控制
6.4 线程的优先级
6.5 线程组
6.6 线程的同步
6.7 定时器与精灵线程
应用篇
第7章 Applet概 述
7.1 支持Java的浏览器
7.2 HTML文件中的Applet
7.3 Applet的命名方法
7.4 支持Java的浏览器与不支持Java的浏览器
第8章 基本类Applet
8.1 基本文本类Applet（BasicText）
8.2 基本图像Applet（BasicImage）
8.3 声音Applet（Audi0）
8.4 声音按钮Applet（Audi0Button）
8.5 声音文本Applet（Audi0Text）
8.6 声音图像文本Applet（AudioImageText）
8.7 URL按钮Applet（URLButton）
8.8 URL声音图像文本Applet（URLAudImgTxt）
8.9 URL声音图像文本背景Applet（URLAudImgTxtBG）
8.10 图像地图Applet（ImageMap）
8.11 小结
8.11.1 基本类Applet的功能总结
8.11.2 基本类Applet的继承关系总结
8.11.3 基本类Applet参数总结
第9章 文本类Applet
9.1 文本Applet（Text）
9.2 阴影Applet（Shadow）
9.3 柔和阴影Applet（SoftShadow）
9.4 光滑文本Applet（SmoothText）
9.5 波浪形文本Applet（WaveText）
9.6 深度Applet（Depth）
9.7 深度消褪Applet（DepthFade）
9.8 深度阴影Applet（DepthShade）
9.9 突体Applet（Emboss）
9.10 雕刻效果Applet（Engrave）
9.11 摹绘效果Applet（Stencil）
9.12 多色彩Applet（MultiColor）
9.13 多文本Applet（MultiText）
9.14 小结
9.14.1 参数总结
9.14.2 功能总结
第10章 图像类Applet
10.1 滤波器的使用
10.2 图像Applet（Image）
10.3 旋转Applet（Rotate）
10.4 镜像Applet（Mirror）
10.5 右倾Applet（SlantRight）
左倾Applet（SlantLeft）
上倾Applet（SlantUp）
下倾Applet（SlantDown）
10.6 波浪形图像Applet（WaveImageApplet）
10.7 模糊化Applet（Blur）
10.8 突体图像Applet（EmbossImage）
10.9 色彩透明Applet（TransColor）
10.10 缩放Applet（Scale）
10.11 反色Applet（Negative）
10.12 图像消褪Applet（Fade）
10.13 透明效果Applet（Transparent）
10.14 剪取与删除（Cr0p&Remove）
10.15 多图像Applet（MultiImage）
10.16 小结
10.16.1 参数总结
10.16.2 功能总结
第11章 动画类Applet
11.1 动画的概念与动画类Applet
11.2 制作动画的方法
11.2.1 文本的动画
11.2.2 图像的动画
11.3 双向动画Applet（AnimateTW0Way）
11.4 按钮动画Applet（AnimateOnButt0n）
11.5 双向按钮动画Applet（AnimateOnButt0nTw0Way）
11.6 指针动画Applet（AnimateOnEntry）
11.7 双向指针动画Applet（AnimateOnEntryTw0Way）
11.8 多重动画Applet（AnimateMultiple）
第12章 文本动画类Applet
12.1 TrackerApplet
12.2 TrackFadeApplet
12.3 CoalesCeApplet
12.4 MoveLeftApplet
12.5 MoveUpApplet
12.6 UpAndOverApplet
12.7 TickerApplet
12.8 小结
第13章 滑动类Applet
13.1 SlideShowApplet的功能实现
13.2 SlideShowPushApplet，
Slidesh0wSlideApplet
SlideShowsplitApplet，
SlideShowSwapApplet的功能实现
13.3 SlideShowFadeApplet
深入篇
第14章 输入输出流
14.1 流的基本概念
14.2 File类
14.3 Java语言流库的结构
14.4 输入类及方法
14.4.1 文件输入流（FileI即utStream）
14.4.2 字节数组输入流（ByteArrayInputStream）
14.4.3 字符串缓冲输入流（BufferedInputStream）
14.4.4 顺序输入流（SequenceInputStream）
14.4.5 管道输入流（PipedInputStream）
14.4.6 输入过滤流（FilterInputStream）
14.5 输出类及方法
14.5.1 文件输出流（FileOutputStream）
14.5.2 字节数组输出流（ByteArrayOutputStream）
14.5.3 管道输出流（PipedOutputStream）
14.5.4 输出过滤流（FilterOutputStream）
14.6 文件随机访问流
14.7 有关文件流的几个跨平台移植问题
第15章 网络程序设计
15.1 网络程序设计的基本概念
15.1.1 TCP/IP协议的简介
15.1.2 socket编程机制
15.2 Java语言中面向连接的socket机制
15.2.1 用socket实现简单的服务器
15.2.2 客户端的socket实现
15.2.3 服务器s0cket机制的深入讨论――并发服务器的实现
15.2.4 s0cket常用的API方法
15.3 数据报socket通信机制
15.3.1 建立数据报Socket
15.3.2 数据报的接收与发送
15.4 全球资源定位器――URL
15.4.1 URL的概念
15.4.2 创建URL
15.4.3 由URL对象获得其要素
15.4.4 运用URL
15.5 Java语言的安全管理
15.5.1 SecurityManager类
15.5.2 自行实现一个安全管理器
第16章 抽象窗口工具箱（AWT）
16.1 AWT的简单应用
16.2 AWT的工作机制
16.3 AWT的特点及类结构
16.4 AWT的组成类
16.4.1 Component类
16.4.2 Container类
16.4.3 Window类
16.4.4 Frame类
16.4.5 Dialog类
16.4.6 Panel类
16.5 各种各样的组件
16.5.1 有关组件的基本用法
16.5.2 Button类
16.5.3 Label类
16.5.4 Canvas类
16.5.5 Scrollbar类
16.5.6 Checkb0x类和Checkb0xGroup类
16.5.7 List类
16.5.8 Ch0ice类
16.5.9 TextField类
16.5.10 TextArea类
16.6 菜单
16.7 AWT的布局管理器
16.8 AWT的事件处理
16.8.1 AWT的事件类型
16.8.2 事件的处理过程
16.9 AWT的图形设计
16.9.1 颜色、字体、文本、绘图模式
16.9.2 绘制一些基本图形
16.9.3 图像显示
第17章 Applet高级程序设计技术
17.1 Applet的简单应用
17.2 Applet的生命周期
17.3 Applet用户界面的创建
17.3.1 创建Applet图形用户界面
17.3.2 Applet参数的定义和获取
17.3.3 在Applet中播放声音和图像
17.3.4 在浏览器中显示有关Applet的状态信息
17.3.5 使用标准输出显示诊断信息
17.4 动画技术
17.5 Applet与其它程序间的通信
17.5.1 同一主页的Applet之间的通信
17.5.2 Applet与浏览器的通信
17.5.3 通过网络连接与服务器通信
17.6 Applet的安全性限制
参考文献
后记

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JAVA程序设计语言
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JavaScript权威指南(第6版)
前言  1
第1章 JavaScript概述  5
1.1 JavaScript语言核心  8
1.2 客户端JavaScript  12
第一部分 JavaScript 语言核心
第2章 词法结构  25
2.1 字符集  25
2.2 注释  27
2.3 直接量  27
2.4 标识符和保留字  28
2.5 可选的分号  30
第3章 类型、值和变量  32
3.1 数字  34
3.2 文本  38
3.3 布尔值  43
3.4 null和undefined  44
3.5 全局对象  45
3.6 包装对象  46
3.7 不可变的原始值和可变的对象引用  47
3.8 类型转换  48
3.9 变量声明  55
3.10 变量作用域  56
第4章 表达式和运算符  60
4.1 原始表达式  60
4.2 对象和数组的初始化表达式  61
4.3 函数定义表达式  62
4.4 属性访问表达式  63
4.5 调用表达式  64
4.6 对象创建表达式  64
4.7 运算符概述  65
4.8 算术表达式  69
4.9 关系表达式  74
4.10 逻辑表达式  79
4.11 赋值表达式  81
4.12 表达式计算  83
4.13 其他运算符  86
第5章 语句  91
5.1 表达式语句  92
5.2 复合语句和空语句  92
5.3 声明语句  94
5.4 条件语句  96
5.5 循环  101
5.6 跳转  106
5.7 其他语句类型  113
5.8 JavaScript语句小结  116
第6章 对象  118
6.1 创建对象  120
6.2 属性的查询和设置  123
6.3 删除属性  127
6.4 检测属性  128
6.5 枚举属性  130
6.6 属性getter和setter  132
6.7 属性的特性  134
6.8 对象的三个属性  138
6.9 序列化对象  141
6.10 对象方法  142
第7章 数组  144
7.1 创建数组  144
7.2 数组元素的读和写  145
7.3 稀疏数组  147
7.4 数组长度  148
7.5 数组元素的添加和删除  149
7.6 数组遍历  149
7.7 多维数组  151
7.8 数组方法  152
7.9 ECMAScript 5中的数组方法  156
7.10 数组类型  160
7.11 类数组对象  161
7.12 作为数组的字符串  163
第8章 函数  165
8.1 函数定义  166
8.2 函数调用  168
8.3 函数的实参和形参  173
8.4 作为值的函数  178
8.5 作为命名空间的函数  181
8.6 闭包  182
8.7 函数属性、方法和构造函数  188
8.8 函数式编程  194
第9章 类和模块  201
9.1 类和原型  202
9.2 类和构造函数  203
9.3 JavaScript中Java式的类继承  207
9.4 类的扩充  210
9.5 类和类型  212
9.6 JavaScript中的面向对象技术  217
9.7 子类  230
9.8 ECMAScript 5 中的类  239
9.9 模块  248
第10章 正则表达式的模式匹配  253
10.1 正则表达式的定义  253
10.2 用于模式匹配的String方法  261
10.3 RegExp对象  263
第11章 JavaScript的子集和扩展  267
11.1 JavaScript的子集  268
11.2 常量和局部变量  271
11.3 解构赋值  274
11.4 迭代  276
11.5 函数简写  285
11.6 多Catch 从句  285
11.7 E4X: ECMAScript for XML  286
第12章 服务器端JavaScript  290
12.1 用Rhino脚本化Java  291
12.2 用Node实现异步I/O  297
第二部分 客户端JavaScript
第13章 Web浏览器中的JavaScript  309
13.1 客户端JavaScript  309
13.2 在HTML里嵌入JavaScript  313
13.3 JavaScript程序的执行  319
13.4 兼容性和互用性  326
13.5 可访问性  333
13.6 安全性  334
13.7 客户端框架  339
第14章 Window对象  341
14.1 计时器  342
14.2 浏览器定位和导航  343
14.3 浏览历史  345
14.4 浏览器和屏幕信息  346
14.5 对话框  348
14.6 错误处理  351
14.7 作为Window对象属性的文档元素  351
14.8 多窗口和窗体  353
第15章 脚本化文档  361
15.1 DOM概览  362
15.2 选取文档元素  364
15.3 文档结构和遍历  371
15.4 属性  375
15.5 元素的内容  378
15.6 创建、插入和删除节点  382
15.7 例子：生成目录表  387
15.8 文档和元素的几何形状和滚动  389
15.9 HTML表单  396
15.10 其他文档特性  404
第16章 脚本化CSS  410
16.1 CSS概览  411
16.2 重要的CSS属性  416
16.3 脚本化内联样式  427
16.4 查询计算出的样式  431
16.5 脚本化CSS类  433
16.6 脚本化样式表  435
第17章 事件处理  440
17.1 事件类型  442
17.2 注册事件处理程序  451
17.3 事件处理程序的调用  454
17.4 文档加载事件  459
17.5 鼠标事件  461
17.6 鼠标滚轮事件  465
17.7 拖放事件  468
17.8 文本事件  475
17.9 键盘事件  478
第18章 脚本化HTTP  484
18.1 使用XMLHttpRequest  487
18.2 借助<script>发送HTTP请求：JSONP  505
18.3 基于服务器端推送事件的Comet技术  508
第19章 jQuery类库  514
19.1 jQuery基础  515
19.2 jQuery的getter和setter  522
19.3 修改文档结构  528
19.4 用jQuery处理事件  531
19.5 动画效果  542
19.6 jQuery中的Ajax  550
19.7 工具函数  563
19.8 jQuery选择器和选取方法  566
19.9 jQuery的插件扩展  574
19.10 jQuery UI类库  577
第20章 客户端存储  579
20.1 localStorage和sessionStorage  581
20.2 cookie  586
20.3 利用IE userData来持久化数据  592
20.4 应用程序存储和离线Web应用  594
第21章 多媒体和图形编程  606
21.1 脚本化图片  606
21.2 脚本化音频和视频  608
21.3 SVG：可伸缩的矢量图形  615
21.4 <canvas>中的图形  623
第22章 HTML5 API  658
22.1 地理位置  659
22.2 历史记录管理  662
22.3 跨域消息传递  668
22.4 Web Workers  671
22.5 类型化数组和ArrayBuffer  678
22.6 Blob  682
22.7 文件系统API  691
22.8 客户端数据库  696
22.9 Web套接字  704
第三部分 JavaScript核心参考
JavaScript核心参考  711
第四部分 客户端JavaScript参考
客户端JavaScript参考  847
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JavaScript权威指南(第6版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Android
推荐序
前言
第1章　本书必读1
1.1　概述1
1.2　准备环境和工具2
1.2.1　准备源代码2
1.2.2　准备Source Insight2
1.2.3　准备模拟器和自制系统镜像5
1.2.4　小结8
1.3　本书的内容9
1.4　本书资源下载说明12
第2章　深入理解Class文件格式13
2.1　Class文件格式总览13
2.2　常量池及相关内容14
2.2.1　常量项的类型和关系14
2.2.2　信息描述规则18
2.2.3　常量池实例剖析19
2.3　field_info和method_info19
2.4　access_flags介绍21
2.5　属性介绍22
2.5.1　属性概貌22
2.5.2　Code属性23
2.5.3　LineNumberTable属性25
2.5.4　LocalVariableTable属性26
2.6　Java指令码介绍27
2.6.1　指令码和助记符27
2.6.2　如何阅读规范28
2.7　学习路线推荐30
2.8　参考资料30
第3章　深入理解Dex文件格式31
3.1　Dex文件格式总览31
3.1.1　Dex和Class文件格式的区别31
3.1.2　Dex文件格式的概貌35
3.2　认识Dex文件36
3.2.1　header_item36
3.2.2　string_id_item等37
3.2.3　class_def38
3.2.4　code_item40
3.3　Dex指令码介绍41
3.3.1　insns的组织形式41
3.3.2　指令码描述规则42
3.4　学习路线推荐44
3.5　参考资料45
第4章　深入理解ELF文件格式46
4.1　概述46
4.2　ELF文件格式介绍46
4.2.1　ELF文件头结构介绍47
4.2.2　Linking View下的ELF52
4.2.3　Execution View下的ELF61
4.2.4　实例分析：调用动态库中的函数65
4.2.5　ELF总结72
4.3　学习路线推荐73
4.4　参考资料73
第5章　认识C++1174
5.1　数据类型76
5.1.1　基本内置数据类型介绍76
5.1.2　指针、引用和void类型77
5.1.3　字符和字符串81
5.1.4　数组82
5.2　C++源码构成及编译83
5.2.1　头文件示例83
5.2.2　源文件示例85
5.2.3　编译86
5.3　Class介绍88
5.3.1　构造、赋值和析构函数89
5.3.2　类的派生和继承97
5.3.3　友元和类的前向声明103
5.3.4　explicit构造函数105
5.3.5　C++中的struct106
5.4　操作符重载106
5.4.1　操作符重载的实现方式107
5.4.2　输出和输入操作符重载108
5.4.3　->和*操作符重载110
5.4.4　new和delete操作符重载111
5.4.5　函数调用运算符重载117
5.5　函数模板与类模板118
5.5.1　函数模板119
5.5.2　类模板122
5.6　lambda表达式125
5.7　STL介绍127
5.7.1　string类128
5.7.2　容器类129
5.7.3　算法和函数对象介绍134
5.7.4　智能指针类138
5.7.5　探讨STL的学习140
5.8　其他常用知识141
5.8.1　initializer_list141
5.8.2　带作用域的enum141
5.8.3　constexpr142
5.8.4　static_assert143
5.9　参考资料143
第6章　编译dex字节码为机器码145
6.1　编译器全貌介绍147
6.2　编译器前端介绍150
6.2.1　词法分析和lex151
6.2.2　语法分析和yacc160
6.2.3　语义分析和IR生成介绍171
6.3　优化器介绍175
6.3.1　构造CFG176
6.3.2　分析和处理CFG181
6.3.3　数据流分析与SSA191
6.3.4　IR优化204
6.4　ART中的IR—HInstruction222
6.4.1　ART中的IR222
6.4.2　IR之间的关系225
6.4.3　ART IR对象的初始化231
6.5　寄存器分配233
6.5.1　LSRA介绍235
6.5.2　LSRA相关代码介绍247
6.6　机器码生成相关代码介绍271
6.6.1　GenerateFrameEntry272
6.6.2　VisitAdd和VisitInstance-FieldGet273
6.6.3　GenerateSlowPaths275
6.7　总结277
6.8　参考资料280
第7章　虚拟机的创建283
7.1　概述284
7.1.1　JniInvocation Init函数介绍286
7.1.2　AndroidRuntime startVm函数介绍287
7.2　Runtime Create介绍288
7.2.1　Create函数介绍288
7.2.2　Init函数介绍290
7.3　MemMap与OatFileManager293
7.3.1　MemMap介绍293
7.3.2　OatFileManager介绍298
7.4　FaultManager介绍302
7.4.1　信号处理和SignalAction介绍302
7.4.2　FaultManager介绍307
7.5　Thread介绍311
7.5.1　Startup函数介绍311
7.5.2　Attach函数介绍312
7.6　Heap学习之一325
7.6.1　初识Heap中的关键类326
7.6.2　Heap构造函数第一部分337
7.7　JavaVMExt和JNIEnvExt340
7.7.1　JavaVMExt341
7.7.2　JNIEnvExt343
7.7.3　总结344
7.8　ClassLinker345
7.8.1　关键类介绍345
7.8.2　ClassLinker构造函数352
7.8.3　InitFromBootImage353
7.8.4　ClassLinker总结360
7.9　总结和阅读指导362
第8章　虚拟机的启动363
8.1　Runtime Start364
8.2　初识JNI365
8.2.1　JNI中的数据类型365
8.2.2　ScopedObjectAccess等辅助类367
8.2.3　常用JNI函数介绍369
8.3　Jit LoadCompilerLibrary373
8.4　Runtime InitNativeMethods374
8.4.1　JniConstants Init374
8.4.2　RegisterRuntimeNative Methods375
8.4.3　WellKnownClasses Init和LastInit376
8.5　Thread相关376
8.5.1　Runtime InitThreadGroups377
8.5.2　Thread FinishSetup377
8.5.3　Runtime StartDaemonThreads380
8.6　Runtime CreateSystemClassLoader381
8.7　类的加载、链接和初始化383
8.7.1　关键类介绍383
8.7.2　SetupClass392
8.7.3　LoadClass相关函数393
8.7.4　LinkClass相关函数398
8.7.5　DefineClass414
8.7.6　Verify相关函数416
8.7.7　Initialize相关函数424
8.7.8　ClassLinker中其他常用函数426
8.7.9　ClassLoader介绍437
8.8　虚拟机创建和启动关键内容梳理445
第9章　深入理解dex2oat447
9.1　概述448
9.2　ParseArgs介绍452
9.2.1　CompilerOptions类介绍453
9.2.2　ProcessOptions函数介绍454
9.2.3　InsertCompileOptions函数介绍455
9.3　OpenFile介绍456
9.4　Setup介绍458
9.4.1　Setup代码分析之一458
9.4.2　Setup代码分析之二464
9.4.3　Setup代码分析之三474
9.4.4　Setup代码分析之四484
9.5　CompileImage484
9.5.1　Compile485
9.5.2　ArtCompileDEX496
9.5.3　OptimizingCompiler JniCompile499
9.5.4　OptimizingCompiler Compile527
9.6　OAT和ART文件格式介绍544
9.6.1　OAT文件格式544
9.6.2　ART文件格式550
9.6.3　oatdump介绍554
9.7　总结561
第10章　解释执行和JIT562
10.1　基础知识564
10.1.1　LinkCode564
10.1.2　Runtime ArtMethod566
10.1.3　栈和参数传递572
10.2　解释执行580
10.2.1　art_quick_to_interpreter_bridge580
10.2.2　artQuickToInterpreter-Bridge582
10.2.3　EnterInterpreterFromEntry-Point584
10.2.4　调用栈的管理和遍历593
10.3　ART中的JIT599
10.3.1　Jit、JitCodeCache等600
10.3.2　JIT阈值控制与处理609
10.3.3　OSR的处理612
10.4　HDeoptimize的处理615
10.4.1　VisitDeoptimize相关616
10.4.2　QuickExceptionHandler相关618
10.4.3　解释执行中关于Deoptimize的处理621
10.5　Instrumentation介绍623
10.5.1　MethodEnterEvent和MethodExitEvent624
10.5.2　DexPcMovedEvent625
10.6　异常投递和处理625
10.6.1　抛异常626
10.6.2　异常处理629
10.7　总结635
第11章　ART中的JNI636
11.1　JavaVM和JNIEnv637
11.1.1　JavaVMExt相关介绍638
11.1.2　JNIEnvExt介绍642
11.2　Java native方法的调用644
11.2.1　art_jni_dlsym_lookup_stub644
11.2.2　art_quick_generic_jni_trampoline646
11.3　CallStaticVoidMethod651
11.4　JNI中引用型对象的管理653
11.4.1　关键类介绍653
11.4.2　JniMethodStart和JniMethod-End657
11.4.3　IndirectReferenceTable相关函数658
11.4.4　NewObject和jobject的含义660
11.4.5　JNI中引用对象相关662
11.4.6　PushLocalFrame和PopLocalFrame663
11.4.7　回收引用对象664
11.5　总结666
第12章　CheckPoints、线程同步及信号处理668
12.1　CheckPoints介绍669
12.1.1　设置Check Point标志位670
12.1.2　Check Points的设置672
12.1.3　执行检查点处的任务676
12.2　ThreadList和ThreadState681
12.2.1　线程ID683
12.2.2　RunCheckpoint和Dump684
12.2.3　SuspendAll和ResumeAll687
12.2.4　Thread状态切换690
12.3　线程同步相关知识691
12.3.1　关键类介绍692
12.3.2　synchronized的处理697
12.3.3　Object wait、notifyAll等705
12.4　volatile成员的读写707
12.4.1　基础知识707
12.4.2　解释执行模式下的处理711
12.4.3　机器码执行模式的处理712
12.5　信号处理714
12.5.1　zygote进程的处理714
12.5.2　非zygote进程的处理716
12.6　总结719
第13章　内存分配与释放720
13.1　Space等关键类介绍722
13.2　ZygoteSpace723
13.3　BumpPointerSpace和RegionSpace725
13.3.1　BumpPointerSpace726
13.3.2　RegionSpace733
13.4　DlMallocSpace和RosAlloc-Space740
13.4.1　DlMallocSpace741
13.4.2　RosAllocSpace745
13.4.3　rosalloc介绍748
13.5　LargeObjectMapSpace760
13.6　new-instance/array指令的处理762
13.6.1　设置内存分配器762
13.6.2　解释执行模式下的处理767
13.6.3　机器码执行模式下的处理770
13.6.4　Heap AllocObjectWith-Allocator773
13.7　细观Space779
13.7.1　Space类779
13.7.2　ContinuousSpace和Discon-tinuousSpace类781
13.7.3　MemMapSpace和Continuous MemMapAllocSpace类782
13.7.4　MallocSpace类783
13.8　Heap学习之二784
13.8.1　Heap构造函数784
13.8.2　关键类介绍792
13.8.3　ObjectVisitReferences806
13.9　总结812
第14章　ART中的GC813
14.1　GC基础知识814
14.1.1　Mark-Sweep Collection原理介绍815
14.1.2　Copying Collection原理介绍817
14.1.3　Mark-Compact Collection原理介绍818
14.1.4　其他概念819
14.2　Runtime VisitRoots819
14.2.1　关键数据结构821
14.2.2　Thread VisitRoots824
14.3　ART GC概览827
14.3.1　关键数据结构827
14.3.2　ART GC选项830
14.3.3　创建回收器和设置回收策略832
14.4　MarkSweep835
14.4.1　Heap相关成员变量取值情况835
14.4.2　MarkSweep概貌837
14.4.3　MarkingPhase840
14.4.4　PausePhase848
14.4.5　ReclaimPhase851
14.4.6　FinishPhase857
14.4.7　PartialMarkSweep857
14.4.8　StickyMarkSweep858
14.4.9　Concurrent MarkSweep864
14.4.10　Parallel GC868
14.4.11　MarkSweep小结869
14.5　ConcurrentCopying870
14.5.1　InitalizePhase871
14.5.2　FlipThreadRoots873
14.5.3　MarkingPhase881
14.5.4　ReclaimPhase883
14.5.5ConcurrentCopying小结885
14.6　MarkCompact885
14.6.1　MarkingPhase886
14.6.2　ReclaimPhase889
14.6.3　MarkCompact小结891
14.7　SemiSpace892
14.7.1　InitializePhase893
14.7.2　MarkingPhase894
14.7.3　SemiSpace小结898
14.8　Java Reference对象的处理899
14.8.1　基础知识899
14.8.2　MarkSweep中Reference对象的处理903
14.8.3ReferenceProcessor904
14.8.4　PhantomReference的处理912
14.8.5　finalize函数的调用913
14.8.6　Reference处理小结917
14.9　Heap学习之三917
14.9.1　Heap Trim917
14.9.2　CollectGarbageInternal919
14.9.3　PreZygoteFork924
14.9.4　内存碎片的解决926
14.10　总结927
14.11　参考资料928
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Android
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JavaScript DOM编程艺术 （第2版）
第1章 JavaScript简史	1
1.1 JavaScript的起源	1
1.2 DOM	2
1.3 浏览器战争	3
1.3.1 DHTML	3
1.3.2 浏览器之间的冲突	3
1.4 制定标准	4
1.4.1 浏览器以外的考虑	4
1.4.2 浏览器战争的结局	5
1.4.3 崭新的起点	5
1.5 小结	6
第2章 JavaScript语法	8
2.1 准备工作	8
2.2 语法	10
2.2.1 语句	10
2.2.2 注释	10
2.2.3 变量	11
2.2.4 数据类型	14
2.2.5 数组	16
2.2.6 对象	18
2.3 操作	19
2.4 条件语句	21
2.4.1 比较操作符	22
2.4.2 逻辑操作符	23
2.5 循环语句	24
2.5.1 while循环	24
2.5.2 for循环	25
2.6 函数	26
2.7 对象	29
2.7.1 内建对象	30
2.7.2 宿主对象	31
2.8 小结	31
第3章 DOM	32
3.1 文档：DOM中的“D”	32
3.2 对象：DOM中的“O”	32
3.3 模型：DOM中的“M”	33
3.4 节点	35
3.4.1 元素节点	35
3.4.2 文本节点	35
3.4.3 属性节点	36
3.4.4 CSS	36
3.4.5 获取元素	38
3.4.6 盘点知识点	42
3.5 获取和设置属性	43
3.5.1 getAttribute	43
3.5.2 setAttribute	44
3.6 小结	45
第4章 案例研究：JavaScript图片库	46
4.1 标记	46
4.2 JavaScript	48
4.2.1 非DOM解决方案	49
4.2.2 最终的函数代码清单	50
4.3 应用这个JavaScript函数	50
4.4 对这个函数进行扩展	52
4.4.1 childNodes属性	53
4.4.2 nodeType属性	54
4.4.3 在标记里增加一段描述	54
4.4.4 用JavaScript改变这段描述	55
4.4.5 nodeValue属性	56
4.4.6 firstChild和lastChild属性	56
4.4.7 利用nodeValue属性刷新这段描述	57
4.5 小结	60
第5章 最佳实践	61
5.1 过去的错误	61
5.1.1 不要怪罪JavaScript	61
5.1.2 Flash的遭遇	62
5.1.3 质疑一切	63
5.2 平稳退化	63
5.2.1 “javascript:”伪协议	64
5.2.2 内嵌的事件处理函数	65
5.2.3 谁关心这个	65
5.3 向CSS学习	66
5.3.1 结构与样式的分离	66
5.3.2 渐进增强	67
5.4 分离JavaScript	68
5.5 向后兼容	70
5.5.1 对象检测	70
5.5.2 浏览器嗅探技术	71
5.6 性能考虑	72
5.6.1 尽量少访问DOM和尽量减少标记	72
5.6.2 合并和放置脚本	73
5.6.3 压缩脚本	73
5.7 小结	74
第6章 案例研究：图片库改进版	75
6.1 快速回顾	75
6.2 它支持平稳退化吗	76
6.3 它的JavaScript与HTML标记是分离的吗	77
6.3.1 添加事件处理函数	77
6.3.2 共享onload事件	82
6.4 不要做太多的假设	84
6.5 优化	86
6.6 键盘访问	88
6.7 把JavaScript与CSS结合起来	90
6.8 DOM Core和HTML-DOM	93
6.9 小结	94
第7章 动态创建标记	96
7.1 一些传统方法	96
7.1.1 document.write	96
7.1.2 innerHTML属性	98
7.2 DOM方法	101
7.2.1 createElement方法	101
7.2.2 appendChild方法	102
7.2.3 createTextNode方法	103
7.2.4 一个更复杂的组合	105
7.3 重回图片库	107
7.3.1 在已有元素前插入一个新元素	108
7.3.2 在现有方法后插入一个新元素	109
7.3.3 图片库二次改进版	111
7.4 Ajax	114
7.4.1 XMLHttpRequest对象	115
7.4.2 渐进增强与Ajax	119
7.4.3 Hijax	120
7.5 小结	121
第8章 充实文档的内容	122
8.1 不应该做什么	122
8.2 把“不可见”变成“可见”	123
8.3 内容	123
8.3.1 选用HTML、XHTML还是HTML5	124
8.3.2 CSS	126
8.3.3 JavaScript	127
8.4 显示“缩略语列表”	127
8.4.1 编写displayAbbreviations函数	128
8.4.2 创建标记	130
8.4.3 一个浏览器“地雷”	135
8.5 显示“文献来源链接表”	138
8.6 显示“快捷键清单”	143
8.7 检索和添加信息	146
8.8 小结	147
第9章 CSS-DOM	148
9.1 三位一体的网页	148
9.1.1 结构层	148
9.1.2 表示层	148
9.1.3 行为层	149
9.1.4 分离	150
9.2 style属性	150
9.2.1 获取样式	151
9.2.2 设置样式	156
9.3 何时该用DOM脚本设置样式	158
9.3.1 根据元素在节点树里的位置来设置样式	158
9.3.2 根据某种条件反复设置某种样式	161
9.3.3 响应事件	165
9.4 className属性	167
9.5 小结	171
第10章 用JavaScript实现动画效果	172
10.1 动画基础知识	172
10.1.1 位置	172
10.1.2 时间	175
10.1.3 时间递增量	175
10.1.4 抽象	178
10.2 实用的动画	184
10.2.1 提出问题	184
10.2.2 解决问题	186
10.2.3 CSS	187
10.2.4 JavaScript	189
10.2.5 变量作用域问题	192
10.2.6 改进动画效果	193
10.2.7 添加安全检查	196
10.2.8 生成HTML标记	198
10.3 小结	200
第11章 HTML5	201
11.1 HTML5简介	201
11.2 来自朋友的忠告	203
11.3 几个示例	204
11.3.1 Canvas	205
11.3.2 音频和视频	209
11.3.3 表单	215
11.4 HTML5还有其他特性吗	219
11.5 小结	219
第12章 综合示例	220
12.1 项目简介	220
12.1.1 原始资料	220
12.1.2 站点结构	220
12.1.3 页面结构	221
12.2 设计	222
12.3 CSS	223
12.3.1 颜色	225
12.3.2 布局	226
12.3.3 版式	228
12.4 标记	229
12.5 JavaScript	230
12.5.1 页面突出显示	231
12.5.2 JavaScript幻灯片	235
12.5.3 内部导航	239
12.5.4 JavaScript图片库	242
12.5.5 增强表格	245
12.5.6 增强表单	249
12.5.7 压缩代码	263
12.6 小结	264
附录 JavaScript库	265
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JavaScript DOM编程艺术 （第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring技术内幕（第2版）
前言
第1章　spring的设计理念和整体架构 / 1
1.1　spring的各个子项目 / 2
1.2　spring的设计目标 / 5
1.3　spring的整体架构 / 7
1.4　spring的应用场景 / 10
1.5　小结 / 12
第一部分　spring核心实现篇
第2章　spring framework的核心：ioc容器的实现 / 16
2.1　spring ioc容器概述 / 17
2.1.1　ioc容器和依赖反转模式 / 17
2.1.2　spring ioc的应用场景 / 18
2.2　ioc容器系列的设计与实现：beanfactory和applicationcontext / 19
2.2.1　spring的ioc容器系列 / 19
2.2.2　spring ioc容器的设计 / 21
2.3　ic容器的初始化过程 / 28
2.3.1　beandefinition的resource定位 / 29
2.3.2　beandefinition的载入和解析 / 37
2.3.3　beandefinition在ioc容器中的注册 / 52
.2.4　ioc容器的依赖注入 / 54
2.5　容器其他相关特性的设计与实现 / 75
2.5.1　applicationcontext和bean的初始化及销毁 / 75
2.5.2　lazy-init属性和预实例化 / 81
2.5.3　factorybean的实现 / 82
2.5.4　beanpostprocessor的实现 / 85
2.5.5　autowiring（自动依赖装配）的实现 / 88
2.5.6　bean的依赖检查 / 90
2.5.7　bean对ioc容器的感知 / 91
2.6　小结 / 92
第3章　spring aop的实现 / 94
3.1　spring aop概述 / 95
3.1.1　aop概念回顾 / 95
3.1.2　advice通知 / 98
3.1.3　pointcut切点 / 102
3.1.4　advisor通知器 / 105
3.2　spring aop的设计与实现 / 106
3.2.1　jvm的动态代理特性 / 106
3.2.2　spring aop的设计分析 / 108
3.2.3　spring aop的应用场景 / 108
3.3　建立aopproxy代理对象 / 109
3.3.1　设计原理 / 109
3.3.2　配置proxyfactorybean / 110
3.3.3　proxyfactorybean生成aopproxy代理对象 / 111
3.3.4　jdk生成aopproxy代理对象 / 116
3.3.5　cglib生成aopproxy代理对象 / 117
3.4　spring aop拦截器调用的实现 / 119
3.4.1　设计原理 / 119
3.4.2　jdkdynamicaopproxy的invoke拦截 / 120
3.4.3　cglib2aopproxy的intercept拦截 / 121
3.4.4　目标对象方法的调用 / 122
3.4.5　aop拦截器链的调用 / 123
3.4.6　配置通知器 / 124
3.4.7　advice通知的实现 / 129
3.4.8　proxyfactory实现aop / 136
3.5　spring aop的高级特性 / 138
3.6　小结 / 140
第二部分　spring组件实现篇
第4章　spring mvc与web环境 / 145
4.1　spring mvc概述 / 146
4.2　web环境中的spring mvc / 148
4.3　上下文在web容器中的启动 / 149
4.3.1　ioc容器启动的基本过程 / 149
4.3.2　web容器中的上下文设计 / 151
4.3.3　contextloader的设计与实现 / 154
4.4　spring mvc的设计与实现 / 158
4.4.1　spring mvc的应用场景 / 158
4.4.2　spring mvc设计概览 / 158
4.4.3　dispatcherservlet的启动和初始化 / 160
4.4.4　mvc处理http分发请求 / 166
4.5　spring mvc视图的呈现 / 178
4.5.1　dispatcherservlet视图呈现的设计 / 178
4.5.2　jsp视图的实现 / 182
4.5.3　excelview的实现 / 185
4.5.4　pdf视图的实现 / 187
4.6　小结 / 189
第5章　数据库操作组件的实现 / 191
5.1　spring jdbc的设计与实现 / 192
5.1.1　应用场景 / 192
5.1.2　设计概要 / 192
5.2　spring jdbc中模板类的设计与实现 / 193
5.2.1　设计原理 / 193
5.2.2　jdbctemplate的基本使用 / 193
5.2.3　jdbctemplate的execute实现 / 194
5.2.4　jdbctemplate的query实现 / 196
5.2.5　使用数据库connection / 197
5.3　spring jdbc中rdbms操作对象的实现 / 199
5.3.1　sqlquery的实现 / 200
5.3.2　sqlupdate的实现 / 204
5.3.3　sqlfunction / 206
5.4　spring orm的设计与实现 / 208
5.4.1　应用场景 / 208
5.4.2　设计概要 / 208
5.5　spring驱动hibernate的设计与实现 / 209
5.5.1　设计原理 / 210
5.5.2　hibernate的sessionfactory / 210
5.5.3　hibernatetemplate的实现 / 215
5.5.4　session的管理 / 219
5.6　spring驱动ibatis的设计与实现 / 222
5.6.1　设计原理 / 222
5.6.2　创建sqlmapclient / 222
5.6.3　sqlmapclienttemplate的实现 / 224
5.7　小结 / 227
第6章　spring事务处理的实现 / 228
6.1　spring与事务处理 / 229
6.2　spring事务处理的设计概览 / 229
6.3　spring事务处理的应用场景 / 230
6.4　spring声明式事务处理 / 231
6.4.1　设计原理与基本过程 / 231
6.4.2　实现分析 / 231
6.5　spring事务处理的设计与实现 / 241
6.5.1　spring事务处理的编程式使用 / 241
6.5.2　事务的创建 / 242
6.5.3　事务的挂起 / 249
6.5.4　事务的提交 / 251
6.5.5　事务的回滚 / 253
6.6　spring事务处理器的设计与实现 / 255
6.6.1　spring事务处理的应用场景 / 255
6.6.2　datasourcetransactionmanager的实现 / 256
6.6.3　hibernatetransactionmanager的实现 / 259
6.7　小结 / 265
第7章　spring远端调用的实现 / 267
7.1　spring远端调用的应用场景 / 268
7.2　spring远端调用的设计概览 / 268
7.3　spring远端调用的实现 / 271
7.3.1　spring http调用器的实现 / 271
7.3.2　spring hession/burlap的实现原理 / 282
7.3.3　spring rmi的实现 / 295
7.4　小结 / 302
第三部分　spring应用实现篇
第8章　安全框架acegi的设计与实现 / 307
8.1　spring acegi安全框架概述 / 308
8.1.1　概述 / 308
8.1.2　设计原理与基本实现过程 / 308
8.1.3　acegi的bean配置 / 309
8.2　配置spring acegi / 310
8.3　acegi的web过滤器实现 / 313
8.4　acegi验证器的实现 / 315
8.4.1　authenticationmanager的authenticate / 315
8.4.2　daoauthenticationprovider的实现 / 318
8.4.3　读取数据库用户信息 / 320
8.4.4　完成用户信息的对比验证 / 323
8.5　acegi授权器的实现 / 324
8.5.1　与web环境的接口filtersecurityinterceptor / 324
8.5.2　授权器的实现 / 327
8.5.3　投票器的实现 / 329
8.6　小结 / 330
第9章　spring dm模块的设计与实现 / 332
9.1　spring dm模块的应用场景 / 333
9.2　spring dm的应用过程 / 334
9.3　spring dm设计与实现 / 338
9.4　小结 / 348
第10章　spring flex的设计与实现 / 350
10.1　spring flex模块的应用场景 / 351
10.2　spring flex的应用过程 / 353
10.3　spring flex的设计与实现 / 355
10.4　小结 / 362
附录a　spring项目的源代码环境 / 363
附录b　构建spring项目的发布包 / 378
附录c　使用spring ide / 381
附录d　spring pet clinic应用实例 / 385
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring技术内幕（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计实验与习题解答
第1部分 程序设计实验.实验1 Java文件的编写、编译与运行   1.1 实验目的   1.2 实验任务   1.3 实验内容   1.3.1 实验准备   1.3.2 实验题 实验2 Java语言基础   2.1 实验目的   2.2 实验任务   2.3 实验内容   2.3.1 实验题 实验3 Java的面向对象特性   3.1 实验目的   3.2 实验任务   3.3 实验内容   3.3.1 实验题 实验4 Java的图形用户界面设计与事件处理   4.1 实验目的   4.2 实验任务  4.3 实验内容    4.3.1 复选框与单选按钮    4.3.2 选择控件Choice    4.3.3 如何使控件排列整齐    4.3.4 关于输入密码    4.3.5 实验题实验5 Java的布局管理器  5.1 实验目的  5.2 实验任务  5.3 实验内容    5.3.1 卡片布局管理器    5.3.2 实验题实验6 Java的Applet  6.1 实验目的  6.2 实验任务  6.3 实验内容    6.3.1 文字颜色的设置    6.3.2 实验题实验7 图形GUI设计  7.1 实验目的  7.2 实验任务  7.3 实验内容    7.3.1 图像的放大与缩小    7.3.2 实现文字动画的若干问题    7.3.3 实验题实验8 Java数据流与数据传输  8.1 实验目的  8.2 实验任务  8.3 实验内容    8.3.1 实验题实验9 多线程  9.1 实验目的  9.2 实验任务  9.3 实验内容    9.3.1 两个参考程序    9.3.2 计时时钟设计中的若干问题    9.3.3 实验题实验10 JDBC与数据库  10.1 实验目的  10.2 实验任务  10.3 实验内容    10.3.1 关于字符串相加    10.3.2 实验题      第2部分  习题解答第1章习题第1章习题解答第2章习题第2章习题解答第3章习题第3章习题解答第4章习题第4章习题解答第5章习题第5章习题解答第6章习题第6章习题解答第7章习题第7章习题解答第8章习题第8章习题解答第9章习题第9章习题解答第10章习题第10章习题解答第11章习题第11章习题解答第12章习题第12章习题解答附录  Edit编辑器的使用与批处理文件参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计实验与习题解答
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言计算机科学与程序设计
第一章 计算机及Java简介
第二章 原型、字符串与交互式I/O
第三章 控制流
第四章 定义类与方法
第五章 关于对象与方法的更多知识
第六章 数组
第七章 继承
第八章 异常处理
第九章 流与文件I/O
第十章 动态数据结构
第十一章 递归
第十二章 递归窗口界面――Swing
第十三章 Applet和HTML
第十四章 更多的Swing
附录1 关键字
附录2 优先规则
附录3 Unicode字符集
附录4 SavitchIn
附录5 Protected和Package修饰语
附录6 十进制格式化类
附录7 迭代器接口
附录8 复制
附录9 Javadoc
附录10 JOptionPane类
附录11 C++与Java之间的区别
词汇表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言计算机科学与程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 安全手册
一，安全性基础
二，Java安全概述
三，Java应用程序安全访问控制
四，小程序安全性
五，加密简介
六，密钥管理与数字证书
七，消息摘要与数字签名
八，Java加密扩展
九，SSL与JSSE
十，分布式企业安全概述
十一，数据库与数据库安全
十二，Java验证与授权服务
十三，CORBA安全性
十四，企业JavaBe

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 安全手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 2编程起步
第1章　Java基础
1. 1　Java的起源
1. 1. 1　Java与C和C十十的联系
1. 2　Java对于Internet的贡献
1, 2. 1　Java　applet和应用程序
1. 2

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 2编程起步
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序员面试笔试真题库
前言
面试笔试经验技巧篇
经验技巧1 如何巧妙地回答面试官的问题？2
经验技巧2 如何回答技术性的问题？3
经验技巧3 如何回答非技术性问题？5
经验技巧4 如何回答快速估算类问题？5
经验技巧5 如何回答算法设计问题？6
经验技巧6 如何回答系统设计题？9
经验技巧7 如何解决求职中的时间冲突问题？11
经验技巧8 如果面试问题曾经遇见过，是否要告知面试官？12
经验技巧9 在被企业拒绝后是否可以再申请？13
经验技巧10 如何应对自己不会回答的问题？13
经验技巧11 如何应对面试官的“激将法”语言？14
经验技巧12 如何处理与面试官持不同观点这个问题？15
经验技巧13 什么是职场暗语？15
真 题 篇
真题1 某知名互联网下载服务提供商软件工程师笔试题21
真题2 某知名社交平台软件工程师笔试题22
真题3 某知名安全软件服务提供商软件工程师笔试题27
真题4 某知名互联网金融企业软件工程师笔试题29
真题5 某知名搜索引擎提供商软件工程师笔试题33
真题6 某初创公司软件工程师笔试题41
真题7 某知名游戏软件开发公司软件工程师笔试题44
真题8 某知名电子商务公司软件工程师笔试题48
真题9 某顶级生活消费类网站软件工程师笔试题50
真题10 某知名门户网站软件工程师笔试题51
真题11 某知名互联网金融企业软件工程师笔试题58
真题12 国内某知名网络设备提供商软件工程师笔试题68
真题13 国内某顶级手机制造商软件工程师笔试题71
真题14 某顶级大数据综合服务提供商软件工程师笔试题74
真题15 某著名社交类上市公司软件工程师笔试题77
真题16 某知名互联网公司软件工程师笔试题78
真题17 某知名网络安全公司校园招聘技术类笔试题83
真题18 某知名互联网游戏公司校园招聘运维开发岗笔试题88
真题详解篇
真题详解1 某知名互联网下载服务提供商软件工程师笔试题93
真题详解2 某知名社交平台软件工程师笔试题103
真题详解3 某知名安全软件服务提供商软件工程师笔试题128
真题详解4 某知名互联网金融企业软件工程师笔试题142
真题详解5 某知名搜索引擎提供商软件工程师笔试题156
真题详解6 某初创公司软件工程师笔试题197
真题详解7 某知名游戏软件开发公司软件工程师笔试题206
真题详解8 某知名电子商务公司软件工程师笔试题229
真题详解9 某顶级生活消费类网站软件工程师笔试题250
真题详解10 某知名门户网站软件工程师笔试题260
真题详解11 某知名互联网金融企业软件工程师笔试题272
真题详解12 国内某知名网络设备提供商软件工程师笔试题289
真题详解13 国内某顶级手机制造商软件工程师笔试题292
真题详解14 某顶级大数据综合服务提供商软件工程师笔试题299
真题详解15 某著名社交类上市公司软件工程师笔试题310
真题详解16 某知名互联网公司软件工程师笔试题317
真题详解17 某知名网络安全公司校园招聘技术类笔试题319
真题详解18 某知名互联网游戏公司校园招聘运维开发岗笔试题337
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序员面试笔试真题库
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java ７从入门到精通
目 录
第1 篇 Java 基础篇
第1 章 Java平台及开发环境的搭建························································································ 2
1.1 Windows 下Java 开发环境的配置···························································································· 2
1.1.1 相关软件介绍································································································································ 2
1.1.2 应用平台········································································································································ 3
1.1.3 解析JDK 结构······························································································································ 4
1.2 Eclipse安装和使用····················································································································· 4
1.2.1 Eclipse 的下载和安装··················································································································· 4
1.2.2 MyEclipse 下载和安装················································································································· 5
1.3 JBuilder 集成开发环境介绍······································································································· 5
1.4 NetBeans 集成开发环境介绍····································································································· 6
1.5 本章小结····································································································································· 6
第2 章 理解Java语言············································································································· 7
2.1 Java 的发展历程························································································································· 7
2.1.1 Java 的现状···································································································································· 7
2.1.2 Java 语言的应用领域···················································································································· 8
2.1.3 Java 编程语言的主要目标············································································································ 8
2.1.4 Java JVM 虚拟机··························································································································· 8
2.1.5 垃圾收集机制································································································································ 9
2.1.6 Coin项目······································································································································· 9
2.2 Java 语言的特性······················································································································· 10
2.3 Java 中的面向对象编程··········································································································· 12
2.3.1 对象的定义及操作······················································································································ 12
2.3.2 抽象·············································································································································· 13
2.3.3 如何定义对象类·························································································································· 13
2.3.4 类和对象的关系·························································································································· 14
2.3.5 对象操作······································································································································ 14
2.3.6 封装·············································································································································· 15
2.3.7 继承与子类·································································································································· 15
2.3.8 多态·············································································································································· 16
2.3.9 模板/泛型（template/generic）·································································································· 17
2.3.10 注解············································································································································ 17
2.4 Java 程序结构··························································································································· 18
2.4.1 学习Java 应用程序的编写········································································································· 18
2.4.2 解析FirstHelloWorldApp.java···································································································· 18
2.4.3 编译并运行FirstHelloWorldApp ······························································································· 18
2.4.4 使用package 管理类··················································································································· 20
2.4.5 包的引用······································································································································ 21
2.4.6 目录布局及CLASSPATH环境变量························································································· 21
2.4.7 编译查错······································································································································ 22
2.4.8 从JDK到IDE····························································································································· 23
2.5 Java 与C/C++、C#的比较······································································································· 28
2.5.1 全局变量······································································································································ 28
2.5.2 goto··············································································································································· 29
2.5.3 指针·············································································································································· 29
2.5.4 内存管理······································································································································ 30
2.5.5 数据类型的支持·························································································································· 31
2.5.6 类型转换······································································································································ 31
2.5.7 头文件·········································································································································· 31
2.5.8 结构和联合·································································································································· 32
2.5.9 预处理·········································································································································· 32
2.6 本章考试、面试问题分析······································································································· 32
2.7 实验：Java运行环境的安装、配置与运行··········································································· 33
2.8 问题集锦与解答······················································································································· 36
2.9 自我检测··································································································································· 37
2.10 本章小结································································································································· 37
第3 章 Java标识符、关键字和类型······················································································ 38
3.1 Java 基本语法··························································································································· 38
3.1.1 程序注释······································································································································ 38
3.1.2 分号、块和空白块······················································································································ 40
3.1.3 标识符·········································································································································· 40
3.1.4 Java 关键字·································································································································· 41
3.1.5 Java 编码约定······························································································································ 42
3.2 数据类型··································································································································· 43
3.2.1 简单数据类型······························································································································ 43
3.2.2 复合数据类型······························································································································ 44
3.2.3 常量与变量·································································································································· 44
3.2.4 整型数据······································································································································ 45
3.2.5 浮点型（实型）数据·················································································································· 45
3.2.6 字符型数据·································································································································· 46
3.2.7 布尔型数据·································································································································· 47
3.2.8 枚举类型······································································································································ 48
3.3 二进制字面值··························································································································· 49
3.4 在数值字面量中使用下划线··································································································· 50
3.5 本章程序设计案例··················································································································· 50
3.6 本章考试、面试问题分析······································································································· 51
3.7 实验：Java标识符、关键字和类型练习··············································································· 52
3.8 问题集锦与解答······················································································································· 53
3.9 自我检测··································································································································· 53
3.10 本章小结································································································································· 54
第4 章 表达式和流控制·········································································································· 55
4.1 变量··········································································································································· 55
4.1.1 变量的声明和作用域·················································································································· 55
4.1.2 变量初始化·································································································································· 56
4.2 运算符······································································································································· 57
4.3 算术运算··································································································································· 58
4.3.1 二元算术运算符·························································································································· 58
4.3.2 一元算术运算符·························································································································· 58
4.3.3 整数计算······································································································································ 59
4.3.4 整数除法和余数·························································································································· 59
4.3.5 其他算术运算······························································································································ 59
4.3.6 混合运算自动类型转换·············································································································· 60
4.3.7 混合运算强制类型转换·············································································································· 61
4.4 逻辑关系运算··························································································································· 61
4.4.1 关系运算符·································································································································· 61
4.4.2 布尔逻辑运算符·························································································································· 62
4.5 位运算······································································································································· 63
4.5.1 位运算符······································································································································ 63
4.5.2 位移运算······································································································································ 63
4.5.3 位逻辑运算符······························································································································ 64
4.6 顺序结构··································································································································· 64
4.7 分支结构··································································································································· 65
4.7.1 条件语句if-else··························································································································· 65
4.7.2 多分支语句switch ······················································································································ 65
4.7.3 Java 7 的switch 分支语句········································································································ 67
4.8 循环结构··································································································································· 68
4.8.1 while 循环语句··························································································································· 68
4.8.2 do-while 循环语句······················································································································ 68
4.8.3 for 语句········································································································································ 69
4.9 控制循环结构··························································································································· 69
4.9.1 return 语句··································································································································· 69
4.9.2 continue语句······························································································································· 70
4.9.3 break 语句···································································································································· 70
4.9.4 带标签的break···························································································································· 72
4.9.5 带标签的continue ······················································································································· 72
4.9.6 各种控制语句在实际编程中的应用·························································································· 73
4.10 本章程序设计案例················································································································· 75
4.11 本章考试、面试问题分析····································································································· 76
4.12 实验：Java表达式和流控制练习························································································· 77
4.13 自我检测································································································································· 79
4.14 本章小结································································································································· 80
第5 章 数组和字符串············································································································· 81
5.1 一维数组··································································································································· 81
5.1.1 一维数组的定义·························································································································· 81
5.1.2 一维数组元素的引用·················································································································· 82
5.1.3 一维数组的初始化······················································································································ 83
5.1.4 一维数组在实际编程中的应用方法·························································································· 83
5.2 多维数组··································································································································· 84
5.2.1 二维数组的定义·························································································································· 84
5.2.2 二维数组元素的引用·················································································································· 84
5.2.3 二维数组的初始化······················································································································ 84
5.2.4 二维数组在实际编程中的应用·································································································· 85
5.2.5 复制数组······································································································································ 86
5.3 字符串······································································································································· 86
5.3.1 字符串字面量······························································································································ 86
5.3.2 String 对象的创建······················································································································· 87
5.4 字符串操作······························································································································· 87
5.4.1 字符串基本方法·························································································································· 87
5.4.2 字符串的比较······························································································································ 88
5.4.3 从字符串中提取子串·················································································································· 88
5.5 可变字符串······························································································································· 89
5.5.1 创建StringBuffer 对象················································································································ 89
5.5.2 使用StringBuffer 对象················································································································ 90
5.5.3 删除StringBuffer 对象················································································································ 90
5.5.4 StringBuffer 对象的容量············································································································· 91
5.6 本章考试、面试问题分析······································································································· 91
5.7 实验数组和字符串··················································································································· 92
5.8 问题集锦与解答······················································································································· 94
5.9 自我检测··································································································································· 95
5.10 本章小结································································································································· 95
第6 章 类、对象、包和接口·································································································· 96
6.1 类··············································································································································· 96
6.1.1 类的声明······································································································································ 96
6.1.2 类体·············································································································································· 97
6.2 定义方法··································································································································· 97
6.2.1 方法的返回值······························································································································ 98
6.2.2 方法的参数列表·························································································································· 98
6.3 构造方法··································································································································· 99
6.3.1 构造方法······································································································································ 99
6.3.2 默认构造方法······························································································································ 99
6.4 类成员·····································································································································100
6.4.1 成员变量···································································································································· 100
6.4.2 显式成员初始化························································································································ 101
6.4.3 单根（Singleton）类················································································································ 101
6.5 方法重载·································································································································102
6.5.1 多个构造方法···························································································································· 102
6.5.2 调用重载构造方法···················································································································· 102
6.6 对象·········································································································································103
6.6.1 对象生成···································································································································· 103
6.6.2 对象的使用································································································································ 103
6.6.3 构造函数的特点························································································································ 105
6.7 继承·········································································································································106
6.7.1 继承的概念································································································································ 106
6.7.2 继承定义···································································································································· 106
6.7.3 扩展类········································································································································ 107
6.7.4 属性继承与隐藏························································································································ 109
6.7.5 方法继承、覆盖与重载············································································································ 109
6.7.6 在子类中使用构造方法············································································································ 110
6.7.7 @Override 标记························································································································· 110
6.8 多态与动态绑定·····················································································································111
6.8.1 多态············································································································································ 111
6.8.2 动态绑定···································································································································· 112
6.8.3 父类对象与子类对象的使用与转化························································································ 112
6.8.4 Instanceof 运算符······················································································································ 113
6.8.5 多态性在实际编程中的应用···································································································· 113
6.8.6 泛型············································································································································ 114
6.8.7 Java 7 泛型的“菱形”语法····································································································· 116
6.8.8 构造方法的继承与重载············································································································ 117
6.8.9 参数可变的方法························································································································ 118
6.8.10 Java 7 优化变长参数的方法调用··························································································· 120
6.9 抽象类与抽象方法·················································································································120
6.9.1 抽象类········································································································································ 120
6.9.2 抽象方法···································································································································· 121
6.9.3 访问控制符································································································································ 122
6.10 包···········································································································································123
6.10.1 包的作用·································································································································· 123
6.10.2 包的创建·································································································································· 123
6.10.3 包的引用·································································································································· 123
6.10.4 向包中添加类·························································································································· 124
6.10.5 包的作用域······························································································································ 124
6.10.6 静态引用·································································································································· 124
6.11 接口·······································································································································125
6.11.1 接口概念·································································································································· 126
6.11.2 接口声明·································································································································· 126
6.11.3 接口的实现······························································································································ 127
6.12 静态变量······························································································································· 129
6.12.1 类（static）变量····················································································································· 129
6.12.2 类（static）方法····················································································································· 129
6.13 关键字final ···························································································································130
6.13.1 final 类····································································································································· 130
6.13.2 final 方法································································································································· 130
6.13.3 final 变量································································································································· 131
6.14 内部类···································································································································131
6.14.1 内部类定义······························································································································ 131
6.14.2 内部类属性······························································································································ 132
6.15 包装类···································································································································132
6.16 反射API································································································································133
6.16.1 反射API 特征························································································································· 133
6.16.2 反射机制应用实例·················································································································· 134
6.17 本章考试、面试问题分析···································································································135
6.18 实验：面向对象编程练习···································································································137
6.19 问题集锦与解答···················································································································140
6.20 自我检测······························································································································· 140
6.21 本章小结······························································································································· 141
第2 篇 Java 标准类包篇
第7 章 Java集合与工具类··································································································· 143
7.1 Java 集合·································································································································143
7.1.1 Java 语言的util类···················································································································· 143
7.1.2 Collection 接口·························································································································· 143
7.1.3 Collection 的功能方法·············································································································· 144
7.2 List 集合··································································································································145
7.2.1 LinkedList类····························································································································· 145
7.2.2 ArrayList 类······························································································································· 147
7.2.3 Vector 类···································································································································· 148
7.2.4 Stack 类····································································································································· 148
7.3 Set 集合···································································································································149
7.3.1 HashSet 类································································································································· 151
7.3.2 TreeSet 类·································································································································· 152
7.3.3 LinkedHashSet 类······················································································································ 152
7.3.4 EnumSet类································································································································ 153
7.4 Map 接口·································································································································154
7.4.1 Hashtable 类······························································································································· 155
7.4.2 HashMap 类······························································································································· 155
7.4.3 WeakHashMap 类······················································································································ 156
7.4.4 EnumMap 类······························································································································ 157
7.4.5 IdentityHashMap 类··················································································································· 157
7.5 Queue 集合······························································································································158
7.5.1 PriorityQueue 实现类················································································································ 159
7.5.2 LinkedList实现类····················································································································· 159
7.5.3 Deque 接口与ArrayDeque 实现类··························································································· 160
7.6 日期操作·································································································································162
7.6.1 Date 类······································································································································· 162
7.6.2 Calendar 类································································································································ 162
7.6.3 SimpleDateFormat 类················································································································ 163
7.7 Arrays 类··································································································································164
7.7.1 数组排序···································································································································· 164
7.7.2 数组填充···································································································································· 165
7.7.3 数组比较···································································································································· 165
7.7.4 数组复制···································································································································· 166
7.8 java.lang.Math 类和java.math 包···························································································167
7.8.1 java.lang.Math 类······················································································································· 167
7.8.2 java.math 包······························································································································· 167
7.9 Java Annotation ·······················································································································168
7.9.1 Java 注释···································································································································· 168
7.9.2 @Override 注释························································································································· 168
7.9.3 @Deprecated 注释····················································································································· 169
7.9.4 @SuppressWarnings 注释········································································································· 169
7.9.5 自定义注释································································································································ 170
7.10 常用类···································································································································171
7.10.1 Object 类·································································································································· 171
7.10.2 Java 7 新增的Objects 类········································································································ 171
7.10.3 Java 7 的ThreadLocalRandom 与Random ············································································ 172
7.10.4 BigDecimal ······························································································································ 172
7.10.5 使用Scanner 获取键盘输入··································································································· 173
7.10.6 使用BufferedReader 获取键盘输入······················································································ 174
7.10.7 System类································································································································· 174
7.10.8 Runtime类······························································································································· 176
7.11 本章考试、面试问题分析···································································································177
7.12 实验：集合类的使用···········································································································178
7.13 自我检测······························································································································· 180
7.14 本章小结······························································································································· 182
第8 章 异常处理·················································································································· 183
8.1 异常处理·································································································································183
8.1.1 异常的类型································································································································ 184
8.1.2 不捕捉异常································································································································ 184
8.2 异常处理机制·························································································································184
8.2.1 使用try-catch 捕获异常············································································································ 184
8.2.2 多个catch 子句························································································································· 185
8.2.3 try 语句的嵌套·························································································································· 186
8.2.4 Java 7 提供的多异常捕获········································································································· 186
8.2.5 Java 7 自动关闭资源的try 语句······························································································ 187
8.2.6 使用finally 回收资源··············································································································· 188
8.3 使用throw 抛出异常··············································································································189
8.3.1 throw 语句································································································································· 189
8.3.2 throws语句································································································································ 189
8.3.3 Java 7 增强的throw 语句········································································································· 190
8.4 异常分类·································································································································191
8.5 自定义异常·····························································································································192
8.6 本章考试、面试问题分析·····································································································193
8.7 实验：异常处理·····················································································································194
8.8 问题集锦与解答·····················································································································195
8.9 自我检测·································································································································195
8.10 本章小结······························································································································· 196
第9 章 多线程······················································································································ 197
9.1 多线程的概念·························································································································197
9.2 线程的创建和启动·················································································································198
9.2.1 继承Thread 类创建线程类······································································································ 198
9.2.2 实现Runnable接口创建线程类······························································································ 199
9.2.3 使用Callable 和Future 创建线程···························································································· 200
9.3 线程调度·································································································································201
9.4 线程的同步·····························································································································202
9.5 线程的基本控制·····················································································································203
9.5.1 显式定义线程···························································································································· 203
9.5.2 多线程例子································································································································ 204
9.5.3 启动一个线程···························································································································· 204
9.5.4 操作线程···································································································································· 205
9.5.5 暂停一个线程···························································································································· 205
9.5.6 停止一个线程···························································································································· 205
9.5.7 常用线程API ···························································································································· 205
9.6 线程池·····································································································································206
9.6.1 Java 5 实现的线程池················································································································· 206
9.6.2 Java 7 新增的ForkJoinPool ······································································································ 208
9.7 ThreadLocal 类························································································································210
9.8 本章考试、面试问题分析·····································································································212
9.9 实验：多线程·························································································································213
9.10 问题集锦与解答···················································································································214
9.11 本章小结······························································································································· 215
第10 章 输入/输出··············································································································· 216
10.1 Java 输入/输出流··················································································································216
10.1.1 概述·········································································································································· 216
10.1.2 标准输入/输出例子················································································································· 216
10.2 字节流和字符流···················································································································217
10.2.1 InputStream 和Reader············································································································· 217
10.2.2 OutputStream 和Writer··········································································································· 218
10.2.3 缓冲输入文件·························································································································· 222
10.2.4 格式化的内存输入·················································································································· 223
10.3 文件操作类···························································································································223
10.3.1 创建一个新的文件对象·········································································································· 224
10.3.2 在实际编程中读写文件·········································································································· 225
10.3.3 RandomAccessFile 类·············································································································· 229
10.3.4 Java 的文件管理······················································································································ 233
10.4 对象序列化···························································································································235
10.4.1 序列化的含义和意义·············································································································· 235
10.4.2 使用对象流实现序列化·········································································································· 236
10.4.3 对象引用的序列化·················································································································· 238
10.5 用Zip 进行多文件保存········································································································239
10.6 NIO ········································································································································241
10.6.1 使用Buffer ······························································································································ 242
10.6.2 使用Channel ··························································································································· 243
10.6.3 字符集和Charset····················································································································· 244
10.6.4 文件锁······································································································································ 245
10.7 Java 7 的NIO2 ······················································································································247
10.7.1 文件及路径操作API ·············································································································· 248
10.7.2 使用FileVisitor 遍历文件和目录·························································································· 248
10.7.3 使用WatchService 监控文件变化························································································· 250
10.7.4 访问文件属性·························································································································· 252
10.8 本章考试、面试问题分析···································································································253
10.9 实验：流式I/O和文件········································································································254
10.10 本章小结·····························································································································255
第11 章 网络编程················································································································ 256
11.1 网络编程的基础知识···········································································································256
11.1.1 连接的地址······························································································································ 256
11.1.2 端口号······································································································································ 257
11.2 Java 网络通信模型···············································································································257
11.2.1 Java 网络模型·························································································································· 257
11.2.2 InetAddress 类························································································································· 257
11.2.3 使用URLDecoder 类和URLEncoder 类··············································································· 259
11.2.4 URL类和URLConnection 类································································································ 260
11.3 基于TCP协议的网络编程··································································································261
11.3.1 TCP协议································································································································· 261
11.3.2 使用Socket 进行通信············································································································· 261
11.3.3 使用ServerSocket 创建TCP服务器端················································································· 263
11.3.4 使用NIO 实现非阻塞Socket 通信························································································ 264
11.3.5 使用Java 7 的AIO·················································································································· 267
11.4 基于UDP 协议的网络编程·································································································272
11.4.1 UDP协议基础························································································································· 272
11.4.2 DatagramPacket ······················································································································· 272
11.4.3 DatagramSocket ······················································································································· 273
11.4.4 UDP实现客户端/服务器端通讯···························································································· 273
11.5 Java 访问网络资源···············································································································275
11.6 实验：Java网络编程···········································································································276
11.7 本章小结······························································································································· 277
第12 章 Swing 编程············································································································· 278
12.1 Swing 概述····························································································································278
12.2 Swing 基本组件的用法········································································································279
12.2.1 Swing的类层次结构··············································································································· 279
12.2.2 Swing组件的多样化··············································································································· 280
12.2.3 MVC（Model-View-Control）体系结构··············································································· 280
12.2.4 可存取性支持·························································································································· 280
12.2.5 支持键盘操作·························································································································· 281
12.2.6 设置边框·································································································································· 281
12.2.7 使用图标（Icon）··················································································································· 281
12.2.8 Swing程序结构简介··············································································································· 282
12.3 Swing 组件和容器················································································································282
12.3.1 容器组件的分类······················································································································ 282
12.3.2 使用容器的基本规则·············································································································· 283
12.3.3 Swing事件模型······················································································································· 284
12.4 图解应用集成开发环境设计GUI程序··············································································285
12.4.1 框架API 概述························································································································· 285
12.4.2 图解创建GUI 程序················································································································· 285
12.5 各种容器面板·······················································································································288
12.5.1 分层面板（JLayeredPane）··································································································· 289
12.5.2 面板（JPanel）······················································································································· 289
12.5.3 滚动窗口（JScrollPane）······································································································· 291
12.5.4 选项板（JTabbedPane）········································································································ 291
12.5.5 工具栏（JToolBar）··············································································································· 291
12.5.6 内部框架（JInternalFrame）·································································································· 291
12.6 常用组件······························································································································· 292
12.6.1 按钮（JButton）····················································································································· 292
12.6.2 复选框（JCheckBox）··········································································································· 293
12.6.3 单选按钮（JRadioButton）···································································································· 293
12.6.4 文件选择器（JFileChooser）································································································· 293
12.6.5 Java 7 增强的JColorChooser·································································································· 296
12.6.6 标签（JLabel）······················································································································· 298
12.7 列表·······································································································································298
12.7.1 使用List··································································································································· 298
12.7.2 使用JComboBox····················································································································· 302
12.8 菜单·······································································································································303
12.9 滑动条（JSlider）················································································································304
12.10 进程条（JProgressBar）····································································································304
12.11 表格（JTable）···················································································································305
12.11.1 TableModel ···························································································································· 305
12.11.2 表格的创建···························································································································· 306
12.12 使用JTree 和TreeModel 创建树·······················································································310
12.13 使用消息框·························································································································313
12.13.1 消息框（Message box）······································································································· 313
12.13.2 确认对话框···························································································································· 315
12.13.3 选择对话框···························································································································· 315
12.13.4 信息提示对话框···················································································································· 315
12.13.5 数据录入对话框···················································································································· 316
12.14 使用文本区域·····················································································································316
12.14.1 使用JTextPane ······················································································································ 316
12.14.2 文件编辑器的创建················································································································ 317
12.15 绘图·····································································································································319
12.16 对话框（Dialog box）·······································································································321
12.17 选择外观（Look and Feel）······························································································322
12.17.1 使用Pluggable Look and Feel······························································································· 322
12.17.2 使用Java 7 的Nimbus Look and Feel·················································································· 322
12.18 Java 7 新增的Swing 功能··································································································323
12.18.1 使用JLayer 装饰组件··········································································································· 323
12.18.2 创建透明、不规则形状窗口································································································ 325
12.19 本章考试、面试问题分析·································································································327
12.20 实验：建立图形用户界面·································································································327
12.21 本章小结·····························································································································328
第13 章 Applet 设计············································································································ 329
13.1 Applet 简介···························································································································329
13.1.1 编写Applet 小程序················································································································· 329
13.1.2 把Applet 嵌入到网页············································································································· 330
13.2 Applet 基础···························································································································332
13.2.1 Applet 类与JApplet 类··········································································································· 332
13.2.2 Applet 与Application 的区别································································································· 333
13.2.3 Applet 安全性·························································································································· 334
13.3 向Applet 传递参数··············································································································334
13.4 将Application 转化为Applet ······························································································335
13.4.1 Application程序······················································································································ 335
13.4.2 将Application 转化为Applet 的具体方法············································································ 337
13.4.3 Application 与Applet 组合····································································································· 338
13.5 Applet 与JAR文件··············································································································339
13.5.1 JAR文件概述·························································································································· 339
13.5.2 jar 命令····································································································································· 340
13.5.3 为Applet 生成数字签名········································································································· 341
13.5.4 JNLP与Java Web Start ·········································································································· 344
13.6 本章考试、面试问题分析···································································································349
13.7 实验：Applet 设计···············································································································349
13.8 本章小结······························································································································· 350
第3 篇 Java 扩展功能篇
第14 章 Java图形图像编程································································································· 352
14.1 Java 2D API···························································································································352
14.1.1 概述·········································································································································· 352
14.1.2 图形、文本和图像增强功能·································································································· 353
14.1.3 使用Java 7 的GraphicsEnvironment ····················································································· 353
14.2 基本图形绘制模型···············································································································354
14.2.1 坐标系统·································································································································· 354
14.2.2 变换·········································································································································· 355
14.2.3 字体·········································································································································· 355
14.2.4 图像·········································································································································· 356
14.2.5 填充和笔画······························································································································ 356
14.2.6 复合·········································································································································· 357
14.3 Java 2D API 包······················································································································357
14.4 图形的绘制···························································································································359
14.4.1 接口和类·································································································································· 359
14.4.2 图形绘制过程·························································································································· 360
14.4.3 Stroke 属性······························································································································ 362
14.4.4 Fill属性··································································································································· 362
14.4.5 剪切路径·································································································································· 362
14.4.6 变换·········································································································································· 363
14.4.7 Composite属性······················································································································· 363
14.5 设置Graphics2D 上下文环境······························································································364
14.5.1 指定Stroke 属性····················································································································· 364
14.5.2 指定Fill属性·························································································································· 365
14.5.3 使用纹理填充形状·················································································································· 365
14.5.4 设置剪切路径·························································································································· 366
14.5.5 在Java 2D 中绘制各种样式的图形······················································································· 366
14.5.6 设置Graphics2D 变换············································································································ 370
14.5.7 指定复合样式·························································································································· 371
14.6 图形元素的绘制···················································································································373
14.6.1 绘制形状·································································································································· 373
14.6.2 填充形状·································································································································· 374
14.7 实现几何形状接口和类·······································································································375
14.8 几何·······································································································································376
14.8.1 几何的概念······························································································································ 376
14.8.2 构造几何区域·························································································································· 376
14.9 字体和文本布局···················································································································381
14.9.1 接口和类·································································································································· 381
14.9.2 管理文本布局·························································································································· 381
14.9.3 确定文本布局·························································································································· 382
14.9.4 双插入记号······························································································································ 382
14.9.5 移动插入记号·························································································································· 383
14.9.6 选择测试·································································································································· 383
14.9.7 显示所选内容·························································································································· 383
14.9.8 查询布局度量·························································································································· 384
14.9.9 绘制文本查询·························································································································· 384
14.10 Java 3D API·························································································································386
14.10.1 Java 3D 的安装和运行·········································································································· 386
14.10.2 Java 3D 数据结构·················································································································· 387
14.10.3 Virtual Universe ····················································································································· 389
14.10.4 Java 3D 的坐标系统·············································································································· 389
14.10.5 Java 3D API ··························································································································· 390
14.10.6 创建Java 3D 应用程序········································································································· 391
14.11 BranchGroup 类···················································································································395
14.12 Canvas3D 类························································································································395
14.13 Transform3D 类···················································································································395
14.14 TransformGroup 类·············································································································396
14.15 Vector3f 类··························································································································396
14.16 Primitive 类·························································································································398
14.17 OrbitBehavior 类·················································································································398
14.18 Light 类································································································································399
14.18.1 光的类型································································································································ 399
14.18.2 场景图中的光························································································································ 399
14.18.3 材质特性································································································································ 399
14.19 材质贴图·····························································································································400
14.19.1 装入材质································································································································ 400
14.19.2 粘贴到图像上························································································································ 400
14.19.3 压缩和拉伸材质···················································································································· 400
14.19.4 材质贴图示例························································································································ 401
14.20 Behavior 类··························································································································403
14.20.1 唤醒调用································································································································ 404
14.20.2 processStimulus 方法············································································································· 404
14.20.3 旋转示例································································································································ 404
14.21 Java 打印技术·····················································································································407
14.21.1 打印控制类···························································································································· 407
14.21.2 打印机对话框························································································································ 407
14.21.3 启动打印机···························································································································· 409
14.22 Java 打印实例·····················································································································409
14.22.1 打印图像和文本···················································································································· 409
14.22.2 打印文件································································································································ 411
14.23 实验：图形与多媒体处理·································································································412
14.24 本章小结·····························································································································413
第15 章 MySQL 数据库与JDBC 编程················································································· 414
15.1 JDBC 基础·····························································································································414
15.1.1 JDBC的用途··························································································································· 415
15.1.2 JDBC与ODBC和其他API的比较····················································································· 415
15.1.3 两层模型和三层模型·············································································································· 416
15.1.4 SQL的一致性························································································································· 416
15.1.5 JDBC驱动程序的类型··········································································································· 417
15.2 安装MySQL数据库············································································································417
15.2.1 MySQL的下载与安装············································································································ 417
15.2.2 MySQL图形界面工具的下载与安装···················································································· 422
15.2.3 MySQL图形界面工具············································································································ 423
15.3 SQL 语句基础·······················································································································424
15.3.1 from 子句································································································································· 424
15.3.2 select 子句································································································································ 424
15.3.3 聚集函数·································································································································· 425
15.3.4 where 子句······························································································································· 425
15.3.5 表达式······································································································································ 425
15.3.6 表达式的使用·························································································································· 425
15.4 创建Connection 对象···········································································································426
15.4.1 建立连接·································································································································· 427
15.4.2 发送SQL ································································································································· 427
15.4.3 事务隔离级别·························································································································· 427
15.4.4 驱动设置·································································································································· 428
15.5 使用Statement 对象·············································································································429
15.5.1 创建Statement对象················································································································ 429
15.5.2 使用 Statement 对象执行语句······························································································· 429
15.5.3 语句完成·································································································································· 430
15.5.4 关闭Statement对象················································································································ 430
15.5.5 Statement对象中的SQL转义语法······················································································· 430
15.6 使用ResultSet 对象··············································································································430
15.6.1 行和光标的操作······················································································································ 431
15.6.2 列的操作·································································································································· 431
15.6.3 数据类型和转换······················································································································ 431
15.7 PreparedStatement 接口········································································································432
15.7.1 创建PreparedStatement 对象·································································································· 432
15.7.2 传递IN 参数···························································································································· 432
15.7.3 IN 参数中数据类型的一致性································································································· 432
15.8 CallableStatement 对象·········································································································433
15.8.1 创建CallableStatement 对象·································································································· 433
15.8.2 IN 和OUT 参数······················································································································ 433
15.8.3 INOUT 参数···························································································································· 434
15.8.4 检索OUT 参数························································································································ 434
15.8.5 检索作为OUT 参数的NULL 值··························································································· 434
15.9 JDBC 4.0新特性···················································································································435
15.9.1 自动加载驱动·························································································································· 435
15.9.2 RowId······································································································································· 435
15.9.3 SQL XML ································································································································ 436
15.9.4 SQLExcpetion 的增强············································································································ 436
15.10 JDBC 4.1 新特性···············································································································437
15.10.1 自动关闭相关资源················································································································ 437
15.10.2 Java 7 中的RowSetFactory 与RowSet ················································································ 437
15.11 本章程序设计案例·············································································································439
15.11.1 数据库开发环境的搭建········································································································ 439
15.11.2 操作数据库···························································································································· 440
15.12 本章考试、面试问题分析·································································································442
15.13 实验：数据库的连接·········································································································443
15.14 本章小结·····························································································································444
第4 篇 Java 项目实战篇
第16 章 MP3/MP4媒体播放器···························································································· 446
16.1 在Applet 中播放声音··········································································································446
16.1.1 Java 声音处理·························································································································· 446
16.1.2 应用AudioClip接口来实现声音的播放··············································································· 447
16.1.3 应用Sound API来处理声音·································································································· 448
16.2 Java 媒体框架·······················································································································451
16.2.1 JMF系统介绍························································································································· 451
16.2.2 数据源（Data source）··········································································································· 452
16.2.3 捕获设备（Capture Device）································································································· 452
16.2.4 播放器（Player）···················································································································· 452
16.2.5 处理器（Processor）·············································································································· 453
16.2.6 数据池（DataSink）··············································································································· 454
16.2.7 数据格式（Format）·············································································································· 454
16.2.8 管理器（Manager）················································································································ 454
16.3 MP3/MP4 媒体播放器的设计······························································································455
16.3.1 JMF的下载和安装················································································································· 455
16.3.2 MP3/MP4媒体播放器设计分析···························································································· 456
16.3.3 Player 对象的扩展··················································································································· 457
16.3.4 MP3/MP4媒体播放器主程序的设计···················································································· 459
第17 章 远程实时监控系统·································································································· 462
17.1 获取媒体数据的分析···········································································································462
17.1.1 注册音频和视频截取设备······································································································ 462
17.1.2 获取音频和视频数据·············································································································· 463
17.1.3 保存摄像头数据为视频文件·································································································· 464
17.1.4 摄像头拍照······························································································································ 466
17.1.5 通过网络发送实时媒体流数据······························································································ 467
17.1.6 通过网络接收实时媒体流数据······························································································ 469
17.2 网络实时流媒体收发系统的设计·······················································································471
17.2.1 Java 网络流媒体播放器分析·································································································· 471
17.2.2 媒体设备捕捉和发送类·········································································································· 472
17.2.3 媒体播放主程序类·················································································································· 478
17.2.4 同时接收多个流媒体类·········································································································· 481
17.3 本章小结······························································································································· 484
第18 章 航空票务管理系统·································································································· 485
18.1 系统需求说明·······················································································································485
18.1.1 需求分析·································································································································· 485
18.1.2 主要用例说明·························································································································· 485
18.2 业务实体层设计···················································································································486
18.2.1 设计域模型······························································································································ 486
18.2.2 设计数据模型·························································································································· 487
18.3 系统设计······························································································································· 488
18.3.1 程序的实现······························································································································ 488
18.3.2 航空电子票务管理类·············································································································· 489
18.3.3 数据库连接类·························································································································· 495
18.3.4 每期航班座位信息类·············································································································· 497
18.3.5 航班管理类······························································································································ 502
18.3.6 航班简单查询类······················································································································ 505
18.3.7 综合信息查询类······················································································································ 511
18.3.8 定票管理类······························································································································ 523
18.3.9 定票客户信息类······················································································································ 535
18.3.10 退票管理类···························································································································· 541
18.3.11 查询客户已定票信息类········································································································ 548
18.4 本章小结······························································································································· 551
第19 章 即时通信系统········································································································· 552
19.1 概述·······································································································································552
19.2 服务器用户数据库设计·······································································································552
19.3 系统架构技术·······················································································································553
19.4 即时通信系统服务器设计···································································································553
19.4.1 服务器协议设计······················································································································ 553
19.4.2 启动即时通信系统服务器······································································································ 565
19.4.3 实现多线程类监听类·············································································································· 566
19.5 即时通客户端设计···············································································································566
19.5.1 客户端主界面设计·················································································································· 566
19.5.2 系统托盘的设计······················································································································ 578
19.5.3 用户登录主程序······················································································································ 578
19.5.4 用户登录过程·························································································································· 581
19.5.5 用户申请号码·························································································································· 582
19.5.6 用户注册分析·························································································································· 585
19.5.7 查找并添加网友······················································································································ 587
19.5.8 添加网友程序分析·················································································································· 590
19.5.9 发送聊天信息·························································································································· 593
19.5.10 发送消息过程分析················································································································ 594
19.5.11 接收聊天信息························································································································ 594
19.5.12 查看好友详细信息················································································································ 596
19.5.13 删除好友································································································································ 597
19.6 本章总结······························································································································· 597
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java ７从入门到精通
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java代码与架构之完美优化
目录
序
前言
第1章 代码质量1
1.1 什么是代码质量1
1.2 什么是软件质量1
1.3 代码质量与软件质量1
1.4 代码质量优化理论2
1.5 提高代码质量手段3
小结3
第2章 代码质量静态检查工具4
2.1 静态分析技术概述4
2.2 静态分析技术原理4
2.3 静态分析技术给我们带来的好处5
2.4 常用重要静态分析工具6
2.5 如何优化静态分析工具6
小结11
第3章 代码质量优化通用准则12
3.1 避免使用空块12
3.2 避免使用空类15
3.3 去掉多余的import16
3.4 剪切无效代码17
3.5 制定命名体系规约18
编程解密一：完美规约20
优化技巧01：按照命名规约赋予名称20
3.6 去掉重复代码21
3.7 如何优雅使用switch语句22
3.8 用大写“L”代替小写“l”定义long变量24
3.9 避免在一条语句中声明或赋值多个变量25
3.10 去掉控制标志的临时变量26
优化技巧02：移除控制标志临时变量27
3.11 避免赋予临时变量过多的角色28
优化技巧03：赋予临时变量单一职责29
3.12 避免使用魔法数字29
优化技巧04：用常量取代魔法数字30
3.13 在for循环内修正增量因子有什么弊端31
3.14 用Enum代替Integer类型码常量32
优化技巧05：用枚举取代类型码34
3.15 用BigDecimal类型进行精确计算35
3.16 避免混用“+”36
3.17 避免混用复杂运算符37
3.18 避免使用复杂条件式或分支38
优化技巧06：用代码片段拆分复杂表达式41
优化技巧07：用卫语句代替嵌套条件表达式42
优化技巧08：用多态代替条件表达式43
3.19 如何深入理解“= ；=”的真正含义44
3.20 要习惯于用泛型代替原生类型48
3.21 如何正确使用通配符的边界53
3.22 如何发挥正则表达式的威力55
小结58
第4章 方法优化技巧59
4.1 最小化原则59
优化技巧09：封装类成员60
4.2 hashCode（）与equals（）是个孪生兄弟61
4.3 使用string.equals（"String"）带来的弊端66
4.4 避免命名不具有继承关系的同名方法67
4.5 检查参数的有效性68
4.6 避免使用可变参数69
4.7 如何优化过长参数72
优化技巧10：把参数提升成类成员变量73
优化技巧11：引入参数对象74
4.8 为什么不要重写静态方法75
4.9 避免使用过时的API77
4.10 优雅的集合运算方法知多少78
4.11 避免重复发明轮子81
4.12 如何对臃肿的方法进行瘦身82
优化技巧12：分解方法84
优化技巧13：合并方法85
小结85
第5章 如何保证多线程代码质量86
5.1 为什么不要重写start（）方法86
5.2 避免使用非线程安全的初始化方法87
5.3 用final成员对象作为同期化对象锁90
5.4 在synchronized内使用wait（）方法92
5.5 尽量缩小同期化代码范围93
小结94
第6章 如何优化类与接口95
6.1 避免创建不必要的对象95
6.2 避免使用对象的浅拷贝96
6.3 如何正确放置静态区位置100
6.4 为什么不要使用静态引入102
6.5 如何正确使用instanceof103
6.6 避免实例化特有工具类106
6.7 避免有深度耦合的类关系107
优化技巧14：移动变量110
优化技巧15：移动方法112
6.8 如何为臃肿的类进行手术114
优化技巧16：分解类116
6.9 如何优化冗赘类117
优化技巧17：合并类118
6.10 避免在接口中出现实现代码119
小结120
第7章 如何正确使用异常121
7.1 避免定义继承Error或Throwable子类121
7.2 避免抛出RuntimeException或Exception122
7.3 避免捕获NullPointerException或Error124
7.4 避免在finally块中处理返回值125
7.5 避免使失败失去原子性127
7.6 如何对异常进行封装128
优化技巧18：用异常代替错误码129
7.7 将优雅的异常信息反馈给用户130
7.8 避免乱用异常131
小结133
第8章 如何优化代码性能134
8.1 避免在大量字符串拼接时用“+”134
8.2 避免在循环体内生成临时对象135
8.3 在频繁插入与删除时使用LinkedList137
8.4 在文件操作后要进行清理动作139
编程解密四：完美改造140
8.5 避免显示调用finalized（）方法142
小结143
第9章 架构优化144
9.1 单一职责原则144
优化技巧19：梳理并分解类职责145
9.2 接口隔离原则147
优化技巧20：隔离接口149
9.3 依赖倒置原则151
优化技巧21：提炼接口152
9.4 里式替换原则154
9.5 最少知道原则155
9.6 如何扩展外部类功能159
优化技巧22：引入本地扩展160
9.7 如何梳理混杂的架构体系160
优化技巧23：以委托代替继承165
优化技巧24：封装向下转型165
优化技巧25：提炼继承体系167
优化技巧26：折叠继承体系169
小结170
第10章 包优化172
10.1 发布等价原则172
10.2 共同重用原则173
10.3 共同封闭原则174
10.4 无环依赖原则176
10.5 如何保持包的清晰179
优化技巧28：规整包中类位置180
编程解密五：完美优化181
10.6 如何抽出框架层次182
10.7 如何提取框架工程183
小结189
第11章 优良代码风格190
11.1 如何优化代码格式工具190
11.2 如何统一标准的代码格式193
11.3 养成良好的代码注释习惯194
编程解密六：完美突破196
小结198
结束语199
附录200
参考文献229
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java代码与架构之完美优化
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java JDK 7实例宝典
第1章  Java基础	1
1.1  转换基本数据类型	1
1.2  Java的运算符	3
1.3  控制程序的流程	9
1.4  计算阶乘	11
1.5  实现命令行程序	12
第2章  Java面向对象程序设计	14
2.1  复数类	14
2.2  equals、hashCode和clone方法	17
2.3  Java的参数传递	20
2.4  自定义形状类	21
2.5  类的加载顺序	26
2.6  方法和变量在继承时的覆盖与隐藏	28
2.7  排序类	31
2.8  Singleton（单例）模式	37
2.9  Factory（工厂）模式	39
2.10  Adapter（适配器）模式	41
第3章  数字	43
3.1  数字与数字封装类	43
3.2  格式化数字	45
3.3  数字的舍入	46
3.4  转换数字的进制	50
3.5  生成随机数	51
3.6  处理大数字	53
第4章  数组与集合	58
4.1  使用Arrays 	58
4.2  求质数	60
4.3  动态调整数组长度	62
4.4  矩阵	63
4.5  ArrayList、Vector和LinkedList	73
4.6  生成不重复的随机数序列	78
4.7  自定义队列	81
4.8  对List排序	83
4.9  HashSet、LinkedHashSet和TreeSet 	85
4.10  列表、集合与数组的互相转换	88
4.11  HashMap、HashTable、LinkedHashMap和TreeMap	89
4.12  对Map排序	93
4.13  Properties属性文件	95
第5章  字符串	97
5.1  使用String	97
5.2  基本数据类型与字符串的转换	101
5.3  判断Java标识符	103
5.4  使用StringBuffer 	104
5.5  IP地址转换成整数	107
5.6  18位身份证号码格式验证	109
5.7  表达式解析器	111
5.8  字符串编码的转换	119
5.9  字符串对齐器	122
5.10  密码加密与验证	125
5.11  制作命令行程序	127
5.12  使用StringTokenizer	131
5.13  使用正则表达式操作字符串	133
5.14  使用正则表达式验证电话号码格式	141
第6 章  Java异常处理	143
6.1  throw、throws、try和catch	143
6.2  自定义异常类	145
6.3  使用finally 	147
6.4  使用异常的技巧与原则	150
第7章  IO（输入输出）流	153
7.1  获取文件的属性信息	153
7.2  列出指定目录下的文件	155
7.3  创建文件和目录	157
7.4  删除文件和目录	161
7.5  移动文件和目录	163
7.6  复制文件和目录	167
7.7  一个简单的文件搜索器	171
7.8  读文件	174
7.9  写文件	179
7.10  添加内容到文件尾	181
7.11  文件的分割与合并	183
7.12  从键盘接收数据并输出到文件	186
7.13  使用StreamTokenizer统计文件的字符数	187
7.14  序列化和反序列化对象	190
7.15  控制对象的序列化和反序列	192
7.16  读jar包的资源文件	194
7.17  用Zip格式压缩和解压缩文件	196
7.18  操作Excel文件	201
7.19  操作PDF文件	205
7.20  自定义日志文件类	210
第8章  线程	214
8.1  定义和启动线程	214
8.2  停止线程	216
8.3  线程互斥	218
8.4  线程协作	221
8.5  线程join 	223
8.6  生产者/消费者问题	225
8.7  线程优先级	231
8.8  列出虚拟机中所有的线程	233
8.9  守护线程	235
8.10  线程池	237
8.11  一个线程死锁的例子	241
8.12  定时器（Timer）	243
第9章  Java GUI	245
9.1  日历	245
9.2  开窗户游戏	251
9.3  标准型计算器	255
9.4  更改组件外观	260
9.5  自定义对话框	262
9.6  制作欢迎画面	264
9.7  一个简单的编辑器	267
9.8  Swing的Drag和Drop	288
第10章  Java图形	297
10.1  一个圆形的按钮	297
10.2  捕捉屏幕	299
10.3  缩放图片	302
10.4  2D图形	306
10.5  3D图形	316
10.6  一个时钟程序	323
第11章  Java多媒体	331
11.1  滚动的消息	331
11.2  三维弹球	334
11.3  贪吃蛇游戏	338
11.4  Java声音处理	348
11.5  媒体播放器	356
第12章  反射	361
12.1  instanceof操作符	361
12.2  获取类的信息	362
12.3  动态调用类的方法	368
第13章  网络编程	371
13.1  获取URL的信息	371
13.2  Web浏览器	373
13.3  获取IP地址和域名	382
13.4  HTTP客户端	384
13.5  基本的Socket编程	385
13.6  HTTP服务器端	390
13.7  一个支持多线程的服务器框架	396
13.8  代理服务器	409
13.9  Telnet客户端	413
13.10  UDP编程	415
13.11  聊天室服务器端	419
13.12  聊天室客户端	426
13.13  FTP客户端	432
第14章  数据库	448
14.1  连接各种数据库	448
14.2  获得数据库和表的元数据	453
14.3  查询和更新数据库	457
14.4  批处理	461
14.5  提交和回滚事务	463
14.6  使用PreparedStatement	467
14.7  读写二进制数据	468
14.8  读写Blob数据	470
14.9  使用ResultSet更新数据库	473
14.10  使用RowSet	477
14.11  调用存储过程	486
14.12  一个数据库连接池	489
第15章  Applet	501
15.1  Applet时钟	501
15.2  处理鼠标和键盘事件	503
15.3  英文打字游戏	507
15.4  Applet间的通信	516
15.5  汉诺塔游戏	518
第16章  Java与XML	536
16.1  用DOM处理XML文档	536
16.2  用SAX处理XML文档	543
16.3  用XSLT转换XML	546
16.4  对象与XML文档的转换	549
第17章  JavaMail	552
17.1  使用SMTP协议发送简单的邮件	552
17.2  发送带附件的邮件	558
17.3  发送邮件给多人	560
17.4  使用POP3接收邮件	564
第18章  JSP与Servlet	578
18.1  获取客户端的真实IP地址	578
18.2  设置和读取Cookie	579
18.3  JSP无刷新聊天室	583
18.4  上传文件	587
18.5  用Servlet生成图形验证码	592
18.6  用Servlet实现分页查看数据库	595
第19章  J2SE 7.0新特性	608
19.1  Java编程语法的加强	608
19.2  新的JDBC 4.1	611
19.3  流的新特性	614
19.4  并发加强	619
19.5  网络加强新特性	623
19.6  2D加强	626
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java JDK 7实例宝典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java从初学到精通
第1篇 Java语言基础篇  第1章 Java语言概述  第2章 Java语言基本语法  第3章 数组  第4章 程序流程控制语句  第5章 数字、字符和字符串处理第2篇 Java面向对象篇  第6章 类和对象  第7章 继承  第8章 接口  第9章 抽象类与嵌套类  第10章 泛型  第11章 包  第12章 集合第3篇 Java图形图像篇  第13章 创建一个图形界面应用程序  第14章 使用Swing基本组件  第15章 使用Swing高级组件  第16章 程序界面布局  第17章 事件处理  第18章 图形、文本和图像处理第4篇 Java开发技术篇  第19章 异常处理  第20章 输入与输出  第21章 并发程序设计  第22章 网络编程  第23章 Java数据库应用程序开发基础  第24章 使用Swing组件创建数据库应用程序第5篇 Java实战篇  第25章 案例1：拼图游戏  第26章 案例2：心心网络聊天室  第27章 案例3：惠文教育教务管理系统
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java从初学到精通
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言程序设计
第1章  Java快速入门	  1.1  Java简介	    1.1.1  Java的定义	    1.1.2  Java的起源与发展	    1.1.3  Java语言的特点	    1.1.4  Java的3个分支	    1.1.5  Java的用途	  1.2  Java的开发环境与运行环境	    1.2.1  SDK、JDK、JRE与JVM	    1.2.2  SDK与Java（TM）的下载与安装	    1.2.3  配置Java开发与运行环境	  1.3  初步了解Java程序	    1.3.1  编写第一个Java源程序	    1.3.2  在“命令提示符”窗口编译与运行Java程序	    1.3.3  在EditPlus主窗口中编译与运行Java程序	    1.3.4  小结习题	第2章  Java基本语法第3章  Java语句及其控制结构第4章  面向对象编程第5章  深入类第6章  Java的异常处理机制第7章  常用系统类第8章  图形用户界面第9章  高级组件第10章  多线程机制第11章  图形与多媒体处理第12章  访问数据库第13章  综合应用程序实例编后语参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java精彩编程200例（全彩版）
第1章Java基础应用
实例001判断某一年是否为闰年
实例002从控制台接收输入的身份证号
实例003为新员工分配部门
实例004重定向输出流实现程序日志
实例005用动态数组保存学生姓名
实例006用List集合传递学生信息
实例007利用数组随机抽取幸运观众
实例008Map映射集合实现省市级联选择框
实例009格式化当前日期
实例010人民币金额转换成大写格式
实例011验证IP地址的有效性
实例012鉴别非法电话号码
实例013汉诺塔问题求解
实例014ASCII编码查看器
实例015经理与员工的差异
实例016简单的汽车销售4S店
实例017两只完全相同的宠物
实例018简单的截图软件
实例019泛型化的折半查找法
实例020查看和修改线程名称
实例021简单的电子时钟
实例022简单的模拟时钟
实例023简单的公历万年历
实例024判断日期格式的有效性
实例025查看本地时区
实例026计算程序运行时间
实例027七星彩号码生成器
实例028大乐透号码生成器
实例029监视JVM内存状态
第2章图形与图表操作
实例030为图形填充渐变色
实例031绘制艺术图案
实例032绘制花瓣
实例033裁剪图片
实例034使用像素值生成图像
实例035水印文字特效
实例036中文验证码
实例037图片验证码
实例038带干扰线的验证码
实例039图片半透明特效
实例040图片融合特效
实例041文字跑马灯特效
实例042字幕显示特效
实例043电影胶片特效
实例044雪花飘落动画效果
实例045水波动画效果
实例046图片配对游戏
实例047小猪走迷宫游戏
实例048拼图游戏
实例049海滩捉螃蟹游戏
实例050荒山打猎游戏
实例051打字母游戏
实例052警察抓小偷
实例053掷骰子
实例054画梅花
实例055打造自己的开心农场
实例056基本饼图
实例057分离饼图
实例058创建3D饼图
实例059实现多饼图
实例060简单柱形图
实例061绘制3D柱形图
实例062多系列柱形图
实例063多系列3D柱形图
实例064基本折线图
实例0653D折线图
实例066XY折线图
实例067排序折线图
第3章文字操作与数据库
实例068以树结构显示文件路径
实例069文件批量重命名
实例070快速批量移动文件
实例071读取属性文件的单个属性值
实例072删除文件夹中的所有文件
实例073修改文件属性
实例074显示指定类型的文件
实例075键盘录入内容保存到文本文件
实例076逆序输出数组信息
实例077合并多个txt文件
实例078实现文件简单加密与解密
实例079分割大文件
实例080重新合并分割后的文件
实例081向属性文件中添加信息
实例082替换文本文件内容
实例083批量复制指定扩展名的文件
实例084投票统计
实例085压缩所有文本文件
实例086压缩所有子文件夹
实例087在指定目录下搜索文件
实例088压缩包解压到指定文件夹
实例089设置RAR压缩包密码
实例090深层压缩文件夹的释放
实例091把窗体压缩成ZIP文件
实例092解压缩Java对象
实例093窗体动态加载磁盘文件
实例094从XML文件中读取数据
实例095分类存储文件夹中的文件
实例096统计文本中的字符数
实例097序列化与反序列化对象
实例098文件锁定
实例099使用SAX解析XML元素名称
实例100使用SAX解析XML元素名称和内容
实例101使用SAX解析XML元素属性和属性值
实例102使用DOM解析XML元素名称
实例103使用DOM解析XML元素名称和内容
实例104使用DOM解析XML元素属性和属性值
第4章网络安全与多线程
实例105获取本地主机的域名和主机名
实例106通过IP地址获取域名和主机名
实例107获取内网的所有IP地址
实例108设置等待连接的超时时间
实例109获取Socket信息
实例110接收和发送Socket信息
实例111使用Socket通信
实例112防止Socket传递汉字乱码
实例113使用Socket传输图片
实例114使用Socket传输音频
实例115使用Socket传输视频
实例116一个服务器与一个客户端通信
实例117一个服务器与多个客户端通信
实例118客户端一对多通信
实例119客户端一对一通信
实例120聊天室服务器端
实例121聊天室客户端
实例122使用MD5加密
实例123使用Hmac加密
实例124使用DSA加密
实例125线程的插队运行
实例126使用方法实现线程同步
实例127使用代码块实现线程同步
实例128使用特殊域变量实现线程同步
实例129使用重入锁实现线程同步
实例130使用线程局部变量实现线程同步
实例131简单的线程通信
实例132解决线程的死锁问题
实例133使用阻塞队列实现线程同步
实例134哲学家就餐问题
实例135使用信号量实现线程同步
实例136使用原子变量实现线程同步
实例137查看JVM中的线程名
实例138查看和修改线程的优先级
实例139使用事件分配线程更新Swing控件
第5章Swing程序设计
实例140根据桌面大小调整窗体大小
实例141自定义最大化、最小化和关闭按钮
实例142设置闪烁的标题栏
实例143实现带背景图片的窗体
实例144渐变背景的主界面
实例145文件的保存对话框
实例146支持图片预览的文件选择对话框
实例147右下角弹出信息窗体
实例148颜色选择对话框
实例149窗体顶层的进度条
实例150窗体抖动效果
实例151模拟QQ隐藏窗体
实例152百叶窗登场特效
实例153框架容器的背景图片
实例154拦截事件的玻璃窗格
实例155简单的每日提示信息
实例156震动效果对话框
实例157给文本域设置背景图片
实例158简单的字符统计工具
实例159能预览图片的复选框
实例160简单的计票软件
实例161能显示图片的组合框
实例162使用滑块选择日期
实例163模仿记事本的菜单栏
实例164自定义纵向的菜单栏
实例165复选框与单选按钮菜单
实例166包含图片的弹出菜单
实例167工具栏的实现与应用
实例168修改列表项显示方式
实例169修改列表项选择模式
实例170查找特定的列表元素
实例171设置表格的选择模式
实例172实现表格的查找功能
实例173在表格中应用组合框
实例174删除表格中选中的行
实例175实现表格的分页技术
实例176为单元格绘制背景色
实例177实现表格的栅栏效果
实例178编写中国省市信息树
实例179为树节点增加提示信息
实例180双击编辑树节点功能
实例181检查代码中的括号是否匹配
实例182文档中显示自定义图片
实例183高亮显示用户指定的关键字
实例184使用微调控件调整时间
实例185显示完成情况的进度条
实例186监视文件读入的进度
实例187支持图标的列表控件
实例188实现按钮关键字描红
实例189忙碌的按钮控件
实例190实现透明效果的表格控件
实例191在表格中显示工作进度百分比
实例192在表格中显示图片
实例193按钮放大效果
实例194带有动画效果的登录按钮
实例195焦点按钮的缩放
实例196动态加载表格数据
实例197石英钟控件
实例198日历控件
实例199平移面板控件
实例200背景图面板控件
附录1Java代码编写规范
附录2Eclipse常用的快捷键
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java精彩编程200例（全彩版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>解密搜索引擎技术实战(第二版)
第1章  搜索引擎总体结构	1
1.1  搜索引擎基本模块	2
1.2  开发环境	2
1.3  搜索引擎工作原理	4
1.3.1  网络爬虫	4
1.3.2  全文索引结构与Lucene实现	4
1.3.3  搜索用户界面	7
1.3.4  计算框架	8
1.3.5  文本挖掘	9
1.4  本章小结	10
第2章  网络爬虫的原理与应用	11
2.1  爬虫的基本原理	12
2.2  爬虫架构	14
2.2.1  基本架构	15
2.2.2  分布式爬虫架构	17
2.2.3  垂直爬虫架构	18
2.3  抓取网页	19
2.3.1  下载网页的基本方法	20
2.3.2  网页更新	23
2.3.3  抓取限制应对方法	25
2.3.4  URL地址提取	27
2.3.5  抓取JavaScript动态页面	28
2.3.6  抓取即时信息	31
2.3.7  抓取暗网	32
2.3.8  信息过滤	33
2.3.9  最好优先遍历	38
2.4  存储URL地址	40
2.4.1  BerkeleyDB	40
2.4.2  布隆过滤器	42
2.5  并行抓取	45
2.5.1  多线程爬虫	45
2.5.2  垂直搜索的多线程爬虫	47
2.5.3  异步I/O	49
2.6  RSS抓取	52
2.7  抓取FTP	54
2.8  下载图片	55
2.9  图像的OCR识别	56
2.9.1  图像二值化	57
2.9.2  切分图像	59
2.9.3  SVM分类	62
2.10  Web结构挖掘	66
2.10.1  存储Web图	66
2.10.2  PageRank算法	70
2.10.3  HITs算法	77
2.10.4  主题相关的PageRank	81
2.11  部署爬虫	82
2.12  本章小结	82
第3章  索引内容提取	86
3.1  从HTML文件中提取文本	87
3.1.1  字符集编码	87
3.1.2  识别网页的编码	90
3.1.3  网页编码转换为字符串编码	93
3.1.4  使用HTMLParser实现定向抓取	93
3.1.5  使用正则表达式提取数据	98
3.1.6  结构化信息提取	99
3.1.7  网页的DOM结构	102
3.1.8  使用NekoHTML提取信息	104
3.1.9  网页去噪	109
3.1.10  网页结构相似度计算	114
3.1.11  提取标题	116
3.1.12  提取日期	117
3.2  从非HTML文件中提取文本	117
3.2.1  提取标题的一般方法	118
3.2.2  PDF文件	122
3.2.3  Word文件	126
3.2.4  Rtf文件	127
3.2.5  Excel文件	138
3.2.6  PowerPoint文件	141
3.3  提取垂直行业信息	141
3.3.1  医疗行业	141
3.3.2  旅游行业	142
3.4  流媒体内容提取	143
3.4.1  音频流内容提取	143
3.4.2  视频流内容提取	147
3.5  存储提取内容	148
3.6  本章小结	149
第4章  中文分词原理与实现	151
4.1  Lucene中的中文分词	152
4.1.1  Lucene切分原理	152
4.1.2  Lucene中的Analyzer	154
4.1.3  自己写Analyzer	155
4.1.4  Lietu中文分词	158
4.2  查找词典算法	158
4.2.1  标准Trie树	159
4.2.2  三叉Trie树	162
4.3  中文分词的原理	166
4.4  中文分词流程与结构	170
4.5  形成切分词图	171
4.6  概率语言模型的分词方法	177
4.7  N元分词方法	181
4.8  新词发现	183
4.9  未登录词识别	185
4.10  词性标注	186
4.10.1  隐马尔可夫模型	189
4.10.2  基于转换的错误学习方法	197
4.11  平滑算法	199
4.12  机器学习的方法	203
4.12.1  最大熵	204
4.12.2  条件随机场	207
4.13  有限状态机	207
4.14  本章小结	214
第5章  让搜索引擎理解自然语言	216
5.1  停用词表	217
5.2  句法分析树	219
5.3  相似度计算	223
5.4  文档排重	226
5.4.1  语义指纹	227
5.4.2  SimHash	230
5.4.3  分布式文档排重	240
5.5  中文关键词提取	241
5.5.1  关键词提取的基本方法	241
5.5.2  HITS算法应用于关键词提取	243
5.5.3  从网页中提取关键词	245
5.6  相关搜索词	246
5.6.1  挖掘相关搜索词	246
5.6.2  使用多线程计算相关搜索词	248
5.7  信息提取	249
5.8  拼写检查与建议	254
5.8.1  模糊匹配问题	257
5.8.2  英文拼写检查	260
5.8.3  中文拼写检查	261
5.9  自动摘要	264
5.9.1  自动摘要技术	264
5.9.2  自动摘要的设计	265
5.9.3  基于篇章结构的自动摘要	271
5.9.4  Lucene中的动态摘要	271
5.10  文本分类	274
5.10.1  特征提取	276
5.10.2  中心向量法	280
5.10.3  朴素贝叶斯	282
5.10.4  支持向量机	291
5.10.5  多级分类	299
5.10.6  规则方法	300
5.10.7  网页分类	303
5.11  自动聚类	304
5.11.1  聚类的定义	304
5.11.2  K均值聚类方法	304
5.11.3  K均值实现	306
5.11.4  深入理解DBScan算法	310
5.11.5  使用DBScan算法聚类实例	312
5.12  拼音转换	314
5.13  概念搜索	315
5.14  多语言搜索	323
5.15  跨语言搜索	324
5.16  情感识别	325
5.16.1  确定词语的褒贬倾向	328
5.16.2  实现情感识别	329
5.16.3  用户协同过滤	331
5.17  本章小结	332
第6章  Lucene原理与应用	334
6.1  Lucene深入介绍	335
6.1.1  常用查询	335
6.1.2  查询语法与解析	336
6.1.3  查询原理	340
6.1.4  使用Filter筛选搜索结果	341
6.1.5  遍历索引库	341
6.1.6  索引数值列	343
6.2  Lucene中的压缩算法	346
6.2.1  变长压缩	346
6.2.2  PForDelta	348
6.2.3  前缀压缩	351
6.2.4  差分编码	352
6.2.5  设计索引库结构	354
6.3  创建和维护索引库	355
6.3.1  创建索引库	355
6.3.2  向索引库中添加索引文档	356
6.3.3  删除索引库中的索引文档	359
6.3.4  更新索引库中的索引文档	359
6.3.5  索引的合并	360
6.3.6  索引文件格式	360
6.3.7  分发索引	363
6.3.8  修复索引	366
6.4  查找索引库	366
6.5  读写并发控制	367
6.6  优化使用Lucene	368
6.6.1  索引优化	368
6.6.2  查询优化	369
6.6.3  实现时间加权排序	372
6.6.4  实现字词混合索引	375
6.6.5  重用Tokenizer	380
6.6.6  定制Tokenizer	380
6.7  检索模型	382
6.7.1  向量空间模型	382
6.7.2  BM25概率模型	387
6.7.3  统计语言模型	392
6.8  查询大容量索引	394
6.9  实时搜索	395
6.10  本章小结	396
第7章  搜索引擎用户界面	397
7.1  实现Lucene搜索	398
7.2  搜索页面设计	399
7.2.1  Struts2实现的搜索界面	399
7.2.2  翻页组件	400
7.3  实现搜索接口	401
7.3.1  编码识别	401
7.3.2  布尔搜索	404
7.3.3  指定范围搜索	405
7.3.4  搜索结果排序	406
7.3.5  搜索页面的索引缓存与更新	406
7.4  历史搜索词记录	409
7.5  实现关键词高亮显示	410
7.6  实现分类统计视图	412
7.7  实现相似文档搜索	417
7.8  实现AJAX搜索联想词	419
7.8.1  估计查询词的文档频率	419
7.8.2  搜索联想词总体结构	420
7.8.3  服务器端处理	420
7.8.4  浏览器端处理	421
7.8.5  服务器端改进	426
7.8.6  拼音提示	429
7.8.7  部署总结	430
7.9  集成其他功能	430
7.9.1  拼写检查	430
7.9.2  分类统计	431
7.9.3  相关搜索	433
7.9.4  再次查找	436
7.9.5  搜索日志	436
7.10  搜索日志分析	438
7.10.1  日志信息过滤	438
7.10.2  信息统计	440
7.10.3  挖掘日志信息	442
7.11  本章小结	443
第8章  使用Solr实现企业搜索	444
8.1  Solr简介	445
8.2  Solr基本用法	446
8.2.1  Solr服务器端的配置与中文支持	447
8.2.2  把数据放进Solr	452
8.2.3  删除数据	454
8.2.4  Solr客户端与搜索界面	455
8.2.5  Solr索引库的查找	457
8.2.6  索引分发	461
8.2.7  Solr搜索优化	464
8.3  从FAST Search移植到Solr	467
8.4  Solr扩展与定制	468
8.4.1  Solr中字词混合索引	469
8.4.2  相关检索	470
8.4.3  搜索结果去重	472
8.4.4  定制输入输出	476
8.4.5  分布式搜索	480
8.4.6  SolrJ查询分析器	481
8.4.7  扩展SolrJ	489
8.4.8  扩展Solr	490
8.4.9  查询Web图	494
8.5  Solr的.NET客户端	496
8.6  Solr的PHP客户端	502
8.7  本章小结	505
第9章  地理信息系统案例分析	506
9.1  新闻提取	508
9.2  POI信息提取	512
9.2.1  提取主体	517
9.2.2  提取地区	519
9.2.3  指代消解	520
9.3  本章小结	522
第10章  户外活动搜索案例分析	523
10.1  爬虫	524
10.2  信息提取	525
10.3  活动分类	528
10.4  搜索	529
10.5  本章小结	530
参考资料	531
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>解密搜索引擎技术实战(第二版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java编程方法论：响应式RxJava与代码设计实战
第1章  响应式编程总览（Reactive Programming）	1
1.1  异步编程模式	1
1.1.1  并发	2
1.1.2  并行开发初探	3
1.2  流（Stream）	3
1.3  响应式流（Reactive Stream）	4
1.3.1  响应式流的特性	4
1.3.2  响应式开发的设计原则	5
1.3.3  响应式开发的好处	6
1.4  响应式开发工具库	6
1.4.1  RxJava简介	6
1.4.2  Reactor简介	7
1.4.3  MongoDB简介	8
1.4.4  响应式项目用例	8
1.5  Java 9中的响应式编程	10
1.5.1  响应式编程接口	10
1.5.2  Java 9响应式编程入门Demo	12
1.5.3  SubmissionPublisher类的源码解读	18
1.5.4  响应式编程整合Spring实战案例	23
1.6  小结	29
第2章  在RxJava中创建Observable	30
2.1  响应式编程所涉及的设计模式	30
2.1.1  观察者模式	30
2.1.2  迭代器模式	30
2.2  解读reactivex.Observable	31
2.2.1  从Flow.Publisher到Observable	33
2.2.2  subscribe的二三事	33
2.2.3  create方法的设计思想	36
2.2.4  各式各样的Observable	40
2.2.5  Observable.cache	43
2.2.6  无限流	49
2.2.7  在Observable内处理错误	54
2.2.8  定时控制Observable发送数据	56
2.2.9  Disposable延伸	59
2.2.10  ConnectableObservable解读	67
2.2.11  Observable中的publish.refCount解读	76
2.2.12  RxJava中的Subject解读	79
2.3  小结	89
第3章  RxJava 2中的操作	90
3.1  核心操作	90
3.1.1  使用filter进行条件过滤	90
3.1.2  使用map进行元素转换	96
3.1.3  使用flatMap进行扁平化转换	98
3.1.4  使用scan累加器	112
3.1.5  使用groupBy进行分组	114
3.2  多个Observable的合并操作	122
3.2.1  使用merge对Observable进行合并	122
3.2.2  使用zip方法进行合并	124
3.2.3  combineLatest操作	135
3.2.4  withLatestFrom操作	141
3.2.5  amb操作	142
3.3  高级操作	143
3.3.1  再谈累加器scan	143
3.3.2  聚合操作reduce	144
3.3.3  收集操作collect	146
3.3.4  使用distinct去重	148
3.3.5  使用distinctUntilChanged过滤重复数据	152
3.3.6  其他操作	152
3.3.7  自定义操作	153
3.4  小结	159
第4章  对RxJava 2的设计探索	160
4.1  源的创建设计思路	160
4.2  中间操作的转承	162
4.3  小结	166
第5章  Observable实战	167
5.1  初版架子实现	167
5.1.1  DAO层面的处理工作	167
5.1.2  控制层的响应式实现	172
5.2  基于架子实现一个汇率查询的服务	175
5.3  rxjava-web-spring-boot-starter的抽取设计	179
5.4  ObservableSseEmitter的设计实现	188
5.5  小结	196
第6章  RxJava 2中的多线程操作	197
6.1  初探RxJava并发编程	197
6.2  subscribeOn操作	211
6.3  observeOn操作	216
6.4  unsubscribeOn操作	220
6.5  调度器Scheduler	226
6.5.1  Schedulers.newThread方式	227
6.5.2  Schedulers.io方式	227
6.5.3  Schedulers.computation方式	228
6.5.4  Schedulers.from(Executor executor)自定义方式	228
6.6  小结	230
第7章  Flowable与背压	231
7.1  回顾背压	231
7.2  引入Flowable	233
7.3  探索Flowable.create	234
7.3.1  BackpressureStrategy.BUFFER策略	239
7.3.2  BackpressureStrategy.LATEST策略	246
7.3.3  BackpressureStrategy.DROP策略	249
7.4  将一个Observable转化为一个Flowable	251
7.5  通过onBackpressureXXX操作来实现背压策略	252
7.5.1  onBackPressureBuffer操作	255
7.5.2  onBackpressureLatest与onBackpressureDrop操作	256
7.6  Flowable.generate操作	257
7.7  小结	262
第8章  Flowable实战	263
8.1  使用Flowable封装JDBC	263
8.1.1  封装部分查询逻辑	263
8.1.2  封装update逻辑	265
8.2  结合Spring Web应用使用Flowable	268
8.2.1  接口数据的获取	269
8.2.2  响应式服务的源设计	271
8.3  单元测试	274
8.3.1  使用Mock Service Server进行测试	274
8.3.2  使用@Mock来进行一些服务测试	277
8.4  controller层的实现逻辑改造	279
8.5  小结	282
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java编程方法论：响应式RxJava与代码设计实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java问答式教程
第1章
Java概述1.1

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java问答式教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务实战
第1章　基础知识	1
什么是微服务架构	1
-- 与单体系统的区别	1
-- 如何实施微服务	2
为什么选择Spring Cloud	6
Spring Cloud简介	7
版本说明	8
第2章　微服务构建：Spring Boot	11
框架简介	12
快速入门	13
-- 项目构建与解析	13
-- 实现RESTful API	17
配置详解	20
-- 配置文件	20
-- 自定义参数	22
-- 参数引用	22
-- 使用随机数	23
-- 命令行参数	23
-- 多环境配置	24
-- 加载顺序	25
监控与管理	26
-- 初识actuator	27
-- 原生端点	28
小结	38
第3章　服务治理：Spring Cloud Eureka	39
服务治理	39
-- Netflix Eureka	40
--搭建服务注册中心	41
--注册服务提供者	43
--高可用注册中心	46
--服务发现与消费	48
Eureka详解	51
--基础架构	52
--服务治理机制	52
--源码分析	56
配置详解	65
--服务注册类配置	65
--服务实例类配置	67
跨平台支持	71
第4章　客户端负载均衡：Spring Cloud Ribbon	73
客户端负载均衡	73
RestTemplate详解	75
-- GET请求	75
-- POST请求	77
-- PUT请求	79
-- DELETE请求	79
源码分析	80
-- 负载均衡器	91
-- 负载均衡策略	109
配置详解	123
--自动化配置	124
-- Camden版本对RibbonClient配置的优化	125
-- 参数配置	127
-- 与Eureka结合	127
重试机制	128
第5章　服务容错保护：Spring Cloud Hystrix	130
快速入门	131
原理分析	135
-- 工作流程	135
-- 断路器原理	144
-- 依赖隔离	148
使用详解	151
-- 创建请求命令	151
-- 定义服务降级	154
-- 异常处理	157
-- 命令名称、分组以及线程池划分	158
-- 请求缓存	159
-- 请求合并	166
属性详解	172
-- Command属性	174
-- collapser属性	184
-- threadPool属性	185
Hystrix仪表盘	187
Turbine集群监控	192
-- 构建监控聚合服务	192
-- 与消息代理结合	196
第6章　声明式服务调用：Spring Cloud Feign	199
快速入门	200
参数绑定	202
继承特性	205
Ribbon配置	209
全局配置	209
指定服务配置	209
重试机制	210
Hystrix配置	211
全局配置	211
禁用Hystrix	211
指定命令配置	212
服务降级配置	212
其他配置	214
第7章　API网关服务：Spring Cloud Zuul	217
快速入门	219
-- 构建网关	220
-- 请求路由	221
-- 请求过滤	223
路由详解	226
-- 传统路由配置	226
-- 服务路由配置	228
-- 服务路由的默认规则	229
-- 自定义路由映射规则	229
-- 路径匹配	230
-- 路由前缀	233
-- 本地跳转	234
--  Cookie与头信息	235
-- Hystrix和Ribbon支持	236
过滤器详解	238
-- 过滤器	238
-- 请求生命周期	239
-- 核心过滤器	240
-- 异常处理	244
-- 禁用过滤器	256
动态加载	257
-- 动态路由	257
-- 动态过滤器	261
第8章　分布式配置中心：Spring Cloud Config	267
快速入门	267
-- 构建配置中心	268
-- 配置规则详解	269
-- 客户端配置映射	272
服务端详解	274
-- 基础架构	274
-- Git配置仓库	276
-- SVN配置仓库	279
-- 本地仓库	279
-- 本地文件系统	279
-- 健康监测	280
-- 属性覆盖	281
-- 安全保护	281
-- 加密解密	282
-- 高可用配置	286
客户端详解	286
--  URI指定配置中心	287
-- 服务化配置中心	287
-- 失败快速响应与重试	290
-- 获取远程配置	292
-- 动态刷新配置	293
第9章　消息总线：Spring Cloud Bus	295
消息代理	295
RabbitMQ实现消息总线	296
-- 基本概念	297
-- 安装与使用	298
-- 快速入门	302
-- 整合Spring Cloud Bus	306
-- 原理分析	307
-- 指定刷新范围	308
-- 架构优化	309
-- RabbitMQ配置	310
Kafka实现消息总线	312
-- Kafka简介	312
-- 快速入门	313
--整合Spring Cloud Bus	315
-- Kafka配置	318
深入理解	318
-- 源码分析	320
-- 其他消息代理的支持	342
第10章　消息驱动的微服务：Spring Cloud Stream	344
快速入门	344
核心概念	349
-- 绑定器	350
-- 发布-订阅模式	351
-- 消费组	353
-- 消息分区	354
使用详解	355
-- 开启绑定功能	355
-- 绑定消息通道	356
-- 消息生产与消费	360
-- 响应式编程	366
-- 消费组与消息分区	368
-- 消息类型	370
绑定器详解	373
-- 绑定器SPI	373
-- 自动化配置	374
-- 多绑定器配置	374
--  RabbitMQ与Kafka绑定器	376
配置详解	376
-- 基础配置	377
-- 绑定通道配置	377
-- 绑定器配置	379
第11章　分布式服务跟踪：Spring Cloud Sleuth	386
快速入门	386
-- 准备工作	386
-- 实现跟踪	389
跟踪原理	390
抽样收集	392
与Logstash整合	394
与Zipkin整合	397
--  HTTP收集	398
-- 消息中间件收集	402
-- 收集原理	404
-- 数据存储	414
--  API接口	417
附录A　Starter POMs	419
后记	421
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>java for kids
第一章： 第一个Java程序
第二章： 转到Eclipse上开发
第三章： 宠物和鱼-Java的类
第四章： Java编程基础
第五章： 图形计算器
第六章： 窗口事件
第七章： 井字棋Applet小游戏
第八章： 程序异常处理
第九章： 保存游戏分数
第十章： 更多Java模块
第十一章： 回归图形-乒乓球游戏
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>java for kids
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计方法与实例
第1章 Java简介
1.1Java应用程序
1.2字节码
1.3与C++程序结构的比较
1.4编写Applet程序
1.5程序说明
第2章 数据与运算
2.1变量
2.2基本数据类型
2.3数据类型的转换
2.4变量的初始值
2.5基本数据类型的封装
2.6运算符
2.7常量的声明
第3章 流程控制
3.1if语句
3.2switch语句
3.3while语句

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计方法与实例
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>从 C++、Java 到 C#
第一章 概述
第二章 数据类型和变量
第三章 操作符和表达式
第四章 语句
第五章 数组
第六章 结构
第七章 类和对象
第八章 接口
第九章 异常
第十章 包和空间
第十一章 平台无关性
第十二章 线程
第十三章 安全机制
第十四章 文件操作
第十五章 应用实例
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>从 C++、Java 到 C#
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 2实用培训教程
第一章  JAVA 2介绍
第二章  面向对象编程
第三章  JAVA语言基础
第四章  JAVA中的对象
第五章  数组和控制结构
第六章  创建类和方法
第七章  JAVA小程序简介
第八章  学习SWING
第九章  SWING窗口
第十章  JAVA的布局设计
第十一章  响应用户事件
第十二章  图形设计
第十三章  动画设计
第十四章  JAVASOUND
第十五章  JAVA接口、异常和包
第十六章  使用JAVA流处理数据
第十七章  INTERNET通信
第十八章  使用JAVABEAN
第十九章  数据库编程与数据结构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 2实用培训教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向对象程序设计与Java语言
第一章 程序和程序设计 
第二章 基本数据类型
第三章 基本控制结构
第四章 方法
第五章 类与对象
第六章 复合数据类型
第七章 继承与多态
第八章 接口与程序包
第九章 异常处理与断言
第十章 输入/输出流
第十一章 对象容器
第十二章 图形用户界面 
第十三章 数据库编程初步  
第十四章 多线程编辑
第十五章 网络通信编程
第十六章 相关软件技术简介
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向对象程序设计与Java语言
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计案例教程
第1章 Java语言概述  1.1 Java语言简介  1.2 第一个Java语言程序    1.2.1 Java开发环境    1.2.2 “Java与咖啡”源代码    1.2.3 程序输入、调试和运行步骤  1.3 Java语言开发环境    1.3.1 JDK的下载与安装    1.3.2 Eclipse的下载与使用    1.3.3 Java小程序输入、调试和运行步骤  本章小结  习题1第2章 Java语言基础  2.1 基本语言要素    2.1.1 标识符    2.1.2 关键字    2.1.3 分隔符    2.1.4 注释  2.2 基本数据类型    2.2.1 整数类型    2.2.2 浮点类型    2.2.3 字符类型    2.2.4 布尔类型  2.3 常量和变量    2.3.1 常量    2.3.2 变量  2.4 运算符和表达式    2.4.1 运算符    2.4.2 表达式  2.5 赋值语句  2.6 Java数据类型的转换    2.6.1 自动类型转换    2.6.2 强制类型转换  本章小结  习题2第3章 Java流程控制  3.1 顺序结构及可视化输入输出  3.2 选择结构    3.2.1 单分支选择语句(if语句)    3.2.2 双分支选择语句(if…else语句)    3.2.3 用嵌套的if语句实现多分支选择结构    3.2.4 多分支选择语句(if…else if…else语句)    3.2.5 switeh语句  3.3 循环结构    3.3.1 while语句    3.3.2 dowhile语句    3.3.3 for语句    3.3.4 循环的嵌套    3.3.5 跳转语句  本章小结  习题3第4章 数组  4.1 一维数组    4.1.1 数组的建立    4.1.2 数组元素的引用    4.1.3 数组的复制  4.2 一维数组算法应用实例  4.3 二维数组和多维数组    4.3.1 二维数组元素的逻辑结构    4.3.2 二维数组的初始化    4.3.3 二维数组元素的引用  4.4 Java中的字符串    4.4.1 String类    4.4.2 可变长字符串StringBuffer类  4.5 Arrays与ArrayList类    4.5.1 Arrays类    4.5.2 ArrayList类  本章小结  习题4第5章 Java面向对象程序设计  5.1 类和对象    5.1.1 面向对象方法    5.1.2 类的定义    5.1.3 成员变量    5.1.4 成员方法    5.1.5 构造方法    5.1.6 对象的创建和使用    5.1.7 类成员与实例成员    5.1.8 对象数组  5.2 类的封装性    5.2.1 封装的概念    5.2.2 访问权限修饰符    5.2.3 方法的重载    5.2.4 this引用    5.2.5 类之间的组合关系  5.3 类的继承性    5.3.1 继承的概念    5.3.2 子类的定义    5.3.3 super引用    5.3.4 抽象类与最终类    5.3.5 内部类  5.4 接口    5.4.1 接口的概念    5.4.2 声明接口    5.4.3 实现接口    5.4.4 接口变量  5.5 类的多态性    5.5.1 多态性的概念    5.5.2 运行时多态性  本章小结  习题5第6章 包与异常处理  6.1 包    6.1.1 包的创建    6.1.2 包的导人    6.1.3 案例6-1的实现  6.2 异常    6.2.1 异常的概念    6.2.2 Java的异常类    6.2.3 异常处理机制    6.2.4 自定义异常    6.2.5 案例6-2的分析与实现  本章小结  习题6第7章 图形用户界面  7.1 图形用户界面设计基础    7.1.1 AwT与Swing概述    7.1.2 容器与布局管理器    7.1.3 初识事件及事件处理    7.1.4 图形用户界面的设计方法和步骤    7.1.5 案例7-1的实现  7.2 Swing组件及其应用    7.2.1 常用Swing组件    7.2.2 案例7-2的实现与分析  7.3 Java的事件处理机制    7.3.1 委托事件模型    7.3.2 案例7-2中的事件处理的分析  7.4 窗口与菜单    7.4.1 菜单的组成与菜单类    7.4.2 为窗口加入菜单    7.4.3 案例7-3的实现  7.5 图形绘制    7.5.1 Graphics类    7.5.2 在组件上绘图    7.5.3 案例7-4的实现  本章小结  习题7  ……第8章 多线程第9章 Java Applet第10章 Java输入输出流第11章 JDBC与数据库访问第12章 Java网络程序设计参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计案例教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java SE7 技術手冊
序
導讀
01 Java平台概論
02 從JDK到IDE
03 基礎語法
04 認識物件
05 物件封裝
06 繼承與多型
07 介面與多型
08 例外處理
09 Collection與Map
10 輸入輸出
11 執行緒與並行API
12 通用API
13 視窗程式設計
14 整合資料庫
15 反射與類別載入器
16 自訂泛型、列舉與標註
附錄A 如何使用本書專案
附錄B MySQL入門
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java SE7 技術手冊
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java项目开发全程实录（第3版）
第1章  进销存管理系统（Swing+SQL Server
2000实现）	1
视频讲解：1小时44分钟
1.1  开发背景	2
1.2  系统分析	2
1.2.1  需求分析	2
1.2.2  可行性分析	2
1.2.3  编写项目计划书	4
1.3  系统设计	5
1.3.1  系统目标	5
1.3.2  系统功能结构	6
1.3.3  业务逻辑编码规则	6
1.3.4  系统流程图	8
1.3.5  构建开发环境	8
1.3.6  系统预览	8
1.3.7  文件夹组织结构	9
1.4  数据库设计	10
1.4.1  数据库分析	10
1.4.2  进销存管理系统的E-R图	10
1.4.3  使用PowerDesigner建模	11
1.4.4  创建数据库	14
1.5  主窗体设计	14
1.5.1  创建主窗体	14
1.5.2  创建导航面板	16
1.6  公共模块设计	19
1.6.1  编写Dao公共类	19
1.6.2  编写Item类	23
1.7  基础信息模块设计	24
1.7.1  基础信息模块概述	24
1.7.2  基础信息模块技术分析	25
1.7.3  供应商添加的实现过程	25
1.7.4  供应商修改与删除的实现过程	27
1.7.5  单元测试	30
1.8  进货管理模块设计	33
1.8.1  进货管理模块概述	33
1.8.2  进货管理模块技术分析	34
1.8.3  进货单的实现过程	35
1.9  查询统计模块设计	38
1.9.1  查询统计模块概述	38
1.9.2  查询统计模块技术分析	39
1.9.3  销售查询的实现过程	40
1.10  库存管理模块设计	42
1.10.1  库存管理模块概述	42
1.10.2  库存管理模块技术分析	42
1.10.3  价格调整的实现过程	42
1.10.4  单元测试	44
1.11  系统打包发布	45
1.12  开发技巧与难点分析	46
1.13  使用PowerDesigner逆向生成
数据库E-R图	47
1.14  本章小结	48
第2章  企业内部通信系统（Swing+
JavaDB实现）	49
视频讲解：1小时42分钟
2.1  开发背景	50
2.2  系统分析	50
2.2.1  需求分析	50
2.2.2  可行性分析	50
2.2.3  编写项目计划书	52
2.3  系统设计	53
2.3.1  系统目标	53
2.3.2  系统功能结构	53
2.3.3  数据库设计	54
2.3.4  系统预览	55
2.3.5  文件夹组织结构	56
2.4  主窗体设计	56
2.4.1  创建主窗体	56
2.4.2  记录窗体位置	60
2.5  公共模块设计	61
2.5.1  数据库操作类	61
2.5.2  系统工具类	66
2.6  系统托盘模块设计	71
2.6.1  系统托盘模块概述	71
2.6.2  系统托盘模块技术分析	71
2.6.3  系统托盘模块的实现过程	72
2.7  系统工具模块设计	74
2.7.1  系统工具模块概述	74
2.7.2  系统工具模块技术分析	74
2.7.3  系统工具模块的实现过程	74
2.8  用户管理模块设计	79
2.8.1  用户管理模块概述	79
2.8.2  用户管理模块技术分析	79
2.8.3  用户管理模块的实现过程	80
2.8.4  单元测试	84
2.9  通信模块设计	86
2.9.1  通信模块概述	86
2.9.2  通信模块技术分析	86
2.9.3  通信模块的实现过程	86
2.10  开发技巧与难点分析	90
2.11  使用系统托盘	91
2.12  本章小结	92
第3章  企业人事管理系统（Swing+Hibernate+
Oracle实现）	93
视频讲解：2小时55分钟
3.1  开发背景	94
3.2  系统分析	94
3.3  系统设计	94
3.3.1  系统目标	94
3.3.2  系统功能结构	94
3.3.3  系统预览	95
3.3.4  业务流程图	97
3.3.5  文件夹结构设计	98
3.4  数据库设计	98
3.4.1  数据库分析	98
3.4.2  数据库概念设计	98
3.4.3  数据库逻辑结构设计	99
3.5  主窗体设计	100
3.5.1  导航栏的设计	100
3.5.2  工具栏的设计	102
3.6  公共模块设计	104
3.6.1  编写Hibernate配置文件	104
3.6.2  编写Hibernate持久化类和映射文件	105
3.6.3  编写通过Hibernate操作持久化对象的
常用方法	106
3.6.4  创建用于特殊效果的部门树对话框	107
3.6.5  创建通过部门树选取员工的面板和
对话框	109
3.7  人事管理模块设计	111
3.7.1  人事管理模块功能概述	111
3.7.2  人事管理模块技术分析	112
3.7.3  人事管理模块的实现过程	112
3.7.4  单元测试	116
3.8  待遇管理模块设计	117
3.8.1  待遇管理模块功能概述	117
3.8.2  待遇管理模块技术分析	118
3.8.3  待遇管理模块的实现过程	118
3.9  系统维护模块设计	123
3.9.1  系统维护模块功能概述	123
3.9.2  系统维护模块技术分析	124
3.9.3  系统维护模块的实现过程	124
3.9.4  单元测试	128
3.10  开发技巧与难点分析	129
3.11  Hibernate关联关系的建立方法	129
3.11.1  建立一对一关联	129
3.11.2  建立一对多关联	130
3.12  本章小结	132
第4章  酒店管理系统（Swing+SQL Server
2005实现）	133
视频讲解：2小时42分钟
4.1  概述	134
4.2  系统分析	134
4.3  系统设计	134
4.3.1  系统目标	134
4.3.2  系统功能结构	135
4.3.3  系统预览	135
4.3.4  业务流程图	136
4.3.5  文件夹结构设计	136
4.4  数据库设计	137
4.4.1  数据库分析	137
4.4.2  数据库概念设计	137
4.4.3  数据库逻辑结构设计	138
4.4.4  视图设计	138
4.5  公共模块设计	139
4.5.1  编写数据库连接类	139
4.5.2  封装常用的操作数据库的方法	140
4.5.3  自定义表格组件	141
4.5.4  编写利用正则表达式验证数据合法性的
方法	143
4.6  主窗体设计	143
4.7  用户登录窗口设计	145
4.8  开台签单工作区设计	150
4.8.1  开台签单工作区的功能概述	150
4.8.2  开台签单工作区技术分析	150
4.8.3  开台签单工作区的实现过程	151
4.8.4  单元测试	156
4.9  自动结账工作区设计	157
4.9.1  自动结账工作区功能概述	157
4.9.2  自动结账工作区技术分析	157
4.9.3  自动结账工作区的实现过程	157
4.10  结账报表工作区设计	159
4.10.1  结账报表工作区功能概述	159
4.10.2  结账报表工作区技术分析	160
4.10.3  结账报表工作区的实现过程	160
4.10.4  单元测试	163
4.11  后台管理工作区设计	164
4.11.1  后台管理工作区功能概述	164
4.11.2  后台管理工作区技术分析	165
4.11.3  后台管理工作区的实现过程	165
4.11.4  单元测试	172
4.12  开发技巧与难点分析	172
4.13  使用Visio逆向生成数据库E-R图	174
4.14  本章小结	175
第5章  图书馆管理系统（Swing+SQL Server
2000实现）	176
视频讲解：2小时18分钟
5.1  开发背景	177
5.2  需求分析	177
5.3  系统设计	177
5.3.1  系统目标	177
5.3.2  系统功能结构	178
5.3.3  系统流程图	178
5.3.4  系统预览	179
5.3.5  构建开发环境	179
5.3.6  文件夹组织结构	180
5.4  数据库设计	180
5.4.1  数据库分析	180
5.4.2  数据库概念设计	180
5.4.3  使用PowerDesigner建模	182
5.5  公共模块设计	183
5.5.1  数据库连接及操作类的编写	183
5.5.2  MenuActions类的编写	185
5.5.3  限制文本框长度类的编写	187
5.5.4  描述组合框索引与内容类的编写	188
5.5.5  在JLable上添加图片类的编写	189
5.6  主窗体设计	190
5.6.1  主窗体概述	190
5.6.2  主窗体技术分析	190
5.6.3  主窗体的实现过程	192
5.7  登录模块设计	196
5.7.1  登录模块概述	196
5.7.2  登录模块技术分析	196
5.7.3  登录模块的实现过程	197
5.8  图书信息管理模块设计	201
5.8.1  图书信息管理模块概述	201
5.8.2  图书信息管理模块技术分析	201
5.8.3  图书信息管理模块的实现过程	202
5.8.4  单元测试	210
5.9  图书借阅、归还模块设计	211
5.9.1  图书借阅、归还模块概述	211
5.9.2  图书借阅、归还模块技术分析	211
5.9.3  图书借阅、归还模块的实现过程	212
5.9.4  单元测试	219
5.10  图书查询模块设计	219
5.10.1  图书查询模块概述	219
5.10.2  图书查询模块技术分析	220
5.10.3  图书查询模块的实现过程	221
5.11  开发技巧与难点分析	223
5.11.1  级联删除	223
5.11.2  窗体中单选按钮即时显示	223
5.12  格式化的文本框	224
5.12.1  使用JFormattedTextField限制整型数字
输入	224
5.12.2  使用JFormattedTextField限制日期
输入	224
5.13  本章小结	225
第6章  企业快信（Swing+JavaDB
实现）	226
视频讲解：1小时38分钟
6.1  企业快信概述	227
6.2  系统分析	227
6.2.1  需求分析	227
6.2.2  可行性研究	227
6.3  系统设计	228
6.3.1  系统目标	228
6.3.2  系统功能结构	228
6.3.3  业务流程图	228
6.3.4  系统预览	229
6.3.5  构建开发环境	231
6.3.6  文件夹组织结构	232
6.4  数据库设计	232
6.4.1  数据库分析	232
6.4.2  数据库概念设计	232
6.4.3  数据库逻辑结构设计	233
6.4.4  视图设计	234
6.5  主窗体设计	234
6.6  公共模块设计	236
6.6.1  编写数据库连接类	236
6.6.2  封装常用的操作数据库的方法	238
6.7  资源管理模块设计	239
6.7.1  名片夹管理功能概述	239
6.7.2  名片夹管理功能技术分析	240
6.7.3  名片夹管理功能的实现过程	241
6.8  发送短信模块设计	248
6.8.1  发送短信模块功能概述	248
6.8.2  发送短信模块技术分析	249
6.8.3  发送短信模块的实现过程	250
6.9  发送邮件模块设计	254
6.9.1  发送邮件模块功能概述	254
6.9.2  发送邮件模块技术分析	255
6.9.3  发送邮件模块的实现过程	255
6.10  系统设置模块设计	260
6.10.1  系统设置模块功能概述	260
6.10.2  系统设置模块技术分析	260
6.10.3  短信设置的实现过程	261
6.10.4  邮箱设置的实现过程	263
6.11  开发技巧与难点分析	264
6.12  使用短信猫和Java Mail组件	265
6.12.1  使用短信猫	265
6.12.2  使用Java Mail组件	267
6.13  本章小结	272
第7章  欣想电子商城（Swing+Hibernate+
SQL Server实现）	273
视频讲解：1小时58分钟
7.1  开发背景	274
7.2  系统分析	274
7.2.1  需求分析	274
7.2.2  可行性分析	274
7.3  系统设计	275
7.3.1  系统目标	275
7.3.2  系统功能结构	275
7.3.3  购物流程图	276
7.3.4  系统预览	276
7.3.5  构建开发环境	277
7.3.6  文件夹组织结构	279
7.4  数据库设计	280
7.4.1  数据库分析	280
7.4.2  数据库概念设计	280
7.4.3  PowerDesigner数据库建模	281
7.4.4  数据库创建	282
7.5  网站首页设计	282
7.5.1  首页布局	283
7.5.2  创建首页控制器	286
7.5.3  配置控制器	287
7.6  公共模块设计	288
7.6.1  编写Dao公共类	289
7.6.2  配置数据库连接和事务管理器	291
7.6.3  配置Spring控制器的请求映射	292
7.7  会员管理模块设计	294
7.7.1  会员管理模块概述	294
7.7.2  会员管理模块技术分析	295
7.7.3  会员注册的实现过程	295
7.7.4  会员登录的实现过程	299
7.8  购物模块设计	301
7.8.1  购物模块概述	301
7.8.2  购物模块技术分析	302
7.8.3  购物车的实现过程	302
7.8.4  收银台的实现过程	306
7.8.5  单元测试	309
7.9  商品管理模块设计	310
7.9.1  商品管理模块概述	310
7.9.2  商品管理模块技术分析	311
7.9.3  商品列表的实现过程	311
7.9.4  商品添加的实现过程	314
7.9.5  单元测试	316
7.10  发布与运行	317
7.11  开发技巧与难点分析	319
7.11.1  为Spring的数据源配置正确的URL	319
7.11.2  为Tiles指定错误页面	320
7.12  使用MyEclipse生成Hibernate实体类
和映射文件	320
7.13  本章小结	322
第8章  超市管理系统（Swing+ SQL Server
2005实现）	323
视频讲解：2小时10分钟
8.1  开发背景	324
8.2  系统分析	324
8.2.1  需求分析	324
8.2.2  可行性分析	324
8.3  系统设计	325
8.3.1  系统目标	325
8.3.2  系统功能结构	325
8.3.3  系统流程图	325
8.3.4  系统预览	326
8.3.5  文件夹组织结构	327
8.4  数据库设计	327
8.4.1  数据库分析	328
8.4.2  数据库概念设计	328
8.5  公共类设计	329
8.5.1  连接数据库公共类	329
8.5.2  获取当前系统时间类	330
8.6  登录模块设计	331
8.6.1  登录模块概述	331
8.6.2  实现带背景的窗体	331
8.6.3  登录模块的实现过程	332
8.7  主窗体设计	334
8.7.1  主窗体概述	334
8.7.2  平移面板控件	334
8.7.3  主窗体的实现过程	338
8.8  采购订货模块设计	340
8.8.1  采购订货模块概述	340
8.8.2  在表格中添加按钮	340
8.8.3  添加采购订货信息的实现过程	341
8.8.4  搜索采购订货信息的实现过程	343
8.8.5  修改采购订货信息的实现过程	344
8.8.6  删除采购订货信息的实现过程	347
8.9  人员管理模块设计	348
8.9.1  人员管理模块概述	348
8.9.2  使用触发器级联删除数据	349
8.9.3  显示查询条件的实现过程	350
8.9.4  显示员工基本信息的实现过程	352
8.9.5  添加员工信息的实现过程	353
8.9.6  删除员工信息的实现过程	356
8.10  在Eclipse中实现程序打包	357
8.11  本章小结	359
第9章  企业门户网站（JSP+JavaBean+
SQL Server 2000实现）	360
视频讲解：1小时8分钟
9.1  开发背景	361
9.2  需求分析	361
9.3  系统设计	361
9.3.1  系统目标	361
9.3.2  系统功能结构	362
9.3.3  业务流程图	362
9.3.4  系统预览	362
9.3.5  构建开发环境	363
9.3.6  文件夹组织结构	366
9.4  数据库设计	366
9.4.1  数据库需求分析	366
9.4.2  数据库概念设计	366
9.4.3  数据库逻辑结构设计	367
9.5  公共模块设计	368
9.5.1  定义connsqlserver类	368
9.5.2  创建Web应用过滤器	370
9.5.3  构建转码类	371
9.6  网站首页设计	372
9.6.1  首页概述	372
9.6.2  首页技术分析	372
9.6.3  首页的实现过程	373
9.7  商品介绍模块设计	375
9.7.1  商品介绍模块概述	375
9.7.2  商品介绍模块技术分析	376
9.7.3  商品介绍模块的实现过程	376
9.8  后台登录模块设计	377
9.8.1  后台登录模块概述	377
9.8.2  后台登录模块技术分析	378
9.8.3  后台登录模块的实现过程	379
9.8.4  单元测试	381
9.9  商品管理模块设计	382
9.9.1  商品管理模块概述	382
9.9.2  商品管理模块技术分析	382
9.9.3  商品管理模块的实现过程	383
9.9.4  单元测试	394
9.10  新闻管理模块设计	394
9.10.1  新闻管理模块概述	394
9.10.2  新闻管理模块技术分析	395
9.10.3  新闻管理模块的实现过程	396

9.11  开发技巧与难点分析	403
9.11.1  页面弹出窗口控制	403
9.11.2  FileUpload组件获取表单中的值	404
9.11.3  配置全局Tomcat连接池	404
9.12  Proxool连接池	405
9.12.1  Proxool安装	405
9.12.2  Proxool使用	405
9.13  本章小结	407
第10章  棋牌游戏系统之网络五子棋
（Swing+Socket实现）	408
视频讲解：2小时10分钟
10.1  开发背景	409
10.2  需求分析	409
10.3  系统设计	409
10.3.1  系统目标	409
10.3.2  系统功能结构	410
10.3.3  系统流程图	410
10.3.4  构建开发环境	410
10.3.5  系统预览	411
10.3.6  文件夹组织结构	412
10.4  公共模块设计	412
10.4.1  绑定属性的JavaBean	412
10.4.2  在棋盘中绘制棋子	413
10.4.3  实现动态调整棋盘大小	415
10.4.4  游戏悔棋	416
10.4.5  游戏回放	416
10.5  实现登录界面	418
10.6  编写游戏主窗体	420
10.7  编写下棋面板	424
10.8  编写棋盘面板	433
10.9  实现游戏规则算法	438
10.10  编写棋盘模型	442
10.11  编写联机通讯类	444
10.12  系统打包发布	448
10.13  开发技巧与难点分析	449
10.14  本章小结	449
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java项目开发全程实录（第3版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java面向对象程序设计教程
第1章 Java导论
1.1 Java语言的特点
1.1.1 简单的面向对象程序设计语言
1.1.2 健壮安全的分布式语言
1.1.3 结构巾立.可移植性强的解释型语言
1.1.4 高效能
1.1.5 支持多线程的动态语言
1.1.6 Java与几种常用语言的比较
1.2.Java执行环境
1.2.1 JVM机制Java平台的基础
1.2.2 白动垃圾收集
1.2.3 保护域机制与沙箱模型
1.2.4 类加载器启动引擎的点火器
1.3 JDK的组成与安装设置
1.3.1 Java平台的组成结构
1.3.2 SETPATH和SETCLASSPATIt的作用
1.3.3 Java开发平台简介
1.4 典型例子及常见问题
1.4.1 编泽器.解释器.小程序观察器和反编泽器
1.4.2 简单的"HelloWorld!”例子
1.4.3 应用程序的主方法
1.4.4 小程序的运行
1.5 思考与练习
第2章 Java的基本语法
2.1 类型.值与基本变量
2.1.1 基本概念
2.1.2 基本类型
2.1.3 引用类型
2.1.4 类型转换
2.1.5 简化操作的一些辅助手段
2.2 运算符与表达式
2.2.1 算术运算符与表达式
2.2.2 关系运算符与表达式
2.2.3 逻辑运算符与表达式
2.2.4 位运算符与表达式
2.2.5 条件运算符与表达式
2.2.6 赋值运算符与表达式
2.2.7 instanceof运算符
2.2.8 运算符优先级与赋值顺序的理解
2.2.9 基本类型所支持的操作运算
2.3 语句
2.3.1 编组语句
2.3.2 表达式语句
2.3.3 选择语句
2.3.4 循环语句
2.3.5 迭代与递归
2.3.6 控制转移语句
2.3.7 注释语句
2.4 思考与练习
第3章 Java对象的生命周期
3.1 面向对象技术
3.1.1 面向过程与面向对象的比较
3.1.2 面向对象技术的基本原则
3.1.3 面向对象技术的基本要素
3.1.4 软件开发过程的面向对象技术
3.1.5 Java语言中的一些基本术语
3.2 对象声明
3.2.1 对象的声明方式
3.2.2 引用变量与对象的关系
3.3 对象的创建
3.3.1 创建方式
3.3.2 对象的初始化
3.3.3 继承链上相关类的加载顺序以及构造方法链的调用
3.4 对象的使用
3.4.1 使用了哪个对象
3.4.2 使用了哪个方法
3.4.3 使用了哪个属性
3.4.4 内部类
3.5 对象清除
3.5.1 垃圾自动收集机制
3.5.2 调用垃圾收集方法
3.5.3 finalize方法的利用
3.6 思考与练习
第4章 对象设计的Java规范
4.1 规范概述
4.1.1 硬约束与软约束
4.1.2 软件工程的要求
4.1.3 面向对象设计原则
4.2 Java语言的Object类及标准包
4.2.1 Object类
4.2.2 java.1 ang包
4.2.3 Java标准包
4.3 Java的异常处理机制
4.3.1 异常处理
4.3.2 核心代码与异常处理分离机制
4.3.3 引发异常及对异常处理的两条途径
4.3.4 Java的内置异常类
4.3.5 设计异常类
4.3.6 断言语句
4.3.7 对异常不作为与作为的区别
4.4 包.接口.类与方法设计
4.4.1 包设计
4.4.2 制作JAR文件包
4.4.3 接口设计
4.4.4 抽象类设计
4.4.5 类设计
4.4.6 方法设计
4.4.7 设计模式
4.5 Java编码的其他规范
4.5.1 命名规范
4.5.2 文件组织样式
4.5.3 增加程序可读性的一些建议
4.5.4 完整的例子
4.6 思考与练习
第5章 Java的线程
5.1 线程的概念与POSIX标准
5.1.1 现成的概念
5.1.2 线程的POSIX标准
5.2 多线程的Java实现
5.2.1 线程的创建方法
5.2.2 线程的状态
5.3 互斥线程间的同步机制
5.3.1 多线程带来的冲突问题
5.3.2 共享资源合理使用的实现
5.3.3 按同步协调程度划分的线程间的关系
5.4 java.util.concurrent包简介
5.5 思考与练习
第6章 Java的输入输出
6.1 流输入输出类的层次结构
6.1.1 流的概念
6.1.2 字.节流
6.1.3 字符流
6.1.4 输入输出类的分类
6.1.5 标准流及其重定向
6.1.6 IOExeeption及其子类
6.2 输人输出流类的应用
6.2.1 输入输出流类的般例子
6.2.2 典型的输入输出流类的组合应用
6.2.3 格式化输出
6.3 数据持久化
6.3.1 对象串行化
6.3.2 XML文件的输入输出
6.3.3 JDBC入门
6.4 文件类的应用
6.4.1 File类
6.4.2 File类应用举例
6.5 思考与练习
第7章 Java的集合框架与泛型
7.1 集合API
7.2 Collection与Iterator
7.2.1 Collection接口
7.2.2 迭代器Iterator
7.2.3 1terator的使用举例
7.3 List.LinkedList与List
7.3.1 List接口
7.3.2 LinkedList与ArrayList类
7.3.3 List的使用举例
7.4 Set.SortedSEt.HashSet与TreeSet
7.4.1 Set和SortedSEt接口
7.4.2 HashSet.TreeSet和LinkedHashSet类
7.4.3 Set的使用举例
7.5 Map.SortedMap接口及其实现类
7.5.1 Map接口
7.5.2 SortedMap接口
7.5.3 HashMap.TreeMap和LinkedHashMap等实现类
7.5.4 Map的使用举例
7.6 泛型类型
7.6.1 向下转型与ClassCastException异常
7.6.2 泛型的定义
7.6.3 泛型的使用
7.6.4 泛型的设计
7.7 思考与练习
第8章 Java的图形用户界面
8.1 JFC的组成
8.1.1 AWT
8.1.2 Swing
8.1.3 DragandDrop
8.1.4 Java2D
8.1.5 JavaAccessibility
8.2 应用程序和小程序界面图形化
8.2.1 Swing的根面板
8.2.2 小程序的典型例子
8.2.3 应用程序的典型例子
8.2.4 结合小程序和应用程序的典型例子
8.3 AWT的组件布局管理模型
8.3.1 基于策略模式的授权模型
8.3.2 布局管理器类
8.4 AWT的事件处理模型
8.4.1 基于观察者模式的授权模型
8.4.2 事件源
8.4.3 事件类
8.4.4 事件监听器
8.4.5 创建事件监听器对象
8.5 思考与练习
附录源代码清单
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java面向对象程序设计教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计实践教程
第1章 Java概述	1
1.1 Java的发展	1
1.1.1 Java的发展史	1
1.1.2 Java与C、C++和C#的
关系	2
1.2 Java的特点	3
1.3 面向对象程序设计	4
1.3.1 封装	5
1.3.2 继承	5
1.3.3 多态性	6
1.3.4 Java的开发工具	6
1.4 一个简单的Java程序	7
1.4.1 编写Java程序	7
1.4.2 编译和执行Java程序	8
1.4.3 Java程序的基本要素	9
1.5 实验指导	12
1.6 思考与练习	13
第2章 数据类型与运算符	15
2.1 常量、变量和表达式	15
2.1.1 常量	15
2.1.2 变量	16
2.2 数据类型	18
2.2.1 整数类型	19
2.2.2 浮点类型	20
2.2.3 字符类型	21
2.2.4 布尔类型	22
2.2.5 类型之间的转换	22
2.2.6 转义序列	23
2.3 运算符和表达式	24
2.3.1 算术运算符	25
2.3.2 关系运算符和逻辑运算符	28
2.3.3 位运算符	29
2.3.4 赋值运算符和条件运算符	30
2.3.5 扩展运算符	31
2.3.6 其他运算符	32
2.3.7 运算符优先级	33
2.4 实验指导	33
2.5 思考与练习	34
第3章 程序控制语句	36
3.1 选择语句	36
3.1.1 简单的if语句	36
3.1.2 if-else语句	37
3.1.3 if嵌套语句	38
3.1.4 switch语句	40
3.2 循环语句	42
3.2.1 while循环语句	42
3.2.2 do-while循环语句	43
3.2.3 for循环语句	45
3.3 与程序有关的其他语句	47
3.3.1 break语句	47
3.3.2 continue语句	51
3.3.3 return语句	52
3.4 实验指导	53
3.5 思考与练习	53
第4章 数组	56
4.1 一维数组	56
4.1.1 声明数组和创建数组	56
4.1.2 一维数组初始化及元素
引用	57
4.2 多维数组	60
4.2.1 声明数组和创建数组	60
4.2.2 初始化数组	61
4.2.3 数组程序举例	62
4.3 不规则数组	67
4.4 搜索数组	70
4.5 排序数组	72
4.5.1 选择排序	72
4.5.2 冒泡排序	73
4.5.3 快速排序	75
4.6 实验指导	76
4.7 思考与练习	78
第5章 类、对象和方法	79
5.1 Java类	79
5.1.1 类的基本形式	79
5.1.2 类的定义	80
5.2 创建对象	82
5.3 对象引用变量	83
5.4 方法	84
5.4.1 添加方法	85
5.4.2 调用对象的方法	86
5.4.3 将对象传递给方法	87
5.5 构造函数和垃圾回收	88
5.5.1 构造函数	88
5.5.2 垃圾回收	89
5.6 new运算符	90
5.7 类成员的访问控制	90
5.8 共享变量、常量和静态方法	91
5.9 this关键字	94
5.10 对象数组	95
5.11 实验指导	97
5.12 思考与练习	98
第6章 继承和接口	101
6.1 继承	101
6.1.1 超类和子类	101
6.1.2 成员访问和继承	103
6.2 super关键字	105
6.2.1 使用super调用超类
构造函数	106
6.2.2 使用super访问超类成员	109
6.2.3 创建多级层次结构	110
6.2.4 何时调用构造函数	112
6.3 方法重载和方法重写	113
6.3.1 方法重载	113
6.3.2 方法重写	114
6.3.3 重写的方法支持多态性	115
6.3.4 使用重写方法的原因	116
6.4 抽象类	117
6.5 继承中的final修饰符	119
6.5.1 使用final防止重写	119
6.5.2 使用final防止继承	120
6.6 Object类	120
6.6.1 clone方法	121
6.6.2 equals方法	121
6.6.3 toString方法	122
6.7 接口	122
6.7.1 接口定义	122
6.7.2 实现接口	123
6.7.3 接口引用	126
6.7.4 接口中的变量	128
6.7.5 接口的扩展	129
6.8 实验指导	130
6.9 思考与练习	131
第7章 字符串	133
7.1 字符类	133
7.1.1 构造字符串	133
7.1.2 匹配字符串	136
7.1.3 求字符串长度和检索
单个字符	136
7.1.4 字符串比较	137
7.1.5 查找子字符串	138
7.2 Character类	141
7.2.1 Character类的介绍	141
7.2.2 Character类方法的应用	142
7.3 StringBuffer类	144
7.3.1 构造StringBuffer类	145
7.3.2 StringBuffer类常用方法	146
7.3.3 StringBuffer类特有的
方法	148
7.3.4 StringBuffer类特有方法
的应用示例	148
7.4 实验指导	151
7.5 思考与练习	152
第8章 包和Applet	155
8.1 包	155
8.1.1 定义包	155
8.1.2 导入包	156
8.1.3 类路径（CLASSPATH）	157
8.1.4 访问控制	157
8.2 applet程序	160
8.2.1 applet类	160
8.2.2 请求重绘	163
8.3 HTML APPLET标记	164
8.4 将参数传递到applet	165
8.5 实验指导	166
8.6 思考与练习	167
第9章 GUI编程基础	169
9.1 GUI类	169
9.2 框架	171
9.2.1 创建框架	171
9.2.2 在框架内添加组件	172
9.3 布局管理	173
9.3.1 FlowLayout	173
9.3.2 GridLayout	174
9.3.3 BorderLayout	175
9.3.4 CardLayout	177
9.3.5 GridBagLayout	179
9.3.6 null	182
9.4 面板容器	183
9.5 事件	185
9.5.1 事件和事件源	185
9.5.2 事件监听	186
9.5.3 处理事件	188
9.6 用户界面对象（UI）	192
9.6.1 按钮	192
9.6.2 标签	195
9.6.3 单行文本框和多行文
本域	196
9.6.4 复选框和单选按钮	199
9.6.5 组合框	203
9.6.6 滚动条	206
9.6.7 滚动面板	209
9.6.8 菜单	210
9.7 GUI绘图	213
9.7.1 颜色	214
9.7.2 绘制几何图形	214
9.7.3 显示字体	218
9.8 实验指导	221
9.9 思考与练习	223
第10章 异常处理	227
10.1 异常和异常类型	227
10.1.1 异常的含义	227
10.1.2 异常类型	228
10.2 理解异常处理	228
10.3 声明异常（throws）	230
10.4 抛出异常（throw）	231
10.5 捕获异常	233
10.5.1 使用try-catch	233
10.5.2 使用多重catch语句	235
10.5.3 嵌套try语句	236
10.6 finally的用法	238
10.7 异常的应用	240
10.7.1 Java中的内置异常	241
10.7.2 创建自定义的异常类	242
10.7.3 输出警告信息	244
10.7.4 应用异常的建议	245
10.8 实验指导	246
10.9 思考与练习	248
第11章 线程与多线程	251
11.1 线程与多线程	251
11.1.1 线程的性质	252
11.1.2 线程的状态	254
11.1.3 守护线程	254
11.2 创建线程	256
11.2.1 扩展Thread类创建
线程	257
11.2.2 实现Runnable接口
创建线程	259
11.2.3 创建多线程	260
11.3 多线程程序设计	263
11.3.1 多线程同时运行	263
11.3.2 多线程优先级调度	267
11.3.3 多线程的互斥和同步	269
11.3.4 死锁	276
11.4 多线程的控制	280
11.4.1 判断线程是否结束	281
11.4.2 线程阻塞	283
11.4.3 处理线程阻塞	284
11.5 线程的应用	288
11.5.1 为applet创建线程	289
11.5.2 使用Timer类来控制
动画	290
11.6 实验指导	295
11.7 思考与练习	295
第12章 输入输出系统	297
12.1 Java的I/O基于流	297
12.1.1 字节流	298
12.1.2 字符流	299
12.1.3 预定义流	300
12.2 字节流	302
12.2.1 InputStream类和
OutputStream类	302
12.2.2 文件字节流的顺序
输入输出	303
12.2.3 文件字节流的随机
访问	306
12.3 过滤流	308
12.3.1 DataInputStream和
DataOutputStream	309
12.3.2 BufferedInputStream和
BufferedOutputStream	310
12.3.3 LineNumberInputStream	311
12.3.4 PushbackInputStream	312
12.4 字符流	313
12.4.1 基类Reader和Writer	313
12.4.2 InputStreamReader和
OutputStreamWriter	314
12.4.3 FileReader和
FileWriter	315
12.4.4 BufferedReader和
BufferedWriter	316
12.4.5 PrintWriter类	317
12.5 File类	318
12.5.1 File类的3种构造
函数	318
12.5.2 File类的常用方法	319
12.6 对象的串行化	321
12.7 实验指导	325
12.8 思考与练习	326
第13章 网络通信和多媒体	328
13.1 网络基础知识	328
13.1.1 域名和IP地址	328
13.1.2 端口号(port)	330
13.2 Socket（套接字）通信	330
13.3 UDP和FTP类型通信	334
13.3.1 UDP通信介绍	334
13.3.2 FTP通信介绍	335
13.4 applet通信	336
13.4.1 同页applet之间的
通信	336
13.4.2 applet和浏览器之间的
通信	340
13.5 多媒体	342
13.5.1 Applet中播放音频	342
13.5.2 Applet中显示图像	345
13.5.3 在应用程序中载入图像
和音频文件	347
13.5.4 显示一列图像	351
13.5.5 MediaTracker	353
13.6 实验指导	355
13.7 思考与练习	356
第14章 数据库编程	358
14.1 JDBC简介	358
14.2 JDBC应用模型	359
14.3 java.sql包	360
14.4 访问数据库	360
14.4.1 配置ODBC数据源	360
14.4.2 加载JDBC驱动程序	361
14.4.3 创建数据库连接	362
14.4.4 执行SQL语句	363
14.4.5 处理结果集	364
14.4.6 更新数据库	369
14.4.7 数据库连接	372
14.5 使用预编译SQL语句	373
14.6 获取数据库信息	375
14.7 实验指导	377
14.8 思考与练习	378
第15章 Java的数据结构	381
15.1 了解Java集合架构	381
15.2 Collection接口、Map接口及
其子接口	383
15.2.1 Collection接口	383
15.2.2 Set接口和SortedSet
接口	384
15.2.3 List接口	384
15.2.4 Map接口和SortedMap
接口	385
15.3 AbstractSet类和HashSet类	386
15.4 TreeSet类和Comparator接口	387
15.4.1 使用TreeSet类	387
15.4.2 使用Comparator接口	388
15.5 ArrayList类和LinkedList类	389
15.6 Vector类和Stack类	390
15.7 HashMap类和TreeMap类	392
15.8 Collections类和Arrays类	395
15.8.1 使用Collections类	395
15.8.2 使用Arrays类	398
15.9 实验指导	400
15.10 思考与练习	400
附录 思考与练习答案	402
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计实践教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言程序设计(21世纪高等学校计算机专业实用规划教材)/好程序员成长丛书
第1章Java开发入门
1.1Java概述
1.1.1认识Java
1.1.2Java发展史
1.1.3Java语言的特点
1.2JDK的使用
1.2.1下载JDK
1.2.2安装JDK
1.2.3配置JDK
1.2.4测试开发环境
1.2.5JDK目录介绍
1.3第一个Java程序
1.3.1编写Java源文件
1.3.2编译运行
1.3.3Java虚拟机(JVM)
1.4Java运行流程
1.5本章小结
1.6习题
第2章Java编程基础
2.1Java的基本语法
2.1.1语句和表达式
2.1.2基本格式
2.1.3注释
2.1.4关键字
2.1.5进制转换
2.2基本数据类型

2.2.1整数类型
2.2.2浮点数类型
2.2.3字符类型
2.2.4布尔类型

2.3变量与常量
2.3.1标识符
2.3.2变量的定义
2.3.3变量的类型转换
2.3.4变量的作用域
2.3.5常量
2.4Java中的运算符
2.4.1算术运算符
2.4.2赋值运算符
2.4.3关系运算符
2.4.4逻辑运算符
2.4.5位运算符
2.4.6运算符的优先级
2.5程序的结构
2.5.1顺序结构
2.5.2选择结构
2.5.3循环结构
2.5.4循环中断
2.6本章小结
2.7习题
第3章数组与方法
3.1数组
3.1.1数组的定义
3.1.2数组的初始化
3.1.3数组的常用操作
3.1.4数组的内存原理
3.1.5二维数组
3.2方法
3.2.1方法的定义
3.2.2方法的调用
3.2.3方法的重载
3.2.4方法的递归
3.3数组的引用传递
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言程序设计(21世纪高等学校计算机专业实用规划教材)/好程序员成长丛书
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件是这样“炼”成的——Java学习全演练
目录
第1章何为面向对象
1.1面向对象的基础知识
1.2面向对象的核心概念
1.2.1对象
1.2.2类
1.2.3继承
1.2.4接口
1.2.5封装与透明
1.2.6多态
1.2.7组合
1.2.8绑定
1.2.9消息
1.3类间关系
1.3.1关联
1.3.2聚合
1.3.3继承
1.3.4实现
1.3.5依赖
1.3.6包
1.4本章小结
第2章Java是什么
2.1Java程序设计语言
2.1.1什么是程序设计语言
2.1.2程序设计语言发展历史
2.2Java发展历史
2.3Java跨平台原理
2.3.1高级程序编译原理
2.3.2Java跨平台原理
2.3.3Java的特点
2.4Java开发环境搭建
2.4.1JDK安装
2.4.2MyEclipse介绍及安装
2.5本章小结
第3章JDK API介绍
3.1关于JDK的讨论
3.2JDK基础类型介绍
3.3数据集合及日期处理
3.4输入输出流
3.5ZIP压缩工具
3.6JAR归档工具
3.7日志工具
3.8网络编程
3.8.1地址
3.8.2套接字
3.8.3接口
3.8.4高级API
3.9用户界面（Java.awt）
3.9.1Java.awt介绍
3.9.2其他包介绍
3.10Java.swing
3.11数据库操作
3.11.1Java.sql
3.11.2Javax.sql
3.12本章小结
第4章规范Java编程
4.1关于编程规范的讨论
4.2帮助文件范例
4.2.1版本信息
4.2.2字段概要
4.2.3方法及构造方法摘要
4.2.4字段详细信息
4.2.5方法或构造方法详细
信息
4.3Java编程规范
4.3.1排版规范
4.3.2注释规范
4.3.3命名规范
4.3.4编码规范
4.4JavaDoc文档
4.4.1JavaDoc介绍
4.4.2JavaDoc标记
4.4.3JavaDoc命令的用法
4.5本章小结
第5章本书唯一案例说明
5.1案例假设
5.2用户资料整理
5.3实现功能
5.3.1学校信息维护
5.3.2学院信息查询
5.3.3系信息查询
5.3.4系分专业学生名录
5.3.5系分专业综合成绩排名
5.3.6关于学生信息维护
5.4“学籍管理软件”在本书中的应用
5.5不可思议的代码
第6章Java源程序组成
6.1Java源程序包含的基本内容
6.1.1包
6.1.2类定义
6.1.3方法定义
6.1.4数据成员
6.2使用JDK编译和运行程序
6.2.1编译Java源文件
6.2.2运行Java程序
6.3代码展示——类初步规划
6.3.1案例分析
6.3.2部分代码展示
6.4代码解析
6.4.1代码分析
6.4.2进程检查
6.5本章小结
第7章探讨类数据成员——数据
类型
7.1基本数据类型
7.1.1基本概念
7.1.2详细说明
7.1.3简单数据类型的转换
7.1.4Java中的高精度数
7.2引用类型
7.3变量和常量
7.3.1变量
7.3.2常量
7.3.3变量的作用范围
7.3.4静态变量的生命周期
7.3.5对象的默认引用
——this关键字
7.4参数传递
7.5“学籍管理软件”数据类型设计
7.5.1JDK Java包引用分析
7.5.2“学籍管理软件”数据类型
与变量设计
7.6代码实现
7.6.1“学籍管理软件”中全局
变量校验实现
7.6.2部分代码摘录
7.7进程检查
7.8本章小结
第8章类方法成员——操作符
8.1运算符
8.1.1算术运算符
8.1.2关系运算符
8.1.3逻辑运算符
8.1.4位运算符
8.1.5其他运算符
8.1.6运算符的优先级
8.2Java修饰符
8.3“学籍管理软件”运算符应用
分析
8.3.1关于业务规则讨论
8.3.2部分实现代码摘录
8.4进程检查表
8.5本章小结
第9章探讨类方法成员——流程
控制
9.1流程控制
9.2条件转换语句
9.2.1if 语句
9.2.2ifelse
9.2.3ifelse if语句
9.2.4if语句的嵌套
9.2.5switch语句
9.3循环语句
9.3.1for循环语句
9.3.2while循环语句
9.3.3do while循环语句
9.3.4循环语句的嵌套
9.3.5转移语句
9.4“学籍管理软件”案例分析运行流程
控制
9.4.1“学籍管理软件”运行
流程
9.4.2类优化设计
9.5“学籍管理软件”业务数据校验
代码展示
9.6进程检查
9.7本章小结
第10章异常处理及应用
10.1Java异常处理机制
10.2用户异常定义
10.3Java异常分类
10.3.1可检测异常
10.3.2非检测异常
10.3.3自定义异常
10.4异常处理
10.4.1Java异常处理方法
10.4.2异常声明及抛出异常
10.5“学籍管理软件”异常设计
10.5.1关于异常的探讨
10.5.2“学籍管理软件”流程优化
——异常思考
10.6“学籍管理软件”异常设计实现类
代码分析
10.6.1“学籍管理软件”
类优化
10.6.2异常设计代码实现
10.7进程检查表
10.8本章小结
第11章类间关系之继承应用
11.1继承设计的基本流程
11.2方法重载
11.3方法覆盖
11.4super关键字
11.5“学籍管理软件”优化设计
11.5.1关于继承的讨论
11.5.2类间关系优化设计
——继承的思想
11.5.3程序运行流程——重载
的思想
11.5.4异常处理——继承
的思想
11.6部分程序代码——继承及重载
的思想
11.6.1父类——学校信息
维护
11.6.2子类——学院信息
维护
11.6.3父类与子类的整合——
学生信息维护页面
11.6.4重载方法——统计分析
类框架代码
11.7继承及重载优化进程检查
11.8本章小结
第12章类间关系之抽象类与
接口应用
12.1抽象类
12.2接口
12.2.1接口的概念
12.2.2接口的实现
12.3接口与抽象类
12.4多态
12.5“学籍管理软件”优化设计
12.6“学籍管理软件”接口及接口
实现代码
12.6.1业务查询接口
（bussinessSearch）
12.6.2数据删除接口
（bussinessDelete）
12.6.3统计分析类
（bussinessStatistics）
12.6.4信息查询类（bussiness
LogicListSearch）
12.7进程检查——类抽象与接口
应用
12.8本章小结
第13章Java数据结构之数组
13.1一维数组创建
13.2一维数组元素访问
13.3二维数组创建
13.4二维数组元素访问
13.5本章小结
第14章Java数据结构之常用集合
14.1Java集合概述
14.2Collection接口和Iterator接口
14.2.1AbstractCollection
抽象类
14.2.2Iterator 接口
14.2.3Collection接口支持的
其他操作
14.3Set
14.3.1HashSet类和
TreeSet类
14.3.2AbstractSet类
14.4List
14.4.1ListIterator接口
14.4.2ArrayList 类和
LinkedList类
14.5Map
14.5.1Map接口概述
14.5.2Map.Entry接口
14.5.3SortedMap接口
14.5.4AbstractMap抽象类
——Abstrac
14.5.5HashMap类和
TreeMap类
14.5.6LinkedHashMap类
14.5.7Map例程
14.6本章小结
第15章数据结构在“学籍管理软件”
中的应用
15.1关于Java集合的讨论
15.2“学籍管理软件”数据
结构设计
15.2.1数据分析
15.2.2数据结构设计
15.3类优化
15.4查询算法设计
15.5“学籍管理软件”数据结构代码
实现
15.5.1学生名单排序实体
15.5.2考试成绩排序
15.6进程检查——数据结构完善
第16章数据输入输出——Java IO流
16.1Java数据流概述和Java.IO
16.1.1流的概念
16.1.2Java.IO包
16.2InputStream与
OutputStream类
16.2.1InputStream类
16.2.2OutputStream类
16.3File类
16.3.1File类的构造函数
16.3.2File类举例
16.4文件输入与输出
16.4.1FileInputStream类和
FileOutputStream类
16.4.2FileInputStream和
FileOutputStream在“学籍
管理软件”中的应用
16.4.3随机文件的读取
RandomAccessFile类
16.5标准输入和输出
16.5.1System.in对象
16.5.2System.out对象
16.5.3数据类型的转换
16.6本章小结
第17章数据存储与读取在“学籍
管理软件”中的应用
17.1数据存储及文件规划
17.1.1数据存储说明
17.1.2数据表间关系
17.1.3表结构设计
17.2类优化设计
17.3程序流程优化
17.4数据保存及查询
17.4.1数据保存
17.4.2数据读取
17.5Java IO异常处理
17.6数据存储与读取代码实现
17.6.1文件管理
17.6.2数据保存
17.6.3多记录查询
17.7数据读取与存储实现进程检查
17.8本章小结
第18章Java图形界面在“学籍管理
软件”中的应用
18.1用AWT生成图形化用户界面
18.2组件
18.3容器
18.4事件处理
18.4.1事件类
18.4.2事件监听器
18.4.3AWT事件相应的监听器
接口
18.4.4事件适配器
18.5AWT组件库
18.6“学籍管理软件”页面设计
18.6.1页面构成
18.6.2主界面程序代码
18.6.3维护页面button影响
矩阵图
18.7案例进程
18.8本章小结
第19章Java Swing在“学籍管理
软件”中的应用
19.1Java Swing介绍
19.2Javax主要控件介绍
19.2.1AbstractButton
19.2.2ButtonGroup
19.2.3JApplet
19.2.4JButton
19.2.5JCheckBox和
JRadioButton
19.2.6JComboBox
19.2.7JScrollPane
19.2.8JTable
19.2.9JTextField
19.2.10JTextArea
19.2.11JTree
19.3基于Java Swing优化“学籍
管理软件”设计
19.3.1基于MVC设计模式设计
“学籍管理软件”
19.3.2类图优化设计——
基于MVC
19.3.3“学籍管理软件”页面
设计实现代码摘录
19.4“学籍管理软件”案例
进程检查
19.5本章小结
第20章多线程简述
20.1Java多线程
20.2Java多线程的5种基本状态
20.3Java多线程的创建及启动
20.3.1继承Thread方法创建线
程并启动线程
20.3.2使用Runnable接口来
创建并启动线程
20.3.3使用 ExecutorService、
Callable和Future创建
线程
20.4Java多线程的优先级和调度
20.5多线程的线程控制
20.6线程的同步
20.6.1同步代码块
20.6.2同步方法
20.6.3使用特殊域变量(volatile)
实现线程同步
20.6.4使用重入锁实现
线程同步
20.6.5使用局部变量实
现线程同步
20.7线程间的通信
20.7.1线程间的通信
20.7.2线程通信的其他几个
常用方法
20.8本章小结
第21章Java学习历程回顾
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件是这样“炼”成的——Java学习全演练
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>网络数据采集技术：Java网络爬虫实战
目录
第1 章 网络爬虫概述与原理 ............................................................................ 1
1.1 网络爬虫简介 ............................................................................................. 1
1.2 网络爬虫分类 ............................................................................................. 2
1.3 网络爬虫流程 ............................................................................................. 4
1.4 网络爬虫的采集策略 ................................................................................. 5
1.5 学习网络爬虫的建议 ................................................................................. 5
1.6 本章小结 ..................................................................................................... 6
第2 章 网络爬虫涉及的Java 基础知识 ........................................................... 7
2.1 开发环境的搭建 ......................................................................................... 7
2.1.1 JDK 的安装及环境变量配置 .......................................................... 7
2.1.2 Eclipse 的下载 .................................................................................. 9
2.2 基本数据类型 ........................................................................................... 10
2.3 数组 ........................................................................................................... 11
2.4 条件判断与循环 ....................................................................................... 12
2.5 集合 ........................................................................................................... 15
2.5.1 List 和Set 集合 .............................................................................. 15
2.5.2 Map 集合 ........................................................................................ 16
2.5.3 Queue 集合 ..................................................................................... 17
2.6 对象与类 ................................................................................................... 19
2.7 String 类 ..................................................................................................... 21
2.8 日期和时间处理 ....................................................................................... 23
2.9 正则表达式 ............................................................................................... 26
2.10 Maven 工程的创建 ................................................................................. 29
2.11 log4j 的使用 ............................................................................................ 33
2.12 本章小结 ................................................................................................. 40
第3 章 HTTP 协议基础与网络抓包 ............................................................... 41
3.1 HTTP 协议简介 ........................................................................................ 41
3.2 URL ........................................................................................................... 42
3.3 报文 ........................................................................................................... 44
3.4 HTTP 请求方法 ........................................................................................ 46
3.5 HTTP 状态码 ............................................................................................ 46
3.5.1 状态码2XX .................................................................................... 47
3.5.2 状态码3XX .................................................................................... 47
3.5.3 状态码4XX .................................................................................... 48
3.5.4 状态码5XX .................................................................................... 48
3.6 HTTP 信息头 ............................................................................................ 48
3.6.1 通用头 ............................................................................................ 49
3.6.2 请求头 ............................................................................................ 52
3.6.3 响应头 ............................................................................................ 55
3.6.4 实体头 ............................................................................................ 56
3.7 HTTP 响应正文 ........................................................................................ 57
3.7.1 HTML ............................................................................................. 58
3.7.2 XML ............................................................................................... 60
3.7.3 JSON ............................................................................................... 61
3.8 网络抓包 ................................................................................................... 64
3.8.1 简介 ................................................................................................ 64
3.8.2 使用情境 ........................................................................................ 65
3.8.3 浏览器实现网络抓包 ..................................................................... 65
3.8.4 其他网络抓包工具推荐 ................................................................. 70
3.9 本章小结 ................................................................................................... 70
第4 章 网页内容获取 .................................................................................... 71
4.1 Jsoup 的使用 ............................................................................................. 71
4.1.1 jar 包的下载 ................................................................................... 71
4.1.2 请求URL ....................................................................................... 72
4.1.3 设置头信息 .................................................................................... 75
4.1.4 提交请求参数 ................................................................................ 78
4.1.5 超时设置 ........................................................................................ 80
4.1.6 代理服务器的使用 ......................................................................... 81
4.1.7 响应转输出流（图片、PDF 等的下载）..................................... 83
4.1.8 HTTPS 请求认证 ........................................................................... 85
4.1.9 大文件内容获取问题 ..................................................................... 89
4.2 HttpClient 的使用 ...................................................................................... 91
4.2.1 jar 包的下载 ................................................................................... 91
4.2.2 请求URL ....................................................................................... 92
4.2.3 EntityUtils 类 .................................................................................. 97
4.2.4 设置头信息 .................................................................................... 98
4.2.5 POST 提交表单 ............................................................................ 100
4.2.6 超时设置 ...................................................................................... 103
4.2.7 代理服务器的使用 ....................................................................... 105
4.2.8 文件下载 ...................................................................................... 106
4.2.9 HTTPS 请求认证 ......................................................................... 108
4.2.10 请求重试 .................................................................................... 111
4.2.11 多线程执行请求 ......................................................................... 114
4.3 URLConnection 与HttpURLConnection ................................................ 117
4.3.1 实例化 .......................................................................................... 117
4.3.2 获取网页内容 .............................................................................. 118
4.3.3 GET 请求 ...................................................................................... 118
4.3.4 模拟提交表单（POST 请求） .................................................... 119
4.3.5 设置头信息 .................................................................................. 120
4.3.6 连接超时设置 .............................................................................. 121
4.3.7 代理服务器的使用 ....................................................................... 122
4.3.8 HTTPS 请求认证 ......................................................................... 122
4.4 本章小结 ................................................................................................. 124
第5 章 网页内容解析 .................................................................................. 125
5.1 HTML 解析 ............................................................................................. 125
5.1.1 CSS 选择器 .................................................................................. 125
5.1.2 Xpath 语法 .................................................................................... 127
5.1.3 Jsoup 解析HTML ........................................................................ 128
5.1.4 HtmlCleaner 解析HTML ............................................................. 135
5.1.5 HTMLParser 解析HTML ............................................................ 139
5.2 XML 解析 ............................................................................................... 144
5.3 JSON 解析 ............................................................................................... 145
5.3.1 JSON 校正 .................................................................................... 145
5.3.2 org.json 解析JSON ...................................................................... 147
5.3.3 Gson 解析JSON........................................................................... 152
5.3.4 Fastjson 解析JSON ...................................................................... 157
5.3.5 网络爬虫实战演练 ....................................................................... 159
5.4 本章小结 ................................................................................................. 165
第6 章 网络爬虫数据存储 ........................................................................... 166
6.1 输入流与输出流 ..................................................................................... 166
6.1.1 简介 .............................................................................................. 166
6.1.2 File 类 ........................................................................................... 166
6.1.3 文件字节流 .................................................................................. 169
6.1.4 文件字符流 .................................................................................. 172
6.1.5 缓冲流 .......................................................................................... 176
6.1.6 网络爬虫下载图片实战 ............................................................... 180
6.1.7 网络爬虫文本存储实战 ............................................................... 184
6.2 Excel 存储 ............................................................................................... 188
6.2.1 Jxl 的使用 ..................................................................................... 188
6.2.2 POI 的使用 ................................................................................... 191
6.2.3 爬虫案例 ...................................................................................... 198
6.3 MySQL 数据存储 ................................................................................... 202
6.3.1 数据库的基本概念 ....................................................................... 203
6.3.2 SQL 语句基础 .............................................................................. 203
6.3.3 Java 操作数据库 .......................................................................... 207
6.3.4 爬虫案例 ...................................................................................... 217
6.4 本章小结 ................................................................................................. 219
第7 章 网络爬虫实战项目 ........................................................................... 220
7.1 新闻数据采集 ......................................................................................... 220
7.1.1 采集的网页 .................................................................................. 220
7.1.2 框架介绍 ...................................................................................... 222
7.1.3 程序编写 ...................................................................................... 223
7.2 企业信息采集 ......................................................................................... 235
7.2.1 采集的网页 .................................................................................. 235
7.2.2 框架介绍 ...................................................................................... 238
7.2.3 第一层信息采集........................................................................... 239
7.2.4 第二层信息采集........................................................................... 248
7.3 股票信息采集 ......................................................................................... 256
7.3.1 采集的网页 .................................................................................. 256
7.3.2 框架介绍 ...................................................................................... 257
7.3.3 程序设计 ...................................................................................... 258
7.3.4 Quartz 实现定时调度任务 ........................................................... 267
7.4 本章小结 ................................................................................................. 271
第8 章 Selenium 的使用 ............................................................................. 272
8.1 Selenium 简介 ......................................................................................... 272
8.2 Java Selenium 环境搭建 ......................................................................... 272
8.3 浏览器的操控 ......................................................................................... 274
8.4 元素定位 ................................................................................................. 276
8.4.1 id 定位 .......................................................................................... 276
8.4.2 name 定位 ..................................................................................... 277
8.4.3 class 定位 ...................................................................................... 278
8.4.4 tag name 定位 ............................................................................... 278
8.4.5 link text 定位 ................................................................................ 278
8.4.6 Xpath 定位 .................................................................................... 279
8.4.7 CSS 选择器定位 .......................................................................... 279
8.5 模拟登录 ................................................................................................. 280
8.6 动态加载JavaScript 数据（操作滚动条） ........................................... 283
8.7 隐藏浏览器 ............................................................................................. 285
8.8 截取验证码 ............................................................................................. 287
8.9 本章小结 ................................................................................................. 291
第9 章 网络爬虫开源框架 ........................................................................... 292
9.1 Crawler4j 的使用 .................................................................................... 292
9.1.1 Crawler4j 简介.............................................................................. 292
9.1.2 jar 包的下载 ................................................................................. 292
9.1.3 入门案例 ...................................................................................... 293
9.1.4 相关配置 ...................................................................................... 297
9.1.5 图片的采集 .................................................................................. 300
9.1.6 数据采集入库 .............................................................................. 304
9.2 WebCollector 的使用 .............................................................................. 312
9.2.1 WebCollector 简介 ....................................................................... 312
9.2.2 jar 包的下载 ................................................................................. 313
9.2.3 入门案例 ...................................................................................... 313
9.2.4 相关配置 ...................................................................................... 318
9.2.5 HTTP 请求扩展............................................................................ 319
9.2.6 翻页数据采集 .............................................................................. 327
9.2.7 图片的采集 .................................................................................. 331
9.2.8 数据采集入库 .............................................................................. 334
9.3 WebMagic 的使用 ................................................................................... 347
9.3.1 WebMagic 简介 ............................................................................ 347
9.3.2 jar 包的下载 ................................................................................. 347
9.3.3 入门案例（翻页数据采集） ....................................................... 347
9.3.4 相关配置 ...................................................................................... 351
9.3.5 数据存储方式 .............................................................................. 352
9.3.6 数据采集入库 .............................................................................. 355
9.3.7 图片的采集 .................................................................................. 365
9.4 本章小结 ................................................................................................. 368
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>网络数据采集技术：Java网络爬虫实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Netty实战
第一部分 Netty的概念及体系结构
第1 章 Netty——异步和事件驱动 3
1.1 Java 网络编程 4
1.1.1 Java NIO 5
1.1.2 选择器 6
1.2 Netty 简介 6
1.2.1 谁在使用Netty 7
1.2.2 异步和事件驱动 8
1.3 Netty 的核心组件 9
1.3.1 Channel 9
1.3.2 回调 9
1.3.3 Future 10
1.3.4 事件和ChannelHandler 11
1.3.5 把它们放在一起 12
1.4 小结 13
第2 章 你的第一款Netty应用程序 14
2.1 设置开发环境 14
2.1.1 获取并安装Java 开发工具包 14
2.1.2 下载并安装IDE 15
2.1.3 下载和安装Apache Maven 15
2.1.4 配置工具集 16
2.2 Netty 客户端/服务器概览 16
2.3 编写Echo 服务器 17
2.3.1 ChannelHandler 和业务逻辑 17
2.3.2 引导服务器 18
2.4 编写Echo 客户端 21
2.4.1 通过ChannelHandler 实现客户端逻辑 21
2.4.2 引导客户端 22
2.5 构建和运行Echo 服务器和客户端 24
2.5.1 运行构建 24
2.5.2 运行Echo 服务器和客户端 27
2.6 小结 29
第3 章 Netty 的组件和设计 30
3.1 Channel、EventLoop 和ChannelFuture 30
3.1.1 Channel 接口 31
3.1.2 EventLoop 接口 31
3.1.3 ChannelFuture 接口 32
3.2 ChannelHandler 和ChannelPipeline 32
3.2.1 ChannelHandler 接口 32
3.2.2 ChannelPipeline 接口 33
3.2.3 更加深入地了解ChannelHandler 34
3.2.4 编码器和解码器 35
3.2.5 抽象类SimpleChannelInboundHandler 35
3.3 引导 36
3.4 小结 37
第4 章 传输 38
4.1 案例研究：传输迁移 38
4.1.1 不通过Netty 使用OIO和NIO 39
4.1.2 通过Netty 使用OIO和NIO 41
4.1.3 非阻塞的Netty 版本 42
4.2 传输API 43
4.3 内置的传输 45
4.3.1 NIO——非阻塞I/O 46
4.3.2 Epoll——用于Linux的本地非阻塞传输 47
4.3.3 OIO——旧的阻塞I/O 48
4.3.4 用于JVM 内部通信的Local 传输 48
4.3.5 Embedded 传输 49
4.4 传输的用例 49
4.5 小结 51
第5 章 ByteBuf 52
5.1 ByteBuf 的API 52
5.2 ByteBuf 类——Netty的数据容器 53
5.2.1 它是如何工作的 53
5.2.2 ByteBuf 的使用模式 53
5.3 字节级操作 57
5.3.1 随机访问索引 57
5.3.2 顺序访问索引 57
5.3.3 可丢弃字节 58
5.3.4 可读字节 58
5.3.5 可写字节 59
5.3.6 索引管理 59
5.3.7 查找操作 60
5.3.8 派生缓冲区 60
5.3.9 读/写操作 62
5.3.10 更多的操作 64
5.4 ByteBufHolder 接口 65
5.5 ByteBuf 分配 65
5.5.1 按需分配：ByteBufAllocator 接口 65
5.5.2 Unpooled 缓冲区 67
5.5.3 ByteBufUtil 类 67
5.6 引用计数 67
5.7 小结 68
第6 章 ChannelHandler 和ChannelPipeline 70
6.1 ChannelHandler 家族 70
6.1.1 Channel 的生命周期 70
6.1.2 ChannelHandler的生命周期 71
6.1.3 ChannelInboundHandler接口 71
6.1.4 ChannelOutboundHandler接口 73
6.1.5 ChannelHandler 适配器 74
6.1.6 资源管理 74
6.2 ChannelPipeline 接口 76
6.2.1 修改ChannelPipeline 78
6.2.2 触发事件 79
6.3 ChannelHandlerContext接口 80
6.3.1 使用ChannelHandlerContext 82
6.3.2 ChannelHandler 和ChannelHandlerContext 的高级用法 84
6.4 异常处理 86
6.4.1 处理入站异常 86
6.4.2 处理出站异常 87
6.5 小结 88
第7 章 EventLoop 和线程模型 89
7.1 线程模型概述 89
7.2 EventLoop 接口 90
7.2.1 Netty 4 中的I/O 和事件处理 92
7.2.2 Netty 3 中的I/O 操作 92
7.3 任务调度 93
7.3.1 JDK 的任务调度API 93
7.3.2 使用EventLoop调度任务 94
7.4 实现细节 95
7.4.1 线程管理 95
7.4.2 EventLoop/线程的分配 96
7.5 小结 98
第8 章 引导 99
8.1 Bootstrap 类 99
8.2 引导客户端和无连接协议 101
8.2.1 引导客户端 102
8.2.2 Channel 和EventLoopGroup 的兼容性 103
8.3 引导服务器 104
8.3.1 ServerBootstrap 类 104
8.3.2 引导服务器 105
8.4 从Channel引导客户端 107
8.5 在引导过程中添加多个ChannelHandler 108
8.6 使用Netty 的ChannelOption 和属性 110
8.7 引导DatagramChannel 111
8.8 关闭 112
8.9 小结 112
第9 章 单元测试 113
9.1 EmbeddedChannel概述 113
9.2 使用EmbeddedChannel测试ChannelHandler 115
9.2.1 测试入站消息 115
9.2.2 测试出站消息 118
9.3 测试异常处理 119
9.4 小结 121
第二部分 编解码器
第10 章 编解码器框架 125
10.1 什么是编解码器 125
10.2 解码器 125
10.2.1 抽象类ByteToMessageDecoder 126
10.2.2 抽象类ReplayingDecoder 127
10.2.3 抽象类MessageToMessageDecoder 128
10.2.4 TooLongFrameException 类 130
10.3 编码器 131
10.3.1 抽象类MessageToByteEncoder 131
10.3.2 抽象类MessageToMessageEncoder 132
10.4 抽象的编解码器类 133
10.4.1 抽象类ByteToMessageCodec 133
10.4.2 抽象类MessageToMessageCodec 134
10.4.3 CombinedChannelDuplexHandler 类 137
10.5 小结 138
第11 章 预置的ChannelHandler和编解码器 139
11.1 通过SSL/TLS 保护Netty 应用程序 139
11.2 构建基于Netty 的HTTP/HTTPS 应用程序 141
11.2.1 HTTP 解码器、编码器和编解码器 141
11.2.2 聚合HTTP 消息 143
11.2.3 HTTP 压缩 144
11.2.4 使用HTTPS 145
11.2.5 WebSocket 146
11.3 空闲的连接和超时 148
11.4 解码基于分隔符的协议和基于长度的协议 150
11.4.1 基于分隔符的协议 150
11.4.2 基于长度的协议 153
11.5 写大型数据 155
11.6 序列化数据 1 57
11.6.1 JDK 序列化 157
11.6.2 使用JBoss Marshalling进行序列化 157
11.6.3 通过Protocol Buffers序列化 159
11.7 小结 160
第三部分 网络协议
第12 章 WebSocket 163
12.1 WebSocket 简介 163
12.2 我们的WebSocket 示例应用程序 164
12.3 添加WebSocket支持 165
12.3.1 处理HTTP 请求 165
12.3.2 处理WebSocket 帧 168
12.3.3 初始化ChannelPipeline 169
12.3.4 引导 171
12.4 测试该应用程序 173
12.5 小结 176
第13章 使用UDP 广播事件 177
13.1 UDP 的基础知识 177
13.2 UDP 广播 178
13.3 UDP 示例应用程序 178
13.4 消息 POJO:LogEvent 179
13.5 编写广播者 180
13.6 编写监视器 185
13.7 运行LogEventBroadcaster 和LogEventMonitor 187
13.8 小结 189
第四部分 案例研究
第14 章 案例研究，第一部分 193
14.1 Droplr—构建移动服务 193
14.1.1 这一切的起因 193
14.1.2 Droplr 是怎样工作的 194
14.1.3 创造一个更加快速的上传体验 194
14.1.4 技术栈 196
14.1.5 性能 199
14.1.6 小结——站在巨人的肩膀上 200
14.2 Firebase—实时的数据同步服务 200
14.2.1 Firebase 的架构 201
14.2.2 长轮询 201
14.2.3 HTTP 1.1 keep-alive和流水线化 204
14.2.4 控制SslHandler 205
14.2.5 Firebase 小结 207
14.3 Urban Airship—构建移动服务 207
14.3.1 移动消息的基础知识 207
14.3.2 第三方递交 208
14.3.3 使用二进制协议的例子 209
14.3.4 直接面向设备的递交 211
14.3.5 Netty 擅长管理大量的并发连接 212
14.3.6 Urban Airship 小结——跨越防火墙边界 213
14.4 小结 214
第15 章 案例研究，第二部分 215
15.1 Netty 在Facebook 的使用：Nifty 和Swift 215
15.1.1 什么是Thrift 215
15.1.2 使用Netty 改善Java Thrift 的现状 216
15.1.3 Nifty 服务器的设计 217
15.1.4 Nifty 异步客户端的设计 220
15.1.5 Swift：一种更快的构建Java Thrift 服务的方式 221
15.1.6 结果 221
15.1.7 Facebook 小结 224
15.2 Netty 在Twitter的使用：Finagle 224
15.2.1 Twitter 成长的烦恼 224
15.2.2 Finagle 的诞生 224
15.2.3 Finagle 是如何工作的 225
15.2.4 Finagle 的抽象 230
15.2.5 故障管理 231
15.2.6 组合服务 232
15.2.7 未来：Netty 232
15.2.8 Twitter 小结 233
15.3 小结 233
附录 Maven 介绍 234
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Netty实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向对象编程基础
第1章  面向对象基础  1.1  对象  1.2  面向对象  1.3  面向对象程序的特点第2章  UML类图及其设计  2.1  UML类图  2.2  典型类结构  2.3  类图的设计第3章  封装性的Java编程实现  3.1  Java中的类与对象  3.2  Java中的访问权限限制  3.3  Java API应用举例  3.4  公司雇员管理系统部分类的实现第4章  Javadoc编写规范  4.1  Javadoc撰写规范  4.2  Javadoc标签撰写规范第5章  Java开发工具包(JDK)  5.1  环境变量  5.2  环境变量的设置  5.3  JDK相关命令  5.4  Eclipse集成开发环境第6章  Java的异常处理机制  6.1  问题的提出  6.2  throw关键字  6.3  try-catch关键字  6.4  异常类和throws关键字  6.5  自定义异常第7章  继承关系的Java编程实现  7.1  继承关系的实现  7.2  equals方法和toString方法  7.3  公司雇员信息管理系统的实现第8章  关联关系的.Java编程实现  8.1  数组  8.2  容器Java.util.Vector和迭代器.Java.util.Iterators  8.3  公司雇员信息管理系统的实现第9章  多态性的Java编程实现  9.1  变量的多态性  9.2  方法的多态性第10章  类设计和Java编程实现的高级主题  10.1  抽象类  10.2  接口  10.3  接口与抽象类及一般类的比较  10.4  应用案例分析  10.5  设计模式第11章  Java数据流编程  11.1  Java I/O概述  11.2  Java字节流  11.3  Java字符流  11.4  Java I/O编程第12章  Java图形界面编程  12.1  组件与容器  12.2  对话框和菜单  12.3  布局管理器  12.4  事件处理机制  12.5  公司雇员信息管理系统GUI编程实现参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向对象编程基础
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Grails入门指南（第二版）
1. 简介
例程学习
RaceTrack应用 2. 安装Grails
安装JDK
安装Grails
安装数据库 3. 创建GRAILS应用程序
创建RACETRACK应用
GRAILS应用目录结构
领域类
使用脚手架创建控制器和视图 4. 验证
自定义字段顺序
增加验证
改变错误消息
创建自定义验证
测试验证 5. 关系
创建"一对多"关系
创建"多对多"关系
启动时初始化数据 6. 数据库
GORM
DataSource.groovy
切换到外部数据库 7. 控制器
比较CREATE-CONTROLLER 和GENERATE-CONTROLLER
理解URL和控制器
从请求到控制器再到视图
GSP速览
了解控制器ACTION的其余内容
展示不匹配ACTION名字的视图 8. GROOVY服务器页面
理解GSP
理解SITEMESH
理解局部模板
理解自定义标签库
自定义缺省模板 9. 安全
实现用户认证
对控制器进行单元测试
创建口令编解码器（CODEC）
创建认证标签库
利用BEFOREINTERCEPTOR
利用过滤器（FILTER）
安全插件10. 插件、服务及部署
理解插件
安装SEARCHABLE插件
探索SEARCHABLE插件
理解服务
增加搜索框
使用URL映射（URLMAPPING）改变主页
产品部署检查清单
总结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Grails入门指南（第二版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ZooKeeper:分布式过程协同技术详解
前言1
第一部分ZooKeeper的概念和基础
第1章简介7
1.1ZooKeeper的使命8
1.1.1ZooKeeper改变了什么10
1.1.2ZooKeeper不适用的场景10
1.1.3关于Apache项目11
1.1.4通过ZooKeeper构建分布式系统11
1.2示例：主—从应用12
1.2.1主节点失效13
1.2.2从节点失效14
1.2.3通信故障14
1.2.4任务总结15
1.3分布式协作的难点16
1.4ZooKeeper的成功和注意事项18
第2章了解ZooKeeper19
2.1ZooKeeper基础19
2.1.1API概述20
2.1.2znode的不同类型21
2.1.3监视与通知22
2.1.4版本24
2.2ZooKeeper架构25
2.2.1ZooKeeper仲裁26
2.2.2会话27
2.3开始使用ZooKeeper28
2.3.1第一个ZooKeeper会话28
2.3.2会话的状态和声明周期31
2.3.3ZooKeeper与仲裁模式33
2.3.4实现一个原语：通过ZooKeeper实现锁36
2.4一个主—从模式例子的实现37
2.4.1主节点角色37
2.4.2从节点、任务和分配40
2.4.3从节点角色40
2.4.4客户端角色41
2.5小结43
第二部分使用ZooKeeper进行开发
第3章开始使用ZooKeeper的API47
3.1设置ZooKeeper的CLASSPATH47
3.2建立ZooKeeper会话47
3.2.1实现一个Watcher49
3.2.2运行Watcher的示例51
3.3获取管理权53
3.3.1异步获取管理权57
3.3.2设置元数据60
3.4注册从节点62
3.5任务队列化65
3.6管理客户端66
3.7小结68
第4章处理状态变化70
4.1单次触发器71
4.2如何设置监视点72
4.3普遍模型73
4.4主—从模式的例子74
4.4.1管理权变化74
4.4.2主节点等待从节点列表的变化77
4.4.3主节点等待新任务进行分配80
4.4.4从节点等待分配新任务83
4.4.5客户端等待任务的执行结果86
4.5另一种调用方式：Multiop88
4.6通过监视点代替显式缓存管理90
4.7顺序的保障91
4.7.1写操作的顺序91
4.7.2读操作的顺序91
4.7.3通知的顺序92
4.8监视点的羊群效应和可扩展性93
4.9小结94
第5章故障处理96
5.1可恢复的故障98
5.2不可恢复的故障102
5.3群首选举和外部资源103
5.4小结106
第6章ZooKeeper注意事项107
6.1使用ACL107
6.1.1内置的鉴权模式108
6.1.2SASL和Kerberos111
6.1.3增加新鉴权模式111
6.2恢复会话111
6.3当znode节点重新创建时，重置版本号112
6.4sync方法112
6.5顺序性保障114
6.5.1连接丢失时的顺序性114
6.5.2同步API和多线程的顺序性115
6.5.3同步和异步混合调用的顺序性115
6.6数据字段和子节点的限制116
6.7嵌入式ZooKeeper服务器116
6.8小结117
第7章C语言客户端118
7.1配置开发环境118
7.2开始会话119
7.3引导主节点121
7.4行使管理权126
7.5任务分配129
7.6单线程与多线程客户端132
7.7小结135
第8章Curator：ZooKeeperAPI的高级封装库136
8.1Curator客户端程序136
8.2流畅式API137
8.3监听器138
8.4Curator中状态的转换140
8.5两种边界情况141
8.6菜谱141
8.6.1群首闩142
8.6.2群首选举器143
8.6.3子节点缓存器146
8.7小结148
第三部分ZooKeeper的管理
第9章ZooKeeper内部原理151
9.1请求、事务和标识符152
9.2群首选举153
9.3Zab：状态更新的广播协议157
9.4观察者161
9.5服务器的构成162
9.5.1独立服务器163
9.5.2群首服务器164
9.5.3追随者和观察者服务器165
9.6本地存储166
9.6.1日志和磁盘的使用166
9.6.2快照167
9.7服务器与会话169
9.8服务器与监视点170
9.9客户端170
9.10序列化171
9.11小结171
第10章运行ZooKeeper173
10.1配置ZooKeeper服务器174
10.1.1基本配置175
10.1.2存储配置175
10.1.3网络配置177
10.1.4集群配置179
10.1.5认证和授权选项181
10.1.6非安全配置182
10.1.7日志183
10.1.8专用资源185
10.2配置ZooKeeper集群185
10.2.1多数原则186
10.2.2法定人数的可配置性186
10.2.3观察者188
10.3重配置188
10.4配额管理194
10.5多租赁配置196
10.6文件系统布局和格式197
10.6.1事务日志198
10.6.2快照199
10.6.3时间戳文件200
10.6.4已保存的ZooKeeper数据的应用200
10.7四字母命令201
10.8通过JMX进行监控202
10.9工具209
10.10小结209
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ZooKeeper:分布式过程协同技术详解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>函数式编程思维
译者序　　ix
前言　　xi
第1章　为什么　　1
1.1　范式转变　　2
1.2　跟上语言发展的潮流　　4
1.3　把控制权让渡给语言/ 运行时　　4
1.4　简洁　　5
第2章　转变思维　　9
2.1　普通的例子　　9
2.1.1　命令式解法　　9
2.1.2　函数式解法　　10
2.2　案例研究：完美数的分类问题　　15
2.2.1　完美数分类的命令式解法　　15
2.2.2　稍微向函数式靠拢的完美数分类解法　　16
2.2.3　完美数分类的Java 8实现　　18
2.2.4　完美数分类的Functional Java实现　　19
2.3　具有普遍意义的基本构造单元　　21
2.3.1　筛选　　22
2.3.2　映射　　23
2.3.3　折叠/ 化约　　25
2.4　函数的同义异名问题　　28
2.4.1　筛选　　28
2.4.2　映射　　31
2.4.3　折叠/ 化约　　33
第3章　权责让渡　　37
3.1　迭代让位于高阶函数　　37
3.2　闭包　　38
3.3　柯里化和函数的部分施用　　41
3.3.1　定义与辨析　　41
3.3.2　Groovy的情况　　42
3.3.3　Clojure的情况　　44
3.3.4　Scala的情况　　44
3.3.5　一般用途　　47
3.4　递归　　48
3.5　Stream 和作业顺序重排　　53
第4章　用巧不用蛮　　55
4.1　记忆　　55
4.1.1　缓存　　56
4.1.2　引入“记忆”　　59
4.2　缓求值　　65
4.2.1　Java语言下的缓求值迭代子　　65
4.2.2　使用Totally Lazy框架的完美数分类实现　　67
4.2.3　Groovy语言的缓求值列表　　69
4.2.4　构造缓求值列表　　72
4.2.5　缓求值的好处　　74
4.2.6　缓求值的字段初始化　　76
第5章　演化的语言　　79
5.1　少量的数据结构搭配大量的操作　　79
5.2　让语言去迎合问题　　81
5.3　对分发机制的再思考　　82
5.3.1　Groovy对分发机制的改进　　82
5.3.2　“身段柔软”的Clojure 语言　　83
5.3.3　Clojure的多重方法和基于任意特征的多态　　85
5.4　运算符重载　　87
5.4.1　Groovy　　87
5.4.2　Scala　　89
5.5　函数式的数据结构　　91
5.5.1　函数式的错误处理　　91
5.5.2　Either类　　92
5.5.3　Option类　　100
5.5.4　Either树和模式匹配　　100
第6章　模式与重用　　107
6.1　函数式语言中的设计模式　　107
6.2　函数级别的重用　　108
6.2.1　Template Method模式　　109
6.2.2　Strategy模式　　 111
6.2.3　Flyweight模式和记忆　　113
6.2.4　Factory模式和柯里化　　116
6.3　结构化重用和函数式重用的对比　　117
第7章　现实应用　　125
7.1　Java 8　　125
7.1.1　函数式接口　　126
7.1.2　Optional类型　　128
7.1.3　Java 8的stream　　128
7.2　函数式的基础设施　　129
7.2.1　架构　　129
7.2.2　Web 框架　　132
7.2.3　数据库　　133
第8章　多语言与多范式　　135
8.1　函数式与元编程的结合　　136
8.2　利用元编程在数据类型之间建立映射　　137
8.3　多范式语言的后顾之忧　　140
8.4　上下文型抽象与复合型抽象的对比　　141
8.5　函数式金字塔　　143
作者简介　　147
封面介绍　　147
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>函数式编程思维
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Server Pages技术参考
第1章 JAVA家族
第2章 Servlet简介
第3章 JSP简介
第4章 JSP语法
第5章 隐含对象
第6章 JSP执行环境与开发环境
第7章 网页表单的处理
第8章 JSP与JavaBean
第9章 Session TracKing
第10章 JSP与数据库――JDBC
第11章 JSP与XML

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Server Pages技术参考
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言实用教程
第1章 JAVA快速入门
第2章 JAVA基本语法
第3章 JAVA语句及其控制结构
第4章 面向对象编程
第5章 类的继承性与多态性
第6章 包、接口和异常
第7章 常用系统类
第8章 图形用户界面
第9章 窗口和菜单
第10章 多线程机制
第11章 图形与多媒体处理
参考文献

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言实用教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计实用教程
第一章 概述
第二章 Java语言基础
第三章 类和对象
第四章 类与继承
第五章 Java API基础
第六章 图形用户界面
第七章 Java小程序
第八章 异常处理
第九章 输入/输出流
第十章 多线程
第十一章 数据库应用
第十二章 网络通信
第十三章 JSP简介
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计实用教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言调试技术
目录
第1章 Java调试器JDB简介
1.1 JDB的基本结构
1.2 JDB命令简介
第2章 JDB初级调试技术
2.1 设置断点和显示变量
2.2 对象的调试
2.3 Java基本数据类的调试
2.4 字符串类的调试
2.5 输入输出流的调试
第3章 JDB高级调试技术
3.1 意外处理的调试
3.2 线程的调试
3.3 AWT和事件处理的调试
3.4 网络通讯的调试
3.5 动画APPLET的调试
第4章 JavaDebuggerAPI简介
附录 Java语言解释器java的命令行参数

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言调试技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计导学
第0章 俗话程序设计
第1章 编程全过程概览
第2章 Java基本语法
第3章 程序流程设计和控制
第4章 面向对象技术的基础知识
第5章 面向对象技术的高级主题
第6章 通过Java文档了解类的使用
第7章 几个基本的Java类
第8章 程序的异常处理
第9章 输入输出
第10章 在Windows中绘图
附录A Java运行环境设置和DOS基本操作
附录B Windows程序设计入门
附录C 各章习题参考答案
附录D 综合实习题
附录E Java中部分中文术语之我见
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计导学
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 2API大全（上、下）
1、Java.applet包
2、Java.awt包
3、Java.awt.color包
4、Java.awt.datatransfer包
5、Java.awt.dnd包
6、Java.awt.event包
7、Java.awt.font包
8、Java.awt.geom包
9、Java.awt.im包
1、Java.awt.im.spi包<b

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 2API大全（上、下）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Beans 使用手册
第1部分
JavaBeans概

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Beans 使用手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 2 认证考试指南
第一部分 准备程序员考试 第1章

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 2 认证考试指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JAVA实用编程技术
前言
第一章  引言
1. 1  Java历史
1. 2 Java语言的特点
1. 2. 1  简单性Simple
1. 2. 2  面向对象
1. 2. 3  分布式

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JAVA实用编程技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JAVA 2高级开发指南
第一部分  基础篇
第1章  Java技术
Java与联网
Java类
Java安全性支持
Java与文件系统
Ja

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JAVA 2高级开发指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 2程序设计
第1章 Java简介
第2章 J2SDK的安装与运行环境的建立
第3章 Java语言的特征
第4章 Java程序的组成
第5章  Java的例外处理机制
第6章 字符串、日期和时间
第7章 Java的输入与输出
第8章 Java的图形用户界面AWT包
第9章 Java的图形用户界面――Swing包
第10章 图形界面的布局管理器
第11章 组件的事件处理机制
第12章 Java与数据库
第13章 Java的多线程
第14章 网页内嵌程序――Applet
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 2程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java开发指南
第1章  XML与数据描述
何谓XML
XML规则
用XSL牛成样式单
在应用程序中使用XML
SAX编程
XML一览

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java开发指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java完全探索 第2版
第一部分 Java语言
第1章

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java完全探索 第2版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>反编译 Java 程序
第0章 Java Applet的

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>反编译 Java 程序
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web开发权威经典
前言
第一部分 java web应用开发体系与环境配置
第1章 java web开发体系与环境配置
第二部分 java web开发体系的主要技术
第2章 sewiet编程技术
第3章 jsp编程技术
第4章 javabean组件技术
第5章 java web开发体系主要技术的协作
第三部分 java web数据库访问技术
第6章 jdbc数据库访问技术
第7章 jsp操作oracle数据库
第8章 jsp操作sql server数据库
第四部分 java web开发体系的其他重要技术
第9章 jsp操作xml文件
第10章 java web开发体系的其他实用技术
附录
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web开发权威经典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计习题解析与实验教程
第1章　面向对象技术概述与编程环境　1.1　习题解析　1.2　实验指导第2章　Java语言基础　2.1　习题解析　2.2　实验指导第3章　对象与类　3.1　习题解析　3.2　实验指导第4章　继承和多态　4.1　习题解析　4.2　实验指导第5章　输入输出流和异常　5.1　习题解析　5.2　实验指导第6章　图形用户界面设计　6.1　习题解析　6.2　实验指导第7章　网络编程　7.1　习题解析　7.2　实验指导第8章　Applet　8.1　习题解析　8.2　实验指导第9章　JDBC 与数据库　9.1　习题解析　9.2　实验指导第10章　常用数据结构的实现　10.1　习题解析　10.2　实验指导参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计习题解析与实验教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java面向对象编程 (第2版)
第1章面向对象开发方法概述1
1.1结构化的软件开发方法简介3
1.2面向对象的软件开发方法简介6
1.2.1对象模型6
1.2.2UML：可视化建模语言7
1.2.3RationalRose：可视化建模工具7
1.3面向对象开发中的核心思想和概念8
1.3.1问题领域、对象、属性、状态、行为、方法、实现8
1.3.2类、类型10
1.3.3消息、服务12
1.3.4接口13
1.3.5封装、透明14
1.3.6抽象18
1.3.7继承、扩展、覆盖20
1.3.8组合21
1.3.9多态、动态绑定24
1.4UML语言简介26
1.4.1用例图27
1.4.2类框图28
1.4.3时序图29
1.4.4协作图30
1.4.5状态转换图30
1.4.6组件图31
1.4.7部署图32
1.5类之间的关系32
1.5.1关联（Association）33
1.5.2依赖（Dependency）34
1.5.3聚集（Aggregation）35
1.5.4泛化（Generalization）36
1.5.5实现（Realization）36
1.5.6区分依赖、关联和聚集关系36
1.6实现Panel系统39
1.6.1扩展Panel系统42
1.6.2用配置文件进一步提高Panel系统的可维护性43
1.6.3运行Panel系统45
1.7小结45
1.8思考题46
第2章第一个Java应用47
2.1创建Java源文件47
2.1.1Java源文件结构49
2.1.2包声明语句49
2.1.3包引入语句51
2.1.4方法的声明53
2.1.5程序入口main（）方法的声明54
2.1.6给main（）方法传递参数55
2.1.7注释语句55
2.1.8关键字56
2.1.9标识符56
2.1.10编程规范57
2.2用JDK管理Java应用57
2.2.1JDK简介以及安装方法58
2.2.2编译Java源文件60
2.2.3运行Java程序62
2.2.4给Java应用打包65
2.3使用和创建JavaDoc文档66
2.3.1JavaDoc标记68
2.3.2javadoc命令的用法73
2.4Java虚拟机运行Java程序的基本原理75
2.5小结77
2.6思考题78
第3章数据类型和变量81
3.1基本数据类型82
3.1.1boolean类型82
3.1.2byte、short、int和long类型83
3.1.3char类型与字符编码85
3.1.4float和double类型87
3.2引用类型91
3.2.1基本类型与引用类型的区别92
3.2.2用new关键字创建对象94
3.3变量的作用域95
3.3.1实例变量和静态变量的生命周期97
3.3.2局部变量的生命周期100
3.3.3成员变量和局部变量同名101
3.3.4将局部变量的作用域最小化102
3.4对象的默认引用：this103
3.5参数传递105
3.6变量的初始化以及默认值107
3.6.1成员变量的初始化107
3.6.2局部变量的初始化108
3.7直接数109
3.7.1直接数的类型110
3.7.2直接数的赋值111
3.8小结112
3.9思考题113
第4章操作符115
4.1操作符简介115
4.2整型操作符116
4.2.1一元整型操作符117
4.2.2二元整型操作符118
4.3浮点型操作符123
4.4比较操作符和逻辑操作符124
4.5特殊操作符“？：”127
4.6字符串连接操作符“+”127
4.7操作符“==”与对象的equals（）方法129
4.7.1操作符“==”129
4.7.2对象的equals（）方法130
4.8instanceof操作符133
4.9变量的赋值和类型转换135
4.9.1基本数据类型转换136
4.9.2引用类型的类型转换139
4.10小结139
4.11思考题142
第5章流程控制145
5.1分支语句146
5.1.1ifelse语句146
5.1.2switch语句150
5.2循环语句154
5.2.1while语句154
5.2.2dowhile语句156
5.2.3for语句158
5.2.4foreach语句161
5.2.5多重循环162
5.3流程跳转语句162
5.4综合例子：八皇后问题165
5.5小结168
5.6思考题169
第6章继承173
6.1继承的基本语法173
6.2方法重载（Overload）175
6.3方法覆盖（Override）177
6.4方法覆盖与方法重载的异同183
6.5super关键字183
6.6多态185
6.7继承的利弊和使用原则189
6.7.1继承树的层次不可太多190
6.7.2继承树的上层为抽象层190
6.7.3继承关系最大的弱点：打破封装191
6.7.4精心设计专门用于被继承的类193
6.7.5区分对象的属性与继承195
6.8比较组合与继承197
6.8.1组合关系的分解过程对应继承关系的抽象过程197
6.8.2组合关系的组合过程对应继承关系的扩展过程200
6.9小结203
6.10思考题204
第7章Java语言中的修饰符209
7.1访问控制修饰符210
7.2abstract修饰符212
7.3final修饰符214
7.3.1final类215
7.3.2final方法215
7.3.3final变量216
7.4static修饰符220
7.4.1static变量220
7.4.2static方法223
7.4.3static代码块226
7.4.4用static进行静态导入228
7.5小结228
7.6思考题230
第8章接口233
8.1接口的概念和基本特征234
8.2比较抽象类与接口237
8.3与接口相关的设计模式241
8.3.1定制服务模式241
8.3.2适配器模式245
8.3.3默认适配器模式250
8.3.4代理模式251
8.3.5标识类型模式256
8.3.6常量接口模式257
8.4小结258
8.5思考题259
第9章异常处理261
9.1Java异常处理机制概述262
9.1.1Java异常处理机制的优点262
9.1.2Java虚拟机的方法调用栈264
9.1.3异常处理对性能的影响267
9.2运用Java异常处理机制267
9.2.1try—catch语句：捕获异常267
9.2.2finally语句：任何情况下必须执行的代码268
9.2.3throws子句：声明可能会出现的异常270
9.2.4throw语句：抛出异常271
9.2.5异常处理语句的语法规则271
9.2.6异常流程的运行过程274
9.2.7跟踪丢失的异常278
9.3Java异常类280
9.3.1运行时异常282
9.3.2受检查异常（CheckedException）282
9.3.3区分运行时异常和受检查异常283
9.4用户定义异常285
9.4.1异常转译和异常链285
9.4.2处理多样化异常288
9.5异常处理原则289
9.5.1异常只能用于非正常情况290
9.5.2为异常提供说明文档290
9.5.3尽可能地避免异常291
9.5.4保持异常的原子性292
9.5.5避免过于庞大的try代码块294
9.5.6在catch子句中指定具体的异常类型294
9.5.7不要在catch代码块中忽略被捕获的异常294
9.6记录日志295
9.6.1创建Logger对象及设置日志级别296
9.6.2生成日志297
9.6.3把日志输出到文件297
9.6.4设置日志的输出格式298
9.7使用断言299
9.8小结300
9.9思考题301
第10章类的生命周期305
10.1Java虚拟机及程序的生命周期305
10.2类的加载、连接和初始化305
10.2.1类的加载306
10.2.2类的验证307
10.2.3类的准备307
10.2.4类的解析308
10.2.5类的初始化308
10.2.6类的初始化的时机310
10.3类加载器313
10.3.1类加载的父亲委托机制315
10.3.2创建用户自定义的类加载器317
10.3.3URLClassLoader类323
10.4类的卸载324
10.5小结325
10.6思考题326
第11章对象的生命周期327
11.1创建对象的方式327
11.2构造方法330
11.2.1重载构造方法331
11.2.2默认构造方法332
11.2.3子类调用父类的构造方法333
11.2.4构造方法的作用域337
11.2.5构造方法的访问级别337
11.3静态工厂方法338
11.3.1单例类340
11.3.2枚举类342
11.3.3不可变（immutable）类与可变类344
11.3.4具有实例缓存的不可变类348
11.3.5松耦合的系统接口350
11.4垃圾回收351
11.4.1对象的可触及性352
11.4.2垃圾回收的时间354
11.4.3对象的finalize（）方法简介354
11.4.4对象的finalize（）方法的特点355
11.4.5比较finalize（）方法和finally代码块357
11.5清除过期的对象引用358
11.6对象的强、软、弱和虚引用360
11.7小结366
11.8思考题367
第12章内部类371
12.1内部类的基本语法371
12.1.1实例内部类373
12.1.2静态内部类376
12.1.3局部内部类377
12.2内部类的继承379
12.3子类与父类中的内部类同名380
12.4匿名类381
12.5内部接口以及接口中的内部类384
12.6内部类的用途385
12.6.1封装类型385
12.6.2直接访问外部类的成员385
12.6.3回调386
12.7内部类的类文件388
12.8小结389
12.9思考题389
第13章多线程393
13.1Java线程的运行机制393
13.2线程的创建和启动395
13.2.1扩展java.lang.Thread类395
13.2.2实现Runnable接口400
13.3线程的状态转换402
13.3.1新建状态402
13.3.2就绪状态402
13.3.3运行状态402
13.3.4阻塞状态403
13.3.5死亡状态404
13.4线程调度405
13.4.1调整各个线程的优先级406
13.4.2线程睡眠：Thread.sleep（）方法408
13.4.3线程让步：Thead.yield（）方法409
13.4.4等待其他线程结束：join（）410
13.5获得当前线程对象的引用411
13.6后台线程412
13.7定时器413
13.8线程的同步415
13.8.1同步代码块418
13.8.2线程同步的特征422
13.8.3同步与并发425
13.8.4线程安全的类426
13.8.5释放对象的锁427
13.8.6死锁429
13.9线程通信430
13.10中断阻塞435
13.11线程控制436
13.11.1被废弃的suspend（）和resume（）方法437
13.11.2被废弃的stop（）方法438
13.11.3以编程的方式控制线程438
13.12线程组440
13.13处理线程未捕获的异常441
13.14ThreadLocal类443
13.15concurrent并发包445
13.15.1用于线程同步的Lock外部锁446
13.15.2用于线程通信的Condition条件接口447
13.15.3支持异步计算的Callable接口和Future接口450
13.15.4通过线程池来高效管理多个线程452
13.15.5BlockingQueue阻塞队列454
13.16小结457
13.17思考题458
第14章数组461
14.1数组变量的声明461
14.2创建数组对象462
14.3访问数组的元素和长度463
14.4数组的初始化465
14.5多维数组以及不规则数组465
14.6调用数组对象的方法467
14.7把数组作为方法参数或返回值467
14.8数组排序470
14.9数组的二分查找算法471
14.10哈希表472
14.11数组实用类：Arrays477
14.12用符号“…”声明数目可变参数480
14.13小结481
14.14思考题481
第15章Java集合485
15.1Collection和Iterator接口486
15.2集合中直接加入基本类型数据489
15.3Set（集）490
15.3.1Set的一般用法490
15.3.2HashSet类491
15.3.3TreeSet类493
15.4List（列表）497
15.4.1访问列表的元素498
15.4.2为列表排序498
15.4.3ListIterator接口499
15.4.4获得固定长度的List对象500
15.4.5比较Java数组和各种List的性能500
15.5Queue（队列）503
15.5.1Deque（双向队列）504
15.5.2PriorityQueue（优先级队列）505
15.6Map（映射）505
15.7HashSet和HashMap的负载因子507
15.8集合实用类：Collections508
15.9线程安全的集合510
15.10集合与数组的互换511
15.11集合的批量操作512
15.12历史集合类513
15.13枚举类型517
15.13.1枚举类型的构造方法519
15.13.2EnumSet类和EnumMap类520
15.14小结521
15.15思考题521
第16章泛型523
16.1Java集合的泛型523
16.2定义泛型类和泛型接口524
16.3用extends关键字限定类型参数526
16.4定义泛型数组527
16.5定义泛型方法528
16.6使用“？”通配符529
16.7使用泛型的注意事项530
16.8小结531
16.9思考题531
第17章Lambda表达式533
17.1Lambda表达式的基本用法533
17.2用Lambda表达式代替内部类534
17.3Lambda表达式和集合的forEach（）方法535
17.4用Lambda表达式对集合进行排序536
17.5Lambda表达式与StreamAPI联合使用537
17.6Lambda表达式可操纵的变量作用域539
17.7Lambda表达式中的方法引用540
17.8函数式接口（FunctionalInterface）541
17.9总结Java语法糖541
17.10小结542
17.11思考题542
第18章输入与输出（I／O）545
18.1输入流和输出流概述546
18.2输入流547
18.2.1字节数组输入流：ByteArrayInputStream类548
18.2.2文件输入流：FileInputStream类549
18.2.3管道输入流：PipedInputStream551
18.2.4顺序输入流：SequenceInputStream类552
18.3过滤输入流：FilterInputStream552
18.3.1装饰器设计模式553
18.3.2过滤输入流的种类554
18.3.3DataInputStream类555
18.3.4BufferedInputStream类556
18.3.5PushbackInputStream类557
18.4输出流557
18.4.1字节数组输出流：ByteArrayOutputStream类557
18.4.2文件输出流：FileOutputStream558
18.5过滤输出流：FilterOutputStream559
18.5.1DataOutputStream559
18.5.2BufferedOutputStream559
18.5.3PrintStream类561
18.6Reader／Writer概述563
18.7Reader类565
18.7.1字符数组输入流：CharArrayReader类566
18.7.2字符串输入流：StringReader类566
18.7.3InputStreamReader类567
18.7.4FileReader类568
18.7.5BufferedReader类568
18.8Writer类568
18.8.1字符数组输出流：CharArrayWriter类569
18.8.2OutputStreamWriter类570
18.8.3FileWriter类572
18.8.4BufferedWriter类573
18.8.5PrintWriter类573
18.9标准I／O574
18.9.1重新包装标准输入和输出574
18.9.2标准I／O重定向575
18.10随机访问文件类：RandomAccessFile576
18.11新I／O类库577
18.11.1缓冲器Buffer概述578
18.11.2通道Channel概述579
18.11.3字符编码Charset类概述581
18.11.4用FileChannel读写文件581
18.11.5控制缓冲区582
18.11.6字符编码转换583
18.11.7缓冲区视图584
18.11.8文件映射缓冲区：MappedByteBuffer586
18.11.9文件加锁587
18.12对象的序列化与反序列化589
18.13自动释放资源595
18.14用File类来查看、创建和删除文件或目录596
18.15用java.nio.file类库来操作文件系统599
18.15.1复制、移动文件以及遍历、过滤目录树600
18.15.2查看ZIP压缩文件601
18.16小结602
18.17思考题603
第19章图形用户界面605
19.1AWT组件和Swing组件605
19.2创建图形用户界面的基本步骤608
19.3布局管理器610
19.3.1FlowLayout（流式布局管理器）611
19.3.2BorderLayout（边界布局管理器）613
19.3.3GridLayout（网格布局管理器）616
19.3.4CardLayout（卡片布局管理器）619
19.3.5GridBagLayout（网格包布局管理器）620
19.4事件处理626
19.4.1事件处理的软件实现626
19.4.2事件源﹑事件和监听器的类层次和关系632
19.5AWT绘图637
19.5.1Graphics类639
19.5.2Graphics2D类644
19.6AWT线程（事件分派线程）647
19.7小结649
19.8思考题650
第20章常用Swing组件653
20.1边框（Border）653
20.2按钮组件（AbstractButton）及子类654
20.3文本框（JTextField）657
20.4文本区域（JTextArea）与滚动面板（JScrollPane）660
20.5复选框（JCheckBox）与单选按钮（JRadioButton）661
20.6下拉列表（JComboBox）664
20.7列表框（JList）665
20.8页签面板（JTabbedPane）667
20.9菜单（JMenu）669
20.10对话框（JDialog）674
20.11文件对话框（JFileChoose）676
20.12消息框679
20.13制作动画681
20.14播放音频文件683
20.15BoxLayout布局管理器686
20.16设置Swing界面的外观和感觉689
20.17小结691
20.18思考题692
第21章Java常用类693
21.1Object类693
21.2String类和StringBuffer类694
21.2.1String类694
21.2.2“hello”与newString（“hello”）的区别697
21.2.3StringBuffer类698
21.2.4比较String类与StringBuffer类699
21.2.5正则表达式701
21.2.6格式化字符串703
21.3包装类707
21.3.1包装类的构造方法707
21.3.2包装类的常用方法708
21.3.3包装类的自动装箱和拆箱709
21.4Math类710
21.5Random类712
21.6传统的处理日期／时间的类712
21.6.1Date类713
21.6.2DateFormat类713
21.6.3Calendar类715
21.7新的处理日期／时间的类716
21.7.1LocalDate类717
21.7.2LocalTime类718
21.7.3LocalDateTime类718
21.8BigInteger类719
21.9BigDecimal类720
21.10用Optional类避免空指针异常722
21.11小结724
21.12思考题725
第22章Annotation注解727
22.1自定义Annotation注解类型727
22.2在类的源代码中引用注解类型730
22.3在程序中运用反射机制读取类的注解信息732
22.4基本内置注解735
22.5小结736
22.6思考题736
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java面向对象编程 (第2版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构与抽象（Java版）第三版
目    录
第1章  袋子
袋子
袋子的行为
袋子的规格说明
接口
ADT袋子的使用
像使用自动售货机一样使用ADT
Java类库： 接口Set
第2章  使用数组实现袋子
使用固定大小的数组实现ADT袋子
一个类比
一组核心方法
核心方法的实现
核心方法的测试
更多方法的实现
删除物品的方法
使用可变大小的数组实现ADT袋子
调整数组的大小
袋子的一种新的实现
使用数组实现ADT袋子的优缺点
第3章  使用链表实现袋子
链表
通过添加节点到表头来创建链表
ADT袋子的链表实现
私有的类Node
类LinkedBag的概要
一些核心方法的定义
核心方法的测试
方法getFrequencyOf
方法contains
从链表中删除物品
方法remove和clear
具有方法set和get的类Node
使用链表实现ADT袋子的优缺点
第4章  算法的效率
动机
算法效率的度量
基本操作次数的统计
最好、 最坏和平均情况
大O表示法
程序结构的复杂度
效率的图形化表示
ADT袋子不同实现的效率
基于数组的实现
基于链表的实现
两种实现方法的比较
第5章  栈
ADT栈的规格说明
利用栈处理代数表达式
应用问题： 中缀代数表达式中括号平衡的
检查
应用问题： 中缀表达式向后缀表达式的
转换
应用问题： 后缀表达式的求值
应用问题： 中缀表达式的求值
程序栈
Java类库： 类Stack
第6章  栈的实现
基于链表的实现
基于数组的实现
基于向量的实现
Java类库： Vector类
使用向量实现ADT栈
第7章  递归
什么是递归
跟踪一个递归方法
有返回值的递归方法
递归地处理一个数组
递归地处理一个链表
递归方法的时间效率
countDown的时间效率
计算xn的时间效率
一个复杂问题的简单解决方案
一个简单问题的拙劣解决方案
尾递归
间接递归
使用栈代替递归
第8章  排序引论
组织Java对数组排序的方法
选择排序
迭代选择排序
递归选择排序
选择排序的效率
插入排序
迭代插入排序
递归插入排序
插入排序的效率
链表的插入排序
希尔排序
Java代码
希尔排序的效率
算法比较
第9章  快速排序方法
归并排序
数组的归并
递归的归并排序
归并排序的效率
迭代的归并排序
Java类库中的归并排序
快速排序
快速排序的效率
创建划分
快速排序的Java代码
Java类库中的快速排序
基数排序
基数排序的伪代码
基数排序的效率
算法比较
第10章  队列、 双端队列和优先队列
ADT队列
解决问题： 模拟排队
解决问题： 计算出售股票时的资本
增益（一）
Java类库： 接口Queue
ADT双端队列
解决问题： 计算出售股票时的资本
增益（二）
Java类库： 接口Deque
Java类库： ArrayDeque类
ADT优先队列
解决问题： 跟踪你的作业
Java类库： 类PriorityQueue
第11章  队列、 双端队列和优先队列的
实现
基于链表队列的实现
基于数组队列的实现
循环数组
有一个未使用存储单元的循环数组
基于向量队列的实现
基于循环链表队列的实现
由两部分构成的循环链表
Java类库： 类AbstractQueue
基于双向链表双端队列的实现
实现优先队列的可用方法
第12章  线性表
ADT线性表的规格说明
使用ADT线性表
Java类库： List接口
Jave类库： ArraryList类
第13章  用数组实现线性表
用数组实现ADT线性表
一个类比
Java实现
用数组实现ADT线性表的效率
用Vector实现ADT线性表
第14章  用链表实现线性表
操作链表节点
在多种位置加入节点
在多种位置删除节点
私有方法getNodeAt
开始实现
数据域和构造函数
在列表结尾加入
在列表给定位置加入
方法isEmpty和toArray
测试核心方法
继续实现
一个更好的实现
尾引用
用链表实现ADT列表的效率
Java类库： 类LinkedList
第15章  迭代器
迭代器是什么
Iterator接口
使用Iterator接口
独立类迭代器
内部类迭代器
基于链表实现
基于数组实现
为什么迭代器方法在它们自己的
类中
ListIterator接口
使用ListIterator接口
ListIterator接口基于数组的实现
内部类
Java类库： Iterable接口
Iterable和for-each循环
修改版接口List
第16章  有序表
ADT有序表的规格说明
使用ADT有序表
链表实现
方法add
链表实现的效率
使用ADT线性表的实现
效率问题
第17章  继承及线性表
使用继承实现有序表
设计一个基类
创建一个抽象基类
有序表的一种高效实现
方法add
第18章  查找
问题引入
查找无序数组
无序数组的迭代式顺序查找
无序数组的递归式顺序查找
顺序查找数组的效率
查找有序数组
有序数组的顺序查找
有序数组的二分查找
Java类库: 方法binarySearch
二分查找数组的效率
查找无序链表
无序链表的迭代式顺序查找
无序链表的递归式顺序查找
顺序查找链表的效率
查找有序链表
有序链表的顺序查找
二分查找有序链表
查找方法的选择
第19章  词典
ADT词典规格说明
Java接口
迭代器
使用ADT词典
问题解决： 电话号码本
问题解决： 词频
问题解决： 词的索引
Java类库： Map接口
第20章  词典的实现
基于数组的实现
一个无序数组词典
一个有序数组词典
基于向量的实例
链式实例
一个无序链式词典
一个有序链式词典
第21章  散列概述
散列是什么
散列函数
计算散列码
将散列码压缩成散列表的索引
处理冲突
用线性探测实现开放定址
用二次探测实现开放定址
用双重散列实现开放定址
开放定址的潜在问题
链地址
第22章  用散列实现词典
散列的效率
容载分析
开放定址消耗分析
链地址消耗分析
再散列
不同冲突解决方案的对比
用散列实现词典的实例
散列表中的条目
数据域和构造函数
getValue， remove和add方法
迭代器
Java类库： HashMap类
Java类库： HashSet类
第23章  树
树的概念
层次化的数据组织
树的术语
树的遍历
遍历二叉树
一般树的遍历
树的Java接口
树的通用接口
二叉树的接口
二叉树的例子
表达式树
决策树
二叉查找树
堆
一般树的例子
语法分析树
游戏树
第24章  树的实现
二叉树的节点
节点的接口
二叉树节点的实现
ADT二叉树的实现
创建基本二叉树
privateSetTree方法
访问器与更改器方法
计算高度和节点数
遍历
表达式树的实现
一般树
一般树的节点
用二叉树表示一般树
第25章  二叉查找树的实现
开始
二叉查找树接口
重复的条目
开始类定义
查找和检索
遍历
添加条目
递归实现
迭代实现
删除条目
删除一个叶子节点的条目
删除节点有一个孩子的条目
删除节点有两个孩子的条目
删除为根的条目
递归实现
迭代实现
操作的效率
平衡的重要性
节点添加的顺序
ADT词典实现
第26章  堆的实现
再论ADT堆
用数组表示堆
插入条目
删除根
创建堆
堆排序
第27章  平衡查找树
AVL树
单旋转
双旋转
实现细节
2-3树
查找2-3树
添加条目至2-3树
添加时分裂节点
2-4树
添加条目至2-4树
比较AVL， 2-3和2-4树
红黑树
红黑树的性质
添加条目到红黑树
Java类库： TreeMap类
B树
第28章  图
一些示例和术语
公路线路图
航空线路图
迷宫
树
遍历
广度优先遍历
深度优先遍历
拓扑排序
路径
寻找路径
无权图的最短路径算法
加权图中的最短路径
ADT图的Java接口
第29章  图的实现
两种实现的概述
邻接矩阵
邻接表
顶点和边
类Vertex的规格说明
内部类Edge
实现Vertex类
ADT图的实现
基本操作
图算法在 线 部 分
第30章  可变的、 不可变的和可复制的对象（英文版本）
附录A  Java基础
附录B  Java类
附录C  从已有类创建新类
附录D  类的设计
附录E  异常处理
附录F  文件输入与输出
附录G  文档与程序设计风格
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构与抽象（Java版）第三版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java核心技术及面试指南
第1章　带你走进Java的世界
1.1　搭建Java开发环境，运行基本程序
1.1.1　在MyEclipse中开发第一个Java程序
1.1.2　第一个程序分析容易犯的错误
1.1.3　开发稍微复杂带函数调用的程序
1.1.4　可以通过Debug来排查问题
1.1.5　输入运行时的参数
1.2　遵循规范，让你的代码看上去很专业
1.2.1　注意缩进
1.2.2　规范命名
1.2.3　在必要的地方加注释，让别人能看懂你的代码
1.2.4　把不同类型的代码放入不同的类、不同的包（package）
1.3　高效学习法，让你不再半途而废
1.3.1　在公司项目中，Web是重点，Core是基础
1.3.2　Core和Web知识点的学习路线图
1.3.3　从基本的LinkedList入手，分享一些学习方法
1.3.4　除非有特殊的需求，否则可以延后学习的知识点
1.3.5　以需求为导向，否则效率不高
1.3.6　提升能力后，成功跳槽时常见的忧虑
第2章　基本语法中的常用技术点精讲
2.1　基本数据类型、封装类和基本运算操作
2.1.1　从int和Integer来区别基本数据类型和封装类
2.1.2　左加加和右加加的使用建议
2.1.3　可以通过三目运算符来替代简单的if语句
2.1.4　==和equals的区别
2.1.5　基本数据类型、封装类和运算操作的面试题
2.2　流程控制时的注意要点
2.2.1　以if分支语句为例，观察条件表达式中的注意要点
2.2.2　避免短路现象
2.2.3　尤其注意while,do...while和for循环的边界值
2.2.4　switch中的break和default
2.2.5　流程控制方面的面试题
2.3　需要单独分析的String对象
2.3.1　通过String定义常量和变量的区别
2.3.2　通过String来了解“内存值不可变”
2.3.3　通过String和StringBuilder的区别查看内存优化
2.3.4　会被不知不觉调用的toString()方法
2.3.5　使用String对象时容易出错的问题点
2.3.6　String相关的面试题
2.4　论封装：类和方法
2.4.1　类和实例的区别
2.4.2　方法的参数是副本，返回值需要return
2.4.3　通过合理的访问控制符实现封装
2.4.4　静态方法和静态变量
2.4.5　默认构造函数和自定义的构造函数
2.5　论继承：类的继承和接口的实现
2.5.1　从项目角度（非语法角度）观察抽象类和接口
2.5.2　子类中覆盖父类的方法
2.5.3　Java是单重继承，来看看老祖宗Object类的常用方法
2.5.4　不能回避的final关键字
2.5.5　要理解finalize方法，但别重写
2.6　论多态：同一方法根据不同的输入有不同的作用
2.6.1　通过方法重载实现多态
2.6.2　方法重载和覆盖
2.6.3　构造函数能重载但不能覆盖，兼说this和super
2.6.4　通过多态减少代码修改成本
2.7　面向对象思想的常用面试题及解析
第3章　集合类与常用的数据结构
3.1　常见集合类对象的典型用法
3.1.1　通过数组来观察线性表类集合的常见用法
3.1.2　以HashMap为代表，观察键值对类型的集合对象
3.1.3　Set类集合的使用场景
3.2　要学习线性表类集合，你必须掌握这些知识
3.2.1　ArrayList和LinketList等线性表的适用场景
3.2.2　对比ArrayList和Vector对象，分析Vector为什么不常用
3.2.3　通过线性表初步观察泛型
3.2.4　Set集合是如何判断重复的
3.2.5　TreeSet、HashSet和LinkedHashSet的特点
3.2.6　集合中存放的是引用：通过浅复制和深复制来理解
3.2.7　通过迭代器访问线性表的注意事项
3.2.8　线性表类集合的面试题
3.3　关于键值对集合，你必须掌握这些基本知识
3.3.1　通过Hash算法来了解HashMap对象的高效性
3.3.2　为什么要重写equals和hashCode方法
3.3.3　通过迭代器遍历HashMap的方法
3.3.4　综合对比HashMap、HashTable及HashSet三个对象
3.3.5　键值对部分的面试题
3.4　Collections类中包含着操控集合的常见方法
3.4.1　通过sort方法对集合进行排序
3.4.2　把线程不安全变成线程安全的方法
3.5　泛型的深入研究
3.5.1　泛型可以作用在类和接口上
3.5.2　泛型的继承和通配符
3.6　集合部分的面试题及解析
第4章　异常处理与IO操作
4.1　异常处理的常规知识点
4.1.1　错误和异常
4.1.2　异常处理的定式，try...catch...finally语句
4.1.3　运行期异常类不必包含在try从句中
4.1.4　throw,throws的Throwable的区别
4.2　高级程序员需要掌握的异常部分知识点
4.2.1　finally中应该放内存回收相关的代码
4.2.2　在子类方法中不应该抛出比父类范围更广的异常
4.2.3　异常处理部分的使用要点
4.2.4　异常部分的面试题
4.3　常见的IO读写操作
4.3.1　遍历指定文件夹中的内容
4.3.2　通过复制文件的案例解析读写文件的方式
4.3.3　默认的输入输出设备与重定向
4.3.4　生成和解开压缩文件
4.3.5　对IO操作的总结
4.4　非阻塞性的NIO操作
4.4.1　与传统IO的区别
4.4.2　NIO的三大重要组件
4.4.3　通道（Channel）和缓冲器（Buffer）
4.4.4　选择器（Selector）
4.5　解析XML文件
4.5.1　XML的文件格式
4.5.2　基于DOM树的解析方式
4.5.3　基于事件的解析方式
4.5.4　DOM和SAX两种解析方式的应用场景
4.6　Java IO部分的面试题
第5章　SQL,JDBC与数据库编程
5.1　项目中常用SQL语句的注意事项
5.1.1　尽量别写select *
5.1.2　count(*)和count（字段名）的比较
5.1.3　insert的注意事项
5.1.4　在delete中，可以通过in语句同时删除多个记录
5.1.5　merge和update的比较
5.1.6　关于存储过程的分析
5.2　通过JDBC开发读写数据库的代码
5.2.1　MySQL数据库中的准备工作
5.2.2　编写读数据表的代码
5.2.3　编写插入、更新、删除数据表的代码
5.2.4　迁移数据库后，JDBC部分代码的改动
5.3　优化数据库部分的代码
5.3.1　把相对固定的连接信息写入配置文件中
5.3.2　用PreparedStatement以批处理的方式操作数据库
5.3.3　通过PreparedStatement对象防止SQL注入
5.3.4　使用C3P0连接池
5.3.5　数据库操作方面的面试题
5.4　通过JDBC进行事务操作
5.4.1　开启事务，合理地提交和回滚
5.4.2　事务中的常见问题：脏读、幻读和不可重复读
5.4.3　事务隔离级别
5.5　面试时JDBC方面的准备要点
第6章　反射机制和代理模式
6.1　字节码与反射机制
6.1.1　字节码和.class文件
6.1.2　Class类是反射实现的语法基础
6.2　反射的常见用法
6.2.1　查看属性的修饰符、类型和名称
6.2.2　查看方法的返回类型、参数和名称
6.2.3　通过forName和newInstance方法加载类
6.2.4　通过反射机制调用类的方法
6.2.5　反射部分的面试题
6.3　代理模式和反射机制
6.3.1　代理模式
6.3.2　有改进余地的静态代理模式
6.3.3　在动态代理中能看到反射机制
6.4　你已经掌握了一种设计模式，就应大胆地说出来
6.4.1　如何在面试时找机会说出“代理模式”
6.4.2　面试时如何说出对代理模式的认识
第7章　多线程与并发编程
7.1　线程的基本概念与实现多线程的基本方法
7.1.1　线程和进程
7.1.2　线程的生命周期
7.1.3　通过extends Thread来实现多线程
7.1.4　通过implements Runnable来实现多线程（线程优先级）
7.1.5　多线程方面比较基本的面试题
7.2　多线程的竞争和同步
7.2.1　通过sleep方法让线程释放CPU资源
7.2.2　Synchronized作用在方法上
7.2.3　Synchronized作用在代码块上
7.2.4　配套使用wait和notify方法
7.2.5　死锁的案例
7.2.6　Synchronized的局限性
7.2.7　通过锁来管理业务层面的并发性
7.2.8　通过Condition实现线程间的通信
7.2.9　通过Semaphore管理多线程的竞争
7.2.10　多线程并发方面的面试题
7.3　对锁机制的进一步分析
7.3.1　可重入锁
7.3.2　公平锁和非公平锁
7.3.3　读写锁
7.4　从内存结构观察线程并发
7.4.1　直观地了解线程安全与不安全
7.4.2　从线程内存结构中了解并发结果不一致的原因
7.4.3　volatile不能解决数据不一致的问题
7.4.4　通过ThreadLocal为每个线程定义本地变量
7.5　线程池
7.5.1　通过ThreadPoolExecutor实现线程池
7.5.2　通过Callable让线程返回结果
7.5.3　通过ExecutorService创建4种类型的线程池
7.6　多线程综合面试点归纳
7.6.1　说出多线程的基本概念和常规用法
7.6.2　说出多线程并发的知识点
7.6.3　从线程内存角度分析并发情况
第8章　让设计模式真正帮到你
8.1　初识设计模式
8.1.1　设计模式的分类
8.1.2　面试时的常见问题（学习设计模式的侧重点）
8.2　从单例模式入手来了解创建型设计模式
8.2.1　单例模式的实现代码和应用场景
8.2.2　通过工厂模式屏蔽创建细节
8.2.3　简单工厂模式违背了开闭原则
8.2.4　抽象工厂和一般工厂模式的区别
8.2.5　分析建造者模式和工厂模式的区别
8.3　了解结构型的设计模式
8.3.1　简单的装饰器模式
8.3.2　通过适配器模式协调不同类之间的调用关系
8.4　了解行为型的设计模式
8.4.1　通过迭代器了解迭代模式
8.4.2　常见但大多数情况不用自己实现的责任链模式
8.4.3　适用于联动场景的观察者模式
8.5　设计模式背后包含的原则
8.5.1　应用依赖倒转原则能减少修改所影响的范围
8.5.2　能尽量让类稳定的单一职责原则
8.5.3　继承时需要遵循的里氏替换原则
8.5.4　接口隔离原则和最少知道原则
8.5.5　通过合成复用原则优化继承的使用场景
8.6　设计模式方面学习面试经验总结
8.6.1　设计模式方面对于不同程序员的面试标准
8.6.2　设计模式方面学习和面试的误区
8.6.3　面试时如何展示设计模式的能力
8.6.4　设计模式方面的面试题
第9章　虚拟机内存优化技巧
9.1　虚拟机体系结构和Java跨平台特性
9.1.1　字节码、虚拟机、JRE和跨平台特性
9.1.2　虚拟机体系结构
9.1.3　归纳静态数据、基本数据类型和引用等数据的存储位置
9.2　Java的垃圾收集机制
9.2.1　分代管理与垃圾回收流程
9.2.2　不重视内存性能可能会导致的后果
9.2.3　判断对象可回收的依据
9.2.4　深入了解finalize方法
9.2.5　Java垃圾回收机制方面的初级面试题
9.3　通过强、弱、软、虚4种引用进一步了解垃圾回收机制
9.3.1　软引用和弱引用的用法
9.3.2　软引用的使用场景
9.3.3　通过WeakHashMap来了解弱引用的使用场景
9.3.4　虚引用及其使用场景
9.4　更高效地使用内存
9.4.1　StoptheWorld、栈溢出错误和内存溢出错误
9.4.2　内存泄漏的示例
9.4.3　在代码中优化内存性能的具体做法
9.4.4　调整运行参数，优化堆内存性能
9.5　定位和排查内存性能问题
9.5.1　什么情况下该排查内存问题
9.5.2　通过JConsole监控内存使用量
9.5.3　通过GC日志来观察内存使用情况
9.5.4　通过打印内存使用量定位问题点
9.5.5　出现OOM后如何获取和分析Dump文件
9.5.6　出现内存问题该怎样排查
9.6　内部类、final与垃圾回收
9.7　在面试中如何展示虚拟机和内存调优技能
9.7.1　从虚拟机体系结构引出内存管理的话题
9.7.2　如何自然地引出内存话题
9.7.3　根据堆区结构，阐述垃圾回收的流程
9.7.4　进一步说明如何写出高性能的代码
9.7.5　展示监控、定位和调优方面的综合能力
第10章　通过简历和面试找到好工作
10.1　哪些人能应聘成功
10.1.1　公司凭什么留下待面试的简历
10.1.2　技术面试官考查的要点及各要点的优先级
10.1.3　项目经理和人事的考查要点
10.1.4　入职后怎样进行背景调查
10.2　怎样的简历能帮你争取到面试机会
10.2.1　简历中应包含的要素，一个都别落下
10.2.2　如何描述公司的工作情况
10.2.3　描述项目经验的技巧
10.2.4　投送简历时的注意要点
10.3　面试时叙述项目经验和回答问题的技巧
10.3.1　通过叙述项目技能引导后继问题
10.3.2　结合项目实际回答问题
10.4　面试前可以做的准备
10.4.1　事先准备些亮点，回答问题时找机会抛出
10.4.2　事先练习展示责任心和团队协作能力的方式
10.4.3　准备提问环节的问题，以求给自己加分
10.4.4　准备用英文回答问题，以求有备无患
10.4.5　准备些常见刁钻问题的回答，不要临场发挥
10.4.6　准备谈薪资的措辞
10.5　项目经理级别面试的注意要点
10.5.1　把面试官想象成直接领导
10.5.2　在回答中展示良好的沟通和团队协作能力
10.5.3　让面试官确信你会干得长久
10.6　Offer和劳动合同中需要注意的要点
10.7　最后祝大家前程似锦
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java核心技术及面试指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web开发实践教程
第1章 Java Web入门知识 1
1.1 Java Web简介 1
1.2 搭建开发环境 2
1.2.1 安装JDK 2
1.2.2 安装Tomcat 8
1.2.3 安装MyEclipse 12
1.3 实验指导1-1：配置JDK环境
变量 20
1.4 实验指导1-2：创建第一个JSP
程序 21
1.5 实验指导1-3：使用MyEclipse开发JSP
程序 22
1.6 Java Web开发模式 28
1.6.1 单一JSP模式 28
1.6.2 JSP+JavaBean模式 28
1.6.3 JSP+JavaBean+Servlet
模式 29
1.6.4 Struts框架模式 30
1.6.5 J2EE模式实现 31
思考与练习 32
第2章 JSP语法 33
2.1 JSP页面元素 33
2.2 JSP注释 35
2.2.1 HTML注释 35
2.2.2 隐藏注释 35
2.2.3 代码注释 36
2.3 脚本元素 36
2.3.1 Java脚本 37
2.3.2 表达式 38
2.3.3 声明 39
2.4 指令元素 40
2.4.1 page指令 41
2.4.2 taglib指令 43
2.4.3 include指令 44
2.5 动作元素 47
2.5.1 动作 47
2.5.2 动作 49
2.5.3 动作 51
2.5.4 、
和 52
2.6 实验指导2-1：会员注册 55
思考与练习 59
第3章 JSP页面请求与响应 60
3.1 JSP内置对象简介 60
3.2 页面输出对象out 62
3.2.1 out对象成员方法 62
3.2.2 输出数据到客户端 62
3.2.3 管理缓冲区 64
3.3 页面对象page 65
3.4 页面请求对象request 66
3.4.1 request对象成员方法 66
3.4.2 获取客户端信息 68
3.4.3 获取HTTP Headers信息 70
3.4.4 获取请求参数 72
3.4.5 管理请求中的属性 74
3.4.6 处理中文 76
3.5 页面响应对象response 77
3.5.1 response对象成员方法 77
3.5.2 处理HTTP Headers信息 78
3.5.3 处理重定向 80
3.6 实验指导3-1：维护商品信息 82
思考与练习 87
第4章 保存页面状态 88
4.1 会话对象session 88
4.1.1 session对象生命周期 88
4.1.2 session对象方法 89
4.1.3 session对象ID 90
4.1.4 存取数据应用 90
4.1.5 设置会话的有效时间 95
4.2 实验指导4-1：在线考试系统 95
4.3 pageContext对象 100
4.4 全局应用程序对象application 101
4.4.1 application对象生命周期 101
4.4.2 application对象方法 101
4.4.3 存储数据应用 103
4.5 获取配置信息对象config 104
思考与练习 106
第5章 JavaBean技术 108
5.1 JavaBean概述 108
5.1.1 JavaBean技术介绍 108
5.1.2 JavaBean的分类 109
5.1.3 JavaBean规范 110
5.2 JavaBean属性 111
5.2.1 Simple属性 111
5.2.2 Indexed属性 112
5.2.3 Bound属性 113
5.2.4 Constrained属性 114
5.3 实验指导5-1：邮箱验证 115
5.4 JavaBean作用域范围 118
5.4.1 JavaBean的作用域简介 118
5.4.2 Page作用域 118
5.4.3 Request作用域 120
5.4.4 Session作用域 122
5.4.5 Application作用域 123
5.5 实验指导5-2：统计登录用户
数量 125
思考与练习 126
第6章 Servlet技术 128
6.1 Servlet基础 128
6.1.1 Servlet概述 128
6.1.2 Servlet的功能 129
6.1.3 Servlet的特点 130
6.1.4 Servlet的生命周期 130
6.2 Servlet技术开发 132
6.2.1 Servlet在Java EE中的结构
体系 132
6.2.2 Servlet核心API 133
6.2.3 创建Servlet类 135
6.2.4 配置Servlet相关元素 137
6.3 Servlet的典型应用 138
6.3.1 Servlet读取表单数据 138
6.3.2 Servlet实现页面转发 138
6.3.3 Servlet读取当前页的绝对
路径 139
6.3.4 Servlet操作Cookie 139
6.4 实验指导6-1：使用Servlet处理表单
数据 141
6.5 Servlet过滤器 146
6.5.1 过滤器的处理方式 146
6.5.2 过滤器API 147
6.5.3 创建并配置过滤器 148
6.6 实验指导6-2：使用过滤器验证用
户身份 150
6.7 Servlet监听器 153
6.7.1 Servlet监听器简介 153
6.7.2 监听Servlet上下文 153
6.7.3 监听HTTP会话 154
6.7.4 监听Servlet请求 155
6.8 实验指导6-3：使用监听器实现同一
用户只能有一个在线 155
思考与练习 160
第7章 EL表达式 162
7.1 EL概述 162
7.1.1 EL的基本语法 162
7.1.2 EL的特点 163
7.1.3 使用EL表达式的条件 163
7.1.4 EL表达式的存取范围 164
7.1.5 通过EL访问数据 165
7.1.6 EL表达式的保留关键字 165
7.2 EL表达式的运算符 166
7.2.1 存取运算符 166
7.2.2 算术运算符 167
7.2.3 关系运算符 168
7.2.4 逻辑运算符 168
7.2.5 条件运算符 169
7.2.6 empty运算符 169
7.2.7 运算符的优先级 170
7.3 EL的隐含对象 170
7.3.1 页面上下文对象 171
7.3.2 访问环境信息的隐含
对象 173
7.3.3 访问作用域范围的隐含
对象 175
7.4 实验指导7-1：使用EL表达式实现
计算器 175
7.5 定义和使用EL函数 176
7.5.1 定义和使用EL函数 177
7.5.2 常见的错误 179
7.6 实验指导7-2：使用EL访问JavaBean
属性 181
思考与练习 183
第8章 JSTL标签库 184
8.1 JSTL标签库简介 184
8.2 表达式标签 186
8.2.1 输出标签 186
8.2.2 设置标签 188
8.2.3 移除标签 190
8.2.4 捕获异常标签 191
8.3 URL操作标签 191
8.3.1 文件导入标签 192
8.3.2 生成URL地址
标签 193
8.3.3 重定向标签 193
8.3.4 参数传递标签 194
8.4 流程控制标签 194
8.4.1 条件判断标签 195
8.4.2 标签 196
8.4.3 标签 196
8.4.4 标签 196
8.5 实验指导8-1：使用流程控制标签
划分成绩 197
8.6 循环标签 198
8.6.1 循环标签 199
8.6.2 迭代标签 200
8.7 实验指导8-2：使用JSTL标签库
完成用户的登录 202
思考与练习 204
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web开发实践教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业应用架构模式
模式列表
译者序
前言
引言
第一部分 表述
第1章 分层
第2章 组织领域逻辑
第3章 映射到关系数据库
第4章 Web表现层
第5章 并发
第6章 会话状态
第7章 分布策略
第8章 通盘考虑
第二部分 模式
……
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业应用架构模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言程序设计教程
第1章  面向对象思想与Java运行环境第2章  Java语言和HTML简介第3章  数据类型和基础类库第4章  运算符和表达式第5章  Java语言的基本语句第6章  数组、字符串和向量第7章  Java语言的方法第8章  类的声明和对象的实例化第9章  继承性、多态性和泛型第10章  接口、异常、包和Class类第11章  数据流和对象序列化第12章  容器、布局、事件和菜单第13章  awt、swing组件和对话框第14章  多线程第15章  网络编程第16章  数据库编程第17章  常见数据结构第18章  多媒体编程附录参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言程序设计教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计实用教程
第1章  Java基础知识  1．1．Java语言简介及特点    1．1．1  Java语言简介    1．1．2  Java语言特点  1．2．Java开发运行环境    1．2．1  JDK的安装    1．2．2  系统环境变量的设置    1．2．3  编译命令和执行命令的用法    1．2．4  编辑器介绍  1．3  一个简单Java应用程序  1．4  本章小结  习题第2章  Java语言基础  2．1  标识符和关键字    2．1．1  标识符    2．1．2  关键字  2．2  常量和变量    2．2．1  常量    2．2．2  变量    2．2．3  变量作用域  2．3  基本数据类型    2．3．1  基本数据类型    2．3．2  数据类型转换  2．4  运算符和表达式    2．4．1  赋值运算符与赋值表达式    2．4．2  算术运算符与算术表达式    2．4．3  关系运算符与关系表达式    2．4．4  逻辑运算符与逻辑表达式    2．4．5  位运算符    2．4．6  移位运算符    2．4．7  条件运算符第3章  面向对象的编程I（基本语法）第4章  面向对象的变成II（高级语法）第5章  Java常用类和接口第6章  Java异常处理第7章  图形用户界面的创建第8章  常用Swing组件第9章  I/O处理第10章  多线程编程第11章  Java网络编程技术第12章  数据库编程第13章  图书信息查询系统
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计实用教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计习题精析与实验指导
前言
第1章java程序设计概述
1.1重点复习
1.1.1java程序设计语言的发展
1.1.2java程序设计语言的特点
1.1.3java相关程序介绍
1.1.4java程序及开发过程
1.2习题解析
1.3实验指导
1.3.1实验目的与要求
1.3.2实验样例
1.3.3实验内容
1.4练习题
第2章java程序设计的基本概念
2.1重点复习
2.1.1数据类型及标识符
2.1.2常量的定义与使用
2.1.3变量的定义与使用
2.1.4运算符与表达式的使用
2.1.5数据类型的转换
2.2习题解析
2.3实验指导
2.3.1实验目的与要求
2.3.2实验样例
2.3.3实验内容
2.4练习题
第3章java的结构化程序设计
3.1重点复习
3.1.1顺序结构及基本语句
3.1.2选择结构语句
3.1.3循环结构语句
3.1.4数组
3.1.5方法
3.2习题解析
3.3实验指导
3.3.1实验目的与要求
3.3.2实验样例
3.3.3实验内容
3.4练习题
第4章java的面向对象程序设计
4.1重点复习
4.1.1面向对象程序设计的基本思想
4.1.2类的创建方法
4.1.3类的成员以及声明方式
4.1.4对象的创建和构造方法
4.1.5对象的使用方法和销毁机制
4.1.6类的封装与四种访问权限
4.1.7类成员（静态成员）的声明和使用
4.1.8类的继承及应用
4.1.9null、this、super对象运算符的意义和使用
4.1.10最终类和抽象类及相关方法的定义
4.1.11多态的两种应用方式：重载和覆盖
4.1.12接口的声明和实现
4.1.13java常用包及用户自定义包
4.2习题解析
4.3实验指导
4.3.1实验目的与要求
4.3.2实验样例
4.3.3实验内容
4.4练习题
第5章java的图形用户界面
5.1重点复习
5.1.1图形用户界面
5.1.2组件
5.1.3容器
5.1.4布局管理器
5.1.5java的事件及事件处理机制
5.1.6applet
5.1.7swing组件
5.1.8二维图形设计
5.2习题解析
5.3实验指导
5.3.1实验目的与要求
5.3.2实验样例
5.3.3实验内容
5.4练习题
第6章java的异常处理
6.1重点复习
6.1.1异常类与错误类
6.1.2异常类结构及常见异常类型
6.1.3异常处理机制
6.1.4throw和throws语句
6.1.5自定义异常的一般步骤
6.2习题解析
6.3实验指导
6.3.1实验目的与要求
6.3.2实验样例
6.3.3实验内容
6.4练习题
第7章java的多线程程序设计
7.1重点复习
7.1.1线程的相关概念
7.1.2创建线程的方法
7.1.3线程的状态及转换控制
7.1.4线程的优先等级与调度原则
7.1.5线程的同步控制机制
7.2习题解析
7.3实验指导
7.3.1实验目的与要求
7.3.2实验样例
7.3.3实验内容
7.4练习题
第8章java的输入输出流
8.1重点复习
8.1.1数据流与输入输出
8.1.2字节流及其常用方法
8.1.3字符流及其常用方法
8.1.4文件类及其常用方法
8.1.5i/o流与文件的操作
8.1.6文件对话框与文件的操作
8.2习题解析
8.3实验指导
8.3.1实验目的与要求
8.3.2实验样例
8.3.3实验内容
8.4练习题
第9章java的网络应用
9.1重点复习
9.1.1网络的基本概念
9.1.2url的使用
9.1.3socket的应用
9.2习题解析
9.3实验指导
9.3.1实验目的与要求
9.3.2实验样例
9.3.3实验内容
9.4练习题
第10章java的多媒体应用
10.1重点复习
10.1.1图像显示
10.1.2动画实现
10.1.3声音播放
10.2习题解析
10.3实验指导
10.3.1实验目的与要求
10.3.2实验样例
10.3.3实验内容
10.4练习题
第11章综合练习
附录 参考答案
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计习题精析与实验指导
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Netty权威指南（第2版）
基础篇走进Java NIO
第1 章Java 的I/O 演进之路.2
1.1 I/O 基础入门...............3
1.1.1 Linux 网络I/O 模型简介.......3
1.1.2 I/O 多路复用技术.................6
1.2 Java 的I/O 演进..........8
1.3 总结............................ 10
第2 章NIO 入门.................... 11
2.1 传统的BIO 编程....... 11
2.1.1 BIO 通信模型图.................. 12
2.1.2 同步阻塞式I/O 创建的TimeServer 源码分析............. 13
2.1.3 同步阻塞式I/O 创建的TimeClient 源码分析.......... 16
2.2 伪异步I/O 编程........ 18
2.2.1 伪异步I/O 模型图.............. 19
2.2.2 伪异步I/O 创建的TimeServer 源码分析..... 19
2.2.3 伪异步I/O 弊端分析........... 21
2.3 NIO 编程.................... 24
2.3.1 NIO 类库简介.. 24
2.3.2 NIO 服务端序列图.............. 28
2.3.3 NIO 创建的TimeServer 源码分析................ 30
2.3.4 NIO 客户端序列图.............. 36
2.3.5 NIO 创建的TimeClient 源码分析................ 39
2.4 AIO 编程.................... 45
2.4.1 AIO 创建的TimeServer 源码分析................ 46
2.4.2 AIO 创建的TimeClient 源码分析................ 51
2.4.3 AIO 版本时间服务器运行结果.................... 56
2.5 4 种I/O 的对比......... 58
2.5.1 概念澄清.......... 58
2.5.2 不同I/O 模型对比.............. 59
2.6 选择Netty 的理由..... 60
2.6.1 不选择Java 原生NIO 编程的原因............... 61
2.6.2 为什么选择Netty ................ 62
2.7 总结............................ 63
入门篇 Netty NIO 开发指南
第3 章Netty 入门应用.......... 66
3.1 Netty 开发环境的搭建................ 66
3.1.1 下载Netty 的软件包........... 67
3.1.2 搭建Netty 应用工程........... 67
3.2 Netty 服务端开发...... 68
3.3 Netty 客户端开发...... 73
3.4 运行和调试................ 76
3.4.1 服务端和客户端的运行...... 76
3.4.2 打包和部署...... 77
3.5 总结............................ 77
第4 章TCP 粘包/拆包问题的解决之道...... 79
4.1 TCP 粘包/拆包.......... 79
4.1.1 TCP 粘包/拆包问题说明..... 80
4.1.2 TCP 粘包/拆包发生的原因....... 80
4.1.3 粘包问题的解决策略.......... 81
4.2 未考虑TCP 粘包导致功能异常案例................. 82
4.2.1 TimeServer 的改造.............. 82
4.2.2 TimeClient 的改造............... 83
4.2.3 运行结果.......... 84
4.3 利用LineBasedFrameDecoder 解决TCP 粘包问题................ 85
4.3.1 支持TCP 粘包的TimeServer ....................... 86
4.3.2 支持TCP 粘包的TimeClient........................ 88
4.3.3 运行支持TCP 粘包的时间服务器程序........ 90
4.3.4 LineBasedFrameDecoder 和StringDecoder 的原理分析........... 91
4.4 总结............................ 92
第5 章分隔符和定长解码器的应用...... 93
5.1 DelimiterBasedFrameDecoder 应用开发............. 94
5.1.1 DelimiterBasedFrameDecoder 服务端开发.... 94
5.1.2 DelimiterBasedFrameDecoder 客户端开发.... 97
5.1.3 运行DelimiterBasedFrameDecoder 服务端和客户端............... 99
5.2 FixedLengthFrameDecoder 应用开发............... 101
5.2.1 FixedLengthFrameDecoder 服务端开发...... 101
5.2.2 利用telnet 命令行测试EchoServer 服务端......103
5.3 总结.......................... 104
中级篇 Netty 编解码开发指南
第6 章编解码技术.............. 106
6.1 Java 序列化的缺点 ...... 107
6.1.1 无法跨语言.... 107
6.1.2 序列化后的码流太大........ 107
6.1.3 序列化性能太低................ 110
6.2 业界主流的编解码框架............ 113
6.2.1 Google 的Protobuf 介绍.... 113
6.2.2 Facebook 的Thrift 介绍.... 115
6.2.3 JBoss Marshalling 介绍..... 116
6.3 总结.......................... 117
第7 章MessagePack 编解码............... 118
7.1 MessagePack 介绍... 118
7.1.1 MessagePack 多语言支持.. 119
7.1.2 MessagePack Java API 介绍........................ 119
7.1.3 MessagePack 开发包下载. 120
7.2 MessagePack 编码器和解码器开发................. 120
7.2.1 MessagePack 编码器开发....... 120
7.2.2 MessagePack 解码器开发 ...... 121
7.2.3 功能测试........ 121
7.3 粘包/半包支持......... 124
7.4 总结.......................... 127
第8 章Google Protobuf 编解码.......... 128
8.1 Protobuf 的入门....... 129
8.1.1 Protobuf 开发环境搭建..... 129
8.1.2 Protobuf 编解码开发......... 131
8.1.3 运行Protobuf 例程............ 133
8.2 Netty 的Protobuf 服务端开发.. 133
8.2.1 Protobuf 版本的图书订购服务端开发........ 134
8.2.2 Protobuf 版本的图书订购客户端开发........ 136
8.2.3 Protobuf 版本的图书订购程序功能测试.... 139
8.3 Protobuf 的使用注意事项......... 140
8.4 总结.......................... 142
第9 章JBoss Marshalling 编解码....... 143
9.1 Marshalling 开发环境准备........ 143
9.2 Netty 的Marshalling 服务端开发..................... 144
9.3 Netty 的Marshalling 客户端开发..................... 147
9.4 运行Marshalling 客户端和服务端例程........... 149
9.5 总结.......................... 150
高级篇 Netty 多协议开发和应用
第10 章HTTP 协议开发应用............... 154
10.1 HTTP 协议介绍..... 155
10.1.1 HTTP 协议的URL .......... 155
10.1.2 HTTP 请求消息（HttpRequest）.............. 155
10.1.3 HTTP 响应消息（HttpResponse）........... 158
10.2 Netty HTTP 服务端入门开发....... 159
10.2.1 HTTP 服务端例程场景描述..................... 160
10.2.2 HTTP 服务端开发........... 160
10.2.3 Netty HTTP 文件服务器例程运行结果.... 166
10.3 Netty HTTP+XML 协议栈开发....................... 170
10.3.1 开发场景介绍................. 171
10.3.2 HTTP+XML 协议栈设计.......174
10.3.3 高效的XML 绑定框架JiBx ..................... 175
10.3.4 HTTP+XML 编解码框架开发.................. 183
10.3.5 HTTP+XML 协议栈测试....... 199
10.3.6 小结............. 201
10.4 总结........................ 202
第11 章WebSocket 协议开发............. 203
11.1 HTTP 协议的弊端....... 204
11.2 WebSocket 入门..... 204
11.2.1 WebSocket 背景............... 205
11.2.2 WebSocket 连接建立....... 206
11.2.3 WebSocket 生命周期....... 207
11.2.4 WebSocket 连接关闭....... 208
11.3 Netty WebSocket 协议开发..... 209
11.3.1 WebSocket 服务端功能介绍..................... 209
11.3.2 WebSocket 服务端开发.... 210
11.3.3 运行WebSocket 服务端... 218
11.4 总结........................ 219
第12 章私有协议栈开发.... 221
12.1 私有协议介绍........ 221
12.2 Netty 协议栈功能设计............ 223
12.2.1 网络拓扑图.. 223
12.2.2 协议栈功能描述.............. 224
12.2.3 通信模型...... 224
12.2.4 消息定义...... 225
12.2.5 Netty 协议支持的字段类型...................... 226
12.2.6 Netty 协议的编解码规范. 227
12.2.7 链路的建立.. 229
12.2.8 链路的关闭.. 230
12.2.9 可靠性设计.. 230
12.2.10 安全性设计 232
12.2.11 可扩展性设计................ 232
12.3 Netty 协议栈开发.. 233
12.3.1 数据结构定义................. 233
12.3.2 消息编解码.. 237
12.3.3 握手和安全认证.............. 241
12.3.4 心跳检测机制................. 245
12.3.5 断连重连...... 248
12.3.6 客户端代码.. 249
12.3.7 服务端代码.. 251
12.4 运行协议栈............ 252
12.4.1 正常场景...... 252
12.4.2 异常场景：服务端宕机重启.................... 253
12.4.3 异常场景：客户端宕机重启.................... 256
12.5 总结........................ 256
第13 章服务端创建............ 258
13.1 原生NIO 类库的复杂性......... 259
13.2 Netty 服务端创建源码分析.... 259
13.2.1 Netty 服务端创建时序图. 260
13.2.2 Netty 服务端创建源码分析...................... 263
13.3 客户端接入源码分析.............. 272
13.4 总结........................ 275
第14 章客户端创建............ 276
14.1 Netty 客户端创建流程分析.... 276
14.2.1 Netty 客户端创建时序图. 276
14.2.2 Netty 客户端创建流程分析...................... 277
14.2 Netty 客户端创建源码分析.... 278
14.2.1 客户端连接辅助类Bootstrap.................... 278
14.2.2 客户端连接操作.............. 281
14.2.3 异步连接结果通知.......... 283
14.2.4 客户端连接超时机制...... 284
14.3 总结........................ 286
源码分析篇 Netty 功能介绍和源码分析
第15 章ByteBuf 和相关辅助类........... 288
15.1 ByteBuf 功能说明. 288
15.1.1 ByteBuf 的工作原理........ 289
15.1.2 ByteBuf 的功能介绍........ 294
15.2 ByteBuf 源码分析. 308
15.2.1 ByteBuf 的主要类继承关系..................... 309
15.2.2 AbstractByteBuf 源码分析........................ 310
15.2.3 AbstractReferenceCountedByteBuf 源码分析.................. 319
15.2.4 UnpooledHeapByteBuf 源码分析.............. 321
15.2.5 PooledByteBuf 内存池原理分析............... 326
15.2.6 PooledDirectByteBuf 源码分析................. 329
15.3 ByteBuf 相关的辅助类功能介绍.................... 332
15.3.1 ByteBufHolder................. 332
15.3.2 ByteBufAllocator ............. 333
15.3.3 CompositeByteBuf ........... 334
15.3.4 ByteBufUtil .. 336
15.4 总结........................ 337
第16 章Channel 和Unsafe ................. 338
16.1 Channel 功能说明. 338
16.1.1 Channel 的工作原理........ 339
16.1.2 Channel 的功能介绍........ 340
16.2 Channel 源码分析. 343
16.2.1 Channel 的主要继承关系类图.................. 343
16.2.2 AbstractChannel 源码分析........................ 344
16.2.3 AbstractNioChannel 源码分析.................. 347
16.2.4 AbstractNioByteChannel 源码分析........... 350
16.2.5 AbstractNioMessageChannel 源码分析..... 353
16.2.6 AbstractNioMessageServerChannel 源码分析.............. 354
16.2.7 NioServerSocketChannel 源码分析........... 355
16.2.8 NioSocketChannel 源码分析..................... 358
16.3 Unsafe 功能说明... 364
16.4 Unsafe 源码分析... 365
16.4.1 Unsafe 继承关系类图...... 365
16.4.2 AbstractUnsafe 源码分析. 366
16.4.3 AbstractNioUnsafe 源码分析.................... 375
16.4.4 NioByteUnsafe 源码分析. 379
16.5 总结........................ 387
第17 章ChannelPipeline 和ChannelHandler........... 388
17.1 ChannelPipeline 功能说明....... 389
17.1.1 ChannelPipeline 的事件处理.................... 389
17.1.2 自定义拦截器................. 391
17.1.3 构建pipeline 392
17.1.4 ChannelPipeline 的主要特性.................... 393
17.2 ChannelPipeline 源码分析....... 393
17.2.1 ChannelPipeline 的类继承关系图............. 393
17.2.2 ChannelPipeline 对ChannelHandler 的管理........... 393
17.2.3 ChannelPipeline 的inbound 事件.............. 396
17.2.4 ChannelPipeline 的outbound 事件............ 397
17.3 ChannelHandler 功能说明....... 398
17.3.1 ChannelHandlerAdapter 功能说明............ 399
17.3.2 ByteToMessageDecoder 功能说明............ 399
17.3.3 MessageToMessageDecoder 功能说明...... 400
17.3.4 LengthFieldBasedFrameDecoder 功能说明............... 400
17.3.5 MessageToByteEncoder 功能说明............. 404
17.3.6 MessageToMessageEncoder 功能说明....... 404
17.3.7 LengthFieldPrepender 功能说明............... 405
17.4 ChannelHandler 源码分析....... 406
17.4.1 ChannelHandler 的类继承关系图............. 406
17.4.2 ByteToMessageDecoder 源码分析............ 407
17.4.3 MessageToMessageDecoder 源码分析...... 410
17.4.4 LengthFieldBasedFrameDecoder 源码分析............ 411
17.4.5 MessageToByteEncoder 源码分析............. 415
17.4.6 MessageToMessageEncoder 源码分析....... 416
17.4.7 LengthFieldPrepender 源码分析............... 417
17.5 总结........................ 418
第18 章EventLoop 和EventLoopGroup.................... 419
18.1 Netty 的线程模型.. 419
18.1.1 Reactor 单线程模型......... 420
18.1.2 Reactor 多线程模型......... 421
18.1.3 主从Reactor 多线程模型 422
18.1.4 Netty 的线程模型............ 423
18.1.5 最佳实践...... 424
18.2 NioEventLoop 源码分析......... 425
18.2.1 NioEventLoop 设计原理.. 425
18.2.2 NioEventLoop 继承关系类图................... 426
18.2.3 NioEventLoop.................. 427
18.3 总结........................ 436
第19 章Future 和Promise .................. 438
19.1 Future 功能............ 438
19.2 ChannelFuture 源码分析......... 443
19.3 Promise 功能介绍. 445
19.4 Promise 源码分析. 447
19.4.1 Promise 继承关系图........ 447
19.4.2 DefaultPromise ................ 447
19.5 总结........................ 449
架构和行业应用篇 Netty 高级特性
第20 章Netty 架构剖析..... 452
20.1 Netty 逻辑架构...... 452
20.1.1 Reactor 通信调度层......... 453
20.1.2 职责链ChannelPipeline ... 453
20.1.3 业务逻辑编排层（Service ChannelHandler）........... 454
20.2 关键架构质量属性.................. 454
20.2.1 高性能.......... 454
20.2.2 可靠性.......... 457
20.2.3 可定制性...... 460
20.2.4 可扩展性...... 460
20.3 总结........................ 460
第21 章Java 多线程编程在Netty 中的应用............. 461
21.1 Java 内存模型与多线程编程.. 461
21.1.1 硬件的发展和多任务处理........................ 461
21.1.2 Java 内存模型................. 462
21.2 Netty 的并发编程实践............ 464
21.2.1 对共享的可变数据进行正确的同步......... 464
21.2.2 正确使用锁.. 465
21.2.3 volatile 的正确使用......... 467
21.2.4 CAS 指令和原子类......... 470
21.2.5 线程安全类的应用.......... 472
21.2.6 读写锁的应用................. 476
21.2.7 线程安全性文档说明...... 477
21.2.8 不要依赖线程优先级...... 478
21.3 总结........................ 479
第22 章高性能之道............ 480
22.1 RPC 调用性能模型分析.......... 480
22.1.1 传统RPC 调用性能差的三宗罪............... 480
22.1.2 I/O 通信性能三原则........ 481
22.2 Netty 高性能之道.. 482
22.2.1 异步非阻塞通信.............. 482
22.2.2 高效的Reactor 线程模型 482
22.2.3 无锁化的串行设计.......... 485
22.2.4 高效的并发编程.............. 486
22.2.5 高性能的序列化框架...... 486
22.2.6 零拷贝.......... 487
22.2.7 内存池.......... 491
22.2.8 灵活的TCP 参数配置能力....................... 494
22.3 主流NIO 框架性能对比......... 495
22.4 总结........................ 497
第23 章可靠性.................... 498
23.1 可靠性需求............ 498
23.1.1 宕机的代价.. 498
23.1.2 Netty 可靠性需求............ 499
23.2 Netty 高可靠性设计................ 500
23.2.1 网络通信类故障.............. 500
23.2.2 链路的有效性检测.......... 507
23.2.3 Reactor 线程的保护......... 510
23.2.4 内存保护...... 513
23.2.5 流量整形...... 516
23.2.6 优雅停机接口................. 519
23.3 优化建议................ 520
23.3.1 发送队列容量上限控制... 520
23.3.2 回推发送失败的消息...... 521
23.4 总结........................ 521
第24 章安全性.................... 522
24.1 严峻的安全形势.... 522
24.1.1 OpenSSL Heart bleed 漏洞.......... 522
24.1.2 安全漏洞的代价.............. 523
24.1.3 Netty 面临的安全风险..... 523
24.2 Netty SSL 安全特性................. 525
24.2.1 SSL 单向认证.................. 525
24.2.2 SSL 双向认证.................. 532
24.2.3 第三方CA 认证.............. 536
24.3 Netty SSL 源码分析................. 538
24.3.1 客户端.......... 538
24.3.2 服务端.......... 541
24.3.3 消息读取...... 544
24.3.4 消息发送...... 545
24.4 Netty 扩展的安全特性............ 546
24.4.1 IP 地址黑名单机制.......... 547
24.4.2 接入认证...... 548
24.4 总结........................ 550
第25 章Netty 未来展望..... 551
25.1 应用范围................ 551
25.2 技术演进................ 552
25.3 社区活跃度............ 552
25.4 Road Map ............... 552
25.5 总结........................ 553
附录A Netty 参数配置表.... 554
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Netty权威指南（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>图解设计模式
第1部分　适应设计模式　　1
第1章　Iterator模式——一个一个遍历　　1
1.1　Iterator模式　　2
1.2　示例程序　　2
Aggregate接口　　3
Iterator接口　　5
Book类　　5
BookShelf类　　5
BookShelfIteraotr类　　6
Main类　　7
1.3　Iterator模式中的登场角色　　8
1.4　拓展思路的要点　　9
不管实现如何变化，都可以使用Iterator　　9
难以理解抽象类和接口　　9
Aggregate和Iterator的对应　　9
容易弄错“下一个”　　10
还容易弄错“最后一个”　　10
多个Iterator　　10
迭代器的种类多种多样　　10
不需要deleteIterator　　10
1.5　相关的设计模式　　11
1.6　本章所学知识　　11
1.7　练习题　　11
第2章　Adapter模式——加个“适配器”以便于复用　　13
2.1　Adapter模式　　14
2.2　示例程序（1）（使用继承的适配器）　　14
Banner类　　15
Print接口　　16
PrintBanner类　　16
Main类　　16
2.3　示例程序（2）（使用委托的示例程序）　　17
Print类　　18
PrintBanner类　　18
2.4　Adapter模式中的登场角色　　18
2.5　拓展思路的要点　　19
什么时候使用Adapter模式　　19
如果没有现成的代码　　20
版本升级与兼容性　　20
功能完全不同的类　　20
2.6　相关的设计模式　　20
2.7　本章所学知识　　21
2.8　练习题　　21
第2部分　交给子类　　23
第3章　Template Method模式——将具体处理交给子类　　23
3.1　Template Method模式　　24
什么是模板　　24
什么是Template Method模式　　24
3.2　示例程序　　24
AbstractDisplay类　　25
CharDisplay类　　26
StringDisplay类　　27
Main类　　28
3.3　Template Method模式中的登场角色　　28
3.4　拓展思路的要点　　29
可以使逻辑处理通用化　　29
父类与子类之间的协作　　29
父类与子类的一致性　　29
3.5　相关的设计模式　　30
3.6　延伸阅读：类的层次与抽象类　　30
父类对子类的要求　　30
抽象类的意义　　30
父类与子类之间的协作　　31
3.7　本章所学知识　　31
3.8　练习题　　31
第4章　Factory Method模式——将实例的生成交给子类　　33
4.1　Factory Method模式　　34
4.2　示例程序　　34
Product类　　35
Factory类　　35
IDCard类　　36
IDCardFactory类　　36
Main类　　37
4.3　Factory Method模式中的登场角色　　37
4.4　拓展思路的要点　　39
框架与具体加工　　39
生成实例——方法的三种实现方式　　39
使用模式与开发人员之间的沟通　　40
4.5　相关的设计模式　　40
4.6　本章所学知识　　41
4.7　练习题　　41
第3部分　生成实例　　43
第5章　Singleton模式——只有一个实例　　43
5.1　Singleton模式　　44
5.2　示例程序　　44
Singleton类　　44
Main类　　45
5.3　Singleton模式中的登场角色　　46
5.4　拓展思路的要点　　46
为什么必须设置限制　　46
何时生成这个唯一的实例　　46
5.5　相关的设计模式　　47
5.6　本章所学知识　　47
5.7　练习题　　47
第6章　Prototype模式——通过复制生成实例　　49
6.1　Prototype模式　　50
6.2　示例程序　　50
Product接口　　51
Manager类　　52
MessageBox类　　52
UnderlinePen类　　53
Main类　　54
6.3　Prototype模式中的登场角色　　55
6.4　拓展思路的要点　　56
不能根据类来生成实例吗　　56
类名是束缚吗　　56
6.5　相关的设计模式　　57
6.6　延伸阅读：clone方法和java.lang.Clonable接口　　57
Java语言的clone　　57
clone方法是在哪里定义的　　58
需要实现Cloneable的哪些方法　　58
clone方法进行的是浅复制　　58
6.7　本章所学知识　　58
6.8　练习题　　59
第7章　Builder模式——组装复杂的实例　　61
7.1　Builder模式　　62
7.2　示例程序　　62
Builder类　　63
Director类　　63
TextBuilder类　　64
HTMLBuilder类　　65
Main类　　65
7.3　Builder模式中的登场角色　　67
7.4　相关的设计模式　　69
7.5　拓展思路的要点　　69
谁知道什么　　69
设计时能够决定的事情和不能决定的事情　　70
代码的阅读方法和修改方法　　70
7.6　本章所学知识　　70
7.7　练习题　　70
第8章　Abstract Factory模式——将关联零件组装成产品　　73
8.1　Abstract Factory模式　　74
8.2　示例程序　　74
抽象的零件：Item类　　77
抽象的零件：Link类　　78
抽象的零件：Tray类　　78
抽象的产品：Page类　　79
抽象的工厂：Factory类　　79
使用工厂将零件组装称为产品：Main类　　80
具体的工厂：ListFactory类　　81
具体的零件：ListLink类　　82
具体的零件：ListTray类　　82
具体的产品：ListPage类　　83
8.3　为示例程序增加其他工厂　　84
具体的工厂：TableFactory类　　85
具体的零件：TableLink类　　86
具体的零件：TableTray类　　86
具体的产品：TablePage类　　87
8.4　Abstract Factory模式中的登场角色　　87
8.5　拓展思路的要点　　89
易于增加具体的工厂　　89
难以增加新的零件　　89
8.6　相关的设计模式　　89
8.7　延伸阅读：各种生成实例的方法的介绍　　90
8.8　本章所学知识　　91
8.9　练习题　　91
第4部分　分开考虑　　93
第9章　Bridge模式——将类的功能层次结构与实现层次结构分离　　93
9.1　Bridge模式　　94
9.2　示例程序　　95
类的功能层次结构：Display类　　96
类的功能层次结构：CountDisplay类　　97
类的实现层次结构：DisplayImpl类　　97
类的实现层次结构：StringDisplayImpl类　　98
Main类　　98
9.3　Bridge模式中的登场角色　　99
9.4　拓展思路的要点　　100
分开后更容易扩展　　100
继承是强关联，委托是弱关联　　100
9.5　相关的设计模式　　101
9.6　本章所学知识　　101
9.7　练习题　　102
第10章　Strategy模式——整体地替换算法　　103
10.1　Strategy模式　　104
10.2　示例程序　　104
Hand类　　105
Strategy接口　　106
WinningStrategy类　　106
ProbStrategy类　　107
Player类　　109
Main类　　109
10.3　Strategy模式中的登场角色　　111
10.4　拓展思路的要点　　112
为什么需要特意编写Strategy角色　　112
程序运行中也可以切换策略　　112
10.5　相关的设计模式　　113
10.6　本章所学知识　　113
10.7　练习题　　113
第5部分　一致性　　117
第11章　Composite模式——容器与内容的一致性　　117
11.1　Composite模式　　118
11.2　示例程序　　118
Entry类　　119
File类　　120
Directory类　　121
FileTreatMentException类　　122
Main类　　122
11.3　Composite模式中的登场角色　　124
11.4　拓展思路的要点　　125
多个和单个的一致性　　125
Add方法应该放在哪里　　126
到处都存在递归结构　　126
11.5　相关的设计模式　　126
11.6　本章所学知识　　127
11.7　练习题　　127
第12章　Decorator模式——装饰边框与被装饰物的一致性　　129
12.1　Decorator模式　　130
12.2　示例程序　　130
Display类　　131
StringDisplay类　　132
Border类　　132
SideBorder类　　133
FullBorder类　　134
Main类　　135
12.3　Decorator模式中的登场角色　　136
12.4　拓展思路的要点　　137
接口（API）的透明性　　137
在不改变被装饰物的前提下增加功能　　138
可以动态地增加功能　　138
只需要一些装饰物即可添加许多功能　　138
java.io包与Decorator模式　　138
导致增加许多很小的类　　139
12.5　相关的设计模式　　139
12.6　延伸阅读：继承和委托中的一致性　　140
继承——父类和子类的一致性　　140
委托——自己和被委托对象的一致性　　140
12.7　本章所学知识　　142
12.8　练习题　　142
第6部分　访问数据结构　　145
第13章　Visitor模式——访问数据结构并处理数据　　145
13.1　Visitor模式　　146
13.2　示例程序　　146
Visitor类　　147
Element接口　　148
Entry类　　148
File类　　148
Directory类　　149
ListVisitor类　　150
FileTreatmentException类　　151
Main类　　151
Visitor与Element之间的相互调用　　152
13.3　Visitor模式中的登场角色　　154
13.4　拓展思路的要点　　155
双重分发　　155
为什么要弄得这么复杂　　155
开闭原则——对扩展开放，对修改关闭　　155
易于增加ConcreteVisitor角色　　156
难以增加ConcreteElement角色　　156
Visitor工作所需的条件　　156
13.5　相关的设计模式　　157
13.6　本章所学知识　　157
13.7　练习题　　157
第14章　Chain of Responsibility模式——推卸责任　　161
14.1　Chain of Responsibility模式　　162
14.2　示例程序　　162
Trouble类　　163
Support类　　163
NoSupport类　　164
LimitSupport类　　164
OddSupport类　　165
SpecialSupport类　　165
Main类　　166
14.3　Chain of Responsibility模式中的登场角色　　167
14.4　拓展思路的要点　　168
弱化了发出请求的人和处理请求的人之间的关系　　168
可以动态地改变职责链　　168
专注于自己的工作　　169
推卸请求会导致处理延迟吗　　169
14.5　相关的设计模式　　169
14.6　本章所学知识　　169
14.7　练习题　　169
第7部分　简单化　　171
第15章　Facade模式——简单窗口　　171
15.1　Facade模式　　172
15.2　示例程序　　172
Database类　　173
HtmlWriter类　　174
PageMaker类　　175
Main类　　176
15.3　Facade模式中的登场角色　　176
15.4　拓展思路的要点　　177
Facade角色到底做什么工作　　177
递归地使用Facade模式　　178
开发人员不愿意创建Facade角色的原因——心理原因　　178
15.5　相关的设计模式　　178
15.6　本章所学知识　　178
15.7　练习题　　179
第16章　Mediator模式——只有一个仲裁者　　181
16.1　Mediator模式　　182
16.2　示例程序　　182
Mediator接口　　185
Colleague接口　　186
ColleagueButton类　　186
ColleagueTextField类　　187
ColleagueCheckbox类　　188
LoginFrame类　　188
Main类　　191
16.3　Mediator模式中的登场角色　　191
16.4　拓展思路的要点　　192
当发生分散灾难时　　192
通信线路的增加　　193
哪些角色可以复用　　193
16.5　相关的设计模式　　193
16.6　本章所学知识　　193
16.7　练习题　　194
第8部分　管理状态　　195
第17章　Observer模式——发送状态变化通知　　195
17.1　Observer模式　　196
17.2　示例程序　　196
Observer接口　　196
NumberGenerator类　　197
RandomNumberGenerator类　　198
DigitObserver类　　198
GraphObserver类　　199
Main类　　199
17.3　Observer模式中的登场角色　　200
17.4　拓展思路的要点　　201
这里也出现了可替换性　　201
Observer的顺序　　202
当Observer的行为会对Subject产生影响时　　202
传递更新信息的方式　　202
从“观察”变为“通知”　　203
Model/View/Controller（MVC）　　203
17.5　延伸阅读：java.util.Observer接口　　203
17.6　相关的设计模式　　204
17.7　本章所学知识　　204
17.8　练习题　　204
第18章　Memento模式——保存对象状态　　207
18.1　Memento模式　　208
18.2　示例程序　　208
Memento类　　209
Gamer类　　210
Main类　　211
18.3　Memento模式中的登场角色　　215
18.4　拓展思路的要点　　216
两种接口（API）和可见性　　216
需要多少个Memento　　217
Memento的有效期限是多久　　217
划分Caretaker角色和Originator角色的意义　　217
18.5　相关的设计模式　　218
18.6　本章所学知识　　218
18.7　练习题　　218
第19章　State模式——用类表示状态　　221
19.1　State模式　　222
19.2　示例程序　　222
金库警报系统　　222
不使用State模式的伪代码　　223
使用了State模式的伪代码　　224
State接口　　226
DayState类　　226
NightState类　　227
Context接口　　228
SafeFrame类　　228
Main类　　231
19.3　State模式中的登场角色　　232
19.4　拓展思路的要点　　233
分而治之　　233
依赖于状态的处理　　233
应当是谁来管理状态迁移　　233
不会自相矛盾　　234
易于增加新的状态　　234
实例的多面性　　235
19.5　相关的设计模式　　235
19.6　本章所学知识　　235
19.7　练习题　　236
第9部分　避免浪费　　237
第20章　Flyweight模式——共享对象，避免浪费　　237
20.1　Flyweight模式　　238
20.2　示例程序　　238
BigChar类　　240
BigCharFactory类　　241
BigString类　　242
Main类　　244
20.3　Flyweight模式中的登场角色　　244
20.4　拓展思路的要点　　245
对多个地方产生影响　　245
Intrinsic与Extrinsic　　246
不要让被共享的实例被垃圾回收器回收了　　246
内存之外的其他资源　　247
20.5　相关的设计模式　　247
20.6　本章所学知识　　247
20.7　练习题　　247
第21章　Proxy模式——只在必要时生成实例　　249
21.1　Proxy模式　　250
21.2　示例程序　　250
Printer类　　251
Printable接口　　252
PrinterProxy类　　253
Main类　　254
21.3　Proxy模式中的登场角色　　254
21.4　拓展思路的要点　　255
使用代理人来提升处理速度　　255
有必要划分代理人和本人吗　　256
代理与委托　　256
透明性　　256
HTTP代理　　256
各种Proxy模式　　257
21.5　相关的设计模式　　257
21.6　本章所学知识　　257
21.7　练习题　　257
第10部分　用类来表现　　259
第22章　Command模式——命令也是类　　259
22.1　Command模式　　260
22.2　示例程序　　260
Command接口　　261
MacroCommand类　　262
DrawCommand类　　263
Drawable接口　　263
DrawCanvas类　　264
Main类　　265
22.3　Command模式中的登场角色　　268
22.4　拓展思路的要点　　269
命令中应该包含哪些信息　　269
保存历史记录　　269
适配器　　269
22.5　相关的设计模式　　271
22.6　本章所学知识　　272
22.7　练习题　　272
第23章　Interpreter模式——语法规则也是类　　273
23.1　Interpreter模式　　274
23.2　迷你语言　　274
迷你语言的命令　　274
迷你语言程序示例　　275
迷你语言的语法　　278
终结符表达式与非终结符表达式　　279
23.3　示例程序　　279
Node类　　281
ProgramNode类　　281
CommandListNode类　　282
CommandNode类　　283
RepeatCommandNode类　　284
PrimitiveCommandNode类　　285
Context类　　285
ParseException类　　286
Main类　　287
23.4　Interpreter模式中的登场角色　　288
23.5　拓展思路的要点　　289
还有其他哪些迷你语言　　289
跳过标记还是读取标记　　290
23.6　相关的设计模式　　290
23.7　本章所学知识以及本书的结束语　　290
23.8　练习题　　290
附录　　293
附录A　习题解答　　294
附录B　示例程序的运行步骤　　359
附录C　GoF对设计模式的分类　　361
附录D　设计模式Q&A　　362
附录E　参考书籍　　365
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>图解设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>垃圾回收算法手册：自动内存管理的艺术
出版者的话
译者序
前言
作者简介
第1章　引言 1
1.1　显式内存释放 1
1.2自动动态内存管理 3
1.3　垃圾回收算法之间的比较 5
1.3.1　安全性 5
1.3.2　吞吐量 5
1.3.3　完整性与及时性 5
1.3.4　停顿时间 6
1.3.5　空间开销 7
1.3.6　针对特定语言的优化 7
1.3.7　可扩展性与可移植性 8
1.4　性能上的劣势 8
1.5　实验方法 8
1.6　术语和符号 10
1.6.1　堆 10
1.6.2　赋值器与回收器 11
1.6.3　赋值器根 11
1.6.4　引用、域和地址 11
1.6.5　存活性、正确性以及可达性 12
1.6.6　伪代码 12
1.6.7　分配器 13
1.6.8　赋值器的读写操作 13
1.6.9　原子操作 13
1.6.10	集合、多集合、序列以及元组 14
第2章　标记–清扫回收 15
2.1　标记–清扫算法 16
2.2　三色抽象 18
2.3　改进的标记–清扫算法 18
2.4　位图标记 19
2.5　懒惰清扫 21
2.6　标记过程中的高速缓存不命中问题 24
2.7　需要考虑的问题 25
2.7.1　赋值器开销 25
2.7.2　吞吐量 26
2.7.3　空间利用率 26
2.7.4　移动，还是不移动 26
第3章　标记–整理回收 28
3.1　双指针整理算法 29
3.2　Lisp 2算法 30
3.3　引线整理算法 32
3.4　单次遍历算法 34
3.5　需要考虑的问题 36
3.5.1　整理的必要性 36
3.5.2　整理的吞吐量开销 36
3.5.3　长寿数据 36
3.5.4　局部性 37
3.5.5　标记–整理算法的局限性 37
第4章　复制式回收 38
4.1　半区复制回收 38
4.1.1　工作列表的实现 39
4.1.2　示例 40
4.2　遍历顺序与局部性 42
4.3　需要考虑的问题 46
4.3.1　分配 46
4.3.2　空间与局部性 47
4.3.3　移动对象 48
第5章　引用计数 49
5.1　引用计数算法的优缺点 50
5.2　提升效率 51
5.3　延迟引用计数 52
5.4　合并引用计数 54
5.5　环状引用计数 57
5.6　受限域引用计数 61
5.7　需要考虑的问题 62
5.7.1　应用场景 62
5.7.2　高级的解决方案 62
第6章　垃圾回收器的比较 64
6.1　吞吐量 64
6.2　停顿时间 65
6.3　内存空间 65
6.4　回收器的实现 66
6.5　自适应系统 66
6.6　统一垃圾回收理论 67
6.6.1　垃圾回收的抽象 67
6.6.2　追踪式垃圾回收 67
6.6.3　引用计数垃圾回收 69
第7章　内存分配 72
7.1　顺序分配 72
7.2　空闲链表分配 73
7.2.1　首次适应分配 73
7.2.2　循环首次适应分配 75
7.2.3　最佳适应分配 75
7.2.4　空闲链表分配的加速 76
7.3　内存碎片化 77
7.4　分区适应分配 78
7.4.1　内存碎片 79
7.4.2　空间大小分级的填充 79
7.5　分区适应分配与简单空闲链表分配的结合 81
7.6　其他需要考虑的问题 81
7.6.1　字节对齐 81
7.6.2　空间大小限制 82
7.6.3　边界标签 82
7.6.4　堆可解析性 82
7.6.5　局部性 84
7.6.6　拓展块保护 84
7.6.7　跨越映射 85
7.7　并发系统中的内存分配 85
7.8　需要考虑的问题 86
第8章　堆内存的划分 87
8.1　术语 87
8.2　为何要进行分区 87
8.2.1　根据移动性进行分区 87
8.2.2　根据对象大小进行分区 88
8.2.3　为空间进行分区 88
8.2.4　根据类别进行分区 89
8.2.5　为效益进行分区 89
8.2.6　为缩短停顿时间进行分区 90
8.2.7　为局部性进行分区 90
8.2.8　根据线程进行分区 90
8.2.9　根据可用性进行分区 91
8.2.10　根据易变性进行分区 91
8.3　如何进行分区 92
8.4　何时进行分区 93
第9章　分代垃圾回收 95
9.1　示例 95
9.2　时间测量 96
9.3　分代假说 97
9.4　分代与堆布局 97
9.5　多分代 98
9.6　年龄记录 99
9.6.1　集体提升 99
9.6.2　衰老半区 100
9.6.3　存活对象空间与柔性提升 101
9.7　对程序行为的适应 103
9.7.1　Appel式垃圾回收 103
9.7.2　基于反馈的对象提升 104
9.8　分代间指针 105
9.8.1　记忆集 106
9.8.2　指针方向 106
9.9　空间管理 107
9.10　中年优先回收 108
9.11　带式回收框架 110
9.12　启发式方法在分代垃圾回收中的应用 112
9.13　需要考虑的问题 113
9.14　抽象分代垃圾回收 115
第10章　其他分区策略 117
10.1　大对象空间 117
10.1.1　转轮回收器 118
10.1.2　在操作系统支持下的对象移动 119
10.1.3　不包含指针的对象 119
10.2　基于对象拓扑结构的回收器 119
10.2.1　成熟对象空间的回收 120
10.2.2　基于对象相关性的回收 122
10.2.3　线程本地回收 123
10.2.4　栈上分配 126
10.2.5　区域推断 127
10.3　混合标记–清扫、复制式回收器 128
10.3.1　Garbage-First回收 129
10.3.2　Immix回收以及其他回收 130
10.3.3　受限内存空间中的复制式回收 133
10.4　书签回收器 134
10.5　超引用计数回收器 135
10.6　需要考虑的问题 136
第11章　运行时接口 138
11.1　对象分配接口 138
11.1.1　分配过程的加速 141
11.1.2　清零 141
11.2　指针查找 142
11.2.1　保守式指针查找 143
11.2.2　使用带标签值进行精确指针查找 144
11.2.3　对象中的精确指针查找 145
11.2.4　全局根中的精确指针查找 147
11.2.5　栈与寄存器中的精确指针查找 147
11.2.6　代码中的精确指针查找 157
11.2.7　内部指针的处理 158
11.2.8　派生指针的处理 159
11.3　对象表 159
11.4　来自外部代码的引用 160
11.5　栈屏障 162
11.6　安全回收点以及赋值器的挂起 163
11.7　针对代码的回收 165
11.8　读写屏障 166
11.8.1　读写屏障的设计工程学 167
11.8.2　写屏障的精度 167
11.8.3　哈希表 169
11.8.4　顺序存储缓冲区 170
11.8.5　溢出处理 172
11.8.6　卡表 172
11.8.7　跨越映射 174
11.8.8　汇总卡 176
11.8.9　硬件与虚拟内存技术 176
11.8.10　写屏障相关技术小结 177
11.8.11　内存块链表 178
11.9　地址空间管理 179
11.10　虚拟内存页保护策略的应用 180
11.10.1　二次映射 180
11.10.2　禁止访问页的应用 181
11.11　堆大小的选择 183
11.12　需要考虑的问题 185
第12章　特定语言相关内容 188
12.1　终结 188
12.1.1　何时调用终结方法 189
12.1.2　终结方法应由哪个线程调用 190
12.1.3　是否允许终结方法彼此之间的并发 190
12.1.4　是否允许终结方法访问不可达对象 190
12.1.5　何时回收已终结对象 191
12.1.6　终结方法执行出错时应当如何处理 191
12.1.7　终结操作是否需要遵从某种顺序 191
12.1.8　终结过程中的竞争问题 192
12.1.9　终结方法与锁 193
12.1.10　特定语言的终结机制 193
12.1.11　进一步的研究 195
12.2　弱引用 195
12.2.1　其他动因 196
12.2.2　对不同强度指针的支持 196
12.2.3　使用虚对象控制终结顺序 199
12.2.4　弱指针置空过程的竞争问题 199
12.2.5　弱指针置空时的通知 199
12.2.6　其他语言中的弱指针 200
12.3　需要考虑的问题 201
第13章　并发算法预备知识 202
13.1　硬件 202
13.1.1　处理器与线程 202
13.1.2　处理器与内存之间的互联 203
13.1.3　内存 203
13.1.4　高速缓存 204
13.1.5　高速缓存一致性 204
13.1.6　高速缓存一致性对性能的影响示例：自旋锁 205
13.2　硬件内存一致性 207
13.2.1　内存屏障与先于关系 208
13.2.2　内存一致性模型 209
13.3　硬件原语 209
13.3.1　比较并交换 210
13.3.2　加载链接/条件存储 211
13.3.3　原子算术原语 212
13.3.4　检测–检测并设置 213
13.3.5　更加强大的原语 213
13.3.6　原子操作原语的开销 214
13.4　前进保障 215
13.5　并发算法的符号记法 217
13.6　互斥 218
13.7　工作共享与结束检测 219
13.8　并发数据结构 224
13.8.1　并发栈 226
13.8.2　基于单链表的并发队列 228
13.8.3　基于数组的并发队列 230
13.8.4　支持工作窃取的并发双端队列 235
13.9　事务内存 237
13.9.1　何谓事务内存 237
13.9.2　使用事务内存助力垃圾回收器的实现 239
13.9.3　垃圾回收机制对事务内存的支持 240
13.10　需要考虑的问题 241
第14章　并行垃圾回收 242
14.1　是否有足够多的工作可以并行 243
14.2　负载均衡 243
14.3　同步 245
14.4　并行回收的分类 245
14.5　并行标记 246
14.6　并行复制 254
14.6.1　以处理器为中心的并行复制 254
14.6.2　以内存为中心的并行复制技术 258
14.7　并行清扫 263
14.8　并行整理 264
14.9　需要考虑的问题 267
14.9.1　术语 267
14.9.2　并行回收是否值得 267
14.9.3　负载均衡策略 267
14.9.4　并行追踪 268
14.9.5　低级同步 269
14.9.6　并行清扫与并行整理 270
14.9.7　结束检测 270
第15章　并发垃圾回收 271
15.1　并发回收的正确性 272
15.1.1　三色抽象回顾 273
15.1.2　对象丢失问题 274
15.1.3　强三色不变式与弱三色不变式 275
15.1.4　回收精度 276
15.1.5　赋值器颜色 276
15.1.6　新分配对象的颜色 276
15.1.7　基于增量更新的解决方案 277
15.1.8　基于起始快照的解决方案 277
15.2　并发回收的相关屏障技术 277
15.2.1　灰色赋值器屏障技术 278
15.2.2　黑色赋值器屏障技术 279
15.2.3　屏障技术的完整性 280
15.2.4　并发写屏障的实现机制 281
15.2.5　单级卡表 282
15.2.6　两级卡表 282
15.2.7　减少回收工作量的相关策略 282
15.3　需要考虑的问题 283
第16章　并发标记–清扫算法 285
16.1　初始化 285
16.2　结束 287
16.3　分配 287
16.4　标记过程与清扫过程的并发 288
16.5　即时标记 289
16.5.1　即时回收的写屏障 290
16.5.2　Doligez-Leroy-Gonthier回收器 290
16.5.3　Doligez-Leroy-Gonthier回收器在Java中的应用 292
16.5.4　滑动视图 292
16.6　抽象并发回收框架 293
16.6.1　回收波面 294
16.6.2　增加追踪源头 295
16.6.3　赋值器屏障 295
16.6.4　精度 295
16.6.5　抽象并发回收器的实例化 296
16.7　需要考虑的问题 296
第17章　并发复制、并发整理算法 298
17.1　主体并发复制：Baker算法 298
17.2　Brooks间接屏障 301
17.3　自删除读屏障 301
17.4　副本复制 302
17.5　多版本复制 303
17.6　Sapphire回收器 306
17.6.1　回收的各个阶段 306
17.6.2　相邻阶段的合并 311
17.6.3　Volatile域 312
17.7　并发整理算法 312
17.7.1　Compressor回收器 312
17.7.2　Pauseless回收器 315
17.8　需要考虑的问题 321
第18章　并发引用计数算法 322
18.1　简单引用计数算法回顾 322
18.2　缓冲引用计数 324
18.3　并发环境下的环状引用计数处理 326
18.4　堆快照的获取 326
18.5　滑动视图引用计数 328
18.5.1　面向年龄的回收 328
18.5.2　算法实现 328
18.5.3　基于滑动视图的环状垃圾回收 331
18.5.4　内存一致性 331
18.6　需要考虑的问题 332
第19章　实时垃圾回收 333
19.1　实时系统 333
19.2　实时回收的调度 334
19.3　基于工作的实时回收 335
19.3.1　并行、并发副本回收 335
19.3.2　非均匀工作负载的影响 341
19.4　基于间隙的实时回收 342
19.4.1　回收工作的调度 346
19.4.2　执行开销 346
19.4.3　开发者需要提供的信息 347
19.5　基于时间的实时回收：Metronome回收器 347
19.5.1　赋值器使用率 348
19.5.2　对可预测性的支持 349
19.5.3　Metronome回收器的分析 351
19.5.4　鲁棒性 355
19.6　多种调度策略的结合：“税收与开支” 355
19.6.1　“税收与开支”调度策略 356
19.6.2　“税收与开支”调度策略的实现基础 357
19.7　内存碎片控制 359
19.7.1　Metronome回收器中的增量整理 360
19.7.2　单处理器上的增量副本复制 361
19.7.3　Stopless回收器：无锁垃圾回收 361
19.7.4　Staccato回收器：在赋值器无等待前进保障条件下的尽力整理 363
19.7.5　Chicken回收器：在赋值器无等待前进保障条件下的尽力整理（x86平台） 365
19.7.6　Clover回收器：赋值器乐观无锁前进保障下的可靠整理 366
19.7.7　Stopless回收器、Chicken回收器、Clover回收器之间的比较 367
19.7.8　离散分配 368
19.8　需要考虑的问题 370
术语表 372
参考文献 383
索引 413
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>垃圾回收算法手册：自动内存管理的艺术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>2007笔试考试习题集
第1套第2套第3套第4套第5套第6套第7套第8套第9套第10套第11套第12套第13套第14套第15套第16套第17套第18套第19套第20套第21套第22套第23套第24套第25套附录  参考答案
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>2007笔试考试习题集
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Eclipse完全攻略
第1章「Eclipse是什麼」
解說Eclipse的概要，並介紹開放原始碼的Eclipse之緣起和Eclipse專案的概略。
第2章「先來試著使用看看吧」
說明Eclipse的安裝方式和快速入門法。初次使用Eclipse的讀者請照著本章內容從頭操作一遍。
第3章「理解Eclipse的功能」
全面解說Eclipse的基本功能。雖然主要是說明Java開發工具的部分，但若深入研究，可能會讓您有意想不到的新發現。
第4章「開發Web應用程式」
一邊實際製作範例應用程式，一邊介紹架構Web應用程式所需要的功能。從不可或缺的資料庫設定，到Apache Struts的用法都會一併解說。
第5章「Eclipse的團隊開發」
介紹團隊開發功能，特別是CVS、Subversion、GIT使用方法。透過這些工具的組合，將可在一天之內，單憑Eclipse完成開發。
第6章「測試與除錯」
說明在Eclipse上使用JUnit進行測試、除錯的方式。程式碼附件、Web應用程式之除錯等相關項目也會在這一章做說明。
第7章「Ant與應用程式建置」
介紹Ant的基礎和應用程式的建置方式。
第8章「UML與重構」
針對在Eclipse上的UML建模和重構作重點說明。
第9章「建立GUI應用程式」
介紹Swing、Applet、SWT應用程式的建立方式。此外WindowBuilder這類的開發工具也將一併介紹。
第10章「建立Eclipse外掛程式」
介紹開發外掛程式並嵌入至Eclipse中的方式，以及RCP應用程式的建立方式。
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Eclipse完全攻略
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>神经网络算法与实现
第1章初识神经网络1
1.1探索神经网络1
1.2为什么要用人工神经网络2
1.3神经网络的构造3
1.3.1基础元素——人工神经元3
1.3.2赋予神经元生命——激活函数4
1.3.3基础值——权值5
1.3.4重要参数——偏置5
1.3.5神经网络组件——层5
1.4神经网络结构6
1.4.1单层神经网络7
1.4.2多层神经网络7
1.4.3前馈神经网络8
1.4.4反馈神经网络8
1.5从无知到有识——学习过程8
1.6实践神经网络9
1.7小结15
第2章神经网络是如何学习的16
2.1神经网络的学习能力16
2.2学习范式17
2.2.1监督学习17
2.2.2无监督学习18
2.3系统结构——学习算法19
2.3.1学习的两个阶段——训练和测试20
2.3.2细节——学习参数21
2.3.3误差度量和代价函数22
2.4学习算法示例22
2.4.1感知机22
2.4.2Delta规则23
2.5神经网络学习过程的编码23
2.5.1参数学习实现23
2.5.2学习过程24
2.5.3类定义26
2.6两个实例33
2.6.1感知机（报警系统）34
2.6.2ADALINE（交通预测）37
2.7小结42
第3章运用感知机43
3.1学习感知机神经网络43
3.1.1感知机的应用和局限性44
3.1.2线性分离44
3.1.3经典XOR（异或）例子45
3.2流行的多层感知机（MLP）47
3.2.1MLP属性48
3.2.2MLP权值49
3.2.3递归MLP50
3.2.4MLP在OOP范式中的结构50
3.3有趣的MLP应用51
3.3.1使用MLP进行分类51
3.3.2用MLP进行回归53
3.4MLP的学习过程54
3.4.1简单但很强大的学习算法——反向传播55
3.4.2复杂而有效的学习算法——Levenberg–Marquardt57
3.5MLP实现58
3.5.1实战反向传播算法61
3.5.2探索代码62
3.6Levenberg–Marquardt实现66
3.7实际应用——新生入学68
3.8小结71
第4章自组织映射72
4.1神经网络无监督学习方式72
4.2无监督学习算法介绍73
4.3Kohonen自组织映射76
4.3.1一维SOM77
4.3.2二维SOM78
4.3.3逐步实现自组织映射网络学习80
4.3.4如何使用SOM81
4.4Kohonen算法编程81
4.4.1探索Kohonen类84
4.4.2Kohonen实现（动物聚类）86
4.5小结88
第5章天气预测89
5.1针对预测问题的神经网络89
5.2无数据，无神经网络——选择数据91
5.2.1了解问题——天气变量92
5.2.2选择输入输出变量92
5.2.3移除无关行为——数据过滤93
5.3调整数值——数据预处理94
5.4Java实现天气预测96
5.4.1绘制图表96
5.4.2处理数据文件97
5.4.3构建天气预测神经网络98
5.5神经网络经验设计101
5.5.1选择训练和测试数据集101
5.5.2设计实验102
5.5.3结果和模拟103
5.6小结105
第6章疾病诊断分类106
6.1什么是分类问题，以及如何应用神经网络106
6.2激活函数的特殊类型——逻辑回归107
6.2.1二分类VS多分类109
6.2.2比较预期结果与产生结果——混淆矩阵109
6.2.3分类衡量——灵敏度和特异性110
6.3应用神经网络进行分类111
6.4神经网络的疾病诊断114
6.4.1使用神经网络诊断乳腺癌114
6.4.2应用神经网络进行早期糖尿病诊断118
6.5小结121
第7章客户特征聚类122
7.1聚类任务123
7.1.1聚类分析123
7.1.2聚类评估和验证124
7.1.3外部验证125
7.2应用无监督学习125
7.2.1径向基函数神经网络125
7.2.2Kohonen神经网络126
7.2.3数据类型127
7.3客户特征128
7.4Java实现129
7.5小结135
第8章模式识别（OCR案例）136
8.1什么是模式识别136
8.1.1定义大量数据中的类别137
8.1.2如果未定义的类没有被定义怎么办138
8.1.3外部验证138
8.2如何在模式识别中应用神经网络算法138
8.3OCR问题140
8.3.1简化任务——数字识别140
8.3.2数字表示的方法140
8.4开始编码141
8.4.1生成数据141
8.4.2构建神经网络143
8.4.3测试和重新设计——试错144
8.4.4结果145
8.5小结148
第9章神经网络优化与自适应149
9.1神经网络实现中的常见问题149
9.2输入选择150
9.2.1数据相关性150
9.2.2降维151
9.2.3数据过滤152
9.3结构选择152
9.4在线再训练154
9.4.1随机在线学习155
9.4.2实现156
9.4.3应用157
9.5自适应神经网络159
9.5.1自适应共振理论159
9.5.2实现160
9.6小结162
附录ANetBeans环境搭建163
附录BEclipse环境搭建175
附录C参考文献186
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>神经网络算法与实现
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>HotSpot实战
第1章　初识HotSpot　1
1.1　JDK概述　2
1.1.1　JCP与JSR　3
1.1.2　JDK的发展历程　4
1.1.3　Java 7的语法变化　7
1.2　动手编译虚拟机　13
1.2.1　源代码下载　13
1.2.2　HotSpot源代码结构　13
1.2.3　搭建编译环境　15
1.2.4　编译目标　16
1.2.5　编译过程　17
1.2.6　编译常见问题　19
1.3　实战：在HotSpot内调试HelloWorld　20
1.3.1　认识GDB　21
1.3.2　准备调试脚本　22
1.4　小结　26
第2章　启动　28
2.1　HotSpot内核　28
2.1.1　如何阅读源代码　28
2.1.2　HotSpot内核框架　36
2.1.3　Prims　37
2.1.4　Services　39
2.1.5　Runtime　43
2.2　启动　46
2.2.1　Launcher　46
2.2.2　虚拟机生命周期　48
2.2.3　入口：main函数　50
2.2.4　主线程　51
2.2.5　InitializeJVM函数　53
2.2.6　JNI_CreateJavaVM函数　55
2.2.7　调用Java主方法　56
2.2.8　JVM退出路径 56
2.3　系统初始化　57
2.3.1　配置OS模块　58
2.3.2　配置系统属性　60
2.3.3　加载系统库　61
2.3.4　启动线程　62
2.3.5　vm_init_globals函数：初始化全局数据结构　65
2.3.6　init_globals函数：初始化全局模块　65
2.4　小结　69
第3章　类与对象　70
3.1　对象表示机制　71
3.1.1　OOP-Klass二分模型　71
3.1.2　Oops模块　71
3.1.3　OOP框架与对象访问机制　73
3.1.4　Klass与instanceKlass　79
3.1.5　实战：用HSDB调试HotSpot　82
3.2　类的状态转换　87
3.2.1　入口：Class文件　87
3.2.2　类的状态　92
3.2.3　加载　96
3.2.4　链接　101
3.2.5　初始化　104
3.2.6　实战：类的“族谱”　107
3.2.7　实战：系统字典　111
3.3　创建对象　113
3.3.1　实例对象的创建流程　114
3.3.2　实战：探测JVM内部对象　116
3.4　小结　119
第4章　运行时数据区　120
4.1　堆　121
4.1.1　Java的自动内存管理　121
4.1.2　堆的管理　122
4.2　线程私有区域　125
4.2.1　PC　125
4.2.2　JVM栈　126
4.3　方法区　126
4.3.1　纽带作用　127
4.3.2　常量池　130
4.3.3　常量池缓存：ConstantPoolCache　133
4.3.4　方法的表示：methodOop　134
4.3.5　方法的解析：将符号引用转换成直接引用　138
4.3.6　代码放在哪里：ConstMethodOop　141
4.3.7　实战：探测运行时常量池　142
4.4　性能监控数据区：Perf Data　147
4.4.1　描述这段空间：PerfMemory　147
4.4.2　查看　148
4.4.3　生产　150
4.5　转储　151
4.5.1　用VisualVM进行转储分析　151
4.5.2　JVM Crash　153
4.6　小结　158
第5章　垃圾收集　159
5.1　堆与GC　160
5.1.1　垃圾收集　160
5.1.2　分代收集　162
5.1.3　快速分配　165
5.1.4　栈上分配和逸出分析　167
5.1.5　GC公共模块　167
5.2　垃圾收集器　170
5.2.1　设计演进　170
5.2.2　CMS收集器　175
5.2.3　G1收集器　180
5.3　实战：性能分析方法　184
5.3.1　获取GC日志　184
5.3.2　GC监控信息　187
5.3.3　内存分析工具　189
5.3.4　选择合适的收集器与GC性能评估　190
5.3.5　不要忽略JVM Crash日志　195
5.4　小结　196
第6章　栈　197
6.1　硬件背景：了解真实机器　198
6.1.1　程序是如何运行的　198
6.1.2　x86与栈帧　199
6.1.3　ARM对Java硬件级加速：Jazelle技术　202
6.2　Java栈　203
6.2.1　寄存器式指令集与栈式指令集　203
6.2.2　HotSpot中的栈　204
6.2.3　栈帧　207
6.2.4　充分利用寄存器资源　210
6.2.5　虚拟机如何调用Java函数　212
6.2.6　优化：栈顶缓存　221
6.2.7　实战：操作数栈　223
6.3　小结　228
第7章　解释器和即时编译器　229
7.1　概述　230
7.2　解释器如何工作　231
7.2.1　Interpreter模块　232
7.2.2　Code模块　234
7.2.3　字节码表　235
7.2.4　Code Cache　236
7.2.5　InterpreterCodelet与Stub队列　239
7.2.6　Code生成器　241
7.2.7　模板表与转发表　244
7.2.8　实战：InterpreterCodelet　247
7.3　即时编译器　250
7.3.1　概述　250
7.3.2　编译器模块　251
7.3.3　编译器的基本结构　252
7.3.4　实战：编译原理实践，了解编译中间环节　255
7.4　小结　267
第8章　指令集　268
8.1　再说栈式指令集　268
8.2　数据传送　270
8.2.1　局部变量、常量池和操作数栈之间的数据传送　270
8.2.2　数据传送指令　272
8.2.3　实战：数组的越界检查　277
8.3　类型转换　279
8.4　对象的创建和操作　281
8.5　程序流程控制　282
8.5.1　控制转移指令　282
8.5.2　条件转移　283
8.5.3　无条件转移　284
8.5.4　复合条件转移　285
8.5.5　实战：switch语句如何使用String　287
8.6　运算　290
8.6.1　加法：iadd　290
8.6.2　取负：ineg　291
8.7　函数的调用和返回　292
8.7.1　Java函数分发机制：VTABLE与ITABLE　293
8.7.2　invoke系列指令　297
8.7.3　动态分发：覆盖　299
8.7.4　静态分发：重载　302
8.8　异常　305
8.8.1　异常表　305
8.8.2　创建异常　306
8.8.3　try-catch　309
8.8.4　finally　311
8.9　小结　312
第9章　虚拟机监控工具　313
9.1　Attach机制　314
9.1.1　AttachProvider与VirtualMachine　314
9.1.2　命令的下发：execute()　317
9.1.3　命令的执行：Attach Listener守护线程　319
9.2　查看JVM进程　320
9.2.1　用jps查看Java进程　320
9.2.2　实战：定制jps，允许查看库路径　323
9.3　查看和配置JVM　326
9.3.1　用jinfo查看JVM参数配置　326
9.3.2　实战：扩展flags选项，允许查看命令行参数　330
9.4　堆内存转储工具　332
9.4.1　Heap Dump　332
9.4.2　原理　333
9.5　堆转储分析　337
9.5.1　Heap Dump分析工具：jhat　337
9.5.2　实战：MAT分析过程　340
9.6　线程转储分析　343
9.6.1　jstack　343
9.6.2　实战：如何分析资源等待　344
9.7　小结　347
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>HotSpot实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JAVA程序设计教程
第1章 Java语言与面向对象概述
1.1 Java发展简史
1.1.1 Java发展简介
1.1.2 Java语言的特点
1.2 Java虚拟机
1.2.1 Java 虚拟机的概念
1.2.2 Java 虚拟机的结构
1.3 Java 2平台的3种版本
1.3.1 Java SE
1.3.2 Java EE
1.3.3 Java ME
1.4 面向对象开发概述
1.4.1 面向对象编程的概念
1.4.2 面向对象编程的特点
1.4.3 对象的抽象和封装
1.4.4 面向对象的软件开发步骤
本章小结
习题
第2章 Java程序编程概述
2.1 JDK的安装与配置
2.1.1 JDK的安装
2.1.2 JDK的环境配置
2.2 Java 程序集成开发工具
2.2.1 UltraEdit工具
2.2.2 EditPlus工具
2.2.3 JCreator工具
2.2.4 Eclipse工具
2.3 Java应用程序实例
2.3.1 Java应用程序的编辑
2.3.2 Java应用程序的编译和运行
2.4 Java Applet实例
2.4.1 Java Applet源程序的编辑与编译
2.4.2 嵌入Java Applet的HTML文件
2.5 Java 应用程序的输入/ 输出
2.5.1 文本界面的输入/输出
2.5.2 图形界面的输入/输出
本章小结
习题
第3章 Java基本数据类型
3.1 Java程序基本组成元素
3.1.1 标识符
3.1.2 关键字
3.1.3 分隔符
3.1.4 注释
3.2 数据类型
3.2.1 整数类型
3.2.2 浮点类型
3.2.3 字符类型
3.2.4 布尔类型
3.2.5 基本数据类型之间的转换
3.3 变量与常量
3.3.1 常量
3.3.2 变量
3.4 运算符与表达式
3.4.1 赋值运算符与赋值表达式
3.4.2 算术运算符与算术表达式
3.4.3 关系运算符与条件运算符
3.4.4 逻辑运算符与逻辑表达式
3.4.5 位运算符与位表达式
3.4.6 复合赋值运算符
3.4.7 运算符的优先级
本章小结
习题
第4章 程序流程控制语句
4.1 结构化程序的3种结构
4.1.1 顺序结构
4.1.2 选择结构
4.1.3 循环结构
4.2 选择语句
4.2.1 if语句
4.2.2 switch语句
4.3 循环语句
4.3.1 for循环语句
4.3.2 while循环语句
4.3.3 do…while循环语句
4.4 循环跳离语句
4.4.1 break语句
4.4.2 continue语句
本章小结
习题
第5章 类与对象
5.1 类与对象的关系
5.2 类和对象的定义
5.2.1 类的定义
5.2.2 对象的初始化
5.2.3 构造方法的定义和重载
5.3 域的定义
5.3.1 静态域
5.3.2 静态初始化器
5.3.3 最终域与final关键字
5.4 方法的创建
5.4.1 方法的返回值
5.4.2 方法的参数传递
5.4.3 方法中的局部变量
5.4.4 静态方法
5.4.5 main()方法
5.4.6 方法的重载
5.4.7 this关键字
5.5 类与类之间的关系
本章小结
习题
第6章 继承、抽象、接口和包
6.1 类的继承
6.1.1 继承的基本概念
6.1.2 类的继承实现
6.1.3 域的隐藏
6.1.4 方法的覆盖
6.1.5 super关键字
6.1.6 对象的类型转换
6.2 抽象类和抽象方法
6.2.1 抽象类和抽象方法的定义
6.2.2 抽象类的实现
6.3 接口和多重继承
6.3.1 接口的定义
6.3.2 接口的实现
6.4 包
6.4.1 包的定义
6.4.2 包内类的装载
6.4.3 包的路径设置
6.5 访问控制符
6.5.1 public修饰符
6.5.2 private修饰符
6.5.3 protected修饰符
6.5.4 默认访问修饰符
本章小结
习题
第7章 Java基本类库
7.1 Java类库
7.1.1 Java类库概述
7.1.2 Java类库的使用方法
7.1.3 Object类
7.2 字符串
7.2.1 String类
7.2.2 StringBuffer类
7.2.3 字符串的分解
7.3 Math类
7.4 基本数据类型包装类
7.4.1 基本数据类型包装类
7.4.2 自动封包／拆包
7.5 Java异常处理
7.5.1 Java异常类层次结构
7.5.2 异常的捕获和处理
7.5.3 throws子句声明异常
7.5.4 自定义异常
本章小结
习题
第8章 数组与ArrayList类
8.1 一维数组
8.1.1 一维数组的声明与创建
8.1.2 一维数组的初始化
8.1.3 一维数组的应用实例
8.2 多维数组
8.2.1 二维数组的创建
8.2.2 列数不规则的二维数组
8.2.3 二维数组的应用实例
8.2.4 多维数组的创建
8.3 使用for…each循环语句访问数组
8.4 数组参数在方法中传递
8.5 Arrays类
8.6 ArrayList类
本章小结
习题
第9章 图形用户接口
9.1 Swing组件概述
9.1.1 Swing的简单示例
9.1.2 Swing的层次结构
9.2 框架
9.3 按钮与事件处理
9.3.1 按钮
9.3.2 按钮的事件处理
9.3.3 事件处理类
9.4 文本框与文本域
9.4.1 单行文本框与密码文本框
9.4.2 多行文本域
9.5 布局管理器
9.5.1 BorderLayout布局方式
9.5.2 FlowLayout布局方式
9.5.3 GridLayout布局方式
9.5.4 BoxLayout布局方式
9.6 选择框
9.6.1 复选框
9.6.2 单选按钮
9.7 下拉列表框
9.8 面板
本章小结
习题
第10章 文件与流
10.1 流概述
10.1.1 字节流
10.1.2 字符流
10.2 标准I/O流
10.3 File类
10.3.1 文件的创建
10.3.2 文件操作
10.4 文件流
10.4.1 文件输入流
10.4.2 文件输出流
10.5 随机存取文件流
10.6 对象序列化
10.6.1 ObjectOutputStream流
10.6.2 ObjectInputStream流
10.6.3 对象序列化实例
本章小结
习题
第11章 多线程
11.1 多线程的基本概念
11.1.1 多线程的引入
11.1.2 多线程的特点
11.2 多线程的实现
11.2.1 Thread类实现多线程
11.2.2 Runnable接口实现多线程
11.3 线程的生命周期
11.4 线程的调度管理
11.4.1 线程的优先级
11.4.2 join()方法的应用
11.4.3 sleep()方法的应用
11.4.4 yield()方法的应用
11.5 线程同步
11.5.1 同步方法
11.5.2 同步语句
11.6 线程间的通信
11.6.1 线程之间的通信问题
11.6.2 线程之间的通信解决方法
本章小结
习题
第12章 JDBC数据库编程基础
12.1 JDBC概述
12.2 使用JDBC存取应用程序数据
12.2.1 JDBC驱动设置
12.2.2 建立数据库连接
12.2.3 操纵数据库
12.3 JDBC进阶——PreparedStatement和CallableStatement接口
12.3.1 PreparedStatement接口
12.3.2 CallableStatement接口
12.4 一个完整的例子
12.4.1 实例说明
12.4.2 建立数据库连接基类basejdbc.java
12.4.3 建立班级数据表类classdb.java
12.4.4 完成业务逻辑appClass.java
12.4.5 程序运行结果
本章小结
习题
第13章 Servlet和JSP技术基础
13.1 Servlet技术及其特点
13.1.1 Servlet是什么？
13.1.2 Servlet的生命周期
13.1.3 Java Servlet API
13.1.4 创建HTTPServlet
13.1.5 Servlet技术的特点
13.2 JSP技术及其特点
13.2.1 JSP技术概述
13.2.2 JSP内置对象
13.2.3 JSP的语法
13.2.4 JSP技术的特点
13.3 使用Servlet和JSP开发Web应用
13.3.1 安装Servlet和JSP开发工具
13.3.2 安装支持Servlet的Web服务器——TOMCAT
13.3.3 创建和发布Web应用
本章小结
习题
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JAVA程序设计教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java面向对象程序设计实验实践教程
第1章  Java开发工具及程序设计初步	1
1.1  J2SDK开发工具入门	1
1.1.1  JDK的下载、安装	1
1.1.2  环境变量介绍和配置	5
1.1.3  JDK开发工具简介	7
1.2  Java程序开发步骤	7
1.3  Java程序基本结构	9
1.4  良好的编程习惯	10
1.5  实验目的	11
1.6  实验内容	11
实验1  第一个Java 应用程序	11
实验2  第一个Java Applet小程序	14
实验3  读程序，答问题	16
1.7  TextPad工具的使用	17
第2章  Java语言基础	19
2.1  知识点	19
2.2  实验目的	19
2.3  实验内容	19
实验1  程序填空与测试分析	19
实验2  编程测试Java数值类型的最大值和最小值	20
实验3  韩信点兵问题	21
实验4  实现简易移位加密	21
实验5  基本数据类型应用：自我介绍	22
第3章  Java输入/输出	23
3.1  知识点	23
3.2  实验目的	23
3.3  实验内容	23
实验1  标准输入/输出方法	23
实验2  键盘输入–Scanner类	25
实验3  综合实践	27
第4章  程序流程控制、算法和方法设计	29
4.1  知识点	29
4.2  实验目的	30
4.3  实验内容	30
实验1  选择结构	30
实验2  循环结构	33
实验3  循环嵌套	36
实验4  迭代和穷举算法	37
实验5  综合实践	41
第5章  Java数组	45
5.1  知识点	45
5.2  实验目的	46
5.3  实验内容	46
实验1  一维数组实验	46
实验2  二维数组实验	49
实验3  Arrays类	52
实验4  综合实践	53
第6章  类的结构和设计	59
6.1  知识点	59
6.2  实验目的	60
6.3  实验内容	60
实验1  类的定义及对象的创建和使用	60
实验2  对象比较和字符串的比较	64
实验3  引用型参数传递	66
实验4  静态变量和静态方法应用	71
实验5  类的继承：this和super	73
实验6  抽象类和接口	77
实验7  方法重载和方法重构	79
实验8  成员变量的隐藏	80
实验9  泛型应用	81
实验10  综合实践	83
第7章  UML类图及面向对象设计的基本原则、模式	99
7.1  知识点	99
7.2  实验目的	101
7.3  实验内容	101
实验1  面向抽象编程	101
实验2  多用组合、少用继承编程	105
实验3  策略模式设计	106
实验4  中介者模式	107
实验5  模板方法模式	112
第8章  Java包	114
8.1  知识点	114
8.2  实验目的	115
8.3  实验内容	115
实验1  jar包的创建	115
实验2  包的定义和互连	119
第9章  GUI和事件驱动	122
9.1  知识点	122
9.2  实验目的	124
9.3  实验内容	125
实验1  组件应用入门	125
实验2  文本框的应用	126
实验3  菜单的应用	130
实验4  窗口及对话框的应用	132
实验5  表格的应用	135
实验6  MVC结构	137
实验7  音乐播放器	139
实验8  综合实践	141
第10章  Java图形及多线程	149
10.1  知识点	149
10.2  实验目的	153
10.3  实验内容	153
实验1  绘制图形	153
实验2  用Thread类创建线程	157
实验3  实现Runnable接口创建线程	159
实验4  线程间的数据共享：模拟航空售票	160
实验5  多线程的同步控制：模拟银行取款	161
实验6  综合实践	162
第11章  JDBC编程	166
11.1  知识点	166
11.2  实验目的	169
11.3  实验内容	170
实验1  Access数据库的创建与ODBC数据源	170
实验2  运用JDBC操作数据库	173
第12章  综合设计	176
实验1  UML分析和模块化实现猜数字游戏	176
实验2  UML设计	179
实验3  网络通信	183
实验4  四则运算和日期计算	187
参考答案	206
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java面向对象程序设计实验实践教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计实践教程
目录
第1篇实验指导
实验一简单的Java程序
实验二Java语言基础
实验三顺序结构程序
实验四选择结构程序
实验五循环结构程序
实验六字符串处理与数组应用
实验七Java类与对象
实验八类的继承和多态机制
实验九异常处理
实验十输入／输出处理
实验十一多线程编程
实验十二网络程序设计
实验十三数据库应用开发
实验十四图形用户界面设计
第2篇习题选解
习题一Java语言概述
习题二Java语言基础
习题三算法与程序控制结构
习题四Java类与对象
习题五类的继承与多态性
习题六异常处理与输入／输出
习题七多线程
习题八网络程序设计
习题九数据库应用开发
习题十图形用户界面设计
第3篇应用案例
案例一网上聊天系统
案例二学生管理系统
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计实践教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java攻略
译者序　　ix
序　　xi
前言　　xiii
第1章　基础知识　　1
1.1　lambda 表达式　　2
1.2　方法引用　　5
1.3　构造函数引用　　8
1.4　函数式接口　　12
1.5　接口中的默认方法　　14
1.6　接口中的静态方法　　17
第2章　java.util.function 包　　20
2.1　Consumer 接口　　20
2.2　Supplier 接口　　22
2.3　Predicate 接口　　25
2.4　Function 接口　　28
第3章　流式操作　　31
3.1　流的创建　　31
3.2　装箱流　　35
3.3　利用reduce 方法实现归约操作　　36
3.4　利用reduce 方法校验排序　　44
3.5　利用peek 方法对流进行调试　　45
3.6　字符串与流之间的转换　　47
3.7　获取元素数量　　50
3.8　汇总统计　　52
3.9　查找流的第一个元素　　54
3.10　使用anyMatch、allMatch 与noneMatch 方法　　58
3.11　使用flatMap 与map 方法　　60
3.12　流的拼接　　63
3.13　惰性流　　66
第4章　比较器与收集器　　69
4.1　利用比较器实现排序　　69
4.2　将流转换为集合　　72
4.3　将线性集合添加到映射　　75
4.4　对映射排序　　77
4.5　分区与分组　　79
4.6　下游收集器　　81
4.7　查找最大值和最小值　　83
4.8　创建不可变集合　　85
4.9　实现Collector 接口　　87
第5章　流式操作、lambda 表达式与方法引用的相关问题　　91
5.1　java.util.Objects 类　　91
5.2　lambda 表达式与效果等同于final 的变量　　93
5.3　随机数流　　96
5.4　Map 接口的默认方法　　97
5.5　默认方法冲突　　101
5.6　集合与映射的迭代　　103
5.7　利用Supplier 创建日志消息　　105
5.8　闭包复合　　107
5.9　利用提取的方法实现异常处理　　110
5.10　受检异常与lambda 表达式　　112
5.11　泛型异常包装器的应用　　114
第6章　Optional 类　　117
6.1　Optional 的创建　　118
6.2　从Optional 中检索值　　120
6.3　getter 和setter 方法中的Optional　　122
6.4　Optional.flatMap 与Optional.map 方法　　124
6.5　Optional 的映射　　127
第7章　文件I/O　　131
7.1　文件处理　　132
7.2　以流的形式检索文件　　134
7.3　文件系统的遍历　　135
7.4　文件系统的搜索　　137
第8章　java.time 包　　139
8.1　Date-Time API 中的基本类　　140
8.2　根据现有实例创建日期和时间　　143
8.3　调节器与查询　　147
8.4　将java.util.Date 转换为java.time.LocalDate　　152
8.5　解析与格式化　　155
8.6　查找具有非整数小时偏移量的时区　　158
8.7　根据UTC 偏移量查找地区名　　160
8.8　获取事件之间的时间　　162
第9章　并行与并发　　165
9.1　将顺序流转换为并行流　　166
9.2　并行流的优点　　169
9.3　调整线程池大小　　173
9.4　Future 接口　　175
9.5　完成CompletableFuture　　178
9.6　多个CompletableFuture 之间的协调（第1 部分）　　181
9.7　多个CompletableFuture 之间的协调（第2 部分）　　186
第10章　Java 9 新特性　　193
10.1　Jigsaw 中的模块　　194
10.2　接口中的私有方法　　198
10.3　创建不可变集合　　200
10.4　新增的Stream 方法　　204
10.5　下游收集器：filtering 与flatMapping　　207
10.6　新增的Optional 方法　　210
10.7　日期范围　　212
附录A　泛型与Java 8　　215
作者简介　　230
封面介绍　　230
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java攻略
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>漫画面向对象编程
第1章 故事的开始 001
第2章 面向对象简介　005
第3章 如何由类创建一个对象　008
第4章 编写一个类，并创建一个对象　011
4.1　包　013
4.2　涉及的变量类型　014
第5章 类的构造函数　015
5.1　自定构造函数　018
5.2　编写多个构造函数　020
第6章 类的方法：让对象活动起来　021
第7章 修饰符　025
第8章 Java的第 一特征：封装　029
第9章 Java的第二特征：继承　032
9.1　继承　033
9.2　继承的好处　035
9.3　继承关系下，修饰符的有效范围　037
第10章 Java的第三特征：多态　039
10.1　丢失的方法　040
10.2　新的战术　043
10.3　对象变量与对象的区别　047
10.4　多态的例子　048
10.5　接口　052
10.6　接口的另外一种理解　054
10.7　再理解接口　056
10.8　Arraylist介绍　059
第11章 Java的一些事　060
11.1　变量类型的改变　061
11.2　Java不支持多继承　062
11.3　Java的多次继承　063
11.4　Java的修饰符　066
第12章 补充的知识点　069
12.1　线程问题　070
12.2　线程　073
12.3　创建线程　074
12.4　线程例子 078 12.5 异常处理　079
第13章 用Java创建一个小世界　082
13.1世界的时钟　083
13.2　设计动物类和接口　084
13.3　接口数组　085
13.4　计算动物的生命值　086
13.5　动物的编号　087
13.6　随机生成动物　088
13.7　死亡动物的处理　089
第14章 多线程共享数据　091
14.1　乡村竞赛　092
14.2　多线程共享数据　096
14.3　线程同步方式　099
第15章 上半部分结束　103
第16章 设计模式　104
16.1　设计模式简介　105
16.2　UML介绍　106
16.3　关联关系的分类　108
16.4　单例模式　109
16.5　工厂模式：要啥有啥的工厂　112
16.6　建造者模式：改变的建造流程　118
16.7　代理模式：片头和片尾　123
16.8　装饰模式：外卖的小哥　126
16.9　组合模式：汉堡套餐　133
16.10　命令模式：控制命令　139
16.11　策略模式：会员的折扣　144
16.12　状态模式：自己改变的红绿灯　147
16.13　适配器模式：傲娇的电器　152
16.14　访问者模式：传来传去　155
16.15　观察者模式：被观察者才是控制者　159
第17章 结束语　163
附录A　搭建Java开发环境　164
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>漫画面向对象编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言导学（英文版第6版）
第1章快速入门
关于Java技术
Java程序语言
Java平台
Java技术的功能
Java技术的优势
“Hello World！”示例程序
用NetBeans IDE开发“Hello World！”
在Microsoft Windows中开发“Hello World！”
在Solaris和Linux中开发“Hello World！”
“Hello World！”示例程序剖析
源码注释
HelloWorldApp类定义
main方法
常见问题（及其解决方案）
编译器问题
运行时问题
问题和练习：快速入门
问题
练习
答案
第2章面向对象的编程概念
对象
类
继承
接口
包
问题和练习：面向对象的编程概念
问题
练习
答案
第3章语言基础
变量
命名
基本数据类型
数组
小结
问题和练习：变量
运算符
赋值运算符、算术运算符和一元运算符
等式运算符、关系运算符和条件运算符
位运算符和移位运算符
小结
问题和练习：运算符
表达式、语句和块
表达式
语句
块
问题和练习：表达式、语句和块
控制流语句
if—then语句和if—then—else语句
switch语句
while语句和do—while语句
for语句
分支语句
小结
问题和练习：控制流语句
第4章类和对象
类
声明类
声明成员变量
定义方法
构建构造器
将消息传给方法或构造器
对象
创建对象
使用对象
类的更多细节
方法的返回值
使用this关键字
控制对类成员的访问
类成员
初始化字段
小结
问题和练习：类
问题和练习：对象
嵌套类
为什么使用嵌套类
静态嵌套类
内部类
隐藏
序列化
内部类示例
局部类和匿名类
修饰符
局部类
匿名类
Lambda表达式
何时使用嵌套类、局部类、匿名类和
Lambda表达式
问题和练习：嵌套类
枚举类型
问题和练习：枚举类型
第5章注解
注解的基本概念
注解格式
哪些地方使用注解
声明注解类型
预定义注解类型
Java语言使用的注解类型
应用于其他注解的注解类型
类型注解和可插拔类型系统
重复注解
步骤1：声明可重复的注解类型
步骤2：声明包含的注解类型
检索注解
设计注意事项
问题和练习：注解
问题
练习
答案
第6章接口与继承
接口
Java语言的接口
将接口用作API
定义接口
实现接口
将接口用作类型
演化接口
默认方法
小结
问题和练习：接口
继承
Java平台中类的层次结构
继承示例
子类能做什么
超类的私有成员
转换对象
状态、实现和类型的多继承
覆盖和屏蔽方法
多态性
屏蔽字段
使用super关键字
将对象用作超类
编写final类和方法
抽象方法和类
小结
问题和练习：继承
第7章泛型
为什么用泛型
泛型类型
一个简单的Box类
Box类的泛型版本
类型参数命名约定
泛型类型的调用和实例化
钻石运算符
多个类型参数
参数化类型
原生类型
泛型方法
受限类型参数
多重限制
泛型方法和受限类型参数
泛型、继承和子类型
泛型类和子类型
类型推导
类型推导与泛型方法
类型推导与泛型类的实例化
类型推导与泛型类和非泛型类的泛型
构造器
目标类型
通配符
上界通配符
界通配符
下界通配符
通配符和予类型
通配符匹配和辅助方法
通配符使用指南
类型擦除
泛型类型的擦除
泛型方法的擦除
类型擦除效果和桥方法
不可具体化类型和可变长参数方法
泛型的局限性
不能用基本数据类型实例化泛型类型
不能创建类型参数实例
不能声明类型为“类型参数”的静态字段
对参数化类型不能用类型转换或运算符
不能创建参数化类型数组
不能创建、捕获或抛出参数化类型的对象
不能重载方法，若方法每次重载的形式
参数类型都被擦为相同的原生类型
问题和练习：泛型
答案
第8章程序包
创建和使用程序包
创建程序包
命名程序包
使用程序包成员
管理源文件和类文件
小结
问题和练习：创建和使用程序包
问题
练习
答案
第9章，数和字符串
数
Number类
格式化数字打印输出
其他数学运算方法
自动装箱和拆箱
小结
问题和练习：数
字符
转义字符
字符串
创建字符串
字符串长度
字符串连接
创建格式字符串
数字和字符串之间的转换
操作字符串中的字符
比较字符串和字符串的子串
StringBuilder类
小结
问题和练习：字符和字符串
第10章异常
什么是异常
捕获或指明规定
三类异常
绕过捕获或指明
捕获和处理异常
try块
catch块
finally块
try—with—resources语句
汇总
指明一个方法抛出的异常
如何抛出异常
throw语句
Throwable类及其子类
Error类
Exception类
链式异常
创建异常类
未检查异常：争议
异常的优点
优点1：从正规代码中分离出错误处理代码
优点2：根据调用栈上传错误
优点3：分组和区分错误类型
小结
问题和练习
问题
练习
答案
第11章基本I／O和NIO.2
I／O流
字节流
字符流
缓冲流
扫描和格式化
命令行I／o
数据流
对象流
文件I／O（以NIO.2为特征）
什么是路径（以及其他文件系统情况）
Path类
文件操作
检查文件或目录
删除文件或目录
复制文件或目录
移动文件或目录
管理元数据（文件和文件存储属性）
读取、写入和创建文件
随机存取文件
创建和读取目录
符号链接或其他方式的链接
遍历文件树
查找文件
监视目录的变化
其他有用的方法
遗留文件的I／O代码
小结
问题和练习：基本I／O
问题
练习
答案
……
第12章集合
第13章并发
第14章正则表达式
第15章平台环境
第16章在JAR文件中打包程序
第17章Java WebStan
第18章印plet
第19章Java富互联网应用系统
第20章深入理解部署
第21章日期／时间API
第22章JavaFX简介
附录Java程序语言认证复习大纲
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言导学（英文版第6版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构与抽象
出版者的话
译者序
前言
导论　组织数据 1
序言　设计类 3
封装 3
规范说明方法 5
注释 5
前置条件和后置条件 5
断言 6
Java接口 7
写一个接口 8
实现一个接口 9
接口作为数据类型 11
派生一个接口 12
接口内的命名常量 13
选择类 14
标识类 15
CRC卡 15
统一建模语言 16
重用类 18
练习 19
项目 19
第1章　包 22
什么是包 22
包的行为 23
规范说明一个包 23
一个接口 28
使用ADT包 30
像使用自动贩卖机一样使用ADT 33
ADT集合 34
Java类库：接口Set 35
本章小结 35
练习 36
项目 37
Java插曲1　泛型 40
泛型数据类型 40
接口中的泛型 40
泛型类 41
第2章　使用数组实现包 44
使用定长数组实现ADT包 44
模拟 44
一组核心方法 45
实现核心方法 46
让实现安全 52
测试核心方法 54
实现更多的方法 57
删除项的方法 59
使用变长数组实现ADT包 67
变长数组 67
包的新实现 69
使用数组实现ADT包的优缺点 71
本章小结 72
程序设计技巧 72
练习 73
项目 74
Java插曲2　异常 75
基础 75
处理异常 77
延缓处理：throws子句 77
现在处理：try-catch块 78
多个catch块 79
抛出异常 80
第3章　使用链式数据实现包 83
链式数据 83
添加到开头形成一个链表 84
ADT包的链式实现 85
私有类Node 85
类LinkedBag的框架 87
定义一些核心方法 88
测试核心方法 91
方法getFrequencyOf 92
方法contains 93
从链表中删除一项 94
方法remove和clear 95
有设置和获取方法的类Node 98
使用链表实现ADT包的优缺点 101
本章小结 101
程序设计技巧 101
练习 102
项目 102
第4章　算法的效率 104
动机 104
算法效率的衡量 105
统计基本操作 107
最优、最差和平均情况 109
大O表示 109
程序结构的复杂度 112
图示化效率 113
实现ADT包的效率 115
基于数组的实现 115
链式实现 117
两种实现的比较 118
本章小结 118
练习 118
项目 121
第5章　栈 123
ADT栈的规范说明 123
使用栈来处理代数表达式 127
问题求解：检查中缀代数表达式中平衡的分隔符 128
问题求解：将中缀表达式转换为后缀表达式 132
问题求解：计算后缀表达式的值 136
问题求解：计算中缀表达式的值 137
程序栈 139
Java类库：类Stack 140
本章小结 141
程序设计技巧 141
练习 141
项目 143
第6章　栈的实现 146
链式实现 146
基于数组的实现 149
基于向量的实现 152
Java类库：类Vector 153
使用Vector实现ADT栈 154
本章小结 155
练习 156
项目 156
Java插曲3　再论异常 158
程序员定义的异常类 158
继承和异常 162
finally块 163
第7章　队列、双端队列和优先队列 166
ADT队列 166
问题求解：模拟排队 169
问题求解：计算股票售出的资本收益 174
Java类库：接口Queue 177
ADT双端队列 177
问题求解：计算股票售出的资本收益 180
Java类库：接口Deque 181
Java类库：类ArrayDeque 182
ADT优先队列 183
问题求解：跟踪指派 184
Java类库：类PriorityQueue 185
本章小结 186
程序设计技巧 187
练习 187
项目 188
第8章　队列、双端队列和优先队列的实现 192
队列的链式实现 192
基于数组实现队列 196
循环数组 196
带一个未用元素的循环数组 198
队列的循环链式实现 203
两部分组成的循环链表 204
Java类库：类AbstractQueue 209
队列的双向链式实现 209
优先队列的可能实现方案 213
本章小结 213
程序设计技巧 214
练习 214
项目 215
第9章　递归 217
什么是递归 217
跟踪递归方法 221
返回一个值的递归方法 224
递归处理数组 226
递归处理链表 228
递归方法的时间效率 230
countDown的时间效率 230
计算xn的时间效率 231
尾递归 232
使用栈来替代递归 233
本章小结 234
程序设计技巧 234
练习 235
项目 237
第10章　线性表 240
ADT线性表的规范说明 240
使用ADT线性表 246
问题求解：使用大整数 250
Java类库：接口List 252
Java类库：类ArrayList 252
本章小结 253
练习 253
项目 254
第11章　使用数组实现线性表 257
使用数组实现ADT线性表 257
模拟 257
Java实现 259
使用数组实现ADT线性表的效率 266
本章小结 268
练习 268
项目 269
第12章　使用链式数据实现线性表 271
结点链表上的操作 271
在不同的位置添加结点 271
从不同的位置删除结点 275
私有方法getNodeAt 276
实现之初 277
数据域和构造方法 278
添加到线性表表尾 279
在线性表的给定位置添加 280
方法isEmpty和toArray 281
测试核心方法 283
继续实现 284
完善实现 286
尾引用 287
使用链表实现ADT线性表的效率 290
Java类库：类LinkedList 292
本章小结 292
练习 293
项目 294
Java插曲4　迭代器 296
什么是迭代器 296
接口Iterator 297
接口Iterable 298
使用接口Iterator 299
Iterable和for-each循环 302
接口ListIterator 303
再论接口List 306
使用接口ListIterator 306
第13章　ADT线性表的迭代器 309
实现迭代器的方法 309
独立类迭代器 309
内部类迭代器 312
链式实现 313
基于数组的实现 316
为什么迭代器方法在它自己的类中 319
基于数组实现接口ListIterator 320
内部类 322
本章小结 327
程序设计技巧 327
练习 327
项目 329
第14章　使用递归求解问题 331
困难问题的简单求解方案 331
简单问题的低劣求解方案 336
语言和语法 338
Java标识符语言 338
前缀表达式语言 339
前缀表达式的计算 342
间接递归 343
回溯 343
穿越迷宫 344
n皇后问题 345
本章小结 347
练习 348
项目 349
Java插曲5　再论泛型 352
接口Comparable 352
泛型方法 354
限定的类型参数 354
通配符 357
限定的通配符 357
第15章　排序简介 360
对数组进行排序的Java方法的组织 360
选择排序 361
迭代的选择排序 362
递归的选择排序 364
选择排序的效率 364
插入排序 365
迭代的插入排序 366
递归的插入排序 367
插入排序的效率 369
结点链表上的插入排序 369
希尔排序 372
算法 373
希尔排序的效率 374
算法比较 374
本章小结 375
程序设计技巧 375
练习 375
项目 377
第16章　更快的排序方法 379
归并排序 379
归并数组 379
递归的归并排序 380
归并排序的效率 382
迭代的归并排序 384
Java类库中的归并排序 384
快速排序 385
快速排序的效率 385
创建划分 386
实现快速排序 388
Java类库中的快速排序 390
基数排序 390
基数排序的伪代码 392
基数排序的效率 392
算法比较 393
本章小结 393
练习 394
项目 395
Java插曲6　可变及不可变对象 397
可变对象 397
不可变对象 398
创建只读类 399
伴生类 400
第17章　有序表 403
ADT有序表的规范说明 403
使用ADT有序表 406
链式实现 407
方法add 408
链式实现的效率 414
使用ADT线性表的实现 414
效率问题 417
本章小结 418
练习 419
项目 419
Java插曲7　继承和多态 421
继承的其他方面 421
何时使用继承 421
保护访问 422
抽象类和方法 422
接口与抽象类 424
多态 425
第18章　继承和线性表 430
使用继承实现有序表 430
设计一个基类 432
创建抽象基类 436
有序表的高效实现 439
方法add 439
本章小结 440
程序设计技巧 440
练习 440
项目 441
第19章　查找 443
问题 443
在无序数组中查找 443
无序数组中的迭代顺序查找 444
无序数组中的递归顺序查找 445
顺序查找数组的效率 446
在有序数组中查找 446
有序数组中的顺序查找 447
有序数组中的二分查找 447
Java类库：binarySearch方法 451
数组中二分查找的效率 451
在无序链表中查找 453
无序链表中的迭代顺序查找 453
无序链表中的递归顺序查找 453
链表中顺序查找的效率 454
在有序链表中查找 454
有序链表中的顺序查找 454
有序链表中的二分查找 455
查找方法的选择 455
本章小结 456
程序设计技巧 456
练习 456
项目 458
Java插曲8　三论泛型 460
多个泛型 460
第20章　字典 462
ADT字典的规范说明 462
Java接口 465
迭代器 466
使用ADT字典 468
问题求解：电话号码簿 468
问题求解：单词的频率 472
问题求解：单词的索引 475
Java类库：接口Map 478
本章小结 478
程序设计技巧 478
练习 479
项目 479
第21章　字典的实现 482
基于数组的实现 482
基于无序数组的字典 482
基于有序数组的字典 487
链式实现 491
无序链式字典 491
有序链式字典 492
本章小结 494
程序设计技巧 494
练习 494
项目 495
第22章　散列简介 496
什么是散列 496
散列函数 498
计算散列码 498
将散列码压缩为散列表的下标 501
解决冲突 502
开放地址的线性探查 502
开放地址的二次探查 507
开放地址的双散列 508
开放地址的潜在问题 510
拉链法 510
本章小结 513
练习 513
项目 514
第23章　使用散列实现字典 516
散列的效率 516
装填因子 516
开放地址法的代价 517
拉链法的代价 518
再散列 519
冲突解决机制的比较 520
使用散列实现字典 521
散列表中的项 521
数据域和构造方法 522
方法getValue、remove和add 523
迭代器 525
Java类库：类HashMap 526
Java类库：类HashSet 527
本章小结 527
练习 528
项目 528
第24章　树 531
树的概念 531
层次结构 531
树的术语 532
树的遍历 537
二叉树的遍历 537
一般树的遍历 538
用于树的Java接口 539
用于所有树的接口 539
用于二叉树的接口 540
二叉树示例 541
表达式树 541
决策树 543
二叉查找树 545
堆 547
一般树示例 548
解析树 549
游戏树 550
本章小结 550
练习 551
项目 553
第25章　树的实现 555
二叉树中的结点 555
二叉结点类 556
ADT二叉树的实现 557
创建基本二叉树 557
方法initializeTree 559
访问方法和赋值方法 561
计算高度和结点个数 562
遍历 563
表达式树的实现 567
一般树 568
用于一般树的结点 568
使用二叉树表示一般树 569
本章小结 570
程序设计技巧 570
练习 570
项目 572
Java插曲9　克隆 574
可克隆的对象 574
克隆一个数组 579
克隆一个链表 581
有序表的克隆 585
克隆一个二叉结点 587
第26章　二叉查找树的实现 589
入门知识 589
用于二叉查找树的接口 590
重复项 591
开始定义类 592
查找和获取 593
遍历 595
添加一项 595
递归实现 596
迭代实现 598
删除一项 600
删除叶结点中的项 600
删除仅有一个孩子的结点中的项 600
删除有两个孩子的结点中的项 601
删除根中的项 604
递归实现 604
迭代实现 607
操作效率 610
平衡的重要性 611
结点按什么次序添加 611
ADT字典的实现 612
本章小结 614
练习 615
项目 617
第27章　堆的实现 620
再论：ADT堆 620
使用数组表示堆 620
添加项 623
删除根 626
创建堆 628
堆排序 630
本章小结 633
练习 633
项目 634
第28章　平衡查找树 636
AVL树 636
单旋转 636
双旋转 639
实现细节 642
2-3树 646
在2-3树中进行查找 646
向2-3树中添加项 647
添加过程中结点的分裂 649
2-4树 650
向2-4树中添加项 650
AVL树、2-3树和2-4树的比较 652
红黑树 653
红黑树的特性 654
向红黑树中添加项 654
Java类库：类TreeMap 659
B树 659
本章小结 660
练习 660
项目 661
第29章　图 663
一些示例及术语 663
公路地图 663
航空公司的航线 665
迷宫 666
先修课程 666
树 667
遍历 667
广度优先遍历 668
深度优先遍历 669
拓扑序 670
路径 672
寻找路径 673
无权图中的最短路径 673
带权图中的最短路径 675
用于ADT图的Java接口 678
本章小结 681
练习 682
项目 684
第30章　图的实现 686
两个实现概述 686
邻接矩阵 686
邻接表 687
顶点和边 688
规范说明类Vertex 688
内部类Edge 690
类Vertex的实现 691
ADT图的实现 694
基本操作 694
图算法 697
本章小结 699
练习 699
项目 701
附录A　文档和程序设计风格 702
附录B　Java类 706
附录C　从其他类创建类 727
补充材料1　Java基础（在线）
补充材料2　文件输入输出（在线）
补充材料3　词汇表（在线）
补充材料4　学习问题答案（在线）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据结构与抽象
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>尽在双11：阿里巴巴技术演进与超越
序一  IX
序二  X
双11大事年表  XII
引言  XIII
第1章 阿里技术架构演进  1
双11是阿里技术发展的强大驱动力，双11业务的快速发展造就了阿里具备高度水平伸缩能力、低成本的电商架构体系。这个架构体系是如何一步一步形成的呢？在形成过程中阿里遇到了哪些问题，做了哪些尝试，最终用什么样的思路、方法和技术解决了问题？
1.1 五彩石，电商架构新起点  3
1.2 异地多活，解除单地域部署限制的新型双11扩容方式  9
1.3混合云，利用阿里云弹性大幅降低双11成本  17
1.4 OceanBase，云时代的关系数据库  23
1.5 手机淘宝，移动互联网电商新时代  30
1.6 蚂蚁技术架构演进  36
第2章 稳定，双11的生命线  43
双11最大的困难在于零点峰值的稳定性保障。面对这种世界级的场景、独一无二的挑战，阿里建设了大量高可用技术产品，形成了全链路一体化的解决方案，用更加逼真和自动化的方式，去评估、优化和保护整个技术链条，最大化地为用户提供稳定可靠的服务。
2.1 容量规划，资源分配的指南针  45
2.2 全链路压测，大促备战的核武器  51
2.3 全链路功能，提前开始的狂欢盛宴  58
2.4 自动化备战，喝着咖啡搞大促  65
2.5 实时业务审计，从系统可用到业务正确  70
2.6 故障演练，系统健壮性的探测仪  75
2.7 系统自我保护，稳定性的最后一道屏障  82
第3章 技术拓展商业边界  89
双11业务驱动技术发展的同时，技术的创新与发展也不断推动着商业模式的升级与变革，实践着技术拓展商业的边界。
3.1 招商报名，活动基础设施建设  91
3.2 会场，小二与商家共同打造的购物清单  99
3.3 搜索，大促场景下智能化演进之路  107
3.4 个性化推荐，大数据和智能时代的新航路  114
3.5 供应链，从飞速增长到精耕细作  120
3.6 蚂蚁花呗，无忧支付的完美体验  127
第4章 移动端的技术创新之路  133
从2010年开始，国内爆发了从PC向移动端技术和业务的持续迁移，移动深刻地改变着人们的衣食住行和人际交往。阿里的双11始于2009年，正好经历了移动互联网崛起的全程，双11在移动端的主要创新有哪些呢？
4.1 Weex，让双11更流畅  135
4.2 互动，让购物变成狂欢  143
4.3 VR&AR，移动端创新体验  153
4.4 奥创&TMF，让双11多端业务腾飞  163
第5章 繁荣生态，赋能商家  171
双11从阿里内部员工的一个点子到全球购物狂欢节，其背后支撑是服务、物流、大数据、云计算、金融服务等，是商家自身业务结构的调整、消费者消费习惯的转变、第三方开发者的大量入驻，以及整个生态的变迁。
5.1 聚石塔，开放的电商云工作台  173
5.2 菜鸟电子面单，大数据改变物流  179
5.3 生意参谋，数据赋能商家的“黑科技”  184
5.4 阿里小蜜，用智能重新定义服务  191
5.5 阿里中间件，让传统企业插上互联网的翅膀  198
5.6 蚂蚁金服，金融机构间协同运维的探索和实践  205
展望  213
索引  216
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>尽在双11：阿里巴巴技术演进与超越
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>研磨设计模式
第1章 设计模式基础
1.1 设计模式是什么
1.1.1 什么是模式
1.1.2 设计模式的概念
1.1.3 设计模式的理解
1.1.4 设计模式的历史
1.2 设计模式有什么
1.2.1 设计模式的组成
1.2.2 设计模式的分类
1.3 设计模式的学习
1.3.1 为什么要学习设计模式
1.3.2 学习设计模式的层次
1.3.3 如何学习设计模式
1.4 本书的组织方式
1.4.1 本书所讲述的设计模式的提纲
1.4.2 每个模式的讲述结构
第2章 简单工厂
2.1 场景问题
2.1.1 接口回顾
2.1.2 面向接口编程
2.1.3 不用模式的解决方案
2.1.4 有何问题
2.2 解决方案
2.2.1 使用简单工厂来解决问题
2.2.2 简单工厂的结构和说明
2.2.3 简单工厂示例代码
2.2.4 使用简单工厂重写示例
2.3 模式讲解
2.3.1 典型疑问
2.3.2 认识简单工厂
2.3.3 简单工厂中方法的写法
2.3.4 可配置的简单工厂
2.3.5 简单工厂的优缺点
2.3.6 思考简单工厂
2.3.7 相关模式
第3章 外观模式
3.1 场景问题
3.1.1 生活中的示例
3.1.2 代码生成的应用
3.1.3 不用模式的解决方案
3.1.4 有何问题
3.2 解决方案
3.2.1 使用外观模式来解决问题
3.2.2 外观模式的结构和说明
3.2.3 外观模式示例代码
3.2.4 使用外观模式重写示例
3.3 模式讲解
3.3.1 认识外观模式
3.3.2 外观模式的实现
3.3.3 外观模式的优缺点
3.3.4 思考外观模式
3.3.5 相关模式
第4章 适配器模式（Adapter）
4.1 场景问题
4.1.1 装配电脑的例子
4.1.2 同时支持数据库和文件的日志管理
4.1.3 有何问题
4.2 解决方案
4.2.1 使适配器模式来解决问题
4.2.2 模式的结构和说明
4.2.3 适配器模式示例代码
4.2.4 使用适配器模式来实现示例
4.3 模式讲解
4.3.1 认识适配器模式
4.3.2 适配器模式的实现
4.3.3 双向适配器
4.3.4 对象适配器和类适配器
4.3.5 适配器模式的优缺点
4.3.6 思考适配器模式
4.3.7 相关模式
第5章 单例模式（Singleton）
5.1 场景问题
5.1.1 读取配置文件的内容
5.1.2 不用模式的解决方案
5.1.3 有何问题
5.2 解决方案
5.2.1 使用单例模式来解决问题
5.2.2 单例模式的结构和说明
5.2.3 单例模式示例代码
5.2.4 使用单例模式重写示例
5.3 模式讲解
5.3.1 认识单例模式
5.3.2 懒汉式和饿汉式实现
5.3.3 延迟加载的思想
5.3.4 缓存的思想
5.3.5 Java中缓存的基本实现
5.3.6 利用缓存来实现单例模式
5.3.7 单例模式的优缺点
5.3.8 在Java中一种更好的单例实现方式
5.3.9 单例和枚举
5.3.10 思考单例模式
5.3.11 相关模式
第6章 工厂方法模式（Factory Method）
6.1 场景问题
6.1.1 导出数据的应用框架
6.1.2 框架的基础知识
6.1.3 有何问题
6.2 解决方案
6.2.1 使用工厂方法模式来解决问题
6.2.2 工厂方法模式的结构和说明
6.2.3 工厂方法模式示例代码
6.2.4 使用工厂方法模式来实现示例
6.3 模式讲解
6.3.1 认识工厂方法模式
6.3.2 工厂方法模式与IoC/DI
6.3.3 平行的类层次结构
6.3.4 参数化工厂方法
6.3.5 工厂方法模式的优缺点
6.3.6 思考工厂方法模式
6.3.7 相关模式
第7章 抽象工厂模式 （Abstract Factory）
7.1 场景问题
7.1.1 选择组装电脑的配件
7.1.2 不用模式的解决方案
7.1.3 有何问题
7.2 解决方案
7.2.1 使用抽象工厂模式来解决问题
7.2.2 抽象工厂模式的结构和说明
7.2.3 抽象工厂模式示例代码
7.2.4 使用抽象工厂模式重写示例
7.3 模 式 讲 解
7.3.1 认识抽象工厂模式
7.3.2 定义可扩展的工厂
7.3.3 抽象工厂模式和DAO
7.3.4 抽象工厂模式的优缺点
7.3.5 思考抽象工厂模式
7.3.6 相关模式
第8章 生成器模式（Builder）
8.1 场景问题
8.1.1 继续导出数据的应用框架
8.1.2 不用模式的解决方案
8.1.3 有何问题
8.2 解决方案
8.2.1 使用生成器模式来解决问题
8.2.2 生成器模式的结构和说明
8.2.3 生成器模式示例代码
8.2.4 使用生成器模式重写示例
8.3 模式讲解
8.3.1 认识生成器模式
8.3.2 生成器模式的实现
8.3.3 使用生成器模式构建复杂对象
8.3.4 生成器模式的优点
8.3.5 思考生成器模式
8.3.6 相关模式
第9章 原型模式（Prototype）
9.1 场景问题
9.1.1 订单处理系统
9.1.2 不用模式的解决方案
9.1.3 有何问题
9.2 解决方案
9.2.1 使用原型模式来解决问题
9.2.2 原形模式的结构和说明
9.2.3 原型模式示例代码
9.2.4 使用原型模式重写示例
9.3 模式讲解
9.3.1 认识原型模式
9.3.2 Java中的克隆方法
9.3.3 浅度克隆和深度克隆
9.3.4 原型管理器
9.3.5 原型模式的优缺点
9.3.6 思考原型模式
9.3.7 相关模式
第10章 中介者模式（Mediator）
10.1 场景问题
10.1.1 如果没有主板
10.1.2 有何问题
10.1.3 使用电脑来看电影
10.2 解决方案
10.2.1 使用中介者模式来解决问题
10.2.2 中介者模式的结构和说明
10.2.3 中介者模式示例代码
10.2.4 使用中介者模式来实现示例
10.3 模式讲解
10.3.1 认识中介者模式
10.3.2 广义中介者
10.3.3 中介者模式的优缺点
10.3.4 思考中介者模式
10.3.5 相关模式
第11章 代 理 模 式（Proxy）
11.1 场景问题
11.1.1 访问多条数据
11.1.2 不用模式的解决方案
11.1.3 有何问题
11.2 解决方案
11.2.1 使用代理模式来解决问题
11.2.2 代理模式的结构和说明
11.2.3 代理模式示例代码
11.2.4 使用代理模式重写示例
11.3 模式讲解
11.3.1 认识代理模式
11.3.2 保护代理
11.3.3 Java中的代理
11.3.4 代理模式的特点
11.3.5 思考代理模式
11.3.6 相关模式
第12章 观察者模式(Observer)
12.1 场景问题
12.1.1 订阅报纸的过程
12.1.2 订阅报纸的问题
12.2 解决方案
12.2.1 使用观察者模式来解决问题
12.2.2 观察者模式的结构和说明
12.2.3 观察者模式示例代码
12.2.4 使用观察者模式实现示例
12.3 模式讲解
12.3.1 认识观察者模式
12.3.2 推模型和拉模型
12.3.3 Java中的观察者模式
12.3.4　观察者模式的优缺点
12.3.5 思考观察者模式
12.3.6 Swing中的观察者模式
12.3.7 简单变形示例——区别对待观察者
12.3.8 相关模式
第13章 命令模式(Command)
13.1 场景问题
13.1.1 如何开机
13.1.2 与我何干
13.1.3 有何问题
13.2 解决方案
13.2.1 使用命令模式来解决问题
13.2.2 命令模式的结构和说明
13.2.3 命令模式示例代码
13.2.4 使用命令模式来实现示例
13.3 模式解
13.3.1 认识命令模式
13.3.2 参数化配置
13.3.3 可撤销的操作
13.3.4 宏命令
13.3.5 队列请求
13.3.6 日志请求
13.3.7 命令模式的优点
13.3.8 思考命令模式
13.3.9 退化的命令模式
13.3.10 相关模式
第14章 迭代器模式（Iterator）
14.1 场景问题
14.1.1 工资表数据的整合
14.1.2 有何问题
14.2 解决方案
14.2.1 使用迭代器模式来解决问题
14.2.2 选化器模式的结构和说明
14.2.3 迭代器模式示例代码
14.2.4 使用迭代器模式来实现示例
14.3 模式讲解
14.3.1 认识迭代器模式
14.3.2 使用Java的迭代器
14.3.3 带迭代策略的迭代器
14.3.4 双向迭代器
14.3.5 迭代器模式的优点
14.3.6 思考迭代器模式
14.3.7 翻页迭代
14.3.8 相关模式
第15章 组合模式(Composite)
15.1 场景问题
15.1.1 商品类别树
15.1.2 不用模式的解决方案
15.1.3 有何问题
15.2 解决方案
15.2.1 使用组合模式来解决问题
15.2.2 组合模式的结构和说明
15.2.3 组合模式示例代码
15.2.4 使用组合模式重写示例
15.3 模式讲解
15.3.1 认识组合模式
15.3.2 安全性和透明性
15.3.3 父组件引用
15.3.4 环状引用
15.3.5 组合模式的优缺点
15.3.6 思考组合模式
15.3.7 相关模式
第16章 模板方法模式(Template Method)
16.1 场景问题
16.1.1 登录控制
16.1.2 不用模式的解决方案
16.1.3 有何问题
16.2 解决方案
16.2.1 使用模板方法模式来解决问题
16.2.2 模板方法模式的结构和说明
16.2.3 模板方法模式示例代码
16.2.4 使用模板方法模式重写示例
16.3 模式讲解
16.3.1 认识模板方法模式
16.3.2 模板的写法
16.3.3 Java回调与模板方法模式
16.3.4 典型应用：排序
16.3.5 实现通用的增删改查
16.3.6 模板方法模式的优缺点
16.3.7 思考模板方法模式
16.3.8 相关模式
第17章 策略模式(Strategy)
17.1 场景问题
17.1.1 报价管理
17.1.2 不用模式的解决方案
17.1.3 有何问题
17.2 解 决 方 案
17.2.1 使用策略模式来解决问题
17.2.2 策略模式的结构和说明
17.2.3 策略模式示例代码
17.2.4 使用策略模式重写示例
17.3 模式讲解
17.3.1 认识策略模式
17.3.2 Context和Strategy的关系
17.3.3 容错恢复机制
17.3.4 策略模式结合模板方法模式
17.3.5 策略模式的优缺点
17.3.6 思考策略模式
17.3.7 相关模式
第18章 状态模式（State）
18.1 场景问题
18.1.1 实现在线投票
18.1.2 不用模式的解决方案
18.1.3 有何问题
18.2 解决方案
18.2.1 使用状态模式来解决问题
18.2.2 状态模式的结构和说明
18.2.3 状态模式示例代码
18.2.4 使用状态模式重写示例
18.3 模式讲解
18.3.1 认识状态模式
18.3.2 状态的维护和转换控制
18.3.3 使用数据库来维护状态
18.3.4 模拟工作流
18.3.5 状态模式的优缺点
18.3.6 思考状态模式
18.3.7 相关模式
第19章 备忘录模式（Memento）
19.1 场景问题
19.1.1 开发仿真系统
19.1.2 不用模式的解决方案
19.1.3 有何问题
19.2 解决方案
19.2.1 使用备忘录模式来解决问题
19.2.2 备忘录模式的结构和说明
19.2.3 备忘录模式示例代码
19.2.4 使用备忘录模式重写示例
19.3 模式讲解
19.3.1 认识备忘录模式
19.3.2 结合原型模式
19.3.3 离线存储
19.3.4 再次实现可撤销操作
19.3.5 备忘录模式的优缺点
19.3.6 思考备忘录模式
19.3.7 相关模式
第20章 享元模式（Flyweight）
20.1 场景问题
20.1.1 加入权限控制
20.1.2 不使用模式的解决方案
20.1.3 有何问题
20.2 解决方案
20.2.1 使用享元模式来解决问题
20.2.2 享元模式的结构和说明
20.2.3 享元模式示例代码
20.2.4 使用享元模式重写示例
20.3 模式讲解
20.3.1 认识享元模式
20.3.2 不需要共享的享元实现
20.3.3 对享元对象的管理
20.3.4 享元模式的优缺点
20.3.5 思考享元模式
20.3.6 相关模式
第21章 解释器模式（Interpreter）
21.1 场景问题
21.1.1 读取配置文件
21.1.2 不用模式的解决方案
21.1.3 有何问题
21.2 解决方案
21.2.1 使用解释器模式来解决问题
21.2.2 解释器模式的结构和说明
21.2.3 解释器模式示例代码
21.2.4 使用解释器模式重写示例
21.3 模式讲解
21.3.1 认识解释器模式
21.3.2 读取多个元素或属性的值
21.3.3 解析器
21.3.4 解释器模式的优缺点
21.3.5 思考解释器模式
21.3.6 相关模式
第22章 装饰模式（Decorator）
22.1 场景问题
22.1.1 复杂的奖金计算
22.1.2 简化后的奖金计算体系
22.1.3 不用模式的解决方案
22.1.4 有何问题
22.2 解决方案
22.2.1 使用装饰模式来解决问题
22.2.2 装饰模式的结构和说明
22.2.3 装饰模式示例代码
22.2.4 使用装饰模式重写示例
22.3 模式讲解
22.3.1 认识装饰模式
22.3.2 Java中的装饰模式应用
22.3.3 装饰模式和AOP
22.3.4 装饰模式的优缺点
22.3.5 思考装饰模式
22.3.6 相关模式
第23章 职责链模式（Chain of Responsibility）
23.1 场景问题
23.1.1 申请聚餐费用
23.1.2 不用模式的解决方案
23.1.3 有何问题
23.2 解决方案
23.2.1 使用职责链模式来解决问题
23.2.2 职责链模式的结构和说明
23.2.3 职责链模式示例代码
23.2.4 使用职责链模式重写示例
23.3 模式讲解
23.3.1 认识职责链模式
23.3.2 处理多种请求
23.3.3 功能链
23.3.4 职责链模式的优缺点
23.3.5 思考职责链模式
23.3.6 相关模式
第24章 桥接模式（Bridge）
24.1 场景问
24.1.1 发送提示消息
24.1.2 不用模式的解决方案
24.1.3 有何问题
24.2 解决方案
24.2.1 使用桥接模式来解决问题
24.2.2 桥接模式的结构和说明
24.2.3 桥接模式示例代码
24.2.4 使用桥接模式重写示例
24.3 模式讲解
24.3.1 认识桥接模式
24.3.2 谁来桥接
24.3.3 典型例子——JDBC
24.3.4 广义桥接——Java中无处不桥接
24.3.5 桥接模式的优缺点
24.3.6 思考桥接模式
24.3.7 相关模式
第25章 访问者模式（Visitor）
25.1 场景问题
25.1.1 扩展客户管理的功能
25.1.2 不用模式的解决方案
25.1.3 有何问题
25.2 解决方案
25.2.1 使用访问者模式来解决问题
25.2.2 访问者模式的结构和说明
25.2.3 访问者模式示例代码
25.2.4 使用访问者模式重写示例
25.3 模式讲解
25.3.1 认识访问者模式
25.3.2 操作组合对象结构
25.3.3 谁负责遍历所有元素对象
25.3.4 访问者模式的优缺点
25.3.5 思考访问者模式
25.3.6 相关模式
附录A 常见面向对象设计原则
A.1 设计模式和设计原则
A.1.1 设计模式和设计原则的关系
A.1.2 为何不重点讲解设计原则
A.2 常见的面向对象设计原则
A.2.1 单一职责原则SRP（Single Responsibility Principle）
A.2.2 开放-关闭原则OCP（Open-Closed Principle）
A.2.3 里氏替换原则LSP（Liskov Substitution Principle）
A.2.4 依赖倒置原则DIP（Dependence Inversion Principle）
A.2.5 接口隔离原则ISP（Interface Segregation Principle）
A.2.6 最少知识原则LKP（Least Knowledge Principle）
A.2.7 其他原则
附录B UML简介
B.1 UML基础
B.1.1 UML是什么
B.1.2 UML历史
B.1.3 UML能干什么
B.1.4 UML有什么
B.2 类图
B.2.1 类图的概念
B.2.2 类图的基本表达
B.2.3 抽象类和接口
B.2.4 关系
B.3 顺序图
B.3.1 顺序图的概念
B.3.2 顺序图的基本表达
临别赠言
不是结束而是新的开始
你该怎么做
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>研磨设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>看透Spring MVC
前言
第一篇　网站基础知识
第1章　网站架构及其演变过程2
1.1　软件的三大类型2
1.2　基础的结构并不简单3
1.3　架构演变的起点5
1.4　海量数据的解决方案5
1.4.1　缓存和页面静态化5
1.4.2　数据库优化6
1.4.3　分离活跃数据8
1.4.4　批量读取和延迟修改8
1.4.5　读写分离9
1.4.6　分布式数据库10
1.4.7　NoSQL和Hadoop10
1.5　高并发的解决方案11
1.5.1　应用和静态资源分离11
1.5.2　页面缓存12
1.5.3　集群与分布式12
1.5.4　反向代理13
1.5.5　CDN14
1.6　底层的优化15
1.7　小结15
第2章　常见协议和标准17
2.1　DNS协议17
2.2　TCP/IP协议与Socket18
2.3　HTTP协议20
2.4　Servlet与Java Web开发22
第3章　DNS的设置23
3.1　DNS解析23
3.2　Windows 7设置DNS服务器24
3.3　Windows设置本机域名和IP的对应关系25
第4章　Java中Socket的用法26
4.1　普通Socket的用法26
4.2　NioSocket的用法28
第5章　自己动手实现HTTP协议33
第6章　详解Servlet37
6.1　Servlet接口37
6.2　GenericServlet40
6.3　HttpServlet41
第7章　Tomcat分析44
7.1　Tomcat的顶层结构及启动过程44
7.1.1　Tomcat的顶层结构44
7.1.2　Bootstrap的启动过程45
7.1.3　Catalina的启动过程47
7.1.4　Server的启动过程48
7.1.5　Service的启动过程50
7.2　Tomcat的生命周期管理52
7.2.1　Lifecycle接口52
7.2.2　LifecycleBase53
7.3　Container分析59
7.3.1　ContainerBase的结构59
7.3.2　Container的4个子容器60
7.3.3　4种容器的配置方法60
7.3.4　Container的启动62
7.4　Pipeline-Value管道69
7.4.1　Pipeline-Value处理模式69
7.4.2　Pipeline-Value的实现方法70
7.5　Connector分析73
7.5.1　Connector的结构73
7.5.2　Connector自身类74
7.5.3　ProtocolHandler77
7.5.4　处理TCP/IP协议的Endpoint77
7.5.5　处理HTTP协议的Processor80
7.5.6　适配器Adapter81
第二篇　俯视Spring MVC
第8章　Spring MVC之初体验84
8.1　环境搭建84
8.2　Spring MVC最简单的配置84
8.2.1　在web.xml中配置Servlet85
8.2.2　创建Spring MVC的xml配置文件85
8.2.3　 创建Controller和view86
8.3　关联spring源代码87
8.4　小结89
第9章　创建Spring MVC之器90
9.1　整体结构介绍90
9.2　HttpServletBean93
9.3　FrameworkServlet95
9.4　DispatcherServlet100
9.5　小结107
第10章　Spring MVC之用108
10.1　HttpServletBean108
10.2　FrameworkServlet108
10.3　DispatcherServlet114
10.4　doDispatch结构118
10.5　小结123
第三篇　Spring MVC组件分析
第11章　组件概览126
11.1　HandlerMapping126
11.2　HandlerAdapter128
11.3　HandlerExceptionResolver130
11.4　ViewResolver131
11.5　RequestToViewNameTranslator133
11.6　LocaleResolver133
11.7　ThemeResolver135
11.8　MultipartResolver137
11.9　FlashMapManager138
11.10　小结139
第12章　HandlerMapping140
12.1　AbstractHandlerMapping140
12.1.1　创建AbstractHandlerMapping之器141
12.1.2　AbstractHandlerMapping之用142
12.2　AbstractUrlHandlerMapping系列143
12.2.1　AbstractUrlHandlerMapping143
12.2.2　SimpleUrlHandlerMapping149
12.2.3　AbstractDetectingUrlHandler-Mapping150
12.3　AbstractHandlerMethodMapping系列152
12.3.1　创建AbstractHandlerMethod-Mapping系列之器153
12.3.2　AbstractHandlerMethodMapping系列之用158
12.4　小结159
第13章　HandlerAdapter161
13.1　RequestMappingHandlerAdapter概述162
13.2　RequestMappingHandlerAdapter自身结构169
13.2.1　创建RequestMappingHandler-Adapter之器169
13.2.2　RequestMappingHandlerAdapter之用173
13.2.3　小结185
13.3　ModelAndViewContainer185
13.4　SessionAttributesHandler和SessionAttributeStore188
13.5　ModelFactory192
13.5.1　初始化Model192
13.5.2　更新Model197
13.6　ServletInvocableHandlerMethod199
13.6.1　HandlerMethod199
13.6.2　InvocableHandlerMethod203
13.6.3　ServletInvocableHandler-Method205
13.7　HandlerMethodArgumentResolver207
13.8　HandlerMethodReturnValue-Handler218
13.9　小结221
第14章　ViewResolver223
14.1　ContentNegotiatingViewResolver225
14.2　AbstractCachingViewResolver系列228
UrlBasedViewResolver231
14.3　小结235
第15章　RequestToViewName-Translator237
第16章　HandlerExceptionResolver239
16.1　AbstractHandlerException-Resolver239
16.2　ExceptionHandlerException-Resolver241
16.3　DefaultHandlerExceptionResolver243
16.4　ResponseStatusExceptionResolver245
16.5　SimpleMappingExceptionResolver246
16.6　小结250
第17章　MultipartResolver251
17.1　StandardServletMultipart-Resolver251
17.2　CommonsMultipartResolver253
17.3　小结256
第18章　LocaleResolver257
第19章　ThemeResolver263
第20章　FlashMapManager266
第四篇　总结与补充
第21章　总结272
21.1　Spring MVC原理总结272
21.2　实际跟踪一个请求275
第22章　异步请求281
22.1　Servlet 3.0对异步请求的支持281
22.1.1　Servlet 3.0处理异步请求实例282
22.1.2　异步请求监听器Async-Listener284
22.2　Spring MVC中的异步请求286
22.2.1　Spring MVC中异步请求相关组件286
22.2.2　Spring MVC对异步请求的支持297
22.2.3　WebAsyncTask和Callable类型异步请求的处理过程及用法301
22.2.4　DeferredResult类型异步请求的处理过程及用法303
22.2.5　ListenableFuture类型异步请求的处理过程及用法305
22.3　小结309
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>看透Spring MVC
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入浅出面向对象分析与设计（中文版）
介绍1  伟大软件由此开始：良好应用程序的基石2  给客户所需之物：收集需求3  山可移，此情永不渝……现在，情况有变：需求变更4  将你的软件带进现实世界：分析5  第一部分：诸行无常——良好的设计  插曲：OO大灾难  第二部分：给你的软件30分钟的伸展操——灵活的软件6  “我的名字是Art Vandelay”：解决真正的大问题7  为混乱带来次序：架构8  原创性被高估：设计原则9  软件终究为客户服务：重复与测试10  组合在一起：OOA&D生命周期  附录1：本书遗珠  附录2：欢迎光临对象村
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入浅出面向对象分析与设计（中文版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>RabbitMQ实战
第1章 天降奇兵 1
1.1 住在别人的地下城堡 3
1.2 救世主AMQP 5
1.3 RabbitMQ简史 5
1.4 百里挑一 8
1.5 在UNIX系统上安装RabbitMQ 8
1.5.1 为什么环境很重要--生活在Erlang 的世界里 9
1.5.2 获取安装包 9
1.5.3 设置文件夹结构 9
1.5.4 首次运行Rabbit 10
1.6 总结 12
第2章 理解消息通信13
2.1 消费者和生产者（这可不是经济学课程哦） 14
2.2 从底部开始构造：队列 17
2.3 联合起来：交换器和绑定 22
2.4 多租户模式：虚拟主机和隔离 27
2.5 我的消息去哪儿了呢？持久化和你的策略 28
2.6 把所有内容结合起来：一条消息的一生 32
2.7 使用发送方确认模式来确认投递 37
2.8 总结 40
第3章 运行和管理Rabbit 42
3.1 服务器管理 43
3.1.1 启动节点 43
3.1.2 停止节点 45
3.1.3 关闭和重启应用程序：有何差别 46
3.1.4 Rabbit 配置文件 46
3.2 请求许可 48
3.2.1 管理用户 49
3.2.2 Rabbit 的权限系统 50
3.3 检查 54
3.3.1 查看数据统计 54
3.3.2 理解RabbitMQ 日志 59
3.4 修复Rabbit：疑难解答 63
由badrpc、nodedown 和其他Erlang 引起的问题 63
3.5 总结 68
第4章 解决Rabbit相关问题：编码与模式69
4.1 解耦风雨路：谁将我们推向消息通信 70
4.1.1 异步状态思维（分离请求和动作） 70
4.1.2 提供扩展性：没有负载均衡器的世界 73
4.1.3 零成本API ：语言不应成为枷锁 73
4.2 发后即忘模型 74
4.2.1 发送告警 75
4.2.2 并行处理 84
4.3 别忘了：用RabbitMQ实现RPC并等待响应 92
4.3.1 私有队列和发送确认 93
4.3.2 使用reply_to 来实现简单的JSON RPC 93
4.4 总结 98
第5章 集群并处理失败99
5.1 开足马力：RabbitMQ集群 100
5.2 集群架构 101
5.2.1 集群中的队列 101
5.2.2 分布交换器 103
5.2.3 是内存节点还是磁盘节点 104
5.3 在你的笔记本电脑上设置集群 106
5.4 将节点分布到更多的机器上 110
5.5 升级集群节点 114
5.6 镜像队列和保留消息 115
5.6.1 声明并使用镜像队列 115
5.6.2 镜像队列工作原理 118
5.7 总结 120
第6章 从故障中恢复121
6.1 为Rabbit做负载均衡 122
6.1.1 安装HAProxy 124
6.1.2 配置HAProxy 125
6.2 连接丢失和故障转移 127
6.3 总结 134
第7章 warren和Shovel：故障转移和复制 135
7.1 warren：另一种集群方式 136
7.2 设定负载均衡器--基于主/从的集群 138
7.3 远距离通信和复制 142
7.3.1 给Rabbit 装备Shovel ：Shovel 插件介绍 142
7.3.2 安装Shovel 145
7.3.3 配置并运行Shovel 146
7.4 总结 152
第8章 从Web端管理RabbitMQ 154
8.1 超越rabbitmqctl：RabbitMQ Management插件 155
8.1.1 为何需要Management 插件 155
8.1.2 Management 插件功能 155
8.1.3 启用Management 插件 156
8.2 从Web控制台来管理RabbitMQ 158
8.2.1 监控Erlang VM 158
8.2.2 从JSON 文件导入配置 159
8.3 从Web控制台管理用户 160
8.3.1 创建用户 161
8.3.2 管理用户的权限 162
8.4 从Web控制台管理交换器和队列 163
8.4.1 列出队列信息 165
8.4.2 创建队列 166
8.5 回到命令行 168
8.5.1 为什么需要另一个CLI 168
8.5.2 CLI 管理：一种更简单的方式 170
8.5.3 安装rabbitmqadmin 脚本 170
8.5.4 清空队列、创建交换器等 171
8.6 总结 172
第9章 使用REST API控制Rabbit 173
9.1 能用RabbitMQ REST API做什么 175
9.2 对客户端授权访问 177
9.3 访问数据统计 178
9.4 自动化vhost和用户配置 181
9.5 总结 .186
第10章 监控187
10.1 监控RabbitMQ：密切关注你的warren 188
10.1.1 为Nagios 编写健康检测 188
10.1.2 使用AMQP 模拟检测来确认RabbitMQ 是否运行 190
10.1.3 使用REST API 来检测 193
10.1.4 监控配置文件修改 196
10.1.5 监控集群状态 201
10.2 确保消费者正常工作 206
10.2.1 通过AMQP 监控队列等级 208
10.2.2 使用REST API 来监控队列级别 212
10.2.3 建立队列的消息计数基准经验法则 215
10.3 总结216
第11章 提升性能，保障安全217
11.1 对速度的需求 218
11.1.1 消息持久化 218
11.1.2 消息确认 219
11.1.3 路由算法和绑定规则 219
11.1.4 投递消息 221
11.2 内存使用率和进程限制 223
11.2.1 内存使用率 223
11.2.2 Erlang 进程计数 226
11.3 SSL连接 ..227
11.3.1 SSL 证书.228
11.3.2 设置证书颁发机构 ..229
11.3.3 生成根证书 233
11.3.4 生成服务器端证书 234
11.3.5 生成客户端证书 235
11.3.6 启用RabbitMQ 的SSL 监听器 236
11.3.7 测试你的RabbitMQ SSL 设置 237
11.4 总结 239
第12章 聪明的Rabbit：扩展RabbitMQ241
12.1 RabbitMQ插件 242
12.1.1 你可以用插件做什么 242
12.1.2 在哪里可以找到插件 244
12.1.3 安装插件 244
12.1.4 移除插件 245
12.2 制作你自己的插件 247
12.2.1 获取RabbitMQ Public Umbrella 248
12.2.2 设置文件夹结构 249
12.2.3 包含插件构建系统 250
12.2.4 创建Erlang 应用文件 250
12.3 创建自定义交换器模块 252
12.3.1 将交换器注册到RabbitMQ 254
12.3.2 实现交换器behaviour 257
12.3.3 编译自定义交换器 264
12.3.4 测试你的插件 267
12.4 总结 271
附录A 在Java和.NET上使用Rabbit 273
附录B 在线资源302
附录C 在Windows上安装RabbitMQ 307
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>RabbitMQ实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala编程
目录	ix
图示清单	xvii
表格清单	xix
代码清单	xxi
序	I
致谢	III
简介	V
第1章  可伸展的语言	3
1.1	与你一同成长的语言	3
1.2	是什么让Scala具有可扩展性？	6
1.3	为什么选择Scala？	8
1.4	Scala的根源	13
1.5	小结	14
第2章  Scala入门初探	15
2.1	第一步  学习使用Scala解释器	15
2.2	第二步  变量定义	16
2.3	第三步  函数定义	18
2.4	第四步  编写Scala脚本	19
2.5	第五步  用while做循环；用if做判断	20
2.6	第六步  用foreach和for做枚举	21
2.7	小结	22
第3章  Scala入门再探	23
3.1	第七步  使用类型参数化数组（Array）	23
3.2	第八步  使用列表（List）	25
3.3	第九步  使用元组（Tuple）	28
3.4	第十步  使用集（set）和映射（map）	29
3.5	第十一步  学习识别函数式风格	32
3.6	第十二步  从文件里读取文本行	34
3.7	小结	36
第4章  类和对象	37
4.1	类、字段和方法	37
4.2	分号推断	40
4.3	Singleton对象	41
4.4	Scala程序	43
4.5	Application特质	45
4.6	小结	45
第5章  基本类型和操作	47
5.1	基本类型	47
5.2	字面量	48
5.3	操作符和方法	52
5.4	数学运算	54
5.5	关系和逻辑操作	55
5.6	位操作符	56
5.7	对象相等性	57
5.8	操作符的优先级和关联性	58
5.9	富包装器	60
5.10	小结	60
第6章  函数式对象	61
6.1	类Rational的规格说明书	61
6.2	创建Rational	62
6.3	重新实现toString方法	63
6.4	检查先决条件	63
6.5	添加字段	64
6.6	自指向	65
6.7	辅助构造器	65
6.8	私有字段和方法	66
6.9	定义操作符	67
6.10	Scala的标识符	68
6.11	方法重载	70
6.12	隐式转换	71
6.13	一番告诫	72
6.14	小结	72
第7章  内建控制结构	73
7.1	If表达式	73
7.2	While循环	74
7.3	for表达式	76
7.4	使用try表达式处理异常	80
7.5	匹配（match）表达式	82
7.6	不再使用break和continue	83
7.7	变量范围	84
7.8	重构指令式风格的代码	87
7.9	小结	88
第8章  函数和闭包	89
8.1	方法	89
8.2	本地函数	90
8.3	头等函数	91
8.4	函数字面量的短格式	93
8.5	占位符语法	93
8.6	部分应用函数	94
8.7	闭包	96
8.8	重复参数	98
8.9	尾递归	99
8.10	小结	102
第9章  控制抽象	103
9.1	减少代码重复	103
9.2	简化客户代码	106
9.3	柯里化（currying）	107
9.4	编写新的控制结构	108
9.5	传名参数（by-name parameter）	110
9.6	小结	112
第10章  组合与继承	113
10.1	二维布局库	113
10.2	抽象类	114
10.3	定义无参数方法	114
10.4	扩展类	116
10.5	重写方法和字段	117
10.6	定义参数化字段	118
10.7	调用超类构造器	119
10.8	使用override修饰符	120
10.9	多态和动态绑定	121
10.10	定义final成员	123
10.11	使用组合与继承	124
10.12	实现above、beside和toString	124
10.13	定义工厂对象	126
10.14	变高变宽	128
10.15	把代码都放在一起	129
10.16	小结	130
第11章  Scala的层级	131
11.1	Scala的类层级	131
11.2	原始类型是如何实现的	134
11.3	底层类型	135
11.4	小结	136
第12章  特质	137
12.1	特质是如何工作的	137
12.2	瘦接口对阵胖接口	139
12.3	样例：长方形对象	140
12.4	Ordered特质	141
12.5	特质用来做可堆叠的改变	143
12.6	为什么不是多重继承？	146
12.7	特质，用还是不用？	148
12.8	小结	149
第13章  包和引用	151
13.1	包	151
13.2	引用	153
13.3	隐式引用	156
13.4	访问修饰符	156
13.5	小结	160
第14章  断言和单元测试	161
14.1	断言	161
14.2	Scala里的单元测试	162
14.3	翔实的失败报告	163
14.4	使用JUnit和TestNG	164
14.5	规格测试	166
14.6	基于属性的测试	167
14.7	组织和运行测试	168
14.8	小结	170
第15章  样本类和模式匹配	171
15.1  简单例子	171
15.2  模式的种类	174
15.3  模式守卫	180
15.4  模式重叠	181
15.5  封闭类	182
15.6  Option类型	183
15.7  模式无处不在	184
15.8  一个更大的例子	187
15.9  小结	192
第16章  使用列表	193
16.1  列表字面量	193
16.2  List类型	193
16.3  构造列表	194
16.4  列表的基本操作	194
16.5  列表模式	195
16.6  List类的一阶方法	196
16.7  List类的高阶方法	204
16.8  List对象的方法	210
16.9  了解Scala的类型推断算法	212
16.10  小结	214
第17章  集合类型	215
17.1  集合库概览	215
17.2  序列	216
17.3  集（Set）和映射（Map）	220
17.4  可变（mutable）集合vs.不可变（immutable）集合	227
17.5  初始化集合	229
17.6  元组	231
17.7  小结	232
第18章  有状态的对象	233
18.1  什么让对象具有状态？	233
18.2  可重新赋值的变量和属性	234
18.3  案例研究：离散事件模拟	237
18.4  为数字电路定制的语言	237
18.5  Simulation API	239
18.6  电路模拟	242
18.7  小结	247
第19章  类型参数化	249
19.1  queues函数式队列	249
19.2  信息隐藏	251
19.3  变化型注解	253
19.4  检查变化型注解	256
19.5  下界	258
19.6  逆变	259
19.7  对象私有数据	261
19.8  上界	263
19.9  小结	264
第20章  抽象成员	265
20.1  抽象成员的快速浏览	265
20.2  类型成员	266
20.3  抽象val	266
20.4  抽象var	267
20.5  初始化抽象val	267
20.6  抽象类型	273
20.7  路径依赖类型	274
20.8  枚举	276
20.9  案例研究：货币	277
20.10  小结	284
第21章  隐式转换和参数	285
21.1  隐式转换	285
21.2  隐式操作规则	287
21.3  隐式转换为期望类型	289
21.4  转换（方法调用的）接收者	290
21.5  隐式参数	292
21.6  视界	296
21.7  隐式操作调试	297
21.8  小结	299
第22章  实现列表	301
22.1  List类原理	301
22.2  ListBuffer类	305
22.3  实际的List类	306
22.4  外在的函数式（风格）	308
22.5  小结	308
第23章  重访For表达式	309
23.1  For表达式	310
23.2  皇后问题	311
23.3  使用for表达式做查询	313
23.4  for表达式的转译	314
23.5  反其道而行之	317
23.6  泛化的for	318
23.7  小结	319
第24章  抽取器（Extractors）	321
24.1  例子：抽取email地址	321
24.2  抽取器	322
24.3  0或1个变量的模式	324
24.4  变参抽取器	325
24.5  抽取器和序列模式	327
24.6  抽取器VS.样本类	327
24.7  正则表达式	328
24.8  小结	330
第25章  注解	331
25.1  为什么要有注解？	331
25.2  注解语法	332
25.3  标准注解	333
25.4  小结	334
第26章  使用XML	335
26.1  半结构化数据	335
26.2  XML概览	335
26.3  XML字面量	336
26.4  序列化	338
26.5  拆解XML	339
26.6  反序列化	340
26.7  加载和保存	341
26.8  XML的模式匹配	342
26.9  小结	344
第27章  使用对象的模块化编程	345
27.1  问题	345
27.2  食谱应用	346
27.3  抽象概念	348
27.4  把模块拆分为特质	350
27.5  运行期链接	352
27.6  跟踪模块实例	353
27.7  小结	354
第28章  对象相等性	355
28.1  Scala中的相等性	355
28.2  编写相等性方法	355
28.3  定义带参数类型的相等性	365
28.4  equals和hashCode的制作方法	368
28.5  小结	371
第29章  结合Scala和Java	373
29.1  在Java中使用Scala	373
29.2  注解	375
29.3  存在类型	379
29.4  小结	381
第30章  Actor和并发	383
30.1  天堂中的烦恼	383
30.2  actor和消息传递	384
30.3  将原生线程当作actor	387
30.4  通过重用线程获得更好的性能	387
30.5  良好的actor风格	389
30.6  更长一些的示例：并行离散事件模拟	394
30.7  小结	406
第31章  连结符解析	407
31.1  示例：算术表达式	408
31.2  运行你的解析器	409
31.3  基本的正则表达式解析器	410
31.4  另一个示例：JSON	410
31.5  解析器输出	412
31.6  实现连结符解析器	416
31.7  字符串字面量和正则表达式	421
31.8  词法分析和解析	422
31.9  错误报告	423
31.10  回溯vs. LL(1)	424
31.11  小结	425
第32章  GUI编程	427
32.1  第一个Swing应用	427
32.2  面板和布局	429
32.3  处理事件	430
32.4  示例：摄氏/华氏温度转换器	432
32.5  小结	434
第33章  Scell试算表	435
33.1  可视化框架	435
33.2  将数据录入和显示分开	437
33.3  公式	439
33.4  解析公式	440
33.5  求值	444
33.6  操作库	446
33.7  修改传达	448
33.8  小结	451
附录A  Unix和Windows的Scala脚本	453
术语表	455
参考文献	465
关于作者	467
索引	469
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Scala编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式服务框架：原理与实践
第1章　应用架构演进 1
1.1 传统垂直应用架构 2
1.1.1 垂直应用架构介绍 2
1.1.2 垂直应用架构面临的挑战 4
1.2 RPC架构 6
1.2.1　RPC框架原理 6
1.2.2　最简单的RPC框架实现 8
1.2.3　业界主流RPC框架 14
1.2.4　RPC框架面临的挑战 17
1.3 SOA服务化架构 18
1.3.1　面向服务设计的原则 18
1.3.2　服务治理 19
1.4 微服务架构 21
1.4.1　什么是微服务 21
1.4.2　微服务架构对比SOA 22
1.5　总结 23
第2章　分布式服务框架入门 25
2.1　分布式服务框架诞生背景 26
2.1.1 应用从集中式走向分布式 26
2.1.2 亟需服务治理 28
2.2 业界分布式服务框架介绍 29
2.2.1　阿里Dubbo 30
2.2.2　淘宝HSF 33
2.2.3　亚马逊Coral Service 35
2.3 分布式服务框架设计 36
2.3.1　架构原理 36
2.3.2　功能特性 37
2.3.3　性能特性 39
2.3.4　可靠性 39
2.3.5　服务治理 40
2.4 总结 41
第3章　通信框架 42
3.1　关键技术点分析 43
3.1.1 长连接还是短连接 43
3.1.2 BIO还是NIO 43
3.1.3 自研还是选择开源NIO框架 46
3.2 功能设计 47
3.2.1　服务端设计 48
3.2.2　客户端设计 50
3.3 可靠性设计 53
3.3.1　链路有效性检测 54
3.3.2　断连重连机制 56
3.3.3　消息缓存重发 57
3.3.4　资源优雅释放 58
3.4 性能设计 59
3.4.1　性能差的三宗罪 59
3.4.2　通信性能三原则 60
3.4.3　高性能之道 61
3.5 最佳实践 61
3.6 总结 64
第4章　序列化与反序列化 65
4.1　几个关键概念澄清 66
4.1.1 序列化与通信框架的关系 66
4.1.2 序列化与通信协议的关系 66
4.1.3 是否需要支持多种序列化方式 67
4.2 功能设计 67
4.2.1　功能丰富度 67
4.2.2　跨语言支持 68
4.2.3　兼容性 69
4.2.4　性能 70
4.3 扩展性设计 71
4.3.1　内置的序列化/反序列化功能类 71
4.3.2　反序列化扩展 72
4.3.3　序列化扩展 75
4.4 最佳实践 77
4.4.1　接口的前向兼容性规范 77
4.4.2　高并发下的稳定性 78
4.5 总结 78
第5章　协议栈 79
5.1　关键技术点分析 80
5.1.1 是否必须支持多协议 80
5.1.2 公有协议还是私有协议 80
5.1.3 集成开源还是自研 81
5.2 功能设计 82
5.2.1　功能描述 82
5.2.2　通信模型 82
5.2.3　协议消息定义 84
5.2.4　协议栈消息序列化支持的字段类型 85
5.2.5　协议消息的序列化和反序列化 86
5.2.6　链路创建 89
5.2.7　链路关闭 90
5.3 可靠性设计 90
5.3.1　客户端连接超时 90
5.3.2　客户端重连机制 91
5.3.3　客户端重复握手保护 91
5.3.4　消息缓存重发 92
5.3.5　心跳机制 92
5.4 安全性设计 92
5.5 最佳实践—协议的前向兼容性 94
5.6 总结 95
第6章　服务路由 96
6.1　透明化路由 97
6.1.1 基于服务注册中心的订阅发布 97
6.1.2 消费者缓存服务提供者地址 98
6.2 负载均衡 98
6.2.1　随机 98
6.2.2　轮循 99
6.2.3　服务调用时延 99
6.2.4　一致性哈希 100
6.2.5　粘滞连接 101
6.3 本地路由优先策略 102
6.3.1　injvm模式 102
6.3.2　innative模式 102
6.4 路由规则 103
6.4.1　条件路由规则 103
6.4.2　脚本路由规则 104
6.5　路由策略定制 105
6.6　配置化路由 106
6.7　最佳实践—多机房路由 107
6.8 总结 108
第７章　集群容错 109
7.1　集群容错场景 110
7.1.1 通信链路故障 110
7.1.2 服务端超时 111
7.1.3 服务端调用失败 111
7.2 容错策略 112
7.2.1　失败自动切换（Failover） 112
7.2.2　失败通知（Failback） 113
7.2.3　失败缓存（Failcache） 113
7.2.4　快速失败（Failfast） 114
7.2.5　容错策略扩展 114
7.3 总结 115
第8章　服务调用 116
8.1　几个误区 117
8.1.1 NIO就是异步服务 117
8.1.2 服务调用天生就是同步的 118
8.1.3 异步服务调用性能更高 120
8.2 服务调用方式 120
8.2.1　同步服务调用 120
8.2.2　异步服务调用 121
8.2.3　并行服务调用 125
8.2.4　泛化调用 129
8.3 最佳实践 130
8.4 总结 131
第９章　服务注册中心 132
9.1　几个概念 133
9.1.1 服务提供者 133
9.1.2 服务消费者 133
9.1.3 服务注册中心 133
9.2 关键功能特性设计 134
9.2.1　支持对等集群 135
9.2.2　提供CRUD接口 136
9.2.3　安全加固 136
9.2.4　订阅发布机制 137
9.2.5　可靠性 138
9.3　基于ZooKeeper的服务注册中心设计 139
9.3.1　服务订阅发布流程设计 139
9.3.2　服务健康状态检测 141
9.3.3　对等集群防止单点故障 142
9.3.4　变更通知机制 144
9.4 总结 144
第10章　服务发布和引用 145
10.1　服务发布设计 146
10.1.1　服务发布的几种方式 146
10.1.2　本地实现类封装成代理 148
10.1.3　服务发布成指定协议 148
10.1.4　服务提供者信息注册 149
10.2 服务引用设计 150
10.2.1　本地接口调用转换成远程服务调用 150
10.2.2　服务地址本地缓存 151
10.2.3　远程服务调用 151
10.3　最佳实践 152
10.3.1　对等设计原则 152
10.3.2　启动顺序问题 153
10.3.3　同步还是异步发布服务 153
10.3.4　警惕网络风暴 154
10.3.5　配置扩展 154
10.4 总结 156
第11章　服务灰度发布 157
11.1　服务灰度发布流程设计 158
11.1.1　灰度环境准备 158
11.1.2　灰度规则设置 159
11.1.3　灰度规则下发 160
11.1.4　灰度路由 161
11.1.5　失败回滚 162
11.1.6　灰度发布总结 163
11.2　总结 163
第12章　参数传递 164
12.1　内部传参 165
12.1.1　业务内部参数传递 165
12.1.2　服务框架内部参数传递 168
12.2　外部传参 169
12.2.1　通信协议支持 169
12.2.2　传参接口定义 170
12.3　最佳实践 171
12.3.1　防止参数互相覆盖 171
12.3.2　参数生命周期管理 171
12.4　总结 172
第13章　服务多版本 173
13.1　服务多版本管理设计 174
13.1.1　服务版本号管理 174
13.1.2　服务提供者 175
13.1.3　服务消费者 175
13.1.4　基于版本号的服务路由 176
13.1.5　服务热升级 177
13.2　与OSGi的对比 178
13.2.1　模块化开发 179
13.2.2　插件热部署和热升级 184
13.2.3　不使用OSGi的其他理由 185
13.3　总结 185
第14章　流量控制 186
14.1　静态流控 187
14.1.1　传统静态流控设计方案 187
14.1.2　传统方案的缺点 188
14.1.3　动态配额分配制 188
14.1.4　动态配额申请制 190
14.2　动态流控 191
14.2.1　动态流控因子 192
14.2.2　分级流控 192
14.3　并发控制 193
14.3.1　服务端全局控制 193
14.3.2　服务消费者流控 194
14.4　连接控制 195
14.4.1　服务端连接数流控 195
14.4.2　服务消费者连接数流控 195
14.5　并发和连接控制算法 195
14.6　总结 197
第15章　服务降级 198
15.1　屏蔽降级 199
15.1.1　屏蔽降级的流程 199
15.1.2　屏蔽降级的设计实现 200
15.2　容错降级 202
15.2.1　容错降级的工作原理 202
15.2.2　运行时容错降级 204
15.3　业务层降级 205
15.4　总结 205
第16章　服务优先级调度 207
16.1　设置服务优先级 208
16.2　线程调度器方案 209
16.3　Java优先级队列 210
16.4　加权优先级队列 211
16.5　服务迁入迁出 212
16.6　总结 213
第17章　服务治理 214
17.1　服务治理技术的历史变迁 215
17.1.1　SOA Governance 215
17.1.2　分布式服务框架服务治理 217
17.1.3　AWS云端微服务治理 217
17.2　应用服务化后面临的挑战 218
17.2.1　跨团队协作问题 219
17.2.2　服务的上下线管控 220
17.2.3　服务安全 220
17.2.4　服务SLA保障 221
17.2.5　故障快速定界定位 221
17.3　服务治理 222
17.3.1　服务治理架构设计 223
17.3.2　运行态服务治理功能设计 225
17.3.3　线下服务治理 232
17.3.4　安全和权限管理 234
17.4　总结 237
第18章　分布式消息跟踪 239
18.1　业务场景分析 240
18.1.1　故障的快速定界定位 240
18.1.2　调用路径分析 241
18.1.3　调用来源和去向分析 242
18.2　分布式消息跟踪系统设计 242
18.2.1　系统架构 243
18.2.2　埋点日志 244
18.2.3　采样率 247
18.2.4　采集和存储埋点日志 248
18.2.5　计算和展示 249
18.2.6　调用链扩展 251
18.3　总结 251
第19章　可靠性设计 253
19.1　服务状态检测 254
19.1.1　基于服务注册中心状态检测 254
19.1.2　链路有效性状态检测机制 255
19.2　服务健康度检测 256
19.3　服务故障隔离 257
19.3.1　进程级故障隔离 257
19.3.2　VM级故障隔离 259
19.3.3　物理机故障隔离 260
19.3.4　机房故障隔离 261
19.4　其他可靠性特性 262
19.4.1　服务注册中心 262
19.4.2　监控中心 262
19.4.3　服务提供者 262
19.5　总结 263
第20章　微服务架构 264
20.1　微服务架构产生的历史背景 265
20.1.1　研发成本挑战 265
20.1.2　运维成本高 267
20.1.3　新需求上线周期长 268
20.2　微服务架构带来的改变 268
20.2.1　应用解耦 268
20.2.2　分而治之 270
20.2.3　敏捷交付 271
20.3　微服务架构解析 271
20.3.1　微服务划分原则 272
20.3.2　开发微服务 272
20.3.3　基于Docker容器部署微服务 274
20.3.4　治理和运维微服务 277
20.3.5　特点总结 278
20.4　总结 279
第21章　服务化最佳实践 280
21.1　性能和时延问题 281
21.1.1　RPC框架高性能设计 281
21.1.2　业务最佳实践 285
21.2　事务一致性问题 286
21.2.1　分布式事务设计方案 287
21.2.2　分布式事务优化 288
21.3　研发团队协作问题 289
21.3.1　共用服务注册中心 290
21.3.2　直连提供者 290
21.3.3　多团队进度协同 291
21.3.4　服务降级和Mock测试 291
21.3.5　协同调试问题 292
21.3.6　接口前向兼容性 292
21.4　总结 292
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式服务框架：原理与实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构真经
目录
本书赞誉
中文版序一
中文版序二
译者序
前言
致谢
作者简介
第1章　大道至简 …… 1
规则1——避免过度设计 …… 4
规则2——方案中包括扩展 …… 9
规则3——三次简化方案 …… 13
规则4——减少域名解析 …… 16
规则5——减少页面目标 …… 19
规则6——采用同构网络 …… 23
总结 …… 24
注释 …… 25
第2章　分而治之 …… 27
规则7——X轴扩展 …… 31
规则8——Y轴拆分 …… 35
规则9——Z轴拆分 …… 39
总结 …… 41
注释 …… 42
第3章　水平扩展 …… 43
规则10——向外扩展 …… 46
规则11——用商品化系统（金鱼而非汗血宝马） …… 50
规则12——托管方案扩展 …… 53
规则13——利用云 …… 61
总结 …… 64
注释 …… 64
第4章　先利其器 …… 65
规则14——适当使用数据库 …… 71
规则15——慎重使用防火墙 …… 80
规则16——积极使用日志文件 …… 85
总结 …… 88
注释 …… 89
第5章　画龙点睛 …… 90
规则17——避免画蛇添足 …… 93
规则18——停止重定向 …… 98
规则19——放宽时间约束 …… 104
总结 …… 107
注释 …… 107
第6章　缓存为王 …… 109
规则20——利用CDN缓存 …… 113
规则21——灵活管理缓存 …… 117
规则22——利用Ajax缓存 …… 120
规则23——利用页面缓存 …… 128
规则24——利用应用缓存 …… 130
规则25——利用对象缓存 …… 134
规则26——独立对象缓存 …… 137
总结 …… 139
注释 …… 139
第7章　前车之鉴 …… 141
规则27——失败乃成功之母 …… 144
规则28——不靠QA发现错误 …… 151
规则29——不能回滚注定失败 …… 155
总结 …… 160
注释 …… 160
第8章　重中之重 …… 162
规则30——从事务处理中清除商务智能 …… 164
规则31——注意昂贵的关系 …… 168
规则32——正确使用数据库锁 …… 172
规则33——禁用分阶段提交 …… 176
规则34——慎用Select for Update …… 178
规则35——避免选择所有列 …… 181
总结 …… 183
注释 …… 184
第9章　有备无患 …… 185
规则36——用“泳道”隔离故障 …… 188
规则37——拒绝单点故障 …… 194
规则38——避免系统串联 …… 198
规则39——启用与禁用功能 …… 201
总结 …… 205
第10章　超然物外 …… 206
规则40——力求无状态 …… 208
规则41——在浏览器中保存会话数据 …… 211
规则42——用分布式缓存处理状态 …… 213
总结 …… 216
注释 …… 217
第11章　异步通信 …… 218
规则43——尽可能异步通信 …… 220
规则44——扩展消息总线 …… 224
规则45——避免总线过度拥挤 …… 229
总结 …… 233
第12章　意犹未尽 …… 234
规则46——警惕第三方方案 …… 237
规则47——梯级存储策略 …… 240
规则48——分类处理不同负载 …… 246
规则49——完善监控 …… 250
规则50——保持竞争力 …… 255
总结 …… 257
注释 …… 258
第13章　谋定而动 …… 259
用风险收益模型评估可扩展性项目和举措 …… 259
50条可扩展性规则简述 …… 264
可扩展性规则的利益与优先级排行榜 …… 297
总结 …… 300
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构真经
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JSP & Servlet学习笔记

第1章  Web应用程序简介	1
1.1  Web应用程序基础知识	2
1.1.1  关于HTML	2
1.1.2  URL、URN与URI	3
1.1.3  关于HTTP	5
1.1.4  有关URL编码	9
1.1.5  动态网页与静态网页	11
1.2  Servlet/JSP简介	13
1.2.1  何谓Web容器	13
1.2.2  Servlet与JSP的关系	15
1.2.3  关于MVC/Model 2	18
1.2.4  Java EE简介	21
1.3  重点复习	22
1.4  课后练习	23
第2章  编写与设置Servlet	25
2.1  第一个Servlet	26
2.1.1  准备开发环境	26
2.1.2  第一个Servlet程序	28
2.2  在HelloServlet之后	31
2.2.1  关于HttpServlet	31
2.2.2  使用@WebServlet	33
2.2.3  使用web.xml	34
2.2.4  文件组织与部署	36
2.3  进阶部署设置	37
2.3.1  URL模式设置	38
2.3.2  Web目录结构	40
2.3.3  使用web-fragment.xml	42
2.4  重点复习	45
2.5  课后练习	46
第3章  请求与响应	48
3.1  从容器到HttpServlet	49
3.1.1  Web容器做了什么	49
3.1.2  doXXX()方法	51
3.2  关于HttpServletRequest	54
3.2.1  处理请求参数与标头	54
3.2.2  请求参数编码处理	57
3.2.3  getReader()、getInputStream()
读取Body内容	60
3.2.4  getPart()、getParts()取得上传
文件	64
3.2.5  使用RequestDispatcher调派
请求	69
3.3  关于HttpServletResponse	75
3.3.1  设置响应标头、缓冲区	76
3.3.2  使用getWriter()输出字符	77
3.3.3  使用getOutputStream()输出
二进制字符	80
3.3.4  使用sendRedirect()、
sendError()	82
3.4  综合练习／微博	84
3.4.1  微博应用程序功能概述	84
3.4.2  实现会员注册功能	86
3.4.3  实现会员登录功能	90
3.5  重点复习	92
3.6  课后练习	93
第4章  会话管理	96
4.1  会话管理基本原理	97
4.1.1  使用隐藏域	97
4.1.2  使用Cookie	100
4.1.3  使用URL重写	104
4.2  HttpSession会话管理	107
4.2.1  使用HttpSession	107
4.2.2  HttpSession会话管理
原理	111
4.2.3  HttpSession与URL重写	113
4.3  综合练习／微博	115
4.3.1  修改微博应用程序	116
4.3.2  新增与删除信息	117
4.3.3  会员网页显示信息	120
4.4  重点复习	122
4.5  课后练习	123
第5章  Servlet进阶API、过滤器
与监听器	125
5.1  Servlet进阶API	126
5.1.1  Servlet、ServletConfig与GenericServlet	126
5.1.2  使用ServletConfig	128
5.1.3  使用ServletContext	131
5.2  应用程序事件、监听器	134
5.2.1  ServletContext事件、
监听器	134
5.2.2  HttpSession事件、
监听器	137
5.2.3  HttpServletRequest事件、
监听器	144
5.3  过滤器	145
5.3.1  过滤器的概念	145
5.3.2  实现与设置过滤器	147
5.3.3  请求封装器	152
5.3.4  响应封装器	157
5.4  异步处理	161
5.4.1  AsyncContext简介	161
5.4.2  模拟服务器推播	164
5.4.3  更多AsyncContext
细节	167
5.5  综合练习／微博	168
5.5.1  创建UserService	168
5.5.2  设置过滤器	174
5.5.3  重构微博	175
5.6  重点复习	180
5.7  课后练习	182
第6章  使用JSP	186
6.1  从JSP到Servlet	187
6.1.1  JSP生命周期	187
6.1.2  Servlet至JSP的简单
转换	190
6.1.3  指示元素	194
6.1.4  声明、Scriptlet与表达式
元素	198
6.1.5  注释元素	202
6.1.6  隐式对象	203
6.1.7  错误处理	205
6.2  标准标签	210
6.2.1  <jsp:include>、<jsp:forward>
标签	210
6.2.2  <jsp:useBean>、<jsp:setProperty>
与<jsp:getProperty>简介	211
6.2.3  深入<jsp:useBean>、<jsp:setProperty> 与<jsp:getProperty>	214
6.2.4  谈谈Model 1	218
6.2.5  XML格式标签	220
6.3  表达式语言(EL)	221
6.3.1  EL简介	221
6.3.2  使用EL取得属性	223
6.3.3  EL隐式对象	226
6.3.4  EL运算符	227
6.3.5  自定义EL函数	228
6.4  综合练习／微博	230
6.4.1  改用JSP实现视图	230
6.4.2  重构UserService
与member.jsp	234
6.4.3  创建register.jsp、index.jsp、
user.jsp	240
6.5  重点复习	245
6.6  课后练习	247
第7章  使用JSTL	249
7.1  JSTL简介	250
7.2  核心标签库	252
7.2.1  流程处理标签	252
7.2.2  错误处理标签	255
7.2.3  网页导入、重定向、URL
处理标签	257
7.2.4  属性处理与输出标签	258
7.3  I18N兼容格式标签库	261
7.3.1  I18N基础	261
7.3.2  信息标签	264
7.3.3  地区标签	267
7.3.4  格式标签	272
7.4  XML标签库	275
7.4.1  XPath、XSLT基础	276
7.4.2  解析、设置与输出
标签	279
7.4.3  流程处理标签	280
7.4.4  文件转换标签	281
7.5  函数标签库	283
7.6  综合练习／微博	284
7.6.1  修改register.jsp	285
7.6.2  修改member.jsp	285
7.6.3  修改user.jsp	287
7.7  重点复习	288
7.8  课后练习	290
第8章  自定义标签	293
8.1  Tag File自定义标签	294
8.1.1  Tag File简介	294
8.1.2  处理标签属性与Body	297
8.1.3  TLD文件	299
8.2  Simple Tag自定义标签	301
8.2.1  Simple Tag简介	301
8.2.2  了解API架构与生命
周期	304
8.2.3  处理标签属性与Body	306
8.2.4  与父标签沟通	310
8.2.5  TLD文件	314
8.3  Tag自定义标签	315
8.3.1  Tag简介	315
8.3.2  了解架构与生命周期	317
8.3.3  重复执行标签Body	319
8.3.4  处理Body运行结果	321
8.3.5  与父标签沟通	324
8.4  综合练习／微博	327
8.4.1  实现首页最新信息	327
8.4.2  自定义Blahs标签	330
8.5  重点复习	332
8.6  课后练习	334
第9章  整合数据库	338
9.1  JDBC入门	339
9.1.1  JDBC简介	339
9.1.2  连接数据库	344
9.1.3  使用Statement、
ResultSet	350
9.1.4  使用PreparedStatement、CallableStatement	355
9.2  JDBC进阶	359
9.2.1  使用DataSource取得
连接	359
9.2.2  使用ResultSet卷动、更新
数据	362
9.2.3  批次更新	364
9.2.4  Blob与Clob	366
9.2.5  事务简介	374
9.2.6  metadata简介	381
9.2.7  RowSet简介	384
9.3  使用SQL标签库	390
9.3.1  数据源、查询标签	390
9.3.2  更新、参数、事务标签	391
9.4  综合练习／微博	392
9.4.1  重构／使用DAO	393
9.4.2  使用JDBC实现DAO	395
9.4.3  设置JNDI部署描述	400
9.5  重点复习	401
9.6  课后练习	402
第10章  Web容器安全管理	404
10.1  了解与实现Web容器安全
管理	405
10.1.1  Java EE安全基本概念	405
10.1.2  声明式基本身份验证	408
10.1.3  容器基本身份验证
原理	413
10.1.4  声明式窗体验证	414
10.1.5  容器窗体验证原理	415
10.1.6  使用HTTPS保护
数据	416
10.1.7  编程式安全管理	419
10.1.8  标注访问控制	422
10.2  综合练习／微博	424
10.2.1  使用容器窗体验证	424
10.2.2  设置DataSourceRealm	426
10.3  重点复习	429
10.4  课后练习	430
第11章  JavaMail入门	432
11.1  使用JavaMail	433
11.1.1  传送纯文字邮件	433
11.1.2  发送多重内容邮件	436
11.2  综合练习／微博	440
11.2.1  实现取回密码功能	440
11.2.2  接收重送密码请求	445
11.3  重点复习	447
11.4  课后练习	447
第12章  从模式到框架	449
12.1  认识设计模式	450
12.1.1  Template Method模式(Gof
设计模式)	450
12.1.2  Intercepting Filter模式(Java
EE设计模式)	451
12.1.3  Model-View-Controller模式
(架构模式)	452
12.2  重构、模式与框架	453
12.2.1  Business Delegate
模式	453
12.2.2  Service Locator模式	454
12.2.3  Transfer Object模式	455
12.2.4  Front Controller模式	455
12.2.5  库与框架	456
12.3  重点复习	457
12.5  课后练习	459
附录A  如何使用本书项目	460
附录B  MySQL入门	463
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JSP & Servlet学习笔记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Spring 4.x
第1篇 基础篇
第1章 Spring概述\t2
1．1 认识Spring\t2
1．2 关于SpringSource\t4
1．3 Spring带给我们什么\t5
1．4 Spring体系结构\t6
1．5 Spring对Java版本的要求\t8
1．6 Spring 4．0新特性\t8
1．6．1 全面支持Java 8．0\t9
1．6．2 核心容器的增强\t11
1．6．3 支持用Groovy定义Bean\t12
1．6．4 Web的增强\t12
1．6．5 支持WebSocket\t12
1．6．6 测试的增强\t13
1．6．7 其他\t13
1．7 Spring子项目\t13
1．8 如何获取Spring\t15
1．9 小结\t16
第2章 快速入门\t17
2．1 实例概述\t17
2．1．1 比Hello World更适用的实例\t18
2．1．2 实例功能简介\t18
2．2 环境准备\t20
2．2．1 构建工具Maven\t20
2．2．2 创建库表\t22
2．2．3 建立工程\t23
2．2．4 类包及Spring配置文件规划\t28
2．3 持久层\t29
2．3．1 建立领域对象\t29
2．3．2 UserDao\t30
2．3．3 LoginLogDao\t33
2．3．4 在Spring中装配DAO\t34
2．4 业务层\t35
2．4．1 UserService\t35
2．4．2 在Spring中装配Service\t37
2．4．3 单元测试\t38
2．5 展现层\t40
2．5．1 配置Spring MVC框架\t40
2．5．2 处理登录请求\t42
2．5．3 JSP视图页面\t44
2．6 运行Web应用\t46
2．7 小结\t48
第3章 Spring Boot\t49
3．1 Spring Boot概览\t49
3．1．1 Spring Boot发展背景\t50
3．1．2 Spring Boot特点\t50
3．1．3 Spring Boot启动器\t50
3．2 快速入门\t52
3．3 安装配置\t54
3．3．1 基于Maven环境配置\t54
3．3．2 基于Gradle环境配置\t56
3．3．3 基于Spring Boot CLI环境
配置\t57
3．3．4 代码包结构规划\t58
3．4 持久层\t59
3．4．1 初始化配置\t59
3．4．2 UserDao\t61
3．5 业务层\t62
3．6 展现层\t64
3．6．1 配置pom．xml依赖\t64
3．6．2 配置Spring MVC框架\t65
3．6．3 处理登录请求\t65
3．7 运维支持\t67
3．8 小结\t70
第2篇 核心篇
第4章 IoC容器\t72
4．1 IoC概述\t72
4．1．1 通过实例理解IoC的概念\t73
4．1．2 IoC的类型\t75
4．1．3 通过容器完成依赖关系的
注入\t77
4．2 相关Java基础知识\t78
4．2．1 简单实例\t78
4．2．2 类装载器ClassLoader\t80
4．2．3 Java反射机制\t83
4．3 资源访问利器\t85
4．3．1 资源抽象接口\t85
4．3．2 资源加载\t88
4．4 BeanFactory和ApplicationContext\t91
4．4．1 BeanFactory介绍\t92
4．4．2 ApplicationContext介绍\t94
4．4．3 父子容器\t103
4．5 Bean的生命周期\t103
4．5．1 BeanFactory中Bean的生命
周期\t103
4．5．2 ApplicationContext中Bean
的生命周期\t112
4．6 小结\t114
第5章 在IoC容器中装配Bean\t115
5．1 Spring配置概述\t116
5．1．1 Spring容器高层视图\t116
5．1．2 基于XML的配置\t117
5．2 Bean基本配置\t120
5．2．1 装配一个Bean\t120
5．2．2 Bean的命名\t120
5．3 依赖注入\t121
5．3．1 属性注入\t121
5．3．2 构造函数注入\t124
5．3．3 工厂方法注入\t128
5．3．4 选择注入方式的考量\t130
5．4 注入参数详解\t130
5．4．1 字面值\t130
5．4．2 引用其他Bean\t131
5．4．3 内部Bean\t133
5．4．4 null值\t133
5．4．5 级联属性\t134
5．4．6 集合类型属性\t134
5．4．7 简化配置方式\t138
5．4．8 自动装配\t141
5．5 方法注入\t142
5．5．1 lookup方法注入\t142
5．5．2 方法替换\t143
5．6 ＜bean＞之间的关系\t144
5．6．1 继承\t144
5．6．2 依赖\t145
5．6．3 引用\t146
5．7 整合多个配置文件\t147
5．8 Bean作用域\t148
5．8．1 singleton作用域\t148
5．8．2 prototype作用域\t149
5．8．3 与Web应用环境相关的Bean
作用域\t150
5．8．4 作用域依赖问题\t152
5．9 FactoryBean\t153
5．10 基于注解的配置\t155
5．10．1 使用注解定义Bean\t155
5．10．2 扫描注解定义的Bean\t156
5．10．3 自动装配Bean\t157
5．10．4 Bean作用范围及生命过程
方法\t162
5．11 基于Java类的配置\t164
5．11．1 使用Java类提供Bean定义
信息\t164
5．11．2 使用基于Java类的配置信息
启动Spring容器\t167
5．12 基于Groovy DSL的配置\t169
5．12．1 使用Groovy DSL提供Bean
定义信息\t169
5．12．2 使用GenericGroovyApplication
Context启动Spring容器\t171
5．13 通过编码方式动态添加Bean\t172
5．13．1 通过DefaultListableBean
Factory\t172
5．13．2 扩展自定义标签\t173
5．14 不同配置方式比较\t175
5．15 小结\t177
第6章 Spring容器高级主题\t178
6．1 Spring容器技术内幕\t178
6．1．1 内部工作机制\t179
6．1．2 BeanDefinition\t182
6．1．3 InstantiationStrategy\t183
6．1．4 BeanWrapper\t183
6．2 属性编辑器\t184
6．2．1 JavaBean的编辑器\t185
6．2．2 Spring默认属性编辑器\t188
6．2．3 自定义属性编辑器\t189
6．3 使用外部属性文件\t192
6．3．1 PropertyPlaceholderConfigurer
属性文件\t192
6．3．2 使用加密的属性文件\t195
6．3．3 属性文件自身的引用\t198
6．4 引用Bean的属性值\t199
6．5 国际化信息\t201
6．5．1 基础知识\t201
6．5．2 MessageSource\t206
6．5．3 容器级的国际化信息资源\t209
6．6 容器事件\t210
6．6．1 Spring事件类结构\t211
6．6．2 解构Spring事件体系的具体
实现\t213
6．6．3 一个实例\t214
6．7 小结\t215
第7章 Spring AOP基础\t216
7．1 AOP概述\t216
7．1．1 AOP到底是什么\t217
7．1．2 AOP术语\t219
7．1．3 AOP的实现者\t221
7．2 基础知识\t222
7．2．1 带有横切逻辑的实例\t222
7．2．2 JDK动态代理\t224
7．2．3 CGLib动态代理\t228
7．2．4 AOP联盟\t229
7．2．5 代理知识小结\t230
7．3 创建增强类\t230
7．3．1 增强类型\t230
7．3．2 前置增强\t231
7．3．3 后置增强\t235
7．3．4 环绕增强\t236
7．3．5 异常抛出增强\t237
7．3．6 引介增强\t239
7．4 创建切面\t243
7．4．1 切点类型\t243
7．4．2 切面类型\t244
7．4．3 静态普通方法名匹配切面\t246
7．4．4 静态正则表达式方法匹配
切面\t248
7．4．5 动态切面\t251
7．4．6 流程切面\t254
7．4．7 复合切点切面\t256
7．4．8 引介切面\t258
7．5 自动创建代理\t259
7．5．1 实现类介绍\t259
7．5．2 BeanNameAutoProxyCreator\t260
7．5．3 DefaultAdvisorAutoProxy
Creator\t261
7．5．4 AOP无法增强疑难问题
剖析\t262
7．6 小结\t267
第8章 基于@AspectJ和Schema的
AOP\t269
8．1 Spring对AOP的支持\t269
8．2 Java 5．0注解知识快速进阶\t270
8．2．1 了解注解\t270
8．2．2 一个简单的注解类\t271
8．2．3 使用注解\t272
8．2．4 访问注解\t273
8．3 着手使用@AspectJ\t274
8．3．1 使用前的准备\t275
8．3．2 一个简单的例子\t275
8．3．3 如何通过配置使用@AspectJ
切面\t277
8．4 @AspectJ语法基础\t278
8．4．1 切点表达式函数\t278
8．4．2 在函数入参中使用通配符\t279
8．4．3 逻辑运算符\t280
8．4．4 不同增强类型\t281
8．4．5 引介增强用法\t282
8．5 切点函数详解\t283
8．5．1 @annotation()\t284
8．5．2 execution()\t285
8．5．3 args()和@args()\t287
8．5．4 within()\t288
8．5．5 @within()和@target()\t289
8．5．6 target()和this()\t290
8．6 @AspectJ进阶\t291
8．6．1 切点复合运算\t292
8．6．2 命名切点\t292
8．6．3 增强织入的顺序\t294
8．6．4 访问连接点信息\t294
8．6．5 绑定连接点方法入参\t295
8．6．6 绑定代理对象\t297
8．6．7 绑定类注解对象\t298
8．6．8 绑定返回值\t299
8．6．9 绑定抛出的异常\t299
8．7 基于Schema配置切面\t300
8．7．1 一个简单切面的配置\t300
8．7．2 配置命名切点\t302
8．7．3 各种增强类型的配置\t303
8．7．4 绑定连接点信息\t305
8．7．5 Advisor配置\t306
8．8 混合切面类型\t307
8．8．1 混合使用各种切面类型\t308
8．8．2 各种切面类型总结\t308
8．9 其他\t309
8．9．1 JVM Class文件字节码转换
基础知识\t309
8．9．2 使用LTW织入切面\t311
8．10 小结\t314
第9章 Spring SpEL\t316
9．1 JVM动态语言\t316
9．2 SpEL表达式概述\t318
9．3 SpEL核心接口\t319
9．3．1 EvaluationContext接口\t320
9．3．2 SpEL编译器\t321
9．4 SpEL基础表达式\t323
9．4．1 文本字符解析\t323
9．4．2 对象属性解析\t323
9．4．3 数组、集合类型解析\t324
9．4．4 方法解析\t326
9．4．5 操作符解析\t327
9．4．6 安全导航操作符\t329
9．4．7 三元操作符\t330
9．4．8 Elvis操作符\t331
9．4．9 赋值、类型、构造器、变量\t332
9．4．10 集合过滤\t335
9．4．11 集合转换\t335
9．5 在Spring中使用SpEL\t336
9．5．1 基于XML的配置\t336
9．5．2 基于注解的配置\t337
9．6 小结\t338
第3篇 数据篇
第10章 Spring对DAO的支持\t340
10．1 Spring的DAO理念\t340
10．2 统一的异常体系\t341
10．2．1 Spring的DAO异常体系\t341
10．2．2 JDBC的异常转换器\t343
10．2．3 其他持久化技术的异常
转换器\t344
10．3 统一数据访问模板\t344
10．3．1 使用模板和回调机制\t345
10．3．2 Spring为不同持久化技术
所提供的模板类\t347
10．4 数据源\t348
10．4．1 配置一个数据源\t348
10．4．2 获取JNDI数据源\t352
10．4．3 Spring的数据源实现类\t353
10．5 小结\t353
第11章 Spring的事务管理\t355
11．1 数据库事务基础知识\t355
11．1．1 何为数据库事务\t356
11．1．2 数据并发的问题\t357
11．1．3 数据库锁机制\t359
11．1．4 事务隔离级别\t360
11．1．5 JDBC对事务的支持\t361
11．2 ThreadLocal基础知识\t362
11．2．1 ThreadLocal是什么\t363
11．2．2 ThreadLocal的接口方法\t363
11．2．3 一个TheadLocal实例\t364
11．2．4 与Thread同步机制的比较\t366
11．2．5 Spring使用ThreadLocal解决
线程安全问题\t366
11．3 Spring对事务管理的支持\t368
11．3．1 事务管理关键抽象\t369
11．3．2 Spring的事务管理器实现类\t371
11．3．3 事务同步管理器\t374
11．3．4 事务传播行为\t375
11．4 编程式的事务管理\t376
11．5 使用XML配置声明式事务\t377
11．5．1 一个将被实施事务增强的
服务接口\t379
11．5．2 使用原始的TransactionProxy
FactoryBean\t379
11．5．3 基于aop/tx命名空间的配置\t382
11．6 使用注解配置声明式事务\t385
11．6．1 使用@Transactional注解\t385
11．6．2 通过AspectJ LTW引入事务
切面\t389
11．7 集成特定的应用服务器\t390
11．7．1 BEA WebLogic\t390
11．7．2 WebSphere\t390
11．8 小结\t390
第12章 Spring的事务管理难点剖析\t392
12．1 DAO和事务管理的牵绊\t393
12．1．1 JDBC访问数据库\t393
12．1．2 Hibernate访问数据库\t395
12．2 应用分层的迷惑\t398
12．3 事务方法嵌套调用的迷茫\t401
12．3．1 Spring事务传播机制回顾\t401
12．3．2 相互嵌套的服务方法\t402
12．4 多线程的困惑\t405
12．4．1 Spring通过单实例化Bean
简化多线程问题\t405
12．4．2 启动独立线程调用事务
方法\t405
12．5 联合军种作战的混乱\t408
12．5．1 Spring事务管理器的应对\t408
12．5．2 Hibernate+Spring JDBC
混合框架的事务管理\t408
12．6 特殊方法成漏网之鱼\t412
12．6．1 哪些方法不能实施Spring
AOP事务\t412
12．6．2 事务增强遗漏实例\t413
12．7 数据连接泄露\t416
12．7．1 底层连接资源的访问问题\t416
12．7．2 Spring JDBC数据连接泄露\t417
12．7．3 事务环境下通过DataSource
Utils获取数据连接\t420
12．7．4 无事务环境下通过DataSource
Utils获取数据连接\t422
12．7．5 JdbcTemplate如何做到对连接
泄露的免疫\t424
12．7．6 使用TransactionAwareData
SourceProxy\t425
12．7．7 其他数据访问技术的等价类\t426
12．8 小结\t426
第13章 使用Spring JDBC访问
数据库\t428
13．1 使用Spring JDBC\t428
13．1．1 JdbcTemplate小试牛刀\t429
13．1．2 在DAO中使用Jdbc
Template\t429
13．2 基本的数据操作\t431
13．2．1 更改数据\t431
13．2．2 返回数据库的表自增主键值\t434
13．2．3 批量更改数据\t436
13．2．4 查询数据\t437
13．2．5 查询单值数据\t440
13．2．6 调用存储过程\t442
13．3 BLOB/CLOB类型数据的操作\t444
13．3．1 如何获取本地数据连接\t445
13．3．2 相关的操作接口\t446
13．3．3 插入LOB类型的数据\t448
13．3．4 以块数据方式读取LOB
数据\t450
13．3．5 以流数据方式读取LOB
数据\t451
13．4 自增键和行集\t452
13．4．1 自增键的使用\t452
13．4．2 如何规划主键方案\t454
13．4．3 以行集返回数据\t456
13．5 NamedParameterJdbcTemplate
模板类\t456
13．6 小结\t459
第14章 整合其他ORM框架\t460
14．1 Spring整合ORM技术\t460
14．2 在Spring中使用Hibernate\t462
14．2．1 配置SessionFactory\t462
14．2．2 使用HibernateTemplate\t465
14．2．3 处理LOB类型的数据\t469
14．2．4 添加Hibernate事件监听器\t470
14．2．5 使用原生的Hibernate API\t471
14．2．6 使用注解配置\t472
14．2．7 事务处理\t474
14．2．8 延迟加载问题\t475
14．3 在Spring中使用MyBatis\t476
14．3．1 配置SqlMapClient\t476
14．3．2 在Spring中配置MyBatis\t478
14．3．3 编写MyBatis的DAO\t479
14．4 DAO层设计\t482
14．4．1 DAO基类设计\t482
14．4．2 查询接口方法设计\t484
14．4．3 分页查询接口设计\t486
14．5 小结\t487
第4篇 应用篇
第15章 Spring Cache\t490
15．1 缓存概述\t490
15．1．1 缓存的概念\t490
15．1．2 使用Spring Cache\t493
15．2 掌握Spring Cache抽象\t498
15．2．1 缓存注解\t498
15．2．2 缓存管理器\t504
15．2．3 使用SpEL表达式\t506
15．2．4 基于XML的Cache声明\t506
15．2．5 以编程方式初始化缓存\t507
15．2．6 自定义缓存注解\t509
15．3 配置Cache存储\t509
15．3．1 EhCache\t510
15．3．2 Guava\t510
15．3．3 HazelCast\t511
15．3．4 GemFire\t511
15．3．5 JSR-107 Cache\t511
15．4 实战经验\t513
15．5 小结\t514
第16章 任务调度和异步执行器\t516
16．1 任务调度概述\t516
16．2 Quartz快速进阶\t517
16．2．1 Quartz基础结构\t518
16．2．2 使用SimpleTrigger\t520
16．2．3 使用CronTrigger\t522
16．2．4 使用Calendar\t526
16．2．5 任务调度信息存储\t527
16．3 在Spring中使用Quartz\t530
16．3．1 创建JobDetail\t530
16．3．2 创建Trigger\t533
16．3．3 创建Scheduler\t534
16．4 在Spring中使用JDK Timer\t536
16．4．1 Timer和TimerTask\t536
16．4．2 Spring对Java Timer的支持\t539
16．5 Spring对Java 5．0 Executor的
支持\t540
16．5．1 了解Java 5．0的Executor\t541
16．5．2 Spring对Executor所提供的
抽象\t543
16．6 实际应用中的任务调度\t544
16．6．1 如何产生任务\t545
16．6．2 任务调度对应用程序集群的
影响\t547
16．6．3 任务调度云\t547
16．6．4 Web应用程序中调度器的
启动和关闭问题\t549
16．7 小结\t552
第17章 Spring MVC\t553
17．1 Spring MVC体系概述\t554
17．1．1 体系结构\t554
17．1．2 配置DispatcherServlet\t555
17．1．3 一个简单的实例\t560
17．2 注解驱动的控制器\t565
17．2．1 使用@RequestMapping
映射请求\t565
17．2．2 请求处理方法签名\t569
17．2．3 使用矩阵变量绑定参数\t570
17．2．4 请求处理方法签名详细说明\t571
17．2．5 使用HttpMessageConverter
＜T＞\t575
17．2．6 使用@RestController和AsyncRestTemplate\t584
17．2．7 处理模型数据\t586
17．3 处理方法的数据绑定\t591
17．3．1 数据绑定流程剖析\t592
17．3．2 数据转换\t592
17．3．3 数据格式化\t598
17．3．4 数据校验\t602
17．4 视图和视图解析器\t611
17．4．1 认识视图\t611
17．4．2 认识视图解析器\t612
17．4．3 JSP和JSTL\t613
17．4．4 模板视图\t618
17．4．5 Excel\t621
17．4．6 PDF\t623
17．4．7 输出XML\t625
17．4．8 输出JSON\t626
17．4．9 使用XmlViewResolver\t626
17．4．10 使用ResourceBundleView
Resolver\t627
17．4．11 混合使用多种视图技术\t628
17．5 本地化解析\t630
17．5．1 本地化的概念\t630
17．5．2 使用CookieLocaleResolver\t631
17．5．3 使用SessionLocaleResolver\t632
17．5．4 使用LocaleChange
Interceptor\t632
17．6 文件上传\t633
17．6．1 配置MultipartResolver\t633
17．6．2 编写控制器和文件上传表单
页面\t633
17．7 WebSocket支持\t634
17．7．1 使用WebSocket\t634
17．7．2 WebSocket的限制\t638
17．8 杂项\t639
17．8．1 静态资源处理\t639
17．8．2 装配拦截器\t643
17．8．3 异常处理\t644
17．8．4 RequestContextHolder的
使用\t646
17．9 小结\t646
第18章 实战案例开发\t648
18．1 论坛案例概述\t648
18．1．1 论坛整体功能结构\t648
18．1．2 论坛用例描述\t649
18．1．3 主要功能流程描述\t651
18．2 系统设计\t655
18．2．1 技术框架选择\t655
18．2．2 采用Maven构建项目\t656
18．2．3 单元测试类包结构规划\t657
18．2．4 系统架构图\t658
18．2．5 PO类设计\t658
18．2．6 持久层设计\t659
18．2．7 服务层设计\t660
18．2．8 Web层设计\t661
18．2．9 数据库设计\t662
18．3 开发前的准备\t663
18．4 持久层开发\t664
18．4．1 PO类\t664
18．4．2 DAO基类\t666
18．4．3 通过扩展基类定义DAO类\t670
18．4．4 DAO Bean的装配\t672
18．4．5 使用Hibernate二级缓存\t673
18．5 对持久层进行测试\t675
18．5．1 配置Unitils测试环境\t675
18．5．2 准备测试数据库及测试
数据\t676
18．5．3 编写DAO测试基类\t677
18．5．4 编写BoardDao测试用例\t678
18．6 服务层开发\t680
18．6．1 UserService的开发\t680
18．6．2 ForumService的开发\t681
18．6．3 服务类Bean的装配\t683
18．7 对服务层进行测试\t684
18．7．1 编写Service测试基类\t685
18．7．2 编写ForumService测试
用例\t685
18．8 Web层开发\t687
18．8．1 BaseController的基类\t687
18．8．2 用户登录和注销\t689
18．8．3 用户注册\t691
18．8．4 论坛管理\t692
18．8．5 论坛普通功能\t694
18．8．6 分页显示论坛版块的主题
帖子\t696
18．8．7 web．xml配置\t700
18．8．8 Spring MVC配置\t702
18．9 对Web层进行测试\t703
18．9．1 编写Web测试基类\t703
18．9．2 编写ForumManageController
测试用例\t704
18．10 开发环境部署\t705
18．11 项目配置实战经验\t708
18．11．1 “传统的”Web项目属性
文件\t708
18．11．2 如何规划便于部署的Web
项目属性文件\t709
18．11．3 数据源的配置\t710
18．12 小结\t712
第5篇 提高篇
第19章 Spring OXM\t714
19．1 认识XML解析技术\t714
19．1．1 什么是XML\t714
19．1．2 XML的处理技术\t715
19．2 XML处理利器：XStream\t717
19．2．1 XStream概述\t717
19．2．2 快速入门\t718
19．2．3 使用XStream别名\t720
19．2．4 XStream转换器\t721
19．2．5 XStream注解\t723
19．2．6 流化对象\t725
19．2．7 持久化API\t726
19．2．8 额外功能：处理JSON\t727
19．3 其他常见的O/X Mapping开源
项目\t729
19．3．1 JAXB\t729
19．3．2 Castor\t733
19．3．3 JiBX\t738
19．3．4 总结比较\t741
19．4 与Spring OXM整合\t742
19．4．1 Spring OXM概述\t742
19．4．2 整合OXM实现者\t744
19．4．3 如何在Spring中进行配置\t744
19．4．4 Spring OXM简单实例\t747
19．5 小结\t749
第20章 实战型单元测试\t750
20．1 单元测试概述\t751
20．1．1 为什么需要单元测试\t751
20．1．2 单元测试之误解\t752
20．1．3 单元测试之困境\t754
20．1．4 单元测试基本概念\t755
20．2 TestNG快速进阶\t757
20．2．1 TestNG概述\t757
20．2．2 TestNG生命周期\t758
20．2．3 使用TestNG\t758
20．3 模拟利器Mockito\t763
20．3．1 模拟测试概述\t763
20．3．2 创建Mock对象\t763
20．3．3 设定Mock对象的期望行为
及返回值\t764
20．3．4 验证交互行为\t766
20．4 测试整合之王Unitils\t767
20．4．1 Unitils概述\t767
20．4．2 集成Spring\t770
20．4．3 集成Hibernate\t773
20．4．4 集成DbUnit\t774
20．4．5 自定义扩展模块\t775
20．5 使用Unitils测试DAO层\t776
20．5．1 数据库测试的难点\t776
20．5．2 扩展DbUnit用Excel准备
数据\t776
20．5．3 测试实战\t779
20．6 使用Unitils测试Service层\t789
20．7 测试Web层\t794
20．7．1 对LoginController进行单元
测试\t794
20．7．2 使用Spring Servlet API模拟
对象\t795
20．7．3 使用Spring RestTemplate
测试\t797
20．8 小结\t798
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Spring 4.x
