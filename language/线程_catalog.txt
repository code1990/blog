>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux多线程服务端编程
第1 部分C++ 多线程系统编程1
第1章 线程安全的对象生命期管理3
1.1 当析构函数遇到多线程. . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
1.1.1 线程安全的定义. . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
1.1.2 MutexLock 与MutexLockGuard . . . . . . . . . . . . . . . . . . . . 4
1.1.3 一个线程安全的Counter 示例. . . . . . . . . . . . . . . . . . . . 4
1.2 对象的创建很简单. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
1.3 销毁太难. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.3.1 mutex 不是办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
1.3.2 作为数据成员的mutex 不能保护析构. . . . . . . . . . . . . . . 8
1.4 线程安全的Observer 有多难. . . . . . . . . . . . . . . . . . . . . . . . . 8
1.5 原始指针有何不妥. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
1.6 神器shared_ptr/weak_ptr . . . . . . . . . . . . . . . . . . . . . . . . . . 13
1.7 插曲：系统地避免各种指针错误. . . . . . . . . . . . . . . . . . . . . . . 14
1.8 应用到Observer 上. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
1.9 再论shared_ptr 的线程安全. . . . . . . . . . . . . . . . . . . . . . . . . 17
1.10 shared_ptr 技术与陷阱. . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
1.11 对象池. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
1.11.1 enable_shared_from_this . . . . . . . . . . . . . . . . . . . . . . 23
1.11.2 弱回调. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24
1.12 替代方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
1.13 心得与小结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
1.14 Observer 之谬. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28
第2章 线程同步精要31
2.1 互斥器（mutex） . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
2.1.1 只使用非递归的mutex . . . . . . . . . . . . . . . . . . . . . . . . 33
2.1.2 死锁. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
2.2 条件变量（condition variable） . . . . . . . . . . . . . . . . . . . . . . . 40
2.3 不要用读写锁和信号量. . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
2.4 封装MutexLock、MutexLockGuard、Condition . . . . . . . . . . . . . . 44
2.5 线程安全的Singleton 实现. . . . . . . . . . . . . . . . . . . . . . . . . . 48
2.6 sleep(3) 不是同步原语. . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
2.7 归纳与总结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51
2.8 借shared_ptr 实现copy-on-write . . . . . . . . . . . . . . . . . . . . . . 52
第3章 多线程服务器的适用场合与常用编程模型59
3.1 进程与线程. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
3.2 单线程服务器的常用编程模型. . . . . . . . . . . . . . . . . . . . . . . . 61
3.3 多线程服务器的常用编程模型. . . . . . . . . . . . . . . . . . . . . . . . 62
3.3.1 one loop per thread . . . . . . . . . . . . . . . . . . . . . . . . . . 62
3.3.2 线程池. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63
3.3.3 推荐模式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64
3.4 进程间通信只用TCP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65
3.5 多线程服务器的适用场合. . . . . . . . . . . . . . . . . . . . . . . . . . . 67
3.5.1 必须用单线程的场合. . . . . . . . . . . . . . . . . . . . . . . . . 69
3.5.2 单线程程序的优缺点. . . . . . . . . . . . . . . . . . . . . . . . . 70
3.5.3 适用多线程程序的场景. . . . . . . . . . . . . . . . . . . . . . . . 71
3.6 “多线程服务器的适用场合”例释与答疑. . . . . . . . . . . . . . . . . . 74
第4章 C++ 多线程系统编程精要83
4.1 基本线程原语的选用. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84
4.2 C/C++ 系统库的线程安全性. . . . . . . . . . . . . . . . . . . . . . . . . 85
4.3 Linux 上的线程标识. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89
4.4 线程的创建与销毁的守则. . . . . . . . . . . . . . . . . . . . . . . . . . . 91
4.4.1 pthread_cancel 与C++ . . . . . . . . . . . . . . . . . . . . . . . 94
4.4.2 exit(3) 在C++ 中不是线程安全的. . . . . . . . . . . . . . . . . 94
4.5 善用__thread 关键字. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96
4.6 多线程与IO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98
4.7 用RAII 包装文件描述符. . . . . . . . . . . . . . . . . . . . . . . . . . . 99
4.8 RAII 与fork() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101
4.9 多线程与fork() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102
4.10 多线程与signal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
4.11 Linux 新增系统调用的启示. . . . . . . . . . . . . . . . . . . . . . . . . . 105
第5章 高效的多线程日志107
5.1 功能需求. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
5.2 性能需求. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112
5.3 多线程异步日志. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114
5.4 其他方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120
第2部分 muduo 网络库123
第6章 muduo 网络库简介125
6.1 由来. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125
6.2 安装. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127
6.3 目录结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
6.3.1 代码结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
6.3.2 例子. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
6.3.3 线程模型. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
6.4 使用教程. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
6.4.1 TCP 网络编程本质论. . . . . . . . . . . . . . . . . . . . . . . . . 136
6.4.2 echo 服务的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . 138
6.4.3 七步实现finger 服务. . . . . . . . . . . . . . . . . . . . . . . . . 140
6.5 性能评测. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144
6.5.1 muduo 与Boost.Asio、libevent2 的吞吐量对比. . . . . . . . . . 145
6.5.2 击鼓传花：对比muduo 与libevent2 的事件处理效率. . . . . . 148
6.5.3 muduo 与Nginx 的吞吐量对比. . . . . . . . . . . . . . . . . . . 153
6.5.4 muduo 与ZeroMQ 的延迟对比. . . . . . . . . . . . . . . . . . . 156
6.6 详解muduo 多线程模型. . . . . . . . . . . . . . . . . . . . . . . . . . . 157
6.6.1 数独求解服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
6.6.2 常见的并发网络服务程序设计方案. . . . . . . . . . . . . . . . . 160
第7章 muduo 编程示例177
7.1 五个简单TCP 示例. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178
7.2 文件传输. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185
7.3 Boost.Asio 的聊天服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . 194
7.3.1 TCP 分包. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194
7.3.2 消息格式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195
7.3.3 编解码器LengthHeaderCodec . . . . . . . . . . . . . . . . . . . . 197
7.3.4 服务端的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198
7.3.5 客户端的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200
7.4 muduo Buffer 类的设计与使用. . . . . . . . . . . . . . . . . . . . . . . 204
7.4.1 muduo 的IO 模型. . . . . . . . . . . . . . . . . . . . . . . . . . 204
7.4.2 为什么non-blocking 网络编程中应用层buffer 是必需的. . . . 205
7.4.3 Buffer 的功能需求. . . . . . . . . . . . . . . . . . . . . . . . . . 207
7.4.4 Buffer 的数据结构. . . . . . . . . . . . . . . . . . . . . . . . . . 209
7.4.5 Buffer 的操作. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211
7.4.6 其他设计方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
7.4.7 性能是不是问题. . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
7.5 一种自动反射消息类型的Google Protobuf 网络传输方案. . . . . . . . 220
7.5.1 网络编程中使用Protobuf 的两个先决条件. . . . . . . . . . . . . 220
7.5.2 根据type name 反射自动创建Message 对象. . . . . . . . . . . . 221
7.5.3 Protobuf 传输格式. . . . . . . . . . . . . . . . . . . . . . . . . . 226
7.6 在muduo 中实现Protobuf 编解码器与消息分发器. . . . . . . . . . . . 228
7.6.1 什么是编解码器（codec） . . . . . . . . . . . . . . . . . . . . . . 229
7.6.2 实现ProtobufCodec . . . . . . . . . . . . . . . . . . . . . . . . . 232
7.6.3 消息分发器（dispatcher）有什么用. . . . . . . . . . . . . . . . 232
7.6.4 ProtobufCodec 与ProtobufDispatcher 的综合运用. . . . . . . 233
7.6.5 ProtobufDispatcher 的两种实现. . . . . . . . . . . . . . . . . . 234
7.6.6 ProtobufCodec 和ProtobufDispatcher 有何意义. . . . . . . . . 236
7.7 限制服务器的最大并发连接数. . . . . . . . . . . . . . . . . . . . . . . . 237
7.7.1 为什么要限制并发连接数. . . . . . . . . . . . . . . . . . . . . . 237
7.7.2 在muduo 中限制并发连接数. . . . . . . . . . . . . . . . . . . . 238
7.8 定时器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240
7.8.1 程序中的时间. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240
7.8.2 Linux 时间函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . 241
7.8.3 muduo 的定时器接口. . . . . . . . . . . . . . . . . . . . . . . . . 242
7.8.4 Boost.Asio Timer 示例. . . . . . . . . . . . . . . . . . . . . . . . 243
7.8.5 Java Netty 示例. . . . . . . . . . . . . . . . . . . . . . . . . . . . 245
7.9 测量两台机器的网络延迟和时间差. . . . . . . . . . . . . . . . . . . . . 248
7.10 用timing wheel 踢掉空闲连接. . . . . . . . . . . . . . . . . . . . . . . . 250
7.10.1 timing wheel 原理. . . . . . . . . . . . . . . . . . . . . . . . . . 251
7.10.2 代码实现与改进. . . . . . . . . . . . . . . . . . . . . . . . . . . . 254
7.11 简单的消息广播服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257
7.12 “串并转换”连接服务器及其自动化测试. . . . . . . . . . . . . . . . . . 260
7.13 socks4a 代理服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264
7.13.1 TCP 中继器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264
7.13.2 socks4a 代理服务器. . . . . . . . . . . . . . . . . . . . . . . . . . 267
7.13.3 N : 1 与1 : N 连接转发. . . . . . . . . . . . . . . . . . . . . . . . 267
7.14 短址服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267
7.15 与其他库集成. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268
7.15.1 UDNS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270
7.15.2 c-ares DNS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272
7.15.3 curl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273
7.15.4 更多. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275
第8章 muduo 网络库设计与实现277
8.0 什么都不做的EventLoop . . . . . . . . . . . . . . . . . . . . . . . . . . . 277
8.1 Reactor 的关键结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280
8.1.1 Channel class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280
8.1.2 Poller class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283
8.1.3 EventLoop 的改动. . . . . . . . . . . . . . . . . . . . . . . . . . . 287
8.2 TimerQueue 定时器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290
8.2.1 TimerQueue class . . . . . . . . . . . . . . . . . . . . . . . . . . . 290
8.2.2 EventLoop 的改动. . . . . . . . . . . . . . . . . . . . . . . . . . . 292
8.3 EventLoop::runInLoop() 函数. . . . . . . . . . . . . . . . . . . . . . . . 293
8.3.1 提高TimerQueue 的线程安全性. . . . . . . . . . . . . . . . . . . 296
8.3.2 EventLoopThread class . . . . . . . . . . . . . . . . . . . . . . . . 297
8.4 实现TCP 网络库. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299
8.5 TcpServer 接受新连接. . . . . . . . . . . . . . . . . . . . . . . . . . . . 303
8.5.1 TcpServer class . . . . . . . . . . . . . . . . . . . . . . . . . . . . 304
8.5.2 TcpConnection class . . . . . . . . . . . . . . . . . . . . . . . . . 305
8.6 TcpConnection 断开连接. . . . . . . . . . . . . . . . . . . . . . . . . . . 308
8.7 Buffer 读取数据. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 313
8.7.1 TcpConnection 使用Buffer 作为输入缓冲. . . . . . . . . . . . . 314
8.7.2 Buffer::readFd() . . . . . . . . . . . . . . . . . . . . . . . . . . 315
8.8 TcpConnection 发送数据. . . . . . . . . . . . . . . . . . . . . . . . . . . 316
8.9 完善TcpConnection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 320
8.9.1 SIGPIPE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321
8.9.2 TCP No Delay 和TCP keepalive . . . . . . . . . . . . . . . . . . 321
8.9.3 WriteCompleteCallback 和HighWaterMarkCallback . . . . . . . 322
8.10 多线程TcpServer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 324
8.11 Connector . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327
8.12 TcpClient . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 332
8.13 epoll . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333
8.14 测试程序一览. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 336
第3部分 工程实践经验谈337
第9章 分布式系统工程实践339
9.1 我们在技术浪潮中的位置. . . . . . . . . . . . . . . . . . . . . . . . . . . 341
9.1.1 分布式系统的本质困难. . . . . . . . . . . . . . . . . . . . . . . . 343
9.1.2 分布式系统是个险恶的问题. . . . . . . . . . . . . . . . . . . . . 344
9.2 分布式系统的可靠性浅说. . . . . . . . . . . . . . . . . . . . . . . . . . . 349
9.2.1 分布式系统的软件不要求7  24 可靠. . . . . . . . . . . . . . . . 352
9.2.2 “能随时重启进程”作为程序设计目标. . . . . . . . . . . . . . . 354
9.3 分布式系统中心跳协议的设计. . . . . . . . . . . . . . . . . . . . . . . . 356
9.4 分布式系统中的进程标识. . . . . . . . . . . . . . . . . . . . . . . . . . . 360
9.4.1 错误做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361
9.4.2 正确做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 362
9.4.3 TCP 协议的启示. . . . . . . . . . . . . . . . . . . . . . . . . . . . 363
9.5 构建易于维护的分布式程序. . . . . . . . . . . . . . . . . . . . . . . . . 364
9.6 为系统演化做准备. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 367
9.6.1 可扩展的消息格式. . . . . . . . . . . . . . . . . . . . . . . . . . 368
9.6.2 反面教材：ICE 的消息打包格式. . . . . . . . . . . . . . . . . . . 369
9.7 分布式程序的自动化回归测试. . . . . . . . . . . . . . . . . . . . . . . . 370
9.7.1 单元测试的能与不能. . . . . . . . . . . . . . . . . . . . . . . . . 370
9.7.2 分布式系统测试的要点. . . . . . . . . . . . . . . . . . . . . . . . 373
9.7.3 分布式系统的抽象观点. . . . . . . . . . . . . . . . . . . . . . . . 374
9.7.4 一种自动化的回归测试方案. . . . . . . . . . . . . . . . . . . . . 375
9.7.5 其他用处. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 379
9.8 分布式系统部署、监控与进程管理的几重境界. . . . . . . . . . . . . . . 380
9.8.1 境界1：全手工操作. . . . . . . . . . . . . . . . . . . . . . . . . 382
9.8.2 境界2：使用零散的自动化脚本和第三方组件. . . . . . . . . . . 383
9.8.3 境界3：自制机群管理系统，集中化配置. . . . . . . . . . . . . 386
9.8.4 境界4：机群管理与naming service 结合. . . . . . . . . . . . . 389
第10章 C++ 编译链接模型精要391
10.1 C 语言的编译模型及其成因. . . . . . . . . . . . . . . . . . . . . . . . . 394
10.1.1 为什么C 语言需要预处理. . . . . . . . . . . . . . . . . . . . . . 395
10.1.2 C 语言的编译模型. . . . . . . . . . . . . . . . . . . . . . . . . . . 398
10.2 C++ 的编译模型. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399
10.2.1 单遍编译. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399
10.2.2 前向声明. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 402
10.3 C++ 链接（linking） . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 404
10.3.1 函数重载. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 406
10.3.2 inline 函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 407
10.3.3 模板. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 409
10.3.4 虚函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 414
10.4 工程项目中头文件的使用规则. . . . . . . . . . . . . . . . . . . . . . . . 415
10.4.1 头文件的害处. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 416
10.4.2 头文件的使用规则. . . . . . . . . . . . . . . . . . . . . . . . . . 417
10.5 工程项目中库文件的组织原则. . . . . . . . . . . . . . . . . . . . . . . . 418
10.5.1 动态库是有害的. . . . . . . . . . . . . . . . . . . . . . . . . . . . 423
10.5.2 静态库也好不到哪儿去. . . . . . . . . . . . . . . . . . . . . . . . 424
10.5.3 源码编译是王道. . . . . . . . . . . . . . . . . . . . . . . . . . . . 428
第11章 反思C++ 面向对象与虚函数429
11.1 朴实的C++ 设计. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 429
11.2 程序库的二进制兼容性. . . . . . . . . . . . . . . . . . . . . . . . . . . . 431
11.2.1 什么是二进制兼容性. . . . . . . . . . . . . . . . . . . . . . . . . 432
11.2.2 有哪些情况会破坏库的ABI . . . . . . . . . . . . . . . . . . . . . 433
11.2.3 哪些做法多半是安全的. . . . . . . . . . . . . . . . . . . . . . . . 435
11.2.4 反面教材：COM . . . . . . . . . . . . . . . . . . . . . . . . . . . 435
11.2.5 解决办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 436
11.3 避免使用虚函数作为库的接口. . . . . . . . . . . . . . . . . . . . . . . . 436
11.3.1 C++ 程序库的作者的生存环境. . . . . . . . . . . . . . . . . . . . 437
11.3.2 虚函数作为库的接口的两大用途. . . . . . . . . . . . . . . . . . 438
11.3.3 虚函数作为接口的弊端. . . . . . . . . . . . . . . . . . . . . . . . 439
11.3.4 假如Linux 系统调用以COM 接口方式实现. . . . . . . . . . . . 442
11.3.5 Java 是如何应对的. . . . . . . . . . . . . . . . . . . . . . . . . . 443
11.4 动态库接口的推荐做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . 443
11.5 以boost::function 和boost::bind 取代虚函数. . . . . . . . . . . . . 447
11.5.1 基本用途. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 450
11.5.2 对程序库的影响. . . . . . . . . . . . . . . . . . . . . . . . . . . . 451
11.5.3 对面向对象程序设计的影响. . . . . . . . . . . . . . . . . . . . . 453
11.6 iostream 的用途与局限. . . . . . . . . . . . . . . . . . . . . . . . . . . . 457
11.6.1 stdio 格式化输入输出的缺点. . . . . . . . . . . . . . . . . . . . . 457
11.6.2 iostream 的设计初衷. . . . . . . . . . . . . . . . . . . . . . . . . 461
11.6.3 iostream 与标准库其他组件的交互. . . . . . . . . . . . . . . . . 463
11.6.4 iostream 在使用方面的缺点. . . . . . . . . . . . . . . . . . . . . 464
11.6.5 iostream 在设计方面的缺点. . . . . . . . . . . . . . . . . . . . . 468
11.6.6 一个300 行的memory buffer output stream . . . . . . . . . . . 476
11.6.7 现实的C++ 程序如何做文件IO . . . . . . . . . . . . . . . . . . . 480
11.7 值语义与数据抽象. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482
11.7.1 什么是值语义. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482
11.7.2 值语义与生命期. . . . . . . . . . . . . . . . . . . . . . . . . . . . 483
11.7.3 值语义与标准库. . . . . . . . . . . . . . . . . . . . . . . . . . . . 488
11.7.4 值语义与C++ 语言. . . . . . . . . . . . . . . . . . . . . . . . . . 488
11.7.5 什么是数据抽象. . . . . . . . . . . . . . . . . . . . . . . . . . . . 490
11.7.6 数据抽象所需的语言设施. . . . . . . . . . . . . . . . . . . . . . 493
11.7.7 数据抽象的例子. . . . . . . . . . . . . . . . . . . . . . . . . . . . 495
第12章 C++ 经验谈501
12.1 用异或来交换变量是错误的. . . . . . . . . . . . . . . . . . . . . . . . . 501
12.1.1 编译器会分别生成什么代码. . . . . . . . . . . . . . . . . . . . . 503
12.1.2 为什么短的代码不一定快. . . . . . . . . . . . . . . . . . . . . . 505
12.2 不要重载全局::operator new() . . . . . . . . . . . . . . . . . . . . . . 507
12.2.1 内存管理的基本要求. . . . . . . . . . . . . . . . . . . . . . . . . 507
12.2.2 重载::operator new() 的理由. . . . . . . . . . . . . . . . . . . 508
12.2.3 ::operator new() 的两种重载方式. . . . . . . . . . . . . . . . . 508
12.2.4 现实的开发环境. . . . . . . . . . . . . . . . . . . . . . . . . . . . 509
12.2.5 重载::operator new() 的困境. . . . . . . . . . . . . . . . . . . 510
12.2.6 解决办法：替换malloc() . . . . . . . . . . . . . . . . . . . . . . 512
12.2.7 为单独的class 重载::operator new() 有问题吗. . . . . . . . . 513
12.2.8 有必要自行定制内存分配器吗. . . . . . . . . . . . . . . . . . . . 513
12.3 带符号整数的除法与余数. . . . . . . . . . . . . . . . . . . . . . . . . . . 514
12.3.1 语言标准怎么说. . . . . . . . . . . . . . . . . . . . . . . . . . . . 515
12.3.2 C/C++ 编译器的表现. . . . . . . . . . . . . . . . . . . . . . . . . 516
12.3.3 其他语言的规定. . . . . . . . . . . . . . . . . . . . . . . . . . . . 516
12.3.4 脚本语言解释器代码. . . . . . . . . . . . . . . . . . . . . . . . . 517
12.3.5 硬件实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521
12.4 在单元测试中mock 系统调用. . . . . . . . . . . . . . . . . . . . . . . . 522
12.4.1 系统函数的依赖注入. . . . . . . . . . . . . . . . . . . . . . . . . 522
12.4.2 链接期垫片（link seam） . . . . . . . . . . . . . . . . . . . . . . 524
12.5 慎用匿名namespace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 526
12.5.1 C 语言的static 关键字的两种用法. . . . . . . . . . . . . . . . . 526
12.5.2 C++ 语言的static 关键字的四种用法. . . . . . . . . . . . . . . . 526
12.5.3 匿名namespace 的不利之处. . . . . . . . . . . . . . . . . . . . . 527
12.5.4 替代办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 529
12.6 采用有利于版本管理的代码格式. . . . . . . . . . . . . . . . . . . . . . . 529
12.6.1 对diff 友好的代码格式. . . . . . . . . . . . . . . . . . . . . . . . 530
12.6.2 对grep 友好的代码风格. . . . . . . . . . . . . . . . . . . . . . . 537
12.6.3 一切为了效率. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 538
12.7 再探std::string . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539
12.7.1 直接拷贝（eager copy） . . . . . . . . . . . . . . . . . . . . . . . 540
12.7.2 写时复制（copy-on-write） . . . . . . . . . . . . . . . . . . . . . 542
12.7.3 短字符串优化（SSO） . . . . . . . . . . . . . . . . . . . . . . . . 543
12.8 用STL algorithm 轻松解决几道算法面试题. . . . . . . . . . . . . . . . 546
12.8.1 用next_permutation() 生成排列与组合. . . . . . . . . . . . . . 546
12.8.2 用unique() 去除连续重复空白. . . . . . . . . . . . . . . . . . . 548
12.8.3 用{make,push,pop}_heap() 实现多路归并. . . . . . . . . . . . 549
12.8.4 用partition() 实现“重排数组，让奇数位于偶数前面” . . . . 553
12.8.5 用lower_bound() 查找IP 地址所属的城市. . . . . . . . . . . . . 554
第4 部分附录559
附录A 谈一谈网络编程学习经验561
附录B 从《C++ Primer（第4 版）》入手学习C++ 579
附录C 关于Boost 的看法591
附录D 关于TCP 并发连接的几个思考题与试验593
参考文献599
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux多线程服务端编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>图解Java多线程设计模式
序章1　Java线程　　1
I1.1　Java线程　　2
I1.2　何谓线程　　2
明为跟踪处理流程，实为跟踪线程　　2
单线程程序　　3
多线程程序　　4
Thread类的run方法和start方法　　5
I1.3　线程的启动　　9
线程的启动（1）——利用Thread类的子类　　9
线程的启动（2）——利用Runnable接口　　10
I1.4　线程的暂停　　12
I1.5　线程的互斥处理　　13
synchronized方法　　14
synchronized代码块　　17
I1.6　线程的协作　　18
等待队列——线程休息室　　19
wait方法——将线程放入等待队列　　19
notify方法——从等待队列中取出线程　　21
notifyAll方法——从等待队列中取出所有线程　　23
wait、notify、notifyAll是Object类的方法　　24
I1.7　线程的状态迁移　　24
I1.8　线程相关的其他话题　　26
I1.9　本章所学知识　　26
I1.10　　练习题　　26
序章2　多线程程序的评价标准　　31
I2.1　多线程程序的评价标准　　32
安全性——不损坏对象　　32
生存性——必要的处理能够被执行　　32
可复用性——类可重复利用　　33
性能——能快速、大批量地执行处理　　33
评价标准总结　　33
I2.2　本章所学知识　　34
I2.3　练习题　　34
第1章　　Single Threaded Execution模式——能通过这座桥的只有一个人　　35
1.1　Single Threaded Execution模式　　36
1.2　示例程序1：不使用Single Threaded Execution模式的程序　　36
Main类　　37
非线程安全的Gate类　　37
UserThread类　　38
执行起来看看……出错了　　39
为什么会出错呢　　40
1.3　示例程序2：使用Single Threaded Execution模式的程序　　41
线程安全的Gate类　　41
synchronized的作用　　42
1.4　Single Threaded Execution模式中的登场角色　　43
1.5　拓展思路的要点　　44
何时使用（可使用Single Threaded Execution模式的情况）　　44
生存性与死锁　　45
可复用性和继承反常　　46
临界区的大小和性能　　46
1.6　相关的设计模式　　47
Guarded Suspension模式　　47
Read-Write Lock模式　　47
Immutable模式　　47
Thread-Specific Storage模式　　48
1.7　延伸阅读1：关于synchronized　　48
synchronized语法与Before/After模式　　48
synchronized在保护着什么　　49
该以什么单位来保护呢　　50
使用哪个锁保护　　50
原子操作　　51
long与double的操作不是原子的　　51
1.8　延伸阅读2：java.util.concurrent包和计数信号量　　52
计数信号量和Semaphore类　　52
使用Semaphore类的示例程序　　52
1.9　本章所学知识　　55
1.10　　练习题　　55
第2章　　Immutable模式——想破坏也破坏不了　　61
2.1　Immutable模式　　62
2.2　示例程序　　62
使用Immutable模式的Person类　　62
Main类　　63
PrintPersonThread类　　63
2.3　Immutable模式中的登场角色　　65
2.4　拓展思路的要点　　66
何时使用（可使用Immutable模式的情况）　　66
考虑成对的mutable类和immutable类 [性能]　　66
为了确保不可变性 [可复用性]　　67
标准类库中用到的Immutable模式　　67
2.5　相关的设计模式　　69
Single Threaded Execution模式　　69
Read-Write Lock模式　　69
Flyweight模式　　69
2.6　延伸阅读1：final　　69
final的含义　　69
2.7　延伸阅读2：集合类与多线程　　71
示例1：非线程安全的java.util.ArrayList类　　71
示例2：利用Collections.synchronizedList方法所进行的同步　　74
示例3：使用copy-on-write的java.util.concurrent.CopyOnWriteArrayList类　　75
2.8　本章所学知识　　76
2.9　练习题　　77
第3章　　Guarded Suspension模式——等我准备好哦　　81
3.1　Guarded Suspension模式　　82
3.2　示例程序　　82
Request类　　83
RequestQueue类　　84
ClientThread类　　85
ServerThread类　　85
Main类　　86
java.util.Queue与java.util.LinkedList的操作　　87
getRequest详解　　87
putRequest详解　　89
synchronized的含义　　89
wait与锁　　89
3.3　Guarded Suspension模式中的登场角色　　90
3.4　拓展思路的要点　　91
附加条件的synchronized　　91
多线程版本的if　　91
忘记改变状态与生存性　　91
wait与notify/notifyAll的责任 [可复用性]　　91
各种称呼　　91
使用java.util.concurrent.LinkedBlockingQueue的示例程序　　93
3.5　相关的设计模式　　94
Single Threaded Execution模式　　94
Balking模式　　94
Producer-Consumer模式　　94
Future模式　　94
3.6　本章所学知识　　95
3.7　练习题　　95
第4章　　Balking模式——不需要就算了　　99
4.1　Balking模式　　100
4.2　示例程序　　100
Data类　　100
SaverThread类　　102
ChangerThread类　　102
Main类　　103
4.3　Balking模式中的登场角色　　105
4.4　拓展思路的要点　　106
何时使用（可使用Balking模式的情况）　　106
balk结果的表示方式　　107
4.5　相关的设计模式　　107
Guarded Suspension模式　　107
Observer模式　　107
4.6　延伸阅读：超时　　108
Balking模式和Guarded Suspension模式之间　　108
wait何时终止呢　　108
guarded timed的实现（使用wait）　　109
synchronized中没有超时，也不能中断　　110
java.util.concurrent中的超时　　111
4.7　本章所学知识　　111
4.8　练习题　　112
第5章　　Producer-Consumer模式——我来做，你来用　　115
5.1　Producer-Consumer模式　　116
5.2　示例程序　　116
Main类　　116
MakerThread类　　117
EaterThread类　　118
Table类　　118
解读put方法　　120
解读take方法　　121
5.3　Producer-Consumer模式中的登场角色　　122
5.4　拓展思路的要点　　123
守护安全性的Channel角色（可复用性）　　123
不可以直接传递吗　　124
Channel角色的剩余空间所导致的问题　　124
以什么顺序传递Data角色呢　　125
“存在中间角色”的意义　　125
Consumer角色只有一个时会怎么样呢　　126
5.5　相关的设计模式　　126
Mediator模式　　126
Worker Thread模式　　126
Command模式　　126
Strategy模式　　127
5.6　延伸阅读1：理解InterruptedException异常　　127
可能会花费时间，但可以取消　　127
加了throws InterruptedException的方法　　127
sleep方法和interrupt方法　　128
wait方法和interrupt方法　　128
join方法和interrupt方法　　129
interrupt方法只是改变中断状态　　129
isInterrupted方法——检查中断状态　　130
Thread.interrupted方法——检查并清除中断状态　　130
不可以使用Thread类的stop方法　　130
5.7　延伸阅读2：java.util.concurrent包和Producer-Consumer模式　　131
java.util.concurrent包中的队列　　131
使用java.util.concurrent.ArrayBlockingQueue的示例程序　　132
使用java.util.concurrent.Exchanger类交换缓冲区　　133
5.8　本章所学知识　　136
5.9　练习题　　137
第6章　　Read-Write Lock模式——大家一起读没问题，但读的时候不要写哦　　141
6.1　Read-Write Lock模式　　142
6.2　示例程序　　142
Main类　　143
Data类　　143
WriterThread类　　146
ReaderThread类　　146
ReadWriteLock类　　147
执行起来看看　　149
守护条件的确认　　150
6.3　Read-Write Lock模式中的登场角色　　151
6.4　拓展思路的要点　　153
利用“读取”操作的线程之间不会冲突的特性来提高程序性能　　153
适合读取操作繁重时　　153
适合读取频率比写入频率高时　　153
锁的含义　　153
6.5　相关的设计模式　　154
Immutable模式　　154
Single Threaded Execution模式　　154
Guarded Suspension模式　　154
Before/After模式　　154
Strategized Locking模式　　154
6.6　延伸阅读：java.util.concurrent.locks包和Read-Write Lock模式　　154
java.util.concurrent.locks包　　154
使用java.util.concurrent.locks的示例程序　　155
6.7　本章所学知识　　156
6.8　练习题　　157
第7章　　Thread-Per-Message模式——这项工作就交给你了　　163
7.1　Thread-Per-Message模式　　164
7.2　示例程序　　164
Main类　　164
Host类　　165
Helper类　　166
7.3　Thread-Per-Message模式中的登场角色　　168
7.4　拓展思路的要点　　169
提高响应性，缩短延迟时间　　169
适用于操作顺序没有要求时　　169
适用于不需要返回值时　　169
应用于服务器　　169
调用方法＋启动线程→发送消息　　170
7.5　相关的设计模式　　170
Future模式　　170
Worker Thread模式　　170
7.6　延伸阅读1：进程与线程　　171
7.7　延伸阅读2：java.util.concurrent包和Thread-Per-Message模式　　171
java.lang.Thread类　　171
java.lang.Runnable接口　　172
java.util.concurrent.ThreadFactory接口　　173
java.util.concurrent.Executors类获取的ThreadFactory　　174
java.util.concurrent.Executor接口　　175
java.util.concurrent.ExecutorService接口　　176
java.util.concurrent.ScheduledExecutorService类　　177
总结　　178
7.8　本章所学知识　　180
7.9　练习题　　180
第8章　　Worker Thread模式——工作没来就一直等，工作来了就干活　　187
8.1　Worker Thread模式　　188
8.2　示例程序　　188
Main类　　189
ClientThread类　　190
Request类　　190
Channel类　　191
WorkerThread类　　192
8.3　Worker Thread模式中的登场角色　　193
8.4　拓展思路的要点　　195
提高吞吐量　　195
容量控制　　195
调用与执行的分离　　196
Runnable接口的意义　　197
多态的Request角色　　198
独自一人的Worker角色　　199
8.5　相关的设计模式　　199
Producer-Consumer模式　　199
Thread-Per-Message模式　　199
Command模式　　199
Future模式　　199
Flyweight模式　　199
Thread-Specific Storage模式　　200
Active Ojbect模式　　200
8.6　延伸阅读1：Swing事件分发线程　　200
什么是事件分发线程　　200
事件分发线程只有一个　　200
事件分发线程调用监听器　　201
注册监听器的意义　　201
事件分发线程也负责绘制界面　　201
javax.swing.SwingUtilities类　　202
Swing的单线程规则　　203
8.7　延伸阅读2：java.util.concurrent包和Worker Thread模式　　204
ThreadPoolExecutor类　　204
通过java.util.concurrent包创建线程池　　205
8.8　本章所学知识　　207
8.9　练习题　　208
第9章　　Future模式——先给您提货单　　211
9.1　Future模式　　212
9.2　示例程序　　212
Main类　　214
Host类　　214
Data接口　　215
FutureData类　　216
RealData类　　217
9.3　Future模式中的登场角色　　218
9.4　拓展思路的要点　　219
吞吐量会提高吗　　219
异步方法调用的“返回值”　　220
“准备返回值”和“使用返回值”的分离　　220
变种——不让主线程久等的Future角色　　220
变种——会发生变化的Future角色　　221
谁会在意多线程呢？“可复用性”　　221
回调与Future模式　　221
9.5　相关的设计模式　　222
Thread-Per-Message模式　　222
Builder模式　　222
Proxy模式　　222
Guarded Suspension模式　　222
Balking模式　　222
9.6　延伸阅读：java.util.concurrent包与Future模式　　222
java.util.concurrent包　　222
使用了java.util.concurrent包的示例程序　　223
9.7　本章所学知识　　226
9.8　练习题　　226
第10章　　Two-Phase Termination模式——先收拾房间再睡觉　　231
10.1　Two-Phase Termination模式　　232
10.2　示例程序　　233
CountupThread类　　234
Main类　　236
10.3　Two-Phase Termination模式中的登场角色　　237
10.4　拓展思路的要点　　238
不能使用Thread类的stop方法　　238
仅仅检查标志是不够的　　239
仅仅检查中断状态是不够的　　239
在长时间处理前检查终止请求　　239
join方法和isAlive方法　　240
java.util.concurrent.ExecutorService接口与Two-Phase Termination模式　　240
要捕获程序整体的终止时　　241
优雅地终止线程　　243
10.5　相关的设计模式　　243
Before/After模式　　243
Multiphase Cancellation模式　　243
Multi-Phase Startup模式　　244
Balking模式　　244
10.6　延伸阅读1：中断状态与InterruptedException异常的相互转换　　244
中断状态→InterruptedException异常的转换　　244
InterruptedException异常→中断状态的转换　　245
InterruptedException异常→InterruptedException异常的转换　　245
10.7　延伸阅读2：java.util.concurrent包与线程同步　　246
java.util.concurrent.CountDownLatch类　　246
java.util.concurrent.CyclicBarrier类　　249
10.8　本章所学知识　　253
10.9　练习题　　253
第11章　　Thread-Specific Storage模式——一个线程一个储物柜　　263
11.1　Thread-Specific Storage模式　　264
11.2　关于java.lang.ThreadLocal类　　264
java.lang.ThreadLocal就是储物间　　264
java.lang.ThreadLocal与泛型　　265
11.3　示例程序1：不使用Thread-Specific Storage模式的示例　　265
Log类　　266
Main类　　266
11.4　示例程序2：使用了Thread-Specific Storage模式的示例　　267
线程特有的TSLog类　　268
Log类　　269
ClientThread类　　270
Main类　　271
11.5　Thread-Specific Storage模式中的登场角色　　272
11.6　拓展思路的要点　　274
局部变量与java.lang.ThreadLocal类　　274
保存线程特有的信息的位置　　275
不必担心其他线程访问　　275
吞吐量的提高很大程序上取决于实现方式　　276
上下文的危险性　　276
11.7　相关的设计模式　　277
Singleton模式　　277
Worker Thread模式　　277
Single Threaded Execution模式　　277
Proxy模式　　277
11.8　延伸阅读：基于角色与基于任务　　277
主体与客体　　277
基于角色的考虑方式　　278
基于任务的考虑方式　　278
实际上两种方式是综合在一起的　　279
11.9　本章所学知识　　279
11.10　　练习题　　280
第12章　　Active Object模式——接收异步消息的主动对象　　283
12.1　Active Object模式　　284
12.2　示例程序1　284
调用方：Main类　　287
调用方：MakerClientThread类　　288
调用方：DisplayClientThread类　　289
主动对象方：ActiveObject接口　　289
主动对象方：ActiveObjectFactory类　　290
主动对象方：Proxy类　　290
主动对象方：SchedulerThread类　　291
主动对象方：ActivationQueue类　　292
主动对象方：MethodRequest类　　293
主动对象方：MakeStringRequest类　　294
主动对象方：DisplayStringRequest类　　295
主动对象方：Result类　　295
主动对象方：FutureResult类　　296
主动对象方：RealResult类　　296
主动对象方：Servant类　　297
示例程序1的运行　　297
12.3　ActiveObject模式中的登场角色　　298
12.4　拓展思路的要点　　304
到底做了些什么事情　　304
运用模式时需要考虑问题的粒度　　304
关于并发性　　304
增加方法　　305
Scheduler角色的作用　　305
主动对象之间的交互　　306
通往分布式——从跨越线程界线变为跨越计算机界线　　306
12.5　相关的设计模式　　306
Producer-Consumer模式　　306
Future模式　　307
Worker Thread模式　　307
Thread-Specific Storage模式　　307
12.6　延伸阅读：java.util.concurrent包与Active Object模式　　307
类与接口　　307
调用方：Main类　　309
调用方：MakerClientThread类　　309
调用方：DisplayClientThread类　　310
主动对象方：ActiveObject接口　　311
主动对象方：ActiveObjectFactory类　　311
主动对象：ActiveObjectImpl类　　312
示例程序2的运行　　313
12.7　本章所学知识　　314
12.8　练习题　　315
第13章　　总结——多线程编程的模式语言　　321
13.1　多线程编程的模式语言　　322
模式与模式语言　　322
13.2　Single Threaded Execution模式
——能通过这座桥的只有一个人　　323
13.3　Immutable模式
——想破坏也破坏不了　　324
13.4　Guarded Suspension模式
——等我准备好哦　　325
13.5　Balking模式
——不需要就算了　　326
13.6　Producer-Consumer模式
——我来做，你来用　　327
13.7　Read-Write Lock模式
——大家一起读没问题，但读的时候不要写哦　　328
13.8　Thread-Per-Message模式
——这项工作就交给你了　　329
13.9　Worker Thread模式
——工作没来就一直等，工作来了就干活　　330
13.10　　Future模式
——先给您提货单　　330
13.11　Two-Phase Termination模式
——先收拾房间再睡觉　　331
13.12　Thread-Specific Storage模式
——一个线程一个储物柜　　332
13.13　Active Object模式
——接收异步消息的主动对象　　333
13.14　写在最后　　335
附录　　337
附录A　习题解答　　338
附录B　Java内存模型　　447
附录C　Java线程的优先级　　467
附录D　线程相关的主要API　　469
附录E　java.util.concurrent包　　475
附录F　示例程序的运行步骤　　483
附录G　参考文献　　485
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>图解Java多线程设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Objective-C高级编程
第1章 自动引用计数　　1
1.1 　什么是自动引用计数　　2
1.2 　内存管理/引用计数　　2
1.2.1 　概要　　2
1.2.2 　内存管理的思考方式　　5
1.2.3 　alloc/retain/release/dealloc实现　　13
1.2.4 　苹果的实现　　17
1.2.5 　autorelease　　20
1.2.6 　autorelease实现　　24
1.2.7 　苹果的实现　　26
1.3 　ARC规则　　29
1.3.1 　概要　　29
1.3.2 　内存管理的思考方式　　30
1.3.3 　所有权修饰符　　30
1.3.4 　规则　　50
1.3.5 　属性　　62
1.3.6 　数组　　63
1.4 　ARC的实现　　65
1.4.1 　__strong修饰符　　65
1.4.2 　__weak修饰符　　67
1.4.3 　__autoreleasing修饰符　　75
1.4.4 　引用计数　　76
第2章 Blocks　　79
2.1 　Blocks概要　　80
2.1.1 　什么是Blocks　　80
2.2 　Blocks模式　　83
2.2.1 　Block语法　　83
2.2.2 　Block类型变量　　85
2.2.3 　截获自动变量值　　88
2.2.4 　__block说明符　　88
2.2.5 　截获的自动变量　　89
2.3 　Blocks的实现　　91
2.3.1 　Block的实质　　91
2.3.2 　截获自动变量值　　99
2.3.3 　__block说明符　　102
2.3.4 　Block存储域　　108
2.3.5 　__block变量存储域　　117
2.3.6 　截获对象　　121
2.3.7 　__block变量和对象　　126
2.3.8 　Block循环引用　　128
2.3.9 　copy/release　　134
第3章 Grand Central Dispatch　　137
3.1 　Grand Central Dispatch（GCD）概要　　138
3.1.1 　什么是GCD　　138
3.1.2 　多线程编程　　140
3.2 　GCD的API　　144
3.2.1 　Dispatch Queue　　144
3.2.2 　dispatch_queue_create　　147
3.2.3 　Main Dispatch Queue/Global Dispatch Queue　　150
3.2.4 　dispatch_set_target_queue　　153
3.2.5 　dispatch_after　　154
3.2.6 　Dispatch Group　　155
3.2.7 　dispatch_barrier_async　　157
3.2.8 　dispatch_sync　　160
3.2.9 　dispatch_apply　　161
3.2.10 　dispatch_suspend / dispatch_resume　　163
3.2.11 　Dispatch Semaphore　　164
3.2.12 　dispatch_once　　166
3.2.13 　Dispatch I/O　　167
3.3 　GCD实现　　169
3.3.1 　Dispatch Queue　　169
3.3.2 　Dispatch Source　　171
附录A 　ARC、Blocks、GCD使用范例　　176
附录B 　参考资料　　182
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Objective-C高级编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程核心技术
前 言
第1章 Java多线程技能，
1.1 进程和多线程的概念及线程的优点
1.2 使用多线程
1.2.1 继承Thread类
1.2.2 实现Runnable接口
1.2.3 实例变量与线程安全
1.2.4 留意i——与System.out.println（）的异常
1.3 currentThread（）方法
1.4 isAlive（）方法
1.5 sleep（）方法
1.6 getId（）方法
1.7 停止线程
1.7.1 停止不了的线程
1.7.2 判断线程是否是停止状态
1.7.3 能停止的线程——异常法
1.7.4 在沉睡中停止
1.7.5 能停止的线程——暴力停止
1.7.6 方法stop（）与java.lang.ThreadDeath异常
1.7.7 释放锁的不良后果
1.7.8 使用return停止线程
1.8 暂停线程
1.8.1 suspend与resume方法的使用
1.8.2 suspend与resume方法的缺点——独占
1.8.3 suspend与resume方法的缺点——不同步
1.9 yield方法
1.10 线程的优先级
1.10.1 线程优先级的继承特性
1.10.2 优先级具有规则性
1.10.3 优先级具有随机性
1.10.4 看谁运行得快
1.11 守护线程
1.12 本章小结
第2章 对象及变量的并发访问
2.1 synchronized同步方法
2.1.1 方法内的变量为线程安全
2.1.2 实例变量非线程安全
2.1.3 多个对象多个锁
2.1.4 synchronized方法与锁对象
2.1.5 脏读
2.1.6 synchronized锁重入
2.1.7 出现异常，锁自动释放
2.1.8 同步不具有继承性
2.2 synchronized同步语句块
2.2.1 synchronized方法的弊端
2.2.2 synchronized同步代码块的使用
2.2.3 用同步代码块解决同步方法的弊端
2.2.4 一半异步，一半同步
2.2.5 synchronized代码块间的同步性
2.2.6 验证同步synchronized（this）代码块是锁定当前对象的
2.2.7 将任意对象作为对象监视器
2.2.8 细化验证3个结论
2.2.9 静态同步synchronized方法与synchronized（class）代码块
2.2.10 数据类型String的常量池特性
2.2.11 同步synchronized方法无限等待与解决
2.2.12 多线程的死锁
2.2.13 内置类与静态内置类
2.2.14 内置类与同步：实验1
2.2.15 内置类与同步：实验2
2.2.16 锁对象的改变
2.3 volatile关键字
2.3.1 关键字volatile与死循环
2.3.2 解决同步死循环
2.3.3 解决异步死循环
2.3.4 volatile非原子的特性
2.3.5 使用原子类进行i++操作
2.3.6 原子类也并不完全安全
2.3.7 synchronized代码块有volatile同步的功能
2.4 本章总结
第3章 线程间通信
3.1 等待/通知机制
3.1.1 不使用等待/通知机制实现线程间通信
3.1.2 什么是等待/通知机制
3.1.3 等待/通知机制的实现
3.1.4 方法wait（）锁释放与notify（）锁不释放
3.1.5 当interrupt方法遇到wait方法
3.1.6 只通知一个线程
3.1.7 唤醒所有线程
3.1.8 方法wait（long）的使用
3.1.9 通知过早
3.1.10 等待wait的条件发生变化
3.1.11 生产者/消费者模式实现
3.1.12 通过管道进行线程间通信：字节流
3.1.13 通过管道进行线程间通信：字符流
3.1.14 实战：等待/通知之交叉备份
3.2 方法join的使用
3.2.1 学习方法join前的铺垫
3.2.2 用join（）方法来解决
3.2.3 方法join与异常
3.2.4 方法join（long）的使用
3.2.5 方法join（long）与sleep（long）的区别
3.2.6 方法join（）后面的代码提前运行：出现意外
3.2.7 方法join（）后面的代码提前运行：解释意外
3.3 类ThreadLocal的使用
3.3.1 方法get（）与null
3.3.2 验证线程变量的隔离性
3.3.3 解决get（）返回null问题
3.3.4 再次验证线程变量的隔离性
3.4 类InheritableThreadLocal的使用
3.4.1 值继承
3.4.2 值继承再修改
3.5 本章总结
第4章 Lock的使用
4.1 使用ReentrantLock类
4.1.1 使用ReentrantLock实现同步：测试1
4.1.2 使用ReentrantLock实现同步：测试2
4.1.3 使用Condition实现等待/通知错误用法与解决
4.1.4 正确使用Condition实现等待/通知
4.1.5 使用多个Condition实现通知部分线程：错误用法
4.1.6 使用多个Condition实现通知部分线程：正确用法
4.1.7 实现生产者/消费者模式：一对一交替打印
4.1.8 实现生产者/消费者模式：多对多交替打印
4.1.9 公平锁与非公平锁
4.1.10 方法getHoldCount（）、getQueueLength（）和getWaitQueueLength（）的测试
4.1.11 方法hasQueuedThread（）、hasQueuedThreads（）和hasWaiters（）的测试
4.1.12 方法isFair（）、isHeldByCurrentThread（）和isLocked（）的测试
4.1.13 方法lockInterruptibly（）、tryLock（）和tryLock（long timeout，TimeUnit unit）的测试
4.1.14 方法awaitUninterruptibly（）的使用
4.1.15 方法awaitUntil（）的使用
4.1.16 使用Condition实现顺序执行
4.2 使用ReentrantReadWriteLock类
4.2.1 类ReentrantReadWriteLock的使用：读读共享
4.2.2 类ReentrantReadWriteLock的使用：写写互斥
4.2.3 类ReentrantReadWriteLock的使用：读写互斥
4.2.4 类ReentrantReadWriteLock的使用：写读互斥
4.3 本章总结
第5章 定时器Timer
5.1 定时器Timer的使用
5.1.1 方法schedule（TimerTask task， Date time）的测试
5.1.2 方法schedule（TimerTask task， Date firstTime， long period）的测试
5.1.3 方法schedule（TimerTask task， long delay）的测试
5.1.4 方法schedule（TimerTask task， long delay， long period）的测试
5.1.5 方法scheduleAtFixedRate（TimerTask task， Date firstTime， long period）的测试
5.2 本章总结
第6章 单例模式与多线程
6.1 立即加载/"饿汉模式"
6.2 延迟加载/"懒汉模式"
6.3 使用静态内置类实现单例模式
6.4 序列化与反序列化的单例模式实现
6.5 使用static代码块实现单例模式
6.6 使用enum枚举数据类型实现单例模式
6.7 完善使用enum枚举实现单例模式
6.8 本章总结
第7章 拾遗增补
7.1 线程的状态
7.1.1 验证NEW、RUNNABLE和TERMINATED
7.1.2 验证TIMED_WAITING
7.1.3 验证BLOCKED
7.1.4 验证WAITING
7.2 线程组
7.2.1 线程对象关联线程组：1级关联
7.2.2 线程对象关联线程组：多级关联
7.2.3 线程组自动归属特性
7.2.4 获取根线程组
7.2.5 线程组里加线程组
7.2.6 组内的线程批量停止
7.2.7 递归与非递归取得组内对象
7.3 使线程具有有序性
7.4 SimpleDateFormat非线程安全
7.4.1 出现异常
7.4.2 解决异常方法1
7.4.3 解决异常方法2
7.5 线程中出现异常的处理
7.6 线程组内处理异常
7.7 线程异常处理的传递
7.8 本章总结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程核心技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Unity游戏设计与实现
第0章　Unity概要　　1
0.1　Unity基础　Concept　　2
0.1.1　脚本一览　　2
0.1.2　本章小节　　2
0.1.3　本章开发的小游戏　　2
0.2　入门教程（上）——创建项目　Tips　　3
0.2.1　概要　　3
0.2.2　创建新项目　　3
0.2.3　创建地面（创建游戏对象）　　4
0.2.4　创建场景，保存项目　　5
0.2.5　让地面围绕原点移动　　7
0.2.6　调整场景视图的摄像机　　8
0.2.7　创建方块和小球（创建游戏对象并调整坐标）　　9
0.2.8　运行游戏　　12
0.2.9　模拟物理运动（添加Rigidbody组件）　　12
0.2.10　让小方块跳起来（添加游戏脚本）　　13
0.2.11　修改游戏对象的名字　　17
0.2.12　修改游戏对象的颜色（创建材质）　　17
0.2.13　让画面更明亮（创建光源）　　19
0.2.14　调整游戏画面的尺寸（调整播放器设置）　　19
0.2.15　小结　　21
0.3　入门教程（下）——让游戏更有趣　Tips　　21
0.3.1　概要　　21
0.3.2　让小球飞起来（物理运动和速度）　　21
0.3.3　创建大量小球（预设游戏对象）　　23
0.3.4　整理项目视图　　24
0.3.5　发射小球（通过脚本创建游戏对象）　　26
0.3.6　删除画面外的小球（通过脚本删除游戏对象）　　29
0.3.7　防止小方块在空中起跳（发生碰撞时的处理）　　30
0.3.8　禁止小方块旋转（抑制旋转）　　32
0.3.9　让小方块不被弹开（设置重量）　　33
0.3.10　让小球强烈反弹（设置物理材质）　　34
0.3.11　消除“漂浮感”（调整重力大小）　　36
0.3.12　调整摄像机的位置　　37
0.3.13　修复空中起跳的bug（区分碰撞对象）　　39
0.3.14　小结　　44
0.4　C#和JavaScript的对比　Tips　　44
0.4.1　概要　　44
0.4.2　类的定义　　45
0.4.3　变量定义　　45
0.4.4　函数的定义　　46
0.4.5　作用域　　47
0.4.6　静态函数和静态变量的定义　　47
0.4.7　范型方法的调用　　47
0.4.8　Bool类型和字符串类型　　48
0.4.9　数组　　48
0.4.10　小结　　48
0.5　关于预设　Tips　　48
0.5.1　概要　　48
0.5.2　改良“小方块”游戏对象　　48
0.5.3　预设与对象实例　　50
0.5.4　预设和实例的变更　　51
0.5.5　小结　　53
第1章　点击动作游戏——怪物　　55
1.1　玩法介绍　How to Play　　56
1.2　简单的操作和爽快感　Concept　　58
1.2.1　脚本一览　　58
1.2.2　本章小节　　60
1.3　无限滚动的背景　Tips　　60
1.3.1　关联文件　　60
1.3.2　概要　　60
1.3.3　背景组件的显示位置　　61
1.3.4　小结　　63
1.4　无限滚动的背景的改良　Tips　　63
1.4.1　关联文件　　63
1.4.2　概要　　64
1.4.3　稍作尝试　　64
1.4.4　背景组件显示位置的改良　　65
1.4.5　小结　　67
1.5　怪物出现模式的管理　Tips　　67
1.5.1　关联文件　　67
1.5.2　概要　　67
1.5.3　怪物出现的时间点　　68
1.5.4　怪物出现模式的变化　　70
1.5.5　小结　　74
1.6　武士和怪物的碰撞检测　Tips　　74
1.6.1　关联文件　　74
1.6.2　概要　　74
1.6.3　分别对各个怪物进行碰撞检测的问题　　75
1.6.4　把怪物编成小组　　76
1.6.5　小结　　78
1.7　得分高低的判定　Tips　　78
1.7.1　概要　　78
1.7.2　武士的攻击判定　　78
1.7.3　判断在多近的距离斩杀　　79
1.7.4　小结　　82
1.8　使被砍中的怪物向四处飞散　Tips　　82
1.8.1　概要　　82
1.8.2　想象一下“圆锥体”　　82
1.8.3　具体的计算方法　　84
1.8.4　小结　　86
第2章　拼图游戏——迷你拼图　 87
2.1　玩法介绍　How to Play　　88
排列拼图碎片，拼出最后的图案！　　88
2.2　流畅的拖曳操作　Concept　　90
2.2.1　脚本一览　　90
2.2.2　本章小节　　90
2.3　点住碎片的任意位置拖动　Tips　　92
2.3.1　关联文件　　92
2.3.2　概要　　92
2.3.3　透视变换和逆透视变换　　92
2.3.4　被点击处即为光标的位置　　92
2.3.5　测试拖曳碎片的中心　　95
2.3.6　小结　　96
2.4　打乱拼图碎片　Tips　　96
2.4.1　关联文件　　96
2.4.2　概要　　96
2.4.3　设置拼图碎片的坐标为随机数　　96
2.4.4　改进策略　　97
2.4.5　小结　　102
2.5　游戏对象和组件的关系　Tips　　102
2.5.1　关联文件　　102
2.5.2　概要　　102
2.5.3　虚拟形象（游戏对象）和定制（组件）　　103
2.5.4　“this”是什么　　105
2.5.5　GetComponent<>()的缩写　　106
2.5.6　删除GameObject　　108
2.5.7　迷你拼图的应用实例　　108
2.5.8　小结　　110
第3章　吃豆游戏——地牢吞噬者　　111
3.1　玩法介绍　How to Play　　112
3.2　适时进退和逆转的机会　Concept　　114
3.2.1　脚本一览　　114
3.2.2　本章小节　　116
3.3　平滑的网格移动　Tips　　116
3.3.1　关联文件　　116
3.3.2　概要　　116
3.3.3　能够改变方向的时机　　117
3.3.4　穿过网格的时机　　117
3.3.5　小结　　119
3.4　地图数据　Tips　　120
3.4.1　关联文件　　120
3.4.2　概要　　120
3.4.3　文本文件的格式　　120
3.4.4　扩展编辑器的功能　　125
3.4.5　小结　　127
3.5　动画的小技巧　Tips　　127
3.5.1　关联文件　　127
3.5.2　概要　　127
3.5.3　身体各部位的动画　　128
3.5.4　根据事件播放音效　　129
3.5.5　小结　　131
3.6　幽灵的AI　Tips　　131
3.6.1　关联文件　　131
3.6.2　概要　　131
3.6.3　跟踪的算法　　131
3.6.4　埋伏等待型、包围攻击型和随机型　　135
3.6.5　观察幽灵的行动　　137
3.6.6　小结　　138
第4章　3D声音探索游戏——In the Dark Water　　139
4.1　玩法介绍　How to Play　　140
4.2　只依靠声音　Concept　　142
4.2.1　脚本一览　　142
4.2.2　本章小节　　144
4.3　仅依靠声音定位　Tips　　144
4.3.1　概要　　144
4.3.2　3D声音的特性　　144
4.3.3　用于实验的项目　　146
4.3.4　小结　　147
4.4　3D声音的控制　Tips　　147
4.4.1　关联文件　　147
4.4.2　概要　　147
4.4.3　3D声音的设置　　147
4.4.4　按一定间隔发出声音　　148
4.4.5　声音的淡出　　149
4.4.6　小结　　150
4.5　潜水艇的操纵　Tips　　151
4.5.1　关联文件　　151
4.5.2　概要　　151
4.5.3　操作方法　　151
4.5.4　转弯速度的衰减　　153
4.5.5　小结　　157
4.6　声纳的制作方法　Tips　　157
4.6.1　概要　　157
4.6.2　Prespective和Ortho　　158
4.6.3　“Dark Water”的声纳摄像机　　159
4.6.4　摄像机和对象的层　　160
4.6.5　稍作尝试　　163
4.6.6　摄像机的视口　　164
4.6.7　小结　　165
第5章　节奏游戏——摇滚女孩　　167
5.1　玩法介绍　How to Play　　168
5.2　Band-girl的世界　Concept　　169
5.2.1　脚本一览　　170
5.2.2　本章小节　　170
5.3　显示点击时刻的节拍标记　Tips　　172
5.3.1　关联文件　　172
5.3.2　概要　　172
5.3.3　定位单元　　172
5.3.4　标记的显示　　175
5.3.5　小结　　178
5.4　判断是否配合了音乐点击　Tips　　178
5.4.1　关联文件　　178
5.4.2　概要　　178
5.4.3　得分高低的判断　　178
5.4.4　避免重复判断　　180
5.4.5　小结　　185
5.5　演出数据的管理和执行　Tips　　185
5.5.1　关联文件　　185
5.5.2　概要　　185
5.5.3　事件数据的检索　　185
5.5.4　定位单元和执行单元　　187
5.5.5　小结　　191
5.6　其他调整功能　Tips　　191
5.6.1　关联文件　　191
5.6.2　概要　　191
5.6.3　什么是“turn around”　　192
5.6.4　显示时刻的偏移值　　192
5.6.5　定位条　　194
5.6.6　显示标记的行号　　196
5.6.7　小结　　196
第6章　全方位滚动射击游戏——噬星者　　197
6.1　玩法介绍　How to Play　　198
6.2　功能强大的激光制导　Concept　　199
6.2.1　脚本一览　　200
6.2.2　本章小节　　200
6.3　索敌激光的碰撞检测　Tips　　202
6.3.1　关联文件　　202
6.3.2　概要　　202
6.3.3　索敌激光的碰撞检测　　202
6.3.4　碰撞网格的生成方法　　204
6.3.5　确认碰撞网格　　209
6.3.6　小结　　209
6.4　不会重复的锁定　Tips　　210
6.4.1　关联文件　　210
6.4.2　概要　　210
6.4.3　锁定的管理　　210
6.4.4　小结　　213
6.5　制导激光　Tips　　213
6.5.1　关联文件　　213
6.5.2　概要　　213
6.5.3　根据TrailRenderer生成网格　　213
6.5.4　制导激光的移动　　214
6.5.5　稍作尝试　　218
6.5.6　小结　　218
6.6　消息窗口　Tips　　219
6.6.1　关联文件　　219
6.6.2　概要　　219
6.6.3　消息队列和显示缓冲区　　219
6.6.4　小结　　224
第7章　消除动作解谜游戏——吃月亮　　225
7.1　玩法介绍　How to Play　　226
7.2　爽快的连锁和有趣的方块移动　Concept　　228
7.2.1　脚本一览　　228
7.2.2　本章小节　　230
7.3　同色方块相邻与否的判断　Tips　　230
7.3.1　关联文件　　230
7.3.2　概要　　230
7.3.3　连结与连锁　　230
7.3.4　不停地检测相邻方块　　231
7.3.5　递归调用　　233
7.3.6　用于测试连结检测的工程　　236
7.3.7　防止无限循环检测　　237
7.3.8　小结　　238
7.4　方块的初始设置　Tips　　239
7.4.1　关联文件　　239
7.4.2　概要　　239
7.4.3　颜色的选择方法　　239
7.4.4　随机选取方块的摆放位置　　242
7.4.5　小结　　244
7.5　动画的父子构造关系　Tips　　244
7.5.1　关联文件　　244
7.5.2　概要　　244
7.5.3　方块的运动　　244
7.5.4　动画的父子构造——用于测试的工程　　247
7.5.5　“吃月亮”中面板的位置和角度的计算　　252
7.5.6　小结　　254
7.6　方块的平滑移动　Tips　　254
7.6.1　关联文件　　254
7.6.2　概要　　254
7.6.3　数组的索引和画面上的位置　　255
7.6.4　桶列方法　　257
7.6.5　小结　　260
第8章　跳跃动作游戏——猫跳纸窗　　261
8.1　玩法介绍　How to Play　　262
8.2　刺激的跳跃　Concept　　264
8.2.1　脚本一览　　264
8.2.2　本章小节　　266
8.3　角色的状态管理　Tips　　266
8.3.1　关联文件　　266
8.3.2　概要　　266
8.3.3　角色的动作　　266
8.3.4　状态的迁移　　267
8.3.5　状态管理的流程　　268
8.3.6　小结　　272
8.4　可以控制高度的跳跃　Tips　　273
8.4.1　关联文件　　273
8.4.2　概要　　273
8.4.3　跳跃的物理规律　　273
8.4.4　自由控制跳跃高度的操作　　274
8.4.5　小结　　277
8.5　窗户纸的碰撞检测　Tips　　277
8.5.1　关联文件　　277
8.5.2　概要　　277
8.5.3　“碰撞”的内部实现机制　　277
8.5.4　窗户对象　　279
8.5.5　矛盾的碰撞结果　　279
8.5.6　平滑地穿过格子眼　　289
8.5.7　小结　　292
第9章　角色扮演游戏——村子里的传说　　293
9.1　玩法介绍　How to Play　　294
9.2　移动简单，人人都是主人公　Concept　　296
9.2.1　脚本一览　　296
9.2.2　本章小节　　298
9.3　事件和Actor　Tips　　298
9.3.1　关联文件　　298
9.3.2　概要　　298
9.3.3　事件　　298
9.3.4　事件的数据结构　　302
9.3.5　Actor　　304
9.3.6　事件的执行　　307
9.3.7　试着执行一个事件　　310
9.3.8　小结　　312
9.4　游戏内参数　Tips　　312
9.4.1　关联文件　　312
9.4.2　概要　　312
9.4.3　游戏内参数　　312
9.4.4　小结　　316
9.5　事件文件的读取　Tips　　316
9.5.1　关联文件　　316
9.5.2　概要　　316
9.5.3　文件的读取　　316
9.5.4　小结　　320
9.6　特殊的事件　Tips　　321
9.6.1　关联文件　　321
9.6.2　概要　　321
9.6.3　选项指令　　321
9.6.4　宝箱事件　　323
9.6.5　进入屋子的事件　　325
9.6.6　小结　　326
第10章　驾驶游戏——迷踪赛道　　327
10.1　玩法介绍　How to Play　　328
10.2　自行创建，即作即用　Concept　　330
10.2.1　脚本一览　　330
10.2.2　本章小节　　332
10.2.3　关于Car Tutorial脚本　　332
10.3　透视变换和逆透视变换　Tips　　332
10.3.1　关联文件　　332
10.3.2　概要　　332
10.3.3　透视变换　　333
10.3.4　逆透视变换　　335
10.3.5　小结　　337
10.4　多边形网格的生成方法　Tips　　338
10.4.1　关联文件　　338
10.4.2　概要　　338
10.4.3　生成道路的中心线　　339
10.4.4　多边形的生成方法　　341
10.4.5　生成道路多边形　　342
10.4.6　急转弯时的多边形重叠　　347
10.4.7　多边形生成的测试用工程　　348
10.4.8　小结　　348
10.5　模型的变形　Tips　　348
10.5.1　关联文件　　348
10.5.2　概要　　348
10.5.3　变形后顶点的位置坐标　　349
10.5.4　小结　　353
10.6　点缀实例　Tips　　353
10.6.1　关联文件　　353
10.6.2　概要　　353
10.6.3　生成基准线　　354
10.6.4　把树木设置到基准线上　　358
10.6.5　小结　　362
后记　　363
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Unity游戏设计与实现
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java高并发编程详解
推荐序一
推荐序二
推荐序三
推荐序四
前言
第一部分 多线程基础
第1章 快速认识线程 3
1.1 线程的介绍 3
1.2 快速创建并启动一个线程 3
1.2.1 尝试并行运行 4
1.2.2 并发运行交替输出 5
1.2.3 使用Jconsole观察线程 6
1.3 线程的生命周期详解 7
1.3.1 线程的NEW状态 8
1.3.2 线程的RUNNABLE状态 8
1.3.3 线程的 RUNNING状态 8
1.3.4 线程的BLOCKED状态 8
1.3.5 线程的TERMINATED状态 9
1.4 线程的start方法剖析：模板设计模式在Thread中的应用 9
1.4.1 Thread start方法源码分析以及注意事项 9
1.4.2 模板设计模式在Thread中的应用 11
1.4.3 Thread模拟营业大厅叫号机程序 13
1.5 Runnable接口的引入以及策略模式在Thread中的使用 16
1.5.1 Runnable的职责 16
1.5.2 策略模式在Thread中的应用 16
1.5.3 模拟营业大厅叫号机程序 18
1.6 本章总结 19
第2章 深入理解Thread构造函数 20
2.1 线程的命名 20
2.1.1 线程的默认命名 21
2.1.2 命名线程 21
2.1.3 修改线程的名字 22
2.2 线程的父子关系 22
2.3 Thread与ThreadGroup 23
2.4 Thread与Runnable 24
2.5 Thread与JVM虚拟机栈 25
2.5.1 Thread与Stacksize 25
2.5.2 JVM内存结构 27
2.5.3 Thread与虚拟机栈 30
2.6 守护线程 33
2.6.1 什么是守护线程 33
2.6.2 守护线程的作用 34
2.7 本章总结 34
第3章 Thread API的详细介绍 35
3.1 线程sleep 35
3.1.1 sleep方法介绍 35
3.1.2 使用TimeUnit替代Thread.sleep 36
3.2 线程yield 37
3.2.1 yield方法介绍 37
3.2.2 yield和sleep 37
3.3 设置线程的优先级 38
3.3.1 线程优先级介绍 38
3.3.2 线程优先级源码分析 39
3.3.3 关于优先级的一些总结 40
3.4 获取线程ID 40
3.5 获取当前线程 41
3.6 设置线程上下文类加载器 41
3.7 线程interrupt 42
3.7.1 interrupt 42
3.7.2 isInterrupted 43
3.7.3 interrupted 45
3.7.4 interrupt注意事项 46
3.8 线程join 47
3.8.1 线程join方法详解 48
3.8.2 join方法结合实战 50
3.9 如何关闭一个线程 53
3.9.1 正常关闭 54
3.9.2 异常退出 56
3.9.3 进程假死 56
3.10 本章总结 58
第4章 线程安全与数据同步 59
4.1 数据同步 59
4.1.1 数据不一致问题的引入 59
4.1.2 数据不一致问题原因分析 61
4.2 初识 synchronized关键字 62
4.2.1 什么是synchronized 63
4.2.2 synchronized关键字的用法 63
4.3 深入synchronized关键字 65
4.3.1 线程堆栈分析 65
4.3.2 JVM指令分析 67
4.3.3 使用synchronized需要注意的问题 70
4.4 This Monitor和Class Monitor的详细介绍 72
4.4.1 this monitor 72
4.4.2 class monitor 74
4.5 程序死锁的原因以及如何诊断 77
4.5.1 程序死锁 77
4.5.2 程序死锁举例 77
4.5.3 死锁诊断 80
4.6 本章总结 81
第5章 线程间通信 82
5.1 同步阻塞与异步非阻塞 82
5.1.1 同步阻塞消息处理 82
5.1.2 异步非阻塞消息处理 83
5.2 单线程间通信 84
5.2.1 初识wait和notify 84
5.2.2 wait和notify方法详解 87
5.2.3 关于wait和notify的注意事项 89
5.2.4 wait和sleep 90
5.3 多线程间通信 90
5.3.1 生产者消费者 90
5.3.2 线程休息室wait set 93
5.4 自定义显式锁BooleanLock 94
5.4.1 synchronized关键字的缺陷 94
5.4.2 显式锁BooleanLock 95
5.5 本章总结 104
第6章 ThreadGroup详细讲解 105
6.1 ThreadGroup与Thread 105
6.2 创建ThreadGroup 105
6.3 复制Thread数组和ThreadGroup数组 106
6.3.1 复制Thread数组 106
6.3.2 复制ThreadGroup数组 109
6.4 ThreadGroup操作 109
6.4.1 ThreadGroup的基本操作 110
6.4.2 ThreadGroup的interrupt 113
6.4.3 ThreadGroup的destroy 114
6.4.4 守护ThreadGroup 115
6.5 本章总结 116
第7章 Hook线程以及捕获线程执行异常 117
7.1 获取线程运行时异常 117
7.1.1 UncaughtExceptionHandler的介绍 117
7.1.2 UncaughtExceptionHandler实例 118
7.1.3 UncaughtExceptionHandler源码分析 119
7.2 注入钩子线程 121
7.2.1 Hook线程介绍 121
7.2.2 Hook线程实战 122
7.2.3 Hook线程应用场景以及注意事项 124
7.3 本章总结 124
第8章 线程池原理以及自定义线程池 125
8.1 线程池原理 125
8.2 线程池实现 126
8.2.1 线程池接口定义 127
8.2.2 线程池详细实现 131
8.3 线程池的应用 139
8.4 本章总结 142
第二部分 Java ClassLoader
第9章 类的加载过程 144
9.1 类的加载过程简介 144
9.2 类的主动使用和被动使用 145
9.3 类的加载过程详解 148
9.3.1 类的加载阶段 148
9.3.2 类的连接阶段 149
9.3.3 类的初始化阶段 154
9.4 本章总结 156
第10章 JVM类加载器 158
10.1 JVM内置三大类加载器 158
10.1.1 根类加载器介绍 159
10.1.2 扩展类加载器介绍 159
10.1.3 系统类加载器介绍 160
10.2 自定义类加载器 161
10.2.1 自定义类加载器，问候世界 161
10.2.2 双亲委托机制详细介绍 165
10.2.3 破坏双亲委托机制 167
10.2.4 类加载器命名空间、运行时包、类的卸载等 170
10.3 本章总结 175
第11章 线程上下文类加载器 177
11.1 为什么需要线程上下文类加载器 177
11.2 数据库驱动的初始化源码分析 178
11.3 本章总结 180
第三部分 深入理解volatile关键字
第12章 volatile关键字的介绍 182
12.1 初识volatile关键字 182
12.2 机器硬件CPU 184
12.2.1 CPU Cache模型 184
12.2.2 CPU缓存一致性问题 186
12.3 Java内存模型 187
12.4 本章总结 188
第13章 深入volatile关键字 189
13.1 并发编程的三个重要特性 189
13.1.1 原子性 189
13.1.2 可见性 190
13.1.3 有序性 190
13.2 JMM如何保证三大特性 191
13.2.1 JMM与原子性 192
13.2.2 JMM与可见性 193
13.2.3 JMM与有序性 194
13.3 volatile关键字深入解析 195
13.3.1 volatile关键字的语义 195
13.3.2 volatile的原理和实现机制 197
13.3.3 volatile的使用场景 198
13.3.4 volatile和synchronized 199
13.4 本章总结 200
第14章 7种单例设计模式的设计 201
14.1 饿汉式 201
14.2 懒汉式 202
14.3 懒汉式+同步方法 203
14.4 Double-Check 204
14.5 Volatile+Double-Check 206
14.6 Holder方式 206
14.7 枚举方式 207
14.8 本章总结 208
第四部分 多线程设计架构模式
第15章 监控任务的生命周期 212
15.1 场景描述 212
15.2 当观察者模式遇到Thread 212
15.2.1 接口定义 212
15.2.2 ObservableThread实现 215
15.3 本章总结 217
15.3.1 测试运行 217
15.3.2 关键点总结 219
第16章 Single Thread Execution设计模式 220
16.1 机场过安检 220
16.1.1 非线程安全 221
16.1.2 问题分析 223
16.1.3 线程安全 225
16.2 吃面问题 225
16.2.1 吃面引起的死锁 226
16.2.2 解决吃面引起的死锁问题 228
16.2.3 哲学家吃面 229
16.3 本章总结 230
第17章 读写锁分离设计模式 231
17.1 场景描述 231
17.2 读写分离程序设计 232
17.2.1 接口定义 232
17.2.2 程序实现 234
17.3 读写锁的使用 239
17.4 本章总结 242
第18章 不可变对象设计模式 244
18.1 线程安全性 244
18.2 不可变对象的设计 244
18.2.1 非线程安全的累加器 245
18.2.2 方法同步增加线程安全性 247
18.2.3 不可变的累加器对象设计 248
18.3 本章总结 249
第19章 Future设计模式 251
19.1 先给你一张凭据 251
19.2 Future设计模式实现 251
19.2.1 接口定义 252
19.2.2 程序实现 253
19.3 Future的使用以及技巧总结 256
19.4 增强FutureService使其支持回调 257
19.5 本章总结 258
第20章 Guarded Suspension设计模式 259
20.1 什么是Guarded Suspension设计模式 259
20.2 Guarded Suspension的示例 259
20.3 本章总结 261
第21章 线程上下文设计模式 262
21.1 什么是上下文 262
21.2 线程上下文设计 263
21.3 ThreadLocal详解 264
21.3.1 ThreadLocal的使用场景及注意事项 265
21.3.2 ThreadLocal的方法详解及源码分析 265
21.3.3 ThreadLocal的内存泄漏问题分析 270
21.4 使用ThreadLocal设计线程上下文 274
21.5 本章总结 276
第22章 Balking设计模式 277
22.1 什么是Balking设计 277
22.2 Balking模式之文档编辑 278
22.2.1 Document 278
22.2.2 AutoSaveThread 280
22.2.3 DocumentEditThread 281
22.3 本章总结 283
第23章 Latch设计模式 284
23.1 什么是Latch 284
23.2 CountDownLatch程序实现 285
23.2.1 无限等待的Latch 285
23.2.2 有超时设置的Latch 289
23.3 本章总结 291
第24章 Thread-Per-Message设计模式 293
24.1 什么是Thread-Per-Message模式 293
24.2 每个任务一个线程 293
24.3 多用户的网络聊天 296
24.3.1 服务端程序 296
24.3.2 响应客户端连接的Handler 297
24.3.3 聊天程序测试 299
24.4 本章总结 300
第25章 Two Phase Termination设计模式 301
25.1 什么是Two Phase Termination模式 301
25.2 Two Phase Termination的示例 302
25.2.1 线程停止的Two Phase Termination 302
25.2.2 进程关闭的Two Phase Termination 303
25.3 知识扩展 304
25.3.1 Strong Reference及LRUCache 304
25.3.2 Soft Reference及SoftLRUCache 308
25.3.3 Weak Reference 311
25.3.4 Phantom Reference 312
25.4 本章总结 314
第26章 Worker-Thread设计模式 315
26.1 什么是Worker-Thread模式 315
26.2 Worker-Thread模式实现 315
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java高并发编程详解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程实战指南（核心篇）
第一部分  多线程编程基础
第1章  走近Java世界中的线程	2
1.1  进程、线程与任务	2
1.2  多线程编程简介	4
1.2.1  什么是多线程编程	4
1.2.2  为什么使用多线程	4
1.3  Java线程API简介	5
1.3.1  线程的创建、启动与运行	5
1.3.2  Runnable接口	9
1.3.3  线程属性	12
1.3.4  Thread类的常用方法	14
1.3.5  Thread类的一些废弃方法	16
1.4  无处不在的线程	17
1.5  线程的层次关系	19
1.6  线程的生命周期状态	21
1.7  线程的监视	22
1.8  多线程编程简单运用实例	26
*1.9  多线程编程的优势和风险	27
1.10  本章小结	29
第2章  多线程编程的目标与挑战	31
2.1  串行、并发与并行	31
2.2  竞态	33
2.2.1  二维表分析法：解释竞态的结果	37
2.2.2  竞态的模式与竞态产生的条件	39
2.3  线程安全性	42
2.4  原子性	43
2.5  可见性	49
2.6  有序性	56
2.6.1  重排序的概念	56
2.6.2  指令重排序	57
2.6.3  存储子系统重排序	63
2.6.4  貌似串行语义	66
2.6.5  保证内存访问的顺序性	68
2.7  上下文切换	69
2.7.1  上下文切换及其产生原因	69
2.7.2  上下文切换的分类及具体诱因	70
2.7.3  上下文切换的开销和测量	71
2.8  线程的活性故障	73
2.9  资源争用与调度	74
2.10  本章小结	77
第3章  Java线程同步机制	80
3.1  线程同步机制简介	80
3.2  锁概述	81
3.2.1  锁的作用	82
3.2.2  与锁相关的几个概念	84
3.2.3  锁的开销及其可能导致的问题	86
3.3  内部锁：synchronized关键字	86
3.4  显式锁：Lock接口	89
3.4.1  显式锁的调度	91
3.4.2  显式锁与内部锁的比较	92
3.4.3  内部锁还是显式锁：锁的选用	95
*3.4.4  改进型锁：读写锁	95
3.5  锁的适用场景	99
3.6  线程同步机制的底层助手：内存屏障	99
*3.7  锁与重排序	102
3.8  轻量级同步机制：volatile关键字	105
3.8.1  volatile的作用	105
3.8.2  volatile变量的开销	111
3.8.3  volatile的典型应用场景与实战案例	111
3.9  实践：正确实现看似简单的单例模式	120
3.10  CAS与原子变量	126
3.10.1  CAS	127
3.10.2  原子操作工具：原子变量类	129
3.11  对象的发布与逸出	135
3.11.1  对象的初始化安全：重访final与static	137
3.11.2  安全发布与逸出	142
3.12  本章小结	143
第4章  牛刀小试：玩转线程	148
4.1  挖掘可并发点	148
4.2  新战场上的老武器：分而治之	148
4.3  基于数据的分割实现并发化	149
4.4  基于任务的分割实现并发化	158
4.4.1  按任务的资源消耗属性分割	159
4.4.2  实战案例的启发	169
4.4.3  按处理步骤分割	171
4.5  合理设置线程数	172
4.5.1  Amdahl's定律	172
4.5.2  线程数设置的原则	173
4.6  本章小结	177
第5章  线程间协作	179
5.1  等待与通知：wait/notify	179
5.1.1  wait/notify的作用与用法	180
5.1.2  wait/notify的开销及问题	188
5.1.3  Object.notify()/notifyAll()的选用	191
*5.1.4  wait/notify与Thread.join()	191
5.2  Java条件变量	192
5.3  倒计时协调器：CountDownLatch	198
5.4  栅栏（CyclicBarrier）	203
5.5  生产者—消费者模式	210
5.5.1  阻塞队列	213
5.5.2  限购：流量控制与信号量（Semaphore）	216
*5.5.3  管道：线程间的直接输出与输入	218
5.5.4  一手交钱，一手交货：双缓冲与Exchanger	221
5.5.5  一个还是一批：产品的粒度	223
5.5.6  再探线程与任务之间的关系	224
5.6  对不起，打扰一下：线程中断机制	225
5.7  线程停止：看似简单，实则不然	228
5.7.1  生产者—消费者模式中的线程停止	233
5.7.2  实践：Web应用中的线程停止	233
5.8  本章小结	236
第6章  保障线程安全的设计技术	240
*6.1  Java运行时存储空间	240
6.2  大公无私：无状态对象	243
6.3  以“不变”应万变：不可变对象	248
6.4  我有我地盘：线程特有对象	254
6.4.1  线程特有对象可能导致的问题及其规避	258
6.4.2  线程特有对象的典型应用场景	264
6.5  装饰器模式	265
6.6  并发集合	267
6.7  本章小结	270
第7章  线程的活性故障	273
7.1  鹬蚌相争：死锁	273
7.1.1  死锁的检测	274
7.1.2  死锁产生的条件与规避	283
7.1.3  死锁的恢复	296
7.2  沉睡不醒的睡美人：锁死	301
7.2.1  信号丢失锁死	301
7.2.2  嵌套监视器锁死	301
7.3  巧妇难为无米之炊：线程饥饿	307
7.4  屡战屡败，屡败屡战：活锁	307
7.5  本章小结	308
第8章  线程管理	310
8.1  线程组	310
8.2  可靠性：线程的未捕获异常与监控	311
8.3  有组织有纪律：线程工厂	316
8.4  线程的暂挂与恢复	318
8.5  线程的高效利用：线程池	320
8.5.1  任务的处理结果、异常处理与取消	326
8.5.2  线程池监控	329
8.5.3  线程池死锁	330
8.5.4  工作者线程的异常终止	330
8.6  本章小结	331
第9章  Java异步编程	333
9.1  同步计算与异步计算	333
9.2  Java Executor框架	336
9.2.1  实用工具类Executors	337
9.2.2  异步任务的批量执行：CompletionService	339
9.3  异步计算助手：FutureTask	344
9.3.1  实践：实现XML文档的异步解析	345
9.3.2  可重复执行的异步任务	349
9.4  计划任务	352
9.5  本章小结	358
第10章  Java多线程程序的调试与测试	360
10.1  多线程程序的调试技巧	360
10.1.1  使用监视点	360
10.1.2  设置暂挂策略	361
10.2  多线程程序的测试	363
10.2.1  可测试性	364
10.2.2  静态检查工具：FindBugs	369
10.2.3  多线程程序的代码复审	370
10.2.4  多线程程序的单元测试：JCStress	372
10.3  本章小结	375
第二部分  多线程编程进阶
第11章  多线程编程的硬件基础与Java内存模型	378
11.1  填补处理器与内存之间的鸿沟：高速缓存	378
11.2  数据世界的交通规则：缓存一致性协议	382
11.3  硬件缓冲区：写缓冲器与无效化队列	386
11.3.1  存储转发	388
11.3.2  再探内存重排序	388
11.3.3  再探可见性	391
11.4  基本内存屏障	392
11.5  Java同步机制与内存屏障	395
11.5.1  volatile关键字的实现	395
11.5.2  synchronized关键字的实现	397
11.5.3  Java虚拟机对内存屏障使用的优化	398
11.5.4  final关键字的实现	398
11.6  Java内存模型	399
11.6.1  什么是Java内存模型	400
11.6.2  happen(s)-before关系	401
11.6.3  再探对象的安全发布	407
11.6.4  JSR 133	411
11.7  共享变量与性能	411
11.8  本章小结	411
第12章  Java多线程程序的性能调校	415
12.1  Java虚拟机对内部锁的优化	415
12.1.1  锁消除	415
12.1.2  锁粗化	417
12.1.3  偏向锁	419
12.1.4  适应性锁	420
12.2  优化对锁的使用	421
12.2.1  锁的开销与锁争用监视	421
12.2.2  使用可参数化锁	424
12.2.3  减小临界区的长度	428
12.2.4  减小锁的粒度	432
12.2.5  考虑锁的替代品	438
12.3  减少系统内耗：上下文切换	438
12.4  多线程编程的“三十六计”：多线程设计模式	440
12.5  性能的隐形杀手：伪共享	441
12.5.1  Java对象内存布局	442
12.5.2  伪共享的侦测与消除	445
12.6  本章小结	454
Web参考资源	457
参考文献	463
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程实战指南（核心篇）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程实战指南（设计模式篇）
1章  Java多线程编程实战基础	1
1.1  无处不在的线程	1
1.2  线程的创建与运行	2
1.3  线程的状态与上下文切换	5
1.4  线程的监视	7
1.5  原子性、内存可见性和重排序——重新认识synchronized和volatile	10
1.6  线程的优势和风险	11
1.7  多线程编程常用术语	13
第2章  设计模式简介	17
2.1  设计模式及其作用	17
2.2  多线程设计模式简介	20
2.3  设计模式的描述	21
第3章  Immutable Object（不可变对象）模式	23
3.1  Immutable Object模式简介	23
3.2  Immutable Object模式的架构	25
3.3  Immutable Object模式实战案例	27
3.4  Immutable Object模式的评价与实现考量	31
3.5  Immutable Object模式的可复用实现代码	32
3.6  Java标准库实例	32
3.7  相关模式	34
3.7.1  Thread Specific Storage模式（第10章）	34
3.7.2  Serial Thread Confinement模式（第11章）	34
3.8  参考资源	34
第4章  Guarded Suspension（保护性暂挂）模式	35
4.1  Guarded Suspension模式简介	35
4.2  Guarded Suspension模式的架构	35
4.3  Guarded Suspension模式实战案例解析	39
4.4  Guarded Suspension模式的评价与实现考量	45
4.4.1  内存可见性和锁泄漏（Lock Leak）	46
4.4.2  线程过早被唤醒	46
4.4.3  嵌套监视器锁死	47
4.5  Guarded Suspension模式的可复用实现代码	50
4.6  Java标准库实例	50
4.7  相关模式	51
4.7.1  Promise模式（第6章）	51
4.7.2  Producer-Consumer模式（第7章）	51
4.8  参考资源	51
第5章  Two-phase Termination（两阶段终止）模式	52
5.1  Two-phase Termination模式简介	52
5.2  Two-phase Termination模式的架构	53
5.3  Two-phase Termination模式实战案例	56
5.4  Two-phase Termination模式的评价与实现考量	63
5.4.1  线程停止标志	63
5.4.2  生产者-消费者问题中的线程停止	64
5.4.3  隐藏而非暴露可停止的线程	65
5.5  Two-phase Termination模式的可复用实现代码	65
5.6  Java标准库实例	66
5.7  相关模式	66
5.7.1  Producer-Consumer模式（第7章）	66
5.7.2  Master-Slave模式（第12章）	66
5.8  参考资源	66
第6章  Promise（承诺）模式	67
6.1  Promise模式简介	67
6.2  Promise模式的架构	68
6.3  Promise模式实战案例解析	70
6.4  Promise模式的评价与实现考量	74
6.4.1  异步方法的异常处理	75
6.4.2  轮询（Polling）	75
6.4.3  异步任务的执行	75
6.5  Promise模式的可复用实现代码	77
6.6  Java标准库实例	77
6.7  相关模式	78
6.7.1  Guarded Suspension模式（第4章）	78
6.7.2  Active Object模式（第8章）	78
6.7.3  Master-Slave模式（第12章）	78
6.7.4  Factory Method模式	78
6.8  参考资源	79
第7章  Producer-Consumer（生产者/消费者）模式	80
7.1  Producer-Consumer模式简介	80
7.2  Producer-Consumer模式的架构	80
7.3  Producer-Consumer模式实战案例解析	83
7.4  Producer-Consumer模式的评价与实现考量	87
7.4.1  通道积压	87
7.4.2  工作窃取算法	88
7.4.3  线程的停止	92
7.4.4  高性能高可靠性的Producer-Consumer模式实现	92
7.5  Producer-Consumer模式的可复用实现代码	92
7.6  Java标准库实例	93
7.7  相关模式	93
7.7.1  Guarded Suspension模式（第4章）	93
7.7.2  Thread Pool模式（第9章）	93
7.8  参考资源	93
第8章  Active Object（主动对象）模式	94
8.1  Active Object模式简介	94
8.2  Active Object模式的架构	95
8.3  Active Object模式实战案例解析	98
8.4  Active Object模式的评价与实现考量	105
8.4.1  错误隔离	107
8.4.2  缓冲区监控	108
8.4.3  缓冲区饱和处理策略	108
8.4.4  Scheduler空闲工作者线程清理	109
8.5  Active Object模式的可复用实现代码	109
8.6  Java标准库实例	111
8.7  相关模式	112
8.7.1  Promise模式（第6章）	112
8.7.2  Producer-Consumer模式（第7章）	112
8.8  参考资源	112
第9章  Thread Pool（线程池）模式	113
9.1  Thread Pool模式简介	113
9.2  Thread Pool模式的架构	114
9.3  Thread Pool模式实战案例解析	116
9.4  Thread Pool模式的评价与实现考量	117
9.4.1  工作队列的选择	118
9.4.2  线程池大小调校	119
9.4.3  线程池监控	121
9.4.4  线程泄漏	122
9.4.5  可靠性与线程池饱和处理策略	122
9.4.6  死锁	125
9.4.7  线程池空闲线程清理	126
9.5  Thread Pool模式的可复用实现代码	127
9.6  Java标准库实例	127
9.7  相关模式	127
9.7.1  Two-phase Termination模式（第5章）	127
9.7.2  Promise模式（第6章）	127
9.7.3  Producer-Consumer模式（第7章）	127
9.8  参考资源	128
第10章  Thread Specific Storage（线程特有存储）模式	129
10.1  Thread Specific Storage模式简介	129
10.2  Thread Specific Storage模式的架构	131
10.3  Thread Specific Storage模式实战案例解析	133
10.4  Thread Specific Storage模式的评价与实现考量	135
10.4.1  线程池环境下使用Thread Specific Storage模式	138
10.4.2  内存泄漏与伪内存泄漏	139
10.5  Thread Specific Storage模式的可复用实现代码	145
10.6  Java标准库实例	146
10.7  相关模式	146
10.7.1  Immutable Object模式（第3章）	146
10.7.2  Proxy（代理）模式	146
10.7.3  Singleton（单例）模式	146
10.8  参考资源	147
第11章  Serial Thread Confinement（串行线程封闭）模式	148
11.1  Serial Thread Confinement模式简介	148
11.2  Serial Thread Confinement模式的架构	148
11.3  Serial Thread Confinement模式实战案例解析	151
11.4  Serial Thread Confinement模式的评价与实现考量	155
11.4.1  任务的处理结果	155
11.5  Serial Thread Confinement模式的可复用实现代码	156
11.6  Java标准库实例	160
11.7  相关模式	160
11.7.1  Immutable Object模式（第3章）	160
11.7.2  Promise模式（第6章）	160
11.7.3  Producer-Consumer模式（第7章）	160
11.7.4  Thread Specific Storage（线程特有存储）模式 （第10章）	161
11.8  参考资源	161
第12章  Master-Slave（主仆）模式	162
12.1  Master-Slave模式简介	162
12.2  Master-Slave模式的架构	162
12.3  Master-Slave模式实战案例解析	164
12.4  Master-Slave模式的评价与实现考量	171
12.4.1  子任务的处理结果的收集	172
12.4.2  Slave参与者实例的负载均衡与工作窃取	173
12.4.3  可靠性与异常处理	173
12.4.4  Slave线程的停止	174
12.5  Master-Slave模式的可复用实现代码	174
12.6  Java标准库实例	186
12.7  相关模式	186
12.7.1  Two-phase Termination模式（第5章）	186
12.7.2  Promise模式（第6章）	186
12.7.3  Strategy（策略）模式	186
12.7.4  Template（模板）模式	186
12.7.5  Factory Method（工厂方法）模式	186
12.8  参考资源	187
第13章  Pipeline（流水线）模式	188
13.1  Pipeline模式简介	188
13.2  Pipeline模式的架构	189
13.3  Pipeline模式实战案例解析	194
13.4  Pipeline模式的评价与实现考量	208
13.4.1  Pipeline的深度	209
13.4.2  基于线程池的Pipe	209
13.4.3  错误处理	212
13.4.4  可配置的Pipeline	212
13.5  Pipeline模式的可复用实现代码	212
13.6  Java标准库实例	222
13.7  相关模式	222
13.7.1  Serial Thread Confinement模式（第11章）	222
13.7.2  Master-Slave模式（第12章）	222
13.7.3  Composite模式	223
13.8  参考资源	223
第14章  Half-sync/Half-async（半同步/半异步）模式	224
14.1  Half-sync/Half-async模式简介	224
14.2  Half-sync/Half-async模式的架构	224
14.3  Half-sync/Half-async模式实战案例解析	226
14.4  Half-sync/Half-async模式的评价与实现考量	234
14.4.1  队列积压	235
14.4.2  避免同步层处理过慢	235
14.5  Half-sync/Half-async模式的可复用实现代码	236
14.6  Java标准库实例	240
14.7  相关模式	240
14.7.1  Two-phase Termination模式（第5章）	240
14.7.2  Producer-Consumer模式（第7章）	241
14.7.3  Active Object模式（第8章）	241
14.7.4  Thread Pool模式（第9章）	241
14.8  参考资源	241
第15章  模式语言	242
15.1  模式与模式间的联系	242
15.2  mmutable Object（不可变对象）模式	244
15.3  Guarded Suspension（保护性暂挂）模式	244
15.4  Two-phase Termination（两阶段终止）模式	245
15.5  Promise（承诺）模式	246
15.6  Producer-Consumer（生产者/消费者）模式	247
15.7  Active Object（主动对象）模式	248
15.8  Thread Pool（线程池）模式	249
15.9  Thread Specific Storage（线程特有存储）模式	250
15.10  Serial Thread Confinement（串行线程封闭）模式	251
15.11  Master-Slave（主仆）模式	252
15.12  Pipeline（流水线）模式	253
15.13  Half-sync/Half-async（半同步/半异步）模式	254
附录  本书常用UML图指南	255
A.1  UML简介	255
A.2  类图（Class Diagram）	256
A.1.1  类的属性、方法和立体型（Stereotype）	256
A.1.2  类与类之间的关系	258
A.3  序列图（Sequence Diagram）	261
参考文献	263
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程实战指南（设计模式篇）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java线程
前言
第一章 Thread导论
Java术语
关于范例
为何要用Thread？
总结
第二章 Thread的创建与管理
什么是Thread？
创建Thread
Thread的生命周期
两种停止Thfead的方式
Runnable工nterface
Thread与对象
总结
第三章 数据同步
Synchronized关键字
Volatile关键字
更多RaceCOnd“iOn的讨论
明确的 (explicit)Locking
Lock Scope
选择Locking机制
Nested Lock
死锁
Lock公平 (Fairness)
总结
第四章 Thread NOtification
等待与通知
条件变量
总结
第五章 极简同步技巧
能避免同步吗？
Atomic变量
Thread局部变量
总结
第六章 高级同步议题
同步术语
J2SE 5.0中加入的同步Class
防止死锁
死锁检测
Lock饥饿
总结
第七章 Thread与Swing
Swing Threading的限制
事件派发Thread的处理
使用invokeLater()与invokeAndWait()
长时间运行的事件回调
总结
第八章 Thread与Collection Class
Collection Class的概述
同步与Collection Class
生产者/肖费者模式
使用CollectionClass
总结
第九章 Thread调度
Thread调度的概述
以Thread优先级来调度
常见Threading的实现
总结
第十章 Thread Pool
为何要用Thread Pool？
Executor
使用Thread Pool
Queue与大小
创建Thread
Callable Task与Future结果
单一Thread化的访问
总结
第十一章 Task的调度
Task调度的概述
java.util.Timer Class
javax.Swing.Timer Class
SCheduledThreadPoolExecutor Class
总结
第十二章 Thread与I／O
传统的I／O服务器
新的I／O服务器
被中断的I／O
总结
第十三章 各种Thread议题
Thread Group
Thread与Java安全性
Daemon Thread
Thread与C1ass的力口载
Thread与异常处理
Thread、Stack、 内存的使用
总结
第十四章 Thread性能
性能的概述
同步的Collection
Atomic变量与有竞争的同步
Thread的创建与Thread Pool
总结
第十五章 多处理器计算机的并行化循环
对单一Threaded程序的并行化
多处理器扩大(scaling)
总结
附录 被撤换的Threading功能
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java线程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java并发编程实战
对本书的赞誉
译者序
前　言
第1章　简介1
1.1　并发简史1
1.2　线程的优势2
1.2.1　发挥多处理器的强大能力2
1.2.2　建模的简单性3
1.2.3　异步事件的简化处理3
1.2.4　响应更灵敏的用户界面4
1.3　线程带来的风险4
1.3.1　安全性问题5
1.3.2　活跃性问题7
1.3.3　性能问题7
1.4　线程无处不在7
第一部分　基础知识
第2章　线程安全性11
2.1　什么是线程安全性13
2.2　原子性14
2.2.1　竞态条件15
2.2.2　示例：延迟初始化中的竞态条件16
2.2.3　复合操作17
2.3　加锁机制18
2.3.1　内置锁20
2.3.2　重入21
2.4　用锁来保护状态22
2.5　活跃性与性能23
第3章　对象的共享27
3.1　可见性27
3.1.1　失效数据28
3.1.2　非原子的64位操作29
3.1.3　加锁与可见性30
3.1.4　Volatile变量 30
3.2　发布与逸出32
3.3　线程封闭35
3.3.1　Ad-hoc线程封闭35
3.3.2　栈封闭36
3.3.3　ThreadLocal类37
3.4　不变性38
3.4.1　Final域39
3.4.2　示例：使用Volatile类型来发布不可变对象40
3.5　安全发布41
3.5.1　不正确的发布：正确的对象被破坏42
3.5.2 　不可变对象与初始化安全性42
3.5.3　安全发布的常用模式43
3.5.4　事实不可变对象44
3.5.5　可变对象44
3.5.6　安全地共享对象44
第4章　对象的组合46
4.1　设计线程安全的类46
4.1.1　收集同步需求47
4.1.2　依赖状态的操作48
4.1.3　状态的所有权48
4.2　实例封闭49
4.2.1　Java监视器模式51
4.2.2　示例：车辆追踪51
4.3　线程安全性的委托53
4.3.1　示例：基于委托的车辆追踪器54
4.3.2　独立的状态变量55
4.3.3　当委托失效时56
4.3.4　发布底层的状态变量57
4.3.5　示例：发布状态的车辆追踪器58
4.4　在现有的线程安全类中添加功能59
4.4.1　客户端加锁机制60
4.4.2　组合62
4.5　将同步策略文档化62
第5章　基础构建模块66
5.1　同步容器类66
5.1.1　同步容器类的问题66
5.1.2　迭代器与Concurrent-ModificationException68
5.1.3　隐藏迭代器69
5.2　并发容器70
5.2.1　ConcurrentHashMap71
5.2.2　额外的原子Map操作72
5.2.3　CopyOnWriteArrayList72
5.3　阻塞队列和生产者-消费者模式73
5.3.1　示例：桌面搜索75
5.3.2　串行线程封闭76
5.3.3　双端队列与工作密取77
5.4　阻塞方法与中断方法77
5.5　同步工具类78
5.5.1　闭锁79
5.5.2　FutureTask80
5.5.3　信号量82
5.5.4　栅栏83
5.6　构建高效且可伸缩的结果缓存85
第二部分　结构化并发应用程序
第6章　任务执行93
6.1　在线程中执行任务93
6.1.1　串行地执行任务94
6.1.2　显式地为任务创建线程94
6.1.3　无限制创建线程的不足95
6.2　Executor框架96
6.2.1　示例：基于Executor的Web服务器97
6.2.2　执行策略98
6.2.3　线程池98
6.2.4　Executor的生命周期99
6.2.5　延迟任务与周期任务101
6.3　找出可利用的并行性102
6.3.1　示例：串行的页面渲染器102
6.3.2　携带结果的任务Callable与Future103
6.3.3　示例：使用Future实现页面渲染器104
6.3.4　在异构任务并行化中存在的局限106
6.3.5　CompletionService:Executor与BlockingQueue106
6.3.6　示例：使用CompletionService实现页面渲染器107
6.3.7　为任务设置时限108
6.3.8　示例：旅行预定门户网站109
第7章　取消与关闭111
7.1　任务取消111
7.1.1　中断113
7.1.2　中断策略116
7.1.3　响应中断117
7.1.4　示例：计时运行118
7.1.5　通过Future来实现取消120
7.1.6　处理不可中断的阻塞121
7.1.7　采用newTaskFor来封装非标准的取消122
7.2　停止基于线程的服务124
7.2.1　示例：日志服务124
7.2.2　关闭ExecutorService127
7.2.3　“毒丸”对象128
7.2.4　示例：只执行一次的服务129
7.2.5　shutdownNow的局限性130
7.3　处理非正常的线程终止132
7.4　JVM关闭135
7.4.1　关闭钩子135
7.4.2　守护线程136
7.4.3　终结器136
第8章　线程池的使用138
8.1　在任务与执行策略之间的隐性耦合138
8.1.1　线程饥饿死锁139
8.1.2　运行时间较长的任务140
8.2　设置线程池的大小140
8.3　配置ThreadPoolExecutor141
8.3.1　线程的创建与销毁142
8.3.2　管理队列任务142
8.3.3　饱和策略144
8.3.4　线程工厂146
8.3.5　在调用构造函数后再定制ThreadPoolExecutor147
8.4　扩展 ThreadPoolExecutor148
8.5　递归算法的并行化149
第9章　图形用户界面应用程序156
9.1　为什么GUI是单线程的156
9.1.1　串行事件处理157
9.1.2　Swing中的线程封闭机制158
9.2　短时间的GUI任务160
9.3　长时间的GUI任务161
9.3.1　取消162
9.3.2　进度标识和完成标识163
9.3.3　SwingWorker165
9.4　共享数据模型165
9.4.1　线程安全的数据模型166
9.4.2　分解数据模型166
9.5　其他形式的单线程子系统167
第三部分　活跃性、性能与测试
第10章　避免活跃性危险169
10.1　死锁169
10.1.1　锁顺序死锁170
10.1.2　动态的锁顺序死锁171
10.1.3　在协作对象之间发生的死锁174
10.1.4　开放调用175
10.1.5　资源死锁177
10.2　死锁的避免与诊断178
10.2.1　支持定时的锁178
10.2.2　通过线程转储信息来分析死锁178
10.3　其他活跃性危险180
10.3.1　饥饿180
10.3.2　糟糕的响应性181
10.3.3　活锁181
第11章　性能与可伸缩性183
11.1　对性能的思考183
11.1.1　性能与可伸缩性184
11.1.2　评估各种性能权衡因素185
11.2　Amdahl定律186
11.2.1　示例：在各种框架中隐藏的串行部分188
11.2.2　Amdahl定律的应用189
11.3　线程引入的开销189
11.3.1　上下文切换190
11.3.2　内存同步190
11.3.3　阻塞192
11.4　减少锁的竞争192
11.4.1　缩小锁的范围（“快进快出”）193
11.4.2　减小锁的粒度195
11.4.3　锁分段196
11.4.4　避免热点域197
11.4.5　一些替代独占锁的方法198
11.4.6　监测CPU的利用率199
11.4.7　向对象池说“不”200
11.5　示例：比较Map的性能200
11.6　减少上下文切换的开销201
第12章　并发程序的测试204
12.1　正确性测试205
12.1.1　基本的单元测试206
12.1.2　对阻塞操作的测试207
12.1.3　安全性测试208
12.1.4　资源管理的测试212
12.1.5　使用回调213
12.1.6　产生更多的交替操作214
12.2　性能测试215
12.2.1　在PutTakeTest中增加计时功能215
12.2.2　多种算法的比较217
12.2.3　响应性衡量218
12.3　避免性能测试的陷阱220
12.3.1　垃圾回收220
12.3.2　动态编译220
12.3.3　对代码路径的不真实采样222
12.3.4　不真实的竞争程度222
12.3.5　无用代码的消除223
12.4　其他的测试方法224
12.4.1　代码审查224
12.4.2　静态分析工具224
12.4.3　面向方面的测试技术226
12.4.4　分析与监测工具226
第四部分　高级主题
第13章　显式锁227
13.1　Lock与 ReentrantLock227
13.1.1　轮询锁与定时锁228
13.1.2　可中断的锁获取操作230
13.1.3　非块结构的加锁231
13.2　性能考虑因素231
13.3　公平性232
13.4　在synchronized和ReentrantLock之间进行选择234
13.5　读-写锁235
第14章　构建自定义的同步工具238
14.1　状态依赖性的管理238
14.1.1　示例：将前提条件的失败传递给调用者240
14.1.2　示例：通过轮询与休眠来实现简单的阻塞241
14.1.3　条件队列243
14.2　使用条件队列244
14.2.1　条件谓词244
14.2.2　过早唤醒245
14.2.3　丢失的信号246
14.2.4　通知247
14.2.5　示例：阀门类248
14.2.6　子类的安全问题249
14.2.7　封装条件队列250
14.2.8　入口协议与出口协议250
14.3　显式的Condition对象251
14.4　Synchronizer剖析253
14.5　AbstractQueuedSynchronizer254
14.6　java.util.concurrent同步器类中的 AQS257
14.6.1　ReentrantLock257
14.6.2　Semaphore与CountDownLatch258
14.6.3　FutureTask259
14.6.4　ReentrantReadWriteLock259
第15章　原子变量与非阻塞同步机制261
15.1　锁的劣势261
15.2　硬件对并发的支持262
15.2.1　比较并交换263
15.2.2　非阻塞的计数器264
15.2.3　JVM对CAS的支持265
15.3　原子变量类265
15.3.1　原子变量是一种“更好的volatile”266
15.3.2　性能比较：锁与原子变量267
15.4　非阻塞算法270
15.4.1　非阻塞的栈270
15.4.2　非阻塞的链表272
15.4.3　原子的域更新器274
15.4.4　ABA问题275
第16章　Java内存模型277
16.1　什么是内存模型，为什么需要它277
16.1.1　平台的内存模型278
16.1.2　重排序278
16.1.3　Java内存模型简介280
16.1.4　借助同步281
16.2　发布283
16.2.1　不安全的发布283
16.2.2　安全的发布284
16.2.3　安全初始化模式284
16.2.4　双重检查加锁286
16.3　初始化过程中的安全性287
附录A　并发性标注289
参考文献291
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java并发编程实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C#线程参考手册
第1章 定义线程
1.1 线程的定义
1.1.1 多任务
1.1.2 进程
1.1.3 线程
1.2 .NET和C#对线程的支持
1.2.1 System.Appdomai

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C#线程参考手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>POSIX多线程程序设计
序言
第1章 概述
1.1 舀水的程序员
1.2 术语定义
1.3 异步编程是直观的
1.4 关于本书的实例
1.5 异步编程举例

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>POSIX多线程程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程核心技术（第2版）
前言
第1章　Java多线程技能1
1.1　进程和多线程概述1
1.2　使用多线程5
1.2.1　继承Thread类5
1.2.2　使用常见命令分析线程的信息8
1.2.3　线程随机性的展现11
1.2.4　执行start()的顺序不代表执行run()的顺序12
1.2.5　实现Runnable接口13
1.2.6　使用Runnable接口实现多线程的优点14
1.2.7　实现Runnable接口与继承Thread类的内部流程16
1.2.8　实例变量共享造成的非线程安全问题与解决方案17
1.2.9　Servlet技术造成的非线程安全问题与解决方案21
1.2.10　留意i--与System.out.println()出现的非线程安全问题24
1.3　currentThread()方法26
1.4　isAlive()方法29
1.5　sleep(long millis)方法31
1.6　sleep(long millis, int nanos)方法33
1.7　StackTraceElement[] getStackTrace()方法33
1.8　static void dumpStack()方法35
1.9　static Map<Thread, StackTrace-Element[]> getAllStackTraces()方法36
1.10　getId()方法38
1.11　停止线程38
1.11.1　停止不了的线程39
1.11.2　判断线程是否为停止状态41
1.11.3　能停止的线程—异常法43
1.11.4　在sleep状态下停止线程47
1.11.5　用stop()方法暴力停止线程49
1.11.6　stop()方法与java.lang.ThreadDeath异常51
1.11.7　使用stop()释放锁给数据造成不一致的结果52
1.11.8　使用“return;”语句停止线程的缺点与解决方案54
1.12　暂停线程57
1.12.1　suspend()方法与resume()方法的使用57
1.12.2　suspend()方法与resume()方法的缺点—独占58
1.12.3　suspend()方法与resume()方法的缺点—数据不完整62
1.13　yield()方法63
1.14　线程的优先级64
1.14.1　线程优先级的继承特性65
1.14.2　优先级的规律性66
1.14.3　优先级的随机性68
1.14.4　优先级对线程运行速度的影响70
1.15　守护线程71
1.16　本章小结73
第2章　对象及变量的并发访问74
2.1　synchronized同步方法74
2.1.1　方法内的变量为线程安全74
2.1.2　实例变量非线程安全问题与解决方案77
2.1.3　同步synchronized在字节码指令中的原理80
2.1.4　多个对象多个锁81
2.1.5　将synchronized方法与对象作为锁84
2.1.6　脏读89
2.1.7　synchronized锁重入91
2.1.8　锁重入支持继承的环境93
2.1.9　出现异常，锁自动释放94
2.1.10　重写方法不使用synchronized96
2.1.11　public static boolean holdsLock(Object obj)方法的使用99
2.2　synchronized同步语句块99
2.2.1　synchronized方法的弊端99
2.2.2　synchronized同步代码块的使用102
2.2.3　用同步代码块解决同步方法的弊端104
2.2.4　一半异步，一半同步105
2.2.5　synchronized代码块间的同步性108
2.2.6　println()方法也是同步的110
2.2.7　验证同步synchronized(this)代码块是锁定当前对象的110
2.2.8　将任意对象作为锁113
2.2.9　多个锁就是异步执行116
2.2.10　验证方法被调用是随机的118
2.2.11　不同步导致的逻辑错误及其解决方法121
2.2.12　细化验证3个结论124
2.2.13　类Class的单例性129
2.2.14　静态同步synchronized方法与synchronized(class)代码块130
2.2.15　同步syn static方法可以对类的所有对象实例起作用135
2.2.16　同步syn(class)代码块可以对类的所有对象实例起作用137
2.2.17　String常量池特性与同步相关的问题与解决方案138
2.2.18　同步synchronized方法无限等待问题与解决方案141
2.2.19　多线程的死锁143
2.2.20　内置类与静态内置类146
2.2.21　内置类与同步：实验1149
2.2.22　内置类与同步：实验2151
2.2.23　锁对象改变导致异步执行153
2.2.24　锁对象不改变依然同步执行156
2.2.25　同步写法案例比较158
2.3　volatile关键字159
2.3.1　可见性的测试159
2.3.2　原子性的测试168
2.3.3　禁止代码重排序的测试176
2.4　本章小结187
第3章　线程间通信188
3.1　wait/notify机制188
3.1.1　不使用wait/notify机制实现线程间通信188
3.1.2　wait/notify机制191
3.1.3　wait/notify机制的原理192
3.1.4　wait()方法的基本使用192
3.1.5　完整实现wait/notify机制194
3.1.6　使用wait/notify机制实现list.size()等于5时的线程销毁195
3.1.7　对业务代码进行封装198
3.1.8　线程状态的切换201
3.1.9　wait()方法：立即释放锁202
3.1.10　sleep()方法：不释放锁203
3.1.11　notify()方法：不立即释放锁204
3.1.12　interrupt()方法遇到wait()方法206
3.1.13　notify()方法：只通知一个线程208
3.1.14　notifyAll()方法：通知所有线程211
3.1.15　wait(long)方法的基本使用212
3.1.16　wait(long)方法自动向下运行需要重新持有锁214
3.1.17　通知过早问题与解决方法217
3.1.18　wait条件发生变化与使用while的必要性220
3.1.19　生产者/消费者模式的实现224
3.1.20　通过管道进行线程间通信—字节流250
3.1.21　通过管道进行线程间通信—字符流253
3.1.22　实现wait/notify的交叉备份256
3.2　join()方法的使用259
3.2.1　学习join()方法前的铺垫259
3.2.2　join()方法和interrupt()方法出现异常261
3.2.3　join(long)方法的使用263
3.2.4　join(long)方法与sleep(long)方法的区别264
3.2.5　join()方法后面的代码提前运行—出现意外 268
3.2.6　join()方法后面的代码提前运行—解释意外270
3.2.7　join(long millis, int nanos)方法的使用273
3.3　类ThreadLocal的使用273
3.3.1　get()方法与null274
3.3.2　类ThreadLocal存取数据流程分析275
3.3.3　验证线程变量的隔离性277
3.3.4　解决get()方法返回null的问题282
3.3.5　验证重写initialValue()方法的隔离性283
3.4　类InheritableThreadLocal的使用284
3.4.1　类ThreadLocal不能实现值继承285
3.4.2　使用InheritableThreadLocal体现值继承特性286
3.4.3　值继承特性在源代码中的执行流程288
3.4.4　父线程有最新的值，子线程仍是旧值291
3.4.5　子线程有最新的值，父线程仍是旧值293
3.4.6　子线程可以感应对象属性值的变化294
3.4.7　重写childValue()方法实现对继承的值进行加工297
3.5　本章小结298
第4章　Lock对象的使用299
4.1　使用ReentrantLock类299
4.1.1　使用ReentrantLock实现同步299
4.1.2　验证多代码块间的同步性301
4.1.3　await()方法的错误用法与更正304
4.1.4　使用await()和signal()实现wait/notify机制307
4.1.5　await()方法暂停线程运行的原理309
4.1.6　通知部分线程—错误用法312
4.1.7　通知部分线程—正确用法314
4.1.8　实现生产者/消费者模式一对一交替输出317
4.1.9　实现生产者/消费者模式多对多交替输出319
4.1.10　公平锁与非公平锁321
4.1.11　public int getHoldCount()方法的使用324
4.1.12　public final int getQueue Length()方法的使用325
4.1.13　public int getWaitQueue-Length (Condition condition)方法的使用327
4.1.14　public final boolean has-QueuedThread (Thread thread)方法的使用328
4.1.15　public final boolean has-QueuedThreads()方法的使用329
4.1.16　public boolean hasWaiters (Con-dition condition)方法的使用331
4.1.17　public final boolean isFair()方法的使用332
4.1.18　public boolean isHeldBy-CurrentThread()方法的使用333
4.1.19　public boolean isLocked()方法的使用334
4.1.20　public void lockInterruptibly()方法的使用335
4.1.21　public boolean tryLock()方法的使用336
4.1.22　public boolean tryLock (long timeout, TimeUnit unit)方法的使用338
4.1.23　public boolean await (long time, TimeUnit unit)方法的使用339
4.1.24　public long awaitNanos(long nanosTimeout)方法的使用341
4.1.25　public boolean awaitUntil(Date deadline)方法的使用342
4.1.26　public void awaitUninterru-ptibly()方法的使用344
4.1.27　实现线程按顺序执行业务346
4.2　使用ReentrantReadWriteLock类349
4.2.1　ReentrantLock类的缺点349
4.2.2　ReentrantReadWriteLock类的使用—读读共享351
4.2.3　ReentrantReadWriteLock类的使用—写写互斥352
4.2.4　ReentrantReadWriteLock类的使用—读写互斥352
4.2.5　ReentrantReadWriteLock类的使用—写读互斥354
4.3　本章小结355
第5章　定时器Timer356
5.1　定时器Timer的使用356
5.1.1　schedule(TimerTask task, Datetime)方法的测试356
5.1.2　schedule(TimerTask task, Date firstTime, long period)方法的测试366
5.1.3　schedule(TimerTask task, long delay)方法的测试374
5.1.4　schedule(TimerTask task, long delay, long period)方法的测试374
5.1.5　scheduleAtFixedRate (TimerTask task, Date firstTime, long period)方法的测试375
5.2　本章小结384
第6章　单例模式与多线程385
6.1　立即加载/饿汉模式385
6.2　延迟加载/懒汉模式387
6.2.1　延迟加载/懒汉模式解析387
6.2.2　延迟加载/懒汉模式的缺点388
6.2.3　延迟加载/懒汉模式的解决方案390
6.3　使用静态内置类实现单例模式399
6.4　序列化与反序列化的单例模式实现400
6.5　使用static代码块实现单例模式402
6.6　使用enum枚举数据类型实现单例模式404
6.7　完善使用enum枚举数据类型实现单例模式405
6.8　本章小结407
第7章　拾遗增补408
7.1　线程的状态408
7.1.1　验证NEW、RUNNABLE和TERMINATED410
7.1.2　验证TIMED_WAITING411
7.1.3　验证BLOCKED412
7.1.4　验证WAITING414
7.2　线程组415
7.2.1　线程对象关联线程组：一级关联416
7.2.2　线程对象关联线程组：多级关联417
7.2.3　线程组自动归属特性418
7.2.4　获取根线程组419
7.2.5　线程组中加线程组420
7.2.6　组内的线程批量停止421
7.2.7　递归取得与非递归取得组内对象422
7.3　Thread.activeCount()方法的使用423
7.4　Thread.enumerate(Thread tarray[])方法的使用423
7.5　再次实现线程执行有序性424
7.6　SimpleDateFormat非线程安全426
7.6.1　出现异常426
7.6.2　解决异常的方法1428
7.6.3　解决异常的方法2430
7.7　线程中出现异常的处理431
7.7.1　线程出现异常的默认行为431
7.7.2　使用setUncaughtException-Handler()方法进行异常处理432
7.7.3　使用setDefaultUncaughtExce-ptionHandler()方法进行异常处理433
7.8　线程组内处理异常434
7.9　线程异常处理的优先性437
7.10　本章小结442
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程编程核心技术（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java线程
前言
第一章 线程简介
java术语
线程概述
为什么要使用线程？
总结
第二章 java线程api
通过thread类创建线程
使用runable接口的线程
线程的生命周期
线程命名
访问线程
线程的启动、停止和连接
总结
第三章 同步技术
银行的例子
异步读取数据
.一个进行同步操作的类
同步块
嵌套锁
死锁
返回到银行的例子
同步静态方法
总结
第四章 等待和通知
返回到银行的例子
等待和通知
wait（）、notify（）和notifyall（）
wait（）和sleep（）
线程中断
静态方法（有关同步的细节）
总结
第五章 java线程编程的例子
数据结构和容器
简单的同步例子
一个网络服务器类
asyncinputstream类
使用tcpserver和asynclnputstream
总结
第六章 java线程调度
线程调度概述
何时调度是重要的
调度和线程优先级
常见的调度实现
本地调度支持
其他线程调度方法
总结
第七章 java线程调度例子
线程池
循环调度
作业调度
总结
第八章 和同步相关的高级主题
同步术语
预防死锁
锁饥饿
非线程安全的类
总结
第九章 多处理器机器上的并行化
单线程程序并行化
内层循环线程化
循环输出
多处理器扩展
总结
第十章 线程组
线程组概念
创建线程组
线程组方法
操作线程组
线程组、线程和安全
总结
附录一 其他主题
附录二 异常和错误
词汇表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java线程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java线程编程
第一部分  线
程
第1章  线程简介　3
1.1  什么是线程　4
1.2  为什么使用多线程　4
1.2.1  与用户的更佳交互　4
1.2.2  同步动作的模拟　5

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java线程编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Windows环境下的多线程编程原理与应用
第一章 概述
1 进程与线程概念
……
第二章 面向对象技术与C++语言概述
1 面向对象技术概述
……
第三章 Windows环境中的多线程实现
1 Win32 API中的基本线程函数
……
第四章 线程间通信概述
1 线程之间通信的方法
……
第五章 互斥及其应用
1 互斥的实现算法
……
第六章 临界段及其应用
1 临界段的概念
……
第七章 事件及其应用
1 事件的基本概念
……
第八章 信号量及其应用
第九章 附加论题
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Windows环境下的多线程编程原理与应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Unity游戏设计与实现
第0章　游戏开发前的准备　　1
0.1　Unity入门　Concept　　2
0.1.1　概要　　2
0.1.2　游戏对象　　3
0.1.3　组件　　5
0.1.4　资源　　8
0.1.5　流程　　10
0.1.6　场景　　11
0.1.7　预设　　13
0.1.8　小结　　16
0.2　先来复习一下Unity的基础知识吧　Concept　　17
0.2.1　脚本一览　　17
0.2.2　本章小节　　18
0.2.3　本章开发的小游戏　　18
0.3　入门教程（上）——创建项目　Tips　　18
0.3.1　概要　　18
0.3.2　创建新项目　　19
0.3.3　创建地面（创建游戏对象）　　20
0.3.4　创建场景，保存项目　　21
0.3.5　调整场景视图的摄像机　　23
0.3.6　创建方块和小球（创建游戏对象并调整坐标）　　24
0.3.7　运行游戏　　27
0.3.8　摄像机的便捷功能　　28
0.3.9　修改游戏对象的名字　　28
0.3.10　模拟物理运动（添加Rigidbody组件）　　29
0.3.11　让玩家角色跳起来（添加游戏脚本）　　30
0.3.12　修改游戏对象的颜色（创建材质）　　35
0.3.13　调整游戏画面的尺寸（调整播放器设置）　　36
0.3.14　小结　　38
0.4　入门教程（下）——让游戏更有趣　Tips　　38
0.4.1　概要　　38
0.4.2　让小球飞起来（物理运动和速度）　　38
0.4.3　创建大量小球（预设游戏对象）　　39
0.4.4　整理项目视图　　41
0.4.5　发射小球（通过脚本创建游戏对象）　　43
0.4.6　删除画面外的小球（通过脚本删除游戏对象）　　46
0.4.7　防止玩家角色在空中起跳（发生碰撞时的处理）　　48
0.4.8　禁止玩家角色旋转（抑制旋转）　　50
0.4.9　让玩家角色不被弹开（设置重量）　　51
0.4.10　让小球强烈反弹（设置物理材质）　　52
0.4.11　消除“漂浮感”（调整重力大小）　　54
0.4.12　调整摄像机的位置　　56
0.4.13　修复空中起跳的bug（区分碰撞对象）　　57
0.4.14　小结　　63
0.5　关于预设　Tips　　64
0.5.1　概要　　64
0.5.2　改良“小方块”游戏对象　　64
0.5.3　预设与对象实例　　65
0.5.4　预设和实例的变更　　67
0.5.5　小结　　70
0.6　C#和JavaScript的对比　Tips　　71
0.6.1　概要　　71
0.6.2　类的定义　　72
0.6.3　变量的定义　　72
0.6.4　函数的定义 　　73
0.6.5　作用域　　74
0.6.6　静态函数和静态变量的定义　　74
0.6.7　泛型方法的调用　　74
0.6.8　Bool类型和字符串类型　　75
0.6.9　数组　　75
0.6.10　小结　　75
第1章　点击动作游戏——怪物　　77
1.1　玩法介绍　How to Play　　78
1.2　简单的操作和爽快感　Concept　　80
1.2.1　脚本一览　　80
1.2.2　本章小节　　82
1.3　无限滚动的背景　Tips　　82
1.3.1　关联文件　　82
1.3.2　概要　　82
1.3.3　背景组件的显示位置　　83
1.3.4　小结　　85
1.4　无限滚动的背景的改良　Tips　　85
1.4.1　关联文件　　85
1.4.2　概要　　86
1.4.3　稍作尝试　　86
1.4.4　背景组件显示位置的改良　　87
1.4.5　小结　　89
1.5　怪物出现模式的管理　Tips　　89
1.5.1　关联文件　　89
1.5.2　概要　　89
1.5.3　怪物出现的时间点　　90
1.5.4　怪物出现模式的变化　　92
1.5.5　小结　　96
1.6　武士和怪物的碰撞检测　Tips　　96
1.6.1　关联文件　　96
1.6.2　概要　　96
1.6.3　分别对各个怪物进行碰撞检测时的问题　　97
1.6.4　把怪物编成小组　　98
1.6.5　小结　　100
1.7　得分高低的判定　Tips　　100
1.7.1　概要　　100
1.7.2　武士的攻击判定　　100
1.7.3　判断在多近的距离斩杀　　101
1.7.4　小结　　104
1.8　使被砍中的怪物向四处飞散　Tips　　104
1.8.1　概要　　104
1.8.2　想象一下“圆锥体”　　104
1.8.3　具体的计算方法　　106
1.8.4　小结　　108
第2章　拼图游戏——迷你拼图　　109
2.1　玩法介绍　How to Play　　110
排列拼图碎片，拼出最后的图案！　　110
2.2　流畅的拖曳操作　Concept　　112
2.2.1　脚本一览　　112
2.2.2　本章小节　　112
2.3　点住碎片的任意位置拖动　Tips　　114
2.3.1　关联文件　　114
2.3.2　概要　　114
2.3.3　透视变换和逆透视变换　　114
2.3.4　被点击处即为光标的位置　　114
2.3.5　测试拖曳碎片的中心　　117
2.3.6　小结　　118
2.4　打乱拼图碎片　Tips　　118
2.4.1　关联文件　　118
2.4.2　概要　　118
2.4.3　设置拼图碎片的坐标为随机数　　118
2.4.4　改进策略　　119
2.4.5　小结　　124
第3章　吃豆游戏——地牢吞噬者　　125
3.1　玩法介绍　How to Play　　126
3.2　适时进退和逆转的机会　Concept　　128
3.2.1　脚本一览　　128
3.2.2　本章小节　　130
3.3　平滑的网格移动　Tips　　130
3.3.1　关联文件　　130
3.3.2　概要　　130
3.3.3　能够改变方向的时机　　131
3.3.4　穿过网格的时机　　131
3.3.5　小结　　133
3.4　地图数据　Tips　　134
3.4.1　关联文件　　134
3.4.2　概要　　134
3.4.3　文本文件的格式　　134
3.4.4　扩展编辑器的功能　　139
3.4.5　小结　　141
3.5　摄像机变焦功能的运用　Tips　　141
3.5.1　关联文件　　141
3.5.2　概要　　141
3.5.3　调整策略　　142
3.5.4　摄像机的视野　　143
3.5.5　缓动动画　　145
3.5.6　变焦效果的代码实现　　146
3.5.7　小结　　149
3.6　幽灵的AI　Tips　　149
3.6.1　关联文件　　149
3.6.2　概要　　149
3.6.3　跟踪的算法　　150
3.6.4　埋伏等待型、包围攻击型和随机型　　153
3.6.5　观察幽灵的行动　　155
3.6.6　小结　　157
第4章　3D声音探索游戏——In the Dark Water　　159
4.1　玩法介绍　How to Play　　160
4.2　只依靠声音　Concept　　162
4.2.1　脚本一览　　162
4.2.2　本章小节　　164
4.3　仅依靠声音定位　Tips　　164
4.3.1　概要　　164
4.3.2　3D 声音的特性　　164
4.3.3　用于实验的项目　　166
4.3.4　小结　　167
4.4　3D声音的控制　Tips　　167
4.4.1　关联文件　　167
4.4.2　概要　　167
4.4.3　3D 声音的设置　　167
4.4.4　按一定间隔发出声音　　168
4.4.5　声音的淡出　　169
4.4.6　小结　　170
4.5　潜水艇的操纵　Tips　　171
4.5.1　关联文件　　171
4.5.2　概要　　171
4.5.3　操作方法　　171
4.5.4　转弯速度的衰减　　173
4.5.5　小结　　177
4.6　声纳的制作方法　Tips　　177
4.6.1　概要　　177
4.6.2　Perspective和Ortho　　178
4.6.3　Dark Water的声纳摄像机　　179
4.6.4　摄像机和对象的层　　180
4.6.5　稍作尝试　　183
4.6.6　摄像机的视口　　184
4.6.7　小结　　185
第5章　节奏游戏——摇滚女孩　　187
5.1　玩法介绍　How to Play　　188
5.2　Band-girl的世界　Concept　　189
5.2.1　脚本一览　　190
5.2.2　本章小节　　190
5.3　显示点击时刻的节拍标记　Tips　　192
5.3.1　关联文件　　192
5.3.2　概要　　192
5.3.3　定位单元　　192
5.3.4　标记的显示　　195
5.3.5　小结　　198
5.4　判断是否配合了音乐点击　Tips　　198
5.4.1　关联文件　　198
5.4.2　概要　　198
5.4.3　得分高低的判断　　198
5.4.4　避免重复判断　　200
5.4.5　小结　　205
5.5　演出数据的管理和执行　Tips　　205
5.5.1　关联文件　　205
5.5.2　概要　　205
5.5.3　事件数据的检索　　205
5.5.4　定位单元和执行单元　　207
5.5.5　小结　　211
5.6　其他调整功能　Tips　　211
5.6.1　关联文件　　211
5.6.2　概要　　211
5.6.3　什么是turn around　　212
5.6.4　显示时刻的偏移值　　212
5.6.5　定位条　　214
5.6.6　显示标记的行号　　216
5.6.7　小结　　216
第6章　全方位滚动射击游戏——噬星者　　217
6.1　玩法介绍　How to Play　　218
6.2　功能强大的激光制导　Concept　　219
6.2.1　脚本一览　　220
6.2.2　本章小节　　220
6.3　索敌激光的碰撞检测　Tips　　222
6.3.1　关联文件　　222
6.3.2　概要　　222
6.3.3　索敌激光的碰撞检测　　222
6.3.4　碰撞网格的生成方法　　224
6.3.5　确认碰撞网格　　229
6.3.6　小结　　229
6.4　不会重复的锁定　Tips　　230
6.4.1　关联文件　　230
6.4.2　概要　　230
6.4.3　锁定的管理　　230
6.4.4　小结　　233
6.5　制导激光　Tips　　233
6.5.1　关联文件　　233
6.5.2　概要　　233
6.5.3　根据TrailRenderer生成网格　　233
6.5.4　制导激光的移动　　234
6.5.5　稍作尝试　　238
6.5.6　小结　　238
6.6　消息窗口　Tips　　239
6.6.1　关联文件　　239
6.6.2　概要　　239
6.6.3　消息队列和显示缓冲区　　239
6.6.4　小结　　244
第7章　消除动作解谜游戏——吃月亮　　245
7.1　玩法介绍　How to Play　　246
7.2　爽快的连锁和有趣的方块移动　Concept　　248
7.2.1　脚本一览　　248
7.2.2　本章小节　　250
7.3　同色方块相邻与否的判断　Tips　　250
7.3.1　关联文件　　250
7.3.2　概要　　250
7.3.3　连结与连锁　　250
7.3.4　不停地检测相邻方块　　251
7.3.5　递归调用　　253
7.3.6　用于测试连结检测的项目　　256
7.3.7　防止无限循环检测　　257
7.3.8　小结　　258
7.4　方块的初始设置　Tips　　259
7.4.1　关联文件　　259
7.4.2　概要　　259
7.4.3　颜色的选择方法　　259
7.4.4　随机选取方块的摆放位置　　262
7.4.5　小结　　264
7.5　动画的父子构造关系　Tips　　264
7.5.1　关联文件　　264
7.5.2　概要　　264
7.5.3　方块的运动　　264
7.5.4　动画的父子构造——用于测试的项目　　267
7.5.5　《吃月亮》中面板的位置和角度的计算　　272
7.5.6　小结　　274
7.6　方块的平滑移动　Tips　　274
7.6.1　关联文件　　274
7.6.2　概要　　274
7.6.3　数组的索引和画面上的位置　　275
7.6.4　桶列方法　　277
7.6.5　小结　　280
第8章　跳跃动作游戏——猫跳纸窗　　281
8.1　玩法介绍　How to Play　　282
8.2　刺激的跳跃　Concept　　284
8.2.1　脚本一览　　284
8.2.2　本章小节　　286
8.3　角色的状态管理　Tips　　286
8.3.1　关联文件　　286
8.3.2　概要　　286
8.3.3　角色的动作　　286
8.3.4　状态的迁移　　287
8.3.5　状态管理的流程　　288
8.3.6　小结　　292
8.4　可以控制高度的跳跃　Tips　　293
8.4.1　关联文件　　293
8.4.2　概要　　293
8.4.3　跳跃的物理规律　　293
8.4.4　自由控制跳跃高度的操作　　294
8.4.5　小结　　297
8.5　窗户纸的碰撞检测　Tips　　297
8.5.1　关联文件　　297
8.5.2　概要　　297
8.5.3　“碰撞”的内部实现机制　　297
8.5.4　窗户对象　　299
8.5.5　矛盾的碰撞结果　　299
8.5.6　平滑地穿过格子眼　　309
8.5.7　小结　　312
第9章　角色扮演游戏——村子里的传说　　313
9.1　玩法介绍　How to Play　　314
9.2　移动简单，人人都是主人公　Concept　　316
9.2.1　脚本一览　　316
9.2.2　本章小节　　318
9.3　事件和Actor　Tips　　318
9.3.1　关联文件　　318
9.3.2　概要　　318
9.3.3　事件　　318
9.3.4　事件的数据结构　　322
9.3.5　Actor　　324
9.3.6　事件的执行　　327
9.3.7　试着执行一个事件　　330
9.3.8　小结　　332
9.4　游戏内参数　Tips　　332
9.4.1　关联文件　　332
9.4.2　概要　　332
9.4.3　游戏内参数　　332
9.4.4　小结　　336
9.5　事件文件的读取　Tips　　336
9.5.1　关联文件　　336
9.5.2　概要　　336
9.5.3　文件的读取　　336
9.5.4　小结　　340
9.6　特殊的事件　Tips　　341
9.6.1　关联文件　　341
9.6.2　概要　　341
9.6.3　选项指令　　341
9.6.4　宝箱事件　　343
9.6.5　进入屋子的事件　　345
9.6.6　小结　　346
第10章　驾驶游戏——迷踪赛道　　347
10.1　玩法介绍　How to Play　　348
10.2　自行创建，即作即用　Concept　　350
10.2.1　脚本一览　　350
10.2.2　本章小节　　352
10.2.3　关于Car Tutorial脚本　　352
10.3　透视变换和逆透视变换　Tips　　352
10.3.1　关联文件　　352
10.3.2　概要　　352
10.3.3　透视变换　　353
10.3.4　逆透视变换　　355
10.3.5　小结　　357
10.4　多边形网格的生成方法　Tips　　358
10.4.1　关联文件　　358
10.4.2　概要　　358
10.4.3　生成道路的中心线　　359
10.4.4　多边形的生成方法　　361
10.4.5　生成道路多边形　　362
10.4.6　急转弯时的多边形重叠　　367
10.4.7　用于测试多边形生成的项目　　368
10.4.8　小结　　368
10.5　模型的变形　Tips　　368
10.5.1　关联文件　　368
10.5.2　概要　　368
10.5.3　变形后顶点的位置坐标　　369
10.5.4　小结　　373
10.6　点缀实例　Tips　　373
10.6.1　关联文件　　373
10.6.2　概要　　373
10.6.3　生成基准线　　374
10.6.4　把树木设置到基准线上　　378
10.6.5　小结　　382
后记　　383
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Unity游戏设计与实现
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Visual C++6.0高级编程技术-MFC与多线程篇
第1章 按扭控件
1.1 CButton类和CBitmapButton类
  1.1.1 CButton类与CBitmapButton类的类声明
  1.1.2 CButton类与CBitmapButton类的类方法
  1.1.3 CButton类与CBitmapButton类的按钮样式
  1.1.4 CButton类与CBitmapButton类的创建与使用
1.2 设计特殊效果按钮
  1.2.1设计一个圆形按钮
  1.2.2设计一个三角形按钮
  1.2.3设计一个包含图形和文本的按钮
1.3 程序实例
1.4小结
第2章 下拉列表框控件
2.1设计一个CComboBox颜色拾取器
2.2扩展CComboColorPicker
2.3程序实例
2.4小结

第３章 编辑控件
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Visual C++6.0高级编程技术-MFC与多线程篇
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Visual Basic.NET线程参考手册
第1章 定义线程
1 线程的定义
……
第2章 .NET中的线程
1 System.Threading命名空间
……
第3章 使用线程
1 为何担心同步
……
第4章 设计模式
1 应用程序中的多线程
……
第5章 线程应用程序的伸缩
1 什么是线程池管理
……
第6章 调试与跟踪线程
1 创建应用程序代码
……
第7章 联网与线程
1 在.NET中的联网
……
附录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Visual Basic.NET线程参考手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>网络编程新冲浪Java2.0网络・多线程编程实例教程（含CD）
目录
第一篇Java语言初步
第1章概述．
1．1Java的历史
1．1．l什么是Java
l．1．2Java带来的影响
l．l．3Java语言的应用前景
1．2Java语言的特点
1．2．1Java是简单的．
1．2．2Java是面向对象的
1．2．3Java是静态类型的
1．2．4JaVa是编译型的
1．2．5Java是体系结构中立的
1．2．6Java是健全的
1．2．7Java是小巧的
1．2．8Java是多线程的
1．2．9Java是可收集无用的存储单元的
1．2．10Java是快速的
1．2．11Java是安全的
1．3几种Java语言的开发工具简介
1．3．1Java如何进行布局管理
1．3．2Java Workshop 2．0
1．3．3JBuilder 1.0
1．3．4VisalAge for Java Enterprise Version 1.0
1．3．5Visual Cafe for Java Database Development Edition 2.0
1．4对Java语言的常见误解
1．4．IJava是HTML的扩充
1．4．2Java是一种很容易学会的编程语言
1．4．3Java是一个简单的编程环境
1．4．4Java将成为所有平台的统一编程语
1．4．5Java是解释型的，它对于特殊平台的重要应用太慢了
l。4．6所有的Java程序都在Web页中运行
1．4．7Java消除了CGI编程的需要
1．4．8Java将彻底改变客户／服务器计算
1．4．9使用Java，用户可以用500美元的Internet设备来代替计算机
1．4．10Java将允许放弃基于部件的计算模式
1．5简单的Java程序
第2章Java程序设计基础
2．1定义常量
2．1．1常量
2．1．2整型常量
2．1．3实型常量
2．l．4字符型常量
2．1．5字符串型常量
2．2定义变量
2．2．1变量
2．2．2整型变量
2．2．3实型变量
2．2．4字符型变量
2．2．5布尔型变量
2．2．6各类数值型数据间的混合运算
2．3运算符和表达式
2．3．1算术运算符
2．3．2关系运算符
2．3．3布尔逻辑运算符
2．3．4位运算符
2．3．5赋值运算符
2．3．6条件运算符
2．3．7表达式
2．4Java流程控制

2．4．1分支语句
2．4．2循环语句
第3章Java面向对象程序设计
3．1面向对象的基本概念
3．1．1对象
3．1．2消息
3．1．3类
3．2对象及对象的使用
3．1．1创建对象
3．2．2引用对象
3．2．3撤消对象
3．3类的定义及实现
3．3．1类说明
3．3．2类体
3．4方法的定义和实现
3．4．l方法的说明
3．4．2方法体
3．4．3构造子
3．4．4析构子
3．5重用技术
3．5．1继承
3．5．2界面
第4章数组与字符串
4．l数组
4．1．1数组的声明及初始化
4．1．2数组的引用
4．1．3多维数组
4．2字符串
4．2．l不可变字符串
4．2．2可变字符串
第5章Java的输入与输出流
5．1InputStream类
5．1．1read()方法
5．1．2available()方法
5．1．3close()方法
5．l．4可标记流
5．1．5skip()方法
5．2OutputStream类
5．2．1write()方法
5．2．2flush()方法
5．2．3close()方法
5．3字节数组的输入输出（I／O）
5．3．1ByteArrayInputStream类
5．3．2ByteArrayInputStream类
5．3．3StringBufferInputStream类
5．4文件输入输出（I／O）
5．4．1File类
5．4．2FileDescriptor类
5．4．3FileInputStream类
5．4．4FileOutputStream类
5．5过滤I／O
5．5．1FilterInputStream类
5．5．2FilterOuputStream类
5．5．3缓冲I/O
5．5．4数据I/O
5．5．5管道I/O
5．6随机访问文件
5．6．1创建随机访问文件
5．6．2访问信息
5．6．3增加信息
5．6．4追加信息例子
5．7StreamTokenizer类
5．8URL输入流
第二篇　IBM VisualAge For Java 3.0程序设计
第6章VisuaAge　for　Java IDE介绍
6．1安装IBM VisualAge for Java
6．1．l运行安装之前
6．1．2安装步骤
6．2建立你的第一个Java小程序
6．2．1创建Java小程序
6．2．2测试Java小程序
6．3VisualAge for JavaIDE概述

6．3．1IDE简介
6．3．2重要概念
6．4测览VisualAge for Java IDE
6．4．1工作台窗口
6．4．2浏览器
6．4．3VisualAge for Java IDE中的符号
与快捷键
6．4．4定制VisualAgeforJavaIDE
6．4．5IDE失效或工作区毁坏
6．4．6Applctat览器
6．4．7查找程序元素
6．4．8在IDE中打印
6．4．9访问上下文敏感API帮助
6．4．10使用快速启动窗口
6．4．11生成类的HTML文档
第7章在IDE中开发应用程序
7．l创建程序和程序元素
7．1．1创建项目
7．1．2创建包
7．1．3Java小程序与Java应用程序
7．1．4生成类
7．1．5生成方法存根
7．1．6创建接口
7．1．7创建方法
7．1．8创建字段
7．1．9生成字段存取方法
7．1．10编写与格式化源代码
7．1．11从资源库向工作区添加项目和包
7．1．12从资源库向工作区添加类和方法
7．1．13更换工作区的修订版
7．1．14动态装入外部类
7．1．15从文件系统导入文件
7．1．16从另一个资源库中导入
7．1．17在项目中包含资源文件
7．2修改程序元素
7．2．1保存更改的代码
7．2．2存储工作区
7．2．3编译代码
7．2．4查找和修正问题
7．2．5版本化程序元素
7．2．6创建开放修订版
7．2．7从工作区删除程序元素
7．2．8复制或移动程序元素
7．2．9重命名程序元素
7．2．10比较两个程序元素
7．2．11比较程序元素的修订版
7．2．12合并类或接日的修订版．
7．3在代码片段编辑测试窗中组织用户思路
7．3．1代码片段编辑测试窗
7．3．2实验代码片段
7．4管理资源库
7．4．1备份资源库
7．4．2从资源库中删除程序元素
7．4．3恢复程序元素
7．4．4压缩资源库
第8章运行和调试程序
8．1运行程序
8．1．l在IDE中运行Applet
8．1．2在IDE中运行应用程序
8．1．3对Applet作运行时更改
8．2调试程序
8．2．1在开发周期中用集成调试器调试
8．2．2手工启动集成调试器
8．2．3挂起、恢复和终止线程
8．2．4在源代码中设置断点
8．2．5配置并设置断点条件
8．2．6在外部类中设置断点
8．2．7选择调试器要捕获的异常
8．2．8清除并且禁止断点
8．2．9检查并修改变量值
8．2．10单步跟踪方法
8．2．11调试过程中修改代码
8．2．12在集成调试器中求值表达式
8．2．13单步执行时监视一个表达式的值
8．2．14生成类跟踪
8．2．15设置调试器选项
8．3导出代码
8．3．1导出代码
8．3．2导出字节码
8．3．3导出资源文件
8．3．4调试导出
8．3．5导出到另一个资源库
第9章异常处理
9．1异常的概念
9．1．1采用新的出错处理机制
9．1．2异常
9．2异常处理
9．2．1try／catch块
9．2．2finally块
9．2．3try／catch／finally组合使用
9．3异常类的层次
9．3．l运行异常
9．3．2非运行异常
9．4激反异
9．5创建自己的异常
9．5．1定义一个新的异常类
9．5．2创建程序中的异常
第10章Java网络编程
10．l网络基础
10．1．l计算机网络的概念、特点及功能
10．1．2网络协议简介
10．1．3IP地址
10．2用InetAddress类进行Internet寻址
10．2．1java．net包
10．2．2用InetAddress类进行Internet寻址
10．3用UM类访问网络资源
10．3．l什么是URL
10．3．2URL类的创建与地址查询
10．3．3用URL类访问资源
10．3．4URL Connection类
10．3．5AppletContext类
10．4Java的Socket通讯机制
10．4．1Socket类
10．4．2有连接通讯方式的客户／服务器应用工作模式
10．5Java的数据报通讯机制
10．5．1数据报简介
10．5．2数据报方式的通讯过程
10．5．3数据报的创建
10．6网络安全措施
10．6．1网络安全与SecurityManager类
10．6．2覆盖Security Manager类中的检验方法
10．6．3安装新的SecurityManager类对象
第11章多线程程序设计
11．1线程相关概念
11．2Java线程的创建
11．2．l继承Thread父类
11．2．2实现hanable接日
11．3线程状态与线程控制
11．4线程组
11‘5线程优先级和线程调度
11．6线程同步和死锁
第12章图形用户界面构件
12．1抽象窗口工具集AWT简介
12．2GUI标准构件的使用方法
12．2．1Component类提供的方法
12．2．2添加构件到容器中
12．2．3改变构件的外观行为
12．3事件处理机制
12．3．l键盘事件
12．3．2鼠标事件
12．3．3动作（Action）事件
12．3．4其他事件
12．4创建用户界面
12，4．1按钮（Button）
12．4．2检查盒（Checkbox）
12．4．3选择框（Choice）
12．4．4标签（Label）
12．4．5列表（List）
12．4．6滚动条（Scrollbar）
12．4．7文本输入域（TextField ＆TextArea）
12．4．8框架（Frame）
12．4．9对话框（Dialog）
12．5布局控制

12．5．1流控制（FlowLayout）
12．5．2边界控制（BorderLayout）
12．5．3栅格控制（GridLayout）
12．5．4卡片控制（CardLayout）
12．5．5栅格包控制（GridBagLayout）
12．6创建和使用菜单．
12．6．1菜单（Menu）简介
12．6．2菜单的创建步骤
12．6．3菜单的事件处理
12．6．4菜单实例
第13章图形和图像
13．1应用components类作图
13．2应用Graphics类
13．2．1颜色
13．2．2作图方法
13．2．3设置大小
13．3处理图像
13．3．l应用MediaTracker
13．3．2创建脱屏图像板面
13．3．3producer和consumer


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>网络编程新冲浪Java2.0网络・多线程编程实例教程（含CD）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程与Socket：实战微服务框架
第1章  多线程基础
1.1  多线程的概念
1.1.1  进程与线程
1.1.2  并发与并行
1.1.3  线程状态
1.2  Thread线程类
1.2.1  基本用法与思考
1.2.2  常用方法介绍
1.2.3  wait和sleep的区别
1.2.4  sleep和yield的区别
1.3  Runnable接口
1.4  线程池
1.4.1  Executors
1.4.2  ExecutorService
1.4.3  ThreadPoolExecutor
1.4.4  基本用法与思考
1.5  Callable与Future
1.6  线程安全与效率
1.6.1  什么是线程安全
1.6.2  线程同步
1.6.3  饥饿与公平
1.6.4  锁与死锁
1.6.5  线程中断
1.7  编程进阶
1.7.1  volatile关键字
1.7.2  synchronized关键字
1.7.3  wait/notify/notifyAll
1.7.4  CAS操作
1.7.5  atomic包
1.7.6  Lock自旋锁
1.7.7  Condition条件变量
1.7.8  线程安全容器
1.7.9  ThreadLocal类
1.7.10  CountDownLatch计数器
1.7.11  CyclicBarrier栅栏
1.7.12  Semaphore信号量
1.7.13  fork/join框架
第2章  Socket基础
2.1  TCP与Socket
2.2  TCP的通信过程
2.2.1  基本过程
2.2.2  建立连接
2.2.3  全双工异步通信
2.2.4  断开连接
2.2.5  优雅地断开
2.2.6  半……连接
2.3  通信方式
2.3.1  长连接与短连接
2.3.2  线程模型
2.3.3  拆包与组包
2.3.4  断包与粘包
2.3.5  数据包的结构
2.4  BIO
2.4.1  典型编程模型
2.4.2  关键API概述
2.4.3  字符流传输
2.4.4  字节流传输
2.4.5  传输多笔数据
2.5  NIO
2.5.1  NIO简介
2.5.2  Buffer
2.5.3  Channel
2.5.4  Selector
2.5.5  Scatter/Gather
2.5.6  Pipe
2.5.7  内存映像文件
2.5.8  文件传输示例
2.5.9  “聊天室”示例
2.6  AIO
2.6.1  AIO简介
2.6.2  关键API概述
2.6.3  示例代码
第3章  Spring与Spring Cloud
3.1  Spring简介
3.2  IoC容器
3.2.1  IoC的概念
3.2.2  Spring中的bean
3.2.3  XML配置方式
3.2.4  注解配置方式
3.2.5  用Java类来配置
3.2.6  BeanFactory与FactoryBean
3.2.7  ApplicationContext与ApplicationContextAware
3.2.8  动态注册bean配置
3.2.9  ApplicationListener与容器事件
3.3  bean的基本配置
3.3.1  scope属性
3.3.2  parent与abstract
3.3.3  factory-bean与factory-method
3.3.4  bean的初始化与释放
3.4  依赖注入
3.4.1  setter注入
3.4.2  工厂方式注入
3.4.3  构造器注入
3.4.4  注解注入
3.5  Spring Boot
3.5.1  快速创建工程
3.5.2  编码与测试
3.5.3  打包部署
3.5.4  辅助开发工具
3.5.5  监控功能
3.6  Spring Cloud
3.6.1  Spring Cloud简介
3.6.2  架构设计
3.6.3  创建应用
3.6.4  服务的注册与发现
3.6.5  服务配置
3.6.6  Ribbon负载均衡
3.6.7  Feign服务调用
3.6.8  Hystrix
3.6.9  Zuul服务路由
3.6.10  服务监控
第4章  动态代理
4.1  代理模式
4.2  静态代理
4.3  类的装载
4.4  Java反射
4.5  JDK动态代理
4.6  CGLIB动态代理
4.7  Java Compiler API
4.8  Javassist动态代理
第5章  对象序列化
5.1  什么是序列化
5.2  Java序列化
5.2.1  基本用法
5.2.2  关于serialVersionUID
5.2.3  自定义序列化
5.2.4  封装实现代码
5.3  Hessian序列化
5.4  Kryo序列化
5.5  FST序列化
5.6  其他序列化组件
5.7  集成与扩展
5.7.1  优雅地集成
5.7.2  使用Java SPI
5.7.3  使用Spring
第6章  框架设计
6.1  总体结构
6.1.1  逻辑架构
6.1.2  框架设计概述
6.1.3  RPC原理
6.1.4  工程结构
6.1.5  依赖的jar包
6.1.6  主要的类
6.2  初始化过程
6.2.1  Spring配置
6.2.2  应用节点的启动
6.2.3  Web容器的启动
6.2.4  RpcCore的初始化
6.2.5  RpcContext的初始化
6.3  服务的暴露
6.3.1  服务暴露配置
6.3.2  方法配置与ID
6.3.3  内置的服务方法
6.3.4  服务提供方本地调用器
6.3.5  服务提供方代理生成器
6.3.6  注册要暴露的服务
6.4  服务的引用
6.4.1  服务引用配置
6.4.2  本地引用工厂类
6.4.3  注册本地引用工厂
6.4.4  本地引用与方法ID
6.5  服务的注册与发现
6.5.1  注册表集合
6.5.2  注册表的同步
6.5.3  注册表的解析
6.5.4  提交注册表
6.5.5  注册表推送
6.5.6  注册表检查
6.6  优雅地停机
6.6.1  停机的过程
6.6.2  停机钩子
6.6.3  监听Web容器的关闭
6.6.4  RpcCore的关闭
6.6.5  停机通知的处理
第7章  方法调用
7.1  方法调用类型
7.2  同步调用
7.2.1  同步调用的时序
7.2.2  同步调用的发起
7.2.3  负载均衡
7.2.4  指定服务提供者
7.2.5  失败转移
7.2.6  发送调用请求
7.2.7  处理调用请求
7.2.8  处理调用响应
7.3  异步调用
7.3.1  异步调用的时序
7.3.2  异步调用的发起
7.3.3  异步调用的执行
7.3.4  方法调用对象
7.4  同步/异步通知
7.5  异步回调
7.6  广播调用与广播通知
7.6.1  广播示例
7.6.2  广播代码
第8章  通信层实现
8.1  Socket通信框架
8.1.1  Netty与Mina
8.1.2  为什么要自己写
8.1.3  是NIO还是AIO
8.1.4  设计思路
8.1.5  实际结构
8.2  通信协议
8.2.1  传输对象
8.2.2  数据包结构
8.2.3  拆包与发送
8.2.4  接收并组包
8.3  连接的建立
8.3.1  工作模型
8.3.2  开始监听
8.3.3  发起连接
8.3.4  绑定连接
8.3.5  断线检测
第9章  性能测试与调优
9.1  性能调优概述
9.1.1  性能指标
9.1.2  性能瓶颈
9.1.3  环境因素
9.2  压力测试
9.2.1  测试方法
9.2.2  场景设计
9.2.3  测试环境
9.2.4  Dubbo配置
9.2.5  测试程序
9.3  线程池调优
9.3.1  调整线程池的大小
9.3.2  选择合适的队列
9.3.3  线程的管理逻辑
9.3.4  选择拒绝策略
9.4  优化线程同步
9.4.1  减少上下文切换
9.4.2  避免线程滥用
9.4.3  避免过多的锁
9.4.4  synchronized VS Lock
9.4.5  缩小锁的范围和粒度
9.4.6  线程分析工具
9.5  JVM调优
9.5.1  堆与栈
9.5.2  JVM内存的分代
9.5.3  GC分类
9.5.4  GC算法
9.5.5  分代GC
9.5.6  对象的引用
9.5.7  内存大小设置
9.5.8  内存调优工具
9.6  其他优化内容
9.6.1  避免使用反射
9.6.2  对象池
9.6.3  缓冲区队列
9.6.4  使用直接内存
9.6.5  缓存其他对象
9.6.6  协调与平衡
第10章  服务治理
10.1  服务治理概述
10.1.1  什么是服务治理
10.1.2  服务治理架构
10.1.3  服务治理接口
10.2  服务的定义
10.2.1  服务识别
10.2.2  接口定义
10.2.3  版本管理
10.2.4  协议适配
10.2.5  服务设计
10.2.6  服务的实现
10.2.7  依赖关系管理
10.3  服务的部署
10.3.1  服务的部署方式
10.3.2  自动化部署
10.3.3  服务的热部署
10.4  注册与发现
10.4.1  WSDL与UDDI
10.4.2  ZooKeeper的方案
10.4.3  Eureka的方案
10.4.4  Consul的方案
10.4.5  etcd的方案
10.4.6  注册中心集成方案
10.5  服务的控制
10.5.1  服务状态
10.5.2  服务控制
10.5.3  服务开关
10.5.4  服务模拟
10.5.5  黑白名单
10.5.6  “踢除”服务提供者
10.6  监控与限流
10.6.1  TPS监控与限流
10.6.2  响应时间的监控
10.6.3  调用链的监控
10.6.4  资源监控
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java多线程与Socket：实战微服务框架
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C#多线程编程实战(原书第2版)
译者序
前言
本书内容
准备事项
读者对象
下载示例代码
第1章 线程基础
1.1 简介
1.2 使用C#创建线程
1.3 暂停线程
1.4 线程等待
1.5 终止线程
1.6 检测线程状态
1.7 线程优先级
1.8 前台线程和后台线程
1.9 向线程传递参数
1.10 使用C#中的lock关键字
1.11 使用Monitor类锁定资源

1.12 处理异常
第2章 线程同步
2.1 简介

2.2 执行基本的原子操作

2.3 使用Mutex类

2.4 使用SemaphoreSlim类

2.5 使用AutoResetEvent类

2.6 使用ManualResetEventSlim类

2.7 使用CountDownEvent类

2.8 使用Barrier类

2.9 使用ReaderWriterLockSlim类

2.10 使用SpinWait类
第3章 使用线程池
3.1 简介
3.2 在线程池中调用委托
3.3 向线程池中放入异步操作
3.4 线程池与并行度
3.5 实现一个取消选项

3.6 在线程池中使用等待事件处理器及超时

3.7 使用计时器

3.8 使用BackgroundWorker组件
第4章 使用任务并行库
4.1 简介

4.2 创建任务

4.3 使用任务执行基本的操作

4.4 组合任务

4.5 将APM模式转换为任务

4.6 将EAP模式转换为任务

4.7 实现取消选项

4.8 处理任务中的异常

4.9 并行运行任务

4.10 使用TaskScheduler配置任务的执行
第5章 使用C#6.0
5.1 简介

5.2 使用await操作符获取异步任务结果

5.3 在lambda表达式中使用await操作符

5.4 对连续的异步任务使用await操作符

5.5 对并行执行的异步任务使用await操作符

5.6 处理异步操作中的异常

5.7 避免使用捕获的同步上下文

5.8 使用async void方法

5.9 设计一个自定义的awaitable类型

5.10 对动态类型使用await
第6章 使用并发集合
6.1 简介

6.2 使用ConcurrentDictionary

6.3 使用ConcurrentQueue实现异步处理

6.4 改变ConcurrentStack异步处理顺序

6.5 使用ConcurrentBag创建一个可扩展的爬虫

6.6 使用BlockingCollection进行异步处理
第7章 使用PLINQ
7.1 简介

7.2 使用Parallel类

7.3 并行化LINQ查询

7.4 调整PLINQ查询的参数

7.5 处理PLINQ查询中的异常

7.6 管理PLINQ查询中的数据分区

7.7 为PLINQ查询创建一个自定义的聚合器
第8章 使用Reactive Extensions
8.1 简介

8.2 将普通集合转换为异步的可观察集合

8.3 编写自定义的可观察对象

8.3.1 准备工作

8.3.2 实现方式

8.3.3 工作原理

8.4 使用Subject

8.5 创建可观察的对象

8.6 对可观察的集合使用LINQ查询

8.7 使用Rx创建异步操作
第9章 使用异步I/O
9.1 简介

9.2 异步地使用文件

9.3 编写一个异步的HTTP服务器和客户端

9.4 异步操作数据库

9.5 异步调用WCF服务
第10章 并行编程模式
10.1 简介

10.2 实现惰性求值的共享状态

10.3 使用BlockingCollection实现并行管道

10.4 使用TPL数据流实现并行管道

10.5 使用PLINQ实现Map/Reduce模式
第11章 更多信息
11.1 简介
11.2 在通用Windows平台应用中使用计时器

11.3 在通常的应用程序中使用WinRT

11.4 在通用Windows平台应用中使用BackgroundTask

11.5 在OS X上运行.NET内核应用程序

11.6 在Ubuntu Linux上运行.NET内核应用程序
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C#多线程编程实战(原书第2版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>UNIX系统编程: 通信、并发与线程
第一部分  基础知识
第1章    技术对程序的影响  3
1.1  术语的变化  3
1.2  时间和速度  5
1.3  多道程序设计和分时  6
1.4  应用层的并发  8
1.4.1  中断  8
1.4.2  信号  9
1.4.3  输入和输出  10
1.4.4  进程、线程和资源共享  10
1.4.5  具有共享内存的多个处理器  11
1.4.6  网络作为计算机  11
1.5  安全和容错  12
1.6  非法入侵造成的缓冲区溢出  13
1.6.1  缓冲区溢出的后果  14
1.6.2  缓冲区溢出和安全  16
1.7  UNIX标准  17
1.8  延伸阅读  19
第2章    程序、线程和进程  21
2.1  程序是如何成为进程的  21
2.2  线程和执行线程  22
2.3  程序映象的布局  23
2.4  库函数调用  26
2.5  函数返回值和错误  29
2.6  参数数组  31
2.6.1  用makeargv函数创建一个数组  32
2.6.2  makeargv函数的实现  34
2.7  线程安全函数  38
2.8  静态变量的使用  40
2.9  静态对象的结构  42
2.10  进程环境  48
2.11  进程终止  51
2.12  练习：一个env实用程序  54
2.13  练习：消息日志  55
2.14  延伸阅读  57
第3章    UNIX中的进程  58
3.1  进程标识符  58
3.2  进程状态  60
3.3  UNIX 进程创建和fork函数  63
3.4  wait函数  70
状态值  76
3.5  exec函数  77
3.6  后台进程和守护进程  83
3.7  临界区  86
3.8  练习：进程链  87
3.9  练习：进程扇  88
3.10  延伸阅读  89
第4章    UNIX I/O  90
4.1  设备术语  90
4.2  读/写  91
4.3  打开和关闭文件  102
4.4  select函数  107
4.5  poll函数  116
4.6  文件表示  119
4.6.1  文件描述符  119
4.6.2  文件指针和缓冲  122
4.6.3  文件描述符的继承  124
4.7  过滤器和重定向  128
4.8  文件控制  132
4.9  练习：原子日志  135
原子日志库  139
4.10  练习：cat实用程序  141
4.11  延伸阅读  143
第5章    文件和目录  144
5.1  UNIX文件系统导航  144
5.1.1  当前工作目录  145
5.1.2  搜索路径  150
5.2  目录访问  151
5.2.1  访问文件状态信息  153
5.2.2  确定文件的类型  156
5.3  UNIX文件系统实现  157
5.3.1  UNIX文件实现  158
5.3.2  目录实现  161
5.4  硬链接和符号链接  161
5.4.1  创建或删除一个链接  162
5.4.2  创建和删除符号链接  167
5.5  练习：which命令  172
5.6  练习：邮件通知程序  173
5.7  练习：新闻通知程序  176
5.8  练习：遍历目录  177
5.9  延伸阅读  179
第6章    UNIX特殊文件  180
6.1  管道  180
6.2  流水线  184
6.3  FIFO  189
6.4  管道与客户机-服务器模型  193
6.5  终端控制  200
规范和非规范的输入处理  208
6.6  音频设备  212
6.7  练习：音频  218
6.8  练习：屏障  220
6.9  练习：stty命令  221
6.10  练习：重提客户机-服务器  222
6.11  延伸阅读  222
第7章    项目：令牌环  224
7.1  环形拓扑  224
7.2  环的形成  226
7.3  环的探讨  232
7.4  简单通信  234
7.5  用令牌环实现互斥  235
7.6  用投票实现互斥  237
7.7  匿名环中的领导者选举  238
7.8  用于通信的令牌环  240
7.9  流水线预处理机  242
7.10  并行环算法  244
7.10.1  图像过滤  244
7.10.2  矩阵乘法  247
7.11  弹性环  248
7.12  延伸阅读  249
第二部分  异步事件
第8章    信号  253
8.1  信号的基本概念  253
8.2  信号的产生  254
8.3  对信号掩码和信号集进行操作  259
8.4  捕获和忽略信号—sigaction  266
8.5  等待信号—pause、sigsuspend和sigwait  272
8.5.1  pause函数  272
8.5.2  sigsuspend函数  274
8.5.3  sigwait函数  282
8.6  处理信号：错误和异步信号安全  283
8.7  用siglongjmp和sigsetjmp进行程序控制  286
8.8  使用异步I/O编程  288
8.9  练习：转储统计  300
8.10  练习：同时处理慢速设备  301
8.11  延伸阅读  301
第9章    时间和定时器  303
9.1  POSIX时间  303
9.1.1  用从Epoch开始的秒数表示时间  304
9.1.2  显示日期和时间  305
9.1.3  使用struct timeval表示时间  308
9.1.4  使用实时时钟  311
9.1.5  耗时和处理器时间的对比  313
9.2  睡眠函数  316
9.3  POSIX:XSI间隔定时器  319
9.4  实时信号  323
9.5  POSIX:TMR间隔定时器  328
9.6  定时器漂移、溢出和绝对时间  333
9.7  延伸阅读  344
第10章    项目：虚拟定时器  345
10.1  项目概述  345
10.2  简单的定时器  348
10.3  对5个定时器中的一个进行设置  351
10.3.1  virtualtimers对象  351
10.3.2  hardwaretimer对象  353
10.3.3  主程序实现  354
10.3.4  用show谱写定时器代码  355
10.4  使用多个定时器  361
10.4.1  设置多个定时器  364
10.4.2  用多个定时器进行测试  365
10.5  多定时器的健壮实现  369
10.6  POSIX:TMR定时器的实现  371
10.7  一个小型的cron工具mycron  372
10.8  延伸阅读  372
第11章    项目：破解shell  373
11.1  构建一个简单的shell  373
11.2  重定向  378
11.3  流水线  382
11.4  前台的信号处理  385
11.5  进程组、会话和控制终端  391
11.5.1  进程组  391
11.5.2  会话  393
11.6  ush中的后台进程  396
11.7  作业控制  403
11.8  ush的作业控制  407
11.8.1  一个作业列表对象  407
11.8.2  ush中的作业列表  409
11.8.3  ush中的作业控制  409
11.8.4  等待流水线时的进程行为  410
11.9  延伸阅读  411
第三部分  并  发
第12章    POSIX线程  415
12.1  监视文件描述符的方法  415
12.2  使用线程监视多个文件描述符  417
12.3  线程管理  420
12.3.1  用ID引用线程  421
12.3.2  创建一个线程  422
12.3.3  分离和连接  423
12.3.4  退出和取消  426
12.3.5  向线程传递参数并返回值  429
12.4  线程安全  438
12.5  用户级线程 VS 内核级线程  439
12.6  线程属性  442
12.6.1  线程状态  443
12.6.2  线程栈  444
12.6.3  线程调度  446
12.7  练习：并行文件复制  450
12.8  延伸阅读  451
第13章  线程同步  452
13.1  POSIX同步函数  452
13.2  互斥锁  453
13.2.1  创建并初始化一个互斥量  454
13.2.2  销毁一个互斥量  455
13.2.3  锁定和解锁互斥量  456
13.2.4  保护不安全的库函数  458
13.2.5  同步标志和全局值  459
13.2.6  让数据结构成为线程安全的  465
13.3  最多一次和至少一次的执行  467
13.4  条件变量  471
13.4.1  条件变量的创建和销毁  473
13.4.2  等待并通知条件变量  475
13.5  信号处理和线程  478
13.5.1  将信号定向到一个特定的线程中  479
13.5.2  为线程屏蔽信号  480
13.5.3  信号处理的专用线程  480
13.6  读者和写者  484
13.7  strerror_r实现  489
13.8  死锁和其他讨厌的问题  491
13.9  练习：多个屏障  492
13.10  延伸阅读  492
第14章  临界区和信号量  493
14.1  临界区的处理  493
14.2  信号量  496
14.3  POSIX:SEM匿名信号量  499
14.4  POSIX:SEM信号量操作  501
14.5  POSIX:SEM命名信号量  508
14.5.1  创建并打开命名信号量  509
14.5.2  关闭信号量并删除其链接  512
14.6  练习：许可管理器  514
14.6.1  license对象  515
14.6.2  runsim主程序  515
14.6.3  对许可管理器的扩展  516
14.7  延伸阅读  516
第15章  POSIX IPC  517
15.1  POSIX:XSI进程间通信  517
15.1.1  标识并访问IPC对象  518
15.1.2  在shell中访问POSIX:XSI IPC资源  519
15.2  POSIX:XSI信号量集  520
15.2.1  信号量的创建  521
15.2.2  信号量的控制  523
15.2.3  POSIX信号量集操作  525
15.3  POSIX:XSI共享内存  532
15.3.1  访问共享内存段  532
15.3.2  共享内存段的连接和分离  533
15.3.3  控制共享内存  534
15.3.4  共享内存示例  535
15.4  POSIX:XSI消息队列  541
访问消息队列  542
15.5  练习：POSIX匿名信号量  549
15.6  练习：POSIX命名信号量  550
15.7  练习：用共享内存实现管道  551
15.8  练习：用消息队列实现管道  554
15.9  延伸阅读  554
第16章  项目：生产者-消费者同步  555
16.1  生产者-消费者问题  555
16.2  受互斥锁保护的有界缓冲区  557
16.3  使用信号量的缓冲区实现  560
16.4  一个简单的生产者-消费者问题简介  566
16.5  使用条件变量的有界缓冲区  570
16.6  带有完成条件的缓冲区  571
16.7  并行文件复制  580
16.7.1  并行文件复制的生产者  580
16.7.2  并行文件复制的消费者  581
16.7.3  并行文件复制的main程序  582
16.7.4  并行文件复制的增强  582
16.8  线程化打印服务器  583
16.8.1  请求缓冲区  584
16.8.2  生产者线程  585
16.8.3  消费者线程  586
16.8.4  打印服务器  586
16.8.5  其他增强功能  586
16.9  延伸阅读  587
第17章  项目：非完全并行虚拟机  588
17.1  PVM的历史、术语和结构  588
17.2  非完全并行虚拟机  591
17.3  NTPVM项目概述  593
17.3.1  NEWTASK分组  596
17.3.2  DATA分组  596
17.3.3  DONE分组  597
17.4  调度程序的I/O和测试  598
17.4.1  用多个窗口测试  604
17.4.2  用远程日志测试  605
17.5  没有输入的单任务  607
17.6  顺序任务  608
17.6.1  输入线程  609
17.6.2  输出线程  610
17.7  并发任务  611
17.8  分组通信、广播和屏障  611
17.9  终止和信号  612
17.10  有序的消息传递  613
17.11  延伸阅读  613
第四部分  通  信
第18章  面向连接的通信  617
18.1  客户机-服务器模型  617
18.2  通信信道  618
18.3  面向连接的服务器策略  622
18.4  通用因特网通信接口（UICI）  625
18.4.1  处理错误  627
18.4.2  读和写  627
18.5  不同服务器策略的UICI实现  628
18.6  UICI客户机  631
18.7  UICI的套接字实现  637
18.7.1  socket函数  638
18.7.2  bind函数  639
18.7.3  listen函数  641
18.7.4  u_open函数的实现  642
18.7.5  accept函数  643
18.7.6  u_accept函数的实现  645
18.7.7  connect函数  646
18.7.8  u_connect函数的实现  647
18.8  主机名和IP地址  649
18.9  线程安全的UICI  658
18.10  练习：ping服务器  661
18.11  练习：音频的传输  662
18.12  延伸阅读  664
第19章  项目：WWW重定向  665
19.1  万维网  665
19.2  统一资源定位符（URL）   666
19.3  HTTP入门  668
19.3.1  客户端请求  669
19.3.2  服务器响应  669
19.3.3  HTTP消息交换  670
19.4  Web通信模式  673
19.4.1  隧道  673
19.4.2  代理  674
19.4.3  高速缓存和透明性  676
19.4.4  网关  678
19.5  单连接的通过型监控  679
19.6  隧道服务器的实现  682
19.7  用于测试的服务器驱动程序  682
19.8  HTTP头解析  684
19.9  简单的代理服务器  686
19.10  代理监视器  688
19.11  代理高速缓存  691
19.12  门户网站的网关  692
19.13  用于负载平衡的网关  692
19.14  事后的调查分析  693
19.14.1  线程和计时错误  693
19.14.2  未捕获的错误和错误的退出  694
19.14.3  书写风格和表示  695
19.14.4  糟糕的测试和结果表示  696
19.14.5  编程错误和不好的风格  697
19.15  延伸阅读  698
第20章  无连接通信和多播  699
20.1  无连接通信简介  699
20.2  无连接通信的简化接口  701
20.2.1  主机名和u_buf_t结构  703
20.2.2  UICI UDP的返回错误  703
20.2.3  UDP缓冲区大小和UICI UDP  703
20.3  简单-请求协议  704
20.4  请求-应答协议  710
20.5  有超时和重试的请求-应答  716
20.6  请求-应答-确认协议  722
20.7  UICI UDP的实现  723
20.7.1  u_openudp函数的实现  723
20.7.2  sendto函数  725
20.7.3  u_sendto和 u_sendtohost函数的实现  726
20.7.4  recvfrom函数  727
20.7.5  u_recvfrom和u_recvfromtimed函数的实现  728
20.7.6  主机名和u_buf_t  730
20.8  UDP和TCP的比较  732
20.9  多播  733
20.9.1  多播寻址  733
20.9.2  u_join函数的实现  735
20.9.3  u_leave函数的实现  736
20.10  练习：UDP端口服务器  737
20.11  练习：无状态文件服务器  738
远程文件服务  739
20.12  延伸阅读  740
第21章  项目：互联网广播  741
21.1  项目概述  741
21.2  音频设备模拟  744
21.3  具有一个节目和一个接收者的UDP实现  744
21.3.1  简单实现  744
21.3.2  接收者的终止  747
21.3.3  接收者缓冲来处理网络延迟  748
21.3.4  接收者缓冲来处理乱序传递  751
21.4  具有多个节目和接收者的UDP实现  754
21.4.1  多个节目和单个接收者  754
21.4.2  多个节目和多个接收者  755
21.5  音频广播的UDP实现  756
21.6  无线电广播的多播实现  758
21.7  TCP实现的差异  758
21.7.1  单个节目和单个接收者的TCP实现  759
21.7.2  多个节目和单个接收者的TCP实现  760
21.7.3  无线电广播的TCP实现  761
21.8  通过浏览器接收流式音频  764
21.8.1  使用浏览器助手应用程序  764
21.8.2  在你的Web服务器中设置一种新的mime类型  765
21.8.3  设置你的浏览器来处理新的mime类型  766
21.8.4  创建Web页面  766
21.8.5  使用预定义的mime类型  767
21.9  延伸阅读  767
第22章  项目：服务器性能  769
22.1  服务器性能成本  769
22.2  服务器架构  770
22.3  项目概述  774
22.4  单客户端驱动程序  775
22.4.1  处理一个连接  775
22.4.2  对响应进行编程  776
22.4.3  收集统计信息  777
22.4.4  测试客户端  777
22.5  多客户端驱动程序  778
另一种多客户端设计  781
22.6  实现每个请求一个线程和每个请求一个进程  781
22.7  线程工作者池策略  782
22.8  使用有界缓冲区的多线程工作者池  782
22.9  进程工作者池  783
22.10  磁盘I/O的影响  783
22.11  性能研究  787
22.11.1  基线测量  787
22.11.2  波动性的根源  788
22.11.3  测量错误  789
22.11.4  同步  792
22.11.5  普通的错误  793
22.11.6  要测量什么  794
22.11.7  数据分析和表示  796
22.12  报告撰写  797
22.12.1  引言  797
22.12.2  设计、实现和测试  798
22.12.3  实验  798
22.12.4  结果和分析  799
22.12.5  结论  799
22.12.6  参考文献  799
22.13  延伸阅读  800
附录A  UNIX基础  801
附录B  重启库  819
附录C  UICI实现  829
附录D  日志函数  846
附录E  POSIX扩展  864
参考文献  867
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>UNIX系统编程: 通信、并发与线程
