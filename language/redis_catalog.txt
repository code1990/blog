>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Redis设计与实现
第1章 引言	1
1.1 Redis版本说明	1
1.2 章节编排	1
1.3 推荐的阅读方法	4
1.4 行文规则	4
1.5 配套网站	5
第一部分 数据结构与对象
第2章 简单动态字符串	8
2.1 SDS的定义	9
2.2 SDS与C字符串的区别	10
2.3 SDS API	17
2.4 重点回顾	18
2.5 参考资料	18
第3章 链表	19
3.1 链表和链表节点的实现	20
3.2 链表和链表节点的API	21
3.3 重点回顾	22
第4章 字典	23
4.1 字典的实现	24
4.2 哈希算法	27
4.3 解决键冲突	28
4.4 rehash 	29
4.5 渐进式rehash	32
4.6 字典API	36
4.7 重点回顾	37
第5章 跳跃表	38
5.1 跳跃表的实现	39
5.2 跳跃表API	44
5.3 重点回顾	45
第6章 整数集合	46
6.1 整数集合的实现	46
6.2 升级	48
6.3 升级的好处	50
6.4 降级	51
6.5 整数集合API	51
6.6 重点回顾	51
第7章 压缩列表	52
7.1 压缩列表的构成	52
7.2 压缩列表节点的构成	54
7.3 连锁更新	57
7.4 压缩列表API	59
7.5 重点回顾	59
第8章 对象	60
8.1 对象的类型与编码	60
8.2 字符串对象	64
8.3 列表对象	68
8.4 哈希对象	71
8.5 集合对象	75
8.6 有序集合对象	77
8.7 类型检查与命令多态	81
8.8 内存回收	84
8.9 对象共享	85
8.10 对象的空转时长	87
8.11 重点回顾	88
第二部分 单机数据库的实现
第9章 数据库	90
9.1 服务器中的数据库	90
9.2 切换数据库	91
9.3 数据库键空间	93
9.4 设置键的生存时间或过期时间	99
9.5 过期键删除策略	107
9.6 Redis的过期键删除策略	108
9.7 AOF、RDB和复制功能对过期键的处理	111
9.8 数据库通知	113
9.9 重点回顾	117
第10章 RDB持久化	118
10.1 RDB 文件的创建与载入	119
10.2 自动间隔性保存	121
10.3 RDB 文件结构	125
10.4 分析RDB文件	133
10.5 重点回顾	137
10.6 参考资料	137
第11章 AOF持久化	138
11.1 AOF持久化的实现	139
11.2 AOF文件的载入与数据还原	142
11.3 AOF重写	143
11.4 重点回顾	150
第12章 事件	151
12.1 文件事件	151
12.2 时间事件	156
12.3 事件的调度与执行	159
12.4 重点回顾	161
12.5 参考资料	161
第13章 客户端	162
13.1 客户端属性	163
13.2 客户端的创建与关闭	172
13.3 重点回顾	174
第14章 服务器	176
14.1 命令请求的执行过程	176
14.2 serverCron函数	184
14.3 初始化服务器	192
14.4 重点回顾	196
第三部分 多机数据库的实现
第15章 复制	198
15.1 旧版复制功能的实现	199
15.2 旧版复制功能的缺陷	201
15.3 新版复制功能的实现	203
15.4 部分重同步的实现	204
15.5 PSYNC 命令的实现	209
15.6 复制的实现	211
15.7 心跳检测	216
15.8 重点回顾	218
第16章 Sentinel	219
16.1 启动并初始化Sentinel 	220
16.2 获取主服务器信息	227
16.3 获取从服务器信息	229
16.4 向主服务器和从服务器发送信息	230
16.5 接收来自主服务器和从服务器的频道信息	231
16.6 检测主观下线状态	234
16.7 检查客观下线状态	236
16.8 选举领头Sentinel 	238
16.9 故障转移	240
16.10 重点回顾	243
16.11 参考资料	244
第17章 集群	245
17.1 节点	245
17.2 槽指派	251
17.3 在集群中执行命令	258
17.4 重新分片	265
17.5 ASK错误	267
17.6 复制与故障转移	273
17.7 消息	281
17.8 重点回顾	288
第四部分 独立功能的实现
第18章 发布与订阅	290
18.1 频道的订阅与退订	292
18.2 模式的订阅与退订	295
18.3 发送消息	298
18.4 查看订阅信息	300
18.5 重点回顾	303
18.6 参考资料	304
第19章 事务	305
19.1 事务的实现	306
19.2 WATCH 命令的实现	310
19.3 事务的ACID 性质	314
19.4 重点回顾	319
19.5 参考资料	320
第20章 Lua脚本	321
20.1 创建并修改Lua 环境	322
20.2 Lua 环境协作组件	327
20.3 EVAL命令的实现	329
20.4 EVALSHA 命令的实现	332
20.5 脚本管理命令的实现	333
20.6 脚本复制	336
20.7 重点回顾	342
20.8 参考资料	343
第21章 排序	344
21.1 SORT <key> 命令的实现	345
21.2 ALPHA 选项的实现	347
21.3 ASC 选项和DESC 选项的实现	348
21.4 BY选项的实现	350
21.5 带有ALPHA 选项的BY 选项的实现	352
21.6 LIMIT 选项的实现	353
21.7 GET选项的实现	355
21.8 STORE 选项的实现	358
21.9 多个选项的执行顺序	359
21.10 重点回顾	361
第22章 二进制位数组	362
22.1 位数组的表示	363
22.2 GETBIT命令的实现	365
22.3 SETBIT 命令的实现	366
22.4 BITCOUNT 命令的实现	369
22.5 BITOP 命令的实现	376
22.6 重点回顾	377
22.7 参考资料	377
第23章 慢查询日志	378
23.1 慢查询记录的保存	380
23.2 慢查询日志的阅览和删除	382
23.3 添加新日志	383
23.4 重点回顾	385
第24章 监视器	386
24.1 成为监视器	387
24.2 向监视器发送命令信息	387
24.3 重点回顾	388
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Redis设计与实现
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Redis开发与运维
序　言
前　言
致　谢
第1章　初识Redis 1
1.1　盛赞Redis 1
1.2　Redis特性 2
1.3　Redis使用场景 5
1.3.1　Redis可以做什么 5
1.3.2　Redis不可以做什么 5
1.4　用好Redis的建议 6
1.5　正确安装并启动Redis 6
1.5.1　安装Redis 7
1.5.2　配置、启动、操作、关闭Redis 8
1.6　Redis重大版本 11
1.7　本章重点回顾 14
第2章　API的理解和使用 15
2.1　预备 15
2.1.1　全局命令 15
2.1.2　数据结构和内部编码 18
2.1.3　单线程架构 19
2.2　字符串 21
2.2.1　命令 22
2.2.2　内部编码 27
2.2.3　典型使用场景 28
2.3　哈希 31
2.3.1　命令 32
2.3.2　内部编码 35
2.3.3　使用场景 36
2.4　列表 38
2.4.1　命令 38
2.4.2　内部编码 43
2.4.3　使用场景 44
2.5　集合 46
2.5.1　命令 46
2.5.2　内部编码 50
2.5.3　使用场景 51
2.6　有序集合 52
2.6.1　命令 53
2.6.2　内部编码 59
2.6.3　使用场景 59
2.7　键管理 60
2.7.1　单个键管理 60
2.7.2　遍历键 67
2.7.3　数据库管理 70
2.8　本章重点回顾 73
第3章　小功能大用处 74
3.1　慢查询分析 74
3.1.1　慢查询的两个配置参数 75
3.1.2　最佳实践 77
3.2　Redis Shell 78
3.2.1　redis-cli详解 78
3.2.2　redis-server详解 82
3.2.3　redis-benchmark详解 83
3.3　Pipeline 84
3.3.1　Pipeline概念 84
3.3.2　性能测试 85
3.3.3　原生批量命令与Pipeline对比 86
3.3.4　最佳实践 87
3.4　事务与Lua 87
3.4.1　事务 87
3.4.2　Lua用法简述 90
3.4.3　Redis与Lua 92
3.4.4　案例 94
3.4.5　Redis如何管理Lua脚本 96
3.5　Bitmaps 98
3.5.1　数据结构模型 98
3.5.2　命令 98
3.5.3　Bitmaps分析 101
3.6　HyperLogLog 102
3.7　发布订阅 105
3.7.1　命令 106
3.7.2　使用场景 108
3.8　GEO 109
3.9　本章重点回顾 112
第4章　客户端 113
4.1　客户端通信协议 113
4.2　Java客户端Jedis 117
4.2.1　获取Jedis 117
4.2.2　Jedis的基本使用方法 118
4.2.3　Jedis连接池的使用方法 122
4.2.4　Redis中Pipeline的使用方法 125
4.2.5　Jedis的Lua脚本 126
4.3　Python客户端redis-py 128
4.3.1　获取redis-py 128
4.3.2　redis-py的基本使用方法 128
4.3.3　redis-py中Pipeline的使用方法 130
4.3.4　redis-py中的Lua脚本使用方法 130
4.4　客户端管理 131
4.4.1　客户端API 132
4.4.2　客户端相关配置 145
4.4.3　客户端统计片段 145
4.5　客户端常见异常 146
4.6　客户端案例分析 149
4.6.1　Redis内存陡增 149
4.6.2　客户端周期性的超时 151
4.7　本章重点回顾 153
第5章　持久化 154
5.1　RDB 154
5.1.1　触发机制 154
5.1.2　流程说明 155
5.1.3　RDB文件的处理 156
5.1.4　RDB的优缺点 156
5.2　AOF 157
5.2.1　使用AOF 157
5.2.2　命令写入 157
5.2.3　文件同步 158
5.2.4　重写机制 159
5.2.5　重启加载 161
5.2.6　文件校验 162
5.3　问题定位与优化 162
5.3.1　fork操作 162
5.3.2　子进程开销监控和优化 163
5.3.3　AOF追加阻塞 165
5.4　多实例部署 166
5.5　本章重点回顾 167
第6章　复制 168
6.1　配置 168
6.1.1　建立复制 168
6.1.2　断开复制 170
6.1.3　安全性 170
6.1.4　只读 170
6.1.5　传输延迟 171
6.2　拓扑 171
6.3　原理 172
6.3.1　复制过程 172
6.3.2　数据同步 175
6.3.3　全量复制 178
6.3.4　部分复制 181
6.3.5　心跳 183
6.3.6　异步复制 184
6.4　开发与运维中的问题 184
6.4.1　读写分离 184
6.4.2　主从配置不一致 186
6.4.3　规避全量复制 186
6.4.4　规避复制风暴 187
6.5　本章重点回顾 188
第7章　Redis的噩梦：阻塞 189
7.1　发现阻塞 189
7.2　内在原因 191
7.2.1　API或数据结构使用不合理 191
7.2.2　CPU饱和 193
7.2.3　持久化阻塞 194
7.3　外在原因 195
7.3.1　CPU竞争 195
7.3.2　内存交换 195
7.3.3　网络问题 196
7.4　本章重点回顾 199
第8章　理解内存 200
8.1　内存消耗 200
8.1.1　内存使用统计 200
8.1.2　内存消耗划分 201
8.1.3　子进程内存消耗 203
8.2　内存管理 204
8.2.1　设置内存上限 204
8.2.2　动态调整内存上限 204
8.2.3　内存回收策略 205
8.3　内存优化 209
8.3.1　redisObject对象 209
8.3.2　缩减键值对象 210
8.3.3　共享对象池 211
8.3.4　字符串优化 213
8.3.5　编码优化 216
8.3.6　控制键的数量 223
8.4　本章重点回顾 225
第9章　哨兵 226
9.1　基本概念 226
9.1.1　主从复制的问题 227
9.1.2　高可用 227
9.1.3　Redis Sentinel的高可用性 229
9.2　安装和部署 232
9.2.1　部署拓扑结构 232
9.2.2　部署Redis数据节点 233
9.2.3　部署Sentinel节点 234
9.2.4　配置优化 236
9.2.5　部署技巧 243
9.3　API 244
9.4　客户端连接 249
9.4.1　Redis Sentinel的客户端 249
9.4.2　Redis Sentinel客户端基本实现原理 249
9.4.3　Java操作Redis Sentinel 251
9.5　实现原理 254
9.5.1　三个定时监控任务 254
9.5.2　主观下线和客观下线 256
9.5.3　领导者Sentinel节点选举 258
9.5.4　故障转移 261
9.6　开发与运维中的问题 262
9.6.1　故障转移日志分析 262
9.6.2　节点运维 268
9.6.3　高可用读写分离 271
9.7　本章重点回顾 272
第10章　集群 274
10.1　数据分布 274
10.1.1　数据分布理论 274
10.1.2　Redis数据分区 277
10.1.3　集群功能限制 278
10.2　搭建集群 278
10.2.1　准备节点 278
10.2.2　节点握手 280
10.2.3　分配槽 282
10.2.4　用redis-trib.rb搭建集群 284
10.3　节点通信 287
10.3.1　通信流程 287
10.3.2　Gossip消息 287
10.3.3　节点选择 290
10.4　集群伸缩 291
10.4.1　伸缩原理 291
10.4.2　扩容集群 293
10.4.3　收缩集群 301
10.5　请求路由 305
10.5.1　请求重定向 305
10.5.2　Smart客户端 309
10.5.3　ASK重定向 318
10.6　故障转移 323
10.6.1　故障发现 323
10.6.2　故障恢复 329
10.6.3　故障转移时间 334
10.6.4　故障转移演练 334
10.7　集群运维 336
10.7.1　集群完整性 336
10.7.2　带宽消耗 337
10.7.3　Pub/Sub广播问题 337
10.7.4　集群倾斜 338
10.7.5　集群读写分离 339
10.7.6　手动故障转移 341
10.7.7　数据迁移 344
10.8　本章重点回顾 344
第11章　缓存设计 346
11.1　缓存的收益和成本 346
11.2　缓存更新策略 347
11.3　缓存粒度控制 349
11.4　穿透优化 350
11.5　无底洞优化 352
11.6　雪崩优化 359
11.7　热点key重建优化 360
11.8　本章重点回顾 364
第12章　开发运维的“陷阱” 365
12.1　Linux配置优化 365
12.1.1　内存分配控制 365
12.1.2　swappiness 367
12.1.3　THP 369
12.1.4　OOM killer 370
12.1.5　使用NTP 371
12.1.6　ulimit 371
12.1.7　TCP backlog 372
12.2　flushall/flushdb误操作 372
12.2.1　缓存与存储 373
12.2.2　借助AOF机制恢复 373
12.2.3　RDB有什么变化 374
12.2.4　从节点有什么变化 374
12.2.5　快速恢复数据 374
12.3　安全的Redis 375
12.3.1　Redis密码机制 377
12.3.2　伪装危险命令 378
12.3.3　防火墙 380
12.3.4　bind 380
12.3.5　定期备份数据 381
12.3.6　不使用默认端口 381
12.3.7　使用非root用户启动 381
12.4　处理bigkey 382
12.4.1　bigkey的危害 382
12.4.2　如何发现 382
12.4.3　如何删除 383
12.4.4　最佳实践思路 386
12.5　寻找热点key 386
12.6　本章重点回顾 391
第13章　Redis监控运维云平台CacheCloud 392
13.1　CacheCloud是什么 392
13.1.1　现有问题 393
13.1.2　CacheCloud基本功能 393
13.2　快速部署 395
13.2.1　CacheCloud环境需求 395
13.2.2　CacheCloud快速开始 395
13.3　机器部署 397
13.3.1　部署脚本 398
13.3.2　添加机器 399
13.4　接入应用 400
13.4.1　总体流程 401
13.4.2　账户申请和审批 401
13.4.3　应用申请和审批 402
13.4.4　客户端接入 405
13.5　用户功能 407
13.5.1　应用统计信息 408
13.5.2　实例列表 409
13.5.3　应用详情 409
13.5.4　命令曲线 409
13.5.5　CacheCloud Redis Shell控制台 410
13.5.6　慢查询 410
13.5.7　应用拓扑 411
13.6　运维功能 413
13.6.1　应用运维 413
13.6.2　接入已存在的Redis节点 415
13.6.3　Redis配置模板 416
13.6.4　迁移工具 417
13.6.5　监控报警 420
13.6.6　系统配置管理 422
13.7　客户端上报 423
13.7.1　客户端上报整体设计 424
13.7.2　Jedis核心代码修改 424
13.7.3　带上报功能的客户端 426
13.7.4　CacheCloud客户端统计 427
13.8　本章重点回顾 429
第14章　Redis配置统计字典 430
14.1　info系统状态说明 430
14.1.1　命令说明 430
14.1.2　详细说明 431
14.2　standalone配置说明和分析 436
14.2.1　总体配置 436
14.2.2　最大内存及策略 437
14.2.3　AOF相关配置 437
14.2.4　RDB相关配置 438
14.2.5　慢查询配置 438
14.2.6　数据结构优化配置 439
14.2.7　复制相关配置 439
14.2.8　客户端相关配置 440
14.2.9　安全相关配置 440
14.3　Sentinel配置说明和分析 440
14.4　Cluster配置说明和分析 441
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Redis开发与运维
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Redis实战
译者序
序言
前言
致谢
关于本书
关于封面插图
第一部分：基础知识
第1章 初识Redis
1.1 Redis简介
1.2 Redis数据结构简介
1.3 Redis，你好！
1.4 寻求帮助
1.5 小结
第2章 使用Redis构建Web应用
2.1 登录和cookie缓存
2.2 使用Redis实现购物车
2.3 网页缓存
2.4 数据行缓存
2.5 网页分析
2.6 小结
第二部分：核心概念
第3章 Redis命令
3.1 字符串
3.2 列表
3.3 集合
3.4 散列
3.5 有序集合
3.6 发布与订阅
3.7 其他命令
3.8 小结
第 4 章 数据安全与性能保障
4.1 持久化选项
4.2 复制
4.3 处理系统故障
4.4 Redis事务
4.5 非事务型流水线
4.6 关于性能方面的注意事项
4.7 小结
第 5 章 使用Redis构建支持程序
5.1 使用Redis来记录日志
5.2 计数器和统计数据
5.3 查找IP所属城市以及国家
5.4 服务的发现与配置
5.5 小结
第 6 章 使用 Redis 构建应用组件
6.1 自动补完
6.2 分布式锁
6.3 计数信号量
6.4 任务队列
6.5 消息拉取
6.6 使用 Redis 进行文件分发
6.7 小结
第 7 章 基于搜索的应用程序
7.1 使用 Redis 进行搜索
7.2 有序索引
7.3 广告定向
7.4 职位搜索
7.5 小结
第 8 章 构建简单的社交网站
8.1 用户和状态
8.2 定制时间线
8.3 关注者列表以及正在关注列表
8.4 状态消息的发布与删除
8.5 流 API
8.6 小结
第三部分：进阶内容
第 9 章 降低内存占用
9.1 短结构
9.2 分片结构
9.3 打包储存二进制位和字节
9.4 小结
第 10 章 扩展 Redis
10.1 扩展读性能
10.2 扩展写性能和内存容量
10.3 对复杂的查询进行扩展
10.4 小结
第 11 章 Redis 的 Lua 脚本编程
11.1 在不编写 C 代码的情况下添加新功能
11.2 使用 Lua 重写锁和信号量
11.3 移除 WATCH/MULTI/EXEC 事务
11.4 使用 Lua 对列表进行分片
11.5 小结
第四部分：附录
附录A 快速安装指南
A.1 在Debian Linux或者Ubuntu Linux上面安装Redis的方法
A.2 在OS X上面安装Redis的方法
A.3 在Windows上安装Redis的方法
A.4 你好Redis
附录B 其他资源和参考资料
B.1 提供帮助的论坛
B.2 入门议题
B.3 队列函数库以及一些其他用途的函数库
B.4 数据可视化和数据记录
B.5 数据源
B.6 Redis经验分享和相关文章
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Redis实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE互联网轻量级框架整合开发
第1部分  入门和技术基础
第1章  认识SSM框架和Redis	2
1.1  Spring框架	2
1.1.1  Spring IoC简介	2
1.1.2  Spring AOP	4
1.2  MyBatis简介	6
1.2.1  Hibernate简介	7
1.2.2  MyBatis	8
1.2.3  Hibernate和MyBatis的区别	11
1.3  Spring MVC简介	11
1.4  最流行的NoSQL——Redis	12
1.5  SSM+Redis结构框图及概述	13
第2章  Java设计模式	15
2.1  Java反射技术	15
2.1.1  通过反射构建对象	15
2.1.2  反射方法	17
2.1.3  实例	18
2.2  动态代理模式和责任链模式	19
2.2.1  JDK动态代理	20
2.2.2  CGLIB动态代理	22
2.2.3  拦截器	24
2.2.4  责任链模式	28
2.3  观察者（Observer）模式	30
2.3.1  概述	31
2.3.2  实例	32
2.4  工厂模式和抽象工厂模式	35
2.4.1  普通工厂（Simple Factory）模式	35
2.4.2  抽象工厂（Abstract Factory）模式	36
2.5  建造者（Builder）模式	38
2.5.1  概述	38
2.5.2  Builder模式实例	39
2.6  总结	41
第2部分  互联网持久框架——MyBatis
第3章  认识MyBatis核心组件	44
3.1  持久层的概念和MyBatis的特点	44
3.2  准备MyBatis环境	45
3.3  MyBatis的核心组件	46
3.4  SqlSessionFactory（工厂接口）	47
3.4.1  使用XML构建SqlSessionFactory	48
3.4.2  使用代码创建SqlSessionFactory	50
3.5  SqlSession	50
3.6  映射器	51
3.6.1  用XML实现映射器	52
3.6.2  注解实现映射器	53
3.6.3  SqlSession发送SQL	54
3.6.4  用Mapper接口发送SQL	55
3.6.5  对比两种发送SQL方式	55
3.7  生命周期	55
3.7.1  SqlSessionFactoryBuilder	56
3.7.2  SqlSessionFactory	56
3.7.3  SqlSession	56
3.7.4  Mapper	56
3.8  实例	57
第4章  MyBatis配置	63
4.1  概述	63
4.2  properties属性	64
4.2.1  property子元素	64
4.2.2  使用properties文件	65
4.2.3  使用程序传递方式传递参数	66
4.2.4  总结	66
4.3  settings设置	66
4.4  typeAliases别名	69
4.4.1  系统定义别名	69
4.4.2  自定义别名	72
4.5  typeHandler类型转换器	72
4.5.1  系统定义的typeHandler	73
4.5.2  自定义typeHandler	78
4.5.3  枚举typeHandler	81
4.5.4  文件操作	86
4.6  ObjectFactory（对象工厂）	87
4.7  插件	89
4.8  environments（运行环境）	89
4.8.1  transactionManager（事务管理器）	90
4.8.2  environment数据源环境	92
4.9  databaseIdProvider数据库厂商标识	95
4.9.1  使用系统默认的databaseIdProvider	95
4.9.2  不使用系统规则	98
4.10  引入映射器的方法	99
第5章  映射器	102
5.1  概述	102
5.2  select元素——查询语句	103
5.2.1  简单的select元素的应用	104
5.2.2  自动映射和驼峰映射	105
5.2.3  传递多个参数	106
5.2.4  使用resultMap映射结果集	109
5.2.5  分页参数RowBounds	110
5.3  insert元素——插入语句	112
5.3.1  概述	112
5.3.2  简单的insert语句的应用	113
5.3.3  主键回填	113
5.3.4  自定义主键	114
5.4  update元素和delete元素	114
5.5  sql元素	115
5.6  参数	116
5.6.1  概述	116
5.6.2  存储过程参数支持	117
5.6.3  特殊字符串的替换和处理（#和$）	117
5.7  resultMap元素	118
5.7.1  resultMap元素的构成	118
5.7.2  使用map存储结果集	119
5.7.3  使用POJO存储结果集	119
5.8  级联	120
5.8.1  MyBatis中的级联	121
5.8.2  建立POJO	124
5.8.3  配置映射文件	127
5.8.4  N+1问题	133
5.8.5  延迟加载	133
5.8.6  另一种级联	137
5.8.7  多对多级联	140
5.9  缓存	143
5.9.1  一级缓存和二级缓存	144
5.9.2  缓存配置项、自定义和引用	147
5.10  存储过程	149
5.10.1  IN和OUT参数存储过程	150
5.10.2  游标的使用	152
第6章  动态SQL	155
6.1  概述	155
6.2  if元素	156
6.3  choose、when、otherwise元素	156
6.4  trim、where、set元素	157
6.5  foreach元素	159
6.6  用test的属性判断字符串	159
6.7  bind元素	160
第7章  MyBatis的解析和运行原理	162
7.1  构建SqlSessionFactory过程	163
7.1.1  构建Configuration	165
7.1.2  构建映射器的内部组成	165
7.1.3  构建SqlSessionFactory	167
7.2  SqlSession运行过程	168
7.2.1  映射器（Mapper）的动态代理	168
7.2.2  SqlSession下的四大对象	172
7.2.3  SqlSession运行总结	179
第8章  插件	181
8.1  插件接口	181
8.2  插件的初始化	182
8.3  插件的代理和反射设计	183
8.4  常用的工具类——MetaObject	186
8.5  插件开发过程和实例	187
8.5.1  确定需要拦截的签名	187
8.5.2  实现拦截方法	189
8.5.3  配置和运行	191
8.5.4  插件实例——分页插件	192
8.6  总结	205
第3部分  Spring基础
第9章  Spring IoC的概念	208
9.1  Spring的概述	208
9.2  Spring IoC概述	210
9.2.1  主动创建对象	211
9.2.2  被动创建对象	213
9.2.3  Spring IoC阐述	214
9.3  Spring IoC容器	215
9.3.1  Spring IoC容器的设计	215
9.3.2  Spring IoC容器的初始化和依赖注入	218
9.3.3  Spring Bean的生命周期	219
9.4  小结	223
第10章  装配Spring Bean	224
10.1  依赖注入的3种方式	224
10.1.1  构造器注入	224
10.1.2  使用setter注入	225
10.1.3  接口注入	226
10.2  装配Bean概述	227
10.3  通过XML配置装配Bean	228
10.3.1  装配简易值	228
10.3.2  装配集合	229
10.3.3  命名空间装配	233
10.4  通过注解装配Bean	235
10.4.1  使用@Component装配Bean	236
10.4.2  自动装配——@Autowired	239
10.4.3  自动装配的歧义性（@Primary和@Qualifier）	241
10.4.4  装载带有参数的构造方法类	244
10.4.5  使用@Bean装配Bean	245
10.4.6  注解自定义Bean的初始化和销毁方法	245
10.5  装配的混合使用	246
10.6  使用Profile	249
10.6.1  使用注解@Profile配置	249
10.6.2  使用XML定义Profile	250
10.6.3  启动Profile	252
10.7  加载属性（properties）文件	254
10.7.1  使用注解方式加载属性文件	254
10.7.2  使用XML方式加载属性文件	257
10.8  条件化装配Bean	258
10.9  Bean的作用域	259
10.10  使用Spring表达式（Spring EL）	261
10.10.1  Spring EL相关的类	261
10.10.2  Bean的属性和方法	264
10.10.3  使用类的静态常量和方法	265
10.10.4  Spring EL运算	265
第11章  面向切面编程	267
11.1  一个简单的约定游戏	267
11.1.1  约定规则	267
11.1.2  读者的代码	269
11.1.3  笔者的代码	271
11.2  Spring AOP的基本概念	274
11.2.1  AOP的概念和使用原因	274
11.2.2  面向切面编程的术语	278
11.2.3  Spring对AOP的支持	280
11.3  使用@AspectJ注解开发Spring AOP	280
11.3.1  选择切点	281
11.3.2  创建切面	281
11.3.3  连接点	283
11.3.4  测试AOP	285
11.3.5  环绕通知	287
11.3.6  织入	289
11.3.7  给通知传递参数	289
11.3.8  引入	290
11.4  使用XML配置开发Spring AOP	293
11.4.1  前置通知、后置通知、返回通知和异常通知	294
11.4.2  环绕通知	296
11.4.3  给通知传递参数	297
11.4.4  引入	298
11.5  经典Spring AOP应用程序	299
11.6  多个切面	301
11.7  小结	306
第12章  Spring和数据库编程	307
12.1  传统的JDBC代码的弊端	307
12.2  配置数据库资源	309
12.2.1  使用简单数据库配置	309
12.2.2  使用第三方数据库连接池	310
12.2.3  使用JNDI数据库连接池	310
12.3  JDBC代码失控的解决方案——jdbcTemplate	311
12.3.1  jdbcTemplate的增、删、查、改	312
12.3.2  执行多条SQL	314
12.3.3  jdbcTemplate的源码分析	315
12.4  MyBatis-Spring项目	317
12.4.1  配置SqlSessionFactoryBean	318
12.4.2  SqlSessionTemplate组件	322
12.4.3  配置MapperFactoryBean	324
12.4.4  配置MapperScannerConfigurer	324
12.4.5  测试Spring+MyBatis	327
第13章  深入Spring数据库事务管理	330
13.1  Spring数据库事务管理器的设计	331
13.1.1  配置事务管理器	333
13.1.2  用Java配置方式实现Spring数据库事务	334
13.2  编程式事务	336
13.3  声明式事务	337
13.3.1  Transactional的配置项	337
13.3.2  使用XML进行配置事务管理器	339
13.3.3  事务定义器	340
13.3.4  声明式事务的约定流程	341
13.4  数据库的相关知识	343
13.4.1  数据库事务ACID特性	343
13.4.2  丢失更新	343
13.4.3  隔离级别	344
13.5  选择隔离级别和传播行为	347
13.5.1  选择隔离级别	347
13.5.2  传播行为	348
13.6  在Spring+MyBatis组合中使用事务	350
13.7  @Transactional的自调用失效问题	358
13.8  典型错误用法的剖析	363
13.8.1  错误使用Service	363
13.8.2  过长时间占用事务	364
13.8.3  错误捕捉异常	366
第4部分  Spring MVC框架
第14章  Spring MVC的初始化和流程	370
14.1  MVC设计概述	370
14.1.1  Spring MVC的架构	372
14.1.2  Spring MVC组件与流程	372
14.1.3  Spring MVC入门的实例	374
14.2  Spring MVC初始化	378
14.2.1  初始化Spring IoC上下文	378
14.2.2  初始化映射请求上下文	379
14.2.3  使用注解配置方式初始化	386
14.3  Spring MVC开发流程详解	389
14.3.1  配置@RequestMapping	390
14.3.2  控制器的开发	391
14.3.3  视图渲染	396
14.4  小结	398
第15章  深入Spring MVC组件开发	399
15.1  控制器接收各类请求参数	399
15.1.1  接收普通请求参数	401
15.1.2  使用@RequestParam注解获取参数	402
15.1.3  使用URL传递参数	403
15.1.4  传递JSON参数	404
15.1.5  接收列表数据和表单序列化	406
15.2  重定向	409
15.3  保存并获取属性参数	412
15.3.1  注解@RequestAttribute	412
15.3.2  注解@SessionAttribute和注解@SessionAttributes	414
15.3.3  注解@CookieValue和注解@RequestHeader	417
15.4  拦截器	417
15.4.1  拦截器的定义	418
15.4.2  拦截器的执行流程	419
15.4.3  开发拦截器	419
15.4.4  多个拦截器执行的顺序	421
15.5  验证表单	424
15.5.1  使用JSR 303注解验证输入内容	425
15.5.2  使用验证器	429
15.6  数据模型	432
15.7  视图和视图解析器	434
15.7.1  视图	434
15.7.2  视图解析器	436
15.7.3  实例：Excel视图的使用	438
15.8  上传文件	441
15.8.1  MultipartResolver概述	442
15.8.2  提交上传文件表单	446
第16章  Spring MVC高级应用	449
16.1  Spring MVC的数据转换和格式化	449
16.1.1  HttpMessageConverter和JSON消息转换器	451
16.1.2  一对一转换器（Converter）	455
16.1.3  数组和集合转换器GenericConverter	458
16.1.4  使用格式化器（Formatter）	463
16.2  为控制器添加通知	466
16.3  处理异常	470
16.4  国际化	471
16.4.1  概述	471
16.4.2  MessageSource接口	473
16.4.3  CookieLocaleResolver和SessionLocaleResolver	475
16.4.4  国际化拦截器（LocaleChangeInterceptor）	477
16.4.5  开发国际化	477
第5部分  Redis应用
第17章  Redis概述	480
17.1  Redis在Java Web中的应用	481
17.1.1  缓存	481
17.1.2  高速读/写场合	482
17.2  Redis基本安装和使用	483
17.2.1  在Windows下安装Redis	483
17.2.2  在Linux下安装Redis	485
17.3  Redis的Java API	486
17.3.1  在Java程序中使用Redis	487
17.3.2  在Spring中使用Redis	488
17.4  简介Redis的6种数据类型	494
17.5  Redis和数据库的异同	495
第18章  Redis数据结构常用命令	496
18.1  Redis数据结构——字符串	497
18.2  Redis数据结构——哈希	502
18.3  Redis数据结构——链表（linked-list）	506
18.4  Redis数据结构——集合	513
18.5  Redis数据结构——有序集合	516
18.5.1  Redis基础命令	516
18.5.2  spring-data-redis对有序集合的封装	518
18.5.3  使用Spring操作有序集合	520
18.6  基数——HyperLogLog	522
18.7  小结	524
第19章  Redis的一些常用技术	525
19.1  Redis的基础事务	526
19.2  探索Redis事务回滚	528
19.3  使用watch命令监控事务	529
19.4  流水线（pipelined）	532
19.5  发布订阅	534
19.6  超时命令	538
19.7  使用Lua语言	540
19.7.1  执行输入Lua程序代码	541
19.7.2  执行Lua文件	544
19.8  小结	547
第20章  Redis配置	548
20.1  Redis基础配置文件	548
20.2  Redis备份（持久化）	549
20.3  Redis内存回收策略	552
20.4  复制	553
20.4.1  主从同步基础概念	553
20.4.2  Redis主从同步配置	554
20.4.3  Redis主从同步的过程	555
20.5  哨兵（Sentinel）模式	556
20.5.1  哨兵模式概述	557
20.5.2  搭建哨兵模式	558
20.5.3  在Java中使用哨兵模式	559
20.5.4  哨兵模式的其他配置项	563
第21章  Spring缓存机制和Redis的结合	565
21.1  Redis和数据库的结合	565
21.1.1  Redis和数据库读操作	566
21.1.2  Redis和数据库写操作	567
21.2  使用Spring缓存机制整合Redis	568
21.2.1  准备测试环境	568
21.2.2  Spring的缓存管理器	573
21.2.3  缓存注解简介	575
21.2.4  注解@Cacheable和@CachePut	576
21.2.5  注解@CacheEvict	580
21.2.6  不适用缓存的方法	581
21.2.7  自调用失效问题	582
21.3  RedisTemplate的实例	582
第6部分  SSM框架+Redis实践应用
第22章  高并发业务	586
22.1  互联系统应用架构基础分析	586
22.2  高并发系统的分析和设计	588
22.2.1  有效请求和无效请求	588
22.2.2  系统设计	590
22.2.3  数据库设计	591
22.2.4  动静分离技术	593
22.2.5  锁和高并发	594
22.3  搭建抢红包开发环境和超发现象	595
22.3.1  搭建Service层和DAO层	595
22.3.2  使用全注解搭建SSM开发环境	602
22.3.3  开发控制器和超发现象测试	609
22.4  悲观锁	611
22.5  乐观锁	614
22.5.1  CAS原理概述	614
22.5.2  ABA问题	615
22.5.3  乐观锁实现抢红包业务	616
22.5.4  乐观锁重入机制	618
22.6  使用Redis实现抢红包	621
22.6.1  使用注解方式配置Redis	621
22.6.2  数据存储设计	622
22.6.3  使用Redis实现抢红包	627
22.7  各类方式的优缺点	631
附录A  数据库表模型	633
附录B  DispatcherServlet流程源码分析	637
附录C  JSTL常用标签	648
附录D  spring data redis项目分析	660
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE互联网轻量级框架整合开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Redis使用手册
前　言
第1章　引言 1
1.1 Redis简介 1
1.2 内容编排 3
1.3 目标读者 4
1.4 预备工作 4
1.5 执行命令 5
1.6 配置服务器 6
1.7 示例代码 7
1.8 版本说明 7
1.9 读者服务网站 8
1.10 启程 8
第一部分　数据结构与应用
第2章　字符串 10
2.1 SET：为字符串键设置值 11
2.1.1 改变覆盖规则 12
2.1.2 其他信息 13
2.2 GET：获取字符串键的值 13
2.3 GETSET：获取旧值并设置新值 14
示例：缓存 14
示例：锁 16
2.4 MSET：一次为多个字符串键设置值 18
2.5 MGET：一次获取多个字符串键的值 19
2.6 MSETNX：只在键不存在的情况下，一次为多个字符串键设置值 20
示例：存储文章信息 20
2.7 STRLEN：获取字符串值的字节长度 25
2.8 字符串值的索引 26
2.9 GETRANGE：获取字符串值指定索引范围上的内容 26
2.10 SETRANGE：对字符串值的指定索引范围进行设置 27
2.10.1 自动扩展被修改的字符串 29
2.10.2 在值里面填充空字节 29
2.10.3 其他信息 30
示例：给文章存储程序加上文章长度计数功能和文章预览功能 31
2.11 APPEND：追加新内容到值的末尾 32
2.11.1 处理不存在的键 33
2.11.2 其他信息 33
示例：存储日志 34
2.12 使用字符串键存储数字值 37
2.13 INCRBY、DECRBY：对整数值执行加法操作和减法操作 37
2.13.1 类型限制 38
2.13.2 处理不存在的键 39
2.13.3 其他信息 40
2.14 INCR、DECR：对整数值执行加1操作和减1操作 40
2.15 INCRBYFLOAT：对数字值执行浮点数加法操作 41
2.15.1 处理不存在的键 41
2.15.2 使用INCRBYFLOAT执行浮点数减法操作 41
2.15.3 INCRBYFLOAT与整数值 42
2.15.4 小数位长度限制 43
2.15.5 其他信息 43
示例：ID生成器 43
示例：计数器 44
示例：限速器 46
2.16 重点回顾 48
第3章　散列 49
3.1 散列简介 50
3.2 HSET：为字段设置值 51
3.2.1 使用新值覆盖旧值 53
3.2.2 其他信息 53
3.3 HSETNX：只在字段不存在的情况下为它设置值 53
3.4 HGET：获取字段的值 54
3.4.1 处理不存在的字段或者不存在的散列 55
3.4.2 其他信息 55
示例：实现短网址生成程序 55
3.5 HINCRBY：对字段存储的整数值执行加法或减法操作 58
3.5.1 执行减法操作 58
3.5.2 处理异常情况 59
3.5.3 其他信息 59
3.6 HINCRBYFLOAT：对字段存储的数字值执行浮点数加法或减法操作 59
3.6.1 增量和字段值的类型限制 60
3.6.2 执行减法操作 60
3.6.3 其他信息 60
示例：使用散列键重新实现计数器 60
3.7 HSTRLEN：获取字段值的字节长度 63
3.8 HEXISTS：检查字段是否存在 63
3.9 HDEL：删除字段 64
3.10 HLEN：获取散列包含的字段数量 65
示例：实现用户登录会话 66
3.11 HMSET：一次为多个字段设置值 69
3.11.1 使用新值覆盖旧值 69
3.11.2 其他信息 70
3.12 HMGET：一次获取多个字段的值 70
3.13 HKEYS、HVALS、HGETALL：获取所有字段、所有值、所有字段和值 71
3.13.1 字段在散列中的排列顺序 72
3.13.2 其他信息 73
示例：存储图数据 73
示例：使用散列键重新实现文章存储程序 77
3.14 散列与字符串 79
3.14.1 散列键的优点 80
3.14.2 字符串键的优点 81
3.14.3 字符串键和散列键的选择 82
3.15 重点回顾 82
第4章　列表 83
4.1 LPUSH：将元素推入列表左端 84
4.1.1 一次推入多个元素 84
4.1.2 其他信息 86
4.2 RPUSH：将元素推入列表右端 86
4.2.1 一次推入多个元素 86
4.2.2 其他信息 88
4.3 LPUSHX、RPUSHX：只对已存在的列表执行推入操作 88
4.3.1 每次只能推入单个元素 89
4.3.2 其他信息 90
4.4 LPOP：弹出列表最左端的元素 90
4.5 RPOP：弹出列表最右端的元素 91
4.6 RPOPLPUSH：将右端弹出的元素推入左端 92
4.6.1 源列表和目标列表相同 93
4.6.2 处理空列表 94
4.6.3 其他信息 95
示例：先进先出队列 95
4.7 LLEN：获取列表的长度 96
4.8 LINDEX：获取指定索引上的元素 97
4.8.1 处理超出范围的索引 98
4.8.2 其他信息 98
4.9 LRANGE：获取指定索引范围上的元素 98
4.9.1 获取列表包含的所有元素 99
4.9.2 处理超出范围的索引 100
4.9.3 其他信息 101
示例：分页 101
4.10 LSET：为指定索引设置新元素 103
4.10.1 处理超出范围的索引 104
4.10.2 其他信息 104
4.11 LINSERT：将元素插入列表 104
4.11.1 处理不存在的元素 105
4.11.2 其他信息 105
4.12 LTRIM：修剪列表 105
4.12.1 处理负数索引 107
4.12.2 其他信息 107
4.13 LREM：从列表中移除指定元素 107
示例：待办事项列表 109
4.14 BLPOP：阻塞式左端弹出操作 112
4.14.1 解除阻塞状态 112
4.14.2 处理空列表 113
4.14.3 列表名的作用 114
4.14.4 阻塞效果的范围 114
4.14.5 其他信息 114
4.15 BRPOP：阻塞式右端弹出操作 114
4.16 BRPOPLPUSH：阻塞式弹出并推入操作 114
4.16.1 处理源列表为空的情况 116
4.16.2 其他信息 116
示例：带有阻塞功能的消息队列 116
4.17 重点回顾 119
第5章　集合 120
5.1 SADD：将元素添加到集合 121
5.1.1 忽略已存在元素 122
5.1.2 其他信息 122
5.2 SREM：从集合中移除元素 122
5.2.1 忽略不存在的元素 122
5.2.2 其他信息 123
5.3 SMOVE：将元素从一个集合移动到另一个集合 123
5.3.1 忽略不存在的元素 124
5.3.2 覆盖已存在的元素 124
5.3.3 其他信息 125
5.4 SMEMBERS：获取集合包含的所有元素 125
5.4.1 元素的无序排列 126
5.4.2 其他信息 126
5.5 SCARD：获取集合包含的元素数量 126
5.6 SISMEMBER：检查给定元素是否存在于集合 127
示例：唯一计数器 128
示例：打标签 129
示例：点赞 131
示例：投票 132
示例：社交关系 135
5.7 SRANDMEMBER：随机获取集合中的元素 137
5.7.1 返回指定数量的元素 138
5.7.2 其他信息 139
5.8 SPOP：随机地从集合中移除指定数量的元素 139
5.8.1 SPOP与SRANDMEMBER的区别 140
5.8.2 其他信息 141
示例：抽奖 141
5.9 SINTER、SINTERSTORE：对集合执行交集计算 142
5.9.1 SINTERSTORE命令 143
5.9.2 其他信息 143
5.10 SUNION、SUNIONSTORE：对集合执行并集计算 143
5.10.1 SUNIONSTORE命令 144
5.10.2 其他信息 144
5.11 SDIFF、SDIFFSTORE：对集合执行差集计算 144
5.11.1 SDIFFSTORE命令 145
5.11.2 其他信息 145
示例：共同关注与推荐关注 146
示例：使用反向索引构建商品筛选器 149
5.12 重点回顾 152
第6章　有序集合 153
6.1 ZADD：添加或更新成员 154
6.1.1 更新已有成员的分值 154
6.1.2 指定要执行的操作 154
6.1.3 返回被修改成员的数量 155
6.1.4 其他信息 156
6.2 ZREM：移除指定的成员 156
6.2.1 忽略不存在的成员 157
6.2.2 其他信息 157
6.3 ZSCORE：获取成员的分值 157
6.4 ZINCRBY：对成员的分值执行自增或自减操作 158
6.4.1 执行自减操作 159
6.4.2 处理不存在的键或者不存在的成员 160
6.4.3 其他信息 160
6.5 ZCARD：获取有序集合的大小 160
6.6 ZRANK、ZREVRANK：获取成员在有序集合中的排名 161
6.6.1 处理不存在的键或者不存在的成员 162
6.6.2 其他信息 162
6.7 ZRANGE、ZREVRANGE：获取指定索引范围内的成员 162
6.7.1 使用负数索引 163
6.7.2 获取成员及其分值 164
6.7.3 处理不存在的有序集合 165
6.7.4 其他信息 165
示例：排行榜 165
6.8 ZRANGEBYSCORE、ZREVRAN-GEBYSCORE：获取指定分值范围内的成员 167
6.8.1 获取成员及其分值 168
6.8.2 限制命令返回的成员数量 168
6.8.3 使用开区间分值范围 169
6.8.4 使用无限值作为范围 170
6.8.5 其他信息 171
6.9 ZCOUNT：统计指定分值范围内的成员数量 171
6.9.1 分值范围的格式 171
6.9.2 其他信息 172
示例：时间线 172
6.10 ZREMRANGEBYRANK：移除指定排名范围内的成员 175
6.10.1 使用负数排名 175
6.10.2 其他信息 175
6.11 ZREMRANGEBYSCORE：移除指定分值范围内的成员 176
6.12 ZUNIONSTORE、ZINTERSTORE：有序集合的并集运算和交集运算 176
6.12.1 指定聚合函数 177
6.12.2 设置权重 179
6.12.3 使用集合作为输入 180
6.12.4 其他信息 181
示例：商品推荐 181
6.13 ZRANGEBYLEX、ZREVRAN-GEBYLEX：返回指定字典序范围内的成员 182
6.13.1 ZREVRANGEBYLEX 184
6.13.2 限制命令返回的成员数量 184
6.13.3 其他信息 185
6.14 ZLEXCOUNT：统计位于字典序指定范围内的成员数量 185
6.15 ZREMRANGEBYLEX：移除位于字典序指定范围内的成员 186
示例：自动补全 187
6.16 ZPOPMAX、ZPOPMIN：弹出分值最高和最低的成员 188
6.17 BZPOPMAX、BZPOPMIN：阻塞式最大/最小元素弹出操作 189
6.18 重点回顾 191
第7章　HyperLogLog 192
7.1 HyperLogLog简介 193
7.2 PFADD：对集合元素进行计数 193
7.3 PFCOUNT：返回集合的近似基数 194
7.3.1 返回并集的近似基数 194
7.3.2 其他信息 195
示例：优化唯一计数器 195
示例：检测重复信息 196
7.4 PFMERGE：计算多个HyperLogLog的并集 198
7.4.1 PFCOUNT与PFMERGE 198
7.4.2 其他信息 199
示例：实现每周/月度/年度计数器 199
7.5 重点回顾 200
第8章　位图 201
8.1 SETBIT：设置二进制位的值 201
8.1.1 位图的扩展 202
8.1.2 偏移量只能为正数 203
8.1.3 其他信息 203
8.2 GETBIT：获取二进制位的值 203
8.2.1 处理范围之外的偏移量 204
8.2.2 其他信息 204
8.3 BITCOUNT：统计被设置的二进制位数量 204
8.3.1 只统计位图指定字节范围内的二进制位 204
8.3.2 使用负数偏移量定义统计范围 206
8.3.3 其他信息 206
示例：用户行为记录器 207
8.4 BITPOS：查找第一个指定的二进制位值 208
8.4.1 只在指定的字节范围内进行查找 209
8.4.2 使用负数偏移量定义查找范围 209
8.4.3 边界情况处理 210
8.4.4 其他信息 211
8.5 BITOP：执行二进制位运算 211
8.5.1 处理不同长度的位图 212
8.5.2 其他信息 212
示例：0-1矩阵 212
8.6 BITFIELD：在位图中存储整数值 214
8.6.1 根据偏移量对区域进行设置 214
8.6.2 根据索引对区域进行设置 216
8.6.3 获取区域存储的值 216
8.6.4 执行加法操作或减法操作 217
8.6.5 处理溢出 218
8.6.6 使用位图存储整数的原因 219
8.6.7 其他信息 219
示例：紧凑计数器 219
8.7 使用字符串命令对位图进行操作 221
8.8 重点回顾 222
第9章　地理坐标 223
9.1 GEOADD：存储坐标 224
9.1.1 更新已有位置的坐标 224
9.1.2 其他信息 224
9.2 GEOPOS：获取指定位置的坐标 224
9.3 GEODIST：计算两个位置之间的直线距离 225
9.3.1 指定距离的单位 225
9.3.2 处理不存在的位置 226
9.3.3 其他信息 226
示例：具有基本功能的用户地理位置程序 226
9.4 GEORADIUS：查找指定坐标半径范围内的其他位置 228
9.4.1 返回被匹配位置与中心点之间的距离 229
9.4.2 返回被匹配位置的坐标 229
9.4.3 排序查找结果 230
9.4.4 限制命令获取的位置数量 231
9.4.5 同时使用多个可选项 231
9.4.6 其他信息 232
9.5 GEORADIUSBYMEMBER：查找指定位置半径范围内的其他位置 232
示例：查找附近用户 233
9.6 GEOHASH：获取指定位置的Geohash值 235
9.6.1 在进行范围查找时获取Geohash值 235
9.6.2 其他信息 236
9.7 使用有序集合命令操作GEO数据 236
9.8 重点回顾 237
第10章　流 238
10.1 XADD：追加新元素到流的末尾 239
10.1.1 流元素的ID 239
10.1.2 不完整的流ID 240
10.1.3 流元素ID的限制 240
10.1.4 自动生成元素ID 241
10.1.5 限制流的长度 242
10.1.6 其他信息 243
10.2 XTRIM：对流进行修剪 243
10.3 XDEL：移除指定元素 244
10.4 XLEN：获取流包含的元素数量 244
10.5 XRANGE、XREVRANGE：访问流中元素 245
10.5.1 获取ID指定的单个元素 245
10.5.2 获取指定ID范围内的多个元素 246
10.5.3 获取所有元素 247
10.5.4 获取指定数量的元素 248
10.5.5 对流进行迭代 249
10.5.6 以逆序访问流中元素 251
10.5.7 其他信息 251
10.6 XREAD：以阻塞或非阻塞方式获取流元素 251
10.6.1 从多个流中获取大于指定ID的元素 251
10.6.2 迭代流 253
10.6.3 阻塞 254
10.6.4 只获取新出现的元素 256
10.6.5 其他信息 258
示例：消息队列 258
10.7 消费者组 260
10.7.1 创建消费者组 261
10.7.2 读取消费者组 262
10.7.3 消费者 262
10.7.4 消息的状态转换 263
10.7.5 实际示例 263
10.8 XGROUP：管理消费者组 264
10.8.1 创建消费者组 264
10.8.2 修改消费者组的最后递送消息ID 265
10.8.3 删除消费者 267
10.8.4 删除消费者组 268
10.9 XREADGROUP：读取消费者组中的消息 268
10.9.1 读取未递送过的新消息 269
10.9.2 其他信息 270
10.10 XPENDING：显示待处理消息的相关信息 270
10.11 XACK：将消息标记为“已处理” 271
10.12 XCLAIM：转移消息的归属权 272
10.12.1 只返回被转移消息的ID 273
10.12.2 其他信息 273
10.13 XINFO：查看流和消费者组的相关信息 273
10.13.1 打印消费者信息 273
10.13.2 打印消费者组信息 274
10.13.3 打印流消息 274
10.13.4 其他信息 275
示例：为消息队列提供消费者组功能 275
10.14 重点回顾 277
第二部分　附加功能
第11章　数据库 280
11.1 SELECT：切换至指定的数据库 281
11.2 KEYS：获取所有与给定匹配符相匹配的键 282
11.2.1 全局匹配符 282
11.2.2 其他信息 283
11.3 SCAN：以渐进方式迭代数据库中的键 283
11.3.1 一次简单的迭代示例 284
11.3.2 SCAN命令的迭代保证 285
11.3.3 游标的使用 285
11.3.4 迭代与给定匹配符相匹配的键 285
11.3.5 指定返回键的期望数量 286
11.3.6 数据结构迭代命令 287
11.3.7 其他信息 289
示例：构建数据库迭代器 289
11.4 RANDOMKEY：随机返回一个键 292
11.5 SORT：对键的值进行排序 292
11.5.1 指定排序方式 293
11.5.2 对字符串值进行排序 294
11.5.3 只获取部分排序结果 294
11.5.4 获取外部键的值作为结果 295
11.5.5 使用外部键的值作为排序权重 298
11.5.6 保存排序结果 299
11.5.7 其他信息 300
11.6 EXISTS：检查给定键是否存在 300
11.6.1 只能接受单个键的EXISTS命令 300
11.6.2 其他信息 300
11.7 DBSIZE：获取数据库包含的键值对数量 301
11.8 TYPE：查看键的类型 301
示例：数据库取样程序 302
11.9 RENAME、RENAMENX：修改键名 304
11.9.1 覆盖已存在的键 305
11.9.2 只在新键名尚未被占用的情况下进行改名 305
11.9.3 其他信息 306
11.10 MOVE：将给定的键移动到另一个数据库 306
11.10.1 不覆盖同名键 306
11.10.2 其他信息 307
11.11 DEL：移除指定的键 307
11.12 UNLINK：以异步方式移除指定的键 307
11.13 FLUSHDB：清空当前数据库 308
11.13.1 async选项 308
11.13.2 其他信息 309
11.14 FLUSHALL：清空所有数据库 309
11.14.1 async选项 309
11.14.2 其他信息 309
11.15 SWAPDB：互换数据库 309
示例：使用SWAPDB命令实行在线替换数据库 310
11.16 重点回顾 312
第12章　自动过期 313
12.1 EXPIRE、PEXPIRE：设置生存时间 313
12.1.1 更新键的生存时间 315
12.1.2 其他信息 315
示例：带有自动移除特性的缓存程序 316
12.2 SET命令的EX选项和PX选项 317
12.2.1 组合命令的安全问题 317
12.2.2 其他信息 318
示例：带有自动释放特性的锁 318
12.3 EXPIREAT、PEXPIREAT：设置过期时间 319
12.3.1 EXPIREAT使用示例 320
12.3.2 PEXPIREAT使用示例 320
12.3.3 更新键的过期时间 321
12.3.4 自动过期特性的不足之处 321
12.3.5 其他信息 322
12.4 TTL、PTTL：获取键的剩余生存时间 322
12.4.1 没有剩余生存时间的键和不存在的键 322
12.4.2 TTL命令的精度问题 322
12.4.3 其他信息 323
示例：自动过期的登录会话 323
示例：自动淘汰冷门数据 326
12.5 重点回顾 328
第13章　流水线与事务 329
13.1 流水线 329
示例：使用流水线优化随机键创建程序 331
13.2 事务 333
13.2.1 MULTI：开启事务 335
13.2.2 EXEC：执行事务 335
13.2.3 DISCARD：放弃事务 336
13.2.4 事务的安全性 337
13.2.5 事务对服务器的影响 337
13.2.6 流水线与事务 337
示例：实现mlpop()函数 338
13.3 带有乐观锁的事务 339
13.3.1 WATCH：对键进行监视 341
13.3.2 UNWATCH：取消对键的监视 342
示例：带有身份验证功能的锁 343
示例：带有身份验证功能的计数信号量 344
13.4 重点回顾 347
第14章　Lua脚本 348
14.1 EVAL：执行脚本 349
14.1.1 使用脚本执行Redis命令 349
14.1.2 值转换 350
14.1.3 全局变量保护 352
14.1.4 在脚本中切换数据库 353
14.1.5 脚本的原子性 353
14.1.6 以命令行方式执行脚本 353
14.1.7 其他信息 354
示例：使用脚本重新实现带有身份验证功能的锁 354
示例：实现LPOPRPUSH命令 355
14.2 SCRIPT LOAD和EVALSHA：缓存并执行脚本 357
14.3 脚本管理 359
14.3.1 SCRIPT EXISTS：检查脚本是否已被缓存 359
14.3.2 SCRIPT FLUSH：移除所有已缓存脚本 359
14.3.3 SCRIPT KILL：强制停止正在运行的脚本 360
14.4 内置函数库 361
14.4.1 redis包 362
14.4.2 bit包 364
14.4.3 struct包 364
14.4.4 cjson包 365
14.4.5 cmsgpack包 365
14.5 脚本调试 366
14.5.1 一个简单的调试示例 366
14.5.2 调试命令 368
14.5.3 断点 369
14.5.4 动态断点 371
14.5.5 输出调试日志 372
14.5.6 执行指定的代码或命令 373
14.5.7 显示调用链 373
14.5.8 重载脚本 375
14.5.9 调试模式 376
14.5.10 终止调试会话 378
14.6 重点回顾 379
第15章　持久化 380
15.1 RDB持久化 380
15.1.1 SAVE：阻塞服务器并创建RDB文件 381
15.1.2 BGSAVE：以非阻塞方式创建RDB文件 382
15.1.3 通过配置选项自动创建RDB文件 382
15.1.4 SAVE命令和BGSAVE命令的选择 384
15.1.5 RDB文件结构 384
15.1.6 载入RDB文件 386
15.1.7 数据丢失 387
15.2 AOF持久化 389
15.2.1 打开AOF持久化功能 390
15.2.2 设置AOF文件的冲洗频率 391
15.2.3 AOF重写 391
15.2.4 AOF持久化的优缺点 394
15.3 RDB-AOF混合持久化 394
15.4 同时使用RDB持久化和AOF持久化 396
15.5 无持久化 397
15.6 SHUTDOWN：关闭服务器 397
15.6.1 通过可选项指示持久化操作 398
15.6.2 其他信息 399
15.7 重点回顾 399
第16章　发布与订阅 400
16.1 PUBLISH：向频道发送消息 402
16.2 SUBSCRIBE：订阅频道 402
16.2.1 接收频道消息 403
16.2.2 其他信息 404
16.3 UNSUBSCRIBE：退订频道 404
16.3.1 UNSUBSCRIBE命令在不同客户端中的应用 404
16.3.2 其他信息 405
16.4 PSUBSCRIBE：订阅模式 405
16.4.1 接收模式消息 406
16.4.2 其他信息 407
16.5 PUNSUBSCRIBE：退订模式 407
16.5.1 PUNSUBSCRIBE命令在不同客户端中的应用 407
16.5.2 其他信息 408
16.6 PUBSUB：查看发布与订阅的相关信息 408
16.6.1 查看被订阅的频道 408
16.6.2 查看频道的订阅者数量 409
16.6.3 查看被订阅模式的总数量 409
16.6.4 其他信息 409
示例：广播系统 409
16.7 重点回顾 411
第17章　模块 412
17.1 模块的管理 413
17.1.1 编译模块 413
17.1.2 载入模块 413
17.1.3 列出已载入的模块 414
17.1.4 卸载模块 415
17.2 ReJSON模块 416
17.2.1 编译和载入 416
17.2.2 使用示例 417
17.2.3 ReJSON路径 418
17.2.4 API简介 420
17.3 RediSQL模块 423
17.3.1 编译模块 423
17.3.2 使用示例 424
17.3.3 API简介 425
17.4 RediSearch模块 428
17.4.1 下载与编译 428
17.4.2 使用示例 429
17.4.3 API简介 430
17.5 重点回顾 442
第三部分　多机功能
第18章　复制 444
18.1 REPLICAOF：将服务器设置为从服务器 446
18.1.1 通过配置选项设置从服务器 447
18.1.2 取消复制 447
18.1.3 其他信息 448
18.2 ROLE：查看服务器的角色 448
18.2.1 主服务器执行ROLE命令 448
18.2.2 从服务器执行ROLE命令 449
18.2.3 其他信息 449
18.3 数据同步 449
18.3.1 完整同步 450
18.3.2 在线更新 450
18.3.3 部分同步 451
18.4 无须硬盘的复制 452
18.5 降低数据不一致情况出现的概率 452
18.6 可写的从服务器 453
示例：使用从服务器处理复杂计算操作 454
18.7 脚本复制 455
18.7.1 脚本传播模式 455
18.7.2 命令传播模式 456
18.7.3 选择性命令传播 457
18.7.4 模式的选择 458
18.8 重点回顾 459
第19章　Sentinel 460
19.1 启动Sentinel 461
19.2 Sentinel网络 464
19.3 Sentinel管理命令 466
19.3.1 SENTINEL masters：获取所有被监视主服务器的信息 467
19.3.2 SENTINEL master：获取指定被监视主服务器的信息 468
19.3.3 SENTINEL slaves：获取被监视主服务器的从服务器信息 469
19.3.4 SENTINEL sentinels：获取其他Sentinel的相关信息 471
19.3.5 SENTINEL get-master-addr-by-name：获取给定主服务器的IP地址和端口号 472
19.3.6 SENTINEL reset：重置主服务器状态 473
19.3.7 SENTINEL failover：强制执行故障转移 473
19.3.8 SENTINEL ckquorum：检查可用Sentinel的数量 474
19.3.9 SENTINEL flushconfig：强制写入配置文件 474
19.4 在线配置Sentinel 475
19.4.1 SENTINEL monitor：监视给定主服务器 475
19.4.2 SENTINEL remove：取消对给定主服务器的监视 476
19.4.3 SENTINEL set：修改Sentinel配置选项的值 477
19.4.4 使用在线配置命令的注意事项 478
示例：使用redis-py管理Sentinel 479
19.5 重点回顾 479
第20章　集群 481
20.1 基本特性 481
20.1.1 复制与高可用 481
20.1.2 分片与重分片 482
20.1.3 高性能 482
20.1.4 简单易用 483
20.2 搭建集群 483
20.2.1 快速搭建集群 483
20.2.2 手动搭建集群 486
示例：使用客户端连接集群 489
20.3 散列标签 491
20.4 打开/关闭从节点的读命令执行权限 492
20.4.1 READONLY：打开读命令执行权限 493
20.4.2 READWRITE：关闭读命令执行权限 493
20.4.3 其他信息 494
20.5 集群管理工具redis-cli 494
20.5.1 创建集群 495
20.5.2 查看集群信息 496
20.5.3 检查集群 497
20.5.4 修复槽错误 498
20.5.5 重分片 499
20.5.6 负载均衡 501
20.5.7 添加节点 502
20.5.8 移除节点 503
20.5.9 执行命令 504
20.5.10 设置超时时间 504
20.5.11 导入数据 505
20.6 集群管理命令 506
20.6.1 CLUSTER MEET：将节点添加至集群 506
20.6.2 CLUSTER NODES：查看集群内所有节点的相关信息 508
20.6.3 CLUSTER MYID：查看当前节点的运行ID 511
20.6.4 CLUSTER INFO：查看集群信息 512
20.6.5 CLUSTER FORGET：从集群中移除节点 513
20.6.6 CLUSTER REPLICATE：将节点变为从节点 514
20.6.7 CLUSTER REPLICAS：查看给定节点的所有从节点 515
20.6.8 CLUSTER FAILOVER：强制执行故障转移 516
20.6.9 CLUSTER RESET：重置节点 517
20.7 槽管理命令 518
20.7.1 CLUSTER SLOTS：查看槽与节点之间的关联信息 519
20.7.2 CLUSTER ADDSLOTS：把槽指派给节点 520
20.7.3 CLUSTER DELSLOTS：撤销对节点的槽指派 521
20.7.4 CLUSTER FLUSHSLOTS：撤销对节点的所有槽指派 522
20.7.5 CLUSTER KEYSLOT：查看键所属的槽 523
20.7.6 CLUSTER COUNTKEYSINSLOT：查看槽包含的键数量 524
20.7.7 CLUSTER GETKEYSINSLOT：获取槽包含的键 524
20.7.8 CLUSTER SETSLOT：改变槽的状态 525
20.8 重点回顾 527
附录A　Redis安装方法 528
附录B　redis-py安装方法 531
附录C　Redis命令索引表 533
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Redis使用手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Boot实战派
目录
+++++++++入 门 篇
第1章  进入Spring Boot世界  /2
1.1  认识Spring Boot  /2
∣1.1.1  什么是Spring Boot  /2
∣1.1.2  Spring、Spring Boot、Spring Cloud的关系  /4
∣1.1.3  Spring Boot的特色  /5
∣1.1.4  Spring Boot支持的开发语言  /6
∣1.1.5  学习Spring Boot的前景展望  /6
1.2  学习Spring Boot的建议  /7
∣1.2.1  看透本书理论，模仿实战例子  /7
∣1.2.2  利用开发工具自动学习  /7
∣1.2.3  发现新功能的方法  /8
∣1.2.4  建立高阶的思维方式  /9
∣1.2.5  控制版本，降低犯错的代价  /10
∣1.2.6  获取最新、最全的资料  /11
∣1.2.7  学会自己发现和解决问题  /11
∣1.2.8  善于提问，成功一半  /12
第2章  准备开发环境  /14
2.1  搭建环境  /14
∣2.1.1  安装Java开发环境JDK  /14
∣2.1.2  配置JDK的环境变量  /15
2.2  熟悉Maven  /18
∣2.2.1  安装及配置Maven  /18
∣2.2.2  认识其中的pom.xml文件  /19
∣2.2.3  Maven的运作方式  /23
∣2.2.4  配置国内仓库  /23
第3章  使用开发工具  /25
3.1  安装开发工具IDEA及插件  /25
∣3.1.1  安装IDEA  /25
∣3.1.2  配置IDEA的Maven环境  /27
∣3.1.3  安装Spring Assistant插件  /27
∣3.1.4  安装插件Lombok  /28
3.2  【实例1】用Spring Boot输出“Hello World”  /30
∣3.2.1  构建Spring Boot项目  /30
∣3.2.2  编写控制器，实现输出功能  /31
∣3.2.3  在IDEA中运行程序  /33
∣3.2.4  打包成可执行的JAR包  /33
3.3  在Eclipse中开发Spring Boot应用程序  /35
∣3.3.1  安装Eclipse  /35
∣3.3.2  安装Spring Tools 4插件  /35
∣3.3.3  配置Eclipse的Maven环境  /36
∣3.3.4  创建Spring Boot项目  /37
3.4  了解Spring官方开发工具STS  /37
3.5  必会的IDEA实用技能  /38
∣3.5.1  智能提示代码  /38
∣3.5.2  自动提示参数  /39
∣3.5.3  实现自动转义  /39
∣3.5.4  自定义高复用代码块  /40
∣3.5.5  设置注释信息  /41
∣3.5.6  超能的“Alt+Enter”快捷键  /42
∣3.5.7  使用全局配置  /42
∣3.5.8  自动生成语句  /43
3.6  比较IDEA与Eclipse  /44
3.7  如何使用本书源代码  /47
∣3.7.1  在IDEA中使用  /47
∣3.7.2  在Eclipse（STS）中使用  /47
∣
+++++++++基 础 篇
第4章  Spring Boot基础  /50
4.1  了解Spring Boot  /50
∣4.1.1  了解Spring Boot项目结构  /50
∣4.1.2  了解Spring Boot的入口类  /51
∣4.1.3  了解Spring Boot的自动配置  /52
∣4.1.4  了解Spring Boot热部署  /52
∣4.1.5  【实例2】定制启动画面  /53
4.2  Spring Boot的常用注解  /54
∣4.2.1  什么是注解式编程  /55
∣4.2.2  了解系统注解  /55
∣4.2.3  Spring Boot的常用注解  /56
4.3  使用配置文件  /61
∣4.3.1  【实例3】演示如何使用application.yml文件  /62
∣4.3.2  【实例4】演示如何使用application.properties文件  /65
∣4.3.3  【实例5】用application.yml和application.properties配置多环境  /67
4.4  Spring Boot的Starter  /69
∣4.4.1  了解Starter  /69
∣4.4.2  使用Starter  /70
第5章  分层开发Web应用程序  /71
5.1  应用程序分层开发模式——MVC  /71
∣5.1.1  了解MVC模式  /71
∣5.1.2  MVC和三层架构的关系  /72
5.2  使用视图技术Thymeleaf  /73
∣5.2.1  认识Thymeleaf  /73
∣5.2.2  基础语法  /75
∣5.2.3  处理循环遍历  /78
∣5.2.4  处理公共代码块  /80
∣5.2.5  处理分页  /81
∣5.2.6  验证和提示错误消息  /82
∣5.2.7  【实例6】编写Thymeleaf视图以展示数据  /83
5.3  使用控制器  /85
∣5.3.1  常用注解  /85
∣5.3.2  将URL映射到方法  /86
∣5.3.3  处理HTTP请求的方法  /87
∣5.3.4  处理内容类型  /89
∣5.3.5  在方法中使用参数  /90
5.4  理解模型  /93
5.5  【实例7】实现MVC模式的Web应用程序  /94
∣5.5.1  添加依赖  /94
∣5.5.2  创建实体模型  /95
∣5.5.3  创建控制器  /95
∣5.5.4  创建用于展示的视图  /96
5.6  验证数据  /96
∣5.6.1  认识内置的验证器Hibernate∣validator  /96
∣5.6.2  自定义验证功能  /98
∣5.6.3  【实例8】验证表单数据并实现数据的自定义验证  /99
第6章  响应式编程  /103
6.1  认识响应式编程  /103
∣6.1.1  什么是WebFlux  /103
∣6.1.2  比较MVC和WebFlux  /103
∣6.1.3  认识Mono和Flux  /105
∣6.1.4  开发WebFlux的流程  /106
6.2  【实例9】用注解式开发实现Hello World  /107
∣6.2.1  配置WebFlux依赖  /107
∣6.2.2  编写控制器  /107
6.3  【实例10】用注解式开发实现数据的增、删、改、查  /108
∣6.3.1  创建实体类  /108
∣6.3.2  编写控制器  /108
∣6.3.3  测试API功能  /110
6.4  【实例11】用响应式开发方式开发WebFlux  /111
∣6.4.1  编写处理器类Handler  /111
∣6.4.2  编写路由器类Router  /112
6.5  【实例12】用WebFlux模式操作MongoDB数据库,实现数据的增、删、改、查功能  /112
∣6.5.1  添加依赖  /112
∣6.5.2  创建实体类  /113
∣6.5.3  编写接口  /113
6.5.4  编写增、删、改、查数据的API  /113
∣
+++++++++进 阶 篇
第7章  Spring Boot进阶  /118
7.1  面向切面编程  /118
∣7.1.1  认识Spring AOP  /118
∣7.1.2  【实例13】用AOP方式管理日志  /119
7.2  认识IoC容器和Servlet容器  /121
∣7.2.1  认识容器  /121
∣7.2.2  【实例14】用IoC管理Bean  /123
∣7.2.3  【实例15】用Servlet处理请求  /125
7.3  过滤器与监听器  /126
∣7.3.1  认识过滤器  /126
∣7.3.2  【实例16】实现过滤器  /128
∣7.3.3  认识监听器  /128
∣7.3.4  【实例17】实现监听器  /129
7.4  自动配置  /130
∣7.4.1  自定义入口类  /130
∣7.4.2  自动配置的原理  /131
∣7.4.3  【实例18】自定义Starter  /133
7.5  元注解  /136
∣7.5.1  了解元注解  /136
∣7.5.2  【实例19】自定义注解  /137
7.6  异常处理  /138
∣7.6.1  认识异常处理  /138
∣7.6.2  使用控制器通知  /141
∣7.6.3  【实例20】自定义错误处理控制器  /142
∣7.6.4  【实例21】自定义业务异常类  /143
7.7  单元测试  /145
∣7.7.1  了解单元测试  /145
∣7.7.2  Spring Boot 的测试库  /145
∣7.7.3  快速创建测试单元  /149
∣7.7.4  【实例22】Controller层的单元测试  /150
∣7.7.5  【实例23】Service层的单元测试  /153
∣7.7.6  【实例24】Repository层的单元测试  /154
第8章  用ORM操作SQL数据库  /156
8.1  认识Java的数据库连接模板JDBCTemplate  /156
∣8.1.1  认识JDBCTemplate  /156
∣8.1.2  【实例25】用JDBCTemplate实现数据的增、删、改、查  /157
∣8.1.3  认识ORM  /161
8.2  JPA——Java持久层API  /161
∣8.2.1  认识Spring Data  /161
∣8.2.2  认识JPA  /162
∣8.2.3  使用JPA  /164
∣8.2.4  了解JPA注解和属性  /165
∣8.2.5  【实例26】用JPA构建实体数据表  /167
8.3  认识JPA的接口  /169
∣8.3.1  JPA接口JpaRepository  /169
∣8.3.2  分页排序接口PagingAndSortingRepository  /169
∣8.3.3  数据操作接口CrudRepository  /170
∣8.3.4  分页接口Pageable和Page  /170
∣8.3.5  排序类Sort  /171
8.4  JPA的查询方式  /171
∣8.4.1  使用约定方法名  /171
∣8.4.2  用JPQL进行查询  /173
∣8.4.3  用原生SQL进行查询  /174
∣8.4.4  用Specifications进行查询  /175
∣8.4.5  用ExampleMatcher进行查询  /177
∣8.4.6  用谓语QueryDSL进行查询  /177
∣8.4.7  用NamedQuery进行查询  /177
8.5  【实例27】用JPA开发文章管理模块  /178
∣8.5.1  实现文章实体  /178
∣8.5.2  实现数据持久层  /179
∣8.5.3  实现服务接口和服务接口的实现类  /179
∣8.5.4  实现增、删、改、查的控制层API功能  /180
∣8.5.5  实现增、删、改、查功能的视图层  /182
8.6  实现自动填充字段  /185
8.7  掌握关系映射开发  /187
∣8.7.1  认识实体间关系映射  /187
∣8.7.2  【实例28】实现“一对一”映射  /188
∣8.7.3  【实例29】实现“一对多”映射  /192
∣8.7.4  【实例30】实现“多对多”映射  /195
8.8  认识MyBatis——Java数据持久层框架  /197
∣8.8.1  CRUD注解  /198
∣8.8.2  映射注解  /198
∣8.8.3  高级注解  /199
8.9  【实例31】用MyBatis实现数据的增加、删除、修改、查询和分页  /200
∣8.9.1  创建Spring Boot项目并引入依赖  /201
∣8.9.2  实现数据表的自动初始化  /201
∣8.9.3  实现实体对象建模  /202
∣8.9.4  实现实体和数据表的映射关系  /202
∣8.9.5  实现增、删、改、查功能  /203
∣8.9.6  配置分页功能  /204
∣8.9.7  实现分页控制器  /205
∣8.9.8  创建分页视图  /206
8.10  比较JPA与MyBatis  /207
第9章  接口架构风格——RESTful  /209
9.1  REST——前后台间的通信方式  /209
∣9.1.1  认识REST  /209
∣9.1.2  认识HTTP方法与CRUD动作映射  /210
∣9.1.3  实现RESTful风格的数据增、删、改、查  /210
9.2  设计统一的RESTful风格的数据接口  /212
∣9.2.1  版本控制  /212
∣9.2.2  过滤信息  /213
∣9.2.3  确定HTTP的方法  /213
∣9.2.4  确定HTTP的返回状态  /213
∣9.2.5  定义统一返回的格式  /214
9.3  【实例32】为手机APP、PC、H5网页提供统一风格的API  /214
∣9.3.1  实现响应的枚举类  /214
∣9.3.2  实现返回的对象实体  /215
∣9.3.3  封装返回结果  /215
∣9.3.4  统一处理异常  /215
∣9.3.5  编写测试控制器  /219
∣9.3.6  实现数据的增、删、改、查控制器  /220
∣9.3.7  测试数据  /221
9.4  【实例33】用Swagger实现接口文档  /222
∣9.4.1  配置Swagger  /222
∣9.4.2  编写接口文档  /224
9.5  用RestTemplate发起请求  /224
∣9.5.1  认识RestTemplate  /224
∣9.5.2  【实例34】用RestTemplate发送GET请求  /225
∣9.5.3  【实例35】用RestTemplate发送POST请求  /228
∣9.5.4  用RestTemplate发送PUT和DELETE请求  /231
第10章  集成安全框架，实现安全认证和授权  /233
10.1  Spring Security——Spring的安全框架  /233
∣10.1.1  认识Spring Security  /233
∣10.1.2  核心类  /235
10.2  配置Spring Security  /240
∣10.2.1  继承WebSecurityConfigurer Adapter  /240
∣10.2.2  配置自定义策略  /240
∣10.2.3  配置加密方式  /242
∣10.2.4  自定义加密规则  /242
∣10.2.5  配置多用户系统  /242
∣10.2.6  获取当前登录用户信息的几种方式  /244
10.3  【实例36】用Spring Security实现后台登录及权限认证功能  /246
∣10.3.1  引入依赖  /246
∣10.3.2  创建权限开放的页面  /246
∣10.3.3  创建需要权限验证的页面  /247
∣10.3.4  配置Spring Security  /247
∣10.3.5  创建登录页面  /248
∣10.3.6  测试权限  /249
10.4  权限控制方式  /249
∣10.4.1  Spring EL权限表达式  /249
∣10.4.2  通过表达式控制URL权限  /250
∣10.4.3  通过表达式控制方法权限  /252
∣10.4.4  【实例37】使用JSR∣250注解  /254
∣10.4.5  【实例38】实现RBAC权限模型  /256
10.5  认识JWT  /258
10.6  【实例39】用JWT技术为Spring Boot的API增加认证和授权保护  /260
∣10.6.1  配置安全类  /260
∣10.6.2  处理注册  /261
∣10.6.3  处理登录  /262
∣10.6.4  测试多方式注册和登录  /264
∣10.6.5  测试token方式登录和授权  /265
10.7  Shiro——Apache通用安全框架  /266
∣10.7.1  认识Shiro安全框架  /266
∣10.7.2  认识Shiro的核心组件  /267
10.8  【实例40】用Shiro实现管理后台的动态权限功能  /267
∣10.8.1  创建实体  /267
∣10.8.2  实现视图模板  /270
∣10.8.3  进行权限配置  /271
∣10.8.4  实现认证身份功能  /271
∣10.8.5  测试权限  /272
10.9   对比Spring Security与Shiro  /273
第11章  集成Redis，实现高并发  /275
11.1  认识Spring Cache  /275
∣11.1.1  声明式缓存注解  /276
∣11.1.2  【实例41】用Spring Cache进行缓存管理  /278
∣11.1.3  整合Ehcache  /281
∣11.1.4  整合Caffeine  /281
11.2  认识Redis  /282
∣11.2.1  对比Redis与Memcached  /282
∣11.2.2  Redis的适用场景  /285
11.3  Redis的数据类型  /285
11.4  用RedisTemplate操作Redis的5种数据类型  /287
∣11.4.1  认识opsFor方法  /287
∣11.4.2  【实例42】操作字符串  /287
∣11.4.3  【实例43】操作散列  /290
∣11.4.4  【实例44】操作列表  /294
∣11.4.5  【实例45】操作集合  /298
∣11.4.6  【实例46】操作有序集合  /301
∣11.4.7  比较RedisTemplate和StringRedisTemplate  /306
11.5  【实例47】用Redis和MyBatis完成缓存数据的增加、删除、修改、查询功能  /306
∣11.5.1  在Spring Boot中集成Redis  /306
∣11.5.2  配置Redis类  /307
∣11.5.3  创建测试实体类  /308
∣11.5.4  实现实体和数据表的映射关系  /309
∣11.5.5  创建Redis缓存服务层  /309
∣11.5.6  完成增、删、改、查测试API  /310
11.6  【实例48】用Redis和JPA实现缓存文章和点击量  /311
∣11.6.1  实现缓存文章  /311
∣11.6.2  实现统计点击量  /312
∣11.6.3  实现定时同步  /312
11.7  【实例49】实现分布式Session  /313
∣11.7.1  用Redis实现Session共享  /313
∣11.7.2  配置Nginx实现负载均衡  /314
第12章  集成RabbitMQ，实现系统间的数据交换  /316
12.1  认识RabbitMQ  /316
∣12.1.1  介绍RabbitMQ  /316
∣12.1.2  使用场景  /317
∣12.1.3  特性  /318
12.2  RabbitMQ的基本概念  /318
∣12.2.1  生产者、消费者和代理  /318
∣12.2.2  消息队列  /319
∣12.2.3  交换机  /319
∣12.2.4  绑定  /320
∣12.2.5  通道  /321
∣12.2.6  消息确认  /321
12.3  RabbitMQ的6种工作模式  /321
∣12.3.1  简单模式  /321
∣12.3.2  工作队列模式  /321
∣12.3.3  交换机模式  /322
∣12.3.4  Routing转发模式  /322
∣12.3.5  主题转发模式  /322
∣12.3.6  RPC模式  /323
12.4  认识AmqpTemplate接口  /323
∣12.4.1  发送消息  /324
∣12.4.2  接收消息  /324
∣12.4.3  异步接收消息  /325
12.5  在Spring Boot中集成RabbitMQ  /325
∣12.5.1  安装RabbitMQ  /325
∣12.5.2  界面化管理RabbitMQ  /326
∣12.5.3  在Spring Boot中配置RabbitMQ  /327
12.6  在Spring Boot中实现RabbitMQ的4种发送/接收模式  /328
∣12.6.1  【实例50】实现发送和接收队列  /328
∣12.6.2  【实例51】实现发送和接收对象  /330
∣12.6.3  【实例52】实现用接收器接收多个主题  /331
∣12.6.4  【实例53】实现广播模式  /334
12.7  【实例54】实现消息队列延迟功能  /336
第13章  集成NoSQL数据库，实现搜索引擎  /339
13.1  Elasticsearch——搜索应用服务器  /339
∣13.1.1  什么是搜索引擎  /339
∣13.1.2  用数据库实现搜索功能  /339
∣13.1.3  认识Elasticsearch  /343
∣13.1.4  Elasticsearch应用案例  /343
∣13.1.5  对比Elasticsearch与MySQL  /343
∣13.1.6  认识ElasticSearchRepository  /344
∣13.1.7  认识ElasticsearchTemplate  /345
∣13.1.8  认识注解@Document  /345
∣13.1.9  管理索引  /347
13.2  【实例55】用ELK管理Spring Boot应用程序的日志  /348
∣13.2.1  安装Elasticsearch  /348
∣13.2.2  安装Logstash  /349
∣13.2.3  安装Kibana  /350
∣13.2.4  配置Spring Boot项目  /350
∣13.2.5  创建日志计划任务  /351
∣13.2.6  用Kibana查看管理日志  /352
13.3  【实例56】在Spring Boot中集成Elasticsearch，实现增、删、改、查功能  /353
∣13.3.1  集成Elasticsearch  /353
∣13.3.2  创建实体  /353
∣13.3.3  实现增、删、改、查文档的功能  /355
13.4  Elasticsearch查询  /356
∣13.4.1  自定义方法  /356
∣13.4.2  精准查询  /357
∣13.4.3  模糊查询  /359
∣13.4.4  范围查询  /362
∣13.4.5  组合查询  /362
∣13.4.6  分页查询  /363
∣13.4.7  聚合查询  /364
13.5  【实例57】实现产品搜索引擎  /365
13.6  Solr——搜索应用服务器  /367
∣13.6.1  了解Solr  /367
∣13.6.2  安装配置Solr  /367
∣13.6.3  整合Spring Boot和Solr  /368
13.7  【实例58】在Sping Boot中集成Solr，实现数据的增、删、改和查  /369
∣13.7.1  创建User类  /369
∣13.7.2  测试增、删、改、查功能  /369
13.8  对比Elasticsearch和Solr  /372
∣
+++++++++项目实战篇
第14章  开发企业级通用的后台系统  /376
14.1  用JPA实现实体间的映射关系  /376
∣14.1.1  创建用户实体  /376
∣14.1.2  创建角色实体  /377
∣14.1.3  创建权限实体  /378
14.2  用Spring Security实现动态授权（RBAC）功能  /380
∣14.2.1  实现管理（增、删、改、查）管理员角色功能  /380
∣14.2.2  实现管理权限功能  /381
∣14.2.3  实现管理管理员功能  /383
∣14.2.4  配置安全类  /384
∣14.2.5  实现基于RBAC权限控制功能  /386
14.3  监控Spring Boot应用  /387
∣14.3.1  在Spring Boot中集成Actuator  /387
∣14.3.2  在Spring Boot中集成Spring Boot Admin应用监控  /390
∣14.3.3  在Spring Boot中集成Druid 连接池监控  /392
第15章  实现一个类似“京东”的电子商务商城  /394
15.1  用Spring Security实现会员系统  /394
∣15.1.1  实现会员实体  /394
∣15.1.2  实现会员接口  /395
∣15.1.3  实现用户名、邮箱、手机号多方式注册功能  /396
∣15.1.4  实现用RabbitMQ发送会员注册验证邮件  /398
∣15.1.5  实现用户名、邮箱、手机号多方式登录功能  /399
15.2  整合会员系统（Web、APP多端、多方式注册登录）和后台系统  /400
∣15.3  实现购物系统  /401
∣15.3.1  设计数据表  /401
∣15.3.2  实现商品展示功能  /402
∣15.3.3  实现购物车功能  /403
∣15.3.4  用Redis实现购物车数据持久化  /404
15.4  用Redis实现分布式秒杀系统  /406
∣15.4.1  实现抢购功能，解决并发超卖问题  /406
∣15.4.2  缓存页面和限流  /409
15.5  用RabbitMQ实现订单过期取消功能  /409
15.6  实现结算和支付功能  /411
∣15.6.1  实现结算生成订单功能  /411
∣15.6.2  集成支付  /412
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Boot实战派
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Redis入门指南
第1章　简介　1
1.1　历史与发展　1
1.2　特性　2
1.2.1　存储结构　2
1.2.2　内存存储与持久化　3
1.2.3　功能丰富　3
1.2.4　简单稳定　4
第2章　准备　7
2.1　安装Redis　7
2.1.1　在POSIX系统中安装　7
2.1.2　在OS X系统中安装　8
2.1.3　在Windows中安装　9
2.2　启动和停止Redis　11
2.2.1　启动Redis　11
2.2.2　停止Redis　14
2.3　Redis命令行客户端　14
2.3.1　发送命令　14
2.3.2　命令返回值　15
2.4　配置　16
2.5　多数据库　17
第3章　入门　19
3.1　热身　19
3.2　字符串类型　21
3.2.1　介绍　22
3.2.2　命令　22
3.2.3　实践　26
3.2.4　命令拾遗　28
3.3　散列类型　32
3.3.1　介绍　33
3.3.2　命令　34
3.3.3　实践　37
3.3.4　命令拾遗　39
3.4　列表类型　40
3.4.1　介绍　41
3.4.2　命令　41
3.4.3　实践　44
3.4.5　命令拾遗　46
3.5　集合类型　48
3.5.1　介绍　48
3.5.2　命令　49
3.5.3　实践　52
3.5.4　命令拾遗　54
3.6　有序集合类型　57
3.6.1　介绍　57
3.6.2　命令　58
3.6.3　实践　62
3.6.4　命令拾遗　63
第4章　进阶　67
4.1　事务　67
4.1.1　概述　68
4.1.2　错误处理　69
4.1.3　WATCH命令介绍　70
4.2　生存时间　72
4.2.1　命令介绍　73
4.2.2　实现访问频率限制之一　75
4.2.3　实现访问频率限制之二　76
4.2.4　实现缓存　77
4.3　排序　78
4.3.1　有序集合的集合操作　78
4.3.2　SORT命令　79
4.3.3　BY参数　81
4.3.4　GET参数　83
4.3.5　STORE参数　84
4.3.6　性能优化　85
4.4　消息通知　85
4.4.1　任务队列　86
4.4.2　使用Redis实现任务队列　87
4.4.3　优先级队列　88
4.4.4　“发布/订阅”模式　90
4.4.5　按照规则订阅　91
4.5　管道　92
4.6　节省空间　93
4.6.1　精简键名和键值　94
4.6.2　内部编码优化　94
第5章　实践　103
5.1　PHP与Redis　103
5.1.1　安装　104
5.1.2　使用方法　104
5.1.3　简便用法　105
5.1.4　实践：用户注册登录功能　107
5.2　Ruby与Redis　111
5.2.1　安装　111
5.2.2　使用方法　111
5.2.3　简便用法　112
5.2.4　实践：自动完成　112
5.3　Python与Redis　116
5.3.1　安装　116
5.3.2　使用方法　116
5.3.3　简便用法　117
5.3.4　实践：在线的好友　117
5.4　Node.js与Redis　123
5.4.1　安装　123
5.4.2　使用方法　123
5.4.3　简便用法　125
5.4.4　实践：IP地址查询　127
第6章　脚本　131
6.1　概览　131
6.1.1　脚本介绍　132
6.1.2　实例：访问频率限制　132
6.2　Lua语言　133
6.2.1　Lua语法　134
6.2.2　标准库　143
6.2.3　其他库　146
6.3　Redis与Lua　147
6.3.1　在脚本中调用Redis命令　147
6.3.2　从脚本中返回值　148
6.3.3　脚本相关命令　148
6.3.4　应用实例　149
6.4　深入脚本　152
6.4.1　KEYS与ARGV　152
6.4.2　沙盒与随机数　153
6.4.3　其他脚本相关命令　154
6.4.4　原子性和执行时间　155
第7章　管理　157
7.1　持久化　157
7.1.1　RDB方式　157
7.1.2　AOF方式　159
7.2　复制　161
7.2.1　配置　161
7.2.2　原理　163
7.2.3 图结构　164
7.2.4　读写分离　165
7.2.5　从数据库持久化　165
7.3　安全　166
7.3.1　可信的环境　166
7.3.2　数据库密码　166
7.3.3　命名命令　167
7.4　通信协议　167
7.4.1　简单协议　167
7.4.2　统一请求协议　169
7.5　管理工具　170
7.5.1　redis-cli　170
7.5.2　phpRedisAdmin　171
7.5.3　Rdbtools　173
附录A　Redis命令属性　175
A.1　REDIS_CMD_WRITE　175
A.2　REDIS_CMD_DENYOOM　177
A.3　REDIS_CMD_NOSCRIPT　178
A.4　REDIS_CMD_RANDOM　179
A.5　REDIS_CMD_SORT_FOR_SCRIPT　179
A.6　REDIS_CMD_LOADING　179
附录B　配置参数索引　181
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Redis入门指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Redis 深度历险：核心原理与应用实践
第1篇 基础和应用篇 / 1
1.1 授人以鱼不如授人以渔 / 1
1.1.1 由 Redis 面试想到的 / 1
1.1.2 本书的内容范围 / 2
1.1.3 Redis 可以做什么 / 3
1.1.4 小结 / 3
1.1.5 扩展阅读 / 4
1.2 万丈高楼平地起——Redis 基础数据结构 / 4
1.2.1 Redis 的安装 / 5
1.2.2 5 种基础数据结构 / 6
1.2.3 容器型数据结构的通用规则 / 17
1.2.4 过期时间 / 17
1.2.5 思考&作业 / 17
1.3 千帆竞发——分布式锁 / 18
1.3.1 分布式锁的奥义 / 18
1.3.2 超时问题 / 20
1.3.3 可重入性 / 21
1.3.4 思考&作业 / 24
1.4 缓兵之计——延时队列 / 24
1.4.1 异步消息队列 / 24
1.4.2 队列空了怎么办 / 26
1.4.3 阻塞读 / 26
1.4.4 空闲连接自动断开 / 26
1.4.5 锁冲突处理 / 27
1.4.6 延时队列的实现 / 27
1.4.7 进一步优化 / 30
1.4.8 思考&作业 / 31
1.5 节衣缩食——位图 / 31
1.5.1 基本用法 / 31
1.5.2 统计和查找 / 34
1.5.3 魔术指令 bitfield / 35
1.5.4 思考&作业 / 38
1.6 四两拨千斤——HyperLogLog / 38
1.6.1 使用方法 / 39
1.6.2 pfadd 中的 pf 是什么意思 / 41
1.6.3 pfmerge 适合的场合 / 42
1.6.4 注意事项 / 42
1.6.5 HyperLogLog 实现原理 / 42
1.6.6 pf 的内存占用为什么是 12KB / 49
1.6.7 思考&作业 / 50
1.7 层峦叠嶂——布隆过滤器 / 50
1.7.1 布隆过滤器是什么 / 51
1.7.2 Redis 中的布隆过滤器 / 51
1.7.3 布隆过滤器的基本用法 / 52
1.7.4 注意事项 / 59
1.7.5 布隆过滤器的原理 / 60
1.7.6 空间占用估计 / 61
1.7.7 实际元素超出时，误判率会怎样变化 / 62
1.7.8 用不上 Redis 4.0 怎么办 / 63
1.7.9 布隆过滤器的其他应用 / 63
1.8 断尾求生——简单限流 / 64
1.8.1 如何使用 Redis 来实现简单限流策略 / 64
1.8.2 解决方案 / 65
1.8.3 小结 / 67
1.9 一毛不拔——漏斗限流 / 68
1.9.1 Redis-Cell / 71
1.9.2 思考&作业 / 72
1.9.3 扩展阅读：Redis-Cell 作者介绍 / 72
1.10 近水楼台——GeoHash / 73
1.10.1 用数据库来算附近的人 / 73
1.10.2 GeoHash 算法 / 74
1.10.3 Geo 指令的基本用法 / 75
1.10.4 注意事项 / 78
1.11 大海捞针——scan / 79
1.11.1 scan 基本用法 / 80
1.11.2 字典的结构 / 82
1.11.3 scan 遍历顺序 / 82
1.11.4 字典扩容 / 83
1.11.5 对比扩容、缩容前后的遍历顺序 / 84
1.11.6 渐进式 rehash / 85
1.11.7 更多的 scan 指令 / 85
1.11.8 大 key 扫描 / 85
第2 篇 原理篇 / 87
2.1 鞭辟入里——线程 IO 模型 / 87
2.1.1 非阻塞 IO / 87
2.1.2 事件轮询 （多路复用） / 88
2.1.3 指令队列 / 90
2.1.4 响应队列 / 90
2.1.5 定时任务 / 90
2.1.6 扩展阅读 / 90
2.2 交头接耳——通信协议 / 90
2.2.1 RESP / 91
2.2.2 客户端→服务器 / 92
2.2.3 服务器→客户端 / 92
2.2.4 小结 / 95
2.2.5 扩展阅读 / 95
2.3 未雨绸缪——持久化 / 95
2.3.1 快照原理 / 96
2.3.2 fork（多进程） / 96
2.3.3 AOF 原理 / 97
2.3.4 AOF 重写 / 98
2.3.5 fsync / 98
2.3.6 运维 / 98
2.3.7 Redis 4.0 混合持久化 / 99
2.3.8 思考&作业 / 100
2.4 雷厉风行——管道 / 100
2.4.1 Redis 的消息交互 / 100
2.4.2 管道压力测试 / 101
2.4.3 深入理解管道本质 / 102
2.4.4 小结 / 104
2.5 同舟共济——事务 / 104
2.5.1 Redis 事务的基本用法 / 104
2.5.2 原子性 / 105
2.5.3 discard（丢弃） / 106
2.5.4 优化 / 106
2.5.5 watch / 107
2.5.6 注意事项 / 108
2.5.7 思考&作业 / 110
2.6 小道消息——PubSub / 110
2.6.1 消息多播 / 110
2.6.2 PubSub / 111
2.6.3 模式订阅 / 113
2.6.4 消息结构 / 114
2.6.5 PubSub 的缺点 / 115
2.6.6 补充 / 115
2.7 开源节流——小对象压缩 / 115
2.7.1 32bit VS 64bit / 116
2.7.2 小对象压缩存储（ziplist） / 116
2.7.3 内存回收机制 / 120
2.7.4 内存分配算法 / 120
第3 篇 集群篇 / 122
3.1 有备无患——主从同步 / 122
3.1.1 CAP 原理 / 122
3.1.2 最终一致 / 123
3.1.3 主从同步与从从同步 / 123
3.1.4 增量同步 / 124
3.1.5 快照同步 / 124
3.1.6 增加从节点 / 125
3.1.7 无盘复制 / 125
3.1.8 wait 指令 / 125
3.1.9 小结 / 126
3.2 李代桃僵——Sentinel / 126
3.2.1 消息丢失 / 128
3.2.2 Sentinel 基本用法 / 128
3.2.3 思考&作业 / 129
3.3 分而治之——Codis / 130
3.3.1 Codis 分片原理 / 131
3.3.2 不同的 Codis 实例之间槽位关系如何同步 / 132
3.3.3 扩容 / 132
3.3.4 自动均衡 / 133
3.3.5 Codis 的代价 / 133
3.3.6 Codis 的优点 / 134
3.3.7 mget 指令的操作过程 / 134
3.3.8 架构变迁 / 135
3.3.9 Codis 的尴尬 / 135
3.3.10 Codis 的后台管理 / 136
3.3.11 思考&作业 / 136
3.4 众志成城——Cluster / 137
3.4.1 槽位定位算法 / 138
3.4.2 跳转 / 138
3.4.3 迁移 / 138
3.4.4 容错 / 140
3.4.5 网络抖动 / 140
3.4.6 可能下线（PFAIL）与确定下线（Fail） / 141
3.4.7 Cluster 基本用法 / 141
3.4.8 槽位迁移感知 / 142
3.4.9 集群变更感知 / 143
3.4.10 思考&作业 / 143
第4 篇 拓展篇 / 144
4.1 耳听八方——Stream / 144
4.1.1 消息 ID / 145
4.1.2 消息内容 / 145
4.1.3 增删改查 / 145
4.1.4 独立消费 / 147
4.1.5 创建消费组 / 148
4.1.6 消费 / 150
4.1.7 Stream 消息太多怎么办 / 152
4.1.8 消息如果忘记 ack 会怎样 / 153
4.1.9 PEL 如何避免消息丢失 / 153
4.1.10 Stream 的高可用 / 153
4.1.11 分区 Partition / 154
4.1.12 小结 / 154
4.2 无所不知——Info 指令 / 154
4.2.1 Redis 每秒执行多少次指令 / 155
4.2.2 Redis 连接了多少客户端 / 156
4.2.3 Redis 内存占用多大 / 156
4.2.4 复制积压缓冲区多大 / 157
4.2.5 思考&作业 / 158
4.3 拾遗补漏——再谈分布式锁 / 158
4.3.1 Redlock 算法 / 158
4.3.2 Redlock 使用场景 / 159
4.3.3 扩展阅读：redlock-py 的作者 / 160
4.4 朝生暮死——过期策略 / 160
4.4.1 过期的 key 集合 / 160
4.4.2 定时扫描策略 / 160
4.4.3 从节点的过期策略 / 161
4.5 优胜劣汰——LRU / 162
4.5.1 LRU 算法 / 163
4.5.2 近似 LRU 算法 / 164
4.5.3 思考&作业 / 165
4.6 平波缓进——懒惰删除 / 165
4.6.1 Redis 为什么使用懒惰删除 / 165
4.6.2 flush / 166
4.6.3 异步队列 / 166
4.6.4 AOF Sync 也很慢 / 166
4.6.5 更多异步删除点 / 166
4.7 妙手仁心——优雅地使用 Jedis / 167
4.7.1 重试 / 171
4.7.2 思考&作业 / 172
4.8 居安思危——保护 Redis / 172
4.8.1 指令安全 / 172
4.8.2 端口安全 / 173
4.8.3 Lua 脚本安全 / 174
4.8.4 SSL 代理 / 174
4.8.5 小结 / 174
4.9 隔墙有耳——Redis 安全通信 / 175
4.9.1 spiped 原理 / 176
4.9.2 spiped 使用入门 / 176
4.9.3 思考&作业 / 179
第5 篇 源码篇 / 180
5.1 丝分缕析——探索“字符串”内部 / 180
5.1.1 embstr VS raw / 181
5.1.2 扩容策略 / 184
5.1.3 思考&作业 / 184
5.2 循序渐进——探索“字典”内部 / 184
5.2.1 dict 内部结构 / 184
5.2.2 渐进式 rehash / 186
5.2.3 查找过程 / 187
5.2.4 hash 函数 / 188
5.2.5 hash 攻击 / 188
5.2.6 扩容条件 / 188
5.2.7 缩容条件 / 189
5.2.8 set 的结构 / 189
5.2.9 思考&作业 / 189
5.3 挨肩迭背——探索“压缩列表”内部 / 190
5.3.1 增加元素 / 192
5.3.2 级联更新 / 192
5.3.3 intset 小整数集合 / 194
5.3.4 思考&作业 / 195
5.4 风驰电掣——探索“快速列表”内部 / 195
5.4.1 每个 ziplist 存多少元素 / 197
5.4.2 压缩深度 / 198
5.5 凌波微步——探索“跳跃列表”内部 / 198
5.5.1 基本结构 / 199
5.5.2 查找过程 / 199
5.5.3 随机层数 / 200
5.5.4 插入过程 / 201
5.5.5 删除过程 / 202
5.5.6 更新过程 / 203
5.5.7 如果 score 值都一样呢 / 203
5.5.8 元素排名是怎么算出来的 / 203
5.5.9 思考&作业 / 204
5.5.10 题外话 / 204
5.6 破旧立新——探索“紧凑列表”内部 / 205
5.6.1 级联更新 / 207
5.6.2 取代 ziplist 尚需时日 / 207
5.6.3 思考&作业 / 207
5.7 金枝玉叶——探索“基数树”内部 / 207
5.7.1 应用 / 208
5.7.2 结构 / 210
5.7.3 思考&作业 / 213
5.8 精益求精——LFU VS LRU / 213
5.8.1 Redis 对象的热度 / 213
5.8.2 LRU 模式 / 213
5.8.3 LFU 模式 / 214
5.8.4 为什么 Redis 要缓存系统时间戳 / 217
5.8.5 Redis 为什么在获取 lruclock 时使用原子操作 / 217
5.8.6 如何打开 LFU 模式 / 218
5.8.7 思考&作业 / 218
5.9 如履薄冰——懒惰删除的巨大牺牲 / 218
5.9.1 懒惰删除的最初实现不是异步线程 / 219
5.9.2 异步线程方案其实也相当复杂 / 219
5.9.3 异步删除的实现 / 221
5.9.4 队列安全 / 224
5.9.5 思考&作业 / 225
5.10 跋山涉水——深入字典遍历 / 225
5.10.1 一边遍历一边修改 / 226
5.10.2 重复遍历的难题 / 227
5.10.3 迭代器的结构 / 227
5.10.4 迭代过程 / 229
5.10.5 迭代器的选择 / 231
5.10.6 思考&作业 / 232
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Redis 深度历险：核心原理与应用实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Redis入门指南（第2版）
第1章　简介
1.1 历史与发展
1.2 特性
1.2.1 存储结构
1.2.2 内存存储与持久化
1.2.3 功能丰富
1.2.4 简单稳定
第2章　准备
2.1　安装Redis
2.1.1 在POSIX系统中安装
2.1.2　在OS X系统中安装
2.1.3　在Windows中安装
2.2　启动和停止Redis
2.2.1　启动Redis
2.2.2　停止Redis
2.3　Redis命令行客户端
2.3.1　发送命令
2.3.2　命令返回值
2.4　配置
2.5　多数据库
第3章　入门
3.1 热身
3.2 字符串类型
3.2.1 介绍
3.2.2 命令
3.2.3 实践
3.2.4 命令拾遗
3.3 散列类型
3.3.1 介绍
3.3.2 命令
3.3.3 实践
3.3.4 命令拾遗
3.4 列表类型
3.4.1 介绍
3.4.2 命令
3.4.3 实践
3.4.5 命令拾遗
3.5 集合类型
3.5.1 介绍
3.5.2 命令
3.5.3 实践
3.5.4 命令拾遗
3.6 有序集合类型
3.6.1 介绍
3.6.2 命令
3.6.3 实践
3.6.4 命令拾遗
第4章　进阶
4.1　事务
4.1.1　概述
4.1.2　错误处理
4.1.3　WATCH命令介绍
4.2　过期时间
4.2.1　命令介绍
4.2.2　实现访问频率限制之一
4.2.3　实现访问频率限制之二
4.2.4　实现缓存
4.3　排序
4.3.1　有序集合的集合操作
4.3.2　SORT命令
4.3.3　BY参数
4.3.4　GET参数
4.3.5　STORE参数
4.3.6　性能优化
4.4　消息通知
4.4.1　任务队列
4.4.2　使用Redis实现任务队列
4.4.3　优先级队列
4.4.4　"发布/订阅"模式
4.4.5　按照规则订阅
4.5　管道
4.6　节省空间
4.6.1　精简键名和键值
4.6.2　内部编码优化
第5章　实践
5.1 PHP与Redis
5.1.1 安装
5.1.2 使用方法
5.1.3 简便用法
5.1.4 实践：用户注册登录功能
5.2 Ruby与Redis
5.2.1 安装
5.2.2 使用方法
5.2.3 简便用法
5.2.4 实践：自动完成
5.3 Python与Redis
5.3.1 安装
5.3.2 使用方法
5.3.3 简便用法
5.3.4 实践：在线的好友
5.4 Node.js与Redis
5.4.1 安装
5.4.2 使用方法
5.4.3 简便用法
5.4.4 实践：IP地址查询
第6章　脚本
6.1 概览
6.1.1 脚本介绍
6.1.2 实例：访问频率限制
6.2 Lua语言
6.2.1 Lua语法
6.2.2 标准库
6.2.3 其他库
6.3 Redis与Lua
6.3.1 在脚本中调用Redis命令
6.3.2 从脚本中返回值
6.3.3 脚本相关命令
6.3.4 应用实例
6.4 深入脚本
6.4.1 KEYS与ARGV
6.4.2 沙盒与随机数
6.4.3 其他脚本相关命令
6.4.4 原子性和执行时间
第7章　持久化
7.1 RDB方式
7.1.1 根据配置规则进行自动快照
7.1.2 用户执行SAVE或BGSAVE命令
7.1.3 执行FLUSHALL命令
7.1.4 执行复制时
7.1.5 快照原理
7.2 AOF方式
7.2.1 开启AOF
7.2.2 AOF的实现
7.2.3 同步硬盘数据
第8章　集群
8.1 复制
8.1.1 配置
8.1.2 原理
8.1.3 图结构
8.1.4 读写分离与一致性
8.1.5 从数据库持久化
8.1.6 无硬盘复制
8.1.7 增量复制
8.2 哨兵
8.2.1 什么是哨兵
8.2.2 马上上手
8.2.3 实现原理
8.2.4 哨兵的部署
8.3 集群
8.3.1 配置集群
8.3.2 节点的增加
8.3.3 插槽的分配
8.3.4 获取与插槽对应的节点
8.3.5 故障恢复
第9章　管理
9.1 安全
9.1.1 可信的环境
9.1.2 数据库密码
9.1.3 命名命令
9.2 通信协议
9.2.1 简单协议
9.2.2 统一请求协议
9.3 管理工具
9.3.1 redis-cli
9.3.2 phpRedisAdmin
9.3.3 Rdbtools
附录A　Redis命令属性
附录B　配置参数索引
附录C　CRC16实现参考
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Redis入门指南（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Netty、Redis、Zookeeper高并发实战
前言
第1章 高并发时代的必备技能 1
1.1 Netty为何这么火 1
1.1.1 Netty火热的程度 1
1.1.2 Netty是面试的必杀器 2
1.2 高并发利器Redis 2
1.2.1 什么是Redis 2
1.2.2 Redis成为缓存事实标准的原因 3
1.3 分布式利器ZooKeeper 3
1.3.1 什么是ZooKeeper 3
1.3.2 ZooKeeper的优势 4
1.4 高并发IM的综合实践 4
1.4.1 高并发IM的学习价值 4
1.4.2 庞大的应用场景 5
1.5 Netty、Redis、ZooKeeper实践计划 5
1.5.1 第1天：Java NIO实践 5
1.5.2 第2天：Reactor反应器模式实践 6
1.5.3 第3天：异步回调模式实践 7
1.5.4 第4天：Netty基础实践 8
1.5.5 第5天：解码器（Decoder）与编码器（Encoder）实践 9
1.5.6 第6天：JSON和ProtoBuf序列化实践 11
1.5.7 第7~10天：基于Netty的单聊实战 12
1.5.8 第11天：ZooKeeper实践计划 14
1.5.9 第12天：Redis实践计划 14
1.6 本章小结 16
第2章 高并发IO的底层原理 17
2.1 IO读写的基础原理 17
2.1.1 内核缓冲区与进程缓冲区 18
2.1.2 详解典型的系统调用流程 18
2.2 四种主要的IO模型 19
2.2.1 同步阻塞IO（Blocking IO） 20
2.2.2 同步非阻塞NIO（None Blocking IO） 21
2.2.3 IO多路复用模型（IO Multiplexing） 22
2.2.4 异步IO模型（Asynchronous IO） 23
2.3 通过合理配置来支持百万级并发连接 24
2.4 本章小结 26
第3章 Java NIO通信基础详解 27
3.1 Java NIO简介 27
3.1.1 NIO和OIO的对比 28
3.1.2 通道（Channel） 28
3.1.3 Selector 选择器 28
3.1.4 缓冲区（Buffer） 29
3.2 详解NIO Buffer类及其属性 29
3.2.1 Buffer类 29
3.2.2 Buffer类的重要属性 29
3.2.3 4个属性的小结 31
3.3 详解NIO Buffer类的重要方法 31
3.3.1 allocate()创建缓冲区 31
3.3.2 put()写入到缓冲区 32
3.3.3 flip()翻转 33
3.3.4 get()从缓冲区读取 34
3.3.5 rewind()倒带 35
3.3.6 mark( )和reset( ) 37
3.3.7 clear( )清空缓冲区 38
3.3.8 使用Buffer类的基本步骤 38
3.4 详解NIO Channel（通道）类 38
3.4.1 Channel（通道）的主要类型 39
3.4.2 FileChannel文件通道 39
3.4.3 使用FileChannel完成文件复制的实践案例 41
3.4.4 SocketChannel套接字通道 42
3.4.5 使用SocketChannel发送文件的实践案例 44
3.4.6 DatagramChannel数据报通道 46
3.4.7 使用DatagramChannel数据包通道发送数据的实践案例 47
3.5 详解NIO Selector选择器 49
3.5.1 选择器以及注册 49
3.5.2 SelectableChannel可选择通道 50
3.5.3 SelectionKey选择键 50
3.5.4 选择器使用流程 50
3.5.5 使用NIO实现Discard服务器的实践案例 52
3.5.6 使用SocketChannel在服务器端接收文件的实践案例 54
3.6 本章小结 57
第4章 鼎鼎大名的Reactor反应器模式 59
4.1 Reactor反应器模式为何如此重要 59
4.1.1 为什么首先学习Reactor反应器模式 59
4.1.2 Reactor反应器模式简介 60
4.1.3 多线程OIO的致命缺陷 60
4.2 单线程Reactor反应器模式 62
4.2.1 什么是单线程Reactor反应器 62
4.2.2 单线程Reactor反应器的参考代码 63
4.2.3 一个Reactor反应器版本的EchoServer实践案例 65
4.2.4 单线程Reactor反应器模式的缺点 67
4.3 多线程的Reactor反应器模式 68
4.3.1 多线程池Reactor反应器演进 68
4.3.2 多线程Reactor 反应器的实践案例 68
4.3.3 多线程Handler处理器的实践案例 70
4.4 Reactor反应器模式小结 72
4.5 本章小结 73
第5章 并发基础中的Future异步回调模式 74
5.1 从泡茶的案例说起 74
5.2 join异步阻塞 75
5.2.1 线程的join合并流程 75
5.2.2 使用join实现异步泡茶喝的实践案例 75
5.2.3 详解join合并方法 77
5.3 FutureTask异步回调之重武器 77
5.3.1 Callable接口 77
5.3.2 初探FutureTask类 78
5.3.3 Future接口 79
5.3.4 再探FutureTask类 79
5.3.5 使用FutureTask类实现异步泡茶喝的实践案例 80
5.4 Guava的异步回调 82
5.4.1 详解FutureCallback 82
5.4.2 详解ListenableFuture 83
5.4.3 ListenableFuture异步任务 84
5.4.4 使用Guava实现泡茶喝的实践案例 84
5.5 Netty的异步回调模式 87
5.5.1 详解GenericFutureListener接口 87
5.5.2 详解Netty的Future接口 88
5.5.3 ChannelFuture的使用 88
5.5.4 Netty的出站和入站异步回调 89
5.6 本章小结 90
第6章 Netty原理与基础 91
6.1 第一个Netty的实践案例DiscardServer 91
6.1.1 创建第一个Netty项目 91
6.1.2 第一个Netty服务器端程序 92
6.1.3 业务处理器NettyDiscardHandler 93
6.1.4 运行NettyDiscardServer 94
6.2 解密Netty中的Reactor反应器模式 95
6.2.1 回顾Reactor反应器模式中IO事件的处理流程 95
6.2.2 Netty中的Channel通道组件 96
6.2.3 Netty中的Reactor 反应器 96
6.2.4 Netty中的Handler处理器 97
6.2.5 Netty的流水线（Pipeline） 98
6.3 详解Bootstrap启动器类 100
6.3.1 父子通道 100
6.3.2 EventLoopGroup线程组 101
6.3.3 Bootstrap的启动流程 101
6.3.4 ChannelOption通道选项 104
6.4 详解Channel通道 105
6.4.1 Channel通道的主要成员和方法 105
6.4.2 EmbeddedChannel嵌入式通道 107
6.5 详解Handler业务处理器 108
6.5.1 ChannelInboundHandler通道入站处理器 109
6.5.2 ChannelOutboundHandler通道出站处理器 110
6.5.3 ChannelInitializer通道初始化处理器 111
6.5.4 ChannelInboundHandler的生命周期的实践案例 112
6.6 详解Pipeline流水线 115
6.6.1 Pipeline入站处理流程 115
6.6.2 Pipeline出站处理流程 116
6.6.3 ChannelHandlerContext上下文 118
6.6.4 截断流水线的处理 118
6.6.5 Handler业务处理器的热拔插 120
6.7 详解ByteBuf缓冲区 122
6.7.1 ByteBuf的优势 122
6.7.2 ByteBuf的逻辑部分 123
6.7.3 ByteBuf的重要属性 123
6.7.4 ByteBuf的三组方法 124
6.7.5 ByteBuf基本使用的实践案例 125
6.7.6 ByteBuf的引用计数 127
6.7.7 ByteBuf的Allocator分配器 128
6.7.8 ByteBuf缓冲区的类型 130
6.7.9 三类ByteBuf使用的实践案例 131
6.7.10 ByteBuf的自动释放 133
6.8 ByteBuf浅层复制的高级使用方式 136
6.8.1 slice切片浅层复制 136
6.8.2 duplicate整体浅层复制 137
6.8.3 浅层复制的问题 138
6.9 EchoServer回显服务器的实践案例 138
6.9.1 NettyEchoServer回显服务器的服务器端 138
6.9.2 共享NettyEchoServerHandler处理器 139
6.9.3 NettyEchoClient客户端代码 140
6.9.4 NettyEchoClientHandler处理器 142
6.10 本章小结 143
第7章 Decoder与Encoder重要组件 144
7.1 Decoder原理与实践 144
7.1.1 ByteToMessageDecoder解码器 145
7.1.2 自定义Byte2IntegerDecoder整数解码器的实践案例 146
7.1.3 ReplayingDecoder解码器 148
7.1.4 整数的分包解码器的实践案例 149
7.1.5 字符串的分包解码器的实践案例 152
7.1.6 MessageToMessageDecoder解码器 156
7.2 开箱即用的Netty内置Decoder 157
7.2.1 LineBasedFrameDecoder解码器 157
7.2.2 DelimiterBasedFrameDecoder解码器 158
7.2.3 LengthFieldBasedFrameDecoder解码器 159
7.2.4 多字段Head-Content协议数据帧解析的实践案例 162
7.3 Encoder原理与实践 164
7.3.1 MessageToByteEncoder编码器 165
7.3.2 MessageToMessageEncoder编码器 166
7.4 解码器和编码器的结合 167
7.4.1 ByteToMessageCodec编解码器 168
7.4.2 CombinedChannelDuplexHandler组合器 169
7.5 本章小结 169
第8章 JSON和ProtoBuf序列化 171
8.1 详解粘包和拆包 172
8.1.1 半包问题的实践案例 172
8.1.2 什么是半包问题 174
8.1.3 半包现象的原理 174
8.2 JSON协议通信 175
8.2.1 JSON序列化的通用类 175
8.2.2 JSON序列化与反序列化的实践案例 176
8.2.3 JSON传输的编码器和解码器之原理 178
8.2.4 JSON传输之服务器端的实践案例 179
8.2.5 JSON传输之客户端的实践案例 180
8.3 Protobuf协议通信 182
8.3.1 一个简单的proto文件的实践案例 182
8.3.2 控制台命令生成POJO和Builder 183
8.3.3 Maven插件生成POJO和Builder 183
8.3.4 消息POJO和Builder的使用之实践案例 184
8.4 Protobuf编解码的实践案例 187
8.4.1 Protobuf编码器和解码器的原理 187
8.4.2 Protobuf传输之服务器端的实践案例 188
8.4.3 Protobuf传输之客户端的实践案例 189
8.5 详解Protobuf协议语法 191
8.5.1 proto的头部声明 191
8.5.2 消息结构体与消息字段 192
8.5.3 字段的数据类型 193
8.5.4 其他的语法规范 194
8.6 本章小结 195
第9章 基于Netty的单体IM系统的开发实践 196
9.1 自定义ProtoBuf编解码器 196
9.1.1 自定义Protobuf编码器 197
9.1.2 自定义Protobuf解码器 198
9.1.3 IM系统中Protobuf消息格式的设计 199
9.2 概述IM的登录流程 202
9.2.1 图解登录/响应流程的9个环节 203
9.2.2 客户端涉及的主要模块 203
9.2.3 服务器端涉及的主要模块 204
9.3 客户端的登录处理的实践案例 204
9.3.1 LoginConsoleCommand和User POJO 205
9.3.2 LoginSender发送器 207
9.3.3 ClientSession客户端会话 209
9.3.4 LoginResponceHandler登录响应处理器 211
9.3.5 客户端流水线的装配 212
9.4 服务器端的登录响应的实践案例 213
9.4.1 服务器流水线的装配 214
9.4.2 LoginRequestHandler登录请求处理器 215
9.4.3 LoginProcesser用户验证逻辑 216
9.4.4 EventLoop线程和业务线程相互隔离 217
9.5 详解ServerSession服务器会话 218
9.5.1 通道的容器属性 219
9.5.2 ServerSession服务器端会话类 220
9.5.3 SessionMap会话管理器 222
9.6 点对点单聊的实践案例 223
9.6.1 简述单聊的端到端流程 223
9.6.2 客户端的ChatConsoleCommand收集聊天内容 224
9.6.3 客户端的CommandController发送POJO 224
9.6.4 服务器端的ChatRedirectHandler消息转发 225
9.6.5 服务器端的ChatRedirectProcesser异步处理 226
9.6.6 客户端的ChatMsgHandler接收POJO 227
9.7 详解心跳检测 228
9.7.1 网络连接的假死现象 228
9.7.2 服务器端的空闲检测 229
9.7.3 客户端的心跳报文 230
9.8 本章小结 232
第10章 ZooKeeper分布式协调 233
10.1 ZooKeeper伪集群安装和配置 233
10.1.1 创建数据目录和日志目录： 234
10.1.2 创建myid文件 234
10.1.3 创建和修改配置文件 235
10.1.4 配置文件示例 237
10.1.5 启动ZooKeeper伪集群 238
10.2 使用ZooKeeper进行分布式存储 239
10.2.1 详解ZooKeeper存储模型 239
10.2.2 zkCli客户端命令清单 240
10.3 ZooKeeper应用开发的实践 241
10.3.1 ZkClient开源客户端介绍 242
10.3.2 Curator开源客户端介绍 242
10.3.3 Curator开发的环境准备 243
10.3.4 Curator客户端实例的创建 244
10.3.5 通过Curator创建ZNode节点 245
10.3.6 在Curator中读取节点 247
10.3.7 在Curator中更新节点 248
10.3.8 在Curator中删除节点 249
10.4 分布式命名服务的实践 251
10.4.1 ID生成器 252
10.4.2 ZooKeeper分布式ID生成器的实践案例 253
10.4.3 集群节点的命名服务之实践案例 254
10.4.4 使用ZK实现SnowFlakeID算法的实践案例 256
10.5 分布式事件监听的重点 261
10.5.1 Watcher标准的事件处理器 261
10.5.2 NodeCache节点缓存的监听 265
10.5.3 PathChildrenCache子节点监听 267
10.5.4 Tree Cache节点树缓存 272
10.6 分布式锁的原理与实践 276
10.6.1 公平锁和可重入锁的原理 276
10.6.2 ZooKeeper分布式锁的原理 277
10.6.3 分布式锁的基本流程 279
10.6.4 加锁的实现 280
10.6.5 释放锁的实现 285
10.6.6 分布式锁的使用 287
10.6.7 Curator的InterProcessMutex可重入锁 288
10.7 本章小结 289
第11章 分布式缓存Redis 290
11.1 Redis入门 290
11.1.1 Redis安装和配置 290
11.1.2 Redis客户端命令 292
11.1.3 Redis Key的命名规范 294
11.2 Redis数据类型 295
11.2.1 String字符串 295
11.2.2 List列表 296
11.2.3 Hash哈希表 297
11.2.4 Set集合 298
11.2.5 Zset有序集合 299
11.3 Jedis基础编程的实践案例 300
11.3.1 Jedis操作String字符串 301
11.3.2 Jedis操作List列表 303
11.3.3 Jedis操作Hash哈希表 304
11.3.4 Jedis操作Set集合 305
11.3.5 Jedis操作Zset有序集合 306
11.4 JedisPool连接池的实践案例 308
11.4.1 JedisPool的配置 308
11.4.2 JedisPool创建和预热 310
11.4.3 JedisPool的使用 312
11.5 使用spring-data-redis完成 CRUD的实践案例 313
11.5.1 CRUD中应用缓存的场景 313
11.5.2 配置spring-redis.xml 315
11.5.3 使用RedisTemplate模板API 316
11.5.4 使用RedisTemplate模板API完成CRUD的实践案例 321
11.5.5 使用RedisCallback回调完成CRUD的实践案例 323
11.6 Spring的Redis缓存注解 325
11.6.1 使用Spring缓存注解完成CRUD的实践案例 325
11.6.2 spring-redis.xml中配置的调整 327
11.6.3 详解@CachePut和 @Cacheable注解 328
11.6.4 详解@CacheEvict注解 329
11.6.5 详解@Caching组合注解 330
11.7 详解SpringEL（SpEL） 331
11.7.1 SpEL运算符 332
11.7.2 缓存注解中的SpringEL表达式 334
11.8 本章小结 336
第12章 亿级高并发IM架构的开发实践 337
12.1 如何支撑亿级流量的高并发IM架构的理论基础 337
12.1.1 亿级流量的系统架构的开发实践 338
12.1.2 高并发架构的技术选型 338
12.1.3 详解IM消息的序列化协议选型 339
12.1.4 详解长连接和短连接 339
12.2 分布式IM的命名服务的实践案例 340
12.2.1 IM节点的POJO类 341
12.2.2 IM节点的ImWorker类 342
12.3 Worker集群的负载均衡之实践案例 345
12.3.1 ImLoadBalance负载均衡器 346
12.3.2 与WebGate的整合 348
12.4 即时通信消息的路由和转发的实践案例 349
12.4.1 IM路由器WorkerRouter 349
12.4.2 IM转发器WorkerReSender 352
12.5 Feign短连接RESTful调用 354
12.5.1 短连接API的接口准备 355
12.5.2 声明远程接口的本地代理 355
12.5.3 远程API的本地调用 356
12.6 分布式的在线用户统计的实践案例 358
12.6.1 Curator的分布式计数器 358
12.6.2 用户上线和下线的统计 360
12.7 本章小结 361
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Netty、Redis、Zookeeper高并发实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>左手MongoDB，右手Redis——从入门到商业实战
第1篇  基础知识
第1章  进入MongoDB与Redis的世界  2
1.1  非关系型数据库的产生背景与分类  2
1.1.1  关系型数据库遇到的问题  2
1.1.2  非关系型数据库的分类及特点  2
1.2  MongoDB与Redis可以做什么  3
1.2.1  MongoDB适合做什么  3
1.2.2  Redis适合做什么  3
1.3  如何学习MongoDB和Redis  4
1.3.1  项目驱动，先用再学  4
1.3.2  系统梳理，由点到面  4
1.3.3  分清主次，不要在无谓的操作中浪费时间  5
1.3.4  在不同领域中尝试  5
1.4  如何使用本书  5
1.4.1  本书的产品定位  5
1.4.2  本书适用的读者群体  6
1.4.3  如何利用本书实例进行练习  6
第2章  数据存储方式的演进  8
2.1  从文件到MongoDB数据库  8
2.1.1  使用文件保存数据  8
2.1.2  使用MongoDB保存数据  9
2.2  从队列Queue到Redis  9
2.2.1  了解“生产者/消费者”模型  9
2.2.2  实例1：使用Python实现队列  10
2.2.3  Python的Queue及其缺陷  12
2.2.4  实例2：使用Redis替代Queue  12
本章小结  14
第2篇  快速入门
第3章  MongoDB 快速入门  16
3.1  MongoDB和SQL术语对比  16
3.2  安装MongoDB  16
3.2.1  在Windows中安装  16
3.2.2  在Linux中安装  19
3.2.3  在macOS中安装  21
3.3  MongoDB的图形化管理软件——Robo 3T  25
3.3.1  安装  25
3.3.2  认识Robo 3T的界面  28
3.4  MongoDB的基本操作  29
3.4.1  实例3：创建数据库与集合，写入数据  29
3.4.2  实例4：查询数据  36
3.4.3  实例5：修改数据  46
3.4.4  实例6：删除数据  47
3.4.5  实例7：数据去重  49
3.5  使用Python操作MongoDB  51
3.5.1  连接数据库  51
3.5.2  MongoDB命令在Python中的对应方法  53
3.5.3  实例8：插入数据到MongoDB  55
3.5.4  实例9：从MongoDB中查询数据  55
3.5.5  实例10：更新/删除MongoDB中的数据  56
3.6  MongoDB与Python不通用的操作  58
本章小结  64
第4章  实例11：用MongoDB开发员工信息管理系统  65
4.1  了解实例最终目标  65
4.2  准备工作  69
4.2.1  了解文件结构  69
4.2.2  搭建项目运行环境  69
4.2.3  启动项目  72
4.3  项目开发过程  74
4.3.1  生成初始数据  74
4.3.2  实现“查询数据”功能  75
4.3.3  实现“添加数据”功能  79
4.3.4  实现“更新数据”功能  83
4.3.5  实现“删除数据”功能  85
本章小结  88
第5章  Redis快速入门  89
5.1  安装Redis  89
5.1.1  在Windows中安装Redis  89
5.1.2  在Linux中安装Redis  91
5.1.3  在macOS中安装Redis  92
5.1.4  在线测试环境  93
5.2  字符串的创建、查询和修改  94
5.2.1  使用redis-cli实现  94
5.2.2  使用Python实现  99
5.2.3  字符串的应用  103
5.3  列表的创建、查询和修改  105
5.3.1  使用redis-cli实现  105
5.3.2  使用Python实现  110
5.3.3  列表的应用  116
5.4  集合的创建和修改  118
5.4.1  使用redis-cli实现  118
5.4.2  使用Python实现  127
5.4.3  集合的应用  132
本章小结  133
第6章  实例12：用Redis开发一个聊天室  134
6.1  了解实例的最终目标  134
6.2  准备工作  135
6.2.1  了解文件结构  135
6.2.2  搭建项目运行环境  136
6.3  项目开发过程  139
6.3.1  实现登录功能1：创建Redis的连接实例  139
6.3.2  实现登录功能2：实现“检查昵称是否重复”功能  141
6.3.3  实现登录功能3：实现“设置和获取Token”功能  142
6.3.4  实现聊天室页面1：实现“获取聊天消息”功能  145
6.3.5  实现聊天室页面2：实现“发送新信息”功能  148
6.3.6  实现聊天室页面3：设定“刷屏检查字符串”  151
6.3.7  实现聊天室页面4：读取刷屏限制的剩余时间  153
本章小结  154
第3篇  高级应用
第7章  MongoDB的高级语法  156
7.1  AND和OR操作  156
7.1.1  实例13：查询同时符合两个条件的人（AND操作）  156
7.1.2  实例14：查询只符合其中任一条件的人（OR操作）  159
7.1.3  实例15：用Python实现MongoDB的AND与OR操作  162
7.2  查询子文档或数组中的数据  163
7.2.1  认识嵌入式文档  163
7.2.2  实例16：嵌入式文档的应用  164
7.2.3  认识数组字段  167
7.2.4  实例17：数组应用——查询数组包含与不包含“”的数据  168
7.2.5  实例18：数组应用——根据数组长度查询数据  170
7.2.6  实例19：数组应用——根据索引查询数据  170
7.2.7  Python操作嵌入式文档与数组字段  172
7.3  MongoDB的聚合查询  173
7.3.1  聚合的基本语法  173
7.3.2  实例20：筛选数据  174
7.3.3  实例21：筛选与修改字段  177
7.3.4  实例22：分组操作  184
7.3.5  实例23：拆分数组  191
7.3.6  实例24：联集合查询  193
7.3.7  实例25：使用Python执行聚合操作  204
本章小结  205
第8章  MongoDB的优化和安全建议  206
8.1  提高MongoDB读写性能  206
8.1.1  实例26：“批量插入”与“逐条插入”数据，比较性能差异  206
8.1.2  实例27：“插入”与“更新”数据，比较性能差异  214
8.1.3  实例28：使用“索引”提高查询速度  217
8.1.4  实例29：引入Redis，以降低MongoDB的读取频率  218
8.1.5  实例30：增添适当冗余信息，以提高查询速度  219
8.2  提高MongoDB的安全性  221
8.2.1  配置权限管理机制  221
8.2.2  开放外网访问  230
本章小结  233
第9章  Redis的高级数据结构  234
9.1  哈希表的功能和应用  234
9.1.1  实例31：使用Redis记录用户在线状态  234
9.1.2  实例32：使用Python向哈希表中添加数据  239
9.1.3  实例33：使用Python从哈希表中读取数据  241
9.1.4  实例34：使用Python判断哈希表中是否存在某字段，并获取字段数量  244
9.1.5  实例35：在Redis交互环境redis-cli中读/写哈希表  245
9.2  发布消息/订阅频道  247
9.2.1  实例36：实现一对多的消息发布  247
9.2.2  实例37：在Python中发布消息/订阅频道  252
9.2.3  实例38：在redis-cli中发布消息/订阅频道  254
9.3  有序集合  255
9.3.1  实例39：实现排行榜功能  256
9.3.2  实例40：使用Python读写有序集合  258
9.3.3  实例41：在Redis交互环境redis-cli中使用有序集合  264
9.4  Redis的安全管理  266
9.4.1  实例42：设置密码并开放外网访问  266
9.4.2  禁用危险命令  269
本章小结  269
第4篇  商业实战
第10章  实例43：搭建一个类似“知乎”的问答网站  272
10.1  了解实例的最终目标  272
10.2  准备工作  274
10.2.1  了解文件结构  274
10.2.2  搭建实例运行环境  275
10.2.3  运行项目  276
10.3  项目开发过程  278
10.3.1  生成初始数据  278
10.3.2  实现“查询问题列表”功能  279
10.3.3  实现“查询回答”功能  281
10.3.4  实现“提问与回答”功能  282
10.3.5  实现“点赞”与“点踩”功能  283
本章小结  284
第11章  实例44：使用Redis存储网站会话（接第10章实例）  285
11.1  了解实例的最终目标  285
11.1.1  注册账号  285
11.1.2  登录后回答问题  287
11.1.3  修改回答  287
11.1.4  用户回答同一个问题的次数  287
11.1.5  修改提问  288
11.2  准备工作  288
11.2.1  了解文件结构  288
11.2.2  搭建项目运行环境  290
11.2.3  运行实例  290
11.3  开发过程  292
11.3.1  会话管理的基本原理  292
11.3.2  保存与读取用户信息  294
11.3.3  更新问题和回答  295
11.3.4  检查用户名是否已经注册  295
11.3.5  在Redis中储存与删除Session  295
11.3.6  从Redis中获取Session  296
11.3.7  记录和检查“用户回答是否回答了某个问题”  297
本章小结  297
第12章  实例45：大规模验重和问答排序（接第11章实例）  298
12.1  了解实例的最终目标  298
12.1.1  账号验重  298
12.1.2  动态排序  299
12.1.3  注销登录功能  299
12.2.4  翻页功能  300
12.2  准备工作  300
12.2.1  了解文件结构  300
12.2.2  搭建项目运行环境  302
12.2.3  运行项目  302
12.3  开发过程  304
12.3.1  了解“布隆过滤器”的基本原理  304
12.3.2  使用“布隆过滤器”对注册用户进行验重  308
12.3.3  让“问题”与“回答”根据点赞数动态排序  311
本章小结  317
第13章  重构和优化  319
13.1  划分代码层次  319
13.1.1  寻找问题  319
13.1.2  如何重构  321
13.2  MongoDB的常见陷阱  322
13.2.1  默认超时时间  322
13.2.2  硬盘空间的使用  325
13.3  使用Redis的注意事项  326
13.3.1  “多Redis实例”与“单Redis实例多数据库”的差异  326
13.3.2  尽可能为每个Key设置过期时间  328
本章小结  329
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>左手MongoDB，右手Redis——从入门到商业实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Redis
1 为何选择Redis？  1
合适之选？  2
尝试使用Redis  4
流行的使用模式  9
Redis 不合心意？马上再试试！  11
总结  13
2 高级键管理与数据结构  14
Redis 键  14
- - Redis 键模式 15
- - 键分隔符和命名约定 17
手动创建Redis 模式  19
- - 解构Redis 对象映射器  22
- - 键过期 27
- - 键的注意事项 27
大O 符号  28
-- 为自定义代码计算大O 符号 30
回顾Redis 数据结构的时间复杂度  32
- -字符串 32
- -哈希 33
- -列表 34
- -集合 35
有序集合  36
高级有序集合操作  39
位串和位操作  39
HyperLogLogs  41
总结  42
3 内存管理的建议与技巧  43
配置Redis  43
- -主从 44
32 位Redis  44
- - INFO memory 详解 46
键过期  48
LRU 键清除策略  53
创建内存高效的Redis 数据结构  61
- -小巧的哈希、列表、集合和有序集合 61
- -把位、字节和Redis 字符串用作随机访问数组 67
优化哈希，高效存储  68
硬件和网络延迟  71
操作系统建议  73
总结  74
4 Redis 编程第一部分：Redis 核心、客户端和编程语言  75
Redis 的内部结构  75
- - 理解redish 和redisc 82
- - Redis 序列化协议92
- - Redis RDB 格式 95
使用Redis 和Python 创建协程  98
- -使用Nodejs 和Redis 实现Todo 列表应用  102
- -复制与公共访问  105
总结  105
5 Redis 编程第二部分：Lua 脚本、管理与DevOps  106
在Redis 中使用Lua  106
使用Redis 的KEYS 和ARGV  115
Redis 中的高级Lua 脚本  119
- - MARC21 数据提取  119
- -纸质文具在线商店  121
- -让JSON-LD、Lua 和Redis 协同工作 124
Redis Lua 调试器  128
- - Redis 的编程与管理  131
- -主从复制  132
- -使用MULTI 和EXEC 实现事务  134
Redis 在DevOps 中扮演的角色  137
总结  138
6 可伸缩性：Redis 集群和Sentinel  140
数据分区的方法  140
- -范围分区  141
- -列表分区  143
- -哈希分区  146
- -复合分区  147
- -键哈希标签  148
使用Twemproxy 实现Redis 集群  149
- -使用关联数据片段服务器测试Twemproxy  150
- -Redis 集群的背景  156
- -Redis 集群概览  157
使用Redis 集群  158
- - Redis 集群实时重新配置及重新分片  163
- -故障转移  166
- -在Redis 集群中替换或者升级节点  168
使用Redis Sentinel 进行监控  169
- -为区域代码列表分区配置Redis Sentinel  171
总结  174
7 Redis 与互补的NoSQL 技术  175
NoSQL 技术的繁荣  175
Redis 作为MongoDB 的分析补充  179
Redis 作为ElasticSearch 的预处理组件  191
- -在BIBCAT 中使用Redis 和ElasticSearch  191
- - ElasticSearch、Logstash 和Redis  196
Redis 作为Fedora Commons 的智能缓存补充  197
总结  203
8 Docker 容器与云端部署  204
Linux 容器  204
与Redis 相关的Docker 基础  209
Docker 镜像中的层  217
- - Docker 文件系统后端  218
Docker 和Redis 的问题  225
使用Docker Compose 打包应用程序  225
Redis 和AWS  230
专门的云托管选项  231
Redis Labs  232
- - DigitalOcean Redis  232
总结  233
9 任务管理与消息队列  234
Redis 的发布/订阅模式概述  234
- -发布/订阅RESP 回复  235
- - SUBSCRIBE 和UNSUBSCRIBE RESP 数组  235
- - PSUBSCRIBE 和UNSUBSCRIBE 数组  237
- -使用redis-cli 进行发布/订阅  238
Redis 发布订阅实战  240
- -第一个工作站采用Python 进行发布订阅  242
- -第二个工作站采用Nodejs 进行发布订阅  244
- -第三个工作站使用Lua 客户端进行发布订阅  246
Redis 键空间通知  249
使用Redis 和Celery 进行任务管理  253
GIS 和RestMQ  257
使用RestMQ 进行任务管理  260
- -使用Redis 技术进行消息通信  262
使用Disque 进行消息通信  262
总结  264
10 信息流的测量与管理  265
基于Redis 的ETL 方案  265
- -将JSON 转换成RESP  271
- -管理Redis 时的安全考虑  277
- -使用Redis Web 仪表板进行运营监测  280
机器学习  281
- -朴素贝叶斯与工作分类  282
- -使用Redis 实现线性规划  292
总结  296
附录：来源  298
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Redis
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Redis5设计与源码分析
本书赞誉
序
前言
第1章　引言1
1.1　Redis简介1
1.2　Redis 5.0的新特性2
1.3　Redis源码概述3
1.4　Redis安装与调试4
1.5　本章小结6
第2章　简单动态字符串7
2.1　数据结构7
2.2　基本操作11
2.2.1　创建字符串11
2.2.2　释放字符串12
2.2.3　拼接字符串12
2.2.4　其余API15
2.3　本章小结15
第3章　跳跃表17
3.1　简介17
3.2　跳跃表节点与结构19
3.2.1　跳跃表节点19
3.2.2　跳跃表结构20
3.3　基本操作20
3.3.1　创建跳跃表21
3.3.2　插入节点22
3.3.3　删除节点28
3.3.4　删除跳跃表30
3.4　跳跃表的应用31
3.5　本章小结32
第4章　压缩列表33
4.1　压缩列表的存储结构33
4.2　结构体35
4.3　基本操作37
4.3.1　创建压缩列表37
4.3.2　插入元素38
4.3.3　删除元素42
4.3.4　遍历压缩列表44
4.4　连锁更新44
4.5　本章小结45
第5章　字典47
5.1　基本概念47
5.1.1　数组48
5.1.2　Hash函数49
5.1.3　Hash冲突51
5.2　Redis字典的实现52
5.3　基本操作55
5.3.1　字典初始化55
5.3.2　添加元素56
5.3.3　查找元素60
5.3.4　修改元素61
5.3.5　删除元素61
5.4　字典的遍历62
5.4.1　迭代器遍历62
5.4.2　间断遍历65
5.5　API列表70
5.6　本章小结71
第6章　整数集合72
6.1　数据存储72
6.2　基本操作75
6.2.1　查询元素75
6.2.2　添加元素78
6.2.3　删除元素82
6.2.4　常用API83
6.3　本章小结85
第7章　quicklist的实现86
7.1　quicklist简介86
7.2　数据存储87
7.3　数据压缩91
7.3.1　压缩92
7.3.2　解压缩93
7.4　基本操作94
7.4.1　初始化94
7.4.2　添加元素95
7.4.3　删除元素96
7.4.4　更改元素98
7.4.5　查找元素99
7.4.6　常用API100
7.5　本章小结101
第8章　Stream102
8.1　Stream简介102
8.1.1　Stream底层结构listpack103
8.1.2　Stream底层结构Rax简介104
8.1.3　Stream结构108
8.2　Stream底层结构listpack的实现112
8.2.1　初始化112
8.2.2　增删改操作112
8.2.3　遍历操作113
8.2.4　读取元素113
8.3　Stream底层结构Rax的实现114
8.3.1　初始化114
8.3.2　查找元素114
8.3.3　添加元素116
8.3.4　删除元素118
8.3.5　遍历元素120
8.4　Stream结构的实现123
8.4.1　初始化124
8.4.2　添加元素124
8.4.3　删除元素125
8.4.4　查找元素128
8.4.5　遍历129
8.5　本章小结131
第9章　命令处理生命周期132
9.1　基本知识132
9.1.1　对象结构体robj132
9.1.2　客户端结构体client136
9.1.3　服务端结构体redisServer138
9.1.4　命令结构体redisCommand139
9.1.5　事件处理141
9.2　server启动过程149
9.2.1　server初始化149
9.2.2　启动监听152
9.3　命令处理过程155
9.3.1　命令解析156
9.3.2　命令调用159
9.3.3　返回结果161
9.4　本章小结163
第10章　键相关命令的实现164
10.1　对象结构体和数据库结构体回顾164
10.1.1　对象结构体redisObject164
10.1.2　数据库结构体redisDb166
10.2　查看键信息166
10.2.1　查看键属性166
10.2.2　查看键类型169
10.2.3　查看键过期时间170
10.3　设置键信息171
10.3.1　设置键过期时间171
10.3.2　删除键过期时间172
10.3.3　重命名键173
10.3.4　修改键最后访问173
10.4　查找键174
10.4.1　判断键是否存在174
10.4.2　查找符合模式的键175
10.4.3　遍历键176
10.4.4　随机取键177
10.5　操作键178
10.5.1　删除键178
10.5.2　序列化／反序列化键182
10.5.3　移动键183
10.5.4　键排序185
10.6　本章小结187
第11章　字符串相关命令的实现188
11.1　相关命令介绍188
11.2　设置字符串189
11.2.1　set命令189
11.2.2　mset命令195
11.3　修改字符串196
11.3.1　append命令196
11.3.2　setrange命令197
11.3.3　计数器命令197
11.4　字符串获取199
11.4.1　get命令199
11.4.2　getset命令199
11.4.3　getrange命令199
11.4.4　strlen命令200
11.4.5　mget命令201
11.5　字符串位操作201
11.5.1　setbit命令201
11.5.2　getbit命令203
11.5.3　bitpos命令203
11.5.4　bitcount命令205
11.5.5　bitop命令208
11.5.6　bitfield命令209
11.6　本章小结212
第12章　散列表相关命令的实现213
12.1　简介213
12.1.1　底层存储213
12.1.2　底层存储转换215
12.1.3　接口说明215
12.2　设置命令216
12.3　读取命令217
12.3.1　hexists命令218
12.3.2　hget/hmget命令218
12.3.3　hkeys/hvals/hgetall命令219
12.3.4　hlen命令220
12.3.5　hscan命令220
12.4　删除命令221
12.5　自增命令222
12.6　本章小结224
第13章　列表相关命令的实现225
13.1　相关命令介绍225
13.1.1　命令列表225
13.1.2　栈和队列命令列表226
13.2　push/pop相关命令228
13.2.1　push类命令的实现228
13.2.2　pop类命令的实现229
13.2.3　阻塞push/pop类命令的实现230
13.3　获取列表数据234
13.3.1　获取单个元素234
13.3.2　获取多个元素235
13.3.3　获取列表长度236
13.4　操作列表236
13.4.1　设置元素237
13.4.2　插入元素237
13.4.3　删除元素238
13.4.4　裁剪列表239
13.5　本章小结240
第14章　集合相关命令的实现241
14.1　相关命令介绍241
14.2　集合运算254
14.2.1　交集254
14.2.2　并集258
14.2.3　差集260
14.3　本章小结263
第15章　有序集合相关命令的实现264
15.1　相关命令介绍264
15.2　基本操作272
15.2.1　添加成员272
15.2.2　删除成员275
15.2.3　基数统计276
15.2.4　数量计算277
15.2.5　计数器279
15.2.6　获取排名279
15.2.7　获取分值279
15.2.8　遍历280
15.3　批量操作280
15.3.1　范围查找280
15.3.2　范围删除283
15.4　集合运算284
15.5　本章小结284
第16章　GEO相关命令285
16.1　基础知识285
16.2　命令实现288
16.2.1　使用geoadd添加坐标288
16.2.2　计算坐标的geohash291
16.2.3　使用geopos查询位置经纬度292
16.2.4　使用geodist计算两点距离295
16.2.5　使用georadius/georadius-bymembe查询范围内元素295
16.3　本章小结297
第17章　HyperLogLog相关命令的实现298
17.1　基本原理298
17.1.1　算法演进299
17.1.2　线性计数算法299
17.1.3　对数计数算法300
17.1.4　自适应计数算法302
17.1.5　超对数计数算法302
17.2　HLL Redis实现302
17.2.1　HLL头对象303
17.2.2　稀疏编码304
17.2.3　密集编码306
17.2.4　内部编码308
17.2.5　编码转换309
17.3　命令实现310
17.3.1　添加基数310
17.3.2　近似基数311
17.3.3　合并基数313
17.4　本章小结314
第18章　数据流相关命令的实现315
18.1　相关命令介绍315
18.2　基本操作命令原理分析323
18.2.1　添加消息323
18.2.2　删除消息325
18.2.3　范围查找326
18.2.4　获取队列信息327
18.2.5　长度统计327
18.2.6　剪切消息328
18.3　分组命令原理分析328
18.3.1　分组管理328
18.3.2　消费消息330
18.3.3　响应消息331
18.3.4　获取未响应消息列表331
18.3.5　修改指定未响应消息归属331
18.4　本章小结332
第19章　其他命令333
19.1　事务333
19.1.1　事务简介333
19.1.2　事务命令实现334
19.2　发布-订阅命令实现339
19.3　Lua脚本345
19.3.1　初始化Lua环境345
19.3.2　在Lua中调用Redis命令347
19.3.3　Redis和Lua数据类型转换349
19.3.4　命令实现351
19.4　本章小结356
第20章　持久化357
20.1　RDB358
20.1.1　RDB执行流程358
20.1.2　RDB文件结构359
20.2　AOF367
20.2.1　AOF执行流程368
20.2.2　AOF重写369
20.3　RDB与AOF相关配置指令372
20.4　本章小结374
第21章　主从复制375
21.1　主从复制功能实现375
21.2　主从复制源码基础378
21.3　slaver源码分析382
21.4　master源码分析388
21.5　本章小结391
第22章　哨兵和集群392
22.1　哨兵392
22.1.1　哨兵简介393
22.1.2　代码流程394
22.1.3　主从切换396
22.1.4　常用命令399
22.2　集群400
22.2.1　集群简介401
22.2.2　代码流程402
22.2.3　主从切换404
22.2.4　副本漂移406
22.2.5　分片迁移407
22.2.6　通信数据包类型409
22.3　本章小结415
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Redis5设计与源码分析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Redis 4.x Cookbook中文版
第1 章开始使用Redis
1.1 本章概要
1.2 下载和安装Redis
1.3 启动和停止Redis
1.4 使用redis-cli 连接到Redis
1.5 获取服务器信息.
1.6 理解Redis 事件模型
1.7 理解Redis 通信协议
第2 章数据类型
2.1 本章概要
2.2 使用字符串（string）类型
2.3 使用列表（list）类型
2.4 使用哈希（hash）类型
2.5 使用集合（set）类型
2.6 使用有序集合（sorted set）类型
2.7 使用HyperLogLog 类型.
2.8 使用Geo 类型.
2.9 键管理
第3 章数据特性
3.1 本章概要
3.2 使用位图（bitmap）
3.3 设置键的过期时间
3.4 使用SORT 命令
3.5 使用管道（pipeline）
3.6 理解Redis 事务（transaction）
3.7 使用发布订阅（PubSub）
3.8 使用Lua 脚本
3.9 调试Lua 脚本
第4 章使用Redis 进行开发
4.1 本章概要
4.2 Redis 常见应用场景
4.3 使用正确的数据类型
4.4 使用正确的API .
4.5 使用Java 连接到Redis
4.6 使用Python 连接到Redis
4.7 使用Spring Data 连接到Redis
4.8 使用Redis 编写MapReduce 作业
4.9 使用Redis 编写Spark 作业
第5 章复制
5.1 本章概要
5.2 配置Redis 的复制机制
5.3 复制机制的调优
5.4 复制机制的故障诊断
第6 章持久化
6.1 本章概要
6.2 使用RDB
6.3 探究RDB 文件
6.4 使用AOF
6.5 探究AOF 文件
6.6 RDB 和AOF 的结合使用.
第7 章配置高可用和集群
7.1 本章概要
7.2 配置Sentinel
7.3 测试Sentinel
7.4 管理Sentinel
7.5 配置Redis Cluster
7.6 测试Redis Cluster
7.7 管理Redis Cluster
第8 章生产环境部署
8.1 本章概要
8.2 在Linux 上部署Redis
8.3 Redis 安全相关设置
8.4 配置客户端连接选项
8.5 配置内存策略
8.6 基准测试
8.7 日志
第9 章管理Redis
9.1 本章概要
9.2 管理Redis 服务器配置
9.3 使用bin/redis-cli 操作Redis
9.4 备份和恢复
9.5 监控内存使用情况
9.6 管理客户端
9.7 数据迁移
第10 章Redis 的故障诊断
10.1 本章概要
10.2 Redis 的健康检查
10.3 使用SLOWLOG 识别慢查询
10.4 延迟问题的故障诊断
10.5 内存问题的故障诊断
10.6 崩溃问题的故障诊断
第11 章使用Redis 模块扩展Redis
11.1 本章概要.
11.2 加载Redis 模块
11.3 编写Redis 模块
第12 章Redis 生态系统
12.1 本章概要
12.2 Redisson 客户端
12.3 Twemproxy
12.4 Codis—一个基于代理的高性能Redis 集群解决方案
12.5 CacheCloud 管理系统
12.6 Pika—一个与Redis 兼容的NoSQL 数据库
附录A   Windows 环境搭建
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Redis 4.x Cookbook中文版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>NoSQL数据库技术实战
第1篇  NoSQL的兴起与理论基础
第1章  NoSQL与大数据简介	2
1.1  引子——NoSQL在国内使用的案例	2
1.1.1  新浪微博	2
1.1.2  淘宝数据平台	3
1.1.3  视觉中国网站	4
1.1.4  优酷运营数据分析	5
1.1.5  飞信空间	6
1.1.6  豆瓣社区	7
1.2  大数据	8
1.2.1  大数据的度量单位	8
1.2.2  大数据的特点	9
1.3  大数据相关技术	10
1.3.1  大数据采集技术	10
1.3.2  大数据预处理技术	11
1.3.3  大数据存储及管理技术	11
1.3.4  大数据分析及挖掘技术	11
1.3.5  大数据展现与应用技术	12
1.4  NoSQL简介	12
1.4.1  什么是NoSQL	12
1.4.2  关系型数据库简史	13
1.4.3  数据库分类	13
1.4.4  关系型数据库的优势	14
1.4.5  不擅长的处理	15
1.4.6  NoSQL数据库	18
1.5  NoSQL数据库的类型	20
1.5.1  键值（Key/Value）存储	20
1.5.2  面向文档的数据库	21
1.5.3  面向列的数据库	22
1.6  如何使用和学习NoSQL数据库	23
1.6.1  始终只是一种选择	23
1.6.2  在何种程度上信赖它	23
1.7  云数据管理	24
第2章  NoSQL的数据一致性	25
2.1  传统关系数据库中的ACID	25
2.1.1  原子性	25
2.1.2  一致性	25
2.1.3  隔离性	26
2.1.4  持久性	26
2.1.5  举例	26
2.2  CAP理论	27
2.2.1  NoSQL系统是分布式系统	27
2.2.2  CAP理论阐述	27
2.3  AP的例子——DNS系统	29
2.3.1  DNS系统	29
2.3.2  DNS域名解析过程	29
2.3.3  DNS系统是最终一致性的	31
2.4  数据一致性模型与BASE	31
2.4.1  数据一致性模型	31
2.4.2  BASE（Basically Available，Soft-state，Eventual consistency）	32
2.5  数据一致性实现方法	33
2.5.1  Quorum系统NRW策略	33
2.5.2  时间戳策略	34
2.5.3  向量时钟	37
第3章  NoSQL的水平扩展与其他基础知识	41
3.1  所有数据存放在一个服务器上	41
3.2  分片（Sharding）	41
3.3  主从复制	43
3.4  对等（Peer To Peer）复制	44
3.5  复制和分片的同时使用	45
3.6  数据水平扩展的方法总结	46
3.7  分片对数据的划分方式	46
3.7.1  Range-Based Partitioning	47
3.7.2  Round-Robin	49
3.8  一致性hash算法（Consistent Hashing）	50
3.8.1  基本场景	51
3.8.2  hash算法和单调性	51
3.8.3  Consistent Hashing算法的原理	51
3.8.4  虚拟节点	54
3.9  磁盘的读写特点及五分钟法则	55
3.9.1  磁道、扇区、柱面和磁头数	56
3.9.2  固态硬盘（SSD）：随机读写速度快	57
3.9.3  内存：读写速度极快	57
3.9.4  五分钟法则	57
3.10  不要删除数据	58
第2篇  列式NoSQL系统
第4章  BigTable与Google云计算原理	60
4.1  云计算	60
4.1.1  云计算的概念	60
4.1.2  云计算发展现状	63
4.1.3  云计算实现机制	64
4.1.4  网格计算与云计算	66
4.2  Google文件系统GFS	68
4.2.1  系统架构	69
4.2.2  容错机制	71
4.2.3  系统管理技术	72
4.3  并行数据处理MapReduce	73
4.3.1  产生背景	73
4.3.2  编程模型	73
4.3.3  实现机制	74
4.4  分布式锁服务Chubby	78
4.4.1  Paxos算法	78
4.4.2  Chubby系统设计	79
4.4.3  Chubby文件系统	80
4.4.4  通信协议	82
4.4.5  正确性与性能	83
4.5  分布式结构化数据表BigTable	84
4.5.1  设计动机与目标	85
4.5.2  数据模型	85
4.5.3  系统架构	87
4.5.4  主服务器	88
4.5.5  子表服务器	89
4.5.6  性能优化	92
第5章  Google云计算的开源版本——Hadoop	94
5.1  Hadoop简介	94
5.1.1  Hadoop发展史	94
5.1.2  Apache Hadoop项目及体系结构	96
5.2  Hadoop产生的原因	97
5.2.1  海量的数据	97
5.2.2  数据的存储和分析	98
5.3  Hadoop和其他系统的比较	99
5.3.1  和关系型数据库管理系统（RDBMS）的比较	99
5.3.2  和网格计算的比较	100
5.4  HDFS的架构设计	101
5.4.1  前提和设计目标	102
5.4.2  Namenode和Datanode	102
5.4.3  文件系统的Namespace	103
5.4.4  数据复制	103
5.4.5  文件系统元数据的持久化	104
5.4.6  通讯协议	105
5.4.7  健壮性	105
5.4.8  数据组织	106
5.4.9  可访问性	107
5.4.10  空间的回收	107
5.5  安装Hadoop	108
5.5.1  安装JDK 1.7	108
5.5.2  安装Hadoop	109
5.6  HDFS操作	113
5.6.1  使用FS Shell命令操作HDFS	113
5.6.2  编程读写HDFS	118
5.7  Hadoop中的MapReduce模型	119
5.7.1  MapReduce计算模型	119
5.7.2  Hadoop中的Hello World程序	120
5.7.3  运行MapReduce程序	124
5.7.4  Hadoop中的Hello World程序——新的API	125
5.7.5  MapReduce的数据流和控制流	127
5.8  Zookeeper	129
5.8.1  Zookeeper配置安装	129
5.8.2  Zookeeper的数据模型	130
5.8.3  Zookeeper的基本使用	131
5.8.4  ZooKeeper 典型的应用场景	133
5.8.5  统一命名服务（Name Service）	133
5.8.6  共享锁（Locks）	136
5.8.7  队列管理	137
5.8.8  Zookeeper总结	139
5.9  HBase	139
5.9.1  简介	139
5.9.2  逻辑视图	139
5.9.3  物理存储	141
5.9.4  系统架构	144
5.9.5  关键算法/流程	146
5.10  HBase的安装和配置	149
5.11  HBase使用例子	151
第3篇  Key/Value NoSQL系统
第6章  Dynamo：Amazon的高可用键值对存储	156
6.1  简介	156
6.2  背景	157
6.2.1  系统假设和要求	158
6.2.2  服务水平协议（SLA）	158
6.2.3  设计考虑	160
6.3  系统架构	161
6.3.1  系统接口	162
6.3.2  划分算法	162
6.3.3  复制	163
6.3.4  版本的数据	163
6.3.5  执行get()和put()操作	165
6.3.6  故障处理：暗示移交（Hinted Handoff）	166
6.3.7  处理永久性故障：副本同步	167
6.3.8  会员和故障检测	167
6.3.9  添加/删除存储节点	169
6.4  实现	169
6.5  Amazon使用的经验与教训	170
6.5.1  平衡性能和耐久性	171
6.5.2  确保均匀的负载分布	172
6.5.3  不同版本：何时以及有多少	175
6.5.4  客户端驱动或服务器驱动协调	176
6.5.5  权衡后台和前台任务	177
6.5.6  讨论	177
6.6  结论	178
第7章  LevelDb——出自Google的 Key-Value数据库	179
7.1  LevelDb简介	179
7.2  LevelDb的静态部分	180
7.2.1  整体架构	180
7.2.2  log文件	182
7.2.3  SSTable文件	183
7.2.4  MemTable详解	186
7.3  LevelDb的动态部分	187
7.3.1  写入与删除记录	187
7.3.2  读取记录	188
7.3.3  Compaction操作	190
7.3.4  LevelDb中的Cache	192
7.3.5  Version、VersionEdit和VersionSet	194
第8章  Redis实战	195
8.1  Redis安装与准备	195
8.1.1  下载与安装	195
8.1.2  配置文件修改	196
8.1.3  启动Redis	197
8.1.4  停止Redis	198
8.2  Redis所支持的数据结构	198
8.2.1  String	199
8.2.2  List	203
8.2.3  Set	207
8.2.4  Hash/哈希/散列	210
8.2.5  有序集合/Zset	213
8.3  Key操作命令	218
8.3.1  概述	218
8.3.2  命令示例	220
8.4  事物	223
8.4.1  事物概述	223
8.4.2  相关命令	223
8.4.3  命令示例	224
8.4.4  WATCH命令和基于CAS的乐观锁	225
8.5  Redis的主从复制	226
8.5.1  Redis的Replication	226
8.5.2  Replication的工作原理	227
8.5.3  如何配置Replication	227
8.5.4  应用示例	228
8.6  Redis的持久化	228
8.6.1  持久化机制	228
8.6.2  RDB机制的优势和劣势	229
8.6.3  AOF机制的优势和劣势	229
8.6.4  其他	230
8.7  Redis的虚拟内存	231
8.7.1  简介	231
8.7.2  应用场景	231
8.7.3  配置	231
8.8  pipeline/管线	233
8.8.1  请求应答协议和RTT	233
8.8.2  管线（pipelining）	233
8.8.3  Benchmark	234
8.9  实例	234
第4篇  文档型NoSQL系统
第9章  面向文档的数据库CouchDB	240
9.1  CouchDB介绍	240
9.1.1  基本概念	240
9.1.2  扩展概念	241
9.2  CouchDB安装与配置	241
9.3  REST API	242
9.3.1  数据库REST API	243
9.3.2  文档REST API	243
9.3.3  视图 REST API	243
9.3.4  附件 REST API	244
9.4  为应用建模	244
9.4.1  描述实体	244
9.4.2  描述一对一和一对多关系	245
9.4.3  描述多对多关系	246
9.5  实战开发	247
9.5.1  开发Web应用	247
9.5.2  使用CouchDB jQuery插件	248
9.5.3  示例应用建模	249
9.5.4  管理文档	250
9.5.5  视图	253
9.6  高级话题	259
9.6.1  权限控制与安全	259
9.6.2  文档更新校验	259
9.6.3  分组	259
9.6.4  键的排序	260
第10章  MongoDB实战	261
10.1  为什么要使用MongoDB	261
10.1.1  不能确定的表结构信息	261
10.1.2  序列化可以解决一切问题吗	261
10.1.3  无需定义表结构的数据库	262
10.2  MongoDB的优势和不足	262
10.2.1  无表结构	262
10.2.2  容易扩展	263
10.2.3  丰富的功能	263
10.2.4  性能卓越	264
10.2.5  简便的管理	264
10.2.6  MongoDB的不足	264
10.3  基本概念	264
10.4  Linux下MongoDB的安装和配置、启动和停止	265
10.4.1  下载	265
10.4.2  安装	266
10.4.3  启动数据库	267
10.4.4  停止数据库	269
10.5  创建、更新及删除文档	270
10.5.1  连接数据库	270
10.5.2  插入记录	270
10.5.3  _id key	272
10.5.4  修改记录	272
10.5.5  删除记录	272
10.6  查询记录	273
10.6.1  普通查询	273
10.6.2  条件查询	274
10.6.3  findOne()语法	274
10.6.4  通过limit限制结果集数量	274
10.7  高级查询	275
10.7.1  条件操作符	275
10.7.2  $all匹配所有	275
10.7.3  $exists判断字段是否存在	276
10.7.4  Null值处理	276
10.7.5  $mod取模运算	276
10.7.6  $ne不等于	277
10.7.7  $in包含	277
10.7.8  $nin不包含	278
10.7.9  $size数组元素个数	278
10.7.10  正则表达式匹配	278
10.7.11  JavaScript查询和$where查询	279
10.7.12  count查询记录条数	279
10.7.13  skip限制返回记录的起点	279
10.7.14  sort排序	280
10.7.15  游标	280
10.8  MapReduce	281
10.8.1  Map	282
10.8.2  Reduce	282
10.8.3  Result	282
10.8.4  Finalize	283
10.8.5  Options	283
10.9  索引	284
10.9.1  基础索引	284
10.9.2  文档索引	285
10.9.3  组合索引	285
10.9.4  唯一索引	285
10.9.5  强制使用索引	286
10.9.6  删除索引	287
10.10  性能优化	287
10.10.1  explain执行计划	287
10.10.2  优化器Profile	288
10.10.3  性能优化举例	289
10.11  性能监控	290
10.11.1  mongosniff	291
10.11.2  Mongostat	292
10.11.3  db.serverStatus	292
10.11.4  db.stats	294
10.11.5  第三方工具	294
10.12  Replica Sets复制集	294
10.12.1  部署Replica Sets	295
10.12.2  主从操作日志oplog	297
10.12.3  主从配置信息	298
10.12.4  管理维护Replica Sets	299
10.12.5  增减节点	301
10.13  Sharding分片	305
10.13.1  建立Sharding Cluster	306
10.13.2  管理维护Sharding	308
10.14  Replica Sets和Sharding的结合	313
10.14.1  创建数据目录	314
10.14.2  配置Replica Sets	314
10.14.3  配置3台Route Process	316
10.14.4  配置Shard Cluster	316
10.14.5  验证Sharding正常工作	317
第5篇  MySQL基础与性能优化
第11章  MySQL基础	320
11.1  CentOS 6.5下MySQL的安装	320
11.2  MySQL基本命令	322
11.3  MySQL数据类型	325
11.3.1  整型	325
11.3.2  浮点型	326
11.3.3  定点数	326
11.3.4  字符串（char,varchar,xxxtext）	326
11.3.5  二进制数据	327
11.3.6  日期时间类型	327
11.3.7  数据类型的属性	327
11.4  创建数据库和表	328
11.5  检索表中的数据	331
11.6  多个表的操作	334
第12章  MySQL高级特性与性能优化	338
12.1  MySQL Server系统架构	338
12.1.1  逻辑模块组成	338
12.1.2  各模块工作配合	341
12.2  存储引擎	343
12.2.1  MySQL存储引擎概述	343
12.2.2  MyISAM存储引擎简介	344
12.2.3  Innodb 存储引擎简介	346
12.3  MySQL中的锁定机制	347
12.3.1  MySQL中锁定机制概述	347
12.3.2  合理利用锁机制优化MySQL	349
12.4  索引与优化	350
12.4.1  选择索引的数据类型	351
12.4.2  索引入门	351
12.4.3  索引的类型	352
12.4.4  高性能的索引策略	353
12.4.5  索引与加锁	358
12.5  MySQL的MyISAM和Innodb的Cache优化	359
12.5.1  MyISAM存储引擎的Cache优化	359
12.5.2  Innodb缓存相关优化	362
12.6  MySQL的复制	364
12.6.1  复制对于可扩展性的意义	364
12.6.2  复制的原理	365
12.6.3  体验MySQL复制	366
12.6.4  复制的常用拓扑结构	370
12.7  可扩展性设计之数据切分	375
12.7.1  何谓数据切分	375
12.7.2  数据的垂直切分	375
12.7.3  数据的水平切分	377
12.7.4  垂直与水平联合切分的使用	379
12.7.5  数据切分及整合方案	381
12.7.6  数据切分与整合中可能存在的问题	386
12.8  小结	388



>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>NoSQL数据库技术实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>重新发现制度
第一章  政治学的制度主义视角第二章  规则与行为制度化第三章  意义的诠释与制度化第四章  政治制度的转型第五章  作为专项行动的制度改革第六章  作为公共政策的制度改革第七章  对恰适性制度的探寻第八章  偏好、权力与民主制度第九章  政治制度的作用参考文献索引致谢探寻政治生活中的制度逻辑（译后记）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>重新发现制度
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>原來如此(1)：還原聖經希伯來脈絡，重現基督教信仰精義
前言
第1章聖經根據
第2章盟約
第3章訂婚之約
第4章魔鬼與污鬼
第5章金燈台
第6章神話與真理的對照
第7章反盟約
第8章上帝的節期
第9章 上帝的色彩
第10章 邁向啟示錄
附錄 A比較：以諾書與啟示錄的對照
附註
參考書目
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>原來如此(1)：還原聖經希伯來脈絡，重現基督教信仰精義
