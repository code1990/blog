1	{"count":20,"start":0,"total":1198604,"books":[{"rating":{"max":10,"numRaters":1850,"average":"8.9","min":0},"subtitle":"C语言描述","author":["维斯"],"pubdate":"2004-1-1","tags":[{"count":2183,"name":"数据结构","title":"数据结构"},{"count":1727,"name":"算法","title":"算法"},{"count":976,"name":"计算机","title":"计算机"},{"count":900,"name":"数据结构与算法分析","title":"数据结构与算法分析"},{"count":731,"name":"编程","title":"编程"},{"count":706,"name":"算法、数据结构","title":"算法、数据结构"},{"count":647,"name":"C","title":"C"},{"count":552,"name":"C语言","title":"C语言"}],"origin_title":"Data Structures and Algorithm Analysis in C:Second Edition","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s28015501.jpg","binding":"平装","translator":["冯舜玺"],"catalog":"第1章 引论\n1．1 本书讨论的内容\n1．2 数学知识复习\n1．2．1 指数\n1．2．2 对数\n1．2．3 级数\n1．2．4 模运算\n1. 2．5 证明方法\n1．3 递归简论\n总结\n练习\n参考文献\n第2章 算法分析\n2．1 数学基础\n2．2 模型\n2．3 要分析的问题\n2．4 运行时间计算\n2．4．1 一个简单的例子\n2．4．2 一般法则\n2．4．3 最大子序列和问题的解\n.2．4．4 运行时间中的对数\n2．4．5 检验你的分析\n2．4．6 分析结果的准确性\n总结\n练习\n参考文献\n第3章 表、栈和队列\n3．1 抽象数据类型(adt)\n3．2 表adt\n3．2．1 表的简单数组实现\n3．2．2 链表\n3．2．3 程序设计细节\n3．2．4 常见的错误\n3．2．5 双链表\n3．2．6 循环链表\n3．2．7 例子\n3．2．8 链表的游标实现\n3．3 栈adt\n3．3．1 栈模型\n3．3．2 栈的实现\n3．3．3 应用\n3．4 队列adt\n3．4．1 队列模型\n3．4．2 队列的数组实现\n3．4．3 队列的应用\n总结\n练习\n第4章 树\n4．1 预备知识\n4．1．1 树的实现\n4．1．2 树的遍历及应用\n4．2 二叉树\n4．2．1 实现\n4．2．2 表达式树\n4．3 查找树adt--二叉查找树\n4．3．1 makeempty\n4．3．2 find\n4．3．3 findmin和findmax\n4．3．4 insert\n4．3．5 delere\n4．3．6 平均情形分析\n4．4 avl树\n4．4．1 单旋转\n4．4．2 双旋转\n4．5 伸展树\n4．5．1 一个简单的想法\n4．5．2 展开\n4．6 树的遍历\n4．7 b-树\n总结\n练习\n参考文献\n第5章 散列\n5．1 一般想法\n5．2 散列函数\n5．3 分离链接法\n5．4 开放定址法\n5．4．1 线性探测法\n5．4．2 平方探测法\n5．4．3 双散列\n5．5 再散列\n5．6 可扩散列\n总结\n练习\n参考文献\n第6章 优先队列(堆)\n6．1 模型\n6．2 一些简单的实现\n6．3 二叉堆\n6．3．1 结构性质\n6．3．2 堆序性质\n6．3．3 基本的堆操作\n6．3．4 其他的堆操作\n6．4 优先队列的应用\n6．4．1 选择问题\n6．4．2 事件模拟\n6．5 d-堆\n6．6 左式堆\n6．6．1 左式堆的性质\n6．6．2 左式堆的操作\n6．7 斜堆\n6．8 二项队列\n6．8．1 二项队列结构\n6．8．2 二项队列操作\n6．8．3 二项队列的实现\n总结\n练习\n参考文献\n第7章 排序\n7．1 预备知识\n7．2 插入排序\n7．2．1 算法\n7．2．2 插入排序的分析\n7．3 一些简单排序算法的下界\n7. 4 希尔排序\n7．4．1 希尔排序的最坏情形分析\n7．5 堆排序\n7．5．1 堆排序的分析\n7．6 归并排序\n7．6．1 归并排序的分析\n7．7 快速排序\n7．7．1 选取枢纽元\n7．7．2 分割策略\n7．7．3 小数组\n7．7．4 实际的快速排序例程\n7．7．5 快速排序的分析\n7．7．6 选择的线性期望时间算法\n7．8 大型结构的排序\n7．9 排序的一般下界\n7．9．1 决策树\n7．10 桶式排序\n7．11 外部排序\n7．11．1 为什么需要新的算法\n7．11．2 外部排序模型\n7．11．3 简单算法\n7．11．4 多路合并\n7．11．5 多相合并\n7．11．6 替换选择\n总结\n练习\n参考文献\n第8章 不相交集adt\n8．1 等价关系\n8．2 动态等价性问题\n8．3 基本数据结构\n8．4 灵巧求并算法\n8．5 路径压缩\n8．6 按秩求并和路径压缩的最坏情形\n8．6．1 union／find算法分析\n8．7 一个应用\n总结\n练习\n参考文献\n第9章 图论算法\n9．1 若干定义\n9．1．1 图的表示\n9．2 拓扑排序\n9．3 最短路径算法\n9．3．1 无权最短路径\n9．3．2 dijkstra算法\n9．3．3 具有负边值的图\n9．3．4 无圈图\n9．3．5 所有点对最短路径\n9．4 网络流问题\n9．4．1 一个简单的最大流算法\n9．5 最小生成树\n9．5．1 prim算法\n9．5．2 kruskal算法\n9．6 深度优先搜索的应用\n9．6．1 无向图\n9．6．2 双连通性\n9．6．3 欧拉回路\n9．6．4 有向图\n9．6．5 查找强分支\n9．7 np-完全性介绍\n9．7．1 难与易\n9．7．2 np类\n9．7．3 np-完全问题\n总结\n练习\n参考文献\n第10章 算法设计技巧\n10．1 贪婪算法\n10．1．1 一个简单的调度问题\n10．1．2 huffman编码\n10．1．3 近似装箱问题\n10．2 分治算法\n10．2．1 分治算法的运行时间\n10．2．2 最近点问题\n10．2．3 选择问题\n10．2．4 一些运算问题的理论改进\n10．3 动态规划\n10．3．1 用一个表代替递归\n10．3．2 矩阵乘法的顺序安排\n10．3．3 最优二叉查找树\n10．3．4 所有点对最短路径\n10．4 随机化算法\n10．4．1 随机数发生器\n10．4．2 跳跃表\n10．4．3 素性测试\n10．5 回溯算法\n10．5．1 收费公路重建问题\n10．5．2 博弈\n总结\n练习\n参考文献\n第11章 摊还分析\n11．1 一个无关的智力问题\n11．2 二项队列\n11．3 斜堆\n11．4 斐波那契堆\n11．4．1 切除左式堆中的节点\n11．4．2 二项队列的懒惰合并\n11．4．3 斐波那契堆操作\n11．4．4 时间界的证明\n11. 5 伸展树\n总结\n练习\n参考文献\n第12章 高级数据结构及其实现\n12．1 自顶向下伸展树\n12．2 红黑树\n12．2．1 自底向上插入\n12．2．2 自顶向下红黑树\n12．2．3 自顶向下删除\n12．3 确定性跳跃表\n12．4 aa-树\n12．5 treap树\n12．6 k-d树\n12．7 配对堆\n总结\n练习\n参考文献\n索引","pages":"391","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s28015501.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s28015501.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s28015501.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1139426\/","id":"1139426","publisher":"机械工业出版社","isbn10":"711112748X","isbn13":"9787111127482","title":"数据结构与算法分析","url":"https:\/\/api.douban.com\/v2\/book\/1139426","alt_title":"Data Structures and Algorithm Analysis in C:Second Edition","author_intro":"Mark Allen Weiss，1987年在普林斯顿大学获得计算机科学博士学位，师从Robert Sedgewick (师从Knuth)，现任美国佛罗里达国际大学计算与信息科学学院教授。他曾经担任全美AP(Advanced Placement)考试计算机学科委员会的主席(2000-2004)。他的主要研究方向是数据结构、算法和教育学。","summary":"本书是《Data Structures and Algorithm Analysis in C》一书第2版的简体中译本。原书曾被评为20世纪顶尖的30部计算机著作之一，作者Mark Allen Weiss在数据结构和算法分析方面卓有建树，他的数据结构和算法分析的著作尤其畅销，并受到广泛好评．已被世界500余所大学用作教材。\n在本书中，作者更加精炼并强化了他对算法和数据结构方面创新的处理方法。通过C程序的实现，着重阐述了抽象数据类型的概念，并对算法的效率、性能和运行时间进行了分析。\n全书特点如下：\n●专用一章来讨论算法设计技巧，包括贪婪算法、分治算法、动态规划、随机化算法以及回溯算法\n●介绍了当前流行的论题和新的数据结构，如斐波那契堆、斜堆、二项队列、跳跃表和伸展树\n●安排一章专门讨论摊还分析，考查书中介绍的一些高级数据结构\n●新开辟一章讨论高级数据结构以及它们的实现，其中包括红黑树、自顶向下伸展树。treap树、k-d树、配对堆以及其他相关内容\n●合并了堆排序平均情况分析的一些新结果\n本书是国外数据结构与算法分析方面的标准教材，介绍了数据结构(大量数据的组织方法)以及算法分析(算法运行时间的估算)。本书的编写目标是同时讲授好的程序设计和算法分析技巧，使读者可以开发出具有最高效率的程序。 本书可作为高级数据结构课程或研究生一年级算法分析课程的教材，使用本书需具有一些中级程序设计知识，还需要离散数学的一些背景知识。","series":{"id":"1163","title":"计算机科学丛书"},"price":"35.00元"},{"rating":{"max":10,"numRaters":1332,"average":"8.9","min":0},"subtitle":"C语言调试指南","author":["凯尼格"],"pubdate":"2008-2-1","tags":[{"count":708,"name":"C语言","title":"C语言"},{"count":437,"name":"编程","title":"编程"},{"count":318,"name":"C","title":"C"},{"count":278,"name":"计算机","title":"计算机"},{"count":248,"name":"c","title":"c"},{"count":210,"name":"C\/C++","title":"C\/C++"},{"count":194,"name":"经典","title":"经典"},{"count":179,"name":"程序设计","title":"程序设计"}],"origin_title":"C Traps and Pitfalls","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s2870233.jpg","binding":"平装","translator":["高巍"],"catalog":"第0章　导读\n第1章　词法“陷阱”\n1.1　=不同于==\n1.2　& 和 | 不同于&& 和 ||\n1.3　词法分析中的“贪心法”\n1.4　整型常量\n1.5　字符与字符串\n第2章　语法“陷阱”\n2.1　理解函数声明\n2.2　运算符的优先级问题\n2.3　注意作为语句结束标志的分号\n2.4　switch语句\n2.5　函数调用\n2.6　“悬挂”else引发的问题\n第3章　语义“陷阱”\n3.1　指针与数组\n3.2　非数组的指针\n3.3　作为参数的数组声明\n3.4　避免“举隅法”\n3.5　空指针并非空字符串\n3.6　边界计算与不对称边界\n3.7　求值顺序\n3.8　运算符&&、|| 和 !\n3.9　整数溢出\n3.10　为函数main提供返回值\n第4章　连接\n4.1　什么是连接器\n4.2　声明与定义\n4.3　命名冲突与static修饰符\n4.4　形参、实参与返回值\n4.5　检查外部类型\n4.6　头文件\n第5章　库函数\n5.1　返回整数的getchar函数\n5.2　更新顺序文件\n5.3　缓冲输出与内存分配\n5.4　使用errno检测错误\n5.5　库函数signal\n第6章　预处理器\n6.1　不能忽视宏定义中的空格\n6.2　宏并不是函数\n6.3　宏并不是语句\n6.4　宏并不是类型定义\n第7章　可移植性缺陷\n7.1　应对C语言标准变更\n7.2　标识符名称的限制\n7.3　整数的大小\n7.4　字符是有符号整数还是无符号整数\n7.5　移位运算符\n7.6　内存位置0\n7.7　除法运算时发生的截断\n7.8　随机数的大小\n7.9　大小写转换\n7.10　首先释放，然后重新分配\n7.11　可移植性问题的一个例子\n第8章　建议与答案\n8.1　建议\n8.2　答案\n附录A　PRINTF，VARARGS与STDARG\n附录B　Koenig和Moo夫妇访谈","pages":"172","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s2870233.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s2870233.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s2870233.jpg"},"alt":"https:\/\/book.douban.com\/subject\/2778632\/","id":"2778632","publisher":"人民邮电出版社","isbn10":"7115171793","isbn13":"9787115171795","title":"C陷阱与缺陷","url":"https:\/\/api.douban.com\/v2\/book\/2778632","alt_title":"C Traps and Pitfalls","author_intro":"Andrew Koenig 是AT&T公司Shannon实验室大规模编程研究部门中的成员，同时也是C++标准委员会的项目编辑。他的编程经验超过30年，其中有15年在使用C++，他已经出版了超过150 篇和C++有关的论文，并且在世界范围内就这个主题进行过多次演讲。","summary":"作者以自己1985年在Bell实验室时发表的一篇论文为基础，结合自己的工作经验扩展成为这本对C程序员具有珍贵价值的经典著作。写作本书的出发点不是要批判C语言，而是要帮助C程序员绕过编程过程中的陷阱和障碍。..\n全书分为8章，分别从词法分析、语法语义、连接、库函数、预处理器、可移植性缺陷等几个方面分析了C编程中可能遇到的问题。最后，作者用一章的篇幅给出了若干具有实用价值的建议。..\n本书适合有一定经验的C程序员阅读学习，即便你是C编程高手，本书也应该成为你的案头必备书籍。","series":{"id":"9931","title":"C和C++经典著作"},"price":"30.00元"},{"rating":{"max":10,"numRaters":4408,"average":"9.4","min":0},"subtitle":"第 2 版·新版","author":["（美）Brian W. Kernighan","（美）Dennis M. Ritchie"],"pubdate":"2004-1","tags":[{"count":3001,"name":"C","title":"C"},{"count":2408,"name":"c语言","title":"c语言"},{"count":2131,"name":"编程","title":"编程"},{"count":1549,"name":"计算机","title":"计算机"},{"count":1291,"name":"程序设计","title":"程序设计"},{"count":1080,"name":"经典","title":"经典"},{"count":987,"name":"编程语言","title":"编程语言"},{"count":869,"name":"C\/C++","title":"C\/C++"}],"origin_title":"The C Programming Language","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1106934.jpg","binding":"平装","translator":["徐宝文","李志译","尤晋元审校"],"catalog":"出版者的话\n专家指导委员会\n中文版序\n译者序\n校译者简介\n序\n第1版序\n引言\n第1章 导言\n1.1 入门\n1.2 变量与算术表态式\n1.3 for语句\n1.4 符号常量\n1.5 字符输入\/输出\n1.6 数组\n1.7 函数\n1.8 参数——传值调用\n1.9 字符数组\n1.10 外部变量与作用域\n第2章 类型、运算符与表达式\n2.1 变量名\n2.2 数据类型及长度\n2.3 常量\n2.4 声明\n2.5 算术运算符\n2.6 关系运算符与逻辑运算符\n2.7 类型转换\n2.8 自增运算符与自减运算符\n2.9 按位运算符\n2.10 赋值运算符与表达式\n2.11 条件表达式\n2.12 运算符优先级与求值次序\n第3章 控制流\n3.1 语句与程序块\n3.2 if-else语句\n3.3 else-if语句\n3.4 switch语句\n3.5 whil循环与for特环\n3.6 do-while循环\n3.7 break语句与continue语句\n3.8 goto语句与标号\n第4章 涵数与程序结构\n第5章 指针与数组\n第6章 结构\n第7章 输入与输出\n第8章 UNIX系统接口\n附录A 参考手册\n附录B 标准库\n附录C 变更小结\n索引","pages":"258","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s1106934.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s1106934.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1106934.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1139336\/","id":"1139336","publisher":"机械工业出版社","isbn10":"7111128060","isbn13":"9787111128069","title":"C程序设计语言","url":"https:\/\/api.douban.com\/v2\/book\/1139336","alt_title":"The C Programming Language","author_intro":"Brian W. Kernighan： 贝尔实验室计算科学研究中心高级研究人员，著名的计算机科学家。他参加了UNIX系统、C语言、AWK语言和许多其他系统的开发，同时出版了许多在计算机领域具有影响的著作，如《The Elements of Programming Style》、《The Practice of Programming》、《The UNIX Programming Environment》、《The AWK Language》、《Software Tools》等。\nDennis M. Ritchie：1967年加入贝尔实验室。他和Ken L. Thompson两人共同设计并实现的C语言改变了程序设计语言发展的轨迹，是程序设计语言发展过程中的一个重要里程碑。与此同时，他们两人还设计并实现了UNIX操作系统。正是由于这两项巨大贡献，Dennis M. Ritchie于1983年获得了计算机界的最高奖——图灵奖。此外，他还获得了ACM、IEEE、贝尔实验室等授予的多种奖项.。","summary":"在计算机发展的历史上，没有哪一种程序设计语言像C语言这样应用广泛。本书原著即为C语言的设计者之一Dennis M.Ritchie和著名计算机科学家Brian W.Kernighan合著的一本介绍C语言的权威经典著作。我们现在见到的大量论述C语言程序设计的教材和专著均以此书为蓝本。原著第1版中介绍的C语言成为后来广泛使用的C语言版本——标准C的基础。人们熟知的“hello,World\"程序就是由本书首次引入的，现在，这一程序已经成为众多程序设计语言入门的第一课。\n原著第2版根据1987年制定的ANSIC标准做了适当的修订．引入了最新的语言形式，并增加了新的示例，通过简洁的描述、典型的示例，作者全面、系统、准确地讲述了C语言的各个特性以及程序设计的基本方法。对于计算机从业人员来说，《C程序设计语言》是一本必读的程序设计语 言方面的参考书。","series":{"id":"1163","title":"计算机科学丛书"},"price":"30.00元"},{"rating":{"max":10,"numRaters":132,"average":"8.5","min":0},"subtitle":"C语言描述","author":["(美)安佩尔"],"pubdate":"2006-4","tags":[{"count":306,"name":"编译原理","title":"编译原理"},{"count":115,"name":"虎书","title":"虎书"},{"count":95,"name":"C","title":"C"},{"count":83,"name":"计算机","title":"计算机"},{"count":81,"name":"计算机科学","title":"计算机科学"},{"count":60,"name":"compiler","title":"compiler"},{"count":59,"name":"编译理论","title":"编译理论"},{"count":59,"name":"编译器","title":"编译器"}],"origin_title":"Modern Compiler Implementation in C","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1852496.jpg","binding":"简裝本","translator":["赵克佳","黄春","沈志宇"],"catalog":"第一部分 编译基本原理\n第1章 绪论\n1.1 模块与接口\n1.2 工具和软件\n1.3 树语言的数据结构\n程序设计：直线式程序解释器\n推荐阅读\n习题\n第2章 词法分析\n2.1 词法单词\n2.2 正则表达式\n2.3 有限自动机\n2.4 非确定有限自动机\n2.4.1 将正则表达式转换为NFA\n2.4.2 将NFA转换为DFA\n2.5 Lex：词法分析器的生成器\n程序设计：词法分析\n推荐阅读\n习题\n第3章 语法分析\n3.1 上下文无关文法\n3.1.1 推导\n3.1.2 语法分析树\n3.1.3 二义性文法\n3.1.4 文件结束符\n3.2 预测分析\n3.2.1 FIRST集合和FOLLOW集合\n3.2.2 构造一个预测分析器\n3.2.3 消除左递归\n3.2.4 提取左因子\n3.2.5 错误恢复\n3.3 LR分析\n3.3.1 LR分析引擎\n3.3.2 LR(0)分析器生成器\n3.3.3 SLR分析器的生成\n3.3.4 LR(1)项和LR(1)分析表\n3.3.5 LALR(1)分析表\n3.3.6 各类文法的层次\n3.3.7 二义性文法的LR分析\n3.4 使用分析器的生成器\n3.4.1 冲突\n3.4.2 优先级指导\n3.4.3 语法和语义\n3.5 错误恢复\n3.5.1 用error符号恢复\n3.5.2 全局错误修复\n程序设计：语法分析\n推荐阅读\n习题\n第4章 抽象语法\n4.1 语义动作\n4.1.1 递归下降\n4.1.2 Yacc生成的分析器\n4.1.3 语义动作的解释器\n4.2 抽象语法分析树\n4.2.1 位置\n4.2.2 Tiger的抽象语法\n程序设计：抽象语法\n推荐阅读\n习题\n第5章 语义分析\n5.1 符号表\n5.1.1 多个符号表\n5.1.2 高效的命令式风格符号表\n5.1.3 高效的函数式符号表\n5.1.4 Tiger编译器的符号\n5.1.5 函数式风格的符号表\n5.2 Tiger编译器的绑定\n5.3 表达式的类型检查\n5.4 声明的类型检查\n5.4.1 变量声明\n5.4.2 类型声明\n5.4.3 函数声明\n5.4.4 递归声明\n程序设计：类型检查\n习题\n第6章 活动记录\n6.1 栈帧\n6.1.1 帧指针\n6.1.2 寄存器\n6.1.3 参数传递\n6.1.4 返回地址\n6.1.5 栈帧内的变量\n6.1.6 静态链\n6.2 Tiger编译器的栈帧\n6.2.1 栈帧描述的表示\n6.2.2 局部变量\n6.2.3 计算逃逸变量\n6.2.4 临时变量和标号\n6.2.5 两层抽象\n6.2.6 管理静态链\n6.2.7 追踪层次信息\n程序设计：栈帧\n推荐阅读\n习题\n第7章 翻译成中间代码\n7.1 中间表示树\n7.2 翻译为树中间语言\n7.2.1 表达式的种类\n7.2.2 简单变量\n7.2.3 追随静态链\n7.2.4 数组变量\n7.2.5 结构化的左值\n7.2.6 下标和域选择\n7.2.7 关于安全性的劝告\n7.2.8 算术操作\n7.2.9 条件表达式\n7.2.10 字符串\n7.2.11 记录和数组的创建\n7.2.12 while循环\n7.2.13 for循环\n7.2.14 函数调用\n7.3 声明\n7.3.1 变量定义\n7.3.2 函数定义\n7.3.3 片段\n程序设计：翻译成树\n习题\n第8章 基本块和轨迹\n8.1 规范树\n8.1.1 ESEQ的转换\n8.1.2 一般重写规则\n8.1.3 将CALL移到顶层\n8.1.4 线性语句表\n8.2 处理条件分支\n8.2.1 基本块\n8.2.2 轨迹\n8.2.3 完善\n8.2.4 最优轨迹\n推荐阅读\n习题\n第9章 指令选择\n9.1 指令选择算法\n9.1.1 Maximal Munch算法\n9.1.2 动态规划\n9.1.3 树文法\n9.1.4 快速匹配\n9.1.5 覆盖算法的效率\n9.2 CISC机器\n9.3 Tiger编译器的指令选择\n9.3.1 抽象的汇编语言指令\n9.3.2 生成汇编指令\n9.3.3 过程调用\n9.3.4 无帧指针的情形\n程序设计：指令选择\n推荐阅读\n习题\n第10章 活跃分析\n10.1 数据流方程的解\n10.1.1 活跃性计算\n10.1.2 集合的表示\n10.1.3 时间复杂度\n10.1.4 最小不动点\n10.1.5 静态活跃性与动态活跃性\n10.1.6 冲突图\n10.2 Tiger编译器的活跃分析\n10.2.1 图\n10.2.2 控制流图\n10.2.3 活跃分析\n程序设计：构造流图\n程序设计：活跃分析模块\n习题\n第11章 寄存器分配\n11.1 通过简化进行着色\n11.2 合并\n11.3 预着色的结点\n11.3.1 机器寄存器的临时副本\n11.3.2 调用者保护的寄存器和被调用者保护的寄存器\n11.3.3 含预着色结点的例子\n11.4 图着色的实现\n11.4.1 传送指令工作表的管理\n11.4.2 数据结构\n11.4.3 程序代码\n11.5 针对树的寄存器分配\n程序设计：图着色\n推荐阅读\n习题\n第12章 整合为一体\n程序设计：过程入口\/出口\n程序设计：创建一个可运行的编译器\n第二部分 高级主题\n第13章 垃圾收集\n13.1 标记-清扫式收集\n13.2 引用计数\n13.3 复制式收集\n13.4 分代收集\n13.5 增量式收集\n13.6 Baker算法\n13.7 编译器接口\n13.7.1 快速分配\n13.7.2 数据布局的描述\n13.7.3 导出指针\n程序设计：描述字\n程序设计：垃圾收集\n推荐阅读\n习题\n第14章 面向对象的语言\n14.1 类\n14.2 数据域的单继承性\n14.3 多继承性\n14.4 测试类成员关系\n14.5 私有域和私有方法\n14.6 无类语言\n14.7 向对象程序的优化\n程序设计：OBJECT Tiger\n推荐阅读\n习题\n第15章 函数式程序设计语言\n15.1 一个简单的函数式语言\n15.2 闭包\n15.3 不变的变量\n15.3.1 基于延续的……I\/O226\n15.3.2 语言上的变化\n15.3.3 纯函数式语言的优化\n15.4 内联扩展\n15.5 闭包变换\n15.6 高效的尾递归\n15.7 懒惰计算\n15.7.1 传名调用计算\n15.7.2 按需调用\n15.7.3 懒惰程序的计算\n15.7.4 懒惰函数式程序的优化\n15.7.5 严格性分析\n推荐阅读\n程序设计：编译函数式语言\n习题\n第16章 多态类型\n16.1 参数多态性\n16.1.1 显式带类型的多态语言\n16.1.2 多态类型的检查\n16.2 类型推论\n16.2.1 一个隐式类型的多态语言\n16.2.2 类型推论算法\n16.2.3 递归的数据类型\n16.2.4 Hindley Milner类型的能力\n16.3 多态变量的表示\n16.3.1 多态函数的扩展\n16.3.2 完全的装箱转换\n16.3.3 基于强制的表示分析\n16.3.4 将类型作为运行时参数传递\n16.4 静态重载的解决方法\n推荐阅读\n习题\n第17章 数据流分析\n17.1 流分析使用的中间表示\n17.2 各种数据流分析\n17.2.1 到达定值\n17.2.2 可用表达式\n17.2.3 到达表达式\n17.2.4 活跃分析\n17.3 使用数据流分析结果的几种转换\n17.3.1 公共子表达式删除\n17.3.2 常数传播\n17.3.3 复写传播\n17.3.4 死代码删除\n17.4 加快数据流分析\n17.4.1 位向量\n17.4.2 基本块\n17.4.3 结点排序\n17.4.4 使用-定值链和定值-使用链\n17.4.5 工作表算法\n17.4.6 增量式数据流分析\n17.5 别名分析\n17.5.1 基于类型的别名分析\n17.5.2 基于流的别名分析\n17.5.3 使用可能别名信息\n17.5.4 严格的纯函数式语言中的别名分析\n推荐阅读\n习题\n第18章 循环优化\n18.1 必经结点\n18.1.1 寻找必经结点的算法\n18.1.2 直接必经结点\n18.1.3 循环\n18.1.4 循环前置结点\n18.2 循环不变量计算\n18.3 归纳变量\n18.3.1 发现归纳变量\n18.3.2 强度削弱\n18.3.3 删除\n18.3.4 重写比较\n18.4 数组边界检查\n18.5 循环展开\n推荐阅读\n习题\n第19章 静态单赋值形式\n19.1 转化为SSA形式\n19.1.1 插入Φ函数的标准\n19.1.2 必经结点边界\n19.1.3 插入Φ函数\n19.1.4 变量重命名\n19.1.5 边分割\n19.2 必经结点树的高效计算\n19.2.1 深度优先生成树\n19.2.2 半必经结点\n19.2.3 Lengauer Tarjan算法\n19.3 使用SSA的优化算法\n19.3.1 死代码删除\n19.3.2 简单的常数传播\n19.3.3 条件常数传播\n19.3.4 保持必经结点性质\n19.4 数组、指针和存储器\n19.5 控制依赖图\n19.6 从SSA形式转变回来\n19.7 函数式中间形式\n推荐阅读\n习题\n第20章 流水和调度\n20.1 没有资源约束时的循环调度\n20.2 有资源约束的循环流水\n20.2.1 模调度\n20.2.2 寻找最小的启动间距\n20.2.3 其他控制流\n20.2.4 编译器应该调度指令吗\n20.3 分支预测\n20.3.1 静态分支预测\n20.3.2 编译器应该预测分支吗\n推荐阅读\n习题\n第21章 存储层次\n21.1 cache的组织结构\n21.2 cache块对齐\n21.3 预取\n21.4 循环交换\n21.5 分块\n21.6 垃圾收集和存储层次\n推荐阅读\n习题\n附录 Tiger语言参考手册\n参考文献\n索引","pages":"385","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s1852496.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s1852496.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1852496.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1806974\/","id":"1806974","publisher":"人民邮电出版社","isbn10":"7115145520","isbn13":"9787115145529","title":"现代编译原理","url":"https:\/\/api.douban.com\/v2\/book\/1806974","alt_title":"Modern Compiler Implementation in C","author_intro":"","summary":"《现代编译原理:C语言描述》全面讲述了现代编译器的结构、编译算法和实现方法，是Andrew w．Apple的“虎书”——Modern Compiler Implementation——“红、蓝、绿”三序列之一。这三本书的内容基本相同。但是使用不同的语言来实现书中给出的一个编译器。本书使用的是更适合广大读者的c语言，而另外两本书分别采用ML语言和Java语言。本书的另一个特点是增加了一些其他编译原理教科书没有涉及的内容。前端增加了面向对象的程序设计语言、函数式程序设计语言等现代语言的编译实现方法，后端增加了针对现代计算机体系结构特征的一些比较成熟的优化方法。这部分内容展现了现代商业编译器需解决的一些关键问题，开拓了学生的视野，为学生未来进行更深入的研究奠定了基础。\n\n《现代编译原理:C语言描述》全面讲述了现代编译器的各个组成部分，包括词法分析、语法分析、抽象语法、语义检查、中间代码表示、指令选择、数据流分析、寄存器分配以及运行时系统等。全书分成两部分，第一部分是编译的基础知识，适用于第一门编译原理课程(一个学期)；第二部分是高级主题，包括面向对象语言和函数语言、垃圾收集、循环优化、ssA(静态单赋值)形式、循环调度、存储结构优化等，适合于后续课程或研究生教学。书中专门为学生提供了一个用C语言编写的实习项目，包括前端和后端设计，学生可以在一学期内创建一个功能完整的编译器。","series":{"id":"18507","title":"图灵计算机科学丛书"},"price":"45.00元"},{"rating":{"max":10,"numRaters":137,"average":"9.1","min":0},"subtitle":"编写高质量C语言代码","author":["Steve Maguire"],"pubdate":"2009.2","tags":[{"count":297,"name":"编程","title":"编程"},{"count":250,"name":"C","title":"C"},{"count":153,"name":"C语言","title":"C语言"},{"count":102,"name":"程序设计","title":"程序设计"},{"count":100,"name":"计算机","title":"计算机"},{"count":81,"name":"Programming","title":"Programming"},{"count":71,"name":"C\/C++","title":"C\/C++"},{"count":67,"name":"经典","title":"经典"}],"origin_title":"Writing Solid Code","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s3529626.jpg","binding":"","translator":[],"catalog":"1 a hypothetical compiler\n2 assert yourself\n3 fortify your subsystems\n4 step through your code\n5 candy-machine interfaces\n6 risky business\n7 treacheries of the trade\n8 the rest is attitude\nepilogue where do you go from here?\nappendix a coding checklists\nappendix b memory logging routines\nappendix c answers\nreferences\nindex","pages":"256","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s3529626.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s3529626.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s3529626.jpg"},"alt":"https:\/\/book.douban.com\/subject\/3406939\/","id":"3406939","publisher":"人民邮电出版社","isbn10":"7115193169","isbn13":"9787115193162","title":"编程精粹","url":"https:\/\/api.douban.com\/v2\/book\/3406939","alt_title":"Writing Solid Code","author_intro":"","summary":"编写高质量的、没有bug的程序，是每位程序员所追求的目标。但随着软件规模越来越大，功能日趋复杂，这一目标变得越来越困难。\n本书揭示了微软公司应对质量挑战、开发出世界级代码的技术内幕，作者在自己不断探索、实践和思考的基础上，系统总结了多年来指导微软各团队的经验，将其凝聚为许多切实可行的编程实践指导，可谓字字珠玑。正因如此，本书被公认为与《代码大全》齐名的编程技术名著，曾于1993年荣获有软件开发奥斯卡奖之称的Jolt生产效率大奖。书中内容主要针对C语言，但其中的思想对目前的各主流语言编程也完全适用。","series":{"id":"50484","title":"图灵程序设计丛书·C\/C++系列"},"price":"45.00元"},{"rating":{"max":10,"numRaters":462,"average":"8.1","min":0},"subtitle":"—C++\/C语言","author":["林锐","韩永泉"],"pubdate":"2007-5","tags":[{"count":218,"name":"C++","title":"C++"},{"count":154,"name":"编程","title":"编程"},{"count":126,"name":"C\/C++","title":"C\/C++"},{"count":104,"name":"程序设计","title":"程序设计"},{"count":78,"name":"高质量程序设计指南--C++\/c语言","title":"高质量程序设计指南--C++\/c语言"},{"count":70,"name":"计算机","title":"计算机"},{"count":70,"name":"编程风格","title":"编程风格"},{"count":61,"name":"C","title":"C"}],"origin_title":"","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s2660317.jpg","binding":"","translator":[],"catalog":"第1章  高质量软件开发之道\t11.1  软件质量基本概念\t11.1.1  如何理解软件的质量\t11.1.2  提高软件质量的基本方法\t31.1.3  “零缺陷”理念\t41.2  细说软件质量属性\t41.2.1  正确性\t41.2.2  健壮性\t51.2.3  可靠性\t51.2.4  性能\t61.2.5  易用性\t71.2.6  清晰性\t71.2.7  安全性\t71.2.8  可扩展性\t81.2.9  兼容性\t81.2.10  可移植性\t81.3  人们关注的不仅仅是质量\t91.3.1  质量、生产率和成本之间的关系\t91.3.2  软件过程改进的基本概念\t111.4  高质量软件开发的基本方法\t131.4.1  建立软件过程规范\t131.4.2  复用\t151.4.3  分而治之\t161.4.4  优化与折中\t171.4.5  技术评审\t181.4.6  测试\t191.4.7  质量保证\t211.4.8  改错\t221.5  关于软件开发的一些常识和思考\t241.5.1  有最好的编程语言吗\t241.5.2  编程是一门艺术吗\t241.5.3  编程时应该多使用技巧吗\t241.5.4  换更快的计算机还是换更快的算法\t251.5.5  错误是否应该分等级\t251.5.6  一些错误的观念\t251.6  小结\t26第2章  编程语言发展简史\t272.1  编程语言大事记\t272.2  Ada的故事\t302.3  C\/C++发展简史\t312.4  Borland与Microsoft之争\t322.5  Java阵营与Microsoft的较量\t332.6  小结\t36第3章  程序的基本概念\t373.1  程序设计语言\t373.2  语言实现\t383.3  程序库\t403.4  开发环境\t403.5  程序的工作原理\t413.6  良好的编程习惯\t42第4章  C++\/C程序设计入门\t454.1  C++\/C程序的基本概念\t454.1.1  启动函数main()\t454.1.2  命令行参数\t474.1.3  内部名称\t484.1.4  连接规范\t494.1.5  变量及其初始化\t514.1.6  C Runtime Library\t524.1.7  编译时和运行时的不同\t524.1.8  编译单元和独立编译技术\t544.2  基本数据类型和内存映像\t544.3  类型转换\t564.3.1  隐式转换\t564.3.2  强制转换\t584.4  标识符\t604.5  转义序列\t614.6  运算符\t624.7  表达式\t634.8  基本控制结构\t654.9  选择（判断）结构\t654.9.1  布尔变量与零值比较\t664.9.2  整型变量与零值比较\t674.9.3  浮点变量与零值比较\t674.9.4  指针变量与零值比较\t694.9.5  对if语句的补充说明\t704.9.6  switch结构\t704.10   循环（重复）结构\t714.10.1  for语句的循环控制变量\t724.10.2  循环语句的效率\t734.11  结构化程序设计原理\t784.12  goto\/continue\/break语句\t794.13  示例\t80第5章  C++\/C常量\t855.1  认识常量\t855.1.1  字面常量\t855.1.2  符号常量\t865.1.3  契约性常量\t875.1.4  枚举常量\t875.2  正确定义符号常量\t875.3  const与#define的比较\t885.4  类中的常量\t895.5  实际应用中如何定义常量\t90第6章  C++\/C函数设计基础\t956.1  认识函数\t956.2  函数原型和定义\t966.3  函数调用方式\t976.4  认识函数堆栈\t996.5  函数调用规范\t1006.6  函数连接规范\t1016.7  参数传递规则\t1026.8  返回值的规则\t1046.9  函数内部实现的规则\t1076.10  存储类型及作用域规则\t1096.10.1  存储类型\t1096.10.2  作用域规则\t1106.10.3  连接类型\t1116.11  递归函数\t1136.12  使用断言\t1166.13  使用const提高函数的健壮性\t1186.13.1  用const修饰函数的参数\t1186.13.2  用const修饰函数的返回值\t119第7章  C++\/C指针、数组和字符串\t1217.1  指针\t1217.1.1  指针的本质\t1217.1.2  指针的类型及其支持的运算\t1237.1.3  指针传递\t1257.2  数组\t1267.2.1  数组的本质\t1267.2.2  二维数组\t1287.2.3  数组传递\t1297.2.4  动态创建、初始化和删除数组的方法\t1317.3  字符数组、字符指针和字符串\t1337.3.1  字符数组、字符串和‘\\0’的关系\t1337.3.2  字符指针的误区\t1347.3.3  字符串拷贝和比较\t1347.4  函数指针\t1357.5  引用和指针的比较\t137第8章  C++\/C高级数据类型\t1418.1  结构（Struct）\t1418.1.1  关键字struct与class的困惑\t1418.1.2  使用struct\t1428.1.3  位域\t1458.1.4  成员对齐\t1478.2  联合（Union）\t1598.3  枚举（Enum）\t1618.4  文件\t163第9章  C++\/C编译预处理\t1659.1  文件包含\t1659.1.1  内部包含卫哨和外部包含卫哨\t1659.1.2  头文件包含的合理顺序\t1669.2  宏定义\t1669.3  条件编译\t1699.3.1  #if、#elif和#else\t1699.3.2  #ifdef 和 #ifndef\t1709.4  #error\t1719.5  #pragma\t1719.6  #和##运算符\t1719.7  预定义符号常量\t172第10章  C++\/C文件结构和程序版式\t17510.1  程序文件的目录结构\t17510.2  文件的结构\t17610.2.1  头文件的用途和结构\t17610.2.2  版权和版本信息\t17710.2.3  源文件结构\t17810.3  代码的版式\t17810.3.1  适当的空行\t17810.3.2  代码行及行内空格\t17910.3.3  长行拆分\t18010.3.4  对齐与缩进\t18110.3.5  修饰符的位置\t18210.3.6  注释风格\t18210.3.7  ADT\/UDT版式\t183第11章  C++\/C应用程序命名规则\t18511.1  共性规则\t18511.2  简单的Windows应用程序命名\t186第12章  C++面向对象程序设计方法概述\t18912.1  漫谈面向对象\t18912.2  对象的概念\t19012.3  信息隐藏与类的封装\t19112.4  类的继承特性\t19512.5  类的组合特性\t20012.6  动态特性\t20112.6.1  虚函数\t20212.6.2  抽象基类\t20212.6.3  动态绑定\t20512.6.4  运行时多态\t20712.6.5  多态数组\t20812.7  C++对象模型\t21512.7.1  对象的内存映像\t21512.7.2  隐含成员\t22412.7.3  C++编译器如何处理成员函数\t22512.7.4  C++编译器如何处理静态成员\t22512.8  小结\t226第13章  对象的初始化、拷贝和析构\t22913.1  构造函数与析构函数的起源\t22913.2  为什么需要构造函数和析构函数\t23013.3  构造函数的成员初始化列表\t23213.4  对象的构造和析构次序\t23413.5  构造函数和析构函数的调用时机\t23513.6  构造函数和赋值函数的重载\t23613.7  示例：类String的构造函数和析构函数\t23813.8  何时应该定义拷贝构造函数和拷贝赋值函数\t23913.9  示例：类String的拷贝构造函数和拷贝赋值函数\t24013.10  用偷懒的办法处理拷贝构造函数和拷贝赋值函数\t24213.11  如何实现派生类的基本函数\t243第14章  C++函数的高级特性\t24714.1  函数重载的概念\t24714.1.1  重载的起源\t24714.1.2  重载是如何实现的\t24714.1.3  当心隐式类型转换导致重载函数产生二义性\t24914.2  成员函数的重载、覆盖与隐藏\t25014.2.1  重载与覆盖\t25014.2.2  令人迷惑的隐藏规则\t25114.2.3  摆脱隐藏\t25314.3  参数的默认值\t25414.4  运算符重载\t25514.4.1  基本概念\t25514.4.2  运算符重载的特殊性\t25614.4.3  不能重载的运算符\t25714.4.4  重载++和--\t25714.5  函数内联\t25914.5.1  用函数内联取代宏\t25914.5.2  内联函数的编程风格\t26014.5.3  慎用内联\t26114.6  类型转换函数\t26114.7  const成员函数\t264第15章  C++异常处理和RTTI\t26715.1  为什么要使用异常处理\t26715.2  C++异常处理\t26815.2.1  异常处理的原理\t26815.2.2  异常类型和异常对象\t26915.2.3  异常处理的语法结构\t27015.2.4  异常的类型匹配规则\t27215.2.5  异常说明及其冲突\t27215.2.6  当异常抛出时局部对象如何释放\t27315.2.7  对象构造和析构期间的异常\t27315.2.8  如何使用好异常处理技术\t27515.2.9  C++的标准异常\t27815.3  虚函数面临的难题\t27815.4  RTTI及其构成\t28015.4.1  起源\t28015.4.2  typeid运算符\t28115.4.3  dynamic_cast<>运算符\t28315.4.4  RTTI的魅力与代价\t285第16章  内存管理\t28716.1  内存分配方式\t28716.2  常见的内存错误及其对策\t28816.3  指针参数是如何传递内存的\t28916.4  free和delete把指针怎么啦\t29116.5  动态内存会被自动释放吗\t29216.6  杜绝“野指针”\t29216.7  有了malloc\/free为什么还要new\/delete\t29316.8  malloc\/free的使用要点\t29516.9  new有3种使用方式\t29616.9.1  plain new\/delete\t29616.9.2  nothrow new\/delete\t29716.9.3  placement new\/delete\t29716.10  new\/delete的使用要点\t30016.11  内存耗尽怎么办\t30116.12  用对象模拟指针\t30216.13  泛型指针auto_ptr\t30516.14  带有引用计数的智能指针\t30616.15  智能指针作为容器元素\t310第17章  学习和使用STL\t32317.1  STL简介\t32317.2  STL头文件的分布\t32417.2.1  容器类\t32417.2.2  泛型算法\t32517.2.3  迭代器\t32517.2.4  数学运算库\t32517.2.5  通用工具\t32517.2.6  其他头文件\t32617.3  容器设计原理\t32617.3.1  内存映像\t32617.3.2  存储方式和访问方式\t32717.3.3  顺序容器和关联式容器的比较\t32817.3.4  如何遍历容器\t33117.3.5  存储空间重分配问题\t33217.3.6  什么样的对象才能作为STL容器的元素\t33317.4  迭代器\t33417.4.1  迭代器的本质\t33417.4.2  迭代器失效及其危险性\t33817.5  存储分配器\t34617.6  适配器\t34717.7  泛型算法\t35017.8  一些特殊的容器\t35417.8.1  string类\t35417.8.2  bitset并非set\t35517.8.3  节省存储空间的vector<bool>\t35717.8.4  空容器\t35817.9  STL容器特征总结\t36017.10  STL使用心得\t362附录A  C++\/C试题\t365附录B  C++\/C试题答案与评分标准\t369附录C  大学十年\t375附录D  《大学十年》后记\t393附录E  术语与缩写解释\t395参考文献\t397","pages":"394","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s2660317.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s2660317.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s2660317.jpg"},"alt":"https:\/\/book.douban.com\/subject\/2116929\/","id":"2116929","publisher":"电子工业","isbn10":"7121041146","isbn13":"9787121041143","title":"高质量程序设计指南","url":"https:\/\/api.douban.com\/v2\/book\/2116929","alt_title":"","author_intro":"林锐，国内知名的软件工程专家和研发管理咨询师。西安电子科技大学硕士，浙江大学计算机系博士。2000年7月加入上海贝尔有限公司，从事软件工程和CMM的研究推广工作。2003年7月当选为Alcatel集团技术专家。2004年初创建上海漫索计算机科技有限公司(http：／／www.chinaspis.com)，致力于创建适合国内IT企业需求的研发管理解决方案，包括方法论和软件产品。已出版著作七部。","summary":"《高质量程序设计指南:C++、C语言》(第3版)以轻松幽默的笔调向读者论述了高质量软件开发方法与C++\/C编程规范。它是作者多年从事软件开发工作的经验总结。《高质量程序设计指南:C++、C语言》(第3版)共17章，第1章到第4章重点介绍软件质量和基本的程序设计方法；第5章到第16章重点阐述 C++\/C编程风格、面向对象程序设计方法和一些技术专题；第17章阐述STL 的原理和使用方法。\n　　《高质量程序设计指南:C++、C语言》(第3版)第1版和第2版部分章节曾经在Internet上广泛流传，被国内IT企业的不少软件开发人员采用。《高质量程序设计指南:C++、C语言》(第3版)的附录C《大学十年》是作者在网上发表的一个短篇传记，文中所描述的充满激情的学习和生活态度，感染了大批莘莘学子。","price":"39.80元"},{"rating":{"max":10,"numRaters":78,"average":"9.1","min":0},"subtitle":"C语言描述","author":["韦斯(Mark Allen Weiss)"],"pubdate":"2010-8","tags":[{"count":165,"name":"数据结构","title":"数据结构"},{"count":148,"name":"算法","title":"算法"},{"count":89,"name":"计算机","title":"计算机"},{"count":63,"name":"C","title":"C"},{"count":45,"name":"Algorithms","title":"Algorithms"},{"count":41,"name":"计算机科学","title":"计算机科学"},{"count":38,"name":"编程","title":"编程"},{"count":16,"name":"数据结构与算法","title":"数据结构与算法"}],"origin_title":"Data Structures and Algorithm Analysis in C","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s4459394.jpg","binding":"平装","translator":[],"catalog":"1  Introduction  1.1. What's the Book About?  1.2. Mathematics Review    1.2.1. Exponents    1.2.2. Logarithms    1.2.3. Series    1.2.4. Modular Arithmetic    1.2.5. The P Word  1.3. A Brief Introduction to Recursion    Summary    Exercises    References2  Algorithm Analysis3  Lists, Stacks, and Queues4  Trees5  Hashing6  Priority Queues (Heaps)7  Sorting 2198  The Disjoint Set ADT9  Graph Algorithms10  Algorithm Design Techniques11  Amortized Analysis12  Advanced Data Structures and Implementation","pages":"511","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s4459394.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s4459394.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s4459394.jpg"},"alt":"https:\/\/book.douban.com\/subject\/4924153\/","id":"4924153","publisher":"机械工业出版社","isbn10":"7111312805","isbn13":"9787111312802","title":"数据结构与算法分析","url":"https:\/\/api.douban.com\/v2\/book\/4924153","alt_title":"Data Structures and Algorithm Analysis in C","author_intro":"Mark Allen Weiss 1987年在普林斯顿大学获得计算机科学博士学位。师从Roberl Sedgewick，现任美国佛罗里达国际大学计算与信息科学学院教授。他曾担任全美AP(Advanced Placement)考试计算机学科委员会主席。其主要研究方向是数据结构、算法和教育学。","summary":"《数据结构与算法分析:C语言描述》曾被评为20世纪顶尖的30部计算机著作之一，作者在数据结构和算法分析方面卓有建树，他的数据结构和算法分析的著作尤其畅销，并受到广泛好评，已被世界500余所大学选作教材。\n在《数据结构与算法分析:C语言描述》中，作者精炼并强化了他对算法和数据结构方面创新的处理方法。通过C程序的实现，着重阐述了抽象数据类型的概念，并对算法的效率、性能和运行时间进行了分析。\n《数据结构与算法分析:C语言描述》特色：着重讨论了算法设计技巧，包括贪婪算法、分治算法、动态规划、随机化算法以及回溯算法。系统介绍了当前流行的论题和新的数据结构，如斐波那契堆、斜堆、二项队列、跳跃表和伸展树。详细讨论了摊还分析，考查书中介绍的一些高级数据结构。增加了高级数据结构及其实现的内容，包括红黑树、自顶向下伸展树、treap树、k-d树、配对堆等。整合了堆排序平均情况分析的一些新结果。","series":{"id":"1895","title":"经典原版书库"},"price":"45.00元"},{"rating":{"max":10,"numRaters":1802,"average":"9.1","min":0},"subtitle":"（第五版）","author":["Stephen Prata","云巅工作室"],"pubdate":"2005-2-1","tags":[{"count":915,"name":"编程","title":"编程"},{"count":840,"name":"c","title":"c"},{"count":830,"name":"c语言","title":"c语言"},{"count":611,"name":"计算机","title":"计算机"},{"count":480,"name":"程序设计","title":"程序设计"},{"count":379,"name":"经典","title":"经典"},{"count":378,"name":"C","title":"C"},{"count":243,"name":"programming","title":"programming"}],"origin_title":"","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1308874.jpg","binding":"平装(无盘)","translator":["云巅工作室"],"catalog":"第1章 概览\n1.1 C语言的起源\n1.2 使用C语言的理由\n1.3 C语言的发展方向\n1.4 计算机工作的基本原理\n1.5 高级计算机语言和编译器\n1.6 使用C语言的7个步骤\n1.7 编程机制\n1.8 语言标准\n1.9 本书的组织结构\n1.10 本书体例\n1.11 总结\n1.12 复习题\n1.13 编程练习\n第2章 C语言概述\n2.1 C语言的一个简单实例\n2.2 实例说明\n2.3 一个简单程序的结构\n2.4 使程序可读的技巧\n2.5 更进一步\n2.6 多个函数\n2.7 调试\n2.8 关键字和保留标识符\n2.9 关键概念\n2.10 总结\n2.11 复习题\n2.12 编程练习\n第3章 数据和C\n3.1 示例程序\n3.2 变量与常量数据\n3.3 数据：数据类型关键字\n3.4 C数据类型\n3.5 使用数据类型\n3.6 参数和易犯的错误\n3.7 另一个例子：转义序列\n3.8 关键概念\n3.9 总结\n3.10 复习题\n3.11 编程练习\n第4章 字符串和格式化输入\/输出\n4.1 前导程序\n4.2 字符串简介\n4.3 常量和C预处理器\n4.4 研究和利用printf（）和scanf（）\n4.5 关键概念\n4.6 总结\n4.7 复习题\n4.8 编程练习\n第5章 运算符、表达式和语句\n5.1 循环简介\n5.2 基本运算符\n5.3 其他运算符\n5.4 表达式和语句\n5.5 类型转换\n5.6 带有参数的函数\n5.7 一个示例程序\n5.8 关键概念\n5.9 总结\n5.10 复习题\n5.11 编程练习\n第6章 C控制语句：循环\n6.1 再探while循环\n6.2 while语句\n6.4 不确定循环与计数循环\n6.5 for循环\n6.6 更多赋值运算符：+=、-=、*=、\/=和%=\n6.7 逗号运算符\n6.8 退出条件循环：do while\n6.9 选择哪种循环\n6.10 嵌套循环\n6.11 数组\n6.12 使用函数返回值的循环例子\n6.13 关键概念\n6.14 总结\n6.15 复习题\n6.16 编程练习\n第7章 C控制语句：分支和跳转\n7.1 if语句\n7.2 在if语句中添加else关键字\n7.3 获得逻辑性\n7.4 一个统计字数的程序\n7.5 条件运算符?:\n7.6 循环辅助手段：continue和break\n7.7 多重选择：switch和break\n7.8 goto语句\n7.9 关键概念\n7.10 总结\n7.11 复习题\n7.12 编程练习\n第8章 字符输入\/输出和输入确认\n8.1 单字符I\/O：getchar（）和putchar（）\n8.2 缓冲区\n8.3 终止键盘输入\n8.5 创建一个更友好的用户界面\n8.6 输入确认\n8.7 菜单浏览\n8.8 关键概念\n8.9 总结\n8.10 复习题\n8.11 编程练习\n第9章 函数\n9.1 函数概述\n9.2 ANSI C的函数原型\n9.3 递归\n9.4 多源代码文件程序的编译\n9.5 地址运算符：&\n9.6 改变调用函数中的变量\n9.7 指针简介\n9.8 关键概念\n9.9 总结\n9.10 复习题\n9.11 编程练习\n第10章 数组和指针\n10.1 数组\n10.2 多维数组\n10.3 指针和数组\n10.4 函数、数组和指针\n10.5 指针操作\n10.6 保护数组内容\n10.7 指针和多维数组\n10.8 变长数组（VLA）\n10.9 复合文字\n10.10 关键概念\n10.11 总结\n10.12 复习题\n10.13 编程练习\n第11章 字符串和字符串函数\n11.1 字符串表示和字符串I\/O\n11.2 字符串输入\n11.3 字符串输出\n11.4 自定义字符串输入\/输出函数\n11.5 字符串函数\n11.6 字符串例子：字符串排序\n11.7 ctype.h字符函数和字符串\n11.8 命令行参数\n11.9 把字符串转换为数字\n11.10 关键概念\n11.11 总结\n11.12 复习题\n11.13 编程练习\n第12章 存储类、链接和内存管理\n12.1 存储类\n12.2 存储类说明符\n12.3 存储类和函数\n12.4 随机数函数和静态变量\n12.5 掷骰子\n12.6 分配内存：malloc（）和free（）\n12.7 ANSI C的类型限定词\n12.8 关键概念\n12.9 总结\n12.10 复习题\n12.11 编程练习\n第13章 文件输入\/输出\n13.1 和文件进行通信\n13.2 标准I\/O\n13.3 一个简单的文件压缩程序\n13.4 文件I\/O：fprintf ( )、fscanf ( )、fgets ( )和fputs ( )函数\n13.5 随机存取：fseek（）和ftell（）函数\n13.6 标准I\/O内幕\n13.7 其他标准I\/O函数\n13.8 关键概念\n13.9 总结\n13.10 复习题\n13.11 编程练习\n第14章 结构和其他数据形式\n14.1 示例问题：创建图书目录\n14.2 建立结构声明\n14.3 定义结构变量\n14.4 结构数组\n14.5 嵌套结构\n14.6 指向结构的指针\n14.7 向函数传递结构信息\n14.8 把结构内容保存到文件中\n14.9 结构：下一步是什么\n14.10 联合简介\n14.11 枚举类型\n14.12 typedef简介\n14.13 奇特的声明\n14.14 函数和指针\n14.15 关键概念\n14.16 总结\n14.17 复习题\n14.18 编程练习\n第15章 位操作\n15.1 二进制数、位和字节\n15.2 其他基数\n15.3 C的位运算符\n15.4 位字段\n15.5 关键概念\n15.6 总结\n15.7 复习题\n15.8 编程练习\n第16章 C预处理器和C库\n16.1 翻译程序的第一步\n16.2 明显常量：#define\n16.3 在#define中使用参数\n16.4 宏，还是函数\n16.5 文件包含：＃include\n16.6 其他指令\n16.7 内联函数\n16.8 C库\n16.9 数学库\n16.10 通用工具库\n16.11 诊断库\n16.12 string.h库中的memcpy（）和memmove（）\n16.13 可变参数：stdarg.h\n16.14 关键概念\n16.15 总结\n16.16 复习题\n16.17 编程练习\n第17章 高级数据表示\n17.1 研究数据表示\n17.2 从数组到链表\n17.3 抽象数据类型（ADT）\n17.4 队列ADT\n17.5 用队列进行模拟\n17.6 链表与数组\n17.7 二叉搜索树\n17.8 其他说明\n17.9 关键概念\n17.10 总结\n17.11 复习题\n17.12 编程练习\n附录A 复习题答案\n附录B 参考资料","pages":"626","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s1308874.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s1308874.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1308874.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1240002\/","id":"1240002","publisher":"人民邮电出版社","isbn10":"7115130221","isbn13":"9787115130228","title":"C Primer Plus","url":"https:\/\/api.douban.com\/v2\/book\/1240002","alt_title":"","author_intro":"普拉塔，在加利福尼亚州的Kentfield的Marin学院教授天文学、物理学和程序设计课程。他在加州工业学院获得学士学位，从加州大学伯克利分校获得博士学位。他最早接触计算机，始于对星河的计算机建模。Stephen已经编写或与他人合作编写了十多本书。其中包括C++Primer Plus和Unix Prinmer Plus。","summary":"《C Primer Plus（第5版）（中文版）》共17章。第1、2章学习C语言编程所需的预备知识。第3到15章介绍了C语言的相关知识，包括数据类型、格式化输入输出、运算符、表达式、流程控制语句、函数、数组和指针、字符串操作、内存管理、位操作等等，知识内容都针对C99标准；另外，第10章强化了对指针的讨论，第12章引入了动态内存分配的概念，这些内容更加适合读者的需求。第16章和第17章讨论了C预处理器和C库函数、高级数据表示（数据结构）方面的内容。附录给出了各章后面复习题、编程练习的答案和丰富的C编程参考资料。","price":"60.00元"},{"rating":{"max":10,"numRaters":1935,"average":"9.2","min":0},"subtitle":"","author":["Peter Van Der Linden"],"pubdate":"2008-2","tags":[{"count":1196,"name":"C语言","title":"C语言"},{"count":681,"name":"编程","title":"编程"},{"count":446,"name":"计算机","title":"计算机"},{"count":405,"name":"c","title":"c"},{"count":387,"name":"C专家编程","title":"C专家编程"},{"count":364,"name":"C\/C++","title":"C\/C++"},{"count":339,"name":"C","title":"C"},{"count":302,"name":"程序设计","title":"程序设计"}],"origin_title":"Expert C Programming: Deep C Secrets","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s5886086.jpg","binding":"平装","translator":["徐波"],"catalog":"第1章 C：穿越时空的迷雾\n1.1 C语言的史前阶段\n1.2 C语言的早期体验\n1.3 标准I\/O库和C预处理器\n1.4 K&R C\n1.5 今日之ANSI C\n1.6 它很棒，但它符合标准吗\n1.7 编译限制\n1.8 ANSI C标准的结构\n1.9 阅读ANSI C标准，寻找乐趣和裨益\n1.10 “安静的改变”究竟有多少安静\n1.11 轻松一下——由编译器定义的Pragmas效果\n第2章 这不是Bug，而是语言特性\n2.1 这关语言特性何事，在Fortran里这就是Bug呀\n2.2 多做之过\n2.3 误做之过\n2.4 少做之过\n2.5 轻松一下——有些特性确实就是Bug\n2.6 参考文献\n第3章 分析C语言的声明\n3.1 只有编译器才会喜欢的语法\n3.2 声明是如何形成的\n3.3 优先级规则\n3.4 通过图表分析C语言的声明\n3.5 typedef可以成为你的朋友\n3.6 typedef int x[10]和#define x int[10]的区别\n3.7 typedef struct foo{ ... foo; }的含义\n3.8 理解所有分析过程的代码段\n3.9 轻松一下——驱动物理实体的软件\n第4章 令人震惊的事实：数组和指针并不相同\n4.1 数组并非指针\n4.2 我的代码为什么无法运行\n4.3 什么是声明，什么是定义\n4.4 使声明与定义相匹配\n4.5 数组和指针的其他区别\n4.6 轻松一下——回文的乐趣\n第5章 对链接的思考\n5.1 函数库、链接和载入\n5.2 动态链接的优点\n5.3 函数库链接的5个特殊秘密\n5.4 警惕Interpositioning\n5.5 产生链接器报告文件\n5.6 轻松一下——看看谁在说话：挑战Turing测验\n第6章 运动的诗章：运行时数据结构\n6.1 a.out及其传说\n6.2 段\n6.3 操作系统在a.out文件里干了些什么\n6.4 C语言运行时系统在a.out里干了些什么\n6.5 当函数被调用时发生了什么：过程活动记录\n6.6 auto和static关键字\n6.7 控制线程\n6.8 setjmp和longjmp\n6.9 UNIX中的堆栈段\n6.10 MS-DOS中的堆栈段\n6.11 有用的C语言工具\n6.12 轻松一下——卡耐基-梅隆大学的编程难题\n6.13 只适用于高级学员阅读的材料\n第7章 对内存的思考\n7.1 Intel 80x86系列\n7.2 Intel 80x86内存模型以及它的工作原理\n7.3 虚拟内存\n7.4 Cache存储器\n7.5 数据段和堆\n7.6 内存泄漏\n7.7 总线错误\n7.8 轻松一下——“Thing King”和“页面游戏”\n第8章 为什么程序员无法分清万圣节和圣诞节\n8.1 Portzebie度量衡系统\n8.2 根据位模式构筑图形\n8.3 在等待时类型发生了变化\n8.4 原型之痛\n8.5 原型在什么地方会失败\n8.6 不需要按回车键就能得到一个字符\n8.7 用C语言实现有限状态机\n8.8 软件比硬件更困难\n8.9 如何进行强制类型转换，为何要进行类型强制转换\n8.10 轻松一下——国际C语言混乱代码大赛\n第9章 再论数组\n9.1 什么时候数组与指针相同\n9.2 为什么会发生混淆\n9.3 为什么C语言把数组形参当作指针\n9.4 数组片段的下标\n9.5 数组和指针可交换性的总结\n9.6 C语言的多维数组\n9.7 轻松一下——软件\/硬件平衡\n第10章 再论指针\n10.1 多维数组的内存布局\n10.2 指针数组就是Iliffe向量\n10.3 在锯齿状数组上使用指针\n10.4 向函数传递一个一维数组\n10.5 使用指针向函数传递一个多维数组\n10.6 使用指针从函数返回一个数组\n10.7 使用指针创建和使用动态数组\n10.8 轻松一下——程序检验的限制\n第11章 你懂得C，所以C++不在话下\n11.1 初识OOP\n11.2 抽象——取事物的本质特性\n11.3 封装——把相关的类型、数据和函数组合在一起\n11.4 展示一些类——用户定义类型享有和预定义类型一样的权限\n11.5 访问控制\n11.6 声明\n11.7 如何调用成员函数\n11.8 继承——复用已经定义的操作\n11.9 多重继承——从两个或更多的基类派生\n11.10 重载——作用于不同类型的同一操作具有相同的名字\n11.11 C++如何进行操作符重载\n11.12 C++的输入\/输出(I\/O)\n11.13 多态——运行时绑定\n11.14 解释\n11.15 C++如何表现多态\n11.16 新奇玩意——多态\n11.17 C++的其他要点\n11.18 如果我的目标是那里，我不会从这里起步\n11.19 它或许过于复杂，但却是惟一可行的方案\n11.20 轻松一下——死亡计算机协会\n11.21 更多阅读材料\n附录A 程序员工作面试的秘密\n附录B 术语表","pages":"291","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s5886086.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s5886086.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s5886086.jpg"},"alt":"https:\/\/book.douban.com\/subject\/2377310\/","id":"2377310","publisher":"人民邮电出版社","isbn10":"7115171807","isbn13":"9787115171801","title":"C专家编程","url":"https:\/\/api.douban.com\/v2\/book\/2377310","alt_title":"Expert C Programming: Deep C Secrets","author_intro":"","summary":"《C专家编程》展示了最优秀的C程序员所使用的编码技巧，并专门开辟了一章对C++的基础知识进行了介绍。\n书中C的历史、语言特性、声明、数组、指针、链接、运行时、内存以及如何进一步学习C++等问题进行了细致的讲解和深入的分析。全书撷取几十个实例进行讲解，对C程序员具有非常高的实用价值。\n本书可以帮助有一定经验的C程序员成为C编程方面的专家，对于具备相当的C语言基础的程序员，本书可以帮助他们站在C的高度了解和学习C++。","series":{"id":"9931","title":"C和C++经典著作"},"price":"45.00元"},{"rating":{"max":10,"numRaters":154,"average":"8.8","min":0},"subtitle":"C标准库“圣经”","author":["P. J. Plauger"],"pubdate":"2009-7","tags":[{"count":228,"name":"C","title":"C"},{"count":196,"name":"C语言","title":"C语言"},{"count":103,"name":"编程","title":"编程"},{"count":102,"name":"标准库","title":"标准库"},{"count":76,"name":"计算机","title":"计算机"},{"count":76,"name":"C\/C++","title":"C\/C++"},{"count":57,"name":"程序设计","title":"程序设计"},{"count":40,"name":"库","title":"库"}],"origin_title":"","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s3820140.jpg","binding":"","translator":["卢红星","徐明亮","霍建同"],"catalog":"第0章　简介. 1\n0.1　背景知识1\n0.2　C 标准的内容 3\n0.3　库的使用7\n0.4　库的实现9\n0.5　库的测试13\n0.6　参考文献15\n0.7　习题15\n第1章　(assert.h)17\n1.1　背景知识17\n1.2　C 标准的内容18\n1.3　(assert.h) 的使用18\n1.4　(assert.h) 的实现20\n1.5　(assert.h) 的测试22\n1.6　参考文献23\n1.7　习题23\n第2章　(ctype.h) 25\n2.1　背景知识25\n2.2　C 标准的内容28\n2.3　(ctype.h) 的使用 30\n2.4　(ctype.h) 的实现 34\n2.5　(ctype.h) 的测试 42\n2.6　参考文献45\n2.7　习题45\n第3章　(errno.h) 47\n3.1　背景知识47\n3.2　C 标准的内容50\n3.3　(errno.h) 的使用 50\n3.4　(errno.h) 的实现 51\n3.5　(errno.h) 的测试 55\n3.6　参考文献55\n3.7　习题55\n第4章　(float.h)57\n4.1　背景知识57\n4.2　C 标准的内容59\n4.3　(float.h) 的使用.62\n4.4　(float.h) 的实现.64\n4.5　(float.h) 的测试.69\n4.6　参考文献71\n4.7　习题72\n第5章　(limits.h)73\n5.1　背景知识73\n5.2　C 标准的内容74\n5.3　(limits.h) 的使用75\n5.4　(limits.h) 的实现77\n5.5　(limits.h) 的测试79\n5.6　参考文献80\n5.7　习题80\n第6章　(locale.h)81\n6.1　背景知识81\n6.2　C 标准的内容84\n6.3　(locale.h) 的使用87\n6.4　(locale.h) 的实现94\n6.5　(locale.h) 的测试 123\n6.6　参考文献.123\n6.7　习题123\n第7章　(math.h)127\n7.1　背景知识.127\n7.2　C 标准的内容 130\n7.3　(math.h) 的使用 135\n7.4　(math.h) 的实现 137\n7.5　(math.h) 的测试 171\n7.6　参考文献.177\n7.7　习题177\n第8章　(setjmp.h).. 181\n8.1　背景知识.181\n8.2　C 标准的内容 184\n8.3　(setjmp.h) 的使用 185\n8.4　(setjmp.h) 的实现 187\n8.5 (setjmp.h) 的测试191\n8.6 参考文献 192\n8.7 习题 192\n第9章　(signal.h) 193\n9.1　背景知识.193\n9.2　C 标准的内容 195\n9.3　(signal.h) 的使用 197\n9.4　(signal.h) 的实现 199\n9.5　(signal.h) 的测试 203\n9.6　参考文献.203\n9.7　习题203\n第10章　(stdarg.h) 205\n10.1　背景知识205\n10.2　C 标准的内容 207\n10.3　(stdarg.h) 的使用 208\n10.4　(stdarg.h) 的实现 211\n10.5　(stdarg.h) 的测试 212\n10.6　参考文献212\n10.7　习题.214\n第11章　(stddef.h) 215\n11.1　背景知识 215\n11.2　C 标准的内容 217\n11.3　(stddef.h) 的使用 217\n11.4　(stddef.h) 的实现 222\n11.5　(stddef.h) 的测试 223\n11.6　参考文献 223\n11.7　习题223\n第12章　(stdio.h) 225\n12.1　背景知识225\n12.2　C 标准的内容 233\n12.3　(stdio.h) 的使用 252\n12.4　(stdio.h) 的实现 274\n12.5　(stdio.h) 的测试 323\n12.6　参考文献325\n12.7　习题.325\n第13章　(stdlib.h) 331\n13.1　背景知识331\n13.2　C 标准的内容 332\n13.3　(stdlib.h) 的使用 342\n13.4　(stdlib.h) 的实现 351\n13.5　(stdlib.h) 的测试 379\n13.6　参考文献379\n13.7　习题.382\n第14章　(string.h) 385\n14.1　背景知识385\n14.2　C 标准的内容 386\n14.3　(string.h) 的使用 392\n14.4　(string.h) 的实现 396\n14.5　(string.h) 的测试 409\n14.6　参考文献409\n14.7　习题.409\n第15章　(time.h) 413\n15.1　背景知识413\n15.2　C 标准的内容 414\n15.3　(time.h) 的使用 418\n15.4　(time.h) 的实现 422\n15.5　(time.h) 的测试440\n15.6　参考文献441\n15.7　习题.441\n附录A　接口 443\n附录B　名字 451\n附录C　术语... 461","pages":"488","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s3820140.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s3820140.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s3820140.jpg"},"alt":"https:\/\/book.douban.com\/subject\/3775842\/","id":"3775842","publisher":"人民邮电出版社","isbn10":"7115172862","isbn13":"9787115172860","title":"C标准库","url":"https:\/\/api.douban.com\/v2\/book\/3775842","alt_title":"","author_intro":"P. J. Plauger  世界著名的软件技术专家，曾任ISO C标准委员会主席，C\/C++ User’s Journal主编，现任ISO C++标准委员会主席。他是C\/C++标准库开发领域的大师，所开发的Dinkumware标准库应用广泛。","summary":"本书是由世界级C语言专家编写的C标准库经典著作。英文版已经重印十多次，影响了几代程序员。\n本书结合C标准的相关部分，精辟地讲述了每一个库函数的使用方法和实现细节，而这正是一个真正的C程序员所必须掌握的。更重要的是，书中给出了实现和测试这些函数的完整源代码，可以让你更深入地学习C语言。不仅如此，本书还讨论了一些即使是最有经验的C程序员通常也不熟悉的知识，比如国际化和独立于区域设置的程序的编写、与构建库相关的概念和设计思想。\n本书结构清晰，内容权威，阐述精辟，对于各层次C 程序员和相关专业高校师生都是一本优秀的参考书。","series":{"id":"50484","title":"图灵程序设计丛书·C\/C++系列"},"price":"79.00元"},{"rating":{"max":10,"numRaters":808,"average":"8.6","min":0},"subtitle":"一本37.5°C的博物馆地图","author":["沈辛成"],"pubdate":"2017-5-20","tags":[{"count":588,"name":"纽约","title":"纽约"},{"count":560,"name":"博物馆","title":"博物馆"},{"count":455,"name":"旅行","title":"旅行"},{"count":370,"name":"美国","title":"美国"},{"count":337,"name":"艺术","title":"艺术"},{"count":281,"name":"城市","title":"城市"},{"count":214,"name":"历史","title":"历史"},{"count":193,"name":"生活","title":"生活"}],"origin_title":"","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s29478001.jpg","binding":"精装","translator":[],"catalog":"指南与致谢\n有点像跋的序\n第一章 你这个种族主义者\n纽约深度游线路一：黑色与白色\n第二章 没有华尔的街\n纽约深度游线路二：革命与资本\n第三章 纽约水故事\n纽约深度游线路三：饮水与思源\n第四章 我的画报你的城\n纽约深度游之四：寻根与漂流\n第五章 曼哈顿是平的\n纽约深度游之五：贫穷与富裕\n第六章 开往昨天的地铁\n纽约深度游之六：地下与地上\n第七章 美国的归美国，纽约的归纽约\n纽约深度游之七：美国与欧洲\n第八章 不知道为什么就流泪\n纽约深度游之八：战争与和平\n有点像序的跋\n附录\n附录一：一些遗珠\n附录二：纽约博物馆排名","pages":"380","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s29478001.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s29478001.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s29478001.jpg"},"alt":"https:\/\/book.douban.com\/subject\/27037182\/","id":"27037182","publisher":"中西书局","isbn10":"7547512488","isbn13":"9787547512487","title":"纽约无人是客","url":"https:\/\/api.douban.com\/v2\/book\/27037182","alt_title":"","author_intro":"沈辛成，1984年生人，非业余博物馆爱好者，走访全美八十余座博物馆，曾服务于美国自然历史博物馆、“911”国家纪念馆和纽约历史学会，参与从事档案研究、出版与策展工作。佐治亚理工学院科技史博士在读，哥伦比亚大学人类学硕士，复旦大学考古学硕士，北京大学博物馆学学士，做过独立唱作人，兼职美国时政评论。","summary":"本书为作者在纽约实地踏访数十家博物馆并进行深入了解后，对纽约博物馆展示特色、专业内涵、设计匠心及观众体验等进行多维度评价的作品。\n本书不是一本简单的博物馆导览手册，而是基于作者的个人经历和专业背景，试图阐释纽约这个五方杂处、光怪陆离却又独具特色的国际大都会的底色。全书行文从容，图文并茂，兼具知识性、实用性和可读性，无论是否去过纽约，它都会在流畅的阅读之后，带给你充足的知识与细节，同时也带给你深深的思索。","price":"39.80元"},{"rating":{"max":10,"numRaters":1399,"average":"9.0","min":0},"subtitle":"","author":["Kenneth A.Reek"],"pubdate":"2008 年4月","tags":[{"count":869,"name":"C","title":"C"},{"count":776,"name":"C语言","title":"C语言"},{"count":540,"name":"编程","title":"编程"},{"count":437,"name":"指针","title":"指针"},{"count":381,"name":"计算机","title":"计算机"},{"count":304,"name":"程序设计","title":"程序设计"},{"count":276,"name":"C\/C++","title":"C\/C++"},{"count":180,"name":"Programming","title":"Programming"}],"origin_title":"Pointers on C","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s2996168.jpg","binding":"平装","translator":["徐波"],"catalog":"第1章 快速上手\n1.1 简介\n1.1.1 空白和注释\n1.1.2 预处理指令\n1.1.3 main函数\n1.1.4 read_column_numbers函数\n1.1.5 rearrange函数\n1.2 补充说明\n1.3 编译\n1.4 总结\n1.5 警告的总结\n1.6 编程提示的总结\n1.7 问题\n1.8 编程练习\n第2章 基本概念\n2.1 环境\n2.1.1 翻译\n2.1.2 执行\n2.2 词法规则\n2.2.1 字符\n2.2.2 注释\n2.2.3 自由形式的源代码\n2.2.4 标识符\n2.2.5 程序的形式\n2.3 程序风格\n2.4 总结\n2.5 警告的总结\n2.6 编程提示的总结\n2.7 问题\n2.8 编程练习\n第3章 数据\n第4章 语句\n第5章 操作符和表达式\n第6章 指针\n第7章 函数\n第8章 数组\n第9章 字符串、字符和字节\n第10章 结构和联合\n第11章 动态内存分配\n第12章 使用结构和指针\n第13章 高级指针话题\n第14章 预处理器\n第15章 输入\/输出函数\n第16章 标准函数库\n第17章 经典抽象数据类型\n第18章 运行时环境\n附录 部分问题答案\n索引\n参考文献","pages":"448","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s2996168.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s2996168.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s2996168.jpg"},"alt":"https:\/\/book.douban.com\/subject\/3012360\/","id":"3012360","publisher":"人民邮电出版社","isbn10":"7115172013","isbn13":"9787115172013","title":"C和指针","url":"https:\/\/api.douban.com\/v2\/book\/3012360","alt_title":"Pointers on C","author_intro":"Kenneth·Reek是罗彻斯特理工大学计算机科学教授。他是一位经验丰富的C程序员，曾为多家公司担任过技术顾问。他讲授的课程有操作系统、数据通信、计算机网络、形式语言、算法分析和交换系统等。本书正是基于他9年的编程及教学的经验积累。","summary":"本书提供与C语言编程相关的全面资源和深入讨论。本书通过对指针的基础知识和高级特性的探讨，帮助程序员把指针的强大功能融入到自己的程序中去。\n全书共18章，覆盖了数据、语句、操作符和表达式、指针、函数、数组、字符串、结构和联合等几乎所有重要的C编程话题。书中给出了很多编程技巧和提示，每章后面有针对性很强的练习，附录部分则给出了部分练习的解答。\n本书适合C语言初学者和初级C程序员阅读，也可作为计算机专业学生学习C语言的参考。","series":{"id":"9931","title":"C和C++经典著作"},"price":"65.00元"},{"rating":{"max":10,"numRaters":1270,"average":"9.6","min":0},"subtitle":"-","author":["Brian W. Kernighan","Dennis M. Ritchie"],"pubdate":"1988-4-1","tags":[{"count":611,"name":"c","title":"c"},{"count":434,"name":"Programming","title":"Programming"},{"count":403,"name":"C语言","title":"C语言"},{"count":382,"name":"编程","title":"编程"},{"count":316,"name":"计算机","title":"计算机"},{"count":240,"name":"经典","title":"经典"},{"count":218,"name":"C","title":"C"},{"count":205,"name":"程序设计","title":"程序设计"}],"origin_title":"","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s29586132.jpg","binding":"Paperback","translator":[],"catalog":"","pages":"274","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s29586132.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s29586132.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s29586132.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1236999\/","id":"1236999","publisher":"Prentice Hall","isbn10":"0131103628","isbn13":"9780131103627","title":"The  C Programming Language","url":"https:\/\/api.douban.com\/v2\/book\/1236999","alt_title":"C Programming Language","author_intro":"Brian W. Kernighan works in the Computing Science Research Center at Bell Laboratories, Lucent Technologies. He is Consulting Editor for Addison-Wesley's Professional Computing Series and the author, with Dennis Ritchie, of The C Programming Language.\nDennis Ritchie is a computer scientist notable for his influence on ALTRAN, B, BCPL, C, Multics, and Unix.","summary":"Presents a complete guide to ANSI standard C language programming. Written by the developers of C, this new version helps readers keep up with the finalized ANSI standard for C while showing how to take advantage of C's rich set of operators, economy of expression, improved control flow, and data structures. This 2nd edition has been completely rewritten with additional examples and problem sets to clarify the implementation of difficult language constructs. 7 x 9 1\/4.","price":"USD 67.00"},{"rating":{"max":10,"numRaters":604,"average":"9.3","min":0},"subtitle":"第六版","author":["普拉达 (Stephen Prata)"],"pubdate":"2016-4-1","tags":[{"count":347,"name":"C语言","title":"C语言"},{"count":231,"name":"C","title":"C"},{"count":215,"name":"编程","title":"编程"},{"count":183,"name":"计算机","title":"计算机"},{"count":142,"name":"计算机科学","title":"计算机科学"},{"count":125,"name":"经典","title":"经典"},{"count":86,"name":"C++","title":"C++"},{"count":78,"name":"软件开发","title":"软件开发"}],"origin_title":"C Primer Plus : 6th","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s29438897.jpg","binding":"平装","translator":["姜佑"],"catalog":"第1章　初识C语言\t1\n1．1　C语言的起源\t1\n1．2 选择C语言的理由\t1\n1．2．1 设计特性\t1\n1．2．2 高效性\t1\n1．2．3 可移植性\t2\n1．2．4 强大而灵活\t3\n1．2．5 面向程序员\t3\n1．2．6 缺点\t3\n1．3 C语言的应用范围\t3\n1．4 计算机能做什么\t4\n1．5 高级计算机语言和编译器\t5\n1．6 语言标准\t6\n1．6．1 第1个ANSI\/ISO C标准\t6\n1．6．2 C99标准\t6\n1．6．3 C11标准\t7\n1．7 使用C语言的7个步骤\t7\n1．7．1 第1步：定义程序的目标\t8\n1．7．2 第2步：设计程序\t8\n1．7．3 第3步：编写代码\t8\n1．7．4 第4步：编译\t8\n1．7．5 第5步：运行程序\t9\n1．7．6 第6步：测试和调试程序\t9\n1．7．7 第7步：维护和修改代码\t9\n1．7．8 说明\t9\n1．8 编程机制\t10\n1．8．1 目标代码文件、可执行文件和库\t10\n1．8．2 UNIX系统\t11\n1．8．3 GNU编译器集合和LLVM项目\t13\n1．8．4 Linux系统\t13\n1．8．5 PC的命令行编译器\t14\n1．8．6 集成开发环境（Windows）\t14\n1．8．7 Windows\/Linux\t15\n1．8．8 Macintosh中的C\t15\n1．9 本书的组织结构\t15\n1．10 本书的约定\t16\n1．10．1 字体\t16\n1．10．2 程序输出\t16\n1．10．3 特殊元素\t17\n1．11 本章小结\t17\n1．12 复习题\t18\n1．13 编程练习\t18\n第2章　C语言概述\t19\n2．1 简单的C程序示例\t19\n2．2 示例解释\t20\n2．2．1 第1遍：快速概要\t21\n2．2．2 第2遍：程序细节\t21\n2．3 简单程序的结构\t28\n2．4 提高程序可读性的技巧\t28\n2．5 进一步使用C\t29\n2．5．1 程序说明\t30\n2．5．2 多条声明\t30\n2．5．3 乘法\t30\n2．5．4 打印多个值\t30\n2．6 多个函数\t30\n2．7 调试程序\t32\n2．7．1 语法错误\t32\n2．7．2 语义错误\t33\n2．7．3 程序状态\t34\n2．8 关键字和保留标识符\t34\n2．9 关键概念\t35\n2．10 本章小结\t35\n2．11 复习题\t36\n2．12 编程练习\t37\n第3章　数据和C\t39\n3．1 示例程序\t39\n3．2 变量与常量数据\t42\n3．3 数据：数据类型关键字\t42\n3．3．1 整数和浮点数\t43\n3．3．2 整数\t43\n3．3．3 浮点数\t43\n3．4 C语言基本数据类型\t44\n3．4．1 int类型\t44\n3．4．2 其他整数类型\t47\n3．4．3 使用字符：char类型\t50\n3．4．4 _Bool类型\t54\n3．4．5 可移植类型：stdint．h和inttypes．h\t55\n3．4．6 float、double和long double\t56\n3．4．7 复数和虚数类型\t60\n3．4．8 其他类型\t60\n3．4．9 类型大小\t62\n3．5 使用数据类型\t63\n3．6 参数和陷阱\t63\n3．7 转义序列示例\t64\n3．7．1 程序运行情况\t65\n3．7．2 刷新输出\t65\n3．8 关键概念\t66\n3．9 本章小结\t66\n3．10 复习题\t67\n3．11 编程练习\t68\n第4章　字符串和格式化输入\/输出\t71\n4．1 前导程序\t71\n4．2 字符串简介\t72\n4．2．1 char类型数组和null字符\t72\n4．2．2 使用字符串\t73\n4．2．3 strlen()函数\t74\n4．3 常量和C预处理器\t76\n4．3．1 const限定符\t78\n4．3．2 明示常量\t78\n4．4 printf()和scanf()\t80\n4．4．1 printf()函数\t80\n4．4．2 使用printf()\t81\n4．4．3 printf()的转换说明修饰符\t83\n4．4．4 转换说明的意义\t87\n4．4．5 使用scanf()\t92\n4．4．6 printf()和scanf()的*修饰符\t95\n4．4．7 printf()的用法提示\t97\n4．5 关键概念\t98\n4．6 本章小结\t98\n4．7 复习题\t99\n4．8 编程练习\t100\n第5章　运算符、表达式和语句\t103\n5．1 循环简介\t103\n5．2 基本运算符\t105\n5．2．1 赋值运算符：=\t105\n5．2．2 加法运算符：+\t107\n5．2．3 减法运算符：-\t107\n5．2．4 符号运算符：-和+\t107\n5．2．5 乘法运算符：*\t108\n5．2．6 除法运算符：\/\t110\n5．2．7 运算符优先级\t110\n5．2．8 优先级和求值顺序\t112\n5．3 其他运算符\t113\n5．3．1 sizeof运算符和size_t类型\t113\n5．3．2 求模运算符：%\t114\n5．3．3 递增运算符：++\t115\n5．3．4 递减运算符：--\t118\n5．3．5 优先级\t118\n5．3．6 不要自作聪明\t119\n5．4 表达式和语句\t120\n5．4．1 表达式\t120\n5．4．2 语句\t120\n5．4．3 复合语句（块）\t123\n5．5 类型转换\t124\n5．6 带参数的函数\t127\n5．7 示例程序\t129\n5．8 关键概念\t130\n5．9 本章小结\t130\n5．10 复习题\t131\n5．11 编程练习\t134\n第6章　C控制语句：循环\t137\n6．1 再探while循环\t137\n6．1．1 程序注释\t138\n6．1．2 C风格读取循环\t139\n6．2 while语句\t140\n6．2．1 终止while循环\t140\n6．2．2 何时终止循环\t141\n6．2．3 while：入口条件循环\t141\n6．2．4 语法要点\t141\n6．3 用关系运算符和表达式比较大小\t143\n6．3．1 什么是真\t144\n6．3．2 其他真值\t145\n6．3．3 真值的问题\t146\n6．3．4 新的_Bool类型\t147\n6．3．5 优先级和关系运算符\t148\n6．4 不确定循环和计数循环\t150\n6．5 for循环\t151\n6．6 其他赋值运算符：+=、-=、*=、\/=、%=\t155\n6．7 逗号运算符\t156\n6．8 出口条件循环：do while\t159\n6．9 如何选择循环\t161\n6．10 嵌套循环\t162\n6．10．1 程序分析\t163\n6．10．2 嵌套变式\t163\n6．11 数组简介\t164\n6．12 使用函数返回值的循环示例\t166\n6．12．1 程序分析\t168\n6．12．2 使用带返回值的函数\t169\n6．13 关键概念\t169\n6．14 本章小结\t170\n6．15 复习题\t170\n6．16 编程练习\t174\n第7章　C控制语句：分支和跳转\t177\n7．1 if语句\t177\n7．2 if else语句\t179\n7．2．1 另一个示例：介绍getchar()和putchar()\t180\n7．2．2 ctype．h系列的字符函数\t182\n7．2．3 多重选择else if\t184\n7．2．4 else与if配对\t186\n7．2．5 多层嵌套的if语句\t187\n7．3 逻辑运算符\t190\n7．3．1 备选拼写：iso646．h头文件\t191\n7．3．2 优先级\t192\n7．3．3 求值顺序\t192\n7．3．4 范围\t193\n7．4 一个统计单词的程序\t194\n7．5 条件运算符：?：\t196\n7．6 循环辅助：continue和break\t198\n7．6．1 continue语句\t198\n7．6．2 break语句\t200\n7．7 多重选择：switch和break\t202\n7．7．1 switch语句\t204\n7．7．2 只读每行的首字符\t205\n7．7．3 多重标签\t206\n7．7．4 switch和if else\t208\n7．8 goto语句\t208\n7．9 关键概念\t211\n7．10 本章小结\t211\n7．11 复习题\t212\n7．12 编程练习\t214\n第8章　字符输入\/输出和输入验证\t217\n8．1 单字符I\/O：getchar()和putchar()\t217\n8．2 缓冲区\t218\n8．3 结束键盘输入\t219\n8．3．1 文件、流和键盘输入\t219\n8．3．2 文件结尾\t220\n8．4 重定向和文件\t222\n8．5 创建更友好的用户界面\t226\n8．5．1 使用缓冲输入\t226\n8．5．2 混合数值和字符输入\t228\n8．6 输入验证\t230\n8．6．1 分析程序\t234\n8．6．2 输入流和数字\t234\n8．7 菜单浏览\t235\n8．7．1 任务\t235\n8．7．2 使执行更顺利\t235\n8．7．3 混合字符和数值输入\t237\n8．8 关键概念\t240\n8．9 本章小结\t240\n8．10 复习题\t241\n8．11 编程练习\t241\n第9章　函数\t243\n9．1 复习函数\t243\n9．1．1 创建并使用简单函数\t244\n9．1．2 分析程序\t245\n9．1．3 函数参数\t247\n9．1．4 定义带形式参数的函数\t248\n9．1．5 声明带形式参数函数的原型\t249\n9．1．6 调用带实际参数的函数\t249\n9．1．7 黑盒视角\t250\n9．1．8 使用return从函数中返回值\t250\n9．1．9 函数类型\t252\n9．2 ANSI C函数原型\t253\n9．2．1 问题所在\t253\n9．2．2 ANSI的解决方案\t254\n9．2．3 无参数和未指定参数\t255\n9．2．4 函数原型的优点\t256\n9．3 递归\t256\n9．3．1 演示递归\t256\n9．3．2 递归的基本原理\t258\n9．3．3 尾递归\t258\n9．3．4 递归和倒序计算\t260\n9．3．5 递归的优缺点\t262\n9．4 编译多源代码文件的程序\t262\n9．4．1 UNIX\t263\n9．4．2 Linux\t263\n9．4．3 DOS命令行编译器\t263\n9．4．4 Windows和苹果的IDE编译器\t263\n9．4．5 使用头文件\t263\n9．5 查找地址：&运算符\t267\n9．6 更改主调函数中的变量\t268\n9．7 指针简介\t269\n9．7．1 间接运算符：*\t270\n9．7．2 声明指针\t270\n9．7．3 使用指针在函数间通信\t271\n9．8 关键概念\t274\n9．9 本章小结\t275\n9．10　复习题\t275\n9．11 编程练习\t276\n第10章　数组和指针\t277\n10．1 数组\t277\n10．1．1 初始化数组\t277\n10．1．2 指定初始化器（C99）\t281\n10．1．3 给数组元素赋值\t282\n10．1．4 数组边界\t282\n10．1．5 指定数组的大小\t284\n10．2 多维数组\t284\n10．2．1 初始化二维数组\t287\n10．2．2 其他多维数组\t288\n10．3 指针和数组\t288\n10．4 函数、数组和指针\t290\n10．4．1 使用指针形参\t293\n10．4．2 指针表示法和数组表示法\t294\n10．5 指针操作\t295\n10．6 保护数组中的数据\t298\n10．6．1 对形式参数使用const\t299\n10．6．2　const的其他内容\t300\n10．7 指针和多维数组\t302\n10．7．1 指向多维数组的指针\t304\n10．7．2 指针的兼容性\t305\n10．7．3 函数和多维数组\t306\n10．8 变长数组（VLA）\t309\n10．9 复合字面量\t312\n10．10 关键概念\t314\n10．11 本章小结\t315\n10．12 复习题\t316\n10．13 编程练习\t317\n第11章　字符串和字符串函数\t321\n11．1 表示字符串和字符串I\/O\t321\n11．1．1 在程序中定义字符串\t322\n11．1．2 指针和字符串\t328\n11．2 字符串输入\t329\n11．2．1 分配空间\t329\n11．2．2 不幸的gets()函数\t330\n11．2．3 gets()的替代品\t331\n11．2．4 scanf()函数\t336\n11．3 字符串输出\t337\n11．3．1 puts()函数\t338\n11．3．2 fputs()函数\t339\n11．3．3 printf()函数\t339\n11．4 自定义输入\/输出函数\t340\n11．5 字符串函数\t342\n11．5．1 strlen()函数\t342\n11．5．2 strcat()函数\t343\n11．5．3 strncat()函数\t345\n11．5．4 strcmp()函数\t346\n11．5．5 strcpy()和strncpy()函数\t351\n11．5．6 sprintf()函数\t356\n11．5．7 其他字符串函数\t357\n11．6 字符串示例：字符串排序\t359\n11．6．1 排序指针而非字符串\t360\n11．6．2 选择排序算法\t361\n11．7 ctype．h字符函数和字符串\t362\n11．8 命令行参数\t363\n11．8．1 集成环境中的命令行参数\t365\n11．8．2 Macintosh中的命令行参数\t365\n11．9 把字符串转换为数字\t365\n11．10 关键概念\t368\n11．11 本章小结\t368\n11．12 复习题\t369\n11．13 编程练习\t371\n第12章　存储类别、链接和内存管理\t373\n12．1 存储类别\t373\n12．1．1 作用域\t374\n12．1．2 链接\t376\n12．1．3 存储期\t376\n12．1．4 自动变量\t377\n12．1．5 寄存器变量\t380\n12．1．6 块作用域的静态变量\t381\n12．1．7 外部链接的静态变量\t382\n12．1．8 内部链接的静态变量\t386\n12．1．9 多文件\t386\n12．1．10 存储类别说明符\t387\n12．1．11 存储类别和函数\t389\n12．1．12 存储类别的选择\t389\n12．2 随机数函数和静态变量\t390\n12．3 掷骰子\t393\n12．4 分配内存：malloc()和free()\t396\n12．4．1 free()的重要性\t399\n12．4．2 calloc()函数\t400\n12．4．3 动态内存分配和变长数组\t400\n12．4．4 存储类别和动态内存分配\t401\n12．5 ANSI C类型限定符\t402\n12．5．1 const类型限定符\t403\n12．5．2 volatile类型限定符\t404\n12．5．3 restrict类型限定符\t405\n12．5．4 _Atomic类型限定符（C11）\t406\n12．5．5 旧关键字的新位置\t406\n12．6　关键概念\t407\n12．7 本章小结\t407\n12．8 复习题\t408\n12．9 编程练习\t409\n第13章　文件输入\/输出\t413\n13．1 与文件进行通信\t413\n13．1．1 文件是什么\t413\n13．1．2 文本模式和二进制模式\t413\n13．1．3 I\/O的级别\t415\n13．1．4 标准文件\t415\n13．2 标准I\/O\t415\n13．2．1 检查命令行参数\t416\n13．2．2 fopen()函数\t416\n13．2．3 getc()和putc()函数\t417\n13．2．4 文件结尾\t418\n13．2．5 fclose()函数\t419\n13．2．6 指向标准文件的指针\t419\n13．3 一个简单的文件压缩程序\t419\n13．4 文件I\/O：fprintf()、fscanf()、fgets()和fputs()\t421\n13．4．1 fprintf()和fscanf()函数\t421\n13．4．2 fgets()和fputs()函数\t422\n13．5 随机访问：fseek()和ftell()\t423\n13．5．1 fseek()和ftell()的工作原理\t424\n13．5．2 二进制模式和文本模式\t425\n13．5．3 可移植性\t425\n13．5．4 fgetpos()和fsetpos()函数\t426\n13．6 标准I\/O的机理\t426\n13．7 其他标准I\/O函数\t427\n13．7．1 int ungetc(int c， FILE *fp)函数\t427\n13．7．2 int fflush()函数\t428\n13．7．3 int setvbuf()函数\t428\n13．7．4 二进制I\/O：fread()和fwrite()\t428\n13．7．5 size_t fwrite()函数\t429\n13．7．6 size_t fread()函数\t430\n13．7．7 int feof(FILE *fp)和int ferror(FILE *fp)函数\t430\n13．7．8 一个程序示例\t430\n13．7．9 用二进制I\/O进行随机访问\t433\n13．8 关键概念\t435\n13．9 本章小结\t435\n13．10 复习题\t435\n13．11 编程练习\t437\n第14章　结构和其他数据形式\t439\n14．1 示例问题：创建图书目录\t439\n14．2 建立结构声明\t441\n14．3 定义结构变量\t441\n14．3．1 初始化结构\t442\n14．3．2 访问结构成员\t443\n14．3．3 结构的初始化器\t443\n14．4 结构数组\t444\n14．4．1 声明结构数组\t446\n14．4．2 标识结构数组的成员\t447\n14．4．3 程序讨论\t447\n14．5 嵌套结构\t448\n14．6 指向结构的指针\t449\n14．6．1 声明和初始化结构指针\t450\n14．6．2 用指针访问成员\t451\n14．7 向函数传递结构的信息\t451\n14．7．1 传递结构成员\t451\n14．7．2 传递结构的地址\t452\n14．7．3 传递结构\t453\n14．7．4 其他结构特性\t454\n14．7．5 结构和结构指针的选择\t458\n14．7．6 结构中的字符数组和字符指针\t458\n14．7．7 结构、指针和malloc()\t459\n14．7．8 复合字面量和结构（C99）\t462\n14．7．9 伸缩型数组成员（C99）\t463\n14．7．10 匿名结构（C11）\t465\n14．7．11 使用结构数组的函数\t466\n14．8 把结构内容保存到文件中\t467\n14．8．1 保存结构的程序示例\t468\n14．8．2 程序要点\t470\n14．9 链式结构\t471\n14．10 联合简介\t472\n14．10．1 使用联合\t472\n14．10．2 匿名联合（C11）\t473\n14．11 枚举类型\t474\n14．11．1 enum常量\t475\n14．11．2 默认值\t475\n14．11．3 赋值\t475\n14．11．4 enum的用法\t476\n14．11．5 共享名称空间\t477\n14．12 typedef简介\t478\n14．13 其他复杂的声明\t479\n14．14 函数和指针\t481\n14．15 关键概念\t487\n14．16 本章小结\t487\n14．17 复习题\t488\n14．18 编程练习\t490\n第15章　位操作\t493\n15．1 二进制数、位和字节\t493\n15．1．1 二进制整数\t494\n15．1．2 有符号整数\t494\n15．1．3 二进制浮点数\t495\n15．2 其他进制数\t495\n15．2．1 八进制\t495\n15．2．2 十六进制\t496\n15．3 C按位运算符\t496\n15．3．1 按位逻辑运算符\t497\n15．3．2 用法：掩码\t498\n15．3．3 用法：打开位（设置位）\t498\n15．3．4 用法：关闭位（清空位）\t499\n15．3．5 用法：切换位\t499\n15．3．6 用法：检查位的值\t500\n15．3．7 移位运算符\t500\n15．3．8 编程示例\t501\n15．3．9 另一个例子\t503\n15．4 位字段\t505\n15．4．1 位字段示例\t506\n15．4．2 位字段和按位运算符\t509\n15．5 对齐特性（C11）\t515\n15．6 关键概念\t516\n15．7 本章小结\t516\n15．8 复习题\t517\n15．9 编程练习\t518\n第16章　C预处理器和C库\t521\n16．1 翻译程序的第一步\t521\n16．2 明示常量：#define\t522\n16．2．1 记号\t525\n16．2．2 重定义常量\t525\n16．3 在#define中使用参数\t525\n16．3．1 用宏参数创建字符串：#运算符\t527\n16．3．2 预处理器黏合剂：##运算符\t528\n16．3．3 变参宏：．．．和_ _VA_ARGS_ _\t529\n16．4 宏和函数的选择\t530\n16．5 文件包含：#include\t531\n16．5．1 头文件示例\t531\n16．5．2 使用头文件\t533\n16．6 其他指令\t534\n16．6．1 #undef指令\t534\n16．6．2 从C预处理器角度看已定义\t534\n16．6．3 条件编译\t535\n16．6．4 预定义宏\t539\n16．6．5 #line和#error\t540\n16．6．6 #pragma\t540\n16．6．7 泛型选择（C11）\t541\n16．7 内联函数（C99）\t542\n16．8 _Noreturn函数（C11）\t544\n16．9 C库\t544\n16．9．1 访问C库\t544\n16．9．2 使用库描述\t545\n16．10 数学库\t546\n16．10．1 三角问题\t547\n16．10．2 类型变体\t548\n16．10．3 tgmath．h库（C99）\t550\n16．11 通用工具库\t550\n16．11．1 exit()和atexit()函数\t550\n16．11．2 qsort()函数\t552\n16．12 断言库\t556\n16．12．1 assert的用法\t556\n16．12．2 _Static_assert（C11）\t557\n16．13 string．h库中的memcpy()和memmove()\t558\n16．14 可变参数：stdarg．h\t560\n16．15 关键概念\t562\n16．16 本章小结\t562\n16．17 复习题\t562\n16．18 编程练习\t563\n第17章　高级数据表示\t567\n17．1 研究数据表示\t567\n17．2 从数组到链表\t570\n17．2．1 使用链表\t572\n17．2．2 反思\t576\n17．3 抽象数据类型（ADT）\t576\n17．3．1 建立抽象\t577\n17．3．2 建立接口\t578\n17．3．3 使用接口\t581\n17．3．4 实现接口\t583\n17．4 队列ADT\t589\n17．4．1 定义队列抽象数据类型\t590\n17．4．2 定义一个接口\t590\n17．4．3 实现接口数据表示\t591\n17．4．4 测试队列\t598\n17．5 用队列进行模拟\t600\n17．6 链表和数组\t605\n17．7 二叉查找树\t608\n17．7．1 二叉树ADT\t608\n17．7．2 二叉查找树接口\t609\n17．7．3 二叉树的实现\t611\n17．7．4 使用二叉树\t624\n17．7．5 树的思想\t628\n17．8 其他说明\t629\n17．9 关键概念\t630\n17．10 本章小结\t630\n17．11 复习题\t630\n17．12 编程练习\t631\n附录A　复习题答案\t633\n附录B　参考资料\t665\nB．1 参考资料I：补充阅读\t665\nB．2 参考资料II：C运算符\t667\nB．3 参考资料III：基本类型和存储类别\t671\nB．4 参考资料IV：表达式、语句和程序流\t675\nB．5 参考资料V：新增C99和C11的ANSI C库\t679\nB．6 参考资料VI：扩展的整数类型\t714\nB．7 参考资料VII：扩展字符支持\t716\nB．8 参考资料VIII：C99\/C11数值计算增强\t720\nB．9 参考资料IX：C和C++的区别\t726","pages":"730","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s29438897.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s29438897.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s29438897.jpg"},"alt":"https:\/\/book.douban.com\/subject\/26792521\/","id":"26792521","publisher":"人民邮电出版社","isbn10":"7115390592","isbn13":"9787115390592","title":"C Primer Plus（第6版）中文版","url":"https:\/\/api.douban.com\/v2\/book\/26792521","alt_title":"C Primer Plus : 6th","author_intro":"Stephen Prata曾在加利福尼亚的马林学院（肯特菲尔德）教授天文学、物理学和程序设计课程，现已退休。他在加州理工学院获得学士学位，在加州大学伯克利分校获得博士学位。他接触程序设计，是为了利用计算机给星团建模。Stephen撰写和与他人合著了十几本书籍，其中包括C++ Primer Plus和Unix Primer Plus。","summary":"《C Primer Plus（第6版）中文版》详细讲解了C语言的基本概念和编程技巧。\n《C Primer Plus（第6版）中文版》共17章。第1、2章介绍了C语言编程的预备知识。第3~15章详细讲解了C语言的相关知识，包括数据类型、格式化输入\/输出、运算符、表达式、语句、循环、字符输入和输出、函数、数组和指针、字符和字符串函数、内存管理、文件输入输出、结构、位操作等。第16章、17章介绍C预处理器、C库和高级数据表示。本书以完整的程序为例，讲解C语言的知识要点和注意事项。每章末设计了大量复习题和编程练习，帮助读者巩固所学知识和提高实际编程能力。附录给出了各章复习题的参考答案和丰富的参考资料。\n《C Primer Plus（第6版）中文版》可作为C语言的教材，适用于需要系统学习C语言的初学者，也适用于巩固C语言知识或希望进一步提高编程技术的程序员。","series":{"id":"23545","title":"C和C++实务精选"},"price":"CNY 89.00"},{"rating":{"max":10,"numRaters":389,"average":"9.3","min":0},"subtitle":"现代方法","author":["K. N. King"],"pubdate":"2010-4","tags":[{"count":526,"name":"C语言","title":"C语言"},{"count":315,"name":"C","title":"C"},{"count":240,"name":"程序设计","title":"程序设计"},{"count":239,"name":"编程","title":"编程"},{"count":230,"name":"计算机","title":"计算机"},{"count":182,"name":"C\/C++","title":"C\/C++"},{"count":162,"name":"编程语言","title":"编程语言"},{"count":128,"name":"计算机科学","title":"计算机科学"}],"origin_title":"C Programming: A Modern Approach, Second Edition","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s4171870.jpg","binding":"平装","translator":["吕秀锋","黄倩"],"catalog":"第1章 C语言概述1\n1.1 C语言的历史1\n1.1.1 起源1\n1.1.2 标准化1\n1.1.3 基于C的语言2\n1.2 C语言的优缺点3\n1.2.1 C语言的优点3\n1.2.2 C语言的缺点3\n1.2.3 高效地使用C语言4\n问与答5\n第2章 C语言基本概念7\n2.1 编写一个简单的C程序7\n程序显示双关语7\n2.1.1 编译和链接8\n2.1.2 集成开发环境8\n2.2 简单程序的一般形式9\n2.2.1 指令9\n2.2.2 函数9\n2.2.3 语句10\n2.2.4 显示字符串10\n2.3 注释11\n2.4 变量和赋值12\n2.4.1 类型12\n2.4.2 声明13\n2.4.3 赋值13\n2.4.4 显示变量的值14\n程序计算箱子的空间重量14\n2.4.5 初始化15\n2.4.6 显示表达式的值16\n2.5 读入输入16\n程序计算箱子的空间重量（改进版）16\n2.6 定义常量的名字17\n程序华氏温度转换为摄氏温度17\n2.7 标识符18\n2.8 C程序的书写规范19\n问与答21\n练习题23\n编程题24\n第3章 格式化输入\/输出26\n3.1 printf函数26\n3.1.1 转换说明27\n程序用printf函数格式化数28\n3.1.2 转义序列28\n3.2 scanf函数29\n3.2.1 scanf函数的工作方法30\n3.2.2 格式串中的普通字符31\n3.2.3 易混淆的printf函数和scanf函数32\n程序分数相加32\n问与答33\n练习题34\n编程题35\n第4章 表达式36\n4.1 算术运算符36\n程序计算通用产品代码的校验位38\n4.2 赋值运算符39\n4.2.1 简单赋值40\n4.2.2 左值41\n4.2.3 复合赋值41\n4.3 自增运算符和自减运算符42\n4.4 表达式求值43\n4.5 表达式语句45\n问与答45\n练习题47\n编程题49\n第5章 选择语句50\n5.1 逻辑表达式50\n5.1.1 关系运算符50\n5.1.2 判等运算符51\n5.1.3 逻辑运算符51\n5.2 if语句52\n5.2.1 复合语句53\n5.2.2 else子句53\n5.2.3 级联式if语句54\n程序计算股票经纪人的佣金55\n5.2.4 “悬空else”的问题56\n5.2.5 条件表达式57\n5.2.6 C89中的布尔值58\n5.2.7 C99中的布尔值58\n5.3 switch语句59\n程序显示法定格式的日期61\n问与答62\n练习题65\n编程题67\n第6章 循环69\n6.1 while语句69\n程序显示平方表71\n程序数列求和71\n6.2 do语句72\n程序计算整数的位数73\n6.3 for语句73\n6.3.1 for语句的惯用法74\n6.3.2 在for语句中省略表达式75\n6.3.3 C99中的for语句75\n6.3.4 逗号运算符76\n程序显示平方表（改进版）77\n6.4 退出循环78\n6.4.1 break语句78\n6.4.2 continue语句78\n6.4.3 goto语句79\n程序账簿结算80\n6.5 空语句81\n问与答83\n练习题84\n编程题85\n第7章 基本类型88\n7.1 整数类型88\n7.1.1 C99中的整数类型90\n7.1.2 整数常量90\n7.1.3 C99中的整数常量91\n7.1.4 整数溢出91\n7.1.5 读\/写整数91\n程序数列求和（改进版）92\n7.2 浮点类型93\n7.2.1 浮点常量94\n7.2.2 读\/写浮点数94\n7.3 字符类型94\n7.3.1 字符操作95\n7.3.2 有符号字符和无符号字符95\n7.3.3 算术类型96\n7.3.4 转义序列96\n7.3.5 字符处理函数97\n7.3.6 用scanf和printf读\/写字符98\n7.3.7 用getchar和putchar读\/写字符98\n程序确定消息的长度99\n7.4 类型转换100\n7.4.1 常用算术转换101\n7.4.2 赋值过程中的转换102\n7.4.3 C99中的隐式转换103\n7.4.4 强制类型转换103\n7.5 类型定义105\n7.5.1 类型定义的优点105\n7.5.2 类型定义和可移植性105\n7.6 sizeof运算符106\n问与答107\n练习题109\n编程题110\n第8章 数组113\n8.1 一维数组113\n8.1.1 数组下标113\n程序数列反向115\n8.1.2 数组初始化115\n8.1.3 指定初始化式116\n程序检查数中重复出现的数字116\n8.1.4 对数组使用sizeof运算符117\n程序计算利息118\n8.2 多维数组119\n8.2.1 多维数组初始化120\n8.2.2 常量数组121\n程序发牌121\n8.3 C99中的变长数组122\n问与答123\n练习题124\n编程题125\n第9章 函数129\n9.1 函数的定义和调用129\n程序计算平均值129\n程序显示倒计数130\n程序显示双关语（改进版）131\n9.1.1 函数定义132\n9.1.2 函数调用133\n程序判定素数134\n9.2 函数声明135\n9.3 实际参数136\n9.3.1 实际参数的转换137\n9.3.2 数组型实际参数138\n9.3.3 变长数组形式参数140\n9.3.4 在数组参数声明中使用static141\n9.3.5 复合字面量141\n9.4 return语句142\n9.5 程序终止143\n9.6 递归144\n程序快速排序146\n问与答147\n练习题150\n编程题153\n第10章 程序结构155\n10.1 局部变量155\n10.1.1 静态局部变量156\n10.1.2 形式参数156\n10.2 外部变量156\n10.2.1 示例：用外部变量实现栈156\n10.2.2 外部变量的利与弊157\n程序猜数158\n10.3 程序块161\n10.4 作用域162\n10.5 构建C程序163\n程序给一手牌分类163\n问与答169\n练习题169\n编程题170\n第11章 指针172\n11.1 指针变量172\n11.2 取地址运算符和间接寻址运算符173\n11.2.1 取地址运算符173\n11.2.2 间接寻址运算符174\n11.3 指针赋值174\n11.4 指针作为参数176\n程序找出数组中的最大元素和最小元素177\n11.5 指针作为返回值179\n问与答180\n练习题181\n编程题182\n第12章 指针和数组184\n12.1 指针的算术运算184\n12.1.1 指针加上整数185\n12.1.2 指针减去整数185\n12.1.3 两个指针相减186\n12.1.4 指针比较186\n12.1.5 指向复合常量的指针186\n12.2 指针用于数组处理186\n12.3 用数组名作为指针188程序数列反向（改进版）189\n12.3.1 数组型实际参数（改进版）189\n12.3.2 用指针作为数组名191\n12.4 指针和多维数组191\n12.4.1 处理多维数组的元素191\n12.4.2 处理多维数组的行192\n12.4.3 处理多维数组的列192\n12.4.4 用多维数组名作为指针192\n12.5 C99中的指针和变长数组193\n问与答194\n练习题195\n编程题197\n第13章 字符串198\n13.1 字符串字面量198\n13.1.1 字符串字面量中的转义序列198\n13.1.2 延续字符串字面量199\n13.1.3 如何存储字符串字面量199\n13.1.4 字符串字面量的操作200\n13.1.5 字符串字面量与字符常量200\n13.2 字符串变量200\n13.2.1 初始化字符串变量201\n13.2.2 字符数组与字符指针202\n13.3 字符串的读和写203\n13.3.1 用printf函数和puts函数写字符串203\n13.3.2 用scanf函数和gets函数读字符串203\n13.3.3 逐个字符读字符串204\n13.4 访问字符串中的字符205\n13.5 使用C语言的字符串库206\n13.5.1 strcpy函数207\n13.5.2 strlen函数208\n13.5.3 strcat函数208\n13.5.4 strcmp函数209程序显示一个月的提醒列表209\n13.6 字符串惯用法211\n13.6.1 搜索字符串的结尾211\n13.6.2 复制字符串213\n13.7 字符串数组214\n程序核对行星的名字217\n问与答218\n练习题220\n编程题222\n第14章 预处理器225\n14.1 预处理器的工作原理225\n14.2 预处理指令227\n14.3 宏定义227\n14.3.1 简单的宏227\n14.3.2 带参数的宏229\n14.3.3 #运算符231\n14.3.4 ##运算符231\n14.3.5 宏的通用属性232\n14.3.6 宏定义中的圆括号233\n14.3.7 创建较长的宏233\n14.3.8 预定义宏234\n14.3.9 C99中新增的预定义宏235\n14.3.10 空的宏参数236\n14.3.11 参数个数可变的宏236\n14.3.12 __func__标识符237\n14.4 条件编译237\n14.4.1 #if指令和#endif指令238\n14.4.2 defined运算符238\n14.4.3 #ifdef指令和#ifndef指令239\n14.4.4 #elif指令和#else指令239\n14.4.5 使用条件编译240\n14.5 其他指令240\n14.5.1 #error指令240\n14.5.2 #line指令241\n14.5.3 #pragma指令242\n14.5.4 _Pragma运算符242\n问与答243\n练习题245\n第15章 编写大型程序248\n15.1 源文件248\n15.2 头文件249\n15.2.1 #include指令249\n15.2.2 共享宏定义和类型定义250\n15.2.3 共享函数原型251\n15.2.4 共享变量声明252\n15.2.5 嵌套包含253\n15.2.6 保护头文件253\n15.2.7 头文件中的#error指令254\n15.3 把程序划分成多个文件254程序文本格式化255\n15.4 构建多文件程序260\n15.4.1 makefile260\n15.4.2 链接期间的错误262\n15.4.3 重新构建程序262\n15.4.4 在程序外定义宏264\n问与答264\n练习题265\n编程题266\n第16章 结构、联合和枚举267\n16.1 结构变量267\n16.1.1 结构变量的声明267\n16.1.2 结构变量的初始化269\n16.1.3 指定初始化269\n16.1.4 对结构的操作270\n16.2 结构类型270\n16.2.1 结构标记的声明271\n16.2.2 结构类型的定义272\n16.2.3 结构作为参数和返回值272\n16.2.4 复合字面量273\n16.3 嵌套的数组和结构274\n16.3.1 嵌套的结构274\n16.3.2 结构数组274\n16.3.3 结构数组的初始化275程序维护零件数据库275\n16.4 联合281\n16.4.1 用联合来节省空间282\n16.4.2 用联合来构造混合的数据结构284\n16.4.3 为联合添加“标记字段”284\n16.5 枚举285\n16.5.1 枚举标记和类型名286\n16.5.2 枚举作为整数286\n16.5.3 用枚举声明“标记字段”286\n问与答287\n练习题289\n编程题293\n第17章 指针的高级应用294\n17.1 动态存储分配294\n17.1.1 内存分配函数294\n17.1.2 空指针295\n17.2 动态分配字符串296\n……\n第18章 声明 327\n第19章 程序设计 345\n第20章 底层程序设计 363\n第21章 标准库 377\n第22章 输入\/输出 384\n第23章 库对数值和字符数据的支持 419\n第24章 错误处理 446\n第25章 国际化特性 456\n第26章 其他库函数 482\n第27章 C99对数学计算的新增支持 503\n附录A C语言运算符 524\n附录B C99与C89的比较 525\n附录C C89与经典C的比较 529\n附录D 标准库函数 532\n附录E ASCII字符集 569\n参考文献 570\n索引 573","pages":"600","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s4171870.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s4171870.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s4171870.jpg"},"alt":"https:\/\/book.douban.com\/subject\/4279678\/","id":"4279678","publisher":"人民邮电出版社","isbn10":"7115219575","isbn13":"9787115219572","title":"C语言程序设计","url":"https:\/\/api.douban.com\/v2\/book\/4279678","alt_title":"C Programming: A Modern Approach, Second Edition","author_intro":"K. N. King 世界知名的计算机程序设计教育家，现为佐治亚州立大学数学与计算机科学系副教授。他拥有耶鲁大学计算机科学硕士学位，加州大学伯克利分校计算机科学博士学位，曾任教于佐治亚理工学院。除本书外，他还撰写了广受欢迎的著作Modula-2: A Complete Guide 和Java Programming: From the Beginning，并在Dr.Dobb's Journal等权威杂志上发表了许多文章。\n吕秀锋，亚洲理工大学（AIT）计算机软件硕士，现为北京理工大学软件学院教师。多年来一直从事“计算机基础（双语）”、“C语言程序设计（双语）”以及“程序设计开发与实践”等本科生课程的教学工作，深受学生欢迎。她还译有《数据结构与算法：C＃语言描述》一书。\n黄倩，中国科学院计算技术研究所工学博士，中国计算机学会会员。研究方向包括视频处理、视频监控等，已在知名的国际期刊和国际会议论文集上发表10篇论文。译有《编程珠玑（第2版）》一书，受到读者欢迎。","summary":"时至今日， C语言仍然是计算机领域的通用语言之一，但今天的 C语言已经和最初的时候大不相同了。本书最主要的一个目的就是通过一种“现代方法”来介绍 C语言，书中强调标准 C，强调软件工程，不再强调“手工优化”。这一版中紧密结合了 C99标准，并与 C89标准进行对照，补充了 C99中的最新特性。本书分为 C语言的基础特性、 C语言的高级特性、 C语言标准库和参考资料 4个部分。每章末尾都有一个“问与答”小节给出一系列与该章内容相关的问题及答案，此外还包含适量的习题。\n本书是为大学本科阶段的 C语言课程编写的教材，同时也非常适合作为其他课程的辅助用书。","series":{"id":"50484","title":"图灵程序设计丛书·C\/C++系列"},"price":"79.00元"},{"rating":{"max":10,"numRaters":133,"average":"8.0","min":0},"subtitle":"C语言描述","author":["Kyle Loudon"],"pubdate":"2012-8","tags":[{"count":270,"name":"算法","title":"算法"},{"count":103,"name":"C语言","title":"C语言"},{"count":79,"name":"编程","title":"编程"},{"count":63,"name":"计算机","title":"计算机"},{"count":48,"name":"计算机科学","title":"计算机科学"},{"count":38,"name":"程序设计","title":"程序设计"},{"count":34,"name":"C","title":"C"},{"count":31,"name":"Programming","title":"Programming"}],"origin_title":"Mastering Algorithms with C","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s11351454.jpg","binding":"平装","translator":["肖翔","陈舸"],"catalog":"1. 前言\n2. 第1部分 预备知识\n3. 第1章 概述\n4. 数据结构简介\n5. 算法简介\n6. 小酌软件工程\n7. 如何使用本书\n8. 第2章 指针操作\n9. 指针基础\n10. 存储空间分配\n11. 数据集合与指针的算术运算\n12. 作为函数参数的指针\n13. 泛型指针与类型转换\n14. 函数指针\n15. 问与答\n16. 相关主题\n17. 第3章 递归\n18. 基本递归\n19. 尾递归\n20. 问与答\n21. 相关主题\n22. 第4章 算法分析\n23. 最坏情况分析\n24. O表示法\n25. 计算的复杂度\n26. 实例分析：插入排序\n27. 问与答\n28. 相关主题\n29. 第2部分 数据结构\n30. 第5章 链表\n31. 单链表介绍\n32. 单链表接口的定义\n33. 单链表的实现与分析\n34. 使用链表的例子：页帧管理\n35. 双向链表介绍\n36. 双向链表接口的定义\n37. 双向链表的实现与分析\n38. 循环链表介绍\n39. 循环链表接口的定义\n40. 循环链表的实现与分析\n41. 使用循环链表的例子：第二次机会页面置换法\n42. 问与答\n43. 相关主题\n44. 第6章 栈和队列\n45. 栈的描述\n46. 栈的接口定义\n47. 栈的实现与分析\n48. 队列的描述\n49. 队列的接口定义\n50. 队列的实现与分析\n51. 队列示例：事件处理\n52. 问与答\n53. 相关主题\n54. 第7章 集合\n55. 集合介绍\n56. 集合的性质\n57. 集合接口的定义\n58. 集合抽象数据类型的实现和分析\n59. Set示例：集合覆盖\n60. 问与答\n61. 相关主题\n62. 第8章 哈希表\n63. 链式哈希表的描述\n64. 链式哈希表的接口定义\n65. 链式哈希表的实现与分析\n66. 链式哈希表的例子：符号表\n67. 开地址哈希表的描述\n68. 开地址哈希函数的接口定义\n69. 开地址哈希表的实现与分析\n70. 问与答\n71. 相关主题\n72. 第9章 树\n73. 二叉树介绍\n74. 二叉树的接口定义\n75. 二叉树的实现与分析\n76. 二叉树示例：表达式处理\n77. 二叉搜索树介绍\n78. 二叉搜索树的接口定义\n79. 二叉搜索树的实现与分析\n80. 问与答\n81. 相关主题\n82. 第10章 堆和优先队列\n83. 堆的描述\n84. 堆的接口定义\n85. 堆的实现与分析\n86. 优先队列的描述\n87. 优先队列的接口定义\n88. 优先队列的实现与分析\n89. 优先队列的示例：包裹分拣\n90. 问与答\n91. 相关主题\n92. 第11章 图\n93. 图的描述\n94. 图的接口定义\n95. 图的实现与分析\n96. 关于图的应用举例：计算网络跳数\n97. 关于图的应用举例：拓扑排序\n98. 问与答\n99. 相关主题\n100. 第3部分 算法\n101. 第12章 排序和搜索\n102. 插入排序的描述\n103. 插入排序的接口定义\n104. 插入排序的实现与分析\n105. 快速排序的描述\n106. 快速排序的接口定义\n107. 快速排序的实现与分析\n108. 快速排序的例子：目录列表\n109. 归并排序的描述\n110. 归并排序的接口定义\n111. 归并排序的实现与分析\n112. 计数排序的描述\n113. 计数排序的接口定义\n114. 计数排序的实现与分析\n115. 基数排序的描述\n116. 基数排序的接口定义\n117. 基数排序的实现与分析\n118. 二分查找的描述\n119. 二分查找的接口定义\n120. 二分查找的实现与分析\n121. 二分查找的例子：拼写检查器\n122. 问与答\n123. 相关主题\n124. 第13章 数值计算\n125. 多项式插值法\n126. 多项式插值的接口定义\n127. 多项式插值的实现与分析\n128. 最小二乘估计法\n129. 最小二乘估计的接口定义\n130. 最小二乘估计的实现和分析\n131. 方程求解介绍\n132. 方程求解的接口定义\n133. 方程求解的实现与分析\n134. 问与答\n135. 相关主题\n136. 第14章 数据压缩\n137. 位操作的描述\n138. 位操作的接口定义\n139. 位操作的实现与分析\n140. 霍夫曼编码的描述\n141. 霍夫曼编码的接口定义\n142. 霍夫曼编码的分析与实现\n143. 霍夫曼编码的例子：网络优化\n144. LZ77的描述\n145. LZ77的接口定义\n146. LZ77的实现与分析\n147. 问与答\n148. 相关主题\n149. 第15章 数据加密\n150. DES算法介绍\n151. DES的接口定义\n152. DES算法的实现和分析\n153. DES应用举例：分组加密模式\n154. RSA算法介绍\n155. RSA的接口定义\n156. RSA算法的实现与分析\n157. 问与答\n158. 相关主题\n159. 第16章 图算法\n160. 最小生成树的描述\n161. 最小生成树的接口定义\n162. 最小生成树的实现与分析\n163. 最短路径的描述\n164. 最短路径的接口定义\n165. 最短路径的实现与分析\n166. 最短路径的例子：路由表\n167. 旅行商问题的描述\n168. 旅行商问题的接口定义\n169. 旅行商问题的实现与分析\n170. 问与答\n171. 相关主题\n172. 第17章 几何算法\n173. 测试线段是否相交\n174. 测试线段是否相交的标准方法\n175. 检测线段是否相交的接口定义\n176. 检测线段是否相交的实现与分析\n177. 凸包简介\n178. Jarvis’s March\n179. 凸包的接口定义\n180. 凸包的实现与分析\n181. 球面弧长\n182. 求解球面弧长的接口定义\n183. 求解球面弧长的实现和分析\n184. 球面弧长的应用举例：地球上两点之间的近似距离\n185. 问与答\n186. 相关主题","pages":"401","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s11351454.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s11351454.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s11351454.jpg"},"alt":"https:\/\/book.douban.com\/subject\/14267904\/","id":"14267904","publisher":"机械工业出版社","isbn10":"7111394267","isbn13":"9787111394266","title":"算法精解","url":"https:\/\/api.douban.com\/v2\/book\/14267904","alt_title":"Mastering Algorithms with C","author_intro":"Kyle Loudon是美国加州洛斯加托斯Jeppesen Dataplan公司的一名软件工程师，主管图形接口开发小组，主攻航迹规划软件的研发，这些软件主要用于商业航空公司、私营航空部门和其他一些航空制造业。在来到Jeppesen之前，Kyle在IBM公司是一名系统程序员。在技术上，Kyle主要对操作系统、网络、人机交互等领域感兴趣。1992年，Kyle在普渡大学拿到了计算机科学学士学位，并取得了法语的第二学位，同时他还被选入斐陶斐荣誉学会（美国大学优等生之荣誉学会）。他在普渡大学计算机系教了三年的计算机课程。在这期间，他完成了他个人的第一本书《Understanding Computers》，这本书用理论结合实践的方式介绍计算机的方方面面。如今，尽管他继续工作在硅谷的软件业，但他仍然坚韧不拔地在追求一个更高的学位。\n除了计算机，Kyle多年来喜欢打网球、教网球。他还喜欢山地骑行、滑冰，偶尔也和朋友们一起参加高尔夫课程。另外，Kyle还喜欢各种形式的戏剧、美食，以及某些风格的音乐和艺术；他期望成为钢琴家和艺术家，但希望渺茫。他现在在Jeppesen的工作是从他1992年开始驾驶飞机之后找到的。现在，他是一个拥有美国联邦航空局颁发的商业飞行员执照的飞行员。","summary":"本书是数据结构和算法领域的经典之作，十余年来，畅销不衰！全书共分为三部分：第一部分首先介绍了数据结构和算法的概念，以及使用它们的原因和意义，然后讲解了数据结构和算法中最常用的技术——指针和递归，最后还介绍了算法的分析方法，旨在为读者学习这本书打下坚实的基础；第二部分对链表、栈、队列、集合、哈希表、堆、图等常用数据结构进行了深入阐述；第三部分对排序、搜索数值计算、数据压缩、数据加密、图算法、几何算法等经典算法进行了精辟的分析和讲解。\n本书的众多特色使得它在同类书中独树一帜：具体实现都采用正式的C语言代码而不是伪代码，在很多数据结构和算法的实现过程中，有大量细节问题是伪代码不能解决的；每一章都有精心组织的主题和应用；全部示例来自真实的应用，不只是一般的练习；对每种数据结构、算法和示例都进行了详细分析；每一章的末尾都会有一系列问题和对应的回答，旨在强调这一章的重要思想……\n本书中的代码尤为值得强调：所有实现都采用C语言编写，所有代码都优先用于教学目的，所有代码都在4种平台上经过完整测试，头文件记录了所有公共的接口，命名规则适用于全书所有的代码，所有的代码都包含大量注释……\n本书内容包括：\n· 数据结构和算法的概念，以及使用它们的原因和意义\n· 指针和递归\n· 算法分析\n· 常用数据结构：链表、栈、队列、集合、哈希表、树、堆、优先级队列以及图\n· 排序和搜索\n· 数值计算\n· 数据压缩\n· 数据加密\n· 图算法\n· 几何算法","price":"79.00元"},{"rating":{"max":10,"numRaters":266,"average":"9.4","min":0},"subtitle":"42 Specific Ways to Improve Your Use of C++11 and C++14","author":["Scott Meyers"],"pubdate":"2014-12","tags":[{"count":330,"name":"C++","title":"C++"},{"count":168,"name":"C++11","title":"C++11"},{"count":111,"name":"C\/C++","title":"C\/C++"},{"count":86,"name":"编程","title":"编程"},{"count":80,"name":"计算机","title":"计算机"},{"count":72,"name":"Programming","title":"Programming"},{"count":49,"name":"程序设计","title":"程序设计"},{"count":34,"name":"effective","title":"effective"}],"origin_title":"","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s27951196.jpg","binding":"Paperback","translator":[],"catalog":"","pages":"320","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s27951196.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s27951196.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s27951196.jpg"},"alt":"https:\/\/book.douban.com\/subject\/25923597\/","id":"25923597","publisher":"O'Reilly Media","isbn10":"1491903996","isbn13":"9781491903995","title":"Effective Modern C++","url":"https:\/\/api.douban.com\/v2\/book\/25923597","alt_title":"","author_intro":"Scott Meyers is one of the world's foremost authorities on C++. He wrote the best-selling Effective C++ series (Effective C++, More Effective C++, and Effective STL); published and maintains the annotated training materials Overview of the New C++ (C++11\/14) and Effective C++ in an Embedded Environment; is Consulting Editor for the Effective Software Development Series, and, with Herb Sutter and Andrei Alexandrescu, is a principal in C++ and Beyond. He has a Ph.D in Computer Science from Brown University. He's currently working on a new book, Effective Modern C++, which he expects to publish this fall.","summary":"Learn how to program expertly with C++ with this practical book from Scott Meyers, one of the world's foremost authorities on this systems programming language. Scott Meyers takes some of the most difficult pieces of C++ code and unfurls them so that you can see how to manipulate your own project code. This is the first book to contain content written with the C++14 standard.\nTackle 42 separate C++ problems and solutions\nLearn critical techniques for success on topics from smart pointers to lambda expressions\nUnderstand key concepts by taking the C++ 98 standard to C++ 11 and then to C++ 14","price":"USD 49.99"},{"rating":{"max":10,"numRaters":625,"average":"9.1","min":0},"subtitle":"N．C. Wyeth 插图官方授权版本","author":["[美] 玛•金•罗琳斯"],"pubdate":"2016-6-1","tags":[{"count":198,"name":"自然","title":"自然"},{"count":183,"name":"美国文学","title":"美国文学"},{"count":183,"name":"外国文学","title":"外国文学"},{"count":146,"name":"玛•金•罗琳斯","title":"玛•金•罗琳斯"},{"count":136,"name":"美国","title":"美国"},{"count":135,"name":"成长","title":"成长"},{"count":129,"name":"我想读这本书","title":"我想读这本书"},{"count":128,"name":"小说","title":"小说"}],"origin_title":"The Yearling","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28748579.jpg","binding":"平装","translator":["梅静"],"catalog":"目录\n第一章 小水车\n第二章 乔迪的家\n第三章 飞来横祸\n第四章 猎熊\n第五章 草翅膀\n第六章 大快朵颐\n第七章 一桩好买卖\n第八章 意外收获\n第九章 灰岩坑\n第十章 夜晚的奇遇\n第十一章 猎鹿\n第十二章 仗义相助\n第十三章 告别奥利弗\n第十四章 危机\n第十五章 新伙伴\n第十六章 偷蜜和猎狐\n第十七章 痛失好友\n第十八章 怀念“草翅膀”\n第十九章 暴风雨\n第二十章 暴风雨后的森林\n第二十一章 瘟疫\n第二十二章 储粮\n第二十三章 狼群的夜袭\n第二十四章 猎狼\n第二十五章圣诞节前夕\n第二十六章 追捕“大笨脚”\n第二十七章 送别\n第二十八章 孤狼\n第二十九章 闯祸\n第三十章 爸爸病了\n第三十一章 无计可施\n第三十二章 再见，小鹿\n第三十三章 别了，童年","ebook_url":"https:\/\/read.douban.com\/ebook\/22165742\/","pages":"432","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s28748579.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s28748579.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28748579.jpg"},"alt":"https:\/\/book.douban.com\/subject\/26801361\/","id":"26801361","publisher":"云南人民出版社","isbn10":"7222145583","isbn13":"9787222145580","title":"鹿苑长春","url":"https:\/\/api.douban.com\/v2\/book\/26801361","alt_title":"The Yearling","author_intro":"【作者 】\n玛•金•罗琳斯\nMarjorie Kinnan Rawlings\n1896-1953\n美国作家  生于华盛顿， 毕业于威斯康星大学， 在纽约担任多年记者、编辑\n创建了佛罗里达边远林区的“地方文学”\n先后获得普利策奖、 欧·亨利奖、兰登书屋终身畅销奖\n创作的两部长篇小说《鹿苑长春》和《十字小溪》先后荣获普利策文学奖\n代表作《鹿苑长春》《十字小溪》《一位年轻姑娘》《南方月亮下》《金苹果》等\n【绘者】\nN.C.韦思\nNewell Convers Wyeth\n1882—1956\n美国现实主义绘画大师  一生创作近4000幅画作\n画作现收藏于布兰迪万河博物馆 、波特兰艺术博物馆和法恩斯沃斯艺术博物馆。1997年，他生活和工作的地方（宾夕法尼亚州查兹福德小镇墨菲路）被美国政府指定为国家历史地标之一。\n【译者】\n梅静\n北京大学外国语学院翻译硕士\n译有《柳林风声》《小鹿斑比》《小公主》《威士忌海滩》《孪生姐妹》《想飞的乔琪》《布谷鸟的呼唤》。","summary":"【“任何人遇到挫折的时候，都能够从这里得到新的勇气。”】\n【内容简介】\n《鹿苑长春》由美国作家玛·金·罗琳斯创作于1938年，根据佛罗里达林区一位老人的童年回忆创作改编，发行后登上美国畅销书榜首并持续140周，于次年获得普利策文学奖。至今，在美国累计阅读量达到5.5亿。至今，该小说被翻译成20种语言，在133个国家出版，受到不同地域和文化人们的喜爱。在1946年被米高梅公司拍摄成电影，获得奥斯卡最佳艺术指导奖和最佳摄影奖。\n故事讲述美国南北战争后佛罗里达垦荒区普通人的劳动、斗争和悲欢离合。主人公巴克斯特一家生活在佛罗里达岛地过着自给自足的农耕狩猎生活，所处的自然美景中是一幅生动绚丽的丛林画卷，该作品后被誉为描绘少年时代的经典童年诗歌。然而，它却是一本全年龄段读本，书中透出的森林清新气息和舒缓节奏，与当代都市生活迥然不同。其中有惊险的狩猎、奇妙的自然景观、悠然的乡村美景，还有风趣幽默的人物对话，以及充满泥土气息的方言。书中人们为了生存这一简单目的，持有着最质朴的勇气和信念。\n孩子们可以从书中读到激动人心的狩猎，看见原野林莽、飞鸟起落、狼踪熊迹、暴雨狂风，进入乔迪的世界，与他共度被爸爸精心呵护、无忧无虑的童年。成年人，尤其是经历过离合悲欢、人世艰难的人，都能从书中读出欢笑、甜蜜、惆怅和感伤。\n【编辑推荐】\n《鹿苑长春》是一部经典的动物文学与环境文学著作。\n故事发生在美国南北战争结束后的垦荒时代，讲述与父母生活在佛罗里达岛地的男孩乔迪与一岁小鹿间的故事。\n爸爸在牧师家庭长大，正直善良，从不说谎，因经历战争后，厌倦了与人相处的世俗，带着妻子奥拉远离城镇，选择佛罗里达的巴克斯特岛地，过着狩猎农耕的生活。家中的生计依赖于自然选择，时常受到岛地周围野兽的威胁，尤其是经常出没偷食家畜的棕熊“大笨脚”。\n因为自然环境的严酷，夫妻两人连续夭折了3个孩子，以至于乔迪诞生后，妈妈奥拉因为遭遇太多次失去，对儿子不抱有太多疼爱，也许是向现实的冷酷低头，看待事物抱有异常冷漠的清醒。爸爸彭尼从小在家中担起大梁，了解天真无邪的珍贵，反而给乔迪加倍的疼爱，试图延长乔迪无忧无虑的童年。在丛林里，有变幻的迷人风光，也有让人惊叹的动物奇观。乔迪一直喜欢听猎人讲在狩猎途中的奇遇，期待着自己与动物的亲近。\n他跟着爸爸狩猎，追踪“大笨脚”，爬在树上看鹿妈妈带着小鹿啃食树叶，与爸爸抓到罕见的白色浣熊、在克拉克莎草丛中钓鱼，遇到高鸣鹤跳沙龙舞；他跟着巴克.福利斯特在月光下的玉米地里猎狐，去松树干掏蜂蜜；与好友“草翅膀”喂养小浣熊、欧洲灰雀，一起看西班牙人后裔穿过古栈道，一起数天上米诺鱼般的星星……生活就像他给自己在灰岩坑水塘边造的小水车，随着时间的流水，悠然转动，奏出欢快的乐章，似乎没有停下来的理由。\n然而乔迪作为独子，在偏远岛地，一直是孤寂的。他希望能像爸爸彭尼一样拥有只对自己忠诚的宠物。因为口粮不足，妈妈却一直拒绝驯养动物。直到有一天，在乔迪跟随爸爸追踪走失家猪的途中，遭遇危机，也遇到了那头刚出生不久的小鹿……\n故事讲失去，也讲成长；讲孤独，也讲爱与宽容。每个人也许会从中找到真挚的共鸣，遗憾和怅惘，但更多的是，是勇气。\n【名人推荐】\n“谈到近人的作品，说「不朽」总彷佛还太早，然而《鹿苑长春》在近代文学上的地位已经奠定了。《鹿苑长春》里面出现的动物比人多──鹿、响尾蛇、八字脚的老熊、牛、马、猪──像一个动物园，但是里面的人物，尤其是那男孩子乔迪，是使人永远不能忘记的。\n那孩子失去了他最心爱的东西，使他受到很深的刺激，然而他从此就坚强起来，长大成人了。我们仔细回味，就可以觉得这不止于是一个孩子的故事，任何人遇到挫折的时候，都能够从这里得到新的勇气。\n这故事具有真正的悲剧的因素──无法避免，也不可挽回。书中对于儿童心理有非常深入的描写，可以帮助做父母的人了解自己的子女。写父爱也发掘到人性的深处。\n它是健康的，向上的，但也许它最动人的地方是与东方的心情特别接近的一种淡淡的哀愁。最后的两段更是充满了一种难堪的怅惘，我译到这里的时候，甚至于译完之后重抄一遍，抄到这里的时候，也都是像第一次读到一样地觉得非常感动，眼睛湿润起来。我相信许多读者一定也有同感。”\n——张爱玲\n【媒体推荐】\n\n在罗琳斯女士之前，还没有谁创造出如此栩栩如生且亲近读者的一系列形象，其亲密的感情感染人，不禁令人产生共鸣。\n——纽约时报\n“Never before has Mrs. Rawlings created a set of characters who are so close and real to the reader, whose intimate life one can share without the taint of unconscious patronage.\" (The New York Times)\n惊心动魄的探险和令人怅惘的人性元素……这是一部不愧于普利策奖桂冠的经典作品，故事质朴的语言和四季变化下的生态智慧，都给予这本书一种独特而难忘的气质。而画家N.C.韦思也以温暖、柔和的插图，恰到好处地捕捉到那个垦荒时代的粗莽和淳美。\n——亚马逊网站\n“Heart-stopping adventure and heart-wrenching human element…. This is a classic well worth its Pulitzer Prize. Earthy dialect and homespun wisdom season the story, giving it a unique and unforgettable flavor, and N.C. Wyeth's warm, soft illustrations capture an era of rough subsistence and sweet survival.”\n(Amazon.com)","ebook_price":"12.00","price":"48.00元"},{"rating":{"max":10,"numRaters":531,"average":"8.9","min":0},"subtitle":"使用Visual C++5.0 & MFC 4.2","author":["侯俊杰"],"pubdate":"2001-1","tags":[{"count":303,"name":"MFC","title":"MFC"},{"count":174,"name":"C++","title":"C++"},{"count":108,"name":"计算机","title":"计算机"},{"count":92,"name":"编程","title":"编程"},{"count":74,"name":"深入浅出MFC","title":"深入浅出MFC"},{"count":72,"name":"侯捷","title":"侯捷"},{"count":64,"name":"Windows","title":"Windows"},{"count":38,"name":"经典","title":"经典"}],"origin_title":"","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28952279.jpg","binding":"平装16开","translator":[],"catalog":"第一篇 勿在浮砂筑高台\n第一章 Win32 程序基本概念\n第二章 C++的重要性质\n第三章 MFC六大关键技术之仿真\n第二篇 欲善工事先利其器\n第四章 Visual C++ 集成开发环境\n第三篇 浅出MFC程序设计\n第五章 总观Application Framework\n第六章 MFC程序的生死因果\n第七章 简单而完整：MFC骨干程序\n第四篇 深入MFC 程序设计\n第八章 Document-View深入探讨\n第九章 消息映射与命令传递\n第十章 MFC与对话框\n第十一章 Vies功能的加强与重绘效率的提高\n第十二章 打印与预览\n第十三章 多重文件与多重视图\n第十四章 MFC 多线程程序设计\n第十五章 站在众人的肩膀――使用Components & ActiveX Controls\n第五篇 附录","pages":"701","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s28952279.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s28952279.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28952279.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1094852\/","id":"1094852","publisher":"华中科技大学出版社","isbn10":"7900614931","isbn13":"9787900614933","title":"深入浅出MFC （第二版）","url":"https:\/\/api.douban.com\/v2\/book\/1094852","alt_title":"","author_intro":"侯俊杰（1961年9月28日－），笔名侯捷，台湾知名电脑技术专栏作家，致力于电脑技术之扎根工作，文章兼具科技之长与灵性之美，有读者的评语是“比作家更工程师，比工程师更作家”。大同国中、师大附中、交通大学土木系毕业、清华大学动力机械研究所硕士。曾任职工研院机械所与电通所，曾在元智大学授课，近年来多从事两岸学术交流工作。他的妻子美静是一名钢琴师，侯俊杰说他自己“嗜咖啡。妻严不能常得。”","summary":"《深入浅出MFC》分为四大篇。第一篇提出学习MFC程序设计之前的必要基础，包括Widnows程序的基本观念以及C++的高阶议题。“学前基础”是相当主观的认定，但作者是甚于自己的学习经验以及教学经验，其挑选应该颇具说服力。第二篇介绍Visual C++整合环境开发工具。此篇只是提纲挈领，并不企图取代Visual C++使用手册；然而对于软件使用的老手，此篇或已足以帮助掌握Visual C++整合环境。工具的使用虽然谈不上学问，但在视觉化软件开发过程中扮演极重角色。第三篇介绍application framework的观念，以及MFC骨干程序，所谓骨干程序，是指Visual C++的工具AppWizard所产生出来的程序码。当然，AppWizard会根据使用者的选项做出不同的程序码，作者据以解说的是大众化选项下的产品。第四篇以微软公司附于Visual C++光碟片上的一个范例程序Scribble为主轴，一步一步加上新的功能；并在其间深入介绍Runtime Type Information（RTTI）、Dynamic Creation、Persistence（Serialization）、Message Mapping、Command Routing等核心技术。这些技术正是其他专著最缺乏的部分。此篇的最后数章则脱离Scribble程序，另成一格。\n这本书配有一片光盘，书中所有原始码与可执行文件都在其中。","price":"80.00元"},{"rating":{"max":10,"numRaters":457,"average":"8.8","min":0},"subtitle":"使用muduo C++网络库","author":["陈硕"],"pubdate":"2013-1-15","tags":[{"count":607,"name":"网络编程","title":"网络编程"},{"count":543,"name":"Linux","title":"Linux"},{"count":541,"name":"C++","title":"C++"},{"count":454,"name":"多线程","title":"多线程"},{"count":155,"name":"计算机","title":"计算机"},{"count":143,"name":"编程","title":"编程"},{"count":110,"name":"C\/C++","title":"C\/C++"},{"count":87,"name":"Networks","title":"Networks"}],"origin_title":"","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s24522799.jpg","binding":"平装","translator":[],"catalog":"第1 部分C++ 多线程系统编程1\n第1章 线程安全的对象生命期管理3\n1.1 当析构函数遇到多线程. . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n1.1.1 线程安全的定义. . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\n1.1.2 MutexLock 与MutexLockGuard . . . . . . . . . . . . . . . . . . . . 4\n1.1.3 一个线程安全的Counter 示例. . . . . . . . . . . . . . . . . . . . 4\n1.2 对象的创建很简单. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n1.3 销毁太难. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n1.3.1 mutex 不是办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n1.3.2 作为数据成员的mutex 不能保护析构. . . . . . . . . . . . . . . 8\n1.4 线程安全的Observer 有多难. . . . . . . . . . . . . . . . . . . . . . . . . 8\n1.5 原始指针有何不妥. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n1.6 神器shared_ptr\/weak_ptr . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n1.7 插曲：系统地避免各种指针错误. . . . . . . . . . . . . . . . . . . . . . . 14\n1.8 应用到Observer 上. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\n1.9 再论shared_ptr 的线程安全. . . . . . . . . . . . . . . . . . . . . . . . . 17\n1.10 shared_ptr 技术与陷阱. . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n1.11 对象池. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21\n1.11.1 enable_shared_from_this . . . . . . . . . . . . . . . . . . . . . . 23\n1.11.2 弱回调. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\n1.12 替代方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n1.13 心得与小结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n1.14 Observer 之谬. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\n第2章 线程同步精要31\n2.1 互斥器（mutex） . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32\n2.1.1 只使用非递归的mutex . . . . . . . . . . . . . . . . . . . . . . . . 33\n2.1.2 死锁. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\n2.2 条件变量（condition variable） . . . . . . . . . . . . . . . . . . . . . . . 40\n2.3 不要用读写锁和信号量. . . . . . . . . . . . . . . . . . . . . . . . . . . . 43\n2.4 封装MutexLock、MutexLockGuard、Condition . . . . . . . . . . . . . . 44\n2.5 线程安全的Singleton 实现. . . . . . . . . . . . . . . . . . . . . . . . . . 48\n2.6 sleep(3) 不是同步原语. . . . . . . . . . . . . . . . . . . . . . . . . . . . 50\n2.7 归纳与总结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\n2.8 借shared_ptr 实现copy-on-write . . . . . . . . . . . . . . . . . . . . . . 52\n第3章 多线程服务器的适用场合与常用编程模型59\n3.1 进程与线程. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59\n3.2 单线程服务器的常用编程模型. . . . . . . . . . . . . . . . . . . . . . . . 61\n3.3 多线程服务器的常用编程模型. . . . . . . . . . . . . . . . . . . . . . . . 62\n3.3.1 one loop per thread . . . . . . . . . . . . . . . . . . . . . . . . . . 62\n3.3.2 线程池. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63\n3.3.3 推荐模式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64\n3.4 进程间通信只用TCP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65\n3.5 多线程服务器的适用场合. . . . . . . . . . . . . . . . . . . . . . . . . . . 67\n3.5.1 必须用单线程的场合. . . . . . . . . . . . . . . . . . . . . . . . . 69\n3.5.2 单线程程序的优缺点. . . . . . . . . . . . . . . . . . . . . . . . . 70\n3.5.3 适用多线程程序的场景. . . . . . . . . . . . . . . . . . . . . . . . 71\n3.6 “多线程服务器的适用场合”例释与答疑. . . . . . . . . . . . . . . . . . 74\n第4章 C++ 多线程系统编程精要83\n4.1 基本线程原语的选用. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84\n4.2 C\/C++ 系统库的线程安全性. . . . . . . . . . . . . . . . . . . . . . . . . 85\n4.3 Linux 上的线程标识. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89\n4.4 线程的创建与销毁的守则. . . . . . . . . . . . . . . . . . . . . . . . . . . 91\n4.4.1 pthread_cancel 与C++ . . . . . . . . . . . . . . . . . . . . . . . 94\n4.4.2 exit(3) 在C++ 中不是线程安全的. . . . . . . . . . . . . . . . . 94\n4.5 善用__thread 关键字. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96\n4.6 多线程与IO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98\n4.7 用RAII 包装文件描述符. . . . . . . . . . . . . . . . . . . . . . . . . . . 99\n4.8 RAII 与fork() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101\n4.9 多线程与fork() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102\n4.10 多线程与signal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103\n4.11 Linux 新增系统调用的启示. . . . . . . . . . . . . . . . . . . . . . . . . . 105\n第5章 高效的多线程日志107\n5.1 功能需求. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109\n5.2 性能需求. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112\n5.3 多线程异步日志. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114\n5.4 其他方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120\n第2部分 muduo 网络库123\n第6章 muduo 网络库简介125\n6.1 由来. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125\n6.2 安装. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127\n6.3 目录结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129\n6.3.1 代码结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131\n6.3.2 例子. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134\n6.3.3 线程模型. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135\n6.4 使用教程. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136\n6.4.1 TCP 网络编程本质论. . . . . . . . . . . . . . . . . . . . . . . . . 136\n6.4.2 echo 服务的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . 138\n6.4.3 七步实现finger 服务. . . . . . . . . . . . . . . . . . . . . . . . . 140\n6.5 性能评测. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144\n6.5.1 muduo 与Boost.Asio、libevent2 的吞吐量对比. . . . . . . . . . 145\n6.5.2 击鼓传花：对比muduo 与libevent2 的事件处理效率. . . . . . 148\n6.5.3 muduo 与Nginx 的吞吐量对比. . . . . . . . . . . . . . . . . . . 153\n6.5.4 muduo 与ZeroMQ 的延迟对比. . . . . . . . . . . . . . . . . . . 156\n6.6 详解muduo 多线程模型. . . . . . . . . . . . . . . . . . . . . . . . . . . 157\n6.6.1 数独求解服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . . 157\n6.6.2 常见的并发网络服务程序设计方案. . . . . . . . . . . . . . . . . 160\n第7章 muduo 编程示例177\n7.1 五个简单TCP 示例. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178\n7.2 文件传输. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185\n7.3 Boost.Asio 的聊天服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . 194\n7.3.1 TCP 分包. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194\n7.3.2 消息格式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195\n7.3.3 编解码器LengthHeaderCodec . . . . . . . . . . . . . . . . . . . . 197\n7.3.4 服务端的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198\n7.3.5 客户端的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200\n7.4 muduo Buffer 类的设计与使用. . . . . . . . . . . . . . . . . . . . . . . 204\n7.4.1 muduo 的IO 模型. . . . . . . . . . . . . . . . . . . . . . . . . . 204\n7.4.2 为什么non-blocking 网络编程中应用层buffer 是必需的. . . . 205\n7.4.3 Buffer 的功能需求. . . . . . . . . . . . . . . . . . . . . . . . . . 207\n7.4.4 Buffer 的数据结构. . . . . . . . . . . . . . . . . . . . . . . . . . 209\n7.4.5 Buffer 的操作. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211\n7.4.6 其他设计方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217\n7.4.7 性能是不是问题. . . . . . . . . . . . . . . . . . . . . . . . . . . . 218\n7.5 一种自动反射消息类型的Google Protobuf 网络传输方案. . . . . . . . 220\n7.5.1 网络编程中使用Protobuf 的两个先决条件. . . . . . . . . . . . . 220\n7.5.2 根据type name 反射自动创建Message 对象. . . . . . . . . . . . 221\n7.5.3 Protobuf 传输格式. . . . . . . . . . . . . . . . . . . . . . . . . . 226\n7.6 在muduo 中实现Protobuf 编解码器与消息分发器. . . . . . . . . . . . 228\n7.6.1 什么是编解码器（codec） . . . . . . . . . . . . . . . . . . . . . . 229\n7.6.2 实现ProtobufCodec . . . . . . . . . . . . . . . . . . . . . . . . . 232\n7.6.3 消息分发器（dispatcher）有什么用. . . . . . . . . . . . . . . . 232\n7.6.4 ProtobufCodec 与ProtobufDispatcher 的综合运用. . . . . . . 233\n7.6.5 ProtobufDispatcher 的两种实现. . . . . . . . . . . . . . . . . . 234\n7.6.6 ProtobufCodec 和ProtobufDispatcher 有何意义. . . . . . . . . 236\n7.7 限制服务器的最大并发连接数. . . . . . . . . . . . . . . . . . . . . . . . 237\n7.7.1 为什么要限制并发连接数. . . . . . . . . . . . . . . . . . . . . . 237\n7.7.2 在muduo 中限制并发连接数. . . . . . . . . . . . . . . . . . . . 238\n7.8 定时器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240\n7.8.1 程序中的时间. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240\n7.8.2 Linux 时间函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . 241\n7.8.3 muduo 的定时器接口. . . . . . . . . . . . . . . . . . . . . . . . . 242\n7.8.4 Boost.Asio Timer 示例. . . . . . . . . . . . . . . . . . . . . . . . 243\n7.8.5 Java Netty 示例. . . . . . . . . . . . . . . . . . . . . . . . . . . . 245\n7.9 测量两台机器的网络延迟和时间差. . . . . . . . . . . . . . . . . . . . . 248\n7.10 用timing wheel 踢掉空闲连接. . . . . . . . . . . . . . . . . . . . . . . . 250\n7.10.1 timing wheel 原理. . . . . . . . . . . . . . . . . . . . . . . . . . 251\n7.10.2 代码实现与改进. . . . . . . . . . . . . . . . . . . . . . . . . . . . 254\n7.11 简单的消息广播服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257\n7.12 “串并转换”连接服务器及其自动化测试. . . . . . . . . . . . . . . . . . 260\n7.13 socks4a 代理服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264\n7.13.1 TCP 中继器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264\n7.13.2 socks4a 代理服务器. . . . . . . . . . . . . . . . . . . . . . . . . . 267\n7.13.3 N : 1 与1 : N 连接转发. . . . . . . . . . . . . . . . . . . . . . . . 267\n7.14 短址服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267\n7.15 与其他库集成. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268\n7.15.1 UDNS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270\n7.15.2 c-ares DNS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272\n7.15.3 curl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273\n7.15.4 更多. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275\n第8章 muduo 网络库设计与实现277\n8.0 什么都不做的EventLoop . . . . . . . . . . . . . . . . . . . . . . . . . . . 277\n8.1 Reactor 的关键结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280\n8.1.1 Channel class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280\n8.1.2 Poller class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283\n8.1.3 EventLoop 的改动. . . . . . . . . . . . . . . . . . . . . . . . . . . 287\n8.2 TimerQueue 定时器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290\n8.2.1 TimerQueue class . . . . . . . . . . . . . . . . . . . . . . . . . . . 290\n8.2.2 EventLoop 的改动. . . . . . . . . . . . . . . . . . . . . . . . . . . 292\n8.3 EventLoop::runInLoop() 函数. . . . . . . . . . . . . . . . . . . . . . . . 293\n8.3.1 提高TimerQueue 的线程安全性. . . . . . . . . . . . . . . . . . . 296\n8.3.2 EventLoopThread class . . . . . . . . . . . . . . . . . . . . . . . . 297\n8.4 实现TCP 网络库. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299\n8.5 TcpServer 接受新连接. . . . . . . . . . . . . . . . . . . . . . . . . . . . 303\n8.5.1 TcpServer class . . . . . . . . . . . . . . . . . . . . . . . . . . . . 304\n8.5.2 TcpConnection class . . . . . . . . . . . . . . . . . . . . . . . . . 305\n8.6 TcpConnection 断开连接. . . . . . . . . . . . . . . . . . . . . . . . . . . 308\n8.7 Buffer 读取数据. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 313\n8.7.1 TcpConnection 使用Buffer 作为输入缓冲. . . . . . . . . . . . . 314\n8.7.2 Buffer::readFd() . . . . . . . . . . . . . . . . . . . . . . . . . . 315\n8.8 TcpConnection 发送数据. . . . . . . . . . . . . . . . . . . . . . . . . . . 316\n8.9 完善TcpConnection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 320\n8.9.1 SIGPIPE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321\n8.9.2 TCP No Delay 和TCP keepalive . . . . . . . . . . . . . . . . . . 321\n8.9.3 WriteCompleteCallback 和HighWaterMarkCallback . . . . . . . 322\n8.10 多线程TcpServer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 324\n8.11 Connector . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327\n8.12 TcpClient . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 332\n8.13 epoll . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333\n8.14 测试程序一览. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 336\n第3部分 工程实践经验谈337\n第9章 分布式系统工程实践339\n9.1 我们在技术浪潮中的位置. . . . . . . . . . . . . . . . . . . . . . . . . . . 341\n9.1.1 分布式系统的本质困难. . . . . . . . . . . . . . . . . . . . . . . . 343\n9.1.2 分布式系统是个险恶的问题. . . . . . . . . . . . . . . . . . . . . 344\n9.2 分布式系统的可靠性浅说. . . . . . . . . . . . . . . . . . . . . . . . . . . 349\n9.2.1 分布式系统的软件不要求7  24 可靠. . . . . . . . . . . . . . . . 352\n9.2.2 “能随时重启进程”作为程序设计目标. . . . . . . . . . . . . . . 354\n9.3 分布式系统中心跳协议的设计. . . . . . . . . . . . . . . . . . . . . . . . 356\n9.4 分布式系统中的进程标识. . . . . . . . . . . . . . . . . . . . . . . . . . . 360\n9.4.1 错误做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361\n9.4.2 正确做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 362\n9.4.3 TCP 协议的启示. . . . . . . . . . . . . . . . . . . . . . . . . . . . 363\n9.5 构建易于维护的分布式程序. . . . . . . . . . . . . . . . . . . . . . . . . 364\n9.6 为系统演化做准备. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 367\n9.6.1 可扩展的消息格式. . . . . . . . . . . . . . . . . . . . . . . . . . 368\n9.6.2 反面教材：ICE 的消息打包格式. . . . . . . . . . . . . . . . . . . 369\n9.7 分布式程序的自动化回归测试. . . . . . . . . . . . . . . . . . . . . . . . 370\n9.7.1 单元测试的能与不能. . . . . . . . . . . . . . . . . . . . . . . . . 370\n9.7.2 分布式系统测试的要点. . . . . . . . . . . . . . . . . . . . . . . . 373\n9.7.3 分布式系统的抽象观点. . . . . . . . . . . . . . . . . . . . . . . . 374\n9.7.4 一种自动化的回归测试方案. . . . . . . . . . . . . . . . . . . . . 375\n9.7.5 其他用处. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 379\n9.8 分布式系统部署、监控与进程管理的几重境界. . . . . . . . . . . . . . . 380\n9.8.1 境界1：全手工操作. . . . . . . . . . . . . . . . . . . . . . . . . 382\n9.8.2 境界2：使用零散的自动化脚本和第三方组件. . . . . . . . . . . 383\n9.8.3 境界3：自制机群管理系统，集中化配置. . . . . . . . . . . . . 386\n9.8.4 境界4：机群管理与naming service 结合. . . . . . . . . . . . . 389\n第10章 C++ 编译链接模型精要391\n10.1 C 语言的编译模型及其成因. . . . . . . . . . . . . . . . . . . . . . . . . 394\n10.1.1 为什么C 语言需要预处理. . . . . . . . . . . . . . . . . . . . . . 395\n10.1.2 C 语言的编译模型. . . . . . . . . . . . . . . . . . . . . . . . . . . 398\n10.2 C++ 的编译模型. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399\n10.2.1 单遍编译. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399\n10.2.2 前向声明. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 402\n10.3 C++ 链接（linking） . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 404\n10.3.1 函数重载. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 406\n10.3.2 inline 函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 407\n10.3.3 模板. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 409\n10.3.4 虚函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 414\n10.4 工程项目中头文件的使用规则. . . . . . . . . . . . . . . . . . . . . . . . 415\n10.4.1 头文件的害处. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 416\n10.4.2 头文件的使用规则. . . . . . . . . . . . . . . . . . . . . . . . . . 417\n10.5 工程项目中库文件的组织原则. . . . . . . . . . . . . . . . . . . . . . . . 418\n10.5.1 动态库是有害的. . . . . . . . . . . . . . . . . . . . . . . . . . . . 423\n10.5.2 静态库也好不到哪儿去. . . . . . . . . . . . . . . . . . . . . . . . 424\n10.5.3 源码编译是王道. . . . . . . . . . . . . . . . . . . . . . . . . . . . 428\n第11章 反思C++ 面向对象与虚函数429\n11.1 朴实的C++ 设计. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 429\n11.2 程序库的二进制兼容性. . . . . . . . . . . . . . . . . . . . . . . . . . . . 431\n11.2.1 什么是二进制兼容性. . . . . . . . . . . . . . . . . . . . . . . . . 432\n11.2.2 有哪些情况会破坏库的ABI . . . . . . . . . . . . . . . . . . . . . 433\n11.2.3 哪些做法多半是安全的. . . . . . . . . . . . . . . . . . . . . . . . 435\n11.2.4 反面教材：COM . . . . . . . . . . . . . . . . . . . . . . . . . . . 435\n11.2.5 解决办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 436\n11.3 避免使用虚函数作为库的接口. . . . . . . . . . . . . . . . . . . . . . . . 436\n11.3.1 C++ 程序库的作者的生存环境. . . . . . . . . . . . . . . . . . . . 437\n11.3.2 虚函数作为库的接口的两大用途. . . . . . . . . . . . . . . . . . 438\n11.3.3 虚函数作为接口的弊端. . . . . . . . . . . . . . . . . . . . . . . . 439\n11.3.4 假如Linux 系统调用以COM 接口方式实现. . . . . . . . . . . . 442\n11.3.5 Java 是如何应对的. . . . . . . . . . . . . . . . . . . . . . . . . . 443\n11.4 动态库接口的推荐做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . 443\n11.5 以boost::function 和boost::bind 取代虚函数. . . . . . . . . . . . . 447\n11.5.1 基本用途. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 450\n11.5.2 对程序库的影响. . . . . . . . . . . . . . . . . . . . . . . . . . . . 451\n11.5.3 对面向对象程序设计的影响. . . . . . . . . . . . . . . . . . . . . 453\n11.6 iostream 的用途与局限. . . . . . . . . . . . . . . . . . . . . . . . . . . . 457\n11.6.1 stdio 格式化输入输出的缺点. . . . . . . . . . . . . . . . . . . . . 457\n11.6.2 iostream 的设计初衷. . . . . . . . . . . . . . . . . . . . . . . . . 461\n11.6.3 iostream 与标准库其他组件的交互. . . . . . . . . . . . . . . . . 463\n11.6.4 iostream 在使用方面的缺点. . . . . . . . . . . . . . . . . . . . . 464\n11.6.5 iostream 在设计方面的缺点. . . . . . . . . . . . . . . . . . . . . 468\n11.6.6 一个300 行的memory buffer output stream . . . . . . . . . . . 476\n11.6.7 现实的C++ 程序如何做文件IO . . . . . . . . . . . . . . . . . . . 480\n11.7 值语义与数据抽象. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482\n11.7.1 什么是值语义. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482\n11.7.2 值语义与生命期. . . . . . . . . . . . . . . . . . . . . . . . . . . . 483\n11.7.3 值语义与标准库. . . . . . . . . . . . . . . . . . . . . . . . . . . . 488\n11.7.4 值语义与C++ 语言. . . . . . . . . . . . . . . . . . . . . . . . . . 488\n11.7.5 什么是数据抽象. . . . . . . . . . . . . . . . . . . . . . . . . . . . 490\n11.7.6 数据抽象所需的语言设施. . . . . . . . . . . . . . . . . . . . . . 493\n11.7.7 数据抽象的例子. . . . . . . . . . . . . . . . . . . . . . . . . . . . 495\n第12章 C++ 经验谈501\n12.1 用异或来交换变量是错误的. . . . . . . . . . . . . . . . . . . . . . . . . 501\n12.1.1 编译器会分别生成什么代码. . . . . . . . . . . . . . . . . . . . . 503\n12.1.2 为什么短的代码不一定快. . . . . . . . . . . . . . . . . . . . . . 505\n12.2 不要重载全局::operator new() . . . . . . . . . . . . . . . . . . . . . . 507\n12.2.1 内存管理的基本要求. . . . . . . . . . . . . . . . . . . . . . . . . 507\n12.2.2 重载::operator new() 的理由. . . . . . . . . . . . . . . . . . . 508\n12.2.3 ::operator new() 的两种重载方式. . . . . . . . . . . . . . . . . 508\n12.2.4 现实的开发环境. . . . . . . . . . . . . . . . . . . . . . . . . . . . 509\n12.2.5 重载::operator new() 的困境. . . . . . . . . . . . . . . . . . . 510\n12.2.6 解决办法：替换malloc() . . . . . . . . . . . . . . . . . . . . . . 512\n12.2.7 为单独的class 重载::operator new() 有问题吗. . . . . . . . . 513\n12.2.8 有必要自行定制内存分配器吗. . . . . . . . . . . . . . . . . . . . 513\n12.3 带符号整数的除法与余数. . . . . . . . . . . . . . . . . . . . . . . . . . . 514\n12.3.1 语言标准怎么说. . . . . . . . . . . . . . . . . . . . . . . . . . . . 515\n12.3.2 C\/C++ 编译器的表现. . . . . . . . . . . . . . . . . . . . . . . . . 516\n12.3.3 其他语言的规定. . . . . . . . . . . . . . . . . . . . . . . . . . . . 516\n12.3.4 脚本语言解释器代码. . . . . . . . . . . . . . . . . . . . . . . . . 517\n12.3.5 硬件实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521\n12.4 在单元测试中mock 系统调用. . . . . . . . . . . . . . . . . . . . . . . . 522\n12.4.1 系统函数的依赖注入. . . . . . . . . . . . . . . . . . . . . . . . . 522\n12.4.2 链接期垫片（link seam） . . . . . . . . . . . . . . . . . . . . . . 524\n12.5 慎用匿名namespace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 526\n12.5.1 C 语言的static 关键字的两种用法. . . . . . . . . . . . . . . . . 526\n12.5.2 C++ 语言的static 关键字的四种用法. . . . . . . . . . . . . . . . 526\n12.5.3 匿名namespace 的不利之处. . . . . . . . . . . . . . . . . . . . . 527\n12.5.4 替代办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 529\n12.6 采用有利于版本管理的代码格式. . . . . . . . . . . . . . . . . . . . . . . 529\n12.6.1 对diff 友好的代码格式. . . . . . . . . . . . . . . . . . . . . . . . 530\n12.6.2 对grep 友好的代码风格. . . . . . . . . . . . . . . . . . . . . . . 537\n12.6.3 一切为了效率. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 538\n12.7 再探std::string . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539\n12.7.1 直接拷贝（eager copy） . . . . . . . . . . . . . . . . . . . . . . . 540\n12.7.2 写时复制（copy-on-write） . . . . . . . . . . . . . . . . . . . . . 542\n12.7.3 短字符串优化（SSO） . . . . . . . . . . . . . . . . . . . . . . . . 543\n12.8 用STL algorithm 轻松解决几道算法面试题. . . . . . . . . . . . . . . . 546\n12.8.1 用next_permutation() 生成排列与组合. . . . . . . . . . . . . . 546\n12.8.2 用unique() 去除连续重复空白. . . . . . . . . . . . . . . . . . . 548\n12.8.3 用{make,push,pop}_heap() 实现多路归并. . . . . . . . . . . . 549\n12.8.4 用partition() 实现“重排数组，让奇数位于偶数前面” . . . . 553\n12.8.5 用lower_bound() 查找IP 地址所属的城市. . . . . . . . . . . . . 554\n第4 部分附录559\n附录A 谈一谈网络编程学习经验561\n附录B 从《C++ Primer（第4 版）》入手学习C++ 579\n附录C 关于Boost 的看法591\n附录D 关于TCP 并发连接的几个思考题与试验593\n参考文献599","pages":"610","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s24522799.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s24522799.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s24522799.jpg"},"alt":"https:\/\/book.douban.com\/subject\/20471211\/","id":"20471211","publisher":"电子工业出版社","isbn10":"7121192829","isbn13":"9787121192821","title":"Linux多线程服务端编程","url":"https:\/\/api.douban.com\/v2\/book\/20471211","alt_title":"","author_intro":"陈硕，北京师范大学硕士，擅长C++ 多线程网络编程和实时分布式系统架构。曾在摩根士丹利IT 部门工作5 年，从事实时外汇交易系统开发。现在在美国加州硅谷某互联网大公司工作，从事大规模分布式系统的可靠性工程。编写了开源C++ 网络库muduo，参与翻译了《代码大全（ 第2 版）》和《C++ 编程规范（繁体版）》，整理了《C++ Primer （第4 版）（评注版）》，并曾多次在各地技术大会演讲。","summary":"本书主要讲述采用现代C++ 在x86-64 Linux 上编写多线程TCP 网络服务程序的主流常规技术，重点讲解一种适应性较强的多线程服务器的编程模型，即one loop per thread。这是在Linux 下以native 语言编写用户态高性能网络程序最成熟的模式，掌握之后可顺利地开发各类常见的服务端网络应用程序。本书以muduo 网络库为例，讲解这种编程模型的使用方法及注意事项。\n本书的宗旨是贵精不贵多。掌握两种基本的同步原语就可以满足各种多线程同步的功能需求，还能写出更易用的同步设施。掌握一种进程间通信方式和一种多线程网络编程模型就足以应对日常开发任务，编写运行于公司内网环境的分布式服务统。","price":"89.00元"}]}
2	{"count":20,"start":0,"total":1198604,"books":[{"rating":{"max":10,"numRaters":1850,"average":"8.9","min":0},"subtitle":"C语言描述","author":["维斯"],"pubdate":"2004-1-1","tags":[{"count":2183,"name":"数据结构","title":"数据结构"},{"count":1727,"name":"算法","title":"算法"},{"count":976,"name":"计算机","title":"计算机"},{"count":900,"name":"数据结构与算法分析","title":"数据结构与算法分析"},{"count":731,"name":"编程","title":"编程"},{"count":706,"name":"算法、数据结构","title":"算法、数据结构"},{"count":647,"name":"C","title":"C"},{"count":552,"name":"C语言","title":"C语言"}],"origin_title":"Data Structures and Algorithm Analysis in C:Second Edition","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s28015501.jpg","binding":"平装","translator":["冯舜玺"],"catalog":"第1章 引论\n1．1 本书讨论的内容\n1．2 数学知识复习\n1．2．1 指数\n1．2．2 对数\n1．2．3 级数\n1．2．4 模运算\n1. 2．5 证明方法\n1．3 递归简论\n总结\n练习\n参考文献\n第2章 算法分析\n2．1 数学基础\n2．2 模型\n2．3 要分析的问题\n2．4 运行时间计算\n2．4．1 一个简单的例子\n2．4．2 一般法则\n2．4．3 最大子序列和问题的解\n.2．4．4 运行时间中的对数\n2．4．5 检验你的分析\n2．4．6 分析结果的准确性\n总结\n练习\n参考文献\n第3章 表、栈和队列\n3．1 抽象数据类型(adt)\n3．2 表adt\n3．2．1 表的简单数组实现\n3．2．2 链表\n3．2．3 程序设计细节\n3．2．4 常见的错误\n3．2．5 双链表\n3．2．6 循环链表\n3．2．7 例子\n3．2．8 链表的游标实现\n3．3 栈adt\n3．3．1 栈模型\n3．3．2 栈的实现\n3．3．3 应用\n3．4 队列adt\n3．4．1 队列模型\n3．4．2 队列的数组实现\n3．4．3 队列的应用\n总结\n练习\n第4章 树\n4．1 预备知识\n4．1．1 树的实现\n4．1．2 树的遍历及应用\n4．2 二叉树\n4．2．1 实现\n4．2．2 表达式树\n4．3 查找树adt--二叉查找树\n4．3．1 makeempty\n4．3．2 find\n4．3．3 findmin和findmax\n4．3．4 insert\n4．3．5 delere\n4．3．6 平均情形分析\n4．4 avl树\n4．4．1 单旋转\n4．4．2 双旋转\n4．5 伸展树\n4．5．1 一个简单的想法\n4．5．2 展开\n4．6 树的遍历\n4．7 b-树\n总结\n练习\n参考文献\n第5章 散列\n5．1 一般想法\n5．2 散列函数\n5．3 分离链接法\n5．4 开放定址法\n5．4．1 线性探测法\n5．4．2 平方探测法\n5．4．3 双散列\n5．5 再散列\n5．6 可扩散列\n总结\n练习\n参考文献\n第6章 优先队列(堆)\n6．1 模型\n6．2 一些简单的实现\n6．3 二叉堆\n6．3．1 结构性质\n6．3．2 堆序性质\n6．3．3 基本的堆操作\n6．3．4 其他的堆操作\n6．4 优先队列的应用\n6．4．1 选择问题\n6．4．2 事件模拟\n6．5 d-堆\n6．6 左式堆\n6．6．1 左式堆的性质\n6．6．2 左式堆的操作\n6．7 斜堆\n6．8 二项队列\n6．8．1 二项队列结构\n6．8．2 二项队列操作\n6．8．3 二项队列的实现\n总结\n练习\n参考文献\n第7章 排序\n7．1 预备知识\n7．2 插入排序\n7．2．1 算法\n7．2．2 插入排序的分析\n7．3 一些简单排序算法的下界\n7. 4 希尔排序\n7．4．1 希尔排序的最坏情形分析\n7．5 堆排序\n7．5．1 堆排序的分析\n7．6 归并排序\n7．6．1 归并排序的分析\n7．7 快速排序\n7．7．1 选取枢纽元\n7．7．2 分割策略\n7．7．3 小数组\n7．7．4 实际的快速排序例程\n7．7．5 快速排序的分析\n7．7．6 选择的线性期望时间算法\n7．8 大型结构的排序\n7．9 排序的一般下界\n7．9．1 决策树\n7．10 桶式排序\n7．11 外部排序\n7．11．1 为什么需要新的算法\n7．11．2 外部排序模型\n7．11．3 简单算法\n7．11．4 多路合并\n7．11．5 多相合并\n7．11．6 替换选择\n总结\n练习\n参考文献\n第8章 不相交集adt\n8．1 等价关系\n8．2 动态等价性问题\n8．3 基本数据结构\n8．4 灵巧求并算法\n8．5 路径压缩\n8．6 按秩求并和路径压缩的最坏情形\n8．6．1 union／find算法分析\n8．7 一个应用\n总结\n练习\n参考文献\n第9章 图论算法\n9．1 若干定义\n9．1．1 图的表示\n9．2 拓扑排序\n9．3 最短路径算法\n9．3．1 无权最短路径\n9．3．2 dijkstra算法\n9．3．3 具有负边值的图\n9．3．4 无圈图\n9．3．5 所有点对最短路径\n9．4 网络流问题\n9．4．1 一个简单的最大流算法\n9．5 最小生成树\n9．5．1 prim算法\n9．5．2 kruskal算法\n9．6 深度优先搜索的应用\n9．6．1 无向图\n9．6．2 双连通性\n9．6．3 欧拉回路\n9．6．4 有向图\n9．6．5 查找强分支\n9．7 np-完全性介绍\n9．7．1 难与易\n9．7．2 np类\n9．7．3 np-完全问题\n总结\n练习\n参考文献\n第10章 算法设计技巧\n10．1 贪婪算法\n10．1．1 一个简单的调度问题\n10．1．2 huffman编码\n10．1．3 近似装箱问题\n10．2 分治算法\n10．2．1 分治算法的运行时间\n10．2．2 最近点问题\n10．2．3 选择问题\n10．2．4 一些运算问题的理论改进\n10．3 动态规划\n10．3．1 用一个表代替递归\n10．3．2 矩阵乘法的顺序安排\n10．3．3 最优二叉查找树\n10．3．4 所有点对最短路径\n10．4 随机化算法\n10．4．1 随机数发生器\n10．4．2 跳跃表\n10．4．3 素性测试\n10．5 回溯算法\n10．5．1 收费公路重建问题\n10．5．2 博弈\n总结\n练习\n参考文献\n第11章 摊还分析\n11．1 一个无关的智力问题\n11．2 二项队列\n11．3 斜堆\n11．4 斐波那契堆\n11．4．1 切除左式堆中的节点\n11．4．2 二项队列的懒惰合并\n11．4．3 斐波那契堆操作\n11．4．4 时间界的证明\n11. 5 伸展树\n总结\n练习\n参考文献\n第12章 高级数据结构及其实现\n12．1 自顶向下伸展树\n12．2 红黑树\n12．2．1 自底向上插入\n12．2．2 自顶向下红黑树\n12．2．3 自顶向下删除\n12．3 确定性跳跃表\n12．4 aa-树\n12．5 treap树\n12．6 k-d树\n12．7 配对堆\n总结\n练习\n参考文献\n索引","pages":"391","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s28015501.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s28015501.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s28015501.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1139426\/","id":"1139426","publisher":"机械工业出版社","isbn10":"711112748X","isbn13":"9787111127482","title":"数据结构与算法分析","url":"https:\/\/api.douban.com\/v2\/book\/1139426","alt_title":"Data Structures and Algorithm Analysis in C:Second Edition","author_intro":"Mark Allen Weiss，1987年在普林斯顿大学获得计算机科学博士学位，师从Robert Sedgewick (师从Knuth)，现任美国佛罗里达国际大学计算与信息科学学院教授。他曾经担任全美AP(Advanced Placement)考试计算机学科委员会的主席(2000-2004)。他的主要研究方向是数据结构、算法和教育学。","summary":"本书是《Data Structures and Algorithm Analysis in C》一书第2版的简体中译本。原书曾被评为20世纪顶尖的30部计算机著作之一，作者Mark Allen Weiss在数据结构和算法分析方面卓有建树，他的数据结构和算法分析的著作尤其畅销，并受到广泛好评．已被世界500余所大学用作教材。\n在本书中，作者更加精炼并强化了他对算法和数据结构方面创新的处理方法。通过C程序的实现，着重阐述了抽象数据类型的概念，并对算法的效率、性能和运行时间进行了分析。\n全书特点如下：\n●专用一章来讨论算法设计技巧，包括贪婪算法、分治算法、动态规划、随机化算法以及回溯算法\n●介绍了当前流行的论题和新的数据结构，如斐波那契堆、斜堆、二项队列、跳跃表和伸展树\n●安排一章专门讨论摊还分析，考查书中介绍的一些高级数据结构\n●新开辟一章讨论高级数据结构以及它们的实现，其中包括红黑树、自顶向下伸展树。treap树、k-d树、配对堆以及其他相关内容\n●合并了堆排序平均情况分析的一些新结果\n本书是国外数据结构与算法分析方面的标准教材，介绍了数据结构(大量数据的组织方法)以及算法分析(算法运行时间的估算)。本书的编写目标是同时讲授好的程序设计和算法分析技巧，使读者可以开发出具有最高效率的程序。 本书可作为高级数据结构课程或研究生一年级算法分析课程的教材，使用本书需具有一些中级程序设计知识，还需要离散数学的一些背景知识。","series":{"id":"1163","title":"计算机科学丛书"},"price":"35.00元"},{"rating":{"max":10,"numRaters":1332,"average":"8.9","min":0},"subtitle":"C语言调试指南","author":["凯尼格"],"pubdate":"2008-2-1","tags":[{"count":708,"name":"C语言","title":"C语言"},{"count":437,"name":"编程","title":"编程"},{"count":318,"name":"C","title":"C"},{"count":278,"name":"计算机","title":"计算机"},{"count":248,"name":"c","title":"c"},{"count":210,"name":"C\/C++","title":"C\/C++"},{"count":194,"name":"经典","title":"经典"},{"count":179,"name":"程序设计","title":"程序设计"}],"origin_title":"C Traps and Pitfalls","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s2870233.jpg","binding":"平装","translator":["高巍"],"catalog":"第0章　导读\n第1章　词法“陷阱”\n1.1　=不同于==\n1.2　& 和 | 不同于&& 和 ||\n1.3　词法分析中的“贪心法”\n1.4　整型常量\n1.5　字符与字符串\n第2章　语法“陷阱”\n2.1　理解函数声明\n2.2　运算符的优先级问题\n2.3　注意作为语句结束标志的分号\n2.4　switch语句\n2.5　函数调用\n2.6　“悬挂”else引发的问题\n第3章　语义“陷阱”\n3.1　指针与数组\n3.2　非数组的指针\n3.3　作为参数的数组声明\n3.4　避免“举隅法”\n3.5　空指针并非空字符串\n3.6　边界计算与不对称边界\n3.7　求值顺序\n3.8　运算符&&、|| 和 !\n3.9　整数溢出\n3.10　为函数main提供返回值\n第4章　连接\n4.1　什么是连接器\n4.2　声明与定义\n4.3　命名冲突与static修饰符\n4.4　形参、实参与返回值\n4.5　检查外部类型\n4.6　头文件\n第5章　库函数\n5.1　返回整数的getchar函数\n5.2　更新顺序文件\n5.3　缓冲输出与内存分配\n5.4　使用errno检测错误\n5.5　库函数signal\n第6章　预处理器\n6.1　不能忽视宏定义中的空格\n6.2　宏并不是函数\n6.3　宏并不是语句\n6.4　宏并不是类型定义\n第7章　可移植性缺陷\n7.1　应对C语言标准变更\n7.2　标识符名称的限制\n7.3　整数的大小\n7.4　字符是有符号整数还是无符号整数\n7.5　移位运算符\n7.6　内存位置0\n7.7　除法运算时发生的截断\n7.8　随机数的大小\n7.9　大小写转换\n7.10　首先释放，然后重新分配\n7.11　可移植性问题的一个例子\n第8章　建议与答案\n8.1　建议\n8.2　答案\n附录A　PRINTF，VARARGS与STDARG\n附录B　Koenig和Moo夫妇访谈","pages":"172","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s2870233.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s2870233.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s2870233.jpg"},"alt":"https:\/\/book.douban.com\/subject\/2778632\/","id":"2778632","publisher":"人民邮电出版社","isbn10":"7115171793","isbn13":"9787115171795","title":"C陷阱与缺陷","url":"https:\/\/api.douban.com\/v2\/book\/2778632","alt_title":"C Traps and Pitfalls","author_intro":"Andrew Koenig 是AT&T公司Shannon实验室大规模编程研究部门中的成员，同时也是C++标准委员会的项目编辑。他的编程经验超过30年，其中有15年在使用C++，他已经出版了超过150 篇和C++有关的论文，并且在世界范围内就这个主题进行过多次演讲。","summary":"作者以自己1985年在Bell实验室时发表的一篇论文为基础，结合自己的工作经验扩展成为这本对C程序员具有珍贵价值的经典著作。写作本书的出发点不是要批判C语言，而是要帮助C程序员绕过编程过程中的陷阱和障碍。..\n全书分为8章，分别从词法分析、语法语义、连接、库函数、预处理器、可移植性缺陷等几个方面分析了C编程中可能遇到的问题。最后，作者用一章的篇幅给出了若干具有实用价值的建议。..\n本书适合有一定经验的C程序员阅读学习，即便你是C编程高手，本书也应该成为你的案头必备书籍。","series":{"id":"9931","title":"C和C++经典著作"},"price":"30.00元"},{"rating":{"max":10,"numRaters":4408,"average":"9.4","min":0},"subtitle":"第 2 版·新版","author":["（美）Brian W. Kernighan","（美）Dennis M. Ritchie"],"pubdate":"2004-1","tags":[{"count":3001,"name":"C","title":"C"},{"count":2408,"name":"c语言","title":"c语言"},{"count":2131,"name":"编程","title":"编程"},{"count":1549,"name":"计算机","title":"计算机"},{"count":1291,"name":"程序设计","title":"程序设计"},{"count":1080,"name":"经典","title":"经典"},{"count":987,"name":"编程语言","title":"编程语言"},{"count":869,"name":"C\/C++","title":"C\/C++"}],"origin_title":"The C Programming Language","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1106934.jpg","binding":"平装","translator":["徐宝文","李志译","尤晋元审校"],"catalog":"出版者的话\n专家指导委员会\n中文版序\n译者序\n校译者简介\n序\n第1版序\n引言\n第1章 导言\n1.1 入门\n1.2 变量与算术表态式\n1.3 for语句\n1.4 符号常量\n1.5 字符输入\/输出\n1.6 数组\n1.7 函数\n1.8 参数——传值调用\n1.9 字符数组\n1.10 外部变量与作用域\n第2章 类型、运算符与表达式\n2.1 变量名\n2.2 数据类型及长度\n2.3 常量\n2.4 声明\n2.5 算术运算符\n2.6 关系运算符与逻辑运算符\n2.7 类型转换\n2.8 自增运算符与自减运算符\n2.9 按位运算符\n2.10 赋值运算符与表达式\n2.11 条件表达式\n2.12 运算符优先级与求值次序\n第3章 控制流\n3.1 语句与程序块\n3.2 if-else语句\n3.3 else-if语句\n3.4 switch语句\n3.5 whil循环与for特环\n3.6 do-while循环\n3.7 break语句与continue语句\n3.8 goto语句与标号\n第4章 涵数与程序结构\n第5章 指针与数组\n第6章 结构\n第7章 输入与输出\n第8章 UNIX系统接口\n附录A 参考手册\n附录B 标准库\n附录C 变更小结\n索引","pages":"258","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s1106934.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s1106934.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1106934.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1139336\/","id":"1139336","publisher":"机械工业出版社","isbn10":"7111128060","isbn13":"9787111128069","title":"C程序设计语言","url":"https:\/\/api.douban.com\/v2\/book\/1139336","alt_title":"The C Programming Language","author_intro":"Brian W. Kernighan： 贝尔实验室计算科学研究中心高级研究人员，著名的计算机科学家。他参加了UNIX系统、C语言、AWK语言和许多其他系统的开发，同时出版了许多在计算机领域具有影响的著作，如《The Elements of Programming Style》、《The Practice of Programming》、《The UNIX Programming Environment》、《The AWK Language》、《Software Tools》等。\nDennis M. Ritchie：1967年加入贝尔实验室。他和Ken L. Thompson两人共同设计并实现的C语言改变了程序设计语言发展的轨迹，是程序设计语言发展过程中的一个重要里程碑。与此同时，他们两人还设计并实现了UNIX操作系统。正是由于这两项巨大贡献，Dennis M. Ritchie于1983年获得了计算机界的最高奖——图灵奖。此外，他还获得了ACM、IEEE、贝尔实验室等授予的多种奖项.。","summary":"在计算机发展的历史上，没有哪一种程序设计语言像C语言这样应用广泛。本书原著即为C语言的设计者之一Dennis M.Ritchie和著名计算机科学家Brian W.Kernighan合著的一本介绍C语言的权威经典著作。我们现在见到的大量论述C语言程序设计的教材和专著均以此书为蓝本。原著第1版中介绍的C语言成为后来广泛使用的C语言版本——标准C的基础。人们熟知的“hello,World\"程序就是由本书首次引入的，现在，这一程序已经成为众多程序设计语言入门的第一课。\n原著第2版根据1987年制定的ANSIC标准做了适当的修订．引入了最新的语言形式，并增加了新的示例，通过简洁的描述、典型的示例，作者全面、系统、准确地讲述了C语言的各个特性以及程序设计的基本方法。对于计算机从业人员来说，《C程序设计语言》是一本必读的程序设计语 言方面的参考书。","series":{"id":"1163","title":"计算机科学丛书"},"price":"30.00元"},{"rating":{"max":10,"numRaters":132,"average":"8.5","min":0},"subtitle":"C语言描述","author":["(美)安佩尔"],"pubdate":"2006-4","tags":[{"count":306,"name":"编译原理","title":"编译原理"},{"count":115,"name":"虎书","title":"虎书"},{"count":95,"name":"C","title":"C"},{"count":83,"name":"计算机","title":"计算机"},{"count":81,"name":"计算机科学","title":"计算机科学"},{"count":60,"name":"compiler","title":"compiler"},{"count":59,"name":"编译理论","title":"编译理论"},{"count":59,"name":"编译器","title":"编译器"}],"origin_title":"Modern Compiler Implementation in C","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1852496.jpg","binding":"简裝本","translator":["赵克佳","黄春","沈志宇"],"catalog":"第一部分 编译基本原理\n第1章 绪论\n1.1 模块与接口\n1.2 工具和软件\n1.3 树语言的数据结构\n程序设计：直线式程序解释器\n推荐阅读\n习题\n第2章 词法分析\n2.1 词法单词\n2.2 正则表达式\n2.3 有限自动机\n2.4 非确定有限自动机\n2.4.1 将正则表达式转换为NFA\n2.4.2 将NFA转换为DFA\n2.5 Lex：词法分析器的生成器\n程序设计：词法分析\n推荐阅读\n习题\n第3章 语法分析\n3.1 上下文无关文法\n3.1.1 推导\n3.1.2 语法分析树\n3.1.3 二义性文法\n3.1.4 文件结束符\n3.2 预测分析\n3.2.1 FIRST集合和FOLLOW集合\n3.2.2 构造一个预测分析器\n3.2.3 消除左递归\n3.2.4 提取左因子\n3.2.5 错误恢复\n3.3 LR分析\n3.3.1 LR分析引擎\n3.3.2 LR(0)分析器生成器\n3.3.3 SLR分析器的生成\n3.3.4 LR(1)项和LR(1)分析表\n3.3.5 LALR(1)分析表\n3.3.6 各类文法的层次\n3.3.7 二义性文法的LR分析\n3.4 使用分析器的生成器\n3.4.1 冲突\n3.4.2 优先级指导\n3.4.3 语法和语义\n3.5 错误恢复\n3.5.1 用error符号恢复\n3.5.2 全局错误修复\n程序设计：语法分析\n推荐阅读\n习题\n第4章 抽象语法\n4.1 语义动作\n4.1.1 递归下降\n4.1.2 Yacc生成的分析器\n4.1.3 语义动作的解释器\n4.2 抽象语法分析树\n4.2.1 位置\n4.2.2 Tiger的抽象语法\n程序设计：抽象语法\n推荐阅读\n习题\n第5章 语义分析\n5.1 符号表\n5.1.1 多个符号表\n5.1.2 高效的命令式风格符号表\n5.1.3 高效的函数式符号表\n5.1.4 Tiger编译器的符号\n5.1.5 函数式风格的符号表\n5.2 Tiger编译器的绑定\n5.3 表达式的类型检查\n5.4 声明的类型检查\n5.4.1 变量声明\n5.4.2 类型声明\n5.4.3 函数声明\n5.4.4 递归声明\n程序设计：类型检查\n习题\n第6章 活动记录\n6.1 栈帧\n6.1.1 帧指针\n6.1.2 寄存器\n6.1.3 参数传递\n6.1.4 返回地址\n6.1.5 栈帧内的变量\n6.1.6 静态链\n6.2 Tiger编译器的栈帧\n6.2.1 栈帧描述的表示\n6.2.2 局部变量\n6.2.3 计算逃逸变量\n6.2.4 临时变量和标号\n6.2.5 两层抽象\n6.2.6 管理静态链\n6.2.7 追踪层次信息\n程序设计：栈帧\n推荐阅读\n习题\n第7章 翻译成中间代码\n7.1 中间表示树\n7.2 翻译为树中间语言\n7.2.1 表达式的种类\n7.2.2 简单变量\n7.2.3 追随静态链\n7.2.4 数组变量\n7.2.5 结构化的左值\n7.2.6 下标和域选择\n7.2.7 关于安全性的劝告\n7.2.8 算术操作\n7.2.9 条件表达式\n7.2.10 字符串\n7.2.11 记录和数组的创建\n7.2.12 while循环\n7.2.13 for循环\n7.2.14 函数调用\n7.3 声明\n7.3.1 变量定义\n7.3.2 函数定义\n7.3.3 片段\n程序设计：翻译成树\n习题\n第8章 基本块和轨迹\n8.1 规范树\n8.1.1 ESEQ的转换\n8.1.2 一般重写规则\n8.1.3 将CALL移到顶层\n8.1.4 线性语句表\n8.2 处理条件分支\n8.2.1 基本块\n8.2.2 轨迹\n8.2.3 完善\n8.2.4 最优轨迹\n推荐阅读\n习题\n第9章 指令选择\n9.1 指令选择算法\n9.1.1 Maximal Munch算法\n9.1.2 动态规划\n9.1.3 树文法\n9.1.4 快速匹配\n9.1.5 覆盖算法的效率\n9.2 CISC机器\n9.3 Tiger编译器的指令选择\n9.3.1 抽象的汇编语言指令\n9.3.2 生成汇编指令\n9.3.3 过程调用\n9.3.4 无帧指针的情形\n程序设计：指令选择\n推荐阅读\n习题\n第10章 活跃分析\n10.1 数据流方程的解\n10.1.1 活跃性计算\n10.1.2 集合的表示\n10.1.3 时间复杂度\n10.1.4 最小不动点\n10.1.5 静态活跃性与动态活跃性\n10.1.6 冲突图\n10.2 Tiger编译器的活跃分析\n10.2.1 图\n10.2.2 控制流图\n10.2.3 活跃分析\n程序设计：构造流图\n程序设计：活跃分析模块\n习题\n第11章 寄存器分配\n11.1 通过简化进行着色\n11.2 合并\n11.3 预着色的结点\n11.3.1 机器寄存器的临时副本\n11.3.2 调用者保护的寄存器和被调用者保护的寄存器\n11.3.3 含预着色结点的例子\n11.4 图着色的实现\n11.4.1 传送指令工作表的管理\n11.4.2 数据结构\n11.4.3 程序代码\n11.5 针对树的寄存器分配\n程序设计：图着色\n推荐阅读\n习题\n第12章 整合为一体\n程序设计：过程入口\/出口\n程序设计：创建一个可运行的编译器\n第二部分 高级主题\n第13章 垃圾收集\n13.1 标记-清扫式收集\n13.2 引用计数\n13.3 复制式收集\n13.4 分代收集\n13.5 增量式收集\n13.6 Baker算法\n13.7 编译器接口\n13.7.1 快速分配\n13.7.2 数据布局的描述\n13.7.3 导出指针\n程序设计：描述字\n程序设计：垃圾收集\n推荐阅读\n习题\n第14章 面向对象的语言\n14.1 类\n14.2 数据域的单继承性\n14.3 多继承性\n14.4 测试类成员关系\n14.5 私有域和私有方法\n14.6 无类语言\n14.7 向对象程序的优化\n程序设计：OBJECT Tiger\n推荐阅读\n习题\n第15章 函数式程序设计语言\n15.1 一个简单的函数式语言\n15.2 闭包\n15.3 不变的变量\n15.3.1 基于延续的……I\/O226\n15.3.2 语言上的变化\n15.3.3 纯函数式语言的优化\n15.4 内联扩展\n15.5 闭包变换\n15.6 高效的尾递归\n15.7 懒惰计算\n15.7.1 传名调用计算\n15.7.2 按需调用\n15.7.3 懒惰程序的计算\n15.7.4 懒惰函数式程序的优化\n15.7.5 严格性分析\n推荐阅读\n程序设计：编译函数式语言\n习题\n第16章 多态类型\n16.1 参数多态性\n16.1.1 显式带类型的多态语言\n16.1.2 多态类型的检查\n16.2 类型推论\n16.2.1 一个隐式类型的多态语言\n16.2.2 类型推论算法\n16.2.3 递归的数据类型\n16.2.4 Hindley Milner类型的能力\n16.3 多态变量的表示\n16.3.1 多态函数的扩展\n16.3.2 完全的装箱转换\n16.3.3 基于强制的表示分析\n16.3.4 将类型作为运行时参数传递\n16.4 静态重载的解决方法\n推荐阅读\n习题\n第17章 数据流分析\n17.1 流分析使用的中间表示\n17.2 各种数据流分析\n17.2.1 到达定值\n17.2.2 可用表达式\n17.2.3 到达表达式\n17.2.4 活跃分析\n17.3 使用数据流分析结果的几种转换\n17.3.1 公共子表达式删除\n17.3.2 常数传播\n17.3.3 复写传播\n17.3.4 死代码删除\n17.4 加快数据流分析\n17.4.1 位向量\n17.4.2 基本块\n17.4.3 结点排序\n17.4.4 使用-定值链和定值-使用链\n17.4.5 工作表算法\n17.4.6 增量式数据流分析\n17.5 别名分析\n17.5.1 基于类型的别名分析\n17.5.2 基于流的别名分析\n17.5.3 使用可能别名信息\n17.5.4 严格的纯函数式语言中的别名分析\n推荐阅读\n习题\n第18章 循环优化\n18.1 必经结点\n18.1.1 寻找必经结点的算法\n18.1.2 直接必经结点\n18.1.3 循环\n18.1.4 循环前置结点\n18.2 循环不变量计算\n18.3 归纳变量\n18.3.1 发现归纳变量\n18.3.2 强度削弱\n18.3.3 删除\n18.3.4 重写比较\n18.4 数组边界检查\n18.5 循环展开\n推荐阅读\n习题\n第19章 静态单赋值形式\n19.1 转化为SSA形式\n19.1.1 插入Φ函数的标准\n19.1.2 必经结点边界\n19.1.3 插入Φ函数\n19.1.4 变量重命名\n19.1.5 边分割\n19.2 必经结点树的高效计算\n19.2.1 深度优先生成树\n19.2.2 半必经结点\n19.2.3 Lengauer Tarjan算法\n19.3 使用SSA的优化算法\n19.3.1 死代码删除\n19.3.2 简单的常数传播\n19.3.3 条件常数传播\n19.3.4 保持必经结点性质\n19.4 数组、指针和存储器\n19.5 控制依赖图\n19.6 从SSA形式转变回来\n19.7 函数式中间形式\n推荐阅读\n习题\n第20章 流水和调度\n20.1 没有资源约束时的循环调度\n20.2 有资源约束的循环流水\n20.2.1 模调度\n20.2.2 寻找最小的启动间距\n20.2.3 其他控制流\n20.2.4 编译器应该调度指令吗\n20.3 分支预测\n20.3.1 静态分支预测\n20.3.2 编译器应该预测分支吗\n推荐阅读\n习题\n第21章 存储层次\n21.1 cache的组织结构\n21.2 cache块对齐\n21.3 预取\n21.4 循环交换\n21.5 分块\n21.6 垃圾收集和存储层次\n推荐阅读\n习题\n附录 Tiger语言参考手册\n参考文献\n索引","pages":"385","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s1852496.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s1852496.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1852496.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1806974\/","id":"1806974","publisher":"人民邮电出版社","isbn10":"7115145520","isbn13":"9787115145529","title":"现代编译原理","url":"https:\/\/api.douban.com\/v2\/book\/1806974","alt_title":"Modern Compiler Implementation in C","author_intro":"","summary":"《现代编译原理:C语言描述》全面讲述了现代编译器的结构、编译算法和实现方法，是Andrew w．Apple的“虎书”——Modern Compiler Implementation——“红、蓝、绿”三序列之一。这三本书的内容基本相同。但是使用不同的语言来实现书中给出的一个编译器。本书使用的是更适合广大读者的c语言，而另外两本书分别采用ML语言和Java语言。本书的另一个特点是增加了一些其他编译原理教科书没有涉及的内容。前端增加了面向对象的程序设计语言、函数式程序设计语言等现代语言的编译实现方法，后端增加了针对现代计算机体系结构特征的一些比较成熟的优化方法。这部分内容展现了现代商业编译器需解决的一些关键问题，开拓了学生的视野，为学生未来进行更深入的研究奠定了基础。\n\n《现代编译原理:C语言描述》全面讲述了现代编译器的各个组成部分，包括词法分析、语法分析、抽象语法、语义检查、中间代码表示、指令选择、数据流分析、寄存器分配以及运行时系统等。全书分成两部分，第一部分是编译的基础知识，适用于第一门编译原理课程(一个学期)；第二部分是高级主题，包括面向对象语言和函数语言、垃圾收集、循环优化、ssA(静态单赋值)形式、循环调度、存储结构优化等，适合于后续课程或研究生教学。书中专门为学生提供了一个用C语言编写的实习项目，包括前端和后端设计，学生可以在一学期内创建一个功能完整的编译器。","series":{"id":"18507","title":"图灵计算机科学丛书"},"price":"45.00元"},{"rating":{"max":10,"numRaters":137,"average":"9.1","min":0},"subtitle":"编写高质量C语言代码","author":["Steve Maguire"],"pubdate":"2009.2","tags":[{"count":297,"name":"编程","title":"编程"},{"count":250,"name":"C","title":"C"},{"count":153,"name":"C语言","title":"C语言"},{"count":102,"name":"程序设计","title":"程序设计"},{"count":100,"name":"计算机","title":"计算机"},{"count":81,"name":"Programming","title":"Programming"},{"count":71,"name":"C\/C++","title":"C\/C++"},{"count":67,"name":"经典","title":"经典"}],"origin_title":"Writing Solid Code","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s3529626.jpg","binding":"","translator":[],"catalog":"1 a hypothetical compiler\n2 assert yourself\n3 fortify your subsystems\n4 step through your code\n5 candy-machine interfaces\n6 risky business\n7 treacheries of the trade\n8 the rest is attitude\nepilogue where do you go from here?\nappendix a coding checklists\nappendix b memory logging routines\nappendix c answers\nreferences\nindex","pages":"256","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s3529626.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s3529626.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s3529626.jpg"},"alt":"https:\/\/book.douban.com\/subject\/3406939\/","id":"3406939","publisher":"人民邮电出版社","isbn10":"7115193169","isbn13":"9787115193162","title":"编程精粹","url":"https:\/\/api.douban.com\/v2\/book\/3406939","alt_title":"Writing Solid Code","author_intro":"","summary":"编写高质量的、没有bug的程序，是每位程序员所追求的目标。但随着软件规模越来越大，功能日趋复杂，这一目标变得越来越困难。\n本书揭示了微软公司应对质量挑战、开发出世界级代码的技术内幕，作者在自己不断探索、实践和思考的基础上，系统总结了多年来指导微软各团队的经验，将其凝聚为许多切实可行的编程实践指导，可谓字字珠玑。正因如此，本书被公认为与《代码大全》齐名的编程技术名著，曾于1993年荣获有软件开发奥斯卡奖之称的Jolt生产效率大奖。书中内容主要针对C语言，但其中的思想对目前的各主流语言编程也完全适用。","series":{"id":"50484","title":"图灵程序设计丛书·C\/C++系列"},"price":"45.00元"},{"rating":{"max":10,"numRaters":462,"average":"8.1","min":0},"subtitle":"—C++\/C语言","author":["林锐","韩永泉"],"pubdate":"2007-5","tags":[{"count":218,"name":"C++","title":"C++"},{"count":154,"name":"编程","title":"编程"},{"count":126,"name":"C\/C++","title":"C\/C++"},{"count":104,"name":"程序设计","title":"程序设计"},{"count":78,"name":"高质量程序设计指南--C++\/c语言","title":"高质量程序设计指南--C++\/c语言"},{"count":70,"name":"计算机","title":"计算机"},{"count":70,"name":"编程风格","title":"编程风格"},{"count":61,"name":"C","title":"C"}],"origin_title":"","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s2660317.jpg","binding":"","translator":[],"catalog":"第1章  高质量软件开发之道\t11.1  软件质量基本概念\t11.1.1  如何理解软件的质量\t11.1.2  提高软件质量的基本方法\t31.1.3  “零缺陷”理念\t41.2  细说软件质量属性\t41.2.1  正确性\t41.2.2  健壮性\t51.2.3  可靠性\t51.2.4  性能\t61.2.5  易用性\t71.2.6  清晰性\t71.2.7  安全性\t71.2.8  可扩展性\t81.2.9  兼容性\t81.2.10  可移植性\t81.3  人们关注的不仅仅是质量\t91.3.1  质量、生产率和成本之间的关系\t91.3.2  软件过程改进的基本概念\t111.4  高质量软件开发的基本方法\t131.4.1  建立软件过程规范\t131.4.2  复用\t151.4.3  分而治之\t161.4.4  优化与折中\t171.4.5  技术评审\t181.4.6  测试\t191.4.7  质量保证\t211.4.8  改错\t221.5  关于软件开发的一些常识和思考\t241.5.1  有最好的编程语言吗\t241.5.2  编程是一门艺术吗\t241.5.3  编程时应该多使用技巧吗\t241.5.4  换更快的计算机还是换更快的算法\t251.5.5  错误是否应该分等级\t251.5.6  一些错误的观念\t251.6  小结\t26第2章  编程语言发展简史\t272.1  编程语言大事记\t272.2  Ada的故事\t302.3  C\/C++发展简史\t312.4  Borland与Microsoft之争\t322.5  Java阵营与Microsoft的较量\t332.6  小结\t36第3章  程序的基本概念\t373.1  程序设计语言\t373.2  语言实现\t383.3  程序库\t403.4  开发环境\t403.5  程序的工作原理\t413.6  良好的编程习惯\t42第4章  C++\/C程序设计入门\t454.1  C++\/C程序的基本概念\t454.1.1  启动函数main()\t454.1.2  命令行参数\t474.1.3  内部名称\t484.1.4  连接规范\t494.1.5  变量及其初始化\t514.1.6  C Runtime Library\t524.1.7  编译时和运行时的不同\t524.1.8  编译单元和独立编译技术\t544.2  基本数据类型和内存映像\t544.3  类型转换\t564.3.1  隐式转换\t564.3.2  强制转换\t584.4  标识符\t604.5  转义序列\t614.6  运算符\t624.7  表达式\t634.8  基本控制结构\t654.9  选择（判断）结构\t654.9.1  布尔变量与零值比较\t664.9.2  整型变量与零值比较\t674.9.3  浮点变量与零值比较\t674.9.4  指针变量与零值比较\t694.9.5  对if语句的补充说明\t704.9.6  switch结构\t704.10   循环（重复）结构\t714.10.1  for语句的循环控制变量\t724.10.2  循环语句的效率\t734.11  结构化程序设计原理\t784.12  goto\/continue\/break语句\t794.13  示例\t80第5章  C++\/C常量\t855.1  认识常量\t855.1.1  字面常量\t855.1.2  符号常量\t865.1.3  契约性常量\t875.1.4  枚举常量\t875.2  正确定义符号常量\t875.3  const与#define的比较\t885.4  类中的常量\t895.5  实际应用中如何定义常量\t90第6章  C++\/C函数设计基础\t956.1  认识函数\t956.2  函数原型和定义\t966.3  函数调用方式\t976.4  认识函数堆栈\t996.5  函数调用规范\t1006.6  函数连接规范\t1016.7  参数传递规则\t1026.8  返回值的规则\t1046.9  函数内部实现的规则\t1076.10  存储类型及作用域规则\t1096.10.1  存储类型\t1096.10.2  作用域规则\t1106.10.3  连接类型\t1116.11  递归函数\t1136.12  使用断言\t1166.13  使用const提高函数的健壮性\t1186.13.1  用const修饰函数的参数\t1186.13.2  用const修饰函数的返回值\t119第7章  C++\/C指针、数组和字符串\t1217.1  指针\t1217.1.1  指针的本质\t1217.1.2  指针的类型及其支持的运算\t1237.1.3  指针传递\t1257.2  数组\t1267.2.1  数组的本质\t1267.2.2  二维数组\t1287.2.3  数组传递\t1297.2.4  动态创建、初始化和删除数组的方法\t1317.3  字符数组、字符指针和字符串\t1337.3.1  字符数组、字符串和‘\\0’的关系\t1337.3.2  字符指针的误区\t1347.3.3  字符串拷贝和比较\t1347.4  函数指针\t1357.5  引用和指针的比较\t137第8章  C++\/C高级数据类型\t1418.1  结构（Struct）\t1418.1.1  关键字struct与class的困惑\t1418.1.2  使用struct\t1428.1.3  位域\t1458.1.4  成员对齐\t1478.2  联合（Union）\t1598.3  枚举（Enum）\t1618.4  文件\t163第9章  C++\/C编译预处理\t1659.1  文件包含\t1659.1.1  内部包含卫哨和外部包含卫哨\t1659.1.2  头文件包含的合理顺序\t1669.2  宏定义\t1669.3  条件编译\t1699.3.1  #if、#elif和#else\t1699.3.2  #ifdef 和 #ifndef\t1709.4  #error\t1719.5  #pragma\t1719.6  #和##运算符\t1719.7  预定义符号常量\t172第10章  C++\/C文件结构和程序版式\t17510.1  程序文件的目录结构\t17510.2  文件的结构\t17610.2.1  头文件的用途和结构\t17610.2.2  版权和版本信息\t17710.2.3  源文件结构\t17810.3  代码的版式\t17810.3.1  适当的空行\t17810.3.2  代码行及行内空格\t17910.3.3  长行拆分\t18010.3.4  对齐与缩进\t18110.3.5  修饰符的位置\t18210.3.6  注释风格\t18210.3.7  ADT\/UDT版式\t183第11章  C++\/C应用程序命名规则\t18511.1  共性规则\t18511.2  简单的Windows应用程序命名\t186第12章  C++面向对象程序设计方法概述\t18912.1  漫谈面向对象\t18912.2  对象的概念\t19012.3  信息隐藏与类的封装\t19112.4  类的继承特性\t19512.5  类的组合特性\t20012.6  动态特性\t20112.6.1  虚函数\t20212.6.2  抽象基类\t20212.6.3  动态绑定\t20512.6.4  运行时多态\t20712.6.5  多态数组\t20812.7  C++对象模型\t21512.7.1  对象的内存映像\t21512.7.2  隐含成员\t22412.7.3  C++编译器如何处理成员函数\t22512.7.4  C++编译器如何处理静态成员\t22512.8  小结\t226第13章  对象的初始化、拷贝和析构\t22913.1  构造函数与析构函数的起源\t22913.2  为什么需要构造函数和析构函数\t23013.3  构造函数的成员初始化列表\t23213.4  对象的构造和析构次序\t23413.5  构造函数和析构函数的调用时机\t23513.6  构造函数和赋值函数的重载\t23613.7  示例：类String的构造函数和析构函数\t23813.8  何时应该定义拷贝构造函数和拷贝赋值函数\t23913.9  示例：类String的拷贝构造函数和拷贝赋值函数\t24013.10  用偷懒的办法处理拷贝构造函数和拷贝赋值函数\t24213.11  如何实现派生类的基本函数\t243第14章  C++函数的高级特性\t24714.1  函数重载的概念\t24714.1.1  重载的起源\t24714.1.2  重载是如何实现的\t24714.1.3  当心隐式类型转换导致重载函数产生二义性\t24914.2  成员函数的重载、覆盖与隐藏\t25014.2.1  重载与覆盖\t25014.2.2  令人迷惑的隐藏规则\t25114.2.3  摆脱隐藏\t25314.3  参数的默认值\t25414.4  运算符重载\t25514.4.1  基本概念\t25514.4.2  运算符重载的特殊性\t25614.4.3  不能重载的运算符\t25714.4.4  重载++和--\t25714.5  函数内联\t25914.5.1  用函数内联取代宏\t25914.5.2  内联函数的编程风格\t26014.5.3  慎用内联\t26114.6  类型转换函数\t26114.7  const成员函数\t264第15章  C++异常处理和RTTI\t26715.1  为什么要使用异常处理\t26715.2  C++异常处理\t26815.2.1  异常处理的原理\t26815.2.2  异常类型和异常对象\t26915.2.3  异常处理的语法结构\t27015.2.4  异常的类型匹配规则\t27215.2.5  异常说明及其冲突\t27215.2.6  当异常抛出时局部对象如何释放\t27315.2.7  对象构造和析构期间的异常\t27315.2.8  如何使用好异常处理技术\t27515.2.9  C++的标准异常\t27815.3  虚函数面临的难题\t27815.4  RTTI及其构成\t28015.4.1  起源\t28015.4.2  typeid运算符\t28115.4.3  dynamic_cast<>运算符\t28315.4.4  RTTI的魅力与代价\t285第16章  内存管理\t28716.1  内存分配方式\t28716.2  常见的内存错误及其对策\t28816.3  指针参数是如何传递内存的\t28916.4  free和delete把指针怎么啦\t29116.5  动态内存会被自动释放吗\t29216.6  杜绝“野指针”\t29216.7  有了malloc\/free为什么还要new\/delete\t29316.8  malloc\/free的使用要点\t29516.9  new有3种使用方式\t29616.9.1  plain new\/delete\t29616.9.2  nothrow new\/delete\t29716.9.3  placement new\/delete\t29716.10  new\/delete的使用要点\t30016.11  内存耗尽怎么办\t30116.12  用对象模拟指针\t30216.13  泛型指针auto_ptr\t30516.14  带有引用计数的智能指针\t30616.15  智能指针作为容器元素\t310第17章  学习和使用STL\t32317.1  STL简介\t32317.2  STL头文件的分布\t32417.2.1  容器类\t32417.2.2  泛型算法\t32517.2.3  迭代器\t32517.2.4  数学运算库\t32517.2.5  通用工具\t32517.2.6  其他头文件\t32617.3  容器设计原理\t32617.3.1  内存映像\t32617.3.2  存储方式和访问方式\t32717.3.3  顺序容器和关联式容器的比较\t32817.3.4  如何遍历容器\t33117.3.5  存储空间重分配问题\t33217.3.6  什么样的对象才能作为STL容器的元素\t33317.4  迭代器\t33417.4.1  迭代器的本质\t33417.4.2  迭代器失效及其危险性\t33817.5  存储分配器\t34617.6  适配器\t34717.7  泛型算法\t35017.8  一些特殊的容器\t35417.8.1  string类\t35417.8.2  bitset并非set\t35517.8.3  节省存储空间的vector<bool>\t35717.8.4  空容器\t35817.9  STL容器特征总结\t36017.10  STL使用心得\t362附录A  C++\/C试题\t365附录B  C++\/C试题答案与评分标准\t369附录C  大学十年\t375附录D  《大学十年》后记\t393附录E  术语与缩写解释\t395参考文献\t397","pages":"394","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s2660317.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s2660317.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s2660317.jpg"},"alt":"https:\/\/book.douban.com\/subject\/2116929\/","id":"2116929","publisher":"电子工业","isbn10":"7121041146","isbn13":"9787121041143","title":"高质量程序设计指南","url":"https:\/\/api.douban.com\/v2\/book\/2116929","alt_title":"","author_intro":"林锐，国内知名的软件工程专家和研发管理咨询师。西安电子科技大学硕士，浙江大学计算机系博士。2000年7月加入上海贝尔有限公司，从事软件工程和CMM的研究推广工作。2003年7月当选为Alcatel集团技术专家。2004年初创建上海漫索计算机科技有限公司(http：／／www.chinaspis.com)，致力于创建适合国内IT企业需求的研发管理解决方案，包括方法论和软件产品。已出版著作七部。","summary":"《高质量程序设计指南:C++、C语言》(第3版)以轻松幽默的笔调向读者论述了高质量软件开发方法与C++\/C编程规范。它是作者多年从事软件开发工作的经验总结。《高质量程序设计指南:C++、C语言》(第3版)共17章，第1章到第4章重点介绍软件质量和基本的程序设计方法；第5章到第16章重点阐述 C++\/C编程风格、面向对象程序设计方法和一些技术专题；第17章阐述STL 的原理和使用方法。\n　　《高质量程序设计指南:C++、C语言》(第3版)第1版和第2版部分章节曾经在Internet上广泛流传，被国内IT企业的不少软件开发人员采用。《高质量程序设计指南:C++、C语言》(第3版)的附录C《大学十年》是作者在网上发表的一个短篇传记，文中所描述的充满激情的学习和生活态度，感染了大批莘莘学子。","price":"39.80元"},{"rating":{"max":10,"numRaters":78,"average":"9.1","min":0},"subtitle":"C语言描述","author":["韦斯(Mark Allen Weiss)"],"pubdate":"2010-8","tags":[{"count":165,"name":"数据结构","title":"数据结构"},{"count":148,"name":"算法","title":"算法"},{"count":89,"name":"计算机","title":"计算机"},{"count":63,"name":"C","title":"C"},{"count":45,"name":"Algorithms","title":"Algorithms"},{"count":41,"name":"计算机科学","title":"计算机科学"},{"count":38,"name":"编程","title":"编程"},{"count":16,"name":"数据结构与算法","title":"数据结构与算法"}],"origin_title":"Data Structures and Algorithm Analysis in C","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s4459394.jpg","binding":"平装","translator":[],"catalog":"1  Introduction  1.1. What's the Book About?  1.2. Mathematics Review    1.2.1. Exponents    1.2.2. Logarithms    1.2.3. Series    1.2.4. Modular Arithmetic    1.2.5. The P Word  1.3. A Brief Introduction to Recursion    Summary    Exercises    References2  Algorithm Analysis3  Lists, Stacks, and Queues4  Trees5  Hashing6  Priority Queues (Heaps)7  Sorting 2198  The Disjoint Set ADT9  Graph Algorithms10  Algorithm Design Techniques11  Amortized Analysis12  Advanced Data Structures and Implementation","pages":"511","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s4459394.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s4459394.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s4459394.jpg"},"alt":"https:\/\/book.douban.com\/subject\/4924153\/","id":"4924153","publisher":"机械工业出版社","isbn10":"7111312805","isbn13":"9787111312802","title":"数据结构与算法分析","url":"https:\/\/api.douban.com\/v2\/book\/4924153","alt_title":"Data Structures and Algorithm Analysis in C","author_intro":"Mark Allen Weiss 1987年在普林斯顿大学获得计算机科学博士学位。师从Roberl Sedgewick，现任美国佛罗里达国际大学计算与信息科学学院教授。他曾担任全美AP(Advanced Placement)考试计算机学科委员会主席。其主要研究方向是数据结构、算法和教育学。","summary":"《数据结构与算法分析:C语言描述》曾被评为20世纪顶尖的30部计算机著作之一，作者在数据结构和算法分析方面卓有建树，他的数据结构和算法分析的著作尤其畅销，并受到广泛好评，已被世界500余所大学选作教材。\n在《数据结构与算法分析:C语言描述》中，作者精炼并强化了他对算法和数据结构方面创新的处理方法。通过C程序的实现，着重阐述了抽象数据类型的概念，并对算法的效率、性能和运行时间进行了分析。\n《数据结构与算法分析:C语言描述》特色：着重讨论了算法设计技巧，包括贪婪算法、分治算法、动态规划、随机化算法以及回溯算法。系统介绍了当前流行的论题和新的数据结构，如斐波那契堆、斜堆、二项队列、跳跃表和伸展树。详细讨论了摊还分析，考查书中介绍的一些高级数据结构。增加了高级数据结构及其实现的内容，包括红黑树、自顶向下伸展树、treap树、k-d树、配对堆等。整合了堆排序平均情况分析的一些新结果。","series":{"id":"1895","title":"经典原版书库"},"price":"45.00元"},{"rating":{"max":10,"numRaters":1802,"average":"9.1","min":0},"subtitle":"（第五版）","author":["Stephen Prata","云巅工作室"],"pubdate":"2005-2-1","tags":[{"count":915,"name":"编程","title":"编程"},{"count":840,"name":"c","title":"c"},{"count":830,"name":"c语言","title":"c语言"},{"count":611,"name":"计算机","title":"计算机"},{"count":480,"name":"程序设计","title":"程序设计"},{"count":379,"name":"经典","title":"经典"},{"count":378,"name":"C","title":"C"},{"count":243,"name":"programming","title":"programming"}],"origin_title":"","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1308874.jpg","binding":"平装(无盘)","translator":["云巅工作室"],"catalog":"第1章 概览\n1.1 C语言的起源\n1.2 使用C语言的理由\n1.3 C语言的发展方向\n1.4 计算机工作的基本原理\n1.5 高级计算机语言和编译器\n1.6 使用C语言的7个步骤\n1.7 编程机制\n1.8 语言标准\n1.9 本书的组织结构\n1.10 本书体例\n1.11 总结\n1.12 复习题\n1.13 编程练习\n第2章 C语言概述\n2.1 C语言的一个简单实例\n2.2 实例说明\n2.3 一个简单程序的结构\n2.4 使程序可读的技巧\n2.5 更进一步\n2.6 多个函数\n2.7 调试\n2.8 关键字和保留标识符\n2.9 关键概念\n2.10 总结\n2.11 复习题\n2.12 编程练习\n第3章 数据和C\n3.1 示例程序\n3.2 变量与常量数据\n3.3 数据：数据类型关键字\n3.4 C数据类型\n3.5 使用数据类型\n3.6 参数和易犯的错误\n3.7 另一个例子：转义序列\n3.8 关键概念\n3.9 总结\n3.10 复习题\n3.11 编程练习\n第4章 字符串和格式化输入\/输出\n4.1 前导程序\n4.2 字符串简介\n4.3 常量和C预处理器\n4.4 研究和利用printf（）和scanf（）\n4.5 关键概念\n4.6 总结\n4.7 复习题\n4.8 编程练习\n第5章 运算符、表达式和语句\n5.1 循环简介\n5.2 基本运算符\n5.3 其他运算符\n5.4 表达式和语句\n5.5 类型转换\n5.6 带有参数的函数\n5.7 一个示例程序\n5.8 关键概念\n5.9 总结\n5.10 复习题\n5.11 编程练习\n第6章 C控制语句：循环\n6.1 再探while循环\n6.2 while语句\n6.4 不确定循环与计数循环\n6.5 for循环\n6.6 更多赋值运算符：+=、-=、*=、\/=和%=\n6.7 逗号运算符\n6.8 退出条件循环：do while\n6.9 选择哪种循环\n6.10 嵌套循环\n6.11 数组\n6.12 使用函数返回值的循环例子\n6.13 关键概念\n6.14 总结\n6.15 复习题\n6.16 编程练习\n第7章 C控制语句：分支和跳转\n7.1 if语句\n7.2 在if语句中添加else关键字\n7.3 获得逻辑性\n7.4 一个统计字数的程序\n7.5 条件运算符?:\n7.6 循环辅助手段：continue和break\n7.7 多重选择：switch和break\n7.8 goto语句\n7.9 关键概念\n7.10 总结\n7.11 复习题\n7.12 编程练习\n第8章 字符输入\/输出和输入确认\n8.1 单字符I\/O：getchar（）和putchar（）\n8.2 缓冲区\n8.3 终止键盘输入\n8.5 创建一个更友好的用户界面\n8.6 输入确认\n8.7 菜单浏览\n8.8 关键概念\n8.9 总结\n8.10 复习题\n8.11 编程练习\n第9章 函数\n9.1 函数概述\n9.2 ANSI C的函数原型\n9.3 递归\n9.4 多源代码文件程序的编译\n9.5 地址运算符：&\n9.6 改变调用函数中的变量\n9.7 指针简介\n9.8 关键概念\n9.9 总结\n9.10 复习题\n9.11 编程练习\n第10章 数组和指针\n10.1 数组\n10.2 多维数组\n10.3 指针和数组\n10.4 函数、数组和指针\n10.5 指针操作\n10.6 保护数组内容\n10.7 指针和多维数组\n10.8 变长数组（VLA）\n10.9 复合文字\n10.10 关键概念\n10.11 总结\n10.12 复习题\n10.13 编程练习\n第11章 字符串和字符串函数\n11.1 字符串表示和字符串I\/O\n11.2 字符串输入\n11.3 字符串输出\n11.4 自定义字符串输入\/输出函数\n11.5 字符串函数\n11.6 字符串例子：字符串排序\n11.7 ctype.h字符函数和字符串\n11.8 命令行参数\n11.9 把字符串转换为数字\n11.10 关键概念\n11.11 总结\n11.12 复习题\n11.13 编程练习\n第12章 存储类、链接和内存管理\n12.1 存储类\n12.2 存储类说明符\n12.3 存储类和函数\n12.4 随机数函数和静态变量\n12.5 掷骰子\n12.6 分配内存：malloc（）和free（）\n12.7 ANSI C的类型限定词\n12.8 关键概念\n12.9 总结\n12.10 复习题\n12.11 编程练习\n第13章 文件输入\/输出\n13.1 和文件进行通信\n13.2 标准I\/O\n13.3 一个简单的文件压缩程序\n13.4 文件I\/O：fprintf ( )、fscanf ( )、fgets ( )和fputs ( )函数\n13.5 随机存取：fseek（）和ftell（）函数\n13.6 标准I\/O内幕\n13.7 其他标准I\/O函数\n13.8 关键概念\n13.9 总结\n13.10 复习题\n13.11 编程练习\n第14章 结构和其他数据形式\n14.1 示例问题：创建图书目录\n14.2 建立结构声明\n14.3 定义结构变量\n14.4 结构数组\n14.5 嵌套结构\n14.6 指向结构的指针\n14.7 向函数传递结构信息\n14.8 把结构内容保存到文件中\n14.9 结构：下一步是什么\n14.10 联合简介\n14.11 枚举类型\n14.12 typedef简介\n14.13 奇特的声明\n14.14 函数和指针\n14.15 关键概念\n14.16 总结\n14.17 复习题\n14.18 编程练习\n第15章 位操作\n15.1 二进制数、位和字节\n15.2 其他基数\n15.3 C的位运算符\n15.4 位字段\n15.5 关键概念\n15.6 总结\n15.7 复习题\n15.8 编程练习\n第16章 C预处理器和C库\n16.1 翻译程序的第一步\n16.2 明显常量：#define\n16.3 在#define中使用参数\n16.4 宏，还是函数\n16.5 文件包含：＃include\n16.6 其他指令\n16.7 内联函数\n16.8 C库\n16.9 数学库\n16.10 通用工具库\n16.11 诊断库\n16.12 string.h库中的memcpy（）和memmove（）\n16.13 可变参数：stdarg.h\n16.14 关键概念\n16.15 总结\n16.16 复习题\n16.17 编程练习\n第17章 高级数据表示\n17.1 研究数据表示\n17.2 从数组到链表\n17.3 抽象数据类型（ADT）\n17.4 队列ADT\n17.5 用队列进行模拟\n17.6 链表与数组\n17.7 二叉搜索树\n17.8 其他说明\n17.9 关键概念\n17.10 总结\n17.11 复习题\n17.12 编程练习\n附录A 复习题答案\n附录B 参考资料","pages":"626","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s1308874.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s1308874.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1308874.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1240002\/","id":"1240002","publisher":"人民邮电出版社","isbn10":"7115130221","isbn13":"9787115130228","title":"C Primer Plus","url":"https:\/\/api.douban.com\/v2\/book\/1240002","alt_title":"","author_intro":"普拉塔，在加利福尼亚州的Kentfield的Marin学院教授天文学、物理学和程序设计课程。他在加州工业学院获得学士学位，从加州大学伯克利分校获得博士学位。他最早接触计算机，始于对星河的计算机建模。Stephen已经编写或与他人合作编写了十多本书。其中包括C++Primer Plus和Unix Prinmer Plus。","summary":"《C Primer Plus（第5版）（中文版）》共17章。第1、2章学习C语言编程所需的预备知识。第3到15章介绍了C语言的相关知识，包括数据类型、格式化输入输出、运算符、表达式、流程控制语句、函数、数组和指针、字符串操作、内存管理、位操作等等，知识内容都针对C99标准；另外，第10章强化了对指针的讨论，第12章引入了动态内存分配的概念，这些内容更加适合读者的需求。第16章和第17章讨论了C预处理器和C库函数、高级数据表示（数据结构）方面的内容。附录给出了各章后面复习题、编程练习的答案和丰富的C编程参考资料。","price":"60.00元"},{"rating":{"max":10,"numRaters":1935,"average":"9.2","min":0},"subtitle":"","author":["Peter Van Der Linden"],"pubdate":"2008-2","tags":[{"count":1196,"name":"C语言","title":"C语言"},{"count":681,"name":"编程","title":"编程"},{"count":446,"name":"计算机","title":"计算机"},{"count":405,"name":"c","title":"c"},{"count":387,"name":"C专家编程","title":"C专家编程"},{"count":364,"name":"C\/C++","title":"C\/C++"},{"count":339,"name":"C","title":"C"},{"count":302,"name":"程序设计","title":"程序设计"}],"origin_title":"Expert C Programming: Deep C Secrets","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s5886086.jpg","binding":"平装","translator":["徐波"],"catalog":"第1章 C：穿越时空的迷雾\n1.1 C语言的史前阶段\n1.2 C语言的早期体验\n1.3 标准I\/O库和C预处理器\n1.4 K&R C\n1.5 今日之ANSI C\n1.6 它很棒，但它符合标准吗\n1.7 编译限制\n1.8 ANSI C标准的结构\n1.9 阅读ANSI C标准，寻找乐趣和裨益\n1.10 “安静的改变”究竟有多少安静\n1.11 轻松一下——由编译器定义的Pragmas效果\n第2章 这不是Bug，而是语言特性\n2.1 这关语言特性何事，在Fortran里这就是Bug呀\n2.2 多做之过\n2.3 误做之过\n2.4 少做之过\n2.5 轻松一下——有些特性确实就是Bug\n2.6 参考文献\n第3章 分析C语言的声明\n3.1 只有编译器才会喜欢的语法\n3.2 声明是如何形成的\n3.3 优先级规则\n3.4 通过图表分析C语言的声明\n3.5 typedef可以成为你的朋友\n3.6 typedef int x[10]和#define x int[10]的区别\n3.7 typedef struct foo{ ... foo; }的含义\n3.8 理解所有分析过程的代码段\n3.9 轻松一下——驱动物理实体的软件\n第4章 令人震惊的事实：数组和指针并不相同\n4.1 数组并非指针\n4.2 我的代码为什么无法运行\n4.3 什么是声明，什么是定义\n4.4 使声明与定义相匹配\n4.5 数组和指针的其他区别\n4.6 轻松一下——回文的乐趣\n第5章 对链接的思考\n5.1 函数库、链接和载入\n5.2 动态链接的优点\n5.3 函数库链接的5个特殊秘密\n5.4 警惕Interpositioning\n5.5 产生链接器报告文件\n5.6 轻松一下——看看谁在说话：挑战Turing测验\n第6章 运动的诗章：运行时数据结构\n6.1 a.out及其传说\n6.2 段\n6.3 操作系统在a.out文件里干了些什么\n6.4 C语言运行时系统在a.out里干了些什么\n6.5 当函数被调用时发生了什么：过程活动记录\n6.6 auto和static关键字\n6.7 控制线程\n6.8 setjmp和longjmp\n6.9 UNIX中的堆栈段\n6.10 MS-DOS中的堆栈段\n6.11 有用的C语言工具\n6.12 轻松一下——卡耐基-梅隆大学的编程难题\n6.13 只适用于高级学员阅读的材料\n第7章 对内存的思考\n7.1 Intel 80x86系列\n7.2 Intel 80x86内存模型以及它的工作原理\n7.3 虚拟内存\n7.4 Cache存储器\n7.5 数据段和堆\n7.6 内存泄漏\n7.7 总线错误\n7.8 轻松一下——“Thing King”和“页面游戏”\n第8章 为什么程序员无法分清万圣节和圣诞节\n8.1 Portzebie度量衡系统\n8.2 根据位模式构筑图形\n8.3 在等待时类型发生了变化\n8.4 原型之痛\n8.5 原型在什么地方会失败\n8.6 不需要按回车键就能得到一个字符\n8.7 用C语言实现有限状态机\n8.8 软件比硬件更困难\n8.9 如何进行强制类型转换，为何要进行类型强制转换\n8.10 轻松一下——国际C语言混乱代码大赛\n第9章 再论数组\n9.1 什么时候数组与指针相同\n9.2 为什么会发生混淆\n9.3 为什么C语言把数组形参当作指针\n9.4 数组片段的下标\n9.5 数组和指针可交换性的总结\n9.6 C语言的多维数组\n9.7 轻松一下——软件\/硬件平衡\n第10章 再论指针\n10.1 多维数组的内存布局\n10.2 指针数组就是Iliffe向量\n10.3 在锯齿状数组上使用指针\n10.4 向函数传递一个一维数组\n10.5 使用指针向函数传递一个多维数组\n10.6 使用指针从函数返回一个数组\n10.7 使用指针创建和使用动态数组\n10.8 轻松一下——程序检验的限制\n第11章 你懂得C，所以C++不在话下\n11.1 初识OOP\n11.2 抽象——取事物的本质特性\n11.3 封装——把相关的类型、数据和函数组合在一起\n11.4 展示一些类——用户定义类型享有和预定义类型一样的权限\n11.5 访问控制\n11.6 声明\n11.7 如何调用成员函数\n11.8 继承——复用已经定义的操作\n11.9 多重继承——从两个或更多的基类派生\n11.10 重载——作用于不同类型的同一操作具有相同的名字\n11.11 C++如何进行操作符重载\n11.12 C++的输入\/输出(I\/O)\n11.13 多态——运行时绑定\n11.14 解释\n11.15 C++如何表现多态\n11.16 新奇玩意——多态\n11.17 C++的其他要点\n11.18 如果我的目标是那里，我不会从这里起步\n11.19 它或许过于复杂，但却是惟一可行的方案\n11.20 轻松一下——死亡计算机协会\n11.21 更多阅读材料\n附录A 程序员工作面试的秘密\n附录B 术语表","pages":"291","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s5886086.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s5886086.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s5886086.jpg"},"alt":"https:\/\/book.douban.com\/subject\/2377310\/","id":"2377310","publisher":"人民邮电出版社","isbn10":"7115171807","isbn13":"9787115171801","title":"C专家编程","url":"https:\/\/api.douban.com\/v2\/book\/2377310","alt_title":"Expert C Programming: Deep C Secrets","author_intro":"","summary":"《C专家编程》展示了最优秀的C程序员所使用的编码技巧，并专门开辟了一章对C++的基础知识进行了介绍。\n书中C的历史、语言特性、声明、数组、指针、链接、运行时、内存以及如何进一步学习C++等问题进行了细致的讲解和深入的分析。全书撷取几十个实例进行讲解，对C程序员具有非常高的实用价值。\n本书可以帮助有一定经验的C程序员成为C编程方面的专家，对于具备相当的C语言基础的程序员，本书可以帮助他们站在C的高度了解和学习C++。","series":{"id":"9931","title":"C和C++经典著作"},"price":"45.00元"},{"rating":{"max":10,"numRaters":154,"average":"8.8","min":0},"subtitle":"C标准库“圣经”","author":["P. J. Plauger"],"pubdate":"2009-7","tags":[{"count":228,"name":"C","title":"C"},{"count":196,"name":"C语言","title":"C语言"},{"count":103,"name":"编程","title":"编程"},{"count":102,"name":"标准库","title":"标准库"},{"count":76,"name":"计算机","title":"计算机"},{"count":76,"name":"C\/C++","title":"C\/C++"},{"count":57,"name":"程序设计","title":"程序设计"},{"count":40,"name":"库","title":"库"}],"origin_title":"","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s3820140.jpg","binding":"","translator":["卢红星","徐明亮","霍建同"],"catalog":"第0章　简介. 1\n0.1　背景知识1\n0.2　C 标准的内容 3\n0.3　库的使用7\n0.4　库的实现9\n0.5　库的测试13\n0.6　参考文献15\n0.7　习题15\n第1章　(assert.h)17\n1.1　背景知识17\n1.2　C 标准的内容18\n1.3　(assert.h) 的使用18\n1.4　(assert.h) 的实现20\n1.5　(assert.h) 的测试22\n1.6　参考文献23\n1.7　习题23\n第2章　(ctype.h) 25\n2.1　背景知识25\n2.2　C 标准的内容28\n2.3　(ctype.h) 的使用 30\n2.4　(ctype.h) 的实现 34\n2.5　(ctype.h) 的测试 42\n2.6　参考文献45\n2.7　习题45\n第3章　(errno.h) 47\n3.1　背景知识47\n3.2　C 标准的内容50\n3.3　(errno.h) 的使用 50\n3.4　(errno.h) 的实现 51\n3.5　(errno.h) 的测试 55\n3.6　参考文献55\n3.7　习题55\n第4章　(float.h)57\n4.1　背景知识57\n4.2　C 标准的内容59\n4.3　(float.h) 的使用.62\n4.4　(float.h) 的实现.64\n4.5　(float.h) 的测试.69\n4.6　参考文献71\n4.7　习题72\n第5章　(limits.h)73\n5.1　背景知识73\n5.2　C 标准的内容74\n5.3　(limits.h) 的使用75\n5.4　(limits.h) 的实现77\n5.5　(limits.h) 的测试79\n5.6　参考文献80\n5.7　习题80\n第6章　(locale.h)81\n6.1　背景知识81\n6.2　C 标准的内容84\n6.3　(locale.h) 的使用87\n6.4　(locale.h) 的实现94\n6.5　(locale.h) 的测试 123\n6.6　参考文献.123\n6.7　习题123\n第7章　(math.h)127\n7.1　背景知识.127\n7.2　C 标准的内容 130\n7.3　(math.h) 的使用 135\n7.4　(math.h) 的实现 137\n7.5　(math.h) 的测试 171\n7.6　参考文献.177\n7.7　习题177\n第8章　(setjmp.h).. 181\n8.1　背景知识.181\n8.2　C 标准的内容 184\n8.3　(setjmp.h) 的使用 185\n8.4　(setjmp.h) 的实现 187\n8.5 (setjmp.h) 的测试191\n8.6 参考文献 192\n8.7 习题 192\n第9章　(signal.h) 193\n9.1　背景知识.193\n9.2　C 标准的内容 195\n9.3　(signal.h) 的使用 197\n9.4　(signal.h) 的实现 199\n9.5　(signal.h) 的测试 203\n9.6　参考文献.203\n9.7　习题203\n第10章　(stdarg.h) 205\n10.1　背景知识205\n10.2　C 标准的内容 207\n10.3　(stdarg.h) 的使用 208\n10.4　(stdarg.h) 的实现 211\n10.5　(stdarg.h) 的测试 212\n10.6　参考文献212\n10.7　习题.214\n第11章　(stddef.h) 215\n11.1　背景知识 215\n11.2　C 标准的内容 217\n11.3　(stddef.h) 的使用 217\n11.4　(stddef.h) 的实现 222\n11.5　(stddef.h) 的测试 223\n11.6　参考文献 223\n11.7　习题223\n第12章　(stdio.h) 225\n12.1　背景知识225\n12.2　C 标准的内容 233\n12.3　(stdio.h) 的使用 252\n12.4　(stdio.h) 的实现 274\n12.5　(stdio.h) 的测试 323\n12.6　参考文献325\n12.7　习题.325\n第13章　(stdlib.h) 331\n13.1　背景知识331\n13.2　C 标准的内容 332\n13.3　(stdlib.h) 的使用 342\n13.4　(stdlib.h) 的实现 351\n13.5　(stdlib.h) 的测试 379\n13.6　参考文献379\n13.7　习题.382\n第14章　(string.h) 385\n14.1　背景知识385\n14.2　C 标准的内容 386\n14.3　(string.h) 的使用 392\n14.4　(string.h) 的实现 396\n14.5　(string.h) 的测试 409\n14.6　参考文献409\n14.7　习题.409\n第15章　(time.h) 413\n15.1　背景知识413\n15.2　C 标准的内容 414\n15.3　(time.h) 的使用 418\n15.4　(time.h) 的实现 422\n15.5　(time.h) 的测试440\n15.6　参考文献441\n15.7　习题.441\n附录A　接口 443\n附录B　名字 451\n附录C　术语... 461","pages":"488","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s3820140.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s3820140.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s3820140.jpg"},"alt":"https:\/\/book.douban.com\/subject\/3775842\/","id":"3775842","publisher":"人民邮电出版社","isbn10":"7115172862","isbn13":"9787115172860","title":"C标准库","url":"https:\/\/api.douban.com\/v2\/book\/3775842","alt_title":"","author_intro":"P. J. Plauger  世界著名的软件技术专家，曾任ISO C标准委员会主席，C\/C++ User’s Journal主编，现任ISO C++标准委员会主席。他是C\/C++标准库开发领域的大师，所开发的Dinkumware标准库应用广泛。","summary":"本书是由世界级C语言专家编写的C标准库经典著作。英文版已经重印十多次，影响了几代程序员。\n本书结合C标准的相关部分，精辟地讲述了每一个库函数的使用方法和实现细节，而这正是一个真正的C程序员所必须掌握的。更重要的是，书中给出了实现和测试这些函数的完整源代码，可以让你更深入地学习C语言。不仅如此，本书还讨论了一些即使是最有经验的C程序员通常也不熟悉的知识，比如国际化和独立于区域设置的程序的编写、与构建库相关的概念和设计思想。\n本书结构清晰，内容权威，阐述精辟，对于各层次C 程序员和相关专业高校师生都是一本优秀的参考书。","series":{"id":"50484","title":"图灵程序设计丛书·C\/C++系列"},"price":"79.00元"},{"rating":{"max":10,"numRaters":808,"average":"8.6","min":0},"subtitle":"一本37.5°C的博物馆地图","author":["沈辛成"],"pubdate":"2017-5-20","tags":[{"count":588,"name":"纽约","title":"纽约"},{"count":560,"name":"博物馆","title":"博物馆"},{"count":455,"name":"旅行","title":"旅行"},{"count":370,"name":"美国","title":"美国"},{"count":337,"name":"艺术","title":"艺术"},{"count":281,"name":"城市","title":"城市"},{"count":214,"name":"历史","title":"历史"},{"count":193,"name":"生活","title":"生活"}],"origin_title":"","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s29478001.jpg","binding":"精装","translator":[],"catalog":"指南与致谢\n有点像跋的序\n第一章 你这个种族主义者\n纽约深度游线路一：黑色与白色\n第二章 没有华尔的街\n纽约深度游线路二：革命与资本\n第三章 纽约水故事\n纽约深度游线路三：饮水与思源\n第四章 我的画报你的城\n纽约深度游之四：寻根与漂流\n第五章 曼哈顿是平的\n纽约深度游之五：贫穷与富裕\n第六章 开往昨天的地铁\n纽约深度游之六：地下与地上\n第七章 美国的归美国，纽约的归纽约\n纽约深度游之七：美国与欧洲\n第八章 不知道为什么就流泪\n纽约深度游之八：战争与和平\n有点像序的跋\n附录\n附录一：一些遗珠\n附录二：纽约博物馆排名","pages":"380","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s29478001.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s29478001.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s29478001.jpg"},"alt":"https:\/\/book.douban.com\/subject\/27037182\/","id":"27037182","publisher":"中西书局","isbn10":"7547512488","isbn13":"9787547512487","title":"纽约无人是客","url":"https:\/\/api.douban.com\/v2\/book\/27037182","alt_title":"","author_intro":"沈辛成，1984年生人，非业余博物馆爱好者，走访全美八十余座博物馆，曾服务于美国自然历史博物馆、“911”国家纪念馆和纽约历史学会，参与从事档案研究、出版与策展工作。佐治亚理工学院科技史博士在读，哥伦比亚大学人类学硕士，复旦大学考古学硕士，北京大学博物馆学学士，做过独立唱作人，兼职美国时政评论。","summary":"本书为作者在纽约实地踏访数十家博物馆并进行深入了解后，对纽约博物馆展示特色、专业内涵、设计匠心及观众体验等进行多维度评价的作品。\n本书不是一本简单的博物馆导览手册，而是基于作者的个人经历和专业背景，试图阐释纽约这个五方杂处、光怪陆离却又独具特色的国际大都会的底色。全书行文从容，图文并茂，兼具知识性、实用性和可读性，无论是否去过纽约，它都会在流畅的阅读之后，带给你充足的知识与细节，同时也带给你深深的思索。","price":"39.80元"},{"rating":{"max":10,"numRaters":1399,"average":"9.0","min":0},"subtitle":"","author":["Kenneth A.Reek"],"pubdate":"2008 年4月","tags":[{"count":869,"name":"C","title":"C"},{"count":776,"name":"C语言","title":"C语言"},{"count":540,"name":"编程","title":"编程"},{"count":437,"name":"指针","title":"指针"},{"count":381,"name":"计算机","title":"计算机"},{"count":304,"name":"程序设计","title":"程序设计"},{"count":276,"name":"C\/C++","title":"C\/C++"},{"count":180,"name":"Programming","title":"Programming"}],"origin_title":"Pointers on C","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s2996168.jpg","binding":"平装","translator":["徐波"],"catalog":"第1章 快速上手\n1.1 简介\n1.1.1 空白和注释\n1.1.2 预处理指令\n1.1.3 main函数\n1.1.4 read_column_numbers函数\n1.1.5 rearrange函数\n1.2 补充说明\n1.3 编译\n1.4 总结\n1.5 警告的总结\n1.6 编程提示的总结\n1.7 问题\n1.8 编程练习\n第2章 基本概念\n2.1 环境\n2.1.1 翻译\n2.1.2 执行\n2.2 词法规则\n2.2.1 字符\n2.2.2 注释\n2.2.3 自由形式的源代码\n2.2.4 标识符\n2.2.5 程序的形式\n2.3 程序风格\n2.4 总结\n2.5 警告的总结\n2.6 编程提示的总结\n2.7 问题\n2.8 编程练习\n第3章 数据\n第4章 语句\n第5章 操作符和表达式\n第6章 指针\n第7章 函数\n第8章 数组\n第9章 字符串、字符和字节\n第10章 结构和联合\n第11章 动态内存分配\n第12章 使用结构和指针\n第13章 高级指针话题\n第14章 预处理器\n第15章 输入\/输出函数\n第16章 标准函数库\n第17章 经典抽象数据类型\n第18章 运行时环境\n附录 部分问题答案\n索引\n参考文献","pages":"448","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s2996168.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s2996168.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s2996168.jpg"},"alt":"https:\/\/book.douban.com\/subject\/3012360\/","id":"3012360","publisher":"人民邮电出版社","isbn10":"7115172013","isbn13":"9787115172013","title":"C和指针","url":"https:\/\/api.douban.com\/v2\/book\/3012360","alt_title":"Pointers on C","author_intro":"Kenneth·Reek是罗彻斯特理工大学计算机科学教授。他是一位经验丰富的C程序员，曾为多家公司担任过技术顾问。他讲授的课程有操作系统、数据通信、计算机网络、形式语言、算法分析和交换系统等。本书正是基于他9年的编程及教学的经验积累。","summary":"本书提供与C语言编程相关的全面资源和深入讨论。本书通过对指针的基础知识和高级特性的探讨，帮助程序员把指针的强大功能融入到自己的程序中去。\n全书共18章，覆盖了数据、语句、操作符和表达式、指针、函数、数组、字符串、结构和联合等几乎所有重要的C编程话题。书中给出了很多编程技巧和提示，每章后面有针对性很强的练习，附录部分则给出了部分练习的解答。\n本书适合C语言初学者和初级C程序员阅读，也可作为计算机专业学生学习C语言的参考。","series":{"id":"9931","title":"C和C++经典著作"},"price":"65.00元"},{"rating":{"max":10,"numRaters":1270,"average":"9.6","min":0},"subtitle":"-","author":["Brian W. Kernighan","Dennis M. Ritchie"],"pubdate":"1988-4-1","tags":[{"count":611,"name":"c","title":"c"},{"count":434,"name":"Programming","title":"Programming"},{"count":403,"name":"C语言","title":"C语言"},{"count":382,"name":"编程","title":"编程"},{"count":316,"name":"计算机","title":"计算机"},{"count":240,"name":"经典","title":"经典"},{"count":218,"name":"C","title":"C"},{"count":205,"name":"程序设计","title":"程序设计"}],"origin_title":"","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s29586132.jpg","binding":"Paperback","translator":[],"catalog":"","pages":"274","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s29586132.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s29586132.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s29586132.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1236999\/","id":"1236999","publisher":"Prentice Hall","isbn10":"0131103628","isbn13":"9780131103627","title":"The  C Programming Language","url":"https:\/\/api.douban.com\/v2\/book\/1236999","alt_title":"C Programming Language","author_intro":"Brian W. Kernighan works in the Computing Science Research Center at Bell Laboratories, Lucent Technologies. He is Consulting Editor for Addison-Wesley's Professional Computing Series and the author, with Dennis Ritchie, of The C Programming Language.\nDennis Ritchie is a computer scientist notable for his influence on ALTRAN, B, BCPL, C, Multics, and Unix.","summary":"Presents a complete guide to ANSI standard C language programming. Written by the developers of C, this new version helps readers keep up with the finalized ANSI standard for C while showing how to take advantage of C's rich set of operators, economy of expression, improved control flow, and data structures. This 2nd edition has been completely rewritten with additional examples and problem sets to clarify the implementation of difficult language constructs. 7 x 9 1\/4.","price":"USD 67.00"},{"rating":{"max":10,"numRaters":604,"average":"9.3","min":0},"subtitle":"第六版","author":["普拉达 (Stephen Prata)"],"pubdate":"2016-4-1","tags":[{"count":347,"name":"C语言","title":"C语言"},{"count":231,"name":"C","title":"C"},{"count":215,"name":"编程","title":"编程"},{"count":183,"name":"计算机","title":"计算机"},{"count":142,"name":"计算机科学","title":"计算机科学"},{"count":125,"name":"经典","title":"经典"},{"count":86,"name":"C++","title":"C++"},{"count":78,"name":"软件开发","title":"软件开发"}],"origin_title":"C Primer Plus : 6th","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s29438897.jpg","binding":"平装","translator":["姜佑"],"catalog":"第1章　初识C语言\t1\n1．1　C语言的起源\t1\n1．2 选择C语言的理由\t1\n1．2．1 设计特性\t1\n1．2．2 高效性\t1\n1．2．3 可移植性\t2\n1．2．4 强大而灵活\t3\n1．2．5 面向程序员\t3\n1．2．6 缺点\t3\n1．3 C语言的应用范围\t3\n1．4 计算机能做什么\t4\n1．5 高级计算机语言和编译器\t5\n1．6 语言标准\t6\n1．6．1 第1个ANSI\/ISO C标准\t6\n1．6．2 C99标准\t6\n1．6．3 C11标准\t7\n1．7 使用C语言的7个步骤\t7\n1．7．1 第1步：定义程序的目标\t8\n1．7．2 第2步：设计程序\t8\n1．7．3 第3步：编写代码\t8\n1．7．4 第4步：编译\t8\n1．7．5 第5步：运行程序\t9\n1．7．6 第6步：测试和调试程序\t9\n1．7．7 第7步：维护和修改代码\t9\n1．7．8 说明\t9\n1．8 编程机制\t10\n1．8．1 目标代码文件、可执行文件和库\t10\n1．8．2 UNIX系统\t11\n1．8．3 GNU编译器集合和LLVM项目\t13\n1．8．4 Linux系统\t13\n1．8．5 PC的命令行编译器\t14\n1．8．6 集成开发环境（Windows）\t14\n1．8．7 Windows\/Linux\t15\n1．8．8 Macintosh中的C\t15\n1．9 本书的组织结构\t15\n1．10 本书的约定\t16\n1．10．1 字体\t16\n1．10．2 程序输出\t16\n1．10．3 特殊元素\t17\n1．11 本章小结\t17\n1．12 复习题\t18\n1．13 编程练习\t18\n第2章　C语言概述\t19\n2．1 简单的C程序示例\t19\n2．2 示例解释\t20\n2．2．1 第1遍：快速概要\t21\n2．2．2 第2遍：程序细节\t21\n2．3 简单程序的结构\t28\n2．4 提高程序可读性的技巧\t28\n2．5 进一步使用C\t29\n2．5．1 程序说明\t30\n2．5．2 多条声明\t30\n2．5．3 乘法\t30\n2．5．4 打印多个值\t30\n2．6 多个函数\t30\n2．7 调试程序\t32\n2．7．1 语法错误\t32\n2．7．2 语义错误\t33\n2．7．3 程序状态\t34\n2．8 关键字和保留标识符\t34\n2．9 关键概念\t35\n2．10 本章小结\t35\n2．11 复习题\t36\n2．12 编程练习\t37\n第3章　数据和C\t39\n3．1 示例程序\t39\n3．2 变量与常量数据\t42\n3．3 数据：数据类型关键字\t42\n3．3．1 整数和浮点数\t43\n3．3．2 整数\t43\n3．3．3 浮点数\t43\n3．4 C语言基本数据类型\t44\n3．4．1 int类型\t44\n3．4．2 其他整数类型\t47\n3．4．3 使用字符：char类型\t50\n3．4．4 _Bool类型\t54\n3．4．5 可移植类型：stdint．h和inttypes．h\t55\n3．4．6 float、double和long double\t56\n3．4．7 复数和虚数类型\t60\n3．4．8 其他类型\t60\n3．4．9 类型大小\t62\n3．5 使用数据类型\t63\n3．6 参数和陷阱\t63\n3．7 转义序列示例\t64\n3．7．1 程序运行情况\t65\n3．7．2 刷新输出\t65\n3．8 关键概念\t66\n3．9 本章小结\t66\n3．10 复习题\t67\n3．11 编程练习\t68\n第4章　字符串和格式化输入\/输出\t71\n4．1 前导程序\t71\n4．2 字符串简介\t72\n4．2．1 char类型数组和null字符\t72\n4．2．2 使用字符串\t73\n4．2．3 strlen()函数\t74\n4．3 常量和C预处理器\t76\n4．3．1 const限定符\t78\n4．3．2 明示常量\t78\n4．4 printf()和scanf()\t80\n4．4．1 printf()函数\t80\n4．4．2 使用printf()\t81\n4．4．3 printf()的转换说明修饰符\t83\n4．4．4 转换说明的意义\t87\n4．4．5 使用scanf()\t92\n4．4．6 printf()和scanf()的*修饰符\t95\n4．4．7 printf()的用法提示\t97\n4．5 关键概念\t98\n4．6 本章小结\t98\n4．7 复习题\t99\n4．8 编程练习\t100\n第5章　运算符、表达式和语句\t103\n5．1 循环简介\t103\n5．2 基本运算符\t105\n5．2．1 赋值运算符：=\t105\n5．2．2 加法运算符：+\t107\n5．2．3 减法运算符：-\t107\n5．2．4 符号运算符：-和+\t107\n5．2．5 乘法运算符：*\t108\n5．2．6 除法运算符：\/\t110\n5．2．7 运算符优先级\t110\n5．2．8 优先级和求值顺序\t112\n5．3 其他运算符\t113\n5．3．1 sizeof运算符和size_t类型\t113\n5．3．2 求模运算符：%\t114\n5．3．3 递增运算符：++\t115\n5．3．4 递减运算符：--\t118\n5．3．5 优先级\t118\n5．3．6 不要自作聪明\t119\n5．4 表达式和语句\t120\n5．4．1 表达式\t120\n5．4．2 语句\t120\n5．4．3 复合语句（块）\t123\n5．5 类型转换\t124\n5．6 带参数的函数\t127\n5．7 示例程序\t129\n5．8 关键概念\t130\n5．9 本章小结\t130\n5．10 复习题\t131\n5．11 编程练习\t134\n第6章　C控制语句：循环\t137\n6．1 再探while循环\t137\n6．1．1 程序注释\t138\n6．1．2 C风格读取循环\t139\n6．2 while语句\t140\n6．2．1 终止while循环\t140\n6．2．2 何时终止循环\t141\n6．2．3 while：入口条件循环\t141\n6．2．4 语法要点\t141\n6．3 用关系运算符和表达式比较大小\t143\n6．3．1 什么是真\t144\n6．3．2 其他真值\t145\n6．3．3 真值的问题\t146\n6．3．4 新的_Bool类型\t147\n6．3．5 优先级和关系运算符\t148\n6．4 不确定循环和计数循环\t150\n6．5 for循环\t151\n6．6 其他赋值运算符：+=、-=、*=、\/=、%=\t155\n6．7 逗号运算符\t156\n6．8 出口条件循环：do while\t159\n6．9 如何选择循环\t161\n6．10 嵌套循环\t162\n6．10．1 程序分析\t163\n6．10．2 嵌套变式\t163\n6．11 数组简介\t164\n6．12 使用函数返回值的循环示例\t166\n6．12．1 程序分析\t168\n6．12．2 使用带返回值的函数\t169\n6．13 关键概念\t169\n6．14 本章小结\t170\n6．15 复习题\t170\n6．16 编程练习\t174\n第7章　C控制语句：分支和跳转\t177\n7．1 if语句\t177\n7．2 if else语句\t179\n7．2．1 另一个示例：介绍getchar()和putchar()\t180\n7．2．2 ctype．h系列的字符函数\t182\n7．2．3 多重选择else if\t184\n7．2．4 else与if配对\t186\n7．2．5 多层嵌套的if语句\t187\n7．3 逻辑运算符\t190\n7．3．1 备选拼写：iso646．h头文件\t191\n7．3．2 优先级\t192\n7．3．3 求值顺序\t192\n7．3．4 范围\t193\n7．4 一个统计单词的程序\t194\n7．5 条件运算符：?：\t196\n7．6 循环辅助：continue和break\t198\n7．6．1 continue语句\t198\n7．6．2 break语句\t200\n7．7 多重选择：switch和break\t202\n7．7．1 switch语句\t204\n7．7．2 只读每行的首字符\t205\n7．7．3 多重标签\t206\n7．7．4 switch和if else\t208\n7．8 goto语句\t208\n7．9 关键概念\t211\n7．10 本章小结\t211\n7．11 复习题\t212\n7．12 编程练习\t214\n第8章　字符输入\/输出和输入验证\t217\n8．1 单字符I\/O：getchar()和putchar()\t217\n8．2 缓冲区\t218\n8．3 结束键盘输入\t219\n8．3．1 文件、流和键盘输入\t219\n8．3．2 文件结尾\t220\n8．4 重定向和文件\t222\n8．5 创建更友好的用户界面\t226\n8．5．1 使用缓冲输入\t226\n8．5．2 混合数值和字符输入\t228\n8．6 输入验证\t230\n8．6．1 分析程序\t234\n8．6．2 输入流和数字\t234\n8．7 菜单浏览\t235\n8．7．1 任务\t235\n8．7．2 使执行更顺利\t235\n8．7．3 混合字符和数值输入\t237\n8．8 关键概念\t240\n8．9 本章小结\t240\n8．10 复习题\t241\n8．11 编程练习\t241\n第9章　函数\t243\n9．1 复习函数\t243\n9．1．1 创建并使用简单函数\t244\n9．1．2 分析程序\t245\n9．1．3 函数参数\t247\n9．1．4 定义带形式参数的函数\t248\n9．1．5 声明带形式参数函数的原型\t249\n9．1．6 调用带实际参数的函数\t249\n9．1．7 黑盒视角\t250\n9．1．8 使用return从函数中返回值\t250\n9．1．9 函数类型\t252\n9．2 ANSI C函数原型\t253\n9．2．1 问题所在\t253\n9．2．2 ANSI的解决方案\t254\n9．2．3 无参数和未指定参数\t255\n9．2．4 函数原型的优点\t256\n9．3 递归\t256\n9．3．1 演示递归\t256\n9．3．2 递归的基本原理\t258\n9．3．3 尾递归\t258\n9．3．4 递归和倒序计算\t260\n9．3．5 递归的优缺点\t262\n9．4 编译多源代码文件的程序\t262\n9．4．1 UNIX\t263\n9．4．2 Linux\t263\n9．4．3 DOS命令行编译器\t263\n9．4．4 Windows和苹果的IDE编译器\t263\n9．4．5 使用头文件\t263\n9．5 查找地址：&运算符\t267\n9．6 更改主调函数中的变量\t268\n9．7 指针简介\t269\n9．7．1 间接运算符：*\t270\n9．7．2 声明指针\t270\n9．7．3 使用指针在函数间通信\t271\n9．8 关键概念\t274\n9．9 本章小结\t275\n9．10　复习题\t275\n9．11 编程练习\t276\n第10章　数组和指针\t277\n10．1 数组\t277\n10．1．1 初始化数组\t277\n10．1．2 指定初始化器（C99）\t281\n10．1．3 给数组元素赋值\t282\n10．1．4 数组边界\t282\n10．1．5 指定数组的大小\t284\n10．2 多维数组\t284\n10．2．1 初始化二维数组\t287\n10．2．2 其他多维数组\t288\n10．3 指针和数组\t288\n10．4 函数、数组和指针\t290\n10．4．1 使用指针形参\t293\n10．4．2 指针表示法和数组表示法\t294\n10．5 指针操作\t295\n10．6 保护数组中的数据\t298\n10．6．1 对形式参数使用const\t299\n10．6．2　const的其他内容\t300\n10．7 指针和多维数组\t302\n10．7．1 指向多维数组的指针\t304\n10．7．2 指针的兼容性\t305\n10．7．3 函数和多维数组\t306\n10．8 变长数组（VLA）\t309\n10．9 复合字面量\t312\n10．10 关键概念\t314\n10．11 本章小结\t315\n10．12 复习题\t316\n10．13 编程练习\t317\n第11章　字符串和字符串函数\t321\n11．1 表示字符串和字符串I\/O\t321\n11．1．1 在程序中定义字符串\t322\n11．1．2 指针和字符串\t328\n11．2 字符串输入\t329\n11．2．1 分配空间\t329\n11．2．2 不幸的gets()函数\t330\n11．2．3 gets()的替代品\t331\n11．2．4 scanf()函数\t336\n11．3 字符串输出\t337\n11．3．1 puts()函数\t338\n11．3．2 fputs()函数\t339\n11．3．3 printf()函数\t339\n11．4 自定义输入\/输出函数\t340\n11．5 字符串函数\t342\n11．5．1 strlen()函数\t342\n11．5．2 strcat()函数\t343\n11．5．3 strncat()函数\t345\n11．5．4 strcmp()函数\t346\n11．5．5 strcpy()和strncpy()函数\t351\n11．5．6 sprintf()函数\t356\n11．5．7 其他字符串函数\t357\n11．6 字符串示例：字符串排序\t359\n11．6．1 排序指针而非字符串\t360\n11．6．2 选择排序算法\t361\n11．7 ctype．h字符函数和字符串\t362\n11．8 命令行参数\t363\n11．8．1 集成环境中的命令行参数\t365\n11．8．2 Macintosh中的命令行参数\t365\n11．9 把字符串转换为数字\t365\n11．10 关键概念\t368\n11．11 本章小结\t368\n11．12 复习题\t369\n11．13 编程练习\t371\n第12章　存储类别、链接和内存管理\t373\n12．1 存储类别\t373\n12．1．1 作用域\t374\n12．1．2 链接\t376\n12．1．3 存储期\t376\n12．1．4 自动变量\t377\n12．1．5 寄存器变量\t380\n12．1．6 块作用域的静态变量\t381\n12．1．7 外部链接的静态变量\t382\n12．1．8 内部链接的静态变量\t386\n12．1．9 多文件\t386\n12．1．10 存储类别说明符\t387\n12．1．11 存储类别和函数\t389\n12．1．12 存储类别的选择\t389\n12．2 随机数函数和静态变量\t390\n12．3 掷骰子\t393\n12．4 分配内存：malloc()和free()\t396\n12．4．1 free()的重要性\t399\n12．4．2 calloc()函数\t400\n12．4．3 动态内存分配和变长数组\t400\n12．4．4 存储类别和动态内存分配\t401\n12．5 ANSI C类型限定符\t402\n12．5．1 const类型限定符\t403\n12．5．2 volatile类型限定符\t404\n12．5．3 restrict类型限定符\t405\n12．5．4 _Atomic类型限定符（C11）\t406\n12．5．5 旧关键字的新位置\t406\n12．6　关键概念\t407\n12．7 本章小结\t407\n12．8 复习题\t408\n12．9 编程练习\t409\n第13章　文件输入\/输出\t413\n13．1 与文件进行通信\t413\n13．1．1 文件是什么\t413\n13．1．2 文本模式和二进制模式\t413\n13．1．3 I\/O的级别\t415\n13．1．4 标准文件\t415\n13．2 标准I\/O\t415\n13．2．1 检查命令行参数\t416\n13．2．2 fopen()函数\t416\n13．2．3 getc()和putc()函数\t417\n13．2．4 文件结尾\t418\n13．2．5 fclose()函数\t419\n13．2．6 指向标准文件的指针\t419\n13．3 一个简单的文件压缩程序\t419\n13．4 文件I\/O：fprintf()、fscanf()、fgets()和fputs()\t421\n13．4．1 fprintf()和fscanf()函数\t421\n13．4．2 fgets()和fputs()函数\t422\n13．5 随机访问：fseek()和ftell()\t423\n13．5．1 fseek()和ftell()的工作原理\t424\n13．5．2 二进制模式和文本模式\t425\n13．5．3 可移植性\t425\n13．5．4 fgetpos()和fsetpos()函数\t426\n13．6 标准I\/O的机理\t426\n13．7 其他标准I\/O函数\t427\n13．7．1 int ungetc(int c， FILE *fp)函数\t427\n13．7．2 int fflush()函数\t428\n13．7．3 int setvbuf()函数\t428\n13．7．4 二进制I\/O：fread()和fwrite()\t428\n13．7．5 size_t fwrite()函数\t429\n13．7．6 size_t fread()函数\t430\n13．7．7 int feof(FILE *fp)和int ferror(FILE *fp)函数\t430\n13．7．8 一个程序示例\t430\n13．7．9 用二进制I\/O进行随机访问\t433\n13．8 关键概念\t435\n13．9 本章小结\t435\n13．10 复习题\t435\n13．11 编程练习\t437\n第14章　结构和其他数据形式\t439\n14．1 示例问题：创建图书目录\t439\n14．2 建立结构声明\t441\n14．3 定义结构变量\t441\n14．3．1 初始化结构\t442\n14．3．2 访问结构成员\t443\n14．3．3 结构的初始化器\t443\n14．4 结构数组\t444\n14．4．1 声明结构数组\t446\n14．4．2 标识结构数组的成员\t447\n14．4．3 程序讨论\t447\n14．5 嵌套结构\t448\n14．6 指向结构的指针\t449\n14．6．1 声明和初始化结构指针\t450\n14．6．2 用指针访问成员\t451\n14．7 向函数传递结构的信息\t451\n14．7．1 传递结构成员\t451\n14．7．2 传递结构的地址\t452\n14．7．3 传递结构\t453\n14．7．4 其他结构特性\t454\n14．7．5 结构和结构指针的选择\t458\n14．7．6 结构中的字符数组和字符指针\t458\n14．7．7 结构、指针和malloc()\t459\n14．7．8 复合字面量和结构（C99）\t462\n14．7．9 伸缩型数组成员（C99）\t463\n14．7．10 匿名结构（C11）\t465\n14．7．11 使用结构数组的函数\t466\n14．8 把结构内容保存到文件中\t467\n14．8．1 保存结构的程序示例\t468\n14．8．2 程序要点\t470\n14．9 链式结构\t471\n14．10 联合简介\t472\n14．10．1 使用联合\t472\n14．10．2 匿名联合（C11）\t473\n14．11 枚举类型\t474\n14．11．1 enum常量\t475\n14．11．2 默认值\t475\n14．11．3 赋值\t475\n14．11．4 enum的用法\t476\n14．11．5 共享名称空间\t477\n14．12 typedef简介\t478\n14．13 其他复杂的声明\t479\n14．14 函数和指针\t481\n14．15 关键概念\t487\n14．16 本章小结\t487\n14．17 复习题\t488\n14．18 编程练习\t490\n第15章　位操作\t493\n15．1 二进制数、位和字节\t493\n15．1．1 二进制整数\t494\n15．1．2 有符号整数\t494\n15．1．3 二进制浮点数\t495\n15．2 其他进制数\t495\n15．2．1 八进制\t495\n15．2．2 十六进制\t496\n15．3 C按位运算符\t496\n15．3．1 按位逻辑运算符\t497\n15．3．2 用法：掩码\t498\n15．3．3 用法：打开位（设置位）\t498\n15．3．4 用法：关闭位（清空位）\t499\n15．3．5 用法：切换位\t499\n15．3．6 用法：检查位的值\t500\n15．3．7 移位运算符\t500\n15．3．8 编程示例\t501\n15．3．9 另一个例子\t503\n15．4 位字段\t505\n15．4．1 位字段示例\t506\n15．4．2 位字段和按位运算符\t509\n15．5 对齐特性（C11）\t515\n15．6 关键概念\t516\n15．7 本章小结\t516\n15．8 复习题\t517\n15．9 编程练习\t518\n第16章　C预处理器和C库\t521\n16．1 翻译程序的第一步\t521\n16．2 明示常量：#define\t522\n16．2．1 记号\t525\n16．2．2 重定义常量\t525\n16．3 在#define中使用参数\t525\n16．3．1 用宏参数创建字符串：#运算符\t527\n16．3．2 预处理器黏合剂：##运算符\t528\n16．3．3 变参宏：．．．和_ _VA_ARGS_ _\t529\n16．4 宏和函数的选择\t530\n16．5 文件包含：#include\t531\n16．5．1 头文件示例\t531\n16．5．2 使用头文件\t533\n16．6 其他指令\t534\n16．6．1 #undef指令\t534\n16．6．2 从C预处理器角度看已定义\t534\n16．6．3 条件编译\t535\n16．6．4 预定义宏\t539\n16．6．5 #line和#error\t540\n16．6．6 #pragma\t540\n16．6．7 泛型选择（C11）\t541\n16．7 内联函数（C99）\t542\n16．8 _Noreturn函数（C11）\t544\n16．9 C库\t544\n16．9．1 访问C库\t544\n16．9．2 使用库描述\t545\n16．10 数学库\t546\n16．10．1 三角问题\t547\n16．10．2 类型变体\t548\n16．10．3 tgmath．h库（C99）\t550\n16．11 通用工具库\t550\n16．11．1 exit()和atexit()函数\t550\n16．11．2 qsort()函数\t552\n16．12 断言库\t556\n16．12．1 assert的用法\t556\n16．12．2 _Static_assert（C11）\t557\n16．13 string．h库中的memcpy()和memmove()\t558\n16．14 可变参数：stdarg．h\t560\n16．15 关键概念\t562\n16．16 本章小结\t562\n16．17 复习题\t562\n16．18 编程练习\t563\n第17章　高级数据表示\t567\n17．1 研究数据表示\t567\n17．2 从数组到链表\t570\n17．2．1 使用链表\t572\n17．2．2 反思\t576\n17．3 抽象数据类型（ADT）\t576\n17．3．1 建立抽象\t577\n17．3．2 建立接口\t578\n17．3．3 使用接口\t581\n17．3．4 实现接口\t583\n17．4 队列ADT\t589\n17．4．1 定义队列抽象数据类型\t590\n17．4．2 定义一个接口\t590\n17．4．3 实现接口数据表示\t591\n17．4．4 测试队列\t598\n17．5 用队列进行模拟\t600\n17．6 链表和数组\t605\n17．7 二叉查找树\t608\n17．7．1 二叉树ADT\t608\n17．7．2 二叉查找树接口\t609\n17．7．3 二叉树的实现\t611\n17．7．4 使用二叉树\t624\n17．7．5 树的思想\t628\n17．8 其他说明\t629\n17．9 关键概念\t630\n17．10 本章小结\t630\n17．11 复习题\t630\n17．12 编程练习\t631\n附录A　复习题答案\t633\n附录B　参考资料\t665\nB．1 参考资料I：补充阅读\t665\nB．2 参考资料II：C运算符\t667\nB．3 参考资料III：基本类型和存储类别\t671\nB．4 参考资料IV：表达式、语句和程序流\t675\nB．5 参考资料V：新增C99和C11的ANSI C库\t679\nB．6 参考资料VI：扩展的整数类型\t714\nB．7 参考资料VII：扩展字符支持\t716\nB．8 参考资料VIII：C99\/C11数值计算增强\t720\nB．9 参考资料IX：C和C++的区别\t726","pages":"730","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s29438897.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s29438897.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s29438897.jpg"},"alt":"https:\/\/book.douban.com\/subject\/26792521\/","id":"26792521","publisher":"人民邮电出版社","isbn10":"7115390592","isbn13":"9787115390592","title":"C Primer Plus（第6版）中文版","url":"https:\/\/api.douban.com\/v2\/book\/26792521","alt_title":"C Primer Plus : 6th","author_intro":"Stephen Prata曾在加利福尼亚的马林学院（肯特菲尔德）教授天文学、物理学和程序设计课程，现已退休。他在加州理工学院获得学士学位，在加州大学伯克利分校获得博士学位。他接触程序设计，是为了利用计算机给星团建模。Stephen撰写和与他人合著了十几本书籍，其中包括C++ Primer Plus和Unix Primer Plus。","summary":"《C Primer Plus（第6版）中文版》详细讲解了C语言的基本概念和编程技巧。\n《C Primer Plus（第6版）中文版》共17章。第1、2章介绍了C语言编程的预备知识。第3~15章详细讲解了C语言的相关知识，包括数据类型、格式化输入\/输出、运算符、表达式、语句、循环、字符输入和输出、函数、数组和指针、字符和字符串函数、内存管理、文件输入输出、结构、位操作等。第16章、17章介绍C预处理器、C库和高级数据表示。本书以完整的程序为例，讲解C语言的知识要点和注意事项。每章末设计了大量复习题和编程练习，帮助读者巩固所学知识和提高实际编程能力。附录给出了各章复习题的参考答案和丰富的参考资料。\n《C Primer Plus（第6版）中文版》可作为C语言的教材，适用于需要系统学习C语言的初学者，也适用于巩固C语言知识或希望进一步提高编程技术的程序员。","series":{"id":"23545","title":"C和C++实务精选"},"price":"CNY 89.00"},{"rating":{"max":10,"numRaters":389,"average":"9.3","min":0},"subtitle":"现代方法","author":["K. N. King"],"pubdate":"2010-4","tags":[{"count":526,"name":"C语言","title":"C语言"},{"count":315,"name":"C","title":"C"},{"count":240,"name":"程序设计","title":"程序设计"},{"count":239,"name":"编程","title":"编程"},{"count":230,"name":"计算机","title":"计算机"},{"count":182,"name":"C\/C++","title":"C\/C++"},{"count":162,"name":"编程语言","title":"编程语言"},{"count":128,"name":"计算机科学","title":"计算机科学"}],"origin_title":"C Programming: A Modern Approach, Second Edition","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s4171870.jpg","binding":"平装","translator":["吕秀锋","黄倩"],"catalog":"第1章 C语言概述1\n1.1 C语言的历史1\n1.1.1 起源1\n1.1.2 标准化1\n1.1.3 基于C的语言2\n1.2 C语言的优缺点3\n1.2.1 C语言的优点3\n1.2.2 C语言的缺点3\n1.2.3 高效地使用C语言4\n问与答5\n第2章 C语言基本概念7\n2.1 编写一个简单的C程序7\n程序显示双关语7\n2.1.1 编译和链接8\n2.1.2 集成开发环境8\n2.2 简单程序的一般形式9\n2.2.1 指令9\n2.2.2 函数9\n2.2.3 语句10\n2.2.4 显示字符串10\n2.3 注释11\n2.4 变量和赋值12\n2.4.1 类型12\n2.4.2 声明13\n2.4.3 赋值13\n2.4.4 显示变量的值14\n程序计算箱子的空间重量14\n2.4.5 初始化15\n2.4.6 显示表达式的值16\n2.5 读入输入16\n程序计算箱子的空间重量（改进版）16\n2.6 定义常量的名字17\n程序华氏温度转换为摄氏温度17\n2.7 标识符18\n2.8 C程序的书写规范19\n问与答21\n练习题23\n编程题24\n第3章 格式化输入\/输出26\n3.1 printf函数26\n3.1.1 转换说明27\n程序用printf函数格式化数28\n3.1.2 转义序列28\n3.2 scanf函数29\n3.2.1 scanf函数的工作方法30\n3.2.2 格式串中的普通字符31\n3.2.3 易混淆的printf函数和scanf函数32\n程序分数相加32\n问与答33\n练习题34\n编程题35\n第4章 表达式36\n4.1 算术运算符36\n程序计算通用产品代码的校验位38\n4.2 赋值运算符39\n4.2.1 简单赋值40\n4.2.2 左值41\n4.2.3 复合赋值41\n4.3 自增运算符和自减运算符42\n4.4 表达式求值43\n4.5 表达式语句45\n问与答45\n练习题47\n编程题49\n第5章 选择语句50\n5.1 逻辑表达式50\n5.1.1 关系运算符50\n5.1.2 判等运算符51\n5.1.3 逻辑运算符51\n5.2 if语句52\n5.2.1 复合语句53\n5.2.2 else子句53\n5.2.3 级联式if语句54\n程序计算股票经纪人的佣金55\n5.2.4 “悬空else”的问题56\n5.2.5 条件表达式57\n5.2.6 C89中的布尔值58\n5.2.7 C99中的布尔值58\n5.3 switch语句59\n程序显示法定格式的日期61\n问与答62\n练习题65\n编程题67\n第6章 循环69\n6.1 while语句69\n程序显示平方表71\n程序数列求和71\n6.2 do语句72\n程序计算整数的位数73\n6.3 for语句73\n6.3.1 for语句的惯用法74\n6.3.2 在for语句中省略表达式75\n6.3.3 C99中的for语句75\n6.3.4 逗号运算符76\n程序显示平方表（改进版）77\n6.4 退出循环78\n6.4.1 break语句78\n6.4.2 continue语句78\n6.4.3 goto语句79\n程序账簿结算80\n6.5 空语句81\n问与答83\n练习题84\n编程题85\n第7章 基本类型88\n7.1 整数类型88\n7.1.1 C99中的整数类型90\n7.1.2 整数常量90\n7.1.3 C99中的整数常量91\n7.1.4 整数溢出91\n7.1.5 读\/写整数91\n程序数列求和（改进版）92\n7.2 浮点类型93\n7.2.1 浮点常量94\n7.2.2 读\/写浮点数94\n7.3 字符类型94\n7.3.1 字符操作95\n7.3.2 有符号字符和无符号字符95\n7.3.3 算术类型96\n7.3.4 转义序列96\n7.3.5 字符处理函数97\n7.3.6 用scanf和printf读\/写字符98\n7.3.7 用getchar和putchar读\/写字符98\n程序确定消息的长度99\n7.4 类型转换100\n7.4.1 常用算术转换101\n7.4.2 赋值过程中的转换102\n7.4.3 C99中的隐式转换103\n7.4.4 强制类型转换103\n7.5 类型定义105\n7.5.1 类型定义的优点105\n7.5.2 类型定义和可移植性105\n7.6 sizeof运算符106\n问与答107\n练习题109\n编程题110\n第8章 数组113\n8.1 一维数组113\n8.1.1 数组下标113\n程序数列反向115\n8.1.2 数组初始化115\n8.1.3 指定初始化式116\n程序检查数中重复出现的数字116\n8.1.4 对数组使用sizeof运算符117\n程序计算利息118\n8.2 多维数组119\n8.2.1 多维数组初始化120\n8.2.2 常量数组121\n程序发牌121\n8.3 C99中的变长数组122\n问与答123\n练习题124\n编程题125\n第9章 函数129\n9.1 函数的定义和调用129\n程序计算平均值129\n程序显示倒计数130\n程序显示双关语（改进版）131\n9.1.1 函数定义132\n9.1.2 函数调用133\n程序判定素数134\n9.2 函数声明135\n9.3 实际参数136\n9.3.1 实际参数的转换137\n9.3.2 数组型实际参数138\n9.3.3 变长数组形式参数140\n9.3.4 在数组参数声明中使用static141\n9.3.5 复合字面量141\n9.4 return语句142\n9.5 程序终止143\n9.6 递归144\n程序快速排序146\n问与答147\n练习题150\n编程题153\n第10章 程序结构155\n10.1 局部变量155\n10.1.1 静态局部变量156\n10.1.2 形式参数156\n10.2 外部变量156\n10.2.1 示例：用外部变量实现栈156\n10.2.2 外部变量的利与弊157\n程序猜数158\n10.3 程序块161\n10.4 作用域162\n10.5 构建C程序163\n程序给一手牌分类163\n问与答169\n练习题169\n编程题170\n第11章 指针172\n11.1 指针变量172\n11.2 取地址运算符和间接寻址运算符173\n11.2.1 取地址运算符173\n11.2.2 间接寻址运算符174\n11.3 指针赋值174\n11.4 指针作为参数176\n程序找出数组中的最大元素和最小元素177\n11.5 指针作为返回值179\n问与答180\n练习题181\n编程题182\n第12章 指针和数组184\n12.1 指针的算术运算184\n12.1.1 指针加上整数185\n12.1.2 指针减去整数185\n12.1.3 两个指针相减186\n12.1.4 指针比较186\n12.1.5 指向复合常量的指针186\n12.2 指针用于数组处理186\n12.3 用数组名作为指针188程序数列反向（改进版）189\n12.3.1 数组型实际参数（改进版）189\n12.3.2 用指针作为数组名191\n12.4 指针和多维数组191\n12.4.1 处理多维数组的元素191\n12.4.2 处理多维数组的行192\n12.4.3 处理多维数组的列192\n12.4.4 用多维数组名作为指针192\n12.5 C99中的指针和变长数组193\n问与答194\n练习题195\n编程题197\n第13章 字符串198\n13.1 字符串字面量198\n13.1.1 字符串字面量中的转义序列198\n13.1.2 延续字符串字面量199\n13.1.3 如何存储字符串字面量199\n13.1.4 字符串字面量的操作200\n13.1.5 字符串字面量与字符常量200\n13.2 字符串变量200\n13.2.1 初始化字符串变量201\n13.2.2 字符数组与字符指针202\n13.3 字符串的读和写203\n13.3.1 用printf函数和puts函数写字符串203\n13.3.2 用scanf函数和gets函数读字符串203\n13.3.3 逐个字符读字符串204\n13.4 访问字符串中的字符205\n13.5 使用C语言的字符串库206\n13.5.1 strcpy函数207\n13.5.2 strlen函数208\n13.5.3 strcat函数208\n13.5.4 strcmp函数209程序显示一个月的提醒列表209\n13.6 字符串惯用法211\n13.6.1 搜索字符串的结尾211\n13.6.2 复制字符串213\n13.7 字符串数组214\n程序核对行星的名字217\n问与答218\n练习题220\n编程题222\n第14章 预处理器225\n14.1 预处理器的工作原理225\n14.2 预处理指令227\n14.3 宏定义227\n14.3.1 简单的宏227\n14.3.2 带参数的宏229\n14.3.3 #运算符231\n14.3.4 ##运算符231\n14.3.5 宏的通用属性232\n14.3.6 宏定义中的圆括号233\n14.3.7 创建较长的宏233\n14.3.8 预定义宏234\n14.3.9 C99中新增的预定义宏235\n14.3.10 空的宏参数236\n14.3.11 参数个数可变的宏236\n14.3.12 __func__标识符237\n14.4 条件编译237\n14.4.1 #if指令和#endif指令238\n14.4.2 defined运算符238\n14.4.3 #ifdef指令和#ifndef指令239\n14.4.4 #elif指令和#else指令239\n14.4.5 使用条件编译240\n14.5 其他指令240\n14.5.1 #error指令240\n14.5.2 #line指令241\n14.5.3 #pragma指令242\n14.5.4 _Pragma运算符242\n问与答243\n练习题245\n第15章 编写大型程序248\n15.1 源文件248\n15.2 头文件249\n15.2.1 #include指令249\n15.2.2 共享宏定义和类型定义250\n15.2.3 共享函数原型251\n15.2.4 共享变量声明252\n15.2.5 嵌套包含253\n15.2.6 保护头文件253\n15.2.7 头文件中的#error指令254\n15.3 把程序划分成多个文件254程序文本格式化255\n15.4 构建多文件程序260\n15.4.1 makefile260\n15.4.2 链接期间的错误262\n15.4.3 重新构建程序262\n15.4.4 在程序外定义宏264\n问与答264\n练习题265\n编程题266\n第16章 结构、联合和枚举267\n16.1 结构变量267\n16.1.1 结构变量的声明267\n16.1.2 结构变量的初始化269\n16.1.3 指定初始化269\n16.1.4 对结构的操作270\n16.2 结构类型270\n16.2.1 结构标记的声明271\n16.2.2 结构类型的定义272\n16.2.3 结构作为参数和返回值272\n16.2.4 复合字面量273\n16.3 嵌套的数组和结构274\n16.3.1 嵌套的结构274\n16.3.2 结构数组274\n16.3.3 结构数组的初始化275程序维护零件数据库275\n16.4 联合281\n16.4.1 用联合来节省空间282\n16.4.2 用联合来构造混合的数据结构284\n16.4.3 为联合添加“标记字段”284\n16.5 枚举285\n16.5.1 枚举标记和类型名286\n16.5.2 枚举作为整数286\n16.5.3 用枚举声明“标记字段”286\n问与答287\n练习题289\n编程题293\n第17章 指针的高级应用294\n17.1 动态存储分配294\n17.1.1 内存分配函数294\n17.1.2 空指针295\n17.2 动态分配字符串296\n……\n第18章 声明 327\n第19章 程序设计 345\n第20章 底层程序设计 363\n第21章 标准库 377\n第22章 输入\/输出 384\n第23章 库对数值和字符数据的支持 419\n第24章 错误处理 446\n第25章 国际化特性 456\n第26章 其他库函数 482\n第27章 C99对数学计算的新增支持 503\n附录A C语言运算符 524\n附录B C99与C89的比较 525\n附录C C89与经典C的比较 529\n附录D 标准库函数 532\n附录E ASCII字符集 569\n参考文献 570\n索引 573","pages":"600","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s4171870.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s4171870.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s4171870.jpg"},"alt":"https:\/\/book.douban.com\/subject\/4279678\/","id":"4279678","publisher":"人民邮电出版社","isbn10":"7115219575","isbn13":"9787115219572","title":"C语言程序设计","url":"https:\/\/api.douban.com\/v2\/book\/4279678","alt_title":"C Programming: A Modern Approach, Second Edition","author_intro":"K. N. King 世界知名的计算机程序设计教育家，现为佐治亚州立大学数学与计算机科学系副教授。他拥有耶鲁大学计算机科学硕士学位，加州大学伯克利分校计算机科学博士学位，曾任教于佐治亚理工学院。除本书外，他还撰写了广受欢迎的著作Modula-2: A Complete Guide 和Java Programming: From the Beginning，并在Dr.Dobb's Journal等权威杂志上发表了许多文章。\n吕秀锋，亚洲理工大学（AIT）计算机软件硕士，现为北京理工大学软件学院教师。多年来一直从事“计算机基础（双语）”、“C语言程序设计（双语）”以及“程序设计开发与实践”等本科生课程的教学工作，深受学生欢迎。她还译有《数据结构与算法：C＃语言描述》一书。\n黄倩，中国科学院计算技术研究所工学博士，中国计算机学会会员。研究方向包括视频处理、视频监控等，已在知名的国际期刊和国际会议论文集上发表10篇论文。译有《编程珠玑（第2版）》一书，受到读者欢迎。","summary":"时至今日， C语言仍然是计算机领域的通用语言之一，但今天的 C语言已经和最初的时候大不相同了。本书最主要的一个目的就是通过一种“现代方法”来介绍 C语言，书中强调标准 C，强调软件工程，不再强调“手工优化”。这一版中紧密结合了 C99标准，并与 C89标准进行对照，补充了 C99中的最新特性。本书分为 C语言的基础特性、 C语言的高级特性、 C语言标准库和参考资料 4个部分。每章末尾都有一个“问与答”小节给出一系列与该章内容相关的问题及答案，此外还包含适量的习题。\n本书是为大学本科阶段的 C语言课程编写的教材，同时也非常适合作为其他课程的辅助用书。","series":{"id":"50484","title":"图灵程序设计丛书·C\/C++系列"},"price":"79.00元"},{"rating":{"max":10,"numRaters":133,"average":"8.0","min":0},"subtitle":"C语言描述","author":["Kyle Loudon"],"pubdate":"2012-8","tags":[{"count":270,"name":"算法","title":"算法"},{"count":103,"name":"C语言","title":"C语言"},{"count":79,"name":"编程","title":"编程"},{"count":63,"name":"计算机","title":"计算机"},{"count":48,"name":"计算机科学","title":"计算机科学"},{"count":38,"name":"程序设计","title":"程序设计"},{"count":34,"name":"C","title":"C"},{"count":31,"name":"Programming","title":"Programming"}],"origin_title":"Mastering Algorithms with C","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s11351454.jpg","binding":"平装","translator":["肖翔","陈舸"],"catalog":"1. 前言\n2. 第1部分 预备知识\n3. 第1章 概述\n4. 数据结构简介\n5. 算法简介\n6. 小酌软件工程\n7. 如何使用本书\n8. 第2章 指针操作\n9. 指针基础\n10. 存储空间分配\n11. 数据集合与指针的算术运算\n12. 作为函数参数的指针\n13. 泛型指针与类型转换\n14. 函数指针\n15. 问与答\n16. 相关主题\n17. 第3章 递归\n18. 基本递归\n19. 尾递归\n20. 问与答\n21. 相关主题\n22. 第4章 算法分析\n23. 最坏情况分析\n24. O表示法\n25. 计算的复杂度\n26. 实例分析：插入排序\n27. 问与答\n28. 相关主题\n29. 第2部分 数据结构\n30. 第5章 链表\n31. 单链表介绍\n32. 单链表接口的定义\n33. 单链表的实现与分析\n34. 使用链表的例子：页帧管理\n35. 双向链表介绍\n36. 双向链表接口的定义\n37. 双向链表的实现与分析\n38. 循环链表介绍\n39. 循环链表接口的定义\n40. 循环链表的实现与分析\n41. 使用循环链表的例子：第二次机会页面置换法\n42. 问与答\n43. 相关主题\n44. 第6章 栈和队列\n45. 栈的描述\n46. 栈的接口定义\n47. 栈的实现与分析\n48. 队列的描述\n49. 队列的接口定义\n50. 队列的实现与分析\n51. 队列示例：事件处理\n52. 问与答\n53. 相关主题\n54. 第7章 集合\n55. 集合介绍\n56. 集合的性质\n57. 集合接口的定义\n58. 集合抽象数据类型的实现和分析\n59. Set示例：集合覆盖\n60. 问与答\n61. 相关主题\n62. 第8章 哈希表\n63. 链式哈希表的描述\n64. 链式哈希表的接口定义\n65. 链式哈希表的实现与分析\n66. 链式哈希表的例子：符号表\n67. 开地址哈希表的描述\n68. 开地址哈希函数的接口定义\n69. 开地址哈希表的实现与分析\n70. 问与答\n71. 相关主题\n72. 第9章 树\n73. 二叉树介绍\n74. 二叉树的接口定义\n75. 二叉树的实现与分析\n76. 二叉树示例：表达式处理\n77. 二叉搜索树介绍\n78. 二叉搜索树的接口定义\n79. 二叉搜索树的实现与分析\n80. 问与答\n81. 相关主题\n82. 第10章 堆和优先队列\n83. 堆的描述\n84. 堆的接口定义\n85. 堆的实现与分析\n86. 优先队列的描述\n87. 优先队列的接口定义\n88. 优先队列的实现与分析\n89. 优先队列的示例：包裹分拣\n90. 问与答\n91. 相关主题\n92. 第11章 图\n93. 图的描述\n94. 图的接口定义\n95. 图的实现与分析\n96. 关于图的应用举例：计算网络跳数\n97. 关于图的应用举例：拓扑排序\n98. 问与答\n99. 相关主题\n100. 第3部分 算法\n101. 第12章 排序和搜索\n102. 插入排序的描述\n103. 插入排序的接口定义\n104. 插入排序的实现与分析\n105. 快速排序的描述\n106. 快速排序的接口定义\n107. 快速排序的实现与分析\n108. 快速排序的例子：目录列表\n109. 归并排序的描述\n110. 归并排序的接口定义\n111. 归并排序的实现与分析\n112. 计数排序的描述\n113. 计数排序的接口定义\n114. 计数排序的实现与分析\n115. 基数排序的描述\n116. 基数排序的接口定义\n117. 基数排序的实现与分析\n118. 二分查找的描述\n119. 二分查找的接口定义\n120. 二分查找的实现与分析\n121. 二分查找的例子：拼写检查器\n122. 问与答\n123. 相关主题\n124. 第13章 数值计算\n125. 多项式插值法\n126. 多项式插值的接口定义\n127. 多项式插值的实现与分析\n128. 最小二乘估计法\n129. 最小二乘估计的接口定义\n130. 最小二乘估计的实现和分析\n131. 方程求解介绍\n132. 方程求解的接口定义\n133. 方程求解的实现与分析\n134. 问与答\n135. 相关主题\n136. 第14章 数据压缩\n137. 位操作的描述\n138. 位操作的接口定义\n139. 位操作的实现与分析\n140. 霍夫曼编码的描述\n141. 霍夫曼编码的接口定义\n142. 霍夫曼编码的分析与实现\n143. 霍夫曼编码的例子：网络优化\n144. LZ77的描述\n145. LZ77的接口定义\n146. LZ77的实现与分析\n147. 问与答\n148. 相关主题\n149. 第15章 数据加密\n150. DES算法介绍\n151. DES的接口定义\n152. DES算法的实现和分析\n153. DES应用举例：分组加密模式\n154. RSA算法介绍\n155. RSA的接口定义\n156. RSA算法的实现与分析\n157. 问与答\n158. 相关主题\n159. 第16章 图算法\n160. 最小生成树的描述\n161. 最小生成树的接口定义\n162. 最小生成树的实现与分析\n163. 最短路径的描述\n164. 最短路径的接口定义\n165. 最短路径的实现与分析\n166. 最短路径的例子：路由表\n167. 旅行商问题的描述\n168. 旅行商问题的接口定义\n169. 旅行商问题的实现与分析\n170. 问与答\n171. 相关主题\n172. 第17章 几何算法\n173. 测试线段是否相交\n174. 测试线段是否相交的标准方法\n175. 检测线段是否相交的接口定义\n176. 检测线段是否相交的实现与分析\n177. 凸包简介\n178. Jarvis’s March\n179. 凸包的接口定义\n180. 凸包的实现与分析\n181. 球面弧长\n182. 求解球面弧长的接口定义\n183. 求解球面弧长的实现和分析\n184. 球面弧长的应用举例：地球上两点之间的近似距离\n185. 问与答\n186. 相关主题","pages":"401","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s11351454.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s11351454.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s11351454.jpg"},"alt":"https:\/\/book.douban.com\/subject\/14267904\/","id":"14267904","publisher":"机械工业出版社","isbn10":"7111394267","isbn13":"9787111394266","title":"算法精解","url":"https:\/\/api.douban.com\/v2\/book\/14267904","alt_title":"Mastering Algorithms with C","author_intro":"Kyle Loudon是美国加州洛斯加托斯Jeppesen Dataplan公司的一名软件工程师，主管图形接口开发小组，主攻航迹规划软件的研发，这些软件主要用于商业航空公司、私营航空部门和其他一些航空制造业。在来到Jeppesen之前，Kyle在IBM公司是一名系统程序员。在技术上，Kyle主要对操作系统、网络、人机交互等领域感兴趣。1992年，Kyle在普渡大学拿到了计算机科学学士学位，并取得了法语的第二学位，同时他还被选入斐陶斐荣誉学会（美国大学优等生之荣誉学会）。他在普渡大学计算机系教了三年的计算机课程。在这期间，他完成了他个人的第一本书《Understanding Computers》，这本书用理论结合实践的方式介绍计算机的方方面面。如今，尽管他继续工作在硅谷的软件业，但他仍然坚韧不拔地在追求一个更高的学位。\n除了计算机，Kyle多年来喜欢打网球、教网球。他还喜欢山地骑行、滑冰，偶尔也和朋友们一起参加高尔夫课程。另外，Kyle还喜欢各种形式的戏剧、美食，以及某些风格的音乐和艺术；他期望成为钢琴家和艺术家，但希望渺茫。他现在在Jeppesen的工作是从他1992年开始驾驶飞机之后找到的。现在，他是一个拥有美国联邦航空局颁发的商业飞行员执照的飞行员。","summary":"本书是数据结构和算法领域的经典之作，十余年来，畅销不衰！全书共分为三部分：第一部分首先介绍了数据结构和算法的概念，以及使用它们的原因和意义，然后讲解了数据结构和算法中最常用的技术——指针和递归，最后还介绍了算法的分析方法，旨在为读者学习这本书打下坚实的基础；第二部分对链表、栈、队列、集合、哈希表、堆、图等常用数据结构进行了深入阐述；第三部分对排序、搜索数值计算、数据压缩、数据加密、图算法、几何算法等经典算法进行了精辟的分析和讲解。\n本书的众多特色使得它在同类书中独树一帜：具体实现都采用正式的C语言代码而不是伪代码，在很多数据结构和算法的实现过程中，有大量细节问题是伪代码不能解决的；每一章都有精心组织的主题和应用；全部示例来自真实的应用，不只是一般的练习；对每种数据结构、算法和示例都进行了详细分析；每一章的末尾都会有一系列问题和对应的回答，旨在强调这一章的重要思想……\n本书中的代码尤为值得强调：所有实现都采用C语言编写，所有代码都优先用于教学目的，所有代码都在4种平台上经过完整测试，头文件记录了所有公共的接口，命名规则适用于全书所有的代码，所有的代码都包含大量注释……\n本书内容包括：\n· 数据结构和算法的概念，以及使用它们的原因和意义\n· 指针和递归\n· 算法分析\n· 常用数据结构：链表、栈、队列、集合、哈希表、树、堆、优先级队列以及图\n· 排序和搜索\n· 数值计算\n· 数据压缩\n· 数据加密\n· 图算法\n· 几何算法","price":"79.00元"},{"rating":{"max":10,"numRaters":266,"average":"9.4","min":0},"subtitle":"42 Specific Ways to Improve Your Use of C++11 and C++14","author":["Scott Meyers"],"pubdate":"2014-12","tags":[{"count":330,"name":"C++","title":"C++"},{"count":168,"name":"C++11","title":"C++11"},{"count":111,"name":"C\/C++","title":"C\/C++"},{"count":86,"name":"编程","title":"编程"},{"count":80,"name":"计算机","title":"计算机"},{"count":72,"name":"Programming","title":"Programming"},{"count":49,"name":"程序设计","title":"程序设计"},{"count":34,"name":"effective","title":"effective"}],"origin_title":"","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s27951196.jpg","binding":"Paperback","translator":[],"catalog":"","pages":"320","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s27951196.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s27951196.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s27951196.jpg"},"alt":"https:\/\/book.douban.com\/subject\/25923597\/","id":"25923597","publisher":"O'Reilly Media","isbn10":"1491903996","isbn13":"9781491903995","title":"Effective Modern C++","url":"https:\/\/api.douban.com\/v2\/book\/25923597","alt_title":"","author_intro":"Scott Meyers is one of the world's foremost authorities on C++. He wrote the best-selling Effective C++ series (Effective C++, More Effective C++, and Effective STL); published and maintains the annotated training materials Overview of the New C++ (C++11\/14) and Effective C++ in an Embedded Environment; is Consulting Editor for the Effective Software Development Series, and, with Herb Sutter and Andrei Alexandrescu, is a principal in C++ and Beyond. He has a Ph.D in Computer Science from Brown University. He's currently working on a new book, Effective Modern C++, which he expects to publish this fall.","summary":"Learn how to program expertly with C++ with this practical book from Scott Meyers, one of the world's foremost authorities on this systems programming language. Scott Meyers takes some of the most difficult pieces of C++ code and unfurls them so that you can see how to manipulate your own project code. This is the first book to contain content written with the C++14 standard.\nTackle 42 separate C++ problems and solutions\nLearn critical techniques for success on topics from smart pointers to lambda expressions\nUnderstand key concepts by taking the C++ 98 standard to C++ 11 and then to C++ 14","price":"USD 49.99"},{"rating":{"max":10,"numRaters":625,"average":"9.1","min":0},"subtitle":"N．C. Wyeth 插图官方授权版本","author":["[美] 玛•金•罗琳斯"],"pubdate":"2016-6-1","tags":[{"count":198,"name":"自然","title":"自然"},{"count":183,"name":"美国文学","title":"美国文学"},{"count":183,"name":"外国文学","title":"外国文学"},{"count":146,"name":"玛•金•罗琳斯","title":"玛•金•罗琳斯"},{"count":136,"name":"美国","title":"美国"},{"count":135,"name":"成长","title":"成长"},{"count":129,"name":"我想读这本书","title":"我想读这本书"},{"count":128,"name":"小说","title":"小说"}],"origin_title":"The Yearling","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28748579.jpg","binding":"平装","translator":["梅静"],"catalog":"目录\n第一章 小水车\n第二章 乔迪的家\n第三章 飞来横祸\n第四章 猎熊\n第五章 草翅膀\n第六章 大快朵颐\n第七章 一桩好买卖\n第八章 意外收获\n第九章 灰岩坑\n第十章 夜晚的奇遇\n第十一章 猎鹿\n第十二章 仗义相助\n第十三章 告别奥利弗\n第十四章 危机\n第十五章 新伙伴\n第十六章 偷蜜和猎狐\n第十七章 痛失好友\n第十八章 怀念“草翅膀”\n第十九章 暴风雨\n第二十章 暴风雨后的森林\n第二十一章 瘟疫\n第二十二章 储粮\n第二十三章 狼群的夜袭\n第二十四章 猎狼\n第二十五章圣诞节前夕\n第二十六章 追捕“大笨脚”\n第二十七章 送别\n第二十八章 孤狼\n第二十九章 闯祸\n第三十章 爸爸病了\n第三十一章 无计可施\n第三十二章 再见，小鹿\n第三十三章 别了，童年","ebook_url":"https:\/\/read.douban.com\/ebook\/22165742\/","pages":"432","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s28748579.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s28748579.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28748579.jpg"},"alt":"https:\/\/book.douban.com\/subject\/26801361\/","id":"26801361","publisher":"云南人民出版社","isbn10":"7222145583","isbn13":"9787222145580","title":"鹿苑长春","url":"https:\/\/api.douban.com\/v2\/book\/26801361","alt_title":"The Yearling","author_intro":"【作者 】\n玛•金•罗琳斯\nMarjorie Kinnan Rawlings\n1896-1953\n美国作家  生于华盛顿， 毕业于威斯康星大学， 在纽约担任多年记者、编辑\n创建了佛罗里达边远林区的“地方文学”\n先后获得普利策奖、 欧·亨利奖、兰登书屋终身畅销奖\n创作的两部长篇小说《鹿苑长春》和《十字小溪》先后荣获普利策文学奖\n代表作《鹿苑长春》《十字小溪》《一位年轻姑娘》《南方月亮下》《金苹果》等\n【绘者】\nN.C.韦思\nNewell Convers Wyeth\n1882—1956\n美国现实主义绘画大师  一生创作近4000幅画作\n画作现收藏于布兰迪万河博物馆 、波特兰艺术博物馆和法恩斯沃斯艺术博物馆。1997年，他生活和工作的地方（宾夕法尼亚州查兹福德小镇墨菲路）被美国政府指定为国家历史地标之一。\n【译者】\n梅静\n北京大学外国语学院翻译硕士\n译有《柳林风声》《小鹿斑比》《小公主》《威士忌海滩》《孪生姐妹》《想飞的乔琪》《布谷鸟的呼唤》。","summary":"【“任何人遇到挫折的时候，都能够从这里得到新的勇气。”】\n【内容简介】\n《鹿苑长春》由美国作家玛·金·罗琳斯创作于1938年，根据佛罗里达林区一位老人的童年回忆创作改编，发行后登上美国畅销书榜首并持续140周，于次年获得普利策文学奖。至今，在美国累计阅读量达到5.5亿。至今，该小说被翻译成20种语言，在133个国家出版，受到不同地域和文化人们的喜爱。在1946年被米高梅公司拍摄成电影，获得奥斯卡最佳艺术指导奖和最佳摄影奖。\n故事讲述美国南北战争后佛罗里达垦荒区普通人的劳动、斗争和悲欢离合。主人公巴克斯特一家生活在佛罗里达岛地过着自给自足的农耕狩猎生活，所处的自然美景中是一幅生动绚丽的丛林画卷，该作品后被誉为描绘少年时代的经典童年诗歌。然而，它却是一本全年龄段读本，书中透出的森林清新气息和舒缓节奏，与当代都市生活迥然不同。其中有惊险的狩猎、奇妙的自然景观、悠然的乡村美景，还有风趣幽默的人物对话，以及充满泥土气息的方言。书中人们为了生存这一简单目的，持有着最质朴的勇气和信念。\n孩子们可以从书中读到激动人心的狩猎，看见原野林莽、飞鸟起落、狼踪熊迹、暴雨狂风，进入乔迪的世界，与他共度被爸爸精心呵护、无忧无虑的童年。成年人，尤其是经历过离合悲欢、人世艰难的人，都能从书中读出欢笑、甜蜜、惆怅和感伤。\n【编辑推荐】\n《鹿苑长春》是一部经典的动物文学与环境文学著作。\n故事发生在美国南北战争结束后的垦荒时代，讲述与父母生活在佛罗里达岛地的男孩乔迪与一岁小鹿间的故事。\n爸爸在牧师家庭长大，正直善良，从不说谎，因经历战争后，厌倦了与人相处的世俗，带着妻子奥拉远离城镇，选择佛罗里达的巴克斯特岛地，过着狩猎农耕的生活。家中的生计依赖于自然选择，时常受到岛地周围野兽的威胁，尤其是经常出没偷食家畜的棕熊“大笨脚”。\n因为自然环境的严酷，夫妻两人连续夭折了3个孩子，以至于乔迪诞生后，妈妈奥拉因为遭遇太多次失去，对儿子不抱有太多疼爱，也许是向现实的冷酷低头，看待事物抱有异常冷漠的清醒。爸爸彭尼从小在家中担起大梁，了解天真无邪的珍贵，反而给乔迪加倍的疼爱，试图延长乔迪无忧无虑的童年。在丛林里，有变幻的迷人风光，也有让人惊叹的动物奇观。乔迪一直喜欢听猎人讲在狩猎途中的奇遇，期待着自己与动物的亲近。\n他跟着爸爸狩猎，追踪“大笨脚”，爬在树上看鹿妈妈带着小鹿啃食树叶，与爸爸抓到罕见的白色浣熊、在克拉克莎草丛中钓鱼，遇到高鸣鹤跳沙龙舞；他跟着巴克.福利斯特在月光下的玉米地里猎狐，去松树干掏蜂蜜；与好友“草翅膀”喂养小浣熊、欧洲灰雀，一起看西班牙人后裔穿过古栈道，一起数天上米诺鱼般的星星……生活就像他给自己在灰岩坑水塘边造的小水车，随着时间的流水，悠然转动，奏出欢快的乐章，似乎没有停下来的理由。\n然而乔迪作为独子，在偏远岛地，一直是孤寂的。他希望能像爸爸彭尼一样拥有只对自己忠诚的宠物。因为口粮不足，妈妈却一直拒绝驯养动物。直到有一天，在乔迪跟随爸爸追踪走失家猪的途中，遭遇危机，也遇到了那头刚出生不久的小鹿……\n故事讲失去，也讲成长；讲孤独，也讲爱与宽容。每个人也许会从中找到真挚的共鸣，遗憾和怅惘，但更多的是，是勇气。\n【名人推荐】\n“谈到近人的作品，说「不朽」总彷佛还太早，然而《鹿苑长春》在近代文学上的地位已经奠定了。《鹿苑长春》里面出现的动物比人多──鹿、响尾蛇、八字脚的老熊、牛、马、猪──像一个动物园，但是里面的人物，尤其是那男孩子乔迪，是使人永远不能忘记的。\n那孩子失去了他最心爱的东西，使他受到很深的刺激，然而他从此就坚强起来，长大成人了。我们仔细回味，就可以觉得这不止于是一个孩子的故事，任何人遇到挫折的时候，都能够从这里得到新的勇气。\n这故事具有真正的悲剧的因素──无法避免，也不可挽回。书中对于儿童心理有非常深入的描写，可以帮助做父母的人了解自己的子女。写父爱也发掘到人性的深处。\n它是健康的，向上的，但也许它最动人的地方是与东方的心情特别接近的一种淡淡的哀愁。最后的两段更是充满了一种难堪的怅惘，我译到这里的时候，甚至于译完之后重抄一遍，抄到这里的时候，也都是像第一次读到一样地觉得非常感动，眼睛湿润起来。我相信许多读者一定也有同感。”\n——张爱玲\n【媒体推荐】\n\n在罗琳斯女士之前，还没有谁创造出如此栩栩如生且亲近读者的一系列形象，其亲密的感情感染人，不禁令人产生共鸣。\n——纽约时报\n“Never before has Mrs. Rawlings created a set of characters who are so close and real to the reader, whose intimate life one can share without the taint of unconscious patronage.\" (The New York Times)\n惊心动魄的探险和令人怅惘的人性元素……这是一部不愧于普利策奖桂冠的经典作品，故事质朴的语言和四季变化下的生态智慧，都给予这本书一种独特而难忘的气质。而画家N.C.韦思也以温暖、柔和的插图，恰到好处地捕捉到那个垦荒时代的粗莽和淳美。\n——亚马逊网站\n“Heart-stopping adventure and heart-wrenching human element…. This is a classic well worth its Pulitzer Prize. Earthy dialect and homespun wisdom season the story, giving it a unique and unforgettable flavor, and N.C. Wyeth's warm, soft illustrations capture an era of rough subsistence and sweet survival.”\n(Amazon.com)","ebook_price":"12.00","price":"48.00元"},{"rating":{"max":10,"numRaters":531,"average":"8.9","min":0},"subtitle":"使用Visual C++5.0 & MFC 4.2","author":["侯俊杰"],"pubdate":"2001-1","tags":[{"count":303,"name":"MFC","title":"MFC"},{"count":174,"name":"C++","title":"C++"},{"count":108,"name":"计算机","title":"计算机"},{"count":92,"name":"编程","title":"编程"},{"count":74,"name":"深入浅出MFC","title":"深入浅出MFC"},{"count":72,"name":"侯捷","title":"侯捷"},{"count":64,"name":"Windows","title":"Windows"},{"count":38,"name":"经典","title":"经典"}],"origin_title":"","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28952279.jpg","binding":"平装16开","translator":[],"catalog":"第一篇 勿在浮砂筑高台\n第一章 Win32 程序基本概念\n第二章 C++的重要性质\n第三章 MFC六大关键技术之仿真\n第二篇 欲善工事先利其器\n第四章 Visual C++ 集成开发环境\n第三篇 浅出MFC程序设计\n第五章 总观Application Framework\n第六章 MFC程序的生死因果\n第七章 简单而完整：MFC骨干程序\n第四篇 深入MFC 程序设计\n第八章 Document-View深入探讨\n第九章 消息映射与命令传递\n第十章 MFC与对话框\n第十一章 Vies功能的加强与重绘效率的提高\n第十二章 打印与预览\n第十三章 多重文件与多重视图\n第十四章 MFC 多线程程序设计\n第十五章 站在众人的肩膀――使用Components & ActiveX Controls\n第五篇 附录","pages":"701","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s28952279.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s28952279.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28952279.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1094852\/","id":"1094852","publisher":"华中科技大学出版社","isbn10":"7900614931","isbn13":"9787900614933","title":"深入浅出MFC （第二版）","url":"https:\/\/api.douban.com\/v2\/book\/1094852","alt_title":"","author_intro":"侯俊杰（1961年9月28日－），笔名侯捷，台湾知名电脑技术专栏作家，致力于电脑技术之扎根工作，文章兼具科技之长与灵性之美，有读者的评语是“比作家更工程师，比工程师更作家”。大同国中、师大附中、交通大学土木系毕业、清华大学动力机械研究所硕士。曾任职工研院机械所与电通所，曾在元智大学授课，近年来多从事两岸学术交流工作。他的妻子美静是一名钢琴师，侯俊杰说他自己“嗜咖啡。妻严不能常得。”","summary":"《深入浅出MFC》分为四大篇。第一篇提出学习MFC程序设计之前的必要基础，包括Widnows程序的基本观念以及C++的高阶议题。“学前基础”是相当主观的认定，但作者是甚于自己的学习经验以及教学经验，其挑选应该颇具说服力。第二篇介绍Visual C++整合环境开发工具。此篇只是提纲挈领，并不企图取代Visual C++使用手册；然而对于软件使用的老手，此篇或已足以帮助掌握Visual C++整合环境。工具的使用虽然谈不上学问，但在视觉化软件开发过程中扮演极重角色。第三篇介绍application framework的观念，以及MFC骨干程序，所谓骨干程序，是指Visual C++的工具AppWizard所产生出来的程序码。当然，AppWizard会根据使用者的选项做出不同的程序码，作者据以解说的是大众化选项下的产品。第四篇以微软公司附于Visual C++光碟片上的一个范例程序Scribble为主轴，一步一步加上新的功能；并在其间深入介绍Runtime Type Information（RTTI）、Dynamic Creation、Persistence（Serialization）、Message Mapping、Command Routing等核心技术。这些技术正是其他专著最缺乏的部分。此篇的最后数章则脱离Scribble程序，另成一格。\n这本书配有一片光盘，书中所有原始码与可执行文件都在其中。","price":"80.00元"},{"rating":{"max":10,"numRaters":457,"average":"8.8","min":0},"subtitle":"使用muduo C++网络库","author":["陈硕"],"pubdate":"2013-1-15","tags":[{"count":607,"name":"网络编程","title":"网络编程"},{"count":543,"name":"Linux","title":"Linux"},{"count":541,"name":"C++","title":"C++"},{"count":454,"name":"多线程","title":"多线程"},{"count":155,"name":"计算机","title":"计算机"},{"count":143,"name":"编程","title":"编程"},{"count":110,"name":"C\/C++","title":"C\/C++"},{"count":87,"name":"Networks","title":"Networks"}],"origin_title":"","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s24522799.jpg","binding":"平装","translator":[],"catalog":"第1 部分C++ 多线程系统编程1\n第1章 线程安全的对象生命期管理3\n1.1 当析构函数遇到多线程. . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n1.1.1 线程安全的定义. . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\n1.1.2 MutexLock 与MutexLockGuard . . . . . . . . . . . . . . . . . . . . 4\n1.1.3 一个线程安全的Counter 示例. . . . . . . . . . . . . . . . . . . . 4\n1.2 对象的创建很简单. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n1.3 销毁太难. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n1.3.1 mutex 不是办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n1.3.2 作为数据成员的mutex 不能保护析构. . . . . . . . . . . . . . . 8\n1.4 线程安全的Observer 有多难. . . . . . . . . . . . . . . . . . . . . . . . . 8\n1.5 原始指针有何不妥. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n1.6 神器shared_ptr\/weak_ptr . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n1.7 插曲：系统地避免各种指针错误. . . . . . . . . . . . . . . . . . . . . . . 14\n1.8 应用到Observer 上. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\n1.9 再论shared_ptr 的线程安全. . . . . . . . . . . . . . . . . . . . . . . . . 17\n1.10 shared_ptr 技术与陷阱. . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n1.11 对象池. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21\n1.11.1 enable_shared_from_this . . . . . . . . . . . . . . . . . . . . . . 23\n1.11.2 弱回调. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\n1.12 替代方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n1.13 心得与小结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n1.14 Observer 之谬. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\n第2章 线程同步精要31\n2.1 互斥器（mutex） . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32\n2.1.1 只使用非递归的mutex . . . . . . . . . . . . . . . . . . . . . . . . 33\n2.1.2 死锁. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\n2.2 条件变量（condition variable） . . . . . . . . . . . . . . . . . . . . . . . 40\n2.3 不要用读写锁和信号量. . . . . . . . . . . . . . . . . . . . . . . . . . . . 43\n2.4 封装MutexLock、MutexLockGuard、Condition . . . . . . . . . . . . . . 44\n2.5 线程安全的Singleton 实现. . . . . . . . . . . . . . . . . . . . . . . . . . 48\n2.6 sleep(3) 不是同步原语. . . . . . . . . . . . . . . . . . . . . . . . . . . . 50\n2.7 归纳与总结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\n2.8 借shared_ptr 实现copy-on-write . . . . . . . . . . . . . . . . . . . . . . 52\n第3章 多线程服务器的适用场合与常用编程模型59\n3.1 进程与线程. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59\n3.2 单线程服务器的常用编程模型. . . . . . . . . . . . . . . . . . . . . . . . 61\n3.3 多线程服务器的常用编程模型. . . . . . . . . . . . . . . . . . . . . . . . 62\n3.3.1 one loop per thread . . . . . . . . . . . . . . . . . . . . . . . . . . 62\n3.3.2 线程池. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63\n3.3.3 推荐模式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64\n3.4 进程间通信只用TCP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65\n3.5 多线程服务器的适用场合. . . . . . . . . . . . . . . . . . . . . . . . . . . 67\n3.5.1 必须用单线程的场合. . . . . . . . . . . . . . . . . . . . . . . . . 69\n3.5.2 单线程程序的优缺点. . . . . . . . . . . . . . . . . . . . . . . . . 70\n3.5.3 适用多线程程序的场景. . . . . . . . . . . . . . . . . . . . . . . . 71\n3.6 “多线程服务器的适用场合”例释与答疑. . . . . . . . . . . . . . . . . . 74\n第4章 C++ 多线程系统编程精要83\n4.1 基本线程原语的选用. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84\n4.2 C\/C++ 系统库的线程安全性. . . . . . . . . . . . . . . . . . . . . . . . . 85\n4.3 Linux 上的线程标识. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89\n4.4 线程的创建与销毁的守则. . . . . . . . . . . . . . . . . . . . . . . . . . . 91\n4.4.1 pthread_cancel 与C++ . . . . . . . . . . . . . . . . . . . . . . . 94\n4.4.2 exit(3) 在C++ 中不是线程安全的. . . . . . . . . . . . . . . . . 94\n4.5 善用__thread 关键字. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96\n4.6 多线程与IO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98\n4.7 用RAII 包装文件描述符. . . . . . . . . . . . . . . . . . . . . . . . . . . 99\n4.8 RAII 与fork() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101\n4.9 多线程与fork() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102\n4.10 多线程与signal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103\n4.11 Linux 新增系统调用的启示. . . . . . . . . . . . . . . . . . . . . . . . . . 105\n第5章 高效的多线程日志107\n5.1 功能需求. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109\n5.2 性能需求. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112\n5.3 多线程异步日志. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114\n5.4 其他方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120\n第2部分 muduo 网络库123\n第6章 muduo 网络库简介125\n6.1 由来. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125\n6.2 安装. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127\n6.3 目录结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129\n6.3.1 代码结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131\n6.3.2 例子. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134\n6.3.3 线程模型. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135\n6.4 使用教程. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136\n6.4.1 TCP 网络编程本质论. . . . . . . . . . . . . . . . . . . . . . . . . 136\n6.4.2 echo 服务的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . 138\n6.4.3 七步实现finger 服务. . . . . . . . . . . . . . . . . . . . . . . . . 140\n6.5 性能评测. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144\n6.5.1 muduo 与Boost.Asio、libevent2 的吞吐量对比. . . . . . . . . . 145\n6.5.2 击鼓传花：对比muduo 与libevent2 的事件处理效率. . . . . . 148\n6.5.3 muduo 与Nginx 的吞吐量对比. . . . . . . . . . . . . . . . . . . 153\n6.5.4 muduo 与ZeroMQ 的延迟对比. . . . . . . . . . . . . . . . . . . 156\n6.6 详解muduo 多线程模型. . . . . . . . . . . . . . . . . . . . . . . . . . . 157\n6.6.1 数独求解服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . . 157\n6.6.2 常见的并发网络服务程序设计方案. . . . . . . . . . . . . . . . . 160\n第7章 muduo 编程示例177\n7.1 五个简单TCP 示例. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178\n7.2 文件传输. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185\n7.3 Boost.Asio 的聊天服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . 194\n7.3.1 TCP 分包. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194\n7.3.2 消息格式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195\n7.3.3 编解码器LengthHeaderCodec . . . . . . . . . . . . . . . . . . . . 197\n7.3.4 服务端的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198\n7.3.5 客户端的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200\n7.4 muduo Buffer 类的设计与使用. . . . . . . . . . . . . . . . . . . . . . . 204\n7.4.1 muduo 的IO 模型. . . . . . . . . . . . . . . . . . . . . . . . . . 204\n7.4.2 为什么non-blocking 网络编程中应用层buffer 是必需的. . . . 205\n7.4.3 Buffer 的功能需求. . . . . . . . . . . . . . . . . . . . . . . . . . 207\n7.4.4 Buffer 的数据结构. . . . . . . . . . . . . . . . . . . . . . . . . . 209\n7.4.5 Buffer 的操作. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211\n7.4.6 其他设计方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217\n7.4.7 性能是不是问题. . . . . . . . . . . . . . . . . . . . . . . . . . . . 218\n7.5 一种自动反射消息类型的Google Protobuf 网络传输方案. . . . . . . . 220\n7.5.1 网络编程中使用Protobuf 的两个先决条件. . . . . . . . . . . . . 220\n7.5.2 根据type name 反射自动创建Message 对象. . . . . . . . . . . . 221\n7.5.3 Protobuf 传输格式. . . . . . . . . . . . . . . . . . . . . . . . . . 226\n7.6 在muduo 中实现Protobuf 编解码器与消息分发器. . . . . . . . . . . . 228\n7.6.1 什么是编解码器（codec） . . . . . . . . . . . . . . . . . . . . . . 229\n7.6.2 实现ProtobufCodec . . . . . . . . . . . . . . . . . . . . . . . . . 232\n7.6.3 消息分发器（dispatcher）有什么用. . . . . . . . . . . . . . . . 232\n7.6.4 ProtobufCodec 与ProtobufDispatcher 的综合运用. . . . . . . 233\n7.6.5 ProtobufDispatcher 的两种实现. . . . . . . . . . . . . . . . . . 234\n7.6.6 ProtobufCodec 和ProtobufDispatcher 有何意义. . . . . . . . . 236\n7.7 限制服务器的最大并发连接数. . . . . . . . . . . . . . . . . . . . . . . . 237\n7.7.1 为什么要限制并发连接数. . . . . . . . . . . . . . . . . . . . . . 237\n7.7.2 在muduo 中限制并发连接数. . . . . . . . . . . . . . . . . . . . 238\n7.8 定时器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240\n7.8.1 程序中的时间. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240\n7.8.2 Linux 时间函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . 241\n7.8.3 muduo 的定时器接口. . . . . . . . . . . . . . . . . . . . . . . . . 242\n7.8.4 Boost.Asio Timer 示例. . . . . . . . . . . . . . . . . . . . . . . . 243\n7.8.5 Java Netty 示例. . . . . . . . . . . . . . . . . . . . . . . . . . . . 245\n7.9 测量两台机器的网络延迟和时间差. . . . . . . . . . . . . . . . . . . . . 248\n7.10 用timing wheel 踢掉空闲连接. . . . . . . . . . . . . . . . . . . . . . . . 250\n7.10.1 timing wheel 原理. . . . . . . . . . . . . . . . . . . . . . . . . . 251\n7.10.2 代码实现与改进. . . . . . . . . . . . . . . . . . . . . . . . . . . . 254\n7.11 简单的消息广播服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257\n7.12 “串并转换”连接服务器及其自动化测试. . . . . . . . . . . . . . . . . . 260\n7.13 socks4a 代理服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264\n7.13.1 TCP 中继器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264\n7.13.2 socks4a 代理服务器. . . . . . . . . . . . . . . . . . . . . . . . . . 267\n7.13.3 N : 1 与1 : N 连接转发. . . . . . . . . . . . . . . . . . . . . . . . 267\n7.14 短址服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267\n7.15 与其他库集成. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268\n7.15.1 UDNS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270\n7.15.2 c-ares DNS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272\n7.15.3 curl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273\n7.15.4 更多. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275\n第8章 muduo 网络库设计与实现277\n8.0 什么都不做的EventLoop . . . . . . . . . . . . . . . . . . . . . . . . . . . 277\n8.1 Reactor 的关键结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280\n8.1.1 Channel class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280\n8.1.2 Poller class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283\n8.1.3 EventLoop 的改动. . . . . . . . . . . . . . . . . . . . . . . . . . . 287\n8.2 TimerQueue 定时器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290\n8.2.1 TimerQueue class . . . . . . . . . . . . . . . . . . . . . . . . . . . 290\n8.2.2 EventLoop 的改动. . . . . . . . . . . . . . . . . . . . . . . . . . . 292\n8.3 EventLoop::runInLoop() 函数. . . . . . . . . . . . . . . . . . . . . . . . 293\n8.3.1 提高TimerQueue 的线程安全性. . . . . . . . . . . . . . . . . . . 296\n8.3.2 EventLoopThread class . . . . . . . . . . . . . . . . . . . . . . . . 297\n8.4 实现TCP 网络库. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299\n8.5 TcpServer 接受新连接. . . . . . . . . . . . . . . . . . . . . . . . . . . . 303\n8.5.1 TcpServer class . . . . . . . . . . . . . . . . . . . . . . . . . . . . 304\n8.5.2 TcpConnection class . . . . . . . . . . . . . . . . . . . . . . . . . 305\n8.6 TcpConnection 断开连接. . . . . . . . . . . . . . . . . . . . . . . . . . . 308\n8.7 Buffer 读取数据. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 313\n8.7.1 TcpConnection 使用Buffer 作为输入缓冲. . . . . . . . . . . . . 314\n8.7.2 Buffer::readFd() . . . . . . . . . . . . . . . . . . . . . . . . . . 315\n8.8 TcpConnection 发送数据. . . . . . . . . . . . . . . . . . . . . . . . . . . 316\n8.9 完善TcpConnection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 320\n8.9.1 SIGPIPE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321\n8.9.2 TCP No Delay 和TCP keepalive . . . . . . . . . . . . . . . . . . 321\n8.9.3 WriteCompleteCallback 和HighWaterMarkCallback . . . . . . . 322\n8.10 多线程TcpServer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 324\n8.11 Connector . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327\n8.12 TcpClient . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 332\n8.13 epoll . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333\n8.14 测试程序一览. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 336\n第3部分 工程实践经验谈337\n第9章 分布式系统工程实践339\n9.1 我们在技术浪潮中的位置. . . . . . . . . . . . . . . . . . . . . . . . . . . 341\n9.1.1 分布式系统的本质困难. . . . . . . . . . . . . . . . . . . . . . . . 343\n9.1.2 分布式系统是个险恶的问题. . . . . . . . . . . . . . . . . . . . . 344\n9.2 分布式系统的可靠性浅说. . . . . . . . . . . . . . . . . . . . . . . . . . . 349\n9.2.1 分布式系统的软件不要求7  24 可靠. . . . . . . . . . . . . . . . 352\n9.2.2 “能随时重启进程”作为程序设计目标. . . . . . . . . . . . . . . 354\n9.3 分布式系统中心跳协议的设计. . . . . . . . . . . . . . . . . . . . . . . . 356\n9.4 分布式系统中的进程标识. . . . . . . . . . . . . . . . . . . . . . . . . . . 360\n9.4.1 错误做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361\n9.4.2 正确做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 362\n9.4.3 TCP 协议的启示. . . . . . . . . . . . . . . . . . . . . . . . . . . . 363\n9.5 构建易于维护的分布式程序. . . . . . . . . . . . . . . . . . . . . . . . . 364\n9.6 为系统演化做准备. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 367\n9.6.1 可扩展的消息格式. . . . . . . . . . . . . . . . . . . . . . . . . . 368\n9.6.2 反面教材：ICE 的消息打包格式. . . . . . . . . . . . . . . . . . . 369\n9.7 分布式程序的自动化回归测试. . . . . . . . . . . . . . . . . . . . . . . . 370\n9.7.1 单元测试的能与不能. . . . . . . . . . . . . . . . . . . . . . . . . 370\n9.7.2 分布式系统测试的要点. . . . . . . . . . . . . . . . . . . . . . . . 373\n9.7.3 分布式系统的抽象观点. . . . . . . . . . . . . . . . . . . . . . . . 374\n9.7.4 一种自动化的回归测试方案. . . . . . . . . . . . . . . . . . . . . 375\n9.7.5 其他用处. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 379\n9.8 分布式系统部署、监控与进程管理的几重境界. . . . . . . . . . . . . . . 380\n9.8.1 境界1：全手工操作. . . . . . . . . . . . . . . . . . . . . . . . . 382\n9.8.2 境界2：使用零散的自动化脚本和第三方组件. . . . . . . . . . . 383\n9.8.3 境界3：自制机群管理系统，集中化配置. . . . . . . . . . . . . 386\n9.8.4 境界4：机群管理与naming service 结合. . . . . . . . . . . . . 389\n第10章 C++ 编译链接模型精要391\n10.1 C 语言的编译模型及其成因. . . . . . . . . . . . . . . . . . . . . . . . . 394\n10.1.1 为什么C 语言需要预处理. . . . . . . . . . . . . . . . . . . . . . 395\n10.1.2 C 语言的编译模型. . . . . . . . . . . . . . . . . . . . . . . . . . . 398\n10.2 C++ 的编译模型. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399\n10.2.1 单遍编译. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399\n10.2.2 前向声明. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 402\n10.3 C++ 链接（linking） . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 404\n10.3.1 函数重载. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 406\n10.3.2 inline 函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 407\n10.3.3 模板. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 409\n10.3.4 虚函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 414\n10.4 工程项目中头文件的使用规则. . . . . . . . . . . . . . . . . . . . . . . . 415\n10.4.1 头文件的害处. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 416\n10.4.2 头文件的使用规则. . . . . . . . . . . . . . . . . . . . . . . . . . 417\n10.5 工程项目中库文件的组织原则. . . . . . . . . . . . . . . . . . . . . . . . 418\n10.5.1 动态库是有害的. . . . . . . . . . . . . . . . . . . . . . . . . . . . 423\n10.5.2 静态库也好不到哪儿去. . . . . . . . . . . . . . . . . . . . . . . . 424\n10.5.3 源码编译是王道. . . . . . . . . . . . . . . . . . . . . . . . . . . . 428\n第11章 反思C++ 面向对象与虚函数429\n11.1 朴实的C++ 设计. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 429\n11.2 程序库的二进制兼容性. . . . . . . . . . . . . . . . . . . . . . . . . . . . 431\n11.2.1 什么是二进制兼容性. . . . . . . . . . . . . . . . . . . . . . . . . 432\n11.2.2 有哪些情况会破坏库的ABI . . . . . . . . . . . . . . . . . . . . . 433\n11.2.3 哪些做法多半是安全的. . . . . . . . . . . . . . . . . . . . . . . . 435\n11.2.4 反面教材：COM . . . . . . . . . . . . . . . . . . . . . . . . . . . 435\n11.2.5 解决办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 436\n11.3 避免使用虚函数作为库的接口. . . . . . . . . . . . . . . . . . . . . . . . 436\n11.3.1 C++ 程序库的作者的生存环境. . . . . . . . . . . . . . . . . . . . 437\n11.3.2 虚函数作为库的接口的两大用途. . . . . . . . . . . . . . . . . . 438\n11.3.3 虚函数作为接口的弊端. . . . . . . . . . . . . . . . . . . . . . . . 439\n11.3.4 假如Linux 系统调用以COM 接口方式实现. . . . . . . . . . . . 442\n11.3.5 Java 是如何应对的. . . . . . . . . . . . . . . . . . . . . . . . . . 443\n11.4 动态库接口的推荐做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . 443\n11.5 以boost::function 和boost::bind 取代虚函数. . . . . . . . . . . . . 447\n11.5.1 基本用途. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 450\n11.5.2 对程序库的影响. . . . . . . . . . . . . . . . . . . . . . . . . . . . 451\n11.5.3 对面向对象程序设计的影响. . . . . . . . . . . . . . . . . . . . . 453\n11.6 iostream 的用途与局限. . . . . . . . . . . . . . . . . . . . . . . . . . . . 457\n11.6.1 stdio 格式化输入输出的缺点. . . . . . . . . . . . . . . . . . . . . 457\n11.6.2 iostream 的设计初衷. . . . . . . . . . . . . . . . . . . . . . . . . 461\n11.6.3 iostream 与标准库其他组件的交互. . . . . . . . . . . . . . . . . 463\n11.6.4 iostream 在使用方面的缺点. . . . . . . . . . . . . . . . . . . . . 464\n11.6.5 iostream 在设计方面的缺点. . . . . . . . . . . . . . . . . . . . . 468\n11.6.6 一个300 行的memory buffer output stream . . . . . . . . . . . 476\n11.6.7 现实的C++ 程序如何做文件IO . . . . . . . . . . . . . . . . . . . 480\n11.7 值语义与数据抽象. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482\n11.7.1 什么是值语义. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482\n11.7.2 值语义与生命期. . . . . . . . . . . . . . . . . . . . . . . . . . . . 483\n11.7.3 值语义与标准库. . . . . . . . . . . . . . . . . . . . . . . . . . . . 488\n11.7.4 值语义与C++ 语言. . . . . . . . . . . . . . . . . . . . . . . . . . 488\n11.7.5 什么是数据抽象. . . . . . . . . . . . . . . . . . . . . . . . . . . . 490\n11.7.6 数据抽象所需的语言设施. . . . . . . . . . . . . . . . . . . . . . 493\n11.7.7 数据抽象的例子. . . . . . . . . . . . . . . . . . . . . . . . . . . . 495\n第12章 C++ 经验谈501\n12.1 用异或来交换变量是错误的. . . . . . . . . . . . . . . . . . . . . . . . . 501\n12.1.1 编译器会分别生成什么代码. . . . . . . . . . . . . . . . . . . . . 503\n12.1.2 为什么短的代码不一定快. . . . . . . . . . . . . . . . . . . . . . 505\n12.2 不要重载全局::operator new() . . . . . . . . . . . . . . . . . . . . . . 507\n12.2.1 内存管理的基本要求. . . . . . . . . . . . . . . . . . . . . . . . . 507\n12.2.2 重载::operator new() 的理由. . . . . . . . . . . . . . . . . . . 508\n12.2.3 ::operator new() 的两种重载方式. . . . . . . . . . . . . . . . . 508\n12.2.4 现实的开发环境. . . . . . . . . . . . . . . . . . . . . . . . . . . . 509\n12.2.5 重载::operator new() 的困境. . . . . . . . . . . . . . . . . . . 510\n12.2.6 解决办法：替换malloc() . . . . . . . . . . . . . . . . . . . . . . 512\n12.2.7 为单独的class 重载::operator new() 有问题吗. . . . . . . . . 513\n12.2.8 有必要自行定制内存分配器吗. . . . . . . . . . . . . . . . . . . . 513\n12.3 带符号整数的除法与余数. . . . . . . . . . . . . . . . . . . . . . . . . . . 514\n12.3.1 语言标准怎么说. . . . . . . . . . . . . . . . . . . . . . . . . . . . 515\n12.3.2 C\/C++ 编译器的表现. . . . . . . . . . . . . . . . . . . . . . . . . 516\n12.3.3 其他语言的规定. . . . . . . . . . . . . . . . . . . . . . . . . . . . 516\n12.3.4 脚本语言解释器代码. . . . . . . . . . . . . . . . . . . . . . . . . 517\n12.3.5 硬件实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521\n12.4 在单元测试中mock 系统调用. . . . . . . . . . . . . . . . . . . . . . . . 522\n12.4.1 系统函数的依赖注入. . . . . . . . . . . . . . . . . . . . . . . . . 522\n12.4.2 链接期垫片（link seam） . . . . . . . . . . . . . . . . . . . . . . 524\n12.5 慎用匿名namespace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 526\n12.5.1 C 语言的static 关键字的两种用法. . . . . . . . . . . . . . . . . 526\n12.5.2 C++ 语言的static 关键字的四种用法. . . . . . . . . . . . . . . . 526\n12.5.3 匿名namespace 的不利之处. . . . . . . . . . . . . . . . . . . . . 527\n12.5.4 替代办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 529\n12.6 采用有利于版本管理的代码格式. . . . . . . . . . . . . . . . . . . . . . . 529\n12.6.1 对diff 友好的代码格式. . . . . . . . . . . . . . . . . . . . . . . . 530\n12.6.2 对grep 友好的代码风格. . . . . . . . . . . . . . . . . . . . . . . 537\n12.6.3 一切为了效率. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 538\n12.7 再探std::string . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539\n12.7.1 直接拷贝（eager copy） . . . . . . . . . . . . . . . . . . . . . . . 540\n12.7.2 写时复制（copy-on-write） . . . . . . . . . . . . . . . . . . . . . 542\n12.7.3 短字符串优化（SSO） . . . . . . . . . . . . . . . . . . . . . . . . 543\n12.8 用STL algorithm 轻松解决几道算法面试题. . . . . . . . . . . . . . . . 546\n12.8.1 用next_permutation() 生成排列与组合. . . . . . . . . . . . . . 546\n12.8.2 用unique() 去除连续重复空白. . . . . . . . . . . . . . . . . . . 548\n12.8.3 用{make,push,pop}_heap() 实现多路归并. . . . . . . . . . . . 549\n12.8.4 用partition() 实现“重排数组，让奇数位于偶数前面” . . . . 553\n12.8.5 用lower_bound() 查找IP 地址所属的城市. . . . . . . . . . . . . 554\n第4 部分附录559\n附录A 谈一谈网络编程学习经验561\n附录B 从《C++ Primer（第4 版）》入手学习C++ 579\n附录C 关于Boost 的看法591\n附录D 关于TCP 并发连接的几个思考题与试验593\n参考文献599","pages":"610","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s24522799.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s24522799.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s24522799.jpg"},"alt":"https:\/\/book.douban.com\/subject\/20471211\/","id":"20471211","publisher":"电子工业出版社","isbn10":"7121192829","isbn13":"9787121192821","title":"Linux多线程服务端编程","url":"https:\/\/api.douban.com\/v2\/book\/20471211","alt_title":"","author_intro":"陈硕，北京师范大学硕士，擅长C++ 多线程网络编程和实时分布式系统架构。曾在摩根士丹利IT 部门工作5 年，从事实时外汇交易系统开发。现在在美国加州硅谷某互联网大公司工作，从事大规模分布式系统的可靠性工程。编写了开源C++ 网络库muduo，参与翻译了《代码大全（ 第2 版）》和《C++ 编程规范（繁体版）》，整理了《C++ Primer （第4 版）（评注版）》，并曾多次在各地技术大会演讲。","summary":"本书主要讲述采用现代C++ 在x86-64 Linux 上编写多线程TCP 网络服务程序的主流常规技术，重点讲解一种适应性较强的多线程服务器的编程模型，即one loop per thread。这是在Linux 下以native 语言编写用户态高性能网络程序最成熟的模式，掌握之后可顺利地开发各类常见的服务端网络应用程序。本书以muduo 网络库为例，讲解这种编程模型的使用方法及注意事项。\n本书的宗旨是贵精不贵多。掌握两种基本的同步原语就可以满足各种多线程同步的功能需求，还能写出更易用的同步设施。掌握一种进程间通信方式和一种多线程网络编程模型就足以应对日常开发任务，编写运行于公司内网环境的分布式服务统。","price":"89.00元"}]}
3	{"count":20,"start":0,"total":1198604,"books":[{"rating":{"max":10,"numRaters":1850,"average":"8.9","min":0},"subtitle":"C语言描述","author":["维斯"],"pubdate":"2004-1-1","tags":[{"count":2183,"name":"数据结构","title":"数据结构"},{"count":1727,"name":"算法","title":"算法"},{"count":976,"name":"计算机","title":"计算机"},{"count":900,"name":"数据结构与算法分析","title":"数据结构与算法分析"},{"count":731,"name":"编程","title":"编程"},{"count":706,"name":"算法、数据结构","title":"算法、数据结构"},{"count":647,"name":"C","title":"C"},{"count":552,"name":"C语言","title":"C语言"}],"origin_title":"Data Structures and Algorithm Analysis in C:Second Edition","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s28015501.jpg","binding":"平装","translator":["冯舜玺"],"catalog":"第1章 引论\n1．1 本书讨论的内容\n1．2 数学知识复习\n1．2．1 指数\n1．2．2 对数\n1．2．3 级数\n1．2．4 模运算\n1. 2．5 证明方法\n1．3 递归简论\n总结\n练习\n参考文献\n第2章 算法分析\n2．1 数学基础\n2．2 模型\n2．3 要分析的问题\n2．4 运行时间计算\n2．4．1 一个简单的例子\n2．4．2 一般法则\n2．4．3 最大子序列和问题的解\n.2．4．4 运行时间中的对数\n2．4．5 检验你的分析\n2．4．6 分析结果的准确性\n总结\n练习\n参考文献\n第3章 表、栈和队列\n3．1 抽象数据类型(adt)\n3．2 表adt\n3．2．1 表的简单数组实现\n3．2．2 链表\n3．2．3 程序设计细节\n3．2．4 常见的错误\n3．2．5 双链表\n3．2．6 循环链表\n3．2．7 例子\n3．2．8 链表的游标实现\n3．3 栈adt\n3．3．1 栈模型\n3．3．2 栈的实现\n3．3．3 应用\n3．4 队列adt\n3．4．1 队列模型\n3．4．2 队列的数组实现\n3．4．3 队列的应用\n总结\n练习\n第4章 树\n4．1 预备知识\n4．1．1 树的实现\n4．1．2 树的遍历及应用\n4．2 二叉树\n4．2．1 实现\n4．2．2 表达式树\n4．3 查找树adt--二叉查找树\n4．3．1 makeempty\n4．3．2 find\n4．3．3 findmin和findmax\n4．3．4 insert\n4．3．5 delere\n4．3．6 平均情形分析\n4．4 avl树\n4．4．1 单旋转\n4．4．2 双旋转\n4．5 伸展树\n4．5．1 一个简单的想法\n4．5．2 展开\n4．6 树的遍历\n4．7 b-树\n总结\n练习\n参考文献\n第5章 散列\n5．1 一般想法\n5．2 散列函数\n5．3 分离链接法\n5．4 开放定址法\n5．4．1 线性探测法\n5．4．2 平方探测法\n5．4．3 双散列\n5．5 再散列\n5．6 可扩散列\n总结\n练习\n参考文献\n第6章 优先队列(堆)\n6．1 模型\n6．2 一些简单的实现\n6．3 二叉堆\n6．3．1 结构性质\n6．3．2 堆序性质\n6．3．3 基本的堆操作\n6．3．4 其他的堆操作\n6．4 优先队列的应用\n6．4．1 选择问题\n6．4．2 事件模拟\n6．5 d-堆\n6．6 左式堆\n6．6．1 左式堆的性质\n6．6．2 左式堆的操作\n6．7 斜堆\n6．8 二项队列\n6．8．1 二项队列结构\n6．8．2 二项队列操作\n6．8．3 二项队列的实现\n总结\n练习\n参考文献\n第7章 排序\n7．1 预备知识\n7．2 插入排序\n7．2．1 算法\n7．2．2 插入排序的分析\n7．3 一些简单排序算法的下界\n7. 4 希尔排序\n7．4．1 希尔排序的最坏情形分析\n7．5 堆排序\n7．5．1 堆排序的分析\n7．6 归并排序\n7．6．1 归并排序的分析\n7．7 快速排序\n7．7．1 选取枢纽元\n7．7．2 分割策略\n7．7．3 小数组\n7．7．4 实际的快速排序例程\n7．7．5 快速排序的分析\n7．7．6 选择的线性期望时间算法\n7．8 大型结构的排序\n7．9 排序的一般下界\n7．9．1 决策树\n7．10 桶式排序\n7．11 外部排序\n7．11．1 为什么需要新的算法\n7．11．2 外部排序模型\n7．11．3 简单算法\n7．11．4 多路合并\n7．11．5 多相合并\n7．11．6 替换选择\n总结\n练习\n参考文献\n第8章 不相交集adt\n8．1 等价关系\n8．2 动态等价性问题\n8．3 基本数据结构\n8．4 灵巧求并算法\n8．5 路径压缩\n8．6 按秩求并和路径压缩的最坏情形\n8．6．1 union／find算法分析\n8．7 一个应用\n总结\n练习\n参考文献\n第9章 图论算法\n9．1 若干定义\n9．1．1 图的表示\n9．2 拓扑排序\n9．3 最短路径算法\n9．3．1 无权最短路径\n9．3．2 dijkstra算法\n9．3．3 具有负边值的图\n9．3．4 无圈图\n9．3．5 所有点对最短路径\n9．4 网络流问题\n9．4．1 一个简单的最大流算法\n9．5 最小生成树\n9．5．1 prim算法\n9．5．2 kruskal算法\n9．6 深度优先搜索的应用\n9．6．1 无向图\n9．6．2 双连通性\n9．6．3 欧拉回路\n9．6．4 有向图\n9．6．5 查找强分支\n9．7 np-完全性介绍\n9．7．1 难与易\n9．7．2 np类\n9．7．3 np-完全问题\n总结\n练习\n参考文献\n第10章 算法设计技巧\n10．1 贪婪算法\n10．1．1 一个简单的调度问题\n10．1．2 huffman编码\n10．1．3 近似装箱问题\n10．2 分治算法\n10．2．1 分治算法的运行时间\n10．2．2 最近点问题\n10．2．3 选择问题\n10．2．4 一些运算问题的理论改进\n10．3 动态规划\n10．3．1 用一个表代替递归\n10．3．2 矩阵乘法的顺序安排\n10．3．3 最优二叉查找树\n10．3．4 所有点对最短路径\n10．4 随机化算法\n10．4．1 随机数发生器\n10．4．2 跳跃表\n10．4．3 素性测试\n10．5 回溯算法\n10．5．1 收费公路重建问题\n10．5．2 博弈\n总结\n练习\n参考文献\n第11章 摊还分析\n11．1 一个无关的智力问题\n11．2 二项队列\n11．3 斜堆\n11．4 斐波那契堆\n11．4．1 切除左式堆中的节点\n11．4．2 二项队列的懒惰合并\n11．4．3 斐波那契堆操作\n11．4．4 时间界的证明\n11. 5 伸展树\n总结\n练习\n参考文献\n第12章 高级数据结构及其实现\n12．1 自顶向下伸展树\n12．2 红黑树\n12．2．1 自底向上插入\n12．2．2 自顶向下红黑树\n12．2．3 自顶向下删除\n12．3 确定性跳跃表\n12．4 aa-树\n12．5 treap树\n12．6 k-d树\n12．7 配对堆\n总结\n练习\n参考文献\n索引","pages":"391","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s28015501.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s28015501.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s28015501.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1139426\/","id":"1139426","publisher":"机械工业出版社","isbn10":"711112748X","isbn13":"9787111127482","title":"数据结构与算法分析","url":"https:\/\/api.douban.com\/v2\/book\/1139426","alt_title":"Data Structures and Algorithm Analysis in C:Second Edition","author_intro":"Mark Allen Weiss，1987年在普林斯顿大学获得计算机科学博士学位，师从Robert Sedgewick (师从Knuth)，现任美国佛罗里达国际大学计算与信息科学学院教授。他曾经担任全美AP(Advanced Placement)考试计算机学科委员会的主席(2000-2004)。他的主要研究方向是数据结构、算法和教育学。","summary":"本书是《Data Structures and Algorithm Analysis in C》一书第2版的简体中译本。原书曾被评为20世纪顶尖的30部计算机著作之一，作者Mark Allen Weiss在数据结构和算法分析方面卓有建树，他的数据结构和算法分析的著作尤其畅销，并受到广泛好评．已被世界500余所大学用作教材。\n在本书中，作者更加精炼并强化了他对算法和数据结构方面创新的处理方法。通过C程序的实现，着重阐述了抽象数据类型的概念，并对算法的效率、性能和运行时间进行了分析。\n全书特点如下：\n●专用一章来讨论算法设计技巧，包括贪婪算法、分治算法、动态规划、随机化算法以及回溯算法\n●介绍了当前流行的论题和新的数据结构，如斐波那契堆、斜堆、二项队列、跳跃表和伸展树\n●安排一章专门讨论摊还分析，考查书中介绍的一些高级数据结构\n●新开辟一章讨论高级数据结构以及它们的实现，其中包括红黑树、自顶向下伸展树。treap树、k-d树、配对堆以及其他相关内容\n●合并了堆排序平均情况分析的一些新结果\n本书是国外数据结构与算法分析方面的标准教材，介绍了数据结构(大量数据的组织方法)以及算法分析(算法运行时间的估算)。本书的编写目标是同时讲授好的程序设计和算法分析技巧，使读者可以开发出具有最高效率的程序。 本书可作为高级数据结构课程或研究生一年级算法分析课程的教材，使用本书需具有一些中级程序设计知识，还需要离散数学的一些背景知识。","series":{"id":"1163","title":"计算机科学丛书"},"price":"35.00元"},{"rating":{"max":10,"numRaters":1332,"average":"8.9","min":0},"subtitle":"C语言调试指南","author":["凯尼格"],"pubdate":"2008-2-1","tags":[{"count":708,"name":"C语言","title":"C语言"},{"count":437,"name":"编程","title":"编程"},{"count":318,"name":"C","title":"C"},{"count":278,"name":"计算机","title":"计算机"},{"count":248,"name":"c","title":"c"},{"count":210,"name":"C\/C++","title":"C\/C++"},{"count":194,"name":"经典","title":"经典"},{"count":179,"name":"程序设计","title":"程序设计"}],"origin_title":"C Traps and Pitfalls","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s2870233.jpg","binding":"平装","translator":["高巍"],"catalog":"第0章　导读\n第1章　词法“陷阱”\n1.1　=不同于==\n1.2　& 和 | 不同于&& 和 ||\n1.3　词法分析中的“贪心法”\n1.4　整型常量\n1.5　字符与字符串\n第2章　语法“陷阱”\n2.1　理解函数声明\n2.2　运算符的优先级问题\n2.3　注意作为语句结束标志的分号\n2.4　switch语句\n2.5　函数调用\n2.6　“悬挂”else引发的问题\n第3章　语义“陷阱”\n3.1　指针与数组\n3.2　非数组的指针\n3.3　作为参数的数组声明\n3.4　避免“举隅法”\n3.5　空指针并非空字符串\n3.6　边界计算与不对称边界\n3.7　求值顺序\n3.8　运算符&&、|| 和 !\n3.9　整数溢出\n3.10　为函数main提供返回值\n第4章　连接\n4.1　什么是连接器\n4.2　声明与定义\n4.3　命名冲突与static修饰符\n4.4　形参、实参与返回值\n4.5　检查外部类型\n4.6　头文件\n第5章　库函数\n5.1　返回整数的getchar函数\n5.2　更新顺序文件\n5.3　缓冲输出与内存分配\n5.4　使用errno检测错误\n5.5　库函数signal\n第6章　预处理器\n6.1　不能忽视宏定义中的空格\n6.2　宏并不是函数\n6.3　宏并不是语句\n6.4　宏并不是类型定义\n第7章　可移植性缺陷\n7.1　应对C语言标准变更\n7.2　标识符名称的限制\n7.3　整数的大小\n7.4　字符是有符号整数还是无符号整数\n7.5　移位运算符\n7.6　内存位置0\n7.7　除法运算时发生的截断\n7.8　随机数的大小\n7.9　大小写转换\n7.10　首先释放，然后重新分配\n7.11　可移植性问题的一个例子\n第8章　建议与答案\n8.1　建议\n8.2　答案\n附录A　PRINTF，VARARGS与STDARG\n附录B　Koenig和Moo夫妇访谈","pages":"172","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s2870233.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s2870233.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s2870233.jpg"},"alt":"https:\/\/book.douban.com\/subject\/2778632\/","id":"2778632","publisher":"人民邮电出版社","isbn10":"7115171793","isbn13":"9787115171795","title":"C陷阱与缺陷","url":"https:\/\/api.douban.com\/v2\/book\/2778632","alt_title":"C Traps and Pitfalls","author_intro":"Andrew Koenig 是AT&T公司Shannon实验室大规模编程研究部门中的成员，同时也是C++标准委员会的项目编辑。他的编程经验超过30年，其中有15年在使用C++，他已经出版了超过150 篇和C++有关的论文，并且在世界范围内就这个主题进行过多次演讲。","summary":"作者以自己1985年在Bell实验室时发表的一篇论文为基础，结合自己的工作经验扩展成为这本对C程序员具有珍贵价值的经典著作。写作本书的出发点不是要批判C语言，而是要帮助C程序员绕过编程过程中的陷阱和障碍。..\n全书分为8章，分别从词法分析、语法语义、连接、库函数、预处理器、可移植性缺陷等几个方面分析了C编程中可能遇到的问题。最后，作者用一章的篇幅给出了若干具有实用价值的建议。..\n本书适合有一定经验的C程序员阅读学习，即便你是C编程高手，本书也应该成为你的案头必备书籍。","series":{"id":"9931","title":"C和C++经典著作"},"price":"30.00元"},{"rating":{"max":10,"numRaters":4408,"average":"9.4","min":0},"subtitle":"第 2 版·新版","author":["（美）Brian W. Kernighan","（美）Dennis M. Ritchie"],"pubdate":"2004-1","tags":[{"count":3001,"name":"C","title":"C"},{"count":2408,"name":"c语言","title":"c语言"},{"count":2131,"name":"编程","title":"编程"},{"count":1549,"name":"计算机","title":"计算机"},{"count":1291,"name":"程序设计","title":"程序设计"},{"count":1080,"name":"经典","title":"经典"},{"count":987,"name":"编程语言","title":"编程语言"},{"count":869,"name":"C\/C++","title":"C\/C++"}],"origin_title":"The C Programming Language","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1106934.jpg","binding":"平装","translator":["徐宝文","李志译","尤晋元审校"],"catalog":"出版者的话\n专家指导委员会\n中文版序\n译者序\n校译者简介\n序\n第1版序\n引言\n第1章 导言\n1.1 入门\n1.2 变量与算术表态式\n1.3 for语句\n1.4 符号常量\n1.5 字符输入\/输出\n1.6 数组\n1.7 函数\n1.8 参数——传值调用\n1.9 字符数组\n1.10 外部变量与作用域\n第2章 类型、运算符与表达式\n2.1 变量名\n2.2 数据类型及长度\n2.3 常量\n2.4 声明\n2.5 算术运算符\n2.6 关系运算符与逻辑运算符\n2.7 类型转换\n2.8 自增运算符与自减运算符\n2.9 按位运算符\n2.10 赋值运算符与表达式\n2.11 条件表达式\n2.12 运算符优先级与求值次序\n第3章 控制流\n3.1 语句与程序块\n3.2 if-else语句\n3.3 else-if语句\n3.4 switch语句\n3.5 whil循环与for特环\n3.6 do-while循环\n3.7 break语句与continue语句\n3.8 goto语句与标号\n第4章 涵数与程序结构\n第5章 指针与数组\n第6章 结构\n第7章 输入与输出\n第8章 UNIX系统接口\n附录A 参考手册\n附录B 标准库\n附录C 变更小结\n索引","pages":"258","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s1106934.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s1106934.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1106934.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1139336\/","id":"1139336","publisher":"机械工业出版社","isbn10":"7111128060","isbn13":"9787111128069","title":"C程序设计语言","url":"https:\/\/api.douban.com\/v2\/book\/1139336","alt_title":"The C Programming Language","author_intro":"Brian W. Kernighan： 贝尔实验室计算科学研究中心高级研究人员，著名的计算机科学家。他参加了UNIX系统、C语言、AWK语言和许多其他系统的开发，同时出版了许多在计算机领域具有影响的著作，如《The Elements of Programming Style》、《The Practice of Programming》、《The UNIX Programming Environment》、《The AWK Language》、《Software Tools》等。\nDennis M. Ritchie：1967年加入贝尔实验室。他和Ken L. Thompson两人共同设计并实现的C语言改变了程序设计语言发展的轨迹，是程序设计语言发展过程中的一个重要里程碑。与此同时，他们两人还设计并实现了UNIX操作系统。正是由于这两项巨大贡献，Dennis M. Ritchie于1983年获得了计算机界的最高奖——图灵奖。此外，他还获得了ACM、IEEE、贝尔实验室等授予的多种奖项.。","summary":"在计算机发展的历史上，没有哪一种程序设计语言像C语言这样应用广泛。本书原著即为C语言的设计者之一Dennis M.Ritchie和著名计算机科学家Brian W.Kernighan合著的一本介绍C语言的权威经典著作。我们现在见到的大量论述C语言程序设计的教材和专著均以此书为蓝本。原著第1版中介绍的C语言成为后来广泛使用的C语言版本——标准C的基础。人们熟知的“hello,World\"程序就是由本书首次引入的，现在，这一程序已经成为众多程序设计语言入门的第一课。\n原著第2版根据1987年制定的ANSIC标准做了适当的修订．引入了最新的语言形式，并增加了新的示例，通过简洁的描述、典型的示例，作者全面、系统、准确地讲述了C语言的各个特性以及程序设计的基本方法。对于计算机从业人员来说，《C程序设计语言》是一本必读的程序设计语 言方面的参考书。","series":{"id":"1163","title":"计算机科学丛书"},"price":"30.00元"},{"rating":{"max":10,"numRaters":132,"average":"8.5","min":0},"subtitle":"C语言描述","author":["(美)安佩尔"],"pubdate":"2006-4","tags":[{"count":306,"name":"编译原理","title":"编译原理"},{"count":115,"name":"虎书","title":"虎书"},{"count":95,"name":"C","title":"C"},{"count":83,"name":"计算机","title":"计算机"},{"count":81,"name":"计算机科学","title":"计算机科学"},{"count":60,"name":"compiler","title":"compiler"},{"count":59,"name":"编译理论","title":"编译理论"},{"count":59,"name":"编译器","title":"编译器"}],"origin_title":"Modern Compiler Implementation in C","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1852496.jpg","binding":"简裝本","translator":["赵克佳","黄春","沈志宇"],"catalog":"第一部分 编译基本原理\n第1章 绪论\n1.1 模块与接口\n1.2 工具和软件\n1.3 树语言的数据结构\n程序设计：直线式程序解释器\n推荐阅读\n习题\n第2章 词法分析\n2.1 词法单词\n2.2 正则表达式\n2.3 有限自动机\n2.4 非确定有限自动机\n2.4.1 将正则表达式转换为NFA\n2.4.2 将NFA转换为DFA\n2.5 Lex：词法分析器的生成器\n程序设计：词法分析\n推荐阅读\n习题\n第3章 语法分析\n3.1 上下文无关文法\n3.1.1 推导\n3.1.2 语法分析树\n3.1.3 二义性文法\n3.1.4 文件结束符\n3.2 预测分析\n3.2.1 FIRST集合和FOLLOW集合\n3.2.2 构造一个预测分析器\n3.2.3 消除左递归\n3.2.4 提取左因子\n3.2.5 错误恢复\n3.3 LR分析\n3.3.1 LR分析引擎\n3.3.2 LR(0)分析器生成器\n3.3.3 SLR分析器的生成\n3.3.4 LR(1)项和LR(1)分析表\n3.3.5 LALR(1)分析表\n3.3.6 各类文法的层次\n3.3.7 二义性文法的LR分析\n3.4 使用分析器的生成器\n3.4.1 冲突\n3.4.2 优先级指导\n3.4.3 语法和语义\n3.5 错误恢复\n3.5.1 用error符号恢复\n3.5.2 全局错误修复\n程序设计：语法分析\n推荐阅读\n习题\n第4章 抽象语法\n4.1 语义动作\n4.1.1 递归下降\n4.1.2 Yacc生成的分析器\n4.1.3 语义动作的解释器\n4.2 抽象语法分析树\n4.2.1 位置\n4.2.2 Tiger的抽象语法\n程序设计：抽象语法\n推荐阅读\n习题\n第5章 语义分析\n5.1 符号表\n5.1.1 多个符号表\n5.1.2 高效的命令式风格符号表\n5.1.3 高效的函数式符号表\n5.1.4 Tiger编译器的符号\n5.1.5 函数式风格的符号表\n5.2 Tiger编译器的绑定\n5.3 表达式的类型检查\n5.4 声明的类型检查\n5.4.1 变量声明\n5.4.2 类型声明\n5.4.3 函数声明\n5.4.4 递归声明\n程序设计：类型检查\n习题\n第6章 活动记录\n6.1 栈帧\n6.1.1 帧指针\n6.1.2 寄存器\n6.1.3 参数传递\n6.1.4 返回地址\n6.1.5 栈帧内的变量\n6.1.6 静态链\n6.2 Tiger编译器的栈帧\n6.2.1 栈帧描述的表示\n6.2.2 局部变量\n6.2.3 计算逃逸变量\n6.2.4 临时变量和标号\n6.2.5 两层抽象\n6.2.6 管理静态链\n6.2.7 追踪层次信息\n程序设计：栈帧\n推荐阅读\n习题\n第7章 翻译成中间代码\n7.1 中间表示树\n7.2 翻译为树中间语言\n7.2.1 表达式的种类\n7.2.2 简单变量\n7.2.3 追随静态链\n7.2.4 数组变量\n7.2.5 结构化的左值\n7.2.6 下标和域选择\n7.2.7 关于安全性的劝告\n7.2.8 算术操作\n7.2.9 条件表达式\n7.2.10 字符串\n7.2.11 记录和数组的创建\n7.2.12 while循环\n7.2.13 for循环\n7.2.14 函数调用\n7.3 声明\n7.3.1 变量定义\n7.3.2 函数定义\n7.3.3 片段\n程序设计：翻译成树\n习题\n第8章 基本块和轨迹\n8.1 规范树\n8.1.1 ESEQ的转换\n8.1.2 一般重写规则\n8.1.3 将CALL移到顶层\n8.1.4 线性语句表\n8.2 处理条件分支\n8.2.1 基本块\n8.2.2 轨迹\n8.2.3 完善\n8.2.4 最优轨迹\n推荐阅读\n习题\n第9章 指令选择\n9.1 指令选择算法\n9.1.1 Maximal Munch算法\n9.1.2 动态规划\n9.1.3 树文法\n9.1.4 快速匹配\n9.1.5 覆盖算法的效率\n9.2 CISC机器\n9.3 Tiger编译器的指令选择\n9.3.1 抽象的汇编语言指令\n9.3.2 生成汇编指令\n9.3.3 过程调用\n9.3.4 无帧指针的情形\n程序设计：指令选择\n推荐阅读\n习题\n第10章 活跃分析\n10.1 数据流方程的解\n10.1.1 活跃性计算\n10.1.2 集合的表示\n10.1.3 时间复杂度\n10.1.4 最小不动点\n10.1.5 静态活跃性与动态活跃性\n10.1.6 冲突图\n10.2 Tiger编译器的活跃分析\n10.2.1 图\n10.2.2 控制流图\n10.2.3 活跃分析\n程序设计：构造流图\n程序设计：活跃分析模块\n习题\n第11章 寄存器分配\n11.1 通过简化进行着色\n11.2 合并\n11.3 预着色的结点\n11.3.1 机器寄存器的临时副本\n11.3.2 调用者保护的寄存器和被调用者保护的寄存器\n11.3.3 含预着色结点的例子\n11.4 图着色的实现\n11.4.1 传送指令工作表的管理\n11.4.2 数据结构\n11.4.3 程序代码\n11.5 针对树的寄存器分配\n程序设计：图着色\n推荐阅读\n习题\n第12章 整合为一体\n程序设计：过程入口\/出口\n程序设计：创建一个可运行的编译器\n第二部分 高级主题\n第13章 垃圾收集\n13.1 标记-清扫式收集\n13.2 引用计数\n13.3 复制式收集\n13.4 分代收集\n13.5 增量式收集\n13.6 Baker算法\n13.7 编译器接口\n13.7.1 快速分配\n13.7.2 数据布局的描述\n13.7.3 导出指针\n程序设计：描述字\n程序设计：垃圾收集\n推荐阅读\n习题\n第14章 面向对象的语言\n14.1 类\n14.2 数据域的单继承性\n14.3 多继承性\n14.4 测试类成员关系\n14.5 私有域和私有方法\n14.6 无类语言\n14.7 向对象程序的优化\n程序设计：OBJECT Tiger\n推荐阅读\n习题\n第15章 函数式程序设计语言\n15.1 一个简单的函数式语言\n15.2 闭包\n15.3 不变的变量\n15.3.1 基于延续的……I\/O226\n15.3.2 语言上的变化\n15.3.3 纯函数式语言的优化\n15.4 内联扩展\n15.5 闭包变换\n15.6 高效的尾递归\n15.7 懒惰计算\n15.7.1 传名调用计算\n15.7.2 按需调用\n15.7.3 懒惰程序的计算\n15.7.4 懒惰函数式程序的优化\n15.7.5 严格性分析\n推荐阅读\n程序设计：编译函数式语言\n习题\n第16章 多态类型\n16.1 参数多态性\n16.1.1 显式带类型的多态语言\n16.1.2 多态类型的检查\n16.2 类型推论\n16.2.1 一个隐式类型的多态语言\n16.2.2 类型推论算法\n16.2.3 递归的数据类型\n16.2.4 Hindley Milner类型的能力\n16.3 多态变量的表示\n16.3.1 多态函数的扩展\n16.3.2 完全的装箱转换\n16.3.3 基于强制的表示分析\n16.3.4 将类型作为运行时参数传递\n16.4 静态重载的解决方法\n推荐阅读\n习题\n第17章 数据流分析\n17.1 流分析使用的中间表示\n17.2 各种数据流分析\n17.2.1 到达定值\n17.2.2 可用表达式\n17.2.3 到达表达式\n17.2.4 活跃分析\n17.3 使用数据流分析结果的几种转换\n17.3.1 公共子表达式删除\n17.3.2 常数传播\n17.3.3 复写传播\n17.3.4 死代码删除\n17.4 加快数据流分析\n17.4.1 位向量\n17.4.2 基本块\n17.4.3 结点排序\n17.4.4 使用-定值链和定值-使用链\n17.4.5 工作表算法\n17.4.6 增量式数据流分析\n17.5 别名分析\n17.5.1 基于类型的别名分析\n17.5.2 基于流的别名分析\n17.5.3 使用可能别名信息\n17.5.4 严格的纯函数式语言中的别名分析\n推荐阅读\n习题\n第18章 循环优化\n18.1 必经结点\n18.1.1 寻找必经结点的算法\n18.1.2 直接必经结点\n18.1.3 循环\n18.1.4 循环前置结点\n18.2 循环不变量计算\n18.3 归纳变量\n18.3.1 发现归纳变量\n18.3.2 强度削弱\n18.3.3 删除\n18.3.4 重写比较\n18.4 数组边界检查\n18.5 循环展开\n推荐阅读\n习题\n第19章 静态单赋值形式\n19.1 转化为SSA形式\n19.1.1 插入Φ函数的标准\n19.1.2 必经结点边界\n19.1.3 插入Φ函数\n19.1.4 变量重命名\n19.1.5 边分割\n19.2 必经结点树的高效计算\n19.2.1 深度优先生成树\n19.2.2 半必经结点\n19.2.3 Lengauer Tarjan算法\n19.3 使用SSA的优化算法\n19.3.1 死代码删除\n19.3.2 简单的常数传播\n19.3.3 条件常数传播\n19.3.4 保持必经结点性质\n19.4 数组、指针和存储器\n19.5 控制依赖图\n19.6 从SSA形式转变回来\n19.7 函数式中间形式\n推荐阅读\n习题\n第20章 流水和调度\n20.1 没有资源约束时的循环调度\n20.2 有资源约束的循环流水\n20.2.1 模调度\n20.2.2 寻找最小的启动间距\n20.2.3 其他控制流\n20.2.4 编译器应该调度指令吗\n20.3 分支预测\n20.3.1 静态分支预测\n20.3.2 编译器应该预测分支吗\n推荐阅读\n习题\n第21章 存储层次\n21.1 cache的组织结构\n21.2 cache块对齐\n21.3 预取\n21.4 循环交换\n21.5 分块\n21.6 垃圾收集和存储层次\n推荐阅读\n习题\n附录 Tiger语言参考手册\n参考文献\n索引","pages":"385","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s1852496.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s1852496.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1852496.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1806974\/","id":"1806974","publisher":"人民邮电出版社","isbn10":"7115145520","isbn13":"9787115145529","title":"现代编译原理","url":"https:\/\/api.douban.com\/v2\/book\/1806974","alt_title":"Modern Compiler Implementation in C","author_intro":"","summary":"《现代编译原理:C语言描述》全面讲述了现代编译器的结构、编译算法和实现方法，是Andrew w．Apple的“虎书”——Modern Compiler Implementation——“红、蓝、绿”三序列之一。这三本书的内容基本相同。但是使用不同的语言来实现书中给出的一个编译器。本书使用的是更适合广大读者的c语言，而另外两本书分别采用ML语言和Java语言。本书的另一个特点是增加了一些其他编译原理教科书没有涉及的内容。前端增加了面向对象的程序设计语言、函数式程序设计语言等现代语言的编译实现方法，后端增加了针对现代计算机体系结构特征的一些比较成熟的优化方法。这部分内容展现了现代商业编译器需解决的一些关键问题，开拓了学生的视野，为学生未来进行更深入的研究奠定了基础。\n\n《现代编译原理:C语言描述》全面讲述了现代编译器的各个组成部分，包括词法分析、语法分析、抽象语法、语义检查、中间代码表示、指令选择、数据流分析、寄存器分配以及运行时系统等。全书分成两部分，第一部分是编译的基础知识，适用于第一门编译原理课程(一个学期)；第二部分是高级主题，包括面向对象语言和函数语言、垃圾收集、循环优化、ssA(静态单赋值)形式、循环调度、存储结构优化等，适合于后续课程或研究生教学。书中专门为学生提供了一个用C语言编写的实习项目，包括前端和后端设计，学生可以在一学期内创建一个功能完整的编译器。","series":{"id":"18507","title":"图灵计算机科学丛书"},"price":"45.00元"},{"rating":{"max":10,"numRaters":137,"average":"9.1","min":0},"subtitle":"编写高质量C语言代码","author":["Steve Maguire"],"pubdate":"2009.2","tags":[{"count":297,"name":"编程","title":"编程"},{"count":250,"name":"C","title":"C"},{"count":153,"name":"C语言","title":"C语言"},{"count":102,"name":"程序设计","title":"程序设计"},{"count":100,"name":"计算机","title":"计算机"},{"count":81,"name":"Programming","title":"Programming"},{"count":71,"name":"C\/C++","title":"C\/C++"},{"count":67,"name":"经典","title":"经典"}],"origin_title":"Writing Solid Code","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s3529626.jpg","binding":"","translator":[],"catalog":"1 a hypothetical compiler\n2 assert yourself\n3 fortify your subsystems\n4 step through your code\n5 candy-machine interfaces\n6 risky business\n7 treacheries of the trade\n8 the rest is attitude\nepilogue where do you go from here?\nappendix a coding checklists\nappendix b memory logging routines\nappendix c answers\nreferences\nindex","pages":"256","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s3529626.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s3529626.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s3529626.jpg"},"alt":"https:\/\/book.douban.com\/subject\/3406939\/","id":"3406939","publisher":"人民邮电出版社","isbn10":"7115193169","isbn13":"9787115193162","title":"编程精粹","url":"https:\/\/api.douban.com\/v2\/book\/3406939","alt_title":"Writing Solid Code","author_intro":"","summary":"编写高质量的、没有bug的程序，是每位程序员所追求的目标。但随着软件规模越来越大，功能日趋复杂，这一目标变得越来越困难。\n本书揭示了微软公司应对质量挑战、开发出世界级代码的技术内幕，作者在自己不断探索、实践和思考的基础上，系统总结了多年来指导微软各团队的经验，将其凝聚为许多切实可行的编程实践指导，可谓字字珠玑。正因如此，本书被公认为与《代码大全》齐名的编程技术名著，曾于1993年荣获有软件开发奥斯卡奖之称的Jolt生产效率大奖。书中内容主要针对C语言，但其中的思想对目前的各主流语言编程也完全适用。","series":{"id":"50484","title":"图灵程序设计丛书·C\/C++系列"},"price":"45.00元"},{"rating":{"max":10,"numRaters":462,"average":"8.1","min":0},"subtitle":"—C++\/C语言","author":["林锐","韩永泉"],"pubdate":"2007-5","tags":[{"count":218,"name":"C++","title":"C++"},{"count":154,"name":"编程","title":"编程"},{"count":126,"name":"C\/C++","title":"C\/C++"},{"count":104,"name":"程序设计","title":"程序设计"},{"count":78,"name":"高质量程序设计指南--C++\/c语言","title":"高质量程序设计指南--C++\/c语言"},{"count":70,"name":"计算机","title":"计算机"},{"count":70,"name":"编程风格","title":"编程风格"},{"count":61,"name":"C","title":"C"}],"origin_title":"","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s2660317.jpg","binding":"","translator":[],"catalog":"第1章  高质量软件开发之道\t11.1  软件质量基本概念\t11.1.1  如何理解软件的质量\t11.1.2  提高软件质量的基本方法\t31.1.3  “零缺陷”理念\t41.2  细说软件质量属性\t41.2.1  正确性\t41.2.2  健壮性\t51.2.3  可靠性\t51.2.4  性能\t61.2.5  易用性\t71.2.6  清晰性\t71.2.7  安全性\t71.2.8  可扩展性\t81.2.9  兼容性\t81.2.10  可移植性\t81.3  人们关注的不仅仅是质量\t91.3.1  质量、生产率和成本之间的关系\t91.3.2  软件过程改进的基本概念\t111.4  高质量软件开发的基本方法\t131.4.1  建立软件过程规范\t131.4.2  复用\t151.4.3  分而治之\t161.4.4  优化与折中\t171.4.5  技术评审\t181.4.6  测试\t191.4.7  质量保证\t211.4.8  改错\t221.5  关于软件开发的一些常识和思考\t241.5.1  有最好的编程语言吗\t241.5.2  编程是一门艺术吗\t241.5.3  编程时应该多使用技巧吗\t241.5.4  换更快的计算机还是换更快的算法\t251.5.5  错误是否应该分等级\t251.5.6  一些错误的观念\t251.6  小结\t26第2章  编程语言发展简史\t272.1  编程语言大事记\t272.2  Ada的故事\t302.3  C\/C++发展简史\t312.4  Borland与Microsoft之争\t322.5  Java阵营与Microsoft的较量\t332.6  小结\t36第3章  程序的基本概念\t373.1  程序设计语言\t373.2  语言实现\t383.3  程序库\t403.4  开发环境\t403.5  程序的工作原理\t413.6  良好的编程习惯\t42第4章  C++\/C程序设计入门\t454.1  C++\/C程序的基本概念\t454.1.1  启动函数main()\t454.1.2  命令行参数\t474.1.3  内部名称\t484.1.4  连接规范\t494.1.5  变量及其初始化\t514.1.6  C Runtime Library\t524.1.7  编译时和运行时的不同\t524.1.8  编译单元和独立编译技术\t544.2  基本数据类型和内存映像\t544.3  类型转换\t564.3.1  隐式转换\t564.3.2  强制转换\t584.4  标识符\t604.5  转义序列\t614.6  运算符\t624.7  表达式\t634.8  基本控制结构\t654.9  选择（判断）结构\t654.9.1  布尔变量与零值比较\t664.9.2  整型变量与零值比较\t674.9.3  浮点变量与零值比较\t674.9.4  指针变量与零值比较\t694.9.5  对if语句的补充说明\t704.9.6  switch结构\t704.10   循环（重复）结构\t714.10.1  for语句的循环控制变量\t724.10.2  循环语句的效率\t734.11  结构化程序设计原理\t784.12  goto\/continue\/break语句\t794.13  示例\t80第5章  C++\/C常量\t855.1  认识常量\t855.1.1  字面常量\t855.1.2  符号常量\t865.1.3  契约性常量\t875.1.4  枚举常量\t875.2  正确定义符号常量\t875.3  const与#define的比较\t885.4  类中的常量\t895.5  实际应用中如何定义常量\t90第6章  C++\/C函数设计基础\t956.1  认识函数\t956.2  函数原型和定义\t966.3  函数调用方式\t976.4  认识函数堆栈\t996.5  函数调用规范\t1006.6  函数连接规范\t1016.7  参数传递规则\t1026.8  返回值的规则\t1046.9  函数内部实现的规则\t1076.10  存储类型及作用域规则\t1096.10.1  存储类型\t1096.10.2  作用域规则\t1106.10.3  连接类型\t1116.11  递归函数\t1136.12  使用断言\t1166.13  使用const提高函数的健壮性\t1186.13.1  用const修饰函数的参数\t1186.13.2  用const修饰函数的返回值\t119第7章  C++\/C指针、数组和字符串\t1217.1  指针\t1217.1.1  指针的本质\t1217.1.2  指针的类型及其支持的运算\t1237.1.3  指针传递\t1257.2  数组\t1267.2.1  数组的本质\t1267.2.2  二维数组\t1287.2.3  数组传递\t1297.2.4  动态创建、初始化和删除数组的方法\t1317.3  字符数组、字符指针和字符串\t1337.3.1  字符数组、字符串和‘\\0’的关系\t1337.3.2  字符指针的误区\t1347.3.3  字符串拷贝和比较\t1347.4  函数指针\t1357.5  引用和指针的比较\t137第8章  C++\/C高级数据类型\t1418.1  结构（Struct）\t1418.1.1  关键字struct与class的困惑\t1418.1.2  使用struct\t1428.1.3  位域\t1458.1.4  成员对齐\t1478.2  联合（Union）\t1598.3  枚举（Enum）\t1618.4  文件\t163第9章  C++\/C编译预处理\t1659.1  文件包含\t1659.1.1  内部包含卫哨和外部包含卫哨\t1659.1.2  头文件包含的合理顺序\t1669.2  宏定义\t1669.3  条件编译\t1699.3.1  #if、#elif和#else\t1699.3.2  #ifdef 和 #ifndef\t1709.4  #error\t1719.5  #pragma\t1719.6  #和##运算符\t1719.7  预定义符号常量\t172第10章  C++\/C文件结构和程序版式\t17510.1  程序文件的目录结构\t17510.2  文件的结构\t17610.2.1  头文件的用途和结构\t17610.2.2  版权和版本信息\t17710.2.3  源文件结构\t17810.3  代码的版式\t17810.3.1  适当的空行\t17810.3.2  代码行及行内空格\t17910.3.3  长行拆分\t18010.3.4  对齐与缩进\t18110.3.5  修饰符的位置\t18210.3.6  注释风格\t18210.3.7  ADT\/UDT版式\t183第11章  C++\/C应用程序命名规则\t18511.1  共性规则\t18511.2  简单的Windows应用程序命名\t186第12章  C++面向对象程序设计方法概述\t18912.1  漫谈面向对象\t18912.2  对象的概念\t19012.3  信息隐藏与类的封装\t19112.4  类的继承特性\t19512.5  类的组合特性\t20012.6  动态特性\t20112.6.1  虚函数\t20212.6.2  抽象基类\t20212.6.3  动态绑定\t20512.6.4  运行时多态\t20712.6.5  多态数组\t20812.7  C++对象模型\t21512.7.1  对象的内存映像\t21512.7.2  隐含成员\t22412.7.3  C++编译器如何处理成员函数\t22512.7.4  C++编译器如何处理静态成员\t22512.8  小结\t226第13章  对象的初始化、拷贝和析构\t22913.1  构造函数与析构函数的起源\t22913.2  为什么需要构造函数和析构函数\t23013.3  构造函数的成员初始化列表\t23213.4  对象的构造和析构次序\t23413.5  构造函数和析构函数的调用时机\t23513.6  构造函数和赋值函数的重载\t23613.7  示例：类String的构造函数和析构函数\t23813.8  何时应该定义拷贝构造函数和拷贝赋值函数\t23913.9  示例：类String的拷贝构造函数和拷贝赋值函数\t24013.10  用偷懒的办法处理拷贝构造函数和拷贝赋值函数\t24213.11  如何实现派生类的基本函数\t243第14章  C++函数的高级特性\t24714.1  函数重载的概念\t24714.1.1  重载的起源\t24714.1.2  重载是如何实现的\t24714.1.3  当心隐式类型转换导致重载函数产生二义性\t24914.2  成员函数的重载、覆盖与隐藏\t25014.2.1  重载与覆盖\t25014.2.2  令人迷惑的隐藏规则\t25114.2.3  摆脱隐藏\t25314.3  参数的默认值\t25414.4  运算符重载\t25514.4.1  基本概念\t25514.4.2  运算符重载的特殊性\t25614.4.3  不能重载的运算符\t25714.4.4  重载++和--\t25714.5  函数内联\t25914.5.1  用函数内联取代宏\t25914.5.2  内联函数的编程风格\t26014.5.3  慎用内联\t26114.6  类型转换函数\t26114.7  const成员函数\t264第15章  C++异常处理和RTTI\t26715.1  为什么要使用异常处理\t26715.2  C++异常处理\t26815.2.1  异常处理的原理\t26815.2.2  异常类型和异常对象\t26915.2.3  异常处理的语法结构\t27015.2.4  异常的类型匹配规则\t27215.2.5  异常说明及其冲突\t27215.2.6  当异常抛出时局部对象如何释放\t27315.2.7  对象构造和析构期间的异常\t27315.2.8  如何使用好异常处理技术\t27515.2.9  C++的标准异常\t27815.3  虚函数面临的难题\t27815.4  RTTI及其构成\t28015.4.1  起源\t28015.4.2  typeid运算符\t28115.4.3  dynamic_cast<>运算符\t28315.4.4  RTTI的魅力与代价\t285第16章  内存管理\t28716.1  内存分配方式\t28716.2  常见的内存错误及其对策\t28816.3  指针参数是如何传递内存的\t28916.4  free和delete把指针怎么啦\t29116.5  动态内存会被自动释放吗\t29216.6  杜绝“野指针”\t29216.7  有了malloc\/free为什么还要new\/delete\t29316.8  malloc\/free的使用要点\t29516.9  new有3种使用方式\t29616.9.1  plain new\/delete\t29616.9.2  nothrow new\/delete\t29716.9.3  placement new\/delete\t29716.10  new\/delete的使用要点\t30016.11  内存耗尽怎么办\t30116.12  用对象模拟指针\t30216.13  泛型指针auto_ptr\t30516.14  带有引用计数的智能指针\t30616.15  智能指针作为容器元素\t310第17章  学习和使用STL\t32317.1  STL简介\t32317.2  STL头文件的分布\t32417.2.1  容器类\t32417.2.2  泛型算法\t32517.2.3  迭代器\t32517.2.4  数学运算库\t32517.2.5  通用工具\t32517.2.6  其他头文件\t32617.3  容器设计原理\t32617.3.1  内存映像\t32617.3.2  存储方式和访问方式\t32717.3.3  顺序容器和关联式容器的比较\t32817.3.4  如何遍历容器\t33117.3.5  存储空间重分配问题\t33217.3.6  什么样的对象才能作为STL容器的元素\t33317.4  迭代器\t33417.4.1  迭代器的本质\t33417.4.2  迭代器失效及其危险性\t33817.5  存储分配器\t34617.6  适配器\t34717.7  泛型算法\t35017.8  一些特殊的容器\t35417.8.1  string类\t35417.8.2  bitset并非set\t35517.8.3  节省存储空间的vector<bool>\t35717.8.4  空容器\t35817.9  STL容器特征总结\t36017.10  STL使用心得\t362附录A  C++\/C试题\t365附录B  C++\/C试题答案与评分标准\t369附录C  大学十年\t375附录D  《大学十年》后记\t393附录E  术语与缩写解释\t395参考文献\t397","pages":"394","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s2660317.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s2660317.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s2660317.jpg"},"alt":"https:\/\/book.douban.com\/subject\/2116929\/","id":"2116929","publisher":"电子工业","isbn10":"7121041146","isbn13":"9787121041143","title":"高质量程序设计指南","url":"https:\/\/api.douban.com\/v2\/book\/2116929","alt_title":"","author_intro":"林锐，国内知名的软件工程专家和研发管理咨询师。西安电子科技大学硕士，浙江大学计算机系博士。2000年7月加入上海贝尔有限公司，从事软件工程和CMM的研究推广工作。2003年7月当选为Alcatel集团技术专家。2004年初创建上海漫索计算机科技有限公司(http：／／www.chinaspis.com)，致力于创建适合国内IT企业需求的研发管理解决方案，包括方法论和软件产品。已出版著作七部。","summary":"《高质量程序设计指南:C++、C语言》(第3版)以轻松幽默的笔调向读者论述了高质量软件开发方法与C++\/C编程规范。它是作者多年从事软件开发工作的经验总结。《高质量程序设计指南:C++、C语言》(第3版)共17章，第1章到第4章重点介绍软件质量和基本的程序设计方法；第5章到第16章重点阐述 C++\/C编程风格、面向对象程序设计方法和一些技术专题；第17章阐述STL 的原理和使用方法。\n　　《高质量程序设计指南:C++、C语言》(第3版)第1版和第2版部分章节曾经在Internet上广泛流传，被国内IT企业的不少软件开发人员采用。《高质量程序设计指南:C++、C语言》(第3版)的附录C《大学十年》是作者在网上发表的一个短篇传记，文中所描述的充满激情的学习和生活态度，感染了大批莘莘学子。","price":"39.80元"},{"rating":{"max":10,"numRaters":78,"average":"9.1","min":0},"subtitle":"C语言描述","author":["韦斯(Mark Allen Weiss)"],"pubdate":"2010-8","tags":[{"count":165,"name":"数据结构","title":"数据结构"},{"count":148,"name":"算法","title":"算法"},{"count":89,"name":"计算机","title":"计算机"},{"count":63,"name":"C","title":"C"},{"count":45,"name":"Algorithms","title":"Algorithms"},{"count":41,"name":"计算机科学","title":"计算机科学"},{"count":38,"name":"编程","title":"编程"},{"count":16,"name":"数据结构与算法","title":"数据结构与算法"}],"origin_title":"Data Structures and Algorithm Analysis in C","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s4459394.jpg","binding":"平装","translator":[],"catalog":"1  Introduction  1.1. What's the Book About?  1.2. Mathematics Review    1.2.1. Exponents    1.2.2. Logarithms    1.2.3. Series    1.2.4. Modular Arithmetic    1.2.5. The P Word  1.3. A Brief Introduction to Recursion    Summary    Exercises    References2  Algorithm Analysis3  Lists, Stacks, and Queues4  Trees5  Hashing6  Priority Queues (Heaps)7  Sorting 2198  The Disjoint Set ADT9  Graph Algorithms10  Algorithm Design Techniques11  Amortized Analysis12  Advanced Data Structures and Implementation","pages":"511","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s4459394.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s4459394.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s4459394.jpg"},"alt":"https:\/\/book.douban.com\/subject\/4924153\/","id":"4924153","publisher":"机械工业出版社","isbn10":"7111312805","isbn13":"9787111312802","title":"数据结构与算法分析","url":"https:\/\/api.douban.com\/v2\/book\/4924153","alt_title":"Data Structures and Algorithm Analysis in C","author_intro":"Mark Allen Weiss 1987年在普林斯顿大学获得计算机科学博士学位。师从Roberl Sedgewick，现任美国佛罗里达国际大学计算与信息科学学院教授。他曾担任全美AP(Advanced Placement)考试计算机学科委员会主席。其主要研究方向是数据结构、算法和教育学。","summary":"《数据结构与算法分析:C语言描述》曾被评为20世纪顶尖的30部计算机著作之一，作者在数据结构和算法分析方面卓有建树，他的数据结构和算法分析的著作尤其畅销，并受到广泛好评，已被世界500余所大学选作教材。\n在《数据结构与算法分析:C语言描述》中，作者精炼并强化了他对算法和数据结构方面创新的处理方法。通过C程序的实现，着重阐述了抽象数据类型的概念，并对算法的效率、性能和运行时间进行了分析。\n《数据结构与算法分析:C语言描述》特色：着重讨论了算法设计技巧，包括贪婪算法、分治算法、动态规划、随机化算法以及回溯算法。系统介绍了当前流行的论题和新的数据结构，如斐波那契堆、斜堆、二项队列、跳跃表和伸展树。详细讨论了摊还分析，考查书中介绍的一些高级数据结构。增加了高级数据结构及其实现的内容，包括红黑树、自顶向下伸展树、treap树、k-d树、配对堆等。整合了堆排序平均情况分析的一些新结果。","series":{"id":"1895","title":"经典原版书库"},"price":"45.00元"},{"rating":{"max":10,"numRaters":1802,"average":"9.1","min":0},"subtitle":"（第五版）","author":["Stephen Prata","云巅工作室"],"pubdate":"2005-2-1","tags":[{"count":915,"name":"编程","title":"编程"},{"count":840,"name":"c","title":"c"},{"count":830,"name":"c语言","title":"c语言"},{"count":611,"name":"计算机","title":"计算机"},{"count":480,"name":"程序设计","title":"程序设计"},{"count":379,"name":"经典","title":"经典"},{"count":378,"name":"C","title":"C"},{"count":243,"name":"programming","title":"programming"}],"origin_title":"","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1308874.jpg","binding":"平装(无盘)","translator":["云巅工作室"],"catalog":"第1章 概览\n1.1 C语言的起源\n1.2 使用C语言的理由\n1.3 C语言的发展方向\n1.4 计算机工作的基本原理\n1.5 高级计算机语言和编译器\n1.6 使用C语言的7个步骤\n1.7 编程机制\n1.8 语言标准\n1.9 本书的组织结构\n1.10 本书体例\n1.11 总结\n1.12 复习题\n1.13 编程练习\n第2章 C语言概述\n2.1 C语言的一个简单实例\n2.2 实例说明\n2.3 一个简单程序的结构\n2.4 使程序可读的技巧\n2.5 更进一步\n2.6 多个函数\n2.7 调试\n2.8 关键字和保留标识符\n2.9 关键概念\n2.10 总结\n2.11 复习题\n2.12 编程练习\n第3章 数据和C\n3.1 示例程序\n3.2 变量与常量数据\n3.3 数据：数据类型关键字\n3.4 C数据类型\n3.5 使用数据类型\n3.6 参数和易犯的错误\n3.7 另一个例子：转义序列\n3.8 关键概念\n3.9 总结\n3.10 复习题\n3.11 编程练习\n第4章 字符串和格式化输入\/输出\n4.1 前导程序\n4.2 字符串简介\n4.3 常量和C预处理器\n4.4 研究和利用printf（）和scanf（）\n4.5 关键概念\n4.6 总结\n4.7 复习题\n4.8 编程练习\n第5章 运算符、表达式和语句\n5.1 循环简介\n5.2 基本运算符\n5.3 其他运算符\n5.4 表达式和语句\n5.5 类型转换\n5.6 带有参数的函数\n5.7 一个示例程序\n5.8 关键概念\n5.9 总结\n5.10 复习题\n5.11 编程练习\n第6章 C控制语句：循环\n6.1 再探while循环\n6.2 while语句\n6.4 不确定循环与计数循环\n6.5 for循环\n6.6 更多赋值运算符：+=、-=、*=、\/=和%=\n6.7 逗号运算符\n6.8 退出条件循环：do while\n6.9 选择哪种循环\n6.10 嵌套循环\n6.11 数组\n6.12 使用函数返回值的循环例子\n6.13 关键概念\n6.14 总结\n6.15 复习题\n6.16 编程练习\n第7章 C控制语句：分支和跳转\n7.1 if语句\n7.2 在if语句中添加else关键字\n7.3 获得逻辑性\n7.4 一个统计字数的程序\n7.5 条件运算符?:\n7.6 循环辅助手段：continue和break\n7.7 多重选择：switch和break\n7.8 goto语句\n7.9 关键概念\n7.10 总结\n7.11 复习题\n7.12 编程练习\n第8章 字符输入\/输出和输入确认\n8.1 单字符I\/O：getchar（）和putchar（）\n8.2 缓冲区\n8.3 终止键盘输入\n8.5 创建一个更友好的用户界面\n8.6 输入确认\n8.7 菜单浏览\n8.8 关键概念\n8.9 总结\n8.10 复习题\n8.11 编程练习\n第9章 函数\n9.1 函数概述\n9.2 ANSI C的函数原型\n9.3 递归\n9.4 多源代码文件程序的编译\n9.5 地址运算符：&\n9.6 改变调用函数中的变量\n9.7 指针简介\n9.8 关键概念\n9.9 总结\n9.10 复习题\n9.11 编程练习\n第10章 数组和指针\n10.1 数组\n10.2 多维数组\n10.3 指针和数组\n10.4 函数、数组和指针\n10.5 指针操作\n10.6 保护数组内容\n10.7 指针和多维数组\n10.8 变长数组（VLA）\n10.9 复合文字\n10.10 关键概念\n10.11 总结\n10.12 复习题\n10.13 编程练习\n第11章 字符串和字符串函数\n11.1 字符串表示和字符串I\/O\n11.2 字符串输入\n11.3 字符串输出\n11.4 自定义字符串输入\/输出函数\n11.5 字符串函数\n11.6 字符串例子：字符串排序\n11.7 ctype.h字符函数和字符串\n11.8 命令行参数\n11.9 把字符串转换为数字\n11.10 关键概念\n11.11 总结\n11.12 复习题\n11.13 编程练习\n第12章 存储类、链接和内存管理\n12.1 存储类\n12.2 存储类说明符\n12.3 存储类和函数\n12.4 随机数函数和静态变量\n12.5 掷骰子\n12.6 分配内存：malloc（）和free（）\n12.7 ANSI C的类型限定词\n12.8 关键概念\n12.9 总结\n12.10 复习题\n12.11 编程练习\n第13章 文件输入\/输出\n13.1 和文件进行通信\n13.2 标准I\/O\n13.3 一个简单的文件压缩程序\n13.4 文件I\/O：fprintf ( )、fscanf ( )、fgets ( )和fputs ( )函数\n13.5 随机存取：fseek（）和ftell（）函数\n13.6 标准I\/O内幕\n13.7 其他标准I\/O函数\n13.8 关键概念\n13.9 总结\n13.10 复习题\n13.11 编程练习\n第14章 结构和其他数据形式\n14.1 示例问题：创建图书目录\n14.2 建立结构声明\n14.3 定义结构变量\n14.4 结构数组\n14.5 嵌套结构\n14.6 指向结构的指针\n14.7 向函数传递结构信息\n14.8 把结构内容保存到文件中\n14.9 结构：下一步是什么\n14.10 联合简介\n14.11 枚举类型\n14.12 typedef简介\n14.13 奇特的声明\n14.14 函数和指针\n14.15 关键概念\n14.16 总结\n14.17 复习题\n14.18 编程练习\n第15章 位操作\n15.1 二进制数、位和字节\n15.2 其他基数\n15.3 C的位运算符\n15.4 位字段\n15.5 关键概念\n15.6 总结\n15.7 复习题\n15.8 编程练习\n第16章 C预处理器和C库\n16.1 翻译程序的第一步\n16.2 明显常量：#define\n16.3 在#define中使用参数\n16.4 宏，还是函数\n16.5 文件包含：＃include\n16.6 其他指令\n16.7 内联函数\n16.8 C库\n16.9 数学库\n16.10 通用工具库\n16.11 诊断库\n16.12 string.h库中的memcpy（）和memmove（）\n16.13 可变参数：stdarg.h\n16.14 关键概念\n16.15 总结\n16.16 复习题\n16.17 编程练习\n第17章 高级数据表示\n17.1 研究数据表示\n17.2 从数组到链表\n17.3 抽象数据类型（ADT）\n17.4 队列ADT\n17.5 用队列进行模拟\n17.6 链表与数组\n17.7 二叉搜索树\n17.8 其他说明\n17.9 关键概念\n17.10 总结\n17.11 复习题\n17.12 编程练习\n附录A 复习题答案\n附录B 参考资料","pages":"626","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s1308874.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s1308874.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1308874.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1240002\/","id":"1240002","publisher":"人民邮电出版社","isbn10":"7115130221","isbn13":"9787115130228","title":"C Primer Plus","url":"https:\/\/api.douban.com\/v2\/book\/1240002","alt_title":"","author_intro":"普拉塔，在加利福尼亚州的Kentfield的Marin学院教授天文学、物理学和程序设计课程。他在加州工业学院获得学士学位，从加州大学伯克利分校获得博士学位。他最早接触计算机，始于对星河的计算机建模。Stephen已经编写或与他人合作编写了十多本书。其中包括C++Primer Plus和Unix Prinmer Plus。","summary":"《C Primer Plus（第5版）（中文版）》共17章。第1、2章学习C语言编程所需的预备知识。第3到15章介绍了C语言的相关知识，包括数据类型、格式化输入输出、运算符、表达式、流程控制语句、函数、数组和指针、字符串操作、内存管理、位操作等等，知识内容都针对C99标准；另外，第10章强化了对指针的讨论，第12章引入了动态内存分配的概念，这些内容更加适合读者的需求。第16章和第17章讨论了C预处理器和C库函数、高级数据表示（数据结构）方面的内容。附录给出了各章后面复习题、编程练习的答案和丰富的C编程参考资料。","price":"60.00元"},{"rating":{"max":10,"numRaters":1935,"average":"9.2","min":0},"subtitle":"","author":["Peter Van Der Linden"],"pubdate":"2008-2","tags":[{"count":1196,"name":"C语言","title":"C语言"},{"count":681,"name":"编程","title":"编程"},{"count":446,"name":"计算机","title":"计算机"},{"count":405,"name":"c","title":"c"},{"count":387,"name":"C专家编程","title":"C专家编程"},{"count":364,"name":"C\/C++","title":"C\/C++"},{"count":339,"name":"C","title":"C"},{"count":302,"name":"程序设计","title":"程序设计"}],"origin_title":"Expert C Programming: Deep C Secrets","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s5886086.jpg","binding":"平装","translator":["徐波"],"catalog":"第1章 C：穿越时空的迷雾\n1.1 C语言的史前阶段\n1.2 C语言的早期体验\n1.3 标准I\/O库和C预处理器\n1.4 K&R C\n1.5 今日之ANSI C\n1.6 它很棒，但它符合标准吗\n1.7 编译限制\n1.8 ANSI C标准的结构\n1.9 阅读ANSI C标准，寻找乐趣和裨益\n1.10 “安静的改变”究竟有多少安静\n1.11 轻松一下——由编译器定义的Pragmas效果\n第2章 这不是Bug，而是语言特性\n2.1 这关语言特性何事，在Fortran里这就是Bug呀\n2.2 多做之过\n2.3 误做之过\n2.4 少做之过\n2.5 轻松一下——有些特性确实就是Bug\n2.6 参考文献\n第3章 分析C语言的声明\n3.1 只有编译器才会喜欢的语法\n3.2 声明是如何形成的\n3.3 优先级规则\n3.4 通过图表分析C语言的声明\n3.5 typedef可以成为你的朋友\n3.6 typedef int x[10]和#define x int[10]的区别\n3.7 typedef struct foo{ ... foo; }的含义\n3.8 理解所有分析过程的代码段\n3.9 轻松一下——驱动物理实体的软件\n第4章 令人震惊的事实：数组和指针并不相同\n4.1 数组并非指针\n4.2 我的代码为什么无法运行\n4.3 什么是声明，什么是定义\n4.4 使声明与定义相匹配\n4.5 数组和指针的其他区别\n4.6 轻松一下——回文的乐趣\n第5章 对链接的思考\n5.1 函数库、链接和载入\n5.2 动态链接的优点\n5.3 函数库链接的5个特殊秘密\n5.4 警惕Interpositioning\n5.5 产生链接器报告文件\n5.6 轻松一下——看看谁在说话：挑战Turing测验\n第6章 运动的诗章：运行时数据结构\n6.1 a.out及其传说\n6.2 段\n6.3 操作系统在a.out文件里干了些什么\n6.4 C语言运行时系统在a.out里干了些什么\n6.5 当函数被调用时发生了什么：过程活动记录\n6.6 auto和static关键字\n6.7 控制线程\n6.8 setjmp和longjmp\n6.9 UNIX中的堆栈段\n6.10 MS-DOS中的堆栈段\n6.11 有用的C语言工具\n6.12 轻松一下——卡耐基-梅隆大学的编程难题\n6.13 只适用于高级学员阅读的材料\n第7章 对内存的思考\n7.1 Intel 80x86系列\n7.2 Intel 80x86内存模型以及它的工作原理\n7.3 虚拟内存\n7.4 Cache存储器\n7.5 数据段和堆\n7.6 内存泄漏\n7.7 总线错误\n7.8 轻松一下——“Thing King”和“页面游戏”\n第8章 为什么程序员无法分清万圣节和圣诞节\n8.1 Portzebie度量衡系统\n8.2 根据位模式构筑图形\n8.3 在等待时类型发生了变化\n8.4 原型之痛\n8.5 原型在什么地方会失败\n8.6 不需要按回车键就能得到一个字符\n8.7 用C语言实现有限状态机\n8.8 软件比硬件更困难\n8.9 如何进行强制类型转换，为何要进行类型强制转换\n8.10 轻松一下——国际C语言混乱代码大赛\n第9章 再论数组\n9.1 什么时候数组与指针相同\n9.2 为什么会发生混淆\n9.3 为什么C语言把数组形参当作指针\n9.4 数组片段的下标\n9.5 数组和指针可交换性的总结\n9.6 C语言的多维数组\n9.7 轻松一下——软件\/硬件平衡\n第10章 再论指针\n10.1 多维数组的内存布局\n10.2 指针数组就是Iliffe向量\n10.3 在锯齿状数组上使用指针\n10.4 向函数传递一个一维数组\n10.5 使用指针向函数传递一个多维数组\n10.6 使用指针从函数返回一个数组\n10.7 使用指针创建和使用动态数组\n10.8 轻松一下——程序检验的限制\n第11章 你懂得C，所以C++不在话下\n11.1 初识OOP\n11.2 抽象——取事物的本质特性\n11.3 封装——把相关的类型、数据和函数组合在一起\n11.4 展示一些类——用户定义类型享有和预定义类型一样的权限\n11.5 访问控制\n11.6 声明\n11.7 如何调用成员函数\n11.8 继承——复用已经定义的操作\n11.9 多重继承——从两个或更多的基类派生\n11.10 重载——作用于不同类型的同一操作具有相同的名字\n11.11 C++如何进行操作符重载\n11.12 C++的输入\/输出(I\/O)\n11.13 多态——运行时绑定\n11.14 解释\n11.15 C++如何表现多态\n11.16 新奇玩意——多态\n11.17 C++的其他要点\n11.18 如果我的目标是那里，我不会从这里起步\n11.19 它或许过于复杂，但却是惟一可行的方案\n11.20 轻松一下——死亡计算机协会\n11.21 更多阅读材料\n附录A 程序员工作面试的秘密\n附录B 术语表","pages":"291","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s5886086.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s5886086.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s5886086.jpg"},"alt":"https:\/\/book.douban.com\/subject\/2377310\/","id":"2377310","publisher":"人民邮电出版社","isbn10":"7115171807","isbn13":"9787115171801","title":"C专家编程","url":"https:\/\/api.douban.com\/v2\/book\/2377310","alt_title":"Expert C Programming: Deep C Secrets","author_intro":"","summary":"《C专家编程》展示了最优秀的C程序员所使用的编码技巧，并专门开辟了一章对C++的基础知识进行了介绍。\n书中C的历史、语言特性、声明、数组、指针、链接、运行时、内存以及如何进一步学习C++等问题进行了细致的讲解和深入的分析。全书撷取几十个实例进行讲解，对C程序员具有非常高的实用价值。\n本书可以帮助有一定经验的C程序员成为C编程方面的专家，对于具备相当的C语言基础的程序员，本书可以帮助他们站在C的高度了解和学习C++。","series":{"id":"9931","title":"C和C++经典著作"},"price":"45.00元"},{"rating":{"max":10,"numRaters":154,"average":"8.8","min":0},"subtitle":"C标准库“圣经”","author":["P. J. Plauger"],"pubdate":"2009-7","tags":[{"count":228,"name":"C","title":"C"},{"count":196,"name":"C语言","title":"C语言"},{"count":103,"name":"编程","title":"编程"},{"count":102,"name":"标准库","title":"标准库"},{"count":76,"name":"计算机","title":"计算机"},{"count":76,"name":"C\/C++","title":"C\/C++"},{"count":57,"name":"程序设计","title":"程序设计"},{"count":40,"name":"库","title":"库"}],"origin_title":"","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s3820140.jpg","binding":"","translator":["卢红星","徐明亮","霍建同"],"catalog":"第0章　简介. 1\n0.1　背景知识1\n0.2　C 标准的内容 3\n0.3　库的使用7\n0.4　库的实现9\n0.5　库的测试13\n0.6　参考文献15\n0.7　习题15\n第1章　(assert.h)17\n1.1　背景知识17\n1.2　C 标准的内容18\n1.3　(assert.h) 的使用18\n1.4　(assert.h) 的实现20\n1.5　(assert.h) 的测试22\n1.6　参考文献23\n1.7　习题23\n第2章　(ctype.h) 25\n2.1　背景知识25\n2.2　C 标准的内容28\n2.3　(ctype.h) 的使用 30\n2.4　(ctype.h) 的实现 34\n2.5　(ctype.h) 的测试 42\n2.6　参考文献45\n2.7　习题45\n第3章　(errno.h) 47\n3.1　背景知识47\n3.2　C 标准的内容50\n3.3　(errno.h) 的使用 50\n3.4　(errno.h) 的实现 51\n3.5　(errno.h) 的测试 55\n3.6　参考文献55\n3.7　习题55\n第4章　(float.h)57\n4.1　背景知识57\n4.2　C 标准的内容59\n4.3　(float.h) 的使用.62\n4.4　(float.h) 的实现.64\n4.5　(float.h) 的测试.69\n4.6　参考文献71\n4.7　习题72\n第5章　(limits.h)73\n5.1　背景知识73\n5.2　C 标准的内容74\n5.3　(limits.h) 的使用75\n5.4　(limits.h) 的实现77\n5.5　(limits.h) 的测试79\n5.6　参考文献80\n5.7　习题80\n第6章　(locale.h)81\n6.1　背景知识81\n6.2　C 标准的内容84\n6.3　(locale.h) 的使用87\n6.4　(locale.h) 的实现94\n6.5　(locale.h) 的测试 123\n6.6　参考文献.123\n6.7　习题123\n第7章　(math.h)127\n7.1　背景知识.127\n7.2　C 标准的内容 130\n7.3　(math.h) 的使用 135\n7.4　(math.h) 的实现 137\n7.5　(math.h) 的测试 171\n7.6　参考文献.177\n7.7　习题177\n第8章　(setjmp.h).. 181\n8.1　背景知识.181\n8.2　C 标准的内容 184\n8.3　(setjmp.h) 的使用 185\n8.4　(setjmp.h) 的实现 187\n8.5 (setjmp.h) 的测试191\n8.6 参考文献 192\n8.7 习题 192\n第9章　(signal.h) 193\n9.1　背景知识.193\n9.2　C 标准的内容 195\n9.3　(signal.h) 的使用 197\n9.4　(signal.h) 的实现 199\n9.5　(signal.h) 的测试 203\n9.6　参考文献.203\n9.7　习题203\n第10章　(stdarg.h) 205\n10.1　背景知识205\n10.2　C 标准的内容 207\n10.3　(stdarg.h) 的使用 208\n10.4　(stdarg.h) 的实现 211\n10.5　(stdarg.h) 的测试 212\n10.6　参考文献212\n10.7　习题.214\n第11章　(stddef.h) 215\n11.1　背景知识 215\n11.2　C 标准的内容 217\n11.3　(stddef.h) 的使用 217\n11.4　(stddef.h) 的实现 222\n11.5　(stddef.h) 的测试 223\n11.6　参考文献 223\n11.7　习题223\n第12章　(stdio.h) 225\n12.1　背景知识225\n12.2　C 标准的内容 233\n12.3　(stdio.h) 的使用 252\n12.4　(stdio.h) 的实现 274\n12.5　(stdio.h) 的测试 323\n12.6　参考文献325\n12.7　习题.325\n第13章　(stdlib.h) 331\n13.1　背景知识331\n13.2　C 标准的内容 332\n13.3　(stdlib.h) 的使用 342\n13.4　(stdlib.h) 的实现 351\n13.5　(stdlib.h) 的测试 379\n13.6　参考文献379\n13.7　习题.382\n第14章　(string.h) 385\n14.1　背景知识385\n14.2　C 标准的内容 386\n14.3　(string.h) 的使用 392\n14.4　(string.h) 的实现 396\n14.5　(string.h) 的测试 409\n14.6　参考文献409\n14.7　习题.409\n第15章　(time.h) 413\n15.1　背景知识413\n15.2　C 标准的内容 414\n15.3　(time.h) 的使用 418\n15.4　(time.h) 的实现 422\n15.5　(time.h) 的测试440\n15.6　参考文献441\n15.7　习题.441\n附录A　接口 443\n附录B　名字 451\n附录C　术语... 461","pages":"488","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s3820140.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s3820140.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s3820140.jpg"},"alt":"https:\/\/book.douban.com\/subject\/3775842\/","id":"3775842","publisher":"人民邮电出版社","isbn10":"7115172862","isbn13":"9787115172860","title":"C标准库","url":"https:\/\/api.douban.com\/v2\/book\/3775842","alt_title":"","author_intro":"P. J. Plauger  世界著名的软件技术专家，曾任ISO C标准委员会主席，C\/C++ User’s Journal主编，现任ISO C++标准委员会主席。他是C\/C++标准库开发领域的大师，所开发的Dinkumware标准库应用广泛。","summary":"本书是由世界级C语言专家编写的C标准库经典著作。英文版已经重印十多次，影响了几代程序员。\n本书结合C标准的相关部分，精辟地讲述了每一个库函数的使用方法和实现细节，而这正是一个真正的C程序员所必须掌握的。更重要的是，书中给出了实现和测试这些函数的完整源代码，可以让你更深入地学习C语言。不仅如此，本书还讨论了一些即使是最有经验的C程序员通常也不熟悉的知识，比如国际化和独立于区域设置的程序的编写、与构建库相关的概念和设计思想。\n本书结构清晰，内容权威，阐述精辟，对于各层次C 程序员和相关专业高校师生都是一本优秀的参考书。","series":{"id":"50484","title":"图灵程序设计丛书·C\/C++系列"},"price":"79.00元"},{"rating":{"max":10,"numRaters":808,"average":"8.6","min":0},"subtitle":"一本37.5°C的博物馆地图","author":["沈辛成"],"pubdate":"2017-5-20","tags":[{"count":588,"name":"纽约","title":"纽约"},{"count":560,"name":"博物馆","title":"博物馆"},{"count":455,"name":"旅行","title":"旅行"},{"count":370,"name":"美国","title":"美国"},{"count":337,"name":"艺术","title":"艺术"},{"count":281,"name":"城市","title":"城市"},{"count":214,"name":"历史","title":"历史"},{"count":193,"name":"生活","title":"生活"}],"origin_title":"","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s29478001.jpg","binding":"精装","translator":[],"catalog":"指南与致谢\n有点像跋的序\n第一章 你这个种族主义者\n纽约深度游线路一：黑色与白色\n第二章 没有华尔的街\n纽约深度游线路二：革命与资本\n第三章 纽约水故事\n纽约深度游线路三：饮水与思源\n第四章 我的画报你的城\n纽约深度游之四：寻根与漂流\n第五章 曼哈顿是平的\n纽约深度游之五：贫穷与富裕\n第六章 开往昨天的地铁\n纽约深度游之六：地下与地上\n第七章 美国的归美国，纽约的归纽约\n纽约深度游之七：美国与欧洲\n第八章 不知道为什么就流泪\n纽约深度游之八：战争与和平\n有点像序的跋\n附录\n附录一：一些遗珠\n附录二：纽约博物馆排名","pages":"380","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s29478001.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s29478001.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s29478001.jpg"},"alt":"https:\/\/book.douban.com\/subject\/27037182\/","id":"27037182","publisher":"中西书局","isbn10":"7547512488","isbn13":"9787547512487","title":"纽约无人是客","url":"https:\/\/api.douban.com\/v2\/book\/27037182","alt_title":"","author_intro":"沈辛成，1984年生人，非业余博物馆爱好者，走访全美八十余座博物馆，曾服务于美国自然历史博物馆、“911”国家纪念馆和纽约历史学会，参与从事档案研究、出版与策展工作。佐治亚理工学院科技史博士在读，哥伦比亚大学人类学硕士，复旦大学考古学硕士，北京大学博物馆学学士，做过独立唱作人，兼职美国时政评论。","summary":"本书为作者在纽约实地踏访数十家博物馆并进行深入了解后，对纽约博物馆展示特色、专业内涵、设计匠心及观众体验等进行多维度评价的作品。\n本书不是一本简单的博物馆导览手册，而是基于作者的个人经历和专业背景，试图阐释纽约这个五方杂处、光怪陆离却又独具特色的国际大都会的底色。全书行文从容，图文并茂，兼具知识性、实用性和可读性，无论是否去过纽约，它都会在流畅的阅读之后，带给你充足的知识与细节，同时也带给你深深的思索。","price":"39.80元"},{"rating":{"max":10,"numRaters":1399,"average":"9.0","min":0},"subtitle":"","author":["Kenneth A.Reek"],"pubdate":"2008 年4月","tags":[{"count":869,"name":"C","title":"C"},{"count":776,"name":"C语言","title":"C语言"},{"count":540,"name":"编程","title":"编程"},{"count":437,"name":"指针","title":"指针"},{"count":381,"name":"计算机","title":"计算机"},{"count":304,"name":"程序设计","title":"程序设计"},{"count":276,"name":"C\/C++","title":"C\/C++"},{"count":180,"name":"Programming","title":"Programming"}],"origin_title":"Pointers on C","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s2996168.jpg","binding":"平装","translator":["徐波"],"catalog":"第1章 快速上手\n1.1 简介\n1.1.1 空白和注释\n1.1.2 预处理指令\n1.1.3 main函数\n1.1.4 read_column_numbers函数\n1.1.5 rearrange函数\n1.2 补充说明\n1.3 编译\n1.4 总结\n1.5 警告的总结\n1.6 编程提示的总结\n1.7 问题\n1.8 编程练习\n第2章 基本概念\n2.1 环境\n2.1.1 翻译\n2.1.2 执行\n2.2 词法规则\n2.2.1 字符\n2.2.2 注释\n2.2.3 自由形式的源代码\n2.2.4 标识符\n2.2.5 程序的形式\n2.3 程序风格\n2.4 总结\n2.5 警告的总结\n2.6 编程提示的总结\n2.7 问题\n2.8 编程练习\n第3章 数据\n第4章 语句\n第5章 操作符和表达式\n第6章 指针\n第7章 函数\n第8章 数组\n第9章 字符串、字符和字节\n第10章 结构和联合\n第11章 动态内存分配\n第12章 使用结构和指针\n第13章 高级指针话题\n第14章 预处理器\n第15章 输入\/输出函数\n第16章 标准函数库\n第17章 经典抽象数据类型\n第18章 运行时环境\n附录 部分问题答案\n索引\n参考文献","pages":"448","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s2996168.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s2996168.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s2996168.jpg"},"alt":"https:\/\/book.douban.com\/subject\/3012360\/","id":"3012360","publisher":"人民邮电出版社","isbn10":"7115172013","isbn13":"9787115172013","title":"C和指针","url":"https:\/\/api.douban.com\/v2\/book\/3012360","alt_title":"Pointers on C","author_intro":"Kenneth·Reek是罗彻斯特理工大学计算机科学教授。他是一位经验丰富的C程序员，曾为多家公司担任过技术顾问。他讲授的课程有操作系统、数据通信、计算机网络、形式语言、算法分析和交换系统等。本书正是基于他9年的编程及教学的经验积累。","summary":"本书提供与C语言编程相关的全面资源和深入讨论。本书通过对指针的基础知识和高级特性的探讨，帮助程序员把指针的强大功能融入到自己的程序中去。\n全书共18章，覆盖了数据、语句、操作符和表达式、指针、函数、数组、字符串、结构和联合等几乎所有重要的C编程话题。书中给出了很多编程技巧和提示，每章后面有针对性很强的练习，附录部分则给出了部分练习的解答。\n本书适合C语言初学者和初级C程序员阅读，也可作为计算机专业学生学习C语言的参考。","series":{"id":"9931","title":"C和C++经典著作"},"price":"65.00元"},{"rating":{"max":10,"numRaters":1270,"average":"9.6","min":0},"subtitle":"-","author":["Brian W. Kernighan","Dennis M. Ritchie"],"pubdate":"1988-4-1","tags":[{"count":611,"name":"c","title":"c"},{"count":434,"name":"Programming","title":"Programming"},{"count":403,"name":"C语言","title":"C语言"},{"count":382,"name":"编程","title":"编程"},{"count":316,"name":"计算机","title":"计算机"},{"count":240,"name":"经典","title":"经典"},{"count":218,"name":"C","title":"C"},{"count":205,"name":"程序设计","title":"程序设计"}],"origin_title":"","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s29586132.jpg","binding":"Paperback","translator":[],"catalog":"","pages":"274","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s29586132.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s29586132.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s29586132.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1236999\/","id":"1236999","publisher":"Prentice Hall","isbn10":"0131103628","isbn13":"9780131103627","title":"The  C Programming Language","url":"https:\/\/api.douban.com\/v2\/book\/1236999","alt_title":"C Programming Language","author_intro":"Brian W. Kernighan works in the Computing Science Research Center at Bell Laboratories, Lucent Technologies. He is Consulting Editor for Addison-Wesley's Professional Computing Series and the author, with Dennis Ritchie, of The C Programming Language.\nDennis Ritchie is a computer scientist notable for his influence on ALTRAN, B, BCPL, C, Multics, and Unix.","summary":"Presents a complete guide to ANSI standard C language programming. Written by the developers of C, this new version helps readers keep up with the finalized ANSI standard for C while showing how to take advantage of C's rich set of operators, economy of expression, improved control flow, and data structures. This 2nd edition has been completely rewritten with additional examples and problem sets to clarify the implementation of difficult language constructs. 7 x 9 1\/4.","price":"USD 67.00"},{"rating":{"max":10,"numRaters":604,"average":"9.3","min":0},"subtitle":"第六版","author":["普拉达 (Stephen Prata)"],"pubdate":"2016-4-1","tags":[{"count":347,"name":"C语言","title":"C语言"},{"count":231,"name":"C","title":"C"},{"count":215,"name":"编程","title":"编程"},{"count":183,"name":"计算机","title":"计算机"},{"count":142,"name":"计算机科学","title":"计算机科学"},{"count":125,"name":"经典","title":"经典"},{"count":86,"name":"C++","title":"C++"},{"count":78,"name":"软件开发","title":"软件开发"}],"origin_title":"C Primer Plus : 6th","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s29438897.jpg","binding":"平装","translator":["姜佑"],"catalog":"第1章　初识C语言\t1\n1．1　C语言的起源\t1\n1．2 选择C语言的理由\t1\n1．2．1 设计特性\t1\n1．2．2 高效性\t1\n1．2．3 可移植性\t2\n1．2．4 强大而灵活\t3\n1．2．5 面向程序员\t3\n1．2．6 缺点\t3\n1．3 C语言的应用范围\t3\n1．4 计算机能做什么\t4\n1．5 高级计算机语言和编译器\t5\n1．6 语言标准\t6\n1．6．1 第1个ANSI\/ISO C标准\t6\n1．6．2 C99标准\t6\n1．6．3 C11标准\t7\n1．7 使用C语言的7个步骤\t7\n1．7．1 第1步：定义程序的目标\t8\n1．7．2 第2步：设计程序\t8\n1．7．3 第3步：编写代码\t8\n1．7．4 第4步：编译\t8\n1．7．5 第5步：运行程序\t9\n1．7．6 第6步：测试和调试程序\t9\n1．7．7 第7步：维护和修改代码\t9\n1．7．8 说明\t9\n1．8 编程机制\t10\n1．8．1 目标代码文件、可执行文件和库\t10\n1．8．2 UNIX系统\t11\n1．8．3 GNU编译器集合和LLVM项目\t13\n1．8．4 Linux系统\t13\n1．8．5 PC的命令行编译器\t14\n1．8．6 集成开发环境（Windows）\t14\n1．8．7 Windows\/Linux\t15\n1．8．8 Macintosh中的C\t15\n1．9 本书的组织结构\t15\n1．10 本书的约定\t16\n1．10．1 字体\t16\n1．10．2 程序输出\t16\n1．10．3 特殊元素\t17\n1．11 本章小结\t17\n1．12 复习题\t18\n1．13 编程练习\t18\n第2章　C语言概述\t19\n2．1 简单的C程序示例\t19\n2．2 示例解释\t20\n2．2．1 第1遍：快速概要\t21\n2．2．2 第2遍：程序细节\t21\n2．3 简单程序的结构\t28\n2．4 提高程序可读性的技巧\t28\n2．5 进一步使用C\t29\n2．5．1 程序说明\t30\n2．5．2 多条声明\t30\n2．5．3 乘法\t30\n2．5．4 打印多个值\t30\n2．6 多个函数\t30\n2．7 调试程序\t32\n2．7．1 语法错误\t32\n2．7．2 语义错误\t33\n2．7．3 程序状态\t34\n2．8 关键字和保留标识符\t34\n2．9 关键概念\t35\n2．10 本章小结\t35\n2．11 复习题\t36\n2．12 编程练习\t37\n第3章　数据和C\t39\n3．1 示例程序\t39\n3．2 变量与常量数据\t42\n3．3 数据：数据类型关键字\t42\n3．3．1 整数和浮点数\t43\n3．3．2 整数\t43\n3．3．3 浮点数\t43\n3．4 C语言基本数据类型\t44\n3．4．1 int类型\t44\n3．4．2 其他整数类型\t47\n3．4．3 使用字符：char类型\t50\n3．4．4 _Bool类型\t54\n3．4．5 可移植类型：stdint．h和inttypes．h\t55\n3．4．6 float、double和long double\t56\n3．4．7 复数和虚数类型\t60\n3．4．8 其他类型\t60\n3．4．9 类型大小\t62\n3．5 使用数据类型\t63\n3．6 参数和陷阱\t63\n3．7 转义序列示例\t64\n3．7．1 程序运行情况\t65\n3．7．2 刷新输出\t65\n3．8 关键概念\t66\n3．9 本章小结\t66\n3．10 复习题\t67\n3．11 编程练习\t68\n第4章　字符串和格式化输入\/输出\t71\n4．1 前导程序\t71\n4．2 字符串简介\t72\n4．2．1 char类型数组和null字符\t72\n4．2．2 使用字符串\t73\n4．2．3 strlen()函数\t74\n4．3 常量和C预处理器\t76\n4．3．1 const限定符\t78\n4．3．2 明示常量\t78\n4．4 printf()和scanf()\t80\n4．4．1 printf()函数\t80\n4．4．2 使用printf()\t81\n4．4．3 printf()的转换说明修饰符\t83\n4．4．4 转换说明的意义\t87\n4．4．5 使用scanf()\t92\n4．4．6 printf()和scanf()的*修饰符\t95\n4．4．7 printf()的用法提示\t97\n4．5 关键概念\t98\n4．6 本章小结\t98\n4．7 复习题\t99\n4．8 编程练习\t100\n第5章　运算符、表达式和语句\t103\n5．1 循环简介\t103\n5．2 基本运算符\t105\n5．2．1 赋值运算符：=\t105\n5．2．2 加法运算符：+\t107\n5．2．3 减法运算符：-\t107\n5．2．4 符号运算符：-和+\t107\n5．2．5 乘法运算符：*\t108\n5．2．6 除法运算符：\/\t110\n5．2．7 运算符优先级\t110\n5．2．8 优先级和求值顺序\t112\n5．3 其他运算符\t113\n5．3．1 sizeof运算符和size_t类型\t113\n5．3．2 求模运算符：%\t114\n5．3．3 递增运算符：++\t115\n5．3．4 递减运算符：--\t118\n5．3．5 优先级\t118\n5．3．6 不要自作聪明\t119\n5．4 表达式和语句\t120\n5．4．1 表达式\t120\n5．4．2 语句\t120\n5．4．3 复合语句（块）\t123\n5．5 类型转换\t124\n5．6 带参数的函数\t127\n5．7 示例程序\t129\n5．8 关键概念\t130\n5．9 本章小结\t130\n5．10 复习题\t131\n5．11 编程练习\t134\n第6章　C控制语句：循环\t137\n6．1 再探while循环\t137\n6．1．1 程序注释\t138\n6．1．2 C风格读取循环\t139\n6．2 while语句\t140\n6．2．1 终止while循环\t140\n6．2．2 何时终止循环\t141\n6．2．3 while：入口条件循环\t141\n6．2．4 语法要点\t141\n6．3 用关系运算符和表达式比较大小\t143\n6．3．1 什么是真\t144\n6．3．2 其他真值\t145\n6．3．3 真值的问题\t146\n6．3．4 新的_Bool类型\t147\n6．3．5 优先级和关系运算符\t148\n6．4 不确定循环和计数循环\t150\n6．5 for循环\t151\n6．6 其他赋值运算符：+=、-=、*=、\/=、%=\t155\n6．7 逗号运算符\t156\n6．8 出口条件循环：do while\t159\n6．9 如何选择循环\t161\n6．10 嵌套循环\t162\n6．10．1 程序分析\t163\n6．10．2 嵌套变式\t163\n6．11 数组简介\t164\n6．12 使用函数返回值的循环示例\t166\n6．12．1 程序分析\t168\n6．12．2 使用带返回值的函数\t169\n6．13 关键概念\t169\n6．14 本章小结\t170\n6．15 复习题\t170\n6．16 编程练习\t174\n第7章　C控制语句：分支和跳转\t177\n7．1 if语句\t177\n7．2 if else语句\t179\n7．2．1 另一个示例：介绍getchar()和putchar()\t180\n7．2．2 ctype．h系列的字符函数\t182\n7．2．3 多重选择else if\t184\n7．2．4 else与if配对\t186\n7．2．5 多层嵌套的if语句\t187\n7．3 逻辑运算符\t190\n7．3．1 备选拼写：iso646．h头文件\t191\n7．3．2 优先级\t192\n7．3．3 求值顺序\t192\n7．3．4 范围\t193\n7．4 一个统计单词的程序\t194\n7．5 条件运算符：?：\t196\n7．6 循环辅助：continue和break\t198\n7．6．1 continue语句\t198\n7．6．2 break语句\t200\n7．7 多重选择：switch和break\t202\n7．7．1 switch语句\t204\n7．7．2 只读每行的首字符\t205\n7．7．3 多重标签\t206\n7．7．4 switch和if else\t208\n7．8 goto语句\t208\n7．9 关键概念\t211\n7．10 本章小结\t211\n7．11 复习题\t212\n7．12 编程练习\t214\n第8章　字符输入\/输出和输入验证\t217\n8．1 单字符I\/O：getchar()和putchar()\t217\n8．2 缓冲区\t218\n8．3 结束键盘输入\t219\n8．3．1 文件、流和键盘输入\t219\n8．3．2 文件结尾\t220\n8．4 重定向和文件\t222\n8．5 创建更友好的用户界面\t226\n8．5．1 使用缓冲输入\t226\n8．5．2 混合数值和字符输入\t228\n8．6 输入验证\t230\n8．6．1 分析程序\t234\n8．6．2 输入流和数字\t234\n8．7 菜单浏览\t235\n8．7．1 任务\t235\n8．7．2 使执行更顺利\t235\n8．7．3 混合字符和数值输入\t237\n8．8 关键概念\t240\n8．9 本章小结\t240\n8．10 复习题\t241\n8．11 编程练习\t241\n第9章　函数\t243\n9．1 复习函数\t243\n9．1．1 创建并使用简单函数\t244\n9．1．2 分析程序\t245\n9．1．3 函数参数\t247\n9．1．4 定义带形式参数的函数\t248\n9．1．5 声明带形式参数函数的原型\t249\n9．1．6 调用带实际参数的函数\t249\n9．1．7 黑盒视角\t250\n9．1．8 使用return从函数中返回值\t250\n9．1．9 函数类型\t252\n9．2 ANSI C函数原型\t253\n9．2．1 问题所在\t253\n9．2．2 ANSI的解决方案\t254\n9．2．3 无参数和未指定参数\t255\n9．2．4 函数原型的优点\t256\n9．3 递归\t256\n9．3．1 演示递归\t256\n9．3．2 递归的基本原理\t258\n9．3．3 尾递归\t258\n9．3．4 递归和倒序计算\t260\n9．3．5 递归的优缺点\t262\n9．4 编译多源代码文件的程序\t262\n9．4．1 UNIX\t263\n9．4．2 Linux\t263\n9．4．3 DOS命令行编译器\t263\n9．4．4 Windows和苹果的IDE编译器\t263\n9．4．5 使用头文件\t263\n9．5 查找地址：&运算符\t267\n9．6 更改主调函数中的变量\t268\n9．7 指针简介\t269\n9．7．1 间接运算符：*\t270\n9．7．2 声明指针\t270\n9．7．3 使用指针在函数间通信\t271\n9．8 关键概念\t274\n9．9 本章小结\t275\n9．10　复习题\t275\n9．11 编程练习\t276\n第10章　数组和指针\t277\n10．1 数组\t277\n10．1．1 初始化数组\t277\n10．1．2 指定初始化器（C99）\t281\n10．1．3 给数组元素赋值\t282\n10．1．4 数组边界\t282\n10．1．5 指定数组的大小\t284\n10．2 多维数组\t284\n10．2．1 初始化二维数组\t287\n10．2．2 其他多维数组\t288\n10．3 指针和数组\t288\n10．4 函数、数组和指针\t290\n10．4．1 使用指针形参\t293\n10．4．2 指针表示法和数组表示法\t294\n10．5 指针操作\t295\n10．6 保护数组中的数据\t298\n10．6．1 对形式参数使用const\t299\n10．6．2　const的其他内容\t300\n10．7 指针和多维数组\t302\n10．7．1 指向多维数组的指针\t304\n10．7．2 指针的兼容性\t305\n10．7．3 函数和多维数组\t306\n10．8 变长数组（VLA）\t309\n10．9 复合字面量\t312\n10．10 关键概念\t314\n10．11 本章小结\t315\n10．12 复习题\t316\n10．13 编程练习\t317\n第11章　字符串和字符串函数\t321\n11．1 表示字符串和字符串I\/O\t321\n11．1．1 在程序中定义字符串\t322\n11．1．2 指针和字符串\t328\n11．2 字符串输入\t329\n11．2．1 分配空间\t329\n11．2．2 不幸的gets()函数\t330\n11．2．3 gets()的替代品\t331\n11．2．4 scanf()函数\t336\n11．3 字符串输出\t337\n11．3．1 puts()函数\t338\n11．3．2 fputs()函数\t339\n11．3．3 printf()函数\t339\n11．4 自定义输入\/输出函数\t340\n11．5 字符串函数\t342\n11．5．1 strlen()函数\t342\n11．5．2 strcat()函数\t343\n11．5．3 strncat()函数\t345\n11．5．4 strcmp()函数\t346\n11．5．5 strcpy()和strncpy()函数\t351\n11．5．6 sprintf()函数\t356\n11．5．7 其他字符串函数\t357\n11．6 字符串示例：字符串排序\t359\n11．6．1 排序指针而非字符串\t360\n11．6．2 选择排序算法\t361\n11．7 ctype．h字符函数和字符串\t362\n11．8 命令行参数\t363\n11．8．1 集成环境中的命令行参数\t365\n11．8．2 Macintosh中的命令行参数\t365\n11．9 把字符串转换为数字\t365\n11．10 关键概念\t368\n11．11 本章小结\t368\n11．12 复习题\t369\n11．13 编程练习\t371\n第12章　存储类别、链接和内存管理\t373\n12．1 存储类别\t373\n12．1．1 作用域\t374\n12．1．2 链接\t376\n12．1．3 存储期\t376\n12．1．4 自动变量\t377\n12．1．5 寄存器变量\t380\n12．1．6 块作用域的静态变量\t381\n12．1．7 外部链接的静态变量\t382\n12．1．8 内部链接的静态变量\t386\n12．1．9 多文件\t386\n12．1．10 存储类别说明符\t387\n12．1．11 存储类别和函数\t389\n12．1．12 存储类别的选择\t389\n12．2 随机数函数和静态变量\t390\n12．3 掷骰子\t393\n12．4 分配内存：malloc()和free()\t396\n12．4．1 free()的重要性\t399\n12．4．2 calloc()函数\t400\n12．4．3 动态内存分配和变长数组\t400\n12．4．4 存储类别和动态内存分配\t401\n12．5 ANSI C类型限定符\t402\n12．5．1 const类型限定符\t403\n12．5．2 volatile类型限定符\t404\n12．5．3 restrict类型限定符\t405\n12．5．4 _Atomic类型限定符（C11）\t406\n12．5．5 旧关键字的新位置\t406\n12．6　关键概念\t407\n12．7 本章小结\t407\n12．8 复习题\t408\n12．9 编程练习\t409\n第13章　文件输入\/输出\t413\n13．1 与文件进行通信\t413\n13．1．1 文件是什么\t413\n13．1．2 文本模式和二进制模式\t413\n13．1．3 I\/O的级别\t415\n13．1．4 标准文件\t415\n13．2 标准I\/O\t415\n13．2．1 检查命令行参数\t416\n13．2．2 fopen()函数\t416\n13．2．3 getc()和putc()函数\t417\n13．2．4 文件结尾\t418\n13．2．5 fclose()函数\t419\n13．2．6 指向标准文件的指针\t419\n13．3 一个简单的文件压缩程序\t419\n13．4 文件I\/O：fprintf()、fscanf()、fgets()和fputs()\t421\n13．4．1 fprintf()和fscanf()函数\t421\n13．4．2 fgets()和fputs()函数\t422\n13．5 随机访问：fseek()和ftell()\t423\n13．5．1 fseek()和ftell()的工作原理\t424\n13．5．2 二进制模式和文本模式\t425\n13．5．3 可移植性\t425\n13．5．4 fgetpos()和fsetpos()函数\t426\n13．6 标准I\/O的机理\t426\n13．7 其他标准I\/O函数\t427\n13．7．1 int ungetc(int c， FILE *fp)函数\t427\n13．7．2 int fflush()函数\t428\n13．7．3 int setvbuf()函数\t428\n13．7．4 二进制I\/O：fread()和fwrite()\t428\n13．7．5 size_t fwrite()函数\t429\n13．7．6 size_t fread()函数\t430\n13．7．7 int feof(FILE *fp)和int ferror(FILE *fp)函数\t430\n13．7．8 一个程序示例\t430\n13．7．9 用二进制I\/O进行随机访问\t433\n13．8 关键概念\t435\n13．9 本章小结\t435\n13．10 复习题\t435\n13．11 编程练习\t437\n第14章　结构和其他数据形式\t439\n14．1 示例问题：创建图书目录\t439\n14．2 建立结构声明\t441\n14．3 定义结构变量\t441\n14．3．1 初始化结构\t442\n14．3．2 访问结构成员\t443\n14．3．3 结构的初始化器\t443\n14．4 结构数组\t444\n14．4．1 声明结构数组\t446\n14．4．2 标识结构数组的成员\t447\n14．4．3 程序讨论\t447\n14．5 嵌套结构\t448\n14．6 指向结构的指针\t449\n14．6．1 声明和初始化结构指针\t450\n14．6．2 用指针访问成员\t451\n14．7 向函数传递结构的信息\t451\n14．7．1 传递结构成员\t451\n14．7．2 传递结构的地址\t452\n14．7．3 传递结构\t453\n14．7．4 其他结构特性\t454\n14．7．5 结构和结构指针的选择\t458\n14．7．6 结构中的字符数组和字符指针\t458\n14．7．7 结构、指针和malloc()\t459\n14．7．8 复合字面量和结构（C99）\t462\n14．7．9 伸缩型数组成员（C99）\t463\n14．7．10 匿名结构（C11）\t465\n14．7．11 使用结构数组的函数\t466\n14．8 把结构内容保存到文件中\t467\n14．8．1 保存结构的程序示例\t468\n14．8．2 程序要点\t470\n14．9 链式结构\t471\n14．10 联合简介\t472\n14．10．1 使用联合\t472\n14．10．2 匿名联合（C11）\t473\n14．11 枚举类型\t474\n14．11．1 enum常量\t475\n14．11．2 默认值\t475\n14．11．3 赋值\t475\n14．11．4 enum的用法\t476\n14．11．5 共享名称空间\t477\n14．12 typedef简介\t478\n14．13 其他复杂的声明\t479\n14．14 函数和指针\t481\n14．15 关键概念\t487\n14．16 本章小结\t487\n14．17 复习题\t488\n14．18 编程练习\t490\n第15章　位操作\t493\n15．1 二进制数、位和字节\t493\n15．1．1 二进制整数\t494\n15．1．2 有符号整数\t494\n15．1．3 二进制浮点数\t495\n15．2 其他进制数\t495\n15．2．1 八进制\t495\n15．2．2 十六进制\t496\n15．3 C按位运算符\t496\n15．3．1 按位逻辑运算符\t497\n15．3．2 用法：掩码\t498\n15．3．3 用法：打开位（设置位）\t498\n15．3．4 用法：关闭位（清空位）\t499\n15．3．5 用法：切换位\t499\n15．3．6 用法：检查位的值\t500\n15．3．7 移位运算符\t500\n15．3．8 编程示例\t501\n15．3．9 另一个例子\t503\n15．4 位字段\t505\n15．4．1 位字段示例\t506\n15．4．2 位字段和按位运算符\t509\n15．5 对齐特性（C11）\t515\n15．6 关键概念\t516\n15．7 本章小结\t516\n15．8 复习题\t517\n15．9 编程练习\t518\n第16章　C预处理器和C库\t521\n16．1 翻译程序的第一步\t521\n16．2 明示常量：#define\t522\n16．2．1 记号\t525\n16．2．2 重定义常量\t525\n16．3 在#define中使用参数\t525\n16．3．1 用宏参数创建字符串：#运算符\t527\n16．3．2 预处理器黏合剂：##运算符\t528\n16．3．3 变参宏：．．．和_ _VA_ARGS_ _\t529\n16．4 宏和函数的选择\t530\n16．5 文件包含：#include\t531\n16．5．1 头文件示例\t531\n16．5．2 使用头文件\t533\n16．6 其他指令\t534\n16．6．1 #undef指令\t534\n16．6．2 从C预处理器角度看已定义\t534\n16．6．3 条件编译\t535\n16．6．4 预定义宏\t539\n16．6．5 #line和#error\t540\n16．6．6 #pragma\t540\n16．6．7 泛型选择（C11）\t541\n16．7 内联函数（C99）\t542\n16．8 _Noreturn函数（C11）\t544\n16．9 C库\t544\n16．9．1 访问C库\t544\n16．9．2 使用库描述\t545\n16．10 数学库\t546\n16．10．1 三角问题\t547\n16．10．2 类型变体\t548\n16．10．3 tgmath．h库（C99）\t550\n16．11 通用工具库\t550\n16．11．1 exit()和atexit()函数\t550\n16．11．2 qsort()函数\t552\n16．12 断言库\t556\n16．12．1 assert的用法\t556\n16．12．2 _Static_assert（C11）\t557\n16．13 string．h库中的memcpy()和memmove()\t558\n16．14 可变参数：stdarg．h\t560\n16．15 关键概念\t562\n16．16 本章小结\t562\n16．17 复习题\t562\n16．18 编程练习\t563\n第17章　高级数据表示\t567\n17．1 研究数据表示\t567\n17．2 从数组到链表\t570\n17．2．1 使用链表\t572\n17．2．2 反思\t576\n17．3 抽象数据类型（ADT）\t576\n17．3．1 建立抽象\t577\n17．3．2 建立接口\t578\n17．3．3 使用接口\t581\n17．3．4 实现接口\t583\n17．4 队列ADT\t589\n17．4．1 定义队列抽象数据类型\t590\n17．4．2 定义一个接口\t590\n17．4．3 实现接口数据表示\t591\n17．4．4 测试队列\t598\n17．5 用队列进行模拟\t600\n17．6 链表和数组\t605\n17．7 二叉查找树\t608\n17．7．1 二叉树ADT\t608\n17．7．2 二叉查找树接口\t609\n17．7．3 二叉树的实现\t611\n17．7．4 使用二叉树\t624\n17．7．5 树的思想\t628\n17．8 其他说明\t629\n17．9 关键概念\t630\n17．10 本章小结\t630\n17．11 复习题\t630\n17．12 编程练习\t631\n附录A　复习题答案\t633\n附录B　参考资料\t665\nB．1 参考资料I：补充阅读\t665\nB．2 参考资料II：C运算符\t667\nB．3 参考资料III：基本类型和存储类别\t671\nB．4 参考资料IV：表达式、语句和程序流\t675\nB．5 参考资料V：新增C99和C11的ANSI C库\t679\nB．6 参考资料VI：扩展的整数类型\t714\nB．7 参考资料VII：扩展字符支持\t716\nB．8 参考资料VIII：C99\/C11数值计算增强\t720\nB．9 参考资料IX：C和C++的区别\t726","pages":"730","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s29438897.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s29438897.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s29438897.jpg"},"alt":"https:\/\/book.douban.com\/subject\/26792521\/","id":"26792521","publisher":"人民邮电出版社","isbn10":"7115390592","isbn13":"9787115390592","title":"C Primer Plus（第6版）中文版","url":"https:\/\/api.douban.com\/v2\/book\/26792521","alt_title":"C Primer Plus : 6th","author_intro":"Stephen Prata曾在加利福尼亚的马林学院（肯特菲尔德）教授天文学、物理学和程序设计课程，现已退休。他在加州理工学院获得学士学位，在加州大学伯克利分校获得博士学位。他接触程序设计，是为了利用计算机给星团建模。Stephen撰写和与他人合著了十几本书籍，其中包括C++ Primer Plus和Unix Primer Plus。","summary":"《C Primer Plus（第6版）中文版》详细讲解了C语言的基本概念和编程技巧。\n《C Primer Plus（第6版）中文版》共17章。第1、2章介绍了C语言编程的预备知识。第3~15章详细讲解了C语言的相关知识，包括数据类型、格式化输入\/输出、运算符、表达式、语句、循环、字符输入和输出、函数、数组和指针、字符和字符串函数、内存管理、文件输入输出、结构、位操作等。第16章、17章介绍C预处理器、C库和高级数据表示。本书以完整的程序为例，讲解C语言的知识要点和注意事项。每章末设计了大量复习题和编程练习，帮助读者巩固所学知识和提高实际编程能力。附录给出了各章复习题的参考答案和丰富的参考资料。\n《C Primer Plus（第6版）中文版》可作为C语言的教材，适用于需要系统学习C语言的初学者，也适用于巩固C语言知识或希望进一步提高编程技术的程序员。","series":{"id":"23545","title":"C和C++实务精选"},"price":"CNY 89.00"},{"rating":{"max":10,"numRaters":389,"average":"9.3","min":0},"subtitle":"现代方法","author":["K. N. King"],"pubdate":"2010-4","tags":[{"count":526,"name":"C语言","title":"C语言"},{"count":315,"name":"C","title":"C"},{"count":240,"name":"程序设计","title":"程序设计"},{"count":239,"name":"编程","title":"编程"},{"count":230,"name":"计算机","title":"计算机"},{"count":182,"name":"C\/C++","title":"C\/C++"},{"count":162,"name":"编程语言","title":"编程语言"},{"count":128,"name":"计算机科学","title":"计算机科学"}],"origin_title":"C Programming: A Modern Approach, Second Edition","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s4171870.jpg","binding":"平装","translator":["吕秀锋","黄倩"],"catalog":"第1章 C语言概述1\n1.1 C语言的历史1\n1.1.1 起源1\n1.1.2 标准化1\n1.1.3 基于C的语言2\n1.2 C语言的优缺点3\n1.2.1 C语言的优点3\n1.2.2 C语言的缺点3\n1.2.3 高效地使用C语言4\n问与答5\n第2章 C语言基本概念7\n2.1 编写一个简单的C程序7\n程序显示双关语7\n2.1.1 编译和链接8\n2.1.2 集成开发环境8\n2.2 简单程序的一般形式9\n2.2.1 指令9\n2.2.2 函数9\n2.2.3 语句10\n2.2.4 显示字符串10\n2.3 注释11\n2.4 变量和赋值12\n2.4.1 类型12\n2.4.2 声明13\n2.4.3 赋值13\n2.4.4 显示变量的值14\n程序计算箱子的空间重量14\n2.4.5 初始化15\n2.4.6 显示表达式的值16\n2.5 读入输入16\n程序计算箱子的空间重量（改进版）16\n2.6 定义常量的名字17\n程序华氏温度转换为摄氏温度17\n2.7 标识符18\n2.8 C程序的书写规范19\n问与答21\n练习题23\n编程题24\n第3章 格式化输入\/输出26\n3.1 printf函数26\n3.1.1 转换说明27\n程序用printf函数格式化数28\n3.1.2 转义序列28\n3.2 scanf函数29\n3.2.1 scanf函数的工作方法30\n3.2.2 格式串中的普通字符31\n3.2.3 易混淆的printf函数和scanf函数32\n程序分数相加32\n问与答33\n练习题34\n编程题35\n第4章 表达式36\n4.1 算术运算符36\n程序计算通用产品代码的校验位38\n4.2 赋值运算符39\n4.2.1 简单赋值40\n4.2.2 左值41\n4.2.3 复合赋值41\n4.3 自增运算符和自减运算符42\n4.4 表达式求值43\n4.5 表达式语句45\n问与答45\n练习题47\n编程题49\n第5章 选择语句50\n5.1 逻辑表达式50\n5.1.1 关系运算符50\n5.1.2 判等运算符51\n5.1.3 逻辑运算符51\n5.2 if语句52\n5.2.1 复合语句53\n5.2.2 else子句53\n5.2.3 级联式if语句54\n程序计算股票经纪人的佣金55\n5.2.4 “悬空else”的问题56\n5.2.5 条件表达式57\n5.2.6 C89中的布尔值58\n5.2.7 C99中的布尔值58\n5.3 switch语句59\n程序显示法定格式的日期61\n问与答62\n练习题65\n编程题67\n第6章 循环69\n6.1 while语句69\n程序显示平方表71\n程序数列求和71\n6.2 do语句72\n程序计算整数的位数73\n6.3 for语句73\n6.3.1 for语句的惯用法74\n6.3.2 在for语句中省略表达式75\n6.3.3 C99中的for语句75\n6.3.4 逗号运算符76\n程序显示平方表（改进版）77\n6.4 退出循环78\n6.4.1 break语句78\n6.4.2 continue语句78\n6.4.3 goto语句79\n程序账簿结算80\n6.5 空语句81\n问与答83\n练习题84\n编程题85\n第7章 基本类型88\n7.1 整数类型88\n7.1.1 C99中的整数类型90\n7.1.2 整数常量90\n7.1.3 C99中的整数常量91\n7.1.4 整数溢出91\n7.1.5 读\/写整数91\n程序数列求和（改进版）92\n7.2 浮点类型93\n7.2.1 浮点常量94\n7.2.2 读\/写浮点数94\n7.3 字符类型94\n7.3.1 字符操作95\n7.3.2 有符号字符和无符号字符95\n7.3.3 算术类型96\n7.3.4 转义序列96\n7.3.5 字符处理函数97\n7.3.6 用scanf和printf读\/写字符98\n7.3.7 用getchar和putchar读\/写字符98\n程序确定消息的长度99\n7.4 类型转换100\n7.4.1 常用算术转换101\n7.4.2 赋值过程中的转换102\n7.4.3 C99中的隐式转换103\n7.4.4 强制类型转换103\n7.5 类型定义105\n7.5.1 类型定义的优点105\n7.5.2 类型定义和可移植性105\n7.6 sizeof运算符106\n问与答107\n练习题109\n编程题110\n第8章 数组113\n8.1 一维数组113\n8.1.1 数组下标113\n程序数列反向115\n8.1.2 数组初始化115\n8.1.3 指定初始化式116\n程序检查数中重复出现的数字116\n8.1.4 对数组使用sizeof运算符117\n程序计算利息118\n8.2 多维数组119\n8.2.1 多维数组初始化120\n8.2.2 常量数组121\n程序发牌121\n8.3 C99中的变长数组122\n问与答123\n练习题124\n编程题125\n第9章 函数129\n9.1 函数的定义和调用129\n程序计算平均值129\n程序显示倒计数130\n程序显示双关语（改进版）131\n9.1.1 函数定义132\n9.1.2 函数调用133\n程序判定素数134\n9.2 函数声明135\n9.3 实际参数136\n9.3.1 实际参数的转换137\n9.3.2 数组型实际参数138\n9.3.3 变长数组形式参数140\n9.3.4 在数组参数声明中使用static141\n9.3.5 复合字面量141\n9.4 return语句142\n9.5 程序终止143\n9.6 递归144\n程序快速排序146\n问与答147\n练习题150\n编程题153\n第10章 程序结构155\n10.1 局部变量155\n10.1.1 静态局部变量156\n10.1.2 形式参数156\n10.2 外部变量156\n10.2.1 示例：用外部变量实现栈156\n10.2.2 外部变量的利与弊157\n程序猜数158\n10.3 程序块161\n10.4 作用域162\n10.5 构建C程序163\n程序给一手牌分类163\n问与答169\n练习题169\n编程题170\n第11章 指针172\n11.1 指针变量172\n11.2 取地址运算符和间接寻址运算符173\n11.2.1 取地址运算符173\n11.2.2 间接寻址运算符174\n11.3 指针赋值174\n11.4 指针作为参数176\n程序找出数组中的最大元素和最小元素177\n11.5 指针作为返回值179\n问与答180\n练习题181\n编程题182\n第12章 指针和数组184\n12.1 指针的算术运算184\n12.1.1 指针加上整数185\n12.1.2 指针减去整数185\n12.1.3 两个指针相减186\n12.1.4 指针比较186\n12.1.5 指向复合常量的指针186\n12.2 指针用于数组处理186\n12.3 用数组名作为指针188程序数列反向（改进版）189\n12.3.1 数组型实际参数（改进版）189\n12.3.2 用指针作为数组名191\n12.4 指针和多维数组191\n12.4.1 处理多维数组的元素191\n12.4.2 处理多维数组的行192\n12.4.3 处理多维数组的列192\n12.4.4 用多维数组名作为指针192\n12.5 C99中的指针和变长数组193\n问与答194\n练习题195\n编程题197\n第13章 字符串198\n13.1 字符串字面量198\n13.1.1 字符串字面量中的转义序列198\n13.1.2 延续字符串字面量199\n13.1.3 如何存储字符串字面量199\n13.1.4 字符串字面量的操作200\n13.1.5 字符串字面量与字符常量200\n13.2 字符串变量200\n13.2.1 初始化字符串变量201\n13.2.2 字符数组与字符指针202\n13.3 字符串的读和写203\n13.3.1 用printf函数和puts函数写字符串203\n13.3.2 用scanf函数和gets函数读字符串203\n13.3.3 逐个字符读字符串204\n13.4 访问字符串中的字符205\n13.5 使用C语言的字符串库206\n13.5.1 strcpy函数207\n13.5.2 strlen函数208\n13.5.3 strcat函数208\n13.5.4 strcmp函数209程序显示一个月的提醒列表209\n13.6 字符串惯用法211\n13.6.1 搜索字符串的结尾211\n13.6.2 复制字符串213\n13.7 字符串数组214\n程序核对行星的名字217\n问与答218\n练习题220\n编程题222\n第14章 预处理器225\n14.1 预处理器的工作原理225\n14.2 预处理指令227\n14.3 宏定义227\n14.3.1 简单的宏227\n14.3.2 带参数的宏229\n14.3.3 #运算符231\n14.3.4 ##运算符231\n14.3.5 宏的通用属性232\n14.3.6 宏定义中的圆括号233\n14.3.7 创建较长的宏233\n14.3.8 预定义宏234\n14.3.9 C99中新增的预定义宏235\n14.3.10 空的宏参数236\n14.3.11 参数个数可变的宏236\n14.3.12 __func__标识符237\n14.4 条件编译237\n14.4.1 #if指令和#endif指令238\n14.4.2 defined运算符238\n14.4.3 #ifdef指令和#ifndef指令239\n14.4.4 #elif指令和#else指令239\n14.4.5 使用条件编译240\n14.5 其他指令240\n14.5.1 #error指令240\n14.5.2 #line指令241\n14.5.3 #pragma指令242\n14.5.4 _Pragma运算符242\n问与答243\n练习题245\n第15章 编写大型程序248\n15.1 源文件248\n15.2 头文件249\n15.2.1 #include指令249\n15.2.2 共享宏定义和类型定义250\n15.2.3 共享函数原型251\n15.2.4 共享变量声明252\n15.2.5 嵌套包含253\n15.2.6 保护头文件253\n15.2.7 头文件中的#error指令254\n15.3 把程序划分成多个文件254程序文本格式化255\n15.4 构建多文件程序260\n15.4.1 makefile260\n15.4.2 链接期间的错误262\n15.4.3 重新构建程序262\n15.4.4 在程序外定义宏264\n问与答264\n练习题265\n编程题266\n第16章 结构、联合和枚举267\n16.1 结构变量267\n16.1.1 结构变量的声明267\n16.1.2 结构变量的初始化269\n16.1.3 指定初始化269\n16.1.4 对结构的操作270\n16.2 结构类型270\n16.2.1 结构标记的声明271\n16.2.2 结构类型的定义272\n16.2.3 结构作为参数和返回值272\n16.2.4 复合字面量273\n16.3 嵌套的数组和结构274\n16.3.1 嵌套的结构274\n16.3.2 结构数组274\n16.3.3 结构数组的初始化275程序维护零件数据库275\n16.4 联合281\n16.4.1 用联合来节省空间282\n16.4.2 用联合来构造混合的数据结构284\n16.4.3 为联合添加“标记字段”284\n16.5 枚举285\n16.5.1 枚举标记和类型名286\n16.5.2 枚举作为整数286\n16.5.3 用枚举声明“标记字段”286\n问与答287\n练习题289\n编程题293\n第17章 指针的高级应用294\n17.1 动态存储分配294\n17.1.1 内存分配函数294\n17.1.2 空指针295\n17.2 动态分配字符串296\n……\n第18章 声明 327\n第19章 程序设计 345\n第20章 底层程序设计 363\n第21章 标准库 377\n第22章 输入\/输出 384\n第23章 库对数值和字符数据的支持 419\n第24章 错误处理 446\n第25章 国际化特性 456\n第26章 其他库函数 482\n第27章 C99对数学计算的新增支持 503\n附录A C语言运算符 524\n附录B C99与C89的比较 525\n附录C C89与经典C的比较 529\n附录D 标准库函数 532\n附录E ASCII字符集 569\n参考文献 570\n索引 573","pages":"600","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s4171870.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s4171870.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s4171870.jpg"},"alt":"https:\/\/book.douban.com\/subject\/4279678\/","id":"4279678","publisher":"人民邮电出版社","isbn10":"7115219575","isbn13":"9787115219572","title":"C语言程序设计","url":"https:\/\/api.douban.com\/v2\/book\/4279678","alt_title":"C Programming: A Modern Approach, Second Edition","author_intro":"K. N. King 世界知名的计算机程序设计教育家，现为佐治亚州立大学数学与计算机科学系副教授。他拥有耶鲁大学计算机科学硕士学位，加州大学伯克利分校计算机科学博士学位，曾任教于佐治亚理工学院。除本书外，他还撰写了广受欢迎的著作Modula-2: A Complete Guide 和Java Programming: From the Beginning，并在Dr.Dobb's Journal等权威杂志上发表了许多文章。\n吕秀锋，亚洲理工大学（AIT）计算机软件硕士，现为北京理工大学软件学院教师。多年来一直从事“计算机基础（双语）”、“C语言程序设计（双语）”以及“程序设计开发与实践”等本科生课程的教学工作，深受学生欢迎。她还译有《数据结构与算法：C＃语言描述》一书。\n黄倩，中国科学院计算技术研究所工学博士，中国计算机学会会员。研究方向包括视频处理、视频监控等，已在知名的国际期刊和国际会议论文集上发表10篇论文。译有《编程珠玑（第2版）》一书，受到读者欢迎。","summary":"时至今日， C语言仍然是计算机领域的通用语言之一，但今天的 C语言已经和最初的时候大不相同了。本书最主要的一个目的就是通过一种“现代方法”来介绍 C语言，书中强调标准 C，强调软件工程，不再强调“手工优化”。这一版中紧密结合了 C99标准，并与 C89标准进行对照，补充了 C99中的最新特性。本书分为 C语言的基础特性、 C语言的高级特性、 C语言标准库和参考资料 4个部分。每章末尾都有一个“问与答”小节给出一系列与该章内容相关的问题及答案，此外还包含适量的习题。\n本书是为大学本科阶段的 C语言课程编写的教材，同时也非常适合作为其他课程的辅助用书。","series":{"id":"50484","title":"图灵程序设计丛书·C\/C++系列"},"price":"79.00元"},{"rating":{"max":10,"numRaters":133,"average":"8.0","min":0},"subtitle":"C语言描述","author":["Kyle Loudon"],"pubdate":"2012-8","tags":[{"count":270,"name":"算法","title":"算法"},{"count":103,"name":"C语言","title":"C语言"},{"count":79,"name":"编程","title":"编程"},{"count":63,"name":"计算机","title":"计算机"},{"count":48,"name":"计算机科学","title":"计算机科学"},{"count":38,"name":"程序设计","title":"程序设计"},{"count":34,"name":"C","title":"C"},{"count":31,"name":"Programming","title":"Programming"}],"origin_title":"Mastering Algorithms with C","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s11351454.jpg","binding":"平装","translator":["肖翔","陈舸"],"catalog":"1. 前言\n2. 第1部分 预备知识\n3. 第1章 概述\n4. 数据结构简介\n5. 算法简介\n6. 小酌软件工程\n7. 如何使用本书\n8. 第2章 指针操作\n9. 指针基础\n10. 存储空间分配\n11. 数据集合与指针的算术运算\n12. 作为函数参数的指针\n13. 泛型指针与类型转换\n14. 函数指针\n15. 问与答\n16. 相关主题\n17. 第3章 递归\n18. 基本递归\n19. 尾递归\n20. 问与答\n21. 相关主题\n22. 第4章 算法分析\n23. 最坏情况分析\n24. O表示法\n25. 计算的复杂度\n26. 实例分析：插入排序\n27. 问与答\n28. 相关主题\n29. 第2部分 数据结构\n30. 第5章 链表\n31. 单链表介绍\n32. 单链表接口的定义\n33. 单链表的实现与分析\n34. 使用链表的例子：页帧管理\n35. 双向链表介绍\n36. 双向链表接口的定义\n37. 双向链表的实现与分析\n38. 循环链表介绍\n39. 循环链表接口的定义\n40. 循环链表的实现与分析\n41. 使用循环链表的例子：第二次机会页面置换法\n42. 问与答\n43. 相关主题\n44. 第6章 栈和队列\n45. 栈的描述\n46. 栈的接口定义\n47. 栈的实现与分析\n48. 队列的描述\n49. 队列的接口定义\n50. 队列的实现与分析\n51. 队列示例：事件处理\n52. 问与答\n53. 相关主题\n54. 第7章 集合\n55. 集合介绍\n56. 集合的性质\n57. 集合接口的定义\n58. 集合抽象数据类型的实现和分析\n59. Set示例：集合覆盖\n60. 问与答\n61. 相关主题\n62. 第8章 哈希表\n63. 链式哈希表的描述\n64. 链式哈希表的接口定义\n65. 链式哈希表的实现与分析\n66. 链式哈希表的例子：符号表\n67. 开地址哈希表的描述\n68. 开地址哈希函数的接口定义\n69. 开地址哈希表的实现与分析\n70. 问与答\n71. 相关主题\n72. 第9章 树\n73. 二叉树介绍\n74. 二叉树的接口定义\n75. 二叉树的实现与分析\n76. 二叉树示例：表达式处理\n77. 二叉搜索树介绍\n78. 二叉搜索树的接口定义\n79. 二叉搜索树的实现与分析\n80. 问与答\n81. 相关主题\n82. 第10章 堆和优先队列\n83. 堆的描述\n84. 堆的接口定义\n85. 堆的实现与分析\n86. 优先队列的描述\n87. 优先队列的接口定义\n88. 优先队列的实现与分析\n89. 优先队列的示例：包裹分拣\n90. 问与答\n91. 相关主题\n92. 第11章 图\n93. 图的描述\n94. 图的接口定义\n95. 图的实现与分析\n96. 关于图的应用举例：计算网络跳数\n97. 关于图的应用举例：拓扑排序\n98. 问与答\n99. 相关主题\n100. 第3部分 算法\n101. 第12章 排序和搜索\n102. 插入排序的描述\n103. 插入排序的接口定义\n104. 插入排序的实现与分析\n105. 快速排序的描述\n106. 快速排序的接口定义\n107. 快速排序的实现与分析\n108. 快速排序的例子：目录列表\n109. 归并排序的描述\n110. 归并排序的接口定义\n111. 归并排序的实现与分析\n112. 计数排序的描述\n113. 计数排序的接口定义\n114. 计数排序的实现与分析\n115. 基数排序的描述\n116. 基数排序的接口定义\n117. 基数排序的实现与分析\n118. 二分查找的描述\n119. 二分查找的接口定义\n120. 二分查找的实现与分析\n121. 二分查找的例子：拼写检查器\n122. 问与答\n123. 相关主题\n124. 第13章 数值计算\n125. 多项式插值法\n126. 多项式插值的接口定义\n127. 多项式插值的实现与分析\n128. 最小二乘估计法\n129. 最小二乘估计的接口定义\n130. 最小二乘估计的实现和分析\n131. 方程求解介绍\n132. 方程求解的接口定义\n133. 方程求解的实现与分析\n134. 问与答\n135. 相关主题\n136. 第14章 数据压缩\n137. 位操作的描述\n138. 位操作的接口定义\n139. 位操作的实现与分析\n140. 霍夫曼编码的描述\n141. 霍夫曼编码的接口定义\n142. 霍夫曼编码的分析与实现\n143. 霍夫曼编码的例子：网络优化\n144. LZ77的描述\n145. LZ77的接口定义\n146. LZ77的实现与分析\n147. 问与答\n148. 相关主题\n149. 第15章 数据加密\n150. DES算法介绍\n151. DES的接口定义\n152. DES算法的实现和分析\n153. DES应用举例：分组加密模式\n154. RSA算法介绍\n155. RSA的接口定义\n156. RSA算法的实现与分析\n157. 问与答\n158. 相关主题\n159. 第16章 图算法\n160. 最小生成树的描述\n161. 最小生成树的接口定义\n162. 最小生成树的实现与分析\n163. 最短路径的描述\n164. 最短路径的接口定义\n165. 最短路径的实现与分析\n166. 最短路径的例子：路由表\n167. 旅行商问题的描述\n168. 旅行商问题的接口定义\n169. 旅行商问题的实现与分析\n170. 问与答\n171. 相关主题\n172. 第17章 几何算法\n173. 测试线段是否相交\n174. 测试线段是否相交的标准方法\n175. 检测线段是否相交的接口定义\n176. 检测线段是否相交的实现与分析\n177. 凸包简介\n178. Jarvis’s March\n179. 凸包的接口定义\n180. 凸包的实现与分析\n181. 球面弧长\n182. 求解球面弧长的接口定义\n183. 求解球面弧长的实现和分析\n184. 球面弧长的应用举例：地球上两点之间的近似距离\n185. 问与答\n186. 相关主题","pages":"401","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s11351454.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s11351454.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s11351454.jpg"},"alt":"https:\/\/book.douban.com\/subject\/14267904\/","id":"14267904","publisher":"机械工业出版社","isbn10":"7111394267","isbn13":"9787111394266","title":"算法精解","url":"https:\/\/api.douban.com\/v2\/book\/14267904","alt_title":"Mastering Algorithms with C","author_intro":"Kyle Loudon是美国加州洛斯加托斯Jeppesen Dataplan公司的一名软件工程师，主管图形接口开发小组，主攻航迹规划软件的研发，这些软件主要用于商业航空公司、私营航空部门和其他一些航空制造业。在来到Jeppesen之前，Kyle在IBM公司是一名系统程序员。在技术上，Kyle主要对操作系统、网络、人机交互等领域感兴趣。1992年，Kyle在普渡大学拿到了计算机科学学士学位，并取得了法语的第二学位，同时他还被选入斐陶斐荣誉学会（美国大学优等生之荣誉学会）。他在普渡大学计算机系教了三年的计算机课程。在这期间，他完成了他个人的第一本书《Understanding Computers》，这本书用理论结合实践的方式介绍计算机的方方面面。如今，尽管他继续工作在硅谷的软件业，但他仍然坚韧不拔地在追求一个更高的学位。\n除了计算机，Kyle多年来喜欢打网球、教网球。他还喜欢山地骑行、滑冰，偶尔也和朋友们一起参加高尔夫课程。另外，Kyle还喜欢各种形式的戏剧、美食，以及某些风格的音乐和艺术；他期望成为钢琴家和艺术家，但希望渺茫。他现在在Jeppesen的工作是从他1992年开始驾驶飞机之后找到的。现在，他是一个拥有美国联邦航空局颁发的商业飞行员执照的飞行员。","summary":"本书是数据结构和算法领域的经典之作，十余年来，畅销不衰！全书共分为三部分：第一部分首先介绍了数据结构和算法的概念，以及使用它们的原因和意义，然后讲解了数据结构和算法中最常用的技术——指针和递归，最后还介绍了算法的分析方法，旨在为读者学习这本书打下坚实的基础；第二部分对链表、栈、队列、集合、哈希表、堆、图等常用数据结构进行了深入阐述；第三部分对排序、搜索数值计算、数据压缩、数据加密、图算法、几何算法等经典算法进行了精辟的分析和讲解。\n本书的众多特色使得它在同类书中独树一帜：具体实现都采用正式的C语言代码而不是伪代码，在很多数据结构和算法的实现过程中，有大量细节问题是伪代码不能解决的；每一章都有精心组织的主题和应用；全部示例来自真实的应用，不只是一般的练习；对每种数据结构、算法和示例都进行了详细分析；每一章的末尾都会有一系列问题和对应的回答，旨在强调这一章的重要思想……\n本书中的代码尤为值得强调：所有实现都采用C语言编写，所有代码都优先用于教学目的，所有代码都在4种平台上经过完整测试，头文件记录了所有公共的接口，命名规则适用于全书所有的代码，所有的代码都包含大量注释……\n本书内容包括：\n· 数据结构和算法的概念，以及使用它们的原因和意义\n· 指针和递归\n· 算法分析\n· 常用数据结构：链表、栈、队列、集合、哈希表、树、堆、优先级队列以及图\n· 排序和搜索\n· 数值计算\n· 数据压缩\n· 数据加密\n· 图算法\n· 几何算法","price":"79.00元"},{"rating":{"max":10,"numRaters":266,"average":"9.4","min":0},"subtitle":"42 Specific Ways to Improve Your Use of C++11 and C++14","author":["Scott Meyers"],"pubdate":"2014-12","tags":[{"count":330,"name":"C++","title":"C++"},{"count":168,"name":"C++11","title":"C++11"},{"count":111,"name":"C\/C++","title":"C\/C++"},{"count":86,"name":"编程","title":"编程"},{"count":80,"name":"计算机","title":"计算机"},{"count":72,"name":"Programming","title":"Programming"},{"count":49,"name":"程序设计","title":"程序设计"},{"count":34,"name":"effective","title":"effective"}],"origin_title":"","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s27951196.jpg","binding":"Paperback","translator":[],"catalog":"","pages":"320","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s27951196.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s27951196.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s27951196.jpg"},"alt":"https:\/\/book.douban.com\/subject\/25923597\/","id":"25923597","publisher":"O'Reilly Media","isbn10":"1491903996","isbn13":"9781491903995","title":"Effective Modern C++","url":"https:\/\/api.douban.com\/v2\/book\/25923597","alt_title":"","author_intro":"Scott Meyers is one of the world's foremost authorities on C++. He wrote the best-selling Effective C++ series (Effective C++, More Effective C++, and Effective STL); published and maintains the annotated training materials Overview of the New C++ (C++11\/14) and Effective C++ in an Embedded Environment; is Consulting Editor for the Effective Software Development Series, and, with Herb Sutter and Andrei Alexandrescu, is a principal in C++ and Beyond. He has a Ph.D in Computer Science from Brown University. He's currently working on a new book, Effective Modern C++, which he expects to publish this fall.","summary":"Learn how to program expertly with C++ with this practical book from Scott Meyers, one of the world's foremost authorities on this systems programming language. Scott Meyers takes some of the most difficult pieces of C++ code and unfurls them so that you can see how to manipulate your own project code. This is the first book to contain content written with the C++14 standard.\nTackle 42 separate C++ problems and solutions\nLearn critical techniques for success on topics from smart pointers to lambda expressions\nUnderstand key concepts by taking the C++ 98 standard to C++ 11 and then to C++ 14","price":"USD 49.99"},{"rating":{"max":10,"numRaters":625,"average":"9.1","min":0},"subtitle":"N．C. Wyeth 插图官方授权版本","author":["[美] 玛•金•罗琳斯"],"pubdate":"2016-6-1","tags":[{"count":198,"name":"自然","title":"自然"},{"count":183,"name":"美国文学","title":"美国文学"},{"count":183,"name":"外国文学","title":"外国文学"},{"count":146,"name":"玛•金•罗琳斯","title":"玛•金•罗琳斯"},{"count":136,"name":"美国","title":"美国"},{"count":135,"name":"成长","title":"成长"},{"count":129,"name":"我想读这本书","title":"我想读这本书"},{"count":128,"name":"小说","title":"小说"}],"origin_title":"The Yearling","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28748579.jpg","binding":"平装","translator":["梅静"],"catalog":"目录\n第一章 小水车\n第二章 乔迪的家\n第三章 飞来横祸\n第四章 猎熊\n第五章 草翅膀\n第六章 大快朵颐\n第七章 一桩好买卖\n第八章 意外收获\n第九章 灰岩坑\n第十章 夜晚的奇遇\n第十一章 猎鹿\n第十二章 仗义相助\n第十三章 告别奥利弗\n第十四章 危机\n第十五章 新伙伴\n第十六章 偷蜜和猎狐\n第十七章 痛失好友\n第十八章 怀念“草翅膀”\n第十九章 暴风雨\n第二十章 暴风雨后的森林\n第二十一章 瘟疫\n第二十二章 储粮\n第二十三章 狼群的夜袭\n第二十四章 猎狼\n第二十五章圣诞节前夕\n第二十六章 追捕“大笨脚”\n第二十七章 送别\n第二十八章 孤狼\n第二十九章 闯祸\n第三十章 爸爸病了\n第三十一章 无计可施\n第三十二章 再见，小鹿\n第三十三章 别了，童年","ebook_url":"https:\/\/read.douban.com\/ebook\/22165742\/","pages":"432","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s28748579.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s28748579.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28748579.jpg"},"alt":"https:\/\/book.douban.com\/subject\/26801361\/","id":"26801361","publisher":"云南人民出版社","isbn10":"7222145583","isbn13":"9787222145580","title":"鹿苑长春","url":"https:\/\/api.douban.com\/v2\/book\/26801361","alt_title":"The Yearling","author_intro":"【作者 】\n玛•金•罗琳斯\nMarjorie Kinnan Rawlings\n1896-1953\n美国作家  生于华盛顿， 毕业于威斯康星大学， 在纽约担任多年记者、编辑\n创建了佛罗里达边远林区的“地方文学”\n先后获得普利策奖、 欧·亨利奖、兰登书屋终身畅销奖\n创作的两部长篇小说《鹿苑长春》和《十字小溪》先后荣获普利策文学奖\n代表作《鹿苑长春》《十字小溪》《一位年轻姑娘》《南方月亮下》《金苹果》等\n【绘者】\nN.C.韦思\nNewell Convers Wyeth\n1882—1956\n美国现实主义绘画大师  一生创作近4000幅画作\n画作现收藏于布兰迪万河博物馆 、波特兰艺术博物馆和法恩斯沃斯艺术博物馆。1997年，他生活和工作的地方（宾夕法尼亚州查兹福德小镇墨菲路）被美国政府指定为国家历史地标之一。\n【译者】\n梅静\n北京大学外国语学院翻译硕士\n译有《柳林风声》《小鹿斑比》《小公主》《威士忌海滩》《孪生姐妹》《想飞的乔琪》《布谷鸟的呼唤》。","summary":"【“任何人遇到挫折的时候，都能够从这里得到新的勇气。”】\n【内容简介】\n《鹿苑长春》由美国作家玛·金·罗琳斯创作于1938年，根据佛罗里达林区一位老人的童年回忆创作改编，发行后登上美国畅销书榜首并持续140周，于次年获得普利策文学奖。至今，在美国累计阅读量达到5.5亿。至今，该小说被翻译成20种语言，在133个国家出版，受到不同地域和文化人们的喜爱。在1946年被米高梅公司拍摄成电影，获得奥斯卡最佳艺术指导奖和最佳摄影奖。\n故事讲述美国南北战争后佛罗里达垦荒区普通人的劳动、斗争和悲欢离合。主人公巴克斯特一家生活在佛罗里达岛地过着自给自足的农耕狩猎生活，所处的自然美景中是一幅生动绚丽的丛林画卷，该作品后被誉为描绘少年时代的经典童年诗歌。然而，它却是一本全年龄段读本，书中透出的森林清新气息和舒缓节奏，与当代都市生活迥然不同。其中有惊险的狩猎、奇妙的自然景观、悠然的乡村美景，还有风趣幽默的人物对话，以及充满泥土气息的方言。书中人们为了生存这一简单目的，持有着最质朴的勇气和信念。\n孩子们可以从书中读到激动人心的狩猎，看见原野林莽、飞鸟起落、狼踪熊迹、暴雨狂风，进入乔迪的世界，与他共度被爸爸精心呵护、无忧无虑的童年。成年人，尤其是经历过离合悲欢、人世艰难的人，都能从书中读出欢笑、甜蜜、惆怅和感伤。\n【编辑推荐】\n《鹿苑长春》是一部经典的动物文学与环境文学著作。\n故事发生在美国南北战争结束后的垦荒时代，讲述与父母生活在佛罗里达岛地的男孩乔迪与一岁小鹿间的故事。\n爸爸在牧师家庭长大，正直善良，从不说谎，因经历战争后，厌倦了与人相处的世俗，带着妻子奥拉远离城镇，选择佛罗里达的巴克斯特岛地，过着狩猎农耕的生活。家中的生计依赖于自然选择，时常受到岛地周围野兽的威胁，尤其是经常出没偷食家畜的棕熊“大笨脚”。\n因为自然环境的严酷，夫妻两人连续夭折了3个孩子，以至于乔迪诞生后，妈妈奥拉因为遭遇太多次失去，对儿子不抱有太多疼爱，也许是向现实的冷酷低头，看待事物抱有异常冷漠的清醒。爸爸彭尼从小在家中担起大梁，了解天真无邪的珍贵，反而给乔迪加倍的疼爱，试图延长乔迪无忧无虑的童年。在丛林里，有变幻的迷人风光，也有让人惊叹的动物奇观。乔迪一直喜欢听猎人讲在狩猎途中的奇遇，期待着自己与动物的亲近。\n他跟着爸爸狩猎，追踪“大笨脚”，爬在树上看鹿妈妈带着小鹿啃食树叶，与爸爸抓到罕见的白色浣熊、在克拉克莎草丛中钓鱼，遇到高鸣鹤跳沙龙舞；他跟着巴克.福利斯特在月光下的玉米地里猎狐，去松树干掏蜂蜜；与好友“草翅膀”喂养小浣熊、欧洲灰雀，一起看西班牙人后裔穿过古栈道，一起数天上米诺鱼般的星星……生活就像他给自己在灰岩坑水塘边造的小水车，随着时间的流水，悠然转动，奏出欢快的乐章，似乎没有停下来的理由。\n然而乔迪作为独子，在偏远岛地，一直是孤寂的。他希望能像爸爸彭尼一样拥有只对自己忠诚的宠物。因为口粮不足，妈妈却一直拒绝驯养动物。直到有一天，在乔迪跟随爸爸追踪走失家猪的途中，遭遇危机，也遇到了那头刚出生不久的小鹿……\n故事讲失去，也讲成长；讲孤独，也讲爱与宽容。每个人也许会从中找到真挚的共鸣，遗憾和怅惘，但更多的是，是勇气。\n【名人推荐】\n“谈到近人的作品，说「不朽」总彷佛还太早，然而《鹿苑长春》在近代文学上的地位已经奠定了。《鹿苑长春》里面出现的动物比人多──鹿、响尾蛇、八字脚的老熊、牛、马、猪──像一个动物园，但是里面的人物，尤其是那男孩子乔迪，是使人永远不能忘记的。\n那孩子失去了他最心爱的东西，使他受到很深的刺激，然而他从此就坚强起来，长大成人了。我们仔细回味，就可以觉得这不止于是一个孩子的故事，任何人遇到挫折的时候，都能够从这里得到新的勇气。\n这故事具有真正的悲剧的因素──无法避免，也不可挽回。书中对于儿童心理有非常深入的描写，可以帮助做父母的人了解自己的子女。写父爱也发掘到人性的深处。\n它是健康的，向上的，但也许它最动人的地方是与东方的心情特别接近的一种淡淡的哀愁。最后的两段更是充满了一种难堪的怅惘，我译到这里的时候，甚至于译完之后重抄一遍，抄到这里的时候，也都是像第一次读到一样地觉得非常感动，眼睛湿润起来。我相信许多读者一定也有同感。”\n——张爱玲\n【媒体推荐】\n\n在罗琳斯女士之前，还没有谁创造出如此栩栩如生且亲近读者的一系列形象，其亲密的感情感染人，不禁令人产生共鸣。\n——纽约时报\n“Never before has Mrs. Rawlings created a set of characters who are so close and real to the reader, whose intimate life one can share without the taint of unconscious patronage.\" (The New York Times)\n惊心动魄的探险和令人怅惘的人性元素……这是一部不愧于普利策奖桂冠的经典作品，故事质朴的语言和四季变化下的生态智慧，都给予这本书一种独特而难忘的气质。而画家N.C.韦思也以温暖、柔和的插图，恰到好处地捕捉到那个垦荒时代的粗莽和淳美。\n——亚马逊网站\n“Heart-stopping adventure and heart-wrenching human element…. This is a classic well worth its Pulitzer Prize. Earthy dialect and homespun wisdom season the story, giving it a unique and unforgettable flavor, and N.C. Wyeth's warm, soft illustrations capture an era of rough subsistence and sweet survival.”\n(Amazon.com)","ebook_price":"12.00","price":"48.00元"},{"rating":{"max":10,"numRaters":531,"average":"8.9","min":0},"subtitle":"使用Visual C++5.0 & MFC 4.2","author":["侯俊杰"],"pubdate":"2001-1","tags":[{"count":303,"name":"MFC","title":"MFC"},{"count":174,"name":"C++","title":"C++"},{"count":108,"name":"计算机","title":"计算机"},{"count":92,"name":"编程","title":"编程"},{"count":74,"name":"深入浅出MFC","title":"深入浅出MFC"},{"count":72,"name":"侯捷","title":"侯捷"},{"count":64,"name":"Windows","title":"Windows"},{"count":38,"name":"经典","title":"经典"}],"origin_title":"","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28952279.jpg","binding":"平装16开","translator":[],"catalog":"第一篇 勿在浮砂筑高台\n第一章 Win32 程序基本概念\n第二章 C++的重要性质\n第三章 MFC六大关键技术之仿真\n第二篇 欲善工事先利其器\n第四章 Visual C++ 集成开发环境\n第三篇 浅出MFC程序设计\n第五章 总观Application Framework\n第六章 MFC程序的生死因果\n第七章 简单而完整：MFC骨干程序\n第四篇 深入MFC 程序设计\n第八章 Document-View深入探讨\n第九章 消息映射与命令传递\n第十章 MFC与对话框\n第十一章 Vies功能的加强与重绘效率的提高\n第十二章 打印与预览\n第十三章 多重文件与多重视图\n第十四章 MFC 多线程程序设计\n第十五章 站在众人的肩膀――使用Components & ActiveX Controls\n第五篇 附录","pages":"701","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s28952279.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s28952279.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28952279.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1094852\/","id":"1094852","publisher":"华中科技大学出版社","isbn10":"7900614931","isbn13":"9787900614933","title":"深入浅出MFC （第二版）","url":"https:\/\/api.douban.com\/v2\/book\/1094852","alt_title":"","author_intro":"侯俊杰（1961年9月28日－），笔名侯捷，台湾知名电脑技术专栏作家，致力于电脑技术之扎根工作，文章兼具科技之长与灵性之美，有读者的评语是“比作家更工程师，比工程师更作家”。大同国中、师大附中、交通大学土木系毕业、清华大学动力机械研究所硕士。曾任职工研院机械所与电通所，曾在元智大学授课，近年来多从事两岸学术交流工作。他的妻子美静是一名钢琴师，侯俊杰说他自己“嗜咖啡。妻严不能常得。”","summary":"《深入浅出MFC》分为四大篇。第一篇提出学习MFC程序设计之前的必要基础，包括Widnows程序的基本观念以及C++的高阶议题。“学前基础”是相当主观的认定，但作者是甚于自己的学习经验以及教学经验，其挑选应该颇具说服力。第二篇介绍Visual C++整合环境开发工具。此篇只是提纲挈领，并不企图取代Visual C++使用手册；然而对于软件使用的老手，此篇或已足以帮助掌握Visual C++整合环境。工具的使用虽然谈不上学问，但在视觉化软件开发过程中扮演极重角色。第三篇介绍application framework的观念，以及MFC骨干程序，所谓骨干程序，是指Visual C++的工具AppWizard所产生出来的程序码。当然，AppWizard会根据使用者的选项做出不同的程序码，作者据以解说的是大众化选项下的产品。第四篇以微软公司附于Visual C++光碟片上的一个范例程序Scribble为主轴，一步一步加上新的功能；并在其间深入介绍Runtime Type Information（RTTI）、Dynamic Creation、Persistence（Serialization）、Message Mapping、Command Routing等核心技术。这些技术正是其他专著最缺乏的部分。此篇的最后数章则脱离Scribble程序，另成一格。\n这本书配有一片光盘，书中所有原始码与可执行文件都在其中。","price":"80.00元"},{"rating":{"max":10,"numRaters":457,"average":"8.8","min":0},"subtitle":"使用muduo C++网络库","author":["陈硕"],"pubdate":"2013-1-15","tags":[{"count":607,"name":"网络编程","title":"网络编程"},{"count":543,"name":"Linux","title":"Linux"},{"count":541,"name":"C++","title":"C++"},{"count":454,"name":"多线程","title":"多线程"},{"count":155,"name":"计算机","title":"计算机"},{"count":143,"name":"编程","title":"编程"},{"count":110,"name":"C\/C++","title":"C\/C++"},{"count":87,"name":"Networks","title":"Networks"}],"origin_title":"","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s24522799.jpg","binding":"平装","translator":[],"catalog":"第1 部分C++ 多线程系统编程1\n第1章 线程安全的对象生命期管理3\n1.1 当析构函数遇到多线程. . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n1.1.1 线程安全的定义. . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\n1.1.2 MutexLock 与MutexLockGuard . . . . . . . . . . . . . . . . . . . . 4\n1.1.3 一个线程安全的Counter 示例. . . . . . . . . . . . . . . . . . . . 4\n1.2 对象的创建很简单. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n1.3 销毁太难. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n1.3.1 mutex 不是办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n1.3.2 作为数据成员的mutex 不能保护析构. . . . . . . . . . . . . . . 8\n1.4 线程安全的Observer 有多难. . . . . . . . . . . . . . . . . . . . . . . . . 8\n1.5 原始指针有何不妥. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n1.6 神器shared_ptr\/weak_ptr . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n1.7 插曲：系统地避免各种指针错误. . . . . . . . . . . . . . . . . . . . . . . 14\n1.8 应用到Observer 上. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\n1.9 再论shared_ptr 的线程安全. . . . . . . . . . . . . . . . . . . . . . . . . 17\n1.10 shared_ptr 技术与陷阱. . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n1.11 对象池. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21\n1.11.1 enable_shared_from_this . . . . . . . . . . . . . . . . . . . . . . 23\n1.11.2 弱回调. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\n1.12 替代方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n1.13 心得与小结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n1.14 Observer 之谬. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\n第2章 线程同步精要31\n2.1 互斥器（mutex） . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32\n2.1.1 只使用非递归的mutex . . . . . . . . . . . . . . . . . . . . . . . . 33\n2.1.2 死锁. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\n2.2 条件变量（condition variable） . . . . . . . . . . . . . . . . . . . . . . . 40\n2.3 不要用读写锁和信号量. . . . . . . . . . . . . . . . . . . . . . . . . . . . 43\n2.4 封装MutexLock、MutexLockGuard、Condition . . . . . . . . . . . . . . 44\n2.5 线程安全的Singleton 实现. . . . . . . . . . . . . . . . . . . . . . . . . . 48\n2.6 sleep(3) 不是同步原语. . . . . . . . . . . . . . . . . . . . . . . . . . . . 50\n2.7 归纳与总结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\n2.8 借shared_ptr 实现copy-on-write . . . . . . . . . . . . . . . . . . . . . . 52\n第3章 多线程服务器的适用场合与常用编程模型59\n3.1 进程与线程. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59\n3.2 单线程服务器的常用编程模型. . . . . . . . . . . . . . . . . . . . . . . . 61\n3.3 多线程服务器的常用编程模型. . . . . . . . . . . . . . . . . . . . . . . . 62\n3.3.1 one loop per thread . . . . . . . . . . . . . . . . . . . . . . . . . . 62\n3.3.2 线程池. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63\n3.3.3 推荐模式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64\n3.4 进程间通信只用TCP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65\n3.5 多线程服务器的适用场合. . . . . . . . . . . . . . . . . . . . . . . . . . . 67\n3.5.1 必须用单线程的场合. . . . . . . . . . . . . . . . . . . . . . . . . 69\n3.5.2 单线程程序的优缺点. . . . . . . . . . . . . . . . . . . . . . . . . 70\n3.5.3 适用多线程程序的场景. . . . . . . . . . . . . . . . . . . . . . . . 71\n3.6 “多线程服务器的适用场合”例释与答疑. . . . . . . . . . . . . . . . . . 74\n第4章 C++ 多线程系统编程精要83\n4.1 基本线程原语的选用. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84\n4.2 C\/C++ 系统库的线程安全性. . . . . . . . . . . . . . . . . . . . . . . . . 85\n4.3 Linux 上的线程标识. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89\n4.4 线程的创建与销毁的守则. . . . . . . . . . . . . . . . . . . . . . . . . . . 91\n4.4.1 pthread_cancel 与C++ . . . . . . . . . . . . . . . . . . . . . . . 94\n4.4.2 exit(3) 在C++ 中不是线程安全的. . . . . . . . . . . . . . . . . 94\n4.5 善用__thread 关键字. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96\n4.6 多线程与IO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98\n4.7 用RAII 包装文件描述符. . . . . . . . . . . . . . . . . . . . . . . . . . . 99\n4.8 RAII 与fork() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101\n4.9 多线程与fork() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102\n4.10 多线程与signal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103\n4.11 Linux 新增系统调用的启示. . . . . . . . . . . . . . . . . . . . . . . . . . 105\n第5章 高效的多线程日志107\n5.1 功能需求. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109\n5.2 性能需求. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112\n5.3 多线程异步日志. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114\n5.4 其他方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120\n第2部分 muduo 网络库123\n第6章 muduo 网络库简介125\n6.1 由来. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125\n6.2 安装. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127\n6.3 目录结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129\n6.3.1 代码结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131\n6.3.2 例子. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134\n6.3.3 线程模型. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135\n6.4 使用教程. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136\n6.4.1 TCP 网络编程本质论. . . . . . . . . . . . . . . . . . . . . . . . . 136\n6.4.2 echo 服务的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . 138\n6.4.3 七步实现finger 服务. . . . . . . . . . . . . . . . . . . . . . . . . 140\n6.5 性能评测. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144\n6.5.1 muduo 与Boost.Asio、libevent2 的吞吐量对比. . . . . . . . . . 145\n6.5.2 击鼓传花：对比muduo 与libevent2 的事件处理效率. . . . . . 148\n6.5.3 muduo 与Nginx 的吞吐量对比. . . . . . . . . . . . . . . . . . . 153\n6.5.4 muduo 与ZeroMQ 的延迟对比. . . . . . . . . . . . . . . . . . . 156\n6.6 详解muduo 多线程模型. . . . . . . . . . . . . . . . . . . . . . . . . . . 157\n6.6.1 数独求解服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . . 157\n6.6.2 常见的并发网络服务程序设计方案. . . . . . . . . . . . . . . . . 160\n第7章 muduo 编程示例177\n7.1 五个简单TCP 示例. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178\n7.2 文件传输. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185\n7.3 Boost.Asio 的聊天服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . 194\n7.3.1 TCP 分包. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194\n7.3.2 消息格式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195\n7.3.3 编解码器LengthHeaderCodec . . . . . . . . . . . . . . . . . . . . 197\n7.3.4 服务端的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198\n7.3.5 客户端的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200\n7.4 muduo Buffer 类的设计与使用. . . . . . . . . . . . . . . . . . . . . . . 204\n7.4.1 muduo 的IO 模型. . . . . . . . . . . . . . . . . . . . . . . . . . 204\n7.4.2 为什么non-blocking 网络编程中应用层buffer 是必需的. . . . 205\n7.4.3 Buffer 的功能需求. . . . . . . . . . . . . . . . . . . . . . . . . . 207\n7.4.4 Buffer 的数据结构. . . . . . . . . . . . . . . . . . . . . . . . . . 209\n7.4.5 Buffer 的操作. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211\n7.4.6 其他设计方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217\n7.4.7 性能是不是问题. . . . . . . . . . . . . . . . . . . . . . . . . . . . 218\n7.5 一种自动反射消息类型的Google Protobuf 网络传输方案. . . . . . . . 220\n7.5.1 网络编程中使用Protobuf 的两个先决条件. . . . . . . . . . . . . 220\n7.5.2 根据type name 反射自动创建Message 对象. . . . . . . . . . . . 221\n7.5.3 Protobuf 传输格式. . . . . . . . . . . . . . . . . . . . . . . . . . 226\n7.6 在muduo 中实现Protobuf 编解码器与消息分发器. . . . . . . . . . . . 228\n7.6.1 什么是编解码器（codec） . . . . . . . . . . . . . . . . . . . . . . 229\n7.6.2 实现ProtobufCodec . . . . . . . . . . . . . . . . . . . . . . . . . 232\n7.6.3 消息分发器（dispatcher）有什么用. . . . . . . . . . . . . . . . 232\n7.6.4 ProtobufCodec 与ProtobufDispatcher 的综合运用. . . . . . . 233\n7.6.5 ProtobufDispatcher 的两种实现. . . . . . . . . . . . . . . . . . 234\n7.6.6 ProtobufCodec 和ProtobufDispatcher 有何意义. . . . . . . . . 236\n7.7 限制服务器的最大并发连接数. . . . . . . . . . . . . . . . . . . . . . . . 237\n7.7.1 为什么要限制并发连接数. . . . . . . . . . . . . . . . . . . . . . 237\n7.7.2 在muduo 中限制并发连接数. . . . . . . . . . . . . . . . . . . . 238\n7.8 定时器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240\n7.8.1 程序中的时间. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240\n7.8.2 Linux 时间函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . 241\n7.8.3 muduo 的定时器接口. . . . . . . . . . . . . . . . . . . . . . . . . 242\n7.8.4 Boost.Asio Timer 示例. . . . . . . . . . . . . . . . . . . . . . . . 243\n7.8.5 Java Netty 示例. . . . . . . . . . . . . . . . . . . . . . . . . . . . 245\n7.9 测量两台机器的网络延迟和时间差. . . . . . . . . . . . . . . . . . . . . 248\n7.10 用timing wheel 踢掉空闲连接. . . . . . . . . . . . . . . . . . . . . . . . 250\n7.10.1 timing wheel 原理. . . . . . . . . . . . . . . . . . . . . . . . . . 251\n7.10.2 代码实现与改进. . . . . . . . . . . . . . . . . . . . . . . . . . . . 254\n7.11 简单的消息广播服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257\n7.12 “串并转换”连接服务器及其自动化测试. . . . . . . . . . . . . . . . . . 260\n7.13 socks4a 代理服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264\n7.13.1 TCP 中继器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264\n7.13.2 socks4a 代理服务器. . . . . . . . . . . . . . . . . . . . . . . . . . 267\n7.13.3 N : 1 与1 : N 连接转发. . . . . . . . . . . . . . . . . . . . . . . . 267\n7.14 短址服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267\n7.15 与其他库集成. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268\n7.15.1 UDNS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270\n7.15.2 c-ares DNS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272\n7.15.3 curl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273\n7.15.4 更多. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275\n第8章 muduo 网络库设计与实现277\n8.0 什么都不做的EventLoop . . . . . . . . . . . . . . . . . . . . . . . . . . . 277\n8.1 Reactor 的关键结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280\n8.1.1 Channel class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280\n8.1.2 Poller class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283\n8.1.3 EventLoop 的改动. . . . . . . . . . . . . . . . . . . . . . . . . . . 287\n8.2 TimerQueue 定时器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290\n8.2.1 TimerQueue class . . . . . . . . . . . . . . . . . . . . . . . . . . . 290\n8.2.2 EventLoop 的改动. . . . . . . . . . . . . . . . . . . . . . . . . . . 292\n8.3 EventLoop::runInLoop() 函数. . . . . . . . . . . . . . . . . . . . . . . . 293\n8.3.1 提高TimerQueue 的线程安全性. . . . . . . . . . . . . . . . . . . 296\n8.3.2 EventLoopThread class . . . . . . . . . . . . . . . . . . . . . . . . 297\n8.4 实现TCP 网络库. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299\n8.5 TcpServer 接受新连接. . . . . . . . . . . . . . . . . . . . . . . . . . . . 303\n8.5.1 TcpServer class . . . . . . . . . . . . . . . . . . . . . . . . . . . . 304\n8.5.2 TcpConnection class . . . . . . . . . . . . . . . . . . . . . . . . . 305\n8.6 TcpConnection 断开连接. . . . . . . . . . . . . . . . . . . . . . . . . . . 308\n8.7 Buffer 读取数据. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 313\n8.7.1 TcpConnection 使用Buffer 作为输入缓冲. . . . . . . . . . . . . 314\n8.7.2 Buffer::readFd() . . . . . . . . . . . . . . . . . . . . . . . . . . 315\n8.8 TcpConnection 发送数据. . . . . . . . . . . . . . . . . . . . . . . . . . . 316\n8.9 完善TcpConnection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 320\n8.9.1 SIGPIPE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321\n8.9.2 TCP No Delay 和TCP keepalive . . . . . . . . . . . . . . . . . . 321\n8.9.3 WriteCompleteCallback 和HighWaterMarkCallback . . . . . . . 322\n8.10 多线程TcpServer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 324\n8.11 Connector . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327\n8.12 TcpClient . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 332\n8.13 epoll . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333\n8.14 测试程序一览. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 336\n第3部分 工程实践经验谈337\n第9章 分布式系统工程实践339\n9.1 我们在技术浪潮中的位置. . . . . . . . . . . . . . . . . . . . . . . . . . . 341\n9.1.1 分布式系统的本质困难. . . . . . . . . . . . . . . . . . . . . . . . 343\n9.1.2 分布式系统是个险恶的问题. . . . . . . . . . . . . . . . . . . . . 344\n9.2 分布式系统的可靠性浅说. . . . . . . . . . . . . . . . . . . . . . . . . . . 349\n9.2.1 分布式系统的软件不要求7  24 可靠. . . . . . . . . . . . . . . . 352\n9.2.2 “能随时重启进程”作为程序设计目标. . . . . . . . . . . . . . . 354\n9.3 分布式系统中心跳协议的设计. . . . . . . . . . . . . . . . . . . . . . . . 356\n9.4 分布式系统中的进程标识. . . . . . . . . . . . . . . . . . . . . . . . . . . 360\n9.4.1 错误做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361\n9.4.2 正确做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 362\n9.4.3 TCP 协议的启示. . . . . . . . . . . . . . . . . . . . . . . . . . . . 363\n9.5 构建易于维护的分布式程序. . . . . . . . . . . . . . . . . . . . . . . . . 364\n9.6 为系统演化做准备. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 367\n9.6.1 可扩展的消息格式. . . . . . . . . . . . . . . . . . . . . . . . . . 368\n9.6.2 反面教材：ICE 的消息打包格式. . . . . . . . . . . . . . . . . . . 369\n9.7 分布式程序的自动化回归测试. . . . . . . . . . . . . . . . . . . . . . . . 370\n9.7.1 单元测试的能与不能. . . . . . . . . . . . . . . . . . . . . . . . . 370\n9.7.2 分布式系统测试的要点. . . . . . . . . . . . . . . . . . . . . . . . 373\n9.7.3 分布式系统的抽象观点. . . . . . . . . . . . . . . . . . . . . . . . 374\n9.7.4 一种自动化的回归测试方案. . . . . . . . . . . . . . . . . . . . . 375\n9.7.5 其他用处. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 379\n9.8 分布式系统部署、监控与进程管理的几重境界. . . . . . . . . . . . . . . 380\n9.8.1 境界1：全手工操作. . . . . . . . . . . . . . . . . . . . . . . . . 382\n9.8.2 境界2：使用零散的自动化脚本和第三方组件. . . . . . . . . . . 383\n9.8.3 境界3：自制机群管理系统，集中化配置. . . . . . . . . . . . . 386\n9.8.4 境界4：机群管理与naming service 结合. . . . . . . . . . . . . 389\n第10章 C++ 编译链接模型精要391\n10.1 C 语言的编译模型及其成因. . . . . . . . . . . . . . . . . . . . . . . . . 394\n10.1.1 为什么C 语言需要预处理. . . . . . . . . . . . . . . . . . . . . . 395\n10.1.2 C 语言的编译模型. . . . . . . . . . . . . . . . . . . . . . . . . . . 398\n10.2 C++ 的编译模型. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399\n10.2.1 单遍编译. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399\n10.2.2 前向声明. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 402\n10.3 C++ 链接（linking） . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 404\n10.3.1 函数重载. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 406\n10.3.2 inline 函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 407\n10.3.3 模板. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 409\n10.3.4 虚函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 414\n10.4 工程项目中头文件的使用规则. . . . . . . . . . . . . . . . . . . . . . . . 415\n10.4.1 头文件的害处. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 416\n10.4.2 头文件的使用规则. . . . . . . . . . . . . . . . . . . . . . . . . . 417\n10.5 工程项目中库文件的组织原则. . . . . . . . . . . . . . . . . . . . . . . . 418\n10.5.1 动态库是有害的. . . . . . . . . . . . . . . . . . . . . . . . . . . . 423\n10.5.2 静态库也好不到哪儿去. . . . . . . . . . . . . . . . . . . . . . . . 424\n10.5.3 源码编译是王道. . . . . . . . . . . . . . . . . . . . . . . . . . . . 428\n第11章 反思C++ 面向对象与虚函数429\n11.1 朴实的C++ 设计. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 429\n11.2 程序库的二进制兼容性. . . . . . . . . . . . . . . . . . . . . . . . . . . . 431\n11.2.1 什么是二进制兼容性. . . . . . . . . . . . . . . . . . . . . . . . . 432\n11.2.2 有哪些情况会破坏库的ABI . . . . . . . . . . . . . . . . . . . . . 433\n11.2.3 哪些做法多半是安全的. . . . . . . . . . . . . . . . . . . . . . . . 435\n11.2.4 反面教材：COM . . . . . . . . . . . . . . . . . . . . . . . . . . . 435\n11.2.5 解决办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 436\n11.3 避免使用虚函数作为库的接口. . . . . . . . . . . . . . . . . . . . . . . . 436\n11.3.1 C++ 程序库的作者的生存环境. . . . . . . . . . . . . . . . . . . . 437\n11.3.2 虚函数作为库的接口的两大用途. . . . . . . . . . . . . . . . . . 438\n11.3.3 虚函数作为接口的弊端. . . . . . . . . . . . . . . . . . . . . . . . 439\n11.3.4 假如Linux 系统调用以COM 接口方式实现. . . . . . . . . . . . 442\n11.3.5 Java 是如何应对的. . . . . . . . . . . . . . . . . . . . . . . . . . 443\n11.4 动态库接口的推荐做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . 443\n11.5 以boost::function 和boost::bind 取代虚函数. . . . . . . . . . . . . 447\n11.5.1 基本用途. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 450\n11.5.2 对程序库的影响. . . . . . . . . . . . . . . . . . . . . . . . . . . . 451\n11.5.3 对面向对象程序设计的影响. . . . . . . . . . . . . . . . . . . . . 453\n11.6 iostream 的用途与局限. . . . . . . . . . . . . . . . . . . . . . . . . . . . 457\n11.6.1 stdio 格式化输入输出的缺点. . . . . . . . . . . . . . . . . . . . . 457\n11.6.2 iostream 的设计初衷. . . . . . . . . . . . . . . . . . . . . . . . . 461\n11.6.3 iostream 与标准库其他组件的交互. . . . . . . . . . . . . . . . . 463\n11.6.4 iostream 在使用方面的缺点. . . . . . . . . . . . . . . . . . . . . 464\n11.6.5 iostream 在设计方面的缺点. . . . . . . . . . . . . . . . . . . . . 468\n11.6.6 一个300 行的memory buffer output stream . . . . . . . . . . . 476\n11.6.7 现实的C++ 程序如何做文件IO . . . . . . . . . . . . . . . . . . . 480\n11.7 值语义与数据抽象. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482\n11.7.1 什么是值语义. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482\n11.7.2 值语义与生命期. . . . . . . . . . . . . . . . . . . . . . . . . . . . 483\n11.7.3 值语义与标准库. . . . . . . . . . . . . . . . . . . . . . . . . . . . 488\n11.7.4 值语义与C++ 语言. . . . . . . . . . . . . . . . . . . . . . . . . . 488\n11.7.5 什么是数据抽象. . . . . . . . . . . . . . . . . . . . . . . . . . . . 490\n11.7.6 数据抽象所需的语言设施. . . . . . . . . . . . . . . . . . . . . . 493\n11.7.7 数据抽象的例子. . . . . . . . . . . . . . . . . . . . . . . . . . . . 495\n第12章 C++ 经验谈501\n12.1 用异或来交换变量是错误的. . . . . . . . . . . . . . . . . . . . . . . . . 501\n12.1.1 编译器会分别生成什么代码. . . . . . . . . . . . . . . . . . . . . 503\n12.1.2 为什么短的代码不一定快. . . . . . . . . . . . . . . . . . . . . . 505\n12.2 不要重载全局::operator new() . . . . . . . . . . . . . . . . . . . . . . 507\n12.2.1 内存管理的基本要求. . . . . . . . . . . . . . . . . . . . . . . . . 507\n12.2.2 重载::operator new() 的理由. . . . . . . . . . . . . . . . . . . 508\n12.2.3 ::operator new() 的两种重载方式. . . . . . . . . . . . . . . . . 508\n12.2.4 现实的开发环境. . . . . . . . . . . . . . . . . . . . . . . . . . . . 509\n12.2.5 重载::operator new() 的困境. . . . . . . . . . . . . . . . . . . 510\n12.2.6 解决办法：替换malloc() . . . . . . . . . . . . . . . . . . . . . . 512\n12.2.7 为单独的class 重载::operator new() 有问题吗. . . . . . . . . 513\n12.2.8 有必要自行定制内存分配器吗. . . . . . . . . . . . . . . . . . . . 513\n12.3 带符号整数的除法与余数. . . . . . . . . . . . . . . . . . . . . . . . . . . 514\n12.3.1 语言标准怎么说. . . . . . . . . . . . . . . . . . . . . . . . . . . . 515\n12.3.2 C\/C++ 编译器的表现. . . . . . . . . . . . . . . . . . . . . . . . . 516\n12.3.3 其他语言的规定. . . . . . . . . . . . . . . . . . . . . . . . . . . . 516\n12.3.4 脚本语言解释器代码. . . . . . . . . . . . . . . . . . . . . . . . . 517\n12.3.5 硬件实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521\n12.4 在单元测试中mock 系统调用. . . . . . . . . . . . . . . . . . . . . . . . 522\n12.4.1 系统函数的依赖注入. . . . . . . . . . . . . . . . . . . . . . . . . 522\n12.4.2 链接期垫片（link seam） . . . . . . . . . . . . . . . . . . . . . . 524\n12.5 慎用匿名namespace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 526\n12.5.1 C 语言的static 关键字的两种用法. . . . . . . . . . . . . . . . . 526\n12.5.2 C++ 语言的static 关键字的四种用法. . . . . . . . . . . . . . . . 526\n12.5.3 匿名namespace 的不利之处. . . . . . . . . . . . . . . . . . . . . 527\n12.5.4 替代办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 529\n12.6 采用有利于版本管理的代码格式. . . . . . . . . . . . . . . . . . . . . . . 529\n12.6.1 对diff 友好的代码格式. . . . . . . . . . . . . . . . . . . . . . . . 530\n12.6.2 对grep 友好的代码风格. . . . . . . . . . . . . . . . . . . . . . . 537\n12.6.3 一切为了效率. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 538\n12.7 再探std::string . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539\n12.7.1 直接拷贝（eager copy） . . . . . . . . . . . . . . . . . . . . . . . 540\n12.7.2 写时复制（copy-on-write） . . . . . . . . . . . . . . . . . . . . . 542\n12.7.3 短字符串优化（SSO） . . . . . . . . . . . . . . . . . . . . . . . . 543\n12.8 用STL algorithm 轻松解决几道算法面试题. . . . . . . . . . . . . . . . 546\n12.8.1 用next_permutation() 生成排列与组合. . . . . . . . . . . . . . 546\n12.8.2 用unique() 去除连续重复空白. . . . . . . . . . . . . . . . . . . 548\n12.8.3 用{make,push,pop}_heap() 实现多路归并. . . . . . . . . . . . 549\n12.8.4 用partition() 实现“重排数组，让奇数位于偶数前面” . . . . 553\n12.8.5 用lower_bound() 查找IP 地址所属的城市. . . . . . . . . . . . . 554\n第4 部分附录559\n附录A 谈一谈网络编程学习经验561\n附录B 从《C++ Primer（第4 版）》入手学习C++ 579\n附录C 关于Boost 的看法591\n附录D 关于TCP 并发连接的几个思考题与试验593\n参考文献599","pages":"610","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s24522799.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s24522799.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s24522799.jpg"},"alt":"https:\/\/book.douban.com\/subject\/20471211\/","id":"20471211","publisher":"电子工业出版社","isbn10":"7121192829","isbn13":"9787121192821","title":"Linux多线程服务端编程","url":"https:\/\/api.douban.com\/v2\/book\/20471211","alt_title":"","author_intro":"陈硕，北京师范大学硕士，擅长C++ 多线程网络编程和实时分布式系统架构。曾在摩根士丹利IT 部门工作5 年，从事实时外汇交易系统开发。现在在美国加州硅谷某互联网大公司工作，从事大规模分布式系统的可靠性工程。编写了开源C++ 网络库muduo，参与翻译了《代码大全（ 第2 版）》和《C++ 编程规范（繁体版）》，整理了《C++ Primer （第4 版）（评注版）》，并曾多次在各地技术大会演讲。","summary":"本书主要讲述采用现代C++ 在x86-64 Linux 上编写多线程TCP 网络服务程序的主流常规技术，重点讲解一种适应性较强的多线程服务器的编程模型，即one loop per thread。这是在Linux 下以native 语言编写用户态高性能网络程序最成熟的模式，掌握之后可顺利地开发各类常见的服务端网络应用程序。本书以muduo 网络库为例，讲解这种编程模型的使用方法及注意事项。\n本书的宗旨是贵精不贵多。掌握两种基本的同步原语就可以满足各种多线程同步的功能需求，还能写出更易用的同步设施。掌握一种进程间通信方式和一种多线程网络编程模型就足以应对日常开发任务，编写运行于公司内网环境的分布式服务统。","price":"89.00元"}]}
4	{"count":20,"start":0,"total":1198604,"books":[{"rating":{"max":10,"numRaters":1850,"average":"8.9","min":0},"subtitle":"C语言描述","author":["维斯"],"pubdate":"2004-1-1","tags":[{"count":2183,"name":"数据结构","title":"数据结构"},{"count":1727,"name":"算法","title":"算法"},{"count":976,"name":"计算机","title":"计算机"},{"count":900,"name":"数据结构与算法分析","title":"数据结构与算法分析"},{"count":731,"name":"编程","title":"编程"},{"count":706,"name":"算法、数据结构","title":"算法、数据结构"},{"count":647,"name":"C","title":"C"},{"count":552,"name":"C语言","title":"C语言"}],"origin_title":"Data Structures and Algorithm Analysis in C:Second Edition","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s28015501.jpg","binding":"平装","translator":["冯舜玺"],"catalog":"第1章 引论\n1．1 本书讨论的内容\n1．2 数学知识复习\n1．2．1 指数\n1．2．2 对数\n1．2．3 级数\n1．2．4 模运算\n1. 2．5 证明方法\n1．3 递归简论\n总结\n练习\n参考文献\n第2章 算法分析\n2．1 数学基础\n2．2 模型\n2．3 要分析的问题\n2．4 运行时间计算\n2．4．1 一个简单的例子\n2．4．2 一般法则\n2．4．3 最大子序列和问题的解\n.2．4．4 运行时间中的对数\n2．4．5 检验你的分析\n2．4．6 分析结果的准确性\n总结\n练习\n参考文献\n第3章 表、栈和队列\n3．1 抽象数据类型(adt)\n3．2 表adt\n3．2．1 表的简单数组实现\n3．2．2 链表\n3．2．3 程序设计细节\n3．2．4 常见的错误\n3．2．5 双链表\n3．2．6 循环链表\n3．2．7 例子\n3．2．8 链表的游标实现\n3．3 栈adt\n3．3．1 栈模型\n3．3．2 栈的实现\n3．3．3 应用\n3．4 队列adt\n3．4．1 队列模型\n3．4．2 队列的数组实现\n3．4．3 队列的应用\n总结\n练习\n第4章 树\n4．1 预备知识\n4．1．1 树的实现\n4．1．2 树的遍历及应用\n4．2 二叉树\n4．2．1 实现\n4．2．2 表达式树\n4．3 查找树adt--二叉查找树\n4．3．1 makeempty\n4．3．2 find\n4．3．3 findmin和findmax\n4．3．4 insert\n4．3．5 delere\n4．3．6 平均情形分析\n4．4 avl树\n4．4．1 单旋转\n4．4．2 双旋转\n4．5 伸展树\n4．5．1 一个简单的想法\n4．5．2 展开\n4．6 树的遍历\n4．7 b-树\n总结\n练习\n参考文献\n第5章 散列\n5．1 一般想法\n5．2 散列函数\n5．3 分离链接法\n5．4 开放定址法\n5．4．1 线性探测法\n5．4．2 平方探测法\n5．4．3 双散列\n5．5 再散列\n5．6 可扩散列\n总结\n练习\n参考文献\n第6章 优先队列(堆)\n6．1 模型\n6．2 一些简单的实现\n6．3 二叉堆\n6．3．1 结构性质\n6．3．2 堆序性质\n6．3．3 基本的堆操作\n6．3．4 其他的堆操作\n6．4 优先队列的应用\n6．4．1 选择问题\n6．4．2 事件模拟\n6．5 d-堆\n6．6 左式堆\n6．6．1 左式堆的性质\n6．6．2 左式堆的操作\n6．7 斜堆\n6．8 二项队列\n6．8．1 二项队列结构\n6．8．2 二项队列操作\n6．8．3 二项队列的实现\n总结\n练习\n参考文献\n第7章 排序\n7．1 预备知识\n7．2 插入排序\n7．2．1 算法\n7．2．2 插入排序的分析\n7．3 一些简单排序算法的下界\n7. 4 希尔排序\n7．4．1 希尔排序的最坏情形分析\n7．5 堆排序\n7．5．1 堆排序的分析\n7．6 归并排序\n7．6．1 归并排序的分析\n7．7 快速排序\n7．7．1 选取枢纽元\n7．7．2 分割策略\n7．7．3 小数组\n7．7．4 实际的快速排序例程\n7．7．5 快速排序的分析\n7．7．6 选择的线性期望时间算法\n7．8 大型结构的排序\n7．9 排序的一般下界\n7．9．1 决策树\n7．10 桶式排序\n7．11 外部排序\n7．11．1 为什么需要新的算法\n7．11．2 外部排序模型\n7．11．3 简单算法\n7．11．4 多路合并\n7．11．5 多相合并\n7．11．6 替换选择\n总结\n练习\n参考文献\n第8章 不相交集adt\n8．1 等价关系\n8．2 动态等价性问题\n8．3 基本数据结构\n8．4 灵巧求并算法\n8．5 路径压缩\n8．6 按秩求并和路径压缩的最坏情形\n8．6．1 union／find算法分析\n8．7 一个应用\n总结\n练习\n参考文献\n第9章 图论算法\n9．1 若干定义\n9．1．1 图的表示\n9．2 拓扑排序\n9．3 最短路径算法\n9．3．1 无权最短路径\n9．3．2 dijkstra算法\n9．3．3 具有负边值的图\n9．3．4 无圈图\n9．3．5 所有点对最短路径\n9．4 网络流问题\n9．4．1 一个简单的最大流算法\n9．5 最小生成树\n9．5．1 prim算法\n9．5．2 kruskal算法\n9．6 深度优先搜索的应用\n9．6．1 无向图\n9．6．2 双连通性\n9．6．3 欧拉回路\n9．6．4 有向图\n9．6．5 查找强分支\n9．7 np-完全性介绍\n9．7．1 难与易\n9．7．2 np类\n9．7．3 np-完全问题\n总结\n练习\n参考文献\n第10章 算法设计技巧\n10．1 贪婪算法\n10．1．1 一个简单的调度问题\n10．1．2 huffman编码\n10．1．3 近似装箱问题\n10．2 分治算法\n10．2．1 分治算法的运行时间\n10．2．2 最近点问题\n10．2．3 选择问题\n10．2．4 一些运算问题的理论改进\n10．3 动态规划\n10．3．1 用一个表代替递归\n10．3．2 矩阵乘法的顺序安排\n10．3．3 最优二叉查找树\n10．3．4 所有点对最短路径\n10．4 随机化算法\n10．4．1 随机数发生器\n10．4．2 跳跃表\n10．4．3 素性测试\n10．5 回溯算法\n10．5．1 收费公路重建问题\n10．5．2 博弈\n总结\n练习\n参考文献\n第11章 摊还分析\n11．1 一个无关的智力问题\n11．2 二项队列\n11．3 斜堆\n11．4 斐波那契堆\n11．4．1 切除左式堆中的节点\n11．4．2 二项队列的懒惰合并\n11．4．3 斐波那契堆操作\n11．4．4 时间界的证明\n11. 5 伸展树\n总结\n练习\n参考文献\n第12章 高级数据结构及其实现\n12．1 自顶向下伸展树\n12．2 红黑树\n12．2．1 自底向上插入\n12．2．2 自顶向下红黑树\n12．2．3 自顶向下删除\n12．3 确定性跳跃表\n12．4 aa-树\n12．5 treap树\n12．6 k-d树\n12．7 配对堆\n总结\n练习\n参考文献\n索引","pages":"391","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s28015501.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s28015501.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s28015501.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1139426\/","id":"1139426","publisher":"机械工业出版社","isbn10":"711112748X","isbn13":"9787111127482","title":"数据结构与算法分析","url":"https:\/\/api.douban.com\/v2\/book\/1139426","alt_title":"Data Structures and Algorithm Analysis in C:Second Edition","author_intro":"Mark Allen Weiss，1987年在普林斯顿大学获得计算机科学博士学位，师从Robert Sedgewick (师从Knuth)，现任美国佛罗里达国际大学计算与信息科学学院教授。他曾经担任全美AP(Advanced Placement)考试计算机学科委员会的主席(2000-2004)。他的主要研究方向是数据结构、算法和教育学。","summary":"本书是《Data Structures and Algorithm Analysis in C》一书第2版的简体中译本。原书曾被评为20世纪顶尖的30部计算机著作之一，作者Mark Allen Weiss在数据结构和算法分析方面卓有建树，他的数据结构和算法分析的著作尤其畅销，并受到广泛好评．已被世界500余所大学用作教材。\n在本书中，作者更加精炼并强化了他对算法和数据结构方面创新的处理方法。通过C程序的实现，着重阐述了抽象数据类型的概念，并对算法的效率、性能和运行时间进行了分析。\n全书特点如下：\n●专用一章来讨论算法设计技巧，包括贪婪算法、分治算法、动态规划、随机化算法以及回溯算法\n●介绍了当前流行的论题和新的数据结构，如斐波那契堆、斜堆、二项队列、跳跃表和伸展树\n●安排一章专门讨论摊还分析，考查书中介绍的一些高级数据结构\n●新开辟一章讨论高级数据结构以及它们的实现，其中包括红黑树、自顶向下伸展树。treap树、k-d树、配对堆以及其他相关内容\n●合并了堆排序平均情况分析的一些新结果\n本书是国外数据结构与算法分析方面的标准教材，介绍了数据结构(大量数据的组织方法)以及算法分析(算法运行时间的估算)。本书的编写目标是同时讲授好的程序设计和算法分析技巧，使读者可以开发出具有最高效率的程序。 本书可作为高级数据结构课程或研究生一年级算法分析课程的教材，使用本书需具有一些中级程序设计知识，还需要离散数学的一些背景知识。","series":{"id":"1163","title":"计算机科学丛书"},"price":"35.00元"},{"rating":{"max":10,"numRaters":1332,"average":"8.9","min":0},"subtitle":"C语言调试指南","author":["凯尼格"],"pubdate":"2008-2-1","tags":[{"count":708,"name":"C语言","title":"C语言"},{"count":437,"name":"编程","title":"编程"},{"count":318,"name":"C","title":"C"},{"count":278,"name":"计算机","title":"计算机"},{"count":248,"name":"c","title":"c"},{"count":210,"name":"C\/C++","title":"C\/C++"},{"count":194,"name":"经典","title":"经典"},{"count":179,"name":"程序设计","title":"程序设计"}],"origin_title":"C Traps and Pitfalls","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s2870233.jpg","binding":"平装","translator":["高巍"],"catalog":"第0章　导读\n第1章　词法“陷阱”\n1.1　=不同于==\n1.2　& 和 | 不同于&& 和 ||\n1.3　词法分析中的“贪心法”\n1.4　整型常量\n1.5　字符与字符串\n第2章　语法“陷阱”\n2.1　理解函数声明\n2.2　运算符的优先级问题\n2.3　注意作为语句结束标志的分号\n2.4　switch语句\n2.5　函数调用\n2.6　“悬挂”else引发的问题\n第3章　语义“陷阱”\n3.1　指针与数组\n3.2　非数组的指针\n3.3　作为参数的数组声明\n3.4　避免“举隅法”\n3.5　空指针并非空字符串\n3.6　边界计算与不对称边界\n3.7　求值顺序\n3.8　运算符&&、|| 和 !\n3.9　整数溢出\n3.10　为函数main提供返回值\n第4章　连接\n4.1　什么是连接器\n4.2　声明与定义\n4.3　命名冲突与static修饰符\n4.4　形参、实参与返回值\n4.5　检查外部类型\n4.6　头文件\n第5章　库函数\n5.1　返回整数的getchar函数\n5.2　更新顺序文件\n5.3　缓冲输出与内存分配\n5.4　使用errno检测错误\n5.5　库函数signal\n第6章　预处理器\n6.1　不能忽视宏定义中的空格\n6.2　宏并不是函数\n6.3　宏并不是语句\n6.4　宏并不是类型定义\n第7章　可移植性缺陷\n7.1　应对C语言标准变更\n7.2　标识符名称的限制\n7.3　整数的大小\n7.4　字符是有符号整数还是无符号整数\n7.5　移位运算符\n7.6　内存位置0\n7.7　除法运算时发生的截断\n7.8　随机数的大小\n7.9　大小写转换\n7.10　首先释放，然后重新分配\n7.11　可移植性问题的一个例子\n第8章　建议与答案\n8.1　建议\n8.2　答案\n附录A　PRINTF，VARARGS与STDARG\n附录B　Koenig和Moo夫妇访谈","pages":"172","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s2870233.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s2870233.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s2870233.jpg"},"alt":"https:\/\/book.douban.com\/subject\/2778632\/","id":"2778632","publisher":"人民邮电出版社","isbn10":"7115171793","isbn13":"9787115171795","title":"C陷阱与缺陷","url":"https:\/\/api.douban.com\/v2\/book\/2778632","alt_title":"C Traps and Pitfalls","author_intro":"Andrew Koenig 是AT&T公司Shannon实验室大规模编程研究部门中的成员，同时也是C++标准委员会的项目编辑。他的编程经验超过30年，其中有15年在使用C++，他已经出版了超过150 篇和C++有关的论文，并且在世界范围内就这个主题进行过多次演讲。","summary":"作者以自己1985年在Bell实验室时发表的一篇论文为基础，结合自己的工作经验扩展成为这本对C程序员具有珍贵价值的经典著作。写作本书的出发点不是要批判C语言，而是要帮助C程序员绕过编程过程中的陷阱和障碍。..\n全书分为8章，分别从词法分析、语法语义、连接、库函数、预处理器、可移植性缺陷等几个方面分析了C编程中可能遇到的问题。最后，作者用一章的篇幅给出了若干具有实用价值的建议。..\n本书适合有一定经验的C程序员阅读学习，即便你是C编程高手，本书也应该成为你的案头必备书籍。","series":{"id":"9931","title":"C和C++经典著作"},"price":"30.00元"},{"rating":{"max":10,"numRaters":4408,"average":"9.4","min":0},"subtitle":"第 2 版·新版","author":["（美）Brian W. Kernighan","（美）Dennis M. Ritchie"],"pubdate":"2004-1","tags":[{"count":3001,"name":"C","title":"C"},{"count":2408,"name":"c语言","title":"c语言"},{"count":2131,"name":"编程","title":"编程"},{"count":1549,"name":"计算机","title":"计算机"},{"count":1291,"name":"程序设计","title":"程序设计"},{"count":1080,"name":"经典","title":"经典"},{"count":987,"name":"编程语言","title":"编程语言"},{"count":869,"name":"C\/C++","title":"C\/C++"}],"origin_title":"The C Programming Language","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1106934.jpg","binding":"平装","translator":["徐宝文","李志译","尤晋元审校"],"catalog":"出版者的话\n专家指导委员会\n中文版序\n译者序\n校译者简介\n序\n第1版序\n引言\n第1章 导言\n1.1 入门\n1.2 变量与算术表态式\n1.3 for语句\n1.4 符号常量\n1.5 字符输入\/输出\n1.6 数组\n1.7 函数\n1.8 参数——传值调用\n1.9 字符数组\n1.10 外部变量与作用域\n第2章 类型、运算符与表达式\n2.1 变量名\n2.2 数据类型及长度\n2.3 常量\n2.4 声明\n2.5 算术运算符\n2.6 关系运算符与逻辑运算符\n2.7 类型转换\n2.8 自增运算符与自减运算符\n2.9 按位运算符\n2.10 赋值运算符与表达式\n2.11 条件表达式\n2.12 运算符优先级与求值次序\n第3章 控制流\n3.1 语句与程序块\n3.2 if-else语句\n3.3 else-if语句\n3.4 switch语句\n3.5 whil循环与for特环\n3.6 do-while循环\n3.7 break语句与continue语句\n3.8 goto语句与标号\n第4章 涵数与程序结构\n第5章 指针与数组\n第6章 结构\n第7章 输入与输出\n第8章 UNIX系统接口\n附录A 参考手册\n附录B 标准库\n附录C 变更小结\n索引","pages":"258","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s1106934.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s1106934.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1106934.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1139336\/","id":"1139336","publisher":"机械工业出版社","isbn10":"7111128060","isbn13":"9787111128069","title":"C程序设计语言","url":"https:\/\/api.douban.com\/v2\/book\/1139336","alt_title":"The C Programming Language","author_intro":"Brian W. Kernighan： 贝尔实验室计算科学研究中心高级研究人员，著名的计算机科学家。他参加了UNIX系统、C语言、AWK语言和许多其他系统的开发，同时出版了许多在计算机领域具有影响的著作，如《The Elements of Programming Style》、《The Practice of Programming》、《The UNIX Programming Environment》、《The AWK Language》、《Software Tools》等。\nDennis M. Ritchie：1967年加入贝尔实验室。他和Ken L. Thompson两人共同设计并实现的C语言改变了程序设计语言发展的轨迹，是程序设计语言发展过程中的一个重要里程碑。与此同时，他们两人还设计并实现了UNIX操作系统。正是由于这两项巨大贡献，Dennis M. Ritchie于1983年获得了计算机界的最高奖——图灵奖。此外，他还获得了ACM、IEEE、贝尔实验室等授予的多种奖项.。","summary":"在计算机发展的历史上，没有哪一种程序设计语言像C语言这样应用广泛。本书原著即为C语言的设计者之一Dennis M.Ritchie和著名计算机科学家Brian W.Kernighan合著的一本介绍C语言的权威经典著作。我们现在见到的大量论述C语言程序设计的教材和专著均以此书为蓝本。原著第1版中介绍的C语言成为后来广泛使用的C语言版本——标准C的基础。人们熟知的“hello,World\"程序就是由本书首次引入的，现在，这一程序已经成为众多程序设计语言入门的第一课。\n原著第2版根据1987年制定的ANSIC标准做了适当的修订．引入了最新的语言形式，并增加了新的示例，通过简洁的描述、典型的示例，作者全面、系统、准确地讲述了C语言的各个特性以及程序设计的基本方法。对于计算机从业人员来说，《C程序设计语言》是一本必读的程序设计语 言方面的参考书。","series":{"id":"1163","title":"计算机科学丛书"},"price":"30.00元"},{"rating":{"max":10,"numRaters":132,"average":"8.5","min":0},"subtitle":"C语言描述","author":["(美)安佩尔"],"pubdate":"2006-4","tags":[{"count":306,"name":"编译原理","title":"编译原理"},{"count":115,"name":"虎书","title":"虎书"},{"count":95,"name":"C","title":"C"},{"count":83,"name":"计算机","title":"计算机"},{"count":81,"name":"计算机科学","title":"计算机科学"},{"count":60,"name":"compiler","title":"compiler"},{"count":59,"name":"编译理论","title":"编译理论"},{"count":59,"name":"编译器","title":"编译器"}],"origin_title":"Modern Compiler Implementation in C","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1852496.jpg","binding":"简裝本","translator":["赵克佳","黄春","沈志宇"],"catalog":"第一部分 编译基本原理\n第1章 绪论\n1.1 模块与接口\n1.2 工具和软件\n1.3 树语言的数据结构\n程序设计：直线式程序解释器\n推荐阅读\n习题\n第2章 词法分析\n2.1 词法单词\n2.2 正则表达式\n2.3 有限自动机\n2.4 非确定有限自动机\n2.4.1 将正则表达式转换为NFA\n2.4.2 将NFA转换为DFA\n2.5 Lex：词法分析器的生成器\n程序设计：词法分析\n推荐阅读\n习题\n第3章 语法分析\n3.1 上下文无关文法\n3.1.1 推导\n3.1.2 语法分析树\n3.1.3 二义性文法\n3.1.4 文件结束符\n3.2 预测分析\n3.2.1 FIRST集合和FOLLOW集合\n3.2.2 构造一个预测分析器\n3.2.3 消除左递归\n3.2.4 提取左因子\n3.2.5 错误恢复\n3.3 LR分析\n3.3.1 LR分析引擎\n3.3.2 LR(0)分析器生成器\n3.3.3 SLR分析器的生成\n3.3.4 LR(1)项和LR(1)分析表\n3.3.5 LALR(1)分析表\n3.3.6 各类文法的层次\n3.3.7 二义性文法的LR分析\n3.4 使用分析器的生成器\n3.4.1 冲突\n3.4.2 优先级指导\n3.4.3 语法和语义\n3.5 错误恢复\n3.5.1 用error符号恢复\n3.5.2 全局错误修复\n程序设计：语法分析\n推荐阅读\n习题\n第4章 抽象语法\n4.1 语义动作\n4.1.1 递归下降\n4.1.2 Yacc生成的分析器\n4.1.3 语义动作的解释器\n4.2 抽象语法分析树\n4.2.1 位置\n4.2.2 Tiger的抽象语法\n程序设计：抽象语法\n推荐阅读\n习题\n第5章 语义分析\n5.1 符号表\n5.1.1 多个符号表\n5.1.2 高效的命令式风格符号表\n5.1.3 高效的函数式符号表\n5.1.4 Tiger编译器的符号\n5.1.5 函数式风格的符号表\n5.2 Tiger编译器的绑定\n5.3 表达式的类型检查\n5.4 声明的类型检查\n5.4.1 变量声明\n5.4.2 类型声明\n5.4.3 函数声明\n5.4.4 递归声明\n程序设计：类型检查\n习题\n第6章 活动记录\n6.1 栈帧\n6.1.1 帧指针\n6.1.2 寄存器\n6.1.3 参数传递\n6.1.4 返回地址\n6.1.5 栈帧内的变量\n6.1.6 静态链\n6.2 Tiger编译器的栈帧\n6.2.1 栈帧描述的表示\n6.2.2 局部变量\n6.2.3 计算逃逸变量\n6.2.4 临时变量和标号\n6.2.5 两层抽象\n6.2.6 管理静态链\n6.2.7 追踪层次信息\n程序设计：栈帧\n推荐阅读\n习题\n第7章 翻译成中间代码\n7.1 中间表示树\n7.2 翻译为树中间语言\n7.2.1 表达式的种类\n7.2.2 简单变量\n7.2.3 追随静态链\n7.2.4 数组变量\n7.2.5 结构化的左值\n7.2.6 下标和域选择\n7.2.7 关于安全性的劝告\n7.2.8 算术操作\n7.2.9 条件表达式\n7.2.10 字符串\n7.2.11 记录和数组的创建\n7.2.12 while循环\n7.2.13 for循环\n7.2.14 函数调用\n7.3 声明\n7.3.1 变量定义\n7.3.2 函数定义\n7.3.3 片段\n程序设计：翻译成树\n习题\n第8章 基本块和轨迹\n8.1 规范树\n8.1.1 ESEQ的转换\n8.1.2 一般重写规则\n8.1.3 将CALL移到顶层\n8.1.4 线性语句表\n8.2 处理条件分支\n8.2.1 基本块\n8.2.2 轨迹\n8.2.3 完善\n8.2.4 最优轨迹\n推荐阅读\n习题\n第9章 指令选择\n9.1 指令选择算法\n9.1.1 Maximal Munch算法\n9.1.2 动态规划\n9.1.3 树文法\n9.1.4 快速匹配\n9.1.5 覆盖算法的效率\n9.2 CISC机器\n9.3 Tiger编译器的指令选择\n9.3.1 抽象的汇编语言指令\n9.3.2 生成汇编指令\n9.3.3 过程调用\n9.3.4 无帧指针的情形\n程序设计：指令选择\n推荐阅读\n习题\n第10章 活跃分析\n10.1 数据流方程的解\n10.1.1 活跃性计算\n10.1.2 集合的表示\n10.1.3 时间复杂度\n10.1.4 最小不动点\n10.1.5 静态活跃性与动态活跃性\n10.1.6 冲突图\n10.2 Tiger编译器的活跃分析\n10.2.1 图\n10.2.2 控制流图\n10.2.3 活跃分析\n程序设计：构造流图\n程序设计：活跃分析模块\n习题\n第11章 寄存器分配\n11.1 通过简化进行着色\n11.2 合并\n11.3 预着色的结点\n11.3.1 机器寄存器的临时副本\n11.3.2 调用者保护的寄存器和被调用者保护的寄存器\n11.3.3 含预着色结点的例子\n11.4 图着色的实现\n11.4.1 传送指令工作表的管理\n11.4.2 数据结构\n11.4.3 程序代码\n11.5 针对树的寄存器分配\n程序设计：图着色\n推荐阅读\n习题\n第12章 整合为一体\n程序设计：过程入口\/出口\n程序设计：创建一个可运行的编译器\n第二部分 高级主题\n第13章 垃圾收集\n13.1 标记-清扫式收集\n13.2 引用计数\n13.3 复制式收集\n13.4 分代收集\n13.5 增量式收集\n13.6 Baker算法\n13.7 编译器接口\n13.7.1 快速分配\n13.7.2 数据布局的描述\n13.7.3 导出指针\n程序设计：描述字\n程序设计：垃圾收集\n推荐阅读\n习题\n第14章 面向对象的语言\n14.1 类\n14.2 数据域的单继承性\n14.3 多继承性\n14.4 测试类成员关系\n14.5 私有域和私有方法\n14.6 无类语言\n14.7 向对象程序的优化\n程序设计：OBJECT Tiger\n推荐阅读\n习题\n第15章 函数式程序设计语言\n15.1 一个简单的函数式语言\n15.2 闭包\n15.3 不变的变量\n15.3.1 基于延续的……I\/O226\n15.3.2 语言上的变化\n15.3.3 纯函数式语言的优化\n15.4 内联扩展\n15.5 闭包变换\n15.6 高效的尾递归\n15.7 懒惰计算\n15.7.1 传名调用计算\n15.7.2 按需调用\n15.7.3 懒惰程序的计算\n15.7.4 懒惰函数式程序的优化\n15.7.5 严格性分析\n推荐阅读\n程序设计：编译函数式语言\n习题\n第16章 多态类型\n16.1 参数多态性\n16.1.1 显式带类型的多态语言\n16.1.2 多态类型的检查\n16.2 类型推论\n16.2.1 一个隐式类型的多态语言\n16.2.2 类型推论算法\n16.2.3 递归的数据类型\n16.2.4 Hindley Milner类型的能力\n16.3 多态变量的表示\n16.3.1 多态函数的扩展\n16.3.2 完全的装箱转换\n16.3.3 基于强制的表示分析\n16.3.4 将类型作为运行时参数传递\n16.4 静态重载的解决方法\n推荐阅读\n习题\n第17章 数据流分析\n17.1 流分析使用的中间表示\n17.2 各种数据流分析\n17.2.1 到达定值\n17.2.2 可用表达式\n17.2.3 到达表达式\n17.2.4 活跃分析\n17.3 使用数据流分析结果的几种转换\n17.3.1 公共子表达式删除\n17.3.2 常数传播\n17.3.3 复写传播\n17.3.4 死代码删除\n17.4 加快数据流分析\n17.4.1 位向量\n17.4.2 基本块\n17.4.3 结点排序\n17.4.4 使用-定值链和定值-使用链\n17.4.5 工作表算法\n17.4.6 增量式数据流分析\n17.5 别名分析\n17.5.1 基于类型的别名分析\n17.5.2 基于流的别名分析\n17.5.3 使用可能别名信息\n17.5.4 严格的纯函数式语言中的别名分析\n推荐阅读\n习题\n第18章 循环优化\n18.1 必经结点\n18.1.1 寻找必经结点的算法\n18.1.2 直接必经结点\n18.1.3 循环\n18.1.4 循环前置结点\n18.2 循环不变量计算\n18.3 归纳变量\n18.3.1 发现归纳变量\n18.3.2 强度削弱\n18.3.3 删除\n18.3.4 重写比较\n18.4 数组边界检查\n18.5 循环展开\n推荐阅读\n习题\n第19章 静态单赋值形式\n19.1 转化为SSA形式\n19.1.1 插入Φ函数的标准\n19.1.2 必经结点边界\n19.1.3 插入Φ函数\n19.1.4 变量重命名\n19.1.5 边分割\n19.2 必经结点树的高效计算\n19.2.1 深度优先生成树\n19.2.2 半必经结点\n19.2.3 Lengauer Tarjan算法\n19.3 使用SSA的优化算法\n19.3.1 死代码删除\n19.3.2 简单的常数传播\n19.3.3 条件常数传播\n19.3.4 保持必经结点性质\n19.4 数组、指针和存储器\n19.5 控制依赖图\n19.6 从SSA形式转变回来\n19.7 函数式中间形式\n推荐阅读\n习题\n第20章 流水和调度\n20.1 没有资源约束时的循环调度\n20.2 有资源约束的循环流水\n20.2.1 模调度\n20.2.2 寻找最小的启动间距\n20.2.3 其他控制流\n20.2.4 编译器应该调度指令吗\n20.3 分支预测\n20.3.1 静态分支预测\n20.3.2 编译器应该预测分支吗\n推荐阅读\n习题\n第21章 存储层次\n21.1 cache的组织结构\n21.2 cache块对齐\n21.3 预取\n21.4 循环交换\n21.5 分块\n21.6 垃圾收集和存储层次\n推荐阅读\n习题\n附录 Tiger语言参考手册\n参考文献\n索引","pages":"385","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s1852496.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s1852496.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1852496.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1806974\/","id":"1806974","publisher":"人民邮电出版社","isbn10":"7115145520","isbn13":"9787115145529","title":"现代编译原理","url":"https:\/\/api.douban.com\/v2\/book\/1806974","alt_title":"Modern Compiler Implementation in C","author_intro":"","summary":"《现代编译原理:C语言描述》全面讲述了现代编译器的结构、编译算法和实现方法，是Andrew w．Apple的“虎书”——Modern Compiler Implementation——“红、蓝、绿”三序列之一。这三本书的内容基本相同。但是使用不同的语言来实现书中给出的一个编译器。本书使用的是更适合广大读者的c语言，而另外两本书分别采用ML语言和Java语言。本书的另一个特点是增加了一些其他编译原理教科书没有涉及的内容。前端增加了面向对象的程序设计语言、函数式程序设计语言等现代语言的编译实现方法，后端增加了针对现代计算机体系结构特征的一些比较成熟的优化方法。这部分内容展现了现代商业编译器需解决的一些关键问题，开拓了学生的视野，为学生未来进行更深入的研究奠定了基础。\n\n《现代编译原理:C语言描述》全面讲述了现代编译器的各个组成部分，包括词法分析、语法分析、抽象语法、语义检查、中间代码表示、指令选择、数据流分析、寄存器分配以及运行时系统等。全书分成两部分，第一部分是编译的基础知识，适用于第一门编译原理课程(一个学期)；第二部分是高级主题，包括面向对象语言和函数语言、垃圾收集、循环优化、ssA(静态单赋值)形式、循环调度、存储结构优化等，适合于后续课程或研究生教学。书中专门为学生提供了一个用C语言编写的实习项目，包括前端和后端设计，学生可以在一学期内创建一个功能完整的编译器。","series":{"id":"18507","title":"图灵计算机科学丛书"},"price":"45.00元"},{"rating":{"max":10,"numRaters":137,"average":"9.1","min":0},"subtitle":"编写高质量C语言代码","author":["Steve Maguire"],"pubdate":"2009.2","tags":[{"count":297,"name":"编程","title":"编程"},{"count":250,"name":"C","title":"C"},{"count":153,"name":"C语言","title":"C语言"},{"count":102,"name":"程序设计","title":"程序设计"},{"count":100,"name":"计算机","title":"计算机"},{"count":81,"name":"Programming","title":"Programming"},{"count":71,"name":"C\/C++","title":"C\/C++"},{"count":67,"name":"经典","title":"经典"}],"origin_title":"Writing Solid Code","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s3529626.jpg","binding":"","translator":[],"catalog":"1 a hypothetical compiler\n2 assert yourself\n3 fortify your subsystems\n4 step through your code\n5 candy-machine interfaces\n6 risky business\n7 treacheries of the trade\n8 the rest is attitude\nepilogue where do you go from here?\nappendix a coding checklists\nappendix b memory logging routines\nappendix c answers\nreferences\nindex","pages":"256","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s3529626.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s3529626.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s3529626.jpg"},"alt":"https:\/\/book.douban.com\/subject\/3406939\/","id":"3406939","publisher":"人民邮电出版社","isbn10":"7115193169","isbn13":"9787115193162","title":"编程精粹","url":"https:\/\/api.douban.com\/v2\/book\/3406939","alt_title":"Writing Solid Code","author_intro":"","summary":"编写高质量的、没有bug的程序，是每位程序员所追求的目标。但随着软件规模越来越大，功能日趋复杂，这一目标变得越来越困难。\n本书揭示了微软公司应对质量挑战、开发出世界级代码的技术内幕，作者在自己不断探索、实践和思考的基础上，系统总结了多年来指导微软各团队的经验，将其凝聚为许多切实可行的编程实践指导，可谓字字珠玑。正因如此，本书被公认为与《代码大全》齐名的编程技术名著，曾于1993年荣获有软件开发奥斯卡奖之称的Jolt生产效率大奖。书中内容主要针对C语言，但其中的思想对目前的各主流语言编程也完全适用。","series":{"id":"50484","title":"图灵程序设计丛书·C\/C++系列"},"price":"45.00元"},{"rating":{"max":10,"numRaters":462,"average":"8.1","min":0},"subtitle":"—C++\/C语言","author":["林锐","韩永泉"],"pubdate":"2007-5","tags":[{"count":218,"name":"C++","title":"C++"},{"count":154,"name":"编程","title":"编程"},{"count":126,"name":"C\/C++","title":"C\/C++"},{"count":104,"name":"程序设计","title":"程序设计"},{"count":78,"name":"高质量程序设计指南--C++\/c语言","title":"高质量程序设计指南--C++\/c语言"},{"count":70,"name":"计算机","title":"计算机"},{"count":70,"name":"编程风格","title":"编程风格"},{"count":61,"name":"C","title":"C"}],"origin_title":"","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s2660317.jpg","binding":"","translator":[],"catalog":"第1章  高质量软件开发之道\t11.1  软件质量基本概念\t11.1.1  如何理解软件的质量\t11.1.2  提高软件质量的基本方法\t31.1.3  “零缺陷”理念\t41.2  细说软件质量属性\t41.2.1  正确性\t41.2.2  健壮性\t51.2.3  可靠性\t51.2.4  性能\t61.2.5  易用性\t71.2.6  清晰性\t71.2.7  安全性\t71.2.8  可扩展性\t81.2.9  兼容性\t81.2.10  可移植性\t81.3  人们关注的不仅仅是质量\t91.3.1  质量、生产率和成本之间的关系\t91.3.2  软件过程改进的基本概念\t111.4  高质量软件开发的基本方法\t131.4.1  建立软件过程规范\t131.4.2  复用\t151.4.3  分而治之\t161.4.4  优化与折中\t171.4.5  技术评审\t181.4.6  测试\t191.4.7  质量保证\t211.4.8  改错\t221.5  关于软件开发的一些常识和思考\t241.5.1  有最好的编程语言吗\t241.5.2  编程是一门艺术吗\t241.5.3  编程时应该多使用技巧吗\t241.5.4  换更快的计算机还是换更快的算法\t251.5.5  错误是否应该分等级\t251.5.6  一些错误的观念\t251.6  小结\t26第2章  编程语言发展简史\t272.1  编程语言大事记\t272.2  Ada的故事\t302.3  C\/C++发展简史\t312.4  Borland与Microsoft之争\t322.5  Java阵营与Microsoft的较量\t332.6  小结\t36第3章  程序的基本概念\t373.1  程序设计语言\t373.2  语言实现\t383.3  程序库\t403.4  开发环境\t403.5  程序的工作原理\t413.6  良好的编程习惯\t42第4章  C++\/C程序设计入门\t454.1  C++\/C程序的基本概念\t454.1.1  启动函数main()\t454.1.2  命令行参数\t474.1.3  内部名称\t484.1.4  连接规范\t494.1.5  变量及其初始化\t514.1.6  C Runtime Library\t524.1.7  编译时和运行时的不同\t524.1.8  编译单元和独立编译技术\t544.2  基本数据类型和内存映像\t544.3  类型转换\t564.3.1  隐式转换\t564.3.2  强制转换\t584.4  标识符\t604.5  转义序列\t614.6  运算符\t624.7  表达式\t634.8  基本控制结构\t654.9  选择（判断）结构\t654.9.1  布尔变量与零值比较\t664.9.2  整型变量与零值比较\t674.9.3  浮点变量与零值比较\t674.9.4  指针变量与零值比较\t694.9.5  对if语句的补充说明\t704.9.6  switch结构\t704.10   循环（重复）结构\t714.10.1  for语句的循环控制变量\t724.10.2  循环语句的效率\t734.11  结构化程序设计原理\t784.12  goto\/continue\/break语句\t794.13  示例\t80第5章  C++\/C常量\t855.1  认识常量\t855.1.1  字面常量\t855.1.2  符号常量\t865.1.3  契约性常量\t875.1.4  枚举常量\t875.2  正确定义符号常量\t875.3  const与#define的比较\t885.4  类中的常量\t895.5  实际应用中如何定义常量\t90第6章  C++\/C函数设计基础\t956.1  认识函数\t956.2  函数原型和定义\t966.3  函数调用方式\t976.4  认识函数堆栈\t996.5  函数调用规范\t1006.6  函数连接规范\t1016.7  参数传递规则\t1026.8  返回值的规则\t1046.9  函数内部实现的规则\t1076.10  存储类型及作用域规则\t1096.10.1  存储类型\t1096.10.2  作用域规则\t1106.10.3  连接类型\t1116.11  递归函数\t1136.12  使用断言\t1166.13  使用const提高函数的健壮性\t1186.13.1  用const修饰函数的参数\t1186.13.2  用const修饰函数的返回值\t119第7章  C++\/C指针、数组和字符串\t1217.1  指针\t1217.1.1  指针的本质\t1217.1.2  指针的类型及其支持的运算\t1237.1.3  指针传递\t1257.2  数组\t1267.2.1  数组的本质\t1267.2.2  二维数组\t1287.2.3  数组传递\t1297.2.4  动态创建、初始化和删除数组的方法\t1317.3  字符数组、字符指针和字符串\t1337.3.1  字符数组、字符串和‘\\0’的关系\t1337.3.2  字符指针的误区\t1347.3.3  字符串拷贝和比较\t1347.4  函数指针\t1357.5  引用和指针的比较\t137第8章  C++\/C高级数据类型\t1418.1  结构（Struct）\t1418.1.1  关键字struct与class的困惑\t1418.1.2  使用struct\t1428.1.3  位域\t1458.1.4  成员对齐\t1478.2  联合（Union）\t1598.3  枚举（Enum）\t1618.4  文件\t163第9章  C++\/C编译预处理\t1659.1  文件包含\t1659.1.1  内部包含卫哨和外部包含卫哨\t1659.1.2  头文件包含的合理顺序\t1669.2  宏定义\t1669.3  条件编译\t1699.3.1  #if、#elif和#else\t1699.3.2  #ifdef 和 #ifndef\t1709.4  #error\t1719.5  #pragma\t1719.6  #和##运算符\t1719.7  预定义符号常量\t172第10章  C++\/C文件结构和程序版式\t17510.1  程序文件的目录结构\t17510.2  文件的结构\t17610.2.1  头文件的用途和结构\t17610.2.2  版权和版本信息\t17710.2.3  源文件结构\t17810.3  代码的版式\t17810.3.1  适当的空行\t17810.3.2  代码行及行内空格\t17910.3.3  长行拆分\t18010.3.4  对齐与缩进\t18110.3.5  修饰符的位置\t18210.3.6  注释风格\t18210.3.7  ADT\/UDT版式\t183第11章  C++\/C应用程序命名规则\t18511.1  共性规则\t18511.2  简单的Windows应用程序命名\t186第12章  C++面向对象程序设计方法概述\t18912.1  漫谈面向对象\t18912.2  对象的概念\t19012.3  信息隐藏与类的封装\t19112.4  类的继承特性\t19512.5  类的组合特性\t20012.6  动态特性\t20112.6.1  虚函数\t20212.6.2  抽象基类\t20212.6.3  动态绑定\t20512.6.4  运行时多态\t20712.6.5  多态数组\t20812.7  C++对象模型\t21512.7.1  对象的内存映像\t21512.7.2  隐含成员\t22412.7.3  C++编译器如何处理成员函数\t22512.7.4  C++编译器如何处理静态成员\t22512.8  小结\t226第13章  对象的初始化、拷贝和析构\t22913.1  构造函数与析构函数的起源\t22913.2  为什么需要构造函数和析构函数\t23013.3  构造函数的成员初始化列表\t23213.4  对象的构造和析构次序\t23413.5  构造函数和析构函数的调用时机\t23513.6  构造函数和赋值函数的重载\t23613.7  示例：类String的构造函数和析构函数\t23813.8  何时应该定义拷贝构造函数和拷贝赋值函数\t23913.9  示例：类String的拷贝构造函数和拷贝赋值函数\t24013.10  用偷懒的办法处理拷贝构造函数和拷贝赋值函数\t24213.11  如何实现派生类的基本函数\t243第14章  C++函数的高级特性\t24714.1  函数重载的概念\t24714.1.1  重载的起源\t24714.1.2  重载是如何实现的\t24714.1.3  当心隐式类型转换导致重载函数产生二义性\t24914.2  成员函数的重载、覆盖与隐藏\t25014.2.1  重载与覆盖\t25014.2.2  令人迷惑的隐藏规则\t25114.2.3  摆脱隐藏\t25314.3  参数的默认值\t25414.4  运算符重载\t25514.4.1  基本概念\t25514.4.2  运算符重载的特殊性\t25614.4.3  不能重载的运算符\t25714.4.4  重载++和--\t25714.5  函数内联\t25914.5.1  用函数内联取代宏\t25914.5.2  内联函数的编程风格\t26014.5.3  慎用内联\t26114.6  类型转换函数\t26114.7  const成员函数\t264第15章  C++异常处理和RTTI\t26715.1  为什么要使用异常处理\t26715.2  C++异常处理\t26815.2.1  异常处理的原理\t26815.2.2  异常类型和异常对象\t26915.2.3  异常处理的语法结构\t27015.2.4  异常的类型匹配规则\t27215.2.5  异常说明及其冲突\t27215.2.6  当异常抛出时局部对象如何释放\t27315.2.7  对象构造和析构期间的异常\t27315.2.8  如何使用好异常处理技术\t27515.2.9  C++的标准异常\t27815.3  虚函数面临的难题\t27815.4  RTTI及其构成\t28015.4.1  起源\t28015.4.2  typeid运算符\t28115.4.3  dynamic_cast<>运算符\t28315.4.4  RTTI的魅力与代价\t285第16章  内存管理\t28716.1  内存分配方式\t28716.2  常见的内存错误及其对策\t28816.3  指针参数是如何传递内存的\t28916.4  free和delete把指针怎么啦\t29116.5  动态内存会被自动释放吗\t29216.6  杜绝“野指针”\t29216.7  有了malloc\/free为什么还要new\/delete\t29316.8  malloc\/free的使用要点\t29516.9  new有3种使用方式\t29616.9.1  plain new\/delete\t29616.9.2  nothrow new\/delete\t29716.9.3  placement new\/delete\t29716.10  new\/delete的使用要点\t30016.11  内存耗尽怎么办\t30116.12  用对象模拟指针\t30216.13  泛型指针auto_ptr\t30516.14  带有引用计数的智能指针\t30616.15  智能指针作为容器元素\t310第17章  学习和使用STL\t32317.1  STL简介\t32317.2  STL头文件的分布\t32417.2.1  容器类\t32417.2.2  泛型算法\t32517.2.3  迭代器\t32517.2.4  数学运算库\t32517.2.5  通用工具\t32517.2.6  其他头文件\t32617.3  容器设计原理\t32617.3.1  内存映像\t32617.3.2  存储方式和访问方式\t32717.3.3  顺序容器和关联式容器的比较\t32817.3.4  如何遍历容器\t33117.3.5  存储空间重分配问题\t33217.3.6  什么样的对象才能作为STL容器的元素\t33317.4  迭代器\t33417.4.1  迭代器的本质\t33417.4.2  迭代器失效及其危险性\t33817.5  存储分配器\t34617.6  适配器\t34717.7  泛型算法\t35017.8  一些特殊的容器\t35417.8.1  string类\t35417.8.2  bitset并非set\t35517.8.3  节省存储空间的vector<bool>\t35717.8.4  空容器\t35817.9  STL容器特征总结\t36017.10  STL使用心得\t362附录A  C++\/C试题\t365附录B  C++\/C试题答案与评分标准\t369附录C  大学十年\t375附录D  《大学十年》后记\t393附录E  术语与缩写解释\t395参考文献\t397","pages":"394","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s2660317.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s2660317.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s2660317.jpg"},"alt":"https:\/\/book.douban.com\/subject\/2116929\/","id":"2116929","publisher":"电子工业","isbn10":"7121041146","isbn13":"9787121041143","title":"高质量程序设计指南","url":"https:\/\/api.douban.com\/v2\/book\/2116929","alt_title":"","author_intro":"林锐，国内知名的软件工程专家和研发管理咨询师。西安电子科技大学硕士，浙江大学计算机系博士。2000年7月加入上海贝尔有限公司，从事软件工程和CMM的研究推广工作。2003年7月当选为Alcatel集团技术专家。2004年初创建上海漫索计算机科技有限公司(http：／／www.chinaspis.com)，致力于创建适合国内IT企业需求的研发管理解决方案，包括方法论和软件产品。已出版著作七部。","summary":"《高质量程序设计指南:C++、C语言》(第3版)以轻松幽默的笔调向读者论述了高质量软件开发方法与C++\/C编程规范。它是作者多年从事软件开发工作的经验总结。《高质量程序设计指南:C++、C语言》(第3版)共17章，第1章到第4章重点介绍软件质量和基本的程序设计方法；第5章到第16章重点阐述 C++\/C编程风格、面向对象程序设计方法和一些技术专题；第17章阐述STL 的原理和使用方法。\n　　《高质量程序设计指南:C++、C语言》(第3版)第1版和第2版部分章节曾经在Internet上广泛流传，被国内IT企业的不少软件开发人员采用。《高质量程序设计指南:C++、C语言》(第3版)的附录C《大学十年》是作者在网上发表的一个短篇传记，文中所描述的充满激情的学习和生活态度，感染了大批莘莘学子。","price":"39.80元"},{"rating":{"max":10,"numRaters":78,"average":"9.1","min":0},"subtitle":"C语言描述","author":["韦斯(Mark Allen Weiss)"],"pubdate":"2010-8","tags":[{"count":165,"name":"数据结构","title":"数据结构"},{"count":148,"name":"算法","title":"算法"},{"count":89,"name":"计算机","title":"计算机"},{"count":63,"name":"C","title":"C"},{"count":45,"name":"Algorithms","title":"Algorithms"},{"count":41,"name":"计算机科学","title":"计算机科学"},{"count":38,"name":"编程","title":"编程"},{"count":16,"name":"数据结构与算法","title":"数据结构与算法"}],"origin_title":"Data Structures and Algorithm Analysis in C","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s4459394.jpg","binding":"平装","translator":[],"catalog":"1  Introduction  1.1. What's the Book About?  1.2. Mathematics Review    1.2.1. Exponents    1.2.2. Logarithms    1.2.3. Series    1.2.4. Modular Arithmetic    1.2.5. The P Word  1.3. A Brief Introduction to Recursion    Summary    Exercises    References2  Algorithm Analysis3  Lists, Stacks, and Queues4  Trees5  Hashing6  Priority Queues (Heaps)7  Sorting 2198  The Disjoint Set ADT9  Graph Algorithms10  Algorithm Design Techniques11  Amortized Analysis12  Advanced Data Structures and Implementation","pages":"511","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s4459394.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s4459394.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s4459394.jpg"},"alt":"https:\/\/book.douban.com\/subject\/4924153\/","id":"4924153","publisher":"机械工业出版社","isbn10":"7111312805","isbn13":"9787111312802","title":"数据结构与算法分析","url":"https:\/\/api.douban.com\/v2\/book\/4924153","alt_title":"Data Structures and Algorithm Analysis in C","author_intro":"Mark Allen Weiss 1987年在普林斯顿大学获得计算机科学博士学位。师从Roberl Sedgewick，现任美国佛罗里达国际大学计算与信息科学学院教授。他曾担任全美AP(Advanced Placement)考试计算机学科委员会主席。其主要研究方向是数据结构、算法和教育学。","summary":"《数据结构与算法分析:C语言描述》曾被评为20世纪顶尖的30部计算机著作之一，作者在数据结构和算法分析方面卓有建树，他的数据结构和算法分析的著作尤其畅销，并受到广泛好评，已被世界500余所大学选作教材。\n在《数据结构与算法分析:C语言描述》中，作者精炼并强化了他对算法和数据结构方面创新的处理方法。通过C程序的实现，着重阐述了抽象数据类型的概念，并对算法的效率、性能和运行时间进行了分析。\n《数据结构与算法分析:C语言描述》特色：着重讨论了算法设计技巧，包括贪婪算法、分治算法、动态规划、随机化算法以及回溯算法。系统介绍了当前流行的论题和新的数据结构，如斐波那契堆、斜堆、二项队列、跳跃表和伸展树。详细讨论了摊还分析，考查书中介绍的一些高级数据结构。增加了高级数据结构及其实现的内容，包括红黑树、自顶向下伸展树、treap树、k-d树、配对堆等。整合了堆排序平均情况分析的一些新结果。","series":{"id":"1895","title":"经典原版书库"},"price":"45.00元"},{"rating":{"max":10,"numRaters":1802,"average":"9.1","min":0},"subtitle":"（第五版）","author":["Stephen Prata","云巅工作室"],"pubdate":"2005-2-1","tags":[{"count":915,"name":"编程","title":"编程"},{"count":840,"name":"c","title":"c"},{"count":830,"name":"c语言","title":"c语言"},{"count":611,"name":"计算机","title":"计算机"},{"count":480,"name":"程序设计","title":"程序设计"},{"count":379,"name":"经典","title":"经典"},{"count":378,"name":"C","title":"C"},{"count":243,"name":"programming","title":"programming"}],"origin_title":"","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1308874.jpg","binding":"平装(无盘)","translator":["云巅工作室"],"catalog":"第1章 概览\n1.1 C语言的起源\n1.2 使用C语言的理由\n1.3 C语言的发展方向\n1.4 计算机工作的基本原理\n1.5 高级计算机语言和编译器\n1.6 使用C语言的7个步骤\n1.7 编程机制\n1.8 语言标准\n1.9 本书的组织结构\n1.10 本书体例\n1.11 总结\n1.12 复习题\n1.13 编程练习\n第2章 C语言概述\n2.1 C语言的一个简单实例\n2.2 实例说明\n2.3 一个简单程序的结构\n2.4 使程序可读的技巧\n2.5 更进一步\n2.6 多个函数\n2.7 调试\n2.8 关键字和保留标识符\n2.9 关键概念\n2.10 总结\n2.11 复习题\n2.12 编程练习\n第3章 数据和C\n3.1 示例程序\n3.2 变量与常量数据\n3.3 数据：数据类型关键字\n3.4 C数据类型\n3.5 使用数据类型\n3.6 参数和易犯的错误\n3.7 另一个例子：转义序列\n3.8 关键概念\n3.9 总结\n3.10 复习题\n3.11 编程练习\n第4章 字符串和格式化输入\/输出\n4.1 前导程序\n4.2 字符串简介\n4.3 常量和C预处理器\n4.4 研究和利用printf（）和scanf（）\n4.5 关键概念\n4.6 总结\n4.7 复习题\n4.8 编程练习\n第5章 运算符、表达式和语句\n5.1 循环简介\n5.2 基本运算符\n5.3 其他运算符\n5.4 表达式和语句\n5.5 类型转换\n5.6 带有参数的函数\n5.7 一个示例程序\n5.8 关键概念\n5.9 总结\n5.10 复习题\n5.11 编程练习\n第6章 C控制语句：循环\n6.1 再探while循环\n6.2 while语句\n6.4 不确定循环与计数循环\n6.5 for循环\n6.6 更多赋值运算符：+=、-=、*=、\/=和%=\n6.7 逗号运算符\n6.8 退出条件循环：do while\n6.9 选择哪种循环\n6.10 嵌套循环\n6.11 数组\n6.12 使用函数返回值的循环例子\n6.13 关键概念\n6.14 总结\n6.15 复习题\n6.16 编程练习\n第7章 C控制语句：分支和跳转\n7.1 if语句\n7.2 在if语句中添加else关键字\n7.3 获得逻辑性\n7.4 一个统计字数的程序\n7.5 条件运算符?:\n7.6 循环辅助手段：continue和break\n7.7 多重选择：switch和break\n7.8 goto语句\n7.9 关键概念\n7.10 总结\n7.11 复习题\n7.12 编程练习\n第8章 字符输入\/输出和输入确认\n8.1 单字符I\/O：getchar（）和putchar（）\n8.2 缓冲区\n8.3 终止键盘输入\n8.5 创建一个更友好的用户界面\n8.6 输入确认\n8.7 菜单浏览\n8.8 关键概念\n8.9 总结\n8.10 复习题\n8.11 编程练习\n第9章 函数\n9.1 函数概述\n9.2 ANSI C的函数原型\n9.3 递归\n9.4 多源代码文件程序的编译\n9.5 地址运算符：&\n9.6 改变调用函数中的变量\n9.7 指针简介\n9.8 关键概念\n9.9 总结\n9.10 复习题\n9.11 编程练习\n第10章 数组和指针\n10.1 数组\n10.2 多维数组\n10.3 指针和数组\n10.4 函数、数组和指针\n10.5 指针操作\n10.6 保护数组内容\n10.7 指针和多维数组\n10.8 变长数组（VLA）\n10.9 复合文字\n10.10 关键概念\n10.11 总结\n10.12 复习题\n10.13 编程练习\n第11章 字符串和字符串函数\n11.1 字符串表示和字符串I\/O\n11.2 字符串输入\n11.3 字符串输出\n11.4 自定义字符串输入\/输出函数\n11.5 字符串函数\n11.6 字符串例子：字符串排序\n11.7 ctype.h字符函数和字符串\n11.8 命令行参数\n11.9 把字符串转换为数字\n11.10 关键概念\n11.11 总结\n11.12 复习题\n11.13 编程练习\n第12章 存储类、链接和内存管理\n12.1 存储类\n12.2 存储类说明符\n12.3 存储类和函数\n12.4 随机数函数和静态变量\n12.5 掷骰子\n12.6 分配内存：malloc（）和free（）\n12.7 ANSI C的类型限定词\n12.8 关键概念\n12.9 总结\n12.10 复习题\n12.11 编程练习\n第13章 文件输入\/输出\n13.1 和文件进行通信\n13.2 标准I\/O\n13.3 一个简单的文件压缩程序\n13.4 文件I\/O：fprintf ( )、fscanf ( )、fgets ( )和fputs ( )函数\n13.5 随机存取：fseek（）和ftell（）函数\n13.6 标准I\/O内幕\n13.7 其他标准I\/O函数\n13.8 关键概念\n13.9 总结\n13.10 复习题\n13.11 编程练习\n第14章 结构和其他数据形式\n14.1 示例问题：创建图书目录\n14.2 建立结构声明\n14.3 定义结构变量\n14.4 结构数组\n14.5 嵌套结构\n14.6 指向结构的指针\n14.7 向函数传递结构信息\n14.8 把结构内容保存到文件中\n14.9 结构：下一步是什么\n14.10 联合简介\n14.11 枚举类型\n14.12 typedef简介\n14.13 奇特的声明\n14.14 函数和指针\n14.15 关键概念\n14.16 总结\n14.17 复习题\n14.18 编程练习\n第15章 位操作\n15.1 二进制数、位和字节\n15.2 其他基数\n15.3 C的位运算符\n15.4 位字段\n15.5 关键概念\n15.6 总结\n15.7 复习题\n15.8 编程练习\n第16章 C预处理器和C库\n16.1 翻译程序的第一步\n16.2 明显常量：#define\n16.3 在#define中使用参数\n16.4 宏，还是函数\n16.5 文件包含：＃include\n16.6 其他指令\n16.7 内联函数\n16.8 C库\n16.9 数学库\n16.10 通用工具库\n16.11 诊断库\n16.12 string.h库中的memcpy（）和memmove（）\n16.13 可变参数：stdarg.h\n16.14 关键概念\n16.15 总结\n16.16 复习题\n16.17 编程练习\n第17章 高级数据表示\n17.1 研究数据表示\n17.2 从数组到链表\n17.3 抽象数据类型（ADT）\n17.4 队列ADT\n17.5 用队列进行模拟\n17.6 链表与数组\n17.7 二叉搜索树\n17.8 其他说明\n17.9 关键概念\n17.10 总结\n17.11 复习题\n17.12 编程练习\n附录A 复习题答案\n附录B 参考资料","pages":"626","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s1308874.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s1308874.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1308874.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1240002\/","id":"1240002","publisher":"人民邮电出版社","isbn10":"7115130221","isbn13":"9787115130228","title":"C Primer Plus","url":"https:\/\/api.douban.com\/v2\/book\/1240002","alt_title":"","author_intro":"普拉塔，在加利福尼亚州的Kentfield的Marin学院教授天文学、物理学和程序设计课程。他在加州工业学院获得学士学位，从加州大学伯克利分校获得博士学位。他最早接触计算机，始于对星河的计算机建模。Stephen已经编写或与他人合作编写了十多本书。其中包括C++Primer Plus和Unix Prinmer Plus。","summary":"《C Primer Plus（第5版）（中文版）》共17章。第1、2章学习C语言编程所需的预备知识。第3到15章介绍了C语言的相关知识，包括数据类型、格式化输入输出、运算符、表达式、流程控制语句、函数、数组和指针、字符串操作、内存管理、位操作等等，知识内容都针对C99标准；另外，第10章强化了对指针的讨论，第12章引入了动态内存分配的概念，这些内容更加适合读者的需求。第16章和第17章讨论了C预处理器和C库函数、高级数据表示（数据结构）方面的内容。附录给出了各章后面复习题、编程练习的答案和丰富的C编程参考资料。","price":"60.00元"},{"rating":{"max":10,"numRaters":1935,"average":"9.2","min":0},"subtitle":"","author":["Peter Van Der Linden"],"pubdate":"2008-2","tags":[{"count":1196,"name":"C语言","title":"C语言"},{"count":681,"name":"编程","title":"编程"},{"count":446,"name":"计算机","title":"计算机"},{"count":405,"name":"c","title":"c"},{"count":387,"name":"C专家编程","title":"C专家编程"},{"count":364,"name":"C\/C++","title":"C\/C++"},{"count":339,"name":"C","title":"C"},{"count":302,"name":"程序设计","title":"程序设计"}],"origin_title":"Expert C Programming: Deep C Secrets","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s5886086.jpg","binding":"平装","translator":["徐波"],"catalog":"第1章 C：穿越时空的迷雾\n1.1 C语言的史前阶段\n1.2 C语言的早期体验\n1.3 标准I\/O库和C预处理器\n1.4 K&R C\n1.5 今日之ANSI C\n1.6 它很棒，但它符合标准吗\n1.7 编译限制\n1.8 ANSI C标准的结构\n1.9 阅读ANSI C标准，寻找乐趣和裨益\n1.10 “安静的改变”究竟有多少安静\n1.11 轻松一下——由编译器定义的Pragmas效果\n第2章 这不是Bug，而是语言特性\n2.1 这关语言特性何事，在Fortran里这就是Bug呀\n2.2 多做之过\n2.3 误做之过\n2.4 少做之过\n2.5 轻松一下——有些特性确实就是Bug\n2.6 参考文献\n第3章 分析C语言的声明\n3.1 只有编译器才会喜欢的语法\n3.2 声明是如何形成的\n3.3 优先级规则\n3.4 通过图表分析C语言的声明\n3.5 typedef可以成为你的朋友\n3.6 typedef int x[10]和#define x int[10]的区别\n3.7 typedef struct foo{ ... foo; }的含义\n3.8 理解所有分析过程的代码段\n3.9 轻松一下——驱动物理实体的软件\n第4章 令人震惊的事实：数组和指针并不相同\n4.1 数组并非指针\n4.2 我的代码为什么无法运行\n4.3 什么是声明，什么是定义\n4.4 使声明与定义相匹配\n4.5 数组和指针的其他区别\n4.6 轻松一下——回文的乐趣\n第5章 对链接的思考\n5.1 函数库、链接和载入\n5.2 动态链接的优点\n5.3 函数库链接的5个特殊秘密\n5.4 警惕Interpositioning\n5.5 产生链接器报告文件\n5.6 轻松一下——看看谁在说话：挑战Turing测验\n第6章 运动的诗章：运行时数据结构\n6.1 a.out及其传说\n6.2 段\n6.3 操作系统在a.out文件里干了些什么\n6.4 C语言运行时系统在a.out里干了些什么\n6.5 当函数被调用时发生了什么：过程活动记录\n6.6 auto和static关键字\n6.7 控制线程\n6.8 setjmp和longjmp\n6.9 UNIX中的堆栈段\n6.10 MS-DOS中的堆栈段\n6.11 有用的C语言工具\n6.12 轻松一下——卡耐基-梅隆大学的编程难题\n6.13 只适用于高级学员阅读的材料\n第7章 对内存的思考\n7.1 Intel 80x86系列\n7.2 Intel 80x86内存模型以及它的工作原理\n7.3 虚拟内存\n7.4 Cache存储器\n7.5 数据段和堆\n7.6 内存泄漏\n7.7 总线错误\n7.8 轻松一下——“Thing King”和“页面游戏”\n第8章 为什么程序员无法分清万圣节和圣诞节\n8.1 Portzebie度量衡系统\n8.2 根据位模式构筑图形\n8.3 在等待时类型发生了变化\n8.4 原型之痛\n8.5 原型在什么地方会失败\n8.6 不需要按回车键就能得到一个字符\n8.7 用C语言实现有限状态机\n8.8 软件比硬件更困难\n8.9 如何进行强制类型转换，为何要进行类型强制转换\n8.10 轻松一下——国际C语言混乱代码大赛\n第9章 再论数组\n9.1 什么时候数组与指针相同\n9.2 为什么会发生混淆\n9.3 为什么C语言把数组形参当作指针\n9.4 数组片段的下标\n9.5 数组和指针可交换性的总结\n9.6 C语言的多维数组\n9.7 轻松一下——软件\/硬件平衡\n第10章 再论指针\n10.1 多维数组的内存布局\n10.2 指针数组就是Iliffe向量\n10.3 在锯齿状数组上使用指针\n10.4 向函数传递一个一维数组\n10.5 使用指针向函数传递一个多维数组\n10.6 使用指针从函数返回一个数组\n10.7 使用指针创建和使用动态数组\n10.8 轻松一下——程序检验的限制\n第11章 你懂得C，所以C++不在话下\n11.1 初识OOP\n11.2 抽象——取事物的本质特性\n11.3 封装——把相关的类型、数据和函数组合在一起\n11.4 展示一些类——用户定义类型享有和预定义类型一样的权限\n11.5 访问控制\n11.6 声明\n11.7 如何调用成员函数\n11.8 继承——复用已经定义的操作\n11.9 多重继承——从两个或更多的基类派生\n11.10 重载——作用于不同类型的同一操作具有相同的名字\n11.11 C++如何进行操作符重载\n11.12 C++的输入\/输出(I\/O)\n11.13 多态——运行时绑定\n11.14 解释\n11.15 C++如何表现多态\n11.16 新奇玩意——多态\n11.17 C++的其他要点\n11.18 如果我的目标是那里，我不会从这里起步\n11.19 它或许过于复杂，但却是惟一可行的方案\n11.20 轻松一下——死亡计算机协会\n11.21 更多阅读材料\n附录A 程序员工作面试的秘密\n附录B 术语表","pages":"291","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s5886086.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s5886086.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s5886086.jpg"},"alt":"https:\/\/book.douban.com\/subject\/2377310\/","id":"2377310","publisher":"人民邮电出版社","isbn10":"7115171807","isbn13":"9787115171801","title":"C专家编程","url":"https:\/\/api.douban.com\/v2\/book\/2377310","alt_title":"Expert C Programming: Deep C Secrets","author_intro":"","summary":"《C专家编程》展示了最优秀的C程序员所使用的编码技巧，并专门开辟了一章对C++的基础知识进行了介绍。\n书中C的历史、语言特性、声明、数组、指针、链接、运行时、内存以及如何进一步学习C++等问题进行了细致的讲解和深入的分析。全书撷取几十个实例进行讲解，对C程序员具有非常高的实用价值。\n本书可以帮助有一定经验的C程序员成为C编程方面的专家，对于具备相当的C语言基础的程序员，本书可以帮助他们站在C的高度了解和学习C++。","series":{"id":"9931","title":"C和C++经典著作"},"price":"45.00元"},{"rating":{"max":10,"numRaters":154,"average":"8.8","min":0},"subtitle":"C标准库“圣经”","author":["P. J. Plauger"],"pubdate":"2009-7","tags":[{"count":228,"name":"C","title":"C"},{"count":196,"name":"C语言","title":"C语言"},{"count":103,"name":"编程","title":"编程"},{"count":102,"name":"标准库","title":"标准库"},{"count":76,"name":"计算机","title":"计算机"},{"count":76,"name":"C\/C++","title":"C\/C++"},{"count":57,"name":"程序设计","title":"程序设计"},{"count":40,"name":"库","title":"库"}],"origin_title":"","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s3820140.jpg","binding":"","translator":["卢红星","徐明亮","霍建同"],"catalog":"第0章　简介. 1\n0.1　背景知识1\n0.2　C 标准的内容 3\n0.3　库的使用7\n0.4　库的实现9\n0.5　库的测试13\n0.6　参考文献15\n0.7　习题15\n第1章　(assert.h)17\n1.1　背景知识17\n1.2　C 标准的内容18\n1.3　(assert.h) 的使用18\n1.4　(assert.h) 的实现20\n1.5　(assert.h) 的测试22\n1.6　参考文献23\n1.7　习题23\n第2章　(ctype.h) 25\n2.1　背景知识25\n2.2　C 标准的内容28\n2.3　(ctype.h) 的使用 30\n2.4　(ctype.h) 的实现 34\n2.5　(ctype.h) 的测试 42\n2.6　参考文献45\n2.7　习题45\n第3章　(errno.h) 47\n3.1　背景知识47\n3.2　C 标准的内容50\n3.3　(errno.h) 的使用 50\n3.4　(errno.h) 的实现 51\n3.5　(errno.h) 的测试 55\n3.6　参考文献55\n3.7　习题55\n第4章　(float.h)57\n4.1　背景知识57\n4.2　C 标准的内容59\n4.3　(float.h) 的使用.62\n4.4　(float.h) 的实现.64\n4.5　(float.h) 的测试.69\n4.6　参考文献71\n4.7　习题72\n第5章　(limits.h)73\n5.1　背景知识73\n5.2　C 标准的内容74\n5.3　(limits.h) 的使用75\n5.4　(limits.h) 的实现77\n5.5　(limits.h) 的测试79\n5.6　参考文献80\n5.7　习题80\n第6章　(locale.h)81\n6.1　背景知识81\n6.2　C 标准的内容84\n6.3　(locale.h) 的使用87\n6.4　(locale.h) 的实现94\n6.5　(locale.h) 的测试 123\n6.6　参考文献.123\n6.7　习题123\n第7章　(math.h)127\n7.1　背景知识.127\n7.2　C 标准的内容 130\n7.3　(math.h) 的使用 135\n7.4　(math.h) 的实现 137\n7.5　(math.h) 的测试 171\n7.6　参考文献.177\n7.7　习题177\n第8章　(setjmp.h).. 181\n8.1　背景知识.181\n8.2　C 标准的内容 184\n8.3　(setjmp.h) 的使用 185\n8.4　(setjmp.h) 的实现 187\n8.5 (setjmp.h) 的测试191\n8.6 参考文献 192\n8.7 习题 192\n第9章　(signal.h) 193\n9.1　背景知识.193\n9.2　C 标准的内容 195\n9.3　(signal.h) 的使用 197\n9.4　(signal.h) 的实现 199\n9.5　(signal.h) 的测试 203\n9.6　参考文献.203\n9.7　习题203\n第10章　(stdarg.h) 205\n10.1　背景知识205\n10.2　C 标准的内容 207\n10.3　(stdarg.h) 的使用 208\n10.4　(stdarg.h) 的实现 211\n10.5　(stdarg.h) 的测试 212\n10.6　参考文献212\n10.7　习题.214\n第11章　(stddef.h) 215\n11.1　背景知识 215\n11.2　C 标准的内容 217\n11.3　(stddef.h) 的使用 217\n11.4　(stddef.h) 的实现 222\n11.5　(stddef.h) 的测试 223\n11.6　参考文献 223\n11.7　习题223\n第12章　(stdio.h) 225\n12.1　背景知识225\n12.2　C 标准的内容 233\n12.3　(stdio.h) 的使用 252\n12.4　(stdio.h) 的实现 274\n12.5　(stdio.h) 的测试 323\n12.6　参考文献325\n12.7　习题.325\n第13章　(stdlib.h) 331\n13.1　背景知识331\n13.2　C 标准的内容 332\n13.3　(stdlib.h) 的使用 342\n13.4　(stdlib.h) 的实现 351\n13.5　(stdlib.h) 的测试 379\n13.6　参考文献379\n13.7　习题.382\n第14章　(string.h) 385\n14.1　背景知识385\n14.2　C 标准的内容 386\n14.3　(string.h) 的使用 392\n14.4　(string.h) 的实现 396\n14.5　(string.h) 的测试 409\n14.6　参考文献409\n14.7　习题.409\n第15章　(time.h) 413\n15.1　背景知识413\n15.2　C 标准的内容 414\n15.3　(time.h) 的使用 418\n15.4　(time.h) 的实现 422\n15.5　(time.h) 的测试440\n15.6　参考文献441\n15.7　习题.441\n附录A　接口 443\n附录B　名字 451\n附录C　术语... 461","pages":"488","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s3820140.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s3820140.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s3820140.jpg"},"alt":"https:\/\/book.douban.com\/subject\/3775842\/","id":"3775842","publisher":"人民邮电出版社","isbn10":"7115172862","isbn13":"9787115172860","title":"C标准库","url":"https:\/\/api.douban.com\/v2\/book\/3775842","alt_title":"","author_intro":"P. J. Plauger  世界著名的软件技术专家，曾任ISO C标准委员会主席，C\/C++ User’s Journal主编，现任ISO C++标准委员会主席。他是C\/C++标准库开发领域的大师，所开发的Dinkumware标准库应用广泛。","summary":"本书是由世界级C语言专家编写的C标准库经典著作。英文版已经重印十多次，影响了几代程序员。\n本书结合C标准的相关部分，精辟地讲述了每一个库函数的使用方法和实现细节，而这正是一个真正的C程序员所必须掌握的。更重要的是，书中给出了实现和测试这些函数的完整源代码，可以让你更深入地学习C语言。不仅如此，本书还讨论了一些即使是最有经验的C程序员通常也不熟悉的知识，比如国际化和独立于区域设置的程序的编写、与构建库相关的概念和设计思想。\n本书结构清晰，内容权威，阐述精辟，对于各层次C 程序员和相关专业高校师生都是一本优秀的参考书。","series":{"id":"50484","title":"图灵程序设计丛书·C\/C++系列"},"price":"79.00元"},{"rating":{"max":10,"numRaters":808,"average":"8.6","min":0},"subtitle":"一本37.5°C的博物馆地图","author":["沈辛成"],"pubdate":"2017-5-20","tags":[{"count":588,"name":"纽约","title":"纽约"},{"count":560,"name":"博物馆","title":"博物馆"},{"count":455,"name":"旅行","title":"旅行"},{"count":370,"name":"美国","title":"美国"},{"count":337,"name":"艺术","title":"艺术"},{"count":281,"name":"城市","title":"城市"},{"count":214,"name":"历史","title":"历史"},{"count":193,"name":"生活","title":"生活"}],"origin_title":"","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s29478001.jpg","binding":"精装","translator":[],"catalog":"指南与致谢\n有点像跋的序\n第一章 你这个种族主义者\n纽约深度游线路一：黑色与白色\n第二章 没有华尔的街\n纽约深度游线路二：革命与资本\n第三章 纽约水故事\n纽约深度游线路三：饮水与思源\n第四章 我的画报你的城\n纽约深度游之四：寻根与漂流\n第五章 曼哈顿是平的\n纽约深度游之五：贫穷与富裕\n第六章 开往昨天的地铁\n纽约深度游之六：地下与地上\n第七章 美国的归美国，纽约的归纽约\n纽约深度游之七：美国与欧洲\n第八章 不知道为什么就流泪\n纽约深度游之八：战争与和平\n有点像序的跋\n附录\n附录一：一些遗珠\n附录二：纽约博物馆排名","pages":"380","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s29478001.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s29478001.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s29478001.jpg"},"alt":"https:\/\/book.douban.com\/subject\/27037182\/","id":"27037182","publisher":"中西书局","isbn10":"7547512488","isbn13":"9787547512487","title":"纽约无人是客","url":"https:\/\/api.douban.com\/v2\/book\/27037182","alt_title":"","author_intro":"沈辛成，1984年生人，非业余博物馆爱好者，走访全美八十余座博物馆，曾服务于美国自然历史博物馆、“911”国家纪念馆和纽约历史学会，参与从事档案研究、出版与策展工作。佐治亚理工学院科技史博士在读，哥伦比亚大学人类学硕士，复旦大学考古学硕士，北京大学博物馆学学士，做过独立唱作人，兼职美国时政评论。","summary":"本书为作者在纽约实地踏访数十家博物馆并进行深入了解后，对纽约博物馆展示特色、专业内涵、设计匠心及观众体验等进行多维度评价的作品。\n本书不是一本简单的博物馆导览手册，而是基于作者的个人经历和专业背景，试图阐释纽约这个五方杂处、光怪陆离却又独具特色的国际大都会的底色。全书行文从容，图文并茂，兼具知识性、实用性和可读性，无论是否去过纽约，它都会在流畅的阅读之后，带给你充足的知识与细节，同时也带给你深深的思索。","price":"39.80元"},{"rating":{"max":10,"numRaters":1399,"average":"9.0","min":0},"subtitle":"","author":["Kenneth A.Reek"],"pubdate":"2008 年4月","tags":[{"count":869,"name":"C","title":"C"},{"count":776,"name":"C语言","title":"C语言"},{"count":540,"name":"编程","title":"编程"},{"count":437,"name":"指针","title":"指针"},{"count":381,"name":"计算机","title":"计算机"},{"count":304,"name":"程序设计","title":"程序设计"},{"count":276,"name":"C\/C++","title":"C\/C++"},{"count":180,"name":"Programming","title":"Programming"}],"origin_title":"Pointers on C","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s2996168.jpg","binding":"平装","translator":["徐波"],"catalog":"第1章 快速上手\n1.1 简介\n1.1.1 空白和注释\n1.1.2 预处理指令\n1.1.3 main函数\n1.1.4 read_column_numbers函数\n1.1.5 rearrange函数\n1.2 补充说明\n1.3 编译\n1.4 总结\n1.5 警告的总结\n1.6 编程提示的总结\n1.7 问题\n1.8 编程练习\n第2章 基本概念\n2.1 环境\n2.1.1 翻译\n2.1.2 执行\n2.2 词法规则\n2.2.1 字符\n2.2.2 注释\n2.2.3 自由形式的源代码\n2.2.4 标识符\n2.2.5 程序的形式\n2.3 程序风格\n2.4 总结\n2.5 警告的总结\n2.6 编程提示的总结\n2.7 问题\n2.8 编程练习\n第3章 数据\n第4章 语句\n第5章 操作符和表达式\n第6章 指针\n第7章 函数\n第8章 数组\n第9章 字符串、字符和字节\n第10章 结构和联合\n第11章 动态内存分配\n第12章 使用结构和指针\n第13章 高级指针话题\n第14章 预处理器\n第15章 输入\/输出函数\n第16章 标准函数库\n第17章 经典抽象数据类型\n第18章 运行时环境\n附录 部分问题答案\n索引\n参考文献","pages":"448","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s2996168.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s2996168.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s2996168.jpg"},"alt":"https:\/\/book.douban.com\/subject\/3012360\/","id":"3012360","publisher":"人民邮电出版社","isbn10":"7115172013","isbn13":"9787115172013","title":"C和指针","url":"https:\/\/api.douban.com\/v2\/book\/3012360","alt_title":"Pointers on C","author_intro":"Kenneth·Reek是罗彻斯特理工大学计算机科学教授。他是一位经验丰富的C程序员，曾为多家公司担任过技术顾问。他讲授的课程有操作系统、数据通信、计算机网络、形式语言、算法分析和交换系统等。本书正是基于他9年的编程及教学的经验积累。","summary":"本书提供与C语言编程相关的全面资源和深入讨论。本书通过对指针的基础知识和高级特性的探讨，帮助程序员把指针的强大功能融入到自己的程序中去。\n全书共18章，覆盖了数据、语句、操作符和表达式、指针、函数、数组、字符串、结构和联合等几乎所有重要的C编程话题。书中给出了很多编程技巧和提示，每章后面有针对性很强的练习，附录部分则给出了部分练习的解答。\n本书适合C语言初学者和初级C程序员阅读，也可作为计算机专业学生学习C语言的参考。","series":{"id":"9931","title":"C和C++经典著作"},"price":"65.00元"},{"rating":{"max":10,"numRaters":1270,"average":"9.6","min":0},"subtitle":"-","author":["Brian W. Kernighan","Dennis M. Ritchie"],"pubdate":"1988-4-1","tags":[{"count":611,"name":"c","title":"c"},{"count":434,"name":"Programming","title":"Programming"},{"count":403,"name":"C语言","title":"C语言"},{"count":382,"name":"编程","title":"编程"},{"count":316,"name":"计算机","title":"计算机"},{"count":240,"name":"经典","title":"经典"},{"count":218,"name":"C","title":"C"},{"count":205,"name":"程序设计","title":"程序设计"}],"origin_title":"","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s29586132.jpg","binding":"Paperback","translator":[],"catalog":"","pages":"274","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s29586132.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s29586132.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s29586132.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1236999\/","id":"1236999","publisher":"Prentice Hall","isbn10":"0131103628","isbn13":"9780131103627","title":"The  C Programming Language","url":"https:\/\/api.douban.com\/v2\/book\/1236999","alt_title":"C Programming Language","author_intro":"Brian W. Kernighan works in the Computing Science Research Center at Bell Laboratories, Lucent Technologies. He is Consulting Editor for Addison-Wesley's Professional Computing Series and the author, with Dennis Ritchie, of The C Programming Language.\nDennis Ritchie is a computer scientist notable for his influence on ALTRAN, B, BCPL, C, Multics, and Unix.","summary":"Presents a complete guide to ANSI standard C language programming. Written by the developers of C, this new version helps readers keep up with the finalized ANSI standard for C while showing how to take advantage of C's rich set of operators, economy of expression, improved control flow, and data structures. This 2nd edition has been completely rewritten with additional examples and problem sets to clarify the implementation of difficult language constructs. 7 x 9 1\/4.","price":"USD 67.00"},{"rating":{"max":10,"numRaters":604,"average":"9.3","min":0},"subtitle":"第六版","author":["普拉达 (Stephen Prata)"],"pubdate":"2016-4-1","tags":[{"count":347,"name":"C语言","title":"C语言"},{"count":231,"name":"C","title":"C"},{"count":215,"name":"编程","title":"编程"},{"count":183,"name":"计算机","title":"计算机"},{"count":142,"name":"计算机科学","title":"计算机科学"},{"count":125,"name":"经典","title":"经典"},{"count":86,"name":"C++","title":"C++"},{"count":78,"name":"软件开发","title":"软件开发"}],"origin_title":"C Primer Plus : 6th","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s29438897.jpg","binding":"平装","translator":["姜佑"],"catalog":"第1章　初识C语言\t1\n1．1　C语言的起源\t1\n1．2 选择C语言的理由\t1\n1．2．1 设计特性\t1\n1．2．2 高效性\t1\n1．2．3 可移植性\t2\n1．2．4 强大而灵活\t3\n1．2．5 面向程序员\t3\n1．2．6 缺点\t3\n1．3 C语言的应用范围\t3\n1．4 计算机能做什么\t4\n1．5 高级计算机语言和编译器\t5\n1．6 语言标准\t6\n1．6．1 第1个ANSI\/ISO C标准\t6\n1．6．2 C99标准\t6\n1．6．3 C11标准\t7\n1．7 使用C语言的7个步骤\t7\n1．7．1 第1步：定义程序的目标\t8\n1．7．2 第2步：设计程序\t8\n1．7．3 第3步：编写代码\t8\n1．7．4 第4步：编译\t8\n1．7．5 第5步：运行程序\t9\n1．7．6 第6步：测试和调试程序\t9\n1．7．7 第7步：维护和修改代码\t9\n1．7．8 说明\t9\n1．8 编程机制\t10\n1．8．1 目标代码文件、可执行文件和库\t10\n1．8．2 UNIX系统\t11\n1．8．3 GNU编译器集合和LLVM项目\t13\n1．8．4 Linux系统\t13\n1．8．5 PC的命令行编译器\t14\n1．8．6 集成开发环境（Windows）\t14\n1．8．7 Windows\/Linux\t15\n1．8．8 Macintosh中的C\t15\n1．9 本书的组织结构\t15\n1．10 本书的约定\t16\n1．10．1 字体\t16\n1．10．2 程序输出\t16\n1．10．3 特殊元素\t17\n1．11 本章小结\t17\n1．12 复习题\t18\n1．13 编程练习\t18\n第2章　C语言概述\t19\n2．1 简单的C程序示例\t19\n2．2 示例解释\t20\n2．2．1 第1遍：快速概要\t21\n2．2．2 第2遍：程序细节\t21\n2．3 简单程序的结构\t28\n2．4 提高程序可读性的技巧\t28\n2．5 进一步使用C\t29\n2．5．1 程序说明\t30\n2．5．2 多条声明\t30\n2．5．3 乘法\t30\n2．5．4 打印多个值\t30\n2．6 多个函数\t30\n2．7 调试程序\t32\n2．7．1 语法错误\t32\n2．7．2 语义错误\t33\n2．7．3 程序状态\t34\n2．8 关键字和保留标识符\t34\n2．9 关键概念\t35\n2．10 本章小结\t35\n2．11 复习题\t36\n2．12 编程练习\t37\n第3章　数据和C\t39\n3．1 示例程序\t39\n3．2 变量与常量数据\t42\n3．3 数据：数据类型关键字\t42\n3．3．1 整数和浮点数\t43\n3．3．2 整数\t43\n3．3．3 浮点数\t43\n3．4 C语言基本数据类型\t44\n3．4．1 int类型\t44\n3．4．2 其他整数类型\t47\n3．4．3 使用字符：char类型\t50\n3．4．4 _Bool类型\t54\n3．4．5 可移植类型：stdint．h和inttypes．h\t55\n3．4．6 float、double和long double\t56\n3．4．7 复数和虚数类型\t60\n3．4．8 其他类型\t60\n3．4．9 类型大小\t62\n3．5 使用数据类型\t63\n3．6 参数和陷阱\t63\n3．7 转义序列示例\t64\n3．7．1 程序运行情况\t65\n3．7．2 刷新输出\t65\n3．8 关键概念\t66\n3．9 本章小结\t66\n3．10 复习题\t67\n3．11 编程练习\t68\n第4章　字符串和格式化输入\/输出\t71\n4．1 前导程序\t71\n4．2 字符串简介\t72\n4．2．1 char类型数组和null字符\t72\n4．2．2 使用字符串\t73\n4．2．3 strlen()函数\t74\n4．3 常量和C预处理器\t76\n4．3．1 const限定符\t78\n4．3．2 明示常量\t78\n4．4 printf()和scanf()\t80\n4．4．1 printf()函数\t80\n4．4．2 使用printf()\t81\n4．4．3 printf()的转换说明修饰符\t83\n4．4．4 转换说明的意义\t87\n4．4．5 使用scanf()\t92\n4．4．6 printf()和scanf()的*修饰符\t95\n4．4．7 printf()的用法提示\t97\n4．5 关键概念\t98\n4．6 本章小结\t98\n4．7 复习题\t99\n4．8 编程练习\t100\n第5章　运算符、表达式和语句\t103\n5．1 循环简介\t103\n5．2 基本运算符\t105\n5．2．1 赋值运算符：=\t105\n5．2．2 加法运算符：+\t107\n5．2．3 减法运算符：-\t107\n5．2．4 符号运算符：-和+\t107\n5．2．5 乘法运算符：*\t108\n5．2．6 除法运算符：\/\t110\n5．2．7 运算符优先级\t110\n5．2．8 优先级和求值顺序\t112\n5．3 其他运算符\t113\n5．3．1 sizeof运算符和size_t类型\t113\n5．3．2 求模运算符：%\t114\n5．3．3 递增运算符：++\t115\n5．3．4 递减运算符：--\t118\n5．3．5 优先级\t118\n5．3．6 不要自作聪明\t119\n5．4 表达式和语句\t120\n5．4．1 表达式\t120\n5．4．2 语句\t120\n5．4．3 复合语句（块）\t123\n5．5 类型转换\t124\n5．6 带参数的函数\t127\n5．7 示例程序\t129\n5．8 关键概念\t130\n5．9 本章小结\t130\n5．10 复习题\t131\n5．11 编程练习\t134\n第6章　C控制语句：循环\t137\n6．1 再探while循环\t137\n6．1．1 程序注释\t138\n6．1．2 C风格读取循环\t139\n6．2 while语句\t140\n6．2．1 终止while循环\t140\n6．2．2 何时终止循环\t141\n6．2．3 while：入口条件循环\t141\n6．2．4 语法要点\t141\n6．3 用关系运算符和表达式比较大小\t143\n6．3．1 什么是真\t144\n6．3．2 其他真值\t145\n6．3．3 真值的问题\t146\n6．3．4 新的_Bool类型\t147\n6．3．5 优先级和关系运算符\t148\n6．4 不确定循环和计数循环\t150\n6．5 for循环\t151\n6．6 其他赋值运算符：+=、-=、*=、\/=、%=\t155\n6．7 逗号运算符\t156\n6．8 出口条件循环：do while\t159\n6．9 如何选择循环\t161\n6．10 嵌套循环\t162\n6．10．1 程序分析\t163\n6．10．2 嵌套变式\t163\n6．11 数组简介\t164\n6．12 使用函数返回值的循环示例\t166\n6．12．1 程序分析\t168\n6．12．2 使用带返回值的函数\t169\n6．13 关键概念\t169\n6．14 本章小结\t170\n6．15 复习题\t170\n6．16 编程练习\t174\n第7章　C控制语句：分支和跳转\t177\n7．1 if语句\t177\n7．2 if else语句\t179\n7．2．1 另一个示例：介绍getchar()和putchar()\t180\n7．2．2 ctype．h系列的字符函数\t182\n7．2．3 多重选择else if\t184\n7．2．4 else与if配对\t186\n7．2．5 多层嵌套的if语句\t187\n7．3 逻辑运算符\t190\n7．3．1 备选拼写：iso646．h头文件\t191\n7．3．2 优先级\t192\n7．3．3 求值顺序\t192\n7．3．4 范围\t193\n7．4 一个统计单词的程序\t194\n7．5 条件运算符：?：\t196\n7．6 循环辅助：continue和break\t198\n7．6．1 continue语句\t198\n7．6．2 break语句\t200\n7．7 多重选择：switch和break\t202\n7．7．1 switch语句\t204\n7．7．2 只读每行的首字符\t205\n7．7．3 多重标签\t206\n7．7．4 switch和if else\t208\n7．8 goto语句\t208\n7．9 关键概念\t211\n7．10 本章小结\t211\n7．11 复习题\t212\n7．12 编程练习\t214\n第8章　字符输入\/输出和输入验证\t217\n8．1 单字符I\/O：getchar()和putchar()\t217\n8．2 缓冲区\t218\n8．3 结束键盘输入\t219\n8．3．1 文件、流和键盘输入\t219\n8．3．2 文件结尾\t220\n8．4 重定向和文件\t222\n8．5 创建更友好的用户界面\t226\n8．5．1 使用缓冲输入\t226\n8．5．2 混合数值和字符输入\t228\n8．6 输入验证\t230\n8．6．1 分析程序\t234\n8．6．2 输入流和数字\t234\n8．7 菜单浏览\t235\n8．7．1 任务\t235\n8．7．2 使执行更顺利\t235\n8．7．3 混合字符和数值输入\t237\n8．8 关键概念\t240\n8．9 本章小结\t240\n8．10 复习题\t241\n8．11 编程练习\t241\n第9章　函数\t243\n9．1 复习函数\t243\n9．1．1 创建并使用简单函数\t244\n9．1．2 分析程序\t245\n9．1．3 函数参数\t247\n9．1．4 定义带形式参数的函数\t248\n9．1．5 声明带形式参数函数的原型\t249\n9．1．6 调用带实际参数的函数\t249\n9．1．7 黑盒视角\t250\n9．1．8 使用return从函数中返回值\t250\n9．1．9 函数类型\t252\n9．2 ANSI C函数原型\t253\n9．2．1 问题所在\t253\n9．2．2 ANSI的解决方案\t254\n9．2．3 无参数和未指定参数\t255\n9．2．4 函数原型的优点\t256\n9．3 递归\t256\n9．3．1 演示递归\t256\n9．3．2 递归的基本原理\t258\n9．3．3 尾递归\t258\n9．3．4 递归和倒序计算\t260\n9．3．5 递归的优缺点\t262\n9．4 编译多源代码文件的程序\t262\n9．4．1 UNIX\t263\n9．4．2 Linux\t263\n9．4．3 DOS命令行编译器\t263\n9．4．4 Windows和苹果的IDE编译器\t263\n9．4．5 使用头文件\t263\n9．5 查找地址：&运算符\t267\n9．6 更改主调函数中的变量\t268\n9．7 指针简介\t269\n9．7．1 间接运算符：*\t270\n9．7．2 声明指针\t270\n9．7．3 使用指针在函数间通信\t271\n9．8 关键概念\t274\n9．9 本章小结\t275\n9．10　复习题\t275\n9．11 编程练习\t276\n第10章　数组和指针\t277\n10．1 数组\t277\n10．1．1 初始化数组\t277\n10．1．2 指定初始化器（C99）\t281\n10．1．3 给数组元素赋值\t282\n10．1．4 数组边界\t282\n10．1．5 指定数组的大小\t284\n10．2 多维数组\t284\n10．2．1 初始化二维数组\t287\n10．2．2 其他多维数组\t288\n10．3 指针和数组\t288\n10．4 函数、数组和指针\t290\n10．4．1 使用指针形参\t293\n10．4．2 指针表示法和数组表示法\t294\n10．5 指针操作\t295\n10．6 保护数组中的数据\t298\n10．6．1 对形式参数使用const\t299\n10．6．2　const的其他内容\t300\n10．7 指针和多维数组\t302\n10．7．1 指向多维数组的指针\t304\n10．7．2 指针的兼容性\t305\n10．7．3 函数和多维数组\t306\n10．8 变长数组（VLA）\t309\n10．9 复合字面量\t312\n10．10 关键概念\t314\n10．11 本章小结\t315\n10．12 复习题\t316\n10．13 编程练习\t317\n第11章　字符串和字符串函数\t321\n11．1 表示字符串和字符串I\/O\t321\n11．1．1 在程序中定义字符串\t322\n11．1．2 指针和字符串\t328\n11．2 字符串输入\t329\n11．2．1 分配空间\t329\n11．2．2 不幸的gets()函数\t330\n11．2．3 gets()的替代品\t331\n11．2．4 scanf()函数\t336\n11．3 字符串输出\t337\n11．3．1 puts()函数\t338\n11．3．2 fputs()函数\t339\n11．3．3 printf()函数\t339\n11．4 自定义输入\/输出函数\t340\n11．5 字符串函数\t342\n11．5．1 strlen()函数\t342\n11．5．2 strcat()函数\t343\n11．5．3 strncat()函数\t345\n11．5．4 strcmp()函数\t346\n11．5．5 strcpy()和strncpy()函数\t351\n11．5．6 sprintf()函数\t356\n11．5．7 其他字符串函数\t357\n11．6 字符串示例：字符串排序\t359\n11．6．1 排序指针而非字符串\t360\n11．6．2 选择排序算法\t361\n11．7 ctype．h字符函数和字符串\t362\n11．8 命令行参数\t363\n11．8．1 集成环境中的命令行参数\t365\n11．8．2 Macintosh中的命令行参数\t365\n11．9 把字符串转换为数字\t365\n11．10 关键概念\t368\n11．11 本章小结\t368\n11．12 复习题\t369\n11．13 编程练习\t371\n第12章　存储类别、链接和内存管理\t373\n12．1 存储类别\t373\n12．1．1 作用域\t374\n12．1．2 链接\t376\n12．1．3 存储期\t376\n12．1．4 自动变量\t377\n12．1．5 寄存器变量\t380\n12．1．6 块作用域的静态变量\t381\n12．1．7 外部链接的静态变量\t382\n12．1．8 内部链接的静态变量\t386\n12．1．9 多文件\t386\n12．1．10 存储类别说明符\t387\n12．1．11 存储类别和函数\t389\n12．1．12 存储类别的选择\t389\n12．2 随机数函数和静态变量\t390\n12．3 掷骰子\t393\n12．4 分配内存：malloc()和free()\t396\n12．4．1 free()的重要性\t399\n12．4．2 calloc()函数\t400\n12．4．3 动态内存分配和变长数组\t400\n12．4．4 存储类别和动态内存分配\t401\n12．5 ANSI C类型限定符\t402\n12．5．1 const类型限定符\t403\n12．5．2 volatile类型限定符\t404\n12．5．3 restrict类型限定符\t405\n12．5．4 _Atomic类型限定符（C11）\t406\n12．5．5 旧关键字的新位置\t406\n12．6　关键概念\t407\n12．7 本章小结\t407\n12．8 复习题\t408\n12．9 编程练习\t409\n第13章　文件输入\/输出\t413\n13．1 与文件进行通信\t413\n13．1．1 文件是什么\t413\n13．1．2 文本模式和二进制模式\t413\n13．1．3 I\/O的级别\t415\n13．1．4 标准文件\t415\n13．2 标准I\/O\t415\n13．2．1 检查命令行参数\t416\n13．2．2 fopen()函数\t416\n13．2．3 getc()和putc()函数\t417\n13．2．4 文件结尾\t418\n13．2．5 fclose()函数\t419\n13．2．6 指向标准文件的指针\t419\n13．3 一个简单的文件压缩程序\t419\n13．4 文件I\/O：fprintf()、fscanf()、fgets()和fputs()\t421\n13．4．1 fprintf()和fscanf()函数\t421\n13．4．2 fgets()和fputs()函数\t422\n13．5 随机访问：fseek()和ftell()\t423\n13．5．1 fseek()和ftell()的工作原理\t424\n13．5．2 二进制模式和文本模式\t425\n13．5．3 可移植性\t425\n13．5．4 fgetpos()和fsetpos()函数\t426\n13．6 标准I\/O的机理\t426\n13．7 其他标准I\/O函数\t427\n13．7．1 int ungetc(int c， FILE *fp)函数\t427\n13．7．2 int fflush()函数\t428\n13．7．3 int setvbuf()函数\t428\n13．7．4 二进制I\/O：fread()和fwrite()\t428\n13．7．5 size_t fwrite()函数\t429\n13．7．6 size_t fread()函数\t430\n13．7．7 int feof(FILE *fp)和int ferror(FILE *fp)函数\t430\n13．7．8 一个程序示例\t430\n13．7．9 用二进制I\/O进行随机访问\t433\n13．8 关键概念\t435\n13．9 本章小结\t435\n13．10 复习题\t435\n13．11 编程练习\t437\n第14章　结构和其他数据形式\t439\n14．1 示例问题：创建图书目录\t439\n14．2 建立结构声明\t441\n14．3 定义结构变量\t441\n14．3．1 初始化结构\t442\n14．3．2 访问结构成员\t443\n14．3．3 结构的初始化器\t443\n14．4 结构数组\t444\n14．4．1 声明结构数组\t446\n14．4．2 标识结构数组的成员\t447\n14．4．3 程序讨论\t447\n14．5 嵌套结构\t448\n14．6 指向结构的指针\t449\n14．6．1 声明和初始化结构指针\t450\n14．6．2 用指针访问成员\t451\n14．7 向函数传递结构的信息\t451\n14．7．1 传递结构成员\t451\n14．7．2 传递结构的地址\t452\n14．7．3 传递结构\t453\n14．7．4 其他结构特性\t454\n14．7．5 结构和结构指针的选择\t458\n14．7．6 结构中的字符数组和字符指针\t458\n14．7．7 结构、指针和malloc()\t459\n14．7．8 复合字面量和结构（C99）\t462\n14．7．9 伸缩型数组成员（C99）\t463\n14．7．10 匿名结构（C11）\t465\n14．7．11 使用结构数组的函数\t466\n14．8 把结构内容保存到文件中\t467\n14．8．1 保存结构的程序示例\t468\n14．8．2 程序要点\t470\n14．9 链式结构\t471\n14．10 联合简介\t472\n14．10．1 使用联合\t472\n14．10．2 匿名联合（C11）\t473\n14．11 枚举类型\t474\n14．11．1 enum常量\t475\n14．11．2 默认值\t475\n14．11．3 赋值\t475\n14．11．4 enum的用法\t476\n14．11．5 共享名称空间\t477\n14．12 typedef简介\t478\n14．13 其他复杂的声明\t479\n14．14 函数和指针\t481\n14．15 关键概念\t487\n14．16 本章小结\t487\n14．17 复习题\t488\n14．18 编程练习\t490\n第15章　位操作\t493\n15．1 二进制数、位和字节\t493\n15．1．1 二进制整数\t494\n15．1．2 有符号整数\t494\n15．1．3 二进制浮点数\t495\n15．2 其他进制数\t495\n15．2．1 八进制\t495\n15．2．2 十六进制\t496\n15．3 C按位运算符\t496\n15．3．1 按位逻辑运算符\t497\n15．3．2 用法：掩码\t498\n15．3．3 用法：打开位（设置位）\t498\n15．3．4 用法：关闭位（清空位）\t499\n15．3．5 用法：切换位\t499\n15．3．6 用法：检查位的值\t500\n15．3．7 移位运算符\t500\n15．3．8 编程示例\t501\n15．3．9 另一个例子\t503\n15．4 位字段\t505\n15．4．1 位字段示例\t506\n15．4．2 位字段和按位运算符\t509\n15．5 对齐特性（C11）\t515\n15．6 关键概念\t516\n15．7 本章小结\t516\n15．8 复习题\t517\n15．9 编程练习\t518\n第16章　C预处理器和C库\t521\n16．1 翻译程序的第一步\t521\n16．2 明示常量：#define\t522\n16．2．1 记号\t525\n16．2．2 重定义常量\t525\n16．3 在#define中使用参数\t525\n16．3．1 用宏参数创建字符串：#运算符\t527\n16．3．2 预处理器黏合剂：##运算符\t528\n16．3．3 变参宏：．．．和_ _VA_ARGS_ _\t529\n16．4 宏和函数的选择\t530\n16．5 文件包含：#include\t531\n16．5．1 头文件示例\t531\n16．5．2 使用头文件\t533\n16．6 其他指令\t534\n16．6．1 #undef指令\t534\n16．6．2 从C预处理器角度看已定义\t534\n16．6．3 条件编译\t535\n16．6．4 预定义宏\t539\n16．6．5 #line和#error\t540\n16．6．6 #pragma\t540\n16．6．7 泛型选择（C11）\t541\n16．7 内联函数（C99）\t542\n16．8 _Noreturn函数（C11）\t544\n16．9 C库\t544\n16．9．1 访问C库\t544\n16．9．2 使用库描述\t545\n16．10 数学库\t546\n16．10．1 三角问题\t547\n16．10．2 类型变体\t548\n16．10．3 tgmath．h库（C99）\t550\n16．11 通用工具库\t550\n16．11．1 exit()和atexit()函数\t550\n16．11．2 qsort()函数\t552\n16．12 断言库\t556\n16．12．1 assert的用法\t556\n16．12．2 _Static_assert（C11）\t557\n16．13 string．h库中的memcpy()和memmove()\t558\n16．14 可变参数：stdarg．h\t560\n16．15 关键概念\t562\n16．16 本章小结\t562\n16．17 复习题\t562\n16．18 编程练习\t563\n第17章　高级数据表示\t567\n17．1 研究数据表示\t567\n17．2 从数组到链表\t570\n17．2．1 使用链表\t572\n17．2．2 反思\t576\n17．3 抽象数据类型（ADT）\t576\n17．3．1 建立抽象\t577\n17．3．2 建立接口\t578\n17．3．3 使用接口\t581\n17．3．4 实现接口\t583\n17．4 队列ADT\t589\n17．4．1 定义队列抽象数据类型\t590\n17．4．2 定义一个接口\t590\n17．4．3 实现接口数据表示\t591\n17．4．4 测试队列\t598\n17．5 用队列进行模拟\t600\n17．6 链表和数组\t605\n17．7 二叉查找树\t608\n17．7．1 二叉树ADT\t608\n17．7．2 二叉查找树接口\t609\n17．7．3 二叉树的实现\t611\n17．7．4 使用二叉树\t624\n17．7．5 树的思想\t628\n17．8 其他说明\t629\n17．9 关键概念\t630\n17．10 本章小结\t630\n17．11 复习题\t630\n17．12 编程练习\t631\n附录A　复习题答案\t633\n附录B　参考资料\t665\nB．1 参考资料I：补充阅读\t665\nB．2 参考资料II：C运算符\t667\nB．3 参考资料III：基本类型和存储类别\t671\nB．4 参考资料IV：表达式、语句和程序流\t675\nB．5 参考资料V：新增C99和C11的ANSI C库\t679\nB．6 参考资料VI：扩展的整数类型\t714\nB．7 参考资料VII：扩展字符支持\t716\nB．8 参考资料VIII：C99\/C11数值计算增强\t720\nB．9 参考资料IX：C和C++的区别\t726","pages":"730","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s29438897.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s29438897.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s29438897.jpg"},"alt":"https:\/\/book.douban.com\/subject\/26792521\/","id":"26792521","publisher":"人民邮电出版社","isbn10":"7115390592","isbn13":"9787115390592","title":"C Primer Plus（第6版）中文版","url":"https:\/\/api.douban.com\/v2\/book\/26792521","alt_title":"C Primer Plus : 6th","author_intro":"Stephen Prata曾在加利福尼亚的马林学院（肯特菲尔德）教授天文学、物理学和程序设计课程，现已退休。他在加州理工学院获得学士学位，在加州大学伯克利分校获得博士学位。他接触程序设计，是为了利用计算机给星团建模。Stephen撰写和与他人合著了十几本书籍，其中包括C++ Primer Plus和Unix Primer Plus。","summary":"《C Primer Plus（第6版）中文版》详细讲解了C语言的基本概念和编程技巧。\n《C Primer Plus（第6版）中文版》共17章。第1、2章介绍了C语言编程的预备知识。第3~15章详细讲解了C语言的相关知识，包括数据类型、格式化输入\/输出、运算符、表达式、语句、循环、字符输入和输出、函数、数组和指针、字符和字符串函数、内存管理、文件输入输出、结构、位操作等。第16章、17章介绍C预处理器、C库和高级数据表示。本书以完整的程序为例，讲解C语言的知识要点和注意事项。每章末设计了大量复习题和编程练习，帮助读者巩固所学知识和提高实际编程能力。附录给出了各章复习题的参考答案和丰富的参考资料。\n《C Primer Plus（第6版）中文版》可作为C语言的教材，适用于需要系统学习C语言的初学者，也适用于巩固C语言知识或希望进一步提高编程技术的程序员。","series":{"id":"23545","title":"C和C++实务精选"},"price":"CNY 89.00"},{"rating":{"max":10,"numRaters":389,"average":"9.3","min":0},"subtitle":"现代方法","author":["K. N. King"],"pubdate":"2010-4","tags":[{"count":526,"name":"C语言","title":"C语言"},{"count":315,"name":"C","title":"C"},{"count":240,"name":"程序设计","title":"程序设计"},{"count":239,"name":"编程","title":"编程"},{"count":230,"name":"计算机","title":"计算机"},{"count":182,"name":"C\/C++","title":"C\/C++"},{"count":162,"name":"编程语言","title":"编程语言"},{"count":128,"name":"计算机科学","title":"计算机科学"}],"origin_title":"C Programming: A Modern Approach, Second Edition","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s4171870.jpg","binding":"平装","translator":["吕秀锋","黄倩"],"catalog":"第1章 C语言概述1\n1.1 C语言的历史1\n1.1.1 起源1\n1.1.2 标准化1\n1.1.3 基于C的语言2\n1.2 C语言的优缺点3\n1.2.1 C语言的优点3\n1.2.2 C语言的缺点3\n1.2.3 高效地使用C语言4\n问与答5\n第2章 C语言基本概念7\n2.1 编写一个简单的C程序7\n程序显示双关语7\n2.1.1 编译和链接8\n2.1.2 集成开发环境8\n2.2 简单程序的一般形式9\n2.2.1 指令9\n2.2.2 函数9\n2.2.3 语句10\n2.2.4 显示字符串10\n2.3 注释11\n2.4 变量和赋值12\n2.4.1 类型12\n2.4.2 声明13\n2.4.3 赋值13\n2.4.4 显示变量的值14\n程序计算箱子的空间重量14\n2.4.5 初始化15\n2.4.6 显示表达式的值16\n2.5 读入输入16\n程序计算箱子的空间重量（改进版）16\n2.6 定义常量的名字17\n程序华氏温度转换为摄氏温度17\n2.7 标识符18\n2.8 C程序的书写规范19\n问与答21\n练习题23\n编程题24\n第3章 格式化输入\/输出26\n3.1 printf函数26\n3.1.1 转换说明27\n程序用printf函数格式化数28\n3.1.2 转义序列28\n3.2 scanf函数29\n3.2.1 scanf函数的工作方法30\n3.2.2 格式串中的普通字符31\n3.2.3 易混淆的printf函数和scanf函数32\n程序分数相加32\n问与答33\n练习题34\n编程题35\n第4章 表达式36\n4.1 算术运算符36\n程序计算通用产品代码的校验位38\n4.2 赋值运算符39\n4.2.1 简单赋值40\n4.2.2 左值41\n4.2.3 复合赋值41\n4.3 自增运算符和自减运算符42\n4.4 表达式求值43\n4.5 表达式语句45\n问与答45\n练习题47\n编程题49\n第5章 选择语句50\n5.1 逻辑表达式50\n5.1.1 关系运算符50\n5.1.2 判等运算符51\n5.1.3 逻辑运算符51\n5.2 if语句52\n5.2.1 复合语句53\n5.2.2 else子句53\n5.2.3 级联式if语句54\n程序计算股票经纪人的佣金55\n5.2.4 “悬空else”的问题56\n5.2.5 条件表达式57\n5.2.6 C89中的布尔值58\n5.2.7 C99中的布尔值58\n5.3 switch语句59\n程序显示法定格式的日期61\n问与答62\n练习题65\n编程题67\n第6章 循环69\n6.1 while语句69\n程序显示平方表71\n程序数列求和71\n6.2 do语句72\n程序计算整数的位数73\n6.3 for语句73\n6.3.1 for语句的惯用法74\n6.3.2 在for语句中省略表达式75\n6.3.3 C99中的for语句75\n6.3.4 逗号运算符76\n程序显示平方表（改进版）77\n6.4 退出循环78\n6.4.1 break语句78\n6.4.2 continue语句78\n6.4.3 goto语句79\n程序账簿结算80\n6.5 空语句81\n问与答83\n练习题84\n编程题85\n第7章 基本类型88\n7.1 整数类型88\n7.1.1 C99中的整数类型90\n7.1.2 整数常量90\n7.1.3 C99中的整数常量91\n7.1.4 整数溢出91\n7.1.5 读\/写整数91\n程序数列求和（改进版）92\n7.2 浮点类型93\n7.2.1 浮点常量94\n7.2.2 读\/写浮点数94\n7.3 字符类型94\n7.3.1 字符操作95\n7.3.2 有符号字符和无符号字符95\n7.3.3 算术类型96\n7.3.4 转义序列96\n7.3.5 字符处理函数97\n7.3.6 用scanf和printf读\/写字符98\n7.3.7 用getchar和putchar读\/写字符98\n程序确定消息的长度99\n7.4 类型转换100\n7.4.1 常用算术转换101\n7.4.2 赋值过程中的转换102\n7.4.3 C99中的隐式转换103\n7.4.4 强制类型转换103\n7.5 类型定义105\n7.5.1 类型定义的优点105\n7.5.2 类型定义和可移植性105\n7.6 sizeof运算符106\n问与答107\n练习题109\n编程题110\n第8章 数组113\n8.1 一维数组113\n8.1.1 数组下标113\n程序数列反向115\n8.1.2 数组初始化115\n8.1.3 指定初始化式116\n程序检查数中重复出现的数字116\n8.1.4 对数组使用sizeof运算符117\n程序计算利息118\n8.2 多维数组119\n8.2.1 多维数组初始化120\n8.2.2 常量数组121\n程序发牌121\n8.3 C99中的变长数组122\n问与答123\n练习题124\n编程题125\n第9章 函数129\n9.1 函数的定义和调用129\n程序计算平均值129\n程序显示倒计数130\n程序显示双关语（改进版）131\n9.1.1 函数定义132\n9.1.2 函数调用133\n程序判定素数134\n9.2 函数声明135\n9.3 实际参数136\n9.3.1 实际参数的转换137\n9.3.2 数组型实际参数138\n9.3.3 变长数组形式参数140\n9.3.4 在数组参数声明中使用static141\n9.3.5 复合字面量141\n9.4 return语句142\n9.5 程序终止143\n9.6 递归144\n程序快速排序146\n问与答147\n练习题150\n编程题153\n第10章 程序结构155\n10.1 局部变量155\n10.1.1 静态局部变量156\n10.1.2 形式参数156\n10.2 外部变量156\n10.2.1 示例：用外部变量实现栈156\n10.2.2 外部变量的利与弊157\n程序猜数158\n10.3 程序块161\n10.4 作用域162\n10.5 构建C程序163\n程序给一手牌分类163\n问与答169\n练习题169\n编程题170\n第11章 指针172\n11.1 指针变量172\n11.2 取地址运算符和间接寻址运算符173\n11.2.1 取地址运算符173\n11.2.2 间接寻址运算符174\n11.3 指针赋值174\n11.4 指针作为参数176\n程序找出数组中的最大元素和最小元素177\n11.5 指针作为返回值179\n问与答180\n练习题181\n编程题182\n第12章 指针和数组184\n12.1 指针的算术运算184\n12.1.1 指针加上整数185\n12.1.2 指针减去整数185\n12.1.3 两个指针相减186\n12.1.4 指针比较186\n12.1.5 指向复合常量的指针186\n12.2 指针用于数组处理186\n12.3 用数组名作为指针188程序数列反向（改进版）189\n12.3.1 数组型实际参数（改进版）189\n12.3.2 用指针作为数组名191\n12.4 指针和多维数组191\n12.4.1 处理多维数组的元素191\n12.4.2 处理多维数组的行192\n12.4.3 处理多维数组的列192\n12.4.4 用多维数组名作为指针192\n12.5 C99中的指针和变长数组193\n问与答194\n练习题195\n编程题197\n第13章 字符串198\n13.1 字符串字面量198\n13.1.1 字符串字面量中的转义序列198\n13.1.2 延续字符串字面量199\n13.1.3 如何存储字符串字面量199\n13.1.4 字符串字面量的操作200\n13.1.5 字符串字面量与字符常量200\n13.2 字符串变量200\n13.2.1 初始化字符串变量201\n13.2.2 字符数组与字符指针202\n13.3 字符串的读和写203\n13.3.1 用printf函数和puts函数写字符串203\n13.3.2 用scanf函数和gets函数读字符串203\n13.3.3 逐个字符读字符串204\n13.4 访问字符串中的字符205\n13.5 使用C语言的字符串库206\n13.5.1 strcpy函数207\n13.5.2 strlen函数208\n13.5.3 strcat函数208\n13.5.4 strcmp函数209程序显示一个月的提醒列表209\n13.6 字符串惯用法211\n13.6.1 搜索字符串的结尾211\n13.6.2 复制字符串213\n13.7 字符串数组214\n程序核对行星的名字217\n问与答218\n练习题220\n编程题222\n第14章 预处理器225\n14.1 预处理器的工作原理225\n14.2 预处理指令227\n14.3 宏定义227\n14.3.1 简单的宏227\n14.3.2 带参数的宏229\n14.3.3 #运算符231\n14.3.4 ##运算符231\n14.3.5 宏的通用属性232\n14.3.6 宏定义中的圆括号233\n14.3.7 创建较长的宏233\n14.3.8 预定义宏234\n14.3.9 C99中新增的预定义宏235\n14.3.10 空的宏参数236\n14.3.11 参数个数可变的宏236\n14.3.12 __func__标识符237\n14.4 条件编译237\n14.4.1 #if指令和#endif指令238\n14.4.2 defined运算符238\n14.4.3 #ifdef指令和#ifndef指令239\n14.4.4 #elif指令和#else指令239\n14.4.5 使用条件编译240\n14.5 其他指令240\n14.5.1 #error指令240\n14.5.2 #line指令241\n14.5.3 #pragma指令242\n14.5.4 _Pragma运算符242\n问与答243\n练习题245\n第15章 编写大型程序248\n15.1 源文件248\n15.2 头文件249\n15.2.1 #include指令249\n15.2.2 共享宏定义和类型定义250\n15.2.3 共享函数原型251\n15.2.4 共享变量声明252\n15.2.5 嵌套包含253\n15.2.6 保护头文件253\n15.2.7 头文件中的#error指令254\n15.3 把程序划分成多个文件254程序文本格式化255\n15.4 构建多文件程序260\n15.4.1 makefile260\n15.4.2 链接期间的错误262\n15.4.3 重新构建程序262\n15.4.4 在程序外定义宏264\n问与答264\n练习题265\n编程题266\n第16章 结构、联合和枚举267\n16.1 结构变量267\n16.1.1 结构变量的声明267\n16.1.2 结构变量的初始化269\n16.1.3 指定初始化269\n16.1.4 对结构的操作270\n16.2 结构类型270\n16.2.1 结构标记的声明271\n16.2.2 结构类型的定义272\n16.2.3 结构作为参数和返回值272\n16.2.4 复合字面量273\n16.3 嵌套的数组和结构274\n16.3.1 嵌套的结构274\n16.3.2 结构数组274\n16.3.3 结构数组的初始化275程序维护零件数据库275\n16.4 联合281\n16.4.1 用联合来节省空间282\n16.4.2 用联合来构造混合的数据结构284\n16.4.3 为联合添加“标记字段”284\n16.5 枚举285\n16.5.1 枚举标记和类型名286\n16.5.2 枚举作为整数286\n16.5.3 用枚举声明“标记字段”286\n问与答287\n练习题289\n编程题293\n第17章 指针的高级应用294\n17.1 动态存储分配294\n17.1.1 内存分配函数294\n17.1.2 空指针295\n17.2 动态分配字符串296\n……\n第18章 声明 327\n第19章 程序设计 345\n第20章 底层程序设计 363\n第21章 标准库 377\n第22章 输入\/输出 384\n第23章 库对数值和字符数据的支持 419\n第24章 错误处理 446\n第25章 国际化特性 456\n第26章 其他库函数 482\n第27章 C99对数学计算的新增支持 503\n附录A C语言运算符 524\n附录B C99与C89的比较 525\n附录C C89与经典C的比较 529\n附录D 标准库函数 532\n附录E ASCII字符集 569\n参考文献 570\n索引 573","pages":"600","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s4171870.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s4171870.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s4171870.jpg"},"alt":"https:\/\/book.douban.com\/subject\/4279678\/","id":"4279678","publisher":"人民邮电出版社","isbn10":"7115219575","isbn13":"9787115219572","title":"C语言程序设计","url":"https:\/\/api.douban.com\/v2\/book\/4279678","alt_title":"C Programming: A Modern Approach, Second Edition","author_intro":"K. N. King 世界知名的计算机程序设计教育家，现为佐治亚州立大学数学与计算机科学系副教授。他拥有耶鲁大学计算机科学硕士学位，加州大学伯克利分校计算机科学博士学位，曾任教于佐治亚理工学院。除本书外，他还撰写了广受欢迎的著作Modula-2: A Complete Guide 和Java Programming: From the Beginning，并在Dr.Dobb's Journal等权威杂志上发表了许多文章。\n吕秀锋，亚洲理工大学（AIT）计算机软件硕士，现为北京理工大学软件学院教师。多年来一直从事“计算机基础（双语）”、“C语言程序设计（双语）”以及“程序设计开发与实践”等本科生课程的教学工作，深受学生欢迎。她还译有《数据结构与算法：C＃语言描述》一书。\n黄倩，中国科学院计算技术研究所工学博士，中国计算机学会会员。研究方向包括视频处理、视频监控等，已在知名的国际期刊和国际会议论文集上发表10篇论文。译有《编程珠玑（第2版）》一书，受到读者欢迎。","summary":"时至今日， C语言仍然是计算机领域的通用语言之一，但今天的 C语言已经和最初的时候大不相同了。本书最主要的一个目的就是通过一种“现代方法”来介绍 C语言，书中强调标准 C，强调软件工程，不再强调“手工优化”。这一版中紧密结合了 C99标准，并与 C89标准进行对照，补充了 C99中的最新特性。本书分为 C语言的基础特性、 C语言的高级特性、 C语言标准库和参考资料 4个部分。每章末尾都有一个“问与答”小节给出一系列与该章内容相关的问题及答案，此外还包含适量的习题。\n本书是为大学本科阶段的 C语言课程编写的教材，同时也非常适合作为其他课程的辅助用书。","series":{"id":"50484","title":"图灵程序设计丛书·C\/C++系列"},"price":"79.00元"},{"rating":{"max":10,"numRaters":133,"average":"8.0","min":0},"subtitle":"C语言描述","author":["Kyle Loudon"],"pubdate":"2012-8","tags":[{"count":270,"name":"算法","title":"算法"},{"count":103,"name":"C语言","title":"C语言"},{"count":79,"name":"编程","title":"编程"},{"count":63,"name":"计算机","title":"计算机"},{"count":48,"name":"计算机科学","title":"计算机科学"},{"count":38,"name":"程序设计","title":"程序设计"},{"count":34,"name":"C","title":"C"},{"count":31,"name":"Programming","title":"Programming"}],"origin_title":"Mastering Algorithms with C","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s11351454.jpg","binding":"平装","translator":["肖翔","陈舸"],"catalog":"1. 前言\n2. 第1部分 预备知识\n3. 第1章 概述\n4. 数据结构简介\n5. 算法简介\n6. 小酌软件工程\n7. 如何使用本书\n8. 第2章 指针操作\n9. 指针基础\n10. 存储空间分配\n11. 数据集合与指针的算术运算\n12. 作为函数参数的指针\n13. 泛型指针与类型转换\n14. 函数指针\n15. 问与答\n16. 相关主题\n17. 第3章 递归\n18. 基本递归\n19. 尾递归\n20. 问与答\n21. 相关主题\n22. 第4章 算法分析\n23. 最坏情况分析\n24. O表示法\n25. 计算的复杂度\n26. 实例分析：插入排序\n27. 问与答\n28. 相关主题\n29. 第2部分 数据结构\n30. 第5章 链表\n31. 单链表介绍\n32. 单链表接口的定义\n33. 单链表的实现与分析\n34. 使用链表的例子：页帧管理\n35. 双向链表介绍\n36. 双向链表接口的定义\n37. 双向链表的实现与分析\n38. 循环链表介绍\n39. 循环链表接口的定义\n40. 循环链表的实现与分析\n41. 使用循环链表的例子：第二次机会页面置换法\n42. 问与答\n43. 相关主题\n44. 第6章 栈和队列\n45. 栈的描述\n46. 栈的接口定义\n47. 栈的实现与分析\n48. 队列的描述\n49. 队列的接口定义\n50. 队列的实现与分析\n51. 队列示例：事件处理\n52. 问与答\n53. 相关主题\n54. 第7章 集合\n55. 集合介绍\n56. 集合的性质\n57. 集合接口的定义\n58. 集合抽象数据类型的实现和分析\n59. Set示例：集合覆盖\n60. 问与答\n61. 相关主题\n62. 第8章 哈希表\n63. 链式哈希表的描述\n64. 链式哈希表的接口定义\n65. 链式哈希表的实现与分析\n66. 链式哈希表的例子：符号表\n67. 开地址哈希表的描述\n68. 开地址哈希函数的接口定义\n69. 开地址哈希表的实现与分析\n70. 问与答\n71. 相关主题\n72. 第9章 树\n73. 二叉树介绍\n74. 二叉树的接口定义\n75. 二叉树的实现与分析\n76. 二叉树示例：表达式处理\n77. 二叉搜索树介绍\n78. 二叉搜索树的接口定义\n79. 二叉搜索树的实现与分析\n80. 问与答\n81. 相关主题\n82. 第10章 堆和优先队列\n83. 堆的描述\n84. 堆的接口定义\n85. 堆的实现与分析\n86. 优先队列的描述\n87. 优先队列的接口定义\n88. 优先队列的实现与分析\n89. 优先队列的示例：包裹分拣\n90. 问与答\n91. 相关主题\n92. 第11章 图\n93. 图的描述\n94. 图的接口定义\n95. 图的实现与分析\n96. 关于图的应用举例：计算网络跳数\n97. 关于图的应用举例：拓扑排序\n98. 问与答\n99. 相关主题\n100. 第3部分 算法\n101. 第12章 排序和搜索\n102. 插入排序的描述\n103. 插入排序的接口定义\n104. 插入排序的实现与分析\n105. 快速排序的描述\n106. 快速排序的接口定义\n107. 快速排序的实现与分析\n108. 快速排序的例子：目录列表\n109. 归并排序的描述\n110. 归并排序的接口定义\n111. 归并排序的实现与分析\n112. 计数排序的描述\n113. 计数排序的接口定义\n114. 计数排序的实现与分析\n115. 基数排序的描述\n116. 基数排序的接口定义\n117. 基数排序的实现与分析\n118. 二分查找的描述\n119. 二分查找的接口定义\n120. 二分查找的实现与分析\n121. 二分查找的例子：拼写检查器\n122. 问与答\n123. 相关主题\n124. 第13章 数值计算\n125. 多项式插值法\n126. 多项式插值的接口定义\n127. 多项式插值的实现与分析\n128. 最小二乘估计法\n129. 最小二乘估计的接口定义\n130. 最小二乘估计的实现和分析\n131. 方程求解介绍\n132. 方程求解的接口定义\n133. 方程求解的实现与分析\n134. 问与答\n135. 相关主题\n136. 第14章 数据压缩\n137. 位操作的描述\n138. 位操作的接口定义\n139. 位操作的实现与分析\n140. 霍夫曼编码的描述\n141. 霍夫曼编码的接口定义\n142. 霍夫曼编码的分析与实现\n143. 霍夫曼编码的例子：网络优化\n144. LZ77的描述\n145. LZ77的接口定义\n146. LZ77的实现与分析\n147. 问与答\n148. 相关主题\n149. 第15章 数据加密\n150. DES算法介绍\n151. DES的接口定义\n152. DES算法的实现和分析\n153. DES应用举例：分组加密模式\n154. RSA算法介绍\n155. RSA的接口定义\n156. RSA算法的实现与分析\n157. 问与答\n158. 相关主题\n159. 第16章 图算法\n160. 最小生成树的描述\n161. 最小生成树的接口定义\n162. 最小生成树的实现与分析\n163. 最短路径的描述\n164. 最短路径的接口定义\n165. 最短路径的实现与分析\n166. 最短路径的例子：路由表\n167. 旅行商问题的描述\n168. 旅行商问题的接口定义\n169. 旅行商问题的实现与分析\n170. 问与答\n171. 相关主题\n172. 第17章 几何算法\n173. 测试线段是否相交\n174. 测试线段是否相交的标准方法\n175. 检测线段是否相交的接口定义\n176. 检测线段是否相交的实现与分析\n177. 凸包简介\n178. Jarvis’s March\n179. 凸包的接口定义\n180. 凸包的实现与分析\n181. 球面弧长\n182. 求解球面弧长的接口定义\n183. 求解球面弧长的实现和分析\n184. 球面弧长的应用举例：地球上两点之间的近似距离\n185. 问与答\n186. 相关主题","pages":"401","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s11351454.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s11351454.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s11351454.jpg"},"alt":"https:\/\/book.douban.com\/subject\/14267904\/","id":"14267904","publisher":"机械工业出版社","isbn10":"7111394267","isbn13":"9787111394266","title":"算法精解","url":"https:\/\/api.douban.com\/v2\/book\/14267904","alt_title":"Mastering Algorithms with C","author_intro":"Kyle Loudon是美国加州洛斯加托斯Jeppesen Dataplan公司的一名软件工程师，主管图形接口开发小组，主攻航迹规划软件的研发，这些软件主要用于商业航空公司、私营航空部门和其他一些航空制造业。在来到Jeppesen之前，Kyle在IBM公司是一名系统程序员。在技术上，Kyle主要对操作系统、网络、人机交互等领域感兴趣。1992年，Kyle在普渡大学拿到了计算机科学学士学位，并取得了法语的第二学位，同时他还被选入斐陶斐荣誉学会（美国大学优等生之荣誉学会）。他在普渡大学计算机系教了三年的计算机课程。在这期间，他完成了他个人的第一本书《Understanding Computers》，这本书用理论结合实践的方式介绍计算机的方方面面。如今，尽管他继续工作在硅谷的软件业，但他仍然坚韧不拔地在追求一个更高的学位。\n除了计算机，Kyle多年来喜欢打网球、教网球。他还喜欢山地骑行、滑冰，偶尔也和朋友们一起参加高尔夫课程。另外，Kyle还喜欢各种形式的戏剧、美食，以及某些风格的音乐和艺术；他期望成为钢琴家和艺术家，但希望渺茫。他现在在Jeppesen的工作是从他1992年开始驾驶飞机之后找到的。现在，他是一个拥有美国联邦航空局颁发的商业飞行员执照的飞行员。","summary":"本书是数据结构和算法领域的经典之作，十余年来，畅销不衰！全书共分为三部分：第一部分首先介绍了数据结构和算法的概念，以及使用它们的原因和意义，然后讲解了数据结构和算法中最常用的技术——指针和递归，最后还介绍了算法的分析方法，旨在为读者学习这本书打下坚实的基础；第二部分对链表、栈、队列、集合、哈希表、堆、图等常用数据结构进行了深入阐述；第三部分对排序、搜索数值计算、数据压缩、数据加密、图算法、几何算法等经典算法进行了精辟的分析和讲解。\n本书的众多特色使得它在同类书中独树一帜：具体实现都采用正式的C语言代码而不是伪代码，在很多数据结构和算法的实现过程中，有大量细节问题是伪代码不能解决的；每一章都有精心组织的主题和应用；全部示例来自真实的应用，不只是一般的练习；对每种数据结构、算法和示例都进行了详细分析；每一章的末尾都会有一系列问题和对应的回答，旨在强调这一章的重要思想……\n本书中的代码尤为值得强调：所有实现都采用C语言编写，所有代码都优先用于教学目的，所有代码都在4种平台上经过完整测试，头文件记录了所有公共的接口，命名规则适用于全书所有的代码，所有的代码都包含大量注释……\n本书内容包括：\n· 数据结构和算法的概念，以及使用它们的原因和意义\n· 指针和递归\n· 算法分析\n· 常用数据结构：链表、栈、队列、集合、哈希表、树、堆、优先级队列以及图\n· 排序和搜索\n· 数值计算\n· 数据压缩\n· 数据加密\n· 图算法\n· 几何算法","price":"79.00元"},{"rating":{"max":10,"numRaters":266,"average":"9.4","min":0},"subtitle":"42 Specific Ways to Improve Your Use of C++11 and C++14","author":["Scott Meyers"],"pubdate":"2014-12","tags":[{"count":330,"name":"C++","title":"C++"},{"count":168,"name":"C++11","title":"C++11"},{"count":111,"name":"C\/C++","title":"C\/C++"},{"count":86,"name":"编程","title":"编程"},{"count":80,"name":"计算机","title":"计算机"},{"count":72,"name":"Programming","title":"Programming"},{"count":49,"name":"程序设计","title":"程序设计"},{"count":34,"name":"effective","title":"effective"}],"origin_title":"","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s27951196.jpg","binding":"Paperback","translator":[],"catalog":"","pages":"320","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s27951196.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s27951196.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s27951196.jpg"},"alt":"https:\/\/book.douban.com\/subject\/25923597\/","id":"25923597","publisher":"O'Reilly Media","isbn10":"1491903996","isbn13":"9781491903995","title":"Effective Modern C++","url":"https:\/\/api.douban.com\/v2\/book\/25923597","alt_title":"","author_intro":"Scott Meyers is one of the world's foremost authorities on C++. He wrote the best-selling Effective C++ series (Effective C++, More Effective C++, and Effective STL); published and maintains the annotated training materials Overview of the New C++ (C++11\/14) and Effective C++ in an Embedded Environment; is Consulting Editor for the Effective Software Development Series, and, with Herb Sutter and Andrei Alexandrescu, is a principal in C++ and Beyond. He has a Ph.D in Computer Science from Brown University. He's currently working on a new book, Effective Modern C++, which he expects to publish this fall.","summary":"Learn how to program expertly with C++ with this practical book from Scott Meyers, one of the world's foremost authorities on this systems programming language. Scott Meyers takes some of the most difficult pieces of C++ code and unfurls them so that you can see how to manipulate your own project code. This is the first book to contain content written with the C++14 standard.\nTackle 42 separate C++ problems and solutions\nLearn critical techniques for success on topics from smart pointers to lambda expressions\nUnderstand key concepts by taking the C++ 98 standard to C++ 11 and then to C++ 14","price":"USD 49.99"},{"rating":{"max":10,"numRaters":625,"average":"9.1","min":0},"subtitle":"N．C. Wyeth 插图官方授权版本","author":["[美] 玛•金•罗琳斯"],"pubdate":"2016-6-1","tags":[{"count":198,"name":"自然","title":"自然"},{"count":183,"name":"美国文学","title":"美国文学"},{"count":183,"name":"外国文学","title":"外国文学"},{"count":146,"name":"玛•金•罗琳斯","title":"玛•金•罗琳斯"},{"count":136,"name":"美国","title":"美国"},{"count":135,"name":"成长","title":"成长"},{"count":129,"name":"我想读这本书","title":"我想读这本书"},{"count":128,"name":"小说","title":"小说"}],"origin_title":"The Yearling","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28748579.jpg","binding":"平装","translator":["梅静"],"catalog":"目录\n第一章 小水车\n第二章 乔迪的家\n第三章 飞来横祸\n第四章 猎熊\n第五章 草翅膀\n第六章 大快朵颐\n第七章 一桩好买卖\n第八章 意外收获\n第九章 灰岩坑\n第十章 夜晚的奇遇\n第十一章 猎鹿\n第十二章 仗义相助\n第十三章 告别奥利弗\n第十四章 危机\n第十五章 新伙伴\n第十六章 偷蜜和猎狐\n第十七章 痛失好友\n第十八章 怀念“草翅膀”\n第十九章 暴风雨\n第二十章 暴风雨后的森林\n第二十一章 瘟疫\n第二十二章 储粮\n第二十三章 狼群的夜袭\n第二十四章 猎狼\n第二十五章圣诞节前夕\n第二十六章 追捕“大笨脚”\n第二十七章 送别\n第二十八章 孤狼\n第二十九章 闯祸\n第三十章 爸爸病了\n第三十一章 无计可施\n第三十二章 再见，小鹿\n第三十三章 别了，童年","ebook_url":"https:\/\/read.douban.com\/ebook\/22165742\/","pages":"432","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s28748579.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s28748579.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28748579.jpg"},"alt":"https:\/\/book.douban.com\/subject\/26801361\/","id":"26801361","publisher":"云南人民出版社","isbn10":"7222145583","isbn13":"9787222145580","title":"鹿苑长春","url":"https:\/\/api.douban.com\/v2\/book\/26801361","alt_title":"The Yearling","author_intro":"【作者 】\n玛•金•罗琳斯\nMarjorie Kinnan Rawlings\n1896-1953\n美国作家  生于华盛顿， 毕业于威斯康星大学， 在纽约担任多年记者、编辑\n创建了佛罗里达边远林区的“地方文学”\n先后获得普利策奖、 欧·亨利奖、兰登书屋终身畅销奖\n创作的两部长篇小说《鹿苑长春》和《十字小溪》先后荣获普利策文学奖\n代表作《鹿苑长春》《十字小溪》《一位年轻姑娘》《南方月亮下》《金苹果》等\n【绘者】\nN.C.韦思\nNewell Convers Wyeth\n1882—1956\n美国现实主义绘画大师  一生创作近4000幅画作\n画作现收藏于布兰迪万河博物馆 、波特兰艺术博物馆和法恩斯沃斯艺术博物馆。1997年，他生活和工作的地方（宾夕法尼亚州查兹福德小镇墨菲路）被美国政府指定为国家历史地标之一。\n【译者】\n梅静\n北京大学外国语学院翻译硕士\n译有《柳林风声》《小鹿斑比》《小公主》《威士忌海滩》《孪生姐妹》《想飞的乔琪》《布谷鸟的呼唤》。","summary":"【“任何人遇到挫折的时候，都能够从这里得到新的勇气。”】\n【内容简介】\n《鹿苑长春》由美国作家玛·金·罗琳斯创作于1938年，根据佛罗里达林区一位老人的童年回忆创作改编，发行后登上美国畅销书榜首并持续140周，于次年获得普利策文学奖。至今，在美国累计阅读量达到5.5亿。至今，该小说被翻译成20种语言，在133个国家出版，受到不同地域和文化人们的喜爱。在1946年被米高梅公司拍摄成电影，获得奥斯卡最佳艺术指导奖和最佳摄影奖。\n故事讲述美国南北战争后佛罗里达垦荒区普通人的劳动、斗争和悲欢离合。主人公巴克斯特一家生活在佛罗里达岛地过着自给自足的农耕狩猎生活，所处的自然美景中是一幅生动绚丽的丛林画卷，该作品后被誉为描绘少年时代的经典童年诗歌。然而，它却是一本全年龄段读本，书中透出的森林清新气息和舒缓节奏，与当代都市生活迥然不同。其中有惊险的狩猎、奇妙的自然景观、悠然的乡村美景，还有风趣幽默的人物对话，以及充满泥土气息的方言。书中人们为了生存这一简单目的，持有着最质朴的勇气和信念。\n孩子们可以从书中读到激动人心的狩猎，看见原野林莽、飞鸟起落、狼踪熊迹、暴雨狂风，进入乔迪的世界，与他共度被爸爸精心呵护、无忧无虑的童年。成年人，尤其是经历过离合悲欢、人世艰难的人，都能从书中读出欢笑、甜蜜、惆怅和感伤。\n【编辑推荐】\n《鹿苑长春》是一部经典的动物文学与环境文学著作。\n故事发生在美国南北战争结束后的垦荒时代，讲述与父母生活在佛罗里达岛地的男孩乔迪与一岁小鹿间的故事。\n爸爸在牧师家庭长大，正直善良，从不说谎，因经历战争后，厌倦了与人相处的世俗，带着妻子奥拉远离城镇，选择佛罗里达的巴克斯特岛地，过着狩猎农耕的生活。家中的生计依赖于自然选择，时常受到岛地周围野兽的威胁，尤其是经常出没偷食家畜的棕熊“大笨脚”。\n因为自然环境的严酷，夫妻两人连续夭折了3个孩子，以至于乔迪诞生后，妈妈奥拉因为遭遇太多次失去，对儿子不抱有太多疼爱，也许是向现实的冷酷低头，看待事物抱有异常冷漠的清醒。爸爸彭尼从小在家中担起大梁，了解天真无邪的珍贵，反而给乔迪加倍的疼爱，试图延长乔迪无忧无虑的童年。在丛林里，有变幻的迷人风光，也有让人惊叹的动物奇观。乔迪一直喜欢听猎人讲在狩猎途中的奇遇，期待着自己与动物的亲近。\n他跟着爸爸狩猎，追踪“大笨脚”，爬在树上看鹿妈妈带着小鹿啃食树叶，与爸爸抓到罕见的白色浣熊、在克拉克莎草丛中钓鱼，遇到高鸣鹤跳沙龙舞；他跟着巴克.福利斯特在月光下的玉米地里猎狐，去松树干掏蜂蜜；与好友“草翅膀”喂养小浣熊、欧洲灰雀，一起看西班牙人后裔穿过古栈道，一起数天上米诺鱼般的星星……生活就像他给自己在灰岩坑水塘边造的小水车，随着时间的流水，悠然转动，奏出欢快的乐章，似乎没有停下来的理由。\n然而乔迪作为独子，在偏远岛地，一直是孤寂的。他希望能像爸爸彭尼一样拥有只对自己忠诚的宠物。因为口粮不足，妈妈却一直拒绝驯养动物。直到有一天，在乔迪跟随爸爸追踪走失家猪的途中，遭遇危机，也遇到了那头刚出生不久的小鹿……\n故事讲失去，也讲成长；讲孤独，也讲爱与宽容。每个人也许会从中找到真挚的共鸣，遗憾和怅惘，但更多的是，是勇气。\n【名人推荐】\n“谈到近人的作品，说「不朽」总彷佛还太早，然而《鹿苑长春》在近代文学上的地位已经奠定了。《鹿苑长春》里面出现的动物比人多──鹿、响尾蛇、八字脚的老熊、牛、马、猪──像一个动物园，但是里面的人物，尤其是那男孩子乔迪，是使人永远不能忘记的。\n那孩子失去了他最心爱的东西，使他受到很深的刺激，然而他从此就坚强起来，长大成人了。我们仔细回味，就可以觉得这不止于是一个孩子的故事，任何人遇到挫折的时候，都能够从这里得到新的勇气。\n这故事具有真正的悲剧的因素──无法避免，也不可挽回。书中对于儿童心理有非常深入的描写，可以帮助做父母的人了解自己的子女。写父爱也发掘到人性的深处。\n它是健康的，向上的，但也许它最动人的地方是与东方的心情特别接近的一种淡淡的哀愁。最后的两段更是充满了一种难堪的怅惘，我译到这里的时候，甚至于译完之后重抄一遍，抄到这里的时候，也都是像第一次读到一样地觉得非常感动，眼睛湿润起来。我相信许多读者一定也有同感。”\n——张爱玲\n【媒体推荐】\n\n在罗琳斯女士之前，还没有谁创造出如此栩栩如生且亲近读者的一系列形象，其亲密的感情感染人，不禁令人产生共鸣。\n——纽约时报\n“Never before has Mrs. Rawlings created a set of characters who are so close and real to the reader, whose intimate life one can share without the taint of unconscious patronage.\" (The New York Times)\n惊心动魄的探险和令人怅惘的人性元素……这是一部不愧于普利策奖桂冠的经典作品，故事质朴的语言和四季变化下的生态智慧，都给予这本书一种独特而难忘的气质。而画家N.C.韦思也以温暖、柔和的插图，恰到好处地捕捉到那个垦荒时代的粗莽和淳美。\n——亚马逊网站\n“Heart-stopping adventure and heart-wrenching human element…. This is a classic well worth its Pulitzer Prize. Earthy dialect and homespun wisdom season the story, giving it a unique and unforgettable flavor, and N.C. Wyeth's warm, soft illustrations capture an era of rough subsistence and sweet survival.”\n(Amazon.com)","ebook_price":"12.00","price":"48.00元"},{"rating":{"max":10,"numRaters":531,"average":"8.9","min":0},"subtitle":"使用Visual C++5.0 & MFC 4.2","author":["侯俊杰"],"pubdate":"2001-1","tags":[{"count":303,"name":"MFC","title":"MFC"},{"count":174,"name":"C++","title":"C++"},{"count":108,"name":"计算机","title":"计算机"},{"count":92,"name":"编程","title":"编程"},{"count":74,"name":"深入浅出MFC","title":"深入浅出MFC"},{"count":72,"name":"侯捷","title":"侯捷"},{"count":64,"name":"Windows","title":"Windows"},{"count":38,"name":"经典","title":"经典"}],"origin_title":"","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28952279.jpg","binding":"平装16开","translator":[],"catalog":"第一篇 勿在浮砂筑高台\n第一章 Win32 程序基本概念\n第二章 C++的重要性质\n第三章 MFC六大关键技术之仿真\n第二篇 欲善工事先利其器\n第四章 Visual C++ 集成开发环境\n第三篇 浅出MFC程序设计\n第五章 总观Application Framework\n第六章 MFC程序的生死因果\n第七章 简单而完整：MFC骨干程序\n第四篇 深入MFC 程序设计\n第八章 Document-View深入探讨\n第九章 消息映射与命令传递\n第十章 MFC与对话框\n第十一章 Vies功能的加强与重绘效率的提高\n第十二章 打印与预览\n第十三章 多重文件与多重视图\n第十四章 MFC 多线程程序设计\n第十五章 站在众人的肩膀――使用Components & ActiveX Controls\n第五篇 附录","pages":"701","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s28952279.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s28952279.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28952279.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1094852\/","id":"1094852","publisher":"华中科技大学出版社","isbn10":"7900614931","isbn13":"9787900614933","title":"深入浅出MFC （第二版）","url":"https:\/\/api.douban.com\/v2\/book\/1094852","alt_title":"","author_intro":"侯俊杰（1961年9月28日－），笔名侯捷，台湾知名电脑技术专栏作家，致力于电脑技术之扎根工作，文章兼具科技之长与灵性之美，有读者的评语是“比作家更工程师，比工程师更作家”。大同国中、师大附中、交通大学土木系毕业、清华大学动力机械研究所硕士。曾任职工研院机械所与电通所，曾在元智大学授课，近年来多从事两岸学术交流工作。他的妻子美静是一名钢琴师，侯俊杰说他自己“嗜咖啡。妻严不能常得。”","summary":"《深入浅出MFC》分为四大篇。第一篇提出学习MFC程序设计之前的必要基础，包括Widnows程序的基本观念以及C++的高阶议题。“学前基础”是相当主观的认定，但作者是甚于自己的学习经验以及教学经验，其挑选应该颇具说服力。第二篇介绍Visual C++整合环境开发工具。此篇只是提纲挈领，并不企图取代Visual C++使用手册；然而对于软件使用的老手，此篇或已足以帮助掌握Visual C++整合环境。工具的使用虽然谈不上学问，但在视觉化软件开发过程中扮演极重角色。第三篇介绍application framework的观念，以及MFC骨干程序，所谓骨干程序，是指Visual C++的工具AppWizard所产生出来的程序码。当然，AppWizard会根据使用者的选项做出不同的程序码，作者据以解说的是大众化选项下的产品。第四篇以微软公司附于Visual C++光碟片上的一个范例程序Scribble为主轴，一步一步加上新的功能；并在其间深入介绍Runtime Type Information（RTTI）、Dynamic Creation、Persistence（Serialization）、Message Mapping、Command Routing等核心技术。这些技术正是其他专著最缺乏的部分。此篇的最后数章则脱离Scribble程序，另成一格。\n这本书配有一片光盘，书中所有原始码与可执行文件都在其中。","price":"80.00元"},{"rating":{"max":10,"numRaters":457,"average":"8.8","min":0},"subtitle":"使用muduo C++网络库","author":["陈硕"],"pubdate":"2013-1-15","tags":[{"count":607,"name":"网络编程","title":"网络编程"},{"count":543,"name":"Linux","title":"Linux"},{"count":541,"name":"C++","title":"C++"},{"count":454,"name":"多线程","title":"多线程"},{"count":155,"name":"计算机","title":"计算机"},{"count":143,"name":"编程","title":"编程"},{"count":110,"name":"C\/C++","title":"C\/C++"},{"count":87,"name":"Networks","title":"Networks"}],"origin_title":"","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s24522799.jpg","binding":"平装","translator":[],"catalog":"第1 部分C++ 多线程系统编程1\n第1章 线程安全的对象生命期管理3\n1.1 当析构函数遇到多线程. . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n1.1.1 线程安全的定义. . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\n1.1.2 MutexLock 与MutexLockGuard . . . . . . . . . . . . . . . . . . . . 4\n1.1.3 一个线程安全的Counter 示例. . . . . . . . . . . . . . . . . . . . 4\n1.2 对象的创建很简单. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n1.3 销毁太难. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n1.3.1 mutex 不是办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n1.3.2 作为数据成员的mutex 不能保护析构. . . . . . . . . . . . . . . 8\n1.4 线程安全的Observer 有多难. . . . . . . . . . . . . . . . . . . . . . . . . 8\n1.5 原始指针有何不妥. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n1.6 神器shared_ptr\/weak_ptr . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n1.7 插曲：系统地避免各种指针错误. . . . . . . . . . . . . . . . . . . . . . . 14\n1.8 应用到Observer 上. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\n1.9 再论shared_ptr 的线程安全. . . . . . . . . . . . . . . . . . . . . . . . . 17\n1.10 shared_ptr 技术与陷阱. . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n1.11 对象池. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21\n1.11.1 enable_shared_from_this . . . . . . . . . . . . . . . . . . . . . . 23\n1.11.2 弱回调. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\n1.12 替代方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n1.13 心得与小结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n1.14 Observer 之谬. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\n第2章 线程同步精要31\n2.1 互斥器（mutex） . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32\n2.1.1 只使用非递归的mutex . . . . . . . . . . . . . . . . . . . . . . . . 33\n2.1.2 死锁. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\n2.2 条件变量（condition variable） . . . . . . . . . . . . . . . . . . . . . . . 40\n2.3 不要用读写锁和信号量. . . . . . . . . . . . . . . . . . . . . . . . . . . . 43\n2.4 封装MutexLock、MutexLockGuard、Condition . . . . . . . . . . . . . . 44\n2.5 线程安全的Singleton 实现. . . . . . . . . . . . . . . . . . . . . . . . . . 48\n2.6 sleep(3) 不是同步原语. . . . . . . . . . . . . . . . . . . . . . . . . . . . 50\n2.7 归纳与总结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\n2.8 借shared_ptr 实现copy-on-write . . . . . . . . . . . . . . . . . . . . . . 52\n第3章 多线程服务器的适用场合与常用编程模型59\n3.1 进程与线程. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59\n3.2 单线程服务器的常用编程模型. . . . . . . . . . . . . . . . . . . . . . . . 61\n3.3 多线程服务器的常用编程模型. . . . . . . . . . . . . . . . . . . . . . . . 62\n3.3.1 one loop per thread . . . . . . . . . . . . . . . . . . . . . . . . . . 62\n3.3.2 线程池. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63\n3.3.3 推荐模式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64\n3.4 进程间通信只用TCP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65\n3.5 多线程服务器的适用场合. . . . . . . . . . . . . . . . . . . . . . . . . . . 67\n3.5.1 必须用单线程的场合. . . . . . . . . . . . . . . . . . . . . . . . . 69\n3.5.2 单线程程序的优缺点. . . . . . . . . . . . . . . . . . . . . . . . . 70\n3.5.3 适用多线程程序的场景. . . . . . . . . . . . . . . . . . . . . . . . 71\n3.6 “多线程服务器的适用场合”例释与答疑. . . . . . . . . . . . . . . . . . 74\n第4章 C++ 多线程系统编程精要83\n4.1 基本线程原语的选用. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84\n4.2 C\/C++ 系统库的线程安全性. . . . . . . . . . . . . . . . . . . . . . . . . 85\n4.3 Linux 上的线程标识. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89\n4.4 线程的创建与销毁的守则. . . . . . . . . . . . . . . . . . . . . . . . . . . 91\n4.4.1 pthread_cancel 与C++ . . . . . . . . . . . . . . . . . . . . . . . 94\n4.4.2 exit(3) 在C++ 中不是线程安全的. . . . . . . . . . . . . . . . . 94\n4.5 善用__thread 关键字. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96\n4.6 多线程与IO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98\n4.7 用RAII 包装文件描述符. . . . . . . . . . . . . . . . . . . . . . . . . . . 99\n4.8 RAII 与fork() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101\n4.9 多线程与fork() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102\n4.10 多线程与signal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103\n4.11 Linux 新增系统调用的启示. . . . . . . . . . . . . . . . . . . . . . . . . . 105\n第5章 高效的多线程日志107\n5.1 功能需求. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109\n5.2 性能需求. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112\n5.3 多线程异步日志. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114\n5.4 其他方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120\n第2部分 muduo 网络库123\n第6章 muduo 网络库简介125\n6.1 由来. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125\n6.2 安装. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127\n6.3 目录结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129\n6.3.1 代码结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131\n6.3.2 例子. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134\n6.3.3 线程模型. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135\n6.4 使用教程. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136\n6.4.1 TCP 网络编程本质论. . . . . . . . . . . . . . . . . . . . . . . . . 136\n6.4.2 echo 服务的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . 138\n6.4.3 七步实现finger 服务. . . . . . . . . . . . . . . . . . . . . . . . . 140\n6.5 性能评测. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144\n6.5.1 muduo 与Boost.Asio、libevent2 的吞吐量对比. . . . . . . . . . 145\n6.5.2 击鼓传花：对比muduo 与libevent2 的事件处理效率. . . . . . 148\n6.5.3 muduo 与Nginx 的吞吐量对比. . . . . . . . . . . . . . . . . . . 153\n6.5.4 muduo 与ZeroMQ 的延迟对比. . . . . . . . . . . . . . . . . . . 156\n6.6 详解muduo 多线程模型. . . . . . . . . . . . . . . . . . . . . . . . . . . 157\n6.6.1 数独求解服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . . 157\n6.6.2 常见的并发网络服务程序设计方案. . . . . . . . . . . . . . . . . 160\n第7章 muduo 编程示例177\n7.1 五个简单TCP 示例. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178\n7.2 文件传输. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185\n7.3 Boost.Asio 的聊天服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . 194\n7.3.1 TCP 分包. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194\n7.3.2 消息格式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195\n7.3.3 编解码器LengthHeaderCodec . . . . . . . . . . . . . . . . . . . . 197\n7.3.4 服务端的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198\n7.3.5 客户端的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200\n7.4 muduo Buffer 类的设计与使用. . . . . . . . . . . . . . . . . . . . . . . 204\n7.4.1 muduo 的IO 模型. . . . . . . . . . . . . . . . . . . . . . . . . . 204\n7.4.2 为什么non-blocking 网络编程中应用层buffer 是必需的. . . . 205\n7.4.3 Buffer 的功能需求. . . . . . . . . . . . . . . . . . . . . . . . . . 207\n7.4.4 Buffer 的数据结构. . . . . . . . . . . . . . . . . . . . . . . . . . 209\n7.4.5 Buffer 的操作. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211\n7.4.6 其他设计方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217\n7.4.7 性能是不是问题. . . . . . . . . . . . . . . . . . . . . . . . . . . . 218\n7.5 一种自动反射消息类型的Google Protobuf 网络传输方案. . . . . . . . 220\n7.5.1 网络编程中使用Protobuf 的两个先决条件. . . . . . . . . . . . . 220\n7.5.2 根据type name 反射自动创建Message 对象. . . . . . . . . . . . 221\n7.5.3 Protobuf 传输格式. . . . . . . . . . . . . . . . . . . . . . . . . . 226\n7.6 在muduo 中实现Protobuf 编解码器与消息分发器. . . . . . . . . . . . 228\n7.6.1 什么是编解码器（codec） . . . . . . . . . . . . . . . . . . . . . . 229\n7.6.2 实现ProtobufCodec . . . . . . . . . . . . . . . . . . . . . . . . . 232\n7.6.3 消息分发器（dispatcher）有什么用. . . . . . . . . . . . . . . . 232\n7.6.4 ProtobufCodec 与ProtobufDispatcher 的综合运用. . . . . . . 233\n7.6.5 ProtobufDispatcher 的两种实现. . . . . . . . . . . . . . . . . . 234\n7.6.6 ProtobufCodec 和ProtobufDispatcher 有何意义. . . . . . . . . 236\n7.7 限制服务器的最大并发连接数. . . . . . . . . . . . . . . . . . . . . . . . 237\n7.7.1 为什么要限制并发连接数. . . . . . . . . . . . . . . . . . . . . . 237\n7.7.2 在muduo 中限制并发连接数. . . . . . . . . . . . . . . . . . . . 238\n7.8 定时器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240\n7.8.1 程序中的时间. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240\n7.8.2 Linux 时间函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . 241\n7.8.3 muduo 的定时器接口. . . . . . . . . . . . . . . . . . . . . . . . . 242\n7.8.4 Boost.Asio Timer 示例. . . . . . . . . . . . . . . . . . . . . . . . 243\n7.8.5 Java Netty 示例. . . . . . . . . . . . . . . . . . . . . . . . . . . . 245\n7.9 测量两台机器的网络延迟和时间差. . . . . . . . . . . . . . . . . . . . . 248\n7.10 用timing wheel 踢掉空闲连接. . . . . . . . . . . . . . . . . . . . . . . . 250\n7.10.1 timing wheel 原理. . . . . . . . . . . . . . . . . . . . . . . . . . 251\n7.10.2 代码实现与改进. . . . . . . . . . . . . . . . . . . . . . . . . . . . 254\n7.11 简单的消息广播服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257\n7.12 “串并转换”连接服务器及其自动化测试. . . . . . . . . . . . . . . . . . 260\n7.13 socks4a 代理服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264\n7.13.1 TCP 中继器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264\n7.13.2 socks4a 代理服务器. . . . . . . . . . . . . . . . . . . . . . . . . . 267\n7.13.3 N : 1 与1 : N 连接转发. . . . . . . . . . . . . . . . . . . . . . . . 267\n7.14 短址服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267\n7.15 与其他库集成. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268\n7.15.1 UDNS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270\n7.15.2 c-ares DNS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272\n7.15.3 curl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273\n7.15.4 更多. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275\n第8章 muduo 网络库设计与实现277\n8.0 什么都不做的EventLoop . . . . . . . . . . . . . . . . . . . . . . . . . . . 277\n8.1 Reactor 的关键结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280\n8.1.1 Channel class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280\n8.1.2 Poller class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283\n8.1.3 EventLoop 的改动. . . . . . . . . . . . . . . . . . . . . . . . . . . 287\n8.2 TimerQueue 定时器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290\n8.2.1 TimerQueue class . . . . . . . . . . . . . . . . . . . . . . . . . . . 290\n8.2.2 EventLoop 的改动. . . . . . . . . . . . . . . . . . . . . . . . . . . 292\n8.3 EventLoop::runInLoop() 函数. . . . . . . . . . . . . . . . . . . . . . . . 293\n8.3.1 提高TimerQueue 的线程安全性. . . . . . . . . . . . . . . . . . . 296\n8.3.2 EventLoopThread class . . . . . . . . . . . . . . . . . . . . . . . . 297\n8.4 实现TCP 网络库. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299\n8.5 TcpServer 接受新连接. . . . . . . . . . . . . . . . . . . . . . . . . . . . 303\n8.5.1 TcpServer class . . . . . . . . . . . . . . . . . . . . . . . . . . . . 304\n8.5.2 TcpConnection class . . . . . . . . . . . . . . . . . . . . . . . . . 305\n8.6 TcpConnection 断开连接. . . . . . . . . . . . . . . . . . . . . . . . . . . 308\n8.7 Buffer 读取数据. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 313\n8.7.1 TcpConnection 使用Buffer 作为输入缓冲. . . . . . . . . . . . . 314\n8.7.2 Buffer::readFd() . . . . . . . . . . . . . . . . . . . . . . . . . . 315\n8.8 TcpConnection 发送数据. . . . . . . . . . . . . . . . . . . . . . . . . . . 316\n8.9 完善TcpConnection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 320\n8.9.1 SIGPIPE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321\n8.9.2 TCP No Delay 和TCP keepalive . . . . . . . . . . . . . . . . . . 321\n8.9.3 WriteCompleteCallback 和HighWaterMarkCallback . . . . . . . 322\n8.10 多线程TcpServer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 324\n8.11 Connector . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327\n8.12 TcpClient . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 332\n8.13 epoll . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333\n8.14 测试程序一览. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 336\n第3部分 工程实践经验谈337\n第9章 分布式系统工程实践339\n9.1 我们在技术浪潮中的位置. . . . . . . . . . . . . . . . . . . . . . . . . . . 341\n9.1.1 分布式系统的本质困难. . . . . . . . . . . . . . . . . . . . . . . . 343\n9.1.2 分布式系统是个险恶的问题. . . . . . . . . . . . . . . . . . . . . 344\n9.2 分布式系统的可靠性浅说. . . . . . . . . . . . . . . . . . . . . . . . . . . 349\n9.2.1 分布式系统的软件不要求7  24 可靠. . . . . . . . . . . . . . . . 352\n9.2.2 “能随时重启进程”作为程序设计目标. . . . . . . . . . . . . . . 354\n9.3 分布式系统中心跳协议的设计. . . . . . . . . . . . . . . . . . . . . . . . 356\n9.4 分布式系统中的进程标识. . . . . . . . . . . . . . . . . . . . . . . . . . . 360\n9.4.1 错误做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361\n9.4.2 正确做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 362\n9.4.3 TCP 协议的启示. . . . . . . . . . . . . . . . . . . . . . . . . . . . 363\n9.5 构建易于维护的分布式程序. . . . . . . . . . . . . . . . . . . . . . . . . 364\n9.6 为系统演化做准备. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 367\n9.6.1 可扩展的消息格式. . . . . . . . . . . . . . . . . . . . . . . . . . 368\n9.6.2 反面教材：ICE 的消息打包格式. . . . . . . . . . . . . . . . . . . 369\n9.7 分布式程序的自动化回归测试. . . . . . . . . . . . . . . . . . . . . . . . 370\n9.7.1 单元测试的能与不能. . . . . . . . . . . . . . . . . . . . . . . . . 370\n9.7.2 分布式系统测试的要点. . . . . . . . . . . . . . . . . . . . . . . . 373\n9.7.3 分布式系统的抽象观点. . . . . . . . . . . . . . . . . . . . . . . . 374\n9.7.4 一种自动化的回归测试方案. . . . . . . . . . . . . . . . . . . . . 375\n9.7.5 其他用处. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 379\n9.8 分布式系统部署、监控与进程管理的几重境界. . . . . . . . . . . . . . . 380\n9.8.1 境界1：全手工操作. . . . . . . . . . . . . . . . . . . . . . . . . 382\n9.8.2 境界2：使用零散的自动化脚本和第三方组件. . . . . . . . . . . 383\n9.8.3 境界3：自制机群管理系统，集中化配置. . . . . . . . . . . . . 386\n9.8.4 境界4：机群管理与naming service 结合. . . . . . . . . . . . . 389\n第10章 C++ 编译链接模型精要391\n10.1 C 语言的编译模型及其成因. . . . . . . . . . . . . . . . . . . . . . . . . 394\n10.1.1 为什么C 语言需要预处理. . . . . . . . . . . . . . . . . . . . . . 395\n10.1.2 C 语言的编译模型. . . . . . . . . . . . . . . . . . . . . . . . . . . 398\n10.2 C++ 的编译模型. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399\n10.2.1 单遍编译. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399\n10.2.2 前向声明. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 402\n10.3 C++ 链接（linking） . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 404\n10.3.1 函数重载. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 406\n10.3.2 inline 函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 407\n10.3.3 模板. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 409\n10.3.4 虚函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 414\n10.4 工程项目中头文件的使用规则. . . . . . . . . . . . . . . . . . . . . . . . 415\n10.4.1 头文件的害处. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 416\n10.4.2 头文件的使用规则. . . . . . . . . . . . . . . . . . . . . . . . . . 417\n10.5 工程项目中库文件的组织原则. . . . . . . . . . . . . . . . . . . . . . . . 418\n10.5.1 动态库是有害的. . . . . . . . . . . . . . . . . . . . . . . . . . . . 423\n10.5.2 静态库也好不到哪儿去. . . . . . . . . . . . . . . . . . . . . . . . 424\n10.5.3 源码编译是王道. . . . . . . . . . . . . . . . . . . . . . . . . . . . 428\n第11章 反思C++ 面向对象与虚函数429\n11.1 朴实的C++ 设计. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 429\n11.2 程序库的二进制兼容性. . . . . . . . . . . . . . . . . . . . . . . . . . . . 431\n11.2.1 什么是二进制兼容性. . . . . . . . . . . . . . . . . . . . . . . . . 432\n11.2.2 有哪些情况会破坏库的ABI . . . . . . . . . . . . . . . . . . . . . 433\n11.2.3 哪些做法多半是安全的. . . . . . . . . . . . . . . . . . . . . . . . 435\n11.2.4 反面教材：COM . . . . . . . . . . . . . . . . . . . . . . . . . . . 435\n11.2.5 解决办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 436\n11.3 避免使用虚函数作为库的接口. . . . . . . . . . . . . . . . . . . . . . . . 436\n11.3.1 C++ 程序库的作者的生存环境. . . . . . . . . . . . . . . . . . . . 437\n11.3.2 虚函数作为库的接口的两大用途. . . . . . . . . . . . . . . . . . 438\n11.3.3 虚函数作为接口的弊端. . . . . . . . . . . . . . . . . . . . . . . . 439\n11.3.4 假如Linux 系统调用以COM 接口方式实现. . . . . . . . . . . . 442\n11.3.5 Java 是如何应对的. . . . . . . . . . . . . . . . . . . . . . . . . . 443\n11.4 动态库接口的推荐做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . 443\n11.5 以boost::function 和boost::bind 取代虚函数. . . . . . . . . . . . . 447\n11.5.1 基本用途. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 450\n11.5.2 对程序库的影响. . . . . . . . . . . . . . . . . . . . . . . . . . . . 451\n11.5.3 对面向对象程序设计的影响. . . . . . . . . . . . . . . . . . . . . 453\n11.6 iostream 的用途与局限. . . . . . . . . . . . . . . . . . . . . . . . . . . . 457\n11.6.1 stdio 格式化输入输出的缺点. . . . . . . . . . . . . . . . . . . . . 457\n11.6.2 iostream 的设计初衷. . . . . . . . . . . . . . . . . . . . . . . . . 461\n11.6.3 iostream 与标准库其他组件的交互. . . . . . . . . . . . . . . . . 463\n11.6.4 iostream 在使用方面的缺点. . . . . . . . . . . . . . . . . . . . . 464\n11.6.5 iostream 在设计方面的缺点. . . . . . . . . . . . . . . . . . . . . 468\n11.6.6 一个300 行的memory buffer output stream . . . . . . . . . . . 476\n11.6.7 现实的C++ 程序如何做文件IO . . . . . . . . . . . . . . . . . . . 480\n11.7 值语义与数据抽象. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482\n11.7.1 什么是值语义. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482\n11.7.2 值语义与生命期. . . . . . . . . . . . . . . . . . . . . . . . . . . . 483\n11.7.3 值语义与标准库. . . . . . . . . . . . . . . . . . . . . . . . . . . . 488\n11.7.4 值语义与C++ 语言. . . . . . . . . . . . . . . . . . . . . . . . . . 488\n11.7.5 什么是数据抽象. . . . . . . . . . . . . . . . . . . . . . . . . . . . 490\n11.7.6 数据抽象所需的语言设施. . . . . . . . . . . . . . . . . . . . . . 493\n11.7.7 数据抽象的例子. . . . . . . . . . . . . . . . . . . . . . . . . . . . 495\n第12章 C++ 经验谈501\n12.1 用异或来交换变量是错误的. . . . . . . . . . . . . . . . . . . . . . . . . 501\n12.1.1 编译器会分别生成什么代码. . . . . . . . . . . . . . . . . . . . . 503\n12.1.2 为什么短的代码不一定快. . . . . . . . . . . . . . . . . . . . . . 505\n12.2 不要重载全局::operator new() . . . . . . . . . . . . . . . . . . . . . . 507\n12.2.1 内存管理的基本要求. . . . . . . . . . . . . . . . . . . . . . . . . 507\n12.2.2 重载::operator new() 的理由. . . . . . . . . . . . . . . . . . . 508\n12.2.3 ::operator new() 的两种重载方式. . . . . . . . . . . . . . . . . 508\n12.2.4 现实的开发环境. . . . . . . . . . . . . . . . . . . . . . . . . . . . 509\n12.2.5 重载::operator new() 的困境. . . . . . . . . . . . . . . . . . . 510\n12.2.6 解决办法：替换malloc() . . . . . . . . . . . . . . . . . . . . . . 512\n12.2.7 为单独的class 重载::operator new() 有问题吗. . . . . . . . . 513\n12.2.8 有必要自行定制内存分配器吗. . . . . . . . . . . . . . . . . . . . 513\n12.3 带符号整数的除法与余数. . . . . . . . . . . . . . . . . . . . . . . . . . . 514\n12.3.1 语言标准怎么说. . . . . . . . . . . . . . . . . . . . . . . . . . . . 515\n12.3.2 C\/C++ 编译器的表现. . . . . . . . . . . . . . . . . . . . . . . . . 516\n12.3.3 其他语言的规定. . . . . . . . . . . . . . . . . . . . . . . . . . . . 516\n12.3.4 脚本语言解释器代码. . . . . . . . . . . . . . . . . . . . . . . . . 517\n12.3.5 硬件实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521\n12.4 在单元测试中mock 系统调用. . . . . . . . . . . . . . . . . . . . . . . . 522\n12.4.1 系统函数的依赖注入. . . . . . . . . . . . . . . . . . . . . . . . . 522\n12.4.2 链接期垫片（link seam） . . . . . . . . . . . . . . . . . . . . . . 524\n12.5 慎用匿名namespace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 526\n12.5.1 C 语言的static 关键字的两种用法. . . . . . . . . . . . . . . . . 526\n12.5.2 C++ 语言的static 关键字的四种用法. . . . . . . . . . . . . . . . 526\n12.5.3 匿名namespace 的不利之处. . . . . . . . . . . . . . . . . . . . . 527\n12.5.4 替代办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 529\n12.6 采用有利于版本管理的代码格式. . . . . . . . . . . . . . . . . . . . . . . 529\n12.6.1 对diff 友好的代码格式. . . . . . . . . . . . . . . . . . . . . . . . 530\n12.6.2 对grep 友好的代码风格. . . . . . . . . . . . . . . . . . . . . . . 537\n12.6.3 一切为了效率. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 538\n12.7 再探std::string . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539\n12.7.1 直接拷贝（eager copy） . . . . . . . . . . . . . . . . . . . . . . . 540\n12.7.2 写时复制（copy-on-write） . . . . . . . . . . . . . . . . . . . . . 542\n12.7.3 短字符串优化（SSO） . . . . . . . . . . . . . . . . . . . . . . . . 543\n12.8 用STL algorithm 轻松解决几道算法面试题. . . . . . . . . . . . . . . . 546\n12.8.1 用next_permutation() 生成排列与组合. . . . . . . . . . . . . . 546\n12.8.2 用unique() 去除连续重复空白. . . . . . . . . . . . . . . . . . . 548\n12.8.3 用{make,push,pop}_heap() 实现多路归并. . . . . . . . . . . . 549\n12.8.4 用partition() 实现“重排数组，让奇数位于偶数前面” . . . . 553\n12.8.5 用lower_bound() 查找IP 地址所属的城市. . . . . . . . . . . . . 554\n第4 部分附录559\n附录A 谈一谈网络编程学习经验561\n附录B 从《C++ Primer（第4 版）》入手学习C++ 579\n附录C 关于Boost 的看法591\n附录D 关于TCP 并发连接的几个思考题与试验593\n参考文献599","pages":"610","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s24522799.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s24522799.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s24522799.jpg"},"alt":"https:\/\/book.douban.com\/subject\/20471211\/","id":"20471211","publisher":"电子工业出版社","isbn10":"7121192829","isbn13":"9787121192821","title":"Linux多线程服务端编程","url":"https:\/\/api.douban.com\/v2\/book\/20471211","alt_title":"","author_intro":"陈硕，北京师范大学硕士，擅长C++ 多线程网络编程和实时分布式系统架构。曾在摩根士丹利IT 部门工作5 年，从事实时外汇交易系统开发。现在在美国加州硅谷某互联网大公司工作，从事大规模分布式系统的可靠性工程。编写了开源C++ 网络库muduo，参与翻译了《代码大全（ 第2 版）》和《C++ 编程规范（繁体版）》，整理了《C++ Primer （第4 版）（评注版）》，并曾多次在各地技术大会演讲。","summary":"本书主要讲述采用现代C++ 在x86-64 Linux 上编写多线程TCP 网络服务程序的主流常规技术，重点讲解一种适应性较强的多线程服务器的编程模型，即one loop per thread。这是在Linux 下以native 语言编写用户态高性能网络程序最成熟的模式，掌握之后可顺利地开发各类常见的服务端网络应用程序。本书以muduo 网络库为例，讲解这种编程模型的使用方法及注意事项。\n本书的宗旨是贵精不贵多。掌握两种基本的同步原语就可以满足各种多线程同步的功能需求，还能写出更易用的同步设施。掌握一种进程间通信方式和一种多线程网络编程模型就足以应对日常开发任务，编写运行于公司内网环境的分布式服务统。","price":"89.00元"}]}
5	{"count":20,"start":0,"total":1198604,"books":[{"rating":{"max":10,"numRaters":1850,"average":"8.9","min":0},"subtitle":"C语言描述","author":["维斯"],"pubdate":"2004-1-1","tags":[{"count":2183,"name":"数据结构","title":"数据结构"},{"count":1727,"name":"算法","title":"算法"},{"count":976,"name":"计算机","title":"计算机"},{"count":900,"name":"数据结构与算法分析","title":"数据结构与算法分析"},{"count":731,"name":"编程","title":"编程"},{"count":706,"name":"算法、数据结构","title":"算法、数据结构"},{"count":647,"name":"C","title":"C"},{"count":552,"name":"C语言","title":"C语言"}],"origin_title":"Data Structures and Algorithm Analysis in C:Second Edition","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s28015501.jpg","binding":"平装","translator":["冯舜玺"],"catalog":"第1章 引论\n1．1 本书讨论的内容\n1．2 数学知识复习\n1．2．1 指数\n1．2．2 对数\n1．2．3 级数\n1．2．4 模运算\n1. 2．5 证明方法\n1．3 递归简论\n总结\n练习\n参考文献\n第2章 算法分析\n2．1 数学基础\n2．2 模型\n2．3 要分析的问题\n2．4 运行时间计算\n2．4．1 一个简单的例子\n2．4．2 一般法则\n2．4．3 最大子序列和问题的解\n.2．4．4 运行时间中的对数\n2．4．5 检验你的分析\n2．4．6 分析结果的准确性\n总结\n练习\n参考文献\n第3章 表、栈和队列\n3．1 抽象数据类型(adt)\n3．2 表adt\n3．2．1 表的简单数组实现\n3．2．2 链表\n3．2．3 程序设计细节\n3．2．4 常见的错误\n3．2．5 双链表\n3．2．6 循环链表\n3．2．7 例子\n3．2．8 链表的游标实现\n3．3 栈adt\n3．3．1 栈模型\n3．3．2 栈的实现\n3．3．3 应用\n3．4 队列adt\n3．4．1 队列模型\n3．4．2 队列的数组实现\n3．4．3 队列的应用\n总结\n练习\n第4章 树\n4．1 预备知识\n4．1．1 树的实现\n4．1．2 树的遍历及应用\n4．2 二叉树\n4．2．1 实现\n4．2．2 表达式树\n4．3 查找树adt--二叉查找树\n4．3．1 makeempty\n4．3．2 find\n4．3．3 findmin和findmax\n4．3．4 insert\n4．3．5 delere\n4．3．6 平均情形分析\n4．4 avl树\n4．4．1 单旋转\n4．4．2 双旋转\n4．5 伸展树\n4．5．1 一个简单的想法\n4．5．2 展开\n4．6 树的遍历\n4．7 b-树\n总结\n练习\n参考文献\n第5章 散列\n5．1 一般想法\n5．2 散列函数\n5．3 分离链接法\n5．4 开放定址法\n5．4．1 线性探测法\n5．4．2 平方探测法\n5．4．3 双散列\n5．5 再散列\n5．6 可扩散列\n总结\n练习\n参考文献\n第6章 优先队列(堆)\n6．1 模型\n6．2 一些简单的实现\n6．3 二叉堆\n6．3．1 结构性质\n6．3．2 堆序性质\n6．3．3 基本的堆操作\n6．3．4 其他的堆操作\n6．4 优先队列的应用\n6．4．1 选择问题\n6．4．2 事件模拟\n6．5 d-堆\n6．6 左式堆\n6．6．1 左式堆的性质\n6．6．2 左式堆的操作\n6．7 斜堆\n6．8 二项队列\n6．8．1 二项队列结构\n6．8．2 二项队列操作\n6．8．3 二项队列的实现\n总结\n练习\n参考文献\n第7章 排序\n7．1 预备知识\n7．2 插入排序\n7．2．1 算法\n7．2．2 插入排序的分析\n7．3 一些简单排序算法的下界\n7. 4 希尔排序\n7．4．1 希尔排序的最坏情形分析\n7．5 堆排序\n7．5．1 堆排序的分析\n7．6 归并排序\n7．6．1 归并排序的分析\n7．7 快速排序\n7．7．1 选取枢纽元\n7．7．2 分割策略\n7．7．3 小数组\n7．7．4 实际的快速排序例程\n7．7．5 快速排序的分析\n7．7．6 选择的线性期望时间算法\n7．8 大型结构的排序\n7．9 排序的一般下界\n7．9．1 决策树\n7．10 桶式排序\n7．11 外部排序\n7．11．1 为什么需要新的算法\n7．11．2 外部排序模型\n7．11．3 简单算法\n7．11．4 多路合并\n7．11．5 多相合并\n7．11．6 替换选择\n总结\n练习\n参考文献\n第8章 不相交集adt\n8．1 等价关系\n8．2 动态等价性问题\n8．3 基本数据结构\n8．4 灵巧求并算法\n8．5 路径压缩\n8．6 按秩求并和路径压缩的最坏情形\n8．6．1 union／find算法分析\n8．7 一个应用\n总结\n练习\n参考文献\n第9章 图论算法\n9．1 若干定义\n9．1．1 图的表示\n9．2 拓扑排序\n9．3 最短路径算法\n9．3．1 无权最短路径\n9．3．2 dijkstra算法\n9．3．3 具有负边值的图\n9．3．4 无圈图\n9．3．5 所有点对最短路径\n9．4 网络流问题\n9．4．1 一个简单的最大流算法\n9．5 最小生成树\n9．5．1 prim算法\n9．5．2 kruskal算法\n9．6 深度优先搜索的应用\n9．6．1 无向图\n9．6．2 双连通性\n9．6．3 欧拉回路\n9．6．4 有向图\n9．6．5 查找强分支\n9．7 np-完全性介绍\n9．7．1 难与易\n9．7．2 np类\n9．7．3 np-完全问题\n总结\n练习\n参考文献\n第10章 算法设计技巧\n10．1 贪婪算法\n10．1．1 一个简单的调度问题\n10．1．2 huffman编码\n10．1．3 近似装箱问题\n10．2 分治算法\n10．2．1 分治算法的运行时间\n10．2．2 最近点问题\n10．2．3 选择问题\n10．2．4 一些运算问题的理论改进\n10．3 动态规划\n10．3．1 用一个表代替递归\n10．3．2 矩阵乘法的顺序安排\n10．3．3 最优二叉查找树\n10．3．4 所有点对最短路径\n10．4 随机化算法\n10．4．1 随机数发生器\n10．4．2 跳跃表\n10．4．3 素性测试\n10．5 回溯算法\n10．5．1 收费公路重建问题\n10．5．2 博弈\n总结\n练习\n参考文献\n第11章 摊还分析\n11．1 一个无关的智力问题\n11．2 二项队列\n11．3 斜堆\n11．4 斐波那契堆\n11．4．1 切除左式堆中的节点\n11．4．2 二项队列的懒惰合并\n11．4．3 斐波那契堆操作\n11．4．4 时间界的证明\n11. 5 伸展树\n总结\n练习\n参考文献\n第12章 高级数据结构及其实现\n12．1 自顶向下伸展树\n12．2 红黑树\n12．2．1 自底向上插入\n12．2．2 自顶向下红黑树\n12．2．3 自顶向下删除\n12．3 确定性跳跃表\n12．4 aa-树\n12．5 treap树\n12．6 k-d树\n12．7 配对堆\n总结\n练习\n参考文献\n索引","pages":"391","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s28015501.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s28015501.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s28015501.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1139426\/","id":"1139426","publisher":"机械工业出版社","isbn10":"711112748X","isbn13":"9787111127482","title":"数据结构与算法分析","url":"https:\/\/api.douban.com\/v2\/book\/1139426","alt_title":"Data Structures and Algorithm Analysis in C:Second Edition","author_intro":"Mark Allen Weiss，1987年在普林斯顿大学获得计算机科学博士学位，师从Robert Sedgewick (师从Knuth)，现任美国佛罗里达国际大学计算与信息科学学院教授。他曾经担任全美AP(Advanced Placement)考试计算机学科委员会的主席(2000-2004)。他的主要研究方向是数据结构、算法和教育学。","summary":"本书是《Data Structures and Algorithm Analysis in C》一书第2版的简体中译本。原书曾被评为20世纪顶尖的30部计算机著作之一，作者Mark Allen Weiss在数据结构和算法分析方面卓有建树，他的数据结构和算法分析的著作尤其畅销，并受到广泛好评．已被世界500余所大学用作教材。\n在本书中，作者更加精炼并强化了他对算法和数据结构方面创新的处理方法。通过C程序的实现，着重阐述了抽象数据类型的概念，并对算法的效率、性能和运行时间进行了分析。\n全书特点如下：\n●专用一章来讨论算法设计技巧，包括贪婪算法、分治算法、动态规划、随机化算法以及回溯算法\n●介绍了当前流行的论题和新的数据结构，如斐波那契堆、斜堆、二项队列、跳跃表和伸展树\n●安排一章专门讨论摊还分析，考查书中介绍的一些高级数据结构\n●新开辟一章讨论高级数据结构以及它们的实现，其中包括红黑树、自顶向下伸展树。treap树、k-d树、配对堆以及其他相关内容\n●合并了堆排序平均情况分析的一些新结果\n本书是国外数据结构与算法分析方面的标准教材，介绍了数据结构(大量数据的组织方法)以及算法分析(算法运行时间的估算)。本书的编写目标是同时讲授好的程序设计和算法分析技巧，使读者可以开发出具有最高效率的程序。 本书可作为高级数据结构课程或研究生一年级算法分析课程的教材，使用本书需具有一些中级程序设计知识，还需要离散数学的一些背景知识。","series":{"id":"1163","title":"计算机科学丛书"},"price":"35.00元"},{"rating":{"max":10,"numRaters":1332,"average":"8.9","min":0},"subtitle":"C语言调试指南","author":["凯尼格"],"pubdate":"2008-2-1","tags":[{"count":708,"name":"C语言","title":"C语言"},{"count":437,"name":"编程","title":"编程"},{"count":318,"name":"C","title":"C"},{"count":278,"name":"计算机","title":"计算机"},{"count":248,"name":"c","title":"c"},{"count":210,"name":"C\/C++","title":"C\/C++"},{"count":194,"name":"经典","title":"经典"},{"count":179,"name":"程序设计","title":"程序设计"}],"origin_title":"C Traps and Pitfalls","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s2870233.jpg","binding":"平装","translator":["高巍"],"catalog":"第0章　导读\n第1章　词法“陷阱”\n1.1　=不同于==\n1.2　& 和 | 不同于&& 和 ||\n1.3　词法分析中的“贪心法”\n1.4　整型常量\n1.5　字符与字符串\n第2章　语法“陷阱”\n2.1　理解函数声明\n2.2　运算符的优先级问题\n2.3　注意作为语句结束标志的分号\n2.4　switch语句\n2.5　函数调用\n2.6　“悬挂”else引发的问题\n第3章　语义“陷阱”\n3.1　指针与数组\n3.2　非数组的指针\n3.3　作为参数的数组声明\n3.4　避免“举隅法”\n3.5　空指针并非空字符串\n3.6　边界计算与不对称边界\n3.7　求值顺序\n3.8　运算符&&、|| 和 !\n3.9　整数溢出\n3.10　为函数main提供返回值\n第4章　连接\n4.1　什么是连接器\n4.2　声明与定义\n4.3　命名冲突与static修饰符\n4.4　形参、实参与返回值\n4.5　检查外部类型\n4.6　头文件\n第5章　库函数\n5.1　返回整数的getchar函数\n5.2　更新顺序文件\n5.3　缓冲输出与内存分配\n5.4　使用errno检测错误\n5.5　库函数signal\n第6章　预处理器\n6.1　不能忽视宏定义中的空格\n6.2　宏并不是函数\n6.3　宏并不是语句\n6.4　宏并不是类型定义\n第7章　可移植性缺陷\n7.1　应对C语言标准变更\n7.2　标识符名称的限制\n7.3　整数的大小\n7.4　字符是有符号整数还是无符号整数\n7.5　移位运算符\n7.6　内存位置0\n7.7　除法运算时发生的截断\n7.8　随机数的大小\n7.9　大小写转换\n7.10　首先释放，然后重新分配\n7.11　可移植性问题的一个例子\n第8章　建议与答案\n8.1　建议\n8.2　答案\n附录A　PRINTF，VARARGS与STDARG\n附录B　Koenig和Moo夫妇访谈","pages":"172","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s2870233.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s2870233.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s2870233.jpg"},"alt":"https:\/\/book.douban.com\/subject\/2778632\/","id":"2778632","publisher":"人民邮电出版社","isbn10":"7115171793","isbn13":"9787115171795","title":"C陷阱与缺陷","url":"https:\/\/api.douban.com\/v2\/book\/2778632","alt_title":"C Traps and Pitfalls","author_intro":"Andrew Koenig 是AT&T公司Shannon实验室大规模编程研究部门中的成员，同时也是C++标准委员会的项目编辑。他的编程经验超过30年，其中有15年在使用C++，他已经出版了超过150 篇和C++有关的论文，并且在世界范围内就这个主题进行过多次演讲。","summary":"作者以自己1985年在Bell实验室时发表的一篇论文为基础，结合自己的工作经验扩展成为这本对C程序员具有珍贵价值的经典著作。写作本书的出发点不是要批判C语言，而是要帮助C程序员绕过编程过程中的陷阱和障碍。..\n全书分为8章，分别从词法分析、语法语义、连接、库函数、预处理器、可移植性缺陷等几个方面分析了C编程中可能遇到的问题。最后，作者用一章的篇幅给出了若干具有实用价值的建议。..\n本书适合有一定经验的C程序员阅读学习，即便你是C编程高手，本书也应该成为你的案头必备书籍。","series":{"id":"9931","title":"C和C++经典著作"},"price":"30.00元"},{"rating":{"max":10,"numRaters":4408,"average":"9.4","min":0},"subtitle":"第 2 版·新版","author":["（美）Brian W. Kernighan","（美）Dennis M. Ritchie"],"pubdate":"2004-1","tags":[{"count":3001,"name":"C","title":"C"},{"count":2408,"name":"c语言","title":"c语言"},{"count":2131,"name":"编程","title":"编程"},{"count":1549,"name":"计算机","title":"计算机"},{"count":1291,"name":"程序设计","title":"程序设计"},{"count":1080,"name":"经典","title":"经典"},{"count":987,"name":"编程语言","title":"编程语言"},{"count":869,"name":"C\/C++","title":"C\/C++"}],"origin_title":"The C Programming Language","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1106934.jpg","binding":"平装","translator":["徐宝文","李志译","尤晋元审校"],"catalog":"出版者的话\n专家指导委员会\n中文版序\n译者序\n校译者简介\n序\n第1版序\n引言\n第1章 导言\n1.1 入门\n1.2 变量与算术表态式\n1.3 for语句\n1.4 符号常量\n1.5 字符输入\/输出\n1.6 数组\n1.7 函数\n1.8 参数——传值调用\n1.9 字符数组\n1.10 外部变量与作用域\n第2章 类型、运算符与表达式\n2.1 变量名\n2.2 数据类型及长度\n2.3 常量\n2.4 声明\n2.5 算术运算符\n2.6 关系运算符与逻辑运算符\n2.7 类型转换\n2.8 自增运算符与自减运算符\n2.9 按位运算符\n2.10 赋值运算符与表达式\n2.11 条件表达式\n2.12 运算符优先级与求值次序\n第3章 控制流\n3.1 语句与程序块\n3.2 if-else语句\n3.3 else-if语句\n3.4 switch语句\n3.5 whil循环与for特环\n3.6 do-while循环\n3.7 break语句与continue语句\n3.8 goto语句与标号\n第4章 涵数与程序结构\n第5章 指针与数组\n第6章 结构\n第7章 输入与输出\n第8章 UNIX系统接口\n附录A 参考手册\n附录B 标准库\n附录C 变更小结\n索引","pages":"258","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s1106934.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s1106934.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1106934.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1139336\/","id":"1139336","publisher":"机械工业出版社","isbn10":"7111128060","isbn13":"9787111128069","title":"C程序设计语言","url":"https:\/\/api.douban.com\/v2\/book\/1139336","alt_title":"The C Programming Language","author_intro":"Brian W. Kernighan： 贝尔实验室计算科学研究中心高级研究人员，著名的计算机科学家。他参加了UNIX系统、C语言、AWK语言和许多其他系统的开发，同时出版了许多在计算机领域具有影响的著作，如《The Elements of Programming Style》、《The Practice of Programming》、《The UNIX Programming Environment》、《The AWK Language》、《Software Tools》等。\nDennis M. Ritchie：1967年加入贝尔实验室。他和Ken L. Thompson两人共同设计并实现的C语言改变了程序设计语言发展的轨迹，是程序设计语言发展过程中的一个重要里程碑。与此同时，他们两人还设计并实现了UNIX操作系统。正是由于这两项巨大贡献，Dennis M. Ritchie于1983年获得了计算机界的最高奖——图灵奖。此外，他还获得了ACM、IEEE、贝尔实验室等授予的多种奖项.。","summary":"在计算机发展的历史上，没有哪一种程序设计语言像C语言这样应用广泛。本书原著即为C语言的设计者之一Dennis M.Ritchie和著名计算机科学家Brian W.Kernighan合著的一本介绍C语言的权威经典著作。我们现在见到的大量论述C语言程序设计的教材和专著均以此书为蓝本。原著第1版中介绍的C语言成为后来广泛使用的C语言版本——标准C的基础。人们熟知的“hello,World\"程序就是由本书首次引入的，现在，这一程序已经成为众多程序设计语言入门的第一课。\n原著第2版根据1987年制定的ANSIC标准做了适当的修订．引入了最新的语言形式，并增加了新的示例，通过简洁的描述、典型的示例，作者全面、系统、准确地讲述了C语言的各个特性以及程序设计的基本方法。对于计算机从业人员来说，《C程序设计语言》是一本必读的程序设计语 言方面的参考书。","series":{"id":"1163","title":"计算机科学丛书"},"price":"30.00元"},{"rating":{"max":10,"numRaters":132,"average":"8.5","min":0},"subtitle":"C语言描述","author":["(美)安佩尔"],"pubdate":"2006-4","tags":[{"count":306,"name":"编译原理","title":"编译原理"},{"count":115,"name":"虎书","title":"虎书"},{"count":95,"name":"C","title":"C"},{"count":83,"name":"计算机","title":"计算机"},{"count":81,"name":"计算机科学","title":"计算机科学"},{"count":60,"name":"compiler","title":"compiler"},{"count":59,"name":"编译理论","title":"编译理论"},{"count":59,"name":"编译器","title":"编译器"}],"origin_title":"Modern Compiler Implementation in C","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1852496.jpg","binding":"简裝本","translator":["赵克佳","黄春","沈志宇"],"catalog":"第一部分 编译基本原理\n第1章 绪论\n1.1 模块与接口\n1.2 工具和软件\n1.3 树语言的数据结构\n程序设计：直线式程序解释器\n推荐阅读\n习题\n第2章 词法分析\n2.1 词法单词\n2.2 正则表达式\n2.3 有限自动机\n2.4 非确定有限自动机\n2.4.1 将正则表达式转换为NFA\n2.4.2 将NFA转换为DFA\n2.5 Lex：词法分析器的生成器\n程序设计：词法分析\n推荐阅读\n习题\n第3章 语法分析\n3.1 上下文无关文法\n3.1.1 推导\n3.1.2 语法分析树\n3.1.3 二义性文法\n3.1.4 文件结束符\n3.2 预测分析\n3.2.1 FIRST集合和FOLLOW集合\n3.2.2 构造一个预测分析器\n3.2.3 消除左递归\n3.2.4 提取左因子\n3.2.5 错误恢复\n3.3 LR分析\n3.3.1 LR分析引擎\n3.3.2 LR(0)分析器生成器\n3.3.3 SLR分析器的生成\n3.3.4 LR(1)项和LR(1)分析表\n3.3.5 LALR(1)分析表\n3.3.6 各类文法的层次\n3.3.7 二义性文法的LR分析\n3.4 使用分析器的生成器\n3.4.1 冲突\n3.4.2 优先级指导\n3.4.3 语法和语义\n3.5 错误恢复\n3.5.1 用error符号恢复\n3.5.2 全局错误修复\n程序设计：语法分析\n推荐阅读\n习题\n第4章 抽象语法\n4.1 语义动作\n4.1.1 递归下降\n4.1.2 Yacc生成的分析器\n4.1.3 语义动作的解释器\n4.2 抽象语法分析树\n4.2.1 位置\n4.2.2 Tiger的抽象语法\n程序设计：抽象语法\n推荐阅读\n习题\n第5章 语义分析\n5.1 符号表\n5.1.1 多个符号表\n5.1.2 高效的命令式风格符号表\n5.1.3 高效的函数式符号表\n5.1.4 Tiger编译器的符号\n5.1.5 函数式风格的符号表\n5.2 Tiger编译器的绑定\n5.3 表达式的类型检查\n5.4 声明的类型检查\n5.4.1 变量声明\n5.4.2 类型声明\n5.4.3 函数声明\n5.4.4 递归声明\n程序设计：类型检查\n习题\n第6章 活动记录\n6.1 栈帧\n6.1.1 帧指针\n6.1.2 寄存器\n6.1.3 参数传递\n6.1.4 返回地址\n6.1.5 栈帧内的变量\n6.1.6 静态链\n6.2 Tiger编译器的栈帧\n6.2.1 栈帧描述的表示\n6.2.2 局部变量\n6.2.3 计算逃逸变量\n6.2.4 临时变量和标号\n6.2.5 两层抽象\n6.2.6 管理静态链\n6.2.7 追踪层次信息\n程序设计：栈帧\n推荐阅读\n习题\n第7章 翻译成中间代码\n7.1 中间表示树\n7.2 翻译为树中间语言\n7.2.1 表达式的种类\n7.2.2 简单变量\n7.2.3 追随静态链\n7.2.4 数组变量\n7.2.5 结构化的左值\n7.2.6 下标和域选择\n7.2.7 关于安全性的劝告\n7.2.8 算术操作\n7.2.9 条件表达式\n7.2.10 字符串\n7.2.11 记录和数组的创建\n7.2.12 while循环\n7.2.13 for循环\n7.2.14 函数调用\n7.3 声明\n7.3.1 变量定义\n7.3.2 函数定义\n7.3.3 片段\n程序设计：翻译成树\n习题\n第8章 基本块和轨迹\n8.1 规范树\n8.1.1 ESEQ的转换\n8.1.2 一般重写规则\n8.1.3 将CALL移到顶层\n8.1.4 线性语句表\n8.2 处理条件分支\n8.2.1 基本块\n8.2.2 轨迹\n8.2.3 完善\n8.2.4 最优轨迹\n推荐阅读\n习题\n第9章 指令选择\n9.1 指令选择算法\n9.1.1 Maximal Munch算法\n9.1.2 动态规划\n9.1.3 树文法\n9.1.4 快速匹配\n9.1.5 覆盖算法的效率\n9.2 CISC机器\n9.3 Tiger编译器的指令选择\n9.3.1 抽象的汇编语言指令\n9.3.2 生成汇编指令\n9.3.3 过程调用\n9.3.4 无帧指针的情形\n程序设计：指令选择\n推荐阅读\n习题\n第10章 活跃分析\n10.1 数据流方程的解\n10.1.1 活跃性计算\n10.1.2 集合的表示\n10.1.3 时间复杂度\n10.1.4 最小不动点\n10.1.5 静态活跃性与动态活跃性\n10.1.6 冲突图\n10.2 Tiger编译器的活跃分析\n10.2.1 图\n10.2.2 控制流图\n10.2.3 活跃分析\n程序设计：构造流图\n程序设计：活跃分析模块\n习题\n第11章 寄存器分配\n11.1 通过简化进行着色\n11.2 合并\n11.3 预着色的结点\n11.3.1 机器寄存器的临时副本\n11.3.2 调用者保护的寄存器和被调用者保护的寄存器\n11.3.3 含预着色结点的例子\n11.4 图着色的实现\n11.4.1 传送指令工作表的管理\n11.4.2 数据结构\n11.4.3 程序代码\n11.5 针对树的寄存器分配\n程序设计：图着色\n推荐阅读\n习题\n第12章 整合为一体\n程序设计：过程入口\/出口\n程序设计：创建一个可运行的编译器\n第二部分 高级主题\n第13章 垃圾收集\n13.1 标记-清扫式收集\n13.2 引用计数\n13.3 复制式收集\n13.4 分代收集\n13.5 增量式收集\n13.6 Baker算法\n13.7 编译器接口\n13.7.1 快速分配\n13.7.2 数据布局的描述\n13.7.3 导出指针\n程序设计：描述字\n程序设计：垃圾收集\n推荐阅读\n习题\n第14章 面向对象的语言\n14.1 类\n14.2 数据域的单继承性\n14.3 多继承性\n14.4 测试类成员关系\n14.5 私有域和私有方法\n14.6 无类语言\n14.7 向对象程序的优化\n程序设计：OBJECT Tiger\n推荐阅读\n习题\n第15章 函数式程序设计语言\n15.1 一个简单的函数式语言\n15.2 闭包\n15.3 不变的变量\n15.3.1 基于延续的……I\/O226\n15.3.2 语言上的变化\n15.3.3 纯函数式语言的优化\n15.4 内联扩展\n15.5 闭包变换\n15.6 高效的尾递归\n15.7 懒惰计算\n15.7.1 传名调用计算\n15.7.2 按需调用\n15.7.3 懒惰程序的计算\n15.7.4 懒惰函数式程序的优化\n15.7.5 严格性分析\n推荐阅读\n程序设计：编译函数式语言\n习题\n第16章 多态类型\n16.1 参数多态性\n16.1.1 显式带类型的多态语言\n16.1.2 多态类型的检查\n16.2 类型推论\n16.2.1 一个隐式类型的多态语言\n16.2.2 类型推论算法\n16.2.3 递归的数据类型\n16.2.4 Hindley Milner类型的能力\n16.3 多态变量的表示\n16.3.1 多态函数的扩展\n16.3.2 完全的装箱转换\n16.3.3 基于强制的表示分析\n16.3.4 将类型作为运行时参数传递\n16.4 静态重载的解决方法\n推荐阅读\n习题\n第17章 数据流分析\n17.1 流分析使用的中间表示\n17.2 各种数据流分析\n17.2.1 到达定值\n17.2.2 可用表达式\n17.2.3 到达表达式\n17.2.4 活跃分析\n17.3 使用数据流分析结果的几种转换\n17.3.1 公共子表达式删除\n17.3.2 常数传播\n17.3.3 复写传播\n17.3.4 死代码删除\n17.4 加快数据流分析\n17.4.1 位向量\n17.4.2 基本块\n17.4.3 结点排序\n17.4.4 使用-定值链和定值-使用链\n17.4.5 工作表算法\n17.4.6 增量式数据流分析\n17.5 别名分析\n17.5.1 基于类型的别名分析\n17.5.2 基于流的别名分析\n17.5.3 使用可能别名信息\n17.5.4 严格的纯函数式语言中的别名分析\n推荐阅读\n习题\n第18章 循环优化\n18.1 必经结点\n18.1.1 寻找必经结点的算法\n18.1.2 直接必经结点\n18.1.3 循环\n18.1.4 循环前置结点\n18.2 循环不变量计算\n18.3 归纳变量\n18.3.1 发现归纳变量\n18.3.2 强度削弱\n18.3.3 删除\n18.3.4 重写比较\n18.4 数组边界检查\n18.5 循环展开\n推荐阅读\n习题\n第19章 静态单赋值形式\n19.1 转化为SSA形式\n19.1.1 插入Φ函数的标准\n19.1.2 必经结点边界\n19.1.3 插入Φ函数\n19.1.4 变量重命名\n19.1.5 边分割\n19.2 必经结点树的高效计算\n19.2.1 深度优先生成树\n19.2.2 半必经结点\n19.2.3 Lengauer Tarjan算法\n19.3 使用SSA的优化算法\n19.3.1 死代码删除\n19.3.2 简单的常数传播\n19.3.3 条件常数传播\n19.3.4 保持必经结点性质\n19.4 数组、指针和存储器\n19.5 控制依赖图\n19.6 从SSA形式转变回来\n19.7 函数式中间形式\n推荐阅读\n习题\n第20章 流水和调度\n20.1 没有资源约束时的循环调度\n20.2 有资源约束的循环流水\n20.2.1 模调度\n20.2.2 寻找最小的启动间距\n20.2.3 其他控制流\n20.2.4 编译器应该调度指令吗\n20.3 分支预测\n20.3.1 静态分支预测\n20.3.2 编译器应该预测分支吗\n推荐阅读\n习题\n第21章 存储层次\n21.1 cache的组织结构\n21.2 cache块对齐\n21.3 预取\n21.4 循环交换\n21.5 分块\n21.6 垃圾收集和存储层次\n推荐阅读\n习题\n附录 Tiger语言参考手册\n参考文献\n索引","pages":"385","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s1852496.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s1852496.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1852496.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1806974\/","id":"1806974","publisher":"人民邮电出版社","isbn10":"7115145520","isbn13":"9787115145529","title":"现代编译原理","url":"https:\/\/api.douban.com\/v2\/book\/1806974","alt_title":"Modern Compiler Implementation in C","author_intro":"","summary":"《现代编译原理:C语言描述》全面讲述了现代编译器的结构、编译算法和实现方法，是Andrew w．Apple的“虎书”——Modern Compiler Implementation——“红、蓝、绿”三序列之一。这三本书的内容基本相同。但是使用不同的语言来实现书中给出的一个编译器。本书使用的是更适合广大读者的c语言，而另外两本书分别采用ML语言和Java语言。本书的另一个特点是增加了一些其他编译原理教科书没有涉及的内容。前端增加了面向对象的程序设计语言、函数式程序设计语言等现代语言的编译实现方法，后端增加了针对现代计算机体系结构特征的一些比较成熟的优化方法。这部分内容展现了现代商业编译器需解决的一些关键问题，开拓了学生的视野，为学生未来进行更深入的研究奠定了基础。\n\n《现代编译原理:C语言描述》全面讲述了现代编译器的各个组成部分，包括词法分析、语法分析、抽象语法、语义检查、中间代码表示、指令选择、数据流分析、寄存器分配以及运行时系统等。全书分成两部分，第一部分是编译的基础知识，适用于第一门编译原理课程(一个学期)；第二部分是高级主题，包括面向对象语言和函数语言、垃圾收集、循环优化、ssA(静态单赋值)形式、循环调度、存储结构优化等，适合于后续课程或研究生教学。书中专门为学生提供了一个用C语言编写的实习项目，包括前端和后端设计，学生可以在一学期内创建一个功能完整的编译器。","series":{"id":"18507","title":"图灵计算机科学丛书"},"price":"45.00元"},{"rating":{"max":10,"numRaters":137,"average":"9.1","min":0},"subtitle":"编写高质量C语言代码","author":["Steve Maguire"],"pubdate":"2009.2","tags":[{"count":297,"name":"编程","title":"编程"},{"count":250,"name":"C","title":"C"},{"count":153,"name":"C语言","title":"C语言"},{"count":102,"name":"程序设计","title":"程序设计"},{"count":100,"name":"计算机","title":"计算机"},{"count":81,"name":"Programming","title":"Programming"},{"count":71,"name":"C\/C++","title":"C\/C++"},{"count":67,"name":"经典","title":"经典"}],"origin_title":"Writing Solid Code","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s3529626.jpg","binding":"","translator":[],"catalog":"1 a hypothetical compiler\n2 assert yourself\n3 fortify your subsystems\n4 step through your code\n5 candy-machine interfaces\n6 risky business\n7 treacheries of the trade\n8 the rest is attitude\nepilogue where do you go from here?\nappendix a coding checklists\nappendix b memory logging routines\nappendix c answers\nreferences\nindex","pages":"256","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s3529626.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s3529626.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s3529626.jpg"},"alt":"https:\/\/book.douban.com\/subject\/3406939\/","id":"3406939","publisher":"人民邮电出版社","isbn10":"7115193169","isbn13":"9787115193162","title":"编程精粹","url":"https:\/\/api.douban.com\/v2\/book\/3406939","alt_title":"Writing Solid Code","author_intro":"","summary":"编写高质量的、没有bug的程序，是每位程序员所追求的目标。但随着软件规模越来越大，功能日趋复杂，这一目标变得越来越困难。\n本书揭示了微软公司应对质量挑战、开发出世界级代码的技术内幕，作者在自己不断探索、实践和思考的基础上，系统总结了多年来指导微软各团队的经验，将其凝聚为许多切实可行的编程实践指导，可谓字字珠玑。正因如此，本书被公认为与《代码大全》齐名的编程技术名著，曾于1993年荣获有软件开发奥斯卡奖之称的Jolt生产效率大奖。书中内容主要针对C语言，但其中的思想对目前的各主流语言编程也完全适用。","series":{"id":"50484","title":"图灵程序设计丛书·C\/C++系列"},"price":"45.00元"},{"rating":{"max":10,"numRaters":462,"average":"8.1","min":0},"subtitle":"—C++\/C语言","author":["林锐","韩永泉"],"pubdate":"2007-5","tags":[{"count":218,"name":"C++","title":"C++"},{"count":154,"name":"编程","title":"编程"},{"count":126,"name":"C\/C++","title":"C\/C++"},{"count":104,"name":"程序设计","title":"程序设计"},{"count":78,"name":"高质量程序设计指南--C++\/c语言","title":"高质量程序设计指南--C++\/c语言"},{"count":70,"name":"计算机","title":"计算机"},{"count":70,"name":"编程风格","title":"编程风格"},{"count":61,"name":"C","title":"C"}],"origin_title":"","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s2660317.jpg","binding":"","translator":[],"catalog":"第1章  高质量软件开发之道\t11.1  软件质量基本概念\t11.1.1  如何理解软件的质量\t11.1.2  提高软件质量的基本方法\t31.1.3  “零缺陷”理念\t41.2  细说软件质量属性\t41.2.1  正确性\t41.2.2  健壮性\t51.2.3  可靠性\t51.2.4  性能\t61.2.5  易用性\t71.2.6  清晰性\t71.2.7  安全性\t71.2.8  可扩展性\t81.2.9  兼容性\t81.2.10  可移植性\t81.3  人们关注的不仅仅是质量\t91.3.1  质量、生产率和成本之间的关系\t91.3.2  软件过程改进的基本概念\t111.4  高质量软件开发的基本方法\t131.4.1  建立软件过程规范\t131.4.2  复用\t151.4.3  分而治之\t161.4.4  优化与折中\t171.4.5  技术评审\t181.4.6  测试\t191.4.7  质量保证\t211.4.8  改错\t221.5  关于软件开发的一些常识和思考\t241.5.1  有最好的编程语言吗\t241.5.2  编程是一门艺术吗\t241.5.3  编程时应该多使用技巧吗\t241.5.4  换更快的计算机还是换更快的算法\t251.5.5  错误是否应该分等级\t251.5.6  一些错误的观念\t251.6  小结\t26第2章  编程语言发展简史\t272.1  编程语言大事记\t272.2  Ada的故事\t302.3  C\/C++发展简史\t312.4  Borland与Microsoft之争\t322.5  Java阵营与Microsoft的较量\t332.6  小结\t36第3章  程序的基本概念\t373.1  程序设计语言\t373.2  语言实现\t383.3  程序库\t403.4  开发环境\t403.5  程序的工作原理\t413.6  良好的编程习惯\t42第4章  C++\/C程序设计入门\t454.1  C++\/C程序的基本概念\t454.1.1  启动函数main()\t454.1.2  命令行参数\t474.1.3  内部名称\t484.1.4  连接规范\t494.1.5  变量及其初始化\t514.1.6  C Runtime Library\t524.1.7  编译时和运行时的不同\t524.1.8  编译单元和独立编译技术\t544.2  基本数据类型和内存映像\t544.3  类型转换\t564.3.1  隐式转换\t564.3.2  强制转换\t584.4  标识符\t604.5  转义序列\t614.6  运算符\t624.7  表达式\t634.8  基本控制结构\t654.9  选择（判断）结构\t654.9.1  布尔变量与零值比较\t664.9.2  整型变量与零值比较\t674.9.3  浮点变量与零值比较\t674.9.4  指针变量与零值比较\t694.9.5  对if语句的补充说明\t704.9.6  switch结构\t704.10   循环（重复）结构\t714.10.1  for语句的循环控制变量\t724.10.2  循环语句的效率\t734.11  结构化程序设计原理\t784.12  goto\/continue\/break语句\t794.13  示例\t80第5章  C++\/C常量\t855.1  认识常量\t855.1.1  字面常量\t855.1.2  符号常量\t865.1.3  契约性常量\t875.1.4  枚举常量\t875.2  正确定义符号常量\t875.3  const与#define的比较\t885.4  类中的常量\t895.5  实际应用中如何定义常量\t90第6章  C++\/C函数设计基础\t956.1  认识函数\t956.2  函数原型和定义\t966.3  函数调用方式\t976.4  认识函数堆栈\t996.5  函数调用规范\t1006.6  函数连接规范\t1016.7  参数传递规则\t1026.8  返回值的规则\t1046.9  函数内部实现的规则\t1076.10  存储类型及作用域规则\t1096.10.1  存储类型\t1096.10.2  作用域规则\t1106.10.3  连接类型\t1116.11  递归函数\t1136.12  使用断言\t1166.13  使用const提高函数的健壮性\t1186.13.1  用const修饰函数的参数\t1186.13.2  用const修饰函数的返回值\t119第7章  C++\/C指针、数组和字符串\t1217.1  指针\t1217.1.1  指针的本质\t1217.1.2  指针的类型及其支持的运算\t1237.1.3  指针传递\t1257.2  数组\t1267.2.1  数组的本质\t1267.2.2  二维数组\t1287.2.3  数组传递\t1297.2.4  动态创建、初始化和删除数组的方法\t1317.3  字符数组、字符指针和字符串\t1337.3.1  字符数组、字符串和‘\\0’的关系\t1337.3.2  字符指针的误区\t1347.3.3  字符串拷贝和比较\t1347.4  函数指针\t1357.5  引用和指针的比较\t137第8章  C++\/C高级数据类型\t1418.1  结构（Struct）\t1418.1.1  关键字struct与class的困惑\t1418.1.2  使用struct\t1428.1.3  位域\t1458.1.4  成员对齐\t1478.2  联合（Union）\t1598.3  枚举（Enum）\t1618.4  文件\t163第9章  C++\/C编译预处理\t1659.1  文件包含\t1659.1.1  内部包含卫哨和外部包含卫哨\t1659.1.2  头文件包含的合理顺序\t1669.2  宏定义\t1669.3  条件编译\t1699.3.1  #if、#elif和#else\t1699.3.2  #ifdef 和 #ifndef\t1709.4  #error\t1719.5  #pragma\t1719.6  #和##运算符\t1719.7  预定义符号常量\t172第10章  C++\/C文件结构和程序版式\t17510.1  程序文件的目录结构\t17510.2  文件的结构\t17610.2.1  头文件的用途和结构\t17610.2.2  版权和版本信息\t17710.2.3  源文件结构\t17810.3  代码的版式\t17810.3.1  适当的空行\t17810.3.2  代码行及行内空格\t17910.3.3  长行拆分\t18010.3.4  对齐与缩进\t18110.3.5  修饰符的位置\t18210.3.6  注释风格\t18210.3.7  ADT\/UDT版式\t183第11章  C++\/C应用程序命名规则\t18511.1  共性规则\t18511.2  简单的Windows应用程序命名\t186第12章  C++面向对象程序设计方法概述\t18912.1  漫谈面向对象\t18912.2  对象的概念\t19012.3  信息隐藏与类的封装\t19112.4  类的继承特性\t19512.5  类的组合特性\t20012.6  动态特性\t20112.6.1  虚函数\t20212.6.2  抽象基类\t20212.6.3  动态绑定\t20512.6.4  运行时多态\t20712.6.5  多态数组\t20812.7  C++对象模型\t21512.7.1  对象的内存映像\t21512.7.2  隐含成员\t22412.7.3  C++编译器如何处理成员函数\t22512.7.4  C++编译器如何处理静态成员\t22512.8  小结\t226第13章  对象的初始化、拷贝和析构\t22913.1  构造函数与析构函数的起源\t22913.2  为什么需要构造函数和析构函数\t23013.3  构造函数的成员初始化列表\t23213.4  对象的构造和析构次序\t23413.5  构造函数和析构函数的调用时机\t23513.6  构造函数和赋值函数的重载\t23613.7  示例：类String的构造函数和析构函数\t23813.8  何时应该定义拷贝构造函数和拷贝赋值函数\t23913.9  示例：类String的拷贝构造函数和拷贝赋值函数\t24013.10  用偷懒的办法处理拷贝构造函数和拷贝赋值函数\t24213.11  如何实现派生类的基本函数\t243第14章  C++函数的高级特性\t24714.1  函数重载的概念\t24714.1.1  重载的起源\t24714.1.2  重载是如何实现的\t24714.1.3  当心隐式类型转换导致重载函数产生二义性\t24914.2  成员函数的重载、覆盖与隐藏\t25014.2.1  重载与覆盖\t25014.2.2  令人迷惑的隐藏规则\t25114.2.3  摆脱隐藏\t25314.3  参数的默认值\t25414.4  运算符重载\t25514.4.1  基本概念\t25514.4.2  运算符重载的特殊性\t25614.4.3  不能重载的运算符\t25714.4.4  重载++和--\t25714.5  函数内联\t25914.5.1  用函数内联取代宏\t25914.5.2  内联函数的编程风格\t26014.5.3  慎用内联\t26114.6  类型转换函数\t26114.7  const成员函数\t264第15章  C++异常处理和RTTI\t26715.1  为什么要使用异常处理\t26715.2  C++异常处理\t26815.2.1  异常处理的原理\t26815.2.2  异常类型和异常对象\t26915.2.3  异常处理的语法结构\t27015.2.4  异常的类型匹配规则\t27215.2.5  异常说明及其冲突\t27215.2.6  当异常抛出时局部对象如何释放\t27315.2.7  对象构造和析构期间的异常\t27315.2.8  如何使用好异常处理技术\t27515.2.9  C++的标准异常\t27815.3  虚函数面临的难题\t27815.4  RTTI及其构成\t28015.4.1  起源\t28015.4.2  typeid运算符\t28115.4.3  dynamic_cast<>运算符\t28315.4.4  RTTI的魅力与代价\t285第16章  内存管理\t28716.1  内存分配方式\t28716.2  常见的内存错误及其对策\t28816.3  指针参数是如何传递内存的\t28916.4  free和delete把指针怎么啦\t29116.5  动态内存会被自动释放吗\t29216.6  杜绝“野指针”\t29216.7  有了malloc\/free为什么还要new\/delete\t29316.8  malloc\/free的使用要点\t29516.9  new有3种使用方式\t29616.9.1  plain new\/delete\t29616.9.2  nothrow new\/delete\t29716.9.3  placement new\/delete\t29716.10  new\/delete的使用要点\t30016.11  内存耗尽怎么办\t30116.12  用对象模拟指针\t30216.13  泛型指针auto_ptr\t30516.14  带有引用计数的智能指针\t30616.15  智能指针作为容器元素\t310第17章  学习和使用STL\t32317.1  STL简介\t32317.2  STL头文件的分布\t32417.2.1  容器类\t32417.2.2  泛型算法\t32517.2.3  迭代器\t32517.2.4  数学运算库\t32517.2.5  通用工具\t32517.2.6  其他头文件\t32617.3  容器设计原理\t32617.3.1  内存映像\t32617.3.2  存储方式和访问方式\t32717.3.3  顺序容器和关联式容器的比较\t32817.3.4  如何遍历容器\t33117.3.5  存储空间重分配问题\t33217.3.6  什么样的对象才能作为STL容器的元素\t33317.4  迭代器\t33417.4.1  迭代器的本质\t33417.4.2  迭代器失效及其危险性\t33817.5  存储分配器\t34617.6  适配器\t34717.7  泛型算法\t35017.8  一些特殊的容器\t35417.8.1  string类\t35417.8.2  bitset并非set\t35517.8.3  节省存储空间的vector<bool>\t35717.8.4  空容器\t35817.9  STL容器特征总结\t36017.10  STL使用心得\t362附录A  C++\/C试题\t365附录B  C++\/C试题答案与评分标准\t369附录C  大学十年\t375附录D  《大学十年》后记\t393附录E  术语与缩写解释\t395参考文献\t397","pages":"394","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s2660317.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s2660317.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s2660317.jpg"},"alt":"https:\/\/book.douban.com\/subject\/2116929\/","id":"2116929","publisher":"电子工业","isbn10":"7121041146","isbn13":"9787121041143","title":"高质量程序设计指南","url":"https:\/\/api.douban.com\/v2\/book\/2116929","alt_title":"","author_intro":"林锐，国内知名的软件工程专家和研发管理咨询师。西安电子科技大学硕士，浙江大学计算机系博士。2000年7月加入上海贝尔有限公司，从事软件工程和CMM的研究推广工作。2003年7月当选为Alcatel集团技术专家。2004年初创建上海漫索计算机科技有限公司(http：／／www.chinaspis.com)，致力于创建适合国内IT企业需求的研发管理解决方案，包括方法论和软件产品。已出版著作七部。","summary":"《高质量程序设计指南:C++、C语言》(第3版)以轻松幽默的笔调向读者论述了高质量软件开发方法与C++\/C编程规范。它是作者多年从事软件开发工作的经验总结。《高质量程序设计指南:C++、C语言》(第3版)共17章，第1章到第4章重点介绍软件质量和基本的程序设计方法；第5章到第16章重点阐述 C++\/C编程风格、面向对象程序设计方法和一些技术专题；第17章阐述STL 的原理和使用方法。\n　　《高质量程序设计指南:C++、C语言》(第3版)第1版和第2版部分章节曾经在Internet上广泛流传，被国内IT企业的不少软件开发人员采用。《高质量程序设计指南:C++、C语言》(第3版)的附录C《大学十年》是作者在网上发表的一个短篇传记，文中所描述的充满激情的学习和生活态度，感染了大批莘莘学子。","price":"39.80元"},{"rating":{"max":10,"numRaters":78,"average":"9.1","min":0},"subtitle":"C语言描述","author":["韦斯(Mark Allen Weiss)"],"pubdate":"2010-8","tags":[{"count":165,"name":"数据结构","title":"数据结构"},{"count":148,"name":"算法","title":"算法"},{"count":89,"name":"计算机","title":"计算机"},{"count":63,"name":"C","title":"C"},{"count":45,"name":"Algorithms","title":"Algorithms"},{"count":41,"name":"计算机科学","title":"计算机科学"},{"count":38,"name":"编程","title":"编程"},{"count":16,"name":"数据结构与算法","title":"数据结构与算法"}],"origin_title":"Data Structures and Algorithm Analysis in C","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s4459394.jpg","binding":"平装","translator":[],"catalog":"1  Introduction  1.1. What's the Book About?  1.2. Mathematics Review    1.2.1. Exponents    1.2.2. Logarithms    1.2.3. Series    1.2.4. Modular Arithmetic    1.2.5. The P Word  1.3. A Brief Introduction to Recursion    Summary    Exercises    References2  Algorithm Analysis3  Lists, Stacks, and Queues4  Trees5  Hashing6  Priority Queues (Heaps)7  Sorting 2198  The Disjoint Set ADT9  Graph Algorithms10  Algorithm Design Techniques11  Amortized Analysis12  Advanced Data Structures and Implementation","pages":"511","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s4459394.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s4459394.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s4459394.jpg"},"alt":"https:\/\/book.douban.com\/subject\/4924153\/","id":"4924153","publisher":"机械工业出版社","isbn10":"7111312805","isbn13":"9787111312802","title":"数据结构与算法分析","url":"https:\/\/api.douban.com\/v2\/book\/4924153","alt_title":"Data Structures and Algorithm Analysis in C","author_intro":"Mark Allen Weiss 1987年在普林斯顿大学获得计算机科学博士学位。师从Roberl Sedgewick，现任美国佛罗里达国际大学计算与信息科学学院教授。他曾担任全美AP(Advanced Placement)考试计算机学科委员会主席。其主要研究方向是数据结构、算法和教育学。","summary":"《数据结构与算法分析:C语言描述》曾被评为20世纪顶尖的30部计算机著作之一，作者在数据结构和算法分析方面卓有建树，他的数据结构和算法分析的著作尤其畅销，并受到广泛好评，已被世界500余所大学选作教材。\n在《数据结构与算法分析:C语言描述》中，作者精炼并强化了他对算法和数据结构方面创新的处理方法。通过C程序的实现，着重阐述了抽象数据类型的概念，并对算法的效率、性能和运行时间进行了分析。\n《数据结构与算法分析:C语言描述》特色：着重讨论了算法设计技巧，包括贪婪算法、分治算法、动态规划、随机化算法以及回溯算法。系统介绍了当前流行的论题和新的数据结构，如斐波那契堆、斜堆、二项队列、跳跃表和伸展树。详细讨论了摊还分析，考查书中介绍的一些高级数据结构。增加了高级数据结构及其实现的内容，包括红黑树、自顶向下伸展树、treap树、k-d树、配对堆等。整合了堆排序平均情况分析的一些新结果。","series":{"id":"1895","title":"经典原版书库"},"price":"45.00元"},{"rating":{"max":10,"numRaters":1802,"average":"9.1","min":0},"subtitle":"（第五版）","author":["Stephen Prata","云巅工作室"],"pubdate":"2005-2-1","tags":[{"count":915,"name":"编程","title":"编程"},{"count":840,"name":"c","title":"c"},{"count":830,"name":"c语言","title":"c语言"},{"count":611,"name":"计算机","title":"计算机"},{"count":480,"name":"程序设计","title":"程序设计"},{"count":379,"name":"经典","title":"经典"},{"count":378,"name":"C","title":"C"},{"count":243,"name":"programming","title":"programming"}],"origin_title":"","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1308874.jpg","binding":"平装(无盘)","translator":["云巅工作室"],"catalog":"第1章 概览\n1.1 C语言的起源\n1.2 使用C语言的理由\n1.3 C语言的发展方向\n1.4 计算机工作的基本原理\n1.5 高级计算机语言和编译器\n1.6 使用C语言的7个步骤\n1.7 编程机制\n1.8 语言标准\n1.9 本书的组织结构\n1.10 本书体例\n1.11 总结\n1.12 复习题\n1.13 编程练习\n第2章 C语言概述\n2.1 C语言的一个简单实例\n2.2 实例说明\n2.3 一个简单程序的结构\n2.4 使程序可读的技巧\n2.5 更进一步\n2.6 多个函数\n2.7 调试\n2.8 关键字和保留标识符\n2.9 关键概念\n2.10 总结\n2.11 复习题\n2.12 编程练习\n第3章 数据和C\n3.1 示例程序\n3.2 变量与常量数据\n3.3 数据：数据类型关键字\n3.4 C数据类型\n3.5 使用数据类型\n3.6 参数和易犯的错误\n3.7 另一个例子：转义序列\n3.8 关键概念\n3.9 总结\n3.10 复习题\n3.11 编程练习\n第4章 字符串和格式化输入\/输出\n4.1 前导程序\n4.2 字符串简介\n4.3 常量和C预处理器\n4.4 研究和利用printf（）和scanf（）\n4.5 关键概念\n4.6 总结\n4.7 复习题\n4.8 编程练习\n第5章 运算符、表达式和语句\n5.1 循环简介\n5.2 基本运算符\n5.3 其他运算符\n5.4 表达式和语句\n5.5 类型转换\n5.6 带有参数的函数\n5.7 一个示例程序\n5.8 关键概念\n5.9 总结\n5.10 复习题\n5.11 编程练习\n第6章 C控制语句：循环\n6.1 再探while循环\n6.2 while语句\n6.4 不确定循环与计数循环\n6.5 for循环\n6.6 更多赋值运算符：+=、-=、*=、\/=和%=\n6.7 逗号运算符\n6.8 退出条件循环：do while\n6.9 选择哪种循环\n6.10 嵌套循环\n6.11 数组\n6.12 使用函数返回值的循环例子\n6.13 关键概念\n6.14 总结\n6.15 复习题\n6.16 编程练习\n第7章 C控制语句：分支和跳转\n7.1 if语句\n7.2 在if语句中添加else关键字\n7.3 获得逻辑性\n7.4 一个统计字数的程序\n7.5 条件运算符?:\n7.6 循环辅助手段：continue和break\n7.7 多重选择：switch和break\n7.8 goto语句\n7.9 关键概念\n7.10 总结\n7.11 复习题\n7.12 编程练习\n第8章 字符输入\/输出和输入确认\n8.1 单字符I\/O：getchar（）和putchar（）\n8.2 缓冲区\n8.3 终止键盘输入\n8.5 创建一个更友好的用户界面\n8.6 输入确认\n8.7 菜单浏览\n8.8 关键概念\n8.9 总结\n8.10 复习题\n8.11 编程练习\n第9章 函数\n9.1 函数概述\n9.2 ANSI C的函数原型\n9.3 递归\n9.4 多源代码文件程序的编译\n9.5 地址运算符：&\n9.6 改变调用函数中的变量\n9.7 指针简介\n9.8 关键概念\n9.9 总结\n9.10 复习题\n9.11 编程练习\n第10章 数组和指针\n10.1 数组\n10.2 多维数组\n10.3 指针和数组\n10.4 函数、数组和指针\n10.5 指针操作\n10.6 保护数组内容\n10.7 指针和多维数组\n10.8 变长数组（VLA）\n10.9 复合文字\n10.10 关键概念\n10.11 总结\n10.12 复习题\n10.13 编程练习\n第11章 字符串和字符串函数\n11.1 字符串表示和字符串I\/O\n11.2 字符串输入\n11.3 字符串输出\n11.4 自定义字符串输入\/输出函数\n11.5 字符串函数\n11.6 字符串例子：字符串排序\n11.7 ctype.h字符函数和字符串\n11.8 命令行参数\n11.9 把字符串转换为数字\n11.10 关键概念\n11.11 总结\n11.12 复习题\n11.13 编程练习\n第12章 存储类、链接和内存管理\n12.1 存储类\n12.2 存储类说明符\n12.3 存储类和函数\n12.4 随机数函数和静态变量\n12.5 掷骰子\n12.6 分配内存：malloc（）和free（）\n12.7 ANSI C的类型限定词\n12.8 关键概念\n12.9 总结\n12.10 复习题\n12.11 编程练习\n第13章 文件输入\/输出\n13.1 和文件进行通信\n13.2 标准I\/O\n13.3 一个简单的文件压缩程序\n13.4 文件I\/O：fprintf ( )、fscanf ( )、fgets ( )和fputs ( )函数\n13.5 随机存取：fseek（）和ftell（）函数\n13.6 标准I\/O内幕\n13.7 其他标准I\/O函数\n13.8 关键概念\n13.9 总结\n13.10 复习题\n13.11 编程练习\n第14章 结构和其他数据形式\n14.1 示例问题：创建图书目录\n14.2 建立结构声明\n14.3 定义结构变量\n14.4 结构数组\n14.5 嵌套结构\n14.6 指向结构的指针\n14.7 向函数传递结构信息\n14.8 把结构内容保存到文件中\n14.9 结构：下一步是什么\n14.10 联合简介\n14.11 枚举类型\n14.12 typedef简介\n14.13 奇特的声明\n14.14 函数和指针\n14.15 关键概念\n14.16 总结\n14.17 复习题\n14.18 编程练习\n第15章 位操作\n15.1 二进制数、位和字节\n15.2 其他基数\n15.3 C的位运算符\n15.4 位字段\n15.5 关键概念\n15.6 总结\n15.7 复习题\n15.8 编程练习\n第16章 C预处理器和C库\n16.1 翻译程序的第一步\n16.2 明显常量：#define\n16.3 在#define中使用参数\n16.4 宏，还是函数\n16.5 文件包含：＃include\n16.6 其他指令\n16.7 内联函数\n16.8 C库\n16.9 数学库\n16.10 通用工具库\n16.11 诊断库\n16.12 string.h库中的memcpy（）和memmove（）\n16.13 可变参数：stdarg.h\n16.14 关键概念\n16.15 总结\n16.16 复习题\n16.17 编程练习\n第17章 高级数据表示\n17.1 研究数据表示\n17.2 从数组到链表\n17.3 抽象数据类型（ADT）\n17.4 队列ADT\n17.5 用队列进行模拟\n17.6 链表与数组\n17.7 二叉搜索树\n17.8 其他说明\n17.9 关键概念\n17.10 总结\n17.11 复习题\n17.12 编程练习\n附录A 复习题答案\n附录B 参考资料","pages":"626","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s1308874.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s1308874.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1308874.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1240002\/","id":"1240002","publisher":"人民邮电出版社","isbn10":"7115130221","isbn13":"9787115130228","title":"C Primer Plus","url":"https:\/\/api.douban.com\/v2\/book\/1240002","alt_title":"","author_intro":"普拉塔，在加利福尼亚州的Kentfield的Marin学院教授天文学、物理学和程序设计课程。他在加州工业学院获得学士学位，从加州大学伯克利分校获得博士学位。他最早接触计算机，始于对星河的计算机建模。Stephen已经编写或与他人合作编写了十多本书。其中包括C++Primer Plus和Unix Prinmer Plus。","summary":"《C Primer Plus（第5版）（中文版）》共17章。第1、2章学习C语言编程所需的预备知识。第3到15章介绍了C语言的相关知识，包括数据类型、格式化输入输出、运算符、表达式、流程控制语句、函数、数组和指针、字符串操作、内存管理、位操作等等，知识内容都针对C99标准；另外，第10章强化了对指针的讨论，第12章引入了动态内存分配的概念，这些内容更加适合读者的需求。第16章和第17章讨论了C预处理器和C库函数、高级数据表示（数据结构）方面的内容。附录给出了各章后面复习题、编程练习的答案和丰富的C编程参考资料。","price":"60.00元"},{"rating":{"max":10,"numRaters":1935,"average":"9.2","min":0},"subtitle":"","author":["Peter Van Der Linden"],"pubdate":"2008-2","tags":[{"count":1196,"name":"C语言","title":"C语言"},{"count":681,"name":"编程","title":"编程"},{"count":446,"name":"计算机","title":"计算机"},{"count":405,"name":"c","title":"c"},{"count":387,"name":"C专家编程","title":"C专家编程"},{"count":364,"name":"C\/C++","title":"C\/C++"},{"count":339,"name":"C","title":"C"},{"count":302,"name":"程序设计","title":"程序设计"}],"origin_title":"Expert C Programming: Deep C Secrets","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s5886086.jpg","binding":"平装","translator":["徐波"],"catalog":"第1章 C：穿越时空的迷雾\n1.1 C语言的史前阶段\n1.2 C语言的早期体验\n1.3 标准I\/O库和C预处理器\n1.4 K&R C\n1.5 今日之ANSI C\n1.6 它很棒，但它符合标准吗\n1.7 编译限制\n1.8 ANSI C标准的结构\n1.9 阅读ANSI C标准，寻找乐趣和裨益\n1.10 “安静的改变”究竟有多少安静\n1.11 轻松一下——由编译器定义的Pragmas效果\n第2章 这不是Bug，而是语言特性\n2.1 这关语言特性何事，在Fortran里这就是Bug呀\n2.2 多做之过\n2.3 误做之过\n2.4 少做之过\n2.5 轻松一下——有些特性确实就是Bug\n2.6 参考文献\n第3章 分析C语言的声明\n3.1 只有编译器才会喜欢的语法\n3.2 声明是如何形成的\n3.3 优先级规则\n3.4 通过图表分析C语言的声明\n3.5 typedef可以成为你的朋友\n3.6 typedef int x[10]和#define x int[10]的区别\n3.7 typedef struct foo{ ... foo; }的含义\n3.8 理解所有分析过程的代码段\n3.9 轻松一下——驱动物理实体的软件\n第4章 令人震惊的事实：数组和指针并不相同\n4.1 数组并非指针\n4.2 我的代码为什么无法运行\n4.3 什么是声明，什么是定义\n4.4 使声明与定义相匹配\n4.5 数组和指针的其他区别\n4.6 轻松一下——回文的乐趣\n第5章 对链接的思考\n5.1 函数库、链接和载入\n5.2 动态链接的优点\n5.3 函数库链接的5个特殊秘密\n5.4 警惕Interpositioning\n5.5 产生链接器报告文件\n5.6 轻松一下——看看谁在说话：挑战Turing测验\n第6章 运动的诗章：运行时数据结构\n6.1 a.out及其传说\n6.2 段\n6.3 操作系统在a.out文件里干了些什么\n6.4 C语言运行时系统在a.out里干了些什么\n6.5 当函数被调用时发生了什么：过程活动记录\n6.6 auto和static关键字\n6.7 控制线程\n6.8 setjmp和longjmp\n6.9 UNIX中的堆栈段\n6.10 MS-DOS中的堆栈段\n6.11 有用的C语言工具\n6.12 轻松一下——卡耐基-梅隆大学的编程难题\n6.13 只适用于高级学员阅读的材料\n第7章 对内存的思考\n7.1 Intel 80x86系列\n7.2 Intel 80x86内存模型以及它的工作原理\n7.3 虚拟内存\n7.4 Cache存储器\n7.5 数据段和堆\n7.6 内存泄漏\n7.7 总线错误\n7.8 轻松一下——“Thing King”和“页面游戏”\n第8章 为什么程序员无法分清万圣节和圣诞节\n8.1 Portzebie度量衡系统\n8.2 根据位模式构筑图形\n8.3 在等待时类型发生了变化\n8.4 原型之痛\n8.5 原型在什么地方会失败\n8.6 不需要按回车键就能得到一个字符\n8.7 用C语言实现有限状态机\n8.8 软件比硬件更困难\n8.9 如何进行强制类型转换，为何要进行类型强制转换\n8.10 轻松一下——国际C语言混乱代码大赛\n第9章 再论数组\n9.1 什么时候数组与指针相同\n9.2 为什么会发生混淆\n9.3 为什么C语言把数组形参当作指针\n9.4 数组片段的下标\n9.5 数组和指针可交换性的总结\n9.6 C语言的多维数组\n9.7 轻松一下——软件\/硬件平衡\n第10章 再论指针\n10.1 多维数组的内存布局\n10.2 指针数组就是Iliffe向量\n10.3 在锯齿状数组上使用指针\n10.4 向函数传递一个一维数组\n10.5 使用指针向函数传递一个多维数组\n10.6 使用指针从函数返回一个数组\n10.7 使用指针创建和使用动态数组\n10.8 轻松一下——程序检验的限制\n第11章 你懂得C，所以C++不在话下\n11.1 初识OOP\n11.2 抽象——取事物的本质特性\n11.3 封装——把相关的类型、数据和函数组合在一起\n11.4 展示一些类——用户定义类型享有和预定义类型一样的权限\n11.5 访问控制\n11.6 声明\n11.7 如何调用成员函数\n11.8 继承——复用已经定义的操作\n11.9 多重继承——从两个或更多的基类派生\n11.10 重载——作用于不同类型的同一操作具有相同的名字\n11.11 C++如何进行操作符重载\n11.12 C++的输入\/输出(I\/O)\n11.13 多态——运行时绑定\n11.14 解释\n11.15 C++如何表现多态\n11.16 新奇玩意——多态\n11.17 C++的其他要点\n11.18 如果我的目标是那里，我不会从这里起步\n11.19 它或许过于复杂，但却是惟一可行的方案\n11.20 轻松一下——死亡计算机协会\n11.21 更多阅读材料\n附录A 程序员工作面试的秘密\n附录B 术语表","pages":"291","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s5886086.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s5886086.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s5886086.jpg"},"alt":"https:\/\/book.douban.com\/subject\/2377310\/","id":"2377310","publisher":"人民邮电出版社","isbn10":"7115171807","isbn13":"9787115171801","title":"C专家编程","url":"https:\/\/api.douban.com\/v2\/book\/2377310","alt_title":"Expert C Programming: Deep C Secrets","author_intro":"","summary":"《C专家编程》展示了最优秀的C程序员所使用的编码技巧，并专门开辟了一章对C++的基础知识进行了介绍。\n书中C的历史、语言特性、声明、数组、指针、链接、运行时、内存以及如何进一步学习C++等问题进行了细致的讲解和深入的分析。全书撷取几十个实例进行讲解，对C程序员具有非常高的实用价值。\n本书可以帮助有一定经验的C程序员成为C编程方面的专家，对于具备相当的C语言基础的程序员，本书可以帮助他们站在C的高度了解和学习C++。","series":{"id":"9931","title":"C和C++经典著作"},"price":"45.00元"},{"rating":{"max":10,"numRaters":154,"average":"8.8","min":0},"subtitle":"C标准库“圣经”","author":["P. J. Plauger"],"pubdate":"2009-7","tags":[{"count":228,"name":"C","title":"C"},{"count":196,"name":"C语言","title":"C语言"},{"count":103,"name":"编程","title":"编程"},{"count":102,"name":"标准库","title":"标准库"},{"count":76,"name":"计算机","title":"计算机"},{"count":76,"name":"C\/C++","title":"C\/C++"},{"count":57,"name":"程序设计","title":"程序设计"},{"count":40,"name":"库","title":"库"}],"origin_title":"","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s3820140.jpg","binding":"","translator":["卢红星","徐明亮","霍建同"],"catalog":"第0章　简介. 1\n0.1　背景知识1\n0.2　C 标准的内容 3\n0.3　库的使用7\n0.4　库的实现9\n0.5　库的测试13\n0.6　参考文献15\n0.7　习题15\n第1章　(assert.h)17\n1.1　背景知识17\n1.2　C 标准的内容18\n1.3　(assert.h) 的使用18\n1.4　(assert.h) 的实现20\n1.5　(assert.h) 的测试22\n1.6　参考文献23\n1.7　习题23\n第2章　(ctype.h) 25\n2.1　背景知识25\n2.2　C 标准的内容28\n2.3　(ctype.h) 的使用 30\n2.4　(ctype.h) 的实现 34\n2.5　(ctype.h) 的测试 42\n2.6　参考文献45\n2.7　习题45\n第3章　(errno.h) 47\n3.1　背景知识47\n3.2　C 标准的内容50\n3.3　(errno.h) 的使用 50\n3.4　(errno.h) 的实现 51\n3.5　(errno.h) 的测试 55\n3.6　参考文献55\n3.7　习题55\n第4章　(float.h)57\n4.1　背景知识57\n4.2　C 标准的内容59\n4.3　(float.h) 的使用.62\n4.4　(float.h) 的实现.64\n4.5　(float.h) 的测试.69\n4.6　参考文献71\n4.7　习题72\n第5章　(limits.h)73\n5.1　背景知识73\n5.2　C 标准的内容74\n5.3　(limits.h) 的使用75\n5.4　(limits.h) 的实现77\n5.5　(limits.h) 的测试79\n5.6　参考文献80\n5.7　习题80\n第6章　(locale.h)81\n6.1　背景知识81\n6.2　C 标准的内容84\n6.3　(locale.h) 的使用87\n6.4　(locale.h) 的实现94\n6.5　(locale.h) 的测试 123\n6.6　参考文献.123\n6.7　习题123\n第7章　(math.h)127\n7.1　背景知识.127\n7.2　C 标准的内容 130\n7.3　(math.h) 的使用 135\n7.4　(math.h) 的实现 137\n7.5　(math.h) 的测试 171\n7.6　参考文献.177\n7.7　习题177\n第8章　(setjmp.h).. 181\n8.1　背景知识.181\n8.2　C 标准的内容 184\n8.3　(setjmp.h) 的使用 185\n8.4　(setjmp.h) 的实现 187\n8.5 (setjmp.h) 的测试191\n8.6 参考文献 192\n8.7 习题 192\n第9章　(signal.h) 193\n9.1　背景知识.193\n9.2　C 标准的内容 195\n9.3　(signal.h) 的使用 197\n9.4　(signal.h) 的实现 199\n9.5　(signal.h) 的测试 203\n9.6　参考文献.203\n9.7　习题203\n第10章　(stdarg.h) 205\n10.1　背景知识205\n10.2　C 标准的内容 207\n10.3　(stdarg.h) 的使用 208\n10.4　(stdarg.h) 的实现 211\n10.5　(stdarg.h) 的测试 212\n10.6　参考文献212\n10.7　习题.214\n第11章　(stddef.h) 215\n11.1　背景知识 215\n11.2　C 标准的内容 217\n11.3　(stddef.h) 的使用 217\n11.4　(stddef.h) 的实现 222\n11.5　(stddef.h) 的测试 223\n11.6　参考文献 223\n11.7　习题223\n第12章　(stdio.h) 225\n12.1　背景知识225\n12.2　C 标准的内容 233\n12.3　(stdio.h) 的使用 252\n12.4　(stdio.h) 的实现 274\n12.5　(stdio.h) 的测试 323\n12.6　参考文献325\n12.7　习题.325\n第13章　(stdlib.h) 331\n13.1　背景知识331\n13.2　C 标准的内容 332\n13.3　(stdlib.h) 的使用 342\n13.4　(stdlib.h) 的实现 351\n13.5　(stdlib.h) 的测试 379\n13.6　参考文献379\n13.7　习题.382\n第14章　(string.h) 385\n14.1　背景知识385\n14.2　C 标准的内容 386\n14.3　(string.h) 的使用 392\n14.4　(string.h) 的实现 396\n14.5　(string.h) 的测试 409\n14.6　参考文献409\n14.7　习题.409\n第15章　(time.h) 413\n15.1　背景知识413\n15.2　C 标准的内容 414\n15.3　(time.h) 的使用 418\n15.4　(time.h) 的实现 422\n15.5　(time.h) 的测试440\n15.6　参考文献441\n15.7　习题.441\n附录A　接口 443\n附录B　名字 451\n附录C　术语... 461","pages":"488","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s3820140.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s3820140.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s3820140.jpg"},"alt":"https:\/\/book.douban.com\/subject\/3775842\/","id":"3775842","publisher":"人民邮电出版社","isbn10":"7115172862","isbn13":"9787115172860","title":"C标准库","url":"https:\/\/api.douban.com\/v2\/book\/3775842","alt_title":"","author_intro":"P. J. Plauger  世界著名的软件技术专家，曾任ISO C标准委员会主席，C\/C++ User’s Journal主编，现任ISO C++标准委员会主席。他是C\/C++标准库开发领域的大师，所开发的Dinkumware标准库应用广泛。","summary":"本书是由世界级C语言专家编写的C标准库经典著作。英文版已经重印十多次，影响了几代程序员。\n本书结合C标准的相关部分，精辟地讲述了每一个库函数的使用方法和实现细节，而这正是一个真正的C程序员所必须掌握的。更重要的是，书中给出了实现和测试这些函数的完整源代码，可以让你更深入地学习C语言。不仅如此，本书还讨论了一些即使是最有经验的C程序员通常也不熟悉的知识，比如国际化和独立于区域设置的程序的编写、与构建库相关的概念和设计思想。\n本书结构清晰，内容权威，阐述精辟，对于各层次C 程序员和相关专业高校师生都是一本优秀的参考书。","series":{"id":"50484","title":"图灵程序设计丛书·C\/C++系列"},"price":"79.00元"},{"rating":{"max":10,"numRaters":808,"average":"8.6","min":0},"subtitle":"一本37.5°C的博物馆地图","author":["沈辛成"],"pubdate":"2017-5-20","tags":[{"count":588,"name":"纽约","title":"纽约"},{"count":560,"name":"博物馆","title":"博物馆"},{"count":455,"name":"旅行","title":"旅行"},{"count":370,"name":"美国","title":"美国"},{"count":337,"name":"艺术","title":"艺术"},{"count":281,"name":"城市","title":"城市"},{"count":214,"name":"历史","title":"历史"},{"count":193,"name":"生活","title":"生活"}],"origin_title":"","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s29478001.jpg","binding":"精装","translator":[],"catalog":"指南与致谢\n有点像跋的序\n第一章 你这个种族主义者\n纽约深度游线路一：黑色与白色\n第二章 没有华尔的街\n纽约深度游线路二：革命与资本\n第三章 纽约水故事\n纽约深度游线路三：饮水与思源\n第四章 我的画报你的城\n纽约深度游之四：寻根与漂流\n第五章 曼哈顿是平的\n纽约深度游之五：贫穷与富裕\n第六章 开往昨天的地铁\n纽约深度游之六：地下与地上\n第七章 美国的归美国，纽约的归纽约\n纽约深度游之七：美国与欧洲\n第八章 不知道为什么就流泪\n纽约深度游之八：战争与和平\n有点像序的跋\n附录\n附录一：一些遗珠\n附录二：纽约博物馆排名","pages":"380","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s29478001.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s29478001.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s29478001.jpg"},"alt":"https:\/\/book.douban.com\/subject\/27037182\/","id":"27037182","publisher":"中西书局","isbn10":"7547512488","isbn13":"9787547512487","title":"纽约无人是客","url":"https:\/\/api.douban.com\/v2\/book\/27037182","alt_title":"","author_intro":"沈辛成，1984年生人，非业余博物馆爱好者，走访全美八十余座博物馆，曾服务于美国自然历史博物馆、“911”国家纪念馆和纽约历史学会，参与从事档案研究、出版与策展工作。佐治亚理工学院科技史博士在读，哥伦比亚大学人类学硕士，复旦大学考古学硕士，北京大学博物馆学学士，做过独立唱作人，兼职美国时政评论。","summary":"本书为作者在纽约实地踏访数十家博物馆并进行深入了解后，对纽约博物馆展示特色、专业内涵、设计匠心及观众体验等进行多维度评价的作品。\n本书不是一本简单的博物馆导览手册，而是基于作者的个人经历和专业背景，试图阐释纽约这个五方杂处、光怪陆离却又独具特色的国际大都会的底色。全书行文从容，图文并茂，兼具知识性、实用性和可读性，无论是否去过纽约，它都会在流畅的阅读之后，带给你充足的知识与细节，同时也带给你深深的思索。","price":"39.80元"},{"rating":{"max":10,"numRaters":1399,"average":"9.0","min":0},"subtitle":"","author":["Kenneth A.Reek"],"pubdate":"2008 年4月","tags":[{"count":869,"name":"C","title":"C"},{"count":776,"name":"C语言","title":"C语言"},{"count":540,"name":"编程","title":"编程"},{"count":437,"name":"指针","title":"指针"},{"count":381,"name":"计算机","title":"计算机"},{"count":304,"name":"程序设计","title":"程序设计"},{"count":276,"name":"C\/C++","title":"C\/C++"},{"count":180,"name":"Programming","title":"Programming"}],"origin_title":"Pointers on C","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s2996168.jpg","binding":"平装","translator":["徐波"],"catalog":"第1章 快速上手\n1.1 简介\n1.1.1 空白和注释\n1.1.2 预处理指令\n1.1.3 main函数\n1.1.4 read_column_numbers函数\n1.1.5 rearrange函数\n1.2 补充说明\n1.3 编译\n1.4 总结\n1.5 警告的总结\n1.6 编程提示的总结\n1.7 问题\n1.8 编程练习\n第2章 基本概念\n2.1 环境\n2.1.1 翻译\n2.1.2 执行\n2.2 词法规则\n2.2.1 字符\n2.2.2 注释\n2.2.3 自由形式的源代码\n2.2.4 标识符\n2.2.5 程序的形式\n2.3 程序风格\n2.4 总结\n2.5 警告的总结\n2.6 编程提示的总结\n2.7 问题\n2.8 编程练习\n第3章 数据\n第4章 语句\n第5章 操作符和表达式\n第6章 指针\n第7章 函数\n第8章 数组\n第9章 字符串、字符和字节\n第10章 结构和联合\n第11章 动态内存分配\n第12章 使用结构和指针\n第13章 高级指针话题\n第14章 预处理器\n第15章 输入\/输出函数\n第16章 标准函数库\n第17章 经典抽象数据类型\n第18章 运行时环境\n附录 部分问题答案\n索引\n参考文献","pages":"448","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s2996168.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s2996168.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s2996168.jpg"},"alt":"https:\/\/book.douban.com\/subject\/3012360\/","id":"3012360","publisher":"人民邮电出版社","isbn10":"7115172013","isbn13":"9787115172013","title":"C和指针","url":"https:\/\/api.douban.com\/v2\/book\/3012360","alt_title":"Pointers on C","author_intro":"Kenneth·Reek是罗彻斯特理工大学计算机科学教授。他是一位经验丰富的C程序员，曾为多家公司担任过技术顾问。他讲授的课程有操作系统、数据通信、计算机网络、形式语言、算法分析和交换系统等。本书正是基于他9年的编程及教学的经验积累。","summary":"本书提供与C语言编程相关的全面资源和深入讨论。本书通过对指针的基础知识和高级特性的探讨，帮助程序员把指针的强大功能融入到自己的程序中去。\n全书共18章，覆盖了数据、语句、操作符和表达式、指针、函数、数组、字符串、结构和联合等几乎所有重要的C编程话题。书中给出了很多编程技巧和提示，每章后面有针对性很强的练习，附录部分则给出了部分练习的解答。\n本书适合C语言初学者和初级C程序员阅读，也可作为计算机专业学生学习C语言的参考。","series":{"id":"9931","title":"C和C++经典著作"},"price":"65.00元"},{"rating":{"max":10,"numRaters":1270,"average":"9.6","min":0},"subtitle":"-","author":["Brian W. Kernighan","Dennis M. Ritchie"],"pubdate":"1988-4-1","tags":[{"count":611,"name":"c","title":"c"},{"count":434,"name":"Programming","title":"Programming"},{"count":403,"name":"C语言","title":"C语言"},{"count":382,"name":"编程","title":"编程"},{"count":316,"name":"计算机","title":"计算机"},{"count":240,"name":"经典","title":"经典"},{"count":218,"name":"C","title":"C"},{"count":205,"name":"程序设计","title":"程序设计"}],"origin_title":"","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s29586132.jpg","binding":"Paperback","translator":[],"catalog":"","pages":"274","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s29586132.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s29586132.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s29586132.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1236999\/","id":"1236999","publisher":"Prentice Hall","isbn10":"0131103628","isbn13":"9780131103627","title":"The  C Programming Language","url":"https:\/\/api.douban.com\/v2\/book\/1236999","alt_title":"C Programming Language","author_intro":"Brian W. Kernighan works in the Computing Science Research Center at Bell Laboratories, Lucent Technologies. He is Consulting Editor for Addison-Wesley's Professional Computing Series and the author, with Dennis Ritchie, of The C Programming Language.\nDennis Ritchie is a computer scientist notable for his influence on ALTRAN, B, BCPL, C, Multics, and Unix.","summary":"Presents a complete guide to ANSI standard C language programming. Written by the developers of C, this new version helps readers keep up with the finalized ANSI standard for C while showing how to take advantage of C's rich set of operators, economy of expression, improved control flow, and data structures. This 2nd edition has been completely rewritten with additional examples and problem sets to clarify the implementation of difficult language constructs. 7 x 9 1\/4.","price":"USD 67.00"},{"rating":{"max":10,"numRaters":604,"average":"9.3","min":0},"subtitle":"第六版","author":["普拉达 (Stephen Prata)"],"pubdate":"2016-4-1","tags":[{"count":347,"name":"C语言","title":"C语言"},{"count":231,"name":"C","title":"C"},{"count":215,"name":"编程","title":"编程"},{"count":183,"name":"计算机","title":"计算机"},{"count":142,"name":"计算机科学","title":"计算机科学"},{"count":125,"name":"经典","title":"经典"},{"count":86,"name":"C++","title":"C++"},{"count":78,"name":"软件开发","title":"软件开发"}],"origin_title":"C Primer Plus : 6th","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s29438897.jpg","binding":"平装","translator":["姜佑"],"catalog":"第1章　初识C语言\t1\n1．1　C语言的起源\t1\n1．2 选择C语言的理由\t1\n1．2．1 设计特性\t1\n1．2．2 高效性\t1\n1．2．3 可移植性\t2\n1．2．4 强大而灵活\t3\n1．2．5 面向程序员\t3\n1．2．6 缺点\t3\n1．3 C语言的应用范围\t3\n1．4 计算机能做什么\t4\n1．5 高级计算机语言和编译器\t5\n1．6 语言标准\t6\n1．6．1 第1个ANSI\/ISO C标准\t6\n1．6．2 C99标准\t6\n1．6．3 C11标准\t7\n1．7 使用C语言的7个步骤\t7\n1．7．1 第1步：定义程序的目标\t8\n1．7．2 第2步：设计程序\t8\n1．7．3 第3步：编写代码\t8\n1．7．4 第4步：编译\t8\n1．7．5 第5步：运行程序\t9\n1．7．6 第6步：测试和调试程序\t9\n1．7．7 第7步：维护和修改代码\t9\n1．7．8 说明\t9\n1．8 编程机制\t10\n1．8．1 目标代码文件、可执行文件和库\t10\n1．8．2 UNIX系统\t11\n1．8．3 GNU编译器集合和LLVM项目\t13\n1．8．4 Linux系统\t13\n1．8．5 PC的命令行编译器\t14\n1．8．6 集成开发环境（Windows）\t14\n1．8．7 Windows\/Linux\t15\n1．8．8 Macintosh中的C\t15\n1．9 本书的组织结构\t15\n1．10 本书的约定\t16\n1．10．1 字体\t16\n1．10．2 程序输出\t16\n1．10．3 特殊元素\t17\n1．11 本章小结\t17\n1．12 复习题\t18\n1．13 编程练习\t18\n第2章　C语言概述\t19\n2．1 简单的C程序示例\t19\n2．2 示例解释\t20\n2．2．1 第1遍：快速概要\t21\n2．2．2 第2遍：程序细节\t21\n2．3 简单程序的结构\t28\n2．4 提高程序可读性的技巧\t28\n2．5 进一步使用C\t29\n2．5．1 程序说明\t30\n2．5．2 多条声明\t30\n2．5．3 乘法\t30\n2．5．4 打印多个值\t30\n2．6 多个函数\t30\n2．7 调试程序\t32\n2．7．1 语法错误\t32\n2．7．2 语义错误\t33\n2．7．3 程序状态\t34\n2．8 关键字和保留标识符\t34\n2．9 关键概念\t35\n2．10 本章小结\t35\n2．11 复习题\t36\n2．12 编程练习\t37\n第3章　数据和C\t39\n3．1 示例程序\t39\n3．2 变量与常量数据\t42\n3．3 数据：数据类型关键字\t42\n3．3．1 整数和浮点数\t43\n3．3．2 整数\t43\n3．3．3 浮点数\t43\n3．4 C语言基本数据类型\t44\n3．4．1 int类型\t44\n3．4．2 其他整数类型\t47\n3．4．3 使用字符：char类型\t50\n3．4．4 _Bool类型\t54\n3．4．5 可移植类型：stdint．h和inttypes．h\t55\n3．4．6 float、double和long double\t56\n3．4．7 复数和虚数类型\t60\n3．4．8 其他类型\t60\n3．4．9 类型大小\t62\n3．5 使用数据类型\t63\n3．6 参数和陷阱\t63\n3．7 转义序列示例\t64\n3．7．1 程序运行情况\t65\n3．7．2 刷新输出\t65\n3．8 关键概念\t66\n3．9 本章小结\t66\n3．10 复习题\t67\n3．11 编程练习\t68\n第4章　字符串和格式化输入\/输出\t71\n4．1 前导程序\t71\n4．2 字符串简介\t72\n4．2．1 char类型数组和null字符\t72\n4．2．2 使用字符串\t73\n4．2．3 strlen()函数\t74\n4．3 常量和C预处理器\t76\n4．3．1 const限定符\t78\n4．3．2 明示常量\t78\n4．4 printf()和scanf()\t80\n4．4．1 printf()函数\t80\n4．4．2 使用printf()\t81\n4．4．3 printf()的转换说明修饰符\t83\n4．4．4 转换说明的意义\t87\n4．4．5 使用scanf()\t92\n4．4．6 printf()和scanf()的*修饰符\t95\n4．4．7 printf()的用法提示\t97\n4．5 关键概念\t98\n4．6 本章小结\t98\n4．7 复习题\t99\n4．8 编程练习\t100\n第5章　运算符、表达式和语句\t103\n5．1 循环简介\t103\n5．2 基本运算符\t105\n5．2．1 赋值运算符：=\t105\n5．2．2 加法运算符：+\t107\n5．2．3 减法运算符：-\t107\n5．2．4 符号运算符：-和+\t107\n5．2．5 乘法运算符：*\t108\n5．2．6 除法运算符：\/\t110\n5．2．7 运算符优先级\t110\n5．2．8 优先级和求值顺序\t112\n5．3 其他运算符\t113\n5．3．1 sizeof运算符和size_t类型\t113\n5．3．2 求模运算符：%\t114\n5．3．3 递增运算符：++\t115\n5．3．4 递减运算符：--\t118\n5．3．5 优先级\t118\n5．3．6 不要自作聪明\t119\n5．4 表达式和语句\t120\n5．4．1 表达式\t120\n5．4．2 语句\t120\n5．4．3 复合语句（块）\t123\n5．5 类型转换\t124\n5．6 带参数的函数\t127\n5．7 示例程序\t129\n5．8 关键概念\t130\n5．9 本章小结\t130\n5．10 复习题\t131\n5．11 编程练习\t134\n第6章　C控制语句：循环\t137\n6．1 再探while循环\t137\n6．1．1 程序注释\t138\n6．1．2 C风格读取循环\t139\n6．2 while语句\t140\n6．2．1 终止while循环\t140\n6．2．2 何时终止循环\t141\n6．2．3 while：入口条件循环\t141\n6．2．4 语法要点\t141\n6．3 用关系运算符和表达式比较大小\t143\n6．3．1 什么是真\t144\n6．3．2 其他真值\t145\n6．3．3 真值的问题\t146\n6．3．4 新的_Bool类型\t147\n6．3．5 优先级和关系运算符\t148\n6．4 不确定循环和计数循环\t150\n6．5 for循环\t151\n6．6 其他赋值运算符：+=、-=、*=、\/=、%=\t155\n6．7 逗号运算符\t156\n6．8 出口条件循环：do while\t159\n6．9 如何选择循环\t161\n6．10 嵌套循环\t162\n6．10．1 程序分析\t163\n6．10．2 嵌套变式\t163\n6．11 数组简介\t164\n6．12 使用函数返回值的循环示例\t166\n6．12．1 程序分析\t168\n6．12．2 使用带返回值的函数\t169\n6．13 关键概念\t169\n6．14 本章小结\t170\n6．15 复习题\t170\n6．16 编程练习\t174\n第7章　C控制语句：分支和跳转\t177\n7．1 if语句\t177\n7．2 if else语句\t179\n7．2．1 另一个示例：介绍getchar()和putchar()\t180\n7．2．2 ctype．h系列的字符函数\t182\n7．2．3 多重选择else if\t184\n7．2．4 else与if配对\t186\n7．2．5 多层嵌套的if语句\t187\n7．3 逻辑运算符\t190\n7．3．1 备选拼写：iso646．h头文件\t191\n7．3．2 优先级\t192\n7．3．3 求值顺序\t192\n7．3．4 范围\t193\n7．4 一个统计单词的程序\t194\n7．5 条件运算符：?：\t196\n7．6 循环辅助：continue和break\t198\n7．6．1 continue语句\t198\n7．6．2 break语句\t200\n7．7 多重选择：switch和break\t202\n7．7．1 switch语句\t204\n7．7．2 只读每行的首字符\t205\n7．7．3 多重标签\t206\n7．7．4 switch和if else\t208\n7．8 goto语句\t208\n7．9 关键概念\t211\n7．10 本章小结\t211\n7．11 复习题\t212\n7．12 编程练习\t214\n第8章　字符输入\/输出和输入验证\t217\n8．1 单字符I\/O：getchar()和putchar()\t217\n8．2 缓冲区\t218\n8．3 结束键盘输入\t219\n8．3．1 文件、流和键盘输入\t219\n8．3．2 文件结尾\t220\n8．4 重定向和文件\t222\n8．5 创建更友好的用户界面\t226\n8．5．1 使用缓冲输入\t226\n8．5．2 混合数值和字符输入\t228\n8．6 输入验证\t230\n8．6．1 分析程序\t234\n8．6．2 输入流和数字\t234\n8．7 菜单浏览\t235\n8．7．1 任务\t235\n8．7．2 使执行更顺利\t235\n8．7．3 混合字符和数值输入\t237\n8．8 关键概念\t240\n8．9 本章小结\t240\n8．10 复习题\t241\n8．11 编程练习\t241\n第9章　函数\t243\n9．1 复习函数\t243\n9．1．1 创建并使用简单函数\t244\n9．1．2 分析程序\t245\n9．1．3 函数参数\t247\n9．1．4 定义带形式参数的函数\t248\n9．1．5 声明带形式参数函数的原型\t249\n9．1．6 调用带实际参数的函数\t249\n9．1．7 黑盒视角\t250\n9．1．8 使用return从函数中返回值\t250\n9．1．9 函数类型\t252\n9．2 ANSI C函数原型\t253\n9．2．1 问题所在\t253\n9．2．2 ANSI的解决方案\t254\n9．2．3 无参数和未指定参数\t255\n9．2．4 函数原型的优点\t256\n9．3 递归\t256\n9．3．1 演示递归\t256\n9．3．2 递归的基本原理\t258\n9．3．3 尾递归\t258\n9．3．4 递归和倒序计算\t260\n9．3．5 递归的优缺点\t262\n9．4 编译多源代码文件的程序\t262\n9．4．1 UNIX\t263\n9．4．2 Linux\t263\n9．4．3 DOS命令行编译器\t263\n9．4．4 Windows和苹果的IDE编译器\t263\n9．4．5 使用头文件\t263\n9．5 查找地址：&运算符\t267\n9．6 更改主调函数中的变量\t268\n9．7 指针简介\t269\n9．7．1 间接运算符：*\t270\n9．7．2 声明指针\t270\n9．7．3 使用指针在函数间通信\t271\n9．8 关键概念\t274\n9．9 本章小结\t275\n9．10　复习题\t275\n9．11 编程练习\t276\n第10章　数组和指针\t277\n10．1 数组\t277\n10．1．1 初始化数组\t277\n10．1．2 指定初始化器（C99）\t281\n10．1．3 给数组元素赋值\t282\n10．1．4 数组边界\t282\n10．1．5 指定数组的大小\t284\n10．2 多维数组\t284\n10．2．1 初始化二维数组\t287\n10．2．2 其他多维数组\t288\n10．3 指针和数组\t288\n10．4 函数、数组和指针\t290\n10．4．1 使用指针形参\t293\n10．4．2 指针表示法和数组表示法\t294\n10．5 指针操作\t295\n10．6 保护数组中的数据\t298\n10．6．1 对形式参数使用const\t299\n10．6．2　const的其他内容\t300\n10．7 指针和多维数组\t302\n10．7．1 指向多维数组的指针\t304\n10．7．2 指针的兼容性\t305\n10．7．3 函数和多维数组\t306\n10．8 变长数组（VLA）\t309\n10．9 复合字面量\t312\n10．10 关键概念\t314\n10．11 本章小结\t315\n10．12 复习题\t316\n10．13 编程练习\t317\n第11章　字符串和字符串函数\t321\n11．1 表示字符串和字符串I\/O\t321\n11．1．1 在程序中定义字符串\t322\n11．1．2 指针和字符串\t328\n11．2 字符串输入\t329\n11．2．1 分配空间\t329\n11．2．2 不幸的gets()函数\t330\n11．2．3 gets()的替代品\t331\n11．2．4 scanf()函数\t336\n11．3 字符串输出\t337\n11．3．1 puts()函数\t338\n11．3．2 fputs()函数\t339\n11．3．3 printf()函数\t339\n11．4 自定义输入\/输出函数\t340\n11．5 字符串函数\t342\n11．5．1 strlen()函数\t342\n11．5．2 strcat()函数\t343\n11．5．3 strncat()函数\t345\n11．5．4 strcmp()函数\t346\n11．5．5 strcpy()和strncpy()函数\t351\n11．5．6 sprintf()函数\t356\n11．5．7 其他字符串函数\t357\n11．6 字符串示例：字符串排序\t359\n11．6．1 排序指针而非字符串\t360\n11．6．2 选择排序算法\t361\n11．7 ctype．h字符函数和字符串\t362\n11．8 命令行参数\t363\n11．8．1 集成环境中的命令行参数\t365\n11．8．2 Macintosh中的命令行参数\t365\n11．9 把字符串转换为数字\t365\n11．10 关键概念\t368\n11．11 本章小结\t368\n11．12 复习题\t369\n11．13 编程练习\t371\n第12章　存储类别、链接和内存管理\t373\n12．1 存储类别\t373\n12．1．1 作用域\t374\n12．1．2 链接\t376\n12．1．3 存储期\t376\n12．1．4 自动变量\t377\n12．1．5 寄存器变量\t380\n12．1．6 块作用域的静态变量\t381\n12．1．7 外部链接的静态变量\t382\n12．1．8 内部链接的静态变量\t386\n12．1．9 多文件\t386\n12．1．10 存储类别说明符\t387\n12．1．11 存储类别和函数\t389\n12．1．12 存储类别的选择\t389\n12．2 随机数函数和静态变量\t390\n12．3 掷骰子\t393\n12．4 分配内存：malloc()和free()\t396\n12．4．1 free()的重要性\t399\n12．4．2 calloc()函数\t400\n12．4．3 动态内存分配和变长数组\t400\n12．4．4 存储类别和动态内存分配\t401\n12．5 ANSI C类型限定符\t402\n12．5．1 const类型限定符\t403\n12．5．2 volatile类型限定符\t404\n12．5．3 restrict类型限定符\t405\n12．5．4 _Atomic类型限定符（C11）\t406\n12．5．5 旧关键字的新位置\t406\n12．6　关键概念\t407\n12．7 本章小结\t407\n12．8 复习题\t408\n12．9 编程练习\t409\n第13章　文件输入\/输出\t413\n13．1 与文件进行通信\t413\n13．1．1 文件是什么\t413\n13．1．2 文本模式和二进制模式\t413\n13．1．3 I\/O的级别\t415\n13．1．4 标准文件\t415\n13．2 标准I\/O\t415\n13．2．1 检查命令行参数\t416\n13．2．2 fopen()函数\t416\n13．2．3 getc()和putc()函数\t417\n13．2．4 文件结尾\t418\n13．2．5 fclose()函数\t419\n13．2．6 指向标准文件的指针\t419\n13．3 一个简单的文件压缩程序\t419\n13．4 文件I\/O：fprintf()、fscanf()、fgets()和fputs()\t421\n13．4．1 fprintf()和fscanf()函数\t421\n13．4．2 fgets()和fputs()函数\t422\n13．5 随机访问：fseek()和ftell()\t423\n13．5．1 fseek()和ftell()的工作原理\t424\n13．5．2 二进制模式和文本模式\t425\n13．5．3 可移植性\t425\n13．5．4 fgetpos()和fsetpos()函数\t426\n13．6 标准I\/O的机理\t426\n13．7 其他标准I\/O函数\t427\n13．7．1 int ungetc(int c， FILE *fp)函数\t427\n13．7．2 int fflush()函数\t428\n13．7．3 int setvbuf()函数\t428\n13．7．4 二进制I\/O：fread()和fwrite()\t428\n13．7．5 size_t fwrite()函数\t429\n13．7．6 size_t fread()函数\t430\n13．7．7 int feof(FILE *fp)和int ferror(FILE *fp)函数\t430\n13．7．8 一个程序示例\t430\n13．7．9 用二进制I\/O进行随机访问\t433\n13．8 关键概念\t435\n13．9 本章小结\t435\n13．10 复习题\t435\n13．11 编程练习\t437\n第14章　结构和其他数据形式\t439\n14．1 示例问题：创建图书目录\t439\n14．2 建立结构声明\t441\n14．3 定义结构变量\t441\n14．3．1 初始化结构\t442\n14．3．2 访问结构成员\t443\n14．3．3 结构的初始化器\t443\n14．4 结构数组\t444\n14．4．1 声明结构数组\t446\n14．4．2 标识结构数组的成员\t447\n14．4．3 程序讨论\t447\n14．5 嵌套结构\t448\n14．6 指向结构的指针\t449\n14．6．1 声明和初始化结构指针\t450\n14．6．2 用指针访问成员\t451\n14．7 向函数传递结构的信息\t451\n14．7．1 传递结构成员\t451\n14．7．2 传递结构的地址\t452\n14．7．3 传递结构\t453\n14．7．4 其他结构特性\t454\n14．7．5 结构和结构指针的选择\t458\n14．7．6 结构中的字符数组和字符指针\t458\n14．7．7 结构、指针和malloc()\t459\n14．7．8 复合字面量和结构（C99）\t462\n14．7．9 伸缩型数组成员（C99）\t463\n14．7．10 匿名结构（C11）\t465\n14．7．11 使用结构数组的函数\t466\n14．8 把结构内容保存到文件中\t467\n14．8．1 保存结构的程序示例\t468\n14．8．2 程序要点\t470\n14．9 链式结构\t471\n14．10 联合简介\t472\n14．10．1 使用联合\t472\n14．10．2 匿名联合（C11）\t473\n14．11 枚举类型\t474\n14．11．1 enum常量\t475\n14．11．2 默认值\t475\n14．11．3 赋值\t475\n14．11．4 enum的用法\t476\n14．11．5 共享名称空间\t477\n14．12 typedef简介\t478\n14．13 其他复杂的声明\t479\n14．14 函数和指针\t481\n14．15 关键概念\t487\n14．16 本章小结\t487\n14．17 复习题\t488\n14．18 编程练习\t490\n第15章　位操作\t493\n15．1 二进制数、位和字节\t493\n15．1．1 二进制整数\t494\n15．1．2 有符号整数\t494\n15．1．3 二进制浮点数\t495\n15．2 其他进制数\t495\n15．2．1 八进制\t495\n15．2．2 十六进制\t496\n15．3 C按位运算符\t496\n15．3．1 按位逻辑运算符\t497\n15．3．2 用法：掩码\t498\n15．3．3 用法：打开位（设置位）\t498\n15．3．4 用法：关闭位（清空位）\t499\n15．3．5 用法：切换位\t499\n15．3．6 用法：检查位的值\t500\n15．3．7 移位运算符\t500\n15．3．8 编程示例\t501\n15．3．9 另一个例子\t503\n15．4 位字段\t505\n15．4．1 位字段示例\t506\n15．4．2 位字段和按位运算符\t509\n15．5 对齐特性（C11）\t515\n15．6 关键概念\t516\n15．7 本章小结\t516\n15．8 复习题\t517\n15．9 编程练习\t518\n第16章　C预处理器和C库\t521\n16．1 翻译程序的第一步\t521\n16．2 明示常量：#define\t522\n16．2．1 记号\t525\n16．2．2 重定义常量\t525\n16．3 在#define中使用参数\t525\n16．3．1 用宏参数创建字符串：#运算符\t527\n16．3．2 预处理器黏合剂：##运算符\t528\n16．3．3 变参宏：．．．和_ _VA_ARGS_ _\t529\n16．4 宏和函数的选择\t530\n16．5 文件包含：#include\t531\n16．5．1 头文件示例\t531\n16．5．2 使用头文件\t533\n16．6 其他指令\t534\n16．6．1 #undef指令\t534\n16．6．2 从C预处理器角度看已定义\t534\n16．6．3 条件编译\t535\n16．6．4 预定义宏\t539\n16．6．5 #line和#error\t540\n16．6．6 #pragma\t540\n16．6．7 泛型选择（C11）\t541\n16．7 内联函数（C99）\t542\n16．8 _Noreturn函数（C11）\t544\n16．9 C库\t544\n16．9．1 访问C库\t544\n16．9．2 使用库描述\t545\n16．10 数学库\t546\n16．10．1 三角问题\t547\n16．10．2 类型变体\t548\n16．10．3 tgmath．h库（C99）\t550\n16．11 通用工具库\t550\n16．11．1 exit()和atexit()函数\t550\n16．11．2 qsort()函数\t552\n16．12 断言库\t556\n16．12．1 assert的用法\t556\n16．12．2 _Static_assert（C11）\t557\n16．13 string．h库中的memcpy()和memmove()\t558\n16．14 可变参数：stdarg．h\t560\n16．15 关键概念\t562\n16．16 本章小结\t562\n16．17 复习题\t562\n16．18 编程练习\t563\n第17章　高级数据表示\t567\n17．1 研究数据表示\t567\n17．2 从数组到链表\t570\n17．2．1 使用链表\t572\n17．2．2 反思\t576\n17．3 抽象数据类型（ADT）\t576\n17．3．1 建立抽象\t577\n17．3．2 建立接口\t578\n17．3．3 使用接口\t581\n17．3．4 实现接口\t583\n17．4 队列ADT\t589\n17．4．1 定义队列抽象数据类型\t590\n17．4．2 定义一个接口\t590\n17．4．3 实现接口数据表示\t591\n17．4．4 测试队列\t598\n17．5 用队列进行模拟\t600\n17．6 链表和数组\t605\n17．7 二叉查找树\t608\n17．7．1 二叉树ADT\t608\n17．7．2 二叉查找树接口\t609\n17．7．3 二叉树的实现\t611\n17．7．4 使用二叉树\t624\n17．7．5 树的思想\t628\n17．8 其他说明\t629\n17．9 关键概念\t630\n17．10 本章小结\t630\n17．11 复习题\t630\n17．12 编程练习\t631\n附录A　复习题答案\t633\n附录B　参考资料\t665\nB．1 参考资料I：补充阅读\t665\nB．2 参考资料II：C运算符\t667\nB．3 参考资料III：基本类型和存储类别\t671\nB．4 参考资料IV：表达式、语句和程序流\t675\nB．5 参考资料V：新增C99和C11的ANSI C库\t679\nB．6 参考资料VI：扩展的整数类型\t714\nB．7 参考资料VII：扩展字符支持\t716\nB．8 参考资料VIII：C99\/C11数值计算增强\t720\nB．9 参考资料IX：C和C++的区别\t726","pages":"730","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s29438897.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s29438897.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s29438897.jpg"},"alt":"https:\/\/book.douban.com\/subject\/26792521\/","id":"26792521","publisher":"人民邮电出版社","isbn10":"7115390592","isbn13":"9787115390592","title":"C Primer Plus（第6版）中文版","url":"https:\/\/api.douban.com\/v2\/book\/26792521","alt_title":"C Primer Plus : 6th","author_intro":"Stephen Prata曾在加利福尼亚的马林学院（肯特菲尔德）教授天文学、物理学和程序设计课程，现已退休。他在加州理工学院获得学士学位，在加州大学伯克利分校获得博士学位。他接触程序设计，是为了利用计算机给星团建模。Stephen撰写和与他人合著了十几本书籍，其中包括C++ Primer Plus和Unix Primer Plus。","summary":"《C Primer Plus（第6版）中文版》详细讲解了C语言的基本概念和编程技巧。\n《C Primer Plus（第6版）中文版》共17章。第1、2章介绍了C语言编程的预备知识。第3~15章详细讲解了C语言的相关知识，包括数据类型、格式化输入\/输出、运算符、表达式、语句、循环、字符输入和输出、函数、数组和指针、字符和字符串函数、内存管理、文件输入输出、结构、位操作等。第16章、17章介绍C预处理器、C库和高级数据表示。本书以完整的程序为例，讲解C语言的知识要点和注意事项。每章末设计了大量复习题和编程练习，帮助读者巩固所学知识和提高实际编程能力。附录给出了各章复习题的参考答案和丰富的参考资料。\n《C Primer Plus（第6版）中文版》可作为C语言的教材，适用于需要系统学习C语言的初学者，也适用于巩固C语言知识或希望进一步提高编程技术的程序员。","series":{"id":"23545","title":"C和C++实务精选"},"price":"CNY 89.00"},{"rating":{"max":10,"numRaters":389,"average":"9.3","min":0},"subtitle":"现代方法","author":["K. N. King"],"pubdate":"2010-4","tags":[{"count":526,"name":"C语言","title":"C语言"},{"count":315,"name":"C","title":"C"},{"count":240,"name":"程序设计","title":"程序设计"},{"count":239,"name":"编程","title":"编程"},{"count":230,"name":"计算机","title":"计算机"},{"count":182,"name":"C\/C++","title":"C\/C++"},{"count":162,"name":"编程语言","title":"编程语言"},{"count":128,"name":"计算机科学","title":"计算机科学"}],"origin_title":"C Programming: A Modern Approach, Second Edition","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s4171870.jpg","binding":"平装","translator":["吕秀锋","黄倩"],"catalog":"第1章 C语言概述1\n1.1 C语言的历史1\n1.1.1 起源1\n1.1.2 标准化1\n1.1.3 基于C的语言2\n1.2 C语言的优缺点3\n1.2.1 C语言的优点3\n1.2.2 C语言的缺点3\n1.2.3 高效地使用C语言4\n问与答5\n第2章 C语言基本概念7\n2.1 编写一个简单的C程序7\n程序显示双关语7\n2.1.1 编译和链接8\n2.1.2 集成开发环境8\n2.2 简单程序的一般形式9\n2.2.1 指令9\n2.2.2 函数9\n2.2.3 语句10\n2.2.4 显示字符串10\n2.3 注释11\n2.4 变量和赋值12\n2.4.1 类型12\n2.4.2 声明13\n2.4.3 赋值13\n2.4.4 显示变量的值14\n程序计算箱子的空间重量14\n2.4.5 初始化15\n2.4.6 显示表达式的值16\n2.5 读入输入16\n程序计算箱子的空间重量（改进版）16\n2.6 定义常量的名字17\n程序华氏温度转换为摄氏温度17\n2.7 标识符18\n2.8 C程序的书写规范19\n问与答21\n练习题23\n编程题24\n第3章 格式化输入\/输出26\n3.1 printf函数26\n3.1.1 转换说明27\n程序用printf函数格式化数28\n3.1.2 转义序列28\n3.2 scanf函数29\n3.2.1 scanf函数的工作方法30\n3.2.2 格式串中的普通字符31\n3.2.3 易混淆的printf函数和scanf函数32\n程序分数相加32\n问与答33\n练习题34\n编程题35\n第4章 表达式36\n4.1 算术运算符36\n程序计算通用产品代码的校验位38\n4.2 赋值运算符39\n4.2.1 简单赋值40\n4.2.2 左值41\n4.2.3 复合赋值41\n4.3 自增运算符和自减运算符42\n4.4 表达式求值43\n4.5 表达式语句45\n问与答45\n练习题47\n编程题49\n第5章 选择语句50\n5.1 逻辑表达式50\n5.1.1 关系运算符50\n5.1.2 判等运算符51\n5.1.3 逻辑运算符51\n5.2 if语句52\n5.2.1 复合语句53\n5.2.2 else子句53\n5.2.3 级联式if语句54\n程序计算股票经纪人的佣金55\n5.2.4 “悬空else”的问题56\n5.2.5 条件表达式57\n5.2.6 C89中的布尔值58\n5.2.7 C99中的布尔值58\n5.3 switch语句59\n程序显示法定格式的日期61\n问与答62\n练习题65\n编程题67\n第6章 循环69\n6.1 while语句69\n程序显示平方表71\n程序数列求和71\n6.2 do语句72\n程序计算整数的位数73\n6.3 for语句73\n6.3.1 for语句的惯用法74\n6.3.2 在for语句中省略表达式75\n6.3.3 C99中的for语句75\n6.3.4 逗号运算符76\n程序显示平方表（改进版）77\n6.4 退出循环78\n6.4.1 break语句78\n6.4.2 continue语句78\n6.4.3 goto语句79\n程序账簿结算80\n6.5 空语句81\n问与答83\n练习题84\n编程题85\n第7章 基本类型88\n7.1 整数类型88\n7.1.1 C99中的整数类型90\n7.1.2 整数常量90\n7.1.3 C99中的整数常量91\n7.1.4 整数溢出91\n7.1.5 读\/写整数91\n程序数列求和（改进版）92\n7.2 浮点类型93\n7.2.1 浮点常量94\n7.2.2 读\/写浮点数94\n7.3 字符类型94\n7.3.1 字符操作95\n7.3.2 有符号字符和无符号字符95\n7.3.3 算术类型96\n7.3.4 转义序列96\n7.3.5 字符处理函数97\n7.3.6 用scanf和printf读\/写字符98\n7.3.7 用getchar和putchar读\/写字符98\n程序确定消息的长度99\n7.4 类型转换100\n7.4.1 常用算术转换101\n7.4.2 赋值过程中的转换102\n7.4.3 C99中的隐式转换103\n7.4.4 强制类型转换103\n7.5 类型定义105\n7.5.1 类型定义的优点105\n7.5.2 类型定义和可移植性105\n7.6 sizeof运算符106\n问与答107\n练习题109\n编程题110\n第8章 数组113\n8.1 一维数组113\n8.1.1 数组下标113\n程序数列反向115\n8.1.2 数组初始化115\n8.1.3 指定初始化式116\n程序检查数中重复出现的数字116\n8.1.4 对数组使用sizeof运算符117\n程序计算利息118\n8.2 多维数组119\n8.2.1 多维数组初始化120\n8.2.2 常量数组121\n程序发牌121\n8.3 C99中的变长数组122\n问与答123\n练习题124\n编程题125\n第9章 函数129\n9.1 函数的定义和调用129\n程序计算平均值129\n程序显示倒计数130\n程序显示双关语（改进版）131\n9.1.1 函数定义132\n9.1.2 函数调用133\n程序判定素数134\n9.2 函数声明135\n9.3 实际参数136\n9.3.1 实际参数的转换137\n9.3.2 数组型实际参数138\n9.3.3 变长数组形式参数140\n9.3.4 在数组参数声明中使用static141\n9.3.5 复合字面量141\n9.4 return语句142\n9.5 程序终止143\n9.6 递归144\n程序快速排序146\n问与答147\n练习题150\n编程题153\n第10章 程序结构155\n10.1 局部变量155\n10.1.1 静态局部变量156\n10.1.2 形式参数156\n10.2 外部变量156\n10.2.1 示例：用外部变量实现栈156\n10.2.2 外部变量的利与弊157\n程序猜数158\n10.3 程序块161\n10.4 作用域162\n10.5 构建C程序163\n程序给一手牌分类163\n问与答169\n练习题169\n编程题170\n第11章 指针172\n11.1 指针变量172\n11.2 取地址运算符和间接寻址运算符173\n11.2.1 取地址运算符173\n11.2.2 间接寻址运算符174\n11.3 指针赋值174\n11.4 指针作为参数176\n程序找出数组中的最大元素和最小元素177\n11.5 指针作为返回值179\n问与答180\n练习题181\n编程题182\n第12章 指针和数组184\n12.1 指针的算术运算184\n12.1.1 指针加上整数185\n12.1.2 指针减去整数185\n12.1.3 两个指针相减186\n12.1.4 指针比较186\n12.1.5 指向复合常量的指针186\n12.2 指针用于数组处理186\n12.3 用数组名作为指针188程序数列反向（改进版）189\n12.3.1 数组型实际参数（改进版）189\n12.3.2 用指针作为数组名191\n12.4 指针和多维数组191\n12.4.1 处理多维数组的元素191\n12.4.2 处理多维数组的行192\n12.4.3 处理多维数组的列192\n12.4.4 用多维数组名作为指针192\n12.5 C99中的指针和变长数组193\n问与答194\n练习题195\n编程题197\n第13章 字符串198\n13.1 字符串字面量198\n13.1.1 字符串字面量中的转义序列198\n13.1.2 延续字符串字面量199\n13.1.3 如何存储字符串字面量199\n13.1.4 字符串字面量的操作200\n13.1.5 字符串字面量与字符常量200\n13.2 字符串变量200\n13.2.1 初始化字符串变量201\n13.2.2 字符数组与字符指针202\n13.3 字符串的读和写203\n13.3.1 用printf函数和puts函数写字符串203\n13.3.2 用scanf函数和gets函数读字符串203\n13.3.3 逐个字符读字符串204\n13.4 访问字符串中的字符205\n13.5 使用C语言的字符串库206\n13.5.1 strcpy函数207\n13.5.2 strlen函数208\n13.5.3 strcat函数208\n13.5.4 strcmp函数209程序显示一个月的提醒列表209\n13.6 字符串惯用法211\n13.6.1 搜索字符串的结尾211\n13.6.2 复制字符串213\n13.7 字符串数组214\n程序核对行星的名字217\n问与答218\n练习题220\n编程题222\n第14章 预处理器225\n14.1 预处理器的工作原理225\n14.2 预处理指令227\n14.3 宏定义227\n14.3.1 简单的宏227\n14.3.2 带参数的宏229\n14.3.3 #运算符231\n14.3.4 ##运算符231\n14.3.5 宏的通用属性232\n14.3.6 宏定义中的圆括号233\n14.3.7 创建较长的宏233\n14.3.8 预定义宏234\n14.3.9 C99中新增的预定义宏235\n14.3.10 空的宏参数236\n14.3.11 参数个数可变的宏236\n14.3.12 __func__标识符237\n14.4 条件编译237\n14.4.1 #if指令和#endif指令238\n14.4.2 defined运算符238\n14.4.3 #ifdef指令和#ifndef指令239\n14.4.4 #elif指令和#else指令239\n14.4.5 使用条件编译240\n14.5 其他指令240\n14.5.1 #error指令240\n14.5.2 #line指令241\n14.5.3 #pragma指令242\n14.5.4 _Pragma运算符242\n问与答243\n练习题245\n第15章 编写大型程序248\n15.1 源文件248\n15.2 头文件249\n15.2.1 #include指令249\n15.2.2 共享宏定义和类型定义250\n15.2.3 共享函数原型251\n15.2.4 共享变量声明252\n15.2.5 嵌套包含253\n15.2.6 保护头文件253\n15.2.7 头文件中的#error指令254\n15.3 把程序划分成多个文件254程序文本格式化255\n15.4 构建多文件程序260\n15.4.1 makefile260\n15.4.2 链接期间的错误262\n15.4.3 重新构建程序262\n15.4.4 在程序外定义宏264\n问与答264\n练习题265\n编程题266\n第16章 结构、联合和枚举267\n16.1 结构变量267\n16.1.1 结构变量的声明267\n16.1.2 结构变量的初始化269\n16.1.3 指定初始化269\n16.1.4 对结构的操作270\n16.2 结构类型270\n16.2.1 结构标记的声明271\n16.2.2 结构类型的定义272\n16.2.3 结构作为参数和返回值272\n16.2.4 复合字面量273\n16.3 嵌套的数组和结构274\n16.3.1 嵌套的结构274\n16.3.2 结构数组274\n16.3.3 结构数组的初始化275程序维护零件数据库275\n16.4 联合281\n16.4.1 用联合来节省空间282\n16.4.2 用联合来构造混合的数据结构284\n16.4.3 为联合添加“标记字段”284\n16.5 枚举285\n16.5.1 枚举标记和类型名286\n16.5.2 枚举作为整数286\n16.5.3 用枚举声明“标记字段”286\n问与答287\n练习题289\n编程题293\n第17章 指针的高级应用294\n17.1 动态存储分配294\n17.1.1 内存分配函数294\n17.1.2 空指针295\n17.2 动态分配字符串296\n……\n第18章 声明 327\n第19章 程序设计 345\n第20章 底层程序设计 363\n第21章 标准库 377\n第22章 输入\/输出 384\n第23章 库对数值和字符数据的支持 419\n第24章 错误处理 446\n第25章 国际化特性 456\n第26章 其他库函数 482\n第27章 C99对数学计算的新增支持 503\n附录A C语言运算符 524\n附录B C99与C89的比较 525\n附录C C89与经典C的比较 529\n附录D 标准库函数 532\n附录E ASCII字符集 569\n参考文献 570\n索引 573","pages":"600","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s4171870.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s4171870.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s4171870.jpg"},"alt":"https:\/\/book.douban.com\/subject\/4279678\/","id":"4279678","publisher":"人民邮电出版社","isbn10":"7115219575","isbn13":"9787115219572","title":"C语言程序设计","url":"https:\/\/api.douban.com\/v2\/book\/4279678","alt_title":"C Programming: A Modern Approach, Second Edition","author_intro":"K. N. King 世界知名的计算机程序设计教育家，现为佐治亚州立大学数学与计算机科学系副教授。他拥有耶鲁大学计算机科学硕士学位，加州大学伯克利分校计算机科学博士学位，曾任教于佐治亚理工学院。除本书外，他还撰写了广受欢迎的著作Modula-2: A Complete Guide 和Java Programming: From the Beginning，并在Dr.Dobb's Journal等权威杂志上发表了许多文章。\n吕秀锋，亚洲理工大学（AIT）计算机软件硕士，现为北京理工大学软件学院教师。多年来一直从事“计算机基础（双语）”、“C语言程序设计（双语）”以及“程序设计开发与实践”等本科生课程的教学工作，深受学生欢迎。她还译有《数据结构与算法：C＃语言描述》一书。\n黄倩，中国科学院计算技术研究所工学博士，中国计算机学会会员。研究方向包括视频处理、视频监控等，已在知名的国际期刊和国际会议论文集上发表10篇论文。译有《编程珠玑（第2版）》一书，受到读者欢迎。","summary":"时至今日， C语言仍然是计算机领域的通用语言之一，但今天的 C语言已经和最初的时候大不相同了。本书最主要的一个目的就是通过一种“现代方法”来介绍 C语言，书中强调标准 C，强调软件工程，不再强调“手工优化”。这一版中紧密结合了 C99标准，并与 C89标准进行对照，补充了 C99中的最新特性。本书分为 C语言的基础特性、 C语言的高级特性、 C语言标准库和参考资料 4个部分。每章末尾都有一个“问与答”小节给出一系列与该章内容相关的问题及答案，此外还包含适量的习题。\n本书是为大学本科阶段的 C语言课程编写的教材，同时也非常适合作为其他课程的辅助用书。","series":{"id":"50484","title":"图灵程序设计丛书·C\/C++系列"},"price":"79.00元"},{"rating":{"max":10,"numRaters":133,"average":"8.0","min":0},"subtitle":"C语言描述","author":["Kyle Loudon"],"pubdate":"2012-8","tags":[{"count":270,"name":"算法","title":"算法"},{"count":103,"name":"C语言","title":"C语言"},{"count":79,"name":"编程","title":"编程"},{"count":63,"name":"计算机","title":"计算机"},{"count":48,"name":"计算机科学","title":"计算机科学"},{"count":38,"name":"程序设计","title":"程序设计"},{"count":34,"name":"C","title":"C"},{"count":31,"name":"Programming","title":"Programming"}],"origin_title":"Mastering Algorithms with C","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s11351454.jpg","binding":"平装","translator":["肖翔","陈舸"],"catalog":"1. 前言\n2. 第1部分 预备知识\n3. 第1章 概述\n4. 数据结构简介\n5. 算法简介\n6. 小酌软件工程\n7. 如何使用本书\n8. 第2章 指针操作\n9. 指针基础\n10. 存储空间分配\n11. 数据集合与指针的算术运算\n12. 作为函数参数的指针\n13. 泛型指针与类型转换\n14. 函数指针\n15. 问与答\n16. 相关主题\n17. 第3章 递归\n18. 基本递归\n19. 尾递归\n20. 问与答\n21. 相关主题\n22. 第4章 算法分析\n23. 最坏情况分析\n24. O表示法\n25. 计算的复杂度\n26. 实例分析：插入排序\n27. 问与答\n28. 相关主题\n29. 第2部分 数据结构\n30. 第5章 链表\n31. 单链表介绍\n32. 单链表接口的定义\n33. 单链表的实现与分析\n34. 使用链表的例子：页帧管理\n35. 双向链表介绍\n36. 双向链表接口的定义\n37. 双向链表的实现与分析\n38. 循环链表介绍\n39. 循环链表接口的定义\n40. 循环链表的实现与分析\n41. 使用循环链表的例子：第二次机会页面置换法\n42. 问与答\n43. 相关主题\n44. 第6章 栈和队列\n45. 栈的描述\n46. 栈的接口定义\n47. 栈的实现与分析\n48. 队列的描述\n49. 队列的接口定义\n50. 队列的实现与分析\n51. 队列示例：事件处理\n52. 问与答\n53. 相关主题\n54. 第7章 集合\n55. 集合介绍\n56. 集合的性质\n57. 集合接口的定义\n58. 集合抽象数据类型的实现和分析\n59. Set示例：集合覆盖\n60. 问与答\n61. 相关主题\n62. 第8章 哈希表\n63. 链式哈希表的描述\n64. 链式哈希表的接口定义\n65. 链式哈希表的实现与分析\n66. 链式哈希表的例子：符号表\n67. 开地址哈希表的描述\n68. 开地址哈希函数的接口定义\n69. 开地址哈希表的实现与分析\n70. 问与答\n71. 相关主题\n72. 第9章 树\n73. 二叉树介绍\n74. 二叉树的接口定义\n75. 二叉树的实现与分析\n76. 二叉树示例：表达式处理\n77. 二叉搜索树介绍\n78. 二叉搜索树的接口定义\n79. 二叉搜索树的实现与分析\n80. 问与答\n81. 相关主题\n82. 第10章 堆和优先队列\n83. 堆的描述\n84. 堆的接口定义\n85. 堆的实现与分析\n86. 优先队列的描述\n87. 优先队列的接口定义\n88. 优先队列的实现与分析\n89. 优先队列的示例：包裹分拣\n90. 问与答\n91. 相关主题\n92. 第11章 图\n93. 图的描述\n94. 图的接口定义\n95. 图的实现与分析\n96. 关于图的应用举例：计算网络跳数\n97. 关于图的应用举例：拓扑排序\n98. 问与答\n99. 相关主题\n100. 第3部分 算法\n101. 第12章 排序和搜索\n102. 插入排序的描述\n103. 插入排序的接口定义\n104. 插入排序的实现与分析\n105. 快速排序的描述\n106. 快速排序的接口定义\n107. 快速排序的实现与分析\n108. 快速排序的例子：目录列表\n109. 归并排序的描述\n110. 归并排序的接口定义\n111. 归并排序的实现与分析\n112. 计数排序的描述\n113. 计数排序的接口定义\n114. 计数排序的实现与分析\n115. 基数排序的描述\n116. 基数排序的接口定义\n117. 基数排序的实现与分析\n118. 二分查找的描述\n119. 二分查找的接口定义\n120. 二分查找的实现与分析\n121. 二分查找的例子：拼写检查器\n122. 问与答\n123. 相关主题\n124. 第13章 数值计算\n125. 多项式插值法\n126. 多项式插值的接口定义\n127. 多项式插值的实现与分析\n128. 最小二乘估计法\n129. 最小二乘估计的接口定义\n130. 最小二乘估计的实现和分析\n131. 方程求解介绍\n132. 方程求解的接口定义\n133. 方程求解的实现与分析\n134. 问与答\n135. 相关主题\n136. 第14章 数据压缩\n137. 位操作的描述\n138. 位操作的接口定义\n139. 位操作的实现与分析\n140. 霍夫曼编码的描述\n141. 霍夫曼编码的接口定义\n142. 霍夫曼编码的分析与实现\n143. 霍夫曼编码的例子：网络优化\n144. LZ77的描述\n145. LZ77的接口定义\n146. LZ77的实现与分析\n147. 问与答\n148. 相关主题\n149. 第15章 数据加密\n150. DES算法介绍\n151. DES的接口定义\n152. DES算法的实现和分析\n153. DES应用举例：分组加密模式\n154. RSA算法介绍\n155. RSA的接口定义\n156. RSA算法的实现与分析\n157. 问与答\n158. 相关主题\n159. 第16章 图算法\n160. 最小生成树的描述\n161. 最小生成树的接口定义\n162. 最小生成树的实现与分析\n163. 最短路径的描述\n164. 最短路径的接口定义\n165. 最短路径的实现与分析\n166. 最短路径的例子：路由表\n167. 旅行商问题的描述\n168. 旅行商问题的接口定义\n169. 旅行商问题的实现与分析\n170. 问与答\n171. 相关主题\n172. 第17章 几何算法\n173. 测试线段是否相交\n174. 测试线段是否相交的标准方法\n175. 检测线段是否相交的接口定义\n176. 检测线段是否相交的实现与分析\n177. 凸包简介\n178. Jarvis’s March\n179. 凸包的接口定义\n180. 凸包的实现与分析\n181. 球面弧长\n182. 求解球面弧长的接口定义\n183. 求解球面弧长的实现和分析\n184. 球面弧长的应用举例：地球上两点之间的近似距离\n185. 问与答\n186. 相关主题","pages":"401","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s11351454.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s11351454.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s11351454.jpg"},"alt":"https:\/\/book.douban.com\/subject\/14267904\/","id":"14267904","publisher":"机械工业出版社","isbn10":"7111394267","isbn13":"9787111394266","title":"算法精解","url":"https:\/\/api.douban.com\/v2\/book\/14267904","alt_title":"Mastering Algorithms with C","author_intro":"Kyle Loudon是美国加州洛斯加托斯Jeppesen Dataplan公司的一名软件工程师，主管图形接口开发小组，主攻航迹规划软件的研发，这些软件主要用于商业航空公司、私营航空部门和其他一些航空制造业。在来到Jeppesen之前，Kyle在IBM公司是一名系统程序员。在技术上，Kyle主要对操作系统、网络、人机交互等领域感兴趣。1992年，Kyle在普渡大学拿到了计算机科学学士学位，并取得了法语的第二学位，同时他还被选入斐陶斐荣誉学会（美国大学优等生之荣誉学会）。他在普渡大学计算机系教了三年的计算机课程。在这期间，他完成了他个人的第一本书《Understanding Computers》，这本书用理论结合实践的方式介绍计算机的方方面面。如今，尽管他继续工作在硅谷的软件业，但他仍然坚韧不拔地在追求一个更高的学位。\n除了计算机，Kyle多年来喜欢打网球、教网球。他还喜欢山地骑行、滑冰，偶尔也和朋友们一起参加高尔夫课程。另外，Kyle还喜欢各种形式的戏剧、美食，以及某些风格的音乐和艺术；他期望成为钢琴家和艺术家，但希望渺茫。他现在在Jeppesen的工作是从他1992年开始驾驶飞机之后找到的。现在，他是一个拥有美国联邦航空局颁发的商业飞行员执照的飞行员。","summary":"本书是数据结构和算法领域的经典之作，十余年来，畅销不衰！全书共分为三部分：第一部分首先介绍了数据结构和算法的概念，以及使用它们的原因和意义，然后讲解了数据结构和算法中最常用的技术——指针和递归，最后还介绍了算法的分析方法，旨在为读者学习这本书打下坚实的基础；第二部分对链表、栈、队列、集合、哈希表、堆、图等常用数据结构进行了深入阐述；第三部分对排序、搜索数值计算、数据压缩、数据加密、图算法、几何算法等经典算法进行了精辟的分析和讲解。\n本书的众多特色使得它在同类书中独树一帜：具体实现都采用正式的C语言代码而不是伪代码，在很多数据结构和算法的实现过程中，有大量细节问题是伪代码不能解决的；每一章都有精心组织的主题和应用；全部示例来自真实的应用，不只是一般的练习；对每种数据结构、算法和示例都进行了详细分析；每一章的末尾都会有一系列问题和对应的回答，旨在强调这一章的重要思想……\n本书中的代码尤为值得强调：所有实现都采用C语言编写，所有代码都优先用于教学目的，所有代码都在4种平台上经过完整测试，头文件记录了所有公共的接口，命名规则适用于全书所有的代码，所有的代码都包含大量注释……\n本书内容包括：\n· 数据结构和算法的概念，以及使用它们的原因和意义\n· 指针和递归\n· 算法分析\n· 常用数据结构：链表、栈、队列、集合、哈希表、树、堆、优先级队列以及图\n· 排序和搜索\n· 数值计算\n· 数据压缩\n· 数据加密\n· 图算法\n· 几何算法","price":"79.00元"},{"rating":{"max":10,"numRaters":266,"average":"9.4","min":0},"subtitle":"42 Specific Ways to Improve Your Use of C++11 and C++14","author":["Scott Meyers"],"pubdate":"2014-12","tags":[{"count":330,"name":"C++","title":"C++"},{"count":168,"name":"C++11","title":"C++11"},{"count":111,"name":"C\/C++","title":"C\/C++"},{"count":86,"name":"编程","title":"编程"},{"count":80,"name":"计算机","title":"计算机"},{"count":72,"name":"Programming","title":"Programming"},{"count":49,"name":"程序设计","title":"程序设计"},{"count":34,"name":"effective","title":"effective"}],"origin_title":"","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s27951196.jpg","binding":"Paperback","translator":[],"catalog":"","pages":"320","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s27951196.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s27951196.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s27951196.jpg"},"alt":"https:\/\/book.douban.com\/subject\/25923597\/","id":"25923597","publisher":"O'Reilly Media","isbn10":"1491903996","isbn13":"9781491903995","title":"Effective Modern C++","url":"https:\/\/api.douban.com\/v2\/book\/25923597","alt_title":"","author_intro":"Scott Meyers is one of the world's foremost authorities on C++. He wrote the best-selling Effective C++ series (Effective C++, More Effective C++, and Effective STL); published and maintains the annotated training materials Overview of the New C++ (C++11\/14) and Effective C++ in an Embedded Environment; is Consulting Editor for the Effective Software Development Series, and, with Herb Sutter and Andrei Alexandrescu, is a principal in C++ and Beyond. He has a Ph.D in Computer Science from Brown University. He's currently working on a new book, Effective Modern C++, which he expects to publish this fall.","summary":"Learn how to program expertly with C++ with this practical book from Scott Meyers, one of the world's foremost authorities on this systems programming language. Scott Meyers takes some of the most difficult pieces of C++ code and unfurls them so that you can see how to manipulate your own project code. This is the first book to contain content written with the C++14 standard.\nTackle 42 separate C++ problems and solutions\nLearn critical techniques for success on topics from smart pointers to lambda expressions\nUnderstand key concepts by taking the C++ 98 standard to C++ 11 and then to C++ 14","price":"USD 49.99"},{"rating":{"max":10,"numRaters":625,"average":"9.1","min":0},"subtitle":"N．C. Wyeth 插图官方授权版本","author":["[美] 玛•金•罗琳斯"],"pubdate":"2016-6-1","tags":[{"count":198,"name":"自然","title":"自然"},{"count":183,"name":"美国文学","title":"美国文学"},{"count":183,"name":"外国文学","title":"外国文学"},{"count":146,"name":"玛•金•罗琳斯","title":"玛•金•罗琳斯"},{"count":136,"name":"美国","title":"美国"},{"count":135,"name":"成长","title":"成长"},{"count":129,"name":"我想读这本书","title":"我想读这本书"},{"count":128,"name":"小说","title":"小说"}],"origin_title":"The Yearling","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28748579.jpg","binding":"平装","translator":["梅静"],"catalog":"目录\n第一章 小水车\n第二章 乔迪的家\n第三章 飞来横祸\n第四章 猎熊\n第五章 草翅膀\n第六章 大快朵颐\n第七章 一桩好买卖\n第八章 意外收获\n第九章 灰岩坑\n第十章 夜晚的奇遇\n第十一章 猎鹿\n第十二章 仗义相助\n第十三章 告别奥利弗\n第十四章 危机\n第十五章 新伙伴\n第十六章 偷蜜和猎狐\n第十七章 痛失好友\n第十八章 怀念“草翅膀”\n第十九章 暴风雨\n第二十章 暴风雨后的森林\n第二十一章 瘟疫\n第二十二章 储粮\n第二十三章 狼群的夜袭\n第二十四章 猎狼\n第二十五章圣诞节前夕\n第二十六章 追捕“大笨脚”\n第二十七章 送别\n第二十八章 孤狼\n第二十九章 闯祸\n第三十章 爸爸病了\n第三十一章 无计可施\n第三十二章 再见，小鹿\n第三十三章 别了，童年","ebook_url":"https:\/\/read.douban.com\/ebook\/22165742\/","pages":"432","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s28748579.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s28748579.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28748579.jpg"},"alt":"https:\/\/book.douban.com\/subject\/26801361\/","id":"26801361","publisher":"云南人民出版社","isbn10":"7222145583","isbn13":"9787222145580","title":"鹿苑长春","url":"https:\/\/api.douban.com\/v2\/book\/26801361","alt_title":"The Yearling","author_intro":"【作者 】\n玛•金•罗琳斯\nMarjorie Kinnan Rawlings\n1896-1953\n美国作家  生于华盛顿， 毕业于威斯康星大学， 在纽约担任多年记者、编辑\n创建了佛罗里达边远林区的“地方文学”\n先后获得普利策奖、 欧·亨利奖、兰登书屋终身畅销奖\n创作的两部长篇小说《鹿苑长春》和《十字小溪》先后荣获普利策文学奖\n代表作《鹿苑长春》《十字小溪》《一位年轻姑娘》《南方月亮下》《金苹果》等\n【绘者】\nN.C.韦思\nNewell Convers Wyeth\n1882—1956\n美国现实主义绘画大师  一生创作近4000幅画作\n画作现收藏于布兰迪万河博物馆 、波特兰艺术博物馆和法恩斯沃斯艺术博物馆。1997年，他生活和工作的地方（宾夕法尼亚州查兹福德小镇墨菲路）被美国政府指定为国家历史地标之一。\n【译者】\n梅静\n北京大学外国语学院翻译硕士\n译有《柳林风声》《小鹿斑比》《小公主》《威士忌海滩》《孪生姐妹》《想飞的乔琪》《布谷鸟的呼唤》。","summary":"【“任何人遇到挫折的时候，都能够从这里得到新的勇气。”】\n【内容简介】\n《鹿苑长春》由美国作家玛·金·罗琳斯创作于1938年，根据佛罗里达林区一位老人的童年回忆创作改编，发行后登上美国畅销书榜首并持续140周，于次年获得普利策文学奖。至今，在美国累计阅读量达到5.5亿。至今，该小说被翻译成20种语言，在133个国家出版，受到不同地域和文化人们的喜爱。在1946年被米高梅公司拍摄成电影，获得奥斯卡最佳艺术指导奖和最佳摄影奖。\n故事讲述美国南北战争后佛罗里达垦荒区普通人的劳动、斗争和悲欢离合。主人公巴克斯特一家生活在佛罗里达岛地过着自给自足的农耕狩猎生活，所处的自然美景中是一幅生动绚丽的丛林画卷，该作品后被誉为描绘少年时代的经典童年诗歌。然而，它却是一本全年龄段读本，书中透出的森林清新气息和舒缓节奏，与当代都市生活迥然不同。其中有惊险的狩猎、奇妙的自然景观、悠然的乡村美景，还有风趣幽默的人物对话，以及充满泥土气息的方言。书中人们为了生存这一简单目的，持有着最质朴的勇气和信念。\n孩子们可以从书中读到激动人心的狩猎，看见原野林莽、飞鸟起落、狼踪熊迹、暴雨狂风，进入乔迪的世界，与他共度被爸爸精心呵护、无忧无虑的童年。成年人，尤其是经历过离合悲欢、人世艰难的人，都能从书中读出欢笑、甜蜜、惆怅和感伤。\n【编辑推荐】\n《鹿苑长春》是一部经典的动物文学与环境文学著作。\n故事发生在美国南北战争结束后的垦荒时代，讲述与父母生活在佛罗里达岛地的男孩乔迪与一岁小鹿间的故事。\n爸爸在牧师家庭长大，正直善良，从不说谎，因经历战争后，厌倦了与人相处的世俗，带着妻子奥拉远离城镇，选择佛罗里达的巴克斯特岛地，过着狩猎农耕的生活。家中的生计依赖于自然选择，时常受到岛地周围野兽的威胁，尤其是经常出没偷食家畜的棕熊“大笨脚”。\n因为自然环境的严酷，夫妻两人连续夭折了3个孩子，以至于乔迪诞生后，妈妈奥拉因为遭遇太多次失去，对儿子不抱有太多疼爱，也许是向现实的冷酷低头，看待事物抱有异常冷漠的清醒。爸爸彭尼从小在家中担起大梁，了解天真无邪的珍贵，反而给乔迪加倍的疼爱，试图延长乔迪无忧无虑的童年。在丛林里，有变幻的迷人风光，也有让人惊叹的动物奇观。乔迪一直喜欢听猎人讲在狩猎途中的奇遇，期待着自己与动物的亲近。\n他跟着爸爸狩猎，追踪“大笨脚”，爬在树上看鹿妈妈带着小鹿啃食树叶，与爸爸抓到罕见的白色浣熊、在克拉克莎草丛中钓鱼，遇到高鸣鹤跳沙龙舞；他跟着巴克.福利斯特在月光下的玉米地里猎狐，去松树干掏蜂蜜；与好友“草翅膀”喂养小浣熊、欧洲灰雀，一起看西班牙人后裔穿过古栈道，一起数天上米诺鱼般的星星……生活就像他给自己在灰岩坑水塘边造的小水车，随着时间的流水，悠然转动，奏出欢快的乐章，似乎没有停下来的理由。\n然而乔迪作为独子，在偏远岛地，一直是孤寂的。他希望能像爸爸彭尼一样拥有只对自己忠诚的宠物。因为口粮不足，妈妈却一直拒绝驯养动物。直到有一天，在乔迪跟随爸爸追踪走失家猪的途中，遭遇危机，也遇到了那头刚出生不久的小鹿……\n故事讲失去，也讲成长；讲孤独，也讲爱与宽容。每个人也许会从中找到真挚的共鸣，遗憾和怅惘，但更多的是，是勇气。\n【名人推荐】\n“谈到近人的作品，说「不朽」总彷佛还太早，然而《鹿苑长春》在近代文学上的地位已经奠定了。《鹿苑长春》里面出现的动物比人多──鹿、响尾蛇、八字脚的老熊、牛、马、猪──像一个动物园，但是里面的人物，尤其是那男孩子乔迪，是使人永远不能忘记的。\n那孩子失去了他最心爱的东西，使他受到很深的刺激，然而他从此就坚强起来，长大成人了。我们仔细回味，就可以觉得这不止于是一个孩子的故事，任何人遇到挫折的时候，都能够从这里得到新的勇气。\n这故事具有真正的悲剧的因素──无法避免，也不可挽回。书中对于儿童心理有非常深入的描写，可以帮助做父母的人了解自己的子女。写父爱也发掘到人性的深处。\n它是健康的，向上的，但也许它最动人的地方是与东方的心情特别接近的一种淡淡的哀愁。最后的两段更是充满了一种难堪的怅惘，我译到这里的时候，甚至于译完之后重抄一遍，抄到这里的时候，也都是像第一次读到一样地觉得非常感动，眼睛湿润起来。我相信许多读者一定也有同感。”\n——张爱玲\n【媒体推荐】\n\n在罗琳斯女士之前，还没有谁创造出如此栩栩如生且亲近读者的一系列形象，其亲密的感情感染人，不禁令人产生共鸣。\n——纽约时报\n“Never before has Mrs. Rawlings created a set of characters who are so close and real to the reader, whose intimate life one can share without the taint of unconscious patronage.\" (The New York Times)\n惊心动魄的探险和令人怅惘的人性元素……这是一部不愧于普利策奖桂冠的经典作品，故事质朴的语言和四季变化下的生态智慧，都给予这本书一种独特而难忘的气质。而画家N.C.韦思也以温暖、柔和的插图，恰到好处地捕捉到那个垦荒时代的粗莽和淳美。\n——亚马逊网站\n“Heart-stopping adventure and heart-wrenching human element…. This is a classic well worth its Pulitzer Prize. Earthy dialect and homespun wisdom season the story, giving it a unique and unforgettable flavor, and N.C. Wyeth's warm, soft illustrations capture an era of rough subsistence and sweet survival.”\n(Amazon.com)","ebook_price":"12.00","price":"48.00元"},{"rating":{"max":10,"numRaters":531,"average":"8.9","min":0},"subtitle":"使用Visual C++5.0 & MFC 4.2","author":["侯俊杰"],"pubdate":"2001-1","tags":[{"count":303,"name":"MFC","title":"MFC"},{"count":174,"name":"C++","title":"C++"},{"count":108,"name":"计算机","title":"计算机"},{"count":92,"name":"编程","title":"编程"},{"count":74,"name":"深入浅出MFC","title":"深入浅出MFC"},{"count":72,"name":"侯捷","title":"侯捷"},{"count":64,"name":"Windows","title":"Windows"},{"count":38,"name":"经典","title":"经典"}],"origin_title":"","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28952279.jpg","binding":"平装16开","translator":[],"catalog":"第一篇 勿在浮砂筑高台\n第一章 Win32 程序基本概念\n第二章 C++的重要性质\n第三章 MFC六大关键技术之仿真\n第二篇 欲善工事先利其器\n第四章 Visual C++ 集成开发环境\n第三篇 浅出MFC程序设计\n第五章 总观Application Framework\n第六章 MFC程序的生死因果\n第七章 简单而完整：MFC骨干程序\n第四篇 深入MFC 程序设计\n第八章 Document-View深入探讨\n第九章 消息映射与命令传递\n第十章 MFC与对话框\n第十一章 Vies功能的加强与重绘效率的提高\n第十二章 打印与预览\n第十三章 多重文件与多重视图\n第十四章 MFC 多线程程序设计\n第十五章 站在众人的肩膀――使用Components & ActiveX Controls\n第五篇 附录","pages":"701","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s28952279.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s28952279.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28952279.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1094852\/","id":"1094852","publisher":"华中科技大学出版社","isbn10":"7900614931","isbn13":"9787900614933","title":"深入浅出MFC （第二版）","url":"https:\/\/api.douban.com\/v2\/book\/1094852","alt_title":"","author_intro":"侯俊杰（1961年9月28日－），笔名侯捷，台湾知名电脑技术专栏作家，致力于电脑技术之扎根工作，文章兼具科技之长与灵性之美，有读者的评语是“比作家更工程师，比工程师更作家”。大同国中、师大附中、交通大学土木系毕业、清华大学动力机械研究所硕士。曾任职工研院机械所与电通所，曾在元智大学授课，近年来多从事两岸学术交流工作。他的妻子美静是一名钢琴师，侯俊杰说他自己“嗜咖啡。妻严不能常得。”","summary":"《深入浅出MFC》分为四大篇。第一篇提出学习MFC程序设计之前的必要基础，包括Widnows程序的基本观念以及C++的高阶议题。“学前基础”是相当主观的认定，但作者是甚于自己的学习经验以及教学经验，其挑选应该颇具说服力。第二篇介绍Visual C++整合环境开发工具。此篇只是提纲挈领，并不企图取代Visual C++使用手册；然而对于软件使用的老手，此篇或已足以帮助掌握Visual C++整合环境。工具的使用虽然谈不上学问，但在视觉化软件开发过程中扮演极重角色。第三篇介绍application framework的观念，以及MFC骨干程序，所谓骨干程序，是指Visual C++的工具AppWizard所产生出来的程序码。当然，AppWizard会根据使用者的选项做出不同的程序码，作者据以解说的是大众化选项下的产品。第四篇以微软公司附于Visual C++光碟片上的一个范例程序Scribble为主轴，一步一步加上新的功能；并在其间深入介绍Runtime Type Information（RTTI）、Dynamic Creation、Persistence（Serialization）、Message Mapping、Command Routing等核心技术。这些技术正是其他专著最缺乏的部分。此篇的最后数章则脱离Scribble程序，另成一格。\n这本书配有一片光盘，书中所有原始码与可执行文件都在其中。","price":"80.00元"},{"rating":{"max":10,"numRaters":457,"average":"8.8","min":0},"subtitle":"使用muduo C++网络库","author":["陈硕"],"pubdate":"2013-1-15","tags":[{"count":607,"name":"网络编程","title":"网络编程"},{"count":543,"name":"Linux","title":"Linux"},{"count":541,"name":"C++","title":"C++"},{"count":454,"name":"多线程","title":"多线程"},{"count":155,"name":"计算机","title":"计算机"},{"count":143,"name":"编程","title":"编程"},{"count":110,"name":"C\/C++","title":"C\/C++"},{"count":87,"name":"Networks","title":"Networks"}],"origin_title":"","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s24522799.jpg","binding":"平装","translator":[],"catalog":"第1 部分C++ 多线程系统编程1\n第1章 线程安全的对象生命期管理3\n1.1 当析构函数遇到多线程. . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n1.1.1 线程安全的定义. . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\n1.1.2 MutexLock 与MutexLockGuard . . . . . . . . . . . . . . . . . . . . 4\n1.1.3 一个线程安全的Counter 示例. . . . . . . . . . . . . . . . . . . . 4\n1.2 对象的创建很简单. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n1.3 销毁太难. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n1.3.1 mutex 不是办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n1.3.2 作为数据成员的mutex 不能保护析构. . . . . . . . . . . . . . . 8\n1.4 线程安全的Observer 有多难. . . . . . . . . . . . . . . . . . . . . . . . . 8\n1.5 原始指针有何不妥. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n1.6 神器shared_ptr\/weak_ptr . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n1.7 插曲：系统地避免各种指针错误. . . . . . . . . . . . . . . . . . . . . . . 14\n1.8 应用到Observer 上. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\n1.9 再论shared_ptr 的线程安全. . . . . . . . . . . . . . . . . . . . . . . . . 17\n1.10 shared_ptr 技术与陷阱. . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n1.11 对象池. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21\n1.11.1 enable_shared_from_this . . . . . . . . . . . . . . . . . . . . . . 23\n1.11.2 弱回调. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\n1.12 替代方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n1.13 心得与小结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n1.14 Observer 之谬. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\n第2章 线程同步精要31\n2.1 互斥器（mutex） . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32\n2.1.1 只使用非递归的mutex . . . . . . . . . . . . . . . . . . . . . . . . 33\n2.1.2 死锁. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\n2.2 条件变量（condition variable） . . . . . . . . . . . . . . . . . . . . . . . 40\n2.3 不要用读写锁和信号量. . . . . . . . . . . . . . . . . . . . . . . . . . . . 43\n2.4 封装MutexLock、MutexLockGuard、Condition . . . . . . . . . . . . . . 44\n2.5 线程安全的Singleton 实现. . . . . . . . . . . . . . . . . . . . . . . . . . 48\n2.6 sleep(3) 不是同步原语. . . . . . . . . . . . . . . . . . . . . . . . . . . . 50\n2.7 归纳与总结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\n2.8 借shared_ptr 实现copy-on-write . . . . . . . . . . . . . . . . . . . . . . 52\n第3章 多线程服务器的适用场合与常用编程模型59\n3.1 进程与线程. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59\n3.2 单线程服务器的常用编程模型. . . . . . . . . . . . . . . . . . . . . . . . 61\n3.3 多线程服务器的常用编程模型. . . . . . . . . . . . . . . . . . . . . . . . 62\n3.3.1 one loop per thread . . . . . . . . . . . . . . . . . . . . . . . . . . 62\n3.3.2 线程池. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63\n3.3.3 推荐模式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64\n3.4 进程间通信只用TCP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65\n3.5 多线程服务器的适用场合. . . . . . . . . . . . . . . . . . . . . . . . . . . 67\n3.5.1 必须用单线程的场合. . . . . . . . . . . . . . . . . . . . . . . . . 69\n3.5.2 单线程程序的优缺点. . . . . . . . . . . . . . . . . . . . . . . . . 70\n3.5.3 适用多线程程序的场景. . . . . . . . . . . . . . . . . . . . . . . . 71\n3.6 “多线程服务器的适用场合”例释与答疑. . . . . . . . . . . . . . . . . . 74\n第4章 C++ 多线程系统编程精要83\n4.1 基本线程原语的选用. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84\n4.2 C\/C++ 系统库的线程安全性. . . . . . . . . . . . . . . . . . . . . . . . . 85\n4.3 Linux 上的线程标识. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89\n4.4 线程的创建与销毁的守则. . . . . . . . . . . . . . . . . . . . . . . . . . . 91\n4.4.1 pthread_cancel 与C++ . . . . . . . . . . . . . . . . . . . . . . . 94\n4.4.2 exit(3) 在C++ 中不是线程安全的. . . . . . . . . . . . . . . . . 94\n4.5 善用__thread 关键字. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96\n4.6 多线程与IO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98\n4.7 用RAII 包装文件描述符. . . . . . . . . . . . . . . . . . . . . . . . . . . 99\n4.8 RAII 与fork() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101\n4.9 多线程与fork() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102\n4.10 多线程与signal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103\n4.11 Linux 新增系统调用的启示. . . . . . . . . . . . . . . . . . . . . . . . . . 105\n第5章 高效的多线程日志107\n5.1 功能需求. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109\n5.2 性能需求. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112\n5.3 多线程异步日志. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114\n5.4 其他方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120\n第2部分 muduo 网络库123\n第6章 muduo 网络库简介125\n6.1 由来. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125\n6.2 安装. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127\n6.3 目录结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129\n6.3.1 代码结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131\n6.3.2 例子. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134\n6.3.3 线程模型. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135\n6.4 使用教程. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136\n6.4.1 TCP 网络编程本质论. . . . . . . . . . . . . . . . . . . . . . . . . 136\n6.4.2 echo 服务的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . 138\n6.4.3 七步实现finger 服务. . . . . . . . . . . . . . . . . . . . . . . . . 140\n6.5 性能评测. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144\n6.5.1 muduo 与Boost.Asio、libevent2 的吞吐量对比. . . . . . . . . . 145\n6.5.2 击鼓传花：对比muduo 与libevent2 的事件处理效率. . . . . . 148\n6.5.3 muduo 与Nginx 的吞吐量对比. . . . . . . . . . . . . . . . . . . 153\n6.5.4 muduo 与ZeroMQ 的延迟对比. . . . . . . . . . . . . . . . . . . 156\n6.6 详解muduo 多线程模型. . . . . . . . . . . . . . . . . . . . . . . . . . . 157\n6.6.1 数独求解服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . . 157\n6.6.2 常见的并发网络服务程序设计方案. . . . . . . . . . . . . . . . . 160\n第7章 muduo 编程示例177\n7.1 五个简单TCP 示例. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178\n7.2 文件传输. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185\n7.3 Boost.Asio 的聊天服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . 194\n7.3.1 TCP 分包. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194\n7.3.2 消息格式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195\n7.3.3 编解码器LengthHeaderCodec . . . . . . . . . . . . . . . . . . . . 197\n7.3.4 服务端的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198\n7.3.5 客户端的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200\n7.4 muduo Buffer 类的设计与使用. . . . . . . . . . . . . . . . . . . . . . . 204\n7.4.1 muduo 的IO 模型. . . . . . . . . . . . . . . . . . . . . . . . . . 204\n7.4.2 为什么non-blocking 网络编程中应用层buffer 是必需的. . . . 205\n7.4.3 Buffer 的功能需求. . . . . . . . . . . . . . . . . . . . . . . . . . 207\n7.4.4 Buffer 的数据结构. . . . . . . . . . . . . . . . . . . . . . . . . . 209\n7.4.5 Buffer 的操作. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211\n7.4.6 其他设计方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217\n7.4.7 性能是不是问题. . . . . . . . . . . . . . . . . . . . . . . . . . . . 218\n7.5 一种自动反射消息类型的Google Protobuf 网络传输方案. . . . . . . . 220\n7.5.1 网络编程中使用Protobuf 的两个先决条件. . . . . . . . . . . . . 220\n7.5.2 根据type name 反射自动创建Message 对象. . . . . . . . . . . . 221\n7.5.3 Protobuf 传输格式. . . . . . . . . . . . . . . . . . . . . . . . . . 226\n7.6 在muduo 中实现Protobuf 编解码器与消息分发器. . . . . . . . . . . . 228\n7.6.1 什么是编解码器（codec） . . . . . . . . . . . . . . . . . . . . . . 229\n7.6.2 实现ProtobufCodec . . . . . . . . . . . . . . . . . . . . . . . . . 232\n7.6.3 消息分发器（dispatcher）有什么用. . . . . . . . . . . . . . . . 232\n7.6.4 ProtobufCodec 与ProtobufDispatcher 的综合运用. . . . . . . 233\n7.6.5 ProtobufDispatcher 的两种实现. . . . . . . . . . . . . . . . . . 234\n7.6.6 ProtobufCodec 和ProtobufDispatcher 有何意义. . . . . . . . . 236\n7.7 限制服务器的最大并发连接数. . . . . . . . . . . . . . . . . . . . . . . . 237\n7.7.1 为什么要限制并发连接数. . . . . . . . . . . . . . . . . . . . . . 237\n7.7.2 在muduo 中限制并发连接数. . . . . . . . . . . . . . . . . . . . 238\n7.8 定时器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240\n7.8.1 程序中的时间. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240\n7.8.2 Linux 时间函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . 241\n7.8.3 muduo 的定时器接口. . . . . . . . . . . . . . . . . . . . . . . . . 242\n7.8.4 Boost.Asio Timer 示例. . . . . . . . . . . . . . . . . . . . . . . . 243\n7.8.5 Java Netty 示例. . . . . . . . . . . . . . . . . . . . . . . . . . . . 245\n7.9 测量两台机器的网络延迟和时间差. . . . . . . . . . . . . . . . . . . . . 248\n7.10 用timing wheel 踢掉空闲连接. . . . . . . . . . . . . . . . . . . . . . . . 250\n7.10.1 timing wheel 原理. . . . . . . . . . . . . . . . . . . . . . . . . . 251\n7.10.2 代码实现与改进. . . . . . . . . . . . . . . . . . . . . . . . . . . . 254\n7.11 简单的消息广播服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257\n7.12 “串并转换”连接服务器及其自动化测试. . . . . . . . . . . . . . . . . . 260\n7.13 socks4a 代理服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264\n7.13.1 TCP 中继器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264\n7.13.2 socks4a 代理服务器. . . . . . . . . . . . . . . . . . . . . . . . . . 267\n7.13.3 N : 1 与1 : N 连接转发. . . . . . . . . . . . . . . . . . . . . . . . 267\n7.14 短址服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267\n7.15 与其他库集成. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268\n7.15.1 UDNS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270\n7.15.2 c-ares DNS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272\n7.15.3 curl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273\n7.15.4 更多. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275\n第8章 muduo 网络库设计与实现277\n8.0 什么都不做的EventLoop . . . . . . . . . . . . . . . . . . . . . . . . . . . 277\n8.1 Reactor 的关键结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280\n8.1.1 Channel class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280\n8.1.2 Poller class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283\n8.1.3 EventLoop 的改动. . . . . . . . . . . . . . . . . . . . . . . . . . . 287\n8.2 TimerQueue 定时器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290\n8.2.1 TimerQueue class . . . . . . . . . . . . . . . . . . . . . . . . . . . 290\n8.2.2 EventLoop 的改动. . . . . . . . . . . . . . . . . . . . . . . . . . . 292\n8.3 EventLoop::runInLoop() 函数. . . . . . . . . . . . . . . . . . . . . . . . 293\n8.3.1 提高TimerQueue 的线程安全性. . . . . . . . . . . . . . . . . . . 296\n8.3.2 EventLoopThread class . . . . . . . . . . . . . . . . . . . . . . . . 297\n8.4 实现TCP 网络库. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299\n8.5 TcpServer 接受新连接. . . . . . . . . . . . . . . . . . . . . . . . . . . . 303\n8.5.1 TcpServer class . . . . . . . . . . . . . . . . . . . . . . . . . . . . 304\n8.5.2 TcpConnection class . . . . . . . . . . . . . . . . . . . . . . . . . 305\n8.6 TcpConnection 断开连接. . . . . . . . . . . . . . . . . . . . . . . . . . . 308\n8.7 Buffer 读取数据. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 313\n8.7.1 TcpConnection 使用Buffer 作为输入缓冲. . . . . . . . . . . . . 314\n8.7.2 Buffer::readFd() . . . . . . . . . . . . . . . . . . . . . . . . . . 315\n8.8 TcpConnection 发送数据. . . . . . . . . . . . . . . . . . . . . . . . . . . 316\n8.9 完善TcpConnection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 320\n8.9.1 SIGPIPE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321\n8.9.2 TCP No Delay 和TCP keepalive . . . . . . . . . . . . . . . . . . 321\n8.9.3 WriteCompleteCallback 和HighWaterMarkCallback . . . . . . . 322\n8.10 多线程TcpServer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 324\n8.11 Connector . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327\n8.12 TcpClient . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 332\n8.13 epoll . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333\n8.14 测试程序一览. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 336\n第3部分 工程实践经验谈337\n第9章 分布式系统工程实践339\n9.1 我们在技术浪潮中的位置. . . . . . . . . . . . . . . . . . . . . . . . . . . 341\n9.1.1 分布式系统的本质困难. . . . . . . . . . . . . . . . . . . . . . . . 343\n9.1.2 分布式系统是个险恶的问题. . . . . . . . . . . . . . . . . . . . . 344\n9.2 分布式系统的可靠性浅说. . . . . . . . . . . . . . . . . . . . . . . . . . . 349\n9.2.1 分布式系统的软件不要求7  24 可靠. . . . . . . . . . . . . . . . 352\n9.2.2 “能随时重启进程”作为程序设计目标. . . . . . . . . . . . . . . 354\n9.3 分布式系统中心跳协议的设计. . . . . . . . . . . . . . . . . . . . . . . . 356\n9.4 分布式系统中的进程标识. . . . . . . . . . . . . . . . . . . . . . . . . . . 360\n9.4.1 错误做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361\n9.4.2 正确做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 362\n9.4.3 TCP 协议的启示. . . . . . . . . . . . . . . . . . . . . . . . . . . . 363\n9.5 构建易于维护的分布式程序. . . . . . . . . . . . . . . . . . . . . . . . . 364\n9.6 为系统演化做准备. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 367\n9.6.1 可扩展的消息格式. . . . . . . . . . . . . . . . . . . . . . . . . . 368\n9.6.2 反面教材：ICE 的消息打包格式. . . . . . . . . . . . . . . . . . . 369\n9.7 分布式程序的自动化回归测试. . . . . . . . . . . . . . . . . . . . . . . . 370\n9.7.1 单元测试的能与不能. . . . . . . . . . . . . . . . . . . . . . . . . 370\n9.7.2 分布式系统测试的要点. . . . . . . . . . . . . . . . . . . . . . . . 373\n9.7.3 分布式系统的抽象观点. . . . . . . . . . . . . . . . . . . . . . . . 374\n9.7.4 一种自动化的回归测试方案. . . . . . . . . . . . . . . . . . . . . 375\n9.7.5 其他用处. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 379\n9.8 分布式系统部署、监控与进程管理的几重境界. . . . . . . . . . . . . . . 380\n9.8.1 境界1：全手工操作. . . . . . . . . . . . . . . . . . . . . . . . . 382\n9.8.2 境界2：使用零散的自动化脚本和第三方组件. . . . . . . . . . . 383\n9.8.3 境界3：自制机群管理系统，集中化配置. . . . . . . . . . . . . 386\n9.8.4 境界4：机群管理与naming service 结合. . . . . . . . . . . . . 389\n第10章 C++ 编译链接模型精要391\n10.1 C 语言的编译模型及其成因. . . . . . . . . . . . . . . . . . . . . . . . . 394\n10.1.1 为什么C 语言需要预处理. . . . . . . . . . . . . . . . . . . . . . 395\n10.1.2 C 语言的编译模型. . . . . . . . . . . . . . . . . . . . . . . . . . . 398\n10.2 C++ 的编译模型. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399\n10.2.1 单遍编译. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399\n10.2.2 前向声明. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 402\n10.3 C++ 链接（linking） . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 404\n10.3.1 函数重载. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 406\n10.3.2 inline 函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 407\n10.3.3 模板. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 409\n10.3.4 虚函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 414\n10.4 工程项目中头文件的使用规则. . . . . . . . . . . . . . . . . . . . . . . . 415\n10.4.1 头文件的害处. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 416\n10.4.2 头文件的使用规则. . . . . . . . . . . . . . . . . . . . . . . . . . 417\n10.5 工程项目中库文件的组织原则. . . . . . . . . . . . . . . . . . . . . . . . 418\n10.5.1 动态库是有害的. . . . . . . . . . . . . . . . . . . . . . . . . . . . 423\n10.5.2 静态库也好不到哪儿去. . . . . . . . . . . . . . . . . . . . . . . . 424\n10.5.3 源码编译是王道. . . . . . . . . . . . . . . . . . . . . . . . . . . . 428\n第11章 反思C++ 面向对象与虚函数429\n11.1 朴实的C++ 设计. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 429\n11.2 程序库的二进制兼容性. . . . . . . . . . . . . . . . . . . . . . . . . . . . 431\n11.2.1 什么是二进制兼容性. . . . . . . . . . . . . . . . . . . . . . . . . 432\n11.2.2 有哪些情况会破坏库的ABI . . . . . . . . . . . . . . . . . . . . . 433\n11.2.3 哪些做法多半是安全的. . . . . . . . . . . . . . . . . . . . . . . . 435\n11.2.4 反面教材：COM . . . . . . . . . . . . . . . . . . . . . . . . . . . 435\n11.2.5 解决办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 436\n11.3 避免使用虚函数作为库的接口. . . . . . . . . . . . . . . . . . . . . . . . 436\n11.3.1 C++ 程序库的作者的生存环境. . . . . . . . . . . . . . . . . . . . 437\n11.3.2 虚函数作为库的接口的两大用途. . . . . . . . . . . . . . . . . . 438\n11.3.3 虚函数作为接口的弊端. . . . . . . . . . . . . . . . . . . . . . . . 439\n11.3.4 假如Linux 系统调用以COM 接口方式实现. . . . . . . . . . . . 442\n11.3.5 Java 是如何应对的. . . . . . . . . . . . . . . . . . . . . . . . . . 443\n11.4 动态库接口的推荐做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . 443\n11.5 以boost::function 和boost::bind 取代虚函数. . . . . . . . . . . . . 447\n11.5.1 基本用途. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 450\n11.5.2 对程序库的影响. . . . . . . . . . . . . . . . . . . . . . . . . . . . 451\n11.5.3 对面向对象程序设计的影响. . . . . . . . . . . . . . . . . . . . . 453\n11.6 iostream 的用途与局限. . . . . . . . . . . . . . . . . . . . . . . . . . . . 457\n11.6.1 stdio 格式化输入输出的缺点. . . . . . . . . . . . . . . . . . . . . 457\n11.6.2 iostream 的设计初衷. . . . . . . . . . . . . . . . . . . . . . . . . 461\n11.6.3 iostream 与标准库其他组件的交互. . . . . . . . . . . . . . . . . 463\n11.6.4 iostream 在使用方面的缺点. . . . . . . . . . . . . . . . . . . . . 464\n11.6.5 iostream 在设计方面的缺点. . . . . . . . . . . . . . . . . . . . . 468\n11.6.6 一个300 行的memory buffer output stream . . . . . . . . . . . 476\n11.6.7 现实的C++ 程序如何做文件IO . . . . . . . . . . . . . . . . . . . 480\n11.7 值语义与数据抽象. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482\n11.7.1 什么是值语义. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482\n11.7.2 值语义与生命期. . . . . . . . . . . . . . . . . . . . . . . . . . . . 483\n11.7.3 值语义与标准库. . . . . . . . . . . . . . . . . . . . . . . . . . . . 488\n11.7.4 值语义与C++ 语言. . . . . . . . . . . . . . . . . . . . . . . . . . 488\n11.7.5 什么是数据抽象. . . . . . . . . . . . . . . . . . . . . . . . . . . . 490\n11.7.6 数据抽象所需的语言设施. . . . . . . . . . . . . . . . . . . . . . 493\n11.7.7 数据抽象的例子. . . . . . . . . . . . . . . . . . . . . . . . . . . . 495\n第12章 C++ 经验谈501\n12.1 用异或来交换变量是错误的. . . . . . . . . . . . . . . . . . . . . . . . . 501\n12.1.1 编译器会分别生成什么代码. . . . . . . . . . . . . . . . . . . . . 503\n12.1.2 为什么短的代码不一定快. . . . . . . . . . . . . . . . . . . . . . 505\n12.2 不要重载全局::operator new() . . . . . . . . . . . . . . . . . . . . . . 507\n12.2.1 内存管理的基本要求. . . . . . . . . . . . . . . . . . . . . . . . . 507\n12.2.2 重载::operator new() 的理由. . . . . . . . . . . . . . . . . . . 508\n12.2.3 ::operator new() 的两种重载方式. . . . . . . . . . . . . . . . . 508\n12.2.4 现实的开发环境. . . . . . . . . . . . . . . . . . . . . . . . . . . . 509\n12.2.5 重载::operator new() 的困境. . . . . . . . . . . . . . . . . . . 510\n12.2.6 解决办法：替换malloc() . . . . . . . . . . . . . . . . . . . . . . 512\n12.2.7 为单独的class 重载::operator new() 有问题吗. . . . . . . . . 513\n12.2.8 有必要自行定制内存分配器吗. . . . . . . . . . . . . . . . . . . . 513\n12.3 带符号整数的除法与余数. . . . . . . . . . . . . . . . . . . . . . . . . . . 514\n12.3.1 语言标准怎么说. . . . . . . . . . . . . . . . . . . . . . . . . . . . 515\n12.3.2 C\/C++ 编译器的表现. . . . . . . . . . . . . . . . . . . . . . . . . 516\n12.3.3 其他语言的规定. . . . . . . . . . . . . . . . . . . . . . . . . . . . 516\n12.3.4 脚本语言解释器代码. . . . . . . . . . . . . . . . . . . . . . . . . 517\n12.3.5 硬件实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521\n12.4 在单元测试中mock 系统调用. . . . . . . . . . . . . . . . . . . . . . . . 522\n12.4.1 系统函数的依赖注入. . . . . . . . . . . . . . . . . . . . . . . . . 522\n12.4.2 链接期垫片（link seam） . . . . . . . . . . . . . . . . . . . . . . 524\n12.5 慎用匿名namespace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 526\n12.5.1 C 语言的static 关键字的两种用法. . . . . . . . . . . . . . . . . 526\n12.5.2 C++ 语言的static 关键字的四种用法. . . . . . . . . . . . . . . . 526\n12.5.3 匿名namespace 的不利之处. . . . . . . . . . . . . . . . . . . . . 527\n12.5.4 替代办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 529\n12.6 采用有利于版本管理的代码格式. . . . . . . . . . . . . . . . . . . . . . . 529\n12.6.1 对diff 友好的代码格式. . . . . . . . . . . . . . . . . . . . . . . . 530\n12.6.2 对grep 友好的代码风格. . . . . . . . . . . . . . . . . . . . . . . 537\n12.6.3 一切为了效率. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 538\n12.7 再探std::string . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539\n12.7.1 直接拷贝（eager copy） . . . . . . . . . . . . . . . . . . . . . . . 540\n12.7.2 写时复制（copy-on-write） . . . . . . . . . . . . . . . . . . . . . 542\n12.7.3 短字符串优化（SSO） . . . . . . . . . . . . . . . . . . . . . . . . 543\n12.8 用STL algorithm 轻松解决几道算法面试题. . . . . . . . . . . . . . . . 546\n12.8.1 用next_permutation() 生成排列与组合. . . . . . . . . . . . . . 546\n12.8.2 用unique() 去除连续重复空白. . . . . . . . . . . . . . . . . . . 548\n12.8.3 用{make,push,pop}_heap() 实现多路归并. . . . . . . . . . . . 549\n12.8.4 用partition() 实现“重排数组，让奇数位于偶数前面” . . . . 553\n12.8.5 用lower_bound() 查找IP 地址所属的城市. . . . . . . . . . . . . 554\n第4 部分附录559\n附录A 谈一谈网络编程学习经验561\n附录B 从《C++ Primer（第4 版）》入手学习C++ 579\n附录C 关于Boost 的看法591\n附录D 关于TCP 并发连接的几个思考题与试验593\n参考文献599","pages":"610","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s24522799.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s24522799.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s24522799.jpg"},"alt":"https:\/\/book.douban.com\/subject\/20471211\/","id":"20471211","publisher":"电子工业出版社","isbn10":"7121192829","isbn13":"9787121192821","title":"Linux多线程服务端编程","url":"https:\/\/api.douban.com\/v2\/book\/20471211","alt_title":"","author_intro":"陈硕，北京师范大学硕士，擅长C++ 多线程网络编程和实时分布式系统架构。曾在摩根士丹利IT 部门工作5 年，从事实时外汇交易系统开发。现在在美国加州硅谷某互联网大公司工作，从事大规模分布式系统的可靠性工程。编写了开源C++ 网络库muduo，参与翻译了《代码大全（ 第2 版）》和《C++ 编程规范（繁体版）》，整理了《C++ Primer （第4 版）（评注版）》，并曾多次在各地技术大会演讲。","summary":"本书主要讲述采用现代C++ 在x86-64 Linux 上编写多线程TCP 网络服务程序的主流常规技术，重点讲解一种适应性较强的多线程服务器的编程模型，即one loop per thread。这是在Linux 下以native 语言编写用户态高性能网络程序最成熟的模式，掌握之后可顺利地开发各类常见的服务端网络应用程序。本书以muduo 网络库为例，讲解这种编程模型的使用方法及注意事项。\n本书的宗旨是贵精不贵多。掌握两种基本的同步原语就可以满足各种多线程同步的功能需求，还能写出更易用的同步设施。掌握一种进程间通信方式和一种多线程网络编程模型就足以应对日常开发任务，编写运行于公司内网环境的分布式服务统。","price":"89.00元"}]}
6	{"count":20,"start":0,"total":1198604,"books":[{"rating":{"max":10,"numRaters":1850,"average":"8.9","min":0},"subtitle":"C语言描述","author":["维斯"],"pubdate":"2004-1-1","tags":[{"count":2183,"name":"数据结构","title":"数据结构"},{"count":1727,"name":"算法","title":"算法"},{"count":976,"name":"计算机","title":"计算机"},{"count":900,"name":"数据结构与算法分析","title":"数据结构与算法分析"},{"count":731,"name":"编程","title":"编程"},{"count":706,"name":"算法、数据结构","title":"算法、数据结构"},{"count":647,"name":"C","title":"C"},{"count":552,"name":"C语言","title":"C语言"}],"origin_title":"Data Structures and Algorithm Analysis in C:Second Edition","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s28015501.jpg","binding":"平装","translator":["冯舜玺"],"catalog":"第1章 引论\n1．1 本书讨论的内容\n1．2 数学知识复习\n1．2．1 指数\n1．2．2 对数\n1．2．3 级数\n1．2．4 模运算\n1. 2．5 证明方法\n1．3 递归简论\n总结\n练习\n参考文献\n第2章 算法分析\n2．1 数学基础\n2．2 模型\n2．3 要分析的问题\n2．4 运行时间计算\n2．4．1 一个简单的例子\n2．4．2 一般法则\n2．4．3 最大子序列和问题的解\n.2．4．4 运行时间中的对数\n2．4．5 检验你的分析\n2．4．6 分析结果的准确性\n总结\n练习\n参考文献\n第3章 表、栈和队列\n3．1 抽象数据类型(adt)\n3．2 表adt\n3．2．1 表的简单数组实现\n3．2．2 链表\n3．2．3 程序设计细节\n3．2．4 常见的错误\n3．2．5 双链表\n3．2．6 循环链表\n3．2．7 例子\n3．2．8 链表的游标实现\n3．3 栈adt\n3．3．1 栈模型\n3．3．2 栈的实现\n3．3．3 应用\n3．4 队列adt\n3．4．1 队列模型\n3．4．2 队列的数组实现\n3．4．3 队列的应用\n总结\n练习\n第4章 树\n4．1 预备知识\n4．1．1 树的实现\n4．1．2 树的遍历及应用\n4．2 二叉树\n4．2．1 实现\n4．2．2 表达式树\n4．3 查找树adt--二叉查找树\n4．3．1 makeempty\n4．3．2 find\n4．3．3 findmin和findmax\n4．3．4 insert\n4．3．5 delere\n4．3．6 平均情形分析\n4．4 avl树\n4．4．1 单旋转\n4．4．2 双旋转\n4．5 伸展树\n4．5．1 一个简单的想法\n4．5．2 展开\n4．6 树的遍历\n4．7 b-树\n总结\n练习\n参考文献\n第5章 散列\n5．1 一般想法\n5．2 散列函数\n5．3 分离链接法\n5．4 开放定址法\n5．4．1 线性探测法\n5．4．2 平方探测法\n5．4．3 双散列\n5．5 再散列\n5．6 可扩散列\n总结\n练习\n参考文献\n第6章 优先队列(堆)\n6．1 模型\n6．2 一些简单的实现\n6．3 二叉堆\n6．3．1 结构性质\n6．3．2 堆序性质\n6．3．3 基本的堆操作\n6．3．4 其他的堆操作\n6．4 优先队列的应用\n6．4．1 选择问题\n6．4．2 事件模拟\n6．5 d-堆\n6．6 左式堆\n6．6．1 左式堆的性质\n6．6．2 左式堆的操作\n6．7 斜堆\n6．8 二项队列\n6．8．1 二项队列结构\n6．8．2 二项队列操作\n6．8．3 二项队列的实现\n总结\n练习\n参考文献\n第7章 排序\n7．1 预备知识\n7．2 插入排序\n7．2．1 算法\n7．2．2 插入排序的分析\n7．3 一些简单排序算法的下界\n7. 4 希尔排序\n7．4．1 希尔排序的最坏情形分析\n7．5 堆排序\n7．5．1 堆排序的分析\n7．6 归并排序\n7．6．1 归并排序的分析\n7．7 快速排序\n7．7．1 选取枢纽元\n7．7．2 分割策略\n7．7．3 小数组\n7．7．4 实际的快速排序例程\n7．7．5 快速排序的分析\n7．7．6 选择的线性期望时间算法\n7．8 大型结构的排序\n7．9 排序的一般下界\n7．9．1 决策树\n7．10 桶式排序\n7．11 外部排序\n7．11．1 为什么需要新的算法\n7．11．2 外部排序模型\n7．11．3 简单算法\n7．11．4 多路合并\n7．11．5 多相合并\n7．11．6 替换选择\n总结\n练习\n参考文献\n第8章 不相交集adt\n8．1 等价关系\n8．2 动态等价性问题\n8．3 基本数据结构\n8．4 灵巧求并算法\n8．5 路径压缩\n8．6 按秩求并和路径压缩的最坏情形\n8．6．1 union／find算法分析\n8．7 一个应用\n总结\n练习\n参考文献\n第9章 图论算法\n9．1 若干定义\n9．1．1 图的表示\n9．2 拓扑排序\n9．3 最短路径算法\n9．3．1 无权最短路径\n9．3．2 dijkstra算法\n9．3．3 具有负边值的图\n9．3．4 无圈图\n9．3．5 所有点对最短路径\n9．4 网络流问题\n9．4．1 一个简单的最大流算法\n9．5 最小生成树\n9．5．1 prim算法\n9．5．2 kruskal算法\n9．6 深度优先搜索的应用\n9．6．1 无向图\n9．6．2 双连通性\n9．6．3 欧拉回路\n9．6．4 有向图\n9．6．5 查找强分支\n9．7 np-完全性介绍\n9．7．1 难与易\n9．7．2 np类\n9．7．3 np-完全问题\n总结\n练习\n参考文献\n第10章 算法设计技巧\n10．1 贪婪算法\n10．1．1 一个简单的调度问题\n10．1．2 huffman编码\n10．1．3 近似装箱问题\n10．2 分治算法\n10．2．1 分治算法的运行时间\n10．2．2 最近点问题\n10．2．3 选择问题\n10．2．4 一些运算问题的理论改进\n10．3 动态规划\n10．3．1 用一个表代替递归\n10．3．2 矩阵乘法的顺序安排\n10．3．3 最优二叉查找树\n10．3．4 所有点对最短路径\n10．4 随机化算法\n10．4．1 随机数发生器\n10．4．2 跳跃表\n10．4．3 素性测试\n10．5 回溯算法\n10．5．1 收费公路重建问题\n10．5．2 博弈\n总结\n练习\n参考文献\n第11章 摊还分析\n11．1 一个无关的智力问题\n11．2 二项队列\n11．3 斜堆\n11．4 斐波那契堆\n11．4．1 切除左式堆中的节点\n11．4．2 二项队列的懒惰合并\n11．4．3 斐波那契堆操作\n11．4．4 时间界的证明\n11. 5 伸展树\n总结\n练习\n参考文献\n第12章 高级数据结构及其实现\n12．1 自顶向下伸展树\n12．2 红黑树\n12．2．1 自底向上插入\n12．2．2 自顶向下红黑树\n12．2．3 自顶向下删除\n12．3 确定性跳跃表\n12．4 aa-树\n12．5 treap树\n12．6 k-d树\n12．7 配对堆\n总结\n练习\n参考文献\n索引","pages":"391","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s28015501.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s28015501.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s28015501.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1139426\/","id":"1139426","publisher":"机械工业出版社","isbn10":"711112748X","isbn13":"9787111127482","title":"数据结构与算法分析","url":"https:\/\/api.douban.com\/v2\/book\/1139426","alt_title":"Data Structures and Algorithm Analysis in C:Second Edition","author_intro":"Mark Allen Weiss，1987年在普林斯顿大学获得计算机科学博士学位，师从Robert Sedgewick (师从Knuth)，现任美国佛罗里达国际大学计算与信息科学学院教授。他曾经担任全美AP(Advanced Placement)考试计算机学科委员会的主席(2000-2004)。他的主要研究方向是数据结构、算法和教育学。","summary":"本书是《Data Structures and Algorithm Analysis in C》一书第2版的简体中译本。原书曾被评为20世纪顶尖的30部计算机著作之一，作者Mark Allen Weiss在数据结构和算法分析方面卓有建树，他的数据结构和算法分析的著作尤其畅销，并受到广泛好评．已被世界500余所大学用作教材。\n在本书中，作者更加精炼并强化了他对算法和数据结构方面创新的处理方法。通过C程序的实现，着重阐述了抽象数据类型的概念，并对算法的效率、性能和运行时间进行了分析。\n全书特点如下：\n●专用一章来讨论算法设计技巧，包括贪婪算法、分治算法、动态规划、随机化算法以及回溯算法\n●介绍了当前流行的论题和新的数据结构，如斐波那契堆、斜堆、二项队列、跳跃表和伸展树\n●安排一章专门讨论摊还分析，考查书中介绍的一些高级数据结构\n●新开辟一章讨论高级数据结构以及它们的实现，其中包括红黑树、自顶向下伸展树。treap树、k-d树、配对堆以及其他相关内容\n●合并了堆排序平均情况分析的一些新结果\n本书是国外数据结构与算法分析方面的标准教材，介绍了数据结构(大量数据的组织方法)以及算法分析(算法运行时间的估算)。本书的编写目标是同时讲授好的程序设计和算法分析技巧，使读者可以开发出具有最高效率的程序。 本书可作为高级数据结构课程或研究生一年级算法分析课程的教材，使用本书需具有一些中级程序设计知识，还需要离散数学的一些背景知识。","series":{"id":"1163","title":"计算机科学丛书"},"price":"35.00元"},{"rating":{"max":10,"numRaters":1332,"average":"8.9","min":0},"subtitle":"C语言调试指南","author":["凯尼格"],"pubdate":"2008-2-1","tags":[{"count":708,"name":"C语言","title":"C语言"},{"count":437,"name":"编程","title":"编程"},{"count":318,"name":"C","title":"C"},{"count":278,"name":"计算机","title":"计算机"},{"count":248,"name":"c","title":"c"},{"count":210,"name":"C\/C++","title":"C\/C++"},{"count":194,"name":"经典","title":"经典"},{"count":179,"name":"程序设计","title":"程序设计"}],"origin_title":"C Traps and Pitfalls","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s2870233.jpg","binding":"平装","translator":["高巍"],"catalog":"第0章　导读\n第1章　词法“陷阱”\n1.1　=不同于==\n1.2　& 和 | 不同于&& 和 ||\n1.3　词法分析中的“贪心法”\n1.4　整型常量\n1.5　字符与字符串\n第2章　语法“陷阱”\n2.1　理解函数声明\n2.2　运算符的优先级问题\n2.3　注意作为语句结束标志的分号\n2.4　switch语句\n2.5　函数调用\n2.6　“悬挂”else引发的问题\n第3章　语义“陷阱”\n3.1　指针与数组\n3.2　非数组的指针\n3.3　作为参数的数组声明\n3.4　避免“举隅法”\n3.5　空指针并非空字符串\n3.6　边界计算与不对称边界\n3.7　求值顺序\n3.8　运算符&&、|| 和 !\n3.9　整数溢出\n3.10　为函数main提供返回值\n第4章　连接\n4.1　什么是连接器\n4.2　声明与定义\n4.3　命名冲突与static修饰符\n4.4　形参、实参与返回值\n4.5　检查外部类型\n4.6　头文件\n第5章　库函数\n5.1　返回整数的getchar函数\n5.2　更新顺序文件\n5.3　缓冲输出与内存分配\n5.4　使用errno检测错误\n5.5　库函数signal\n第6章　预处理器\n6.1　不能忽视宏定义中的空格\n6.2　宏并不是函数\n6.3　宏并不是语句\n6.4　宏并不是类型定义\n第7章　可移植性缺陷\n7.1　应对C语言标准变更\n7.2　标识符名称的限制\n7.3　整数的大小\n7.4　字符是有符号整数还是无符号整数\n7.5　移位运算符\n7.6　内存位置0\n7.7　除法运算时发生的截断\n7.8　随机数的大小\n7.9　大小写转换\n7.10　首先释放，然后重新分配\n7.11　可移植性问题的一个例子\n第8章　建议与答案\n8.1　建议\n8.2　答案\n附录A　PRINTF，VARARGS与STDARG\n附录B　Koenig和Moo夫妇访谈","pages":"172","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s2870233.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s2870233.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s2870233.jpg"},"alt":"https:\/\/book.douban.com\/subject\/2778632\/","id":"2778632","publisher":"人民邮电出版社","isbn10":"7115171793","isbn13":"9787115171795","title":"C陷阱与缺陷","url":"https:\/\/api.douban.com\/v2\/book\/2778632","alt_title":"C Traps and Pitfalls","author_intro":"Andrew Koenig 是AT&T公司Shannon实验室大规模编程研究部门中的成员，同时也是C++标准委员会的项目编辑。他的编程经验超过30年，其中有15年在使用C++，他已经出版了超过150 篇和C++有关的论文，并且在世界范围内就这个主题进行过多次演讲。","summary":"作者以自己1985年在Bell实验室时发表的一篇论文为基础，结合自己的工作经验扩展成为这本对C程序员具有珍贵价值的经典著作。写作本书的出发点不是要批判C语言，而是要帮助C程序员绕过编程过程中的陷阱和障碍。..\n全书分为8章，分别从词法分析、语法语义、连接、库函数、预处理器、可移植性缺陷等几个方面分析了C编程中可能遇到的问题。最后，作者用一章的篇幅给出了若干具有实用价值的建议。..\n本书适合有一定经验的C程序员阅读学习，即便你是C编程高手，本书也应该成为你的案头必备书籍。","series":{"id":"9931","title":"C和C++经典著作"},"price":"30.00元"},{"rating":{"max":10,"numRaters":4408,"average":"9.4","min":0},"subtitle":"第 2 版·新版","author":["（美）Brian W. Kernighan","（美）Dennis M. Ritchie"],"pubdate":"2004-1","tags":[{"count":3001,"name":"C","title":"C"},{"count":2408,"name":"c语言","title":"c语言"},{"count":2131,"name":"编程","title":"编程"},{"count":1549,"name":"计算机","title":"计算机"},{"count":1291,"name":"程序设计","title":"程序设计"},{"count":1080,"name":"经典","title":"经典"},{"count":987,"name":"编程语言","title":"编程语言"},{"count":869,"name":"C\/C++","title":"C\/C++"}],"origin_title":"The C Programming Language","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1106934.jpg","binding":"平装","translator":["徐宝文","李志译","尤晋元审校"],"catalog":"出版者的话\n专家指导委员会\n中文版序\n译者序\n校译者简介\n序\n第1版序\n引言\n第1章 导言\n1.1 入门\n1.2 变量与算术表态式\n1.3 for语句\n1.4 符号常量\n1.5 字符输入\/输出\n1.6 数组\n1.7 函数\n1.8 参数——传值调用\n1.9 字符数组\n1.10 外部变量与作用域\n第2章 类型、运算符与表达式\n2.1 变量名\n2.2 数据类型及长度\n2.3 常量\n2.4 声明\n2.5 算术运算符\n2.6 关系运算符与逻辑运算符\n2.7 类型转换\n2.8 自增运算符与自减运算符\n2.9 按位运算符\n2.10 赋值运算符与表达式\n2.11 条件表达式\n2.12 运算符优先级与求值次序\n第3章 控制流\n3.1 语句与程序块\n3.2 if-else语句\n3.3 else-if语句\n3.4 switch语句\n3.5 whil循环与for特环\n3.6 do-while循环\n3.7 break语句与continue语句\n3.8 goto语句与标号\n第4章 涵数与程序结构\n第5章 指针与数组\n第6章 结构\n第7章 输入与输出\n第8章 UNIX系统接口\n附录A 参考手册\n附录B 标准库\n附录C 变更小结\n索引","pages":"258","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s1106934.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s1106934.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1106934.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1139336\/","id":"1139336","publisher":"机械工业出版社","isbn10":"7111128060","isbn13":"9787111128069","title":"C程序设计语言","url":"https:\/\/api.douban.com\/v2\/book\/1139336","alt_title":"The C Programming Language","author_intro":"Brian W. Kernighan： 贝尔实验室计算科学研究中心高级研究人员，著名的计算机科学家。他参加了UNIX系统、C语言、AWK语言和许多其他系统的开发，同时出版了许多在计算机领域具有影响的著作，如《The Elements of Programming Style》、《The Practice of Programming》、《The UNIX Programming Environment》、《The AWK Language》、《Software Tools》等。\nDennis M. Ritchie：1967年加入贝尔实验室。他和Ken L. Thompson两人共同设计并实现的C语言改变了程序设计语言发展的轨迹，是程序设计语言发展过程中的一个重要里程碑。与此同时，他们两人还设计并实现了UNIX操作系统。正是由于这两项巨大贡献，Dennis M. Ritchie于1983年获得了计算机界的最高奖——图灵奖。此外，他还获得了ACM、IEEE、贝尔实验室等授予的多种奖项.。","summary":"在计算机发展的历史上，没有哪一种程序设计语言像C语言这样应用广泛。本书原著即为C语言的设计者之一Dennis M.Ritchie和著名计算机科学家Brian W.Kernighan合著的一本介绍C语言的权威经典著作。我们现在见到的大量论述C语言程序设计的教材和专著均以此书为蓝本。原著第1版中介绍的C语言成为后来广泛使用的C语言版本——标准C的基础。人们熟知的“hello,World\"程序就是由本书首次引入的，现在，这一程序已经成为众多程序设计语言入门的第一课。\n原著第2版根据1987年制定的ANSIC标准做了适当的修订．引入了最新的语言形式，并增加了新的示例，通过简洁的描述、典型的示例，作者全面、系统、准确地讲述了C语言的各个特性以及程序设计的基本方法。对于计算机从业人员来说，《C程序设计语言》是一本必读的程序设计语 言方面的参考书。","series":{"id":"1163","title":"计算机科学丛书"},"price":"30.00元"},{"rating":{"max":10,"numRaters":132,"average":"8.5","min":0},"subtitle":"C语言描述","author":["(美)安佩尔"],"pubdate":"2006-4","tags":[{"count":306,"name":"编译原理","title":"编译原理"},{"count":115,"name":"虎书","title":"虎书"},{"count":95,"name":"C","title":"C"},{"count":83,"name":"计算机","title":"计算机"},{"count":81,"name":"计算机科学","title":"计算机科学"},{"count":60,"name":"compiler","title":"compiler"},{"count":59,"name":"编译理论","title":"编译理论"},{"count":59,"name":"编译器","title":"编译器"}],"origin_title":"Modern Compiler Implementation in C","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1852496.jpg","binding":"简裝本","translator":["赵克佳","黄春","沈志宇"],"catalog":"第一部分 编译基本原理\n第1章 绪论\n1.1 模块与接口\n1.2 工具和软件\n1.3 树语言的数据结构\n程序设计：直线式程序解释器\n推荐阅读\n习题\n第2章 词法分析\n2.1 词法单词\n2.2 正则表达式\n2.3 有限自动机\n2.4 非确定有限自动机\n2.4.1 将正则表达式转换为NFA\n2.4.2 将NFA转换为DFA\n2.5 Lex：词法分析器的生成器\n程序设计：词法分析\n推荐阅读\n习题\n第3章 语法分析\n3.1 上下文无关文法\n3.1.1 推导\n3.1.2 语法分析树\n3.1.3 二义性文法\n3.1.4 文件结束符\n3.2 预测分析\n3.2.1 FIRST集合和FOLLOW集合\n3.2.2 构造一个预测分析器\n3.2.3 消除左递归\n3.2.4 提取左因子\n3.2.5 错误恢复\n3.3 LR分析\n3.3.1 LR分析引擎\n3.3.2 LR(0)分析器生成器\n3.3.3 SLR分析器的生成\n3.3.4 LR(1)项和LR(1)分析表\n3.3.5 LALR(1)分析表\n3.3.6 各类文法的层次\n3.3.7 二义性文法的LR分析\n3.4 使用分析器的生成器\n3.4.1 冲突\n3.4.2 优先级指导\n3.4.3 语法和语义\n3.5 错误恢复\n3.5.1 用error符号恢复\n3.5.2 全局错误修复\n程序设计：语法分析\n推荐阅读\n习题\n第4章 抽象语法\n4.1 语义动作\n4.1.1 递归下降\n4.1.2 Yacc生成的分析器\n4.1.3 语义动作的解释器\n4.2 抽象语法分析树\n4.2.1 位置\n4.2.2 Tiger的抽象语法\n程序设计：抽象语法\n推荐阅读\n习题\n第5章 语义分析\n5.1 符号表\n5.1.1 多个符号表\n5.1.2 高效的命令式风格符号表\n5.1.3 高效的函数式符号表\n5.1.4 Tiger编译器的符号\n5.1.5 函数式风格的符号表\n5.2 Tiger编译器的绑定\n5.3 表达式的类型检查\n5.4 声明的类型检查\n5.4.1 变量声明\n5.4.2 类型声明\n5.4.3 函数声明\n5.4.4 递归声明\n程序设计：类型检查\n习题\n第6章 活动记录\n6.1 栈帧\n6.1.1 帧指针\n6.1.2 寄存器\n6.1.3 参数传递\n6.1.4 返回地址\n6.1.5 栈帧内的变量\n6.1.6 静态链\n6.2 Tiger编译器的栈帧\n6.2.1 栈帧描述的表示\n6.2.2 局部变量\n6.2.3 计算逃逸变量\n6.2.4 临时变量和标号\n6.2.5 两层抽象\n6.2.6 管理静态链\n6.2.7 追踪层次信息\n程序设计：栈帧\n推荐阅读\n习题\n第7章 翻译成中间代码\n7.1 中间表示树\n7.2 翻译为树中间语言\n7.2.1 表达式的种类\n7.2.2 简单变量\n7.2.3 追随静态链\n7.2.4 数组变量\n7.2.5 结构化的左值\n7.2.6 下标和域选择\n7.2.7 关于安全性的劝告\n7.2.8 算术操作\n7.2.9 条件表达式\n7.2.10 字符串\n7.2.11 记录和数组的创建\n7.2.12 while循环\n7.2.13 for循环\n7.2.14 函数调用\n7.3 声明\n7.3.1 变量定义\n7.3.2 函数定义\n7.3.3 片段\n程序设计：翻译成树\n习题\n第8章 基本块和轨迹\n8.1 规范树\n8.1.1 ESEQ的转换\n8.1.2 一般重写规则\n8.1.3 将CALL移到顶层\n8.1.4 线性语句表\n8.2 处理条件分支\n8.2.1 基本块\n8.2.2 轨迹\n8.2.3 完善\n8.2.4 最优轨迹\n推荐阅读\n习题\n第9章 指令选择\n9.1 指令选择算法\n9.1.1 Maximal Munch算法\n9.1.2 动态规划\n9.1.3 树文法\n9.1.4 快速匹配\n9.1.5 覆盖算法的效率\n9.2 CISC机器\n9.3 Tiger编译器的指令选择\n9.3.1 抽象的汇编语言指令\n9.3.2 生成汇编指令\n9.3.3 过程调用\n9.3.4 无帧指针的情形\n程序设计：指令选择\n推荐阅读\n习题\n第10章 活跃分析\n10.1 数据流方程的解\n10.1.1 活跃性计算\n10.1.2 集合的表示\n10.1.3 时间复杂度\n10.1.4 最小不动点\n10.1.5 静态活跃性与动态活跃性\n10.1.6 冲突图\n10.2 Tiger编译器的活跃分析\n10.2.1 图\n10.2.2 控制流图\n10.2.3 活跃分析\n程序设计：构造流图\n程序设计：活跃分析模块\n习题\n第11章 寄存器分配\n11.1 通过简化进行着色\n11.2 合并\n11.3 预着色的结点\n11.3.1 机器寄存器的临时副本\n11.3.2 调用者保护的寄存器和被调用者保护的寄存器\n11.3.3 含预着色结点的例子\n11.4 图着色的实现\n11.4.1 传送指令工作表的管理\n11.4.2 数据结构\n11.4.3 程序代码\n11.5 针对树的寄存器分配\n程序设计：图着色\n推荐阅读\n习题\n第12章 整合为一体\n程序设计：过程入口\/出口\n程序设计：创建一个可运行的编译器\n第二部分 高级主题\n第13章 垃圾收集\n13.1 标记-清扫式收集\n13.2 引用计数\n13.3 复制式收集\n13.4 分代收集\n13.5 增量式收集\n13.6 Baker算法\n13.7 编译器接口\n13.7.1 快速分配\n13.7.2 数据布局的描述\n13.7.3 导出指针\n程序设计：描述字\n程序设计：垃圾收集\n推荐阅读\n习题\n第14章 面向对象的语言\n14.1 类\n14.2 数据域的单继承性\n14.3 多继承性\n14.4 测试类成员关系\n14.5 私有域和私有方法\n14.6 无类语言\n14.7 向对象程序的优化\n程序设计：OBJECT Tiger\n推荐阅读\n习题\n第15章 函数式程序设计语言\n15.1 一个简单的函数式语言\n15.2 闭包\n15.3 不变的变量\n15.3.1 基于延续的……I\/O226\n15.3.2 语言上的变化\n15.3.3 纯函数式语言的优化\n15.4 内联扩展\n15.5 闭包变换\n15.6 高效的尾递归\n15.7 懒惰计算\n15.7.1 传名调用计算\n15.7.2 按需调用\n15.7.3 懒惰程序的计算\n15.7.4 懒惰函数式程序的优化\n15.7.5 严格性分析\n推荐阅读\n程序设计：编译函数式语言\n习题\n第16章 多态类型\n16.1 参数多态性\n16.1.1 显式带类型的多态语言\n16.1.2 多态类型的检查\n16.2 类型推论\n16.2.1 一个隐式类型的多态语言\n16.2.2 类型推论算法\n16.2.3 递归的数据类型\n16.2.4 Hindley Milner类型的能力\n16.3 多态变量的表示\n16.3.1 多态函数的扩展\n16.3.2 完全的装箱转换\n16.3.3 基于强制的表示分析\n16.3.4 将类型作为运行时参数传递\n16.4 静态重载的解决方法\n推荐阅读\n习题\n第17章 数据流分析\n17.1 流分析使用的中间表示\n17.2 各种数据流分析\n17.2.1 到达定值\n17.2.2 可用表达式\n17.2.3 到达表达式\n17.2.4 活跃分析\n17.3 使用数据流分析结果的几种转换\n17.3.1 公共子表达式删除\n17.3.2 常数传播\n17.3.3 复写传播\n17.3.4 死代码删除\n17.4 加快数据流分析\n17.4.1 位向量\n17.4.2 基本块\n17.4.3 结点排序\n17.4.4 使用-定值链和定值-使用链\n17.4.5 工作表算法\n17.4.6 增量式数据流分析\n17.5 别名分析\n17.5.1 基于类型的别名分析\n17.5.2 基于流的别名分析\n17.5.3 使用可能别名信息\n17.5.4 严格的纯函数式语言中的别名分析\n推荐阅读\n习题\n第18章 循环优化\n18.1 必经结点\n18.1.1 寻找必经结点的算法\n18.1.2 直接必经结点\n18.1.3 循环\n18.1.4 循环前置结点\n18.2 循环不变量计算\n18.3 归纳变量\n18.3.1 发现归纳变量\n18.3.2 强度削弱\n18.3.3 删除\n18.3.4 重写比较\n18.4 数组边界检查\n18.5 循环展开\n推荐阅读\n习题\n第19章 静态单赋值形式\n19.1 转化为SSA形式\n19.1.1 插入Φ函数的标准\n19.1.2 必经结点边界\n19.1.3 插入Φ函数\n19.1.4 变量重命名\n19.1.5 边分割\n19.2 必经结点树的高效计算\n19.2.1 深度优先生成树\n19.2.2 半必经结点\n19.2.3 Lengauer Tarjan算法\n19.3 使用SSA的优化算法\n19.3.1 死代码删除\n19.3.2 简单的常数传播\n19.3.3 条件常数传播\n19.3.4 保持必经结点性质\n19.4 数组、指针和存储器\n19.5 控制依赖图\n19.6 从SSA形式转变回来\n19.7 函数式中间形式\n推荐阅读\n习题\n第20章 流水和调度\n20.1 没有资源约束时的循环调度\n20.2 有资源约束的循环流水\n20.2.1 模调度\n20.2.2 寻找最小的启动间距\n20.2.3 其他控制流\n20.2.4 编译器应该调度指令吗\n20.3 分支预测\n20.3.1 静态分支预测\n20.3.2 编译器应该预测分支吗\n推荐阅读\n习题\n第21章 存储层次\n21.1 cache的组织结构\n21.2 cache块对齐\n21.3 预取\n21.4 循环交换\n21.5 分块\n21.6 垃圾收集和存储层次\n推荐阅读\n习题\n附录 Tiger语言参考手册\n参考文献\n索引","pages":"385","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s1852496.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s1852496.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1852496.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1806974\/","id":"1806974","publisher":"人民邮电出版社","isbn10":"7115145520","isbn13":"9787115145529","title":"现代编译原理","url":"https:\/\/api.douban.com\/v2\/book\/1806974","alt_title":"Modern Compiler Implementation in C","author_intro":"","summary":"《现代编译原理:C语言描述》全面讲述了现代编译器的结构、编译算法和实现方法，是Andrew w．Apple的“虎书”——Modern Compiler Implementation——“红、蓝、绿”三序列之一。这三本书的内容基本相同。但是使用不同的语言来实现书中给出的一个编译器。本书使用的是更适合广大读者的c语言，而另外两本书分别采用ML语言和Java语言。本书的另一个特点是增加了一些其他编译原理教科书没有涉及的内容。前端增加了面向对象的程序设计语言、函数式程序设计语言等现代语言的编译实现方法，后端增加了针对现代计算机体系结构特征的一些比较成熟的优化方法。这部分内容展现了现代商业编译器需解决的一些关键问题，开拓了学生的视野，为学生未来进行更深入的研究奠定了基础。\n\n《现代编译原理:C语言描述》全面讲述了现代编译器的各个组成部分，包括词法分析、语法分析、抽象语法、语义检查、中间代码表示、指令选择、数据流分析、寄存器分配以及运行时系统等。全书分成两部分，第一部分是编译的基础知识，适用于第一门编译原理课程(一个学期)；第二部分是高级主题，包括面向对象语言和函数语言、垃圾收集、循环优化、ssA(静态单赋值)形式、循环调度、存储结构优化等，适合于后续课程或研究生教学。书中专门为学生提供了一个用C语言编写的实习项目，包括前端和后端设计，学生可以在一学期内创建一个功能完整的编译器。","series":{"id":"18507","title":"图灵计算机科学丛书"},"price":"45.00元"},{"rating":{"max":10,"numRaters":137,"average":"9.1","min":0},"subtitle":"编写高质量C语言代码","author":["Steve Maguire"],"pubdate":"2009.2","tags":[{"count":297,"name":"编程","title":"编程"},{"count":250,"name":"C","title":"C"},{"count":153,"name":"C语言","title":"C语言"},{"count":102,"name":"程序设计","title":"程序设计"},{"count":100,"name":"计算机","title":"计算机"},{"count":81,"name":"Programming","title":"Programming"},{"count":71,"name":"C\/C++","title":"C\/C++"},{"count":67,"name":"经典","title":"经典"}],"origin_title":"Writing Solid Code","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s3529626.jpg","binding":"","translator":[],"catalog":"1 a hypothetical compiler\n2 assert yourself\n3 fortify your subsystems\n4 step through your code\n5 candy-machine interfaces\n6 risky business\n7 treacheries of the trade\n8 the rest is attitude\nepilogue where do you go from here?\nappendix a coding checklists\nappendix b memory logging routines\nappendix c answers\nreferences\nindex","pages":"256","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s3529626.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s3529626.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s3529626.jpg"},"alt":"https:\/\/book.douban.com\/subject\/3406939\/","id":"3406939","publisher":"人民邮电出版社","isbn10":"7115193169","isbn13":"9787115193162","title":"编程精粹","url":"https:\/\/api.douban.com\/v2\/book\/3406939","alt_title":"Writing Solid Code","author_intro":"","summary":"编写高质量的、没有bug的程序，是每位程序员所追求的目标。但随着软件规模越来越大，功能日趋复杂，这一目标变得越来越困难。\n本书揭示了微软公司应对质量挑战、开发出世界级代码的技术内幕，作者在自己不断探索、实践和思考的基础上，系统总结了多年来指导微软各团队的经验，将其凝聚为许多切实可行的编程实践指导，可谓字字珠玑。正因如此，本书被公认为与《代码大全》齐名的编程技术名著，曾于1993年荣获有软件开发奥斯卡奖之称的Jolt生产效率大奖。书中内容主要针对C语言，但其中的思想对目前的各主流语言编程也完全适用。","series":{"id":"50484","title":"图灵程序设计丛书·C\/C++系列"},"price":"45.00元"},{"rating":{"max":10,"numRaters":462,"average":"8.1","min":0},"subtitle":"—C++\/C语言","author":["林锐","韩永泉"],"pubdate":"2007-5","tags":[{"count":218,"name":"C++","title":"C++"},{"count":154,"name":"编程","title":"编程"},{"count":126,"name":"C\/C++","title":"C\/C++"},{"count":104,"name":"程序设计","title":"程序设计"},{"count":78,"name":"高质量程序设计指南--C++\/c语言","title":"高质量程序设计指南--C++\/c语言"},{"count":70,"name":"计算机","title":"计算机"},{"count":70,"name":"编程风格","title":"编程风格"},{"count":61,"name":"C","title":"C"}],"origin_title":"","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s2660317.jpg","binding":"","translator":[],"catalog":"第1章  高质量软件开发之道\t11.1  软件质量基本概念\t11.1.1  如何理解软件的质量\t11.1.2  提高软件质量的基本方法\t31.1.3  “零缺陷”理念\t41.2  细说软件质量属性\t41.2.1  正确性\t41.2.2  健壮性\t51.2.3  可靠性\t51.2.4  性能\t61.2.5  易用性\t71.2.6  清晰性\t71.2.7  安全性\t71.2.8  可扩展性\t81.2.9  兼容性\t81.2.10  可移植性\t81.3  人们关注的不仅仅是质量\t91.3.1  质量、生产率和成本之间的关系\t91.3.2  软件过程改进的基本概念\t111.4  高质量软件开发的基本方法\t131.4.1  建立软件过程规范\t131.4.2  复用\t151.4.3  分而治之\t161.4.4  优化与折中\t171.4.5  技术评审\t181.4.6  测试\t191.4.7  质量保证\t211.4.8  改错\t221.5  关于软件开发的一些常识和思考\t241.5.1  有最好的编程语言吗\t241.5.2  编程是一门艺术吗\t241.5.3  编程时应该多使用技巧吗\t241.5.4  换更快的计算机还是换更快的算法\t251.5.5  错误是否应该分等级\t251.5.6  一些错误的观念\t251.6  小结\t26第2章  编程语言发展简史\t272.1  编程语言大事记\t272.2  Ada的故事\t302.3  C\/C++发展简史\t312.4  Borland与Microsoft之争\t322.5  Java阵营与Microsoft的较量\t332.6  小结\t36第3章  程序的基本概念\t373.1  程序设计语言\t373.2  语言实现\t383.3  程序库\t403.4  开发环境\t403.5  程序的工作原理\t413.6  良好的编程习惯\t42第4章  C++\/C程序设计入门\t454.1  C++\/C程序的基本概念\t454.1.1  启动函数main()\t454.1.2  命令行参数\t474.1.3  内部名称\t484.1.4  连接规范\t494.1.5  变量及其初始化\t514.1.6  C Runtime Library\t524.1.7  编译时和运行时的不同\t524.1.8  编译单元和独立编译技术\t544.2  基本数据类型和内存映像\t544.3  类型转换\t564.3.1  隐式转换\t564.3.2  强制转换\t584.4  标识符\t604.5  转义序列\t614.6  运算符\t624.7  表达式\t634.8  基本控制结构\t654.9  选择（判断）结构\t654.9.1  布尔变量与零值比较\t664.9.2  整型变量与零值比较\t674.9.3  浮点变量与零值比较\t674.9.4  指针变量与零值比较\t694.9.5  对if语句的补充说明\t704.9.6  switch结构\t704.10   循环（重复）结构\t714.10.1  for语句的循环控制变量\t724.10.2  循环语句的效率\t734.11  结构化程序设计原理\t784.12  goto\/continue\/break语句\t794.13  示例\t80第5章  C++\/C常量\t855.1  认识常量\t855.1.1  字面常量\t855.1.2  符号常量\t865.1.3  契约性常量\t875.1.4  枚举常量\t875.2  正确定义符号常量\t875.3  const与#define的比较\t885.4  类中的常量\t895.5  实际应用中如何定义常量\t90第6章  C++\/C函数设计基础\t956.1  认识函数\t956.2  函数原型和定义\t966.3  函数调用方式\t976.4  认识函数堆栈\t996.5  函数调用规范\t1006.6  函数连接规范\t1016.7  参数传递规则\t1026.8  返回值的规则\t1046.9  函数内部实现的规则\t1076.10  存储类型及作用域规则\t1096.10.1  存储类型\t1096.10.2  作用域规则\t1106.10.3  连接类型\t1116.11  递归函数\t1136.12  使用断言\t1166.13  使用const提高函数的健壮性\t1186.13.1  用const修饰函数的参数\t1186.13.2  用const修饰函数的返回值\t119第7章  C++\/C指针、数组和字符串\t1217.1  指针\t1217.1.1  指针的本质\t1217.1.2  指针的类型及其支持的运算\t1237.1.3  指针传递\t1257.2  数组\t1267.2.1  数组的本质\t1267.2.2  二维数组\t1287.2.3  数组传递\t1297.2.4  动态创建、初始化和删除数组的方法\t1317.3  字符数组、字符指针和字符串\t1337.3.1  字符数组、字符串和‘\\0’的关系\t1337.3.2  字符指针的误区\t1347.3.3  字符串拷贝和比较\t1347.4  函数指针\t1357.5  引用和指针的比较\t137第8章  C++\/C高级数据类型\t1418.1  结构（Struct）\t1418.1.1  关键字struct与class的困惑\t1418.1.2  使用struct\t1428.1.3  位域\t1458.1.4  成员对齐\t1478.2  联合（Union）\t1598.3  枚举（Enum）\t1618.4  文件\t163第9章  C++\/C编译预处理\t1659.1  文件包含\t1659.1.1  内部包含卫哨和外部包含卫哨\t1659.1.2  头文件包含的合理顺序\t1669.2  宏定义\t1669.3  条件编译\t1699.3.1  #if、#elif和#else\t1699.3.2  #ifdef 和 #ifndef\t1709.4  #error\t1719.5  #pragma\t1719.6  #和##运算符\t1719.7  预定义符号常量\t172第10章  C++\/C文件结构和程序版式\t17510.1  程序文件的目录结构\t17510.2  文件的结构\t17610.2.1  头文件的用途和结构\t17610.2.2  版权和版本信息\t17710.2.3  源文件结构\t17810.3  代码的版式\t17810.3.1  适当的空行\t17810.3.2  代码行及行内空格\t17910.3.3  长行拆分\t18010.3.4  对齐与缩进\t18110.3.5  修饰符的位置\t18210.3.6  注释风格\t18210.3.7  ADT\/UDT版式\t183第11章  C++\/C应用程序命名规则\t18511.1  共性规则\t18511.2  简单的Windows应用程序命名\t186第12章  C++面向对象程序设计方法概述\t18912.1  漫谈面向对象\t18912.2  对象的概念\t19012.3  信息隐藏与类的封装\t19112.4  类的继承特性\t19512.5  类的组合特性\t20012.6  动态特性\t20112.6.1  虚函数\t20212.6.2  抽象基类\t20212.6.3  动态绑定\t20512.6.4  运行时多态\t20712.6.5  多态数组\t20812.7  C++对象模型\t21512.7.1  对象的内存映像\t21512.7.2  隐含成员\t22412.7.3  C++编译器如何处理成员函数\t22512.7.4  C++编译器如何处理静态成员\t22512.8  小结\t226第13章  对象的初始化、拷贝和析构\t22913.1  构造函数与析构函数的起源\t22913.2  为什么需要构造函数和析构函数\t23013.3  构造函数的成员初始化列表\t23213.4  对象的构造和析构次序\t23413.5  构造函数和析构函数的调用时机\t23513.6  构造函数和赋值函数的重载\t23613.7  示例：类String的构造函数和析构函数\t23813.8  何时应该定义拷贝构造函数和拷贝赋值函数\t23913.9  示例：类String的拷贝构造函数和拷贝赋值函数\t24013.10  用偷懒的办法处理拷贝构造函数和拷贝赋值函数\t24213.11  如何实现派生类的基本函数\t243第14章  C++函数的高级特性\t24714.1  函数重载的概念\t24714.1.1  重载的起源\t24714.1.2  重载是如何实现的\t24714.1.3  当心隐式类型转换导致重载函数产生二义性\t24914.2  成员函数的重载、覆盖与隐藏\t25014.2.1  重载与覆盖\t25014.2.2  令人迷惑的隐藏规则\t25114.2.3  摆脱隐藏\t25314.3  参数的默认值\t25414.4  运算符重载\t25514.4.1  基本概念\t25514.4.2  运算符重载的特殊性\t25614.4.3  不能重载的运算符\t25714.4.4  重载++和--\t25714.5  函数内联\t25914.5.1  用函数内联取代宏\t25914.5.2  内联函数的编程风格\t26014.5.3  慎用内联\t26114.6  类型转换函数\t26114.7  const成员函数\t264第15章  C++异常处理和RTTI\t26715.1  为什么要使用异常处理\t26715.2  C++异常处理\t26815.2.1  异常处理的原理\t26815.2.2  异常类型和异常对象\t26915.2.3  异常处理的语法结构\t27015.2.4  异常的类型匹配规则\t27215.2.5  异常说明及其冲突\t27215.2.6  当异常抛出时局部对象如何释放\t27315.2.7  对象构造和析构期间的异常\t27315.2.8  如何使用好异常处理技术\t27515.2.9  C++的标准异常\t27815.3  虚函数面临的难题\t27815.4  RTTI及其构成\t28015.4.1  起源\t28015.4.2  typeid运算符\t28115.4.3  dynamic_cast<>运算符\t28315.4.4  RTTI的魅力与代价\t285第16章  内存管理\t28716.1  内存分配方式\t28716.2  常见的内存错误及其对策\t28816.3  指针参数是如何传递内存的\t28916.4  free和delete把指针怎么啦\t29116.5  动态内存会被自动释放吗\t29216.6  杜绝“野指针”\t29216.7  有了malloc\/free为什么还要new\/delete\t29316.8  malloc\/free的使用要点\t29516.9  new有3种使用方式\t29616.9.1  plain new\/delete\t29616.9.2  nothrow new\/delete\t29716.9.3  placement new\/delete\t29716.10  new\/delete的使用要点\t30016.11  内存耗尽怎么办\t30116.12  用对象模拟指针\t30216.13  泛型指针auto_ptr\t30516.14  带有引用计数的智能指针\t30616.15  智能指针作为容器元素\t310第17章  学习和使用STL\t32317.1  STL简介\t32317.2  STL头文件的分布\t32417.2.1  容器类\t32417.2.2  泛型算法\t32517.2.3  迭代器\t32517.2.4  数学运算库\t32517.2.5  通用工具\t32517.2.6  其他头文件\t32617.3  容器设计原理\t32617.3.1  内存映像\t32617.3.2  存储方式和访问方式\t32717.3.3  顺序容器和关联式容器的比较\t32817.3.4  如何遍历容器\t33117.3.5  存储空间重分配问题\t33217.3.6  什么样的对象才能作为STL容器的元素\t33317.4  迭代器\t33417.4.1  迭代器的本质\t33417.4.2  迭代器失效及其危险性\t33817.5  存储分配器\t34617.6  适配器\t34717.7  泛型算法\t35017.8  一些特殊的容器\t35417.8.1  string类\t35417.8.2  bitset并非set\t35517.8.3  节省存储空间的vector<bool>\t35717.8.4  空容器\t35817.9  STL容器特征总结\t36017.10  STL使用心得\t362附录A  C++\/C试题\t365附录B  C++\/C试题答案与评分标准\t369附录C  大学十年\t375附录D  《大学十年》后记\t393附录E  术语与缩写解释\t395参考文献\t397","pages":"394","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s2660317.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s2660317.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s2660317.jpg"},"alt":"https:\/\/book.douban.com\/subject\/2116929\/","id":"2116929","publisher":"电子工业","isbn10":"7121041146","isbn13":"9787121041143","title":"高质量程序设计指南","url":"https:\/\/api.douban.com\/v2\/book\/2116929","alt_title":"","author_intro":"林锐，国内知名的软件工程专家和研发管理咨询师。西安电子科技大学硕士，浙江大学计算机系博士。2000年7月加入上海贝尔有限公司，从事软件工程和CMM的研究推广工作。2003年7月当选为Alcatel集团技术专家。2004年初创建上海漫索计算机科技有限公司(http：／／www.chinaspis.com)，致力于创建适合国内IT企业需求的研发管理解决方案，包括方法论和软件产品。已出版著作七部。","summary":"《高质量程序设计指南:C++、C语言》(第3版)以轻松幽默的笔调向读者论述了高质量软件开发方法与C++\/C编程规范。它是作者多年从事软件开发工作的经验总结。《高质量程序设计指南:C++、C语言》(第3版)共17章，第1章到第4章重点介绍软件质量和基本的程序设计方法；第5章到第16章重点阐述 C++\/C编程风格、面向对象程序设计方法和一些技术专题；第17章阐述STL 的原理和使用方法。\n　　《高质量程序设计指南:C++、C语言》(第3版)第1版和第2版部分章节曾经在Internet上广泛流传，被国内IT企业的不少软件开发人员采用。《高质量程序设计指南:C++、C语言》(第3版)的附录C《大学十年》是作者在网上发表的一个短篇传记，文中所描述的充满激情的学习和生活态度，感染了大批莘莘学子。","price":"39.80元"},{"rating":{"max":10,"numRaters":78,"average":"9.1","min":0},"subtitle":"C语言描述","author":["韦斯(Mark Allen Weiss)"],"pubdate":"2010-8","tags":[{"count":165,"name":"数据结构","title":"数据结构"},{"count":148,"name":"算法","title":"算法"},{"count":89,"name":"计算机","title":"计算机"},{"count":63,"name":"C","title":"C"},{"count":45,"name":"Algorithms","title":"Algorithms"},{"count":41,"name":"计算机科学","title":"计算机科学"},{"count":38,"name":"编程","title":"编程"},{"count":16,"name":"数据结构与算法","title":"数据结构与算法"}],"origin_title":"Data Structures and Algorithm Analysis in C","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s4459394.jpg","binding":"平装","translator":[],"catalog":"1  Introduction  1.1. What's the Book About?  1.2. Mathematics Review    1.2.1. Exponents    1.2.2. Logarithms    1.2.3. Series    1.2.4. Modular Arithmetic    1.2.5. The P Word  1.3. A Brief Introduction to Recursion    Summary    Exercises    References2  Algorithm Analysis3  Lists, Stacks, and Queues4  Trees5  Hashing6  Priority Queues (Heaps)7  Sorting 2198  The Disjoint Set ADT9  Graph Algorithms10  Algorithm Design Techniques11  Amortized Analysis12  Advanced Data Structures and Implementation","pages":"511","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s4459394.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s4459394.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s4459394.jpg"},"alt":"https:\/\/book.douban.com\/subject\/4924153\/","id":"4924153","publisher":"机械工业出版社","isbn10":"7111312805","isbn13":"9787111312802","title":"数据结构与算法分析","url":"https:\/\/api.douban.com\/v2\/book\/4924153","alt_title":"Data Structures and Algorithm Analysis in C","author_intro":"Mark Allen Weiss 1987年在普林斯顿大学获得计算机科学博士学位。师从Roberl Sedgewick，现任美国佛罗里达国际大学计算与信息科学学院教授。他曾担任全美AP(Advanced Placement)考试计算机学科委员会主席。其主要研究方向是数据结构、算法和教育学。","summary":"《数据结构与算法分析:C语言描述》曾被评为20世纪顶尖的30部计算机著作之一，作者在数据结构和算法分析方面卓有建树，他的数据结构和算法分析的著作尤其畅销，并受到广泛好评，已被世界500余所大学选作教材。\n在《数据结构与算法分析:C语言描述》中，作者精炼并强化了他对算法和数据结构方面创新的处理方法。通过C程序的实现，着重阐述了抽象数据类型的概念，并对算法的效率、性能和运行时间进行了分析。\n《数据结构与算法分析:C语言描述》特色：着重讨论了算法设计技巧，包括贪婪算法、分治算法、动态规划、随机化算法以及回溯算法。系统介绍了当前流行的论题和新的数据结构，如斐波那契堆、斜堆、二项队列、跳跃表和伸展树。详细讨论了摊还分析，考查书中介绍的一些高级数据结构。增加了高级数据结构及其实现的内容，包括红黑树、自顶向下伸展树、treap树、k-d树、配对堆等。整合了堆排序平均情况分析的一些新结果。","series":{"id":"1895","title":"经典原版书库"},"price":"45.00元"},{"rating":{"max":10,"numRaters":1802,"average":"9.1","min":0},"subtitle":"（第五版）","author":["Stephen Prata","云巅工作室"],"pubdate":"2005-2-1","tags":[{"count":915,"name":"编程","title":"编程"},{"count":840,"name":"c","title":"c"},{"count":830,"name":"c语言","title":"c语言"},{"count":611,"name":"计算机","title":"计算机"},{"count":480,"name":"程序设计","title":"程序设计"},{"count":379,"name":"经典","title":"经典"},{"count":378,"name":"C","title":"C"},{"count":243,"name":"programming","title":"programming"}],"origin_title":"","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1308874.jpg","binding":"平装(无盘)","translator":["云巅工作室"],"catalog":"第1章 概览\n1.1 C语言的起源\n1.2 使用C语言的理由\n1.3 C语言的发展方向\n1.4 计算机工作的基本原理\n1.5 高级计算机语言和编译器\n1.6 使用C语言的7个步骤\n1.7 编程机制\n1.8 语言标准\n1.9 本书的组织结构\n1.10 本书体例\n1.11 总结\n1.12 复习题\n1.13 编程练习\n第2章 C语言概述\n2.1 C语言的一个简单实例\n2.2 实例说明\n2.3 一个简单程序的结构\n2.4 使程序可读的技巧\n2.5 更进一步\n2.6 多个函数\n2.7 调试\n2.8 关键字和保留标识符\n2.9 关键概念\n2.10 总结\n2.11 复习题\n2.12 编程练习\n第3章 数据和C\n3.1 示例程序\n3.2 变量与常量数据\n3.3 数据：数据类型关键字\n3.4 C数据类型\n3.5 使用数据类型\n3.6 参数和易犯的错误\n3.7 另一个例子：转义序列\n3.8 关键概念\n3.9 总结\n3.10 复习题\n3.11 编程练习\n第4章 字符串和格式化输入\/输出\n4.1 前导程序\n4.2 字符串简介\n4.3 常量和C预处理器\n4.4 研究和利用printf（）和scanf（）\n4.5 关键概念\n4.6 总结\n4.7 复习题\n4.8 编程练习\n第5章 运算符、表达式和语句\n5.1 循环简介\n5.2 基本运算符\n5.3 其他运算符\n5.4 表达式和语句\n5.5 类型转换\n5.6 带有参数的函数\n5.7 一个示例程序\n5.8 关键概念\n5.9 总结\n5.10 复习题\n5.11 编程练习\n第6章 C控制语句：循环\n6.1 再探while循环\n6.2 while语句\n6.4 不确定循环与计数循环\n6.5 for循环\n6.6 更多赋值运算符：+=、-=、*=、\/=和%=\n6.7 逗号运算符\n6.8 退出条件循环：do while\n6.9 选择哪种循环\n6.10 嵌套循环\n6.11 数组\n6.12 使用函数返回值的循环例子\n6.13 关键概念\n6.14 总结\n6.15 复习题\n6.16 编程练习\n第7章 C控制语句：分支和跳转\n7.1 if语句\n7.2 在if语句中添加else关键字\n7.3 获得逻辑性\n7.4 一个统计字数的程序\n7.5 条件运算符?:\n7.6 循环辅助手段：continue和break\n7.7 多重选择：switch和break\n7.8 goto语句\n7.9 关键概念\n7.10 总结\n7.11 复习题\n7.12 编程练习\n第8章 字符输入\/输出和输入确认\n8.1 单字符I\/O：getchar（）和putchar（）\n8.2 缓冲区\n8.3 终止键盘输入\n8.5 创建一个更友好的用户界面\n8.6 输入确认\n8.7 菜单浏览\n8.8 关键概念\n8.9 总结\n8.10 复习题\n8.11 编程练习\n第9章 函数\n9.1 函数概述\n9.2 ANSI C的函数原型\n9.3 递归\n9.4 多源代码文件程序的编译\n9.5 地址运算符：&\n9.6 改变调用函数中的变量\n9.7 指针简介\n9.8 关键概念\n9.9 总结\n9.10 复习题\n9.11 编程练习\n第10章 数组和指针\n10.1 数组\n10.2 多维数组\n10.3 指针和数组\n10.4 函数、数组和指针\n10.5 指针操作\n10.6 保护数组内容\n10.7 指针和多维数组\n10.8 变长数组（VLA）\n10.9 复合文字\n10.10 关键概念\n10.11 总结\n10.12 复习题\n10.13 编程练习\n第11章 字符串和字符串函数\n11.1 字符串表示和字符串I\/O\n11.2 字符串输入\n11.3 字符串输出\n11.4 自定义字符串输入\/输出函数\n11.5 字符串函数\n11.6 字符串例子：字符串排序\n11.7 ctype.h字符函数和字符串\n11.8 命令行参数\n11.9 把字符串转换为数字\n11.10 关键概念\n11.11 总结\n11.12 复习题\n11.13 编程练习\n第12章 存储类、链接和内存管理\n12.1 存储类\n12.2 存储类说明符\n12.3 存储类和函数\n12.4 随机数函数和静态变量\n12.5 掷骰子\n12.6 分配内存：malloc（）和free（）\n12.7 ANSI C的类型限定词\n12.8 关键概念\n12.9 总结\n12.10 复习题\n12.11 编程练习\n第13章 文件输入\/输出\n13.1 和文件进行通信\n13.2 标准I\/O\n13.3 一个简单的文件压缩程序\n13.4 文件I\/O：fprintf ( )、fscanf ( )、fgets ( )和fputs ( )函数\n13.5 随机存取：fseek（）和ftell（）函数\n13.6 标准I\/O内幕\n13.7 其他标准I\/O函数\n13.8 关键概念\n13.9 总结\n13.10 复习题\n13.11 编程练习\n第14章 结构和其他数据形式\n14.1 示例问题：创建图书目录\n14.2 建立结构声明\n14.3 定义结构变量\n14.4 结构数组\n14.5 嵌套结构\n14.6 指向结构的指针\n14.7 向函数传递结构信息\n14.8 把结构内容保存到文件中\n14.9 结构：下一步是什么\n14.10 联合简介\n14.11 枚举类型\n14.12 typedef简介\n14.13 奇特的声明\n14.14 函数和指针\n14.15 关键概念\n14.16 总结\n14.17 复习题\n14.18 编程练习\n第15章 位操作\n15.1 二进制数、位和字节\n15.2 其他基数\n15.3 C的位运算符\n15.4 位字段\n15.5 关键概念\n15.6 总结\n15.7 复习题\n15.8 编程练习\n第16章 C预处理器和C库\n16.1 翻译程序的第一步\n16.2 明显常量：#define\n16.3 在#define中使用参数\n16.4 宏，还是函数\n16.5 文件包含：＃include\n16.6 其他指令\n16.7 内联函数\n16.8 C库\n16.9 数学库\n16.10 通用工具库\n16.11 诊断库\n16.12 string.h库中的memcpy（）和memmove（）\n16.13 可变参数：stdarg.h\n16.14 关键概念\n16.15 总结\n16.16 复习题\n16.17 编程练习\n第17章 高级数据表示\n17.1 研究数据表示\n17.2 从数组到链表\n17.3 抽象数据类型（ADT）\n17.4 队列ADT\n17.5 用队列进行模拟\n17.6 链表与数组\n17.7 二叉搜索树\n17.8 其他说明\n17.9 关键概念\n17.10 总结\n17.11 复习题\n17.12 编程练习\n附录A 复习题答案\n附录B 参考资料","pages":"626","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s1308874.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s1308874.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1308874.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1240002\/","id":"1240002","publisher":"人民邮电出版社","isbn10":"7115130221","isbn13":"9787115130228","title":"C Primer Plus","url":"https:\/\/api.douban.com\/v2\/book\/1240002","alt_title":"","author_intro":"普拉塔，在加利福尼亚州的Kentfield的Marin学院教授天文学、物理学和程序设计课程。他在加州工业学院获得学士学位，从加州大学伯克利分校获得博士学位。他最早接触计算机，始于对星河的计算机建模。Stephen已经编写或与他人合作编写了十多本书。其中包括C++Primer Plus和Unix Prinmer Plus。","summary":"《C Primer Plus（第5版）（中文版）》共17章。第1、2章学习C语言编程所需的预备知识。第3到15章介绍了C语言的相关知识，包括数据类型、格式化输入输出、运算符、表达式、流程控制语句、函数、数组和指针、字符串操作、内存管理、位操作等等，知识内容都针对C99标准；另外，第10章强化了对指针的讨论，第12章引入了动态内存分配的概念，这些内容更加适合读者的需求。第16章和第17章讨论了C预处理器和C库函数、高级数据表示（数据结构）方面的内容。附录给出了各章后面复习题、编程练习的答案和丰富的C编程参考资料。","price":"60.00元"},{"rating":{"max":10,"numRaters":1935,"average":"9.2","min":0},"subtitle":"","author":["Peter Van Der Linden"],"pubdate":"2008-2","tags":[{"count":1196,"name":"C语言","title":"C语言"},{"count":681,"name":"编程","title":"编程"},{"count":446,"name":"计算机","title":"计算机"},{"count":405,"name":"c","title":"c"},{"count":387,"name":"C专家编程","title":"C专家编程"},{"count":364,"name":"C\/C++","title":"C\/C++"},{"count":339,"name":"C","title":"C"},{"count":302,"name":"程序设计","title":"程序设计"}],"origin_title":"Expert C Programming: Deep C Secrets","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s5886086.jpg","binding":"平装","translator":["徐波"],"catalog":"第1章 C：穿越时空的迷雾\n1.1 C语言的史前阶段\n1.2 C语言的早期体验\n1.3 标准I\/O库和C预处理器\n1.4 K&R C\n1.5 今日之ANSI C\n1.6 它很棒，但它符合标准吗\n1.7 编译限制\n1.8 ANSI C标准的结构\n1.9 阅读ANSI C标准，寻找乐趣和裨益\n1.10 “安静的改变”究竟有多少安静\n1.11 轻松一下——由编译器定义的Pragmas效果\n第2章 这不是Bug，而是语言特性\n2.1 这关语言特性何事，在Fortran里这就是Bug呀\n2.2 多做之过\n2.3 误做之过\n2.4 少做之过\n2.5 轻松一下——有些特性确实就是Bug\n2.6 参考文献\n第3章 分析C语言的声明\n3.1 只有编译器才会喜欢的语法\n3.2 声明是如何形成的\n3.3 优先级规则\n3.4 通过图表分析C语言的声明\n3.5 typedef可以成为你的朋友\n3.6 typedef int x[10]和#define x int[10]的区别\n3.7 typedef struct foo{ ... foo; }的含义\n3.8 理解所有分析过程的代码段\n3.9 轻松一下——驱动物理实体的软件\n第4章 令人震惊的事实：数组和指针并不相同\n4.1 数组并非指针\n4.2 我的代码为什么无法运行\n4.3 什么是声明，什么是定义\n4.4 使声明与定义相匹配\n4.5 数组和指针的其他区别\n4.6 轻松一下——回文的乐趣\n第5章 对链接的思考\n5.1 函数库、链接和载入\n5.2 动态链接的优点\n5.3 函数库链接的5个特殊秘密\n5.4 警惕Interpositioning\n5.5 产生链接器报告文件\n5.6 轻松一下——看看谁在说话：挑战Turing测验\n第6章 运动的诗章：运行时数据结构\n6.1 a.out及其传说\n6.2 段\n6.3 操作系统在a.out文件里干了些什么\n6.4 C语言运行时系统在a.out里干了些什么\n6.5 当函数被调用时发生了什么：过程活动记录\n6.6 auto和static关键字\n6.7 控制线程\n6.8 setjmp和longjmp\n6.9 UNIX中的堆栈段\n6.10 MS-DOS中的堆栈段\n6.11 有用的C语言工具\n6.12 轻松一下——卡耐基-梅隆大学的编程难题\n6.13 只适用于高级学员阅读的材料\n第7章 对内存的思考\n7.1 Intel 80x86系列\n7.2 Intel 80x86内存模型以及它的工作原理\n7.3 虚拟内存\n7.4 Cache存储器\n7.5 数据段和堆\n7.6 内存泄漏\n7.7 总线错误\n7.8 轻松一下——“Thing King”和“页面游戏”\n第8章 为什么程序员无法分清万圣节和圣诞节\n8.1 Portzebie度量衡系统\n8.2 根据位模式构筑图形\n8.3 在等待时类型发生了变化\n8.4 原型之痛\n8.5 原型在什么地方会失败\n8.6 不需要按回车键就能得到一个字符\n8.7 用C语言实现有限状态机\n8.8 软件比硬件更困难\n8.9 如何进行强制类型转换，为何要进行类型强制转换\n8.10 轻松一下——国际C语言混乱代码大赛\n第9章 再论数组\n9.1 什么时候数组与指针相同\n9.2 为什么会发生混淆\n9.3 为什么C语言把数组形参当作指针\n9.4 数组片段的下标\n9.5 数组和指针可交换性的总结\n9.6 C语言的多维数组\n9.7 轻松一下——软件\/硬件平衡\n第10章 再论指针\n10.1 多维数组的内存布局\n10.2 指针数组就是Iliffe向量\n10.3 在锯齿状数组上使用指针\n10.4 向函数传递一个一维数组\n10.5 使用指针向函数传递一个多维数组\n10.6 使用指针从函数返回一个数组\n10.7 使用指针创建和使用动态数组\n10.8 轻松一下——程序检验的限制\n第11章 你懂得C，所以C++不在话下\n11.1 初识OOP\n11.2 抽象——取事物的本质特性\n11.3 封装——把相关的类型、数据和函数组合在一起\n11.4 展示一些类——用户定义类型享有和预定义类型一样的权限\n11.5 访问控制\n11.6 声明\n11.7 如何调用成员函数\n11.8 继承——复用已经定义的操作\n11.9 多重继承——从两个或更多的基类派生\n11.10 重载——作用于不同类型的同一操作具有相同的名字\n11.11 C++如何进行操作符重载\n11.12 C++的输入\/输出(I\/O)\n11.13 多态——运行时绑定\n11.14 解释\n11.15 C++如何表现多态\n11.16 新奇玩意——多态\n11.17 C++的其他要点\n11.18 如果我的目标是那里，我不会从这里起步\n11.19 它或许过于复杂，但却是惟一可行的方案\n11.20 轻松一下——死亡计算机协会\n11.21 更多阅读材料\n附录A 程序员工作面试的秘密\n附录B 术语表","pages":"291","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s5886086.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s5886086.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s5886086.jpg"},"alt":"https:\/\/book.douban.com\/subject\/2377310\/","id":"2377310","publisher":"人民邮电出版社","isbn10":"7115171807","isbn13":"9787115171801","title":"C专家编程","url":"https:\/\/api.douban.com\/v2\/book\/2377310","alt_title":"Expert C Programming: Deep C Secrets","author_intro":"","summary":"《C专家编程》展示了最优秀的C程序员所使用的编码技巧，并专门开辟了一章对C++的基础知识进行了介绍。\n书中C的历史、语言特性、声明、数组、指针、链接、运行时、内存以及如何进一步学习C++等问题进行了细致的讲解和深入的分析。全书撷取几十个实例进行讲解，对C程序员具有非常高的实用价值。\n本书可以帮助有一定经验的C程序员成为C编程方面的专家，对于具备相当的C语言基础的程序员，本书可以帮助他们站在C的高度了解和学习C++。","series":{"id":"9931","title":"C和C++经典著作"},"price":"45.00元"},{"rating":{"max":10,"numRaters":154,"average":"8.8","min":0},"subtitle":"C标准库“圣经”","author":["P. J. Plauger"],"pubdate":"2009-7","tags":[{"count":228,"name":"C","title":"C"},{"count":196,"name":"C语言","title":"C语言"},{"count":103,"name":"编程","title":"编程"},{"count":102,"name":"标准库","title":"标准库"},{"count":76,"name":"计算机","title":"计算机"},{"count":76,"name":"C\/C++","title":"C\/C++"},{"count":57,"name":"程序设计","title":"程序设计"},{"count":40,"name":"库","title":"库"}],"origin_title":"","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s3820140.jpg","binding":"","translator":["卢红星","徐明亮","霍建同"],"catalog":"第0章　简介. 1\n0.1　背景知识1\n0.2　C 标准的内容 3\n0.3　库的使用7\n0.4　库的实现9\n0.5　库的测试13\n0.6　参考文献15\n0.7　习题15\n第1章　(assert.h)17\n1.1　背景知识17\n1.2　C 标准的内容18\n1.3　(assert.h) 的使用18\n1.4　(assert.h) 的实现20\n1.5　(assert.h) 的测试22\n1.6　参考文献23\n1.7　习题23\n第2章　(ctype.h) 25\n2.1　背景知识25\n2.2　C 标准的内容28\n2.3　(ctype.h) 的使用 30\n2.4　(ctype.h) 的实现 34\n2.5　(ctype.h) 的测试 42\n2.6　参考文献45\n2.7　习题45\n第3章　(errno.h) 47\n3.1　背景知识47\n3.2　C 标准的内容50\n3.3　(errno.h) 的使用 50\n3.4　(errno.h) 的实现 51\n3.5　(errno.h) 的测试 55\n3.6　参考文献55\n3.7　习题55\n第4章　(float.h)57\n4.1　背景知识57\n4.2　C 标准的内容59\n4.3　(float.h) 的使用.62\n4.4　(float.h) 的实现.64\n4.5　(float.h) 的测试.69\n4.6　参考文献71\n4.7　习题72\n第5章　(limits.h)73\n5.1　背景知识73\n5.2　C 标准的内容74\n5.3　(limits.h) 的使用75\n5.4　(limits.h) 的实现77\n5.5　(limits.h) 的测试79\n5.6　参考文献80\n5.7　习题80\n第6章　(locale.h)81\n6.1　背景知识81\n6.2　C 标准的内容84\n6.3　(locale.h) 的使用87\n6.4　(locale.h) 的实现94\n6.5　(locale.h) 的测试 123\n6.6　参考文献.123\n6.7　习题123\n第7章　(math.h)127\n7.1　背景知识.127\n7.2　C 标准的内容 130\n7.3　(math.h) 的使用 135\n7.4　(math.h) 的实现 137\n7.5　(math.h) 的测试 171\n7.6　参考文献.177\n7.7　习题177\n第8章　(setjmp.h).. 181\n8.1　背景知识.181\n8.2　C 标准的内容 184\n8.3　(setjmp.h) 的使用 185\n8.4　(setjmp.h) 的实现 187\n8.5 (setjmp.h) 的测试191\n8.6 参考文献 192\n8.7 习题 192\n第9章　(signal.h) 193\n9.1　背景知识.193\n9.2　C 标准的内容 195\n9.3　(signal.h) 的使用 197\n9.4　(signal.h) 的实现 199\n9.5　(signal.h) 的测试 203\n9.6　参考文献.203\n9.7　习题203\n第10章　(stdarg.h) 205\n10.1　背景知识205\n10.2　C 标准的内容 207\n10.3　(stdarg.h) 的使用 208\n10.4　(stdarg.h) 的实现 211\n10.5　(stdarg.h) 的测试 212\n10.6　参考文献212\n10.7　习题.214\n第11章　(stddef.h) 215\n11.1　背景知识 215\n11.2　C 标准的内容 217\n11.3　(stddef.h) 的使用 217\n11.4　(stddef.h) 的实现 222\n11.5　(stddef.h) 的测试 223\n11.6　参考文献 223\n11.7　习题223\n第12章　(stdio.h) 225\n12.1　背景知识225\n12.2　C 标准的内容 233\n12.3　(stdio.h) 的使用 252\n12.4　(stdio.h) 的实现 274\n12.5　(stdio.h) 的测试 323\n12.6　参考文献325\n12.7　习题.325\n第13章　(stdlib.h) 331\n13.1　背景知识331\n13.2　C 标准的内容 332\n13.3　(stdlib.h) 的使用 342\n13.4　(stdlib.h) 的实现 351\n13.5　(stdlib.h) 的测试 379\n13.6　参考文献379\n13.7　习题.382\n第14章　(string.h) 385\n14.1　背景知识385\n14.2　C 标准的内容 386\n14.3　(string.h) 的使用 392\n14.4　(string.h) 的实现 396\n14.5　(string.h) 的测试 409\n14.6　参考文献409\n14.7　习题.409\n第15章　(time.h) 413\n15.1　背景知识413\n15.2　C 标准的内容 414\n15.3　(time.h) 的使用 418\n15.4　(time.h) 的实现 422\n15.5　(time.h) 的测试440\n15.6　参考文献441\n15.7　习题.441\n附录A　接口 443\n附录B　名字 451\n附录C　术语... 461","pages":"488","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s3820140.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s3820140.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s3820140.jpg"},"alt":"https:\/\/book.douban.com\/subject\/3775842\/","id":"3775842","publisher":"人民邮电出版社","isbn10":"7115172862","isbn13":"9787115172860","title":"C标准库","url":"https:\/\/api.douban.com\/v2\/book\/3775842","alt_title":"","author_intro":"P. J. Plauger  世界著名的软件技术专家，曾任ISO C标准委员会主席，C\/C++ User’s Journal主编，现任ISO C++标准委员会主席。他是C\/C++标准库开发领域的大师，所开发的Dinkumware标准库应用广泛。","summary":"本书是由世界级C语言专家编写的C标准库经典著作。英文版已经重印十多次，影响了几代程序员。\n本书结合C标准的相关部分，精辟地讲述了每一个库函数的使用方法和实现细节，而这正是一个真正的C程序员所必须掌握的。更重要的是，书中给出了实现和测试这些函数的完整源代码，可以让你更深入地学习C语言。不仅如此，本书还讨论了一些即使是最有经验的C程序员通常也不熟悉的知识，比如国际化和独立于区域设置的程序的编写、与构建库相关的概念和设计思想。\n本书结构清晰，内容权威，阐述精辟，对于各层次C 程序员和相关专业高校师生都是一本优秀的参考书。","series":{"id":"50484","title":"图灵程序设计丛书·C\/C++系列"},"price":"79.00元"},{"rating":{"max":10,"numRaters":808,"average":"8.6","min":0},"subtitle":"一本37.5°C的博物馆地图","author":["沈辛成"],"pubdate":"2017-5-20","tags":[{"count":588,"name":"纽约","title":"纽约"},{"count":560,"name":"博物馆","title":"博物馆"},{"count":455,"name":"旅行","title":"旅行"},{"count":370,"name":"美国","title":"美国"},{"count":337,"name":"艺术","title":"艺术"},{"count":281,"name":"城市","title":"城市"},{"count":214,"name":"历史","title":"历史"},{"count":193,"name":"生活","title":"生活"}],"origin_title":"","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s29478001.jpg","binding":"精装","translator":[],"catalog":"指南与致谢\n有点像跋的序\n第一章 你这个种族主义者\n纽约深度游线路一：黑色与白色\n第二章 没有华尔的街\n纽约深度游线路二：革命与资本\n第三章 纽约水故事\n纽约深度游线路三：饮水与思源\n第四章 我的画报你的城\n纽约深度游之四：寻根与漂流\n第五章 曼哈顿是平的\n纽约深度游之五：贫穷与富裕\n第六章 开往昨天的地铁\n纽约深度游之六：地下与地上\n第七章 美国的归美国，纽约的归纽约\n纽约深度游之七：美国与欧洲\n第八章 不知道为什么就流泪\n纽约深度游之八：战争与和平\n有点像序的跋\n附录\n附录一：一些遗珠\n附录二：纽约博物馆排名","pages":"380","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s29478001.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s29478001.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s29478001.jpg"},"alt":"https:\/\/book.douban.com\/subject\/27037182\/","id":"27037182","publisher":"中西书局","isbn10":"7547512488","isbn13":"9787547512487","title":"纽约无人是客","url":"https:\/\/api.douban.com\/v2\/book\/27037182","alt_title":"","author_intro":"沈辛成，1984年生人，非业余博物馆爱好者，走访全美八十余座博物馆，曾服务于美国自然历史博物馆、“911”国家纪念馆和纽约历史学会，参与从事档案研究、出版与策展工作。佐治亚理工学院科技史博士在读，哥伦比亚大学人类学硕士，复旦大学考古学硕士，北京大学博物馆学学士，做过独立唱作人，兼职美国时政评论。","summary":"本书为作者在纽约实地踏访数十家博物馆并进行深入了解后，对纽约博物馆展示特色、专业内涵、设计匠心及观众体验等进行多维度评价的作品。\n本书不是一本简单的博物馆导览手册，而是基于作者的个人经历和专业背景，试图阐释纽约这个五方杂处、光怪陆离却又独具特色的国际大都会的底色。全书行文从容，图文并茂，兼具知识性、实用性和可读性，无论是否去过纽约，它都会在流畅的阅读之后，带给你充足的知识与细节，同时也带给你深深的思索。","price":"39.80元"},{"rating":{"max":10,"numRaters":1399,"average":"9.0","min":0},"subtitle":"","author":["Kenneth A.Reek"],"pubdate":"2008 年4月","tags":[{"count":869,"name":"C","title":"C"},{"count":776,"name":"C语言","title":"C语言"},{"count":540,"name":"编程","title":"编程"},{"count":437,"name":"指针","title":"指针"},{"count":381,"name":"计算机","title":"计算机"},{"count":304,"name":"程序设计","title":"程序设计"},{"count":276,"name":"C\/C++","title":"C\/C++"},{"count":180,"name":"Programming","title":"Programming"}],"origin_title":"Pointers on C","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s2996168.jpg","binding":"平装","translator":["徐波"],"catalog":"第1章 快速上手\n1.1 简介\n1.1.1 空白和注释\n1.1.2 预处理指令\n1.1.3 main函数\n1.1.4 read_column_numbers函数\n1.1.5 rearrange函数\n1.2 补充说明\n1.3 编译\n1.4 总结\n1.5 警告的总结\n1.6 编程提示的总结\n1.7 问题\n1.8 编程练习\n第2章 基本概念\n2.1 环境\n2.1.1 翻译\n2.1.2 执行\n2.2 词法规则\n2.2.1 字符\n2.2.2 注释\n2.2.3 自由形式的源代码\n2.2.4 标识符\n2.2.5 程序的形式\n2.3 程序风格\n2.4 总结\n2.5 警告的总结\n2.6 编程提示的总结\n2.7 问题\n2.8 编程练习\n第3章 数据\n第4章 语句\n第5章 操作符和表达式\n第6章 指针\n第7章 函数\n第8章 数组\n第9章 字符串、字符和字节\n第10章 结构和联合\n第11章 动态内存分配\n第12章 使用结构和指针\n第13章 高级指针话题\n第14章 预处理器\n第15章 输入\/输出函数\n第16章 标准函数库\n第17章 经典抽象数据类型\n第18章 运行时环境\n附录 部分问题答案\n索引\n参考文献","pages":"448","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s2996168.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s2996168.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s2996168.jpg"},"alt":"https:\/\/book.douban.com\/subject\/3012360\/","id":"3012360","publisher":"人民邮电出版社","isbn10":"7115172013","isbn13":"9787115172013","title":"C和指针","url":"https:\/\/api.douban.com\/v2\/book\/3012360","alt_title":"Pointers on C","author_intro":"Kenneth·Reek是罗彻斯特理工大学计算机科学教授。他是一位经验丰富的C程序员，曾为多家公司担任过技术顾问。他讲授的课程有操作系统、数据通信、计算机网络、形式语言、算法分析和交换系统等。本书正是基于他9年的编程及教学的经验积累。","summary":"本书提供与C语言编程相关的全面资源和深入讨论。本书通过对指针的基础知识和高级特性的探讨，帮助程序员把指针的强大功能融入到自己的程序中去。\n全书共18章，覆盖了数据、语句、操作符和表达式、指针、函数、数组、字符串、结构和联合等几乎所有重要的C编程话题。书中给出了很多编程技巧和提示，每章后面有针对性很强的练习，附录部分则给出了部分练习的解答。\n本书适合C语言初学者和初级C程序员阅读，也可作为计算机专业学生学习C语言的参考。","series":{"id":"9931","title":"C和C++经典著作"},"price":"65.00元"},{"rating":{"max":10,"numRaters":1270,"average":"9.6","min":0},"subtitle":"-","author":["Brian W. Kernighan","Dennis M. Ritchie"],"pubdate":"1988-4-1","tags":[{"count":611,"name":"c","title":"c"},{"count":434,"name":"Programming","title":"Programming"},{"count":403,"name":"C语言","title":"C语言"},{"count":382,"name":"编程","title":"编程"},{"count":316,"name":"计算机","title":"计算机"},{"count":240,"name":"经典","title":"经典"},{"count":218,"name":"C","title":"C"},{"count":205,"name":"程序设计","title":"程序设计"}],"origin_title":"","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s29586132.jpg","binding":"Paperback","translator":[],"catalog":"","pages":"274","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s29586132.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s29586132.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s29586132.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1236999\/","id":"1236999","publisher":"Prentice Hall","isbn10":"0131103628","isbn13":"9780131103627","title":"The  C Programming Language","url":"https:\/\/api.douban.com\/v2\/book\/1236999","alt_title":"C Programming Language","author_intro":"Brian W. Kernighan works in the Computing Science Research Center at Bell Laboratories, Lucent Technologies. He is Consulting Editor for Addison-Wesley's Professional Computing Series and the author, with Dennis Ritchie, of The C Programming Language.\nDennis Ritchie is a computer scientist notable for his influence on ALTRAN, B, BCPL, C, Multics, and Unix.","summary":"Presents a complete guide to ANSI standard C language programming. Written by the developers of C, this new version helps readers keep up with the finalized ANSI standard for C while showing how to take advantage of C's rich set of operators, economy of expression, improved control flow, and data structures. This 2nd edition has been completely rewritten with additional examples and problem sets to clarify the implementation of difficult language constructs. 7 x 9 1\/4.","price":"USD 67.00"},{"rating":{"max":10,"numRaters":604,"average":"9.3","min":0},"subtitle":"第六版","author":["普拉达 (Stephen Prata)"],"pubdate":"2016-4-1","tags":[{"count":347,"name":"C语言","title":"C语言"},{"count":231,"name":"C","title":"C"},{"count":215,"name":"编程","title":"编程"},{"count":183,"name":"计算机","title":"计算机"},{"count":142,"name":"计算机科学","title":"计算机科学"},{"count":125,"name":"经典","title":"经典"},{"count":86,"name":"C++","title":"C++"},{"count":78,"name":"软件开发","title":"软件开发"}],"origin_title":"C Primer Plus : 6th","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s29438897.jpg","binding":"平装","translator":["姜佑"],"catalog":"第1章　初识C语言\t1\n1．1　C语言的起源\t1\n1．2 选择C语言的理由\t1\n1．2．1 设计特性\t1\n1．2．2 高效性\t1\n1．2．3 可移植性\t2\n1．2．4 强大而灵活\t3\n1．2．5 面向程序员\t3\n1．2．6 缺点\t3\n1．3 C语言的应用范围\t3\n1．4 计算机能做什么\t4\n1．5 高级计算机语言和编译器\t5\n1．6 语言标准\t6\n1．6．1 第1个ANSI\/ISO C标准\t6\n1．6．2 C99标准\t6\n1．6．3 C11标准\t7\n1．7 使用C语言的7个步骤\t7\n1．7．1 第1步：定义程序的目标\t8\n1．7．2 第2步：设计程序\t8\n1．7．3 第3步：编写代码\t8\n1．7．4 第4步：编译\t8\n1．7．5 第5步：运行程序\t9\n1．7．6 第6步：测试和调试程序\t9\n1．7．7 第7步：维护和修改代码\t9\n1．7．8 说明\t9\n1．8 编程机制\t10\n1．8．1 目标代码文件、可执行文件和库\t10\n1．8．2 UNIX系统\t11\n1．8．3 GNU编译器集合和LLVM项目\t13\n1．8．4 Linux系统\t13\n1．8．5 PC的命令行编译器\t14\n1．8．6 集成开发环境（Windows）\t14\n1．8．7 Windows\/Linux\t15\n1．8．8 Macintosh中的C\t15\n1．9 本书的组织结构\t15\n1．10 本书的约定\t16\n1．10．1 字体\t16\n1．10．2 程序输出\t16\n1．10．3 特殊元素\t17\n1．11 本章小结\t17\n1．12 复习题\t18\n1．13 编程练习\t18\n第2章　C语言概述\t19\n2．1 简单的C程序示例\t19\n2．2 示例解释\t20\n2．2．1 第1遍：快速概要\t21\n2．2．2 第2遍：程序细节\t21\n2．3 简单程序的结构\t28\n2．4 提高程序可读性的技巧\t28\n2．5 进一步使用C\t29\n2．5．1 程序说明\t30\n2．5．2 多条声明\t30\n2．5．3 乘法\t30\n2．5．4 打印多个值\t30\n2．6 多个函数\t30\n2．7 调试程序\t32\n2．7．1 语法错误\t32\n2．7．2 语义错误\t33\n2．7．3 程序状态\t34\n2．8 关键字和保留标识符\t34\n2．9 关键概念\t35\n2．10 本章小结\t35\n2．11 复习题\t36\n2．12 编程练习\t37\n第3章　数据和C\t39\n3．1 示例程序\t39\n3．2 变量与常量数据\t42\n3．3 数据：数据类型关键字\t42\n3．3．1 整数和浮点数\t43\n3．3．2 整数\t43\n3．3．3 浮点数\t43\n3．4 C语言基本数据类型\t44\n3．4．1 int类型\t44\n3．4．2 其他整数类型\t47\n3．4．3 使用字符：char类型\t50\n3．4．4 _Bool类型\t54\n3．4．5 可移植类型：stdint．h和inttypes．h\t55\n3．4．6 float、double和long double\t56\n3．4．7 复数和虚数类型\t60\n3．4．8 其他类型\t60\n3．4．9 类型大小\t62\n3．5 使用数据类型\t63\n3．6 参数和陷阱\t63\n3．7 转义序列示例\t64\n3．7．1 程序运行情况\t65\n3．7．2 刷新输出\t65\n3．8 关键概念\t66\n3．9 本章小结\t66\n3．10 复习题\t67\n3．11 编程练习\t68\n第4章　字符串和格式化输入\/输出\t71\n4．1 前导程序\t71\n4．2 字符串简介\t72\n4．2．1 char类型数组和null字符\t72\n4．2．2 使用字符串\t73\n4．2．3 strlen()函数\t74\n4．3 常量和C预处理器\t76\n4．3．1 const限定符\t78\n4．3．2 明示常量\t78\n4．4 printf()和scanf()\t80\n4．4．1 printf()函数\t80\n4．4．2 使用printf()\t81\n4．4．3 printf()的转换说明修饰符\t83\n4．4．4 转换说明的意义\t87\n4．4．5 使用scanf()\t92\n4．4．6 printf()和scanf()的*修饰符\t95\n4．4．7 printf()的用法提示\t97\n4．5 关键概念\t98\n4．6 本章小结\t98\n4．7 复习题\t99\n4．8 编程练习\t100\n第5章　运算符、表达式和语句\t103\n5．1 循环简介\t103\n5．2 基本运算符\t105\n5．2．1 赋值运算符：=\t105\n5．2．2 加法运算符：+\t107\n5．2．3 减法运算符：-\t107\n5．2．4 符号运算符：-和+\t107\n5．2．5 乘法运算符：*\t108\n5．2．6 除法运算符：\/\t110\n5．2．7 运算符优先级\t110\n5．2．8 优先级和求值顺序\t112\n5．3 其他运算符\t113\n5．3．1 sizeof运算符和size_t类型\t113\n5．3．2 求模运算符：%\t114\n5．3．3 递增运算符：++\t115\n5．3．4 递减运算符：--\t118\n5．3．5 优先级\t118\n5．3．6 不要自作聪明\t119\n5．4 表达式和语句\t120\n5．4．1 表达式\t120\n5．4．2 语句\t120\n5．4．3 复合语句（块）\t123\n5．5 类型转换\t124\n5．6 带参数的函数\t127\n5．7 示例程序\t129\n5．8 关键概念\t130\n5．9 本章小结\t130\n5．10 复习题\t131\n5．11 编程练习\t134\n第6章　C控制语句：循环\t137\n6．1 再探while循环\t137\n6．1．1 程序注释\t138\n6．1．2 C风格读取循环\t139\n6．2 while语句\t140\n6．2．1 终止while循环\t140\n6．2．2 何时终止循环\t141\n6．2．3 while：入口条件循环\t141\n6．2．4 语法要点\t141\n6．3 用关系运算符和表达式比较大小\t143\n6．3．1 什么是真\t144\n6．3．2 其他真值\t145\n6．3．3 真值的问题\t146\n6．3．4 新的_Bool类型\t147\n6．3．5 优先级和关系运算符\t148\n6．4 不确定循环和计数循环\t150\n6．5 for循环\t151\n6．6 其他赋值运算符：+=、-=、*=、\/=、%=\t155\n6．7 逗号运算符\t156\n6．8 出口条件循环：do while\t159\n6．9 如何选择循环\t161\n6．10 嵌套循环\t162\n6．10．1 程序分析\t163\n6．10．2 嵌套变式\t163\n6．11 数组简介\t164\n6．12 使用函数返回值的循环示例\t166\n6．12．1 程序分析\t168\n6．12．2 使用带返回值的函数\t169\n6．13 关键概念\t169\n6．14 本章小结\t170\n6．15 复习题\t170\n6．16 编程练习\t174\n第7章　C控制语句：分支和跳转\t177\n7．1 if语句\t177\n7．2 if else语句\t179\n7．2．1 另一个示例：介绍getchar()和putchar()\t180\n7．2．2 ctype．h系列的字符函数\t182\n7．2．3 多重选择else if\t184\n7．2．4 else与if配对\t186\n7．2．5 多层嵌套的if语句\t187\n7．3 逻辑运算符\t190\n7．3．1 备选拼写：iso646．h头文件\t191\n7．3．2 优先级\t192\n7．3．3 求值顺序\t192\n7．3．4 范围\t193\n7．4 一个统计单词的程序\t194\n7．5 条件运算符：?：\t196\n7．6 循环辅助：continue和break\t198\n7．6．1 continue语句\t198\n7．6．2 break语句\t200\n7．7 多重选择：switch和break\t202\n7．7．1 switch语句\t204\n7．7．2 只读每行的首字符\t205\n7．7．3 多重标签\t206\n7．7．4 switch和if else\t208\n7．8 goto语句\t208\n7．9 关键概念\t211\n7．10 本章小结\t211\n7．11 复习题\t212\n7．12 编程练习\t214\n第8章　字符输入\/输出和输入验证\t217\n8．1 单字符I\/O：getchar()和putchar()\t217\n8．2 缓冲区\t218\n8．3 结束键盘输入\t219\n8．3．1 文件、流和键盘输入\t219\n8．3．2 文件结尾\t220\n8．4 重定向和文件\t222\n8．5 创建更友好的用户界面\t226\n8．5．1 使用缓冲输入\t226\n8．5．2 混合数值和字符输入\t228\n8．6 输入验证\t230\n8．6．1 分析程序\t234\n8．6．2 输入流和数字\t234\n8．7 菜单浏览\t235\n8．7．1 任务\t235\n8．7．2 使执行更顺利\t235\n8．7．3 混合字符和数值输入\t237\n8．8 关键概念\t240\n8．9 本章小结\t240\n8．10 复习题\t241\n8．11 编程练习\t241\n第9章　函数\t243\n9．1 复习函数\t243\n9．1．1 创建并使用简单函数\t244\n9．1．2 分析程序\t245\n9．1．3 函数参数\t247\n9．1．4 定义带形式参数的函数\t248\n9．1．5 声明带形式参数函数的原型\t249\n9．1．6 调用带实际参数的函数\t249\n9．1．7 黑盒视角\t250\n9．1．8 使用return从函数中返回值\t250\n9．1．9 函数类型\t252\n9．2 ANSI C函数原型\t253\n9．2．1 问题所在\t253\n9．2．2 ANSI的解决方案\t254\n9．2．3 无参数和未指定参数\t255\n9．2．4 函数原型的优点\t256\n9．3 递归\t256\n9．3．1 演示递归\t256\n9．3．2 递归的基本原理\t258\n9．3．3 尾递归\t258\n9．3．4 递归和倒序计算\t260\n9．3．5 递归的优缺点\t262\n9．4 编译多源代码文件的程序\t262\n9．4．1 UNIX\t263\n9．4．2 Linux\t263\n9．4．3 DOS命令行编译器\t263\n9．4．4 Windows和苹果的IDE编译器\t263\n9．4．5 使用头文件\t263\n9．5 查找地址：&运算符\t267\n9．6 更改主调函数中的变量\t268\n9．7 指针简介\t269\n9．7．1 间接运算符：*\t270\n9．7．2 声明指针\t270\n9．7．3 使用指针在函数间通信\t271\n9．8 关键概念\t274\n9．9 本章小结\t275\n9．10　复习题\t275\n9．11 编程练习\t276\n第10章　数组和指针\t277\n10．1 数组\t277\n10．1．1 初始化数组\t277\n10．1．2 指定初始化器（C99）\t281\n10．1．3 给数组元素赋值\t282\n10．1．4 数组边界\t282\n10．1．5 指定数组的大小\t284\n10．2 多维数组\t284\n10．2．1 初始化二维数组\t287\n10．2．2 其他多维数组\t288\n10．3 指针和数组\t288\n10．4 函数、数组和指针\t290\n10．4．1 使用指针形参\t293\n10．4．2 指针表示法和数组表示法\t294\n10．5 指针操作\t295\n10．6 保护数组中的数据\t298\n10．6．1 对形式参数使用const\t299\n10．6．2　const的其他内容\t300\n10．7 指针和多维数组\t302\n10．7．1 指向多维数组的指针\t304\n10．7．2 指针的兼容性\t305\n10．7．3 函数和多维数组\t306\n10．8 变长数组（VLA）\t309\n10．9 复合字面量\t312\n10．10 关键概念\t314\n10．11 本章小结\t315\n10．12 复习题\t316\n10．13 编程练习\t317\n第11章　字符串和字符串函数\t321\n11．1 表示字符串和字符串I\/O\t321\n11．1．1 在程序中定义字符串\t322\n11．1．2 指针和字符串\t328\n11．2 字符串输入\t329\n11．2．1 分配空间\t329\n11．2．2 不幸的gets()函数\t330\n11．2．3 gets()的替代品\t331\n11．2．4 scanf()函数\t336\n11．3 字符串输出\t337\n11．3．1 puts()函数\t338\n11．3．2 fputs()函数\t339\n11．3．3 printf()函数\t339\n11．4 自定义输入\/输出函数\t340\n11．5 字符串函数\t342\n11．5．1 strlen()函数\t342\n11．5．2 strcat()函数\t343\n11．5．3 strncat()函数\t345\n11．5．4 strcmp()函数\t346\n11．5．5 strcpy()和strncpy()函数\t351\n11．5．6 sprintf()函数\t356\n11．5．7 其他字符串函数\t357\n11．6 字符串示例：字符串排序\t359\n11．6．1 排序指针而非字符串\t360\n11．6．2 选择排序算法\t361\n11．7 ctype．h字符函数和字符串\t362\n11．8 命令行参数\t363\n11．8．1 集成环境中的命令行参数\t365\n11．8．2 Macintosh中的命令行参数\t365\n11．9 把字符串转换为数字\t365\n11．10 关键概念\t368\n11．11 本章小结\t368\n11．12 复习题\t369\n11．13 编程练习\t371\n第12章　存储类别、链接和内存管理\t373\n12．1 存储类别\t373\n12．1．1 作用域\t374\n12．1．2 链接\t376\n12．1．3 存储期\t376\n12．1．4 自动变量\t377\n12．1．5 寄存器变量\t380\n12．1．6 块作用域的静态变量\t381\n12．1．7 外部链接的静态变量\t382\n12．1．8 内部链接的静态变量\t386\n12．1．9 多文件\t386\n12．1．10 存储类别说明符\t387\n12．1．11 存储类别和函数\t389\n12．1．12 存储类别的选择\t389\n12．2 随机数函数和静态变量\t390\n12．3 掷骰子\t393\n12．4 分配内存：malloc()和free()\t396\n12．4．1 free()的重要性\t399\n12．4．2 calloc()函数\t400\n12．4．3 动态内存分配和变长数组\t400\n12．4．4 存储类别和动态内存分配\t401\n12．5 ANSI C类型限定符\t402\n12．5．1 const类型限定符\t403\n12．5．2 volatile类型限定符\t404\n12．5．3 restrict类型限定符\t405\n12．5．4 _Atomic类型限定符（C11）\t406\n12．5．5 旧关键字的新位置\t406\n12．6　关键概念\t407\n12．7 本章小结\t407\n12．8 复习题\t408\n12．9 编程练习\t409\n第13章　文件输入\/输出\t413\n13．1 与文件进行通信\t413\n13．1．1 文件是什么\t413\n13．1．2 文本模式和二进制模式\t413\n13．1．3 I\/O的级别\t415\n13．1．4 标准文件\t415\n13．2 标准I\/O\t415\n13．2．1 检查命令行参数\t416\n13．2．2 fopen()函数\t416\n13．2．3 getc()和putc()函数\t417\n13．2．4 文件结尾\t418\n13．2．5 fclose()函数\t419\n13．2．6 指向标准文件的指针\t419\n13．3 一个简单的文件压缩程序\t419\n13．4 文件I\/O：fprintf()、fscanf()、fgets()和fputs()\t421\n13．4．1 fprintf()和fscanf()函数\t421\n13．4．2 fgets()和fputs()函数\t422\n13．5 随机访问：fseek()和ftell()\t423\n13．5．1 fseek()和ftell()的工作原理\t424\n13．5．2 二进制模式和文本模式\t425\n13．5．3 可移植性\t425\n13．5．4 fgetpos()和fsetpos()函数\t426\n13．6 标准I\/O的机理\t426\n13．7 其他标准I\/O函数\t427\n13．7．1 int ungetc(int c， FILE *fp)函数\t427\n13．7．2 int fflush()函数\t428\n13．7．3 int setvbuf()函数\t428\n13．7．4 二进制I\/O：fread()和fwrite()\t428\n13．7．5 size_t fwrite()函数\t429\n13．7．6 size_t fread()函数\t430\n13．7．7 int feof(FILE *fp)和int ferror(FILE *fp)函数\t430\n13．7．8 一个程序示例\t430\n13．7．9 用二进制I\/O进行随机访问\t433\n13．8 关键概念\t435\n13．9 本章小结\t435\n13．10 复习题\t435\n13．11 编程练习\t437\n第14章　结构和其他数据形式\t439\n14．1 示例问题：创建图书目录\t439\n14．2 建立结构声明\t441\n14．3 定义结构变量\t441\n14．3．1 初始化结构\t442\n14．3．2 访问结构成员\t443\n14．3．3 结构的初始化器\t443\n14．4 结构数组\t444\n14．4．1 声明结构数组\t446\n14．4．2 标识结构数组的成员\t447\n14．4．3 程序讨论\t447\n14．5 嵌套结构\t448\n14．6 指向结构的指针\t449\n14．6．1 声明和初始化结构指针\t450\n14．6．2 用指针访问成员\t451\n14．7 向函数传递结构的信息\t451\n14．7．1 传递结构成员\t451\n14．7．2 传递结构的地址\t452\n14．7．3 传递结构\t453\n14．7．4 其他结构特性\t454\n14．7．5 结构和结构指针的选择\t458\n14．7．6 结构中的字符数组和字符指针\t458\n14．7．7 结构、指针和malloc()\t459\n14．7．8 复合字面量和结构（C99）\t462\n14．7．9 伸缩型数组成员（C99）\t463\n14．7．10 匿名结构（C11）\t465\n14．7．11 使用结构数组的函数\t466\n14．8 把结构内容保存到文件中\t467\n14．8．1 保存结构的程序示例\t468\n14．8．2 程序要点\t470\n14．9 链式结构\t471\n14．10 联合简介\t472\n14．10．1 使用联合\t472\n14．10．2 匿名联合（C11）\t473\n14．11 枚举类型\t474\n14．11．1 enum常量\t475\n14．11．2 默认值\t475\n14．11．3 赋值\t475\n14．11．4 enum的用法\t476\n14．11．5 共享名称空间\t477\n14．12 typedef简介\t478\n14．13 其他复杂的声明\t479\n14．14 函数和指针\t481\n14．15 关键概念\t487\n14．16 本章小结\t487\n14．17 复习题\t488\n14．18 编程练习\t490\n第15章　位操作\t493\n15．1 二进制数、位和字节\t493\n15．1．1 二进制整数\t494\n15．1．2 有符号整数\t494\n15．1．3 二进制浮点数\t495\n15．2 其他进制数\t495\n15．2．1 八进制\t495\n15．2．2 十六进制\t496\n15．3 C按位运算符\t496\n15．3．1 按位逻辑运算符\t497\n15．3．2 用法：掩码\t498\n15．3．3 用法：打开位（设置位）\t498\n15．3．4 用法：关闭位（清空位）\t499\n15．3．5 用法：切换位\t499\n15．3．6 用法：检查位的值\t500\n15．3．7 移位运算符\t500\n15．3．8 编程示例\t501\n15．3．9 另一个例子\t503\n15．4 位字段\t505\n15．4．1 位字段示例\t506\n15．4．2 位字段和按位运算符\t509\n15．5 对齐特性（C11）\t515\n15．6 关键概念\t516\n15．7 本章小结\t516\n15．8 复习题\t517\n15．9 编程练习\t518\n第16章　C预处理器和C库\t521\n16．1 翻译程序的第一步\t521\n16．2 明示常量：#define\t522\n16．2．1 记号\t525\n16．2．2 重定义常量\t525\n16．3 在#define中使用参数\t525\n16．3．1 用宏参数创建字符串：#运算符\t527\n16．3．2 预处理器黏合剂：##运算符\t528\n16．3．3 变参宏：．．．和_ _VA_ARGS_ _\t529\n16．4 宏和函数的选择\t530\n16．5 文件包含：#include\t531\n16．5．1 头文件示例\t531\n16．5．2 使用头文件\t533\n16．6 其他指令\t534\n16．6．1 #undef指令\t534\n16．6．2 从C预处理器角度看已定义\t534\n16．6．3 条件编译\t535\n16．6．4 预定义宏\t539\n16．6．5 #line和#error\t540\n16．6．6 #pragma\t540\n16．6．7 泛型选择（C11）\t541\n16．7 内联函数（C99）\t542\n16．8 _Noreturn函数（C11）\t544\n16．9 C库\t544\n16．9．1 访问C库\t544\n16．9．2 使用库描述\t545\n16．10 数学库\t546\n16．10．1 三角问题\t547\n16．10．2 类型变体\t548\n16．10．3 tgmath．h库（C99）\t550\n16．11 通用工具库\t550\n16．11．1 exit()和atexit()函数\t550\n16．11．2 qsort()函数\t552\n16．12 断言库\t556\n16．12．1 assert的用法\t556\n16．12．2 _Static_assert（C11）\t557\n16．13 string．h库中的memcpy()和memmove()\t558\n16．14 可变参数：stdarg．h\t560\n16．15 关键概念\t562\n16．16 本章小结\t562\n16．17 复习题\t562\n16．18 编程练习\t563\n第17章　高级数据表示\t567\n17．1 研究数据表示\t567\n17．2 从数组到链表\t570\n17．2．1 使用链表\t572\n17．2．2 反思\t576\n17．3 抽象数据类型（ADT）\t576\n17．3．1 建立抽象\t577\n17．3．2 建立接口\t578\n17．3．3 使用接口\t581\n17．3．4 实现接口\t583\n17．4 队列ADT\t589\n17．4．1 定义队列抽象数据类型\t590\n17．4．2 定义一个接口\t590\n17．4．3 实现接口数据表示\t591\n17．4．4 测试队列\t598\n17．5 用队列进行模拟\t600\n17．6 链表和数组\t605\n17．7 二叉查找树\t608\n17．7．1 二叉树ADT\t608\n17．7．2 二叉查找树接口\t609\n17．7．3 二叉树的实现\t611\n17．7．4 使用二叉树\t624\n17．7．5 树的思想\t628\n17．8 其他说明\t629\n17．9 关键概念\t630\n17．10 本章小结\t630\n17．11 复习题\t630\n17．12 编程练习\t631\n附录A　复习题答案\t633\n附录B　参考资料\t665\nB．1 参考资料I：补充阅读\t665\nB．2 参考资料II：C运算符\t667\nB．3 参考资料III：基本类型和存储类别\t671\nB．4 参考资料IV：表达式、语句和程序流\t675\nB．5 参考资料V：新增C99和C11的ANSI C库\t679\nB．6 参考资料VI：扩展的整数类型\t714\nB．7 参考资料VII：扩展字符支持\t716\nB．8 参考资料VIII：C99\/C11数值计算增强\t720\nB．9 参考资料IX：C和C++的区别\t726","pages":"730","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s29438897.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s29438897.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s29438897.jpg"},"alt":"https:\/\/book.douban.com\/subject\/26792521\/","id":"26792521","publisher":"人民邮电出版社","isbn10":"7115390592","isbn13":"9787115390592","title":"C Primer Plus（第6版）中文版","url":"https:\/\/api.douban.com\/v2\/book\/26792521","alt_title":"C Primer Plus : 6th","author_intro":"Stephen Prata曾在加利福尼亚的马林学院（肯特菲尔德）教授天文学、物理学和程序设计课程，现已退休。他在加州理工学院获得学士学位，在加州大学伯克利分校获得博士学位。他接触程序设计，是为了利用计算机给星团建模。Stephen撰写和与他人合著了十几本书籍，其中包括C++ Primer Plus和Unix Primer Plus。","summary":"《C Primer Plus（第6版）中文版》详细讲解了C语言的基本概念和编程技巧。\n《C Primer Plus（第6版）中文版》共17章。第1、2章介绍了C语言编程的预备知识。第3~15章详细讲解了C语言的相关知识，包括数据类型、格式化输入\/输出、运算符、表达式、语句、循环、字符输入和输出、函数、数组和指针、字符和字符串函数、内存管理、文件输入输出、结构、位操作等。第16章、17章介绍C预处理器、C库和高级数据表示。本书以完整的程序为例，讲解C语言的知识要点和注意事项。每章末设计了大量复习题和编程练习，帮助读者巩固所学知识和提高实际编程能力。附录给出了各章复习题的参考答案和丰富的参考资料。\n《C Primer Plus（第6版）中文版》可作为C语言的教材，适用于需要系统学习C语言的初学者，也适用于巩固C语言知识或希望进一步提高编程技术的程序员。","series":{"id":"23545","title":"C和C++实务精选"},"price":"CNY 89.00"},{"rating":{"max":10,"numRaters":389,"average":"9.3","min":0},"subtitle":"现代方法","author":["K. N. King"],"pubdate":"2010-4","tags":[{"count":526,"name":"C语言","title":"C语言"},{"count":315,"name":"C","title":"C"},{"count":240,"name":"程序设计","title":"程序设计"},{"count":239,"name":"编程","title":"编程"},{"count":230,"name":"计算机","title":"计算机"},{"count":182,"name":"C\/C++","title":"C\/C++"},{"count":162,"name":"编程语言","title":"编程语言"},{"count":128,"name":"计算机科学","title":"计算机科学"}],"origin_title":"C Programming: A Modern Approach, Second Edition","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s4171870.jpg","binding":"平装","translator":["吕秀锋","黄倩"],"catalog":"第1章 C语言概述1\n1.1 C语言的历史1\n1.1.1 起源1\n1.1.2 标准化1\n1.1.3 基于C的语言2\n1.2 C语言的优缺点3\n1.2.1 C语言的优点3\n1.2.2 C语言的缺点3\n1.2.3 高效地使用C语言4\n问与答5\n第2章 C语言基本概念7\n2.1 编写一个简单的C程序7\n程序显示双关语7\n2.1.1 编译和链接8\n2.1.2 集成开发环境8\n2.2 简单程序的一般形式9\n2.2.1 指令9\n2.2.2 函数9\n2.2.3 语句10\n2.2.4 显示字符串10\n2.3 注释11\n2.4 变量和赋值12\n2.4.1 类型12\n2.4.2 声明13\n2.4.3 赋值13\n2.4.4 显示变量的值14\n程序计算箱子的空间重量14\n2.4.5 初始化15\n2.4.6 显示表达式的值16\n2.5 读入输入16\n程序计算箱子的空间重量（改进版）16\n2.6 定义常量的名字17\n程序华氏温度转换为摄氏温度17\n2.7 标识符18\n2.8 C程序的书写规范19\n问与答21\n练习题23\n编程题24\n第3章 格式化输入\/输出26\n3.1 printf函数26\n3.1.1 转换说明27\n程序用printf函数格式化数28\n3.1.2 转义序列28\n3.2 scanf函数29\n3.2.1 scanf函数的工作方法30\n3.2.2 格式串中的普通字符31\n3.2.3 易混淆的printf函数和scanf函数32\n程序分数相加32\n问与答33\n练习题34\n编程题35\n第4章 表达式36\n4.1 算术运算符36\n程序计算通用产品代码的校验位38\n4.2 赋值运算符39\n4.2.1 简单赋值40\n4.2.2 左值41\n4.2.3 复合赋值41\n4.3 自增运算符和自减运算符42\n4.4 表达式求值43\n4.5 表达式语句45\n问与答45\n练习题47\n编程题49\n第5章 选择语句50\n5.1 逻辑表达式50\n5.1.1 关系运算符50\n5.1.2 判等运算符51\n5.1.3 逻辑运算符51\n5.2 if语句52\n5.2.1 复合语句53\n5.2.2 else子句53\n5.2.3 级联式if语句54\n程序计算股票经纪人的佣金55\n5.2.4 “悬空else”的问题56\n5.2.5 条件表达式57\n5.2.6 C89中的布尔值58\n5.2.7 C99中的布尔值58\n5.3 switch语句59\n程序显示法定格式的日期61\n问与答62\n练习题65\n编程题67\n第6章 循环69\n6.1 while语句69\n程序显示平方表71\n程序数列求和71\n6.2 do语句72\n程序计算整数的位数73\n6.3 for语句73\n6.3.1 for语句的惯用法74\n6.3.2 在for语句中省略表达式75\n6.3.3 C99中的for语句75\n6.3.4 逗号运算符76\n程序显示平方表（改进版）77\n6.4 退出循环78\n6.4.1 break语句78\n6.4.2 continue语句78\n6.4.3 goto语句79\n程序账簿结算80\n6.5 空语句81\n问与答83\n练习题84\n编程题85\n第7章 基本类型88\n7.1 整数类型88\n7.1.1 C99中的整数类型90\n7.1.2 整数常量90\n7.1.3 C99中的整数常量91\n7.1.4 整数溢出91\n7.1.5 读\/写整数91\n程序数列求和（改进版）92\n7.2 浮点类型93\n7.2.1 浮点常量94\n7.2.2 读\/写浮点数94\n7.3 字符类型94\n7.3.1 字符操作95\n7.3.2 有符号字符和无符号字符95\n7.3.3 算术类型96\n7.3.4 转义序列96\n7.3.5 字符处理函数97\n7.3.6 用scanf和printf读\/写字符98\n7.3.7 用getchar和putchar读\/写字符98\n程序确定消息的长度99\n7.4 类型转换100\n7.4.1 常用算术转换101\n7.4.2 赋值过程中的转换102\n7.4.3 C99中的隐式转换103\n7.4.4 强制类型转换103\n7.5 类型定义105\n7.5.1 类型定义的优点105\n7.5.2 类型定义和可移植性105\n7.6 sizeof运算符106\n问与答107\n练习题109\n编程题110\n第8章 数组113\n8.1 一维数组113\n8.1.1 数组下标113\n程序数列反向115\n8.1.2 数组初始化115\n8.1.3 指定初始化式116\n程序检查数中重复出现的数字116\n8.1.4 对数组使用sizeof运算符117\n程序计算利息118\n8.2 多维数组119\n8.2.1 多维数组初始化120\n8.2.2 常量数组121\n程序发牌121\n8.3 C99中的变长数组122\n问与答123\n练习题124\n编程题125\n第9章 函数129\n9.1 函数的定义和调用129\n程序计算平均值129\n程序显示倒计数130\n程序显示双关语（改进版）131\n9.1.1 函数定义132\n9.1.2 函数调用133\n程序判定素数134\n9.2 函数声明135\n9.3 实际参数136\n9.3.1 实际参数的转换137\n9.3.2 数组型实际参数138\n9.3.3 变长数组形式参数140\n9.3.4 在数组参数声明中使用static141\n9.3.5 复合字面量141\n9.4 return语句142\n9.5 程序终止143\n9.6 递归144\n程序快速排序146\n问与答147\n练习题150\n编程题153\n第10章 程序结构155\n10.1 局部变量155\n10.1.1 静态局部变量156\n10.1.2 形式参数156\n10.2 外部变量156\n10.2.1 示例：用外部变量实现栈156\n10.2.2 外部变量的利与弊157\n程序猜数158\n10.3 程序块161\n10.4 作用域162\n10.5 构建C程序163\n程序给一手牌分类163\n问与答169\n练习题169\n编程题170\n第11章 指针172\n11.1 指针变量172\n11.2 取地址运算符和间接寻址运算符173\n11.2.1 取地址运算符173\n11.2.2 间接寻址运算符174\n11.3 指针赋值174\n11.4 指针作为参数176\n程序找出数组中的最大元素和最小元素177\n11.5 指针作为返回值179\n问与答180\n练习题181\n编程题182\n第12章 指针和数组184\n12.1 指针的算术运算184\n12.1.1 指针加上整数185\n12.1.2 指针减去整数185\n12.1.3 两个指针相减186\n12.1.4 指针比较186\n12.1.5 指向复合常量的指针186\n12.2 指针用于数组处理186\n12.3 用数组名作为指针188程序数列反向（改进版）189\n12.3.1 数组型实际参数（改进版）189\n12.3.2 用指针作为数组名191\n12.4 指针和多维数组191\n12.4.1 处理多维数组的元素191\n12.4.2 处理多维数组的行192\n12.4.3 处理多维数组的列192\n12.4.4 用多维数组名作为指针192\n12.5 C99中的指针和变长数组193\n问与答194\n练习题195\n编程题197\n第13章 字符串198\n13.1 字符串字面量198\n13.1.1 字符串字面量中的转义序列198\n13.1.2 延续字符串字面量199\n13.1.3 如何存储字符串字面量199\n13.1.4 字符串字面量的操作200\n13.1.5 字符串字面量与字符常量200\n13.2 字符串变量200\n13.2.1 初始化字符串变量201\n13.2.2 字符数组与字符指针202\n13.3 字符串的读和写203\n13.3.1 用printf函数和puts函数写字符串203\n13.3.2 用scanf函数和gets函数读字符串203\n13.3.3 逐个字符读字符串204\n13.4 访问字符串中的字符205\n13.5 使用C语言的字符串库206\n13.5.1 strcpy函数207\n13.5.2 strlen函数208\n13.5.3 strcat函数208\n13.5.4 strcmp函数209程序显示一个月的提醒列表209\n13.6 字符串惯用法211\n13.6.1 搜索字符串的结尾211\n13.6.2 复制字符串213\n13.7 字符串数组214\n程序核对行星的名字217\n问与答218\n练习题220\n编程题222\n第14章 预处理器225\n14.1 预处理器的工作原理225\n14.2 预处理指令227\n14.3 宏定义227\n14.3.1 简单的宏227\n14.3.2 带参数的宏229\n14.3.3 #运算符231\n14.3.4 ##运算符231\n14.3.5 宏的通用属性232\n14.3.6 宏定义中的圆括号233\n14.3.7 创建较长的宏233\n14.3.8 预定义宏234\n14.3.9 C99中新增的预定义宏235\n14.3.10 空的宏参数236\n14.3.11 参数个数可变的宏236\n14.3.12 __func__标识符237\n14.4 条件编译237\n14.4.1 #if指令和#endif指令238\n14.4.2 defined运算符238\n14.4.3 #ifdef指令和#ifndef指令239\n14.4.4 #elif指令和#else指令239\n14.4.5 使用条件编译240\n14.5 其他指令240\n14.5.1 #error指令240\n14.5.2 #line指令241\n14.5.3 #pragma指令242\n14.5.4 _Pragma运算符242\n问与答243\n练习题245\n第15章 编写大型程序248\n15.1 源文件248\n15.2 头文件249\n15.2.1 #include指令249\n15.2.2 共享宏定义和类型定义250\n15.2.3 共享函数原型251\n15.2.4 共享变量声明252\n15.2.5 嵌套包含253\n15.2.6 保护头文件253\n15.2.7 头文件中的#error指令254\n15.3 把程序划分成多个文件254程序文本格式化255\n15.4 构建多文件程序260\n15.4.1 makefile260\n15.4.2 链接期间的错误262\n15.4.3 重新构建程序262\n15.4.4 在程序外定义宏264\n问与答264\n练习题265\n编程题266\n第16章 结构、联合和枚举267\n16.1 结构变量267\n16.1.1 结构变量的声明267\n16.1.2 结构变量的初始化269\n16.1.3 指定初始化269\n16.1.4 对结构的操作270\n16.2 结构类型270\n16.2.1 结构标记的声明271\n16.2.2 结构类型的定义272\n16.2.3 结构作为参数和返回值272\n16.2.4 复合字面量273\n16.3 嵌套的数组和结构274\n16.3.1 嵌套的结构274\n16.3.2 结构数组274\n16.3.3 结构数组的初始化275程序维护零件数据库275\n16.4 联合281\n16.4.1 用联合来节省空间282\n16.4.2 用联合来构造混合的数据结构284\n16.4.3 为联合添加“标记字段”284\n16.5 枚举285\n16.5.1 枚举标记和类型名286\n16.5.2 枚举作为整数286\n16.5.3 用枚举声明“标记字段”286\n问与答287\n练习题289\n编程题293\n第17章 指针的高级应用294\n17.1 动态存储分配294\n17.1.1 内存分配函数294\n17.1.2 空指针295\n17.2 动态分配字符串296\n……\n第18章 声明 327\n第19章 程序设计 345\n第20章 底层程序设计 363\n第21章 标准库 377\n第22章 输入\/输出 384\n第23章 库对数值和字符数据的支持 419\n第24章 错误处理 446\n第25章 国际化特性 456\n第26章 其他库函数 482\n第27章 C99对数学计算的新增支持 503\n附录A C语言运算符 524\n附录B C99与C89的比较 525\n附录C C89与经典C的比较 529\n附录D 标准库函数 532\n附录E ASCII字符集 569\n参考文献 570\n索引 573","pages":"600","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s4171870.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s4171870.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s4171870.jpg"},"alt":"https:\/\/book.douban.com\/subject\/4279678\/","id":"4279678","publisher":"人民邮电出版社","isbn10":"7115219575","isbn13":"9787115219572","title":"C语言程序设计","url":"https:\/\/api.douban.com\/v2\/book\/4279678","alt_title":"C Programming: A Modern Approach, Second Edition","author_intro":"K. N. King 世界知名的计算机程序设计教育家，现为佐治亚州立大学数学与计算机科学系副教授。他拥有耶鲁大学计算机科学硕士学位，加州大学伯克利分校计算机科学博士学位，曾任教于佐治亚理工学院。除本书外，他还撰写了广受欢迎的著作Modula-2: A Complete Guide 和Java Programming: From the Beginning，并在Dr.Dobb's Journal等权威杂志上发表了许多文章。\n吕秀锋，亚洲理工大学（AIT）计算机软件硕士，现为北京理工大学软件学院教师。多年来一直从事“计算机基础（双语）”、“C语言程序设计（双语）”以及“程序设计开发与实践”等本科生课程的教学工作，深受学生欢迎。她还译有《数据结构与算法：C＃语言描述》一书。\n黄倩，中国科学院计算技术研究所工学博士，中国计算机学会会员。研究方向包括视频处理、视频监控等，已在知名的国际期刊和国际会议论文集上发表10篇论文。译有《编程珠玑（第2版）》一书，受到读者欢迎。","summary":"时至今日， C语言仍然是计算机领域的通用语言之一，但今天的 C语言已经和最初的时候大不相同了。本书最主要的一个目的就是通过一种“现代方法”来介绍 C语言，书中强调标准 C，强调软件工程，不再强调“手工优化”。这一版中紧密结合了 C99标准，并与 C89标准进行对照，补充了 C99中的最新特性。本书分为 C语言的基础特性、 C语言的高级特性、 C语言标准库和参考资料 4个部分。每章末尾都有一个“问与答”小节给出一系列与该章内容相关的问题及答案，此外还包含适量的习题。\n本书是为大学本科阶段的 C语言课程编写的教材，同时也非常适合作为其他课程的辅助用书。","series":{"id":"50484","title":"图灵程序设计丛书·C\/C++系列"},"price":"79.00元"},{"rating":{"max":10,"numRaters":133,"average":"8.0","min":0},"subtitle":"C语言描述","author":["Kyle Loudon"],"pubdate":"2012-8","tags":[{"count":270,"name":"算法","title":"算法"},{"count":103,"name":"C语言","title":"C语言"},{"count":79,"name":"编程","title":"编程"},{"count":63,"name":"计算机","title":"计算机"},{"count":48,"name":"计算机科学","title":"计算机科学"},{"count":38,"name":"程序设计","title":"程序设计"},{"count":34,"name":"C","title":"C"},{"count":31,"name":"Programming","title":"Programming"}],"origin_title":"Mastering Algorithms with C","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s11351454.jpg","binding":"平装","translator":["肖翔","陈舸"],"catalog":"1. 前言\n2. 第1部分 预备知识\n3. 第1章 概述\n4. 数据结构简介\n5. 算法简介\n6. 小酌软件工程\n7. 如何使用本书\n8. 第2章 指针操作\n9. 指针基础\n10. 存储空间分配\n11. 数据集合与指针的算术运算\n12. 作为函数参数的指针\n13. 泛型指针与类型转换\n14. 函数指针\n15. 问与答\n16. 相关主题\n17. 第3章 递归\n18. 基本递归\n19. 尾递归\n20. 问与答\n21. 相关主题\n22. 第4章 算法分析\n23. 最坏情况分析\n24. O表示法\n25. 计算的复杂度\n26. 实例分析：插入排序\n27. 问与答\n28. 相关主题\n29. 第2部分 数据结构\n30. 第5章 链表\n31. 单链表介绍\n32. 单链表接口的定义\n33. 单链表的实现与分析\n34. 使用链表的例子：页帧管理\n35. 双向链表介绍\n36. 双向链表接口的定义\n37. 双向链表的实现与分析\n38. 循环链表介绍\n39. 循环链表接口的定义\n40. 循环链表的实现与分析\n41. 使用循环链表的例子：第二次机会页面置换法\n42. 问与答\n43. 相关主题\n44. 第6章 栈和队列\n45. 栈的描述\n46. 栈的接口定义\n47. 栈的实现与分析\n48. 队列的描述\n49. 队列的接口定义\n50. 队列的实现与分析\n51. 队列示例：事件处理\n52. 问与答\n53. 相关主题\n54. 第7章 集合\n55. 集合介绍\n56. 集合的性质\n57. 集合接口的定义\n58. 集合抽象数据类型的实现和分析\n59. Set示例：集合覆盖\n60. 问与答\n61. 相关主题\n62. 第8章 哈希表\n63. 链式哈希表的描述\n64. 链式哈希表的接口定义\n65. 链式哈希表的实现与分析\n66. 链式哈希表的例子：符号表\n67. 开地址哈希表的描述\n68. 开地址哈希函数的接口定义\n69. 开地址哈希表的实现与分析\n70. 问与答\n71. 相关主题\n72. 第9章 树\n73. 二叉树介绍\n74. 二叉树的接口定义\n75. 二叉树的实现与分析\n76. 二叉树示例：表达式处理\n77. 二叉搜索树介绍\n78. 二叉搜索树的接口定义\n79. 二叉搜索树的实现与分析\n80. 问与答\n81. 相关主题\n82. 第10章 堆和优先队列\n83. 堆的描述\n84. 堆的接口定义\n85. 堆的实现与分析\n86. 优先队列的描述\n87. 优先队列的接口定义\n88. 优先队列的实现与分析\n89. 优先队列的示例：包裹分拣\n90. 问与答\n91. 相关主题\n92. 第11章 图\n93. 图的描述\n94. 图的接口定义\n95. 图的实现与分析\n96. 关于图的应用举例：计算网络跳数\n97. 关于图的应用举例：拓扑排序\n98. 问与答\n99. 相关主题\n100. 第3部分 算法\n101. 第12章 排序和搜索\n102. 插入排序的描述\n103. 插入排序的接口定义\n104. 插入排序的实现与分析\n105. 快速排序的描述\n106. 快速排序的接口定义\n107. 快速排序的实现与分析\n108. 快速排序的例子：目录列表\n109. 归并排序的描述\n110. 归并排序的接口定义\n111. 归并排序的实现与分析\n112. 计数排序的描述\n113. 计数排序的接口定义\n114. 计数排序的实现与分析\n115. 基数排序的描述\n116. 基数排序的接口定义\n117. 基数排序的实现与分析\n118. 二分查找的描述\n119. 二分查找的接口定义\n120. 二分查找的实现与分析\n121. 二分查找的例子：拼写检查器\n122. 问与答\n123. 相关主题\n124. 第13章 数值计算\n125. 多项式插值法\n126. 多项式插值的接口定义\n127. 多项式插值的实现与分析\n128. 最小二乘估计法\n129. 最小二乘估计的接口定义\n130. 最小二乘估计的实现和分析\n131. 方程求解介绍\n132. 方程求解的接口定义\n133. 方程求解的实现与分析\n134. 问与答\n135. 相关主题\n136. 第14章 数据压缩\n137. 位操作的描述\n138. 位操作的接口定义\n139. 位操作的实现与分析\n140. 霍夫曼编码的描述\n141. 霍夫曼编码的接口定义\n142. 霍夫曼编码的分析与实现\n143. 霍夫曼编码的例子：网络优化\n144. LZ77的描述\n145. LZ77的接口定义\n146. LZ77的实现与分析\n147. 问与答\n148. 相关主题\n149. 第15章 数据加密\n150. DES算法介绍\n151. DES的接口定义\n152. DES算法的实现和分析\n153. DES应用举例：分组加密模式\n154. RSA算法介绍\n155. RSA的接口定义\n156. RSA算法的实现与分析\n157. 问与答\n158. 相关主题\n159. 第16章 图算法\n160. 最小生成树的描述\n161. 最小生成树的接口定义\n162. 最小生成树的实现与分析\n163. 最短路径的描述\n164. 最短路径的接口定义\n165. 最短路径的实现与分析\n166. 最短路径的例子：路由表\n167. 旅行商问题的描述\n168. 旅行商问题的接口定义\n169. 旅行商问题的实现与分析\n170. 问与答\n171. 相关主题\n172. 第17章 几何算法\n173. 测试线段是否相交\n174. 测试线段是否相交的标准方法\n175. 检测线段是否相交的接口定义\n176. 检测线段是否相交的实现与分析\n177. 凸包简介\n178. Jarvis’s March\n179. 凸包的接口定义\n180. 凸包的实现与分析\n181. 球面弧长\n182. 求解球面弧长的接口定义\n183. 求解球面弧长的实现和分析\n184. 球面弧长的应用举例：地球上两点之间的近似距离\n185. 问与答\n186. 相关主题","pages":"401","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s11351454.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s11351454.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s11351454.jpg"},"alt":"https:\/\/book.douban.com\/subject\/14267904\/","id":"14267904","publisher":"机械工业出版社","isbn10":"7111394267","isbn13":"9787111394266","title":"算法精解","url":"https:\/\/api.douban.com\/v2\/book\/14267904","alt_title":"Mastering Algorithms with C","author_intro":"Kyle Loudon是美国加州洛斯加托斯Jeppesen Dataplan公司的一名软件工程师，主管图形接口开发小组，主攻航迹规划软件的研发，这些软件主要用于商业航空公司、私营航空部门和其他一些航空制造业。在来到Jeppesen之前，Kyle在IBM公司是一名系统程序员。在技术上，Kyle主要对操作系统、网络、人机交互等领域感兴趣。1992年，Kyle在普渡大学拿到了计算机科学学士学位，并取得了法语的第二学位，同时他还被选入斐陶斐荣誉学会（美国大学优等生之荣誉学会）。他在普渡大学计算机系教了三年的计算机课程。在这期间，他完成了他个人的第一本书《Understanding Computers》，这本书用理论结合实践的方式介绍计算机的方方面面。如今，尽管他继续工作在硅谷的软件业，但他仍然坚韧不拔地在追求一个更高的学位。\n除了计算机，Kyle多年来喜欢打网球、教网球。他还喜欢山地骑行、滑冰，偶尔也和朋友们一起参加高尔夫课程。另外，Kyle还喜欢各种形式的戏剧、美食，以及某些风格的音乐和艺术；他期望成为钢琴家和艺术家，但希望渺茫。他现在在Jeppesen的工作是从他1992年开始驾驶飞机之后找到的。现在，他是一个拥有美国联邦航空局颁发的商业飞行员执照的飞行员。","summary":"本书是数据结构和算法领域的经典之作，十余年来，畅销不衰！全书共分为三部分：第一部分首先介绍了数据结构和算法的概念，以及使用它们的原因和意义，然后讲解了数据结构和算法中最常用的技术——指针和递归，最后还介绍了算法的分析方法，旨在为读者学习这本书打下坚实的基础；第二部分对链表、栈、队列、集合、哈希表、堆、图等常用数据结构进行了深入阐述；第三部分对排序、搜索数值计算、数据压缩、数据加密、图算法、几何算法等经典算法进行了精辟的分析和讲解。\n本书的众多特色使得它在同类书中独树一帜：具体实现都采用正式的C语言代码而不是伪代码，在很多数据结构和算法的实现过程中，有大量细节问题是伪代码不能解决的；每一章都有精心组织的主题和应用；全部示例来自真实的应用，不只是一般的练习；对每种数据结构、算法和示例都进行了详细分析；每一章的末尾都会有一系列问题和对应的回答，旨在强调这一章的重要思想……\n本书中的代码尤为值得强调：所有实现都采用C语言编写，所有代码都优先用于教学目的，所有代码都在4种平台上经过完整测试，头文件记录了所有公共的接口，命名规则适用于全书所有的代码，所有的代码都包含大量注释……\n本书内容包括：\n· 数据结构和算法的概念，以及使用它们的原因和意义\n· 指针和递归\n· 算法分析\n· 常用数据结构：链表、栈、队列、集合、哈希表、树、堆、优先级队列以及图\n· 排序和搜索\n· 数值计算\n· 数据压缩\n· 数据加密\n· 图算法\n· 几何算法","price":"79.00元"},{"rating":{"max":10,"numRaters":266,"average":"9.4","min":0},"subtitle":"42 Specific Ways to Improve Your Use of C++11 and C++14","author":["Scott Meyers"],"pubdate":"2014-12","tags":[{"count":330,"name":"C++","title":"C++"},{"count":168,"name":"C++11","title":"C++11"},{"count":111,"name":"C\/C++","title":"C\/C++"},{"count":86,"name":"编程","title":"编程"},{"count":80,"name":"计算机","title":"计算机"},{"count":72,"name":"Programming","title":"Programming"},{"count":49,"name":"程序设计","title":"程序设计"},{"count":34,"name":"effective","title":"effective"}],"origin_title":"","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s27951196.jpg","binding":"Paperback","translator":[],"catalog":"","pages":"320","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s27951196.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s27951196.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s27951196.jpg"},"alt":"https:\/\/book.douban.com\/subject\/25923597\/","id":"25923597","publisher":"O'Reilly Media","isbn10":"1491903996","isbn13":"9781491903995","title":"Effective Modern C++","url":"https:\/\/api.douban.com\/v2\/book\/25923597","alt_title":"","author_intro":"Scott Meyers is one of the world's foremost authorities on C++. He wrote the best-selling Effective C++ series (Effective C++, More Effective C++, and Effective STL); published and maintains the annotated training materials Overview of the New C++ (C++11\/14) and Effective C++ in an Embedded Environment; is Consulting Editor for the Effective Software Development Series, and, with Herb Sutter and Andrei Alexandrescu, is a principal in C++ and Beyond. He has a Ph.D in Computer Science from Brown University. He's currently working on a new book, Effective Modern C++, which he expects to publish this fall.","summary":"Learn how to program expertly with C++ with this practical book from Scott Meyers, one of the world's foremost authorities on this systems programming language. Scott Meyers takes some of the most difficult pieces of C++ code and unfurls them so that you can see how to manipulate your own project code. This is the first book to contain content written with the C++14 standard.\nTackle 42 separate C++ problems and solutions\nLearn critical techniques for success on topics from smart pointers to lambda expressions\nUnderstand key concepts by taking the C++ 98 standard to C++ 11 and then to C++ 14","price":"USD 49.99"},{"rating":{"max":10,"numRaters":625,"average":"9.1","min":0},"subtitle":"N．C. Wyeth 插图官方授权版本","author":["[美] 玛•金•罗琳斯"],"pubdate":"2016-6-1","tags":[{"count":198,"name":"自然","title":"自然"},{"count":183,"name":"美国文学","title":"美国文学"},{"count":183,"name":"外国文学","title":"外国文学"},{"count":146,"name":"玛•金•罗琳斯","title":"玛•金•罗琳斯"},{"count":136,"name":"美国","title":"美国"},{"count":135,"name":"成长","title":"成长"},{"count":129,"name":"我想读这本书","title":"我想读这本书"},{"count":128,"name":"小说","title":"小说"}],"origin_title":"The Yearling","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28748579.jpg","binding":"平装","translator":["梅静"],"catalog":"目录\n第一章 小水车\n第二章 乔迪的家\n第三章 飞来横祸\n第四章 猎熊\n第五章 草翅膀\n第六章 大快朵颐\n第七章 一桩好买卖\n第八章 意外收获\n第九章 灰岩坑\n第十章 夜晚的奇遇\n第十一章 猎鹿\n第十二章 仗义相助\n第十三章 告别奥利弗\n第十四章 危机\n第十五章 新伙伴\n第十六章 偷蜜和猎狐\n第十七章 痛失好友\n第十八章 怀念“草翅膀”\n第十九章 暴风雨\n第二十章 暴风雨后的森林\n第二十一章 瘟疫\n第二十二章 储粮\n第二十三章 狼群的夜袭\n第二十四章 猎狼\n第二十五章圣诞节前夕\n第二十六章 追捕“大笨脚”\n第二十七章 送别\n第二十八章 孤狼\n第二十九章 闯祸\n第三十章 爸爸病了\n第三十一章 无计可施\n第三十二章 再见，小鹿\n第三十三章 别了，童年","ebook_url":"https:\/\/read.douban.com\/ebook\/22165742\/","pages":"432","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s28748579.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s28748579.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28748579.jpg"},"alt":"https:\/\/book.douban.com\/subject\/26801361\/","id":"26801361","publisher":"云南人民出版社","isbn10":"7222145583","isbn13":"9787222145580","title":"鹿苑长春","url":"https:\/\/api.douban.com\/v2\/book\/26801361","alt_title":"The Yearling","author_intro":"【作者 】\n玛•金•罗琳斯\nMarjorie Kinnan Rawlings\n1896-1953\n美国作家  生于华盛顿， 毕业于威斯康星大学， 在纽约担任多年记者、编辑\n创建了佛罗里达边远林区的“地方文学”\n先后获得普利策奖、 欧·亨利奖、兰登书屋终身畅销奖\n创作的两部长篇小说《鹿苑长春》和《十字小溪》先后荣获普利策文学奖\n代表作《鹿苑长春》《十字小溪》《一位年轻姑娘》《南方月亮下》《金苹果》等\n【绘者】\nN.C.韦思\nNewell Convers Wyeth\n1882—1956\n美国现实主义绘画大师  一生创作近4000幅画作\n画作现收藏于布兰迪万河博物馆 、波特兰艺术博物馆和法恩斯沃斯艺术博物馆。1997年，他生活和工作的地方（宾夕法尼亚州查兹福德小镇墨菲路）被美国政府指定为国家历史地标之一。\n【译者】\n梅静\n北京大学外国语学院翻译硕士\n译有《柳林风声》《小鹿斑比》《小公主》《威士忌海滩》《孪生姐妹》《想飞的乔琪》《布谷鸟的呼唤》。","summary":"【“任何人遇到挫折的时候，都能够从这里得到新的勇气。”】\n【内容简介】\n《鹿苑长春》由美国作家玛·金·罗琳斯创作于1938年，根据佛罗里达林区一位老人的童年回忆创作改编，发行后登上美国畅销书榜首并持续140周，于次年获得普利策文学奖。至今，在美国累计阅读量达到5.5亿。至今，该小说被翻译成20种语言，在133个国家出版，受到不同地域和文化人们的喜爱。在1946年被米高梅公司拍摄成电影，获得奥斯卡最佳艺术指导奖和最佳摄影奖。\n故事讲述美国南北战争后佛罗里达垦荒区普通人的劳动、斗争和悲欢离合。主人公巴克斯特一家生活在佛罗里达岛地过着自给自足的农耕狩猎生活，所处的自然美景中是一幅生动绚丽的丛林画卷，该作品后被誉为描绘少年时代的经典童年诗歌。然而，它却是一本全年龄段读本，书中透出的森林清新气息和舒缓节奏，与当代都市生活迥然不同。其中有惊险的狩猎、奇妙的自然景观、悠然的乡村美景，还有风趣幽默的人物对话，以及充满泥土气息的方言。书中人们为了生存这一简单目的，持有着最质朴的勇气和信念。\n孩子们可以从书中读到激动人心的狩猎，看见原野林莽、飞鸟起落、狼踪熊迹、暴雨狂风，进入乔迪的世界，与他共度被爸爸精心呵护、无忧无虑的童年。成年人，尤其是经历过离合悲欢、人世艰难的人，都能从书中读出欢笑、甜蜜、惆怅和感伤。\n【编辑推荐】\n《鹿苑长春》是一部经典的动物文学与环境文学著作。\n故事发生在美国南北战争结束后的垦荒时代，讲述与父母生活在佛罗里达岛地的男孩乔迪与一岁小鹿间的故事。\n爸爸在牧师家庭长大，正直善良，从不说谎，因经历战争后，厌倦了与人相处的世俗，带着妻子奥拉远离城镇，选择佛罗里达的巴克斯特岛地，过着狩猎农耕的生活。家中的生计依赖于自然选择，时常受到岛地周围野兽的威胁，尤其是经常出没偷食家畜的棕熊“大笨脚”。\n因为自然环境的严酷，夫妻两人连续夭折了3个孩子，以至于乔迪诞生后，妈妈奥拉因为遭遇太多次失去，对儿子不抱有太多疼爱，也许是向现实的冷酷低头，看待事物抱有异常冷漠的清醒。爸爸彭尼从小在家中担起大梁，了解天真无邪的珍贵，反而给乔迪加倍的疼爱，试图延长乔迪无忧无虑的童年。在丛林里，有变幻的迷人风光，也有让人惊叹的动物奇观。乔迪一直喜欢听猎人讲在狩猎途中的奇遇，期待着自己与动物的亲近。\n他跟着爸爸狩猎，追踪“大笨脚”，爬在树上看鹿妈妈带着小鹿啃食树叶，与爸爸抓到罕见的白色浣熊、在克拉克莎草丛中钓鱼，遇到高鸣鹤跳沙龙舞；他跟着巴克.福利斯特在月光下的玉米地里猎狐，去松树干掏蜂蜜；与好友“草翅膀”喂养小浣熊、欧洲灰雀，一起看西班牙人后裔穿过古栈道，一起数天上米诺鱼般的星星……生活就像他给自己在灰岩坑水塘边造的小水车，随着时间的流水，悠然转动，奏出欢快的乐章，似乎没有停下来的理由。\n然而乔迪作为独子，在偏远岛地，一直是孤寂的。他希望能像爸爸彭尼一样拥有只对自己忠诚的宠物。因为口粮不足，妈妈却一直拒绝驯养动物。直到有一天，在乔迪跟随爸爸追踪走失家猪的途中，遭遇危机，也遇到了那头刚出生不久的小鹿……\n故事讲失去，也讲成长；讲孤独，也讲爱与宽容。每个人也许会从中找到真挚的共鸣，遗憾和怅惘，但更多的是，是勇气。\n【名人推荐】\n“谈到近人的作品，说「不朽」总彷佛还太早，然而《鹿苑长春》在近代文学上的地位已经奠定了。《鹿苑长春》里面出现的动物比人多──鹿、响尾蛇、八字脚的老熊、牛、马、猪──像一个动物园，但是里面的人物，尤其是那男孩子乔迪，是使人永远不能忘记的。\n那孩子失去了他最心爱的东西，使他受到很深的刺激，然而他从此就坚强起来，长大成人了。我们仔细回味，就可以觉得这不止于是一个孩子的故事，任何人遇到挫折的时候，都能够从这里得到新的勇气。\n这故事具有真正的悲剧的因素──无法避免，也不可挽回。书中对于儿童心理有非常深入的描写，可以帮助做父母的人了解自己的子女。写父爱也发掘到人性的深处。\n它是健康的，向上的，但也许它最动人的地方是与东方的心情特别接近的一种淡淡的哀愁。最后的两段更是充满了一种难堪的怅惘，我译到这里的时候，甚至于译完之后重抄一遍，抄到这里的时候，也都是像第一次读到一样地觉得非常感动，眼睛湿润起来。我相信许多读者一定也有同感。”\n——张爱玲\n【媒体推荐】\n\n在罗琳斯女士之前，还没有谁创造出如此栩栩如生且亲近读者的一系列形象，其亲密的感情感染人，不禁令人产生共鸣。\n——纽约时报\n“Never before has Mrs. Rawlings created a set of characters who are so close and real to the reader, whose intimate life one can share without the taint of unconscious patronage.\" (The New York Times)\n惊心动魄的探险和令人怅惘的人性元素……这是一部不愧于普利策奖桂冠的经典作品，故事质朴的语言和四季变化下的生态智慧，都给予这本书一种独特而难忘的气质。而画家N.C.韦思也以温暖、柔和的插图，恰到好处地捕捉到那个垦荒时代的粗莽和淳美。\n——亚马逊网站\n“Heart-stopping adventure and heart-wrenching human element…. This is a classic well worth its Pulitzer Prize. Earthy dialect and homespun wisdom season the story, giving it a unique and unforgettable flavor, and N.C. Wyeth's warm, soft illustrations capture an era of rough subsistence and sweet survival.”\n(Amazon.com)","ebook_price":"12.00","price":"48.00元"},{"rating":{"max":10,"numRaters":531,"average":"8.9","min":0},"subtitle":"使用Visual C++5.0 & MFC 4.2","author":["侯俊杰"],"pubdate":"2001-1","tags":[{"count":303,"name":"MFC","title":"MFC"},{"count":174,"name":"C++","title":"C++"},{"count":108,"name":"计算机","title":"计算机"},{"count":92,"name":"编程","title":"编程"},{"count":74,"name":"深入浅出MFC","title":"深入浅出MFC"},{"count":72,"name":"侯捷","title":"侯捷"},{"count":64,"name":"Windows","title":"Windows"},{"count":38,"name":"经典","title":"经典"}],"origin_title":"","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28952279.jpg","binding":"平装16开","translator":[],"catalog":"第一篇 勿在浮砂筑高台\n第一章 Win32 程序基本概念\n第二章 C++的重要性质\n第三章 MFC六大关键技术之仿真\n第二篇 欲善工事先利其器\n第四章 Visual C++ 集成开发环境\n第三篇 浅出MFC程序设计\n第五章 总观Application Framework\n第六章 MFC程序的生死因果\n第七章 简单而完整：MFC骨干程序\n第四篇 深入MFC 程序设计\n第八章 Document-View深入探讨\n第九章 消息映射与命令传递\n第十章 MFC与对话框\n第十一章 Vies功能的加强与重绘效率的提高\n第十二章 打印与预览\n第十三章 多重文件与多重视图\n第十四章 MFC 多线程程序设计\n第十五章 站在众人的肩膀――使用Components & ActiveX Controls\n第五篇 附录","pages":"701","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s28952279.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s28952279.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28952279.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1094852\/","id":"1094852","publisher":"华中科技大学出版社","isbn10":"7900614931","isbn13":"9787900614933","title":"深入浅出MFC （第二版）","url":"https:\/\/api.douban.com\/v2\/book\/1094852","alt_title":"","author_intro":"侯俊杰（1961年9月28日－），笔名侯捷，台湾知名电脑技术专栏作家，致力于电脑技术之扎根工作，文章兼具科技之长与灵性之美，有读者的评语是“比作家更工程师，比工程师更作家”。大同国中、师大附中、交通大学土木系毕业、清华大学动力机械研究所硕士。曾任职工研院机械所与电通所，曾在元智大学授课，近年来多从事两岸学术交流工作。他的妻子美静是一名钢琴师，侯俊杰说他自己“嗜咖啡。妻严不能常得。”","summary":"《深入浅出MFC》分为四大篇。第一篇提出学习MFC程序设计之前的必要基础，包括Widnows程序的基本观念以及C++的高阶议题。“学前基础”是相当主观的认定，但作者是甚于自己的学习经验以及教学经验，其挑选应该颇具说服力。第二篇介绍Visual C++整合环境开发工具。此篇只是提纲挈领，并不企图取代Visual C++使用手册；然而对于软件使用的老手，此篇或已足以帮助掌握Visual C++整合环境。工具的使用虽然谈不上学问，但在视觉化软件开发过程中扮演极重角色。第三篇介绍application framework的观念，以及MFC骨干程序，所谓骨干程序，是指Visual C++的工具AppWizard所产生出来的程序码。当然，AppWizard会根据使用者的选项做出不同的程序码，作者据以解说的是大众化选项下的产品。第四篇以微软公司附于Visual C++光碟片上的一个范例程序Scribble为主轴，一步一步加上新的功能；并在其间深入介绍Runtime Type Information（RTTI）、Dynamic Creation、Persistence（Serialization）、Message Mapping、Command Routing等核心技术。这些技术正是其他专著最缺乏的部分。此篇的最后数章则脱离Scribble程序，另成一格。\n这本书配有一片光盘，书中所有原始码与可执行文件都在其中。","price":"80.00元"},{"rating":{"max":10,"numRaters":457,"average":"8.8","min":0},"subtitle":"使用muduo C++网络库","author":["陈硕"],"pubdate":"2013-1-15","tags":[{"count":607,"name":"网络编程","title":"网络编程"},{"count":543,"name":"Linux","title":"Linux"},{"count":541,"name":"C++","title":"C++"},{"count":454,"name":"多线程","title":"多线程"},{"count":155,"name":"计算机","title":"计算机"},{"count":143,"name":"编程","title":"编程"},{"count":110,"name":"C\/C++","title":"C\/C++"},{"count":87,"name":"Networks","title":"Networks"}],"origin_title":"","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s24522799.jpg","binding":"平装","translator":[],"catalog":"第1 部分C++ 多线程系统编程1\n第1章 线程安全的对象生命期管理3\n1.1 当析构函数遇到多线程. . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n1.1.1 线程安全的定义. . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\n1.1.2 MutexLock 与MutexLockGuard . . . . . . . . . . . . . . . . . . . . 4\n1.1.3 一个线程安全的Counter 示例. . . . . . . . . . . . . . . . . . . . 4\n1.2 对象的创建很简单. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n1.3 销毁太难. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n1.3.1 mutex 不是办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n1.3.2 作为数据成员的mutex 不能保护析构. . . . . . . . . . . . . . . 8\n1.4 线程安全的Observer 有多难. . . . . . . . . . . . . . . . . . . . . . . . . 8\n1.5 原始指针有何不妥. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n1.6 神器shared_ptr\/weak_ptr . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n1.7 插曲：系统地避免各种指针错误. . . . . . . . . . . . . . . . . . . . . . . 14\n1.8 应用到Observer 上. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\n1.9 再论shared_ptr 的线程安全. . . . . . . . . . . . . . . . . . . . . . . . . 17\n1.10 shared_ptr 技术与陷阱. . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n1.11 对象池. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21\n1.11.1 enable_shared_from_this . . . . . . . . . . . . . . . . . . . . . . 23\n1.11.2 弱回调. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\n1.12 替代方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n1.13 心得与小结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n1.14 Observer 之谬. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\n第2章 线程同步精要31\n2.1 互斥器（mutex） . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32\n2.1.1 只使用非递归的mutex . . . . . . . . . . . . . . . . . . . . . . . . 33\n2.1.2 死锁. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\n2.2 条件变量（condition variable） . . . . . . . . . . . . . . . . . . . . . . . 40\n2.3 不要用读写锁和信号量. . . . . . . . . . . . . . . . . . . . . . . . . . . . 43\n2.4 封装MutexLock、MutexLockGuard、Condition . . . . . . . . . . . . . . 44\n2.5 线程安全的Singleton 实现. . . . . . . . . . . . . . . . . . . . . . . . . . 48\n2.6 sleep(3) 不是同步原语. . . . . . . . . . . . . . . . . . . . . . . . . . . . 50\n2.7 归纳与总结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\n2.8 借shared_ptr 实现copy-on-write . . . . . . . . . . . . . . . . . . . . . . 52\n第3章 多线程服务器的适用场合与常用编程模型59\n3.1 进程与线程. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59\n3.2 单线程服务器的常用编程模型. . . . . . . . . . . . . . . . . . . . . . . . 61\n3.3 多线程服务器的常用编程模型. . . . . . . . . . . . . . . . . . . . . . . . 62\n3.3.1 one loop per thread . . . . . . . . . . . . . . . . . . . . . . . . . . 62\n3.3.2 线程池. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63\n3.3.3 推荐模式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64\n3.4 进程间通信只用TCP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65\n3.5 多线程服务器的适用场合. . . . . . . . . . . . . . . . . . . . . . . . . . . 67\n3.5.1 必须用单线程的场合. . . . . . . . . . . . . . . . . . . . . . . . . 69\n3.5.2 单线程程序的优缺点. . . . . . . . . . . . . . . . . . . . . . . . . 70\n3.5.3 适用多线程程序的场景. . . . . . . . . . . . . . . . . . . . . . . . 71\n3.6 “多线程服务器的适用场合”例释与答疑. . . . . . . . . . . . . . . . . . 74\n第4章 C++ 多线程系统编程精要83\n4.1 基本线程原语的选用. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84\n4.2 C\/C++ 系统库的线程安全性. . . . . . . . . . . . . . . . . . . . . . . . . 85\n4.3 Linux 上的线程标识. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89\n4.4 线程的创建与销毁的守则. . . . . . . . . . . . . . . . . . . . . . . . . . . 91\n4.4.1 pthread_cancel 与C++ . . . . . . . . . . . . . . . . . . . . . . . 94\n4.4.2 exit(3) 在C++ 中不是线程安全的. . . . . . . . . . . . . . . . . 94\n4.5 善用__thread 关键字. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96\n4.6 多线程与IO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98\n4.7 用RAII 包装文件描述符. . . . . . . . . . . . . . . . . . . . . . . . . . . 99\n4.8 RAII 与fork() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101\n4.9 多线程与fork() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102\n4.10 多线程与signal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103\n4.11 Linux 新增系统调用的启示. . . . . . . . . . . . . . . . . . . . . . . . . . 105\n第5章 高效的多线程日志107\n5.1 功能需求. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109\n5.2 性能需求. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112\n5.3 多线程异步日志. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114\n5.4 其他方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120\n第2部分 muduo 网络库123\n第6章 muduo 网络库简介125\n6.1 由来. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125\n6.2 安装. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127\n6.3 目录结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129\n6.3.1 代码结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131\n6.3.2 例子. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134\n6.3.3 线程模型. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135\n6.4 使用教程. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136\n6.4.1 TCP 网络编程本质论. . . . . . . . . . . . . . . . . . . . . . . . . 136\n6.4.2 echo 服务的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . 138\n6.4.3 七步实现finger 服务. . . . . . . . . . . . . . . . . . . . . . . . . 140\n6.5 性能评测. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144\n6.5.1 muduo 与Boost.Asio、libevent2 的吞吐量对比. . . . . . . . . . 145\n6.5.2 击鼓传花：对比muduo 与libevent2 的事件处理效率. . . . . . 148\n6.5.3 muduo 与Nginx 的吞吐量对比. . . . . . . . . . . . . . . . . . . 153\n6.5.4 muduo 与ZeroMQ 的延迟对比. . . . . . . . . . . . . . . . . . . 156\n6.6 详解muduo 多线程模型. . . . . . . . . . . . . . . . . . . . . . . . . . . 157\n6.6.1 数独求解服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . . 157\n6.6.2 常见的并发网络服务程序设计方案. . . . . . . . . . . . . . . . . 160\n第7章 muduo 编程示例177\n7.1 五个简单TCP 示例. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178\n7.2 文件传输. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185\n7.3 Boost.Asio 的聊天服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . 194\n7.3.1 TCP 分包. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194\n7.3.2 消息格式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195\n7.3.3 编解码器LengthHeaderCodec . . . . . . . . . . . . . . . . . . . . 197\n7.3.4 服务端的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198\n7.3.5 客户端的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200\n7.4 muduo Buffer 类的设计与使用. . . . . . . . . . . . . . . . . . . . . . . 204\n7.4.1 muduo 的IO 模型. . . . . . . . . . . . . . . . . . . . . . . . . . 204\n7.4.2 为什么non-blocking 网络编程中应用层buffer 是必需的. . . . 205\n7.4.3 Buffer 的功能需求. . . . . . . . . . . . . . . . . . . . . . . . . . 207\n7.4.4 Buffer 的数据结构. . . . . . . . . . . . . . . . . . . . . . . . . . 209\n7.4.5 Buffer 的操作. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211\n7.4.6 其他设计方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217\n7.4.7 性能是不是问题. . . . . . . . . . . . . . . . . . . . . . . . . . . . 218\n7.5 一种自动反射消息类型的Google Protobuf 网络传输方案. . . . . . . . 220\n7.5.1 网络编程中使用Protobuf 的两个先决条件. . . . . . . . . . . . . 220\n7.5.2 根据type name 反射自动创建Message 对象. . . . . . . . . . . . 221\n7.5.3 Protobuf 传输格式. . . . . . . . . . . . . . . . . . . . . . . . . . 226\n7.6 在muduo 中实现Protobuf 编解码器与消息分发器. . . . . . . . . . . . 228\n7.6.1 什么是编解码器（codec） . . . . . . . . . . . . . . . . . . . . . . 229\n7.6.2 实现ProtobufCodec . . . . . . . . . . . . . . . . . . . . . . . . . 232\n7.6.3 消息分发器（dispatcher）有什么用. . . . . . . . . . . . . . . . 232\n7.6.4 ProtobufCodec 与ProtobufDispatcher 的综合运用. . . . . . . 233\n7.6.5 ProtobufDispatcher 的两种实现. . . . . . . . . . . . . . . . . . 234\n7.6.6 ProtobufCodec 和ProtobufDispatcher 有何意义. . . . . . . . . 236\n7.7 限制服务器的最大并发连接数. . . . . . . . . . . . . . . . . . . . . . . . 237\n7.7.1 为什么要限制并发连接数. . . . . . . . . . . . . . . . . . . . . . 237\n7.7.2 在muduo 中限制并发连接数. . . . . . . . . . . . . . . . . . . . 238\n7.8 定时器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240\n7.8.1 程序中的时间. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240\n7.8.2 Linux 时间函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . 241\n7.8.3 muduo 的定时器接口. . . . . . . . . . . . . . . . . . . . . . . . . 242\n7.8.4 Boost.Asio Timer 示例. . . . . . . . . . . . . . . . . . . . . . . . 243\n7.8.5 Java Netty 示例. . . . . . . . . . . . . . . . . . . . . . . . . . . . 245\n7.9 测量两台机器的网络延迟和时间差. . . . . . . . . . . . . . . . . . . . . 248\n7.10 用timing wheel 踢掉空闲连接. . . . . . . . . . . . . . . . . . . . . . . . 250\n7.10.1 timing wheel 原理. . . . . . . . . . . . . . . . . . . . . . . . . . 251\n7.10.2 代码实现与改进. . . . . . . . . . . . . . . . . . . . . . . . . . . . 254\n7.11 简单的消息广播服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257\n7.12 “串并转换”连接服务器及其自动化测试. . . . . . . . . . . . . . . . . . 260\n7.13 socks4a 代理服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264\n7.13.1 TCP 中继器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264\n7.13.2 socks4a 代理服务器. . . . . . . . . . . . . . . . . . . . . . . . . . 267\n7.13.3 N : 1 与1 : N 连接转发. . . . . . . . . . . . . . . . . . . . . . . . 267\n7.14 短址服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267\n7.15 与其他库集成. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268\n7.15.1 UDNS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270\n7.15.2 c-ares DNS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272\n7.15.3 curl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273\n7.15.4 更多. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275\n第8章 muduo 网络库设计与实现277\n8.0 什么都不做的EventLoop . . . . . . . . . . . . . . . . . . . . . . . . . . . 277\n8.1 Reactor 的关键结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280\n8.1.1 Channel class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280\n8.1.2 Poller class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283\n8.1.3 EventLoop 的改动. . . . . . . . . . . . . . . . . . . . . . . . . . . 287\n8.2 TimerQueue 定时器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290\n8.2.1 TimerQueue class . . . . . . . . . . . . . . . . . . . . . . . . . . . 290\n8.2.2 EventLoop 的改动. . . . . . . . . . . . . . . . . . . . . . . . . . . 292\n8.3 EventLoop::runInLoop() 函数. . . . . . . . . . . . . . . . . . . . . . . . 293\n8.3.1 提高TimerQueue 的线程安全性. . . . . . . . . . . . . . . . . . . 296\n8.3.2 EventLoopThread class . . . . . . . . . . . . . . . . . . . . . . . . 297\n8.4 实现TCP 网络库. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299\n8.5 TcpServer 接受新连接. . . . . . . . . . . . . . . . . . . . . . . . . . . . 303\n8.5.1 TcpServer class . . . . . . . . . . . . . . . . . . . . . . . . . . . . 304\n8.5.2 TcpConnection class . . . . . . . . . . . . . . . . . . . . . . . . . 305\n8.6 TcpConnection 断开连接. . . . . . . . . . . . . . . . . . . . . . . . . . . 308\n8.7 Buffer 读取数据. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 313\n8.7.1 TcpConnection 使用Buffer 作为输入缓冲. . . . . . . . . . . . . 314\n8.7.2 Buffer::readFd() . . . . . . . . . . . . . . . . . . . . . . . . . . 315\n8.8 TcpConnection 发送数据. . . . . . . . . . . . . . . . . . . . . . . . . . . 316\n8.9 完善TcpConnection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 320\n8.9.1 SIGPIPE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321\n8.9.2 TCP No Delay 和TCP keepalive . . . . . . . . . . . . . . . . . . 321\n8.9.3 WriteCompleteCallback 和HighWaterMarkCallback . . . . . . . 322\n8.10 多线程TcpServer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 324\n8.11 Connector . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327\n8.12 TcpClient . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 332\n8.13 epoll . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333\n8.14 测试程序一览. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 336\n第3部分 工程实践经验谈337\n第9章 分布式系统工程实践339\n9.1 我们在技术浪潮中的位置. . . . . . . . . . . . . . . . . . . . . . . . . . . 341\n9.1.1 分布式系统的本质困难. . . . . . . . . . . . . . . . . . . . . . . . 343\n9.1.2 分布式系统是个险恶的问题. . . . . . . . . . . . . . . . . . . . . 344\n9.2 分布式系统的可靠性浅说. . . . . . . . . . . . . . . . . . . . . . . . . . . 349\n9.2.1 分布式系统的软件不要求7  24 可靠. . . . . . . . . . . . . . . . 352\n9.2.2 “能随时重启进程”作为程序设计目标. . . . . . . . . . . . . . . 354\n9.3 分布式系统中心跳协议的设计. . . . . . . . . . . . . . . . . . . . . . . . 356\n9.4 分布式系统中的进程标识. . . . . . . . . . . . . . . . . . . . . . . . . . . 360\n9.4.1 错误做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361\n9.4.2 正确做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 362\n9.4.3 TCP 协议的启示. . . . . . . . . . . . . . . . . . . . . . . . . . . . 363\n9.5 构建易于维护的分布式程序. . . . . . . . . . . . . . . . . . . . . . . . . 364\n9.6 为系统演化做准备. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 367\n9.6.1 可扩展的消息格式. . . . . . . . . . . . . . . . . . . . . . . . . . 368\n9.6.2 反面教材：ICE 的消息打包格式. . . . . . . . . . . . . . . . . . . 369\n9.7 分布式程序的自动化回归测试. . . . . . . . . . . . . . . . . . . . . . . . 370\n9.7.1 单元测试的能与不能. . . . . . . . . . . . . . . . . . . . . . . . . 370\n9.7.2 分布式系统测试的要点. . . . . . . . . . . . . . . . . . . . . . . . 373\n9.7.3 分布式系统的抽象观点. . . . . . . . . . . . . . . . . . . . . . . . 374\n9.7.4 一种自动化的回归测试方案. . . . . . . . . . . . . . . . . . . . . 375\n9.7.5 其他用处. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 379\n9.8 分布式系统部署、监控与进程管理的几重境界. . . . . . . . . . . . . . . 380\n9.8.1 境界1：全手工操作. . . . . . . . . . . . . . . . . . . . . . . . . 382\n9.8.2 境界2：使用零散的自动化脚本和第三方组件. . . . . . . . . . . 383\n9.8.3 境界3：自制机群管理系统，集中化配置. . . . . . . . . . . . . 386\n9.8.4 境界4：机群管理与naming service 结合. . . . . . . . . . . . . 389\n第10章 C++ 编译链接模型精要391\n10.1 C 语言的编译模型及其成因. . . . . . . . . . . . . . . . . . . . . . . . . 394\n10.1.1 为什么C 语言需要预处理. . . . . . . . . . . . . . . . . . . . . . 395\n10.1.2 C 语言的编译模型. . . . . . . . . . . . . . . . . . . . . . . . . . . 398\n10.2 C++ 的编译模型. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399\n10.2.1 单遍编译. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399\n10.2.2 前向声明. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 402\n10.3 C++ 链接（linking） . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 404\n10.3.1 函数重载. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 406\n10.3.2 inline 函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 407\n10.3.3 模板. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 409\n10.3.4 虚函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 414\n10.4 工程项目中头文件的使用规则. . . . . . . . . . . . . . . . . . . . . . . . 415\n10.4.1 头文件的害处. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 416\n10.4.2 头文件的使用规则. . . . . . . . . . . . . . . . . . . . . . . . . . 417\n10.5 工程项目中库文件的组织原则. . . . . . . . . . . . . . . . . . . . . . . . 418\n10.5.1 动态库是有害的. . . . . . . . . . . . . . . . . . . . . . . . . . . . 423\n10.5.2 静态库也好不到哪儿去. . . . . . . . . . . . . . . . . . . . . . . . 424\n10.5.3 源码编译是王道. . . . . . . . . . . . . . . . . . . . . . . . . . . . 428\n第11章 反思C++ 面向对象与虚函数429\n11.1 朴实的C++ 设计. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 429\n11.2 程序库的二进制兼容性. . . . . . . . . . . . . . . . . . . . . . . . . . . . 431\n11.2.1 什么是二进制兼容性. . . . . . . . . . . . . . . . . . . . . . . . . 432\n11.2.2 有哪些情况会破坏库的ABI . . . . . . . . . . . . . . . . . . . . . 433\n11.2.3 哪些做法多半是安全的. . . . . . . . . . . . . . . . . . . . . . . . 435\n11.2.4 反面教材：COM . . . . . . . . . . . . . . . . . . . . . . . . . . . 435\n11.2.5 解决办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 436\n11.3 避免使用虚函数作为库的接口. . . . . . . . . . . . . . . . . . . . . . . . 436\n11.3.1 C++ 程序库的作者的生存环境. . . . . . . . . . . . . . . . . . . . 437\n11.3.2 虚函数作为库的接口的两大用途. . . . . . . . . . . . . . . . . . 438\n11.3.3 虚函数作为接口的弊端. . . . . . . . . . . . . . . . . . . . . . . . 439\n11.3.4 假如Linux 系统调用以COM 接口方式实现. . . . . . . . . . . . 442\n11.3.5 Java 是如何应对的. . . . . . . . . . . . . . . . . . . . . . . . . . 443\n11.4 动态库接口的推荐做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . 443\n11.5 以boost::function 和boost::bind 取代虚函数. . . . . . . . . . . . . 447\n11.5.1 基本用途. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 450\n11.5.2 对程序库的影响. . . . . . . . . . . . . . . . . . . . . . . . . . . . 451\n11.5.3 对面向对象程序设计的影响. . . . . . . . . . . . . . . . . . . . . 453\n11.6 iostream 的用途与局限. . . . . . . . . . . . . . . . . . . . . . . . . . . . 457\n11.6.1 stdio 格式化输入输出的缺点. . . . . . . . . . . . . . . . . . . . . 457\n11.6.2 iostream 的设计初衷. . . . . . . . . . . . . . . . . . . . . . . . . 461\n11.6.3 iostream 与标准库其他组件的交互. . . . . . . . . . . . . . . . . 463\n11.6.4 iostream 在使用方面的缺点. . . . . . . . . . . . . . . . . . . . . 464\n11.6.5 iostream 在设计方面的缺点. . . . . . . . . . . . . . . . . . . . . 468\n11.6.6 一个300 行的memory buffer output stream . . . . . . . . . . . 476\n11.6.7 现实的C++ 程序如何做文件IO . . . . . . . . . . . . . . . . . . . 480\n11.7 值语义与数据抽象. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482\n11.7.1 什么是值语义. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482\n11.7.2 值语义与生命期. . . . . . . . . . . . . . . . . . . . . . . . . . . . 483\n11.7.3 值语义与标准库. . . . . . . . . . . . . . . . . . . . . . . . . . . . 488\n11.7.4 值语义与C++ 语言. . . . . . . . . . . . . . . . . . . . . . . . . . 488\n11.7.5 什么是数据抽象. . . . . . . . . . . . . . . . . . . . . . . . . . . . 490\n11.7.6 数据抽象所需的语言设施. . . . . . . . . . . . . . . . . . . . . . 493\n11.7.7 数据抽象的例子. . . . . . . . . . . . . . . . . . . . . . . . . . . . 495\n第12章 C++ 经验谈501\n12.1 用异或来交换变量是错误的. . . . . . . . . . . . . . . . . . . . . . . . . 501\n12.1.1 编译器会分别生成什么代码. . . . . . . . . . . . . . . . . . . . . 503\n12.1.2 为什么短的代码不一定快. . . . . . . . . . . . . . . . . . . . . . 505\n12.2 不要重载全局::operator new() . . . . . . . . . . . . . . . . . . . . . . 507\n12.2.1 内存管理的基本要求. . . . . . . . . . . . . . . . . . . . . . . . . 507\n12.2.2 重载::operator new() 的理由. . . . . . . . . . . . . . . . . . . 508\n12.2.3 ::operator new() 的两种重载方式. . . . . . . . . . . . . . . . . 508\n12.2.4 现实的开发环境. . . . . . . . . . . . . . . . . . . . . . . . . . . . 509\n12.2.5 重载::operator new() 的困境. . . . . . . . . . . . . . . . . . . 510\n12.2.6 解决办法：替换malloc() . . . . . . . . . . . . . . . . . . . . . . 512\n12.2.7 为单独的class 重载::operator new() 有问题吗. . . . . . . . . 513\n12.2.8 有必要自行定制内存分配器吗. . . . . . . . . . . . . . . . . . . . 513\n12.3 带符号整数的除法与余数. . . . . . . . . . . . . . . . . . . . . . . . . . . 514\n12.3.1 语言标准怎么说. . . . . . . . . . . . . . . . . . . . . . . . . . . . 515\n12.3.2 C\/C++ 编译器的表现. . . . . . . . . . . . . . . . . . . . . . . . . 516\n12.3.3 其他语言的规定. . . . . . . . . . . . . . . . . . . . . . . . . . . . 516\n12.3.4 脚本语言解释器代码. . . . . . . . . . . . . . . . . . . . . . . . . 517\n12.3.5 硬件实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521\n12.4 在单元测试中mock 系统调用. . . . . . . . . . . . . . . . . . . . . . . . 522\n12.4.1 系统函数的依赖注入. . . . . . . . . . . . . . . . . . . . . . . . . 522\n12.4.2 链接期垫片（link seam） . . . . . . . . . . . . . . . . . . . . . . 524\n12.5 慎用匿名namespace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 526\n12.5.1 C 语言的static 关键字的两种用法. . . . . . . . . . . . . . . . . 526\n12.5.2 C++ 语言的static 关键字的四种用法. . . . . . . . . . . . . . . . 526\n12.5.3 匿名namespace 的不利之处. . . . . . . . . . . . . . . . . . . . . 527\n12.5.4 替代办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 529\n12.6 采用有利于版本管理的代码格式. . . . . . . . . . . . . . . . . . . . . . . 529\n12.6.1 对diff 友好的代码格式. . . . . . . . . . . . . . . . . . . . . . . . 530\n12.6.2 对grep 友好的代码风格. . . . . . . . . . . . . . . . . . . . . . . 537\n12.6.3 一切为了效率. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 538\n12.7 再探std::string . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539\n12.7.1 直接拷贝（eager copy） . . . . . . . . . . . . . . . . . . . . . . . 540\n12.7.2 写时复制（copy-on-write） . . . . . . . . . . . . . . . . . . . . . 542\n12.7.3 短字符串优化（SSO） . . . . . . . . . . . . . . . . . . . . . . . . 543\n12.8 用STL algorithm 轻松解决几道算法面试题. . . . . . . . . . . . . . . . 546\n12.8.1 用next_permutation() 生成排列与组合. . . . . . . . . . . . . . 546\n12.8.2 用unique() 去除连续重复空白. . . . . . . . . . . . . . . . . . . 548\n12.8.3 用{make,push,pop}_heap() 实现多路归并. . . . . . . . . . . . 549\n12.8.4 用partition() 实现“重排数组，让奇数位于偶数前面” . . . . 553\n12.8.5 用lower_bound() 查找IP 地址所属的城市. . . . . . . . . . . . . 554\n第4 部分附录559\n附录A 谈一谈网络编程学习经验561\n附录B 从《C++ Primer（第4 版）》入手学习C++ 579\n附录C 关于Boost 的看法591\n附录D 关于TCP 并发连接的几个思考题与试验593\n参考文献599","pages":"610","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s24522799.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s24522799.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s24522799.jpg"},"alt":"https:\/\/book.douban.com\/subject\/20471211\/","id":"20471211","publisher":"电子工业出版社","isbn10":"7121192829","isbn13":"9787121192821","title":"Linux多线程服务端编程","url":"https:\/\/api.douban.com\/v2\/book\/20471211","alt_title":"","author_intro":"陈硕，北京师范大学硕士，擅长C++ 多线程网络编程和实时分布式系统架构。曾在摩根士丹利IT 部门工作5 年，从事实时外汇交易系统开发。现在在美国加州硅谷某互联网大公司工作，从事大规模分布式系统的可靠性工程。编写了开源C++ 网络库muduo，参与翻译了《代码大全（ 第2 版）》和《C++ 编程规范（繁体版）》，整理了《C++ Primer （第4 版）（评注版）》，并曾多次在各地技术大会演讲。","summary":"本书主要讲述采用现代C++ 在x86-64 Linux 上编写多线程TCP 网络服务程序的主流常规技术，重点讲解一种适应性较强的多线程服务器的编程模型，即one loop per thread。这是在Linux 下以native 语言编写用户态高性能网络程序最成熟的模式，掌握之后可顺利地开发各类常见的服务端网络应用程序。本书以muduo 网络库为例，讲解这种编程模型的使用方法及注意事项。\n本书的宗旨是贵精不贵多。掌握两种基本的同步原语就可以满足各种多线程同步的功能需求，还能写出更易用的同步设施。掌握一种进程间通信方式和一种多线程网络编程模型就足以应对日常开发任务，编写运行于公司内网环境的分布式服务统。","price":"89.00元"}]}
7	{"count":20,"start":0,"total":1198604,"books":[{"rating":{"max":10,"numRaters":1850,"average":"8.9","min":0},"subtitle":"C语言描述","author":["维斯"],"pubdate":"2004-1-1","tags":[{"count":2183,"name":"数据结构","title":"数据结构"},{"count":1727,"name":"算法","title":"算法"},{"count":976,"name":"计算机","title":"计算机"},{"count":900,"name":"数据结构与算法分析","title":"数据结构与算法分析"},{"count":731,"name":"编程","title":"编程"},{"count":706,"name":"算法、数据结构","title":"算法、数据结构"},{"count":647,"name":"C","title":"C"},{"count":552,"name":"C语言","title":"C语言"}],"origin_title":"Data Structures and Algorithm Analysis in C:Second Edition","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s28015501.jpg","binding":"平装","translator":["冯舜玺"],"catalog":"第1章 引论\n1．1 本书讨论的内容\n1．2 数学知识复习\n1．2．1 指数\n1．2．2 对数\n1．2．3 级数\n1．2．4 模运算\n1. 2．5 证明方法\n1．3 递归简论\n总结\n练习\n参考文献\n第2章 算法分析\n2．1 数学基础\n2．2 模型\n2．3 要分析的问题\n2．4 运行时间计算\n2．4．1 一个简单的例子\n2．4．2 一般法则\n2．4．3 最大子序列和问题的解\n.2．4．4 运行时间中的对数\n2．4．5 检验你的分析\n2．4．6 分析结果的准确性\n总结\n练习\n参考文献\n第3章 表、栈和队列\n3．1 抽象数据类型(adt)\n3．2 表adt\n3．2．1 表的简单数组实现\n3．2．2 链表\n3．2．3 程序设计细节\n3．2．4 常见的错误\n3．2．5 双链表\n3．2．6 循环链表\n3．2．7 例子\n3．2．8 链表的游标实现\n3．3 栈adt\n3．3．1 栈模型\n3．3．2 栈的实现\n3．3．3 应用\n3．4 队列adt\n3．4．1 队列模型\n3．4．2 队列的数组实现\n3．4．3 队列的应用\n总结\n练习\n第4章 树\n4．1 预备知识\n4．1．1 树的实现\n4．1．2 树的遍历及应用\n4．2 二叉树\n4．2．1 实现\n4．2．2 表达式树\n4．3 查找树adt--二叉查找树\n4．3．1 makeempty\n4．3．2 find\n4．3．3 findmin和findmax\n4．3．4 insert\n4．3．5 delere\n4．3．6 平均情形分析\n4．4 avl树\n4．4．1 单旋转\n4．4．2 双旋转\n4．5 伸展树\n4．5．1 一个简单的想法\n4．5．2 展开\n4．6 树的遍历\n4．7 b-树\n总结\n练习\n参考文献\n第5章 散列\n5．1 一般想法\n5．2 散列函数\n5．3 分离链接法\n5．4 开放定址法\n5．4．1 线性探测法\n5．4．2 平方探测法\n5．4．3 双散列\n5．5 再散列\n5．6 可扩散列\n总结\n练习\n参考文献\n第6章 优先队列(堆)\n6．1 模型\n6．2 一些简单的实现\n6．3 二叉堆\n6．3．1 结构性质\n6．3．2 堆序性质\n6．3．3 基本的堆操作\n6．3．4 其他的堆操作\n6．4 优先队列的应用\n6．4．1 选择问题\n6．4．2 事件模拟\n6．5 d-堆\n6．6 左式堆\n6．6．1 左式堆的性质\n6．6．2 左式堆的操作\n6．7 斜堆\n6．8 二项队列\n6．8．1 二项队列结构\n6．8．2 二项队列操作\n6．8．3 二项队列的实现\n总结\n练习\n参考文献\n第7章 排序\n7．1 预备知识\n7．2 插入排序\n7．2．1 算法\n7．2．2 插入排序的分析\n7．3 一些简单排序算法的下界\n7. 4 希尔排序\n7．4．1 希尔排序的最坏情形分析\n7．5 堆排序\n7．5．1 堆排序的分析\n7．6 归并排序\n7．6．1 归并排序的分析\n7．7 快速排序\n7．7．1 选取枢纽元\n7．7．2 分割策略\n7．7．3 小数组\n7．7．4 实际的快速排序例程\n7．7．5 快速排序的分析\n7．7．6 选择的线性期望时间算法\n7．8 大型结构的排序\n7．9 排序的一般下界\n7．9．1 决策树\n7．10 桶式排序\n7．11 外部排序\n7．11．1 为什么需要新的算法\n7．11．2 外部排序模型\n7．11．3 简单算法\n7．11．4 多路合并\n7．11．5 多相合并\n7．11．6 替换选择\n总结\n练习\n参考文献\n第8章 不相交集adt\n8．1 等价关系\n8．2 动态等价性问题\n8．3 基本数据结构\n8．4 灵巧求并算法\n8．5 路径压缩\n8．6 按秩求并和路径压缩的最坏情形\n8．6．1 union／find算法分析\n8．7 一个应用\n总结\n练习\n参考文献\n第9章 图论算法\n9．1 若干定义\n9．1．1 图的表示\n9．2 拓扑排序\n9．3 最短路径算法\n9．3．1 无权最短路径\n9．3．2 dijkstra算法\n9．3．3 具有负边值的图\n9．3．4 无圈图\n9．3．5 所有点对最短路径\n9．4 网络流问题\n9．4．1 一个简单的最大流算法\n9．5 最小生成树\n9．5．1 prim算法\n9．5．2 kruskal算法\n9．6 深度优先搜索的应用\n9．6．1 无向图\n9．6．2 双连通性\n9．6．3 欧拉回路\n9．6．4 有向图\n9．6．5 查找强分支\n9．7 np-完全性介绍\n9．7．1 难与易\n9．7．2 np类\n9．7．3 np-完全问题\n总结\n练习\n参考文献\n第10章 算法设计技巧\n10．1 贪婪算法\n10．1．1 一个简单的调度问题\n10．1．2 huffman编码\n10．1．3 近似装箱问题\n10．2 分治算法\n10．2．1 分治算法的运行时间\n10．2．2 最近点问题\n10．2．3 选择问题\n10．2．4 一些运算问题的理论改进\n10．3 动态规划\n10．3．1 用一个表代替递归\n10．3．2 矩阵乘法的顺序安排\n10．3．3 最优二叉查找树\n10．3．4 所有点对最短路径\n10．4 随机化算法\n10．4．1 随机数发生器\n10．4．2 跳跃表\n10．4．3 素性测试\n10．5 回溯算法\n10．5．1 收费公路重建问题\n10．5．2 博弈\n总结\n练习\n参考文献\n第11章 摊还分析\n11．1 一个无关的智力问题\n11．2 二项队列\n11．3 斜堆\n11．4 斐波那契堆\n11．4．1 切除左式堆中的节点\n11．4．2 二项队列的懒惰合并\n11．4．3 斐波那契堆操作\n11．4．4 时间界的证明\n11. 5 伸展树\n总结\n练习\n参考文献\n第12章 高级数据结构及其实现\n12．1 自顶向下伸展树\n12．2 红黑树\n12．2．1 自底向上插入\n12．2．2 自顶向下红黑树\n12．2．3 自顶向下删除\n12．3 确定性跳跃表\n12．4 aa-树\n12．5 treap树\n12．6 k-d树\n12．7 配对堆\n总结\n练习\n参考文献\n索引","pages":"391","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s28015501.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s28015501.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s28015501.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1139426\/","id":"1139426","publisher":"机械工业出版社","isbn10":"711112748X","isbn13":"9787111127482","title":"数据结构与算法分析","url":"https:\/\/api.douban.com\/v2\/book\/1139426","alt_title":"Data Structures and Algorithm Analysis in C:Second Edition","author_intro":"Mark Allen Weiss，1987年在普林斯顿大学获得计算机科学博士学位，师从Robert Sedgewick (师从Knuth)，现任美国佛罗里达国际大学计算与信息科学学院教授。他曾经担任全美AP(Advanced Placement)考试计算机学科委员会的主席(2000-2004)。他的主要研究方向是数据结构、算法和教育学。","summary":"本书是《Data Structures and Algorithm Analysis in C》一书第2版的简体中译本。原书曾被评为20世纪顶尖的30部计算机著作之一，作者Mark Allen Weiss在数据结构和算法分析方面卓有建树，他的数据结构和算法分析的著作尤其畅销，并受到广泛好评．已被世界500余所大学用作教材。\n在本书中，作者更加精炼并强化了他对算法和数据结构方面创新的处理方法。通过C程序的实现，着重阐述了抽象数据类型的概念，并对算法的效率、性能和运行时间进行了分析。\n全书特点如下：\n●专用一章来讨论算法设计技巧，包括贪婪算法、分治算法、动态规划、随机化算法以及回溯算法\n●介绍了当前流行的论题和新的数据结构，如斐波那契堆、斜堆、二项队列、跳跃表和伸展树\n●安排一章专门讨论摊还分析，考查书中介绍的一些高级数据结构\n●新开辟一章讨论高级数据结构以及它们的实现，其中包括红黑树、自顶向下伸展树。treap树、k-d树、配对堆以及其他相关内容\n●合并了堆排序平均情况分析的一些新结果\n本书是国外数据结构与算法分析方面的标准教材，介绍了数据结构(大量数据的组织方法)以及算法分析(算法运行时间的估算)。本书的编写目标是同时讲授好的程序设计和算法分析技巧，使读者可以开发出具有最高效率的程序。 本书可作为高级数据结构课程或研究生一年级算法分析课程的教材，使用本书需具有一些中级程序设计知识，还需要离散数学的一些背景知识。","series":{"id":"1163","title":"计算机科学丛书"},"price":"35.00元"},{"rating":{"max":10,"numRaters":1332,"average":"8.9","min":0},"subtitle":"C语言调试指南","author":["凯尼格"],"pubdate":"2008-2-1","tags":[{"count":708,"name":"C语言","title":"C语言"},{"count":437,"name":"编程","title":"编程"},{"count":318,"name":"C","title":"C"},{"count":278,"name":"计算机","title":"计算机"},{"count":248,"name":"c","title":"c"},{"count":210,"name":"C\/C++","title":"C\/C++"},{"count":194,"name":"经典","title":"经典"},{"count":179,"name":"程序设计","title":"程序设计"}],"origin_title":"C Traps and Pitfalls","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s2870233.jpg","binding":"平装","translator":["高巍"],"catalog":"第0章　导读\n第1章　词法“陷阱”\n1.1　=不同于==\n1.2　& 和 | 不同于&& 和 ||\n1.3　词法分析中的“贪心法”\n1.4　整型常量\n1.5　字符与字符串\n第2章　语法“陷阱”\n2.1　理解函数声明\n2.2　运算符的优先级问题\n2.3　注意作为语句结束标志的分号\n2.4　switch语句\n2.5　函数调用\n2.6　“悬挂”else引发的问题\n第3章　语义“陷阱”\n3.1　指针与数组\n3.2　非数组的指针\n3.3　作为参数的数组声明\n3.4　避免“举隅法”\n3.5　空指针并非空字符串\n3.6　边界计算与不对称边界\n3.7　求值顺序\n3.8　运算符&&、|| 和 !\n3.9　整数溢出\n3.10　为函数main提供返回值\n第4章　连接\n4.1　什么是连接器\n4.2　声明与定义\n4.3　命名冲突与static修饰符\n4.4　形参、实参与返回值\n4.5　检查外部类型\n4.6　头文件\n第5章　库函数\n5.1　返回整数的getchar函数\n5.2　更新顺序文件\n5.3　缓冲输出与内存分配\n5.4　使用errno检测错误\n5.5　库函数signal\n第6章　预处理器\n6.1　不能忽视宏定义中的空格\n6.2　宏并不是函数\n6.3　宏并不是语句\n6.4　宏并不是类型定义\n第7章　可移植性缺陷\n7.1　应对C语言标准变更\n7.2　标识符名称的限制\n7.3　整数的大小\n7.4　字符是有符号整数还是无符号整数\n7.5　移位运算符\n7.6　内存位置0\n7.7　除法运算时发生的截断\n7.8　随机数的大小\n7.9　大小写转换\n7.10　首先释放，然后重新分配\n7.11　可移植性问题的一个例子\n第8章　建议与答案\n8.1　建议\n8.2　答案\n附录A　PRINTF，VARARGS与STDARG\n附录B　Koenig和Moo夫妇访谈","pages":"172","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s2870233.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s2870233.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s2870233.jpg"},"alt":"https:\/\/book.douban.com\/subject\/2778632\/","id":"2778632","publisher":"人民邮电出版社","isbn10":"7115171793","isbn13":"9787115171795","title":"C陷阱与缺陷","url":"https:\/\/api.douban.com\/v2\/book\/2778632","alt_title":"C Traps and Pitfalls","author_intro":"Andrew Koenig 是AT&T公司Shannon实验室大规模编程研究部门中的成员，同时也是C++标准委员会的项目编辑。他的编程经验超过30年，其中有15年在使用C++，他已经出版了超过150 篇和C++有关的论文，并且在世界范围内就这个主题进行过多次演讲。","summary":"作者以自己1985年在Bell实验室时发表的一篇论文为基础，结合自己的工作经验扩展成为这本对C程序员具有珍贵价值的经典著作。写作本书的出发点不是要批判C语言，而是要帮助C程序员绕过编程过程中的陷阱和障碍。..\n全书分为8章，分别从词法分析、语法语义、连接、库函数、预处理器、可移植性缺陷等几个方面分析了C编程中可能遇到的问题。最后，作者用一章的篇幅给出了若干具有实用价值的建议。..\n本书适合有一定经验的C程序员阅读学习，即便你是C编程高手，本书也应该成为你的案头必备书籍。","series":{"id":"9931","title":"C和C++经典著作"},"price":"30.00元"},{"rating":{"max":10,"numRaters":4408,"average":"9.4","min":0},"subtitle":"第 2 版·新版","author":["（美）Brian W. Kernighan","（美）Dennis M. Ritchie"],"pubdate":"2004-1","tags":[{"count":3001,"name":"C","title":"C"},{"count":2408,"name":"c语言","title":"c语言"},{"count":2131,"name":"编程","title":"编程"},{"count":1549,"name":"计算机","title":"计算机"},{"count":1291,"name":"程序设计","title":"程序设计"},{"count":1080,"name":"经典","title":"经典"},{"count":987,"name":"编程语言","title":"编程语言"},{"count":869,"name":"C\/C++","title":"C\/C++"}],"origin_title":"The C Programming Language","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1106934.jpg","binding":"平装","translator":["徐宝文","李志译","尤晋元审校"],"catalog":"出版者的话\n专家指导委员会\n中文版序\n译者序\n校译者简介\n序\n第1版序\n引言\n第1章 导言\n1.1 入门\n1.2 变量与算术表态式\n1.3 for语句\n1.4 符号常量\n1.5 字符输入\/输出\n1.6 数组\n1.7 函数\n1.8 参数——传值调用\n1.9 字符数组\n1.10 外部变量与作用域\n第2章 类型、运算符与表达式\n2.1 变量名\n2.2 数据类型及长度\n2.3 常量\n2.4 声明\n2.5 算术运算符\n2.6 关系运算符与逻辑运算符\n2.7 类型转换\n2.8 自增运算符与自减运算符\n2.9 按位运算符\n2.10 赋值运算符与表达式\n2.11 条件表达式\n2.12 运算符优先级与求值次序\n第3章 控制流\n3.1 语句与程序块\n3.2 if-else语句\n3.3 else-if语句\n3.4 switch语句\n3.5 whil循环与for特环\n3.6 do-while循环\n3.7 break语句与continue语句\n3.8 goto语句与标号\n第4章 涵数与程序结构\n第5章 指针与数组\n第6章 结构\n第7章 输入与输出\n第8章 UNIX系统接口\n附录A 参考手册\n附录B 标准库\n附录C 变更小结\n索引","pages":"258","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s1106934.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s1106934.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1106934.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1139336\/","id":"1139336","publisher":"机械工业出版社","isbn10":"7111128060","isbn13":"9787111128069","title":"C程序设计语言","url":"https:\/\/api.douban.com\/v2\/book\/1139336","alt_title":"The C Programming Language","author_intro":"Brian W. Kernighan： 贝尔实验室计算科学研究中心高级研究人员，著名的计算机科学家。他参加了UNIX系统、C语言、AWK语言和许多其他系统的开发，同时出版了许多在计算机领域具有影响的著作，如《The Elements of Programming Style》、《The Practice of Programming》、《The UNIX Programming Environment》、《The AWK Language》、《Software Tools》等。\nDennis M. Ritchie：1967年加入贝尔实验室。他和Ken L. Thompson两人共同设计并实现的C语言改变了程序设计语言发展的轨迹，是程序设计语言发展过程中的一个重要里程碑。与此同时，他们两人还设计并实现了UNIX操作系统。正是由于这两项巨大贡献，Dennis M. Ritchie于1983年获得了计算机界的最高奖——图灵奖。此外，他还获得了ACM、IEEE、贝尔实验室等授予的多种奖项.。","summary":"在计算机发展的历史上，没有哪一种程序设计语言像C语言这样应用广泛。本书原著即为C语言的设计者之一Dennis M.Ritchie和著名计算机科学家Brian W.Kernighan合著的一本介绍C语言的权威经典著作。我们现在见到的大量论述C语言程序设计的教材和专著均以此书为蓝本。原著第1版中介绍的C语言成为后来广泛使用的C语言版本——标准C的基础。人们熟知的“hello,World\"程序就是由本书首次引入的，现在，这一程序已经成为众多程序设计语言入门的第一课。\n原著第2版根据1987年制定的ANSIC标准做了适当的修订．引入了最新的语言形式，并增加了新的示例，通过简洁的描述、典型的示例，作者全面、系统、准确地讲述了C语言的各个特性以及程序设计的基本方法。对于计算机从业人员来说，《C程序设计语言》是一本必读的程序设计语 言方面的参考书。","series":{"id":"1163","title":"计算机科学丛书"},"price":"30.00元"},{"rating":{"max":10,"numRaters":132,"average":"8.5","min":0},"subtitle":"C语言描述","author":["(美)安佩尔"],"pubdate":"2006-4","tags":[{"count":306,"name":"编译原理","title":"编译原理"},{"count":115,"name":"虎书","title":"虎书"},{"count":95,"name":"C","title":"C"},{"count":83,"name":"计算机","title":"计算机"},{"count":81,"name":"计算机科学","title":"计算机科学"},{"count":60,"name":"compiler","title":"compiler"},{"count":59,"name":"编译理论","title":"编译理论"},{"count":59,"name":"编译器","title":"编译器"}],"origin_title":"Modern Compiler Implementation in C","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1852496.jpg","binding":"简裝本","translator":["赵克佳","黄春","沈志宇"],"catalog":"第一部分 编译基本原理\n第1章 绪论\n1.1 模块与接口\n1.2 工具和软件\n1.3 树语言的数据结构\n程序设计：直线式程序解释器\n推荐阅读\n习题\n第2章 词法分析\n2.1 词法单词\n2.2 正则表达式\n2.3 有限自动机\n2.4 非确定有限自动机\n2.4.1 将正则表达式转换为NFA\n2.4.2 将NFA转换为DFA\n2.5 Lex：词法分析器的生成器\n程序设计：词法分析\n推荐阅读\n习题\n第3章 语法分析\n3.1 上下文无关文法\n3.1.1 推导\n3.1.2 语法分析树\n3.1.3 二义性文法\n3.1.4 文件结束符\n3.2 预测分析\n3.2.1 FIRST集合和FOLLOW集合\n3.2.2 构造一个预测分析器\n3.2.3 消除左递归\n3.2.4 提取左因子\n3.2.5 错误恢复\n3.3 LR分析\n3.3.1 LR分析引擎\n3.3.2 LR(0)分析器生成器\n3.3.3 SLR分析器的生成\n3.3.4 LR(1)项和LR(1)分析表\n3.3.5 LALR(1)分析表\n3.3.6 各类文法的层次\n3.3.7 二义性文法的LR分析\n3.4 使用分析器的生成器\n3.4.1 冲突\n3.4.2 优先级指导\n3.4.3 语法和语义\n3.5 错误恢复\n3.5.1 用error符号恢复\n3.5.2 全局错误修复\n程序设计：语法分析\n推荐阅读\n习题\n第4章 抽象语法\n4.1 语义动作\n4.1.1 递归下降\n4.1.2 Yacc生成的分析器\n4.1.3 语义动作的解释器\n4.2 抽象语法分析树\n4.2.1 位置\n4.2.2 Tiger的抽象语法\n程序设计：抽象语法\n推荐阅读\n习题\n第5章 语义分析\n5.1 符号表\n5.1.1 多个符号表\n5.1.2 高效的命令式风格符号表\n5.1.3 高效的函数式符号表\n5.1.4 Tiger编译器的符号\n5.1.5 函数式风格的符号表\n5.2 Tiger编译器的绑定\n5.3 表达式的类型检查\n5.4 声明的类型检查\n5.4.1 变量声明\n5.4.2 类型声明\n5.4.3 函数声明\n5.4.4 递归声明\n程序设计：类型检查\n习题\n第6章 活动记录\n6.1 栈帧\n6.1.1 帧指针\n6.1.2 寄存器\n6.1.3 参数传递\n6.1.4 返回地址\n6.1.5 栈帧内的变量\n6.1.6 静态链\n6.2 Tiger编译器的栈帧\n6.2.1 栈帧描述的表示\n6.2.2 局部变量\n6.2.3 计算逃逸变量\n6.2.4 临时变量和标号\n6.2.5 两层抽象\n6.2.6 管理静态链\n6.2.7 追踪层次信息\n程序设计：栈帧\n推荐阅读\n习题\n第7章 翻译成中间代码\n7.1 中间表示树\n7.2 翻译为树中间语言\n7.2.1 表达式的种类\n7.2.2 简单变量\n7.2.3 追随静态链\n7.2.4 数组变量\n7.2.5 结构化的左值\n7.2.6 下标和域选择\n7.2.7 关于安全性的劝告\n7.2.8 算术操作\n7.2.9 条件表达式\n7.2.10 字符串\n7.2.11 记录和数组的创建\n7.2.12 while循环\n7.2.13 for循环\n7.2.14 函数调用\n7.3 声明\n7.3.1 变量定义\n7.3.2 函数定义\n7.3.3 片段\n程序设计：翻译成树\n习题\n第8章 基本块和轨迹\n8.1 规范树\n8.1.1 ESEQ的转换\n8.1.2 一般重写规则\n8.1.3 将CALL移到顶层\n8.1.4 线性语句表\n8.2 处理条件分支\n8.2.1 基本块\n8.2.2 轨迹\n8.2.3 完善\n8.2.4 最优轨迹\n推荐阅读\n习题\n第9章 指令选择\n9.1 指令选择算法\n9.1.1 Maximal Munch算法\n9.1.2 动态规划\n9.1.3 树文法\n9.1.4 快速匹配\n9.1.5 覆盖算法的效率\n9.2 CISC机器\n9.3 Tiger编译器的指令选择\n9.3.1 抽象的汇编语言指令\n9.3.2 生成汇编指令\n9.3.3 过程调用\n9.3.4 无帧指针的情形\n程序设计：指令选择\n推荐阅读\n习题\n第10章 活跃分析\n10.1 数据流方程的解\n10.1.1 活跃性计算\n10.1.2 集合的表示\n10.1.3 时间复杂度\n10.1.4 最小不动点\n10.1.5 静态活跃性与动态活跃性\n10.1.6 冲突图\n10.2 Tiger编译器的活跃分析\n10.2.1 图\n10.2.2 控制流图\n10.2.3 活跃分析\n程序设计：构造流图\n程序设计：活跃分析模块\n习题\n第11章 寄存器分配\n11.1 通过简化进行着色\n11.2 合并\n11.3 预着色的结点\n11.3.1 机器寄存器的临时副本\n11.3.2 调用者保护的寄存器和被调用者保护的寄存器\n11.3.3 含预着色结点的例子\n11.4 图着色的实现\n11.4.1 传送指令工作表的管理\n11.4.2 数据结构\n11.4.3 程序代码\n11.5 针对树的寄存器分配\n程序设计：图着色\n推荐阅读\n习题\n第12章 整合为一体\n程序设计：过程入口\/出口\n程序设计：创建一个可运行的编译器\n第二部分 高级主题\n第13章 垃圾收集\n13.1 标记-清扫式收集\n13.2 引用计数\n13.3 复制式收集\n13.4 分代收集\n13.5 增量式收集\n13.6 Baker算法\n13.7 编译器接口\n13.7.1 快速分配\n13.7.2 数据布局的描述\n13.7.3 导出指针\n程序设计：描述字\n程序设计：垃圾收集\n推荐阅读\n习题\n第14章 面向对象的语言\n14.1 类\n14.2 数据域的单继承性\n14.3 多继承性\n14.4 测试类成员关系\n14.5 私有域和私有方法\n14.6 无类语言\n14.7 向对象程序的优化\n程序设计：OBJECT Tiger\n推荐阅读\n习题\n第15章 函数式程序设计语言\n15.1 一个简单的函数式语言\n15.2 闭包\n15.3 不变的变量\n15.3.1 基于延续的……I\/O226\n15.3.2 语言上的变化\n15.3.3 纯函数式语言的优化\n15.4 内联扩展\n15.5 闭包变换\n15.6 高效的尾递归\n15.7 懒惰计算\n15.7.1 传名调用计算\n15.7.2 按需调用\n15.7.3 懒惰程序的计算\n15.7.4 懒惰函数式程序的优化\n15.7.5 严格性分析\n推荐阅读\n程序设计：编译函数式语言\n习题\n第16章 多态类型\n16.1 参数多态性\n16.1.1 显式带类型的多态语言\n16.1.2 多态类型的检查\n16.2 类型推论\n16.2.1 一个隐式类型的多态语言\n16.2.2 类型推论算法\n16.2.3 递归的数据类型\n16.2.4 Hindley Milner类型的能力\n16.3 多态变量的表示\n16.3.1 多态函数的扩展\n16.3.2 完全的装箱转换\n16.3.3 基于强制的表示分析\n16.3.4 将类型作为运行时参数传递\n16.4 静态重载的解决方法\n推荐阅读\n习题\n第17章 数据流分析\n17.1 流分析使用的中间表示\n17.2 各种数据流分析\n17.2.1 到达定值\n17.2.2 可用表达式\n17.2.3 到达表达式\n17.2.4 活跃分析\n17.3 使用数据流分析结果的几种转换\n17.3.1 公共子表达式删除\n17.3.2 常数传播\n17.3.3 复写传播\n17.3.4 死代码删除\n17.4 加快数据流分析\n17.4.1 位向量\n17.4.2 基本块\n17.4.3 结点排序\n17.4.4 使用-定值链和定值-使用链\n17.4.5 工作表算法\n17.4.6 增量式数据流分析\n17.5 别名分析\n17.5.1 基于类型的别名分析\n17.5.2 基于流的别名分析\n17.5.3 使用可能别名信息\n17.5.4 严格的纯函数式语言中的别名分析\n推荐阅读\n习题\n第18章 循环优化\n18.1 必经结点\n18.1.1 寻找必经结点的算法\n18.1.2 直接必经结点\n18.1.3 循环\n18.1.4 循环前置结点\n18.2 循环不变量计算\n18.3 归纳变量\n18.3.1 发现归纳变量\n18.3.2 强度削弱\n18.3.3 删除\n18.3.4 重写比较\n18.4 数组边界检查\n18.5 循环展开\n推荐阅读\n习题\n第19章 静态单赋值形式\n19.1 转化为SSA形式\n19.1.1 插入Φ函数的标准\n19.1.2 必经结点边界\n19.1.3 插入Φ函数\n19.1.4 变量重命名\n19.1.5 边分割\n19.2 必经结点树的高效计算\n19.2.1 深度优先生成树\n19.2.2 半必经结点\n19.2.3 Lengauer Tarjan算法\n19.3 使用SSA的优化算法\n19.3.1 死代码删除\n19.3.2 简单的常数传播\n19.3.3 条件常数传播\n19.3.4 保持必经结点性质\n19.4 数组、指针和存储器\n19.5 控制依赖图\n19.6 从SSA形式转变回来\n19.7 函数式中间形式\n推荐阅读\n习题\n第20章 流水和调度\n20.1 没有资源约束时的循环调度\n20.2 有资源约束的循环流水\n20.2.1 模调度\n20.2.2 寻找最小的启动间距\n20.2.3 其他控制流\n20.2.4 编译器应该调度指令吗\n20.3 分支预测\n20.3.1 静态分支预测\n20.3.2 编译器应该预测分支吗\n推荐阅读\n习题\n第21章 存储层次\n21.1 cache的组织结构\n21.2 cache块对齐\n21.3 预取\n21.4 循环交换\n21.5 分块\n21.6 垃圾收集和存储层次\n推荐阅读\n习题\n附录 Tiger语言参考手册\n参考文献\n索引","pages":"385","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s1852496.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s1852496.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1852496.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1806974\/","id":"1806974","publisher":"人民邮电出版社","isbn10":"7115145520","isbn13":"9787115145529","title":"现代编译原理","url":"https:\/\/api.douban.com\/v2\/book\/1806974","alt_title":"Modern Compiler Implementation in C","author_intro":"","summary":"《现代编译原理:C语言描述》全面讲述了现代编译器的结构、编译算法和实现方法，是Andrew w．Apple的“虎书”——Modern Compiler Implementation——“红、蓝、绿”三序列之一。这三本书的内容基本相同。但是使用不同的语言来实现书中给出的一个编译器。本书使用的是更适合广大读者的c语言，而另外两本书分别采用ML语言和Java语言。本书的另一个特点是增加了一些其他编译原理教科书没有涉及的内容。前端增加了面向对象的程序设计语言、函数式程序设计语言等现代语言的编译实现方法，后端增加了针对现代计算机体系结构特征的一些比较成熟的优化方法。这部分内容展现了现代商业编译器需解决的一些关键问题，开拓了学生的视野，为学生未来进行更深入的研究奠定了基础。\n\n《现代编译原理:C语言描述》全面讲述了现代编译器的各个组成部分，包括词法分析、语法分析、抽象语法、语义检查、中间代码表示、指令选择、数据流分析、寄存器分配以及运行时系统等。全书分成两部分，第一部分是编译的基础知识，适用于第一门编译原理课程(一个学期)；第二部分是高级主题，包括面向对象语言和函数语言、垃圾收集、循环优化、ssA(静态单赋值)形式、循环调度、存储结构优化等，适合于后续课程或研究生教学。书中专门为学生提供了一个用C语言编写的实习项目，包括前端和后端设计，学生可以在一学期内创建一个功能完整的编译器。","series":{"id":"18507","title":"图灵计算机科学丛书"},"price":"45.00元"},{"rating":{"max":10,"numRaters":137,"average":"9.1","min":0},"subtitle":"编写高质量C语言代码","author":["Steve Maguire"],"pubdate":"2009.2","tags":[{"count":297,"name":"编程","title":"编程"},{"count":250,"name":"C","title":"C"},{"count":153,"name":"C语言","title":"C语言"},{"count":102,"name":"程序设计","title":"程序设计"},{"count":100,"name":"计算机","title":"计算机"},{"count":81,"name":"Programming","title":"Programming"},{"count":71,"name":"C\/C++","title":"C\/C++"},{"count":67,"name":"经典","title":"经典"}],"origin_title":"Writing Solid Code","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s3529626.jpg","binding":"","translator":[],"catalog":"1 a hypothetical compiler\n2 assert yourself\n3 fortify your subsystems\n4 step through your code\n5 candy-machine interfaces\n6 risky business\n7 treacheries of the trade\n8 the rest is attitude\nepilogue where do you go from here?\nappendix a coding checklists\nappendix b memory logging routines\nappendix c answers\nreferences\nindex","pages":"256","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s3529626.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s3529626.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s3529626.jpg"},"alt":"https:\/\/book.douban.com\/subject\/3406939\/","id":"3406939","publisher":"人民邮电出版社","isbn10":"7115193169","isbn13":"9787115193162","title":"编程精粹","url":"https:\/\/api.douban.com\/v2\/book\/3406939","alt_title":"Writing Solid Code","author_intro":"","summary":"编写高质量的、没有bug的程序，是每位程序员所追求的目标。但随着软件规模越来越大，功能日趋复杂，这一目标变得越来越困难。\n本书揭示了微软公司应对质量挑战、开发出世界级代码的技术内幕，作者在自己不断探索、实践和思考的基础上，系统总结了多年来指导微软各团队的经验，将其凝聚为许多切实可行的编程实践指导，可谓字字珠玑。正因如此，本书被公认为与《代码大全》齐名的编程技术名著，曾于1993年荣获有软件开发奥斯卡奖之称的Jolt生产效率大奖。书中内容主要针对C语言，但其中的思想对目前的各主流语言编程也完全适用。","series":{"id":"50484","title":"图灵程序设计丛书·C\/C++系列"},"price":"45.00元"},{"rating":{"max":10,"numRaters":462,"average":"8.1","min":0},"subtitle":"—C++\/C语言","author":["林锐","韩永泉"],"pubdate":"2007-5","tags":[{"count":218,"name":"C++","title":"C++"},{"count":154,"name":"编程","title":"编程"},{"count":126,"name":"C\/C++","title":"C\/C++"},{"count":104,"name":"程序设计","title":"程序设计"},{"count":78,"name":"高质量程序设计指南--C++\/c语言","title":"高质量程序设计指南--C++\/c语言"},{"count":70,"name":"计算机","title":"计算机"},{"count":70,"name":"编程风格","title":"编程风格"},{"count":61,"name":"C","title":"C"}],"origin_title":"","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s2660317.jpg","binding":"","translator":[],"catalog":"第1章  高质量软件开发之道\t11.1  软件质量基本概念\t11.1.1  如何理解软件的质量\t11.1.2  提高软件质量的基本方法\t31.1.3  “零缺陷”理念\t41.2  细说软件质量属性\t41.2.1  正确性\t41.2.2  健壮性\t51.2.3  可靠性\t51.2.4  性能\t61.2.5  易用性\t71.2.6  清晰性\t71.2.7  安全性\t71.2.8  可扩展性\t81.2.9  兼容性\t81.2.10  可移植性\t81.3  人们关注的不仅仅是质量\t91.3.1  质量、生产率和成本之间的关系\t91.3.2  软件过程改进的基本概念\t111.4  高质量软件开发的基本方法\t131.4.1  建立软件过程规范\t131.4.2  复用\t151.4.3  分而治之\t161.4.4  优化与折中\t171.4.5  技术评审\t181.4.6  测试\t191.4.7  质量保证\t211.4.8  改错\t221.5  关于软件开发的一些常识和思考\t241.5.1  有最好的编程语言吗\t241.5.2  编程是一门艺术吗\t241.5.3  编程时应该多使用技巧吗\t241.5.4  换更快的计算机还是换更快的算法\t251.5.5  错误是否应该分等级\t251.5.6  一些错误的观念\t251.6  小结\t26第2章  编程语言发展简史\t272.1  编程语言大事记\t272.2  Ada的故事\t302.3  C\/C++发展简史\t312.4  Borland与Microsoft之争\t322.5  Java阵营与Microsoft的较量\t332.6  小结\t36第3章  程序的基本概念\t373.1  程序设计语言\t373.2  语言实现\t383.3  程序库\t403.4  开发环境\t403.5  程序的工作原理\t413.6  良好的编程习惯\t42第4章  C++\/C程序设计入门\t454.1  C++\/C程序的基本概念\t454.1.1  启动函数main()\t454.1.2  命令行参数\t474.1.3  内部名称\t484.1.4  连接规范\t494.1.5  变量及其初始化\t514.1.6  C Runtime Library\t524.1.7  编译时和运行时的不同\t524.1.8  编译单元和独立编译技术\t544.2  基本数据类型和内存映像\t544.3  类型转换\t564.3.1  隐式转换\t564.3.2  强制转换\t584.4  标识符\t604.5  转义序列\t614.6  运算符\t624.7  表达式\t634.8  基本控制结构\t654.9  选择（判断）结构\t654.9.1  布尔变量与零值比较\t664.9.2  整型变量与零值比较\t674.9.3  浮点变量与零值比较\t674.9.4  指针变量与零值比较\t694.9.5  对if语句的补充说明\t704.9.6  switch结构\t704.10   循环（重复）结构\t714.10.1  for语句的循环控制变量\t724.10.2  循环语句的效率\t734.11  结构化程序设计原理\t784.12  goto\/continue\/break语句\t794.13  示例\t80第5章  C++\/C常量\t855.1  认识常量\t855.1.1  字面常量\t855.1.2  符号常量\t865.1.3  契约性常量\t875.1.4  枚举常量\t875.2  正确定义符号常量\t875.3  const与#define的比较\t885.4  类中的常量\t895.5  实际应用中如何定义常量\t90第6章  C++\/C函数设计基础\t956.1  认识函数\t956.2  函数原型和定义\t966.3  函数调用方式\t976.4  认识函数堆栈\t996.5  函数调用规范\t1006.6  函数连接规范\t1016.7  参数传递规则\t1026.8  返回值的规则\t1046.9  函数内部实现的规则\t1076.10  存储类型及作用域规则\t1096.10.1  存储类型\t1096.10.2  作用域规则\t1106.10.3  连接类型\t1116.11  递归函数\t1136.12  使用断言\t1166.13  使用const提高函数的健壮性\t1186.13.1  用const修饰函数的参数\t1186.13.2  用const修饰函数的返回值\t119第7章  C++\/C指针、数组和字符串\t1217.1  指针\t1217.1.1  指针的本质\t1217.1.2  指针的类型及其支持的运算\t1237.1.3  指针传递\t1257.2  数组\t1267.2.1  数组的本质\t1267.2.2  二维数组\t1287.2.3  数组传递\t1297.2.4  动态创建、初始化和删除数组的方法\t1317.3  字符数组、字符指针和字符串\t1337.3.1  字符数组、字符串和‘\\0’的关系\t1337.3.2  字符指针的误区\t1347.3.3  字符串拷贝和比较\t1347.4  函数指针\t1357.5  引用和指针的比较\t137第8章  C++\/C高级数据类型\t1418.1  结构（Struct）\t1418.1.1  关键字struct与class的困惑\t1418.1.2  使用struct\t1428.1.3  位域\t1458.1.4  成员对齐\t1478.2  联合（Union）\t1598.3  枚举（Enum）\t1618.4  文件\t163第9章  C++\/C编译预处理\t1659.1  文件包含\t1659.1.1  内部包含卫哨和外部包含卫哨\t1659.1.2  头文件包含的合理顺序\t1669.2  宏定义\t1669.3  条件编译\t1699.3.1  #if、#elif和#else\t1699.3.2  #ifdef 和 #ifndef\t1709.4  #error\t1719.5  #pragma\t1719.6  #和##运算符\t1719.7  预定义符号常量\t172第10章  C++\/C文件结构和程序版式\t17510.1  程序文件的目录结构\t17510.2  文件的结构\t17610.2.1  头文件的用途和结构\t17610.2.2  版权和版本信息\t17710.2.3  源文件结构\t17810.3  代码的版式\t17810.3.1  适当的空行\t17810.3.2  代码行及行内空格\t17910.3.3  长行拆分\t18010.3.4  对齐与缩进\t18110.3.5  修饰符的位置\t18210.3.6  注释风格\t18210.3.7  ADT\/UDT版式\t183第11章  C++\/C应用程序命名规则\t18511.1  共性规则\t18511.2  简单的Windows应用程序命名\t186第12章  C++面向对象程序设计方法概述\t18912.1  漫谈面向对象\t18912.2  对象的概念\t19012.3  信息隐藏与类的封装\t19112.4  类的继承特性\t19512.5  类的组合特性\t20012.6  动态特性\t20112.6.1  虚函数\t20212.6.2  抽象基类\t20212.6.3  动态绑定\t20512.6.4  运行时多态\t20712.6.5  多态数组\t20812.7  C++对象模型\t21512.7.1  对象的内存映像\t21512.7.2  隐含成员\t22412.7.3  C++编译器如何处理成员函数\t22512.7.4  C++编译器如何处理静态成员\t22512.8  小结\t226第13章  对象的初始化、拷贝和析构\t22913.1  构造函数与析构函数的起源\t22913.2  为什么需要构造函数和析构函数\t23013.3  构造函数的成员初始化列表\t23213.4  对象的构造和析构次序\t23413.5  构造函数和析构函数的调用时机\t23513.6  构造函数和赋值函数的重载\t23613.7  示例：类String的构造函数和析构函数\t23813.8  何时应该定义拷贝构造函数和拷贝赋值函数\t23913.9  示例：类String的拷贝构造函数和拷贝赋值函数\t24013.10  用偷懒的办法处理拷贝构造函数和拷贝赋值函数\t24213.11  如何实现派生类的基本函数\t243第14章  C++函数的高级特性\t24714.1  函数重载的概念\t24714.1.1  重载的起源\t24714.1.2  重载是如何实现的\t24714.1.3  当心隐式类型转换导致重载函数产生二义性\t24914.2  成员函数的重载、覆盖与隐藏\t25014.2.1  重载与覆盖\t25014.2.2  令人迷惑的隐藏规则\t25114.2.3  摆脱隐藏\t25314.3  参数的默认值\t25414.4  运算符重载\t25514.4.1  基本概念\t25514.4.2  运算符重载的特殊性\t25614.4.3  不能重载的运算符\t25714.4.4  重载++和--\t25714.5  函数内联\t25914.5.1  用函数内联取代宏\t25914.5.2  内联函数的编程风格\t26014.5.3  慎用内联\t26114.6  类型转换函数\t26114.7  const成员函数\t264第15章  C++异常处理和RTTI\t26715.1  为什么要使用异常处理\t26715.2  C++异常处理\t26815.2.1  异常处理的原理\t26815.2.2  异常类型和异常对象\t26915.2.3  异常处理的语法结构\t27015.2.4  异常的类型匹配规则\t27215.2.5  异常说明及其冲突\t27215.2.6  当异常抛出时局部对象如何释放\t27315.2.7  对象构造和析构期间的异常\t27315.2.8  如何使用好异常处理技术\t27515.2.9  C++的标准异常\t27815.3  虚函数面临的难题\t27815.4  RTTI及其构成\t28015.4.1  起源\t28015.4.2  typeid运算符\t28115.4.3  dynamic_cast<>运算符\t28315.4.4  RTTI的魅力与代价\t285第16章  内存管理\t28716.1  内存分配方式\t28716.2  常见的内存错误及其对策\t28816.3  指针参数是如何传递内存的\t28916.4  free和delete把指针怎么啦\t29116.5  动态内存会被自动释放吗\t29216.6  杜绝“野指针”\t29216.7  有了malloc\/free为什么还要new\/delete\t29316.8  malloc\/free的使用要点\t29516.9  new有3种使用方式\t29616.9.1  plain new\/delete\t29616.9.2  nothrow new\/delete\t29716.9.3  placement new\/delete\t29716.10  new\/delete的使用要点\t30016.11  内存耗尽怎么办\t30116.12  用对象模拟指针\t30216.13  泛型指针auto_ptr\t30516.14  带有引用计数的智能指针\t30616.15  智能指针作为容器元素\t310第17章  学习和使用STL\t32317.1  STL简介\t32317.2  STL头文件的分布\t32417.2.1  容器类\t32417.2.2  泛型算法\t32517.2.3  迭代器\t32517.2.4  数学运算库\t32517.2.5  通用工具\t32517.2.6  其他头文件\t32617.3  容器设计原理\t32617.3.1  内存映像\t32617.3.2  存储方式和访问方式\t32717.3.3  顺序容器和关联式容器的比较\t32817.3.4  如何遍历容器\t33117.3.5  存储空间重分配问题\t33217.3.6  什么样的对象才能作为STL容器的元素\t33317.4  迭代器\t33417.4.1  迭代器的本质\t33417.4.2  迭代器失效及其危险性\t33817.5  存储分配器\t34617.6  适配器\t34717.7  泛型算法\t35017.8  一些特殊的容器\t35417.8.1  string类\t35417.8.2  bitset并非set\t35517.8.3  节省存储空间的vector<bool>\t35717.8.4  空容器\t35817.9  STL容器特征总结\t36017.10  STL使用心得\t362附录A  C++\/C试题\t365附录B  C++\/C试题答案与评分标准\t369附录C  大学十年\t375附录D  《大学十年》后记\t393附录E  术语与缩写解释\t395参考文献\t397","pages":"394","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s2660317.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s2660317.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s2660317.jpg"},"alt":"https:\/\/book.douban.com\/subject\/2116929\/","id":"2116929","publisher":"电子工业","isbn10":"7121041146","isbn13":"9787121041143","title":"高质量程序设计指南","url":"https:\/\/api.douban.com\/v2\/book\/2116929","alt_title":"","author_intro":"林锐，国内知名的软件工程专家和研发管理咨询师。西安电子科技大学硕士，浙江大学计算机系博士。2000年7月加入上海贝尔有限公司，从事软件工程和CMM的研究推广工作。2003年7月当选为Alcatel集团技术专家。2004年初创建上海漫索计算机科技有限公司(http：／／www.chinaspis.com)，致力于创建适合国内IT企业需求的研发管理解决方案，包括方法论和软件产品。已出版著作七部。","summary":"《高质量程序设计指南:C++、C语言》(第3版)以轻松幽默的笔调向读者论述了高质量软件开发方法与C++\/C编程规范。它是作者多年从事软件开发工作的经验总结。《高质量程序设计指南:C++、C语言》(第3版)共17章，第1章到第4章重点介绍软件质量和基本的程序设计方法；第5章到第16章重点阐述 C++\/C编程风格、面向对象程序设计方法和一些技术专题；第17章阐述STL 的原理和使用方法。\n　　《高质量程序设计指南:C++、C语言》(第3版)第1版和第2版部分章节曾经在Internet上广泛流传，被国内IT企业的不少软件开发人员采用。《高质量程序设计指南:C++、C语言》(第3版)的附录C《大学十年》是作者在网上发表的一个短篇传记，文中所描述的充满激情的学习和生活态度，感染了大批莘莘学子。","price":"39.80元"},{"rating":{"max":10,"numRaters":78,"average":"9.1","min":0},"subtitle":"C语言描述","author":["韦斯(Mark Allen Weiss)"],"pubdate":"2010-8","tags":[{"count":165,"name":"数据结构","title":"数据结构"},{"count":148,"name":"算法","title":"算法"},{"count":89,"name":"计算机","title":"计算机"},{"count":63,"name":"C","title":"C"},{"count":45,"name":"Algorithms","title":"Algorithms"},{"count":41,"name":"计算机科学","title":"计算机科学"},{"count":38,"name":"编程","title":"编程"},{"count":16,"name":"数据结构与算法","title":"数据结构与算法"}],"origin_title":"Data Structures and Algorithm Analysis in C","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s4459394.jpg","binding":"平装","translator":[],"catalog":"1  Introduction  1.1. What's the Book About?  1.2. Mathematics Review    1.2.1. Exponents    1.2.2. Logarithms    1.2.3. Series    1.2.4. Modular Arithmetic    1.2.5. The P Word  1.3. A Brief Introduction to Recursion    Summary    Exercises    References2  Algorithm Analysis3  Lists, Stacks, and Queues4  Trees5  Hashing6  Priority Queues (Heaps)7  Sorting 2198  The Disjoint Set ADT9  Graph Algorithms10  Algorithm Design Techniques11  Amortized Analysis12  Advanced Data Structures and Implementation","pages":"511","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s4459394.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s4459394.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s4459394.jpg"},"alt":"https:\/\/book.douban.com\/subject\/4924153\/","id":"4924153","publisher":"机械工业出版社","isbn10":"7111312805","isbn13":"9787111312802","title":"数据结构与算法分析","url":"https:\/\/api.douban.com\/v2\/book\/4924153","alt_title":"Data Structures and Algorithm Analysis in C","author_intro":"Mark Allen Weiss 1987年在普林斯顿大学获得计算机科学博士学位。师从Roberl Sedgewick，现任美国佛罗里达国际大学计算与信息科学学院教授。他曾担任全美AP(Advanced Placement)考试计算机学科委员会主席。其主要研究方向是数据结构、算法和教育学。","summary":"《数据结构与算法分析:C语言描述》曾被评为20世纪顶尖的30部计算机著作之一，作者在数据结构和算法分析方面卓有建树，他的数据结构和算法分析的著作尤其畅销，并受到广泛好评，已被世界500余所大学选作教材。\n在《数据结构与算法分析:C语言描述》中，作者精炼并强化了他对算法和数据结构方面创新的处理方法。通过C程序的实现，着重阐述了抽象数据类型的概念，并对算法的效率、性能和运行时间进行了分析。\n《数据结构与算法分析:C语言描述》特色：着重讨论了算法设计技巧，包括贪婪算法、分治算法、动态规划、随机化算法以及回溯算法。系统介绍了当前流行的论题和新的数据结构，如斐波那契堆、斜堆、二项队列、跳跃表和伸展树。详细讨论了摊还分析，考查书中介绍的一些高级数据结构。增加了高级数据结构及其实现的内容，包括红黑树、自顶向下伸展树、treap树、k-d树、配对堆等。整合了堆排序平均情况分析的一些新结果。","series":{"id":"1895","title":"经典原版书库"},"price":"45.00元"},{"rating":{"max":10,"numRaters":1802,"average":"9.1","min":0},"subtitle":"（第五版）","author":["Stephen Prata","云巅工作室"],"pubdate":"2005-2-1","tags":[{"count":915,"name":"编程","title":"编程"},{"count":840,"name":"c","title":"c"},{"count":830,"name":"c语言","title":"c语言"},{"count":611,"name":"计算机","title":"计算机"},{"count":480,"name":"程序设计","title":"程序设计"},{"count":379,"name":"经典","title":"经典"},{"count":378,"name":"C","title":"C"},{"count":243,"name":"programming","title":"programming"}],"origin_title":"","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1308874.jpg","binding":"平装(无盘)","translator":["云巅工作室"],"catalog":"第1章 概览\n1.1 C语言的起源\n1.2 使用C语言的理由\n1.3 C语言的发展方向\n1.4 计算机工作的基本原理\n1.5 高级计算机语言和编译器\n1.6 使用C语言的7个步骤\n1.7 编程机制\n1.8 语言标准\n1.9 本书的组织结构\n1.10 本书体例\n1.11 总结\n1.12 复习题\n1.13 编程练习\n第2章 C语言概述\n2.1 C语言的一个简单实例\n2.2 实例说明\n2.3 一个简单程序的结构\n2.4 使程序可读的技巧\n2.5 更进一步\n2.6 多个函数\n2.7 调试\n2.8 关键字和保留标识符\n2.9 关键概念\n2.10 总结\n2.11 复习题\n2.12 编程练习\n第3章 数据和C\n3.1 示例程序\n3.2 变量与常量数据\n3.3 数据：数据类型关键字\n3.4 C数据类型\n3.5 使用数据类型\n3.6 参数和易犯的错误\n3.7 另一个例子：转义序列\n3.8 关键概念\n3.9 总结\n3.10 复习题\n3.11 编程练习\n第4章 字符串和格式化输入\/输出\n4.1 前导程序\n4.2 字符串简介\n4.3 常量和C预处理器\n4.4 研究和利用printf（）和scanf（）\n4.5 关键概念\n4.6 总结\n4.7 复习题\n4.8 编程练习\n第5章 运算符、表达式和语句\n5.1 循环简介\n5.2 基本运算符\n5.3 其他运算符\n5.4 表达式和语句\n5.5 类型转换\n5.6 带有参数的函数\n5.7 一个示例程序\n5.8 关键概念\n5.9 总结\n5.10 复习题\n5.11 编程练习\n第6章 C控制语句：循环\n6.1 再探while循环\n6.2 while语句\n6.4 不确定循环与计数循环\n6.5 for循环\n6.6 更多赋值运算符：+=、-=、*=、\/=和%=\n6.7 逗号运算符\n6.8 退出条件循环：do while\n6.9 选择哪种循环\n6.10 嵌套循环\n6.11 数组\n6.12 使用函数返回值的循环例子\n6.13 关键概念\n6.14 总结\n6.15 复习题\n6.16 编程练习\n第7章 C控制语句：分支和跳转\n7.1 if语句\n7.2 在if语句中添加else关键字\n7.3 获得逻辑性\n7.4 一个统计字数的程序\n7.5 条件运算符?:\n7.6 循环辅助手段：continue和break\n7.7 多重选择：switch和break\n7.8 goto语句\n7.9 关键概念\n7.10 总结\n7.11 复习题\n7.12 编程练习\n第8章 字符输入\/输出和输入确认\n8.1 单字符I\/O：getchar（）和putchar（）\n8.2 缓冲区\n8.3 终止键盘输入\n8.5 创建一个更友好的用户界面\n8.6 输入确认\n8.7 菜单浏览\n8.8 关键概念\n8.9 总结\n8.10 复习题\n8.11 编程练习\n第9章 函数\n9.1 函数概述\n9.2 ANSI C的函数原型\n9.3 递归\n9.4 多源代码文件程序的编译\n9.5 地址运算符：&\n9.6 改变调用函数中的变量\n9.7 指针简介\n9.8 关键概念\n9.9 总结\n9.10 复习题\n9.11 编程练习\n第10章 数组和指针\n10.1 数组\n10.2 多维数组\n10.3 指针和数组\n10.4 函数、数组和指针\n10.5 指针操作\n10.6 保护数组内容\n10.7 指针和多维数组\n10.8 变长数组（VLA）\n10.9 复合文字\n10.10 关键概念\n10.11 总结\n10.12 复习题\n10.13 编程练习\n第11章 字符串和字符串函数\n11.1 字符串表示和字符串I\/O\n11.2 字符串输入\n11.3 字符串输出\n11.4 自定义字符串输入\/输出函数\n11.5 字符串函数\n11.6 字符串例子：字符串排序\n11.7 ctype.h字符函数和字符串\n11.8 命令行参数\n11.9 把字符串转换为数字\n11.10 关键概念\n11.11 总结\n11.12 复习题\n11.13 编程练习\n第12章 存储类、链接和内存管理\n12.1 存储类\n12.2 存储类说明符\n12.3 存储类和函数\n12.4 随机数函数和静态变量\n12.5 掷骰子\n12.6 分配内存：malloc（）和free（）\n12.7 ANSI C的类型限定词\n12.8 关键概念\n12.9 总结\n12.10 复习题\n12.11 编程练习\n第13章 文件输入\/输出\n13.1 和文件进行通信\n13.2 标准I\/O\n13.3 一个简单的文件压缩程序\n13.4 文件I\/O：fprintf ( )、fscanf ( )、fgets ( )和fputs ( )函数\n13.5 随机存取：fseek（）和ftell（）函数\n13.6 标准I\/O内幕\n13.7 其他标准I\/O函数\n13.8 关键概念\n13.9 总结\n13.10 复习题\n13.11 编程练习\n第14章 结构和其他数据形式\n14.1 示例问题：创建图书目录\n14.2 建立结构声明\n14.3 定义结构变量\n14.4 结构数组\n14.5 嵌套结构\n14.6 指向结构的指针\n14.7 向函数传递结构信息\n14.8 把结构内容保存到文件中\n14.9 结构：下一步是什么\n14.10 联合简介\n14.11 枚举类型\n14.12 typedef简介\n14.13 奇特的声明\n14.14 函数和指针\n14.15 关键概念\n14.16 总结\n14.17 复习题\n14.18 编程练习\n第15章 位操作\n15.1 二进制数、位和字节\n15.2 其他基数\n15.3 C的位运算符\n15.4 位字段\n15.5 关键概念\n15.6 总结\n15.7 复习题\n15.8 编程练习\n第16章 C预处理器和C库\n16.1 翻译程序的第一步\n16.2 明显常量：#define\n16.3 在#define中使用参数\n16.4 宏，还是函数\n16.5 文件包含：＃include\n16.6 其他指令\n16.7 内联函数\n16.8 C库\n16.9 数学库\n16.10 通用工具库\n16.11 诊断库\n16.12 string.h库中的memcpy（）和memmove（）\n16.13 可变参数：stdarg.h\n16.14 关键概念\n16.15 总结\n16.16 复习题\n16.17 编程练习\n第17章 高级数据表示\n17.1 研究数据表示\n17.2 从数组到链表\n17.3 抽象数据类型（ADT）\n17.4 队列ADT\n17.5 用队列进行模拟\n17.6 链表与数组\n17.7 二叉搜索树\n17.8 其他说明\n17.9 关键概念\n17.10 总结\n17.11 复习题\n17.12 编程练习\n附录A 复习题答案\n附录B 参考资料","pages":"626","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s1308874.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s1308874.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s1308874.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1240002\/","id":"1240002","publisher":"人民邮电出版社","isbn10":"7115130221","isbn13":"9787115130228","title":"C Primer Plus","url":"https:\/\/api.douban.com\/v2\/book\/1240002","alt_title":"","author_intro":"普拉塔，在加利福尼亚州的Kentfield的Marin学院教授天文学、物理学和程序设计课程。他在加州工业学院获得学士学位，从加州大学伯克利分校获得博士学位。他最早接触计算机，始于对星河的计算机建模。Stephen已经编写或与他人合作编写了十多本书。其中包括C++Primer Plus和Unix Prinmer Plus。","summary":"《C Primer Plus（第5版）（中文版）》共17章。第1、2章学习C语言编程所需的预备知识。第3到15章介绍了C语言的相关知识，包括数据类型、格式化输入输出、运算符、表达式、流程控制语句、函数、数组和指针、字符串操作、内存管理、位操作等等，知识内容都针对C99标准；另外，第10章强化了对指针的讨论，第12章引入了动态内存分配的概念，这些内容更加适合读者的需求。第16章和第17章讨论了C预处理器和C库函数、高级数据表示（数据结构）方面的内容。附录给出了各章后面复习题、编程练习的答案和丰富的C编程参考资料。","price":"60.00元"},{"rating":{"max":10,"numRaters":1935,"average":"9.2","min":0},"subtitle":"","author":["Peter Van Der Linden"],"pubdate":"2008-2","tags":[{"count":1196,"name":"C语言","title":"C语言"},{"count":681,"name":"编程","title":"编程"},{"count":446,"name":"计算机","title":"计算机"},{"count":405,"name":"c","title":"c"},{"count":387,"name":"C专家编程","title":"C专家编程"},{"count":364,"name":"C\/C++","title":"C\/C++"},{"count":339,"name":"C","title":"C"},{"count":302,"name":"程序设计","title":"程序设计"}],"origin_title":"Expert C Programming: Deep C Secrets","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s5886086.jpg","binding":"平装","translator":["徐波"],"catalog":"第1章 C：穿越时空的迷雾\n1.1 C语言的史前阶段\n1.2 C语言的早期体验\n1.3 标准I\/O库和C预处理器\n1.4 K&R C\n1.5 今日之ANSI C\n1.6 它很棒，但它符合标准吗\n1.7 编译限制\n1.8 ANSI C标准的结构\n1.9 阅读ANSI C标准，寻找乐趣和裨益\n1.10 “安静的改变”究竟有多少安静\n1.11 轻松一下——由编译器定义的Pragmas效果\n第2章 这不是Bug，而是语言特性\n2.1 这关语言特性何事，在Fortran里这就是Bug呀\n2.2 多做之过\n2.3 误做之过\n2.4 少做之过\n2.5 轻松一下——有些特性确实就是Bug\n2.6 参考文献\n第3章 分析C语言的声明\n3.1 只有编译器才会喜欢的语法\n3.2 声明是如何形成的\n3.3 优先级规则\n3.4 通过图表分析C语言的声明\n3.5 typedef可以成为你的朋友\n3.6 typedef int x[10]和#define x int[10]的区别\n3.7 typedef struct foo{ ... foo; }的含义\n3.8 理解所有分析过程的代码段\n3.9 轻松一下——驱动物理实体的软件\n第4章 令人震惊的事实：数组和指针并不相同\n4.1 数组并非指针\n4.2 我的代码为什么无法运行\n4.3 什么是声明，什么是定义\n4.4 使声明与定义相匹配\n4.5 数组和指针的其他区别\n4.6 轻松一下——回文的乐趣\n第5章 对链接的思考\n5.1 函数库、链接和载入\n5.2 动态链接的优点\n5.3 函数库链接的5个特殊秘密\n5.4 警惕Interpositioning\n5.5 产生链接器报告文件\n5.6 轻松一下——看看谁在说话：挑战Turing测验\n第6章 运动的诗章：运行时数据结构\n6.1 a.out及其传说\n6.2 段\n6.3 操作系统在a.out文件里干了些什么\n6.4 C语言运行时系统在a.out里干了些什么\n6.5 当函数被调用时发生了什么：过程活动记录\n6.6 auto和static关键字\n6.7 控制线程\n6.8 setjmp和longjmp\n6.9 UNIX中的堆栈段\n6.10 MS-DOS中的堆栈段\n6.11 有用的C语言工具\n6.12 轻松一下——卡耐基-梅隆大学的编程难题\n6.13 只适用于高级学员阅读的材料\n第7章 对内存的思考\n7.1 Intel 80x86系列\n7.2 Intel 80x86内存模型以及它的工作原理\n7.3 虚拟内存\n7.4 Cache存储器\n7.5 数据段和堆\n7.6 内存泄漏\n7.7 总线错误\n7.8 轻松一下——“Thing King”和“页面游戏”\n第8章 为什么程序员无法分清万圣节和圣诞节\n8.1 Portzebie度量衡系统\n8.2 根据位模式构筑图形\n8.3 在等待时类型发生了变化\n8.4 原型之痛\n8.5 原型在什么地方会失败\n8.6 不需要按回车键就能得到一个字符\n8.7 用C语言实现有限状态机\n8.8 软件比硬件更困难\n8.9 如何进行强制类型转换，为何要进行类型强制转换\n8.10 轻松一下——国际C语言混乱代码大赛\n第9章 再论数组\n9.1 什么时候数组与指针相同\n9.2 为什么会发生混淆\n9.3 为什么C语言把数组形参当作指针\n9.4 数组片段的下标\n9.5 数组和指针可交换性的总结\n9.6 C语言的多维数组\n9.7 轻松一下——软件\/硬件平衡\n第10章 再论指针\n10.1 多维数组的内存布局\n10.2 指针数组就是Iliffe向量\n10.3 在锯齿状数组上使用指针\n10.4 向函数传递一个一维数组\n10.5 使用指针向函数传递一个多维数组\n10.6 使用指针从函数返回一个数组\n10.7 使用指针创建和使用动态数组\n10.8 轻松一下——程序检验的限制\n第11章 你懂得C，所以C++不在话下\n11.1 初识OOP\n11.2 抽象——取事物的本质特性\n11.3 封装——把相关的类型、数据和函数组合在一起\n11.4 展示一些类——用户定义类型享有和预定义类型一样的权限\n11.5 访问控制\n11.6 声明\n11.7 如何调用成员函数\n11.8 继承——复用已经定义的操作\n11.9 多重继承——从两个或更多的基类派生\n11.10 重载——作用于不同类型的同一操作具有相同的名字\n11.11 C++如何进行操作符重载\n11.12 C++的输入\/输出(I\/O)\n11.13 多态——运行时绑定\n11.14 解释\n11.15 C++如何表现多态\n11.16 新奇玩意——多态\n11.17 C++的其他要点\n11.18 如果我的目标是那里，我不会从这里起步\n11.19 它或许过于复杂，但却是惟一可行的方案\n11.20 轻松一下——死亡计算机协会\n11.21 更多阅读材料\n附录A 程序员工作面试的秘密\n附录B 术语表","pages":"291","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s5886086.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s5886086.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s5886086.jpg"},"alt":"https:\/\/book.douban.com\/subject\/2377310\/","id":"2377310","publisher":"人民邮电出版社","isbn10":"7115171807","isbn13":"9787115171801","title":"C专家编程","url":"https:\/\/api.douban.com\/v2\/book\/2377310","alt_title":"Expert C Programming: Deep C Secrets","author_intro":"","summary":"《C专家编程》展示了最优秀的C程序员所使用的编码技巧，并专门开辟了一章对C++的基础知识进行了介绍。\n书中C的历史、语言特性、声明、数组、指针、链接、运行时、内存以及如何进一步学习C++等问题进行了细致的讲解和深入的分析。全书撷取几十个实例进行讲解，对C程序员具有非常高的实用价值。\n本书可以帮助有一定经验的C程序员成为C编程方面的专家，对于具备相当的C语言基础的程序员，本书可以帮助他们站在C的高度了解和学习C++。","series":{"id":"9931","title":"C和C++经典著作"},"price":"45.00元"},{"rating":{"max":10,"numRaters":154,"average":"8.8","min":0},"subtitle":"C标准库“圣经”","author":["P. J. Plauger"],"pubdate":"2009-7","tags":[{"count":228,"name":"C","title":"C"},{"count":196,"name":"C语言","title":"C语言"},{"count":103,"name":"编程","title":"编程"},{"count":102,"name":"标准库","title":"标准库"},{"count":76,"name":"计算机","title":"计算机"},{"count":76,"name":"C\/C++","title":"C\/C++"},{"count":57,"name":"程序设计","title":"程序设计"},{"count":40,"name":"库","title":"库"}],"origin_title":"","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s3820140.jpg","binding":"","translator":["卢红星","徐明亮","霍建同"],"catalog":"第0章　简介. 1\n0.1　背景知识1\n0.2　C 标准的内容 3\n0.3　库的使用7\n0.4　库的实现9\n0.5　库的测试13\n0.6　参考文献15\n0.7　习题15\n第1章　(assert.h)17\n1.1　背景知识17\n1.2　C 标准的内容18\n1.3　(assert.h) 的使用18\n1.4　(assert.h) 的实现20\n1.5　(assert.h) 的测试22\n1.6　参考文献23\n1.7　习题23\n第2章　(ctype.h) 25\n2.1　背景知识25\n2.2　C 标准的内容28\n2.3　(ctype.h) 的使用 30\n2.4　(ctype.h) 的实现 34\n2.5　(ctype.h) 的测试 42\n2.6　参考文献45\n2.7　习题45\n第3章　(errno.h) 47\n3.1　背景知识47\n3.2　C 标准的内容50\n3.3　(errno.h) 的使用 50\n3.4　(errno.h) 的实现 51\n3.5　(errno.h) 的测试 55\n3.6　参考文献55\n3.7　习题55\n第4章　(float.h)57\n4.1　背景知识57\n4.2　C 标准的内容59\n4.3　(float.h) 的使用.62\n4.4　(float.h) 的实现.64\n4.5　(float.h) 的测试.69\n4.6　参考文献71\n4.7　习题72\n第5章　(limits.h)73\n5.1　背景知识73\n5.2　C 标准的内容74\n5.3　(limits.h) 的使用75\n5.4　(limits.h) 的实现77\n5.5　(limits.h) 的测试79\n5.6　参考文献80\n5.7　习题80\n第6章　(locale.h)81\n6.1　背景知识81\n6.2　C 标准的内容84\n6.3　(locale.h) 的使用87\n6.4　(locale.h) 的实现94\n6.5　(locale.h) 的测试 123\n6.6　参考文献.123\n6.7　习题123\n第7章　(math.h)127\n7.1　背景知识.127\n7.2　C 标准的内容 130\n7.3　(math.h) 的使用 135\n7.4　(math.h) 的实现 137\n7.5　(math.h) 的测试 171\n7.6　参考文献.177\n7.7　习题177\n第8章　(setjmp.h).. 181\n8.1　背景知识.181\n8.2　C 标准的内容 184\n8.3　(setjmp.h) 的使用 185\n8.4　(setjmp.h) 的实现 187\n8.5 (setjmp.h) 的测试191\n8.6 参考文献 192\n8.7 习题 192\n第9章　(signal.h) 193\n9.1　背景知识.193\n9.2　C 标准的内容 195\n9.3　(signal.h) 的使用 197\n9.4　(signal.h) 的实现 199\n9.5　(signal.h) 的测试 203\n9.6　参考文献.203\n9.7　习题203\n第10章　(stdarg.h) 205\n10.1　背景知识205\n10.2　C 标准的内容 207\n10.3　(stdarg.h) 的使用 208\n10.4　(stdarg.h) 的实现 211\n10.5　(stdarg.h) 的测试 212\n10.6　参考文献212\n10.7　习题.214\n第11章　(stddef.h) 215\n11.1　背景知识 215\n11.2　C 标准的内容 217\n11.3　(stddef.h) 的使用 217\n11.4　(stddef.h) 的实现 222\n11.5　(stddef.h) 的测试 223\n11.6　参考文献 223\n11.7　习题223\n第12章　(stdio.h) 225\n12.1　背景知识225\n12.2　C 标准的内容 233\n12.3　(stdio.h) 的使用 252\n12.4　(stdio.h) 的实现 274\n12.5　(stdio.h) 的测试 323\n12.6　参考文献325\n12.7　习题.325\n第13章　(stdlib.h) 331\n13.1　背景知识331\n13.2　C 标准的内容 332\n13.3　(stdlib.h) 的使用 342\n13.4　(stdlib.h) 的实现 351\n13.5　(stdlib.h) 的测试 379\n13.6　参考文献379\n13.7　习题.382\n第14章　(string.h) 385\n14.1　背景知识385\n14.2　C 标准的内容 386\n14.3　(string.h) 的使用 392\n14.4　(string.h) 的实现 396\n14.5　(string.h) 的测试 409\n14.6　参考文献409\n14.7　习题.409\n第15章　(time.h) 413\n15.1　背景知识413\n15.2　C 标准的内容 414\n15.3　(time.h) 的使用 418\n15.4　(time.h) 的实现 422\n15.5　(time.h) 的测试440\n15.6　参考文献441\n15.7　习题.441\n附录A　接口 443\n附录B　名字 451\n附录C　术语... 461","pages":"488","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s3820140.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s3820140.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s3820140.jpg"},"alt":"https:\/\/book.douban.com\/subject\/3775842\/","id":"3775842","publisher":"人民邮电出版社","isbn10":"7115172862","isbn13":"9787115172860","title":"C标准库","url":"https:\/\/api.douban.com\/v2\/book\/3775842","alt_title":"","author_intro":"P. J. Plauger  世界著名的软件技术专家，曾任ISO C标准委员会主席，C\/C++ User’s Journal主编，现任ISO C++标准委员会主席。他是C\/C++标准库开发领域的大师，所开发的Dinkumware标准库应用广泛。","summary":"本书是由世界级C语言专家编写的C标准库经典著作。英文版已经重印十多次，影响了几代程序员。\n本书结合C标准的相关部分，精辟地讲述了每一个库函数的使用方法和实现细节，而这正是一个真正的C程序员所必须掌握的。更重要的是，书中给出了实现和测试这些函数的完整源代码，可以让你更深入地学习C语言。不仅如此，本书还讨论了一些即使是最有经验的C程序员通常也不熟悉的知识，比如国际化和独立于区域设置的程序的编写、与构建库相关的概念和设计思想。\n本书结构清晰，内容权威，阐述精辟，对于各层次C 程序员和相关专业高校师生都是一本优秀的参考书。","series":{"id":"50484","title":"图灵程序设计丛书·C\/C++系列"},"price":"79.00元"},{"rating":{"max":10,"numRaters":808,"average":"8.6","min":0},"subtitle":"一本37.5°C的博物馆地图","author":["沈辛成"],"pubdate":"2017-5-20","tags":[{"count":588,"name":"纽约","title":"纽约"},{"count":560,"name":"博物馆","title":"博物馆"},{"count":455,"name":"旅行","title":"旅行"},{"count":370,"name":"美国","title":"美国"},{"count":337,"name":"艺术","title":"艺术"},{"count":281,"name":"城市","title":"城市"},{"count":214,"name":"历史","title":"历史"},{"count":193,"name":"生活","title":"生活"}],"origin_title":"","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s29478001.jpg","binding":"精装","translator":[],"catalog":"指南与致谢\n有点像跋的序\n第一章 你这个种族主义者\n纽约深度游线路一：黑色与白色\n第二章 没有华尔的街\n纽约深度游线路二：革命与资本\n第三章 纽约水故事\n纽约深度游线路三：饮水与思源\n第四章 我的画报你的城\n纽约深度游之四：寻根与漂流\n第五章 曼哈顿是平的\n纽约深度游之五：贫穷与富裕\n第六章 开往昨天的地铁\n纽约深度游之六：地下与地上\n第七章 美国的归美国，纽约的归纽约\n纽约深度游之七：美国与欧洲\n第八章 不知道为什么就流泪\n纽约深度游之八：战争与和平\n有点像序的跋\n附录\n附录一：一些遗珠\n附录二：纽约博物馆排名","pages":"380","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s29478001.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s29478001.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s29478001.jpg"},"alt":"https:\/\/book.douban.com\/subject\/27037182\/","id":"27037182","publisher":"中西书局","isbn10":"7547512488","isbn13":"9787547512487","title":"纽约无人是客","url":"https:\/\/api.douban.com\/v2\/book\/27037182","alt_title":"","author_intro":"沈辛成，1984年生人，非业余博物馆爱好者，走访全美八十余座博物馆，曾服务于美国自然历史博物馆、“911”国家纪念馆和纽约历史学会，参与从事档案研究、出版与策展工作。佐治亚理工学院科技史博士在读，哥伦比亚大学人类学硕士，复旦大学考古学硕士，北京大学博物馆学学士，做过独立唱作人，兼职美国时政评论。","summary":"本书为作者在纽约实地踏访数十家博物馆并进行深入了解后，对纽约博物馆展示特色、专业内涵、设计匠心及观众体验等进行多维度评价的作品。\n本书不是一本简单的博物馆导览手册，而是基于作者的个人经历和专业背景，试图阐释纽约这个五方杂处、光怪陆离却又独具特色的国际大都会的底色。全书行文从容，图文并茂，兼具知识性、实用性和可读性，无论是否去过纽约，它都会在流畅的阅读之后，带给你充足的知识与细节，同时也带给你深深的思索。","price":"39.80元"},{"rating":{"max":10,"numRaters":1399,"average":"9.0","min":0},"subtitle":"","author":["Kenneth A.Reek"],"pubdate":"2008 年4月","tags":[{"count":869,"name":"C","title":"C"},{"count":776,"name":"C语言","title":"C语言"},{"count":540,"name":"编程","title":"编程"},{"count":437,"name":"指针","title":"指针"},{"count":381,"name":"计算机","title":"计算机"},{"count":304,"name":"程序设计","title":"程序设计"},{"count":276,"name":"C\/C++","title":"C\/C++"},{"count":180,"name":"Programming","title":"Programming"}],"origin_title":"Pointers on C","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s2996168.jpg","binding":"平装","translator":["徐波"],"catalog":"第1章 快速上手\n1.1 简介\n1.1.1 空白和注释\n1.1.2 预处理指令\n1.1.3 main函数\n1.1.4 read_column_numbers函数\n1.1.5 rearrange函数\n1.2 补充说明\n1.3 编译\n1.4 总结\n1.5 警告的总结\n1.6 编程提示的总结\n1.7 问题\n1.8 编程练习\n第2章 基本概念\n2.1 环境\n2.1.1 翻译\n2.1.2 执行\n2.2 词法规则\n2.2.1 字符\n2.2.2 注释\n2.2.3 自由形式的源代码\n2.2.4 标识符\n2.2.5 程序的形式\n2.3 程序风格\n2.4 总结\n2.5 警告的总结\n2.6 编程提示的总结\n2.7 问题\n2.8 编程练习\n第3章 数据\n第4章 语句\n第5章 操作符和表达式\n第6章 指针\n第7章 函数\n第8章 数组\n第9章 字符串、字符和字节\n第10章 结构和联合\n第11章 动态内存分配\n第12章 使用结构和指针\n第13章 高级指针话题\n第14章 预处理器\n第15章 输入\/输出函数\n第16章 标准函数库\n第17章 经典抽象数据类型\n第18章 运行时环境\n附录 部分问题答案\n索引\n参考文献","pages":"448","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s2996168.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s2996168.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s2996168.jpg"},"alt":"https:\/\/book.douban.com\/subject\/3012360\/","id":"3012360","publisher":"人民邮电出版社","isbn10":"7115172013","isbn13":"9787115172013","title":"C和指针","url":"https:\/\/api.douban.com\/v2\/book\/3012360","alt_title":"Pointers on C","author_intro":"Kenneth·Reek是罗彻斯特理工大学计算机科学教授。他是一位经验丰富的C程序员，曾为多家公司担任过技术顾问。他讲授的课程有操作系统、数据通信、计算机网络、形式语言、算法分析和交换系统等。本书正是基于他9年的编程及教学的经验积累。","summary":"本书提供与C语言编程相关的全面资源和深入讨论。本书通过对指针的基础知识和高级特性的探讨，帮助程序员把指针的强大功能融入到自己的程序中去。\n全书共18章，覆盖了数据、语句、操作符和表达式、指针、函数、数组、字符串、结构和联合等几乎所有重要的C编程话题。书中给出了很多编程技巧和提示，每章后面有针对性很强的练习，附录部分则给出了部分练习的解答。\n本书适合C语言初学者和初级C程序员阅读，也可作为计算机专业学生学习C语言的参考。","series":{"id":"9931","title":"C和C++经典著作"},"price":"65.00元"},{"rating":{"max":10,"numRaters":1270,"average":"9.6","min":0},"subtitle":"-","author":["Brian W. Kernighan","Dennis M. Ritchie"],"pubdate":"1988-4-1","tags":[{"count":611,"name":"c","title":"c"},{"count":434,"name":"Programming","title":"Programming"},{"count":403,"name":"C语言","title":"C语言"},{"count":382,"name":"编程","title":"编程"},{"count":316,"name":"计算机","title":"计算机"},{"count":240,"name":"经典","title":"经典"},{"count":218,"name":"C","title":"C"},{"count":205,"name":"程序设计","title":"程序设计"}],"origin_title":"","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s29586132.jpg","binding":"Paperback","translator":[],"catalog":"","pages":"274","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s29586132.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s29586132.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s29586132.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1236999\/","id":"1236999","publisher":"Prentice Hall","isbn10":"0131103628","isbn13":"9780131103627","title":"The  C Programming Language","url":"https:\/\/api.douban.com\/v2\/book\/1236999","alt_title":"C Programming Language","author_intro":"Brian W. Kernighan works in the Computing Science Research Center at Bell Laboratories, Lucent Technologies. He is Consulting Editor for Addison-Wesley's Professional Computing Series and the author, with Dennis Ritchie, of The C Programming Language.\nDennis Ritchie is a computer scientist notable for his influence on ALTRAN, B, BCPL, C, Multics, and Unix.","summary":"Presents a complete guide to ANSI standard C language programming. Written by the developers of C, this new version helps readers keep up with the finalized ANSI standard for C while showing how to take advantage of C's rich set of operators, economy of expression, improved control flow, and data structures. This 2nd edition has been completely rewritten with additional examples and problem sets to clarify the implementation of difficult language constructs. 7 x 9 1\/4.","price":"USD 67.00"},{"rating":{"max":10,"numRaters":604,"average":"9.3","min":0},"subtitle":"第六版","author":["普拉达 (Stephen Prata)"],"pubdate":"2016-4-1","tags":[{"count":347,"name":"C语言","title":"C语言"},{"count":231,"name":"C","title":"C"},{"count":215,"name":"编程","title":"编程"},{"count":183,"name":"计算机","title":"计算机"},{"count":142,"name":"计算机科学","title":"计算机科学"},{"count":125,"name":"经典","title":"经典"},{"count":86,"name":"C++","title":"C++"},{"count":78,"name":"软件开发","title":"软件开发"}],"origin_title":"C Primer Plus : 6th","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s29438897.jpg","binding":"平装","translator":["姜佑"],"catalog":"第1章　初识C语言\t1\n1．1　C语言的起源\t1\n1．2 选择C语言的理由\t1\n1．2．1 设计特性\t1\n1．2．2 高效性\t1\n1．2．3 可移植性\t2\n1．2．4 强大而灵活\t3\n1．2．5 面向程序员\t3\n1．2．6 缺点\t3\n1．3 C语言的应用范围\t3\n1．4 计算机能做什么\t4\n1．5 高级计算机语言和编译器\t5\n1．6 语言标准\t6\n1．6．1 第1个ANSI\/ISO C标准\t6\n1．6．2 C99标准\t6\n1．6．3 C11标准\t7\n1．7 使用C语言的7个步骤\t7\n1．7．1 第1步：定义程序的目标\t8\n1．7．2 第2步：设计程序\t8\n1．7．3 第3步：编写代码\t8\n1．7．4 第4步：编译\t8\n1．7．5 第5步：运行程序\t9\n1．7．6 第6步：测试和调试程序\t9\n1．7．7 第7步：维护和修改代码\t9\n1．7．8 说明\t9\n1．8 编程机制\t10\n1．8．1 目标代码文件、可执行文件和库\t10\n1．8．2 UNIX系统\t11\n1．8．3 GNU编译器集合和LLVM项目\t13\n1．8．4 Linux系统\t13\n1．8．5 PC的命令行编译器\t14\n1．8．6 集成开发环境（Windows）\t14\n1．8．7 Windows\/Linux\t15\n1．8．8 Macintosh中的C\t15\n1．9 本书的组织结构\t15\n1．10 本书的约定\t16\n1．10．1 字体\t16\n1．10．2 程序输出\t16\n1．10．3 特殊元素\t17\n1．11 本章小结\t17\n1．12 复习题\t18\n1．13 编程练习\t18\n第2章　C语言概述\t19\n2．1 简单的C程序示例\t19\n2．2 示例解释\t20\n2．2．1 第1遍：快速概要\t21\n2．2．2 第2遍：程序细节\t21\n2．3 简单程序的结构\t28\n2．4 提高程序可读性的技巧\t28\n2．5 进一步使用C\t29\n2．5．1 程序说明\t30\n2．5．2 多条声明\t30\n2．5．3 乘法\t30\n2．5．4 打印多个值\t30\n2．6 多个函数\t30\n2．7 调试程序\t32\n2．7．1 语法错误\t32\n2．7．2 语义错误\t33\n2．7．3 程序状态\t34\n2．8 关键字和保留标识符\t34\n2．9 关键概念\t35\n2．10 本章小结\t35\n2．11 复习题\t36\n2．12 编程练习\t37\n第3章　数据和C\t39\n3．1 示例程序\t39\n3．2 变量与常量数据\t42\n3．3 数据：数据类型关键字\t42\n3．3．1 整数和浮点数\t43\n3．3．2 整数\t43\n3．3．3 浮点数\t43\n3．4 C语言基本数据类型\t44\n3．4．1 int类型\t44\n3．4．2 其他整数类型\t47\n3．4．3 使用字符：char类型\t50\n3．4．4 _Bool类型\t54\n3．4．5 可移植类型：stdint．h和inttypes．h\t55\n3．4．6 float、double和long double\t56\n3．4．7 复数和虚数类型\t60\n3．4．8 其他类型\t60\n3．4．9 类型大小\t62\n3．5 使用数据类型\t63\n3．6 参数和陷阱\t63\n3．7 转义序列示例\t64\n3．7．1 程序运行情况\t65\n3．7．2 刷新输出\t65\n3．8 关键概念\t66\n3．9 本章小结\t66\n3．10 复习题\t67\n3．11 编程练习\t68\n第4章　字符串和格式化输入\/输出\t71\n4．1 前导程序\t71\n4．2 字符串简介\t72\n4．2．1 char类型数组和null字符\t72\n4．2．2 使用字符串\t73\n4．2．3 strlen()函数\t74\n4．3 常量和C预处理器\t76\n4．3．1 const限定符\t78\n4．3．2 明示常量\t78\n4．4 printf()和scanf()\t80\n4．4．1 printf()函数\t80\n4．4．2 使用printf()\t81\n4．4．3 printf()的转换说明修饰符\t83\n4．4．4 转换说明的意义\t87\n4．4．5 使用scanf()\t92\n4．4．6 printf()和scanf()的*修饰符\t95\n4．4．7 printf()的用法提示\t97\n4．5 关键概念\t98\n4．6 本章小结\t98\n4．7 复习题\t99\n4．8 编程练习\t100\n第5章　运算符、表达式和语句\t103\n5．1 循环简介\t103\n5．2 基本运算符\t105\n5．2．1 赋值运算符：=\t105\n5．2．2 加法运算符：+\t107\n5．2．3 减法运算符：-\t107\n5．2．4 符号运算符：-和+\t107\n5．2．5 乘法运算符：*\t108\n5．2．6 除法运算符：\/\t110\n5．2．7 运算符优先级\t110\n5．2．8 优先级和求值顺序\t112\n5．3 其他运算符\t113\n5．3．1 sizeof运算符和size_t类型\t113\n5．3．2 求模运算符：%\t114\n5．3．3 递增运算符：++\t115\n5．3．4 递减运算符：--\t118\n5．3．5 优先级\t118\n5．3．6 不要自作聪明\t119\n5．4 表达式和语句\t120\n5．4．1 表达式\t120\n5．4．2 语句\t120\n5．4．3 复合语句（块）\t123\n5．5 类型转换\t124\n5．6 带参数的函数\t127\n5．7 示例程序\t129\n5．8 关键概念\t130\n5．9 本章小结\t130\n5．10 复习题\t131\n5．11 编程练习\t134\n第6章　C控制语句：循环\t137\n6．1 再探while循环\t137\n6．1．1 程序注释\t138\n6．1．2 C风格读取循环\t139\n6．2 while语句\t140\n6．2．1 终止while循环\t140\n6．2．2 何时终止循环\t141\n6．2．3 while：入口条件循环\t141\n6．2．4 语法要点\t141\n6．3 用关系运算符和表达式比较大小\t143\n6．3．1 什么是真\t144\n6．3．2 其他真值\t145\n6．3．3 真值的问题\t146\n6．3．4 新的_Bool类型\t147\n6．3．5 优先级和关系运算符\t148\n6．4 不确定循环和计数循环\t150\n6．5 for循环\t151\n6．6 其他赋值运算符：+=、-=、*=、\/=、%=\t155\n6．7 逗号运算符\t156\n6．8 出口条件循环：do while\t159\n6．9 如何选择循环\t161\n6．10 嵌套循环\t162\n6．10．1 程序分析\t163\n6．10．2 嵌套变式\t163\n6．11 数组简介\t164\n6．12 使用函数返回值的循环示例\t166\n6．12．1 程序分析\t168\n6．12．2 使用带返回值的函数\t169\n6．13 关键概念\t169\n6．14 本章小结\t170\n6．15 复习题\t170\n6．16 编程练习\t174\n第7章　C控制语句：分支和跳转\t177\n7．1 if语句\t177\n7．2 if else语句\t179\n7．2．1 另一个示例：介绍getchar()和putchar()\t180\n7．2．2 ctype．h系列的字符函数\t182\n7．2．3 多重选择else if\t184\n7．2．4 else与if配对\t186\n7．2．5 多层嵌套的if语句\t187\n7．3 逻辑运算符\t190\n7．3．1 备选拼写：iso646．h头文件\t191\n7．3．2 优先级\t192\n7．3．3 求值顺序\t192\n7．3．4 范围\t193\n7．4 一个统计单词的程序\t194\n7．5 条件运算符：?：\t196\n7．6 循环辅助：continue和break\t198\n7．6．1 continue语句\t198\n7．6．2 break语句\t200\n7．7 多重选择：switch和break\t202\n7．7．1 switch语句\t204\n7．7．2 只读每行的首字符\t205\n7．7．3 多重标签\t206\n7．7．4 switch和if else\t208\n7．8 goto语句\t208\n7．9 关键概念\t211\n7．10 本章小结\t211\n7．11 复习题\t212\n7．12 编程练习\t214\n第8章　字符输入\/输出和输入验证\t217\n8．1 单字符I\/O：getchar()和putchar()\t217\n8．2 缓冲区\t218\n8．3 结束键盘输入\t219\n8．3．1 文件、流和键盘输入\t219\n8．3．2 文件结尾\t220\n8．4 重定向和文件\t222\n8．5 创建更友好的用户界面\t226\n8．5．1 使用缓冲输入\t226\n8．5．2 混合数值和字符输入\t228\n8．6 输入验证\t230\n8．6．1 分析程序\t234\n8．6．2 输入流和数字\t234\n8．7 菜单浏览\t235\n8．7．1 任务\t235\n8．7．2 使执行更顺利\t235\n8．7．3 混合字符和数值输入\t237\n8．8 关键概念\t240\n8．9 本章小结\t240\n8．10 复习题\t241\n8．11 编程练习\t241\n第9章　函数\t243\n9．1 复习函数\t243\n9．1．1 创建并使用简单函数\t244\n9．1．2 分析程序\t245\n9．1．3 函数参数\t247\n9．1．4 定义带形式参数的函数\t248\n9．1．5 声明带形式参数函数的原型\t249\n9．1．6 调用带实际参数的函数\t249\n9．1．7 黑盒视角\t250\n9．1．8 使用return从函数中返回值\t250\n9．1．9 函数类型\t252\n9．2 ANSI C函数原型\t253\n9．2．1 问题所在\t253\n9．2．2 ANSI的解决方案\t254\n9．2．3 无参数和未指定参数\t255\n9．2．4 函数原型的优点\t256\n9．3 递归\t256\n9．3．1 演示递归\t256\n9．3．2 递归的基本原理\t258\n9．3．3 尾递归\t258\n9．3．4 递归和倒序计算\t260\n9．3．5 递归的优缺点\t262\n9．4 编译多源代码文件的程序\t262\n9．4．1 UNIX\t263\n9．4．2 Linux\t263\n9．4．3 DOS命令行编译器\t263\n9．4．4 Windows和苹果的IDE编译器\t263\n9．4．5 使用头文件\t263\n9．5 查找地址：&运算符\t267\n9．6 更改主调函数中的变量\t268\n9．7 指针简介\t269\n9．7．1 间接运算符：*\t270\n9．7．2 声明指针\t270\n9．7．3 使用指针在函数间通信\t271\n9．8 关键概念\t274\n9．9 本章小结\t275\n9．10　复习题\t275\n9．11 编程练习\t276\n第10章　数组和指针\t277\n10．1 数组\t277\n10．1．1 初始化数组\t277\n10．1．2 指定初始化器（C99）\t281\n10．1．3 给数组元素赋值\t282\n10．1．4 数组边界\t282\n10．1．5 指定数组的大小\t284\n10．2 多维数组\t284\n10．2．1 初始化二维数组\t287\n10．2．2 其他多维数组\t288\n10．3 指针和数组\t288\n10．4 函数、数组和指针\t290\n10．4．1 使用指针形参\t293\n10．4．2 指针表示法和数组表示法\t294\n10．5 指针操作\t295\n10．6 保护数组中的数据\t298\n10．6．1 对形式参数使用const\t299\n10．6．2　const的其他内容\t300\n10．7 指针和多维数组\t302\n10．7．1 指向多维数组的指针\t304\n10．7．2 指针的兼容性\t305\n10．7．3 函数和多维数组\t306\n10．8 变长数组（VLA）\t309\n10．9 复合字面量\t312\n10．10 关键概念\t314\n10．11 本章小结\t315\n10．12 复习题\t316\n10．13 编程练习\t317\n第11章　字符串和字符串函数\t321\n11．1 表示字符串和字符串I\/O\t321\n11．1．1 在程序中定义字符串\t322\n11．1．2 指针和字符串\t328\n11．2 字符串输入\t329\n11．2．1 分配空间\t329\n11．2．2 不幸的gets()函数\t330\n11．2．3 gets()的替代品\t331\n11．2．4 scanf()函数\t336\n11．3 字符串输出\t337\n11．3．1 puts()函数\t338\n11．3．2 fputs()函数\t339\n11．3．3 printf()函数\t339\n11．4 自定义输入\/输出函数\t340\n11．5 字符串函数\t342\n11．5．1 strlen()函数\t342\n11．5．2 strcat()函数\t343\n11．5．3 strncat()函数\t345\n11．5．4 strcmp()函数\t346\n11．5．5 strcpy()和strncpy()函数\t351\n11．5．6 sprintf()函数\t356\n11．5．7 其他字符串函数\t357\n11．6 字符串示例：字符串排序\t359\n11．6．1 排序指针而非字符串\t360\n11．6．2 选择排序算法\t361\n11．7 ctype．h字符函数和字符串\t362\n11．8 命令行参数\t363\n11．8．1 集成环境中的命令行参数\t365\n11．8．2 Macintosh中的命令行参数\t365\n11．9 把字符串转换为数字\t365\n11．10 关键概念\t368\n11．11 本章小结\t368\n11．12 复习题\t369\n11．13 编程练习\t371\n第12章　存储类别、链接和内存管理\t373\n12．1 存储类别\t373\n12．1．1 作用域\t374\n12．1．2 链接\t376\n12．1．3 存储期\t376\n12．1．4 自动变量\t377\n12．1．5 寄存器变量\t380\n12．1．6 块作用域的静态变量\t381\n12．1．7 外部链接的静态变量\t382\n12．1．8 内部链接的静态变量\t386\n12．1．9 多文件\t386\n12．1．10 存储类别说明符\t387\n12．1．11 存储类别和函数\t389\n12．1．12 存储类别的选择\t389\n12．2 随机数函数和静态变量\t390\n12．3 掷骰子\t393\n12．4 分配内存：malloc()和free()\t396\n12．4．1 free()的重要性\t399\n12．4．2 calloc()函数\t400\n12．4．3 动态内存分配和变长数组\t400\n12．4．4 存储类别和动态内存分配\t401\n12．5 ANSI C类型限定符\t402\n12．5．1 const类型限定符\t403\n12．5．2 volatile类型限定符\t404\n12．5．3 restrict类型限定符\t405\n12．5．4 _Atomic类型限定符（C11）\t406\n12．5．5 旧关键字的新位置\t406\n12．6　关键概念\t407\n12．7 本章小结\t407\n12．8 复习题\t408\n12．9 编程练习\t409\n第13章　文件输入\/输出\t413\n13．1 与文件进行通信\t413\n13．1．1 文件是什么\t413\n13．1．2 文本模式和二进制模式\t413\n13．1．3 I\/O的级别\t415\n13．1．4 标准文件\t415\n13．2 标准I\/O\t415\n13．2．1 检查命令行参数\t416\n13．2．2 fopen()函数\t416\n13．2．3 getc()和putc()函数\t417\n13．2．4 文件结尾\t418\n13．2．5 fclose()函数\t419\n13．2．6 指向标准文件的指针\t419\n13．3 一个简单的文件压缩程序\t419\n13．4 文件I\/O：fprintf()、fscanf()、fgets()和fputs()\t421\n13．4．1 fprintf()和fscanf()函数\t421\n13．4．2 fgets()和fputs()函数\t422\n13．5 随机访问：fseek()和ftell()\t423\n13．5．1 fseek()和ftell()的工作原理\t424\n13．5．2 二进制模式和文本模式\t425\n13．5．3 可移植性\t425\n13．5．4 fgetpos()和fsetpos()函数\t426\n13．6 标准I\/O的机理\t426\n13．7 其他标准I\/O函数\t427\n13．7．1 int ungetc(int c， FILE *fp)函数\t427\n13．7．2 int fflush()函数\t428\n13．7．3 int setvbuf()函数\t428\n13．7．4 二进制I\/O：fread()和fwrite()\t428\n13．7．5 size_t fwrite()函数\t429\n13．7．6 size_t fread()函数\t430\n13．7．7 int feof(FILE *fp)和int ferror(FILE *fp)函数\t430\n13．7．8 一个程序示例\t430\n13．7．9 用二进制I\/O进行随机访问\t433\n13．8 关键概念\t435\n13．9 本章小结\t435\n13．10 复习题\t435\n13．11 编程练习\t437\n第14章　结构和其他数据形式\t439\n14．1 示例问题：创建图书目录\t439\n14．2 建立结构声明\t441\n14．3 定义结构变量\t441\n14．3．1 初始化结构\t442\n14．3．2 访问结构成员\t443\n14．3．3 结构的初始化器\t443\n14．4 结构数组\t444\n14．4．1 声明结构数组\t446\n14．4．2 标识结构数组的成员\t447\n14．4．3 程序讨论\t447\n14．5 嵌套结构\t448\n14．6 指向结构的指针\t449\n14．6．1 声明和初始化结构指针\t450\n14．6．2 用指针访问成员\t451\n14．7 向函数传递结构的信息\t451\n14．7．1 传递结构成员\t451\n14．7．2 传递结构的地址\t452\n14．7．3 传递结构\t453\n14．7．4 其他结构特性\t454\n14．7．5 结构和结构指针的选择\t458\n14．7．6 结构中的字符数组和字符指针\t458\n14．7．7 结构、指针和malloc()\t459\n14．7．8 复合字面量和结构（C99）\t462\n14．7．9 伸缩型数组成员（C99）\t463\n14．7．10 匿名结构（C11）\t465\n14．7．11 使用结构数组的函数\t466\n14．8 把结构内容保存到文件中\t467\n14．8．1 保存结构的程序示例\t468\n14．8．2 程序要点\t470\n14．9 链式结构\t471\n14．10 联合简介\t472\n14．10．1 使用联合\t472\n14．10．2 匿名联合（C11）\t473\n14．11 枚举类型\t474\n14．11．1 enum常量\t475\n14．11．2 默认值\t475\n14．11．3 赋值\t475\n14．11．4 enum的用法\t476\n14．11．5 共享名称空间\t477\n14．12 typedef简介\t478\n14．13 其他复杂的声明\t479\n14．14 函数和指针\t481\n14．15 关键概念\t487\n14．16 本章小结\t487\n14．17 复习题\t488\n14．18 编程练习\t490\n第15章　位操作\t493\n15．1 二进制数、位和字节\t493\n15．1．1 二进制整数\t494\n15．1．2 有符号整数\t494\n15．1．3 二进制浮点数\t495\n15．2 其他进制数\t495\n15．2．1 八进制\t495\n15．2．2 十六进制\t496\n15．3 C按位运算符\t496\n15．3．1 按位逻辑运算符\t497\n15．3．2 用法：掩码\t498\n15．3．3 用法：打开位（设置位）\t498\n15．3．4 用法：关闭位（清空位）\t499\n15．3．5 用法：切换位\t499\n15．3．6 用法：检查位的值\t500\n15．3．7 移位运算符\t500\n15．3．8 编程示例\t501\n15．3．9 另一个例子\t503\n15．4 位字段\t505\n15．4．1 位字段示例\t506\n15．4．2 位字段和按位运算符\t509\n15．5 对齐特性（C11）\t515\n15．6 关键概念\t516\n15．7 本章小结\t516\n15．8 复习题\t517\n15．9 编程练习\t518\n第16章　C预处理器和C库\t521\n16．1 翻译程序的第一步\t521\n16．2 明示常量：#define\t522\n16．2．1 记号\t525\n16．2．2 重定义常量\t525\n16．3 在#define中使用参数\t525\n16．3．1 用宏参数创建字符串：#运算符\t527\n16．3．2 预处理器黏合剂：##运算符\t528\n16．3．3 变参宏：．．．和_ _VA_ARGS_ _\t529\n16．4 宏和函数的选择\t530\n16．5 文件包含：#include\t531\n16．5．1 头文件示例\t531\n16．5．2 使用头文件\t533\n16．6 其他指令\t534\n16．6．1 #undef指令\t534\n16．6．2 从C预处理器角度看已定义\t534\n16．6．3 条件编译\t535\n16．6．4 预定义宏\t539\n16．6．5 #line和#error\t540\n16．6．6 #pragma\t540\n16．6．7 泛型选择（C11）\t541\n16．7 内联函数（C99）\t542\n16．8 _Noreturn函数（C11）\t544\n16．9 C库\t544\n16．9．1 访问C库\t544\n16．9．2 使用库描述\t545\n16．10 数学库\t546\n16．10．1 三角问题\t547\n16．10．2 类型变体\t548\n16．10．3 tgmath．h库（C99）\t550\n16．11 通用工具库\t550\n16．11．1 exit()和atexit()函数\t550\n16．11．2 qsort()函数\t552\n16．12 断言库\t556\n16．12．1 assert的用法\t556\n16．12．2 _Static_assert（C11）\t557\n16．13 string．h库中的memcpy()和memmove()\t558\n16．14 可变参数：stdarg．h\t560\n16．15 关键概念\t562\n16．16 本章小结\t562\n16．17 复习题\t562\n16．18 编程练习\t563\n第17章　高级数据表示\t567\n17．1 研究数据表示\t567\n17．2 从数组到链表\t570\n17．2．1 使用链表\t572\n17．2．2 反思\t576\n17．3 抽象数据类型（ADT）\t576\n17．3．1 建立抽象\t577\n17．3．2 建立接口\t578\n17．3．3 使用接口\t581\n17．3．4 实现接口\t583\n17．4 队列ADT\t589\n17．4．1 定义队列抽象数据类型\t590\n17．4．2 定义一个接口\t590\n17．4．3 实现接口数据表示\t591\n17．4．4 测试队列\t598\n17．5 用队列进行模拟\t600\n17．6 链表和数组\t605\n17．7 二叉查找树\t608\n17．7．1 二叉树ADT\t608\n17．7．2 二叉查找树接口\t609\n17．7．3 二叉树的实现\t611\n17．7．4 使用二叉树\t624\n17．7．5 树的思想\t628\n17．8 其他说明\t629\n17．9 关键概念\t630\n17．10 本章小结\t630\n17．11 复习题\t630\n17．12 编程练习\t631\n附录A　复习题答案\t633\n附录B　参考资料\t665\nB．1 参考资料I：补充阅读\t665\nB．2 参考资料II：C运算符\t667\nB．3 参考资料III：基本类型和存储类别\t671\nB．4 参考资料IV：表达式、语句和程序流\t675\nB．5 参考资料V：新增C99和C11的ANSI C库\t679\nB．6 参考资料VI：扩展的整数类型\t714\nB．7 参考资料VII：扩展字符支持\t716\nB．8 参考资料VIII：C99\/C11数值计算增强\t720\nB．9 参考资料IX：C和C++的区别\t726","pages":"730","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s29438897.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s29438897.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s29438897.jpg"},"alt":"https:\/\/book.douban.com\/subject\/26792521\/","id":"26792521","publisher":"人民邮电出版社","isbn10":"7115390592","isbn13":"9787115390592","title":"C Primer Plus（第6版）中文版","url":"https:\/\/api.douban.com\/v2\/book\/26792521","alt_title":"C Primer Plus : 6th","author_intro":"Stephen Prata曾在加利福尼亚的马林学院（肯特菲尔德）教授天文学、物理学和程序设计课程，现已退休。他在加州理工学院获得学士学位，在加州大学伯克利分校获得博士学位。他接触程序设计，是为了利用计算机给星团建模。Stephen撰写和与他人合著了十几本书籍，其中包括C++ Primer Plus和Unix Primer Plus。","summary":"《C Primer Plus（第6版）中文版》详细讲解了C语言的基本概念和编程技巧。\n《C Primer Plus（第6版）中文版》共17章。第1、2章介绍了C语言编程的预备知识。第3~15章详细讲解了C语言的相关知识，包括数据类型、格式化输入\/输出、运算符、表达式、语句、循环、字符输入和输出、函数、数组和指针、字符和字符串函数、内存管理、文件输入输出、结构、位操作等。第16章、17章介绍C预处理器、C库和高级数据表示。本书以完整的程序为例，讲解C语言的知识要点和注意事项。每章末设计了大量复习题和编程练习，帮助读者巩固所学知识和提高实际编程能力。附录给出了各章复习题的参考答案和丰富的参考资料。\n《C Primer Plus（第6版）中文版》可作为C语言的教材，适用于需要系统学习C语言的初学者，也适用于巩固C语言知识或希望进一步提高编程技术的程序员。","series":{"id":"23545","title":"C和C++实务精选"},"price":"CNY 89.00"},{"rating":{"max":10,"numRaters":389,"average":"9.3","min":0},"subtitle":"现代方法","author":["K. N. King"],"pubdate":"2010-4","tags":[{"count":526,"name":"C语言","title":"C语言"},{"count":315,"name":"C","title":"C"},{"count":240,"name":"程序设计","title":"程序设计"},{"count":239,"name":"编程","title":"编程"},{"count":230,"name":"计算机","title":"计算机"},{"count":182,"name":"C\/C++","title":"C\/C++"},{"count":162,"name":"编程语言","title":"编程语言"},{"count":128,"name":"计算机科学","title":"计算机科学"}],"origin_title":"C Programming: A Modern Approach, Second Edition","image":"https://img3.doubanio.com\/view\/subject\/m\/public\/s4171870.jpg","binding":"平装","translator":["吕秀锋","黄倩"],"catalog":"第1章 C语言概述1\n1.1 C语言的历史1\n1.1.1 起源1\n1.1.2 标准化1\n1.1.3 基于C的语言2\n1.2 C语言的优缺点3\n1.2.1 C语言的优点3\n1.2.2 C语言的缺点3\n1.2.3 高效地使用C语言4\n问与答5\n第2章 C语言基本概念7\n2.1 编写一个简单的C程序7\n程序显示双关语7\n2.1.1 编译和链接8\n2.1.2 集成开发环境8\n2.2 简单程序的一般形式9\n2.2.1 指令9\n2.2.2 函数9\n2.2.3 语句10\n2.2.4 显示字符串10\n2.3 注释11\n2.4 变量和赋值12\n2.4.1 类型12\n2.4.2 声明13\n2.4.3 赋值13\n2.4.4 显示变量的值14\n程序计算箱子的空间重量14\n2.4.5 初始化15\n2.4.6 显示表达式的值16\n2.5 读入输入16\n程序计算箱子的空间重量（改进版）16\n2.6 定义常量的名字17\n程序华氏温度转换为摄氏温度17\n2.7 标识符18\n2.8 C程序的书写规范19\n问与答21\n练习题23\n编程题24\n第3章 格式化输入\/输出26\n3.1 printf函数26\n3.1.1 转换说明27\n程序用printf函数格式化数28\n3.1.2 转义序列28\n3.2 scanf函数29\n3.2.1 scanf函数的工作方法30\n3.2.2 格式串中的普通字符31\n3.2.3 易混淆的printf函数和scanf函数32\n程序分数相加32\n问与答33\n练习题34\n编程题35\n第4章 表达式36\n4.1 算术运算符36\n程序计算通用产品代码的校验位38\n4.2 赋值运算符39\n4.2.1 简单赋值40\n4.2.2 左值41\n4.2.3 复合赋值41\n4.3 自增运算符和自减运算符42\n4.4 表达式求值43\n4.5 表达式语句45\n问与答45\n练习题47\n编程题49\n第5章 选择语句50\n5.1 逻辑表达式50\n5.1.1 关系运算符50\n5.1.2 判等运算符51\n5.1.3 逻辑运算符51\n5.2 if语句52\n5.2.1 复合语句53\n5.2.2 else子句53\n5.2.3 级联式if语句54\n程序计算股票经纪人的佣金55\n5.2.4 “悬空else”的问题56\n5.2.5 条件表达式57\n5.2.6 C89中的布尔值58\n5.2.7 C99中的布尔值58\n5.3 switch语句59\n程序显示法定格式的日期61\n问与答62\n练习题65\n编程题67\n第6章 循环69\n6.1 while语句69\n程序显示平方表71\n程序数列求和71\n6.2 do语句72\n程序计算整数的位数73\n6.3 for语句73\n6.3.1 for语句的惯用法74\n6.3.2 在for语句中省略表达式75\n6.3.3 C99中的for语句75\n6.3.4 逗号运算符76\n程序显示平方表（改进版）77\n6.4 退出循环78\n6.4.1 break语句78\n6.4.2 continue语句78\n6.4.3 goto语句79\n程序账簿结算80\n6.5 空语句81\n问与答83\n练习题84\n编程题85\n第7章 基本类型88\n7.1 整数类型88\n7.1.1 C99中的整数类型90\n7.1.2 整数常量90\n7.1.3 C99中的整数常量91\n7.1.4 整数溢出91\n7.1.5 读\/写整数91\n程序数列求和（改进版）92\n7.2 浮点类型93\n7.2.1 浮点常量94\n7.2.2 读\/写浮点数94\n7.3 字符类型94\n7.3.1 字符操作95\n7.3.2 有符号字符和无符号字符95\n7.3.3 算术类型96\n7.3.4 转义序列96\n7.3.5 字符处理函数97\n7.3.6 用scanf和printf读\/写字符98\n7.3.7 用getchar和putchar读\/写字符98\n程序确定消息的长度99\n7.4 类型转换100\n7.4.1 常用算术转换101\n7.4.2 赋值过程中的转换102\n7.4.3 C99中的隐式转换103\n7.4.4 强制类型转换103\n7.5 类型定义105\n7.5.1 类型定义的优点105\n7.5.2 类型定义和可移植性105\n7.6 sizeof运算符106\n问与答107\n练习题109\n编程题110\n第8章 数组113\n8.1 一维数组113\n8.1.1 数组下标113\n程序数列反向115\n8.1.2 数组初始化115\n8.1.3 指定初始化式116\n程序检查数中重复出现的数字116\n8.1.4 对数组使用sizeof运算符117\n程序计算利息118\n8.2 多维数组119\n8.2.1 多维数组初始化120\n8.2.2 常量数组121\n程序发牌121\n8.3 C99中的变长数组122\n问与答123\n练习题124\n编程题125\n第9章 函数129\n9.1 函数的定义和调用129\n程序计算平均值129\n程序显示倒计数130\n程序显示双关语（改进版）131\n9.1.1 函数定义132\n9.1.2 函数调用133\n程序判定素数134\n9.2 函数声明135\n9.3 实际参数136\n9.3.1 实际参数的转换137\n9.3.2 数组型实际参数138\n9.3.3 变长数组形式参数140\n9.3.4 在数组参数声明中使用static141\n9.3.5 复合字面量141\n9.4 return语句142\n9.5 程序终止143\n9.6 递归144\n程序快速排序146\n问与答147\n练习题150\n编程题153\n第10章 程序结构155\n10.1 局部变量155\n10.1.1 静态局部变量156\n10.1.2 形式参数156\n10.2 外部变量156\n10.2.1 示例：用外部变量实现栈156\n10.2.2 外部变量的利与弊157\n程序猜数158\n10.3 程序块161\n10.4 作用域162\n10.5 构建C程序163\n程序给一手牌分类163\n问与答169\n练习题169\n编程题170\n第11章 指针172\n11.1 指针变量172\n11.2 取地址运算符和间接寻址运算符173\n11.2.1 取地址运算符173\n11.2.2 间接寻址运算符174\n11.3 指针赋值174\n11.4 指针作为参数176\n程序找出数组中的最大元素和最小元素177\n11.5 指针作为返回值179\n问与答180\n练习题181\n编程题182\n第12章 指针和数组184\n12.1 指针的算术运算184\n12.1.1 指针加上整数185\n12.1.2 指针减去整数185\n12.1.3 两个指针相减186\n12.1.4 指针比较186\n12.1.5 指向复合常量的指针186\n12.2 指针用于数组处理186\n12.3 用数组名作为指针188程序数列反向（改进版）189\n12.3.1 数组型实际参数（改进版）189\n12.3.2 用指针作为数组名191\n12.4 指针和多维数组191\n12.4.1 处理多维数组的元素191\n12.4.2 处理多维数组的行192\n12.4.3 处理多维数组的列192\n12.4.4 用多维数组名作为指针192\n12.5 C99中的指针和变长数组193\n问与答194\n练习题195\n编程题197\n第13章 字符串198\n13.1 字符串字面量198\n13.1.1 字符串字面量中的转义序列198\n13.1.2 延续字符串字面量199\n13.1.3 如何存储字符串字面量199\n13.1.4 字符串字面量的操作200\n13.1.5 字符串字面量与字符常量200\n13.2 字符串变量200\n13.2.1 初始化字符串变量201\n13.2.2 字符数组与字符指针202\n13.3 字符串的读和写203\n13.3.1 用printf函数和puts函数写字符串203\n13.3.2 用scanf函数和gets函数读字符串203\n13.3.3 逐个字符读字符串204\n13.4 访问字符串中的字符205\n13.5 使用C语言的字符串库206\n13.5.1 strcpy函数207\n13.5.2 strlen函数208\n13.5.3 strcat函数208\n13.5.4 strcmp函数209程序显示一个月的提醒列表209\n13.6 字符串惯用法211\n13.6.1 搜索字符串的结尾211\n13.6.2 复制字符串213\n13.7 字符串数组214\n程序核对行星的名字217\n问与答218\n练习题220\n编程题222\n第14章 预处理器225\n14.1 预处理器的工作原理225\n14.2 预处理指令227\n14.3 宏定义227\n14.3.1 简单的宏227\n14.3.2 带参数的宏229\n14.3.3 #运算符231\n14.3.4 ##运算符231\n14.3.5 宏的通用属性232\n14.3.6 宏定义中的圆括号233\n14.3.7 创建较长的宏233\n14.3.8 预定义宏234\n14.3.9 C99中新增的预定义宏235\n14.3.10 空的宏参数236\n14.3.11 参数个数可变的宏236\n14.3.12 __func__标识符237\n14.4 条件编译237\n14.4.1 #if指令和#endif指令238\n14.4.2 defined运算符238\n14.4.3 #ifdef指令和#ifndef指令239\n14.4.4 #elif指令和#else指令239\n14.4.5 使用条件编译240\n14.5 其他指令240\n14.5.1 #error指令240\n14.5.2 #line指令241\n14.5.3 #pragma指令242\n14.5.4 _Pragma运算符242\n问与答243\n练习题245\n第15章 编写大型程序248\n15.1 源文件248\n15.2 头文件249\n15.2.1 #include指令249\n15.2.2 共享宏定义和类型定义250\n15.2.3 共享函数原型251\n15.2.4 共享变量声明252\n15.2.5 嵌套包含253\n15.2.6 保护头文件253\n15.2.7 头文件中的#error指令254\n15.3 把程序划分成多个文件254程序文本格式化255\n15.4 构建多文件程序260\n15.4.1 makefile260\n15.4.2 链接期间的错误262\n15.4.3 重新构建程序262\n15.4.4 在程序外定义宏264\n问与答264\n练习题265\n编程题266\n第16章 结构、联合和枚举267\n16.1 结构变量267\n16.1.1 结构变量的声明267\n16.1.2 结构变量的初始化269\n16.1.3 指定初始化269\n16.1.4 对结构的操作270\n16.2 结构类型270\n16.2.1 结构标记的声明271\n16.2.2 结构类型的定义272\n16.2.3 结构作为参数和返回值272\n16.2.4 复合字面量273\n16.3 嵌套的数组和结构274\n16.3.1 嵌套的结构274\n16.3.2 结构数组274\n16.3.3 结构数组的初始化275程序维护零件数据库275\n16.4 联合281\n16.4.1 用联合来节省空间282\n16.4.2 用联合来构造混合的数据结构284\n16.4.3 为联合添加“标记字段”284\n16.5 枚举285\n16.5.1 枚举标记和类型名286\n16.5.2 枚举作为整数286\n16.5.3 用枚举声明“标记字段”286\n问与答287\n练习题289\n编程题293\n第17章 指针的高级应用294\n17.1 动态存储分配294\n17.1.1 内存分配函数294\n17.1.2 空指针295\n17.2 动态分配字符串296\n……\n第18章 声明 327\n第19章 程序设计 345\n第20章 底层程序设计 363\n第21章 标准库 377\n第22章 输入\/输出 384\n第23章 库对数值和字符数据的支持 419\n第24章 错误处理 446\n第25章 国际化特性 456\n第26章 其他库函数 482\n第27章 C99对数学计算的新增支持 503\n附录A C语言运算符 524\n附录B C99与C89的比较 525\n附录C C89与经典C的比较 529\n附录D 标准库函数 532\n附录E ASCII字符集 569\n参考文献 570\n索引 573","pages":"600","images":{"small":"https://img3.doubanio.com\/view\/subject\/s\/public\/s4171870.jpg","large":"https://img3.doubanio.com\/view\/subject\/l\/public\/s4171870.jpg","medium":"https://img3.doubanio.com\/view\/subject\/m\/public\/s4171870.jpg"},"alt":"https:\/\/book.douban.com\/subject\/4279678\/","id":"4279678","publisher":"人民邮电出版社","isbn10":"7115219575","isbn13":"9787115219572","title":"C语言程序设计","url":"https:\/\/api.douban.com\/v2\/book\/4279678","alt_title":"C Programming: A Modern Approach, Second Edition","author_intro":"K. N. King 世界知名的计算机程序设计教育家，现为佐治亚州立大学数学与计算机科学系副教授。他拥有耶鲁大学计算机科学硕士学位，加州大学伯克利分校计算机科学博士学位，曾任教于佐治亚理工学院。除本书外，他还撰写了广受欢迎的著作Modula-2: A Complete Guide 和Java Programming: From the Beginning，并在Dr.Dobb's Journal等权威杂志上发表了许多文章。\n吕秀锋，亚洲理工大学（AIT）计算机软件硕士，现为北京理工大学软件学院教师。多年来一直从事“计算机基础（双语）”、“C语言程序设计（双语）”以及“程序设计开发与实践”等本科生课程的教学工作，深受学生欢迎。她还译有《数据结构与算法：C＃语言描述》一书。\n黄倩，中国科学院计算技术研究所工学博士，中国计算机学会会员。研究方向包括视频处理、视频监控等，已在知名的国际期刊和国际会议论文集上发表10篇论文。译有《编程珠玑（第2版）》一书，受到读者欢迎。","summary":"时至今日， C语言仍然是计算机领域的通用语言之一，但今天的 C语言已经和最初的时候大不相同了。本书最主要的一个目的就是通过一种“现代方法”来介绍 C语言，书中强调标准 C，强调软件工程，不再强调“手工优化”。这一版中紧密结合了 C99标准，并与 C89标准进行对照，补充了 C99中的最新特性。本书分为 C语言的基础特性、 C语言的高级特性、 C语言标准库和参考资料 4个部分。每章末尾都有一个“问与答”小节给出一系列与该章内容相关的问题及答案，此外还包含适量的习题。\n本书是为大学本科阶段的 C语言课程编写的教材，同时也非常适合作为其他课程的辅助用书。","series":{"id":"50484","title":"图灵程序设计丛书·C\/C++系列"},"price":"79.00元"},{"rating":{"max":10,"numRaters":133,"average":"8.0","min":0},"subtitle":"C语言描述","author":["Kyle Loudon"],"pubdate":"2012-8","tags":[{"count":270,"name":"算法","title":"算法"},{"count":103,"name":"C语言","title":"C语言"},{"count":79,"name":"编程","title":"编程"},{"count":63,"name":"计算机","title":"计算机"},{"count":48,"name":"计算机科学","title":"计算机科学"},{"count":38,"name":"程序设计","title":"程序设计"},{"count":34,"name":"C","title":"C"},{"count":31,"name":"Programming","title":"Programming"}],"origin_title":"Mastering Algorithms with C","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s11351454.jpg","binding":"平装","translator":["肖翔","陈舸"],"catalog":"1. 前言\n2. 第1部分 预备知识\n3. 第1章 概述\n4. 数据结构简介\n5. 算法简介\n6. 小酌软件工程\n7. 如何使用本书\n8. 第2章 指针操作\n9. 指针基础\n10. 存储空间分配\n11. 数据集合与指针的算术运算\n12. 作为函数参数的指针\n13. 泛型指针与类型转换\n14. 函数指针\n15. 问与答\n16. 相关主题\n17. 第3章 递归\n18. 基本递归\n19. 尾递归\n20. 问与答\n21. 相关主题\n22. 第4章 算法分析\n23. 最坏情况分析\n24. O表示法\n25. 计算的复杂度\n26. 实例分析：插入排序\n27. 问与答\n28. 相关主题\n29. 第2部分 数据结构\n30. 第5章 链表\n31. 单链表介绍\n32. 单链表接口的定义\n33. 单链表的实现与分析\n34. 使用链表的例子：页帧管理\n35. 双向链表介绍\n36. 双向链表接口的定义\n37. 双向链表的实现与分析\n38. 循环链表介绍\n39. 循环链表接口的定义\n40. 循环链表的实现与分析\n41. 使用循环链表的例子：第二次机会页面置换法\n42. 问与答\n43. 相关主题\n44. 第6章 栈和队列\n45. 栈的描述\n46. 栈的接口定义\n47. 栈的实现与分析\n48. 队列的描述\n49. 队列的接口定义\n50. 队列的实现与分析\n51. 队列示例：事件处理\n52. 问与答\n53. 相关主题\n54. 第7章 集合\n55. 集合介绍\n56. 集合的性质\n57. 集合接口的定义\n58. 集合抽象数据类型的实现和分析\n59. Set示例：集合覆盖\n60. 问与答\n61. 相关主题\n62. 第8章 哈希表\n63. 链式哈希表的描述\n64. 链式哈希表的接口定义\n65. 链式哈希表的实现与分析\n66. 链式哈希表的例子：符号表\n67. 开地址哈希表的描述\n68. 开地址哈希函数的接口定义\n69. 开地址哈希表的实现与分析\n70. 问与答\n71. 相关主题\n72. 第9章 树\n73. 二叉树介绍\n74. 二叉树的接口定义\n75. 二叉树的实现与分析\n76. 二叉树示例：表达式处理\n77. 二叉搜索树介绍\n78. 二叉搜索树的接口定义\n79. 二叉搜索树的实现与分析\n80. 问与答\n81. 相关主题\n82. 第10章 堆和优先队列\n83. 堆的描述\n84. 堆的接口定义\n85. 堆的实现与分析\n86. 优先队列的描述\n87. 优先队列的接口定义\n88. 优先队列的实现与分析\n89. 优先队列的示例：包裹分拣\n90. 问与答\n91. 相关主题\n92. 第11章 图\n93. 图的描述\n94. 图的接口定义\n95. 图的实现与分析\n96. 关于图的应用举例：计算网络跳数\n97. 关于图的应用举例：拓扑排序\n98. 问与答\n99. 相关主题\n100. 第3部分 算法\n101. 第12章 排序和搜索\n102. 插入排序的描述\n103. 插入排序的接口定义\n104. 插入排序的实现与分析\n105. 快速排序的描述\n106. 快速排序的接口定义\n107. 快速排序的实现与分析\n108. 快速排序的例子：目录列表\n109. 归并排序的描述\n110. 归并排序的接口定义\n111. 归并排序的实现与分析\n112. 计数排序的描述\n113. 计数排序的接口定义\n114. 计数排序的实现与分析\n115. 基数排序的描述\n116. 基数排序的接口定义\n117. 基数排序的实现与分析\n118. 二分查找的描述\n119. 二分查找的接口定义\n120. 二分查找的实现与分析\n121. 二分查找的例子：拼写检查器\n122. 问与答\n123. 相关主题\n124. 第13章 数值计算\n125. 多项式插值法\n126. 多项式插值的接口定义\n127. 多项式插值的实现与分析\n128. 最小二乘估计法\n129. 最小二乘估计的接口定义\n130. 最小二乘估计的实现和分析\n131. 方程求解介绍\n132. 方程求解的接口定义\n133. 方程求解的实现与分析\n134. 问与答\n135. 相关主题\n136. 第14章 数据压缩\n137. 位操作的描述\n138. 位操作的接口定义\n139. 位操作的实现与分析\n140. 霍夫曼编码的描述\n141. 霍夫曼编码的接口定义\n142. 霍夫曼编码的分析与实现\n143. 霍夫曼编码的例子：网络优化\n144. LZ77的描述\n145. LZ77的接口定义\n146. LZ77的实现与分析\n147. 问与答\n148. 相关主题\n149. 第15章 数据加密\n150. DES算法介绍\n151. DES的接口定义\n152. DES算法的实现和分析\n153. DES应用举例：分组加密模式\n154. RSA算法介绍\n155. RSA的接口定义\n156. RSA算法的实现与分析\n157. 问与答\n158. 相关主题\n159. 第16章 图算法\n160. 最小生成树的描述\n161. 最小生成树的接口定义\n162. 最小生成树的实现与分析\n163. 最短路径的描述\n164. 最短路径的接口定义\n165. 最短路径的实现与分析\n166. 最短路径的例子：路由表\n167. 旅行商问题的描述\n168. 旅行商问题的接口定义\n169. 旅行商问题的实现与分析\n170. 问与答\n171. 相关主题\n172. 第17章 几何算法\n173. 测试线段是否相交\n174. 测试线段是否相交的标准方法\n175. 检测线段是否相交的接口定义\n176. 检测线段是否相交的实现与分析\n177. 凸包简介\n178. Jarvis’s March\n179. 凸包的接口定义\n180. 凸包的实现与分析\n181. 球面弧长\n182. 求解球面弧长的接口定义\n183. 求解球面弧长的实现和分析\n184. 球面弧长的应用举例：地球上两点之间的近似距离\n185. 问与答\n186. 相关主题","pages":"401","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s11351454.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s11351454.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s11351454.jpg"},"alt":"https:\/\/book.douban.com\/subject\/14267904\/","id":"14267904","publisher":"机械工业出版社","isbn10":"7111394267","isbn13":"9787111394266","title":"算法精解","url":"https:\/\/api.douban.com\/v2\/book\/14267904","alt_title":"Mastering Algorithms with C","author_intro":"Kyle Loudon是美国加州洛斯加托斯Jeppesen Dataplan公司的一名软件工程师，主管图形接口开发小组，主攻航迹规划软件的研发，这些软件主要用于商业航空公司、私营航空部门和其他一些航空制造业。在来到Jeppesen之前，Kyle在IBM公司是一名系统程序员。在技术上，Kyle主要对操作系统、网络、人机交互等领域感兴趣。1992年，Kyle在普渡大学拿到了计算机科学学士学位，并取得了法语的第二学位，同时他还被选入斐陶斐荣誉学会（美国大学优等生之荣誉学会）。他在普渡大学计算机系教了三年的计算机课程。在这期间，他完成了他个人的第一本书《Understanding Computers》，这本书用理论结合实践的方式介绍计算机的方方面面。如今，尽管他继续工作在硅谷的软件业，但他仍然坚韧不拔地在追求一个更高的学位。\n除了计算机，Kyle多年来喜欢打网球、教网球。他还喜欢山地骑行、滑冰，偶尔也和朋友们一起参加高尔夫课程。另外，Kyle还喜欢各种形式的戏剧、美食，以及某些风格的音乐和艺术；他期望成为钢琴家和艺术家，但希望渺茫。他现在在Jeppesen的工作是从他1992年开始驾驶飞机之后找到的。现在，他是一个拥有美国联邦航空局颁发的商业飞行员执照的飞行员。","summary":"本书是数据结构和算法领域的经典之作，十余年来，畅销不衰！全书共分为三部分：第一部分首先介绍了数据结构和算法的概念，以及使用它们的原因和意义，然后讲解了数据结构和算法中最常用的技术——指针和递归，最后还介绍了算法的分析方法，旨在为读者学习这本书打下坚实的基础；第二部分对链表、栈、队列、集合、哈希表、堆、图等常用数据结构进行了深入阐述；第三部分对排序、搜索数值计算、数据压缩、数据加密、图算法、几何算法等经典算法进行了精辟的分析和讲解。\n本书的众多特色使得它在同类书中独树一帜：具体实现都采用正式的C语言代码而不是伪代码，在很多数据结构和算法的实现过程中，有大量细节问题是伪代码不能解决的；每一章都有精心组织的主题和应用；全部示例来自真实的应用，不只是一般的练习；对每种数据结构、算法和示例都进行了详细分析；每一章的末尾都会有一系列问题和对应的回答，旨在强调这一章的重要思想……\n本书中的代码尤为值得强调：所有实现都采用C语言编写，所有代码都优先用于教学目的，所有代码都在4种平台上经过完整测试，头文件记录了所有公共的接口，命名规则适用于全书所有的代码，所有的代码都包含大量注释……\n本书内容包括：\n· 数据结构和算法的概念，以及使用它们的原因和意义\n· 指针和递归\n· 算法分析\n· 常用数据结构：链表、栈、队列、集合、哈希表、树、堆、优先级队列以及图\n· 排序和搜索\n· 数值计算\n· 数据压缩\n· 数据加密\n· 图算法\n· 几何算法","price":"79.00元"},{"rating":{"max":10,"numRaters":266,"average":"9.4","min":0},"subtitle":"42 Specific Ways to Improve Your Use of C++11 and C++14","author":["Scott Meyers"],"pubdate":"2014-12","tags":[{"count":330,"name":"C++","title":"C++"},{"count":168,"name":"C++11","title":"C++11"},{"count":111,"name":"C\/C++","title":"C\/C++"},{"count":86,"name":"编程","title":"编程"},{"count":80,"name":"计算机","title":"计算机"},{"count":72,"name":"Programming","title":"Programming"},{"count":49,"name":"程序设计","title":"程序设计"},{"count":34,"name":"effective","title":"effective"}],"origin_title":"","image":"https://img9.doubanio.com\/view\/subject\/m\/public\/s27951196.jpg","binding":"Paperback","translator":[],"catalog":"","pages":"320","images":{"small":"https://img9.doubanio.com\/view\/subject\/s\/public\/s27951196.jpg","large":"https://img9.doubanio.com\/view\/subject\/l\/public\/s27951196.jpg","medium":"https://img9.doubanio.com\/view\/subject\/m\/public\/s27951196.jpg"},"alt":"https:\/\/book.douban.com\/subject\/25923597\/","id":"25923597","publisher":"O'Reilly Media","isbn10":"1491903996","isbn13":"9781491903995","title":"Effective Modern C++","url":"https:\/\/api.douban.com\/v2\/book\/25923597","alt_title":"","author_intro":"Scott Meyers is one of the world's foremost authorities on C++. He wrote the best-selling Effective C++ series (Effective C++, More Effective C++, and Effective STL); published and maintains the annotated training materials Overview of the New C++ (C++11\/14) and Effective C++ in an Embedded Environment; is Consulting Editor for the Effective Software Development Series, and, with Herb Sutter and Andrei Alexandrescu, is a principal in C++ and Beyond. He has a Ph.D in Computer Science from Brown University. He's currently working on a new book, Effective Modern C++, which he expects to publish this fall.","summary":"Learn how to program expertly with C++ with this practical book from Scott Meyers, one of the world's foremost authorities on this systems programming language. Scott Meyers takes some of the most difficult pieces of C++ code and unfurls them so that you can see how to manipulate your own project code. This is the first book to contain content written with the C++14 standard.\nTackle 42 separate C++ problems and solutions\nLearn critical techniques for success on topics from smart pointers to lambda expressions\nUnderstand key concepts by taking the C++ 98 standard to C++ 11 and then to C++ 14","price":"USD 49.99"},{"rating":{"max":10,"numRaters":625,"average":"9.1","min":0},"subtitle":"N．C. Wyeth 插图官方授权版本","author":["[美] 玛•金•罗琳斯"],"pubdate":"2016-6-1","tags":[{"count":198,"name":"自然","title":"自然"},{"count":183,"name":"美国文学","title":"美国文学"},{"count":183,"name":"外国文学","title":"外国文学"},{"count":146,"name":"玛•金•罗琳斯","title":"玛•金•罗琳斯"},{"count":136,"name":"美国","title":"美国"},{"count":135,"name":"成长","title":"成长"},{"count":129,"name":"我想读这本书","title":"我想读这本书"},{"count":128,"name":"小说","title":"小说"}],"origin_title":"The Yearling","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28748579.jpg","binding":"平装","translator":["梅静"],"catalog":"目录\n第一章 小水车\n第二章 乔迪的家\n第三章 飞来横祸\n第四章 猎熊\n第五章 草翅膀\n第六章 大快朵颐\n第七章 一桩好买卖\n第八章 意外收获\n第九章 灰岩坑\n第十章 夜晚的奇遇\n第十一章 猎鹿\n第十二章 仗义相助\n第十三章 告别奥利弗\n第十四章 危机\n第十五章 新伙伴\n第十六章 偷蜜和猎狐\n第十七章 痛失好友\n第十八章 怀念“草翅膀”\n第十九章 暴风雨\n第二十章 暴风雨后的森林\n第二十一章 瘟疫\n第二十二章 储粮\n第二十三章 狼群的夜袭\n第二十四章 猎狼\n第二十五章圣诞节前夕\n第二十六章 追捕“大笨脚”\n第二十七章 送别\n第二十八章 孤狼\n第二十九章 闯祸\n第三十章 爸爸病了\n第三十一章 无计可施\n第三十二章 再见，小鹿\n第三十三章 别了，童年","ebook_url":"https:\/\/read.douban.com\/ebook\/22165742\/","pages":"432","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s28748579.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s28748579.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28748579.jpg"},"alt":"https:\/\/book.douban.com\/subject\/26801361\/","id":"26801361","publisher":"云南人民出版社","isbn10":"7222145583","isbn13":"9787222145580","title":"鹿苑长春","url":"https:\/\/api.douban.com\/v2\/book\/26801361","alt_title":"The Yearling","author_intro":"【作者 】\n玛•金•罗琳斯\nMarjorie Kinnan Rawlings\n1896-1953\n美国作家  生于华盛顿， 毕业于威斯康星大学， 在纽约担任多年记者、编辑\n创建了佛罗里达边远林区的“地方文学”\n先后获得普利策奖、 欧·亨利奖、兰登书屋终身畅销奖\n创作的两部长篇小说《鹿苑长春》和《十字小溪》先后荣获普利策文学奖\n代表作《鹿苑长春》《十字小溪》《一位年轻姑娘》《南方月亮下》《金苹果》等\n【绘者】\nN.C.韦思\nNewell Convers Wyeth\n1882—1956\n美国现实主义绘画大师  一生创作近4000幅画作\n画作现收藏于布兰迪万河博物馆 、波特兰艺术博物馆和法恩斯沃斯艺术博物馆。1997年，他生活和工作的地方（宾夕法尼亚州查兹福德小镇墨菲路）被美国政府指定为国家历史地标之一。\n【译者】\n梅静\n北京大学外国语学院翻译硕士\n译有《柳林风声》《小鹿斑比》《小公主》《威士忌海滩》《孪生姐妹》《想飞的乔琪》《布谷鸟的呼唤》。","summary":"【“任何人遇到挫折的时候，都能够从这里得到新的勇气。”】\n【内容简介】\n《鹿苑长春》由美国作家玛·金·罗琳斯创作于1938年，根据佛罗里达林区一位老人的童年回忆创作改编，发行后登上美国畅销书榜首并持续140周，于次年获得普利策文学奖。至今，在美国累计阅读量达到5.5亿。至今，该小说被翻译成20种语言，在133个国家出版，受到不同地域和文化人们的喜爱。在1946年被米高梅公司拍摄成电影，获得奥斯卡最佳艺术指导奖和最佳摄影奖。\n故事讲述美国南北战争后佛罗里达垦荒区普通人的劳动、斗争和悲欢离合。主人公巴克斯特一家生活在佛罗里达岛地过着自给自足的农耕狩猎生活，所处的自然美景中是一幅生动绚丽的丛林画卷，该作品后被誉为描绘少年时代的经典童年诗歌。然而，它却是一本全年龄段读本，书中透出的森林清新气息和舒缓节奏，与当代都市生活迥然不同。其中有惊险的狩猎、奇妙的自然景观、悠然的乡村美景，还有风趣幽默的人物对话，以及充满泥土气息的方言。书中人们为了生存这一简单目的，持有着最质朴的勇气和信念。\n孩子们可以从书中读到激动人心的狩猎，看见原野林莽、飞鸟起落、狼踪熊迹、暴雨狂风，进入乔迪的世界，与他共度被爸爸精心呵护、无忧无虑的童年。成年人，尤其是经历过离合悲欢、人世艰难的人，都能从书中读出欢笑、甜蜜、惆怅和感伤。\n【编辑推荐】\n《鹿苑长春》是一部经典的动物文学与环境文学著作。\n故事发生在美国南北战争结束后的垦荒时代，讲述与父母生活在佛罗里达岛地的男孩乔迪与一岁小鹿间的故事。\n爸爸在牧师家庭长大，正直善良，从不说谎，因经历战争后，厌倦了与人相处的世俗，带着妻子奥拉远离城镇，选择佛罗里达的巴克斯特岛地，过着狩猎农耕的生活。家中的生计依赖于自然选择，时常受到岛地周围野兽的威胁，尤其是经常出没偷食家畜的棕熊“大笨脚”。\n因为自然环境的严酷，夫妻两人连续夭折了3个孩子，以至于乔迪诞生后，妈妈奥拉因为遭遇太多次失去，对儿子不抱有太多疼爱，也许是向现实的冷酷低头，看待事物抱有异常冷漠的清醒。爸爸彭尼从小在家中担起大梁，了解天真无邪的珍贵，反而给乔迪加倍的疼爱，试图延长乔迪无忧无虑的童年。在丛林里，有变幻的迷人风光，也有让人惊叹的动物奇观。乔迪一直喜欢听猎人讲在狩猎途中的奇遇，期待着自己与动物的亲近。\n他跟着爸爸狩猎，追踪“大笨脚”，爬在树上看鹿妈妈带着小鹿啃食树叶，与爸爸抓到罕见的白色浣熊、在克拉克莎草丛中钓鱼，遇到高鸣鹤跳沙龙舞；他跟着巴克.福利斯特在月光下的玉米地里猎狐，去松树干掏蜂蜜；与好友“草翅膀”喂养小浣熊、欧洲灰雀，一起看西班牙人后裔穿过古栈道，一起数天上米诺鱼般的星星……生活就像他给自己在灰岩坑水塘边造的小水车，随着时间的流水，悠然转动，奏出欢快的乐章，似乎没有停下来的理由。\n然而乔迪作为独子，在偏远岛地，一直是孤寂的。他希望能像爸爸彭尼一样拥有只对自己忠诚的宠物。因为口粮不足，妈妈却一直拒绝驯养动物。直到有一天，在乔迪跟随爸爸追踪走失家猪的途中，遭遇危机，也遇到了那头刚出生不久的小鹿……\n故事讲失去，也讲成长；讲孤独，也讲爱与宽容。每个人也许会从中找到真挚的共鸣，遗憾和怅惘，但更多的是，是勇气。\n【名人推荐】\n“谈到近人的作品，说「不朽」总彷佛还太早，然而《鹿苑长春》在近代文学上的地位已经奠定了。《鹿苑长春》里面出现的动物比人多──鹿、响尾蛇、八字脚的老熊、牛、马、猪──像一个动物园，但是里面的人物，尤其是那男孩子乔迪，是使人永远不能忘记的。\n那孩子失去了他最心爱的东西，使他受到很深的刺激，然而他从此就坚强起来，长大成人了。我们仔细回味，就可以觉得这不止于是一个孩子的故事，任何人遇到挫折的时候，都能够从这里得到新的勇气。\n这故事具有真正的悲剧的因素──无法避免，也不可挽回。书中对于儿童心理有非常深入的描写，可以帮助做父母的人了解自己的子女。写父爱也发掘到人性的深处。\n它是健康的，向上的，但也许它最动人的地方是与东方的心情特别接近的一种淡淡的哀愁。最后的两段更是充满了一种难堪的怅惘，我译到这里的时候，甚至于译完之后重抄一遍，抄到这里的时候，也都是像第一次读到一样地觉得非常感动，眼睛湿润起来。我相信许多读者一定也有同感。”\n——张爱玲\n【媒体推荐】\n\n在罗琳斯女士之前，还没有谁创造出如此栩栩如生且亲近读者的一系列形象，其亲密的感情感染人，不禁令人产生共鸣。\n——纽约时报\n“Never before has Mrs. Rawlings created a set of characters who are so close and real to the reader, whose intimate life one can share without the taint of unconscious patronage.\" (The New York Times)\n惊心动魄的探险和令人怅惘的人性元素……这是一部不愧于普利策奖桂冠的经典作品，故事质朴的语言和四季变化下的生态智慧，都给予这本书一种独特而难忘的气质。而画家N.C.韦思也以温暖、柔和的插图，恰到好处地捕捉到那个垦荒时代的粗莽和淳美。\n——亚马逊网站\n“Heart-stopping adventure and heart-wrenching human element…. This is a classic well worth its Pulitzer Prize. Earthy dialect and homespun wisdom season the story, giving it a unique and unforgettable flavor, and N.C. Wyeth's warm, soft illustrations capture an era of rough subsistence and sweet survival.”\n(Amazon.com)","ebook_price":"12.00","price":"48.00元"},{"rating":{"max":10,"numRaters":531,"average":"8.9","min":0},"subtitle":"使用Visual C++5.0 & MFC 4.2","author":["侯俊杰"],"pubdate":"2001-1","tags":[{"count":303,"name":"MFC","title":"MFC"},{"count":174,"name":"C++","title":"C++"},{"count":108,"name":"计算机","title":"计算机"},{"count":92,"name":"编程","title":"编程"},{"count":74,"name":"深入浅出MFC","title":"深入浅出MFC"},{"count":72,"name":"侯捷","title":"侯捷"},{"count":64,"name":"Windows","title":"Windows"},{"count":38,"name":"经典","title":"经典"}],"origin_title":"","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28952279.jpg","binding":"平装16开","translator":[],"catalog":"第一篇 勿在浮砂筑高台\n第一章 Win32 程序基本概念\n第二章 C++的重要性质\n第三章 MFC六大关键技术之仿真\n第二篇 欲善工事先利其器\n第四章 Visual C++ 集成开发环境\n第三篇 浅出MFC程序设计\n第五章 总观Application Framework\n第六章 MFC程序的生死因果\n第七章 简单而完整：MFC骨干程序\n第四篇 深入MFC 程序设计\n第八章 Document-View深入探讨\n第九章 消息映射与命令传递\n第十章 MFC与对话框\n第十一章 Vies功能的加强与重绘效率的提高\n第十二章 打印与预览\n第十三章 多重文件与多重视图\n第十四章 MFC 多线程程序设计\n第十五章 站在众人的肩膀――使用Components & ActiveX Controls\n第五篇 附录","pages":"701","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s28952279.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s28952279.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s28952279.jpg"},"alt":"https:\/\/book.douban.com\/subject\/1094852\/","id":"1094852","publisher":"华中科技大学出版社","isbn10":"7900614931","isbn13":"9787900614933","title":"深入浅出MFC （第二版）","url":"https:\/\/api.douban.com\/v2\/book\/1094852","alt_title":"","author_intro":"侯俊杰（1961年9月28日－），笔名侯捷，台湾知名电脑技术专栏作家，致力于电脑技术之扎根工作，文章兼具科技之长与灵性之美，有读者的评语是“比作家更工程师，比工程师更作家”。大同国中、师大附中、交通大学土木系毕业、清华大学动力机械研究所硕士。曾任职工研院机械所与电通所，曾在元智大学授课，近年来多从事两岸学术交流工作。他的妻子美静是一名钢琴师，侯俊杰说他自己“嗜咖啡。妻严不能常得。”","summary":"《深入浅出MFC》分为四大篇。第一篇提出学习MFC程序设计之前的必要基础，包括Widnows程序的基本观念以及C++的高阶议题。“学前基础”是相当主观的认定，但作者是甚于自己的学习经验以及教学经验，其挑选应该颇具说服力。第二篇介绍Visual C++整合环境开发工具。此篇只是提纲挈领，并不企图取代Visual C++使用手册；然而对于软件使用的老手，此篇或已足以帮助掌握Visual C++整合环境。工具的使用虽然谈不上学问，但在视觉化软件开发过程中扮演极重角色。第三篇介绍application framework的观念，以及MFC骨干程序，所谓骨干程序，是指Visual C++的工具AppWizard所产生出来的程序码。当然，AppWizard会根据使用者的选项做出不同的程序码，作者据以解说的是大众化选项下的产品。第四篇以微软公司附于Visual C++光碟片上的一个范例程序Scribble为主轴，一步一步加上新的功能；并在其间深入介绍Runtime Type Information（RTTI）、Dynamic Creation、Persistence（Serialization）、Message Mapping、Command Routing等核心技术。这些技术正是其他专著最缺乏的部分。此篇的最后数章则脱离Scribble程序，另成一格。\n这本书配有一片光盘，书中所有原始码与可执行文件都在其中。","price":"80.00元"},{"rating":{"max":10,"numRaters":457,"average":"8.8","min":0},"subtitle":"使用muduo C++网络库","author":["陈硕"],"pubdate":"2013-1-15","tags":[{"count":607,"name":"网络编程","title":"网络编程"},{"count":543,"name":"Linux","title":"Linux"},{"count":541,"name":"C++","title":"C++"},{"count":454,"name":"多线程","title":"多线程"},{"count":155,"name":"计算机","title":"计算机"},{"count":143,"name":"编程","title":"编程"},{"count":110,"name":"C\/C++","title":"C\/C++"},{"count":87,"name":"Networks","title":"Networks"}],"origin_title":"","image":"https://img1.doubanio.com\/view\/subject\/m\/public\/s24522799.jpg","binding":"平装","translator":[],"catalog":"第1 部分C++ 多线程系统编程1\n第1章 线程安全的对象生命期管理3\n1.1 当析构函数遇到多线程. . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n1.1.1 线程安全的定义. . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\n1.1.2 MutexLock 与MutexLockGuard . . . . . . . . . . . . . . . . . . . . 4\n1.1.3 一个线程安全的Counter 示例. . . . . . . . . . . . . . . . . . . . 4\n1.2 对象的创建很简单. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n1.3 销毁太难. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n1.3.1 mutex 不是办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n1.3.2 作为数据成员的mutex 不能保护析构. . . . . . . . . . . . . . . 8\n1.4 线程安全的Observer 有多难. . . . . . . . . . . . . . . . . . . . . . . . . 8\n1.5 原始指针有何不妥. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n1.6 神器shared_ptr\/weak_ptr . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n1.7 插曲：系统地避免各种指针错误. . . . . . . . . . . . . . . . . . . . . . . 14\n1.8 应用到Observer 上. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\n1.9 再论shared_ptr 的线程安全. . . . . . . . . . . . . . . . . . . . . . . . . 17\n1.10 shared_ptr 技术与陷阱. . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n1.11 对象池. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21\n1.11.1 enable_shared_from_this . . . . . . . . . . . . . . . . . . . . . . 23\n1.11.2 弱回调. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\n1.12 替代方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n1.13 心得与小结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n1.14 Observer 之谬. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\n第2章 线程同步精要31\n2.1 互斥器（mutex） . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32\n2.1.1 只使用非递归的mutex . . . . . . . . . . . . . . . . . . . . . . . . 33\n2.1.2 死锁. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\n2.2 条件变量（condition variable） . . . . . . . . . . . . . . . . . . . . . . . 40\n2.3 不要用读写锁和信号量. . . . . . . . . . . . . . . . . . . . . . . . . . . . 43\n2.4 封装MutexLock、MutexLockGuard、Condition . . . . . . . . . . . . . . 44\n2.5 线程安全的Singleton 实现. . . . . . . . . . . . . . . . . . . . . . . . . . 48\n2.6 sleep(3) 不是同步原语. . . . . . . . . . . . . . . . . . . . . . . . . . . . 50\n2.7 归纳与总结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\n2.8 借shared_ptr 实现copy-on-write . . . . . . . . . . . . . . . . . . . . . . 52\n第3章 多线程服务器的适用场合与常用编程模型59\n3.1 进程与线程. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59\n3.2 单线程服务器的常用编程模型. . . . . . . . . . . . . . . . . . . . . . . . 61\n3.3 多线程服务器的常用编程模型. . . . . . . . . . . . . . . . . . . . . . . . 62\n3.3.1 one loop per thread . . . . . . . . . . . . . . . . . . . . . . . . . . 62\n3.3.2 线程池. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63\n3.3.3 推荐模式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64\n3.4 进程间通信只用TCP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65\n3.5 多线程服务器的适用场合. . . . . . . . . . . . . . . . . . . . . . . . . . . 67\n3.5.1 必须用单线程的场合. . . . . . . . . . . . . . . . . . . . . . . . . 69\n3.5.2 单线程程序的优缺点. . . . . . . . . . . . . . . . . . . . . . . . . 70\n3.5.3 适用多线程程序的场景. . . . . . . . . . . . . . . . . . . . . . . . 71\n3.6 “多线程服务器的适用场合”例释与答疑. . . . . . . . . . . . . . . . . . 74\n第4章 C++ 多线程系统编程精要83\n4.1 基本线程原语的选用. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84\n4.2 C\/C++ 系统库的线程安全性. . . . . . . . . . . . . . . . . . . . . . . . . 85\n4.3 Linux 上的线程标识. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89\n4.4 线程的创建与销毁的守则. . . . . . . . . . . . . . . . . . . . . . . . . . . 91\n4.4.1 pthread_cancel 与C++ . . . . . . . . . . . . . . . . . . . . . . . 94\n4.4.2 exit(3) 在C++ 中不是线程安全的. . . . . . . . . . . . . . . . . 94\n4.5 善用__thread 关键字. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96\n4.6 多线程与IO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98\n4.7 用RAII 包装文件描述符. . . . . . . . . . . . . . . . . . . . . . . . . . . 99\n4.8 RAII 与fork() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101\n4.9 多线程与fork() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102\n4.10 多线程与signal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103\n4.11 Linux 新增系统调用的启示. . . . . . . . . . . . . . . . . . . . . . . . . . 105\n第5章 高效的多线程日志107\n5.1 功能需求. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109\n5.2 性能需求. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112\n5.3 多线程异步日志. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114\n5.4 其他方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120\n第2部分 muduo 网络库123\n第6章 muduo 网络库简介125\n6.1 由来. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125\n6.2 安装. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127\n6.3 目录结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129\n6.3.1 代码结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131\n6.3.2 例子. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134\n6.3.3 线程模型. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135\n6.4 使用教程. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136\n6.4.1 TCP 网络编程本质论. . . . . . . . . . . . . . . . . . . . . . . . . 136\n6.4.2 echo 服务的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . 138\n6.4.3 七步实现finger 服务. . . . . . . . . . . . . . . . . . . . . . . . . 140\n6.5 性能评测. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144\n6.5.1 muduo 与Boost.Asio、libevent2 的吞吐量对比. . . . . . . . . . 145\n6.5.2 击鼓传花：对比muduo 与libevent2 的事件处理效率. . . . . . 148\n6.5.3 muduo 与Nginx 的吞吐量对比. . . . . . . . . . . . . . . . . . . 153\n6.5.4 muduo 与ZeroMQ 的延迟对比. . . . . . . . . . . . . . . . . . . 156\n6.6 详解muduo 多线程模型. . . . . . . . . . . . . . . . . . . . . . . . . . . 157\n6.6.1 数独求解服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . . 157\n6.6.2 常见的并发网络服务程序设计方案. . . . . . . . . . . . . . . . . 160\n第7章 muduo 编程示例177\n7.1 五个简单TCP 示例. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178\n7.2 文件传输. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185\n7.3 Boost.Asio 的聊天服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . 194\n7.3.1 TCP 分包. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194\n7.3.2 消息格式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195\n7.3.3 编解码器LengthHeaderCodec . . . . . . . . . . . . . . . . . . . . 197\n7.3.4 服务端的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198\n7.3.5 客户端的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200\n7.4 muduo Buffer 类的设计与使用. . . . . . . . . . . . . . . . . . . . . . . 204\n7.4.1 muduo 的IO 模型. . . . . . . . . . . . . . . . . . . . . . . . . . 204\n7.4.2 为什么non-blocking 网络编程中应用层buffer 是必需的. . . . 205\n7.4.3 Buffer 的功能需求. . . . . . . . . . . . . . . . . . . . . . . . . . 207\n7.4.4 Buffer 的数据结构. . . . . . . . . . . . . . . . . . . . . . . . . . 209\n7.4.5 Buffer 的操作. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211\n7.4.6 其他设计方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217\n7.4.7 性能是不是问题. . . . . . . . . . . . . . . . . . . . . . . . . . . . 218\n7.5 一种自动反射消息类型的Google Protobuf 网络传输方案. . . . . . . . 220\n7.5.1 网络编程中使用Protobuf 的两个先决条件. . . . . . . . . . . . . 220\n7.5.2 根据type name 反射自动创建Message 对象. . . . . . . . . . . . 221\n7.5.3 Protobuf 传输格式. . . . . . . . . . . . . . . . . . . . . . . . . . 226\n7.6 在muduo 中实现Protobuf 编解码器与消息分发器. . . . . . . . . . . . 228\n7.6.1 什么是编解码器（codec） . . . . . . . . . . . . . . . . . . . . . . 229\n7.6.2 实现ProtobufCodec . . . . . . . . . . . . . . . . . . . . . . . . . 232\n7.6.3 消息分发器（dispatcher）有什么用. . . . . . . . . . . . . . . . 232\n7.6.4 ProtobufCodec 与ProtobufDispatcher 的综合运用. . . . . . . 233\n7.6.5 ProtobufDispatcher 的两种实现. . . . . . . . . . . . . . . . . . 234\n7.6.6 ProtobufCodec 和ProtobufDispatcher 有何意义. . . . . . . . . 236\n7.7 限制服务器的最大并发连接数. . . . . . . . . . . . . . . . . . . . . . . . 237\n7.7.1 为什么要限制并发连接数. . . . . . . . . . . . . . . . . . . . . . 237\n7.7.2 在muduo 中限制并发连接数. . . . . . . . . . . . . . . . . . . . 238\n7.8 定时器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240\n7.8.1 程序中的时间. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240\n7.8.2 Linux 时间函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . 241\n7.8.3 muduo 的定时器接口. . . . . . . . . . . . . . . . . . . . . . . . . 242\n7.8.4 Boost.Asio Timer 示例. . . . . . . . . . . . . . . . . . . . . . . . 243\n7.8.5 Java Netty 示例. . . . . . . . . . . . . . . . . . . . . . . . . . . . 245\n7.9 测量两台机器的网络延迟和时间差. . . . . . . . . . . . . . . . . . . . . 248\n7.10 用timing wheel 踢掉空闲连接. . . . . . . . . . . . . . . . . . . . . . . . 250\n7.10.1 timing wheel 原理. . . . . . . . . . . . . . . . . . . . . . . . . . 251\n7.10.2 代码实现与改进. . . . . . . . . . . . . . . . . . . . . . . . . . . . 254\n7.11 简单的消息广播服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257\n7.12 “串并转换”连接服务器及其自动化测试. . . . . . . . . . . . . . . . . . 260\n7.13 socks4a 代理服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264\n7.13.1 TCP 中继器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264\n7.13.2 socks4a 代理服务器. . . . . . . . . . . . . . . . . . . . . . . . . . 267\n7.13.3 N : 1 与1 : N 连接转发. . . . . . . . . . . . . . . . . . . . . . . . 267\n7.14 短址服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267\n7.15 与其他库集成. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268\n7.15.1 UDNS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270\n7.15.2 c-ares DNS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272\n7.15.3 curl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273\n7.15.4 更多. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275\n第8章 muduo 网络库设计与实现277\n8.0 什么都不做的EventLoop . . . . . . . . . . . . . . . . . . . . . . . . . . . 277\n8.1 Reactor 的关键结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280\n8.1.1 Channel class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280\n8.1.2 Poller class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283\n8.1.3 EventLoop 的改动. . . . . . . . . . . . . . . . . . . . . . . . . . . 287\n8.2 TimerQueue 定时器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290\n8.2.1 TimerQueue class . . . . . . . . . . . . . . . . . . . . . . . . . . . 290\n8.2.2 EventLoop 的改动. . . . . . . . . . . . . . . . . . . . . . . . . . . 292\n8.3 EventLoop::runInLoop() 函数. . . . . . . . . . . . . . . . . . . . . . . . 293\n8.3.1 提高TimerQueue 的线程安全性. . . . . . . . . . . . . . . . . . . 296\n8.3.2 EventLoopThread class . . . . . . . . . . . . . . . . . . . . . . . . 297\n8.4 实现TCP 网络库. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299\n8.5 TcpServer 接受新连接. . . . . . . . . . . . . . . . . . . . . . . . . . . . 303\n8.5.1 TcpServer class . . . . . . . . . . . . . . . . . . . . . . . . . . . . 304\n8.5.2 TcpConnection class . . . . . . . . . . . . . . . . . . . . . . . . . 305\n8.6 TcpConnection 断开连接. . . . . . . . . . . . . . . . . . . . . . . . . . . 308\n8.7 Buffer 读取数据. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 313\n8.7.1 TcpConnection 使用Buffer 作为输入缓冲. . . . . . . . . . . . . 314\n8.7.2 Buffer::readFd() . . . . . . . . . . . . . . . . . . . . . . . . . . 315\n8.8 TcpConnection 发送数据. . . . . . . . . . . . . . . . . . . . . . . . . . . 316\n8.9 完善TcpConnection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 320\n8.9.1 SIGPIPE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321\n8.9.2 TCP No Delay 和TCP keepalive . . . . . . . . . . . . . . . . . . 321\n8.9.3 WriteCompleteCallback 和HighWaterMarkCallback . . . . . . . 322\n8.10 多线程TcpServer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 324\n8.11 Connector . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327\n8.12 TcpClient . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 332\n8.13 epoll . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333\n8.14 测试程序一览. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 336\n第3部分 工程实践经验谈337\n第9章 分布式系统工程实践339\n9.1 我们在技术浪潮中的位置. . . . . . . . . . . . . . . . . . . . . . . . . . . 341\n9.1.1 分布式系统的本质困难. . . . . . . . . . . . . . . . . . . . . . . . 343\n9.1.2 分布式系统是个险恶的问题. . . . . . . . . . . . . . . . . . . . . 344\n9.2 分布式系统的可靠性浅说. . . . . . . . . . . . . . . . . . . . . . . . . . . 349\n9.2.1 分布式系统的软件不要求7  24 可靠. . . . . . . . . . . . . . . . 352\n9.2.2 “能随时重启进程”作为程序设计目标. . . . . . . . . . . . . . . 354\n9.3 分布式系统中心跳协议的设计. . . . . . . . . . . . . . . . . . . . . . . . 356\n9.4 分布式系统中的进程标识. . . . . . . . . . . . . . . . . . . . . . . . . . . 360\n9.4.1 错误做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361\n9.4.2 正确做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 362\n9.4.3 TCP 协议的启示. . . . . . . . . . . . . . . . . . . . . . . . . . . . 363\n9.5 构建易于维护的分布式程序. . . . . . . . . . . . . . . . . . . . . . . . . 364\n9.6 为系统演化做准备. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 367\n9.6.1 可扩展的消息格式. . . . . . . . . . . . . . . . . . . . . . . . . . 368\n9.6.2 反面教材：ICE 的消息打包格式. . . . . . . . . . . . . . . . . . . 369\n9.7 分布式程序的自动化回归测试. . . . . . . . . . . . . . . . . . . . . . . . 370\n9.7.1 单元测试的能与不能. . . . . . . . . . . . . . . . . . . . . . . . . 370\n9.7.2 分布式系统测试的要点. . . . . . . . . . . . . . . . . . . . . . . . 373\n9.7.3 分布式系统的抽象观点. . . . . . . . . . . . . . . . . . . . . . . . 374\n9.7.4 一种自动化的回归测试方案. . . . . . . . . . . . . . . . . . . . . 375\n9.7.5 其他用处. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 379\n9.8 分布式系统部署、监控与进程管理的几重境界. . . . . . . . . . . . . . . 380\n9.8.1 境界1：全手工操作. . . . . . . . . . . . . . . . . . . . . . . . . 382\n9.8.2 境界2：使用零散的自动化脚本和第三方组件. . . . . . . . . . . 383\n9.8.3 境界3：自制机群管理系统，集中化配置. . . . . . . . . . . . . 386\n9.8.4 境界4：机群管理与naming service 结合. . . . . . . . . . . . . 389\n第10章 C++ 编译链接模型精要391\n10.1 C 语言的编译模型及其成因. . . . . . . . . . . . . . . . . . . . . . . . . 394\n10.1.1 为什么C 语言需要预处理. . . . . . . . . . . . . . . . . . . . . . 395\n10.1.2 C 语言的编译模型. . . . . . . . . . . . . . . . . . . . . . . . . . . 398\n10.2 C++ 的编译模型. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399\n10.2.1 单遍编译. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399\n10.2.2 前向声明. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 402\n10.3 C++ 链接（linking） . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 404\n10.3.1 函数重载. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 406\n10.3.2 inline 函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 407\n10.3.3 模板. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 409\n10.3.4 虚函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 414\n10.4 工程项目中头文件的使用规则. . . . . . . . . . . . . . . . . . . . . . . . 415\n10.4.1 头文件的害处. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 416\n10.4.2 头文件的使用规则. . . . . . . . . . . . . . . . . . . . . . . . . . 417\n10.5 工程项目中库文件的组织原则. . . . . . . . . . . . . . . . . . . . . . . . 418\n10.5.1 动态库是有害的. . . . . . . . . . . . . . . . . . . . . . . . . . . . 423\n10.5.2 静态库也好不到哪儿去. . . . . . . . . . . . . . . . . . . . . . . . 424\n10.5.3 源码编译是王道. . . . . . . . . . . . . . . . . . . . . . . . . . . . 428\n第11章 反思C++ 面向对象与虚函数429\n11.1 朴实的C++ 设计. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 429\n11.2 程序库的二进制兼容性. . . . . . . . . . . . . . . . . . . . . . . . . . . . 431\n11.2.1 什么是二进制兼容性. . . . . . . . . . . . . . . . . . . . . . . . . 432\n11.2.2 有哪些情况会破坏库的ABI . . . . . . . . . . . . . . . . . . . . . 433\n11.2.3 哪些做法多半是安全的. . . . . . . . . . . . . . . . . . . . . . . . 435\n11.2.4 反面教材：COM . . . . . . . . . . . . . . . . . . . . . . . . . . . 435\n11.2.5 解决办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 436\n11.3 避免使用虚函数作为库的接口. . . . . . . . . . . . . . . . . . . . . . . . 436\n11.3.1 C++ 程序库的作者的生存环境. . . . . . . . . . . . . . . . . . . . 437\n11.3.2 虚函数作为库的接口的两大用途. . . . . . . . . . . . . . . . . . 438\n11.3.3 虚函数作为接口的弊端. . . . . . . . . . . . . . . . . . . . . . . . 439\n11.3.4 假如Linux 系统调用以COM 接口方式实现. . . . . . . . . . . . 442\n11.3.5 Java 是如何应对的. . . . . . . . . . . . . . . . . . . . . . . . . . 443\n11.4 动态库接口的推荐做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . 443\n11.5 以boost::function 和boost::bind 取代虚函数. . . . . . . . . . . . . 447\n11.5.1 基本用途. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 450\n11.5.2 对程序库的影响. . . . . . . . . . . . . . . . . . . . . . . . . . . . 451\n11.5.3 对面向对象程序设计的影响. . . . . . . . . . . . . . . . . . . . . 453\n11.6 iostream 的用途与局限. . . . . . . . . . . . . . . . . . . . . . . . . . . . 457\n11.6.1 stdio 格式化输入输出的缺点. . . . . . . . . . . . . . . . . . . . . 457\n11.6.2 iostream 的设计初衷. . . . . . . . . . . . . . . . . . . . . . . . . 461\n11.6.3 iostream 与标准库其他组件的交互. . . . . . . . . . . . . . . . . 463\n11.6.4 iostream 在使用方面的缺点. . . . . . . . . . . . . . . . . . . . . 464\n11.6.5 iostream 在设计方面的缺点. . . . . . . . . . . . . . . . . . . . . 468\n11.6.6 一个300 行的memory buffer output stream . . . . . . . . . . . 476\n11.6.7 现实的C++ 程序如何做文件IO . . . . . . . . . . . . . . . . . . . 480\n11.7 值语义与数据抽象. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482\n11.7.1 什么是值语义. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482\n11.7.2 值语义与生命期. . . . . . . . . . . . . . . . . . . . . . . . . . . . 483\n11.7.3 值语义与标准库. . . . . . . . . . . . . . . . . . . . . . . . . . . . 488\n11.7.4 值语义与C++ 语言. . . . . . . . . . . . . . . . . . . . . . . . . . 488\n11.7.5 什么是数据抽象. . . . . . . . . . . . . . . . . . . . . . . . . . . . 490\n11.7.6 数据抽象所需的语言设施. . . . . . . . . . . . . . . . . . . . . . 493\n11.7.7 数据抽象的例子. . . . . . . . . . . . . . . . . . . . . . . . . . . . 495\n第12章 C++ 经验谈501\n12.1 用异或来交换变量是错误的. . . . . . . . . . . . . . . . . . . . . . . . . 501\n12.1.1 编译器会分别生成什么代码. . . . . . . . . . . . . . . . . . . . . 503\n12.1.2 为什么短的代码不一定快. . . . . . . . . . . . . . . . . . . . . . 505\n12.2 不要重载全局::operator new() . . . . . . . . . . . . . . . . . . . . . . 507\n12.2.1 内存管理的基本要求. . . . . . . . . . . . . . . . . . . . . . . . . 507\n12.2.2 重载::operator new() 的理由. . . . . . . . . . . . . . . . . . . 508\n12.2.3 ::operator new() 的两种重载方式. . . . . . . . . . . . . . . . . 508\n12.2.4 现实的开发环境. . . . . . . . . . . . . . . . . . . . . . . . . . . . 509\n12.2.5 重载::operator new() 的困境. . . . . . . . . . . . . . . . . . . 510\n12.2.6 解决办法：替换malloc() . . . . . . . . . . . . . . . . . . . . . . 512\n12.2.7 为单独的class 重载::operator new() 有问题吗. . . . . . . . . 513\n12.2.8 有必要自行定制内存分配器吗. . . . . . . . . . . . . . . . . . . . 513\n12.3 带符号整数的除法与余数. . . . . . . . . . . . . . . . . . . . . . . . . . . 514\n12.3.1 语言标准怎么说. . . . . . . . . . . . . . . . . . . . . . . . . . . . 515\n12.3.2 C\/C++ 编译器的表现. . . . . . . . . . . . . . . . . . . . . . . . . 516\n12.3.3 其他语言的规定. . . . . . . . . . . . . . . . . . . . . . . . . . . . 516\n12.3.4 脚本语言解释器代码. . . . . . . . . . . . . . . . . . . . . . . . . 517\n12.3.5 硬件实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521\n12.4 在单元测试中mock 系统调用. . . . . . . . . . . . . . . . . . . . . . . . 522\n12.4.1 系统函数的依赖注入. . . . . . . . . . . . . . . . . . . . . . . . . 522\n12.4.2 链接期垫片（link seam） . . . . . . . . . . . . . . . . . . . . . . 524\n12.5 慎用匿名namespace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 526\n12.5.1 C 语言的static 关键字的两种用法. . . . . . . . . . . . . . . . . 526\n12.5.2 C++ 语言的static 关键字的四种用法. . . . . . . . . . . . . . . . 526\n12.5.3 匿名namespace 的不利之处. . . . . . . . . . . . . . . . . . . . . 527\n12.5.4 替代办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 529\n12.6 采用有利于版本管理的代码格式. . . . . . . . . . . . . . . . . . . . . . . 529\n12.6.1 对diff 友好的代码格式. . . . . . . . . . . . . . . . . . . . . . . . 530\n12.6.2 对grep 友好的代码风格. . . . . . . . . . . . . . . . . . . . . . . 537\n12.6.3 一切为了效率. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 538\n12.7 再探std::string . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539\n12.7.1 直接拷贝（eager copy） . . . . . . . . . . . . . . . . . . . . . . . 540\n12.7.2 写时复制（copy-on-write） . . . . . . . . . . . . . . . . . . . . . 542\n12.7.3 短字符串优化（SSO） . . . . . . . . . . . . . . . . . . . . . . . . 543\n12.8 用STL algorithm 轻松解决几道算法面试题. . . . . . . . . . . . . . . . 546\n12.8.1 用next_permutation() 生成排列与组合. . . . . . . . . . . . . . 546\n12.8.2 用unique() 去除连续重复空白. . . . . . . . . . . . . . . . . . . 548\n12.8.3 用{make,push,pop}_heap() 实现多路归并. . . . . . . . . . . . 549\n12.8.4 用partition() 实现“重排数组，让奇数位于偶数前面” . . . . 553\n12.8.5 用lower_bound() 查找IP 地址所属的城市. . . . . . . . . . . . . 554\n第4 部分附录559\n附录A 谈一谈网络编程学习经验561\n附录B 从《C++ Primer（第4 版）》入手学习C++ 579\n附录C 关于Boost 的看法591\n附录D 关于TCP 并发连接的几个思考题与试验593\n参考文献599","pages":"610","images":{"small":"https://img1.doubanio.com\/view\/subject\/s\/public\/s24522799.jpg","large":"https://img1.doubanio.com\/view\/subject\/l\/public\/s24522799.jpg","medium":"https://img1.doubanio.com\/view\/subject\/m\/public\/s24522799.jpg"},"alt":"https:\/\/book.douban.com\/subject\/20471211\/","id":"20471211","publisher":"电子工业出版社","isbn10":"7121192829","isbn13":"9787121192821","title":"Linux多线程服务端编程","url":"https:\/\/api.douban.com\/v2\/book\/20471211","alt_title":"","author_intro":"陈硕，北京师范大学硕士，擅长C++ 多线程网络编程和实时分布式系统架构。曾在摩根士丹利IT 部门工作5 年，从事实时外汇交易系统开发。现在在美国加州硅谷某互联网大公司工作，从事大规模分布式系统的可靠性工程。编写了开源C++ 网络库muduo，参与翻译了《代码大全（ 第2 版）》和《C++ 编程规范（繁体版）》，整理了《C++ Primer （第4 版）（评注版）》，并曾多次在各地技术大会演讲。","summary":"本书主要讲述采用现代C++ 在x86-64 Linux 上编写多线程TCP 网络服务程序的主流常规技术，重点讲解一种适应性较强的多线程服务器的编程模型，即one loop per thread。这是在Linux 下以native 语言编写用户态高性能网络程序最成熟的模式，掌握之后可顺利地开发各类常见的服务端网络应用程序。本书以muduo 网络库为例，讲解这种编程模型的使用方法及注意事项。\n本书的宗旨是贵精不贵多。掌握两种基本的同步原语就可以满足各种多线程同步的功能需求，还能写出更易用的同步设施。掌握一种进程间通信方式和一种多线程网络编程模型就足以应对日常开发任务，编写运行于公司内网环境的分布式服务统。","price":"89.00元"}]}
