>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业IT架构转型之道：阿里巴巴中台战略思想与架构实战
序言一
序言二
前言
第一部分 引  子
第1章 阿里巴巴集团中台战略引发的思考 2
1.1 阿里巴巴共享业务事业部的发展史 4
1.2 企业信息中心发展的症结 8
第2章 构建业务中台的基础——共享服务体系 15
2.1 回归SOA的本质——服务重用 15
2.2 服务需要不断的业务滋养 17
2.3 共享服务体系是培育业务创新的土壤 19
2.4 赋予业务快速创新和试错能力 21
2.5 为真正发挥大数据威力做好储备 25
2.6 改变组织阵型会带来组织效能的提升 28
第二部分 共享服务体系搭建
第3章 分布式服务框架的选择 35
3.1 淘宝平台“服务化”历程 35
3.2 “中心化”与“去中心化”服务框架的对比 39
3.3 阿里巴巴分布式服务框架HSF 45
3.4 关于微服务 53
第4章 共享服务中心建设原则 57
4.1 淘宝的共享服务中心概貌 58
4.2 什么是服务中心 61
4.3 服务中心的划分原则 63
第5章 数据拆分实现数据库能力线性扩展 67
5.1 数据库瓶颈阻碍业务的持续发展 67
5.2 数据库分库分表的实践 69
第6章 异步化与缓存原则 89
6.1 业务流程异步化 90
6.2 数据库事务异步化 91
6.3 事务与柔性事务 94
6.4 大促秒杀活动催生缓存技术的高度使用 124
第7章 打造数字化运营能力 132
7.1 业务服务化带来的问题 132
7.2 鹰眼平台的架构 137
7.3 埋点和输出日志 138
7.4 海量日志分布式处理平台 141
7.5 日志收集控制 143
7.6 典型业务场景 144
第8章 打造平台稳定性能力 157
8.1 限流和降级 158
8.2 流量调度 165
8.3 业务开关 171
8.4 容量压测及评估规划 173
8.5 全链路压测平台 176
8.6 业务一致性平台 179
第9章 共享服务中心对内和对外的协作共享 184
9.1 服务化建设野蛮发展带来的问题 184
9.2 共享服务平台的建设思路 188
9.3 共享服务平台与业务方协作 194
9.4 业务中台与前端应用协作 196
9.5 业务中台绩效考核 198
9.6 能力开放是构建生态的基础 200
第三部分 阿里巴巴能力输出与案例
第10章 大型央企互联网转型 207
10.1 项目背景 207
10.2 项目实施 208
10.3 客户收益 210
10.4 笔者感想 211
10.5 项目后记 212
第11章 时尚行业品牌公司互联网转型 216
11.1 项目背景 216
11.2 供应链的改造 219
11.3 基于SCRM的全渠道整合营销 225
11.4 小结 229
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业IT架构转型之道：阿里巴巴中台战略思想与架构实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大规模分布式存储系统
前言
第1章　概述
1.1　分布式存储概念
1.2　分布式存储分类
第一篇　基础篇
第2章　单机存储系统
2.1　硬件基础
2.1.1　CPU架构
2.1.2　IO总线
2.1.3　网络拓扑
2.1.4　性能参数
2.1.5　存储层次架构
2.2　单机存储引擎
2.2.1　哈希存储引擎
2.2.2　B树存储引擎
2.2.3　LSM树存储引擎
2.3　数据模型
2.3.1　文件模型
2.3.2　关系模型
2.3.3　键值模型
2.3.4　SQL与NoSQL
2.4　事务与并发控制
2.4.1　事务
2.4.2　并发控制
2.5　故障恢复
2.5.1　操作日志
2.5.2　重做日志
2.5.3　优化手段
2.6　数据压缩
2.6.1　压缩算法
2.6.2　列式存储
第3章　分布式系统
3.1　基本概念
3.1.1　异常
3.1.2　一致性
3.1.3　衡量指标
3.2　性能分析
3.3　数据分布
3.3.1　哈希分布
3.3.2　顺序分布
3.3.3　负载均衡
3.4　复制
3.4.1　复制的概述
3.4.2　一致性与可用性
3.5　容错
3.5.1　常见故障
3.5.2　故障检测
3.5.3　故障恢复
3.6　可扩展性
3.6.1　总控节点
3.6.2　数据库扩容
3.6.3　异构系统
3.7　分布式协议
3.7.1　两阶段提交协议
3.7.2　Paxos协议
3.7.3　Paxos与2PC
3.8　跨机房部署
第二篇　范型篇
第4章　分布式文件系统
4.1　Google文件系统
4.1.1　系统架构
4.1.2　关键问题
4.1.3　Master设计
4.1.4　ChunkServer设计
4.1.5　讨论
4.2　Taobao File System
4.2.1　系统架构
4.2.2　讨论
4.3　Facebook Haystack
4.3.1　系统架构
4.3.2　讨论
4.4　内容分发网络
4.4.1　CDN架构
4.4.2　讨论
第5章　分布式键值系统
5.1　Amazon Dynamo
5.1.1　数据分布
5.1.2　一致性与复制
5.1.3　容错
5.1.4　负载均衡
5.1.5　读写流程
5.1.6　单机实现
5.1.7　讨论
5.2　淘宝Tair
5.2.1　系统架构
5.2.2　关键问题
5.2.3　讨论
第6章　分布式表格系统
6.1　Google Bigtable
6.1.1　架构
6.1.2　数据分布
6.1.3　复制与一致性
6.1.4　容错
6.1.5　负载均衡
6.1.6　分裂与合并
6.1.7　单机存储
6.1.8　垃圾回收
6.1.9　讨论
6.2　Google Megastore
6.2.1　系统架构
6.2.2　实体组
6.2.3　并发控制
6.2.4　复制
6.2.5　索引
6.2.6　协调者
6.2.7　读取流程
6.2.8　写入流程
6.2.9　讨论
6.3　Windows Azure Storage
6.3.1　整体架构
6.3.2　文件流层
6.3.3　分区层
6.3.4　讨论
第7章　分布式数据库
7.1　数据库中间层
7.1.1　架构
7.1.2　扩容
7.1.3　讨论
7.2　Microsoft SQL Azure
7.2.1　数据模型
7.2.2　架构
7.2.3　复制与一致性
7.2.4　容错
7.2.5　负载均衡
7.2.6　多租户
7.2.7　讨论
7.3　Google Spanner
7.3.1　数据模型
7.3.2　架构
7.3.3　复制与一致性
7.3.4　TrueTime
7.3.5　并发控制
7.3.6　数据迁移
7.3.7　讨论
第三篇　实践篇
第8章　OceanBase架构初探
8.1　背景简介
8.2　设计思路
8.3　系统架构
8.3.1　整体架构图
8.3.2　客户端
8.3.3　RootServer
8.3.4　MergeServer
8.3.5　ChunkServer
8.3.6　UpdateServer
8.3.7　定期合并&数据分发
8.4　架构剖析
8.4.1　一致性选择
8.4.2　数据结构
8.4.3　可靠性与可用性
8.4.4　读写事务
8.4.5　单点性能
8.4.6　SSD支持
8.4.7　数据正确性
8.4.8　分层结构
第9章　分布式存储引擎
9.1　公共模块
9.1.1　内存管理
9.1.2　基础数据结构
9.1.3　锁
9.1.4　任务队列
9.1.5　网络框架
9.1.6　压缩与解压缩
9.2　RootServer实现机制
9.2.1　数据结构
9.2.2　子表复制与负载均衡
9.2.3　子表分裂与合并
9.2.4　UpdateServer选主
9.2.5　RootServer主备
9.3　UpdateServer实现机制
9.3.1　存储引擎
9.3.2　任务模型
9.3.3　主备同步
9.4　ChunkServer实现机制
9.4.1　子表管理
9.4.2　SSTable
9.4.3　缓存实现
9.4.4　IO实现
9.4.5　定期合并&数据分发
9.4.6　定期合并限速
9.5　消除更新瓶颈
9.5.1　读写优化回顾
9.5.2　数据旁路导入
9.5.3　数据分区
第10章　数据库功能
10.1　整体结构
10.2　只读事务
10.2.1　物理操作符接口
10.2.2　单表操作
10.2.3　多表操作
10.2.4　SQL执行本地化
10.3　写事务
10.3.1　写事务执行流程
10.3.2　多版本并发控制
10.4　OLAP业务支持
10.4.1　并发查询
10.4.2　列式存储
10.5　特色功能
10.5.1　大表左连接
10.5.2　数据过期与批量删除
第11章　质量保证、运维及实践
11.1　质量保证
11.1.1　RD开发
11.1.2　QA测试
11.1.3　试运行
11.2　使用与运维
11.2.1　使用
11.2.2　运维
11.3　应用
11.3.1　收藏夹
11.3.2　天猫评价
11.3.3　直通车报表
11.4　最佳实践
11.4.1　系统发展路径
11.4.2　人员成长
11.4.3　系统设计
11.4.4　系统实现
11.4.5　使用与运维
11.4.6　工程现象
11.4.7　经验法则
第四篇　专题篇
第12章　云存储
12.1　云存储的概念
12.2　云存储的产品形态
12.3　云存储技术
12.4　云存储的核心优势
12.5　云平台整体架构
12.5.1　Amazon云平台
12.5.2　Google云平台
12.5.3　Microsoft云平台
12.5.4　云平台架构
12.6　云存储技术体系
12.7　云存储安全
第13章　大数据
13.1　大数据的概念
13.2　MapReduce
13.3　MapReduce扩展
13.3.1　Google Tenzing
13.3.2　Microsoft Dryad
13.3.3　Google Pregel
13.4　流式计算
13.4.1　原理
13.4.2　Yahoo S4
13.4.3　Twitter Storm
13.5　实时分析
13.5.1　MPP架构
13.5.2　EMC Greenplum
13.5.3　HP Vertica
13.5.4　Google Dremel
参考资料
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大规模分布式存储系统
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大型网站技术架构
第1篇  概述
1      大型网站架构演化	2
1.1  大型网站软件系统的特点	3
1.2  大型网站架构演化发展历程	4
1.2.1  初始阶段的网站架构	4
1.2.2  应用服务和数据服务分离	4
1.2.3  使用缓存改善网站性能	5
1.2.4  使用应用服务器集群改善网站的并发处理能力	6
1.2.5  数据库读写分离	7
1.2.6  使用反向代理和CDN加速网站响应	8
1.2.7  使用分布式文件系统和分布式数据库系统	9
1.2.8  使用NoSQL和搜索引擎	10
1.2.9  业务拆分	11
1.2.10  分布式服务	11
1.3  大型网站架构演化的价值观	13
1.3.1  大型网站架构技术的核心价值是随网站所需灵活应对	13
1.3.2  驱动大型网站技术发展的主要力量是网站的业务发展	13
1.4  网站架构设计误区	14
1.4.1  一味追随大公司的解决方案	14
1.4.2  为了技术而技术	14
1.4.3  企图用技术解决所有问题	14
1.5  小结	15
2      大型网站架构模式	16
2.1  网站架构模式	16
2.1.1  分层	17
2.1.2  分割	18
2.1.3  分布式	18
2.1.4  集群	19
2.1.5  缓存	20
2.1.6  异步	20
2.1.7  冗余	21
2.1.8  自动化	22
2.1.9  安全	23
2.2  架构模式在新浪微博的应用	23
2.3  小结	25
3      大型网站核心架构要素	26
3.1  性能	27
3.2  可用性	28
3.3  伸缩性	29
3.4  扩展性	30
3.5  安全性	30
3.6  小结	31
第2篇  架构
4      瞬时响应：网站的高性能架构	34
4.1  网站性能测试	35
4.1.1  不同视角下的网站性能	35
4.1.2  性能测试指标	36
4.1.3  性能测试方法	39
4.1.4  性能测试报告	41
4.1.5  性能优化策略	41
4.2  Web前端性能优化	42
4.2.1  浏览器访问优化	42
4.2.2  CDN加速	43
4.2.3  反向代理	44
4.3  应用服务器性能优化	45
4.3.1  分布式缓存	45
4.3.2  异步操作	52
4.3.3  使用集群	53
4.3.4  代码优化	54
4.4  存储性能优化	58
4.4.1  机械硬盘vs. 固态硬盘	58
4.4.2  B+树vs. LSM树	59
4.4.3  RAID vs. HDFS	61
4.5  小结	64
5      万无一失：网站的高可用架构	66
5.1  网站可用性的度量与考核	67
5.1.1  网站可用性度量	67
5.1.2  网站可用性考核	67
5.2  高可用的网站架构	69
5.3  高可用的应用	71
5.3.1  通过负载均衡进行无状态服务的失效转移	72
5.3.2  应用服务器集群的Session管理	73
5.4  高可用的服务	76
5.5  高可用的数据	78
5.5.1  CAP原理	79
5.5.2  数据备份	82
5.5.3  失效转移	84
5.6  高可用网站的软件质量保证	85
5.6.1  网站发布	85
5.6.2  自动化测试	86
5.6.3  预发布验证	87
5.6.4  代码控制	88
5.6.5  自动化发布	90
5.6.6  灰度发布	91
5.7  网站运行监控	91
5.7.1  监控数据采集	92
5.7.2  监控管理	93
5.8  小结	94
6      永无止境：网站的伸缩性架构	95
6.1  网站架构的伸缩性设计	97
6.1.1  不同功能进行物理分离实现伸缩	97
6.1.2  单一功能通过集群规模实现伸缩	98
6.2  应用服务器集群的伸缩性设计	99
6.2.1  HTTP重定向负载均衡	100
6.2.2  DNS域名解析负载均衡	101
6.2.3  反向代理负载均衡	102
6.2.4  IP负载均衡	103
6.2.5  数据链路层负载均衡	104
6.2.6  负载均衡算法	105
6.3  分布式缓存集群的伸缩性设计	106
6.3.1  Memcached分布式缓存集群的访问模型	107
6.3.2  Memcached分布式缓存集群的伸缩性挑战	107
6.3.3  分布式缓存的一致性Hash算法	109
6.4  数据存储服务器集群的伸缩性设计	112
6.4.1  关系数据库集群的伸缩性设计	113
6.4.2  NoSQL数据库的伸缩性设计	117
6.5  小结	119
7      随需应变：网站的可扩展架构	121
7.1  构建可扩展的网站架构	122
7.2  利用分布式消息队列降低系统耦合性	123
7.2.1  事件驱动架构	123
7.2.2  分布式消息队列	124
7.3  利用分布式服务打造可复用的业务平台	126
7.3.1  Web Service与企业级分布式服务	128
7.3.2  大型网站分布式服务的需求与特点	129
7.3.3  分布式服务框架设计	130
7.4  可扩展的数据结构	131
7.5  利用开放平台建设网站生态圈	132
7.6  小结	134
8      固若金汤：网站的安全架构	135
8.1  道高一尺魔高一丈的网站应用攻击与防御	136
8.1.1  XSS攻击	136
8.1.2  注入攻击	138
8.1.3  CSRF攻击	139
8.1.4  其他攻击和漏洞	140
8.1.5  Web应用防火墙	141
8.1.6  网站安全漏洞扫描	142
8.2  信息加密技术及密钥安全管理	142
8.2.1  单向散列加密	143
8.2.2  对称加密	144
8.2.3  非对称加密	144
8.2.4  密钥安全管理	145
8.3  信息过滤与反垃圾	146
8.3.1  文本匹配	147
8.3.2  分类算法	148
8.3.3  黑名单	149
8.4  电子商务风险控制	150
8.4.1  风险	151
8.4.2  风控	151
8.5  小结	153
第3篇  案例
9      淘宝网的架构演化案例分析	156
9.1  淘宝网的业务发展历程	157
9.2  淘宝网技术架构演化	158
9.3  小结	162
10     维基百科的高性能架构设计分析	163
10.1  Wikipedia网站整体架构	163
10.2  Wikipedia性能优化策略	165
10.2.1  Wikipedia前端性能优化	165
10.2.2  Wikipedia服务端性能优化	166
10.2.3  Wikipedia后端性能优化	167
11     海量分布式存储系统Doris的高可用架构设计分析	169
11.1  分布式存储系统的高可用架构	170
11.2  不同故障情况下的高可用解决方案	171
11.2.1  分布式存储系统的故障分类	172
11.2.2  正常情况下系统访问结构	172
11.2.3  瞬时故障的高可用解决方案	173
11.2.4  临时故障的高可用解决方案	174
11.2.5  永久故障的高可用解决方案	175
12     网购秒杀系统架构设计案例分析	176
12.1  秒杀活动的技术挑战	177
12.2  秒杀系统的应对策略	177
12.3  秒杀系统架构设计	178
12.4  小结	182
13     大型网站典型故障案例分析	183
13.1  写日志也会引发故障	184
13.2  高并发访问数据库引发的故障	184
13.3  高并发情况下锁引发的故障	185
13.4  缓存引发的故障	185
13.5  应用启动不同步引发的故障	186
13.6  大文件读写独占磁盘引发的故障	186
13.7  滥用生产环境引发的故障	187
13.8  不规范的流程引发的故障	187
13.9  不好的编程习惯引发的故障	188
13.10  小结	188
第4篇  架构师
14     架构师领导艺术	190
14.1  关注人而不是产品	191
14.2  发掘人的优秀	191
14.3  共享美好蓝图	192
14.4  共同参与架构	193
14.5  学会妥协	194
14.6  成就他人	194
15     网站架构师职场攻略	196
15.1  发现问题，寻找突破	197
15.2  提出问题，寻求支持	199
15.3  解决问题，达成绩效	201
16     漫话网站架构师	203
16.1  按作用划分架构师	203
16.2  按效果划分架构师	204
16.3  按职责角色划分架构师	205
16.4  按关注层次划分架构师	205
16.5  按口碑划分架构师	206
16.6  非主流方式划分架构师	207
附录A  大型网站架构技术一览	208
附录B  Web开发技术发展历程	215
后记	218
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大型网站技术架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Web信息架构(第3版)
序
前言
第1部分：信息架构简介
第1章：信息架构的意义
定义
石板、卷轴、书籍，以及图书馆
对别人解释IA
什么不是信息架构？
为什么信息架构如此重要？
实践
第2章：实践信息架构
我们需要信息架构师吗？
谁有资格从事信息架构的工作？
信息架构专家
在真实世界实践信息架构
向前看
第3章：用户需求及其行为
“过于简单”的信息模型
信息需求
信息搜寻行为
学习信息需求和信息搜寻行为
第2部分：信息架构基本原理
第4章：信息架构详解
展现信息架构
信息架构组件
第5章：组织系统
信息组织的挑战
组织网站和企业网络
组织体系
组织结构
大众分类
建立凝聚性的组织系统
第6章：标签系统
为何要关心标签命名之事
各式各样的标签
设计标签
第7章：导航系统
导航系统的种类
重要的灰色地带
浏览器的导航特点
建立情境
改善灵活性
嵌入式导航系统
辅助性导航系统
高级导航方法
第8章：搜索系统
网站需要搜索功能吗？
搜索系统详解
搜索不是一种IT玩意
选择要搜索什么
搜索算法
查询辅助工具
展示结果
设计搜索界面
上哪儿学更多
第9章：叙词表、受控词表，以及元数据
元数据
受控词表
技术行话
叙词表实例
叙词表的种类
叙词表标准
语义关系
优选术语
复合式等级体系
分面分类法
第3部分：流程和方法论
第10章：研究
流程概观
研究框架
情境
内容
用户
参与者的定义和招募
用户研究会议
研究的保卫战
第11章：策略
什么是信息架构策略？
策略受到质疑
从研究到策略
开发策略
工作产品与成果
策略报告
项目计划
演示
第12章：设计和文件说明
制作信息架构图的原则
视觉沟通
蓝图
框架图
内容映射和清单
建立内容模型
受控词表
设计的共同合作
整合：信息架构风格指南
第4部分：信息架构实践
第13章：教育
教育过渡期
一个充满选择的年代
我需要学位吗？
领域现状
第14章：伦理
伦理考虑
塑造未来
第15章：成立信息架构小组
建设中的破坏性举动
快速层和慢速层
项目vs计划
购买或租赁
我们真的需要聘请专业人员吗？
梦幻小组
第16章：工具和软件
变动的时代
分类乱象
需要询问的事
第5部分：信息架构与组织
第17章：信息架构商机
你一定要做营销
世界上的两种人
谈谈数字
和保守派交手
其他的推销技巧
信息架构价值清单
最后一点
第18章：商业策略
策略之源
定义商业策略
策略的适应性
揭露商业策略内的分歧
最佳方法
很多好方法
了解我们的大象
竞争优势
开始的结束
第19章：企业信息架构
当信息架构碰上企业时
EIA的目标是什么？
设计企业信息架构
EIA策略和操作
办事和付钱
把握时机：阶段性展开
向前走的框架
第6部分：案例研究
第20章：MSWeb：企业网络
用户的挑战
信息架构师的挑战
任何分类法我们都喜欢
对用户的益处
下一步
MSWeb的成就
第21章：enolt．org：在线社区
evolt．org简介
构建在线社区
参与经济论
信息架构如何融入
无信息架构
附录：重要资源
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Web信息架构(第3版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据日知录
第0 章 当谈论大数据时我们在谈什么................ 1
0.1 大数据是什么.......................... 2
0.2 大数据之翼：技术范型转换......................................... 4
0.3 大数据商业炼金术................................ 6
0.4 “大数据”在路上................................................... 7
第1 章 数据分片与路由.............................................. 9
1.1 抽象模型.......................................................10
1.2 哈希分片（Hash Partition） ..............................11
1.2.1 Round Robin....................................11
1.2.2 虚拟桶（Virtual Buckets） ..........................12
1.2.3 一致性哈希（Consistent Hashing） ...........................13
1.3 范围分片（Range Partition） ......................................18
参考文献......................................19
第2 章 数据复制与一致性................................................20
2.1 基本原则与设计理念............................21
2.1.1 原教旨CAP 主义..............................................21
2.1.2 CAP 重装上阵（CAP Reloaded）.............................23
2.1.3 ACID 原则...............................................24
2.1.4 BASE 原则.................................................24
2.1.5 CAP/ACID/BASE 三者的关系...........................25
2.1.6 幂等性（Idempotent）........................................26
2.2 一致性模型分类.................................................26
2.2.1 强一致性............................................27
2.2.2 最终一致性........................................28
2.2.3 因果一致性.............................28
2.2.4 “读你所写”一致性....................................29
2.2.5 会话一致性....................................29
2.2.6 单调读一致性..............................................30
2.2.7 单调写一致性.....................................................30
2.3 副本更新策略...........................30
2.3.1 同时更新..........................................30
2.3.2 主从式更新.....................................31
2.3.3 任意节点更新......................................32
2.4 一致性协议...........................................................32
2.4.1 两阶段提交协议（Two-Phrase Commit，2PC）..........................33
2.4.2 向量时钟（Vector Clock） ..............................38
2.4.3 RWN 协议.................................................40
2.4.4 Paxos 协议.............................................42
2.4.5 Raft 协议.............................................45
参考文献................................................49
第3 章 大数据常用的算法与数据结构....................................51
3.1 布隆过滤器（Bloom Filter） ............................51
3.1.1 基本原理.............................................52
3.1.2 误判率及相关计算..........................................52
3.1.3 改进：计数Bloom Filter....................................53
3.1.4 应用............................................54
3.2 SkipList............................................55
3.3 LSM 树........................................58
3.4 Merkle 哈希树（Merkle Hash Tree） .............................62
3.4.1 Merkle 树基本原理..................................................62
3.4.2 Dynamo 中的应用.........................................63
3.4.3 比特币中的应用..................................................63
3.5 Snappy 与LZSS 算法..........................................65
3.5.1 LZSS 算法.............................................65
3.5.2 Snappy..........................................67
3.6 Cuckoo 哈希（Cuckoo Hashing） ..................................67
3.6.1 基本原理...............................................68
3.6.2 应用：SILT 存储系统.........................................68
参考文献...................................................70
第4 章 集群资源管理与调度.......................................71
4.1 资源管理抽象模型...................................72
4.1.1 概念模型....................................72
4.1.2 通用架构...............................................73
4.2 调度系统设计的基本问题.....................................74
4.2.1 资源异质性与工作负载异质性............................74
4.2.2 数据局部性（Data Locality） ........................................75
4.2.3 抢占式调度与非抢占式调度...................................75
4.2.4 资源分配粒度（Allocation Granularity） .............76
4.2.5 饿死（Starvation）与死锁（Dead Lock）问题...........................76
4.2.6 资源隔离方法........................................77
4.3 资源管理与调度系统范型.............................77
4.3.1 集中式调度器（Monolithic Scheduler）.......................78
4.3.2 两级调度器（Two-Level Scheduler） .........................79
4.3.3 状态共享调度器（Shared-State Scheduler） ....................79
4.4 资源调度策略...............................................81
4.4.1 FIFO 调度策略..........................................81
4.4.2 公平调度器（Fair Scheduler）......................81
4.4.3 能力调度器（Capacity Scheduler） ..........................82
4.4.4 延迟调度策略（Delay Scheduling）............................82
4.4.5 主资源公平调度策略（Dominant Resource Fair Scheduling）.............82
4.5 Mesos .................................84
4.6 YARN......................................87
参考文献..............................................90
第5 章 分布式协调系统...................................91
5.1 Chubby 锁服务...............................92
5.1.1 系统架构........................................93
5.1.2 数据模型..................................94
5.1.3 会话与KeepAlive 机制...............................95
5.1.4 客户端缓存.......................................95
5.2 ZooKeeper ................................96
5.2.1 体系结构...........................................96
5.2.2 数据模型（Data Model） .............................97
5.2.3 API ...............................98
5.2.4 ZooKeeper 的典型应用场景..................................98
5.2.5 ZooKeeper 的实际应用.......................................103
参考文献...................................104
第6 章 分布式通信..............................106
6.1 序列化与远程过程调用框架..................................107
6.1.1 Protocol Buffer 与Thrift .....................108
6.1.2 Avro...............................109
6.2 消息队列.....................................110
6.2.1 常见的消息队列系统......................................110
6.2.2 Kafka .......................111
6.3 应用层多播通信（Application-Level Multi-Broadcast）........114
6.3.1 概述...............................114
6.3.2 Gossip 协议...........................115
参考文献..........................118
第7 章 数据通道.........................................120
7.1 Log 数据收集.................................120
7.1.1 Chukwa........................121
7.1.2 Scribe......................122
7.2 数据总线......................................123
7.2.1 Databus............................125
7.2.2 Wormhole .......................127
7.3 数据导入/导出...........................................128
参考文献.............................129
第8 章 分布式文件系统....................................131
8.1 Google 文件系统（GFS） .................................132
8.1.1 GFS 设计原则...........................................132
8.1.2 GFS 整体架构..............................133
8.1.3 GFS 主控服务器..................................134
8.1.4 系统交互行为.................................136
8.1.5 Colossus ........................137
8.2 HDFS ..........................138
8.2.1 HDFS 整体架构.................................139
8.2.2 HA 方案..............................140
8.2.3 NameNode 联盟........................143
8.3 HayStack 存储系统....................................145
8.3.1 HayStack 整体架构.................................146
8.3.2 目录服务..................................147
8.3.3 HayStack 缓存...........................................148
8.3.4 HayStack 存储系统的实现...............................148
8.4 文件存储布局.........................................150
8.4.1 行式存储........................................151
8.4.2 列式存储...........................................151
8.4.3 混合式存储........................................156
8.5 纠删码（Erasure Code）.............................158
8.5.1 Reed-Solomon 编码...............................159
8.5.2 LRC 编码.....................................164
8.5.3 HDFS-RAID 架构.........................166
参考文献.....................................166
第9 章 内存KV 数据库...................................168
9.1 RAMCloud ..............................169
9.1.1 RAMCloud 整体架构................................169
9.1.2 数据副本管理与数据恢复................................170
9.2 Redis....................................172
9.3 MemBase ...............................173
参考文献................................................175
第10 章 列式数据库...........................................176
10.1 BigTable....................................177
10.1.1 BigTable 的数据模型..........................177
10.1.2 BigTable 的整体结构................................178
10.1.3 BigTable 的管理数据.............................179
10.1.4 主控服务器（Master Server）......................181
10.1.5 子表服务器（Tablet Server） ....................182
10.2 PNUTS 存储系统........................................186
10.2.1 PNUTS 的整体架构..............................186
10.2.2 存储单元...............................187
10.2.3 子表控制器与数据路由器..................................187
10.2.4 雅虎消息代理.............................188
10.2.5 数据一致性.........................................189
10.3 MegaStore..................................................190
10.3.1 实体群组切分......................191
10.3.2 数据模型........................................192
10.3.3 数据读/写与备份.................................193
10.4 Spanner .........................................194
10.4.1 SpanServer 软件栈.........................................195
10.4.2 数据模型.........................................196
10.4.3 TrueTime ...........................................196
参考文献..............................................197
第11 章 大规模批处理系统...................................199
11.1 MapReduce 计算模型与架构................................200
11.1.1 计算模型.......................................201
11.1.2 系统架构......................................203
11.1.3 MapReduce 计算的特点及不足......................................206
11.2 MapReduce 计算模式...........................206
11.2.1 求和模式（Summarization Pattern）................207
11.2.2 过滤模式（Filtering Pattern） ................208
11.2.3 组织数据模式（Data Organization Pattern） .....................210
11.2.4 Join 模式（Join Pattern）......................212
11.3 DAG 计算模型..........................................214
11.3.1 DAG 计算系统的三层结构............................214
11.3.2 Dryad .......................................215
11.3.3 FlumeJava 和Tez ........................................217
参考文献...........................................218
第12 章 流式计算........................................219
12.1 流式计算系统架构....................................222
12.1.1 主从架构............................................222
12.1.2 P2P 架构.....................................................223
12.1.3 Samza 架构..........................................224
12.2 DAG 拓扑结构..........................................224
12.2.1 计算节点.....................................................225
12.2.2 数据流..............................................226
12.2.3 拓扑结构..................................226
12.3 送达保证（Delivery Guarantees）..............................229
12.3.1 Storm 的送达保证机制.................................230
12.3.2 MillWheel 的“恰好送达一次”机制...........................233
12.4 状态持久化...........................................234
12.4.1 容错的三种模式....................................234
12.4.2 Storm 的状态持久化.......................................236
12.4.3 MillWheel 和Samza 的状态持久化......................237
参考文献............................................238
第13 章 交互式数据分析...................................240
13.1 Hive 系数据仓库.................................242
13.1.1 Hive .....................................242
13.1.2 StingerInitiative ................................250
13.2 Shark 系数据仓库..................................251
13.2.1 Shark 架构.........................................252
13.2.2 部分DAG 执行引擎（PDE） ........................253
13.2.3 数据共同分片.........................................254
13.3 Dremel 系数据仓库...................................254
13.3.1 Dremel...........................255
13.3.2 PowerDrill ..........................258
13.3.3 Impala.................................261
13.3.4 Presto...............................264
13.4 混合系数据仓库......................................265
参考文献.................................269
第14 章 图数据库：架构与算法................................271
14.1 在线查询类图数据库...........................272
14.1.1 三层结构.........................272
14.1.2 TAO 图数据库.................................273
14.2 常见图挖掘问题..........................................277
14.2.1 PageRank 计算.......................................278
14.2.2 单源最短路径（Single Source Shortest Path） ..................278
14.2.3 二部图最大匹配.............................279
14.3 离线挖掘数据分片..............................................279
14.3.1 切边法（Edge-Cut）......................................280
14.3.2 切点法（Vertex-Cut）...............................282
14.4 离线挖掘计算模型...................................284
14.4.1 以节点为中心的编程模型..........................284
14.4.2 GAS 编程模型...........................................285
14.4.3 同步执行模型.....................................286
14.4.4 异步执行模型...................................290
14.5 离线挖掘图数据库.................................292
14.5.1 Pregel..........................292
14.5.2 Giraph...............................299
14.5.3 GraphChi ............................301
14.5.4 PowerGraph.......................307
参考文献.......................................311
第15 章 机器学习：范型与架构.........................................313
15.1 分布式机器学习...........................................314
15.1.1 机器学习简介.............................................314
15.1.2 数据并行VS.模型并行.....................................316
15.2 分布式机器学习范型.....................317
15.2.1 三种范型...................................318
15.2.2 MapReduce 迭代计算模型........................319
15.2.3 BSP 计算模型...................................321
15.2.4 SSP 模型............................323
15.3 分布式机器学习架构...................................324
15.3.1 MapReduce 系列..................................325
15.3.2 Spark 及MLBase ..........................................327
15.3.3 参数服务器（Parameter Server）.............332
参考文献................................................335
第16 章 机器学习：分布式算法...............................337
16.1 计算广告：逻辑回归.......................................338
16.1.1 逻辑回归（Logistic Regression，LR）.............................338
16.1.2 并行随机梯度下降（Parallel Stochastic Gradient Descent）............341
16.1.3 批学习并行逻辑回归..................................341
16.2 推荐系统：矩阵分解................................................344
16.2.1 矩阵分解方法.......................................344
16.2.2 ALS-WR 算法............................................346
16.2.3 并行版ALS-WR 算法..............................347
16.3 搜索引擎：机器学习排序................................347
16.3.1 机器学习排序简介.................................348
16.3.2 LambdaMART.................................349
16.3.3 分布式LambdaMART........................................351
16.4 自然语言处理：文档相似性计算.......................................352
16.5 社交挖掘：谱聚类.................................355
16.5.1 社交挖掘实例...............................355
16.5.2 谱聚类....................................356
16.5.3 并行版谱聚类..........................................358
16.6 深度学习：DistBelief .............................................358
16.6.1 深度学习简介........................................359
16.6.2 DistBelief.....................360
参考文献.........................................364
第17 章 增量计算..........................................366
17.1 增量计算模式...........................367
17.1.1 两种计算模式...............................367
17.1.2 Hadoop 平台下增量计算的一般模式.............................368
17.2 Percolator................................370
17.2.1 事务支持..........................................371
17.2.2 “观察/通知”体系结构...........................373
17.3 Kineograph ............................374
17.3.1 整体架构.........................................375
17.3.2 增量计算机制....................................375
17.4 DryadInc ....................................376
参考文献..............................................................377
附录A 硬件体系结构及常用性能指标......................................378
附录B 大数据必读文献....................................380
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据日知录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件架构设计
第1部分  什么是架构
第1章  五花八门的架构师职业  2
1.1  架构师职业分类  2
1.2  架构的分类  2
第2章  架构的道与术  5
2.1  何为道，何为术  5
2.2  道与术的辩证关系  6
第2部分  计算机功底
第3章  语言  10
3.1  层出不穷的编程语言  10
3.2  精通一门语言  10
第4章  操作系统  12
4.1  缓冲I/O和直接I/O  12
4.2  内存映射文件与零拷贝  14
4.2.1  内存映射文件  14
4.2.2  零拷贝  15
4.3  网络I/O模型  17
4.3.1  实现层面的网络I/O模型  17
4.3.2  Reactor模式与Preactor模式  20
4.3.3  select、epoll的LT与ET  20
4.3.4  服务器编程的1+N+M模型  22
4.4  进程、线程和协程  24
4.5  无锁（内存屏障与CAS）  27
4.5.1  内存屏障  27
4.5.2  CAS  30
第5章  网络  31
5.1  HTTP 1.0  31
5.1.1  HTTP 1.0的问题  31
5.1.2  Keep-Alive机制与Content-Length属性  31
5.2  HTTP 1.1  32
5.2.1  连接复用与Chunk机制  32
5.2.2  Pipeline与Head-of-line Blocking问题  33
5.2.3  HTTP/2出现之前的性能提升方法  34
5.2.4  “一来多回”问题  35
5.2.5  断点续传  36
5.3  HTTP/2  36
5.3.1  与HTTP 1.1的兼容  37
5.3.2  二进制分帧  37
5.3.3  头部压缩  39
5.4  SSL/TLS  39
5.4.1  背景  39
5.4.2  对称加密的问题  40
5.4.3  双向非对称加密  41
5.4.4  单向非对称加密  42
5.4.5  中间人攻击  43
5.4.6  数字证书与证书认证中心  44
5.4.7  根证书与CA信任链  45
5.4.8  SSL/TLS协议：四次握手  47
5.5  HTTPS  48
5.6  TCP/UDP  49
5.6.1  可靠与不可靠  49
5.6.2  TCP的“假”连接（状态机）  51
5.6.3  三次握手（网络2将军问题）  53
5.6.4  四次挥手  54
5.7  QUIC  56
5.7.1  不丢包（Raid5算法和Raid6算法）  57
5.7.2  更少的RTT  58
5.7.3  连接迁移  58
第6章  数据库  59
6.1  范式与反范式  59
6.2  分库分表  59
6.2.1  为什么要分  60
6.2.2  分布式ID生成服务  60
6.2.3  拆分维度的选择  60
6.2.4  Join查询问题  61
6.2.5  分布式事务  61
6.3  B+树  62
6.3.1  B+树逻辑结构  62
6.3.2  B+树物理结构  63
6.3.3  非主键索引  65
6.4  事务与锁  66
6.4.1  事务的四个隔离级别  66
6.4.2  悲观锁和乐观锁  67
6.4.3  死锁检测  71
6.5  事务实现原理之1：Redo Log  72
6.5.1  Write-Ahead  73
6.5.2  Redo Log的逻辑与物理结构  74
6.5.3  Physiological Logging  75
6.5.4  I/O写入的原子性（Double Write）  76
6.5.5  Redo Log Block结构  77
6.5.6  事务、LSN与Log Block的关系  78
6.5.7  事务Rollback与崩溃恢复（ARIES算法）  80
6.6  事务实现原理之2：Undo Log  86
6.6.1  Undo Log是否一定需要  86
6.6.2  Undo Log（MVCC）  88
6.6.3  Undo Log不是Log  89
6.6.4  Undo Log与Redo Log的关联  90
6.6.4  各种锁  91
6.7  Binlog与主从复制  94
6.7.1  Binlog与Redo Log的主要差异  94
6.7.2  内部XA – Binlog与Redo Log一致性问题  95
6.7.3  三种主从复制方式  96
6.7.3  并行复制  97
第7章  框架、软件与中间件  99
7.1  对生态体系的认知  99
7.2  框架  99
7.3  软件与中间件  100
第3部分  技术架构之道
第8章  高并发问题  104
8.1  问题分类  104
8.1.1  侧重于“高并发读”的系统  104
8.1.2  侧重于“高并发写”的系统  105
8.1.3  同时侧重于“高并发读”和“高并发写”的系统  106
8.2  高并发读  108
8.2.1  策略1：加缓存  108
8.2.2  策略2：并发读  109
8.2.3  策略3：重写轻读  110
8.2.4  总结：读写分离（CQRS架构）  113
8.3  高并发写  114
8.3.1  策略1：数据分片  114
8.3.2  策略2：任务分片  115
8.3.3  策略3：异步化  117
8.3.4  策略4：批量  123
8.3.5  策略5：串行化+多进程单线程+异步I/O  124
8.4  容量规划  125
8.4.1  吞吐量、响应时间与并发数  125
8.4.2  压力测试与容量评估  127
第9章  高可用与稳定性  129
9.1  多副本  129
9.2  隔离、限流、熔断和降级  130
9.3  灰度发布与回滚  135
9.4  监控体系与日志报警  136
第10章  事务一致性  138
10.1  随处可见的分布式事务问题  138
10.2  分布式事务解决方案汇总  139
10.2.1  2PC  139
10.2.2  最终一致性（消息中间件）  141
10.2.3  TCC  145
10.2.4  事务状态表+调用方重试+接收方幂等  147
10.2.5  对账  148
10.2.6  妥协方案：弱一致性+基于状态的补偿  149
10.2.7  妥协方案：重试+回滚+报警+人工修复  151
10.2.8  总结  152
第11章  多副本一致性  153
11.1  高可用且强一致性到底有多难  153
11.1.1  Kafka的消息丢失问题  153
11.1.2  Kafka消息错乱问题  156
11.2  Paxos算法解析  158
11.2.1  Paxos解决什么问题  158
11.2.2  复制状态机  161
11.2.3  一个朴素而深刻的思想  163
11.2.4  Basic Paxos算法  164
11.2.5  Multi Paxos算法  167
11.3  Raft算法解析  169
11.3.1  为“可理解性”而设计  169
11.3.2  单点写入  170
11.3.3  日志结构  171
11.3.4  阶段1：Leader选举  174
11.3.5  阶段2：日志复制  176
11.3.6  阶段3：恢复阶段  177
11.3.7  安全性保证  177
11.4  Zab算法解析  180
11.4.1  Replicated State Machine vs. Primary-Backup System  180
11.4.2  zxid  182
11.4.3  “序”：乱序提交 vs. 顺序提交  182
11.4.4  Leader选举：FLE算法  184
11.4.5  正常阶段：2阶段提交  186
11.4.6  恢复阶段  186
11.5  三种算法对比  187
第12章  CAP理论  189
12.1  CAP理论的误解  189
12.2  现实世界不存在“强一致性”（PACELC理论）  190
12.3  典型案例：分布式锁  192
第4部分  业务架构之道
第13章  业务意识  196
13.1  产品经理vs.需求分析师  196
13.2  什么叫作一个“业务”  198
13.3  “业务架构”的双重含义  199
13.4  “业务架构”与“技术架构”的区分  200
第14章  业务架构思维  202
14.1  “伪”分层  202
14.2  边界思维  204
14.3  系统化思维  205
14.4  利益相关者分析  206
14.5  非功能性需求分析（以终为始）  208
14.6  视角（横看成岭侧成峰）  209
14.7  抽象  210
14.8  建模  213
14.9  正交分解  215
第15章  技术架构与业务架构的融合  218
15.1  各式各样的方法论  218
15.2  为什么要“领域驱动”  218
15.3  “业务流程”不等于“系统流程”  221
15.4  为何很难设计一个好的领域模型  222
15.5  领域驱动设计与微服务架构的“合”  223
15.6  领域驱动设计与读写分离（CQRS）  224
15.7  业务分层架构模式  225
15.8  管道—过滤器架构模式  226
15.9  状态机架构模式  226
15.10  业务切面/业务闭环架构模式  228
第5部分  从架构到技术管理
第16章  个人素质的提升  232
16.1  能力模型  232
16.2  影响力的塑造  234
第17章  团队能力的提升  237
17.1  不确定性与风险把控  237
17.2  以价值为中心的管理  239
17.3  团队培养  241
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件架构设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构即未来：现代企业可扩展的Web架构、流程和组织(原书第2版)
目录
本书赞誉
中文版序一
中文版序二
中文版序三
中文版序四
译者序
序
前言
作者简介
第一部分　可扩展性组织的人员配置
第1章　人员和领导力对扩展性的影响 …… 2
1.1　案例方法 …… 3
1.2　为什么要讨论人 …… 3
1.3　为什么组织很重要 …… 5
1.4　为什么管理和领导如此重要 …… 12
1.5　结论 …… 15
第2章　可扩展性技术组织的角色 …… 17
2.1　失败的影响 …… 17
2.2　定义角色 …… 19
2.3　执行人员的责任 …… 22
2.4　独立贡献者的责任 …… 28
2.5　RASCI工具 …… 35
2.6　结论 …… 39
第3章　组织的设置 …… 41
3.1　组织对可扩展性的影响 …… 41
3.2　团队规模 …… 45
3.3　组织结构 …… 54
3.4　结论 …… 77
第4章　领导力秘籍 …… 80
4.1　什么是领导力 …… 82
4.2　领导力概念模型 …… 84
4.3　自知之明 …… 86
4.4　身先士卒 …… 89
4.5　谦虚谨慎 …… 91
4.6　以人为本，使命为先 …… 92
4.7　决策英明，以德服人 …… 93
4.8　用人不疑 …… 95
4.9　与股东价值保持一致 …… 96
4.10　变革型领导 …… 97
4.11　愿景 …… 98
4.12　使命 …… 102
4.13　目标 …… 104
4.14　总结 …… 106
4.15　成功的因果路线图 …… 111
4.16　结论 …… 113
第5章　管理秘籍 …… 116
5.1　什么是管理 …… 118
5.2　项目和任务管理 …… 120
5.3　团队建设：球队类比 …… 124
5.4　优化团队：花园类比 …… 126
5.5　度量、指标和目标评估 …… 131
5.6　目标树 …… 135
5.7　为成功铺路 …… 137
5.8　结论 …… 138
第6章　关系、思维和商业案例 …… 141
6.1　业务与技术之间的鸿沟 …… 141
6.2　击败IT思维模式 …… 145
6.3　为扩展性加大投入的业务理由 …… 147
6.4　结论 …… 152
第二部分　构建可扩展的过程
第7章　过程是可扩展的关键 …… 154
7.1　过程的目的 …… 155
7.2　正确的时间和正确的过程 …… 160
7.3　当好的过程变坏的时候 …… 164
7.4　结论 …… 166
第8章　管理故障和问题 …… 169
8.1　什么是故障 …… 170
8.2　什么是问题 …… 171
8.3　事故管理的组成部分 …… 172
8.4　问题管理的组成部分 …… 176
8.5　解决事故和问题管理之间的矛盾 …… 177
8.6　事故和问题的生命周期 …… 178
8.7　施行每日事故例会制 …… 179
8.8　施行季度事故总结制度 …… 181
8.9　事后处理 …… 182
8.10　融会贯通 …… 185
8.11　结论 …… 186
第9章　危机管理和升级 …… 189
9.1　什么是危机 …… 191
9.2　为什么要区分危机和其他的事故 …… 192
9.3　危机如何改变公司 …… 193
9.4　混乱中的秩序 …… 195
9.5　通信与控制 …… 200
9.6　作战室 …… 201
9.7　升级 …… 203
9.8　情况通报 …… 204
9.9　危机事后处理与沟通 …… 205
9.10　结论 …… 207
第10章　生产环境的变更管理 …… 210
10.1　什么是变更 …… 211
10.2　变更识别 …… 212
10.3　变更管理 …… 214
10.4　变更控制会议 …… 228
10.5　过程的持续改进 …… 229
10.6　结论 …… 230
第11章　确定应用发展的预留空间 …… 233
11.1　目的 …… 234
11.2　结构 …… 235
11.3　理想使用率 …… 240
11.4　使用电子表格的快速示例 …… 244
11.5　结论 …… 246
第12章　确立架构原则 …… 248
12.1　目标和原则 …… 248
12.2　架构选择 …… 251
12.3　AKF采用的最普遍的架构原则 …… 255
12.4　结论 …… 266
第13章　联合架构设计和架构审查委员会 …… 267
13.1　修复组织的功能障碍 …… 267
13.2　跨部门的扩展性设计 …… 268
13.3　JAD的准入和退出标准 …… 271
13.4　从JAD到ARB …… 274
13.5　举行会议 …… 276
13.6　ARB的准入和退出标准 …… 278
13.7　结论 …… 281
第14章　敏捷架构设计 …… 284
14.1　敏捷组织中的架构 …… 286
14.2　架构的所有权 …… 287
14.3　有限的资源 …… 288
14.4　标准 …… 290
14.5　敏捷组织中的ARB …… 293
14.6　结论 …… 294
第15章　聚焦核心竞争力：自建与外购 …… 296
15.1　自建与外购及可扩展性 …… 296
15.2　聚焦成本 …… 297
15.3　聚焦策略 …… 298
15.4　一切自建的现象 …… 299
15.5　合并成本与策略方法 …… 300
15.6　该组件是否会形成战略性的差异化竞争优势 …… 301
15.7　我们是这个组件或资产的最佳所有者吗 …… 302
15.8　这个组件的竞争力是什么 …… 303
15.9　我们能有效地构建这个组件吗 …… 303
15.10　最佳的购买决策 …… 304
15.11　自建失败剖析 …… 306
15.12　结论 …… 308
第16章　确定风险 …… 310
16.1　风险管理的重要性 …… 310
16.2　测量风险 …… 313
16.3　管理风险 …… 322
16.4　结论 …… 325
第17章　性能与压力测试 …… 328
17.1　执行性能测试 …… 328
17.2　不要过度强调压力测试 …… 338
17.3　可扩展性的性能和压力测试 …… 346
17.4　结论 …… 348
第18章　障碍条件与回滚 …… 351
18.1　障碍条件 …… 352
18.2　回滚能力 …… 358
18.3　服务降级：设计禁用 …… 362
18.4　结论 …… 364
第三部分　可扩展的架构方案
第19章　构建故障隔离的架构 …… 368
19.1　故障隔离架构 …… 369
19.2　故障隔离的好处 …… 371
19.3　如何进行故障隔离 …… 380
19.4　何时实施故障隔离 …… 383
19.5　如何测试故障隔离 …… 386
19.6　结论 …… 387
第20章　AKF扩展立方体介绍 …… 389
20.1　AKF扩展立方体 …… 389
20.2　扩展立方体的X轴 …… 391
20.3　扩展立方体的Y轴 …… 393
20.4　扩展立方体的Z轴 …… 396
20.5　融会贯通 …… 397
20.6　何时以及何处使用扩展立方体 …… 400
20.7　结论 …… 401
第21章　为扩展分割应用 …… 404
21.1　AKF应用扩展立方体 …… 404
21.2　AKF应用扩展立方体的X轴 …… 406
21.3　AKF应用扩展立方体的Y轴 …… 409
21.4　AKF应用扩展立方体的Z轴 …… 412
21.5　融会贯通 …… 414
21.6　应用立方体实例 …… 418
21.7　结论 …… 423
第22章　为扩展分割数据库 …… 426
22.1　在数据库上应用AKF扩展立方体 …… 426
22.2　AKF数据库扩展立方体的X轴 …… 428
22.3　AKF数据库扩展立方体的Y轴 …… 434
22.4　AKF数据库扩展立方体的Z轴 …… 436
22.5　融会贯通 …… 439
22.6　数据库扩展立方体使用案例 …… 443
22.7　结论 …… 450
第23章　为扩展而缓存 …… 452
23.1　定义缓存 …… 453
23.2　对象缓存 …… 457
23.3　应用缓存 …… 461
23.4　内容传送网络 …… 467
23.5　结论 …… 469
第24章　为扩展而异步 …… 472
24.1　对同步的共识 …… 472
24.2　同步与异步调用 …… 474
24.3　定义状态 …… 482
24.4　结论 …… 488
第四部分　其他的问题和挑战
第25章　海量数据 …… 492
25.1　数据的成本 …… 493
25.2　数据的成本价值困局 …… 496
25.3　数据产生利润 …… 498
25.4　处理大量的数据 …… 502
25.5　结论 …… 514
第26章　云计算的突飞猛进 …… 517
26.1　历史和定义 …… 518
26.2　云的特性与架构 …… 522
26.3　云和网格之间的差异 …… 528
26.4　云计算的优势和劣势 …… 530
26.5　云适用于什么样的公司 …… 540
26.6　决策过程 …… 543
26.7　结论 …… 546
第27章　云计算准备就绪 …… 550
27.1　云端的扩展立方体 …… 550
27.2　克服挑战 …… 553
27.3　Intuit案例研究 …… 559
27.4　结论 …… 561
第28章　应用监控 …… 564
28.1　为什么我们没有及早发现问题 …… 564
28.2　监控框架 …… 566
28.3　衡量监控的价值 …… 575
28.4　监控和过程 …… 576
28.5　结论 …… 578
第29章　规划数据中心 …… 581
29.1　数据中心的成本和约束 …… 581
29.2　位置、位置、位置 …… 584
29.3　数据中心和增量增长 …… 588
29.4　什么时候考虑采用IaaS …… 591
29.5　魔法三规则 …… 595
29.6　多活数据中心的考虑 …… 602
29.7　结论 …… 604
第30章　纵观全局 …… 608
30.1　现在该做什么 …… 610
30.2　可扩展性的其他资源 …… 612
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构即未来：现代企业可扩展的Web架构、流程和组织(原书第2版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构整洁之道
第1部分  概述
第1章  设计与架构究竟是什么  3
目标是什么  4
案例分析  5
本章小结  11
第2章  两个价值维度  12
行为价值  13
架构价值  13
哪个价值维度更重要  14
艾森豪威尔矩阵  15
为好的软件架构而持续斗争  16
第2部分  从基础构件开始：编程范式
第3章  编程范式总览  21
结构化编程  22
面向对象编程  22
函数式编程  23
仅供思考  23
本章小结  24
第4章  结构化编程  25
可推导性  26
goto是有害的  28
功能性降解拆分  29
形式化证明没有发生  29
科学来救场  29
测试  30
本章小结  31
第5章  面向对象编程  32
封装  33
继承  36
多态  38
本章小结  44
第6章  函数式编程  45
整数平方  46
不可变性与软件架构  47
可变性的隔离  48
事件溯源  49
本章小结  51
第3部分  设计原则
第7章  SRP：单一职责原则  56
反面案例2：代码合并  59
解决方案  60
本章小结  61
第8章  OCP：开闭原则  62
思想实验  63
依赖方向的控制  67
信息隐藏  67
本章小结  67
第9章  LSP：里氏替换原则  68
继承的使用指导  69
正方形/长方形问题  70
LSP与软件架构  70
违反LSP的案例  71
本章小结  73
第10章 ISP：接口隔离原则  74
ISP与编程语言  76
ISP与软件架构  76
本章小结  77
第11章 DIP：依赖反转原则  78
稳定的抽象层  79
工厂模式  80
具体实现组件  82
本章小结  82
第4部分  组件构建原则
第12章 组件  84
组件发展史  85
重定位技术  88
链接器  88
本章小结  90
第13章 组件聚合  91
复用/发布等同原则  92
共同闭包原则  93
共同复用原则  94
组件聚合张力图  95
本章小结  97
第14章 组件耦合  98
无依赖环原则  99
自上而下的设计  105
稳定依赖原则  106
稳定抽象原则  112
本章小结  117
第5部分  软件架构
第15章 什么是软件架构  120
开发（Development）  122
部署（Deployment）  123
运行（Operation）  123
维护（Maintenance）  124
保持可选项  124
设备无关性  126
垃圾邮件  128
物理地址寻址  129
本章小结  130
第16章 独立性  131
用例  132
运行  133
开发  133
部署  134
保留可选项  134
按层解耦  135
用例的解耦  136
解耦的模式  136
开发的独立性  137
部署的独立性  137
重复  138
再谈解耦模式  139
本章小结  141
第17章 划分边界  142
几个悲伤的故事  143
FitNesse  146
应在何时、何处画这些线  148
输入和输出怎么办  151
插件式架构  152
插件式架构的好处  153
本章小结  154
第18章 边界剖析  155
跨边界调用  156
令人生畏的单体结构  156
部署层次的组件  158
线程  159
本地进程  159
服务  160
本章小结  161
第19章 策略与层次  162
层次（Level）  163
本章小结  166
第20章 业务逻辑  167
业务实体  168
用例  169
请求和响应模型  171
本章小结  172
第21章 尖叫的软件架构  173
架构设计的主题  174
架构设计的核心目标  175
那Web呢  175
框架是工具而不是生活信条  175
可测试的架构设计  176
本章小结  176
第22章 整洁架构  177
依赖关系规则  179
一个常见的应用场景  183
本章小结  184
第23章 展示器和谦卑对象  185
谦卑对象模式  186
展示器与视图  186
测试与架构  187
数据库网关  188
数据映射器  188
服务监听器  189
本章小结  189
第24章 不完全边界  190
省掉最后一步  191
单向边界  192
门户模式  193
本章小结  193
第25章 层次与边界  194
基于文本的冒险游戏：Hunt The Wumpus  195
可否采用整洁架构  196
交汇数据流  199
数据流的分割  199
本章小结  201
第26章 Main组件  203
最细节化的部分  204
本章小结  208
第27章 服务：宏观与微观  209
面向服务的架构  210
服务所带来的好处  210
运送猫咪的难题  212
对象化是救星  213
基于组件的服务  215
横跨型变更  216
本章小结  216
第28章 测试边界  217
测试也是一种系统组件  218
可测试性设计  219
测试专用API  220
本章小结  221
第29章 整洁的嵌入式架构  222
“程序适用测试”测试  225
目标硬件瓶颈  228
本章小结  238
第6部分  实现细节
第30章 数据库只是实现细节  240
关系型数据库  241
为什么数据库系统如此流行  242
假设磁盘不存在会怎样  243
实现细节  243
但性能怎么办呢  244
一段轶事  244
本章小结  246
第31章 Web是实现细节  247
无尽的钟摆  248
总结一下  250
本章小结  251
第32章 应用程序框架是实现细节  252
框架作者  253
单向婚姻  253
风险  254
解决方案  255
不得不接受的依赖  255
本章小结  256
第33章 案例分析：视频销售网站  257
产品  258
用例分析  258
组件架构  260
依赖关系管理  261
本章小结  262
第34章 拾遗  263
按层封装  264
按功能封装  266
端口和适配器  268
按组件封装  270
具体实现细节中的陷阱  274
组织形式与封装的区别  275
其他的解耦合模式  277
本章小结：本书拾遗  279
后序  280
附录A  架构设计考古  283
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构整洁之道
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Nginx
前　言
第一部分　Nginx能帮我们做什么
第1章　研究Nginx前的准备工作 / 2
1.1　Nginx是什么 / 2
1.2　为什么选择Nginx / 4
1.3　准备工作 / 7
1.3.1　Linux操作系统 / 7
1.3.2　使用Nginx的必备软件 / 7
1.3.3　磁盘目录 / 8
1.3.4　Linux内核参数的优化 / 9
1.3.5　获取Nginx源码 / 11
1.4　编译安装Nginx / 11
1.5　configure详解 / 11
1.5.1　configure的命令参数 / 12
1.5.2　configure执行流程 / 18
1.5.3　configure生成的文件 / 22
1.6　Nginx的命令行控制 / 24
1.7　小结 / 27
第2章　Nginx的配置 / 28
2.1　运行中的Nginx进程间的关系 / 28
2.2　Nginx配置的通用语法 / 31
2.2.1　块配置项 / 31
2.2.2　配置项的语法格式 / 32
2.2.3　配置项的注释 / 33
2.2.4　配置项的单位 / 33
2.2.5　在配置中使用变量 / 33
2.3　Nginx服务的基本配置 / 34
2.3.1　用于调试进程和定位问题的配置项 / 34
2.3.2　正常运行的配置项 / 36
2.3.3　优化性能的配置项 / 38
2.3.4　事件类配置项 / 39
2.4　用HTTP核心模块配置一个静态Web服务器 / 41
2.4.1　虚拟主机与请求的分发 / 42
2.4.2　文件路径的定义 / 45
2.4.3　内存及磁盘资源的分配 / 48
2.4.4　网络连接的设置 / 50
2.4.5　MIME类型的设置 / 53
2.4.6　对客户端请求的限制 / 54
2.4.7　文件操作的优化 / 55
2.4.8　对客户端请求的特殊处理 / 57
2.4.9　ngx_http_core_module模块提供的变量 / 59
2.5　用HTTP proxy module配置一个反向代理服务器 / 60
2.5.1　负载均衡的基本配置 / 62
2.5.2　反向代理的基本配置 / 64
2.6　小结 / 68
第二部分　如何编写HTTP模块
第3章　开发一个简单的HTTP模块 / 70
3.1　如何调用HTTP模块 / 70
3.2　准备工作 / 72
3.2.1　整型的封装 / 72
3.2.2　ngx_str_t数据结构 / 73
3.2.3　ngx_list_t数据结构 / 73
3.2.4　ngx_table_elt_t数据结构 / 77
3.2.5　ngx_buf_t数据结构 / 77
3.2.6　ngx_chain_t数据结构 / 79
3.3　如何将自己的HTTP模块编译进Nginx / 79
3.3.1　config文件的写法 / 80
3.3.2　利用configure脚本将定制的模块加入到Nginx中 / 80
3.3.3　直接修改Makefile文件 / 84
3.4　HTTP模块的数据结构 / 85
3.5　定义自己的HTTP模块 / 88
3.6　处理用户请求 / 92
3.6.1　处理方法的返回值 / 92
3.6.2　获取URI和参数 / 95
3.6.3　获取HTTP头部 / 98
3.6.4　获取HTTP包体 / 101
3.7　发送响应 / 102
3.7.1　发送HTTP头部 / 102
3.7.2　将内存中的字符串作为包体发送 / 104
3.7.3　经典的“Hello World”示例 / 106
3.8　将磁盘文件作为包体发送 / 107
3.8.1　如何发送磁盘中的文件 / 107
3.8.2　清理文件句柄 / 110
3.8.3　支持用户多线程下载和断点续传 / 111
3.9　用C++语言编写HTTP模块 / 112
3.9.1　编译方式的修改 / 112
3.9.2　程序中的符号转换 / 114
3.10　小结 / 114
第4章　配置、error日志和请求上下文 / 115
4.1　http配置项的使用场景 / 115
4.2　怎样使用http配置 / 117
4.2.1　分配用于保存配置参数的数据结构 / 117
4.2.2　设定配置项的解析方式 / 119
4.2.3　使用14种预设方法解析配置项 / 125
4.2.4　自定义配置项处理方法 / 136
4.2.5　合并配置项 / 137
4.3　HTTP配置模型 / 140
4.3.1　解析HTTP配置的流程 / 141
4.3.2　HTTP配置模型的内存布局 / 144
4.3.3　如何合并配置项 / 147
4.3.4　预设配置项处理方法的工作原理 / 149
4.4　error日志的用法 / 150
4.5　请求的上下文 / 155
4.5.1　上下文与全异步Web服务器的关系 / 155
4.5.2　如何使用HTTP上下文 / 156
4.5.3　HTTP框架如何维护上下文结构 / 157
4.6　小结 / 158
第5章　访问第三方服务 / 159
5.1　upstream的使用方式 / 160
5.1.1　ngx_http_upstream_t结构体 / 163
5.1.2　设置upstream的限制性参数 / 164
5.1.3　设置需要访问的第三方服务器地址 / 165
5.1.4　设置回调方法 / 166
5.1.5　如何启动upstream机制 / 166
5.2　回调方法的执行场景 / 167
5.2.1　create_request回调方法 / 167
5.2.2　reinit_request回调方法 / 169
5.2.3　finalize_request回调方法 / 170
5.2.4　process_header回调方法 / 171
5.2.5　rewrite_redirect回调方法 / 172
5.2.6　input_filter_init与input_filter回调方法 / 172
5.3　使用upstream的示例 / 173
5.3.1　upstream的各种配置参数 / 174
5.3.2　请求上下文 / 175
5.3.3　在create_request方法中构造请求 / 176
5.3.4　在process_header方法中解析包头 / 177
5.3.5　在finalize_request方法中释放资源 / 180
5.3.6　在ngx_http_mytest_handler方法中启动upstream / 181
5.4　subrequest的使用方式 / 183
5.4.1　配置子请求的处理方式 / 183
5.4.2　实现子请求处理完毕时的回调方法 / 184
5.4.3　处理父请求被重新激活后的回调方法 / 185
5.4.4　启动subrequest子请求 / 185
5.5　subrequest执行过程中的主要场景 / 186
5.5.1　如何启动subrequest / 186
5.5.2　如何转发多个子请求的响应包体 / 188
5.5.3　子请求如何激活父请求 / 192
5.6　subrequest使用的例子 / 193
5.6.1　配置文件中子请求的设置 / 194
5.6.2　请求上下文 / 194
5.6.3　子请求结束时的处理方法 / 195
5.6.4　父请求的回调方法 / 196
5.6.5　启动subrequest / 197
5.7　小结 / 198
第6章　开发一个简单的HTTP过滤模块 / 199
6.1　过滤模块的意义 / 199
6.2　过滤模块的调用顺序 / 200
6.2.1　过滤链表是如何构成的 / 200
6.2.2　过滤链表的顺序 / 203
6.2.3　官方默认HTTP过滤模块的功能简介 / 204
6.3　HTTP过滤模块的开发步骤 / 206
6.4　HTTP过滤模块的简单例子 / 207
6.4.1　如何编写config文件 / 208
6.4.2　配置项和上下文 / 208
6.4.3　定义HTTP过滤模块 / 210
6.4.4　初始化HTTP过滤模块 / 211
6.4.5　处理请求中的HTTP头部 / 212
6.4.6　处理请求中的HTTP包体 / 213
6.5　小结 / 214
第7章　Nginx提供的高级数据结构 / 215
7.1　Nginx提供的高级数据结构概述 / 215
7.2　ngx_queue_t双向链表 / 217
7.2.1　为什么设计ngx_queue_t双向链表 / 217
7.2.2　双向链表的使用方法 / 217
7.2.3　使用双向链表排序的例子 / 219
7.2.4　双向链表是如何实现的 / 221
7.3　ngx_array_t动态数组 / 222
7.3.1　为什么设计ngx_array_t动态数组 / 223
7.3.2　动态数组的使用方法 / 223
7.3.3　 使用动态数组的例子 / 225
7.3.4　动态数组的扩容方式 / 226
7.4　ngx_list_t单向链表 / 226
7.5　ngx_rbtree_t红黑树 / 227
7.5.1　为什么设计ngx_rbtree_t红黑树 / 227
7.5.2　红黑树的特性 / 228
7.5.3　红黑树的使用方法 / 230
7.5.4　使用红黑树的简单例子 / 233
7.5.5　如何自定义添加成员方法 / 234
7.6　ngx_radix_tree_t基数树 / 236
7.6.1　ngx_radix_tree_t基数树的原理 / 236
7.6.2　基数树的使用方法 / 238
7.6.3　使用基数树的例子 / 239
7.7　支持通配符的散列表 / 240
7.7.1　ngx_hash_t基本散列表 / 240
7.7.2　支持通配符的散列表 / 243
7.7.3　带通配符散列表的使用例子 / 250
7.8　小结 / 254
第三部分　深入Nginx
第8章　Nginx基础架构 / 256
8.1　Web服务器设计中的关键约束 / 256
8.2　Nginx的架构设计 / 259
8.2.1　优秀的模块化设计 / 259
8.2.2　事件驱动架构 / 263
8.2.3　请求的多阶段异步处理 / 264
8.2.4　管理进程、多工作进程设计 / 267
8.2.5　平台无关的代码实现 / 268
8.2.6　内存池的设计 / 268
8.2.7　使用统一管道过滤器模式的HTTP过滤模块 / 268
8.2.8　其他一些用户模块 / 269
8.3　Nginx框架中的核心结构体ngx_cycle_t / 269
8.3.1　ngx_listening_t结构体 / 269
8.3.2　ngx_cycle_t结构体 / 271
8.3.3　ngx_cycle_t支持的方法 / 273
8.4　Nginx启动时框架的处理流程 / 275
8.5　worker进程是如何工作的 / 278
8.6　master进程是如何工作的 / 281
8.7　小结 / 286
第9章　事件模块 / 287
9.1　事件处理框架概述 / 287
9.2　Nginx事件的定义 / 290
9.3　Nginx连接的定义 / 293
9.3.1　被动连接 / 294
9.3.2　主动连接 / 297
9.3.3　ngx_connection_t连接池 / 298
9.4　ngx_events_module核心模块 / 300
9.4.1　如何管理所有事件模块的配置项 / 301
9.4.2　管理事件模块 / 303
9.5　ngx_event_core_module事件模块 / 305
9.6　epoll事件驱动模块 / 310
9.6.1　epoll的原理和用法 / 311
9.6.2　如何使用epoll / 313
9.6.3　ngx_epoll_module模块的实现 / 315
9.7　定时器事件 / 323
9.7.1　缓存时间的管理 / 324
9.7.2　缓存时间的精度 / 326
9.7.3　定时器的实现 / 327
9.8　事件驱动框架的处理流程 / 328
9.8.1　如何建立新连接 / 329
9.8.2　如何解决“惊群”问题 / 330
9.8.3　如何实现负载均衡 / 333
9.8.4　post事件队列 / 334
9.8.5　ngx_process_events_and_timers流程 / 335
9.9　文件的异步I/O / 338
9.9.1　Linux内核提供的文件异步I/O / 339
9.9.2　ngx_epoll_module模块中实现的针对文件的异步I/O / 342
9.10　小结 / 346
第10章　HTTP框架的初始化 / 347
10.1　HTTP框架概述 / 348
10.2　管理HTTP模块的配置项 / 351
10.2.1　管理main级别下的配置项 / 352
10.2.2　管理server级别下的配置项 / 354
10.2.3　管理location级别下的配置项 / 357
10.2.4　不同级别配置项的合并 / 362
10.3　监听端口的管理 / 367
10.4　server的快速检索 / 369
10.5　location的快速检索 / 371
10.6　HTTP请求的11个处理阶段 / 372
10.6.1　HTTP处理阶段的普适规则 / 374
10.6.2　NGX_HTTP_POST_READ_PHASE阶段 / 376
10.6.3　NGX_HTTP_SERVER_REWRITE_PHASE阶段 / 378
10.6.4　NGX_HTTP_FIND_CONFIG_PHASE阶段 / 379
10.6.5　NGX_HTTP_REWRITE_PHASE阶段 / 379
10.6.6　NGX_HTTP_POST_REWRITE_PHASE阶段 / 379
10.6.7　NGX_HTTP_PREACCESS_PHASE阶段 / 379
10.6.8　NGX_HTTP_ACCESS_PHASE阶段 / 380
10.6.9　NGX_HTTP_POST_ACCESS_PHASE阶段 / 380
10.6.10　NGX_HTTP_TRY_FILES_PHASE阶段 / 381
10.6.11　NGX_HTTP_CONTENT_PHASE阶段 / 381
10.6.12　NGX_HTTP_LOG_PHASE阶段 / 382
10.7　HTTP框架的初始化流程 / 383
10.8　小结 / 385
第11章　HTTP框架的执行流程 / 386
11.1　HTTP框架执行流程概述 / 387
11.2　新连接建立时的行为 / 388
11.3　第一次可读事件的处理 / 390
11.4　接收HTTP请求行 / 396
11.5　接收HTTP头部 / 399
11.6　处理HTTP请求 / 403
11.6.1　ngx_http_core_generic_phase / 409
11.6.2　ngx_http_core_rewrite_phase / 411
11.6.3　ngx_http_core_access_phase / 412
11.6.4　ngx_http_core_content_phase / 415
11.7　subrequest与post请求 / 419
11.8　处理HTTP包体 / 421
11.8.1　接收包体 / 422
11.8.2　放弃接收包体 / 429
11.9　发送HTTP响应 / 433
11.9.1　ngx_http_send_header / 434
11.9.2　ngx_http_output_filter / 436
11.9.3　ngx_http_writer / 440
11.10　结束HTTP请求 / 442
11.10.1　ngx_http_close_connection / 443
11.10.2　ngx_http_free_request / 444
11.10.3　ngx_http_close_request / 446
11.10.4　ngx_http_finalize_connection / 447
11.10.5　ngx_http_terminate_request / 447
11.10.6　ngx_http_finalize_request / 448
11.11　小结 / 452
第12章　upstream机制的设计与实现 / 453
12.1　upstream机制概述 / 453
12.1.1　设计目的 / 454
12.1.2　ngx_http_upstream_t数据结构的意义 / 456
12.1.3　ngx_http_upstream_conf_t配置结构体 / 459
12.2　启动upstream / 462
12.3　与上游服务器建立连接 / 464
12.4　发送请求到上游服务器 / 467
12.5　接收上游服务器的响应头部 / 470
12.5.1　应用层协议的两段划分方式 / 470
12.5.2　处理包体的3种方式 / 471
12.5.3　接收响应头部的流程 / 473
12.6　不转发响应时的处理流程 / 476
12.6.1　input_filter方法的设计 / 477
12.6.2　默认的input_filter方法 / 478
12.6.3　接收包体的流程 / 479
12.7　以下游网速优先来转发响应 / 481
12.7.1　转发响应的包头 / 482
12.7.2　转发响应的包体 / 484
12.8　以上游网速优先来转发响应 / 489
12.8.1　ngx_event_pipe_t结构体的意义 / 489
12.8.2　转发响应的包头 / 493
12.8.3　转发响应的包体 / 495
12.8.4　ngx_event_pipe_read_upstream方法 / 498
12.8.5　ngx_event_pipe_write_to_downstream方法 / 502
12.9　结束upstream请求 / 504
12.10　小结 / 508
第13章　邮件代理模块 / 509
13.1　邮件代理服务器的功能 / 509
13.2　邮件模块的处理框架 / 512
13.2.1　一个请求的8个独立处理阶段 / 512
13.2.2　邮件类模块的定义 / 514
13.2.3　邮件框架的初始化 / 516
13.3　初始化请求 / 517
13.3.1　描述邮件请求的ngx_mail_session_t结构体 / 517
13.3.2　初始化邮件请求的流程 / 519
13.4　接收并解析客户端请求 / 520
13.5　邮件认证 / 520
13.5.1　ngx_mail_auth_http_ctx_t结构体 / 520
13.5.2　与认证服务器建立连接 / 522
13.5.3　发送请求到认证服务器 / 522
13.5.4　接收并解析响应 / 525
13.6　与上游邮件服务器间的认证交互 / 526
13.6.1　ngx_mail_proxy_ctx_t结构体 / 526
13.6.2　向上游邮件服务器发起连接 / 527
13.6.3　与邮件服务器认证交互的过程 / 528
13.7　透传上游邮件服务器与客户端间的流 / 530
13.8　小结 / 535
第14章　进程间的通信机制 / 536
14.1　概述 / 536
14.2　共享内存 / 536
14.3　原子操作 / 541
14.3.1　不支持原子库下的原子操作 / 541
14.3.2　x86架构下的原子操作 / 542
14.3.3　自旋锁 / 545
14.4　Nginx频道 / 546
14.5　信号 / 549
14.6　信号量 / 551
14.7　文件锁 / 553
14.8　互斥锁 / 556
14.8.1　文件锁实现的ngx_shmtx_t锁 / 558
14.8.2　原子变量实现的ngx_shmtx_t锁 / 560
14.9　小结 / 565
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Nginx
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>系统架构
目录
系统架构原则
译者序
推荐序
前言
致谢
作者介绍
第一部分系统思维
第1章　系统架构简介……2
1.1　复杂系统的架构……2
1.2　良好架构的优势……2
1.3　学习目标……5
1.4　本书结构……6
1.5　参考资料……7
第2章　系统思维……8
2.1　简介……8
2.2　系统与涌现……8
2.2.1　系统……8
2.2.2　涌现……10
2.3　任务一：确定系统及其形式与功能……13
2.3.1　形式与功能……13
2.3.2　工具-过程-操作数：这是人类的标准思维模式吗……16
2.4　任务二：确定系统中的实体及其形式与功能……16
2.4.1　具备形式与功能的实体……17
2.4.2　确定如何将系统初步分解为恰当的实体……18
2.4.3　用整体思维找出系统中的潜在实体……19
2.4.4　集中注意力，找出系统中的重要实体……21
2.4.5　为实体创建抽象或从实体中发现抽象……22
2.4.6　定义系统的边界，并将其与外围环境隔开……24
2.5　任务三：确定实体之间的关系……25
2.5.1　关系的形式与功能……25
2.5.2　外部接口……28
2.6　任务四：涌现……28
2.6.1　涌现的重要性……28
2.6.2　系统故障……29
2.6.3　预测涌现物……30
2.6.4　涌现物依赖于实体及其关系……31
2.7　小结……32
2.8　参考资料……33
第3章　思考复杂的系统……34
3.1　简介……34
3.2　系统中的复杂度……34
3.2.1　复杂度……34
3.2.2　引入TeamXT这一范例系统……35
3.3　系统的分解……38
3.3.1　分解……38
3.3.2　体系……39
3.3.3　层级分解……39
3.3.4　简单的系统、复杂度适中的系统以及复杂的系统……41
3.3.5　原子部件……42
3.4　特殊的逻辑关系……43
3.4.1　类/实例关系……43
3.4.2　特化关系……43
3.4.3　递归……44
3.5　对复杂系统进行思索……44
3.5.1　自顶向下及自底向上式的思考……44
3.5.2　交替思考……45
3.6　架构展示工具：SysML与OPM……45
3.6.1　视图与投射……45
3.6.2　SysML……46
3.6.3　OPM……46
3.7　小结……49
3.8　参考资料……50
第二部分　系统架构的分析
第4章　形式……53
4.1　简介……53
4.2　架构中的形式……53
4.2.1　形式……53
4.2.2　用解析表示法来表现形式：对象……56
4.2.3　形式的分解……57
4.3　对架构中的形式进行分析……58
4.3.1　定义系统……58
4.3.2　确定形式实体……59
4.3.3　把泵作为复杂度适中的系统来分析……61
4.4　对架构中的形式关系进行分析……63
4.4.1　形式关系……63
4.4.2　空间/拓扑形式关系……65
4.4.3　用图和图表来展现形式关系：OPM……67
4.4.4　用表格及类似矩阵的视图来展现形式关系：DSM……70
4.4.5　连接性的形式关系……71
4.4.6　其他的形式关系……74
4.5　形式环境……75
4.5.1　伴生系统、整个产品系统及系统边界……75
4.5.2　使用情境……77
4.6　软件系统中的形式……77
4.6.1　软件系统：信息形式及其二元性……77
4.6.2　软件中的形式实体与形式关系……79
4.6.3　软件系统所在的整个产品系统、软件系统的边界及使用情境……81
4.7　小结……82
4.8　参考资料……82
第5章　功能……83
5.1　简介……83
5.2　架构中的功能……84
5.2.1　功能……84
5.2.2　把功能视为过程加操作数……84
5.2.3　用解析表示法来展现功能……85
5.3　分析对外展现的功能和价值……89
5.3.1　对外界展现的主要功能……89
5.3.2　与价值有关的操作数……90
5.4　对内部功能进行分析……93
5.4.1　内部功能……93
5.4.2　确定内部功能……94
5.5　分析功能交互及功能架构……97
5.5.1　功能交互与功能架构……97
5.5.2　确定功能交互……98
5.5.3　价值通路……100
5.5.4　涌现与细分……101
5.5.5　软件系统中的功能架构……102
5.6　与价值相关的次要外部功能及内部功能……105
5.7　小结……106
5.8　参考资料……107
第6章　系统架构……108
6.1　简介……108
6.2　系统架构：形式与功能……109
6.2.1　形式与功能之间的映射……109
6.2.2　确定形式与过程之间的映射……114
6.2.3　形式结构承载并展现功能交互……116
6.2.4　确定形式结构是如何承载功能和性能的……118
6.3　系统架构中的非理想因素、支持层及接口……119
6.3.1　系统架构中的非理想因素……119
6.3.2　系统架构中的支持功能及支持层……120
6.3.3　形式与功能中的系统接口……121
6.4　操作行为……123
6.4.1　操作者……124
6.4.2　行为……124
6.4.3　操作成本……126
6.5　用各种表示法来推究系统架构……127
6.5.1　能够对系统架构进行简化的几种方式……127
6.5.2　用投射法来表示系统的架构……128
6.5.3　把过程投射到对象……129
6.5.4　把过程和操作数投射到形式……130
6.6　小结……133
6.7　参考资料……134
第7章　与特定解决方案无关的功能和概念……135
7.1　简介……135
7.1.1　正向工程与更加复杂的系统……135
7.1.2　对与特定解决方案无关的功能和概念所做的介绍……136
7.2　确定与特定解决方案无关的功能……138
7.3　概念……140
7.3.1　作为一种观念的概念……140
7.3.2　对概念构想有所帮助的框架……142
7.3.3　构想概念时所应依循的步骤……144
7.3.4　为概念命名……145
7.3.5　对候选的概念进行整理……146
7.3.6　由更为广阔的概念所形成的体系……150
7.4　整体概念……152
7.5　操作概念与服务概念……156
7.6　小结……158
7.7　参考资料……159
第8章　从概念到架构……160
8.1　简介……160
8.2　研发系统之下第1级的架构……161
8.2.1　把概念扩展为功能架构……161
8.2.2　定义形式……162
8.2.3　把功能映射为形式……164
8.3　研发系统之下第2级的架构……166
8.3.1　第2级的功能意图以及对第2级所做的递归思考……166
8.3.2　研发第2级中的架构……166
8.4　家庭数据网络系统的第2级架构……170
8.5　为系统之下的第1级架构做模块化处理……173
8.6　小结……176
8.7　参考资料……177
第三部分　创建系统架构
第9章　架构师的角色……180
9.1　简介……180
9.2　歧义与架构师的角色……180
9.2.1　架构师的角色……180
9.2.2　减少歧义……182
9.2.3　架构师可以交付的成果……185
9.3　产品开发过程……186
9.3.1　各企业所使用的PDP之间的异同……187
9.3.2　通用的产品开发过程……191
9.4　小结……195
9.5　参考资料……199
第10章　上游和下游对系统架构的影响……200
10.1　简介……200
10.2　上游的影响因素：公司策略……201
10.3　上游的影响因素：营销……204
10.3.1　内向营销……205
10.4　上游的影响因素：法规及类似法规的因素……207
10.4.1　法规的来源……208
10.4.2　与法规类似的因素：可能出台的法规、标准和法律责任……209
10.5　上游的影响因素：技术融合……210
10.6　下游的影响因素：实现—编码、制造及供应链管理……212
10.7　下游的影响因素：操作……214
10.7.1　系统的登场与退场……215
10.7.2　偶发操作、应急操作与独立操作……216
10.8　下游的影响因素：DesignforX……216
10.9　下游的影响因素：产品与系统的演化、产品系列……218
10.9.1　复用与遗留元素……219
10.9.2　产品系列……220
10.9.3　平台与架构……221
10.10　产品论证：架构商业论证决策框架（ABCD）……224
10.11　小结……226
10.12　参考资料……229
第11章　将需求转换为目标……231
11.1　简介……231
11.2　确定受益者和利益相关者……232
11.2.1　受益者和利益相关者……232
11.2.2　确定受益者和利益相关者的需求……235
11.2.3　从交换中确定利益相关者及其需求……238
11.2.4　对利益相关者进行分组……240
11.3　描述需求的特征……242
11.3.1　从各种维度来描述利益相关者的需求……242
11.3.2　将利益相关者作为系统：间接的价值交付及利益相关者关系图……244
11.3.3　在各个利益相关者的需求之间排定优先次序……247
11.3.4　对排列各需求的优先次序所做的小结……251
11.4　把需求转换为目标……252
11.4.1　设定目标时所依据的标准……253
11.4.2　人类可以解决的目标：系统问题陈述……255
11.5　排列目标之间的优先次序……259
11.5.1　具备一致性与可达成性的目标……262
11.6　小结……263
11.7　参考资料……270
附：对利益相关者提出的系统需求所进行的特征分析……271
第12章　用创造力生成概念……272
12.1　简介……272
12.2　对概念进行创新……273
12.2.1　创新……273
12.2.2　无结构的创新……274
12.2.3　结构化的创新……274
12.2.4　确定概念……277
12.3　提出概念……278
12.4　扩充概念并提出概念片段……279
12.4.1　对推进功能进行扩充……279
12.4.2　混合动力车的另外7个内部功能所对应的概念片段……282
12.5　演化并完善整体概念……285
12.6　选出几个整体概念，做进一步的发展……288
12.7　小结……291
12.8　参考资料……295
第13章　把分解作为复杂度管理工具来使用……296
13.1　简介……296
13.2　理解复杂度……296
13.2.1　复杂度……296
13.2.2　复杂与难懂……299
13.2.3　必要的复杂度……301
13.3　管理复杂度……305
13.3.1　选定分解方式……305
13.3.2　模块化程度与分解……308
13.4　小结……312
13.5　参考资料……317
第四部分　作为决策的架构
第14章　作为决策制定过程的系统架构……321
14.1　简介……321
14.2　对阿波罗计划的架构决策问题进行公式化处理……322
14.2.1　做决策时可以考虑的经验法则……322
14.2.2　阿波罗计划的决策……323
14.2.3　约束及衡量指标……325
14.2.4　计算各种阿波罗架构的得分……327
14.3　决策与决策支持……328
14.4　决策支持系统的四项主要任务……330
14.5　基本的决策支持工具……331
14.5.1　形态矩阵……332
14.5.2　设计结构矩阵……332
14.5.3　决策树……334
14.6　为系统架构提供决策支持……338
14.7　小结……339
14.8　参考资料……340
第15章　探求架构的权衡空间……343
15.1　简介……343
15.2　权衡空间的基本知识……344
15.3　帕累托前沿……347
15.3.1　帕累托前沿与占优……347
15.3.2　GNC范例系统的帕累托前沿……348
15.3.3　模糊的帕累托前沿及其好处……351
15.3.4　在模糊的帕累托前沿上挖掘数据……352
15.3.5　帕累托前沿的运用机理……354
15.4　权衡空间的结构……355
15.5　敏感度分析……359
15.6　整理架构决策……364
15.6.1　对其他决策的影响……364
15.6.2　对衡量指标的影响……366
15.6.3　决策空间视图……367
15.6.4　对决策进行排序……368
15.6.5　对决策及其顺序的总结……370
15.7　小结……371
15.8　参考资料……372
第16章　系统架构优化问题的表述与求解……374
16.1　简介……374
16.2　对系统架构优化问题进行表述……375
16.3　NEOSS范例：NASA的地球观测卫星系统……379
16.4　系统架构决策中的模式……381
16.4.1　从程序化的决策到模式……382
16.4.2　DECISION-OPTION模式……383
16.4.3　DOWN-SELECTING模式……386
16.4.4　ASSIGNING模式……389
16.4.5　PARTITIONING模式……395
16.4.6　PERMUTING模式……399
16.4.7　CONNECTING模式……402
16.5　对大规模的系统架构问题进行表述……406
16.5.1　模式之间的重合……407
16.5.2　把问题分解为子问题……409
16.6　解决系统架构优化问题……410
16.6.1　介绍……410
16.6.2　全因子排列……411
16.6.3　启发式的架构优化算法……412
16.6.4　基于种群的通用启发式优化……413
16.6.5　生成初始种群……414
16.6.6　把某些固定的架构包含在初始种群中……415
16.6.7　通用的启发式和元启发式高效搜索……416
16.6.8　遗传算法中的启发式策略……416
16.6.9　用更多的启发式技术来强化遗传算法……418
16.7　小结……419
16.8　参考资料……420
附录A根据所选的架构集来计算衡量指标对决策的敏感度……423
附录B聚类算法及其在系统架构中的运用……425
附录C基于规则的系统及其在系统架构中的应用……430
附录D经典的组合优化问题……436
各章问题……441
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>系统架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Nginx（第2版）
第一部分　Nginx能帮我们做什么
第1章　研究Nginx前的准备工作 2
1.1　Nginx是什么 2
1.2　为什么选择Nginx 5
1.3　准备工作 7
1.3.1　Linux操作系统 7
1.3.2　使用Nginx的必备软件 7
1.3.3　磁盘目录 8
1.3.4　Linux内核参数的优化 9
1.3.5　获取Nginx源码 10
1.4　编译安装Nginx 11
1.5　configure详解 11
1.5.1　configure的命令参数 11
1.5.2　configure执行流程 18
1.5.3　configure生成的文件 21
1.6　Nginx的命令行控制 23
1.7　小结 27
第2章　Nginx的配置 28
2.1　运行中的Nginx进程间的关系 28
2.2　Nginx配置的通用语法 31
2.2.1　块配置项 31
2.2.2　配置项的语法格式 32
2.2.3　配置项的注释 33
2.2.4　配置项的单位 33
2.2.5　在配置中使用变量 33
2.3　Nginx服务的基本配置 34
2.3.1　用于调试进程和定位问题的配置项 34
2.3.2　正常运行的配置项 36
2.3.3　优化性能的配置项 37
2.3.4　事件类配置项 39
2.4　用HTTP核心模块配置一个静态Web服务器 40
2.4.1　虚拟主机与请求的分发 41
2.4.2　文件路径的定义 45
2.4.3　内存及磁盘资源的分配 47
2.4.4　网络连接的设置 49
2.4.5　MIME类型的设置 52
2.4.6　对客户端请求的限制 53
2.4.7　文件操作的优化 54
2.4.8　对客户端请求的特殊处理 56
2.4.9　ngx_http_core_module模块提供的变量 57
2.5　用HTTP proxy module配置一个反向代理服务器 59
2.5.1　负载均衡的基本配置 61
2.5.2　反向代理的基本配置 63
2.6　小结 66
第二部分　如何编写HTTP模块
第3章　开发一个简单的HTTP模块 68
3.1　如何调用HTTP模块 68
3.2　准备工作 70
3.2.1　整型的封装 71
3.2.2　ngx_str_t数据结构 71
3.2.3　ngx_list_t数据结构 71
3.2.4　ngx_table_elt_t数据结构 75
3.2.5　ngx_buf_t数据结构 75
3.2.6　ngx_chain_t数据结构 77
3.3　如何将自己的HTTP模块编译进Nginx 77
3.3.1　config文件的写法 77
3.3.2　利用configure脚本将定制的模块加入到Nginx中 78
3.3.3　直接修改Makefile文件 81
3.4　HTTP模块的数据结构 82
3.5　定义自己的HTTP模块 86
3.6　处理用户请求 89
3.6.1　处理方法的返回值 89
3.6.2　获取URI和参数 92
3.6.3　获取HTTP头部 94
3.6.4　获取HTTP包体 97
3.7　发送响应 99
3.7.1　发送HTTP头部 99
3.7.2　将内存中的字符串作为包体发送 101
3.7.3　经典的“Hello World”示例 102
3.8　将磁盘文件作为包体发送 103
3.8.1　如何发送磁盘中的文件 104
3.8.2　清理文件句柄 106
3.8.3　支持用户多线程下载和断点续传 107
3.9　用C++语言编写HTTP模块 108
3.9.1　编译方式的修改 108
3.9.2　程序中的符号转换 109
3.10　小结 110
第4章　配置、error日志和请求上下文 111
4.1　http配置项的使用场景 111
4.2　怎样使用http配置 113
4.2.1　分配用于保存配置参数的数据结构 113
4.2.2　设定配置项的解析方式 115
4.2.3　使用14种预设方法解析配置项 121
4.2.4　自定义配置项处理方法 131
4.2.5　合并配置项 133
4.3　HTTP配置模型 135
4.3.1　解析HTTP配置的流程 136
4.3.2　HTTP配置模型的内存布局 139
4.3.3　如何合并配置项 142
4.3.4　预设配置项处理方法的工作原理 144
4.4　error日志的用法 145
4.5　请求的上下文 149
4.5.1　上下文与全异步Web服务器的关系 149
4.5.2　如何使用HTTP上下文 151
4.5.3　HTTP框架如何维护上下文结构 152
4.6　小结 153
第5章　访问第三方服务 154
5.1　upstream的使用方式 155
5.1.1　ngx_http_upstream_t结构体 158
5.1.2　设置upstream的限制性参数 159
5.1.3　设置需要访问的第三方服务器地址 160
5.1.4　设置回调方法 161
5.1.5　如何启动upstream机制 161
5.2　回调方法的执行场景 162
5.2.1　create_request回调方法 162
5.2.2　reinit_request回调方法 164
5.2.3　finalize_request回调方法 165
5.2.4　process_header回调方法 165
5.2.5　rewrite_redirect回调方法 167
5.2.6　input_filter_init与input_filter回调方法 167
5.3　使用upstream的示例 168
5.3.1　upstream的各种配置参数 168
5.3.2　请求上下文 170
5.3.3　在create_request方法中构造请求 170
5.3.4　在process_header方法中解析包头 171
5.3.5　在finalize_request方法中释放资源 175
5.3.6　在ngx_http_mytest_handler方法中启动upstream 175
5.4　subrequest的使用方式 177
5.4.1　配置子请求的处理方式 177
5.4.2　实现子请求处理完毕时的回调方法 178
5.4.3　处理父请求被重新激活后的回调方法 179
5.4.4　启动subrequest子请求 179
5.5　subrequest执行过程中的主要场景 180
5.5.1　如何启动subrequest 180
5.5.2　如何转发多个子请求的响应包体 182
5.5.3　子请求如何激活父请求 185
5.6　subrequest使用的例子 187
5.6.1　配置文件中子请求的设置 187
5.6.2　请求上下文 188
5.6.3　子请求结束时的处理方法 188
5.6.4　父请求的回调方法 189
5.6.5　启动subrequest 190
5.7　小结 191
第6章　开发一个简单的HTTP过滤模块 192
6.1　过滤模块的意义 192
6.2　过滤模块的调用顺序 193
6.2.1　过滤链表是如何构成的 194
6.2.2　过滤链表的顺序 196
6.2.3　官方默认HTTP过滤模块的功能简介 197
6.3　HTTP过滤模块的开发步骤 198
6.4　HTTP过滤模块的简单例子 200
6.4.1　如何编写config文件 201
6.4.2　配置项和上下文 201
6.4.3　定义HTTP过滤模块 203
6.4.4　初始化HTTP过滤模块 204
6.4.5　处理请求中的HTTP头部 204
6.4.6　处理请求中的HTTP包体 206
6.5　小结 206
第7章　Nginx提供的高级数据结构 207
7.1　Nginx提供的高级数据结构概述 207
7.2　ngx_queue_t双向链表 209
7.2.1　为什么设计ngx_queue_t双向链表 209
7.2.2　双向链表的使用方法 209
7.2.3　使用双向链表排序的例子 212
7.2.4　双向链表是如何实现的 213
7.3　ngx_array_t动态数组 215
7.3.1　为什么设计ngx_array_t动态数组 215
7.3.2　动态数组的使用方法 215
7.3.3　 使用动态数组的例子 217
7.3.4　动态数组的扩容方式 218
7.4　ngx_list_t单向链表 219
7.5　ngx_rbtree_t红黑树 219
7.5.1　为什么设计ngx_rbtree_t红黑树 219
7.5.2　红黑树的特性 220
7.5.3　红黑树的使用方法 222
7.5.4　使用红黑树的简单例子 225
7.5.5　如何自定义添加成员方法 226
7.6　ngx_radix_tree_t基数树 228
7.6.1　ngx_radix_tree_t基数树的原理 228
7.6.2　基数树的使用方法 230
7.6.3　使用基数树的例子 231
7.7　支持通配符的散列表 232
7.7.1　ngx_hash_t基本散列表 232
7.7.2　支持通配符的散列表 235
7.7.3　带通配符散列表的使用例子 241
7.8　小结 245
第三部分　深入Nginx
第8章　Nginx基础架构 248
8.1　Web服务器设计中的关键约束 249
8.2　Nginx的架构设计 251
8.2.1　优秀的模块化设计 251
8.2.2　事件驱动架构 254
8.2.3　请求的多阶段异步处理 256
8.2.4　管理进程、多工作进程设计 259
8.2.5　平台无关的代码实现 259
8.2.6　内存池的设计 259
8.2.7　使用统一管道过滤器模式的HTTP过滤模块 260
8.2.8　其他一些用户模块 260
8.3　Nginx框架中的核心结构体ngx_cycle_t 260
8.3.1　ngx_listening_t结构体 261
8.3.2　ngx_cycle_t结构体 262
8.3.3　ngx_cycle_t支持的方法 264
8.4　Nginx启动时框架的处理流程 266
8.5　worker进程是如何工作的 269
8.6　master进程是如何工作的 271
8.7　ngx_pool_t内存池 276
8.8　小结 284
第9章　事件模块 285
9.1　事件处理框架概述 286
9.2　Nginx事件的定义 288
9.3　Nginx连接的定义 291
9.3.1　被动连接 292
9.3.2　主动连接 295
9.3.3　ngx_connection_t连接池 296
9.4　ngx_events_module核心模块 297
9.4.1　如何管理所有事件模块的配置项 299
9.4.2　管理事件模块 300
9.5　ngx_event_core_module事件模块 302
9.6　epoll事件驱动模块 308
9.6.1　epoll的原理和用法 308
9.6.2　如何使用epoll 310
9.6.3　ngx_epoll_module模块的实现 312
9.7　定时器事件 320
9.7.1　缓存时间的管理 320
9.7.2　缓存时间的精度 323
9.7.3　定时器的实现 323
9.8　事件驱动框架的处理流程 324
9.8.1　如何建立新连接 325
9.8.2　如何解决“惊群”问题 327
9.8.3　如何实现负载均衡 329
9.8.4　post事件队列 330
9.8.5　ngx_process_events_and_timers流程 331
9.9　文件的异步I/O 334
9.9.1　Linux内核提供的文件异步I/O 335
9.9.2　ngx_epoll_module模块中实现的针对文件的异步I/O 337
9.10　TCP协议与Nginx 342
9.11　小结 347
第10章　HTTP框架的初始化 348
10.1　HTTP框架概述 349
10.2　管理HTTP模块的配置项 352
10.2.1　管理main级别下的配置项 353
10.2.2　管理server级别下的配置项 355
10.2.3　管理location级别下的配置项 358
10.2.4　不同级别配置项的合并 364
10.3　监听端口的管理 367
10.4　server的快速检索 370
10.5　location的快速检索 370
10.6　HTTP请求的11个处理阶段 372
10.6.1　HTTP处理阶段的普适规则 374
10.6.2　NGX_HTTP_POST_READ_PHASE阶段 375
10.6.3　NGX_HTTP_SERVER_REWRITE_PHASE阶段 378
10.6.4　NGX_HTTP_FIND_CONFIG_PHASE阶段 378
10.6.5　NGX_HTTP_REWRITE_PHASE阶段 378
10.6.6　NGX_HTTP_POST_REWRITE_PHASE阶段 379
10.6.7　NGX_HTTP_PREACCESS_PHASE阶段 379
10.6.8　NGX_HTTP_ACCESS_PHASE阶段 379
10.6.9　NGX_HTTP_POST_ACCESS_PHASE阶段 380
10.6.10　NGX_HTTP_TRY_FILES_PHASE阶段 380
10.6.11　NGX_HTTP_CONTENT_PHASE阶段 380
10.6.12　NGX_HTTP_LOG_PHASE阶段 382
10.7　HTTP框架的初始化流程 382
10.8　小结 384
第11章　HTTP框架的执行流程 385
11.1　HTTP框架执行流程概述 386
11.2　新连接建立时的行为 387
11.3　第一次可读事件的处理 388
11.4　接收HTTP请求行 394
11.5　接收HTTP头部 398
11.6　处理HTTP请求 400
11.6.1　ngx_http_core_generic_phase 406
11.6.2　ngx_http_core_rewrite_phase 408
11.6.3　ngx_http_core_access_phase 409
11.6.4　ngx_http_core_content_phase 412
11.7　subrequest与post请求 415
11.8　处理HTTP包体 417
11.8.1　接收包体 419
11.8.2　放弃接收包体 425
11.9　发送HTTP响应 429
11.9.1　ngx_http_send_header 430
11.9.2　ngx_http_output_filter 432
11.9.3　ngx_http_writer 435
11.10　结束HTTP请求 437
11.10.1　ngx_http_close_connection 438
11.10.2　ngx_http_free_request 439
11.10.3　ngx_http_close_request 440
11.10.4　ngx_http_finalize_connection 441
11.10.5　ngx_http_terminate_request 443
11.10.6　ngx_http_finalize_request 443
11.11　小结 446
第12章　upstream机制的设计与实现 447
12.1　upstream机制概述 448
12.1.1　设计目的 448
12.1.2　ngx_http_upstream_t数据结构的意义 450
12.1.3　ngx_http_upstream_conf_t配置结构体 453
12.2　启动upstream 455
12.3　与上游服务器建立连接 457
12.4　发送请求到上游服务器 460
12.5　接收上游服务器的响应头部 463
12.5.1　应用层协议的两段划分方式 463
12.5.2　处理包体的3种方式 464
12.5.3　接收响应头部的流程 465
12.6　不转发响应时的处理流程 469
12.6.1　input_filter方法的设计 469
12.6.2　默认的input_filter方法 470
12.6.3　接收包体的流程 472
12.7　以下游网速优先来转发响应 473
12.7.1　转发响应的包头 474
12.7.2　转发响应的包体 477
12.8　以上游网速优先来转发响应 481
12.8.1　ngx_event_pipe_t结构体的意义 481
12.8.2　转发响应的包头 485
12.8.3　转发响应的包体 487
12.8.4　ngx_event_pipe_read_upstream方法 489
12.8.5　ngx_event_pipe_write_to_downstream方法 494
12.9　结束upstream请求 496
12.10　小结 499
第13章　邮件代理模块 500
13.1　邮件代理服务器的功能 500
13.2　邮件模块的处理框架 503
13.2.1　一个请求的8个独立处理阶段 503
13.2.2　邮件类模块的定义 504
13.2.3　邮件框架的初始化 506
13.3　初始化请求 506
13.3.1　描述邮件请求的ngx_mail_session_t结构体 506
13.3.2　初始化邮件请求的流程 509
13.4　接收并解析客户端请求 509
13.5　邮件认证 510
13.5.1　ngx_mail_auth_http_ctx_t结构体 510
13.5.2　与认证服务器建立连接 511
13.5.3　发送请求到认证服务器 513
13.5.4　接收并解析响应 514
13.6　与上游邮件服务器间的认证交互 514
13.6.1　ngx_mail_proxy_ctx_t结构体 516
13.6.2　向上游邮件服务器发起连接 516
13.6.3　与邮件服务器认证交互的过程 518
13.7　透传上游邮件服务器与客户端间的流 520
13.8　小结 524
第14章　进程间的通信机制 525
14.1　概述 525
14.2　共享内存 526
14.3　原子操作 530
14.3.1　不支持原子库下的原子操作 530
14.3.2　x86架构下的原子操作 531
14.3.3　自旋锁 533
14.4　Nginx频道 535
14.5　信号 538
14.6　信号量 540
14.7　文件锁 541
14.8　互斥锁 544
14.8.1　文件锁实现的ngx_shmtx_t锁 546
14.8.2　原子变量实现的ngx_shmtx_t锁 548
14.9　小结 553
第15章　变量 554
15.1　使用内部变量开发模块 555
15.1.1　定义模块 556
15.1.2　定义http模块加载方式 557
15.1.3　解析配置中的变量 558
15.1.4　处理请求 560
15.2　内部变量工作原理 561
15.2.1　何时定义变量 561
15.2.2　相关数据结构详述 564
15.2.3　定义变量的方法 572
15.2.4　使用变量的方法 572
15.2.5　如何解析变量 573
15.3　定义内部变量 576
15.4　外部变量与脚本引擎 577
15.4.1　相关数据结构 578
15.4.2　编译“set”脚本 581
15.4.3　脚本执行流程 586
15.5　小结 589
第16章　slab共享内存 590
16.1　操作slab共享内存的方法 590
16.2　使用slab共享内存池的例子 592
16.2.1　共享内存中的数据结构 593
16.2.2　操作共享内存中的红黑树与链表 595
16.2.3　解析配置文件 600
16.2.4　定义模块 603
16.3　slab内存管理的实现原理 605
16.3.1　内存结构布局 607
16.3.2　分配内存流程 613
16.3.3　释放内存流程 617
16.3.4　如何使用位操作 619
16.3.5　slab内存池间的管理 624
16.4　小结 624
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Nginx（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring技术内幕（第2版）
前言
第1章　spring的设计理念和整体架构 / 1
1.1　spring的各个子项目 / 2
1.2　spring的设计目标 / 5
1.3　spring的整体架构 / 7
1.4　spring的应用场景 / 10
1.5　小结 / 12
第一部分　spring核心实现篇
第2章　spring framework的核心：ioc容器的实现 / 16
2.1　spring ioc容器概述 / 17
2.1.1　ioc容器和依赖反转模式 / 17
2.1.2　spring ioc的应用场景 / 18
2.2　ioc容器系列的设计与实现：beanfactory和applicationcontext / 19
2.2.1　spring的ioc容器系列 / 19
2.2.2　spring ioc容器的设计 / 21
2.3　ic容器的初始化过程 / 28
2.3.1　beandefinition的resource定位 / 29
2.3.2　beandefinition的载入和解析 / 37
2.3.3　beandefinition在ioc容器中的注册 / 52
.2.4　ioc容器的依赖注入 / 54
2.5　容器其他相关特性的设计与实现 / 75
2.5.1　applicationcontext和bean的初始化及销毁 / 75
2.5.2　lazy-init属性和预实例化 / 81
2.5.3　factorybean的实现 / 82
2.5.4　beanpostprocessor的实现 / 85
2.5.5　autowiring（自动依赖装配）的实现 / 88
2.5.6　bean的依赖检查 / 90
2.5.7　bean对ioc容器的感知 / 91
2.6　小结 / 92
第3章　spring aop的实现 / 94
3.1　spring aop概述 / 95
3.1.1　aop概念回顾 / 95
3.1.2　advice通知 / 98
3.1.3　pointcut切点 / 102
3.1.4　advisor通知器 / 105
3.2　spring aop的设计与实现 / 106
3.2.1　jvm的动态代理特性 / 106
3.2.2　spring aop的设计分析 / 108
3.2.3　spring aop的应用场景 / 108
3.3　建立aopproxy代理对象 / 109
3.3.1　设计原理 / 109
3.3.2　配置proxyfactorybean / 110
3.3.3　proxyfactorybean生成aopproxy代理对象 / 111
3.3.4　jdk生成aopproxy代理对象 / 116
3.3.5　cglib生成aopproxy代理对象 / 117
3.4　spring aop拦截器调用的实现 / 119
3.4.1　设计原理 / 119
3.4.2　jdkdynamicaopproxy的invoke拦截 / 120
3.4.3　cglib2aopproxy的intercept拦截 / 121
3.4.4　目标对象方法的调用 / 122
3.4.5　aop拦截器链的调用 / 123
3.4.6　配置通知器 / 124
3.4.7　advice通知的实现 / 129
3.4.8　proxyfactory实现aop / 136
3.5　spring aop的高级特性 / 138
3.6　小结 / 140
第二部分　spring组件实现篇
第4章　spring mvc与web环境 / 145
4.1　spring mvc概述 / 146
4.2　web环境中的spring mvc / 148
4.3　上下文在web容器中的启动 / 149
4.3.1　ioc容器启动的基本过程 / 149
4.3.2　web容器中的上下文设计 / 151
4.3.3　contextloader的设计与实现 / 154
4.4　spring mvc的设计与实现 / 158
4.4.1　spring mvc的应用场景 / 158
4.4.2　spring mvc设计概览 / 158
4.4.3　dispatcherservlet的启动和初始化 / 160
4.4.4　mvc处理http分发请求 / 166
4.5　spring mvc视图的呈现 / 178
4.5.1　dispatcherservlet视图呈现的设计 / 178
4.5.2　jsp视图的实现 / 182
4.5.3　excelview的实现 / 185
4.5.4　pdf视图的实现 / 187
4.6　小结 / 189
第5章　数据库操作组件的实现 / 191
5.1　spring jdbc的设计与实现 / 192
5.1.1　应用场景 / 192
5.1.2　设计概要 / 192
5.2　spring jdbc中模板类的设计与实现 / 193
5.2.1　设计原理 / 193
5.2.2　jdbctemplate的基本使用 / 193
5.2.3　jdbctemplate的execute实现 / 194
5.2.4　jdbctemplate的query实现 / 196
5.2.5　使用数据库connection / 197
5.3　spring jdbc中rdbms操作对象的实现 / 199
5.3.1　sqlquery的实现 / 200
5.3.2　sqlupdate的实现 / 204
5.3.3　sqlfunction / 206
5.4　spring orm的设计与实现 / 208
5.4.1　应用场景 / 208
5.4.2　设计概要 / 208
5.5　spring驱动hibernate的设计与实现 / 209
5.5.1　设计原理 / 210
5.5.2　hibernate的sessionfactory / 210
5.5.3　hibernatetemplate的实现 / 215
5.5.4　session的管理 / 219
5.6　spring驱动ibatis的设计与实现 / 222
5.6.1　设计原理 / 222
5.6.2　创建sqlmapclient / 222
5.6.3　sqlmapclienttemplate的实现 / 224
5.7　小结 / 227
第6章　spring事务处理的实现 / 228
6.1　spring与事务处理 / 229
6.2　spring事务处理的设计概览 / 229
6.3　spring事务处理的应用场景 / 230
6.4　spring声明式事务处理 / 231
6.4.1　设计原理与基本过程 / 231
6.4.2　实现分析 / 231
6.5　spring事务处理的设计与实现 / 241
6.5.1　spring事务处理的编程式使用 / 241
6.5.2　事务的创建 / 242
6.5.3　事务的挂起 / 249
6.5.4　事务的提交 / 251
6.5.5　事务的回滚 / 253
6.6　spring事务处理器的设计与实现 / 255
6.6.1　spring事务处理的应用场景 / 255
6.6.2　datasourcetransactionmanager的实现 / 256
6.6.3　hibernatetransactionmanager的实现 / 259
6.7　小结 / 265
第7章　spring远端调用的实现 / 267
7.1　spring远端调用的应用场景 / 268
7.2　spring远端调用的设计概览 / 268
7.3　spring远端调用的实现 / 271
7.3.1　spring http调用器的实现 / 271
7.3.2　spring hession/burlap的实现原理 / 282
7.3.3　spring rmi的实现 / 295
7.4　小结 / 302
第三部分　spring应用实现篇
第8章　安全框架acegi的设计与实现 / 307
8.1　spring acegi安全框架概述 / 308
8.1.1　概述 / 308
8.1.2　设计原理与基本实现过程 / 308
8.1.3　acegi的bean配置 / 309
8.2　配置spring acegi / 310
8.3　acegi的web过滤器实现 / 313
8.4　acegi验证器的实现 / 315
8.4.1　authenticationmanager的authenticate / 315
8.4.2　daoauthenticationprovider的实现 / 318
8.4.3　读取数据库用户信息 / 320
8.4.4　完成用户信息的对比验证 / 323
8.5　acegi授权器的实现 / 324
8.5.1　与web环境的接口filtersecurityinterceptor / 324
8.5.2　授权器的实现 / 327
8.5.3　投票器的实现 / 329
8.6　小结 / 330
第9章　spring dm模块的设计与实现 / 332
9.1　spring dm模块的应用场景 / 333
9.2　spring dm的应用过程 / 334
9.3　spring dm设计与实现 / 338
9.4　小结 / 348
第10章　spring flex的设计与实现 / 350
10.1　spring flex模块的应用场景 / 351
10.2　spring flex的应用过程 / 353
10.3　spring flex的设计与实现 / 355
10.4　小结 / 362
附录a　spring项目的源代码环境 / 363
附录b　构建spring项目的发布包 / 378
附录c　使用spring ide / 381
附录d　spring pet clinic应用实例 / 385
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring技术内幕（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件架构师应该知道的97件事
前言
客户需求重于个人简历
简化根本复杂性，消除偶发复杂性
关键问题可能不是出在技术上
以沟通为中心，坚持简明清晰的表达方式和开明的领导风格
架构决定性能
分析客户需求背后的意义
起立发言
故障终究会发生
我们常常忽略了自己在谈判
量化需求
一行代码比五百行架构说明更有价值
不存在放之四海皆准的解决方案
提前关注性能问题
架构设计要平衡兼顾多方需求
草率提交任务是不负责任的行为
不要在一棵树上吊死
业务目标至上
先确保解决方案简单可用，再考虑通用性和复用性
架构师应该亲力亲为
持续集成
避免进度调整失误
取舍的艺术
打造数据库堡垒
重视不确定性
不要轻易放过不起眼的问题
让大家学会复用
架构里没有大写的“i”
使用“一千英尺高”的视图
先尝试后决策
掌握业务领域知识
程序设计是一种设计
让开发人员自己做主
时间改变一切
设立软件架构专业为时尚早
控制项目规模
架构师不是演员，是管家
软件架构的道德责任
摩天大厦不可伸缩
混合开发的时代已经来临
性能至上
留意架构图里的空白区域
学习软件专业的行话
具体情境决定一切
侏儒、精灵、巫师和国王
向建筑师学习
避免重复
欢迎来到现实世界
仔细观察，别试图控制一切
架构师好比两面神
架构师当聚焦于边界和接口
助力开发团队
记录决策理由
挑战假设尤其是你自己的
分享知识和经验
模式病
不要滥用架构隐喻
关注应用程序的支持和维护
有舍才有得
先考虑原则、公理和类比再考虑个人意见和口味
从“可行走骨架”开始开发应用
数据是核心
确保简单问题有简单的解
架构师首先是开发人员
根据投资回报率（roi）进行决策
一切软件系统都是遗留系统
起码要有两个可选的解决方案
理解变化的影响
你不能不了解硬件
现在走捷径，将来付利息
不要追求“完美”，“足够好”就行
小心“好主意”
内容为王
对商业方，架构师要避免愤世嫉俗
拉伸关键维度，发现设计中的不足
架构师要以自己的编程能力为依托
命名要恰如其分
稳定的问题才能产生高质量的解决方案
天道酬勤
对决策负责
弃聪明，求质朴
精心选择有效技术，绝不轻易抛弃
客户的客户才是你的客户！
事物发展总会出人意料
选择彼此间可协调工作的框架
着重强调项目的商业价值
不仅仅只控制代码，也要控制数据
偿还技术债务
不要急于求解
打造上手（zuhanden）的系统
找到并留住富有激情的问题解决者
软件并非真实的存在
学习新语言
没有永不过时的解决方案
用户接受度问题
清汤的重要启示
对*终用户而言，界面就是系统
优秀软件不是构建出来的，而是培育起来的
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件架构师应该知道的97件事
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业应用架构模式
译者序
前言
模式列表
引言 1
0.1 架构 1
0.2 企业应用 2
0.3 企业应用的种类 3
0.4 关于性能的考虑 4
0.5 模式 6
0.5.1 模式的结构 7
0.5.2 模式的局限性 9
第一部分 表述
第1章 分层 12
1.1 企业应用中层次的演化 13
1.2 三个基本层次 14
1.3 为各层选择运行环境 15
第2章 组织领域逻辑 19
2.1 抉择 22
2.2 服务层 23
第3章 映射到关系数据库 25
.3.1 架构模式 25
3.2 行为问题 28
3.3 读取数据 29
3.4 结构映射模式 30
3.4.1 关系的映射 30
3.4.2 继承 33
3.5 建立映射 34
3.6 使用元数据 35
3.7 数据库连接 36
3.8 其他问题 38
3.9 进一步阅读 38
第4章 Web表现层 39
4.1 视图模式 41
4.2 输入控制器模式 43
4.3 进一步阅读 43
第5章 并发 45
5.1 并发问题 45
5.2 执行语境 46
5.3 隔离与不变性 47
5.4 乐观并发控制和悲观并发控制 48
5.4.1 避免不一致读 49
5.4.2 死锁 49
5.5 事务 50
5.5.1 ACID 51
5.5.2 事务资源 51
5.5.3 减少事务隔离以提高灵活性 52
5.5.4 业务事务和系统事务 53
5.6 离线并发控制的模式 54
5.7 应用服务器并发 55
5.8 进一步阅读 56
第6章 会话状态 57
6.1 无状态的价值 57
6.2 会话状态 58
6.3 存储会话状态的方法 59
第7章 分布策略 61
7.1 分布对象的诱惑 61
7.2 远程接口和本地接口 62
7.3 必须使用分布的情况 63
7.4 关于分布边界 64
7.5 分布接口 64
第8章 通盘考虑 67
8.1 从领域层开始 67
8.2 深入到数据源层 68
8.2.1 事务脚本的数据源 68
8.2.2 表模块的数据源 69
8.2.3 领域模型的数据源 69
8.3 表现层 69
8.4 一些关于具体技术的建议 70
8.4.1 Java和J2EE 70
8.4.2 .NET 71
8.4.3 存储过程 71
8.4.4 Web Services 72
8.5 其他分层方式 72
第二部分 模 式
第9章 领域逻辑模式 76
9.1 事务脚本（Transaction Script） 76
9.1.1 运行机制 76
9.1.2 使用时机 77
9.1.3 收入确认问题 78
9.1.4 例：收入确认（Java） 78
9.2 领域模型（Domain Model） 81
9.2.1 运行机制 81
9.2.2 使用时机 83
9.2.3 进一步阅读 83
9.2.4 例：收入确认（Java） 84
9.3 表模块（Table Module） 87
9.3.1 运行机制 88
9.3.2 使用时机 90
9.3.3 例：基于表模块的收入确认（C#） 90
9.4 服务层（Service Layer） 93
9.4.1 运行机制 94
9.4.2 使用时机 96
9.4.3 进一步阅读 96
9.4.4 例：收入确认（Java） 96
第10章 数据源架构模式 101
10.1 表数据入口（Table Data Gateway） 101
10.1.1 运行机制 101
10.1.2 使用时机 102
10.1.3 进一步阅读 102
10.1.4 例：人员入口（C#） 103
10.1.5 例：使用ADO.NET数据集（C#） 104
10.2 行数据入口（Row Data Gateway） 106
10.2.1 运行机制 107
10.2.2 使用时机 108
10.2.3 例：人员记录（Java） 108
10.2.4 例：领域对象的数据保持器（Java） 111
10.3 活动记录（Active Record） 112
10.3.1 运行机制 112
10.3.2 使用时机 113
10.3.3 例：一个简单的Person类（Java） 113
10.4 数据映射器（Data Mapper） 115
10.4.1 运行机制 116
10.4.2 使用时机 119
10.4.3 例：一个简单的数据映射器（Java） 119
10.4.4 例：分离查找方法（Java） 123
10.4.5 例：创建一个空对象（Java） 126
第11章 对象－关系行为模式 129
11.1 工作单元（Unit of Work） 129
11.1.1 运行机制 129
11.1.2 使用时机 133
11.1.3 例：使用对象注册的工作单元（Java） 134
11.2 标识映射（Identity Map） 137
11.2.1 运行机制 137
11.2.2 使用时机 139
11.2.3 例：标识映射中的方法（Java） 139
11.3 延迟加载（Lazy Load） 140
11.3.1 运作机制 140
11.3.2 使用时机 142
11.3.3 例：延迟初始化（Java） 142
11.3.4 例：虚代理（Java） 142
11.3.5 例：使用值保持器（Java） 144
11.3.6 例：使用重影（C#） 144
第12章 对象－关系结构模式 151
12.1 标识域（Identity Field） 151
12.1.1 工作机制 151
12.1.2 使用时机 154
12.1.3 进一步阅读 154
12.1.4 例：整型键（C#） 154
12.1.5 例：使用键表（Java） 155
12.1.6 例：使用组合键（Java） 157
12.2 外键映射（Foreign Key Mapping） 166
12.2.1 运行机制 167
12.2.2 使用时机 169
12.2.3 例：单值引用（Java） 169
12.2.4 例：多表查询（Java） 172
12.2.5 例：引用集合（C#） 173
12.3 关联表映射（Association Table Mapping） 175
12.3.1 运行机制 176
12.3.2 使用时机 176
12.3.3 例：雇员和技能（C#） 177
12.3.4 例：使用直接的SQL（Java） 179
12.3.5 例：用一次查询查多个雇员（Java） 182
12.4 依赖映射（Dependent Mapping） 186
12.4.1 运行机制 186
12.4.2 使用时机 187
12.4.3 例：唱片和曲目（Java） 188
12.5 嵌入值（Embedded Value） 190
12.5.1 运行机制 190
12.5.2 使用时机 190
12.5.3 进一步阅读 191
12.5.4 例：简单值对象（Java） 191
12.6 序列化LOB（Serialized LOB） 192
12.6.1 运行机制 193
12.6.2 使用时机 194
12.6.3 例：在XML中序列化一个部门层级（Java） 194
12.7 单表继承（Single Table Inheritance） 196
12.7.1 运行机制 197
12.7.2 使用时机 197
12.7.3 例：运动员的单表（C#） 198
12.7.4 从数据库中加载对象 199
12.8 类表继承（Class Table Inheritance） 202
12.8.1 运行机制 202
12.8.2 使用时机 203
12.8.3 进一步阅读 203
12.8.4 例：运动员和他们的家属（C#） 203
12.9 具体表继承（Concrete Table Inheritance） 208
12.9.1 运行机制 209
12.9.2 使用时机 210
12.9.3 例：具体运动员（C#） 210
12.10 继承映射器（Inheritance Mappers） 214
12.10.1 运行机制 215
12.10.2 使用时机 216
第13章 对象－关系元数据映射模式 217
13.1 元数据映射（Metadata Mapping） 217
13.1.1 运行机制 217
13.1.2 使用时机 218
13.1.3 例：使用元数据和反射（Java） 219
13.2 查询对象（Query Object） 224
13.2.1 运行机制 225
13.2.2 使用时机 225
13.2.3 进一步阅读 226
13.2.4 例：简单的查询对象（Java） 226
13.3 资源库（Repository） 228
13.3.1 运行机制 229
13.3.2 使用时机 230
13.3.3 进一步阅读 231
13.3.4 例：查找一个人所在的部门（Java） 231
13.3.5 例：资源库交换策略（Java） 231
第14章 Web表现模式 233
14.1 模型－视图－控制器（Model View Controller） 233
14.1.1 运行机制 233
14.1.2 使用时机 234
14.2 页面控制器（Page Controller） 235
14.2.1 运行机制 235
14.2.2 使用时机 236
14.2.3 例：Servlet控制器和JSP视图的简单演示（Java） 236
14.2.4 例：使用JSP充当处理程序（Java） 238
14.2.5 例：代码隐藏的页面控制器（C#） 241
14.3 前端控制器（Front Controller） 243
14.3.1 运行机制 244
14.3.2 使用时机 245
14.3.3 进一步阅读 246
14.3.4 例：简单的显示（Java） 246
14.4 模板视图（Template View） 248
14.4.1 运行机制 249
14.4.2 使用时机 251
14.4.3 例：分离的控制器，使用JSP充当视图（Java） 252
14.4.4 例：ASP.NET服务器页面（C#） 253
14.5 转换视图（Transform View） 256
14.5.1 运行机制 256
14.5.2 使用时机 257
14.5.3 例：简单的转换（Java） 257
14.6 两步视图（Two Step View） 259
14.6.1 运行机制 259
14.6.2 使用时机 260
14.6.3 例：两阶XSLT（XSLT） 264
14.6.4 例：JSP和定制标记（Java） 266
14.7 应用控制器（Application Controller） 269
14.7.1 运行机制 270
14.7.2 使用时机 271
14.7.3 进一步阅读 271
14.7.4 例：状态模型应用控制器（Java） 271
第15章 分布模式 275
15.1 远程外观（Remote Facade） 275
15.1.1 运行机制 276
15.1.2 使用时机 278
15.1.3 例：使用Java语言的会话bean来作为远程外观（Java） 278
15.1.4 例：Web Service（C#） 281
15.2 数据传输对象（Data Transfer Object） 285
15.2.1 运行机制 285
15.2.2 使用时机 288
15.2.3 进一步阅读 289
15.2.4 例：传输唱片信息（Java） 289
15.2.5 例：使用XML实现序列化（Java） 293
第16章 离线并发模式 295
16.1 乐观离线锁（Optimistic Offline Lock） 295
16.1.1 运行机制 296
16.1.2 使用时机 298
16.1.3 例：领域层与数据映射器（Java） 298
16.2 悲观离线锁（Pessimistic Offline Lock） 302
16.2.1 运行机制 303
16.2.2 使用时机 305
16.2.3 例：简单锁管理对象（Java） 305
16.3 粗粒度锁（Coarse-Grained Lock） 310
16.3.1 运行机制 310
16.3.2 使用时机 312
16.3.3 例：共享的乐观离线锁（Java） 312
16.3.4 例：共享的悲观离线锁（Java） 316
16.3.5 例：根对象乐观离线锁（Java） 317
16.4 隐含锁（Implicit Lock） 318
16.4.1 运行机制 318
16.4.2 使用时机 319
16.4.3 例：隐含的悲观离线锁（Java） 319
第17章 会话状态模式 321
17.1 客户会话状态（Client Session State） 321
17.1.1 运行机制 321
17.1.2 使用时机 322
17.2 服务器会话状态（Server Session State） 322
17.2.1 运行机制 322
17.2.2 使用时机 324
17.3 数据库会话状态（Database Session State） 324
17.3.1 运行机制 324
17.3.2 使用时机 325
第18章 基本模式 327
18.1 入口（Gateway） 327
18.1.1 运行机制 327
18.1.2 使用时机 328
18.1.3 例：私有消息服务的入口（Java） 329
18.2 映射器（Mapper） 331
18.2.1 运行机制 332
18.2.2 使用时机 332
18.3 层超类型（Layer Supertype） 332
18.3.1 运行机制 332
18.3.2 使用时机 333
18.3.3 例：领域对象（Java） 333
18.4 分离接口（Separated Interface） 333
18.4.1 运行机制 334
18.4.2 使用时机 335
18.5 注册表（Registry） 335
18.5.1 运行机制 336
18.5.2 使用时机 337
18.5.3 例：单子注册表（Java） 337
18.5.4 例：线程安全的注册表（Java） 338
18.6 值对象（Value Object） 339
18.6.1 运行机制 339
18.6.2 使用时机 340
18.7 货币（Money） 340
18.7.1 运行机制 341
18.7.2 使用时机 342
18.7.3 例：货币类（Java） 343
18.8 特殊情况（Special Case） 346
18.8.1 运行机制 347
18.8.2 使用时机 347
18.8.3 进一步阅读 347
18.8.4 例：一个简单的空对象（C#） 347
18.9 插件（Plugin） 348
18.9.1 运行机制 349
18.9.2 使用时机 350
18.9.3 例：ID生成器（Java） 350
18.10 服务桩（Service Stub） 352
18.10.1 运行机制 352
18.10.2 使用时机 353
18.10.3 例：销售税服务（Java） 353
18.11 记录集（Record Set） 355
18.11.1 运行机制 355
18.11.2 使用时机 356
参考文献 359
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业应用架构模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>亿级流量网站架构核心技术
第1部分 概述 / 1
1 交易型系统设计的一些原则 / 2
1.1 高并发原则 / 3
1.1.1 无状态 / 3
1.1.2 拆分 / 3
1.1.3 服务化 / 4
1.1.4 消息队列 / 4
1.1.5 数据异构 / 6
1.1.6 缓存银弹 / 7
1.1.7 并发化 / 9
1.2 高可用原则 / 10
1.2.1 降级 / 10
1.2.2 限流 / 11
1.2.3 切流量 / 12
1.2.4 可回滚 / 12
1.3 业务设计原则 / 12
1.3.1 防重设计 / 13
1.3.2 幂等设计 / 13
1.3.3 流程可定义 / 13
1.3.4 状态与状态机 / 13
1.3.5 后台系统操作可反馈 / 14
1.3.6 后台系统审批化 / 14
1.3.7 文档和注释 / 14
1.3.8 备份 / 14
1.4 总结 / 14
第2部分 高可用 / 17
2 负载均衡与反向代理 / 18
2.1 upstream配置 / 20
2.2 负载均衡算法 / 21
2.3 失败重试 / 23
2.4 健康检查 / 24
2.4.1 TCP心跳检查 / 24
2.4.2 HTTP心跳检查 / 25
2.5 其他配置 / 25
2.5.1 域名上游服务器 / 25
2.5.2 备份上游服务器 / 26
2.5.3 不可用上游服务器 / 26
2.6 长连接 / 26
2.7 HTTP反向代理示例 / 29
2.8 HTTP动态负载均衡 / 30
2.8.1 Consul+Consul-template / 31
2.8.2 Consul+OpenResty / 35
2.9 Nginx四层负载均衡 / 39
2.9.1 静态负载均衡 / 39
2.9.2 动态负载均衡 / 41
参考资料 / 42
3 隔离术 / 43
3.1 线程隔离 / 43
3.2 进程隔离 / 45
3.3 集群隔离 / 45
3.4 机房隔离 / 46
3.5 读写隔离 / 47
3.6 动静隔离 / 48
3.7 爬虫隔离 / 49
3.8 热点隔离 / 50
3.9 资源隔离 / 50
3.10 使用Hystrix实现隔离 / 51
3.10.1 Hystrix简介 / 51
3.10.2 隔离示例 / 52
3.11 基于Servlet 3实现请求隔离 / 56
3.11.1 请求解析和业务处理线程池分离 / 57
3.11.2 业务线程池隔离 / 58
3.11.3 业务线程池监控/运维/降级 / 58
3.11.4 如何使用Servlet 3异步化 / 59
3.11.5 一些Servlet 3异步化压测数据 / 64
4 限流详解 / 66
4.1 限流算法 / 67
4.1.1 令牌桶算法 / 67
4.1.2 漏桶算法 / 68
4.2 应用级限流 / 69
4.2.1 限流总并发/连接/请求数 / 69
4.2.2 限流总资源数 / 70
4.2.3 限流某个接口的总并发/请求数 / 70
4.2.4 限流某个接口的时间窗请求数 / 70
4.2.5 平滑限流某个接口的请求数 / 71
4.3 分布式限流 / 75
4.3.1 Redis+Lua实现 / 76
4.3.2 Nginx+Lua实现 / 77
4.4 接入层限流 / 78
4.4.1 ngx_http_limit_conn_module / 78
4.4.2 ngx_http_limit_req_module / 80
4.4.3 lua-resty-limit-traffic / 88
4.5 节流 / 90
4.5.1 throttleFirst/throttleLast / 90
4.5.2 throttleWithTimeout / 91
参考资料 / 92
5 降级特技 / 93
5.1 降级预案 / 93
5.2 自动开关降级 / 95
5.2.1 超时降级 / 95
5.2.2 统计失败次数降级 / 95
5.2.3 故障降级 / 95
5.2.4 限流降级 / 95
5.3 人工开关降级 / 96
5.4 读服务降级 / 96
5.5 写服务降级 / 97
5.6 多级降级 / 98
5.7 配置中心 / 100
5.7.1 应用层API封装 / 100
5.7.2 配置文件实现开关配置 / 101
5.7.3 配置中心实现开关配置 / 102
5.8 使用Hystrix实现降级 / 106
5.9 使用Hystrix实现熔断 / 108
5.9.1 熔断机制实现 / 108
5.9.2 配置示例 / 112
5.9.3 采样统计 / 113
6 超时与重试机制 / 117
6.1 简介 / 117
6.2 代理层超时与重试 / 119
6.2.1 Nginx / 119
6.2.2 Twemproxy / 126
6.3 Web容器超时 / 127
6.4 中间件客户端超时与重试 / 127
6.5 数据库客户端超时 / 131
6.6 NoSQL客户端超时 / 134
6.7 业务超时 / 135
6.8 前端Ajax超时 / 135
6.9 总结 / 136
6.10 参考资料 / 137
7 回滚机制 / 139
7.1 事务回滚 / 139
7.2 代码库回滚 / 140
7.3 部署版本回滚 / 141
7.4 数据版本回滚 / 142
7.5 静态资源版本回滚 / 143
8 压测与预案 / 145
8.1 系统压测 / 145
8.1.1 线下压测 / 146
8.1.2 线上压测 / 146
8.2 系统优化和容灾 / 147
8.3 应急预案 / 148
第3部分 高并发 / 153
9 应用级缓存 / 154
9.1 缓存简介 / 154
9.2 缓存命中率 / 155
9.3 缓存回收策略 / 155
9.3.1 基于空间 / 155
9.3.2 基于容量 / 155
9.3.3 基于时间 / 155
9.3.4 基于Java对象引用 / 156
9.3.5 回收算法 / 156
9.4 Java缓存类型 / 156
9.4.1 堆缓存 / 158
9.4.2 堆外缓存 / 162
9.4.3 磁盘缓存 / 162
9.4.4 分布式缓存 / 164
9.4.5 多级缓存 / 166
9.5 应用级缓存示例 / 167
9.5.1 多级缓存API封装 / 167
9.5.2 NULL Cache / 170
9.5.3 强制获取最新数据 / 170
9.5.4 失败统计 / 171
9.5.5 延迟报警 / 171
9.6 缓存使用模式实践 / 172
9.6.1 Cache-Aside / 173
9.6.2 Cache-As-SoR / 174
9.6.3 Read-Through / 174
9.6.4 Write-Through / 176
9.6.5 Write-Behind / 177
9.6.6 Copy Pattern / 181
9.7 性能测试 / 181
9.8 参考资料 / 182
10 HTTP缓存 / 183
10.1 简介 / 183
10.2 HTTP缓存 / 184
10.2.1 Last-Modified / 184
10.2.2 ETag / 190
10.2.3 总结 / 192
10.3 HttpClient客户端缓存 / 192
10.3.1 主流程 / 195
10.3.2 清除无效缓存 / 195
10.3.3 查找缓存 / 196
10.3.4 缓存未命中 / 198
10.3.5 缓存命中 / 198
10.3.6 缓存内容陈旧需重新验证 / 202
10.3.7 缓存内容无效需重新执行请求 / 205
10.3.8 缓存响应 / 206
10.3.9 缓存头总结 / 207
10.4 Nginx HTTP缓存设置 / 208
10.4.1 expires / 208
10.4.2 if-modified-since / 209
10.4.3 nginx proxy_pass / 209
10.5 Nginx代理层缓存 / 212
10.5.1 Nginx代理层缓存配置 / 212
10.5.2 清理缓存 / 215
10.6 一些经验 / 216
参考资料 / 217
11 多级缓存 / 218
11.1 多级缓存介绍 / 218
11.2 如何缓存数据 / 220
11.2.1 过期与不过期 / 220
11.2.2 维度化缓存与增量缓存 / 221
11.2.3 大Value缓存 / 221
11.2.4 热点缓存 / 221
11.3 分布式缓存与应用负载均衡 / 222
11.3.1 缓存分布式 / 222
11.3.2 应用负载均衡 / 222
11.4 热点数据与更新缓存 / 223
11.4.1 单机全量缓存+主从 / 223
11.4.2 分布式缓存+应用本地热点 / 224
11.5 更新缓存与原子性 / 225
11.6 缓存崩溃与快速修复 / 226
11.6.1 取模 / 226
11.6.2 一致性哈希 / 226
11.6.3 快速恢复 / 226
12 连接池线程池详解 / 227
12.1 数据库连接池 / 227
12.1.1 DBCP连接池配置 / 228
12.1.2 DBCP配置建议 / 233
12.1.3 数据库驱动超时实现 / 234
12.1.4 连接池使用的一些建议 / 235
12.2 HttpClient连接池 / 236
12.2.1 HttpClient 4.5.2配置 / 236
12.2.2 HttpClient连接池源码分析 / 240
12.2.3 HttpClient 4.2.3配置 / 241
12.2.4 问题示例 / 243
12.3 线程池 / 244
12.3.1 Java线程池 / 245
12.3.2 Tomcat线程池配置 / 248
13 异步并发实战 / 250
13.1 同步阻塞调用 / 251
13.2 异步Future / 252
13.3 异步Callback / 253
13.4 异步编排CompletableFuture / 254
13.5 异步Web服务实现 / 257
13.6 请求缓存 / 259
13.7 请求合并 / 261
14 如何扩容 / 266
14.1 单体应用垂直扩容 / 267
14.2 单体应用水平扩容 / 267
14.3 应用拆分 / 268
14.4 数据库拆分 / 271
14.5 数据库分库分表示例 / 275
14.5.1 应用层还是中间件层 / 275
14.5.2 分库分表策略 / 277
14.5.3 使用sharding-jdbc分库分表 / 279
14.5.4 sharding-jdbc分库分表配置 / 279
14.5.5 使用sharding-jdbc读写分离 / 283
14.6 数据异构 / 284
14.6.1 查询维度异构 / 284
14.6.2 聚合数据异构 / 285
14.7 任务系统扩容 / 285
14.7.1 简单任务 / 285
14.7.2 分布式任务 / 287
14.7.3 Elastic-Job简介 / 287
14.7.4 Elastic-Job-Lite功能与架构 / 287
14.7.5 Elastic-Job-Lite示例 / 288
15 队列术 / 295
15.1 应用场景 / 295
15.2 缓冲队列 / 296
15.3 任务队列 / 297
15.4 消息队列 / 297
15.5 请求队列 / 299
15.6 数据总线队列 / 300
15.7 混合队列 / 301
15.8 其他队列 / 302
15.9 Disruptor+Redis队列 / 303
15.10 下单系统水平可扩展架构 / 311
第4部分 案例 / 323
16 构建需求响应式亿级商品详情页 / 324
16.1 商品详情页是什么 / 324
16.2 商品详情页前端结构 / 325
16.3 我们的性能数据 / 327
16.4 单品页流量特点 / 327
16.5 单品页技术架构发展 / 327
16.5.1 架构1.0 / 328
16.5.2 架构2.0 / 328
16.5.3 架构3.0 / 330
16.6 详情页架构设计原则 / 332
16.7 遇到的一些坑和问题 / 339
16.8 其他 / 347
17 京东商品详情页服务闭环实践 / 348
17.1 为什么需要统一服务 / 348
17.2 整体架构 / 349
17.3 一些架构思路和总结 / 350
17.4 引入Nginx接入层 / 354
17.5 前端业务逻辑后置 / 356
17.6 前端接口服务端聚合 / 357
17.7 服务隔离 / 359
18 使用OpenResty开发高性能Web应用 / 360
18.1 OpenResty简介 / 361
18.1.1 Nginx优点 / 361
18.1.2 Lua的优点 / 361
18.1.3 什么是ngx_lua / 361
18.1.4 开发环境 / 362
18.1.5 OpenResty生态 / 362
18.1.6 场景 / 362
18.2 基于OpenResty的常用架构模式 / 363
18.3 如何使用OpenResty开发Web应用 / 371
18.4 基于OpenResty的常用功能总结 / 375
18.5 一些问题 / 376
19 应用数据静态化架构高性能单页Web应用 / 377
19.1 整体架构 / 378
19.2 数据和模板动态化 / 381
19.3 多版本机制 / 381
19.4 异常问题 / 382
20 使用OpenResty开发Web服务 / 383
20.1 架构 / 383
20.2 单DB架构 / 384
20.3 实现 / 387
21 使用OpenResty开发商品详情页 / 405
21.1 技术选型 / 407
21.2 核心流程 / 408
21.3 项目搭建 / 408
21.4 数据存储实现 / 410
21.5 动态服务实现 / 422
21.6 前端展示实现 / 430
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>亿级流量网站架构核心技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构真经
目录
本书赞誉
中文版序一
中文版序二
译者序
前言
致谢
作者简介
第1章　大道至简 …… 1
规则1——避免过度设计 …… 4
规则2——方案中包括扩展 …… 9
规则3——三次简化方案 …… 13
规则4——减少域名解析 …… 16
规则5——减少页面目标 …… 19
规则6——采用同构网络 …… 23
总结 …… 24
注释 …… 25
第2章　分而治之 …… 27
规则7——X轴扩展 …… 31
规则8——Y轴拆分 …… 35
规则9——Z轴拆分 …… 39
总结 …… 41
注释 …… 42
第3章　水平扩展 …… 43
规则10——向外扩展 …… 46
规则11——用商品化系统（金鱼而非汗血宝马） …… 50
规则12——托管方案扩展 …… 53
规则13——利用云 …… 61
总结 …… 64
注释 …… 64
第4章　先利其器 …… 65
规则14——适当使用数据库 …… 71
规则15——慎重使用防火墙 …… 80
规则16——积极使用日志文件 …… 85
总结 …… 88
注释 …… 89
第5章　画龙点睛 …… 90
规则17——避免画蛇添足 …… 93
规则18——停止重定向 …… 98
规则19——放宽时间约束 …… 104
总结 …… 107
注释 …… 107
第6章　缓存为王 …… 109
规则20——利用CDN缓存 …… 113
规则21——灵活管理缓存 …… 117
规则22——利用Ajax缓存 …… 120
规则23——利用页面缓存 …… 128
规则24——利用应用缓存 …… 130
规则25——利用对象缓存 …… 134
规则26——独立对象缓存 …… 137
总结 …… 139
注释 …… 139
第7章　前车之鉴 …… 141
规则27——失败乃成功之母 …… 144
规则28——不靠QA发现错误 …… 151
规则29——不能回滚注定失败 …… 155
总结 …… 160
注释 …… 160
第8章　重中之重 …… 162
规则30——从事务处理中清除商务智能 …… 164
规则31——注意昂贵的关系 …… 168
规则32——正确使用数据库锁 …… 172
规则33——禁用分阶段提交 …… 176
规则34——慎用Select for Update …… 178
规则35——避免选择所有列 …… 181
总结 …… 183
注释 …… 184
第9章　有备无患 …… 185
规则36——用“泳道”隔离故障 …… 188
规则37——拒绝单点故障 …… 194
规则38——避免系统串联 …… 198
规则39——启用与禁用功能 …… 201
总结 …… 205
第10章　超然物外 …… 206
规则40——力求无状态 …… 208
规则41——在浏览器中保存会话数据 …… 211
规则42——用分布式缓存处理状态 …… 213
总结 …… 216
注释 …… 217
第11章　异步通信 …… 218
规则43——尽可能异步通信 …… 220
规则44——扩展消息总线 …… 224
规则45——避免总线过度拥挤 …… 229
总结 …… 233
第12章　意犹未尽 …… 234
规则46——警惕第三方方案 …… 237
规则47——梯级存储策略 …… 240
规则48——分类处理不同负载 …… 246
规则49——完善监控 …… 250
规则50——保持竞争力 …… 255
总结 …… 257
注释 …… 258
第13章　谋定而动 …… 259
用风险收益模型评估可扩展性项目和举措 …… 259
50条可扩展性规则简述 …… 264
可扩展性规则的利益与优先级排行榜 …… 297
总结 …… 300
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构真经
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>图解服务器端网络架构
第0章　本书的用法　　1
0.1　 网络架构的流程　　2
0.1.1　网络架构分为六个阶段　　2
0.1.1.1　需求定义　　2
0.1.1.2　基础设计　　2
0.1.1.3　详细设计　　2
0.1.1.4　架构　　3
0.1.1.5　测试　　3
0.1.1.6　运行　　3
0.1.2　网络架构的重点是基础设计　　4
0.1.2.1　物理设计　　5
0.1.2.2　逻辑设计　　6
0.1.2.3　安全设计与负载均衡设计　　7
0.1.2.4　高可用性设计　　8
0.1.2.5　管理设计　　9
第1章　物理设计　　11
1.1　 物理层的技术　　12
1.1.1　物理层里有多种规格　　12
1.1.1.1　规格整理好后物理层就会水落石出　　13
1.1.1.2　双绞线电缆有两大要素——类和传输距离　　15
1.1.1.3　光纤光缆是用玻璃制成的　　25
1.2　 物理设计　　31
1.2.1　服务器端有两种结构类型　　31
1.2.1.1　采用串联式结构管理起来更方便　　32
1.2.1.2　采用单路并联式结构更容易扩展　　33
1.2.2　选用设备时应参考考查项的最大值　　36
1.2.2.1　应用程序不同吞吐率也就不同　　37
1.2.2.2　新增连接数和并发连接数都要考虑　　38
1.2.3　选择稳定可靠的 OS版本　　39
不懂就问是捷径　　39
1.2.4　根据实际配置和使用目的选择线缆　　40
1.2.4.1　远距离传输选择光纤光缆　　40
1.2.4.2　追求宽频带和高可靠性时选择光纤　　41
1.2.4.3　通过大小分类决定使用哪种双绞线电缆　　42
1.2.4.4　预先决定好使用线缆的颜色　　43
1.2.5　端口的物理设计出乎意料地重要　　44
1.2.5.1　必须统一规划连接到哪里　　44
1.2.5.2　速率和双工、Auto MDI/MDI-X 的设置也要统一规划　　44
1.2.6　巧妙地配置设备　　45
1.2.6.1　将核心交换机和汇聚交换机置于中央部位　　45
1.2.6.2　要考虑设备中空气吸入和排出的方向　　48
1.2.6.3　从两套系统获取电源　　49
1.2.6.4　切莫超过最大承重　　51
第2章　逻辑设计　　53
2.1　 数据链路层的技术　　54
2.1.1　数据链路层是物理层的帮手　　54
用以太网标准进行成帧处理　　55
2.1.2　数据链路层的关键在于 L2交换机的运作　　61
2.1.2.1　交换 MAC地址　　62
2.1.2.2　通过 VLAN将广播域分隔开　　67
2.1.3　ARP 将逻辑和物理关联到一起　　74
2.1.3.1　ARP 通过IP地址查询MAC地址　　75
2.1.3.2　抓取 ARP包，观察它的写法　　81
2.1.3.3　有几个特殊的 ARP　　82
2.2　 网络层的技术　　85
2.2.1　网络是由网络层拼接起来的　　85
2.2.1.1　添加 IP报头，进行分组化处理　　86
2.2.1.2　IP 地址由32位构成　　91
2.2.2　将网段连接起来　　99
2.2.2.1　利用 IP地址进行路由选择　　100
2.2.2.2　建立路由表　　104
2.2.2.3　整理路由表　　114
2.2.3　转换 IP地址　　118
2.2.3.1　转换 IP地址　　118
2.2.3.2　私网 IP地址　　122
2.2.4　自动设置 IP地址的DHCP　　123
2.2.4.1　DHCP 的消息部分中包含着诸多的信息　　123
2.2.4.2　DHCP 的原理非常简单　　125
2.2.4.3　对 DHCP报文作中继处理　　126
2.2.5　用于故障排除的 ICMP　　127
2.2.5.1　ICMP 的关键在于类型和代码　　127
2.2.5.2　常见的类型和代码有四种组合　　128
2.2.5.3　出现问题时先尝试用 ping去排除故障　　130
2.3　 逻辑设计　　132
2.3.1　整理出所需的 VLAN　　132
2.3.1.1　实际所需的 VLAN会因为诸多因素而变化　　132
2.3.1.2　规定 VLAN的ID　　138
2.3.2　在考虑数量增减的基础上分配 IP地址　　140
2.3.2.1　IP 地址的估算数量应高于当前所需数量　　140
2.3.2.2　按顺序排列网段，使之更容易汇总　　142
2.3.2.3　必须统一规定从何处开始分配 IP地址　　145
2.3.3　路由选择以简为上　　145
2.3.3.1　考虑在路由选择中使用哪些协议　　145
2.3.3.2　考虑采用哪种路由选择方法　　146
2.3.3.3　将路径汇总以减少路径数量　　150
2.3.4　NAT 要按入站和出站分别考虑　　152
2.3.4.1　NAT 是在系统边界进行的　　152
2.3.4.2　通过入站通信转换地址　　152
2.3.4.3　通过出站通信转换地址　　153
第3章　数据安全设计和负载均衡设计　　155
3.1.1　通过端口号划分服务器进程　　156
3.1.1.1　传输层使用 TCP和UDP两种协议　　157
3.1.1.2　TCP 的工作原理比较复杂　　164
3.1.1.3　MTU 和MSS的差异在于对象层不同　　170
3.1.2　用防火墙守卫系统　　173
3.1.2.1　基于连接进行控制　　174
3.1.2.2　状态检测和包过滤之间的区别　　177
3.1.2.3　防火墙在不断进步　　179
3.1.3　通过负载均衡器分散服务器的负荷　　184
3.1.3.1　目的 NAT是服务器负载均衡技术的基础　　185
3.1.3.2　通过健康检查监控服务器的状态　　189
3.1.3.3　熟练掌握可选功能　　200
3.2　 从会话层到应用层的技术　　204
3.2.1　HTTP 支撑着互联网　　204
3.2.1.1　HTTP/1.0 和HTTP/1.1的TCP连接用法大相径庭　　204
3.2.1.2　HTTP 因请求和响应而得以成立　　206
3.2.2　用 SSL保护数据　　211
3.2.2.1　防止窃听、篡改和冒充　　212
3.2.2.2　通过 SSL可以给各种各样的应用程序协议加密　　215
3.2.2.3　SSL 使用混合加密方式进行加密　　216
3.2.2.4　消息摘要是消息的概要　　219
3.2.2.5　SSL 中执行着大量的处理　　222
3.2.2.6　用客户端证书对客户端进行认证　　230
3.2.3　用 FTP传输文件　　233
3.2.3.1　主动模式使用特定的端口　　234
3.2.3.2　被动模式改变使用的端口　　236
3.2.3.3　FTP 就应该当作FTP去处理　　239
3.2.4　用 DNS解析名称　　240
3.2.4.1　用 UDP进行名称解析　　241
3.2.4.2　用 TCP进行区域传输　　242
3.3　 数据安全设计与负载均衡设计　　246
3.3.1　数据安全设计　　246
3.3.1.1　整理出真正需要的通信　　246
3.3.1.2　通过多级防御提高安全系数　　250
3.3.1.3　默认启动的服务应控制在最小范围内　　251
3.3.2　负载均衡设计　　251
3.3.2.1　要高效地均衡负载　　252
3.3.2.2　启用哪些可选功能　　255
第4章　高可用性设计　　257
4.1　 冗余技术　　258
4.1.1　物理层的冗余技术　　258
4.1.1.1　将多条物理链路集结成一条逻辑链路　　258
4.1.1.2　将多个物理网卡集结成一个逻辑网卡　　263
4.1.1.3　将多台物理设备集结成一台逻辑设备　　269
4.1.1.4　当上行链路中断时，让下行链路也随之中断　　278
4.1.2　数据链路层的冗余技术　　279
4.1.2.1　STP 的关键在于根网桥和阻塞端口　　279
4.1.2.2　STP 有三种　　286
4.1.2.3　同时启用多项可选功能　　289
4.1.2.4　利用 BPDU切断桥接环路　　290
4.1.3　网络层的冗余技术　　292
4.1.3.1　FHRP　　292
4.1.3.2　利用路由协议确保通往上层设备的路径　　302
4.1.4　从传输层到应用层的冗余技术　　304
4.1.4.1　防火墙的冗余技术　　304
4.1.4.2　负载均衡器的冗余技术　　310
4.2　 高可用性设计　　312
4.2.1　高可用性设计　　312
4.2.1.1　串联式结构　　312
4.2.1.2　单路并联式结构　　316
4.2.2　理清通信流　　320
4.2.2.1　串联式结构　　320
4.2.2.2　单路并联式结构　　332
第5章　管理设计　　339
5.1　 管理技术　　340
5.1.1　用 NTP同步时间　　340
NTP 的工作原理非常简单　　340
5.1.2　用 SNMP检测故障　　346
5.1.2.1　通过 SNMP管理器和SNMP代理交换信息　　346
5.1.2.2　熟练掌握三种运作模式　　347
5.1.2.3　限制源 IP地址　　351
5.1.3　用 Syslog检测故障　　352
Syslog 的工作原理非常简单　　352
5.1.4　传递设备信息　　355
5.1.4.1　CDP　　355
5.1.4.2　LLDP　　356
5.1.4.3　注意 CDP和LLDP的数据安全问题　　357
5.2　 管理设计　　358
5.2.1　确定主机名　　358
5.2.2　通过标签管理连接　　358
5.2.2.1　线缆标签　　358
5.2.2.2　本体标签　　359
5.2.3　设计密码　　359
5.2.4　管理设置信息　　360
5.2.4.1　在备份设计中应定义时机、方式和保存地点　　360
5.2.4.2　发生故障时执行恢复处理　　361
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>图解服务器端网络架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>聊聊架构
第一部分  认识架构	1
第一章  生命周期	2
1.	生命周期的识别	3
2.	核心与非核心生命周期	3
3.	生命周期与分工	5
第二章  时间	9
第三章  为什么会产生架构	11
1.	分工	11
2.	架构和生命周期	12
第四章  什么是架构	13
1.	架构产生的条件	13
2.	什么是架构	14
3.	架构的生命周期	16
第五章  架构和树	18
1.	树与增长	18
2.	架构和树	19
第六章  概念	20
1.	何为名相？	20
2.	究竟什么才是相？	21
3.	概念是沟通的基础	21
4.	把握概念的力量	22
第七章  什么是抽象	23
1.	个性与共性	23
2.	个性是基础	24
第八章  识别问题	25
1．面对问题有哪些困难	25
2．如何识别问题	26
3．寻找问题主体	28
第九章  切分的原则	29
1．切分就是利益的调整	29
2．为什么需要切分？	30
3．切分的原则	30
4．树和分层	31
5．切分与建模	32
6．切分的输出和组织架构	32
第十章  架构与流程	34
1．什么是流程	34
2．流程和架构分拆的关系	35
第十一章  什么是架构师	36
1．架构师做什么	36
2．架构师也是人	36
3．人人都是架构师	37
4．架构师和权利	38
第二部分  软件架构	39
第一章  什么是软件	40
1．冯诺依曼结构，图灵机，以模拟人为目标	40
2．成本为王	40
3．天空才是极限	41
4．软件的作用	42
第二章  软件的生命周期	45
1．软件的开发生命周期	46
2．软件开发的增长	46
3．软件开发的迭代	48
4．软件的运行生命周期	48
第三章  什么是软件架构	50
1.	要解决什么问题？	50
2.	分别是谁的问题呢？	51
3.	分别有什么问题？	51
4.	分析问题	52
5.	会生成哪些架构	53
6.	什么是软件架构	55
第四章  什么是软件架构师	57
1．软件架构师的不同	57
2．软件架构师的困境	58
3．生命周期的思考	58
4．软件架构师的权利	59
5．软件架构师和技术人员对技术的态度区别	60
6．架构师是技术的使用者	61
7．如何保障架构落地	62
第五章  业务、架构和技术三者的关系	64
1．什么是技术	64
2．业务、架构和技术之间的关系	66
3．技术人员和业务人员的关系	68
4．重新发明轮子	69
5．开源技术	69
第六章  软件研发	72
1．软件工程师的兴起和使命	72
2．分工的困境	74
3．软件的迭代	76
4．软件开发的分工	77
5．软件开发模式和架构	78
6．软件工程师的支持者	80
第七章  软件的架构拆分	82
1．软件拆分的原动力	82
2．软件开发团队的拆分	85
3．软件的拆分	86
4．软件开发的基础技术	88
5．软件拆分的第二动力	90
6．架构一步到位？	90
第八章  如何写好代码	92
1.	什么叫业务逻辑？	98
2.	业务逻辑分散的危害	98
3.	业务逻辑内聚的好处	100
4.	代码架构实例	101
5.	代码误解	103
6.	软件的拆分	104
第九章  单元测试	106
1．什么是单元测试	106
2．单元测试的困境	106
3．单元测试测什么	107
4．如何改造代码	108
5．为什么要做单元测试	111
6．如何做单元测试	113
第十章  软件架构和面向对象	115
1．什么是面向过程	115
2．什么是面向对象	116
3．生命周期和面向对象、面向过程	117
4．架构和面向对象、面向过程	117
5．面向对象的误区	118
6．对象和生命	119
第十一章  软件架构与设计模式	121
1．模式以及模式的意义	121
2．什么是设计模式	122
3．软件设计模式	123
4．设计模式和架构	124
5．设计模式的误区	126
第十二章  软件架构和软件框架	130
1．访问类框架	130
2．业务类框架	132
3．什么是框架	132
4．框架的特点	132
第十三章  软件运维	134
1．软件运行生命周期	134
2．什么是软件运维？	135
3．运维的业务模型	136
4．控制变化	138
5．监控变更	141
6．预警变更	142
7．主导变更	144
8．提升变更质量	146
9．运维的架构拆分	148
第十四章  软件访问生命周期	151
1．软件访问的业务模型	151
2．软件访问路径的架构拆分	153
3．大规模软件访问的架构拆分	155
4．集群	156
5．数据中心	158
第十五章  软件架构和大数据	161
1．什么是大数据	161
2．如何做好大数据	162
3．软件大数据	163
第十六章  软件架构和建筑架构	165
1．软件架构和建筑架构的目标之异同	165
2．软件和建筑的架构扩展之异同	169
第三部分  软件架构的应用	172
第一章  交易	173
1．什么是交易	173
2．货币的出现	174
3．企业的实质	175
4．软件对交易的影响	176
5．软件的交易	176
6．企业的核心	177
第二章  产品	179
1．什么是产品	179
2．什么是商品	182
3．识别产品	184
4．产品系统	185
5．产品列表	185
6．产品详情	186
7．商品的规则	186
第三章  用户	188
1．什么是用户	188
2．为什么需要用户	189
3．客户的出现	189
4．用户的生命周期	190
5．用户的识别	191
第四章  订单	192
1．什么是订单	192
2．订单的生命周期架构拆分	193
3．订单支付	195
4．订单生命周期	196
第五章  交易系统	197
1．企业的架构分拆	197
2．软件系统的建模	201
3．访问业务模型	205
4．交易软件系统的架构分拆	208
5．服务的产生和粒度	209
6．用户系统的分拆	210
第六章  事务	214
1．什么是事务	215
2．软件中的事务	216
3．数据库事务的滥用	217
4．数据库的正确使用方式	217
5．服务调用	218
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>聊聊架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>程序员必读之软件架构
推荐序一：架构师真正要学会的事情　　ix
推荐序二　　xii
译者序2.0　　xiii
序　　xvi
关于本书　　xix
软件架构培训　　xxii
Part Ⅰ　什么是软件架构
第1章　什么是架构　　2
第2章　架构的种类　　4
第3章　软件架构是什么　　6
第4章　敏捷软件架构是什么　　8
第5章　架构对上设计　　11
第6章　软件架构重要吗　　13
第7章　问题　　15
Part Ⅱ　软件架构的角色
第8章　软件架构的角色　　18
第9章　软件架构师应该编码吗　　22
第10章　软件架构师应该是建造大师　　25
第11章　从开发者到架构师　　30
第12章　拓展T　　32
第13章　软技能　　34
第14章　软件架构不是接力运动　　36
第15章　软件架构要引入控制吗　　38
第16章　小心鸿沟　　40
第17章　未来的软件架构师在哪里　　42
第18章　每个人都是架构师，除非他们有其他身份　　44
第19章　软件架构咨询师　　46
第20章　问题　　48
Part Ⅲ　设计软件
第21章　架构驱动力　　50
第22章　质量属性（非功能需求）　　52
第23章　处理非功能需求　　55
第24章　约束　　57
第25章　原则　　60
第26章　技术不是实现细节　　63
第27章　更多分层等于更高复杂度　　66
第28章　协同设计是一把双刃剑　　68
第29章　软件架构是对话的平台　　70
第30章　SharePoint项目也需要软件架构　　72
第31章　问题　　74
Part Ⅳ　可视化软件
第32章　沟通障碍　　76
第33章　对草图的需要　　78
第34章　无效的草图　　81
第35章　C4：语境、容器、组件和类　　91
第36章　语境图　　94
第37章　容器图　　98
第38章　组件图　　102
第39章　是否包含技术选择　　107
第40章　你会那样编码吗　　110
第41章　软件架构和编码　　112
第42章　你不需要UML工具　　117
第43章　有效的草图　　120
第44章　C4的常见问题　　124
第45章　问题　　126
Part Ⅴ　为软件生成文档
第46章　代码不会讲述完整的故事　　128
第47章　软件文档即指南　　131
第48章　语境　　136
第49章　功能性概览　　137
第50章　质量属性　　139
第51章　约束　　141
第52章　原则　　143
第53章　软件架构　　145
第54章　外部接口　　147
第55章　代码　　149
第56章　数据　　151
第57章　基础设施架构　　153
第58章　部署　　155
第59章　运营和支持　　157
第60章　决策日志　　159
第61章　问题　　161
Part Ⅵ　开发生命周期中的软件架构
第62章　敏捷和架构的冲突：神话还是现实　　164
第63章　量化风险　　167
第64章　风险风暴　　169
第65章　恰如其分的预先设计　　173
第66章　初识软件架构　　179
第67章　问题　　183
Part Ⅶ　金融风险系统
第68章　金融风险系统　　186
Part Ⅷ　附录：“技术部落”的软件指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>程序员必读之软件架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>信息架构
前言 xvii
第1部分信息架构简介
第1章信息架构要解决的问题 3
你好，iTunes 5
信息架构要解决的问题 8
信息过载 9
访问信息的更多方式 10
加入信息架构 12
由信息构成的场所 13
渠道之间的一致性 13
系统化思维 15
本章回顾 16
第2章信息架构的定义 19
定义 19
看不到不代表不存在 21
走向优秀的信息架构 26
情景 28
内容 29
用户 30
本章回顾 31
第3章为查找而设计 33
“太过于简单的”信息模型 34
信息需求 35
信息搜寻行为 38
了解信息需求和信息搜寻行为 41
本章回顾 42
第4章为理解而设计 43
场所感 43
(现实世界) 场所的结构 44
由信息组成的场所 45
组织原则 47
结构和秩序 48
类型系统 50
模块化和可扩展性 54
世界上最快乐的场所 56
本章回顾 61
第2部分信息架构的基本原理
第5章信息架构详解 65
信息架构的可视化 65
自顶向下的信息架构 68
自底向上的信息架构 70
不可见的信息架构 73
信息架构组件 74
浏览帮手 75
搜索帮手 76
内容和任务 77
“不可见的” 组件 78
本章回顾 78
第6章组织系统 79
组织信息的挑战 80
模糊性 81
异质性 81
不同观点的差异性 82
公司内部的政治文化 83
组织信息环境 83
组织方案 84
精确的组织方案 84
组织结构 93
层级结构：一种自顶向下的方法 94
数据库模式：一种自底向上的方法 98
社会化分类 102
创建凝聚性组织系统 103
本章回顾 104
第7章标签系统 105
为什么要关心标签命名 106
各种各样的标签 111
作为情景式链接的标签 111
作为标题的标签 114
导航系统内的标签 116
标签作为索引词 118
标签的设计 121
通用原则 121
标签系统的来源 124
创建新的标签系统 129
优化和调整 137
本章回顾 137
第8章导航系统 139
导航系统的种类 140
灰色区域很重要 141
浏览器导航功能 142
场所营造 142
提高灵活性 144
嵌入式导航系统 145
全局导航系统
局部导航系统 148
情景式导航 150
嵌入式导航的实现 152
辅助导航系统 154
站点地图 155
索引 156
指南 159
搜索 162
高级导航方法 162
个性化和自定义 163
可视化 164
社会化导航 165
本章回顾 168
第9章搜索系统 169
你的产品需要搜索吗 169
搜索引擎详解 173
选择要索引什么 174
确定搜索区域 174
选择要建立索引的内容组件 179
搜索算法 182
模式匹配算法 182
其他方法 183
查询生成器 185
显示结果 186
要显示哪些内容组件 187
要显示多少文档 190
列出结果 192
将结果分组 199
对结果采取行动 200
设计搜索界面 201
搜索框 203
自动完成和自动建议 206
高级搜索 207
支持修改 208
当用户被卡住时 212
到哪里学习更多 213
本章回顾 214
第10章叙词表、受控词表和元数据 215
元数据 216
受控词表 216
同义词环 217
规范文档 220
分类方案 223
叙词表 225
技术术语 226
叙词表实例 228
叙词表类型 233
经典叙词表 234
索引叙词表 234
搜索叙词表 234
叙词表标准 235
语义关系 237
等价 237
层级 238
关联 239
首选术语 240
术语形式 240
术语选择 240
术语定义 241
术语特异性 241
多元层级结构 242
分面分类法 243
本章回顾 248
第3部分完成信息架构
第11章研究 251
研究框架 252
情景 253
获得支持 254
背景研究 254
初步演示报告 255
研究会议 255
利益相关者访谈 257
技术评估 258
内容 258
启发式评估 259
内容分析 260
内容映射262
标杆法 263
用户 265
使用分析 266
搜索日志分析 267
参与者定义和招募 270
客户支持数据 270
调查 270
情景调查 270
焦点小组 271
用户研究会议 272
访谈 272
卡片分类法 273
用户测试 277
研究的保卫战 278
克服研究阻力 279
本章回顾 280
第12章策略 283
什么是信息架构策略？ 284
遭到抨击的策略 285
从研究到策略 287
策略的开发 287
思考 288
表述 288
沟通 289
测试 289
工作产品和可交付成果 291
隐喻探索 291
场景 293
案例研究和故事 294
概念图表 295
站点地图和框架图 296
策略报告 296
示例策略报告 296
项目计划 306
演示 307
本章回顾 308
第13章设计和文档 309
创建信息架构图的准则 310
视觉沟通 311
站点地图 313
高级架构站点地图 313
深入站点地图 315
保持站点地图的简单性 319
详细的站点地图 320
组织你的站点地图 322
线框图 324
线框图的类型 327
线框图准则 330
内容映射和清单 331
内容模型 337
它们为什么这么重要？ 337
实例 338
有价值的过程 342
受控词表 342
设计协作 344
设计草图 344
整合：信息架构风格指南 347
“原因”所在 347
“方式”所在 348
本章回顾 349
结语 351
附录A参考文献 355
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>信息架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构之美
序
前言
第一部分 论架构
第1章 架构概述
1.1 简介
1.2 创建软件架构
1.3 架构结构
1.4 好的架构
1.5 美丽的架构
致谢
参考文献
第2章 两个系统的故事：现代软件神话
2.1 混乱大都市
2.2 设计之城
2.3 说明什么问题
2.4 轮到你了
参考文献
第二部分 企业级应用架构
第3章 伸缩性架构设计
3.1 简介
3.2 背景
3.3 架构
3.4 关于架构的思考
第4章 记忆留存
4.1 功能和约束
4.2 工作流
4.3 架构关注点
4.4 用户反应
4.5 结论
参考文献
第5章 面向资源的架构：在Web中
5.1 简介
5.2 传统的Web服务
5.3 Web
5.4 面向资源的架构
5.5 数据驱动的应用
5.6 应用面向资源的架构
5.7 结论
第6章 数据增长：Facebook平台的架构
6.1 简介
6.2 创建一个社会关系Web服务
6.3 创建社会关系数据查询服务
6.4 创建一个社会关系Web门户：FBML
6.5 系统的支持功能
6.6 总结
第三部分 系统架构
第7章 Xen和虚拟化之美
7.1 简介
7.2 Xenoservers
7.3 虚拟化的挑战
7.4 半虚拟化
7.5 Xen的变换形式
7.6 改变的硬件，改变的Xen
7.7 经验教训
7.8 延伸阅读
第8章 Guardian：一个容错操作系统环境
8.1 Tandem/16，将来所有的计算机都会像这样构建
8.2 硬件
8.3 物理布局
8.4 处理器架构
8.5 处理器间总线
8.6 输入/输出
8.7 进程结构
8.8 消息系统
8.9 文件系统
8.10 轶闻趣事
8.11 弊端
8.12 后继者
8.13 延伸阅读
第9章 JPC：一个纯Java的x86 PC模拟程序
9.1 简介
9.2 概念验证
9.3 PC架构
9.4 Java性能技巧
9.5 把4GB放入4GB：这不起作用
9.6 保护模式的危险
9.7 从事一项毫无成功希望的斗争
9.8 劫持JVM
9.9 终极灵活性
9.10 终极安全性
9.11 第二次做会更好
第10章 元循环虚拟机的力量：Jikes RVM
10.1 背景
10.2 与运行时环境相关的传言
10.3 Jikes RVM简史
10.4 一个自足执行的运行时自举
10.5 运行时组件
10.6 经验教训
参考文献
第四部分 最终用户应用架构
第11章 GNU Emacs：滋长的特性是其优势
11.1 使用中的Emacs
11.2 Emacs的架构
11.3 滋长的特性
11.4 另外两个架构
第12章 当集市开始构建教堂
12.1 简介
12.2 KDE项目的历史和组织结构
12.3 Akonadi
12.4 ThreadWeaver
第五部分 语言与架构
第13章 软件架构：面向对象与面向函数
13.1 概述
13.2 函数式示例
13.3 函数式解决方案的模块性评价
13.4 面向对象视图
13.5 面向对象模块性的评价和改进
13.6 代理：将操作封装到对象中
致谢
参考文献
第14章 重读经典
14.1 所有东西都是对象
14.2 类型是隐式定义的
14.3 问题
14.4 砖块和灰浆建筑架构
参考资料
跋 漂亮地构建
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构之美
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件架构设计
第1章  从程序员到架构师	1
1.1  软件业人才结构	1
1.1.1  金字塔型，还是橄榄型？	1
1.1.2  从程序员向架构师转型	2
1.2  本书价值	3
1.2.1  阅读路径1：架构设计入门	3
1.2.2  阅读路径2：领会大系统架构设计	4
1.2.3  阅读路径3：从需求到架构的全过程	5
1.2.4  阅读路径4：结合工作，解决实际问题	6
第1部分  基本概念篇
第2章  解析软件架构概念	10
2.1  软件架构概念的分类	10
2.1.1  组成派	11
2.1.2  决策派	11
2.1.3  软件架构概念大观	12
2.2  概念思想的解析	13
2.2.1  软件架构关注分割与交互	13
2.2.2  软件架构是一系列有层次的决策	14
2.2.3  系统、子系统、框架都可以有架构	17
2.3  实际应用（1）——团队对架构看法不一怎么办	18
2.3.1  结合手上的实际工作来理解架构的含义	18
2.3.2  这样理解“架构”对吗	19
2.3.3  工作中找答案：先看部分设计	19
2.3.4  工作中找答案：反观架构概念的体现	22
第3章  理解架构设计视图	24
3.1  软件架构为谁而设计	24
3.1.1  为用户而设计	25
3.1.2  为客户而设计	26
3.1.3  为开发人员而设计	26
3.1.4  为管理人员而设计	26
3.1.5  总结	27
3.2  理解架构设计视图	28
3.2.1  架构视图	28
3.2.2  一个直观的例子	28
3.2.3  多组涉众，多个视图	29
3.3  运用“逻辑视图+物理视图”设计架构	30
3.3.1  逻辑架构	31
3.3.2  物理架构	32
3.3.3  从“逻辑架构+物理架构”到设计实现	32
3.4  实际应用（2）——开发人员如何快速成长	33
3.4.1  开发人员应该多尝试设计	33
3.4.2  实验项目：案例背景、训练目标	34
3.4.3  逻辑架构设计（迭代1）	35
3.4.4  物理架构设计（迭代1）	35
3.4.5  逻辑架构设计（迭代2）	36
3.4.6  物理架构设计（迭代2）	37
第2部分  实践过程篇
第4章  架构设计过程	40
4.1  架构设计的实践脉络	41
4.1.1  洞察节奏：3个原则	41
4.1.2  掌握过程：6个步骤	43
4.2  架构设计的速查手册	45
4.2.1  需求分析	45
4.2.2  领域建模	46
4.2.3  确定关键需求	47
4.2.4  概念架构设计	49
4.2.5  细化架构设计	50
4.2.6  架构验证	51
第5章  需求分析	53
5.1  需求开发（上）——愿景分析	53
5.1.1  从概念化阶段说起	54
5.1.2  愿景	54
5.1.3  上下文图	56
5.1.4  愿景分析实践要领	60
5.2  需求开发（下）——需求分析	60
5.2.1  需求捕获vs.需求分析vs.系统分析	61
5.2.2  需求捕获及成果	63
5.2.3  需求分析及成果	64
5.2.4  系统分析及成果	65
5.3  掌握的需求全不全	65
5.3.1  二维需求观与ADMEMS矩阵	65
5.3.2  功能	66
5.3.3  质量	68
5.3.4  约束	71
5.4  从需求向设计转化的“密码”	72
5.4.1 “理性设计”还是“拍脑袋”	72
5.4.2  功能：职责协作链	73
5.4.3  质量：完善驱动力	74
5.4.4  约束：设计并不自由	74
5.5  实际应用（3）——PM Suite贯穿案例之需求分析	75
5.5.1  PM Suite案例背景介绍	76
5.5.2  第1步：明确系统目标	77
5.5.3  第2步：范围 + Feature + 上下文图	77
5.5.4  第3步：画用例图	82
5.5.5  第4步：写用例规约	85
5.5.6  插曲：需求启发与需求验证	86
5.5.7  插曲：非功能需求	88
5.5.8  《需求规格》与基于ADMEMS矩阵的需求评审	88
第6章  用例与需求	89
6.1  用例技术族	89
6.1.1  用例图	90
6.1.2  用例简述、用户故事	90
6.1.3  用例规约	91
6.1.4  用例实现、鲁棒图	92
6.1.5  4种技术的关系	93
6.2  用例技术族的应用场景	94
6.2.1  用例与需求分析	94
6.2.2  用例与需求文档	95
6.2.3  用例与需求变更	97
6.3  实际应用（4）——用例建模够不够？流程建模要不要	99
6.3.1  软件事业部的故事	99
6.3.2  小型方法：需求分析的三套实践论（上）	99
6.3.3  中型方法：需求分析的三套实践论（中）	100
6.3.4  大型方法：需求分析的三套实践论（下）	101
6.3.5  PM Suite应用一幕	102
第7章  领域建模	105
7.1  什么是领域模型	106
7.1.1  领域模型“是什么”	106
7.1.2  领域模型“什么样”	106
7.1.3  领域模型“为什么”	107
7.2  需求人员视角——促进用户沟通、解决分析瘫痪	108
7.2.1  领域建模与需求分析的关系	108
7.2.2  沟通不足	109
7.2.3  分析瘫痪	110
7.2.4  案例：多步领域建模，熟悉陌生领域	111
7.3  开发人员视角——破解“领域知识不足”死结	113
7.3.1  领域模型作为“理解领域的手段”	113
7.3.2  案例：从词汇表到领域模型	113
7.4  实际应用（5）——功能决定如何建模，模型决定功能扩展	115
7.4.1  案例：模型决定功能扩展	116
7.4.2  实践：功能决定如何建模	118
7.4.3  PM Suite领域建模实录（1）——类图	122
7.4.4  PM Suite领域建模实录（2）——状态图	125
7.4.5  PM Suite领域建模实录（3）——可扩展性	126
第8章  确定关键需求	129
8.1  众说纷纭——什么决定了架构	129
8.1.1  用例驱动论	130
8.1.2  质量决定论	131
8.1.3  经验决定论	132
8.2  真知灼见——关键需求决定架构	132
8.2.1 “目标错误”比“遗漏需求”更糟糕	132
8.2.2  关键需求决定架构，其余需求验证架构	132
8.3  付诸行动——如何确定关键需求	133
8.3.1  确定关键质量	133
8.3.2  确定关键功能	135
8.4  实际应用（6）——小系统与大系统的架构分水岭	137
8.4.1  架构师的“拿来主义”困惑	137
8.4.2  场景1：小型PMIS（项目型ISV背景）	138
8.4.3  场景2：大型PM Suite（产品型ISV背景）	139
8.4.4  场景3：多个自主产品组成的方案（例如IBM）	140
8.4.5 “拿来主义”虽好，但要合适才行	141
第9章  概念架构设计	143
9.1  概念架构是什么	144
9.1.1  概念架构是直指目标的设计思想、重大选择	144
9.1.2  案例1：汽车电子AUTOSAR——跨平台复用	145
9.1.3  案例2：腾讯QQvideo架构——高性能	149
9.1.4  案例3：微软MFC架构——简化开发	150
9.1.5  总结	151
9.2  概念架构设计概述	151
9.2.1 “关键需求”进，“概念架构”出	151
9.2.2  概念架构≠理想化架构	152
9.2.3  概念架构≠细化架构	152
9.3  左手功能——概念架构设计（上）	153
9.3.1  什么样的鸿沟，架什么样的桥	153
9.3.2  鲁棒图“是什么”	153
9.3.3  鲁棒图“画什么”	154
9.3.4  鲁棒图“怎么画”	156
9.4  右手质量——概念架构设计（下）	159
9.4.1  再谈什么样的鸿沟，架什么样的桥	159
9.4.2  场景思维	159
9.4.3  场景思维的工具	160
9.4.4  目标—场景—决策表应用举例	162
9.5  概念架构设计实践要领	163
9.5.1  要领1：功能需求与质量需求并重	163
9.5.2  要领2：概念架构设计的1个决定、4个选择	163
9.5.3  要领3：备选设计	165
9.6  实际应用（7）——PM Suite贯穿案例之概念架构设计	165
9.6.1  第1步：通过初步设计，探索架构风格和高层分割	165
9.6.2  第2步：选择架构风格，划分顶级子系统	169
9.6.3  第3步：开发技术、集成技术与二次开发技术的选型	171
9.6.4  第4步：评审3个备选架构，敲定概念架构方案	172
第10章  细化架构设计	174
10.1  从2视图方法到5视图方法	175
10.1.1  回顾：2视图方法	175
10.1.2  进阶：5视图方法	175
10.2  程序员向架构师转型的关键突破——学会系统思考	176
10.2.1  系统思考之“从需求到设计”	177
10.2.2  系统思考之“5个设计视图”	179
10.3  5视图方法实践——5个视图、15个设计任务	181
10.3.1  逻辑架构＝模块划分＋接口定义＋领域模型	181
10.3.2  开发架构＝技术选型＋文件划分＋编译关系	184
10.3.3  物理架构＝硬件分布＋软件部署＋方案优化	185
10.3.4  运行架构＝技术选型＋控制流划分＋同步关系	187
10.3.5  数据架构＝技术选型＋存储格式＋数据分布	188
10.4  实际应用（8）——PM Suite贯穿案例之细化架构设计	189
10.4.1  PM Suite接下来的设计任务	189
10.4.2  客户端设计的相关说明	191
10.4.3  细化领域模型时应注意的两点	192
第11章  架构验证	194
11.1  原型技术	194
11.1.1  水平原型vs.垂直原型，抛弃原型vs.演进原型	195
11.1.2  水平抛弃原型	196
11.1.3  水平演进原型	197
11.1.4  垂直抛弃原型	197
11.1.5  垂直演进原型	197
11.2  架构验证	198
11.2.1  原型法	198
11.2.2  框架法	199
11.2.3  测试运行期质量，评审开发期质量	199
第3部分  模块划分专题
第12章  粗粒度“功能模块”划分	202
12.1  功能树	203
12.1.1  什么是功能树	203
12.1.2  功能分解≠结构分解	203
12.2  借助功能树，划分粗粒度“功能模块”	204
12.2.1  核心原理：从“功能组”到“功能模块”	205
12.2.2  第1步：获得功能树	207
12.2.3  第2步：评审功能树	211
12.2.4  第3步：粗粒度“功能模块”划分	212
12.3  实际应用（9）——对比MailProxy案例的4种模块划分设计	213
12.3.1  设计	213
12.3.2  设计的优点、缺点	213
12.4  实际应用（10）——做总体，要提交啥样的“子系统划分方案”	214
第13章  如何分层	217
13.1  分层架构	218
13.1.1  常见模式：展现层、业务层、数据层	218
13.1.2  案例一则	218
13.1.3  常见模式：UI层、SI层、PD层、DM层	219
13.1.4  案例一则	220
13.2  分层架构实践技巧	221
13.2.1  设计思想：分层架构的“封装外部交互”思想	221
13.2.2  实践技巧：设计分层架构，从上下文图开始	221
13.3  实际应用（11）——对比MailProxy案例的 4种模块划分设计	223
13.3.1  设计	223
13.3.2  设计的优点、缺点	224
第14章  用例驱动的模块划分过程	225
14.1  描述需求的序列图 vs. 描述设计的序列图	225
14.1.1  描述“内外对话” vs. 描述“内部协作”	226
14.1.2 《用例规约》这样描述“内外对话”	227
14.2  用例驱动的模块划分过程	228
14.2.1  核心原理：从用例到类，再到模块	228
14.2.2  第1步：实现用例需要哪些类	231
14.2.3  第2步：这些类应该划归哪些模块	235
14.3  实际应用（12）——对比MailProxy案例的 4种模块划分设计	236
14.3.1  设计	236
14.3.2  设计的优点、缺点	236
第15章  模块划分的4步骤方法——运用层、模块、功能 模块、用例驱动	238
15.1  像专家一样思考	238
15.1.1  自顶向下vs.自底向上，垂直切分vs.水平切分	238
15.1.2  横切竖割，并不矛盾	239
15.2  模块划分的4步骤方法——EDD方法	241
15.2.1  封装驱动设计的4个步骤	241
15.2.2  细粒度模块的划分技巧	242
15.3  实际应用（13）——对比MailProxy案例的4种模块划分设计	245
15.3.1  设计	245
15.3.2  设计的优点、缺点	246
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件架构设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业应用架构模式
模式列表
译者序
前言
引言
第一部分 表述
第1章 分层
第2章 组织领域逻辑
第3章 映射到关系数据库
第4章 Web表现层
第5章 并发
第6章 会话状态
第7章 分布策略
第8章 通盘考虑
第二部分 模式
……
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业应用架构模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>一本书看透股权架构
目录
自序
第一部分　顶层架构
第1章　解码24个核心持股比　/  3
1.1　有限公司　/  3
1.1.1　股东捣蛋线（34%）　/  4
1.1.2　绝对控股线（51%）　/  5
1.1.3　完美控制线（67%）　/  6
1.1.4　外资待遇线（25%）　/  6
1.1.5　重大影响线（20%）　/  6
1.1.6　申请解散线（10%）　/  7
1.2　非公众股份公司　/  8
1.2.1　股东代表诉讼线（1%）　/  8
1.2.2　股东提案资格线（3%）　/  9
1.2.3　股东大会召集线（10%）　/  9
1.2.4　申请公司解散线（10%）　/  10
1.3　新三板公司　/  10
1.3.1　重大重组通过线（67%）　/  11
1.3.2　实际控制认定线（30%）　/  12
1.3.3　权益变动报告线（10%）　/  12
1.3.4　重要股东判断线（5%）　/  12
1.4　上市公司　/  13
1.4.1　重大事项通过线（67%）　/  13
1.4.2　实际控制认定线（30%）　/  15
1.4.3　要约收购触碰线（30%）　/  15
1.4.4　首发公众股比线（25%）　/  16
1.4.5　权益变动报告线（20%）　/  16
1.4.6　科创板激励上限（20%）　/  16
1.4.7　激励总量控制线（10%）　/  17
1.4.8　重要股东判断线（5%）　/  18
1.4.9　股东减持限制线（2%）　/  21
1.4.10　独立董事提议线（1%）　/  21
第2章　分股不分权的7种方法　/  22
2.1　有限合伙企业　/  23
2.1.1　有限合伙企业简介　/  23
2.1.2　案例1　海康威视　/  24
2.1.3　有限合伙企业妙用　/  27
2.2　金字塔架构　/  29
2.2.1　金字塔架构简介　/  29
2.2.2　金字塔架构启发　/  31
2.2.3　两种股权架构比较　/  37
2.3　一致行动人　/  41
2.3.1　一致行动人的概念　/  41
2.3.2　案例2　养元饮品　/  43
2.3.3　一致行动人点评　/  45
2.3.4　一致行动人协议　/  48
2.4　委托投票权　/  53
2.4.1　委托投票权的定义　/  53
2.4.2　案例3　天常股份　/  53
2.4.3　委托投票权点评　/  54
2.5　公司章程控制　/  54
2.5.1　案例４　上海新梅　/  55
2.5.2　公司章程要点　/  63
2.6　优先股　/  69
2.6.1　优先股的含义　/  69
2.6.2　案例5　中导光电　/  69
2.6.3　优先股点评　/  72
2.7　AB股　/  73
2.7.1　AB股的概念　/  73
2.7.2　案例6　小米集团　/  75
2.7.3　AB股点评　/  80
第3章　分股的“道”和“术”　/  85
3.1　分股之道　/  85
3.1.1　擅平衡：案例7　独立新媒　/  85
3.1.2　知深浅：案例8　1号店　/  88
3.1.3　驭人性：案例9　真功夫　/  92
3.2　分股之术　/  95
3.2.1　vesting制度　/  95
3.2.2　控分股节奏　/  100
3.2.3　避分配雷区　/  100
第二部分　主体架构
第4章　有限合伙架构　/  112
4.1　有限合伙架构简介　/  112
4.2　案例10　蚂蚁金服　/  113
4.3　有限合伙架构实操要点　/  116
4.3.1　合伙企业的税收陷阱　/  117
4.3.2　合伙企业注册地陷阱　/  119
4.4　有限合伙架构适用情形　/  123
4.4.1　钱权分离度极高的创始人股东　/  123
4.4.2　有短期套现意图的财务投资人　/  125
4.4.3　员工持股平台　/  126
第5章　自然人直接架构　/  127
5.1　自然人直接架构简介　/  127
5.2　案例11　明家科技　/  127
5.3　自然人直接架构点评　/  128
5.3.1　自然人直接架构的优点　/  128
5.3.2　自然人直接架构的缺点　/  132
5.3.3　自然人直接架构适用情形 　/  134
第6章　控股公司架构　/  135
6.1　控股公司架构简介　/  135
6.2　案例12　红星美凯龙　/  136
6.2.1　架构调整之痛　/  136
6.2.2　美凯龙案例反思　/  139
6.3　控股公司架构点评　/  140
6.3.1　控股公司架构的优点　/  140
6.3.2　控股公司架构的缺点　/  141
6.3.3　控股公司架构适用情形　/  142
第7章　混合股权架构　/  143
7.1　混合股权架构简介　/  143
7.2　案例13　公牛集团　/  144
7.2.1　要上市的公牛　/  144
7.2.2　顶层架构设计　/  145
7.2.3　主体架构详解　/  148
7.3　混合股权架构点评　/  149
7.4　混合股权架构适用情形　/  150
第8章　海外股权架构　/  151
8.1　海外股权架构素描　/  151
8.1.1　红筹架构：股权控制模式和VIE模式　/  151
8.1.2　“走出去”架构：案例14　巨轮股份　/  153
8.2　案例15　龙湖地产　/  157
8.2.1　返程投资架构　/  158
8.2.2　5层龙湖架构　/  159
8.3　海外股权架构实操要点　/  164
8.3.1　红筹架构的并购审批　/  165
8.3.2　海外股权架构的外汇登记　/  169
8.3.3　海外股权架构的税收要点　/  173
第9章　契约型架构　/  176
9.1　契约型架构概述　/  176
9.2　案例16　奥康国际　/  177
9.2.1　设立员工持股计划　/  178
9.2.2　购买奥康国际股票　/  180
9.2.3　员工持股计划套现　/  181
9.3　契约型架构点评　/  181
9.3.1　契约型架构的优点　/  181
9.3.2　契约型架构的缺点　/  182
第三部分　底层架构
第10章　创新型子公司　/  188
10.1　案例17　体内控股之华谊创星　/  190
10.1.1　体内控股架构介绍　/  190
10.1.2　体内控股架构点评　/  191
10.2　案例18　完全体外之顺丰集团　/  193
10.2.1　顺丰借壳前的架构调整　/  193
10.2.2　上市前调整架构的原因　/  195
10.2.3　案例启发：可以向华谊和顺丰学到什么　/  197
10.3　案例19　剥离上市之麻辣诱惑　/  198
10.3.1　剥离上市股权架构背景　/  198
10.3.2　第一阶段：“麻小外卖”初试水　/  199
10.3.3　第二阶段：“餐饮”转型“食品”　/  203
10.4　案例20　体内参股之安井食品　/  206
10.4.1　体内参股架构概览　/  206
10.4.2　体内参股架构背景　/  207
10.4.3　体内参股架构点评　/  210
第11章　复制型子公司　/  215
11.1　项目跟投机制　/  215
11.2　案例21　万科地产　/  216
11.2.1　事业合伙人持股计划　/  216
11.2.2　项目跟投制度　/  216
11.3　案例22　碧桂园　/  220
11.3.1　碧桂园激励机制　/  220
11.3.2　万科和碧桂园跟投机制对比　/  222
11.4　跟投制度点评　/  222
第12章　拆分型子公司　/  228
12.1　案例23　海底捞　/  228
12.1.1　海底捞帝国初建　/  229
12.1.2　拆分调料业务　/  229
12.1.3　拆分供应链管理　/  231
12.1.4　拆分人力资源　/  234
12.1.5　拆分信息技术　/  235
12.1.6　火锅餐饮上市　/  236
12.1.7　海底捞帝国全貌　/  238
12.2　拆分型子公司点评　/  238
第四部分　架构重组
第13章　拟上市型企业　/  242
13.1　境内IPO　/  242
第一阶段：公司创立　/  242
第二阶段：引入创业伙伴　/  243
第三阶段：创业伙伴退出　/  243
第四阶段：直接架构变混合架构　/  246
第五阶段：员工股权激励　/  250
第六阶段：上下游持股　/  255
第七阶段：引入第一轮PE　/  256
第八阶段：设立复制型控股子公司　/  262
第九阶段：设立拆分型全资子公司　/  262
第十阶段：体内设立创新型子公司　/  263
第十一阶段：体外设立创新型子公司　/  263
第十二阶段：体外设立参股公司　/  265
第十三阶段：股权置换　/  266
第十四阶段：并购体外参股公司　/  268
第十五阶段：引入第二轮PE　/  276
第十六阶段：股份制改造　/  278
第十七阶段：IPO上市 　/  281
13.2　境外上市　/  282
13.2.1　案例24　红筹架构之周黑鸭　/  282
13.2.2　案例25　红筹架构之正荣地产　/  288
13.2.3　案例26　VIE架构之美图公司　/  291
第14章　家族传承型企业　/  295
14.1　夫妻股权　/  295
14.1.1　离婚之痛：案例27　昆仑万维　/  295
14.1.2　债务之痛：案例28　小马奔腾　/  308
14.2　兄弟股权　/  312
14.2.1　兄弟反目　/  312
14.2.2　分家方案　/  312
14.3　子女股权　/  317
14.3.1　案例29　富贵鸟传承之痛　/  317
14.3.2　富贵鸟案例启发　/  323
第15章　被并购型企业　/  325
15.1　案例30　慈铭体检　/  325
15.1.1　第一阶段架构　/  325
15.1.2　第二阶段架构　/  326
15.1.3　第三阶段架构　/  329
15.1.4　第四阶段架构　/  330
15.2　被并购架构点评　/  331
15.2.1　税收筹划　/  331
15.2.2　并购基金　/  333
附录A　不同持股比含义依据法规汇编　/  335
附录B　离婚析产中期权分割司法判例　/  361
附录C　婚姻法及其司法解释　/  370
附录D　企业重组税收政策汇编　/  374
致谢　/  380
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>一本书看透股权架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入Linux内核架构
第1章　简介和概述
第2章　进程管理和调度
第3章　内存管理
第4章　进程虚拟内存
第5章　锁与进程间通信
第6章　设备驱动程序
第7章　模块
第8章　虚拟文件系统
第9章　Ext文件系统族
第10章　无持久存储的文件系统
第11章　扩展属性和访问控制表
第12章　网络
第13章　系统调用
第14章　内核活动
第15章　时间管理
第16章　页缓存和块缓存
第17章　数据同步
第18章　页面回收和页交换
第19章　审计
附录A　体系结构相关知识
附录B　使用源代码
附录C　有关C语言的注记附录D　系统启动
附录E　ELF二进制格式
附录F　内核开发过程参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入Linux内核架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>游戏引擎架构
推荐序1	iii
推荐序2	v
译序	vii
序言	xvii
前言	xix
致谢	xxi
第一部分 基础	1
第1章 导论	3
1.1 典型游戏团队的结构	4
1.2 游戏是什么	7
1.3 游戏引擎是什么	10
1.4 不同游戏类型中的引擎差异	11
1.5 游戏引擎概观	22
1.6 运行时引擎架构	27
1.7 工具及资产管道	46
第2章 专业工具	53
2.1 版本控制	53
2.2 微软Visual Studio	61
2.3 剖析工具	78
2.4 内存泄漏和损坏检测	79
2.5 其他工具	80
第3章 游戏软件工程基础	83
3.1 重温C++及最佳实践	83
3.2 C/C++的数据、代码及内存	90
3.3 捕捉及处理错误	118
第4章 游戏所需的三维数学	125
4.1 在二维中解决三维问题	125
4.2 点和矢量	125
4.3 矩阵	139
4.4 四元数	156
4.5 比较各种旋转表达方式	164
4.6 其他数学对象	168
4.7 硬件加速的SIMD运算	173
4.8 产生随机数	180
第二部分 低阶引擎系统	183
第5章 游戏支持系统	185
5.1 子系统的启动和终止	185
5.2 内存管理	193
5.3 容器	208
5.4 字符串	225
5.5 引擎配置	234
第6章 资源及文件系统	241
6.1 文件系统	241
6.2 资源管理器	251
第7章 游戏循环及实时模拟	277
7.1 渲染循环	277
7.2 游戏循环	278
7.3 游戏循环的架构风格	280
7.4 抽象时间线	283
7.5 测量及处理时间	285
7.6 多处理器的游戏循环	296
7.7 网络多人游戏循环	304
第8章 人体学接口设备（HID）	309
8.1 各种人体学接口设备	309
8.2 人体学接口设备的接口技术	311
8.3 输入类型	312
8.4 输出类型	316
8.5 游戏引擎的人体学接口设备系统	318
8.6 人体学接口设备使用实践	332
第9章 调试及开发工具	333
9.1 日志及跟踪	333
9.2 调试用的绘图功能	337
9.3 游戏内置菜单	344
9.4 游戏内置主控台	347
9.5 调试用摄像机和游戏暂停	348
9.6 作弊	348
9.7 屏幕截图及录像	349
9.8 游戏内置性能剖析	349
9.9 游戏内置的内存统计和泄漏检测	356
第三部分 图形及动画	359
第10章 渲染引擎	361
10.1 采用深度缓冲的三角形光栅化基础	361
10.2 渲染管道	404
10.3 高级光照及全局光照	426
10.4 视觉效果和覆盖层	438
10.5 延伸阅读	446
第11章 动画系统	447
11.1 角色动画的类型	447
11.2 骨骼	452
11.3 姿势	454
11.4 动画片段	459
11.5 蒙皮及生成矩阵调色板	471
11.6 动画混合	476
11.7 后期处理	493
11.8 压缩技术	496
11.9 动画系统架构	501
11.10 动画管道	502
11.11 动作状态机	515
11.12 动画控制器	535
第12章 碰撞及刚体动力学	537
12.1 你想在游戏中加入物理吗	537
12.2 碰撞/物理中间件	542
12.3 碰撞检测系统	544
12.4 刚体动力学	569
12.5 整合物理引擎至游戏	601
12.6 展望：高级物理功能	616
第四部分 游戏性	617
第13章 游戏性系统简介	619
13.1 剖析游戏世界	619
13.2 实现动态元素：游戏对象	623
13.3 数据驱动游戏引擎	626
13.4 游戏世界编辑器	627
第14章 运行时游戏性基础系统	637
14.1 游戏性基础系统的组件	637
14.2 各种运行时对象模型架构	640
14.3 世界组块的数据格式	657
14.4 游戏世界的加载和串流	663
14.5 对象引用与世界查询	670
14.6 实时更新游戏对象	676
14.7 事件与消息泵	690
14.8 脚本	707
14.9 高层次的游戏流程	726
第五部分 总结	727
第15章 还有更多内容吗	729
15.1 一些未谈及的引擎系统	729
15.2 游戏性系统	730
参考文献	733
中文索引	737
英文索引	755
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>游戏引擎架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>恰如其分的软件架构
第1章  概述 1
1.1  分治、知识与抽象 2
1.2  软件架构的三个案例 3
1.3  反思 5
1.4  视角转换 6
1.5  架构师构建架构 7
1.6  风险驱动的软件架构 8
1.7  敏捷开发者的架构 9
1.8  关于本书 10
第2章  软件架构 15
2.1  何为软件架构？ 16
2.2  软件架构为何重要 18
2.3  架构何时重要？ 22
2.4  推定架构 23
2.5  如何运用软件架构？ 24
2.6  架构无关的设计 25
2.7  专注架构的设计 26
2.8  提升架构的设计 27
2.9  大型组织中的架构 30
2.10  结论 31
2.11  延伸阅读 32
第3章  风险驱动模型 35
3.1  风险驱动模型是什么？ 37
3.2  你现在采用风险驱动了吗？ 38
3.3  风险 39
3.4  技术 42
3.5  选择技术的指导原则 44
3.6  何时停止 47
3.7  计划式设计与演进式设计 48
3.8  软件开发过程 51
3.9  理解过程变化 53
3.10  风险驱动模型与软件开发过程 55
3.11  应用于敏捷过程 56
3.12  风险与架构重构 58
3.13  风险驱动模型的替代方案 58
3.14  结论 60
3.15  延伸阅读 61
第4章  实例：家庭媒体播放器 65
4.1  团队沟通 67
4.2  COTS组件的集成 75
4.3  元数据一致性 81
4.4  结论 86
第5章  建模建议 89
5.1  专注于风险 89
5.2  理解你的架构 90
5.3  传播架构技能 91
5.4  作出合理的架构决策 92
5.5  避免预先大量设计 93
5.6  避免自顶向下设计 95
5.7  余下的挑战 95
5.8  特性和风险：一个故事 97
第6章  工程师使用模型 103
6.1  规模与复杂度需要抽象 104
6.2  抽象提供洞察力和解决手段 105
6.3  分析系统质量 105
6.4  模型忽略细节 106
6.5  模型能够增强推理 107
6.6  提问在前，建模在后 108
6.7  小结 108
6.8  延伸阅读 109
第7章  软件架构的概念模型 111
7.1  规范化模型结构 114
7.2  领域模型、设计模型和代码模型 115
7.3  指定与细化关系 116
7.4  主模型的视图 118
7.5  组织模型的其他方式 121
7.6  业务建模 121
7.7  UML的用法 122
7.8  小结 123
7.9  延伸阅读 123
第8章  领域模型 127
8.1  领域与架构的关系 128
8.2  信息模型 131
8.3  导航和不变量 133
8.4  快照 134
8.5  功能场景 135
8.6  小结 136
8.7  延伸阅读 137
第9章  设计模型 139
9.1  设计模型 140
9.2  边界模型 141
9.3  内部模型 141
9.4  质量属性 142
9.5  Yinzer系统的设计之旅 143
9.6  视图类型 157
9.7  动态架构模型 161
9.8  架构描述语言 162
9.9  小结 163
9.10  深入阅读 164

第10章  代码模型 167
10.1  模型-代码差异 167
10.2  一致性管理 171
10.3  架构明显的编码风格 174
10.4  在代码中表达设计意图 175
10.5  模型嵌入代码原理 177
10.6  表达什么 178
10.7  在代码中表达设计意图的模式 180
10.8  电子邮件处理系统预演 187
10.9  小结 193
第11章  封装和分割 195
11.1  多层级故事 195
11.2  层级和分割 197
11.3  分解策略 199
11.4  有效封装 203
11.5  创建封装接口 206
11.6  小结 210
11.7  深入阅读 210
第12章  模型元素 213
12.1  和部署相关的元素 214
12.2  组件 215
12.3  组件装配 219
12.4  连接器 223
12.5  设计决策 233
12.6  功能场景 234
12.7  (不变量(约束) 239
12.8  模块 239
12.9  端口 241
12.10  质量属性 246
12.11  质量属性场景 249
12.12  职责 251
12.13  权衡 252
12.14  小结 253
第13章  模型关系 255
13.1  投影(视图)关系 256
13.2  分割关系 261
13.3  组合关系 261
13.4  分类关系 261
13.5  泛化关系 262
13.6  指定关系 263
13.7  细化关系 264
13.8  绑定关系 268
13.9  依赖关系 269
13.10  使用关系 269
13.11  小结 270
13.12  深入阅读 271
第14章  架构风格 273
14.1  优势 274
14.2  柏拉图式风格对体验式风格 275
14.3  约束和以架构为中心的设计 276
14.4  模式对风格 277
14.5  风格目录 277
14.6  分层风格 277
14.7  大泥球风格 280
14.8  管道-过滤器风格 281
14.9  批量顺序处理风格 283
14.10  以模型为中心的风格 285
14.11  分发-订阅风格 286
14.12  客户端-服务器风格和多层 288
14.13  对等风格 290
14.14  map-reduce风格 291
14.15  镜像，支架和农场风格 293
14.16  小结 294
14.17  深入阅读 295
第15章  使用架构模型 297
15.1  理想的模型特性 297
15.2  和视图一起工作 303
15.3  改善视图质量 306
15.4  提高图的质量 310
15.5  测试和证明 312
15.6  分析架构模型 312
15.7  架构不匹配 318
15.8  选择你的抽象级别 319
15.9  规划用户界面 320
15.10  指定性模型对描述性模型 320
15.11  对现有系统进行建模 320
15.12  小结 322
15.13  深入阅读 323
第16章  结论 325
16.1  挑战 326
16.2  聚焦质量属性 330
16.3  解决问题，而不是仅仅对它们建模 331
16.4  使用导轨一样的约束 332
16.5  使用标准架构抽象 333
术语表 335
文献 347
索引 355
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>恰如其分的软件架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业级业务架构设计：方法论与实践
推荐语
前言
第一部分 　业务架构基础篇
第1章　业务架构的发展历程2
1.1　Zachman模型2
1.2　TOGAF4
1.3　FEA和DODAF5
1.4　沉吟至今6
1.5　业务架构的定义8
第2章　业务架构的作用及与IT架构的关系10
2.1　业务架构的作用10
2.2　业务架构与IT架构的关系14
第3章　架构伴侣：业务模型18
3.1　模型与业务模型18
3.2　常见的建模方法21
3.3　建模原则与模型思维的应用25
第二部分 　业务架构设计篇
第4章　业务架构的设计起点33
4.1　企业战略分析33
4.2　对标分析38
4.3　组织结构的影响不容忽视40
第5章　业务架构的设计过程44
5.1　价值链分析44
5.2　行为分析：业务领域和业务流程46
5.3　数据分析：企业级数据模型49
5.4　组件分析：行为与数据的结合51
5.5　业务架构的整体逻辑关系53
第6章　业务架构的设计难点56
6.1　基本的标准化方法56
6.2　避免“过度整合”59
6.3　何以解忧，唯有“融合”59
第7章　虚拟案例：商业银行业务架构设计61
7.1　价值链设计61
7.2　存款领域的模型设计63
7.3　贷款领域的模型设计65
7.4　跨领域的标准化67
7.5　组件设计70
7.6　案例总结73
第三部分 　业务架构落地篇
第8章　从业务架构模型到业务架构方案76
8.1　业务架构设计不是为了替代需求分析76
8.2　制作业务架构方案77
8.3　小团队的应对之道83
8.4　需要充分解释架构方案84
8.5　努力打造“通用语言”85
第9章　基于业务架构方案的实施过程88
9.1　基于业务架构的设计89
9.2　基于业务架构的协调94
9.3　处理架构调整的原则96
9.4　企业级物有所值吗？100
第10章　建立转型后的长期应用机制103
10.1　项目结束了该怎么办？103
10.2　促进深度融合的需求管理机制106
第11章　这个“笨重”的过程与敏捷沾边吗？110
11.1　传说中和现实中的双模开发110
11.2　与正宗的敏捷对比112
11.3　与非正宗的敏捷对比114
11.4　且行且珍惜115
第12章　企业级的“五难” 117
12.1　捷径难寻118
12.2　文化难建119
12.3　预期难控120
12.4　权责难定121
12.5　长志难立123
第13章　实战：实现了快速设计的案例124
13.1　项目背景及需求124
13.2　设计思路和业务架构方案125
13.3　案例总结129
第四部分 　架构方法改良篇
第14章　如何支持面向构件的设计132
14.1　“乐高积木”式的软件设计132
14.2　“颗粒度”问题134
14.3　构件模型的设计方式136
14.4　建立构件模型的虚拟案例139
14.5　构件模型的技术设计建议146
14.6　本章小结148
第15章　构建轻量级架构管理工具150
15.1　构件模型的抽象要素及逻辑关系150
15.2　轻量级架构管理工具的设计原理153
15.3　采集项目信息的价值155
15.4　轻量级架构管理工具的优缺点155
15.5　应用轻量级架构管理工具管理新需求156
第16章　基于构件模型谈谈传统企业的产品创新159
16.1　信息传导：打造信息传递高速公路160
16.2　信息分析：创造高维数据162
16.3　创新平台：扩展构件模型165
16.4　构件模型及其应用设想的不足169
第五部分 　业务架构与中台篇
第17章　中台之上172
17.1　阿里中台简介172
17.2　企业文化的作用174
17.3　由业务架构方法可以推导出中台设计吗？176
尾声　对实践的再次思考179
附录A　位置、力量、资源183
附录B　积木式创新187
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业级业务架构设计：方法论与实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构探险――从零开始写Java Web框架
第1章 从一个简单的Web应用 1
正所谓“工欲善其事，必先利其器”，在正式开始设计并开发我们的轻量级Java Web框架之前，有必要首先掌握以下技能：
使用IDEA搭建并开发Java项目；
使用Maven自动化构建Java项目；
使用Git管理项目源代码。
1.1 使用IDEA创建Maven项目 3
1.1.1 创建IDEA项目 3
1.1.2 调整Maven配置 3
1.2 搭建Web项目框架 5
1.2.1 转为Java Web项目 5
1.2.2 添加Java Web的Maven依赖 6
1.3 编写一个简单的Web应用 10
1.3.1 编写 Servlet类 10
1.3.2 编写JSP页面 11
1.4 让Web应用跑起来 12
1.4.1 在IDEA中配置Tomcat 12
1.4.2 使用Tomcat的Maven插件 13
1.4.3 以Debug方式运行程序 13
1.5 将代码放入Git仓库中 14
1.5.1 编写.gitignore文件 14
1.5.2 提交本地 Git 仓库 15
1.5.3 推送远程Git仓库 15
1.5.4 总结 16
第2章 为Web应用添加业务功能 17
我们将在这个应用的基础上增加一些业务功能，您将学会更多有关项目实战的技能，具体包括：
如何进行需求分析；
如何进行系统设计；
如何编写应用程序。
2.1 需求分析与系统设计 19
2.1.1 需求分析 19
2.1.2 系统设计 19
2.2 动手开发Web应用 21
2.2.1 创建数据库 22
2.2.2 准备开发环境 22
2.2.3 编写模型层 23
2.2.4 编写控制器层 25
2.2.5 编写服务层 27
2.2.6 编写单元测试 28
2.2.7 编写视图层 31
2.3 细节完善与代码优化 31
2.3.1 完善服务层 32
2.3.2 完善控制器层 59
2.3.3 完善视图层 60
2.4 总结 65
第3章 搭建轻量级Java Web框架 66
我们需要这样的框架，它足够轻量级、足够灵巧，不妨给它取一个优雅的名字——Smart Framework，本章我们就一起来实现这个框架。
您将通过本章的学习，掌握如下技能：
如何快速搭建开发框架；
如何加载并读取配置文件；
如何实现一个简单的IOC容器；
如何加载指定的类；
如何初始化框架。
3.1 确定目标 68
3.2 搭建开发环境 70
3.2.1 创建框架项目 70
3.2.2 创建示例项目 73
3.3 定义框架配置项 74
3.4 加载配置项 75
3.5 开发一个类加载器 78
3.6 实现Bean容器 87
3.7 实现依赖注入功能 90
3.8 加载Controller 93
3.9 初始化框架 97
3.10 请求转发器 98
3.11 总结 109
第4章 使框架具备AOP特性 110
在本章中，读者将学到大量有用的技术，具体包括：
如何理解并使用代理技术；
如何使用Spring提供的AOP技术；
如何使用动态代理技术实现AOP框架；
如何理解并使用ThreadLocal技术；
如何理解数据库事务管理机制；
如何使用AOP框架实现事务控制。
4.1 代理技术简介 112
4.1.1 什么是代理 112
4.1.2 JDK动态代理 114
4.1.3 CGlib动态代理 116
4.2 AOP技术简介 118
4.2.1 什么是AOP 118
4.2.2 写死代码 119
4.2.3 静态代理 120
4.2.4 JDK动态代理 121
4.2.5 CGLib动态代理 122
4.2.6 Spring AOP 124
4.2.7 Spring + AspectJ 136
4.3 开发AOP框架 142
4.3.1 定义切面注解 142
4.3.2 搭建代理框架 143
4.3.3 加载AOP框架 150
4.4 ThreadLocal简介 158
4.4.1 什么是ThreadLocal 158
4.4.2 自己实现ThreadLocal 161
4.4.3 ThreadLocal使用案例 163
4.5 事务管理简介 172
4.5.1 什么是事务 172
4.5.2 事务所面临的问题 173
4.5.3 Spring的事务传播行为 175
4.6 实现事务控制特性 178
4.6.1 定义事务注解 178
4.6.2 提供事务相关操作 181
4.6.3 编写事务代理切面类 182
4.6.4 在框架中添加事务代理机制 184
4.7 总结 185
第5章 框架优化与功能扩展 186
本章将对现有框架进行优化，并提供一些扩展功能。通过本章的学习，读者可以了解到：
如何优化Action参数；
如何实现文件上传功能；
如何与Servlet API完全解耦；
如何实现安全控制框架；
如何实现Web服务框架。
5.1 优化Action参数 188
5.1.1 明确Action参数优化目标 188
5.1.2 动手优化Action参数使用方式 188
5.2 提供文件上传特性 191
5.2.1 确定文件上传使用场景 191
5.2.2 实现文件上传功能 194
5.3 与Servlet API解耦 214
5.3.1 为何需要与Servlet API解耦 214
5.3.2 与Servlet API解耦的实现过程 215
5.4 安全控制框架——Shiro 219
5.4.1 什么是Shiro 219
5.4.2 Hello Shiro 220
5.4.3 在Web开发中使用Shiro 224
5.5 提供安全控制特性 230
5.5.1 为什么需要安全控制 230
5.5.2 如何使用安全控制框架 231
5.5.3 如何实现安全控制框架 242
5.6 Web服务框架——CXF 261
5.6.1 什么是CXF 261
5.6.2 使用CXF开发SOAP服务 262
5.6.3 基于SOAP的安全控制 278
5.6.4 使用CXF开发REST服务 291
5.7 提供Web服务特性 308
5.8 总结 329
附录A Maven快速入门 330
附录B 将构件发布到Maven中央仓库 342
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构探险――从零开始写Java Web框架
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件架构师的12项修炼
译者序
前  言
致  谢
第一部分   关系技能修炼
第1章　文雅的举止	3
1.1　别人怎样评价你	3
1.2　技术之天花板	4
1.3　变得文雅、专业的途径	6
1.3.1　注重关系甚于争执孰对孰错	6
1.3.2　学会委派	8
1.3.3　生活是有反作用的	9
1.3.4　有效沟通之生与死	11
1.3.5　要正直诚实而不是率直	13
1.3.6　不要掩盖问题—它们以后还会冒出来的	14
1.3.7　提供专业的服务	16
1.3.8　忘掉以前的冒犯	17
1.4　小结	19
1.5　参考资料	19
第2章　沟通	22
2.1　沟通原则	23
2.1.1　先听后说	24
2.1.2　专心致志	24
2.1.3　正面思考	25
2.1.4　尽早道歉	25
2.1.5　不要在缺陷上招致恼羞成怒	26
2.2　沟通策略	27
2.2.1　多说“是”，少说“不是”	27
2.2.2　在销售过程中建立起信任关系	28
2.2.3　特殊场合才说“不”	29
2.2.4　抑制想自卫的冲动	31
2.2.5　倾听建议来改善合作	31
2.2.6　了解别人和自己的沟通需求	32
2.2.7　才思敏捷	34
2.3　与执行官沟通	35
2.3.1　执行官需要信任、忠诚和连贯性	35
2.3.2　清晰性甚于完整性	36
2.3.3　不要让执行官感到惊讶	37
2.4　小结	38
2.5　参考资料	39
第3章　协商	41
3.1　协商原则	42
3.1.1　不要让人惊讶	42
3.1.2　不要模棱两可	43
3.1.3　委派权威而不是义务	43
3.1.4　有困难时寻求帮助	44
3.1.5　不要掩盖问题	44
3.1.6　即使很难，也要坚持做正确的事	45
3.2　协商策略	45
3.2.1　倾听你的内心呼唤	45
3.2.2　设法同意	45
3.2.3　不要找分歧	47
3.2.4　寻找共同点	47
3.2.5　如果无法达到一致，就让所有人稍微不满吧	48
3.2.6　将协商作为一种改进措施	49
3.3　协商前的工作	49
3.3.1　知道哪些是可协商的	49
3.3.2　了解如何在单位里游刃有余	51
3.3.3　关键决定上寻求合作氛围	52
3.3.4　学习文化	53
3.3.5　让别人明白你的想法	53
3.4　协商的收尾	54
3.4.1　捍卫决策的执行	54
3.4.2　维护架构决定记录	54
3.4.3　你有时会赢，有时会输	55
3.4.4　从委派中学习	56
3.5　小结	56
3.6　参考资料	58
第4章　领导力	60
4.1　领导力的原则	61
4.1.1　建立信任关系	61
4.1.2　建立共识	62
4.1.3　建立战略伙伴关系（通过关系带来安全）	62
4.1.4　要身体力行（为你所说的话带来安全）	63
4.1.5　感知风险、评估影响、做出行动（明确风险的清晰度）	64
4.1.6　适当处理风险：什么是鞭炮，什么是原子弹（明确影响的清晰度）	65
4.2　领导策略	66
4.2.1　奥卡姆剃刀法	66
4.2.2　展现可视化信息	66
4.2.3　领导者要确保事情不跑题	67
4.2.4　基于环境推销	68
4.2.5　随大流（找机会利用已有的资源）	69
4.2.6　关注执行官于认知，而非解决冲突	69
4.3　领导的时机	70
4.3.1　利用单位的动量	70
4.3.2　知道何时伸出援手	71
4.3.3　允许其他人学习	71
4.3.4　知道何时该卓尔不群	72
4.3.5　请求原谅还是征求允许	73
4.4　领导别人	73
4.4.1　允许别人奉献（不要命令）	74
4.4.2　通过影响力激励别人	76
4.4.3　确保别人能做主	76
4.4.4　处理冲突	77
4.5　小结	77
4.6　参考资料	79
第5章　政治	81
5.1　政治的定义	81
5.2　政治市场	82
5.3　政治环境	85
5.3.1　与公司的战略方向保持一致	85
5.3.2　理解你所处的文化环境	86
5.3.3　及早处理别人关注的问题	87
5.3.4　相信你所推销的东西	89
5.3.5　不关我的事	90
5.3.6　关系很重要（与别人的关系）	90
5.4　政治原则	91
5.4.1　宽宏大量	91
5.4.2　不要为你的价值妥协	92
5.4.3　光明正大地竞争	92
5.4.4　透明地操作	92
5.4.5　你是怎样的人就怎样表现	93
5.4.6　帮助别人，不求回报	93
5.4.7　认识到生活是反身的	93
5.5　政治策略	94
5.5.1　帮助别人达成其目标	94
5.5.2　学会享受过程而不是目标	94
5.5.3　在关键之处力争出色	95
5.5.4　愿意就低优先级目标妥协	95
5.5.5　不要对别人的糟糕举止采取冒犯的行动	96
5.5.6　私下处理人际问题	97
5.6　政治时机	97
5.6.1　以适时的作风执行事情	97
5.6.2　今天失利并不代表明天不会成功	98
5.6.3　要认识到政治上你不会是常胜将军	99
5.6.4　积极参与政治游戏	99
5.7　成为一名好的政治人物	100
5.8　参考资料	101
第二部分　个人技能修炼
第6章　透明化	105
6.1　住在玻璃房中的架构师	105
6.2　透明化的类型	106
6.3　自我透明化	107
6.3.1　表现自然真诚	107
6.3.2　承认自己的弱点	108
6.3.3　承认你的实力和兴趣	109
6.3.4　赶在人前与上司沟通	110
6.4　项目透明化	111
6.4.1　让执行官看到你手里所有的扑克牌	111
6.4.2　架构师把透明化和清晰性带到许多领域	112
6.4.3　架构师将“发现”变成“收获”	113
6.5　关系透明化	116
6.5.1　该信任时就给别人信任	116
6.5.2　你说的话长久不变	117
6.5.3　道歉表明你的透明化	118
6.5.4　学会在做出反应前倾听（寻求透明化）	118
6.5.5　允许别人对你透明化	119
6.6　成为一名透明的架构师	119
6.7　参考资料	120
第7章　激情	122
7.1　什么是激情	123
7.2　发现激情	124
7.2.1　如何找到激情	124
7.2.2　恒心与激情：终极的杀手组合	125
7.2.3　岗位上的激情	126
7.2.4　重新点燃激情	127
7.3　将激情作为向导	127
7.3.1　等待机遇：它经常在找你，说话非常轻	128
7.3.2　跟着直觉走	129
7.3.3　选择你有激情的领域	129
7.3.4　改变会督促你前行	130
7.3.5　缺乏激情会成为你事业上升的天花板	131
7.3.6　把难事做好，尽心尽力投入	131
7.3.7　激情是提供动力的内在燃料	132
7.4　保护你的激情	132
7.4.1　忽略批评：这是你的激情、你的认知，不是他们的	132
7.4.2　不要分神	133
7.5　今天能做什么来追求你的激情	134
7.6　学会投入并享受过程	135
7.7　成为一名激情四射的架构师	135
7.8　参考资料	136
第8章　语境切换	138
8.1　自我意识语境	140
8.1.1　专心致志	140
8.1.2　明白你的弱项	141
8.1.3　生命中不仅仅有工作	141
8.1.4　多任务工作的效率奥秘	141
8.1.5　控制你的肾上腺素：慢下来	142
8.2　架构意识语境	142
8.2.1　使用“可/有…性”的字眼	142
8.2.2　寻求适当的耦合性和内聚性	142
8.2.3　持续构建你的语境	143
8.3　“大象”语境	144
8.3.1　哪些事没有提到	144
8.3.2　提问一些难题	145
8.3.3　早些发出坏消息	145
8.3.4　如果他们拥有这个公司，他们会怎么做	146
8.4　决策意识语境	146
8.4.1　他们真的已经把问题解决了	146
8.4.2　他们知道哪些替代方案可行吗	147
8.4.3　别人是否已经权衡过此技术	147
8.4.4　作为中立的第三方，即便这样做是个缺点	147
8.5　交谈语境	148
8.5.1　不要开会和用电子邮件	148
8.5.2　如果需要，（马上）让别人参与进来	148
8.6　谈话者语境	148
8.6.1　了解你的谈话对象	148
8.6.2　中庸之道	149
8.6.3　有时要唱红脸，有时要唱白脸	149
8.6.4　提供背景信息	149
8.7　项目语境	150
8.7.1　提出预算	150
8.7.2　带来实用性	151
8.7.3　学会在雪崩中冲浪	151
8.7.4　挑出专门的资源	151
8.7.5　你做出了哪些假设条件	152
8.8　成为一名善于察言观色、见风使舵的架构师	152
8.9　参考资料	154
第三部分　商务技能修炼
第9章　商务知识	157
9.1　了解商务	159
9.1.1　营销、财务（投入产出比）和销售	159
9.1.2　考虑拿一个商务学位	161
9.2　了解你的公司	162
9.2.1　了解产品对客户的价值所在	162
9.2.2　知道你的公司如何赚钱	163
9.2.3　了解你公司的历史、文化	163
9.3　了解你的顾客	164
9.3.1　考虑拜访顾客、打电话给销售或者在门面上帮员工干活	164
9.3.2　考虑参与可用性研究，参与产品概念访谈或其他客户产品评估	167
9.3.3　考虑使用敏捷技术	167
9.4　了解你的领域	167
9.4.1　收集领域知识	168
9.4.2　在商务环境中了解你的领域	169
9.5　帮助公司更好地了解技术	169
9.6　成为一名谙熟商务的架构师	170
9.7　参考资料	171
第10章　创新	173
10.1　创新的定义	174
10.2　建立边界条件	175
10.2.1　找出边界条件	175
10.2.2　在边界内创新	176
10.2.3　你会做什么（假如没有约束条件，不必故作姿态）	178
10.2.4　鼓励别人思考、开放	178
10.2.5　应对那些唱反调的人	179
10.2.6　避开唱反调的人，找个安全的地方来思考	179
10.3　发展内心准则	179
10.3.1　顺从你的直觉	179
10.3.2　学会信任自己	180
10.3.3　认真倾听客户的声音，但要保持自己的认知	180
10.3.4　听听别人的话（协作）	181
10.3.5　你今天能迈出一小步吗	181
10.3.6　今天不行没关系：继续埋头苦干，早晚会成功的	182
10.4　组合基本概念	182
10.4.1　阅读、阅读、还是阅读	183
10.4.2　疯狂的主意让你发现真正的边界	183
10.4.3　要有大眼光	184
10.4.4　创新者的困难抉择	184
10.4.5　创新与集聚：将事情按正确分组整合在一起	184
10.4.6　选择简洁	185
10.4.7　简洁性是知识产权的根本	185
10.4.8　在着手解决前先思考问题	186
10.4.9　定义问题	186
10.4.10　睡觉时思考	187
10.4.11　战略问题还是战术问题	187
10.5　成为一名能创新的架构师	187
10.6　参考资料	189
第11章　实用主义	191
11.1　实用型架构的定义	191
11.2　范围管理	192
11.2.1　与商务伙伴一起确定特性的优先级	192
11.2.2　帮助执行官做出正确决策	193
11.2.3　处理不确定性	193
11.2.4　有些时候，你只需要一个概念就能开始干了	193
11.2.5　使用敏捷过程作为一种实用主义方法	194
11.3　风险管理	194
11.3.1　区分可能性和可行性	194
11.3.2　对于每个决定，都自问一些重要的问题	196
11.3.3　应对可能的风险	197
11.3.4　架构刺探	197
11.3.5　与运营人员一起确定效率	197
11.3.6　观察其他项目，决定有哪些地方是可牺牲的	198
11.4　沟通	198
11.4.1　记录下大家一致同意的决议	199
11.4.2　提供多种替代方案，并推荐其中一种	199
11.4.3　用透明性拉平期望值	199
11.4.4　发展经验方法来估量项目	200
11.5　成为一名实用主义的架构师	200
11.6　参考资料	201
第12章　认知	203
12.1　认知之定义	204
12.2　找寻和创立引人注目的目标	204
12.2.1　发现认知	204
12.2.2　从混沌现实编造出有说服力的故事	206
12.2.3　克服障碍	207
12.3　开发与建立战略路线图	208
12.3.1　将路线映射至认知	208
12.3.2　制定支持认知的战略	209
12.4　确定志同道合的伙伴	210
12.4.1　认知需要齐心协力	210
12.4.2　认知要求有关键的利益相关者	211
12.4.3　认知需要资金支持	212
12.5　实践认知	213
12.5.1　将认知当做增加投入产出比的战略	213
12.5.2　使用认知灌输目标感	213
12.5.3　在项目评估时就应用认知	214
12.5.4　采用支出信封（界定认知范围）	215
12.6　成为一名有远见的架构师	215
12.7　参考资料	216
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件架构师的12项修炼
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud与Docker微服务架构实战
1 微服务架构概述. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.1 单体应用架构存在的问题1
1.2 如何解决单体应用架构存在的问题3
1.3 什么是微服务3
1.4 微服务架构的优点与挑战5
1.4.1 微服务架构的优点5
1.4.2 微服务架构面临的挑战5
1.5 微服务设计原则6
1.6 如何实现微服务架构7
1.6.1 技术选型7
1.6.2 架构图及常用组件8
2 微服务开发框架——Spring Cloud . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2.1 Spring Cloud 简介10
2.2 Spring Cloud 特点10
2.3 Spring Cloud 版本11
2.3.1 版本简介11
2.3.2 子项目一览12
2.3.3 Spring Cloud/Spring Boot 版本兼容性13
3 开始使用Spring Cloud 实战微服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
3.1 Spring Cloud 实战前提14
3.1.1 技术储备14
3.1.2 工具及软件版本15
3.2 服务提供者与服务消费者16
3.3 编写服务提供者16
3.3.1 手动编写项目17
3.3.2 使用Spring Initializr 快速创建Spring Boot 项目21
3.4 编写服务消费者23
3.5 为项目整合Spring Boot Actuator 25
3.6 硬编码有哪些问题27
4 微服务注册与发现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
4.1 服务发现简介29
4.2 Eureka 简介31
4.3 Eureka 原理31
4.4 编写Eureka Server 33
4.5 将微服务注册到Eureka Server 上35
4.6 Eureka Server 的高可用36
4.6.1 将应用注册到Eureka Server 集群上38
4.7 为Eureka Server 添加用户认证39
4.7.1 将微服务注册到需认证的Eureka Server 40
4.8 理解Eureka 的元数据41
4.8.1 改造用户微服务41
4.8.2 改造电影微服务41
4.9 Eureka Server 的REST 端点43
4.9.1 示例45
4.9.2 注销微服务实例49
4.10 Eureka 的自我保护模式51
4.11 多网卡环境下的IP 选择52
4.11.1 忽略指定名称的网卡52
4.11.2 使用正则表达式，指定使用的网络地址52
4.11.3 只使用站点本地地址53
4.11.4 手动指定IP 地址53
4.12 Eureka 的健康检查53
5 使用Ribbon 实现客户端侧负载均衡. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
5.1 Ribbon 简介56
5.2 为服务消费者整合Ribbon 57
5.3 使用Java 代码自定义Ribbon 配置60
5.4 使用属性自定义Ribbon 配置63
5.5 脱离Eureka 使用Ribbon 64
6 使用Feign 实现声明式REST 调用. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
6.1 Feign 简介67
6.2 为服务消费者整合Feign 67
6.3 自定义Feign 配置69
6.4 手动创建Feign 72
6.4.1 修改用户微服务72
6.4.2 修改电影微服务76
6.5 Feign 对继承的支持78
6.6 Feign 对压缩的支持79
6.7 Feign 的日志80
6.8 使用Feign 构造多参数请求82
6.8.1 GET 请求多参数的URL 82
6.8.2 POST 请求包含多个参数83
7 使用Hystrix 实现微服务的容错处理. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
7.1 实现容错的手段85
7.1.1 雪崩效应85
7.1.2 如何容错86
7.2 使用Hystrix 实现容错88
7.2.1 Hystrix 简介88
7.2.2 通用方式整合Hystrix 89
7.2.3 Hystrix 断路器的状态监控与深入理解91
7.2.4 Hystrix 线程隔离策略与传播上下文93
7.2.5 Feign 使用Hystrix 96
7.3 Hystrix 的监控101
7.3.1 Feign 项目的Hystrix 监控102
7.4 使用Hystrix Dashboard 可视化监控数据103
7.5 使用Turbine 聚合监控数据105
7.5.1 Turbine 简介105
7.5.2 使用Turbine 监控多个微服务105
7.5.3 使用消息中间件收集数据108
8 使用Zuul 构建微服务网关. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
8.1 为什么要使用微服务网关113
8.2 Zuul 简介115
8.3 编写Zuul 微服务网关115
8.4 Zuul 的路由端点118
8.5 Zuul 的路由配置详解119
8.6 Zuul 的安全与Header 122
8.6.1 敏感Header 的设置122
8.6.2 忽略Header 123
8.7 使用Zuul 上传文件124
8.7.1 编写文件上传微服务124
8.8 Zuul 的过滤器127
8.8.1 过滤器类型与请求生命周期127
8.8.2 编写Zuul 过滤器128
8.8.3 禁用Zuul 过滤器130
8.9 Zuul 的容错与回退130
8.9.1 为Zuul 添加回退131
8.10 Zuul 的高可用133
8.10.1 Zuul 客户端也注册到了Eureka Server 上133
8.10.2 Zuul 客户端未注册到Eureka Server 上133
8.11 使用Sidecar 整合非JVM 微服务134
8.11.1 编写Node.js 微服务135
8.11.2 编写Sidecar 136
8.11.3 Sidecar 的端点138
8.11.4 Sidecar 与Node.js 微服务分离部署139
8.11.5 Sidecar 原理分析139
9 使用Spring Cloud Config 统一管理微服务配置. . . . . . . . . . . . . . . . . . . . . . . 142
9.1 为什么要统一管理微服务配置142
9.2 Spring Cloud Config 简介143
9.3 编写Config Server 144
9.3.1 Config Server 的端点145
9.4 编写Config Client 147
9.5 Config Server 的Git 仓库配置详解149
9.6 Config Server 的健康状况指示器152
9.7 配置内容的加解密153
9.7.1 安装JCE 153
9.7.2 Config Server 的加解密端点153
9.7.3 对称加密153
9.7.4 存储加密的内容154
9.7.5 非对称加密155
9.8 使用/refresh 端点手动刷新配置155
9.9 使用Spring Cloud Bus 自动刷新配置157
9.9.1 Spring Cloud Bus 简介157
9.9.2 实现自动刷新158
9.9.3 局部刷新159
9.9.4 架构改进159
9.9.5 跟踪总线事件160
9.10 Spring Cloud Config 与Eureka 配合使用161
9.11 Spring Cloud Config 的用户认证162
9.11.1 Config Client 连接需用户认证的Config Server 163
9.12 Config Server 的高可用164
9.12.1 Git 仓库的高可用164
9.12.2 RabbitMQ 的高可用164
9.12.3 Config Server 自身的高可用165
10 使用Spring Cloud Sleuth 实现微服务跟踪. . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
10.1 为什么要实现微服务跟踪167
10.2 Spring Cloud Sleuth 简介168
10.3 整合Spring Cloud Sleuth 170
10.4 Spring Cloud Sleuth 与ELK 配合使用172
10.5 Spring Cloud Sleuth 与Zipkin 配合使用176
10.5.1 Zipkin 简介176
10.5.2 编写Zipkin Server 176
10.5.3 微服务整合Zipkin 178
10.5.4 使用消息中间件收集数据181
10.5.5 存储跟踪数据183
11 Spring Cloud 常见问题与总结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186
11.1 Eureka 常见问题186
11.1.1 Eureka 注册服务慢186
11.1.2 已停止的微服务节点注销慢或不注销187
11.1.3 如何自定义微服务的Instance ID 188
11.1.4 Eureka 的UNKNOWN 问题总结与解决189
11.2 Hystrix/Feign 整合Hystrix 后首次请求失败190
11.2.1 原因分析191
11.2.2 解决方案191
11.3 Turbine 聚合的数据不完整191
11.3.1 解决方案192
11.4 Spring Cloud 各组件配置属性193
11.4.1 Spring Cloud 的配置193
11.4.2 原生配置193
11.5 Spring Cloud 定位问题思路总结194
12 Docker 入门. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197
12.1 Docker 简介197
12.2 Docker 的架构197
12.3 安装Docker 199
12.3.1 系统要求199
12.3.2 移除非官方软件包199
12.3.3 设置Yum 源199
12.3.4 安装Dokcer 200
12.3.5 卸载Docker 201
12.4 配置镜像加速器201
12.5 Docker 常用命令202
12.5.1 Docker 镜像常用命令202
12.5.2 Docker 容器常用命令204
13 将微服务运行在Docker 上. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209
13.1 使用Dockerfile 构建Docker 镜像209
13.1.1 Dockerfile 常用指令210
13.1.2 使用Dockerfile 构建镜像215
13.2 使用Docker Registry 管理Docker 镜像217
13.2.1 使用Docker Hub 管理镜像217
13.2.2 使用私有仓库管理镜像219
13.3 使用Maven 插件构建Docker 镜像220
13.3.1 快速入门221
13.3.2 插件读取Dockerfile 进行构建222
13.3.3 将插件绑定在某个phase 执行223
13.3.4 推送镜像224
13.4 常见问题与总结226
14 使用Docker Compose 编排微服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227
14.1 Docker Compose 简介227
14.2 安装Docker Compose 227
14.2.1 安装Compose 228
14.2.2 安装Compose 命令补全工具228
14.3 Docker Compose 快速入门229
14.3.1 基本步骤229
14.3.2 入门示例229
14.3.3 工程、服务、容器230
14.4 docker-compose.yml 常用命令230
14.4.1 build 230
14.4.2 command 231
14.4.3 dns 231
14.4.4 dns_search 231
14.4.5 environment 231
14.4.6 env_file 232
14.4.7 expose 232
14.4.8 external_links 232
14.4.9 image 232
14.4.10 links 232
14.4.11 networks 233
14.4.12 network_mode 233
14.4.13 ports 233
14.4.14 volumes 233
14.4.15 volumes_from 234
14.5 docker-compose 常用命令234
14.5.1 build 234
14.5.2 help 235
14.5.3 kill 235
14.5.4 logs 235
14.5.5 port 235
14.5.6 ps 235
14.5.7 pull 235
14.5.8 rm 236
14.5.9 run 236
14.5.10 scale 236
14.5.11 start 236
14.5.12 stop 236
14.5.13 up 236
14.6 Docker Compose 网络设置237
14.6.1 基本概念237
14.6.2 更新容器237
14.6.3 links 238
14.6.4 指定自定义网络238
14.6.5 配置默认网络239
14.6.6 使用已存在的网络239
14.7 综合实战：使用Docker Comose 编排Spring Cloud 微服务240
14.7.1 编排Spring Cloud 微服务240
14.7.2 编排高可用的Eureka Server 243
14.7.3 编排高可用Spring Cloud 微服务集群及动态伸缩245
14.8 常见问题与总结247
后记. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 248
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud与Docker微服务架构实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式服务架构：原理、设计与实战
第1章  分布式微服务架构设计原理	1
1.1  从传统单体架构到服务化架构	2
1.1.1  JEE架构	2
1.1.2  SSH架构	5
1.1.3  服务化架构	8
1.2  从服务化到微服务	11
1.2.1  微服务架构的产生	12
1.2.2  微服务架构与传统单体架构的对比	13
1.2.3  微服务架构与SOA服务化的对比	15
1.3  微服务架构的核心要点和实现原理	16
1.3.1  微服务架构中职能团队的划分	16
1.3.2  微服务的去中心化治理	18
1.3.3  微服务的交互模式	18
1.3.4  微服务的分解和组合模式	22
1.3.5  微服务的容错模式	35
1.3.6  微服务的粒度	41
1.4  Java平台微服务架构的项目组织形式	42
1.4.1  微服务项目的依赖关系	42
1.4.2  微服务项目的层级结构	43
1.4.3  微服务项目的持续发布	45
1.5  服务化管理和治理框架的技术选型	45
1.5.1  RPC	46
1.5.2  服务化	47
1.5.3  微服务	49
1.6  本章小结	52
第2章  彻底解决分布式系统一致性的问题	54
2.1  什么是一致性	55
2.2  一致性问题	56
2.3  解决一致性问题的模式和思路	57
2.3.1  酸碱平衡理论	58
2.3.2  分布式一致性协议	61
2.3.3  保证最终一致性的模式	67
2.4  超时处理模式	75
2.4.1  微服务的交互模式	76
2.4.2  同步与异步的抉择	77
2.4.3  交互模式下超时问题的解决方案	78
2.4.4  超时补偿的原则	85
2.5  迁移开关的设计	87
2.6  本章小结	88
第3章  服务化系统容量评估和性能保障	89
3.1  架构设计与非功能质量	90
3.2  全面的非功能质量需求	91
3.2.1  非功能质量需求的概述	91
3.2.2  非功能质量需求的具体指标	92
3.3  典型的技术评审提纲	97
3.3.1  现状	97
3.3.2  需求	98
3.3.3  方案描述	98
3.3.4  方案对比	99
3.3.5  风险评估	100
3.3.6  工作量评估	100
3.4  性能和容量评估经典案例	100
3.4.1  背景	100
3.4.2  目标数据量级	101
3.4.3  量级评估标准	101
3.4.4  方案	102
3.4.5  小结	107
3.5  性能评估参考标准	108
3.5.1  常用的应用层性能指标参考标准	108
3.5.2  常用的系统层性能指标参考标准	109
3.6  性能测试方案的设计和最佳实践	112
3.6.1  明确压测目标	112
3.6.2  压测场景设计和压测方案制定	114
3.6.3  准备压测环境	121
3.6.4  压测的执行	122
3.6.5  问题修复和系统优化	123
3.7  有用的压测工具	123
3.7.1  ab	123
3.7.2  jmeter	125
3.7.3  mysqlslap	125
3.7.4  sysbench	129
3.7.5  dd	134
3.7.6  LoadRunner	135
3.7.7  hprof	136
3.8  本章小结	138
第4章  大数据日志系统的构建	140
4.1  开源日志框架的原理分析与应用实践	142
4.1.1  JDK Logger	142
4.1.2  Apache Commons Logging	143
4.1.3  Apache Log4j	147
4.1.4  Slf4j	156
4.1.5  Logback	160
4.1.6  Apache Log4j 2	164
4.2  日志系统的优化和最佳实践	168
4.2.1  开发人员的日志意识	168
4.2.2  日志级别的设置	168
4.2.3  日志的数量和大小	169
4.2.4  切割方式	170
4.2.5  日志格式的配置	170
4.2.6  一行日志导致的线上事故	177
4.3  大数据日志系统的原理与设计	178
4.3.1  通用架构和设计	179
4.3.2  日志采集器	180
4.3.3  日志缓冲队列	186
4.3.4  日志解析器	187
4.3.5  日志存储和搜索	187
4.3.6  日志展示系统	188
4.3.7  监控和报警	188
4.3.8  日志系统的容量和性能评估	188
4.4  ELK系统的构建与使用	190
4.4.1  Elasticsearch	191
4.4.2  Logstash	193
4.4.3  Kibana	196
4.5  本章小结	198
第5章  基于调用链的服务治理系统的设计与实现	199
5.1  APM系统简介	200
5.1.1  优秀的开源APM系统	200
5.1.2  国内商业APM产品的介绍	202
5.2  调用链跟踪的原理	203
5.2.1  分布式系统的远程调用过程	204
5.2.2  TraceID	207
5.2.3  SpanID	208
5.2.4  业务链	210
5.3  调用链跟踪系统的设计与实现	211
5.3.1  整体架构	211
5.3.2  TraceID和SpanID在服务间的传递	213
5.3.3  采集器的设计与实现	217
5.3.4  处理器的设计与实现	222
5.3.5  调用链系统的展示	225
5.4  本章小结	226
第6章  Java服务的线上应急和技术攻关	227
6.1  海恩法则和墨菲定律	227
6.2  线上应急的目标、原则和方法	229
6.2.1  应急目标	229
6.2.2  应急原则	229
6.2.3  线上应急的方法和流程	230
6.3  技术攻关的方法论	233
6.4  环境搭建和示例服务启动	236
6.5  高效的服务化治理脚本	240
6.5.1  show-busiest-java-threads	240
6.5.2  find-in-jar	243
6.5.3  grep-in-jar	244
6.5.4  jar-conflict-detect	245
6.5.5  http-spy	247
6.5.6  show-mysql-qps	248
6.5.7  小结	249
6.6  JVM提供的监控命令	249
6.6.1  jad	249
6.6.2  btrace	250
6.6.3  jmap	252
6.6.4  jstat	255
6.6.5  jstack	256
6.6.6  jinfo	258
6.6.7  其他命令	258
6.6.8  小结	259
6.7  重要的Linux基础命令	260
6.7.1  必不可少的基础命令和工具	260
6.7.2  查看活动进程的命令	268
6.7.3  窥探内存的命令	270
6.7.4  针对CPU使用情况的监控命令	272
6.7.5  监控磁盘I/O的命令	273
6.7.6  查看网络信息和网络监控命令	275
6.7.7  Linux系统的高级工具	287
6.7.8  /proc文件系统	288
6.7.9  摘要命令	288
6.7.10  小结	290
6.8  现实中的应急和攻关案例	291
6.8.1  一次OOM事故的分析和定位	291
6.8.2  一次CPU 100%的线上事故排查	301
6.9  本章小结	304
第7章  服务的容器化过程	306
7.1  容器vs虚拟机	306
7.1.1  什么是虚拟机	306
7.1.2  什么是容器	306
7.1.3  容器和虚拟机的区别	307
7.1.4  容器主要解决的问题	307
7.1.5  Docker的优势	310
7.2  Docker实战	311
7.2.1  Docker的架构	311
7.2.2  Docker的安装	315
7.2.3  Docker初体验	319
7.2.4  Docker后台服务的管理	322
7.2.5  Docker的客户端命令	328
7.2.6  Docker Compose编排工具的使用	372
7.3  容器化项目	379
7.3.1  传统的应用部署	380
7.3.2  将应用程序部署在虚拟机上	380
7.3.3  容器化部署应用	381
7.3.4  Docker实现的应用容器化示例	382
7.4  本章小结	384
第8章  敏捷开发2.0的自动化工具	385
8.1  什么是敏捷开发2.0	385
8.1.1  常用的4种开发模式	385
8.1.2  什么是DevOps	390
8.1.3  敏捷开发2.0解决的问题	392
8.2  敏捷开发的自动化流程	393
8.2.1  持续集成	393
8.2.2  持续交付和持续部署	397
8.3  敏捷开发的常用自动化工具	400
8.3.1  分布式版本控制工具Git	400
8.3.2  持续集成和持续交付工具Jenkins	410
8.3.3  基础平台管理工具SaltStack	418
8.3.4  Docker容器化工具	421
8.4  本章小结	422
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式服务架构：原理、设计与实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux 内核设计的艺术（第2版）
前　　言
第1章从开机加电到执行
main函数之前的过程
1.1　启动BIOS，准备实模式下的中断向量表和中断服务程序
1.1.1　BIOS的启动原理
1.1.2　BIOS 在内存中加载中断向量表和中断服务程序
1.2　加载操作系统内核程序并为保护模式做准备
1.2.1　加载第一部分内核代码--引导程序（bootsect）
1.2.2　加载第二部分内核代码--setup
1.2.3　加载第三部分内核代码--system模块
1.3　开始向32位模式转变，为main函数的调用做准备
1.3.1　关中断并将system移动到内存地址起始位置0x0000
1.3.2　设置中断描述符表和全局描述符表
1.3.3　打开A20，实现32位寻址
1.3.4　为保护模式下执行head.s做准备
1.3.5　head.s开始执行
1.4　本章小结
第2章设备环境初始化及激活进程
2.1　设置根设备、硬盘
2.2　规划物理内存格局，设置缓冲区、虚拟盘、主内存
2.3　设置虚拟盘空间并初始化
2.4　内存管理结构mem_map初始化
2.5　异常处理类中断服务程序挂接
2.6　初始化块设备请求项结构
2.7　与建立人机交互界面相关的外设的中断服务程序挂接
2.7.1　对串行口进行设置
2.7.2　对显示器进行设置
2.7.3　对键盘进行设置
2.8　开机启动时间设置
2.9　初始化进程
2.9.1　初始化进程
2.9.2　设置时钟中断
2.9.3　设置系统调用总入口
2.10　初始化缓冲区管理结构
2.11　初始化硬盘
2.12　初始化软盘
2.13　开启中断
2.14　进程0由0特权级翻转到3特权级，成为真正的进程
2.15　本章小结
第3章进程1的创建及执行
3.1　进程1的创建
3.1.1　进程0创建进程
3.1.2　在task[64]中为进程1申请一个空闲位置并获取进程号
3.1.3　调用copy_process函数
3.1.4　设置进程1的分页管理
3.1.5　进程1共享进程0的文件
3.1.6　设置进程1在GDT中的表项
3.1.7　进程1处于就绪态
3.2　内核第一次做进程调度
3.3　轮转到进程1执行
3.3.1　进程1为安装硬盘文件系统做准备
3.3.2　进程1格式化虚拟盘并更换根设备为虚拟盘
3.3.3　进程1在根设备上加载根文件系统
3.4　本章小结
第4章进程2的创建及执行
4.1　打开终端设备文件及复制文件句柄
4.1.1　打开标准输入设备文件
4.1.2　打开标准输出、标准错误输出设备文件
4.2　进程1创建进程2并切换到进程2执行
4.3　加载shell程序
4.3.1　关闭标准输入设备文件，打开rc文件
4.3.2　检测shell文件
4.3.3　为shell程序的执行做准备
4.3.4　执行shell程序
4.4　系统实现怠速
4.4.1　创建update进程
4.4.2　切换到shell进程执行
4.4.3　重建shell
4.5　本章小结
第5章文件操作
5.1　安装文件系统
5.1.1　获取外设的超级块
5.1.2　确定根文件系统的挂接点
5.1.3　将超级块与根文件系统挂接
5.2　打开文件
5.2.1　将进程的*filp[20]与file_table[64]挂接
5.2.2　获取文件i节点
5.2.3　将文件i节点与file_table[64]挂接
5.3　读文件
5.3.1　确定数据块在外设中的位置
5.3.2　将数据块读入缓冲块
5.3.3　将缓冲块中的数据复制到进程空间
5.4　新建文件
5.4.1　查找文件
5.4.2　新建文件i节点
5.4.3　新建文件目录项
5.5　写文件
5.5.1　确定文件的写入位置
5.5.2　申请缓冲块
5.5.3　将指定的数据从进程空间复制到缓冲块
5.5.4　数据同步到外设的两种方法
5.6　修改文件
5.6.1　重定位文件的当前操作指针
5.6.2　修改文件
5.7　关闭文件
5.7.1　当前进程的filp与file_table[64]脱钩
5.7.2　文件i节点被释放
5.8　删除文件
5.8.1　对文件的删除条件进行检查
5.8.2　进行具体的删除工作
5.9　本章小结
第6章用户进程与内存管理
6.1　线性地址的保护
6.1.1　进程线性地址空间的格局
6.1.2　段基址、段限长、GDT、LDT、特权级
6.2　分页
6.2.1　线性地址映射到物理地址
6.2.2　进程执行时分页
6.2.3　进程共享页面
6.2.4　内核分页
6.3　一个用户进程从创建到退出的完整过程
6.3.1　创建str1进程
6.3.2　str1进程加载的准备工作
6.3.3　str1进程的运行、加载
6.3.4　str1进程的退出
6.4　多个用户进程同时运行
6.4.1　进程调度
6.4.2　页写保护
6.5　本章小结
第7章缓冲区和多进程操作文件
7.1　缓冲区的作用
7.2　缓冲区的总体结构
7.3　b_dev、b_blocknr及request的作用
7.3.1　保证进程与缓冲块数据交互的正确性
7.3.2　让数据在缓冲区中停留的时间尽可能长
7.4　uptodate和dirt的作用
7.4.1　b_uptodate的作用
7.4.2　b_dirt的作用
7.4.3　i_uptodate、i_dirt和s_dirt的作用
7.5　count、 lock、wait、request的作用
7.5.1　b_count的作用
7.5.2　i_count的作用
7.5.3　b_lock、*b_wait的作用
7.5.4　i_lock、i_wait、s_lock、*s_wait的作用
7.5.5　补充request的作用
7.6　实例1：关于缓冲块的进程等待队列
7.7　总体来看缓冲块和请求项
7.8　实例2：多进程操作文件的综合实例
7.9　本章小结
第8章进程间通信
8.1　管道机制
8.1.1　管道的创建过程
8.1.2　管道的操作
8.2　信号机制
8.2.1　信号的使用
8.2.2　信号对进程执行状态的影响
8.3　本章小结
第9章操作系统的设计指导思想
9.1　运行一个最简单的程序，看操作系统为程序运行做了哪些工作
9.2　操作系统的设计指导思想--主奴机制
9.2.1　主奴机制中的进程及进程创建机制
9.2.2　操作系统的设计如何体现主奴机制
9.3　实现主奴机制的三种关键技术
9.3.1　保护和分页
9.3.2　特权级
9.3.3　中断
9.4　建立主奴机制的决定性因素--先机
9.5　软件和硬件的关系
9.5.1　非用户进程--进程0、进程1、shell进程
9.5.2　文件与数据存储
9.6　父子进程共享页面
9.7　操作系统的全局中断与进程的局部中断--信号
9.8　本章小结
结束语
“新设计团队”简介
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux 内核设计的艺术（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spark技术内幕
序
前言
第1章　Spark简介1
1.1Spark的技术背景1
1.2Spark的优点2
1.3Spark架构综述4
1.4Spark核心组件概述5
1.4.1Spark Streaming5
1.4.2MLlib6
1.4.3Spark SQL7
1.4.4　GraphX8
1.5Spark的整体代码结构规模8
第2章　Spark学习环境的搭建9
2.1源码的获取与编译9
2.1.1源码获取9
2.1.2源码编译10
2.2构建Spark的源码阅读环境11
2.3小结15
第3章　RDD实现详解16
3.1概述16
3.2什么是RDD17
3.2.1RDD的创建19
3.2.2RDD的转换20
3.2.3　RDD的动作22
3.2.4RDD的缓存23
3.2.5RDD的检查点24
3.3RDD的转换和DAG的生成25
3.3.1RDD的依赖关系26
3.3.2DAG的生成30
3.3.3Word Count的RDD转换和DAG划分的逻辑视图30
3.4RDD的计算33
3.4.1Task简介33
3.4.2Task的执行起点33
3.4.3缓存的处理35
3.4.4checkpoint的处理37
3.4.5RDD的计算逻辑39
3.5RDD的容错机制39
3.6小结40
第4章　Scheduler 模块详解41
4.1模块概述41
4.1.1整体架构41
4.1.2Scheduler的实现概述43
4.2DAGScheduler实现详解45
4.2.1DAGScheduler的创建46
4.2.2Job的提交48
4.2.3Stage的划分49
4.2.4任务的生成54
4.3任务调度实现详解57
4.3.1TaskScheduler的创建57
4.3.2Task的提交概述58
4.3.3任务调度具体实现61
4.3.4Task运算结果的处理65
4.4Word Count调度计算过程详解72
4.5小结74
第5章　Deploy模块详解76
5.1　Spark运行模式概述76
5.1.1　local77
5.1.2Mesos78
5.1.3YARN82
5.2模块整体架构86
5.3消息传递机制详解87
5.3.1Master和Worker87
5.3.2Master和Client89
5.3.3Client和Executor91
5.4集群的启动92
5.4.1Master的启动92
5.4.2Worker的启动96
5.5集群容错处理98
5.5.1Master 异常退出98
5.5.2Worker异常退出99
5.5.3Executor异常退出101
5.6Master HA实现详解102
5.6.1Master启动的选举和数据恢复策略103
5.6.2集群启动参数的配置105
5.6.3Curator Framework简介 106
5.6.4ZooKeeperLeaderElectionAgent的实现109
5.7小结110
第6章　Executor模块详解112
6.1Standalone模式的Executor分配详解113
6.1.1SchedulerBackend创建AppClient114
6.1.2AppClient向Master注册Application116
6.1.3Master根据AppClient的提交选择Worker119
6.1.4Worker根据Master的资源分配结果创建Executor121
6.2Task的执行122
6.2.1依赖环境的创建和分发123
6.2.2任务执行125
6.2.3任务结果的处理128
6.2.4Driver端的处理130
6.3　参数设置131
6.3.1　spark.executor.memory131
6.3.2日志相关132
6.3.3spark.executor.heartbeatInterval132
6.4小结133
第7章　Shuffle模块详解134
7.1Hash Based Shuffle Write135
7.1.1Basic Shuffle Writer实现解析136
7.1.2存在的问题138
7.1.3Shuffle Consolidate Writer139
7.1.4小结140
7.2Shuffle Pluggable 框架141
7.2.1org.apache.spark.shuffle.ShuffleManager141
7.2.2org.apache.spark.shuffle.ShuffleWriter143
7.2.3org.apache.spark.shuffle.ShuffleBlockManager143
7.2.4org.apache.spark.shuffle.ShuffleReader144
7.2.5如何开发自己的Shuffle机制144
7.3Sort Based Write144
7.4Shuffle Map Task运算结果的处理148
7.4.1Executor端的处理148
7.4.2Driver端的处理150
7.5Shuffle Read152
7.5.1整体流程152
7.5.2数据读取策略的划分155
7.5.3本地读取156
7.5.4远程读取158
7.6性能调优160
7.6.1spark.shuffle.manager160
7.6.2spark.shuffle.spill162
7.6.3spark.shuffle.memoryFraction和spark.shuffle.safetyFraction162
7.6.4spark.shuffle.sort.bypassMergeThreshold 163
7.6.5spark.shuffle.blockTransferService 163
7.6.6spark.shuffle.consolidateFiles 163
7.6.7spark.shuffle.compress和 spark.shuffle.spill.compress164
7.6.8spark.reducer.maxMbInFlight165
7.7小结165
第8章　Storage模块详解167
8.1模块整体架构167
8.1.1整体架构167
8.1.2源码组织结构170
8.1.3Master 和Slave的消息传递详解173
8.2存储实现详解181
8.2.1存储级别181
8.2.2模块类图184
8.2.3org.apache.spark.storage.DiskStore实现详解186
8.2.4org.apache.spark.storage.MemoryStore实现详解188
8.2.5org.apache.spark.storage.TachyonStore实现详解189
8.2.6Block存储的实现190
8.3性能调优194
8.3.1spark.local.dir194
8.3.2spark.executor.memory194
8.3.3spark.storage.memoryFraction194
8.3.4spark.streaming.blockInterval195
8.4小结195
第9章　企业应用概述197
9.1Spark在百度197
9.1.1现状197
9.1.2百度开放云BMR的Spark198
9.1.3在Spark中使用Tachyon199
9.2Spark在阿里200
9.3Spark在腾讯200
9.4小结201
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spark技术内幕
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大型分布式网站架构设计与实践
第1章　面向服务的体系架构（SOA）	1
本章主要介绍和解决以下问题，这些也是全书的基础：
HTTP协议的工作方式与HTTP网络协议栈的结构。
如何实现基于HTTP协议和TCP协议的RPC调用，它们之间有何差别，分别适应何种场景。
如何实现服务的动态注册和路由，以及软负载均衡的实现。
1.1　基于TCP协议的RPC	3
1.1.1　RPC名词解释	3
1.1.2　对象的序列化	4
1.1.3　基于TCP协议实现RPC	6
1.2　基于HTTP协议的RPC	9
1.2.1　HTTP协议栈	9
1.2.2　HTTP请求与响应	15
1.2.3　通过HttpClient发送HTTP请求	16
1.2.4　使用HTTP协议的优势	17
1.2.5　JSON和XML	18
1.2.6　RESTful和RPC	20
1.2.7　基于HTTP协议的RPC的实现	22
1.3　服务的路由和负载均衡	30
1.3.1　服务化的演变	30
1.3.2  负载均衡算法	33
1.3.3  动态配置规则	39
1.3.4  ZooKeeper介绍与环境搭建	40
1.3.5  ZooKeeper API使用简介	43
1.3.6  zkClient的使用	47
1.3.7  路由和负载均衡的实现	50
1.4  HTTP服务网关	54
第2章　分布式系统基础设施	58
本章主要介绍和解决如下问题：
分布式缓存memcache的使用及分布式策略，包括Hash算法的选择。
常见的分布式系统存储解决方案，包括MySQL的分布式扩展、HBase的API及使用场景、Redis的使用等。
如何使用分布式消息系统ActiveMQ来降低系统之间的耦合度，以及进行应用间的通信。
垂直化的搜索引擎在分布式系统中的使用，包括搜索引擎的基本原理、Lucene详细的使用介绍，以及基于Lucene的开源搜索引擎工具Solr的使用。
2.1  分布式缓存	60
2.1.1  memcache简介及安装	60
2.1.2  memcache API与分布式	64
2.1.3  分布式session	69
2.2  持久化存储	71
2.2.1  MySQL扩展	72
2.2.2  HBase	80
2.2.3  Redis	91
2.3  消息系统	95
2.3.1  ActiveMQ & JMS	96
2.4  垂直化搜索引擎	104
2.4.1  Lucene简介	105
2.4.2  Lucene的使用	108
2.4.3  Solr	119
2.5  其他基础设施	125
第3章　互联网安全架构	126
本章主要介绍和解决如下问题：
常见的Web攻击手段和防御方法，如XSS、CRSF、SQL注入等。
常见的一些安全算法，如数字摘要、对称加密、非对称加密、数字签名、数字证书等。
如何采用摘要认证方式防止信息篡改、通过数字签名验证通信双方的合法性，以及通过HTTPS协议保障通信过程中数据不被第三方监听和截获。
在开放平台体系下，OAuth协议如何保障ISV对数据的访问是经过授权的合法行为。
3.1  常见的Web攻击手段	128
3.1.1  XSS攻击	128
3.1.2  CRSF攻击	130
3.1.3  SQL注入攻击	133
3.1.4  文件上传漏洞	139
3.1.5  DDoS攻击	146
3.1.6  其他攻击手段	149
3.2  常用的安全算法	149
3.2.1  数字摘要	149
3.2.2  对称加密算法	155
3.2.3  非对称加密算法	158
3.2.4  数字签名	162
3.2.5  数字证书	166
3.3  摘要认证	185
3.3.1  为什么需要认证	185
3.3.2  摘要认证的原理	187
3.3.3  摘要认证的实现	188
3.4  签名认证	192
3.4.1  签名认证的原理	192
3.4.2  签名认证的实现	193
3.5  HTTPS协议	200
3.5.1  HTTPS协议原理	200
3.5.2  SSL/TLS	201
3.5.3  部署HTTPS Web	208
3.6  OAuth协议	215
3.6.1  OAuth的介绍	215
3.6.2  OAuth授权过程	216
第4章　系统稳定性	218
本章主要介绍和解决如下问题：
常用的在线日志分析命令的使用和日志分析脚本的编写，如cat、grep、wc、less等命令的使用，以及awk、shell脚本的编写。
如何进行集群的监控，包括监控指标的定义、心跳检测、容量评估等。
如何保障高并发系统的稳定运行，如采用流量控制、依赖管理、服务分级、开关等策略，以及介绍如何设计高并发系统。
如何优化应用的性能，包括前端优化、Java程序优化、数据库查询优化等。
如何进行Java应用故障的在线排查，包括一系列排查工具的使用，以及一些实际案例的介绍等。
4.1  在线日志分析	220
4.1.1  日志分析常用命令	220
4.1.2  日志分析脚本	230
4.2  集群监控	239
4.2.1  监控指标	239
4.2.2  心跳检测	247
4.2.3  容量评估及应用水位	252
4.3  流量控制	255
4.3.1  流量控制实施	255
4.3.2  服务稳定性	260
4.3.3  高并发系统设计	265
4.4  性能优化	277
4.4.1  如何寻找性能瓶颈	277
4.4.2  性能测试工具	285
4.4.3  性能优化措施	292
4.5  Java应用故障的排查	314
4.5.1  常用的工具	314
4.5.2  典型案例分析	331
第5章　数据分析	337
本章主要介绍和解决如下问题：
分布式系统中日志收集系统的架构。
如何通过Storm进行实时的流式数据分析。
如何通过Hadoop进行离线数据分析，通过Hive建立数据仓库。
如何将关系型数据库中存储的数据导入HDFS，以及从HDFS中将数据导入关系型数据库。
如何将分析好的数据通过图形展示给用户。
5.1  日志收集	339
5.1.1  inotify机制	339
5.1.2  ActiveMQ-CPP	343
5.1.3  架构和存储	359
5.1.4  Chukwa	362
5.2  离线数据分析	369
5.2.1  Hadoop项目简介	370
5.2.2  Hadoop环境搭建	374
5.2.3  MapReduce编写	384
5.2.4  Hive使用	389
5.3  流式数据分析	403
5.3.1  Storm的介绍	404
5.3.2  安装部署Storm	407
5.3.3  Storm的使用	418
5.4  数据同步	422
5.4.1  离线数据同步	423
5.4.2  实时数据同步	429
5.5  数据报表	431
5.5.1  数据报表能提供什么	431
5.5.2  报表工具Highcharts	432
参考文献	445
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大型分布式网站架构设计与实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务架构与实践
第1部分 基础篇
第1章 单块架构及其面临的挑战  3
1.1 三层应用架构  4
1.1.1 三层应用架构的发展  4
1.1.2 什么是三层架构  5
1.1.3 三层架构的优势  6
1.2 单块架构  6
1.2.1 什么是单块架构  6
1.2.2 单块架构的优势  7
1.2.3 单块架构面临的挑战  8
1.3 小结  12
第2章 微服务架构综述  13
2.1 什么是微服务架构  13
2.1.1 多微才够微  14
2.1.2 单一职责  17
2.1.3 轻量级通信  17
2.1.4 独立性  19
2.1.5 进程隔离  20
2.2 微服务的诞生背景  22
2.2.1 互联网行业的快速发展  23
2.2.2 敏捷、精益方法论的深入人心 23
2.2.3 单块架构系统面临的挑战  23
2.2.4 容器虚拟化技术  23
2.3 微服务架构与 SOA  24
2.3.1 SOA概述  24
2.3.2 微服务与 SOA  25
2.4 微服务的本质  26
2.4.1 服务作为组件  27
2.4.2 围绕业务组织团队  28
2.4.3 关注产品而非项目  29
2.4.4 技术多样性  31
2.4.5 业务数据独立  32
2.4.6 基础设施自动化  33
2.4.7 演进式架构  33
2.5 微服务不是银弹  34
2.5.1 分布式系统的复杂度  35
2.5.2 运维成本  36
2.5.3 部署自动化  36
2.5.4 DevOps与组织架构  37
2.5.5 服务间的依赖测试  37
2.5.6 服务间的依赖管理  37
2.6 小结  38
第2部分 实践篇
第3章 构建第一个服务  41
3.1 场景分析  41
3.2 任务拆分  43
第4章 Hello World API  45
4.1 API实现  45
4.1.1 开发语言 ——Ruby  45
4.1.2 Web框架——Grape  46
4.1.3 API的具体实现  47
4.2 代码测试与静态检查  50
4.2.1 代码测试  50
4.2.2 测试覆盖率统计  53
4.2.3 静态检查  54
4.2.4 代码复杂度检查  57
第5章 构建 Docker映像  61
5.1 定义 Dockerfile  61
5.2 配置 Docker主机  63
5.3 构建 Docker映像  64
5.4 运行 Docker容器  64
5.5 发布 Docker映像  65
5.6 小结  69
第6章 部署 Docker映像  71
6.1基础设施 AWS  71
6.2基础设施自动化  73
6.3 部署 Docker映像  80
6.4自动化部署  81
6.5 小结  84
第7章 持续交付流水线  85
7.1 持续集成环境  85
7.2 提交阶段  87
7.3 验证阶段  91
7.4 构建阶段  91
7.5 发布阶段  94
7.6 小结  96
第8章 日志聚合  97
8.1 日志聚合工具简介  97
8.2 Splunk的核心  99
8.3 安装 Splunk索引器  100
8.4 安装 Splunk转发器  101
8.5 日志查找  102
8.6 告警设置  103
8.7 小结  104
第9章 监控与告警  105
9.1 Nagios简介  105
9.2 Nagios的工作原理  107
9.3 Nagios安装  108
9.4 Nagios的配置  109
9.5 监控 products-service  111
9.6 告警  113
9.7 小结  114
第10章 功能迭代  115
10.1 定义模型  116
10.2 持久化模型  117
10.3 定义表现形式  119
10.4 实现 API  122
10.5 服务描述文件  125
10.6 小结  127
第3部分 进阶篇
第11章 微服务与持续交付  131
11.1 持续交付的核心  132
11.2 微服务架构与持续交付  133
11.2.1 开发  133
11.2.2 测试  137
11.2.3 持续集成  139
11.2.4 构建  139
11.2.5 部署  140
11.2.6 运维  143
11.3 小结  144
第12章 微服务与轻量级通信机制  145
12.1 同步通信与异步通信  145
12.1.1 概述  145
12.1.2 同步通信与异步通信的选择 146
12.2 远程调用 RPC  147
12.2.1 远程过程调用的核心  147
12.2.2 远程方法调用  148
12.2.3 远程过程调用的弊端  148
12.3 REST  149
12.3.1 概述  149
12.3.2 REST的核心  150
12.3.3 REST的优势  152
12.3.4 REST的不足  152
12.3.5 本节小结  155
12.4 HAL  155
12.4.1 概述  155
12.4.2 HAL的核心  156
12.4.3 HAL浏览器  160
12.5 消息队列  161
12.5.1 核心部分  162
12.5.2 访问方式  163
12.5.3 消息队列的优缺点  164
12.6 后台任务处理系统  165
12.6.1 核心部分  165
12.6.2 服务回调  166
12.6.3 一个例子  167
12.6.4 后台任务与微服务  169
12.7 小结  170
第13章 微服务与测试  171
13.1 微服务的结构  171
13.2 微服务的测试策略  173
13.3 微服务的单元测试  175
13.3.1 单元测试综述  175
13.3.2 单元测试的内容  176
13.4 微服务的集成测试  179
13.4.1 集成测试综述  179
13.4.2 集成测试的实施方法  179
13.4.3 集成测试的内容  180
13.5 基于消费者驱动的契约测试  181
13.5.1 集成测试存在的弊端  181
13.5.2 什么是契约  183
13.5.3 什么是契约测试  184
13.5.4 契约测试的方法  185
13.5.5 Pact实现契约测试  187
13.5.6 一个例子  192
13.5.7 本节小结  205
13.6 微服务的组件测试  205
13.6.1 组件测试概述  205
13.6.2 组件测试的方法  206
13.6.3 本节小结  207
13.7 微服务的端到端测试  208
13.7.1 端到端测试概述  208
13.7.2 端到端测试的内容  208
13.7.3 本节小结  209
13.8 小结  210
第14章 使用微服务架构改造遗留系统  211
14.1 背景与挑战  211
14.2 改造策略  212
14.2.1 昀小修改  212
14.2.2 功能剥离  212
14.2.3 数据解耦  213
14.2.4 数据同步  213
14.2.5 迭代替换  214
14.3 快速开发实践  215
14.3.1 快速开发模板  215
14.3.2 代码生成工具  217
14.3.3 持续集成模板  217
14.3.4 一键部署工具  217
14.4 微服务架构下的新系统  218
14.5 小结  220
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务架构与实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大话存储（终极版）
第1章 混沌初开——存储系统的前世今生 1
1.1 存储历史 2
1.2 信息、数据和数据存储 6
1.2.1 信息 6
1.2.2 什么是数据 7
1.2.3 数据存储 8
1.3 用计算机来处理信息、保存数据 9
第2章 IO大法——走进计算机IO世界 11
2.1 IO的通路——总线 12
2.2 计算机内部通信 13
2.2.1 IO总线是否可以看作网络 14
2.2.2 CPU、内存和磁盘之间通过网络来通信 15
2.3 网中之网 16
第3章 磁盘大挪移——磁盘原理与技术详解 19
3.1 硬盘结构 20
3.1.1 盘片上的数据组织 21
3.1.2 硬盘控制电路简介 27
3.1.3 磁盘的IO单位 28
3.2 磁盘的通俗演绎 29
3.3 磁盘相关高层技术 31
3.3.1 磁盘中的队列技术 31
3.3.2 无序传输技术 32
3.3.3 几种可控磁头扫描方式概论 32
3.3.4 关于磁盘缓存 34
3.3.5 影响磁盘性能的因素 35
3.4 硬盘接口技术 36
3.4.1 IDE硬盘接口 36
3.4.2 SATA硬盘接口 39
3.5 SCSI硬盘接口 42
3.6 磁盘控制器、驱动器控制电路和磁盘控制器驱动程序 50
3.6.1 磁盘控制器 50
3.6.2 驱动器控制电路 50
3.6.3 磁盘控制器驱动程序 50
3.7 内部传输速率和外部传输速率 51
3.7.1 内部传输速率 51
3.7.2 外部传输速率 52
3.8 并行传输和串行传输 52
3.8.1 并行传输 52
3.8.2 串行传输 54
3.9 磁盘的IOPS和传输带宽（吞吐量） 54
3.9.1 IOPS 54
3.9.2 传输带宽 56
3.10 固态存储介质和固态硬盘 56
3.10.1 SSD固态硬盘的硬件组成 57
3.10.2 从Flash芯片读取数据的过程 60
3.10.3 向Flash芯片中写入数据的过程 61
3.10.4 Flash芯片的通病 63
3.10.5 NAND与NOR 64
3.10.6 SSD给自己开的五剂良药 65
3.10.7 SSD如何处理Cell损坏 68
3.10.8 SSD的前景 68
3.11 Memblaze闪存产品介绍 69
3.11.1 技术能力 70
3.11.2 产品能力 73
3.12 小结：网中有网，网中之网 75
第4章 七星北斗——大话/详解七种RAID 77
4.1 大话七种RAID武器 78
4.1.1 RAID 0阵式 78
4.1.2 RAID 1阵式 80
4.1.3 RAID 2阵式 82
4.1.4 RAID 3阵式 85
4.1.5 RAID 4阵式 88
4.1.6 RAID 5阵式 90
4.1.7 RAID 6阵式 94
4.2 七种RAID技术详解 96
4.2.1 RAID 0技术详析 99
4.2.2 RAID 1技术详析 100
4.2.3 RAID 2技术详析 102
4.2.4 RAID 3技术详析 104
4.2.5 RAID 4技术详析 106
4.2.6 RAID 5技术详析 109
4.2.7 RAID 6技术详析 113
第5章 降龙传说——RAID、虚拟磁盘、卷和文件系统实战 115
5.1 操作系统中RAID的实现和配置 116
5.1.1 Windows Server 2003高级磁盘管理 116
5.1.2 Linux下软RAID配置示例 121
5.2 RAID卡 123
5.3 磁盘阵列 134
5.3.1 RAID 50 134
5.3.2 RAID 10和RAID 01 135
5.4 虚拟磁盘 136
5.4.1 RAID组的再划分 136
5.4.2 同一通道存在多种类型的RAID组 137
5.4.3 操作系统如何看待逻辑磁盘 137
5.4.4 RAID控制器如何管理逻辑磁盘 137
5.5 卷管理层 138
5.5.1 有了逻辑盘就万事大吉了么？ 138
5.5.2 深入卷管理层 140
5.5.3 Linux下配置LVM实例 141
5.5.4 卷管理软件的实现 143
5.5.5 低级VM和高级VM 144
5.5.6 VxVM卷管理软件配置简介 146
5.6 大话文件系统 149
5.6.1 成何体统——没有规矩的仓库 149
5.6.2 慧眼识人——交给下一代去设计 150
5.6.3 无孔不入——不浪费一点空间 150
5.6.4 一箭双雕——一张图解决两个难题 151
5.6.5 宽容似海——设计也要像心胸一样宽 153
5.6.6 老将出马——权威发布 153
5.6.7 一统江湖——所有操作系统都在用 154
5.7 文件系统中的IO方式 154
第6章 阵列之行——大话磁盘阵列 157
6.1 初露端倪——外置磁盘柜应用探索 158
6.2 精益求精——结合RAID卡实现外置磁盘阵列 159
6.3 独立宣言——独立的外部磁盘阵列 161
6.4 双龙戏珠——双控制器的高安全性磁盘阵列 163
6.5 龙头凤尾——连接多个扩展柜 165
6.6 锦上添花——完整功能的模块化磁盘阵列 166
6.7 一脉相承——主机和磁盘阵列本是一家 167
6.8 天罗地网——SAN 169
第7章 熟读宝典——系统与系统之间的语言OSI 171
7.1 人类模型与计算机模型的对比剖析 172
7.1.1 人类模型 172
7.1.2 计算机模型 173
7.1.3 个体间交流是群体进化的动力 174
7.2 系统与系统之间的语言——OSI初步 174
7.3 OSI模型的七个层次 176
7.3.1 应用层 176
7.3.2 表示层 176
7.3.3 会话层 176
7.3.4 传输层 177
7.3.5 网络层 177
7.3.6 数据链路层 178
7.3.7 物理层 181
7.4 OSI与网络 182
第8章 勇破难关——Fibre Channel协议详解 185
8.1 FC网络——极佳的候选角色 186
8.1.1 物理层 186
8.1.2 链路层 186
8.1.3 网络层 188
8.1.4 传输层 194
8.1.5 上三层 195
8.1.6 小结 195
8.2 FC协议中的七种端口类型 196
8.2.1 N端口和F端口 196
8.2.2 L端口 196
8.2.3 NL端口和FL端口 197
8.2.4 E端口 199
8.2.5 G端口 199
8.3 FC适配器 200
8.4 改造盘阵前端通路——SCSI迁移到FC 201
8.5 引入FC之后 202
8.6 多路径访问目标 206
8.7 FC交换网络节点4次Login过程简析 210
第9章 天翻地覆——FC协议的巨大力量 211
9.1 FC交换网络替代并行SCSI总线的必然性 212
9.1.1 面向连接与面向无连接 212
9.1.2 串行和并行 213
9.2 不甘示弱——后端也升级换代为FC 213
9.3 FC革命——完整的盘阵解决方案 215
9.3.1 FC磁盘接口结构 215
9.3.2 一个磁盘同时连入两个控制器的Loop中 216
9.3.3 共享环路还是交换——SBOD芯片级详解 217
9.4 SAS大革命 228
9.4.1 SAS物理层 228
9.4.2 SAS链路层 230
9.4.3 SAS网络层 232
9.4.4 SAS传输层和应用层 234
9.4.5 SAS的应用设计和实际应用示例 237
9.4.6 SAS目前的优势和面临的挑战 238
9.5 中高端磁盘阵列整体架构简析 239
9.5.1 IBM DS4800和DS5000控制器架构简析 240
9.5.2 NetApp FAS系列磁盘阵列控制器简析 249
9.5.3 IBM DS8000简介 250
9.5.4 富士通ETERNUS DX8000磁盘阵列控制器结构简析 251
9.5.5 EMC公司Clariion CX/CX3及DMX系列盘阵介绍 254
9.5.6 HDS公司AMS2000和USP系列盘阵介绍 260
9.5.7 HP公司MSA2000和EVA8000存储系统架构简介 264
9.5.8 传统磁盘阵列架构总结 265
9.6 磁盘阵列配置实践 266
9.6.1 基于IBM的DS4500盘阵的配置实例 266
9.6.2 基于EMC的CX700磁盘阵列配置实例 272
9.7 HBA卡逻辑架构详析与SAN Boot示例 275
9.7.1 HBA卡逻辑架构 275
9.7.2 支持Boot的HBA卡访问流程 277
9.8 国产中高端FC磁盘阵列 280
9.8.1 Infortrend中低端ESDS系列存储系统 281
9.8.2 Infortrend中高端ESVA系列存储系统 284
9.8.3 Infortrend存储软件特性及配置界面 284
9.9 小结 287
第10章 三足鼎立——DAS、SAN和NAS 289
10.1 NAS也疯狂 290
10.1.1 另辟蹊径——乱谈NAS的起家 290
10.1.2 双管齐下——两种方式访问的后端存储网络 293
10.1.3 万物归一——网络文件系统 293
10.1.4 美其名曰——NAS 302
10.2 龙争虎斗——NAS与SAN之争 303
10.2.1 SAN快还是NAS快 303
10.2.2 SAN好还是NAS好 305
10.2.3 与SAN设备的通信过程 305
10.2.4 与NAS设备的通信过程 306
10.2.5 文件提供者 307
10.2.6 NAS的本质 308
10.3 DAS、SAN和NAS 308
10.4 最终幻想——将文件系统语言承载于FC网络传输 309
10.5 长路漫漫——存储系统架构演化过程 309
10.5.1 第一阶段：全整合阶段 310
10.5.2 第二阶段：磁盘外置阶段 310
10.5.3 第三阶段：外部独立磁盘阵列阶段 310
10.5.4 第四阶段：网络化独立磁盘阵列阶段 310
10.5.5 第五阶段：瘦服务器主机、独立NAS阶段 311
10.5.6 第六阶段：全分离式阶段 311
10.5.7 第七阶段：统一整合阶段 312
10.5.8 第八阶段：迅速膨胀阶段 312
10.5.9 第九阶段：收缩阶段 313
10.5.10 第十阶段：强烈坍缩阶段 313
10.6 泰山北斗——NetApp的NAS产品 314
10.6.1 WAFL配合RAID 4 314
10.6.2 Data ONTAP利用了数据库管理系统的设计 315
10.6.3 利用NVRAM来记录操作日志 315
10.6.4 WAFL从不覆写数据 316
10.7 初露锋芒——BlueArc公司的NAS产品 316
10.8 宝刀未老——Infortrend公司NAS产品 318
第11章 大师之作——大话以太网和TCP/IP协议 321
11.1 共享总线式以太网 322
11.1.1 连起来 322
11.1.2 找目标 322
11.1.3 发数据 323
11.2 网桥式以太网 324
11.3 交换式以太网 325
11.4 TCP/IP协议 326
11.4.1 TCP/IP协议中的IP 326
11.4.2 IP的另外一个作用 327
11.4.3 TCP/IP协议中的TCP和UDP 327
11.5 TCP/IP和以太网的关系 330
第12章 异军突起——存储网络的新军IP SAN 331
12.1 横眉冷对——TCP/IP与FC 332
12.2 自叹不如——为何不是以太网+TCP/IP 332
12.3 天生我才必有用——攻陷Disk SAN阵地 333
12.4 iSCSI交互过程简析 334
12.4.1 实例一：初始化磁盘过程 334
12.4.2 实例二：新建一个文本文档 337
12.4.3 实例三：文件系统位图 340
12.5 iSCSI磁盘阵列 342
12.6 IP SAN 343
12.7 增强以太网和TCP/IP的性能 344
12.8 FC SAN节节败退 346
12.9 iSCSI配置应用实例 346
12.9.1 第一步：在存储设备上创建LUN 346
12.9.2 第二步：在主机端挂载LUN 349
12.10 iSCSI卡Boot配置示例 351
12.11 10Gb以太网的威力初显 352
12.12 小结 353
第13章 握手言和——IP与FC融合的结果 355
13.1 FC的窘境 356
13.2 协议融合的迫切性 357
13.3 网络通信协议的四级结构 360
13.4 协议融合的三种方式 362
13.5 Tunnel和Map融合方式各论 362
13.5.1 Tunnel方式 363
13.5.2 Map方式 364
13.6 FC与IP协议之间的融合 366
13.7 无处不在的协议融合 367
13.8 交叉融合 367
13.9 IFCP和FCIP的具体实现 368
13.10 局部隔离/全局共享的存储网络 370
13.11 多协议混杂的存储网络 371
13.12 IP Over FC 372
13.13 FCoE 374
13.13.1 FCoE的由来 374
13.13.2 FcoE的设计框架 374
13.13.3 FcoE卡 375
13.13.4 FCoE交换机 376
13.13.5 解剖FCoE交换机 377
13.13.6 存储阵列设备端的改动 380
13.13.7 FCoE与iSCSI 380
13.13.8 FcoE的前景 380
13.13.9 Open FCoE 381
第14章 变幻莫测——虚拟化 383
14.1 操作系统对硬件的虚拟化 384
14.2 计算机存储子系统的虚拟化 385
14.3 带内虚拟化和带外虚拟化 389
14.4 硬网络与软网络 392
14.5 用多台独立的计算机模拟成一台虚拟计算机 393
14.6 用一台独立的计算机模拟出多台虚拟计算机 393
14.7 用磁盘阵列来虚拟磁带库 394
14.8 用控制器来虚拟其他磁盘阵列 402
14.9 飞康NSS存储虚拟化系统 404
14.9.1 存储虚拟化相关技术 405
14.9.2 数据保护相关技术和产品 409
14.9.3 异构迁移和容灾相关技术和产品 409
第15章 众志成城——存储集群 413
15.1 集群概述 414
15.1.1 高可用性集群（HAC） 414
15.1.2 负载均衡集群（LBC） 414
15.1.3 高性能集群（HPC） 414
15.2 集群的适用范围 415
15.3 系统路径上的集群各论 415
15.3.1 硬件层面的集群 415
15.3.2 软件层面的集群 416
15.4 实例：Microsoft MSCS软件实现应用集群 417
15.4.1 在Microsoft Windows Server 2003上安装MSCS 417
15.4.2 配置心跳网络 419
15.4.3 测试安装 419
15.4.4 测试故障转移 420
15.5 实例：SQL Server集群安装配置 420
15.5.1 安装SQL Server 420
15.5.2 验证SQL 数据库集群功能 423
15.6 块级集群存储系统 425
15.6.1 IBM XIV集群存储系统 427
15.6.2 3PAR公司Inserv-T800集群存储系统 436
15.6.3 EMC公司Symmetrix V-MAX集群存储系统 439
15.7 集群NAS系统和集群文件系统 446
15.7.1 HP公司的Ibrix集群NAS系统 446
15.7.2 Panasas和pNFS 449
15.7.3 此“文件系统”非彼“文件系统” 450
15.7.4 什么是Single Name Space 451
15.7.5 Single Filesystem Image与Single Path Image 452
15.7.6 集群中的分布式锁机制 453
15.7.7 集群文件系统的缓存一致性 454
15.7.8 集群NAS的本质 455
15.7.9 块级集群与NAS集群的融合猜想 456
15.8 对象存储系统 456
15.9 当前主流的集群文件系统架构分类与对比 462
15.9.1 共享与非共享存储型集群 462
15.9.2 对称式与非对称式集群 463
15.9.3 自助型与服务型集群 464
15.9.4 SPI与SFI型集群 465
15.9.5 串行与并行集群 466
15.9.6 集群/并行/分布式/共享文件系统各论 467
15.9.7 集群NAS系统的三层架构 468
15.9.8 实际中的各种集群拓扑一览 468
15.10 带外共享SAN文件系统 471
15.10.1 SAN共享文件系统 471
15.10.2 针对NAS和SAN文件系统的并行化改造 472
15.10.3 SAN FS实例分析 473
15.11 集群的本质——一种自组自控轮回的Raid 475
15.11.1 三统理论 476
15.11.2 并行的不仅可以是文件 478
15.11.3 集群底层与上层解耦 479
15.11.4 云基础架构 480
15.12 纯软Scale-Out SAN 480
15.13 互联网运营商的特殊集群——NoSQL 481
第16章 未雨绸缪——数据保护和备份技术 485
16.1 数据保护 486
16.1.1 文件级备份 486
16.1.2 块级备份 487
16.2 高级数据保护方法 487
16.2.1 远程文件复制 487
16.2.2 远程磁盘（卷）镜像 487
16.2.3 快（块）照数据保护 488
16.2.4 卷Clone 516
16.2.5 Continuous Data Protect（CDP，连续数据保护） 522
16.2.6 VSS公共快照服务 566
16.2.7 快照、克隆、CDP与平行宇宙 567
16.2.8 高帧率IO级数据录像 568
16.3 数据备份系统的基本要件 576
16.3.1 备份目标 576
16.3.2 备份通路 579
16.3.3 备份引擎 581
16.3.4 三种备份方式 585
16.3.5 数据备份系统案例一 586
16.3.6 数据备份系统案例二 587
16.3.7 NetBackup配置指南 588
16.3.8 配置DB2数据库备份 599
16.4 与业务应用相结合的快照备份和容灾 606
第17章 愚公移山——大话数据容灾 609
17.1 容灾概述 610
17.2 生产资料容灾——原始数据的容灾 611
17.2.1 通过主机软件实现前端专用网络或者前端公用网络同步 612
17.2.2 案例：DB2数据的HADR组件容灾 615
17.2.3 通过主机软件实现后端专用网络同步 621
17.2.4 通过数据存储设备软件实现专用网络同步 625
17.2.5 案例：IBM公司Remote Mirror容灾实施 626
17.2.6 小结 629
7.3 容灾中数据的同步复制和异步复制 630
17.3.1 同步复制例解 630
17.3.2 异步复制例解 631
17.4 容灾系统数据一致性保证与故障恢复机制 632
17.4.1 数据一致性问题的产生 632
17.4.2 对异步数据复制过程中一致性保证的实现方式 634
17.4.3 灾难后的切换与回切同步过程 645
17.4.4 周期性异步复制与连续异步复制 646
17.5 四大厂商的数据容灾系统方案概述 646
17.5.1 IBM公司的PPRC 646
17.5.2 EMC公司的MirrorView、SanCopy和SRDF 647
17.5.3 HDS公司的Truecopy 649
17.5.4 NetApp公司的Snapmirror 649
17.6 生产者的容灾——服务器应用程序的容灾 650
17.6.1 生产者容灾概述 651
17.6.2 案例一：基于Symantec公司的应用容灾产品VCS① 655
17.6.3 案例二：基于Symantec公司的应用容灾产品VCS② 658
17.7 虚拟容灾技术 660
17.8 一体化先行军——爱数一体化备份存储柜 660
17.8.1 爱数备份存储柜3.5产品架构分析 661
17.8.2 爱数备份存储柜v3.5独特技术 663
17.8.3 国产存储的方向 665
17.9 Infortrend RR远程复制技术 666
17.10 飞康RecoverTrac容灾管理系统 667
17.11 带宽、延迟及其影响 674
第18章 鬼斧神工——数据前处理与后处理 677
18.1 数据存储和数据管理 678
18.2 存储系统之虚实阴阳论 678
18.3 Data Cooker各论 679
18.3.1 Thin Provision/Over Allocation 679
18.3.2 LUN Space Reclaiming（Unprovision/Deprovision，Get Thin） 686
18.3.3 Tier（分级）/Migrating（迁移） 689
18.3.4 Deduplication（重复数据删除） 721
18.3.5 磁盘数据一致性保护及错误恢复 736
第19章 过关斩将——系统IO路径及优化 745
19.1 理解并记忆主机端IO路径架构图 747
19.1.1 应用程序层 748
19.1.2 文件系统层 787
19.1.3 卷管理层 795
19.1.4 层与层之间的调度员：IO Manager 806
19.1.5 底层设备驱动层 814
19.2 理解并记忆存储端IO路径架构图 843
19.2.1 物理磁盘层 843
19.2.2 物理磁盘组织层 844
19.2.3 后端磁盘控制器/适配器层 845
19.2.4 RAID管理层 845
19.2.5 LUN管理层 848
19.2.6 前端接口设备及驱动层 856
19.2.7 缓存管理层 856
19.2.8 数据前处理和后处理层 865
19.2.9 存储系统处理一个IO的一般典型流程 865
19.3 IO性能问题诊断总论 866
19.3.1 所谓“优化”的含义 867
19.3.2 如何发现系统症状 868
19.3.3 六剂良药治愈IO性能低下 868
19.3.4 面向SSD的IO处理过程优化 873
19.4 小结：再论机器世界与人类世界 874
第20章 腾云驾雾——大话云存储 875
20.1 太始之初——“云”的由来 876
20.1.1 观点1：云即设备 876
20.1.2 观点2：云即集群 877
20.1.3 观点3：云即IT系统 877
20.1.4 观点4：云即服务 877
20.1.5 云目前最主流的定义 878
20.2 混沌初开——是谁催生了云 878
20.2.1 一切皆以需求为导向 878
20.2.2 云对外表现为一种商业模式 879
20.3 落地生根——以需求为导向的系统架构变化 880
20.3.1 云对内表现为一种技术架构 880
20.3.2 云到底是模式还是技术 882
20.3.3 公有云和私有云 883
20.4 拨云见日——云系统架构及其组成部分 885
20.4.1 物理支撑层 885
20.4.2 基础IT架构层 885
20.4.3 基础架构/集群管理层 886
20.4.4 资源部署层 886
20.4.5 中间件层 886
20.4.6 应用引擎层 887
20.4.7 业务展现与运营层 887
20.5 真相大白——实例说云 889
20.5.1 3Tera Applogic 889
20.5.2 IBM Blue Could 898
20.6 乘风破浪——困难还是非常多的 903
20.6.1 云的优点 903
20.6.2 云目前存在的问题 904
20.7 千年之梦——云今后的发展 905
20.7.1 云本质思考 905
20.7.2 身边的各种云服务 907
20.7.3 进化还是退化 908
20.7.4 云发展展望 908
20.7.5 Micro、Mini、Normal、Huge、Gird弹性数据中心 909
20.7.6 弹性层的出现将会让数据中心拥有两套性能指标 910
20.8 尘埃落定——云所体现出来的哲学思想 911
20.8.1 轮回往复——云的哲学形态 911
20.8.2 智慧之云——云的最终境界 911
20.8.3 云在哲学上所具有的性质 912
20.8.4 云基础架构的艺术与哲学意境 912
20.8.5 纵观存储发展时代——云发展预测 914
20.9 结束语 917
附录1 存储系统问与答精华集锦 919
附录2 IP硬盘——玩玩还是来真的？ 979
附录3 新技术将如何影响数据中心存储系统 983
后记 989
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大话存储（终极版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MySQL性能调优与架构设计
"第1篇 基础篇 1
第1章 MySQL基本介绍 3
1.0 引言 4
1.1 MySQL Server简介 4
1.2 MySQL与其他数据库的简单比较 6
1.3 MySQL 的主要适用场景 8
1.4 小结 9
第2章 MySQL架构组成 11
2.0 引言 12
2.1 MySQL物理文件组成 12
2.2 MySQL Server系统架构 16
2.3 MySQL 自带工具使用介绍 22
2.4 小结 26
第3章 MySQL存储引擎简介 27
3.0 引言 28
3.1 MySQL存储引擎概述 28
3.2 MyISAM存储引擎简介 29
3.3 InnoDB存储引擎简介 30
3.4 NDB Cluster 存储引擎简介 32
3.5 其他存储引擎介绍 34
3.6 小结 37
第4章 MySQL安全管理 39
4.0 引言 40
4.1 数据库系统安全相关因素 40
4.2 MySQL 权限系统介绍 43
4.3 MySQL 访问授权策略 54
4.4 安全设置注意事项 55
4.5 小结 57
第5章 MySQL备份与恢复 59
5.0 引言 60
5.1 数据库备份使用场景 60
5.2 逻辑备份与恢复测试 61
5.3 物理备份与恢复测试 68
5.4 备份策略的设计思路 75
5.5 小结 76
第2篇 性能优化篇 77
第6章 影响MySQL Server性能的相关因素 79
6.0 引言 80
6.1 商业需求对性能的影响 80
6.2 系统架构及实现对性能的影响 83
6.3 Query语句对系统性能的影响 89
6.4 Schema设计对系统的性能影响 96
6.5 硬件环境对系统性能的影响 99
6.6 小结 102
第7章 MySQL数据库锁定机制 103
7.0 引言 104
7.1 MySQL锁定机制简介 104
7.2 各种锁定机制分析 106
7.3 合理利用锁机制优化MySQL 117
7.4 小结 120
第8章 MySQL数据库Query的优化 121
8.0 引言 122
8.1 理解MySQL的Query Optimizer 122
8.2 Query 语句优化基本思路和原则 123
8.3 充分利用 Explain 和 Profiling 130
8.4 合理设计并利用索引 136
8.5 Join的实现原理及优化思路 149
8.6 ORDER BY、GROUP BY和DISTINCT的优化 155
8.7 小结 167
第9章 MySQL数据库Schema 设计的性能优化 169
9.0 引言 170
9.1 高效的模型设计 170
9.2 合适的数据类型 176
9.3 规范的对象命名 180
9.4 小结 181
第10章 MySQL Server性能优化 183
10.0 引言 184
10.1 MySQL安装优化 184
10.2 MySQL日志设置优化 188
10.3 Query Cache 优化 192
10.4 MySQL Server 其他常用优化 196
10.5 小结 202
第11章 常用存储引擎优化 203
11.0 引言 204
11.1 MyISAM存储引擎优化 204
11.2 InnoDB 存储引擎优化 211
11.3 小结 227
第3篇 架构设计篇 229
第12章 MySQL可扩展设计的基本原则 231
12.0 引言 232
12.1 什么是可扩展性 232
12.2 事务相关性最小化原则 234
12.3 数据一致性原则 235
12.4 高可用及数据安全原则 237
12.5 小结 237
第13章 可扩展性设计之 MySQL Replication 239
13.0 引言 240
13.1 Replication 对可扩展性设计的意义 240
13.2 Replication 机制的实现原理 241
13.3 Replication常用架构 244
13.4 Replication 搭建实现 249
13.5 小结 255
第14章 可扩展性设计之数据切分 257
14.0 引言 258
14.1 何谓数据切分 258
14.2 数据的垂直切分 259
14.3 数据的水平切分 261
14.4 垂直与水平联合切分的使用 263
14.5 数据切分及整合方案 265
14.6 数据切分与整合中可能存在的问题 271
14.7 小结 273
第15章 可扩展性设计之Cache与Search的利用 275
15.0 引言 276
15.1 可扩展设计的数据库之外延伸 276
15.2 合理利用第三方Cache解决方案 277
15.3 自行实现Cache服务 284
15.4 利用Search实现高效的全文检索 285
15.5 利用分布式并行计算实现大数据量的高性能运算 287
15.6 小结 288
第16章 MySQL Cluster 289
16.0 引言 290
16.1 MySQL Cluster介绍 290
16.2 MySQL Cluster环境搭建 292
16.3 MySQL Cluster配置详细介绍（config.ini） 298
16.4 MySQL Cluster基本管理与维护 304
16.5 基本优化思路 307
16.6 小结 308
第17章 高可用设计思路及方案 309
17.0 引言 310
17.1 利用 Replication 来实现高可用架构 310
17.2 利用MySQL Cluster实现整体高可用 316
17.3 利用DRBD保证数据的高安全可靠 320
17.4 其他高可用设计方案 323
17.5 各种高可用方案的利弊比较 326
17.6 小结 327
第18章 高可用设计之MySQL监控 329
18.0 引言 330
18.1 监控系统设计 330
18.2 健康状态监控 332
18.3 性能状态监控 335
18.4 常用开源监控软件 342
18.5 小结 344
附录A 实验测试Schema创建脚本 345
附录B MySQL部分系统参数说明及设置建议 349
附录C MySQL部分状态说明 373
索引 389
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MySQL性能调优与架构设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高可用架构（第1卷）
第1 章 高可用架构案例精选 1
郭斯杰／1.1 Twitter 高性能分布式日志系统架构解析 1
1.1.1 为什么需要分布式日志. 1
1.1.2 Twitter 如何考虑这个问题 4
1.1.3 基于Apache BookKeeper 构建DistributeLog  5
1.1.4 DistributeLog 案例分享13
1.1.5 疑问与解惑.13
颜国平／1.2 腾讯基于用户画像大数据的电商防刷架构.16
1.2.1 背景介绍16
1.2.2 黑产现状介绍16
1.2.3 腾讯内部防刷架构18
1.2.4 腾讯大数据收集维度.20
1.2.5 腾讯大数据处理平台——魔方21
1.2.6 疑问与解惑.24
王渊命／1.3 如何设计类似微信的多终端数据同步协议：Grouk 实践分享.26
1.3.1 移动互联网时代多终端数据同步面临的挑战26
1.3.2 多终端数据同步与传统消息投递协议的差异27
1.3.3 Grouk 在多终端数据同步协议上的探索实践.28
1.3.4 疑问与解惑.32
周 洋／1.4 如何实现支持数亿用户的长连消息系统：Golang 高并发案例33
1.4.1 关于push 系统对比与性能指标的讨论.33
1.4.2 消息系统架构介绍35
1.4.3 哪些因素决定推送系统的效果37
1.4.4 GO 语言开发问题与解决方案.38
1.4.5 消息系统的运维及测试41
1.4.6 疑问与解惑.42
唐福林／1.5 雪球在股市风暴下的高可用架构改造分享.46
1.5.1 雪球公司的介绍46
1.5.2 雪球当前总体架构47
1.5.3 雪球架构优化历程48
1.5.4 关于架构优化的总结和感想.53
1.5.5 疑问与解惑.54
麦俊生／1.6 亿级短视频社交美拍架构实战59
1.6.1 短视频市场的发展59
1.6.2 美拍的发展.60
1.6.3 短视频所面临的架构问题61
1.6.4 为支持亿级用户，美拍架构所做的一些改进62
1.6.5 后续发展68
刘道儒／1.7 微博“异地多活”部署经验谈69
1.7.1 微博异地多活建设历程69
1.7.2 微博异地多活面临的挑战70
1.7.3 异地多活的最佳实践.73
1.7.4 异地多活的新方向74
孙宇聪／1.8 来自Google 的高可用架构理念与实践75
1.8.1 决定可用性的两大因素76
1.8.2 高可用性方案77
1.8.3 可用性7 级图表80
1.8.4 疑问与解惑.81
那 谁／1.9 深入理解同步／异步与阻塞／非阻塞区别84
1.9.1 同步与异步.84
1.9.2 阻塞与非阻塞85
1.9.3 与多路复用I/O 的联系86
第2 章 高可用架构原理与分布式实践.88
黄东旭／2.1 Codis 作者细说分布式Redis 架构设计88
2.1.1 Redis、Redis Cluster 和Codis88
2.1.2 我们更爱一致性90
2.1.3 Codis 在生产环境中的使用经验和坑91
2.1.4 分布式数据库和分布式架构.94
2.1.5 疑问与解惑.95
霍泰稳／2.2 给你介绍一个不一样的硅谷.98
2.2.1 Uber .98
2.2.2 Coursera.99
2.2.3 Airbnb102
2.2.4 硅谷行带给我的一些影响106
2.2.5 疑问与解惑106
金自翔／2.3 解耦的艺术——大型互联网业务系统的插件化改造110
2.3.1 插件化.110
2.3.2 如何处理用户交互115
2.3.3 如何处理数据.115
2.3.4 总结116
沈 剑／2.4 从零开始搭建高可用IM 系统117
2.4.1 什么是IM117
2.4.2 协议设计118
2.4.3 WEB 聊天室.122
2.4.4 IM 典型业务场景126
2.4.5 疑问与解惑126
陈宗志／2.5 360 分布式存储系统Bada 的架构设计和应用.129
2.5.1 主要应用场景.129
2.5.2 整体架构130
2.5.3 主要模块131
2.5.4 数据分布策略.132
2.5.5 请求流程133
2.5.6 多机房架构134
2.5.7 FAQ138
2.5.8 疑问与解惑139
张 亮／2.6 新一代分布式任务调度框架：当当Elastic-Job 开源项目
的10 项特性143
2.6.1 为什么需要作业（定时任务）.143
2.6.2 当当之前使用的作业系统144
2.6.3 Elastic-Job 的来历.144
2.6.4 Elastic-Job 包含的功能145
2.6.5 Elastic-Job 的部署和使用.146
2.6.6 对开源产品的开发理念.147
2.6.7 未来展望148
2.6.8 疑问与解惑149
付海军／2.7 互联网DSP 广告系统架构及关键技术解析152
2.7.1 优秀DSP 系统的特点152
2.7.2 程序化购买的特点153
2.7.3 在线广告的核心问题156
2.7.4 在线广告的挑战.156
2.7.5 DSP 系统架构.157
2.7.6 RTB 投放引擎的架构.158
2.7.7 DMP160
2.7.8 广告系统DMP 数据处理的架构.160
2.7.9 用户画像的方法.162
2.7.10 广告行业的反作弊.165
2.7.11 P2P 流量互刷166
2.7.12 CPS 引流作弊167
2.7.13 疑问与解惑168
王卫华／2.8 亿级规模的Elasticsearch 优化实战170
2.8.1 索引性能（Index Performance） .170
2.8.2 查询性能（Query Perofrmance） 171
2.8.3 其他173
2.8.4 疑问与解惑174
杨卫华／2.9 微博分布式存储考试题：案例讲解及作业精选179
2.9.1 访问场景179
2.9.2 设计180
2.9.3 sharding 策略180
2.9.4 案例精选181
李 凯／2.10 架构师需要了解的Paxos 原理、历程及实战.184
2.10.1 数据库高可用性难题184
2.10.2 Paxos 协议简单回顾.185
2.10.3 Basic Paxos 同步日志的理论模型186
2.10.4 Multi Paxos 的实际应用.187
2.10.5 依赖时钟误差的变种Paxos 选主协议简单分析190
2.10.6 疑问与解惑191
温 铭／2.11 OpenResty 的现在和未来193
2.11.1 OpenResty 是什么，适合什么场景下使用.193
2.11.2 某安全公司服务端技术选型的标准194
2.11.3 如何在项目中引入新技术.196
2.11.4 如何入门以及学习的正确方法197
2.11.5 OpenResty 中的测试和调试.199
2.11.6 NginScript 是否会替代OpenResty201
2.11.7 未来重点解决的问题和新增特性.202
2.11.8 开源社区建设203
2.11.9 疑问与解惑.203
第3 章 电商架构热点专题.205
张开涛／3.1 亿级商品详情页架构演进技术解密.205
3.1.1 商品详情页205
3.1.2 商品详情页发展史209
3.1.3 遇到的一些问题和解决方案220
3.1.4 总结228
3.1.5 疑问与解惑229
杨 超／3.2 大促系统全流量压测及稳定性保证——京东交易架构.232
3.2.1 交易系统的三个阶段232
3.2.2 交易系统的三层结构233
3.2.3 交易系统的访问特征234
3.2.4 应对大促的第1 步：全链路全流量线上压测.234
3.2.5 应对大促的第2 步：根据压力表现进行调优.237
3.2.6 异步和异构240
3.2.7 应对大促的第3 步：分流与限流242
3.2.8 应对大促的第4 步：容灾降级.244
3.2.9 应对大促的第5 步：完善监控.245
3.2.10 疑问与解惑246
吕 毅／3.3 秒杀系统架构解密与防刷设计.248
3.3.1 抢购业务介绍.248
3.3.2 具体抢购项目中的设计.249
3.3.3 如何解耦前后端压力250
3.3.4 如何保证商品库的库存可靠252
3.3.5 如何与第三方多方对账.254
3.3.6 项目总结255
3.3.7 疑问与解惑255
王富平／3.4 Lambda 架构与推荐在电商网站实践.257
3.4.1 Lambda 架构257
3.4.2 1 号店推荐系统实践260
3.4.3 Lambda 的未来262
3.4.4 思考263
3.4.5 疑问与解惑263
杨 硕／3.5 某公司线上真实流量压测工具构建.265
3.5.1 为什么要开发一个通用的压测工具265
3.5.2 常见的压测工具.266
3.5.3 构建自己的压测工具266
3.5.4 疑问与解惑271
第4 章 容器与云计算.273
陈 飞／4.1 微博基于Docker 容器的混合云迁移实战.273
4.1.1 为什么要采用混合云的架构273
4.1.2 跨云的资源管理与调度.275
4.1.3 容器的编排与服务发现.278
4.1.4 混合云监控体系.284
4.1.5 前进路上遇到的那些坑.286
4.1.6 疑问与解惑286
高 磊／4.2 互联网金融创业公司Docker 实践287
4.2.1 背景介绍287
4.2.2 容器选型287
4.2.3 应用迁移288
4.2.4 弹性扩容291
4.2.5 未来规划295
4.2.6 疑问与解惑295
高永超／4.3 使用开源Calico 构建Docker 多租户网络.297
4.3.1 PaaS 平台的网络需求.297
4.3.2 使用Calico 实现Docker 的跨服务器通讯.298
4.3.3 利用Profile 实现ACL301
4.3.4 性能测试306
4.3.5 Calico 的发展308
4.3.6 疑问与解惑309
彭哲夫／4.4 解析Docker 在芒果TV 的实践之路310
4.4.1 豆瓣时期310
4.4.2 芒果TV 的Nebulium Engine .311
4.4.3 Project Eru .312
4.4.4 细节313
4.4.5 网络314
4.4.6 存储315
4.4.7 Scale316
4.4.8 资源分配和集群调度316
4.4.9 服务发现和安全.317
4.4.10 实例317
4.4.11 总结318
4.4.12 疑问与解惑318
王关胜／4.5 微博基于Docker 的混合云平台设计与实践323
4.5.1 微博的业务场景及混合云背景.323
4.5.2 三大基础设施助力微博混合云.326
4.5.3 微博混合云DCP 系统设计核心：自动化、弹性调度328
4.5.4 引入阿里云作为第3 机房，实现弹性调度架构330
4.5.5 大规模集群操作自动化.331
4.5.6 不怕峰值事件.332
第5 章 运维保障333
王 康／5.1 360 如何用QConf 搞定两万以上服务器的配置管理.333
5.1.1 设计初衷333
5.1.2 整体认识334
5.1.3 架构介绍335
5.1.4 QConf 服务端336
5.1.5 QConf 客户端336
5.1.6 QConf 管理端340
5.1.7 其他341
5.1.8 疑问与解惑343
尤 勇／5.2 深度剖析开源分布式监控CAT347
5.2.1 背景介绍347
5.2.2 整体设计348
5.2.3 客户端设计349
5.2.4 服务端设计352
5.2.5 总结感悟357
杨尚刚／5.3 单表60 亿记录等大数据场景的MySQL 优化和运维之道359
5.3.1 前言359
5.3.2 数据库开发规范.360
5.3.3 数据库运维规范.363
5.3.4 性能优化368
5.3.5 疑问与解惑375
秦 迪／5.4 微博在大规模、高负载系统问题排查方法379
5.4.1 背景379
5.4.2 排查方法及线索.379
5.4.3 总结384
5.4.4 疑问与解惑385
秦 迪／5.5 系统运维之为什么每个团队存在大量烂代码387
5.5.1 写烂代码很容易.387
5.5.2 烂代码终究是烂代码388
5.5.3 重构不是万能药.392
5.5.4 写好代码很难.393
5.5.5 悲观的结语394
秦 迪／5.6 系统运维之评价代码优劣的方法395
5.6.1 什么是好代码.395
5.6.2 结语403
5.6.3 参考阅读403
秦 迪／5.7 系统运维之如何应对烂代码404
5.7.1 改善可维护性.404
5.7.2 改善性能与健壮性409
5.7.3 改善生存环境.412
5.7.4 个人感想414
第6 章 大数据与数据库415
王 劲／6.1 某音乐公司的大数据实践.415
6.1.1 什么是大数据.415
6.1.2 某音乐公司大数据技术架构418
6.1.3 在大数据平台重构过程中踩过的坑425
6.1.4 后续的持续改进.430
王新春／6.2 实时计算在点评.431
6.2.1 实时计算在点评的使用场景431
6.2.2 实时计算在业界的使用场景432
6.2.3 点评如何构建实时计算平台433
6.2.4 Storm 基础知识简单介绍.434
6.2.5 如何保证业务运行的可靠性436
6.2.6 Storm 使用经验分享438
6.2.7 关于计算框架的后续想法442
6.2.8 疑问与解惑442
王卫华／6.3 百姓网Elasticsearch 2.x 升级之路.446
6.3.1 Elasticsearch 2.x 变化446
6.3.2 升级之路448
6.3.3 优化或建议451
6.3.4 百姓之道452
6.3.5 后话：Elasticsearch 5.0453
6.3.6 升级2.x 版本成功，5.x 版本还会远吗454
董西成 张虔熙／6.4 Hadoop、HBase 年度回顾457
6.4.1 Hadoop 2015 技术发展457
6.4.2 HBase 2015 年技术发展460
6.4.3 疑问与解惑466
常 雷／6.5 解密Apache HAWQ——功能强大的SQL-on-Hadoop 引擎.469
6.5.1 HAWQ 基本介绍469
6.5.2 Apache HAWQ 系统架构.472
6.5.3 HAWQ 中短期规划.479
6.5.4 贡献到Apache HAWQ 社区479
6.5.5 疑问与解惑480
萧少聪／6.6 PostgresSQL HA 高可用架构实战.482
6.6.1 PostgreSQL 背景介绍.482
6.6.2 在PostgreSQL 下如何实现数据复制技术的HA 高可用集群483
6.6.3 Corosync+Pacemaker MS 模式介绍484
6.6.4 Corosync+Pacemaker M/S 环境配置485
6.6.5 Corosync+Pacemaker HA 基础配置488
6.6.5 PostgreSQL Sync 模式当前的问题492
6.6.6 疑问与解惑492
王晶昱／6.7 从NoSQL 历史看未来.495
6.7.1 前言495
6.7.2 1970 年：We have no SQL496
6.7.3 1980 年：Know SQL 497
6.7.4 2000 年：No SQL .502
6.7.5 2005 年：不仅仅是SQL 504
6.7.6 2013 年：No，SQL .505
6.7.7 阿里的技术选择.505
6.7.8 疑问与解惑506
杨尚刚／6.8 MySQL 5.7 新特性大全和未来展望.508
6.8.1 提高运维效率的特性508
6.8.2 优化器Server 层改进.511
6.8.3 InnoDB 层优化513
6.8.4 未来发展517
6.8.5 运维经验总结.518
6.8.6 疑问与解惑519
谭 政／6.9 大数据盘点之Spark 篇521
6.9.1 Spark 的特性以及功能521
6.9.2 Spark 在Hulu 的实践.525
6.9.3 Spark 未来的发展趋势528
6.9.4 参考文章530
6.9.5 疑问与解惑530
萧少聪／6.10 从Postgres 95 到PostgreSQL 9.5：新版亮眼特性532
6.10.1 Postgres 95 介绍532
6.10.2 PostgresSQL 版本发展历史533
6.10.3 PostgresSQL 9.5 的亮眼特性534
6.10.4 PostgresSQL 还可以做什么544
6.10.5 疑问与解惑547
毕洪宇／6.11 MongoDB 2015 回顾：全新里程碑式的WiredTiger 存储引擎551
6.11.1 存储引擎的发展551
6.11.2 复制集改进.555
6.11.3 自动分片机制556
6.11.4 其他新特性介绍556
6.11.5 疑问与解惑.558
王晓伟／6.12 基于Xapian 的垂直搜索引擎的构建分析561
6.12.1 垂直搜索的应用场景561
6.12.2 技术选型.563
6.12.3 垂直搜索的引擎架构564
6.12.4 垂直搜索技术和业务细节.566
6.12.5 疑问与解惑568
第7 章 安全与网络572
郭 伟／7.1 揭秘DDoS 防护——腾讯云大禹系统572
7.1.1 有关DDoS 简介的问答.574
7.1.2 有关大禹系统简介的问答575
7.1.3 有关大禹系统硬件防护能力的问答576
7.1.4 有关算法设计的问答577
7.1.5 大禹和其他产品、技术的区别.578
冯 磊 赵星宇／7.2 App 域名劫持之DNS 高可用——开源版
HttpDNS 方案详解580
7.2.1 HttpDNSLib 库组成.581
7.2.2 HttpDNS 交互流程582
7.2.3 代码结构583
7.2.4 开发过程中的一些问题及应对.586
7.2.5 疑问与解惑593
马 涛／7.3 CDN 对流媒体和应用分发的支持及优化595
7.3.1 CDN 系统工作原理.595
7.3.2 网络分发过程中ISP 的影响602
7.3.3 防盗链.603
7.3.4 内容分发系统的问题和应对思路604
7.3.5 P2P 穿墙打洞607
7.3.6 疑问与解惑609
马 涛／7.4 HTTPS 环境使用第三方CDN 的证书难题与最佳实践611
蒋海滔／7.5 互联网主要安全威胁分析及应对方案613
7.5.1 互联网Web 应用面临的主要威胁613
7.5.2 威胁应对方案.616
7.5.3 疑问与解惑624
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高可用架构（第1卷）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件系统架构
译者序
前言
第1版前言
第1章 简介  1
1.1 利益相关者、视点和视角  1
1.2 本书结构  4
1.3 谁应该阅读本书  5
1.4 本书约定  5
第一部分 架构的基本原则
第2章 软件架构概念  8
2.1 软件架构  8
2.1.1 系统元素和关系  8
2.1.2 基本系统属性  9
2.1.3 设计和发展的原则  10
2.1.4 系统属性和内部组织形式  10
2.1.5 软件架构的重要性  13
2.2 架构元素  13
2.3 利益相关者  14
2.3.1 个人、团队或组织  14
2.3.2 兴趣和关注点  15
2.3.3 利益相关者的重要性  16
2.4 架构描述  16
2.5 核心概念之间的关系  17
2.6 小结  18
2.7 延伸阅读  19
第3章 视点和视图  20
3.1 架构视图  22
3.2 视点  23
3.3 核心概念之间的关系  24
3.4 使用视点和视图的好处  24
3.5 视点缺陷  25
3.6 视点目录  25
3.7 小结  27
3.8 延伸阅读  28
第4章 架构视角  29
4.1 质量属性  29
4.2 架构视角  30
4.3 向视图应用视角  33
4.4 应用视角的结果  34
4.4.1 深入的观点  34
4.4.2 提升  35
4.4.3 精品内容  35
4.5 核心概念之间的关系  35
4.6 使用视角的好处  36
4.7 视角的缺陷  37
4.8 视角与视点对比  37
4.9 视角种类  38
4.10 小结  39
4.11 延伸阅读  39
第5章 软件架构师的角色  41
5.1 架构定义过程  41
5.1.1 架构定义不仅是设计  42
5.1.2 需求分析和架构定义之间的区别  43
5.1.3 架构定义和设计之间的区别  43
5.2 架构师的角色  44
5.3 核心概念之间的相互关系  46
5.4 架构专门化  47
5.5 组织情境  47
5.5.1 业务分析师  47
5.5.2 项目经理  47
5.5.3 设计主管  48
5.5.4 技术专家  49
5.5.5 开发者  49
5.6 架构师的技能  49
5.7 架构师的责任  50
5.8 小结  51
5.9 延伸阅读  51
第二部分 软件架构过程
第6章 软件架构过程简介  54
第7章 架构定义过程  55
7.1 指导原则  55
7.2 过程产出物  56
7.3 过程情境  56
7.4 支持活动  57
7.5 架构定义活动  60
7.6 过程完成标准  62
7.7 软件开发生命周期中的架构定义  64
7.7.1 瀑布式方法  64
7.7.2 迭代方法  65
7.7.3 敏捷方法  65
7.8 小结  66
7.9 延伸阅读  67
第8章 关注点、原则和决定  68
8.1 专注于问题的关注点  70
8.1.1 业务策略  70
8.1.2 业务目标和驱动力  70
8.1.3 系统范围和需求  71
8.1.4 业务标准和政策  72
8.2 专注于解决方案的关注点  72
8.2.1 IT策略  72
8.2.2 技术目标和驱动力  72
8.2.3 技术标准和政策  73
8.3 其他现实世界中的约束  73
8.4 什么决定了好的关注点  75
8.5 架构原则  75
8.5.1 什么造就了好的原则  78
8.5.2 定义自己的原则  78
8.6 架构决定  79
8.7 使用原则关联关注点和决定  81
8.8 检查列表  82
8.9 小结  83
8.10 延伸阅读  83
第9章 确定并引入利益相关者  84
9.1 利益相关者的选择  84
9.2 利益相关者的类别  85
9.2.1 出资方  86
9.2.2 评估者  86
9.2.3 沟通者  86
9.2.4 开发人员  87
9.2.5 维护人员  87
9.2.6 生产工程师  87
9.2.7 供应商  87
9.2.8 支持人员  87
9.2.9 系统管理员  88
9.2.10 测试人员  88
9.2.11 用户  88
9.3 示例  88
9.3.1 非专门设计的部署项目  88
9.3.2 软件产品开发项目  89
9.3.3 合作开发  89
9.4 代理利益相关者  90
9.5 利益相关者组  90
9.6 利益相关者的责任  90
9.7 检查列表  91
9.8 小结  91
9.9 延伸阅读  92
第10章 识别并使用场景  93
10.1 场景类型  93
10.2 使用场景  94
10.3 识别场景并排定优先级  95
10.4 捕获场景  96
10.5 什么造就了好场景  98
10.6 应用场景  98
10.6.1 纸质模型  98
10.6.2 走查  99
10.6.3 模拟  100
10.6.4 原型实现的测试  100
10.6.5 完整规模真实测试  100
10.7 有效使用场景  100
10.7.1 识别一系列重点场景  101
10.7.2 使用清晰的场景  101
10.7.3 尽早使用场景  101
10.7.4 包含对系统质量场景的使用  101
10.7.5 包含对故障场景的使用  101
10.7.6 让利益相关者紧密参与  101
10.8 检查列表  102
10.9 小结  102
10.10 延伸阅读  103
第11章 使用样式和模式  104
11.1 设计模式介绍  104
11.2 样式、模式和惯用法  105
11.2.1 架构样式  106
11.2.2 软件设计模式  106
11.2.3 语言惯用法  106
11.2.4 使用样式、模式和惯用法  107
11.3 模式和架构策略  107
11.4 架构样式的例子  108
11.5 使用架构样式的好处  110
11.6 样式和架构描述  111
11.7 应用设计模式和语言惯用法  111
11.8 检查列表  113
11.9 小结  113
11.10 延伸阅读  113
第12章 创建架构模型  115
12.1 模型为什么重要  115
12.2 模型的类型  117
12.2.1 定性模型  117
12.2.2 定量模型  118
12.2.3 示意图  119
12.3 建模语言  119
12.3.1 架构描述语言  119
12.3.2 统一建模语言  120
12.3.3 可执行的领域专用语言  121
12.3.4 其他建模语言  121
12.4 创建有效模型的准则  121
12.4.1 有目的地建模  121
12.4.2 应对受众  122
12.4.3 仔细、准确地抽象  122
12.4.4 根据风险确定工作重点  123
12.4.5 选择描述性的名称  123
12.4.6 定义你的术语  123
12.4.7 以简单为目标  124
12.4.8 使用已定义的标记法  124
12.4.9 了解暗示的语义  124
12.4.10 验证模型  125
12.4.11 保持模型的活力  125
12.5 和敏捷团队一起建模  125
12.6 检查列表  126
12.7 小结  127
12.8 延伸阅读  127
第13章 创建架构描述  128
13.1 有效架构描述的属性  129
13.1.1 正确  129
13.1.2 充分  129
13.1.3 及时  130
13.1.4 简洁  131
13.1.5 清晰  131
13.1.6 最新  132
13.1.7 精确  133
13.2 词汇表  134
13.3 ISO标准  134
13.4 架构描述的内容  135
13.4.1 文档控制  135
13.4.2 内容表  135
13.4.3 介绍和管理纲要  135
13.4.4 利益相关者  136
13.4.5 通用架构原则  136
13.4.6 架构设计决定  136
13.4.7 视点  136
13.4.8 视图  136
13.4.9 质量属性摘要  137
13.4.10 重要的方案  137
13.4.11 亟待解决的问题  137
13.4.12 附录  138
13.5 展现架构描述  138
13.6 检查列表  139
13.7 小结  140
13.8 延伸阅读  140
第14章 评估架构  141
14.1 为什么要评估架构  141
14.2 评估技术  142
14.2.1 演讲  142
14.2.2 正式评审和结构化的走查  143
14.2.3 通过使用场景来评估  144
14.2.4 原型和概念验证系统  145
14.2.5 骨架系统  146
14.3 基于场景的评估方法  146
14.3.1 以架构为中心的活动  147
14.3.2 以利益相关者为中心的活动  149
14.4 在软件生命周期内评估  150
14.5 验证现存系统的架构  151
14.6 记录评估结果  153
14.7 选择评估方法  154
14.8 检查列表  154
14.9 小结  155
14.10 延伸阅读  155
第三部分 视点类型
第15章 视点类型简介  158
第16章 情境视点  160
16.1 关注点  161
16.1.1 系统范围和责任  161
16.1.2 外部实体和服务以及所用数据的标识  161
16.1.3 外部实体的本质和特征  162
16.1.4 外部接口的标识和职责  162
16.1.5 外部接口的本质和特征  163
16.1.6 其他外部依赖关系  163
16.1.7 对系统环境的影响  164
16.1.8 总体完成度、一致性和连贯性  164
16.1.9 利益相关者的关注点  165
16.2 模型  165
16.2.1 情境模型  165
16.2.2 交互场景  169
16.3 问题和缺陷  169
16.3.1 遗漏或者错误的外部实体  169
16.3.2 遗漏隐藏的依赖关系  169
16.3.3 松散或不精确的接口描述  170
16.3.4 详细程度不合适  170
16.3.5 范围蔓延  170
16.3.6 隐藏或假设的情境和范围  171
16.3.7 过于复杂的交互  171
16.3.8 过度使用术语  171
16.4 检查列表  172
16.5 延伸阅读  172
第17章 功能视点  173
17.1 关注点  173
17.1.1 功能能力  173
17.1.2 外部接口  174
17.1.3 内部结构  174
17.1.4 功能设计哲学  174
17.1.5 利益相关者的关注点  175
17.2 模型  176
17.3 问题和缺陷  184
17.3.1 设计很差的接口  184
17.3.2 难以理解的职责  184
17.3.3 基础架构作为功能性元素  184
17.3.4 过载的视图  185
17.3.5 没有元素定义的图  186
17.3.6 难以调节多位利益相关者的需求  186
17.3.7 错误的详细程度  187
17.3.8 “神元素”  187
17.3.9 过多依赖关系  188
17.4 检查列表  188
17.5 延伸阅读  188
第18章 信息视点  190
18.1 关注点  191
18.1.1 信息结构和内容  191
18.1.2 信息目的和用途  191
18.1.3 信息所有权  192
18.1.4 企业拥有的信息  193
18.1.5 标识符和映射关系  194
18.1.6 信息语义的易变性  195
18.1.7 信息存储模型  196
18.1.8 信息流  197
18.1.9 信息一致性  198
18.1.10 信息质量  199
18.1.11 及时性、延迟和寿命  200
18.1.12 归档和保留信息  201
18.1.13 利益相关者的关注点  201
18.2 模型  202
18.2.1 静态信息结构模型  202
18.2.2 信息流模型  204
18.2.3 信息生命周期模型  206
18.2.4 其他类型的信息模型  207
18.3 问题和陷阱  209
18.3.1 数据展现不兼容  209
18.3.2 不可避免的多个更新器  210
18.3.3 键值匹配缺陷  211
18.3.4 接口复杂  211
18.3.5 过载的中心数据库  212
18.3.6 不一致的分布式数据库  213
18.3.7 信息质量很差  213
18.3.8 信息延迟过大  213
18.3.9 容量不足  214
18.4 检查列表  214
18.5 延伸阅读  215
第19章 并发视点  216
19.1 关注点  217
19.1.1 任务结构  217
19.1.2 功能元素与任务的映射关系  218
19.1.3 进程间通信  218
19.1.4 状态管理  218
19.1.5 同步和整合  218
19.1.6 支持可伸缩性  219
19.1.7 启动和关闭  219
19.1.8 任务故障  219
19.1.9 重入  219
19.1.10 利益相关者的关注点  220
19.2 模型  220
19.2.1 系统级别的并发模型  220
19.2.2 状态模型  225
19.3 问题和缺陷  228
19.3.1 对错误的并发建模  228
19.3.2 错误地对并发建模  228
19.3.3 过度复杂  229
19.3.4 资源竞争  229
19.3.5 死锁  230
19.3.6 竞争条件  230
19.4 检查列表  230
19.5 延伸阅读  231
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件系统架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hadoop技术内幕
前　言
第一部分　基础篇
第1章　阅读源代码前的准备/ 2
1.1　准备源代码学习环境/ 2
1.1.1　基础软件下载/ 2
1.1.2　如何准备Windows环境/ 3
1.1.3　如何准备Linux环境/ 6
1.2　获取Hadoop源代码/ 7
1.3　搭建Hadoop源代码阅读环境/ 8
1.3.1　创建Hadoop工程/ 8
1.3.2　Hadoop源代码阅读技巧/ 9
1.4　Hadoop源代码组织结构/ 10
1.5　Hadoop初体验/ 13
1.5.1　启动Hadoop/ 13
1.5.2　Hadoop Shell介绍/ 15
1.5.3　Hadoop Eclipse插件介绍/ 15
1.6　编译及调试Hadoop源代码/ 19
1.6.1　编译Hadoop源代码/ 19
1.6.2　调试Hadoop源代码/ 20
1.7　小结/ 23
第2章　MapReduce设计理念与基本架构/ 24
2.1　Hadoop发展史/ 24
2.1.1　Hadoop产生背景/ 24
2.1.2　Apache Hadoop新版本的特性/ 25
2.1.3　Hadoop版本变迁/ 26
2.2　Hadoop MapReduce设计目标/ 28
2.3　MapReduce编程模型概述/ 29
2.3.1　MapReduce编程模型简介/ 29
2.3.2　MapReduce编程实例/ 31
2.4　Hadoop基本架构/ 32
2.4.1　HDFS架构/ 33
2.4.2　Hadoop MapReduce架构/ 34
2.5　Hadoop MapReduce作业的生命周期/ 36
2.6　小结/ 38
第二部分　MapReduce编程模型篇
第3章　MapReduce编程模型/ 40
3.1　MapReduce编程模型概述/ 40
3.1.1　MapReduce编程接口体系结构/ 40
3.1.2　新旧MapReduce API比较/ 41
3.2　MapReduce API基本概念/ 42
3.2.1　序列化/ 42
3.2.2　Reporter参数/ 43
3.2.3　回调机制/ 43
3.3　Java API解析/ 44
3.3.1　作业配置与提交/ 44
3.3.2　InputFormat接口的设计与实现/ 48
3.3.3　OutputFormat接口的设计与实现/ 53
3.3.4　Mapper与Reducer解析/ 55
3.3.5　Partitioner接口的设计与实现/ 59
3.4　非Java API解析/ 61
3.4.1　Hadoop Streaming的实现原理/ 61
3.4.2　Hadoop Pipes的实现原理/ 64
3.5　Hadoop工作流/ 67
3.5.1　JobControl的实现原理/ 67
3.5.2　ChainMapper/ChainReducer的实现原理/ 69
3.5.3　Hadoop工作流引擎/ 71
3.6　小结/ 73
第三部分　MapReduce核心设计篇
第4章　Hadoop RPC框架解析/ 76
4.1　Hadoop RPC框架概述/ 76
4.2　Java基础知识/ 77
4.2.1　Java反射机制与动态代理/ 78
4.2.2　Java网络编程/ 80
4.2.3　Java NIO/ 82
4.3　Hadoop RPC基本框架分析/ 89
4.3.1　RPC基本概念/ 89
4.3.2　Hadoop RPC基本框架/ 91
4.3.3　集成其他开源RPC框架/ 98
4.4　MapReduce通信协议分析/ 100
4.4.1　MapReduce 通信协议概述/ 100
4.4.2　JobSubmissionProtocol通信协议/ 102
4.4.3　InterTrackerProtocol通信协议/ 102
4.4.4　TaskUmbilicalProtocol通信协议/ 103
4.4.5　其他通信协议/ 104
4.5　小结/ 106
第5章　作业提交与初始化过程分析/ 107
5.1　作业提交与初始化概述/ 107
5.2　作业提交过程详解/ 108
5.2.1　执行Shell命令/ 108
5.2.2　作业文件上传/ 109
5.2.3　产生InputSplit文件/ 111
5.2.4　作业提交到JobTracker/ 113
5.3　作业初始化过程详解/ 115
5.4　Hadoop DistributedCache原理分析/ 117
5.4.1　使用方法介绍/ 118
5.4.2　工作原理分析/ 120
5.5　小结/ 122
第6章　JobTracker内部实现剖析/ 123
6.1　JobTracker概述/ 123
6.2　JobTracker启动过程分析/ 125
6.2.1　JobTracker启动过程概述/ 125
6.2.2　重要对象初始化/ 125
6.2.3　各种线程功能/ 128
6.2.4　作业恢复/ 129
6.3　心跳接收与应答/ 129
6.3.1　更新状态/ 131
6.3.2　下达命令/ 131
6.4　Job和Task运行时信息维护/ 134
6.4.1　作业描述模型/ 134
6.4.2　JobInProgress/ 136
6.4.3　TaskInProgress/ 137
6.4.4　作业和任务状态转换图/ 139
6.5　容错机制/ 141
6.5.1　JobTracker容错/ 141
6.5.2　TaskTracker容错/ 142
6.5.3　Job/Task容错/ 145
6.5.4　Record容错/ 147
6.5.5　磁盘容错/ 151
6.6　任务推测执行原理/ 152
6.6.1　计算模型假设/ 153
6.6.2　1.0.0版本的算法/ 153
6.6.3　0.21.0版本的算法/ 154
6.6.4　2.0版本的算法/ 156
6.7　Hadoop资源管理/ 157
6.7.1　任务调度框架分析/ 159
6.7.2　任务选择策略分析/ 162
6.7.3　FIFO调度器分析/ 164
6.7.4　Hadoop资源管理优化/ 165
6.8　小结/ 168
第7章　TaskTracker内部实现剖析/ 169
7.1　TaskTracker概述/ 169
7.2　TaskTracker启动过程分析/ 170
7.2.1　重要变量初始化/ 171
7.2.2　重要对象初始化/ 171
7.2.3　连接JobTracker/ 172
7.3　心跳机制/ 172
7.3.1　单次心跳发送/ 172
7.3.2　状态发送/ 175
7.3.3　命令执行/ 178
7.4　TaskTracker行为分析/ 179
7.4.1　启动新任务/ 179
7.4.2　提交任务/ 179
7.4.3　杀死任务/ 181
7.4.4　杀死作业/ 182
7.4.5　重新初始化/ 184
7.5　作业目录管理/ 184
7.6　启动新任务/ 186
7.6.1　任务启动过程分析/ 186
7.6.2　资源隔离机制/ 193
7.7　小结/ 195
第8章　Task运行过程分析/ 196
8.1　Task运行过程概述/ 196
8.2　基本数据结构和算法/ 197
8.2.1　IFile存储格式/ 197
8.2.2　排序/ 198
8.2.3　Reporter/ 201
8.3　Map Task内部实现/ 204
8.3.1　Map Task整体流程/ 204
8.3.2　Collect过程分析/ 205
8.3.3　Spill过程分析/ 213
8.3.4　Combine过程分析/ 214
8.4　Reduce Task内部实现/ 214
8.4.1　Reduce Task整体流程/ 215
8.4.2　Shuffle和Merge阶段分析/ 215
8.4.3　Sort和Reduce阶段分析/ 218
8.5　Map/Reduce Task优化/ 219
8.5.1　参数调优/ 219
8.5.2　系统优化/ 220
8.6　小结/ 224
第四部分　MapReduce高级篇
第9章　Hadoop性能调优/ 228
9.1　概述/ 228
9.2　从管理员角度进行调优/ 229
9.2.1　硬件选择/ 229
9.2.2　操作系统参数调优/ 229
9.2.3　JVM参数调优/ 230
9.2.4　Hadoop参数调优/ 230
9.3　从用户角度进行调优/ 235
9.3.1　应用程序编写规范/ 235
9.3.2　作业级别参数调优/ 235
9.3.3　任务级别参数调优/ 239
9.4　小结/ 240
第10章　Hadoop多用户作业调度器/ 241
10.1　多用户调度器产生背景/ 241
10.2　HOD/ 242
10.2.1　Torque资源管理器/ 242
10.2.2　HOD作业调度/ 243
10.3　Hadoop队列管理机制/ 245
10.4　Capacity Scheduler实现/ 246
10.4.1　Capacity Scheduler功能介绍/ 247
10.4.2　Capacity Scheduler实现/ 249
10.4.3　多层队列调度/ 254
10.5　Fair Scheduler实现/ 255
10.5.1　Fair Scheduler功能介绍/ 255
10.5.2　Fair Scheduler实现/ 258
10.5.3　Fair Scheduler与Capacity Scheduler对比/ 263
10.6　其他Hadoop调度器介绍/ 264
10.7　小结/ 265
第11章　Hadoop安全机制/ 266
11.1　Hadoop安全机制概述/ 266
11.1.1　Hadoop面临的安全问题/ 266
11.1.2　Hadoop对安全方面的需求/ 267
11.1.3　Hadoop安全设计基本原则/ 267
11.2　基础知识/ 268
11.2.1　安全认证机制/ 268
11.2.2　Kerberos介绍/ 270
11.3　Hadoop安全机制实现/ 273
11.3.1　RPC/ 273
11.3.2　HDFS/ 276
11.3.3　MapReduce/ 278
11.3.4　上层服务/ 280
11.4　应用场景总结/ 281
11.4.1　文件存取/ 281
11.4.2　作业提交与运行/ 282
11.4.3　上层中间件访问Hadoop/ 282
11.5　小结/ 283
第12章　下一代MapReduce框架/ 284
12.1　第一代MapReduce框架的局限性/ 284
12.2　下一代MapReduce框架概述/ 284
12.2.1　基本设计思想/ 284
12.2.2　资源统一管理平台/ 286
12.3　Apache YARN/ 287
12.3.1　Apache YARN基本框架/ 287
12.3.2　Apache YARN工作流程/ 290
12.3.3　Apache YARN设计细节/ 291
12.3.4　MapReduce与YARN结合/ 294
12.4　Facebook Corona / 298
12.4.1　Facebook Corona基本框架/ 298
12.4.2　Facebook Corona工作流程/ 300
12.4.3　YARN与Corona对比/ 303
12.5　Apache Mesos/ 304
12.5.1　Apache Mesos基本框架/ 304
12.5.2　Apache Mesos资源分配/ 305
12.5.3　MapReduce与Mesos结合/ 307
12.6　小结/ 309
附录A　安装Hadoop过程中可能存在的问题及解决方案/ 310
附录B　Hadoop默认HTTP端口号以及HTTP地址/ 312
参考资料/ 313
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hadoop技术内幕
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>从零开始学架构
目录
第1部分 概念和基础
第１章 架构基础
1.1 “架构”到底指什么
1.1.1 系统与子系统
1.1.2 模块与组件
1.1.3 框架与架构
1.1.4 重新定义架构
1.2 架构设计的目的
1.2.1 架构设计的误区
1.2.2 以史为鉴
1.2.3 架构设计的真正目的
1.3 复杂度来源
1.3.1 高性能
1.3.2 高可用
1.3.3 可扩展性
1.3.4 低成本
1.3.5 安全
1.3.6 规模
1.4 本章小结
第2章 架构设计原则
2.1 合适原则
2.2 简单原则
2.3 演化原则
2.4 本章小结
第3章 架构设计流程
3.1 有的放矢—识别复杂度
3.2 按图索骥—设计备选方案
3.3 深思熟虑—评估和选择备选方案
3.3.1 业务背景
3.3.2 备选方案设计
3.3.3 备选方案360度环评
3.4 精雕细琢—详细方案设计
3.5 本章小结
第2部分 高性能架构模式
第4章 存储高性能
4.1 关系数据库
4.1.1 读写分离
4.1.2 分库分表
4.1.3 实现方法
4.2 NoSQL
4.2.1 K-V存储
4.2.2 文档数据库
4.2.3 列式数据库
4.2.4 全文搜索引擎
4.3 缓存
4.3.1 缓存穿透
4.3.2 缓存雪崩
4.3.3 缓存热点
4.4 本章小结
第5章 计算高性能
5.1 单服务器高性能
5.1.1 PPC
5.1.2 prefork
5.1.3 TPC
5.1.4 prethread
5.1.5 Reactor
5.1.6 Proactor
5.2 集群高性能
5.2.1 负载均衡分类
5.2.2 负载均衡架构
5.2.3 负载均衡的算法
5.3 本章小结
第3部分 高可用架构模式
第6章 CAP
6.1 CAP理论
6.1.1 一致性（Consistency）
6.1.2 可用性
6.1.3 分区容忍性（Partition Tolerance）
6.2 CAP应用
6.2.1 CP—Consistency/Partition Tolerance
6.2.2 AP—Availability/Partition Tolerance
6.3 CAP细节
6.4 ACID、BASE
6.4.1 ACID
6.4.2 BASE
6.5 本章小结
第7章 FMEA
7.1 FMEA介绍
7.2 FMEA方法
7.3 FMEA实战
7.4 本章小结
第8章 存储高可用
8.1 主备复制
8.1.1 基本实现
8.1.2 优缺点分析
8.2 主从复制
8.2.1 基本实现
8.2.2 优缺点分析
8.3 主备倒换与主从倒换
8.3.1 设计关键
8.3.2 常见架构
8.4 主主复制
8.5 数据集群
8.5.1 数据集中集群
8.5.2 数据分散集群
8.5.3 分布式事务算法
8.5.4 分布式一致性算法
8.6 数据分区
8.6.1 数据量
8.6.2 分区规则
8.6.3 复制规则
8.7 本章小结
第9章 计算高可用
9.1 主备
9.2 主从
9.3 对称集群
9.4 非对称集群
9.5 本章小结
第10章 业务高可用
10.1 异地多活
10.1.1 异地多活架构
10.1.2 异地多活设计技巧
10.1.3 异地多活设计步骤
10.2 接口级的故障应对方案
10.2.1 降级
10.2.2 熔断
10.2.3 限流
10.2.4 排队
10.3 本章小结
第4部分 可扩展架构模式
第11章 可扩展模式
11.1 可扩展概述
11.2 可扩展的基本思想
11.3 可扩展方式
11.4 本章小结
第12章 分层架构
12.1 分层架构类型
12.2 分层架构详解
12.3 本章小结
第13章 SOA架构
13.1 SOA历史
13.2 SOA详解
13.3 本章小结
第14章 微服务
14.1 微服务历史
14.2 微服务与SOA的关系
14.3 微服务的陷阱
14.4 微服务佳实践
14.4.1 服务粒度
14.4.2 拆分方法
14.4.3 基础设施
14.5 本章小结
第15章 微内核架构
15.1 基本概念
15.2 设计关键点
15.3 OSGi架构简析
15.4 规则引擎架构简析
15.5 本章小结
第5部分 架构实战
第16章 消息队列设计实战
16.1 需求
16.2 设计流程
16.2.1 识别复杂度
16.2.2 设计备选方案
16.2.3 评估和选择备选方案
16.2.4 细化方案
16.3 本章小结
第17章 互联网架构演进
17.1 技术演进
17.1.1 技术演进的动力
17.1.2 淘宝
17.1.3 手机QQ
17.1.4 微信
17.2 技术演进的模式
17.3 互联网业务发展
17.3.1 业务复杂性
17.3.2 用户规模
17.3.3 量变到质变
17.4 本章小结
第18章 互联网架构模板
18.1 总体结构
18.2 存储层技术
18.2.1 SQL
18.2.2 NoSQL
18.2.3 小文件存储
18.2.4 大文件存储
18.3 开发层技术
18.3.1 开发框架
18.3.2 Web服务器
18.3.3 容器
18.4 服务层技术
18.4.1 配置中心
18.4.2 服务中心
18.4.3 消息队列
18.5 网络层技术
18.5.1 负载均衡
18.5.2 CDN
18.5.3 多机房
18.5.4 多中心
18.6 用户层技术
18.6.1 用户管理
18.6.2 消息推送
18.6.3 存储云与图片云
18.7 业务层技术
18.8 平台技术
18.8.1 运维平台
18.8.2 测试平台
18.8.3 数据平台
18.8.4 管理平台
18.9 本章小结
第19章 架构重构
19.1 有的放矢
19.2 合纵连横
19.2.1 合纵
19.2.2 连横
19.3 运筹帷幄
19.4 文武双全—项目管理+技术能力
19.5 本章小结
第20章 开源系统
20.1 选：如何选择一个开源项目
20.1.1 聚焦是否满足业务
20.1.2 聚焦是否成熟
20.1.3 聚焦运维能力
20.2 用：如何使用开源方案
20.2.1 深入研究，仔细测试
20.2.2 小心应用，灰度发布
20.2.3 做好应急，以防万一
20.3 改：如何基于开源项目做二次开发
20.3.1 保持纯洁，加以包装
20.3.2 发明你要的轮子
20.4 本章小结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>从零开始学架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>银行信息系统架构
总序
序
前言
第1章银行信息化的发展历程
1.1信息孤岛阶段
1.2互联互通阶段
1.3银行信息化阶段
1.4信息化银行阶段
第2章银行信息系统架构综述
2.1价值与作用
2.2概念与内容
2.2.1通用架构框架
2.2.2我国银行业常用的架构框架
2.2.3应用、数据与技术架构
2.2.4架构管控
2.3总体规划方法
2.3.1架构原则
2.3.2主要阶段
2.3.3关键输入
2.3.4关键输出
2.4新挑战和架构关注点
2.4.1新挑战
2.4.2架构关注点
第3章应用架构
3.1应用架构概述
3.1.1设计原则
3.1.2分层分组
3.1.3应用集成
3.2应用架构规划方法
3.2.1战略解读与差距分析
3.2.2目标架构设计
3.2.3实施路径规划
3.2.4架构设计的关注点
3.3专题领域架构
3.3.1核心银行
3.3.2支付清算
3.3.3电子银行
3.3.4风险管理
3.3.5管理会计
3.3.6服务总线
3.3.7合作互联
3.4领先银行架构实践
3.4.1流程银行
3.4.2产品创新
3.4.3渠道协同
3.4.4应用平台化
3.5典型案例
3.5.1某大型国有商业银行
3.5.2某全国股份制商业银行
3.5.3某区域性银行
3.6新趋势下的应用架构探索
3.6.1移动化
3.6.2大数据
3.6.3互联网金融
第4章数据架构
4.1数据架构概述
4.1.1数据架构内容
4.1.2数据架构对其他架构的影响
4.2数据架构规划
4.2.1数据架构设计原则
4.2.2数据架构规划方法
4.2.3架构设计的关注点
4.3数据架构设计
4.3.1数据产生
4.3.2数据流转
4.3.3数据传输
4.3.4数据整合
4.3.5数据应用
4.3.6数据归档
4.4典型案例
4.4.1某大型国有商业银行
4.4.2某全国股份制商业银行
4.5新趋势下数据架构探索
4.5.1数据产生层
4.5.2数据整合层
4.5.3数据应用层
4.5.4新的数据处理技术
第5章技术架构
5.1技术架构概述
5.1.1技术架构的内容
5.1.2CAP原理
5.1.3银行IT系统分类
5.2技术架构设计方法
5.2.1IT技术架构的设计框架
5.2.2银行IT非功能性需求
5.3网络架构
5.3.1网络架构设计的原则及方法
5.3.2数据中心网络架构
5.3.3各地局域网络架构
5.3.4城域与广域网络架构
5.3.5网络安全架构
5.3.6架构设计关注点
5.4计算架构
5.4.1架构设计基本原则
5.4.2架构整体设计
5.4.3架构评估与测试方法
5.4.4服务器技术概览
5.4.5第一类系统计算架构设计
5.4.6第二类系统计算架构设计
5.4.7第三类系统计算架构设计
5.4.8架构设计关注点
5.5存储架构
5.5.1存储架构设计基本原则
5.5.2存储整体架构分类及设计方法
5.5.3第一类系统存储架构设计
5.5.4第二类系统存储架构设计
5.5.5第三类系统存储架构设计
5.5.6SAN网络架构
5.5.7统一数据备份
5.5.8架构设计关注点
5.6基础软件
5.6.1操作系统
5.6.2中间件
5.6.3数据库
5.6.4大数据平台
5.7分布式架构
5.7.1分布式架构体系
5.7.2分布式文件系统
5.7.3分布式计算框架
5.7.4分布式数据库
5.7.5分布式缓存
5.7.6分布式协作服务
5.7.7资源管理和调度
5.7.8分布式监控管理与分布式序列化
5.7.9分布式交易系统架构实践
5.8灾备技术架构
5.8.1灾备建设工作要求
5.8.2灾备中心布局模式
5.8.3灾备技术设计
5.8.4双活数据中心
5.9典型案例
5.9.1某大型国有商业银行
5.9.2某中小型商业银行
5.10技术架构发展趋势
5.10.1软件定义环境
5.10.2下一代数据中心
5.10.3未来云的生态模式
第6章信息系统架构管控
6.1架构管控概念与框架
6.1.1管控含义
6.1.2架构管控概念和价值
6.1.3架构管控框架
6.2架构管控流程
6.2.1架构设计与评审流程
6.2.2架构更新与维护流程
6.2.3架构遵从流程
6.2.4架构例外处理流程
6.3架构管控团队
6.3.1典型架构管控团队
6.3.2架构委员会
6.4架构管控工具
6.4.1架构管控工具概述
6.4.2架构工具市场分析
6.4.3银行引入架构工具
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>银行信息系统架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务架构设计模式
目　　录
写给中文版读者的话
译者序
中文版序一
中文版序二
前言
引言
第1章　逃离单体地狱   / 1
1.1　迈向单体地狱的漫长旅程   / 2
1.1.1　FTGO应用程序的架构   / 3
1.1.2　单体架构的好处   / 4
1.1.3　什么是单体地狱   / 4
1.2　为什么本书与你有关   / 7
1.3　你会在本书中学到什么   / 8
1.4　拯救之道：微服务架构   / 8
1.4.1　扩展立方体和服务   / 9
1.4.2　微服务架构作为模块化的一种形式   / 11
1.4.3　每个服务都拥有自己的数据库   / 12
1.4.4　FTGO的微服务架构   / 12
1.4.5　微服务架构与SOA的异同   / 14
1.5　微服务架构的好处和弊端   / 15
1.5.1　微服务架构的好处   / 15
1.5.2　微服务架构的弊端   / 17
1.6　微服务架构的模式语言   / 19
1.6.1　微服务架构并不是“银弹”   / 20
1.6.2　模式和模式语言   / 21
1.6.3　微服务架构的模式语言概述   / 24
1.7　微服务之上：流程和组织   / 29
1.7.1　进行软件开发和交付的组织   / 30
1.7.2　进行软件开发和交付的流程   / 31
1.7.3　采用微服务架构时的人为因素   / 32
第2章　服务的拆分策略   / 34
2.1　微服务架构到底是什么   / 35
2.1.1　软件架构是什么，为什么它如此重要   / 35
2.1.2　什么是架构的风格   / 37
2.1.3　微服务架构是一种架构风格   / 40
2.2　为应用程序定义微服务架构   / 43
2.2.1　识别系统操作   / 45
2.2.2　根据业务能力进行服务拆分   / 50
2.2.3　根据子域进行服务拆分   / 53
2.2.4　拆分的指导原则   / 54
2.2.5　拆分单体应用为服务的难点   / 56
2.2.6　定义服务API   / 59
第3章　微服务架构中的进程间通信   / 63
3.1　微服务架构中的进程间通信概述   / 64
3.1.1　交互方式   / 64
3.1.2　在微服务架构中定义API   / 66
3.1.3　API的演化   / 67
3.1.4　消息的格式   / 69
3.2　基于同步远程过程调用模式的通信   / 70
3.2.1　使用REST   / 71
3.2.2　使用gRPC   / 74
3.2.3　使用断路器模式处理局部故障   / 75
3.2.4　使用服务发现   / 78
3.3　基于异步消息模式的通信   / 82
3.3.1　什么是消息传递   / 83
3.3.2　使用消息机制实现交互方式   / 84
3.3.3　为基于消息机制的服务API创建API规范   / 86
3.3.4　使用消息代理   / 87
3.3.5　处理并发和消息顺序   / 91
3.3.6　处理重复消息   / 92
3.3.7　事务性消息   / 93
3.3.8　消息相关的类库和框架   / 97
3.4　使用异步消息提高可用性   / 99
3.4.1　同步消息会降低可用性   / 99
3.4.2　消除同步交互   / 101
第4章　使用Saga管理事务　   / 106
4.1　微服务架构下的事务管理   / 107
4.1.1　微服务架构对分布式事务的需求   / 108
4.1.2　分布式事务的挑战   / 109
4.1.3　使用Saga模式维护数据一致性   / 109
4.2　Saga的协调模式   / 113
4.2.1　协同式Saga   / 113
4.2.2　编排式Saga   / 117
4.3　解决隔离问题   / 121
4.3.1　缺乏隔离导致的问题   / 122
4.3.2　Saga模式下实现隔离的对策   / 123
4.4　Order Service和Create Order Saga的设计   / 127
4.4.1　OrderService类   / 128
4.4.2　Create Order Saga的实现   / 129
4.4.3　OrderCommandHandlers类   / 136
4.4.4　OrderServiceConfiguration类   / 138
第5章　微服务架构中的业务逻辑设计   / 141
5.1　业务逻辑组织模式   / 142
5.1.1　使用事务脚本模式设计业务逻辑   / 143
5.1.2　使用领域模型模式设计业务逻辑   / 144
5.1.3　关于领域驱动设计   / 146
5.2　使用聚合模式设计领域模型   / 146
5.2.1　模糊边界所带来的问题   / 147
5.2.2　聚合拥有明确的边界   / 149
5.2.3　聚合的规则   / 150
5.2.4　聚合的颗粒度   / 152
5.2.5　使用聚合设计业务逻辑   / 153
5.3　发布领域事件   / 154
5.3.1　为什么需要发布变更事件   / 154
5.3.2　什么是领域事件   / 155
5.3.3　事件增强   / 155
5.3.4　识别领域事件   / 156
5.3.5　生成和发布领域事件   / 157
5.3.6　消费领域事件   / 161
5.4　Kitchen Service的业务逻辑   / 162
5.5　Order Service的业务逻辑   / 167
5.5.1　Order聚合   / 169
5.5.2　 OrderService类   / 173
第6章　使用事件溯源开发业务逻辑   / 176
6.1　使用事件溯源开发业务逻辑概述   / 177
6.1.1　传统持久化技术的问题   / 177
6.1.2　什么是事件溯源   / 179
6.1.3　使用乐观锁处理并发更新   / 186
6.1.4　事件溯源和发布事件   / 186
6.1.5　使用快照提升性能   / 188
6.1.6　幂等方式的消息处理   / 189
6.1.7　领域事件的演化   / 190
6.1.8　事件溯源的好处   / 192
6.1.9　事件溯源的弊端   / 193
6.2　实现事件存储库   / 194
6.2.1　Eventuate Local事件存储库的工作原理   / 195
6.2.2　Eventuate的Java客户端框架   / 198
6.3　同时使用Saga和事件溯源   / 201
6.3.1　使用事件溯源实现协同式Saga   / 203
6.3.2　创建编排式Saga   / 203
6.3.3　实现基于事件溯源的Saga参与方   / 205
6.3.4　实现基于事件溯源的Saga编排器   / 208
第7章　在微服务架构中实现查询   / 212
7.1　使用API组合模式进行查询   / 213
7.1.1　findOrder()查询操作   / 213
7.1.2　什么是API组合模式   / 214
7.1.3　使用API组合模式实现findOrder()查询操作   / 215
7.1.4　API组合模式的设计缺陷   / 216
7.1.5　API组合模式的好处和弊端   / 219
7.2　使用CQRS模式   / 220
7.2.1　为什么要使用CQRS   / 220
7.2.2　什么是CQRS   / 223
7.2.3　CQRS的好处   / 226
7.2.4　CQRS的弊端   / 227
7.3　设计CQRS视图   / 228
7.3.1　选择视图存储库   / 229
7.3.2　设计数据访问模块   / 230
7.3.3　添加和更新CQRS视图   / 232
7.4　实现基于AWS DynamoDB的CQRS视图   / 233
7.4.1　OrderHistoryEventHandlers模块   / 234
7.4.2　DynamoDB中的数据建模和查询设计   / 235
7.4.3　OrderHistoryDaoDynamoDb类   / 239
第8章　外部API模式   / 244
8.1　外部API的设计难题   / 245
8.1.1　FTGO移动客户端API的设计难题   / 246
8.1.2　其他类型客户端API的设计难题   / 248
8.2　API Gateway模式   / 250
8.2.1　什么是API Gateway模式   / 250
8.2.2　API Gateway模式的好处和弊端   / 256
8.2.3　以Netflix为例的API Gateway   / 257
8.2.4　API Gateway的设计难题   / 258
8.3　实现一个API Gateway   / 260
8.3.1　使用现成的API Gateway产品或服务   / 261
8.3.2　开发自己的API Gateway   / 262
8.3.3　使用GraphQL实现API Gateway   / 269
第9章　微服务架构中的测试策略（上）   / 282
9.1　微服务架构中的测试策略概述   / 284
9.1.1　什么是测试   / 284
9.1.2　微服务架构中的测试挑战   / 289
9.1.3　部署流水线   / 295
9.2　为服务编写单元测试   / 296
9.2.1　为实体编写单元测试   / 298
9.2.2　为值对象编写单元测试   / 299
9.2.3　为Saga编写单元测试   / 300
9.2.4　为领域服务编写单元测试   / 302
9.2.5　为控制器编写单元测试   / 303
9.2.6　为事件和消息处理程序编写单元测试   / 305
第10章　微服务架构中的测试策略（下）   / 308
10.1　编写集成测试   / 308
10.1.1　针对持久化层的集成测试   / 311
10.1.2　针对基于REST的请求/响应式交互的集成测试   / 312
10.1.3　针对发布/订阅式交互的集成测试   / 316
10.1.4　针对异步请求/响应式交互的集成契约测试   / 320
10.2　编写组件测试   / 324
10.2.1　定义验收测试   / 325
10.2.2　使用Gherkin编写验收测试   / 326
10.2.3　设计组件测试   / 328
10.2.4　为FTGO的Order Service编写组件测试   / 330
10.3　端到端测试   / 334
10.3.1　设计端到端测试   / 335
10.3.2　编写端到端测试   / 335
10.3.3　运行端到端测试   / 336
第11章　开发面向生产环境的微服务应用   / 338
11.1　开发安全的服务   / 339
11.1.1　传统单体应用程序的安全性   / 340
11.1.2　在微服务架构中实现安全性   / 343
11.2　设计可配置的服务   / 349
11.2.1　使用基于推送的外部化配置   / 350
11.2.2　使用基于拉取的外部化配置   / 352
11.3　设计可观测的服务   / 353
11.3.1　使用健康检查API模式   / 355
11.3.2　使用日志聚合模式   / 357
11.3.3　使用分布式追踪模式   / 358
11.3.4　使用应用程序指标模式   / 361
11.3.5　使用异常追踪模式   / 364
11.3.6　使用审计日志模式   / 365
11.4　使用微服务基底模式开发服务   / 367
11.4.1　使用微服务基底   / 368
11.4.2　从微服务基底到服务网格   / 368
第12章　部署微服务应用   / 371
12.1　部署模式：编程语言特定的发布包格式   / 374
12.1.1　使用编程语言特定的发布包格式进行部署的好处   / 376
12.1.2　使用编程语言特定的发布包格式进行部署的弊端   / 377
12.2　部署模式：将服务部署为虚拟机   / 378
12.2.1　将服务部署为虚拟机的好处   / 380
12.2.2　将服务部署为虚拟机的弊端   / 380
12.3　部署模式：将服务部署为容器   / 381
12.3.1　使用Docker部署服务   / 383
12.3.2　将服务部署为容器的好处   / 385
12.3.3　将服务部署为容器的弊端   / 386
12.4　使用Kubernetes部署FTGO应用程序   / 386
12.4.1　什么是Kubernetes   / 386
12.4.2　在Kubernetes上部署Restaurant Service   / 389
12.4.3　部署API Gateway   / 392
12.4.4　零停机部署   / 393
12.4.5　使用服务网格分隔部署与发布流程   / 394
12.5　部署模式：Serverless部署   / 402
12.5.1　使用AWS Lambda进行Serverless部署   / 403
12.5.2　开发Lambda函数   / 404
12.5.3　调用Lambda函数   / 404
12.5.4　使用Lambda函数的好处   / 405
12.5.5　使用Lambda函数的弊端   / 406
12.6　使用AWS Lambda和AWS Gateway部署RESTful服务   / 406
12.6.1　AWS Lambda版本的Restaurant Service   / 407
12.6.2　把服务打包为ZIP文件   / 411
12.6.3　使用Serverless框架部署Lambda函数   / 412
第13章　微服务架构的重构策略   / 415
13.1　重构到微服务需要考虑的问题   / 416
13.1.1　为什么要重构单体应用   / 416
13.1.2　绞杀单体应用   / 417
13.2　将单体应用重构为微服务架构的若干策略   / 420
13.2.1　将新功能实现为服务   / 420
13.2.2　隔离表现层与后端   / 422
13.2.3　提取业务能力到服务中   / 423
13.3　设计服务与单体的协作方式   / 429
13.3.1　设计集成胶水   / 430
13.3.2　在服务和单体之间维持数据一致性   / 434
13.3.3　处理身份验证和访问授权   / 438
13.4　将新功能实现为服务：处理错误配送订单   / 440
13.4.1　Delayed Delivery Service的设计   / 441
13.4.2　为Delayed Delivery Service设计集成胶水   / 442
13.5　从单体中提取送餐管理功能   / 444
13.5.1　现有的送餐管理功能   / 444
13.5.2　Delivery Service概览   / 446
13.5.3　设计Delivery Service的领域模型   / 447
13.5.4　Delivery Service集成胶水的设计   / 450
13.5.5　修改FTGO单体使其能够与Delivery Service交互   / 451
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务架构设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>REST实战
序言
前言
第1章 将web作为建造分布式系统的平台
web的架构
从资源的角度思考
从web架构到rest架构风格
web作为一个应用平台
web的友好性和richardson的成熟度模型
起航
第2章 介绍restbucks：如何以web风格获得一杯咖啡
restbucks：一家有着全球抱负的小咖啡店
web现身了
第3章 基础的web集成
减肥的感觉真好!
一个简单的咖啡订购系统
uri模板
uri隧道技术
pox：基于http之上的普通老式xml
开始行动
第4章 cruo式web服务
将orde，(订单)建模为资源
建造crud式服务
消费crud式服务
通过wadl自动消费服务
crud虽好，但还可以更好
第5章 超媒体服务
超媒体原则
超媒体格式
契约
超媒体协议
实现超媒体服务
用java建造订购服务
在．net中建造订购服务
ready、set和action
第6章 向外扩展
回到基础
创建可缓存的内容
在．net中实现缓存
保持新鲜
第7章 atom联合格式
格式
将atom用于事件驱动系统
用java建造atom服务
在．net中创建atom服务
atom无处不在?
反思
第8章 atom发布协议
atom发布协议
使用atompub实现订单履行
在．net中实现atompub
一个多功能的协议
第9章 web安全
http安全要点
身份标识和openid协议
oauth协议
服务的黑客攻击和防御
最后的思考
第10章 语义
语法vs．语义
信息的结构和表述
语义网
微格式
链接数据和web
指导
第11章 web和ws-*协议栈
webservices是邪恶的？
soap：全部真相
wsdl：不过是另一种对象接口定义语言(object idl)
两个错误叠加无法得到正确结果
安全的，可靠的，事务性的
webservices的安魂曲?
第12章 为web建造案例
更多的银弹是不存在的
建造并运行基于web的服务
没有度量就没有架构
推销web
出发去建造
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>REST实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>App研发录：架构设计、Crash分析和竞品技术分析
Contents?目    录
序一
序二
序三
前言
第一部分  高效App框架设计与重构
第1章  重构，夜未眠  3
1.1  重新规划Android项目结构  3
1.2  为Activity定义新的生命周期  5
1.3  统一事件编程模型  7
1.4  实体化编程  9
1.4.1  在网络请求中使用实体  9
1.4.2  实体生成器  11
1.4.3  在页面跳转中使用实体  12
1.5  Adapter模板  14
1.6  类型安全转换函数  16
1.7  本章小结  17
第2章  Android网络底层框架设计  19
2.1  网络低层封装  19
2.1.1  网络请求的格式  19
2.1.2  AsyncTask的使用和缺点  21
2.1.3  使用原生的ThreadPoolExecutor + Runnable + Handler  24
2.1.4  网络底层的一些优化工作  28
2.2  App数据缓存设计  32
2.2.1  数据缓存策略  32
2.2.2  强制更新  35
2.3  MockService  36
2.4  用户登录  38
2.4.1  登录成功后的各种场景  39
2.4.2  自动登录  41
2.4.3  Cookie过期的统一处理  44
2.4.4  防止黑客刷库  45
2.5  HTTP头中的奥妙  46
2.5.1  HTTP请求  46
2.5.2  时间校准  48
2.5.3  开启gzip压缩  51
2.6  本章小结  52
第3章  Android经典场景设计  53
3.1  App图片缓存设计  53
3.1.1  ImageLoader设计原理  53
3.1.2  ImageLoader的使用  54
3.1.3  ImageLoader优化  55
3.1.4  图片加载利器Fresco  56
3.2  对网络流量进行优化  58
3.2.1  通信层面的优化  58
3.2.2  图片策略优化  59
3.3  城市列表的设计  61
3.3.1  城市列表数据  61
3.3.2  城市列表数据的增量更新机制  63
3.4  App与HTML5的交互  64
3.4.1  App操作HTML5页面的方法  64
3.4.2  HTML5页面操作App页面的方法  65
3.4.3  App和HTML5之间定义跳转协议  66
3.4.4  在App中内置HTML5页面  67
3.4.5  灵活切换Native和HTML5页面的策略  68
3.4.6  页面分发器  68
3.5  消灭全局变量  70
3.5.1  问题的发现  70
3.5.2  把数据作为Intent的参数传递  71
3.5.3  把全局变量序列化到本地  71
3.5.4  序列化的缺点  75
3.5.5  如果Activity也被销毁了呢  79
3.5.6  如何看待SharedPreferences  80
3.5.7  User是唯一例外的全局变量  80
3.6  本章小结  81
第4章  Android命名规范和编码规范  83
4.1  Android命名规范  83
4.2  Android编码规范  86
4.3  统一代码格式  89
4.4  本章小结  90
第二部分  App开发中的高级技巧
第5章  Crash异常收集与统计  93
5.1  异常收集  93
5.2  异常收集与统计  96
5.2.1  人工统计线上Crash数据  96
5.2.2  第一个线上Crash报表：Crash分类  97
5.2.3  第二个线上Crash报表：Crash去重  99
5.2.4  线上Crash的其他分析工作  104
5.3  本章小结  105
第6章  Crash异常分析  107
6.1  Java语法相关的异常  108
6.1.1  空指针  108
6.1.2  角标越界  109
6.1.3  试图调用一个空对象的方法  110
6.1.4  类型转换异常  110
6.1.5  数字转换错误  111
6.1.6  声明数组时长度为-1  111
6.1.7  遍历集合同时删除其中元素  112
6.1.8  比较器使用不当  114
6.1.9  当除数为0  115
6.1.10  不能随便使用的asList  116
6.1.11  又有类找不到了（一）：ClassNotFoundException  116
6.1.12  又有类找不到了（二）：NoClassDefFoundError  117
6.2  Activity相关的异常  117
6.2.1  找不到Activity  117
6.2.2  不能实例化Activity  118
6.2.3  找不到Service  118
6.2.4  不能启动BroadcastReceiver  119
6.2.5  startActivityForResult不能回传  119
6.2.6  猴急的Fragment  120
6.3  序列化相关的异常  120
6.3.1  实体对象不支持序列化  121
6.3.2  序列化时未指定ClassLoader  121
6.3.3  反序列化时发现类找不到：被ProGuard混淆导致的崩溃  122
6.3.4  反序列化时发现类找不到：传入畸形数据  123
6.3.5  反序列化时出错  123
6.4  列表相关的异常  123
6.4.1  Adapter数据源变化但是没通知ListView  124
6.4.2  ListView滚动时点击刷新按钮后崩溃  125
6.4.3  AbsListView的obtainView返回空指针  125
6.4.4  Adapter数据源变化但是没调用notifyDataSetChanged  126
6.5  窗体相关的异常  126
6.5.1  窗口句柄泄露  126
6.5.2  View not attached to window manager  128
6.5.3  窗体在不恰当的时候获取了焦点  129
6.5.4  token null is not for an application  130
6.5.5  permission denied for this window type  131
6.5.6  is your activity running  131
6.5.7  添加窗体失败  133
6.5.8  AlertDialog.resolveDialogTheme  134
6.5.9  The specif?ied child already has a parent  136
6.5.10  子线程不能修改UI  137
6.5.11  不能在子线程操作AlertDialog和Toast  141
6.6  资源相关的异常  143
6.6.1  Resources$NotFoundException  143
6.6.2  StackOverf?iowError  144
6.6.3  Unsatisf?iedLinkError  144
6.6.4  Inf?iateException之FileNotFoundException  145
6.6.5  Inf?iateException之缺少构造器  145
6.6.6  Inf?iateException之style与android:textStyle的区别  146
6.6.7  TransactionTooLargeException  147
6.7  系统碎片化相关的异常  147
6.7.1  NoSuchMethodError  147
6.7.2  RemoteViews  148
6.7.3  pointerIndex out of range  149
6.7.4  SecurityException之一：Intent中图片太大  150
6.7.5  SecurityException之二：动态加载其他apk的activity  151
6.7.6  SecurityException之三：No permission to modify thread  151
6.7.7  view的getDrawingCache()返回null  152
6.7.8  DeadObjectException  153
6.7.9  Android 2.1不支持SSL  153
6.7.10  ViewFlipper引发的血案  153
6.7.11  ActivityNotFoundException  154
6.7.12  Android 2.2不支持xlargeScreens  154
6.7.13  Package manager has died  155
6.7.14  SpannableString与富文本字符串  155
6.7.15  Can not perform this action after onSaveInstanceState  156
6.7.16  Service Intent must be explicit  157
6.8  SQLite相关的异常  157
6.8.1  No transaction is active  158
6.8.2  忘记关闭Cursor  158
6.8.3  数据库被锁定  159
6.8.4  试图再打开已经关闭的对象  159
6.8.5  文件加密了或无数据库  159
6.8.6  WebView中SQLLite缓存导致的崩溃  160
6.8.7  磁盘读写错误  161
6.8.8  android_metadata表不存在  161
6.8.9  android_metadata表中的locale字段  162
6.8.10  数据库或磁盘满了  162
6.9  不明觉厉的异常  162
6.9.1  内存溢出  163
6.9.2  Verify Failed  163
6.10  其他情况的异常  163
6.10.1  TimeoutException  164
6.10.2  JSON解析异常  164
6.10.3  JSONArray在初始化时为空  164
6.10.4  第三方SDK抛出的Crash  165
6.10.5  两个不同类型的View有相同的id  165
6.10.6  LayoutInf?iater.from().inf?iate()使用不当导致的崩溃  166
6.10.7  ViewGroup中的玄机  166
6.10.8  Monkey点击过快导致的崩溃  167
6.10.9  图片缩放很多倍  168
6.10.10  图片宽高为0  168
6.10.11  不能重复添加组件  168
6.11  本章小结  169
第7章  ProGuard技术详解  171
7.1  ProGuard简介  171
7.2  ProGuard工作原理  172
7.3  如何写一个ProGuard文件  172
7.3.1  基本混淆  172
7.3.2  针对App的量身定制  175
7.3.3  针对第三方jar包的解决方案  177
7.4  其他注意事项  178
7.5  本章小结  179
第8章  持续集成  181
8.1  版本管理策略  181
8.1.1  三种版本管理策略  181
8.1.2  特殊情况的版本管理策略  183
8.2  使用Ant脚本打包  184
8.2.1  Android打包流程  184
8.2.2  打包时的注意事项  189
8.3  Monkey包的生成  190
8.4  自动打包  191
8.4.1  安装和配置各种软件  192
8.4.2  准备Ant打包脚本  193
8.4.3  配置CCNET  193
8.4.4  搭建IIS站点下载apk包  193
8.4.5  自动打包流程小结  193
8.5  批量打渠道包  194
8.5.1  基于apk包批量生成渠道包  194
8.5.2  基于代码批量生成渠道包  195
8.6  Android发版流程  197
8.7  分类打渠道包  198
8.7.1  分门别类生成渠道包  198
8.7.2  批量上传apk的两种方式  199
8.8  灵活切换服务器  199
8.9  单元测试  201
8.10  本章小结  203
第9章  App竞品技术分析  205
9.1  竞品分析概述  205
9.1.1  App竞品定义  205
9.1.2  竞品分析要研究的几个方向  206
9.1.3  竞品分析与拿来主义  206
9.2  App安装包的结构  207
9.2.1  Android安装包的结构  207
9.2.2  iOS安装包的结构  208
9.3  竞品技术一瞥：开机速度  208
9.4  竞品技术二瞥：HTML5页面的打开速度  209
9.4.1  把HTML5页面嵌入到Zip包中  209
9.4.2  Zip包的增量更新机制  209
9.4.3  制作Zip增量包  210
9.4.4  使用WebView预先加载HTML5并缓存到本地  211
9.5  竞品技术三瞥：安装包的大小  211
9.5.1  从几件小事说起  211
9.5.2  安装包为什么那么大  212
9.5.3  png和jpg的区别及使用场景  212
9.5.4  Splash、引导图和背景图  213
9.5.5  iOS的1倍图、2倍图和3倍图  213
9.5.6  在iOS中进行图片拉伸和旋转  214
9.5.7  使用XML配置动画  214
9.5.8  iOS使用storyboard还是xib  215
9.5.9  字体文件的学问  215
9.5.10  表情图片打包下载  217
9.5.11  清除未使用图片  218
9.5.12  Proguard不只是用来混淆的  218
9.5.13  在iOS中使用pdf格式的图片  218
9.5.14  iOS的包永远比Android包体积大吗  219
9.5.15  从代码层面减少iOS包的体积  220
9.6  竞品技术四瞥：性能优化  220
9.6.1  App自动选取最佳服务器的策略  220
9.6.2  使用TCP+Protobuf  222
9.7  竞品技术五瞥：数据采集工具  223
9.7.1  页面跳转器  223
9.7.2  打点统计  226
9.7.3  ABTest  230
9.8  竞品技术六瞥：热修补  232
9.8.1  Native页面和HTML5页面的相互切换  232
9.8.2  在iOS中使用脚本编程  233
9.9  竞品技术七瞥：曲径通幽  237
9.9.1  一切皆可配置  237
9.9.2  App后门  238
9.9.3  Android包中META-INF目录的妙用  239
9.9.4  classes.dex的拆与合  241
9.10  竞品技术八瞥：模块化拆分  242
9.10.1  iOS资源拆分与模块化  242
9.10.2  Android模块化拆分  243
9.11  竞品技术九瞥：第三方SDK  244
9.11.1  HTML5篇  244
9.11.2  iOS篇  245
9.11.3  Android篇  245
9.11.4  其他  246
9.12  竞品技术十瞥：版本策略与App彩蛋  246
9.12.1  版本策略  246
9.12.2  App彩蛋  246
9.13  本章小结  247
第三部分  项目管理和团队建设
第10章  项目管理决定了开发速度  251
10.1  项目管理中的三驾马车  251
10.1.1  为什么不能没有测试团队  252
10.1.2  产品经理应做的事  253
10.1.3  开发人员的喜怒哀乐  254
10.1.4  项目经理的职责  254
10.2  优化团队结构，让敏捷流程跑得更快  255
10.2.1  平行模式还是垂直模式  255
10.2.2  让HTML5站点和MobileAPI的进度提前一个迭代  256
10.2.3  如何进行模块化分工  256
10.3  App敏捷开发流程  257
10.3.1  四周时间的开发流程  257
10.3.2  两周时间的开发流程  261
10.3.3  一周时间的开发流程  262
10.3.4  即时更新策略  263
10.4  项目经理的百宝箱  263
10.4.1  项目经理的任务评估表  263
10.4.2  贴小纸条的艺术  264
10.4.3  敏捷迭代中的会议纪要  265
10.4.4  开站例会的技巧  266
10.4.5  如何确保项目不延期  268
10.4.6  迭代风险管理  268
10.5  迭代中的测试工作  269
10.5.1  冒烟测试  269
10.5.2  探索性测试  271
10.5.3  Monkey测试  271
10.6  高层对敏捷流程的干预  272
10.6.1  重构与产品需求的平衡  272
10.6.2  提高效率，拒绝6×12  273
10.6.3  无线部门的座位安排  274
10.6.4  静时  276
10.7  本章小结  277
第11章  日常工作中的问题解决  279
11.1  使用二分法排查问题  279
11.2  找到能稳定重现问题的人  281
11.3  小流量包  282
11.4  建立全国范围的测试群  283
11.5  如何与用户沟通  284
11.6  日志与App性能  286
11.7  从新人入职作业入手  286
11.8  本章小结  287
第12章  无线团队的组建和管理  289
12.1  从面试谈起  289
12.1.1  如今是卖方市场  289
12.1.2  名校论不适用无线开发  290
12.1.3  如何搞到更多的简历  290
12.1.4  面试时需要考察的几个点  291
12.2  无线团队必备的10份文档  292
12.2.1  新员工入职文档  292
12.2.2  加强版新员工入职文档  292
12.2.3  测试机清单  293
12.2.4  模块分工表  293
12.2.5  页面逻辑流程文档  293
12.2.6  MobileAPI接口分布图  295
12.2.7  版本管理策略文档  295
12.2.8  框架设计文档  295
12.2.9  发版流程文档  296
12.2.10  App启动流程图  296
12.3  一对一沟通  297
12.4  每周技术分享  298
12.5  代码评审  299
12.6  对Android团队Leader的定位  300
12.7  Android应用开发所需技能自我评测  301
12.8  App开发人员的学习路线  302
12.9  本章小结  303
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>App研发录：架构设计、Crash分析和竞品技术分析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>前端架构：从入门到微前端
第1章  前端架构	1
1.1  为什么需要软件架构	2
1.1.1  什么是软件架构	2
1.1.2  开发人员需要怎样的软件架构	3
1.2  架构的设计	4
1.2.1  收集架构需求	5
1.2.2  架构模式	10
1.2.3  架构设计方法	11
1.2.4  生成架构产出物	15
1.3  架构设计原则	16
1.3.1  不多也不少	16
1.3.2  演进式	17
1.3.3  持续性	19
1.4  前端架构发展史	20
1.5  前端架构设计：层次设计	21
1.5.1  系统内架构	22
1.5.2  应用级架构	23
1.5.3  模块级架构	24
1.5.4  代码级：规范与原则	25
1.6  小结	25
第2章  项目中的技术架构实施	27
2.1  技术负责人与架构	28
2.2  技术准备期：探索技术架构	30
2.2.1  架构设计	30
2.2.2  概念验证：架构的原型证明	30
2.2.3  迭代0：搭建完整环境	31
2.2.4  示例项目代码：体现规范与原则	32
2.3  业务回补期：应对第一次Deadline	33
2.3.1  追补业务	33
2.3.2  测试：实践测试策略	34
2.3.3  上线准备	35
2.3.4  第一次部署：验证部署架构	35
2.3.5  提升团队能力	36
2.4  成长优化期：技术债务与演进	39
2.4.1  偿还技术债务	40
2.4.2  优化开发体验	41
2.4.3  带来技术挑战	41
2.4.4  架构完善及演进	42
2.5  小结	43
第3章  架构基础：工作流设计	44
3.1  代码之旅：基础规范	45
3.2  代码组织决定应用架构	47
3.3  统一代码风格，避免架构腐烂	49
3.4  使用Lint规范代码	50
3.5  规范化命名，提升可读性	51
3.5.1  命名法	51
3.5.2  CSS及其预处理器命名规则	52
3.5.3  组件命名规则	53
3.6  规范开发工具，提升开发效率	54
3.7  项目的文档化：README搭建指南	55
3.8  绘制架构图：减少沟通成本	56
3.8.1  代码生成	56
3.8.2  专业工具	57
3.8.3  软件附带工具	57
3.8.4  在线工具	58
3.9  可编辑文档库：提升协作性	59
3.10  记录架构决策：轻量级架构决策记录	59
3.11  可视化文档：注重代码的可读性	60
3.12  看板工具：统一管理业务知识	62
3.13  提交信息：每次代码提交文档化	63
3.13.1  项目方式	63
3.13.2  开源项目方式	64
3.13.3  对比不同文档方式	65
3.14  通过流程化提高代码质量	66
3.14.1  代码预处理	67
3.14.2  手动检视代码	69
3.15  使用工具提升代码质量	70
3.15.1  代码扫描工具	70
3.15.2  IDE 快速重构	71
3.16  测试策略	72
3.16.1  单元测试	73
3.16.2  组件测试	75
3.16.3  契约/接口测试	76
3.17  小结	77
第4章  架构基础：设计构建流	78
4.1  依赖管理工具	81
4.2  软件包源管理	83
4.3  前端代码的打包	88
4.4  设计构建流	89
4.5  持续交付问题	99
4.6  小结	105
第5章  架构设计：多页面应用	107
5.1  为什么不需要单页面应用	108
5.1.1  构建成本	108
5.1.2  学习成本	109
5.1.3  后台渲染成本	110
5.1.4  应用架构的复杂性	111
5.2  简单多页面应用的开发	112
5.2.1  选择UI库及框架	113
5.2.2  jQuery和Bootstrap仍然好用	113
5.2.3  不使用框架：You Don’t Need xxx	114
5.3  复杂多页面应用的开发	115
5.3.1  模板与模板引擎原理	115
5.3.2  基于字符串的模板引擎设计	116
5.3.3  基于JavaScript的模板引擎设计	117
5.3.4  双向绑定原理及实践	120
5.3.5  前端路由原理及实践	124
5.3.6  两种路由类型	124
5.3.7  自造Hash路由管理器	125
5.4  避免散弹式架构	127
5.4.1  散弹式架构应用	127
5.4.2  如何降低散弹性架构的出现频率	128
5.5  小结	130
第6章  架构设计：单页面应用	131
6.1  前端MV*原理	132
6.2  前端MVC架构原理	133
6.3  进阶：设计双向绑定的MVC	135
6.4  前端框架选型	138
6.4.1  选型考虑因素	139
6.4.2  框架类型：大而全还是小而美	140
6.4.3  框架：React	142
6.4.4  框架：Angular	143
6.4.5  框架：Vue	145
6.4.6  选型总结	146
6.5  启动前端应用	146
6.5.1  创建应用脚手架	147
6.5.2  构建组件库	148
6.5.3  考虑浏览器的支持范围	150
6.6  服务端渲染	155
6.6.1  非JavaScript语言的同构渲染	155
6.6.2  基于JavaScript语言的同构渲染	157
6.6.3  预渲染	158
6.7  小结	159
第7章  架构设计：组件化架构	161
7.1  前端的组件化架构	161
7.2  基础：风格指南	163
7.2.1  原则与模式	163
7.2.2  色彩	165
7.2.3  文字排印	167
7.2.4  布局	168
7.2.5  组件	173
7.2.6  文档及其他	174
7.2.7  维护风格指南	174
7.3  重用：模式库	175
7.3.1  组件库	176
7.3.2  组件类型	178
7.3.3  隔离：二次封装	183
7.4  进阶：设计系统	184
7.4.1  设立原则，创建模式	186
7.4.2  原子设计	188
7.4.3  维护与文档	191
7.5  跨框架组件化	192
7.5.1  框架间互相调用：Web Components	192
7.5.2  跨平台模式库	193
7.6  小结	194
第8章  架构设计：前后端分离架构	195
8.1  前后端分离	196
8.1.1  为什么选择前后端分离	196
8.1.2  前后端分离的开发模式	197
8.1.3  前后端分离的API设计	198
8.2  API管理模式：API文档管理方式	202
8.3  前后端并行开发：Mock Server	205
8.3.1  什么是Mock Server	205
8.3.2  三种类型Mock Server的比较	207
8.3.3  Mock Server的测试：契约测试	212
8.3.4  前后端并行开发总结	217
8.4  服务于前端的后端：BFF	218
8.4.1  为什么使用BFF	218
8.4.2  前后端如何实现BFF	221
8.4.3  使用GraphQL作为BFF	223
8.5  小结	228
第9章  架构设计：微前端架构	229
9.1  微前端	230
9.1.1  微前端架构	230
9.1.2  为什么需要微前端	232
9.2  微前端的技术拆分方式	234
9.2.1  路由分发式	235
9.2.2  前端微服务化	236
9.2.3  组合式集成：微应用化	237
9.2.4  微件化	238
9.2.5  前端容器：iframe	239
9.2.6  结合Web Components构建	240
9.3  微前端的业务划分方式	241
9.3.1  按照业务拆分	242
9.3.2  按照权限拆分	243
9.3.3  按照变更的频率拆分	243
9.3.4  按照组织结构拆分	244
9.3.5  跟随后端微服务拆分	244
9.3.6  DDD与事件风暴	245
9.4  微前端的架构设计	245
9.4.1  构建基础设施	246
9.4.2  提取组件与模式库	246
9.4.3  应用通信机制	247
9.4.4  数据管理	248
9.4.5  专用的构建系统	249
9.5  微前端的架构模式	249
9.5.1  基座模式	250
9.5.2  自组织模式	251
9.6  微前端的设计理念	252
9.6.1  中心化：应用注册表	252
9.6.2  标识化应用	253
9.6.3  生命周期	253
9.6.4  高内聚，低耦合	254
9.7 “微”害架构	254
9.7.1  微架构	256
9.7.2  架构的演进	256
9.7.3  微架构带来的问题	257
9.7.4  解决方式：可拆分式微架构	259
9.8  小结	259
第10章  微前端实战	261
10.1  遗留系统：路由分发	262
10.1.1  路由分发式微前端	263
10.1.2  路由分发的测试	264
10.2  遗留系统微前端：使用iframe作为容器	266
10.3  微应用化	266
10.3.1  微应用化	267
10.3.2  架构实施	269
10.3.3  测试策略	271
10.4  前端微服务化	272
10.4.1  微服务化设计方案	273
10.4.2  通用型前端微服务化：Single-SPA	276
10.4.3  定制型前端微服务化：Mooa	279
10.4.4  前端微服务化总结	283
10.5  组件化微前端：微件化	283
10.5.1  运行时编译微件化：动态组件渲染	284
10.5.2  预编译微件化	287
10.6  面向未来：Web Components	288
10.6.1  Web Components	289
10.6.2  纯Web Components方式	291
10.6.3  结合Web Components方式	293
10.7  小结	295
第11章  架构演进：演进式架构	297
11.1  更新	298
11.1.1  依赖和框架版本升级	299
11.1.2  语言版本升级	300
11.1.3  遗留系统重搭	300
11.2  迁移	301
11.2.1  架构迁移的模式	302
11.2.2  迁移方式：微前端	303
11.2.3  迁移方式：寻找容器	303
11.3  重构	304
11.3.1  架构重构	304
11.3.2  组件提取、函数提取、样式提取	305
11.3.3  引入新技术	306
11.4  重写	307
11.4.1  重写能解决问题吗	308
11.4.2  梳理业务	309
11.4.3  沉淀新架构	310
11.5  重新架构	311
11.5.1  重搭架构	311
11.5.2  增量改写	312
11.6  小结	313
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>前端架构：从入门到微前端
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring技术内幕
本书赞誉
前言
致谢
第1章准备源代码环境 1
1.1安装JDK 1
1.2安装Eclipse 1
1.3安装辅助工具 2
1.4获取Spring源代码 8
1.5Spring源代码的组织结构 10
1.6小结 12
第一部分Spring核心实现篇
第2章Spring Framework的核心：IoC容器的实现 16
2.1Spring IoC容器概述 16
2.1.1IoC容器和依赖反转模式 16
2.1.2Spring的IoC容器系列 18
2.2IoC容器系列的实现：BeanFactory 和ApplicationContext 20
2.2.1BeanFactory对IoC容器的功能定义 20
2.2.2IoC容器XmlBeanFactory的工作原理 22
2.2.3ApplicationContext的特点 24
2.3IoC容器的初始化 25
2.3.1BeanDefinition的Resource定位 26
2.3.2BeanDefinition的载入和解析 33
2.3.3BeanDefinition在IoC容器中的注册 47
2.4IoC容器的依赖注入 49
2.5容器其他相关特性的实现 70
2.5.1lazy-init属性和预实例化 70
2.5.2FactoryBean的实现 73
2.5.3BeanPostProcessor的实现 75
2.5.4autowiring的实现原理 78
2.6小结 80
第3章Spring AOP的实现 82
3.1Spring AOP概述 82
3.1.1AOP概念回顾 82
3.1.2Advice通知 84
3.1.3Pointcut切点 88
3.1.4Advisor通知器 90
3.2建立AopProxy代理对象 92
3.2.1配置ProxyFactoryBean 92
3.2.2ProxyFactoryBean生成AopProxy 94
3.2.3JDK生成AopProxy代理对象 98
3.2.4CGLIB生成AopProxy代理对象 99
3.3Spring AOP拦截器调用的实现 101
3.3.1JdkDynamicAopProxy的invoke拦截 101
3.3.2Cglib2AopProxy的intercept拦截 103
3.3.3目标对象方法的调用 105
3.3.4AOP拦截器链的调用 105
3.3.5配置通知器 107
3.3.6Advice通知的实现 112
3.3.7ProxyFactory实现AOP 118
3.4Spring AOP的高级特性 120
3.5小结 121
第二部分Spring组件实现篇
第4章Spring MVC与Web环境.. 127
4.1概述 127
4.2Web环境中的Spring MVC 128
4.3IoC容器在Spring MVC中的启动 130
4.3.1Web容器中的上下文 130
4.3.2ContextLoader建立Web环境的根上下文 132
4.4Spring Web MVC的启动 136
4.4.1DispacherServlet概述 136
4.4.2DispacherServlet的启动和初始化 137
4.5Spring MVC的实现 141
4.5.1DispatcherSevlet的MVC初始化 141
4.5.2HandlerMapping的配置 143
4.5.3使用HandlerMapping完成请求的映射处理 148
4.5.4Spring MVC对HTTP请求的分发处理 150
4.6Spring MVC视图的呈现 155
4.6.1DispatcherServlet视图呈现概述 155
4.6.2JSP视图的实现 157
4.6.3ExcelView的实现 160
4.6.4PDF视图的实现 163
4.7小结 165
第5章数据库操作组件的实现 167
5.1Spring JDBC和Spring ORM概述 167
5.2Spring JDBC模板类的实现 167
5.2.1JdbcTeamplate的基本使用 167
5.2.2JdbcTemplate的execute实现 168
5.2.3JdbcTemplate的query实现 170
5.2.4使用数据库Connection 171
5.3Spring JDBC中RDBMS操作对象的实现 172
5.3.1SqlQuery的实现 173
5.3.2SqlUpdate的实现 177
5.3.3SqlFunction 178
5.4Spring驱动Hibernate的实现 179
5.4.1配置Hibernate的SessionFactory 180
5.4.2HibernateTemplate的实现 185
5.4.3Session的管理 187
5.5Spring驱动iBatis的实现 190
5.5.1创建SqlMapClient 190
5.5.2SqlMapClientTemplate的实现 192
5.6小结 194
第6章Spring事务处理的实现 196
6.1Spring与事务处理 196
6.2声明式事务处理的基本过程 196
6.2.1事务处理拦截器的配置 197
6.2.2事务处理配置的读入 200
6.3事务处理拦截器的实现 203
6.4事务处理的实现 206
6.4.1事务处理的编程式使用 206
6.4.2事务的创建 207
6.4.3事务的挂起 214
6.4.4事务的提交 215
6.4.5事务的回滚 218
6.5具体事务处理器的实现 219
6.5.1DataSourceTransactionManager的实现 219
6.5.2HibernateTransactionManager的实现 222
6.6小结 227
第7章Spring远端调用的 实现 230
7.1Spring远端调用概述 230
7.2Spring HTTP 调用器的实现原理 232
7.2.1配置HTTP调用器客户端 232
7.2.2HTTP调用器客户端的实现 232
7.2.3配置HTTP调用器远端服务器端 237
7.2.4HTTP调用器服务器端的实现 237
7.3Spring Hession/Burlap的实现 原理 241
7.3.1Hessian/Burlap客户端的配置 241
7.3.2Hessian客户端的实现 242
7.3.3Burlap客户端的实现 244
7.3.4Hessian/Burlap服务器端的配置 247
7.3.5Hessian服务器端的实现 247
7.3.6Burlap服务器端的实现 250
7.4Spring RMI的实现 252
7.4.1Spring RMI客户端的配置 252
7.4.2Spring RMI客户端的实现 253
7.4.3Spring RMI服务器端的配置 256
7.4.4Spring RMI服务器端的实现 257
7.5小结 259
第8章安全框架ACEGI的 实现 260
8.1Spring ACEGI安全框架概述 260
8.1.1概述 260
8.1.2使用Spring IDE 261
8.1.3ACEGI的Bean配置 263
8.2配置Spring ACEGI 264
8.3ACEGI的Web过滤器实现 267
8.4ACEGI验证器的实现 269
8.4.1AuthenticationManager的authenticate 269
8.4.2DaoAuthenticationProvider的实现 271
8.4.3读取数据库用户信息 273
8.4.4完成用户信息的对比验证 276
8.5ACEGI授权器的实现 277
8.5.1与Web环境的接口FilterSecurityInterceptor 277
8.5.2授权器的实现 280
8.5.3投票器的实现 282
8.6小结 283
第三部分Spring应用篇
第9章Spring petclinic应用实例 287
9.1petclinic概述 287
9.2部署环境及数据库 289
9.3petclinic的Bean配置 290
9.4petclinic的Web页面实现 291
9.5petclinic的领域对象实现 293
9.6petclinic数据库操作的实现 294
9.6.1使用JDBC的数据库操作 294
9.6.2使用Hibernate的数据库操作 295
9.6.3使用JPA的数据库操作 297
9.7小结 298
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring技术内幕
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>代数学方法(第一卷)
导言
第一章 集合论
1.1 ZFC 公理一览
1.2 序结构与序数
1.3 超穷递归及其应用
1.4 基数
1.5 Grothendieck 宇宙
习题
第二章 范畴论基础
2.1 范畴与态射
2.2 函子与自然变换
2.3 函子范畴
2.4 泛性质
2.5 可表函子
2.6 伴随函子
2.7 极限
2.8 完备性
习题
第三章 幺半范畴
3.1 基本定义
3.2 严格性与融贯定理
3.3 辫结构
3.4 充实范畴
3.5 2-范畴一瞥
习题
第四章 群论
4.1 半群, 幺半群与群
4.2 同态和商群
4.3 直积, 半直积与群扩张
4.4 群作用和计数原理
4.5 Sylow 定理
4.6 群的合成列
4.7 可解群与幂零群
4.8 自由群
4.9 对称群
4.10 群的极限和完备化
4.11 范畴中的群
习题
第五章 环论初步
5.1 基本概念
5.2 几类特殊的环
5.3 交换环初探
5.4 间奏: M？bius 反演
5.5 环的极限与完备化
5.6 从幺半群环到多项式环
5.7 唯一分解性
5.8 对称多项式入门
习题
第六章 模论
6.1 基本概念
6.2 模的基本操作
6.3 自由模
6.4 向量空间
6.5 模的张量积
6.6 环变换
6.7 主理想环上的有限生成模
6.8 正合列入门
6.9 投射模, 内射模, 平坦模
6.10 链条件和模的合成列
6.11 半单模
6.12 不可分模
习题
第七章 代数初步
7.1 交换环上的代数
7.2 整性, 有限性和Frobenius 定理
7.3 代数的张量积
7.4 分次代数
7.5 张量代数
7.6 对称代数和外代数
7.7 牛刀小试: Grassmann 簇
7.8 行列式, 迹, 判别式
习题
第八章 域扩张
8.1 扩张的几种类型
8.2 代数闭包
8.3 分裂域和正规扩张
8.4 可分性
8.5 本原元素定理
8.6 域扩张中的范数与迹
8.7 纯不可分扩张
8.8 超越扩张
8.9 张量积的应用
习题
第九章 Galois 理论
9.1 有限Galois 对应
9.2 无穷Galois 对应
9.3 有限域
9.4 分圆域
9.5 正规基定理
9.6 Kummer 理论
9.7 根式解判准
9.8 尺规作图问题
习题
第十章 域的赋值
10.1 滤子
10.2 Krull 赋值与完备化
10.3 域上的赋值
10.4 绝对值, 局部域和整体域
10.5 个案研究: 单位闭圆盘
10.6 一般扩域的赋值
10.7 代数扩域的赋值
10.8 完备域中求根
10.9 Witt 向量
习题
参考文献
符号索引
名词索引暨英译
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>代数学方法(第一卷)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>互联网时代的软件革命
第1篇 SaaS商业模式
第1章 saaS的前世今生
1.1 什么是SaaS
1.1.1 SaaS的产生
1.1.2 SaaS基本概念
1.1.3 SaaS与ASP的异同
1.2 SaaS软件的优势
1.2.1 给用户的优势
1.2.2 给软件商的优势
1.3 SaaS的缺点及解决办法
1.3.1 依赖互联网
1.3.2 数据安全性
1.3.3 数据保密性
1.4 SaaS成功案例
1.4.1 Salesforce.com
1.4.2 GOOgle.com
1.4.3 Alisoft.com
1.4.4 其他SaaS案例
1.5 小结
第2篇 SaaS应用架构
第2章 saas成熟度模型
2.1 SaaS的规模效应
互联网时代的软件革命
2.2 SaaS成熟度模型分级
2.2.1 Level1：定制开发
2.2.2 Level2：可配置
2.2.3 Level3：高性能的多租户架构
2.2.4 Level4：可伸缩性的多租户架构
2.3 如何选择合适的SaaS成熟度模型
2.3.1 产品所面向的客户群的特征与需求
2.3.2 产品的租户数量级别
2.3.3 团队的开发能力与愿意付出的开发／改造成本
2.4 saaS软件的成熟度模型的渐进步骤
2.5 小结
第3章 构建Multi-Tenant应用
3.1 第一阶段：做项目
3.1.1 发现商机
3.1.2 "4+1"视图
3.1.3 设备托管
3.2 第二阶段：做产品
3.2.1 设备共享
3.2.2 创业之旅
3.2.3 可配置化
3.3 第三阶段：多租户
3.3.1 成长的烦恼
3.3.2 如何转化成saas多租户模式
SaaS架构设计
3.3.3 SaaS多租户设计
3.3.4 saas多租户模式的威力
3.4 小结
第4章 高性能的Multi-Tenant最佳实践
4.1 数据库层性能优化
4.1.1 建立合适的索引
4.1.2 消除大数据表连接
4.1.3 避免复杂SQL
4.2 应用层性能优化
4.2.1 Cache
4.2.2 统计和报表计算
4.2.3 基于Tenant的索引搜索
4.2.4 异步操作
4.3 Web层性能优化
4.3.1 web开发的性能优化策略
4.3.2 Http服务器的性能优化策略
4.4 性能监控
4.5 优化的效果
4.6 小结
第5章 Multi-Tenant应用的可配置性
5.1 数据可配置
5.1.1 定制字段
5.1.2 预分配字段
互联网日寸代的软件革命
5.1.3 名称值对
5.1.4 方案比较
5.2 功能可配置
5.2.1 原子功能划分
5.2.2 功能包设计
5.2.3 功能使用校验
5.3 界面可配置
5.3.1 系统菜单可配置
5.3.2 页面元素可配置
5.4 流程可配置
5.5 配置元数据管理
5.5.1 配置元数据
5.5.2 租户配置数据
5.5.3 配置元数据服务
5.6 可配置系统运行
5.6.1 系统菜单框架
5.6.2 功能页面容器
5.6.3 扩展数据引擎
5.6.4 功能引擎
5.7 小结
第6章 可伸缩的SaaS应用架构
6.1 伸缩性（Scalable）的概念
6.2 应用服务器层的水平扩展
第7章 SaaS系统安全
7.1 应用安全
7.2 数据安全
7.3 网络安全
7.4 小结
第8章 离线应用
8.1 系统分析
8.2 本地使用
8.3 本地存储
8.4 数据同步
8.5 数据传输
8.6 离线应用开发工具介绍
8.7 小结
第3篇 SaaS基础架构——云计算
第9章 分布式文件存储
9.1 大文件的分布式存储
9.2 小文件的分布式存储
9.3 小结
第10章 分布式数据库
10.1 基于列的结构化分布式数据库
10.2 基于代理的分布式数据库
10.3 基于列的分布式关系数据库
10.4 小结
第11章 分布式Cache
11.1 单层的分布式Cache
11.2 多层的分布式Cache
11.3 改进的多层分布式Cache
11.4 小结
第12章 分布式计算
12.1 MapReduce分布式计算框架
12.2 文件下载的分布式计算
12.3 小结
第4篇 开放的SaaS平台
第13章 不Open API
13.1 Open API的商业价值分析
13.2 Open API相关产品
13.3 Open API的实现技术
13.4 Open API与API托管平台
13.5 服务集成平台设计与实现
13.6 小结
第14章 开放的SaaS平台
14.1 PaaS
14.2 互联提升价值
14.2.1 拓展软件的能力：聚合互联网资源
14.3 软件互联平台
14.4 小结
第15章 结束语
15.1 SaaS发展趋势
15.2 软件行业的未来
参考资料
后记 魔教传奇-阿里软件的魔方文化
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>互联网时代的软件革命
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hadoop技术内幕
前　言
第一部分　环境准备
第1章　源代码环境准备/ 2
1.1　什么是Hadoop / 2
1.1.1　Hadoop简史/ 2
1.1.2　Hadoop的优势/ 3
1.1.3　Hadoop生态系统/ 4
1.2　准备源代码阅读环境/ 8
1.2.1　安装与配置JDK / 8
1.2.2　安装Eclipse / 9
1.2.3　安装辅助工具Ant/ 12
1.2.4　安装类UNIX Shell环境Cygwin / 13
1.3　准备Hadoop源代码/ 15
1.3.1　下载Hadoop / 15
1.3.2　创建Eclipse项目/ 16
1.3.3　Hadoop源代码组织/ 18
1.4　小结/ 19
第二部分　Common的实现
第2章　Hadoop配置信息处理/ 22
2.1　配置文件简介/ 22
2.1.1　Windows操作系统的配置文件/ 22
2.1.2　Java配置文件/ 23
2.2　Hadoop Configuration详解/ 24
2.2.1　Hadoop配置文件的格式/ 24
2.2.2　Configuration的成员变量/ 26
2.2.3　资源加载/ 27
2.2.4　使用get*和set*访问/设置配置项/ 32
2.3　Configurable接口/ 34
2.4　小结/ 35
第3章　序列化与压缩/ 36
3.1　序列化/ 36
3.1.1　Java内建序列化机制/ 36
3.1.2　Hadoop序列化机制/ 38
3.1.3　Hadoop序列化机制的特征/ 39
3.1.4　Hadoop Writable机制/ 39
3.1.5　典型的Writable类详解/ 41
3.1.6　Hadoop序列化框架/ 48
3.2　压缩/ 49
3.2.1　Hadoop压缩简介/ 50
3.2.2　Hadoop压缩API应用实例/ 51
3.2.3　Hadoop压缩框架/ 52
3.2.4　Java本地方法/ 61
3.2.5　支持Snappy压缩/ 65
3.3　小结/ 69
第4章　Hadoop远程过程调用/ 70
4.1　远程过程调用基础知识/ 70
4.1.1　RPC原理/ 70
4.1.2　RPC机制的实现/ 72
4.1.3　Java远程方法调用/ 73
4.2　Java动态代理/ 78
4.2.1　创建代理接口/ 78
4.2.2　调用转发/ 80
4.2.3　动态代理实例/ 81
4.3　Java NIO/ 84
4.3.1　Java基本套接字/ 84
4.3.2　Java NIO基础/ 86
4.3.3　Java NIO实例：回显服务器/ 93
4.4　Hadoop中的远程过程调用/ 96
4.4.1　利用Hadoop IPC构建简单的分布式系统/ 96
4.4.2　Hadoop IPC的代码结构/ 100
4.5　Hadoop IPC连接相关过程/ 104
4.5.1　IPC连接成员变量/ 104
4.5.2　建立IPC连接/ 106
4.5.3　数据分帧和读写/ 111
4.5.4　维护IPC连接/ 114
4.5.5　关闭IPC连接/ 116
4.6　Hadoop IPC方法调用相关过程/ 118
4.6.1　Java接口与接口体/ 119
4.6.2　IPC方法调用成员变量/ 121
4.6.3　客户端方法调用过程/ 123
4.6.4　服务器端方法调用过程/ 126
4.7　Hadoop IPC上的其他辅助过程/ 135
4.7.1　RPC.getProxy()和RPC.stopProxy() / 136
4.7.2　RPC.getServer()和Server的启停/ 138
4.8　小结/ 141
第5章　Hadoop文件系统/ 142
5.1　文件系统/ 142
5.1.1　文件系统的用户界面/ 142
5.1.2　文件系统的实现/ 145
5.1.3　文件系统的保护控制/ 147
5.2　Linux文件系统/ 150
5.2.1　Linux本地文件系统/ 150
5.2.2　虚拟文件系统/ 153
5.2.3　Linux文件保护机制/ 154
5.2.4　Linux文件系统API/ 155
5.3　分布式文件系统/ 159
5.3.1　分布式文件系统的特性/ 159
5.3.2　基本NFS体系结构/ 160
5.3.3　NFS支持的文件操作/ 160
5.4　Java文件系统/ 162
5.4.1　Java文件系统API / 162
5.4.2　URI和URL / 164
5.4.3　Java输入/输出流/ 166
5.4.4　随机存取文件/ 169
5.5　Hadoop抽象文件系统/ 170
5.5.1　Hadoop文件系统API / 170
5.5.2　Hadoop输入/输出流/ 175
5.5.3　Hadoop文件系统中的权限/ 179
5.5.4　抽象文件系统中的静态方法/ 180
5.5.5　Hadoop文件系统中的协议处理器/ 184
5.6　Hadoop具体文件系统/ 188
5.6.1　FileSystem层次结构/ 189
5.6.2　RawLocalFileSystem的实现/ 191
5.6.3　ChecksumFileSystem的实现/ 196
5.6.4　RawInMemoryFileSystem的实现/ 210
5.7　小结/ 213
第三部分　Hadoop分布式文件系统
第6章　HDFS概述/ 216
6.1　初识HDFS / 216
6.1.1　HDFS主要特性/ 216
6.1.2　HDFS体系结构/ 217
6.1.3　HDFS源代码结构/ 221
6.2　基于远程过程调用的接口/ 223
6.2.1　与客户端相关的接口/ 224
6.2.2　HDFS各服务器间的接口/ 236
6.3　非远程过程调用接口/ 244
6.3.1　数据节点上的非IPC接口/ 245
6.3.2　名字节点和第二名字节点上的非IPC接口/ 252
6.4　HDFS主要流程/ 254
6.4.1　客户端到名字节点的文件与目录操作/ 254
6.4.2　客户端读文件/ 256
6.4.3　客户端写文件/ 257
6.4.4　数据节点的启动和心跳/ 258
6.4.5　第二名字节点合并元数据/ 259
6.5　小结/ 261
第7章　数据节点实现/ 263
7.1　数据块存储/ 263
7.1.1　数据节点的磁盘目录文件结构/ 263
7.1.2　数据节点存储的实现/ 266
7.1.3　数据节点升级/ 269
7.1.4　文件系统数据集的工作机制/ 276
7.2　流式接口的实现/ 285
7.2.1　DataXceiverServer和DataXceiver / 286
7.2.2　读数据/ 289
7.2.3　写数据/ 298
7.2.4　数据块替换、数据块拷贝和读数据块检验信息/ 313
7.3　作为整体的数据节点/ 314
7.3.1　数据节点和名字节点的交互/ 314
7.3.2　数据块扫描器/ 319
7.3.3　数据节点的启停/ 321
7.4　小结/ 326
第8章　名字节点实现/ 327
8.1　文件系统的目录树/ 327
8.1.1　从i-node到INode/ 327
8.1.2　命名空间镜像和编辑日志/ 333
8.1.3　第二名字节点/ 351
8.1.4　FSDirectory的实现/ 361
8.2　数据块和数据节点管理/ 365
8.2.1　数据结构/ 366
8.2.2　数据节点管理/ 378
8.2.3　数据块管理/ 392
8.3　远程接口ClientProtocol的实现/ 412
8.3.1　文件和目录相关事务/ 412
8.3.2　读数据使用的方法/ 415
8.3.3　写数据使用的方法/ 419
8.3.4　工具dfsadmin依赖的方法/ 443
8.4　名字节点的启动和停止/ 444
8.4.1　安全模式/ 444
8.4.2　名字节点的启动/ 449
8.4.3　名字节点的停止/ 454
8.5　小结/ 454
第9章　HDFS客户端/ 455
9.1　认识DFSClient / 455
9.1.1　DFSClient的构造和关闭/ 455
9.1.2　文件和目录、系统管理相关事务/ 457
9.1.3　删除HDFS文件/目录的流程/ 459
9.2　输入流/ 461
9.2.1　读数据前的准备：打开文件/ 463
9.2.2　读数据/ 465
9.2.3　关闭输入流/ 475
9.2.4　读取HDFS文件数据的流程/ 475
9.3　输出流/ 478
9.3.1　写数据前的准备：创建文件/ 481
9.3.2　写数据：数据流管道的建立/ 482
9.3.3　写数据：数据包的发送/ 486
9.3.4　写数据：数据流管道出错处理/ 493
9.3.5　写数据：租约更新/ 496
9.3.6　写数据：DFSOutputStream.sync()的作用/ 497
9.3.7　关闭输出流/ 499
9.3.8　向HDFS文件写入数据的流程/ 500
9.4　DistributedFileSystem的实现/ 506
9.5　HDFS常用工具/ 508
9.5.1　FsShell / 508
9.5.2　DFSAdmin / 510
9.6　小结/ 511
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hadoop技术内幕
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>反模式
**部分　反模式绪论
第1章　模式与反模式简介　3
1.1　反模式就是揭露假象　3
1.2　反模式的概念　6
1.3　反模式的由来　7
1.4　本书组织结构　10
第2章　反模式参考模型　11
2.1　视角　13
2.2　根源　14
2.2.1　匆忙　14
2.2.2　漠然　15
2.2.3　思想狭隘　16
2.2.4　懒惰　16
2.2.5　贪婪　17
2.2.6　无知　18
2.2.7　自负　18
2.3　原力　19
2.4　软件设计层次模型　25
2.4.1　对象层　28
2.4.2　微架构层　28
2.4.3　框架层　28
2.4.4　应用层　29
2.4.5　系统层　29
2.4.6　企业层　31
2.4.7　全球层　32
2.4.8　设计层次小结　32
2.5　架构规模和原力　33
第3章　模式和反模式的模板　35
3.1　退化形式　35
3.2　Alexander形式　36
3.3　*小化模板(微型模式)　36
3.4　小型模式模板　36
3.4.1　归纳式小型模式　37
3.4.2　演绎式小型模式　37
3.5　正式模板　37
3.5.1　GoF模板　37
3.5.2　模式系统模板　38
3.6　对设计模式模板的反思　38
3.7　反模式模板　39
3.7.1　伪反模式模板　40
3.7.2　小型反模式　40
3.8　完整的反模式模板　40
第4章　对使用反模式的建议　43
4.1　机能不良环境　43
4.2　反模式与变化　44
4.3　编写新反模式　45
4.4　小结　46
第二部分　反模式
第5章　软件开发性反模式　49
5.1　软件重构　49
5.2　开发性反模式摘要　50
5.3　The Blob(胖球)　52
5.3.1　背景　52
5.3.2　一般形式　53
5.3.3　症状和后果　54
5.3.4　典型原因　54
5.3.5　已知例外　55
5.3.6　重构方案　55
5.3.7　变化　58
5.3.8　对其他视角和规模的适用性　59
5.3.9　示例　59
5.4　Lava Flow(岩浆流)　62
5.4.1　背景　62
5.4.2　一般形式　63
5.4.3　症状和后果　65
5.4.4　典型原因　65
5.4.5　已知例外　66
5.4.6　重构方案　66
5.4.7　示例　66
5.4.8　相关解决方案　67
5.4.9　对其他视角和规模的适用性　67
5.5　Functional Decomposition(功能分解)　69
5.5.1　背景　69
5.5.2　一般形式　69
5.5.3　症状和后果　69
5.5.4　典型原因　70
5.5.5　已知例外　70
5.5.6　重构方案　70
5.5.7　示例　71
5.5.8　相关解决方案　72
5.5.9　对其他视角和规模的适用性　72
5.6　Poltergeist(恶作剧鬼)　73
5.6.1　背景　73
5.6.2　一般形式　73
5.6.3　症状和后果　74
5.6.4　典型原因　75
5.6.5　已知例外　75
5.6.6　重构方案　75
5.6.7　示例　75
5.6.8　相关解决方案　76
5.6.9　对其他视角和规模的适用性　76
5.7　Golden Hammer(金锤)　78
5.7.1　背景　78
5.7.2　一般形式　79
5.7.3　症状和后果　79
5.7.4　典型原因　79
5.7.5　已知例外　79
5.7.6　重构方案　80
5.7.7　变化　81
5.7.8　示例　81
5.7.9　相关方案　81
5.8　Spaghetti Code(面条代码)　83
5.8.1　背景　83
5.8.2　一般形式　83
5.8.3　症状和后果　83
5.8.4　典型原因　84
5.8.5　已知例外　84
5.8.6　重构方案　84
5.8.7　示例　86
5.8.8　相关解决方案　89
5.9　Cut-And-Paste Programming(剪贴编程)　92
5.9.1　背景　92
5.9.2　一般形式　92
5.9.3　症状和后果　92
5.9.4　典型原因　93
5.9.5　已知例外　93
5.9.6　重构方案　93
5.9.7　示例　94
5.9.8　相关解决方案　95
第6章　软件架构性反模式　97
6.1　架构性反模式摘要　98
6.2　Stovepipe Enterprise(烟囱企业)　100
6.2.1　背景　100
6.2.2　一般形式　100
6.2.3　症状和后果　101
6.2.4　典型原因　101
6.2.5　已知例外　101
6.2.6　重构方案　102
6.2.7　示例　105
6.2.8　相关解决方案　106
6.2.9　对其他视角和规模的适用性　107
6.3　Stovepipe System(烟囱系统)　108
6.3.1　背景　108
6.3.2　一般形式　108
6.3.3　症状和后果　109
6.3.4　典型原因　109
6.3.5　已知例外　109
6.3.6　重构方案　109
6.3.7　示例　110
6.3.8　相关解决方案　112
6.3.9　对其他视角和规模的适用性　112
6.4　Vendor Lock-In(供应商锁定)　113
6.4.1　背景　113
6.4.2　一般形式　114
6.4.3　症状和后果　114
6.4.4　典型原因　114
6.4.5　已知例外　115
6.4.6　重构方案　115
6.4.7　变化　116
6.4.8　示例　117
6.4.9　相关解决方案　117
6.4.10　对其他视角和规模的适用性　117
6.5　Architecture By Implication(实现主导架构)　120
6.5.1　背景　120
6.5.2　一般形式　120
6.5.3　症状和后果　121
6.5.4　典型原因　121
6.5.5　已知例外　121
6.5.6　重构方案　122
6.5.7　变化　123
6.5.8　示例　123
6.5.9　相关解决方案　124
6.5.10　对其他视角和规模的适用性　124
6.6　Design By Committee(委员会设计)　126
6.6.1　背景　126
6.6.2　一般形式　126
6.6.3　症状和后果　126
6.6.4　典型原因　127
6.6.5　已知例外　127
6.6.6　重构方案　127
6.6.7　变化　129
6.6.8　示例　129
6.6.9　相关解决方案、模式和反模式　131
6.6.10　对其他视角和规模的适用性　132
6.7　Reinvent The Wheel(重新发明轮子)　134
6.7.1　背景　134
6.7.2　一般形式　134
6.7.3　症状和后果　135
6.7.4　典型原因　135
6.7.5　已知例外　135
6.7.6　重构方案　135
6.7.7　变化　136
6.7.8　示例　137
6.7.9　相关解决方案　139
6.7.10　对其他视角和规模的适用性　139
第7章　软件项目管理性反模式　141
7.1　管理角色的转变　141
7.2　管理性反模式摘要　142
7.3　Analysis Paralysis(分析瘫痪)　145
7.3.1　背景　145
7.3.2　一般形式　145
7.3.3　症状和后果　146
7.3.4　典型原因　146
7.3.5　已知例外　147
7.3.6　重构方案　147
7.4　Death By Planning(规划致死)　149
7.4.1　背景　149
7.4.2　一般形式　149
7.4.3　症状和后果　151
7.4.4　典型原因　152
7.4.5　已知例外　152
7.4.6　重构方案　152
7.4.7　变化　154
7.4.8　示例　156
7.4.9　相关解决方案　157
7.4.10　对其他视角和规模的适用性　158
7.5　Corncob(玉米棒子)　159
7.5.1　背景　159
7.5.2　一般形式　159
7.5.3　症状和后果　159
7.5.4　典型原因　160
7.5.5　已知例外　160
7.5.6　重构方案　160
7.5.7　变化　161
7.5.8　示例　163
7.5.9　相关解决方案　163
7.5.10　对其他视角和规模的适用性　163
7.6　Irrational Management(非理性管理)　165
7.6.1　背景　165
7.6.2　一般形式　165
7.6.3　症状和后果　166
7.6.4　典型原因　166
7.6.5　已知例外　166
7.6.6　重构方案　166
7.6.7　变化　169
7.6.8　示例　169
7.7　Project Mismanagement(项目管理不善)　172
7.7.1　背景　172
7.7.2　一般形式　172
7.7.3　症状和后果　173
7.7.4　典型原因　173
7.7.5　已知例外　173
7.7.6　重构方案　173
7.7.7　变化　174
7.7.8　示例　175
7.7.9　相关解决方案　176
第三部分　结论和资源
附录A　反模式大纲　181
附录B　反模式术语表　187
附录C　缩略语　191
附录D　参考文献　193
索引　199
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>反模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>构建Oracle高可用环境
第1篇 高可用性篇	1
第1章 什么是Oracle高可用环境	3
1.1 理解Oracle数据库	5
1.2 Oracle高可用特性（High Availability）	40
1.3 搭建高可用的周边辅助环境	50
1.4 高可用应用设计	53
1.5 高可用数据库设计	55
1.6 高可用性案例	63
1.7 总结	66
第2章 Oracle高可用性之辅助环境	67
2.1 存储的选择与规划	68
2.2 网络存储技术	97
2.3 主机的选择与规划	105
2.4 操作系统与存储管理	115
2.5 高可用环境硬件选型案例分析	124
2.6 总结	126
第3章 Oracle高可用之容灾与分级存储	127
3.1 容灾	128
3.2 容灾案例分析	143
3.3 分级存储	146
3.4 总结	150
第4章 Oracle高可用之RAC介绍	151
4.1 RAC的构架	152
4.2 Oracle 10g/11g中RAC的新特性	158
4.3 RAC的负载均衡	161
4.4 RAC的内部结构与优化	166
4.5 RAC的维护管理	171
4.6 ASM介绍	182
4.7 总结	188
第5章 Oracle高可用之Standby介绍	191
5.1 备用数据库（Standby/Data guard）简介	192
5.2 决定归档的一些参数说明	202
5.3 最大保护模式与最大可用模式	205
5.4 日常管理	207
5.5 主库与备用库的切换	212
5.6 逻辑备用（Logical Standby）库	216
5.7 Standby其他高可用特性	223
5.8 总结	227
第6章 Oracle之Streams介绍	229
6.1 Streams介绍	230
6.2 Streams特性	235
6.3 Streams简单配置	237
6.4 SharePlex与DSG RealSync	251
6.5 总结	253
第7章 高可用性之主机HA	255
7.1 主机HA简介	256
7.2 IBM HACMP简介	262
7.3 Veritas VCS简介	270
7.4 是否应当选择主机HA	272
7.5 总结	273
第8章 Oracle其他高可用特性	275
8.1 Oracle Flashback	276
8.2 Oracle高可用之Logmnr	305
8.3 在线表重定义	311
8.4 总结	321
第2篇 数据处理篇	323
第9章 高可用环境备份方案与策略	325
9.1 高可用环境的备份体系构架	326
9.2 使用导出导入构建逻辑备份策略	333
9.3 使用RMAN构造物理备份策略	339
9.4 其他RMAN高可用特性	360
9.5 总结	367
第10章 高可用环境下数据迁移	369
10.1 数据迁移方案讨论	370
10.2 数据迁移案例分析	374
10.3 其他迁移方法	388
10.4 总结	398
第11章 高可用环境数据规划	399
11.1 表空间管理	400
11.2 数据规划分布	414
11.3 总结	421
第3篇 性能优化篇	423
第12章 高可用环境下性能优化	425
12.1 Statspack与AWR的介绍	426
12.2 Statspack与AWR的安装与配置	427
12.3 Statspack与AWR的使用	430
12.4 分析报表	432
12.5 Statspack与AWR的扩展	451
12.6 总结	453
第13章 高可用环境下优化案例	455
13.1 优化规则分析	456
13.2 表关联	464
13.3 优化案例分析	467
13.4 怎样选择最适合自己的环境	474
13.5 总结	477
第4篇 系统维护篇	479
第14章 高可用环境锁与并发控制	481
14.1 锁与阻塞	482
14.2 死锁分析	493
14.3 并发控制	503
14.4 总结	510
第15章 高可用环境之在线维护	513
15.1 高可用环境下修正数据（DML）	514
15.2 高可用环境下结构操作（DDL）	521
15.3 测试环境与统计分析数据	535
15.4 总结	539
第5篇 监控体系篇	541
第16章 高可用环境监控构架设计	543
16.1 监控构架设计	545
16.2 构建一个监控构架	554
16.3 分析功能的增强	565
16.4 监控与安全	570
16.5 辅助监控手段	573
16.6 其他监控手段与软件	577
16.7 总结	579
附录A 常见专有名称解释	581
附录B 公共代码	585
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>构建Oracle高可用环境
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构实战
译者序序前言致谢作者简介第1章  导言  1.1  流程应用  1.2  流程概述  1.3  范围  1.4  总结第2章  架构、架构师和架构设计  2.1  架构    2.1.1  架构定义结构    2.1.2  架构定义行为    2.1.3  架构关注重要的元素    2.1.4  架构平衡利益相关者的需要    2.1.5  架构基于合理证据使决策具体化    2.1.6  架构会遵循一种架构风格    2.1.7  架构受它的环境影响    2.1.8  架构影响开发团队的结构    2.1.9  所有系统都存在架构    2.1.10  架构有特定的范围  2.2  架构师    2.2.1  架构师是技术领导    2.2.2  架构师的角色可能由一个团队来履行    2.2.3  架构师理解软件开发流程    2.2.4  架构师掌握业务领域的知识    2.2.5  架构师掌握技术知识    2.2.6  架构师掌握设计技能    2.2.7  架构师具备编程技能    2.2.8  架构师是优秀的沟通人员    2.2.9  架构师进行决策    2.2.10  架构师知道组织政策    2.2.11  架构师是谈判专家  2.3  架构设计    2.3.1  架构设计是一门科学    2.3.2  架构设计是一门艺术    2.3.3  架构设计跨越很多方面    2.3.4  架构设计是一个渐进的活动    2.3.5  架构设计受许多利益相关者驱动    2.3.6  架构设计经常包括折中    2.3.7  架构设计承认经验    2.3.8  架构设计既由上而下也由下而上  2.4  架构设计的优点    2.4.1  架构设计解决系统的质量问题    2.4.2  架构设计促进达成共识    2.4.3  架构设计支持计划编制流程    2.4.4  架构设计促进架构的完整性    2.4.5  架构设计有助于管理复杂性    2.4.6  架构设计为重用提供基础    2.4.7  架构设计降低维护成本    2.4.8  架构设计支持影响分析  2.5  总结第3章  方法基本原理  3.1  关键概念  3.2  方法内容    3.2.1  角色    3.2.2  工作产品    3.2.3  活动    3.2.4  任务  3.3  流程    3.3.1  瀑布流程    3.3.2  迭代流程    3.3.3  敏捷流程  3.4  总结第4章  编写软件架构文档  4.1  最终的结局  4.2  关键概念  4.3  视点和视图    4.3.1  基础视点    4.3.2  交叉视点    4.3.3  视图及图表    4.3.4  视点及视图的优点  4.4  模型    4.4.1  实现的层级    4.4.2  模型的优点  4.5架构描述框架的特征    4.5.1  软件架构的4+1视图模型    4.5.2  Zachman框架    4.5.3  Rozanski和Woods框架  4.6  一个架构描述框架    4.6.1  视点    4.6.2  工作产品    4.6.3  实现的层级    4.6.4  视图一致  4.7  软件架构文档  4.8  总结第5章  可重用架构资源  5.1  架构的来源  5.2  架构资源元模型    5.2.1  开发期资源    5.2.2  运行期资源  5.3  资源类型    5.3.1  参考架构    5.3.2  开发方法    5.3.3  视点目录    5.3.4  架构风格    5.3.5  架构机制    5.3.6  模式    5.3.7  参考模型    5.3.8  架构决策    5.3.9  现有的应用程序    5.3.10  封装的应用程序    5.3.11  应用框架    5.3.12  组件库/组件  5.4  架构资源的属性  5.5  重用的其他考虑因素  5.6  总结第6章  案例介绍  6.1  流程应用  6.2  案例研究范围    6.2.1  项目团队    6.2.2  外部影响因素  6.3  应用简介  6.4  YoreTour的愿景    6.4.1  问题声明    6.4.2  利益相关者    6.4.3  系统功能    6.4.4  系统的质量    6.4.5  约束  6.5  总结第7章  定义需求  7.1  关联需求和架构  7.2  功能性需求和非功能性需求  7.3  编写需求文档的技术  7.4  流程应用  7.5  理解任务描述  7.6  定义需求：活动概览  7.7  总结第8章  创建逻辑架构  8.1  从需求走向解决方案  8.2  逻辑架构的价值    8.2.1  使逻辑架构最小化    8.2.2  把逻辑架构作为一项投资    8.2.3  可追溯性的重要性  8.3  流程应用  8.4  创建逻辑架构：活动概览  8.5  总结第9章  创建物理架构  9.1  从逻辑架构到物理架构  9.2  流程应用  9.3  创建物理架构：活动概览  9.4  任务：调查架构资源  9.5  任务：定义架构概览  9.6  任务：编写架构决策文档  9.7  任务：概述功能性元素    9.7.1  将逻辑功能元素映射到物理功能元素    9.7.2  确认物理功能元素    9.7.3  采购产品    9.7.4  适应特定技术的模式  9.8  任务：概述部署元素    9.8.1  映射逻辑部署元素到物理部署元素    9.8.2  确认物理部署元素    9.8.3  采购硬件  9.9  任务：检验架构  9.10  任务：构建架构概念证明  9.11  任务：细化功能性元素  9.12  任务：细化部署元素  9.13  任务：确认架构  9.14  任务：更新软件架构文档  9.15  任务：和利益相关者复审架构  9.16  总结第10章  进阶  10.1  架构师和项目团队    10.1.1  架构师和需求    10.1.2  架构师和开发    10.1.3  架构师和测试    10.1.4  架构师和项目管理    10.1.5  架构师和配置管理    10.1.6  架构师和变更管理    10.1.7  架构师和开发环境    10.1.8  架构师和业务分析  10.2  架构师和外界影响    10.2.1  企业架构    10.2.2  设计权威    10.2.3  基础设施提供者    10.2.4  系统维护者  10.3  复杂系统的架构设计    10.3.1  许多独特的功能正在开发    10.3.2  许多人员参与开发    10.3.3  系统是高度分布式的    10.3.4  开发团队是分布式的    10.3.5  运行质量非常有挑战性    10.3.6  存在系统之系统  10.4  总结附录A  软件架构元模型附录B  视点目录附录C  方法概述附录D  架构需求检查列表术语表参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Tomcat架构解析
第1章　Tomcat介绍　　1
1.1　简介　　1
1.1.1　Tomcat历史　　1
1.1.2　Tomcat许可　　2
1.2　安装和启动　　3
1.2.1　Tomcat下载与安装　　3
1.2.2　Tomcat启动　　4
1.2.3　IDE启动　　5
1.2.4　嵌入式启动　　10
1.2.5　Debug启动　　11
1.3　Tomcat目录结构　　12
1.4　Tomcat 8.5之后的新特性　　12
1.5　小结　　13
第2章　Tomcat总体架构　　14
2.1　总体设计　　14
2.1.1　Server　　14
2.1.2　Connector和Container　　15
2.1.3　Container设计　　17
2.1.4　Lifecycle　　20
2.1.5　Pipeline和Valve　　23
2.1.6　Connector设计　　24
2.1.7　Executor　　26
2.1.8　Bootstrap和Catalina　　28
2.2　Tomcat启动　　30
2.3　请求处理　　31
2.4　类加载器　　33
2.4.1　J2SE标准类加载器　　33
2.4.2　Tomcat加载器　　34
2.4.3　Web应用类加载器　　36
2.5　小结　　37
第3章　Catalina　　38
3.1　什么是Catalina　　38
3.2　Digester　　39
3.2.1　对象栈　　40
3.2.2　匹配模式　　41
3.2.3　处理规则　　41
3.2.4　示例程序　　42
3.3　创建Server　　44
3.3.1　Server的解析　　45
3.3.2　Engine的解析　　48
3.3.3　Host的解析　　49
3.3.4　Context的解析　　50
3.4　Web应用加载　　53
3.4.1　StandardHost　　54
3.4.2　HostConfig　　56
3.4.3　StandardContext　　60
3.4.4　ContextConfig　　64
3.4.5　StandardWrapper　　69
3.4.6　Context命名规则　　69
3.5　Web请求处理　　71
3.5.1　总体过程　　71
3.5.2　请求映射　　72
3.5.3　Catalina请求处理　　80
3.6　DefaultServlet和JspServlet　　81
3.6.1　DefaultServlet　　82
3.6.2　JspServlet　　84
3.7　小结　　85
第4章　Coyote　　86
4.1　什么是Coyote　　86
4.2　Web请求处理　　88
4.2.1　主要概念　　88
4.2.2　请求处理　　90
4.2.3　协议升级　　92
4.3　HTTP　　94
4.3.1　基础知识　　94
4.3.2　配置方式　　95
4.4　AJP　　97
4.4.1　基础知识　　97
4.4.2　Web服务器组件　　103
4.4.3　配置方式　　106
4.5　HTTP/2.0　　106
4.5.1　基础知识　　106
4.5.2　配置方式　　110
4.6　I/O　　111
4.6.1　BIO　　112
4.6.2　NIO　　115
4.6.3　NIO2　　121
4.6.4　APR　　130
4.7　小结　　134
第5章　Jasper　　136
5.1　Jasper简介　　136
5.2　JSP编译方式　　137
5.2.1　运行时编译　　137
5.2.2　预编译　　141
5.3　JSP编译原理　　144
5.4　小结　　151
第6章　Tomcat配置管理　　152
6.1　JVM配置　　152
6.1.1　JVM配置选项　　152
6.1.2　系统属性　　153
6.2　服务器配置　　158
6.2.1　catalina.properties　　158
6.2.2　server.xml　　159
6.2.3　context.xml　　172
6.3　Web应用配置　　172
6.3.1　ServletContext初始化参数　　173
6.3.2　会话配置　　174
6.3.3　Servlet声明及映射　　175
6.3.4　应用生命周期监听器　　177
6.3.5　Filter定义及映射　　177
6.3.6　MIME类型映射　　178
6.3.7　欢迎文件列表　　178
6.3.8　错误页面　　179
6.3.9　本地化及编码映射　　179
6.3.10　安全配置　　179
6.3.11　JNDI配置　　180
6.3.12　其他　　183
6.4　Web应用过滤器　　185
6.4.1　CorsFilter　　186
6.4.2　CsrfPreventionFilter　　188
6.4.3　ExpiresFilter　　188
6.4.4　FailedRequestFilter　　190
6.4.5　RemoteAddrFilter　　191
6.4.6　RemoteHostFilter　　191
6.4.7　RemoteIpFilter　　192
6.4.8　RequestDumperFilter　　195
6.4.9　SetCharacterEncodingFilter　　195
6.4.10　WebdavFixFilter　　196
6.5　Tomcat管理　　196
6.5.1　host-manager　　196
6.5.2　manager　　197
6.5.3　管理命令行　　199
6.5.4　Ant任务　　200
6.5.5　JMX　　201
6.6　小结　　201
第7章　Web服务器集成　　202
7.1　Web服务器与应用服务器的区别　　202
7.2　集成应用场景　　205
7.3　与Apache HTTP Server集成　　206
7.3.1　Windows环境安装　　206
7.3.2　Linux环境安装　　207
7.3.3　mod_jk　　209
7.3.4　mod_proxy_ajp　　229
7.4　与Ngnix集成　　235
7.4.1　Ngnix简介　　235
7.4.2　Windows环境安装　　237
7.4.3　Linux环境安装　　237
7.4.4　Tomcat集成　　241
7.5　与IIS集成　　243
7.6　小结　　243
第8章　Tomcat集群　　244
8.1　Tomcat集群介绍　　244
8.1.1　Tomcat集群基础　　246
8.1.2　Apache Tribes　　247
8.1.3　Tomcat集群组件实现　　253
8.2　集群配置　　254
8.3　会话同步　　255
8.3.1　DeltaManager　　256
8.3.2　BackupManager　　257
8.3.3　替代方案　　257
8.4　集群部署　　258
8.4.1　实现原理　　258
8.4.2　配置方式　　259
8.5　小结　　259
第9章　Tomcat安全　　260
9.1　配置安全　　260
9.1.1　安装部署问题　　260
9.1.2　server.xml配置　　261
9.2　应用安全　　263
9.2.1　Realm　　264
9.2.2　HttpServletRequest　　265
9.2.3　Authenticator　　266
9.3　传输安全（SSL）　　267
9.4　Java安全策略　　273
9.4.1　简介　　273
9.4.2　catalina.policy　　275
9.5　小结　　279
第10章　Tomcat性能调优　　280
10.1　Tomcat性能测试及诊断　　281
10.1.1　常见测试方式　　281
10.1.2　性能测试工具　　282
10.1.3　数据采集及分析　　290
10.2　Tomcat性能优化　　303
10.2.1　JVM优化　　304
10.2.2　Tomcat配置　　308
10.3　应用性能优化建议　　311
10.4　小结　　312
第11章　Tomcat附加功能　　313
11.1　Tomcat的嵌入式启动　　313
11.1.1　为什么需要嵌入式启动　　313
11.1.2　嵌入式启动Tomcat　　314
11.1.3　嵌入式启动服务器　　316
11.2　Tomcat中的JNDI　　317
11.2.1　什么是JNDI　　317
11.2.2　Tomcat中的JNDI　　318
11.3　Comet和WebSocket　　320
11.3.1　什么是Comet　　321
11.3.2　Tomcat的Comet实现　　322
11.3.3　什么是WebSocket　　326
11.3.4　Tomcat的WebSocket实现　　328
11.4　小结　　335
附录　server.xml配置　　336
结束语　　370


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Tomcat架构解析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hadoop技术内幕
前　言
第一部分　准备篇
第1章　环境准备 2
1.1　准备学习环境 2
1.1.1　基础软件下载 2
1.1.2　如何准备Linux环境 3
1.2　获取Hadoop源代码 5
1.3　搭建Hadoop源代码阅读环境 5
1.3.1　创建Hadoop工程 5
1.3.2　Hadoop源代码阅读技巧 8
1.4　Hadoop源代码组织结构 10
1.5　Hadoop初体验 12
1.5.1　搭建Hadoop环境 12
1.5.2　Hadoop Shell介绍 15
1.6　编译及调试Hadoop源代码 16
1.6.1　编译Hadoop源代码 17
1.6.2　调试Hadoop源代码 18
1.7　小结 20
第2章　YARN设计理念与基本架构 21
2.1　YARN产生背景 21
2.1.1　MRv1的局限性 21
2.1.2　轻量级弹性计算平台 22
2.2　Hadoop基础知识 23
2.2.1　术语解释 23
2.2.2　Hadoop版本变迁 25
2.3　YARN基本设计思想 29
2.3.1　基本框架对比 29
2.3.2　编程模型对比 30
2.4　YARN 基本架构 31
2.4.1　YARN基本组成结构 32
2.4.2　YARN通信协议 34
2.5　YARN工作流程 35
2.6　多角度理解YARN 36
2.6.1　并行编程 36
2.6.2　资源管理系统 36
2.6.3　云计算 37
2.7　本书涉及内容 38
2.8　小结 38
第二部分　YARN核心设计篇
第3章　YARN基础库 40
3.1　概述 40
3.2　第三方开源库 41
3.2.1　Protocol Buffers 41
3.2.2　Apache Avro 43
3.3　底层通信库 46
3.3.1　RPC通信模型 46
3.3.2　Hadoop RPC的特点概述 48
3.3.3　RPC总体架构 48
3.3.4　Hadoop RPC使用方法 49
3.3.5　Hadoop RPC类详解 51
3.3.6　Hadoop RPC参数调优 57
3.3.7　YARN RPC实现 57
3.3.8　YARN RPC应用实例 61
3.4　服务库与事件库 65
3.4.1　服务库 66
3.4.2　事件库 66
3.4.3　YARN服务库和事件库的使用方法 68
3.4.4　事件驱动带来的变化 70
3.5　状态机库 72
3.5.1　YARN状态转换方式 72
3.5.2　状态机类 73
3.5.3　状态机的使用方法 73
3.5.4　状态机可视化 76
3.6　源代码阅读引导 76
3.7　小结 77
3.8　问题讨论 77
第4章　YARN应用程序设计方法 78
4.1　概述 78
4.2　客户端设计 79
4.2.1　客户端编写流程 80
4.2.2　客户端编程库 84
4.3　ApplicationMaster设计 84
4.3.1　ApplicationMaster编写流程 84
4.3.2　ApplicationMaster编程库 92
4.4　YARN 应用程序实例 95
4.4.1　DistributedShell 95
4.4.2　Unmanaged AM 99
4.5　源代码阅读引导 100
4.6　小结 100
4.7　问题讨论 100
第5章　ResourceManager剖析 102
5.1　概述 102
5.1.1　ResourceManager基本职能 102
5.1.2　ResourceManager内部架构 103
5.1.3　ResourceManager事件与事件处理器 106
5.2　用户交互模块 108
5.2.1　ClientRMService 108
5.2.2　AdminService 109
5.3　ApplicationMaster管理 109
5.4　NodeManager管理 112
5.5　Application管理 113
5.6　状态机管理 114
5.6.1　RMApp状态机 115
5.6.2　RMAppAttempt状态机 119
5.6.3　RMContainer状态机 123
5.6.4　RMNode状态机 127
5.7　几个常见行为分析 129
5.7.1　启动ApplicationMaster  129
5.7.2　申请与分配Container 132
5.7.3　杀死Application 134
5.7.4　Container超时 135
5.7.5　ApplicationMaster超时 138
5.7.6　NodeManager超时 138
5.8　安全管理 139
5.8.1　术语介绍 139
5.8.2　Hadoop认证机制 139
5.8.3　Hadoop授权机制 142
5.9　容错机制 144
5.9.1　Hadoop HA基本框架 145
5.9.2　YARN HA实现  148
5.10　源代码阅读引导 149
5.11　小结 151
5.12　问题讨论 152
第6章　资源调度器 153
6.1　资源调度器背景 153
6.2　HOD调度器 154
6.2.1　Torque资源管理器 154
6.2.2　HOD作业调度 155
6.3　YARN资源调度器的基本架构 157
6.3.1　基本架构 157
6.3.2　资源表示模型 160
6.3.3　资源调度模型 161
6.3.4　资源抢占模型 164
6.4　YARN层级队列管理机制 169
6.4.1　层级队列管理机制 169
6.4.2　队列命名规则 171
6.5　Capacity Scheduler 172
6.5.1　Capacity Scheduler的功能 172
6.5.2　Capacity Scheduler实现 176
6.6　Fair Scheduler 179
6.6.1　Fair Scheduler功能介绍 180
6.6.2　Fair Scheduler实现 182
6.6.3　Fair Scheduler与Capacity Scheduler对比 183
6.7　其他资源调度器介绍 184
6.8　源代码阅读引导 185
6.9　小结 186
6.10　问题讨论 187
第7章　NodeManager剖析 188
7.1　概述 188
7.1.1　NodeManager基本职能 188
7.1.2　NodeManager内部架构 190
7.1.3　NodeManager事件与事件处理器 193
7.2　节点健康状况检测 194
7.2.1　自定义Shell脚本 194
7.2.2　检测磁盘损坏数目 196
7.3　分布式缓存机制 196
7.3.1　资源可见性与分类 198
7.3.2　分布式缓存实现 200
7.4　目录结构管理 203
7.4.1　数据目录管理 203
7.4.2　日志目录管理 203
7.5　状态机管理 206
7.5.1　Application状态机 207
7.5.2　Container状态机 210
7.5.3　LocalizedResource状态机 213
7.6　Container生命周期剖析 214
7.6.1　Container资源本地化 214
7.6.2　Container运行 218
7.6.3　Container资源清理 222
7.7　资源隔离 224
7.7.1　Cgroups介绍 224
7.7.2　内存资源隔离 228
7.7.3　CPU资源隔离 230
7.8　源代码阅读引导 234
7.9　小结 235
7.10　问题讨论 236
第三部分　计算框架篇
第8章　离线计算框架MapReduce 238
8.1　概述 238
8.1.1　基本构成 238
8.1.2　事件与事件处理器 240
8.2　MapReduce客户端 241
8.2.1　ApplicationClientProtocol协议 242
8.2.2　MRClientProtocol协议 243
8.3　MRAppMaster工作流程 243
8.4　MR作业生命周期及相关状态机 246
8.4.1　MR作业生命周期 246
8.4.2　Job状态机 249
8.4.3　Task状态机 253
8.4.4　TaskAttempt状态机 255
8.5　资源申请与再分配 259
8.5.1　资源申请 259
8.5.2　资源再分配 262
8.6　Container启动与释放 263
8.7　推测执行机制 264
8.7.1　算法介绍 265
8.7.2　推测执行相关类 266
8.8　作业恢复 267
8.9　数据处理引擎 269
8.10　历史作业管理器 271
8.11　MRv1与MRv2对比 273
8.11.1　MRv1 On YARN 273
8.11.2　MRv1与MRv2架构比较 274
8.11.3　MRv1与MRv2编程接口兼容性 274
8.12　源代码阅读引导 275
8.13　小结 277
8.14　问题讨论 277
第9章　DAG计算框架Tez 278
9.1　背景 278
9.2　Tez数据处理引擎 281
9.2.1　Tez编程模型 281
9.2.2　Tez数据处理引擎 282
9.3　DAG Master实现 284
9.3.1　DAG编程模型 284
9.3.2　MR到DAG转换 286
9.3.3　DAGAppMaster 288
9.4　优化机制 291
9.4.1　当前YARN框架存在的问题 291
9.4.2　Tez引入的优化技术 292
9.5　Tez应用场景 292
9.6　与其他系统比较 294
9.7　小结 295
第10章　实时/内存计算框架Storm/Spark 296
10.1　Hadoop MapReduce的短板 296
10.2　实时计算框架Storm  296
10.2.1　Storm编程模型 297
10.2.2　Storm基本架构 302
10.2.3　Storm On YARN 304
10.3　内存计算框架Spark 307
10.3.1　Spark编程模型 308
10.3.2　Spark基本架构 312
10.3.3　Spark On YARN 316
10.3.4　Spark/Storm On YARN比较 317
10.4　小结 317
第四部分　高级篇
第11章　Facebook Corona剖析 320
11.1　概述 320
11.1.1　Corona的基本架构 320
11.1.2　Corona的RPC协议与序列化框架 322
11.2　Corona设计特点 323
11.2.1　推式网络通信模型 323
11.2.2　基于Hadoop 0.20版本 324
11.2.3　使用Thrift 324
11.2.4　深度集成Fair Scheduler 324
11.3　工作流程介绍 324
11.3.1　作业提交 325
11.3.2　资源申请与任务启动 326
11.4　主要模块介绍 327
11.4.1　ClusterManager 327
11.4.2　CoronaJobTracker 330
11.4.3　CoronaTaskTracker 333
11.5　小结 335
第12章　Apache Mesos剖析 336
12.1　概述 336
12.2　底层网络通信库 337
12.2.1　libprocess基本架构 338
12.2.2　一个简单示例 338
12.3　Mesos服务 340
12.3.1　SchedulerProcess 341
12.3.2　Mesos Master  342
12.3.3　Mesos Slave  343
12.3.4　ExecutorProcess 343
12.4　Mesos工作流程 344
12.4.1　框架注册过程 344
12.4.2　Framework Executor注册过程 345
12.4.3　资源分配到任务运行过程 345
12.4.4　任务启动过程 347
12.4.5　任务状态更新过程 347
12.5　Mesos资源分配策略 348
12.5.1　Mesos资源分配框架 349
12.5.2　Mesos资源分配算法 349
12.6　Mesos容错机制 350
12.6.1　Mesos Master容错 350
12.6.2　Mesos Slave容错 351
12.7　Mesos应用实例 352
12.7.1　Hadoop On Mesos 352
12.7.2　Storm On Mesos 353
12.8　Mesos与YARN对比 354
12.9　小结 355
第13章　YARN总结与发展趋势 356
13.1　资源管理系统设计动机 356
13.2　资源管理系统架构演化 357
13.2.1　集中式架构 357
13.2.2　双层调度架构 358
13.2.3　共享状态架构 358
13.3　YARN发展趋势  359
13.3.1　YARN自身的完善 359
13.3.2　以YARN为核心的生态系统 361
13.3.3　YARN周边工具的完善 363
13.4　小结 363
附录A　YARN安装指南 364
附录B　YARN配置参数介绍 367
附录C　Hadoop Shell命令介绍 371
附录D　参考资料 374
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hadoop技术内幕
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>DevOps
译者序
前言
第一部分　背　　景
第1章　DevOps是什么 …… 2
1.1　概述 …… 2
1.1.1　定义DevOps …… 2
1.1.2　DevOps实践 …… 3
1.1.3　持续部署的例子：IMVU …… 5
1.2　为什么是DevOps …… 5
1.2.1　发布过程 …… 5
1.2.2　配合不佳的原因 …… 7
1.2.3　运维人员能力有限 …… 7
1.3　DevOps视角 …… 8
1.3.1　自动化 …… 8
1.3.2　开发团队的职责 …… 9
1.4　DevOps与敏捷 …… 9
1.5　团队结构 …… 10
1.5.1　团队规模 …… 10
1.5.2　团队角色 …… 10
1.6　协作 …… 13
1.6.1　协作的形式 …… 13
1.6.2　团队协作 …… 14
1.6.3　跨团队协作 …… 14
1.7　障碍 …… 15
1.7.1　文化及组织类型 …… 15
1.7.2　部门类型 …… 16
1.7.3　筒仓思维方式（Silo Mentality） …… 17
1.7.4　工具支持 …… 17
1.7.5　人员问题 …… 17
1.8　小结 …… 18
1.9　更多阅读材料 …… 18
第2章　云即平台 …… 20
2.1　概述 …… 20
2.2　云的特性 …… 21
2.2.1　虚拟化 …… 22
2.2.2　IP和域名系统管理 …… 23
2.2.3　平台即服务 …… 25
2.2.4　分布式环境 …… 25
2.3　独特的云特性对DevOps的影响 …… 30
2.3.1　环境 …… 30
2.3.2　轻松创建虚拟机 …… 31
2.3.3　数据考量 …… 31
2.4　小结 …… 32
2.5　更多阅读材料 …… 33
第3章　运维 …… 34
3.1　概述 …… 34
3.2　运维服务 …… 34
3.2.1　供给硬件 …… 34
3.2.2　供给软件 …… 35
3.2.3　IT功能 …… 36
3.2.4　服务级别协议 …… 36
3.2.5　容量规划 …… 36
3.2.6　业务连续性和安全 …… 37
3.2.7　服务策略 …… 38
3.2.8　服务设计 …… 39
3.2.9　服务移交 …… 39
3.2.10　服务运维 …… 40
3.2.11　服务运维概念 …… 40
3.3　服务运维功能 …… 41
3.4　持续服务改进 …… 42
3.5　运维和DevOps …… 43
3.6　小结 …… 44
3.7　更多阅读材料 …… 44
第二部分　部署流水线
第4章　整体架构 …… 48
4.1　DevOps实践是否需要架构调整 …… 48
4.2　架构结构总览 …… 49
4.2.1　协作模式 …… 50
4.2.2　资源管理 …… 51
4.2.3　架构元素之间的映射 …… 52
4.3　微服务架构的质量 …… 52
4.3.1　可靠性 …… 53
4.3.2　可修改性 …… 54
4.4　团队的亚马逊规则 …… 55
4.5　现有系统的微服务方案 …… 56
4.6　小结 …… 56
4.7　更多阅读材料 …… 57
第5章　构建与测试 …… 58
5.1　概述 …… 58
5.2　在部署流水线中移动系统 …… 59
5.2.1　可追溯性 …… 59
5.2.2　环境 …… 60
5.3　横切关注点 …… 61
5.4　开发及提交前测试 …… 63
5.4.1　版本控制与分支 …… 63
5.4.2　功能开关 …… 65
5.4.3　配置参数 …… 66
5.4.4　在开发和提交前测试中的测试 …… 67
5.5　构建与集成测试 …… 67
5.5.1　构建脚本 …… 67
5.5.2　打包 …… 68
5.5.3　持续集成与构建状态 …… 69
5.5.4　集成测试 …… 70
5.6　用户验收测试/预发布/性能测试 …… 70
5.7　生产环境 …… 71
5.7.1　早期发布测试 …… 71
5.7.2　错误检测 …… 72
5.7.3　现场测试 …… 72
5.8　事件 …… 73
5.9　小结 …… 73
5.10　更多阅读材料 …… 74
第6章　部署 …… 75
6.1　概述 …… 75
6.2　部署管理的策略 …… 76
6.2.1　蓝/绿部署 …… 76
6.2.2　滚动升级 …… 77
6.3　逻辑一致性 …… 78
6.3.1　相同服务的多个版本同时存在 …… 78
6.3.2　兼容数据库中保存的数据 …… 81
6.4　打包 …… 82
6.5　多环境部署 …… 84
6.6　部分部署 …… 86
6.6.1　金丝雀测试 …… 86
6.6.2　A/B测试 …… 87
6.7　回滚 …… 87
6.8　工具 …… 89
6.9　小结 …… 90
6.10　更多阅读材料 …… 90
第三部分　横切关注点
第7章　监控 …… 94
7.1　概述 …… 94
7.2　监控什么 …… 95
7.2.1　故障检测 …… 96
7.2.2　性能下降检测 …… 96
7.2.3　容量规划 …… 97
7.2.4　用户交互 …… 98
7.2.5　入侵检测 …… 99
7.3　如何监控 …… 99
7.3.1　基于代理的监控和无代理的监控 …… 101
7.3.2　监控运维活动 …… 102
7.3.3　收集和存储 …… 102
7.4　什么时候变更监控配置 …… 103
7.5　解释监控数据 …… 103
7.5.1　日志 …… 104
7.5.2　绘图和展示 …… 105
7.5.3　警报和警告 …… 105
7.5.4　诊断和反应 …… 106
7.5.5　监控DevOps过程 …… 106
7.6　挑战 …… 107
7.6.1　挑战1：持续变更下的监控 …… 107
7.6.2　挑战2：自下向上与自上向下和在云中的监控 …… 108
7.6.3　挑战3：监控微服务架构 …… 109
7.6.4　挑战4：处理大容量的分布式（日志）数据 …… 109
7.7　工具 …… 109
7.8　从监控数据中诊断出异常——Platformer.com的案例 …… 110
7.8.1　背景 …… 111
7.8.2　数据收集 …… 112
7.8.3　检测异常 …… 112
7.8.4　思考 …… 113
7.9　小结 …… 113
7.10　更多阅读材料 …… 114
第8章　安全与安全审计 …… 115
8.1　安全是什么 …… 115
8.2　威胁 …… 117
8.3　需要保护的资源 …… 118
8.4　安全角色和活动 …… 120
8.5　身份管理 …… 122
8.5.1　认证 …… 123
8.5.2　授权 …… 125
8.6　访问控制 …… 126
8.6.1　阻止访问 …… 127
8.6.2　谁负责预防控制 …… 129
8.7　检测、审计和拒绝服务 …… 129
8.8　开发 …… 130
8.9　审计者 …… 130
8.10　应用设计考虑 …… 131
8.11　部署流水线设计考虑 …… 132
8.12　小结 …… 133
8.13　更多阅读材料 …… 134
第9章　其他非功能需求 …… 135
9.1　概述 …… 135
9.2　可重复性 …… 136
9.2.1　在恰当的层级上定义和执行过程 …… 136
9.2.2　版本控制所有事物 …… 138
9.3　性能 …… 139
9.3.1　测量重要的事物 …… 139
9.3.2　提高资源使用率 …… 140
9.4　可靠性 …… 141
9.4.1　理解不同服务的可靠性特性 …… 141
9.4.2　早期检测和修复错误 …… 142
9.5　可恢复性 …… 142
9.6　互操作性 …… 143
9.6.1　注意接口的互操作性 …… 143
9.6.2　理解现有的数据模型 …… 143
9.7　可测试性 …… 144
9.8　可修改性 …… 145
9.8.1　一个工具内的修改 …… 145
9.8.2　工具之间交互行为的修改 …… 146
9.9　小结 …… 146
9.10　更多阅读材料 …… 147
第10章　业务关注点 …… 148
10.1　概述 …… 148
10.2　业务案例 …… 148
10.2.1　问题和解决问题所带来的好处 …… 149
10.2.2　成本 …… 149
10.2.3　干系人影响 …… 150
10.2.4　风险及其减缓 …… 151
10.2.5　推出计划 …… 153
10.2.6　成功标准 …… 154
10.3　度量和对DevOps实践的合规性 …… 155
10.3.1　测量DevOps实践的成功度 …… 155
10.3.2　测量对DevOps实践的合规性 …… 156
10.3.3　测量干系人的满意度 …… 157
10.4　Dev和Ops之间的交互点 …… 157
10.4.1　许可 …… 157
10.4.2　事故处理 …… 158
10.5　小结 …… 159
10.6　更多阅读材料 …… 159
第四部分　案 例 研 究
第11章　支持多数据中心 …… 162
11.1　概述 …… 162
11.2　当前的情况 …… 163
11.3　业务逻辑和Web层 …… 163
11.3.1　应用逻辑 …… 163
11.3.2　基础设施 …… 164
11.3.3　增加一个应用 …… 164
11.3.4　发现基础设施 …… 165
11.4　数据库层 …… 167
11.4.1　事务数据 …… 167
11.4.2　基础设施支持 …… 168
11.4.3　会话数据 …… 168
11.5　其他基础设施工具 …… 168
11.5.1　gem存储库服务器 …… 169
11.5.2　Elasticsearch …… 169
11.5.3　域名系统 …… 169
11.6　数据中心切换 …… 170
11.6.1　受控切换步骤 …… 170
11.6.2　非受控切换 …… 174
11.6.3　定义和自动化切换步骤 …… 175
11.7　测试 …… 177
11.7.1　数据中心切换应用程序 …… 177
11.7.2　基础设施测试 …… 177
11.7.3　持续交付流水线 …… 177
11.8　小结 …… 178
11.9　更多阅读材料 …… 179
第12章　实施企业的持续部署流水线 …… 180
12.1　概述 …… 180
12.2　组织背景 …… 180
12.3　持续部署流水线 …… 182
12.3.1　持续部署流水线工具 …… 183
12.3.2　使用AWS CloudFormation的环境定义 …… 184
12.3.3　标准化的应用程序生命周期概览及其使用 …… 186
12.3.4　标准化的应用程序生命周期阶段 …… 188
12.3.5　管理复杂的应用程序和流水线状态 …… 194
12.3.6　管理持久化 …… 196
12.4　让安全成为持续部署流水线的基础 …… 196
12.4.1　使用Amazon CloudFormation分离职责 …… 196
12.4.2　身份和访问管理 …… 197
12.5　高级概念 …… 198
12.5.1　最小化生产环境和非生产环境之间的偏移 …… 198
12.5.2　解决供应商的限制 …… 198
12.5.3　厂商锁定 …… 199
12.5.4　新的AWS内置服务的展望 …… 199
12.6　小结 …… 199
12.7　更多阅读材料 …… 200
第13章　迁移到微服务 …… 202
13.1　Atlassian概述 …… 202
13.2　构建部署微服务的平台 …… 203
13.3　BlobStore：一个微服务例子 …… 206
13.3.1　架构 …… 206
13.3.2　通过纯函数式架构和编程实现安全性和性能 …… 207
13.3.3　解决“非功能需求” …… 210
13.4　开发过程 …… 210
13.4.1　开发人员和支持 …… 211
13.4.2　构建和部署流水线 …… 212
13.4.3　客户应用的生产环境的零停机时间路径 …… 214
13.5　BlobStore演进 …… 215
13.6　小结 …… 219
13.7　更多阅读材料 …… 219
第五部分　走 向 未 来
第14章　作为过程的运维 …… 222
14.1　概述 …… 222
14.2　动机和概览 …… 223
14.3　离线活动 …… 224
14.4　在线活动 …… 227
14.4.1　错误检测 …… 227
14.4.2　错误恢复 …… 229
14.5　错误诊断 …… 229
14.6　监控 …… 231
14.7　小结 …… 231
14.8　更多阅读材料 …… 231
第15章　DevOps的未来 …… 232
15.1　概述 …… 232
15.2　组织问题 …… 233
15.2.1　DevOps活动中可能涉及的其他组 …… 233
15.2.2　所有关系和重组 …… 234
15.2.3　授权与控制 …… 234
15.3　过程问题 …… 235
15.3.1　厂商锁定和标准 …… 235
15.3.2　计费模型 …… 235
15.3.3　变更的速度 …… 236
15.4　技术问题 …… 237
15.4.1　持续部署流水线概念 …… 237
15.4.2　在持续部署流水线中获得质量 …… 239
15.4.3　实现 …… 239
15.5　错误报告和修复 …… 240
15.6　结束语 …… 240
15.7　更多阅读材料 …… 240
参考文献 …… 241
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>DevOps
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>可扩展的艺术
目 　 　录
导言　　1
第一部分 　可扩展组织的人员配备
第1章 　人员和领导力对可扩展性的影响　　6
1.1 　AllScale简介　　6
1.2 　为什么要考虑人员　　7
1.3 　为什么要考虑组织　　8
1.4 　为什么要考虑管理和领导力　　12
1.5 　结论　　14
本章要点　　14
第2章 　可扩展技术组织中的角色　　15
2.1 　失败的后果　　15
2.2 　角色的定义　　16
2.3 　执行主管的职责　　17
2.3.1 　CEO　　18
2.3.2 　CFO　　19
2.3.3 　业务单元责任人和P&L责任人　　19
2.3.4 　CTO/CIO　　19
2.4 　组织的职责　　20
2.4.1 　架构团队的职责　　21
2.4.2 　软件开发团队的职责　　21
2.4.3 　生产运营团队的职责　　21
2.4.4 　基础设施团队的职责　　22
2.4.5 　质量保证团队的职责　　22
2.4.6 　产能计划团队的职责　　22
2.5 　个人贡献者的职责和特征　　23
2.5.1 　架构师　　23
2.5.2 　软件工程师　　23
2.5.3 　操作员　　24
2.5.4 　基础设施工程师　　24
2.5.5 　QA工程师/分析师　　24
2.5.6 　产能计划员　　25
2.6 　一个组织示例　　25
2.7 　定义职责的工具　　26
2.8 　结论　　28
本章要点　　29
第3章 　设计组织　　30
3.1 　影响可扩展性的组织因素　　30
3.2 　团队规模　　32
3.2.1 　警示信号　　35
3.2.2 　扩大团队或拆分团队　　36
3.3 　组织架构　　38
3.3.1 　职能型组织　　38
3.3.2 　矩阵型组织　　40
3.4 　结论　　42
本章要点　　43
第4章 　领导力101　　44
4.1 　什么是领导力　　45
4.2 　领导力的一个概念模型　　46
4.3 　评估你是谁　　47
4.4 　身先士卒　　49
4.5 　保持谦虚的态度　　49
4.6 　使命第一，人员至上　　50
4.7 　做出及时、合理、符合道德的决策　　51
4.8 　给团队授能和可扩展性　　51
4.9 　一切围绕股东价值　　52
4.10 　愿景　　53
4.11 　使命　　55
4.12 　战略目标　　55
4.13 　整合愿景、使命和战略目标　　57
4.14 　通向成功的因果图　　59
4.15 　结论　　61
本章要点　　61
第5章 　管理101　　63
5.1 　管理是什么　　63
5.2 　项目和任务管理　　64
5.3 　建设团队——一个运动比喻　　65
5.4 　提升团队——一个花园比喻　　66
5.5 　衡量方法、指标和目标评估　　69
5.6 　目标树　　71
5.7 　为成功铺路　　72
5.8 　结论　　72
本章要点　　73
第6章 　进行商业论证　　74
6.1 　理解经验的鸿沟　　74
6.1.1 　为什么业务主管可能成为问题所在　　75
6.1.2 　为什么技术主管可能成为问题所在　　75
6.2 　破除企业思维定式　　76
6.2.1 　建立关系　　78
6.2.2 　树立榜样　　78
6.2.3 　培训其他主管　　78
6.2.4 　利用RASCI模型　　79
6.2.5 　用商业语言交谈　　79
6.2.6 　让他们参与进来　　79
6.2.7 　用事实让主管团队感到恐慌　　80
6.3 　为扩展论证　　80
6.4 　结论　　83
本章要点　　83
第二部分 　制定扩展流程
第7章 　理解流程对扩展的重要性　　86
7.1 　流程的目的　　87
7.2 　正确的时间，正确的流程　　89
7.2.1 　需要有多严苛　　90
7.2.2 　需要有多复杂　　91
7.3 　好的流程何时会变成坏的　　93
7.4 　结论　　93
本章要点　　94
第8章 　管理故障和问题　　95
8.1 　什么是故障　　96
8.2 　什么是问题　　96
8.3 　故障管理的步骤　　97
8.4 　问题管理的步骤　　99
8.5 　化解故障管理与问题管理之间的冲突　　100
8.6 　故障和问题的生命周期　　100
8.7 　召开每日故障例会　　101
8.8 　召开季度故障回顾会议　　102
8.9 　事后分析流程　　102
8.10 　综合应用　　104
8.11 　结论　　106
本章要点　　106
第9章 　管理危机和升级　　107
9.1 　什么是危机　　107
9.2 　为什么要把危机与其他故障区分开来　　108
9.3 　危机如何改变一个公司　　108
9.4 　为混乱赋予秩序　　109
9.4.1  “问题经理”的角色　　110
9.4.2 　团队经理的角色　　111
9.4.3 　首席工程师的角色　　112
9.4.4 　个人贡献者的角色　　113
9.5 　沟通和控制　　113
9.6 　作战室　　114
9.7 　升级　　115
9.8 　状态沟通　　115
9.9 　危机事后分析会议　　116
9.10 　危机后续跟进和沟通　　117
9.11 　结论　　117
本章要点　　118
第10章 　控制生产环境中的变更　　119
10.1 　什么是变更　　120
10.2 　变更识别　　121
10.3 　变更管理　　122
10.3.1 　变更建议　　123
10.3.2 　变更批准　　125
10.3.3 　变更日程安排　　125
10.3.4 　变更实施和记录　　127
10.3.5 　变更验证　　127
10.3.6 　变更审查　　127
10.4 　变更控制会议　　128
10.5 　持续的流程改善　　128
10.6 　结论　　129
本章要点　　129
第11章 　确定应用的余量　　131
11.1 　流程的目的　　131
11.2 　流程的步骤　　132
11.3 　理想的使用比例　　135
11.4 　结论　　137
本章要点　　138
第12章 　探讨架构设计原则　　139
12.1 　原则和目标　　139
12.2 　原则选择　　142
12.3 　AKF的十二条架构设计原则　　143
12.3.1 　N+1设计　　143
12.3.2 　设计为能够回退的　　144
12.3.3 　设计为能够禁用的　　144
12.3.4 　设计为能够监控的　　144
12.3.5 　设计为多个活动站点　　144
12.3.6 　采用成熟的技术　　144
12.3.7 　设计为异步的　　145
12.3.8 　无状态系统　　145
12.3.9 　进行横向扩展而不是纵向扩展　　145
12.3.10 　设计为至少可以在两条轴上进行扩展　　145
12.3.11 　非核心的组件可以购买　　145
12.3.12 　采用同质化硬件　　145
12.4 　扩展原则深度解析　　146
12.4.1 　设计为能够监控的　　146
12.4.2 　设计为多个活动站点　　147
12.4.3 　设计为异步的　　147
12.4.4 　无状态系统　　148
12.4.5 　进行横向扩展而不是纵向扩展　　148
12.4.6 　设计为至少可以在两条轴上进行扩展　　149
12.5 　结论　　150
本章要点　　150
第13章 　联合架构设计　　151
13.1 　修正组织的功能障碍　　151
13.2 　设计为能够跨部门扩展　　153
13.3 　开始条件和结束条件　　155
13.4 　结论　　157
本章要点　　157
第14章 　架构评审委员会　　159
14.1 　通过审查确保可扩展性　　159
14.2 　委员会成员　　160
14.3 　会议实施　　162
14.4 　开始条件和结束条件　　164
14.5 　结论　　165
本章要点　　166
第15章 　关注核心竞争力：构建还是 　 　 　 　  采购　　167
15.1 　构建还是采购与可扩展性的关系　　167
15.2 　关注成本　　168
15.3 　关注竞争优势　　168
15.4  “非我所建”现象　　169
15.5 　结合成本和竞争优势　　170
15.5.1 　这个组件能够创造竞争优势吗？　　170
15.5.2 　我们是这个组件或资产最好的责任人吗？　　171
15.5.3 　这个组件上的竞争如何？　　171
15.5.4 　我们能经济有效地构建这个组件吗？　　171
15.6 　AllScale公司的构建还是采购难题　　172
15.7 　结论　　173
本章要点　　174
第16章 　确定风险　　175
16.1 　风险管理对扩展的重要性　　175
16.2 　衡量风险　　176
16.3 　管理风险　　181
16.4 　结论　　183
本章要点　　184
第17章 　性能测试和压力测试　　185
17.1 　执行性能测试　　185
17.1.1 　判断标准　　186
17.1.2 　测试环境　　186
17.1.3 　定义测试　　187
17.1.4 　执行测试　　188
17.1.5 　分析数据　　188
17.1.6 　报告给工程师　　189
17.1.7 　重复测试和分析　　189
17.2 　压力测试不要有压力　　190
17.2.1 　确立目标　　190
17.2.2 　识别关键服务　　191
17.2.3 　确定负载　　191
17.2.4 　测试环境　　192
17.2.5 　识别监控项　　192
17.2.6 　制造负载　　192
17.2.7 　执行测试　　193
17.2.8 　分析数据　　193
17.3 　可扩展性的性能测试和压力测试　　194
17.4 　结论　　195
本章要点　　196
第18章 　屏障条件和回退　　197
18.1 　屏障条件　　197
18.1.1 　屏障条件和敏捷开发　　198
18.1.2 　屏障条件和瀑布开发　　200
18.1.3 　屏障条件和混合模型　　200
18.2 　回退能力　　201
18.2.1 　回退窗口需求　　201
18.2.2 　回退的技术考量　　202
18.2.3 　回退的成本考量　　203
18.3 　功能减负——设计为能够禁用的　　203
18.4 　结论　　204
本章要点　　205
第19章 　要快还是要正确　　206
19.1 　业务上的权衡　　206
19.2 　与可扩展性的关系　　209
19.3 　如何做决策　　210
19.4 　结论　　213
本章要点　　214
第三部分 　构建可扩展的方案
第20章 　不受技术限制的设计　　216
20.1 　实现并非架构　　216
20.2 　不受技术限制的设计　　217
20.2.1 　TAD和成本　　217
20.2.2 　TAD和风险　　218
20.2.3 　TAD和可扩展性　　219
20.2.4 　TAD和可用性　　221
20.3 　TAD方法　　221
20.4 　结论　　222
本章要点　　222
第21章 　创建故障隔离的架构　　224
21.1 　故障隔离的架构的术语　　224
21.2 　故障隔离的好处　　226
21.2.1 　故障隔离和可用性——限制影响　　226
21.2.2 　故障隔离和可用性——故障检测和解决　　228
21.2.3 　故障隔离和可扩展性　　228
21.2.4 　故障隔离和上市时间　　229
21.2.5 　故障隔离和成本　　229
21.3 　如何进行故障隔离　　230
21.3.1 　原则1：什么都不能共享　　230
21.3.2 　原则2：什么都不能跨过泳道边界　　231
21.3.3 　原则3：在泳道内交易　　231
21.4 　何时实现故障隔离　　231
21.4.1 　方法1：把最赚钱的功能放入泳道　　232
21.4.2 　方法2：把最容易引发故障的功能放入泳道　　232
21.4.3 　方法3：根据自然界限划分泳道　　232
21.5 　如何测试故障隔离的设计　　233
21.6 　结论　　233
本章要点　　234
第22章 　AKF扩展立方入门　　235
22.1 　概念，还是规则和工具　　235
22.2 　AKF扩展立方介绍　　236
22.3 　扩展立方的含义　　237
22.4 　扩展立方的X轴　　238
22.5 　扩展立方的Y轴　　239
22.6 　扩展立方的Z轴　　240
22.7 　综合应用　　241
22.8 　何时何地使用扩展立方　　243
22.9 　结论　　243
本章要点　　244
第23章 　为扩展划分应用　　245
23.1 　应用的AKF扩展立方　　245
23.2 　AKF应用扩展立方的X轴　　246
23.3 　AKF应用扩展立方的Y轴　　248
23.4 　AKF应用扩展立方的Z轴　　249
23.5 　综合应用　　251
23.6 　应用扩展立方的实际应用　　253
23.6.1 　电子商务平台　　253
23.6.2 　人力资源管理系统　　254
23.6.3 　后台办公IT系统　　255
23.6.4 　经验之谈　　255
23.7 　结论　　256
本章要点　　257
第24章 　为扩展划分数据库　　258
24.1 　数据库的AKF扩展立方　　258
24.2 　AKF数据库扩展立方的X轴　　259
24.3 　AKF数据库扩展立方的Y轴　　262
24.4 　AKF数据库扩展立方的Z轴　　264
24.5 　综合应用　　265
24.6 　数据库扩展立方的实际应用　　267
24.6.1 　电子商务平台　　267
24.6.2 　人力资源管理系统　　269
24.6.3 　后台办公IT系统　　269
24.6.4 　经验之谈　　270
24.6.5 　时间方面的考量　　270
24.7 　结论　　271
本章要点　　271
第25章 　为性能和扩展进行缓存　　272
25.1 　缓存定义　　272
25.2 　对象缓存　　275
25.3 　应用缓存　　277
25.3.1 　代理缓存　　278
25.3.2 　反向代理缓存　　279
25.3.3 　缓存软件　　280
25.4 　内容交付网络　　281
25.5 　结论　　282
本章要点　　282
第26章 　实现扩展的异步设计　　284
26.1 　同步的定义　　284
26.2 　同步调用，还是异步调用　　285
26.2.1 　同步扩展，还是异步扩展　　286
26.2.2 　异步系统示例　　288
26.3 　定义状态　　290
26.4 　结论　　293
本章要点　　294
第四部分 　解决其他的问题和挑战
第27章 　数据太多　　296
27.1 　数据的成本　　296
27.2 　数据的价值和成本–价值难题　　298
27.3 　让数据成为有利可图的　　299
27.3.1 　期权价值　　300
27.3.2 　竞争优势　　300
27.3.3 　成本合理的解决方案（分层的存储方案）　　301
27.3.4 　转换数据　　302
27.4 　处理大量的数据　　302
27.5 　结论　　305
本章要点　　306
第28章 　云和网格　　307
28.1 　历史和定义　　307
28.1.1 　网格计算　　309
28.1.2 　公共云和私有云　　310
28.2 　云的特征和架构　　311
28.2.1 　按用量付费　　311
28.2.2 　按需扩展　　311
28.2.3 　多租户　　312
28.2.4 　虚拟化　　313
28.3 　云和网格的区别　　314
28.4 　结论　　315
本章要点　　316
第29章 　在云上翱翔　　317
29.1 　云计算的利弊　　317
29.1.1 　云计算的优点　　318
29.1.2 　云计算的缺点　　320
29.2 　云计算的不同用法　　323
29.2.1 　环境　　323
29.2.2 　技能集合　　325
29.3 　决策流程　　325
29.4 　结论　　327
本章要点　　328
第30章 　接上网格　　329
30.1 　网格的利弊　　329
30.1.1 　网格的优点　　330
30.1.2 　网格的缺点　　331
30.2 　网格计算的不同用法　　333
30.2.1 　生产网格　　333
30.2.2 　编译网格　　334
30.2.3 　数据仓库网格　　335
30.2.4 　后台办公网格　　335
30.3 　决策流程　　336
30.4 　结论　　338
本章要点　　338
第31章 　监控应用　　340
31.1 　“为什么我们没能及早发现它？”　　340
31.2 　实现监控的框架　　342
31.2.1 　用户体验和业务指标　　345
31.2.2 　系统监控　　345
31.2.3 　应用监控　　346
31.3 　衡量监控：什么有价值，什么无价值　　347
31.4 　监控和流程　　348
31.5 　结论　　349
本章要点　　349
第32章 　规划数据中心　　350
32.1 　数据中心的成本和约束　　350
32.2 　位置、位置、还是位置　　352
32.3 　数据中心与增量增长　　354
32.4 　三条三之原则　　355
32.4.1 　第一条三之原则：数据中心的三个成本驱动力　　355
32.4.2 　第二条三之原则：三对服务器来说是个神奇数字　　356
32.4.3 　第三条三之原则：三对数据中心来说是个神奇数字　　356
32.5 　构建多个活动数据中心要考虑的因素　　359
32.6 　结论　　360
本章要点　　361
第33章 　综合应用　　362
33.1 　接下来做什么　　363
33.2 　案例分析　　365
33.2.1 　eBay：巨大的成功和可扩展性大爆炸　　365
33.2.2 　Quigo：出现可扩展性问题的年轻产品　　366
33.2.3 　ShareThis：一个创业公司的故事　　367
33.3 　参考资料　　368
附 　 　录
附录A 　计算可用性　　372
附录B 　产能规划计算　　378
附录C 　负载和性能计算　　383
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>可扩展的艺术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>2轴思维
版权信息
前言 只要在纸上画两条线，就能搞定一切
序章 你是否仍在“复杂问题复杂思考”
遇事即慌的人与有条不紊的人，区别何在
“立刻行动”并非万能良策
尽快解决问题三原则之一：确立思考的框架
尽快解决问题三原则之二：掌握事物的全貌
尽快解决问题三原则之三：不做无用的思考
Part 1 基础篇
第一章 只要画两条线，就能搞定一切
为什么思维框架总是落不了地
到底什么是“2轴思维”
一张图瞬间改变复杂项目
大名鼎鼎的思维框架，转换为2轴就能用了
2轴思维的五大优点——提升思考与表达的速度
小结 所有工作的基础：具备“IPO”意识
第二章 如何制作2轴思维框架
制作2轴思维框架只需三步
万能“表单式”的制作方法
展示位置关系的“四象限式”的制作方法
揭示变化的“图形式”的制作方法
制作2轴思维框架的要点
小结 通过训练，让2轴思维成为一种习惯
Part 2 实践篇
第三章 利用2轴解决问题
实战中需要搭配使用三种模式
案例一：不知道问题出在哪里
案例二：人员评价
案例三：计划总是延误
案例四：想不出好创意
案例五：制定公司的发展战略
小结 将庞大的表单绘制成“热图”用以概览
第四章 利用2轴进行表达
糟糕的表达方式等于“时间”与“质量”的双失
一下子就让对方明白的“表达三原则”
利用2轴进行表达的三步骤
对于有“交流障碍”的人，2轴的效果最为立竿见影
小结 在白板上使用2轴的三项技巧
第五章 利用2轴制作展示内容
不要过分纠结于内容的外在呈现
高手是如何做出通俗易懂的展示内容的
利用2轴制作展示内容的五步骤
追加章 2轴思维框架一览
表单式
四象限式
图形式
结语
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>2轴思维
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>一线架构师实践指南
第1章  绪论第Ⅰ部分  Pre-Architecture阶段  第2章  Pre-architecture的故事  第3章  Pre-architecture总论  第4章  需求结构化与分析约束影响  第5章  确定关键质量与关键功能第Ⅱ部分  Conceptual Architecture阶段  第6章  概念架构的故事  第7章  Conceptual Architecture总论  第8章  初步设计  第9章  高层分割  第10章  考虑非功能需求第Ⅲ部分  Refined Architecture阶段  第11章  细化架构的故事  第12章  Refined Architecture总论  第13章  逻辑架构  第14章  物理架构、运行架构、开发架构  第15章  数据架构的难点：数据分布第Ⅳ部分  专题：非功能目标的方法论  第16章  故事：困扰己久的非功能问题  第17章  总论：非功能目标的设计环节  第18章  方法：“目标－场景－决策”表索引编辑手记设计手记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>一线架构师实践指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>供应链架构师
第一章 谁能慧眼看穿供应链？——抽丝剥茧 走出误区
第二章 三流集成规划怎么做？——善用工具 讲究方法
第三章 如何降低牛鞭效应？ ——两向一点 推拉结合
第四章 如何规划供应链战略？—— 运筹帷幄 决胜千里
第五章 什么是精益供应链管理模式？——追求卓越 永不止步
第六章 如何搭建计划管理平台？—内外协同 步调一致
第七章 零库存还是大库存？—省时度势 布局合理
第八章 采购是不是个技术活？ —汇聚资源 采购价值
第九章 如何规划良好的资金流？— 注入血液 循环增值
第十章 生产管理与TOC——突破瓶颈 提升效率
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>供应链架构师
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向模式的软件架构 卷4：分布式计算的模式语言
第一部分　概念
第1章　模式与模式语言 2
1.1　模式 2
1.2　模式内幕 3
1.2.1　问题的环境 3
1.2.2　驱动因素：所有模式的核心 4
1.2.3　解决方案与结果 4
1.2.4　模式命名 4
1.2.5　模式表现形式概述 5
1.3　模式的关系 5
1.3.1　模式的互补 5
1.3.2　模式的组合 6
1.3.3　模式故事 6
1.3.4　模式序列 7
1.4　模式语言 7
1.4.1　从模式序列到模式语言 7
1.4.2　展现和使用模式语言 7
1.5　模式的连接 8
第2章　分布式系统 9
2.1　分布式的优点 9
2.2　分布式的挑战 11
2.3　用以支持分布式的技术 12
2.3.1　分布式对象计算中间件 13
2.3.2　组件中间件 14
2.3.3　发布/订阅中间件和面向消息的中间件 15
2.3.4　面向服务架构和Web服务 16
2.4　中间件技术的局限性 17
第3章　模式语言 18
3.1　意图、范畴和对象 18
3.2　起源 18
3.3　结构和内容 19
3.4　模式的表现 24
3.5　实际应用 26
第二部分　模式故事
第4章　仓库管理流程控制 33
4.1　系统范畴 33
4.2　仓库管理流程控制 34
第5章　基线架构 37
5.1　架构环境 37
5.2　划分大泥球 38
5.3　层次分解 38
5.4　访问领域对象功能 40
5.5　网络桥接 41
5.6　分离用户界面 43
5.7　功能分布 45
5.8　支持并发的领域对象访问 47
5.9　获得可扩展的并发性 48
5.10　将面向对象与关系型数据库连接起来 49
5.11　领域对象的运行时配置 50
5.12　基线架构总结 51
第6章　通信中间件 54
6.1　分布式系统的中间件架构 54
6.2　对中间件的内部设计进行结构化 57
6.3　封装底层系统机制 58
6.4　分离ORB核心事件 59
6.5　ORB连接管理 61
6.6　提高ORB的可伸缩性 63
6.7　实现同步请求队列 65
6.8　可互换的内部ORB机制 66
6.9　管理ORB策略 68
6.10　ORB动态配置 69
6.11　通信中间件总结 71
第7章　仓库拓扑 74
7.1　仓库拓扑基线 74
7.2　表现层次化的存储结构 74
7.3　存储结构导航 77
7.4　存储属性建模 78
7.5　不同的存储单元行为 79
7.6　实现全局功能 81
7.7　遍历仓库拓扑 81
7.8　支持控制流扩展 83
7.9　连接数据库 84
7.10　维护内存中的存储单元数据 85
7.11　配置仓库拓扑 86
7.12　细述显式接口 88
7.13　仓库拓扑总结 89
第8章　模式故事背后的故事 91
第三部分　模式语言
第9章　从混沌到结构 97
9.1　Domain Model** 106
9.2　Layers** 108
9.3　Model-View-Controller** 109
9.4　Presentation-Abstraction-Control 111
9.5　Microkernel** 113
9.6　Reflection* 114
9.7　Pipes and Filters** 116
9.8　Shared Repository** 117
9.9　Blackboard 119
9.10　Domain Object** 121
第10章　分布式基础设施 123
10.1　Messaging** 129
10.2　Message Channel** 130
10.3　Message Endpoint** 132
10.4　Message Translator** 133
10.5　Message Router** 134
10.6　Publisher-Subscriber** 135
10.7　Broker** 137
10.8　Client Proxy** 139
10.9　Requestor** 140
10.10　Invoker** 142
10.11　Client Request Handler** 143
10.12　Server Request Handler** 144
第11章　事件分离和分发 147
11.1　Reactor** 150
11.2　Proactor* 152
11.3　Acceptor-Connector** 154
11.4　Asynchronous Completion Token** 155
第12章　接口划分 157
12.1　Explicit Interface** 163
12.2　Extension Interface** 165
12.3　Introspective Interface** 166
12.4　Dynamic Invocation Interface* 167
12.5　Proxy** 169
12.6　Business Delegate** 170
12.7　Facade** 171
12.8　Combined Method** 172
12.9　Iterator** 173
12.10　Enumeration Methond** 174
12.11　Batch Method** 175
第13章　组件划分 177
13.1　Encapsulated Implementation** 181
13.2　Whole-Part** 183
13.3　Composite** 185
13.4　Master-Slave** 186
13.5　Half-Object plus Protocol** 188
13.6　Replicated Component Group** 189
第14章　应用控制 191
14.1　Page Controller** 196
14.2　Front Controller** 197
14.3　Application Controller** 198
14.4　Command Processor** 199
14.5　Template View** 200
14.6　Transform View** 201
14.7　Firewall Proxy** 202
14.8　Authorization** 204
第15章　并发 206
15.1　Half-Sync/Half-Async** 209
15.2　Leader/Followers** 211
15.3　Active Object** 212
15.4　Monitor Object** 214
第16章　同步 216
16.1　Guarded Suspension** 221
16.2　Future** 223
16.3　Thread-Safe Interface* 224
16.4　Double-Checked Locking 225
16.5　Strategized Locking** 226
16.6　Scoped Locking** 227
16.7　Thread-Specific Storage 228
16.8　Copied Value** 230
16.9　Immutable Value** 231
第17章　对象间的交互 233
17.1　Observer** 237
17.2　Double Dispatch ** 238
17.3　Mediator* 239
17.4　Command** 240
17.5　Memento** 242
17.6　Context Object** 243
17.7　Data Transfer Object** 244
17.8　Message** 245
第18章　适配与扩展 247
18.1　Bridge** 255
18.2　Object Adapter** 256
18.3　Chain of Responsibility* 257
18.4　Interpreter 258
18.5　Interceptor** 260
18.6　Visitor** 261
18.7　Decorator 262
18.8　Execute-Around Object** 264
18.9　Template Method* 265
18.10　Strategy** 266
18.11　Null Object** 267
18.12　Wrapper Facade** 269
18.13　Declarative Component Configuration* 270
第19章　模态行为 272
19.1　Objects for States* 274
19.2　Methods for States* 275
19.3　Collections for States* 276
第20章　资源管理 278
20.1　Container* 288
20.2　Component Configurator* 289
20.3　Object Manager** 291
20.4　Lookup** 292
20.5　Virtual Proxy** 294
20.6　Lifecycle Callback** 295
20.7　Task Coordinator* 296
20.8　Resource Pool** 298
20.9　Resource Cache** 299
20.10　Lazy Acquisition** 300
20.11　Eager Acquisition** 301
20.12　Partial Acquisition* 303
20.13　Activator** 304
20.14　Evictor** 305
20.15　Leasing** 306
20.16　Automated Garbage Collection** 307
20.17　Counting Handles** 309
20.18　Abstract Factory** 311
20.19　Builder* 312
20.20　Factory Method** 313
20.21　Disposal Method** 314
第21章　数据库访问 316
21.1　Database Access Layer** 318
21.2　Data Mapper** 320
21.3　Row Data Gateway** 321
21.4　Table Data Gateway ** 323
21.5　Active Record 324
第22章　最后的思考 326
术语表 327
参考书目 340
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向模式的软件架构 卷4：分布式计算的模式语言
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大话计算机
本书共分为12章。
第1章介绍数字计算机的设计思路，制作一个按键计算器，在这个过程中逐步理解数字计算机底层原理。
第2章在第1章的基础上，改造按键计算器，实现能够按照编好的程序自动计算，并介绍对应的处理器内部架构概念。
第3章介绍电子计算机的发展史，包括芯片制造等内容。
第4章介绍流水线相关知识，包括流水线、分支预测、乱序执行、超标量等内容。
第5章介绍计算机程序架构，理解单个、多个程序如何在处理器上编译、链接并最终运行的过程。
第6章介绍缓存以及多处理器并行执行系统的体系结构，包括互联架构、缓存一致性架构的原理和实现。
第7章介绍计算机I/O基本原理，包括PCIE、USB、SAS三大I/O体系。
第8章介绍计算机是如何处理声音和图像的，包括3D渲染和图形加速原理架构和实现。第9章介绍大规模并行计算、超级计算机原理和架构，以及可编程逻辑器件（如FPGA等）的原理和架构。
第10章介绍现代计算机操作系统基本原理和架构，包括内存管理、任务调度、中断管理、时间管理等架构原理。
第11章介绍现代计算机形态和生态体系，包括计算、网络、存储方面的实际计算机产品和生态。
第12章介绍机器学习和人工智能底层原理和架构实现。
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大话计算机
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java高并发编程详解
推荐序一
推荐序二
推荐序三
推荐序四
前言
第一部分 多线程基础
第1章 快速认识线程 3
1.1 线程的介绍 3
1.2 快速创建并启动一个线程 3
1.2.1 尝试并行运行 4
1.2.2 并发运行交替输出 5
1.2.3 使用Jconsole观察线程 6
1.3 线程的生命周期详解 7
1.3.1 线程的NEW状态 8
1.3.2 线程的RUNNABLE状态 8
1.3.3 线程的 RUNNING状态 8
1.3.4 线程的BLOCKED状态 8
1.3.5 线程的TERMINATED状态 9
1.4 线程的start方法剖析：模板设计模式在Thread中的应用 9
1.4.1 Thread start方法源码分析以及注意事项 9
1.4.2 模板设计模式在Thread中的应用 11
1.4.3 Thread模拟营业大厅叫号机程序 13
1.5 Runnable接口的引入以及策略模式在Thread中的使用 16
1.5.1 Runnable的职责 16
1.5.2 策略模式在Thread中的应用 16
1.5.3 模拟营业大厅叫号机程序 18
1.6 本章总结 19
第2章 深入理解Thread构造函数 20
2.1 线程的命名 20
2.1.1 线程的默认命名 21
2.1.2 命名线程 21
2.1.3 修改线程的名字 22
2.2 线程的父子关系 22
2.3 Thread与ThreadGroup 23
2.4 Thread与Runnable 24
2.5 Thread与JVM虚拟机栈 25
2.5.1 Thread与Stacksize 25
2.5.2 JVM内存结构 27
2.5.3 Thread与虚拟机栈 30
2.6 守护线程 33
2.6.1 什么是守护线程 33
2.6.2 守护线程的作用 34
2.7 本章总结 34
第3章 Thread API的详细介绍 35
3.1 线程sleep 35
3.1.1 sleep方法介绍 35
3.1.2 使用TimeUnit替代Thread.sleep 36
3.2 线程yield 37
3.2.1 yield方法介绍 37
3.2.2 yield和sleep 37
3.3 设置线程的优先级 38
3.3.1 线程优先级介绍 38
3.3.2 线程优先级源码分析 39
3.3.3 关于优先级的一些总结 40
3.4 获取线程ID 40
3.5 获取当前线程 41
3.6 设置线程上下文类加载器 41
3.7 线程interrupt 42
3.7.1 interrupt 42
3.7.2 isInterrupted 43
3.7.3 interrupted 45
3.7.4 interrupt注意事项 46
3.8 线程join 47
3.8.1 线程join方法详解 48
3.8.2 join方法结合实战 50
3.9 如何关闭一个线程 53
3.9.1 正常关闭 54
3.9.2 异常退出 56
3.9.3 进程假死 56
3.10 本章总结 58
第4章 线程安全与数据同步 59
4.1 数据同步 59
4.1.1 数据不一致问题的引入 59
4.1.2 数据不一致问题原因分析 61
4.2 初识 synchronized关键字 62
4.2.1 什么是synchronized 63
4.2.2 synchronized关键字的用法 63
4.3 深入synchronized关键字 65
4.3.1 线程堆栈分析 65
4.3.2 JVM指令分析 67
4.3.3 使用synchronized需要注意的问题 70
4.4 This Monitor和Class Monitor的详细介绍 72
4.4.1 this monitor 72
4.4.2 class monitor 74
4.5 程序死锁的原因以及如何诊断 77
4.5.1 程序死锁 77
4.5.2 程序死锁举例 77
4.5.3 死锁诊断 80
4.6 本章总结 81
第5章 线程间通信 82
5.1 同步阻塞与异步非阻塞 82
5.1.1 同步阻塞消息处理 82
5.1.2 异步非阻塞消息处理 83
5.2 单线程间通信 84
5.2.1 初识wait和notify 84
5.2.2 wait和notify方法详解 87
5.2.3 关于wait和notify的注意事项 89
5.2.4 wait和sleep 90
5.3 多线程间通信 90
5.3.1 生产者消费者 90
5.3.2 线程休息室wait set 93
5.4 自定义显式锁BooleanLock 94
5.4.1 synchronized关键字的缺陷 94
5.4.2 显式锁BooleanLock 95
5.5 本章总结 104
第6章 ThreadGroup详细讲解 105
6.1 ThreadGroup与Thread 105
6.2 创建ThreadGroup 105
6.3 复制Thread数组和ThreadGroup数组 106
6.3.1 复制Thread数组 106
6.3.2 复制ThreadGroup数组 109
6.4 ThreadGroup操作 109
6.4.1 ThreadGroup的基本操作 110
6.4.2 ThreadGroup的interrupt 113
6.4.3 ThreadGroup的destroy 114
6.4.4 守护ThreadGroup 115
6.5 本章总结 116
第7章 Hook线程以及捕获线程执行异常 117
7.1 获取线程运行时异常 117
7.1.1 UncaughtExceptionHandler的介绍 117
7.1.2 UncaughtExceptionHandler实例 118
7.1.3 UncaughtExceptionHandler源码分析 119
7.2 注入钩子线程 121
7.2.1 Hook线程介绍 121
7.2.2 Hook线程实战 122
7.2.3 Hook线程应用场景以及注意事项 124
7.3 本章总结 124
第8章 线程池原理以及自定义线程池 125
8.1 线程池原理 125
8.2 线程池实现 126
8.2.1 线程池接口定义 127
8.2.2 线程池详细实现 131
8.3 线程池的应用 139
8.4 本章总结 142
第二部分 Java ClassLoader
第9章 类的加载过程 144
9.1 类的加载过程简介 144
9.2 类的主动使用和被动使用 145
9.3 类的加载过程详解 148
9.3.1 类的加载阶段 148
9.3.2 类的连接阶段 149
9.3.3 类的初始化阶段 154
9.4 本章总结 156
第10章 JVM类加载器 158
10.1 JVM内置三大类加载器 158
10.1.1 根类加载器介绍 159
10.1.2 扩展类加载器介绍 159
10.1.3 系统类加载器介绍 160
10.2 自定义类加载器 161
10.2.1 自定义类加载器，问候世界 161
10.2.2 双亲委托机制详细介绍 165
10.2.3 破坏双亲委托机制 167
10.2.4 类加载器命名空间、运行时包、类的卸载等 170
10.3 本章总结 175
第11章 线程上下文类加载器 177
11.1 为什么需要线程上下文类加载器 177
11.2 数据库驱动的初始化源码分析 178
11.3 本章总结 180
第三部分 深入理解volatile关键字
第12章 volatile关键字的介绍 182
12.1 初识volatile关键字 182
12.2 机器硬件CPU 184
12.2.1 CPU Cache模型 184
12.2.2 CPU缓存一致性问题 186
12.3 Java内存模型 187
12.4 本章总结 188
第13章 深入volatile关键字 189
13.1 并发编程的三个重要特性 189
13.1.1 原子性 189
13.1.2 可见性 190
13.1.3 有序性 190
13.2 JMM如何保证三大特性 191
13.2.1 JMM与原子性 192
13.2.2 JMM与可见性 193
13.2.3 JMM与有序性 194
13.3 volatile关键字深入解析 195
13.3.1 volatile关键字的语义 195
13.3.2 volatile的原理和实现机制 197
13.3.3 volatile的使用场景 198
13.3.4 volatile和synchronized 199
13.4 本章总结 200
第14章 7种单例设计模式的设计 201
14.1 饿汉式 201
14.2 懒汉式 202
14.3 懒汉式+同步方法 203
14.4 Double-Check 204
14.5 Volatile+Double-Check 206
14.6 Holder方式 206
14.7 枚举方式 207
14.8 本章总结 208
第四部分 多线程设计架构模式
第15章 监控任务的生命周期 212
15.1 场景描述 212
15.2 当观察者模式遇到Thread 212
15.2.1 接口定义 212
15.2.2 ObservableThread实现 215
15.3 本章总结 217
15.3.1 测试运行 217
15.3.2 关键点总结 219
第16章 Single Thread Execution设计模式 220
16.1 机场过安检 220
16.1.1 非线程安全 221
16.1.2 问题分析 223
16.1.3 线程安全 225
16.2 吃面问题 225
16.2.1 吃面引起的死锁 226
16.2.2 解决吃面引起的死锁问题 228
16.2.3 哲学家吃面 229
16.3 本章总结 230
第17章 读写锁分离设计模式 231
17.1 场景描述 231
17.2 读写分离程序设计 232
17.2.1 接口定义 232
17.2.2 程序实现 234
17.3 读写锁的使用 239
17.4 本章总结 242
第18章 不可变对象设计模式 244
18.1 线程安全性 244
18.2 不可变对象的设计 244
18.2.1 非线程安全的累加器 245
18.2.2 方法同步增加线程安全性 247
18.2.3 不可变的累加器对象设计 248
18.3 本章总结 249
第19章 Future设计模式 251
19.1 先给你一张凭据 251
19.2 Future设计模式实现 251
19.2.1 接口定义 252
19.2.2 程序实现 253
19.3 Future的使用以及技巧总结 256
19.4 增强FutureService使其支持回调 257
19.5 本章总结 258
第20章 Guarded Suspension设计模式 259
20.1 什么是Guarded Suspension设计模式 259
20.2 Guarded Suspension的示例 259
20.3 本章总结 261
第21章 线程上下文设计模式 262
21.1 什么是上下文 262
21.2 线程上下文设计 263
21.3 ThreadLocal详解 264
21.3.1 ThreadLocal的使用场景及注意事项 265
21.3.2 ThreadLocal的方法详解及源码分析 265
21.3.3 ThreadLocal的内存泄漏问题分析 270
21.4 使用ThreadLocal设计线程上下文 274
21.5 本章总结 276
第22章 Balking设计模式 277
22.1 什么是Balking设计 277
22.2 Balking模式之文档编辑 278
22.2.1 Document 278
22.2.2 AutoSaveThread 280
22.2.3 DocumentEditThread 281
22.3 本章总结 283
第23章 Latch设计模式 284
23.1 什么是Latch 284
23.2 CountDownLatch程序实现 285
23.2.1 无限等待的Latch 285
23.2.2 有超时设置的Latch 289
23.3 本章总结 291
第24章 Thread-Per-Message设计模式 293
24.1 什么是Thread-Per-Message模式 293
24.2 每个任务一个线程 293
24.3 多用户的网络聊天 296
24.3.1 服务端程序 296
24.3.2 响应客户端连接的Handler 297
24.3.3 聊天程序测试 299
24.4 本章总结 300
第25章 Two Phase Termination设计模式 301
25.1 什么是Two Phase Termination模式 301
25.2 Two Phase Termination的示例 302
25.2.1 线程停止的Two Phase Termination 302
25.2.2 进程关闭的Two Phase Termination 303
25.3 知识扩展 304
25.3.1 Strong Reference及LRUCache 304
25.3.2 Soft Reference及SoftLRUCache 308
25.3.3 Weak Reference 311
25.3.4 Phantom Reference 312
25.4 本章总结 314
第26章 Worker-Thread设计模式 315
26.1 什么是Worker-Thread模式 315
26.2 Worker-Thread模式实现 315
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java高并发编程详解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Web信息架构（第3版）
序
前言
第1部分：信息架构简介
第1章：信息架构的意义
定义
石板、卷轴、书籍，以及图书馆
对别人解释IA
什么不是信息架构？
为什么信息架构如此重要？
实践
第2章：实践信息架构
我们需要信息架构师吗？
谁有资格从事信息架构的工作？
信息架构专家
在真实世界实践信息架构
向前看
第3章：用户需求及其行为
“过于简单”的信息模型
信息需求
信息搜寻行为
学习信息需求和信息搜寻行为
第2部分：信息架构基本原理
第4章：信息架构详解
展现信息架构
信息架构组件
第5章：组织系统
信息组织的挑战
组织网站和企业网络
组织体系
组织结构
大众分类
建立凝聚性的组织系统
第6章：标签系统
为何要关心标签命名之事
各式各样的标签
设计标签
第7章：导航系统
导航系统的种类
重要的灰色地带
浏览器的导航特点
建立情境
改善灵活性
嵌入式导航系统
辅助性导航系统
高级导航方法
第8章：搜索系统
网站需要搜索功能吗？
搜索系统详解
搜索不是一种IT玩意
选择要搜索什么
搜索算法
查询辅助工具
展示结果
设计搜索界面
上哪儿学更多
第9章：叙词表、受控词表，以及元数据
元数据
受控词表
技术行话
叙词表实例
叙词表的种类
叙词表标准
语义关系
优选术语
复合式等级体系
分面分类法
第3部分：流程和方法论
第10章：研究
流程概观
研究框架
情境
内容
用户
参与者的定义和招募
用户研究会议
研究的保卫战
第11章：策略
什么是信息架构策略？
策略受到质疑
从研究到策略
开发策略
工作产品与成果
策略报告
项目计划
演示
第12章：设计和文件说明
制作信息架构图的原则
视觉沟通
蓝图
框架图
内容映射和清单
建立内容模型
受控词表
设计的共同合作
整合：信息架构风格指南
第4部分：信息架构实践
第13章：教育
教育过渡期
一个充满选择的年代
我需要学位吗？
领域现状
第14章：伦理
伦理考虑
塑造未来
第15章：成立信息架构小组
建设中的破坏性举动
快速层和慢速层
项目vs计划
购买或租赁
我们真的需要聘请专业人员吗？
梦幻小组
第16章：工具和软件
变动的时代
分类乱象
需要询问的事
第5部分：信息架构与组织
第17章：信息架构商机
你一定要做营销
世界上的两种人
谈谈数字
和保守派交手
其他的推销技巧
信息架构价值清单
最后一点
第18章：商业策略
策略之源
定义商业策略
策略的适应性
揭露商业策略内的分歧
最佳方法
很多好方法
了解我们的大象
竞争优势
开始的结束
第19章：企业信息架构
当信息架构碰上企业时
EIA的目标是什么？
设计企业信息架构
EIA策略和操作
办事和付钱
把握时机：阶段性展开
向前走的框架
第6部分：案例研究
第20章：MSWeb：企业网络
用户的挑战
信息架构师的挑战
任何分类法我们都喜欢
对用户的益处
下一步
MSWeb的成就
第21章：enolt．org：在线社区
evolt．org简介
构建在线社区
参与经济论
信息架构如何融入
无信息架构
附录：重要资源
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Web信息架构（第3版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算应用架构
前言	I
第1章  云计算	1
1.1  云	2
1.2  云应用程序的架构	7
1.3  云计算的价值	10
1.4  云基础设施模型	17
1.5  Amazon Web Services概览	19
第2章  Amazon云计算	25
2.1  Amazon S3	25
2.2  Amazon EC2	29
第3章  进云之前	47
3.1  了解软件授权情况	47
3.2  切换到云成本模型	49
3.3  云应用程序的服务水平	54
3.4  安全	63
3.5  灾难恢复	65
第4章  准备好使用云	67
4.1  Web应用程序设计	67
4.2  机器映像设计	75
4.3  隐私保护设计	80
4.4  数据管理	87
第5章  安全	99
5.1  数据安全	99
5.2  网络安全	106
5.3  主机安全	113
5.4  对攻击的反应	118
第6章  灾难恢复	119
6.1  灾难恢复计划	119
6.2  云中的灾难	122
6.3  灾难管理	132
第7章  扩展云基础设施	137
7.1  容量规划	137
7.2  云扩展	145
附录A  Amazon Web Services参考	153
A.1  Amazon EC2命令行参考	153
A.2  Amazon EC2小诀窍	169
附录B  GoGrid	173
B.1  云的类型	173
B.2  云中心的细节	174
B.3  对比方法	178
B.4  哪款适合你	180
附录C  Rackspace	181
C.1  Rackspace的云服务	181
C.2  彻底集成加狂热的技术支持	184
索引	185
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算应用架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向模式的软件架构 第1卷
目 　录
第1章 　模式　　1
1.1 　模式是什么　　1
1.2 　模式之所以为模式　　5
1.3 　模式类型　　7
1.3.1 　架构模式　　8
1.3.2 　设计模式　　8
1.3.3 　成例　　9
1.3.4 　模式分类在软件开发中的用途　　10
1.4 　模式之间的关系　　1
1.5 　模式的描述　　13
1.6 　模式与软件架构　　5
1.6.1 　作为思维构件的模式　　15
1.6.2 　打造异质架构　　16
1.6.3 　模式与方法　　16
1.6.4 　实现模式　　6
1.7 　总结　　17
第2章 　架构模式　　18
2.1 　导言　　18
2.2 　从混乱到有序　　19
2.2.1 　Layers 模式　　21
2.2.2 　Pipes and Filters 模式　　34
2.2.3 　Blackboard 模式　　46
2.3 　分布式系统　　62
2.4 　交互式系统　　78
2.4.1 　Model-View-Controller 模式　　79
2.4.2 　Presentation-Abstraction-Control 模式　　93
2.5 　可适应系统　　109
2.5.1 　Microkernel 模式　　110
2.5.2 　Reflection 模式　　124
第3章 　设计模式　　143
3.1 　导言　　143
3.2 　结构分解模式　　144
3.3 　工作组织模式　　157
3.4 　访问控制　　169
3.5 　管理模式　　178
3.5.1 　Command Processor 模式　　179
3.5.2 　View Handler 模式　　188
3.6 　通信模式　　198
3.6.1 　Forwarder-Receiver 模式　　199
3.6.2 　Client-Dispatcher-Server 模式　　209
3.6.3 　Publisher-Subscriber 模式　　219
第4章 　成例　　223
4.1 　导言　　223
4.2 　成例的用途　　224
4.3 　成例与风格　　224
4.4 　到哪里去寻找成例　　226
第5章 　模式系统　　233
5.1 　模式系统是什么　　233
5.2 　模式分类　　235
5.2.1 　模式类别　　235
5.2.2 　问题类别　　235
5.2.3 　分类方案　　236
5.2.4 　比较　　237
5.3 　选择模式　　238
5.4 　作为实现指南的模式系统　　239
5.5 　模式系统的演化　　241
5.5.1 　模式描述的演化　　242
5.5.2 　创意写作工坊式审阅　　242
5.5.3 　模式发掘　　243
5.5.4 　添加新模式　　243
5.5.5 　删除过时的模式　　244
5.5.6 　扩展组织方案　　244
5.6 　总结　　246
第6章 　模式与软件架构　　247
6.1 　导言　　247
6.1.1 　软件架构　　247
6.1.2 　组件　　248
6.1.3 　关系　　249
6.1.4 　视图　　250
6.1.5 　功能特征和非功能特征　　251
6.1.6 　软件设计　　251
6.1.7 　小结　　252
6.2 　软件架构中的模式　　252
6.2.1 　开发方法　　253
6.2.2 　开发流程　　253
6.2.3 　架构风格　　254
6.2.4 　框架　　255
6.3 　软件架构支持技术　　256
6.3.1 　抽象　　256
6.3.2 　封装　　257
6.3.3 　信息隐藏　　257
6.3.4 　模块化　　257
6.3.5 　分离关注点　　257
6.3.6 　耦合与内聚　　258
6.3.7 　充分、完整、简单　　258
6.3.8 　策略与实现分离　　258
6.3.9 　接口与实现分离　　259
6.3.10 　单个引用点　　259
6.3.11 　分而治之　　259
6.3.12 　小结　　259
6.4 　软件架构的非功能特征　　260
6.4.1 　可修改性　　260
6.4.2 　互操作性　　261
6.4.3 　效率　　262
6.4.4 　可靠性　　262
6.4.5 　可测试性　　262
6.4.6 　可重用性　　263
6.5 　总结　　264
第7章 　模式界　　265
7.1 　起源　　265
7.2 　领军人物及其成果　　266
7.3 　模式界　　267
第8章 　模式的发展方向　　269
8.1 　模式挖掘　　269
8.1.1 　软件架构模式　　269
8.1.2 　组织模式　　270
8.1.3 　领域特定的模式　　270
8.1.4 　模式语言　　271
8.2 　模式的组织和模式索引　　271
8.3 　方法和工具　　272
8.4 　算法、数据结构和模式　　273
8.5 　模式的规范化　　273
8.6 　结语　　274
表示法　　275
术语表　　279
参考文献　　284
索引　　296
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向模式的软件架构 第1卷
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux内核设计的艺术
本书导读
前言
第1章　从开机加电到执行main函数之前的过程1
1.1　启动BIOS，准备实模式下的中断向量表和中断服务程序1
1.1.1　BIOS的启动原理2
1.1.2　BIOS在内存中加载中断向量表和中断服务程序3
1.2　加载操作系统内核程序并为保护模式做准备4
1.2.1　加载第一部分代码—引导程序（bootsect）5
1.2.2　加载第二部分代码—setup7
1.2.3　加载第三部分代码—system模块12
1.3　开始向32位模式转变，为main函数的调用做准备16
1.3.1　关中断并将system移动到内存地址起始位置0x0000016
1.3.2　设置中断描述符表和全局描述符表18
1.3.3　打开A20，实现32位寻址20
1.3.4　为在保护模式下执行head.s做准备21
1.3.5　head.s开始执行24
1.4　本章小结41
第2章　从main到怠速42
2.1　开中断之前的准备工作43
2.1.1　复制根设备号和硬盘参数表 44
2.1.2　物理内存规划格局45
2.1.3　虚拟盘设置与初始化46
2.1.4　内存管理结构mem_map初始化47
2.1.5　异常处理类中断服务程序挂接48
2.1.6　初始化块设备请求项结构50
2.1.7　与建立人机交互界面相关的外设的中断服务程序挂接52
2.1.8　开机启动时间设置55
2.1.9　系统开始激活进程056
2.1.10　进程相关事务初始化设置57
2.1.11　时钟中断设置59
2.1.12　系统调用服务程序挂接59
2.1.13　初始化缓冲区管理结构61
2.1.14　初始化硬盘63
2.1.15　初始化软盘65
2.1.16　开中断66
2.2　进程创建的最基本动作67
2.2.1　操作系统为进程0创建进程1做准备67
2.2.2　在进程槽中为进程1 申请一个空闲位置并获取进程号71
2.2.3　复制进程信息之前，先将一些数据压栈73
2.2.4　初步设置进程1管理结构74
2.2.5　进程0创建进程1的过程中发生时钟中断76
2.2.6　从时钟中断返回78
2.2.7　调整进程1管理结构79
2.2.8　设置进程1的线性地址空间及物理页面81
2.2.9　继续调整进程1管理结构84
2.2.10　操作系统如何区分进程0和进程187
2.2.11　进程0准备切换到进程189
2.2.12　系统切换到进程1执行90
2.3　加载根文件系统92
2.3.1　进程1如何开始执行96
2.3.2　进程1开始执行98
2.3.3　进程1开始以数据块的形式操作硬盘99
2.3.4　将找到的缓冲块与请求项挂接101
2.3.5　将请求项与硬盘处理函数挂接104
2.3.6　进行硬盘读盘前的准备工作105
2.3.7　给硬盘下达读盘指令106
2.3.8　进程1由于等待读盘操作挂起107
2.3.9　系统切换到进程0执行109
2.3.10　进程0的执行过程110
2.3.11　进程0执行过程中发生硬盘中断111
2.3.12　硬盘中断服务程序响应后，进程0继续执行113
2.3.13　再次响应硬盘中断并唤醒进程1114
2.3.14　读盘操作完成后，进程1继续执行116
2.3.15　进程1继续设置硬盘管理结构117
2.3.16　进程1获取软盘超级块，为加载根文件系统做准备118
2.3.17　进程1备份超级块数据119
2.3.18　进程1将根文件系统从软盘拷贝到虚拟盘120
2.3.19　进程1开始加载根文件系统122
2.3.20　进程1准备加载根文件系统超级块123
2.3.21　进程1加载根文件系统超级块124
2.3.22　进程1继续加载根文件系统126
2.3.23　进程1准备读取根目录i节点127
2.3.24　进程1加载根目录i节点128
2.3.25　进程1结束加载根文件系统的过程129
2.4　打开终端设备文件及复制文件句柄131
2.4.1　进程1与内核文件表挂接，为打开文件做准备133
2.4.2　确定打开操作的起点135
2.4.3　获得枝梢i节点—dev目录文件的i节点136
2.4.4　确定dev目录文件i节点为枝梢i节点137
2.4.5　继续返回枝梢i节点138
2.4.6　查找tty0文件的i节点138
2.4.7　将tty0设备文件的i节点返回给sys_open系统调用 139
2.4.8　分析tty0文件i节点140
2.4.9　设置文件管理结构并返回给用户进程141
2.4.10　进程1复制tty0文件句柄142
2.4.11　进程1继续复制tty0文件句柄144
2.5　创建进程2145
2.5.1　进程1准备创建进程2145
2.5.2　复制进程2管理结构并进行调整146
2.5.3　设置进程2的页目录项并复制进程2的页表146
2.5.4　调整进程2管理结构中与文件有关的内容146
2.5.5　进程1执行过程中发生时钟中断148
2.5.6　进程1从时钟中断返回，准备切换到进程2150
2.6　进程1等待进程2退出150
2.6.1　进程1查找它自己的子进程151
2.6.2　对进程2的状态进行处理151
2.6.3　切换到进程2执行153
2.7　shell程序的加载154
2.7.1　进程2开始执行156
2.7.2　为打开/etc/rc文件做准备156
2.7.3　进程2打开“/etc/rc”配置文件157
2.7.4　通过压栈为加载shell文件做准备158
2.7.5　为参数和环境变量设置做准备159
2.7.6　得到shell文件的i节点160
2.7.7　为加载参数和环境变量做准备161
2.7.8　根据i节点，对shell文件进行检测162
2.7.9　检测shell文件头163
2.7.10　备份文件头并进行分析163
2.7.11　对shell文件进行进一步分析165
2.7.12　拷贝参数和环境变量166
2.7.13　调整进程2的管理结构167
2.7.14　继续调整进程2管理结构168
2.7.15　释放进程2继承的页面169
2.7.16　检测协处理器170
2.7.17　调整shell程序所在的线性空间地址171
2.7.18　为shell程序准备参数和环境变量172
2.7.19　继续调整进程2管理结构173
2.7.20　调整EIP，使其指向shell程序入口地址173
2.7.21　shell程序执行引发缺页中断175
2.7.22　缺页中断中shell程序加载前的检测175
2.7.23　为即将载入的内容申请页面177
2.7.24　将shell程序载入新获得的页面177
2.7.25　根据shell程序的情况，调整页面的内容178
2.7.26　将线性地址空间与程序所在的物理页面对应179
2.8　系统实现怠速180
2.8.1　shell进程准备创建update进程180
2.8.2　进程2开始执行/etc/rc文件181
2.8.3　准备加载update进程181
2.8.4　update进程的作用182
2.8.5　shell程序检测“/etc/rc”文件183
2.8.6　shell进程退出184
2.8.7　shell进程退出善后处理185
2.8.8　进程1清理shell进程管理结构187
2.8.9　系统开始重建shell190
2.8.10　shell进程为何不会再次退出192
2.9　小结194
第3章　安装文件系统195
3.1　获取硬盘设备号196
3.1.1　用户发出安装硬盘文件系统指令196
3.1.2　从分析路径开始，准备查找hd1设备的挂接点197
3.1.3　以根目录i节点为依托，得到dev目录文件的i节点197
3.1.4　从dev目录文件中找到代表hd1设备文件的目录项198
3.1.5　得到hd1设备文件的i节点号199
3.1.6　释放dev目录文件的相关内容200
3.1.7　得到hd1设备文件的i节点200
3.1.8　获得hd1设备的设备号200
3.1.9　释放hd1设备文件的i节点201
3.2　获取虚拟盘上的挂接点202
3.3　得到hd1设备文件的超级块202
3.3.1　准备读取hd1设备文件超级块203
3.3.2　为hd1设备文件的超级块找到存储位置203
3.3.3　初始化空闲超级块并加锁203
3.3.4　从硬盘获得hd1设备文件的超级块204
3.3.5　加载逻辑块位图和i节点位图205
3.4　将hd1设备文件与mnt目录文件的i节点挂接206
3.5　小结207
第4章　文件操作208
4.1　打开文件211
4.1.1　用户程序调用open库函数产生软中断212
4.1.2　建立用户进程与文件管理表的关系213
4.1.3　从硬盘上获取helloc.txt文件的i节点214
4.1.4　将helloc.txt文件与文件管理表相挂接226
4.2　读文件227
4.2.1　为按照用户要求读入文件做准备228
4.2.2　确定要读入的数据块的位置230
4.2.3　将指定的数据块从硬盘读入到高速缓冲块233
4.2.4　将数据拷贝到用户指定的内存234
4.3　新建文件237
4.3.1　查找路径“/mnt/user/hello.txt”238
4.3.2　为hello.txt文件新建一个i节点240
4.3.3　为hello.txt文件新建目录项242
4.3.4　完成hello.txt新建操作并返回给用户进程245
4.4　写文件246
4.4.1　文件写入前的准备工作248
4.4.2　确定hello.txt文件的写入位置249
4.4.3　为数据的写入申请缓冲块252
4.4.4　将指定的写入数据从用户数据区拷贝到缓冲块253
4.4.5　数据同步到硬盘的方法1255
4.4.6　将文件写入硬盘的情况2257
4.5　修改文件260
4.5.1　对文件的当前操作指针进行重定位261
4.5.2　对文件进行修改261
4.6　关闭文件263
4.6.1　当前进程与文件管理表“脱钩”264
4.6.2　将文件管理表中hello.txt对应的引用次数减1265
4.6.3　hello.txt文件与文件管理表“脱钩”266
4.7　删除文件268
4.7.1　系统准备删除hello.txt文件268
4.7.2　删除hello.txt文件在硬盘上对应的数据和i节点270
4.7.3　对hello.txt文件所在的user目录做处理275
4.8　本章小结275
第5章　用户进程与内存管理277
5.1　用户进程的创建277
5.1.1　为创建进程str1准备条件277
5.1.2　为str1进程管理结构找到存储空间279
5.1.3　复制str1进程管理结构281
5.1.4　确定str1进程在线性空间中的位置282
5.1.5　复制str1进程页表并设置其对应的页目录项283
5.1.6　调整str1进程中与文件相关的结构285
5.1.7　建立str1进程与全局描述符表GDT的关联286
5.1.8　将str1进程设为就绪态287
5.2　为用户进程str1的加载做准备288
5.2.1　为str1进程加载自身对应的程序做准备288
5.2.2　读取str1可执行文件的i节点并统计参数和环境变量289
5.2.3　读取str1可执行文件的文件头290
5.2.4　对str1可执行程序文件头进行分析291
5.2.5　拷贝str1可执行程序的参数和环境变量292
5.2.6　调整str1进程管理结构中可执行程序对应的i节点292
5.2.7　继续调整str1进程管理结构—文件和信号相关的字段293
5.2.8　释放str1进程的页表294
5.2.9　重新设置str1的程序代码段和数据段295
5.2.10　创建环境变量和参数指针表296
5.2.11　继续根据str1可执行程序情况调整str1进程管理结构297
5.2.12　设置str1可执行程序的栈指针和eip值297
5.3　对缺页中断的处理298
5.3.1　产生缺页中断并由操作系统响应298
5.3.2　为str1程序申请一个内存页面299
5.3.3　将str1程序加载到新分配的页面中300
5.3.4　检测是否需要对页面剩余空间清0300
5.3.5　将str1程序占用的物理内存地址与str1进程的线性地址空间对应301
5.3.6　不断通过缺页中断加载str1程序的全部内容301
5.3.7　str1程序需要压栈302
5.3.8　str1程序第一次调用foo程序压栈302
5.3.9　str1程序第二次压栈，产生缺页中断302
5.3.10　处理str1程序第二次压栈产生的缺页中断302
5.3.11　str1程序继续执行，反复压栈并产生缺页中断303
5.3.12　str1程序运行结束后清栈303
5.4　str1用户进程的退出305
5.4.1　str1进程准备退出305
5.4.2　释放str1程序所占页面305
5.4.3　解除str1程序与文件有关的内容并给父进程发信号306
5.4.4　str1程序退出后执行进程调度307
5.5　多个用户进程“同时”运行308
5.5.1　依次创建str1、str2和str3进程308
5.5.2　str1进程压栈的执行效果309
5.5.3　str1运行过程中产生时钟中断并切换到str2执行309
5.5.4　str2执行过程遇到时钟中断切换到str3执行310
5.5.5　三个程序执行一段时间后在主内存的分布格局311
5.6　进程的调度与切换311
5.6.1　str1刚被shell创建并处于就绪态311
5.6.2　shell进程将自己挂起,然后准备切换到str1执行311
5.6.3　准备切换到str1进程执行312
5.6.4　str1执行时发生时钟中断314
5.6.5　时钟中断递减str1运行的时间片315
5.6.6　str1执行一段时间后挂起，shell进程新建str2进程315
5.6.7　str2运行期间发生时钟中断316
5.6.8　系统切换到str1程序执行317
5.7　内核的分页318
5.7.1　为设置内核的页目录表和页表做准备—所占空间清0318
5.7.2　设置内核对应的页目录项和页表项的内容319
5.7.3　设置内核对应的全局描述符表GDT320
5.8　页写保护321
5.8.1　进程A和进程B共享页面321
5.8.2　进程A准备进行压栈操作322
5.8.3　进程A的压栈动作引发页写保护322
5.8.4　将进程A的页表指向新申请的页面323
5.8.5　拷贝原页面内容到进程A新申请的页面324
5.8.6　进程B准备操作共享页面325
5.8.7　假设进程B先执行压栈操作的情况325
5.9　小结326
第6章　多个进程“同时”操作一个文件327
6.1　三个进程操作同一个文件327
6.1.1　进程A执行，hello.txt文件被打开328
6.1.2　进程A读取hello.txt文件并由于等待硬盘中断而被系统挂起328
6.1.3　进程B准备打开hello.txt文件330
6.1.4　系统准备为进程B获取hello.txt文件的i节点332
6.1.5　系统找到hello.txt文件已经载入的i节点333
6.1.6　系统准备为进程B从硬盘上读取hello.txt文件334
6.1.7　系统找到了正在操作的缓冲块，将进程B挂起335
6.1.8　系统再次切换到进程0执行337
6.1.9　进程C启动并打开hello.txt文件337
6.1.10　进程C也由于等待缓冲块解锁而被系统挂起338
6.1.11　缓冲块解锁后先唤醒进程C339
6.1.12　系统将进程B设为就绪状态340
6.1.13　系统将指定数据写入缓冲块341
6.1.14　写入完成后，进程C继续执行341
6.1.15　进程C准备切换到进程B342
6.1.16　进程C切换到进程B执行，进程B唤醒进程A342
6.1.17　进程B不断执行，直到时间片减为0后切换到进程A执行343
6.1.18　进程A、B、C退出，写入数据由update进程同步344
6.2　缓冲区与外设的数据同步344
6.2.1　系统不断为进程A向缓冲区写入数据346
6.2.2　继续执行引发缓冲块数据需要同步346
6.2.3　将缓冲区中的数据同步到硬盘上347
6.2.4　进程A由于等待空闲请求项而被系统挂起349
6.2.5　进程B开始执行350
6.2.6　进程B也被挂起351
6.2.7　进程C开始执行并随后被挂起352
6.2.8　进程A和进程C均被唤醒352
6.2.9　进程B切换到进程A执行354
6.3　小结356
第7章　IPC问题358
7.1　管道机制358
7.1.1　为管道文件在文件管理表中申请空闲项360
7.1.2　为管道文件与进程建立联系创造条件360
7.1.3　创建管道文件i节点361
7.1.4　将管道文件i节点与文件管理表建立联系362
7.1.5　将管道文件句柄返回给用户进程363
7.1.6　读管道进程开始操作管道文件363
7.1.7　写管道进程向管道中写入数据364
7.1.8　写管道进程继续向管道写入数据366
7.1.9　写管道进程已将管道空间写满366
7.1.10　写管道进程挂起366
7.1.11　读管道进程从管道中读出数据367
7.1.12　读管道进程继续执行，不断从管道中读出数据369
7.1.13　读管道进程执行中发生时钟中断369
7.1.14　读管道进程执行过程中再次发生时钟中断370
7.1.15　读管道进程切换到写管道进程执行371
7.1.16　写管道进程挂起切换到读管道进程执行371
7.1.17　读管道进程继续执行，直到把管道中的数据读完372
7.1.18　读取完成后，读进程挂起，写进程继续执行373
7.2　信号机制374
7.2.1　processig进程开始执行376
7.2.2　processig进程进入可中断等待状态377
7.2.3　sendsig进程开始执行并向processig进程发信号379
7.2.4　系统检测当前进程接收到信号并准备处理381
7.2.5　系统检测信号处理函数指针挂接是否正常382
7.2.6　调整processig进程的内核栈结构，使之先执行信号处理函数383
7.2.7　信号对进程执行状态的影响386
7.3　小结393
第8章　操作系统的设计指导思想395
8.1　运行一个最简单的程序，看操作系统为程序运行做了哪些工作395
8.2　操作系统的设计指导思想—主奴机制398
8.2.1　主奴机制中的进程及进程创建机制399
8.2.2　操作系统在内存管理中的主奴机制400
8.2.3　操作系统在文件系统中体现的主奴机制401
8.3　实现主奴机制的三种关键技术402
8.3.1　保护和分页402
8.3.2　特权级405
8.3.3　中断405
8.4　建立主奴机制的决定性因素—先机407
8.5　软件和硬件的关系：主机与进程、外设与文件408
8.5.1　非用户进程—进程0、进程1、shell进程408
8.5.2　文件与数据存储409
8.6　父子进程共享页面414
8.7　操作系统的全局中断与进程的局部中断—信号414
8.8　小结415
结束语415
“新设计团队”简介416
附录　搭建Linux 0.11系统环境421
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux内核设计的艺术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大规模分布式系统架构与设计实战（含光盘）
前　言
第1章概述	1
1.1分布式计算、并行计算、云计算概述	1
1.2分布式产品Hadoop、ZooKeeper、HBase概述	6
1.3Fourinone的产生背景	12
第2章分布式并行计算的原理与实践	14
2.1分布式并行计算模式	14
2.1.1最初想到的master-slave结构	14
2.1.2“包工头-职介所-手工仓库-工人”模式	15
2.1.3基于消息中枢的计算模式	17
2.1.4基于网状直接交互的计算模式	18
2.1.5并行结合串行模式	22
2.1.6包工头内部批量多阶段处理模式	23
2.1.7计算集群模式和兼容遗留计算系统	24
2.1.8工人计算的服务化模式	26
2.2跟Hadoop的区别	28
2.3关于分布式的一些概念与产品	30
2.4配置文件和核心API介绍	35
2.5实践与应用	36
2.5.1一个简单的示例	36
2.5.2工头工人计算模式更完整的示例	39
2.5.3工人合并互相say hello的示例	44
2.5.4 实现Hadoop经典实例Word Count	48
2.5.5分布式多机部署的示例	52
2.5.6分布式计算自动部署的示例	53
2.5.7计算过程中的故障和容灾处理	57
2.5.8计算过程中的相关时间属性设置	60
2.5.9如何在一台计算机上一次性启动多个进程	63
2.5.10如何调用C/C++程序实现	68
2.5.11如何中止工人计算和超时中止	68
2.5.12使用并行计算大幅提升递归算法效率	73
2.5.13使用并行计算求圆周率π	81
2.5.14从赌钱游戏看PageRank算法	86
2.5.15使用并行计算实现上亿排序	96
2.5.16工人服务化模式应用示例	104
2.6实时流计算	107
第3章分布式协调的实现	111
3.1协调架构原理简介	111
3.2核心API	113
3.3权限机制	115
3.4相对于ZooKeeper的区别	116
3.5与Paxos算法的区别	117
3.6实践与应用	119
3.6.1如何实现公共配置管理	119
3.6.2如何实现分布式锁	126
3.6.3如何实现集群管理	129
3.6.4多节点权限操作示例	134
3.6.5领导者选举相关属性设置	137
第4章分布式缓存的实现	139
4.1小型网站或企业应用的缓存实现架构	139
4.2大型分布式缓存系统实现过程	140
4.3一致性哈希算法的原理、改进和实现	147
4.4解决任意扩容的问题	152
4.5解决扩容后数据均匀的问题	153
4.6分布式Session的架构设计和实现	154
4.7缓存容量的相关属性设置	156
4.8缓存清空的相关属性设置	158
第5章消息队列的实现	162
5.1闲话中间件与MQ	162
5.2JMS的两种经典模式	163
5.3如何实现发送接收的队列模式	164
5.4如何实现主题订阅模式	168
第6章分布式文件系统的实现	173
6.1FTTP架构原理解析 	174
6.2搭建配置FttpAdapter环境	177
6.3访问集群文件根目录	179
6.4访问和操作远程文件	181
6.5集群内文件复制和并行复制	184
6.6读写远程文件	187
6.7解析远程文件	189
6.8并行读写远程文件	191
6.9批量并行读写远程文件和事务补偿处理	194
6.10如何进行整型读写	198
6.11基于整型读写的上亿排序	205
第7章分布式作业调度平台的实现	219
7.1调度平台的设计与实现	219
7.2资源隔离的实现	224
7.3资源调度算法	226
7.4其他作业调度平台简介	227
7.4.1其他MPI作业资源调度技术	227
7.4.2Mesos和Yarn简介	229
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大规模分布式系统架构与设计实战（含光盘）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>人人都是架构师：分布式系统架构落地与瓶颈突破
第1章  分布式服务案例	1
1.1  分布式系统的架构演变过程	2
1.1.1  单机系统	3
1.1.2  集群架构	4
1.1.3  拆系统之业务垂直化	6
1.1.4  为什么需要实现服务化架构	8
1.1.5  服务拆分粒度之微服务	10
1.2  系统服务化需求	11
1.2.1  服务化与RPC协议	11
1.2.2  使用阿里分布式服务框架Dubbo实现服务化	12
1.2.3  警惕Dubbo因超时和重试引起的系统雪崩	16
1.2.4  服务治理方案	18
1.2.5  关于服务化后的分布式事务问题	20
1.3  分布式调用跟踪系统需求	21
1.3.1  Google的Dapper论文简介	22
1.3.2  基于Dubbo实现分布式调用跟踪系统方案	25
1.3.3  采样率方案	35
1.4  本章小结	37
第2章  大流量限流/消峰案例	38
2.1  分布式系统为什么需要进行流量管制	39
2.2  限流的具体方案	42
2.2.1  常见的限流算法	43
2.2.2  使用Google的Guava实现平均速率限流	45
2.2.3  使用Nginx实现接入层限流	48
2.2.4  使用计数器算法实现商品抢购限流	49
2.3  基于时间分片的消峰方案	51
2.3.1  活动分时段进行实现消峰	52
2.3.2  通过答题验证实现消峰	52
2.4  异步调用需求	53
2.4.1  使用MQ实现系统之间的解耦	54
2.4.2  使用Apache开源的ActiveMQ实现异步调用	55
2.4.3  使用阿里开源的RocketMQ实现互联网场景下的流量消峰	61
2.4.4  基于MQ方案实现流量消峰的一些典型案例	72
2.5  本章小结	75
第3章  分布式配置管理服务案例	76
3.1  本地配置	77
3.1.1  将配置信息耦合在业务代码中	77
3.1.2  将配置信息配置在配置文件中	79
3.2  集中式资源配置需求	82
3.2.1  分布式一致性协调服务ZooKeeper简介	83
3.2.2  ZooKeeper的下载与集群安装	84
3.2.3  ZooKeeper的基本使用技巧	86
3.2.4  基于ZooKeeper实现分布式配置管理平台方案	87
3.2.5  从配置中心获取Spring的Bean定义实现Bean动态注册	93
3.2.6  容灾方案	95
3.2.7  使用淘宝Diamond实现分布式配置管理服务	96
3.2.8  Diamond与ZooKeeper的细节差异	101
3.2.9  使用百度Disconf实现分布式配置管理服务	102
3.3  本章小结	110
第4章  大促场景下热点数据的读/写优化案例	111
4.1  缓存技术简介	112
4.1.1  使用Ehcache实现数据缓存	114
4.1.2  LocalCache存在的弊端	116
4.1.3  神秘的off-heap技术	117
4.2  高性能分布式缓存Redis简介	120
4.2.1  使用Jedis客户端操作Redis	121
4.2.2  使用Redis集群实现数据水平化存储	122
4.3  同一热卖商品高并发读需求	124
4.3.1  Redis集群多写多读方案	125
4.3.2  保障多写时的数据一致性	126
4.3.3  LocalCache结合Redis集群的多级Cache方案	128
4.3.4  实时热点自动发现方案	130
4.4  同一热卖商品高并发写需求	132
4.4.1  InnoDB行锁引起数据库TPS下降	132
4.4.2  在Redis中扣减热卖商品库存方案	134
4.4.3  热卖商品库存扣减优化方案	138
4.4.4  控制单机并发写流量方案	141
4.4.5  使用阿里开源的AliSQL数据库提升秒杀场景性能	142
4.5  本章小结	148
第5章  数据库分库分表案例	149
5.1  关系型数据库的架构演变	150
5.1.1  数据库读写分离	150
5.1.2  数据库垂直分库	151
5.1.3  数据库水平分库与水平分表	152
5.1.4  MySQL Sharding与MySQL Cluster的区别	153
5.2  Sharding中间件	154
5.2.1  常见的 Sharding中间件对比	155
5.2.2  Shark简介	156
5.2.3  Shark的架构模型	157
5.2.4  使用Shark实现分库分表后的数据路由任务	159
5.2.5  分库分表后所带来的影响	166
5.2.6  多机SequenceID解决方案	167
5.2.7  使用Solr满足多维度的复杂条件查询	170
5.2.8  关于分布式事务	172
5.3  数据库的HA方案	173
5.3.1  基于配置中心实现主从切换	174
5.3.2  基于Keepalived实现主从切换	176
5.3.3  保障主从切换过程中的数据一致性	179
5.4  订单业务冗余表需求	180
5.4.1  冗余表的实现方案	181
5.4.2  保障冗余表的数据一致性	183
5.5  本章小结	186
后记	187
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>人人都是架构师：分布式系统架构落地与瓶颈突破
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux系统架构和应用技巧
第1章　你必须知道的！Linux内部结构　　1
1.1　Linux的三大基础：磁盘、进程、内存　　2
1.2　磁盘和文件　　3
1.2.1　磁盘的3D参数　　3
1.2.2　新旧分区表　　7
UEFI和GPT　　8
4KB扇区的磁盘　　11
1.2.3　文件系统和I/O子系统　　12
文件系统的块大小　　12
I/O子系统的概貌　　15
理解I/O调度器　　17
1.3　控制进程就等于控制Linux　　22
1.3.1　fork和exec分别是进程的分身和变身　　22
1.3.2　作业控制中的各项任务处理　　28
1.3.3　快速的数据处理管道　　33
1.4　至关重要的内存管理　　41
1.4.1　物理内存的分配　　42
用户内存的分类　　43
内核内存的分类　　47
1.4.2　内存的分配和释放　　51
了解内存分配机制　　52
了解内存释放机制　　54
1.4.3　上下文切换和页表　　56
COLUMN　何为IT程序员的学习方法　　58
第2章　别说缺少机器！虚拟化基础设施环境的构建　　59
2.1　基础设施工程师的成长来自于日常积累　　60
2.2　LinuxKVM虚拟网络　　62
2.2.1　虚拟网络的构建和虚拟机的配置　　63
YUM资源库的准备　　64
虚拟网络的配置　　65
虚拟机的配置　　65
2.2.2　DNS服务器的搭建　　73
DNS和邮件传输系统的基础知识　　73
BIND的安装和配置　　80
2.2.3　邮件服务器的建立　　87
2.3　HA集群环境在虚拟机上的实现　　94
2.3.1　对HAAdd-on的理解　　95
HA集群的基础　　95
HAAdd-On的工作原理　　97
2.3.2　Linux主机的准备以及虚拟机的构建　　99
虚拟网络的配置　　100
iSCSI目标的构建　　101
虚拟机的构建　　103
2.3.3　HAAdd-On的导入和配置　　105
包集合的导入和配置　　105
集群配置文件的准备　　106
HA集群的启动和服务的开始　　111
模拟故障测试的实现　　114
2.3.4　HA集群设计及运用的准备　　117
COLUMN　IT架构师与补习班讲师的沟通技巧　　119
第3章　10轮决胜！在自编的脚本中灵活使用命令　　121
3.1　简单有效的Shell脚本　　122
3.2　Shell脚本的基本规则　　123
3.2.1　Shell脚本的操作确认　　123
3.2.2　引号的使用方法　　125
3.2.3　条件判断的写法　　126
3.2.4　数组和位置参数的使用方法　　130
3.2.5　命令置换和数值演算　　131
3.3　用Shell脚本一决胜负　　133
3.3.1　[第1轮对决]　在跳板服务器上学到的秘籍~基本模式+异常处理　　133
3.3.2　[第2轮对决]　在分布式Shell上学到的秘籍~基本模式+管道　　138
3.3.3　[第3轮对决]　在进程监视中学到的秘籍~状态迁移处理　　144
3.3.4　[第4轮对决]　秘籍外传~由make命令进行简单的批处理　　148
3.3.5　[第5轮对决]　从模拟快照（snapshot）学到的秘籍~用管道操作日志　　151
3.3.6　[第6轮对决]　在云备份中学到的秘籍~在思考实验中组合处理流程　　155
3.4　Perl脚本的对决　　　　164
3.4.1　[第7轮对决]　自己编写Perl的乐趣　　164
3.4.2　[第8轮对决]　通过Tweet体验Perl带来的便利　　175
3.4.3　[第9轮对决]　用进程监控掌握fork　　178
3.4.4　[第10轮对决]　终极秘籍Perl与管道的结合　　183
COLUMN　造福于开源IT工程师的力量　　188
第4章　最后的堡垒！内核源代码的阅读　　189
4.1　阅读源代码　　190
4.2　内核源代码的走读方法　　191
4.2.1　Linux内核的构建步骤　　191
4.2.2　内核源代码探索入门　　195
4.2.3　读懂结构体和指针　　200
COLUMN　跳槽、英语、结婚——IT工程师的话题关键词　　207
4.3　探索核心子系统　　208
4.3.1　进程管理子系统　　208
不断演化的进程状态管理　　208
系统调用ptrace()　　213
list_head与神奇的宏　　216
4.3.2　内存管理子系统　　221
64位环境中的页映射　　222
/proc/meminfo的“内脏”　　228
4.4　内核源代码的分析实例　　235
4.4.1　Linux内核的系统时间　　235
4.4.2　闰秒发生的瞬间　　238
4.4.3　进一步探索的指南　　249
第5章　先行一步！RHEL6新功能综述　　251
5.1　支持商品化硬件的“操作系统进化”　　252
5.1.1　ext4文件系统的采用　　253
5.1.2　NetworkManager服务的引入　　254
5.1.3　用dracut创建初始RAM磁盘　　256
5.1.4　通过anacron实现定期任务执行　　260
5.2　对服务器启动处理进行变革的Upstart　　　　264
5.2.1　Upstart的概要　　264
5.2.2　Upstart任务的创建示例　　268
5.3　用Control　Groups控制资源分配　　271
5.3.1　Control　Group的概要　　271
5.3.2　各子系统的主要参数　　273
cpuset子系统　　273
cpu子系统　　275
memory子系统　　276
blkio子系统　　276
5.3.3　cg命令群的管理　　279
5.3.4　虚拟机的cgroups操作　　281
5.4　通过LXC体验容器型虚拟化技术　　282
5.4.1　容器型虚拟化技术的概要　　283
进程表的分割　　283
文件系统的分割　　284
网络的分割　　284
CPU和内存的分割　　285
5.4.2　容器中Web服务器的启动　　285
5.4.3　其他的容器设置　　289
COLUMN　“人生20年论”和技能提高的秘诀　　291
结语　　292
参考文献　　293
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux系统架构和应用技巧
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大话存储Ⅱ
第1章 混沌初开——存储系统的前世今生
第2章 IO大法——走进计算机IO世界
第3章 磁盘大挪移——磁盘原理与技术详解
第4章 七星北斗——大话详解七种RAID
第5章 降龙传说——RAID、虚拟磁盘、卷和文件系统实战
第6章 阵列之行——大话磁盘阵列
第7章 熟读宝典——系统与系统之间的语言OSI
第8章 勇破难关——Fibre Channel协议详解
第9章 天翻地覆——FC协议的巨大力量
第10章 三足鼎立——DAS、SAN和NAS
第11章 大师之作——大话以太网和TCP/IP协议
第12章 异军突起——存储网络的新军IP SAN
第13章 握手言和——IP与FC融合的结果
第14章 变幻莫测——虚拟化
第15章 众志成城——存储集群
第16章 未雨绸缪——数据保护和备份技术
第17章 愚公移山——大话数据容灾
第18章 鬼斧神工——数据前处理与后处理
第19章 过关斩将——系统IO路径及优化
第20章 腾云驾雾——大话云存储
附录
后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大话存储Ⅱ
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据架构商业之路
推荐序一
推荐序二
前　　言
第1章　抉择 1
第2章　数据收集 4
2.1　互联网数据收集 4
2.1.1　网络爬虫 5
2.1.2　Apache Nutch简介 11
2.1.3　Heritrix简介 14
2.2　内部数据收集 15
2.2.1　Apache Flume简介 17
2.2.2　Facebook Scribe和Logstash 21
2.3　本章心得 21
2.4　参考资料 22
第3章　数据存储 23
3.1　持久化存储 23
3.1.1　Hadoop和HDFS 25
3.1.2　HBase简介 28
3.1.3　MongoDB 35
3.2　非持久化存储 37
3.2.1　缓存和散列 37
3.2.2　Memcached和Berkeley DB简介 41
3.2.3　Redis简介 41
3.3　本章心得 44
3.4　参考资料 44
第4章　数据处理 46
4.1　离线批量处理 46
4.1.1　Hadoop的MapReduce 47
4.1.2　Spark简介 52
4.1.3　Hive简介 53
4.1.4　Pig、Impala和Spark SQL 56
4.2　提升及时性：消息机制 58
4.2.1　ActiveMQ简介 60
4.2.2　Kafka简介 61
4.3　在线实时处理 63
4.3.1　Storm简介 63
4.3.2　Spark Streaming简介 66
4.4　本章心得 66
4.5　参考资料 67
第5章　信息检索 69
5.1　基本理念 70
5.2　相关性 70
5.2.1　布尔模型 70
5.2.2　基于排序的布尔模型 71
5.2.3　向量空间模型 74
5.2.4　语言模型 75
5.3　及时性 77
5.4　与数据库查询的对比 81
5.5　搜索引擎 82
5.5.1　Web搜索中的链接分析 83
5.5.2　电子商务中的商品排序 86
5.5.3　多因素和基于学习的排序 88
5.5.4　系统框架 89
5.5.5　Lucene简介 93
5.5.6　Solr简介 98
5.5.7　Elasticsearch简介 104
5.6　推荐系统 108
5.6.1　推荐的核心要素 109
5.6.2　推荐系统的分类 110
5.6.3　混合模型 115
5.6.4　系统架构 116
5.6.5　Mahout 116
5.7　在线广告 119
5.8　本章心得 127
5.9　参考资料 128
第6章　数据挖掘 130
6.1　基本理念 131
6.2　数据的表示和预处理 133
6.3　机器学习算法 136
6.4　挖掘工具 157
6.5　本章心得 165
6.6　参考资料 165
第7章　效能评估 167
7.1　效果评估 168
7.2　性能评估 190
7.3　本章心得 202
7.4　参考资料 202
第8章　大数据技术全景 204
第9章　商品太多啦！需要搜索引擎 207
9.1　业务需求 207
9.2　产品设计和技术选型 208
9.3　实现方案 211
第10章　能否更主动？还需要推荐引擎 223
10.1　业务需求 223
10.2　产品设计和技术选型 225
10.3　实现方案 230
第11章　这样做的效果如何 241
11.1　业务需求 241
11.2　产品设计和技术选型 242
11.3　实现方案 243
第12章　这个搜索有点逊 258
12.1　业务需求：还要搜得更多 258
12.2　“还要搜得更多”：产品设计和技术选型 259
12.3　“还要搜得更多”的方案实现 261
12.4　业务需求：还要搜得更准 265
12.5　“还要搜得更准”：产品设计和技术选型 266
12.6　“还要搜得更准”的方案实现 271
12.7　业务需求：还要更快 273
12.8　还要“变”得更快：产品设计和技术选型 274
12.9　还要“搜”得更快：产品设计和技术选型 275
12.10　业务需求：给点提示吧 280
12.11　给点提示吧：产品设计和技术选型 282
第13章　支持更高效的运营 287
13.1　业务需求：互联网时代的CRM 287
13.2　互联网时代的CRM：产品设计和技术选型 288
13.3　业务需求：抓住捣蛋鬼 291
13.4　抓住捣蛋鬼：产品设计和技术选型 292
13.5　业务需求：销售之战 295
13.6　销售之战：产品设计和技术选型 296
后记 299
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据架构商业之路
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向模式的软件架构. 第2卷
目　录

第1章　并发与联网对象　　1
1.1 　驱动因素　　1
1.2 　并发与联网软件面临的挑战　　4
1.2.1 　挑战1：服务访问与配置　　6
1.2.2 　挑战2：事件处理　　9
1.2.3 　挑战3：并发　　11
1.2.4 　挑战4：同步　　13
1.2.5 　联网软件的其他挑战　　14
1.3 　案例研究：设计一个并发的Web服务器程序　　16
1.3.1 　JAWS框架概况　　17
1.3.2 　使用模式解决JAWS中常见的设计挑战　　18
1.3.3 　封装底层的操作系统API　　19
1.3.4 　将事件分离与连接管理同协议处理分离　　20
1.3.5 　通过多线程按比例提升服务器程序的性能　　21
1.3.6 　实现同步请求队列　　23
1.3.7 　最小化服务器程序的线程开销　　24
1.3.8 　有效利用异步I/O　　25
1.3.9 　增强服务器程序的可配置性　　27
1.3.10 　其他用于实现JAWS的模式　　28
1.4 　小结　　29
第2章　服务访问和配置模式　　31
2.1 　Wrapper Facade　　32
2.2 　Component Configurator　　51
2.3 　Interceptor　　73
2.4 　Extension Interface　　95
第3章　事件处理模式　　119
3.1 　Reactor　　120
3.2 　Proactor　　146
3.3 　Asynchronous Completion Token　　178
3.4 　Acceptor-Connector　　195
第4章　同步模式　　223
4.1 　Scoped Locking　　224
4.2 　Strategized Locking　　230
4.3 　Thread-Safe Interface　　238
4.4 　Double-Checked Locking Optimization　　244
第5章　并发模式　　253
5.1 　Active Object模式　　254
5.2 　Monitor Object模式　　275
5.3 　Half-Sync/Half-Async模式　　292
5.4 　Leader/Followers模式　　306
5.5 　Thread-Specific Storage模式　　324
第6章　模式的综合运用　　345
6.1 　从单个模式到模式语言　　345
6.1.1 　没有模式是一座孤岛　　345
6.1.2 　模式语言的形成　　347
6.2 　面向中间件和应用程序的模式语言　　348
6.2.1 　模式语言的细节　　348
6.2.2 　模式语言之我见　　355
6.3 　并发与联网之余　　356
6.3.1 　图形用户接口　　356
6.3.2 　组件　　357
6.3.3 　通用编程　　357
6.4 　模式语言与模式系统　　358
第7章　模式的过去、现在及未来　　361
7.1 　过去四年中模式的发展　　361
7.1.1 　模式　　361
7.1.2 　模式系统和模式语言　　362
7.1.3 　方法和工具　　363
7.1.4 　算法和数据结构　　363
7.1.5 　模式的形式化　　363
7.2 　模式的发展现状　　364
7.3 　模式的未来发展趋势　　365
7.3.1 　模式　　365
7.3.2 　模式语言　　367
7.3.3 　经验报告、方法与工具　　368
7.3.4 　模式文档　　368
7.3.5 　模式与模式语言的形式化　　369
7.3.6 　软件开发流程与组织　　369
7.3.7 　教育　　369
7.3.8 　我们的长期愿景　　370
7.4 　关于预测未来的最后一点想法　　370
第8章　结束语　　372
8.1 　术语表　　373
8.2 　符号　　385
8.2.1 　类－职责－协作者卡片　　385
8.2.2 　UML类图　　385
8.2.3 　UML时序图　　386
8.2.4 　UML 状态图　　388
参考文献　　390
索引　　414

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向模式的软件架构. 第2卷
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>RocketMQ技术内幕
推荐序
前言
第1章 阅读源代码前的准备 1
1.1 获取和调试RocketMQ的源代码 1
1.1.1 Eclipse获取RocketMQ源码 2
1.1.2 Eclipse调试RocketMQ源码 9
1.1.3 IntelliJ IDEA获取RocketMQ源码 15
1.1.4 IntelliJ IDEA调试RocketMQ源码 20
1.2 RocketMQ源代码的目录结构 27
1.3 RocketMQ的设计理念和目标 28
1.3.1 设计理念 28
1.3.2 设计目标 28
第2章 RocketMQ路由中心NameServer 31
2.1 NameServer架构设计 31
2.2 NameServer启动流程 32
2.3 NameServer路由注册、故障剔除 36
2.3.1 路由元信息 36
2.3.2 路由注册 38
2.3.3 路由删除 43
2.3.4 路由发现 46
2.4 本章小结 47
第3章 RocketMQ消息发送 49
3.1 漫谈RocketMQ消息发送 49
3.2 认识RocketMQ消息 50
3.3 生产者启动流程 51
3.3.1 初识DefaultMQProducer消息发送者 51
3.3.2 消息生产者启动流程 54
3.4 消息发送基本流程 56
3.4.1 消息长度验证 56
3.4.2 查找主题路由信息 56
3.4.3 选择消息队列 60
3.4.4 消息发送 65
3.5 批量消息发送 71
3.6 本章小结 74
第4章 RocketMQ消息存储 75
4.1 存储概要设计 75
4.2 初识消息存储 76
4.3 消息发送存储流程 78
4.4 存储文件组织与内存映射 83
4.4.1 MappedFileQueue映射文件队列 84
4.4.2 MappedFile内存映射文件 87
4.4.3 TransientStorePool 93
4.5 RocketMQ存储文件 94
4.5.1 Commitlog文件 95
4.5.2 ConsumeQueue文件 97
4.5.3 Index索引文件 100
4.5.4 checkpoint文件 104
4.6 实时更新消息消费队列与索引文件 105
4.6.1 根据消息更新ConumeQueue 107
4.6.2 根据消息更新Index索引文件 108
4.7 消息队列与索引文件恢复 109
4.7.1 Broker正常停止文件恢复 112
4.7.2 Broker异常停止文件恢复 114
4.8 文件刷盘机制 115
4.8.1 Broker同步刷盘 116
4.8.2 Broker异步刷盘 119
4.9 过期文件删除机制 122
4.10 本章小结 126
第5章 RocketMQ消息消费 127
5.1 RocketMQ消息消费概述 127
5.2 消息消费者初探 128
5.3 消费者启动流程 130
5.4 消息拉取 133
5.4.1 PullMessageService实现机制 133
5.4.2 ProcessQueue实现机制 136
5.4.3 消息拉取基本流程 138
5.5 消息队列负载与重新分布机制 154
5.6 消息消费过程 162
5.6.1 消息消费 163
5.6.2 消息确认(ACK) 167
5.6.3 消费进度管理 171
5.7 定时消息机制 176
5.7.1 load方法 177
5.7.2 start方法 178
5.7.3 定时调度逻辑 179
5.8 消息过滤机制 181
5.9 顺序消息 186
5.9.1 消息队列负载 187
5.9.2 消息拉取 187
5.9.3 消息消费 188
5.9.4 消息队列锁实现 195
5.10 本章小结 196
第6章 消息过滤FilterServer 198
6.1 ClassFilter运行机制 198
6.2 FilterServer注册剖析 199
6.3 类过滤模式订阅机制 202
6.4 消息拉取 205
6.5 本章小结 206
第7章 RocketMQ主从同步(HA)机制 207
7.1 RocketMQ主从复制原理 207
7.1.1 HAService整体工作机制 208
7.1.2 AcceptSocketService实现原理 208
7.1.3 GroupTransferService实现原理 210
7.1.4 HAClient实现原理 211
7.1.5 HAConnection实现原理 214
7.2 RocketMQ读写分离机制 220
7.3 本章小结 223
第8章 RocketMQ事务消息 225
8.1 事务消息实现思想 225
8.2 事务消息发送流程 226
8.3 提交或回滚事务 232
8.4 事务消息回查事务状态 233
8.5 本章小结 240
第9章 RocketMQ实战 242
9.1 消息批量发送 242
9.2 消息发送队列自选择 243
9.3 消息过滤 243
9.3.1 TAG模式过滤 244
9.3.2 SQL表达模式过滤 244
9.3.3 类过滤模式 245
9.4 事务消息 247
9.5 Spring整合RocketMQ 250
9.6 Spring Cloud整合RocketMQ 251
9.7 RocketMQ监控与运维命令 258
9.7.1 RocktetMQ监控平台搭建 258
9.7.2 RocketMQ管理命令 261
9.8 应用场景分析 280
9.9 本章小结 281
附录A 参数说明 282
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>RocketMQ技术内幕
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据时代的IT架构设计
第1 篇 Hadoop 平台应用架构
Hadoop 技术在电信运营商上网日志处理中的应用架构／方建国............... 2
Hadoop 平台在金融银行业的应用架构／薛强彦................. 9
优酷土豆Hadoop 平台开放之路／傅杰....................... 16
第2 篇 推荐系统架构
腾讯个性化精准推荐平台架构／洪坤乾............... 28
社交网络大数据挖掘与社会化推荐引擎的构建／邓雄.............. 42
第3 篇 应用架构实践
微博用户兴趣建模系统架构／张俊林.............. 58
针对移动互联网应用的网络建设和优化／李永斌......... 65
西门子系统架构管理实践／李伟.................. 80
如何构建高性能、稳定的SOA 应用／汪洋............ 91
基于开源技术的网络安全架构实践／李晨光..................106
TOGAF 应用架构设计落地之道／温昱.....................120
分布式系统安全设计解决方案／汪洋............129
第4 篇 大数据下的存储实践
淘宝海量文件存储实践／张友东.......................136
内存作为统一存储实践／尹伟铭.....................145
第5 篇 数据库架构实践
数据库优化精髓暨数据架构最佳实践／侯圣文..............154
Oracle、MySQL 还是NoSQL／简朝阳.................162
SQL Server 中的高可用性／宋沄剑.......................169
第6 篇 大数据下的IT 架构变迁
京东商城网站架构演变／王晓钟..............................180
庶民架构——新浪视频后台架构变迁／郝光普....................189
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据时代的IT架构设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向模式的软件架构 卷5
第0 章  尘埃落定　　1
0.1  渊源　　1
0.2  成功与失败　　 2
0.2.1  观察　　2
0.2.2  状态　　3
0.2.3  处方　　4
0.3  模式定义及解释　　5
0.4  深入理解模式　　11
第一部分  模式剖析
第1 章  问题之解决方案及其他　　15
1.1  问题之解决方案　　15
1.1.1  一个例子（1） 　　15
1.1.2  重现与良好　　16
1.2  流程和物件　　16
1.3  “好”的解决方案　　17
1.4  驱动力：模式之心脏　　19
1.4.1  一个例子（4） 　　19
1.4.2  dysfunctional、bad 还是anti 　　21
1.5  上下文　　22
1.5.1  一个例子（5） 　 23
1.5.2  上下文的一般性　　23
1.5.3  独立上下文　　24
1.5.4  一个例子（6） 　 25
1.6  一般性　　 25
1.7  一图胜（逊）千言　　 27
1.8  模式命名　　29
1.8.1  模式命名的语法分类　　30
1.8.2  字面命名还是隐喻　　 30
1.9  模式是循序渐进的　　 31
1.10  模式既是讲故事，又能发起对话　　33
1.11  模式不能代替思考　　 33
1.12  从“问题—解决方案”到模式　　34
第2 章  多种多样的模式实现　　35
2.1  是否存在一个通用的模型呢　　35
2.1.1  Observer 模式：快速回顾　　36
2.1.2  结构的变化与角色　　36
2.1.3  行为的变化　　37
2.1.4  内部差异　　38
2.1.5  语言及平台的差别　　39
2.1.6  领域、环境相关的变化　40
2.1.7  再论假设　　41
2.2  模式与框架　　42
2.2.1  工具和上下文环境　　44
2.2.2  两个框架的故事　　44
2.3  模式与形式主义　　47
2.4  通用性与特殊性　　48
第3 章  模式格式　　50
3.1  风格与实质　　50
3.2  格式的功能　　52
3.3  格式的元素　　53
3.4  细节　　55
3.4.1  案例　　56
3.4.2  图示　　57
3.4.3  <code>…</code> 　　57
3.5  鸟瞰图　　 58
3.5.1  从金字塔到托盘　　58
3.5.2  模式骨架　　58
3.5.3  总结意图　　60
3.5.4  模式抽象　　60
3.6  不同的格式　　60
3.6.1  演变　　61
3.6.2  选择　　62
3.7  风格与实质（Redux） 　　63
第二部分  模式之间的关系
第4 章  模式孤岛　　 67
4.1  模式的联系　　67
4.2  设计实验：将模式作为孤岛　　68
4.3  第二个设计实验：交织在一起的模式　　72
4.4  模式密度　　73
第5 章  模式的互补性　　 75
5.1  一个问题，多种解决方案　　75
5.2  互相竞争的模式　　76
5.2.1  以状态为例　　76
5.2.2  模式族　　79
5.2.3  迭代开发　　80
5.2.4  适配开发　　83
5.2.5  遵从康威定律　　84
5.2.6  与风格的设计对话　　86
5.3  互相合作的模式　　87
5.3.1  一个关于值的例子　　88
5.3.2  设计上的完善　　 88
5.4  模式结合　　89
5.4.1  再论迭代　　89
5.4.2  再论适配编程　　91
5.5  互补性：竞争、完善、结合　　92
第6 章  模式复合　　93
6.1  常见模式排列　　93
6.2  从元素到复合　　93
6.2.1  Pluggable Factory 　　94
6.2.2  Composite Command 的两种视角　　95
6.2.3  模式复合的格式　　 96
6.3  从补充到复合　　97
6.3.1  重申　　 97
6.3.2  适配　　 99
6.4  是元素还是组合　　100
6.4.1  组合的含义　　100
6.4.2  深入MVC　　101
6.5  复合分析与综合　　102
6.5.1  非设计模式的复合　　102
6.5.2  设计模式复合　　103
第7 章  模式序列　　104
7.1  模式讲述软件工程成功的故事　　104
7.2  模式故事　　105
7.2.1  一个小故事　　105
7.2.2  已经发表的故事　　107
7.3  从故事到序列　　108
7.4  模式的序列　　109
7.4.1  一个早期的例子　　110
7.4.2  模式序列既是流程也是物件　　110
7.4.3  再次回到以前提到的小故事　　111
7.5  回顾模式复合和模式互补　　112
7.5.1  重组　　112
7.5.2  再论Batch Iterator 　　113
7.5.3  再论Interpreter 　　　114
7.5.4  再论Align Architecture andOrganization 　　115
7.6  回到上下文的问题　　 116
7.6.1  定义上下文　　116
7.6.2  专用化与差异化　　118
7.7  模式间的联系　　118
第8 章  模式集合　　120
8.1  模式手册　　120
8.2  组织模式集合　　121
8.3  即时组织　　121
8.4  根据层次组织　　122
8.4.1  设计和架构　　122
8.4.2  惯用法　　 123
8.4.3  混合层次　　124
8.4.4  层次　　124
8.5  根据领域组织　　125
8.6  根据分区组织　　125
8.6.1  阶层架构　　126
8.6.2  分区　　126
8.7  根据意图组织　　126
8.7.1  根据意图划分POSA 的模式　　127
8.7.2  根据意图划分GoF 的模式　　128
8.7.3  根据意图划分DDD 模式　　128
8.7.4  反思模式意图　　128
8.8  组织模式集合（重奏）　　 128
8.9  问题框架　　 129
8.9.1  问题框架　　130
8.9.2  问题框架和模式的对比　　 131
8.9.3  问题框架与模式的组合　　 132
8.10  模式符号学　　132
8.11  模式集合与风格　　134
8.11.1  Unix 接口设计模式　　135
8.11.2  Web 2.0 设计模式　　136
8.11.3  风格与概念一致性　　137
8.12  走向模式语言　　138
第三部分  模式语言
第9 章  语言的元素　　141
9.1  使用模式进行设计　　 141
9.2  从模式故事和模式序列到模式语言　　 142
9.2.1  一个未完成的故事　　143
9.2.2  序列的组合　　145
第10 章  模式网络及其他　　147
10.1  模式网络　　147
10.2  流程与物件　　147
10.2.1  流程的迭代本质　　 148
10.2.2  具体的面向领域的引导　　152
10.3  单项最佳　　153
10.4  驱动力：模式语言之心脏　　155
10.5  模式上下文定义拓扑结构与架构风格　　 158
10.6  模式构成词汇，序列展示语法　　 159
10.7  通用性　　162
10.7.1  不同的模式序列　　162
10.7.2  模式的组合　　163
10.8  完整的语言胜过千幅图　　163
10.9  面向领域的命名帮助忆起模式语言　　164
10.10  模式语言展开对话并讲述很多故事　　165
10.11  路还很长　　165
10.12  模式语言对创造性智慧的回报　　167
10.13  从模式网络到模式语言　　 168
第11 章  亿万种不同的实现　　169
11.1  众口难调　　169
11.2  渐进式成长　　169
11.2.1  面向系统的、进化的设计方法　　170
11.2.2  渐进式成长和敏捷开发　　171
11.3  并没有排斥重构　　172
11.4  一次一个模式　　174
11.4.1  明白手头上的问题的关键　　 174
11.4.2  优先级驱动的设计决策　　175
11.4.3  模式集成先于模式实现　　175
11.5  基于角色的模式集成　　176
11.5.1  选择1：识别并且保持已经实现的角色　　176
11.5.2  选择2：识别并分离已经实现的角色　　177
11.5.3  选择3：将缺失角色分配给既有设计元素　　178
11.5.4  选择4：将缺失角色作为新设计元素来实现　　179
11.5.5  基于角色的模式集成和渐进式成长过程　　180
11.6  模式语言和参考架构　　180
11.7  模式语言与产品线架构　　181
11.8  从十亿个到一个……再到一些　　184
第12 章  模式语言的格式　　185
12.1  风格与本质　　185
12.2  格式的作用　　185
12.3  格式的元素　　186
12.3.1  展示全貌　　187
12.3.2  简洁与细节　　187
12.3.3  模式连接　　189
12.3.4  再说元素　　189
12.4  细节，细节，细节　　 190
12.4.1  模式语言的格式　　 190
12.4.2  鸟瞰图　　 190
12.4.3  展示顺序　　194
12.4.4  示例　　194
12.4.5  细节程度　　195
12.5  再论风格与本质　　 197
第13 章  模式与模式语言　　198
13.1  模式和模式语言：共性　　198
13.1.1  共同的核心属性　　198
13.1.2  共同的根源　　199
13.1.3  一个模式的模式语言　　199
13.2  模式与模式语言：区别　　200
13.2.1  模式和细节　　 200
13.2.2  模式语言和交互　　200
13.2.3  两个独立的世界　　201
13.3  模式“对”模式语言　　201
第14 章  从模式到人　　202
14.1  模式以人为本　　 202
14.1.1  模式价值体系　　 203
14.1.2  人类读者　　 204
14.2  对软件开发者的支持　　204
14.3  对软件使用者的支持　　206
14.3.1  用户界面　　206
14.3.2  用户需求　　206
14.3.3  交到用户手中　　207
14.4  对模式作者的支持　　 207
14.4.1  协同写作　　 207
14.4.2  作者研讨会　　208
14.4.3  牧放　　208
14.5  技术为人　　209
第15 章  模式的过去、现在和未来　　210
15.1  过去的3 年　　210
15.1.1  模式与模式语言　　 210
15.1.2  理论和概念　　212
15.1.3  重构与集成　　212
15.1.4  GoF　　 213
15.2  模式的现状　　213
15.3  模式的明天在哪里　　 214
15.3.1  模式与模式语言　　 214
15.3.2  理论和概念　　216
15.3.3  重构与集成　　216
15.3.4  支持其他的软件开发方法　　 216
15.3.5  对其他学科的影响　　217
15.3.6  其他学科对我们的影响　　217
15.4  简述模式的未来　　218
第16 章  万事如意　　219
模式概念总结　　 221
参考模式　　 225
参考文献　　238
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向模式的软件架构 卷5
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>jQuery 技术内幕
第1章  总体架构	1
1.1 设计理念	1
1.2 总体架构	1
1.3 自调用匿名函数	4
1.4 总结	6
第2章  构造 jQuery 对象	6
2.1 构造函数 jQuery()	7
2.1.1 jQuery( selector [, context] )	7
2.1.2 jQuery( html [, ownerDocument] )、jQuery( html, props )	8
2.1.3 jQuery( element )、jQuery( elementArray )	9
2.1.4 jQuery( object )	9
2.1.5 jQuery( callback )	10
2.1.6 jQuery( jQuery object )	10
2.1.7 jQuery()	10
2.2 总体结构	10
2.3 jQuery.fn.init( selector, context, rootjQuery )	13
2.3.1 12个分支	13
2.3.2 源码分析	14
2.3.3 小结	24
2.4 jQuery.buildFragment( args, nodes, scripts )	24
2.4.1 实现原理	24
2.4.2 源码分析	25
2.4.3 小结	30
2.5 jQuery.clean( elems, context, fragment, scripts )	31
2.5.1 实现原理	31
2.5.2 源码分析	32
2.5.3 小结	48
2.6 jQuery.extend()、jQuery.fn.extend()	48
2.6.1 如何使用	48
2.6.2 源码分析	49
2.7 原型属性和方法	53
2.7.1 .selector、.jquery、.length、.size()	54
2.7.2 .toArray()、.get( [index] )	55
2.7.3 .each( function(index, Element) )、jQuery.each( collection, callback(indexInArray, valueOfElement) )	56
2.7.4 .map( callback(index, domElement) )、jQuery.map( arrayOrObject, callback( value, indexOrKey ) )	59
2.7.5 .pushStack( elements, name, arguments )	62
2.7.6 .end()	64
2.7.7 .eq( index )、.first()、.last()、.slice( start [, end] )	64
2.7.8 .push( valur, ... )、.sort( [orderfunc] )、.splice( start,deleteCount, value, ... )	65
2.7.9 小结	66
2.8 静态属性和方法	67
2.8.1 jQuery.noConflict( [removeAll] )	69
2.8.2 类型检测：jQuery.isFunction( obj )、jQuery.isArray( obj )、jQuery.isWindow( obj )、jQuery.isNumeric( value )、jQuery.type( obj )、jQuery.isPlainObject( object )、jQuery.isEmptyObject( object )	70
2.8.3 解析 JSON 和 XML：jQuery.parseJSON( data)、jQuery.parseXML( data )	75
2.8.4 jQuery.globalEval( code )	81
2.8.5 jQuery.camelCase ( string )	82
2.8.6 jQuery.nodeName ( elem, name )	83
2.8.7 jQuery.trim( str )	84
2.8.8 数组操作方法：jQuery.makeArray( obj )、jQuery.inArray( value, array [, fromIndex] )、jQuery.merge( first, second )、jQuery.grep( array, function(elementOfArray, indexInArray) [, invert] )	85
2.8.9 jQuery.guid、jQuery.proxy( function, context )	91
2.8.10 jQuery.access( elems, key, value, exec, fn( elem, key, value ), pass )	94
2.8.11 jQuery.error( message )、jQuery.noop()、jQuery.now()	96
2.8.12 浏览器嗅探：jQuery.uaMatch( ua )、jQuery.browser	96
2.8.13 小结	98
2.9 总结	100
第3章  选择器 Sizzle	100
3.1 总体结构	101
3.2 选择器表达式	104
3.3 设计思路	105
3.4 Sizzle( selector, context, results, seed )	107
3.5 正则 chunker	119
3.6 Sizzle.find( expr, context, isXML )	121
3.7 Sizzle.filter( expr, set, inplace, not )	124
3.8 Sizzle.selectors.relative	129
3.8.1 "+"	130
3.8.2 ">"	132
3.8.3 ""	133
3.8.4 "~"	134
3.8.5 dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML )	135
3.8.6 dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML )	136
3.9 Sizzle.selectors	138
3.9.1 Sizzle.selectors.order	138
3.9.2 Sizzle.selectors.match/leftMatch	139
3.9.3 Sizzle.selectors.find	151
3.9.4 Sizzle.selectors.preFilter	154
3.9.5 Sizzle.selectors.filters	162
3.9.6 Sizzle.selectors.setFilters	165
3.9.7 Sizzle.selectors.filter	166
3.10 工具方法	176
3.10.1 Sizzle.uniqueSort( results )	176
3.10.2 sortOrder(a, b)	177
3.10.3 Sizzle.contains( a, b )	182
3.10.4 Sizzle.error( msg )	182
3.10.5 Sizzle.getText( elem )	183
3.11 便捷方法	184
3.11.1 Sizzle.matches( expr, set )	184
3.11.2 Sizzle.matchesSelector( node, expr )	184
3.12 jQuery 扩展	186
3.12.1 暴露 Sizzle 给 jQuery	186
3.12.2 .find( selector )	186
3.12.3 .has( target )	188
3.12.4 .not( selector )、.filter( selecotr )	189
3.12.5 .is( selector )	191
3.12.6 .closest( selectors, context )	193
3.12.7 .index( elem )	195
3.12.8 .add( selector, context )	196
3.12.9 jQuery.filter( expr, elems, not )	197
3.12.10 :animated	198
3.12.11 :hidden、:visible	199
3.13 总结	200
第4章  异步队列 Deferred Object	201
4.1 jQuery.Callbacks( flags )	202
4.1.1 实现原理和总体结构	204
4.1.2 源码分析	205
4.1.3 小结	219
4.2 jQuery.Deferred( func )	220
4.2.1 实现原理和总体结构	223
4.2.2 源码分析	224
4.2.3 小结	232
4.3 jQuery.when( deferreds )	232
4.3.1 实现原理	234
4.3.2 源码分析	234
4.4 异步队列在 jQuery 中的应用	237
4.5 总结	238
第5章  数据缓存 Data	238
5.1 实现原理	239
5.1.1 为 DOM 元素附加数据	239
5.1.2 为 JavaScript 对象附加数据	241
5.2 总体结构	242
5.3 jQuery.acceptData( elem )	244
5.4 jQuery.data( elem, name, data, pvt )、jQuery._data( elem, name, data, pvt )	245
5.4.1 如何使用	245
5.4.2 源码分析	246
5.4.3 jQuery._data( elem, name, data )	253
5.4.4 小结	254
5.5 .data( key, value )	256
5.5.1 如何使用	256
5.5.2 源码分析	256
5.5.3 小结	261
5.6 jQuery.removeData( elem, name, pvt )、.removeData( key )	262
5.6.1 如何使用	262
5.6.2 源码分析	263
5.6.4 小结	269
5.7 .removeData( key )	270
5.8 jQuery.cleanData( elems )	271
5.8.1 应用场景	271
5.8.2 源码分析	273
5.8.3 小结	276
5.9 jQuery.hasData( elem )	277
5.10 总结	278
第6章  队列 Queue	279
6.1 如何使用	280
AJAX 队列	280
动画队列 + AJAX 队列	281
基于 JavaScript 对象	281
6.2 实现原理	282
6.3 总体结构	282
6.4 jQuery.queue( elem, type, data )	284
6.5 jQuery.dequeue( elem, type )	286
6.6 .queue( type, data )	288
6.7 .dequeue( type )	290
6.8 .delay( time, type )	291
6.9 .clearQueue( type )	292
6.10 jQuery._mark( elem, type )、jQuery._unmark( force, elem, type )	293
6.11 .promise( type, object )	295
6.11.1 如何使用	295
6.11.2 实现原理	296
6.11.3 源码分析	297
6.11.4 handleQueueMarkDefer( elem, type, src )	299
6.12 总结	301
第7章  浏览器功能测试 Support	302
7.1 总体结构	302
7.2 DOM 测试（15 项）	305
7.2.1 leadingWhitespace	305
7.2.2 tbody	307
7.2.3 htmlSerialize	309
7.2.4 hrefNormalized	311
7.2.5 checkOn	313
7.2.6 noCloneChecked	315
7.2.7 optSelected	318
7.2.8 optDisabled	320
7.2.9 getSetAttribute	322
7.2.10 deleteExpando	326
7.2.11 enctype	328
7.2.12 html5Clone	330
7.2.13 radioValue	332
7.2.14 checkClone	334
7.2.15 appendChecked	337
7.3 样式测试（3 项）	339
7.3.1 style	339
7.3.2 opacity	342
7.3.3 cssFloat	346
7.4 盒模型测试（10 项）	349
7.4.1 reliableMarginRight	349
7.4.2 reliableHiddenOffsets	352
7.4.3 boxModel	355
7.4.4 inlineBlockNeedsLayout	358
7.4.5 shrinkWrapBlocks	361
7.4.6 doesNotAddBorder、doesAddBorderForTableAndCells	365
7.4.7 fixedPosition	369
7.4.8 subtractsBorderForOverflowNotVisible	372
7.4.9 doesNotIncludeMarginInBodyOffset	375
7.5 事件测试（4 项）	378
7.5.1 noCloneEvent	378
7.5.2 submitBubbles、changeBubbles、focusinBubbles	381
7.6 Ajax 测试（2 项）	383
7.6.1 ajax	383
7.6.2 cors	386
7.7 总结	387
第8章  属性操作 Attributes	392
8.1 总体结构	394
8.2 jQuery.attr( elem, name, value, pass )	395
8.2.1 源码分析	396
8.2.2 boolHook	400
8.2.3 nodeHook	403
8.2.4 jQuery.attrHooks	404
8.2.5 小结	411
8.3 .attr( name, value )	412
8.4 jQuery.removeAttr( elem, value )	413
8.4.1 源码分析	414
8.4.2 小结	416
8.5 .removeAttr( name )	416
8.6 jQuery.prop( elem, name, value )	417
8.6.1 源码分析	417
8.6.2 jQuery.propHooks	420
8.6.3 小结	421
8.7 .prop( name, value )	422
8.8 .removeProp( name )	423
8.9 .addClass( className )	424
8.9.1 源码分析	425
8.9.2 小结	427
8.10 .removeClass( [className] )	428
8.10.1 源码分析	429
8.10.2 小结	431
8.11 .toggleClass( [className] [, switch] )	432
8.11.1 源码分析	432
8.11.2 小结	435
8.12 .hasClass( selector )	436
8.12.1 源码分析	436
8.12.2 小结	437
8.13 .val( [value] )	437
8.13.1 源码分析	438
8.13.2 jQuery.valHooks	441
8.13.3 小结	445
8.14 总结	446
第9章  事件系统 Events	448
9.1 总体结构	450
9.2 实现原理	455
9.3 jQuery 事件对象	457
9.3.1 构造函数 jQuery.Event( src, props )	459
9.3.2 原型对象 jQuery.Event.prototype	462
9.3.3 事件属性修正方法 jQuery.event.fix( event )	466
9.4 绑定事件	475
9.4.1 .on( events [, selector] [, data] , handler(eventObject) )	475
9.4.2 jQuery.event.add( elem, types, handler, data, selector )	479
9.5 移除事件	491
9.5.1 .off( events [, selector] [, handler(eventObject)] )	491
9.5.2 jQuery.event.remove( elem, types, handler, selector, mappedTypes )	495
9.6 事件响应	504
9.6.1 主监听函数	504
9.6.2 jQuery.event.dispatch( event )	505
9.7 手动触发事件	514
9.7.1 .trigger( eventType [, extraParameters] )、.triggerHandler( eventType [, extraParameters] )	514
9.7.2 jQuery.event.trigger( event, data, elem, onlyHandlers )	515
9.8 事件修正和模拟 jQuery.event.special	528
9.8.1 ready	529
9.8.2 load	530
9.8.3 focus、blur	530
9.8.4 beforeunload	531
9.8.5 mouseenter、mouseleave	532
9.8.6 submit	534
9.8.7 change	537
9.8.8 focusin、focusout	540
9.8.9 jQuery.event.simulate( type, elem, event, bubble )	541
9.9 事件便捷方法	543
9.10 组合方法	545
9.10.1 .toggle( handler(eventObject), handler(eventObject) [, handler(eventObject)] )	545
9.10.2 .hover(handlerIn(eventObject) [, handlerOut(eventObject)] )	546
9.11 ready 事件	547
9.11.1 总体结构	547
9.11.2 .ready( handler )	551
9.11.3 jQuery.bindReady()	551
9.11.4 jQuery.holdReady( hold )	556
9.11.5 jQuery.ready( wait )	557
9.12 总结	559
第10章  DOM 遍历 Traversing	562
10.1 总体结构	564
10.2 遍历函数	566
10.3 工具函数	569
10.3.1 jQuery.dir( elem, dir, until )	569
10.3.2 jQuery.nth( cur, result, dir, elem )	571
10.3.3 jQuery.sibling( n, elem )	572
10.4 模板函数	574
10.5 总结	576
第11章  DOM 操作 Manipulation	577
11.1 总体结构	577
11.2 插入元素	579
11.2.1 核心方法 .domManip( args, table, callback )	579
11.2.2 .append( content [, content] )	587
11.2.3 .prepend( content [, content] )	587
11.2.4 .before( content [, content] )	588
11.2.5 .after( content [, content] )	588
11.2.6 .appendTo( target )、.prependTo( target )、.insertBefore( target )、.insertAfter( target )	589
11.2.7 .html( [value] )	590
11.2.8 .text( [text] )	595
11.3 删除元素	598
11.3.1 .remove( selector, keepData )	598
11.3.2 .empty()	599
11.3.3 .detach( selector )	599
11.4 复制元素	600
11.4.1 .clone( dataAndEvents, deepDataAndEvents )	600
11.4.2 jQuery.clone( elem, dataAndEvents, deepDataAndEvents )	601
11.4.3 cloneFixAttributes( src, dest )	606
11.5 替换元素	609
11.5.1 .replaceWith( value )	609
11.5.2 .replaceAll( target )	612
11.6 包裹元素	612
11.6.1 .wrapAll( html )	612
11.6.2 .wrapInner( html )	613
11.6.3 .wrap( html )	614
11.6.4 .unwrap()	615
11.7 总结	615
第12章  样式操作 CSS	618
12.1 内联样式、计算样式	619
12.1.1 总体结构	619
12.1.2 .css( name, value )	621
12.1.3 jQuery.style( elem, name, value, extra )	622
12.1.4 jQuery.css( elem, name, extra )	628
12.1.5 curCSS( elem, name )、getComputedStyle( elem, name )、currentStyle( elem, name )	631
12.1.6 jQuery.cssHooks	634
12.2 坐标 Offset	643
12.2.1 总体结构	643
12.2.2 .offset( options )	644
12.2.3 jQuery.offset.setOffset( elem, options, i )	650
12.2.4 jQuery.offset.bodyOffset( body )	654
12.2.5 .position()	655
12.2.6 .offsetParent()	656
12.2.7 .scrollLeft( val )、.scrollTop( val )	657
12.3 尺寸 Dimensions	659
12.3.1 总体结构	659
12.3.2 getWH( elem, name, extra )	660
12.3.3 .innerHeight()、.innerWidth()	664
12.3.4 .outerHeight( margin )、.outerWidth( margin )	665
12.3.5 .height( size )、.width( size )	666
12.3.6 小结	670
12.4 总结	671
第13章  异步请求 Ajax	673
13.1 总体结构	674
13.2 jQuery.ajax( url, options )	677
13.3 前置过滤器、请求发送器的初始化和执行	705
13.3.1 初始化	706
13.3.2 执行	709
13.4 前置过滤器	713
13.4.1 json、jsonp	713
13.4.2 script	716
13.4.3 小结	717
13.5 请求发送器	718
13.5.1 script	718
13.5.2 XMLHttpRequest	722
13.5.3 小结	733
13.6 数据转换器	733
13.6.1 初始化	734
13.6.2 执行	736
13.6.3 小结	741
13.7 Ajax 事件	742
13.8 便捷方法	744
13.8.1 jQuery.get( url, data, callback, type )、jQuery.post( url, data, callback, type )	744
13.8.2 jQuery.getJSON( url, data, callback )、jQuery.getScript( url, callback )	745
13.8.3 .load( url, params, callback )	745
13.9 工具方法	750
13.9.1 .serialize()	750
13.9.2 jQuery.param( a, traditional )	751
13.9.3 .serializeArray()	756
13.10 总结	757
第14章  动画 Effects	761
14.1 总体结构	762
14.2 动画入口	766
14.2.1 .animate( prop, speed, easing, callback )	766
14.2.2 jQuery.speed( speed, easing, fn )	769
14.2.3 doAnimation()	772
14.2.4 jQuery.fx( elem, options, prop )	778
14.2.5 jQuery.fx.prototype.show()	779
14.2.6 jQuery.fx.prototype.hide()	780
14.2.7 小结	780
14.3 动画执行	781
14.3.1 jQuery.fx.prototype.custom( from, to, unit )	781
14.3.2 jQuery.fx.tick()	784
14.3.3 jQuery.fx.prototype.step( gotoEnd )	785
14.3.4 jQuery.easing	790
14.3.5 jQuery.fx.prototype.update()	791
14.3.6 jQuery.fx.step	791
14.4 停止动画 .stop( type, clearQueue, gotoEnd )	793
14.5 便捷方法	797
14.5.1 生成动画样式集 genFx( type, num )	797
14.5.2 显示隐藏 .show/hide/toggle()	798
14.5.3 渐显渐隐 .fadeIn/fadeOut/fadeTo/fadeToggle()	802
14.5.4 滑入滑出 .slideDwon/slidUp/slideToggle()	803
14.6 总结	804
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>jQuery 技术内幕
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>重构
第1章 重构，第一个案例1
1.1 起点1
1.2 重构的第一步7
1.3 分解并重组statement()8
1.4 运用多态取代与价格相关的条件逻辑34
1.5 结语52
第2章 重构原则53
2.1 何谓重构53
2.2 为何重构55
2.3 何时重构57
2.4 怎么对经理说60
2.5 重构的难题62
2.6 重构与设计66
2.7 重构与性能69
2.8 重构起源何处71
第3章 代码的坏味道75
3.1 DuplicatedCode（重复代码）76
3.2 LongMethod（过长函数）76
3.3 LargeClass（过大的类）78
3.4 LongParameterList（过长参数列）78
3.5 DivergentChange（发散式变化）79
3.6 ShotgunSurgery（霰弹式修改）80
3.7 FeatureEnvy（依恋情结）80
3.8 DataClumps（数据泥团）81
3.9 PrimitiveObsession（基本类型偏执）81
3.10 SwitchStatements（switch惊悚现身）82
3.11 ParallelInheritanceHierarchies（平行继承体系）83
3.12 LazyClass（冗赘类）83
3.13 SpeculativeGenerality（夸夸其谈未来性）83
3.14 TemporaryField（令人迷惑的暂时字段）84
3.15 MessageChains（过度耦合的消息链）84
3.16 MiddleMan（中间人）85
3.17 InappropriateIntimacy（狎昵关系）85
3.18 AlternativeClasseswithDifferentInterfaces（异曲同工的类）85
3.19 IncompleteLibraryClass（不完美的库类）86
3.20 DataClass（纯稚的数据类）86
3.21 RefusedBequest（被拒绝的遗赠）87
3.22 Comments（过多的注释）87
第4章 构筑测试体系89
4.1 自测试代码的价值89
4.2 JUnit测试框架91
4.3 添加更多测试97
第5章 重构列表103
5.1 重构的记录格式103
5.2 寻找引用点105
5.3 这些重构手法有多成熟106
第6章 重新组织函数109
6.1 ExtractMethod（提炼函数）110
6.2 InlineMethod（内联函数）117
6.3 InlineTemp（内联临时变量）119
6.4 ReplaceTempwithQuery（以查询取代临时变量）120
6.5 IntroduceExplainingVariable（引入解释性变量）124
6.6 SplitTemporaryVariable（分解临时变量）128
6.7 RemoveAssignmentstoParameters（移除对参数的赋值）131
6.8 ReplaceMethodwithMethodObject（以函数对象取代函数）135
6.9 SubstituteAlgorithm（替换算法）139
第7章 在对象之间搬移特性141
7.1 MoveMethod（搬移函数）142
7.2 MoveField（搬移字段）146
7.3 ExtractClass（提炼类）149
7.4 InlineClass（将类内联化）154
7.5 HideDelegate（隐藏“委托关系”）157
7.6 RemoveMiddleMan（移除中间人）160
7.7 IntroduceForeignMethod（引入外加函数）162
7.8 IntroduceLocalExtension（引入本地扩展）164
第8章 重新组织数据169
8.1 SelfEncapsulateField（自封装字段）171
8.2 ReplaceDataValuewithObject（以对象取代数据值）175
8.3 ChangeValuetoReference（将值对象改为引用对象）179
8.4 ChangeReferencetoValue（将引用对象改为值对象）183
8.5 ReplaceArraywithObject（以对象取代数组）186
8.6 DuplicateObservedData（复制“被监视数据”）189
8.7 ChangeUnidirectionalAssociationtoBidirectional（将单向关联改为双向关联）197
8.8 ChangeBidirectionalAssociationtoUnidirectional（将双向关联改为单向关联）200
8.9 ReplaceMagicNumberwithSymbolicConstant（以字面常量取代魔法数）204
8.10 EncapsulateField（封装字段）206
8.11 EncapsulateCollection（封装集合）208
8.12 ReplaceRecordwithDataClass（以数据类取代记录）217
8.13 ReplaceTypeCodewithClass（以类取代类型码）218
8.14 ReplaceTypeCodewithSubclasses（以子类取代类型码）223
8.15 ReplaceTypeCodewithState/Strategy（以State/Strategy取代类型码）227
8.16 ReplaceSubclasswithFields（以字段取代子类）232
第9章 简化条件表达式237
9.1 DecomposeConditional（分解条件表达式）238
9.2 ConsolidateConditionalExpression（合并条件表达式）240
9.3 ConsolidateDuplicateConditionalFragments（合并重复的条件片段）243
9.4 RemoveControlFlag（移除控制标记）245
9.5 ReplaceNestedConditionalwithGuardClauses（以卫语句取代嵌套条件表达式）250
9.6 ReplaceConditionalwithPolymorphism（以多态取代条件表达式）255
9.7 IntroduceNullObject（引入Null对象）260
9.8 IntroduceAssertion（引入断言）267
第10章 简化函数调用271
10.1 RenameMethod（函数改名）273
10.2 AddParameter（添加参数）275
10.3 RemoveParameter（移除参数）277
10.4 SeparateQueryfromModifier（将查询函数和修改函数分离）279
10.5 ParameterizeMethod（令函数携带参数）283
10.6 ReplaceParameterwithExplicitMethods（以明确函数取代参数）285
10.7 PreserveWholeObject（保持对象完整）288
10.8 ReplaceParameterwithMethods（以函数取代参数）292
10.9 IntroduceParameterObject（引入参数对象）295
10.10 RemoveSettingMethod（移除设值函数）300
10.11 HideMethod（隐藏函数）303
10.12 ReplaceConstructorwithFactoryMethod（以工厂函数取代构造函数）304
10.13 EncapsulateDowncast（封装向下转型）308
10.14 ReplaceErrorCodewithException（以异常取代错误码）310
10.15 ReplaceExceptionwithTest（以测试取代异常）315
第11章 处理概括关系319
11.1 PullUpField（字段上移）320
11.2 PullUpMethod（函数上移）322
11.3 PullUpConstructorBody（构造函数本体上移）325
11.4 PushDownMethod（函数下移）328
11.5 PushDownField（字段下移）329
11.6 ExtractSubclass（提炼子类）330
……
第12章 大型重构359
第13章 重构，复用与现实379
第14章 重构工具401
第15章 总结409
参考书目413
要点列表417
索引419
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>重构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java应用架构设计
本书赞誉
译者序
序
序
前言
第一部分 模块化的理由
第1章 模块定义
1.1 定义模块
1.1.1 可部署
1.1.2 可管理
1.1.3 可测试
1.1.4 原生可重用
1.1.5 可组合
1.1.6 无状态
1.2 软件模块的简洁定义
1.3 结论
第2章 模块化的两个方面
2.1 运行时模型
2.2 开发模型
2.2.1 编程模型
2.2.2 设计范式
2.3 模块化现状
2.4 结论
第3章 架构与模块化
3.1 定义架构
3.2 关于软件架构的一个故事
3.2.1 象牙塔
3.2.2 乌龟和塔
3.3 架构的目标
3.3.1 悖论
3.3.2 消除架构
3.4 模块化：被忽视的部分
3.5 回答我们的问题
3.6 结论
3.7 参考文献
第4章 征服复杂性
4.1 企业级复杂性
4.2 技术债
4.3 设计腐化
4.3.1 干扰可维护性
4.3.2 阻止可扩展性
4.3.3 抑制可重用性
4.3.4 限制可测试性
4.3.5 妨碍集成
4.3.6 阻碍理解
4.4 循环依赖
4.4.1 循环类型
4.4.2 悄然引入的循环
4.4.3 管理循环
4.4.4 循环总是不好的吗
4.5 结合点、模块和SOLID
4.6 管理复杂性
4.7 模块化的益处
4.8 结论
4.9 参考文献
第5章 实现重用
5.1 可用重用悖论
5.2 关于重用的免责声明
5.2.1 粒度
5.2.2 重量级
5.3 重用还是可用
5.4 模块化权衡
5.5 模块化设计
5.6 结论
5.7 参考文献
第6章 模块化与SOA
6.1 重新审视“自上而下”
6.2 粒度——架构师的强大对手
6.2.1 现实世界的一个例子
6.2.2 提升一个等级
6.2.3 另一个维度
6.2.4 全景图
6.2.5 服务样例
6.3 另一个视图
6.4 结论
第7章 参考实现
7.1 为什么不用OSGi
7.2 这个练习的背景：构建系统
7.3 初始版本
7.4 第一次重构
7.5 第二次重构
7.6 第三次重构
7.7 第四次重构
7.7.1 关于OSGi的好处
7.7.2 小结并准备下一次重构
7.8 第五次重构
7.9 第六次重构
7.10 第七次重构
7.11 事后剖析
7.11.1 关于模块测试
7.11.2 关于管理模块依赖
7.11.3 关于模块重用
7.11.4 关于构建
7.11.5 关于面向对象
7.12 结论
7.13 参考文献
第二部分 模 式
第8章 基本模式
8.1 管理关系
8.1.1 表述
8.1.2 描述
8.1.3 多种实现
8.1.4 影响
8.1.5 样例
8.1.6 小结
8.2 模块重用
8.2.1 表述
8.2.2 描述
8.2.3 多种实现
8.2.4 效果
8.2.5 样例
8.2.6 小结
8.3 模块内聚
8.3.1 表述
8.3.2 描述
8.3.3 多种实现
8.3.4 效果
8.3.5 样例
8.3.6 小结
第9章 依赖模式
9.1 非循环关系
9.1.1 表述
9.1.2 描述
9.1.3 多种实现
9.1.4 效果
9.1.5 样例
9.1.6 小结
9.2 等级化模块
9.2.1 表述
9.2.2 描述
9.2.3 多种实现
9.2.4 效果
9.2.5 样例
9.2.6 小结
9.3 物理分层
9.3.1 表述
9.3.2 描述
9.3.3 多种实现
9.3.4 效果
9.3.5 样例
9.3.6 小结
9.4 容器独立
9.4.1 表述
9.4.2 描述
9.4.3 多种实现
9.4.4 效果
9.4.5 样例
9.4.6 小结
9.5 独立部署
9.5.1 表述
9.5.2 描述
9.5.3 多种实现
9.5.4 效果
9.5.5 样例
9.5.6 小结
9.6 参考文献
第10章 可用性模式
10.1 发布接口
10.1.1 表述
10.1.2 描述
10.1.3 多种实现
10.1.4 效果
10.1.5 样例
10.1.6 小结
10.2 外部配置
10.2.1 表述
10.2.2 描述
10.2.3 多种实现
10.2.4 效果
10.2.5 样例
10.2.6 小结
10.3 默认实现
10.3.1 表述
10.3.2 描述
10.3.3 多种实现
10.3.4 效果
10.3.5 样例
10.3.6 小结
10.4 模块门面
10.4.1 表述
10.4.2 描述
10.4.3 多种实现
10.4.4 效果
10.4.5 样例
10.4.6 小结
第11章 扩展性模式
11.1 抽象化模块
11.1.1 表述
11.1.2 描述
11.1.3 多种实现
11.1.4 效果
11.1.5 样例
11.1.6 小结
11.2 实现工厂
11.2.1 表述
11.2.2 描述
11.2.3 多种实现
11.2.4 效果
11.2.5 样例
11.2.6 小结
11.3 分离抽象
11.3.1 表述
11.3.2 描述
11.3.3 多种实现
11.3.4 效果
11.3.5 样例
11.3.6 小结
11.4 参考文献
第12章 通用模式
12.1 就近异常
12.1.1 表述
12.1.2 描述
12.1.3 多种实现
12.1.4 效果
12.1.5 样例
12.1.6 小结
12.2 等级化构建
12.2.1 表述
12.2.2 描述
12.2.3 多种实现
12.2.4 效果
12.2.5 样例
12.2.6 小结
12.3 测试模块
12.3.1 表述
12.3.2 描述
12.3.3 多种实现
12.3.4 效果
12.3.5 样例
12.3.6 小结  201
第三部分 模块化架构模式与OSGi
第13章 OSGi简介
13.1 一点历史
13.2 OSGi所能带来的收益
13.2.1 模块化开发
13.2.2 管理依赖
13.2.3 模块平台
13.2.4 版本化的bundle
13.2.5 动态（重）部署
13.2.6 环境相关的控制
13.3 深入理解OSGi
13.4 OSGi bundle
13.4.1 bundle状态
13.4.2 OSGi Service
13.5 OSGi运行时管理
13.6 重新查看模块化的两个方面
13.7 OSGi与模式
13.7.1 管理依赖
13.7.2 动态性
13.7.3 Blueprint规范
第14章 贷款样例与OSGi
14.1 起步
14.2 清单文件
14.3 Service
14.3.1 Blueprint服务
14.3.2 贷款样例配置
14.3.3 OSGi Service声明
14.4 安装与执行
14.5 结论
第15章 OSGi与Scala
15.1 起步
15.2 Scala代码
15.3 Scala bean配置
15.4 Scala Service配置
15.5 构建Scala模块
15.6 安装与执行
15.7 结论
第16章 OSGi与Groovy
16.1 起步
16.2 Groovy代码
16.3 Groovy bean配置
16.4 Groovy Service配置
16.5 构建Groovy模块
16.6 安装与执行
16.7 结论
第17章 OSGi的未来
17.1 将OSGi作为推动者
17.2 颠覆性
17.3 生态系统的威力
17.3.1 生态系统与模块化的两个方面
17.3.2 基于组件的开发（CBD）不是已经成功了吗
17.4 生态系统
17.5 结论
附录A 类设计的SOLID原则
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java应用架构设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件架构师职业导读
第1章
一个简单的类比

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件架构师职业导读
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据平台基础架构指南
第1章  大数据平台整体建设思想 1
1.1  什么是大数据平台 1
1.2  大数据平台的建设目标 3
1.2.1  别人的大数据平台是怎样的 3
1.2.2  和业内领先的大数据平台的差距 4
1.2.3  大数据平台建设目标小结 6
1.3  大数据平台的建设指导方针 6
1.3.1  组件工具化 7
1.3.2  工具平台化 8
1.3.3  平台服务化 9
1.3.4  平台产品化 10
1.3.5  对中小公司大数据平台的适用性 11
1.4  大数据平台的两种建设路径 12
1.4.1  垂直业务领域一站到底的建设方式 13
1.4.2  通用组件建设，组合支持业务的方式 13
1.4.3  从蘑菇街平台的实践经验对比两种建设路径 14
1.4.4  两种建设路径的对比小结 16
第2章  服务意识和产品思想的培养 17
2.1  明确大数据平台服务能力的评估标准 17
2.1.1  大数据平台团队的职能定位 18
2.1.2  打通上下游系统和业务流程的能力 18
2.2  满足用户真正的需求 19
2.3  认清服务的代价，做好心理建设 20
2.4  寻找解决服务代价问题的方案 23
2.4.1  路线选择带来的代价问题 23
2.4.2  如何降低服务自身的代价 25
2.5  大数据平台的产品化思想 29
2.5.1  从用户体验的角度谈产品设计 31
2.5.2  从价值和利益的角度谈产品思维 36
2.6  小结 38
第3章  工作流（作业）调度系统 39
3.1  作业调度系统基础理论 40
3.1.1  调度系统分类 40
3.1.2  工作流调度系统的两种心法流派 45
3.1.3  工作流调度系统功能特性详解 49
3.2  Jarvis调度系统产品开发实践 55
3.2.1  需求定位分析 55
3.2.2  具体功能目标的详细分析和实践 57
3.2.3  第二代Jarvis现状和将来 75
3.3  小结 79
第4章  集成开发环境门户建设 81
4.1  集成开发环境的功能定位 82
4.1.1  集成开发环境的整体服务思路 83
4.1.2  集成开发环境的具体产品建设目标 86
4.1.3  小结 93
4.2  开发平台测试环境建设 94
4.2.1  问题背景 94
4.2.2  系统功能性测试环境 95
4.2.3  数据业务类测试环境 96
4.2.4  小结 100
第5章  数据采集、传输、交换、同步服务 101
5.1  数据交换服务场景和常见开源方案 102
5.1.1  大数据平台数据交换服务业务场景 102
5.1.2  常见数据交换服务解决方案介绍 103
5.2  数据交换服务具体产品实践 110
5.2.1  数据交换服务底层组件 110
5.2.2  数据交换服务管控平台 113
5.2.3  蘑菇街数据交换服务的实践现状和未来改进计划 118
5.3  用户行为链路分析之日志埋点采集跟踪方案实践 120
5.3.1  记日志有什么难的 120
5.3.2  蘑菇街的用户行为日志采集方案实践 122
5.3.3  小结 129
第6章  数据可视化平台 130
6.1  什么是数据可视化平台 130
6.1.1  数据可视化平台名词定义 131
6.1.2  已经有了那么多商业BI系统，为什么还要造轮子 132
6.2  数据可视化平台产品实践 134
6.2.1  可视化平台产品定位和需求分析 135
6.2.2  具体产品功能需求实践详解 136
6.2.3  将来的改进目标 146
6.2.4  产品实践小结 148
第7章  安全与权限管控 149
7.1  权限管理的目标是什么 149
7.1.1  适度安全，降低人为风险 150
7.1.2  隔离环境，提高工作效率 151
7.1.3  权责明晰，规范业务流程 152
7.1.4  权限管理目标小结 153
7.2  如何解决安全和便利的矛盾 153
7.2.1  安全和便利天生矛盾 153
7.2.2  改变角度，转移目标 154
7.2.3  把握尺度 155
7.2.4  可能的变通措施 157
7.2.5  思想小结 163
7.3  权限管控系统产品方案和技术分析 163
7.3.1  常见开源方案 164
7.3.2  Kerberos 165
7.3.3  Sentry和Ranger 168
7.3.4  Knox 169
7.3.5  开源项目中常见的权限模型概念 169
7.4  基于开发平台服务入口的权限管控方案 171
7.4.1  权限管控方案实践 171
7.4.2  底层统一权限管控和平台边界权限管控方案对比 173
第8章  数据质量管理 175
8.1  元数据管理平台 176
8.1.1  元数据管理平台管理什么 176
8.1.2  元数据管理相关系统方案介绍 180
8.1.3  元数据管理系统工程实践 183
8.2  DQC数据质量中心 185
8.2.1  DQC数据质量中心业界方案 186
8.2.2  DQC数据质量系统建设实践 188
8.3  数据质量管理小结 193
第9章  大数据集群迁移经验谈 195
9.1  集群迁移都要面对哪些麻烦事 196
9.1.1  集群和机房外部环境问题 196
9.1.2  平台自身组件和服务依赖问题 196
9.1.3  业务模式和沟通配合问题 197
9.1.4  业务逻辑和数据正确性问题 198
9.2  集群搬迁方案的总体目标、原则、流程 199
9.3  一些具体问题的分析和实践 201
9.3.1  如何保证正确性 201
9.3.2  集群数据同步拷贝方案 205
9.3.3  各种无法双跑的业务场景梳理 207
9.4  小结 208
第10章  谈谈大数据码农的职业发展问题 210
10.1  如何成为一名糟糕的大数据平台工程师 211
10.1.1  我是小白我怕谁 211
10.1.2  敏而好学，不耻下问 212
10.1.3  效率优先，中文至上 213
10.1.4  流行的就是最好的 213
10.1.5  我们的征途，是星辰大海 215
10.1.6  书中自有颜如玉，热衷阅读代码 216
10.1.7  谜之问题的谜之解决方式 218
10.1.8  勤奋好学，但是回头即忘 220
10.1.9  小结 221
10.2  职业选择和我们早晚要面对的中年危机问题 222
10.2.1  中年危机，要从娃娃抓起 222
10.2.2  中年危机之抗焦虑指南 223
10.2.3  如何才能获得自由 225
10.2.4  案例 230
10.2.5  小结 233
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据平台基础架构指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>思考软件，创新设计——A段架构师的思考技术
第1章商业思维：从商业模式到架构设计	1
1.1  A段架构师的角色	1
1.2  面对复杂，唯有简单	2
1.3  商业环境与模式是复杂的	3
1.4  软件的复杂是本质性的（并非表象而已）	5
1.5  如何从复杂中设计出简单	7
1.5.1  单纯与美丽的密切联系	7
1.5.2  软件美何在，把酒问<对称>	7
1.5.3  软件架构的第1种对称性	8
1.5.4  软件架构的第2种对称性	8
1.6  参考文献	9
第2章软硬整合商业模式范例	10
2.1 复习：A段架构设计	10
2.2  产品设计支持商业模式	11
2.2.1 反思既有的商业模式	12
2.2.2  创立新型商业模式	12
2.3  商业模式范例	13
2.3.1  长期的获利策略	13
2.3.2  短期的获利策略	14
2.3.3  硬硬结合销售	14
2.3.4  软硬整合开发	16
2.4  产品设计范例	17
2.5  延伸到客厅配件市场	18
2.5.1  客厅配件范例	18
2.5.2  客厅配件的商业模式	19
2.5.3  与微信、微博或百度地图等平台对接	20
2.6  产品的架构设计范例	21
2.6.1  基本元素和功能	21
2.6.2  应用情境（举例）	22
2.6.3  架构设计与实践	23
2.7  参考文献	23
第3章获利思维与心境	24
3.1 获利思维VS.成本思维	24
3.2  让架构师身价百倍的招式	26
3.3  领悟信用卡VISA商业模式	27
3.4  以农夫挑水浇花为例	28
3.5  设计客厅配件产品的商业（合作）模式	31
3.5.1  复习：客厅配件的商业模式	31
3.5.2  一样的心境	32
3.5.3  创立OFA联盟	33
3.6  参考文献	34
第4章创新思维	35
4.1  溯因推理与创造性	35
4.2  溯因推理基本观念	36
4.3  <假定-否证>= 删除法	39
4.4  孔明的溯因推理范例	41
4.5  麦肯锡的MECE原则	45
4.5.1  认识MECE原则	45
4.5.2  议题树及其种类	46
4.5.3  持续对议题进行分解和检验	47
4.5.4  符合MECE原则	47
4.5.5  持续进行<检验-否证>	48
4.5.6  展开下一阶层的议题	49
4.5.7  MECE范例	51
4.6  软件敏捷（Agile）开发原则	54
4.6.1  认识敏捷开发原则	54
4.6.2  敏捷幕后的溯因推理	55
4.6.3  A段架构师的敏捷力	57
4.7  敏捷设计：应用于智慧城市顶层设计	58
4.7.1  <顶层设计>含义的迷思	58
4.7.2  创新的起点：愿景（Vision）	59
4.7.3  观察现实，提出假定（Hypothesis）	60
4.7.4  结论：提出<敏捷顶层设计方法>	61
4.7.5  应用：敏捷顶层设计步骤说明	62
4.8  创新设计：<发现EIT造形>之旅	62
4.8.1  什么是代码造形？	62
4.8.2  大家熟悉的两种代码造形：函数和类	63
4.8.3  创新的起点：愿景（Vision）	64
4.8.4  提出假定	65
4.8.5  提出新的假定	65
4.8.6  结论：提出EIT代码造形	66
4.8.7  为什么需要有两个配角	68
4.9  参考文献	69
第5章组合思维	70
5.1  从古典抽象思维谈起	70
5.2  创新组合思维	72
5.2.1  <合>的设计法则	72
5.2.2  序中有乱：以集装箱为例	73
5.2.3  演练：如何抽象出<集装箱>	74
5.2.4  观摩：软件集装箱	75
5.3  组合设计的要素：造形（Form）	77
5.3.1  从集装箱认识“造形”	77
5.3.2  认识EIT软件造形	78
5.3.3  造形的特性	81
5.3.4  造形的内部元素	81
5.3.5  造形的外部组合规律	82
5.4  演练范例：寻找（设计）软件系统的造形	85
5.5  演练范例：从简单造形组合出复杂	90
5.5.1  范例（一）：一对EIT造形包容善变的通信协议	90
5.5.2  范例（二）：EIT造形的巢状组合	93
5.5.3  范例（三）：从EIT造形组合出GoF设计模式	95
5.6  反思：儒家文化中的创新组合思维	99
5.6.1  分解的尽理之精神	99
5.6.2  中学为体，西学为用	99
5.7  设计出未来性	103
5.7.1  今日决策的未来性	103
5.7.2  愿景与连线	104
5.7.3  愿景从哪里来	105
5.7.4  组合与创新	105
5.7.5  演练：未来性架构设计	107
5.8  参考文献	113
第6章战术引导战略思维	114
6.1  架构师擅长于战术引导战略	114
6.2  会赢的战术	116
6.3  找会赢的战术，调整战略资源	117
6.4  <战术引导战略>的企业案例	118
6.5  参考文献	121
第7章四项假设性思维	122
7.1  从溯因推理谈起	122
7.2  假设（Assumption）是什么	125
7.3  第一项：不自觉的假设，放宽思维局限	125
7.3.1  一般范例	125
7.3.2  孔明空城计的范例	126
7.3.3  其他范例	127
7.4  第二项：有待被检验的假定，激发愿景想象	129
7.5  第三项：完成性的假设，想象最终结果	131
7.5.1  什么是完成性假设	131
7.5.2  Mapping from vision to reality与溯因推理	133
7.5.3 “Mapping”如何促进Know Unknown	135
7.5.4  演练：Mapping from vision to reality	137
7.5.5 演练：全脑观想（Visualization）	139
7.5.6  演练：完成性假设	140
7.6  第四项：万一性的假设，预留弹性空间	148
7.6.1  Why？万一性的假设	148
7.6.2  如何预见失败	149
7.6.3  认识Possibility和备胎思维	151
7.7  参考文献	152
第8章架构师策略思维的案例演练	153
8.1  产品策略思维	153
8.1.1  产品策略目标：兼顾独特性、普遍性和可靠性	153
8.1.2  实践方案：软硬整合、跨平台与测试	154
8.1.3  从简单中掌握复杂	155
8.1.4  对假定进行检验	157
8.2  发挥四项假设性思维	158
8.2.1  复习：溯因（Abductive）推理	158
8.2.2  观察现实，观想愿景	159
8.2.3  推导出假定	160
8.2.4 进行Mapping from vision to reality	161
8.2.5  重大发现	163
8.2.6  决定跨平台策略的方向	165
8.3  订定跨平台实践策略	165
8.3.1  复习：探索策略方向	165
8.3.2  拟订实践策略	165
8.3.3  策略-1：把它“EIT（设计）”了	166
8.3.4  策略-2：挟天子以令诸侯	167
8.3.5  策略-3：建立中间件（middleware）	167
8.4  跨芯片小平台策略	167
8.4.1  什么是<跨平台>	167
8.4.2  终端产品跨（芯片）小平台的3种情境	169
8.5  跨Android大平台策略	174
8.5.1  这个<策略-2>从哪里来	174
8.5.2  策略-2的实践	176
8.6  跨自己平台的策略	180
8.6.1  这个<策略-3>从哪里来	180
8.6.2  中间件跨平台的效益：没钱就改版，改版就有钱	182
8.6.3  中间件跨客户端的效益	183
8.6.4  中间件的设计	183
8.6.5  中间件在整体架构中的角色	185
8.7  参考文献	186
第9章架构设计的十个学习步骤	187
9.1  这<十个步骤>从哪里来	187
9.1.1  从架构思维的4个元素出发	187
9.1.2  学好<创意爱上限制>	188
9.1.3  学好<创新组合>	190
9.1.4  学习敏捷测试和设计通用性接口	191
9.2  阐述<十个学习步骤>	192
9.2.1  第1步：学习两种抽象视角（Abstraction View）	192
9.2.2  第2步：关心下层的变动自由度	193
9.2.3  第3步：<系统架构控制力>支撑<商业竞争话语权>	193
9.2.4  第4步：<用户体验>是用户从简单中叫出复杂的满足感	194
9.2.5  第5步：创意爱上限制，即需求检验设计	194
9.2.6  第6步：假设性思维和Mapping from vision to reality	195
9.2.7  第7步：清晰而明确表述接口（Interface）	195
9.2.8  第8步：尽快对接口进行检验和测试	195
9.2.9  第9步：设计通用性接口	196
9.2.10  第10步：有效减法设计，才能开放加法（设计）	197
9.3  深入领悟（一）：变动自由度	197
9.4  深入领悟（二）：创意爱上限制	200
9.5  深入领悟（三）：Mapping from vision to reality	201
9.6  深入领悟（四）：迅速检测接口	204
9.7  深入领悟（五）：有效减法设计，才能开放加法	208
9.7.1  举例：以Socket接口来包容TCP/IP通信协议	208
9.7.2  演练步骤	208
9.8  参考文献	218
第10章<Java/HBase + C>云平台架构设计的十项法则	219
10.1  这<十项法则>从哪里来	219
10.1.1  反思假设	219
10.1.2  关注于命令流及其控制点	221
10.2  阐述<十项法则>	222
10.3  思考议题&提示	227
10.4  参考文献	232
第11章法则-2的实践范例：通用性接口设计	233
11.1  通用性接口	233
11.2  亲自设计通用性接口	235
11.2.1  认识用例（Use Case）及其剧景（Scenario）	235
11.2.2  设计通用性接口来支撑用例（Use Case）	238
11.2.3  衔接到<UC-001：播放音乐>的特殊性接口	239
11.2.4  衔接到<UC-002：播放某首音乐>的特殊性接口	243
11.3  多个通用性接口的联合应用范例	247
11.3.1  应用范例：手机与Android TV的多机整合	247
11.3.2  iPhone手机端的规划	248
11.3.3  衔接iPhone手机端的（通用性）接口：Servlet	249
11.3.4  App的Context接口与myTVServlet对接	253
11.3.5  Android本地App的设计	259
11.4  参考文献	264
第12章法则-3的实践范例：挟天子以令诸侯	265
12.1  一般框架设计：以<五子棋>为例	265
12.1.1  阶段一：从传统类（Class）造形设计出发	265
12.1.2  阶段二：继续运用EIT造形设计	268
12.2  基于Android设计小框架：以<涂鸦>应用为例	272
12.2.1  介绍多层EIT造形	272
12.2.2  简介「涂鸦」（Scribble）	274
12.2.3  <涂鸦>范例的功能说明	274
12.3  实践<挟天子以令诸侯>	275
12.3.1  阶段一：从传统类（Class）造形设计出发	275
12.3.2  阶段二：继续运用EIT造形设计	276
12.4  参考文献	308
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>思考软件，创新设计——A段架构师的思考技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>App 后台开发运维和架构实践
推荐序 .. 3
前言  5
致谢  7
目录  8
第1 章 App 后台入门 .. 16
1.1 App 后台的功能  16
1.2 App 后台架构 . 17
1.3 App 和App 后台的通信 .. 19
1.4 App 后台和Web 后端的区别 .. 22
1.5 选择服务器 . 23
1.6 选择编程语言  24
1.7 快速入门新技术 .. 25
1.7.1 思维模式  25
1.7.2 4 种快速入门新技术的方法 .. 25
1.8 App 是怎样炼成的 .. 26
1.8.1 项目启动阶段 . 26
1.8.2 研发阶段  28
1.8.3 测试阶段  29
1.8.4 正式推出阶段 . 29
1.9 最适合App 的开发模式——敏捷开发 .. 30
1.9.1 Sprint 计划会议 . 31
1.9.2 日常开发  32
1.9.3 每日例会  33
1.9.4 测试和修复Bug  33
1.9.5 评审会议  34
1.9.6 回顾会议  34
1.9.7 及时反馈  34
1.9.8 总结.. 34
第2 章 App 后台基础技术 . 35
2.1 从App 业务逻辑中提炼API 接口 . 35
2.1.1 业务逻辑思维导图 .. 36
2.1.2 功能—业务逻辑思维导图 .. 37
2.1.3 基本功能模块关系 .. 40
2.1.4 功能模块接口UML（设计出API）  41
2.1.5 编写在线API 测试文档 42
2.1.6 设计稿标注API  45
2.2 设计API 的要点 .. 46
2.3 如何选择合适的数据库产品 . 50
2.3.1 Redis，MongoDB，MySQL 读写数据的区别  50
2.3.2 Redis，MongoDB，MySQL 查找数据的区别  50
2.3.3 Redis，MongoDB，MySQL 适用场景  51
2.4 如何选择消息队列软件 .. 52
2.4.1 为什么要用消息队列？  52
2.4.2 消息队列的工作流程 . 53
2.4.3 常见的一些消息队列产品 .. 54
2.5 使用分布式服务实现业务的复用 .. 54
2.5.1 巨无霸系统的危害 .. 55
2.5.2 远程服务的优点  56
2.5.3 远程服务的实现  56
2.6 搜索技术入门  59
2.6.1 一个简单的搜索例子 . 59
2.6.2 搜索技术的基本原理 . 60
2.6.3 常见的开源搜索软件介绍 .. 62
2.7 定时任务 .. 65
2.7.1 Linux 定时任务Crontab  65
2.7.2 在后台轻松管理各种各样的定时任务  66
第3 章 App 后台核心技术 . 68
3.1 用户验证方案  68
3.1.1 使用HTTPS 协议 . 68
3.1.2 基本的用户登录方案 . 69
3.2 App 通信安全 . 72
3.2.1 URL 签名 .. 72
3.2.2 AES 对称加密  74
3.2.3 更进一步的通信安全 . 77
3.3 短信服务 .. 78
3.3.1 App 后台发送短信简介  78
3.3.2 选择短信平台 . 78
3.3.3 建立可靠的短信服务 . 79
3.4 处理表情的一些技巧  80
3.4.1 表情在MySQL 的存储 . 80
3.4.2 当文字中夹带表情的处理 .. 80
3.4.3 Openfire 中发送表情引起连接断开的问题 .. 81
3.5 高效更新数据  82
3.5.1 内容的推拉 .. 83
3.5.2 数据增量更新策略 .. 84
3.6 图片处理 .. 90
3.7 视频处理 .. 91
3.7.1 FFmpeg 简介 .. 91
3.7.2 后台调用FFmpeg 的功能  92
3.8 获取APK 和IPA 文件里的资源 . 94
3.8.1 Android 的APK 文件 . 94
3.8.2 iOS 的IPA 文件  96
3.9 文件系统 .. 98
3.9.1 文件云存储服务  99
3.9.2 架设文件系统 . 99
3.10 ELK 日志分析平台  101
3.10.1 基本模块 .. 101
3.10.2 日志分析流程  102
3.11 Docker 构建一致的开发环境 .. 103
3.11.1 Docker 原理  103
3.11.2 搭建一致的开发环境  104
第4 章 Linux——App 后台应用最广泛的系统 .. 107
4.1 基本的系统优化  107
4.1.1 开机自启动服务优化 .. 107
4.1.2 增大文件描述符 . 109
4.2 常用的命令 .. 110
4.2.1 全面了解系统资源情况——top  110
4.2.2 显示进程状态——ps .. 115
4.2.3 查看网络相关信息——netstat .. 116
4.2.4 查看某个进程打开的所有文件——lsof .. 118
4.2.5 跟踪数据到达主机所经路由——traceroute .. 119
4.2.6 文件下载/上传工具——“ssh secure shell client”和“lrzsz” . 119
4.2.7 查看程序的依赖库——LD_DEBUG . 121
4.2.8 进程管理利器——superivisor  122
4.3 故障案例分析 . 125
第5 章 Nginx——App 后台HTTP 服务的利器 . 126
5.1 简介 . 126
5.2 基本原理  127
5.2.1 工作模型 . 127
5.2.2 进程解析 . 128
5.3 常用配置  129
5.3.1 Nginx 的全局配置 . 130
5.3.2 event 配置 .. 130
5.3.3 http 配置 .. 131
5.3.4 负载均衡配置 .. 133
5.3.5 server 虚拟主机配置  134
5.3.6 location 配置 . 134
5.3.7 HTTPS 的配置 . 135
5.3.8 下载App 的配置  136
5.3.9 生产环境中修改配置的良好习惯  136
5.4 性能统计  136
5.5 实现负载均衡的方案 . 137
5.6 用Nginx 处理业务逻辑 . 139
第6 章 MySQL——App 后台最常用的数据库 .. 140
6.1 基本架构  140
6.2 选择版本  141
6.3 配置文件详解 . 142
6.4 软件优化  144
6.4.1 正确使用MyISAM和InnoDB 存储引擎  144
6.4.2 正确使用索引 .. 145
6.4.3 避免使用select *  146
6.4.4 字段尽可能地设置为NOT NULL .. 146
6.5 硬件优化  147
6.5.1 增加物理内存 .. 147
6.5.2 增加应用缓存 .. 147
6.5.3 用固态硬盘代替机械硬盘  148
6.5.4 SSD 硬盘+SATA 硬盘混合存储方案  149
6.6 架构优化  149
6.6.1 分表 150
6.6.2 读写分离 . 151
6.6.3 分库 153
6.7 SQL 慢查询分析  156
6.8 云数据库简介 . 157
6.9 灵活的存储结构  158
6.10 故障排除案例 .. 159
第7 章 Redis——App 后台高性能的缓存系统 . 160
7.1 Redis 简介 . 160
7.2 Redis 的常用数据结构及应用场景 . 161
7.2.1 string——存储简单的数据 .. 162
7.2.2 hash——存储对象的数据  163
7.2.3 list——模拟队列操作 . 165
7.2.4 set——无序且不重复的元素集合 .. 167
7.2.5 sorted set——有序且不重复的元素集合 . 168
7.3 内存优化  170
7.3.1 监控内存使用的状况 .. 170
7.3.2 优化存储结构 .. 170
7.3.3 限制使用的最大内存 .. 172
7.3.4 设置过期时间 .. 172
7.4 集群 . 174
7.4.1 客户端分片  174
7.4.2 Twemproxy  175
7.4.3 Codis . 176
7.4.4 Redis 3.0 集群 .. 179
7.4.5 云服务器上的集群服务 . 180
7.5 持久化 . 180
7.5.1 RDB .. 181
7.5.2 AOF 182
7.6 故障排除案例 . 184
第8 章 MongoDB——App 后台新兴的数据库 .. 185
8.1 简介 . 185
8.2 核心机制解析 . 186
8.2.1 MMAP（内存文件映射）  186
8.2.2 Journal 日志 .. 187
8.3 入门 . 187
8.3.1 基本操作 . 188
8.3.2 数组操作 . 190
8.3.3 实例演示MySQL 和MongoDB 设计数据库的区别  191
8.4 高可用集群 .. 195
8.4.1 主从 195
8.4.2 副本集 .. 196
8.4.3 分片 198
8.5 LBS——地理位置查询 . 200
8.6 MongoDB 3.0 版本的改进  205
8.6.1 灵活的存储架构 . 206
8.6.2 性能提升7~10 倍 .. 206
8.6.3 存储空间最多减少80%  207
8.6.4 运维成本最多降低95%  207
第9 章 App 后台架构剖析 .. 208
9.1 聊天App 后台架构 .. 208
9.1.1 移动互联网的网络特性 . 209
9.1.2 协议 212
9.1.3 整体架构 . 218
9.2 社交App 后台架构 .. 221
9.2.1 基本表结构  222
9.2.2 推拉模式 . 223
9.2.3 数据库架构的演进  225
9.2.4 缓存架构的演进 . 229
9.3 LBS App 后台架构 . 234
9.3.1 地理坐标详解 .. 235
9.3.2 查找附近的人 .. 236
9.3.3 基于MongoDB 的LBS 后台架构演进 . 240
9.4 推送服务器后台架构 . 242
9.4.1 Android 推送  242
9.4.2 iOS 推送 .. 248
9.5 获得更多App 后台架构资料 . 252
第10 章 App 后台架构的演进  255
10.1 架构的核心要素 . 255
10.1.1 高性能  256
10.1.2 高可用  258
10.1.3 可伸缩  261
10.1.4 可扩展  262
10.1.5 安全性  262
10.2 架构选型的要点 . 262
10.2.1 用成熟稳定的开源软件 .. 263
10.2.2 尽可能使用云服务 . 264
10.3 架构的演进  268
10.3.1 单机部署 .. 269
10.3.2 分布式部署 . 275
10.3.3 服务化  277
10.4 架构的特点  279
10.4.1 每个App 的后台架构不会完全一样 .. 279
10.4.2 架构的演进是由业务驱动的  279
10.4.3 架构不是为了炫耀技术 .. 280
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>App 后台开发运维和架构实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>响应式架构
目录
第１章　Actor模型和企业级软件概述. ................................... 1
为什么企业级软件难以开发........1
响应式应用程序简介....................4
响应性 ....................................5
韧性 ...6
灵活性 ....................................6
消息驱动 ................................7
企业级应用程序............................8
Actor模型 ..9
Actor模型的起源 ................10
了解 Actor模型 ................... 11
Actor模型的明晰性 .....................20
下章提要.21
第２章　使用Scala语言和Akka框架实现Actor模型............. 22
怎样获取Scala语言和Akka框架 23
使用 Typesafe Activator编辑器 ..............................23
使用 sbt ................................23
使用 Maven ..........................24
使用 Gradle ..........................25
使用Scala语言编写程序 .............26
Scala概要教程 ....................27
使用Akka框架编写程序.............39
Actor系统 ............................40
实现 Actor对象 ...................46
监督 .52
远程处理 ..............................55
集群功能 ..............................68
测试 Actor对象 ...................94
CompletableApp类 .............98
小结.......100
第３章　性能情结. ........................ 101
晶体管...101
时钟频率....................................103
核心和高速缓存........................104
可伸缩性....................................106
多线程技术的难点....................109
Actor模型的作用 ....................... 114
处理伪共享 ........................ 116
设计模式.................................... 117
第４章　通过Actor对象传递消息. . 119
消息通道....................................120
消息.......121
管道和过滤器............................126
消息路由器................................131
消息译码器................................134
消息端点....................................135
小结.......137
第５章　消息通道. ........................ 138
点对点通道................................140
发布—订阅通道........................143
本地事件流 ........................143
分布式发布—订阅通道 ....149
数据类型通道............................157
非法消息通道............................159
死信通道....................................161
确保送达机制............................164
通道适配器................................172
消息桥...174
消息总线....................................180
小结.......189
第６章　消息结构. ........................ 190
命令消息....................................191
文档消息....................................192
管理处理流程和处理过程 194
事件消息....................................195
请求—回复模式........................197
返回地址....................................199
相关标识符................................203
消息序列....................................204
消息有效期................................206
格式标识符................................209
小结.......213
第７章　消息路由. ........................ 214
基于内容的路由器....................215
消息过滤器................................219
动态路由器................................223
接收者列表................................232
分离器...241
聚合器...245
重新定序器................................252
组合消息处理器........................259
分散—聚集路由器....................260
传送名单....................................274
处理过程管理器........................282
消息经纪人路由器....................298
小结.......301
第８章　消息转换. ........................ 302
封装器...303
内容丰富器................................305
不可变的 DoctorVisitCompleted消息...................309
是否应在本地系统中创建 AccountingEnricherDispatcher对象 ..............309
内容过滤器................................310
存放证...313
标准化器....................................321
规范化消息模型........................322
Actor系统需要标准 ..........323
小结.......324
第９章　消息端点. ........................ 325
消息传输网关............................326
消息传输映射............................332
事务型客户端/ Actor对象 .........339
事务型客户端 ....................341
事务型 Actor对象 .............342
轮询消费者................................350
资源轮询 ............................354
由事件驱动的消费者................358
具有竞争性的消费者................359
消息调度器................................361
选择性消费者............................364
持久订阅者................................367
幂等接收者................................370
避免处理消息副本 ............370
使消息具有相同的效果 ....371
使状态切换操作不受收到消息副本的影响 .........372
服务激活剂................................378
小结.......379
第10章　系统管理和基础结构...... 380
控制总线....................................380
改道器...382
窃听器...384
消息元数据/历史记录 ...............385
消息日志/存储器 .......................389
智能代理....................................392
测试消息....................................397
通道净化器................................399
小结.......401
附录A　.NET平台上的Akka工具集：Dotsero. ................... 402
Dotsero的Actor系统 ..................402
通过C#和.NET使用Actor对象 .405
Dotsero实现 ...............................410
小结.......413
参考资料.. 414
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>响应式架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud与Docker微服务架构实战（第2版）
1 微服务架构概述  1
1.1 单体应用架构存在的问题  . 1
1.2 如何解决单体应用架构存在的问题  3
1.3 什么是微服务  . 3
1.4 微服务架构的优点与挑战  . 4
1.4.1 微服务架构的优点  5
1.4.2 微服务架构面临的挑战  5
1.5 微服务设计原则  6
1.6 如何实现微服务架构  7
1.6.1 技术选型  7
1.6.2 架构图及常用组件  8
2 微服务开发框架——Spring Cloud  . 9
2.1 Spring Cloud 简介  . 9
2.2 Spring Cloud 特点  . 10
2.3 Spring Cloud 版本  . 10
2.3.1 版本简介  10
2.3.2 子项目一览  . 12
2.3.3 Spring Cloud/Spring Boot 版本兼容性  . 13
3 开始使用Spring Cloud 实战微服务  14
3.1 Spring Cloud 实战前提  14
3.1.1 技术储备  14
3.1.2 工具及软件版本  . 15
3.2 服务提供者与服务消费者  . 16
3.3 编写服务提供者  16
3.3.1 手动编写项目  . 17
3.3.2 使用Spring Initializr 快速创建Spring Boot 项目  . 21
3.4 编写服务消费者  23
3.5 为项目整合Spring Boot Actuator  . 25
3.6 硬编码有哪些问题  28
4 微服务注册与发现  30
4.1 服务发现简介  . 30
4.2 Eureka 简介  . 32
4.3 Eureka 原理  . 32
4.4 编写Eureka Server  34
4.5 将微服务注册到Eureka Server 上  36
4.6 Eureka Server 的高可用  38
4.6.1 编写高可用Eureka Server  38
4.6.2 将应用注册到Eureka Server 集群上  41
4.7 用户认证  . 41
4.7.1 为Eureka Server 添加用户认证  . 41
4.7.2 将微服务注册到需认证的Eureka Server  43
4.8 Eureka 的元数据  43
4.8.1 改造用户微服务  . 43
4.8.2 改造电影微服务  . 44
4.9 Eureka Server 的REST 端点  46
4.9.1 示例  47
4.9.2 注销微服务实例  . 52
4.10 Eureka 的自我保护模式  . 53
4.11 多网卡环境下的IP 选择  . 54
4.12 Eureka 的健康检查  56
4.13 排除Jersey 依赖  . 57
5 使用Ribbon 实现客户端侧负载均衡  . 59
5.1 Ribbon 简介  59
5.2 为服务消费者整合Ribbon  . 60
5.3 Ribbon 配置自定义  63
5.3.1 使用Java 代码自定义Ribbon 配置  63
5.3.2 使用属性自定义Ribbon 配置  67
5.4 脱离Eureka 使用Ribbon  68
5.5 饥饿加载  . 70
6 使用Feign 实现声明式REST 调用  . 72
6.1 Feign 简介  73
6.2 为服务消费者整合Feign  73
6.3 自定义Feign 配置  . 75
6.3.1 使用Java 代码自定义Feign 配置  . 75
6.3.2 使用属性自定义Feign 配置  79
6.4 手动创建Feign  80
6.4.1 修改用户微服务  . 80
6.4.2 修改电影微服务  . 84
6.5 Feign 对继承的支持  . 86
6.6 Feign 对压缩的支持  . 87
6.7 Feign 的日志  87
6.7.1 编码方式设置日志级别  88
6.7.2 使用属性配置日志级别  89
6.8 使用Feign 构造多参数请求  90
6.8.1 GET 请求多参数的URL  . 90
6.8.2 POST 请求包含多个参数  91
6.9 使用Feign 上传文件  92
7 使用Hystrix 实现微服务的容错处理  . 94
7.1 实现容错的手段  94
7.1.1 雪崩效应  95
7.1.2 如何容错  95
7.2 使用Hystrix 实现容错  . 97
7.2.1 Hystrix 简介  . 97
7.2.2 通用方式整合Hystrix  98
7.2.3 Hystrix 断路器的状态监控与深入理解  102
7.2.4 Hystrix 线程隔离策略与传播上下文  103
7.2.5 Feign 使用Hystrix  . 106
7.3 Hystrix 的监控  112
7.4 使用Hystrix Dashboard 可视化监控数据  . 113
7.5 使用Turbine 聚合监控数据  116
7.5.1 Turbine 简介  116
7.5.2 使用Turbine 监控多个微服务  117
7.5.3 使用消息中间件收集数据  119
8 使用Zuul 构建微服务网关  124
8.1 为什么要使用微服务网关  . 124
8.2 Zuul 简介  . 126
8.3 编写Zuul 微服务网关  . 126
8.4 管理端点  . 129
8.4.1 routes 端点  129
8.4.2 filters 端点  131
8.5 路由配置详解  . 132
8.6 Zuul 的安全与Header  . 136
8.6.1 敏感Header 的设置  . 136
8.6.2 忽略Header  . 136
8.7 使用Zuul 上传文件  . 137
8.8 Zuul 的过滤器  140
8.8.1 过滤器类型与请求生命周期  . 140
8.8.2 内置过滤器详解  . 141
8.8.3 编写Zuul 过滤器  144
8.8.4 禁用Zuul 过滤器  146
8.9 Zuul 的容错与回退  146
8.10 饥饿加载  . 149
8.11 Query String 编码  . 150
8.12 Hystrix 隔离策略与线程池  . 150
8.12.1 隔离策略  150
8.12.2 线程池配置  . 151
8.13 Zuul 的高可用  152
8.13.1 Zuul 客户端也注册到了Eureka Server 上  . 152
8.13.2 Zuul 客户端未注册到Eureka Server 上  152
8.14 使用Sidecar 整合非JVM 微服务  . 154
8.14.1 编写Node.js 微服务  . 154
8.14.2 编写Sidecar  . 155
8.14.3 Sidecar 的端点  . 157
8.14.4 Sidecar 与Node.js 微服务分离部署  . 158
8.14.5 Sidecar 原理分析  158
8.15 使用Zuul 聚合微服务  . 160
9 使用Spring Cloud Config 统一管理微服务配置  166
9.1 为什么要统一管理微服务配置  . 166
9.2 Spring Cloud Config 简介  167
9.3 编写Config Server  . 168
9.4 编写Config Client  . 171
9.5 Config Server 的Git 仓库配置详解  . 173
9.5.1 占位符支持  . 173
9.5.2 模式匹配  174
9.5.3 搜索目录  174
9.5.4 启动时加载配置文件  175
9.6 Config Server 的健康状况指示器  . 176
9.7 配置内容的加解密  177
9.7.1 安装JCE  177
9.7.2 Config Server 的加解密端点  177
9.7.3 对称加密  177
9.7.4 存储加密的内容  . 178
9.7.5 非对称加密  . 179
9.8 使用/refresh 端点手动刷新配置  180
9.9 使用Spring Cloud Bus 自动刷新配置  . 181
9.9.1 Spring Cloud Bus 简介  181
9.9.2 实现自动刷新  . 182
9.9.3 局部刷新  183
9.9.4 架构改进  184
9.9.5 跟踪总线事件  . 184
9.10 Spring Cloud Config 与Eureka 配合使用  186
9.11 Spring Cloud Config 的用户认证  . 187
9.12 Config Server 的高可用  188
9.12.1 Git 仓库的高可用  188
9.12.2 RabbitMQ 的高可用  . 189
9.12.3 Config Server 自身的高可用  189
10 使用Spring Cloud Sleuth 实现微服务跟踪  . 191
10.1 为什么要实现微服务跟踪  . 191
10.2 Spring Cloud Sleuth 简介  . 192
10.3 整合Spring Cloud Sleuth  . 194
10.4 Spring Cloud Sleuth 与ELK 配合使用  . 196
10.5 Spring Cloud Sleuth 与Zipkin 配合使用  . 200
10.5.1 Zipkin 简介  . 200
10.5.2 编写Zipkin Server  . 200
10.5.3 微服务整合Zipkin  . 202
10.5.4 Zipkin 与Eureka 配合使用  . 205
10.5.5 使用消息中间件收集数据  206
10.5.6 使用Elasticsearch 存储跟踪数据  209
10.5.7 依赖关系图  . 211
11 Spring Cloud 常见问题与总结  . 213
11.1 Eureka 常见问题  213
11.1.1 Eureka 注册服务慢  213
11.1.2 已停止的微服务节点注销慢或不注销  214
11.1.3 如何自定义微服务的Instance ID  . 215
11.1.4 Eureka 的UNKNOWN 问题总结与解决  217
11.2 整合Hystrix 后首次请求失败  218
11.2.1 原因分析  218
11.2.2 解决方案  218
11.3 Turbine 聚合的数据不完整  219
11.4 Spring Cloud 各组件超时  220
11.4.1 RestTemplate 的超时  . 221
11.4.2 Ribbon 的超时  . 221
11.4.3 Feign 的超时  221
11.4.4 Hystrix 的超时  222
11.4.5 Zuul 的超时  . 222
11.5 Spring Cloud 各组件重试  223
11.5.1 重试步骤  224
11.5.2 基于HTTP 响应码重试  224
11.5.3 关闭重试  224
11.5.4 注意点  224
11.6 Spring Cloud 各组件调优  225
11.6.1 Tomcat 参数  . 225
11.6.2 Hystrix 参数  . 225
11.6.3 Feign 参数  226
11.6.4 Zuul 参数  . 226
11.7 Spring Cloud 各组件配置属性  228
11.7.1 Spring Boot 的配置  228
11.7.2 Spring Cloud 的配置  . 228
11.7.3 原生配置  229
11.8 Spring Cloud 定位问题思路总结  . 229
12 Docker 入门  232
12.1 Docker 简介  232
12.2 版本与迭代计划  232
12.2.1 版本区别  233
12.2.2 迭代计划  233
12.3 Docker 的架构  234
12.4 安装Docker  236
12.4.1 CentOS 7 安装Docker  . 236
12.4.2 Ubuntu 安装Docker  . 239
12.4.3 Windows 安装Docker  244
12.4.4 Mac OS 安装Docker  . 245
12.5 配置镜像加速器  245
12.6 Docker 常用命令  246
12.6.1 Docker 镜像常用命令  246
12.6.2 Docker 容器常用命令  252
13 将微服务运行在Docker 上  260
13.1 使用Dockerfile 构建Docker 镜像  260
13.1.1 Dockerfile 常用指令  . 261
13.1.2 使用Dockerfile 构建镜像  266
13.2 使用Docker Registry 管理Docker 镜像  . 268
13.2.1 使用Docker Hub 管理镜像  . 268
13.2.2 使用私有仓库管理镜像  270
13.3 使用Maven 插件构建Docker 镜像  . 271
13.3.1 快速入门  272
13.3.2 插件读取Dockerfile 进行构建  273
13.3.3 将插件绑定在某个phase 执行  274
13.3.4 推送镜像  275
13.4 常见问题与总结  277
14 使用Docker Compose 编排微服务  . 278
14.1 Docker Compose 简介  . 278
14.2 安装Docker Compose  . 279
14.2.1 安装Compose  . 279
14.2.2 安装Compose 命令补全工具  . 279
14.3 Docker Compose 快速入门  . 280
14.3.1 基本步骤  280
14.3.2 入门示例  280
14.3.3 工程、服务、容器  281
14.4 docker-compose.yml 常用命令  . 281
14.5 docker-compose 常用命令  . 285
14.6 Docker Compose 网络设置  . 286
14.6.1 基本概念  286
14.6.2 更新容器  287
14.6.3 links  287
14.6.4 指定自定义网络  . 288
14.6.5 配置默认网络  . 289
14.6.6 使用已存在的网络  289
14.7 综合实战：使用Docker Comose 编排Spring Cloud 微服务  289
14.7.1 编排Spring Cloud 微服务  289
14.7.2 编排高可用的Eureka Server  293
14.7.3 编排高可用Spring Cloud 微服务集群及动态伸缩  . 295
14.8 常见问题与总结  297
后记  298
附录A：本书配套代码  . 299
附录B：Spring Cloud YES——快速开发脚手架  300
附录C：使用Docker 快速安装本书中的组件  301
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud与Docker微服务架构实战（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向模式的软件架构，卷3
目 录
第1章 　绪论　　1
1.1 　资源管理概述　　2
1.2 　资源管理的范畴　　4
1.3 　模式的用途　　5
1.4 　资源管理模式　　6
1.5 　相关成果　　7
1.6 　模式描述模板　　10
第2章 　资源获取　　11
2.1 　Lookup模式　　12
2.2 　Lazy Acquisition模式　　23
2.3 　Eager Acquisition模式　　33
2.4 　Partial Acquisition模式　　43
第3章 　资源生命周期　　53
3.1 　Caching模式　　54
3.2 　Pooling模式　　63
3.3 　Coordinator模式　　73
3.4 　Resource Lifecycle Manager模式　　84
第4章 　资源释放　　97
4.1 　Leasing模式　　97
4.2 　Evictor模式　　111
第5章 　资源管理模式应用指南　　120
第6章 　案例研究：自组网　　122
6.1 　概述　　122
6.2 　动机　　123
6.3 　解决方案　　124
第7章 　案例研究：移动网络　　129
7.1 　概述　　129
7.2 　动机　　132
7.3 　解决方案　　132
7.3.1 　基站的架构　　133
7.3.2 　基站的功能规范　　134
7.3.3 　OMC的架构　　138
7.3.4 　OMC的功能规范　　139
第8章 　模式的过去、现在和将来　　145
8.1 　最近4年的概况　　145
8.1.1 　模式　　145
8.1.2 　模式语言　　147
8.1.3 　经验报告、方法和工具　　148
8.1.4 　模式汇编　　148
8.1.5 　模式和模式语言的正式化　　148
8.2 　模式的现状　　148
8.3 　模式将走向何方　　149
8.3.1 　模式和模式语言　　149
8.3.2 　理论和概念　　151
8.3.3 　重构和集成　　151
8.3.4 　四人组　　152
8.4 　对预测的简单说明　　152
第9章 　结语　　153
引用的模式　　155
表示法　　159
参考文献　　164
模式索引　　176
索引　　178
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向模式的软件架构，卷3
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据架构师指南
第一部分 大数据架构师入门
第1章 大数据概述 3
1.1 什么是大数据 4
1.2 大数据的本质 6
1.3 大数据技术当前状态 8
1.4 大数据的技术发展趋势 11
第2章 大数据项目常见场景 13
2.1 实验型部署场景 14
2.2 中小型部署场景 16
2.3 大型部署场景 19
第3章 大数据方案关键因素 23
3.1 数据存储规模与数据类型 24
3.2 数据来源与数据质量 25
3.3 业务特征 26
3.4 经济可行性 27
3.5 运维管理要求 28
3.6 安全性要求 29
3.7 部署要求 31
3.8 系统边界 32
3.9 约束条件 34
3.10 要点回顾 34
第二部分 大数据架构师基础
第4章 Hadoop基础组件 39
4.1 Hadoop简介 40
4.2 Hadoop版本演进 41
4.3 Hadoop2.0生态系统简介 42
4.4 Hadoop分布式文件系统HDFS 43
4.5 Hadoop统一资源管理框架YARN 48
4.6 Hadoop分布式计算框架MapReduce 52
4.7 Hadoop分布式集群管理系统ZooKeeper 57
第5章 Hadoop其他常用组件 61
5.1 Hadoop数据仓库工具Hive 62
5.2 Hadoop分布式数据库 HBase 65
5.3 Hadoop实时流处理引擎 Storm 70
5.4 Hadoop交互式查询引擎 Impala 74
5.5 其他常用组件 78
第6章 Spark内存计算框架 83
6.1 内存计算与Spark 84
6.2 Spark的主要概念 86
6.3 Spark核心组件介绍 96
6.4 Spark与Hadoop之间的关系 100
6.5 要点回顾 104
第7章大数据中间件层 105
7.1 中间件层简介 106
7.2 中间件层产品介绍 107
7.3 中间件层的应用 121
7.4 中间件层的发展 124
7.5 要点回顾 128
第8章大数据分析 129
8.1 数据时代 131
8.2 先进分析 133
8.3 架构与平台 136
8.4 数据分析流程 140
8.5 要点回顾 143
第9章可视化技术 145
9.1 可视化技术引言 146
9.2 什么是数据可视化 147
9.3 数据可视化设计 151
9.4 数据可视化的发展趋势 160
9.5 要点回顾 161
第10章大数据安全 163
10.1 安全体系 164
10.2 大数据系统安全 168
10.3 要点回顾 180
第11章大数据管理 181
11.1 数据管理的范围和定义 182
11.2 开源软件的管理能力 183
11.3 国内主流管理 187
11.4 大数据管理展望 195
11.5 要点回顾 195
第三部分大数据架构师实践
第12章大数据项目实践 199
12.1 大数据项目架构关键步骤 201
12.2 架构师实践思考 213
第13章大数据部署实践 217
13.1 中兴通讯DAP大数据平台功能和架构 218
13.2 DAP平台特点 219
13.3 某银行成功案例 220
第四部分 大数据架构师拓展
第14章分布式系统与大数据的关系 229
14.1 分布式系统概述 230
14.2 分布式系统关键协议和算法概述 237
14.3 分布式系统和大数据 241
第 15 章数据库系统与大数据的关系 245
15.1 数据库系统的历史 246
15.2 各类系统求同存异 258
15.3 大数据的发展展望 259
第16章云计算与大数据的关系 261
16.1 虚拟化概述 262
16.2 OpenStack云管理架构实现 267
16.3 大数据基于云计算IAAS部署的探讨 274
后记 277
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据架构师指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>可伸缩架构
序  xv
前言 xvii
第Ⅰ部分可用性
第 1章　什么是可用性 2
可用性与可靠性  3
什么导致了低可用性  4
第 2章　提高应用程序可用性的五个要点 6
要点 1：时刻考虑应对故障  7
要点 2：时刻考虑如何伸缩  8
要点 3：缓和风险  9
要点 4：监控可用性  10
要点 5：以预测和确定的方式来应对可用性问题  11
做好准备  12
第 3章　测量可用性 13
N个 9  14
-- 什么样的可用性是合理的 14
不要上当  14
通过数字来体现可用性 15
第4 章　提高下降的可用性 16
测试并跟踪当前的可用性  17
将手动流程自动化  17
-- 自动化部署 18
-- 配置管理  18
-- 更改实验和高频次更改  19
-- 自动化的变更完备性测试 20
改进你的系统  20
不断变化和发展中的应用程序 20
时刻关注可用性  21
第Ⅱ部分 风险管理
第 5章　什么是风险管理. 24
管理风险  25
识别风险  25
消除最严重的风险  26
风险缓和  26
定期检查  27
对风险管理的总结  27
第 6章　可能性与严重性. 28
10佳列表：低可能性，低严重性  29
订单数据库：低可能性，高严重性  29
自定义字体：高可能性，低严重性  30
T恤图片：高可能性，高严重性 31
第 7章　风险模型 32
风险模型的作用域  34
创建风险模型  34
-- 通过头脑风暴建立风险列表  35
-- 填写可能性和严重性字段 36
-- 风险项详情 37
-- 缓和计划  37
-- 触发计划  37
使用风险模型来制订计划  37
维护风险模型  38
第 8章　风险缓和 40
恢复计划  41
容灾计划  42
改进我们的风险状况 43
第 9章　比赛日 44
预发布环境和生产环境. 44
在生产环境中举行比赛日的担心 46
比赛日测试 47
第 10章　构建低风险系统 48
冗余  48
幂等接口示例  49
增加了复杂性的冗余改进  49
独立性  50
安全  51
简单性  51
自修复  52
运维流程  53
第Ⅲ部分　服务和微服务
第 11章　为什么使用服务.  56
单体应用程序  56
基于服务的应用程序 57
所有权收益 58
规模收益  60
第12 章　使用微服务 62
如何定义服务  63
-- 深入了解服务  63
-- 指导原则 1：特定的业务需求 63
-- 指导原则 2：清晰和独立的团队所有权 64
-- 指导原则 3：天然隔离的数据 65
-- 指导原则 4：共享的能力 /数据 67
-- 多种原因  67
过犹不及  68
适当的平衡 69
第 13章　处理服务故障 70
级联式的服务故障  70
如何响应服务故障  71
-- 可预测的响应  72
-- 可理解的响应  73
-- 合理的响应 73
如何确定故障  74
适当的行为 76
-- 优雅降级  76
-- 优雅补偿  77
-- 尽早失败  77
-- 用户导致的问题 78
第4部分 如何让应用程序具有伸缩性
第 14章　两次失误的高度 82
什么是“两次失误的高度” 83
实践中的“两次失误的高度”  83
-- 丢失一个节点  83
-- 升级过程中出现的问题  85
-- 数据中心恢复  86
-- 隐蔽的共享故障类型  88
-- 故障循环 89
管理你的应用程序  90
航天飞机  90
第 15章　服务所有权 92
由独立团队负责的服务架构  92
STOSA应用程序和组织的好处  94
成为一个服务所有者意味着什么 94
第 16章　服务分级. 97
应用复杂性 97
什么是服务分级  98
为服务分配服务级别标签  99
-- 1级服务 99
-- 2级服务 99
-- 3级服务  100
-- 4级服务  100
示例：在线商店 100
接下来呢  103
第 17章　使用服务分级. 104
期望  104
响应性 104
依赖  106
-- 关键依赖 106
-- 非关键依赖. 107
小结  107
第 18章　服务等级协议. 108
什么是服务等级协议  108
外部 SLA与内部 SLA的对比  110
为什么内部 SLA很重要  110
SLA可以作为一种信任的手段 111
SLA可以用于问题诊断 111
SLA 的性能检测方法 112
-- 限定 SLA 113
-- 排名 SLA 113
-- 延迟分组 115
究竟应当定义多少内部 SLA，以及定义哪些内部 SLA 116
关于 SLA的其他评价 116
第Ⅴ部分　云服务
第 19章　持续改进.  117
定期检查你的应用程序 117
微服务 118
服务所有权  118
无状态服务  118
数据在哪里  118
数据分区  119
持续改进的重要性  121
第 20章　变化和云服务.124
云服务有哪些变化  124
-- 对基于微服务架构的认可  124
-- 更小、更专业的服务 125
-- 更专注于应用程序 125
-- 微型初创公司  125
-- 安全和合规已经成熟 125
变化还在继续 125
第 21章　云上的分布.127
AWS的架构 127
-- AWS区域  127
-- AWS可用区  128
-- 数据中心 128
总体架构概述 129
可用区不是数据中心 131
如何通过地理多样性真正做到高可用  133
第 22章　托管的基础设施. 134
基于云的服务架构  134
-- 原生资源 135
-- 托管资源（基于服务器）  136
-- 托管资源（不基于服务器） 137
使用托管资源的影响  138
使用非托管资源的影响 138
监控和 CloudWatch  138
第 23章　云资源分配.  140
固定额度的资源分配  140
-- 调整分配 141
-- 预留容量 142
基于使用量的资源分配 143
-- 基于使用量分配资源的好处 144
资源分配技术的利与弊 145
第 24章　可伸缩的计算选项. 146
云服务器  147
-- 优点  147
-- 缺点  147
-- 适用场景 147
计算分片  147
-- 优点  147
-- 缺点  148
-- 适用场景 148
动态容器  148
-- 优点  148
-- 缺点  149
-- 适用场景 149
微计算 149
-- 优点  149
-- 缺点  150
-- 适用场景 149
如何选择  150
第 25章　AWS.Lambda. 151
使用 Lambda  151
-- 事件处理 151
-- 手机应用后台  152
-- 物联网数据采集  153
Lambda的优缺点 154
第Ⅵ部分　总结
第 26章　融会贯通156
可用性 156
风险管理  157
服务  157
扩展  157
云服务 158
面向可伸缩的架构  158
索引 159
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>可伸缩架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Struts2技术内幕
《struts2技术内幕：深入解析struts架构设计与实现原理》
前　言
第一部分　知识准备篇
第1章　厉兵秣马—开发环境准备 / 3
1.1　准备源代码阅读环境 / 3
1.1.1　安装与配置jdk / 3
1.1.2　安装eclipse与源码调试 / 5
1.1.3　安装与配置web服务器 / 7
1.1.4　在eclipse中使用jetty搭建web开发环境 / 8
1.2　获取struts2 / 12
1.2.1　struts2的相关资源下载 / 12
1.2.2　struts2项目的目录组织结构 / 13
1.3　struts2源码的初步研究 / 14
1.3.1　源码的组织形式 / 14
1.3.2　调试struts2源码 / 15
1.4　小结 / 18
第2章　固本清源—web开发浅谈 / 20
2.1　面向对象浅谈 / 20
2.1.1　对象构成模型 / 21
2.1.2　对象关系模型 / 25
.2.1.3　面向对象编程的基本观点 / 28
2.2　框架的本质 / 30
2.3　最佳实践 / 34
2.4　web开发的基本模式 / 36
2.4.1　分层开发模式 / 36
2.4.2　mvc模式 / 38
2.5　表示层的困惑 / 40
2.6　如何学习开源框架 / 45
2.7　小结 / 49
第3章　提纲挈领—struts2概览 / 50
3.1　struts2的来世今生 / 50
3.2　struts2面面观 / 51
3.2.1　struts2的运行环境 / 52
3.2.2　struts2的应用场景 / 53
3.2.3　struts2的核心技术 / 54
3.3　多视角透析struts2 / 56
3.3.1　透视镜 — struts2的宏观视图 / 56
3.3.2　显微镜 — struts2的微观元素 / 60
3.4　struts2的配置元素 / 64
3.4.1　struts2配置详解 / 65
3.4.2　struts2配置元素定义 / 67
3.4.3　struts2配置元素的分类 / 71
3.5　小结 / 72
第二部分　核心技术篇
第4章　源头活水—struts2中的设计模式 / 75
4.1　threadlocal模式 / 75
4.1.1　线程安全问题的由来 / 75
4.1.2　threadlocal模式的实现机理 / 78
4.1.3　threadlocal模式的应用场景 / 81
4.1.4　threadlocal模式的核心元素 / 82
4.2　装饰（decorator）模式 / 85
4.2.1 　装饰模式的定义 / 85
4.2.2　装饰模式的构成要素 / 86
4.2.3　装饰模式的应用案例 / 87
4.3　策略（strategry）模式 / 90
4.3.1　策略模式的定义 / 90
4.3.2　策略模式的应用场景 / 91
4.3.3 　策略模式的深入思考 / 93
4.4　构造（builder）模式 / 95
4.4.1　构造模式的核心要素 / 95
4.4.2　构造模式的应用场景 / 97
4.4.3　对象构造步骤 / 100
4.5　责任链（chain of responsibility）模式 / 101
4.5.1　责任链模式的定义 / 101
4.5.2　责任链模式的逻辑意义 / 102
4.6　小结 / 103
第5章　生命之源—xwork中的容器 / 105
5.1　容器，对象生命周期管理的基石 / 105
5.1.1　对象的生命周期管理 / 105
5.1.2　容器（container）的引入 / 106
5.1.3　容器（container），不是容器（collection） / 107
5.2　xwork容器概览 / 108
5.2.1　xwork容器的定义 / 108
5.2.2　xwork容器的管辖范围 / 111
5.2.3　xwork容器操作详解 / 113
5.3　深入浅出xwork容器 / 117
5.3.1　xwork容器的存储结构 / 117
5.3.2　xwork容器的实现机理 / 124
5.4　统一的容器操作接口—objectfactory / 129
5.5　小结 / 135
第6章　灵丹妙药—ognl，数据流转的催化剂 / 136
6.1　架起数据沟通的桥梁 — 表达式引擎 / 136
6.1.1　数据流转的困境 / 136
6.1.2　数据访问的困境 / 138
6.1.3　表达式引擎 / 138
6.2　强大的ognl / 140
6.2.1　深入ognl的api / 140
6.2.2　ognl三要素 / 142
6.2.3　ognl的基本操作 / 143
6.2.4　深入this指针 / 146
6.2.5　有关#符号的三种用途 / 147
6.3　深入ognl内部 / 147
6.3.1　深入ognlcontext / 147
6.3.2　深入ognl的计算规则 / 150
6.3.3　深入ognl的扩展方式 / 164
6.4　小结 / 173
第7章　别具匠心—xwork设计原理 / 175
7.1　请求-响应的哲学 / 175
7.1.1　请求-响应的基本概念 / 175
7.1.2　请求-响应的实现模式 / 177
7.1.3　分歧和职责 / 181
7.2　数据流和控制流 / 184
7.2.1　再谈mvc / 184
7.2.2　数据载体的战争 / 186
7.2.3　控制流的细节 / 191
7.3　xwork概览 / 193
7.3.1　xwork的宏观视图 / 193
7.3.2　xwork的微观视图 / 195
7.4　小结 / 199
第8章　庖丁解牛—xwork元素详解 / 200
8.1　深入xwork宏观视图 / 200
8.1.1　数据流体系 / 200
8.1.2　控制流体系 / 203
8.2　数据流体系 — 相互依存 / 205
8.2.1　actioncontext — 一个平行世界 / 205
8.2.2　valuestack — 对ognl的扩展 / 216
8.2.3　深入valuestack的实现 / 225
8.2.4　形影不离、相互依存的actioncontext与valuestack / 231
8.3　控制流体系 — 有条不紊 / 233
8.3.1　action — 革命性突破 / 233
8.3.2　interceptor—腾飞的翅膀 / 238
8.3.3　actioninvocation—核心调度 / 247
8.3.4　actionproxy—执行窗口 / 254
8.4　交互体系—水乳交融 / 258
8.4.1　数据环境的生命周期 / 259
8.4.2　三军会师之地 / 260
8.4.3　action交互体系 / 261
8.5　小结 / 268
第三部分　运行主线篇
第9章　包罗万象—struts2初始化主线 / 273
9.1　配置元素与初始化主线 / 273
9.1.1　从入口程序开始 / 273
9.1.2　初始化主线的核心驱动力 / 276
9.1.3　初始化主线的构成元素 / 277
9.2　核心分发器 — dispatcher / 278
9.2.1　核心分发器的核心驱动作用 / 278
9.2.2　核心分发器的数据结构 / 280
9.3　配置元素的加载器（provider） / 282
9.3.1　配置元素加载器的作用 / 282
9.3.2　容器加载器—containerprovider / 283
9.3.3　事件映射加载器—packageprovider / 285
9.4　配置元素的构造器（builder） / 288
9.4.1　容器构造器—containerbuilder / 289
9.4.2　事件映射构造器 — packageconfig.builder / 290
9.5　配置元素的管理类 / 295
9.5.1　配置管理元素 — configuration / 296
9.5.2　配置操作接口 — configurationmanager / 299
9.6　struts2初始化主线详解 / 300
9.6.1　核心分发器的初始化 / 301
9.6.2　容器的初始化 / 306
9.7　小结 / 313
第10章　井然有序—与http请求的战斗 / 314
10.1　制定作战计划 / 314
10.1.1　战斗资源 / 314
10.1.2　战斗进程 / 315
10.2　第一战场—http请求的预处理阶段 / 317
10.2.1　三探入口程序 / 317
10.2.2　http请求预处理类—prepareoperations / 320
10.2.3　http请求的执行类—executeoperations / 326
10.3　第二战场 — xwork处理阶段 / 330
10.3.1　执行控制权的移交 / 330
10.3.2　actioninvocation调度的再分析 / 334
10.4　小结 / 338
第11章　展翅高飞 — 让视图放开手脚 / 339
11.1　视图（view）概述 / 339
11.1.1　视图表现技术 / 339
11.1.2　视图的本质 / 343
11.1.3　视图的职责 / 344
11.2　深入result机制 / 345
11.2.1　result的不同视角 / 345
11.2.2　result职责分析 / 348
11.3　标签库，永恒的争论话题 / 349
11.3.1　标签库产生的初衷 / 350
11.3.2　标签库，毒药还是解药 / 350
11.3.3　标签库的发展趋势 / 352
11.3.4　标签的分类 / 353
11.4　数据访问的哲学 / 354
11.4.1　不要问我从哪里来 / 354
11.4.2　不要问我长什么样 / 358
11.5　小结 / 359
第12章　三头六臂—struts2的扩展机制 / 360
12.1　程序扩展机制的深入思考 / 360
12.1.1　插件模式的基本概念 / 360
12.1.2　常见的插件模式 / 362
12.1.3　插件模式的利弊分析 / 364
12.2　struts2的插件模式 / 366
12.2.1　深入struts2插件 / 366
12.2.2　struts2插件分类 / 369
12.2.3　struts2的插件加载机制 / 372
12.3　小结 / 379
后记 / 380
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Struts2技术内幕
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云原生应用架构实践
引子	1
第1章　互联网系统架构的挑战	2
1.1  云应用架构技术发展	4
1.2  云平台下架构的不同点	5
1.2.1  开发模式的区别	6
1.2.2  交付模式的区别	7
1.2.3  架构设计的区别	8
1.3  云原生应用架构	10
1.4  架构演化发展历程	21
1.4.1  初创期架构	22
1.4.2  快速成长期架构	24
1.4.3  分布式服务架构	26
1.5  云计算服务介绍	29
1.6  云计算解决方案	31
1.7  案例概述	34
1.7.1  背景介绍	34
1.7.2  环境要求	36
1.7.3  项目构建	36
1.7.4  项目运行	36
1.7.5  相关技术介绍	37
小结	40
第2章  从0到1工程实践	41
2.1  工程化	41
2.1.1  工程模板	41
2.1.2  模块化	45
2.1.3  工程化构建	50
2.1.4  代码规范及检查	53
2.1.5  代码版本管理	54
2.1.6  环境划分	61
2.2  基于容器工程化	62
2.2.1  Docker及作用	63
2.2.2  Docker镜像及操作	66
2.2.3  Docker容器及操作	73
2.2.4  基于容器工程化	77
2.3  实战示例	78
小结	84
第3章  初创期应用架构实践	85
3.1  技术选型	85
3.1.1  业务框架选型	85
3.1.2  结构化数据存储	92
3.1.3  缓存选型	102
3.1.4  静态资源存储	106
3.2  架构实践	109
3.2.1  快速迭代	109
3.2.2  高可用与负载均衡	111
3.2.3  交付与部署	117
3.2.4  Web应用安全	119
3.3  应用监控	127
3.3.1  应用监控指标	127
3.3.2  应用进程监控	128
3.3.3  操作系统监控	129
小结	136
第4章  快速成长期应用架构实践	137
4.1  关键业务需求	137
4.1.1  计数与排序	137
4.1.2  秒杀	146
4.1.3  全文检索	149
4.1.4  日志收集	154
4.2  架构实践	156
4.2.1  前端系统扩展	157
4.2.2  无状态服务设计	157
4.2.3  在线水平扩展	160
4.2.4  后端系统扩展	163
4.2.5  系统通信	173
4.2.6  消息中间件	176
4.3  系统优化	181
4.3.1  静态资源分离	182
4.3.2  数据库调优	185
4.3.3  系统高可用	193
4.4  应用诊断	200
4.4.1  应用健康检查	200
4.4.2  性能问题诊断	204
4.4.3  基于日志的故障诊断	210
4.5  数据库诊断	214
4.6  DevOps	223
4.6.1  持续集成	224
4.6.2  持续交付	227
4.6.3  灰度发布	229
4.6.4  大应用编排	231
4.7  安全设计	246
4.7.1  入侵检测	247
4.7.2  防劫持攻击	249
小结	255
第5章  稳定期服务化应用架构实践	256
5.1  业务拆分	256
5.2  统一配置中心	259
5.3  分布式定时任务	261
5.3.1  分布式定时任务设计	262
5.3.2  业界流行的开源框架	264
5.4  分布式锁系统	274
5.5  微服务化架构	277
5.5.1  服务发现	279
5.5.2  服务治理	302
5.5.3  微服务框架	307
5.5.4  服务编排	313
5.5.5  微服务测试	321
5.6  分布式数据一致性	333
5.6.1  CAP和BASE理论	333
5.6.2  一致性模型	336
5.6.3  典型的解决方案	337
5.7  同城多活	344
5.7.1  应用同城多活	345
5.7.2  跨AZ负载均衡	347
5.8  故障诊断	348
小结	353
参考文献	354
技术术语	356
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云原生应用架构实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微软应用架构指南
序一   I
序二   II
前言   III
导言   IV
软件架构和设计篇	1
第1章  什么是软件架构	3
1.1  为什么架构很重要？	3
1.2  架构的目标	4
1.2.1  架构风景线（Architectural Landscape）	5
1.3  架构设计的原则	5
1.3.1  关键设计原则	6
1.3.2  其他资源	6
第2章  软件架构的关键原则	7
2.1  概览	7
2.2  关键设计原则	8
2.3  关键设计考量	10
2.3.1  确定应用程序类型	10
2.3.2  确定部署策略	11
2.3.3  确定合适的技术	11
2.3.4  确定质量特性	11
2.3.5  确定横切关注点	11
第3章  架构模式和风格	13
3.1  概览	13
3.2  什么是架构风格？	13
3.3  关键架构风格小结	14
3.3.1  组合架构风格	14
3.4  客户端/服务端架构风格	15
3.5  基于组件的架构风格	16
3.6  领域驱动设计架构风格	17
3.7  分层架构风格	18
3.8  消息总线架构风格	20
3.9  N层/三层架构风格	21
3.10  面向对象架构风格	21
3.11  面向服务架构风格	22
3.12  其他资源	23
第4章  架构和设计的方法	25
4.1  概览	25
4.2  输入、输出和设计步骤	25
4.3  确定架构目标	26
4.3.1  范围和时间	26
4.4  关键应用场景	27
4.4.1  对架构重要的用例	27
4.5  应用程序概览	28
4.5.1  相关技术	29
4.5.2  画出您的架构	29
4.6  关键问题	30
4.6.1  质量特性	30
4.6.2  横切关注点	30
4.6.3  用于减少问题的设计	31
4.7  候选解决方案	32
4.7.1  基准架构和候选架构	32
4.7.2  架构刺探	33
4.8  接下去做什么	33
4.9  评审架构	33
4.9.1  基于应用场景的评估	33
4.10  展示和沟通您的架构设计	34
4.11  其他资源	35
设计基础篇	37
第5章  分层应用程序指导原则	39
5.1  概览	39
5.2  逻辑分层设计	39
5.2.1  表现层、业务层和数据层	39
5.3  服务和分层	40
5.3.1  服务层	41
5.4  分层结构的设计步骤	42
步骤1：选择您的分层策略	42
步骤2：确定您需要的分层	43
步骤3：确定如何分布层和组件	43
步骤4：确定是否需要收缩层	43
步骤5：确定层之间交互的规则	44
步骤6：找出横切关注点	44
步骤7：定义层之间的接口	44
步骤8：选择您的部署策略	45
步骤9：选择通信协议	46
第6章  表现层指导原则	47
6.1  概览	47
6.2  总体设计考量	48
6.3  特定设计问题	49
6.3.1  缓存	49
6.3.2  通信	50
6.3.3  组合	50
6.3.4  异常管理	50
6.3.5  导航	51
6.3.6  用户体验	51
6.3.7  用户界面	52
6.3.8  验证	52
6.4  技术考量	53
6.4.1  移动应用程序	53
6.4.2  富客户端应用程序	53
6.4.3  富互联网应用程序	53
6.4.4  Web应用程序	54
6.5  性能考量	54
6.6  表现层设计步骤	55
6.7  相关设计模式	56
6.8  模式和实践团队提供的产品	57
6.9  其他资源	57
第7章  业务层指导原则	59
7.1  概览	59
7.2  总体设计考量	60
7.3  特定设计问题	61
7.3.1  身份验证	61
7.3.2  授权	61
7.3.3  缓存	62
7.3.4  耦合和内聚	62
7.3.5  异常管理	63
7.3.6  日志、审核和指示器（Instrumentation）	63
7.3.7  验证	63
7.4  部署考量	64
7.5  业务层的设计步骤	64
7.6  相关设计模式	65
7.7  模式和实践小组提供的产品	65
7.8  其他资源	66
第8章  数据层指导原则	67
8.1  概览	67
8.2  总体设计考量	68
8.3  特定设计问题	69
8.3.1  批量处理	69
8.3.2  二进制大对象	70
8.3.3  连接	70
8.3.4  数据格式	70
8.3.5  异常管理	71
8.3.6  对象关系映射	71
8.3.7  查询	72
8.3.8  存储过程	72
8.3.9  存储过程和动态SQL	72
8.3.10  事务	73
8.3.11  验证	74
8.3.12  XML	74
8.4  技术考量	75
8.5  性能考量	75
8.6  安全考量	76
8.7  部署考量	76
8.8  数据层的设计步骤	76
8.9  相关设计模式	77
8.10  其他资源	78
第9章  服务层指导原则	81
9.1  概览	81
9.2  设计考量	82
9.3  具体设计问题	83
9.3.1  身份验证	83
9.3.2  授权	83
9.3.3  通信	84
9.3.4  异常管理	84
9.3.5  消息信道	84
9.3.6  消息构建	85
9.3.7  消息端点	85
9.3.8  消息保护	85
9.3.9  消息路由	86
9.3.10  消息转换	86
9.3.11  服务接口	86
9.3.12  验证	87
9.4  REST和SOAP	87
REST设计考量	88
SOAP设计考量	88
9.5  技术考量	89
9.6  部署考量	89
9.7  服务层的设计步骤	90
9.8  相关设计模式	90
9.9  其他资源	93
第10章  组件指导原则	95
10.1  概览	95
10.2  组件设计总体指导原则	95
10.3  分层组件分布	96
10.4  表现层组件	96
10.5  服务层组件	97
10.6  业务层组件	97
10.7  数据层组件	98
10.8  横切组件	99
10.9  相关设计模式	99
10.10  模式和实践团队提供产品	100
10.11  其他资源	101
第11章  设计表现组件	103
11.1  概览	103
11.2  第一步：理解UI需求	103
11.3  第二步：确定需要的UI类型	104
11.4  第三步：选择UI技术	104
11.5  第四步：设计表现组件	106
11.5.1  用户界面组件	106
11.5.2  表现逻辑组件	107
11.5.3  表现模型组件	107
11.5.4  表现实体	108
11.6  第五步：确定绑定需求	109
11.7  第六步：确定错误处理策略	110
11.8  第七步：确定验证策略	111
11.9  模式和实践小组提供的产品	111
11.10  其他资源	112
第12章  设计业务组件	113
12.1  概览	113
12.2  第一步：确定您的应用程序将会使用的业务组件	113
12.3  第二步：为业务组件进行关键决策	114
12.4  第三步：选择合适的事务支持	114
12.5  第四步：确定如何处理业务规则	115
12.6  第五步：确定满足需求的模式	116
12.7  其他资源	117
第13章  设计业务实体	119
13.1  概览	119
13.2  第一步：选择表现方式	119
13.3  第二步：为业务实体选择设计	120
13.4  第三步：确定序列化支持	120
13.5  领域驱动设计	121
13.6  其他资源	122
第14章  设计业务工作流	123
14.1  概览	123
14.2  第一步：根据应用场景确定工作流风格	123
14.3  第二步：选择编写模式	124
14.4  第三步：确定如何处理规则	124
14.5  第四步：选择工作流解决方案	124
14.6  第五步：设计业务组件来支持工作流	125
14.6.1  Windows Workflow Foundation	125
14.6.2  BizTalk服务器	126
14.6.3  带ESB的BizTalk	126
14.6.4  结合使用Windows Workflow Foundation和BizTalk	127
14.7  其他资源	128
第15章  设计数据组件	129
15.1  概览	129
15.2  第一步：选择数据访问技术	129
15.3  第二步：选择如何从数据源获取和持久化业务对象	130
15.4  第三步：确定如何连接数据源	130
15.4.1  连接	130
15.4.2  连接池	131
15.4.3  事务和并发	132
15.5  第四步：确定处理数据源错误的策略	133
15.5.1  异常	133
15.5.2  重试逻辑	133
15.5.3  超时	134
15.6  第五步：设计服务代理组件（可选）	134
15.7  其他资源	134
第16章  质量特性	135
16.1  概览	135
16.2  常见质量特性	135
16.2.1  可用性	137
16.2.2  概念完整性	137
16.2.3  互操作性	138
16.2.4  可维护性	138
16.2.5  可管理性	139
16.2.6  性能	139
16.2.7  可靠性	140
16.2.8  可重用性	140
16.2.9  可伸缩性	141
16.2.10  安全性	141
16.2.11  可支持性	142
16.2.12  可测试性	142
16.2.13  用户体验/易用性	143
16.3  其他资源	143
第17章  横切关注点	145
17.1  概览	145
17.2  总体设计考量	145
17.3  具体设计问题	146
17.3.1  身份验证	146
17.3.2  授权	147
17.3.3  缓存	147
17.3.4  通信	148
17.3.5  配置管理	148
17.3.6  异常管理	149
17.3.7  日志和指示器	149
17.3.8  状态管理	150
17.3.9  验证	150
17.4  缓存的设计步骤	151
17.4.1  第一步：确定要缓存的数据	151
17.4.2  第二步：确定数据缓存在哪里	151
17.4.3  第三步：确定缓存数据的格式	152
17.4.4  第四步：确定合适的缓存管理策略	152
17.4.5  第五步：确定如何加载缓存数据	153
17.5  异常管理的设计步骤	154
17.5.1  第一步：确定需要处理的异常	154
17.5.2  第二步：确定您的异常检测策略	154
17.5.3  第三步：确定异常的传播策略	154
17.5.4  第四步：确定您自定义异常的策略	155
17.5.5  第五步：确定需要收集的信息	155
17.5.6  第六步：确定异常日志记录策略	156
17.5.7  第七步：确定您的异常通知策略	156
17.5.8  第八步：确定如何处理未处理异常	156
17.6  验证输入和验证数据的设计步骤	157
17.6.1  第一步：确定信任边界	157
17.6.2  第二步：确定关键应用场景	157
17.6.3  第三步：确定哪里需要验证	157
17.6.4  第四步：确定验证策略	158
17.7  相关设计模式	158
17.8  模式和实践团队的解决方案产品	158
17.9  其他资源	159
第18章  通信和消息	161
18.1  概览	161
18.2  总体设计指导原则	161
18.3  基于消息通信的指导原则	162
18.3.1  异步和同步通信	163
18.3.2  耦合和内聚	163
18.3.3  数据格式	163
18.3.4  互操作性	164
18.3.5  性能	165
18.3.6  状态管理	165
18.4  契约先行设计	165
18.5  安全考量	166
18.5.1  传输安全	166
18.5.2  消息安全	167
18.6  技术选项	167
18.6.1  WCF技术选项	167
18.6.2  ASMX技术选项	168
18.7  其他资源	168
第19章  物理层和部署	169
19.1  概览	169
19.2  分布式和非分布式部署	169
19.2.1  非分布式部署	169
19.2.2  分布式部署	170
19.2.3  分布式环境的性能和设计考量	170
19.2.4  针对分布式部署中定位组件的一些建议	171
19.3  分布式部署模式	172
19.3.1  客户端/服务端部署	172
19.3.2  N层部署	172
19.3.3  两层部署	172
19.3.4  三层部署	173
19.3.5  四层部署	173
19.3.6  Web应用程序部署	173
19.3.7  富互联网应用程序部署	174
19.3.8  富客户端应用程序部署	174
19.4  性能模式	174
19.4.1  负载均衡集群	175
19.4.2  亲和性和会话技术	175
19.4.3  应用农场	176
19.5  可靠性模式	176
19.5.1  故障转移集群	176
19.6  安全性模式	177
19.6.1  模拟和委派	177
19.6.2  信任子系统	178
19.6.3  多重信任服务标识	178
19.7  纵向扩展和横向扩展	179
19.7.1  纵向扩展的考量	179
19.7.2  设计以支持横向扩展	179
19.7.3  设计的牵制和权衡	180
19.8  网络基础结构的安全考量	181
19.9  可管理性考量	182
19.10  相关设计模式	182
19.11  其他资源	183
应用程序原型篇	185
第20章  选择应用程序类型	187
20.1  概述	187
20.2  应用程序原型小结	187
20.2.1  应用程序类型优缺点	188
20.3  移动应用程序	189
20.4  富客户端应用程序类型	190
20.5  富Internet程序	191
20.6  服务应用程序类型	192
20.8  Web应用程序类型	193
第21章  设计Web应用程序	195
21.1  概述	195
21.2  通用设计考量	196
21.3  特定的设计考量	196
21.3.1  应用程序提交过程	197
21.3.2  身份验证	198
21.3.3  授权	198
21.3.4  缓存	198
21.3.5  异常管理	199
21.3.6  日志和规范	199
21.3.7  导航	199
21.3.8  页面布局	200
21.3.9  页面渲染	200
21.3.10  Session管理	201
21.3.11  验证	201
21.4  层设计中的考量	202
21.4.1  表现层	202
21.4.2  业务层	202
21.4.3  数据层	202
21.4.4  服务层	202
21.5  测试以及可测试性的考量	203
21.6  技术考量	203
21.7  部署考量	204
21.7.1  非分布式部署	204
21.7.2  分布式部署	204
21.7.3  负载均衡	205
21.8  相关的设计模式	206
21.9  其他资源	207
第22章  设计富客户端应用程序	209
22.1  概述	209
22.2  通用设计考量	210
22.3  特定的设计考量	211
22.3.1  业务层	211
22.3.2  通信	211
22.3.3  组合	212
22.3.4  配置管理	213
22.3.5  数据访问	213
22.3.6  异常管理	214
22.3.7  可维护性	214
22.3.8  表现层	215
22.3.9  状态管理	215
22.3.10  工作流	216
22.4  安全考量	216
22.5  数据处理考量	217
22.5.1  缓存数据	217
22.5.2  数据并发	218
22.5.3  数据绑定	218
22.6  离线/偶尔连线情况的设计考量	218
22.7  技术考量	219
22.8  部署考量	220
22.8.1  独立部署	220
22.8.2  客户端/服务器端部署	220
22.8.3  N层部署	220
22.8.4  部署技术	221
22.9  相关的设计模式	221
22.10  其他资源	223
第23章  设计富Internet应用程序	225
23.1  概述	225
23.2  通用设计考量	226
23.3  特定的设计考量	227
23.1.1  业务层	228
23.1.2  缓存	228
23.1.3  通信	229
23.1.4  组合	229
23.1.5  数据访问	230
23.1.6  异常管理	230
23.1.7  日志	230
23.1.8  媒体和图形	231
23.1.9  可移动性	231
23.1.10  可移植性	232
23.1.11  表现层	232
23.1.12  状态管理	232
23.1.13  验证	233
23.4  安全考量	233
23.5  数据处理考量	234
23.6  技术考量	234
23.7  部署考量	236
23.7.1  RIA插件安装	236
23.7.2  分布式部署	236
23.7.3  负载均衡	237
23.7.4  Web场的优缺点	238
23.8  相关的设计模式	238
23.9  其他资源	239
第24章  设计移动应用程序	241
24.1  概述	241
24.2  通用设计考量	242
24.3  一些特定的设计考量	243
24.3.1  身份验证和授权	243
24.3.2  缓存	244
24.3.3  通信	244
24.3.4  配置管理	245
24.3.5  数据访问	245
24.3.6  设备相关	246
24.3.7  异常管理	246
24.3.8  日志	247
24.3.9  移植应用程序	247
24.3.10  功耗管理	248
24.3.11  同步	248
24.3.12  测试	249
24.3.14  用户界面	249
24.3.15  验证	250
24.4  技术考量	250
24.4.1  Microsoft Silverlight for Mobile	250
24.4.2  .NET Compact Framework	251
24.4.3  Windows Mobile	251
24.4.4  Windows Embedded	252
24.5  部署考量	252
24.6  相关设计模式	253
24.7  其他资源	254
第25章  设计服务应用程序	255
25.1  概述	255
25.2  通用设计考量	256
25.3  特定的设计考量	257
25.3.1  身份验证	258
25.3.2  授权	258
25.3.3  业务层	258
25.3.4  通信	259
25.3.5  数据层	259
25.3.6  异常管理	260
25.3.7  消息结构	260
25.3.8  消息端点	260
25.3.9  消息保护	261
25.3.10  消息转换	261
25.3.11  消息交换模式	262
25.3.12  表述性状态传输	262
25.3.13  服务层	263
25.3.14  SOAP	264
25.3.15  验证	264
25.4  技术考量	265
25.5  部署考量	265
25.6  相关设计模式	266
25.7  其他资源	268
第26章  设计托管和云服务	269
26.1  概述	269
26.1.1  云计算	269
26.1.2  托管和云服务的通用词汇	270
26.2  云端应用程序的好处	271
26.2.1  针对ISV和服务托管的好处	271
26.2.3  针对消费服务企业的好处	272
26.3  设计考量	272
26.3.1  数据隔离和共享	272
26.3.2  数据安全	274
26.3.3  数据的存储和扩展	275
26.3.4  标识管理	277
26.3.5  多重租赁	278
26.3.6  内部托管还是外部托管，构建还是购买	279
26.3.7  性能	280
26.3.8  服务组合	280
26.3.9  服务集成	282
26.3.10  服务管理	283
26.4  相关设计模式	284
26.5  其他资源	285
第27章  设计Office业务应用程序	287
27.1  概述	287
27.1.1  构成Office业务应用程序的组件	288
27.2  Office业务应用程序的关键场景	288
27.2.1  企业内容管理	289
27.2.2  商业智能	289
27.2.3  统一消息	290
27.3  通用的OBA模式	290
27.3.1  扩展的到达通道	290
27.3.2  文档整合	291
27.3.3  文档工作流	293
27.3.4  组合用户界面	293
27.3.5  数据合并（导航发现）	294
27.3.6  协作	296
27.3.7  通知和任务	296
27.4  通用设计考量	297
27.5  安全考量	298
27.6  部署考量	298
27.7  相关设计模式	298
27.8  其他资源	299
第28章  设计SharePoint LOB应用程序	301
28.1  概述	301
28.1.1  SharePoint LOB应用程序的逻辑层	302
28.1.2  物理层部署	302
28.2  关键场景和特性	303
28.3  通用设计考量	303
28.4  特定的设计考量	304
28.4.1  业务数据目录	304
28.4.2  文档和内容存储	305
28.4.3  Excel服务	305
28.4.4  InfoPath 表单服务	306
28.4.5  SharePoint对象模型	306
28.4.6  Web Parts	307
28.4.7  工作流	307
28.5  技术考量	308
28.6  部署考量	308
28.7  相关设计模式	308
28.8  其他资源	309
应用程序原型篇	312
附录A  微软应用程序平台	313
A.1  概述	313
A.2  相关的信息和资源	314
A.2.1  微软是怎样在Web上组织技术信息的	314
A.2.2  Microsoft Developer Network	314
A.2.3  Microsoft TechNet	315
A.3  .NET框架	315
A.4  公共语言运行时	315
A.5  数据访问	315
A.6  移动应用程序	316
A.7  富客户端	317
A.8  富Internet应用程序	317
A.9  服务	318
A.10  工作流	318
A.11  Web应用程序	319
A.12  Web服务器——Internet信息服务	319
A.13  数据库服务器——SQL Server	320
A.14  Visual Studio开发环境	320
A.15  其他的工具和库	320
A.15.1  Patterns & practices解决方案	320
A.16  其他资源	321
附录B  表现方面的技术矩阵	323
B.1  概述	323
B.2  表现层技术小结	323
B.2.1  移动应用程序	323
B.2.2  富客户端应用程序	323
B.2.3  富Internet应用程序	324
B.2.4  Web应用程序	324
B.3  优缺点矩阵	325
B.3.1  移动应用程序	325
B.3.2  富客户端应用程序	326
B.3.3  富Internet应用程序	326
B.3.4  Web应用程序	327
B.4  通用的场景和解决方案	328
B.4.1  移动应用程序	328
B.4.2  富客户端应用程序	328
B.4.3  富Internet应用程序	329
B.4.4  Web应用程序	329
B.5  其他资源	330
附录C  数据访问的技术矩阵	331
C.1  概述	331
C.2  数据访问技术小结	331
C.3  优缺点矩阵	332
C.3.1  对象-关系数据访问	332
C.3.2  断线和离线场景	333
C.3.3  SOA/服务场景	333
C.3.4  N层以及通用场景	333
C.4  通用建议	335
C.5  通用的场景和解决方案	335
C.6  LINQ to SQL的缺点	336
C.7  移动解决方案的缺点	337
C.8  其他资源	337
附录D  整合方面的技术矩阵	339
D.1  概述	339
D.2  整合技术小结	339
D.3  优缺点矩阵	339
D.4  通用的场景和解决方案	341
D.5  其他资源	342
附录E  工作流方面的技术矩阵	343
E.1  概述	343
E.2  整合技术小结	343
E.3  人力工作流VS系统工作流	344
E.4  优缺点矩阵	344
E.5  通用的场景和解决方案	345
E.6  其他资源	345
附录F  patterns & practices企业库	347
F.1  概述	347
F.2  企业库的目标	347
F.3  企业库的内容	347
F.3.1  应用程序块	348
F.4  缓存应用程序块（Caching Application Block）	349
F.4.1  关键场景	349
F.4.2  何时使用	349
F.4.3  缺点	350
F.5  加密应用程序块（Cryptography Application Block）	350
F.5.1  关键场景	350
F.5.2  何时使用	350
F.5.3  缺点	351
F.6  数据访问应用程序块（Data Access Application Block）	351
F.6.1  关键场景	351
F.6.2  何时使用	351
F.6.3  缺点	352
F.7  异常处理应用程序块（Exception Handling Application Block）	352
F.7.1  关键场景	352
F.7.2  何时使用	352
F.8  日志应用程序块（Logging Application Block）	353
F.8.1  关键场景	353
F.8.2  何时使用	353
F.8.3  缺点	353
F.9  策略注入应用程序块（Policy Injection Application Block）	353
F.9.1  关键场景	354
F.9.2  何时使用	354
F.9.3  缺点	354
F.10  安全应用程序块（Security Application Block）	354
F.10.1  关键场景	355
F.10.2  何时使用	355
F.10.3  缺点	355
F.11  Unity应用程序块（Unity Application Block）	355
F.11.1  关键场景	355
F.11.2  何时使用	356
F.11.3  缺点	356
F.12  验证应用程序块（Validation Application Block）	356
F.12.1  关键场景	356
F.12.2  何时使用	356
F.12.3  缺点	357
F.13  其他资源	357
附录G  模式与实践团队模式目录	359
G.1  关于WPF和Silverlight的组合应用程序指南	359
G.2  数据迁移模式	360
G.3  企业解决方案中的模式	361
G.4  整合模式	363
G.5  Web服务安全模式	364
G.6  其他资源	365
索引	367
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微软应用架构指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>淘宝技术这十年
第0章 引言：光棍节的狂欢 / 1
淘宝网不就是一个网站吗？是的，但淘宝网不是一个简单的网站，它的规模排在全球前十几名，顶尖的网站需要顶尖的技术作为支撑。在用户享受淘宝的乐趣的背后，有哪些神秘的技术在支撑它呢？
第1章 个人网站 / 13
创建一个小小的网站需要什么技术？在群敌环伺的状况下怎么走出网站的第一步？淘宝网独特的文化和价值观又是怎么形成的？本章试图给你一个解读。
LAMP架构的网站 / 14
武侠和倒立文化的起源 / 20
第2章 个人网站的升级 / 23
小网站都想变大，变大总会遇到成长的烦恼，淘宝网的青春期有哪些烦心事？淘宝网的工程师用什么思路来解决遇到的问题？在解决问题之余，他们又用了哪些创新的手段来超越竞争对手？
数据库从mySQL到Oracle / 25
支付手段的创新——支付宝 / 28
交流方式的创新——淘宝旺旺 / 29
第3章 企业级Java网站 / 33
给一个网站更换开发语言，这种事情想想都恐怖，淘宝网在2004年就从PHP语言转换成了Java语言，这是怎么做到的？一个企业级的Java系统应该采用什么样的架构？归纳网站遇到的问题，主要是对性能、容量和成本的控制，这有哪些通用的解决方案？在技术实力得到提升之后，淘宝网的哪些业务有了突飞猛进的发展？哪些业务又会遇到技术的障碍？
脱胎换骨的升级——更换开发语言 / 34
坚若磐石——围绕性能、容量和成本的进化 / 41
第4章 创造技术 / 33
用钱能解决的问题都不是问题，我们花钱可以购买更好的机器和更好的服务。但当你变成业内最强之后，你的问题就会独特到没有人碰到过，这就意味着你必须自己动手解决问题。幸运的是，淘宝网的发展很快，不幸的是，淘宝网遇到了前所未有的问题。于是，淘宝网被迫开始走向了技术创新的道路。而技术的创新和业务的创新到底又是谁推动了谁？
淘宝文件系统——TFS / 53
淘宝KV缓存系统——Tair / 64
第5章 分布式电子商务操作系统 / 77
在飞速发展的背后，隐患已经埋下。在技术架构的制约下，团队协作越来越艰难，代码越来越臃肿，开发的效率越来越低，新业务的需求越来越多，老业务的压力眼看就要超过系统的容量了。这时候，架构该做怎样的调整？又一次的脱胎换骨，欲火重生。重生后，在分布式的电子商务操作系统下，我们才敢举办一次又一次的“双十一”活动。
服务化 / 78
中间件 / 88
高性能服务框架HSF / 91
消息中间件Notify / 95
分布式数据访问层TDDL / 99
Session框架 / 107
开放平台 / 111
第6章 我在淘宝这八年 / 129
作为淘宝技术的亲历者，我不经意间见证了一段伟大的历史，这段历史，从高层看波澜壮阔，从底层看妙趣横生。我不是高层，这里记录的是发生在底层的一些事。
第7章 牛P列传 / 167
前面讲述了技术和业务是怎么互相促进、共生发展的。与此类似，企业和个人也是这样一个关系：一个水平很高的人，找不到合适的平台，就难以发挥自己的价值；一个蓬勃发展的企业，找不到合适的人才，其前景也会堪忧。幸运的是，在淘宝网蓬勃发展的过程中，出现了一大批业内顶尖的高手，他们推动了淘宝的发展，淘宝也让他们实现了个人的价值。接下来让我们一起看看那些人、那些事。
正明——集团核心系统高级研究员 / 168
正祥——淘宝高级研究员，OceanBase项目负责人 / 180
毕玄——集团核心系统资深技术专家 / 191
放翁——淘宝开放平台项目负责人 / 198
吴翰清——阿里云集团信息安全中心高级安全专家 / 210
云铮——数据平台与产品部资深技术专家 / 218
小马——淘宝UED前端通用平台高级技术专家 / 225
淘宝传奇工程师多隆的程序世界 / 236
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>淘宝技术这十年
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>前端架构设计
前言　　xi
第一部分　引言
第1章　前端架构原则　　7
第2章　Alpha 项目　　11
2.1　慢而有力的开端　　11
2.2　全副武装　　12
第3章　前端架构的核心　　15
3.1　围绕四个核心工作　　15
3.2　四个核心的含义　　16
第二部分　代码核心
第4章　HTML　　19
4.1　过去处理标记的方法　　19
4.1.1　程序式标记：自动化程度　　100%，可控程度 0%　　19
4.1.2　静态标记：自动化程度 0%，可控程度　　100%　　20
4.2　平衡可控性和自动化　　21
4.3　这一切背后的设计系统　　22
4.4　模块化 CSS 理论的多面性　　22
4.4.1　OOCSS 方法　　23
4.4.2　SMACSS 方法　　23
4.4.3　BEM 方法　　24
4.5　选择适合的方案　　25
第5章　CSS　　27
5.1　特性之争与继承之痛　　28
5.2　一种现代的、模块化的方法　　30
5.3　其他有助益的原则　　32
5.3.1　单一职责原则　　32
5.3.2　单一样式来源　　33
5.3.3　组件修饰符　　34
5.4　小结　　35
第6章　JavaScript　　37
6.1　选择框架　　37
6.2　维护整洁的 JavaScript 代码　　38
6.2.1　保持代码整洁　　38
6.2.2　创造可复用的函数　　38
6.3　小结　　40
第7章　Red Hat 代码　　41
7.1　过多的依赖　　41
7.2　严重的位置依赖问题　　42
7.3　设计分解　　42
7.4　组件分类　　43
7.5　BB 鸟规则　　44
7.6　编写你自己的规则　　44
7.7　每个标签指定唯一的选择器　　46
7.7.1　单一责任原则　　46
7.7.2　样式只有单一的来源　　47
7.7.3　可选的修饰符　　47
7.7.4　可选的上下文　　50
7.8　语义化的网格　　53
第三部分　流程核心
第8章　工作流　　57
8.1　过去的开发工作流　　57
8.2　现代的开发工作流　　58
8.2.1　需求　　58
8.2.2　原型设计　　58
8.2.3　程序开发　　58
8.3　前端工作流　　59
8.3.1　必要的工具　　59
8.3.2　本地部署　　59
8.3.3　编写用户故事　　60
8.4　开发　　61
8.5　发布　　62
8.6　提交编译后的资源　　62
8.7　持续集成的服务器　　63
8.7.1　标签分支　　64
8.7.2　究竟为什么要这么做　　64
8.8　发布渠道　　64
第9章　任务处理器　　67
9.1　在任务处理器中完成一切　　68
9.2　在项目中使用任务处理器　　69
9.3　有明显的优胜者吗　　71
第10章　Red Hat 流程　　73
10.1　征服最后一英里　　73
10.2　模式驱动的设计系统　　75
第四部分　测试核心
第11章　单元测试　　87
11.1　单元　　87
11.1.1　更多重用　　88
11.1.2　更好的测试　　88
11.2　测试驱动的开发　　88
11.3　一个测试驱动的例子　　89
11.4　测试覆盖率要多大才足够　　90
11.4.1　解决分歧点　　90
11.4.2　从测试覆盖率开始　　90
第12章　性能测试　　91
12.1　制定性能预算　　91
12.1.1　竞争基线　　92
12.1.2　平均基准　　92
12.2　原始指标　　93
12.2.1　页面大小　　93
12.2.2　HTTP 请求次数　　94
12.3　计时度量　　94
12.4　混合度量标准　　95
12.4.1　PageSpeed 分数　　95
12.4.2　Speed Index 指标　　95
12.5　设置性能测试　　95
12.5.1　Grunt PageSpeed 插件　　96
12.5.2　Grunt Perfbuget 插件　　96
12.6　小结　　97
第13章　视觉还原测试　　99
13.1　常见的质疑　　99
13.1.1　不了解情况的开发者　　100
13.1.2　不一致的设计　　100
13.1.3　举棋不定的决策者　　100
13.2　一个经过测试的解决方案　　101
13.3　视觉还原测试的多面性　　101
第14章　Red Hat 测试方法　　103
14.1　实践视觉还原测试　　103
14.1.1　测试工具集　　103
14.1.2　设置 Grunt　　104
14.1.3　测试文件　　104
14.1.4　对比　　105
14.1.5　运行全部测试用例　　106
14.1.6　如何应对测试失败　　107
14.1.7　从失败到成功　　107
14.1.8　修改代码以适应需求　　108
14.1.9　将基准图片放在组件目录里　　108
14.1.10　独立运行每个组件的测试集　　109
14.1.11　测试的可扩展性　　110
14.2　小结　　111
第五部分　文档核心
第15章　样式文档　　117
15.1　配置 Hologram　　117
15.1.1　Hologram 的文档注释块　　119
15.1.2　Hologram 编译流程　　120
15.1.3　Hologram 小结　　121
15.2　SassDoc　　121
15.2.1　安装 SassDoc　　121
15.2.2　使用 SassDoc　　122
15.2.3　探索 SassDoc　　123
15.2.4　深入了解 SassDoc　　124
15.2.5　内部依赖　　125
15.3　小结　　127
第16章　图形库　　129
16.1　何为 Pattern Lab　　129
16.2　运行 Pattern Lab　　131
16.3　首页模板　　133
16.4　首变量　　134
16.5　原子　　135
16.6　发挥原子的作用　　135
第17章　Red Hat 文档　　137
17.1　阶段　　1：静态的样式文档　　137
17.2　阶段　　2：重写 Pattern Lab　　139
17.3　阶段　　3：分拆模式库和样式文档　　142
17.4　阶段　　4：创建统一的渲染引擎　　143
17.5　阶段　　5：自动创建新模式　　144
第18章　总结　　147
作者介绍　　149
封面介绍　　149

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>前端架构设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件架构师教程
第1章&nbsp;&nbsp;绪论
&nbsp;1.1&nbsp;&nbsp;给软件架构师的建议
&nbsp;&nbsp;劝告的话
&nbsp;&nbsp;新生知识
&nbsp;&nbsp;无所适从
&nbsp;&nbsp;同行相欺
&nbsp;&nbsp;管理陷阱
&nbsp;&nbsp;定义软件体系结构
&nbsp;&nbsp;“体系结构”一词的

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件架构师教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高性能Linux服务器构建实战
前言
第一部分　安全运维篇
第1章　Linux服务器安全运维
1.1　账户和登录安全
1.1.1　删除特殊的用户和用户组
1.1.2　关闭系统不需要的服务
1.1.3　密码安全策略
1.1.4　合理使用su、sudo命令
1.1.5　删减系统登录欢迎信息
1.1.6　禁止Control-Alt-Delete键盘关闭命令
1.2　远程访问和认证安全
1.2.1　远程登录取消telnet而采用SSH方式
1.2.2　合理使用shell历史命令记录功能
1.2.3　启用tcp_wrappers防火墙
1.3　文件系统安全
1.3.1　锁定系统重要文件
1.3.2　文件权限检查和修改
1.3.3　/tmp、/var/tmp、/dev/shm安全设定
1.4　系统软件安全管理
1.4.1　软件自动升级工具yum
1.4.2　yum的安装与配置
1.4.3　yum的特点与基本用法
1.4.4　几个不错的yum源
1.5　Linux后门入侵检测工具
1.5.1　rootkit后门检测工具chkrootkit
1.5.2　rootkit后门检测工具RKHunter
1.6　服务器遭受攻击后的处理过程
1.6.1　处理服务器遭受攻击的一般思路
1.6.2　检查并锁定可疑用户
1.6.3　查看系统日志
1.6.4　检查并关闭系统可疑进程
1.6.5　检查文件系统的完好性
1.7　一次Linux被入侵后的分析
1.7.1　受攻击现象
1.7.2　初步分析
1.7.3　断网分析系统
1.7.4 　寻找攻击源
1.7.5　查找攻击原因
1.7.6　揭开谜团
1.7.7　如何恢复网站
第2章　Linux网络安全运维
2.1　网络实时流量监测工具iftop
2.1.1　iftop能做什么
2.1.2　iftop的安装
2.1.3　使用iftop监控网卡实时流量
2.2　网络流量监控与分析工具Ntop和Ntopng
2.2.1　Ntop与MRTG的异同
2.2.2　Ntop与Ntopng的功能介绍
2.2.3　安装Ntop与Ntopng
2.2.4　Ntop和Ntopng的使用技巧
2.3　网络性能评估工具iperf
2.3.1　iperf能做什么
2.3.2　iperf的安装与使用
2.3.3　iperf应用实例
2.4　网络探测和安全审核工具nmap
2.4.1　nmap和Zenmap简介
2.4.2　nmap基本功能与结构
2.4.3　nmap的安装与验证
2.4.4　nmap的典型用法
2.4.5　nmap主机发现扫描
2.4.6　nmap端口扫描
2.4.7　nmap版本侦测
2.4.8　nmap操作系统侦测
第3章　数据安全工具DRBD、extundelete
3.1　数据镜像软件DRBD介绍
3.1.1　DRBD的基本功能
3.1.2　DRBD的构成
3.1.3　DRBD与现在的集群的关系
3.1.4　DRBD的主要特性
3.2　DRDB的安装与配置
3.2.1　安装环境说明
3.2.2　DRBD的安装部署
3.2.3　快速配置一个DRBD镜像系统
3.3　DRBD的管理与维护
3.3.1　启动DRDB
3.3.2　测试DRBD数据镜像
3.3.3　DRBD主备节点切换
3.4　数据恢复软件extundelete介绍
3.4.1　如何使用"rm -rf"命令
3.4.2　extundelete与ext3grep的异同
3.4.3　extundelete的恢复原理
3.4.4　安装extundelete
3.4.5　extundelete用法详解
3.5　实战：extundelete恢复数据的过程
3.5.1　通过extundelete恢复单个文件
3.5.2　通过extundelete恢复单个目录
3.5.3　通过extundelete恢复所有误删除数据
3.5.4　通过extundelete恢复某个时间段的数据
第二部分　运维故障排查篇
第4章　Linux系统运维故障排查思路
4.1　Linux系统故障的处理思路
4.2　Linux系统无法启动的解决方法
4.2.1　文件系统破坏导致系统无法启动
4.2.2　/etc/fstab文件丢失导致系统无法启动
4.3　Linux系统无响应（死机）问题分析
4.4　Linux下常见网络故障的处理思路
4.4.1　检查网络硬件问题
4.4.2　检查网卡是否正常工作
4.4.3　检查DNS解析文件是否设置正确
4.4.4　检查服务是否正常打开
4.4.5　检查访问权限是否打开
4.4.6　检查局域网主机之间联机是否正常
第5章　Linux故障排查案例实战
5.1　常见系统故障案例
5.1.1　su切换用户带来的疑惑
5.1.2　"Read-only file system"错误与解决方法
5.1.3　"Argument list too long"错误与解决方法
5.1.4　inode耗尽导致应用故障
5.1.5　文件已删除但空间不释放的原因
5.1.6　"Too many open files"错误与解决方法
5.2　Apache常见错误故障案例
5.2.1　"No space left on device"错误与解决方法
5.2.2　apache(20014)故障与解决方法
5.2.3　"could not bind to address 0.0.0.0:80"错误与解决方法
5.3　因NAS存储故障引起的Linux系统恢复案例
5.3.1　故障现象描述
5.3.2　问题判断思路
5.3.3　问题处理过程
5.3.4　解决问题
第三部分　自动化运维篇
第6章　轻量级运维利器pssh、pdsh和mussh
6.1　并行SSH运维工具pssh
6.1.1　pssh应用场景
6.1.2　pssh的安装与用法
6.1.3　pssh应用实例
6.2　并行分布式运维工具pdsh
6.2.1　pdsh应用场景
6.2.2　pdsh的安装与语法
6.2.3　pdsh应用实例
6.3　多主机ssh封装器mussh
6.3.1　mussh功能介绍
6.3.2　mussh的安装与语法
6.3.3　mussh应用实例
第7章　分布式监控系统Ganglia
7.1　Ganglia简介
7.2　Ganglia的组成
7.3　Ganglia的工作原理
7.3.1　Ganglia数据流向分析
7.3.2　Ganglia工作模式
7.4　Ganglia的安装
7.4.1　yum源安装方式
7.4.2　源码方式
7.5　配置一个Ganglia分布式监控系统
7.5.1　Ganglia配置文件介绍
7.5.2　Ganglia监控系统架构图
7.5.3　Ganglia监控管理端配置
7.5.4　Ganglia的客户端配置
7.5.5　Ganglia的Web端配置
7.6　Ganglia监控系统的管理和维护
7.7　Ganglia监控扩展实现机制
7.7.1　扩展Ganglia监控功能的方法
7.7.2　通过gmetric接口扩展Ganglia监控
7.7.3　通过Python插件扩展Ganglia监控
7.7.4　实战：利用Python接口监控Nginx运行状态
7.8　Ganglia在实际应用中要考虑的问题
7.8.1　网络IO可能存在瓶颈
7.8.2　CPU可能存在瓶颈
7.8.3　gmetad写入rrd数据库可能存在瓶颈
第8章　基于nagios的分布式监控报警平台Centreon
8.1　Centreon概述
8.2　Centreon的特点
8.3　Centreon的结构
8.4　安装Centreon+nagios监控系统
8.4.1　安装支持Centreon的yum源
8.4.2　安装系统基础依赖库
8.4.3　安装nagios及nagios-plugins
8.4.4　安装ndoutils
8.4.5　安装nrpe
8.4.6　安装Centreon
8.4.7　安装配置Centreon Web
8.4.8　启动Centreon相关服务
8.4.9　安装问题总结
8.5　配置Centreon监控系统
8.5.1　添加主机和主机组
8.5.2　批量添加主机
8.5.3　监控引擎管理
8.5.4　添加服务和服务组
8.5.5　监控报警配置
8.5.6　用户和用户权限管理
8.6　配置分布式监控
8.6.1　分布式监控架构与实现原理
8.6.2　分布式监控搭建环境介绍
8.6.3　监控软件的安装
8.6.4　配置节点间SSH信任登录
8.6.5　在Central server上添加分布式监控配置
8.7　常见服务监控配置
8.7.1　 nagios插件编写规范
8.7.2　监控Apache运行状态
8.7.3　监控MySQL运行状态
8.7.4　监控Hadoop HDFS运行状态
8.8　桌面监控报警器Nagstamon
第9章　通过Ganglia与Centreon构建智能化监控报警平台
9.1　智能运维监控报警平台的组成
9.2　Ganglia作为数据收集模块
9.3　Centreon作为监控报警模块
9.4　Ganglia与Centreon的无缝整合
9.4.1　数据提取脚本
9.4.2　实现Ganglia与Centreon完美整合
9.5　在Centreon中实现批量数据收集与监控报警
第四部分　集群架构篇
第10章　高性能Web服务器Nginx
10.1　高性能Web服务器Nginx介绍
10.1.1　Nginx的组成与工作原理
10.1.2　Nginx的性能优势
10.2　Nginx的安装
10.2.1　安装Nginx依赖库
10.2.2　快速安装Nginx
10.3　配置与调试Nginx
10.3.1　Nginx配置文件结构
10.3.2　Nginx配置文件详解
10.3.3　Nginx日常维护技巧
10.4　Nginx常用功能介绍
10.4.1　Nginx反向代理应用实例
10.4.2　Nginx的URL重写应用实例
10.5　案例：Nginx作为Web缓存服务器应用
10.5.1　在Nginx下安装缓存服务器
10.5.2　配置Nginx缓存服务器
10.5.3　测试proxy_cache实现的缓存功能
10.5.4　如何清除指定的URL缓存
10.6　案例：Nginx作为负载均衡服务器应用
10.6.1　Nginx的负载均衡算法
10.6.2　Nginx的负载均衡配置实例
10.7　Nginx性能优化技巧
10.7.1　编译安装过程优化
10.7.2　利用TCMalloc优化Nginx的性能
10.7.3　Nginx内核参数优化
第11章　高性能集群软件Keepalived
11.1　Keepalived介绍
11.1.1　Keepalived是什么
11.1.2　VRRP协议与工作原理
11.1.3　Keepalived工作原理
11.1.4　Keepalived的体系结构
11.2　Keepalived安装与配置
11.2.1　Keepalived的安装过程
11.2.2　Keepalived的全局配置
11.2.3　Keepalived的VRRPD配置
11.2.4　Keepalived的LVS配置
11.3　Keepalived基础功能应用实例
11.3.1　Keepalived基础HA功能演示
11.3.2　通过vrrp_script实现对集群资源的监控
11.3.3　Keepalived集群中MASTER和BACKUP角色选举策略
第12章　千万级高并发负载均衡软件HAProxy
12.1　高性能负载均衡软件HAProxy介绍
12.1.1　HAProxy简介
12.1.2　四层和七层负载均衡的区别
12.1.3　HAProxy与LVS的异同
12.2　HAProxy基础配置与应用实例
12.2.1　快速安装HAProxy集群软件
12.2.2　HAProxy基础配置文件详解
12.2.3　HAProxy的日志配置策略
12.2.4　通过HAProxy的ACL规则实现智能负载均衡
12.3　基于虚拟主机的HAProxy负载均衡系统配置实例
12.3.1　通过HAProxy的ACL规则配置虚拟主机
12.3.2　测试HAProxy实现虚拟主机和负载均衡功能
12.3.3　测试HAProxy的故障转移功能
12.3.4　使用HAProxy的Web监控平台
第13章　构建高性能的MySQL集群系统
13.1　常见的高可用MySQL解决方案
13.1.1　主从复制解决方案
13.1.2　MMM高可用解决方案
13.1.3　Heartbeat/SAN高可用解决方案
13.1.4　Heartbeat/DRBD高可用解决方案
13.1.5　MySQL Cluster高可用解决方案
13.2　通过Keepalived搭建MySQL双主模式的高可用集群系统
13.2.1　MySQLReplication介绍
13.2.2　MySQL Replication实现原理
13.2.3　MySQL Replication常用架构
13.2.4　MySQL主主互备模式架构
13.2.5　MySQL主主互备模式配置
13.2.6　配置Keepalived实现MySQL双主高可用
13.2.7　测试MySQL主从同步功能
13.2.8　测试Keepalived实现MySQL故障转移
13.3　通过MMM构建MySQL高可用集群系统
13.3.1　MMM高可用MySQL方案简介
13.3.2　MMM典型应用方案
13.3.3　MMM高可用MySQL方案架构
13.3.4　MMM的安装与配置
13.3.5　MMM的管理
13.3.6　测试MMM实现MySQL高可用功能
13.4　MySQL读写分离解决方案
13.4.1　通过Amoeba实现MySQL读写分离
13.4.2　通过Keepalived构建高可用的Amoeba服务
第14章　高性能负载均衡集群软件HAProxy
14.1　高性能负载均衡架构设计原则
14.1.1　HAProxy常见方案与拓扑
14.1.2　高可用集群软件的选择
14.2　搭建HAProxy+Keepalived高可用负载均衡系统
14.2.1　搭建环境描述
14.2.2　配置HAProxy负载均衡服务器
14.2.3　配置主、备Keepalived服务器
14.3　测试HAProxy+Keepalived高可用负载均衡集群
14.3.1　测试Keepalived的高可用功能
14.3.2　测试负载均衡功能
14.4　构建双主高可用的HAProxy负载均衡系统
14.4.1　系统架构图与实现原理
14.4.2　安装并配置HAProxy集群系统
14.4.3　安装并配置双主的Keepalived高可用系统
14.4.4　测试双主高可用的HAProxy负载均衡集群系统
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高性能Linux服务器构建实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>未来架构：从服务化到云原生
第1章  云原生  1
1.1  互联网架构变迁  2
1.1.1  互联网架构的核心问题  2
1.1.2  从集中式架构到分布式架构  5
1.1.3  从分布式架构到云原生架构  10
1.2  什么是云原生  15
1.2.1  概述  15
1.2.2  云原生与十二要素  16
1.2.3  十二要素进阶  23
1.2.4  云原生与CNCF  24
第2章  远程通信  41
2.1  通信方式  41
2.1.1  通信协议  42
2.1.2  I/O模型  51
2.1.3  Java中的I/O  53
2.2  序列化  66
2.2.1  文本序列化  67
2.2.2  二进制Java序列化  68
2.2.3  二进制异构语言序列化  71
2.3  远程调用  78
2.3.1  核心概念  78
2.3.2  Java远程方法调用  79
2.3.3  异构语言RPC框架gRPC  82
第3章  配置  89
3.1  本地配置  89
3.2  配置集中化  90
3.3  配置中心和注册中心  91
3.4  读性能  92
3.5  变更实时性  93
3.6  可用性  94
3.7  数据一致性  96
第4章  服务治理  97
4.1  服务发现  97
4.1.1  服务发现概述  97
4.1.2  ZooKeeper  100
4.1.3  Eureka  109
4.2  负载均衡  112
4.2.1  服务端负载均衡  112
4.2.2  客户端负载均衡  115
4.3  限流  118
4.3.1  限流算法  119
4.3.2  限流实现方案  121
4.3.3  限流的维度与粒度  129
4.4  熔断  131
4.4.1  概述  131
4.4.2  熔断器模式  132
4.4.3  Hystrix  133
第5章  观察分布式服务  135
5.1  层次划分  136
5.2  核心概念  136
5.3  分布式追踪  138
5.3.1  概述  138
5.3.2  常见的开源解决方案  139
5.4  应用性能管理与可观察性平台  140
5.5  Apache SkyWalking  142
5.5.1  项目定位  142
5.5.2  SkyWalking 5核心架构  143
5.5.3  SkyWalking 5公开案例  146
5.5.4  SkyWalking 6可观察性分析平台  147
第6章  侵入式服务治理方案  157
6.1  Dubbo  157
6.1.1  Dubbo概述  158
6.1.2  核心流程  160
6.1.3  注册中心  160
6.1.4  负载均衡  162
6.1.5  远程通信  163
6.1.6  限流  164
6.1.7  治理中心  165
6.1.8  监控中心  165
6.1.9  DubboX的扩展  166
6.2  Spring Cloud  168
6.2.1  概述  168
6.2.2  开发脚手架Spring Boot  172
6.2.3  服务发现  174
6.2.4  负载均衡  176
6.2.5  熔断  178
6.2.6  远程通信  179
第7章  云原生生态的基石Kubernetes  181
7.1  Kubernetes架构  182
7.2  分层设计理念及架构模型  183
7.3  设计哲学  184
7.4  Kubernetes中的原语  185
7.4.1  Kubernetes中的对象  185
7.4.2  对象的期望状态与实际状态  186
7.4.3  描述Kubernetes对象  187
7.4.4  服务发现与负载均衡  188
7.4.5  安全性与权限管理  189
7.4.6  Sidecar设计模式  190
7.5  应用Kubernetes  190
7.6  Kubernetes与云原生生态  192
7.6.1  下一代云计算标准  192
7.6.2  当前存在的问题  192
7.6.3  未来趋势  193
第8章  跨语言服务治理方案Service Mesh  195
8.1  Service Mesh概述  195
8.1.1  Service Mesh的由来  195
8.1.2  Service Mesh的定义  196
8.1.3  Service Mesh详解  197
8.2  Service Mesh演进历程  200
8.2.1  远古时代的案例  200
8.2.2  微服务时代的现状  201
8.2.3  侵入式框架的痛点  202
8.2.4  解决问题的思路  206
8.2.5  Proxy模式的探索  207
8.2.6  Sidecar模式的出现  208
8.2.7  第一代Service Mesh  209
8.2.8  第二代Service Mesh  210
8.3  Service Mesh市场竞争  212
8.3.1  Service Mesh的萌芽期  212
8.3.2  急转直下的Linkerd  212
8.3.3  波澜不惊的Envoy  214
8.3.4  背负使命的Istio  214
8.3.5  背水一战的Buoyant  215
8.3.6  其他参与者  217
8.3.7  Service Mesh的国内发展情况  219
8.4  Istio  220
8.4.1  Istio概述  220
8.4.2  架构和核心组件  222
第9章  云原生数据架构  232
9.1  关系型数据库尚能饭否  232
9.1.1  优势  233
9.1.2  不足  234
9.2  未达预期的NoSQL  235
9.2.1  键值数据库  235
9.2.2  文档数据库  236
9.2.3  列族数据库  236
9.3  冉冉升起的NewSQL  237
9.3.1  新架构  238
9.3.2  透明化分片中间件  238
9.3.3  云数据库  239
9.4  云原生数据库中间件的核心功能  239
9.4.1  数据分片  239
9.4.2  分布式事务  258
9.4.3  数据库治理  265
第10章  分布式数据库中间件生态圈ShardingSphere  267
10.1  缘起  267
10.1.1  内部应用框架  268
10.1.2  开源历程  269
10.2  核心功能  271
10.2.1  数据分片  272
10.2.2  分布式事务  301
10.2.3  数据库治理  307
10.3  Sharding-JDBC  310
10.3.1  概述  310
10.3.2  使用说明  311
10.4  Sharding-Proxy  316
10.4.1  概述  316
10.4.2  使用说明  317
10.5  Database Mesh  317
10.5.1  概述  317
10.5.2  Service Mesh回顾  318
10.5.3  Database Mesh与Service Mesh的异同  319
10.5.4  Sharding-Sidecar  320
10.6  未来规划  321
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>未来架构：从服务化到云原生
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>资产证券化实务精解
中文版推荐序任建畅
序言
前言
致谢
第一部分 资产证券化入门
第一章 证券化及资产支持证券介绍
资产证券化的基本概念
资产证券化的流程
抵押贷款证券化
资产支持证券（ABS）的架构：业绩评估及
检验标准入门
证券化：2007—2008年金融危机时期的特征
本章小结
第二章 2007年之后的证券化市场
市场表现
对信用评级机构的影响
本章小结
第二部分 资产证券化交易实施指南
第三章 交易架构的设计及执行
资产证券化的基本流程
本章小结
第四章 信用评级流程及法律审查
选择信用评级机构
开展法律尽职调查
开始起草交易文件
设立SPV
交易建模
确定资本结构及交易触发水平
筹备营销/推介材料
定价、交割及结算（delivery）
本章小结
第五章 静态合成型CDO的现金流“瀑布”模型
本章小结
第三部分 证券化交易的实施模板及任务清单
第六章 交易模板及任务清单
“红海主系列基金有限公司”证券化交易结构图例
基础资产池
交易意向书草稿
实施流程
结构设计要点
评级机构的准备工作及调查问卷
贷款层面数据：评级机构的任务清单
评级现场调查
法律顾问调查
资产转让证明书格式
投资者及评级机构推介模板
内部信用评级映射图：价值区间
评级机构推介：企业内部银行的发起流程
贷款过户计划书
“红海”的贷款转让及账务处理
签署文件：“红海”的资产证券化项目
“红海”的证券化项目审核：财务部
交割的账务处理流程
次级证券交易传票
优先级证券交易传票
内部过户（internaltransfer）的账务处理流程
受托人、支付机构及服务商的调查问卷
本章小结
作者简介
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>资产证券化实务精解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.NET应用架构设计
前言
第一部分　架构与设计的原则和模式
第1章　架构与设计的流程和核心概念/2
1.1　正确认识软件架构/2
1.1.1　什么是架构/2
1.1.2　架构师的职责/3
1.1.3　架构设计/6
1.1.4　架构设计的优点/8
1.2　正确理解设计的含义/11
1.2.1　设计的重要性/12
1.2.2　架构和设计的关系/12
1.3　架构设计中的重要概念/14
1.3.1　Tier和Layer/14
1.3.2　架构与框架/15
1.3.3　架构与模式/15
1.4　本章小结/16
第2章　模式、设计原则和方法/17
2.1　设计原则与软件设计/17
2.1.1　设计原则简述/17
2.1.2　设计原则实战/18
2.2　设计模式/23
2.2.1　设计模式简介/23
2.2.2　正确使用设计模式/25
2.2.3　设计模式实战/26
2.3　企业应用架构模式/31
2.3.1　什么是企业架构/31
2.3.2　什么是企业级开发/31
2.3.3　再议架构设计和模式/32
2.3.4　企业架构模式介绍/33
2.4　企业架构模式实战/34
2.5　设计方法/38
2.5.1　测试驱动开发/38
2.5.2　领域驱动开发/39
2.5.3　行为驱动开发/39
2.6　本章小结/39
第二部分　架构与设计的方法和最佳实践
第3章　架构分层/42
3.1　反模式项目实例/42
3.2　分层设计/45
3.2.1　正确理解分层/45
3.2.2　常见的分层架构设计/46
3.2.3　N-Tier架构/52
3.2.4　N-Tier架构需要考虑的因素/52
3.3　从重构到分层/56
3.3.1　业务层设计实战/58
3.3.2　数据访问层设计实战/62
3.3.3　服务层设计实战/63
3.3.4　显示层设计实战/66
3.4　本章小结/69
第4章　业务层设计/70
4.1　业务层组织模式剖析/70
4.1.1　Transaction Script模式与实战/70
4.1.2　Active Record模式与实战/72
4.1.3　Domain Model模式与实战/78
4.1.4　Anemic Domain Model模式与实战/90
4.1.5　业务层组织模式比较/91
4.2　业务层常用设计模式解析及实战/92
4.2.1　工厂方法模式/92
4.2.2　装饰者模式/95
4.2.3　模板方法模式/102
4.2.4　状态模式/104
4.2.5　策略模式/109
4.2.6　模板方法模式、状态模式、策略模式的比较/109
4.3　业务层常用的企业架构模式及实战/113
4.4　模式联合实战/115
4.4.1　需求规格模式/115
4.4.2　组合模式/116
4.5　业务层常用的设计原则及实战/123
4.6　本章小结/126
第5章　服务层设计/127
5.1　服务层详解/127
5.1.1　服务层的由来/127
5.1.2　服务层的职责是什么/130
5.1.3　服务层的必要性/130
5.2　服务层常用设计模式解析/131
5.2.1　外观模式/131
5.2.2　远程外观模式/133
5.2.3　数据传输对象模式/135
5.3　SOA介绍/136
5.3.1　SOA用途/136
5.3.2　SOA原则/139
5.3.3　服务设计原则/140
5.3.4　服务解惑/142
5.3.5　服务操作设计原则/143
5.3.6　服务粒度介绍/144
5.4　服务层常用消息模式解析/146
5.4.1　文档消息模式与请求-响应模式/146
5.4.2　预约保留模式/147
5.4.3　等幂模式/148
5.5　SOA实战——WCF实现/149
5.5.1　系统分析/149
5.5.2　业务层实战/151
5.5.3　数据层实战/152
5.5.4　服务层实战/155
5.5.5　代理层实战/160
5.5.6　显示层实战/162
5.6　本章小结/163
第6章　数据访问层设计/164
6.1　数据访问层简述/164
6.2　数据访问层的设计策略/165
6.2.1　仓储模式/165
6.2.2　数据访问对象模式/166
6.3　数据访问层常用模式与原则解析/166
6.3.1　工作单元/167
6.3.2　标识映射/175
6.3.3　延迟加载/178
6.3.4　数据并发控制/182
6.3.5　查询对象/184
6.4　ORM对象关系映射/190
6.4.1　NHibernate介绍/191
6.4.2　Entity Framework介绍/191
6.5　企业级领域驱动设计项目实战/192
6.5.1　业务层的实现/192
6.5.2　服务层的实现/197
6.5.3　数据访问层的实现/203
6.5.4　显示层的实现/221
6.6　本章小结/223
第7章　数据存储层设计/224
7.1　合理选择数据存储方案/224
7.1.1　数据存储的三种方式/224
7.1.2　选择合理的数据存储方案/227
7.2　数据库架构设计/228
7.2.1　分布数据/229
7.2.2　数据拆分/229
7.2.3　读写分离/233
7.2.4　数据缓存/234
7.3　数据库设计/236
7.3.1　数据库计划/236
7.3.2　逻辑数据库设计/236
7.3.3　物理数据库设计/238
7.4　SQL Server数据库性能瓶颈分析与解决方案/240
7.4.1　缺失索引的瓶颈分析与解决方案/240
7.4.2　昂贵查询的瓶颈分析与解决方案/255
7.4.3　数据库碎片的瓶颈分析与解决方案/259
7.5　本章小结/261
第8章　显示层设计/262
8.1　MVP模式的原理与实战/262
8.1.1　MVP模式实战（ASP.NET实现）/263
8.1.2　MVP模式经验谈/269
8.1.3　MVP模式之高级话题/276
8.2　前端控制器模式的原理与实战/283
8.2.1　前端控制器模式介绍/283
8.2.2　深入浅出命令模式/284
8.2.3　前端控制器模式实战/287
8.3　MVC模式的原理与实战/289
8.3.1　深入浅出MVC模式/290
8.3.2　MVC模式之高级话题/297
8.3.3　MVC模式实战——对ASP.NET MVC源码进行分析/298
8.4　PM模式的原理与实战/313
8.4.1　PM模式的解析/313
8.4.2　PM模式实战/316
8.5　MVVM模式的原理与实战/324
8.5.1　MVVM模式介绍/324
8.5.2　MVVM模式深度剖析/325
8.5.3　MVVM模式高级话题/337
8.6　本章小结/342
第三部分　.NET应用的架构与设计实战
第9章　IT创业产品互推平台的项目背景与功能介绍/344
9.1　IT创业产品互推平台背景/344
9.2　SNS功能介绍/344
9.2.1　用户管理/345
9.2.2　个人信息管理/346
9.2.3　软件展示功能/347
9.2.4　好友功能/348
9.2.5　站内信息功能/349
9.2.6　多媒体文件管理/350
9.2.7　博客/351
9.2.8　用户群/353
9.2.9　微博/354
9.2.10　共享功能/355
9.2.11　论坛/355
9.2.12　活动/356
9.2.13　投票/358
9.2.14　页面布局定制/359
9.2.15　评级/359
9.3　本章小结/360
第10章　IT创业产品互推平台架构设计/361
10.1　分层设计/361
10.1.1　逻辑分层的总体设计/361
10.1.2　通用功能设计/362
10.1.3　业务层设计/363
10.1.4　数据持久层设计/364
10.1.5　显示层设计/364
10.2　部署设计/365
10.2.1　单服务器部署/365
10.2.2　多服务器部署/365
10.3　文件存储的设计/367
10.4　基础类库的设计/369
10.4.1　缓存/369
10.4.2　配置读取/375
10.4.3　邮件发送/376
10.4.4　日志记录/378
10.4.5　辅助类的实现/382
10.5　本章小结/383
第11章　IT创业产品互推平台用户管理/384
11.1　用户管理功能分析/384
11.1.1　用户注册/384
11.1.2　用户登录/384
11.1.3　找回密码/386
11.1.4　激活账户/386
11.1.5　删除用户/386
11.1.6　更新用户/387
11.1.7　查询用户/387
11.2　用户管理接口的定义/390
11.2.1　服务层实现定义/390
11.2.2　业务模型定义/392
11.2.3　数据访问层的接口定义/393
11.3　用户管理的实现/393
11.3.1　服务层实现/393
11.3.2　业务层实现/400
11.3.3　数据访问层实现/403
11.3.4　显示层实现/404
11.4　本章小结/406
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>.NET应用架构设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高可用可伸缩微服务架构
1.1 什么是架构 1
1.2 几个相关概念 3
1.3 从软件的生命周期看架构设计 7
1.4 架构的形式与特点 9
1.5 架构的目标与方法 13
1.6 架构的不同风格 18
第2章 微服务领域驱动设计 30
2.1 领域驱动设计 31
2.1.1 领域驱动设计概览 31
2.1.2 问题域与解决方案域 34
2.1.3 限界上下文 35
2.1.4 上下文映射 40
2.1.5 领域架构 43
2.2 微服务的设计 48
2.2.1 限界上下文的边界 48
2.2.2 限界上下文即微服务 51
2.2.3 识别限界上下文 53
2.2.4 微服务之间的协作 59
2.3 小结 63
第3章 Apache Dubbo框架的原理与实现 64
3.1 Dubbo框架的选型与使用 64
3.1.1 Dubbo框架的选型 64
3.1.2 Dubbo框架的使用 65
3.2 Dubbo框架的原理分析 70
3.2.1 总体架构分析 70
3.2.2 Dubbo Bean的加载 73
3.2.3 Dubbo Extension机制 77
3.2.4 Dubbo消费端 91
3.2.5 Dubbo服务端 126
3.2.6 Dubbo的通信机制 144
3.3 基于Dubbo的自动化Mock系统 165
3.3.1 Mock模拟系统的产生 166
3.3.2 Dubbo Mock的使用 167
3.3.3 Dubbo Mock的原理解析 168
3.3.4 自动化Mock系统的实现 170
第4章 Spring Boot/Spring Cloud实践 177
4.1 Spring Boot原理剖析 178
4.1.1 Spring Boot Quick Start 178
4.1.2 Spring Boot之SpringApplication 180
4.1.3 spring-boot-loaded模块分析 186
4.1.4 spring-boot-autoconfigure模块分析 190
4.1.5 Spring Boot Conditional注解分析 195
4.2 Dubbo Spring Boot Starter 198
4.2.1 Dubbo Spring Boot Starter简介 198
4.2.2 Dubbo Initializr及sample 198
4.2.3 dubbo-spring-boot-autoconfigure模块 201
4.2.4 dubbo-spring-boot-actuator模块 204
4.3 Spring Cloud栈 211
4.3.1 为什么微服务架构需要Spring Cloud 212
4.3.2 Spring Cloud技术栈总览 214
4.3.3 spring-cloud-scaffold基础库集合 215
4.4 基于Maven Archetype的脚手架 239
4.4.1 Maven Archetype 239
4.4.2 脚手架的搭建 240
4.4.3 生成脚手架 247
第5章 微服务稳定性保证的常用手段 250
5.1 微服务的稳定性 250
5.2 高可用 250
5.2.1 限流原理与实现 250
5.2.2 断路器原理与实现 256
5.2.3 超时与重试 260
5.3 高并发 262
5.3.1 异步 263
5.3.2 缓存 270
5.4 总结 272
第6章 微服务下如何保证事务的一致性 273
6.1 从本地事务到分布式事务的演变 273
6.2 强一致性解决方案 276
6.2.1 二阶段提交协议 276
6.2.2 三阶段提交协议 278
6.3 最终一致性解决方案 280
6.3.1 TCC模式 280
6.3.2 补偿模式 285
6.3.3 可靠事件模式 286
6.4 开源项目的分布式事务实现解读 288
6.4.1 Apache RocketMQ 288
6.4.2 ServiceComb 289
第7章 百亿流量微服务网关的设计与实现 293
7.1 API网关概述 293
7.1.1 分布式服务架构、微服务架构与 API 网关 293
7.1.2 API网关的定义、职能与关注点 296
7.1.3 API网关的分类与技术分析 298
7.2 开源网关的分析与调研 300
7.2.1 常见的开源网关介绍 300
7.2.2 四大开源网关的对比分析 308
7.2.3 开源网关的技术总结 309
7.3 百亿流量交易系统API网关设计 310
7.3.1 百亿流量交易系统API网关的现状和面临问题 310
7.3.2 业务网关的设计与最佳实践 313
第8章 微服务编排 317
8.1 Netflix Conductor 317
8.2 Netflix Conductor的架构 319
8.3 Conductor的使用案例 320
8.4 Netflix Conductor源码分析 328
8.4.1 Client层源码分析 330
8.4.2 Server端源码分析 337
8.4.3 core端源码分析 344
第9章 微服务数据抽取与统计 356
9.1 案例小故事 356
9.2 数据仓库概述 358
9.2.1 什么是数据仓库 358
9.2.2 数据仓库架构 360
9.2.3 数据仓库建模方法 361
9.2.4 数据抽取、转换和加载 361
9.2.5 数据统计 362
9.3 数据仓库工具Hive 362
9.3.1 安装Hive 364
9.3.2 Hive数据库 366
9.3.3 Hive表 367
9.4 使用Sqoop抽取数据 369
9.4.1 安装Sqoop 370
9.4.2 将MySQL表数据导入Hive表 372
9.5 ETL作业调度 375
第10章 微服务双活体系建设 377
10.1 系统高可用 377
10.2 双活数据中心 379
10.2.1 单机房部署 379
10.2.2 双机房部署 380
10.2.3 基于支付场景的双活体系建设 383
第11章 基于支付场景下的微服务改造与性能优化 399
11.1 支付场景的介绍 399
11.2 支付业务建模和服务划分 400
11.3 支付场景下微服务架构的详解与分析 402
11.3.1 业务架构分析 402
11.3.2 技术平台详解 404
11.4 从代码层面提升微服务架构的性能 407
11.4.1 从代码和设计的角度看 407
11.4.2 从整体架构的角度看 418
11.5 微服务架构中常见的一些故障分析技巧 421
第12章 遗留系统的微服务架构改造 426
12.1 代码分层结构的转变 426
12.2 遗留系统的债券与思考 430
12.3 从单体系统拆分服务的方法论 431
12.4 遗留系统的微服务架构改造 436
12.4.1 从代码重构开始 436
12.4.2 拆分服务需要面向服务进行架构设计 437
12.4.3 改造是一个渐进的过程 437
12.4.4 单元测试是基石 440
12.4.5 面向失败的设计 440
12.4.6 前后端分离 441
12.4.7 共享现有数据库 441
12.4.8 灰度发布的必要性 442
12.4.9 日志聚合与全链路监控 442
第13章 Service Mesh详解 443
13.1 Service Mesh是什么 443
13.2 Service Mesh的背景 443
13.3 Service Mesh介绍 444
13.3.1 Service Mesh架构 444
13.3.2 Service Mesh能做什么 445
13.4 Service Mesh的价值 446
13.5 Service Mesh现状 447
13.6 Service Mesh存在的问题 448
13.7 Istio详解 449
13.7.1 Istio架构 449
13.7.2 数据平面 450
13.7.3 控制平面 455
13.7.4 Isito案例 458
13.8 Service Mesh展望 461
第14章 微服务监控实战 463
14.1 APM原理与应用 464
14.1.1 什么是APM 464
14.1.2 APM监控点 464
14.1.3 APM深入解析 464
14.2 Prometheus监控系统介绍 492
14.2.1 Prometheus的主要特点 493
14.2.2 Prometheus的架构及组件介绍 493
14.2.3 Prometheus的安装 494
14.2.4 使用Prometheus对MySQL进行监控 498
14.2.5 Prometheus的告警机制 501
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高可用可伸缩微服务架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻量级微服务架构（上册）
第1章　微服务架构设计概述
1.1　为什么需要微服务架构
1.1.1　传统应用架构的问题
1.1.2　如何解决传统应用架构的问题
1.1.3　传统应用架构还有哪些问题
1.2　微服务架构是什么
1.2.1　微服务架构概念
1.2.2　微服务交付流程
1.2.3　微服务开发规范
1.2.4　微服务架构模式
1.3　微服务架构有哪些特点和挑战
1.3.1　微服务架构的特点
1.3.2　微服务架构的挑战
1.4　如何搭建微服务架构
1.4.1　微服务架构图
1.4.2　微服务技术选型
1.5　本章小结
第2章　微服务开发框架
2.1　Spring Boot 是什么
2.1.1　Spring Boot的由来
2.1.2　Spring Boot的特性
2.1.3　Spring Boot相关插件
2.1.4　Spring Boot的应用场景
2.2　如何使用Spring Boot框架
2.2.1　搭建Spring Boot开发框架
2.2.2　开发一个简单的Spring Boot应用程序
2.2.3　运行Spring Boot应用程序
2.3　Spring Boot生产级特性
2.3.1　端点
2.3.2  健康检查
2.3.3　应用基本信息
2.3.4　跨域
2.3.5　外部配置
2.3.6　远程监控
2.4　本章小结
第3章　微服务网关
3.1　Node.js是什么
3.1.1　Node.js快速入门
3.1.2　Node.js应用场景
3.2　如何使用Node.js
3.2.1　安装Node.js
3.2.2　使用Node.js开发 Web应用
3.2.3　使用Express框架开发Web应用
3.2.4　搭建Node.js集群环境
3.3　使用Node.js搭建微服务网关
3.3.1　什么是微服务网关
3.3.2　使用Node.js实现反向代理
3.4　本章小结
第4章　微服务注册与发现
4.1　ZooKeeper是什么
4.1.1　ZooKeeper树状模型
4.1.2　ZooKeeper集群结构
4.2　如何使用ZooKeeper
4.2.1　运行ZooKeeper
4.2.2　搭建ZooKeeper集群环境
4.2.3　使用命令行客户端连接ZooKeeper
4.2.4　使用Java客户端连接ZooKeeper
4.2.5　使用Node.js客户端连接ZooKeeper
4.3　实现服务注册组件
4.3.1　设计服务注册表数据结构
4.3.2　搭建应用程序框架
4.3.3　定义服务注册表接口
4.3.4　使用ZooKeeper实现服务注册
4.3.5　服务注册模式
4.4　实现服务发现组件
4.4.1　定义服务发现策略
4.4.2　搭建应用程序框架
4.4.3　使用Node.js实现服务发现
4.4.4　服务发现优化方案
4.4.5　服务发现模式
4.5　本章小结
第5章　微服务封装
5.1  Docker是什么
5.1.1  Docker简介
5.1.2  虚拟机与Docker对比
5.1.3　Docker的特点
5.1.4  Docker系统架构
5.1.5  安装Docker
5.2　如何使用Docker
5.2.1　Docker镜像常用操作
5.2.2　Docker容器常用操作
5.2.3  Docker命令汇总
5.3  手工制作Java镜像
5.3.1  下载JDK
5.3.2　启动容器
5.3.3　提交镜像
5.3.4  验证镜像
5.4  使用Dockerfile构建镜像
5.4.1  了解Dockerfile基本结构
5.4.2  使用Dockerfile构建镜像
5.4.3　Dockerfile指令汇总
5.5　使用Docker Registry管理镜像
5.5.1　使用Docker Hub
5.5.2　搭建Docker Registry
5.6  Spring Boot与Docker整合
5.6.1　搭建Spring Boot应用程序框架
5.6.2　为Spring Boot应用添加Dockerfile
5.6.3　使用Maven构建Docker镜像
5.6.4　启动Spring Boot的Docker容器
5.6.5  调整Docker容器内存限制
5.7　本章小结
第6章　微服务部署
6.1　Jenkins是什么
6.1.1　Jenkins简介
6.1.2　自动化发布平台
6.1.3　安装Jenkins
6.2　搭建GitLab版本控制系统
6.2.1　GitLab简介
6.2.2　安装GitLab
6.2.3　将代码推送至GitLab中
6.3　搭建Jenkins持续集成系统
6.3.1　创建构建任务
6.3.2　手工执行构建
6.3.3　自动执行构建
6.4　使用Jenkins实现自动化发布
6.4.1　自动发布jar包
6.4.2　自动发布Docker容器
6.5　本章小结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻量级微服务架构（上册）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件架构
译者序
关于作者
关于评审人
前言
第1章　软件架构原理 1
1.1　软件架构定义 2
1.1.1　软件架构与设计 2
1.1.2　软件架构相关的几个方面 3
1.2　软件架构的特征 3
1.2.1　用架构来定义一种结构 3
1.2.2　由架构来挑选一组核心元素 4
1.2.3　由架构来捕获早期的设计决策 4
1.2.4　由架构来管理利益相关者的需求 5
1.2.5　架构影响着组织结构 5
1.2.6　架构受到环境的影响 6
1.2.7　架构是对系统的文档化 6
1.2.8　架构通常会遵循某个模式 7
1.3　软件架构的重要性 7
1.4　系统架构与企业架构 8
1.5　架构的质量属性 10
1.5.1　可修改性 11
1.5.2　可测试性 13
1.5.3　可扩展性 14
1.5.4　性能 15
1.5.5　可用性 16
1.5.6　安全性 17
1.5.7　可部署性 18
1.6　本章小结 19
第2章　编写可修改可读的代码 20
2.1　什么是可修改性 20
2.2　与可修改性相关的几个方面 20
2.3　理解可读性 21
2.3.1　Python和可读性 21
2.3.2　可读性–反模式 22
2.4　增强可读性的各种技术 24
2.4.1　文档化代码 24
2.4.2　遵守编码和风格规范 30
2.4.3　审查和重构代码 31
2.4.4　注释代码 31
2.5　可修改性的基础——内聚和耦合 32
2.5.1　测量内聚性和耦合性 33
2.5.2　字符串和文本处理 35
2.6　探索提高可修改性的策略 37
2.6.1　提供显式接口 37
2.6.2　减少双向依赖 37
2.6.3　抽象出公共服务 38
2.6.4　使用继承技术 38
2.6.5　使用延迟绑定技术 42
2.7　度量——静态分析工具 43
2.7.1　什么是代码坏味道 43
2.7.2　圈复杂度——McCabe度量 44
2.7.3　度量结果测试 45
2.7.4　运行静态检查器 47
2.8　重构代码 53
2.8.1　降低复杂度 53
2.8.2　改善代码坏味道 55
2.8.3　改善风格上和编码上的问题 57
2.9　本章小结 57
第3章　可测试性——编写可测试的代码 58
3.1　理解可测试性 58
3.1.1　软件可测试性及相关属性 58
3.1.2　架构级的方方面面 59
3.1.3　策略 60
3.2　白盒测试原理 65
3.2.1　单元测试 65
3.2.2　操作中的单元测试 66
3.2.3　单元测试模块nose2 69
3.2.4　用py.test进行测试 70
3.2.5　代码覆盖 72
3.2.6　仿制一些东西 74
3.2.7　文档中的内联测试——doctest 78
3.2.8　集成测试 81
3.2.9　测试自动化 83
3.3　测试驱动开发 84
3.4　有回文的TDD 85
3.5　本章小结 90
第4章　好的性能就是回报 92
4.1　什么是性能 93
4.2　软件性能工程 93
4.3　性能测试和度量工具 94
4.4　性能复杂度 95
4.5　度量性能 96
4.5.1　使用上下文管理器度量时间 97
4.5.2　使用timeit模块来计时代码 99
4.5.3　使用timeit度量代码的性能 100
4.5.4　揭示时间复杂度——各种图 102
4.5.5　使用timeit度量CPU时间 106
4.6　剖析 107
4.6.1　确定性剖析 107
4.6.2　使用cProfile和profile进行剖析 108
4.6.3　收集和报告统计数据 111
4.6.4　第三方剖析器 113
4.7　其他工具 119
4.7.1　objgraph 120
4.7.2　pympler 121
4.8　程序设计性能——数据结构 123
4.8.1　可变容器——链表、字典和集合 123
4.8.2　不可变容器——元组 124
4.8.3　高性能容器——集合模块 125
4.8.4　概率数据结构——布隆过滤器 131
4.9　本章小结 134
第5章　开发可扩展的应用 136
5.1　可扩展性和性能 137
5.2　并发性 139
5.2.1　并发性与并行性 140
5.2.2　Python中的并发性——多线程机制 141
5.3　缩略图产生器 141
5.3.1　缩略图产生器——生产者/消费者架构 143
5.3.2　缩略图产生器——使用锁的资源约束 147
5.3.3　缩略图产生器——使用信号量的资源约束 150
5.3.4　资源约束——信号量和锁比较 153
5.3.5　缩略图产生器——使用条件的URL速率控制器 153
5.4　多线程机制——Python和GIL 160
5.4.1　Python中的并发性——多进程机制 160
5.4.2　质数检查器 161
5.4.3　排序磁盘文件 163
5.5　多线程与多进程比较 168
5.6　先入为主的与合作的多任务处理 170
5.7　Python中的asyncio模块 173
5.8　等待future对象——async和await 175
5.9　concurrent.future——高级并发处理 178
5.9.1　磁盘缩略图产生器 179
5.9.2　并发选项——如何选择？ 181
5.10　并行处理库 182
5.10.1　joblib 182
5.10.2　PyMP 183
5.10.3　fractals —— Mandelbrot集 184
5.11　Web扩展 189
5.11.1　扩展工作流——消息队列和任务队列 189
5.11.2　Celery —— 一种分布式任务队列 190
5.11.3　在Web上使用Python服务——WSGI 194
5.12　可扩展架构 197
5.12.1　垂直可扩展架构 197
5.12.2　水平扩展架构 198
5.13　本章小结 201
第6章　安全性——编写安全代码 202
6.1　信息安全架构 202
6.2　安全编码 203
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据架构详解
第一部分  大数据的本质
第1章  大数据是什么	2
1.1  大数据导论	2
1.1.1  大数据简史	2
1.1.2  大数据现状	3
1.1.3  大数据与BI	3
1.2  企业数据资产	4
1.3  大数据挑战	5
1.3.1  成本挑战	6
1.3.2  实时性挑战	6
1.3.3  安全挑战	6
1.4  小结	6
第2章  运营商大数据架构	7
2.1  架构驱动的因素	7
2.2  大数据平台架构	7
2.3  平台发展趋势	8
2.4  小结	8
第3章  运营商大数据业务	9
3.1  运营商常见的大数据业务	9
3.1.1  SQM（运维质量管理）	9
3.1.2  CSE（客户体验提升）	9
3.1.3  MSS（市场运维支撑）	10
3.1.4  DMP（数据管理平台）	10
3.2  小结	11
第二部分  大数据技术
第4章  数据获取	14
4.1  数据分类	14
4.2  数据获取组件	14
4.3  探针	15
4.3.1  探针原理	15
4.3.2  探针的关键能力	16
4.4  网页采集	26
4.4.1  网络爬虫	26
4.4.2  简单爬虫Python代码示例	32
4.5  日志收集	33
4.5.1  Flume	33
4.5.2  其他日志收集组件	47
4.6  数据分发中间件	47
4.6.1  数据分发中间件的作用	47
4.6.2  Kafka架构和原理	47
4.7  小结	82
第5章  流处理	83
5.1  算子	83
5.2  流的概念	83
5.3  流的应用场景	84
5.3.1  金融领域	84
5.3.2  电信领域	85
5.4  业界两种典型的流引擎	85
5.4.1  Storm	85
5.4.2  Spark Streaming	89
5.4.3  融合框架	102
5.5  CEP	108
5.5.1  CEP是什么	108
5.5.2  CEP的架构	109
5.5.3  Esper	110
5.6  实时结合机器学习	110
5.6.1  Eagle的特点	111
5.6.2  Eagle概览	111
5.7  小结	116
第6章  交互式分析	117
6.1  交互式分析的概念	117
6.2  MPP DB技术	118
6.2.1  MPP的概念	118
6.2.2  典型的MPP数据库	121
6.2.3  MPP DB调优实战	131
6.2.4  MPP DB适用场景	162
6.3  SQL on Hadoop	163
6.3.1  Hive	163
6.3.2  Phoenix	165
6.3.3  Impala	166
6.4  大数据仓库	167
6.4.1  数据仓库的概念	167
6.4.2  OLTP/OLAP对比	168
6.4.3  大数据场景下的同与不同	168
6.4.4  查询引擎	169
6.4.5  存储引擎	170
6.5  小结	171
第7章  批处理技术	172
7.1  批处理技术的概念	172
7.2  MPP DB技术	172
7.3  MapReduce编程框架	173
7.3.1  MapReduce起源	173
7.3.2  MapReduce原理	173
7.3.3  Shuffle	174
7.3.4  性能差的主要原因	177
7.4  Spark架构和原理	177
7.4.1  Spark的起源和特点	177
7.4.2  Spark的核心概念	178
7.5  BSP框架	217
7.5.1  什么是BSP模型	217
7.5.2  并行模型介绍	218
7.5.3  BSP模型基本原理	220
7.5.4  BSP模型的特点	222
7.5.5  BSP模型的评价	222
7.5.6  BSP与MapReduce对比	222
7.5.7  BSP模型的实现	223
7.5.8  Apache Hama简介	223
7.6  批处理关键技术	227
7.6.1  CodeGen	227
7.6.2  CPU亲和技术	228
7.7  小结	229
第8章  机器学习和数据挖掘	230
8.1  机器学习和数据挖掘的联系与区别	230
8.2  典型的数据挖掘和机器学习过程	231
8.3  机器学习概览	232
8.3.1  学习方式	232
8.3.2  算法类似性	233
8.4  机器学习&数据挖掘应用案例	235
8.4.1  尿布和啤酒的故事	235
8.4.2  决策树用于电信领域故障快速定位	236
8.4.3  图像识别领域	236
8.4.4  自然语言识别	238
8.5  交互式分析	239
8.6  深度学习	240
8.6.1  深度学习概述	240
8.6.2  机器学习的背景	241
8.6.3  人脑视觉机理	242
8.6.4  关于特征	244
8.6.5  需要有多少个特征	245
8.6.6  深度学习的基本思想	246
8.6.7  浅层学习和深度学习	246
8.6.8  深度学习与神经网络	247
8.6.9  深度学习的训练过程	248
8.6.10  深度学习的框架	248
8.6.11  深度学习与GPU	255
8.6.12  深度学习小结与展望	256
8.7  小结	257
第9章  资源管理	258
9.1  资源管理的基本概念	258
9.1.1  资源调度的目标和价值	258
9.1.2  资源调度的使用限制及难点	258
9.2  Hadoop领域的资源调度框架	259
9.2.1  YARN	259
9.2.2  Borg	260
9.2.3  Omega	262
9.2.4  本节小结	263
9.3  资源分配算法	263
9.3.1  算法的作用	263
9.3.2  几种调度算法分析	263
9.4  数据中心统一资源调度	271
9.4.1  Mesos+Marathon架构和原理	271
9.4.2  Mesos+Marathon小结	283
9.5  多租户技术	284
9.5.1  多租户概念	284
9.5.2  多租户方案	284
9.6  基于应用描述的智能调度	287
9.7  Apache Mesos架构和原理	288
9.7.1  Apache Mesos背景	288
9.7.2  Apache Mesos总体架构	288
9.7.3  Apache Mesos工作原理	290
9.7.4  Apache Mesos关键技术	295
9.7.5  Mesos与YARN比较	304
9.8  小结	305
第10章  存储是基础	306
10.1  分久必合，合久必分	306
10.2  存储硬件的发展	306
10.2.1  机械硬盘的工作原理	306
10.2.2  SSD的原理	307
10.2.3  3DXPoint	309
10.2.4  硬件发展小结	309
10.3  存储关键指标	309
10.4  RAID技术	309
10.5  存储接口	310
10.5.1  文件接口	311
10.5.2  裸设备	311
10.5.3  对象接口	312
10.5.4  块接口	316
10.5.5  融合是趋势	328
10.6  存储加速技术	328
10.6.1  数据组织技术	328
10.6.2  缓存技术	335
10.7  小结	336
第11章  大数据云化	337
11.1  云计算定义	337
11.2  应用上云	337
11.2.1  Cloud Native概念	338
11.2.2  微服务架构	338
11.2.3  Docker配合微服务架构	342
11.2.4  应用上云小结	348
11.3  大数据上云	348
11.3.1  大数据云服务的两种模式	348
11.3.2  集群模式AWSEMR	349
11.3.3  服务模式Azure Data Lake Analytics	352
11.4  小结	354
第三部分  大数据文化
第12章  大数据技术开发文化	356
12.1  开源文化	356
12.2  DevOps理念	356
12.2.1  Development和Operations的组合	357
12.2.2  对应用程序发布的影响	357
12.2.3  遇到的问题	358
12.2.4  协调人	358
12.2.5  成功的关键	359
12.3  速度远比你想的重要	359
12.4  小结	361
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据架构详解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件架构师的12项修炼(技术技能篇)
译者序
前言
致谢
第一部分项目技能
第1章合作关系
1.1什么是合作关系
1.2合作关系的关键特征
1.3一致
1.3.1我需要和谁结成合作伙伴
1.3.2找出思想领袖
1.3.3认识影响力人物
1.3.4确定可信的建议者
1.3.5社区评审（架构评审委员会）
1.3.6在做出关键决策之前寻求一致
1.3.7共同愿景的一致成就合作关系
1.4信任
1.4.1建立信任
1.4.2建立公开披露机制
1.4.3避免将摊子铺得过大（过度投入）
1.4.4在你过度承诺之后如何解脱
1.4.5学会说“不”
1.4.6信任带来透明度——合作关系的命脉
1.5语境
1.5.1了解合作的性质
1.5.2了解你的业务背景（语境）
1.5.3技术决策需要合作关系
1.5.4关键点：技术决策是政治决策
1.5.5首先介绍情况（提供语境）
1.5.6支持你的合作伙伴
1.5.7为合作伙伴的成功做出贡献
1.5.8人多势众
1.6协作
1.6.1将价值放到台面上
1.6.2成为导师
1.6.3寻找导师
1.6.4合作关系可能是机遇之源
1.6.5合作关系是迈向构思的一步
1.6.6协作推动更强大的合作关系
1.7关系
1.7.1合作关系不仅和业务有关
1.7.2想要索取就要先付出
1.7.3外部合作关系
1.7.4过去的不愉快经历
1.7.5躲开组织中的刻薄鬼
1.8小结
参考书目
第2章发现
2.1什么是发现
2.2发现的关键
2.3了解客户
2.3.1与销售、市场及新产品开发部门建立合作关系
2.3.2与客户会面
2.3.3取悦客户的是什么
2.4了解市场
2.4.1了解客户的客户
2.4.2客户愿意在哪里花钱
2.4.3竞争对手在做什么
2.4.4倾听不同客户的主题
2.5理解你的业务
2.5.1研究你的业务目标
2.5.2个性化公司的战略目标
2.5.3为决策开发一个业务语境
2.6小结
参考书目
第3章概念化
3.1构思
3.2及早介入
3.3概念化：将生命赋予思路
3.4概念形成
3.4.1他们使用什么语言
3.4.2正在讨论的是什么问题
3.4.3当你较晚进入构思团体中时，需要谨慎投入
3.4.4这个概念是什么样子的
3.5概念具体化
3.5.1最小可行性产品
3.5.2试验的需求
3.5.3建立假设有助于协调愿景
3.5.4确定必不可少的功能和客户角色
3.5.5和客户一起进行概念具体化
3.6概念演化
3.6.1以史为鉴
3.6.2接受多种视角
3.6.3寻求概念完整性
3.6.4发现邻近的机遇
3.7小结
参考书目
第4章估算
4.1估算概述
4.1.1估算的目的是什么
4.1.2是否建立了项目语境
4.1.3什么是架构方法
4.2理解估算过程
4.2.1估算管线
4.2.2项目类型
4.2.3项目筹资的其他方式
4.2.4理解业务过程
4.3开发架构方法
4.3.1是合作伙伴关系还是合同关系
4.3.2项目在业务上的依据是什么
4.3.3营销方式是什么
4.3.4是不是重复的估算
4.3.5已经识别了哪些风险？能否缓解
4.3.6是否将构建一个平台
4.3.7是否将更改平台
4.3.8使用何种技术
4.3.9采用何种组织结构
4.3.10是否需要进行外部调查
4.3.11是否找出了可利用的组件
4.4估算策略
4.4.1为未知因素和挑战制订计划
4.4.2务实：不要为了获得项目而屈服
4.4.3严密控制关键因素
4.4.4开发估算反馈循环
4.4.5最大限度地减少组织耦合和内聚
4.4.6随身带着PowerPoint
4.4.7开发检查列表
4.4.8及早获得高管和组织的支持
4.5估算原则
4.5，1确定疑难问题
4.5.2提供选项
4.5.3保持设计决策的开放
4.5.4了解时间表
4.5.5知道你想要的结果
4.5.6避免负面态度
4.5.7寻找说“是”的机会
4.5.8现在就开始讨价还价，不要等到以后
4.5.9不要认输
4.5.10相信你的直觉
4.5.11了解其他人估算过的项目
4.5.12了解业务部门的目标价格
4.6完成估算
4.6.1了解时限
4.6.2谁参与估算
4.6.3理解你的切入点
4.6.4组合所有信息
4.6.5与高管人员接触
4.6.6推销估算
4.7小结
参考书目
第5章管理
5.1架构管理定义
5.2架构师负责的领域
5.3坚持追求技术上的卓越
5.3.1确立一个愿景
5.3.2提升技术负债意识，投资合适的解决方案
5.3.3保持技术环境的趣味性
5.3.4找出潜在的专利
5.3.5寻求数据中心和运营部门对你的方向的支持
5.3.6推广解决方案
5.3.7建立战略性解决方案
5.3.8利用现有解决方案
5.4交付项目
5.4.1与项目经理成为合作伙伴
5.4.2无情地消除依赖性
5.4.3管理预期
5.4.4控制开发过程
5.4.5在发生问题时出现
5.4.6了解项目上不透明的因素
5.4.7限制处于领导地位的承包商数量
5.4.8提供技术管理（职责领域）
5.4.9应急管理
5.5解决问题
5.5.1提出难题
5.5.2立即处理问题
5.5.3说“不”，但是要提出选项
5.5.4在决策中努力保持一致
5.5.5学会正面处理问题、摊牌
5.5.6知道在协商中你所愿意接受的
5.5.7勇于对不同意的领域（有礼貌地）提出挑战
5.5.8坚持立场
5.5.9知道哪些不是你的问题
5.6与高管人员成为合作伙伴
5.6.1通过透明度管理风险
5.6.2审核估算
5.6.3限制框图中方框的数量
5.6.4提升技术意识
5.6.5支持老板
5.6.6不要打断高管人员的讲话
5.6.7保持自信
5.7管理你的时间
5.7.1限制投入的项目数量
5.7.2定义自己的角色并坚持
5.7.3确定费时工作的优先级
5.7.4学会在限定的日期和时间做出决策
5.7.5只在你是活跃的参与者时才参加会议
5.7.6了解最后期限
5.7.7委托你信任的人
5.7.8面对面会谈
5.8培养技术人才
5.8.1制定架构导师计划
5.8.2建立技术论坛
5.8.3鼓励技术团队成员参与当地的会议和用户组
5.8.4雇用最 好的员工：不只是填补一个职位
5.9提高技能
5.9.1与其他架构师坐在一起
5，9.2每天做一些技术工作
5.9.3专注于令你吃惊的事情
5.9.4成为某个领域的专家
5.9，5寻求能够提高技能的项目
5.10小结
参考书目
……
第二部分技术技能
第三部分想象力技能
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件架构师的12项修炼(技术技能篇)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业信息化总体架构
第1章  序言第2章  企业信息化发展和总体架构历史  2.1 企业信息化发展历史    2.1.1 信息处理工具的开启    2.1.2 计算历史    2.1.3 计算机和人类的智能    2.1.4 科学比照商业计算    2.1.5 产品线管理在商业计算方面改进的历史缺陷    2.1.6 计算的本征    2.1.7 架构的概念  2.2 信息化现状和遇到的问题    2.2.1 信息化发展的简单问题    2.2.2 信息化的资源短缺    2.2.3 信息化与企业的发展同步，为业务的创新和竞争优势提供驱动力的方法  2.3 国际总体架构现况综述  2.4 企业信息化总体架构价值综述    2.4.1 需要总体架构的原因    2.4.2 总体架构的综合思考  2.5 投资回报分析    2.5.1 ROI评估    2.5.2 总体架构的商业模型第3章  企业信息化总体架构的内容和发展  3.1 企业信息化总体架构的概念  3.2 企业信息化总体架构的产生    3.2.1 企业信息化总体架构的框架结构    3.2.2 全新的考虑问题的方法    3.2.3 信息化总体架构的范围    3.2.4 总体架构框架  3.3 国际通用的几种企业信息化总体架构的框架理论    3.3.1 企业信息化总体架构组成    3.3.2 总体架构的模型    3.3.3 企业设计总体架构框架理论的目的    3.4 国际主要总体架构组织和理论介绍    3.4.1 Zachman架构框架    3.4.2 联邦总体架构框架FEAF／CIO协会框架    3.4.3 欧共体总体框架    3.4.4 军队指挥系统总体框架    3.4.5 架构框架理论的一致性    3.5 适合我国信息化进程的信息化总体架构EACF    3.6 企业总体架构的治理和作用    3.6.1 信息化总体架构的治理    3.6.2 架构管理工具第4章  企业信息化总体架构的规划和设计  4.1 企业信息化总体架构的内容    4.1.1 业务架构    4.1.2 应用架构    4.1.3 信息(数据)架构    4.1.4 技术架构  4.2 企业信息化总体架构规划方法要点  4.3 建立企业信息化总体架构    4.3.1 企业建立总体架构的方法    4.3.2 建立总体架构的详细步骤    4.3.3 搭建企业总体架构的工作实例  4.4 使用信息化总体架构第5章  企业信息化总体架构的管理和发展  5.1 总体架构与业务战略关系  5.2 企业信息化总体架构生命周期  5.3 企业信息化总体架构的工作、发展、成熟  5.4 企业信息化总体架构的形式、参与与作用    5.4.1 总体架构参与者及其责任    5.4.2 总体架构参与者的参与权重    5.4.3 职责覆盖阶段范围  5.5 信息技术投资评价及评审策略  5.6 企业信息化总体架构成熟度评估第6章  企业信息化总体架构工具  6.1 总体架构建模和设计工具的发展  6.2 总体架构工具的介绍  6.3 总体架构设计工具    6.3.1 信息化架构工具介绍    6.3.2 技术要求及可行性    6.3.3 S架构工具的应用第7章  企业信息化总体架构规划及案例分析  7.1 美国大型企业的总体架构机制(以金融企业为例)  7.2 总体架构的内容和作用(实例及分析)    7.2.1 总体架构政策    7.2.2 指导原则    7.2.3 标准    7.2.4 总体架构的IT项目审核    7.2.5 项目组合优化管理    7.2.6 系统解决方案    7.2.7 系统设计基础架构(架构模板)    7.2.8 模块的应用和技术组件(Solution Pattern and Cornponent ARC)    7.2.9 架构在IT项目周期中的指导和管理    7.2.10 供应商的选择和管理  7.3 金融系统应用技术架构模型  7.4 再论EACF、——适合中国国情的总体架构框架视图  7.5 中国企业信息化总体架构设计分析附录1  术语表附录2  总体架构Internet参考信息源附录3  总体架构工具全球提供商(by Gartner Group)附录4  联邦总体架构实例列举附录5  技术架构规范设计案例总布置规划建议参考文献编后语
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业信息化总体架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux系统架构与目录解析
第1章 Linux目录的基本概念 1
1.1 Linux 目录的定义 6
1.2 根目录的建立 9
1.3 根目录的意义 11
1.4 根目录中的目录清单 13
总结 14
第2章 不同启动模式的目录 15
2.1 本地启动 [/boot]  18
2.1.1 /boot/grub 21
2.1.2 System.map文件 23
2.1.3 kernel及initrd 25
2.2 远程启动 [/tftpboot]  28
总结 30
第3章 Kernel Space与User Space的桥梁——虚拟文件系统 31
3.1 设备文件目录 [/dev]  34
3.1.1 基本的设备文件 36
3.1.2 /dev/bus 39
3.1.3 /dev/disk 40
3.1.4 /dev/input 41
3.1.5 /dev/mapper 42
3.1.6 /dev/net 43
3.1.7 /dev/pts 44
3.1.8 /dev/shm 45
3.1.9 /dev/.udev 46
3.1.10 /dev/VolGroup00 47
3.2 程序信息与系统设置目录 [/proc]  47
3.2.1 基本程序文件 49
3.2.2 /proc/[number] 56
3.2.3 /proc/acpi 57
3.2.4 /proc/bus 58
3.2.5 /proc/driver 58
3.2.6 /proc/fs 58
3.2.7 /proc/irq 58
3.2.8 /proc/net 59
3.2.9 /proc/scsi 62
3.2.10 /proc/sys 62
3.2.11 /proc/sysvipc 79
3.2.12 /proc/tty 79
3.3 系统分类信息 [/sys]  80
3.3.1 /sys/block 82
3.3.2 /sys/bus 83
3.3.3 /sys/class 84
3.3.4 /sys/devices 85
3.3.5 /sys/firmware 86
3.3.6 /sys/fs 86
3.3.7 /sys/kernel 87
3.3.8 /sys/module 87
3.3.9 /sys/power 88
总结 91
第4章 应用程序目录 93
4.1 执行文件目录 [/bin] 与 [/sbin]  95
4.2 函数库目录 [/lib]  98
4.2.1 /lib/bdevid 99
4.2.2 /lib/firmware 99
4.2.3 /lib/i686 100
4.2.4 /lib/iptables 100
4.2.5 /lib/kbd 101
4.2.6 /lib/lsb 102
4.2.7 /lib/modules 103
4.2.8 /lib/rtkaio 105
4.2.9 /lib/security 106
4.2.10 /lib/terminfo 108
4.2.11 /lib/tls 109
4.2.12 /lib/udev 110
4.3 还原损坏文件目录 [/lost+found]  110
4.4 额外安装软件目录 [/opt]  111
4.5 用户共享目录 [/usr]  112
4.5.1 /usr/bin与/usr/sbin 112
4.5.2 /usr/etc 113
4.5.3 /usr/games 113
4.5.4 /usr/include 114
4.5.5 /usr/kerberos 114
4.5.6 /usr/lib 115
4.5.7 /usr/libexec 116
4.5.8 /usr/local 116
4.5.9 /usr/share 117
4.5.10 /usr/src 118
4.6 临时目录 [/tmp]  120
4.6.1 /tmp/.font-unix 121
4.6.2 /tmp/gconfd-juergen 121
4.6.3 /tmp/.ICE-unix 122
总结 122
第5章 用户的主目录 123
5.1 /home/juergen/基本文件 126
5.1.1 .bashrc及.bash_profile 127
5.1.2 .bash_history 129
5.1.3 .bash_logout 130
5.1.4 public_html 130
5.2 /home/juergen/额外文件 131
5.2.1 X Window配置 132
5.2.2 X Window文件存放目录 137
结语 139
第6章 系统配置目录 141
6.1 /etc 143
6.1.1 基本文件 144
6.1.2 服务器目录 169
6.1.3 系统目录 176
6.1.4 安全性目录 196
6.1.5 X Window目录 202
6.1.6 其他目录 210
6.2 /srv 220
总结 220
第7章 日志文件与媒体挂载目录 221
7.1 动态文件记录区 [/var]  223
7.1.1 /var/account 223
7.1.2 /var/cache 225
7.1.3 /var/empty 225
7.1.4 /var/ftp 226
7.1.5 /var/gdm 226
7.1.6 /var/lib 227
7.1.7 /var/lock 227
7.1.8 /var/log 228
7.1.9 /var/named 229
7.1.10 /var/nis和/var/yp 230
7.1.11 /var/run 230
7.1.12 /var/spool 231
7.1.13 /var/tmp 233
7.1.14 /var/www 234
7.2 挂载用目录 [/media vs. /mnt]  234
7.3 自动挂载服务目录 [/misc]  236
总结 237
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux系统架构与目录解析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算架构技术与实践
第 1 章 云计算的商业动力与技术趋势 1
1.1 云计算基础概念与架构 2
1.2 云计算的商业动力：企业ICT转型 3
1.3 企业云计算的发展趋势 12
第 2 章 云计算的架构内涵与关键技术 19
2.1 云计算的总体架构 20
2.2 云计算架构关键技术 34
2.3 云计算核心架构竞争力衡量维度 47
2.4 云计算解决方案的典型服务与落地架构 51
第 3 章 云计算及大数据开源软件概览 65
3.1 OpenStack概述 66
3.2 容器开源软件：Kubernetes / Mesos / Docker 72
3.3 大数据开源软件：Hadoop/Spark 73
3.4 开源还是闭源 81
第 4 章 面向计算资源共享最大化和管理自动化的软件定义计算 83
4.1 XEN/KVM虚拟化引擎 84
4.2 基于OpenStack Nova的计算资源池调度算法 86
4.3 计算高可靠性保障 91
4.4 针对企业关键应用云化的虚拟化调优 92
4.5 基于OpenStack Ironic的裸金属服务 101
4.6 异构适配多种Hypervisor类型 106
第 5 章 面向应用敏捷化部署的Docker容器及其调度 108
5.1 容器典型应用场景 109
5.2 Docker容器关键技术 110
5.3 容器操作系统 112
5.4 Docker容器资源管理调度和应用编排 115
5.5 Docker容器与软件定义计算的集成 123
第 6 章 分布式软件定义存储概述 128
6.1 分布式软件定义存储 129
6.2 支持企业关键应用的软件定义块存储 135
6.3 传统存储SAN/NAS的管理整合及性能加速 142
6.4 分布式对象存储 143
6.5 面向云存储服务的QoS/SLA管理 148
6.6 分布式软件定义存储的Erasure Code，分布式重删压缩 149
第 7 章 面向自动化、多租户的软件定义网络 153
7.1 网络虚拟化的驱动力与关键需求 154
7.2 软件Overlay SDN网络，L2/L3网络 164
7.3 硬件Underlay SDN网络 170
7.4 软件化L4～L7网络功能 172
7.5 网络虚拟化端到端解决方案 176
第 8 章 无边界计算的混合云 186
8.1 混和云的驱动力与背景 187
8.2 典型的混合云架构模式 189
8.3 基于OpenStack级联的开放异构混合云 190
第 9 章 PaaS应用开发平台 193
9.1 PaaS简介 194
9.2 基于Docker的新型PaaS 195
9.3 消息中间件服务 198
9.4 数据库和缓存服务 200
9.5 大数据服务 201
第 10 章 大数据平台核心技术与架构 205
10.1 大数据特点与支撑技术 206
10.2 企业级Hadoop 208
10.3 流处理技术 220
10.4 大数据在金融领域的探索与实践 225
10.5 未来大数据应用畅想 230
第 11 章 企业桌面云接入的关键技术架构与应用 235
11.1 桌面云接入概述 236
11.2 桌面云接入的架构 239
11.3 桌面云接入的典型应用 239
11.4 桌面云接入的关键技术 244
11.5 面向多租户的企业桌面公有云服务 252
11.6 终端无关的移动办公接入 254
第 12 章 第三方云应用生态Marketplace及应用编排自动化 259
12.1 基于开放云平台的云生态系统构建 260
12.2 Marketplace系统架构 262
12.3 面向电信网络和业务云化的CT编排自动化-MANO 262
12.4 面向IT应用的IT编排自动化—— Heat & TOSCA 270
12.5 TOSCA(云应用的拓扑编排标准) 272
第 13 章 云微服务敏捷治理架构与组织流程 275
13.1 从瀑布式到敏捷式，从服务到微服务 276
13.2 微服务的治理架构 278
13.3 支撑敏捷开发与上线的微服务CI/CD工具链 286
13.4 面向微服务的DevOps研发运维组织变革 288
第 14 章 云安全架构与应用实践 290
14.1 端到端云安全架构 291
14.2 可信计算TPM/vTPM 294
14.3 虚拟机的安全隔离 298
14.4 虚拟化环境中的网络安全 300
14.5 云数据安全 301
14.6 公有云、私有云的安全组 303
14.7 云安全管理 304
14.8 安全即服务 306
14.9 云安全应用实施案例 306
14.10 云计算安全的其他考虑 307
14.11 云计算服务法律风险及其应对 308
缩略语 319
后 记 329
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算架构技术与实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>代码审计
代码审计：企业级web代码安全架构	I
前言	IV
导读	VI
致谢和感言	IX
目录	XI
第1章	代码审计环境搭建
1.1	wamp/wnmp环境搭建
1.2	lamp/lnmp环境搭建
1.3	PHP核心配置详解
第2章	审计辅助与漏洞验证工具
2.1	代码编辑器
2.1.1	notepad++
2.1.2	UltraEdit
2.1.3	Zend Studio
2.2	代码审计工具
2.2.1	Seay源码审计系统
2.2.2	Fortify SCA
2.2.3	RIPS
2.3	漏洞验证辅助
2.3.1	burp suite
2.3.2	浏览器扩展
2.3.3	编码转换及加解密工具
2.3.4	正则调试工具
2.3.5	SQL执行监控工具
第3章	通用代码审计思路
3.1	敏感函数回溯参数过程
3.1.1	espcms注入挖掘案例
3.2	通读全文代码
3.2.1	骑士cms通读审计案例
3.2.1.1	查看应用文件结构
3.2.1.2	查看关键文件代码
3.2.1.3	查看配置文件
3.2.1.4	跟读首页文件
3.3	根据功能点定向审计
3.3.1	Bugfree重装漏洞案例
第4章	漏洞挖掘与防范（基础篇）
4.1	SQL注入漏洞
4.1.1	挖掘经验
4.1.1.1	普通注入
4.1.1.2	编码注入
4.1.1.2.1	宽字节注入
4.1.1.2.2	二次urldecode注入
4.1.1.3	espcms搜索注入分析
4.1.2	漏洞防范
4.1.2.1	gpc/rutime魔术引号
4.1.2.2	过滤函数和类
4.1.2.2.1	addslashes函数
4.1.2.2.2	mysql_[real_]escape_string函数
4.1.2.2.3	intval等字符转换
4.1.2.3	PDO prepare预编译
4.2	XSS漏洞
4.2.1	挖掘经验
4.2.1.1	反射型XSS
4.2.1.2	存储型XSS
4.2.1.3	骑士CMS 存储型XSS分析
4.2.2	漏洞防范
4.2.2.1	特殊字符HTML实体转码
4.2.2.2	标签事件属性黑白名单
4.3	CSRF漏洞
4.3.1	挖掘经验
4.3.1.1	Discuz csrf备份拖库分析
4.3.2	漏洞防范
4.3.2.1	Token验证
4.3.2.2	验证码验证
第5章	漏洞挖掘与防范（进阶篇）
5.1	文件操作漏洞
5.1.1	文件包含漏洞
5.1.1.1	挖掘经验
5.1.1.2	本地文件包含
5.1.1.2.1	远程文件包含
5.1.1.2.2	文件包含截断
5.1.1.2.3	Metinfo文件包含漏洞分析
5.1.2	文件读取(下载)漏洞
5.1.2.1	挖掘经验
5.1.2.1.1	phpcms任意文件读取分析
5.1.3	文件上传漏洞
5.1.3.1	挖掘经验
5.1.3.1.1	未过滤或本地过滤
5.1.3.1.2	黑名单扩展名过滤
5.1.3.1.3	文件头、content-type验证绕过
5.1.3.1.4	phpcms任意文件上传分析
5.1.4	文件删除漏洞
5.1.4.1	挖掘经验
5.1.4.1.1	Metinfo任意文件删除分析
5.1.5	文件操作漏洞防范
5.1.5.1	通用文件操作防御
5.1.5.2	文件上传漏洞防范
5.2	代码执行漏洞
5.2.1	挖掘经验
5.2.1.1	代码执行函数
5.2.1.1.1	eval和assert函数
5.2.1.1.2	preg_replace函数
5.2.1.1.3	调用函数过滤不严
5.2.1.2	动态函数执行
5.2.1.3	Thinkphp代码执行漏洞分析
5.2.2	漏洞防范
5.3	命令执行漏洞
5.3.1	挖掘经验
5.3.1.1	命令执行函数
5.3.1.2	反引号命令执行
5.3.1.3	亿邮命令执行漏洞分析
5.3.2	漏洞防范
5.3.2.1	命令防注入函数
5.3.2.2	参数白名单
第6章	漏洞挖掘与防范（深入篇）
6.1	变量覆盖漏洞
6.1.1	挖掘经验
6.1.1.1	函数使用不当
6.1.1.1.1	extract函数
6.1.1.1.2	parse_str函数
6.1.1.1.3	import_request_variables函数
6.1.1.2	$$变量覆盖
6.1.1.3	Metinfo变量覆盖漏洞分析
6.1.2	漏洞防范
6.1.2.1	使用原始变量
6.1.2.2	验证变量存在
6.2	逻辑处理漏洞
6.2.1	挖掘经验
6.2.1.1	等于与存在判断绕过
6.2.1.1.1	in_array函数
6.2.1.1.2	is_numeric函数
6.2.1.1.3	双等于和三等于
6.2.1.2	账户体系中的越权漏洞
6.2.1.3	未exit或return引发的安全问题
6.2.1.4	常见支付漏洞
6.2.1.5	Ecshop逻辑错误注入分析
6.2.2	漏洞防范
6.3	会话认证漏洞
6.3.1	挖掘经验
6.3.1.1	Cookie认证安全
6.3.1.2	Espcms任意用户登录分析
6.3.2	漏洞防范
第7章	二次漏洞审计
7.1	什么是二次漏洞
7.2	二次漏洞审计技巧
7.3	dedecms二次注入漏洞分析
第8章	代码审计小技巧
8.1	钻GPC等转义的空子
8.1.1	不受GPC保护的全局变量
8.1.2	编码转换问题
8.2	神奇的字符串
8.2.1	字符处理函数报错信息泄露
8.2.2	字符串截断
8.2.2.1	%00空字符截断
8.2.2.2	iconv函数字符编码转换截断
8.3	php:// 输入输出流
8.4	PHP代码解析标签
8.5	FUZZ漏洞发现
8.6	不严谨的正则表达式
8.7	十余种MySQL报错注入
8.8	Windows FindFirstFile利用
8.9	PHP可变变量
第9章	参数的安全过滤
9.1	第三方过滤函数与类
9.1.1	discuz SQL安全过滤类分析
9.1.2	discuz xss标签过滤函数分析
9.2	内置过滤函数
第10章	使用安全的加密算法
10.1	对称加密
10.1.1	3DES加密
10.1.2	AES加密
10.2	非对称加密
10.2.1	RSA加密
10.3	单向加密
10.3.1	md5/sha1加密
第11章	业务功能安全设计
11.1	验证码
11.1.1	验证码绕过
11.1.2	验证码资源滥用
11.2	用户登录
11.2.1	撞库漏洞
11.2.2	API登录
11.3	用户注册
11.4	密码找回
11.5	资料查看与修改
11.6	投票/积分/抽奖
11.7	充值支付
11.8	私信及反馈
11.9	远程地址访问
11.10	文件管理
11.11	数据库管理
11.12	命令/代码执行
11.13	文件/数据库备份
11.14	API接口
第12章	应用安全体系建设
12.1	用户密码安全策略
12.2	前后台用户分表
12.3	后台地址隐藏
12.4	密码加密存储方式
12.5	登入限制
12.6	API站库分离
12.7	慎用第三方服务
12.8	严格的权限控制
12.9	敏感操作多因素验证
12.10	应用自身的安全中心
附录
网站推荐
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>代码审计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构解密：从分布式到微服务
第1章  大话分布式系统	1
1.1  IT争霸战	1
1.1.1  划时代的第一台计算机	1
1.1.2  IT界的恐龙时代	4
1.1.3  贵族的没落与平民的胜利	6
1.1.4  ARM新贵的爆发	10
1.1.5  超级计算机的绝地反击	11
1.2  分布式系统的开国元勋	13
1.3  分布式系统的基石：TCP/IP	17
1.4  从无奈到崛起的CDN网	19
1.5  这是一个最好的时代	21
第2章  “知识木桶”中的短板—— 网络基础	23
2.1  即使高手也不大懂的网络	23
2.2  NIO，一本难念的经	30
2.2.1  难懂的ByteBuffer	30
2.2.2  晦涩的“非阻塞”	39
2.2.3  复杂的Reactor模型	41
2.3  AIO，大道至简的设计与苦涩的现实	45
2.4  网络传输中的对象序列化问题	50
第3章  分布式系统的经典基础理论	55
3.1  从分布式系统的设计理念说起	55
3.2  分布式系统的一致性原理	58
3.3  分布式系统的基石之ZooKeeper	61
3.3.1  ZooKeeper的原理与功能	61
3.3.2  ZooKeeper的场景案例分析	65
3.4  经典的CA理论	69
3.5  BASE准则，一个影响深远的指导思想	72
3.6  重新认识分布式事务	73
3.6.1  数据库单机事务的实现原理	73
3.6.2  经典的X/OpenDTP事务模型	75
3.6.3  互联网中的分布式事务解决方案	78
第4章  聊聊RPC	83
4.1  从IPC通信说起	83
4.2  古老又有生命力的RPC	85
4.3  从RPC到服务治理框架	91
4.4  基于ZeroC Ice的微服务架构指南	94
4.4.1  微服务架构概述	95
4.4.2  ZeroC Ice微服务架构指南	100
第5章  深入浅析内存	107
5.1  你所不知道的内存知识	107
5.1.1  复杂的CPU与单纯的内存	107
5.1.2  多核CPU与内存共享的问题	110
5.1.3  著名的Cache伪共享问题	113
5.1.4  深入理解不一致性内存	115
5.2  内存计算技术的前世今生	118
5.3  内存缓存技术分析	123
5.3.1  缓存概述	123
5.3.2  缓存实现的几种方式	125
5.3.3  学习Memcache的内存管理技术	127
5.3.4  Redis的独特之处	129
5.4  内存计算产品分析	131
5.4.1  SAP HANA	131
5.4.2  Hazelcast	133
5.4.3  VoltDB	135
第6章  深入解析分布式存储	138
6.1  数据存储进化史	138
6.2  经典的网络文件系统NFS	145
6.3  高性能计算领域的分布式文件系统	148
6.4  企业级分布式文件系统GlusterFS	150
6.5  创新的Linux分布式存储系统—— Ceph	153
6.6  软件定义存储	160
第7章  聊聊分布式计算	166
7.1  不得不说的Actor模型	166
7.2  Actor原理与实践	170
7.3  初识Akka	177
7.4  适用面很广的Storm	185
7.5  MapReduce及其引发的新世界	194
第8章  全文检索与消息队列中间件	201
8.1  全文检索	201
8.1.1  什么是全文检索	201
8.1.2  起于Lucene	202
8.1.3  Solr	206
8.1.4  ElasticSearch	209
8.2  消息队列	217
8.2.1  消息队列概述	217
8.2.2  JEE专属的JMS	221
8.2.3  生生不息的ActiveMQ	226
8.2.4  RabbitMQ	231
8.2.5  Kafka	238
第9章  微服务架构	244
9.1  微服务架构概述	244
9.1.1  微服务架构兴起的原因	244
9.1.2  不得不提的容器技术	246
9.1.3  如何全面理解微服务架构	249
9.2  几种常见的微服务架构方案	253
9.2.1  ZeroC IceGrid微服务架构	253
9.2.2  Spring Cloud微服务架构	256
9.2.3  基于消息队列的微服务架构	259
9.2.4  Docker Swarm微服务架构	261
9.3  深入Kubernetes微服务平台	263
9.3.1  Kubernetes的概念与功能	263
9.3.2  Kubernetes的组成与原理	268
9.3.3  基于Kubernetes的PaaS平台	272
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构解密：从分布式到微服务
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算安全
推存序
译者序
译者简介
作者简介
前言第1章云计算和安全概述
1.1理解云计算
1.1.1云的规模、模式以及运营效率
1.1.2协同技巧
1.1.3弹性、变形和安全
1.2云的IT基础
1.2.1云计算作为云服务的基础
1.2.2云计算特性
1.3底线
1.4历史观点：云计算的起源
1.4.1分散与扩散
1.4.2网络、Internet及Web
1.4.3虚拟化
1.5安全简明读本：从5万英尺的高度
1.5.1术语和原则
1.5.2风险管理
1.5.3安全必须成为业务的推动力
1.6架构简明读本
1.6.1系统工程
1.6.2IT架构
1.7安全架构：简明讨论
1.8云推动广泛的变革
1.8.1现今的云工程
1.8.2有效关注
1.9总结
第2章云计算架构
2.1云参考架构
2.1.1重温基本特性
2.1.2云服务模式
2.1.3云部署模式
2.2云模式的安全控制
2.3了解云部署
2.3.1公共云
2.3.2私有云
2.3.3社区云
2.3.4混合云
2.4了解服务模式
2.4.1云软件即服务
2.4.2云平台即服务
2.4.3云基础设施即服务
2.5云是怎样构成的以及主要示例
2.5.1使用虚拟化构成云
2.5.2使用应用程序或服务构成云
2.6真实世界的云应用场景
2.6.1虚拟化构成的云
2.6.2应用程序/服务构成的云
2.6.3混合云模式
2.7总结
第3章安全顾虑、风险问题以及法律方面
3.1云计算：安全顾虑
3.1.1近距离观察：虚拟化
3.1.2近距离观察：服务开通
3.1.3近距离观察：云存储
3.1.4近距离观察：云运营、安全与网络
3.2评估你的云计算风险承受能力
3.2.1评估风险
3.2.2信息资产与风险
3.2.3隐私与保密性顾虑
3.2.4数据所有权与场所顾虑
3.2.5审计与取证
3.2.6新兴的威胁
3.2.7这样就安全了吗
3.3法律和监管问题
3.3.1第三方
3.3.2数据隐私
3.3.3诉讼
3.4总结
第4章云安全防护：架构
4.1架构的安全需求
4.1.1物理安全
4.1.2云安全标准和策略
4.1.3云安全需求
4.2安全模式和架构元素
4.2.1纵深防御
4.2.2蜜罐
4.2.3沙盒
4.2.4网络模式
4.2.5配置管理数据库的重要性
4.2.6线缆模式
4.2.7弹性与优雅
4.2.8为变化做规划
4.3云安全架构
4.3.1云成熟度以及它与安全的相关性
4.3.2Jericho论坛
4.3.3代表性的商业云架构
4.3.4代表性的云安全架构
4.4规划安全运营的关键战略
4.4.1将数据和系统分类
4.4.2定义云人员及客户的有效角色
4.5总结
第5章云安全防护：数据安全
5.1云计算数据安全综述
5.1.1数据控制与公共云经济
5.1.2机构责任：所有权与保管权
5.1.3静态数据
5.1.4动态数据
5.1.5云数据安全的常见风险
5.2数据加密：应用及限制
5.2.1密码技术综述
5.2.2数据加密的常见失误或错误
5.3云数据安全：敏感数据分类
5.3.1认证及身份
5.3.2访问控制技术
5.3.3数据分类以及数据标签的使用
5.3.4静态数据的加密应用
5.3.5动态数据的加密应用
5.3.6在云中加密技术的障碍
5.3.7数据删除
5.3.8数据屏蔽
5.4云数据存储
5.5云锁定
5.5.1元数据
5.5.2避免云锁定
5.6总结
第6章云安全防护：关键战略及最佳实践
6.1总战略：有效管理风险
6.2安全控制综述
6.2.1云安全控制必须符合你的需要
6.2.2美国标准与技术研究所对安全控制的定义
6.2.3非机密模式
6.2.4机密模式
6.2.5云安全联盟的方法
6.3安全控制的限制
6.3.1安全性暴露会随时间而变化
6.3.2漏洞攻击是不会光明正大进行的
6.4最佳实践
6.4.1云计算最佳实践：基本原理
6.4.2云社区的最佳实践
6.4.3云计算的其他最佳实践：云服务客户
6.4.4云计算的其他最佳实践：云服务提供商
6.5安全监测
6.5.1安全监测的目的
6.5.2转换事件流
6.5.3安全监测的保密性、完整性及可用性的需求
6.5.4MaaS的机遇
6.6总结
第7章安全标准：构建内部云
7.1私有云：动机和综述
7.1.1安全启示：共享资源与专用资源
7.1.2实现成本节约的考虑
7.1.3私有云：城堡要塞
7.1.4支持架构决定的分析
7.2确保私有云的安全标准
7.2.1网络考虑
7.2.2数据中心考虑
7.2.3运营安全考虑
7.2.4监管
7.3总结
第8章安全标准：选择外部云提供商
8.1选择云服务提供商：保证综述
8.1.1提供商的声明与独立验证
8.1.2选择云服务提供商：提供商的透明度
8.2选择CSP：风险综述
8.2.1风险会因客户和CSP而改变
8.2.2评估风险因素
8.3选择CSP：安全标准
8.3.1安全标准：重温纵深防御
8.3.2安全标准：其他考虑
8.3.3其他安全相关标准
8.4总结
第9章评估云安全：信息安全框架
9.1评估云安全
9.2评估云安全的清单
9.2.1基础安全
9.2.2业务考虑
9.2.3纵深防御
9.2.4运营安全
9.3清单指标
9.4总结
第10章云运营
10.1从架构到有效安全的运营
10.1.1规划的范围
10.1.2物理访问、安全以及持续成本
10.1.3逻辑和虚拟访问
10.1.4人员安全
10.1.5从物理环境到逻辑
10.1.6引导安全运营
10.1.7程序及流程随时间完善
10.1.8效率和成本
10.2安全运营活动
10.2.1服务器构建
10.2.2业务持续、备份与恢复
10.2.3运营环境中的变更管理
10.2.4信息安全管理
10.2.5漏洞和渗透测试
10.2.6安全监测与响应
10.2.7最佳实践
10.2.8运营弹性
10.3总结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算安全
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux内核深度解析
目　　录
第　1章 内核引导和初始化　1
1．1　到哪里读取引导程序　1
1．2　引导程序　1
1．2．1　入口_start　1
1．2．2　标号reset　2
1．2．3　函数_main　4
1．2．4　函数run_main_loop　6
1．3　内核初始化　8
1．3．1　汇编语言部分　8
1．3．2　C语言部分　11
1．3．3　SMP系统的引导　12
1．4　init进程　15
第　2章 进程管理　17
2．1　进程　17
2．2　命名空间　18
2．3　进程标识符　20
2．4　进程关系　21
2．5　启动程序　23
2．5．1　创建新进程　23
2．5．2　装载程序　41
2．6　进程退出　48
2．6．1　线程组退出　49
2．6．2　终止进程　51
2．6．3　查询子进程终止原因　53
2．7　进程状态　55
2．8　进程调度　55
2．8．1　调度策略　55
2．8．2　进程优先级　56
2．8．3　调度类　57
2．8．4　运行队列　59
2．8．5　任务分组　60
2．8．6　调度进程　65
2．8．7　调度时机　75
2．8．8　带宽管理　85
2．9　SMP调度　93
2．9．1　进程的处理器亲和性　93
2．9．2　对调度器的扩展　96
2．9．3　限期调度类的处理器负载均衡　96
2．9．4　实时调度类的处理器负载均衡　98
2．9．5　公平调度类的处理器负载均衡　99
2．9．6　迁移线程　108
2．9．7　隔离处理器　110
2．10　进程的安全上下文　111
第3章　内存管理　113
3．1　概述　113
3．2　虚拟地址空间布局　115
3．2．1　虚拟地址空间划分　115
3．2．2　用户虚拟地址空间布局　115
3．2．3　内核地址空间布局　121
3．3　物理地址空间　122
3．4　内存映射　124
3．4．1　应用编程接口　125
3．4．2　数据结构　129
3．4．3　创建内存映射　133
3．4．4　虚拟内存过量提交策略　137
3．4．5　删除内存映射　139
3．5　物理内存组织　140
3．5．1　体系结构　140
3．5．2　内存模型　140
3．5．3　三级结构　141
3．6　引导内存分配器　144
3．6．1　bootmem分配器　144
3．6．2　memblock分配器　145
3．6．3　物理内存信息　148
3．7　伙伴分配器　151
3．7．1　基本的伙伴分配器　151
3．7．2　分区的伙伴分配器　152
3．7．3　根据可移动性分组　158
3．7．4　每处理器页集合　162
3．7．5　分配页　163
3．7．6　释放页　181
3．8　块分配器　184
3．8．1　编程接口　185
3．8．2　SLAB分配器　186
3．8．3　SLUB分配器　197
3．8．4　SLOB分配器　204
3．9　不连续页分配器　207
3．9．1　编程接口　207
3．9．2　数据结构　208
3．9．3　技术原理　209
3．10　每处理器内存分配器　210
3．10．1　编程接口　210
3．10．2　技术原理　212
3．11　页表　219
3．11．1　统一的页表框架　219
3．11．2　ARM64处理器的页表　222
3．12　页表缓存　226
3．12．1　TLB表项格式　226
3．12．2　TLB管理　226
3．12．3　地址空间标识符　228
3．12．4　虚拟机标识符　232
3．13　巨型页　233
3．13．1　处理器对巨型页的支持　233
3．13．2　标准巨型页　235
3．13．3　透明巨型页　245
3．14　页错误异常处理　257
3．14．1　处理器架构特定部分　257
3．14．2　用户空间页错误异常　266
3．14．3　内核模式页错误异常　283
3．15　反碎片技术　288
3．15．1　虚拟可移动区域　289
3．15．2　内存碎片整理　291
3．16　页回收　309
3．16．1　数据结构　310
3．16．2　发起页回收　317
3．16．3　计算扫描的页数　320
3．16．4　收缩活动页链表　321
3．16．5　回收不活动页　323
3．16．6　页交换　325
3．16．7　回收slab缓存　335
3．17　内存耗尽杀手　338
3．17．1　使用方法　338
3．17．2　技术原理　338
3．18　内存资源控制器　340
3．18．1　使用方法　340
3．18．2　技术原理　344
3．19　处理器缓存　370
3．19．1　缓存结构　370
3．19．2　缓存策略　372
3．19．3　缓存维护　374
3．19．4　SMP缓存一致性　378
3．19．5　利用缓存提高性能的编程技巧　383
3．20　连续内存分配器　384
3．20．1　使用方法　385
3．20．2　技术原理　386
3．21　userfaultfd　391
3．21．1　使用方法　391
3．21．2　技术原理　395
3．22　内存错误检测工具KASAN　401
3．22．1　使用方法　401
3．22．2　技术原理　402
第4章　中断、异常和系统调用　403
4．1　ARM64异常处理　403
4．1．1　异常级别　403
4．1．2　异常分类　404
4．1．3　异常向量表　405
4．1．4　异常处理　407
4．2　中断　411
4．2．1　中断控制器　412
4．2．2　中断域　413
4．2．3　中断控制器驱动初始化　415
4．2．4　Linux中断处理　422
4．2．5　中断线程化　428
4．2．6　禁止/开启中断　430
4．2．7　禁止/开启单个中断　431
4．2．8　中断亲和性　431
4．2．9　处理器间中断　432
4．3　中断下半部　434
4．3．1　软中断　435
4．3．2　小任务　441
4．3．3　工作队列　444
4．4　系统调用　457
4．4．1　定义系统调用　457
4．4．2　执行系统调用　459
第5章　内核互斥技术　463
5．1　信号量　464
5．2　读写信号量　465
5．3　互斥锁　466
5．4　实时互斥锁　467
5．5　原子变量　468
5．6　自旋锁　472
5．7　读写自旋锁　476
5．8　顺序锁　478
5．8．1　完整版的顺序锁　479
5．8．2　只提供序列号的顺序锁　481
5．9　禁止内核抢占　482
5．10　进程和软中断互斥　483
5．11　进程和硬中断互斥　483
5．12　每处理器变量　484
5．12．1　静态每处理器变量　484
5．12．2　动态每处理器变量　484
5．12．3　访问每处理器变量　485
5．13　每处理器计数器　485
5．14　内存屏障　487
5．14．1　编译器屏障　488
5．14．2　处理器内存屏障　489
5．14．3　MMIO写屏障　492
5．14．4　隐含内存屏障　493
5．14．5　ARM64处理器内存屏障　493
5．15　RCU　495
5．15．1　使用方法　496
5．15．2　技术原理　504
5．16　可睡眠RCU　533
5．16．1　使用方法　533
5．16．2　技术原理　534
5．17　死锁检测工具lockdep　542
5．17．1　使用方法　543
5．17．2　技术原理　543
第6章　文件系统　548
6．1　概述　548
6．1．1　用户空间层面　549
6．1．2　硬件层面　549
6．1．3　内核空间层面　550
6．2　虚拟文件系统的数据结构　552
6．2．1　超级块　552
6．2．2　挂载描述符　554
6．2．3　文件系统类型　555
6．2．4　索引节点　556
6．2．5　目录项　559
6．2．6　文件的打开实例和打开文件表　561
6．3　注册文件系统类型　563
6．4　挂载文件系统　564
6．4．1　系统调用mount　566
6．4．2　绑定挂载　567
6．4．3　挂载命名空间　568
6．4．4　挂载根文件系统　574
6．5　打开文件　580
6．5．1　编程接口　580
6．5．2　技术原理　582
6．6　关闭文件　591
6．7　创建文件　593
6．7．1　使用方法　593
6．7．2　技术原理　594
6．8　删除文件　595
6．8．1　使用方法　595
6．8．2　技术原理　595
6．9　设置文件权限　597
6．9．1　使用方法　597
6．9．2　技术原理　598
6．10　页缓存　599
6．10．1　地址空间　600
6．10．2　基数树　601
6．10．3　编程接口　602
6．11　读文件　602
6．11．1　编程接口　602
6．11．2　技术原理　603
6．12　写文件　606
6．12．1　编程接口　606
6．12．2　技术原理　607
6．13　文件回写　610
6．13．1　编程接口　610
6．13．2　技术原理　610
6．14　DAX　618
6．14．1　使用方法　618
6．14．2　技术原理　618
6．15　常用的文件系统类型　621
结束语　622
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux内核深度解析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解TensorFlow：架构设计与实现原理
第 一部分　基础篇
第　1章 TensorFlow系统概述　2
1.1　简介　2
1.1.1　产生背景　2
1.1.2　独特价值　3
1.1.3　版本变迁　4
1.1.4　与其他主流深度学习框架的对比　6
1.2　设计目标　7
1.2.1　灵活通用的深度学习库　8
1.2.2　端云结合的人工智能引擎　9
1.2.3　高性能的基础平台软件　10
1.3　基本架构　12
1.3.1　工作形态　12
1.3.2　组件结构　13
1.4　小结　14
第　2章 TensorFlow环境准备　15
2.1　安装　15
2.1.1　TensorFlow安装概述　15
2.1.2　使用Anaconda安装　17
2.1.3　使用原生pip安装　17
2.1.4　使用virtualenv安装　18
2.1.5　使用Docker安装　19
2.1.6　使用源代码编译安装　20
2.1.7　Hello TensorFlow　22
2.2　依赖项　23
2.2.1　Bazel软件构建工具　24
2.2.2　Protocol Buffers数据结构序列化工具　25
2.2.3　Eigen线性代数计算库　27
2.2.4　CUDA统一计算设备架构　28
2.3　源代码结构　29
2.3.1　根目录　29
2.3.2　tensorflow目录　30
2.3.3　tensorflow/core目录　31
2.3.4　tensorflow/python目录　32
2.3.5　安装目录　33
2.4　小结　33
第3章　TensorFlow基础概念　34
3.1　编程范式：数据流图　34
3.1.1　声明式编程与命令式编程　34
3.1.2　声明式编程在深度学习应用上的优势　35
3.1.3　TensorFlow数据流图的基本概念　38
3.2　数据载体：张量　40
3.2.1　张量：Tensor　40
3.2.2　稀疏张量：SparseTensor　44
3.3　模型载体：操作　46
3.3.1　计算节点：Operation　46
3.3.2　存储节点：Variable　49
3.3.3　数据节点：Placeholder　53
3.4　运行环境：会话　55
3.4.1　普通会话：Session　55
3.4.2　交互式会话：InteractiveSession　59
3.4.3　扩展阅读：会话实现原理　59
3.5　训练工具：优化器　61
3.5.1　损失函数与优化算法　61
3.5.2　优化器概述　64
3.5.3　使用minimize方法训练模型　66
3.5.4　扩展阅读：模型训练方法进阶　68
3.6　一元线性回归模型的最佳实践　72
3.7　小结　76
第二部分　关键模块篇
第4章　TensorFlow数据处理方法　78
4.1　输入数据集　78
4.1.1　使用输入流水线并行读取数据　78
4.1.2　创建批样例数据的方法　86
4.1.3　填充数据节点的方法　87
4.1.4　处理CIFAR-10数据集的最佳实践　88
4.1.5　扩展阅读：MNIST数据集　91
4.2　模型参数　92
4.2.1　模型参数的典型使用流程　92
4.2.2　使用tf.Variable创建、初始化和更新模型参数　92
4.2.3　使用tf.train.Saver保存和恢复模型参数　98
4.2.4　使用变量作用域处理复杂模型　100
4.3　命令行参数　103
4.3.1　使用argparse解析命令行参数　103
4.3.2　使用tf.app.flags解析命令行参数　108
4.4　小结　111
第5章　TensorFlow编程框架　112
5.1　单机程序编程框架　112
5.1.1　概述　112
5.1.2　创建单机数据流图　114
5.1.3　创建并运行单机会话　116
5.2　分布式程序编程框架　118
5.2.1　PS-worker架构概述　118
5.2.2　分布式程序编程框架概述　120
5.2.3　创建TensorFlow集群　121
5.2.4　将操作放置到目标设备　124
5.2.5　数据并行模式　124
5.2.6　同步训练机制　125
5.2.7　异步训练机制　130
5.2.8　使用Supervisor管理模型训练　131
5.2.9　分布式同步训练的最佳实践　133
5.3　小结　137
第6章　TensorBoard可视化工具　138
6.1　概述　138
6.2　可视化数据流图　142
6.2.1　名字作用域与抽象节点　142
6.2.2　可视化数据流图的最佳实践　144
6.2.3　扩展阅读：汇总数据和事件数据　145
6.2.4　扩展阅读：揭秘tf.summary.FileWriter工作原理　147
6.3　可视化学习过程　149
6.3.1　汇总操作概述　149
6.3.2　使用tf.summary.scalar生成折线图　150
6.3.3　使用tf.summary.histogram生成数据分布图　152
6.3.4　使用tf.summary.image生成图像　154
6.3.5　使用tf.summary.audio生成音频　155
6.3.6　可视化MNIST softmax模型学习过程的最佳实践　156
6.4　可视化高维数据　158
6.4.1　使用TensorBoard可视化高维数据　158
6.4.2　可视化MNIST数据集的最佳实践　160
6.5　小结　163
第7章　模型托管工具：TensorFlow Serving　164
7.1　概述　164
7.2　系统架构　165
7.3　安装　167
7.3.1　使用APT安装ModelServer　168
7.3.2　使用源码编译安装ModelServer　169
7.4　最佳实践　170
7.4.1　导出模型　170
7.4.2　发布模型服务　173
7.4.3　更新线上模型服务　174
7.5　小结　175
第三部分　算法模型篇
第8章　深度学习概述　178
8.1　深度学习的历史　178
8.1.1　感知机模型与神经网络　178
8.1.2　神经网络的寒冬与复苏　179
8.1.3　神经网络的发展与第二次寒冬　181
8.1.4　深度学习时代的到来　183
8.2　深度学习的主要应用　184
8.2.1　计算机视觉　185
8.2.2　自然语言处理　186
8.2.3　强化学习　188
8.3　深度学习与TensorFlow　190
8.4　小结　191
第9章　CNN模型　192
9.1　CNN　192
9.1.1　CNN简介　192
9.1.2　卷积层　193
9.1.3　激活层　195
9.1.4　池化层　195
9.1.5　全连接层　196
9.1.6　Dropout层　196
9.1.7　BN层　197
9.1.8　常用的CNN图像分类模型　197
9.2　TensorFlow-Slim　204
9.2.1　TensorFlow-Slim总体结构　204
9.2.2　datasets包和data包　205
9.2.3　preprocessing包　207
9.2.4　deployment包　207
9.2.5　nets包　209
9.2.6　TensorFlow-Slim最佳实践　212
9.3　应用　216
9.3.1　物体检测　216
9.3.2　图像分割　221
9.4　小结　222
第　10章 GAN模型　223
10.1　原理、特点及应用　223
10.1.1　原理　224
10.1.2　特点　225
10.1.3　应用　226
10.2　GAN模型的改进　228
10.2.1　CGAN模型　228
10.2.2　LAPGAN模型　229
10.2.3　DCGAN模型　230
10.2.4　InfoGAN模型　230
10.2.5　LSGAN模型　231
10.2.6　WGAN模型　232
10.3　最佳实践　233
10.4　小结　238
第　11章 RNN模型　239
11.1　基本RNN单元及其变种　239
11.1.1　RNN模型简介　239
11.1.2　基本RNN单元　240
11.1.3　LSTM单元　242
11.1.4　GRU单元　243
11.1.5　双向RNN单元　244
11.1.6　带有其他特性的RNN单元　245
11.2　RNN模型　247
11.2.1　PTB-LSTM语言模型　247
11.2.2　Seq2Seq模型　251
11.3　小结　254
第四部分　核心揭秘篇
第　12章 TensorFlow运行时核心设计与实现　256
12.1　运行时框架概述　256
12.2　关键数据结构　257
12.2.1　张量相关数据结构　258
12.2.2　设备相关数据结构　260
12.2.3　数据流图相关的数据结构　263
12.3　公共基础机制　266
12.3.1　内存分配　266
12.3.2　线程管理　268
12.3.3　多语言接口　269
12.3.4　XLA编译技术　270
12.3.5　单元测试框架　271
12.4　外部环境接口　272
12.4.1　加速器硬件接口　272
12.4.2　系统软件接口　275
12.5　小结　276
第　13章 通信原理与实现　277
13.1　概述　277
13.2　进程内通信　278
13.2.1　通信接口　278
13.2.2　会合点机制　280
13.2.3　异构设备内存访问　282
13.3　进程间通信　283
13.3.1　gRPC通信机制　284
13.3.2　控制通信　286
13.3.3　数据通信　290
13.4　RDMA通信模块　294
13.4.1　模块结构　295
13.4.2　消息语义　296
13.4.3　通信流程　297
13.5　小结　300
第　14章 数据流图计算原理与实现　301
14.1　概述　301
14.2　数据流图创建　302
14.2.1　流程与抽象　303
14.2.2　全图构造　305
14.2.3　子图提取　306
14.2.4　图切分　307
14.2.5　图优化　308
14.3　单机会话运行　308
14.3.1　流程与抽象　309
14.3.2　执行器获取　311
14.3.3　输入数据填充　312
14.3.4　图运行　313
14.3.5　输出数据获取　315
14.3.6　张量保存　315
14.4　分布式会话运行　315
14.4.1　主-从模型　316
14.4.2　主要抽象　317
14.4.3　client创建会话　319
14.4.4　client请求图运行　320
14.4.5　master驱动图运行　321
14.4.6　worker实施图运行　323
14.5　操作节点执行　325
14.5.1　核函数抽象　325
14.5.2　CPU上的执行流程　326
14.5.3　CUDA GPU上的执行流程　326
14.6　小结　327
第五部分　生态发展篇
第　15章 TensorFlow生态环境　330
15.1　生态环境概况　330
15.1.1　社区托管组件　330
15.1.2　第三方项目　333
15.2　深度神经网络库Keras　334
15.2.1　概述　334
15.2.2　模型概述　335
15.2.3　顺序模型　336
15.2.4　函数式模型　338
15.3　TensorFlow与Kubernetes生态的结合　340
15.4　TensorFlow与Spark生态的结合　344
15.5　TensorFlow通信优化技术　345
15.6　TPU及神经网络处理器　348
15.7　NNVM模块化深度学习组件　349
15.8　TensorFlow未来展望——TFX　351
15.9　小结　353
附录A　354
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解TensorFlow：架构设计与实现原理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>演进式架构
序　　ix
前言　　xi
第1章　软件架构　　1
1.1　演进式架构　　2
1.1.1　一切都在变化，如何才能长期规划　　3
1.1.2　完成架构构建后，如何防止它逐渐退化　　4
1.2　增量变更　　5
1.3　引导性变更　　6
1.4　多个架构维度　　6
1.5　康威定律　　8
1.6　为何演进　　10
1.7　小结　　11
第2章　适应度函数　　13
2.1　什么是适应度函数　　15
2.2　适应度函数分类　　16
2.2.1　原子适应度函数与整体适应度函数　　16
2.2.2　触发式适应度函数与持续式适应度函数　　16
2.2.3　静态适应度函数与动态适应度函数　　17
2.2.4　自动适应度函数与手动适应度函数　　17
2.2.5　临时适应度函数　　18
2.2.6　预设式高于应急式　　18
2.2.7　针对特定领域的适应度函数　　18
2.3　尽早确定适应度函数　　18
2.4　审查适应度函数　　19
第3章　实施增量变更　　21
3.1　构件　　24
3.1.1　可测试性　　25
3.1.2　部署流水线　　26
3.1.3　组合不同类型的适应度函数　　30
3.1.4　案例研究：在每天部署60次的情况下重建架构　　31
3.1.5　目标冲突　　33
3.1.6　案例研究：为PenultimateWidgets的发票服务添加适应度函数　　33
3.2　假设驱动开发和数据驱动开发　　36
3.3　案例研究：移植什么　　37
第4章　架构耦合　　39
4.1　模块化　　39
4.2　架构的量子和粒度　　40
4.3　不同类型架构的演进能力　　42
4.3.1　大泥团架构　　42
4.3.2　单体架构　　44
4.3.3　事件驱动架构　　49
4.3.4　服务导向架构　　53
4.3.5　“无服务”架构　　62
4.4　控制架构量子大小　　63
4.5　案例分析：防止组件循环依赖　　64
第5章　演进式数据　　67
5.1　演进式数据库设计　　67
5.1.1　数据库模式演进　　67
5.1.2　共享数据库集成　　69
5.2　不当的数据耦合　　73
5.2.1　二阶段提交事务　　74
5.2.2　数据的年龄和质量　　75
5.3　案例研究：PenultimateWidgets的路由演进　　76
第6章　构建可演进的架构　　79
6.1　演进机制　　79
6.1.1　识别受演进影响的架构维度　　79
6.1.2　为每个维度定义适应度函数　　80
6.1.3　使用部署流水线自动化适应度函数　　80
6.2　全新的项目　　80
6.3　改良现有架构　　81
6.3.1　适当的耦合和内聚　　81
6.3.2　工程实践　　81
6.3.3　适应度函数　　82
6.3.4　关于商业成品软件　　82
6.4　架构迁移　　83
6.4.1　迁移步骤　　84
6.4.2　演进模块间的交互　　86
6.5　演进式架构构建指南　　89
6.5.1　去除不必要的可变性　　89
6.5.2　让决策可逆　　91
6.5.3　演进优于预测　　91
6.5.4　构建防腐层　　92
6.5.5　案例分析：服务模板　　93
6.5.6　构建可牺牲架构　　94
6.5.7　应对外部变化　　95
6.5.8　更新库与更新框架　　97
6.5.9　持续交付优于快照　　97
6.5.10　服务内部版本化　　98
6.6　案例分析：PenultimateWidgets的评分服务演进　　99
第7章　演进式架构的陷阱和反模式　　103
7.1　技术架构　　103
7.1.1　反模式：供应商为王　　103
7.1.2　陷阱：抽象泄漏　　104
7.1.3　反模式：最后10%的陷阱　　107
7.1.4　反模式：代码复用和滥用　　108
7.1.5　案例研究：PenultimateWidgets中的复用　　109
7.1.6　陷阱：简历驱动开发　　110
7.2　增量变更　　111
7.2.1　反模式：管理不当　　111
7.2.2　案例研究：PenultimateWidgets的“金发姑娘”管理　　112
7.2.3　陷阱：发布过慢　　113
7.3　业务问题　　114
7.3.1　陷阱：产品定制　　114
7.3.2　反模式：报表　　115
7.3.3　陷阱：规划视野　　116
第8章　实践演进式架构　　119
8.1　组织因素　　119
8.1.1　全功能团队　　119
8.1.2　围绕业务能力组织团队　　121
8.1.3　产品高于项目　　121
8.1.4　应对外部变化　　122
8.1.5　团队成员间的连接数　　123
8.2　团队的耦合特征　　124
8.2.1　文化　　124
8.2.2　试验文化　　125
8.3　首席财务官和预算　　126
8.4　构建企业适应度函数　　128
8.5　从何开始　　129
8.5.1　容易实现的目标　　129
8.5.2　最高价值优先　　129
8.5.3　测试　　129
8.5.4　基础设施　　130
8.5.5　PenultimateWidgets的企业架构师　　131
8.6　演进式架构的未来　　131
8.6.1　基于AI的适应度函数　　132
8.6.2　生成式测试　　132
8.7　为什么（不）呢　　132
8.7.1　公司为何决定构建演进式架构　　132
8.7.2　案例分析：PenultimateWidgets选择性伸展　　134
8.7.3　企业为何选择不构建演进式架构　　135
8.7.4　说服他人　　136
8.7.5　案例分析：“咨询柔道”　　136
8.8　商业案例　　136
8.8.1　未来已来……　　136
8.8.2　没有后顾之忧地快速前行　　137
8.8.3　风险更低　　137
8.8.4　新能力　　137
8.9　构建演进式架构　　137
关于作者　　139
封面介绍　　140
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>演进式架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>多核应用架构关键技术
译者序
序
前言
第一部分 管道理论
第1章 并行计算与商业应用 2
1.1 机械式解决方案：操作系统级
1.1 的并行计算方式 3
1.1.1 对称多处理 3
1.1.2 集群 3
1.2 自动化网络路由：预定逻辑下的
1.1 并行计算 3
1.3 网格计算：分布式并行计算 4
1.4 商业应用的并行计算 4
1.5 解决方案：软件管道 5
1.6 流体动力学 6
1.7 软件管道示例 7
1.8 小结 10
第2章 管道定律 11
2.1 CPU资源浪费问题 11
2.2 流体动力学 11
.2.3 管道定律：基本法则 12
2.4 推论1：流量限制 12
2.5 推论2：输出流的约束 13
2.6 软件管道规则 14
2.7 规则1 14
2.8 规则2 15
2.9 规则3 17
2.10 小结 20
第3章 管道示例 21
3.1 银行ATM系统（单层分布） 21
3.1.1 管道 21
3.1.2 管道分配器 22
3.2 银行ATM系统（多层分布） 23
3.2.1 下层管道层 24
3.2.2 上层管道层 27
3.3 小结 28
第4章 管道模式 30
4.1 服务调用模式 31
4.1.1 推模式 31
4.1.2 拉模式 31
4.2 消息交换模式 32
4.2.1 一路交换模式 32
4.2.2 请求—应答模式 33
4.3 管道路由模式 34
4.3.1 轮循路由模式 34
4.3.2 基于内容的路由模式 35
4.3.3 定制路由模式 36
4.3.4 加入模式 36
4.4 分配器模式 37
4.4.1 单一分配器模式 37
4.4.2 多层分配器模式 38
4.4.3 客户端分配器模式 39
4.4.4 数据库分片分配器模式 40
4.5 分配器连接器模式 40
4.5.1 本地方法调用模式 41
4.5.2 Socket调用模式 41
4.5.3 Web服务调用模式 41
4.5.4 其他模式 42
4.6 小结 42
第5章 管道：公司的影响 43
5.1 战略评估 43
5.2 预算影响 44
5.3 公司职位与责任 46
5.3.1 管道架构师 46
5.3.2 业务部门领导骨干 47
5.3.3 IT部门管理人员 48
5.3.4 应用开发人员 49
5.3.5 应用项目管理者 50
5.3.6 质量保证管理者 50
5.3.7 IT运营部 51
5.4 小结 51
第二部分 管道方法学
第6章 软件管道优化周期：概述 54
6.1 另一种软件方法学 54
6.2 SPOC概述 54
第7章 SPOC的5个步骤 56
7.1 软件管道优化周期文档 56
7.2 小结 57
第8章 管道示例：管道银行公司
第8章 介绍 58
8.1 SPOC报告模板 60
8.2 小结 61
第9章 SPOC第一步：管道目标 62
9.1 步骤1.1：确定业务目标/需求 63
9.2 步骤1.2：确定输入处理率 66
9.3 步骤1.3：检测未来潜在的输入
9.3 处理速率 67
9.4 步骤1.4：当前处理能力
9.3 的测定 69
9.5 步骤1.5：计算性能差距 70
9.6 步骤1.6：定义管道目标 71
9.7 小结 72
第10章 SPOC步骤2：管道分析 73
10.1 步骤2.1：映射目前处理流程 74
10.2 步骤2.2：确定现有的组件 76
10.3 步骤2.3：测定现有组件的
10.3 处理速率 77
10.4 步骤2.4：计算整个流程的
10.3 处理速率 79
10.5 步骤2.5：确定约束点 80
10.6 小结 81
第11章 SPOC步骤3：管道设计 82
11.1 步骤3.1：定义服务流程
11.1 设计 83
11.2 步骤3.2：确定新的组件 86
11.3 步骤3.3：确定管道化时机 87
11.4 步骤3.4：确定管道方案 89
11.5 步骤3.5：确定分配器
10.3 处理速率 93
11.6 步骤3.6：物理部署环境
10.3 的设计 94
11.7 步骤3.7：确定/优化管道
11.7 设计 95
11.8 小结 104
第12章 SPOC步骤4：管道实现 105
12.1 步骤4.1：构建软件管道框架 106
12.2 步骤4.2：修改现有的组件 107
12.3 步骤4.3：开始新的组件 109
12.4 步骤4.4：编排服务流程 110
12.5 步骤4.5：仪表化服务流程 112
12.6 步骤4.6：开发/修改管道
10.3 套件 112
12.7 步骤4.7：测试并优化
10.3 管道实现 119
12.8 小结 120
第13章 SPOC步骤5：管道部署 121
13.1 步骤5.1：规划管道部署 122
13.2 步骤5.2：部署到产品
10.3 环境中 122
13.3 步骤5.3：检测产品环境 123
13.4 步骤5.4：评估结果，规划下
10.3 一次SPOC迭代过程 124
13.5 小结 124
第三部分 管道示例
第14章 Hello软件管道 126
14.1 定义消息 126
14.2 构建服务 127
14.3 配置分配器 129
14.4 创建客户端 130
14.5 运行服务 133
14.6 小结 133
第15章 扩展Hello软件管道 134
15.1 扩展服务 134
15.2 开发可扩展的测试客户端 135
15.3 运行服务 138
15.4 小结 142
第16章 增加的管道路由器配置 143
16.1 基于内容的路由器 143
16.2 定制管道路由器 152
16.3 小结 163
第17章 从Hello软件管道
第22章 获得应答 164
17.1 请求——响应消息传递 164
17.2 在Hello软件管道中使用
10.3 请求——响应 167
17.3 小结 177
第18章 增添的分配器连接器模式 178
18.1 定义并配置连接器 178
18.2 Socket连接器 180
18.3 Web服务连接器 181
18.4 小结 183
第19章 使用多层分配器 184
19.1 配置多层分配器 184
19.2 创建客户端 188
19.3 运行服务 190
19.4 小结 191
第20章 数据库分片分配器 192
20.1 数据库分片示例 193
20.2 创建数据库分片 194
20.3 构建服务 194
20.4 配置分配器 197
20.5 配置分片驱动 198
20.6 创建客户端 199
20.7 执行服务 201
20.8 小结 202
第21章 管道框架概要 203
21.1 接口概要 203
21.2 管道工具 205
21.3 小结 211
第22章 管道银行公司（PBCOR）
第22章 示例 212
22.1 账户交易事务 213
22.2 管道配置信息 215
22.3 Spring框架 218
22.4 数据库访问 219
22.5 连接服务 225
22.6 运行测试 229
22.7 小结 230
第四部分 软件管道的未来
第23章 软件管道的未来 232
23.1 最后的建议 232
23.2 未来的一些想法 233
附录 管道参考架构Javadoc 235
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>多核应用架构关键技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构大数据——大数据技术及算法解析
第1章 大数据技术概述	1
1.1 大数据的概念	1
1.2 大数据的行业价值	4
1.3 大数据问题的爆发	9
1.4 大数据处理流程	12
1.5 大数据技术	13
1.5.1 基础架构支持	14
1.5.2 数据采集	14
1.5.3 数据存储	15
1.5.4 数据计算	16
1.5.5 展现与交互	18
1.6 练习题	19
参考文献	19
第2章 大数据基础支撑——数据中心及云计算	20
2.1 数据中心概述	20
2.1.1 云计算时代数据中心面临的问题	21
2.1.2 新一代数据中心关键技术	22
2.1.3 业界发展动态	24
2.1.4 小结	25
2.2 云计算简介	25
2.2.1 云计算定义	26
2.2.2 云计算主要特征	27
2.2.3 Web服务、网格和云计算	28
2.2.4 云计算应用分类	29
2.2.5 小结	31
2.3 大数据与云计算的关系	32
2.3.1 大数据是信息技术发展的必然阶段	33
2.3.2 云计算等新兴信息技术正在真正地落地和实施	34
2.3.3 云计算等新兴技术是解决大数据问题的核心关键	34
2.4 云资源调度与管理	35
2.4.1 云资源管理	36
2.4.2 云资源调度策略	38
2.4.3 云计算数据中心负载均衡调度	40
2.5 开源云管理平台OpenStack	44
2.5.1 OpenStack的构成	45
2.5.2 OpenStack各组件之间的关系	46
2.5.3 OpenStack的逻辑架构	47
2.5.4 小结	49
2.6 软件定义网络	49
2.6.1 起源与发展	50
2.6.2 OpenFlow标准和规范	50
2.6.3 OpenFlow的应用	53
2.7 虚拟机与容器	55
2.7.1 VM虚拟化与Container虚拟化	55
2.7.2 Docker	55
2.8 练习题	57
参考文献	57
第3章 云计算先行者——Google的三驾马车	59
3.1 Google的三驾马车	59
3.1.1 GFS——一个可扩展的分布式文件系统	59
3.1.2 MapReduce——一种并行计算的编程模型	64
3.1.3 BigTable——一个分布式数据存储系统	69
3.2 Google新“三驾马车”	77
3.2.1 Caffeine——基于Percolator的搜索索引系统	77
3.2.2 Pregel——高效的分布式图计算的计算框架	80
3.2.3 Dremel——大规模数据的交互式数据分析系统	85
3.3 练习题	89
参考文献	89
第4章 云存储系统	91
4.1 云存储的基本概念	91
4.1.1 云存储结构模型	91
4.1.2 云存储与传统存储系统的区别	94
4.2 云存储关键技术	95
4.2.1 存储虚拟化技术	95
4.2.2 分布式存储技术	97
4.3 云存储系统分类	98
4.3.1 分布式文件存储	99
4.3.2 分布式块存储	105
4.3.3 分布式对象存储	109
4.3.4 统一存储	117
4.4 其他相关技术	124
4.5 练习题	127
参考文献	127
第5章 数据采集系统	129
5.1 Flume	130
5.1.1 Flume架构	130
5.1.2 Flume核心组件	133
5.1.3 Flume环境搭建与部署	134
5.2 Scribe	139
5.2.1 Scribe架构	139
5.2.2 Scribe中的Store	140
5.2.3 Scribe环境搭建与部署	141
5.3 Chukwa	144
5.3.1 Chukwa的设计目标	144
5.3.2 Chukwa架构	145
5.3.3 Chukwa 环境搭建与部署	147
5.4 Kafka	150
5.4.1 Kafka架构	150
5.4.2 Kafka存储	152
5.4.3 Kafka的特点	152
5.4.4 Kafka环境搭建与部署	154
5.5 练习题	155
参考文献	155
第6章 Hadoop与MapReduce	156
6.1 Hadoop平台	156
6.1.1 Hadoop概述	156
6.1.2 Hadoop的发展简史	157
6.1.3 Hadoop的功能和作用	158
6.1.4 HDFS	159
6.1.5 HBase	162
6.2 MapReduce	171
6.2.1 第一代MapReduce（MRv1）	172
6.2.2 MapReduce 2.0——Yarn	180
6.3 Hadoop相关生态系统	184
6.3.1 交互式数据查询分析	184
6.3.2 数据收集、转换工具	187
6.3.3 机器学习工具	188
6.3.4 集群管理与监控	188
6.3.5 其他工具	189
6.4 Hadoop应用案例	191
6.5 练习题	192
参考文献	192
第7章 Spark——大数据统一计算平台	193
7.1 Spark简介	193
7.1.1 Spark	193
7.1.2 BDAS	195
7.2 RDD	197
7.2.1 RDD基本概念	197
7.2.2 RDD示例	199
7.2.3 RDD与分布式共享内存	200
7.3 Spark SQL	201
7.4 MLlib	203
7.5 GraphX	206
7.6 Spark Streaming	206
7.6.1 基本概念	207
7.6.2 编程模型	208
7.7 Spark的安装	210
7.7.1 单机运行Spark	210
7.7.2 使用Spark Shell与Spark交互	213
7.8 Shark、Impala、Hive对比	214
7.9 练习题	216
参考文献	216
第8章 Storm流计算系统	218
8.1 流计算系统	218
8.1.1 流计算系统的特点	218
8.1.2 流计算处理基本流程	219
8.2 Storm流计算框架	220
8.2.1 Storm简介	220
8.2.2 Storm关键术语	221
8.2.3 Storm架构设计	223
8.3 Storm编程实例	225
8.4 Storm应用	228
8.4.1 Storm应用场景	228
8.4.2 Storm应用实例	228
8.5 其他流计算框架	229
8.6 练习题	231
参考文献	231
第9章 SQL、NoSQL与NewSQL	232
9.1 传统SQL数据库	232
9.1.1 关系模型	232
9.1.2 关系型数据库的优点	233
9.1.3 关系型数据库面临的问题	234
9.2 NoSQL	234
9.2.1 NoSQL与大数据	235
9.2.2 NoSQL理论基础	235
9.2.3 分布式模型	238
9.2.4 NoSQL数据库分类	241
9.3 NewSQL	255
9.3.1 系统分类	255
9.3.2 Google Spanner	256
9.3.3 MemSQL	258
9.3.4 VoltDB	260
9.4 练习题	263
参考文献	263
第10章 大数据与数据挖掘	264
10.1 数据挖掘的主要功能和常用算法	264
10.1.1 数据挖掘的主要功能	264
10.1.2 常用算法	265
10.2 大数据时代的数据挖掘	280
10.2.1 传统数据挖掘解决方案	280
10.2.2 分布式数据挖掘解决方案	280
10.3 数据挖掘相关工具	282
10.3.1 Mahout	282
10.3.2 语言工具——Python	288
10.4 数据挖掘与R语言	289
10.4.1 R语言简介	289
10.4.2 R语言在数据挖掘上的应用	290
10.5 练习题	294
参考文献	294
第11章 深度学习	298
11.1 深度学习介绍	299
11.1.1 深度学习的概念	299
11.1.2 深度学习的结构	299
11.1.3 从机器学习到深度学习	301
11.2 深度学习基本方法	302
11.2.1 自动编码器	302
11.2.2 稀疏编码	304
11.3 深度学习模型	305
11.3.1 深度置信网络	306
11.3.2 卷积神经网络	308
11.4 深度学习的训练加速	310
11.4.1 GPU加速	310
11.4.2 数据并行	311
11.4.3 模型并行	312
11.4.4 计算集群	313
11.5 深度学习应用	313
11.5.1 Google	314
11.5.2 百度	314
11.5.3 腾讯Mariana	315
11.6 练习题	316
参考文献	316
第12章 电子商务与社会化网络大数据分析	318
12.1 推荐系统简介	318
12.1.1 推荐系统的评判标准	319
12.1.2 推荐系统的分类	319
12.1.3 在线推荐系统常用算法介绍	320
12.1.4 相关算法知识	323
12.2 计算广告	327
12.2.1 计算广告简介	327
12.2.2 计算广告发展阶段	327
12.2.3 计算广告相关算法	330
12.2.4 计算广告与大数据	332
12.2.5 大数据在计算广告中的应用案例	333
12.3 社交网络	333
12.3.1 社交网络中大数据挖掘的应用场景	334
12.3.2 社交网络大数据挖掘核心算法模型	334
12.3.3 图计算框架	335
12.3.4 大数据在社交网络中的应用案例	337
12.4 练习题	338
第13章 大数据展示与交互技术	339
13.1 数据可视化分类	339
13.1.1 按照展示内容进行划分	340
13.1.2 按照数据类型进行划分	341
13.2 可视化技术分类	351
13.2.1 2D展示技术	351
13.2.2 3D渲染技术	356
13.2.3 体感互动技术	360
13.2.4 虚拟现实技术	362
13.2.5 增强现实技术	364
13.2.6 可穿戴技术	365
13.2.7 可植入设备	368
13.3 练习题	369
参考文献	369
第14章 大数据安全与隐私	372
14.1 云计算时代安全与隐私问题凸显	372
14.2 云计算与大数据时代的安全挑战	374
14.2.1 大数据时代的安全需求	374
14.2.2 信息安全的发展历程	375
14.2.3 新兴信息技术带来的安全挑战	376
14.3 如何解决安全问题	380
14.3.1 云计算安全防护框架	381
14.3.2 基础云安全防护关键技术	384
14.3.3 创立本质安全的新型IT体系	387
14.4 隐私问题	389
14.4.1 防不胜防的隐私泄露	389
14.4.2 隐私保护的政策法规	390
14.4.3 隐私保护技术	391
14.5 练习题	393
参考文献	393
第15章 大数据技术发展趋势	394
15.1 实时化	394
15.2 内存计算	396
15.2.1 机遇与挑战	396
15.2.2 研究进展	397
15.2.3 发展展望	399
15.3 泛在化	399
15.3.1 发展现状	400
15.3.2 发展趋势	401
15.4 智能化	406
15.4.1 传统人工智能	406
15.4.2 基于大数据的人工智能	407
15.5 练习题	410
参考文献	410
第16章 知名企业大数据架构简介	411
16.1 腾讯	411
16.1.1 背景介绍	411
16.1.2 整体架构	412
16.2 淘宝	416
16.2.1 背景介绍	416
16.2.2 整体架构	416
16.3 Facebook	417
16.3.1 背景介绍	417
16.3.2 整体架构	418
16.3.3 技术架构展望	420
16.4 Twitter	420
16.4.1 背景介绍	420
16.4.2 整体架构	420
16.4.3 技术架构展望	422
16.5 Netflix	422
16.5.1 背景介绍	422
16.5.2 整体架构	423
16.5.3 Netflix个性化和推荐系统架构	426
16.6 练习题	430
参考文献	430
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构大数据——大数据技术及算法解析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据安全架构设计与实战
对本书的赞誉
序　一
序　二
前　言
第一部分　安全架构基础
第1章　架构  2
1.1　什么是架构  2
1.2　架构关注的问题  4
第2章　安全架构  5
2.1　什么是安全  5
2.2　为什么使用“数据安全”这个术语  7
2.3　什么是安全架构  10
2.4　安全架构5A方法论  11
2.5　安全架构5A与CIA的关系  13
第二部分　产品安全架构
第3章　产品安全架构简介  16
3.1　产品安全架构  16
3.2　典型的产品架构与框架  17
3.2.1　三层架构  17
3.2.2　B/S架构  18
3.2.3　C/S架构  19
3.2.4　SOA及微服务架构  19
3.2.5　典型的框架  20
3.3　数据访问层的实现  21
3.3.1　自定义DAL  21
3.3.2　使用ORM  22
3.3.3　使用DB Proxy  23
3.3.4　配合统一的数据服务简化DAL  23
第4章　身份认证：把好第一道门  24
4.1　什么是身份认证  24
4.2　如何对用户进行身份认证  26
4.2.1　会话机制  27
4.2.2　持续的消息认证机制  29
4.2.3　不同应用的登录状态与超时管理  30
4.2.4　SSO的典型误区  31
4.3　口令面临的风险及保护  32
4.3.1　口令的保护  33
4.3.2　口令强度  33
4.4　前端慢速加盐散列案例  34
4.5　指纹、声纹、虹膜、面部识别的数据保护  35
4.6　MD5、SHA1还能用于口令保护吗  36
4.6.1　单向散列算法简介  36
4.6.2　Hash算法的选用  38
4.6.3　存量加盐HASH的安全性  38
4.7　后台身份认证  39
4.7.1　基于用户Ticket的后台身份认证  40
4.7.2　基于AppKey的后台身份认证  41
4.7.3　基于非对称加密技术的后台身份认证  41
4.7.4　基于HMAC的后台身份认证  42
4.7.5　基于AES-GCM共享密钥的后台身份认证  44
4.8　双因子认证  44
4.8.1　手机短信验证码  44
4.8.2　TOTP  44
4.8.3　U2F  45
4.9　扫码认证  45
4.10　小结与思考  46
第5章　授权：执掌大权的司令部  48
5.1　授权不严漏洞简介  48
5.2　授权的原则与方式  49
5.2.1　基于属性的授权  49
5.2.2　基于角色的授权  50
5.2.3　基于任务的授权  51
5.2.4　基于ACL的授权  51
5.2.5　动态授权  52
5.3　典型的授权风险  52
5.3.1　平行越权  52
5.3.2　垂直越权  53
5.3.3　诱导授权  53
5.3.4　职责未分离  53
5.4　授权漏洞的发现与改进  54
5.4.1　交叉测试法  54
5.4.2　漏洞改进  54
第6章　访问控制：收敛与放行的执行官  56
6.1　典型的访问控制策略  56
6.1.1　基于属性的访问控制  57
6.1.2　基于角色的访问控制  57
6.1.3　基于任务的访问控制  57
6.1.4　基于ACL的访问控制  58
6.1.5　基于专家知识的访问控制  58
6.1.6　基于IP的辅助访问控制  59
6.1.7　访问控制与授权的关系  61
6.2　不信任原则与输入参数的访问控制  61
6.2.1　基于身份的信任原则  61
6.2.2　执行边界检查防止缓冲区溢出  62
6.2.3　参数化查询防止SQL注入漏洞  62
6.2.4　内容转义及CSP防跨站脚本  68
6.2.5　防跨站请求伪造  70
6.2.6　防跨目录路径操纵  75
6.2.7　防SSRF  76
6.2.8　上传控制  77
6.2.9　Method控制  78
6.3　防止遍历查询  79
第7章　可审计：事件追溯最后一环  81
7.1　为什么需要可审计  81
7.2　操作日志内容  82
7.3　操作日志的保存与清理  82
7.3.1　日志存储位置  82
7.3.2　日志的保存期限  83
第8章　资产保护：数据或资源的贴身保镖  84
8.1　数据安全存储  84
8.1.1　什么是存储加密  84
8.1.2　数据存储需要加密吗  87
8.1.3　加密后如何检索  88
8.1.4　如何加密结构化数据  88
8.2　数据安全传输  89
8.2.1　选择什么样的HTTPS证书  91
8.2.2　HTTPS的部署  92
8.2.3　TLS质量与合规  93
8.3　数据展示与脱敏  94
8.3.1　不脱敏的风险在哪里  94
8.3.2　脱敏的标准  94
8.3.3　脱敏在什么时候进行  94
8.3.4　业务需要使用明文信息怎么办  95
8.4　数据完整性校验  95
第9章　业务安全：让产品自我免疫  97
9.1　一分钱漏洞  97
9.2　账号安全  99
9.2.1　防撞库设计  99
9.2.2　防弱口令尝试  99
9.2.3　防账号数据库泄露  100
9.2.4　防垃圾账号  100
9.2.5　防账号找回逻辑缺陷  100
9.3　B2B交易安全  101
9.4　产品防攻击能力  103
第三部分　安全技术体系架构
第10章　安全技术体系架构简介  106
10.1　安全技术体系架构的建设性思维  106
10.2　安全产品和技术的演化  107
10.2.1　安全产品的“老三样”  107
10.2.2　网络层延伸  107
10.2.3　主机层延伸  108
10.2.4　应用层延伸  108
10.2.5　安全新技术  108
10.3　安全技术体系架构的二维模型  109
10.4　风险管理的“三道防线”  110
10.5　安全技术体系强化产品安全  112
10.5.1　网络部署架构  112
10.5.2　主机层安全  113
10.5.3　应用层安全  115
10.5.4　数据层安全  117
第11章　网络和通信层安全架构  119
11.1　简介  119
11.2　网络安全域  120
11.2.1　最简单的网络安全域  120
11.2.2　最简单的网络安全域改进  121
11.2.3　推荐的网络安全域  121
11.2.4　从有边界网络到无边界网络  122
11.2.5　网络安全域小结  124
11.3　网络接入身份认证  125
11.4　网络接入授权  127
11.5　网络层访问控制  127
11.5.1　网络准入控制  127
11.5.2　生产网络主动连接外网的访问控制  129
11.5.3　网络防火墙的管理  130
11.5.4　内部网络值得信任吗  131
11.5.5　运维通道的访问控制  132
11.6　网络层流量审计  132
11.7　网络层资产保护：DDoS缓解  133
11.7.1　DDoS简介  133
11.7.2　DDoS缓解措施  134
11.7.3　专业抗DDoS方案  134
第12章　设备和主机层安全架构  136
12.1　简介  136
12.2　身份认证与账号安全  136
12.2.1　设备/主机身份认证的主要风险  137
12.2.2　动态口令  137
12.2.3　一次一密认证方案  137
12.2.4　私有协议后台认证方案  138
12.3　授权与访问控制  138
12.3.1　主机授权与账号的访问控制  138
12.3.2　主机服务监听地址  139
12.3.3　跳板机与登录来源控制  140
12.3.4　自动化运维  141
12.3.5　云端运维  142
12.3.6　数据传输  142
12.3.7　设备的访问控制  143
12.4　运维审计与主机资产保护  144
12.4.1　打补丁与防病毒软件  144
12.4.2　母盘镜像与容器镜像  145
12.4.3　开源镜像与软件供应链攻击防范  145
12.4.4　基于主机的入侵检测系统  147
第13章　应用和数据层安全架构  150
13.1　简介  150
13.2　三层架构实践  151
13.2.1　B/S架构  152
13.2.2　C/S架构  153
13.3　应用和数据层身份认证  154
13.3.1　SSO身份认证系统  154
13.3.2　业务系统的身份认证  155
13.3.3　存储系统的身份认证  155
13.3.4　登录状态管理与超时管理  156
13.4　应用和数据层的授权管理  156
13.4.1　权限管理系统  156
13.4.2　权限管理系统的局限性  157
13.5　应用和数据层的访问控制  158
13.5.1　统一的应用网关接入  158
13.5.2　数据库实例的安全访问原则  159
13.6　统一的日志管理平台  159
13.7　应用和数据层的资产保护  160
13.7.1　KMS与存储加密  160
13.7.2　应用网关与HTTPS  164
13.7.3　WAF（Web应用防火墙）  165
13.7.4　CC攻击防御  167
13.7.5　RASP  168
13.7.6　业务风险控制  169
13.8　客户端数据安全  171
13.8.1　客户端敏感数据保护  172
13.8.2　安全传输与防劫持  172
13.8.3　客户端发布  174
第14章　安全架构案例与实战  176
14.1　零信任与无边界网络架构  176
14.1.1　无边界网络概述  177
14.1.2　对人的身份认证（SSO及U2F）  178
14.1.3　对设备的身份认证  178
14.1.4　最小授权原则  178
14.1.5　设备准入控制  179
14.1.6　应用访问控制  179
14.1.7　借鉴与改进  180
14.2　统一HTTPS接入与安全防御  181
14.2.1　原理与架构  181
14.2.2　应用网关与HTTPS  182
14.2.3　WAF与CC防御  183
14.2.4　私钥数据保护  183
14.2.5　负载均衡  184
14.2.6　编码实现  184
14.2.7　典型特点  185
14.3　存储加密实践  186
14.3.1　数据库字段加密  186
14.3.2　数据库透明加密  186
14.3.3　网盘文件加密方案探讨  187
14.3.4　配置文件口令加密  188
14.4　最佳实践小结  189
14.4.1　统一接入  189
14.4.2　收缩防火墙的使用  190
14.4.3　数据服务  190
14.4.4　建立KMS  191
14.4.5　全站HTTPS  191
14.4.6　通用组件作为基础设施  191
14.4.7　自动化运维  192
第四部分　数据安全与隐私保护治理
第15章　数据安全治理  194
15.1　治理简介  194
15.1.1　治理与管理的区别  194
15.1.2　治理三要素  196
15.2　数据安全治理简介  196
15.2.1　数据安全治理的要素  197
15.2.2　数据安全治理与数据安全管理的关系  201
15.3　安全项目管理  203
15.4　安全运营管理  204
15.5　合规与风险管理  208
15.6　安全开发生命周期管理（SDL）  208
15.6.1　SQL注入漏洞案例  209
15.6.2　SDL关键检查点与检查项  211
15.6.3　SDL核心工作  212
15.7　风险管理  212
15.7.1　风险识别或评估  212
15.7.2　风险度量或成熟度分析  216
15.7.3　风险处置与收敛跟踪  220
15.7.4　风险运营工具和技术  221
15.8　PDCA方法论与数据安全治理  224
第16章　数据安全政策文件体系  227
16.1　数据安全文件体系  227
16.1.1　四层文件体系架构简介  228
16.1.2　数据安全四层文件体系  228
16.1.3　标准、规范与管理规定的关系  229
16.1.4　外部法规转为内部文件  231
16.2　数据安全政策总纲  232
16.2.1　数据安全的目标和范围  232
16.2.2　数据安全组织与职责  233
16.2.3　授权原则  233
16.2.4　数据保护原则  234
16.2.5　数据安全外部合规要求  234
16.3　数据安全管理政策  234
16.3.1　数据分级与分类  234
16.3.2　风险评估与定级指南  235
16.3.3　风险管理要求  237
16.3.4　事件管理要求  238
16.3.5　人员管理要求  239
16.3.6　配置和运维管理  242
16.3.7　业务连续性管理  243
16.4　数据安全标准  244
16.4.1　算法与协议标准  244
16.4.2　口令标准  247
16.4.3　产品与组件标准  248
16.4.4　数据脱敏标准  251
16.4.5　漏洞定级标准  251
16.5　数据安全技术规范  252
16.5.1　安全架构设计规范  253
16.5.2　安全开发规范  255
16.5.3　安全运维规范  256
16.5.4　安全配置规范  257
16.6　外部合规认证与测评  259
第17章　隐私保护基础  262
17.1　隐私保护简介  262
17.1.1　典型案例  262
17.1.2　什么是隐私  263
17.1.3　隐私保护与数据安全的关系  264
17.1.4　我需要了解隐私保护吗  264
17.1.5　隐私保护的技术手段  265
17.1.6　合规遵从  265
17.2　GDPR  268
17.2.1　简介  268
17.2.2　两种角色  269
17.2.3　六项原则及问责制  270
17.2.4　处理个人数据的六个法律依据  271
17.2.5　处理儿童数据  271
17.2.6　特殊的数据类型  272
17.2.7　数据主体的权利  272
17.2.8　数据控制者和数据处理者的义务  274
17.2.9　违规与处罚  276
17.3　个人信息安全规范  276
17.3.1　简介  276
17.3.2　个人信息安全原则  277
17.3.3　个人信息的生命周期管理  277
17.4　GAPP框架  279
17.5　ISO 27018  280
第18章　隐私保护增强技术  281
18.1　隐私保护技术初探  281
18.2　去标识化  283
18.2.1　匿名化  283
18.2.2　假名化  284
18.2.3　K?-匿名  284
18.3　差分隐私  286
18.3.1　差分隐私原理  286
18.3.2　差分隐私噪声添加机制  288
18.3.3　数值型差分隐私  288
18.3.4　数值型差分隐私的局限性  291
18.3.5　离散型差分隐私  292
18.3.6　差分隐私案例  294
18.3.7　差分隐私实战  294
第19章　GRC与隐私保护治理  297
19.1　风险  297
19.2　GRC简介  298
19.2.1　GRC三领域  299
19.2.2　GRC控制模型  304
19.3　隐私保护治理简介  306
19.4　隐私保护治理GRC实践  307
19.4.1　计划  308
19.4.2　执行  308
19.4.3　检查  311
19.4.4　处理  311
19.5　隐私保护能力成熟度  311
第20章　数据安全与隐私保护的统一  317
20.1　以数据为中心的统一治理  317
20.1.1　统一的数据安全治理  317
20.1.2　统一数据目录与数据流图  319
20.1.3　统一数据服务  319
20.2　统一的数据安全生命周期管理  320
20.2.1　数据安全生命周期  321
20.2.2　全生命周期的数据主体权利保障  326
20.2.3　典型案例  327
20.3　数据安全治理能力成熟度模型（DSGMM）  334
附录　数据安全架构与治理总结  338
参考文献  340
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据安全架构设计与实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ACE技术内幕
前   言
第1章   概述 / 1
1.1   模式与框架 / 1
1.1.1   模式 / 1
1.1.2   框架 / 2
1.1.3   模式与框架的关系 / 3
1.2   ACE框架 / 3
1.3   关于本书 / 7
1.3.1   本书的内容 / 7
1.3.2   源代码的表示 / 8
1.3.3   测试组网 / 9
1.3.4   几个常用术语 / 9
1.4   ACE Socket封装器 / 9
1.4.1   示例分析 / 10
1.4.2   Socket IPC分析 / 13
1.4.3   ACE_SOCK_Acceptor类的分析 / 15
1.4.4   ACE_SOCK_Connector类的分析 / 19
1.5   进一步学习 / 23
1.6   总结 / 23
第2章   Reactor框架 / 24
2.1   Reactor构架模式 / 24
2.2   Reactor框架概述 / 26
2.3   Reactor框架应用示例 / 27
2.3.1   I/O事件处理器的实现 / 27
2.3.2   Accept事件处理器的实现 / 31
2.3.3   main函数 / 34
2.4   事件处理器接口实现 / 35
2.4.1   事件处理器接口的构造与析构 / 38
2.4.2   事件处理器接口的使用规范 / 38
2.5    Reactor管理器的设计分析 / 39
2.5.1   Reactor管理器接口分析 / 40
2.5.2   Bridge设计模式接口 / 44
2.5.3   ACE_Select_Reactor_Impl类的分析 / 45
2.5.4   ACE_Select_Reactor_T类的分析 / 46
2.6   I/O事件调度的分析 / 47
2.6.1   I/O事件调度集的设计 / 47
2.6.2   调度集操作函数的分析 / 50
2.6.3   I /O事件处理器仓库的分析 / 53
2.6.4   I/O事件注册流程的分析 / 59
2.6.5   I/O事件调度流程的分析 / 61
2.6.6   I/O事件删除流程的分析 / 70
2.7   信号量事件调度的分析 / 71
2.7.1   信号量事件管理器的分析 / 71
2.7.2   Reactor管理器中的信号量事件处理 / 77
2.7.3   信号量事件删除流程的分析 / 78
2.8   定时器事件调度的分析 / 79
2.8.1   定时器事件管理器的分析 / 80
2.8.2   定时器事件注册流程的分析 / 93
2.8.3   定时器事件调度流程的分析 / 94
2.8.4   定时器事件删除流程的分析 / 95
2.9   Notify事件调度的分析 / 96
2.9.1   Notify事件管理器的分析 / 97
2.9.2   Notify事件注册流程的分析 / 105
2.9.3   Notify事件调度流程的分析 / 106
2.10   进一步学习 / 107
2.11   总结 / 107
第3章   Service Configurator框架 / 108
3.1   Component Configurator构架模式 / 108
3.2   Configurator框架概述 / 109
3.3   Configurator框架应用示例1 / 111
3.3.1   配置文件 / 111
3.3.2   可配置组件 / 111
3.3.3   main函数 / 113
3.4   ACE动态库接口封装的分析 / 114
3.5   配置组件接口的分析 / 115
3.6   组件工厂函数的分析 / 117
3.7   组件配置器设计的分析 / 119
3.7.1   组件配置器控制接口的分析 / 119
3.7.2   组件配置器实现的分析 / 128
3.7.3   语法分析器的分析 / 138
3.8   动态库符号定位的分析 / 141
3.8.1   ACE_Location_Node类分析 / 142
3.8.2   ACE_Object_Node类的分析 / 143
3.8.3   ACE_Function_Node类的分析 / 144
3.9   配置组件仓库的分析 / 147
3.9.1   find函数 / 148
3.9.2   remove函数 / 149
3.9.3   suspend函数 / 150
3.9.4   resume函数 / 150
3.10   配置组件类型的分析 / 151
3.10.1   ACE_Service_Type类 / 152
3.10.2   ACE_Service_Type_Impl类 / 153
3.10.3   ACE_Service_Object_Type类 / 154
3.10.4   ACE_Service_Type_Factory类 / 154
3.11   指令解析功能的分析 / 156
3.12   配置文件解析流程的分析 / 157
3.13   Configurator框架应用示例2 / 160
3.13.1   可配置组件 / 160
3.13.2   配置文件 / 161
3.13.3   配置文件解析流程的分析 / 162
3.14   配置改变 / 162
3.15   Configurator框架应用示例3 / 162
3.15.1   静态配置组件 / 163
3.15.2   配置文件 / 165
3.15.3   静态配置组件分析 / 166
3.16   进一步学习 / 169
3.17   总结 / 169
第4章   Task框架 / 170
4.1   Task框架概述 / 170
4.2   Task框架应用示例 / 171
4.2.1   生产者 / 171
4.2.2   消费者 / 173
4.2.3   main函数 / 174
4.3   ACE消息队列实现分析 / 175
4.3.1   数据块结构分析 / 176
4.3.2   消息块结构的分析 / 180
4.3.3   消息队列实现的分析 / 182
4.4   ACE多线程编程 / 185
4.4.1   线程的创建 / 186
4.4.2   线程的运行 / 189
4.4.3   线程的退出 / 191
4.4.4   线程等待 / 195
4.5   Task框架接口的分析 / 198
4.5.1   ACE_Task_Base类 / 199
4.5.2   ACE_Task类 / 200
4.6   Active Object设计模式 / 201
4.6.1   模式概述 / 201
4.6.2   应用示例 / 203
4.6.3   ACE_Future和ACE_Future_Rep类 / 207
4.7   进一步学习 / 210
4.8   总结 / 210
第5章   Acceptor_Connector框架 / 211
5.1   Acceptor_Connector构架模式 / 211
5.2   Acceptor_Connector框架概述 / 212
5.3   Acceptor_Connector框架应用示例 / 213
5.3.1   open函数 / 214
5.3.2   handle_input函数 / 214
5.3.3   handle_close函数 / 215
5.3.4   main函数 / 215
5.4   服务处理器接口的分析 / 216
5.4.1   open函数 / 217
5.4.2   handle_close函数 / 218
5.4.3   close函数 / 219
5.4.4   shutdown函数 / 219
5.5   Acceptor设计的分析 / 220
5.5.1   ACE_Acceptor类 / 220
5.5.2   open函数 / 221
5.5.3   handle_input函数 / 222
5.5.4   handle_close函数 / 224
5.6   Connector设计的分析 / 225
5.6.1   ACE_Connector类 / 226
5.6.2   阻塞模式连接的分析 / 226
5.6.3   非阻塞模式连接的分析 / 229
5.7   进一步学习 / 236
5.8   总结 / 236
第6章   Proactor框架 / 237
6.1   Proactor构架模式 / 237
6.2   Proactor框架概述 / 239
6.3   Proactor框架应用示例 / 240
6.3.1   I/O事件完成处理器的实现 / 240
6.3.2   异步Acceptor的实现 / 245
6.3.3   main函数 / 245
6.4   事件完成处理器接口的分析 / 246
6.5   Proactor管理器的设计分析 / 247
6.5.1   Proactor管理器接口的分析 / 248
6.5.2   Bridge设计模式接口 / 252
6.5.3   ACE_POSIX_Proactor接口分析 / 252
6.6   异步操作初始化器和操作结果分析 / 253
6.6.1   公共接口介绍 / 256
6.6.2   ACE_POSIX_Asynch_Operation类 / 256
6.6.3   ACE_POSIX_Asynch_Result类 / 258
6.6.4   ACE_POSIX_Asynch_Read_Stream_Result类 / 261
6.6.5   ACE_POSIX_Asynch_Read_Stream类 / 263
6.7   ACE_POSIX_AIOCB_Proactor管理器实现的分析 / 265
6.7.1   构造函数 / 267
6.7.2   start_aio函数 / 268
6.7.3   handle_events_i函数 / 271
6.7.4   find_completed_aio函数 / 274
6.7.5   start_deferred_aio函数 / 275
6.7.6   application_specific_code函数 / 277
6.8   异步非I/O事件调度的分析 / 278
6.8.1   ACE_AIOCB_Notify_Pipe_Manager类 / 278
6.8.2   post_completion函数 / 281
6.8.3   putq_result函数 / 282
6.8.4   process_result_queue函数 / 283
6.9   定时器事件调度的分析 / 283
6.9.1   定时器事件操作结果的分析 / 284
6.9.2   定时器管理器实现的分析 / 285
6.10   网络连接之accept事件调度的分析 / 290
6.10.1   Reactor任务分析 / 292
6.10.2   异步Acceptor分析 / 293
6.10.3   ACE_POSIX_Asynch_Accept类 / 294
6.10.4   ACE_POSIX_Asynch_Accept_Result类 / 300
6.10.5   ACE_Asynch_Acceptor类 / 302
6.11   Proactor框架的调度分析 / 311
6.11.1   调度函数分析 / 311
6.11.2   退出调度分析 / 311
6.12   进一步学习 / 313
6.13   总结 / 313
第7章   Streams框架 / 314
7.1   管道和过滤器构架模式 / 314
7.2   Streams框架的概述 / 315
7.2.1   ACE_Task类 / 315
7.2.2   put函数 / 316
7.2.3   put_next函数 / 316
7.3   Streams框架应用示例 / 317
7.3.1   Logrec_Reader类 / 317
7.3.2   Logrec_Timer类 / 318
7.3.3   Logrec_Suffix类 / 319
7.3.4   Logrec_Writer类 / 319
7.3.5   main函数 / 320
7.4   ACE_Module类的分析 / 322
7.4.1   open函数 / 323
7.4.2   link函数 / 324
7.4.3   ACE_Module的关闭 / 325
7.5   ACE_Stream类的分析 / 326
7.5.1   构造函数 / 326
7.5.2   open函数 / 327
7.5.3   push函数 / 329
7.5.4   close函数 / 330
7.6   进一步学习 / 331
7.7   总结 / 331
参考文献 / 332
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ACE技术内幕
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实用软件架构
题献
译者序
序
前言
致谢
第1章　案例研究 …… 1
1.1　业务问题 …… 1
1.1.1　技术挑战 …… 2
1.1.2　用例 …… 2
1.1.3　在机器运转过程中进行实时处理与监控 …… 3
1.1.4　为新机器提供无缝的激活服务 …… 3
1.1.5　生成工作定单 …… 3
1.1.6　尽量减少在为全球客户提供服务时所产生的延迟 …… 4
1.2　小结 …… 4
第2章　软件架构是什么？为什么需要做软件架构 …… 6
2.1　背景知识 …… 6
2.2　软件架构是什么 …… 7
2.3　为什么需要做软件架构 …… 9
2.3.1　把架构视为交流工具 …… 9
2.3.2　对项目规划施加影响力 …… 10
2.3.3　关注非功能方面的能力 …… 11
2.3.4　与设计团队和实现团队做出约定 …… 12
2.3.5　为影响力分析提供支持 …… 12
2.4　架构视图与架构视点 …… 13
2.5　小结 …… 16
2.6　参考资料 …… 16
第3章　恰到好处地把握架构中的重要方面 …… 17
3.1　软件架构中需要关注的一些方面 …… 17
3.2　小结 …… 19
第4章　系统环境 …… 20
4.1　业务环境与系统环境之间的辨析 …… 20
4.2　捕获系统环境 …… 22
4.2.1　系统环境图 …… 23
4.2.2　信息流 …… 25
4.3　案例研究：Elixir的系统环境 …… 27
4.3.1　Elixir的系统环境图 …… 27
4.3.2　Elixir的信息流 …… 32
4.4　小结 …… 33
4.5　参考资料 …… 33
第5章　架构概述 …… 34
5.1　什么是架构概述 …… 34
5.2　为什么要做架构概述 …… 36
5.3　企业视图 …… 37
5.3.1　用户与传输渠道 …… 39
5.3.2　核心业务流程 …… 39
5.3.3　数据与信息 …… 40
5.3.4　技术推动力 …… 41
5.4　分层视图 …… 42
5.4.1　第1层：操作层 …… 45
5.4.2　第2层：服务组件层 …… 45
5.4.3　第3层：服务层 …… 45
5.4.4　第4层：业务流程层 …… 46
5.4.5　第5层：消费者层 …… 46
5.4.6　第6层：集成层 …… 46
5.4.7　第7层：QoS层 …… 46
5.4.8　第8层：信息架构层 …… 47
5.4.9　第9层：治理层 …… 47
5.4.10　进一步研究分层视图的用法 …… 47
5.5　IT系统视图 …… 48
5.6　案例研究：Elixir的架构概述 …… 53
5.6.1　Elixir的企业视图 …… 53
5.6.2　Elixir的业务流程 …… 54
5.6.3　Elixir的数据及信息 …… 54
5.6.4　Elixir的技术推动力 …… 55
5.6.5　Elixir的分层视图 …… 56
5.6.6　Elixir的IT系统视图 …… 57
5.7　小结 …… 58
5.8　参考资料 …… 59
第6章　架构决策 …… 60
6.1　为什么需要做架构决策 …… 60
6.2　怎样开始进行架构决策 …… 61
6.3　创建架构决策 …… 62
6.4　案例研究：Elixir的架构决策 …… 67
6.5　小结 …… 69
第7章　功能模型 …… 71
7.1　为什么需要功能模型 …… 71
7.2　可追溯性 …… 73
7.3　制定功能模型 …… 74
7.3.1　逻辑层面的设计 …… 75
7.3.2　规格层面的设计 …… 79
7.3.3　物理层面的设计 …… 89
7.4　案例研究：Elixir的功能模型 …… 91
7.4.1　逻辑层面 …… 92
7.4.2　规格层面 …… 94
7.4.3　物理层面 …… 97
7.5　小结 …… 98
7.6　参考资料 …… 99
第8章　操作模型 …… 100
8.1　为什么需要操作模型 …… 101
8.2　可追溯性与服务级别协议 …… 102
8.3　制定操作模型 …… 104
8.3.1　概念操作模型 …… 105
8.3.2　规格操作模型 …… 116
8.3.3　物理操作模型 …… 122
8.4　案例研究：Elixir的操作模型 …… 132
8.4.1　COM …… 132
8.4.2　SOM …… 137
8.4.3　POM …… 138
8.5　小结 …… 140
8.6　参考资料 …… 141
第9章　集成：方式与模式 …… 142
9.1　为什么需要进行集成 …… 142
9.2　集成方式 …… 143
9.2.1　用户界面的集成 …… 144
9.2.2　数据层面的集成 …… 144
9.2.3　消息层面的集成 …… 147
9.2.4　API层面的集成 …… 149
9.2.5　服务层面的集成 …… 150
9.3　集成模式 …… 152
9.3.1　同步的请求栂煊δＪ?…… 152
9.3.2　批次模式 …… 153
9.3.3　同步的批次请求栍Υ鹉Ｊ?…… 153
9.3.4　异步的批次请求栍Υ鹉Ｊ?…… 153
9.3.5　存储并转发模式 …… 154
9.3.6　发布柖┰哪Ｊ?…… 154
9.3.7　聚合模式 …… 154
9.3.8　管道与过滤器模式 …… 155
9.3.9　消息路由器模式 …… 155
9.3.10　消息转换器模式 …… 156
9.4　案例研究：Elixir的集成视图 …… 156
9.4.1　标签1～5所表示的数据流 …… 157
9.4.2　标签6～8所表示的数据流 …… 158
9.4.3　标签9～10所表示的数据流 …… 158
9.4.4　标签11～12所表示的数据流 …… 158
9.5　小结 …… 159
9.6　参考资料 …… 160
第10章　基础设施问题 …… 161
10.1　为什么要把基础设施做好 …… 162
10.2　需要考虑的基础设施问题 …… 162
10.2.1　网络 …… 163
10.2.2　托管 …… 165
10.2.3　高可用性与容错性 …… 169
10.2.4　灾难恢复 …… 178
10.2.5　能力规划 …… 178
10.3　案例研究：Elixir系统的基础设施问题 …… 181
10.4　小结 …… 183
10.5　我们现在讲到什么地方了 …… 184
10.6　参考资料 …… 186
第11章　分析架构入门 …… 187
11.1　为什么要做分析 …… 188
11.2　进行数据分析改采用的维度 …… 189
11.2.1　操作分析 …… 189
11.2.2　描述性的分析 …… 190
11.2.3　预测性的分析 …… 190
11.2.4　指示性的分析 …… 191
11.2.5　认知计算 …… 192
11.3　分析架构的基础 …… 194
11.3.1　分层视图中的各层及五大支柱 …… 195
11.3.2　水平层 …… 196
11.3.3　垂直层 …… 199
11.3.4　五大支柱 …… 201
11.4　架构构建块 …… 205
11.4.1　数据类型层中的ABB …… 206
11.4.2　数据获取与访问层中的ABB …… 207
11.4.3　数据存储库层中的ABB …… 208
11.4.4　模型层中的ABB …… 209
11.4.5　数据集成与整合层中的ABB …… 210
11.4.6　分析解决方案层中的ABB …… 211
11.4.7　消费者层中的ABB …… 213
11.4.8　元数据层中的ABB …… 213
11.4.9　数据与信息安全层中的ABB …… 214
11.4.10　描述性的分析中的ABB …… 215
11.4.11　预测性的分析中的ABB …… 215
11.4.12　指示性的分析中的ABB …… 217
11.4.13　操作分析中的ABB …… 217
11.4.14　认知计算中的ABB …… 218
11.5　小结 …… 219
11.6　参考资料 …… 220
第12章　架构经验谈 …… 222
12.1　各种敏捷开发观点应该加以融合 …… 222
12.2　传统的需求收集技术过时了 …… 224
12.3　MVP范式值得考虑 …… 225
12.4　不要忙于应付各种事务 …… 226
12.5　预测性的分析并不是唯一的分析切入点 …… 227
12.6　领导能力也可以通过培养而获得 …… 227
12.7　架构不应该由技术来驱动 …… 228
12.8　开源软件很好，但要谨慎使用 …… 230
12.9　把看似简单的问题总结起来 …… 230
12.10　根据技术产品的核心优势来确定架构基线 …… 231
12.11　小结 …… 232
12.12　参考资料 …… 232
附录A　25个实用小知识 …… 233
附录B　Elixir的功能模型（续） …… 252
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实用软件架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux内核探秘
前　言
第1章　内核的基础层和应用层
1.1 内核基础层提供的服务
1.1.1 内核中使用内存
1.1.2 内核中的任务调度
1.1.3 软中断和tasklet
1.1.4 工作队列
1.1.5 自旋锁
1.1.6 内核信号量
1.1.7 原子变量
1.2 内核基础层的数据结构
1.2.1 双向链表
1.2.2 hash链表
1.2.3 单向链表
1.2.4 红黑树
1.2.5 radix树
1.3 内核应用层
1.4 从Linux内核源码结构纵览内核
1.5 内核学习和应用的四个阶段
1.6 本章小结
第2章　文件系统
2.1 文件系统的基本概念
2.1.1 什么是VFS
2.1.2 超级块super_block
2.1.3 目录项dentry
2.1.4 索引节点inode
2.1.5 文件
2.2 文件系统的架构
2.2.1 超级块作用分析
2.2.2 dentry作用分析
2.2.3 inode作用分析
2.2.4 文件作用分析
2.3 从代码层次深入分析文件系统
2.3.1 一个最简单的文件系统aufs
2.3.2 文件系统如何管理目录和文件
2.3.3 文件系统的挂载过程
2.3.4 文件打开的代码分析
2.4 本章小结
第3章　设备的概念和总体架构
3.1 设备的配置表
3.2 访问设备寄存器和设备内存
3.3 设备中断和DMA
3.4 总线对设备的扫描
3.5 设备驱动管理
3.6 本章小结
第4章　为设备服务的特殊文件系统sysfs
4.1 文件和目录的创建
4.1.1 sysfs文件系统的初始化
4.1.2 sysfs文件系统目录的创建
4.1.3 普通文件的创建
4.2 sysfs文件的打开操作
4.2.1 real_lookup函数详解
4.2.2 为文件创建inode结构
4.2.3 为dentry结构绑定属性
4.2.4 调用文件系统中的open函数
4.3 sysfs文件的读写
4.3.1 读文件的过程分析
4.3.2 写文件的过程分析
4.4 kobject结构
4.4.1 kobject和kset的关系
4.4.2 kobject实例：总线的注册
4.5 本章小结
第5章　字符设备和input设备
5.1 文件如何变成设备
5.1.1 init_special_inode函数
5.1.2 def_chr_fops结构
5.2 input设备的注册
5.2.1 主从设备号
5.2.2 把input设备注册到系统
5.2.3 设备区间的登记
5.2.4 注册字符设备
5.2.5 打开input设备
5.3 input设备架构
5.3.1 注册input设备的驱动
5.3.2 匹配input管理的设备和驱动
5.3.3 注册input设备
5.4 本章小结
第6章　platform总线
6.1 从驱动发现设备的过程
6.1.1 驱动的初始化
6.1.2 注册驱动
6.1.3 为总线增加一个驱动
6.1.4 驱动加载
6.1.5 遍历总线上已经挂载的设备
6.2 从设备找到驱动的过程
6.2.1 注册设备和总线类型
6.2.2 注册设备的资源
6.2.3 增加一个设备对象
6.3 本章小结
第7章　serio总线
7.1 什么是总线适配器
7.2 向serio总线注册设备
7.2.1 注册端口登记事件
7.2.2 遍历总线的驱动
7.2.3 注册input设备
7.3 虚拟键盘驱动
7.3.1 键盘驱动的初始化
7.3.2 与设备建立连接
7.3.3 启动键盘设备
7.3.4 输入设备和主机系统之间的事件
7.4 键盘中断
7.4.1 q40kbd设备的中断处理
7.4.2 serio总线的中断处理
7.4.3 驱动提供的中断处理
7.5 本章小结
第8章　PCI总线
8.1 深入理解PCI总线
8.1.1 PCI设备工作原理
8.1.2 PCI总线域
8.1.3 PCI资源管理
8.1.4 PCI配置空间读取和设置
8.2 PCI设备扫描过程
8.2.1 扫描0号总线
8.2.2 扫描总线上的PCI设备
8.2.3 扫描多功能设备
8.2.4 扫描单个设备
8.2.5 扫描设备信息
8.3 本章小结
第9章　块设备
9.1 块设备的架构
9.1.1 块设备、磁盘对象和队列
9.1.2 块设备和通用磁盘对象的绑定
9.1.3 块设备的队列和队列处理函数
9.2 块设备创建的过程分析
9.2.1 nbd驱动的初始化
9.2.2 为通用磁盘对象创建队列成员
9.2.3 将通用磁盘对象加入系统
9.3 块设备文件系统
9.3.1 块设备文件系统的初始化
9.3.2 块设备文件系统的设计思路
9.4 块设备的打开流程
9.4.1 获取块设备对象
9.4.2 执行块设备的打开流程
9.5 本章小结
第10章　文件系统读写
10.1 page cache机制
10.1.1 buffer I/O和direct I/O
10.1.2 buffer head和块缓存
10.1.3 page cache的管理
10.1.4 page cache的状态
10.2 文件预读
10.3 文件锁
10.4 文件读过程代码分析
10.5 读过程返回
10.6 文件写过程代码分析
10.7 本章小结
第11章　通用块层和scsi层
11.1 块设备队列
11.1.1 scsi块设备队列处理函数
11.1.2 电梯算法和对象
11.2 硬盘HBA抽象层
11.3 I/O的顺序控制
11.4 I/O调度算法
11.4.1 noop调度算法
11.4.2 deadline调度算法
11.5 I/O的处理过程
11.5.1 I/O插入队列的过程分析
11.5.2 I/O出队列的过程分析
11.5.3 I/O返回路径
11.6 本章小结
第12章　内核回写机制
12.1 内核的触发条件
12.2 内核回写控制参数
12.3 定时器触发回写
12.3.1 启动定时器
12.3.2 执行回写操作
12.3.3 检查需要回写的页面
12.3.4 回写超级块内的inode
12.4 平衡写
12.4.1 检查直接回写的条件
12.4.2 回写系统脏页面的条件
12.4.3 检查计算机模式
12.5 本章小结
第13章　一个真实文件系统ext2
13.1 ext2的硬盘布局
13.2 ext2文件系统目录树
13.3 ext2文件内容管理
13.4 ext2文件系统读写
13.5 本章小结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux内核探秘
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>互联网金融商业模式与架构
前　言
第一章　金融遇到互联网　/ 1
互联网金融绝非“金融+互联网”或“互联网+金融”，而是利用互联网的“聚合与连接”作用解决供需双方之间的信息不对称，快速匹配及撮合交易，利用互联网的大数据、云计算管控金融风险，挖掘个性化金融需求。互联网金融的本质是金融，需要遵守金融的基本规则、基本规律。
01 最赚钱的行业——金融　/ 2
02 发展最快的行业——互联网　/ 4
03 千年等一回的相逢　/ 9
不期而遇的金融和互联网
互联网企业“玩”金融
04 金融的互联网还是互联网的金融？　/ 13
05 金融电商与电商金融　/ 15
金融电商
电商金融
06 互联网改变了金融什么？　/ 21
07 最赚钱+最快=赚钱最快？　/ 24
08 运营商来搅局，银行布局P2P　/ 26
互联网金融的天外来客——运营商来搅局银行布局P2P
09 互联网金融也有O2O?　/ 29
10 互联网金融的实质　/ 30
第二章　互联网金融商业模式的价值　/ 33
互联网金融解决的是传统金融所未覆盖的小微金融服务领域，是金融市场的第三极，与传统金融是互补关系，并非颠覆关系。互联网金融的聚合与长尾效应显现出其与传统互联网商业模式的不同。
01 国际视野下的互联网金融发展史　/ 34
02 国内互联网金融发展历程　/ 38
03 互联网金融的“天龙八部”　/ 42
互联网金融“天龙八部”第一部：传统金融机构金融信息化服务
互联网金融“天龙八部”第二部：互联网企业的金融服务
互联网金融“天龙八部”第三部：第三方支付（网络支付）
互联网金融“天龙八部”第四部：互联网理财服务
互联网金融“天龙八部”第五部：网络债权融资P2P/P2B模式
互联网金融“天龙八部”第六部：众筹融资
互联网金融“天龙八部”第七部：网络货币
互联网金融“天龙八部”第八部：互联网金融服务系统
04 互联网金融商业模式有何不同？　/ 51
什么是互联网金融的商业模式？
传统的互联网商业模式有哪些？
互联网金融商业模式与传统互联网商业模式有何不同？
05 互联网金融的价值在哪里？　/ 57
互联网金融商业模式立足之本
互联网金融是颠覆者吗？
第三章　互联网金融商业模式之一：传统金融机构的互联网化　/ 61
传统金融机构最早触网，但最初形态只是利用互联网改善服务。随着进一步发展，传统金融机构新型互联网平台已经开始利用互联网从事更多元的深层次金融服务以及管理风险，由此成为互联网金融的代表性模式之一。
01 传统金融机构互联网化路径　/ 62
传统金融
传统金融互联网化之路通向何方？
02 传统金融机构互联网化的类型　/ 65
传统金融机构利用互联网技术将原有的部分业务在线化
传统金融机构开展的网络借贷业务
传统金融机构跨界电子商务
03 传统金融机构互联网化的商业模式　/ 71
传统金融机构利用互联网技术将原有的部分业务在线化
商业模式分析
传统金融机构开展的网络借贷业务商业模式分析
传统金融机构跨界电子商务商业模式分析
04 传统金融机构互联网化的趋势与方向　/ 81
第四章　互联网金融商业模式之二：互联网企业的金融服务　/ 83
互联网企业走向金融服务是必然的，通过金融服务既可以将基于平台形成的供应链和大数据资产转化为金融服务基础资源，以增加高额的金融服务收益，又可扩大平台的交易量，以增加平台服务收入。
01 互联网企业金融服务的类型　/ 84
电商金融
其他互联网企业的金融服务
02 互联网企业金融服务的商业模式　/ 88
客户/市场需求（痛点）
关键资源及流程（业务模式）
商业价值
盈利模式
第五章　互联网金融商业模式之三：第三方网络融资平台　/ 91
既非传统金融机构又非互联网企业的“草根”，基于互联网建立的众筹融资、P2P等互联网金融服务平台在客观上催生了互联网新商业模式——第三方网络融资平台的诞生。而P2P与众筹融资也是未来最具创新和发展潜力的两类互联网金融业态。
01 第三方网络融资平台的主要业态　/ 92
P2P/P2B模式
众筹融资
网络票据融资或保理融资平台
02 第三方网络融资平台的商业模式　/ 106
客户/市场需求（痛点）
关键资源及流程（业务模式）
商业价值
盈利模式
第六章　互联网金融商业模式之四：互联网金融基础服务平台　/ 111
互联网金融基础服务对互联网金融的发展至关重要，它将促进互联网金融健康有序地发展。尤其是互联网金融资产转让与处置、互联网金融信息服务以及互联网金融征信系统等业态是互联网金融的重要基础设施。
01 概述　/ 112
02 互联网金融基础服务的主要业态　/ 114
第三方支付（网络支付）
互联网金融信息搜索比价服务平台
互联网金融征信系统
互联网货币——新型的互联网金融结算工具
互联网金融转让交易服务平台（债权转让交易，应收账款交易，
网络货币交易）
03 互联网金融基础服务的商业模式　/ 120
客户/市场需求（痛点）
关键资源及流程（业务模式）
商业价值
盈利模式
第七章　互联网金融的架构之一：交易架构　/ 125
商业模式是利益相关者的交易架构，交易架构也是实现商业目的的重要流程。搭建好互联网金融交易架构是互联网金融服务平台首要工作。
01 什么是互联网金融架构？　/ 126
02 交易架构　/ 128
交易架构设计的原则
互联网金融的基本交易架构
第八章　互联网金融的架构之二：风控架构　/ 133
金融的核心竞争力是风险控制，对互联网金融而言尤其如此。未来互联网金融的竞争将是风控能力的竞争。因此，风控架构设计事关互联网金融服务平台的存亡。
01 担保增信式风控架构　/ 135
02 资信评级风控架构　/ 137
第九章　互联网金融的架构之三：法律架构（上）　/ 141
互联网金融属于新金融，其发展往往超前于法律法规的制定，由此造成部分互联网金融业态或模式与现行法律法规存在一定的冲突，而这些冲突将直接导致互联网金融触摸“红线”。因此，法律政策风险将是互联网金融目前面临的最大风险。
01 互联网金融法律架构的重要性　/ 142
02 互联网金融在中国可能面临的法律风险　/ 145
刑事法律风险
行政违法法律风险
民事法律风险
第十章　互联网金融的架构之三：法律架构（下）　/ 159
在针对互联网金融的专门的监管政策法规尚未出台之前，应当严格遵守监管部门确定的3条政策法律红线、4条经营底线，尽可能避免由此而产生的法律风险。
01 国内外互联网金融监管的法律体系　/ 160
英美等国互联网金融监管体系
国内互联网金融监管体系
02 互联网金融法律架构设计　/ 172
法律架构设计的方法与流程
法律架构设计核心——如何避开互联网金融法律风险？
第十一章　互联网金融的架构之四：技术架构　/ 183
互联网金融不是简单的“触网”，也不是将传统金融服务搬到网上，而是充分利用互联网新技术、新方法、新思维等聚合金融需求，以及撮合交易和管理金融风险。
01 互联网金融的技术基础　/ 184
02 互联网金融的技术架构　/ 188
互联网金融技术架构设计原则
互联网金融技术架构设计的方法与流程
第十二章　发现互联网金融商业新模式　/ 191
互联网金融绝非昙花一现，它将成为未来互联网最为重要的商业模式之一。随着新的互联网技术及新型金融需求出现，未来将会不断诞生新型的互联网金融新模式、新业态。
01 国内互联网金融商业模式观察　/ 192
互联网企业金融服务平台代表：阿里巴巴布局大金融
传统银行新型互联网平台代表：民生电商
债权转让式P2P平台代表：宜信
纯中介P2P模式（点对点）代表：拍拍贷
产品众筹模式的代表：点名时间
股权众筹代表：天使汇
线下众筹模式代表：3W众筹咖啡馆
互联网金融信息服务代表：91金融超市
02 发现新模式　/ 206
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>互联网金融商业模式与架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Web Services技术、架构和应用
第1章  Web Services, 第三次革命	1
1.1  Web Services的兴起	1
1.2  Web Services规范	2
1.3  Web Services技术平台	4
1.4  市场趋势	6

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Web Services技术、架构和应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深度探索嵌入式操作系统
前言
第1章　操作系统的功能及为什么需要它1
1.1从hello world开始1
1.2　操作系统功能演进3
1.3　小结7
第2章　硬件平台8
2.1　选择平台8
2.1.1　mini24408
2.1.2　mini2440平台的信息9
2.2　必须要关注的硬件13
2.2.1　原因14
2.2.2　RTC15
2.2.3　定时器16
2.2.4　串口17
2.2.5　中断控制器18
2.2.6　SDRAM19
2.2.7　Norflash23
2.2.8　Nandflash24
2.3　小结26
第3章　处理器28
3.1　ARM公司与其处理器28
3.2　ARM920T的结构与特性29
3.2.1　ARM920T CPU结构29
3.2.2　ARM920T CPU特性32
3.3　ARM920T存储体系33
3.3.1　ARM920T地址空间33
3.3.2　ARM920T存储器格式34
3.3.3　ARM920T存储地址对齐35
3.4　ARM920T 状态35
3.4.1　ARM状态36
3.4.2　Thumb 状态36
3.5　ARM920T处理器的7种工作模式37
3.6　寄存器38
3.7　异常和中断43
3.7.1　什么是异常和中断43
3.7.2　异常中断向量46
3.8　ARM920T指令集47
3.8.1　指令及其编码格式48
3.8.2　分支跳转指令50
3.8.3　数据处理指令53
3.8.4　装载和存储指令63
3.8.5　程序状态寄存器操作指令73
3.8.6　协处理器操作指令76
3.8.7　异常中断产生指令79
3.9　MMU80
3.9.1　MMU概述80
3.9.2　为什么要有MMU82
3.9.3　ARM920T CP15协处理器85
3.9.4　MMU 页表98
3.9.5　MMU页面访问权限的控制113
3.9.6　MMU的快表TLB113
3.9.7　MMU的编程接口114
3.10　Cache115
3.10.1　ARM920T的Cache115
3.10.2　Cache的原理116
3.10.3　Cache的类型及要注意的问题117
3.10.4　ARM920T Cache的编程接口119
3.11　小结120
第4章　操作系统内核的设计与构建122
4.1　操作系统内核的设计122
4.1.1　内核要完成的功能123
4.1.2　内核的架构124
4.1.3　分离硬件的相关性126
4.1.4　我们的选择127
4.2　开发环境及相关工具129
4.2.1　Linux环境129
4.2.2　文本编辑器132
4.2.3　GCC134
4.2.4　LD136
4.2.5　make139
4.3　LMOSEM的构建系统142
4.3.1　LMOSEM的makefile142
4.3.2　LMOSEM的链接脚本147
4.4　开发板的安装150
4.5　小结154
第5章　语言间调用约定与基本数据结构156
5.1　寄存器使用约定156
5.1.1　寄存器别名157
5.1.2　参数传递与返回值157
5.2　基本数据结构159
5.2.1　C语言的基本数据结构160
5.2.2　list_h_t数据结构161
5.2.3　spinlock_t数据结构164
5.2.4　kwlst_t数据结构165
5.2.5　sem_t数据结构166
5.3　数据结构存在于内存中的形式168
5.4　C与汇编的混用170
5.5　小结174
第6章　内核初始化175
6.1　开始175
6.1.1　第一行汇编代码175
6.1.2　第一个C函数178
6.2　MMU和中断向量的初始化181
6.2.1　初始化MMU181
6.2.2　复制中断向量186
6.3　串口初始化190
6.3.1　串口硬件190
6.3.2　内核的printf196
6.4　机器数据结构201
6.4.1　设计数据结构201
6.4.2　确定一些重要数据结构与内核的地址203
6.5　初级内存管理初始化205
6.5.1　设计一些数据结构205
6.5.2　初始化mmapdsc_t结构数组209
6.5.3　建立起内存分配数据结构212
6.6　中断初始化215
6.6.1　设计一些数据结构215
6.6.2　初始中断源描述符220
6.7　初始化测试222
6.8　小结225
第7章　内存管理226
7.1　内核功能层入口226
7.2　内存管理组件的设计228
7.3　块级内存管理229
7.3.1　块级内存管理数据结构视图229
7.3.2　块级内存管理接口230
7.3.3　主分配函数232
7.3.4　分配时查找alcfrelst_t 234
7.3.5　分配时查找和操作mmapdsc_t236
7.3.6　分配代码写得对吗239
7.3.7　主释放函数240
7.3.8　释放时查找alcfrelst_t 241
7.3.9　释放时查找和操作mmapdsc_t242
7.3.10　测试块级内存管理层246
7.4　页级内存管理248
7.4.1　页级内存管理接口及调用流程248
7.4.2　相关的数据结构251
7.4.3　页级内存管理初始化254
7.4.4　分配主函数256
7.4.5　分配时查找mplhead_t257
7.4.6　分配时新建页级内存池258
7.4.7　分配时操作mplhead_t262
7.4.8　分配代码写得对吗263
7.4.9　释放主函数265
7.4.10　释放时查找mplhead_t266
7.4.11　释放时操作mplhead_t268
7.4.12　释放时删除页级内存池269
7.4.13　测试页级内存管理层271
7.5　字级内存管理273
7.5.1　字级内存接口及调用流程274
7.5.2　相关的数据结构275
7.5.3　分配主函数276
7.5.4　分配时查找mplhead_t278
7.5.5　分配时新建字级内存池279
7.5.6　分配时操作mplhead_t282
7.5.7　分配代码写得对吗283
7.5.8　释放主函数285
7.5.9　释放时查找mplhead_t285
7.5.10　释放时操作mplhead_t287
7.5.11　释放时删除字级内存池288
7.5.12　测试字级内存管理层289
7.6　小结292
第8章　中断管理293
8.1　中断与中断控制器293
8.1.1　什么是中断293
8.1.2　S3C2440A中断控制器294
8.2　中断管理的架构与相关数据结构298
8.2.1　中断管理的架构298
8.2.2　设计数据结构intfltdsc_t和intserdsc_t298
8.3　中断处理301
8.3.1　中断辅助例程301
8.3.2　从中断向量开始305
8.3.3　保存CPU上下文306
8.3.4　中断主分派例程310
8.3.5　确定中断源314
8.3.6　调用中断处理例程317
8.4　安装中断回调例程319
8.5　小结322
第9章　驱动模型323
9.1　操作系统内核如何管理设备323
9.1.1　分权而治323
9.1.2　设备类型325
9.1.3　驱动程序327
9.2　相关数据结构328
9.2.1　驱动329
9.2.2　派发例程类型329
9.2.3　设备ID330
9.2.4　设备331
9.2.5　IO包332
9.2.6　设备表333
9.3　驱动模型的基础设施335
9.3.1　驱动程序从哪里执行335
9.3.2　新建与注册设备340
9.3.3　注册回调函数344
9.3.4　发送IO包345
9.3.5　调用驱动程序函数346
9.3.6　等待服务347
9.3.7　完成服务350
9.3.8　驱动模型辅助函数352
9.4　systick驱动程序实例356
9.4.1　systick硬件356
9.4.2　systick驱动程序框架360
9.4.3　systick驱动程序实现362
9.4.4　测试systick驱动程序368
9.5　RTC驱动程序实例370
9.5.1　RTC硬件370
9.5.2　RTC驱动程序实现375
9.6　小结385
第10章　进程386
10.1　应用程序的运行386
10.1.1　程序运行需要什么资源387
10.1.2　任何时刻资源都可用吗388
10.1.3　提出多道程序模型389
10.2　相关的数据结构390
10.2.1　设计进程的数据结构391
10.2.2　调度进程表392
10.3　LMOSEM内核的第一个进程394
10.3.1　进程管理组件的初始化395
10.3.2　建立空转进程396
10.3.3　空转进程运行399
10.4　新建进程404
10.4.1　分配进程描述符404
10.4.2　分配内存空间406
10.4.3　加入进程调度表408
10.5　进程调度410
10.5.1　调度算法410
10.5.2　处理进程时间片411
10.5.3　检查调度状态414
10.5.4　选择进程415
10.5.5　进程切换418
10.5.6　进程等待与唤醒421
10.5.7　进程测试425
10.6　小结428
第11章　文件系统430
11.1　文件系统设计430
11.1.1　文件系统只是一个设备430
11.1.2　数据格式与存储块432
11.1.3　如何组织文件433
11.1.4　关于我们文件系统的限制434
11.2　相关的数据结构434
11.2.1　超级块435
11.2.2　位图435
11.2.3　目录437
11.2.4　文件管理头438
11.3　文件系统格式化440
11.3.1　建立超级块440
11.3.2　建立位图445
11.3.3　建立根目录448
11.4　文件系统基础操作452
11.4.1　获取与释放根目录文件453
11.4.2　字符串操作455
11.4.3　分解路径名457
11.4.4　检查文件是否存在459
11.5　文件操作460
11.5.1　新建文件461
11.5.2　删除文件463
11.5.3　打开文件466
11.5.4　读写文件469
11.5.5　关闭文件472
11.5.6　驱动整合473
11.6　文件系统测试475
11.6.1　格式化测试475
11.6.2　文件操作测试479
11.7　小结482
第12章　系统调用与应用程序库483
12.1　系统调用机制483
12.1.1　软中断指令484
12.1.2　传递系统调用参数486
12.1.3　系统调用分发器488
12.2　时间管理系统调用489
12.3　进程管理系统调用492
12.3.1　进程的运行与退出492
12.3.2　获取进程的ID494
12.4　内存管理系统调用496
12.5　设备与文件系统调用498
12.5.1　设备与文件的打开498
12.5.2　设备与文件的关闭506
12.5.3　设备与文件的读写508
12.5.4　设备与文件的控制512
12.6　应用程序库514
12.7　测试520
12.8　小结526
后记528
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深度探索嵌入式操作系统
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>可伸缩服务架构：框架与中间件
第1章  如何设计一款永不重复的高性能分布式发号器  1
1.1  可选方案及技术选型  2
1.1.1  为什么不用UUID  2
1.1.2  基于数据库的实现方案  2
1.1.3  Snowflake开源项目  3
1.1.4  小结  4
1.2  分布式系统对发号器的基本需求  4
1.3  架构设计与核心要点  6
1.3.1  发布模式  6
1.3.2  ID类型  7
1.3.3  数据结构  7
1.3.4  并发  9
1.3.5  机器ID的分配  9
1.3.6  时间同步  10
1.3.7  设计验证  11
1.4  如何根据设计实现多场景的发号器  11
1.4.1  项目结构  12
1.4.2  服务接口的定义  14
1.4.3  服务接口的实现  15
1.4.4  ID元数据与长整型ID的互相转换  22
1.4.5  时间操作  25
1.4.6  机器ID的生成  27
1.4.7  小结  32
1.5  如何保证性能需求  32
1.5.1  嵌入发布模式的压测结果  33
1.5.2  中心服务器发布模式的压测结果  33
1.5.3  REST发布模式（Netty实现）的压测结果  33
1.5.4  REST发布模式（Spring Boot + Tomcat实现）的压测结果  34
1.5.5  性能测试总结  34
1.6  如何让用户快速使用  35
1.6.1  REST发布模式的使用指南  35
1.6.2  服务化模式的使用指南  38
1.6.3  嵌入发布模式的使用指南  41
1.7  为用户提供API文档  43
1.7.1  RESTful API文档  44
1.7.2  Java API文档  45
第2章  可灵活扩展的消息队列框架的设计与实现  49
2.1  背景介绍  50
2.2  项目目标  50
2.2.1  简单易用  50
2.2.2  高性能  51
2.2.3  高稳定性  51
2.3  架构难点  51
2.3.1  线程模型  51
2.3.2  异常处理  53
2.3.3  优雅关机  53
2.4  设计与实现  54
2.4.1  项目结构  54
2.4.2  项目包的规划  55
2.4.3  生产者的设计与实现  57
2.4.4  消费者的设计与实现  58
2.4.5  启动模块的设计与实现  67
2.4.6  消息处理器的体系结构  76
2.4.7  反射机制  79
2.4.8  模板项目的设计  80
2.5  使用指南  82
2.5.1  安装步骤  82
2.5.2  Java API  83
2.5.3  与Spring环境集成  84
2.5.4  对服务源码进行注解  85
2.6  API简介  87
2.6.1  Producer API  87
2.6.2  Consumer API  88
2.6.3  消息处理器  88
2.6.4  消息处理器定义的注解  90
2.7  消息处理机模板项目  91
2.7.1  快速开发向导  91
2.7.2  后台监控和管理  92
第3章  轻量级的数据库分库分表架构与框架  93
3.1  什么是分库分表  94
3.1.1  使用数据库的三个阶段  94
3.1.2  在什么情况下需要分库分表  95
3.1.3  分库分表的典型实例  96
3.2  三种分而治之的解决方案  97
3.2.1  客户端分片  97
3.2.2  代理分片  100
3.2.3  支持事务的分布式数据库  101
3.3  分库分表的架构设计  102
3.3.1  整体的切分方式  102
3.3.2  水平切分方式的路由过程和分片维度  106
3.3.3  分片后的事务处理机制  107
3.3.4  读写分离  119
3.3.5  分库分表引起的问题  119
3.4  流行代理分片框架Mycat的初体验  123
3.4.1  安装Mycat  123
3.4.2  配置Mycat  124
3.4.3  配置数据库节点  128
3.4.4  数据迁移  129
3.4.5  Mycat支持的分片规则  129
3.5  流行的客户端分片框架Sharding JDBC的初体验  138
3.5.1  Sharding JDBC简介  138
3.5.2  Sharding JDBC的功能  139
3.5.3  Sharding JDBC的使用  141
3.5.4  Sharding JDBC的使用限制  152
3.6  自研客户端分片框架dbsplit的设计、实现与使用  153
3.6.1  项目结构  154
3.6.2  包结构和执行流程  155
3.6.3  切片下标命名策略  159
3.6.4  SQL解析和组装  167
3.6.5  SQL实用程序  168
3.6.6  反射实用程序  173
3.6.7  分片规则的配置  177
3.6.8  支持分片的SplitJdbcTemplate和SimpleSplitJdbcTemplate接口API  179
3.6.9  JdbcTemplate的扩展SimpleJdbcTemplate接口API  184
3.6.10  用于创建分库分表数据库的脚本工具  187
3.6.11  使用dbsplit的一个简单示例  192
3.6.12  使用dbsplit的线上真实示例展示  199
第4章  缓存的本质和缓存使用的优秀实践  201
4.1  使用缓存的目的和问题  202
4.2  自相似，CPU的缓存和系统架构的缓存  203
4.2.1  CPU缓存的架构及性能  205
4.2.2  CPU缓存的运行过程分析  206
4.2.3  缓存行与伪共享  208
4.2.4  从CPU的体系架构到分布式的缓存架构  218
4.3  常用的分布式缓存解决方案  221
4.3.1  常用的分布式缓存的对比  221
4.3.2  Redis初体验  225
4.4  分布式缓存的通用方法  229
4.4.1  缓存编程的具体方法  229
4.4.2  应用层访问缓存的模式  233
4.4.3  分布式缓存分片的三种模式  235
4.4.4  分布式缓存的迁移方案  238
4.4.5  缓存穿透、缓存并发和缓存雪崩  244
4.4.6  缓存对事务的支持  246
4.5  分布式缓存的设计与案例  248
4.5.1  缓存设计的核心要素  248
4.5.2  缓存设计的优秀实践  250
4.5.3  关于常见的缓存线上问题的案例  253
4.6  客户端缓存分片框架redic的设计与实现  257
4.6.1  什么时候需要redic  258
4.6.2  如何使用redic  258
4.6.3  更多的配置  258
4.6.4  项目结构  260
4.6.5  包结构  261
4.6.6  设计与实现的过程  261
第5章  大数据利器之Elasticsearch  268
5.1  Lucene简介  269
5.1.1  核心模块  269
5.1.2  核心术语  270
5.1.3  检索方式  271
5.1.4  分段存储  273
5.1.5  段合并策略  275
5.1.6  Lucene相似度打分  278
5.2  Elasticsearch简介  286
5.2.1  核心概念  286
5.2.2  3C和脑裂  289
5.2.3  事务日志  291
5.2.4  在集群中写索引  294
5.2.5  集群中的查询流程  295
5.3  Elasticsearch实战  298
5.3.1  Elasticsearch的配置说明  298
5.3.2  常用的接口  300
5.4  性能调优  305
5.4.1  写优化  305
5.4.2  读优化  308
5.4.3  堆大小的设置  313
5.4.4  服务器配置的选择  315
5.4.5  硬盘的选择和设置  316
5.4.6  接入方式  318
5.4.7  角色隔离和脑裂  319
第6章  全面揭秘分布式定时任务  321
6.1  什么是定时任务  322
6.2  分布式定时任务  341
6.2.1  定时任务的使用场景  342
6.2.2  传统定时任务存在的问题  342
6.2.3  分布式定时任务及其原理  344
6.3  开源分布式定时任务的用法  347
6.3.1  Quartz的分布式模式  347
6.3.2  TBSchedule  356
6.3.3  Elastic-Job  365
第7章  RPC服务的发展历程和对比分析  377
7.1  什么是RPC服务  378
7.2  RPC服务的原理  379
7.2.1  Sokcet套接字  379
7.2.2  RPC的调用过程  380
7.3  在程序中使用RPC服务  382
7.4  RPC服务的发展历程  383
7.4.1  第一代RPC：以ONC RPC和DCE RPC为代表的函数式RPC  384
7.4.2  第二代RPC：支持面对象的编程  388
7.4.3  第三代RPC：SOA和微服务  398
7.4.4  架构的演进  402
7.5  主流的RPC框架  403
7.5.1  Thrift  403
7.5.2  ZeroC Ice  410
7.5.3  gRPC  418
7.5.4  Dubbo  430
第8章  Dubbo实战及源码分析  436
8.1  Dubbo的四种配置方式  437
8.1.1  XML配置  437
8.1.2  属性配置  440
8.1.3  API配置  441
8.1.4  注解配置  443
8.2  服务的注册与发现  446
8.2.1  注册中心  446
8.2.2  服务暴露  449
8.2.3  引用服务  451
8.3  Dubbo通信协议及序列化探讨  455
8.3.1  Dubbo支持的协议  455
8.3.2  协议的配置方法  456
8.3.3  多协议暴露服务  457
8.3.4  Dubbo协议的使用注意事项  458
8.3.5  Dubbo协议的约束  459
8.4  Dubbo中高效的I/O线程模型  459
8.4.1  对Dubbo中I/O模型的分析  459
8.4.2  Dubbo中线程配置的相关参数  460
8.4.3  在Dubbo线程方面踩过的坑  461
8.4.4  对Dubbo中线程使用的建议  462
8.5  集群的容错机制与负载均衡  462
8.5.1  集群容错机制的原理  462
8.5.2  集群容错模式的配置方法  464
8.5.3  六种集群容错模式  464
8.5.4  集群的负载均衡  465
8.6  监控和运维实践  467
8.6.1  日志适配  467
8.6.2  监控管理后台  467
8.6.3  服务降级  473
8.6.4  优雅停机  475
8.6.5  灰度发布  475
8.7  Dubbo项目线上案例解析  477
8.7.1  线上问题的通用解决方案  477
8.7.2  耗时服务耗尽了线程池的案例  480
8.7.3  容错重试机制引发服务雪崩的案例  481
8.8  深入剖析Dubbo源码及其实现  483
8.8.1  Dubbo的总体架构设计  483
8.8.2  配置文件  486
8.8.3  Dubbo的核心RPC  488
8.8.4  Dubbo巧妙的URL总线设计  491
8.8.5  Dubbo的扩展点加载SPI  492
8.8.6  Dubbo服务暴露的过程  493
8.8.7  服务引用  502
8.8.8  集群容错和负载均衡  503
8.8.9  集群容错  504
8.8.10  负载均衡  509
第9章  高性能网络中间件  512
9.1  TCP/UDP的核心原理及本质探索  513
9.1.1  网络模型  513
9.1.2  UDP、IP及其未解决的问题  515
9.1.3  TCP详解  519
9.1.4  是否可以用UDP代替TCP  527
9.1.5  网络通信的不可靠性讨论  529
9.2  网络测试优秀实践  530
9.2.1  网络测试的关键点  530
9.2.2  那些必不可少的网络测试工具  532
9.2.3  典型的测试报告  539
9.3  高性能网络框架的设计与实现  544
9.3.1  对代理功能的测试及分析  545
9.3.2  网络中间件的使用介绍  549
9.3.3  内存和缓存的优化  551
9.3.4  快速解析流数据  554
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>可伸缩服务架构：框架与中间件
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>新一代银行IT架构
目录
前言
第1章　引言  / 1
1.1　全球商业银行信息科技运用的发展  / 1
1.2　“互联网+”战略下的中国商业银行面临的挑战  / 3
1.2.1　拥抱“互联网+”，普惠金融带来银行IT新挑战  / 3
1.2.2　跨界融合，寻找平衡点  / 4
1.2.3　关系国计民生，银行技术安全可控提上议事日程  / 6
1.3　基于安全可控技术构建新一代银行IT架构  / 6
1.3.1　新挑战  / 6
1.3.2　架构关注点  / 8
第2章　分布式架构理论及典型实践  / 11
2.1　CAP理论  / 12
2.2　分布式架构典型技术介绍  / 13
2.2.1　分布式数据库  / 14
2.2.2　分布式缓存  / 21
2.2.3　分布式存储  / 24
2.2.4　分布式消息总线  / 31
2.2.5　分布式负载均衡网关  / 35
第3章　当前主流的IT架构分析  / 43
3.1　集中式松耦合架构理论和实践  / 44
3.1.1　耦合性架构  / 44
3.1.2　集中式架构  / 48
3.1.3　从集中式紧耦合架构到集中式松耦合架构  / 50
3.2　互联网行业高性能的有损服务  / 52
3.2.1　从集中式到分布式  / 52
3.2.2　从ACID到CAP/BASE  / 54
3.2.3　分布式架构在互联网行业中的典型应用  / 59
3.3　对新一代银行IT架构的匹配性分析  / 62
3.3.1　传统银行IT架构面临的困难和挑战  / 63
3.3.2　新一代银行采用互联网分布式架构的可行性  / 64
3.3.3　新一代银行如何实现核心业务系统的技术转型  / 67
第4章　新一代银行IT架构分析  / 69
4.1　设计原则  / 69
4.1.1　高性能  / 70
4.1.2　高弹性  / 71
4.1.3　高可用性  / 72
4.1.4　高规范性  / 72
4.1.5　低成本  / 73
4.1.6　低风险  / 75
4.2　与当前主流架构的对比  / 75
4.2.1　分布式松耦合架构  / 76
4.2.2　分布式单主多副本架构  / 80
4.3　新一代架构概念模型解析  / 84
4.3.1　分布式松耦合一主多从多副本强一致架构  / 84
4.3.2　新一代架构的关键概念定义  / 86
4.4　实施成果  / 88
第5章　新一代银行IT架构实践  / 89
5.1　微众银行的安全可控技术实践  / 89
5.1.1　实施理念  / 89
5.1.2　整体技术堆栈  / 93
5.1.3　核心技术介绍  / 95
5.2　解构微众银行新一代互联网架构  / 104
5.2.1　架构总览  / 104
5.2.2　关键技术难点分析  / 110
5.2.3　以客户为单位的分布式架构  / 118
5.2.4　通过安全可控技术构建新一代应用架构  / 122
第6章　新一代架构下的运维管理  / 128
6.1　新一代架构下的运维管理体系  / 128
6.1.1　运维管理体系介绍  / 128
6.1.2　体系架构  / 129
6.2　体系关键点  / 131
6.2.1　运维闭环  / 131
6.2.2　高可用资源分配  / 132
6.2.3　灵活可配的IT服务管理  / 132
6.2.4　运维流程方法及指引  / 134
6.2.5　灰度发布机制  / 135
6.3　体系的关键工具系统  / 136
6.3.1　DE专家设计工具  / 136
6.3.2　ITSM IT服务管理系统  / 136
6.3.3　IRAA智能资源管家  / 137
6.3.4　CMDB配置管理数据库  / 138
6.3.5　AOMP 自动化运维平台  / 139
6.3.6　IMS监控  / 140
6.3.7　WeDOS云平台管理系统  / 141
6.4　系统效能  / 143
6.5　服务治理  / 143
6.5.1　服务治理的简介  / 143
6.5.2　分布式架构下的服务治理  / 144
6.5.3　服务的生命周期管理  / 151
第7章　架构效能分析  / 155
7.1　架构特性的实现效果  / 155
7.1.1　高性能  / 156
7.1.2　高可用性  / 156
7.1.3　高规范性  / 159
7.1.4　高可扩展性  / 161
7.1.5　低成本  / 163
7.1.6　低风险  / 163
7.2　架构效能  / 165
7.2.1　经济效益  / 165
7.2.2　社会效益  / 169
后记  / 172
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>新一代银行IT架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算解码
第1章  云计算的基本概念/1  1.1  云计算：第三次IT革命/2  1.2  云计算的特征/4  1.3  云计算服务/6  1.4  云计算的类型/8  1.5  云计算对信息产业的影响/9第2章  云计算的整体架构/12  2.1  云计算的系统架构/13    2.1.1  传统的PC系统架构/13    2.1.2  云计算的系统架构/15  2.2  云计算的分层体系/18    2.2.1  IaaS服务及其实现体系/19    2.2.2  PaaS服务及其实现体系/22    2.2.3  SaaS服务及其实现体系/24    2.2.4  云计算分层体系综述/26第3章  基础设施即服务（IaaS）及其关键实现技术/28  3.1  IaaS概述/29  3.2  IaaS关键实现技术之服务器虚拟化/30    3.2.1  服务器虚拟化概述/31    3.2.2  CPU虚拟化/33    3.2.3  内存虚拟化/37    3.2.4  I/O虚拟化/39  3.3  IaaS关键实现技术之存储虚拟化/40    3.3.1  存储系统概述/40    3.3.2  存储设备层的存储虚拟化/42    3.3.3  块聚合层的存储虚拟化/43    3.3.4  文件/记录层的存储虚拟化/47  3.4  IaaS关键实现技术之网络虚拟化/48    3.4.1  网络虚拟化概述/48    3.4.2  传统的网络虚拟化技术/50    3.4.3  主机网络虚拟化技术/51    3.4.4  网络设备虚拟化的实现/55    3.4.5  运营服务中的网络虚拟化关键技术/58  3.5  IaaS关键实现技术之云计算管理平台/63    3.5.1  自动化部署技术/65    3.5.2  弹性能力提供技术/67    3.5.3  资源监控/68    3.5.4  资源调度/71    3.5.5  业务服务管理和计费度量管理/73  3.6  典型的IaaS提供商——Amazon/75    3.6.1  Amazon云计算服务简介/75    3.6.2  弹性云计算/76第4章  平台即服务（PaaS）及其关键实现技术/81  4.1  PaaS概述/82    4.1.1  PaaS系统架构/83    4.1.2  Google PaaS系统概述/86  4.2  PaaS应用运行托管平台/88    4.2.1  典型的PaaS应用运行托管平台——App Engine/89    4.2.2  PaaS应用运行托管平台的关键技术/102  4.3  基于分布式计算的PaaS基础设施/111    4.3.1  分布式计算技术及实现原则/112    4.3.2  PaaS关键技术之分布式文件系统/118    4.3.3  PaaS关键技术之分布式数据库/126    4.3.4  PaaS关键技术之MapReduce计算模型/132    4.3.5  PaaS关键技术之分布式协同管理技术/135    4.3.6  PaaS关键技术之集群和平台管理/139  4.4  主流PaaS平台及流派分析/147    4.4.1  IaaS衍生型/149    4.4.2  传统生态延伸型/150    4.4.3  SaaS拓展型/150    4.4.4  革新生态型/151第5章  软件即服务（SaaS）及其关键实现技术/153  5.1  SaaS概述/154  5.2  呈现层技术/159    5.2.1  为什么Web呈现层技术对SaaS如此重要/159    5.2.2  基于浏览器的Web呈现技术/162    5.2.3  基于插件方式的Web呈现技术/167    5.2.4  HTML5和Flash技术路线的比较/168  5.3  调度层技术/169    5.3.1  基于DNS的调度/170    5.3.2  基于虚拟IP的调度/170    5.3.3  基于链路聚合的调度/171    5.3.4  基于应用的调度/172    5.3.5  调度策略/172  5.4  业务层/174  5.5  数据层/175  5.6  用户管理和配置管理/177    5.6.1  用户管理/177    5.6.2  个性化配置/181  5.7  典型的SaaS服务提供商/187    5.7.1  Salesforce服务简介/187    5.7.2  Sales Cloud CRM服务及特征/190第6章  云计算对产业的影响/197  6.1  云计算发展的驱动因素/198  6.2  云计算是一种破坏性创新/201  6.3  两大产业阵营——互联网云和IT云/203    6.3.1  以Google为典型代表的互联网云计算/203    6.3.2  以IBM为代表的IT云计算/207  6.4  两大技术流派——分布式架构和虚拟化架构/212    6.4.1  分布式架构/213    6.4.2  虚拟化架构/215  6.5  两大主流市场——公有云和私有云/218第7章  云计算发展展望/221  7.1  云计算发展展望/222    7.1.1  云计算与移动互联网的关系/224    7.1.2  云计算与物联网、“智慧地球”的关系/226  7.2  云计算的研究热点和焦点/228    7.2.1  云操作系统/228    7.2.2  云安全/231    7.2.3  节能减排技术/234  7.3  云计算成功的关键因素/238    7.3.1  技术是云计算成功的基础/238    7.3.2  商业模式是云计算成功的关键/241    7.3.3  运营能力是云计算成功的必要条件/243  7.4  对云计算产业发展的建议/244第8章  电信运营商与云计算/247  8.1  云计算的基本经济规律及产业链分析/248    8.1.1  互联网的本质和基本经济规律/249    8.1.2  云计算产业链分析/254  8.2  电信运营商在云计算时代面临的机遇和挑战/258    8.2.1  云计算给电信运营商带来的机遇/258    8.2.2  云计算时代电信运营商面临的新挑战/260  8.3  电信运营商发展云计算的优势及其产业角色分析/263    8.3.1  电信运营商发展云计算的优势/263    8.3.2  电信运营商在云计算产业链中的定位/266  8.4  国内外电信运营商在云计算方面的实践和探索/268    8.4.1  AT＆T的云计算服务/269    8.4.2  Verizon的Computing as a Service服务/271    8.4.3  法国电信的Flexible 4 Business/273    8.4.4  英国电信的Virtual Data Center服务/274    8.4.5  中国电信的综合信息服务云/275    8.4.6  中国移动的BigCloud系统/276    8.4.7  中国联通的互联云/277    8.4.8  电信运营商发展云计算的现状综述/278参考文献/279
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算解码
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>性能之巅
第1 章 绪论 ...................................................................................... 1
1.1 系统性能 ............................................................................................ 1
1.2 人员 ................................................................................................2
1.3 事情 ................................................................................................3
1.4 视角 ................................................................................................4
1.5 性能是充满挑战的 ...................................................................................... 4
1.5.1 性能是主观的 ........................................................................................................... 4
1.5.2 系统是复杂的 ........................................................................................................... 5
1.5.3 可能有多个问题并存 ............................................................................................... 6
1.6 延时 .................................................................................... 6
1.7 动态跟踪 ......................................................................................................... 7
1.8 云计算 ........................................................................................................... 8
1.9 案例研究 ....................................................................................................... 8
1.9.1 缓慢的磁盘 ............................................................................................................... 9
1.9.2 软件变更 ................................................................................................................. 10
1.9.3 更多阅读 ................................................................................................................. 12
第2 章 方法 .............................................................................................................. 13
2.1 术语 .................................................................................................................. 14
2.2 模型 .......................................................................................................... 14
2.2.1 受测系统 ................................................................................................................. 15
2.2.2 排队系统 ................................................................................................................. 15
2.3 概念 ........................................................................................................... 16
2.3.1 延时 ......................................................................................................................... 16
2.3.2 时间量级 ................................................................................................................. 17
2.3.3 权衡三角 ................................................................................................................. 18
2.3.4 调整的影响 ............................................................................................................. 19
2.3.5 合适的层级 ............................................................................................................. 19
2.3.6 性能建议的时间点 ................................................................................................. 20
2.3.7 负载vs.架构 ............................................................................................................ 20
2.3.8 扩展性 ..................................................................................................................... 21
2.3.9 已知的未知 ............................................................................................................. 22
2.3.10 指标 ....................................................................................................................... 23
2.3.11 使用率 ................................................................................................................... 24
2.3.12 饱和度 ................................................................................................................... 25
2.3.13 剖析 ....................................................................................................................... 26
2.3.14 缓存 ....................................................................................................................... 26
2.4 视角 ............................................................................................................. 28
2.4.1 资源分析 ................................................................................................................. 28
2.4.2 工作负载分析 ......................................................................................................... 29
2.5 方法 .......................................................................................................... 30
2.5.1 街灯反方法 ............................................................................................................. 31
2.5.2 随机变动反方法 ..................................................................................................... 32
2.5.3 责怪他人反方法 ..................................................................................................... 32
2.5.4 ad hoc 核对清单法 .................................................................................................. 33
2.5.5 问题陈述法 ............................................................................................................. 33
2.5.6 科学法 ..................................................................................................................... 34
2.5.7 诊断循环 ................................................................................................................. 35
2.5.8 工具法 ..................................................................................................................... 35
2.5.9 USE 方法 .................................................................................................................. 36
2.5.10 工作负载特征归纳 ............................................................................................... 42
2.5.11 向下挖掘分析 ....................................................................................................... 43
2.5.12 延时分析 ............................................................................................................... 44
2.5.13 R 方法 ................................................................................................................... 45
2.5.14 事件跟踪 ............................................................................................................... 45
2.5.15 基础线统计 ........................................................................................................... 47
2.5.16 静态性能调整 ....................................................................................................... 47
2.5.17 缓存调优 ............................................................................................................... 47
2.5.18 微基准测试 ........................................................................................................... 48
2.6 建模 ...................................................................................................... 49
2.6.1 企业vs.云 ................................................................................................................ 49
2.6.2 可视化识别 ............................................................................................................. 49
2.6.3 Amdahl 扩展定律 ................................................................................................... 51
2.6.4 通用扩展定律 ......................................................................................................... 52
2.6.5 排队理论 ................................................................................................................. 52
2.7 容量规划 ...................................................................................................... 56
2.7.1 资源极限 ................................................................................................................. 56
2.7.2 因素分析 ................................................................................................................. 58
2.7.3 扩展方案 ................................................................................................................. 58
2.8 统计 .................................................................................................. 59
2.8.1 量化性能 ................................................................................................................. 59
2.8.2 平均值 ..................................................................................................................... 60
2.8.3 标准方差、百分位数、中位数 ............................................................................. 61
2.8.4 变异系数 ................................................................................................................. 62
2.8.5 多重模态分布 ......................................................................................................... 62
2.8.6 异常值 ..................................................................................................................... 63
2.9 监视 ................................................................................................... 63
2.9.1 基于时间的规律 ..................................................................................................... 63
2.9.2 监测产品 ................................................................................................................. 65
2.9.3 启动以来的信息统计 ............................................................................................. 65
2.10 可视化 .................................................................................................. 65
2.10.1 线图 ....................................................................................................................... 65
2.10.2 散点图 ................................................................................................................... 66
2.10.3 热图 ....................................................................................................................... 67
2.10.4 表面图 ................................................................................................................... 68
2.10.5 可视化工具 ........................................................................................................... 69
2.11 练习 .................................................................................................. 70
2.12 参考 ............................................................................................................ 70
第3 章 操作系统 .......................................................................................... 72
3.1 术语 ............................................................................................................ 72
3.2 背景 ................................................................................................................... 73
3.2.1 内核 ......................................................................................................................... 73
3.2.2 栈 ............................................................................................................................. 76
3.2.2 中断和中断线程 ..................................................................................................... 77
3.2.4 中断优先级 ............................................................................................................. 78
3.2.5 进程 ......................................................................................................................... 78
3.2.6 系统调用 ................................................................................................................. 80
3.2.7 虚拟内存 ................................................................................................................. 82
3.2.8 内存管理 ................................................................................................................. 82
3.2.9 调度器 ..................................................................................................................... 83
3.2.10 文件系统 ............................................................................................................... 84
3.2.11 缓存 ....................................................................................................................... 86
3.2.12 网络 ....................................................................................................................... 87
3.2.13 设备驱动 ............................................................................................................... 87
3.2.14 多处理器 ............................................................................................................... 87
3.2.15 抢占 ....................................................................................................................... 88
3.2.16 资源管理 ............................................................................................................... 88
3.2.17 观测性 ................................................................................................................... 89
3.3 内核 ................................................................................................................ 89
3.3.1 UNIX ................................................................................................... 90
3.3.2 基于Solaris ............................................................................................................. 90
3.3.3 基于Linux ............................................................................................................... 93
3.3.4 差异 ......................................................................................................................... 95
3.4 练习 ............................................................................................................. 96
3.5 参考 ....................................................................................................... 96
第4 章 观测工具 ....................................................................................... 98
4.1 工具类型 .................................................................................................. 98
4.1.1 计数器 ..................................................................................................................... 99
4.1.2 跟踪 ....................................................................................................................... 100
4.1.3 剖析 ....................................................................................................................... 101
4.1.4 监视（sar） ........................................................................................................... 102
4.2 观测来源 ....................................................................................................... 103
4.2.1 /proc ....................................................................................................................... 103
4.2.2 /sys ......................................................................................................................... 108
4.2.3 kstat ........................................................................................................................ 109
4.2.4 延时核算 ............................................................................................................... 111
4.2.5 微状态核算 ........................................................................................................... 112
4.2.6 其他的观测源 ....................................................................................................... 112
4.3 DTrace .................................................................................................... 114
4.3.1 静态和动态跟踪 ................................................................................................... 115
4.3.2 探针 ....................................................................................................................... 116
4.3.3 provider .................................................................................................................. 116
4.3.4 参数 ....................................................................................................................... 117
4.3.5 D 语言 ................................................................................................................... 117
4.3.6 内置变量 ............................................................................................................... 118
4.3.7 action ..................................................................................................................... 118
4.3.8 变量类型 ............................................................................................................... 119
4.3.9 单行命令 ............................................................................................................... 121
4.3.10 脚本 ..................................................................................................................... 121
4.3.11 开销 ..................................................................................................................... 122
4.3.12 文档和资源 ......................................................................................................... 123
4.4 SystemTap ................................................................................................... 124
4.4.1 探针 ....................................................................................................................... 124
4.4.2 tapset ...................................................................................................................... 125
4.4.3 action 和内置变量................................................................................................. 125
4.4.4 示例 ....................................................................................................................... 125
4.4.5 开销 ....................................................................................................................... 127
4.4.6 文档和资源 ........................................................................................................... 128
4.5 perf ......................................................................................................................... 128
4.6 观测工具的观测 .............................................................................................. 129
4.7 练习 .............................................................................................................. 130
4.8 参考 .............................................................................................................. 130
第5 章 应用程序 ............................................................................................. 131
5.1 应用程序基础 ................................................................................................ 131
5.1.1 目标 ....................................................................................................................... 132
5.1.2 常见情况的优化 ................................................................................................... 133
5.1.3 观测性 ................................................................................................................... 134
5.1.4 大O 标记法 .......................................................................................................... 134
5.2 应用程序性能技术 ........................................................................................... 135
5.2.1 选择I/O 尺寸 ........................................................................................................ 135
5.2.2 缓存 ....................................................................................................................... 136
5.2.3 缓冲区 ................................................................................................................... 136
5.2.4 轮询 ....................................................................................................................... 136
5.2.5 并发和并行 ........................................................................................................... 137
5.2.6 非阻塞I/O ............................................................................................................. 139
5.2.7 处理器绑定 ........................................................................................................... 139
5.3 编程语言 ......................................................................................................... 140
5.3.1 编译语言 ............................................................................................................... 140
5.3.2 解释语言 ............................................................................................................... 141
5.3.3 虚拟机 ................................................................................................................... 142
5.3.4 垃圾回收 ............................................................................................................... 142
5.4 方法和分析 ................................................................................................ 143
5.4.1 线程状态分析 ....................................................................................................... 143
5.4.2 CPU 剖析 .............................................................................................................. 146
5.4.3 系统调用分析 ....................................................................................................... 148
5.4.4 I/O 剖析 ................................................................................................................. 154
5.4.5 工作负载特征归纳 ............................................................................................... 155
5.4.6 USE 方法 ............................................................................................................... 155
5.4.7 向下挖掘法 ........................................................................................................... 156
5.4.8 锁分析 ...................................................................................................... 156
5.4.9 静态性能调优 ................................................................................. 159
5.5 练习 ......................................................................................................... 160
5.6 参考 ...................................................................................................... 161
第6 章 CPU ............................................................................................. 162
6.1 术语 ..................................................................................................... 163
6.2 模型 ........................................................................................................ 163
6.2.1 CPU 架构 .............................................................................................................. 163
6.2.2 CPU 内存缓存 ...................................................................................................... 164
6.2.3 CPU 运行队列 ...................................................................................................... 165
6.3 概念 ............................................................................................................ 165
6.3.1 时钟频率 ............................................................................................................... 165
6.3.2 指令 ....................................................................................................................... 166
6.3.3 指令流水线 ........................................................................................................... 166
6.3.4 指令宽度 ............................................................................................................... 167
6.3.5 CPI，IPC ............................................................................................................... 167
6.3.6 使用率 ................................................................................................................... 167
6.3.7 用户时间/内核时间 .............................................................................................. 168
6.3.8 饱和度 ................................................................................................................... 168
6.3.9 抢占 ....................................................................................................................... 168
6.3.10 优先级反转 ......................................................................................................... 169
6.3.11 多进程，多线程 ................................................................................................. 169
6.3.12 字长 ..................................................................................................................... 170
6.3.13 编译器优化 ......................................................................................................... 171
6.4 架构 ......................................................................................................... 171
6.4.1 硬件 ....................................................................................................................... 171
6.4.2 软件 ....................................................................................................................... 179
6.5 方法 .................................................................................................................. 184
6.5.1 工具法 ................................................................................................................... 184
6.5.2 USE 方法 ............................................................................................................... 185
6.5.3 负载特征归纳 ....................................................................................................... 186
6.5.4 剖析 ....................................................................................................................... 187
6.5.5 周期分析 ............................................................................................................... 188
6.5.6 性能监控 ............................................................................................................... 189
6.5.7 静态性能调优 ....................................................................................................... 189
6.5.8 优先级调优 ........................................................................................................... 189
6.5.9 资源控制 ............................................................................................................... 190
6.5.10 CPU 绑定 ............................................................................................................ 190
6.5.11 微型基准测试 ..................................................................................................... 191
6.5.12 扩展 ..................................................................................................................... 191
6.6 分析 ........................................................................................................... 192
6.6.1 uptime .................................................................................................................... 192
6.6.2 vmstat .................................................................................................................... 194
6.6.3 mpstat .................................................................................................................... 195
6.6.4 sar .......................................................................................................................... 197
6.6.5 ps............................................................................................................................ 198
6.6.6 top .......................................................................................................................... 199
6.6.7 prstat ...................................................................................................................... 200
6.6.8 pidstat .................................................................................................................... 201
6.6.9 time 和ptime ......................................................................................................... 202
6.6.10 DTrace ................................................................................................................. 203
6.5.11 SystemTap ........................................................................................................... 209
6.6.12 perf ....................................................................................................................... 209
6.6.13 cpustat .................................................................................................................. 215
6.6.14 其他工具 ............................................................................................................. 216
6.6.15 可视化 ................................................................................................................. 216
6.7 实验 ...................................................................................................... 219
6.7.1 Ad Hoc ................................................................................................................... 219
6.7.2 SysBench ............................................................................................................... 220
6.8 调优 ........................................................................................................... 220
6.8.1 编译器选项 ........................................................................................................... 221
6.8.2 调度优先级和调度类 ........................................................................................... 221
6.8.3 调度器选项 ........................................................................................................... 221
6.8.4 进程绑定 ............................................................................................................... 223
6.8.5 独占CPU 组 ......................................................................................................... 224
6.8.6 资源控制 ............................................................................................................... 224
6.8.7 处理器选项（BIOS 调优） ................................................................................. 224
6.9 练习 ............................................................................................... 225
6.10 参考资料 ................................................................................................... 226
第7 章 内存 ........................................................................................................... 228
7.1 术语 ................................................................................................................... 229
7.2 概念 ...................................................................................................... 229
7.2.1 虚拟内存 ............................................................................................................... 230
7.2.2 换页 ....................................................................................................................... 230
7.2.3 按需换页 ............................................................................................................... 231
7.2.4 过度提交 ............................................................................................................... 233
7.2.5 交换 ....................................................................................................................... 233
7.2.6 文件系统缓存占用 ............................................................................................... 233
7.2.7 使用率和饱和度 ................................................................................................... 234
7.2.8 分配器 ................................................................................................................... 234
7.2.9 字长 ....................................................................................................................... 234
7.3 架构 ......................................................................................................... 234
7.3.1 硬件 ....................................................................................................................... 235
7.3.2 软件 ....................................................................................................................... 239
7.3.3 进程地址空间 ....................................................................................................... 244
7.4 方法 ........................................................................................................ 248
7.4.1 工具法 ................................................................................................................... 249
7.4.2 USE 方法 ............................................................................................................... 249
7.4.3 使用特征归纳 ....................................................................................................... 250
7.4.4 周期分析 ............................................................................................................... 251
7.4.5 性能监测 ............................................................................................................... 251
7.4.6 泄漏检测 ............................................................................................................... 252
7.4.7 静态性能调优 ....................................................................................................... 252
7.4.8 资源控制 ............................................................................................................... 253
7.4.9 微基准测试 ........................................................................................................... 253
7.5 分析 ................................................................................................... 253
7.5.1 vmstat .................................................................................................................... 254
7.5.2 sar .......................................................................................................................... 256
7.5.3 slabtop .................................................................................................................... 259
7.5.4 ::kmstat .................................................................................................................. 260
7.5.5 ps............................................................................................................................ 261
7.5.6 top .......................................................................................................................... 262
7.5.7 prstat ...................................................................................................................... 263
7.5.8 pmap ...................................................................................................................... 264
7.5.9 DTrace ................................................................................................................... 265
7.5.10 SystemTap ........................................................................................................... 269
7.5.11 其他工具 ............................................................................................................. 269
7.6 调优 .................................................................................. 270
7.6.1 可调参数 ................................................................................................................. 271
7.6.2 多个页面大小 ....................................................................................................... 273
7.6.3 分配器 ................................................................................................................... 274
7.6.4 资源控制 ............................................................................................................... 274
7.7 练习 .......................................................................................................... 274
7.8 参考资料 ............................................................................................................ 276
第8 章 文件系统 ................................................................................................... 278
8.1 术语 ................................................................................................................... 279
8.2 模型 .................................................................................................................. 279
8.2.1 文件系统接口 ....................................................................................................... 279
8.2.2 文件系统缓存 ....................................................................................................... 280
8.2.3 二级缓存 ............................................................................................................... 281
8.3 概念 ..................................................................................................... 281
8.3.1 文件系统延时 ....................................................................................................... 281
8.3.2 缓存 ....................................................................................................................... 282
8.3.3 随机与顺序I/O ..................................................................................................... 282
8.3.4 预取 ....................................................................................................................... 283
8.3.5 预读 ....................................................................................................................... 284
8.3.6 写回缓存 ............................................................................................................... 284
8.3.7 同步写 ................................................................................................................... 284
8.3.8 裸I/O 和直接I/O .................................................................................................. 285
8.3.9 非阻塞I/O ............................................................................................................. 285
8.3.10 内存映射文件 ..................................................................................................... 286
8.3.11 元数据 ................................................................................................................. 286
8.3.12 逻辑I/O vs.物理I/O ........................................................................................... 287
8.3.13 操作并非不平等 ................................................................................................. 288
8.3.14 特殊文件系统 ..................................................................................................... 289
8.3.15 访问时间戳 ......................................................................................................... 289
8.3.16 容量 ..................................................................................................................... 289
8.4 架构 .................................................................................................................. 290
8.4.1 文件系统I/O 栈 .................................................................................................... 290
8.4.2 VFS ........................................................................................................................ 291
8.4.3 文件系统缓存 ....................................................................................................... 291
8.4.4 文件系统特性 ....................................................................................................... 296
8.4.5 文件系统种类 ....................................................................................................... 297
8.4.6 卷和池 ................................................................................................................... 302
8.5 方法 ................................................................................................................ 303
8.5.1 磁盘分析 ............................................................................................................... 304
8.5.2 延时分析 ............................................................................................................... 304
8.5.3 负载特征归纳 ....................................................................................................... 306
8.5.4 性能监控 ............................................................................................................... 308
8.5.5 事件跟踪 ............................................................................................................... 308
8.5.6 静态性能调优 ....................................................................................................... 309
8.5.7 缓存调优 ............................................................................................................... 310
8.5.8 负载分离 ............................................................................................................... 310
8.5.9 内存文件系统 ....................................................................................................... 310
8.5.10 微型基准测试 ..................................................................................................... 310
8.6 分析 .................................................................................................................. 312
8.6.1 vfsstat ..................................................................................................................... 312
8.6.2 fsstat ....................................................................................................................... 313
8.6.3 strace、truss .......................................................................................................... 314
8.6.4 DTrace ................................................................................................................... 314
8.6.5 SystemTap ............................................................................................................. 323
8.6.6 LatencyTOP ........................................................................................................... 323
8.6.7 free ......................................................................................................................... 324
8.6.8 top .......................................................................................................................... 324
8.6.9 vmstat .................................................................................................................... 324
8.6.10 sar ........................................................................................................................ 325
8.6.11 slabtop .................................................................................................................. 326
8.6.12 mdb ::kmastat ...................................................................................................... 327
8.6.13 fcachestat ............................................................................................................. 327
8.6.14 /proc/meminfo ..................................................................................................... 328
8.6.15 mdb ::memstat ..................................................................................................... 328
8.6.16 kstat ...................................................................................................................... 329
8.6.17 其他工具 ............................................................................................................. 330
8.6.18 可视化 ................................................................................................................. 331
8.7 实验 ................................................................................................................. 331
8.7.1 Ad Hoc ................................................................................................................... 332
8.7.2 微型基准测试工具 ............................................................................................... 332
8.7.3 缓存写回 ............................................................................................................... 334
8.8 调优 ..................................................................................................... 334
8.8.1 应用程序调用 ....................................................................................................... 335
8.8.2 ext3 ........................................................................................................................ 336
8.8.3 ZFS ........................................................................................................................ 336
8.9 练习 ................................................................................................................. 338
8.10 参考资料 ........................................................................................................ 339
第9 章 磁盘 ...................................................................................................... 341
9.1 术语 ............................................................................................................... 342
9.2 模型 .................................................................................................................. 342
9.2.1 简单磁盘 ............................................................................................................... 342
9.2.2 缓存磁盘 ............................................................................................................... 343
9.2.3 控制器 ................................................................................................................... 344
9.3 概念 .................................................................................................................... 344
9.3.1 测量时间 ............................................................................................................... 344
9.3.2 时间尺度 ............................................................................................................... 346
9.3.3 缓存 ....................................................................................................................... 347
9.3.4 随机 vs 连续I/O ................................................................................................. 347
9.3.5 读/写比 .................................................................................................................. 348
9.3.6 I/O 大小 ................................................................................................................. 348
9.3.7 IOPS 并不平等 ...................................................................................................... 349
9.3.8 非数据传输磁盘命令 ........................................................................................... 349
9.3.9 使用率 ................................................................................................................... 349
9.3.10 饱和度 ................................................................................................................. 350
9.3.11 I/O 等待 ............................................................................................................... 350
9.3.12 同步 vs 异步 ...................................................................................................... 351
9.3.13 磁盘 vs 应用程序I/O ....................................................................................... 351
9.4 架构 .............................................................................................................. 352
9.4.1 磁盘类型 ............................................................................................................... 352
9.4.2 接口 ....................................................................................................................... 357
9.4.3 存储类型 ............................................................................................................... 358
9.4.4 操作系统磁盘I/O 栈 ............................................................................................ 360
9.5 方法 ................................................................................................................... 363
9.5.1 工具法 ................................................................................................................... 364
9.5.2 USE 方法 ............................................................................................................... 364
9.5.3 性能监控 ............................................................................................................... 365
9.5.4 负载特征归纳 ....................................................................................................... 366
9.5.5 延时分析 ............................................................................................................... 367
9.5.6 事件跟踪 ............................................................................................................... 368
9.5.7 静态性能调优 ....................................................................................................... 369
9.5.8 缓存调优 ............................................................................................................... 370
9.5.9 资源控制 ............................................................................................................... 370
9.5.10 微基准测试 ......................................................................................................... 370
9.5.11 伸缩 ..................................................................................................................... 371
9.6 分析 ............................................................................................................ 372
9.6.1 iostat ...................................................................................................................... 373
9.6.2 sar .......................................................................................................................... 380
9.6.3 pidstat .................................................................................................................... 381
9.6.4 DTrace ................................................................................................................... 382
9.6.5 SystemTap ............................................................................................................. 390
9.6.6 perf ......................................................................................................................... 390
9.6.7 iotop ....................................................................................................................... 391
9.6.8 iosnoop .................................................................................................................. 393
9.6.9 blktrace .................................................................................................................. 396
9.6.10 MegaCli ............................................................................................................... 397
9.6.11 smartctl ................................................................................................................ 398
9.6.12 可视化 ................................................................................................................. 399
9.7 实验 .......................................................................................................... 402
9.7.1 Ad Hoc ................................................................................................................... 402
9.7.2 自定义负载生成器 ............................................................................................... 403
9.7.3 微基准测试工具 ................................................................................................... 403
9.7.4 随机读示例 ........................................................................................................... 403
9.8 调优 .............................................................................................................. 404
9.8.1 操作系统可调参数 ............................................................................................... 404
9.8.2 磁盘设备可调参数 ............................................................................................... 406
9.8.3 磁盘控制器可调参数 ........................................................................................... 406
9.9 练习 .............................................................................................................. 407
9.10 参考资料 ................................................................................................ 408
第10 章 网络 .................................................................................................... 410
10.1 术语 ........................................................................................................... 411
10.2 模型 ............................................................................................................ 411
10.2.1 网络接口 ............................................................................................................. 411
10.2.2 控制器 ................................................................................................................. 412
10.2.3 协议栈 ................................................................................................................. 412
10.3 概念 .......................................................................................................... 413
10.3.1 网络和路由 ......................................................................................................... 413
10.3.2 协议 ..................................................................................................................... 414
10.3.3 封装 ..................................................................................................................... 414
10.3.4 包长度 ................................................................................................................. 414
10.3.5 延时 ..................................................................................................................... 415
10.3.6 缓冲 ..................................................................................................................... 417
10.3.7 连接积压队列 ..................................................................................................... 417
10.3.8 接口协商 ............................................................................................................. 417
10.3.9 使用率 ................................................................................................................. 418
10.3.10 本地连接 ........................................................................................................... 418
10.4 架构 .......................................................................................................... 418
10.4.1 协议 ..................................................................................................................... 418
10.4.2 硬件 ..................................................................................................................... 421
10.4.3 软件 ..................................................................................................................... 423
10.5 方法 ................................................................................................. 427
10.5.1 工具法 ....................................................................................................... 428
10.5.2 USE 方法 ............................................................................................................. 428
10.5.3 工作负载特征归纳 ............................................................................................. 429
10.5.4 延时分析 ............................................................................................................. 430
10.5.5 性能监测 ............................................................................................................. 431
10.5.6 数据包嗅探 ......................................................................................................... 431
10.5.7 TCP 分析 ............................................................................................................. 432
10.5.8 挖掘分析 ............................................................................................................. 433
10.5.9 静态性能调优 ..................................................................................................... 433
10.5.10 资源控制 ........................................................................................................... 434
10.5.11 微基准测试 ....................................................................................................... 434
10.6 分析 ......................................................................................................... 435
10.6.1 netstat ................................................................................................................... 435
10.6.2 sar ........................................................................................................................ 440
10.6.3 ifconfig ................................................................................................................ 442
10.6.4 ip .......................................................................................................................... 443
10.6.5 nicstat ................................................................................................................... 443
10.6.6 dladm ................................................................................................................... 444
10.6.7 ping ...................................................................................................................... 445
10.6.8 traceroute ............................................................................................................. 445
10.6.9 pathchar ............................................................................................................... 446
10.6.10 tcpdump ................................................................................................................ 446
10.6.11 snoop .................................................................................................................. 447
10.6.12 Wireshark ........................................................................................................... 450
10.6.13 DTrace ............................................................................................................... 450
10.6.14 SystemTap ......................................................................................................... 461
10.6.15 perf ..................................................................................................................... 461
10.6.16 其他工具 ........................................................................................................... 462
10.7 实验 ..................................................................................................... 463
10.7.1 iperf ...................................................................................................................... 463
10.8 调优 ............................................................................................................... 464
10.8.1 Linux .................................................................................................................... 465
10.8.2 Solaris .................................................................................................................. 467
10.8.3 配置 ..................................................................................................................... 469
10.9 练习 .............................................................................................................. 470
10.10 参考 ....................................................................................................... 471
第11 章 云计算 ........................................................................................................ 473
11.1 背景 ............................................................................................................... 474
11.1.1 性价比 ..................................................................................................... 474
11.1.2 可扩展的架构 ..................................................................................................... 474
11.1.3 容量规划 ............................................................................................................. 475
11.1.4 存储 ..................................................................................................................... 477
11.1.5 多租户 ................................................................................................................. 477
11.2 OS 虚拟化 ..................................................................................................... 478
11.2.1 系统开销 ............................................................................................................. 479
11.2.2 资源控制 ............................................................................................................. 481
11.2.3 可观测性 ............................................................................................................. 484
11.3 硬件虚拟化 .............................................................................................. 489
11.3.1 系统开销 ............................................................................................................. 490
11.3.2 资源控制 ............................................................................................................. 495
11.3.3 可观测性 ............................................................................................................. 498
11.4 比较 ..................................................................................................................... 503
11.5 练习 .................................................................................................................. 505
11.6 参考资料 ............................................................................................................... 506
第12 章 基准测试 ................................................................................................... 508
12.1 背景 ................................................................................................................ 508
12.1.1 事情 ..................................................................................................................... 509
12.1.2 有效的基准测试 ................................................................................................. 509
12.1.3 基准测试之罪 ..................................................................................................... 511
12.2 基准测试的类型 ............................................................................................... 516
12.2.1 微基准测试 ......................................................................................................... 517
12.2.2 模拟 ..................................................................................................................... 518
12.2.3 回放 ..................................................................................................................... 519
12.2.4 行业标准 ............................................................................................................. 519
12.3 方法 ......................................................................................................... 521
12.3.1 被动基准测试 ..................................................................................................... 521
12.3.2 主动基准测试 ..................................................................................................... 522
12.3.3 CPU 剖析 ............................................................................................................ 524
12.3.4 USE 方法 ............................................................................................................. 525
12.3.5 工作负载特征归纳 ............................................................................................. 526
12.3.6 自定义基准测试 ................................................................................................. 526
12.3.7 逐渐增加负载 ..................................................................................................... 526
12.3.8 完整性检查 ......................................................................................................... 528
12.3.9 统计分析 ............................................................................................................. 529
12.4 基准测试问题 ................................................................................................. 530
12.5 练习 ................................................................................................................... 531
12.6 参考 ........................................................................................................... 532
第13 章 案例研究 ............................................................................................. 534
13.1 案例研究：红鲸 .............................................................................................. 534
13.1.1 问题陈述 ............................................................................................................. 535
13.1.2 支持 ..................................................................................................................... 536
13.1.3 上手 ..................................................................................................................... 537
13.1.4 选择征途 ............................................................................................................. 538
13.1.5 USE 方法 ............................................................................................................. 539
13.1.6 我们做完了吗 ..................................................................................................... 542
13.1.7 二度出击 ............................................................................................................. 542
13.1.8 基础 ..................................................................................................................... 543
13.1.9 忽略红鲸 ............................................................................................................. 544
13.1.10 审问内核 ........................................................................................................... 545
13.1.11 为什么 ............................................................................................................... 546
13.1.12 尾声 ................................................................................................................... 548
13.2 结语 ........................................................................................................ 548
13.3 附加信息 ............................................................................................................... 549
13.4 参考 ..................................................................................................................... 549
附录A USE 法：Linux ........................................................................................................ 551
附录B USE 法：Solaris ..................................................................................................... 556
附录C sar 总结 ............................................................................................. 561
附录D DTrace 单行命令 ....................................................................................... 563
附录E 从DTrace 到SystemTap ........................................................................................ 573
附录F 精选练习题答案 ....................................................................................... 582
附录G 系统性能名人录 ...................................................................................... 585
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>性能之巅
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构探险：从零开始写分布式服务框架
第1章  常用的RPC框架	1
1.1  RPC框架原理	1
1.2  RMI介绍	2
1.2.1  原生RMI代码示例	3
1.2.2  RMI穿透防火墙	5
1.3  CXF/Axis2介绍	7
1.3.1  CXF介绍	7
1.3.2  Axis2介绍	14
1.4  Thrift介绍	21
1.4.1  Thrift工作原理介绍	23
1.4.2  Thrift IDL语法说明	26
1.4.3  基于Apache Thrift的Java版完整案例	28
1.4.4  基于Java注解的简化实现	36
1.5  gRPC介绍	42
1.5.1  protobuf3语法介绍	43
1.5.2  gRPC使用示例	45
1.6  HTTP Client介绍	53
1.6.1  构建HttpClient对象	54
1.6.2  构建URI对象	55
1.6.3  构建请求对象（HttpGet、HttpPost）	56
1.6.4  HttpClient发起调用及获取调用返回结果	56
1.7  实现自己的RPC框架	61
1.8  RPC框架与分布式服务框架的区别	68
1.9  本章小结	68
第2章  分布式服务框架总体架构与功能	69
2.1  面向服务的体系架构（SOA）	69
2.1.1  面向服务架构范式	69
2.1.2  服务拆分原则	71
2.2  分布式服务框架现实需求	72
2.3  分布式服务框架总体架构及所需的技术概述	72
2.4  本章小结	74
第3章  分布式服务框架序列化与反序列化实现	75
3.1  序列化原理及常用的序列化介绍	75
3.2  Java默认的序列化	77
3.3  XML序列化框架介绍	80
3.4  JSON序列化框架介绍	82
3.5  Hessian序列化框架介绍	87
3.6  protobuf序列化框架介绍	88
3.7  protostuff序列化框架介绍	93
3.8  Thrift序列化框架介绍	98
3.9  Avro序列化框架介绍	100
3.9.1  Avro介绍	100
3.9.2  Avro IDL语言介绍	101
3.9.3  Schema定义介绍	103
3.9.4  Maven配置及使用IDL与Schema自动生成代码	103
3.9.5  Avro序列化/反序列化实现	105
3.10  JBoss Marshalling序列化框架介绍	110
3.11  序列化框架的选型	112
3.12  实现自己的序列化工具引擎	113
3.13  本章小结	118
第4章  实现分布式服务框架服务的发布与引入	119
4.1  Spring Framework框架概述	119
4.1.1  Spring Framework介绍	119
4.1.2  Spring Framework周边生态项目介绍	121
4.2  FactoryBean的秘密	122
4.2.1  FactoryBean的作用及使用场景	123
4.2.2  FactoryBean实现原理及示例说明	124
4.3  Spring框架对于已有RPC框架集成的支持	127
4.3.1  Spring支持集成RPC框架介绍	127
4.3.2  基于RmiProxyFactoryBean 实现RMI与Spring的集成	128
4.3.3  基于HttpInvokerProxyFactoryBean实现HTTP Invoker与Spring的集成	131
4.3.4  基于HessianProxyFactoryBean实现Hessian与Spring的集成	133
4.4  实现自定义服务框架与Spring的集成	136
4.4.1  实现远程服务的发布	136
4.4.2  实现远程服务的引入	144
4.5  在Spring中定制自己的XML标签	150
4.6  本章小结	158
第5章  分布式服务框架注册中心	159
5.1  服务注册中心介绍	159
5.2  ZooKeeper实现服务的注册中心原理	161
5.2.1  ZooKeeper介绍	161
5.2.2  部署ZooKeeper	161
5.2.3  ZkClient使用介绍	164
5.2.4  ZooKeeper实现服务注册中心	173
5.3  集成ZooKeeper实现自己的服务注册与发现	175
5.3.1  服务注册中心服务提供方	175
5.3.2  服务注册中心服务消费方	176
5.3.3  服务注册中心实现	178
5.4  本章小结	189
第6章  分布式服务框架底层通信实现	190
6.1  Java I/O模型及I/O类库的进化	190
6.1.1  Linux下实现的I/O模型	190
6.1.2  Java语言实现的I/O模型	194
6.1.3  Java Classic I/O（Blocking I/O）介绍	194
6.1.4  Java Non-blocking I/O（NIO）介绍	211
6.1.5  NIO2及Asynchronous I/O介绍	233
6.2  Netty使用介绍	255
6.2.1  Netty开发入门	256
6.2.2  Netty粘包/半包问题解决	265
6.3  使用Netty构建服务框架底层通信	320
6.3.1  构建分布式服务框架Netty服务端	320
6.3.2  构建分布式服务框架服务调用端Netty客户端	330
6.4  本章小结	347
第7章  分布式服务框架软负载实现	348
7.1  软负载的实现原理	348
7.2  负载均衡常用算法	349
7.2.1  软负载随机算法实现	349
7.2.2  软负载加权随机算法实现	350
7.2.3  软负载轮询算法实现	351
7.2.4  软负载加权轮询算法实现	352
7.2.5  软负载源地址hash算法实现	354
7.3  实现自己的软负载机制	355
7.4  软负载在分布式服务框架中的应用	357
7.5  本章小结	361
第8章  分布式服务框架服务治理	362
8.1  服务治理介绍	362
8.2  服务治理的简单实现	364
8.2.1  服务分组路由实现	364
8.2.2  简单服务依赖关系分析实现	374
8.2.3  服务调用链路跟踪实现原理	380
8.3  本章小结	380
附录A  如何配置运行本书完成的分布式服务框架	381
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构探险：从零开始写分布式服务框架
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>管理架构师
目录
第一篇 价值创造活动
第1章　价值链和价值流
价值链的含义
“端对端”的价值链
内部价值链和外部价值链
第2章　价值创造活动的分类
核心活动和辅助活动
四类价值创造活动
各类活动的解释
价值创造活动的指向
第3章　价值链与商业模式
商业模式的含义
价值链型商业模式
用户资源型商业模式
平台型商业模式
第4章　战略导向下的价值创造活动
战略思想：“赢”的逻辑
关键驱动因素：“赢”的原因
企业价值创造活动体系
多层次“战略目标-战略举措”
第二篇 流程体系
第5章　流程体系的框架
一级流程目录
牵引性活动
增值性活动
要素性活动
支持性活动
企业流程体系大厦
第6章　好大一棵树：流程的细分
流程分解
流程优化
流程细分的限度
进入企业流程体系大厦内部
第7章　战略管理活动：一级流程1～3
一级流程1：战略制定和执行
一级流程2：投资管理
一级流程3：理念架构管理
第8章　年度管理循环：一级流程4～5
一级流程4：年度计划和全面预算
一级流程5：实体绩效管理
第9章　从需求到产品：一级流程6～7
一级流程6：需求分析
一级流程7：产品开发
产品开发中的技术开发
第10章　从生产到交付：一级流程8
一级流程8：集成供应链
生产模式的转变
规模化定制
个性化定制
“多余”和“不足”
第11章　多重空间内的顾客连接：一级流程9
一级流程9：顾客连接
品牌之桥和渠道之桥
线上、线下、社群三个空间的顾客引流和顾客
体验设计
价值流流程小结
第12章　人才供应链：一级流程10～13
人力资源开发管理新框架
一级流程10：人力资源配置
一级流程11：人力资源激励
一级流程12：人力资源开发
一级流程13：干部管理
第13章　企业发展的物质力量：一级流程14～19
一级流程14～16：资金筹措，资金使用，债务危机处理
一级流程17～18：技术吸纳，技术研究
一级流程19：知识产权管理
第14章　数据财富和经营算法：一级流程20～24
一级流程20：信息系统建设与维护
一级流程21：数据流管理
一级流程22：会计核算与决策支持
一级流程23：战略性财务管理
第15章　保驾护航的支持性活动：一级流程24～26
一级流程24：社会责任管理
一级流程25：法务管理
一级流程26：审计管理
第三篇 组织设计
第16章　流程活动的组织化
流程和组织分工
组织分工：粗与细
组织的层级和责任
第17章　组织形态：组织结构的方式
组织形态的演变
职能制
事业部制（分部制）
矩阵制
第18章　新型组织形态
嵌套型组织
分布型组织
生态型组织
第19章　部门职责分析与职位设置
部门职责
从部门到职位
职位及部门编制
部门职责说明书
第20章　职位的编织
职位分析
职位说明书
职位横向分类
职位纵向分层
管理类职位层级
技术类职位层级
职位网络
职位称谓
第21章　任职资格
胜任特征的冰山模型
任职资格的维度
任职资格管理的困境和突破
第22章　素质模型
不同级别的素质标准
知行结构的素质模型
领导力素质模型
第23章　角色管理
从职位到角色
角色的特点
角色实现和组织发展
角色管理的基本工具：角色说明书
第四篇 协同机制
第24章　纵向指挥链：权力机制
组织中的权力
授权还是获权？
权力连接的金字塔形和圆形
多层组织下的权力配置
多层级组织权力配置的工具：确权（分权）手册
总部与事业部权力配置
第25章　朝向事情本身：流程机制
流程的责任主体
流程连接的适用情形
流程式组织：流程连接的优化
部门之间的流程对接
第26章　将市场机制引入组织内部：交易机制
信息不对称的难题
组织协调和交易协调：相互关系的重新思考
交易连接的不同形态
采购活动的交易连接
产品研发活动的交易连接
生产制造活动的交易连接
销售活动的交易连接
第27章　任务型团队和自组织的连接
不同组织形态的连接机制组合
任务型团队的分类
弹性任务团队连接方式实证分析：篮球队员是如何协同的
一群没有“领导”的鸟儿为何能飞到万里之外
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>管理架构师
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算
出版者的话
译者序
推荐语
序
致谢
关于作者
关于序贡献者
关于贡献者
第1章　绪论
1.1　本书目标
1.2　本书未涵盖的内容
1.3　本书适用读者
1.4　本书组织结构
1.5　书写惯例
1.6　附加信息
第2章　案例研究背景
2.1　案例研究1：ATN
2.2　案例研究2：DTGOV
2.3　案例研究3：Innovartus
第一部分　云计算基础
第3章　理解云计算
3.1　起源与影响
3.1.1　简要历史
3.1.2　定义
3.1.3　商业驱动力
3.1.4　技术创新
3.2　基本概念与术语
3.2.1　云
3.2.2　IT资源
3.2.3　企业内部的
3.2.4　云用户与云提供者
3.2.5　可扩展性
3.2.6　云服务
3.2.7　云服务用户
3.3　目标与收益
3.3.1　降低的投资与成比例的开销
3.3.2　提高的可扩展性
3.3.3　提高的可用性和可靠性
3.4　风险与挑战
3.4.1　增加的安全漏洞
3.4.2　降低的运营管理控制
3.4.3　云提供者之间有限的可移植性
3.4.4　多地区法规遵循和法律问题
第4章　基本概念与模型
4.1　角色与边界
4.1.1　云提供者
4.1.2　云用户
4.1.3　云服务拥有者
4.1.4　云资源管理者
4.1.5　其他角色
4.1.6　组织边界
4.1.7　信任边界
4.2　云特性
4.2.1　按需使用
4.2.2　泛在接入
4.2.3　多租户（和资源池）
4.2.4　弹性
4.2.5　可测量的使用
4.2.6　可恢复性
4.3　云交付模型
4.3.1　基础设施作为服务（IaaS）
4.3.2　平台作为服务（PaaS）
4.3.3　软件作为服务（SaaS）
4.3.4　云交付模型比较
4.3.5　云交付模型组合
4.4　云部署模型
4.4.1　公有云
4.4.2　社区云
4.4.3　私有云
4.4.4　混合云
4.4.5　其他云部署模型
第5章　云使能技术
5.1　宽带网络和Internet架构
5.1.1　Internet服务提供者（ISP）
5.1.2　无连接分组交换（数据报网络）
5.1.3　基于路由器的互联
5.1.4　技术和商业考量
5.2　数据中心技术
5.2.1　虚拟化
5.2.2　标准化与模块化
5.2.3　自动化
5.2.4　远程操作与管理
5.2.5　高可用性
5.2.6　安全感知的设计、操作和管理
5.2.7　配套设施
5.2.8　计算硬件
5.2.9　存储硬件
5.2.10　网络硬件
5.2.11　其他考量
5.3　虚拟化技术
5.3.1　硬件无关性
5.3.2　服务器整合
5.3.3　资源复制
5.3.4　基于操作系统的虚拟化
5.3.5　基于硬件的虚拟化
5.3.6　虚拟化管理
5.3.7　其他考量
5.4　Web技术
5.4.1　基本Web技术
5.4.2　Web应用
5.5　多租户技术
5.6　服务技术
5.6.1　Web服务
5.6.2　REST服务
5.6.3　服务代理
5.6.4　服务中间件
第6章　基本云安全
6.1　基本术语和概念
6.1.1　保密性
6.1.2　完整性
6.1.3　真实性
6.1.4　可用性
6.1.5　威胁
6.1.6　漏洞
6.1.7　风险
6.1.8　安全控制
6.1.9　安全机制
6.1.10　安全策略
6.2　威胁作用者
6.2.1　匿名攻击者
6.2.2　恶意服务作用者
6.2.3　授信的攻击者
6.2.4　恶意的内部人员
6.3　云安全威胁
6.3.1　流量窃听
6.3.2　恶意媒介
6.3.3　拒绝服务
6.3.4　授权不足
6.3.5　虚拟化攻击
6.3.6　信任边界重叠
6.4　其他考量
6.4.1　有缺陷的实现
6.4.2　安全策略不一致
6.4.3　合约
6.4.4　风险管理
第二部分　云计算机制
第7章　云基础设施机制
7.1　逻辑网络边界
7.2　虚拟服务器
7.3　云存储设备
7.3.1　云存储等级
7.3.2　网络存储接口
7.3.3　对象存储接口
7.3.4　数据库存储接口
7.4　云使用监控
7.4.1　监控代理
7.4.2　资源代理
7.4.3　轮询代理
7.5　资源复制
7.6　已就绪环境
第8章　特殊云机制
8.1　自动伸缩监听器
8.2　负载均衡器
8.3　SLA监控器
8.4　按使用付费监控器
8.5　审计监控器
8.6　故障转移系统
8.6.1　主动-主动
8.6.2　主动-被动
8.7　虚拟机监控器
8.8　资源集群
8.9　多设备代理
8.10　状态管理数据库
第9章　云管理机制
9.1　远程管理系统
9.2　资源管理系统
9.3　SLA管理系统
9.4　计费管理系统
第10章　云安全机制
10.1　加密
10.1.1　对称加密
10.1.2　非对称加密
10.2　哈希
10.3　数字签名
10.4　公钥基础设施
10.5　身份与访问管理
10.6　单一登录
10.7　基于云的安全组
10.8　强化的虚拟服务器映像
第三部分　云计算架构
第11章　基本云架构
11.1　负载分布架构
11.2　资源池架构
11.3　动态可扩展架构
11.4　弹性资源容量架构
11.5　服务负载均衡架构
11.6　云爆发架构
11.7　弹性磁盘供给架构
11.8　冗余存储架构
第12章　高级云架构
12.1　虚拟机监控器集群架构
12.2　负载均衡的虚拟服务器实例架构
12.3　不中断服务重定位架构
12.4　零宕机架构
12.5　云负载均衡架构
12.6　资源预留架构
12.7　动态故障检测与恢复架构
12.8　裸机供给架构
12.9　快速供给架构
12.10　存储负载管理架构
第13章　特殊云架构
13.1　直接I/O访问架构
13.2　直接LUN访问架构
13.3　动态数据规范化架构
13.4　弹性网络容量架构
13.5　跨存储设备垂直分层架构
13.6　存储设备内部垂直数据分层架构
13.7　负载均衡的虚拟交换机架构
13.8　多路径资源访问架构
13.9　持久虚拟网络配置架构
13.10　虚拟服务器的冗余物理连接架构
13.11　存储维护窗口架构
第四部分　使用云
第14章　云交付模型考量
14.1　云交付模型：从云提供者的角度看
14.1.1　构建IaaS环境
14.1.2　装备PaaS环境
14.1.3　优化SaaS环境
14.2　云交付模型：从云用户的角度看
14.2.1　使用IaaS环境
14.2.2　使用PaaS环境
14.2.3　使用SaaS服务
第15章　成本指标与定价模型
15.1　商业成本指标
15.1.1　前期成本与持续成本
15.1.2　附加成本
15.2　云使用成本指标
15.2.1　网络使用
15.2.2　服务器使用
15.2.3　云存储设备使用
15.2.4　云服务使用
15.3　成本管理考量
15.3.1　定价模型
15.3.2　其他考量
第16章　服务质量指标与SLA
16.1　服务质量指标
16.1.1　服务可用性指标
16.1.2　服务可靠性指标
16.1.3　服务性能指标
16.1.4　服务可扩展性指标
16.1.5　服务弹性指标
16.2　SLA指导准则
第五部分　附录
附录A　案例研究结论
附录B　工业标准组织
附录C　机制与特性的对应关系
附录D　数据中心设施（TIA-942）
附录E　适应云的风险管理框架
附录F　云供给合同
附录G　云商业案例模板
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>SRE
前言   xxxi
序言   xxxv
第Ⅰ部分　概览
第1 章　介绍   2
系统管理员模式   2
Google 的解决之道：SRE   4
SRE 方法论   6
确保长期关注研发工作   6
在保障服务SLO 的前提下最大化迭代速度   7
监控系统   8
应急事件处理   8
变更管理   9
需求预测和容量规划   9
资源部署   10
效率与性能   10
小结   10
第2 章　Google 生产环境：SRE 视角   11
硬件   11
管理物理服务器的系统管理软件   13
管理物理服务器   13
存储   14
网络   15
其他系统软件   16
分布式锁服务   16
监控与警报系统   16
软件基础设施   17
研发环境   17
莎士比亚搜索：一个示范服务   18
用户请求的处理过程   18
任务和数据的组织方式   19
第Ⅱ部分　指导思想
第3 章　拥抱风险   23
管理风险   23
度量服务的风险   24
服务的风险容忍度   25
辨别消费者服务的风险容忍度   26
基础设施服务的风险容忍度   28
使用错误预算的目的   30
错误预算的构建过程   31
好处   32
第4 章　服务质量目标   34
服务质量术语   34
指标   34
目标   35
协议   36
指标在实践中的应用   37
运维人员和最终用户各关心什么   37
指标的收集   37
汇总   38
指标的标准化   39
目标在实践中的应用   39
目标的定义   40
目标的选择   40
控制手段   42
SLO 可以建立用户预期   42
协议在实践中的应用   43
第5 章　减少琐事   44
琐事的定义   44
为什么琐事越少越好   45
什么算作工程工作   46
琐事繁多是不是一定不好   47
小结   48
第6 章　分布式系统的监控   49
术语定义   49
为什么要监控   50
对监控系统设置合理预期   51
现象与原因   52
黑盒监控与白盒监控   53
4 个黄金指标   53
关于长尾问题   54
度量指标时采用合适的精度   55
简化，直到不能再简化   55
将上述理念整合起来   56
监控系统的长期维护   57
Bigtable SRE ：警报过多的案例   57
Gmail ：可预知的、可脚本化的人工干预   58
长跑   59
小结   59
第7 章　Google 的自动化系统的演进   60
自动化的价值   60
一致性   60
平台性   61
修复速度更快   61
行动速度更快   62
节省时间   62
自动化对Google SRE 的价值   62
自动化的应用案例   63
Google SRE 的自动化使用案例   63
自动化分类的层次结构   64
让自己脱离工作：自动化所有的东西   66
舒缓疼痛：将自动化应用到集群上线中   67
使用Prodtest 检测不一致情况   68
幂等地解决不一致情况   69
专业化倾向   71
以服务为导向的集群上线流程   72
Borg ：仓库规模计算机的诞生   73
可靠性是最基本的功能   74
建议   75
第8 章　发布工程   76
发布工程师的角色   76
发布工程哲学   77
自服务模型   77
追求速度   77
密闭性   77
强调策略和流程   78
持续构建与部署   78
构建   78
分支   79
测试   79
打包   79
Rapid 系统   80
部署   81
配置管理   81
小结   82
不仅仅只对Google 有用   83
一开始就进行发布工程   83
第9 章　简单化   85
系统的稳定性与灵活性   85
乏味是一种美德   86
我绝对不放弃我的代码   86
“负代码行”作为一个指标   87
最小 API   87
模块化   87
发布的简单化   88
小结   88
第Ⅲ部分　具体实践
第10 章　基于时间序列数据进行有效报警   93
Borgmon 的起源   94
应用软件的监控埋点   95
监控指标的收集   96
时间序列数据的存储   97
标签与向量   98
Borg 规则计算   99
报警   104
监控系统的分片机制   105
黑盒监控   106
配置文件的维护   106
十年之后   108
第11 章　on-call 轮值   109
介绍   109
on-call 工程师的一天   110
on-call 工作平衡   111
数量上保持平衡   111
质量上保持平衡   111
补贴措施   112
安全感   112
避免运维压力过大   114
运维压力过大   114
奸诈的敌人—运维压力不够   115
小结   115
第12 章　有效的故障排查手段   116
理论   117
实践   119
故障报告   119
定位   119
检查   120
诊断   122
测试和修复   124
神奇的负面结果   125
治愈   126
案例分析   127
使故障排查更简单   130
小结   130
第13 章　紧急事件响应   131
当系统出现问题时怎么办   131
测试导致的紧急事故   132
细节   132
响应   132
事后总结   132
变更部署带来的紧急事故   133
细节   133
事故响应   134
事后总结   134
流程导致的严重事故   135
细节   135
灾难响应   136
事后总结   136
所有的问题都有解决方案   137
向过去学习，而不是重复它   138
为事故保留记录   138
提出那些大的，甚至不可能的问题：假如……   138
鼓励主动测试   138
小结   138
第14 章　紧急事故管理   140
无流程管理的紧急事故   140
对这次无流程管理的事故的剖析   141
过于关注技术问题   141
沟通不畅   141
不请自来   142
紧急事故的流程管理要素   142
嵌套式职责分离   142
控制中心   143
实时事故状态文档   143
明确公开的职责交接   143
一次流程管理良好的事故   144
什么时候对外宣布事故   144
小结   145
第15 章　事后总结：从失败中学习   146
Google 的事后总结哲学   146
协作和知识共享   148
建立事后总结文化   149
小结以及不断优化   151
第16 章　跟踪故障   152
Escalator   152
Outalator   153
聚合   154
加标签   155
分析   155
未预料到的好处   156
第17 章　测试可靠性   157
软件测试的类型   158
传统测试   159
生产测试   160
创造一个构建和测试环境   163
大规模测试   165
测试大规模使用的工具   166
针对灾难的测试   167
对速度的渴求   168
发布到生产环境   170
允许测试失败   170
集成   172
生产环境探针   173
小结   175
第18 章　SRE 部门中的软件工程实践   176
为什么软件工程项目对SRE 很重要   176
Auxon 案例分析：项目背景和要解决的问题   177
传统的容量规划方法   177
解决方案：基于意图的容量规划   179
基于意图的容量规划   180
表达产品意图的先导条件   181
Auxon 简介   182
需求和实现：成功和不足   183
提升了解程度，推进采用率   185
团队内部组成   187
在SRE 团队中培养软件工程风气   187
在SRE 团队中建立起软件工程氛围：招聘与开发时间   188
做到这一点   189
小结   190
第19 章　前端服务器的负载均衡   191
有时候硬件并不能解决问题   191
使用DNS 进行负载均衡   192
负载均衡：虚拟IP   194
第20 章　数据中心内部的负载均衡系统   197
理想情况   198
识别异常任务：流速控制和跛脚鸭任务   199
异常任务的简单应对办法：流速控制   199
一个可靠的识别异常任务的方法：跛脚鸭状态   200
利用划分子集限制连接池大小   201
选择合适的子集   201
子集选择算法一：随机选择   202
子集选择算法二：确定性算法   204
负载均衡策略   206
简单轮询算法   206
最闲轮询策略   209
加权轮询策略   210
第21 章　应对过载   212
QPS 陷阱   213
给每个用户设置限制   213
客户端侧的节流机制   214
重要性   216
资源利用率信号   217
处理过载错误   217
决定何时重试   218
连接造成的负载   220
小结   221
第22 章　处理连锁故障   223
连锁故障产生的原因和如何从设计上避免   224
服务器过载   224
资源耗尽   225
服务不可用   228
防止软件服务器过载   228
队列管理   229
流量抛弃和优雅降级   230
重试   231
请求延迟和截止时间   234
慢启动和冷缓存   236
保持调用栈永远向下   238
连锁故障的触发条件   238
进程崩溃   239
进程更新   239
新的发布   239
自然增长   239
计划中或计划外的不可用   239
连锁故障的测试   240
测试直到出现故障，还要继续测试   240
测试最常用的客户端   241
测试非关键性后端   242
解决连锁故障的立即步骤   242
增加资源   242
停止健康检查导致的任务死亡   242
重启软件服务器   242
丢弃流量   243
进入降级模式   243
消除批处理负载   244
消除有害的流量   244
小结   244
第23 章　管理关键状态：利用分布式共识来提高可靠性   246
使用共识系统的动力：分布式系统协调失败   248
案例1 ：脑裂问题   249
案例2 ：需要人工干预的灾备切换   249
案例3 ：有问题的小组成员算法   249
分布式共识是如何工作的   250
Paxos 概要：协议示例   251
分布式共识的系统架构模式   251
可靠的复制状态机   252
可靠的复制数据存储和配置存储   252
使用领头人选举机制实现高可用的处理系统   253
分布式协调和锁服务   253
可靠的分布式队列和消息传递   254
分布式共识系统的性能问题   255
复合式Paxos ：消息流过程详解   257
应对大量的读操作   258
法定租约   259
分布式共识系统的性能与网络延迟   259
快速Paxos 协议：性能优化   260
稳定的领头人机制   261
批处理   262
磁盘访问   262
分布式共识系统的部署   263
副本的数量   263
副本的位置   265
容量规划和负载均衡   266
对分布式共识系统的监控   270
小结   272
第24 章　分布式周期性任务系统   273
Cron   273
介绍   273
可靠性   274
Cron 任务和幂等性   274
大规模Cron 系统   275
对基础设施的扩展   275
对需求的扩展   276
Google Cron 系统的构建过程   277
跟踪Cron 任务的状态   277
Paxos 协议的使用   277
领头人角色和追随者角色   278
保存状态   281
运维大型Cron 系统   282
小结   283
第25 章　数据处理流水线   284
流水线设计模式的起源   284
简单流水线设计模式与大数据   284
周期性流水线模式的挑战   285
工作分发不均造成的问题   285
分布式环境中周期性数据流水线的缺点   286
监控周期性流水线的问题   287
惊群效应   287
摩尔负载模式   288
Google Workflow 简介   289
Workflow 是模型—视图—控制器（MVC）模式   290
Workflow 中的执行阶段   291
Workflow 正确性保障   291
保障业务的持续性   292
小结   294
第26 章　数据完整性：读写一致   295
数据完整性的强需求   296
提供超高的数据完整性的策略   297
备份与存档   298
云计算环境下的需求   299
保障数据完整性和可用性：Google SRE 的目标   300
数据完整性是手段，数据可用性是目标   300
交付一个恢复系统，而非备份系统   301
造成数据丢失的事故类型   301
维护数据完整性的深度和广度的困难之处   303
Google SRE 保障数据完整性的手段   304
24 种数据完整性的事故组合   304
第一层： 软删除   305
第二层：备份和相关的恢复方法   306
额外一层：复制机制   308
1T vs. 1E ：存储更多数据没那么简单   309
第三层：早期预警   310
确保数据恢复策略可以正常工作   313
案例分析   314
Gmail—2011 年2 月：从GTape 上恢复数据（ 磁带）   314
Google Music—2012 年3 月：一次意外删除事故的检测过程   315
SRE 的基本理念在数据完整性上的应用   319
保持初学者的心态   319
信任但要验证   320
不要一厢情愿   320
纵深防御   320
小结   321
第27 章　可靠地进行产品的大规模发布   322
发布协调工程师   323
发布协调工程师的角色   324
建立发布流程   325
发布检查列表   326
推动融合和简化   326
发布未知的产品   327
起草一个发布检查列表   327
架构与依赖   328
集成   328
容量规划   328
故障模式   329
客户端行为   329
流程与自动化   330
开发流程   330
外部依赖   331
发布计划   331
可靠发布所需要的方法论   332
灰度和阶段性发布   332
功能开关框架   333
应对客户端滥用行为   334
过载行为和压力测试   335
LCE 的发展   335
LCE 检查列表的变迁   336
LCE 没有解决的问题   337
小结   338
第Ⅳ部分　管理
第28 章　迅速培养SRE 加入on-call   341
新的SRE 已经招聘到了，接下来怎么办   341
培训初期：重体系，而非混乱   344
系统性、累积型的学习方式   345
目标性强的项目工作，而非琐事   346
培养反向工程能力和随机应变能力   347
反向工程：弄明白系统如何工作   347
统计学和比较性思维：在压力下坚持科学方法论   347
随机应变的能力：当意料之外的事情发生时怎么办   348
将知识串联起来：反向工程某个生产环境服务   348
有抱负的on-call 工程师的5 个特点   349
对事故的渴望：事后总结的阅读和书写   349
故障处理分角色演习   350
破坏真的东西，并且修复它们   351
维护文档是学徒任务的一部分   352
尽早、尽快见习on-call   353
on-call 之后：通过培训的仪式感，以及日后的持续教育   354
小结   354
第29 章　处理中断性任务   355
管理运维负载   356
如何决策对中断性任务的处理策略   356
不完美的机器   357
流状态   357
将一件事情做好   358
实际一点的建议   359
减少中断   361
第30 章　通过嵌入SRE 的方式帮助团队从运维过载中恢复   363
第一阶段：了解服务，了解上下文   364
确定最大的压力来源   364
找到导火索   364
第二阶段：分享背景知识   365
书写一个好的事后总结作为示范   366
将紧急事件按类型排序   366
第三阶段：主导改变   367
从基础开始   367
获取团队成员的帮助   367
解释你的逻辑推理过程   368
提出引导性问题   368
小结   369
第 31 章　SRE 与其他团队的沟通与协作   370
沟通：生产会议   371
议程   372
出席人员   373
SRE 的内部协作   374
团队构成   375
高效工作的技术   375
SRE 内部的协作案例分析：Viceroy   376
Viceroy 的诞生   376
所面临的挑战   378
建议   379
SRE 与其他部门之间的协作   380
案例分析：将DFP 迁移到F1   380
小结   382
第32 章　SRE 参与模式的演进历程   383
SRE 参与模式：是什么、怎么样以及为什么   383
PRR 模型   384
SRE 参与模型   384
替代性支持   385
PRR ：简单PRR 模型   386
参与   386
分析   387
改进和重构   387
培训   388
“接手”服务   388
持续改进   388
简单PRR 模型的演进：早期参与模型   389
早期参与模型的适用对象   389
早期参与模型的优势   390
不断发展的服务：框架和SRE 平台   391
经验教训   391
影响SRE 的外部因素   392
结构化的解决方案：框架   392
新服务和管理优势   394
小结   395
第Ⅴ部分　结束语
第33 章　其他行业的实践经验   398
有其他行业背景的资深SRE   399
灾难预案与演习   400
从组织架构层面坚持不懈地对安全进行关注   401
关注任何细节   401
冗余容量   401
模拟以及进行线上灾难演习   402
培训与考核   402
对详细的需求收集和系统设计的关注   402
纵深防御   403
事后总结的文化   403
将重复性工作自动化，消除运维负载   404
结构化和理性的决策   406
小结   407
第34 章　结语   408
附录A　系统可用性   411
附录B　生产环境运维过程中的最佳实践   412
附录C　事故状态文档示范   417
附录D　事后总结示范   419
附录E　发布协调检查列表   423
附录F　生产环境会议记录示范   425
参考文献   427
索引   439__
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>SRE
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>代码里的世界观——通往架构师之路
第1章　程序世界的两个基本元素　　1
1.1　数据和代码的相互伪装　　1
1.2　数据和代码的关系　　2
1.3　总结　　3
第2章　用面向对象的方式去理解世界　　4
2.1　好的程序员是安徒生　　4
2.2　封装——招兵买马，等级森严　　5
2.2.1　从单细胞到高等生物　　5
2.2.2　public——对象的外观　　6
2.2.3　private——水下的冰川　　10
2.2.4　protected——内外兼修　　11
2.2.5　封装总结　　12
2.3　继承——快速进化　　13
2.4　多态——抽象的基石　　15
2.5　总结　　16
第3章　面向抽象编程——玩玩虚的更健康　　17
3.1　抽象最讨厌的敌人：new　　17
3.2　消灭new的两件武器　　19
3.2.1　控制反转——脏活让别人去干　　19
3.2.2　工厂模式——抽象的基础设施　　20
3.2.3　new去哪里了呢　　21
3.3　抽象到什么程度　　22
3.4　总结　　23
第4章　耦合其实无处不在　　24
4.1　耦合的种类　　24
4.1.1　数据之间的耦合　　24
4.1.2　函数之间的耦合　　24
4.1.3　数据和函数之间的耦合　　25
4.1.4　耦合种类的总结　　26
4.2　耦合中既有敌人也有朋友　　26
4.3　坏耦合的原因　　28
4.3.1　刻舟求剑　　28
4.3.2  “谈恋爱”是个危险的行为　　29
4.3.3　侵占公共资源　　29
4.3.4　需求变化——防不胜防　　30
4.4　解耦的原则　　30
4.4.1　让模块逻辑独立而完整　　30
4.4.2　让连接桥梁坚固而兼容　　34
4.5　总结　　35
第5章　数据的种类——生命如此多娇　　36
5.1　常用数据类型　　36
5.1.1　string类型：人机沟通的桥梁　　36
5.1.2　int类型：多变的万花筒　　37
5.1.3　bool类型：能量巨大的原子　　37
5.2　按生命周期划分数据　　39
5.3　两个重要的数据容器　　40
5.3.1　数组——容器之王　　40
5.3.2　散列表——银行的保险柜　　41
5.3.3　容器总结　　46
5.4　对象的种类　　46
5.4.1　实体对象——光鲜的主角　　46
5.4.2　值对象——配角或道具　　46
5.5　描述数据的数据　　47
5.6　总结　　48
第6章　数据驱动——把变化抽象成数据　　49
6.1　三个案例　　49
6.2　数据驱动的好帮手：反射　　53
6.2.1　反射是将代码数据化　　54
6.2.2　反射也是一把双刃剑　　54
6.2.3　各种语言对反射的支持　　55
6.3　总结　　55
第7章　对象之间的关系——父子、朋友或情人　　57
7.1　继承——父子关系　　57
7.1.1　里氏替换原则——儿子顶替父亲　　57
7.1.2　鸵鸟非鸟　　58
7.1.3　不听老人言　　60
7.2　组合——朋友关系　　61
7.2.1　组合与继承的区别　　62
7.2.2　组合和继承的联系　　63
7.2.3　策略模式——组装车间　　64
7.2.4　组合的总结　　66
7.3　依赖——情人关系　　67
7.3.1　依赖和组合的差别　　67
7.3.2　迷人的双向依赖　　68
7.3.3　扑朔迷离的访问者模式　　69
7.3.4　依赖的总结　　74
7.4　总结　　74
第8章　函数的种类——迷宫的结构　　75
8.1　面向对象的函数叫方法　　75
8.2　参数是函数的原材料　　75
8.2.1　参数在函数中的地位　　75
8.2.2　参数存在的形式　　76
8.3　返回值对函数的意义　　76
8.3.1　有返回值函数　　77
8.3.2　void函数　　77
8.4　值传递、引用传递和指针传递　　78
8.5　有状态函数和无状态函数　　80
8.6　静态函数和普通函数　　82
8.7　能驾驭其他函数的函数　　84
8.8　编译器做过手脚的函数　　84
8.8.1　函数重载　　84
8.8.2　泛型函数　　85
8.9　总结　　86
第9章　面向接口编程——遵循契约办事　　87
9.1　接口和抽象类——分工其实挺明确　　87
9.2　接口的应用场景　　89
9.2.1　先签约，后对接　　90
9.2.2　专注抽象，脱离具体　　92
9.2.3　解开耦合，破除缠绕　　93
9.2.4　3个场景的总结　　95
9.3　接口和函数指针　　95
9.3.1　原来是亲兄弟　　95
9.3.2　接口的优势　　96
9.3.3　函数指针的优势　　97
9.3.4　两兄弟的总结　　99
9.4　函数指针的应用场景　　99
9.4.1　简化版的Command模式　　99
9.4.2　行为外包　　101
9.4.3　结尾回调——异步搭档　　102
9.5　总结　　104
第10章　if...else的多面性　　105
10.1　两条兄弟语句　　105
10.2　if...else的黑暗面　　106
10.2.1　永无止境的长长铁链　　106
10.2.2　牵一发而动全身　　107
10.2.3　其实黑化不是我的错　　108
10.3　开闭原则——if...else的天敌　　108
10.3.1　扩展和修改的区别　　109
10.3.2　为什么扩展比修改好　　110
10.4　化解if...else黑暗面　　110
10.4.1　抽出共性　　110
10.4.2　利用多态　　112
10.4.3　数据驱动　　114
10.4.4　动态类型　　114
10.5　总结　　116
第11章　挖掘一件神秘武器——static　　117
11.1　static神秘在哪里　　117
11.2　static的特性　　118
11.2.1　对代码的直接访问　　118
11.2.2　隔离性和游离性　　119
11.2.3　将函数参数反客为主　　119
11.3　static的应用场景　　120
11.3.1　实现工具包函数　　120
11.3.2　实现单例也有门道　　120
11.3.3　实现类扩展　　123
11.3.4　让数据互动起来　　128
11.3.5　构建上层建筑　　128
11.4　总结　　131
第12章　把容易变化的逻辑，放在容易修改的地方　　132
12.1　一个和用户的故事　　132
12.2　一个和销售的故事　　134
12.3　一个和产品经理的故事　　136
12.4　一个和运维的故事　　136
12.5　总结　　137
第13章　隐式约定——犹抱琵琶半遮面　　139
13.1　拨开隐式约定的神秘面纱　　139
13.1.1　隐式约定就在你身边　　139
13.1.2　隐式约定的重要特征　　141
13.1.3　隐式约定的其他形式　　142
13.1.4　隐式约定的风险与缺陷　　142
13.2　调料包数据　　143
13.3　越简单的功夫越厉害　　145
13.4　总结　　148
第14章　异常，天使还是魔鬼　　150
14.1　三个江湖派别　　150
14.2　异常的种类　　151
14.3　异常的throw：手榴弹什么时候扔　　153
14.4　异常的catch——能收炸弹的垃圾筐　　154
14.5　异常的使用技巧　　156
14.5.1　看病要趁早　　156
14.5.2　不要加大catch的负担　　156
14.5.3　避免try花了眼　　157
14.5.4　保持克制，不要滥用　　157
14.6　总结　　158
第15章　多线程编程——在混沌中永生　　159
15.1　几个基础概念　　159
15.1.1　每个线程都有独立的安全港——栈区　　159
15.1.2　超乎想象的细微步骤——线程安全　　160
15.2　互斥——相互竞争　　161
15.3　同步——相互协作　　163
15.3.1　同步的本质　　163
15.3.2　共享变量——一块公用的黑板　　164
15.3.3　条件变量——用交通灯来指挥　　165
15.3.4　同步和互斥——本是同根生　　165
15.4　异步——各忙各的　　166
15.4.1　异步的本质　　166
15.4.2　等待烧水，顺便洗碗　　167
15.4.3　明修栈道，暗度陈仓　　167
15.4.4　异步和函数回调　　169
15.4.5　有关异步的问与答　　170
15.4.6　异步总结　　171
15.5　阻塞与非阻塞　　172
15.6　总结　　173
第16章　单元测试——对代码庖丁解牛　　174
16.1　单元测试的诞生　　174
16.2　单元测试的进化　　175
16.2.1　大量繁殖　　175
16.2.2　寻找盟友　　176
16.2.3　划分地盘　　176
16.2.4　反客为主　　177
16.3　编写单元测试的基本原则　　178
16.4　如何让代码面向单元测试　　181
16.4.1　买一个西瓜，无须先买菜市场　　181
16.4.2　只是演习，不玩真的　　183
16.4.3　人机交互代码，怎么攻克　　183
16.5　最后的忠告：无招胜有招　　185
16.6　总结　　186
第17章　代码评审——给身体排排毒　　187
17.1　排毒要养成习惯　　187
17.2　磨刀不误砍柴工　　188
17.3　经验点滴——关键是流程化　　188
17.4　11个案例　　189
17.5　总结　　196
第18章　编程就是用代码来写作　　197
18.1　程序员与作家的区别　　197
18.2　如何提高写作水平　　198
18.2.1　英语还是躲不了的　　198
18.2.2　重视的态度　　198
18.2.3　需要长期的积累　　199
18.3　案例解析——咬文嚼字很重要　　201
18.4　谨慎对待注释　　202
18.4.1　必须存在的注释　　203
18.4.2　做做样子的注释　　203
18.5　总结　　204
第19章　程序员的精神分裂——扮演上帝与木匠　　205
19.1　一个脑袋，两种身份　　205
19.2　上帝模式：开天辟地，指点江山　　205
19.2.1  “上帝”在干什么　　206
19.2.2　和产品设计的争夺　　206
19.3　木匠模式：致富只有勤劳一条路　　208
19.4　总结　　209
第20章　程序员的技术成长——打怪升级之路　　210
20.1　技术成长三部曲　　210
20.2　码农都是好老师　　211
20.3　重视编程效率　　212
20.4　尽量通过工作去锻炼　　212
20.5　三分之一的工匠精神　　214
20.6　明白架构师的含义　　214
20.7　总结　　214
第21章　语言到底哪种好——究竟谁是屠龙刀　　216
21.1　军队的背后是国家实力的较量　　216
21.2　专一和多情哪个好　　216
21.2.1　切换语言的成本到底有多大　　217
21.2.2　海、陆、空齐备最好　　217
21.3　如何快速学习一门新语言　　218
21.3.1　边学边练　　219
21.3.2　抓住该语言的主要特性去学　　219
21.4　总结　　219
第22章　程序员的组织生产——让大家更高效和亲密　　220
22.1　敏捷开发：及时反馈，小步快跑　　220
22.2　双人编程：双人搭配，干活超累　　222
22.3　封闭开发：并不是蹲大狱　　222
22.4　总结　　223
第23章　程序员的职业生涯——选择比努力更重要　　224
23.1　程序员到底能干多久　　224
23.2　程序员的中年危机　　225
23.3　自问一：你适不适合当程序员　　226
23.4　自问二：程序员是否最适合你　　227
23.5　自问三：问问自己有没有双门槛　　228
23.6　自问四：程序员最适合转什么行　　229
23.7　总结　　230
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>代码里的世界观——通往架构师之路
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>在线广告
第1章  在线广告发展简史
1.1  在线广告发展简介
1.1.1  中国古代的广告
1.1.2  在线广告的诞生
1.1.3  搜索广告的诞生和发展
1.1.4  社交和视频类广告
1.1.5  Ad Network的诞生
1.1.6  Ad Exchange和TradingDesk
1.2  移动广告的发展
1.3  搜索广告和定价模式
1.4  社交媒体广告
1.5  视频广告
1.6  在线广告优势
1.7  在线广告规模
参考文献
第2章  广告样式与创意
2.1  主流广告样式
2.1.1  PC端广告样式
2.1.2  移动端广告样式
2.2  技术驱动营销
2.3  广告样式发展趋势
2.4  程序化创意
2.4.1  程序化创意的缘由
2.4.2  程序化创意
2.5  动态创意优化
参考文献
第3章  广告系统架构流程
3.1  投放引擎架构流程
3.1.1  广告投放引擎架构
3.1.2  客户系统
3.1.3  内部管理平台
3.1.4  基础架构及相关模块
3.1.5  广告投放引擎内部模块
3.1.6  工具和测试平台
3.2  收入分解
3.3  程序化广告技术生态
3.4  Ad Network
3.4.1  工作流程
3.4.2  分类
3.4.3  定向方式
3.4.4  优势
3.4.5  移动广告网络
3.5  Ad Exchange
3.5.1  产生背景
3.5.2  工作流程
3.5.3  与Ad Network的不同
3.5.4  国内Ad Exchange的发展
3.6  程序化售卖方式
3.7  其他机制
3.7.1  匿名设置
3.7.2  Reserve Price
3.7.3  Pre-Targeting
参考文献
第4章  品牌广告
4.1  品牌推广的意义
4.2  品牌广告简介
4.2.1  品牌广告
4.2.2  品牌广告常见形式
4.2.3  计费和购买方式
4.2.4  样式和创意
4.3  品牌广告的有效性
4.4  品牌广告效果评估指标
4.5  Benchmark
参考文献
第5章  搜索类广告
5.1  搜索广告简介
5.1.1  搜索广告的模式
5.1.2  广告投放及相关问题
5.1.3  搜索广告的优势
5.2  常见产品形态
5.2.1  综合搜索
5.2.2  定制类搜索
5.2.3  图片类搜索
5.2.4  内容定向
5.2.5  电商类搜索
5.2.6  应用商店搜索
5.2.7  其他
5.3  系统架构和重要模块
5.3.1  广告架构
5.3.2  广告账户组织结构
5.3.3  广告检索流程
5.3.4  预算控制
5.3.5  在线匹配
5.3.6  机制设计
5.3.7  计费流程
5.3.8  准入
5.4  主流竞价机制
5.4.1  GFP机制
5.4.2  GSP机制
5.4.3  VCG机制
5.5  搜索生态
5.6  GSP优化
5.6.1  Weighted GSP
5.6.2  Squashing
5.6.3  UWR
5.6.4  QWR
5.6.5  Anchoring
5.6.6  模型对比
5.6.7  Hidden Cost
5.7  长尾查询
5.8  市场规模
参考文献
第6章  社交类广告
6.1  社交媒体
6.1.1  社交网络国度
6.1.2  社交网络的特点
6.1.3  常见的社交应用
6.1.4  社交网络影响购买行为
6.2  社交广告
6.2.1  常见广告类型
6.2.2  定向方式
6.3  基于社交关系的算法
6.3.1  社交内容推荐算法
6.3.2  社区分割算法
6.3.3  社交内容扩散算法
6.4  社交网络营销
参考文献
第7章  视频类广告
7.1  视频广告简介
7.1.1  常见的广告类型
7.1.2  售卖方式
7.1.3  广告时长
7.2  视频广告生态和投放流程
7.2.1  视频广告生态
7.2.2  广告投放流程
7.3  流量预估
7.3.1  优化目标
7.3.2  模型特征
7.3.3  特征平滑处理
7.3.4  流量预估函数
7.3.5  模型评估方法
7.4  库存分配问题
7.5  库存分配算法
7.5.1  HWM
7.5.2  优化调整
7.5.3  反馈机制
7.5.4  SHALE
7.6  Pacing
7.7  市场规模
参考文献
第8章  用户数据和定向算法
8.1  用户识别
8.1.1  Cookie
8.1.2  Cookie Matching
8.1.3  移动端用户识别
8.1.4  跨屏识别
8.2  用户画像
8.3  定向方式
8.4  经营状况评估和优化
8.4.1  评估指标
8.4.2  CLV优化
8.4.3  客户关系管理和使用
8.5  Lookalike
8.5.1  特征提取和建模
8.5.2  扩展方式
8.5.3  最近邻选择
8.5.4  离线扩展流程
8.5.5  node2vec
8.5.6  实战
8.6  竞价环境预估
8.7  超级用户
参考文献
第9章  点击率预估与推荐算法
9.1  点击率预估简介
9.2  点击率预估特征
9.2.1  相同竞价词下其他订单的特征
9.2.2  相关竞价词的CTR
9.2.3  广告质量相关特征
9.2.4  订单竞价词相关特征
9.2.5  外部相关特征
9.2.6  特征预处理
9.3  预估模型
9.3.1  基础模型
9.3.2  L2-TreeBoost+LR模型
9.3.3  回归树
9.3.4  Gradient Boosting
9.3.5  L2-TreeBoost
9.3.6  特征组合
9.3.7  Freshness
9.3.8  数据采样
9.4  模型评估方法
9.4.1  KL离散算法
9.4.2  AUC
9.4.3  NE
9.5  Bandit
9.5.1  Bandit问题
9.5.2  ε-Greedy方法
9.5.3  Thompson Sampling
9.5.4  UCB
9.5.5  LinUCB
9.6  在线学习方法
9.6.1  梯度下降方法
9.6.2  BGD
9.6.3  SGD
9.6.4  MBGD
9.6.5  简单截断法
9.6.6  截断梯度法
9.6.7  FOBOS
9.6.8  RDA
9.6.9  L1-FOBOS和L1-RDA的对比
9.6.10  FTRL
9.7  推荐算法
9.8  基于协同过滤的推荐
9.8.1  基于用户的协同过滤算法
9.8.2  基于物品的协同过滤算法
9.8.3  其他相似度计算方法
9.8.4  应用
9.9  基于矩阵分解的推荐
9.9.1  矩阵分解
9.9.2  正则化
9.9.3  隐性特征
9.10  基于深度学习的推荐
9.10.1  推荐流程
9.10.2  排序
9.11  广告排序性能优化
参考文献
第10章  在线匹配
10.1  图论基础知识
10.2  在线匹配类型
10.3  在线二部图匹配
10.3.1  Greedy算法
10.3.2  Random算法
10.3.3  Ranking算法
10.4  加权的在线二部图匹配
10.5  Adwords
10.5.1  Greedy算法
10.5.2  Balance算法与Greedy算法对比
10.5.3  MSVV算法
10.5.4  一般情况的证明
10.6  基于原始对偶的匹配
10.6.1  原始对偶问题
10.6.2  互补松弛性
10.6.3  Greedy算法实现
10.6.4  更优算法
10.7  现实系统中的匹配算法
参考文献
第11章  机制设计
11.1  机制设计概述
11.2  经典案例
11.2.1  囚徒困境
11.2.2  二难问题
11.2.3  无怨算法
11.2.4  TureView广告
11.2.5  策略性投票
11.3  激励兼容
11.3.1  投票悖论
11.3.2  阿罗不可能定理
11.4  引入金钱的机制
11.4.1  拍卖机制
11.4.2  VCG机制
11.5  激励兼容的特性
11.6  贝叶斯纳什均衡
11.7  竞价机制分析
11.7.1  临界条件分析
11.7.2  VCG机制
11.7.3  Simplest GSP机制
11.7.4  Weighted GSP机制
11.8  拥挤控制
参考文献
第12章  低质量和敏感控制
12.1  作弊背景
12.1.1  作弊参与者
12.1.2  作弊动机
12.2  广告作弊方法
12.2.1  单机作弊
12.2.2  黑客作弊
12.2.3  有组织的网络作弊
12.2.4  有组织的人工作弊
12.2.5  基于大流量平台的作弊
12.3  广告反作弊
12.3.1  反作弊架构
12.3.2  反作弊算法分类
12.4  广告质量
12.5  数据安全
参考文献
第13章  实验架构和调参
13.1  A/B testing
13.2  分层实验
13.2.1  分层实验方案
13.2.2  实验平台
13.3  实验设计和分析
13.3.1  置信度
13.3.2  置信区间
13.3.3  最少样本数
13.3.4  逐步放量
13.3.5  50% vs 50%
13.3.6  其他因素
13.3.7  对比实验局限
13.3.8  参数化
13.4  自动化调参
参考文献
第14章  数据监测和效果衡量
14.1  第三方监测
14.2  效果跟踪
14.2.1  归因模型
14.2.2  增效测试
参考文献
第15章  在线广告的发展趋势
15.1  网络带来的变化
15.2  未来发展趋势
15.2.1  流量入口
15.2.2  需求和市场
附录A  单词表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>在线广告
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业数字化转型架构：互联网+时代的创新技术与实践
第1 部分 理论篇
1 数字化转型概述 .................................................................................................. 2
1.1 数字化转型势在必行 ........................................................................................... 3
1.1.1 数字化倒逼转型 ..................................................................................................... 3
1.1.2 数字化转型的演变 .............................................................................................. 6
1.1.3 企业数字化转型 ................................................................................................... 9
1.1.4 启程数字化转型 ........................................................................................... 14
1.1.5 数字化能力 ........................................................................................................ 16
1.2 数字化架构转型 ................................................................................................. 20
1.2.1 记录型系统（SoR）与交互参与型系统（SoE）的融合 ........................................ 21
1.2.2 创新的源泉——分析洞察系统（System of Insight） .............................................. 25
1.2.3 联通的纽带——集成交互系统 ............................................................... 26
1.2.4 快速创新，力争优势——创新型系统 ................................................... 28
1.3 数字化转型热点：API 经济与物联网 .............................................................. 29
1.3.1 企业与外部生态环境的互联互通：API 经济的到来 ............................................... 29
1.3.2 物物互联互通 ........................................................................................ 39
1.4 小结 ..................................................................................................................... 44
1.5 本章参考文献 ..................................................................................................... 45
2 数字化转型技术分析 ......................................................................................... 47
2.1 CAMSS 的相互融合及需要考虑的问题 .......................................................... 47
2.1.1 CAMSS 相辅相成，浑然天成 ................................................................................... 47
2.1.2 CAMSS 驱动下的数字化转型进一步凸显了架构的重要性 ................................... 50
2.1.3 CAMSS 带来了更为复杂的系统运营及企业GRC（治理、风险及合规）压力 .. 52
2.1.4 CAMSS 对企业应用交付带来的影响——开放式创新 ............................................ 53
2.1.5 根据企业自身情况循序渐进考虑CAMSS 的采用 .................................................. 56
2.2 云——数字化转型的载体 ................................................................................. 58
2.2.1 云的演进及未来发展展望 ................................................................... 58
2.2.2 动态混合云的策略和发展方向 ............................................................... 61
2.2.3 企业的云计算实践模式 ........................................................................... 63
2.2.4 云对企业架构的影响和挑战 .................................................................... 66
2.3 分析——从数据分析到知识到认知 ................................................................. 66
2.3.1 分析需求的演变 .................................................................................... 67
2.3.2 分析模式的转型 ........................................................................... 69
2.3.3 数据分析的新发展对企业架构的影响和挑战 ............................... 71
2.4 移动——巨大的转型杠杆 ................................................................................. 73
2.4.1 移动发展趋势概述 .................................................................................. 73
2.4.2 移动应用的特点及挑战 ................................................................. 75
2.4.3 移动对企业架构的影响和挑战 ....................................................... 77
2.5 社交——社交商务深刻改变着企业内外协作方式 .......................................... 80
2.5.1 社交网络的演进及发展概述 ............................................................. 81
2.5.2 社交商务 .............................................................................................. 83
2.5.3 社交对企业架构的影响和挑战 ............................................................ 86
2.6 安全——无处不在的平衡艺术 ......................................................................... 87
2.6.1 信息系统安全的演进及发展趋势 ......................................... 88
2.6.2 从架构角度看安全 ........................................................................... 91
2.6.3 安全在CAMS 快速发展下的新课题 .................................................... 93
2.7 应用交付——企业级敏捷与开发运营一体化 .................................................. 93
2.7.1 应用交付的演变及发展趋势 ............................................................ 94
2.7.2 高质量的快速交付需要多种DevOps 实践 ..................................... 97
2.7.3 数字化转型下的企业需要企业级敏捷及DevOps 思路 ....................... 98
2.8 CAMSS 架构转型原则 .................................................................................... 102
2.8.1 新技术引入应注重与传统企业IT 技术架构的融合 ........................ 103
2.8.2 新技术架构应考虑外部能力的熔接 .............................................. 104
2.8.3 创新过程的敏捷 ....................................................................... 105
2.9 小结 ................................................................................................................... 105
2.10 本章参考文献 ................................................................................................. 106
3 数字化转型架构的实现方法 ............................................................................ 109
3.1 思考与行动：企业数字化转型架构思考 ....................................................... 109
3.1.1 企业架构标准规范 ................................................................... 109
3.1.2 成功转型的三大要素 .............................................................. 111
3.1.3 IT 架构师的作用 ............................................................... 114
3.2 知行合一：企业数字化转型架构实现方法 ................................................... 115
3.2.1 CAMSS 的架构转型视角 ......................................................................................... 115
3.2.2 CAMSS 架构转型的五种常见方式 ......................................................................... 119
3.2.3 CAMSS 架构转型实现的关键步骤 ......................................................................... 119
3.2.4 示例：Blue Bank 的数字化银行转型背景介绍 ...................................................... 121
3.3 宏观与微观相结合：数字化转型准备中的现状梳理 ................................... 123
3.3.1 现状梳理中的信息收集 ......................................................... 123
3.3.2 现状梳理中的分析整理 ........................................................ 124
3.3.3 示例：Blue Bank 数字化银行转型准备 .................................................................. 125
3.4 数字化转型准备中的转型路线 ....................................................................... 130
3.4.1 IT—业务相结合 ........................................................................................................ 131
3.4.2 数字化能力评估及转型原则 ..................................................... 131
3.4.3 制定转型计划 .................................................... 133
3.4.4 转型技术框架 ................................................... 133
3.4.5 架构构建模块 .................................................................... 138
3.4.6 业务构建模块 ........................................................ 140
3.4.7 人才技能培养 ............................................................... 143
3.4.8 示例：Blue Bank 数字化银行转型差距分析及路线规划 ...................................... 144
3.5 系统化思考：数字化转型试点的需求分析 ................................................... 149
3.5.1 试点项目定义 ............................................................ 150
3.5.2 整理功能需求 .................................................................. 150
3.5.3 整理应用关系 ................................................. 150
3.5.4 整理非功能需求 ................................................................................ 151
3.5.5 示例：Blue Bank 数字化银行转型小微贷项目试点需求分析 .............................. 152
3.6 数字化转型试点的设计实现 ........................................................................... 157
3.6.1 总体架构设计 .................................................................................. 157
3.6.2 关键架构决策 .......................................................................................... 158
3.6.3 方案详细设计 ....................................................................................... 158
3.6.4 运行模型设计 ................................................................................... 159
3.6.5 系统可行性评估 ............................................................................. 160
3.6.6 示例：Blue Bank 数字化银行转型小微贷试点CAMSS 架构设计 ...................... 160
3.7 数字化转型推广中的总结提升 ....................................................................... 176
3.7.1 整理验收软件资产 ................................................................. 176
3.7.2 架构资产分享交流 .................................................................. 177
3.8 数字化转型推广中的全面推广 ....................................................................... 178
3.9 数字化转型中的架构治理 ............................................................................... 178
3.10 小结 ................................................................................................................. 180
3.11 本章参考文献 ................................................................................................. 182
第2 部分 技术篇
4 数字化转型的云计算架构 ............................................................................... 186
4.1 全局视野为导：按图索骥的混合云图 ........................................................... 186
4.1.1 重整三观：突破企业的入云迷局 ............................................................................ 186
4.1.2 剑胆琴心：循序渐进的云计算落地路线 ................................................................ 188
4.2 开放包容为本：云计算开放架构及标准 ....................................................... 190
4.2.1 IBM 开放的云计算总体架构 ................................................................................... 191
4.2.2 软件定义的环境（SDE）与OpenStack .................................................................. 192
4.2.3 企业应用的PaaS 采纳及Cloud Foundry ................................................................. 194
4.2.4 Docker：企业应用的容器化采纳和趋势 ................................................................ 197
4.3 参考架构为先：云计算参考架构（CCRA） ................................................ 199
4.3.1 CCRA 概述及最新发展 ............................................................................................ 199
4.3.2 CCRA 具体应用实例——云化数据中心 ................................................................. 204
4.4 IBM 即服务——IBM 提供的公共云服务 ...................................................... 208
4.4.1 基础服务为实：SoftLayer ........................................................................................ 208
4.4.2 平台服务为要：Bluemix .......................................................................................... 209
4.4.3 应用服务为续：IBM SaaS ....................................................................................... 211
4.5 云计算架构构建模块示例 ............................................................................... 211
4.5.1 云调度及服务提供 ................................................................. 211
4.5.2 平台云专家集成系统 ..................................................... 213
4.6 本章小结 ........................................................................................................... 214
4.7 本章参考文献 ................................................................................................... 214
5 数字化转型的大数据分析架构 ........................................................................ 215
5.1 大数据应用——典型场景与重要开放标准 ................................................... 215
5.1.1 大数据应用典型场景 .............................................................. 215
5.1.2 大数据技术重要开放标准 .................................................. 216
5.1.3 IBM 开放大数据平台 .............................................. 219
5.2 他山之石，可以攻玉——大数据分析参考架构 ............................................ 220
5.2.1 吐故纳新——大数据分析如何解决传统分析方法的不足 .................. 221
5.2.2 与时俱进——大数据分析新的信息蓝图 .......................................... 223
5.2.3 工欲善其事，必先利其器——基于最佳实践的参考架构 .......................... 223
5.3 实践出真知——大数据分析最佳实践 ........................................................... 234
5.3.1 大数据平台架构决策参考 ............................................................ 234
5.3.2 考察大数据平台的关注点 ............................................................. 235
5.4 事半功倍——大数据分析架构模块示例 ....................................................... 236
5.4.1 Hadoop 基础服务 .......................................................................... 236
5.4.2 流数据实时处理与分析 .......................................................................... 237
5.4.3 NoSQL 数据服务 ...................................................................................................... 238
5.4.4 大数据内容分析 ................................................................................. 239
5.4.5 大数据预测分析 .......................................................................... 240
5.5 小结 ................................................................................................................... 241
5.6 本章参考文献 ................................................................................................... 241
6 数字化转型的企业移动架构 ............................................................................ 242
6.1 决胜差异性竞争的企业移动能力 ................................................................... 242
6.2 企业移动应用的开放标准与核心技术 ........................................................... 244
6.2.1 移动应用种类：Web 应用、原生应用和混合应用 ................................................ 244
6.2.2 移动开发标准：W3C 标准 ....................................................................................... 245
6.2.3 移动开发框架：PhoneGap、Cordova 和Worklight ............................................... 246
6.3 企业移动应用的参考架构 ............................................................................... 247
6.3.1 移动应用需求的梳理 ........................................................ 247
6.3.2 移动应用的总体架构 .......................................................... 248
6.3.3 新时代的移动应用开发 .................................................... 250
6.3.4 移动安全及设备管理 .......................................................... 255
6.3.5 移动应用的客户体验分析 .................................................. 256
6.3.6 移动应用模式的关键架构决策 .............................................. 257
6.4 移动应用平台的参考发展路径 ....................................................................... 259
6.5 企业移动应用的架构构建模块示例 ............................................................... 260
6.5.1 移动开发和运行管理 .............................................................. 260
6.5.2 移动终端管理 ............................................................... 262
6.5.3 移动安全管理 .............................................................. 262
6.5.4 移动应用客户体验分析 ................................................ 263
6.6 小结 ................................................................................................................... 264
6.7 本章参考文献 ................................................................................................... 265
7 数字化转型的社交商务架构 ............................................................................ 266
7.1 转型企业的社交商务 ....................................................................................... 267
7.1.1 企业需要社交商务吗 .................................................. 267
7.1.2 社交商务的核心要素，企业智慧的人与团队 ........................................................ 268
7.1.3 积极实践，企业范围内社交商务的应用 ................................................................ 270
7.1.4 开始行动，如何实施社交商务战略措施 ................................................................ 272
7.2 社交商务的开放标准 ....................................................................................... 273
7.2.1 社交互信授权机制：OAuth & OpenID ................................................................... 273
7.2.2 Social API：OpenSocial 标准 .................................................................................. 274
7.3 社交商务参考架构 ........................................................................................... 274
7.3.1 社交商务转型模式 ...................................................... 275
7.3.2 社交商务核心能力 .............................................................. 276
7.3.3 社交商务参考架构 ..................................................... 278
7.4 社交商务最佳实践 ........................................................................................... 279
7.4.1 社交化知识管理模块度量参考 .......................................... 280
7.4.2 社交协作模块度量参考 ................................................... 280
7.5 社交商务架构构建模块示例 ........................................................................... 281
7.5.1 多渠道用户体验 ................................................. 281
7.5.2 社交协作沟通 ............................................................ 282
7.5.3 智慧团队 ...................................................................... 284
7.5.4 社交化知识管理 ........................................................ 285
7.6 小结 ................................................................................................................... 286
7.7 本章参考文献 ................................................................................................... 286
8 数字化转型的企业安全架构 ............................................................................ 287
8.1 数字化转型过程中不可忽视的安全风险 ....................................................... 287
8.2 行业内重要的安全管理体系和安全标准 ....................................................... 288
8.3 IBM 企业安全框架 .......................................................................................... 289
8.3.1 高级安全及威胁研究 ............................................ 290
8.3.2 人员安全 .................................................................... 291
8.3.3 数据安全 ........................................................... 292
8.3.4 应用安全 .................................................... 292
8.3.5 基础设施安全 ....................................................... 293
8.3.6 高级欺诈防护 ............................................. 294
8.3.7 安全智能与分析 ................................................. 294
8.4 企业安全管理最佳实践 ....................................... 295
8.4.1 安全成熟度模型 ......................................................... 296
8.4.2 云安全参考建议 ..................................................... 296
8.4.3 移动安全参考建议 ................................................. 300
8.5 企业安全架构构建模块示例 ............................................. 305
8.5.1 安全信息和事件管理及审计 ...................................... 306
8.5.2 应用安全保护 ...................................................... 307
8.5.3 身份管理和访问控制 ............................................. 308
8.5.4 集中化用户目录 ..................................................... 309
8.6 小结 ................................................................................................................... 310
8.7 本章参考文献 ................................................................................................... 310
9 数字化转型架构的持续交付途径——DevOps ................................................. 311
9.1 IBM DevOps 参考架构 ................................................................................... 311
9.2 DevOps 四大要素 ............................................................................................ 312
9.2.1 需求掌控 .............................................................................. 313
9.2.2 开发与测试 ..................................................................... 314
9.2.3 发布和部署 ................................................................... 320
9.2.4 监控和优化 ........................................................ 322
9.3 DevOps 工具平台及关键技术 ......................................................................... 325
9.3.1 DevOps 基础平台技术——OSGi 和REST 服务 ..................................................... 325
9.3.2 开放的生命周期协作服务（OSLC）和Jazz 整合架构（JIA） ........................... 326
9.3.3 智慧运维的核心——智能化分析技术 ..................................................................... 327
9.4 DevOps 关键架构构建模块示例 ..................................................................... 329
9.4.1 需求管理 ..................................................................... 329
9.4.2 软件配置变更管理 ................................................................ 330
9.4.3 软件自动化部署 ............................................................... 331
9.4.4 IT 运维分析预测 ...................................................................................................... 332
9.5 小结 ................................................................................................................... 333
9.6 本章参考文献 ................................................................................................... 333
10 API 管理平台——让API 经济快速落地 ......................................................... 335
10.1 从API 战略入手，稳步迈向API 经济 ........................................................ 335
10.2 他山之石——借鉴API 参考架构 ................................................................. 337
10.3 聚焦发力——API 平台关键组件和核心技术 .............................................. 338
10.4 迭代优化——API 系统实现和部署架构 ...................................................... 339
10.4.1 如何定义好的API ................................................................................................... 340
10.4.2 如何选择API 平台 ...................................................... 343
10.4.3 API 系统的安全策略 .......................................................... 345
10.4.4 API 开发者门户 ............................................................... 349
10.4.5 API 系统部署架构 ..................................................... 351
10.5 API 管理架构构建模块示例 ......................................................................... 352
10.5.1 API 网关 ................................................................... 352
10.5.2 API 管理平台 .................................................. 353
10.5.3 API 开发者门户 ................................................... 354
10.6 小结 ................................................................................................................. 355
10.7 本章参考文献 ................................................................................................. 355
第3 部分 实践篇
11 云计算应用案例 .............................................................................................. 358
11.1 平台云——专家集成系统案例 ...................................................................... 358
11.1.1 中小银行的应用运维之痛 ........................................... 358
11.1.2 基于自动化专家运维思路实现自动化运维 .......................... 359
11.1.3 IBM 一体化PaaS 云点石成金 ................................... 361
11.2 运营商的SaaS 云服务案例 ........................................................................... 363
11.2.1 一片等待开发的沃土——中小型企业的信息化 ............................. 363
11.2.2 运营商在云服务创新中的艰难转身 .................................. 364
11.2.3 一个低成本、安全并提供业务弹性的云服务中心 .............................................. 365
11.2.4 合作共赢——新市场环境中的成功之道 ........................... 366
12 大数据应用案例 ............................................................................................. 367
12.1 大数据客户洞察 ............................................................................................. 367
12.1.1 从“粗放营销”转向“精准营销”的互联网金融创新 ...................................... 367
12.1.2 基于大数据的客户洞察所面临的挑战 ...................... 368
12.1.3 大数据客户洞察解决方案的落地 ........................................ 368
12.1.4 360 度客户全景视图的刻画和实现 ................................ 369
12.1.5 通过大数据分析，提高客户转化率 ...................................................................... 370
12.2 大数据实时流数据处理 ................................................................................. 371
12.2.1 面向客户体验的运营商移动网络质量实时监测分析 .............. 371
12.2.2 大数据时代，移动网络实时监测需要的不仅仅是海纳百川的容量 .................. 372
12.2.3 采用海量数据流处理技术，实现移动网络质量实时监测分析 .......................... 373
12.2.4 如虎添翼，移动网络实时监测分析为运营商带来的价值 .................................. 376
13 移动应用案例 ................................................................................................. 377
13.1 手机医疗案例 ................................................................................................. 377
13.1.1 看病难，难于上青天：就诊流程优化迫在眉睫 .................................................. 377
13.1.2 移动改变世界，手机医疗平台说起来容易做起来难 .......................................... 377
13.1.3 手机医疗服务平台的总体架构 ................................ 378
13.1.4 手机医疗平台的安全性保障 ........................................... 380
13.1.5 手机医疗平台的多设备支持 ...................................... 380
13.1.6 手机医疗平台的数据交换 ................................................. 380
13.1.7 手机医疗平台的SOA 扩展 ................................................. 381
13.1.8 手机医疗平台的造福于民 .............................................. 382
13.2 自带设备办公BYOD 案例 ............................................................................ 382
13.2.1 移动设备接入企业 ...................................................... 382
13.2.2 移动改变世界，BYOD 设备需求大摸底 ............................................................. 383
13.2.3 制定政策，提供管理 .............................................................................................. 383
13.2.4 注册流程简单明了 .................................................................................................. 384
13.2.5 通过服务门户实现自助服务 ........................................ 385
13.2.6 保护员工个人隐私 ............................................................. 386
13.2.7 划分公司数据和个人数据 .................................... 386
13.2.8 企业敏感数据如何保护 ....................................... 386
13.2.9 BYOD 改变员工的办公习惯 ................................................................................. 387
14 社交商务参考案例——企业内部社交化协作转型 ........................................... 388
14.1 无处不社交（Social Everywhere） ............................................................... 389
14.2 企业协作需要更多的社交化元素 ................................................................. 390
14.3 企业级社交商务 = 业务 + 社交 ................................................................ 391
14.4 企业团队协作、业务整合、知识社区的转型实现及收效 ......................... 392
15 安全应用案例 ................................................................................................. 397
15.1 移动安全案例 ................................................................................................. 397
15.1.1 日益复杂的非传统型金融移动安全 .................................. 397
15.1.2 迫在眉睫的移动安全风险防范 ....................................... 398
15.1.3 如何构建坚固的移动安全之盾 ................................. 399
15.1.4 领先的移动安全所具备的特色 ................................. 403
15.2 银行移动终端管理案例 ................................................................................. 403
15.2.1 便捷与安全，真的不可兼得吗 .............................................................................. 403
15.2.2 安全容器和数据分离，实现移动安全的关键 ...................................................... 404
15.2.3 移动终端管理总体架构 .......................................................................................... 404
15.2.4 移动终端管理的难点实现 ..................................... 405
15.2.5 移动安全管理的持续改进过程 ............................. 408
16 DevOps 持续交付应用案例——银行持续交付创新案例 ................................. 409
17 API 管理平台案例 .......................................................................................... 414
17.1 银行业API 管理平台案例 ............................................................................ 414
17.1.1 银行转型：平台金融催生银行API 经济 .............................................................. 414
17.1.2 说易行难：银行系统繁多，内外兼顾，挑战重重 .............................................. 415
17.1.3 借力IBM API 管理平台，构建完美架构 ............................................................. 416
17.1.4 银行API 平台开放兼容，安全可控，快速上线 .................................................. 417
17.2 车联网API 管理平台案例 ............................................................................ 418
17.2.1 车联天下，大市场，大平台，大战略 .................................................................. 418
17.2.2 实时响应，海量数据，复杂商圈：车联网想说爱你不容易 .............................. 419
17.2.3 先进技术，开放平台，车联天下不再遥不可及 .................................................. 419
17.2.4 数据为核，应用为渠，API 搭台唱戏 ................................................................... 420
17.2.5 开放兼容，安全可控，以API 为核心的车联网正扬帆启航 .............................. 420
本书缘起 ....................................................................................................................... 422
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业数字化转型架构：互联网+时代的创新技术与实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>系统架构设计
第一篇 程序员向架构师转型概述
第1章 程序员向架构师转型 2
1.1 架构设计基本概念 2
1.1.1 架构的基本定义 2
1.1.2 架构演进理论 4
1.1.3 架构设计与系统工程 7
1.2 剖析架构师角色 8
1.2.1 架构师角色 8
1.2.2 当程序员遇到架构师 10
1.3 架构师的视图和视角 11
1.3.1 架构师的视图 12
1.3.2 架构师的视角 16
1.3.3 视图视角与系统工程 18
1.4 程序员如何向架构师成功转型 19
1.4.1 转型成功的三段式模型 19
1.4.2 转型思维导图 20
1.4.3 作为架构师开展工作 21
1.5 本章小结 22
第二篇 软件架构设计知识体系
第2章 软件架构体系结构 24
2.1 软件体系结构 24
2.2 架构风格 25
2.2.1 分布式 25
2.2.2 事件驱动 28
2.2.3 系统结构 31
2.2.4 消息总线 32
2.2.5 适配与扩展 33
2.3 架构模式 35
2.3.1 数据访问 35
2.3.2 服务定位 36
2.3.3 异步化 38
2.3.4 资源管理 39
2.3.5 依赖管理 41
2.4 架构模型 44
2.5 本章小结 45
第3章 领域驱动设计 46
3.1 面向领域思想 46
3.1.1 架构设计与领域驱动 46
3.1.2 领域驱动设计核心概念 47
3.1.3 案例介绍 47
3.2 面向领域的策略设计 48
3.2.1 通用语言 48
3.2.2 领域与上下文 48
3.2.3 领域驱动的架构风格 51
3.2.4 案例策略设计 54
3.3 面向领域的技术设计 56
3.3.1 实体与值对象 56
3.3.2 领域服务 59
3.3.3 领域事件 60
3.3.4 聚合 62
3.3.5 资源库 64
3.3.6 集成界限上下文 65
3.3.7 应用程序 67
3.3.8 案例技术设计 67
3.4 案例实现 69
3.5 本章小结 70
第4章 分布式系统架构设计 72
4.1 分布式系统 73
4.2 RPC架构 74
4.2.1 网络通信 75
4.2.2 序列化 76
4.2.3 传输协议 77
4.2.4 服务调用 78
4.3 分布式服务架构 81
4.3.1 负载均衡与集群容错 81
4.3.2 服务路由 83
4.3.3 服务注册中心 84
4.3.4 服务发布与调用 88
4.3.5 服务监控与治理 90
4.4 分布式服务框架Dubbo剖析 91
4.4.1 Dubbo核心功能 91
4.4.2 Dubbo原理分析 94
4.5 微服务架构 102
4.5.1 微服务实现策略 103
4.5.2 微服务实现技术 104
4.5.3 微服务实现案例 108
4.6 本章小结 109
第5章 架构实现技术体系 110
5.1 缓存与性能优化 111
5.1.1 性能概述 111
5.1.2 Memcached 112
5.1.3 Redis 116
5.1.4 Nginx 120
5.2 消息传递系统 122
5.2.1 消息中间件需求 122
5.2.2 JMS 123
5.2.3 AMQP 126
5.2.4 Kafka 129
5.3 企业服务总线 130
5.3.1 服务总线解决方案 130
5.3.2 集成化端点 136
5.4 数据分析处理 140
5.4.1 轻量级批处理 140
5.4.2 SpringBatch 142
5.5 安全性 147
5.5.1 安全性概述 147
5.5.2 安全性实现技术 148
5.6 本章小结 151
第三篇 软件架构设计系统工程
第6章 软件工程学 154
6.1 软件工程学概述 154
6.2 软件实现 155
6.2.1 需求工程 155
6.2.2 系统建模与案例分析 157
6.2.3 软件实现与架构师 165
6.3 项目管理 166
6.3.1 项目管理体系 167
6.3.2 项目研发过程的透明化管理 173
6.3.3 项目管理与架构师 178
6.4 过程改进 179
6.4.1 软件过程模型 179
6.4.2 软件过程改进 181
6.4.3 过程改进与架构师 182
6.5 本章小结 183
第7章 敏捷方法与实践 184
7.1 敏捷方法论概述 184
7.2 极限编程与工程实践 186
7.2.1 极限编程方法 186
7.2.2 极限编程工程实践 186
7.3 Scrum与过程管理 191
7.3.1 Scrum简介 191
7.3.2 Scrum框架 192
7.3.3 如何进行敏捷回顾案例分析 194
7.4 敏捷方法论与架构师 198
7.4.1 敏捷开发中架构师的角色 198
7.4.2 识别和消除研发过程浪费 199
7.5 本章小结 204
第8章 软件交付模型 205
8.1 软件交付模型概述 205
8.2 配置管理 206
8.2.1 配置管理概述 206
8.2.2 配置管理模式与实践 209
8.2.3 SVN／GIT基本应用与实践 210
8.2.4 系统版本控制策略案例分析 214
8.3 持续集成 217
8.3.1 持续集成理念 217
8.3.2 Jenkins应用 219
8.4 交付工作流 219
8.5 本章小结 220
第四篇 架构师软技能
第9章 架构师必备软技能 222
9.1 架构师与外部环境 222
9.1.1 政治与协商 223
9.1.2 沟通 224
9.1.3 邮件 227
9.2 架构师与自身团队 231
9.2.1 领导力 231
9.2.2 知识管理 232
9.2.3 人员管理 235
9.2.4 绩效管理 237
9.3 架构师与意识形态 240
9.3.1 思维模式 241
9.3.2 引入变化 241
9.4 本章小结 245
参考文献 246
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>系统架构设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实现领域驱动设计
序............... xix
前言............. xxi
致谢............ xxxi
关于作者................... xxxv
如何使用本书.........xxxvii
第1章 DDD入门...............1
我能DDD吗？..................2
为什么我们需要DDD.............5
如何DDD...................... 17
使用DDD的业务价值..............22
1.你获得了一个非常有用的领域模型................22
2.你的业务得到了更准确的定义和理解............23
3.领域专家可以为软件设计做出贡献...........23
4.更好的用户体验....................23
5.清晰的模型边界.....................24
6.更好的企业架构..............24
7.敏捷、迭代式和持续建模....................24
8.使用战略和战术新工具........................24
实施DDD所面临的挑战.....................25
虚构的案例，真实的实践................... 33
本章小结.........................36
第2章 领域、子域和限界上下文.....................37
总览....................... 37
工作中的子域和限界上下文............................. 38
将关注点放在核心域上............................. 42
战略设计为什么重要.................... 45
现实世界中领域和子域...................48
理解限界上下文..................... 53
限界上下文不仅仅只包含模型..................... 57
限界上下文的大小...................... 59
与技术组件保持一致................... 61
示例上下文........................ 62
协作上下文..................63
身份与访问上下文..................69
敏捷项目管理上下文................. 71
本章小结....................................73
第3章 上下文映射图............................75
上下文映射图为什么重要........................ 75
绘制上下文映射图......................77
产品和组织关系........................79
映射3个示例限界上下文........................82
本章小结............................97
第4章 架构.......................99
采访一个成功的CIO.................... 100
分层................................. 104
依赖倒置原则.................... 107
六边形架构（端口与适配器）..................... 110
面向服务架构.......................114
REST................................117
REST作为一种架构风格...........................117
RESTful HTTP服务器的关键方面 ........................................ 118
RESTful HTTP客户端的关键方面 ........................................ 119
REST和DDD..................... 120
为什么是REST？......................... 121
命令和查询职责分离——CQRS................. 121
CQRS的各个方面........................ 123
处理具有最终一致性的查询模型.................. 128
事件驱动架构................... 129
管道和过滤器..................... 131
长时处理过程（也叫Saga）................... 134
事件源...................... 140
数据网织和基于网格的分布式计算....................... 143
数据复制..................... 144
事件驱动网织和领域事件.................. 145
持续查询................... 145
分布式处理...................... 146
本章小结............................ 148
第5章 实体......................... 149
为什么使用实体......................... 149
唯一标识............................ 151
用户提供唯一标识......................... 152
应用程序生成唯一标识........................... 153
持久化机制生成唯一标识............................ 156
另一个限界上下文提供唯一标识..................... 160
标识生成时间..................... 161
委派标识......................... 163
标识稳定性.......................... 165
发现实体及其本质特征............................. 167
揭开实体及其本质特征的神秘面纱................. 168
挖掘实体的关键行为.......................... 172
角色和职责......................... 176
创建实体......................... 181
验证................................... 183
跟踪变化............................ 192
本章小结................................ 192
第6章 值对象..................... 193
值对象的特征.......................... 194
度量或描述.......................... 195
不变性........................... 195
概念整体................................ 196
可替换性.......................... 199
值对象相等性..........................200
无副作用行为............................. 201
最小化集成..................204
用值对象表示标准类型........................206
测试值对象........................ 210
实现.............................. 214
持久化值对象................. 219
拒绝由数据建模泄漏带来的不利影响..................220
ORM与单个值对象................................ 221
多个值对象序列化到单个列中.....................224
使用数据库实体保存多个值对象....................225
使用联合表保存多个值对象..........................229
ORM与枚举状态对象........................................230
本章小结....................... 233
第7章 领域服务.................................235
什么是领域服务（首先，什么不是领域服务）.................. 237
请确定你是否需要一个领域服务................................ 238
建模领域服务.................. 241
独立接口有必要吗.............................244
一个计算过程..........................246
转换服务........................249
为领域服务创建一个迷你层.........................250
测试领域服务............................250
本章小结.................. 253
第8章 领域事件...............................255
何时/为什么使用领域事件.......................... 255
建模领域事件.................... 258
创建具有聚合特征的领域事件................... 263
身份标识............................264
从领域模型中发布领域事件.............................. 265
发送方................... 265
订阅方.....................269
向远程限界上下文发布领域事件............................. 271
消息设施的一致性........................... 271
自治服务和系统............................. 272
容许时延.................. 273
事件存储.................. 274
转发存储事件的架构风格........................... 279
以REST资源的方式发布事件通知....................... 279
通过消息中间件发布事件通知.................. 283
实现............................284
发布NotificationLog............... 285
发布基于消息的事件通知..............................290
本章小结........................297
第9章 模块................................299
通过模块完成设计..................................299
模块的基本命名规范..........................302
领域模型的命名规范...........................302
敏捷项目管理上下文中的模块..............................305
其他层中的模块..................308
先考虑模块，再是限界上下文...............................309
本章小结......................... 310
第10章 聚合...................... 311
在Scrum核心领域中使用聚合........................ 312
第一次尝试：臃肿的聚合....................... 313
第二次尝试：多个聚合........................... 314
原则：在一致性边界之内建模真正的不变条件................317
原则：设计小聚合............................. 319
不要相信每一个用例............................ 321
原则：通过唯一标识引用其他聚合......................... 322
通过标识引用使多个聚合协同工作 ...................................... 324
建模对象导航性............................ 325
可伸缩性和分布式............................. 326
原则：在边界之外使用最终一致性............................. 327
谁的任务？............................ 328
打破原则的理由......................... 329
理由之一：方便用户界面................................. 329
理由之二：缺乏技术机制............................. 330
理由之三：全局事务.......................................... 331
理由之四：查询性能.................................. 331
遵循原则.................... 332
通过发现，深入理解............................... 332
重新思考设计............................... 332
估算聚合成本............................. 334
常见用例场景........................ 335
内存消耗............................ 336
探索另外的设计................................... 337
实现最终一致性.............................. 338
这是Scrum团队成员的任务吗？......................... 339
决定的时候到了.............................. 341
实现........................................ 341
创建具有唯一标识的根实体........................ 342
优先使用值对象...................... 343
使用迪米特法则和“告诉而非询问”原则 ...............344
乐观并发...............346
避免依赖注入................348
本章小结................................ 349
第11章 工厂................. 351
领域模型中的工厂................. 351
聚合根中的工厂方法............................. 352
创建CalendarEntry实例................... 353
创建Discussion实例............................ 357
领域服务中的工厂.......................... 358
本章小结.......................... 361
第12章 资源库...........................363
面向集合资源库...........................364
Hibernate实现...................... 369
TopLink实现.................... 377
面向持久化资源库........................ 379
Coherence实现............................ 381
MongoDB实现......................... 386
额外的行为...................................... 391
管理事务................................. 393
警告................................. 397
类型层级............................... 397
资源库 vs 数据访问对象（DAO）..............................400
测试资源库.......................................... 401
以内存实现进行测试...................404
本章小结................................407
第13章 集成限界上下文...............................409
集成基础知识....................................409
分布式系统之间存在根本性区别.......................411
跨系统边界交换信息...............................411
通过REST资源集成限界上下文......................... 417
实现REST资源.......................... 418
使用防腐层实现REST客户端........... 421
通过消息集成限界上下文................ 428
从Scrum的产品负责人和团队成员处得到持续通知 .................... 428
你能处理这样的职责吗？..................... 434
长时处理过程，以及避免职责............. 439
长时处理过程的状态机和超时跟踪器 .................................. 450
设计一个更复杂的长时处理过程 ..........................................460
当消息机制或你的系统不可用时 ...........................................464
本章小结.................................465
第14章 应用程序..................467
用户界面...................................469
渲染领域对象............. 470
渲染数据传输对象................... 471
使用调停者发布聚合的内部状态 .......................................... 471
通过领域负载对象渲染聚合实例 .......................................... 472
聚合实例的状态展现............................. 473
用例优化资源库查询...................... 474
处理不同类型的客户端................... 474
渲染适配器以及处理用户编辑............. 475
应用服务 ............................................ 478
示例应用服务 ................................ 478
解耦服务输出 .....................485
组合多个限界上下文 .....................487
基础设施 ...............................489
企业组件容器 ....................490
本章小结 ....................494
附录A 聚合与事件源：A+ES ..........................495
应用服务内部 ....................... 496
命令处理器 .....................505
Lambda语法...................508
并发控制 ....................... 510
A+ES所带来的结构自由性 .............. 513
性能 ............................ 513
实现事件存储 ..................... 516
关系型持久化 .................. 520
BLOB持久化 ...................... 522
专注的聚合 ............................ 523
读模型投射 ........................... 524
与聚合设计一道使用 ................ 527
增强事件 ........................... 527
工具和模式 ................... 529
事件序列器 .......... 530
事件不变性 ................ 531
值对象 ..................... 531
协议生成 .................... 534
单元测试和需求规范 .............. 535
事件源和函数式语言 .......... 536
参考文献 ..................539
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实现领域驱动设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>J2EE架构师认证指南
译者序 前言 第1章 什么是体系

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>J2EE架构师认证指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务设计
前言　　xiv
第1章　微服务　　1
1.1　什么是微服务　　2
1.1.1　很小，专注于做好一件事　　2
1.1.2　自治性　　3
1.2　主要好处　　3
1.2.1　技术异构性　　3
1.2.2　弹性　　4
1.2.3　扩展　　5
1.2.4　简化部署　　5
1.2.5　与组织结构相匹配　　6
1.2.6　可组合性　　6
1.2.7　对可替代性的优化　　6
1.3　面向服务的架构　　7
1.4　其他分解技术　　7
1.4.1　共享库　　8
1.4.2　模块　　8
1.5　没有银弹　　9
1.6　小结　　10
第2章　演化式架构师　　11
2.1　不准确的比较　　11
2.2　架构师的演化视角　　12
2.3　分区　　14
2.4　一个原则性的方法　　15
2.4.1　战略目标　　15
2.4.2　原则　　15
2.4.3　实践　　16
2.4.4　将原则和实践相结合　　16
2.4.5　真实世界的例子　　16
2.5　要求的标准　　17
2.5.1　监控　　18
2.5.2　接口　　18
2.5.3　架构安全性　　18
2.6　代码治理　　18
2.6.1　范例　　19
2.6.2　裁剪服务代码模板　　19
2.7　技术债务　　20
2.8　例外管理　　21
2.9　集中治理和领导　　21
2.10　建设团队　　22
2.11　小结　　23
第3章　如何建模服务　　24
3.1　MusicCorp简介　　24
3.2　什么样的服务是好服务　　25
3.2.1　松耦合　　25
3.2.2　高内聚　　25
3.3　限界上下文　　26
3.3.1　共享的隐藏模型　　26
3.3.2　模块和服务　　27
3.3.3　过早划分　　28
3.4　业务功能　　28
3.5　逐步划分上下文　　29
3.6　关于业务概念的沟通　　30
3.7　技术边界　　30
3.8　小结　　31
第4章　集成　　32
4.1　寻找理想的集成技术　　32
4.1.1　避免破坏性修改　　32
4.1.2　保证API的技术无关性　　32
4.1.3　使你的服务易于消费方使用　　33
4.1.4　隐藏内部实现细节　　33
4.2　为用户创建接口　　33
4.3　共享数据库　　33
4.4　同步与异步　　35
4.5　编排与协同　　35
4.6　远程过程调用　　38
4.6.1　技术的耦合　　38
4.6.2　本地调用和远程调用并不相同　　39
4.6.3　脆弱性　　39
4.6.4　RPC很糟糕吗　　40
4.7　REST　　41
4.7.1　REST和HTTP　　41
4.7.2　超媒体作为程序状态的引擎　　42
4.7.3　JSON、XML还是其他　　44
4.7.4　留心过多的约定　　44
4.7.5　基于HTTP的REST的缺点　　45
4.8　实现基于事件的异步协作方式　　46
4.8.1　技术选择　　46
4.8.2　异步架构的复杂性　　47
4.9　服务即状态机　　48
4.10　响应式扩展　　48
4.11　微服务世界中的DRY和代码重用的危险　　49
4.12　按引用访问　　50
4.13　版本管理　　51
4.13.1　尽可能推迟　　51
4.13.2　及早发现破坏性修改　　52
4.13.3　使用语义化的版本管理　　53
4.13.4　不同的接口共存　　53
4.13.5　同时使用多个版本的服务　　54
4.14　用户界面　　55
4.14.1　走向数字化　　56
4.14.2　约束　　56
4.14.3　API组合　　57
4.14.4　UI片段的组合　　57
4.14.5　为前端服务的后端　　59
4.14.6　一种混合方式　　60
4.15　与第三方软件集成　　61
4.15.1　缺乏控制　　61
4.15.2　定制化　　62
4.15.3　意大利面式的集成　　62
4.15.4　在自己可控的平台进行定制化　　62
4.15.5　绞杀者模式　　64
4.16　小结　　65
第5章　分解单块系统　　66
5.1　关键是接缝　　66
5.2　分解MusicCorp　　67
5.3　分解单块系统的原因　　68
5.3.1　改变的速度　　68
5.3.2　团队结构　　68
5.3.3　安全　　68
5.3.4　技术　　68
5.4　杂乱的依赖　　69
5.5　数据库　　69
5.6　找到问题的关键　　69
5.7　例子：打破外键关系　　70
5.8　例子：共享静态数据　　71
5.9　例子：共享数据　　72
5.10　例子：共享表　　73
5.11　重构数据库　　74
5.12　事务边界　　75
5.12.1　再试一次　　76
5.12.2　终止整个操作　　77
5.12.3　分布式事务　　77
5.12.4　应该怎么办呢　　78
5.13　报告　　78
5.14　报告数据库　　78
5.15　通过服务调用来获取数据　　80
5.16　数据导出　　81
5.17　事件数据导出　　82
5.18　数据导出的备份　　83
5.19　走向实时　　84
5.20　修改的代价　　84
5.21　理解根本原因　　84
5.22　小结　　85
第6章　部署　　86
6.1　持续集成简介　　86
6.2　把持续集成映射到微服务　　87
6.3　构建流水线和持续交付　　90
6.4　平台特定的构建物　　91
6.5　操作系统构建物　　92
6.6　定制化镜像　　93
6.6.1　将镜像作为构建物　　94
6.6.2　不可变服务器　　95
6.7　环境　　95
6.8　服务配置　　96
6.9　服务与主机之间的映射　　97
6.9.1　单主机多服务　　97
6.9.2　应用程序容器　　99
6.9.3　每个主机一个服务　　100
6.9.4　平台即服务　　101
6.10　自动化　　101
6.11　从物理机到虚拟机　　102
6.11.1　传统的虚拟化技术　　103
6.11.2　Vagrant　　104
6.11.3　Linux容器　　104
6.11.4　Docker　　106
6.12　一个部署接口　　107
6.13　小结　　109
第7章　测试　　110
7.1　测试类型　　110
7.2　测试范围　　111
7.2.1　单元测试　　112
7.2.2　服务测试　　113
7.2.3　端到端测试　　114
7.2.4　权衡　　114
7.2.5　比例　　115
7.3　实现服务测试　　115
7.3.1　mock还是打桩　　115
7.3.2　智能的打桩服务　　116
7.4　微妙的端到端测试　　117
7.5　端到端测试的缺点　　118
7.6　脆弱的测试　　118
7.6.1　谁来写这些测试　　119
7.6.2　测试多长时间　　119
7.6.3　大量的堆积　　120
7.6.4　元版本　　120
7.7　测试场景，而不是故事　　121
7.8　拯救消费者驱动的测试　　121
7.8.1　Pact　　123
7.8.2　关于沟通　　124
7.9　还应该使用端到端测试吗　　124
7.10　部署后再测试　　125
7.10.1　区分部署和上线　　125
7.10.2　金丝雀发布　　126
7.10.3　平均修复时间胜过平均故障间隔时间　　127
7.11　跨功能的测试　　128
7.12　小结　　129
第8章　监控　　131
8.1　单一服务，单一服务器　　132
8.2　单一服务，多个服务器　　132
8.3　多个服务，多个服务器　　133
8.4　日志，日志，更多的日志　　134
8.5　多个服务的指标跟踪　　135
8.6　服务指标　　135
8.7　综合监控　　136
8.8　关联标识　　137
8.9　级联　　139
8.10　标准化　　139
8.11　考虑受众　　140
8.12　未来　　140
8.13　小结　　141
第9章　安全　　143
9.1　身份验证和授权　　143
9.1.1　常见的单点登录实现　　144
9.1.2　单点登录网关　　145
9.1.3　细粒度的授权　　146
9.2　服务间的身份验证和授权　　146
9.2.1　在边界内允许一切　　146
9.2.2　HTTP(S) 基本身份验证　　147
9.2.3　使用SAML或OpenID Connect　　148
9.2.4　客户端证书　　148
9.2.5　HTTP之上的HMAC　　149
9.2.6　API密钥　　149
9.2.7　代理问题　　150
9.3　静态数据的安全　　152
9.3.1　使用众所周知的加密算法　　152
9.3.2　一切皆与密钥相关　　153
9.3.3　选择你的目标　　153
9.3.4　按需解密　　153
9.3.5　加密备份　　153
9.4　深度防御　　154
9.4.1　防火墙　　154
9.4.2　日志　　154
9.4.3　入侵检测（和预防）系统　　154
9.4.4　网络隔离　　155
9.4.5　操作系统　　155
9.5　一个示例　　156
9.6　保持节俭　　158
9.7　人的因素　　158
9.8　黄金法则　　158
9.9　内建安全　　159
9.10　外部验证　　159
9.11　小结　　159
第10章　康威定律和系统设计　　161
10.1　证据　　161
10.1.1　松耦合组织和紧耦合组织　　162
10.1.2　Windows Vista　　162
10.2　Netflix和Amazon　　162
10.3　我们可以做什么　　163
10.4　适应沟通途径　　163
10.5　服务所有权　　164
10.6　共享服务的原因　　164
10.6.1　难以分割　　164
10.6.2　特性团队　　164
10.6.3　交付瓶颈　　165
10.7　内部开源　　166
10.7.1　守护者的角色　　166
10.7.2　成熟　　166
10.7.3　工具　　167
10.8　限界上下文和团队结构　　167
10.9　孤儿服务　　167
10.10　案例研究：RealEstate.com.au　　168
10.11　反向的康威定律　　169
10.12　人　　170
10.13　小结　　170
第11章　规模化微服务　　171
11.1　故障无处不在　　171
11.2　多少是太多　　172
11.3　功能降级　　173
11.4　架构性安全措施　　174
11.5　反脆弱的组织　　175
11.5.1　超时　　176
11.5.2　断路器　　176
11.5.3　舱壁　　178
11.5.4　隔离　　179
11.6　幂等　　179
11.7　扩展　　180
11.7.1　更强大的主机　　181
11.7.2　拆分负载　　181
11.7.3　分散风险　　181
11.7.4　负载均衡　　182
11.7.5　基于worker的系统　　184
11.7.6　重新设计　　184
11.8　扩展数据库　　185
11.8.1　服务的可用性和数据的持久性　　185
11.8.2　扩展读取　　185
11.8.3　扩展写操作　　186
11.8.4　共享数据库基础设施　　187
11.8.5　CQRS　　187
11.9　缓存　　188
11.9.1　客户端、 代理和服务器端缓存　　188
11.9.2　HTTP缓存　　189
11.9.3　为写使用缓存　　190
11.9.4　为弹性使用缓存　　190
11.9.5　隐藏源服务　　191
11.9.6　保持简单　　191
11.9.7　缓存中毒：一个警示　　192
11.10　自动伸缩　　192
11.11　CAP定理　　193
11.11.1　牺牲一致性　　194
11.11.2　牺牲可用性　　195
11.11.3　牺牲分区容忍性　　195
11.11.4　AP还是CP　　196
11.11.5　这不是全部或全不　　196
11.11.6　真实世界　　197
11.12　服务发现　　197
11.13　动态服务注册　　199
11.13.1　Zookeeper　　199
11.13.2　Consul　　200
11.13.4　构造你自己的系统　　201
11.13.5　别忘了人　　201
11.14　文档服务　　201
11.14.1　Swagger　　202
11.14.2　HAL 和HAL浏览器　　202
11.15　自描述系统　　203
11.16　小结　　203
第12章　总结　　204
12.1　微服务的原则　　204
12.1.1　围绕业务概念建模　　205
12.1.2　接受自动化文化　　205
12.1.3　隐藏内部实现细节　　205
12.1.4　让一切都去中心化　　206
12.1.5　可独立部署　　206
12.1.6　隔离失败　　206
12.1.7　高度可观察　　207
12.2　什么时候你不应该使用微服务　　207
12.3　临别赠言　　208
关于作者　　209
关于封面　　209
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业架构与IT战略规划设计教程
第1章  企业架构导论	1
1.1  什么是企业架构	1
1.2  为什么需要企业架构	4
1.3  企业架构理论	7
1.3.1  Zachman架构框架	8
1.3.2  TOGAF架构框架	11
1.3.3  FEA框架	13
1.3.4  DoDAF框架	14
1.4  总结	16
练习	17
第2章  业务架构	18
2.1  信息化与业务架构	19
2.2  企业业务模式	20
2.2.1  SWOT方法	20
2.2.2  PEST分析方法	21
2.2.3  波特五力模型方法	24
2.2.4  关键成功因素法	25
2.2.5  企业系统规划方法	27
2.2.6  竞争态势矩阵	29
2.3  业务架构迁移与信息化需求识别	30
2.3.1  企业的业务能力清单	30
2.3.2  企业的业务能力与信息化需求分析	30
2.4  企业组织变革	35
2.5  未来信息规划的关注点	37
2.6  总结	38
练习	39
第3章  数据架构	40
3.1  数据架构概述	41
3.1.1  什么是数据架构	41
3.1.2  数据架构的现状	41
3.1.3  数据环境分类	42
3.1.4  案例分析：商业银行企业的数据架构设计方案	43
3.2  数据分类	46
3.2.1  什么是数据分类	46
3.2.2  企业数据分类方法	46
3.2.3  企业数据分类规范	48
3.2.4  案例分析：某通信行业集团公司数据分类实例	49
3.3  数据分布	54
3.3.1  数据分布的策略	55
3.3.2  数据分布的两个原则	55
3.3.3  数据分布的应用	55
3.3.4  案例分析：淘宝公司数据库发展史	56
3.4  数据CRUD	58
3.4.1  什么是数据CRUD	58
3.4.2  数据CRUD与SQL	58
3.4.3  数据CRUD的意义	59
3.4.4  案例分析：某通信行业公司CRUD规范	59
3.5  数据模型	61
3.5.1  什么是数据模型	61
3.5.2  数据模型分类	61
3.5.3  企业数据模型	63
3.5.4  案例分析：某通信公司数据模型实例	64
3.5.5  常用数据建模工具	67
3.5.6  案例分析：使用PowerDesigner 15企业架构建模	68
3.6  数据管控	70
3.6.1  概念引入	70
3.6.2  企业数据管控环境	71
3.6.3  案例分析：我国银行业数据管控现状	72
3.7  总结	73
练习	74
第4章  应用架构	75
4.1  应用架构概念引入	75
4.2  应用架构风格	76
4.2.1  管道和过滤器架构风格	77
4.2.2  分层架构风格	78
4.2.3  面向构件架构风格	78
4.2.4  面向服务架构风格	79
4.3  应用架构评价标准	81
4.4  应用架构设计策略	82
4.4.1  全面认识业务需求	83
4.4.2  关键需求决定架构	83
4.4.3  多视角探寻架构	84
4.4.4  尽早验证架构	85
4.5  SOA应用架构设计要点	85
4.5.1  SOA适用性评估	85
4.5.2  SOA总体框架	86
4.5.3  SOA实施过程	87
4.5.4  SOA服务分析	89
4.5.5  SOA服务设计	91
4.5.6  SOA应用效果评估	93
4.6  SOA应用架构设计案例	95
4.6.1  案例分析：电子商务应用架构	95
4.6.2  案例分析：电子政务应用架构	98
4.7  总结	103
练习	103
第5章  基础架构设计与优化	104
5.1  企业的可持续发展战略与工具	104
5.1.1  什么是基础架构	104
5.1.2  基础架构都有什么	105
5.1.3  设计基础架构的方法论	105
5.2  平台选型	106
5.2.1  平台选型方法论	106
5.2.2  工作负载特性分析	108
5.2.3  分布式架构扩展性的相关理论	109
5.3  网络技术与规划	110
5.3.1  需求分析	110
5.3.2  通信协议分析	111
5.3.3  逻辑网络设计与物理网络设计	111
5.3.4  网络测试运行和维护	112
5.4  存储技术与规划	113
5.4.1  通过存储级高可用、容灾设计保证业务连续性	113
5.4.2  信息生命周期管理与分级存储	114
5.5  开发技术与规划	115
5.6  运营技术与规划	117
5.7  云计算与公共基础服务	119
5.8  案例分析：某企业基础架构	122
5.8.1  服务器平台选型	123
5.8.2  存储与网络规划	124
5.8.3  开发测试与运营	125
5.9  总结	125
练习	125
第6章  安全架构	126
6.1  企业安全架构简介	126
6.1.1  企业安全架构的特点	126
6.1.2  企业安全架构的框架	127
6.1.3  企业安全架构的框架分类	129
6.2  安全基础架构	130
6.2.1  物理安全	130
6.2.2  网络安全	132
6.2.3  系统平台安全	139
6.2.4  应用程序安全	141
6.2.5  数据安全	141
6.3  应用架构和安全开发	143
6.3.1  应用架构	143
6.3.2  安全开发	148
6.4  安全运维	148
6.4.1  安全监控	149
6.4.2  事件响应	150
6.4.3  变更管理和配置管理	150
6.4.4  安全补丁管理	150
6.4.5  灾难恢复和业务连续性	151
6.5  安全管理	152
6.5.1  安全组织架构	152
6.5.2  安全策略和标准	153
6.5.3  安全意识	154
6.5.4  安全符合性管理	155
6.6  总结	155
练习	156
第7章  架构迁移	157
7.1  架构迁移策略	157
7.2  项目立项管理	158
7.3  项目集管理	159
7.4  项目集时间计划编制	165
7.4.1  项目单元排序	165
7.4.2  IT预算编制	166
7.4.3  战略风险管理	167
7.5  总结	168
练习	168
第8章  需求管理	169
8.1  需求工程概述	169
8.2  信息化需求管理的作用	170
8.3  广义的需求管理	171
8.4  需求管理实践	172
8.4.1  实践描述	172
8.4.2  需求确认	174
8.4.3  需求跟踪	179
8.4.4  需求变更控制	181
8.4.5  实践建议	189
8.5  需求管理问题分析及应对措施	189
8.5.1  需求管理过程中的问题	189
8.5.2  需求管理应对措施	189
8.6  需求管理规范	191
8.7  案例分析：××银行需求管理体系	192
8.7.1  规范描述	192
8.7.2  流程说明	196
8.8  总结	199
练习	199
第9章  企业架构综合应用案例	200
9.1  Q集团IT现状评估总结	200
9.1.1  国内外宏观发展环境	200
9.1.2  国内外市场环境及需求预测、发展趋势	200
9.1.3  总公司对信息化的要求	201
9.1.4  Q集团的现状	201
9.1.5  信息化需求与访谈问题回顾	201
9.2  Q集团IT战略及原则	203
9.2.1  IT战略目标及定位	204
9.2.2  发展战略	204
9.2.3  发展重点	204
9.2.4  布局原则	205
9.3  Q集团IT业务需求	205
9.3.1  IT业务需求分析	205
9.3.2  IT业务需求细则	206
9.4  Q集团架构迁移策略	208
9.4.1  IT项目定义	208
9.4.2  IT项目预算	211
9.4.3  IT项目依赖关系分析	212
9.4.4  Q集团未来三年的IT总体计划	214
9.4.5  项目实施风险管理	215
9.5  IT规划实施中的变革管理	217
9.6  对Q集团下一步工作的建议	218
课后练习参考答案	220
参考文献	229
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业架构与IT战略规划设计教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>IT架构思维
第一章　什么是架构？
1.1　作为基本要素的架构
1.2　架构与设计有何不同
1.3　总结
第二章　IT架构的适用性
2.1　何时应用架构？
2.2　何处应用架构？
2.3　业务
2.4　信息
2.5　应用
2.6　基础设施
2.7　解决方案
2.8　企业情景
2.9　全面构思
2.10　总结
第三章　IT架构的价值
3.1　关于价值
3.2　对发起者的价值
3.3　对用户的价值
3.4　对实践者的价值
3.5　总结
第四章　惠普全球IT战略和架构方法概述
4.1　架构框架
4.2　ITSA框架
4.3　架构概念方法论
4.4　架构蓝图方法论
4.5　其他框架和方法论
4.6　总结
第五章　业务驱动因素和目标
5.1　业务驱动因素
5.2　业务目标
5.3　业务指标
5.4　总结
第六章　利益相关者和架构视图
6.1　利益相关者
6.2　ITSA中的架构视图
6.3　四种架构视图
6.4　架构视图的关注点
6.5　架构视图与业务类型的依赖关系
6.6　总结
第七章　架构原则
7.1　原则的目的
7.2　原则的范围
7.3　原则的力量
7.4　ITSA中的原则
7.5　原则的世界
7.6　原则不同于目标
7.7　原则不同于需求
7.8　原则不同于政策
7.9　总结
第八章　有效的原则
第九章　议题领域
第十章　架构模型
第十一章　架构标准
第十二章　架构需求
第十三章　汇聚一切
第十四章　架构与项目管理
第十五章　IT架构师职业发展
第十六章　IT架构的参考资料
附录A　驱动因素与目标的SWOT分析
附录B　平衡计分卡
附录C　原则描述的样例
附录D　工具包
附录E　案例研究：Information Worker 2.0
附录F　HPGM for ITSA的发展历程
附录G　其他企业架构框架简介（TOGAF、Zachman、FEA）
关于作者
惠普IT管理学院简介
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>IT架构思维
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据密集型应用系统设计
前言 .....................................................1
第一部分 数据系统基础
第1章 可靠、可扩展与可维护的应用系统 ................... 11
认识数据系统 ...........................................12
可靠性 ..................................................14
可扩展性 ................................................18
可维护性 ................................................25
小结 .....................................................28
第2章 数据模型与查询语言 ............................... 33
关系模型与文档模型 .......................................34
数据查询语言 ...........................................46
图状数据模型 ......................................52
小结 ...................................................65
第3章 数据存储与检索 .................................. 71
数据库核心：数据结构 ...................................72
事务处理与分析处理 ...................................89
列式存储 .........................................94
小结 ..............................................101
第4章 数据编码与演化 .............................. 109
数据编码格式 .................................... 110
数据流模式 ......................................124
小结 .............................................134
第二部分 分布式数据系统
第5章 数据复制 ................................. 145
主节点与从节点 ..................................146
复制滞后问题 ......................................154
多主节点复制 .......................................160
无主节点复制 .....................................168
小结 ..............................................181
第6章 数据分区 ............................... 189
数据分区与数据复制 .................................190
键-值数据的分区 ...................................190
分区与二级索引 ...................................195
分区再平衡 ....................................198
请求路由 ..................................202
小结 .................................204
第7章 事务 .............................. 211
深入理解事务 ......................................212
弱隔离级别 .................................221
串行化 ...........................................237
小结 ...........................................250
第8章 分布式系统的挑战 ...................... 259
故障与部分失效 ...............................260
不可靠的网络 ..................................262
不可靠的时钟 ..................................271
知识，真相与谎言 ...............................282
小结 ..........................................292
第9章 一致性与共识 ..................... 303
一致性保证 ....................................304
可线性化 ........................................305
顺序保证 ........................................319
分布式事务与共识 .................................330
小结 ...............................................349
第三部分 派生数据
第10章 批处理系统 ................................ 367
使用UNIX工具进行批处理 .............................368
MapReduce与分布式文件系统 .........................375
超越MapReduce ....................................394
小结 ............................................403
第11章 流处理系统 .............................. 413
发送事件流 .......................................414
数据库与流 .......................................424
流处理 .........................................435
小结 ............................................449
第12章 数据系统的未来 ............................ 461
数据集成 .........................................461
分拆数据库 .......................................469
端到端的正确性 ....................................484
做正确的事情 .......................................500
小结 ..............................................509
术语表 ............................................ 521
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据密集型应用系统设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>提早6小時下班的工作術
推薦序：工作時間不等於業務績效／戴勝益
推薦序：工作就是要事半功倍／秦夢群
前言
PART 1架構會改變你的工作
STAGE 01為什麼架構是必要的？
案例1高明廚師的美味漢堡肉
案例2將事情完全交由優秀的人處理，真的好嗎？
案例3你認為自己長時間工作，很厲害嗎？
個人的才能和努力，有著無法跨越的一道牆
無論是誰、無論何時、無論做幾次，都可以獲得相同的成果
成功的商業人士都懂得建立架構
STAGE 02需要架構化的工作與不需要架構化的工作
「作業型」與「思考型」
「怕麻煩」的種類
需要用頭腦思考的工作，應該多花些時間和勞力
需要溝通的工作，也能建立架構
STAGE 03為自己的工作建立架構
將成功的體驗架構化
將例行公事架構化
要如何有效的運用時間，是商業人士永遠的課題
靠架構讓日常工作變得更有效率
跳脫「工作時間等於業績」的狀況
建立架構，是在為自己將來的時間做投資
正因為忙碌，所以才有成長的機會
STAGE 04運用架構來領導團隊
管理者所需要的架構
新人和年輕的商業人士，應該去模仿成功者
如果覺得窒礙難行，首先應該重新審視架構
失敗經驗也可以架構化
建立一套「可以確實執行架構」的架構
STAGE 05建立可以長久維持的架構
重點在於，不需要堅強的意志力也能長久持續
持之以恆的竅門1　訂定小目標
持之以恆的竅門2　借助別人的力量
STAGE 06架構工作術的三個黃金原則
原則1不依賴才能
原則 2不依賴意志力
原則 3不依賴記憶力
PART 2讓作業型工作徹底的效率化
STAGE 01徹底活用檢查表
作業型工作要以機械化作業的模式來處理
STAGE 02將工作的內容和程序轉化為檢查表
讓檢查表具備實用性的四個訣竅
例行性工作，在第一次執行時便製作出檢查表
任何事情都做成檢查表
改良和建立同樣重要
PART 3統一管理所有工作項目
STAGE 01掌握資料管理的基本原則
為什麼要統一管理？
統一管理的竅門1從頭到尾只使用一部電腦
統一管理的竅門2什麼東西都丟進去
統一管理的竅門3不要把資料夾分得太細
統一管理的竅門4用一定的規則來建立檔案名稱
統一管理的竅門5建立一個「其他」資料夾
統一管理的竅門6將備份的動作架構化
STAGE 02利用待辦事項清單，統一管理所有工作檔案
活用電腦的工作管理功能
要毫不猶豫的將所有東西都丟進清單中
把新點子和備忘筆記以電子郵件寄給自己
目標管理和幹勁的維持也都可以架構化
STAGE 03「不要思考」的工作術，讓原本要花一天的工作時間縮短為兩小時！
不需設定優先順序，從最輕鬆的工作開始，一鼓作氣處理掉
在早上處理完所有作業型的工作
當天沒處理完的工作該怎麼辦？
STAGE 04為電子郵件的處理建立架構
電子郵件的規則1當場回信
電子郵件的規則2判斷的時間不超過五秒
電子郵件的規則3文章必須在二十行之內結束
電子郵件的規則4準備兩個以上的選項
電子郵件的規則5　二十四小時原則
STAGE 05將情報收集也架構化
基本原則是：「讓自己變成接收者」和「不要阻擋資訊進來」
PART 4架構化工作者的七種好習慣
追求輕鬆
簡單化思考
不靠記憶，只靠記錄
不知道的事，就要問
以時薪的觀念來看待自己的時間
模仿成功者
創造自己的「模式」
PART 5架構工作術的目標
架構化所帶來的效益將高達百倍
建立架構的第一步，就是將它寫下來
貼近問題本質的架構工作術
架構化之後，腦袋就會永遠保持清爽
將自己的財富也架構化
後記
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>提早6小時下班的工作術
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件架构
译者序
前言
第1章　软件架构中面向对象、基于组件、面向代理和面向服务的范式
1.1　引言
1.2　历史
1.2.1　面向对象范式
1.2.2　基于组件范式
1.2.3　面向代理范式
1.2.4　面向服务范式
1.3　软件架构
1.3.1　面向对象软件架构
1.3.2　基于组件软件架构
1.3.3　面向代理软件架构
1.3.4　面向服务架构
1.4　概念框架的两个维度：定量和定性
1.4.1　概念差异
1.4.2　定量维度
1.4.3　定性维度
1.5　集成开发范式方法
1.6　小结与讨论
1.7　结语
1.8　参考书目
第2章　参考架构
2.1　引言
2.2　参考架构的定义
2.2.1　参考架构与参考模型的对比
2.2.2　参考架构与产品线架构的对比
2.3　参考架构模型
2.4　参考架构设计
2.4.1　信息源调查
2.4.2　架构需求确立
2.4.3　参考架构设计
2.4.4　参考架构评估
2.5　参考架构的用途
2.6　参考架构的示例
2.7　参考架构的前景
2.8　结语
2.9　参考书目
第3章　多层次/多视图软件架构
3.1　引言
3.2　现有视点方法
3.2.1　引言
3.2.2　需求规格中的视图
3.2.3　系统建模中的视图
3.2.4　编程中的视图
3.3　软件架构中的视图
3.3.1　视图在软件架构中的贡献
3.3.2　“4+1”视图模型
3.3.3　ISO/IEC/IEEE 42010
3.3.4　视图及超越方法
3.3.5　小结
3.3.6　当前软件架构方法的局限性
3.4　多层次/多视图软件架构的定义和基本概念
3.4.1　定义
3.4.2　概念和基础知识
3.5　MoVAL：基于模型、视图和抽象级别的架构
3.5.1　引言
3.5.2　MoVAL
3.5.3　MoVAL元模型
3.5.4　案例分析
3.6　结语
3.7　参考书目
第4章　软件架构与工具：分布与协调动态重配置管理
4.1　引言
4.2　背景
4.3　分布式应用的动态重配置管理机制
4.3.1　集中动态重配置管理
4.3.2　分布式系统集中解决方案的局限性
4.3.3　分布式重配置管理的优势与风险
4.3.4　现有协调机制
4.4　重配置基础设施的专门化
4.4.1　行为的专门化
4.4.2　适配机制分布的专门化
4.5　分布式系统动态重配置的局限性和难点总结
4.6　重配置管理机制的实施方法
4.7　分布动态重配置管理的架构模型
4.7.1　用于适配管理的组件类型
4.7.2　动态重配置管理的分布
4.7.3　适配管理器架构模型
4.7.4　重配置机制的专门化
4.7.5　重配置过程的协调
4.8　结语
4.9　参考书目
第5章　产品线软件架构
5.1　软件生产线简介
5.1.1　3种开发风格
5.1.2　可变性管理
5.1.3　产品线中的架构概念
5.2　音乐商店示例
5.2.1　领域
5.2.2　SongStock产品线
5.2.3　功能需求
5.2.4　其他主要需求
5.3　领域工程
5.3.1　领域分析
5.3.2　集成可变性用例
5.3.3　特征模型
5.3.4　领域设计
5.3.5　设计产品线架构
5.4　产品工程
5.4.1　产品的配置
5.4.2　产品衍生
5.5　参考架构设计过程
5.6　延伸阅读
5.6.1　PLA与参考架构
5.6.2　具有影响力的旧文献
5.7　结语
5.8　参考书目
第6章　软件架构：Web服务复合环境下的服务适配技术
6.1　引言
6.2　Web服务复合和验证
6.3　Web服务不兼容和适配
6.4　适配方法
6.5　结语
6.6　参考书目
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>小团队构建大网站：中小研发团队架构实践
第1篇  开篇
1  可参考的才是有价值的（含案例和代码）
1.1  框架篇—工欲善其事，必先利其器
1.2  架构篇—思想提升
1.3  公共应用篇—业务与技术的结合
1.4  进阶篇—从架构到管理
1.5  案例参考和Demo下载
第2篇  架构篇
2  企业总体架构
2.1  企业商务模型
2.2  架构现状
2.3  领域模型
2.4  架构规划
2.5  架构实施
2.6  案例参考
3  应用架构设计
3.1  初识架构设计
3.2  应用架构设计案例
3.3  更多知识探讨
3.4  互联网公司的架构设计要怎么落地
3.5  你给技术打个分
3.6  案例参考
4  统一应用分层
4.1  为什么要统一应用分层
4.2  统一应用逻辑架构
4.3  分层规范实践
4.4  互动问答
4.5  Demo下载
5  生产环境诊断工具WinDbg
5.1  诊断工具简介
5.2  获取异常进程的Dump文件
5.3  WinDbg的使用方法
5.4  一个真实案例
5.5  Demo下载
第3篇  框架篇
6  RabbitMQ快速入门及应用
6.1  为什么要用消息队列RabbitMQ
6.2  RabbitMQ简介
6.3  RabbitMQ的工作原理
6.4  RabbitMQ的基本用法
6.5  Demo下载
7  Redis快速入门及应用
7.1  Redis简介
7.2  Redis的数据结构
7.3  Redis的重要特性
7.4  使用方法
7.5  Redis Key命名规范与常见问题
7.6  Demo下载
8  任务调度Job
8.1  Job简介
8.2  WinJob
8.3  HttpJob
8.4  Cron表达式
8.5  Demo下载
9  应用监控系统Metrics
9.1  Metrics简介
9.2  埋点Metrics.NET的方法
9.3  Grafana配置
9.3.1  设置仪表盘（Dashboard）
9.3.2  设置面板（Panel）
9.3.3  设置模板Templating
9.3.4  设置Time Range
9.3.5  告警设置
9.4  其他说明
9.5  Metrics的使用价值
9.6  Demo下载
10  集中式日志ELK
10.1  集中式日志
10.2  配置方法
10.3  使用方法
10.4  Demo下载
11  微服务架构MSA
11.1  MSA简介
11.2  MSA框架的使用
11.3  微服务治理
11.4  微服务网关API Gateway
11.5  Demo下载
12  搜索服务Solr
12.1  Solr简介
12.2  Solr的工作原理
12.3  Solr的特性
12.4  Demo下载
13  分布式协调器ZooKeeper
13.1  ZooKeeper是什么
13.2  ZooKeeper的工作原理简介
13.3  ZooKeeper的典型应用场景
13.4  Demo下载
14  小工具合集
14.1  ORM工具
14.2  对象映射工具
14.3  IoC工具
14.4  DLL包管理工具
14.5  Demo下载
15  一键发布和测试之持续集成工具Jenkins
15.1  Jenkins简介
15.2  Jenkins插件与相关工具
15.3  Jenkins关键配置
15.4  Jenkins的使用价值
第4篇  公共应用篇
16  单点登录
16.1  单点登录简介
16.2  SSO技术实现
16.3  JWT规范
17  企业支付网关
17.1  企业支付网关介绍
17.2  统一支付服务
17.3  统一支付通知
17.4  Demo下载
第5篇  进阶篇
18  技改之路：从单体应用到微服务
18.1  系统背景
18.2  前期工作
18.3  技改实施
18.4  总结
18.5  互动问答
19  机票垂直搜索引擎之性能优化
19.1  行业背景与垂直搜索
19.2  主要问题与解决方案
19.3  静态数据与任务打底
19.4  缓存策略与数据一致
19.5  实时查询与三段超时
19.6  政策匹配与算法优化
19.7  小结
20  上云纪要
20.1  为什么要上云
20.2  内部虚拟化和外部云化
20.3  云选型
20.4  上云八条
20.5  成功上云
20.6  上云总结
21  技术与业务的匹配与融合
21.1  技术人员与业务人员的抱怨
21.2  问题出在哪里
21.3  理解源于彼此的了解
21.4  如何去匹配与融合
21.5  什么在驱动公司的发展
22  研发团队文化是怎么“长”出来的
22.1  神秘的文化
22.2  遇到的问题
22.3  解决之道
22.4  总结与提升
22.5  “长”出来的团队文化
后记
架构师进阶之路
谈谈互联网公司的技术架构和管理
短评
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>小团队构建大网站：中小研发团队架构实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大型网站系统与Java中间件开发实践
第1章  分布式系统介绍	1
1.1  初识分布式系统	1
1.1.1  分布式系统的定义	1
1.1.2  分布式系统的意义	3
1.2  分布式系统的基础知识	5
1.2.1  组成计算机的5要素	5
1.2.2  线程与进程的执行模式	6
1.2.3  网络通信基础知识	13
1.2.4  如何把应用从单机扩展到分布式	18
1.2.5  分布式系统的难点	31
第2章  大型网站及其架构演进过程	35
2.1  什么是大型网站	35
2.2  大型网站的架构演进	37
2.2.1  用Java技术和单机来构建的网站	37
2.2.2  从一个单机的交易网站说起	38
2.2.3  单机负载告警，数据库与应用分离	40
2.2.4  应用服务器负载告警，如何让应用服务器走向集群	41
2.2.5  数据读压力变大，读写分离吧	50
2.2.6  弥补关系型数据库的不足，引入分布式存储系统	56
2.2.7  读写分离后，数据库又遇到瓶颈	58
2.2.8  数据库问题解决后，应用面对的新挑战	60
2.2.9  初识消息中间件	63
2.2.10  总结	64
第3章  构建Java中间件	67
3.1  Java中间件的定义	67
3.2  构建Java中间件的基础知识	68
3.2.1  跨平台的Java运行环境——JVM	69
3.2.2  垃圾回收与内存堆布局	70
3.2.3  Java并发编程的类、接口和方法	72
3.2.4  动态代理	89
3.2.5  反射	91
3.2.6  网络通信实现选择	93
3.3  分布式系统中的Java中间件	94
第4章  服务框架	97
4.1  网站功能持续丰富后的困境与应对	97
4.2  服务框架的设计与实现	100
4.2.1  应用从集中式走向分布式所遇到的问题	100
4.2.2  透过示例看服务框架原型	101
4.2.3  服务调用端的设计与实现	107
4.2.4  服务提供端的设计与实现	132
4.2.5  服务升级	137
4.3  实战中的优化	138
4.4  为服务化护航的服务治理	142
4.5  服务框架与ESB的对比	146
4.6  总结	147
第5章  数据访问层	149
5.1  数据库从单机到分布式的挑战和应对	149
5.1.1  从应用使用单机数据库开始	149
5.1.2  数据库垂直/水平拆分的困难	150
5.1.3  单机变为多机后，事务如何处理	152
5.1.4  多机的Sequence问题与处理	165
5.1.5  应对多机的数据查询	168
5.2  数据访问层的设计与实现	174
5.2.1  如何对外提供数据访问层的功能	174
5.2.2  按照数据层流程的顺序看数据层设计	177
5.2.3  独立部署的数据访问层实现方式	192
5.2.4  读写分离的挑战和应对	194
5.3  总结	200
第6章  消息中间件	203
6.1  消息中间件的价值	203
6.1.1  消息中间件的定义	203
6.1.2  透过示例看消息中间件对应用的解耦	204
6.2  互联网时代的消息中间件	208
6.2.1  如何解决消息发送一致性	209
6.2.2  如何解决消息中间件与使用者的强依赖问题	218
6.2.3  消息模型对消息接收的影响	222
6.2.4  消息订阅者订阅消息的方式	229
6.2.5  保证消息可靠性的做法	230
6.2.6  订阅者视角的消息重复的产生和应对	245
6.2.7  消息投递的其他属性支持	249
6.2.8  保证顺序的消息队列的设计	252
6.2.9  Push和Pull方式的对比	257
第7章  软负载中心与集中配置管理	259
7.1  初识软负载中心	259
7.2  软负载中心的结构	261
7.3  内容聚合功能的设计	263
7.4  解决服务上下线的感知	267
7.5  软负载中心的数据分发的特点和设计	269
7.5.1  数据分发与消息订阅的区别	269
7.5.2  提升数据分发性能需要注意的问题	271
7.6  针对服务化的特性支持	272
7.6.1  软负载数据分组	272
7.6.2  提供自动感知以外的上下线开关	273
7.6.3  维护管理路由规则	273
7.7  从单机到集群	274
7.7.1  数据统一管理方案	275
7.7.2  数据对等管理方案	276
7.8  集中配置管理中心	280
7.8.1  客户端实现和容灾策略	282
7.8.2  服务端实现和容灾策略	284
7.8.3  数据库策略	285
第8章  构建大型网站的其他要素	287
8.1  加速静态内容访问速度的CDN	287
8.2  大型网站的存储支持	291
8.2.1  分布式文件系统	292
8.2.2  NoSQL	294
8.2.3  缓存系统	298
8.3  搜索系统	301
8.3.1  爬虫问题	302
8.3.2  倒排索引	302
8.3.3  查询预处理	304
8.3.4  相关度计算	304
8.4  数据计算支撑	304
8.5  发布系统	307
8.6  应用监控系统	310
8.7  依赖管理系统	312
8.8  多机房问题分析	315
8.9  系统容量规划	317
8.10  内部私有云	319
后记	                                                 321
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大型网站系统与Java中间件开发实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>领域驱动设计
第一部分 让领域模型发挥作用
第1章 消化知识
1.1 有效建模的要素
1.2 知识消化
1.3 持续学习
1.4 知识丰富的设计
1.5 深层模型
第2章 语言的交流和使用
2.1 模式：UBIQUITOUS LANGUAGE
2.2 “大声地”建模
2.3 一个团队，一种语言
2.4 文档和图
2.4.1 书面设计文档
2.4.2 完全依赖可执行代码的情况
2.5 解释性模型
第3章 绑定模型和实现
3.1 模式：MODEL-DRIVEN DESIGN
3.2 建模范式和工具支持
3.3 揭示主旨：为什么模型对用户至关重要
3.4 模式：HANDS-ON MODELER
第二部分 模型驱动设计的构造块
第4章 分离领域
4.1 模式：LAYERED ARCHITECTURE
4.1.1 将各层关联起来
4.1.2 架构框架
4.2 模型属于领域层
4.3 模式：THE SMART UI“ANTI-PATTERN”
4.4 其他分离方式
第5章 软件中所表示的模型
5.1 关联
5.2 模式：ENTITY（又称为REFERENCE OBJECT）
5.2.1 ENTITY建模
5.2.2 设计标识操作
5.3 模式：VALUE OBJECT
5.3.1 设计VALUE OBJECT
5.3.2 设计包含VALUE OBJECT的关联
5.4 模式：SERVICE
5.4.1 SERVICE与孤立的领域层
5.4.2 粒度
5.4.3 对SERVICE的访问
5.5 模式：ＭODULE（也称为PACKAGE）
5.5.1 敏捷的MODULE
5.5.2 基础设施驱动的打包存在的隐患
5.6 建模范式
5.6.1 对象范式流行的原因
5.6.2 对象世界中的非对象
5.6.3 在混合范式中坚持使用MODEL-DRIVEN DESIGN
第6章 领域对象的生命周期
6.1 模式：AGGREGATE
6.2 模式：FACTORY
6.2.1 选择FACTORY及其应用位置
6.2.2 有些情况下只需使用构造函数
6.2.3 接口的设计
6.2.4 固定规则的逻辑应放置在哪里
6.2.5 ENTITY FACTORY与VALUE OBJECT FACTORY
6.2.6 重建已存储的对象
6.3 模式：REPOSITORY
6.3.1 REPOSITORY的查询
6.3.2 客户代码可以忽略REPOSITORY的实现，但开发人员不能忽略
6.3.3 REPOSITORY的实现
6.3.4 在框架内工作
6.3.5 REPOSITORY与FACTORY的关系
6.4 为关系数据库设计对象
第7章 使用语言：一个扩展的示例
7.1 货物运输系统简介
7.2 隔离领域：应用程序的引入
7.3 将ENTITY和VALUE OBJECT区别开
7.4 设计运输系统中的关联
7.5 AGGREGATE边界
7.6 选择REPOSITORY
7.7 场景走查
7.7.1 应用程序特性举例：更改Cargo的目的地
7.7.2 应用程序特性举例：重复业务
7.8 对象的创建
7.8.1 Cargo的FACTORY和构造函数
7.8.2 添加一个Handling Event
7.9 停下来重构：Cargo AGGREGATE的另一种设计
7.10 运输模型中的ＭODULE
7.11 引入新特性：配额检查
7.11.1 连接两个系统
7.11.2 进一步完善模型：划分业务
7.11.3 性能优化
7.12 小结
第三部分 通过重构来加深理解
第8章 突破
8.1 一个突破的故事
8.1.1 华而不实的模型
8.1.2 突破
8.1.3 更深层模型
8.1.4 冷静决策
8.1.5 成果
8.2 机遇
8.3 关注根本
8.4 后记：越来越多的新理解
第9章 将隐式概念转变为显式概念
9.1 概念挖掘
9.1.1 倾听语言
9.1.2 检查不足之处
9.1.3 思考矛盾之处
9.1.4 查阅书籍
9.1.5 尝试，再尝试
9.2 如何为那些不太明显的概念建模
9.2.1 显式的约束
9.2.2 作为领域对象的过程
9.2.3 模式：SPECIFICATION
9.2.4 SPECIFICATION的应用和实现
第10章 柔 性 设 计
10.1 模式：INTENTION-REVEALING INTERFACES
10.2 模式：SIDE-EFFECT-FREE FUNCTION
10.3 模式：ASSERTION
10.4 模式：CONCEPTUAL CONTOUR
10.5 模式：STANDALONE CLASS
10.6 模式：CLOSURE OF OPERATION
10.7 声明式设计
10.8 声明式设计风格
10.9 切入问题的角度
10.9.1 分割子领域
10.9.2 尽可能利用已有的形式
第11章 分析模式的应用
第12章 将设计模式应用于模型
12.1 模式：STRATEGY（也称为POLICY）
12.2 模式：COMPOSITE
12.3 为什么没有介绍FLYWEIGHT
第13章 通过重构得到更深层的理解
13.1 开始重构
13.2 探索团队
13.3 借鉴先前的经验
13.4 针对开发人员的设计
13.5 重构的时机
13.6 危机就是机遇
第四部分 战略设计
第14章 保持模型的完整性
14.1 模式：BOUNDED CONTEXT
14.2 模式：CONTINUOUS INTEGRATION
14.3 模式：CONTEXT MAP
14.3.1 测试CONTEXT的边界
14.3.2 CONTEXT MAP的组织和文档化
14.4 BOUNDED CONTEXT之间的关系
14.5 模式：SHARED KERNEL
14.6 模式：CUSTOMER/SUPPLIERDEVELOPMENT TEAM
14.7 模式：CONFORMIST
14.8 模式：ANTICORRUPTION LAYER
14.8.1 设计ANTICORRUPTION LAYER的接口
14.8.2 实现ANTICORRUPTION LAYER
14.8.3 一个关于防御的故事
14.9 模式：SEPARATE WAY
14.10 模式：OPEN HOST SERVICE
14.11 模式：PUBLISHED LANGUAGE
14.12 “大象”的统一
14.13 选择你的模型上下文策略
14.13.1 制定团队决策或更高层的决策
14.13.2 在上下文中工作
14.13.3 转换边界
14.13.4 接受那些我们无法更改的事物：描述外部系统
14.13.5 与外部系统的关系
14.13.6 正在设计的系统
14.13.7 满足不同模型的特殊需要
14.13.8 部署
14.13.9 权衡
14.13.10 当项目正在进行时
14.14 转换
14.14.1 合并CONTEXT：SEPARATE WAY →SHARED KERNEL
14.14.2 合并CONTEXT：SHARED KERNEL→CONTINUOUS INTEGRATION
14.14.3 逐步淘汰遗留系统
14.14.4 OPEN HOST SERVICE→PUBLISHED LANGUAGE
第15章 精炼
15.1 模式：CORE DOMAIN
15.1.1 选择核心
15.1.2 工作的分配
15.2 精炼的逐步提升
15.3 模式：GENERIC SUBDOMAIN
15.3.1 通用不等于可以重用
15.3.2 项目风险管理
15.4 模式：DOMAIN VISION STATEMENT
15.5 模式：HIGHLIGHTED CORE
15.5.1 精炼文档
15.5.2 标明CORE
15.5.3 把精炼文档作为过程工具
15.6 模式：COHESIVE MECHANISM
15.6.1 GENERIC SUBDOMAIN与COHE-SIVE MECHANISM的比较
15.6.2 MECHANISM是CORE DOMAIN一部分
15.7 通过精炼得到声明式风格
15.8 模式：SEGREGATED CORE
15.8.1 创建SEGREGATED CORE的代价
15.8.2 不断发展演变的团队决策
15.9 模式：ABSTRACT CORE
15.10 深层模型精炼
15.11 选择重构目标
第16章 大比例结构
16.1 模式：EVOLVING ORDER
16.2 模式：SYSTEM METAPHOR
16.3 模式：RESPONSIBILITY LAYER
16.4 模式：KNOWLEDGE LEVEL
16.5 模式：PLUGGABLE COMPONENT FRAMEWORK
16.6 结构应该有一种什么样的约束
16.7 通过重构得到更适当的结构
16.7.1 最小化
16.7.2 沟通和自律
16.7.3 通过重构得到柔性设计
16.7.4 通过精炼可以减轻负担
第17章 领域驱动设计的综合运用
17.1 把大比例结构与BOUNDED CONTEXT结合起来使用
17.2 将大比例结构与精炼结合起来使用
17.3 首先评估
17.4 由谁制定策略
17.4.1 从应用程序开发自动得出的结构
17.4.2 以客户为中心的架构团队
17.5 制定战略设计决策的6个要点
17.5.1 技术框架同样如此
17.5.2 注意总体规划
结束语
附录
术语表
参考文献
图片说明
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>领域驱动设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向服务的企业应用架构
第1章 面向服务的企业应用架构概要
1.1 面向服务架构的必然性
1.1.1 阿凡提的兔子汤
1.1.2 秦始皇的度量“衡”
1.1.3 达尔文的“适变”理论
1.1.4 高尔的成功系统定律
1.2 软件工程与SOA成熟度
1.3 什么是面向服务的架构
1.3.1 SOA的架构定义
1.3.2 SOA架构师的技能
1.4 面向服务的全方位架构域
1.4.1 架构域的划分及关联
1.4.2 企业架构
1.4.3 业务架构
1.4.4 应用架构
1.5 面向服务的框架模式
1.5.1 参考方案架构模式
1.5.2 SOA设计模式
1.5.3 应用框架
1.5.4 行业框架
1.6 SOA的服务形式
1.6.1 SOA服务定义
1.6.2 服务分层调用
1.6.3 服务粒度定义
1.6.4 服务暴露形式
1.6.5 服务接口契约
第2章 面向服务企业应用整合的架构特色
2.1 面向服务的架构关注点
2.1.1 面向服务的应用整合框架
2.1.2 面向服务架构的关注点
2.1.3 SOA关注点的架构核心
2.2 界面交互
2.2.1 门户服务
2.2.2 界面应用服务
2.3 业务流程管理
2.3.1 流程类型
2.3.2 业务流与工作流
2.3.3 BPM的协同形式
2.3.4 流程的服务化
2.3.5 流程的事务性
2.3.6 流程的动态性
2.3.7 人员角色关联
2.4 信息集成
2.5 中介转换
2.5.1 报文标准
2.5.2 消息流模式
2.5.3 中介功能模块
2.5.4 中介转换
2.6 通用应用服务
2.6.1 标准接口调用架构
2.6.2 上层中间件——SOA的延伸形态
第3章 面向服务的全息架构视角
3.1 SOA的服务建模实现过程
3.2 架构视角与视图
3.2.1 架构视角
3.2.2 架构视图
3.3 SOA全息视角架构建模方法（SOA-HV）
3.3.1 架构视角模板
3.3.2 架构阶段及视图关联
3.3.3 架构视图的选择裁剪过程
3.4 SOA-HV——企业架构
3.4.1 差距分析视图
3.4.2 企业规划视图
3.4.3 组织结构视图
3.4.4 架构原则视图
3.4.5 应用框架视图
3.4.6 术语词汇视图
3.5 SOA-HV——业务架构
3.5.1 业务环境视图
3.5.2 业务模型视图
3.5.3 服务目录视图
3.5.4 业务分解视图
3.6 SOA-HV——架构需求
3.6.1 现有环境视图
3.6.2 企业痛点视图
3.6.3 功能需求视图
3.6.4 业务用例视图
3.6.5 服务质量视图
3.6.6 衡量指标视图
3.6.7 项目规划视图
3.7 SOA-HV——应用架构
3.7.1 典型场景视图
3.7.2 需求映射视图
3.7.3 架构总览视图
3.7.4 资产规范视图
3.7.5 架构抉择视图
3.7.6 服务组件视图
3.7.7 界面概要视图
3.7.8 门户服务视图
3.7.9 流程服务视图
3.7.10 信息服务视图
3.7.11 中介服务视图
3.8 SOA-HV——接口规约
3.8.1 门户规约视图
3.8.2 流程规约视图
3.8.3 中介规约视图
3.8.4 信息规约视图
3.8.5 重用规约视图
3.9 SOA-HV——架构实现
3.9.1 实现方式视图
3.9.2 服务部署视图
3.9.3 物理部署视图
3.9.4 服务管控视图
3.10 SOA-HV——架构校验
3.10.1 测试计划视图
3.10.2 变更管理视图
3.10.3 资源估算视图
3.10.4 项目报告视图
3.11 SOA-HV——架构视图走场
第4章 端到端企业应用整合架构案例
4.1 企业业务
4.2 项目需求
4.3 应用架构
4.3.1 典型场景
4.3.2 需求映射
4.3.3 系统总览
4.4 架构抉择
4.5 服务组件
4.6 界面概要
4.7 门户服务
4.8 流程服务
4.8.1 流程架构服务
4.8.2 流程应用服务
4.9 信息服务
4.10 中介服务
4.11 接口规约
4.12 服务实现
4.12.1 实现方式
4.12.2 服务部署
4.12.3 物理部署
4.12.4 服务管控
4.13 项目小结
第5章 面向服务架构与其他架构形式
5.1 传统应用架构
5.2 企业资源计划系统（ERP）架构
5.3 模型驱动架构
5.4 敏捷架构
5.5 云计算
附录A SOA建模方法及标记
A.1 SOA设计模型类型及建模方法
A.2 架构视图标记
参考文献
免责声明
致谢
结束语
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向服务的企业应用架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>好设计不简单Ⅰ：100个网站架构的实用要点
第1部分　概述
INTRODUCTION
1. 什么是信息架构
1 什么是信息架构　　14
2 为什么信息架构是必要的　　16
3 Web信息架构的诞生　　18
4 网站的构成要素　　20
5 Web信息架构设计的层级　　22
6 企业信息架构（EIA）　　24
7 EIA和企业品牌　　26
8 模式语言　　28
9 速度分层　　30
10 人性化设计　　32
11 信息终端的信息架构　　34
12 从IA到UXD　　36
2. 如何设计信息架构
13 信息架构设计的流程　　38
14 信息架构设计所必需的知识和能力　　40
15 分析阶段　　42
16 综合阶段　　44
17 信息架构设计由谁来完成　　46
18 进行项目讨论　　48
19 文档　　50
第2部分　分析
ANALYSIS
1. 用户分析
20 用户分析的意义和全貌　　54
21 形式多样的用户调查方法　　56
22 情境设计　　58
23 在线调查　　60
24 可用性测试　　62
25 用户模型　　64
26 用户角色分析法　　66
27 心智模型分析法　　68
28 情况与需求分析　　70
29 信息检索行为模型　　72
2. 内容分析
30 内容分析的意义和全貌　　74
31 内容分类和信息的发展　　76
32 五帽架法则　　78
33 内容的追加和更新　　80
34 现有内容的重复利用　　82
35 卡片分类法　　84
36 内容模型化　　86
37 内容清单（目录）　　88
3. 情境分析
38 情境分析的意义和全貌　　90
39 Web项目的全貌　　92
40 商业需求定义　　94
41 定义为用户提供的价值　　96
42 项目蓝图　　98
43 现状分析　　100
44 启发式评估　　102
45 日志分析　　104
46 标杆分析　　106
47 其他网站的结构分析　　108
48 创意简报　　110
49 计划执行的优先顺序　　112
第3部分　综合
SYNTHESIS
1. 用户体验设计
50 网站概念的定义　　116
51 用户体验设计的定义　　118
52 概念图　　120
53 用户体验流程　　122
54 脚本（故事板）　　124
55 访问网站的契机　　126
2. 网站结构设计
56 网站结构的定义　　128
57 网站结构的模式　　130
58 层级型分类结构　　132
59 分面分类型结构　　134
60 Web型（超链接型）结构　　136
61 辐射型结构　　138
62 列表与内容型结构　　140
63 直线（流程）型结构　　142
64 企业网站的结构　　144
65 服务型网站的结构　　146
66 网站宏观架构　　148
67 网站细节架构　　150
68 网站结构与导航　　152
69 灵活应用Site-it!　　154
70 视觉辞典　　156
71 网站结构的文档　　158
3. 导航设计
72 导航的定义　　160
73 3个导航区域　　162
74 全局区域　　164
75 内容区域　　166
76 本地区域　　168
77 7种导航　　170
78 层级型导航　　172
79 功能导航　　174
80 关联导航　　176
81 直接导航　　178
82 面包屑导航　　180
83 步骤导航　　182
84 动态导航　　184
85 新型导航　　186
4. 标签设计
86 标签的定义　　188
87 菜单标签　　190
88 导航标签　　192
89 标题与文章的统一　　194
90 标签定义的流程　　196
5. 画面设计
91 页面设计　　198
92 从Web生态系统来考量的页面设计　　200
93 用户体验流程和页面设计　　202
94 页面类型　　204
95 门户页面　　206
96 列表页面　　208
97 内容页面　　210
98 各个页面的信息结构　　212
99 用户接口设计　　214
100 线框图　　216
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>好设计不简单Ⅰ：100个网站架构的实用要点
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据架构和算法实现之路：电商系统的技术实战
目录
推荐序
前言
引子 1
第一篇　支持高效的运营
第1章　方案设计和技术选型：分类 5
1.1　分类的基本概念 6
1.2　分类任务的处理流程 7
1.3　算法：朴素贝叶斯和K最近邻 8
1.3.1　朴素贝叶斯 8
1.3.2　K最近邻 9
1.4　分类效果评估 10
1.5　相关软件：R和Mahout 12
1.5.1　R简介 12
1.5.2　Mahout简介 13
1.5.3　Hadoop简介 14
1.6　案例实践 17
1.6.1　实验环境设置 17
1.6.2　中文分词 18
1.6.3　使用R进行朴素贝叶斯分类 22
1.6.4　使用R进行K最近邻分类 37
1.6.5　单机环境使用Mahout运行朴素贝叶斯分类 39
1.6.6　多机环境使用Mahout运行朴素贝叶斯分类 47
1.7　更多的思考 58
第2章　方案设计和技术选型：聚类 60
2.1　聚类的基本概念 60
2.2　算法：K均值和层次型聚类 61
2.2.1　K均值聚类 61
2.2.2　层次型聚类 62
2.3　聚类的效果评估 64
2.4　案例实践 66
2.4.1　使用R进行K均值聚类 66
2.4.2　使用Mahout进行K均值聚类 69
第3章　方案设计和技术选型：因变量连续的回归分析 74
3.1　线性回归的基本概念 74
3.2　案例实践 76
3.2.1　实验环境设置 76
3.2.2　R中数据的标准化 78
3.2.3　使用R的线性回归分析 81
第二篇	为顾客发现喜欢的商品：
基础篇
第4章　方案设计和技术选型：搜索 94
4.1　搜索引擎的基本概念 94
4.1.1　相关性 95
4.1.2　及时性 97
4.2　搜索引擎的评估 100
4.3　为什么不是数据库 103
4.4　系统框架 104
4.4.1　离线预处理 104
4.4.2　在线查询 107
4.5　常见的搜索引擎实现 108
4.5.1　Lucene简介 108
4.5.2　Solr简介 113
4.5.3　Elasticsearch简介 120
4.6　案例实践 123
4.6.1　实验环境设置 123
4.6.2　基于Solr的实现 123
4.6.3　基于Elasticsearch的实现 154
4.6.4　统一的搜索API 175
第三篇	为顾客发现喜欢的商品：高级篇
第5章　方案设计和技术选型：NoSQL和搜索的整合 195
5.1　问题分析 195
5.2　HBase简介 196
5.3　结合HBase和搜索引擎 203
5.4　案例实践 204
5.4.1　实验环境设置 204
5.4.2　HBase的部署 205
5.4.3　HBase和搜索引擎的集成 211
第6章　方案设计和技术选型：查询分类和搜索的整合 219
6.1　问题分析 219
6.2　结合分类器和搜索引擎 219
6.3　案例实践 225
6.3.1　实验环境设置 225
6.3.2　构建查询分类器 226
6.3.3　定制化的搜索排序 229
6.3.4　整合查询分类和定制化排序 236
第7章　方案设计和技术选型：个性化搜索 245
7.1　问题分析 245
7.2　结合用户画像和搜索引擎 245
7.3　案例实践 249
7.3.1　用户画像的读取 250
7.3.2　个性化搜索引擎 253
7.3.3　结果对比 260
第8章　方案设计和技术选型：搜索分片 267
8.1　问题分析 267
8.2　利用搜索的分片机制 269
8.3　案例实践 271
8.3.1　Solr路由的实现 271
8.3.2　Elasticsearch路由的实现 278
第9章　方案设计和技术选型：搜索提示 283
9.1　问题分析 283
9.2　案例实践：基础方案 284
9.2.1　Solr搜索建议和拼写纠错的实现 284
9.2.2　Elasticsearch搜索建议和拼写纠错的实现 286
9.3　改进方案 291
9.4　案例实践：改进方案 294
第10章　方案设计和技术选型：推荐 303
10.1　推荐系统的基本概念 305
10.2　推荐的核心要素 306
10.2.1　系统角色 306
10.2.2　相似度 307
10.2.3　相似度传播框架 307
10.3　推荐系统的分类 307
10.4　混合模型 311
10.5　系统架构 312
10.6　Mahout中的推荐算法 313
10.7　电商常见的推荐系统方案 314
10.7.1　电商常见的推荐系统方案 314
10.7.2　相似度的计算 317
10.7.3　协同过滤 319
10.7.4　结果的查询 320
10.8　案例实践 321
10.8.1　基于内容特征的推荐 321
10.8.2　基于行为特征的推荐 341
第四篇　获取数据，跟踪效果
第11章　方案设计和技术选型：行为跟踪 369
11.1　基本概念 370
11.1.1　网站的核心框架 370
11.1.2　行为数据的类型 371
11.1.3　行为数据的模式 372
11.1.4　设计理念 374
11.2　使用谷歌分析 375
11.3　自行设计之Flume、HDFS和Hive的整合 378
11.3.1　数据的收集——Flume简介 378
11.3.2　数据的存储——Hadoop HDFS回顾 382
11.3.3　批量数据分析——Hive简介 383
11.3.4　Flume、HDFS和Hive的整合方案 386
11.4　自行设计之Flume、Kafka和Storm的整合 386
11.4.1　实时性数据分析之Kafka简介 386
11.4.2　实时性数据分析之Storm简介 388
11.4.3　Flume、Kafka和Storm的整合方案 390
11.5　案例实践 391
11.5.1　数据模式的设计 392
11.5.2　实验环境设置 392
11.5.3　谷歌分析实战 394
11.5.4　自主设计实战之Flume、HDFS和Hive的整合 401
11.5.5　自主设计实战之Flume、Kafka和Storm的整合 410
11.6　更多的思考 424
后记 425
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据架构和算法实现之路：电商系统的技术实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>智慧政府之路——大数据、云计算、物联网架构应用
第一篇  智慧政府之理论篇
第1章  关于智慧政府的概念	2
1.1  智慧政府概念的由来	2
1.1.1  从存在形态定义智慧城市	2
1.1.2  智慧及其诞生	2
1.1.3  智慧与理性的辩证关系	3
1.2  智慧政府出现的条件	5
1.2.1  关于“进化型组织”	5
1.2.2  “内在的创造力”是组织进化的要点	5
1.3  什么是智慧政府	6
1.3.1  从功能形态定义智慧城市	6
1.3.2  智慧政府的概念	6
1.4  虚拟政府与实体政府	7
1.4.1  虚拟政府起源	7
1.4.2  虚拟政府的形成	7
1.4.3  虚拟政府的发展	8
1.4.4  虚拟政府和实体政府的发展关系	8
第2章  智慧政府设计方法论分析	9
2.1  复杂系统的传统设计方法	9
2.1.1  整体论和还原论	9
2.1.2  复杂适应系统理论	10
2.1.3  耗散结构理论	10
2.1.4  共同进化理论	11
2.2  智慧政府设计方法论分析	11
2.2.1  FEA方法论对构建智慧政府的启示	11
2.2.2  IEM方法论对智慧政府建设的启示	14
2.2.3  协同进化论对智慧政府的建设方法论的启示	20
第3章  智慧政府的设计概要	23
3.1  把绩效作为智慧政府发展的引领性目标	23
3.2  梳理政府业务参考模型	24
3.3  建立智慧政府云服务平台	25
3.4  智慧政府的数据治理	25
3.4.1  数据治理是一种内部数据政体	25
3.4.2  数据治理是一组数据管理活动	26
3.4.3  数据治理成果是制度、标准、规范和数据价值	28
3.5  建立智慧政府应用程序总库	28
3.6  建立智慧政府协作平面	29
3.6.1  智慧政府是一个开放的复杂巨系统	29
3.6.2  智慧政府业务需求的差异化和多样性	29
3.6.3  设计智慧政府中的可进化的业务子系统	29
3.6.4  培育智慧政府中业务服务智能体	30
3.6.5  构建智慧政府的智能协作平台	31
3.6.6  发展智慧政府中的IOA	32
3.6.7  在智慧政府中人的要素始终
处于一个重要地位	32
第二篇  智慧政府之技术篇
第4章  智慧政府与云计算	34
4.1  智慧政府与云计算概述	34
4.1.1  云计算的基本定义	34
4.1.2  云计算与信息化十二五规划	34
4.1.3  云计算对智慧政府的影响和作用	35
4.1.4  基于云计算的智慧政府总体框架	35
4.2  智慧政府PaaS公共应用支撑平台	37
4.2.1  基于云计算的PaaS公共应用支撑平台	37
4.2.2  SOA与云计算	41
4.2.3  PaaS应用支撑平台设计思路	43
4.2.4  PaaS公共应用支撑平台与标准规范	48
4.2.5  PaaS公共应用支撑平台基础功能	53
4.2.6  总结	57
4.3  智慧政府SaaS应用
服务中心	57
4.3.1  SaaS与云计算	57
4.3.2  SaaS应用服务中心设计思路	60
4.3.3  SaaS应用服务中心与标准规范	63
4.3.4  SaaS应用服务中心功能	64
4.3.5  SaaS应用服务体系建设	66
4.3.6  SaaS建设模式分析	69
4.3.7  总结	70
第5章  智慧政府与大数据	71
5.1  智慧政府与大数据的关系	71
5.1.1  智慧政府建设是智慧城市的引领示范	71
5.1.2  智慧政府与大数据关系之辨析	74
5.1.3  大数据是智慧城市发展的新亮点	76
5.2  政府的大数据如何设计	78
5.2.1  政府将如何适应大数据时代	78
5.2.2  政府大数据设计的总体设计思想	80
5.2.3  政府大数据的主要技术体系	81
5.2.4  政府大数据设计的总体逻辑结构	82
5.2.5  政府大数据设计应用互联与共享交换体系	84
5.3  大数据服务	91
5.3.1  智慧是政务信息化的新阶段	91
5.3.2  多方面入手建设智慧政府	92
5.3.3  进一步提升智慧政府的大数据服务能力	93
5.3.4  智慧政府服务案例——政府宏观经济数据库建设	94
5.4  大数据的标准体系	102
5.4.1  大数据需要顶层设计	102
5.4.2  大数据需要标准规范支撑	103
第6章  智慧政府与物联网	106
6.1  物联网的总体架构和关键要素	106
6.1.1  物联网技术的广泛应用	106
6.1.2  信息资源的开发与利用	106
6.1.3  信息基础设施	107
6.1.4  物联网技术开发及其产业	107
6.1.5  物联网人才	107
6.1.6  推动物联网发展的政策、法规和标准环境	108
6.1.7  信息安全	108
6.2  物联网体系架构、各类物联网
综合应用与运行平台的布局	109
6.2.1  物联网的基本技术架构	109
6.2.2  基于关键技术的物联网体系架构	109
6.2.3  物联网综合应用与运行平台的布局	110
6.3  物联网所涉及的关键技术	111
6.3.1  实时信息采集技术	111
6.3.2  物联网传输技术	111
6.3.3  物联网海量数据融合、存储与挖掘技术	111
6.3.4  云模式智能化电子政务技术	112
6.3.5  信息安全技术	112
6.4  物联网与智慧政务	112
6.4.1  电子政务、电子社区与物联网发展的关联	112
6.4.2  从数字化、网络化到智能化	113
6.4.3  物联网的发展将促进电子政务和智慧城市迈向高级发展阶段	114
第7章  智慧政府与移动互联网	116
7.1  移动互联网简介	116
7.2  基于移动互联网的社会化软件为智慧政府提供平台	117
7.2.1  传统政务处理面临的问题	117
7.2.2  社交协作时代来临	117
7.2.3  企业社会化协作软件	118
7.2.4  企业2.0对政务2.0的启示	118
7.2.5  政务智能化服务	118
7.3  前景展望	119
第三篇  智慧政府之服务篇
第8章  政务服务	122
8.1  政务服务分类探究	122
8.1.1  政务服务分类参考	122
8.1.2  政务服务分类原则	122
8.1.3  面向对象分类法	123
8.1.4  政务服务定义及分类	123
8.2  政务服务分类表	124
8.2.1  政务服务分类参考	124
8.2.2  政务服务编码参考	128
8.3  政务服务单元描述	130
8.3.1  收文办理	130
8.3.2  文件签发	131
8.3.3  文件交换	132
8.3.4  信息全文检索	133
8.3.5  信息关联检索	134
8.3.6  督查督办	135
8.3.7  会议管理	135
8.3.8  车辆管理	136
8.3.9  办公用品管理	137
8.3.10  固定资产管理	138
8.3.11  请假管理	139
8.3.12  值班管理	139
8.3.13  考勤统计	140
8.3.14  即时消息	141
8.3.15  内部邮件	141
8.3.16  短信办公	142
8.3.17  公共服务统计分析	143
8.3.18  个人日程安排	144
8.3.19  待办消息服务	144
8.3.20  双向单点登录服务	145
第9章  企业服务	146
9.1  引言	146
9.1.1  面向企业的服务分类目标	146
9.1.2  企业服务的核心内容	146
9.2  企业服务分类	146
9.2.1  分类原理	146
9.2.2  分类原则	147
9.2.3  分类方式	147
9.2.4  分类特点	147
9.3  企业服务分类表	148
9.4  企业服务单元描述	152
9.4.1  G2B类服务	152
9.4.2  B2B类服务	163
第10章  公众服务	177
10.1  公众服务分类	177
10.2  公众服务分类表	178
10.3  公众服务单元描述	182
10.3.1  身份证办理	182
10.3.2  结婚证办理	183
10.3.3  计划生育服务证办理	184
10.3.4  独生子女证办理	185
10.3.5  居住证办理	186
10.3.6  残疾证办理	186
10.3.7  申请归侨、侨眷身份证明书办理	187
10.3.8  房产证转移办理	188
10.3.9  暂住老年人免费乘车证办理	189
10.3.10  医院信息查询	189
10.3.11  车辆违章查询	190
10.3.12  驾驶员积分查询	191
10.3.13  学校信息查询	191
10.3.14  继续教育认定	192
10.3.15  会计从业资格证注册及单位变更	193
10.3.16  职业介绍机构查询	194
10.3.17  失业人员就业登记	194
10.3.18  社保缴纳情况查询	195
10.3.19  水电气缴费	196
10.3.20  空气质量播报	196
10.3.21  公积金查询	197
10.3.22  经济适用住房保障申请	198
10.3.23  个人所得税计算服务	199
10.3.24  购物消费生活服务场所查询	199
10.3.25  酒店查询预订	200
第11章  大数据服务	201
11.1  大数据服务分类	201
11.1.1  工具类大数据服务	201
11.1.2  面向应用的大数据服务	203
11.2  大数据服务单元描述	204
11.2.1  工具类大数据服务	204
11.2.2  面向应用的大数据服务	207
第12章  智能协作平面服务	213
12.1  智慧政府应用智能协作平面的目标	213
12.2  智能协作平面表现形式	214
12.3  智能协作平面主体框架	214
12.3.1  基于云平台搭建	214
12.3.2  开放集成的服务	215
12.3.3  面向Agent设计	216
12.3.4  软件移动互联网化	217
12.3.5  流行的前端设计	217
12.4  智能协作平面服务单元描述	217
12.4.1  移动办公服务	217
12.4.2  微门户服务	218
12.4.3  社交协作服务	219
12.4.4  知识库服务	220
12.5  智能协作平面的特点及进化	221
12.6  协作平面打造智慧政府案例——深圳市罗湖区分享协作平台	221
第四篇  智慧政府之运营篇
第13章  智慧政府的运营体制	224
13.1  智慧政府运营模式	224
13.2  借鉴国内外政府运营经验分析	225
13.2.1  美国联邦政府Apps.gov网站	226
13.2.2  中国政府应用程序仓库平台建设	227
13.3  形成多方参与的产业链运营格局	228
13.3.1  政府机构职能的进化与转变	229
13.3.2  标准规范的开放与贯彻	230
13.3.3  各类政府应用的市场化定位与检验	230
13.3.4  全民参与、全面智慧	231
13.4  形成政府单位可运营的程序仓库	231
13.5  智慧政府运营体制的价值与作用	232
13.5.1  将政府形态从生产范式向服务范式转变	232
13.5.2  提供安全可信的政府一站式应用服务共享	232
13.5.3  通过应用创新带动政府服务模式的创新	232
13.5.4  让民众生活更便捷、更幸福	233
第14章  智慧政府的运营服务	234
14.1  智慧政府服务框架	234
14.2  引入互联网运营模式	236
14.2.1  形成传统运营与互联网运营的组合模式	236
14.2.2  解决双边市场定价和集中化两个问题	237
14.2.3  拓展智慧政府的互联网运营策略	237
14.3  智慧政府运营内容	238
14.3.1  智慧政府运营服务保障体系	238
14.3.2  智慧政府运维服务管理框架	239
14.3.3  智慧政府信息化监控管理体系	240
14.4  智慧政府运营重点	242
14.4.1  建立独立的智慧政府协调机构	242
14.4.2  建立智慧政府标准化体系	242
14.4.3  健全智慧政府安全保障机制	242
14.4.4  推行市场化运作机制	242
14.4.5  建立公众导向的服务评价机制	243
第15章  智慧政府的风险控制	244
15.1  智慧政府项目常见特点	244
15.2  智慧政府项目风险管理分析	245
15.2.1  智慧政府项目阶段划分	245
15.2.2  智慧政府项目风险管理内容	245
15.2.3  智慧政府项目管理风险分析方法	246
15.3  智慧政府项目风险管理的应对实践	249
15.4  构建风险因素指标体系	250
15.5  风险管理在智慧政务项目中的思考与探索	250
第五篇  智慧政府之实践篇
第16章  深圳市罗湖区协同办公平台	254
16.1  发展历程	254
16.2  应用现状	254
16.3  建设情况	255
16.4  系统特点	255
16.5  未来发展思路	256
第17章  北京市海淀区办公云平台	257
17.1  北京市海淀区办公自动化系统建设历程	257
17.2  全区办公云平台应用情况	257
17.3  全区办公云平台公共服务建设情况	259
17.3.1  办公云平台5大服务中心	259
17.3.2  办公云平台公共服务总库	259
17.3.3  办公云平台基础支撑环境	259
17.3.4  54部门虚拟化部署OA群	260
17.3.5  智慧海淀办公云平台标准规范	260
17.4  海淀办公云平台未来发展思路	261
17.4.1  进一步深入推进全区协同办公统筹规划建设模式	261
17.4.2  由技术创新带动服务水平的提升	261
17.4.3  加强协同办公标准规范的制定推广	261
17.5  海淀办公云平台未来
发展目标	261
17.5.1  实现服务化建设目标	262
17.5.2  实现开放性建设目标	262
17.5.3  实现即时性建设目标	262
第18章  深圳市福田区行政审批系统	263
18.1  建设历史	263
18.2  建设现状	263
18.3  建设思路	264
18.4  系统特点	265
18.5  未来展望	265
第19章  太仓市企业公共服务平台	267
19.1  平台建设历程	267
19.2  平台建设现状	267
19.3  平台建设思路	269
19.4  平台持续运营思路	269
19.4.1  平台建设与运营面临的问题	269
19.4.2  如何做好本地区的企业服务	270
19.5  未来展望	272
19.5.1  把控主线、开拓创新	272
19.5.2  转型升级、双管齐下	272
第20章  北京市西城区数据服务平台	273
20.1  系统建设历程	273
20.2  数据建设情况	273
20.2.1  综合监测数据	273
20.2.2  区域经济与社会发展基础数据	274
20.3  系统建设成果	274
20.4  未来展望	276
20.4.1  全面整合全区各类数据	276
20.4.2  建立领导服务支持平台	276
20.4.3  建立移动分析展示系统	276
20.4.4  建立与新西城发展相适应的监测平台	276
20.4.5  建立数据推演模型分析平台	277
20.4.6  统计数据与规划委GIS 数据深度整合	277
20.4.7  建立统计数据考评机制，提高数据的质量及利用率	277
20.4.8  云计算虚拟化采集平台	277
20.4.9  物联网在数据分析中的应用	277
20.4.10  建立多终端信息的交互协作平台	277
20.4.11  构建BPM驱动SOA架构下的统计信息化新格局	278
第六篇  智慧政府之产业篇
第21章  我国智慧政府系统建设模式的发展	280
21.1  主流的智慧政府系统建设模式	280
21.2  符合我国特色的智慧政府系统建设模式	280
21.3  地方政府的智慧政府系统建设模式	281
21.4  基于产业联盟的智慧政府建设模式	281
第22章  产业联盟模式的特点和优势	282
22.1  引入标准规范及商业规则	282
22.1.1  引入统一开放技术标准	282
22.1.2  引入透明商业规则，提供软件产品交易服务	282
22.2  联盟机制与智慧政府建设及产业	283
22.2.1  联盟机制解决分散建设带来的问题	283
22.2.2  联盟机制促进产业的形成和发展	284
22.2.3  联盟机制实现产业及产业链的落地	285
第23章  产业联盟模式在智慧政府建设中的实践	287
23.1  区域智慧政府引入软件应用商店	287
23.2  区域智慧政府建设实例	287
第七篇  附    录
附录A  国家智慧城市(区、镇)试点指标体系(试行) 	290
附录B  基于云计算的电子政务公共平台顶层设计指南	294
附录C  关于重视和加快在我国软件产业领域发展开放标准的建议	299
附录D  工业和信息化部关于重视和加快在我国软件产业领域发展开放标准情况的报告	303
附录E  信息技术面向服务的体系结构(SOA)应用的总体技术要求	305
附录F  深圳市电子政务应用服务规范	311
附录G  中关村软件和信息服务产业创新联盟简介	454
后记		456
参考文献	458
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>智慧政府之路——大数据、云计算、物联网架构应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构师修炼之道
第一部分 软件架构导论
第1章 成为软件架构师 3
1.1  软件架构师要做什么 4
1.2  什么是软件架构 7
1.3  成为团队的架构师 11
1.4  开发出色的软件 13
1.5  案例分析：Lionheart项目 14
1.6  预告 14
第2章 设计思维基础 15
2.1  设计思维的四条原则 15
2.2  运用思维模式 18
2.3  思考、动手、检查 21
2.4  预告 24
第二部分 架构设计原理
第3章 制定设计策略 27
3.1  找到够用的设计 27
3.2  决定前期做多少架构设计 29
3.3  用风险做向导 32
3.4  制订设计计划 36
3.5  Lionheart项目：目前的进展 37
3.6  预告 38

第4章 换位思考 39
4.1  找合适的人交谈 39
4.2  创建利益相关方关系图 40
4.3  了解业务目标 43
4.4  Lionheart项目：目前的进展 46
4.5  预告 47
第5章 挖掘关键架构需求 49
5.1  用约束限制设计选择 50
5.2  定义质量属性 51
5.3  对功能需求分类 56
5.4  找出其他影响架构的因素 57
5.5  挖掘关键架构需求 59
5.6  创建ASR工作簿 60
5.7  Lionheart项目：目前的进展 62
5.8  预告 62
第6章 主动选择架构 63
6.1  发散探索，聚合决策 63
6.2  接受约束 66
6.3  提升质量属性 67
6.4  为架构元素分配功能 72
6.5  设计，应变而生 74
6.6  Lionheart项目：目前的进展 75
6.7  预告 76
第7章 架构模式 77
7.1  什么是架构模式 77
7.2  分层模式 78
7.3  端口适配器模式 80
7.4  管道过滤器模式 81
7.5  面向服务架构模式 83
7.6  发布订阅模式 85
7.7  共享数据模式 86
7.8  多层模式 88
7.9  能力中心模式 89
7.10  开源贡献模式 91
7.11  大泥球模式 92
7.12  发现新架构模式 92
7.13  Lionheart项目：目前的进展 93
7.14  预告 93
第8章 建立模型，化繁为简 95
8.1  推演架构 96
8.2  设计元模型 97
8.3  让模型融入代码 104
8.4  Lionheart项目：目前的进展 108
8.5  预告 108
第9章 召开架构设计研讨会 109
9.1  筹划架构设计研讨会 110
9.2  挑选设计方法 115
9.3  挑选参与者 116
9.4  会议管理 118
9.5  与远程团队协作 121
9.6  Lionheart项目：目前的进展 122
9.7  预告 122
第10章 展示设计决策 123
10.1  用不同的视图展现架构 124
10.2  绘制出色的图表 132
10.3  Lionheart项目：目前的进展 138
10.4  预告 139
第11章 描述架构 139
11.1  讲述完整的故事 140
11.2  因地制宜，选择描述方法 141
11.3  尊重受众 145
11.4  围绕利益相关方关注点组织视图 148
11.5  阐述决策的逻辑依据 151
11.6  Lionheart项目：目前的进展 152
11.7  预告 153
第12章 架构评估 153
12.1  评估得真知 154
12.2  检验设计 154
12.3  举办评估研讨会 160
12.4  尽早评估，反复评估，持续评估 164
12.5  Lionheart 项目：目前的进展 168
12.6  预告 168
第13章 鼓励团队参与架构设计 169
13.1  提倡架构师思维 170
13.2  传授技能，辅助决策 171
13.3  为团队创造实践机会 172
13.4  设计下放 173
13.5  共同设计架构 177
13.6  Lionheart项目：大结局 178
13.7  预告 179
第三部分 架构师的工具箱
第14章 理解问题的常用方法 183
14.1  方法1：二选一 184
14.2  方法2：移情图 186
14.3  方法3：GQM研讨会 189
14.4  方法4：利益相关方访谈 191
14.5  方法5：假设清单 194
14.6  方法6：质量属性网络 195
14.7  方法7：微型质量属性研讨会 197
14.8  方法8：观点填空 202
14.9  方法9：响应度量稻草人 205
14.10  方法10：利益相关方关系图 207
第15章 探索解决方案的常用方法 209
15.1  方法11：架构拟人化 210
15.2  方法12：架构演变记录 212
15.3  方法13：组件-功能-协作者卡片 215
15.4  方法14：概念图 219
15.5  方法15：分而治之 221
15.6  方法16：事件风暴 225
15.7  方法17：团队海报 228
15.8  方法18：循环设计 230
15.9  方法19：白板涂鸦 233
第16章 展示设计的常用方法 235
16.1  方法20：架构决策记录 236
16.2  方法21：架构主旨 239
16.3  方法22：背景图 241
16.4  方法23：精选阅读列表 242
16.5  方法24：启动计划书 243
16.6  方法25：模块化分解图 246
16.7  方法26：未采纳的决策 248
16.8  方法27：制作原型，用于学习或决策 250
16.9  方法28：时序图 251
16.10  方法29：系统隐喻 254
第17章 评估设计方案的常用方法 257
17.1  方法30：架构简报 258
17.2  方法31：代码评审 260
17.3  方法32：决策矩阵 263
17.4  方法33：观察系统表现 265
17.5  方法34：问题-评论-关注事项 267
17.6  方法35：风险风暴 269
17.7  方法36：合理性检查 271
17.8  方法37：场景排查 273
17.9  方法38：画草图做比较 277
附录  贡献者简介 279
索引 281
致谢 296
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构师修炼之道
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高性能网站建设进阶指南
致谢	I
前言	III
第1章：理解Ajax性能	1
1.1 权衡	1
1.2 优化原则	2
1.3 Ajax	4
1.4 浏览器	4
1.5 哇！	5
1.6 JavaScript	6
1.7 总结	6
第2章：创建快速响应的Web应用	7
2.1 怎样才算足够快	9
2.2 测量延迟时间	10
2.2.1 当延迟变得很严重时	12
2.3 线程处理	12
2.4 确保响应速度	13
2.4.1 Web Workers	14
2.4.2 Gears	14
2.4.3 定时器	16
2.4.4 内存使用对响应时间的影响	17
2.4.5 虚拟内存	18
2.4.6 内存问题的疑难解答	18
2.5 总结	19
第3章：拆分初始化负载	21
3.1 全部加载	21
3.2 通过拆分来节省下载量	22
3.3 寻找拆分	23
3.4 未定义标识符和竞争状态	24
3.5 个案研究：Google日历	25
第4章：无阻塞加载脚本	27
4.1 脚本阻塞并行下载	27
4.2 让脚本运行得更好	29
4.2.1 XHR Eval	29
4.2.2 XHR注入	31
4.2.3 Script in Iframe	31
4.2.4 Script DOM Element	32
4.2.5 Script Defer	32
4.2.6 document.write Script Tag	33
4.3 浏览器忙指示器	33
4.4 确保（或避免）按顺序执行	35
4.5 汇总结果	36
4.6 最佳方案	38
第5章：整合异步脚本	41
5.1 代码示例：menu.js	42
5.2 竞争状态	44
5.3 异步加载脚本时保持执行顺序	45
5.3.1 技术1：硬编码回调（Hardcoded Callback）	46
5.3.2 技术2：Window Onload	47
5.3.3 技术3：定时器（Timer）	48
5.3.4 技术4：Script Onload	49
5.3.5 技术5：降级使用script标签（Degrading Script Tags）	50
5.4 多个外部脚本	52
5.4.1 Managed XHR	52
5.4.2 DOM Element和Doc Write	56
5.5 综合解决方案	59
5.5.1 单个脚本	59
5.5.2 多个脚本	60
5.6 现实互联网中的异步加载	63
5.6.1 Google分析和Dojo	63
5.6.2 YUI Loader	65
第6章：布置行内脚本	69
6.1 行内脚本阻塞并行下载	69
6.1.1 把行内脚本移至底部	70
6.1.2 异步启动执行脚本	71
6.1.3 使用script的defer属性	73
6.2 保持CSS和JavaScript的执行顺序	73
6.3 风险：把行内脚本放置在样式表之后	74
6.3.1 大部分下载都不阻塞行内脚本	74
6.3.2 样式表阻塞行内脚本	75
6.3.3 问题确曾发生	77
第7章：编写高效的JavaScript	79
7.1 管理作用域	79
7.1.1 使用局部变量	81
7.1.2 增长作用域链	83
7.2 高效的数据存取	85
7.3 流控制	88
7.3.1 快速条件判断	89
7.3.2 快速循环	93
7.4 字符串优化	99
7.4.1 字符串连接	99
7.4.2 裁剪字符串	100
7.5 避免运行时间过长的脚本	102
7.5.1 使用定时器挂起	103
7.5.2 用于挂起的定时器模式	105
7.6 总结	107
第8章：可伸缩的Comet	109
8.1 Comet工作原理	109
8.2 传输技术	111
8.2.1 轮询	111
8.2.2 长轮询	112
8.2.3 永久帧	113
8.2.4 XHR流	115
8.2.5 传输方式的前景	116
8.3 跨域	116
8.4 在应用程序上的执行效果	118
8.4.1 连接管理	118
8.4.2 测量性能	119
8.4.3 协议	119
8.5 总结	120
第9章：超越Gzip压缩	121
9.1 这为什么很重要	121
9.2 问题的根源	123
9.2.1 快速回顾	123
9.2.2 罪魁祸首	123
9.2.3 流行的乌龟窃听者实例	124
9.3 如何帮助这些用户	124
9.3.1 设计目标：最小化未压缩文件的尺寸	125
9.3.2 引导用户	129
9.3.3 对Gzip的支持进行直接探测	130
第10章：图像优化	133
10.1 两步实现简单图像优化	134
10.2 图像格式	135
10.2.1 背景	135
10.2.2 不同图像格式的特性	137
10.2.3 PNG的更多资料	139
10.3 自动无损图像优化	141
10.3.1 优化PNG格式的图像	142
10.3.2 剥离JPEG的元数据	143
10.3.3 将GIF转换成PNG	144
10.3.4 优化GIF动画	144
10.3.5 Smush.it	145
10.3.6 使用渐进JPEG格式来存储大图像	145
10.4 Alpha透明：避免使用AlphaImageLoader	146
10.4.1 Alpha透明度的效果	147
10.4.2 AlphaImageLoader	149
10.4.3 AlphaImageLoader的问题	150
10.4.4 渐进增强的PNG8 Alpha透明	151
10.5 优化Sprite	153
10.5.1 超级Sprite VS.模块化Sprite	154
10.5.2 高度优化的CSS Sprite	155
10.6 其他图像优化方法	155
10.6.1 避免对图像进行缩放	155
10.6.2 优化生成的图像	156
10.6.3 Favicons	157
10.6.4 Apple触摸图标	158
10.7 总结	159
第11章：划分主域	161
11.1 关键路径	161
11.2 谁在划分主域	163
11.3 降级到HTTP/1.0	165
11.4 域划分的扩展话题	168
11.4.1 IP地址和主机名	168
11.4.2 多少个域	168
11.4.3 如何划分资源	168
11.4.4 新型浏览器	169
第12章：尽早刷新文档的输出	171
12.1 刷新文档头部的输出	171
12.2 输出缓冲	173
12.3 块编码	175
12.4 刷新输出和Gzip压缩	176
12.5 其他障碍	177
12.6 刷新输出时的域阻塞	178
12.7 浏览器：最后的障碍	178
12.8 不借助PHP进行刷新输出	179
12.9 刷新输出问题清单	180
第13章：少用iframe	181
13.1 开销最高的DOM元素	181
13.2 iframe阻塞onload事件	182
13.3 使用iframe并行下载	184
13.3.1 脚本位于iframe之前	184
13.3.2 样式表位于iframe之前	185
13.3.3 样式表位于iframe之后	186
13.4 每个主机名的连接	187
13.4.1 iframe中的连接共享	187
13.4.2 跨标签页和窗口的连接共享	188
13.5 总结使用iframe的开销	190
第14章：简化CSS选择符	191
14.1 选择符的类型	191
14.1.1 ID选择符	192
14.1.2 类选择符	193
14.1.3 类型选择符	193
14.1.4 相邻兄弟选择符	193
14.1.5 子选择符	193
14.1.6 后代选择符	193
14.1.7 通配选择符	194
14.1.8 属性选择符	194
14.1.9 伪类和伪元素	194
14.2 高效CSS选择符的关键	194
14.2.1 最右边优先	195
14.2.2 编写高效的CSS选择符	195
14.3 CSS选择符性能	197
14.3.1 复杂的选择符影响性能（有时）	197
14.3.2 应避免使用的CSS选择符	200
14.3.3 回流时间	201
14.4 在现实中测量CSS选择符	202
附录：性能工具	205
索引	221
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高性能网站建设进阶指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>权力战争
前言 揭露中国企业发展核心瓶颈与障碍
第一章 换汤还是换药——从一家企业的N次走马换将说起
第一节 从一路凯歌迈向四面楚歌
第二节 德国海归的“外企型”职业经理人
第三节 炮兵军官出身的“国企型”职业经理人
第四节 印尼归国华侨——“民企型”职业经理人
第五节 职场大忽悠——“关系型”职业经理人
第六节“鬼子老总”——自日本的“外籍型”职业经理人
第七节 中国台湾海军退役上尉——“港台型”职业经理人
第八节 复辟倒退之路——企业再陷黄色危机旋流
第二章 中国职业经理人独有特点——非理性频繁更换
第一节 招聘！招聘！疯狂的总经理招聘！
第二节 聘而不用、聘而乱用——职业经理人的灰色境遇
第三节 更换！更换！永远不停地更换！
第四节 非理性的无差异更换——毫无意义的盲目行为
第五节 职业经理人与老板的权力博弈游戏
第六节 巨大的伤痛——企业总经理频繁更换之殇
第三章 总经理频繁更换深层次原因透视
第一节 黑色生存环境——毫无尊严的“总经理”
第二节 违反科学理性原则的二元权力结构
第三节 怎样对付“总经理”——老板隐秘的内心世界
第四节 两种对立的思维方式———位离职总经理给老板的一卦信
第五节 一开始就埋下的斗争因子——两种对“总经理”的定位差距
第六节 两种人文价值观念——难以调和的冲突
第四章 企业兴亡的永久支——现代型“高层淑力架构”
第一节 中国企业的伟大首创——美的集团现代型高层权力架构
第二节 超越英国——探秘十九世纪末美国企业飞速发展
第三节 永远无法摆脱的黑色病理——家族企业的痼疾
第四节 死亡威胁——中国老板身旁的凶险潜影
第五节 当一次刘备——职业经理人使用哲学
第六节 走何享健之路——让您的企业九十年后依然存在
第五章 创现代企业高层权力架构之具体举措
第一节 选择企业高层权力架构
第二节 选定职业经理人——迈向成功的第一步
第三节 唯一权力中心——不可违反的原则
第四节 去家族化之具体手段与步骤
第五节 不再参与日常事务——重量级股东的基本原则
第六节 建立企业四会运作机制
第七节 确立基本组织原则——不可或缺的基础
第八节 现代型职业经理人考核方式
第六章 现代型“高层权力架构”运作成功案例
第一节 中日合资A公司现代型“高层权力架构”之神奇成功
第二节 凤凰涅槃——安康公司现代型“高层权力架构”之成功
结语 让企业存活九十年——确立“何享健思维方式”
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>权力战争
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>游戏架构设计与策划基础
第1章 游戏策划概述
1.1 什么是游戏策划
1.2 游戏策划的任务
1.3 游戏策划需具备的特质
1.3.1 喜欢玩游戏
1.3.2 丰富的想象力
1.3.3 勇于创新
1.3.4 涉猎广泛
1.3.5 技术意识
1.3.6 审美能力
1.3.7 喜欢思考
1.4 游戏策划职位
1.4.1 主策划
1.4.2 系统策划
1.4.3 执行策划
1.4.4 文案策划
1.4.5 数值策划
1.4.6 场景策划
1.5 游戏策划与团队
1.5.1 制作人
1.5.2 游戏软件开发工程师
1.5.3 游戏美术设计师
1.5.4 质量保证工程师
1.5.5 运营团队
1.6 本章小结
1.7 本章习题
第2章 玩家心理分析与游戏性
2.1 游戏设计的目的
2.2 玩家的分类
2.2.1 核心玩家
2.2.2 普通玩家
2.3 玩家的乐趣所在
2.3.1 挑战与自我证明
2.3.2 竞争与炫耀
2.3.3 合作与交流
2.3.4 嬉戏
2.4 玩家的期望
2.4.1 对操作的期望
2.4.2 对目标的期望
2.4.3 对界面的期望
2.4.4 对感觉的期望
2.4.5 对规则的期望
2.5 玩家需求调查
2.6 游戏性
2.6.1 游戏性的定义
2.6.2 爽快感
2.6.3 成就感
2.6.4 融入感
2.6.5 游戏性的融合
2.7 外挂VS游戏性
2.8 本章小结
2.9 本章习题
第3章 游戏概念及原型设计
3.1 创意的来源
3.1.1 大胆设想
3.1.2 利用现有的娱乐资源
3.1.3 利用现有的游戏体系
3.1.4 收集创意
3.2 加工创意
3.2.1 合成
3.2.2 共鸣
3.3 游戏概念设计文档
3.4 游戏原型设计
3.4.1 实体原型
3.4.2 软件原型
3.4.3 初学者与游戏原型
3.5 本章小结
3.6 本章习题
第4章 游戏背景设计
4.1 游戏世界观
4.1.1 世界架构
4.1.2 人文地理
4.1.3 宗教信仰
4.1.4 政治结构
4.1.5 经济及文化
4.1.6 游戏世界观案例
4.2 故事背景
4.2.1 故事背景的设计方法
4.2.2 故事背景与游戏情节的关系
4.3 统一的游戏背景
4.4 本章小结
4.5 本章习题
第5章 游戏地图与场景设计
5.1 游戏地图与场景设计常用名词
5.2 设计准备工作
5.3 世界地图的制作
5.4 区域地图设计
5.5 场景设计文档编写
5.5.1 编写方法
5.5.2 编写内容
5.6 本章小结
第6章 游戏元素设计
6.1 游戏元素的定义
6.1.1 游戏元素的编写
6.1.2 游戏元素的设计要素
6.1.3 游戏元素属性的设计原则
6.2 主角的含义
6.3 主角的分类
6.4 主角设计内容
6.4.1 故事背景
6.4.2 特色说明
6.4.3 形象设计
6.4.4 动作设计
6.4.5 属性设计
6.5 NPC设定
6.5.1 NPC的作用
6.5.2 NPC的设计内容
6.6 怪物设定
6.6.1 怪物分布图
6.6.2 怪物的设计内容
6.6.3 怪物刷新规则
6.7 AI概述
6.7.1 AI定义
6.7.2 游戏中的人工智能
6.7.3 人工智能定义的不同标准
6.7.4 人工智能在游戏业的现状
6.7.5 游戏人工智能的设计目的
6.8 AI设计
6.8.1 有限状态设计
6.8.2 模糊状态设计
6.8.3 可扩展性AI
6.8.4 AI的编写
6.9 道具设计
6.9.1 道具的分类
6.9.2 道具的获得方式
6.10 道具的设计方法
6.10.1 道具编写分类
6.10.2 设计内容
6.11 道具编辑器
6.12 道具平衡性的考虑
6.13 本章小结
6.14 本章习题
第7章 任务与关卡设计
7.1 游戏任务情节结构
7.1.1 直线型结构
7.1.2 多分支结构
7.1.3 无结局结构
7.2 任务情节的设计技巧
7.2.1 讲故事的人
7.2.2 障碍
7.2.3 预示
7.2.4 个性化
7.2.5 共鸣
7.2.6 戏剧性弧线
7.3 关卡的定义
7.4 关卡设计要素
7.4.1 目标
7.4.2 情节
7.4.3 地形
7.4.4 对手与NPC
7.4.5 物品
7.5 关卡制作过程
7.5.1 确定目标
7.5.2 概念设计
7.5.3 制作
7.5.4 测试
7.6 典型竞赛关卡结构分析
7.6.1 竞技场型
7.6.2 循环型
7.6.3 直线型
7.7 关卡设计的原则
7.7.1 明确目标导向
7.7.2 注意关卡步调
7.7.3 逐步展开内容
7.7.4 控制任务难度
7.7.5 善用任务提示
7.7.6 满足玩家的期待
7.7.7 时间就是质量
7.8 本章小结
7.9 本章习题
第8章 游戏规则设计
8.1 规则体系
8.1.1 世界相关规则
8.1.2 角色相关规则
8.1.3 道具相关规则
8.1.4 战斗相关规则
8.1.5 经济相关规则
8.2 规则设计原则
8.2.1 一致性
8.2.2 简单性
8.2.3 平衡性
8.2.4 避免烦琐
8.3 本章小结
8.4 本章习题
第9章 界面与用户控制
9.1 概述
9.2 视角
9.2.1 平面横向视角
9.2.2 俯视角
9.2.3 斜视角
9.2.4 第一人称视角
9.2.5 第三人称视角
9.2.6 全景视角
9.2.7 视角的选择
9.3 界面设计
9.3.1 界面设计的目标
9.3.2 界面设计的原则
9.3.3 主菜单设计
9.3.4 HUD设计
9.3.5 界面设计文档
9.4 控制
9.5 本章小结
9.6 本章习题
第10章 游戏编辑工具
10.1 游戏编辑工具类型
10.1.1 地形编辑器
10.1.2 触发事件编辑器
10.1.3 声音编辑器
10.1.4 物体编辑器
10.1.5 A1编辑器
10.1.6 战役编辑器
10.1.7 物体管理器
10.1.8 输入管理器
10.2 编辑器基础操作
10.2.1 地图属性
10.2.2 玩家属性
10.2.3 常用菜单
10.3 创建地形及装饰物
10.3.1 创建斜坡
10.3.2 物体缩放
10.3.3 瀑布制作
10.4 触发器
10.4.1 概述
10.4.2 实例：选择英雄
10.5 本章小结
10.6 本章习题
第11章 游戏设计文档
11.1 设计文档的主要功能
11.2 常用设计文档的类型
11.2.1 概念设计文档
11.2.2 游戏设计文档
11.2.3 软件需求说明书
11.2.4 测试计划与测试分析报告
11.3 游戏设计文档模板
11.3.1 标题页
11.3.2 目录
11.3.3 立项说明
11.3.4 正文
11.4 游戏设计文档的格式和风格
11.5 本章小结
11.6 本章习题
附录A 动作休闲网络游戏策划实例
附录B 棋牌类网络游戏策划大纲
附录C 游戏策划案——《炎龙战记》系统策划案
附录D 策划设计文档
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>游戏架构设计与策划基础
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>流式架构：Kafka与MapR Streams数据流处理
第1 章 为什么使用流1
飞机、火车和汽车：车联网和物联网 3
流数据：这才是现实世界 6
什么时候需要流 8
不止是实时：流架构的更多优势11
流架构的最佳实践13
医疗数据流案例 14
流数据：架构设计的核心17
第2 章 流式架构 19
狭义视角：实时应用 20
通用流式架构的关键问题21
消息传递技术的重要性 24
实时分析工具 28
Apache Storm 30
Apache Spark Streaming 31
Apache Flink 32
Apache Apex 33
流分析功能比较33
小结 36
第3 章 流架构：微服务的理想平台 37
为什么需要微服务 38
微服务需要哪些支撑 41
关于微服务的更多详情42
设计流架构：以在线视频服务为例 45
新设计：支持消息传递的基础设施47
通用微架构的重要性 49
命名问题50
为什么使用分布式文件和NoSQL 数据库52
视频服务的新设计 52
小结：综合平台视角 54
第4 章 使用Kafka 进行流传输 57
Kafka 的动机 57
Kafka 的创新 58
Kafka 的基本概念60
排序61
持久化 62
Kafka API 62
KafkaProducer API63
KafkaConsumer API 66
遗留API70
Kafka 实用程序 71
负载均衡 71
镜像 72
Kafka 的陷阱 73
产品环境下的Kafka 73
主题和分区的数目有限 74
手动均衡分区负载 75
没有固有的序列化机制 76
镜像的不足77
小结 78
第5 章 MapR Streams79
MapR Streams 的创新79
MapR 流系统的历史和情境82
MapR Streams 的工作原理 84
配置MapR Streams 86
地理分布式复制 89
MapR Streams 的陷阱 91
第6 章 基于流数据的欺诈检测 93
刷卡速度 94
快速响应决策：“这是欺诈吗”95
多用途流数据98
欺诈检测器的向上扩展 99
小结 101
第7 章 地理分布式数据流 103
利益相关者 104
设计目标 106
设计选择 106
我们的设计 108
数据 108
控制谁能访问流数据109
基于流的地理分布式复制的优势 110
第8 章 总结113
流式架构的优势 115
过渡到流架构116
小结 119
附录A 附加资源121
作者简介125
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>流式架构：Kafka与MapR Streams数据流处理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式Java应用
前言
第1章 分布式Java应用
1.1 基于消息方式实现系统间的通信
1.1.1 基于Java自身技术实现消息方式的系统间通信
1.1.2 基于开源框架实现消息方式的系统间通信
1.2 基于远程调用方式实现系统间的通信
1.2.1 基于Java自身技术实现远程调用方式的系统间通信
1.2.2 基于开源框架实现远程调用方式的系统间通信
第2章 大型分布式Java应用与SOA
2.1 基于SCA实现SOA平台
2.2 基于ESB实现SOA平台
2.3 基于Tuscany实现SOA平台
2.4 基于Mule实现SOA平台
第3章 深入理解JVM
3.1 Java代码的执行机制
3.1.1 Java源码编译机制
3.1.2 类加载机制
3.1.3 类执行机制
3.2 JVM内存管理
3.2.1 内存空间
3.2.2 内存分配
3.2.3 内存回收
3.2.4 JVM内存状况查看方法和分析工具
3.3 JVM线程资源同步及交互机制
3.3.1 线程资源同步机制
3.3.2 线程交互机制
3.3.3 线程状态及分析
第4章 分布式应用与Sun JDK类库
4.1 集合包
4.1.1 ArrayList
4.1.2 LinkedList
4.1.3 Vector
4.1.4 Stack
4.1.5 HashSet
4.1.6 TreeSet
4.1.7 HashMap
4.1.8 TreeMap
4.1.9 性能测试
4.1.10 小结
4.2 并发包（java.util.concurrent）
4.2.1 ConcurrentHashMap
4.2.2 CopyOnWriteArrayList
4.2.3 CopyOnWriteArraySet
4.2.4 ArrayBlockingQueue
4.2.5 AtomicInteger
4.2.6 ThreadPoolExecutor
4.2.7 Executors
4.2.8 FutureTask
4.2.9 Semaphore
4.2.10 CountDownLatch
4.2.11 CyclicBarrier
4.2.12 ReentrantLock
4.2.13 Condition
4.2.14 ReentrantReadWriteLock
4.3 序列化/反序列化
4.3.1 序列化
4.3.2 反序列化
第5章 性能调优
5.1 寻找性能瓶颈
5.1.1 CPU消耗分析
5.1.2 文件IO消耗分析
5.1.3 网络IO消耗分析
5.1.4 内存消耗分析
5.1.5 程序执行慢原因分析
5.2 调优
5.2.1 JVM调优
5.2.2 程序调优
5.2.3 对于资源消耗不多，但程序执行慢的情况
第6章 构建高可用的系统
6.1 避免系统中出现单点
6.1.1 负载均衡技术
6.1.2 热备
6.2 提高应用自身的可用性
6.2.1 尽可能地避免故障
6.2.2 及时发现故障
6.2.3 及时处理故障
6.2.4 访问量及数据量不断上涨的应对策略
第7章 构建可伸缩的系统
7.1 垂直伸缩
7.1.1 支撑高访问量
7.1.2 支撑大数据量
7.1.3 提升计算能力
7.2 水平伸缩
7.2.1 支撑高访问量
7.2.2 支撑大数据量
7.2.3 提升计算能力
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式Java应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>外商顧問超強資料製作術
前言──說服，是商業資料最大的目的

第1章──沒有計畫，不可盲目下筆
section 1什麼是資料製作藍圖？
工作需要方針 │ 掌握4個步驟
section 2【視覺步驟】決定資料的形式
商業資料只有12種形式 │ 從邏輯決定資料的形式
section 3【邏輯步驟】提高資料的說服力
證據、主張和證明，缺一不可 │ 「為什麼」的解答就是證明
section 4【產出步驟】讓資料一步步進化
「草稿」是資料製作高手的最佳武器 │ 筆記和草稿都將連結至正式編輯
section 5【溝通步驟】理解對方的想法和心理
以心傳心 │ 贏了資料，別輸在溝通上 │ 經過溝通的資料才有意義 │ 掌握對方隨時變化的心理

第2章──視覺手法的背後，有邏輯做後盾（基礎篇）
section 6視覺手法和邏輯是相互對應的
邏輯共有6種論法＋2種組合 │ 邏輯與視覺類型的對應圖
資料的視覺效果取決於邏輯，而非直覺
section 7【一對一論法】基礎中的基礎：解讀事實，導出主張
一對一論法──從1個事實導出1個主張 │ 利用數據圖建立邏輯，提高說服力［視覺類型1］
畫數據圖的基本規則
section 8【並列論法】以數個事實或案例進行說明
並列論法——用2個以上的事實提高說服力 │ 以不同例子提示共同訊息［視覺類型2］
觀察、分析數個事實後，說明結果［視覺類型2］
section 9【結合論法】結合數個事實，產生訊息
結合論法──結合數個事實，推論出主張 │ 說明3個重點［視覺類型3］
以因式分解說明原因［視覺類型4］ │ 基本階層結構：金字塔原理［視覺類型5］
section 10【連鎖論法】邏輯解說「風一刮，賣木桶的就發」的道理
連鎖論法──結合事實說故事 │ 表示工作或時間的順序［視覺類型6］
加入路線修改的循環［視覺類型7］
column資料的基本版面設計絕不可動搖

第3章──視覺手法的背後，有邏輯做後盾（應用篇）
section 11【結合論法×連鎖論法】偏好組織論的麥肯錫武器
麥肯錫的流程圖 │ 如何繪製業務流程圖［視覺類型8］
用1張紙繪製事業拓展計畫表［視覺類型8］
section 12【對立論法】說明對立的見解A和見解B
對立論法──提示2個對立的見解 │ 比較2大對立軸［視覺類型9］
經營者和管理者大不相同［視覺類型9］
section 13【比較論法】比較數個策略的最佳手法
比較論法──比較數個選項的好壞 │ 比較商業模式［視覺類型10］
用文氏圖比較顧客導向論、定位論和能力論［視覺類型11］
section 14【對立論法×比較論法】擅長策略定位的BCG矩陣
BCG矩陣 │ 以創新矩陣分類產品［視覺類型12］

第4章──邏輯的強大說服力，是人類的最高智慧
section 15證據、主張和證明，3者的關係密不可分
事實是○○，因此◇◇，因為△△ │ 探究邏輯的3個問句
獨一無二的證據與主張
section 16忙碌的決策者只看主張
看資料的主張，就能看出故事 │ 亞馬遜的成功故事 │ 善用5W1H，把你的主張變故事
section 17資料的整體和部分，都要有邏輯
資料的整體和部分 │ 報告總結就是資料的整合
column邏輯思考是可以訓練的

第5章──完成資料有3階段：筆記→草稿→編輯
section 18我的筆記、草稿、編輯例子
空閒時在咖啡廳做筆記 │ 隨手在紙上寫草稿 │ 電腦的正式編輯留待最後
section 19決定要製作資料時，就先做好資料的雛形
先做好空白檔案 │ 一份資料15頁 │ 草稿要重寫幾次都不難
section 20均衡分配溝通、思考和資料製作的時間
1週的時間分配 │ 正式編輯時，1頁資料只花30分鐘 │ 資訊量與思考量，將攸關成果

第6章──溝通，就是因應對方的變化
section 21商場上，決策的品質與速度是關鍵
不確定的時代來臨了 │ 「試了再說」與「修正路線」 │ 決策者的需求時刻都在改變
section 22資料製作的順序變了
過去的資料製作方式 │ 現今需要的資料製作術 │ 產出的優劣，取決於你輸入了什麼
section 23解開對資料製作起點和終點的誤解
對起點的誤解 │ 對終點的誤解
section 24好的溝通，和資料的頁數無關
即使只有1張資料，也能和客戶對談 │ 0資料的溝通技巧
反覆溝通，就能完成資料
column創意，是將既有要素做新的組合
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>外商顧問超強資料製作術
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业总体架构
第1章 前言
1.1 总体架构的发展
第2章 企业信息化的发展和总体架构的历史
2.1 企业信息化发展历史
2.2 信息化现状和遇到的问题
2.3 国际总体架构现况综述
2.4 企业总体架构价值综述
2.5 投资回报分析（ROI）
第3章 企业总体架构内容和发展
3.1 企业总体架构的概念
3.2 企业总体架构的产生
3.3 国际通用的几种企业总体架构的框架理论（EA Framework）
3.4 企业总体架构的方法论
3.5 国际主要总体架构组织和理论介绍
3.6 企业总架构治理和作用
第4章 企业总体架构的规划和设计
4.1 企业总体架构内容
4.2 企业总体架构规划方法要点
4.3 建立企业总体架构
4.4 使用信息系统总体架构
第5章 企业总体架构管理
5.1 总体架构与业务战略关系
5.2 企业总体架构生命周期
5.3 企业总体架构的参与与作用
5.4 信息技术项目选择和投资评价
5.5 企业总体架构成熟度评估
第6章 企业总体架构工具
6.1 总体架构建模和设计工具发展
6.2 总体架构工具的介绍
6.3 Telelogic SA总体架构设计工具
第7章 企业总体架构规划分析及案例
7.1 美国大型企业的总体架构机制（金融、运输、电信、能源、制造）
7.2 总体架构的内容和作用（实例及分析）
7.3 模块和组件（Pattern and Component）
7.4 金融系统技术应用的模型（Application Mode）
7.5 中国企业总体架构设计分析
附录一 术语表
附录二 术语索引表
附录三 参考资料
附录四 总体架构Internet参考信息源
附录五 总体架构工具全球提供商（by Gartner Group）
附录六 联邦总体架构实例例举
编后
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业总体架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>构建高性能Web站点
第1章 绪论
1.1 等待的真相
1.2 瓶颈在哪里
1.3 增加带宽
1.4 减少网页中的HTTP请求
1.5 加快服务器脚本计算速度
1.6 使用动态内容缓存
1.7 使用数据缓存
1.8 将动态内容静态化
1.9 更换Web服务器软件
1.10 页面组件分离
1.11 合理部署服务器
1.12 使用负载均衡
1.13 优化数据库
1.14 考虑可扩展性
1.15 减少视觉等待
第2章 数据的网络传输
2.1 分层网络模型
2.2 带宽
2.3 响应时间
2.4 互联互通
第3章 服务器并发处理能力
3.1 吞吐率
3.2 CPU并发计算
3.3 系统调用
3.4 内存分配
3.5 持久连接
3.6 I/O模型
3.7 服务器并发策略
第4章 动态内容缓存
4.1 重复的开销
4.2 缓存与速度
4.3 页面缓存
4.4 局部无缓存
4.5 静态化内容
第5章 动态脚本加速
5.1 opcode缓存
5.2 解释器扩展模块
5.3 脚本跟踪与分析
第6章 浏览器缓存
6.1 别忘了浏览器
6.2 缓存协商
6.3 彻底消灭请求
第7章 Web服务器缓存
7.1 URL映射
7.2 缓存响应内容
7.3 缓存文件描述符
第8章 反向代理缓存
8.1 传统代理
8.2 何为反向
8.3 在反向代理上创建缓存
8.4 小心穿过代理
8.5 流量分配
第9章 Web组件分离
9.1 备受争议的分离
9.2 因材施教
9.3 拥有不同的域名
9.4 浏览器并发数
9.5 发挥各自的潜力
第10章 分布式缓存
10.1 数据库的前端缓存区
10.2 使用memcached
10.3 读操作缓存
10.4 写操作缓存
10.5 监控状态
10.6 缓存扩展
第11章 数据库性能优化
11.1 友好的状态报告
11.2 正确使用索引
11.3 锁定与等待
11.4 事务性表的性能
11.5 使用查询缓存
11.6 临时表
11.7 线程池
11.8 反范式化设计
11.9 放弃关系型数据库
第12章 Web负载均衡
12.1 一些思考
12.2 HTTP重定向
12.3 DNS负载均衡
12.4 反向代理负载均衡
12.5 IP负载均衡
12.6 直接路由
12.7 IP隧道
12.8 考虑可用性
第13章 共享文件系统
13.1 网络共享
13.2 NFS
13.3 局限性
第14章 内容分发和同步
14.1 复制
14.2 SSH
14.3 WebDAV
14.4 rsync
14.5 Hashtree
14.6 分发还是同步
14.7 反向代理
第15章 分布式文件系统
15.1 文件系统
15.2 存储节点和追踪器
15.3 MogileFS
第16章 数据库扩展
16.1 复制和分离
16.2 垂直分区
16.3 水平分区
第17章 分布式计算
17.1 异步计算
17.2 并行计算
第18章 性能监控
18.1 实时监控
18.2 监控代理
18.3 系统监控
18.4 服务监控
18.5 响应时间监控
参考文献
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>构建高性能Web站点
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>游戏架构与设计
第一部分 游戏设计
第1章 初步概念
第2章 核心设计
第3章 游戏可玩性
第4章 详细设计
第5章 游戏平衡
第6章 外观和感觉
第7章 包装
第8章 游戏设计的未来
第二部分 团队组建和管理
……
第三部分 游戏体系结构
……
第四部分 附录
……
术语表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>游戏架构与设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>程序员的三门课：技术精进、架构修炼、管理探秘
第1篇  技术精进
第1章  程序员技能与成长	2
1.1  如何学习新的编程语言	2
1.1.1  重点学什么	3
1.1.2  学习方法	3
1.2  代码规范与单元测试	6
1.2.1  编码规范	6
1.2.2  单元测试	7
1.2.3  测试驱动设计	9
1.3  使用静态代码分析工具	18
1.3.1  什么是静态代码分析	19
1.3.2  静态代码分析工具	19
1.4  代码审查	24
1.4.1  什么是代码审查	24
1.4.2  代码审查的好处	24
1.4.3  如何做代码审查	25
1.5  清单和模板	29
1.5.1  清单实践	29
1.5.2  产品需求文档模板	31
1.6  程序员的工作法则	33
1.6.1  工具化法则	33
1.6.2  自动化法则	38
1.6.3  关于文档的问题	40
1.6.4  关于YAGNI	40
1.7  程序员的工具箱	41
1.7.1  可帮我们提升工作效率的硬件	42
1.7.2  可帮我们提升工作效率的操作系统	43
1.7.3  可帮我们提升工作效率的软件	43
1.7.4  在线工具	50
第2章  加速成长与学会学习	56
2.1  程序员如何加速成长	56
2.1.1  积极主动	56
2.1.2  空杯心态	57
2.1.3  选择合适的平台	57
2.1.4  别怕犯错	58
2.1.5  注意细节	58
2.1.6  时间管理	58
2.1.7  打破边界	61
2.1.8  写业务代码中的成长机会	61
2.2  学会学习	66
2.2.1  高效学习的方法	67
2.2.2  高效学习的途径	69
2.2.3  舒适区与小步子原则	72
2.2.4  两个著名的学习理论	72
2.2.5  终身成长	74
第3章  业务分析与设计	75
3.1  黄金圈法则	75
3.2  UML建模工具	77
3.2.1  用例图	78
3.2.2  类图	79
3.2.3  对象图	80
3.2.4  状态图	80
3.2.5  活动图	81
3.2.6  序列图	82
3.2.7  协作图	82
3.2.8  构件图	83
3.2.9  部署图	84
3.3  业务分析与设计的方法	85
3.4  系统分析与设计的三个发展阶段	87
3.4.1  面向数据驱动分析与设计	87
3.4.2  面向对象和服务分析与设计	88
3.4.3  面向问题域分析与设计	89
3.5  面向对象分析与设计	90
3.5.1  什么是面向对象	90
3.5.2  面向对象的特征	91
3.5.3  面向对象设计的原则	91
3.6  面向服务分析与设计	93
3.6.1  Web Service模式	93
3.6.2  ESB模式	94
3.6.3  微服务架构	95
3.7  领域驱动设计	97
3.8  领域模型实践	102
3.8.1  什么是领域模型	102
3.8.2  领域模型的作用	102
3.8.3  如何进行领域建模	104
第2篇  架构修炼
第4章  架构思维	110
4.1  分解	110
4.1.1  分解的作用	111
4.1.2  分解的原则	111
4.1.3  分解的时机	112
4.2  集成	112
4.2.1  常见的集成方式	112
4.2.2  集成的难点	115
4.3  动静分离	120
4.4  复用	121
4.4.1  系统复用的分类	122
4.4.2  可复用性和可维护性的关系	123
4.4.3  可维护性地复用的设计原则	123
4.5  分层	126
4.6  模式	127
4.6.1  分层模式	128
4.6.2  客户端-服务器模式	131
4.6.3  主从设备模式	132
4.6.4  管道-过滤器模式	133
4.6.5  代理模式	133
4.6.6  P2P模式	134
4.6.7  事件总线模式	135
4.6.8  MVC模式	136
4.6.9  黑板模式	137
4.6.10  解释器模式	138
4.7  抽象	139
4.8  结构化	139
4.8.1  结构化的原则	140
4.8.2  结构化分析工具	140
4.8.3  结构化思维的7个环节	141
4.9  迭代	141
4.10  勿做过度设计	141
第5章  架构设计	143
5.1  架构设计概要	143
5.1.1  业务架构	143
5.1.2  应用架构	145
5.1.3  技术架构	147
5.1.4  数据架构	149
5.2  架构设计的流程	151
5.3  架构设计的核心要素	153
5.3.1  性能	153
5.3.2  可用性	153
5.3.3  伸缩性	154
5.3.4  扩展性	154
5.3.5  安全性	154
5.4  高性能设计	154
5.4.1  主要的性能测试指标	155
5.4.2  性能测试方法	156
5.4.3  性能优化策略	157
5.5  高可用设计	159
5.5.1  高可用性的度量与考核	159
5.5.2  高可用的架构	160
5.5.3  高可用质量保证	164
5.5.4  系统运行监控	165
5.6  可伸缩设计	166
5.6.1  架构的伸缩性设计	166
5.6.2  应用服务的伸缩性设计	167
5.6.3  分布式缓存的伸缩性设计	169
5.6.4  数据存储的伸缩性设计	169
5.7  可扩展性设计	169
5.7.1  通过消息降低系统的耦合性	170
5.7.2  通过分布式服务提供可复用的业务	170
5.7.3  建立开放平台	170
5.8  架构设计的典型案例——订单系统	171
5.8.1  订单的基本概念	172
5.8.2  订单流程	174
5.8.3  订单系统设计中的挑战和实践	178
5.8.4  数据库优化	182
5.8.5  小结	185
第6章  架构的保障：质量与风险	186
6.1  内建质量体系	186
6.2  从黑天鹅事件到墨菲定律	189
6.2.1  黑天鹅事件	189
6.2.2  蝴蝶效应	191
6.2.3  墨菲定律	191
6.3  软件质量稳定性之殇	192
6.3.1  业务高速发展带来的变化	193
6.3.2  问题域的复杂性	193
6.3.3  系统的复杂性	194
6.3.4  技术债问题	194
6.3.5  人、流程、文档的博弈	195
6.3.6  采用不能掌控的工具和框架	196
6.3.7  质量意识	196
6.4  从康威定律和技术债看研发之痛	197
6.4.1  康威定律	197
6.4.2  通过3个案例来看研发之痛	197
6.4.3  架构方案和业务形态息息相关	204
6.5  求解质量熵	206
6.5.1  运用敏捷思想	207
6.5.2  运用系统化思想	208
6.5.3  技术债偿还计划	209
6.5.4  抓住合适的时机做架构升级	209
6.5.5  内建质量	210
6.5.6  不迷信，不唯新、不唯上，实践是检验真理的标准	210
6.5.7  复杂的问题域：专项突破	210
6.5.8  领导者的意识	211
6.5.9  创新解决方案	211
6.6  踩过的坑和经验总结	212
6.6.1  简单的数字改动导致电商网站搜索功能失灵	212
6.6.2  应用竟然被外部系统拖垮了	212
6.6.3  HashMap与并发	213
6.7  故障复盘流程及模板	215
6.7.1  什么是故障复盘	215
6.7.2  为什么要做故障复盘	215
6.7.3  如何做故障复盘	216
6.7.4  故障复盘模板	219
6.8  监控与告警	221
6.8.1  监控的重要性	221
6.8.2  监控哪些内容	221
6.8.3  告警	224
6.8.4  监控的架构	224
6.9  应急处置	226
第3篇  管理探秘
第7章  为成为技术主管做准备	232
7.1  构建自我阶段性目标	232
7.2  体验自己的目标身份	234
7.3  勇于抓住机会	235
第8章  从自我管理转为管理团队	236
8.1  什么是领导力	236
8.2  如何构建领导力	237
8.2.1  维度1：提供清晰的领导力风格，并以信任感作为基石	238
8.2.2  维度2：了解业务，并带领团队达到高绩效	240
8.2.3  维度3：发展自己和团队成员	240
8.2.4  维度4：塑造未来	241
8.3  让自己成为T型人才	242
8.4  高效时间管理	243
8.4.1  确定在做的事情符合自己的目标	244
8.4.2  随时应用80/20法则	246
8.4.3  创造大块时间	247
8.5  遇到“不服管”的员工怎么办	249
8.5.1  每个人都是不错的	250
8.5.2  建立亲和与信任感	251
8.5.3  从绩效评估到建设性反馈	255
8.6  如何处理冲突	261
8.6.1  了解产生冲突的原因	261
8.6.2  正确看待冲突	262
8.6.3  处理冲突	263
8.7  引导员工主动工作	264
8.8  如何从带10个人到带100个人	266
8.8.1  在管理上面对的挑战	267
8.8.2  从管理1.0到管理2.0	269
8.9  如何对上管理	276
8.9.1  做好对上的预期管理	277
8.9.2  及时汇报	277
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>程序员的三门课：技术精进、架构修炼、管理探秘
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>计算机系统：系统架构与操作系统的高度集成
出版者的话
译者序
前言
第1章 概述 1
1.1 盒子里有什么 1
1.2 计算机系统中的抽象层次 1
1.3 操作系统的作用 3
1.4 盒子里正在发生什么事 5
1.4.1 在计算机上启动应用程序 7
1.5 计算机硬件的演化 7
1.6 操作系统的演化 9
1.7 本书导读 9
练习题 10
参考文献注释和扩展阅读 10
第2章 处理器体系结构 12
2.1 处理器设计涉及什么 12
2.2 如何设计指令集 13
2.3 常见的高级语言功能集 13
2.4 表达式和赋值语句 14
2.4.1 操作数放在哪里 14
2.4.2 在指令中如何指定内存地址 17
2.4.3 每个操作数应该有多宽 18
2.4.4 字节序 9
2.4.5 操作数打包以及字操作数的对齐 21
2.5 高级数据抽象 22
2.5.1 结构 23
2.5.2 数组 23
2.6 条件语句和循环 24
2.6.1 if-then-else语句 25
2.6.2 switch语句 26
2.6.3 循环语句 27
2.7 检查点 27
2.8 编译函数调用 27
2.8.1 调用者的状态 28
2.8.2 过程调用剩余的工作 30
2.8.3 软件惯例 31
2.8.4 活动记录 35
2.8.5 递归 36
2.8.6 帧指针 36
2.9 指令集体系结构选择 38
2.9.1 额外的指令 38
2.9.2 额外的寻址模式 39
2.9.3 体系结构类型 39
2.9.4 指令格式 39
2.10 LC-2200指令集 42
2.10.1 指令格式 42
2.10.2 LC-2200寄存器组 43
2.11 影响处理器设计的问题 44
2.11.1 指令集 44
2.11.2 应用程序对指令集设计的影响 45
2.11.3 其他驱动处理器设计的问题 46
小结 47
练习题 47
参考文献注释和扩展阅读 49
第3章 处理器实现 51
3.1 体系结构与实现 51
3.2 处理器实现涉及什么 51
3.3 重要的硬件概念 52
3.3.1 电路 52
3.3.2 数据通路的硬件资源 52
3.3.3 边沿触发逻辑 53
3.3.4 连接数据通路元件 54
3.3.5 基于总线的设计 57
3.3.6 有限状态机 59
3.4 数据通路设计 60
3.4.1 ISA与数据通路宽度 61
3.4.2 时钟脉冲宽度 62
3.4.3 检查点 62
3.5 控制单元设计 62
3.5.1 ROM加状态寄存器 63
3.5.2 FETCH宏状态 65
3.5.3 DECODE宏状态 68
3.5.4 EXECUTE宏状态：ADD指令（R型指令部分) 68
3.5.5 EXECUTE宏状态：NAND指令（R型指令部分) 71
3.5.6 EXECUTE宏状态：JALR指令（J型指令部分) 71
3.5.7 EXECUTE宏状态：LW指令（I型指令部分 72
3.5.8 EXECUTE宏状态：SW和ADDI指令（I型指令部分) 75
3.5.9 EXECUTE宏状态：BEQ指令（I型指令部分）  75
3.5.10 设计微程序中的条件分支 78
3.5.11 再谈DECODE宏状态 79
3.6 控制单元设计的另一种选择 80
3.6.1 微程序控制 80
3.6.2 硬连线控制 81
3.6.3 在两种控制设计风格中选择 82
小结 82
历史回顾 83
练习题 84
参考文献注释和扩展阅读 86
第4章 中断、陷入及异常 87
4.1 程序执行中的不连续性 88
4.2 处理程序不连续性 89
4.3 处理程序不连续性的体系结构改进 91
4.3.1 修改FSM 91
4.3.2 一个简单的中断处理过程 92
4.3.3 处理级联中断 92
4.3.4 从处理过程中返回 95
4.3.5 检查点 95
4.4 处理程序不连续性的硬件细节 96
4.4.1 中断的数据通路细节 96
4.4.2 获得处理过程地址的细节 97
4.4.3 保存/恢复栈 99
4.5 信息汇总 100
4.5.1 体系结构和硬件改进总结 100
4.5.2 工作中的中断机制 100
小结 102
练习题 103
参考文献注释和扩展阅读 104
第5章 处理器性能与流水线处理器的设计 105
5.1 时间和空间性能指标  105
5.2 指令频率 107
5.3 基准测试程序 108
5.4 提升处理器的性能 111
5.5 加速比 112
5.6 提升处理器的吞吐量 114
5.7 流水线简介 115
5.8 指令处理流水线 115
5.9 简单指令流水线的问题 117
5.10 修正指令流水线里的问题 118
5.11 指令流水线的数据通路元件 120
5.12 针对流水线的体系结构与实现 121
5.12.1 指令穿过流水线的过程详解 122
5.12.2 流水线寄存器的设计 124
5.12.3 各个阶段的实现 125
5.13 冒险 125
5.13.1 结构性冒险 126
5.13.2 数据冒险 126
5.13.3 控制冒险 135
5.13.4 冒险总结 141
5.14 在流水线处理器里处理程序不连续性 142
5.15 处理器设计的高级话题 144
5.15.1 指令级并行 144
5.15.2 更深的流水线 145
5.15.3 在乱序执行下再次讨论程序不连续性 147
5.15.4 管理共享资源 148
5.15.5 功耗 149
5.15.6 多核处理器设计 149
5.15.7 Intel Core微架构：一个流水线 150
小结 151
历史回顾 152
练习题 152
参考文献注释和扩展阅读 156
第6章 处理器调度 157
6.1 引言 157
6.2 程序和进程 158
6.3 调度环境 161
6.4 调度基础 162
6.5 性能指标 165
6.6 非抢占式调度算法 167
6.6.1 先到先服务 167
6.6.2 最短作业优先 170
6.6.3 优先级 171
6.7 抢占式调度算法 172
6.7.1 轮转调度器 175
6.8 结合优先级和抢占 178
6.9 元调度器 178
6.10 评价 179
6.11 调度对处理器体系结构的影响 180
小结和展望 181
Linux调度器—一个案例研究 181
历史回顾 183
练习题 185
参考文献注释和扩展阅读 186
第7章 内存管理技术 187
7.1 内存管理器提供的功能 187
7.2 内存管理的简单方案 189
7.3 内存分配方案 192
7.3.1 固定尺寸分区 192
7.3.2 变长分区 193
7.3.3 缩并 195
7.4 分页虚拟内存 196
7.4.1 页表 197
7.4.2 支持分页的硬件  199
7.4.3 页表的建立  199
7.4.4 虚拟和物理内存的相对大小 200
7.5 分段虚拟内存 200
7.5.1 支持分段的硬件 204
7.6 分页和分段的比较 204
7.6.1 解读CPU生成的地址 206
小结 207
历史回顾 208
MULTICS 209
Intel的内存体系结构 210
练习题 211
参考文献注释和扩展阅读 212
第8章 页式内存管理 213
8.1 按需分页 213
8.1.1 按需分页的硬件 213
8.1.2 页错误处理程序 214
8.1.3 按需分页内存管理的数据结构 214
8.1.4 页错误解析 215
8.2 进程调度器和内存管理器间交互 217
8.3 页替换策略 218
8.3.1 Belady的Min算法 219
8.3.2 随机替换  219
8.3.3 先进先出策略 219
8.3.4 最近最少使用策略 221
8.3.5 第二次机会页替换算法 223
8.3.6 页替换算法回顾 225
8.4 优化内存管理 225
8.4.1 空闲页帧池 225
8.4.2 颠簸 226
8.4.3 工作集 228
8.4.4 颠簸控制 229
8.5 其他考虑 229
8.6 旁路转换缓存 230
8.6.1 TLB的地址转换 231
8.7 内存管理的高级话题 232
8.7.1 多级页表 232
8.7.2 局部页表项的访问权限 234
8.7.3 反向页表 234
小结 234
练习题 234
参考文献注释和扩展阅读 236
第9章 分级存储体系 237
9.1 缓存的概念 238
9.2 局部性原理 238
9.3 基本术语 238
9.4 多级存储层次 239
9.5 缓存结构 241
9.6 直接映射缓存结构 241
9.6.1 缓存查找 243
9.6.2 缓存项中的字段 244
9.6.3 用于直接映射缓存的硬件 245
9.7 流水线处理器设计的影响 247
9.8 缓存读/写算法 247
9.8.1 CPU对缓存的读访问 248
9.8.2 CPU对缓存的写访问 248
9.9 处理器流水线中的缓存缺失处理 251
9.9.1 在流水线性能上缓存缺失对内存延迟的影响 252
9.10 利用空间局部性提高缓存性能 253
9.10.1 增加块大小对性能的影响 256
9.11 灵活的布局策略 257
9.11.1 全相关缓存 258
9.11.2 组相关缓存 259
9.11.3 组相关的极端情况 261
9.12 指令和数据缓存 263
9.13 降低缺失损失 264
9.14 缓存替换策略 264
9.15 缺失类型简要说明 266
9.16 TLB和缓存整合 268
9.17 缓存控制器 269
9.18 虚拟索引物理标记的缓存 270
9.19 缓存设计因素概述 271
9.20 主存的设计因素 272
9.20.1 简单的主存 272
9.20.2 与缓存块大小相匹配的主存和总线 273
9.20.3 交错式内存 273
9.21 现代主存系统分析 274
9.21.1 页式DRAM 278
9.22 分级存储体系的性能影响 279
小结 280
现代处理器的分级存储体系（一个例子） 281
练习题 281
参考文献注释和扩展阅读 283
第10章 输入/输出和稳定性存储 284
10.1 CPU和I/O设备间的通信 284
10.1.1 设备控制器 284
10.1.2 内存映射I/O 285
10.2 程控I/O 287
10.3 DMA 288
10.4 总线 290
10.5 I/O处理器 291
10.6 设备驱动 292
10.6.1 例子 293
10.7 外围设备 295
10.8 磁盘存储器 296
10.8.1 磁盘技术的传奇故事 302
10.9 磁盘调度算法 304
10.9.1 先到先服务 305
10.9.2 最短寻道时间优先 305
10.9.3 SCAN 305
10.9.4 C-SCAN 306
10.9.5 LOOK和C-LOOK 307
10.9.6 磁盘调度总结 307
10.9.7 算法比较 308
10.10 固态硬盘  309
10.11 I/O总线和设备驱动的演化 310
10.11.1 设备驱动的动态负载 311
10.11.2 信息汇总 312
小结 314
练习题 314
参考文献注释和扩展阅读 315
第11章 文件系统 317
11.1 属性 317
11.2 在磁盘子系统上实现文件系统的设计选择 321
11.2.1 连续分配 322
11.2.2 带有溢出区域的连续分配 324
11.2.3 链接分配 324
11.2.4 文件分配表 325
11.2.5 索引分配 327
11.2.6 多级索引分配 328
11.2.7 混合索引分配 328
11.2.8 不同分配策略的比较 331
11.3 信息汇总 331
11.3.1 索引节点 336
11.4 文件系统的组件 336
11.4.1 创建、写入文件的剖析 337
11.5 各种子系统的交互 337
11.6 文件系统在物理媒介上的布局 340
11.6.1 内存中的数据结构 342
11.7 处理系统崩溃 343
11.8 其他物理媒介上的文件系统 343
11.9 现代文件系统一览 344
11.9.1 Linux 344
11.9.2 Microsoft Windows 348
小结 349
练习题 350
参考文献注释和扩展阅读 352
第12章 多线程编程与多处理器 353
12.1 为什么需要多线程 353
12.2 线程所需的编程支持 354
12.2.1 线程创建和终止 354
12.2.2 线程之间的通信 356
12.2.3 读/写冲突、竞争条件及不确定性 357
12.2.4 线程之间的同步 361
12.2.5 线程库中数据类型的内部表示 365
12.2.6 简单的编程示例 366
12.2.7 死锁和活锁 369
12.2.8 条件变量 370
12.2.9 视频处理示例的完整解决方案 373
12.2.10 解决方案的讨论 374
12.2.11 重新检查条件 375
12.3 线程函数调用和多线程编程概念总结 377
12.4 线程编程的一些注意事项 379
12.5 使用线程作为软件结构抽象 379
12.6 POSIX pthread库调用总结 379
12.7 操作系统对线程的支持 382
12.7.1 用户级线程 383
12.7.2 内核级线程 385
12.7.3 Solaris线程：一个内核级线程例子 386
12.7.4 线程和库 387
12.8 在单处理器上的多线程的硬件支持 388
12.8.1 线程创建、终止以及线程间的通信 388
12.8.2 线程之间的同步 388
12.8.3 原子的Test-and-Set指令 388
12.8.4 使用Test-and-Set指令的Lock算法 390
12.9 多处理器 391
12.9.1 页表 391
12.9.2 分级存储体系 391
12.9.3 保证原子性 393
12.10 高级话题 393
12.10.1 操作系统话题 393
12.10.2 架构话题  403
12.10.3 未来之路：多核与众核架构 412
小结 413
历史回顾 414
练习题  415
参考文献注释和扩展阅读 417
第13章 网络与网络协议基础知识 419
13.1 预备知识 419
13.2 基本术语 419
13.3 网络软件 423
13.4 协议栈 424
13.4.1 因特网协议栈 424
13.4.2 OSI模型 426
13.4.3 分层的实际问题 427
13.5 应用层 427
13.6 传输层 428
13.6.1 停止并等待协议 429
13.6.2 流水线协议 431
13.6.3 可靠的流水线协议 432
13.6.4 处理传输错误 436
13.6.5 因特网上的传输协议 437
13.6.6 传输层总结 438
13.7 网络层 439
13.7.1 路由算法 439
13.7.2 因特网寻址 444
13.7.3 网络服务模式 446
13.7.4 网络路由与转发 449
13.7.5 网络层总结 450
13.8 链路层和局域网 450
13.8.1 以太网 451
13.8.2 CSMA/CD 451
13.8.3 IEEE 802. 3453
13.8.4 无线局域网与IEEE 802. 11453
13.8.5 令牌环 454
13.8.6 其他链路层协议 456
13.9 网络硬件 456
13.10 协议栈各层之间的关系 460
13.11 用于数据包传输的数据结构 460
13.11.1 TCP/IP包头 461
13.12 消息传输时间 462
13.13 协议层功能总结 466
13.14 网络软件与操作系统 466
13.14.1 套接字库 467
13.14.2 在操作系统中实现协议栈 468
13.14.3 网络设备驱动程序 468
13.15 使用UNIX套接字进行网络编程 469
13.16 网络服务与高层协议 474
小结 475
历史回顾 475
练习题 480
参考文献注释和扩展阅读 482
第14章 尾声：旅途回顾 483
14.1 处理器设计 483
14.2 进程 483
14.3 虚拟内存系统和内存管理 483
14.4 分级存储体系 484
14.5 并行系统 484
14.6 输入/输出系统 484
14.7 永久性存储 484
14.8 网络 485
结束语 485
附录A 使用UNIX套接字进行网络编程 486
参考文献 495
索引 500
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>计算机系统：系统架构与操作系统的高度集成
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>工业4.0驱动下的制造业数字化转型
目录
序言
Foreword
前言
导读  1
第一篇　工业4.0的诞生背景、理论和方法
第1章　工业4.0诞生的内外因分析  10
1.1　工业4.0的诞生是内因与外因共同作用的结果  10
1.2　内因之一：以客户个性化需求升级为代表的来自市场的挑战  13
1.2.1　工业4.0时代，通过客户定制化需求的拉动来进行价值重构  14
1.2.2　产品多样化给企业的经营带来了巨大的挑战  16
1.2.3　大规模生产和大规模定制的变迁  19
1.3　内因之二：传统制造业向数字化商业模式的转变  22
1.4　外因之一：CPS、物联网等新技术对传统技术的推动  26
1.4.1　网络物理系统  27
1.4.2　物联网  29
1.5　外因之二：提高制造业竞争力的国家竞争战略的需要  31
1.5.1　德国和欧盟对工业4.0的推动  31
1.5.2　美国政府提出的先进制造业计划  33
1.6　案例分析：德国奥迪的智能工厂愿景  34
第2章　基于CPS的工业4.0  36
2.1　CPS的产生背景  36
2.1.1　从工业3.0时代的控制论到工业4.0时代的分布式人工智能  36
2.1.2　人工智能与机器人的研究进展  40
2.1.3　CPS研究的前身--智能主体  43
2.2　CPS的基本理论  45
2.2.1　CPS的定义  45
2.2.2　CPS的五层次结构  47
2.2.3　基于服务和支持实时运行的CPS  50
2.3　基于CPS的网络物理生产系统  51
2.3.1　从大规模定制1.0到大规模定制2.0  51
2.3.2　CPPS下的新系统架构  56
2.3.3　CPPS的实现道路  59
2.4　应用分析：CPS在智能电网、智能交通和智能医疗中的应用  60
2.4.1　智能电网  61
2.4.2　智能交通  62
2.4.3　智能医疗  63
第3章　工业4.0理论的提出和要点  65
3.1　工业4.0的概念和目标  65
3.1.1　物联网和服务联网是实现工业4.0的两大基础和前提  66
3.1.2　CPS是实现工业4.0的核心技术  67
3.1.3　工业4.0不会孤立存在，而是作为智能、网络化世界的一部分  70
3.1.4　作为物联网的一个子集，M2M在工业4.0中扮演着重要的角色  72
3.1.5　工业4.0的五大核心特征  72
3.1.6　工业4.0可以带来新的商业机会和模式  74
3.2　工业4.0的双重战略  75
3.2.1　水平集成  76
3.2.2　垂直集成  77
3.2.3　端到端的开发  77
3.2.4　员工2.0  78
3.3　工业4.0下的智能工厂  79
3.3.1　自动化和互联的设备  79
3.3.2　产品智能化且可配置  80
3.3.3　智能的机器和流程  82
3.3.4　配备的人做好准备，并有相关技术来支撑  83
3.3.5　高级的分析和建模能力  85
3.4　工业4.0的最新进展--智能服务  86
3.5　案例分析：IFM实现从传感器到SAP的透明连接  88
3.5.1　企业概述  88
3.5.2　从传感器到ERP  88
第4章　工业4.0时代下制造业价值网络的数字化转型  92
4.1　数字化转型的基本概念  92
4.2　数字化转型带来的三种重塑机会  94
4.2.1　重塑商业模型  95
4.2.2　重塑业务流程  100
4.2.3　重塑工作  105
4.2.4　重塑背后的技术创造价值方式的改变  106
4.3　以重塑业务流程为代表的制造业数字化转型  108
4.3.1　工业4.0为制造业的数字化转型提供了数字化创新机遇  108
4.3.2　目前的制造业对于数字化技术的应用存在不足  109
4.3.3　工业4.0对制造企业价值链的重构  110
4.4　以重塑商业模式为代表的制造业数字化转型  111
4.4.1　智能服务的前身--产品服务系统  111
4.4.2　以IPSS为代表的面向使用或结果的制造业商业模式  112
4.5　案例分析：全球物流供应商DHL的数字化转型  114
4.5.1　DHL简介  114
4.5.2　案例背景  115
4.5.3　公路货代的业务特点和面临的挑战  115
4.5.4　DHL的数字化业务变革准备  117
4.5.5　工业4.0时代下DHL的物联网探索  119
第二篇　SAP的物联网和工业4.0战略概览
第5章　以S/4 HANA为数字化核心的SAP工业4.0系统架构  124
5.1　以SAP S/4 HANA为数字核心的工业4.0系统架构  125
5.2　SAP迈向工业4.0的产品升级改造历程  127
5.3　技术发展主线一：HANA技术  130
5.3.1　支持内存计算的HANA  130
5.3.2　支持大数据的HANA  132
5.3.3　支持云计算的HANA云平台  134
5.4　技术发展主线二：移动技术  135
5.5　技术发展主线三：云计算技术  136
5.5.1　云计算平台  136
5.5.2　SAP在SaaS软件上的进展  138
5.6　技术发展主线四：S/4 HANA  142
5.7　快速搭建面向工业4.0的企业的新一代数字化平台  145
5.8　案例分析：美国CenterPoint公司的SAP HANA之旅  147
5.8.1　公司简介  147
5.8.2　美国得克萨斯州电力市场概况  147
5.8.3　SAP HANA帮助CenterPoint提高客户管理水平  148
5.8.4　智能电网负载分析  151
5.8.5　智能电网IT/OT融合  153
第6章　SAP的物联网和工业4.0战略与解决方案概览  155
6.1　SAP对物联网的理解  155
6.1.1　网络经济  155
6.1.2　商业用途的物联网  156
6.1.3　物联网的技术构成  158
6.2　SAP眼中的物联网技术基础  158
6.2.1　交付物联网解决方案概述  159
6.2.2　物联网的三个领域  160
6.2.3　将不同的领域整合起来  161
6.2.4　SAP HANA平台为物联网转型做好了准备  165
6.3　SAP的物联网平台架构  165
6.3.1　物联网接入方案之一：基于SAP HCP的IoT版本  167
6.3.2　物联网接入方案之二：基于SAP的移动技术  168
6.4　SAP的工业4.0数字化解决方案的组成  169
6.5　案例分析：美国哈雷·戴维森摩托车公司的大规模定制生产重生之路  170
6.5.1　公司简介  170
6.5.2　战略转型之旅  170
6.5.3　哈雷从互联营销、智能制造到售后服务的全价值链创新  174
第三篇　SAP的六大工业4.0解决方案详述
第7章　工业4.0下的互联产品  180
7.1　SAP互联产品解决方案概述  181
7.2　支持端到端创新的集成的产品开发  183
7.3　支持大规模定制背景下的产品配置管理  185
7.3.1　产品变量配置的基本概念  185
7.3.2　面向大规模定制的产品数据结构  187
7.3.3　将设计与制造进行同步  191
7.4　提供支持物联网的工程控制中心  194
7.4.1　对多种开发工具的支持  194
7.4.2　对物联网多数据源的支持  196
7.5　加快创新速度的创新平台  197
7.5.1　产品组合计划  197
7.5.2　项目管理  198
7.5.3　打造面向员工参与的创新平台  199
7.5.4　打造基于大数据分析的创新平台  200
7.6　连接客户与厂家的资产智能网络  202
7.7　案例分析：德国宝马汽车公司在产品模块化和客户定制化上的数字化转型  206
7.7.1　公司简介  206
7.7.2　案例背景  206
7.7.3　基于产品生命周期管理项目，推动产品的模块化  208
7.7.4　基于面向客户的销售与生产，实现大规模定制业务  209
第8章　工业4.0下的互联营销  212
8.1　SAP互联营销解决方案概述  212
8.2　基于SAP CEC的全渠道商务  213
8.2.1　传统的实体零售市场在向全渠道迅速转变  213
8.2.2　搭建全渠道解决方案的思路  216
8.2.3　SAP的全渠道B2C商务解决方案  218
8.3　基于SAP HANA的大数据驱动的需求管理  220
8.3.1　从需求计划到需求感知  220
8.3.2　大数据下的需求分析  221
8.3.3　需求分析的技术和工具  222
8.3.4　大数据需求供应分析解决方案  223
8.3.5　基于大数据的精准营销  226
8.4　案例分析：德国HSE24公司利用SAP HANA实现大数据分析与精准营销  231
8.4.1　公司简介  231
8.4.2　电视购物客户与购买特点  232
8.4.3　面临的挑战  234
8.4.4　解决方案  236
第9章　工业4.0下的互联制造  238
9.1　SAP的互联制造解决方案概述  238
9.1.1　SAP的互联制造及其技术路线  238
9.1.2　基于SAP的互联制造解决方案建立开放式集成工厂  241
9.2　基于SAP IBP的供应与响应计划  243
9.2.1　响应与需求管理  244
9.2.2　产品计划与排程  247
9.3　基于SAP HANA的MRP  250
9.4　SAP的制造执行（ME）  252
9.4.1　MES和ERP的区别与互补  252
9.4.2　SAP ME在智能工厂中的应用  255
9.5　SAP的制造集成与智能（MII）  259
9.5.1　挑战：制造业孤岛  259
9.5.2　MII是制造企业的"粘结剂"  259
9.5.3　MII是制造企业的"巡视员"  260
9.5.4　MII是制造企业的"分析师"  260
9.6　SAP工厂连接解决方案  262
9.7　案例分析：德国Elster公司通过OPC UA实现SAP ME与车间自动化设备的连接  264
9.7.1　公司简介  264
9.7.2　项目背景  264
9.7.3　MES项目  265
第10章　工业4.0下的互联供应  269
10.1　SAP的互联供应解决方案概述  269
10.2　通过SAP Ariba搭建互联商务平台  270
10.3　通过SAP IBP搭建需求驱动的业务计划  272
10.3.1　使用集成的业务计划来取代传统的供应链计划系统  272
10.3.2　制订销售和运营计划  273
10.3.3　通过内部和外部的需求数据来提高决策水平  276
10.4　通过SAP IBP搭建供应链控制塔  279
10.4.1　预见问题的能力  280
10.4.2　获取对外包供应链的控制  281
10.4.3　获得敏捷能力  281
10.5　基于SAP SNC的供应网络协同  282
10.6　案例分析：美国高露洁棕榄公司的SAP全球供应链管理  285
10.6.1　公司简介  285
10.6.2　背景  285
10.6.3　高露洁基于SAP的供应链管理  287
第11章　工业4.0下的互联物流  292
11.1　工业4.0环境下物流的新特点  292
11.2　SAP的互联物流解决方案概述  293
11.3　基于SAP WMS/EWM的仓库管理  295
11.3.1　与互联设备的连接  295
11.3.2　与仓储自动化设备的连接  296
11.3.3　增强现实在仓库操作中的应用  298
11.4　基于SAP TM的运输管理  300
11.5　基于SAP EM的跟踪与追溯  302
11.6　SAP的物流网络中心解决方案  303
11.7　案例分析：德国汉堡港的智能港口物流平台  304
11.7.1　公司简介  304
11.7.2　智能港口物流项目背景  305
11.7.3　基于SAP物流网络中心解决方案打造的云平台  307
第12章　工业4.0下的互联服务  309
12.1　工业4.0对产品服务的要求  309
12.2　SAP的远程维修与服务解决方案  310
12.2.1　远程维修与服务的方案架构  310
12.2.2　远程维修与服务的业务效益  312
12.3　SAP的预测性维修与服务  313
12.3.1　方案概述  313
12.3.2　PDMS的应用  315
12.3.3　使用SAP PDMS解决方案的价值  317
12.4　SAP增强现实方案在服务中的应用  318
12.5　案例分析：德国凯撒压缩机公司通过大数据和实时业务，将以客户为中心的服务业务提升到更高的水平  319
12.5.1　公司简介  320
12.5.2　大数据支持下的预防性维护  321
12.5.3　将产品开发与客户需求联系起来  323
12.5.4　通过洞察来加快获取价值的速度  323
第四篇　工业4.0应用效益分析和趋势展望
第13章　制造企业实施工业4.0和物联网的效益与挑战  326
13.1　工业4.0定性的效益分析  326
13.2　工业4.0定量的效益分析  329
13.3　物联网的行业应用效益  330
13.4　汽车零部件企业实现工业4.0的价值分析  332
13.4.1　集成的生产与物流流程  333
13.4.2　加强机器和人之间的协作  333
13.4.3　提高车间层的生产效率  333
13.5　技术、经济、组织、法律等方面对工业4.0的挑战  334
13.6　应用分析：工业4.0为汽车工业带来的变化  336
13.6.1　对复杂性的管理是汽车企业取得成功的关键  336
13.6.2　基于无传送带的分布式汽车生产系统  338
第14章　下一阶段工业4.0的发展及其相关动向  340
14.1　工业4.0的发展路径  340
14.2　智能服务的成熟度  341
14.3　工业4.0参考架构模型  343
14.3.1　RAMI 4.0的结构  343
14.3.2　使用RAMI 4.0的好处  345
14.4　美国先进制造的发展方向  346
14.4.1　先进传感器、控制和制造平台技术  348
14.4.2　可视化、信息化和数字化的制造技术  349
14.5　美国的工业互联网、中国的"中国制造2025"和"互联网+"  351
14.5.1　美国的工业互联网与德国工业4.0  351
14.5.2　"互联网+"的解读  354
14.5.3　"中国制造2025"与电子商务的成功之路  354
缩略语  357
参考文献  362
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>工业4.0驱动下的制造业数字化转型
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Web服务架构与开放互操作技术
第1章  引言
1. 1  计算机发展与技术革命
1. 2  Web体系架构的进化
1. 3　XML Web服务, 第三次革命
1. 4　本书内容安排
第2章  Web服务, 全新的架构

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Web服务架构与开放互操作技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>管理软件商务架构
第1章 商务架构――管理软件的命脉
第2章 商务架构的驱动引擎
第3章 商务架构的支撑领域
第4章 商务架构参考模型
第5章 立体价值链与管理软件有效覆盖能力
第6章 结构化管理：求解流程管理与职能管理难题
第7章 业务组件体系：商务架构元素固定与变动的哲学
第8章 商务架构的质量属性
……
致谢
主要公开参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>管理软件商务架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件架构设计
译者序
前言
第1章　引言 1
1.1　写作动机 1
1.2　软件架构 2
1.2.1　软件架构的重要性 2
1.2.2　生命周期活动 3
1.3　架构师的角色 5
1.4　ADD发展史 6
1.5　小结 7
1.6　扩展阅读 8
第2章　架构设计 9
2.1　通用设计 9
2.2　软件架构中的设计 10
2.2.1　架构设计 11
2.2.2　元素交互设计 11
2.2.3　元素内部设计 12
2.3　为什么架构设计如此重要 13
2.4　架构驱动因子 13
2.4.1　设计目的 14
2.4.2　质量属性 15
2.4.3　主要功能 19
2.4.4　架构关注点 20
2.4.5　约束条件 21
2.5　设计概念：用于创建结构的构建块 22
2.5.1　参考架构 22
2.5.2　架构的设计模式 24
2.5.3　部署模式 25
2.5.4　策略 26
2.5.5　外部开发组件 27
2.6　架构设计决策 30
2.7　小结 31
2.8　扩展阅读 32
第3章　架构设计过程 34
3.1　原理性方法的必要性 34
3.2　属性驱动设计 3.0 34
3.2.1　步骤1：评审输入 35
3.2.2　步骤2：通过选择驱动因子建立迭代目标 36
3.2.3　步骤3：选择一个或多个系统元素来细化 37
3.2.4　步骤4：选择一个或多个设计概念以满足选中的驱动因子 37
3.2.5　步骤5：实例化架构元素、分配职责和定义接口 37
3.2.6　步骤6：草拟视图和记录设计决策 38
3.2.7　步骤7：分析当前设计、评审迭代目标、实现设计目的 38
3.2.8　按需迭代 39
3.3　根据系统类型遵循设计路线图 39
3.3.1　成熟领域的绿地系统设计 39
3.3.2　新兴领域的绿地系统设计 41
3.3.3　现存系统的设计（棕地） 42
3.4　识别和选择设计概念 42
3.4.1　识别设计概念 42
3.4.2　选择设计概念 43
3.5　结构生成 46
3.5.1　元素实例化 47
3.5.2　划分职责和识别属性 47
3.5.3　建立元素间的关系 48
3.6　定义接口 48
3.6.1　外部接口 48
3.6.2　内部接口 48
3.7　在设计中创建概要文档 51
3.7.1　记录视图的草图 51
3.7.2　记录设计决策 53
3.8　追踪设计进度 55
3.8.1　使用架构待办事项清单 55
3.8.2　使用设计看板 55
3.9　小结 57
3.10　扩展阅读 57
第4章　案例研究：FCAPS系统 59
4.1　商用案例 59
4.2　系统需求 60
4.2.1　用例模型 60
4.2.2　质量属性场景 62
4.2.3　约束条件 62
4.2.4　架构关注点 62
4.3　设计过程 63
4.3.1　ADD 步骤1：评审输入 63
4.3.2　迭代1:建立一个完整的系统架构 63
4.3.3　迭代2：识别支持基本功能的架构 70
4.3.4　迭代3：解决质量属性场景的驱动因子（质量属性-3） 77
4.4　小结 80
4.5　扩展阅读 81
第5章　案例研究：大数据系统 82
5.1　商用案例 82
5.2　系统需求 83
5.2.1　用例模型 83
5.2.2　质量属性场景 83
5.2.3　约束条件 84
5.2.4　架构关注点 84
5.3　设计过程 84
5.3.1　ADD方法的步骤1：评审输入 85
5.3.2　迭代1：参考架构和系统整体结构 85
5.3.3　迭代2：技术选择 91
5.3.4　迭代3：数据流元素的细化 99
5.3.5　迭代4：服务层的细化 104
5.4　小结 107
5.5　扩展阅读 107
第6章　案例研究：银行系统 109
6.1　商用案例 109
6.1.1　用例模型 110
6.1.2　质量属性场景 111
6.1.3　约束条件 111
6.1.4　架构关注点 111
6.2　现有的架构文档 112
6.2.1　模块视图 112
6.2.2　分配视图 113
6.3　设计过程 114
6.3.1　ADD方法的步骤1：评审输入 114
6.3.2　迭代1：支持新的驱动因子 114
6.4　小结 118
6.5　扩展阅读 119
第7章　其他设计方法 120
7.1　一种软件架构设计的通用模型 120
7.2　以架构为中心的设计方法 121
7.3　RUP中的架构活动 123
7.4　软件架构设计的过程 124
7.5　一种实现架构与设计的方法 126
7.6　视点与视角方法 127
7.7　小结 129
7.8　扩展阅读 129
第8章　设计过程中的分析 131
8.1　分析和设计 131
8.2　为何分析 133
8.3　分析方法 134
8.4　基于策略的分析 135
8.5　值得反思的问题 137
8.6　基于场景的设计评审 138
8.7　架构描述语言 141
8.8　小结 142
8.9　扩展阅读 142
第9章　组织中的架构设计过程 144
9.1　架构设计与开发生命周期 144
9.1.1　售前阶段的架构设计 145
9.1.2　开发运维阶段的架构设计 146
9.2　组织方面的问题 150
9.2.1　个人设计还是团队设计 150
9.2.2　在组织中应用一套设计概念目录 151
9.3　小结 152
9.4　扩展阅读 152
第10章　结束语 154
10.1　方法的必要性 154
10.2　下一步 155
10.3　扩展阅读 156
附录A　设计概念目录 157
附录B　基于策略的问卷调查 184
术语表 196
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件架构设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据与数据仓库：集成、架构与管理
译者序
前言
致谢
作者简介
第一部分　大数据
第1章　大数据简介2
1.1　引言2
1.2　大数据2
1.3　大数据的定义4
1.4　为什么需要大数据？为什么是现在4
1.5　大数据示例5
1.5.1　社交媒体的文章5
1.5.2　调查数据分析6
1.5.3　调查数据7
1.5.4　气象数据8
1.5.5　Twitter数据8
1.5.6　集成和分析8
1.5.7　附加数据的类型10
1.6　总结11
延伸阅读11
第2章　使用大数据12
2.1　引言12
2.2　数据爆炸12
2.3　数据体量13
2.3.1　机器数据14
2.3.2　应用日志14
2.3.3　点击流日志14
2.3.4　外部或第三方数据15
2.3.5　电子邮件15
2.3.6　合同15
2.3.7　地理信息系统和地理空间数据16
2.3.8　示例：Funshots公司17
2.4　数据速度19
2.4.1　Amazon、Facebook、Yahoo和Google19
2.4.2　传感器数据19
2.4.3　移动网络20
2.4.4　社交媒体20
2.5　数据多样性21
2.6　总结22
第3章　大数据处理架构23
3.1　引言23
3.2　再论数据处理23
3.3　数据处理技术24
3.4　数据处理基础设施的挑战25
3.4.1　存储25
3.4.2　传输25
3.4.3　处理26
3.4.4　速度或吞吐量26
3.5　全共享架构与无共享架构的比较26
3.5.1　全共享架构27
3.5.2　无共享架构27
3.5.3　OLTP与数据仓库28
3.6　大数据处理28
3.6.1　基础设施方面31
3.6.2　数据处理方面32
3.7　电信大数据研究32
3.7.1　基础设施34
3.7.2　数据处理34
第4章　大数据技术简介35
4.1　引言35
4.2　分布式数据处理36
4.3　大数据处理需求38
4.4　大数据处理技术39
4.5　Hadoop42
4.5.1　Hadoop核心组件43
4.5.2　Hadoop总结69
4.6　NoSQL69
4.6.1　CAP定理69
4.6.2　键-值对：Voldemort70
4.6.3　列簇存储：Cassandra70
4.6.4　文档数据库：Riak76
4.6.5　图数据库77
4.6.6　NoSQL小结78
4.7　文本ETL处理78
延伸阅读79
第5章　大数据驱动的商业价值80
5.1　引言80
5.2　案例研究1：传感器数据81
5.2.1　摘要81
5.2.2　Vestas81
5.2.3　概述81
5.2.4　利用风力发电81
5.2.5　把气候变成资本82
5.2.6　跟踪大数据的挑战83
5.2.7　维持数据中心的能源效率83
5.3　案例研究2：流数据84
5.3.1　摘要84
5.3.2　监控和安全：TerraEchos84
5.3.3　需求84
5.3.4　解决方案84
5.3.5　效益84
5.3.6　先进的光纤网结合实时流数据85
5.3.7　解决方案组件85
5.3.8　扩展安全边界创建战略优势85
5.3.9　关联传感器数据使得假阳性率为零86
5.4　案例研究3：通过大数据分析改善患者预后86
5.4.1　摘要86
5.4.2　业务目标87
5.4.3　挑战87
5.4.4　概述：给从业人员新的洞察以指导患者护理87
5.4.5　挑战：将传统数据仓库生态系统与大数据融合87
5.4.6　解决方案：为大数据分析做好准备88
5.4.7　结果：消除“数据陷阱”88
5.4.8　为什么是aster88
5.4.9　关于Aurora89
5.5　案例研究4：安大略大学技术学院—利用关键数据，提供积极的患者护理89
5.5.1　摘要89
5.5.2　概述89
5.5.3　商业上的收益90
5.5.4　更好地利用数据资源90
5.5.5　智慧医疗保健91
5.5.6　解决方案组件91
5.5.7　融合人类知识与技术92
5.5.8　扩大Artemis的影响92
5.6　案例研究5：微软SQL Server客户解决方案93
5.6.1　客户画像93
5.6.2　解决方案的亮点93
5.6.3　业务需求93
5.6.4　解决方案94
5.6.5　好处94
5.7　案例研究6：以客户为中心的数据集成95
5.7.1　概述95
5.7.2　解决方案设计98
5.7.3　促成更好的交叉销售和追加销售的机会99
5.8　总结100
第二部分　数据仓库
第6章　再论数据仓库102
6.1　引言102
6.2　传统的数据仓库或DW 1.0103
6.2.1　数据架构103
6.2.2　基础设施104
6.2.3　数据仓库的陷阱106
6.2.4　建立数据仓库的架构方法111
6.3　DW 2.0113
6.3.1　Inmon的DW 2.0概述114
6.3.2　DSS 2.0概述115
6.4　总结116
延伸阅读116
第7章　数据仓库的再造118
7.1　引言118
7.2　企业数据仓库平台118
7.2.1　事务型系统119
7.2.2　运营数据存储区119
7.2.3　分段区120
7.2.4　数据仓库120
7.2.5　数据集市120
7.2.6　分析型数据库121
7.2.7　数据仓库的问题121
7.3　再造数据仓库的选择122
7.3.1　平台再造122
7.3.2　平台工程123
7.3.3　数据工程124
7.4　使数据仓库现代化125
7.5　使数据仓库现代化的案例研究127
7.5.1　当前状态分析127
7.5.2　推荐127
7.5.3　现代化的业务收益128
7.5.4　一体机的选择过程128
7.6　总结132
第8章　数据仓库中的工作负载管理133
8.1　引言133
8.2　当前状态133
8.3　工作负载的定义134
8.4　了解工作负载135
8.4.1　数据仓库输出136
8.4.2　数据仓库输入137
8.5　查询分类138
8.5.1　宽/宽138
8.5.2　宽/窄139
8.5.3　窄/宽139
8.5.4　窄/窄139
8.5.5　非结构化/半结构化数据140
8.6　ETL和CDC的工作负载140
8.7　度量141
8.8　当前系统设计的局限142
8.9　新工作负载和大数据143
8.10　技术选择144
8.11　总结144
第9章　应用到数据仓库的新技术145
9.1　引言145
9.2　重新检查数据仓库挑战145
9.2.1　数据加载145
9.2.2　可用性146
9.2.3　数据体量146
9.2.4　存储性能147
9.2.5　查询性能147
9.2.6　数据传输147
9.3　数据仓库一体机147
9.3.1　一体机架构148
9.3.2　一体机中的数据分布149
9.3.3　部署数据仓库一体机最佳实践150
9.3.4　大数据一体机152
9.4　云计算152
9.4.1　基础设施即服务152
9.4.2　平台即服务152
9.4.3　软件即服务153
9.4.4　云基础架构153
9.4.5　云计算给数据仓库带来的好处154
9.4.6　将云计算用于数据仓库所面临的问题154
9.5　数据虚拟化154
9.5.1　数据虚拟化是什么155
9.5.2　提高商务智能性能156
9.5.3　工作负载分布156
9.5.4　实施数据虚拟化项目156
9.5.5　使用数据虚拟化时应避免的误区157
9.5.6　内存技术157
9.5.7　内存架构的好处157
9.6　总结158
延伸阅读158
第三部分　构建大数据-数据仓库
第10章　大数据和数据仓库的集成160
10.1　引言160
10.2　新数据仓库的组件160
10.2.1　数据层161
10.2.2　算法162
10.2.3　技术层163
10.3集成策略164
10.3.1　数据驱动的集成164
10.3.2　物理组件集成和架构167
10.3.3　外部数据集成168
10.4Hadoop与RDBMS169
10.5大数据一体机171
10.6数据虚拟化172
10.7语义框架173
10.7.1　词法处理174
10.7.2　聚类174
10.7.3语义知识处理174
10.7.4信息抽取175
10.7.5可视化175
10.8总结175
第11章　大数据的数据驱动架构176
11.1引言176
11.2元数据177
11.2.1技术元数据177
11.2.2业务元数据178
11.2.3上下文元数据178
11.2.4过程设计级元数据178
11.2.5程序级元数据178
11.2.6基础设施元数据179
11.2.7核心业务元数据179
11.2.8运营元数据179
11.2.9商务智能型元数据180
11.3主数据管理180
11.4处理数据仓库中的数据181
11.5处理大数据的复杂性184
11.5.1处理能力的限制184
11.5.2处理大数据184
11.6机器学习190
11.7总结193
第12章　大数据的信息管理和生命周期195
12.1引言195
12.2信息生命周期管理195
12.2.1目标196
12.2.2信息管理策略196
12.2.3治理196
12.2.4信息生命周期管理的优点200
12.3大数据的信息生命周期管理200
12.3.1示例：信息生命周期管理和社交媒体数据200
12.3.2测量信息生命周期管理的影响202
12.4总结203
第13章　大数据分析、可视化和数据科学家204
13.1引言204
13.2大数据分析204
13.3数据发现206
13.4可视化206
13.5数据科学家的角色变迁207
13.6总结208
第14章　实施大数据-数据仓库的现实情况209
14.1引言：构建大数据-数据仓库209
14.2以客户为中心的业务转型209
14.3Hadoop和MySQL驱动创新212
14.4将大数据集成到数据仓库中214
14.4.1增强决策制订215
14.4.2成果216
14.5总结216
附录A　客户案例研究217
附录B　建设医疗保健信息工厂237
结束语269
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据与数据仓库：集成、架构与管理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>系统架构设计师教程
第1章 绪论
第2章 计算机与网络基础知识
第3章 信息系统基础知识
第4章 系统开发基础知识
第5章 软件架构设计
第6章 UML建模与架构文档化
第7章 设计模式
第8章 XML技术
第9章 面向构件的软件设计
第10章 构件平台与典型架构
第11章 信息安全技术
第12章 系统安全架构设计
第13章 系统的可靠性设计
第14章 基于ODP的架构师实践
第15章 架构师的管理实践
第16章 层次式架构设计
第17章 企业集成架构设计
第18章 面向方面的编程
第19章 嵌入式系统设计
第20章 面向服务的架构
第21章 案例研究
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>系统架构设计师教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式之禅
前 言
第一部分 大旗不挥，谁敢
冲锋—热身篇
第1章 单一职责原则
1.1 我是“牛”类，我可以担任多职吗
1.2 绝杀技，打破你的传统思维
1.3 我单纯，所以我快乐
1.4 最佳实践
第2章 里氏替换原则
2.1 爱恨纠葛的父子关系
2.2 纠纷不断，规则压制
2.3 最佳实践
第3章 依赖倒置原则
3.1 依赖倒置原则的定义
3.2 言而无信，你太需要契约
3.3 依赖的三种写法
3.4 最佳实践
第4章 接口隔离原则
4.1 接口隔离原则的定义
4.2 美女何其多，观点各不同
.4.3 保证接口的纯洁性
4.4 最佳实践
第5章 迪米特法则
5.1 迪米特法则的定义
5.2 我的知识你知道得越少越好
5.3 最佳实践
第6章 开闭原则
6.1 开闭原则的定义
6.2 开闭原则的庐山真面目
6.3 为什么要采用开闭原则
6.4 如何使用开闭原则
6.5 最佳实践
第二部分 我惹了谁—
真刀实枪篇
第7章 单例模式
7.1 我是皇帝我独苗
7.2 单例模式的定义
7.3 单例模式的应用
7.4 单例模式的扩展
7.5 最佳实践
第8章 工厂方法模式
8.1 女娲造人的故事
8.2 工厂方法模式的定义
8.3 工厂方法模式的应用
8.3.1 工厂方法模式的优点
8.3.2 工厂方法模式的使用场景
8.4 工厂方法模式的扩展
8.5 最佳实践
第9章 抽象工厂模式
9.1 女娲的失误
9.2 抽象工厂模式的定义
9.3 抽象工厂模式的应用
9.3.1 抽象工厂模式的优点
9.3.2 抽象工厂模式的缺点
9.3.3 抽象工厂模式的使用场景
9.3.4 抽象工厂模式的注意事项
9.4 最佳实践
第10章 模板方法模式
10.1 辉煌工程—制造悍马
10.2 模板方法模式的定义
10.3 模板方法模式的应用
10.4 模板方法模式的扩展
10.5 最佳实践
第11章 建造者模式
11.1 变化是永恒的
11.2 建造者模式的定义
11.3 建造者模式的应用
11.4 建造者模式的扩展
11.5 最佳实践
第12章 代理模式
12.1 我是游戏至尊
12.2 代理模式的定义
12.3 代理模式的应用
12.3.1 代理模式的优点
12.3.2 代理模式的应用
12.4 代理模式的扩展
12.4.1 普通代理
12.4.2 强制代理
12.4.3 代理是有个性的
12.4.4 虚拟代理
12.4.5 动态代理
12.5 最佳实践
第13章 原型模式
13.1 个性化电子账单
13.2 原型模式的定义
13.3 原型模式的应用
13.3.1 原型模式的优点
13.3.2 原型模式的使用场景
13.4 原型模式的注意事项
13.4.1 构造函数不会被执行
13.4.2 浅拷贝和深拷贝
13.4.3 clone与final两个冤家
13.5 最佳实践
第14章 中介者模式
14.1 进销存管理是这个样子的吗？
14.2 中介者模式的定义
14.3 中介者模式的应用
14.4 中介者模式的实际应用
14.5 最佳实践
第15章 命令模式
15.1 项目经理也难当
15.2 命令模式的定义
15.3 命令模式的应用
15.3.1 命令模式的优点
15.3.2 命令模式的缺点
15.3.3 命令模式的使用场景
15.4 命令模式的扩展
15.4.1 未讲完的故事
15.4.2 反悔问题
15.5 最佳实践
第16章 责任链模式
16.1 古代妇女的枷锁—“三从四德”
16.2 责任链模式的定义
16.3 责任链模式的应用
16.3.1 责任链模式的优点
16.3.2 责任链模式的缺点
16.3.3 责任链模式的注意事项
16.4 最佳实践
第17章 装饰模式
17.1 罪恶的成绩单
17.2 装饰模式的定义
17.3 装饰模式应用
17.3.1 装饰模式的优点
17.3.2 装饰模式的缺点
17.3.3 装饰模式的应用
17.4 最佳实践
第18章 策略模式
18.1 刘备江东娶妻，赵云他容易吗
18.2 策略模式的定义
18.3 策略模式的应用
18.3.1 策略模式的优点
18.3.2 策略模式的缺点
18.3.3 策略模式的应用
18.3.4 策略模式的注意事项
18.4 策略模式的扩展
18.5 最佳实践
第19章 适配器模式
19.1 业务发展—上帝才能控制
19.2 适配器模式的定义
19.3 适配器模式的应用
19.3.1 适配器模式的优点
19.3.2 适配器模式的应用
19.3.3 适配器模式的注意事项
19.4 适配器模式的扩展
19.5 最佳实践
第20章 迭代器模式
20.1 整理项目信息—苦差事
20.2 迭代器模式的定义
20.3 迭代器模式的应用
20.4 最佳实践
第21章 组合模式
21.1 公司的人事架构是这样的吗
21.2 组合模式的定义
21.3 组合模式的应用
21.3.1 组合模式的优点
21.3.2 组合模式的缺点
21.3.3 组合模式的应用
21.3.4 组合模式的注意事项
21.4 组合模式的扩展
21.4.1 真实的组合模式
21.4.2 透明的组合模式
21.4.3 组合模式的遍历
21.5 最佳实践
第22章 观察者模式
22.1 韩非子身边的卧底是谁派来的
22.2 观察者模式的定义
22.3 观察者模式的应用
22.3.1 观察者模式的优点
22.3.2 观察者模式的缺点
22.3.3 观察者模式的应用
22.3.4 观察者模式的注意事项
22.4 观察者模式的扩展
22.4.1 java世界中的观察者模式
22.4.2 项目中真实观察者模式
22.4.3 订阅发布模型
22.5 最佳实践
第23章 门面模式
23.1 我要投递信件
23.2 门面模式的定义
23.3 门面模式的应用
23.3.1 门面模式的优点
23.3.2 门面模式的缺点
23.3.3 门面模式的应用
23.4 门面模式的注意事项
23.4.1 一个子系统可以有多个
门面
23.4.2 门面不参与子系统内的
业务逻辑
23.5 最佳实践
第24章 备忘录模式
24.1 如此追女孩子，你还不乐
24.2 备忘录模式的定义
24.3 备忘录模式的应用
24.3.1 备忘录模式的应用
24.3.2 备忘录模式的注意事项
24.4 备忘录模式的扩展
24.4.1 clone方式的备忘录
24.4.2 多状态的备忘录模式
24.4.3 多备份的备忘录
24.4.4 封装得更好一点
24.5 最佳实践
第25章 访问者模式
25.1 员工的隐私何在？
25.2 访问者模式的定义
25.3 访问者模式的应用
25.3.1 访问者模式的优点
25.3.2 访问者模式的缺点
25.3.3 访问者模式的应用
25.4 访问者模式的扩展
25.4.1 统计功能
25.4.2 多个访问者
25.4.3 双分派
25.5 最佳实践
第26章 状态模式
26.1 城市的纵向发展功臣—电梯
26.2 状态模式的定义
26.3 状态模式的应用
26.3.1 状态模式的优点
26.3.2 状态模式的缺点
26.3.3 状态模式的应用
26.3.4 状态模式的注意事项
26.4 最佳实践
第27章 解释器模式
27.1 四则运算你会吗
27.2 解释器模式的定义
27.3 解释器模式的应用
27.3.1 解释器模式的优点
27.3.2 解释器模式的缺点
27.3.3 解释器模式使用的场景
27.3.4 解释器模式的注意事项
27.4 最佳实践
第28章 享元模式
28.1 内存溢出，司空见惯
28.2 享元模式的定义
28.3 享元模式的应用
28.3.1 享元模式优点和缺点
28.3.2 享元模式的应用
28.4 享元模式的扩展
28.4.1 线程安全的问题
28.4.2 性能平衡
28.5 最佳实践
第29章 桥梁模式
29.1 我有一个梦想……
29.2 桥梁模式的定义
29.3 桥梁模式的应用
29.3.1 桥梁模式的优点
29.3.2 桥梁模式的应用
29.3.3 桥梁模式的注意事项
29.4 最佳实践
第三部分 谁的地盘谁做主—模式pk篇
第30章 创建类模式大pk
30.1 工厂方法模式vs建造者模式
30.1.1 按工厂方法建造超人
30.1.2 按建造者模式建造超人
30.1.3 最佳实践
30.2 抽象工厂模式vs建造者模式
30.2.1 按抽象工厂模式生产车辆
30.2.2 按建造者模式生产车辆
30.2.3 最佳实践
第31章 结构类模式大pk
31.1 代理模式vs装饰模式
31.1.1 代理模式
31.1.2 装饰模式
31.1.3 最佳实践
31.2 装饰模式vs适配器模式
31.2.1 按装饰模式描述丑小鸭
31.2.2 按适配器模式实现丑小鸭
31.2.3 最佳实践
第32章 行为类模式大pk
32.1 命令模式vs策略模式
32.1.1 策略模式实现压缩算法
32.1.2 命令模式实现压缩算法
32.1.3 小结
32.2 策略模式vs状态模式
32.2.1 策略模式实现人生
32.2.2 状态模式实现人生
32.2.3 小结
32.3 观察者模式vs责任链模式
32.3.1 责任链模式实现dns
解析过程
32.3.2 触发链模式实现dns解析过程
32.3.3 小结
第33章 跨战区pk
33.1 策略模式vs桥梁模式
33.1.1 策略模式实现邮件发送
33.1.2 桥梁模式实现邮件发送
33.1.3 最佳实践
33.2 门面模式vs中介者模式
33.2.1 中介者模式实现工资计算
33.2.2 门面模式实现工资计算
33.2.3 最佳实践
33.3 包装模式群pk
33.3.1 代理模式
33.3.2 装饰模式
33.3.3 适配器模式
33.3.4 桥梁模式
33.3.5 最佳实践
第四部分 完美世界—混编模式
第34章 命令模式+责任链模式
34.1 搬移unix的命令
34.2 混编小结
第35章 工厂方法模式+策略模式
35.1 迷你版的交易系统
35.2 混编小结
第36章 观察者模式+中介者模式
36.1 事件触发器的开发
36.2 混编小结
第37章 规格模式
37.1 规格模式的实现
37.2 最佳实践
第38章 mvc框架
38.1 mvc框架的实现
38.1.1 mvc的系统架构
38.1.2 模型管理器
38.1.3 值栈
38.1.4 视图管理器
38.1.5 工具类
38.2 最佳实践
附录：23个设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式之禅
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>App架构师实践指南
第一篇　基　础　篇
第 1章　App架构师成长路线 2
1．1　架构师定义 2
1．2　程序员发展路线 3
1．3　App架构师技能矩阵 5
1．3．1　App架构师画布 5
1．3．2　技能图谱 5
1．4　本章小结 6
1．5　推荐资料 7
第2章　App基础语法系列 8
2．1　编程语言 8
2．1．1　那些年，那些语言 9
2．1．2　聊聊Swift 11
2．1．3　Swift 3和Java 8新特性 13
2．2　面向对象思想 14
2．2．1　编程范式 14
2．2．2　封装、继承与多态 15
2．2．3　内部类的使用和思考 17
2．3　线程与进程 19
2．4　反射、注解与泛型 21
2．4．1　反射与注解 21
2．4．2　泛型 23
2．5　本章小结 24
2．6　推荐资料 25
第3章　App开发工具系列 26
3．1　IDE 26
3．1．1　Android Studio 27
3．1．2　Xcode 29
3．2　编译调试 29
3．3　版本管理 31
3．3．1　代码管理 31
3．3．2　Git分支管理 32
3．4　产品设计 34
3．5　程序员珍藏 35
3．5．1　抓包工具 36
3．5．2　ADB 36
3．5．3　Chrome开发插件 37
3．6　本章小结 38
3．7　推荐资料 38
第4章　App SDK使用系列 39
4．1　从Lifecycle说起 39
4．2　大话UI 41
4．2．1　关于布局 41
4．2．2　常用控件 41
4．2．3　自定义View 42
4．3　存储和网络 43
4．4　本章小结 43
4．5　推荐资料 44
第5章　开源库的选择和使用 45
5．1　关于开源 46
5．2　开源库的选择 46
5．2．1　开源项目选择 46
5．2．2　关于License 47
5．3　开源库的使用 48
5．4　本章小结 49
5．5　推荐资料 49
* 二篇　核　心　篇
第6章　App常用模块设计 52
6．1　基础组件库 52
6．1．1　构建你的基础组件库 53
6．1．2　不得不说的图片库 54
6．1．3　浅谈网络库和加密 61
6．2　常用业务模块 65
6．2．1　启动引导模块 65
6．2．2　注册登录模块 66
6．2．3　运营统计模块 67
6．3　编译打包 68
6．3．1　打包方式和流程 68
6．3．2　Gradle实用技巧 71
6．4　版本适配 75
6．4．1　iOS App适配 76
6．4．2　Android App适配 77
6．5　本章小结 78
第7章　App架构和重构 79
7．1　从组件和模块说起 80
7．2　组件化、模块化和插件化 80
7．2．1　三个概念 80
7．2．2　App插件化 82
7．2．3　App组件化 83
7．3　UML基本功 86
7．3．1　UML工具 86
7．3．2　常见UML图 87
7．3．3　UML实例 88
7．4　大话设计模式 88
7．4．1　六大原则 89
7．4．2　设计模式总览 89
7．4．3　设计模式实践 90
7．5　接口设计 91
7．5．1　API，What and Why 92
7．5．2　How API 92
7．6　常见架构模式 95
7．6．1　MVX模式 95
7．6．2　常见软件架构 97
7．6．3　从组件化角度看App架构 100
7．7　重构未眠夜 102
7．7．1　重构概览 102
7．7．2　架构重构 103
7．7．3　代码重构 104
7．8　架构设计够了么 106
7．9　本章小结 106
7．10　推荐资料 106
第8章　App质量和稳定性系列 108
8．1　质量标准和稳定性指标 109
8．1．1　应用的核心质量 109
8．1．2　稳定性衡量指标 109
8．2　质量和稳定性手段 112
8．2．1　质量监控 112
8．2．2　问题处理原则 115
8．2．3　App持续集成 115
8．2．4　代码质量监测 125
8．3　笑谈Crash 138
8．3．1　Crash基础和原理 138
8．3．2　Crash收集和统计 142
8．3．3　Crash分析 150
8．4　测试专场 160
8．4．1　测试综述 161
8．4．2　兼容性测试 165
8．4．3　性能和安全性测试 174
8．4．4　自动化测试 174
8．4．5　A/B Testing 180
8．4．6　代码覆盖率 182
8．4．7　线上演练 183
8．5　本章小结 183
8．6　推荐资料 183
第9章　App性能优化系列 185
9．1　性能分析 186
9．1．1　性能维度 186
9．1．2　性能优化 186
9．1．3　性能测试平台 187
9．2　硬件性能优化 187
9．2．1　电量信息获取 188
9．2．2　耗电分析 190
9．2．3　电量优化 191
9．3　UI和CPU性能优化 194
9．3．1　基础原理 194
9．3．2　流畅度度量 196
9．3．3　卡顿分析和优化 201
9．4　内存性能优化 206
9．4．1　内存机制和原理 206
9．4．2　内存分析工具 210
9．4．3　泄露和溢出 210
9．4．4　内存性能优化 212
9．5　网络性能优化 215
9．5．1　网络性能概述 216
9．5．2　网络性能测试和流量度量 218
9．5．3　网络性能优化 220
9．6　App包Size优化 223
9．6．1　App包Size优化概述 223
9．6．2　App包Size分析 224
9．6．3　App包Size优化 227
9．7　App启动速度优化 230
9．7．1　App启动方式和流程 230
9．7．2　App启动时间度量 232
9．7．3　App启动速度优化 234
9．8　App代码优化 235
9．9　本章小结 240
9．10　推荐资料 240
* 10章　App安全逆向系列 242
10．1　逆向概述 242
10．1．1　App包组成 243
10．1．2　逆向工具 245
10．1．3　Root和越狱 247
10．1．4　二次打包 247
10．2　逆向分析 248
10．2．1　静态分析 248
10．2．2　动态分析 249
10．2．3　Hook和注入 249
10．3　安全测试 251
10．4　安全建议 252
10．4．1　混淆和签名 253
10．4．2　加固加壳 262
10．4．3　安全编码和隐私 263
10．5　本章小结 265
10．6　推荐资料 265
* 11章　App热门技术 267
11．1　进程保活 267
11．1．1　基础知识 268
11．1．2　保活方法 271
11．2　MultiDex 271
11．3　RxJava 273
11．3．1　RxJava基础 273
11．3．2　RxJava应用实例 276
11．4　Hybrid 281
11．5　HotFix 282
11．6　AOP 283
11．6．1　OOP与AOP 283
11．6．2　AOP应用实例 283
11．7　本章小结 286
11．8　推荐资料 286
第三篇　产　品　篇
* 12章　App是如何练成的 290
12．1　App练成 290
12．2　开发流程 291
12．3　也谈版本号 292
12．4　本章小结 293
* 13章　项、产、设、运“四天* ” 294
13．1　项目管理 294
13．1．1　敏捷Scrum 295
13．1．2　班车模式 298
13．2　产品思想 298
13．2．1　产品经理 299
13．2．2　产品思维 299
13．3　设计理念 302
13．3．1　UI与UX 302
13．3．2　设计理念 304
13．4　推广运营 306
13．4．1　运营指标 306
13．4．2　大话推广 309
13．4．3　运营之道 310
13．5　本章小结 310
13．6　推荐资料 310
* 14章　我的高效团队 312
14．1　从代码规范开始 312
14．2　不得不说的Code Review 313
14．3　晨会，高效一 天的开始 315
14．4　沟通和团建 315
14．5　别忘了技术分享 316
14．6　面试，面试，再面试 317
14．7　自管理，扁平化 318
14．8　* 后，聊聊加班 319
14．9　本章小结 319
14．10　推荐资料 319
第四篇　拓　展　篇
* 15章　架构师那点事 322
15．1　大话全栈工程师 322
15．2　架构师思维 323
15．3　学而时习之 324
15．4　软技能 325
15．5　本章小结 326
15．6　推荐资料 326
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>App架构师实践指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入分析Java Web技术内幕（修订版）
第1章  深入Web请求过程	1
1.1  B/S网络架构概述	2
1.2  如何发起一个请求	4
1.3  HTTP解析	6
1.3.1  查看HTTP信息的工具	8
1.3.2  浏览器缓存机制	9
1.4  DNS域名解析	12
1.4.1  DNS域名解析过程	12
1.4.2  跟踪域名解析过程	15
1.4.3  清除缓存的域名	18
1.4.4  几种域名解析方式	19
1.5  CDN工作机制	20
1.5.1  CDN架构	20
1.5.2  负载均衡	21
1.5.3  CDN动态加速	24
1.6  总结	25
第2章  深入分析Java I/O的工作机制	26
2.1  Java的I/O类库的基本架构	26
2.1.1  基于字节的I/O操作接口	27
2.1.2  基于字符的I/O操作接口	28
2.1.3  字节与字符的转化接口	29
2.2  磁盘I/O工作机制	30
2.2.1  几种访问文件的方式	30
2.2.2  Java访问磁盘文件	34
2.2.3  Java序列化技术	35
2.3  网络I/O工作机制	37
2.3.1  TCP状态转化	38
2.3.2  影响网络传输的因素	40
2.3.3  Java Socket的工作机制	40
2.3.4  建立通信链路	41
2.3.5  数据传输	42
2.4  NIO的工作方式	42
2.4.1  BIO带来的挑战	42
2.4.2  NIO的工作机制	43
2.4.3  Buffer的工作方式	46
2.4.4  NIO的数据访问方式	48
2.5  I/O调优	50
2.5.1  磁盘I/O优化	50
2.5.2  TCP网络参数调优	51
2.5.3  网络I/O优化	53
2.6  设计模式解析之适配器模式	57
2.6.1  适配器模式的结构	57
2.6.2  Java I/O中的适配器模式	58
2.7  设计模式解析之装饰器模式	58
2.7.1  装饰器模式的结构	59
2.7.2  Java I/O中的装饰器模式	59
2.8  适配器模式与装饰器模式的区别	60
2.9  总结	60
第3章  深入分析Java Web中的中文编码问题	61
3.1  几种常见的编码格式	61
3.1.1  为什么要编码	61
3.1.2  如何“翻译”	62
3.2  在Java中需要编码的场景	64
3.2.1  在I/O操作中存在的编码	64
3.2.2  在内存操作中的编码	66
3.3  在Java中如何编解码	67
3.3.1  按照ISO-8859-1编码	69
3.3.2  按照GB2312编码	70
3.3.3  按照GBK编码	71
3.3.4  按照UTF-16编码	71
3.3.5  按照UTF-8编码	72
3.3.6  UTF-8编码代码片段	72
3.3.7  对几种编码格式的比较	74
3.4  在Java Web中涉及的编解码	74
3.4.1  URL的编解码	76
3.4.2  HTTP Header的编解码	79
3.4.3  POST表单的编解码	79
3.4.4  HTTP BODY的编解码	80
3.5  在JS中的编码问题	81
3.5.1  外部引入JS文件	81
3.5.2  JS的URL编码	82
3.5.3  其他需要编码的地方	84
3.6  常见问题分析	84
3.6.1  中文变成了看不懂的字符	84
3.6.2  一个汉字变成一个问号	85
3.6.3  一个汉字变成两个问号	85
3.6.4  一种不正常的正确编码	86
3.7  一种繁简转换的实现方式	87
3.8  总结	88
第4章  Javac编译原理	89
4.1  Javac是什么	90
4.2  Javac编译器的基本结构	90
4.3  Javac工作原理分析	92
4.3.1  词法分析器	93
4.3.2  语法分析器	100
4.3.3  语义分析器	105
4.3.4  代码生成器	115
4.4  设计模式解析之访问者模式	118
4.4.1  访问者模式的结构	119
4.4.2  Javac中访问者模式的实现	120
4.5  总结	121
第5章  深入class文件结构	122
5.1  JVM指令集简介	122
5.1.1  与类相关的指令	124
5.1.2  方法的定义	125
5.1.3  属性的定义	126
5.1.4  其他指令集	127
5.2  class文件头的表示形式	135
5.3  常量池	139
5.3.1  UTF8常量类型	142
5.3.2  Fieldref、Methodref常量类型	143
5.3.3  Class常量类型	143
5.3.4  NameAndType常量类型	144
5.4  类信息	144
5.5  Fields和Methods定义	145
5.6  类属性描述	149
5.7  Javap生成的class文件结构	150
5.7.1  LineNumberTable	152
5.7.2  LocalVariableTable	153
5.8  总结	155
第6章  深入分析ClassLoader工作机制	156
6.1  ClassLoader类结构分析	157
6.2  ClassLoader的等级加载机制	158
6.3  如何加载class文件	161
6.3.1  加载字节码到内存	161
6.3.2  验证与解析	163
6.3.3  初始化Class对象	163
6.4  常见加载类错误分析	163
6.4.1  ClassNotFoundException	163
6.4.2  NoClassDefFoundError	164
6.4.3  UnsatisfiedLinkError	165
6.4.4  ClassCastException	166
6.4.5  ExceptionInInitializerError	167
6.5  常用的ClassLoader分析	168
6.6  如何实现自己的ClassLoader	172
6.6.1  加载自定义路径下的class文件	172
6.6.2  加载自定义格式的class文件	174
6.7  实现类的热部署	176
6.8  Java应不应该动态加载类	178
6.9  总结	179
第7章  JVM体系结构与工作方式	180
7.1  JVM体系结构	180
7.1.1  何谓JVM	180
7.1.2  JVM体系结构详解	183
7.2  JVM工作机制	185
7.2.1  机器如何执行代码	185
7.2.2  JVM为何选择基于栈的架构	186
7.2.3  执行引擎的架构设计	187
7.2.4  执行引擎的执行过程	188
7.2.5  JVM方法调用栈	193
7.3  总结	197
第8章  JVM内存管理	198
8.1  物理内存与虚拟内存	199
8.2  内核空间与用户空间	200
8.3  在Java中哪些组件需要使用内存	201
8.3.1  Java堆	201
8.3.2  线程	201
8.3.3  类和类加载器	202
8.3.4  NIO	202
8.3.5  JNI	203
8.4  JVM内存结构	203
8.4.1  PC寄存器	204
8.4.2  Java栈	204
8.4.3  堆	205
8.4.4  方法区	205
8.4.5  运行时常量池	206
8.4.6  本地方法栈	206
8.5  JVM内存分配策略	206
8.5.1  通常的内存分配策略	207
8.5.2  Java中的内存分配详解	207
8.6  JVM内存回收策略	212
8.6.1  静态内存分配和回收	212
8.6.2  动态内存分配和回收	213
8.6.3  如何检测垃圾	213
8.6.4  基于分代的垃圾收集算法	215
8.7  内存问题分析	224
8.7.1  GC日志分析	224
8.7.2  堆快照文件分析	227
8.7.3  JVM Crash日志分析	227
8.8  实例1	233
8.9  实例2	235
8.10  实例3	237
8.11  总结	242
第9章  Servlet工作原理解析	243
9.1  从Servlet容器说起	243
9.1.1  Servlet容器的启动过程	244
9.1.2  Web应用的初始化工作	247
9.2  创建Servlet实例	249
9.2.1  创建Servlet对象	250
9.2.2  初始化Servlet	250
9.3  Servlet体系结构	252
9.4  Servlet如何工作	255
9.5  Servlet中的Listener	257
9.6  Filter如何工作	259
9.7  Servlet中的url-pattern	261
9.8  总结	262
第10章  深入理解Session与Cookie	263
10.1  理解Cookie	264
10.1.1  Cookie属性项	264
10.1.2  Cookie如何工作	265
10.1.3  使用Cookie的限制	268
10.2  理解Session	269
10.2.1  Session与Cookie	269
10.2.2  Session如何工作	270
10.3  Cookie安全问题	273
10.4  分布式Session框架	274
10.4.1  存在哪些问题	274
10.4.2  可以解决哪些问题	275
10.4.3  总体实现思路	275
10.5  Cookie压缩	280
10.6  表单重复提交问题	282
10.7  多终端Session统一	283
10.8  总结	285
第11章  Tomcat的系统架构与设计模式	286
11.1  Tomcat总体设计	286
11.1.1  Tomcat总体结构	287
11.1.2  Connector组件	293
11.1.3  Servlet容器Container	298
11.1.4  Tomcat中的其他组件	309
11.2  Tomcat中的设计模式	309
11.2.1  门面设计模式	309
11.2.2  观察者设计模式	311
11.2.3  命令设计模式	313
11.2.4  责任链设计模式	314
11.3  总结	316
第12章  Jetty的工作原理解析	317
12.1  Jetty的基本架构	317
12.1.1  Jetty基本架构简介	317
12.1.2  Handler的体系结构	319
12.2  Jetty的启动过程	320
12.3  接受请求	321
12.3.1  基于HTTP工作	321
12.3.2  基于AJP工作	323
12.3.3  基于NIO方式工作	326
12.4  处理请求	327
12.5  与JBoss集成	330
12.6  与Tomcat的比较	331
12.6.1  架构比较	331
12.6.2  性能比较	332
12.6.3  特性比较	332
12.7  总结	333
第13章  Spring框架的设计理念与设计模式分析	334
13.1  Spring的骨骼架构	334
13.1.1  Spring的设计理念	335
13.1.2  核心组件如何协同工作	336
13.2  核心组件详解	337
13.2.1  Bean组件	337
13.2.2  Context组件	339
13.2.3  Core组件	340
13.2.4  Ioc容器如何工作	342
13.3  Spring中AOP的特性详解	352
13.3.1  动态代理的实现原理	352
13.3.2  Spring AOP如何实现	355
13.4  设计模式解析之代理模式	358
13.4.1  代理模式原理	358
13.4.2  Spring中代理模式的实现	358
13.5  设计模式解析之策略模式	361
13.5.1  策略模式原理	361
13.5.2  Spring中策略模式的实现	362
13.6  总结	362
第14章  Spring MVC的工作机制与设计模式	364
14.1  Spring MVC的总体设计	364
14.2  Control设计	369
14.2.1  HandlerMapping初始化	370
14.2.2  HandlerAdapter初始化	372
14.2.3  Control的调用逻辑	373
14.3  Model设计	374
14.4  View设计	375
14.5  框架设计的思考	377
14.5.1  为什么需要框架	377
14.5.2  需要什么样的框架	377
14.5.3  框架设计原则	378
14.5.4 “指航灯”	378
14.5.5  最基本的原则	378
14.6  设计模式解析之模板模式	379
14.6.1  模板模式的结构	379
14.6.2  Spring MVC中的模板模式示例	379
14.7  总结	380
第15章  深入分析iBatis框架之系统架构与映射原理	381
15.1  iBatis框架主要的类层次结构	381
15.2  iBatis框架的设计策略	382
15.3  iBatis框架的运行原理	384
15.4  示例	386
15.5  iBatis对SQL语句的解析	388
15.6  数据库字段映射到Java对象	389
15.7  示例运行的结果	391
15.8  设计模式解析之简单工厂模式	391
15.8.1  简单工厂模式的实现原理	391
15.8.2  iBatis中的简单工厂模式示例	392
15.9  设计模式解析之工厂模式	393
15.9.1  工厂模式的实现原理	393
15.9.2  iBatis中的工厂模式示例	394
15.10  总结	395
第16章  Velocity工作原理解析	397
16.1  Velocity总体架构	398
16.2  JJTree渲染过程解析	401
16.2.1  #set语法	405
16.2.2  Velocity的方法调用	406
16.2.3  #if、#elseif和#else语法	409
16.2.4  #foreach语法	410
16.2.5  #parse语法	412
16.3  事件处理机制	413
16.4  常用优化技巧	416
16.4.1  减少树的总节点数量	416
16.4.2  减少渲染耗时的节点数量	416
16.5  与JSP比较	417
16.5.1  JSP渲染机制	417
16.5.2  Velocity与JSP	423
16.6  设计模式解析之合成模式	423
16.6.1  合成模式的结构	423
16.6.2  Velocity中合成模式的实现	424
16.7  设计模式解析之解释器模式	425
16.7.1  解释器模式的结构	425
16.7.2  Velocity中解释器模式的实现	426
16.8  总结	426
第17章  Velocity优化实践	427
17.1  现实存在的问题	427
17.2  优化的理论基础	428
17.2.1  程序语言的三角形结构	428
17.2.2  数据结构减少抽象化	429
17.2.3  简单的程序复杂化	429
17.2.4  减少翻译的代价	430
17.2.5  变的转化为不变的	430
17.3  一个高效的模板引擎实现思路	430
17.3.1  vm模板如何被编译	432
17.3.2  方法调用的无反射优化	439
17.3.3  将字符输出改成字节输出	442
17.4  优化的成果	443
17.4.1  将char转成byte	443
17.4.2  无反射执行	444
17.5  其他优化手段	445
17.6  总结	445
第18章  大浏览量系统的静态化架构设计	446
18.1  淘宝大浏览量商品详情系统简介	446
18.2  系统面临哪些挑战	447
18.3  淘宝前台系统的优化历程	449
18.4  大浏览量系统的静态改造	449
18.4.1  什么是静态化系统	449
18.4.2  为什么要进行静态化架构设计	450
18.4.3  如何改造动态系统	451
18.4.4  几种静态化方案的设计及选择	453
18.4.5  如何解决失效问题	458
18.4.6  服务端静态化方案的演进：CDN化	459
18.5  总结	462
参考资料	463
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入分析Java Web技术内幕（修订版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>RFID与传感器网络
译者序
原书前言
第1部分RFID
第1章　RIFID的媒体访问控制协议
1.1概述
1.2 RFID系统MAC协议的预备知识
1.3标签碰撞
1.3.1确定性的防碰撞机制
1.3.2概率性的防碰撞机制
1.3.3讨论
1.4阅读器碰撞
1.5前景展望
参考文献
第2章　RFID的防碰撞算法
2.1概述
2.2 RFID系统的阅读器碰撞问题
2.3阅读器防碰撞协议
2.3.1’FDMA协议
2.3.1.1 DCS算法
2.3.1.2 Colorwave算法
2.3.2 FDMA协议
2.3.2.1 HiQ协议
2.3.2.2 EPCglobal Gen 2协议
2.3.3 CSMA协议
2.4标签防碰撞协议
2.4.1基于ALOHA的协议
2.4.1.1ALOHA协议
2.4.1.2时隙ALOHA协议
2.4.1.3帧时隙ALOHA协议
2.4.1.4 ISO／IEC 18000-6A协议
2.4.2基于树的协议
2.4.2.1查询树协议
2.4.2.2逐位二进制树协议
2.4.2.3 EPCglobal Class 0
2.4.2.4 TSA协议
2.4.2.5 BSQTA和BSCTTA协议
2.4.2.6 AQS协议
2.4.3基于计数器的协议
2.4.3.1 ISO／IEC 18000-6B协议
2.4.3.2.ABS协议
2.5结论
2.5.1阅读器防碰撞协议的总结和新的研究方向
2.5.2标签防碰撞协议的总结与新的研究方向
参考文献
第3章　用于RFID的低功耗转发器
3.1概述
3.2关于最新的RFID实现的调查
3.3 RFID系统需求
3.3.1电磁传播基础和标签能量消耗
3.3.2制造过程
3.3.3空中接口标准
3.4模拟前端和天线设计讨论
3.4.1天线特性
3.4.2射频整流器
3.4.3电压升压器
3.4.4设备安全保护
3.4.5电压校准
3.4.6 ASK解调器
3.4.7时钟发生器
3.4.8反向散射发送器
3.5数字基带处理器
3.5.1低功耗标准单元设计
3.5.2基带处理器创建模块
3.5.2.1：ISO 18000-6B协议实现的方案
3.5.2.2：ISO 18000-6C实现的方案
3.5.3集成感知设备
3.6开放性问题
3.7结论
参考文献
第4章　RFID的EPC Gen-2标准
4.1概述
4.1.1 EPC Gen-2背景
4.1.1.1 Gen-2标准的目标和需求
4.1.1.2 EPC编码系统的目标和需要
4.1.2 Gen-2通常使用的特性的概述
4.2物理层通信特性
4.2.1数据速率
4.2.2调制类型
4.2.3数据编码
4.2.4信息报头
4.2.4.1阅读器向标签的报头
4.2.4.2标签向阅读器的报头
4.3标签的状态机
4.3.1不同标签状态的概述
4.3.1.1准备状态
4.3.1.2仲裁状态
4.3.1.3回复状态
4.3.1.4确认状态
4.3.1.5开放状态
4.3.1.6安全状态
4.3.1.7死亡状态
4.3.2查询过程期间通过有限状态机移动的概述
4.3.3在一个访问命令期间，通过标签状态机移动的概述
4.4标签查询特性
4.4.1查询命令概述
4.4.1.1查询
4.4.1.2查询重复
4.4.1.3查询调节命令
4.4.1.4选择
4.4.2会话的使用
4.4.3选择命令的特性
4.4.4查询命令的特性
4.4.5查询重复命令的特性
4.4.6查询调节命令的特性
4.5标签单一化
4.5.1 EPC Gen-2标签数据编码分类
4.5.2选择单个标签
4.5.3选择一组标签
4.5.4选择全部的标签
4.6权衡
4.6.1查询货盘上包含一种类型产品的标签
4.6.2访问货盘上包含一种类型产品的标签
4.6.3查询货盘上包含一个单一生产商多种类型的产品的标签
4.6.4访问货盘上包含单一生产商多个产品类型的标签
4.6.5查询货盘上包含多个生产商的多个类型产品的标签
4.6.6访问一个货盘包含的多个生产商的多个类型产品的标签
4.7开放问题
4.8结论和未来研究方向
参考文献
第5章　RFID的认证和隐私
5.1概述
5.2重要的RFID认证和隐私协议
5.2.1标签死亡协议
5.2.2密码协议
5.3 RFID隐私保护设备
5.3.1法拉第笼
5.3.2有源干扰设备
5.3.3拦截器标签
5.4基于hash函数的RFID协议
5.4.1 hash锁：原始的基于hash函数的方法
5.4.2基于树的方法
5.4.3 hash树：一种动态的密钥更新方法
5.5其他的RFID认证和隐私保护协议
5.5.1极简的加密
5.5.2 RFID保护：为被动RFID标签设计的认证和隐私保护协议
5.6结。论
参考文献
第6章　 RFID的安全问题
6.1概述
6.2基本定义和参考场景
6.3领域的当前状态
6.3.1原始密码问题概述
6.3.2密码协议问题概述
6.3.3 RFID安全的一些重要的密码协议
6.3.4测量密码图协议的轻量级特性
6.4新的非确定性加密图协议
6.4.1第一个非确定性协议
6.4.2第二个非确定性协议
6.4.3非确定性协议的简要分析
6.5 RFlD安全的开放性问题
6.5.1 RFID系统的物理安全
6.5.2原始密码和加密协议
6.5.3后台系统
6.5.4法律问题
6.5.5一般的RFID安全问题
6.6结论
参考文献
第7章　RFID的部署：供应链案例研究
7.1概述
7.2第一阶段：商业环境
7.2.1商业环境：激励环境
7.2.1.1检查决策行为
7.2.1.2工作案例研究：全国性的供应链
7.2.2商业环境：商业案例
7.2.2.1工作案例研究：全国性供应链
7.2.3商业环境：阶段的过渡动机
7.2.3.1工作案例研究：全国性供应链
7.3第二阶段：基础设施环境：制造商到零售商
7.3.1使用案例环境
7.3.1.1使用案例
7.3.1.2现场评估
7.3.1.3使用案例环境：步骤转换动机
7.3.2 RFID设备环境
7.3.2.1标准设备
7.3.2.2阅读器配置
7.3.2.3 RFID设备：步骤转换动机
7.3.3设计环境
7.3.3.1设计
7.3.3.2文档
7.3.3.3设计：步骤转换动机
7.3.4基础设施环境：阶段转换动机
7.3.4.1工作案例研究：全国性的供应链
7.4第三阶段：部署环境：工厂到陈列室
7.4.1原型测试环境
7.4.1.1使用案例
7.4.1.2原型测试环境：步骤转换动机
7.4.2试验环境
7.4.2.1使用案例
7.4.2.2试验环境：步骤转换动机
7.4.3部署环境：阶段转换动机
7.4.3.1工作案例研究：全国性的供应链
7.5结论
参考文献
第2部分WSN
第8章　无线传感器网络中的地理位置路由
8.1介绍
8.2地理位置路由的原理
8.2.1简介
8.2.2地理位置路由操作
8.3地理位置单播路由
8.3.1贪心方案
8.3.2周边方案
8.3.3处理真实情景
8.4地理位置多播路由
8.4.1从单播到多播
8.4.2多播贪心路由
8.4.3多播周边路由
8.5信标减地理位置路由
8.5.1动机
8.5.2非协作方式
8.5.3协作的方式
8.5.4处理空洞
8.5.5处理实际场景
8.6总结和讨论
参考文献
第9章　无线传感器网络中的媒体访问控制协议
9.1简介
9.2无线传感器网络
9.2.1无线传感器网络特性
9.2.2传感器节点的功耗
9.2.3通信模式
9.3无线MAC协议的概念和基本原理
9.3.1无线MAC协议的需求和设计条件
9.3.2无线MAC协议的分类
9.4无线传感器网络的介质访问
9.4.1在无线传感器网络中的能源资源消耗
9.4.2无线传感器MAC设计需求和权衡
9.5无线传感器网络MAC协议的分类
9.5.1非预定的MAC协议
9.5.1.1多通道的MAC协议
9.5.1.2面向应用的MAC协议
9.5.1.3多路径数据传输MAC协议
9.5.1.4基于汇合的MAC协议
9.5.1.5基于前同步码的MAC协议
9.5.2预定的MAC协议
9.5.2.1基于竞争的分时隙MAC协议
9.5.2.2基于时分的MAC协议
9.5.2.3基于预定的MAC协议
9.5.2.4基于优先权的MAC协议
9.5.3混合MAC协议
9.5.3.1基于前置的混合MAC协议
9.5.3.2基于预定的混合协议
9.5.3.3传输敏感协议
9.5.3.4基于簇的MAC协议
9.5.4特定服务质量的MAC协议
9.5.4.1传感器网络的QoS控制
9.5.4.2无线传感器网络协议的一种能量高效的QoS保证MAC协议
9.5.5跨层的MAC协议
9.5.5.1MAC+PHY
9.5.5.2 MAC+网络
9.5.5.3网络+PHY
9.5.5.4传输+PHY
9.5.5.5三层解决方案
9.6IEEE802.15.4／ZigBee MAC协议
9.6.1 IEEE 802.15.4／ZigBee协议栈架构
9.6.2 ZigBee网络架构
9.6.3超帧结构
9.6.4数据传输
9.6.5蓝牙
9.7开放的研究方向
9.8结论。
参考文献
第10章　无线传感器网络的定位技术
10.1概述
10.2理论基础
10.2.1距离测量
10.2.2三边测量
10.2.3三角测量
10.2.4网络定位理论：定位和固定理论
10.3基于距离的定位方法
10.3.1单跳锚方法
10.3.2多跳锚方法
10.3.2.1迭代和协作多点监视
10.3.2.2扫描法
10.3.2.3多维排列
10.3.3移动锚应用法
10.3.4无锚节点法
10.4无须测距的定位方法
10.4.1基于跳数的方法
10.4.1.1基于距离向量的定位
10.4.1.2其他改进
10.4.2基于区域的方法
10.5总结
参考文献
第1l章　无线传感器网络中的数据聚合技术
11.1概述
11.2无线传感器网络概述
11.3数据聚合
11.3.1基于树的数据聚合协议
11.3.2基于分簇的数据聚合协议
11.3.3基于多路径的数据聚合协议
11.4安全的数据聚合
11.4.1在普通的数据上的安全数据聚合
11.4.2对加密数据的安全数据聚合
11.5开发性的研究问题和未来研究方向
11.6总结
参考文献
第12章　无线传感器网络中的分簇技术
12.1概述_，
12.1.1无线传感器网络中分簇设计的主要目的和挑战
12.2分簇算法分类
12.2.1分簇参数
12.2.2分类簇集协议
12.3概率分簇方法
12.3.1广泛的概率分簇协议
12.3.1.1低能量的自适应分簇层次
12.3.1.2节能高效的层次分簇
12.3.1.3混合节能高效的分布式簇集
12.3.2扩展和其他类似的方法
12.4非概率的分簇方法
12.4.1邻近节点和基于图的分簇协议
12.4.2基于权的簇协议
12.4.3生物激活分簇方法
12.5反应网络的分簇算法
12.6结论
参考文献
第13章　无线传感器网络中能量有效的感知行为
13.1概述
13.2节能模式回顾
13.2.1硬件能量管理
13.2.1.1动态电压缩放比
13.2.1.2能量资源管理
13.2.2能量有效的无线通信
13.2.2.1基于竞争的MAC
13.2.2.2基于TDMA的MAC
13.2.3能量有效的感知
13.2.3.1自适应的感知负载周期
13.2.3.2协调／合作感知
13.3交替感知模式
13.4性能分析
13.5网络充分覆盖范围
13.5.1理论结果
13.5.2模拟结果
13.6尚未解决的问题和争议
13.7总结和对未来工作的展望
参考文献
第14章　无线传感器网络的移动性
14.1概述
14.2传感器移动性
14.2.1非受控移动性
14.2.2受控移动
14.2.3移动控制策略
14.3 Sink节点的移动
14.3.1为什么要移动Sink节点
14.3.1.1稀疏网络的数据聚集
14.3.1.2负载均衡
14.3.1.3缩短通信路径
14.3.2随机移动
14.3.3可预知移动
14.3.4受控移动
14.3.5自适应移动
14.4虚拟移动
14.5传感器或者Sink节点移动的结果
14.5.1对于节点移动的MAC层解决方案
14.5.2路由和移动性
14.6开放性问题
14.7结论
参考文献
第15章　无线传感器网络安全技术
15.1概述
15.1.1安全目标
15.1.2挑战
15.1.3密钥管理
15.1.4安全路由
15.2预备知识
15.2.1椭圆曲线
15.2.2椭圆曲线群和分离对数问题
15.2.3双线性配对
15.2.4 Diffie-Hellman问题
15.3攻击类型
15.3.1被动攻击
15.3.2主动攻击
15.3.3拒绝服务攻击
15.3.4虫孔攻击
15.3.5洪泛攻击
15.3.6伪装攻击
15.3.7重放攻击
15.3.8信息操纵攻击
15.3.9延迟攻击
15.3.10 Sybil攻击
15.4反抗手段
15.4.1密钥建立和管理
15.4.1.1单一广阔网络密钥、对偶密钥建立、受信任基站和认证
15.4.1.2公钥模式
15.4.1.3路由驱动椭圆曲线基于加密的密钥管理模式
15.4.1.4基于身份和配对的安全的密钥管理模式
15.4.2匿名通信
15.4.2.1分层的匿名通信协议
15.4.2.2在匿名传感器网络中寻找路由
15.4.3入侵检测
15.4.3.1使用情感蚂蚁的传感器网络上的入侵检测
15.4.3.2在无线传感器网络中应用入侵检测系统
15.5总结一
参考文献
第16章　无线传感器网络中的网络管理技术
16.1概述
16.2 wSN管理的设计目标
16.2.1可扩展性
16.2.2有限的能量消耗
16.2.3内存和处理限制
16.2.4有限的带宽消耗
16.2.5网络动态适应性
16.2.6容错性
16.2.7网络应答
16.2.8设备代价
16.3管理规模
16.3.1管理功能
16.3.1.1自管理
16.3.1.2自配置
16.3.1.3自愈
16.3.1.4自计费
16.3.1.5自安全
16.3.1.6自优化
16.3.2管理层
16.3.2.1任务层
16.3.2.2服务
16.3.2.3网络
16.3.2.4网络元素管理
16.3.2.5元素层管理
16.4设计管理结构的其他方案
16.4.1基于策略的方法
16.4.2代表管理
16.4.3分布式管理
16.4.4层次管理
16.4.5基于分层的管理
16.4.6移动或者智能的基于代理的方法
16.5已有的研究成果
16.5.1MANNA
16.5.1.1 MANNA的WSN功能的方面
16.5.2 BOSSj：
16.5.3SNMS
16.5.4移动基于代理的管理策略
16.6作为一个整合技术的IP-USN
16.6.1IP-USN NMS的目标
16.6.2.LNMP作为一个例子结构
16.7网络管理作为FCAPS模型：一个新视角
16.7.1以用户为中心
16.7.2群形成
16.7.3源.Sink节点仲裁
16.7.4路由最高级
16.7.5设备移动性
16.8结论
参考文献
第17章　无线传感器网络中的部署
17.1概述
17.2事件监测模型
17.2.1比特模型
17.2.2概率监测模型
17.2.3跟踪监测模型
17.3部署标准
17.3.1部署传感器的数量
17.3.2覆盖和k-覆盖
17.3.3连通性
17.3.4检测概率
17.3.5网络生命周期
17.4传感器网络部署策略
17.4.1问题定义
17.4.2均匀部署策略
17.4.2.1均匀随机部署
17.4.2.2规则部署
17.4.3非均匀部署策略
17.4.3.1最佳解决方案
17.4.3.2基于分布的随机的部署
17.4.3.3 Max-Avg-Coverage
17.4.3.4 Max-Min-Coverage
17.4.3.5 Min-Miss
17.4.3.6 Diff-Deploy
17.4.3.7 Mesh
17.4.3.8分化的基于禁忌(Tabu)搜索方法的传感器部署
17.4.4部署策略对比
17.5结论和开放性的问题
参考文献
第3部分 RFID与WSN集成
第18章　 RFID)与无线传感器网络在架构和应用上的集成
18.1概述
18.2集成RFID和WSN的原因
18.3集成RFID网络和传感器网络的要求
18.4 RFID和WSN一体化构架
18.4.1集成RFID标签与传感器
18.4.1.1通信能力受限的集成传感器标签
18.4.1.2集成扩展通信能力的传感器标签
18.4.2集成无线传感器节点的RFID读卡器
18.4.3混合结构
18.5各种集成RFID和WSN的应用方案
18.5.1医疗应用
18.5.2供应链管理中集成REID和传感器网络
18.5.3其他应用
18.6结论和开放性问题
参考文献
第19章　应用于智能家居系统的RFID与无线传感器网络的集成
19.1概述
19.2我们的家居智能环境
19.2.1目标
19.2.2现实需求和实验室限制
19.3通用系统构架
19.4实施
19.4.1无线传感器网络
19.4.2移动机器人
19.4.3射频识别
19.4.4网关/手机
19.5实例
19.6实施体验
19.7结论
参考文献
第20章　应用于卫生保健系统的RFID与无线传感器网络的集成
20.1概述
20.2智能医院使用RFID和传感器网络的调查建议
20.2.1医院人员流动供应和需求管理分析
20.2.2追踪重要的和非常敏感的医疗／生活供应
20.2.3建立一个普适感知医院
20.3医院外卫生保健使用RFID和传感器网络的调查建议
20.3.1移动遥测服务
20.3.2无线健康监测系统
20.3.3家庭老年人卫生保健的原型
20.4卫生保健的传感器网络和RFID发展平台¨
20.4.1介绍
20.4.2编程抽象及相关中间件项目
20.4.2.1编程抽象
20.4.2.2 中间件
20.4.2.3 JADE
20.4.3应用程序开发平台
20.4.3.1准备工作和数据结构
20.4.3.2应用发展进程
20.4.3.3能量管理
20.4.4原型实现
20.4.4.1核心模块：登记和监测
20.4.4.2图形用户界面(GUI)应用程序开发
20.4.4.3实验环境
20.4.4.4应用例子
20.4.5摘要
20.5结论
参考文献
第21章　应用于建筑物结构监测的RFID与传感器网络的集成
21.1概述
21.2电阻基传感器背景
21.3电阻应变计
21.4信号调节电阻应变计
21.5大应变二进制输出电阻基传感器
21.6数据获取和通信
21.6.1无源REID设计
21.6.2节点的设计
21.7控制软件
21.7.1安装和配置传感器
21.7.2实验配置
21.7.3数据记录和显示
21.8 CRM计功能测试
21.8.1测试结果
21.9大规模部署CRM计
21.10结论
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>RFID与传感器网络
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件是这样“炼”成的
引言
第1篇 软件需求开发
第1章 需求分析报告评审
第2章 关于需求开发的讨论
2.1 关于需求开发的讨论
2.2 本篇组织
2.3 阅读导读
第3章 UML介绍
3.1 面向对象介绍
3.2 面向对象设计过程与设计准则
3.3 UML介绍
3.4 UML图
3.5 UML关系
3.6 UML机制
第4章 Rational Rose 2003
4.1 Rational Rose 2003简介
4.2 Rational Rose 2003主要作用
4.3 Rational Rose 2003下载和安装
4.4 Rational Rose 2003主界面介绍
4.5 小结
第5章 业务调研及报告编写
5.1 关于业务调研的讨论
5.2 主要调研方式
5.3 整理调研报告静态结构
5.4 整理调研报告动态结构
5.5 非业务调研
5.6 总结
第6章 投核保系统业务调研报告（摘录）
6.1 目标组织结构
6.2 岗位职责分析
6.3 目标流程设计
6.4 表单资料整理
6.5 现行系统状况
6.6 非业务分析
6.7 特别期许
第7章 用例规划
7.1 预备知识——什么是用例图
7.2 概念解析
7.3 解读业务调研报告，规划需求用例
7.4 投核保系统用例规划
7.5 特别期许的用例规划
7.6 小结
第8章 编写数据字典
8.1 数据字典基础知识
8.2 解析数据字典
8.3 解读业务调研报告，编写数据字典
8.4 投核保系统数据字典
8.5 总结
第9章 用例描述
9.1 关于用例描述的解释
9.2 投核保系统用例事件流描述分析
9.3 投核保系统用例描述（摘录）
9.4 总结
第10章 用例及参与者关系分析
10.1 预备知识
10.2 用例与参与者关系概念解析
10.3 解读业务调研报告，分析用例及参与者关系
10.4 投核保系统用例图（摘录）
10.5 总结
……
第2篇 软件架构（上）
第3篇 数据架构
第4篇 软件架构（下）
附录A 在Rose中绘制UML视图
附录B Power Designer介绍
附录C 使用Power Designer完成数据库设计
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件是这样“炼”成的
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算服务
综.述
0.1.本书的写作
0.1.1　本书的重点：云服务的实现
0.1.2　本书的读者群
0.1.3　本书的作者群
0.1.4　写作的思路
0.2.本书内容的结构
0.2.1　商务运营
0.2.2　技术运营
0.2.3　技术架构
0.2.4　安全技术与管理
0.2.5　组织能力
0.3.什么是云计算服务
0.3.1　云计算
0.3.2　云计算的服务模式
0.3.3　云计算的部署方式
0.3.4　云计算的发展
第一部分.商务运营管理
第1章.公司财务运营综述
1.1.财务运营的目的
1.2.云服务公司的财务挑战
1.3.写作重点和章节结构
1.4.财务基本原理介绍（1）：企业与财务团队
1.4.1　.不同类型的企业
1.4.2　.财务团队的结构和职责
1.5.财务基本原理介绍（2）：会计报表与现金流
1.5.1　.三张会计报表的格式以及披露的信息
1.5.2　.净利润不同于现金流
1.5.3　.财务报表分析
第2章.投资与融资决策
云计算服务——运营管理与技术架构
2.1.投资决策
2.1.1　投资决策的基本方法：现值和净现值
2.1.2　投资决策的其他方法
2.1.3　利用净现值进行资本决策
2.2.融资决策
2.2.1　市场有效性
2.2.2　融资的形式
2.2.3　财务杠杆
2.2.4　税收问题
2.3.案例研究
2.3.1　案例（1）：.Google公司的成功避税
2.3.2　案例（2）：云计算服务商Rackspace的成功融资
第3章.财务的日常运营
3.1.公司财务模型与长期计划
3.2.短期财务计划：预算
3.2.1　预算的重要性
3.2.2　年度预算的框架
3.2.3　全面预算的内容
3.2.4　预算的制订和执行流程
3.2.5　滚动预算的做法和各个部门的责任
3.2.6　有效预算的表现及预算实施的六个保证要素
3.2.7.预算工作中的具体内容举例
3.3.案例研究：Equinix公司长期财务计划的有效构建
3.3.1　公司战略
3.3.2　总体财务状况介绍
3.3.3　策略及财务执行分析
3.3.4　财务执行回顾
第4章.成本管理
4.1.成本管理的基本原理
4.1.1　目的
4.1.2　财务会计和管理会计下的成本分析
4.2.成本管理的策略
目.录
4.2.1　成本管理的原则
4.2.2　成本管理的活动
4.2.3　成本管理的方法
4.2.4　成本管理与经营决策
4.3.云服务所面临的挑战
4.3.1　云服务公司的运营成本
4.3.2　云服务公司运营成本控制
4.4.云服务的关键之一：技术运营成本管理
4.4.1　成本管理流程
4.4.2　公司财务控制
4.4.3　云服务的生产设计
4.4.4　容量规划
4.4.5　服务质量管理
4.4.6　责任
4.5.案例研究.：.成本分摊及内部资源的结算
4.5.1　背景介绍
4.5.2　公司面临的挑战及分析
4.5.3　内部资源结算方案
4.5.4　进一步的讨论
4.6.本章总结
第5章.合并与收购
5.1.基本原理
5.1.1　概论
5.1.2　企业并购的目的
5.1.3　并购的种类和运用的手段
5.1.4　并购的成本和风险
5.1.5　并购对公司财务的影响
5.2.并购的流程
5.2.1　公司战略的确定
5.2.2　寻找目标公司
5.2.3　意向征询和关键条款谈判
5.2.4　资金筹划
5.2.5　尽职调查
5.2.6　并购协议签署
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算服务
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业大数据系统构建实战：技术、架构、实施与应用
Contents 目　　录
前言
第1章	企业大数据战略定位  1
1.1	宏观  1
1.2	微观  4
1.2.1	资源协同  5
1.2.2	战略定位  6
1.2.3	启动契机  7
1.2.4	大数据历程  9
1.3	本章小结  12
第2章	企业大数据职能规划  13
2.1	大数据组织架构体系  13
2.1.1	大数据部门在企业中的角色  13
2.1.2	常见的大数据职能及职责  17
2.2	大数据职位构建体系  24
2.2.1	基础平台类  24
2.2.2	数据管理类  26
2.2.3	技术研发类  27
2.2.4	产品设计类  30
2.2.5	数据挖掘类  32
2.2.6	数据分析类  33
2.3	大数据制度和流程规范  35
2.3.1	制度和流程规范意义  35
2.3.2	制度和流程规范内容  35
2.3.3	制度和流程规范模板  42
2.4	本章小结  44
第3章	企业大数据解决方案  45
3.1	企业大数据解决方案实现方式  45
3.1.1	独立研发  45
3.1.2	第三方解决方案  46
3.1.3	联合开发  57
3.2	如何选择解决方案  58
3.2.1	外部环境分析  58
3.2.2	内部环境分析  59
3.2.3	需求规划分析  62
3.2.4	解决方案特性分析  63
3.2.5	解决方案费用评估  67
3.3	本章小结  70
第4章	企业大数据自主实施思路  71
4.1	制定规划原则  71
4.1.1	价值性  71
4.1.2	实时性  72
4.1.3	高效性  72
4.1.4	安全性  72
4.1.5	延展性  73
4.1.6	全局性  74
4.2	制定目标蓝图  75
4.3	制定建设目标  76
4.4	明确组织规划  78
4.4.1	组织结构设计的作用  79
4.4.2	组织结构设立的导向  79
4.4.3	组织结构的最终设立  81
4.5	设计技术方案  85
4.5.1	大数据系统建设方案  85
4.5.2	大数据系统与传统BI的融合方案  91
4.6	制定人才规划  94
4.6.1	指导思想  94
4.6.2	规划原则  94
4.6.3	核心内容  95
4.7	投入产出评估  97
4.7.1	数据投入与产出的内涵  97
4.7.2	数据投入与产出的特征  98
4.7.3	数据投入与产出的管理  99
4.8	数据风险管理  105
4.8.1	数据风险管理的概念  105
4.8.2	数据风险管理的类型  106
4.8.3	数据风险管理的原则  109
4.8.4	数据风险管理与控制  110
4.9	本章小结  114
第5章	大数据技术介绍  115
5.1	核心技术  115
5.1.1	Hadoop生态  115
5.1.2	NoSQL  142
5.1.3	实时计算  150
5.1.4	全文检索  160
5.2	相关技术  204
5.2.1	数据可视化  204
5.2.2	数据缓存  220
5.2.3	中间件  227
5.2.4	关系型数据库  236
5.2.5	数据ETL  245
5.3	大数据算法库  250
5.4	本章小结  276
第6章	大数据架构设计  277
6.1	大数据架构设计原则  277
6.2	大数据核心架构要素  279
6.3	大数据架构设计模式  284
6.4	本章小结  289
第7章	大数据技术开发  290
7.1	数据采集  290
7.1.1	批量采集  291
7.1.2	增量采集  292
7.2	数据存储  293
7.2.1	HDFS文件存储引擎  294
7.2.2	Hive数据存储引擎  295
7.2.3	HBase列式存储引擎  295
7.2.4	MySQL关系型数据存储引擎  296
7.3	多维计算  296
7.4	功能服务  299
7.5	平台管理  301
7.5.1	监控管理  301
7.5.2	调度管理  302
7.5.3	权限管理  304
7.6	应用域  307
7.7	本章小结  308
第8章	大数据工作流  309
8.1	数据源  310
8.1.1	日志/文件  310
8.1.2	数据库  310
8.1.3	网络爬虫  311
8.1.4	第三方API/合作  311
8.2	数据处理  312
8.2.1	数据质量校验  312
8.2.2	清洗转换  316
8.2.3	质量提升  320
8.2.4	数据脱敏  321
8.2.5	集成整合  323
8.3	数据存储  324
8.3.1	关系型数据库  324
8.3.2	分布式文件系统  325
8.4	数据计算  325
8.4.1	三种数据计算时效性  325
8.4.2	结构化数据计算  327
8.4.3	半/非结构化数据计算  333
8.4.4	深度挖掘学习  360
8.5	数据应用  376
8.5.1	辅助决策  376
8.5.2	数据驱动  377
8.6	数据质量管理  379
8.6.1	数据质量建设的内涵  379
8.6.2	影响数据质量的常见因素  380
8.6.3	数据质量建设的框架  381
8.7	本章小结  392
第9章	企业大数据业务应用  393
9.1	大数据应用场景概述  393
9.1.1	场景商业目的分析  394
9.1.2	场景数据来源分析  394
9.1.3	场景数据难易分析  397
9.1.4	场景应用举例  397
9.2	用户画像  407
9.2.1	业务应用背景  407
9.2.2	主要实现过程  408
9.2.3	关键应用场景  414
9.2.4	应用价值提炼  415
9.2.5	场景总结回顾  417
9.3	个性化营销  419
9.3.1	业务应用背景  419
9.3.2	主要实现过程  421
9.3.3	关键应用场景  424
9.3.4	应用价值提炼  425
9.3.5	场景总结回顾  426
9.4	精准广告  427
9.4.1	业务应用背景  427
9.4.2	主要实现过程  429
9.4.3	关键应用场景  438
9.4.4	应用价值提炼  439
9.4.5	场景总结回顾  440
9.5	征信  441
9.5.1	应用场景背景  441
9.5.2	主要实现过程  442
9.5.3	主要应用场景  447
9.5.4	应用价值提炼  449
9.5.5	场景总结回顾  449
9.6	本章小结  450
第10章　企业大数据价值评估  451
10.1　资产价值  451
10.1.1　数据规模  451
10.1.2　数据价值度  452
10.1.3　数据鲜活性  454
10.1.4　数据关联维度  454
10.1.5　数据粒度  455
10.2　业务价值  455
10.2.1　用户体验提升  455
10.2.2　运营优化  457
10.2.3　销售贡献  460
10.2.4　供应链优化  461
10.3　本章小结  462
第11章　大数据的社会价值  463
11.1　民生价值  463
11.2　政务价值  465
11.3　产业价值  468
11.4　本章小结  470
第12章　大数据当前问题及挑战  471
12.1　数据挑战  471
12.2　安全挑战  472
12.3　价值挑战  474
12.4　认知挑战  475
12.5　技术挑战  478
12.6　人才挑战  480
12.7　本章小结  481
第13章　大数据未来趋势  482
13.1　价值资产化  482
13.2　产业生态化  487
13.3　主体社会化  490
13.4　应用智能化  491
13.5　本章小结  492
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业大数据系统构建实战：技术、架构、实施与应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架構的生態系
前言
第一章 什麼是架構的生態系？
第二章 Google如何在全球資訊網上架構起生態系？
第三章 網路如何在沒有Google的情況下進化？
第四章　 為什麼日本跟美國的SNS不同？
第五章　 網路的「外部」設計是怎麼進化的？
第六章　 架構如何操作時間？
第七章　 數位內容的生態系與「通訊記錄的真實性」
第八章　 該如何掌握自日本繁生的架構？
後記
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架構的生態系
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>互联网+顶层商业系统
目录
互联网+顶层商业系统	1
前言	1
目录	2
第1章  巨变时代的转型：互联网时代的商业与管理重构	7
1.1  互联网精神：重构传统商业与管理的“颠覆者”	7
1.1.1  互联网精神的表象：互联网时代的权力弱化	7
1.1.2  互联网精神的本质：互联网权力强化循环体系	10
1.1.3  互联网精神的背后：后权力时代知识型转折	13
1.2  商业重构：互联网时代的价值链变革与融合	14
1.2.1  价值链变革：从传统价值链到价值闭环的转变	15
1.2.2  价值链融合：打破边界，商业发展趋于零边际成本	17
1.2.3  商业重构的背后：人性的回归与管理的突破	19
1.3  管理重构：互联网时代的组织进化与管理变革	20
1.3.1  人才管理重构：组织与员工间的“共享与双赢”	22
1.3.2  战略管理重构：多方参与、共生演化、技术联盟	23
1.3.3  企业文化重构：新型组织文化、价值体系的诞生	24
1.3.4  领导力重构：去权威化、泛中心化、价值多元化	25
1.3.5  组织管理重构：由科层管理体制实现组织扁平化	26
1.3.6  产品与营销重构：从以产品为中心到以客户为中心	28
第2章  互联网+顶层商业系统：实现盈利增收的创新商业模式	34
2.1  商业模式的三维解读：“术、法、道”	34
2.1.1  商业模式的内涵：价值创造与收益获取的组织运作系统	34
2.1.2  商业模式之“术”：商业模式的4个导向因素	36
2.1.3  商业模式之“法”：各要素高效协同的商业系统	38
2.1.4  商业模式之“道”：实现价值共创、基业长青的生态系统	41
2.2  商业模式顶层设计：实现企业盈利增收的5大商业模式	43
2.2.1  免费模式：互联网时代最赚钱的商业模式	43
2.2.2  连锁化模式：连锁经营的盈利复制模式	45
2.2.3  直销化模式：实现企业“裂变”增长的经营模式	49
2.2.4  金融化模式：利用金融杠杆效应，实现收益最大化	54
2.2.5  国际化模式：全球化时代的国际化经营模式	56
2.3  海尔模式的启示：以自主经营体为基础的人单合一管理	60
2.3.1  “以自主经营体为基础的人单合一管理”模式的内涵	61
2.3.2  自主经营体：市场拉动的价值创造网络	65
2.3.3  “人单合一”模式的优势及商业模式创新	67
2.3.4  海尔模式的启示：传统企业如何管理模式的转型升级？	69
第3章  大转型：“互联网+”时代，传统企业的转型与进化	72
3.1  产业转型：“互联网+”新常态下，传统产业模式的转型升级	72
3.1.1  互联网+农业：传统农业传播模式转型	73
3.1.2  互联网+制造：传统制造业模式转型	75
3.1.3  互联网+电信：传统电信行业模式转型	76
3.1.4  互联网+零售：传统零售业模式转型	78
3.2  传统企业痛与变：传统企业如何实现互联网化？	79
3.2.1  失败案例：千寻网、大货栈、邮礼网	79
3.2.2  原因总结：传统企业互联网化失败的4个因素	80
3.2.3  成功经验：互联网企业的商业模式进化路径	81
3.2.4  策略指导：传统企业互联网化的5项原则	83
3.3  互联网巨变时代，老板到底怎么做？	86
3.3.1  具备清晰明确的经营理论	86
3.3.2  为不确定性进行规划	88
3.3.3  企业经营的5个致命点	88
3.3.4  成为企业信息的“搜集者”	90
第4章  平台战略：从传统的竞争思维转化为合作思维	92
4.1  平台战略：构建多方共赢互利的平台生态圈	92
4.1.1  平台战略：互联网时代传统企业的必然选择	92
4.1.2  平台战略的本质：构建多方共赢的平台生态圈	93
4.2  平台模式的“马太效应”：企业由小变大的成长模式	97
4.2.1  赢家通吃：成就行业巨头的最佳商业模式	97
4.2.2  流量聚合：聚拢用户，打造巨大的利润池	99
4.2.3  信息透明：开放共享、合作共赢的获利模式	100
4.3  平台案例：如何构建一家平台型企业？	101
4.3.1  维络城：以电子信息实物化来提高竞争力	101
4.3.2  传化物流：构建多维立体化的物流服务平台	103
4.3.3  联想PC+：开创共赢开放的“PC+”时代	104
4.3.4  蚂蚁短租：通过小项目撑起大平台	106
4.3.5  诚品书店：利用平台模式经营书店	108
第5章  生态型企业：构建自我修复、自我进化的生态系统	109
5.1  什么是“生态型企业”？	109
5.1.1  生态型企业的基本特征	109
5.1.2  生态型企业的3个类型	110
5.2  商业生态系统与生态系统参与者	112
5.2.1  商业生态系统的2大机制：共赢与多样性	112
5.2.2  如何理解“共赢与多样性”？	114
5.2.3  商业生态系统越庞大越好？	118
5.2.4  商业系统的组织者or参与者？	119
5.3  企业生态模式：互联网时代的商业模式创新	120
5.3.1  延伸产业价值链：提升企业竞争优势	120
5.3.2  信息高效共享：提升企业整体协调能力	121
5.3.3  用户至上VS组织无边界：引领企业价值创新	123
5.3.4  增强用户黏性，满足顾客的个性化需求	124
5.3.5  增强动态平衡能力，实现自我循环的生态系统	125
5.4  如何构建自我修复、自我进化的生态型企业？	128
5.4.1  生态型企业的4大要素及10大视角	128
5.4.2  生态型企业与外部生态系统	130
5.4.3  生态型企业与内部生态系统	134
第6章  资本运作：发挥资本优势，实现企业的裂变式增长	138
6.1  资本运作的内涵及分类	138
6.1.1  扩张型资本运作	138
6.1.2  收缩型资本运作	140
6.2  品牌资本运作与管理：资本运营与品牌资产的跨界整合	143
6.2.1  品牌资本模式下，如何对品牌资产进行良性管理？	144
6.2.2  品牌资本模式下，资本运作应当遵循的4大原则	146
6.3  资产裂变 ：借助资本运作，实现企业价值最大化	148
6.3.1  企业资本运作的3个“最大化”	148
6.3.2  企业资本运作案例：海尔、TCL、德隆	149
6.3.3  民营企业资本运作的6大风险	152
6.3.4  现金流管理：优化企业现金流的6项策略	153
6.4  中小企业资本运作：动因、模式与战略选择	158
6.4.1  中小企业资本运作的4个动因	158
6.4.2  中小企业资本运作的3大模式	160
6.4.3  中小企业资本运作的3大战略选择	163
6.5  互联网企业资本运作：资本热潮中的坚守与突破	165
6.5.1  资本运作的积极作用：推动互联网企业转型升级	165
6.5.2  资本运作的负面作用：阻碍互联网企业的创新能力	166
6.5.3  坚守与突破：提升创新能力，积极向移动互联网转型	168
第7章  投融资战略：实现企业资源、资金、资产和资本的高效配置与整合	170
7.1  企业项目投资的选择与决策	170
7.1.1  制定企业投资战略	170
7.1.2  投资项目的选择策略	171
7.1.3  投资项目的可行性研究	174
7.1.4  项目投资决策	178
7.2  企业并购操作流程实战	179
7.2.1  企业并购的概念	179
7.2.2  企业并购操作流程实战	179
7.3  小微企业融资难问题及对策	184
7.3.1  小微企业融资难问题日益凸显	184
7.3.2  小微企业融资难的表现形式	185
7.3.3  小微企业融资难的实质	187
7.3.4  小微企业应对融资难的7点对策	189
7.4  看不见的“软黄金”：企业无形资产管理、运营及评估	190
7.4.1  无形资产管理变革的5大趋势	191
7.4.2  无形资产管理对企业的重要性	194
7.4.3  无形资产管理的3种运营策略	196
7.4.4  企业如何有效经营无形资产？	199
7.4.5  强化企业无形资产管理的5个途径	202
7.5  轻资产模式：以最小化的成本投入获得利润最大化	204
7.5.1  轻资产模式的理论基础	204
7.5.2  轻资产模式的财务战略	206
7.5.3  企业案例：苹果、海澜之家	207
7.5.4  案例分析：苹果与海澜之家的轻资产模式对比	209
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>互联网+顶层商业系统
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>拨云见日
目    录
上篇  内核
第1章  ARM多核处理器	2
1.1  SMP相关基础数据结构	3
1.2  Percpu内存管理	6
1.2.1  内核显式定义的处理器局部数据	6
1.2.2  Percpu内存管理的建立	8
1.2.3  Percpu动态分配内存空间	13
1.3  CpuFreq	15
1.3.1  初始化	15
1.3.2  CpuFreq策略的建立	16
1.3.3  Ondemand调频算法分析	18
1.4  CPU0 bootup CPU1	19
1.4.1  CPU0侧策略和动作	19
1.4.2  CPU1侧执行路线	21
1.5  CPU1的关闭	23
1.5.1  关闭时机	23
1.5.2  CPU1关闭操作	24
1.6  ARM处理器展望	26
1.6.1  ARM架构处理器的演进	26
1.6.2  TrustZone	27
1.6.3  ARM Virtualization	28
第2章  异常	33
2.1  异常向量表	33
2.1.1  异常进入	33
2.1.2  异常表的构建	35
2.2  中断体系	37
2.2.1  Cortex A9多核处理器的中断控制器GIC	37
2.2.2  MT6577的中断体系	38
2.2.3  Exynos4的中断体系	42
2.2.4  OMAP4的中断体系	46
2.3  中断处理	49
2.3.1  中断的基本结构	49
2.3.2  中断源识别	51
2.4  数据异常	54
2.5  处理器间通信	56
第3章  调度与实时性	62
3.1  Tick	62
3.1.1  Local timer	62
3.1.2  Tick挂载	63
3.1.3  Tick产生	66
3.2  Fair调度类	67
3.2.1  Fair调度类的负载均衡	67
3.2.2  Fair调度类的处理器选择	72
3.3  RT调度类	73
3.3.1  RT调度类的基本结构	73
3.3.2  Rt_Bandwidth	76
3.3.3  负载均衡与抢占	79
3.3.4  基础操作	80
3.4  调度器	82
3.4.1  调度域的构建	82
3.4.2  调度器	86
3.5  唤醒	89
3.5.1  唤醒与抢占	89
3.5.2  跨处理器分发线程	91
3.5.3  抢占	92
第4章  Signal	99
4.1  信号发送	99
4.2  信号执行	102
4.2.1  路径切换	102
4.2.2  ARM Linux下信号执行环境的搭建	103
4.2.3  Signal处理函数的返回	107
4.2.4  系统调用重入	109
第5章  进程与进程内存	111
5.1  Linux进程	111
5.1.1  Fork	111
5.1.2  Exec新进程创建	112
5.2  CPU与MMU	117
5.2.1  ARM Linux页表页目录结构	117
5.2.2  页表页目录的建立	120
5.3  进程虚拟内存	122
5.3.1  Android进程虚拟内存的继承	122
5.3.2  进程虚拟地址空间的获得	127
第6章  缺页请页与内存Shrink	129
6.1  缺页与请页	129
6.1.1  File backed虚拟内存段操作函数	130
6.1.2  File backed内存的请页	131
6.1.3  匿名内存的请页	134
6.1.4  COW访问	135
6.2  内存Shrink	137
6.2.1  Shrink操作shrink_page_list	137
6.2.2  Clean Page	142
6.2.3  脏页的监控	143
6.3  全景图	145
第7章  块设备	148
7.1  Bdev文件系统	148
7.2  块设备基础结构	150
7.3  块设备的创建与注册	152
7.4  分区检测生成	156
7.5  块设备的打开	157
7.6  块设备驱动的层次结构	159
7.7  虚拟块设备	161
第8章  VFS	163
8.1  根目录	163
8.1.1  根目录文件系统——initramfs	165
8.1.2  Android ramdisk.img	166
8.1.3  传统根目录文件系统加载方式	166
8.2  文件打开	166
8.2.1  目录的层级查找	167
8.2.2  各层次操作函数的安装	171
8.3  文件写	172
8.3.1  文件写框架	172
8.3.2  write_begin	174
8.3.3  write_end	176
8.4  脏页的提交与回写机制	177
8.4.1  脏页的提交	177
8.4.2  回写时机	179
8.4.3  回写机制的层次操作	183
8.4.4  节点层次的回写	183
第9章  EXT4文件系统	191
9.1  Android文件系统的选择	191
9.2  EXT4文件节点	191
9.2.1  EXT4 inode基础结构	191
9.2.2  EXt4 raw inode的定位	192
9.2.3  EXT4 inode的获取	193
9.3  Mount	195
9.4  EXT4文件写操作	197
9.5  EXT4 journal	199
9.6  Extent tree	202
9.6.1  基础结构	202
9.6.2  定位逻辑块的struct ext4_extent	203
9.6.3  定位逻辑块左右侧的struct ext4_extent项	205
9.7  块分配	208
9.7.1  块组的buddy算法	208
9.7.2  分配物理块	217
9.8  逻辑块到物理块的映射	225
第10章  RCU	229
10.1  RCU tree	229
10.1.1  RCU Tree结构	229
10.1.2  RCU tree的构建	230
10.2  Grace Period	232
10.2.1  Grace Period的检测	232
10.2.2  重新启动新一轮Grace Period	235
10.3  RCU函数的执行	237
第11章  MMC Driver	238
11.1  MMC Driver	238
11.1.1  MMC协议层	238
11.1.2  MMC块设备	239
11.2  开源手机U8836D（MT6577）分区的实现	242
第12章  内核配置系统及内核调试	246
12.1  Conf	246
12.1.1  Kconfig元素	246
12.1.2  Kconfig分析	247
12.2  内核调试	248
12.2.1  senix_printk	249
12.2.2  LOG_BUF	252
下篇  Dalvik与Android用户态源码分析
第13章  内存	258
13.1  Dalvik内存管理	258
13.1.1  虚拟内存分配	258
13.1.2  内存回收	263
13.2  Ashmem	265
13.3  GC	267
13.3.1  对象Mark	267
13.3.2  从Root对象集到普通对象	268
13.3.3  GC与线程实时性	270
第14章  进程与线程	272
14.1  Dalvik虚拟机的进程	272
14.2  Dalvik线程创建机制	273
14.3  Android线程模型	276
14.3.1  主线程的生成	276
14.3.2  线程池线程的生成	276
14.4  Java线程转换	278
14.4.1  从Java到JNI	278
14.4.2  从JNI到Java	279
第15章  Bionic的动态加载机制	283
15.1  Linker——用户态入口	283
15.2  Linker主体——link_image	284
第16章  Android系统初始	287
16.1  Android入口	287
16.2  Init——OS的入口	289
16.2.1  RC文件分析	289
16.2.2  RC动作执行	294
16.2.3  RC的逻辑分析	295
16.2.4  设备探测	295
16.2.5  property库的构建	297
16.2.6  Init的调试	299
第17章  Interpreter与JIT	301
17.1  解释器编译结构	301
17.2  Dalvik寄存器编译模型	301
17.2.1  Callee寄存器分配	301
17.2.2  Caller寄存器分配	303
17.2.3  outs的处理	304
17.3  Portable Interpreter结构	305
17.4  ASM Interpreter	306
17.4.1  基本结构	306
17.4.2  运行时模型与基本操作	308
17.4.3  ASM Interpreter入口	309
17.5  Interpreter的切换	311
17.6  Dalvik运行时帧结构	312
17.7  JIT	313
17.7.1  热点检测	313
17.7.2  Mode切换	315
17.7.3  JIT提交	316
17.8  Compile	317
17.8.1  基础数据结构	317
17.8.2  dalvik指令格式分析	319
17.8.3  TraceRun分析	319
17.8.4  MIR	323
17.8.5  基本块的逻辑关系	325
17.8.6  寄存器分配	327
17.8.7  LIR	332
17.8.8  Codecache	334
17.9  Dalvik ART	335
第18章  Binder	336
18.1  Parcel	336
18.1.1  C++层的Parcel	336
18.1.2  Java层的Parcel	337
18.2  Binder驱动	338
18.2.1  Binder写	339
18.2.2  Binder读	344
18.3  C++层面	346
18.3.1  本地与远端对象	346
18.3.2  服务的建立	349
18.4  Java层面	350
18.5  service_manager	351
第19章  Class	352
19.1  系统类库	352
19.1.1  Inital class	352
19.1.2  ODEX文件的加载	353
19.1.3  系统类库	354
19.1.4  preloaded-classes	355
19.2  类加载	357
19.2.1  类加载框架	357
19.2.2  类加载	359
19.3  对象实体生成	361
第20章  Android应用框架	363
20.1  线程池线程	363
20.1.1  C++层	363
20.1.2  Java层	365
20.2  系统侧Activity与Service的生成控制	366
20.3  class ActivityThread	368
20.3.1  MainLooper	368
20.3.2  activity与service的加载	370
第21章  Android UI体系	371
21.1  窗口体系的生成	371
21.2  ViewRoot与Surface	372
21.3  编辑框实例分析	373
21.3.1  ViewRoot获得系统侧代理对象	373
21.3.2  焦点切换事件——主要Android UI机制的互动	375
21.3.3  输入事件的处理	376
21.3.4  编辑框的生成	377
第22章  ADB	379
22.1  ADB基本结构	379
22.1.1  连接	379
22.1.2  主线程	381
22.1.3  主线程监测的文件句柄	382
22.2  Transport	382
22.2.1  初始化	382
22.2.2  transport传输线程	384
22.2.3  transport的管理	386
22.3  Local服务	389
22.3.1  Local服务的种类	389
22.3.2  Local服务的形态	391
22.3.3  SYNC服务	392
第23章  Android浏览器的Webkit分析	394
23.1  Webcore	394
23.1.1  DOM与Rendering树生成	394
23.1.2  事件的产生与分发	397
23.2  V8 parser源码分析	401
23.2.1  V8 parser处理脚本的层次	402
23.2.2  Scope	406
23.2.3  语法分析的入口 Parser::ParseStatement(…)	408
23.2.4  普通语句的分析	409
23.3  指令生成	415
??
??
??
??
VIII
拨云见日——基于Android的内核与系统架构源码分析
IX
目    录


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>拨云见日
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>NX-OS与Cisco Nexus交换技术
第1章　Cisco NX-OS概述　1
1.1　NX-OS概述　1
1.1.1　NX-OS支持的平台　2
1.1.2　NX-OS许可　7
1.1.3　Cisco NX-OS与Cisco IOS对比　10
1.2　NX-OS用户模式　11
1.2.1　EXEC命令模式　12
1.2.2　全局配置命令模式　13
1.2.3　接口配置命令模式　13
1.3　管理接口　14
1.3.1　CP(控制引擎模块)　15
1.3.2　CMP　16
1.3.3　Telnet　18
1.3.4　SSH　18
1.3.5　XML管理接口　20
1.3.6　SNMP　22
1.3.7　DCNM　25
1.4　管理系统文件　27
1.4.1　文件系统　27
1.4.2　配置文件：配置回退　31
1.4.3　操作系统文件　33
1.5　VDC　34
1.5.1　VDC配置　40
1.5.2　VDC接口分配　43
1.6　故障排查　50
1.6.1　show命令　50
1.6.2　debug命令　50
1.7　拓扑结构　51
1.8　延伸阅读　52
第2章　二层支持能力及配置　53
2.1　二层概述　53
2.1.1　存储转发交换方式　54
2.1.2　直通交换方式　54
2.1.3　利用Nexus 2000实现交换矩阵扩展　54
2.1.4　利用静态映射配置 Nexus2000　55
2.1.5　Nexus 2000静态映射验证　56
2.1.6　利用端口通道配置Nexus2000　60
2.1.7　Nexus 2000端口通道验证　61
2.1.8　Nexus 7000的二层转发　63
2.1.9　二层转发验证　64
2.2　VLAN　65
2.2.1　配置VLAN　66
2.2.2　VLAN中继协议　66
2.2.3　分配VLAN成员关系　67
2.2.4　验证VALN配置　68
2.3　PVLAN　70
2.3.1　配置PVLAN　70
2.3.2　验证PVLAN配置　73
2.4　STP　74
2.4.1　Rapid-PVST+配置　76
2.4.2　MST配置　80
2.4.3　其他生成树配置　84
2.4.4　生成树工具箱　87
2.4.5　生成树端口类型　92
2.4.6　虚拟化主机　93
2.4.7　配置二层接口　93
2.5　端口通道　96
2.5.1　为端口通道分配物理端口　97
2.5.2　端口通道的流控制　100
2.5.3　验证端口通道的负载分发　101
2.6　vPC　102
2.6.1　vPC对等网关　108
2.6.2　vPC对等交换机　109
2.6.3　ARP同步　110
2.7　单向链路检测　110
2.8　Cisco FabricPath　112
2.8.1　vPC+　119
2.8.2　配置vPC+　120
2.9　本章小结　125
第3章　三层支持能力与配置　127
3.1　EIGRP　127
3.1.1　EIGRP操作　128
3.1.2　EIGRP配置　129
3.1.3　EIGRP汇总　134
3.1.4　EIGRP末梢路由　137
3.1.5　EIGRP安全　138
3.1.6　EIGRP重分发　140
3.2　OSPF　145
3.2.1　OSPFv2配置　145
3.2.2　OSPF汇总　151
3.2.3　OSPF末梢路由　153
3.2.4　OSPF安全　157
3.2.5　OSPF重分发　159
3.2.6　OSPFv3配置　166
3.3　IS-IS　168
3.4　BGP　173
3.4.1　BGP配置　173
3.4.2　BGP邻居　176
3.4.3　BGP安全　180
3.4.4　BGP对等体模板　181
3.4.5　宣告BGP网络　183
3.4.6　修改BGP路径度量　186
3.4.7　验证特定BGP配置　187
3.5　FHRP　187
3.5.1　HSRP　188
3.5.2　VRRP　194
3.5.3　HSRP、VRRP与vPC的交互　198
3.5.4　GLBP　199
3.6　本章小结　207
第4章　IP多播配置　209
4.1　多播操作　209
4.1.1　多播分发树　210
4.1.2　RPF　212
4.1.3　PIM　212
4.1.4　RP　213
4.2　Nexus 7000和Nexus 5500上的PIM配置　215
4.2.1　配置静态RP　217
4.2.2　配置BSR　219
4.2.3　配置Auto-RP　222
4.2.4　配置Anycast-RP　225
4.2.5　配置SSM和静态RPF　227
4.3　IGMP操作　229
4.4　Nexus 7000上的IGMP配置　229
4.5　Nexus 5000上的IGMP配置　232
4.6　Nexus 1000V上的IGMP配置　233
4.7　Nexus 7000和Nexus 5500上的MSDP配置　235
4.8　PIM中多播RP的管理定界　237
4.9　配置PIM加入与剪除策略　239
4.10　CoPP　240
4.11　本章小结　241
第5章　安全性　243
5.1　配置RADIUS　244
5.2　配置TACACS+　252
5.3　配置SSH　261
5.4　Cisco TrustSec　264
5.5　配置Cisco TrustSec：IEEE 802.1AE LinkSec　277
5.6　配置IP ACL　285
5.7　配置MAC ACL　288
5.8　配置VLAN ACL　289
5.9　配置端口安全　290
5.10　配置DHCP Snooping　295
5.11　配置动态ARP检测　298
5.12　配置IP源防护　302
5.13　配置密钥链管理　304
5.14　配置流量风暴控制　305
5.15　配置单播RPF　307
5.16　配置CoPP　309
5.17　配置限速　317
5.18　SNMPv3　321
5.19　本章小结　328
第6章　高可用性　329
6.1　物理冗余　329
6.1.1　冗余电源　330
6.1.2　冗余散热系统　332
6.1.3　冗余控制引擎　335
6.1.4　冗余EOBC　336
6.1.5　冗余交换矩阵模块　337
6.2　GOLD　338
6.2.1　启动诊断　339
6.2.2　运行时诊断　339
6.2.3　按需诊断　344
6.3　NX-OS高可用性架构　345
6.4　进程模块化　346
6.5　进程重启　348
6.6　SSO　348
6.7　NSF　350
6.8　ISSU　350
6.9　本章小结　362
第7章　内嵌式维护功能特性　363
7.1　SPAN　364
7.1.1　Nexus 7000上的SPAN　364
7.1.2　在Nexus 7000上配置SPAN　365
7.1.3　Nexus 5x00上的SPAN　370
7.1.4　在Nexus 5x00上配置SPAN　371
7.1.5　Nexus 1000V上的SPAN　374
7.1.6　在Nexus 1000V上配置SPAN　375
7.2　Nexus 1000V上的ERSPAN　377
7.3　Nexus 7000上的ERSPAN　382
7.4　Nexus 5x00上的ERSPAN　388
7.5　内嵌式分析器　391
7.6　智能呼叫到家　400
7.7　Nexus 7000上的配置检查点与回退　406
7.8　Nexus 5x00上的配置检查点与回退　409
7.9　NetFlow　412
7.9.1　在Nexus 7000上配置NetFlow　413
7.9.2　在Nexus 1000V上配置NetFlow　417
7.10　NTP　419
7.11　PTP　420
7.12　IEEE 802.3az(EEE)　421
7.13　POAP　422
7.14　Python　423
7.15　本章小结　428
第8章　统一交换矩阵　429
8.1　统一交换矩阵概述　429
8.2　实现技术　430
8.2.1　10GbE　430
8.2.2　FCoE　432
8.2.3　单跳FCoE　434
8.2.4　多跳FCoE　436
8.2.5　Nexus 7000上的存储VDC　437
8.3　NPV　437
8.3.1　NPIV　439
8.3.2　FCoE-NPV模式　439
8.4　Nexus 5x00统一交换矩阵配置　439
8.4.1　单跳FCoE配置：Nexus 5x00　441
8.4.2　Nexus 5x00上的FCoE-NPV　446
8.5　Nexus 7000统一交换矩阵配置　449
8.6　本章小结　459
第9章　Nexus 1000V　461
9.1　Hypervisor和vSphere概述　461
9.2　Nexus 1000V系统概述　462
9.3　Nexus 1000V交换概述　465
9.4　安装Nexus 1000V VSM　468
9.4.1　部署在Nexus 1010虚拟服务刀片上的Nexus 1000V　468
9.4.2　Nexus 1000V安装管理中心　480
9.4.3　Nexus 1000V安装管理中心提供的VEM安装选项　488
9.4.4　Nexus 1000V安装管理中心提供的vCenter连接选项　491
9.4.5　创建上行链路配置文件　493
9.4.6　向ESX vSphere主机添加VEM　496
9.4.7　启用Telnet服务器进程　503
9.4.8　更改VSM主机名　503
9.4.9　三层控制　504
9.5　Nexus 1000V端口配置文件　509
9.6　VNMC　518
9.6.1　从Cisco.com下载的OVA文件安装VNMC软件　519
9.6.2　在VNMC管理程序中为vCenter连接添加VM-Manager　527
9.6.3　在Nexus 1000V VSM上配置Cisco VNMC PA　533
9.7　VSG　534
9.8　在Nexus 1010上安装VSG　537
9.8.1　在VSG上配置CiscoVNMC PA　539
9.8.2　验证VSG和VSM是VNMC中的注册客户端　540
9.8.3　在VMNC中创建租户　541
9.9　VXLAN　563
9.10　Nexus 1000V NAM　588
9.10.1　安装Nexus 1000V NAM　589
9.10.2　将Nexus 1000V NAM部署为Nexus 1010上的VSB　599
9.11　本章小结　601
第10章　QoS　603
10.1　Nexus 7000的QoS　606
10.1.1　转发架构　606
10.1.2　Network-QoS策略　607
10.1.3　Queuing策略　610
10.1.4　QoS与Nexus 2000 FEX　619
10.1.5　QoS与Nexus 7000 VDC　621
10.2　Nexus 5x00的QoS　621
10.2.1　转发架构　622
10.2.2　Network-QoS策略　622
10.2.3　Queuing策略　625
10.2.4　QoS与Nexus 2000 FEX　626
10.3　Nexus 1000V的QoS　628
10.3.1　转发架构　628
10.3.2　Nexus 1000V的分类　628
10.4　本章小结　631
第11章　OTV　633
11.1　OTV术语与概念　634
11.2　OTV控制平面　639
11.3　支持多播的传输基础设施　645
11.4　支持单播的传输基础设施　648
11.5　OTV数据平面　652
11.6　数据平面多播流量　653
11.7　OTV与QoS　654
11.8　故障隔离　654
11.8.1　STP隔离　655
11.8.2　利用OTV处理未知单播流量　655
11.8.3　利用OTV处理广播流量　655
11.9　OTV的多归属　656
11.10　FHRP定位　658
11.11　入站路径优化　661
11.12　本章小结　663
第12章　三层虚拟化与MPLS　665
12.1　VRF　665
12.1.1　预定义的VRF　666
12.1.2　VRP操作命令　669
12.1.3　VRF-Lite　669
12.2　MPLS概述　673
12.2.1　MPLS术语　674
12.2.2　LDP与三层VPN　675
12.2.3　QoS　678
12.2.4　流量工程　678
12.2.5　MPLS与IPv6：6PE和6VPE　679
12.2.6　管理与故障排查　680
12.2.7　高可用性　680
12.3　MPLS和VRF对Nexus硬件以及NX-OS软件许可的需求　680
12.4　本章小结　681
第13章　LISP　683
13.1　LISP概述　683
13.2　LISP术语　684
13.3　LISP先决条件　685
13.4　LISP控制平面　686
13.5　LISP数据平面　687
13.6　LISP与非LISP站点之间的通信　689
13.7　扩展子网模式下的LISP主机移动性　690
13.8　LISP最佳部署实践　699
13.9　本章小结　699
第14章　Nexus迁移案例研究　701
14.1　现有环境　701
14.2　设计目标　702
14.3　设计方案　703
14.4　迁移计划　703
14.5　预迁移步骤　704
14.6　维护窗口#1　706
14.7　维护窗口#1小结　711
14.8　维护窗口#2　712
14.9　日常维护窗口　738
14.10　本章小结　739
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>NX-OS与Cisco Nexus交换技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计原本
Frederick P. Brooks Jr. 论设计的本质
译者序
前言
作者简介
第一部分  设计之模型
第1章  设计之命题
1.1  培根所言是否正确
1.2  什么是设计
1.3  何为真实？设计的概念
1.3.1  价值何在
1.4  对于设计过程的思考
1.5  设计类别
1.5.1  系统设计与艺术设计
1.5.2  常规，适应性，原创设计
第2章 工程师怎样进行设计思维——理性模型
2.1  模型概览
2.2  该模型的构思从何而来
2.3  理性模型有哪些长处
第3章 理性模型有哪些缺陷
3.1  我们在初始阶段并不真正地知道目标是什么
3.2  我们通常不知晓设计树的样子——一边设计一边探索
3.3  （设计树上的）节点实际上不是设计决策，而是设计暂定方案
3.4  有用性函数无法以增量方式求值
3.5  必要条件及其权重在持续变化
3.6  约束在持续变化
3.7  对于理性模型的其他批评
3.8  但是，尽管有这些缺陷和批评，理性模型仍然不屈不挠地存在
3.9  那又如何？我们的设计过程模型真的那么事关紧要吗
第4章  需求、罪念以及合同
4.1  一段恐怖往事
4.2  殊为不幸，无独有偶
4.3  抵制需求膨胀和蠕变
4.4  罪念
4.5  合同
4.6  一种合同模型
第5章  有哪些更好的设计过程模型
5.1  为什么要有一个占主导地位的模型
5.2  共同演化模型
5.3  Raymond的集市模型
5.3.1  运作机理
5.3.2  模型优势
5.3.3  什么时候可以采用集市模型
5.4  Boehm的螺旋模型
5.5  设计过程模型：第2 ~ 5章的讨论小结
第二部分  协作与电信协作
第6章  协作设计
6.1  协作是在本质上是好的吗
6.2  团队设计是现代标准
6.2.1  为什么工程设计从个人转向团队
6.3  协作的成本
6.4  挑战是概念完整性！
6.4.1  异议
6.5  如何在团队设计中获得概念完整性
6.5.1  现代设计是各学科间的协商吗
6.5.2  系统架构
6.5.3  一名用户界面设计师
6.6  协作何时有帮助
6.6.1  确定利益相关人的需求和愿望
6.6.2  概念探索—激进的可选方案
6.6.3  设计复查
6.7  协作何时无用—对设计本身
6.7.1  概念设计尤其不应该协作
6.8  两人团队很神奇
6.9  对于计算机科学家意味着什么
第7章  电信协作
7.1  为什么要电信协作
7.1.1专业化
7.1.2 家
7.1.3整天工作不停
7.1.4成本
7.1.5政策
7.2  到那里，做那事—IBM System/360计算机系列的分布式开发，1961–1965
7.3  让电信协作有效
7.3.1  面对面的时间很重要
7.3.2  干净的接口
7.4  电信协作的技术
7.4.1  低科技常常足够
7.4.2视频会议
第三部分  设计观点
第8章 设计中的理性主义与经验主义
8.1  理性主义与经验主义
8.2  软件设计
8.3  我是个铁杆的经验主义者
8.4  其他设计领域中的理性主义、经验主义与正确性
第9章 用户模型——错误胜过含糊不清
9.1  明确的用户与用例模型
9.2  果真如此吗
9.3  团队设计
9.4  假如事实不可用该如何是好
9.4.1  猜测
9.4.2  错误胜过含糊不清
第10章 英寸、盎司、位与美元——预算资源
10.1  何谓预算资源
10.2  美元并非万灵丹
10.3  即便美元也有不同，替代品剖析
10.4  预算资源是可变的
10.5  那又如何
10.5.1  明确确认
10.5.2  公开跟踪
10.5.3  严格控制
第11章 约束是我们的朋友
11.1  约束
11.2  不完全如此
11.3  设计悖论：通用的产品要比特定用途的更难以设计
11.4  小结
第12章 技术设计中的美学与风格
12.1  技术设计中的美学
12.2  何谓逻辑美
12.2.1  简约
12.2.2  结构清晰
12.2.3  一致性
12.2.4  什么才是好的计算机架构
12.4.5  一致性的更多优点
12.6  技术设计中的风格
12.7  何谓风格
12.8  风格的属性
12.9  要想获得一致的风格——记录下来
12.10  如何获得良好的风格
第13章 设计中的范本
13.1  很少会有全新的设计
13.2  范例的角色
13.3  计算机与软件设计呢
13.3.1  你使用何种范本
13.4  学习范本的设计原理
13.4.1  第一代计算机
13.4.2  第三代计算机
13.4.3  虚拟内存
13.4.4  小型计算机的变革
13.4.5  微型计算机与RISC的变革
13.5  如何训练才能改进基于范本的设计
13.5.1  范例集合
13.5.2  超越集合
13.5.3  软件设计怎样呢
13.6  范本——懒惰、创意与自满
13.6.1  一些观点
13.6.2  懒惰
13.6.3  创意与自满
第14章 专业设计者缘何犯错
14.1  错误
14.2  曾经最糟糕的计算机语言
14.2.1  何谓JCL
14.2.2  JCL到底怎么了
14.2.3  JCL缘何是这个样子的
14.3小结
第15章  设计的分离
15.1  设计与使用和实现的分离
15.2  为什么分离
15.3  分离的结果
15.4  补救措施
15.4.1  补救措施1：用户场景体验
15.4.2  补救措施2：通过增量式设计和增量式交付与用户密切交互
15.4.3  补救措施3：并发工程
15.4.4  补救措施4：设计者的教育
第16章  展现设计的演变途径和理由
16.1  简介
16.2  知识网线性化
16.3  我们的设计演变途径记录
16.4  我们研究房屋设计过程的过程
16.4.1  什么是设计树
16.5  深入设计过程
16.5.1  设计不只是满足需求，也是发现需求
16.5.2  设计不是简单地选择可选方案，也是意识到它们的存在
16.5.3  设计变化时树也变化—如何展现演进过程
16.6  决策树与设计树
16.7  模块化与紧密集成的设计
16.8  Compendium和可选工具
16.8.1  Task Architect
16.8.2  项目管理工具
16.8.3  IBIS和它的衍生品
16.8.4  Compendium
16.9  DRed：一个诱人的工具
第四部分  计算机科学家设计房屋的梦想系统
第17章  计算机科学家的建筑设计理想系统——从思维到机器
17.1  挑战
17.2  一个设想
17.2.1  渐进完善
17.2.2  模型库
17.2.3  渐进完善模式的不足
17.3  从思维到机器输入的设想
17.3.1  名词-动词组合
17.4  说明动词
17.5  说明名词
17.6  说明文字
17.7  说明助词
17.8  说明视点和视图
17.8.1  内部视图
17.8.2  外部视图
第18章  计算机科学家的建筑设计理想系统——从机器到思维
18.1  双向通道
18.2  视觉显示——多并发窗口
18.2.1  制图桌和绘图视图
18.2.2  2D内容视图
18.2.3  3D视图
18.2.4  外部视图
18.2.5  工作手册视图
18.2.6  规格视图
18.3  声音展示
18.4  触觉展示
18.5  泛化
18.6可行性
第五部分 卓越的设计师
第19章  卓越的设计来自卓越的设计师
19.1  卓越的设计和产品过程
19.2  产品过程：优点和不足
19.2.1  产品过程抑制了卓越的设计吗
19.2.2  为什么要有产品过程
19.3  观点碰撞：过程抑制，过程不可避免；怎么做
19.3.1  卓越的设计来自卓越的设计师，去找到他们
19.3.2  卓越的设计需要大胆的领导者，他们要求创新
19.3.3  如何设计一个鼓励卓越设计的过程
19.3.4寻求概念完整性：信任一名主设计师来完成设计
第20章  卓越的设计师从哪里来
20.1  我们必须教他们设计
20.2  我们必须为卓越设计而招募人才
20.3  我们必须深思熟虑地培养他们
20.3.1  让两架梯子真实而体面
20.3.2  规划正式的教育经历
20.3.3  规划不同的工作经历
20.3.4  规划离开组织机构去休假
20.4  管理他们时必须发挥想象力
20.5  必须严密地保护他们
20.5.1  防止他们分心
20.5.2  保护他们不受管理者干扰
20.5.3  防止他们去做管理
20.6  把自己培养成一名设计师
20.7  不断画设计草稿
20.8  寻求有知识的人对您的设计的批评
20.9  研究教学示例和先例
20.10  一个自我教育项目：1000平方英尺房屋的建筑平面图
第六部分  设计空间之旅：案例研究
第21章  案例研究：海滨小屋“View/360”
21.1  亮点和特性
21.2  背景介绍
21.3  目标
21.4  机会
21.5  约束条件
21.7  设计决定
21.8  考虑正面
21.9  小屋的尺寸
21.10  设想的开始
21.11  在设计之后，构建之前的设计改动
21.12  在框架和外墙完成和初次入住之后的设计改动
21.13  评估（在37年后）
21.13.1  乐事
21.13.2  实用性
21.13.3  牢固性
21.13.4  如果我“废弃一个计划”呢
21.14  学到的一般经验
第22章  案例研究：增加厢房
22.1  亮点和特性
22.2  背景介绍
22.2.1  背景
22.3  目标
22.3.1  最初目标
22.3.2  后来发现的目标
22.4  约束条件
22.5  非约束条件
22.6  事件
22.7  设计决定和迭代
22.7.1  考察
22.7.2  分割设计问题
22.7.3  东部
22.7.4  西部一半的功能安排
22.7.5  方式变化：忘掉预算是设计约束条件
22.7.6  新发现的需求：
22.7.7  功能安排的会合
22.7.8  构建期间的改动
22.8  评估——成功与未解决的缺点
22.8.1  新功能
22.9  学到的一般经验
第23章  案例研究：厨房重新建模
23.1  亮点和特性
23.2  背景介绍
23.2.1  背景
23.3  目标
23.4  机会
23.5  约束条件
23.6  关键宽度预算的推理
23.6.1  从北到南需要的宽度
23.6.2  试验性的设计
23.6.3  另一些宽度解决方案
23.6.4  最终的宽度设计
23.7  长度预算的推理
23.8  其他设计决定
23.8.1  照明
23.9  评估
23.10  满足的其他迫切需求
23.11  在设计中使用图纸、CAD、模型、仿真模型和虚拟环境
23.11.1  虚拟环境的发现
23.12  学到的一般经验
第24章  案例研究：System/360体系结构
24.1  亮点和特性
24.2  项目介绍和相关背景
24.2.1  相关背景
24.3  目标
24.3.1  主要目标
24.3.2  其他重要目标
24.4  机遇（截至1961年6月）
24.5  挑战和限制
24.6  最重大的设计决策
24.7  里程碑事件
24.8  结果评估
24.8.1  稳定性
24.8.2  有用性——竞争力，各个市场的分析
24.8.3  闪光点
24.9  取得的经验教训
第25章 案例研究：IBM Operating System/360操作系统
25.1  亮点和特性
25.2  项目介绍和相关背景
25.2.1  System/360系列机型
25.2.2  1961年的软件格局
25.3  接受挑战
25.4  设计决策
25.4.1  系统架构
25.5  结果评估
25.5.1  成功之处
25.5.2  设计中的不足
25.5.3  流程中的不足
25.6  设计师团队
25.7  取得的经验教训
第26章  案例研究：《Computer Architecture: Concepts and Evolution图书设计
26.1  亮点和特性
26.2  项目介绍和相关背景
26.2.1  相关背景
26.3  项目目标
26.4  机遇
26.5  约束
26.6  设计决策
26.7  结果评估
26.8  经验教训
第27章案例研究：联合计算中心组织：三角区大学计算中心
27.1  亮点与特性
27.2  介绍与内容
27.2.1  内容
27.3  目标
27.3.1  主要目标
27.3.2  其他目标
27.4  机会
27.5  约束
27.6  设计决策
27.7  董事会所考虑的投票方案
27.7.1  权力均衡的限定
27.8  测量评估
27.8.1  牢固性
27.8.2  实用性
27.8  经验总结
第28章 推荐阅读
致谢
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计原本
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>领域驱动设计
目 录
第一部分 运用领域模型
第1章 消化知识 5
1.1 有效建模的要素 9
1.2 知识消化 10
1.3 持续学习 11
1.4 知识丰富的设计 12
1.5 深层模型 15
第2章 交流与语言的使用 16
2.1 模式：UBIQUITOUS LANGUAGE 16
2.2 “大声地”建模 21
2.3 一个团队，一种语言 22
2.4 文档和图 24
2.4.1 书面设计文档 25
2.4.2 完全依赖可执行代码的情况 27
2.5 解释性模型 27
第3章 绑定模型和实现 29
3.1 模式：MODEL-DRIVEN DESIGN 30
3.2 建模范式和工具支持 32
3.3 揭示主旨：为什么模型对用户至关重要 38
3.4 模式：HANDS-ON MODELER 39
第二部分 模型驱动设计的构造块
第4章 分离领域 43
4.1 模式：LAYERED ARCHITECTURE 43
4.1.1 将各层关联起来 46
4.1.2 架构框架 47
4.2 领域层是模型的精髓 48
4.3 模式：THE SMART UI“反模式” 48
4.4 其他分离方式 50
第5章 软件中所表示的模型 51
5.1 关联 52
5.2 模式：ENTITY（又称为REFERENCE OBJECT） 56
5.2.1 ENTITY建模 59
5.2.2 设计标识操作 60
5.3 模式：VALUE OBJECT 62
5.3.1 设计VALUE OBJECT 64
5.3.2 设计包含VALUE OBJECT的关联 67
5.4 模式：SERVICE 67
5.4.1 SERVICE与孤立的领域层 69
5.4.2 粒度 70
5.4.3 对SERVICE的访问 70
5.5 模式：ＭODULE（也称为PACKAGE） 71
5.5.1 敏捷的MODULE 72
5.5.2 通过基础设施打包时存在的隐患 73
5.6 建模范式 75
5.6.1 对象范式流行的原因 76
5.6.2 对象世界中的非对象 77
5.6.3 在混合范式中坚持使用MODEL-DRIVEN DESIGN 78
第6章 领域对象的生命周期 80
6.1 模式：AGGREGATE 81
6.2 模式：FACTORY 89
6.2.1 选择FACTORY及其应用位置 91
6.2.2 有些情况下只需使用构造函数 93
6.2.3 接口的设计 94
6.2.4 固定规则的相关逻辑应放置在哪里 94
6.2.5 ENTITY FACTORY与VALUE OBJECT FACTORY 95
6.2.6 重建已存储的对象 95
6.3 模式：REPOSITORY 97
6.3.1 REPOSITORY的查询 101
6.3.2 客户代码可以忽略REPOSITORY的实现，但开发人员不能忽略 102
6.3.3 REPOSITORY的实现 103
6.3.4 在框架内工作 104
6.3.5 REPOSITORY与FACTORY的关系 104
6.4 为关系数据库设计对象 106
第7章 使用语言：一个扩展的示例 108
7.1 货物运输系统简介 108
7.2 隔离领域：引入应用层 110
7.3 将ENTITY和VALUE OBJECT区别开 110
7.4 设计运输领域中的关联 112
7.5 AGGREGATE边界 113
7.6 选择REPOSITORY 113
7.7 场景走查 115
7.7.1 应用程序特性举例：更改Cargo的目的地 115
7.7.2 应用程序特性举例：重复业务 116
7.8 对象的创建 116
7.8.1 Cargo的FACTORY和构造函数 116
7.8.2 添加Handling Event 117
7.9 停一下，重构：Cargo AGGREGATE 的另一种设计 118
7.10 运输模型中的ＭODULE 120
7.11 引入新特性：配额检查 122
7.11.1 连接两个系统 123
7.11.2 进一步完善模型：划分业务 124
7.11.3 性能优化 125
7.12 小结 126
第三部分 通过重构来加深理解
第8章 突破 131
8.1 一个关于突破的故事 131
8.1.1 华而不实的模型 132
8.1.2 突破 133
8.1.3 更深层模型 135
8.1.4 冷静决策 137
8.1.5 成果 138
8.2 机遇 138
8.3 关注根本 138
8.4 后记：越来越多的新理解 139
第9章 将隐式概念转变为显式概念 140
9.1 概念挖掘 140
9.1.1 倾听语言 140
9.1.2 检查不足之处 144
9.1.3 思考矛盾之处 148
9.1.4 查阅书籍 148
9.1.5 尝试，再尝试 150
9.2 如何为那些不太明显的概念建模 150
9.2.1 显式的约束 151
9.2.2 将过程建模为领域对象 153
9.2.3 模式：SPECIFICATION 154
9.2.4 SPECIFICATION的应用和实现 156
第10章 柔 性 设 计 168
10.1 模式：INTENTION-REVEALING
INTERFACES 169
10.2 模式：SIDE-EFFECT-FREE FUNCTION 173
10.3 模式：ASSERTION 177
10.4 模式：CONCEPTUAL CONTOUR 181
10.5 模式：STANDALONE CLASS 184
10.6 模式：CLOSURE OF OPERATION 186
10.7 声明式设计 188
10.8 声明式设计风格 190
10.9 切入问题的角度 197
10.9.1 分割子领域 197
10.9.2 尽可能利用已有的形式 198
第11章 应用分析模式 206
第12章 将设计模式应用于模型 217
12.1 模式：STRATEGY（也称为POLICY） 218
12.2 模式：COMPOSITE 221
12.3 为什么没有介绍FLYWEIGHT 226
第13章 通过重构得到更深层的理解 227
13.1 开始重构 227
13.2 探索团队 227
13.3 借鉴先前的经验 228
13.4 针对开发人员的设计 229
13.5 重构的时机 229
13.6 危机就是机遇 230
第四部分 战略设计
第14章 保持模型的完整性 233
14.1 模式：BOUNDED CONTEXT 235
14.2 模式：CONTINUOUS INTEGRATION 239
14.3 模式：CONTEXT MAP 241
14.3.1 测试CONTEXT的边界 247
14.3.2 CONTEXT MAP的组织和文档化 247
14.4 BOUNDED CONTEXT之间的关系 248
14.5 模式：SHARED KERNEL 248
14.6 模式：CUSTOMER/SUPPLIER DEVELOPMENT TEAM 250
14.7 模式：CONFORMIST 253
14.8 模式：ANTICORRUPTION LAYER 255
14.8.1 设计ANTICORRUPTION LAYER的接口 256
14.8.2 实现ANTICORRUPTION LAYER 256
14.8.3 一个关于防御的故事 259
14.9 模式：SEPARATE WAY 260
14.10 模式：OPEN HOST SERVICE 261
14.11 模式：PUBLISHED LANGUAGE 262
14.12 “大象”的统一 264
14.13 选择你的模型上下文策略 267
14.13.1 团队决策或更高层决策 268
14.13.2 置身上下文中 268
14.13.3 转换边界 268
14.13.4 接受那些我们无法更改的事物：描述外部系统 269
14.13.5 与外部系统的关系 269
14.13.6 设计中的系统 270
14.13.7 用不同模型满足特殊需要 270
14.13.8 部署 271
14.13.9 权衡 271
14.13.10 当项目正在进行时 272
14.14 转换 272
14.14.1 合并CONTEXT：SEPARATE WAY →SHARED KERNEL 273
14.14.2 合并CONTEXT：SHARED KERNEL→CONTINUOUS INTEGRATION 274
14.14.3 逐步淘汰遗留系统 275
14.14.4 OPEN HOST SERVICE→PUBLISHED LANGUAGE 276
第15章 精炼 277
15.1 模式：CORE DOMAIN 278
15.1.1 选择核心 280
15.1.2 工作的分配 280
15.2 精炼的逐步提升 281
15.3 模式：GENERIC SUBDOMAIN 282
15.3.1 通用不等于可重用 286
15.3.2 项目风险管理 287
15.4 模式：DOMAIN VISION STATEMENT 287
15.5 模式：HIGHLIGHTED CORE 289
15.5.1 精炼文档 289
15.5.2 标明CORE 290
15.5.3 把精炼文档作为过程工具 291
15.6 模式：COHESIVE MECHANISM 292
15.6.1 GENERIC SUBDOMAIN与COHESIVE MECHANISM的比较 293
15.6.2 MECHANISM是CORE DOMAIN一部分 294
15.7 通过精炼得到声明式风格 294
15.8 模式：SEGREGATED CORE 295
15.8.1 创建SEGREGATED CORE的代价 296
15.8.2 不断发展演变的团队决策 296
15.9 模式：ABSTRACT CORE 301
15.10 深层模型精炼 302
15.11 选择重构目标 302
第16章 大型结构 303
16.1 模式：EVOLVING ORDER 306
16.2 模式：SYSTEM METAPHOR 308
16.3 模式：RESPONSIBILITY LAYER 309
16.4 模式：KNOWLEDGE LEVEL 321
16.5 模式：PLUGGABLE COMPONENT FRAMEWORK 328
16.6 结构应该有一种什么样的约束 332
16.7 通过重构得到更适当的结构 333
16.7.1 ZUI小化 333
16.7.2 沟通和自律 334
16.7.3 通过重构得到柔性设计 334
16.7.4 通过精炼可以减轻负担 334
第17章 领域驱动设计的综合运用 336
17.1 把大型结构与BOUNDED CONTEXT结合起来使用 336
17.2 将大型结构与精炼结合起来使用 339
17.3 首先评估 339
17.4 由谁制定策略 341
17.4.1 从应用程序开发自动得出的结构 341
17.4.2 以客户为中心的架构团队 341
17.5 制定战略设计决策的6个要点 342
17.5.1 技术框架同样如此 344
17.5.2 注意总体规划 345
结束语
附录 351
术语表 354
参考文献 357
图片说明 359
索引 360
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>领域驱动设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算架构设计模式
目录
Table of Contents
第1章  缓存驻留模式 1
背景和问题 1
解决方案 1
相关模式与指南 5
更多信息 5
第2章  断路器模式 6
背景和问题 6
解决方案 6
问题与思考 8
何时使用此模式 10
相关模式和指南 14
第3章  补偿事务模式 15
背景和问题 15
解决方案 16
问题与思考 16
何时使用此模式 17
相关模式和指南 18
第4章  竞争消费者模式 19
背景和问题 19
解决方案 19
问题与思考 20
何时使用此模式 21
第5章  计算资源合并模式 25
背景和问题 25
解决方案 26
问题与思考 26
应用场景 28
相关模式和指南 32
扩展阅读 32
第6章  命令和查询职责分离(CQRS)模式 33
背景和问题 33
解决方案 34
问题与思考 35
何时使用此模式 36
第7章  事件溯源模式 41
背景和问题 41
解决方案 41
问题与思考 43
何时使用此模式 44
相关模式和指南 47
第8章  外部配置存储模式 48
背景和问题 48
解决方案 48
问题与思考 49
何时使用此模式 50
关联模式和指南 56
第9章  联合身份模式 57
背景和问题 57
解决方案 57
问题与思考 59
何时使用此模式 59
相关模式和指南 61
更多信息 61
第10章  门卫模式 62
背景和问题 62
解决方案 62
问题与思考 63
何时使用此模式 63
相关模式和指南 64
第11章  健康终端监控模式 65
背景和问题 65
解决方案 65
问题与思考 67
何时使用此模式 68
相关模式和指南 71
更多信息 71

第12章  索引表模式 72
背景和问题 72
解决方案 73
问题与思考 75
何时使用此模式 76
相关模式与指南 77
第13章  领导者选举模式 79
背景和问题 79
解决方案 79
问题与思考 80
何时使用此模式 80
相关模式与指南 85
更多信息 85
第14章  实体化视图模式 86
背景和问题 86
解决方案 86
问题与思考 87
何时使用此模式 88
相关模式与指南 89
第15章  管道过滤器模式 90
背景和问题 90
解决方案 91
问题与思考 92
何时使用此模式 93
相关模式与指南 97
第16章  优先队列模式 98
背景和问题 98
解决方案 98
问题与思考 100
何时使用此模式 101
相关模式与指南 103
第17章  基于队列的负载均衡模式 105
背景和问题 105
解决方案 105
问题与思考 106
何时使用此模式 107
相关模式和指南 108
第18章  重试模式 109
背景和问题 109
解决方案 109
问题与思考 111
何时使用此模式 112
相关模式与指南 114
更多信息 114
第19章  运行时重配模式 115
背景和问题 115
解决方案 115
问题与思考 116
何时使用此模式 117
相关的模式和指南 120
更多的信息 121
第20章  调度器代理管理者模式 122
背景和问题 122
解决方案 122
问题与思考 125
何时使用此模式 125
相关模式与指南 128
更多信息 129
第21章  分片模式 130
背景和问题 130
解决方案 130
分片策略 131
问题与思考 135
何时使用此模式 136
相关模式与指南 138
第22章  静态内容托管模式 139
背景和问题 139
解决方案 139
问题与思考 139
何时使用此模式 140
相关模式与指南 143
更多信息 143
第23章  限流模式 144
背景和问题 144
解决方案 144
问题与思考 146
何时使用此模式 147
相关模式与指南 148
第24章  令牌秘钥模式 149
背景和问题 149
解决方案 149
问题与思考 150
何时使用此模式 152
相关模式和指南 154
更多信息 154
第25章  异步消息传输指南 155
消息队列本质 155
异步消息传递的场景 158
实现异步消息传递的注意事项 159
相关模式和指南 161
更多信息 162
第26章  自动伸缩指南 163
什么是自动伸缩 163
实施自动伸缩的场景 164
实施自动伸缩的注意事项 164
Azure解决方案中的自动伸缩 165
相关模式和指南 167
更多信息 167
第27章  缓存指南 168
云应用程序中的缓存 168
使用缓存的注意事项 170
管理缓存并发 172
相关模式和指南 173
更多信息 173
第28章  计算分区指南 174
Azure计算选项概述 174
计算界限设计指南 174
组件分离计算实例 176
相关模式与指南 177
更多信息 178
第29章  数据一致性指南 179
管理数据一致性 179
最终一致性实现的注意事项 182
相关模式与指南 185
第30章  数据分区指南 186
为什么需要数据分区 186
分区策略 187
设计可扩展性的数据分区 190
设计分区以提升查询性能 191
分区可用性设计 192
问题与思考 192
相关模式与指南 194
更多信息 194
第31章  数据复制与同步指南 195
为什么要数据复制及同步 195
复制和同步数据 195
数据复制和同步的注意事项 198
实现同步 200
相关模式与指南 201
更多信息 201
第32章  远程监控指南 202
为什么远程监控很重要 202
监控 202
语义日志记录 204
遥测 205
远程监控的注意事项 205
相关模式与指南 207
更多信息 208
第33章  多数据中心部署指南 209
为什么部署到多个数据中心 209
多数据中心部署的思考 213
相关模式及指南 217
第34章  服务调用统计指南 218
为什么服务调用统计很重要 218
服务调用统计的场景 218
服务调用统计的注意事项 220
示例 221
相关模式及指南 222
更多信息 222
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算架构设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式微服务架构：原理与实战
目录
第1章 从架构演进启程 1
1.1 水平分层架构 1
1.1.1 概述 1
1.1.2 MVC架构/水平分层架构 2
1.2 SOA服务化架构 4
1.2.1 SOA概述 5
1.2.2 SOA的特征 5
1.2.3 SOA面临的问题 5
1.3 分布式微服务架构 5
1.3.1 微服务概述 5
1.3.2 SOA与微服务 6
1.3.3 微服务架构的特点 6
1.3.4 微服务架构的缺点 7
1.3.5 微服务架构全景图 7
1.3.6 微服务类型 9
1.3.7 微服务拆分原则与步骤 9
第2章 微服务开发框架 11
2.1 环境准备 11
2.1.1 安装JDK 11
2.1.2 安装 Intellij IDEA 14
2.1.3 安装 Apache Maven 14
2.2 一分钟快速搭建Spring Boot项目 15
2.2.1 使用Spring Initializr新建项目 15
2.2.2 测试 18
2.3 Spring Boot简单介绍 18
2.3.1 Spring Boot核心功能及特性 19
2.3.2 Spring Boot的缺点 20
2.4 Spring Boot目录介绍 20
2.4.1 Spring Boot工程目录 20
2.4.2 Spring Boot入口类 21
2.4.3 Spring Boot测试类 22
2.4.4 pom文件 23
2.5 Spring Boot生产级特性 24
2.5.1 应用监控 24
2.5.2 健康检查 28
2.5.3 跨域访问 29
2.5.4 外部配置 30
第3章 分布式RPC框架 31
3.1 RPC框架概述 31
3.1.1 定义 31
3.1.2 RPC核心组件 31
3.1.3 RPC调用过程 32
3.1.4 RPC框架调用分类 33
3.1.5 RPC框架性能 35
3.1.6 RPC框架与分布式服务框架 35
3.2 RPC框架 36
3.2.1 RMI远程方法调用 36
3.2.2 Thrift 37
3.2.3 Hessian 38
3.2.4 Avro-RPC 38
3.2.5 gRPC 38
3.2.6 其他RPC框架 39
第4章 序列化与反序列化 40
4.1 序列化与反序列化 40
4.1.1 序列化/反序列化概念 40
4.1.2 序列化/反序列化特性 41
4.2 常用序列化框架 41
4.2.1 Java默认序列化 41
4.2.2 XML序列化框架 46
4.2.3 JSON序列化框架 48
4.2.4 ProtoBuf序列化框架 50
第5章 微服务底层通信与协议 54
5.1 Java网络通信 54
5.1.1 传统BIO编程 54
5.1.2 伪异步I/O编程 60
5.1.3 NIO编程 62
5.2 Netty框架 78
5.2.1 Netty概述 78
5.2.2 第一个Netty应用程序 78
5.2.3 Netty架构设计 84
5.3 分布式服务框架协议 89
5.3.1 主流公有协议 89
5.3.2 私有协议设计 90
第6章 服务路由与负载均衡 94
6.1 服务路由概述 94
6.1.1 定义 94
6.1.2 服务信息存放方式 94
6.2 服务路由概述 95
6.2.1 定义 95
6.2.2 负载均衡的实现 95
6.2.3 负载均衡算法 98
第7章 微服务注册中心 103
7.1 微服务注册中心 103
7.1.1 注册中心几个概念 103
7.1.2 注册中心 104
7.2 ZooKeeper实现服务注册中心 104
7.2.1 ZooKeeper概述 104
7.2.2 ZooKeeper的原理 105
7.2.3 ZooKeeper的安装 106
7.2.4 ZooKeeper搭建集群环境 109
7.2.5 ZooKeeper集群总体架构 110
7.2.6 命令行客户端zkCli.sh 112
7.2.7 ZkClient连接ZooKeeper 116
7.2.8 ZooKeeper实现服务注册与发现 120
第8章 微服务框架服务调用与容错 122
8.1 服务调用概述 122
8.2 服务调用方式 123
8.2.1 同步服务调用 123
8.2.2 异步服务调用 125
8.2.3 并行服务调用 130
8.2.4 泛化调用 132
第9章 分布式微服务封装与部署 133
9.1 微服务封装技术 133
9.1.1 Docker概述 133
9.1.2 Docker的基本概念 135
9.1.3 Docker架构 135
9.1.4 Docker的安装 137
9.1.5 Docker的常用命令 138
9.1.6 制作镜像 142
9.1.7 使用Dockerfile构建镜像 144
9.1.8 Spring Boot集成Docker 147
9.2 微服务部署概述 150
9.2.1 蓝绿部署 150
9.2.2 滚动发布 152
9.2.3 灰度发布/金丝雀部署 154
第10章 分布式服务限流 155
10.1 服务限流概述 155
10.1.1 限流定义 155
10.1.2 限流算法 155
10.2 限流设计 157
10.2.1 限流设计 157
10.2.2 分级限流 158
第11章 服务降级、熔断、调度 159
11.1 服务降级概述 159
11.2 服务降级方式 159
11.2.1 服务降级开关 159
11.2.2 自动降级 160
11.2.3 读服务降级 161
11.2.4 写服务降级 161
11.3 服务容错策略 161
11.3.1 失败转移（Failover） 162
11.3.2 失败自动恢复（Failback） 162
11.3.3 快速失败（Failfast） 162
11.3.4 失败缓存（FailCache） 162
11.4 Hystrix降级、熔断 162
11.4.1 Hystrix简介 162
11.4.2 Hystrix实现降级/熔断 164
11.5 服务优先级设计 165
11.5.1 服务实例数量调整 165
11.5.2 加权优先级队列 166
11.5.3 线程调度器 167
第12章 服务版本与服务发布 168
12.1 概述 168
12.2 服务版本概述 168
12.2.1 概述 168
12.2.2 Snapshot和Release 169
12.3 服务发布 169
12.3.1 概述 169
12.3.2 服务发布方式 170
第13章 分布式微服务日志中心 173
13.1 分布式日志概述 173
13.1.1 结构化日志/非结构化日志 173
13.1.2 日志类型 175
13.2 日志框架 175
13.2.1 JDK Logger 175
13.2.2 Apache Commons Logging 177
13.2.3 Log4j/Log4j 2 177
13.2.4 Spring Boot集成Log4j 179
13.2.5 Docker日志框架 181
13.2.6 Linux系统Syslog 183
13.3 搭建日志中心 183
13.3.1 ELK概述 183
13.3.2 Elasticsearch日志存储 184
13.3.3 Logstash日志收集 189
13.3.4 Fluentd日志收集 191
13.3.5 Kibana日志查询 193
13.3.6 ELK架构与Docker整合 194
13.3.7 ELK架构原理 195
第14章 分布式微服务监控 197
14.1 分布式服务架构监控 197
14.1.1 监控的价值 197
14.1.2 监控的完整体系 197
14.1.3 微服务监控类型 198
14.1.4 Spring Boot应用监控 198
14.1.5 Spring Boot Admin监控系统 201
14.2 搭建系统监控中心 206
14.2.1 概述 206
14.2.2 时序数据收集系统：cAdvisor 206
14.2.3 时序数据存储系统：InfluxDB 209
14.2.4 时序数据分析系统：Grafana 212
14.2.5 集成InfluxDB + cAdvisor + Grafana 214
第15章 分布式微服务配置中心 218
15.1 配置中心概述 218
15.1.1 概述 218
15.1.2 配置中心解决问题 218
15.1.3 全局配置 219
15.1.4 配置中心 221
15.2 Spring Cloud Config 223
15.2.1 概述 223
15.2.2 Spring Cloud Config快速入门 224
第16章 分布式微服务存储与解耦 232
16.1 分布式数据库架构 232
16.1.1 分库 232
16.1.2 分表 233
16.1.3 水平切分的方式 233
16.1.4 垂直切分的方式 235
16.1.5 分组 235
16.1.6 Mycat分库分表实战 236
16.1.7 Spring+MyBatis+Mycat快速体验 240
16.2 分布式事务 249
16.2.1 数据库事务 249
16.2.2 分布式事务 249
16.2.3 CAP定理 250
16.2.4 BASE理论 251
16.2.5 两阶段提交（2PC） 252
16.2.6 补偿事务（TCC） 252
16.2.7 后置提交 254
16.2.8 本地消息表（异步确保） 255
16.3 分布式缓存架构 256
16.3.1 Memcache与Redis 256
16.3.2 进程内缓存 257
16.3.3 Redis单节点安装 259
16.3.4 Redis持久化策略 260
16.3.5 Redis主从复制模式 263
16.3.6 Redis哨兵模式 266
16.3.7 Redis哨兵模式安装部署 271
16.3.8 Redis集群模式 277
16.3.9 Redis集群环境搭建 280
16.3.10 Redis缓存穿透和雪崩 288
16.4 微服务解耦 294
16.4.1 服务解耦概述 294
16.4.2 Kafka介绍 295
16.4.3 Kafka安装 299
16.4.4 Kafka搭建集群环境 300
16.4.5 Kafka Manager的安装 301
16.4.6 Kafka常用命令 301
16.4.7 Spring Boot集成Kafka 311
16.5 分布式服务Session 315
16.5.1 Session与Cookie 315
16.5.2 Session一致性问题 315
16.5.3 Session同步 316
第17章 分布式微服务测试 318
17.1 分布式微服务测试 318
17.1.1 概述 318
17.1.2 微服务测试 319
17.2 Spring Boot单元测试 321
17.3 Mockito/PowerMockito测试框架 323
17.3.1 Mockito概述 323
17.3.2 Mockito简单实例 324
17.3.3 PowerMock概述 327
17.3.4 PowerMockito简单实例 327
17.4 H2内存型数据库 330
17.4.1 H2概述 330
17.4.2 Spring Boot集成H2 330
17.5 REST API测试 333
17.5.1 Postman概述 333
17.5.2 Postman简单使用 333
17.6 性能测试 336
17.6.1 ab概述 336
17.6.2 ab测试 336
17.6.3 其他性能测试工具 338
第18章 分布式微服务架构经典案例 341
18.1 微服务架构案例 341
18.1.1 概述 341
18.1.2 微服务架构平台选择 342
18.1.3 微服务接口类型 342
18.1.4 微服务类型 343
18.2 分布式服务框架Dubbo 344
18.2.1 Dubbo概述 344
18.2.2 Dubbo原理 344
18.3 Spring Boot + Spring Cloud解决方案 345
18.3.1 Spring Boot概述 345
18.3.2 Spring Cloud概述 345
18.3.3 微服务、Spring Boot、Spring Cloud的关系 347
18.3.4 Spring Cloud与Dubbo的优劣 348
18.4 Spring Boot + Kubernetes + Docker解决方案 348
18.4.1 Docker概述 348
18.4.2 Kubernetes概述 349
18.4.3 Kubernetes的基本概念 349
18.4.4 Kubernetes的使用 352
18.4.5 Kubernetes的架构 356
18.4.6 Kubernetes集群监控 360
18.4.7 Kubernetes集群日志管理 360
18.4.8 Kubernetes解决方案 360
参考文献 362
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式微服务架构：原理与实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>OpenStack企业云平台架构与实践
第1章OpenStack与云	1
1.1  云计算	2
1.2  云服务模式	3
1.2.1  IaaS：基础设施即服务	3
1.2.2  PaaS：平台即服务	4
1.2.3  SaaS：软件即服务	4
1.3  云应用形式	4
1.3.1  私有云	4
1.3.2  云存储	5
1.3.3  云游戏	5
1.3.4  云物联	5
1.3.5  云安全	5
1.3.6  公有云服务	6
1.3.7  混合云	6
1.3.8  云计算的安全风险	6
1.4  云管理与虚拟化管理	7
1.5  私有云与公有云	8
1.6  传统应用与云感知应用	9
1.7  什么是OpenStack	11
1.8  开源云平台比较	13
1.9  术语	15
第2章OpenStack社区	17
2.1  OpenStack基金会	21
2.2  白金会员	22
2.3  黄金会员	22
2.4  OpenStack设计原则	23
2.5  开源而开放的原则	23
2.6  OpenStack版本管理	23
2.7  OpenStack用户	24
2.8  OpenStack的误区	27
2.9  部署OpenStack的技术需求	30
第3章OpenStack与AWS、VMware、虚拟化管理工具	31
3.1  OpenStack与AWS的比较	32
3.2  OpenStack与VMware对比	39
3.2.1  VMware vMotion与OpenStack动态迁移、块迁移	44
3.2.2  VMware DRS、DPM与OpenStack调度器	45
3.2.3  VMware与OpenStack的高可用	45
3.2.4  VMware与OpenStack的容错（Fault Tolerance）	46
3.2.5  总结	46
3.3  虚拟化与虚拟化管理工具	47
3.3.1  服务器虚拟化	47
3.3.2  网络虚拟化	48
3.3.3  存储虚拟化	48
3.3.4  虚拟化工具VirtualBox	48
3.3.5  虚拟化工具Virt-Manager	53
第4章虚拟机管理程序与典型应用	56
4.1  开放虚拟化技术KVM	57
4.1.1  libvirt介绍	58
4.1.2  域配置文件	59
4.1.3  使用 Libvirt创建和管理KVM虚拟机	60
4.2  Linux容器	62
4.2.1  LXC	65
4.2.2  Docker	71
4.3  裸机	77
4.4  LXC/Docker与KVM/Xen的选择	78
4.5  OpenStack与Linux	79
4.6  OpenStack与KVM	79
4.7  OpenStack与VDI	80
4.7.1  基于OpenStack的VDI典型架构	80
4.7.2  Spice协议	81
4.7.3  开发桌面虚拟化应用的功能需求	84
4.8  OpenStack与Hadoop	85
4.8.1  云平台/虚拟化对大数据计算的益处	86
4.8.2  OpenStack对Savanna的支持	86
4.8.3  Savanna的使用简介	87
第5章OpenStack架构与组件	92
5.1  OpenStack项目与组件	93
5.2  IaaS模型与OpenStack组件对应关系	95
5.2.1  OpenStack功能待提高的方面	100
5.2.2  节点与网络类型	100
5.3  消息总线和数据库	104
5.4  多租户	105
5.5  Keystone	107
5.6  Glance	112
5.7  Nova	119
5.7.1  nova-api	119
5.7.2  nova-scheduler	120
5.7.3  nova-schedule过滤器	122
5.7.4  nova-volume	128
5.7.5  nova-compute	128
5.7.6  nova-network	132
5.7.7  nova-conductor	135
5.7.8  服务横向扩展	136
5.8  存储	138
5.8.1  对象存储	139
5.8.2  块存储	139
5.8.3  Cinder	144
5.8.4  卷（Volume）操作	145
5.9  Neutron	148
5.9.1  nova-network的局限性	148
5.9.2  Neutron功能特点	149
5.9.3  ML2	149
5.9.4  Open vSwitch虚拟网络	151
5.10  Ceilometer	154
5.10.1  计算（Nova）	155
5.10.2  网络（Neutron）	156
5.10.3  镜像（Glance）	157
5.10.4  块存储（Cinder）	158
5.10.5  对象存储（Swift）	158
5.10.6  编排（Heat）	158
5.10.7  能源（Kwapi）	159
5.10.8  网络（SDN控制器）	159
5.10.9  计量数据收集的结构、交互图	161
5.11  Heat	161
第6章OpenStack部分组件安装示例	163
6.1  安装拓扑	164
6.2  服务器远程安装配置	165
6.3  软件包与仓库	167
6.3.1  软件包	167
6.3.2  软件仓库	169
6.3.3  依赖关系	169
6.3.4  软件包名称	170
6.3.5  只下载软件包的方法	171
6.3.6  RPM常用命令	172
6.4  ISO	173
6.5  安装OpenStack组件——Keystone、Glance和Quantum	175
6.5.1  控制节点	175
6.5.2  计算节点	187
6.5.3  设置iptables规则	187
6.6  大规模安装技术与工具	187
6.6.1  Chef	187
6.6.2  Puppet	190
6.6.3  Chef与Puppet的比较	191
6.6.4  IBM xCAT	192
第7章系统定制技术	193
7.1  系统环境的定制	194
7.1.1  KVM的检查与安装	194
7.1.2  网络时间协议（NTP）服务的设置	196
7.1.3  SSH无密码登录	197
7.1.4  自动运行定制化程序	199
7.1.5  简单备份	200
7.2  网络	201
7.2.1  ifconfig命令使用及结果分析	201
7.2.2  静态IP地址的配置	202
7.2.3  网卡绑定	204
7.2.4  网桥模式的配置	207
7.2.5  Access、Hybrid和Trunk三种模式	209
7.3  安装与打包技术	211
7.3.1  制作RPM	211
7.3.2  Kickstart快速安装	218
7.3.3  编辑可引导的ISO	230
7.3.4  制作一个定制化可引导的ISO	231
第8章OpenStack部署	240
8.1  来自实际客户的困惑	241
8.2  企业云环境规划	245
8.2.1  理解企业业务需求和预期	245
8.2.2  云平台规划	247
8.3  区域和可用区	252
8.4  典型部署拓扑	255
8.4.1  基于传统网络的基本部署架构	255
8.4.2  基于OpenStack Neutron的部署架构	257
8.4.3  基于Ceph统一存储的部署架构	257
8.4.4  中型企业私有云部署架构	258
8.4.5  中型企业差异化资源池、多种存储池的部署	260
8.4.6  融合传统硬件的部署方案	260
8.5  云平台硬件选择	261
8.5.1  试验环境推荐配置	261
8.5.2  标准部署推荐配置	262
8.6  控制节点的设计	263
8.6.1  硬件抉择	263
8.6.2  服务分离式部署	264
8.6.3  数据库	264
8.6.4  消息中间件	264
8.6.5  认证与授权	265
8.6.6  网络	265
8.6.7  计算节点的设计	265
8.6.8  存储的选择	270
8.6.9  网络的选择	276
8.6.10  计算硬件需求	279
8.6.11  软件部分检查清单	284
8.6.12  与企业现有系统集成	285
8.6.13  云环境扩展需求	286
8.7  生产环境问题和对策	288
8.7.1  计算资源隔离和流量控制	288
8.7.2  调度策略	288
8.7.3  负载均衡	288
8.7.4  OpenStack的实施	289
8.8  云平台监控	291
8.8.1  性能监控	291
8.8.2  服务与资源监控	293
8.8.3  消息中间件监控	295
8.8.4  日志分析	298
第9章第三方工具搭建OpenStack运行环境	300
9.1  DevStack	302
9.1.1  环境准备	302
9.1.2  安装	303
9.2  IBM OpenStack Solution for System X	309
9.2.1  OpenStack Solution客户服务生命周期	310
9.2.2  OpenStack Solution的功能特点与优势	311
9.2.3  云平台内部的修补、优化与定制	313
9.2.4  模块化和自动化的云平台搭建技术	315
9.2.5  控制节点的设计	316
9.2.6  控制服务部署场景	316
9.2.7  安装	317
9.3  Red Hat RDO	322
9.3.1  环境准备	322
9.3.2  设置源	324
9.3.3  安装PackStack	326
9.3.4  定制PackStack的answer文件	326
9.3.5  安装	338
9.3.6  增加计算节点	342
9.4  Mirantis Fuel	343
9.4.1  Fuel简介	343
9.4.2  Mirantis支持的架构	344
9.4.3Fuel安装	349
9.5  Dell Crowbar	364
9.5.1  Crowbar安装OpenStack	365
9.5.2  界面	366
第10章九州云Animbus融合架构一体机解决方案	371
10.1  产品背景	372
10.2  九州云计算存储云一体机	375
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>OpenStack企业云平台架构与实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MySQL技术精粹---架构、高级特性、性能优化与集群实战
第1章  MySQL架构介绍. 1
1.1 MySQL架构   1
1.1.1 MySQL物理文件的组成   2
1.1.2 MySQL各逻辑块简介   4
1.1.3 MySQL各逻辑块协调工作   6
1.2 MySQL存储引擎概述   7
1.3 MySQL各种存储引擎的特性  10
1.3.1 MyISAM.  10
1.3.2 InnoDB  12
1.3.3 MEMORY  15
1.3.4 MERGE  18
1.3.5 BerkeleyDB存储引擎  20
1.4 MySQL工具  21
1.4.1 MySQL命令行实用程序  21
1.4.2 MySQL Workbench  33
1.5 本章小结   34
第2章  MySQL权限与安全   35
2.1 权限表   35
2.1.1 user表.  35
2.1.2 db表和 host表  37
2.1.3 tables_priv表和 columns_priv表   39
2.1.4 procs_priv表  40
2.2 账户管理   41
2.2.1 登录和退出 MySQL服务器   41
2.2.2 新建普通用户   43
2.2.3 删除普通用户   47
2.2.4 root用户修改自己的密码  48
2.2.5 root用户修改普通用户密码  50
2.2.6 普通用户修改密码   51
2.2.7 root用户密码丢失的解决办法  51
2.3 权限管理   53
2.3.1 MySQL的各种权限  53
2.3.2 授权   55
2.3.3 收回权限   57
2.3.4 查看权限   58
2.4 访问控制   59
2.4.1 连接核实阶段   59
2.4.2 请求核实阶段   60
2.5 MySQL的安全问题  61
2.5.1 操作系统相关的安全问题   61
2.5.2 数据库相关的安全问题   62
2.6 使用 SSL安全连接   71
2.7 综合管理用户权限   77
2.8 小结   80
第3章 数据备份与还原. 81
3.1 数据备份   81
3.1.1 使用 mysqldump命令备份  81
3.1.2 直接复制整个数据库目录   88
3.1.3 使用 mysqlhotcopy工具快速备份  88
3.2 数据还原   89
3.2.1 使用 MySQL命令还原   89
3.2.2 直接复制到数据库目录   90
3.2.3 mysqlhotcopy快速恢复   90
3.3 数据库迁移   90
3.3.1 相同版本的 MySQL数据库之间的迁移   91
3.3.2 不同版本的 MySQL数据库之间的迁移   91
3.3.3 不同数据库之间的迁移   92
3.4 表的导出和导入   92
3.4.1 使用 SELECT…INTO OUTFILE导出文本文件   92
3.4.2 用 mysqldump命令导出文本文件  95
3.4.3 用 MySQL命令导出文本文件   98
3.4.4 使用 LOAD DATA INFILE方式导入文本文件  101
3.4.5 使用 mysqlimport命令导入文本文件  103
3.5 综合实例——数据的备份与恢复  105
3.6 小结  109
第4章 MySQL的高级特性  110
4.1 MySQL 查询缓存   110
4.1.1 认识查询缓存  110
4.1.2 监控和维护查询缓存  115
4.1.3 如何检查缓存命中率  117
4.1.4 优化查询缓存  118
4.2 合并表和分区表  119
4.2.1 合并表  119
4.2.2 分区表  121
4.3 事务控制  131
4.4 MySQL分布式事务   135
4.4.1 了解分布式事务的原理  135
4.4.2 分布式事务的语法  136
4.5 小结  137
第5章 MySQL锁定机制 138
5.1 MySQL锁定机制概述   138
5.2 MyISAM表级锁 143
5.2.1 MyISAM表级锁的锁模式 143
5.2.2 获取 MyISAM表级锁的争用情况  145
5.2.3 MyISAM表级锁加锁方法 146
5.2.4 MyISAM Concurrent Insert的特性   148
5.2.5 MyISAM表锁优化建议 150
5.3 InnoDB行级锁   150
5.3.1 InnoDB行级锁模式   150
5.3.2 获取 InnoDB行级锁的争用情况  155
5.3.3 InnoDB行级锁的实现方法   157
5.3.4 间隙锁（Net-Key锁）  162
5.3.5 InnoDB 在不同隔离级别下加锁的差异  163
5.3.6 InnoDB 存储引擎中的死锁  164
5.3.7 InnoDB行级锁优化建议   166
5.4 小结  167
第6章 使用 MySQL Workbench 管理数据库  168
6.1 MySQL Workbench简介   168
6.1.1 MySQL Workbench 的概述  168
6.1.2 MySQL Workbench 的优势  169
6.1.3 MySQL Workbench 的安装  169
6.2 SQL Development的基本操作   171
6.2.1 创建数据库连接  171
6.2.2 创建新的数据库  173
6.2.3 创建和删除新的数据表  174
6.2.4 添加、修改表记录  177
6.2.5 查询表记录  178
6.2.6 修改表结构  178
6.3 Data Modeling的基本操作  179
6.3.1 建立 ER模型  179
6.3.2 导入 ER模型  184
6.4 Server Administration的基本操作  185
6.4.1 管理 MySQL用户  186
6.4.2 备份 MySQL数据库  188
6.4.3 还原 MySQL数据库  191
6.5 小结  192
第7章  SQL性能优化  193
7.1 优化简介  193
7.2 MySQL Query Optimizer概述  194
7.3 SQL 语句优化的基本思路 194
7.4 利用 EXPLAIN分析查询语句   196
7.4.1 EXPLAIN语句的基本语法   196
7.4.2 EXPLAIN语句分析实例   208
7.5 利用 Profiling分析查询语句 212
7.6 合理地使用索引  216
7.6.1 索引对查询速度的影响  216
7.6.2 如何使用索引查询  217
7.7 不同类型 SQL语句优化方法 220
7.7.1 优化 INSERT语句  220
7.7.2 优化 ORDER BY语句   221
7.7.3 优化 GROUP BY语句   222
7.7.4 优化嵌套查询  223
7.7.5 优化 OR条件. 224
7.7.6 优化插入记录的速度  226
7.8 优化数据库结构  228
7.8.1 将字段很多的表分解成多个表  228
7.8.2 增加中间表  230
7.8.3 增加冗余字段  231
7.9 分析表、检查表和优化表  232
7.9.1 分析表  232
7.9.2 检查表  233
7.9.3 优化表  233
7.10 小结   234
第8章  MySQL服务器性能优化  235
8.1 MySQL源码安装的性能优化   235
8.2 MySQL服务器配置优化   238
8.2.1 查看性能参数的方法  238
8.2.2 key_buffer_size的设置  243
8.2.3 table_cache的设置  246
8.2.4 内存参数的设置  248
8.2.5 日志和事务参数的设置  252
8.2.6 存储和 I/O相关参数的设置 253
8.2.7 其他重要参数的设置  254
8.3 MySQL日志设置优化   256
8.4 MySQL I/O设置优化. 257
8.5 MySQL并发设置优化   259
8.6 线程、Table Cache和临时表的优化  261
8.6.1 线程的优化  261
8.6.2 关于 table_cache相关的优化   262
8.6.3 关于临时表的优化  263
8.7 小结  264
第 9章  MySQL性能监控  265
9.1 基本监控系统方法  265
9.1.1 ps命令 265
9.1.2 top命令   266
9.1.3 vmstat命令 268
9.1.4 mytop命令 269
9.1.5 sysstat工具 272
9.2 开源监控利器 Nagios实战 277
9.2.1 安装 Nagios之前的准备工作  277
9.2.2 安装 Nagios主程序  279
9.2.3 整合 Nagios到Apache服务 280
9.2.4 安装 Nagios插件包  284
9.2.5 监控服务器的 CPU、负载、磁盘 I/O使用情况  286
9.2.6 配置 Nagios监控 MySQL服务器 291
9.3 MySQL监控利器 Cacti实战 293
9.3.1 Cacti工具的安装  294
9.3.2 Cacti监控 MySQL服务器 299
9.4 小结  304
第 10章  MySQL Replication 305
10.1 MySQL Replication概述  305
10.2 Windows环境下的 MySQL主从复制 306
10.2.1 复制前的准备工作   306
10.2.2 Windows环境下实现主从复制  306
10.2.3 Windows环境下主从复制测试  314
10.3 Linux环境下的 MySQL复制  315
10.3.1 下载并安装 MySQL 5.6   315
10.3.2 单机主从复制前的准备工作   316
10.3.3 mysqld_multi实现单机主从复制  320
10.3.4 不同服务器之间实现主从复制   328
10.3.5 MySQL 主要复制启动选项   329
10.3.6 指定复制的数据库或者表   330
10.4 查看 Slave的复制进度  338
10.5 日常管理和维护   339
10.5.1 了解服务器的状态   339
10.5.2 服务器复制出错的原因   340
10.6 切换主从服务器   343
10.7 小结   347
第 11章  MySQL Cluster实战  348
11.1 MySQL Cluster概述  348
11.1.1 MySQL Cluster基本概念   348
11.1.2 理解 MySQL Cluster节点   349
11.2 Linux环境下 MySQL Cluster安装和配置 350
11.2.1 安装 MySQL Cluster 7.2.8软件  352
11.2.2 管理节点配置步骤   357
11.2.3 配置 SQL节点和数据节点. 358
11.3 管理 MySQL Cluster  358
11.3.1 Cluster的启动  358
11.3.2 Cluster的测试  360
11.3.3 Cluster的关闭  363
11.4 维护 MySQL Cluster  363
11.4.1 Cluster的日志的管理  366
11.4.2 Cluster的联机备份  367
11.4.3 Cluster的数据恢复  368
11.5 Windows操作系统中配置 Cluster   369
11.6 小结   374
第 12章企业中 MySQL的高可用架构 375
12.1 MySQL高可用的简单介绍  375
12.2 MySQL主从复制  375
12.2.1 MySQL主从架构设计  376
12.2.2 配置环境   376
12.2.3 服务器的安装配置   376
12.2.4 LVS的安装配置  379
12.3 MySQL+DRBD+HA.381
12.3.1 什么是 DRBD   381
12.3.2 MySQL+DRBD+HA架构设计  382
12.3.3 配置环境   382
12.3.4 安装配置 Heartbeat  383
12.3.5 安装配置 DRBD   385
12.4 Lvs+Keepalived+MySQL单点写入主主同步方案   388
12.4.1 配置环境   388
12.4.2 Lvs+Keepalived的安装  393
12.4.3 Lvs+Keepalived的配置  394
12.4.4 Master和 Backup的启动 397
12.5 MMM高可用 MySQL方案  397
12.5.1 MMM的架构   398
12.5.2 配置环境   398
12.5.3 MMM的安装   402
12.5.4 Monitor服务器的配置  402
12.5.5 各个数据库服务器的配置   404
12.5.6 MMM的管理   404
12.6 小结  405
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MySQL技术精粹---架构、高级特性、性能优化与集群实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>监管华尔街
第一部分 金融架构
金融监管架构
中央银行的权力与联邦储备系统的未来
消费者金融保护
第二部分 系统性风险
第4章 对系统性风险的测算
第5章 系统性风险税
第6章 资本、或有资本以及流动性要求
第7章 大型银行和沃克尔规则
第8章 清算授权
第9章 系统性风险和保险公司的监管
第三部分 影子银行
第10章 货币市场基金如何避免跌破
第11章 回购协议（回购）市场
第12章 对冲基金、共同基金和交易所基金
第13章 场外衍生品的监管
第四部分 信贷市场
第14章 政府支持企业（GSEs）
第15章 信用评级机构的监管
第16章 证券化改革
第五部分 公司控制权
第17章 改革薪酬及公司治理
第18章 会计体系和金融改革
结语
关于作者
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>监管华尔街
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云原生服务网格Istio：原理、实践、架构与源码解析
原理篇
第1章 你好，Istio
第2章 Istio架构概述
第3章 非侵入的流量治理
第4章 可扩展的策略和遥测
第5章 可插拔的服务安全
第6章 透明的Sidecar机制
第7章 多集群服务治理
实践篇
第8章 环境准备
第9章 流量监控
第10章 灰度发布
第11章 流量治理
第12章 服务保护
第13章 多集群管理
架构篇
第14章 司令官Pilot
第15章 守护神Mixer
第16章 安全碉堡Citadel
第17章 高性能代理Envoy
第18章 代理守护进程Pilot-agent
第19章 配置中心Galley
源码篇
第20章 Pilot源码解析
第21章 Mixer源码解析
第22章 Citadel源码解析
第23章 Envoy源码解析
第24章 Galley源码解析
结语
附录A 源码仓库介绍
附录B 实践经验和总结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云原生服务网格Istio：原理、实践、架构与源码解析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>TCP/IP架构、设计及应用
第1章 引言	1
1.1 TCP/IP协议栈概述	2
1.1.1 沿协议栈向下的处理过程	2
1.1.2 沿协议栈向上的处理过程	4
1.2 Linux 2.4.20的源码组织结构	6
1.3 TCP/IP协议栈和内核控制路径	9
1.4 版本2.4之后Linux内核的可抢占性	10
1.4.1 Linux系统调用	13
1.4.2 添加新的系统调用	14
1.5 Linux进程和线程	16
1.5.1 fork()	17
1.5.2 线程	17
1.5.3 内核线程	18
1.6 内核同步机制	20
1.6.1 信号量	20
1.6.2 原子操作	21
1.6.3 旋转锁	21
1.7 TCP/IP应用编程接口	22
1.7.1 服务器应用	23
1.7.2 客户端应用	25
1.7.3 套接字选项	27
1.7.4 选项值	27
1.8 Shutdown	33
1.8.1 关闭功能在内核的实现	33
1.8.2 发送关闭	33
1.8.3 接收关闭	34
1.9 I/O	35
1.9.1 read()	35
1.9.2 write()	35
1.9.3 recv()	35
1.9.4 send()	35
1.9.5 select()	36
1.10 TCP状态	36
1.10.1 部分关闭	41
1.10.2 部分关闭的tcpdump输出	43
1.11 本章总结	43
第2章 协议基础	45
2.1 TCP	46
2.2 TCP选项(RFC 1323)	49
2.2.1 mss选项	50
2.2.2 窗口缩放选项	50
2.2.3 时间戳选项	51
2.2.4 有选择确认选项	51
2.3 TCP数据流	53
2.4 延时确认	60
2.5 Nagle算法(RFC 896)	62
2.6 TCP滑动窗口协议	64
2.7 最大化TCP吞吐量	71
2.8 TCP定时器	73
2.8.1 重传定时器	73
2.8.2 persistent定时器	74
2.8.3 keepalive定时器	75
2.8.4 TIME_WAIT定时器	75
2.9 TCP拥塞控制	76
2.10 TCP性能和可靠性	76
2.10.1 RTTD	77
2.10.2 SACK/DSACK	77
2.10.3 窗口缩放	77
2.11 IP(Internet协议)	78
2.12 路由	79
2.13 netstat	80
2.14 traceroute	81
2.15 ICMP	84
2.16 Ping	84
2.17 ARP/RARP	86
2.18 本章总结	88
第3章 套接字的内核实现	89
3.1 套接字层	90
3.2 VFS和套接字	91
3.3 协议套接字注册	92
3.4 结构inet_protosw	94
3.5 内核中的套接字组织结构	95
3.6 socket	96
3.7 inet_create(见源码3-4)	97
3.8 套接字调用流程图	104
3.9 本章总结	105
第4章 TCP连接设置的内核实现	107
4.1 连接设置	108
4.1.1 服务器端设置	108
4.1.2 服务器端操作	109
4.2 BIND	109
4.2.1 套接字BIND相关的数据结构	110
4.2.2 TCP bind的hash桶	110
4.2.3 tcp_ehash	111
4.2.4 tcp_listening_hash	112
4.2.5 tcp_bhash	112
4.2.6 tcp_hashinfo	113
4.2.7 tcp_bind_hashbucket(见图4-6)	114
4.2.8 tcp_bind_bucket	114
4.2.9 bind()	115
4.2.10 sys_bind()	115
4.2.11 sockfd_lookup()	116
4.2.12 fget()	116
4.2.13 inet_bind()	116
4.2.14 tcp_v4_get_port()	117
4.2.15 tcp_bind_conflict()	119
4.3 LISTEN	121
4.3.1 sys_listen()	122
4.3.2 inet_listen()	122
4.3.3 tcp_listen_start()	122
4.3.4 listen控制流	125
4.3.5 结构open_request	126
4.3.6 accept队列已满	131
4.3.7 链接在tcp_ehash hash表中的已建立套接字	134
4.3.8 当三次握手未完成时连接请求的状态	134
4.3.9 当三次握手完成后连接请求的状态	135
4.4 内核对连接请求的处理	136
4.4.1 SYN队列处理	137
4.4.2 accept队列处理	138
4.4.3 处理新连接请求的流程	140
4.5 ACCEPT	140
4.5.1 inet_accept()	143
4.5.2 当三次握手完成且应用程序接受后链接inode和套接字数据结构	143
4.5.3 新连接已建立后链接VFS和内核套接字数据结构	146
4.5.4 新已接受连接套接字的文件表入口项	146
4.5.5 接受新建立连接的流控制	147
4.6 客户端设置	147
4.6.1 客户端操作	147
4.6.2 connect	147
4.6.3 tcp_v4_connect()	148
4.6.4 ip_route_connect()	148
4.6.5 生成连接请求的流控制	149
4.6.6 tcp_v4_hash_connect()	151
4.6.7 __tcp_v4_check_established()	152
4.6.8 tcp_connect()	155
4.6.9 tcp_transmit_skb()	157
4.7 本章总结	159
第5章 sk_buff和协议头	161
5.1 结构sk_buff	162
5.2 结构skb_shared_info(见图5-3)	166
5.3 sk_buff和DMA-skb_frag_struct	166
5.3.1 DMA和分段sk_buff	167
5.3.2 sk_buff和IP分段	167
5.3.3 sk_buff和分段	169
5.4 sk_buff的例程操作	169
5.4.1 alloc_skb()	169
5.4.2 skb_reserve()	170
5.4.3 skb_put()	171
5.4.4 skb_push()	173
5.4.5 skb_pull()	174
5.5 构建向下遍历协议层时的协议头	175
5.5.1 TCP头的添加	175
5.5.2 IP头的添加	176
5.5.3 链路层头的添加	177
5.6 解析向上遍历协议层时的协议头	178
5.6.1 sk_buff指向链路层驱动要处理的链路层头	178
5.6.2 sk_buff指向IP层要处理的IP头	179
5.6.3 sk_buff指向TCP层要处理的TCP头	180
5.7 本章总结	181
第6章 sk_buff在不同协议层的处理	183
6.1 TCP/IP协议栈向下的报文处理	184
6.1.1 从套接字层到设备的报文传输路径	185
6.1.2 TCP报文沿协议栈向下处理的内核路径	187
6.2 准备传输的报文	192
6.3 报文向下处理的内核流	193
6.4 协议栈向上的报文处理过程	195
6.4.1 从设备(接收)到套接字层的报文处理路径	198
6.4.2 TCP报文沿协议栈向上的内核处理路径	198
6.5 沿协议栈向上的报文内核流程	205
6.6 本章总结	205
第7章 TCP发送	207
7.1 TCP分段单元	207
7.1.1 无分散-聚集支持下的分段单元处理	208
7.1.2 无分散-聚集支持的分段处理	210
7.1.3 通过套接字写1 mss字节的数据	211
7.2 分散-聚集支持的分段处理	212
7.2.1 有分散-聚集支持的分段处理	215
7.2.2 应用程序向套接字写Y字节的数据	216
7.2.3 can_coalesce()	216
7.2.4 tcp_copy_to_page()	217
7.2.5 tcp_mark_push()	217
7.2.6 forced_push()	218
7.2.7 tcp_push()	218
7.2.8 __tcp_push_pending_frames()	219
7.2.9 tcp_snd_test()	220
7.2.10 tcp_nagle_check()	220
7.2.11 tcp_minshall_check()	221
7.2.12 tcp_write_xmit()	221
7.2.13 update_send_head()	223
7.2.14 tcp_push_one()	224
7.2.15 skb_entail()	224
7.3 发送OOB数据	225
7.4 TCP分段单元和发送处理流程	226
7.5 分段和发送机制的函数调用流	227
7.6 本章总结	229
第8章 TCP接收	231
8.1 排队机制	231
8.1.1 tcp_rcv_established()的处理	232
8.1.2 tcp_prequeue()	234
8.1.3 队列处理	235
8.1.4 tcp_data_wait()	239
8.1.5 tcp_prequeue_process()	240
8.1.6 lock_sock()	241
8.1.7 __lock_sock()	241
8.1.8 release_sock()	242
8.1.9 __release_sock()	242
8.2 接收队列中TCP数据的处理	243
8.2.1 cleanup_rbuf()	246
8.2.2 skb_copy_datagram_iovec()	248
8.2.3 从接收缓冲区读取无分页的数据	250
8.2.4 应用程序读取X个字节	250
8.2.5 应用程序读取n个字节(1 mss = n)	251
8.2.6 应用程序读取n–X个字节	252
8.2.7 从分页缓冲区读取数据	253
8.2.8 应用程序读取n个字节	253
8.2.9 应用程序读取1页的数据	254
8.3 TCP紧急数据处理	255
8.3.1 紧急字节读取的OOB数据模式	255
8.3.2 tcp_recv_urg()	256
8.3.3 紧急模式处理和紧急字节读取的内联数据模式	257
8.4 通过TCP套接字接收数据的数据流图	260
8.5 本章总结	266
第9章 TCP内存管理	267
9.1 发送端TCP内存管理	267
9.1.1 select_size()	270
9.1.2 tcp_alloc_pskb()	271
9.1.3 alloc_skb()	272
9.1.4 tcp_alloc_page()	273
9.1.5 skb_charge()	274
9.1.6 tcp_mem_schedule()	274
9.1.7 tcp_free_skb()	276
9.1.8 sock_wfree()	277
9.1.9 tcp_write_space()	277
9.1.10 tcp_mem_reclaim()	278
9.1.11 __tcp_mem_reclaim()	279
9.1.12 wait_for_tcp_memory()	279
9.2 接收端TCP内存管理	282
9.2.1 tcp_prune_queue()	285
9.2.2 tcp_clamp_window()	286
9.2.3 tcp_collapse_ofo_queue()	288
9.2.4 tcp_collapse()	289
9.2.5 __skb_queue_purge()	296
9.3 接收缓冲区内存释放	296
9.4 TCP内存管理中的系统级控制参数	296
9.5 本章总结	298
第10章 TCP定时器	299
10.1 Linux中的定时器	300
10.1.1 mod_timer()	300
10.1.2 detach_timer()	301
10.1.3 del_timer()	301
10.1.4 执行定时器例程的时机	302
10.2 TCP重传定时器	302
10.2.1 安装重传定时器的时机	302
10.2.2 重置或者取消重传定时器的时机	303
10.2.3 tcp_enter_loss()	306
10.2.4 tcp_retransmit_skb()	308
10.2.5 tcp_retrans_try_collapse()	309
10.2.6 skb_cloned()	311
10.3 零窗口探测定时器	312
10.3.1 首次安装探测定时器的时机	312
10.3.2 取消连接探测定时器的时机	313
10.3.3 tcp_ack_probe()	313
10.3.4 窗口探测定时器的工作原理	314
10.3.5 tcp_probe_timer()	314
10.3.6 tcp_send_probe0()	315
10.3.7 tcp_write_wakeup()	316
10.4 延时确认定时器	318
10.4.1 ACK的调度时机	319
10.4.2 ACK数据段的发送时机和发送处理过程	320
10.4.3 快速ACK模式	321
10.4.4 __tcp_ack_snd_check()	321
10.4.5 tcp_ack_snd_check()	322
10.4.6 tcp_send_delayed_ack()	323
10.4.7 tcp_delack_timer()	324
10.4.8 tcp_reset_xmit_timer()	326
10.4.9 tcp_write_timer()	327
10.4.10 tcp_clear_xmit_timer()	328
10.5 keepalive定时器	329
10.5.1 激活keepalive定时器的时机	330
10.5.2 如何重置定时器	330
10.5.3 tcp_keepalive_timer()	330
10.6 SYN-ACK定时器	333
10.6.1 SYN-ACK定时器激活的时机	333
10.6.2 SYN-ACK定时器停止的时机	333
10.6.3 tcp_synack_timer()	334
10.7 TIME_WAIT定时器	338
10.7.1 TIME_WAIT定时器的触发时机	338
10.7.2 tcp_time_wait()	338
10.7.3 tcp_tw_schedule()	339
10.7.4 非再生模式	341
10.7.5 再生模式	342
10.7.6 tcp_twkill()	345
10.7.7 tcp_twcal_tick()	347
10.7.8 __tcp_tw_hashdance()	350
10.8 本章总结	352
第11章 TCP核心处理	353
11.1 传入TCP数据段处理	354
11.1.1 预测标志	354
11.1.2 构建预测标志	355
11.1.3 使用快速路径的条件	357
11.1.4 使用慢速路径的时机	357
11.1.5 使用快速路径的时机	358
11.1.6 与预测标志相关的注意点	358
11.2 快速路径处理	359
11.3 慢速路径处理	362
11.3.1 tcp_sequence()	363
11.3.2 tcp_replace_ts_recent()	364
11.3.3 tcp_event_data_recv()	365
11.3.4 tcp_incr_quickack()	367
11.3.5 tcp_grow_window()	367
11.3.6 __tcp_grow_window()	369
11.3.7 计算通告窗口	370
11.3.8 tcp_receive_window()	370
11.3.9 tcp_select_window()	371
11.3.10 tcp_space()	372
11.3.11 tcp_data_snd_check()	372
11.3.12 __tcp_data_snd_check()	373
11.3.13 tcp_paws_discard()	373
11.4 传入ACK的处理	375
11.4.1 tcp_packets_in_flight()	378
11.4.2 tcp_ack_is_dubious()	379
11.4.3 tcp_cong_avoid()	380
11.4.4 tcp_ack_update_window()	381
11.4.5 tcp_may_update_window()	382
11.4.6 tcp_clean_rtx_queue()	382
11.5 处理SACK块	385
11.6 重定序长度	392
11.7 处理TCP紧急指针	395
11.8 在慢速路径中处理数据段	99
11.8.1 tcp_sack_new_ofo_skb()	407
11.8.2 tcp_sack_maybe_coalesce()	409
11.8.3 tcp_sack_extend()	410
11.8.4 tcp_ofo_queue()	411
11.8.5 tcp_sack_remove()	415
11.9 TCP核心处理	417
11.10 本章总结	418
第12章 TCP状态处理	419
12.1 拥塞状态处理概述	420
12.2 TCP状态	422
12.2.1 TCP_CA_CWR	422
12.2.2 从TCP_CA_CWR状态撤消	423
12.3 在恢复状态中处理重复/部分确认	423
12.3.1 tcp_remove_reno_sacks()	424
12.3.2 tcp_try_undo_partial()	425
12.4 在丢失状态中处理重复/部分确认	426
12.4.1 tcp_try_undo_loss()	427
12.4.2 tcp_check_sack_reneging()	429
12.5 TCP状态的默认处理	429
12.5.1 tcp_time_to_recover()	432
12.5.2 tcp_head_timedout()	434
12.5.3 tcp_try_to_open()	435
12.5.4 tcp_update_scoreboard()	436
12.5.5 tcp_xmit_retransmit_queue()	438
12.5.6 tcp_packet_delayed()	440
12.6 当确认超过tp→high_seq时TCP非正常状态的处理	440
12.6.1 TCP_CA_Loss	441
12.6.2 TCP_CA_CWR	441
12.6.3 TCP_CA_Disorder	443
12.6.4 tcp_try_undo_dsack	444
12.6.5 TCP_CA_Recovery	444
12.6.6 tcp_add_reno_sack()	446
12.6.7 tcp_check_reno_reordering()	446
12.6.8 tcp_may_undo()	447
12.6.9 tcp_packet_delayed()	447
12.6.10 tcp_undo_cwr()	448
12.6.11 tcp_mark_head_lost()	449
12.6.12 tcp_sync_left_out()	450
12.7 本章总结	450
第13章 netlink套接字	453
13.1 netlink套接字介绍	453
13.2 启动时netlink套接字的注册和初始化	454
13.3 内核netlink套接字的创建	455
13.4 用户netlink套接字的创建	457
13.5 netlink数据结构	459
13.5.1 nl_table	459
13.5.2 rtnetlink_link	460
13.6 其他重要的数据结构	463
13.6.1 nlmsghdr结构	463
13.6.2 msghdr结构	463
13.7 netlink报文格式	464
13.8 netlink套接字例子—— 添加qdisc的tc命令	465
13.8.1 用户空间中添加qdisc的tc命令流	465
13.8.2 内核空间的tc命令	466
13.9 内核空间中的tc命令流程图	470
13.10 本章总结	471
第14章 IP路由	473
14.1 路由	475
14.2 基于策略的路由	477
14.3 多路径	478
14.4 记录路由选项(RFC 791)以及Linux栈的处理	482
14.5 源路由	483
14.5.1 严格记录路由	483
14.5.2 松散记录路由	483
14.5.3 SRR处理实现	484
14.6 路由表和路由缓存的Linux内核实现	490
14.7 路由缓存实现概述	491
14.8 管理路由缓存	496
14.8.1 本地连接的路由缓存	498
14.8.2 __sk_dst_check()	499
14.8.3 链接失效并报告给路由子系统	500
14.8.4 dst_link_failure()	501
14.8.5 ipv4_link_failure()	501
14.8.6 dst_set_expires()	501
14.8.7 传入报文的路由缓存	502
14.8.8 路由缓存计数器	503
14.8.9 rt_periodic_timer	504
14.8.10 rt_may_expire()	506
14.8.11 dst_free()	507
14.8.12 __dst_free()	508
14.8.13 dst_destroy()	509
14.8.14 dst_run_gc()	509
14.8.15 关闭接口和rt_flush_timer	511
14.8.16 rt_cashe_flush()	512
14.9 转发信息库的实现概述	513
14.9.1 结构fib_table	515
14.9.2 结构fn_hash	516
14.9.3 结构fn_zone	516
14.9.4 结构fib_node	517
14.9.5 结构fib_info	519
14.9.6 结构fib_nh	520
14.9.7 结构fib_rule	521
14.10 使用ip命令在路由表中添加新的表项(RT Netlink接口)	522
14.10.1 当使用向路由表中添加一个表项的路由选项运行ip命令时的情况	523
14.10.2 inet_rtm_newroute()	523
14.10.3 结构rtmsg	524
14.10.4 结构kern_rta	525
14.10.5 fn_hash_insert()	525
14.10.6 fn_new_zone()	528
14.10.7 fib_create_info()	530
14.10.8 fn_hash_insert()	531
14.11 当使用向路由表中添加一个表项的规则选项运行ip命令时的情况	532
14.11.1 inet_rtm_newrule()	532
14.11.2 FIB初始化	534
14.12 FIB遍历流程图	538
14.12.1 ip_route_output()	539
14.12.2 ip_route_output_key()	539
14.12.3 ip_route_output_slow()	540
14.12.4 ip_dev_find()	551
14.12.5 __in_dev_get()	552
14.12.6 inet_select_addr()	553
14.12.7 路由范围	554
14.12.8 fib_lookup()	555
14.13 本章总结	563
第15章 Linux中的IP服务质量(IP QoS)	565
15.1 简介	565
15.2 Linux流量控制的基本组件	566
15.3 Linux中pfifo_fast排队规则的实现	567
15.4 排队规则数据结构	570
15.4.1 结构Qdisc	570
15.4.2 结构Qdisc_ops	571
15.4.3 结构Qdisc_class_ops	572
15.4.4 结构cbq_class	573
15.5 tc用户程序及其内核实现细节	575
15.5.1 tc_modify_qdisc()	576
15.5.2 qdisc_create()	578
15.5.3 cbq_init()	579
15.5.4 qdisc_graft()	580
15.5.5 dev_graft_ qdisc()	581
15.6 为CBQ创建类别层次的tc命令	582
15.6.1 tc_ctl_tclass()	582
15.6.2 cbq_change_class()	584
15.7 过滤器	585
15.8 u32过滤器实现	589
15.9 路由过滤器实现	592
15.10 enqueue	596
15.10.1 cbq_enqueue()	596
15.10.2 cbq_classify()	597
15.10.3 cbq_enqueue()函数概述	598
15.11 CBQ的Linux实现概述	599
15.12 cbq_dequeue()	599
15.12.1 从net/dev/core.c	601
15.12.2 qdisc_run()	602
15.12.3 qdisc_ restart ()	603
15.12.4 cbq_dequeue ()	604
15.12.5 cbq_dequeue_1()	605
15.12.6 cbq_dequeue_prio()	605
15.13 本章总结	609
第16章 IP Filter防火墙	611
16.1 Netfilter Hook框架	612
16.2 IP协议栈上的Netfilter Hook	613
16.2.1 用于传出报文的钩子	614
16.2.2 用于传入报文的钩子	615
16.3 Netfilter Hook注册	616
16.4 Netfilter Hook处理	618
16.4.1 nf_hook_slow()	618
16.4.2 nf_iterate()	619
16.4.3 结构nf_hook_ops	620
16.5 兼容性框架	620
16.6 ipchains	624
16.6.1 使用ipchains过滤	625
16.6.2 ipchains的规则链	626
16.6.3 结构ipchain	626
16.6.4 结构ip_fwkernel	627
16.6.5 结构ip_reent	627
16.6.6 结构ip_fw	628
16.6.7 ipchains中表的组织结构	628
16.7 使用ipchains过滤报文	629
16.7.1 ip_fw_check()	629
16.7.2 ip_rule_match()	632
16.8 iptables	634
16.9 iptables过滤规则和目标组织	635
16.9.1 结构ipt_table	636
16.9.2 结构ipt_table_info	636
16.9.3 结构ipt_entry	638
16.9.4 结构ipt_entry_match	639
16.9.5 结构ipt_tcp	640
16.9.6 结构ipt_entry_target	641
16.9.7 结构ipt_standard_target	641
16.10 iptables过滤规则和目标的组织结构	641
16.11 使用iptables过滤报文	641
16.11.1 ipt_do_table()	642
16.11.2 IPT_MATCH_ITERATE	645
16.12 本章总结	646
第17章 网络软中断	647
17.1 使用软中断的原因和触发机制	648
17.1.1 传输	648
17.1.2 接收	648
17.2 处理软中断	651
17.3 软中断的注册	654
17.4 报文接收以及Rx软中断的延迟处理	655
17.5 网络Rx软中断的处理	659
17.6 报文传输与软中断	663
17.7 本章总结	672
第18章 报文的传输和接收	675
18.1 传输和接收报文的DMA环缓冲区	675
18.2 报文接收处理	676
18.2.1 支持DMA的报文接收处理流程	677
18.2.2 环缓冲区的接收处理	677
18.3 报文传输处理	679
18.3.1 DMA支持的报文传输处理过程	679
18.3.2 传输环缓冲区	680
18.4 报文传输和接收的实现	682
18.4.1 struct etrax_eth_descr	683
18.4.2 struct etrax_dma_descr	683
18.4.3 设备的初始化	684
18.4.4 DMA传输环缓冲区的初始化	685
18.4.5 DMA接收环缓冲区的初始化	686
18.5 处理报文接收的Rx中断	688
18.5.1 Rx DMA缓冲区的初始化	689
18.5.2 e100_rx()	689
18.5.3 产生Rx中断前DMA缓冲区接收到三个报文时的Rx描述符	690
18.5.4 从DMA缓冲区中取出第一个报文交给操作系统Rx中断处理程序后的Rx描述符	691
18.6 报文传输	693
18.6.1 e100_send_packet()	693
18.6.2 初始化后的Tx DMA环缓冲区描述符	694
18.6.3 e100_hardware_send_packet()	696
18.6.4 设备DMA Tx环缓冲区中有两个报文时的处理	696
18.6.5 e100tx_interrupt()	697
18.6.6 传输了第一个报文并且中断已产生时的情形	698
18.7 本章总结	699
第19章 lkcd和TCP/IP协议栈的调试	701
19.1 lkcd源码和补丁	702
19.2 套接字	702
19.3 查看接收套接字缓冲区	704
19.4 查看发送套接字缓冲区	705
19.5 TCP分段单元	708
19.6 发送拥塞窗口和ssthresh	709
19.7 重传和路由	711
19.8 查看连接队列和SYN队列	712
19.9 使用lcrash来查看路由和IP服务质量	715
19.10 使用lcrash调试CBQ(基于类别的)排队规则	717
19.11 u32过滤器	718
19.12 路由过滤器	724
19.13 FIB表的lcrash输出	724
19.14 使用tc命令建立路由过滤器	728
19.15 NETLINK数据结构	731
19.15.1 nl_table	731
19.15.2 rtnetlink_link	732
19.16 本章总结	733
第20章 展望	735
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>TCP/IP架构、设计及应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云原生基础架构
前言 1
第1章 什么是云原生基础架构 9
1.1 云原生的益处 10
1.2 服务器 11
1.3 虚拟化 11
1.4 基础架构即服务 12
1.5 平台即服务 13
1.6 云原生基础架构 14
1.7 什么不是云原生基础架构 15
1.8 云原生应用 17
1.9 云原生应用如何影响基础架构 25
总结 26
第2章 何时采用云原生 27
2.1 应用 28
2.2 人 29
2.3 系统 29
2.4 业务 31
2.5 何时不需要云原生基础架构 32
总结 35
第3章 云原生部署的演进 37
3.1 表述基础架构 38
3.2 部署工具 46
总结 50
第4章 设计基础架构应用 52
4.1 引导问题 53
4.2 API 54
4.3 万物的状态 55
4.4 协调器模式 59
4.5 协调器模式的方法 63
4.6 审计关系 65
总结 67
第5章 开发基础架构应用 69
5.1 设计API 69
5.2 添加特征 70
5.3 弃用特征 71
5.4 改变基础架构 73
总结 76
第6章 云原生基础架构测试 77
6.1 测试的内容是什么 78
6.2 编写可测试代码 79
6.3 自知 82
6.4 测试类型 84
6.5 监控基础架构 95
总结 96
第7章 云原生应用管理 97
7.1 应用设计 98
7.2 实现云原生模式 99
7.3 应用的生命周期 100
7.4 应用对基础架构的要求 104
总结 111
第8章 保护应用程序 113
8.1 策略即代码 113
8.2 审计基础架构 120
8.3 不可变基础架构 122
总结 123
第9章 实现云原生基础架构 125
9.1 关注变革的地方 126
9.2 预测未来 131
总结 132
附录A 网络弹性模式 134
附录B 关于被锁定 140
附录C Box公司案例研究 143
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云原生基础架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MongoDB权威指南
第1 章　简介　　1
1.1　丰富的数据模型　　1
1.2　容易扩展　　　1
1.3　丰富的功能　　　　2
1.4　不牺牲速度　　　　3
1.5　简便的管理　　　　3
1.6　其他内容　　　3
第2 章　入门　　5
2.1　文档　　5
2.2　集合　　6
2.2.1　无模式　　　　6
2.2.2　命名　　　　7
2.3　数据库　　　8
2.4　启动mongodb　　9
2.5　mongodb shell　　　　　　10
2.5.1　运行shell　　　　10
2.5.2　mongodb 客户端　　11
2.5.3　shell 中的基本操作　　11
2.5.4　使用shell 的窍门　　　　13
.2.6　数据类型　　　　15
2.6.1　基本数据类型　　15
2.6.2　数字　　17
2.6.3　日期　　18
2.6.4　数组　　19
2.6.5　内嵌文档　　　　19
2.6.6　_id 和objectid　　　20
第3 章　创建、更新及删除文档　　　23
3.1　插入并保存文档　　　23
3.1.1　批量插入　　　　23
3.1.2　插入：原理和作用　　24
3.2　删除文档　　　　24
3.3　更新文档　　　　25
3.3.1　文档替换　　　　26
3.3.2　使用修改器　　27
3.3.3　upsert　　　　36
3.3.4　更新多个文档　　38
3.3.5　返回已更新的文档　　38
3.4　瞬间完成　　　　41
3.4.1　安全操作　　　　41
3.4.2　捕获“常规”错误　　42
3.5　请求和连接　　　　43
第4 章　查询　　　　 45
4.1　find 简介　　　　45
4.1.1　指定返回的键　　46
4.1.2　限制　　46
4.2　查询条件　　　　47
4.2.1　查询条件　　　　47
4.2.2　or 查询　　47
4.2.3　$not　　　　48
4.2.4　条件句的规则　　49
4.3　特定于类型的查询　　　　49
4.3.1　null　　　49
4.3.2　正则表达式　　50
4.3.3　查询数组　　　　51
4.3.4　查询内嵌文档　　53
4.4　$where 查询　　　　55
4.5　游标　　　　56
4.5.2　避免使用skip 略过大量结果　　　58
4.5.3　高级查询选项　　60
4.5.4　获取一致结果　　61
4.6　游标内幕　　　　63
第5 章　索引　　　　 65
5.1　索引简介　　　　65
5.1.1　扩展索引　　　　67
5.1.2　索引内嵌文档中的键　　　　68
5.1.3　为排序创建索引　　　68
5.1.4　索引名称　　　　69
5.2　唯一索引　　　　69
5.2.1　消除重复　　　　69
5.2.2　复合唯一索引　　70
5.3　使用explain 和hint　　70
5.4　索引管理　　　　75
5.5　地理空间索引　　76
5.5.1　复合地理空间索引　　78
5.5.2　地球不是二维平面　　78
第6 章　聚合　　　　 79
6.1　count　　　79
6.2　distinct　　　　79
6.3　group　　　80
6.3.1　使用完成器　　82
6.3.2　将函数做为键使用　　84
6.4　mapreduce　　　　84
6.4.1　例1：找出集合中的所有键　　85
6.4.2　例2： 网页分类　　　　87
6.4.3　mongodb 和mapreduce　　　87
第7 章　进阶指南　　　　 91
7.1　数据库命令　　　　91
7.1.1　命令的工作原理　　　92
7.1.2　命令参考　　　　92
7.2　固定集合　　　　95
7.2.1　属性及用法　　96
7.2.2　创建固定集合　　96
7.2.3　自然排序　　　　97
7.2.4　尾部游标　　　　98
7.3　gridfs：储存文件　　　　99
7.3.1　开始使用gridfs：mongofiles　　99
7.3.2　通过mongodb 驱动程序操作gridfs　　　　100
7.3.3　内部原理　　100
7.4　服务器端脚本　　101
7.4.1　db.eval　　101
7.4.2　存储javascript 脚本　　　　102
7.4.3　安全性　　103
7.5　数据库引用　　　104
7.5.1　什么是dbref　　104
7.5.2　示例模式　　104
7.5.3　驱动对dbref 的支持　　　105
7.5.4　什么时候该使用dbref 呢　　106
第8 章　管理　　　 107
8.1　启动和停止mongodb　　107
8.1.1　从命令行启动　　　　107
8.1.2　配置文件　　109
8.1.3　停止mongodb　　　110
8.2　监控　　　110
8.2.1　使用管理接口　　　　110
8.2.2　serverstatus　　112
8.2.3　mongostat　　113
8.2.4　第三方插件　　　　113
8.3　安全和认证　　　114
8.3.1　认证的基础知识　　114
8.3.2　认证的工作原理　　115
8.3.3　其他安全考虑　　　　116
8.4　备份和修复　　　116
8.4.1　数据文件备份　　　　117
8.4.2　mongodump 和mongorestore　　117
8.4.3　fsync 和锁　　　　118
8.4.4　从属备份　　119
8.4.5　修复　　　　119
第9 章　复制　　　 121
9.1　主从复制　　　　121
9.1.1　选项　　　　122
9.1.2　添加删除源　　　　123
9.2　副本集　　　124
9.2.1　初始化副本集　　　　125
9.2.2　副本集中的节点　　127
9.2.3　故障切换和主节点选举　　　128
9.3　在从服务器上执行操作　　　　129
9.3.1　读扩展　　130
9.3.2　用从节点做数据处理　　130
9.4　工作原理　　　　130
9.4.1　oplog　　131
9.4.2　同步　　　　131
9.4.3　复制状态和本地数据库　　　132
9.4.4　阻塞复制　　132
9.5　管理　　　133
9.5.1　诊断　　　　133
9.5.2　变更oplog 的大小　　　　134
9.5.3　认证复制　　134
第10 章　分片　　 135
10.1　分片简介　　　　135
10.2　mongodb 中的分片　　　135
10.3　片键　　　137
10.3.1　将已有的集合分片　　137
10.3.2　递增片键还是随机片键 　137
10.3.3　片键对操作的影响　　138
10.4　建立分片　　　　139
10.4.1　启动服务器　　　139
10.4.2　切分数据　　140
10.5　生产配置　　140
10.5.1　健壮的配置　　　141
10.5.2　多个mongos　　　141
10.5.3　健壮的片　　141
10.5.4　物理服务器　　　142
10.6　管理分片　　　　142
10.6.1　配置集合　　142
10.6.2　分片命令　　143
第11 章　应用举例　　　　145
11.1　化学品搜索引擎：java　　145
11.2　新闻聚合器：php　　　　149
11.3　自定义提交表单：ruby　　154
11.4　实时分析: python　　157
附录a　安装mongodb　　　163
附录b　mongo：mongodb shell　　 167
附录c　深入mongodb 内部 　　169
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MongoDB权威指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大规模Web服务开发技术
目 录
第1章 大规模Web服务的开发定位——掌握整体	2
第0课 本书的起源——本书讲述的范围	3
从事大规模Web服务开发——面向大学生的Hatena实习	3
本书讲述的内容	3
本书不讲述的内容	5
致今后从事大规模Web服务的人	5
第1课 大规模服务和小规模服务	6
Hatena的服务规模	6
Hatena是大规模，Google、Facebook是超大规模	8
小规模服务和大规模服务的区别	9
应对大规模数据量	11
第2课 持续增长的服务和大规模化的障碍	13
Web服务的困难	13
Hatena的成长经历	13
系统增长战略——最小化开端、预见变化的管理和设计	17
第3课 服务开发现场	18
Hatena的技术团队体制	18
Hatena的沟通方式	19
服务开发的实际状况	19
开发所用的工具	21
总结	23
第2章 大规模数据处理入门
——内存和磁盘、Web应用程序和负载	24
第4课 Hatena Bookmark的数据规模	25
以Hatena Bookmark为例介绍大规模数据	25
Hatena Bookmark的数据规模	25
针对大规模数据的查询——处理大规模数据的感觉	26
第5课 大规模数据处理的难点——内存和磁盘	28
为何处理大规模数据如此困难——因为无法在内存中
计算	28
内存和磁盘的速度差异——内存要快105～106倍	28
为何磁盘这么慢？——内存和磁盘	29
操作系统层的加速处理	31
传输速度和总线的速度差异	31
第6课 可扩展性的要点	37
扩展和可扩展性	37
可扩展性的要点——CPU负载和I/O负载	38
Web应用程序和负载的关系	38
数据库的可扩展性很难保证	39
第7课 处理大规模数据的基础知识	44
面向程序员的大规模数据的基础	44
处理大规模数据的三个重点——写程序的技巧	44
处理大规模数据之前的三大前提知识——程序开发的
底层基础	45
第3章 操作系统的缓存和分布式
——高效处理大规模数据的原理	50
第8课 操作系统的缓存机制	51
在理解操作系统缓存的基础上编写应用程序——页面
缓存	51
虚拟内存机制	52
Linux页面缓存原理	54
VFS	56
Linux以页面为单位缓存磁盘	57
内存空闲时就缓存——通过sar确认	59
增加内存降低I/O负载	60
页面缓存是透明的	61
第9课 降低I/O负载的策略	67
以缓存为前提的降低I/O负载的策略	67
扩展到多台服务器——无法全部缓存的情况	68
单纯增加数量无法保证可扩展性	69
第10课 利用局部性的分布式	74
什么是利用局部性的分布式？	74
Partitioning——考虑局部性的分布式	75
根据访问模式分割成“岛”——考虑局部性的分布式	78
以页面缓存为前提的基本应用规则	79
第4章 数据库的横向扩展策略
——以分布式为基础的MySQL应用	82
第11课 正确应用索引
——分布式MySQL应用的大前提	83
分布式MySQL应用的三大要点	83
灵活应用操作系统缓存	83
索引的重点——B树	86
索引的效果	89
确认索引是否有效的方法——explain命令	92
第12课 MySQL的分布式
——以扩展为前提的系统设计	95
MySQL的replication功能	95
master/slave的特征——对参照系进行扩展，更新类
不扩展	96
第13课 MySQL的横向扩展和Partitioning	99
MySQL的横向扩展策略	99
关于Partitioning（表分割）的补充	99
以Partitioning为前提的设计	99
避免JOIN——利用where…in…	102
Partitioning的代价	103
第2～4章的小结	107
第5章 大规模数据处理“实践”入门
——应用程序开发的重点	108
第14课 特殊用途索引——处理大规模数据	109
索引和系统架构——超过RDBMS的处理能力时	109
特殊用途索引——使用调优后的数据结构	111
第15课 理论联系实践	115
探寻必须的技术条件	115
第2～5章小结	117
第6章 压缩编程
——考虑数据大小和I/O加速之间的关系	118
第16课 ［课题］以紧凑、简洁方式保存整数数据	119
以紧凑方式保存整数数据	119
出题意图——解决该课题有什么好处？	119
课题所用文件的内容	121
第17课 可变字节码和速度的感觉	122
可变字节码——用紧凑格式保存整数数据	122
可变字节码的伪代码	123
用“差”存储已排序整数	126
（补充）压缩的基础	126
（补充）压缩对象是整数的情形——背景理论	127
第18课 课题详解及解答范例	129
课题详解	129
（参考）pack()函数——将Perl内部数据结构以
二进制形式输出	131
（参考）二进制数据的read/write	133
（参考）性能分析	135
解答范例和思路	136
第7章 算法实用化
——从身边的例子来看理论、研究的实践投入	142
第19课 算法和算法评测	143
数据规模和复杂度的差异	143
何谓算法？	144
学习算法的意义——计算机资源有限，工程师的通用
语言	145
算法评测——复杂度记法	146
纸巾能折叠几次？——O(logn)和O(n)的差距	148
算法和数据结构——千丝万缕的联系	149
复杂度和常数项——评测很重要	150
应用算法的实际情况——简单就是美	151
灵活应用第三方实现——CPAN等	153
通过实例加深感受	155
第20课 Hatena Diary的关键字链接	156
什么是关键字链接？	156
最初的实现	156
出问题了！——关键字字典越来越大	157
用模式匹配实现关键字链接的问题	158
从正则表达式到Trie——改变匹配的实现方式	158
Aho-Corasick算法	160
换成Regexp::List	162
关键字链接的实现、变迁和考察	163
第21课 Hatena Bookmark的文章分类	164
什么是文章分类？	164
机器学习和大规模数据	165
大规模数据和Web服务——The Google Way of Science	166
贝叶斯过滤器的原理	167
算法实用化之路——Hatena Bookmark的实例	170
防守姿态和进攻姿态——从文档分类功能说开去	171
第8章 Hatena关键字链接的实现
——理解通向应用之路	176
第22课 ［课题］创建Hatena关键字链接	177
使用Aho-Corasick算法创建Hatena关键字链接	177
编写测试	180
第23课 解答范例和思路	182
解答范例	182
第9章 挑战全文搜索技术
——各种各样的大规模数据处理经验技巧	184
第24课 全文搜索技术的应用范围	185
用Hatena的数据创建搜索引擎	185
Hatena Diray的全文搜索——搜索服务之外的搜索
系统	185
Hatena Bookmark的全文搜索——满足细节要求的系统	187
第25课 搜索系统的架构	190
搜索系统所需的步骤	190
各种各样的搜索引擎	191
全文搜索的种类	193
第26课 搜索引擎的内部结构	198
逆向索引的结构——Dictionary+Postings	198
Dictionary的创建方法——逆向索引的创建方法 200
小结	210
Postings的创建方法——逆向索引的创建方法 211
关于评分的补充	213
参考文献	214
第10章 创建全文搜索引擎
——基本部分、改进、速度和准确度的要求	216
第27课 ［课题］创建Hatena Bookmark全文搜索	217
开发全文搜索引擎	217
课题内容	217
示例数据格式和数据大小	218
字典的组成——Dictionary、Postings	219
界面	220
基础部分+改进	220
以速度和准确度一决胜负	221
第28课 答案范例和思路	223
解答范例	223
indexer.pl的实现	223
searcher.pl的实现	225
可以改善的地方	227
第11章 支持大规模数据处理的服务器/基础设施入门
—— Web服务的后台	230
第29课 企业软件vs. Web服务	231
企业软件vs. Web服务——应用范围上的差异	231
Web服务的基础设施——三个重点	233
第30课 云vs.自行构建基础设施	235
云计算	235
云的优缺点	235
Hatena应用的云服务	236
自行构筑基础设施的优点	237
自行构建基础设施和垂直结合模型	239
Hatena的服务规模	240
Hatena Bookmark的系统架构图	240
第12章 保证可扩展性的必要思路
——规模扩大和系统扩展	242
第31课 层和可扩展性	243
对可扩展性的要求——一台服务器能处理的流量极限	243
各层的可扩展性	244
第32课 掌握负载进行调优	245
掌握负载——可视化的管理界面	245
测量负载的指标——平均负载、内存和CPU相关信息	247
根据用途进行调优——面向用户的服务器和面向爬虫
的服务器	247
应用程序服务器、数据库服务器的调优策略和服务器
数量	249
服务规模和调优	250
保证可扩展性	251
第13章 保证冗余性和系统的稳定化
——实现100%在线率的原理	252
第33课 保证冗余性	253
保证冗余性——应用程序服务器	253
保证冗余性——数据库服务器	254
保证冗余性——存储服务器	257
第34课 系统稳定化	261
保持系统稳定的权衡	261
系统的不稳定因素	262
第35课 系统稳定对策	267
实际的系统稳定对策——维持适当余量，消灭不稳定
因素	267
第14章 提高效率
——提高硬件资源的使用率	270
第36课 虚拟化技术	271
引入虚拟化技术	271
虚拟化技术的效果	272
虚拟服务器的构建策略	273
总结虚拟化的优势	275
虚拟化和运营——通过服务器管理工具在运营上发挥
虚拟化的优势	276
虚拟化的注意点	277
第37课 硬件和提高效率
——实现低成本的关键技术	280
提高处理器性能	280
内存和硬盘成本下降	281
有效利用廉价硬件——以虚拟化为前提的硬件应用	282
SSD	284
第15章 Web服务和网络
——通过网络看服务增长	288
第38课 网络的分界点	289
服务增长和网络的分界点	289
1Gbps的极限——PC路由器的极限	289
500台主机的极限——子网、ARP表的极限	290
网络架构的层次化	291
全球化	292
第39课 挑战更高的极限	295
超越10Gbps的世界	295
Hatena的基础设施——第11～15章的总结	296
第16章 特别篇 当前构建Web服务需要的实践技术
——应对大规模Web服务须知	298
特别篇第1课 作业队列系统TheSchwartz、Gearman	299
Web服务和请求	299
作业队列系统入门	299
Hatena的作业队列系统	300
通过日志进行分析	302
特别篇第2课 存储方式的选择RDBMS还是
key-value存储	303
如何保存不断增加的数据	303
选择存储系统的前提条件	304
存储系统的种类	305
RDBMS	305
分布式key-value存储	308
分布式文件系统	310
其他存储	312
存储系统的选择策略	314
特别篇第3课 缓存系统——Squid、Varnish	315
Web应用程序负载与代理/缓存系统	315
Squid——基本结构	317
Varnish	321
特别篇第4课 计算集群——Hadoop	323
大量日志数据的并行处理	323
MapReduce计算模型	323
Hadoop	325
索引	327
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大规模Web服务开发技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业安全建设指南
目录
序一
序二
序三
前言
第一部分　安全架构
第1章　企业信息安全建设简介2
1.1　安全的本质2
1.2　安全原则2
1.3　安全世界观4
1.4　正确处理几个关系4
1.5　安全趋势6
1.6　小结7
第2章　金融行业的信息安全8
2.1　金融行业信息安全态势8
2.2　金融行业信息安全目标10
2.3　信息安全与业务的关系：矛盾与共赢12
2.4　信息安全与监管的关系：约束与保护13
2.5　监管科技14
2.6　小结16
第3章　安全规划17
3.1　规划前的思考17
3.2　规划框架18
3.3　制订步骤19
3.3.1　调研19
3.3.2　目标、现状和差距20
3.3.3　制订解决方案22
3.3.4　定稿23
3.3.5　上层汇报23
3.3.6　执行与回顾23
3.4　注意事项24
3.5　小结24
第4章　内控合规管理25
4.1　概述25
4.1.1　合规、内控、风险管理的关系25
4.1.2　目标及领域25
4.1.3　落地方法26
4.2　信息科技风险管理26
4.2.1　原则27
4.2.2　组织架构和职责27
4.2.3　管理内容28
4.2.4　管理手段和流程29
4.2.5　报告机制30
4.2.6　信息科技风险监控指标32
4.3　监督检查34
4.4　制度管理36
4.5　业务连续性管理38
4.5.1　定义和标准38
4.5.2　监管要求39
4.5.3　BCM实施过程40
4.5.4　业务影响分析和风险评估40
4.5.5　BCP、演练和改进43
4.5.6　DRI组织及认证45
4.6　信息科技外包管理46
4.7　分支机构管理46
4.8　信息科技风险库示例47
4.9　小结49
第5章　安全团队建设50
5.1　安全团队建设的“痛点”50
5.2　安全团队面临的宏观环境54
5.3　安全团队文化建设56
5.4　安全团队意识建设63
5.5　安全团队能力建设67
5.5.1　确定目标，找准主要矛盾68
5.5.2　梳理和细分团队职能69
5.5.3　建立学习框架，提升知识和技能水平71
5.5.4　掌握学习方法，实现事半功倍的效果78
5.6　安全团队建设路径80
5.7　安全人员职业规划84
5.8　安全团队与其他团队的关系处理85
5.9　小结88
第6章　安全培训89
6.1　安全培训的问题与“痛点”89
6.1.1　信息安全意识不足的真实案例89
6.1.2　信息安全培训的必要性90
6.1.3　信息安全培训的“痛点”92
6.2　信息安全培训关联方93
6.3　信息安全培训“百宝箱”96
6.4　面向对象的信息安全培训矩阵105
6.5　培训体系实施的效果衡量107
6.6　小结108
第7章　外包安全管理109
7.1　外包安全管理的问题与“痛点”109
7.1.1　几个教训深刻的外包风险事件109
7.1.2　外包安全管理的必要性110
7.1.3　外包管理中的常见问题112
7.2　外包战略体系113
7.3　外包战术体系118
7.3.1　事前预防118
7.3.2　事中控制123
7.3.3　事后处置132
7.4　金融科技时代的外包安全管理133
7.5　小结135
第8章　安全考核136
8.1　考核评价体系与原则136
8.2　 安全考核对象137
8.3　考核方案140
8.3.1　考核方案设计原则140
8.3.2　总部IT部门安全团队141
8.3.3　总部IT部门非安全团队（平行团队）142
8.3.4　个人考核143
8.3.5　一些细节144
8.4　与考核相关的其他几个问题144
8.5　安全考核示例146
8.6　小结150
第9章　安全认证151
9.1　为什么要获得认证151
9.2　认证概述152
9.2.1　认证分类152
9.2.2　认证机构154
9.3　选择什么样的认证157
9.4　如何通过认证159
9.5　小结162
第10章　安全预算、总结与汇报163
10.1　安全预算163
10.2　安全总结166
10.3　安全汇报167
10.4　小结168
第二部分　安全技术实战
第11章　互联网应用安全170
11.1　端口管控170
11.2　Web应用安全172
11.3　系统安全173
11.4　网络安全175
11.5　数据安全175
11.6　业务安全176
11.7　互联网DMZ区安全管控标准176
11.8　小结178
第12章　移动应用安全179
12.1　概述179
12.2　APP开发安全180
12.2.1　AndroidManifest配置安全180
12.2.2　Activity组件安全181
12.2.3　Service组件安全181
12.2.4　Provider组件安全182
12.2.5　BroadcastReceiver组件安全183
12.2.6　WebView组件安全183
12.3　APP业务安全186
12.3.1　代码安全186
12.3.2　数据安全188
12.3.3　其他话题190
12.4　小结191
第13章　企业内网安全192
13.1　安全域192
13.2　终端安全193
13.3　网络安全195
13.3.1　网络入侵检测系统196
13.3.2　异常访问检测系统196
13.3.3　隐蔽信道检测系统197
13.4　服务器安全200
13.5　重点应用安全203
13.6　漏洞战争206
13.6.1　弱口令206
13.6.2　漏洞发现208
13.6.3　SDL210
13.7　蜜罐体系建设213
13.8　小结220
第14章　数据安全221
14.1　数据安全治理221
14.2　终端数据安全222
14.2.1　加密类222
14.2.2　权限控制类225
14.2.3　终端DLP类228
14.2.4　桌面虚拟化228
14.2.5　安全桌面230
14.3　网络数据安全230
14.4　存储数据安全234
14.5　应用数据安全235
14.6　其他话题237
14.6.1　数据脱敏237
14.6.2　水印与溯源237
14.6.3　UEBA240
14.6.4　CASB241
14.7　小结241
第15章　业务安全242
15.1　账号安全242
15.1.1　撞库242
15.1.2　账户盗用247
15.2　爬虫与反爬虫247
15.2.1　爬虫247
15.2.2　反爬虫249
15.3　API网关防护252
15.4　钓鱼与反制252
15.4.1　钓鱼发现252
15.4.2　钓鱼处置254
15.5　大数据风控255
15.5.1　基础知识255
15.5.2　风控介绍256
15.5.3　企业落地259
15.6　小结259
第16章　邮件安全261
16.1　背景261
16.2　入站安全防护262
16.2.1　邮箱账号暴力破解262
16.2.2　邮箱账号密码泄露264
16.2.3　垃圾邮件264
16.2.4　邮件钓鱼269
16.2.5　恶意附件攻击269
16.2.6　入站防护体系小结276
16.3　出站安全防护278
16.4　整体安全防护体系281
16.5　小结283
第17章　活动目录安全284
17.1　背景284
17.2　常见攻击方式285
17.2.1　SYSVOL与GPP漏洞285
17.2.2　MS14-068漏洞287
17.2.3　Kerberoast攻击289
17.2.4　内网横移抓取管理员凭证290
17.2.5　内网钓鱼与欺骗292
17.2.6　用户密码猜解293
17.2.7　获取AD数据库文件294
17.3　维持权限的各种方式295
17.3.1　krbtgt账号与黄金票据295
17.3.2　服务账号与白银票据296
17.3.3　利用DSRM账号297
17.3.4　利用SID History属性298
17.3.5　利用组策略299
17.3.6　利用AdminSDHolder300
17.3.7　利用SSP301
17.3.8　利用Skeleton Key303
17.3.9　利用PasswordChangeNofity304
17.4　安全解决方案304
17.4.1　活动目录整体架构及相关规范305
17.4.2　技术体系运营309
17.4.3　外围平台安全310
17.4.4　被渗透后的注意事项311
17.5　小结311
第18章　安全热点解决方案312
18.1　DDoS攻击与对策312
18.1.1　DDoS防御常规套路312
18.1.2　一些经验314
18.2　勒索软件应对316
18.3　补丁管理317
18.3.1　Windows318
18.3.2　Linux319
18.4　堡垒机管理319
18.5　加密机管理321
18.5.1　选型322
18.5.2　高可用架构与监控322
18.5.3　应用梳理324
18.5.4　上下线与应急324
18.6　情报利用324
18.7　网络攻防大赛与CTF325
18.8　小结329
第19章　安全检测330
19.1　安全检测方法330
19.2　检测工具331
19.3　安全检测思路和流程332
19.4　安全检测案例334
19.4.1　收集信息334
19.4.2　暴力破解335
19.4.3　XSS检测343
19.4.4　OS命令执行检测344
19.4.5　SQL注入检测345
19.4.6　XML实体注入检测346
19.4.7　代码注入346
19.4.8　文件上传漏洞检测347
19.4.9　支付漏洞检测348
19.4.10　密码找回漏洞349
19.4.11　文件包含漏洞350
19.5　红蓝对抗350
19.6　小结352
第20章　安全运营353
20.1　安全运营概述353
20.2　架构354
20.3　工具357
20.4　所需资源359
20.5　安全运营的思考361
20.6　小结364
第21章　安全运营中心365
21.1　安全运营中心概述365
21.2　ArcSight简介365
21.3　SOC实施规划和架构设计369
21.3.1　明确需求370
21.3.2　架构环境370
21.3.3　硬件规格372
21.3.4　日志管理策略373
21.3.5　应用的资产和架构信息373
21.3.6　外部信息集成策略374
21.3.7　开发方法及方式374
21.3.8　工作流规划374
21.3.9　成果度量375
21.4　ArcSight安装配置375
21.4.1　安装前准备376
21.4.2　初始化安装376
21.4.3　安装后验证377
21.4.4　性能调优377
21.4.5　初始备份377
21.4.6　压力测试377
21.4.7　其他参数调整377
21.5　小结378
第22章　安全资产管理和矩阵式监控379
22.1　安全资产管理379
22.1.1　面临的问题379
22.1.2　解决思路和方案383
22.1.3　几点思考387
22.2　矩阵式监控388
22.2.1　存在的问题388
22.2.2　解决方案388
22.2.3　收益和体会391
22.3　小结392
第23章　应急响应393
23.1　概述393
23.2　事件分类394
23.3　事件分级395
23.4　PDCERF模型395
23.5　其他话题396
23.6　小结397
第24章　安全趋势和安全从业者的未来398
24.1　职业规划方法论398
24.2　安全环境趋势和安全从业趋势402
24.3　安全从业指南404
24.4　安全从业注意事项408
24.5　小结410
附　　录
附录A　我的CISSP之路412
附录B　企业安全技能树（插页）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业安全建设指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云落谁家？
第1章通用型应用场景	1
1.1  场景描述	1
1.2  需求分析	2
1.3  技术架构设计	4
1.3.1  规划计算资源	5
1.3.2  规划网络资源	7
1.3.3  规划存储资源	9
1.3.4  软件选择	11
1.3.5  性能	           14
1.3.6  可用性	17
1.3.7  安全性	18
1.4  运营服务设计	20
1.4.1  技术支持和维护	21
1.4.2  监控	21
1.4.3  宕机时间	21
1.4.4  容量规划	22
1.5  架构实体选型建议	23
1.5.1  选择存储硬件	26
1.5.2  选择网络硬件	29
1.5.3  软件选择	30
1.5.4  针对性能敏感的负载	34
1.6  典型案例实践	35
第2章计算密集型应用场景	39
2.1  场景描述	39
2.2  需求分析	40
2.3  技术架构设计	41
2.3.1  扩展计划	43
2.3.2  CPU和内存	43
2.3.3  额外的硬件	45
2.3.4  量力而行	45
2.4  运营服务设计	48
2.4.1  支持和维护	49
2.4.2  监控	          50
2.4.3  计划内和计划外服务器宕机时间	50
2.4.4  容量计划	50
2.5  架构实体选型建议	51
2.5.1  存储硬件选择	53
2.5.2  选择网络硬件	55
2.5.3  软件选择	56
2.6  典型案例实践	60
第3章高负载存储型应用场景	65
3.1  场景描述	65
3.2  需求分析	66
3.3  技术架构设计	68
3.4  运营服务设计	69
3.4.1  管理效率	70
3.4.2  应用的可知性	71
3.4.3  容错和可用性	71
3.4.4  扩展存储服务	73
3.5  架构实体选型建议	75
3.5.1  计算（服务器）硬件选择	77
3.5.2  网络硬件选择	79
3.5.3  软件选择	79
3.6  典型案例实践	83
3.6.1  带数据处理服务的计算分析	85
3.6.2  带数据库服务的高性能数据库	86
第4章高吞吐网络型应用场景	89
4.1  场景描述	89
4.2  需求分析	91
4.2.1  高可用问题	92
4.2.2  风险	           93
4.2.3  安全性	94
4.3  技术架构设计	94
4.3.1  二层架构的局限性  96
4.3.2  三层架构的优势	  97
4.3.3  三层架构的局限性  98
4.3.4  网络建议的总结	98
4.3.5  额外的考虑因素	99
4.4  运营服务设计	102
4.5  架构实体选型建议	104
4.5.1  对设计的影响	105
4.5.2  可调联网组件	108
4.6  典型案例实践	109
4.6.1  负载均衡	111
4.6.2  覆盖网络	111
4.6.3  性能调优	111
4.6.4  网络功能	112
4.6.5  云存储	113
第5章混合云应用场景	115
5.1  场景描述	115
5.2  需求分析	116
5.2.1  法律需求	117
5.2.2  负载考虑	118
5.2.3  工具考量	119
5.2.4  网络考虑	120
5.2.5  风险规避和管理考虑	120
5.3  技术架构设计	121
5.3.1  容量计划	122
5.3.2  安全性	123
5.3.3  量力而行	123
5.3.4  性能	           124
5.3.5  组件	           125
5.3.6  特殊因素	125
5.4  运营服务设计	126
5.4.1  敏捷性	126
5.4.2  应用准备	127
5.4.3  升级	           127
5.4.4  网络操作中心	127
5.4.5  可维护性	128
5.5   架构实体选型建议	128
5.5.1  镜像移植	129
5.5.2  上层服务	130
5.5.3  网络服务	131
5.5.4  数据	131
5.6  典型案例实践	132
5.6.1  突破到一个不是OpenStack的公有云	133
5.6.2  高可用/灾难恢复	134
第6章跨地域多点型应用场景	137
6.1  场景描述	137
6.2  需求分析	138
6.2.1  负载特性	138
6.2.2  镜像和模板在跨不同站点时要保持一致性	139
6.2.3  高可用	139
6.2.4  应用准备	140
6.2.5  成本	140
6.2.6  站点失效和恢复	141
6.2.7  合规性和地理位置  141
6.2.8  审计	141
6.2.9  职责分工	142
6.2.10  站点之间的认证	142
6.3  技术架构设计	142
6.3.1  量力而行	144
6.3.2  性能	144
6.3.3  安全性	145
6.3.4  OpenStack组件	146
6.4  运营服务设计	146
6.4.1  许可	147
6.4.2  记录日志和监测	147
6.4.3  升级	148
6.4.4  配额管理	149
6.4.5  规则管理	149
6.4.6  文档	150
6.5  架构实体选型建议	150
6.5.1  OpenStack服务架构	151
6.5.2  存储	152
6.5.3  网络	152
6.5.4  依赖	153
6.6  典型案例实践	153
6.6.1  地理冗余负载均衡	155
6.6.2  本地服务	157
第7章大规模可扩展型应用场景	159
7.1  场景描述	159
7.2  需求分析	160
7.2.1  用户需求	161
7.2.2  运营者的需求	162
7.3  技术架构设计	163
7.3.1  基础设施隔离	163
7.3.2  主机聚合	165
7.3.3  可用域	165
7.3.4  隔离的例子	166
7.4  运营服务设计	167
7.4.1  最前沿	167
7.4.2  增长和容量计划	168
7.4.3  技能和培训	169
7.5  架构实体选型建议	169
7.5.1  选择存储硬件	171
7.5.2  选择网络硬件	173
7.5.3  软件选择	175
第8章其他应用场景	179
8.1  多虚拟机管理器	180
8.2  虚拟桌面基础设施（VDI）	185
8.3  特殊网络应用示例	187
8.4  软件定义网络	188
8.5  OpenStack上的OpenStack	190
参考资料	193
名词解释	196
OpenStack社区介绍	200
后记	204
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云落谁家？
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Boot 2精髓
第1章　Java EE简介
1.1　Java EE
1.1.1　Java EE架构
1.1.2　Java EE的缺点
1.2　Spring
1.2.1　Spring IoC容器和AOP
1.2.2　Spring的缺点
1.3　Spring Boot
1.4　Hello，Spring Boot
1.4.1　创建一个Maven工程
1.4.2　增加Web支持
1.4.3　Hello Spring Boot示例
1.4.4　使用热部署
1.4.5　添加REST支持
第2章　Spring Boot基础
2.1　检查Java环境与安装Java
2.2　安装和配置Maven
2.2.1　Maven介绍
2.2.2　安装Maven
2.2.3　设置Maven
2.2.4　使用IDE设置Maven
2.2.5　Maven的常用命令
2.3　Spring核心技术
2.3.1　Spring的历史
2.3.2　Spring容器介绍
2.3.3　Spring AOP介绍
第3章　MVC框架
3.1　集成MVC框架
3.1.1　引入依赖
3.1.2　Web应用目录结构
3.1.3　Java包名结构
3.2　使用Controller
3.3　URL映射到方法
3.3.1　@RequestMapping
3.3.2　URL路径匹配
3.3.3　HTTP method匹配
3.3.4　consumes和produces
3.3.5　params和header匹配
3.4　方法参数
3.4.1　PathVariable
3.4.2　Model&ModelAndView
3.4.3　JavaBean接受HTTP参数
3.4.4　@RequsetBody接受JSON
3.4.5　MultipartFile
3.4.6　@ModelAttribute
3.4.7　@InitBinder
3.5　验证框架
3.5.1　JSR-303
3.5.2　MVC中使用@Validated
3.5.3　自定义校验
3.6　WebMvcConfigurer
3.6.1　拦截器
3.6.2　跨域访问
3.6.3　格式化
3.6.4　注册Controller
3.7　视图技术
3.7.1　使用Freemarker
3.7.2　使用Beetl
3.7.3　使用Jackson
3.7.4　Redirect和Forward
3.8　通用错误处理
3.9　@Service和@Transactional
3.9.1　声明一个Service类
3.9.2　事务管理
3.10　curl命令
第4章　视图技术
4.1　Beetl模板引擎
4.1.1　安装Beetl
4.1.2　设置定界符号和占位符
4.1.3　配置Beetl
4.1.4　groupTemplate
4.2　使用变量
4.2.1　全局变量
4.2.2　局部变量
4.2.3　共享变量
4.2.4　模板变量
4.3　表达式
4.3.1　计算表达式
4.3.2　逻辑表达式
4.4　控制语句
4.4.1　循环语句
4.4.2　条件语句
4.4.3　try catch
4.5　函数调用
4.6　格式化函数
4.7　直接调用Java
4.8　标签函数
4.9　HTML标签
4.10　安全输出
4.11　高级功能
4.11.1　配置Beetl
4.11.2　自定义函数
4.11.3　自定义格式化函数
4.11.4　自定义标签函数
4.11.5　自定义HTML标签
4.11.6　布局
4.11.7　AJAX局部渲染
4.12　脚本引擎
4.13　JSON技术
4.13.1　在Spring Boot中使用Jackson
4.13.2　自定义ObjectMapper
4.13.3　Jackson的三种使用方式
4.13.4　Jackson树遍历
4.13.5　对象绑定
4.13.6　流式操作
4.13.7　Jackson注解
4.13.8　集合的反序列化
4.14　MVC分离开发
4.14.1　集成WebSimulate
4.14.2　模拟JSON响应
4.14.3　模拟模板渲染
第5章　数据库访问
5.1　配置数据源
5.2　Spring JDBC Template
5.2.1　查询
5.2.2　修改
5.2.3　JdbcTemplate增强
5.3　BeetlSQL介绍
5.3.1　BeetlSQL功能概览
5.3.2　添加Maven依赖
5.3.3　配置BeetlSQL
5.3.4　SQLManager
5.3.5　使用SQL文件
5.3.6　Mapper
5.3.7　使用实体
5.4　SQLManager内置CRUD
5.4.1　内置的插入API
5.4.2　内置的更新（删除）API
5.4.3　内置的查询API
5.4.4　代码生成方法
5.5　使用sqlId
5.5.1　md文件命名
5.5.2　md文件构成
5.5.3　调用sqlId
5.5.4　翻页查询
5.5.5　TailBean
5.5.6　ORM查询
5.5.7　其他API
5.5.8　Mapper详解
5.6　BeetlSQL的其他功能
5.6.1　常用函数和标签
5.6.2　主键设置
5.6.3　BeetlSQL注解
5.6.4　NameConversion
5.6.5　锁
第6章　Spring Data JPA
6.1　集成Spring Data JPA
6.1.1　集成数据源
6.1.2　配置JPA支持
6.1.3　创建Entity
6.1.4　简化Entity
6.2　Repository
6.2.1　CrudRepository
6.2.2　PagingAndSortingRepository
6.2.3　JpaRepository
6.2.4　持久化Entity
6.2.5　Sort
6.2.6　Pageable和Page
6.2.7　基于方法名字查询
6.2.8　@Query查询
6.2.9　使用JPA Query
6.2.10　Example查询
第7章　Spring Boot配置
7.1　配置Spring Boot
7.1.1　服务器配置
7.1.2　使用其他Web服务器
7.1.3　配置启动信息
7.1.4　配置浏览器显示ico
7.2　日志配置
7.3　读取应用配置
7.3.1　Environment
7.3.2　@Value
7.3.3　@ConfigurationProperties
7.4　Spring Boot自动装配
7.4.1　@Configuration和@Bean
7.4.2　Bean条件装配
7.4.3　Class条件装配
7.4.4　Environment装配
7.4.5　其他条件装配
7.4.6　联合多个条件
7.4.7　Condition接口
7.4.8　制作Starter
第8章　部署Spring Boot应用
8.1　以jar文件运行
8.2　以war方式部署
8.3　多环境部署
8.4　@Profile注解
第9章　Testing单元测试
9.1　JUnit介绍
9.1.1　JUnit的相关概念
9.1.2　JUnit测试
9.1.3　Assert
9.1.4　Suite
9.2　Spring Boot单元测试
9.2.1　测试范围依赖
9.2.2　Spring Boot测试脚手架
9.2.3　测试Service
9.2.4　测试MVC
9.2.5　完成MVC请求模拟
9.2.6　比较MVC的返回结果
9.2.7　JSON比较
9.3　Mockito
9.3.1　模拟对象
9.3.2　模拟方法参数
9.3.3　模拟方法返回值
9.4　面向数据库应用的单元测试
9.4.1　@Sql
9.4.2　XLSUnit
9.4.3　XLSUnit的基本用法
第10章　REST
10.1　REST简介
10.1.1　REST风格的架构
10.1.2　使用“api”作为上下文
10.1.3　增加一个版本标识
10.1.4　标识资源
10.1.5　确定HTTP Method
10.1.6　确定HTTP Status
10.1.7　REST VS. WebService
10.2　Spring Boot集成REST
10.2.1　集成REST
10.2.2　@RestController
10.2.3　REST Client
10.3　Swagger UI
10.3.1　集成Swagger
10.3.2　Swagger规范
10.3.3　接口描述
10.3.4　查询参数描述
10.3.5　URI中的参数
10.3.6　HTTP头参数
10.3.7　表单参数
10.3.8　文件上传参数
10.3.9　整个请求体作为参数
10.4　模拟REST服务
第11章　MongoDB
11.1　安装MongoDB
11.2　使用shell
11.2.1　指定数据库
11.2.2　插入文档
11.2.3　查询文档
11.2.4　更新操作
11.2.5　删除操作
11.3　Spring Boot集成MongoDB
11.4　增删改查
11.4.1　增加API
11.4.2　根据主键查询API
11.4.3　查询API
11.4.4　修改API
11.4.5　删除API
11.4.6　使用MongoDatabase
11.4.7　打印日志
第12章　Redis
12.1　安装Redis
12.2　使用redis-cli
12.2.1　安全设置
12.2.2　基本操作
12.2.3　keys
12.2.4　Redis List
12.2.5　Redis Hash
12.2.6　Set
12.2.7　Pub/Sub
12.3　Spring Boot集成Redis
12.4　使用StringRedisTemplate
12.4.1　opsFor
12.4.2　绑定Key的操作
12.4.3　RedisConnection
12.4.4　Pub/Sub
12.5　序列化策略
12.5.1　默认序列化策略
12.5.2　自定义序列化策略
第13章　Elasticsearch
13.1　Elasticsearch介绍
13.1.1　安装Elasticsearch
13.1.2　Elasticsearch的基本概念
13.2　使用REST访问Elasticsearch
13.2.1　添加文档
13.2.2　根据主键查询
13.2.3　根据主键更新
13.2.4　根据主键删除
13.2.5　搜索文档
13.2.6　联合多个索引搜索
13.3　使用RestTemplate访问ES
13.3.1　创建Book
13.3.2　使用RestTemplate获取搜索结果
13.4　Spring Data Elastic
13.4.1　安装Spring Data
13.4.2　编写Entity
13.4.3　编写Dao
13.4.4　编写Controller
第14章　Cache
14.1　关于Cache
14.1.1　Cache的组件和概念
14.1.2　Cache的单体应用
14.1.3　使用专有的Cache服务器
14.1.4　使用一二级缓存服务器
14.2　Spring Boot Cache
14.3　注释驱动缓存
14.3.1　@Cacheable
14.3.2　Key生成器
14.3.3　@CachePut
14.3.4　@CacheEvict
14.3.5　@Caching
14.3.6　@CacheConfig
14.4　使用Redis Cache
14.4.1　集成Redis缓存
14.4.2　禁止缓存
14.4.3　定制缓存
14.5　Redis缓存原理
14.6　实现Redis两级缓存
14.6.1　实现TwoLevelCacheManager
14.6.2　创建RedisAndLocalCache
14.6.3　缓存同步说明
14.6.4　将代码组合在一起
第15章　Spring Session
15.1　水平扩展实现
15.2　Nginx的安装和配置
15.2.1　安装Nginx
15.2.2　配置Nginx
15.3　Spring Session
15.3.1　Spring Session介绍
15.3.2　使用Redis
15.3.3　Nginx+Redis
第16章　Spring Boot和ZooKeeper
16.1　ZooKeeper
16.1.1　ZooKeeper的数据结构
16.1.2　安装ZooKeeper
16.1.3　ZooKeeper的基本命令
16.1.4　领导选取演示
16.1.5　分布式锁演示
16.1.6　服务注册演示
16.2　Spring Boot集成ZooKeeper
16.2.1　集成Curator
16.2.2　Curator API
16.3　实现分布式锁
16.4　服务注册
16.4.1　通过ServiceDiscovery注册服务
16.4.2　获取服务
16.5　领导选取
第17章　监控Spring Boot应用
17.1　安装Acutator
17.2　HTTP跟踪
17.3　日志查看
17.4　线程栈信息
17.5　内存信息
17.6　查看URL映射
17.7　查看Spring容器管理的Bean
17.8　其他监控
17.9　编写自己的监控信息
17.9.1　编写HealthIndicator
17.9.2　自定义监控
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Boot 2精髓
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云数据中心网络与SDN
目　　录
技术审校
本书赞誉
前言
第1章　云数据中心网络演进 1
1.1　传统的3-Tier架构 1
1.2　设备“多虚一”——虚拟机框 2
1.2.1　Cisco VSS 2
1.2.2　Juniper VC与H3C IRF 4
1.3　高级STP欺骗——跨设备链路聚合 4
1.3.1　Cisco vPC 4
1.3.2　Juniper MC-LAG和Arista M-LAG 6
1.4　变革3-Tier——向Leaf-Spine演进 6
1.5　初识大二层 9
1.6　插叙——虚拟机的接入 10
1.6.1　VEB 10
1.6.2　Cisco VN-TAG 11
1.6.3　VEPA 12
1.6.4　VEB性能优化 13
1.7　消除STP——Underlay L2MP 14
1.7.1　TRILL 15
1.7.2　SPB 17
1.8　Cisco私有的大二层——FabricPath 19
1.8.1　整体设计 19
1.8.2　控制与转发过程分析 21
1.8.3　其他技术细节 25
1.9　Juniper私有的大二层——QFabric 25
1.9.1　整体设计 26
1.9.2　集中式的控制机制 29
1.9.3　控制与转发过程分析 30
1.10　Brocade私有的大二层——VCS 32
1.10.1　整体设计 33
1.10.2　控制与转发过程分析 33
1.10.3　其他技术细节 35
1.11　跨越数据中心的二层——DCI优化 36
1.11.1　Cisco OTV 36
1.11.2　HUAWEI EVN与H3C EVI 38
1.12　端到端的二层——NVo3的崛起 39
1.12.1　VxLAN 39
1.12.2　NvGRE 41
1.12.3　STT 42
1.12.4　Geneve 43
1.13　新时代的开启——SDN入场 45
1.14　Overlay最新技术——EVPN 46
1.14.1　传统网络对SDN的反击 46
1.14.2　组网与数据模型 47
1.14.3　控制信令的设计 48
1.15　Underlay最新技术——Segment Routing 55
1.15.1　SID与Label 56
1.15.2　控制与转发机制 57
1.15.3　SDN 2.0？ 60
1.16　本章小结 62
第2章　杂谈SDN 63
2.1　SDN与传统网络——新概念下的老问题 63
2.2　转控分离——白盒的曙光 66
2.2.1　芯片级开放 68
2.2.2　操作系统级开放 71
2.2.3　应用级开放 75
2.2.4　机箱级开放 76
2.2.5　白盒的“通”与“痛” 77
2.3　网络可编程——百家争鸣 78
2.3.1　芯片可编程 78
2.3.2　FIB可编程 80
2.3.3　RIB可编程 83
2.3.4　设备配置可编程 85
2.3.5　设备OS和控制器可编程 88
2.3.6　业务可编程 88
2.4　集中式控制——与分布式的哲学之争 89
2.4.1　在功能上找到平衡点 90
2.4.2　在扩展性和可用性上找到平衡点 91
2.5　回归软件本源——从N到D再到S 94
2.5.1　模块管理 94
2.5.2　模块间通信 95
2.5.3　接口协议适配 96
2.5.4　数据库 97
2.5.5　集群与分布式 98
2.5.6　容器与微服务 99
2.6　本章小结 100
第3章　SDDCN概述 101
3.1　需求 101
3.1.1　自动化与集中式控制 101
3.1.2　应用感知 103
3.2　整体架构 105
3.2.1　实现形态 105
3.2.2　功能设计 107
3.3　关键技术 107
3.3.1　网络边缘 107
3.3.2　网络传输 110
3.3.3　服务链 112
3.3.4　可视化 115
3.3.5　安全 117
3.3.6　高可用 120
3.4　本章小结 122
第4章　商用SDDCN解决方案 123
4.1　VMware NSX 123
4.1.1　从NVP到NSX 124
4.1.2　NVP控制平面设计 125
4.1.3　NVP数据平面设计 125
4.1.4　NVP转发过程分析 126
4.1.5　NSX-V整体架构 128
4.1.6　NSX-V管理平面设计 129
4.1.7　NSX-V控制平面设计 130
4.1.8　NSX-V数据平面设计 132
4.1.9　NSX-V转发过程分析 132
4.1.10　NSX-MH与NSX-T 139
4.2　Cisco ACI 140
4.2.1　整体架构 141
4.2.2　管理与控制平面设计 142
4.2.3　数据平面设计 145
4.2.4　转发过程分析 152
4.2.5　议ACI与SDN 154
4.3　Cisco VTS 155
4.3.1　整体架构 156
4.3.2　管理与控制平面设计 158
4.3.3　数据平面设计 159
4.4　Juniper Contrail 162
4.4.1　整体架构 164
4.4.2　管理与控制平面设计 167
4.4.3　数据平面设计 173
4.4.4　转发过程分析 175
4.5　Nuage VCS 176
4.5.1　整体架构 178
4.5.2　管理平面设计 179
4.5.3　控制平面设计 179
4.5.4　数据平面设计 180
4.6　Arista EOS与CloudVison 181
4.6.1　整体架构 183
4.6.2　管理与控制平面设计 185
4.6.3　数据平面设计 187
4.7　HUAWEI AC-DCN 187
4.7.1　整体架构 187
4.7.2　管理平面设计 189
4.7.3　控制平面设计 189
4.7.4　数据平面设计 193
4.8　Bigswitch BCF与BMF 194
4.8.1　整体架构 195
4.8.2　BCF控制平面设计 196
4.8.3　BMF控制平面设计 201
4.8.4　数据平面设计 205
4.9　Midokura Midonet 207
4.9.1　整体架构 207
4.9.2　控制平面设计 210
4.9.3　数据平面设计 213
4.10　PLUMgrid ONS 217
4.10.1　整体架构 217
4.10.2　数据平面设计 219
4.10.3　控制平面设计 221
4.10.4　转发过程分析 222
4.11　Plexxi Switch与Control 225
4.11.1　整体架构 225
4.11.2　数据平面设计 227
4.11.3　控制平面设计 229
4.12　Pluribus 230
4.12.1　Server Switch设计 231
4.12.2　Netvisor设计 232
4.12.3　再议数据中心SDN 235
4.13　本章小结 236
第5章　开源SDDCN：OpenStack Neutron的设计与实现 237
5.1　网络基础 237
5.1.1　网络结构与网络类型 238
5.1.2　VLAN网络类型中流量的处理 239
5.2　软件架构 242
5.2.1　分布式组件 242
5.2.2　Core Plugin与Service Plugin 243
5.3　WSGI与RPC的实现 245
5.3.1　Neutron Server的WSGI 245
5.3.2　Neutron Plugin与Neutron Agent间的RPC 247
5.4　虚拟机启动过程中网络的相关实现 248
5.4.1　虚拟机的启动流程 248
5.4.2　Nova请求Port资源 250
5.4.3　Neutron生成Port资源 250
5.4.4　Neutron将Port相关信息通知给DHCP Agent 252
5.4.5　DHCP Agent将Port相关信息通知给DHCP Server 252
5.4.6　Nova拉起虚拟机并通过相应的Port接入网络 252
5.5　OVS Agent的实现 253
5.5.1　网桥的初始化 253
5.5.2　使能RPC 255
5.6　OVS Agent对Overlay L2的处理 256
5.6.1　标准转发机制 256
5.6.2　arp_responder 258
5.6.3　l2_population 260
5.7　OVS Agent对Overlay L3的处理 261
5.7.1　标准转发机制 261
5.7.2　DVR对东西向流量的处理 262
5.7.3　DVR对南北向流量的处理 267
5.8　Security-Group与FWaaS 268
5.8.1　Neutron-Security-Group 268
5.8.2　FWaaS v1 269
5.8.3　FWaaS v2 269
5.9　LBaaS 270
5.9.1　LBaaS v1 270
5.9.2　LBaaS v2 271
5.9.3　Octavia 271
5.10　TaaS 272
5.11　SFC 274
5.12　L2-Gateway 275
5.13　Dynamic Routing 277
5.14　VPNaaS 279
5.15　Networking-BGPVPN与BagPipe 280
5.15.1　Networking-BGPVPN 280
5.15.2　BagPipe 280
5.16　DragonFlow 282
5.17　OVN 287
5.18　本章小结 290
第6章　开源SDDCN：OpenDaylight相关项目的设计与实现 291
6.1　架构分析 291
6.1.1　AD-SAL架构 292
6.1.2　MD-SAL架构 293
6.1.3　YANG和YANG-Tools 294
6.1.4　MD-SAL的内部设计 294
6.1.5　MD-SAL的集群机制 296
6.1.6　其他 298
6.2　OpenFlow的示例实现 298
6.2.1　OF交换机的上线 299
6.2.2　l2switch获得PacketIn 301
6.2.3　l2switch下发PacketOut和FlowMod 302
6.3　OpenStack Networking-ODL 303
6.3.1　v1 303
6.3.2　v2 304
6.4　Neutron-Northbound的实现 306
6.4.1　对接Networking-ODL 306
6.4.2　RESTful请求的处理示例 306
6.5　Netvirt简介 307
6.5.1　OVSDB-Netvirt和VPNService的合并 307
6.5.2　Genius 309
6.6　Netvirt-OVSDB-Neutron的实现 311
6.6.1　net-virt分支 311
6.6.2　net-virt-providers分支 317
6.7　Netvirt-VPNService的实现 321
6.7.1　elanmanager 323
6.7.2　vpnmanager 326
6.8　SFC的实现 328
6.8.1　sfc-openflow-renderer分支 328
6.8.2　sfc-scf-openflow分支 335
6.9　VTN Manager的实现 336
6.9.1　neutron分支 337
6.9.2　implementation分支 339
6.10　本章小结 342
第7章　开源SDDCN：ONOS相关项目的设计与实现 343
7.1　架构分析 343
7.1.1　分层架构 344
7.1.2　分层架构的实现 345
7.1.3　模块的开发 347
7.1.4　分层架构存在的问题 347
7.1.5　数据存储与集群 348
7.1.6　其他 349
7.2　OpenFlow的示例实现 349
7.2.1　OF交换机的上线 350
7.2.2　fwd获得PacketIn 352
7.2.3　fwd下发PacketOut和FlowMod 356
7.3　ONOSFW的实现 359
7.3.1　vtnmgr分支 359
7.3.2　sfcmgr分支 363
7.4　SONA的实现 365
7.4.1　openstacknode分支 366
7.4.2　openstacknetworking分支 368
7.5　CORD简介 371
7.5.1　R-CORD的架构 372
7.5.2　R-CORD的控制与转发机制 373
7.6　本章小结 376
第8章　学术界相关研究 377
8.1　拓扑 377
8.1.1　FatTree 377
8.1.2　VL2 379
8.1.3　DCell 380
8.1.4　FiConn 382
8.1.5　BCube 384
8.1.6　MDCube 385
8.1.7　CamCube 387
8.2　路由 388
8.2.1　Seattle 388
8.2.2　FatTree 391
8.2.3　VL2 393
8.2.4　PortLand 396
8.2.5　SecondNet 400
8.2.6　SiBF 401
8.2.7　SPAIN 402
8.2.8　WCMP 404
8.2.9　OF-based DLB 406
8.2.10　Flowlet与CONGA 406
8.2.11　Hedera 408
8.2.12　DevoFlow 409
8.2.13　MicroTE 409
8.2.14　Mahout 410
8.2.15　F10 410
8.2.16　DDC 411
8.2.17　SlickFlow 412
8.2.18　COXCast 413
8.2.19　Avalanche 415
8.3　虚拟化 416
8.3.1　NetLord 416
8.3.2　FlowN 418
8.3.3　FlowVisor 420
8.3.4　ADVisor 421
8.3.5　VeRTIGO 423
8.3.6　OpenVirteX 424
8.3.7　CoVisor 426
8.4　服务链 427
8.4.1　pSwitch 427
8.4.2　FlowTags 428
8.4.3　Simple 430
8.4.4　StEERING 432
8.4.5　OpenSCaaS 434
8.4.6　SPFRI 435
8.5　服务质量 437
8.5.1　NetShare 437
8.5.2　Seawall 438
8.5.3　GateKeeper 439
8.5.4　El
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云数据中心网络与SDN
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>SPA设计与架构：理解单页面Web应用
第1 部分 基础知识 1
1　单页面应用程序介绍 3
1.1 SPA 简述 4
1.1.1 无须刷新浏览器 7
1.1.2 表现逻辑位于客户端 7
1.1.3 服务器端事务处理 7
1.2 更进一步 8
1.2.1 以Shell 页面开始 8
1.2.2 从传统页面到视图 9
1.2.3 视图的产生 10
1.2.4 实现无刷新的视图切换 11
1.2.5 贯穿动态更新过程的流畅性 12
1.3 SPA 应用相较传统Web 应用的优势 12
1.4 温故知新 13
1.5 优秀SPA 应用的构成 15
1.5.1 组织项目 15
1.5.2 创建可维护的松耦合UI 17
1.5.3 使用JavaScript 模块 18
1.5.4 执行SPA 导航 19
1.5.5 创建视图组成与布局 19
1.5.6 模块通信 20
1.5.7 与服务器端通信 20
1.5.8 执行单元测试 20
1.5.9 客户端自动化技术 20
1.6 小结 21
2　MV* 框架介绍 22
2.1 MV* 概念 24
2.1.1 传统UI 设计模式 25
2.1.2 MV* 和浏览器环境 27
2.2 MV* 基础概念 28
2.2.1 框架 29
2.2.2 我们的MV* 项目 30
2.2.3 模型 32
2.2.4 绑定 36
2.2.5 模板 40
2.2.6 视图 44
2.3 为什么要用MV* 框架 44
2.3.1 关注分离 45
2.3.2 简化日常任务 46
2.3.3 提升生产率 47
2.3.4 标准化 47
2.3.5 可扩展性 48
2.4 框架选择 48
2.5 挑战环节 50
2.6 小结 50
3　JavaScript 模块化 52
3.1 模块概念 53
3.1.1 模块模式概念 53
3.1.2 模块结构 54
3.1.3 揭示模式 55
3.2 模块化编程的意义 56
3.2.1 避免命名冲突 56
3.2.2 保护代码完整性 65
3.2.3 隐藏复杂性 67
3.2.4 降低代码改变带来的冲击 68
3.2.5 代码组织 68
3.2.6 模块模式的不足 69
3.3 模块模式剖析 69
3.3.1 可访问性控制 69
3.3.2 创建公有API 70
3.3.3 允许全局导入 73
3.3.4 创建模块的命名空间 73
3.4 模块加载及依赖管理 74
3.4.1 脚本加载器 74
3.4.2 异步模块定义——AMD 75
3.4.3 通过RequireJS 实践AMD 76
3.5 挑战环节 81
3.6 小结 81
第2 部分　核心概念 83
4　单页面导航 85
4.1 客户端路由器概念 86
4.1.1 传统导航 86
4.1.2 SPA 导航 86
4.2 路由及其配置 88
4.2.1 路由语法 90
4.2.2 路由配置项 90
4.2.3 路由参数 91
4.2.4 缺省路由 93
4.3 客户端路由器的工作机制 93
4.3.1 片段标识符方式 94
4.3.2 HTML5 历史API 方式 95
4.3.3 使用HTML5 历史API 方式 97
4.4 综合实作：实现SPA 路由 98
4.4.1 教员列表（缺省路由） 99
4.4.2 主要联系人路由 101
4.4.3 教员授课时间（参数化路由） 102
4.5 挑战环节 104
4.6 小结 105
5　视图合成与布局 106
5.1 项目介绍 107
5.2 布局设计概念 108
5.2.1 视图 108
5.2.2 Region 109
5.2.3 视图合成 110
5.2.4 嵌套视图 111
5.2.5 路由 112
5.3 高级合成与布局的可选方案 113
5.3.1 优点 113
5.3.2 缺点 114
5.4 设计应用程序 114
5.4.1 设计基本布局 115
5.4.2 设计基本内容 117
5.4.3 在复杂设计中应用视图管理 122
5.4.4 通过自身状态创建嵌套视图 125
5.5 挑战环节 127
5.6 小结 128
6　模块间交互 129
6.1 模块概念回顾 131
6.1.1 用模块封装代码 131
6.1.2 API 提供对内部功能的访问控制 133
6.1.3 SRP——以单一目的作为设计出发点 134
6.1.4 代码重用——控制项目规模 135
6.2 模块间交互方式 136
6.2.1 通过依赖进行模块间交互 136
6.2.2 依赖方式的优缺点 138
6.2.3 通过发布/ 订阅模式进行模块间交互 138
6.2.4 发布/ 订阅模式优缺点 141
6.3 示例项目细节 142
6.3.1 搜索功能 144
6.3.2 显示产品信息 150
6.4 挑战环节 155
6.5 小结 155
7　与服务器端通信 156
7.1 示例项目新要求 157
7.2 与服务器端通信综述 158
7.2.1 选择数据类型 158
7.2.2 HTTP 请求方法 159
7.2.3 数据转换 160
7.3 使用MV* 框架 161
7.3.1 请求生成 162
7.3.2 通过回调函数处理结果 165
7.3.3 通过Promise 处理结果 166
7.3.4 Promise 错误处理 170
7.4 RESTful Web 服务调用 172
7.4.1 什么是REST 172
7.4.2 REST 原则 172
7.4.3 MV* 框架的RESTful 支持 174
7.5 示例项目细节 174
7.5.1 配置REST 调用 174
7.5.2 添加产品到购物车 177
7.5.3 查看购物车 179
7.5.4 修改购物车 181
7.5.5 从购物车中移除产品 183
7.6 挑战环节 184
7.7 小结 184
8　单元测试 186
8.1 示例项目说明 187
8.2 什么是单元测试 187
8.2.1 单元测试的好处 188
8.2.2 构建更好的单元测试 189
8.3 传统的单元测试 192
8.3.1 QUnit 起步 193
8.3.2 创建第一个单元测试 196
8.3.3 测试由MV* 对象创建的代码 200
8.3.4 测试对DOM 所做的改变 205
8.3.5 混合使用其他测试框架 206
8.4 挑战环节 208
8.5 小结 208
9　客户端任务自动化 209
9.1 Task Runner 的常见用途 210
9.1.1 即时刷新浏览器 210
9.1.2 自动化JavaScript 和CSS 的预处理过程 211
9.1.3 自动化Linter 代码分析 211
9.1.4 持续单元测试 211
9.1.5 文件串接 212
9.1.6 代码压缩 212
9.1.7 持续集成 212
9.2 Task Runner 选择 212
9.3 本章示例项目 213
9.3.1 Gulp.js 介绍 214
9.3.2 创建第一个任务 215
9.3.3 创建代码分析任务 216
9.3.4 创建浏览器刷新任务 218
9.3.5 自动化单元测试 220
9.3.6 创建构建过程 222
9.4 挑战环节 227
9.5 小结 227
A　员工通讯录示例说明 229
B　XMLHttpRequest API 259
C　第7 章内容的服务器端设置与总结 266
D　安装Node.js 与Gulp.js 277
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>SPA设计与架构：理解单页面Web应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件框架设计的艺术
第一部分 理论与理由
第1章 软件开发的艺术	4
1.1 理性主义，经验主义以及无绪	4
1.2 软件的演变过程	6
1.3 大型软件	8
1.4 漂亮，真理和优雅	9
1.5 更好的无绪	12
第2章 设计API的动力之源	14
2.1 分布式开发	14
2.2 模块化应用程序	16
2.3 交流互通才是一切	20
2.4 经验主义编程方式	22
2.5 开发第一个版本通常比较容易	24
第3章 评价API好坏的标准	26
3.1 方法和字段签名	26
3.2 文件及其内容	27
3.3 环境变量和命令行选项	29
3.4 文本信息也是API	30
3.5 协议	32
3.6 行为	35
3.7 国际化支持和信息国际化	35
3.8 API的广泛定义	37
3.9 如何检查API的质量	37
3.9.1 可理解性	37
3.9.2 一致性	38
3.9.3 可见性	39
3.9.4 简单的任务应该有简单的方案	40
3.9.5 保护投资	40
第4章 不断变化的目标	42
4.1 第一个版本远非完美	42
4.2 向后兼容	43
4.2.1 源代码兼容	43
4.2.2 二进制兼容	44
4.2.3 功能兼容——阿米巴变形虫效应	50
4.3 面向用例的重要性	52
4.4 API设计评审	55
4.5 一个API的生命周期	56
4.6 逐步改善	60
第二部分 设计实战
第5章 只公开你要公开的内容	67
5.1 方法优于字段	68
5.2 工厂方法优于构造函数	70
5.3 让所有内容都不可更改	71
5.4 避免滥用setter方法	72
5.5 尽可能通过友元的方式来公开功能	73
5.6 赋予对象创建者更多权利	77
5.7 避免暴露深层次继承	82
第6章 面向接口而非实现进行编程	85
6.1 移除方法或者字段	87
6.2 移除或者添加一个类或者接口	88
6.3 向现有的继承体系中添加一个接口或者类	88
6.4 添加方法或者字段	88
6.5 Java中接口和类的区别	90
6.6 弱点背后的优点	91
6.7 添加方法的另一种方案	92
6.8 抽象类有没有用呢	94
6.9 要为增加参数做好准备	95
6.10 接口VS.类	97
第7章 模块化架构	98
7.1 模块化设计的类型	100
7.2 组件定位和交互	103
7.3 编写扩展点	116
7.4 循环依赖的必要性	117
7.5 满城尽是Lookup	121
7.6 Lookup的滥用	126
第8章 设计API时要区分其目标用户群	129
8.1 C和Java语言中如何定义API和SPI	129
8.2 API演进不同于SPI演进	131
8.3	java.io.Writer这个类从JDK 1.4到JDK 5的演进	131
8.4 合理分解API	143
第9章 牢记可测试性	147
9.1 API设计和测试	148
9.2 规范的光环正在褪去	151
9.3 好工具让API设计更简单	153
9.4 兼容性测试套件	155
第10章 与其他API协作	158
10.1 谨慎使用第三方API	158
10.2 只暴露抽象内容	162
10.3 强化API的一致性	164
10.4 代理和组合	168
10.5 避免API的误用	176
10.6 不要滥用JavaBeans那种监听器机制	180
第11章 API具体运行时的一些内容	184
11.1 不要冒险	186
11.2 可靠性与无绪	189
11.3 同步和死锁	191
11.3.1 描述线程模型	192
11.3.2 Java Monitors中的陷阱	193
11.3.3 触发死锁的条件	196
11.3.4 测试死锁	201
11.3.5 对条件竞争进行测试	204
11.3.6 分析随机故障	206
11.3.7 日志的高级用途	208
11.3.8 使用日志记录程序控制流程	210
11.4 循环调用的问题	215
11.5 内存管理	218
第12章 声明式编程	223
12.1 让对象不可变	225
12.2 不可变的行为	229
12.3 文档兼容性	230
第三部分 日常生活
第13章 极端的意见有害无益	236
13.1 API必须是漂亮的	237
13.2 API必须是正确的	237
13.3 API应该尽量简单	240
13.4 API必须是高性能的	242
13.5 API必须绝对兼容	242
13.6 API必须是对称的	245
第14章 API设计中的矛盾之处	247
14.1 API设计中的自相矛盾	248
14.2 背后隐藏的工作	251
14.3 不要害怕发布一个稳定的API	252
14.4 降低维护费用	255
第15章 改进API	258
15.1 让有问题的类库重新焕发活力	259
15.2 自觉地升级与无意识地被迫升级	265
15.3 可选的行为	268
15.4 相似API的桥接和共存	274
第16章 团队协作	286
16.1 在提交代码时进行代码评审	286
16.2 说服开发人员为他们的API提供文档	290
16.3 尽职尽责的监控者	292
16.4 接受API的补丁	297
第17章 利用竞赛游戏来提升API设计技巧	300
17.1 概述	300
17.2 第一天	301
17.2.1 非public类带来的问题	304
17.2.2 不可变性带来的问题	304
17.2.3 遗漏实现的问题	308
17.2.4 返回结果可能不正确的问题	309
17.2.5 第一天的解决方案	310
17.3 第二天	313
17.3.1 我想修正犯下的错误	316
17.3.2 第二天的解决方案	317
17.4 第三天：评判日	320
17.5 也来玩下这个游戏吧	327
第18章 可扩展Visitor模式的案例	328
18.1 抽象类	331
18.2 为改进做好准备	333
18.3 默认的遍历	334
18.4 清楚地定义每个版本	337
18.5 单向改进	339
18.6 使用接口时的数据结构	340
18.7 针对用户和开发商的Visitor模式	341
18.8 三重调度	343
18.9 Visitor模式的圆满结局	345
18.10 语法小技巧	346
第19章 消亡的过程	348
19.1 明确版本的重要性	349
19.2 模块依赖的重要性	349
19.3 被移除的部分需要永久保留吗	352
19.4 分解庞大的API	352
第20章 未来	356
20.1 原则性内容	357
20.2 无绪长存	358
20.3 API设计方法论	360
20.4 编程语言的演变	361
20.5 教育的作用	363
20.6 共享	365
参考书目	366
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件框架设计的艺术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Android 安全架构深究
引言 ................... XXV
第1 章 Android 安全模型 ........ 1
Android 体系结构  1
Linux 内核层  2
原生用户空间层 ............. 3
Dalvik 虚拟机.................. 3
Java 运行时库 ................. 4
系统服务 ...... 4
进程间通信 .. 4
Binder ........... 5
Android 框架库 ............... 9
应用程序 .... 10
Android 的安全模型介绍 ..... 11
应用程序沙箱 ............... 12
权限 ............ 14
IPC ............. 14
代码签名和平台密钥 ... 15
多用户支持  15
SELinux ...... 16
系统更新 .... 16
验证启动模式 ............... 17
总结  18
第2 章 权限 ........ 19
权限的本质 ........ 19
权限申请 ............ 20
权限管理 ............ 21
权限的保护级别  22
权限的赋予 ........ 24
权限执行 ............ 29
内核层的权限执行 ....... 29
原生守护进程级别的权限执行 ....... 30
框架层的权限执行 ....... 32
系统权限 ............ 36
signature 权限 ................ 37
development 权限 .......... 38
共享用户ID ....... 38
自定义权限 ........ 41
公开和私有组件  42
activity 和service 权限 ......... 43
广播权限 ............ 44
content provider 权限 ............ 45
静态provider 权限 ........ 46
动态provider 权限 ........ 47
pending intent ..... 48
总结  50
第3 章 包管理机制 ................ 51
Android 应用程序包文件的格式 ............ 51
代码签名 ............ 53
Java 代码签名 ............... 53
Android 代码签名 ......... 59
APK 的安装过程 .................. 61
应用程序包和数据的位置 ............... 62
活动组件 .... 63
安装一个本地包 ........... 66
更新包 ........ 72
安装加密的APK .......... 76
转发锁定 .... 79
Android 4.1 转发锁定实现 .............. 80
加密的App 和Google Play ............. 82
包验证 ............... 83
Android 对包验证的支持 ................ 84
Google Play 实现 ........... 85
总结  85
第4 章 用户管理 . 87
多用户支持概述  87
用户类型 ............ 89
主用户（持有者） ....... 89
次要用户 .... 90
受限用户 .... 91
访客用户 .... 93
用户管理 ............ 93
命令行工具  94
用户状态和相关广播 ... 94
用户元数据 ........ 95
用户清单文件 ............... 95
用户元数据文件 ........... 96
用户系统目录 ............... 97
每个用户的应用程序管理 ... 98
应用程序数据目录 ....... 98
应用共享 .. 100
外存 ................. 102
外存实现 .. 103
多用户外存 ................. 103
外存权限 .. 109
其他多用户特性 ................. 111
总结 ................. 111
第5 章 加密服务 .................. 112
JCA Provider 结构 ............... 112
加密服务Provider ....... 113
JCA 引擎类 ...... 115
获得引擎类实例 ......... 115
算法名称 .. 116
SecureRandom ............. 117
MessageDigest ............. 118
Signature ... 118
Cipher ....... 119
Mac ........... 123
Key ............ 124
SecretKey 和PBEKey . 124
PublicKey、PrivateKey 和KeyPair .................. 125
KeySpec .... 125
KeyFactory .................. 125
SecretKeyFactory ......... 126
KeyPairGenerator ........ 127
KeyGenerator ............... 127
KeyAgreement ............. 128
KeyStore ... 129
CertificateFactory 和CertPath........ 131
CertPathValidator 和CertPathBuilder ............... 132
Android 的JCA Provider .... 133
Harmony 加密Provider .................. 133
Android 的Bouncy Castle Provider .................. 133
AndroidOpenSSL Provider ............. 137
OpenSSL ... 139
使用定制的Provider ........... 140
Spongy Castle .............. 140
总结 ................. 141
第6 章 网络安全与PKI ....... 142
PKI 与SSL 概述 ................ 143
公钥证书 .. 143
直接信任和Private CA .................. 145
公钥基础设施 ............. 145
证书撤销 .. 147
JSSE 介绍 ........ 148
安全套接字 ................. 148
对等认证 .. 149
主机名认证 ................. 151
Android JSSE 的实现 .......... 152
证书管理与认证 ......... 152
证书黑名单 ................. 158
重新审视PKI 信任模型 ................ 161
总结 ................. 165
第7 章 凭据存储 .................. 166
VPN 和Wi-Fi EAP 凭据..... 167
认证密钥和证书 ......... 167
系统凭据库 ................. 168
凭据存储的具体实现 ......... 169
密钥库（keystore）服务 ............... 169
密钥blob 的版本和类型 ............... 171
访问限制 .. 171
keymaster 模块和密钥库服务的实现 .............. 172
Nexus 4 的基于硬件的实现 .......... 173
框架集成 .. 175
公开API ........... 175
密钥链（KeyChain）API .............. 176
密钥链API 的实现 ..... 180
控制对密钥库的访问 . 181
Android 密钥库Provider ............... 183
总结 ................. 184
第8 章 在线账户管理 ........... 186
Android 账户管理概述 ....... 186
账户管理在Android 中的具体实现 ..... 187
AccountManagerService 与AccountManager .. 188
认证模块 .. 189
认证模块缓存 ............. 189
账户管理服务的操作和权限 ......... 190
账户数据库 ................. 193
多用户支持 ................. 196
增加一个认证器模块 . 197
Google 账户支持 ................. 200
Google 登录服务 ......... 201
Google 服务认证和授权 ................ 203
Google Play 服务 ......... 206
总结 ................. 208
第9 章 企业安全 .................. 209
设备管理 .......... 209
实现方法 .. 211
添加设备管理员 ......... 217
企业账户集成 ............. 220
VPN 支持 ......... 223
PPTP ......... 223
L2TP/IPSec .................. 223
IPSec Xauth ................. 224
基于SSL 的VPN ........ 224
legacy VPN .................. 225
基于应用的VPN ........ 230
多用户支持 ................. 233
Wi-Fi EAP ........ 236
EAP 认证方法 ............. 237
Android Wi-Fi 架构 ..... 238
EAP 凭据管理 ............. 239
使用WifiManager 添加EAP 网络  242
总结 ................. 244
第10 章 设备安全 ................ 245
控制系统的启动和安装 ... 246
引导加载程序 .......... 246
恢复系统 .................. 247
验证启动 ........ 247
dm-verity 简介 ......... 248
Android 实现 ........... 249
打开验证启动 .......... 249
磁盘加密 ........ 251
密码模式 .................. 252
密钥生成 .................. 253
磁盘加密密码 .......... 254
修改磁盘加密密码 .. 255
启用磁盘加密 .......... 256
启动加密设备 .......... 259
屏幕安全 ........ 261
锁屏实现 .................. 261
KeyGuard 解锁方法  263
暴力破解保护 .......... 270
安全USB 调试 ................. 270
xxii Android 安全架构深究
ADB 简介 ................ 271
对安全ADB 的需求 .................. 273
安全ADB ................ 273
安全ADB 实现 ....... 274
ADB 认证密钥 ........ 275
验证宿主密钥指纹 .. 276
Android 备份 .. 277
Android 备份简介 ... 277
备份文件格式 .......... 278
备份加密 .................. 279
控制备份范围 .......... 281
总结 ............... 281
第11 章 NFC 和安全元件 .... 283
NFC 简介 ....... 283
Android 对NFC 的支持 ... 284
读/写模式 ................. 284
端对端模式 .............. 289
卡模拟模式 .............. 289
安全元件 ........ 290
移动设备中的SE 组件 .............. 290
访问内嵌SE ............ 293
Android SE 执行环境 ................. 296
使用UICC 作为安全元件 ......... 299
软件卡模拟 .... 303
Android 4.4 的HCE 架构 ........... 304
APDU 路由 .............. 304
编写HCE 服务 ........ 309
HCE 应用的安全 ..... 311
总结 ............... 312
第12 章 SELinux ................. 313
SELinux 介绍 . 313
SELinux 架构........... 314
强制访问控制 .......... 315
SELinux 模式........... 315
安全上下文 .............. 316
安全上下文的设定和保存 ......... 317
安全规则 .................. 318
策略声明 .................. 318
类型转换规则 .......... 321
域转换规则 .............. 322
访问向量规则 .......... 323
Android 实现 .. 324
内核修改 .................. 325
用户空间修改 .......... 326
设备规则文件 .......... 334
策略事件日志 .......... 334
Android 4.4 的SELinux 策略 .............. 335
策略概述 .................. 335
强制域 ... 337
无限制域 .................. 338
应用域 ... 340
总结 ............... 341
第13 章 系统更新和root 访问 ................ 342
引导加载程序  343
解锁引导加载程序 .. 343
快速启动模式 .......... 344
recovery .......... 347
原生恢复系统 .......... 347
定制恢复系统 .......... 357
root 权限 ........ 359
工程机上的root 访问 ................ 359
正式版本中的root 访问 ... 363
通过修改boot 和system 镜像获取root ...... 364
通过刷入一个OTA 更新包来获取root ....... 364
通过漏洞来获取root ................. 371
总结 ............... 372
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Android 安全架构深究
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务实战
第1章　基础知识	1
什么是微服务架构	1
-- 与单体系统的区别	1
-- 如何实施微服务	2
为什么选择Spring Cloud	6
Spring Cloud简介	7
版本说明	8
第2章　微服务构建：Spring Boot	11
框架简介	12
快速入门	13
-- 项目构建与解析	13
-- 实现RESTful API	17
配置详解	20
-- 配置文件	20
-- 自定义参数	22
-- 参数引用	22
-- 使用随机数	23
-- 命令行参数	23
-- 多环境配置	24
-- 加载顺序	25
监控与管理	26
-- 初识actuator	27
-- 原生端点	28
小结	38
第3章　服务治理：Spring Cloud Eureka	39
服务治理	39
-- Netflix Eureka	40
--搭建服务注册中心	41
--注册服务提供者	43
--高可用注册中心	46
--服务发现与消费	48
Eureka详解	51
--基础架构	52
--服务治理机制	52
--源码分析	56
配置详解	65
--服务注册类配置	65
--服务实例类配置	67
跨平台支持	71
第4章　客户端负载均衡：Spring Cloud Ribbon	73
客户端负载均衡	73
RestTemplate详解	75
-- GET请求	75
-- POST请求	77
-- PUT请求	79
-- DELETE请求	79
源码分析	80
-- 负载均衡器	91
-- 负载均衡策略	109
配置详解	123
--自动化配置	124
-- Camden版本对RibbonClient配置的优化	125
-- 参数配置	127
-- 与Eureka结合	127
重试机制	128
第5章　服务容错保护：Spring Cloud Hystrix	130
快速入门	131
原理分析	135
-- 工作流程	135
-- 断路器原理	144
-- 依赖隔离	148
使用详解	151
-- 创建请求命令	151
-- 定义服务降级	154
-- 异常处理	157
-- 命令名称、分组以及线程池划分	158
-- 请求缓存	159
-- 请求合并	166
属性详解	172
-- Command属性	174
-- collapser属性	184
-- threadPool属性	185
Hystrix仪表盘	187
Turbine集群监控	192
-- 构建监控聚合服务	192
-- 与消息代理结合	196
第6章　声明式服务调用：Spring Cloud Feign	199
快速入门	200
参数绑定	202
继承特性	205
Ribbon配置	209
全局配置	209
指定服务配置	209
重试机制	210
Hystrix配置	211
全局配置	211
禁用Hystrix	211
指定命令配置	212
服务降级配置	212
其他配置	214
第7章　API网关服务：Spring Cloud Zuul	217
快速入门	219
-- 构建网关	220
-- 请求路由	221
-- 请求过滤	223
路由详解	226
-- 传统路由配置	226
-- 服务路由配置	228
-- 服务路由的默认规则	229
-- 自定义路由映射规则	229
-- 路径匹配	230
-- 路由前缀	233
-- 本地跳转	234
--  Cookie与头信息	235
-- Hystrix和Ribbon支持	236
过滤器详解	238
-- 过滤器	238
-- 请求生命周期	239
-- 核心过滤器	240
-- 异常处理	244
-- 禁用过滤器	256
动态加载	257
-- 动态路由	257
-- 动态过滤器	261
第8章　分布式配置中心：Spring Cloud Config	267
快速入门	267
-- 构建配置中心	268
-- 配置规则详解	269
-- 客户端配置映射	272
服务端详解	274
-- 基础架构	274
-- Git配置仓库	276
-- SVN配置仓库	279
-- 本地仓库	279
-- 本地文件系统	279
-- 健康监测	280
-- 属性覆盖	281
-- 安全保护	281
-- 加密解密	282
-- 高可用配置	286
客户端详解	286
--  URI指定配置中心	287
-- 服务化配置中心	287
-- 失败快速响应与重试	290
-- 获取远程配置	292
-- 动态刷新配置	293
第9章　消息总线：Spring Cloud Bus	295
消息代理	295
RabbitMQ实现消息总线	296
-- 基本概念	297
-- 安装与使用	298
-- 快速入门	302
-- 整合Spring Cloud Bus	306
-- 原理分析	307
-- 指定刷新范围	308
-- 架构优化	309
-- RabbitMQ配置	310
Kafka实现消息总线	312
-- Kafka简介	312
-- 快速入门	313
--整合Spring Cloud Bus	315
-- Kafka配置	318
深入理解	318
-- 源码分析	320
-- 其他消息代理的支持	342
第10章　消息驱动的微服务：Spring Cloud Stream	344
快速入门	344
核心概念	349
-- 绑定器	350
-- 发布-订阅模式	351
-- 消费组	353
-- 消息分区	354
使用详解	355
-- 开启绑定功能	355
-- 绑定消息通道	356
-- 消息生产与消费	360
-- 响应式编程	366
-- 消费组与消息分区	368
-- 消息类型	370
绑定器详解	373
-- 绑定器SPI	373
-- 自动化配置	374
-- 多绑定器配置	374
--  RabbitMQ与Kafka绑定器	376
配置详解	376
-- 基础配置	377
-- 绑定通道配置	377
-- 绑定器配置	379
第11章　分布式服务跟踪：Spring Cloud Sleuth	386
快速入门	386
-- 准备工作	386
-- 实现跟踪	389
跟踪原理	390
抽样收集	392
与Logstash整合	394
与Zipkin整合	397
--  HTTP收集	398
-- 消息中间件收集	402
-- 收集原理	404
-- 数据存储	414
--  API接口	417
附录A　Starter POMs	419
后记	421
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式系统原理与范型
第1章 概述 1
1.1 分布式系统的定义 1
1.2 目标 3
1.2.1 使资源可访问 3
1.2.2 透明性 4
1.2.3 开放性 6
1.2.4 可扩展性 7
1.3 分布式系统的类型 12
1.3.1 分布式计算系统 12
1.3.2 分布式信息系统 14
1.3.3 分布式普适系统 17
本章小结 21
习题 22
第2章 体系结构 23
2.1 体系结构的样式 23
2.2 系统体系结构 25
2.2.1 集中式体系结构 25
2.2.2 非集中式体系结构 30
2.2.3 混合体系结构 36
2.3 体系结构与中间件 38
2.3.1 中断器 38
2.3.2 自适应软件的常见方法 40
2.3.3 讨论 40
2.4 分布式系统的自我管理 41
2.4.1 反馈控制模型 42
2.4.2 示例：用Astrolabe监视系统 43
2.4.3 示例：Globule中的差分复制策略 44
2.4.4 示例：Jade的自动组件修复管理 45
本章小结 46
习题 47
第3章 进程 48
3.1 线程 48
3.1.1 线程简介 49
3.1.2 分布式系统中的线程 52
3.2 虚拟化 55
3.2.1 虚拟化在分布式系统中的作用 55
3.2.2 虚拟机体系结构 56
3.3 客户 57
3.3.1 网络连接的用户接口 58
3.3.2 客户端软件与分布透明性 61
3.4 服务器 62
3.4.1 常见的设计问题 62
3.4.2 服务器集群 65
3.4.3 管理服务器集群 69
3.5 代码迁移 72
3.5.1 代码迁移方案 72
3.5.2 迁移与本地资源 75
3.5.3 异构系统中的代码迁移 77
本章小结 79
习题 80
第4章 通信 81
4.1 基础知识 81
4.1.1 分层协议 82
4.1.2 通信类型 87
4.2 远程过程调用 89
4.2.1 基本的RPC操作 89
4.2.2 参数传递 92
4.2.3 异步RPC 95
4.2.4 示例：DCE RPC 96
4.3 面向消息的通信 101
4.3.1 面向消息的瞬时通信 101
4.3.2 面向消息的持久通信 104
4.3.3 示例：IBM WebSphere消息队列系统 109
4.4 面向流的通信 113
4.4.1 为连续媒体提供支持 114
4.4.2 流与服务质量 115
4.4.3 流同步 117
4.5 多播通信 120
4.5.1 应用层多播 120
4.5.2 基于gossip的数据通信 123
本章小结 126
习题 127
第5章 命名系统 129
5.1 名称、标识符和地址 129
5.2 无层次命名 131
5.2.1 简单方法 131
5.2.2 基于宿主位置的方法 134
5.2.3 分布式散列表 135
5.2.4 分层方法 138
5.3 结构化命名 141
5.3.1 名称空间 141
5.3.2 名称解析 143
5.3.3 名称空间的实现 146
5.3.4 示例：域名系统 151
5.4 基于属性的命名 157
5.4.1 目录服务 157
5.4.2 分层实现：LDAP 158
5.4.3 非集中式实现 161
本章小结 164
习题 165
第6章 同步化 167
6.1 时钟同步 167
6.1.1 物理时钟 168
6.1.2 全球定位系统 171
6.1.3 时钟同步算法 172
6.2 逻辑时钟 176
6.2.1 Lamport逻辑时钟 176
6.2.2 向量时钟 179
6.3 互斥 182
6.3.1 概述 182
6.3.2 集中式算法 182
6.3.3 非集中式算法 183
6.3.4 分布式算法 184
6.3.5 令牌环算法 186
6.3.6 四种算法的比较 187
6.4 结点的全局定位 188
6.5 选举算法 190
6.5.1 传统的选举算法 190
6.5.2 无线系统环境中的选举算法 192
6.5.3 大型系统中的选举算法 193
本章小结 195
习题 196
第7章 一致性和复制 198
7.1 概述 198
7.1.1 进行复制的原因 198
7.1.2 作为扩展技术的复制 199
7.2 以数据为中心的一致性模型 200
7.2.1 持续一致性 201
7.2.2 一致的操作顺序 204
7.3 以客户为中心的一致性模型 209
7.3.1 最终一致性 209
7.3.2 单调读 211
7.3.3 单调写 212
7.3.4 读写一致性 213
7.3.5 写读一致性 214
7.4 复制管理 214
7.4.1 副本服务器的放置 215
7.4.2 内容复制与放置 216
7.4.3 内容分发 219
7.5 一致性协议 222
7.5.1 持续一致性 222
7.5.2 基于主备份的协议 223
7.5.3 复制的写协议 225
7.5.4 高速缓存相关性协议 227
7.5.5 实现以客户为中心的一致性 228
本章小结 230
习题 231
第8章 容错性 233
8.1 容错性概述 233
8.1.1 基本概念 233
8.1.2 故障模式 235
8.1.3 使用冗余掩盖故障 237
8.2 进程恢复 238
8.2.1 设计问题 238
8.2.2 故障掩盖和复制 240
8.2.3 故障系统的协定 240
8.2.4 故障检测 243
8.3 可靠的客户-服务器通信 244
8.3.1 点对点通信 244
8.3.2 失败时的RPC语义 244
8.4 可靠的组通信 248
8.4.1 基本的可靠多播方法 249
8.4.2 可靠多播中的可扩展性 249
8.4.3 原子多播 252
8.5 分布式提交 257
8.5.1 两阶段提交 257
8.5.2 三阶段提交 262
8.6 恢复 263
8.6.1 概述 263
8.6.2 检查点 266
8.6.3 消息日志 268
8.6.4 面向恢复的计算 270
本章小结 271
习题 271
第9章 安全性 273
9.1 安全性概述 273
9.1.1 安全威胁、策略和机制 273
9.1.2 设计问题 277
9.1.3 加密 281
9.2 安全通道 287
9.2.1 身份认证 287
9.2.2 消息的完整性和机密性 293
9.2.3 安全组通信 295
9.2.4 示例：Kerberos 298
9.3 访问控制 299
9.3.1 访问控制中的常见问题 299
9.3.2 防火墙 302
9.3.3 安全的移动代码 304
9.3.4 拒绝服务 309
9.4 安全管理 310
9.4.1 密钥管理 310
9.4.2 安全组管理 313
9.4.3 授权管理 314
本章小结 318
习题 319
第10章 基于对象的分布式系统 320
10.1 体系结构 320
10.1.1 分布式对象 320
10.1.2 示例：企业级Java Bean 322
10.1.3 示例：Globe分布式共享对象 324
10.2 进程 325
10.2.1 对象服务器 325
10.2.2 示例：Ice运行时系统 327
10.3 通信 329
10.3.1 把客户绑定到对象上 329
10.3.2 静态远程方法调用与动态远程方法调用 330
10.3.3 参数传递 331
10.3.4 示例：Java RMI 332
10.3.5 基于对象的消息传递 334
10.4 命名 337
10.4.1 CORBA对象引用 337
10.4.2 Globe对象引用 338
10.5 同步 340
10.6 一致性与复制 341
10.6.1 入口一致性 341
10.6.2 复制的调用 343
10.7 容错性 344
10.7.1 示例：CORBA的容错性 345
10.7.2 示例：Java的容错性 346
10.8 安全性 348
10.8.1 示例：Globe 348
10.8.2 远程对象的安全性 351
本章小结 352
习题 353
第11章 分布式文件系统 354
11.1 体系结构 354
11.1.1 客户-服务器体系结构 354
11.1.2 基于群集的分布式文件系统 358
11.1.3 对称式体系结构 360
11.2 进程 361
11.3 通信 362
11.3.1 NFS中的RPC 362
11.3.2 RPC2子系统 363
11.3.3 Plan 9中面向文件的通信 365
11.4 命名 366
11.4.1 NFS中的命名 366
11.4.2 构造全局名称空间 370
11.5 同步 371
11.5.1 文件共享的语义 371
11.5.2 文件锁定 373
11.5.3 在Coda中共享文件 375
11.6 一致性和复制 376
11.6.1 客户端缓存 376
11.6.2 服务器端复制 379
11.6.3 对等文件系统中的复制 381
11.6.4 网格系统中的文件复制 382
11.7 容错性 383
11.7.1 处理Byzantine故障 383
11.7.2 对等系统中的高度可用性 385
11.8 安全性 386
11.8.1 NFS中的安全性 386
11.8.2 分散式身份认证 388
11.8.3 安全的对等文件共享系统 391
本章小结 393
习题 394
第12章 基于Web的分布式系统 395
12.1 体系结构 395
12.1.1 传统的基于Web的系统 396
12.1.2 Web服务 399
12.2 进程 402
12.2.1 客户 402
12.2.2 Apache Web服务器 403
12.2.3 Web服务器群集 405
12.3 通信 406
12.3.1 超文本传输协议 407
12.3.2 简单对象访问协议 411
12.4 命名 412
12.5 同步 414
12.6 一致性与复制 414
12.6.1 Web代理缓存 415
12.6.2 Web宿主系统的复制 417
12.6.3 Web应用程序的复制 421
12.7 容错性 423
12.8 安全性 424
本章小结 425
习题 426
第13章 基于协作的分布式系统 428
13.1 协作模型介绍 428
13.2 体系结构 430
13.2.1 一般方法 430
13.2.2 传统的体系结构 431
13.2.3 对等体系结构 434
13.2.4 移动性和协作 436
13.3 进程 437
13.4 通信 437
13.4.1 基于内容的路由 437
13.4.2 支持复合订阅 439
13.5 命名 439
13.5.1 描述复合事件 440
13.5.2 匹配事件与订阅 441
13.6 同步 442
13.7 一致性和复制 442
13.7.1 静态方法 442
13.7.2 动态复制 445
13.8 容错性 447
13.8.1 可靠的发布-订阅通信 447
13.8.2 共享数据空间中的容错性 449
13.9 安全性 450
13.9.1 保密性 450
13.9.2 安全的共享数据空间 452
本章小结 452
习题 453
第14章 补充读物与参考文献 454
14.1 进一步阅读的建议 454
14.1.1 介绍性和综述性的著作 454
14.1.2 体系结构 455
14.1.3 进程 455
14.1.4 通信 456
14.1.5 命名 456
14.1.6 同步化 457
14.1.7 一致性与复制 457
14.1.8 容错性 458
14.1.9 安全性 458
14.1.10 面向对象的分布式系统 459
14.1.11 分布式文件系统 459
14.1.12 基于Web的分布式系统 460
14.1.13 基于协作的分布式系统 460
14.2 参考文献 461
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式系统原理与范型
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深度挖掘
第一部分  集群理论篇  第1章  集群的概念和发展  第2章  RAC的结构和原理  第3章  存储和网络传输第二部分  运行维护篇  第4章  Oracle RAC安装配置  第5章  RAC管理和维护  第6章  RAC备份和恢复  第7章  Oracle故障诊断及工具第三部分  性能篇  第8章  RAC性能优化设计  第9章  Oracle最高可用架构设计附录  使用VMware Server在Linux上搭建Oracle 10g RAC学习环境
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深度挖掘
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据架构
第1章　企业数据　　1
1.1　企业数据　　1
1.1.1　企业的全体数据　　1
1.1.2　非结构化数据的划分　　2
1.1.3　业务相关性　　3
1.1.4　大数据　　3
1.1.5　分界线　　4
1.1.6　大陆分水岭　　5
1.1.7　企业数据全貌　　6
1.2　数据基础设施　　6
1.2.1　重复型数据的两种类型　　7
1.2.2　重复型结构化数据　　7
1.2.3　重复型大数据　　8
1.2.4　两种基础设施　　9
1.2.5　优化了什么　　10
1.2.6　对比两种基础设施　　11
1.3　分界线　　12
1.3.1　企业数据分类　　12
1.3.2　分界线　　12
1.3.3　重复型非结构化数据　　13
1.3.4　非重复型非结构化数据　　15
1.3.5　不同的领域　　17
1.4　企业数据统计图　　17
1.5　企业数据分析　　22
1.6　数据的生命周期——随时间推移理解数据　　27
1.7　数据简史　　31
1.7.1　纸带和穿孔卡片　　31
1.7.2　磁带　　32
1.7.3　磁盘存储器　　32
1.7.4　数据库管理系统　　32
1.7.5　耦合处理器　　33
1.7.6　在线事务处理　　33
1.7.7　数据仓库　　34
1.7.8　并行数据管理　　34
1.7.9　Data Vault　　35
1.7.10　大数据　　35
1.7.11　分界线　　35
第2章　大数据　　37
2.1　大数据简史　　37
2.1.1　打个比方——占领制高点　　37
2.1.2　占领制高点　　38
2.1.3　IBM360带来的标准化　　38
2.1.4　在线事务处理　　39
2.1.5　Teradata的出现和大规模并行处理　　39
2.1.6　随后到来的Hadoop和大数据　　39
2.1.7　IBM和Hadoop　　39
2.1.8　控制制高点　　40
2.2　大数据是什么　　40
2.2.1　另一种定义　　40
2.2.2　大数据量　　40
2.2.3　廉价存储器　　41
2.2.4　罗马人口统计方法　　41
2.2.5　非结构化数据　　42
2.2.6　大数据中的数据　　42
2.2.7　重复型数据中的语境　　43
2.2.8　非重复型数据　　44
2.2.9　非重复型数据中的语境　　44
2.3　并行处理　　45
2.4　非结构化数据　　50
2.4.1　随处可见的文本信息　　50
2.4.2　基于结构化数据的决策　　51
2.4.3　业务价值定位　　51
2.4.4　重复型和非重复型的非结构化信息　　52
2.4.5　易于分析　　53
2.4.6　语境化　　54
2.4.7　一些语境化方法　　55
2.4.8　MapReduce　　56
2.4.9　手工分析　　56
2.5　重复型非结构化数据的语境化　　57
2.5.1　解析重复型非结构化数据　　57
2.5.2　重组输出数据　　58
2.6　文本消歧　　58
2.6.1　从叙事到分析数据库　　58
2.6.2　文本消歧的输入　　59
2.6.3　映射　　60
2.6.4　输入/输出　　61
2.6.5　文档分片/指定值处理　　61
2.6.6　文档预处理　　62
2.6.7　电子邮件——一个特例　　62
2.6.8　电子表格　　63
2.6.9　报表反编译　　63
2.7　分类法　　65
2.7.1　数据模型和分类法　　65
2.7.2　分类法的适用性　　66
2.7.3　分类法是什么　　66
2.7.4　多语言分类法　　68
2.7.5　分类法与文本消歧的动态　　68
2.7.6　分类法和文本消歧——不同的技术　　69
2.7.7　分类法的不同类型　　70
2.7.8　分类法——随时间推移不断维护　　70
第3章　数据仓库 　　71
3.1　数据仓库简史　　71
3.1.1　早期的应用程序　　71
3.1.2　在线应用程序　　71
3.1.3　抽取程序　　72
3.1.4　4GL技术　　73
3.1.5　个人电脑　　73
3.1.6　电子表格　　74
3.1.7　数据完整性　　75
3.1.8　蛛网系统　　76
3.1.9　维护积压　　77
3.1.10　数据仓库　　78
3.1.11　走向架构式环境　　78
3.1.12　走向企业信息工厂　　78
3.1.13　DW 2.0　　79
3.2　集成的企业数据　　81
3.2.1　数量众多的应用程序　　81
3.2.2　放眼企业　　82
3.2.3　多个分析师　　83
3.2.4　ETL技术　　84
3.2.5　集成的挑战　　86
3.2.6　数据仓库的效益　　86
3.2.7　粒度的视角　　87
3.3　历史数据　　89
3.4　数据集市　　92
3.4.1　颗粒化的数据　　92
3.4.2　关系数据库设计　　93
3.4.3　数据集市　　93
3.4.4　关键性能指标　　94
3.4.5　维度模型　　94
3.4.6　数据仓库和数据集市的整合　　95
3.5　作业数据存储　　96
3.5.1　集成数据的在线事务处理　　96
3.5.2　作业数据存储　　97
3.5.3　ODS和数据仓库　　98
3.5.4　ODS分类　　99
3.5.5　将外部数据更新到ODS　　99
3.5.6　ODS/数据仓库接口　　100
3.6　对数据仓库的误解　　101
3.6.1　一种简单的数据仓库架构　　101
3.6.2　在数据仓库中进行在线高性能事务处理　　101
3.6.3　数据完整性　　102
3.6.4　数据仓库工作负载　　102
3.6.5　来自数据仓库的统计处理　　103
3.6.6　统计处理的频率　　104
3.6.7　探查仓库　　104
第4章　Data Vault　　106
4.1　Data Vault简介　　106
4.1.1　Data Vault 2.0建模　　107
4.1.2　Data Vault 2.0方法论定义　　107
4.1.3　Data Vault 2.0架构　　107
4.1.4　Data Vault 2.0实施　　108
4.1.5　Data Vault 2.0商业效益　　108
4.1.6　Data Vault 1.0　　109
4.2　Data Vault建模介绍　　110
4.2.1　Data Vault模型概念　　110
4.2.2　Data Vault模型定义　　110
4.2.3　Data Vault模型组件　　111
4.2.4　Data Vault和数据仓库　　112
4.2.5　转换到Data Vault建模　　112
4.2.6　数据重构　　113
4.2.7　Data Vault建模的基本规则　　114
4.2.8　为什么需要多对多链接结构　　114
4.2.9　散列键代替顺序号　　115
4.3　Data Vault架构介绍　　116
4.3.1　Data Vault 2.0架构　　116
4.3.2　如何将NoSQL适用于本架构　　117
4.3.3　Data Vault 2.0架构的目标　　117
4.3.4　Data Vault 2.0建模的目标　　118
4.3.5　软硬业务规则　　118
4.3.6　托管式SSBI与DV2架构　　119
4.4　Data Vault方法论介绍　　120
4.4.1　Data Vault 2.0方法论概述　　120
4.4.2　CMMI和Data Vault 2.0方法论　　120
4.4.3　CMMI与敏捷性的对比　　122
4.4.4　项目管理实践和SDLC与CMMI和敏捷的对比　　123
4.4.5　六西格玛和Data Vault 2.0方法论　　123
4.4.6　全质量管理　　124
4.5　Data Vault实施介绍　　125
4.5.1　实施概述　　125
4.5.2　模式的重要性　　126
4.5.3　再造工程和大数据　　127
4.5.4　虚拟化我们的数据集市　　128
4.5.5　托管式自助服务BI　　128
第5章　作业环境　　130
5.1　作业环境——简史　　130
5.1.1　计算机的商业应用　　130
5.1.2　最初的应用程序　　131
5.1.3　Ed Yourdon和结构化革命　　132
5.1.4　系统开发生命周期　　132
5.1.5　磁盘技术　　132
5.1.6　进入数据库管理系统时代　　133
5.1.7　响应时间和可用性　　133
5.1.8　现代企业计算　　136
5.2　标准工作单元　　136
5.2.1　响应时间要素　　136
5.2.2　沙漏的比喻　　137
5.2.3　车道的比喻　　138
5.2.4　你的车跑得跟前面的车一样快　　139
5.2.5　标准工作单元　　139
5.2.6　服务等级协议　　139
5.3　面向结构化环境的数据建模　　140
5.3.1　路线图的作用　　140
5.3.2　只要粒度化的数据　　140
5.3.3　实体关系图　　141
5.3.4　数据项集　　142
5.3.5　物理数据库设计　　143
5.3.6　关联数据模型的不同层次　　143
5.3.7　数据联动的示例　　144
5.3.8　通用数据模型　　146
5.3.9　作业数据模型和数据仓库数据模型　　146
5.4　元数据　　146
5.4.1　典型元数据　　146
5.4.2　存储库　　147
5.4.3　使用元数据　　148
5.4.4　元数据用于分析　　149
5.4.5　查看多个系统　　150
5.4.6　数据谱系　　150
5.4.7　比较已有系统和待建系统　　150
5.5　结构化数据的数据治理　　151
5.5.1　企业活动　　151
5.5.2　数据治理的动机　　152
5.5.3　修复数据　　152
5.5.4　粒度化的详细数据　　153
5.5.5　编制文档　　153
5.5.6　数据主管岗位　　154
第6章　数据架构　　156
6.1　数据架构简史　　156
6.2　大数据/已有系统的接口　　166
6.2.1　大数据/已有系统的接口　　166
6.2.2　重复型原始大数据/已有系统接口　　167
6.2.3　基于异常的数据　　168
6.2.4　非重复型原始大数据/已有系统接口　　169
6.2.5　进入已有系统环境　　170
6.2.6  “语境丰富”的大数据环境　　171
6.2.7　将结构化数据/非结构化数据放在一起分析　　172
6.3　数据仓库/作业环境接口　　172
6.3.1　作业环境/数据仓库接口　　172
6.3.2　经典的ETL接口　　173
6.3.3　作业数据存储/ETL接口　　173
6.3.4　集结区　　174
6.3.5　变化数据的捕获　　175
6.3.6　内联转换　　175
6.3.7　ELT处理　　176
6.4　数据架构——一种高层视角　　177
6.4.1　一种高层视角　　177
6.4.2　冗余　　177
6.4.3　记录系统　　178
6.4.4　不同的群体　　180
第7章　重复型分析　　181
7.1　重复型分析——必备基础　　181
7.1.1　不同种类的分析　　181
7.1.2　寻找模式　　182
7.1.3　启发式处理　　183
7.1.4　沙箱　　186
7.1.5　标准概况　　187
7.1.6　提炼、筛选　　188
7.1.7　建立数据子集　　188
7.1.8　筛选数据　　190
7.1.9　重复型数据和语境　　192
7.1.10　链接重复型记录　　193
7.1.11　日志磁带记录　　193
7.1.12　分析数据点　　194
7.1.13　按时间的推移研究数据　　195
7.2　分析重复型数据　　196
7.2.1　日志数据　　198
7.2.2　数据的主动/被动式索引　　199
7.2.3　汇总/详细数据　　200
7.2.4　大数据中的元数据　　202
7.2.5　相互关联的数据　　203
7.3　重复型分析　　204
7.3.1　内部、外部数据　　204
7.3.2　通用标识符　　205
7.3.3　安全性　　205
7.3.4　筛选、提炼　　207
7.3.5　归档结果　　208
7.3.6　指标　　210
第8章　非重复型分析　　211
8.1　非重复型数据　　211
8.1.1　内联语境化　　213
8.1.2　分类法/本体处理　　214
8.1.3　自定义变量　　215
8.1.4　同形异义消解　　216
8.1.5　缩略语消解　　217
8.1.6　否定分析　　218
8.1.7　数字标注　　219
8.1.8　日期标注　　220
8.1.9　日期标准化　　220
8.1.10　列表的处理　　220
8.1.11　联想式词处理　　221
8.1.12　停用词处理　　222
8.1.13　提取单词词根　　222
8.1.14　文档元数据　　223
8.1.15　文档分类　　223
8.1.16　相近度分析　　224
8.1.17　文本ETL中功能的先后顺序　　225
8.1.18　内部参照完整性　　225
8.1.19　预处理、后处理　　226
8.2　映射　　227
8.3　分析非重复型数据　　229
8.3.1　呼叫中心信息　　229
8.3.2　医疗记录　　237
第9章　作业分析1　　242
第10章　作业分析2　　249
第11章　个人分析　　259
第12章　复合式的数据架构　　264
词汇表　　268
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式实时处理系统：原理、架构与实现
目录
本书赞誉
序一
序二
序三
前言
第1章　分布式计算概述 1
1.1　分布式概念 1
1.2　分布式计算及其原理 2
1.3　分布式系统特性 3
1.3.1　容错性 3
1.3.2　高可扩展性 4
1.3.3　开放性 5
1.3.4　并发处理能力 5
1.3.5　透明性 6
1.4　通用分布式计算系统 6
1.4.1　Apache Hadoop 6
1.4.2　Apache Spark 8
1.4.3　Apache Storm 9
1.5　分布式存储系统 10
1.5.1　分布式存储概念 10
1.5.2　分布式存储系统特点 12
1.5.3　分布式存储系统分类 12
1.5.4　常见分布式存储系统 13
1.6　本章小结 14
第2章　分布式系统通信基础 15
2.1　时代的浪潮 15
2.1.1　集中式通信网 16
2.1.2　去中心化 16
2.2　可靠的数据链路 17
2.2.1　数据分组 17
2.2.2　帧同步 18
2.2.3　差错控制 18
2.2.4　链路管理 18
2.2.5　问题与解决方案 19
2.3　分层架构 19
2.4　网络层 22
2.4.1　寻找路径 22
2.4.2　网络分层 23
2.4.3　TCP/IP概述 23
2.4.4　IP协议 24
2.5　传输层 30
2.5.1　数据自动分包 30
2.5.2　端到端的传输 30
2.5.3　数据的可靠传输 30
2.6　应用层 35
2.6.1　ping 35
2.6.2　telnet 36
2.6.3　OSPF 36
2.6.4　DNS 36
2.6.5　HTTP协议 37
2.7　基于消息协议的公告牌 38
2.7.1　需求描述 38
2.7.2　制定协议 38
2.8　分布式通信举例——MapReduce 39
2.9　本章小结 41
第3章　通信系统高层抽象 42
3.1　RPC介绍 42
3.2　RESTful 44
3.2.1　资源和表现层 45
3.2.2　状态转移 45
3.2.3　RESTful总结 46
3.3　消息队列 46
3.4　序列化 49
3.5　使用Thrift实现公告牌服务 50
3.5.1　Apache Thrift介绍 51
3.5.2　安装Apache Thrift 51
3.5.3　编写Thrift文件 52
3.5.4　实现服务器 53
3.5.5　实现客户端 54
3.6　本章小结 56
第4章　走进C++高性能编程 57
4.1　基于C++的留言板系统 58
4.1.1　基于Socket的通信 58
4.1.2　C++中的内存与资源管理 64
4.2　来自服务器的天书 69
4.2.1　编码 69
4.2.2　C++98的编码缺陷 72
4.2.3　C++11编码支持 73
4.3　繁忙的服务器 75
4.3.1　分身乏术 75
4.3.2　fork——分身术 76
4.3.3　进程间通信 79
4.3.4　轻量级分身——线程 85
4.3.5　C++11线程 86
4.3.6　竞争问题与解决方案 88
4.3.7　多线程优化 95
4.3.8　异步I/O 99
4.4　消失不见的内存 105
4.4.1　内存分配与内存碎片 106
4.4.2　tcmalloc 108
4.4.3　内存池 110
4.5　本章小结 112
第5章　分布式实时处理系统 113
5.1　Hadoop与MapReduce 113
5.1.1　HDFS 114
5.1.2　MapReduce模型 115
5.2　Storm实时处理系统 129
5.2.1　历史 129
5.2.2　计算模型 130
5.2.3　总体架构 133
5.2.4　Storm元数据 133
5.2.5　Storm与Hadoop比较 138
5.3　有保证的消息处理 139
5.3.1　完全处理与元组树 139
5.3.2　元组的唯一标识 139
5.3.3　确认和失败 141
5.3.4　高效实现 143
5.4　本章小结 144
第6章　实时处理系统编程接口设计 145
6.1　总体架构设计 145
6.1.1　Hurricane与Storm比较 145
6.1.2　总体架构 146
6.1.3　任务接口 148
6.2　消息源接口设计 149
6.3　消息处理器接口设计 150
6.4　数据收集器设计 151
6.5　元组接口设计 154
6.6　序列化接口设计 160
6.7　本章小结 161
第7章　服务组件设计与实现 162
7.1　Executor设计与实现 162
7.1.1　事件驱动的消息队列 162
7.1.2　动态装载技术 167
7.1.3　Executor实现 169
7.2　Task设计与实现 171
7.3　本章小结 172
第8章　管理服务设计与实现 173
8.1　President功能与设计 173
8.2　President实现 174
8.2.1　简单的网络通信实现 175
8.2.2　Topology装载实现 182
8.2.3　Manager管理调度实现 184
8.2.4　序列化实现 193
8.3　本章小结 198
第9章　实时处理系统编程接口实现 199
9.1　消息源接口实现 200
9.1.1　消息源执行器 200
9.1.2　WordCount实现实例 205
9.2　消息处理单元接口实现 207
9.2.1　消息处理单元执行器 207
9.2.2　事件处理 212
9.2.3　WordCount实现实例 215
9.3　数据收集器实现 218
9.3.1　分发策略 218
9.3.2　传输层实现 224
9.4　本章小结 226
第10章　可靠消息处理 227
10.1　基本概念 227
10.1.1　完全处理 227
10.1.2　失败与重发 229
10.2　接口设计 229
10.3　具体实现 233
10.3.1　简单实现 233
10.3.2　高效实现 235
10.4　本章小结 237
第11章　通信系统设计与实现 238
11.1　I/O多路复用方案解析 239
11.1.1　基本网络编程接口 239
11.1.2　非阻塞的服务器程序 241
11.1.3　使用select()接口的基于事件驱动的服务器模型 242
11.1.4　使用epoll实现异步事件通知模型 245
11.2　基础工具 249
11.2.1　线程工具 250
11.2.2　日志工具 254
11.3　传输层实现 263
11.3.1　Reactor模式 263
11.3.2　定义抽象TP传输层 264
11.3.3　实现基于epoll的TP传输层 269
11.3.4　实现基于IOCP的TP传输层 290
11.4　应用层HTTP实现 307
11.4.1　HttpContext 307
11.4.2　HttpRequest 311
11.4.3　HttpResponse 313
11.4.4　HttpConnection 315
11.4.5　HttpServer 317
11.4.6　总结 319
11.5　跨平台分割编译 320
11.5.1　Makefile 320
11.5.2　Kake 323
11.6　与实时处理系统集成 325
11.6.1　修改NetListener 325
11.6.2　修改NetConnector 327
11.7　本章小结 330
第12章　事务性Topology实现 331
12.1　Exact-once语义解决方案 331
12.2　设计细节 333
12.2.1　构造事务性Topology 333
12.2.2　消息处理单元 334
12.3　事务性Topology API 337
12.3.1　消息处理单元 337
12.3.2　事务性消息源 339
12.4　本章小结 339
第13章　多语言接口 340
13.1　C语言通用接口 340
13.1.1　元组接口 342
13.1.2　消息源接口 346
13.1.3　消息处理单元接口 349
13.1.4　计算拓扑接口 352
13.2　Python接口 354
13.2.1　ctypes 354
13.2.2　元组接口 356
13.2.3　消息源接口 359
13.2.4　消息处理单元接口 360
13.2.5　计算拓扑接口 361
13.2.6　应用示例 364
13.3　JavaScript接口 365
13.3.1　V8引擎 366
13.3.2　Node.js 366
13.3.3　V8的互操作接口 367
13.3.4　任务接口 368
13.3.5　消息源接口 369
13.3.6　消息处理单元接口 370
13.3.7　计算拓扑接口 371
13.3.8　应用示例 373
13.4　Java接口 375
13.4.1　任务接口 375
13.4.2　消息源接口 376
13.4.3　消息处理单元接口 377
13.4.4　计算拓扑接口 377
13.4.5　本地代码 380
13.4.6　应用示例 382
13.5　Swift接口 384
13.5.1　应用范围 385
13.5.2　任务接口 385
13.5.3　消息源接口 386
13.5.4　消息处理单元接口 387
13.5.5　计算拓扑接口 388
13.6　本章小结 390
第14章　Squared设计与实现——实现高级抽象元语 391
14.1　Storm Trident介绍 391
14.1.1　Squared示例 391
14.1.2　DRPC示例 394
14.2　Squared实现 396
14.2.1　SquaredTopology和Spout 396
14.2.2　SquaredBolt 401
14.2.3　Stream 405
14.2.4　状态存储 410
14.2.5　DRPC实现 412
14.2.6　操作与处理节点 416
14.2.7　流操作 419
14.3　本章小结 423
第15章　实战：日志流处理 425
15.1　日志流处理设计方案 425
15.2　实现Topology 427
15.2.1　编写消息源 427
15.2.2　编写索引消息处理单元 428
15.2.3　编写统计消息处理单元 429
15.3　本章小结 431
第16章　实战：频繁组合查找 432
16.1　背景介绍 432
16.1.1　数据挖掘概念 432
16.1.2　关联规则和频繁项集 433
16.1.3　啤酒与尿布 435
16.2　频繁二项集挖掘方法 435
16.2.1　频繁二项集 435
16.2.2　算法设计思路 438
16.2.3　Hurricane实现思路 439
16.3　编写Spout 439
16.4　编写Bolt 441
16.4.1　SplitBolt 441
16.4.2　PairCountBolt 442
16.4.3　PairTotalCountBolt 443
16.4.4　ConfidenceComputeBolt 444
16.4.5　SupportComputeBolt 445
16.4.6　FilterBolt 447
16.5　编写Topology 448
16.6　本章小结 449
第17章　实战：在AWS和阿里云上部署Hurricane实时处理系统 450
17.1　AWS部署 450
17.1.1　搭建虚拟私有云 452
17.1.2　配置安全组 455
17.1.3　加载EC2实例 456
17.1.4　弹性IP地址管理 461
17.2　阿里云部署 464
17.2.1　创建虚拟私有云 464
17.2.2　管理安全组 467
17.2.3　创建ECS 468
17.2.4　SSH登录 471
17.3　Hurricane分布式部署与管理 471
17.3.1　分布式部署原理 472
17.3.2　分布式安装配置 472
17.3.3　分布式启动 476
17.4　部署分布式实时处理系统 477
17.5　未来之路 478
17.6　本章小结 479
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式实时处理系统：原理、架构与实现
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件工程
Software Engineering: Architecture-Driven Software Development
出版者的话
译者序
作者序
前言
第一部分　软件工程基础
第1章　软件工程简介 5
1.1　明确软件需求 6
1.2　软件架构 7
1.3　集成产品和过程开发 8
1.4　集成产品团队 8
1.5　工作分解结构 10
1.6　软件分解结构 10
1.7　规约树和文档树 11
1.8　集成总体方案和进度安排 11
1.9　评审与审核 12
1.10　配置管理和变更控制 13
1.11　权衡分析 15
1.12　风险管理 16
1.13　建模与仿真 16
第2章　通用软件开发框架 19
2.1　软件分解结构 19
2.2　软件开发过程 21
2.2.1　需求定义阶段 22
2.2.2　概要架构定义阶段 22
2.2.3　关键架构定义阶段 23
2.2.4　软件单元编码和测试阶段 24
2.2.5　软件组件的集成和测试阶段 24
2.2.6　产品测试阶段 24
2.2.7　验收测试阶段 25
2.3　总结 26
第3章　软件架构 27
3.1　涉众需求的关系和依赖性 29
3.2　软件需求基线的关系和依赖性 30
3.3　计算环境的关系和依赖性 30
3.4　测试和评估的关系及依赖性 30
3.5　功能架构的关系和依赖性 31
3.6　物理架构的关系和依赖性 31
3.7　开发后的过程的关系和依赖性 32
3.8　软件架构的动机 32
第4章　理解软件项目环境 35
4.1　集成产品团队 38
4.2　软件架构 39
4.3　复杂性控制机制 40
4.3.1　工作分解结构 40
4.3.2　产品分解结构 41
4.3.3　规约树 42
4.3.4　文档树 42
4.3.5　软件产品基线 42
4.3.6　需求可追踪性准则 42
4.3.7　权衡分析 43
4.3.8　软件复杂性度量 44
4.4　软件术语注册表 46
4.5　软件集成策略 47
4.6　项目和技术方案 47
4.6.1　技术组织规划 48
4.6.2　项目规划 48
第5章　软件集成产品和过程开发 50
5.1　IPPD在软件中的应用 51
5.1.1　客户至上 52
5.1.2　产品和进程的并行开发 53
5.1.3　早期的和连续的生命周期规划 54
5.1.4　最大化承包商独特方法的优化和使用灵活性 54
5.1.5　鼓励鲁棒设计，提高过程能力? 55
5.1.6　事件驱动进度 55
5.1.7　多部门团队协作 55
5.1.8　授权 55
5.1.9　无缝管理工具 56
5.1.10　风险的主动识别和管理 56
5.2　软件工程和开发 56
第6章　软件设计阻碍 58
6.1　作为原材料的软件 59
6.2　软件技术的变革 61
6.2.1　软件开发方法和标准 63
6.2.2　敏捷宣言 66
6.3　架构驱动的软件开发 67
第二部分　软件工程实践
第7章　理解软件需求 76
7.1　第1步：征求渉众需求与期望 78
7.2　第2步：需求分析与规约 79
7.2.1　平衡和化解渉众需求的冲突 80
7.2.2　维护项目的范围 81
7.2.3　有经验的软件人员的参与 82
7.3　第3步：任务定义与安排 82
7.4　第4步：资源的确定、估算和分配 83
7.5　第5步：建立组织工作包 83
7.6　第6步：技术规划 83
7.7　第7步：项目规划 83
7.8　探索渉众的需求 84
第8章　软件需求分析实践 86
8.1　项目分析任务 86
8.1.1　分析项目目的和目标 86
8.1.2　确定开发成功标准 87
8.1.3　征求渉众需求和期望 88
8.1.4　对渉众需求按优先级排序 89
8.2　业务分析任务 89
8.2.1　确定业务概念 89
8.2.2　确定业务场景 89
8.2.3　确定计算环境特征 90
8.2.4　确定外部接口 91
8.3　产品分析任务 91
8.3.1　确定业务模式 91
8.3.2　确定功能行为 91
8.3.3　确定资源利用率需求 93
8.3.4　确定数据处理条件逻辑 93
8.3.5　确定数据持久性需求 93
8.3.6　确定数据安全性需求 93
8.3.7　确定数据存储事务 93
8.3.8　确定性能度量 94
8.4　维护分析任务 94
8.4.1　确定开发后的过程业务概念 94
8.4.2　确定开发后的过程业务场景 94
8.4.3　确定开发后的过程特征 94
8.4.4　确定架构的指导方针和原则 95
8.5　项目评估任务 95
8.5.1　评估需求敏感性 95
8.5.2　确定软件测试策略 96
8.5.3　评估已提议的变更 96
8.5.4　评估项目可行性 97
8.6　建立需求基线 97
第9章　软件需求管理 98
9.1　接受变更 98
9.1.1　时间是一种宝贵资源 98
9.1.2　变更影响分析 99
9.1.3　调整项目里程碑 101
9.2　明确需求 102
9.3　需求分解和分配 103
9.3.1　功能分析 104
9.3.2　性能分配 104
9.3.3　结构化单元综合 104
9.3.4　结构化组件综合 105
9.4　需求可追踪性 105
9.4.1　变更控制 105
9.4.2　配置审核 106
第10章　制定功能架构 107
10.1　功能架构的动机 107
10.2　功能架构本体论 108
10.2.1　功能组件 109
10.2.2　功能单元 109
10.2.3　数据项 109
10.2.4　功能接口 109
10.2.5　外部接口 109
10.2.6　控制结构 110
10.2.7　资源 110
10.2.8　数据存储 110
10.3　构想功能架构 110
10.4　记录功能架构 112
10.4.1　功能层次 112
10.4.2　行为模型 112
10.4.3　功能时限 113
10.4.4　资源利用率概述 113
10.4.5　功能规约 113
10.4.6　需求分配表 114
第11章　功能分析与分配实践 115
11.1　评估功能复杂性 115
11.2　行为分析 117
11.2.1　识别功能场景 117
11.2.2　识别功能序列 118
11.2.3　识别数据流 118
11.2.4　识别控制行为 119
11.2.5　识别数据处理过程 119
11.2.6　识别资源先决条件 120
11.2.7　识别失效条件 120
11.2.8　识别系统监控过程 121
11.2.9　识别数据保留能力需求 122
11.2.10　识别数据安全过程 122
11.2.11　识别数据持久性与保留功能 122
11.3　性能分配 122
11.3.1　分配性能预算 123
11.3.2　分配资源预算 123
11.4　架构评估 123
11.4.1　评估需求满足 124
11.4.2　评估软件性能 124
11.4.3　评估架构复杂性 124
11.4.4　评估优化机会 124
11.5　建立功能架构 124
第12章　物理架构配置 125
12.1　结构设计解决方案 126
12.1.1　定义结构单元 127
12.1.2　准备结构单元规约 128
12.1.3　建立软件集成策略 129
12.1.4　指定工程组套 129
12.1.5　准备软件技术数据包 129
12.2　结构设计考量 130
12.2.1　结构设计指导原则 130
12.2.2　使用建模与仿真 132
12.2.3　行为分析 132
12.2.4　结构权衡分析 133
12.2.5　软件产品性能评估 134
12.2.6　软件原型 136
第13章　软件设计综合实践 138
13.1　设计概念化 139
13.1.1　建立软件架构设计指导原则 140
13.1.2　识别抽象结构组件 141
13.1.3　识别抽象用户接口机制 141
13.2　设计解决方案 142
13.2.1　识别基本结构元素 142
13.2.2　识别集成组件 143
13.2.3　评估软件重用机会 143
13.3　设计相关性 144
13.3.1　建立性能基准 144
13.3.2　识别结构设计缺点 145
13.3.3　评估架构候选方案 146
13.3.4　评估软件实现挑战 146
13.3.5　评估软件维护挑战 146
13.3.6　评估架构完整性 147
13.4　设计表现 147
13.4.1　建立结构设计配置 147
13.4.2　说明结构配置元素 148
13.4.3　识别工程组套 148
13.5　准备软件技术数据包 148
第14章　软件分析实践 150
14.1　定义权衡研究 151
14.1.1　建立权衡研究领域 151
14.1.2　确定候选方案 152
14.1.3　建立成功标准 152
14.2　建立权衡研究环境 153
14.2.1　汇集实验机制 153
14.2.2　汇集数据收集和分析机制 153
14.2.3　建立权衡研究过程 154
14.3　执行分析 154
14.3.1　评估需求候选方案 155
14.3.2　评估功能候选方案 155
14.3.3　评估结构候选方案 155
14.4　评估项目影响 156
14.4.1　评估开发影响 156
14.4.2　评估项目影响 156
14.4.3　确定项目执行策略 156
14.5　评估权衡研究结果 156
14.5.1　为架构候选方案排序 157
14.5.2　确定优先行动路径 157
14.5.3　将权衡研究的决策文档化 157
14.5.4　优化执行策略 158
第15章　软件验证和确认实践 159
15.1　定义V&V策略 160
15.1.1　建立V&V范围 160
15.1.2　建立V&V方法 162
15.1.3　建立V&V过程 162
15.2　验证软件架构 163
15.2.1　验证需求基线 163
15.2.2　验证功能架构 163
15.2.3　验证物理架构 163
15.2.4　验证软件实现 163
15.3　确认物理架构 163
15.3.1　确认结构配置 163
15.3.2　确认集成软件配置 163
15.4　记录V&V结果 164
第16章　软件控制实践 165
16.1　配置管理 166
16.1.1　识别架构元素 166
16.1.2　维护架构状态 166
16.2　处理工程变更包 167
16.2.1　记录工程变更请求和提议 167
16.2.2　准备变更评估包 167
16.3　变更评估 168
16.3.1　评估变更技术优点 168
16.3.2　评估架构影响 169
16.3.3　评估技术工作包影响 169
16.3.4　评估技术方案影响 169
16.4　变更同化 170
16.4.1　发布变更通知包 170
16.4.2　审核架构变更进展 170
16.4.3　评估项目现状 170
16.5　软件库控制 170
16.5.1　维护工程工件库 171
16.5.2　维护变更历史库 171
16.5.3　维护技术风险库 171
第三部分　软件工程应用的阶段
第17章　软件需求定义 176
17.1　软件需求定义的产品 176
17.2　软件工程集成产品团队（软件需求定义阶段） 178
17.3　软件实现（软件需求定义阶段） 180
17.4　计算环境准备（软件需求定义阶段） 180
17.5　开发后的过程实现（软件需求定义阶段） 180
17.6　软件测试和评估（软件需求定义阶段） 181
17.7　评审、里程碑和基线（软件需求定义阶段） 182
第18章　软件架构定义 184
18.1　概要架构定义 185
18.1.1　概要架构定义的产品 185
18.1.2　软件工程集成产品团队（概要架构定义阶段） 186
18.1.3　软件实现（概要架构定义阶段） 187
18.1.4　计算环境准备（概要架构定义阶段） 187
18.1.5　开发后的过程准备（概要架构定义阶段） 187
18.1.6　软件测试和评估（概要架构定义阶段） 188
18.1.7　评审与里程碑（概要架构定义阶段） 189
18.2　详细架构定义 189
18.2.1　详细架构定义的产品 190
18.2.2　软件工程集成产品团队（详细架构定义阶段） 191
18.2.3　软件实现（详细架构定义阶段） 192
18.2.4　计算环境准备（详细架构定义阶段） 192
18.2.5　开发后的过程准备（详细架构定义阶段） 192
18.2.6　软件测试和评估（详细架构定义阶段） 193
18.2.7　评审与里程碑（详细架构定义阶段） 193
18.2.8　建立分配基线 194
第19章　软件实现 195
19.1　软件实现的产品 196
19.2　软件工程任务（软件实现阶段） 197
19.3　软件实现任务（软件实现阶段） 197
19.4　计算环境任务（软件实现阶段） 199
19.5　开发后的过程任务（软件实现阶段） 199
19.6　软件测试和评估任务（软件实现阶段） 199
19.7　评审与里程碑（软件实现阶段） 200
第20章　软件验收测试 202
20.1　软件验收测试的产品 203
20.2　软件工程（软件验收测试阶段） 203
20.3　软件实现组织（软件验收测试阶段） 204
20.4　计算环境实现组织（软件验收测试阶段） 204
20.5　开发后的过程组织（软件验收测试阶段） 204
20.6　软件测试和评估（软件验收测试阶段） 205
20.7　评审与里程碑（软件验收测试阶段） 205
20.8　建立软件产品基线 206
索引 207
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件工程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>中國文化的基層架構
序言
第一章　文化的意涵
第二章　文明的成長、僵化與覆滅
第三章　人類文化的模式──繭式文化
第四章　周文化的歷史地位
第五章　神話與神話原型
第六章　商周的遞嬗與宗法制度
第七章　家族主義的形成與持續
第八章　周公與孔子
第九章　孟子的光輝與矛盾
第十章　不見容於周文化的墨家
第十一章　道家對周文化的背反
第十二章　儒家的另一面──法家
第十三章　中國文化中的陰陽觀
第十四章　秦文化的興起與消弭
第十五章　周文化的復起與鞏固
第十六章　家族倫理的政治化──釋《孝經》
第十七章　中國文化中的女性地位：《列女傳》的意義
第十八章　中國人心靈中的黑暗海洋
第十九章　中國文化的轉折
第二十章　從傳統到現代
第二十一章　從集體主義到個人主義
第二十二章　結語
參考資料
附錄　馬森著作目錄
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>中國文化的基層架構
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式数据库架构及企业实践——基于Mycat中间件
第 1 章数据库中间件与分布式数据库的实现 1
1.1 什么是分布式系统  1
1.2 为什么需要分布式数据库  2
1.3 分布式数据库的实现原理  3
1.4 Mycat 数据库中间件简介 5
1.4.1 Mycat 的历史与未来规划 5
1.4.2 Mycat 与其他中间件的区别 8
1.4.3 Mycat 的优势  10
1.4.4 Mycat 的适用场合  11
第 2 章 Mycat 入门  13
2.1 环境搭建 13
2.1.1 Windows 环境搭建  13
2.1.2 Linux 环境搭建  15
2.2 Mycat 核心概念详解 16
2.2.1 逻辑库（schema） 16
2.2.2 逻辑表（table） 16
2.2.3 分片节点（dataNode） 17
2.2.4 节点主机（dataHost）  17
2.3 Mycat 原理介绍  18
2.4 参与 Mycat 源码开发  19
2.4.1 Mycat 源码环境搭建  19
2.4.2 Mycat 源码调试  19
第 3 章 Mycat 进阶  22
3.1 Mycat 配置详解 22
3.1.1 Mycat 支持的两种配置方式 22
3.1.2 server.xml 配置文件 23
3.1.3 schema.xml 配置文件  28
3.1.4 sequence 配置文件 37
3.1.5 zk-create.yaml 配置文件  41
3.1.6 其他配置文件  44
3.2 Mycat 分片规则详解  46
3.2.1 分片表与非分片表  46
3.2.2 ER 关系分片表  46
3.2.3 分片规则 rule.xml 文件详解  46
3.2.4 取模分片  47
3.2.5 枚举分片  48
3.2.6 范围分片  49
3.2.7 范围求模算法  49
3.2.8 固定分片 hash 算法 50
3.2.9 取模范围算法 52
3.2.10 字符串 hash 求模范围算法  53
3.2.11 应用指定的算法  54
3.2.12 字符串 hash 解析算法  54
3.2.13 一致性 hash 算法  55
3.2.14 按日期（天）分片算法  56
3.2.15 按单月小时算法  57
3.2.16 自然月分片算法  58
3.2.17 日期范围 hash 算法  58
3.3 Mycat 管理命令详解 59
3.3.1 Reload 命令 61
3.3.2 Show 命令  62
第 4 章 Mycat 高级技术实战  68
4.1 用 Mycat 搭建读写分离  68
4.1.1 MySQL 读写分离 69
4.1.2 MySQL Galera Cluster 读写分离 73
4.1.3 SQL Server 读写分离  83
4.2 Mycat 故障切换 86
4.2.1 Mycat 主从切换 86
4.2.2 MySQL Galera 节点切换 99
4.3 Mycat+Percona+HAProxy+Keepalived 113
4.3.1 Mycat 113
4.3.2 Percona 集群 124
4.3.3 HAProxy 131
4.3.4 Keepalived 138
4.4 MHA+Keepalived 集群搭建  140
4.4.1 配置 MySQL 半同步方式  142
4.4.2 安装配置 MHA 150
4.4.3 测试重构 153
4.4.4 扩展 Keepalived  155
4.5 用 ZooKeeper 搭建 Mycat 高可用集群 158
4.5.1 ZooKeeper 概述  158
4.5.2 ZooKeeper 的运用场景  161
4.5.3 ZooKeeper 在 Mycat 中的使用 163
4.6 Mycat 高可用配置 165
4.7 Mycat 注解技术  170
4.7.1 balance 注解实战  170
4.7.2 master/slave 注解实战  172
4.7.3 SQL 注解实战 173
4.7.4 schema 注解实战  176
4.7.5 dataNode 注解实战 176
4.7.6 catlet 注解实战  177
第 5 章 Mycat 企业运维 179
5.1 Mycat 性能监控——Mycat-web 详解 179
5.1.1 Mycat-web 简介 179
5.1.2 Mycat-web 的配置和使用 180
5.1.3 Mycat 性能监控指标 181
5.2 Mycat 性能优化 183
5.3 MySQL 优化技术  186
5.3.1 数据库建表设计规范 186
5.3.2 SQL 语句与索引 195
5.3.3 配置文件 206
5.3.4 InnoDB 选择文件系统  212
5.3.5 系统架构  213
第 6 章 Mycat 架构剖析 215
6.1 Mycat 总体架构介绍  215
6.2 Mycat 网络 I/O 架构与实现  218
6.2.1 Mycat I/O 架构概述 218
6.2.2 前端通信框架  221
6.3 Mycat 线程架构与实现  224
6.3.1 多线程基础 224
6.3.2 Mycat 线程架构  226
6.4 Mycat 内存管理及缓存架构与实现  228
6.4.1 Mycat 内存管理  229
6.4.2 Mycat 缓存架构与实现  231
6.5 Mycat 连接池架构与实现 232
6.5.1 Mycat 连接池 232
6.5.2 Mycat 连接池架构及代码实现 234
6.6 Mycat 主从切换架构与实现  235
6.6.1 Mycat 主从切换概述 236
6.6.2 Mycat 主从切换的实现  238
第 7 章 Mycat 核心技术分析  241
7.1 Mycat 分布式事务的实现  241
7.1.1 XA 规范 241
7.1.2 二阶段提交  242
7.1.3 三阶段提交  243
7.1.4 Mycat 中分布式事务的实现 244
7.2 Mycat SQL 路由的实现 249
7.2.1 路由的作用  249
7.2.2 SQL 解析器 250
7.2.3 路由计算  252
7.3 Mycat 跨库 Join 的实现 260
7.3.1 全局表  261
7.3.2 ER 分片  262
7.3.3 catlet 263
7.3.4 ShareJoin  264
7.4 Mycat 数据汇聚和排序的实现 270
7.4.1 数据排序  270
7.4.2 数据汇聚  273
第 8 章 Mycat多数据库支持原理与实现  275
8.1 MySQL 协议在 Mycat 中的实现 275
8.1.1 MySQL 协议概述  275
8.1.2 Mycat 的 MySQL 协议实现 283
8.2 PostgreSQL 协议在 Mycat 中的实现 287
8.2.1 PostgreSQL 介绍  287
8.2.2 PostgreSQL 协议  288
8.2.3 PostgreSQL 实现  293
8.3 Mycat 对 JDBC 支持的实现  298
8.3.1 Oracle 配置  299
8.3.2 SQL Server 配置  300
8.3.3 MongoDB 配置 301
8.3.4 源码分析 306
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式数据库架构及企业实践——基于Mycat中间件
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>移动平台深度神经网络实战：原理、架构与优化
序一
序二
前言
第一篇　深度学习基础
第1章　向未来问好  2
1.1　机器学习即正义  2
1.1.1　照本宣科  3
1.1.2　关键概念概述  4
1.1.3　数学之美  5
1.2　机器学习的场景和任务  6
1.3　机器学习算法  8
1.3.1　分类算法  8
1.3.2　回归算法  8
1.3.3　聚类算法  8
1.3.4　关联分析算法  9
1.3.5　集成算法  9
1.3.6　强化算法  10
1.4　如何掌握机器学习  10
1.4.1　学习曲线  10
1.4.2　技术栈  11
1.5　深度学习  12
1.5.1　深度学习的贡献  12
1.5.2　深度学习框架简介  13
1.5.3　安装使用深度学习框架  16
1.5.4　深度学习进展  22
1.6　走进移动世界的深度学习  25
1.6.1　移动平台机器学习概述  25
1.6.2　难度和挑战  26
1.7　本书框架  26
1.8　本章小结  27
第2章　机器学习基础  28
2.1　机器学习的主要任务  28
2.2　贝叶斯模型  29
2.3　Logistic回归  33
2.3.1　线性回归  33
2.3.2　几率与Logit  35
2.3.3　Logistic回归  38
2.3.4　背景溯源  39
2.3.5　实现Logistic回归  42
2.4　本章小结  44
第3章　人工神经网络  45
3.1　人工神经网络简介  45
3.2　基本结构与前向传播  46
3.2.1　神经元  46
3.2.2　连接与网络  47
3.2.3　神经网络向量化  48
3.2.4　前向传播  50
3.3　反向传播算法  50
3.4　实现前向神经网络  53
3.4.1　神经网络与前向传播实现  53
3.4.2　Softmax回归  60
3.5　稀疏自编码器  61
3.5.1　引子  61
3.5.2　自编码器简介  61
3.5.3　稀疏自编码算法  63
3.6　神经网络数据预处理  64
3.6.1　去均值  64
3.6.2　归一化  65
3.7　本章小结  65
第4章　深度网络与卷积神经网络  66
4.1　深度网络  66
4.1.1　自我学习  66
4.1.2　特征学习  67
4.1.3　深度神经网络  68
4.1.4　逐层贪婪训练方法  69
4.2　卷积神经网络  70
4.2.1　全连接与部分连接网络  70
4.2.2　卷积  70
4.2.3　池化  72
4.2.4　卷积神经网络  73
4.3　卷积神经网络实现  73
4.3.1　Layer实现  74
4.3.2　Net实现  79
4.3.3　InnerProduct实现  92
4.3.4　Convolution实现  95
4.3.5　Pooling实现  101
4.3.6　定义注册头文件  109
4.4　本章小结  110
第二篇　移动平台深度学习基础
第5章　移动平台深度学习框架设计与实现  112
5.1　移动平台深度学习系统开发简介  112
5.2　ARM Linux基础开发环境  113
5.2.1　通用ARM工具链安装  114
5.2.2　Android NDK安装  114
5.2.3　树莓派工具链安装  115
5.3　TensorFlow Lite介绍  115
5.3.1　TensorFlow Lite特性  115
5.3.2　TensorFlow Lite架构  116
5.3.3　TensorFlow Lite代码结构  117
5.4　移动平台性能优化基础  118
5.4.1　ARM v8体系结构  119
5.4.2　ARM v8数据类型与寄存器  120
5.4.3　Neon指令集介绍  122
5.4.4　ARM v8内存模型  124
5.4.5　Neon指令集加速实例  127
5.5　本章小结  140
第6章　移动平台轻量级网络实战  141
6.1　适用于移动平台的轻量级网络  141
6.2　SqueezeNet  142
6.2.1　微观结构  142
6.2.2　宏观结构  142
6.2.3　核心思路  143
6.2.4　实战：用PyTorch实现SqueezeNet  144
6.3　MobileNet  153
6.4　ShuffleNet  154
6.5　MobileNet V2  155
6.5.1　MobileNet的缺陷  155
6.5.2　MobileNet V2的改进  155
6.5.3　网络结构  156
6.5.4　实战：用PyTorch实现MobileNet V2  157
6.6　本章小结  161
第三篇　深入理解深度学习
第7章　高性能数据预处理实战  164
7.1　数据预处理任务  164
7.1.1　数据清理  165
7.1.2　数据集成  165
7.1.3　数据归约  165
7.1.4　数据变换  166
7.2　数据标准化  166
7.3　PCA  167
7.3.1　PCA的现实问题  167
7.3.2　PCA的计算方法  167
7.3.3　PCA的数学理论基础  169
7.4　在Hurricane之上实现PCA  170
7.4.1　Hurricane实时处理系统  171
7.4.2　实现Hurricane Topology  172
7.4.3　实现PCA  178
7.5　本章小结  192
第8章　基于深度神经网络的物体检测与识别  193
8.1　模式识别与物体识别  193
8.1.1　模式识别  193
8.1.2　模式识别系统  194
8.1.3　传统模式识别方法  194
8.1.4　深度学习模式识别方法  197
8.2　图像分类  197
8.2.1　LeNet  197
8.2.2　AlexNet  200
8.2.3　数据抓取整理  203
8.2.4　数据预处理  204
8.2.5　数据训练  206
8.3　目标识别与物体检测  207
8.3.1　目标识别简介  207
8.3.2　R-CNN  208
8.3.3　SPP-Net  209
8.3.4　Fast R-CNN  211
8.3.5　Faster R-CNN  211
8.3.6　RetinaNet  213
8.4　检测识别实战  213
8.4.1　Faster R-CNN  214
8.4.2　RetinaNet  230
8.5　移动平台检测识别实战  237
8.5.1　移动平台系统开发思路  237
8.5.2　基于RetinaNet的检测定位实现  237
8.5.3　基于AlexNet的识别分类实现  244
8.5.4　接口设计封装  247
8.6　本章小结  258
第四篇　深入理解移动平台深度学习
第9章　深入移动平台性能优化  260
9.1　模型压缩  260
9.2　权重稀疏化  262
9.2.1　Structured Sparsity Learning  262
9.2.2　Dynamic Network Surgery  262
9.2.3　Dynamic Network Surgery实现  264
9.3　模型加速  275
9.3.1　半精度与权重量化  275
9.3.2　深度压缩  276
9.3.3　二值化网络  278
9.3.4　三值化网络  280
9.3.5　DoReFa-Net  282
9.3.6　编程实战  283
9.4　嵌入式优化  287
9.4.1　算法局限与改进  287
9.4.2　理论改进  287
9.4.3　编程实战  288
9.5　嵌入式优化代码实现  290
9.5.1　量化分析实现  290
9.5.2　层实现  302
9.5.3　量化矩阵计算  309
9.6　本章小结  313
第10章　数据采集与模型训练实战  314
10.1　收集海量数据  314
10.1.1　搜索引擎工作原理  315
10.1.2　HTTP会话  316
10.1.3　解决JavaScript渲染问题  316
10.2　图片数据爬虫实现  317
10.2.1　获取任务  318
10.2.2　解析图片  320
10.2.3　图片存储  326
10.2.4　图片去重  327
10.2.5　完成Topology  328
10.3　训练与测试  330
10.3.1　模型定义  330
10.3.2　训练  334
10.3.3　测试  342
10.3.4　封装  344
10.4　本章小结  345
第11章　移动和嵌入式平台引擎与工具实战  346
11.1　TensorFlow Lite构建  346
11.2　集成TensorFlow Lite  357
11.3　核心实现分析  358
11.3.1　解释器代码分析  358
11.3.2　图代码分析  373
11.3.3　操作符注册  381
11.3.4　操作符扩展实现  384
11.3.5　计算与优化模块  399
11.4　模型处理工具  407
11.5　本章小结  425
第12章　移动平台框架与接口实战  426
12.1　Core ML  426
12.1.1　准备数据和生成模型  427
12.1.2　App实战：引入Core ML实现  430
12.2　Android Neural Networks API  437
12.2.1　等等，Google还有一个ML Kit  437
12.2.2　NNAPI编程模型  437
12.2.3　创建网络与计算  439
12.2.4　JNI封装与调用  451
12.2.5　App实战：集成NNAPI  454
12.3　实战：实现Android图像分类器App  459
12.3.1　JNI封装  459
12.3.2　Java调用  474
12.4　未来之路  479
12.5　本章小结  480
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>移动平台深度神经网络实战：原理、架构与优化
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>处理器架构
1  计算机系统概论  1.1  计算机的分类、发展与应用    1.1.1  计算机的分类    1.1.2  计算机的发展概况    1.1.3  计算机的应用  1.2  计算机的基本组成    1.2.1  计算机硬件    1.2.2  计算机软件    1.2.3  软件与硬件的逻辑等价性  1.3  计算机系统的概念    1.3.1  计算机系统的层次结构    1.3.2  计算机系统的3个术语    1.3.3  计算机体系结构的分类2  指令系统  2.1  指令系统概述    2.1.1  指令系统的发展    2.1.2  指令系统的性能要求  2.2  指令格式    2.2.1  操作码    2.2.2  地址码    2.2.3  指令字长度    2.2.4  指令助记符  2.3  指令分类    2.3.1  数据传送指令    2.3.2  算术运算指令    2.3.3  逻辑运算指令    2.3.4  程序控制指令    2.3.5  输入输出指令    2.3.6  字符串处理指令    2.3.7  系统控制指令  2.4  寻址方式    2.4.1  指令寻址方式    2.4.2  操作数寻址方式    2.4.3  堆栈寻址方式  2.5  指令系统实例    2.5.1  8086/8088指令系统    2.5.2  Pentium指令系统    2.5.3  Pentium 4指令系统    2.5.4  Core 2指令系统3  CPU组成  3.1  CPU的功能和组成    3.1.1  CPU的基本功能    3.1.2  CPU的基本组成    3.1.3  CPU中的主要寄存器    3.1.4  操作控制器和时序发生器  3.2  CPU的工作过程    3.2.1  指令的执行过程    3.2.2  指令周期    3.2.3  时序发生器    3.2.4  控制方式  3.3  操作控制器    3.3.1  组合逻辑控制器    3.3.2  微程序控制器    3.3.3  组合逻辑控制器与微程序控制器的比较4  CPU新技术  4.1  并行处理技术概述  4.2  流水线技术    4.2.1  流水线技术    4.2.2  流水线的分类    4.2.3  流水计算机的组成    4.2.4  流水计算机的时空图    4.2.5  指令的相关性  4.3  SIMD技术    4.3.1  MMX    4.3.2  SSE    4.3.3  SSE2    4.3.4  SSE3  4.4  RISC技术    4.4.1  CISC的产生和发展    4.4.2  RISC的产生    4.4.3  RISC的特点    4.4.4  RISC与CISC的主要特征对比  4.5  超线程/多核技术    4.5.1  超线程    4.5.2  多核技术  4.6  动态执行技术    4.6.1  指令调度    4.6.2  乱序执行技术    4.6.3  分支预测    4.6.4  多重指令启动  4.7  低功耗管理技术    4.7.1  制程提升    4.7.2  降低电压    4.7.3  减少晶体管数量    4.7.4  降低频率5  CPU实例  5.1  8086/8088    5.1.1  8086/8088的内部结构    5.1.2  8086/8088的寄存器结构    5.1.3  存储器寻址机制    5.1.4  8086/8088总线周期    5.1.5  8086/8088 CPU的特性  5.2  Pentium    5.2.1  Pentium的体系结构    5.2.2  Pentium的新技术特点  5.3  Pentium 4    5.3.1  Pentium 4的体系结构    5.3.2  Pentium 4的技术特点  5.4  Core 2    5.4.1  Core 2的体系结构    5.4.2  Core 2的技术特点
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>处理器架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云应用中的服务质量
关于作者
译者序
1 概述
1.1 入门
1.2 目标读者
1.3 本书组织结构
I 配置
2.应用程序服务质量
2.1 简单应用程序模型
2.2 服务边界
2.3 质量和性能的关键指标
2.4 关键应用特征
2.4.1 服务急迫性
2.4.2 应用程序交互性
2.4.3 网络传输缺陷的耐受性
2.5 应用程序服务质量指标
2.5.1 服务可用性
2.5.2 服务延迟
2.5.3 服务可靠性
2.5.4 服务可访问性
2.5.5 服务可维持性
2.5.6 服务吞吐量
2.5.7 服务时间戳精度
2.5.8 特定应用程序的服务质量度量
2.6 技术服务与支持服务
2.6.1 技术服务质量
2.6.2 支持服务质量
2.7 安全事项
3 云模型
3.1 云计算中的角色
3.2 云服务模型
3.3 云的基本特征
3.3.1 按需自助服务
3.3.2 广泛的网络访问
3.3.3 资源池
3.3.4 快速弹性
3.3.5 度量服务
3.4 简化云架构
3.4.1 应用软件
3.4.2 虚拟机服务器
3.4.3 虚拟机服务器控制器
3.4.4 云操作支持系统
3.4.5 云技术组件“即服务”
3.5 弹性度量
3.5.1 密度
3.5.2 配置间隔
3.5.3 释放间隔
3.5.4 向内和向外扩展
3.5.5 向上和向下扩展
3.5.6 敏捷性
3.5.7 转换速率和线性度
3.5.8 弹性加速
3.6 空间和区域
3.7 云意识
4 虚拟化架构缺陷
4.1 服务延迟、虚拟化和云
4.1.1 虚拟化和云导致的延迟变化
4.1.2 虚拟化开销
4.1.3 增加架构性能的可变性
4.2 虚拟机故障
4.3 无法交付的虚拟机配置容量
4.4 交付退化的虚拟机容量
4.5 尾部延迟
4.6 时钟事件抖动
4.7 时钟漂移
4.8 失败或缓慢的虚拟机实例分配和启动
4.9 虚拟化架构缺陷展望
II 分析
5 应用程序冗余和云计算
5.1 故障，可用性和简单建构
5.2 通过虚拟化改进软件修复时间
5.3 通过虚拟化改进架构修复时间
5.3.1 理解硬件修复
5.3.2 虚拟机修复即服务
5.3.3 讨论
5.4 冗余和可恢复性
5.4.1 通过虚拟化改进恢复时间
5.5 顺序冗余和并发冗余
5.5.1 混合并发策略
5.6 虚拟化缺陷对应用服务的影响
5.6.1 简单架构的服务影响
5.6.2 顺序冗余架构的服务影响
5.6.3 并发冗余架构的服务影响
5.6.4 混合并发架构的服务影响
5.7 数据冗余
5.7.1 数据存储策略
5.7.2 数据一致性策略
5.7.3 数据架构注意事项
5.8 讨论
5.8.1 服务质量的影响
5.8.2 并发控制
5.8.3 资源使用
5.8.4 简易性
5.8.5 其他注意事项
6 负载分配与均衡
6.1 负载分配机制
6.2 负载分配策略
6.3 代理负载均衡器
6.4 非代理负载分配
6.5 负载分配的层次结构
6.6 基于云的负载均衡所面临的挑战
6.7 负载均衡在支持冗余方面的作用
6.8 负载均衡与可用区域
6.9 工作负载服务度量
6.10 操作注意事项
6.10.1 负载均衡与弹性
6.10.2 负载均衡与过载
6.10.3 负载均衡与发布管理
6.11 负载均衡与应用程序服务质量
6.11.1 服务可用性
6.11.2 服务延迟
6.11.3 服务可靠性
6.11.4 服务可访问性
6.11.5 服务可维持性
6.11.6 服务吞吐量
6.11.7 服务时间戳精度
7 故障容器
7.1 故障容器
7.1.1 故障级联
7.1.2 故障容器与恢复
7.1.3 故障容器与虚拟化
7.2 故障点
7.2.1 单点故障
7.2.2 单点故障与虚拟化
7.2.3 关联性和反关联性考虑
7.2.4 在云计算中确保无SPOF
7.2.5 无SPOF和应用程序数据
7.3 极端共存解决方案
7.3.1 极端共存解决方案的风险
7.4 多租户与解决方案容器
8 容量管理
8.1 工作负载变化
8.2 传统容量管理
8.3 传统过载控制
8.4 容量管理与虚拟化
8.5 云容量管理
8.6 弹性存储注意事项
8.7 弹性和过载
8.8 操作注意事项
8.9 负载拉锯
8.10 一般弹性风险
8.11 弹性故障场景
8.11.1 弹性增长故障场景
8.11.1 弹性逆增长故障场景
9 发布管理
9.1 相关术语
9.2 传统的软件升级策略
9.2.1 软件升级需求
9.2.2 维护窗口
9.2.3 应用升级的客户端注意事项
9.2.4 传统的离线软件升级
9.2.5 传统的在线软件升级
9.2.6 讨论
9.3 支持云的软件升级策略
9.3.1 I型云支持升级策略：街区聚会
9.3.2 II型云支持升级策略：每车一司机
9.3.3 讨论
9.4 数据管理
9.5 软件升级中的服务编排角色
9.5.1 解决方案级软件升级
9.6 结论
10 端到端考虑因素
10.1 端到端服务环境
10.2 三层端到端服务模型
10.2.1 通过三层模型估算服务缺陷
10.2.2 端到端服务可用性
10.2.3 端到端服务延迟
10.2.4 端到端服务可靠性
10.2.5 端到端服务可访问性
10.2.6 端到端服务可维持性
10.2.7 端到端服务吞吐量
10.2.8 端到端服务时间戳精度
10.2.9 现实检查
10.3 分布式和集中式的云数据中心
10.3.1 集中式云数据中心
10.3.2 分布式云数据中心
10.3.3 服务可用性考虑
10.3.4 服务延迟考虑
10.3.5 服务可靠性考虑
10.3.6 服务可访问性考虑
10.3.7 服务可维持性考虑
10.3.8 资源分配考虑
10.4 多层解决方案架构
10.5 灾难恢复与地理冗余
10.5.1 灾难恢复目标
10.5.2 地理冗余架构
10.5.3 服务质量考虑
10.5.4 恢复点考虑
10.5.5 地理冗余和可用区域减轻灾难的影响
III 建议
11 服务质量问责
11.1 传统的问责
11.2 云服务交付路径
11.3 云问责
11.4 问责案例研究
11.4.1 问责和技术组件
11.4.2 问责和弹性
11.5 服务质量差距模型
11.5.1 应用程序面向资源服务差距分析
11.5.2 应用程序面向用户服务差距分析
11.6 服务水平协议
12 服务可用性度量
12.1 服务度量概述
12.2 传统服务可用性度量
12.3 服务可用性度量演化
12.3.1 应用演化分析
12.3.2 技术组件
12.3.3 存储即服务的使用
12.4 硬件可靠性度量演化
12.4.1 虚拟机故障生命周期
12.5 弹性服务可用性度量演化
12.6 发布管理服务可用性度量演化
12.7 服务度量展望
13 应用程序服务质量需求
13.1 服务可用性需求
13.2 服务延迟需求
13.3 服务可靠性需求
13.4 服务可访问性需求
13.5 服务可维持性需求
13.6 服务吞吐量需求
13.7 时间戳精度需求
13.8 弹性需求
13.9 发布管理需求
13.10 灾难恢复需求
14 虚拟化架构度量与管理
14.1 架构服务质量度量的业务环境
14.2 云消费者度量选项
14.3 缺陷度量策略
14.3.1 虚拟机故障度量
14.3.2 无法交付的虚拟机配置容量度量
14.3.3 交付退化的虚拟机容量度量
14.3.4 尾部延迟度量
14.3.5 时钟事件抖动度量
14.3.6 时钟漂移度量
14.3.7失败或缓慢的虚拟机实例分配和启动度量
14.3.8 度量总结
14.4 管理虚拟化架构缺陷
14.4.1 最小化应用程序对架构缺陷的敏感度
14.4.2 虚拟机级拥塞检测与控制
14.4.3 分配更多虚拟资源容量
14.4.4 终止性能欠佳的虚拟机实例
14.4.5 接受性能退化
14.4.6 积极主动的供应商管理
14.4.7 重新设定最终用户服务质量期望
14.4.8 SLA注意事项
14.4.9 更换云服务提供商
15 基于云的应用程序分析
15.1可靠性框图和参照分析
15.2 IaaS缺陷影响分析
15.3 PaaS故障影响分析
15.4 工作负载分配分析
15.4.1 服务质量分析
15.4.2 过载控制分析
15.5 反相关性分析
15.6 弹性分析
15.6.1 服务容量增长场景
15.6.2 服务容量增长操作分析
15.6.3 服务容量逆增长操作分析
15.6.4 存储容量增长场景
15.6.5 在线存储容量增长操作分析
15.6.6 在线存储容量逆增长操作分析
15.7 发布管理影响效应分析
15.7.1 服务可用性影响
15.7.2 服务可靠性影响
15.7.3 服务可访问性影响
15.7.4 服务可维持性影响
15.7.5 服务吞吐量影响
15.8 恢复点目标分析
15.9 恢复时间目标分析
16 测试注意事项
16.1 测试环境
16.2 测试策略
16.2.1 云测试平台
16.2.2 用于测试的容量
16.2.3 统计置信度
16.2.4 服务中断时间
16.3 模拟架构缺陷
16.4 测试计划
16.4.1服务可靠性和延迟测试
16.4.2 架构缺陷测试
16.4.3 健壮性测试
16.4.4 持久性/稳定性测试
16.4.5 应用程序弹性测试
16.4.6 升级测试
16.4.7 灾难恢复测试
16.4.8 极限共存测试
16.4.9 PaaS技术组件测试
16.4.10 自动回归则测试
16.4.11 构造发布测试
17 关键点连接与总结
17.1 应用程序服务质量所面临的挑战
17.2 冗余和健壮性
17.3 可伸缩性设计
17.4 可扩展性设计
17.5 故障设计
17.6 规划注意事项
17.7 传统应用的演化
17.7.1阶段0：传统应用
17.7.2 阶段I：虚拟化架构上的高服务质量
17.7.3 阶段II：手动应用弹性
17.7.4 阶段III：自动发布管理
17.7.5 阶段IV：自动应用弹性
17.7.6 阶段V：虚拟机迁移
17.8 结束语
参考文献
缩略语
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云应用中的服务质量
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>互联网创业核心技术：构建可伸缩的web应用
1 核心概念  1
什么是伸缩性  2
从单一服务器到全球用户的 Web 架构演化  4
单一服务器  5
使用更强的服务器：垂直伸缩  6
服务分离  10
内容分发网络：静态内容的伸缩性  12
分散访问流量：水平伸缩  13
服务全球用户的伸缩性架构  16
数据中心基础设施架构概览  18
前端  19
Web 应用层  20
Web 服务层  20
附加组件  21
数据持久层  21
数据中心基础架构  22
应用架构概览  23
前端  24
Web 服务  25
支撑技术  29
小结  30
2 软件设计原则  31
简单  31
隐藏复杂与构建抽象  32
避免过度设计  33
尝试测试驱动开发  34
从软件设计的简化范例中学习  35
低耦合  36
促进低耦合  37
避免不必要的耦合  39
低耦合范式  40
不要重复自己（DRY）  41
复制粘贴代码  42
基于约定编程  43
画架构图  46
用例图  49
类图  50
模块图  51
单一职责  52
改善单一职责  52
单一职责的例子  53
开闭原则  53
依赖注入  55
控制反转（IOC）  57
为伸缩而设计  59
增加副本  60
功能分割  62
数据分片  63
自愈设计  65
小结  67
3 构建前端层  69
状态管理  70
管理 HTTP 会话  73
管理文件  77
管理其他类型的状态  80
可伸缩的前端组件  83
DNS  84
负载均衡器  85
Web 服务器  92
缓存  93
自动伸缩  94
部署案例  96
AWS 场景  97
私有数据中心  98
小结  101
4  Web 服务  102
Web 服务设计  102
Web 服务作为一种备用表示层  103
API 优先方式  105
务实的方式  107
Web 服务类型  108
以功能为中心的服务  109
以资源为中心的服务  111
伸缩 REST Web 服务  115
保持服务无状态  115
缓存服务响应  121
功能分割  124
小结  127
5  数据存储层  129
MySQL 伸缩性  130
复制  130
数据分区（分片）  142
NoSQL 伸缩性  157
最终一致性  160
快速恢复增加可用性  164
Cassandra 拓扑结构  166
小结  170
6  缓存  171
缓存命中率  171
基于 HTTP 的缓存  173
HTTP 缓存头  174
HTTP 缓存技术类型  179
伸缩 HTTP 缓存  185
缓存应用对象  188
对象缓存的一般类型  189
伸缩对象缓存  194
缓存的经验法则  198
缓存整个调用栈  198
用户间缓存重用  199
从哪儿开始使用缓存？  201
缓存失效的困难  201
小结  203
7  异步处理  204
核心概念  204
同步处理的例子  205
异步处理的例子  208
购物类比  211
消息队列  213
消息生产者  214
消息代理  215
消息消费者  216
消息协议  220
消息基础设施  221
消息队列的好处  224
实现异步处理  225
更好的伸缩性  226
平衡流量峰值  227
失败隔离和自我修复  228
解耦  229
消息队列相关的挑战  230
消息无序  230
消息重新入队列  233
竞态条件可能性增大  233
复杂度风险  234
消息队列有关的反模式  235
将消息队列当作 TCP 套接字  235
将消息队列当作数据库  235
耦合消息生产者和消费者  235
缺少坏消息处理  236
消息平台快速比较与选择  237
亚马逊简单队列服务  237
RabbitMQ  240
ActiveMQ  242
最后的比较说明  243
事件驱动架构介绍  245
请求/响应交互  246
直接队列交互  247
事件驱动交互  247
小结  250
8  数据搜索  252
索引介绍  252
数据建模  260
NoSQL 数据建模  260
宽列数据存储的例子  264
搜索引擎  271
搜索引擎介绍  272
使用专用搜索引擎  274
小结  275
9  伸缩性的其他维度  277
自动化实现生产力可伸缩  278
测试  278
构建与部署  280
监控与报警  285
日志聚合  289
个人可伸缩  291
加班不是一种伸缩性方案  291
自我管理  293
伸缩敏捷团队  300
增加人手  300
流程与创新  301
团结的文化  302
小结  303
A  推荐阅读  304
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>互联网创业核心技术：构建可伸缩的web应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hadoop应用架构
版权声明
O'Reilly Media, Inc. 介绍
译者序
序
前言
第一部分　考虑 Hadoop 应用的架构设计
第 1 章　Hadoop 数据建模
第 2 章　Hadoop 数据移动
第 3 章　Hadoop 数据处理
第 4 章　Hadoop 数据处理通用范式
第 5 章　Hadoop 图处理
第 6 章　协调调度
第 7 章　Hadoop 近实时处理
第二部分　案例研究
第 8 章　点击流分析
第 9 章　欺诈检测
第 10 章　数据仓库
附录 A　Impala 中的关联
作者简介
封面介绍
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hadoop应用架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据技术体系详解：原理、架构与实践
前　言
第一部分　概述篇
第1章　企业级大数据技术体系概述 2
1.1　大数据系统产生背景及应用场景 2
1.1.1　产生背景 2
1.1.2　常见大数据应用场景 3
1.2　企业级大数据技术框架 5
1.2.1　数据收集层 6
1.2.2　数据存储层 7
1.2.3　资源管理与服务协调层 7
1.2.4　计算引擎层 8
1.2.5　数据分析层 9
1.2.6　数据可视化层 9
1.3　企业级大数据技术实现方案 9
1.3.1　Google大数据技术栈 10
1.3.2　Hadoop与Spark开源大数据技术栈 12
1.4　大数据架构：Lambda Architecture 15
1.5　Hadoop与Spark版本选择及安装部署 16
1.5.1　Hadoop与Spark版本选择 16
1.5.2　Hadoop与Spark安装部署 17
1.6　小结 18
1.7　本章问题 18
第二部分　数据收集篇
第2章　关系型数据的收集 20
2.1　Sqoop概述 20
2.1.1　设计动机 20
2.1.2　Sqoop基本思想及特点 21
2.2　Sqoop基本架构 21
2.2.1　Sqoop1基本架构 22
2.2.2　Sqoop2基本架构 23
2.2.3　Sqoop1与Sqoop2对比 24
2.3　Sqoop使用方式 25
2.3.1　Sqoop1使用方式 25
2.3.2　Sqoop2使用方式 28
2.4　数据增量收集CDC 31
2.4.1　CDC动机与应用场景 31
2.4.2　CDC开源实现Canal 32
2.4.3　多机房数据同步系统Otter 33
2.5　小结 35
2.6　本章问题 35
第3章　非关系型数据的收集 36
3.1　概述 36
3.1.1　Flume设计动机 36
3.1.2　Flume基本思想及特点 37
3.2　Flume NG基本架构 38
3.2.1　Flume NG基本架构 38
3.2.2　Flume NG高级组件 41
3.3　Flume NG数据流拓扑构建方法 42
3.3.1　如何构建数据流拓扑 42
3.3.2　数据流拓扑实例剖析 46
3.4　小结 50
3.5　本章问题 50
第4章　分布式消息队列Kafka 51
4.1　概述 51
4.1.1　Kafka设计动机 51
4.1.2　Kafka特点 53
4.2　Kafka设计架构 53
4.2.1　Kafka基本架构 54
4.2.2　Kafka各组件详解 54
4.2.3　Kafka关键技术点 58
4.3　Kafka程序设计 60
4.3.1　Producer程序设计 61
4.3.2　Consumer程序设计 63
4.3.3　开源Producer与Consumer实现 65
4.4　Kafka典型应用场景 65
4.5　小结 67
4.6　本章问题 67
第三部分　数据存储篇
第5章　数据序列化与文件存储格式 70
5.1　数据序列化的意义 70
5.2　数据序列化方案 72
5.2.1　序列化框架Thrift 72
5.2.2　序列化框架Protobuf 74
5.2.3　序列化框架Avro 76
5.2.4　序列化框架对比 78
5.3　文件存储格式剖析 79
5.3.1　行存储与列存储 79
5.3.2　行式存储格式 80
5.3.3　列式存储格式ORC、Parquet与CarbonData 82
5.4　小结 88
5.5　本章问题 89
第6章　分布式文件系统 90
6.1　背景 90
6.2　文件级别和块级别的分布式文件系统 91
6.2.1　文件级别的分布式系统 91
6.2.2　块级别的分布式系统 92
6.3　HDFS基本架构 93
6.4　HDFS关键技术 94
6.4.1　容错性设计 95
6.4.2　副本放置策略 95
6.4.3　异构存储介质 96
6.4.4　集中式缓存管理 97
6.5　HDFS访问方式 98
6.5.1　HDFS shell 98
6.5.2　HDFS API 100
6.5.3　数据收集组件 101
6.5.4　计算引擎 102
6.6　小结 102
6.7　本章问题 103
第7章　分布式结构化存储系统 104
7.1　背景 104
7.2　HBase数据模型 105
7.2.1　逻辑数据模型 105
7.2.2　物理数据存储 107
7.3　HBase基本架构 108
7.3.1　HBase基本架构 108
7.3.2　HBase内部原理 110
7.4　HBase访问方式 114
7.4.1　HBase shell 114
7.4.2　HBase API 116
7.4.3　数据收集组件 118
7.4.4　计算引擎 119
7.4.5　Apache Phoenix 119
7.5　HBase应用案例 120
7.5.1　社交关系数据存储 120
7.5.2　时间序列数据库OpenTSDB 122
7.6　分布式列式存储系统Kudu 125
7.6.1　Kudu基本特点 125
7.6.2　Kudu数据模型与架构 126
7.6.3　HBase与Kudu对比 126
7.7　小结 127
7.8　本章问题 127
第四部分　分布式协调与资源管理篇
第8章　分布式协调服务ZooKeeper 130
8.1　分布式协调服务的存在意义 130
8.1.1　leader选举 130
8.1.2　负载均衡 131
8.2　ZooKeeper数据模型 132
8.3　ZooKeeper基本架构 133
8.4　ZooKeeper程序设计 134
8.4.1　ZooKeeper API 135
8.4.2　Apache Curator 139
8.5　ZooKeeper应用案例 142
8.5.1　leader选举 142
8.5.2　分布式队列 143
8.5.3　负载均衡 143
8.6　小结 144
8.7　本章问题 145
第9章　资源管理与调度系统YARN 146
9.1　YARN产生背景 146
9.1.1　MRv1局限性 146
9.1.2　YARN设计动机 147
9.2　YARN设计思想 148
9.3　YARN的基本架构与原理 149
9.3.1　YARN基本架构 149
9.3.2　YARN高可用 152
9.3.3　YARN工作流程 153
9.4　YARN资源调度器 155
9.4.1　层级队列管理机制 155
9.4.2　多租户资源调度器产生背景 156
9.4.3　Capacity/Fair Scheduler 157
9.4.4　基于节点标签的调度 160
9.4.5　资源抢占模型 163
9.5　YARN资源隔离 164
9.6　以YARN为核心的生态系统 165
9.7　资源管理系统Mesos 167
9.7.1　Mesos基本架构 167
9.7.2　Mesos资源分配策略 169
9.7.3　Mesos与YARN对比 170
9.8　资源管理系统架构演化 170
9.8.1　集中式架构 171
9.8.2　双层调度架构 171
9.8.3　共享状态架构 172
9.9　小结 173
9.10　本章问题 173
第五部分　大数据计算引擎篇
第10章　批处理引擎MapReduce 176
10.1　概述 176
10.1.1　MapReduce产生背景 176
10.1.2　MapReduce设计目标 177
10.2　MapReduce编程模型 178
10.2.1　编程思想 178
10.2.2　MapReduce编程组件 179
10.3　MapReduce程序设计 187
10.3.1　MapReduce程序设计基础 187
10.3.2　MapReduce程序设计进阶 194
10.3.3　Hadoop Streaming 198
10.4　MapReduce内部原理 204
10.4.1　MapReduce作业生命周期 204
10.4.2　MapTask与ReduceTask 206
10.4.3　MapReduce关键技术 209
10.5　MapReduce应用实例 211
10.6　小结 213
10.7　本章问题 213
第11章　DAG计算引擎Spark 215
11.1　概述 215
11.1.1　Spark产生背景 215
11.1.2　Spark主要特点 217
11.2　Spark编程模型 218
11.2.1　Spark核心概念 218
11.2.2　Spark程序基本框架 220
11.2.3　Spark编程接口 221
11.3　Spark运行模式 227
11.3.1　Standalone模式 229
11.3.2　YARN模式 230
11.3.3　Spark Shell 232
11.4　Spark程序设计实例 232
11.4.1　构建倒排索引 232
11.4.2　SQL GroupBy实现 234
11.4.3　应用程序提交 235
11.5　Spark内部原理 236
11.5.1　Spark作业生命周期 237
11.5.2　Spark Shuffle 241
11.6　DataFrame、Dataset与SQL 247
11.6.1　DataFrame/Dataset与SQL的关系 248
11.6.2　DataFrame/Dataset程序设计 249
11.6.3　DataFrame/Dataset程序实例 254
11.7　Spark生态系统 257
11.8　小结 257
11.9　本章问题 258
第12章　交互式计算引擎 261
12.1　概述 261
12.1.1　产生背景 261
12.1.2　交互式查询引擎分类 262
12.1.3　常见的开源实现 263
12.2　ROLAP 263
12.2.1　Impala 263
12.2.2　Presto 267
12.2.3　Impala与Presto对比 271
12.3　MOLAP 271
12.3.1　Druid简介 271
12.3.2　Kylin简介 272
12.3.3　Druid与Kylin对比 274
12.4　小结 274
12.5　本章问题 274
第13章　流式实时计算引擎 276
13.1　概述 276
13.1.1　产生背景 276
13.1.2　常见的开源实现 278
13.2　Storm基础与实战 278
13.2.1　Storm概念与架构 279
13.2.2　Storm程序设计实例 282
13.2.3　Storm内部原理 285
13.3　Spark Streaming基础与实战 290
13.3.1　概念与架构 290
13.3.2　程序设计基础 291
13.3.3　编程实例详解 298
13.3.4　容错性讨论 300
13.4　流式计算引擎对比 303
13.5　小结 304
13.6　本章问题 304
第六部分　数据分析篇
第14章　数据分析语言HQL与SQL 308
14.1　概述 308
14.1.1　背景 308
14.1.2　SQL On Hadoop 309
14.2　Hive架构 309
14.2.1　Hive基本架构 310
14.2.2　Hive查询引擎 311
14.3　Spark SQL架构 312
14.3.1　Spark SQL基本架构 312
14.3.2　Spark SQL与Hive对比 313
14.4　HQL 314
14.4.1　HQL基本语法 314
14.4.2　HQL应用实例 320
14.5　小结 322
14.6　本章问题 322
第15章　大数据统一编程模型 325
15.1　产生背景 325
15.2　Apache Beam基本构成 327
15.2.1　Beam SDK 327
15.2.2　Beam Runner 328
15.3　Apache Beam编程模型 329
15.3.1　构建Pipeline 330
15.3.2　创建PCollection 331
15.3.3　使用Transform 334
15.3.4　side input与side output 340
15.4　Apache Beam流式计算模型 341
15.4.1　window简述 342
15.4.2　watermark、trigger与accumulation 344
15.5　Apache Beam编程实例 346
15.5.1　WordCount 346
15.5.2　移动游戏用户行为分析 348
15.6　小结 350
15.7　本章问题 350
第16章　大数据机器学习库 351
16.1　机器学习库简介 351
16.2　MLLib 机器学习库 354
16.2.1　Pipeline 355
16.2.2　特征工程 357
16.2.3　机器学习算法 360
16.3　小结 361
16.4　本章问题 361
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据技术体系详解：原理、架构与实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ASP.NET 3.5商用开发架构精解
目录 第1章 企业应用程序框架
1.1 提出问题
1.2 设计方案
1.2.1 第2章：数据访问层
1.2.2 第3章：业务逻辑层
1.2.3 第4章：用户界面层
1.2.4 第5章：异常处理
1.2.5 第6章：基于角色的安全体系
1.2.6 第7章：工作流引擎
1.2.7 第8章：通知
1.2.8 第9章：报表
1.2.9 第10章：查询生成器控件
1.2.10 第11章：仪表板
1.2.11 第12章：追踪审计
1.2.12 第13章：代码生成器
1.3 解决方案，
1.4 小结
第2章 数据访问层
2.1 提出问题
2.2 设计方案
2.2.1 ADO.NET连接
2.2 .2动作查询
2.2.3 行返回查询
2.2.4 标量查询
2.2.5 Sql Helper
2.2.6 在BLL与DAL之间传递数据
2.2.7 LINQtoSQL
2.2.8 创建Data Context
2.2.9 添加记录
2.2.10 更新记录
2.2.11 删除记录
2.2.12 选择记录
2.2.13 存储过程
2.3 解决方案
2.4 小结
第3章 业务逻辑层
3.1 提出问题
3.2 设计方案
3.2.1 ENTBaseBO
3.2.2 ENTBaseBOIist
3.2.3 ENTBaseEO
3.2.4 ENTBaseEOIist
3.3 解决方案
3.3.1 首个编辑对象类
3.3.2 首个编辑对象列表对象
3.4 小结
第4章 用户界面层
4.1 提出问题
4.2 设计方案
4.2.1 PaidTimeofr样式表
4.2.2 父母版页
4.2 .3表格编辑页面的母版页
4.2 .4编辑页面的母版页
4.3解决方案
4.3.1 Administration页面
4.3.2 用户列表页面
4.3.3用户编辑页面
4.4 小结
第5章 异常处理
5.1 提出问题
5.2 设计方案
5.2.1 应用程序级的异常处理
5.2.2 页面级的异常处理
5.2 .3方法级的异常处理
5.2.4 web.config
5.2.5 运行状况监视
5.2.6 Enterprise Application Blocks
5.3解决方案
5.4 小结
第6章 基于角色的安全体系
6.1 提出问题
6.2 设计方案
6.3解决方案
6.3.1 实体对象与Data Context
6.3.2 数据类
6.3.3 业务类
6.3.4 用户界面
6.4 小结
第7章 工作流引擎
7.1 提出问题
7.2 设计方案
7.2.1 工作流数据表设计
7.2.2 存储过程
7.2.3 实体对象与Data Context
7.2.4 业务类
7.2.5 用户界面
7.2.6 Transitions
7.3 解决方案
7.3.1 PT0表的设计
7.3.2 实体对象与Data Context对象
7.3.3 业务类
7.3.4 用户界面
7.4 小结
第8章 通知
8.1 提出问题
8.2 设计方案
8.2.1 Smtp Client类
8.2.2 设计数据库表
8.3 解决方案
8.3.1 定义通知服务所用到的数据表
8.3.2 于E.mail通知的业务对象
8.3.3 创建通知注册页面
8.4 小结
第9章 报表
9.1 提出问题
9.2 设计方案
9.2.1 直接连接到数据库来生成报表
9.2.2 报表查看器
9.2.3 基于三层结构的报表
9.3 解决方案
9.4 小结
第10章 查询生成器控件
10.1 提出问题
10.2 设计方案
10.2.1 ENTBase Query Data
10.2.2 ENTBase QueryBO
10.2.3 自定义查询生成器控件
10.3 解决方案
10.4 小结
第11章 仪表板
11.1 提出问题
11.2 设计方案
11.3 解决方案
11.4 小结
第12章 追踪审计
12.1 提出问题
12.2 设计方案
12.2.1 自定义追踪审计
12.2.2 创建用户界面
12.3 解决方案
12.4 小结
第13章 代码生成器
13.1 提出问题
13.2 设计方案
13.3 解决方案
13.4 小结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ASP.NET 3.5商用开发架构精解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据之路
第1章  总述1
第1篇  数据技术篇
第2章  日志采集 8
2.1  浏览器的页面日志采集 8
2.1.1  页面浏览日志采集流程 9
2.1.2  页面交互日志采集 14
2.1.3  页面日志的服务器端清洗和预处理 15
2.2  无线客户端的日志采集 16
2.2.1  页面事件 17
2.2.2  控件点击及其他事件 18
2.2.3  特殊场景 19
2.2.4  H5 & Native日志统一 20
2.2.5  设备标识 22
2.2.6  日志传输 23
2.3  日志采集的挑战 24
2.3.1  典型场景 24
2.3.2  大促保障 26
第3章  数据同步 29
3.1  数据同步基础 29
3.1.1  直连同步 30
3.1.2  数据文件同步 30
3.1.3  数据库日志解析同步 31
3.2  阿里数据仓库的同步方式 35
3.2.1  批量数据同步 35
3.2.2  实时数据同步 37
3.3  数据同步遇到的问题与解决方案 39
3.3.1  分库分表的处理 39
3.3.2  高效同步和批量同步 41
3.3.3  增量与全量同步的合并 42
3.3.4  同步性能的处理 43
3.3.5  数据漂移的处理 45
第4章  离线数据开发 48
4.1  数据开发平台 48
4.1.1  统一计算平台 49
4.1.2  统一开发平台 53
4.2  任务调度系统 58
4.2.1  背景 58
4.2.2  介绍 60
4.2.3  特点及应用 65
第5章  实时技术 68
5.1  简介 69
5.2  流式技术架构 71
5.2.1  数据采集 72
5.2.2  数据处理 74
5.2.3  数据存储 78
5.2.4  数据服务 80
5.3  流式数据模型 80
5.3.1  数据分层 80
5.3.2  多流关联 83
5.3.3  维表使用 84
5.4  大促挑战&保障 86
5.4.1  大促特征 86
5.4.2  大促保障 88
第6章  数据服务 91
6.1  服务架构演进 91
6.1.1  DWSOA 92
6.1.2  OpenAPI 93
6.1.3  SmartDQ 94
6.1.4  统一的数据服务层 96
6.2  技术架构 97
6.2.1  SmartDQ 97
6.2.2  iPush 100
6.2.3  Lego 101
6.2.4  uTiming 102
6.3  最佳实践 103
6.3.1  性能 103
6.3.2  稳定性 111
第7章  数据挖掘 116
7.1  数据挖掘概述 116
7.2  数据挖掘算法平台 117
7.3  数据挖掘中台体系 119
7.3.1  挖掘数据中台 120
7.3.2  挖掘算法中台 122
7.4  数据挖掘案例 123
7.4.1  用户画像 123
7.4.2  互联网反作弊 125
第2篇  数据模型篇
第8章  大数据领域建模综述 130
8.1  为什么需要数据建模 130
8.2  关系数据库系统和数据仓库 131
8.3  从OLTP和OLAP系统的区别看模型方法论的选择 132
8.4  典型的数据仓库建模方法论 132
8.4.1  ER模型 132
8.4.2  维度模型 133
8.4.3  Data Vault模型 134
8.4.4  Anchor模型 135
8.5  阿里巴巴数据模型实践综述 136
第9章  阿里巴巴数据整合及管理体系 138
9.1  概述 138
9.1.1  定位及价值 139
9.1.2  体系架构 139
9.2  规范定义 140
9.2.1  名词术语 141
9.2.2  指标体系 141
9.3  模型设计 148
9.3.1  指导理论 148
9.3.2  模型层次 148
9.3.3  基本原则 150
9.4  模型实施 152
9.4.1  业界常用的模型实施过程 152
9.4.2  OneData实施过程 154
第10章  维度设计 159
10.1  维度设计基础 159
10.1.1  维度的基本概念 159
10.1.2  维度的基本设计方法 160
10.1.3  维度的层次结构 162
10.1.4  规范化和反规范化 163
10.1.5  一致性维度和交叉探查 165
10.2  维度设计高级主题 166
10.2.1  维度整合 166
10.2.2  水平拆分 169
10.2.3  垂直拆分 170
10.2.4  历史归档 171
10.3  维度变化 172
10.3.1  缓慢变化维 172
10.3.2  快照维表 174
10.3.3  极限存储 175
10.3.4  微型维度 178
10.4  特殊维度 180
10.4.1  递归层次 180
10.4.2  行为维度 184
10.4.3  多值维度 185
10.4.4  多值属性 187
10.4.5  杂项维度 188
第11章  事实表设计 190
11.1  事实表基础 190
11.1.1  事实表特性 190
11.1.2  事实表设计原则 191
11.1.3  事实表设计方法 193
11.2  事务事实表 196
11.2.1  设计过程 196
11.2.2  单事务事实表 200
11.2.3  多事务事实表 202
11.2.4  两种事实表对比 206
11.2.5  父子事实的处理方式 208
11.2.6  事实的设计准则 209
11.3  周期快照事实表 210
11.3.1  特性 211
11.3.2  实例 212
11.3.3  注意事项 217
11.4  累积快照事实表 218
11.4.1  设计过程 218
11.4.2  特点 221
11.4.3  特殊处理 223
11.4.4  物理实现 225
11.5  三种事实表的比较 227
11.6  无事实的事实表 228
11.7  聚集型事实表 228
11.7.1  聚集的基本原则 229
11.7.2  聚集的基本步骤 229
11.7.3  阿里公共汇总层 230
11.7.4  聚集补充说明 234
第3篇  数据管理篇
第12章  元数据 236
12.1  元数据概述 236
12.1.1  元数据定义 236
12.1.2  元数据价值 237
12.1.3  统一元数据体系建设 238
12.2  元数据应用 239
12.2.1  Data Profile 239
12.2.2  元数据门户 241
12.2.3  应用链路分析 241
12.2.4  数据建模 242
12.2.5  驱动ETL开发 243
第13章  计算管理 245
13.1  系统优化 245
13.1.1  HBO 246
13.1.2  CBO 249
13.2  任务优化 256
13.2.1  Map倾斜 257
13.2.2  Join倾斜 261
13.2.3  Reduce倾斜 269
第14章  存储和成本管理 275
14.1  数据压缩 275
14.2  数据重分布 276
14.3  存储治理项优化 277
14.4  生命周期管理 278
14.4.1  生命周期管理策略 278
14.4.2  通用的生命周期管理矩阵 280
14.5  数据成本计量 283
14.6  数据使用计费 284
第15章  数据质量 285
15.1  数据质量保障原则 285
15.2  数据质量方法概述 287
15.2.1  消费场景知晓 289
15.2.2  数据加工过程卡点校验 292
15.2.3  风险点监控 295
15.2.4  质量衡量 299
第4篇  数据应用篇
第16章  数据应用 304
16.1  生意参谋 305
16.1.1  背景概述 305
16.1.2  功能架构与技术能力 307
16.1.3  商家应用实践 310
16.2  对内数据产品平台 313
16.2.1  定位 313
16.2.2  产品建设历程 314
16.2.3  整体架构介绍 317
附录A  本书插图索引 320
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据之路
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>构建高性能Web站点
第1章 绪论
1.1 等待的真相
1.2 瓶颈在哪里
1.3 增加带宽
1.4 减少网页中的HTTP请求
1.5 加快服务器脚本计算速度
1.6 使用动态内容缓存
1.7 使用数据缓存
1.8 将动态内容静态化
1.9 更换Web服务器软件
1.10 页面组件分离
1.11 合理部署服务器
1.12 使用负载均衡
1.13 优化数据库
1.14 考虑可扩展性
1.15 减少视觉等待
第2章 数据的网络传输
2.1 分层网络模型
2.2 带宽
2.3 响应时间
2.4 互联互通
第3章 服务器并发处理能力
3.1 吞吐率
3.2 CPU并发计算
3.3 系统调用
3.4 内存分配
3.5 持久连接
3.6 I/O模型
3.7 服务器并发策略
第4章 动态内容缓存
4.1 重复的开销
4.2 缓存与速度
4.3 页面缓存
4.4 局部无缓存
4.5 静态化内容
第5章 动态脚本加速
5.1 opcode缓存
5.2 解释器扩展模块
5.3 脚本跟踪与分析
第6章 浏览器缓存
6.1 别忘了浏览器
6.2 缓存协商
6.3 彻底消灭请求
第7章 Web服务器缓存
7.1 URL映射
7.2 缓存响应内容
7.3 缓存文件描述符
第8章 反向代理缓存
8.1 传统代理
8.2 何为反向
8.3 在反向代理上创建缓存
8.4 小心穿过代理
8.5 流量分配
第9章 Web组件分离
9.1 备受争议的分离
9.2 因材施教
9.3 拥有不同的域名
9.4 浏览器并发数
9.5 发挥各自的潜力
第10章 分布式缓存
10.1 数据库的前端缓存区
10.2 使用memcached
10.3 读操作缓存
10.4 写操作缓存
10.5 监控状态
10.6 缓存扩展
第11章 数据库性能优化
11.1 友好的状态报告
11.2 正确使用索引
11.3 锁定与等待
11.4 事务性表的性能
11.5 使用查询缓存
11.6 临时表
11.7 线程池
11.8 反范式化设计
11.9 放弃关系型数据库
第12章 Web负载均衡
12.1 一些思考
12.2 HTTP重定向
12.3 DNS负载均衡
12.4 反向代理负载均衡
12.5 IP负载均衡
12.6 直接路由
12.7 IP隧道
12.8 考虑可用性
第13章 共享文件系统
13.1 网络共享
13.2 NFS
13.3 局限性
第14章 内容分发和同步
14.1 复制
14.2 SSH
14.3 WebDAV
14.4 rsync
14.5 Hash tree
14.6 分发还是同步
14.7 反向代理
第15章 分布式文件系统
15.1 文件系统
15.2 存储节点和追踪器
15.3 MogileFS
第16章 数据库扩展
16.1 复制和分离
16.2 垂直分区
16.3 水平分区
第17章 分布式计算
17.1 异步计算
17.2 并行计算
第18章 性能监控
18.1 实时监控
18.2 监控代理
18.3 系统监控
18.4 服务监控
参考文献
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>构建高性能Web站点
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入Java2平台安全――体系架构、API设计和实现（第2版）
第一章 计算机和网络安全基础
第二章 JAVA语言的基本安全特点
第三章 JAVA 2安全体系结构
第四章 类的安全装载
第五章 安全策略的元素
第六章 执行安全策略
第七章 定制安全架构
第八章 建立信任
第九章 对象安全
第十章 密码学编程
第十一章  网络安全
第十二章 部署安全架构
第十三章 其它平台和未来发展方向
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入Java2平台安全――体系架构、API设计和实现（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高并发Oracle数据库系统的架构与设计
目　　录
推荐序一
推荐序二
前言
第一部分　内政篇
第1章　大道至简  2
1.1　初见高并发  2
1.1.1　从一次谈话说起  3
1.1.2　问题就在那里  4
1.1.3　你不是一个人在战斗  6
1.2　说句时髦话  8
1.2.1　谈谈去IOE  8
1.2.2　开源的作用域  9
1.3　在Oracle的世界里  10
1.3.1　数据库森林体系  10
1.3.2　大道至简  12
1.4　本章小结  13
第2章　高效B树索引  14
2.1　索引扫描识别  14
2.1.1　B树索引  15
2.1.2　全表扫描  16
2.1.3　ROWID扫描  17
2.1.4　索引唯一扫描  18
2.1.5　索引范围扫描  20
2.1.6　索引全扫描  21
2.1.7　索引快速全扫描  22
2.1.8　索引跳跃扫描  24
2.1.9　索引组合扫描  25
2.1.10　索引联立扫描  27
2.2　索引与排序  28
2.2.1　B树索引内部结构  28
2.2.2　输出排序  29
2.2.3　降序索引  34
2.2.4　聚合查询min()与max()  37
2.3　索引设计优化  40
2.3.1　索引选择度  40
2.3.2　数据分布的影响  41
2.3.3　索引聚簇因子  45
2.3.4　数据存储的影响  47
2.3.5　复合索引  50
2.3.6　索引被无视  54
2.4　索引分裂  58
2.4.1　分裂原理  59
2.4.2　实例分析  61
2.5　索引维护  70
2.5.1　为何重建索引  71
2.5.2　何时重建索引  73
2.5.3　如何重建索引  76
2.5.4　废旧索引清理  77
2.6　本章小结  78
第3章　高效表设计  79
3.1　数据生命周期管理  80
3.1.1　什么是数据生命周期管理  80
3.1.2　架构模型设计  81
3.1.3　数据分层存储  86
3.2　常用字段类型选择  87
3.2.1　VARCHAR2与CHAR  87
3.2.2　NUMBER与VARCHAR2  88
3.2.3　主键字段的选择  90
3.2.4　LOB字段  91
3.3　字段顺序  95
3.3.1　热字段靠前排  95
3.3.2　行宽需要控制  97
3.4　行链接与行迁移  99
3.4.1　行链接原理  99
3.4.2　行迁移原理  101
3.4.3　发现问题  101
3.4.4　解决问题  104
3.5　分区表的使用  105
3.5.1　何时使用分区表  105
3.5.2　分区表设计思路  106
3.5.3　分区表特性  106
3.6　适当的冗余  110
3.6.1　反范式建模  110
3.6.2　物化视图  113
3.6.3　结果集缓存  117
3.6.4　直接路径插入  120
3.7　碎片分析与整理  122
3.7.1　碎片的产生  123
3.7.2　DBMS_SPACE包  125
3.7.3　碎片的整理  130
3.8　本章小结  138
第4章　查询优化器  139
4.1　优化器概述  140
4.1.1　优化器简介  140
4.1.2　参数配置  143
4.2　像优化器一样思考  147
4.2.1　成本计算机制  147
4.2.2　成本计算公式推导  150
4.3　统计信息管理  155
4.3.1　统计信息分类  156
4.3.2　制定收集策略  158
4.3.3　管理收集方式  164
4.3.4　制定备份策略  168
4.3.5　收集直方图  174
4.4　执行计划管理  175
4.4.1　获取执行计划  175
4.4.2　固化执行计划  176
4.5　性能影响分析  183
4.6　数据库重放  188
4.6.1　普通数据库重放特性  188
4.6.2　强化数据库重放特性  193
4.7　本章小结  195
第5章　常见高并发案例  196
5.1　锁相关问题  196
5.1.1　Lock、Latch、Pin、Mutex  196
5.1.2　游标争用问题解决  198
5.1.3　索引争用问题解决  203
5.1.4　LOB争用问题解决  207
5.1.5　全表锁问题解决  213
5.2　REDO相关问题  214
5.2.1　REDO块的大小  214
5.2.2　DIO与AIO  218
5.2.3　进程优先级  219
5.2.4　log file sync分析  221
5.3　本章小结  222
第二部分　纵横篇
第6章　TimesTen内存数据库  224
6.1　TimesTen概述  225
6.1.1　TimesTen历史与定位  225
6.1.2　TimesTen应用场景  226
6.1.3　TimesTen技术架构  228
6.2　开始使用  233
6.2.1　TimesTen安装  233
6.2.2　参数配置  237
6.2.3　创建独立实例  239
6.2.4　创建缓存实例  241
6.3　缓存集合管理  242
6.3.1　只读缓存集合  244
6.3.2　AWT缓存集合  248
6.3.3　SWT缓存集合  251
6.3.4　自定义缓存集合  254
6.3.5　多表缓存集合  258
6.3.6　缓存老化  259
6.3.7　缓存过滤器  261
6.3.8　动态缓存集合  261
6.3.9　PassThrough属性  263
6.4　高可用复制架构  263
6.4.1　复制原理  264
6.4.2　ASP架构  266
6.5　高可用网格架构  273
6.5.1　无网格双活架构  274
6.5.2　网格双活架构  274
6.5.3　ASP网格双活架构  280
6.6　分库分表  283
6.6.1　只读缓存集合的分库分表  283
6.6.2　AWT缓存集合的分库分表  285
6.7　TimesTen设计与管理  286
6.7.1　表设计与管理  286
6.7.2　索引管理  291
6.7.3　统计信息与执行计划  294
6.8　TimesTen性能监控  299
6.8.1　关键指标  299
6.8.2　SQL监控  300
6.8.3　监控报告  302
6.8.4　复制监控  305
6.8.5　自动刷新监控  307
6.9　TimesTen备份与恢复  309
6.9.1　数据库备份  309
6.9.2　数据库恢复  311
6.9.3　数据迁移  313
6.10　TimesTen高并发场景  315
6.10.1　场景选择  316
6.10.2　并发场景测试  317
6.11　本章小结  318
第7章　GoldenGate构建数据库群  319
7.1　GoldenGate概述  319
7.1.1　小核心，大外围  320
7.1.2　GoldenGate应用场景  321
7.1.3　GoldenGate技术架构  323
7.1.4　数据库群的制约因素  328
7.2　开始使用  329
7.2.1　GoldenGate安装  329
7.2.2　GoldenGate配置  331
7.2.3　基本链路的搭建  334
7.2.4　GoldenGate的监控  339
7.3　高级应用  343
7.3.1　DDL功能支持  343
7.3.2　用户级复制  345
7.4　异构数据库群  347
7.4.1　异构字符集数据库间复制  347
7.4.2　异构数据库间复制  351
7.5　本章小结  353
第8章　Data Guard的妙用  354
8.1　“T-1”交易数据库  354
8.1.1　实现原理与应用场景  355
8.1.2　“T-1”备库简介  356
8.1.3　“T-1”库闪回简介  357
8.1.4　“T-1”数据库搭建  358
8.2　ADG实现读写分离  361
8.2.1　ADG架构简介  361
8.2.2　ADG数据库搭建  362
8.3　本章小结  365
第9章　最佳实践  366
9.1　术  366
9.1.1　技术回顾  367
9.1.2　规矩方圆  369
9.1.3　穿越之眼  370
9.2　道  370
9.2.1　数据库架构师  370
9.2.2　沟通之道  371
9.3　势  374
9.4　本章小结  375
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高并发Oracle数据库系统的架构与设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web 2.0架构开发与项目实战
第1部分 基础应用篇
第01章 J2EE技术框架
第02章 Java Web开发过程中实用工具的使用
第03章 Java与XML编程
第2部分 Ajax/Web 2.0应用篇
第04章 Java Script高级应用
第05章 Ajax与Web 2.0应用架构
第06章 A4J框架
第07章 DWR框架
第08章 Dojo框架
第3部分 SSH架构篇
第09章 Struts 2.1框架
第10章 Struts 2.1注解及应用整合
第11章 Spring 2框架
第12章 Hibernate 3框架
第13章 SSH构架应用整合
第4部分 Java EE篇
第14章 Java EE架构技术
第15章 EJB 3
第16章 JMS（Java Message Service）
第17章 实体Bean
第18章 JSF框架
第5部分 项目实战篇
第19章 基于JSF+EJB 3+A4J框架的网上定餐系统
第20章 飞机零部件电子商务交易平台（BCP）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java Web 2.0架构开发与项目实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>智能普适网络
第1部分  后电信时代的到来——运营商应进行运营模式创新思考  第1章  后电信时代业务发展趋势    1.1  互联网与电信网发展趋势      1.1.1  互联网发展趋势      1.1.2  电信网发展趋势    1.2  电信业面临挑战      1.2.1  互联网/移动互联网业务威胁      1.2.2  三网融合竞争压力    1.3  电信运营商转型优势分析      1.3.1  基础设施垄断地位      1.3.2  强大用户聚合效应      1.3.3  丰富客户信息资源    1.4  电信运营商业务模式转型途径      1.4.1  向“通信+商业渠道”转型      1.4.2  向“通信+媒体广告”转型      1.4.3  向“通信+信息服务”转型      1.4.4  向“前+后”收费模式转型  第2章  后电信时代技术发展趋势    2.1  云计算      2.1.1  云计算背景和驱动力      2.1.2  云计算内涵      2.1.3  云计算与相关技术的区别和联系    2.2  普适计算      2.2.1  普适计算起源及现状      2.2.2  普适计算发展趋势      2.2.3  普适计算与相关技术的区别和联系    2.3  物联网      2.3.1  物联网起源与发展      2.3.2  物联网与泛在网      2.3.3  物联网与传感网    2.4  人工智能      2.4.1  人工智能的目标      2.4.2  人工智能在通信领域的应用    2.5  公众计算通信网第2部分  智能普适网络——智能电信网络核心系统  第3章  智能普适网络    3.1  公众通信网及业务的发展回顾      3.1.1  通信网络的发展      3.1.2  公众业务的发展    3.2  公众计算通信网      3.2.1  公众计算通信网的起源和发展      3.2.2  公众计算通信网的特征      3.2.3  公众计算通信网的架构    3.3  智能普适网络      3.3.1  智能普适网络架构      3.3.2  智能普适网络特征分析      3.3.3  智能普适网络与传统电信网、计算机网的关系    3.4  智能普适网络组网拓扑及各层简介      3.4.1  数据中心层      3.4.2  云资源系统层      3.4.3  能力引擎层      3.4.4  资源控制节点层      3.4.5  智能接入网关层      3.4.6  终端层  第4章  分布式智能开放系统    4.1  基本概念    4.2  系统架构    4.3  关键技术      4.3.1  统一虚拟化技术和云管理技术      4.3.2  分布式文件系统和存储技术      4.3.3  海量数据处理技术      4.3.4  普适网络技术和上下文感知计算      4.3.5  业务能力引擎      4.3.6  运营支撑技术      4.3.7 智能资源适配      4.3.8  数据挖掘技术      4.3.9  终端技术      4.3.10  云计算安全和用户隐私保护技术  第5章  业务数据系统    5.1  用户数据子系统      5.1.1  系统组成      5.1.2  分析维度      5.1.3  数据挖掘与商业模型    5.2  网络数据子系统      5.2.1  系统功能      5.2.2  网络控制和管理      5.3  业务数据子系统      5.3.1  系统重点功能      5.3.2  重点业务应用      5.3.3  重点业务场景      5.3.4  数据的整合与管理第3部分  智能普适网络应用  第6章  iun在bss中的应用    6.1  bss现状分析    6.2  bss革新需求    6.3  基于iun的bss解决方案      6.3.1  设计理念      6.3.2  体系架构      6.3.3  功能介绍    6.4  基于iun的用户上网流量查询系统      6.4.1  整体架构      6.4.2  关键技术      6.4.3  优势分析    6.5  iun应用挑战      6.5.1  管理模式挑战      6.5.2  安全模式挑战      6.5.3  技术挑战  第7章  iun在oss中的应用    7.1  oss系统现状分析    7.2  oss系统革新需求    7.3  基于iun的oss云      7.3.1  系统架构      7.3.2  具体实施    7.4  基于iun的信令监测平台      7.4.1  信令监测平台发展趋势分析      7.4.2  统一信令监测平台目标      7.4.3  基于iun的统一信令监测平台      7.4.4  基于iun的海量信令数据挖掘    7.5  iun应用挑战  第8章  iun在企业信息化中的应用    8.1  传统桌面挑战      8.1.1  数据安全      8.1.2  管理成本      8.1.3  应用性能      8.1.4  速度限制    8.2  桌面虚拟化技术      8.2.1  桌面虚拟化概述      8.2.2  桌面虚拟化系统架构    8.3  桌面虚拟化应用策略      8.3.1  总体原则      8.3.2  营业厅应用策略      8.3.3  呼叫中心应用策略  第9章  iun在vdc中的应用    9.1  idc发展现状    9.2  idc革新需求    9.3  iun助力idc向vdc转型    9.4  vdc业务模式分析    9.5  基于iun的vdc技术方案  第10章  iun在增值业务平台中的应用    10.1  增值业务现状分析    10.2  iun在音乐业务中的应用      10.2.1  云计算应用现状      10.2.2  基于iun的音乐业务    10.3  iun在邮件业务中的应用      10.3.1  云计算应用现状      10.3.2  基于iun的邮件服务      10.3.3  关键功能    10.4  iun在视频业务中的应用      10.4.1  云计算应用现状      10.4.2  基于iun的视频业务      10.4.3  视频云存储技术方案  第11章  iun在网络中的应用    11.1  云基站      11.1.1  提出背景      11.1.2  前景优势      11.1.3  关键技术    11.2  数据中心云网络      11.2.1  定义及需求      11.2.2  前景优势      11.2.3  关键技术缩略语
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>智能普适网络
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ROF光载无线通信：从理论到前沿
作者简介
原书序
原书前言
原书致谢
1引言1
1.1背景介绍1
1.1.1ROF系统2
1.1.2毫米波段ROF4
1.1.3配置于特殊区域5
1.1.4对现有光纤的增值利用6
1.1.5微波光子学的进步6
1.1.6动态系统升级7
1.2基本Fi-Wi系统架构8
1.2.1两种调制类型9
1.3主要课题10
1.4其他光纤到馈方案11
1.4.1数字化ROF11
1.4.2光纤中频通信12
1.5本书结构12
2Fi-Wi核心链路元件14
2.1RF—光调制14
2.1.1直接强度调制和激光器二极管14
2.1.2外强度调制21
2.2光纤信道23
2.2.1衰减23
2.2.2多模光纤ROF25
2.2.3单模光纤ROF26
2.2.4干涉噪声28
2.3光接收器29
2.3.1光探测器30
2.3.2量子效率与带宽32
2.4基带—RF调制技术简述33
2.4.1相移键控33
2.4.2幅移键控34
2.4.3正交幅度调制34
2.5无线信道35
2.5.1室内传播35
2.5.2室外传播35
2.5.3路径损耗模型35
2.5.4多径传播和衰落37
3功率链路分配与累积性SNR40
3.1引言40
3.2系统描述40
3.3光学SNR42
3.3.1各种噪声对OSNR的影响45
3.4累积性SNR46
3.4.1无线和光链路噪声功率相近47
3.5RAP设计思想48
3.5.1光接收器放大增益49
3.5.2小区覆盖面积51
3.6总结51
4对相关性强度噪声表达式的改进53
4.1基础53
4.2ROF链路中的基本噪声处理54
4.2.1散粒噪声55
4.2.2相关性强度噪声56
4.3信噪比58
4.4数值评估和讨论59
4.4.1SCM ROF系统的噪声等级增加59
4.5总结61
5子载波复用ROF下行链路62
5.1引言62
5.1.1背景介绍63
5.2ROF下行链路信道63
5.2.1高阶项65
5.3无线下行链路信道73
5.4定量评估与讨论74
6子载波复用ROF上行链路78
6.1无线上行链路信道79
6.2ROF上行链路信道80
6.2.1非线性失真81
6.2.2高阶项82
6.3信号失真、串扰和噪声比89
6.4定量评估和讨论91
6.5总结97
7外调制ROF链路98
7.1Mach-Zehnder调制器98
7.1.1MZI原理100
7.2电吸收调制101
7.3反射型半导体光放大器103
7.4MZI偏置电压的优化104
7.4.1RF增益最大化105
7.4.2噪声因数最小化107
7.4.3无杂散动态范围最大化108
7.4.4合并品质因数110
7.5MZI子载波复用111
8ROF链路非线性的DSP建模115
8.1引论115
8.1.1线性动态范围的要求115
8.1.2相位非线性116
8.2减小NLD的若干种尝试116
8.2.1动态增益控制器和衰减器116
8.2.2静态的光—电方案116
8.2.3一些最新技术117
8.3DSP方法118
8.3.1对光波段失真的基带补偿118
8.4非线性系统的DSP基础119
8.4.1Volterra级数模型120
8.4.2离散时域问题121
8.5通频带复非线性系统的基带表示121
8.6Fi-Wi链路的非线性建模122
9ROF链路非线性的自适应补偿123
9.1ROF链路的自适应模型123
9.1.1Volterra核优化123
9.1.2滤波器阶数和记忆124
9.1.3实例研究127
9.2非对称补偿129
9.2.1预补偿与后验补偿130
9.2.2非对称补偿的共性132
9.2.3自适应DSP补偿的实例研究134
9.2.4查询表与自适应滤波补偿137
9.3总结137
10Fi-Wi信道的联合估计139
10.1Fi-Wi链路的Wiener和Hammerstein系统模型139
10.2Fi-Wi信道估计140
10.2.1输入/输出相关法141
10.2.2线性部分估计142
10.2.3非线性部分估计145
10.3实例研究146
10.3.1线性系统识别147
10.3.2非线性系统识别148
10.4总结149
11Fi-Wi信道的联合均衡150
11.1无线信道的均衡150
11.1.1非线性增强型判决反馈均衡器151
11.1.2Hammerstein型DFE151
11.1.3振幅和时域处理152
11.2多项式滤波器参数优化153
11.2.1直接生成逆多项式153
11.3线性滤波器参数优化155
11.3.1模型描述155
11.3.2参数优化158
11.4总结159
12Hammerstein型DFE的性能评估160
12.1多项式滤波器评估160
12.1.1时间色散的非线性变换160
12.1.2逆多项式变换162
12.1.3多项式滤波器误差的期望163
12.2线性滤波器评估165
12.2.1无限长结果165
12.2.2有限长结果166
12.3实例研究166
12.3.1多项式滤波器的方均误差166
12.3.2线性滤波器的方均误差172
12.3.3HDFE的BER性能172
12.4总结173
13多用户CDMA Fi-Wi系统174
13.1多用户Fi-Wi上行链路模型174
13.2相关性关系176
13.2.1广义输入-输出相关性176
13.2.2多用户下的输入-核相关性178
13.3ROF信道估计180
13.4实例研究181
13.4.1仿真参数181
13.4.2无线信道识别182
13.4.3光纤链路识别183
13.5Fi-Wi上行链路均衡184
13.5.1无线信道均衡184
13.5.2序列回归线性化184
13.6均衡：仿真结果和讨论185
13.7总结187
144G、5G以及无线OFDM网络的Fi-Wi188
14.1蜂窝通信系统简史189
14.1.1全球范围互通性微波接入189
14.1.2长期演进190
14.2无线接入方案191
14.2.1正交频分复用接入191
14.3减小峰值-平均功率比的技术194
14.4OFDM ROF系统进化195
14.4.1自适应调制技术196
14.4.2实例研究198
14.5OFDMA和CDMA的融合198
14.6总结199
参考文献200
附录：缩略语表207
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ROF光载无线通信：从理论到前沿
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>固态存储
前言
第一部分　存储技术基础
第1章　存储技术概要 3
1.1存储技术发展简史 3
1.2存储介质 5
1.2.1磁介质 5
1.2.2光介质 8
1.2.3半导体存储器 11
1.3磁盘阵列 12
1.4网络化存储 14
1.4.1网络存储架构 15
1.4.2分布式存储 21
1.5大数据时代下的新兴存储技术 23
1.6存储系统的逻辑构成 24
1.6.1主机系统 24
1.6.2互连方式 25
1.6.3存储器层次结构 27
本章参考文献 28
第2章　文件系统 29
2.1FAT 29
2.1.1FAT的发展概况 30
2.1.2FAT的重要概念 30
2.1.3FAT 32的原理 32
2.1.4FAT的优缺点 38
2.2EXT 38
2.2.1EXT的发展概况 38
2.2.2树形目录结构 39
2.2.3EXT的磁盘布局 40
2.2.4数据块寻址方法 43
2.2.5日志系统 44
2.2.6EXT4引入的新特性 45
2.3NTFS 46
2.3.1NTFS的重要概念 47
2.3.2NTFS的元文件和总体布局 48
2.3.3NTFS的引导扇区 50
2.3.4NTFS的文件存储特性 51
2.4CDFS 52
2.4.1逻辑存储结构 53
2.4.2CD-ROM上数据的定位 58
2.4.3CDFS的改进 60
2.5其他文件系统 62
2.5.1BtrFS 62
2.5.2ZFS 62
2.5.3HFS 64
2.5.4HFS+ 65
2.5.5ReiserFS 65
2.5.6JFS 66
2.5.7XFS 67
2.5.8UFS 67
2.5.9VMFS 69
2.5.10VxFS 70
2.5.11ReFS 70
2.6常用文件系统的对比分析 71
本章参考文献 73
第3章　接口与协议 74
3.1IDE 76
3.1.17种ATA物理接口规范 76
3.1.2IDE数据传输模式 78
3.2SCSI 79
3.2.1SCSI电气特征 79
3.2.2SCSI接口协议 79
3.2.3SCSI接口的发展 80
3.2.4SCSI与IDE的比较 81
3.3SATA 82
3.3.1SATA接口的组成 83
3.3.2SATA协议介绍 83
3.3.3SATA兼容性 84
3.3.4SATA的优点和不足 85
3.4其他接口 86
3.4.1PCI-E 86
3.4.2FC 87
3.4.3SAS 88
本章参考文献 89
第二部分　固态存储的原理与架构
第4章　固态存储基本知识和工作原理 93
4.1基本知识 93
4.1.1半导体存储器概述 94
4.1.2固态存储器的分类 96
4.1.3固态存储器的特点 97
4.2Flash存储介质工作原理 98
4.2.1NOR Flash 99
4.2.2NAND Flash 104
4.2.3NAND Flash 阵列 113
本章参考文献 119
第5章　固态存储架构 120
5.1概述 120
5.2主机接口 122
5.3主控芯片 142
5.4缓存 150
5.5闪存接口 151
本章参考文献 153
第6章　固态存储文件系统 154
6.1概述 154
6.2JFFS2 156
6.2.1主要节点 156
6.2.2挂载过程 159
6.2.3写文件过程 160
6.2.4读文件过程 160
6.2.5垃圾回收机制 161
6.3YAFFS 162
6.3.1基本概念 162
6.3.2内存结构 165
6.3.3扫描挂载 170
6.3.4垃圾回收 172
6.3.5使用均衡 173
6.4UBIFS 174
6.4.1UBI 174
6.4.2UBIFS分析 178
6.5exFAT 181
6.5.1exFAT分区布局 182
6.5.2目录项 185
本章参考文献 189
第7章　容错与写平衡 190
7.1错误校验码 191
7.1.1概述 191
7.1.2汉明码 192
7.1.3BCH码 197
7.1.4里德-所罗门码 202
7.2平衡机制 209
7.2.1概述 209
7.2.2垃圾回收 210
7.2.3使用均衡 212
7.3坏块管理 215
7.3.1概述 215
7.3.2坏块管理的实现 216
本章参考文献 218
第三部分　固态存储安全技术
第8章　数据安全删除 221
8.1基于NAND Flash的存储设备访问层次模型 221
8.2控制器层方案 224
8.2.1Scrubbing方案 224
8.2.2基于修改典型FTL机制的数据安全删除方案 229
8.2.3NFPS：不可检测的数据安全删除方案 230
8.2.4TedFlash：完备数据安全删除方案 248
8.3文件系统层方案 254
8.3.1基于YAFFS的方案 254
8.3.2基于UBIFS的方案 259
8.4应用层方案 262
8.5跨层方案 263
本章参考文献 264
第9章　存储数据机密性保护 267
9.1XTS-AES 268
9.1.1概述 268
9.1.2单个128位数据块的XTS-AES加密 269
9.1.3数据单元的XTS-AES加密 271
9.1.4XTS-AES的工作模式 273
9.2可否认加密 273
9.2.1可否认加密与认证协议简介 274
9.2.2面向桌面系统的可否认加密方案 276
9.2.3面向移动系统的可否认加密方案 279
9.2.4面向NAND Flash的可否认加密方案 284
本章参考文献 290
第10章　NAND Flash物理不可克隆技术 292
10.1NAND Flash PUF相关原理概述 293
10.1.1NAND Flash存储单元的阈值电压 293
10.1.2NAND Flash存储单元之间的相互干扰 294
10.2NAND Flash PUF应用 295
10.2.1提取设备指纹 295
10.2.2提取随机数 304
10.2.3信息隐藏 308
10.2.4提取密钥 314
本章参考文献 325
第11章　展望 327
11.13D NAND闪存 327
11.1.13D NAND闪存的优势 328
11.1.2主要厂商的3D NAND闪存及其特色 328
11.2相变存储器 330
11.3全息存储技术 331
本章参考文献 332
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>固态存储
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>物联网开放平台
第1章物联网概念基础1
1.1引言1
1.2物联网是什么1
1.3物联网应用场景3
1.3.1物联网场景模型3
1.3.2物联网的技术特征5
1.4物联网与相关概念7
1.4.1物联网与互联网7
1.4.2物联网与传感器网络、泛在网8
1.4.3物联网与M2M和CPS的关系10
1.5物联网政策战略导向11
1.5.1美国的“智慧地球”12
1.5.2欧洲“物联网行动”计划12
1.5.3日本的“U—Japan”计划16
1.5.4韩国的“U—Korea”战略17
1.5.5新加坡的“下一代I—Hub”计划17
1.5.6中国的“感知中国”18
第2章物联网体系基础技术19
2.1引言19
2.2物联网体系结构19
2.3感知层21
2.3.1RFID技术21
2.3.2WSN23
2.3.3ZigBee技术25
2.3.4视频监控31
2.3.5MEMS技术34
2.3.6嵌入式技术36
2.4网络层37
2.4.1LoRa37
2.4.2NB—IoT40
2.4.3IPv6技术42
2.4.4TD—LTE网络46
2.5应用层47
2.5.1M2M技术47
2.5.2通信协议50
2.5.3中间件技术53
2.5.4云计算技术57
2.5.5数据挖掘技术60
第3章从物联网产业生态看开放平台价值63
3.1引言63
3.2物联网产业现状分析63
3.2.1物联网产业发展阶段63
3.2.2物联网发展驱动与问题分析65
3.3物联网平台型生态体系价值66
3.3.1Apple与Google带来的启示66
3.3.2开放平台商业服务与价值67
3.4物联网平台用户体系69
3.5物联网开放平台应用产品分类70
3.6物联网开放平台服务管理模式71
3.6.1物联网生态业务模型71
3.6.2业务模式72
3.7物联网平台生态发展策略74
3.7.1产品开发原理74
3.7.2产品合作流程74
3.7.3业务集群化75
3.8业界其他开放平台架构方式76
3.8.1JasperWireless76
3.8.2VerizonnPhase77
3.8.3BaiduInside79
第4章物联网开放平台架构设计与实现82
4.1引言82
4.2物联网开放平台总体架构82
4.3设备管理平台87
4.3.1感知外设远程管理87
4.3.2传感网管理90
4.4连接管理平台92
4.4.1终端通信状态查询92
4.4.2终端用户支撑系统信息查询93
4.4.3通信管理使用鉴权93
4.4.4限制终端使用通信业务94
4.4.5模拟位置更新94
4.4.6向终端发送测试短信94
4.4.7终端通信故障快速诊断95
4.4.8终端自动监控规则95
4.5应用使能平台95
4.5.1开发社区96
4.5.2开发环境98
4.5.3测试环境99
4.6应用中心平台101
4.6.1商品管理101
4.6.2店铺管理103
4.6.3营销服务104
4.6.4交易管理104
4.6.5积分管理106
4.6.6代金券管理107
4.6.7客服服务108
4.6.8计费结算108
4.6.9统计分析108
4.7资源管理平台109
4.7.1执行环境109
4.7.2接口适配层110
4.7.3运行控制台110
4.7.4服务模式111
4.8业务分析平台112
4.8.1数据管理112
4.8.2数据处理113
4.8.3数据分析114
4.8.4任务引擎115
第5章物联网开放平台开源软件研究116
5.1引言116
5.2开源软件概述117
5.2.1开源的概念117
5.2.2开源许可证117
5.2.3开源软件与商业软件的对比118
5.3企业服务总线（ESB）软件研究119
5.3.1ESB概述119
5.3.2WSO2ESB123
5.3.3其他的典型ESB128
5.3.4典型的ESB软件对比及小结133
5.3.5ESB软件对平台建设的意义135
5.4复杂事件处理（CEP）软件研究136
5.4.1CEP概述136
5.4.2典型CEP软件的对比137
5.4.3Storm138
5.4.4CEP软件对平台建设的意义142
5.5业务流程管理（BPM）软件研究142
5.5.1BPM概述142
5.5.2jBPM145
5.5.3ActivitiBPM148
5.5.4Fixflow151
5.5.5典型BPM软件的对比及小结153
5.5.6BPM软件对平台建设的意义155
5.6消息队列（MQ）软件研究155
5.6.1MQ概述155
5.6.2RabbitMQ157
5.6.3MetaQ160
5.6.4ZeroMQ164
5.6.5典型MQ软件的对比及小结167
5.6.6MQ软件对平台建设的意义168
5.7本章小结169
第6章物联网开放平台高效通信协议研究170
6.1引言170
6.2IBMMQTT170
6.2.1概要170
6.2.2消息格式171
6.2.3消息列表177
6.2.4协议流程187
6.2.5MQTT开源实现—Mosquitto189
6.2.6MQTT小结193
6.3IETF：CoAP193
6.3.1协议介绍193
6.3.2协议栈结构194
6.3.3消息格式194
6.3.4请求与应答196
6.3.5URI方案198
6.3.6业务发现199
6.3.7组播机制199
6.3.8安全机制200
6.3.9交叉代理201
6.3.10CoAP小结201
6.4OMA—LightweightM2M201
6.4.1协议架构202
6.4.2接口设计202
6.4.3资源组织207
6.4.4CoAP承载208
6.4.5LWM2M小结210
6.5协议比较210
6.6本章小结211
……
第7章物联网开放平台安全研究212
第8章物联网典型应用245
参考文献266
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>物联网开放平台
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业级大数据平台构建：架构与实现
推荐序　思者常新，厚积薄发
前　言
第1章　浅谈企业级大数据平台的重要性 1
1.1　缺乏统一大数据平台的问题 2
1.1.1　资源浪费 2
1.1.2　数据孤岛 2
1.1.3　服务孤岛 3
1.1.4　安全存疑 3
1.1.5　缺乏可维护性和可扩展性 3
1.1.6　缺乏可复制性 4
1.2　构建统一大数据平台的优势 4
1.3　企业级大数据平台需要具备的基本能力 6
1.3.1　集群管理与监控 7
1.3.2　数据接入 7
1.3.3　数据存储与查询 7
1.3.4　数据计算 8
1.3.5　平台安全与管理 10
1.4　平台辅助工具 12
1.5　本章小结 13
第2章　企业级大数据平台技术栈介绍 15
2.1　HDFS 16
2.1.1　概述 16
2.1.2　RAID技术 17
2.1.3　核心设计目标 18
2.1.4　命名空间 19
2.1.5　数据模型 20
2.1.6　Namenode和Datanode 20
2.1.7　使用场景 21
2.2　Zookeeper 22
2.2.1　概述 22
2.2.2　核心特性 23
2.2.3　命名空间 24
2.2.4　数据模型 24
2.2.5　节点状态监听 25
2.2.6　原子消息广播协议 25
2.2.7　使用场景 32
2.3　HBase 33
2.3.1　概述 33
2.3.2　数据模型 34
2.3.3　Regions 34
2.3.4　HBase Master 35
2.3.5　Region Server 36
2.3.6　MemStore与HFile 37
2.3.7　使用场景 37
2.4　YARN 38
2.4.1　概述 38
2.4.2　资源模型和Container 40
2.4.3　ResourceManager 40
2.4.4　ApplicationMaster 40
2.4.5　NodeManager 41
2.4.6　单一集群架构 41
2.4.7　工作流程 41
2.4.8　使用场景 43
2.5　Spark 43
2.5.1　概述 43
2.5.2　数据模型 45
2.5.3　编程模型和作业调度 45
2.5.4　依赖 46
2.5.5　容错 47
2.5.6　集群模式 47
2.5.7　使用场景 48
2.6　本章小结 49
第3章　使用Ambari安装Hadoop集群 50
3.1　概述 50
3.2　集群设计 52
3.2.1　主控节点 52
3.2.2　存储与计算节点 53
3.2.3　安全认证与管理节点 54
3.2.4　协同管理与其他节点 54
3.3　Ambari的安装、配置与启动 55
3.3.1　安装前的准备 55
3.3.2　安装Ambari-Server 62
3.3.3　Ambari-Server目录结构 64
3.3.4　配置Ambari-Server 65
3.3.5　启动Ambari-Server 66
3.4　新建集群 67
3.4.1　设置集群名称并配置HDP安装包 67
3.4.2　配置集群 69
3.5　Ambari控制台功能简介 77
3.5.1　集群服务管理 78
3.5.2　集群服务配置 80
3.5.3　辅助工具 82
3.6　本章小结 86
第4章　构建企业级平台安全方案 87
4.1　浅谈企业级大数据平台面临的安全隐患 88
4.1.1　缺乏统一的访问控制机制 88
4.1.2　缺乏统一的资源授权策略 88
4.1.3　缺乏Hadoop服务安全保障 89
4.2　初级安全方案 89
4.2.1　访问控制 89
4.2.2　数据授权与管理 97
4.3　本章小结 110
第5章　Hadoop服务安全方案 111
5.1　Kerberos协议简介 111
5.2　使用FreeIPA安装Kerberos和LDAP 113
5.2.1　安装FreeIPA 115
5.2.2　IPA-Server管理控制台功能介绍 119
5.2.3　IPA CLI功能介绍 122
5.3　开启Ambari的Kerberos安全选项 127
5.3.1　集成前的准备 127
5.3.2　集成IPA 129
5.3.3　测试Kerberos认证 133
5.4　本章小结 136
第6章　单点登录与用户管理 137
6.1　集成单点登录 139
6.1.1　CAS简介 140
6.1.2　安装CAS-Server 141
6.1.3　集成Knox网关与CAS-
Server 148
6.1.4　集成Ranger与CAS-Server 151
6.1.5　集成Ambari与CAS-Server 152
6.2　实现统一的用户管理系统 155
6.3　使用Java程序调用脚本 161
6.4　创建Ranger扩展用户 166
6.5　本章小结 169
第7章　搭建平台管理端RESTful服务 170
7.1　搭建RESTful服务框架 170
7.2　用户查询 174
7.2.1　引入LDAP模块 174
7.2.2　配置LDAP 174
7.2.3　实现持久层 177
7.2.4　实现服务层 181
7.2.5　实现RESTful服务 181
7.2.6　整合用户管理 183
7.3　RESTful服务安全认证 184
7.3.1　用户登录服务 185
7.3.2　使用JWT认证 185
7.3.3　创建用户登录RESTful服务 188
7.3.4　认证过滤器 194
7.3.5　测试服务安全认证 198
7.4　数据仓库数据查询 200
7.4.1　创建JDBC连接 200
7.4.2　Kerberos登录 202
7.4.3　使用JDBC协议查询 202
7.4.4　实现服务层与RESTful服务 206
7.4.5　测试查询 207
7.5　数据仓库元数据查询 208
7.5.1　使用query服务查询数仓元数据 208
7.5.2　引入JdbcTemplate模块 209
7.5.3　增加Hive元数据库配置 210
7.5.4　实现元数据持久层 211
7.5.5　实现元数据服务层与RESTful服务 216
7.5.6　测试元数据查询 218
7.6　本章小结 219
第8章　Spark任务与调度服务 220
8.1　提交Spark任务的3种方式 220
8.1.1　使用Spark-Submit脚本提交 220
8.1.2　使用Spark Client提交 226
8.1.3　使用YARN RESTful API提交 229
8.2　查询Spark日志 234
8.3　任务调度 236
8.3.1　引入Quartz模块 237
8.3.2　增加Quartz配置 237
8.3.3　编写调度任务 240
8.3.4　改进空间 241
8.4　本章小结 241
附录A　Hadoop简史 242
附录B　Hadoop生态其他常用组件一览 245
附录C　常用组件配置说明 248
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业级大数据平台构建：架构与实现
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式缓存
第 1部分 基本功能
第　1章 基于HTTP的内存缓存服务　3
1．1　缓存服务的接口　3
1．1．1　REST接口　3
1．1．2　缓存Set流程　5
1．1．3　缓存Get流程　6
1．1．4　缓存Del流程　7
1．2　Go语言实现　8
1．2．1　main包的实现　8
1．2．2　cache包的实现　9
1．2．3　HTTP包的实现　14
1．3　功能演示　19
1．4　与Redis比较　21
1．4．1　Redis介绍　21
1．4．2　redis-benchmark介绍　23
1．4．3　cache-benchmark介绍　24
1．4．4　性能对比　26
1．5　小结　30
第　2章 基于TCP的内存缓存服务　32
2．1　基于TCP的缓存协议规范　33
2．1．1　协议范式　33
2．1．2　缓存Set流程　35
2．1．3　缓存Get流程　36
2．1．4　缓存Del流程　36
2．2　Go语言实现　37
2．2．1　main函数的变化　37
2．2．2　TCP包的实现　38
2．2．3　客户端的实现　44
2．3　功能演示　45
2．4　性能测试　47
2．5　小结　48
第3章　数据持久化　50
3．1　RocksDB简介　50
3．2　RocksDB性能测试　51
3．2．1　基本读写性能　52
3．2．2　大容量测试　52
3．3　用cgo调用C++库函数　55
3．4　Go语言实现　58
3．4．1　main函数的实现　58
3．4．2　cache包的实现　59
3．5　功能演示　65
3．6　性能测试　67
3．7　小结　69
第　2部分 性能相关
第4章　用pipelining加速性能　73
4．1　pipelining原理　73
4．2　redis pipelining性能对比　75
4．3　Go语言实现　77
4．3．1　main包的实现　77
4．3．2　cacheClient包的实现　86
4．4　性能测试　97
4．5　小结　99
第5章　批量写入　101
5．1　批量写入能够提升写入性能的原理　101
5．2　RocksDB批量写入性能测试　102
5．3　Go语言实现　103
5．4　性能测试　108
5．5　小结　112
第6章　异步操作　113
6．1　异步操作能够提升读取性能的原理　114
6．2　Go语言实现　117
6．3　性能测试　122
6．4　小结　127
第3部分　服务集群
第7章　分布式缓存　131
7．1　为什么我们需要集群服务　131
7．2　负载均衡和一致性散列　133
7．3　获取节点列表的接口　140
7．4　Go语言实现　140
7．4．1　main函数的实现　140
7．4．2　cluster包的实现　141
7．4．3　HTTP包的实现　145
7．4．4　TCP包的实现　147
7．5　功能演示　149
7．6　小结　152
第8章　节点再平衡　154
8．1　节点再平衡的技术细节　154
8．2　节点再平衡的接口　155
8．3　Go语言实现　155
8．3．1　HTTP包的实现　155
8．3．2　cache包的实现　157
8．4　功能演示　162
8．5　小结　164
第9章　缓存生存时间　166
9．1　缓存生存时间的作用　166
9．2　Go语言实现　167
9．2．1　main函数的实现　167
9．2．2　cache包的实现　168
9．3　功能演示　172
9．4　小结　174
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式缓存
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>抢占下一个智能风口：移动物联网
CHAPTER 1 初步认识，规模化的移动物联网形势
1.1　一探究竟，了解移动物联网／ 2
1.1.1 移动物联网的基本概念／ 3
1.1.2 移动物联网的原理与类别／ 5
1.1.3 移动物联网的关键领域／ 7
1.1.4 移动物联网的应用模式／ 11
1.2　技术推动移动物联网发展／ 13
1.2.1 信息呈现——条形码标识／ 14
1.2.2 远程扫码——激光扫描器／ 14
1.2.3 灵敏测量——红外线感应器／ 15
1.2.4 信息识读——二维码标识／ 16
1.2.5 测时与测距——全球定位系统／ 17
1.2.6 无缝通信——3G/4G 技术／ 18
1.2.7 信息输出——传感器／ 19
1.2.8 内部集成——PLM 服务器／ 20
1.2.9 自动化——无线射频识别／ 21
1.2.10 远程识别——遥感器技术／ 21
1.2.11 信息传递——EPC 编码／ 22
1.2.12 实时连接——M2M 技术／ 23
1.3　透析局势，掌控移动物联网／ 24
1.3.1 区别移动物联网与互联网／ 25
1.3.2 数字城市的技术支撑——移动物联网／ 26
1.3.3 关联移动互联网与移动物联网／ 27
1.3.4 IPv6 研发助力移动物联网／ 28
1.3.5 移动物联网，现代产业未来发展的需要／ 29
CHAPTER 2 两化融合，高层次的移动物联网理念
2.1　逐步深入，认识两化融合／ 32
2.1.1 概念生成——两化深度融合／ 32
2.1.2 关系——移动物联网与两化融合／ 35
2.1.3 发展——时代趋势下的两化融合／ 36
2.1.4 核心——装备制造业的产业升级／ 37
2.1.5 挑战——制造业领域的两化融合／ 38
2.2　解读两化融合／ 43
2.2.1 技术融合，创新推动／ 43
2.2.2 产品融合，价值提升／ 44
2.2.3 业务融合，效率提高／ 45
2.2.4 产业衍生，业态发展／ 46
2.3　广泛应用，推进两化融合／ 48
2.3.1 【案例】“双塔”发展，两化融合助推／ 48
2.3.2 【案例】徐工“智慧行”，两化融合推进／53
2.3.3 【案例】医药产业转型，连云港两化融合加速／55
2.3.4 【案例】“4322”工程，两化融合深度行／57
CHAPTER 3 移动支付，智能化的移动物联网金融
3.1　认识移动支付／ 62
3.1.1 概念——移动终端上的支付／ 62
3.1.2 类别——近场与远程并举／ 63
3.1.3 发展——历经三阶段的移动支付／ 65
3.1.4 特点——便捷、安全与综合／ 66
3.2　技术支持实现移动支付／ 69
3.2.1 三种方式主导手机支付／ 70
3.2.2 SIM 与RFID 融合，中国移动的支付方案／74
3.2.3 SIMpass 天线构件，中国电信的支付方案／ 76
3.2.4 NFC 芯片整合，中国联通的支付方案／ 78
3.3　关注移动支付／ 80
3.3.1 国外移动支付的“早”与“全”／ 80
3.3.2 大力推进的国外移动支付企业／ 82
3.3.3 迅速发展的国内移动支付／ 84
3.3.4 创新应用的国内移动支付企业／ 84
3.4　主体形成，发展移动支付／ 85
3.4.1 金融机构业务的移动性／ 86
3.4.2 电信运营商业务的金融性／ 87
3.4.3 第三方支付企业的多样性／ 90
3.5　未来趋势，展望移动支付／ 90
3.5.1 未来的移动支付市场趋势／ 91
3.5.2 未来的移动支付交易／ 92
3.5.3 未来的移动支付方式／ 93
3.5.4 未来的移动支付体系／ 94
CHAPTER 4 云计算，服务型的移动物联网技术
4.1　概览云计算体系／ 96
4.1.1 内涵——网络版的计算模型／ 96
4.1.2 原理——分布式计算的实现／ 99
4.1.3 服务——多样化的表现形式／ 100
4.1.4 核心技术构成／ 105
4.1.5 关系——云计算和移动物联网／ 109
4.2　结合应用，云计算与移动物联网／ 111
4.2.1 数据采集／ 111
4.2.2 云数据中心／ 113
4.2.3 云服务中心／ 114
4.2.4 企业2.0 ／ 115
4.3　电子政务，推进云计算发展／ 117
4.3.1 【案例】北京市“祥云工程”的市政建设／118
4.3.2 【案例】上海市“云海计划”的市政整合／120
4.3.3 【案例】深圳市云试点的市政资源共享／121
CHAPTER 5 M2M 技术，拓展性的移动物联网应用
5.1　 移动物联网中的M2M ／ 124
5.1.1 M2M 的基本内涵／ 124
5.1.2 M2M 的技术部分／ 125
5.1.3 M2M 的产品类别／ 131
5.1.4 M2M 的业务应用／ 131
5.1.5 M2M 与移动物联网的关系／ 133
5.1.6 “网络一切”的M2M 未来发展／ 133
5.2　移动物联网中的M2M 应用／ 135
5.2.1 【案例】奥迪M2M 技术的移动4G 生活／ 135
5.2.2 【案例】泰利特提高电网效能的M2M 技术方案／ 137
5.2.3 【案例】医疗领域M2M 技术应用的信息化趋势／140
5.2.4 【案例】ADL 整合车载资讯的M2M 技术应用／ 144
CHAPTER 6 电子标签，点到点的移动物联网实现
6.1　拨开迷雾，勾画RFID 的知识网络／ 150
6.1.1 基本内涵——RFID 技术的自动识别／ 150
6.1.2 构成与原理——RFID 技术的数据交换／ 153
6.1.3 发展历程——RFID 技术的应用与完善／ 159
6.1.4 能量调制——RFID 标签的不同类别／ 161
6.1.5 产品特性——RFID 不同频段解构／ 164
6.1.6 相互关系——RFID 与移动物联网／ 169
6.2　势不可当，探索RFID 的优势应用／ 170
6.2.1 【案例】跟踪盘点，沃尔玛的RFID 标签管理／ 170
6.2.2 【案例】出入控制，RFID 门禁的安全保障／ 172
6.2.3 【案例】智能应用，RFID 技术的交通方案／ 174
6.2.4 【案例】食品溯源，RFID 的全程监控管理／ 175
CHAPTER 7 条形码技术，创新性的移动物联网发展
7.1　条形码技术的世纪／ 178
7.1.1 “条”与“码”而成的技术／ 178
7.1.2 维度上的条形码分类标识／ 180
7.1.3 两大优势尽显的条形码技术／ 185
7.1.4 发展受限的传统条形码市场／ 186
7.2　效益日显，条形码行业应用裒辑／ 187
7.2.1 润“物”无声／ 188
7.2.2 产品问“源”／ 189
7.2.3 电商“通”路／ 191
7.2.4 车“载”识读／ 193
7.2.5 端前尽“扫”／ 194
7.3　集成创新，条码企业的市场拓展／ 195
7.3.1 安全为上，矽感措施保障／ 196
7.3.2 创新为要，新北洋金融聚焦／ 198
7.3.3 产品首发，新大陆新“芯”片／ 198
7.3.4 借力发展，博思得“拓以宽”／ 199
CHAPTER 8 智能硬件，具象化的移动物联网端口
8.1　智能硬件的市场业态／ 202
8.1.1 家居的智能管理与通信／ 202
8.1.2 智能的人车交互／ 205
8.1.3 解放双手的智能蓝牙耳机／ 207
8.1.4 智能卡的多功能应用／ 209
8.2　智能硬件的企业角逐／ 212
8.2.1 百度的联合布局／ 212
8.2.2 腾讯的社交布局／ 214
8.2.3 奇虎360 的多样化布局／ 214
8.2.4 小米的中心布局／ 215
8.2.5 阿里巴巴的整合布局／ 217
8.3　智能硬件的发展设想／ 219
8.3.1 智能监测空气／ 219
8.3.2 智能操作游戏／ 221
8.3.3 智能互动沟通／ 223
CHAPTER 9 行业智能，产业化的移动物联网推进
9.1　智能交通／ 226
9.1.1 公共交通／ 227
9.1.2 停车场管理／ 229
9.2　智能电网／ 230
9.2.1 智能交互终端／ 232
9.2.2 智能电表／ 233
9.3　智能安防／ 235
9.3.1 环境安全／ 237
9.3.2 身份识别／ 240
9.4　智能物流／ 241
9.4.1 物流配送／ 242
9.4.2 仓储管理／ 243
9.5　智能医疗／ 245
9.5.1 可视化管理／ 246
9.5.2 医疗监护／ 247
CHAPTER 10 跨界创新，以点带面的移动物联网融合
10.1　跨界：移动物联网的新起点／ 250
10.1.1 途径：互联网化的人与设备／ 250
10.1.2 动力：全球本土化的互联网商业／ 251
10.1.3 兴起：移动互联网设备的接入／ 252
10.2　创新：移动物联网的关键点／ 254
10.2.1 线下行业的互联网渗透／ 254
10.2.2 线上线下的双向引流／ 255
10.2.3 在线教育的平台运作／ 256
10.2.4 在线旅游的市场重塑／ 257
10.2.5 人的数字化维度／ 259
10.3　合作：移动物联网的未来中心点／ 260
10.3.1 移动应用与服务的深度进化／ 260
10.3.2 终端与服务入口争夺的商业角逐／ 261
10.3.3 互联网巨头结构化的边界重塑／ 262
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>抢占下一个智能风口：移动物联网
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高可用MySQL
前言 i
第一部分 复制
第1章 引言 3
到底什么是复制5
那么，是否需要备份6
什么是监控 7
还有什么我可以阅读的 7
小结8
第2章 mysql复制原理 9
复制的基本步骤10
配置master 11
配置slave12
连接master和slave13
二进制日志简介14
二进制日志记录了什么 15
观察复制的动作16
二进制日志的结构和内容 17
使用python管理复制 20
基本类及函数22
.操作系统 23
服务器类 23
服务器角色.25
建立新slave26
克隆master 27
克隆slave29
克隆操作的脚本31
执行常见的复制任务33
报表 33
小结39
第3章 二进制日志 41
二进制日志的结构42
binlog事件的结构 44
记录语句 45
记录数据操作语言46
记录数据定义语言46
记录查询 47
load data infile语句 52
二进制日志过滤器54
触发器、事件和存储程序 56
存储过程 61
存储函数 64
events 66
特殊结构 66
非事务性的变化和错误处理 67
记录事务 70
事务缓存 71
使用xa进行分布式事务处理74
二进制日志管理76
二进制日志和系统崩溃安全 77
binlog文件轮换（rotation）78
事故（incident） 79
清除binlog文件 80
mysqlbinlog实用工具81
基本用法 81
解释事件（interpreting events）88
二进制日志选项和变量 92
小结94
第4章 基于复制的数据库高可用技术95
冗余96
计划98
slave故障98
master故障98
中继服务器故障99
灾难恢复 99
程序99
热备份 102
双master 107
半同步复制116
slave的提升 119
循环复制 134
小结 138
第5章 mysql集群的横向扩展 139
读操作的横向扩展 141
异步复制的价值 142
管理复制拓扑144
应用层负载均衡器示例 147
级联复制（hierarchal replication） 150
中继服务器的设置 151
使用python添加中继服务器 152
专用slave 153
过滤复制事件 154
使用过滤将事件分配给slave 155
数据分片 157
分片的表示159
数据分区 160
分片之间的均衡 161
一个分片的例子 163
数据的一致性管理 174
非级联部署中的一致性 174
级联部署中的一致性 176
小结 182
第6章 高级复制183
复制架构基础184
中继日志的结构 185
复制线程 187
slave线程的启动和停止 188
通过internet运行复制189
使用内置支持建立安全复制 191
使用stunnel建立安全复制 192
细粒度控制复制 194
关于复制状态的信息 194
处理断开连接的参数 201
slave是如何处理事件的 202
管理i/o线程 202
sql线程的处理 203
slave的安全和恢复 208
同步，事务和数据库崩溃问题 209
保护非事务性语句的规则 210
多源复制 211
基于行的复制214
基于行的复制参数 215
混合模式的复制 215
处理基于行复制的事件 216
事件的执行220
事件和触发器 222
过滤 223
小结 225
第二部分 监控和灾难恢复
第7章 监控入门229
监控方法 230
监控的好处 231
监控系统组件231
处理器 231
内存 233
磁盘 233
网络子系统234
监控方法 235
linux和unix监控 236
进程活动 237
内存利用率241
磁盘利用率243
网络活动 246
常见系统统计信息 248
使用cron自动监控 249
mac os x 监控 249
system profile 250
控制台（console） 252
activity monitor 253
microsoft windows监控 257
windows experience 257
system health report 259
event viewer（事件查看器） 261
reliability monitor 263
the task manager（任务管理器） 264
performance monitor 266
预防性维护监控 267
小结 268
第8章 监控mysql269
什么是性能 270
mysql服务器监控 270
如何显示mysql性能 271
性能监控 271
sql命令 272
mysqladmin实用工具 278
mysql gui工具 279
mysql管理器 280
mysql查询浏览器 289
服务器日志290
第三方工具293
mysql benchmark套件 295
数据库性能 296
测量数据库性能 297
数据库优化的最佳实践 308
提高性能的最佳实践 315
一切都慢 316
慢查询 316
慢应用 316
慢复制 317
小结 317
第9章 监控存储引擎319
myisam 320
优化磁盘存储 320
优化数据库表 320
使用myisam实用工具 321
按索引顺序存储表 323
压缩表 323
对数据表进行碎片整理 323
监控key cache 324
预加载key cache 325
使用多个key cache 325
其他需要考虑的参数 326
innodb 328
使用show engine命令 329
使用innodb监控器 332
监控日志文件 335
监控缓冲池336
监控表空间338
使用information_schema表 338
其他需要考虑的参数 339
小结 340
第10章 复制监控341
开始 341
安装服务器 342
包容性和排他性复制 342
复制线程 344
监控master 346
master的监控命令 346
master的状态变量 349
监控slave 350
slave的监控命令 350
slave的状态变量 353
使用mysql管理器监控复制 354
其他需要考虑的项 356
网络 356
监控和管理slave滞后 356
slave延迟的原因和预防措施 357
小结 358
第11章 复制的故障排除361
什么导致错误发生 362
master上的问题 362
slave上的问题 366
高级复制问题 371
排除复制故障的工具 372
最佳实践 374
了解你的拓扑结构 374
查询所有服务器的状态 376
查看日志 376
检查配置信息 377
有序执行系统关闭 377
在遇到错误后按序执行重启 377
手动执行失败查询 378
常用程序 378
报告复制故障379
小结 380
第12章 保护你的投资383
什么是信息保障 384
信息保障的三个应用 384
信息保障为什么重要 385
信息完整性、灾难恢复及备份的职责 385
高可用性与灾难恢复 386
灾难恢复 386
数据恢复的重要性 391
备份和恢复392
备份实用程序和操作系统级的解决方案 396
innodb hot backup应用 397
物理文件的复制 400
mysqldump工具 402
xtrabackup 404
逻辑卷管理器快照 404
备份方法的比较 409
备份和mysql复制 410
使用复制进行备份和恢复 410
pitr 411
自动备份 418
小结 421
第13章 mysql企业版 423
mysql企业版入门 424
订阅级别 425
安装概述 426
mysql企业组件 427
mysql企业服务器 427
mem 427
mysql产品支持 431
mysql企业版的使用 431
安装 432
修复监控代理问题 433
监控 434
查询分析器440
更多信息 443
小结 443
第三部分 高可用性环境
第14章 云计算解决方案447
什么是云计算448
云架构 450
云计算是一种经济的选择吗 453
云计算实例 454
云计算的好处454
云计算供应商455
aws 456
技术简要概述 457
它是如何工作的 461
amazon cloud工具461
入门 465
使用磁盘 479
接下来怎么做 484
云中的mysql 484
mysql复制和ec2 485
ec2中使用mysql的最佳实践 488
开源云计算 490
小结 491
第15章 mysql集群493
什么是mysql集群 494
术语和组件494
mysql集群和mysql有何不同 495
典型配置 495
mysql集群的特点 496
局部和全局冗余 497
日志处理 498
冗余和分布式数据 498
mysql集群的架构 499
如何存储数据 501
分区 504
事务管理 504
联机操作 505
配置实例 506
入门 507
启动mysql集群 508
集群测试 513
关闭集群 514
达到高可用性514
系统恢复 517
节点恢复 518
复制 518
获得高性能 523
高性能的注意事项 523
高性能的最佳实践 524
小结 527
附录a 复制建议和窍门529
slave停机了，怎么办 529
检查冗长的二进制日志 530
利用复制在表中重建数据 530
基于语句的日志 530
基于行的日志 531
使用mysql proxy来完成多master的复制 531
使用默认的存储引擎 532
mysql cluster 多源（multisource）复制 532
多路（multichannel）复制故障转移 533
使用当前数据库来过滤 533
slave上的列比master上多 534
slave上的列比master上少 535
选择某几列复制到slave 536
复制心跳 537
在环形复制中忽略服务器 538
功能预览：延时复制 538
功能预览：脚本式复制 539
功能预览：oracle算法 540
索引541
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高可用MySQL
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>基于IP的物联网架构、技术与应用
第1部分　架构
第1章　什么是智能物件　1
1.1　智能物件从何而来？　2
1.1.1　嵌入式系统　3
1.1.2　普适计算　5
1.1.3　移动通信　6
1.1.4　遥测技术及机器间通信　7
1.1.5　无线传感器网络和泛在传感器网络　8
1.1.6　移动计算　9
1.1.7　计算机网络　9
1.2　对智能物件的挑战　10
1.2.1　节点级挑战　10
1.2.2　网络级挑战　11
1.2.3　标准化　13
1.2.4　互通性　14
1.3　小结　14
第2章　IP协议架构　17
2.1　引言　17
2.2　从NCP到TCP/IP　17
2.3　基本的TCP/IP架构设计原则　18
2.4　跨层优化的关键问题　21
2.5　IP分层对智能物件网络至关重要的原因　22
2.6　小结　23
第3章　智能物件为什么要采用IP协议　25
3.1　互通性　26
3.2　一个发展中的通用架构　27
3.3　架构的稳定性和普遍性　28
3.4　可扩展性　29
3.5　配置和管理　29
3.6　痕迹小　30
3.7　还有什么其他选择？　31
3.8　为什么网关不好？　31
3.8.1　固有的复杂性　32
3.8.2　灵活性和可扩展性的缺失　32
3.9　小结　32
第4章　用于智能物件网络和物联网的IPv6协议　33
4.1　引言　33
4.2　IPv4地址空间的耗尽　35
4.3　NAT：IPv4地址枯竭的一个(临时)解决方案　39
4.4　架构讨论　39
4.5　小结　41
第5章　路由　43
5.1　IP网络中的路由　43
5.1.1　IP路由和QoS　43
5.1.2　IP路由和网络可靠性　44
5.2　LLN中的路由特性　46
5.3　二层路由vs三层路由　48
5.4　小结　51
第6章　传输协议　53
6.1　UDP　53
6.1.1　尽力而为的数据报传送　53
6.1.2　UDP头　54
6.2　TCP　54
6.2.1　可靠的流传送　55
6.2.2　TCP头　56
6.2.3　TCP选项字段　57
6.2.4　往返时间估算　58
6.2.5　流量控制　58
6.2.6　拥塞控制　58
6.2.7　TCP状态　59
6.3　用于智能物件的UDP　61
6.4　用于智能物件的TCP　61
6.5　小结　62
第7章　服务发现　63
7.1　IP网络中的服务发现　63
7.2　服务发现协议　64
7.2.1　SLP　64
7.2.2　Zeroconf、Rendezvous和Bonjour　65
7.2.3　UPnP　66
7.3　小结　67
第8章　智能物件的安全性　69
8.1 安全的3个属性　69
8.1.1　保密性　70
8.1.2　完整性　70
8.1.3　可用性　70
8.2　通过隐匿实现安全　71
8.3　加密　71
8.4　智能物件的安全机制　73
8.4.1　智能物件的安全策略　73
8.4.2　链路层加密　74
8.5　IP体系架构上的安全机制　74
8.5.1　IPSec　74
8.5.2　TLS　75
8.6　小结　75
第9章　智能物件Web服务　77
9.1　Web服务基本概念　78
9.1.1　常见数据格式　79
9.1.2　表象化状态转变　80
9.2　智能物件Web服务的基本性能　82
9.2.1　实现的复杂度　83
9.2.2　性能　84
9.3　一个智能物件Web服务的例子——PACHUBE　86
9.3.1　交互模型　88
9.3.2　Pachube数据格式　88
9.3.3　HTTP请求　89
9.3.4　HTTP返回代码　89
9.3.5　验证和安全　90
9.3.6　触发器　90
9.4　小结　91
第10章　智能物件网络连接模型　93
10.1　引言　93
10.2　自治型智能物件网络模型　93
10.3　物联网　94
10.4　扩展Internet　94
10.5　小结　97
第2部分　技术
第11章　智能物件的硬件和软件　99
11.1　硬件　99
11.1.1　通信设备　100
11.1.2　微控制器　101
11.1.3　传感器与制动器　102
11.1.4　电源　103
11.1.5　展望：片上系统、印制电路和电子黏土　104
11.2　智能物件软件部分　105
11.2.1　智能物件的操作系统　106
11.2.2　多线程编程与事件驱动编程的比较　110
11.2.3　内存管理　112
11.2.4　展望：宏编程、Java　113
11.3　能量管理　114
11.3.1　无线能量管理机制　115
11.3.2　异步负载循环　116
11.3.3　同步负载循环　117
11.3.4　无线开启时间示例　118
11.4　小结　118
第12章　智能物件的通信机制　121
12.1　智能物件的通信模式　121
12.1.1　一对一通信　122
12.1.2　一对多通信　122
12.1.3　多对一通信　123
12.2　物理通信标准　124
12.3　IEEE 802.15.4标准　125
12.3.1　802.15.4地址　126
12.3.2　802.15.4物理层　127
12.3.3　媒体访问控制(MAC)层　128
12.3.4　802.15.4的帧格式　129
12.3.5　功耗　129
12.4　IEEE 802.11和Wi-Fi　130
12.4.1　网络拓扑和结构　131
12.4.2　物理层　131
12.4.3　媒体访问控制(MAC)层　132
12.4.4　低功耗Wi-Fi　133
12.5　电力线通信(PLC)　134
12.5.1　物理层　135
12.5.2　MAC层　135
12.5.3　功耗　135
12.6　小结　136
第13章　uIP——轻量的IP协议栈　137
13.1　运行原则　138
13.1.1　输入处理　139
13.1.2　输出处理　142
13.1.3　定期处理　143
13.1.4　数据分组转发　143
13.2　uIP内存缓冲器管理　143
13.3　uIP应用程序接口　144
13.4　uIP协议实现　146
13.4.1　IP分段重组　147
13.4.2　TCP　147
13.4.3　校验和计算　148
13.5　内存占用空间　148
13.6　小结　149
第14章　标准化　151
14.1　引言　151
14.2　IETF　151
14.2.1　IETF的目标　152
14.2.2　IETF组织结构　153
14.2.3　IETF标准化过程　153
14.2.4　IETF标准化过程　155
14.2.5　IAB　156
14.3　和智能物件IP有关的工作组　157
14.3.1　基于低功耗无线个域网的IPv6工作组　158
14.3.2　ROLL工作组　160
14.4　小结　163
第15章　智能物件网络中使用IPv6——技术复习　165
15.1　智能物件网络中使用IPv6？　165
15.2　IPv6包的头　166
15.2.1　IPv6固定的头　166
15.2.2　扩展头　167
15.2.3　逐跳选项头　168
15.2.4　路由头　168
15.2.5　分片头　169
15.2.6　目的地选项头　170
15.2.7　无下一个头　171
15.3　IPv6寻址架构　171
15.3.1　单播、任播和多播的概念　171
15.3.2　IPv6地址的表示　171
15.3.3　单播地址　172
15.3.4　任播地址　174
15.3.5　多播地址　174
15.4　IPv6中的ICMP协议　176
15.4.1　ICMPv6错误消息　176
15.4.2　ICMP信息消息　177
15.5　邻居发现协议　177
15.5.1　邻居请求消息　178
15.5.2　邻居通告消息　179
15.5.3　路由器通告消息　179
15.5.4　路由器请求消息　182
15.5.5　重定向消息　182
15.5.6　邻居不可到达检测(NUD)　182
15.6　负载平衡　183
15.7　IPv6自动配置　183
15.7.1　创建链路本地地址　183
15.7.2　无状态自动配置过程　184
15.7.3　IPv6中无状态地址自动配置的隐私扩展　186
15.8　DHCPv6　187
15.8.1　有状态自动配置　187
15.8.2　无状态DHCP　187
15.9　IPv6服务质量　188
15.9.1　Diffserv模型　188
15.9.2　IntServ模型　189
15.10　IPv4骨干网络上的IPv6　189
15.11　IPv6多播　191
15.12　小结　192
第16章　6LoWPAN适配层　193
16.1　术语　193
16.2　6LoWPAN适配层　194
16.2.1　网状寻址头　195
16.2.2　分片　197
16.2.3　6LoWPAN头压缩　198
16.2.4　无状态配置　207
16.3　小结　208
第17章　智能物件网络中的RPL路由　209
17.1　简介　209
17.2　什么是低功耗有损网络？　209
17.3　路由需求　210
17.4　智能物件网络中的路由度量　212
17.4.1　聚集路由度量与记录路由度量　213
17.4.2　本地度量与全局度量　213
17.4.3　路由度量/限制通用头　213
17.4.4　节点状态和属性目标　213
17.4.5　节点能源目标　214
17.4.6　跳数目标　214
17.4.7　吞吐量目标　214
17.4.8　延迟目标　214
17.4.9　链路可靠性目标　214
17.4.10　链路颜色属性　215
17.5　目标功能　215
17.6　RPL：为智能物件网络设计的新的路由协议　217
17.6.1　协议综述　217
17.6.2　多个DODAG的使用和RPL实例的概念　219
17.6.3　RPL消息　221
17.6.4　RPL DODAG创建过程　223
17.6.5　DODAG内部以及DODAG间的节点的移动　225
17.6.6　使用DAO消息沿着DODAG填充路由表　226
17.6.7　RPL中的回路避免和回路检测机制　229
17.6.8　全局和本地修复　231
17.6.9　RPL路由邻接性　234
17.6.10　RPL定时器管理　235
17.6.11　模拟结果　236
17.7　小结　241
第18章　IP智能物件联盟　243
18.1　IPSO联盟的任务和目标　243
18.2　IPSO联盟　244
18.3　IPSO联盟的关键活动之一：互通性测试　245
18.4　小结　247
第19章　非IP智能物件技术　249
19.1　ZigBee　249
19.1.1　ZigBee设备类型　250
19.1.2　ZigBee协议栈的分层　250
19.1.3　物理层和MAC层　251
19.1.4　网络层　251
19.1.5　应用支撑子层　252
19.1.6　应用框架层　252
19.1.7　网络设置　253
19.1.8　ZigBee正在向IP迁移　253
19.2　Z-Wave　254
19.3　小结　254
第3部分　应用
第20章　智能电网　255
20.1　简介　255
20.2　术语　259
20.3　核心网格监视和控制　259
20.3.1　应用案例1：二次变电站的监控　259
20.3.2　应用案例2：变电站状态检修　261
20.3.3　应用案例3：线路动态评分　262
20.3.4　技术特点与挑战　262
20.4　智能计量(NAN)　265
20.4.1　应用和案例　265
20.4.2　网络特征和技术挑战　266
20.5　HAN　267
20.5.1　应用和案例　267
20.5.2　网络特征和技术挑战　270
20.5.3　技术挑战的总结　271
20.6　小结　272
第21章　工业自动化　273
21.1　机遇　273
21.2　挑战　275
21.3　使用案例　276
21.3.1　状态监测　277
21.3.2　无线控制　278
21.3.3　移动办公　279
21.4　小结　280
第22章　智能城市与城市网络　281
22.1　介绍　281
22.2　城市环境监测　282
22.2.1　城市生态环境监测　282
22.2.2　自然灾害检测和预报　284
22.2.3　技术特点和挑战　285
22.3　社会性网络　286
22.3.1　基于Web的社会化网络服务的扩展　287
22.3.2　监测老人和孩子　288
22.3.3　技术特点和挑战　289
22.4　智能交通系统　290
22.4.1　交通监测和控制　291
22.4.2　自动收费/罚款系统　293
22.4.3　技术特点和挑战　294
22.5　小结　294
第23章　家庭自动化　297
23.1　简介　297
23.2　主要应用及案例　298
23.2.1　照明控制　298
23.2.2　安全性和保密性　298
23.2.3　舒适性和便捷性　299
23.2.4　能源管理　299
23.2.5　远程家庭管理　300
23.2.6　老年人生活自理与辅助　300
23.3　技术挑战和网络特征　300
23.3.1　拓扑类型和流量矩阵　301
23.3.2　设备数量　301
23.3.3　移动程度　301
23.3.4　健壮性和可靠性　301
23.3.5　服务质量的要求　302
23.3.6　电池操控　302
23.3.7　运行环境　302
23.3.8　安全性　302
23.3.9　安装和设置的简便性　303
23.4　小结　303
第24章　楼宇自动化　305
24.1　BAS参考模型　305
24.2　新兴楼宇自动化应用　306
24.2.1　入驻和撤离　307
24.2.2　能源管理　307
24.2.3　需求响应　307
24.2.4　防火防烟　307
24.2.5　疏散　308
24.3　现有楼宇自动化系统　308
24.4　楼宇自动化中传感器和制动器的特性　310
24.4.1　区域控制　311
24.4.2　片区控制　312
24.4.3　楼宇控制　312
24.5　新兴的基于智能物件的BAS　313
24.5.1　新兴的传感器、制动器和协议　313
24.5.2　基于IP的企业层协议　314
24.6　小结　314
第25章　建筑物健康监测　315
25.1　简介　315
25.2　主要应用和案例　317
25.3　技术挑战　318
25.3.1　自动配置　318
25.3.2　多播支持　318
25.3.3　路由　319
25.3.4　网络拓扑　319
25.3.5　网络可扩展性　319
25.3.6　移动性　319
25.3.7　链路和设备特性　319
25.3.8　流量特征　320
25.3.9　服务质量　320
25.3.10　安全　320
25.3.11　部署环境　320
25.4　数据采集与分析　320
25.5　未来的应用与展望　321
25.6　小结　321
第26章　集装箱跟踪　323
26.1　GE CommerceGuard　323
26.2　IBM Secure Trade Lane　325
26.3　小结　326
参考文献　327
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>基于IP的物联网架构、技术与应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>支撑处理器的技术
第 1 章  处理器与计算机系统的基础........................................1
1.1 计算机的结构............................. 2
计算机组成部分——处理器、内存、输入/输出设备.......................2
专栏处理器封装的物理结构..................................... 4
计算机使用二进制进行计算..............................4
专栏 2 值和多值非二进制不可吗？不一定！ ........................... 5
处理器——计算机的大脑，负责解释程序........................6
专栏处理器、微处理器的定义计算机最重要的组件——处理器............. 7
专栏流水线级............................. 8
专栏表示数量级的前缀............................ 10
内存——存储计算机的指令和数据........................13
输入/输出设备——计算机的眼睛、耳朵和嘴巴.............................18
北桥和南桥——逐渐淡化的称呼..............................21
1.2 支撑计算机高速化的半导体技术........................... 22
摩尔（Moore）定律——更多的晶体管，更高的并行度................22
缩放定律——晶体管的性能提升................24
源源不断的开发投资带来的半导体微型化——微型化的步伐还将长期维持.........24
提升性能的三大支柱——提高频率、并行处理和功能扩展..........25
1.3 计算机和数据表示方法........................ 26
字节、半字、字……——比特组及用途.........................26
文字编码............................................27
专栏日语与文字编码................................ 28
无符号整数与符号整数、1 的补数表示与2 的补数表示...............29
浮点小数——IEEE 754 标准...........................30
Big Endian 与Little Endian...............................32
1.4 处理器和指令........................... 34VIII
指令架构入门....................................34
机器指令——处理器的指令............................36
地址空间............................................36
专栏 AMD 和Intel 的64 位扩展架构.......................... 38
1.5 机器指令程序编写方法......................... 39
用汇编语言编程................................39
利用编译器进行高级语言编程................................40
解释语言编程....................................41
1.6 小结............................................. 43
专栏 半导体的微型化................................ 44
第2 章  处理器发展史......................................46
2.1 计算机之前的计算设备.............................. 47
算盘——最早的计算工具................................48
纳皮尔算筹（Napier's bones）——乘法辅助工具............................49
机械式计算机——Schikard 计算机、Pascaline ............50
巴贝奇的差分机——使用齿轮的超级计算机...................................52
2.2 最早的电子计算机................................. 53
最早的电子计算机——ABC 和ENIAC .................53
FUJIC——日本最早的电子计算机.....................54
2.3 处理器组成元件的变迁......................... 55
根据主要部件划分计算机的时代............................55
第1 代：真空管................................55
第2 代：晶体管................................56
第3 代：集成电路............................57
第4 代：大规模集成电路（VLSI） ...........................58
VLSI 处理器的元件数目和时钟频率的发展趋势............................61
2.4 指令架构的变迁...................................... 62
指令架构的发展之路........................62
存储程序的计算机——程序也从内存中读入...................................63
虚拟内存——更加丰富、取之不尽的内存.................64
多处理——需要改变程序的部署...............................66
TSS 与内存管理设施的登场............................67
专栏 MULTICS 之后的事.......................... 68
内存管理设施、特权管理——多用户需要解决安全问题..............68
ISA 扩展——指令架构的确立与指令兼容性的实现.......................69
2.5 微架构的发展........................... 70
微架构的发展之道............................70
流水线处理——通过流水线寄存器有效利用硬件..........................72
运算器的高速化——整数运算器、浮点数运算器..........................73
缓存——解决内存访问问题的锦囊...........................74
RISC 的出现——RISC 与CISC ...........................76
超标量执行——一个周期内执行多条指令.................. 77
乱序执行——改变指令顺序以提高性能...................78
专栏乱序执行（Out of Order）：请注意！？ ............................. 80
分支预测与投机执行——“条件分支指令”对策..........................80
多核心——耗电量的限制推动了多核心的发展..............................81
2.6 处理器的用途越来越广泛................................. 82
活跃在各种舞台的处理器................................82
节能、高可靠技术、实时性——各种各样的需求..........................83
2.7 小结............................................. 83
第 3 章 ［详解］面向编程员的处理器架构................................86
3.1 支撑微架构的技术................................. 87
流水线执行的原理——并行处理指令......................87
缓存的构造——提高内存访问速度.........................99
RISC 与CISC——定长指令与变长指令............................ 112
提高运算器的速度——处理器中因处理复杂而处理时间长的组件之一........... 116
超标量执行的原理——一个周期内并行执行多条指令................126
乱序执行的原理——减轻数据灾难的影响......................128
分支预测的原理——降低控制灾难造成的损失............................134
现代处理器会消除或减轻各种灾难以提高性能............................140
内存、I/O 与输入/输出接口..........................141
性能计数器——性能分析器和处理器内部执行状况的信息........147
3.2 架构扩展扩大了处理器的使用范围.................................. 149
多程序和内存管理设施..................................149
中断处理设施..................................155X
专栏异常、中断、陷阱——术语整理.......................................159
虚拟化支持——内存访问和内存管理设施..................................160
多媒体、加密等支持——需要大量数据的计算............................162
3.3 x86 Nehalem 架构处理器............................. 167
x86 的指令体系和Intel 64 架构.................................167
Core i7 处理器的结构.....................................175
内存管理采用4 级表......................................180
新的处理器接口QPI ......................................184
3.4 小结........................................... 185
第 4 章  虚拟化支持.........................188
4.1 虚拟化的目的和优缺点............................. 189
虚拟化的基础知识（复习）..........................189
虚拟化的目的..................................190
实现用户间强隔离——虚拟化的优点........................................190
集合多台服务器，提高运行率——虚拟化的优点...................191
VMM 运行时的额外开销——虚拟化的缺点、注意点.................193
4.2 实现虚拟化的条件............................... 194
为操作系统提供独立的（虚拟）硬件的VMM.............................195
4.3 支撑虚拟化的硬件设施............................ 196
检测硬件操作命令..........................196
硬件状态的保存和还原——切换虚拟机.................198
双重地址转换、TLB ......................................199
I/O 的虚拟化....................................203
实时迁移（Live Migration） ...............................207
4.4 小结........................................... 208
专栏 虚拟化的前世今生...........................209
第5 章  多处理器的出现和普及..........................211
5.1 多线程处理器......................... 212
线程、多线程的纷繁芜杂（!?）——首先总结一下术语..............212
多线程的两种方式..........................213
VMT 的原理——短时间内切换线程......................214
SMT 的原理——混杂执行多个线程的指令...................................216
专栏历史悠久的SMT .............................216
SMT 必需的机制.........................217
多线程的效果如何——通过Windows 任务管理器查看效果.......219
5.2 多处理器系统......................... 222
多处理器、多核心是什么意思........................222
多核心处理器的结构......................................223
专栏超多核心处理器（Many-core processor）的结构..............224
缓存一致性控制——多处理器之间缓存的一致性........................225
多插槽系统......................................231
专栏插槽还是芯片..................................234
专栏多核心时代的处理器、CPU 的含义..................................236
提高多处理器系统的性能——问题和解决方案............................238
共享内存系统和分布式内存系统...........................244
5.3 小结........................................... 246
第 6 章  处理器周边技术...............................249
6.1 内存技术.................................. 250
内存历史概览..................................250
DRAM 内存的工作原理——利用电荷存储信息...........................251
DRAM 芯片和内存DIMM............................254
DRAM 芯片的内部结构——内存单元阵列、行/列解码器、检测放大器、Bank ........256
处理器和DIMM 的连接................................258
内存系统的错误处理......................................259
6.2 连接输入/输出设备.............................. 265
处理器的I/O 连接...........................265
PCI 总线...........................................266
专栏通向 PCI 总线之路..........................267
Intel Core i 系列处理器的I/O 结构......................272
Intel PCH 的I/O 控制结构.............................273
6.3 小结........................................... 273
专栏 DRAM的刷新.................................274
第7 章 GPGPU 和超并行处理...............................276
7.1 GPGPU 的原理...................................... 277
3D 图形和GPU——需要大量计算..........................277
GPU 系统.........................................279
从GPU 到GPGPU..........................280
作为“超并行SIMD 处理器”的GPGPU......................................281
作为“超多线程处理器”的GPGPU........................283
专栏 Warp！ .............................284
GPGPU 的内存层次结构................................285
GPGPU 中的多线程需要分割使用通用寄存器..............................287
CPU 和GPGPU 的巨大不同..........................288
7.2 GPGPU 编程........................... 289
现代 GPGPU 编程...........................290
CUDA 的运行模型——线程块、网格..........................290
CUDA 中的函数声明和变量声明...............................292
OpenCL 编程...................................293
如何发挥GPGPU 的性能...............................295
7.3 小结........................................... 303
专栏 Top500 和GPU 计算....................................304
第 8 章 处理器的发展趋势..........................306
8.1 耗电量是万恶之源............................... 307
为何处理器要消耗电力..................................307
节能技术的发展..............................310
8.2 更高、更快、更强............................... 313
半导体微型化技术..........................314
如何有效利用增加的晶体管..........................315
利用部分晶体管降低生产成本....................................316
有效利用部分块不合格的芯片.........................................318
8.3 更可靠、更安全的处理器设计................ 320
为何处理器会有错误行为——故障、噪声.............................320
防止错误行为，确保安全运转......................................322
8.4 未来处理器的发展方向...................................... 323
无处不在的处理器..........................324
家电用处理器..................................324
汽车用处理器..................................324
个人计算机用处理器................................................325
智能手机用处理器..........................325
服务器用处理器..............................327
8.5 小结........................................... 329
索引...........................................................331
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>支撑处理器的技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>用Mesos框架构建分布式应用
序  ix
第1 章 Mesos 介绍 1
如何使用Mesos2
Mesos 作为部署系统 3
Mesos 作为执行平台 4
本书是如何组织的4
本章小结 5
第2 章 开启Mesos 之旅 7
框架7
Master 和Slave 8
Master8
Slave 10
资源13
配置自定义资源 15
配置slave 属性16
角色16
静态和动态slave 预留 17
任务和执行器 20
CommandExecutor 21
理解mesos.proto 21
不通过Mesos 管理 24
本章小结 25
第3 章 将已有应用程序迁移到Mesos 上27
将Web 应用程序迁移到Mesos 上27
搭建Marathon 28
使用Marathon 30
扩展应用程序 35
使用位置约束 35
运行容器化的应用程序37
挂载主机卷38
健康检查40
应用版本化和滚动升级42
事件总线43
搭建Marathon 上的HAProxy43
在Marathon 上运行Mesos 框架 47
Chronos 是什么47
在Marathon 上运行Chronos48
Chronos 运维注意事项 49
Marathon 上的Chronos ：小结 50
Marathon+Chronos 的备选方案50
Singularity50
Aurora51
本章小结 51
第4 章 为Mesos 创建新的框架53
调度器 53
服务器池调度器 54
工作队列调度器 54
作业处理器调度器 55
没什么用的远程BASH 56
实现基本的作业处理器 62
将任务匹配到Offer 上65
搭建Offers 和Jobs 之间语义差别的桥梁68
增加高可用性 70
添加核对 76
高级调度器技术77
分布式通信78
强制故障转移 79
合并Offer79
加固调度器80
检查点82
CommandInfo 83
启动进程83
配置进程环境 83
本章小结 84
第5 章 构建Mesos 执行器85
执行器 85
构建工作队列worker 86
运行pickled 任务 86
共享资源86
更好地看护87
增强的日志88
重写CommandExecutor88
引导执行器的安装97
添加心跳 99
高级执行器特性 102
进度报告 103
添加远程日志  104
多个任务 104
本章小结  106
第6 章 Mesos 的进阶主题 107
libprocess 和actor 模型  107
一致性模型  108
如何处理slave 的故障  109
如何处理master（或者registry）的故障 110
故障转移期间的核对 111
容器机  112
使用Docker. 113
新的Offer API 114
框架动态预留API 114
数据库使用的持久化卷 118
本章小结  119
第7 章 Mesos 的未来121
多租户工作负载 121
超配 123
数据库和Turnkey 基础架构  125
基于容器的IP  125
本章小结  126
索引 129
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>用Mesos框架构建分布式应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>管理经济学与组织架构（第4版）
第一编　基本概念　1
第1章　导　论　3
第2章　关于行为的经济学家观点　15
第3章　市场、组织以及知识的作用　41
第二编　管理经济学　75
第4章　需　求　77
第5章　生产和成本　104
第6章　市场结构　131
第7章　具有市场控制力的定价　154
第8章　战略经济学：创造和获取价值　181
第9章　战略经济学：博弈论　218
第10章　激励冲突与合约　241
第三编　设计组织架构　263
第11章　组织架构　265
第12章　决策权：授权程度　285
第13章　决策权：组合任务形成工作和子单元　310
第14章　吸引和留住合格的员工　329
第15章　激励性薪酬　357
第16章　个人绩效评估　381
第17章　部门绩效评估　406
第四编　组织架构的应用　433
第18章　公司治理　435
第19章　纵向一体化与外包　465
第20章　领导：激发组织内变革　494
第21章　理解经营环境：管制经济学　515
第22章　道德与组织架构　541
第23章　组织架构与管理创新过程　565
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>管理经济学与组织架构（第4版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Serverless架构：无服务器单页应用开发
第1 章 从简单开始  1
无服Web 应用 2
-- 无服设计的好处  4
-- 无服设计的限制  6
使用自己的工作空间  8
-- 本地执行  12
-- 创建着陆页  13
部署到Amazon S3 15
-- 搭建AWS 命令行接口  16
-- 创建一个带访问密钥的AWS 用户  17
首次部署  20
-- 下一步 21
第2 章 基于hash 事件的视图路由  23
设计可测试的路由器  24
-- 运行Jasmine 测试  25
-- 编写第一个测试用例 26
路由函数  29
-- 创建命名空间 29
-- 添加路由函数 30
-- 创建视图容器 32
添加路由  34
添加视图参数  37
-- 用spy 测试调用 37
-- 处理视图函数中的参数  39
-- 加载应用  41
-- 响应事件  42
-- 响应hash 事件  44
再次部署  46
-- 下一步 46
第3 章 单页应用的必要组件 49
创建视图  50
定义数据模型  53
-- 数据绑定  55
-- 优化数据模型 58
处理用户输入  60
-- 有效地使用视觉反馈 64
-- 控制导航  66
创建一个应用外壳 68
-- 提取着陆页  68
-- 添加工具条  69
使用自定义事件  72
再次部署  75
-- 下一步 75
第4 章 基于Amazon Cognito 的认证服务 77
接入外部身份认证服务商 78
创建身份池 82
-- 身份池配置  83
-- IAM 角色和策略  84
获取Google 身份. 87
请求AWS 证书 90
-- 刷新令牌  91
-- 基于Deferred 对象和Promise 的认证请求  93
-- 创建一个身份Deferred 对象 95
创建个人主页视图 96
再次部署  98
-- 下一步 99
第5 章 使用DynamoDB 存储数据 101
使用DynamoDB  102
-- 理解DynamoDB 的键和哈希 102
-- DynamoDB 用作文档数据库  103
-- 强一致性和最终一致性 105
创建表 106
-- 属性和键值  108
-- 预设吞吐量  109
-- 二级索引与查询 vs 扫描 110
授权访问DynamoDB 111
保存文档  113
-- 一个fail-safe 的数据访问函数  114
-- 创建和保存一个item  115
读取文档  117
数据访问和验证  119
重新部署  122
-- 下一步  122
第6 章 使用Lambda 构建微服务  125
理解Amazon Lambda 126
-- Lambda 环境 126
-- Lambda 的局限  128
-- 内存、时间和费用  129
先部署 130
-- 配置一个Lambda 函数  131
-- 创建代码包  133
-- 通过AWS 控制台测试函数 134
-- 创建一个新的Lambda 配置  135
-- 往Lambda 执行角色上添加策略 136
编写Lambda 函数  138
-- 规避微服务架构问题  138
-- 添加服务依赖  140
-- 构建可测试的服务  141
-- 查询、分组和分页  143
调用Lambda 函数  145
使用Amazon API 网关  146
重新部署  148
-- 下一步  148
第7 章 无服应用的安全  151
保护你的AWS 账号  152
-- 禁用所有root 访问密钥 152
-- 管理用户配置  152
-- 保护AWS 证书  153
-- 设置多重身份认证  154
查询注入攻击 154
跨站脚本攻击 156
-- XSS 注入方法  156
-- 使用web worker 沙盒化JavaScript 157
跨站请求伪造 159
-- 不用Javascript 实现XSRF  160
-- 跨站请求和同源策略  161
线路攻击和传输层安全  162
-- Sidejacking 攻击 162
-- 高效使用HTTPS  163
拒绝服务攻击 165
-- 用CloudFront 保护S3 165
-- 可扩展服务和用户身份 166
重新部署  167
-- 下一步  167
第8 章 扩容  169
监控Web 服务  169
-- 监控容量限制  170
-- 创建付款警告  173
分析S3 的流量  174
-- 记录S3 请求 174
-- 分析S3 日志 177
-- 响应代码频率  179
-- 热门资源 180
-- 每日用量 181
优化应用，实现增长 182
-- 通过缓存降低成本和加载时间 183
-- 通过带版本号的文件名清除缓存  186
云的成本  187
-- 加载成本 188
-- 数据成本 188
-- 微服务成本  189
-- 加起来  190
再次部署  192
-- 下一步 192
附录A 安装Node.js  195
安装Node.js 运行时  195
-- Linux  195
-- OS X  196
-- Windows  196
管理多个Node.js 版本  197
附录B 分配一个域名 199
参考书目 201
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Serverless架构：无服务器单页应用开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>内容分发网络（CDN） 关键技术、架构与应用
第一部分　内容分发网络(CDN)技术
第1章　内容分发网络技术发展与基本原理　3
1.1　CDN的基本概念和产生背景　3
1.2　CDN发展历史　5
1.3　互联网用户访问模型　8
1.4　内容分发基本原理　10
1.4.1　基于PULL的分发机制　10
1.4.2　基于PUSH的分发机制　11
1.4.3　混合分发机制　12
第2章　内容分发网络关键技术　13
2.1　IPTV业务服务流程示例　13
2.2　内容分发网络关键技术　14
2.3　内容统一ID　17
2.3.1　统一资源定位符　17
2.3.2　CDN内容统一ID　17
2.4　用户请求重定向调度　18
2.4.1　设计原则　19
2.4.2　基于DNS重定向　19
2.4.3　基于网络就近性判断　20
2.4.4　用户请求重定向调度方式对比　21
2.5　负载均衡技术　22
2.5.1　什么是负载均衡　22
2.5.2　负载均衡的原理　23
2.5.3　负载均衡的实现层次　24
2.5.4　负载均衡的技术分类　25
2.5.5　负载均衡的算法　26
2.6　缓存替换算法　28
2.6.1　CDN缓存替换概述　28
2.6.2　CDN缓存算法介绍　29
2.6.3　缓存算法的比较　33
2.7　媒体服务　33
2.7.1　网页加速　33
2.7.2　流媒体服务　37
2.7.3　文件传输加速　44
2.7.4　应用协议加速　45
第3章　CDN主要技术指标　46
3.1　服务指标　46
3.1.1　命中率　46
3.1.2　吞吐量　48
3.1.3　并发值　48
3.1.4　响应时间　49
3.1.5　MDI　50
3.1.6　MOS　51
3.2　CDN服务指标测试方法　52
3.2.1　功能测试　52
3.2.2　性能测试　53
3.2.3　功耗测试　59
3.2.4　稳定性测试　60
第4章　CDN硬件　61
4.1　CDN硬件发展　61
4.1.1　CDN硬件的种类　61
4.1.2　专用硬件的发展　66
4.1.3　通用硬件的发展　67
4.1.4　技术和行业特点　103
4.2　CDN硬件的选型　106
4.2.1　主要考虑的关键因素　106
4.2.2　关键硬件的选型　108
4.2.3　几类服务器选型　108
4.2.4　硬件选型的趋势　112
第5章　CDN标准化　114
5.1　CDN标准化概述　114
5.2　CDN域内标准化　116
5.2.1　CDN域内标准化主要方向　116
5.2.2　YD/T 2366——2011标准介绍　118
5.2.3　YD/T 2366——2011CDN系统模块组成　119
5.3　CDN域间标准化　121
5.3.1　CDN互联互通架构探讨　121
5.3.2　CDN互联互通关键技术　124
第6章　CDN与P2P结合　126
6.1　P2P网络介绍　126
6.2　CDN与P2P融合的技术特点　128
6.3　CDN与P2P的融合模式　129
6.3.1　上层CDN下层P2P分发模式　129
6.3.2　CDN节点作为P2P的补偿节点　130
第7章　CDN云化　131
7.1　CDN云化的意义　131
7.1.1　云计算与云存储介绍　131
7.1.2　发展云计算是电信运营商的迫切需求　132
7.1.3　国内外CDN云化的研究和发展现状　132
7.1.4　从商业模式看CDN与云计算　133
7.2　CDN与云计算的技术结合　134
7.2.1　CDN与云计算　134
7.2.2　CDN与云存储　136
第二部分　内容分发网络(CDN)架构设计与部署
第8章　CDN需求分析　139
8.1　业务需求　139
8.1.1　高带宽视频业务对CDN的需求　139
8.1.2　多屏、多格式的内容对CDN的需求　140
8.1.3　业务功能要求　140
8.2　技术需求　141
8.3　扩展与安全性需求　141
第9章　CDN总体架构　142
9.1　CDN架构发展历程　142
9.2　CDN技术发展趋势　145
9.2.1　CDN融合承载发展趋势　145
9.2.2　CDN能力管道化趋势　146
9.2.3　CDN能力与媒体无关趋势　146
9.2.4　CDN硬件能力快速提高趋势　147
9.2.5　CDN与转码系统有机结合趋势　147
9.2.6　CDN与网络结合的调度优化趋势　148
9.3　CDN总体架构设计　148
9.3.1　CDN逻辑平面　148
9.3.2　CDN控制与分发平面设计　149
9.3.3　中国电信融合CDN架构　150
9.4　CDN主要功能模块　152
9.4.1　内容库　152
9.4.2　缓存功能模块　154
9.4.3　媒体服务功能模块　154
9.4.4　运营管理功能模块　155
9.4.5　用户请求路由功能模块　155
第10章　CDN部署方案　156
10.1　CDN冗余与备份设计　156
10.2　节点部署方案　158
第11章　CDN与视频提升技术　160
11.1　IPTV差错控制技术　161
11.1.1　ARQ技术原理　161
11.1.2　FEC技术原理　163
11.2　快速频道切换技术(FCC)　168
11.2.1　典型的频道切换时延　168
11.2.2　快速频道切换原理　171
第12章　CDN网络管理　173
12.1　概述　173
12.2　系统架构　174
12.3　功能模块　174
12.4　业务管理　175
12.4.1　节点管理　175
12.4.2　内容注入　176
12.4.3　内容管理　176
12.4.4　调度管理　182
12.5　网络管理　183
12.5.1　拓扑管理　183
12.5.2　配置管理　184
12.5.3　告警管理　184
12.5.4　性能管理　186
12.5.5　日志管理　187
12.5.6　资源管理　187
12.6　服务统计　187
12.6.1　数据要求　187
12.6.2　统计输出　188
12.7　安全管理　189
12.7.1　系统账号管理　189
12.7.2　访问列表管理　189
第13章　CDN承载网络部署方案　190
13.1　CDN与IP网协同　190
13.1.1　CDN网络部署　190
13.1.2　应用层流量优化(ALTO)　192
13.1.3　DECADE　195
13.2　CDN的IPv6部署方案　196
13.2.1　IPv6网络过渡方案　196
13.2.2　IPv4向IPv6过渡的基本技术　197
13.2.3　CDN的IPv6部署方案　199
第14章　自适应流媒体方案　201
14.1　RTSP自适应流媒体　201
14.2　HTTP自适应流媒体　202
14.2.1　Apple Http Live Streaming　203
14.2.2　Microsoft Http Smooth Streaming　205
14.2.3　Adobe Http Dynamic Streaming　207
14.3　CDN承载方案　208
14.3.1　透明传输方案　208
14.3.2　优化方案　210
第三部分　内容分发网络(CDN)应用
第15章　CDN主要应用　215
15.1　IPTV CDN应用　215
15.1.1　IPTV业务简介　215
15.1.2　IPTV业务产业链　216
15.1.3　国内外IPTV发展趋势　217
15.1.4　IPTV技术标准发展　219
15.1.5　IPTV系统架构　223
15.1.6　IPTV技术动态　227
15.1.7　IPTV CDN架构示例　231
15.2　OTT CDN应用　233
15.2.1　OTT CDN技术特征　233
15.2.2　OTT对产业链的影响　236
15.2.3　OTT CDN与IPTV CDN的区别　236
15.3　Web CDN应用　237
15.3.1　Web网页介绍　237
15.3.2　Web CDN与视频CDN的区别　238
15.4　CDN透明缓存应用　239
15.4.1　透明缓存技术　239
15.4.2　CDN透明缓存应用　240
15.4.3　实现原理　242
15.5　云CDN应用　246
15.5.1　CDN与云计算的结合　246
15.5.2　CDN与云存储的结合　248
第16章　主要CDN产品介绍　250
16.1　中兴通讯CDN产品　250
16.1.1　中兴通讯高性能CDN产品VS8000H　250
16.1.2　中兴通讯高性能CDN产品VS3000　252
16.2　华为公司StreamXP 5100流媒体服务器产品　255
16.2.1　产品特点　255
16.2.2　产品介绍　256
16.3　Cisco CDN产品　259
16.3.1　Cisco产品特点　260
16.3.2　Cisco CDN产品性能　261
16.3.3　Cisco CDN产品介绍　262
16.4　青牛CDN产品介绍　265
16.4.1　产品特点　265
16.4.2　产品介绍　266
参考文献　271
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>内容分发网络（CDN） 关键技术、架构与应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>尽在双11：阿里巴巴技术演进与超越
序一  IX
序二  X
双11大事年表  XII
引言  XIII
第1章 阿里技术架构演进  1
双11是阿里技术发展的强大驱动力，双11业务的快速发展造就了阿里具备高度水平伸缩能力、低成本的电商架构体系。这个架构体系是如何一步一步形成的呢？在形成过程中阿里遇到了哪些问题，做了哪些尝试，最终用什么样的思路、方法和技术解决了问题？
1.1 五彩石，电商架构新起点  3
1.2 异地多活，解除单地域部署限制的新型双11扩容方式  9
1.3混合云，利用阿里云弹性大幅降低双11成本  17
1.4 OceanBase，云时代的关系数据库  23
1.5 手机淘宝，移动互联网电商新时代  30
1.6 蚂蚁技术架构演进  36
第2章 稳定，双11的生命线  43
双11最大的困难在于零点峰值的稳定性保障。面对这种世界级的场景、独一无二的挑战，阿里建设了大量高可用技术产品，形成了全链路一体化的解决方案，用更加逼真和自动化的方式，去评估、优化和保护整个技术链条，最大化地为用户提供稳定可靠的服务。
2.1 容量规划，资源分配的指南针  45
2.2 全链路压测，大促备战的核武器  51
2.3 全链路功能，提前开始的狂欢盛宴  58
2.4 自动化备战，喝着咖啡搞大促  65
2.5 实时业务审计，从系统可用到业务正确  70
2.6 故障演练，系统健壮性的探测仪  75
2.7 系统自我保护，稳定性的最后一道屏障  82
第3章 技术拓展商业边界  89
双11业务驱动技术发展的同时，技术的创新与发展也不断推动着商业模式的升级与变革，实践着技术拓展商业的边界。
3.1 招商报名，活动基础设施建设  91
3.2 会场，小二与商家共同打造的购物清单  99
3.3 搜索，大促场景下智能化演进之路  107
3.4 个性化推荐，大数据和智能时代的新航路  114
3.5 供应链，从飞速增长到精耕细作  120
3.6 蚂蚁花呗，无忧支付的完美体验  127
第4章 移动端的技术创新之路  133
从2010年开始，国内爆发了从PC向移动端技术和业务的持续迁移，移动深刻地改变着人们的衣食住行和人际交往。阿里的双11始于2009年，正好经历了移动互联网崛起的全程，双11在移动端的主要创新有哪些呢？
4.1 Weex，让双11更流畅  135
4.2 互动，让购物变成狂欢  143
4.3 VR&AR，移动端创新体验  153
4.4 奥创&TMF，让双11多端业务腾飞  163
第5章 繁荣生态，赋能商家  171
双11从阿里内部员工的一个点子到全球购物狂欢节，其背后支撑是服务、物流、大数据、云计算、金融服务等，是商家自身业务结构的调整、消费者消费习惯的转变、第三方开发者的大量入驻，以及整个生态的变迁。
5.1 聚石塔，开放的电商云工作台  173
5.2 菜鸟电子面单，大数据改变物流  179
5.3 生意参谋，数据赋能商家的“黑科技”  184
5.4 阿里小蜜，用智能重新定义服务  191
5.5 阿里中间件，让传统企业插上互联网的翅膀  198
5.6 蚂蚁金服，金融机构间协同运维的探索和实践  205
展望  213
索引  216
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>尽在双11：阿里巴巴技术演进与超越
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>設計的精髓
各界推薦
前言：多看、多問，然後提出批判
第一章 剖析蘋果（Apple）的產品設計
分解MacBook Air
夢幻的Mac OS
Macintosh Plus開啟的每一天
操作iPhone得心應手的小寶寶
蘋果（Apple）、戴森（Dyson），各自的理想主義
討厭梯形的史帝夫‧賈伯斯（Steve Jobs）
產品愈薄，重量愈重
iPhone3G機體的祕密
第二章　將設計科學化
設計聲音
機器人的基因
雨打在身上為什麼不會痛
高低差
想念太陽
客機全長和馬桶尺寸
空氣乾燥
螺旋與節
彈性與黏滯
斑點圖案的數學原理
水的形狀中隱藏的數學
科學思考和（0_0）
輪胎胎紋的圖案並非固定
立體影像與３Ｄ體驗的差異
藍天有多大
真正地壓迫胸部
一再分離或相遇
年輪是從外側生長
高能量描繪出的巨幅畫作
Suica（西瓜卡）的判讀角度是這樣定出來的：其一
Suica（西瓜卡）的判讀角度是這樣定出來的：其二
開始航太設計
桌燈Tolomeo：建築師與照明技師的共同創作
第三章　將概念具體成形
會呼吸的椅子
並不是模仿鯊魚的牙齒
手錶INSETTO商品化的過程：其一
手錶INSETTO商品化的過程：其二
手錶INSETTO商品化的過程：其三
Ｆ計畫：與小山薰堂、猪子壽之合作
設計師，這麼急是要趕去哪裡？
Ｆ計畫：圓規和鑰匙孔
行動電話的基因
平靜順暢的流程
從日產汽車（Nissan Motor）辭職的原因
日產TRI-X：聚集兩百萬人次的東京車展
TRY-Z：JR東日本E991在來線高速實驗車、Kumoya E911
非勞動式機器人
未來預測圖
製作曲面
孤獨的時間
tagtype鍵盤成為MoMA的永久館藏：其一
tagtype鍵盤成為MoMA的永久館藏：其二
必須自己駕駛車輛的時代
遺珠模型追思會之一：向徠卡（Leica）致敬
遺珠模型追思會之二：妖怪椅子
纖細柔軟的武術專家
加油！Willcom：其一
加油！Willcom：其二
以「簡單對話」為名的W-SIM一號機
第四章　從素描開始
不可以刻意想畫出形體
橢圓形
四腳雞
素描裡的動感
水、紙和顏料構成的小宇宙
忘不了的慢速側投
寒武紀的素描
沒能留下來的嶄新創意
從正上方俯瞰的威瓦西亞蟲
覺得「讓我來吧！」的時刻
在活動現場畫圖
習以為常的事物愈困難
第五章　從製作的第一線思考
只有剖面可以自由發展
設計與計算：想憑藉體感還要三一五年
腦內尺度
火柴盒小汽車並非實車的縮小版
巨無霸客機中隱含的美學
深澤直人的梯形
愛的漸開線齒輪
不需要圖稿
由水而生，回歸於水
乘著風，寄託生命
一定要這家公司來做
水與木漿的離別與相會
第六章　人與人的相遇
攝影家清水行雄的雙眼
義肢裝具師臼井二美男
明和電機的土佐信道
Team Lab的猪子壽之
機器人博士古田貴之
MIT Media Lab的石井裕
設計「好喝牛奶」的佐藤卓
表現研究家佐藤雅彥
設計師吉岡德仁
第七章　了解「骨架」
取名為Stem（莖）的零件
傀儡人偶的操作方式
找出符合感覺的詞彙吧
便利和美感
清水行雄與玉屋庄兵衛
傳承的創意
促成「骨」展的賽克洛斯
汙泥中綻放的一枝花
人工造型物的骨架
第八章　探尋人體的奧祕
跑就是跳
一群刀鋒跑者
成為幾萬人的腳
現場測試
讓學生看著我的示範教學時
閱讀《徒具形式的愛》
肌肉彈性
腦內錄音機
第九章　畫漫畫，讀漫畫
二選一之外的選擇
將漫畫推廣到全球的原動力
寺田寅彥的「漫畫與科學」
膠墨筆和面相筆
浦澤直樹的《PLUTO》
附錄
關於漫畫〈Hull+Halluc-II〉
漫畫〈Hull+Halluc-II〉
作者簡介
圖片版權聲明
圖片索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>設計的精髓
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>四宮格目標筆記
前言 開啟行動革新
拖延所得到的好處
拖延所得到的壞處
擺脫拖延的惡性循環
第一章 如何設定目標
閱讀第一章之前
光靠集中精神和努力並無法克服拖延的壞習慣
將未來，從過去的延長線上脫離
從未來開始倒數
立下華麗目標，打開行動的開關
這樣的目標，會讓人想要不斷地拖延
開始寫下腦海中浮現的目標
寫下目標的重點1不要質疑夢想和目標
寫下目標的重點2順著自己的欲望
寫下目標的重點3就算只有享樂，沒有責任也可以
寫下目標的重點4首先，量比質重要
寫下目標的重點5寫下煩惱或問題
驚人的目標必須是「可以清楚地想像的」事情
不可將驚人的目標當作目的
在六個領域大躍進
七個問題確定目標
第二章 靠著行動革新煥然一新
閱讀第二章之前
讓人朝著目標展開行動
將驚人的目標寫在筆記本的最前面
製作一個每次看都會興奮不已的「目標頁
只要三分鐘，就能執行四宮格目標筆記
如果習慣在晚上完成是也很棒
第三章 四宮格目標筆記的三個實際案例
閱讀第三章之前
M小姐的個案（任職於知名機器製造商負責事務工作、34歲、女性）
設立驚人的目標
實踐十秒行動
H先生的個案（任職於大型IT企業企劃開發部門、29歲、男性）
設立驚人的目標
十秒行動的實踐
T先生的個案（任職於教育相關事業人事部、41歲、男性）
設定驚人的目標
十秒行動的實踐
第四章 讓四宮格目標筆記持之以恒的妙招
閱讀第四章之前
十秒行動不要想太多
持續一個禮拜時「給自己一點獎勵
就算無法做到十秒行動，也不要責備自己
擬定計畫ABC
習慣拖延的人，最常掛在嘴上的七個口頭禪
縮小刻度來思考
開始拖延「筆記」，該怎麼辦？
安排報告會
沒有多餘時間十秒行動時，該如何重新開始？
提升十秒行動的等級
就算沒能立刻立竿見影，也不要放棄
結 語 找到自我的生活
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>四宮格目標筆記
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>网络功能虚拟化
第1章　NFV概述	1
1．1　NFV概况　1
1．1．1　NFV的发展背景　1
1．1．2　NFV的优势　3
1．1．3　NFV组织　4
1．1．4　NFV行业发展概况　8
1．2　NFV特性　9
1．2．1　可移植性　9
1．2．2　性能　9
1．2．3　伸缩　10
1．2．4　弹性和稳定性　10
1．2．5　安全　11
1．2．6　服务持续性　11
1．2．7　管理和编排　12
1．2．8　多厂商间的互操作性　12
1．2．9　可操作性　12
1．2．10　能源效率　12
1．2．11　兼容性　12
1．3　NFV技术基础　12
1．3．1　标准服务器　12
1．3．2　虚拟化技术　13
1．3．3　云计算　14
1．3．4　软件定义网络（SDN）　15
1．3．5　开源软件　16
1．4　NFV挑战　17
1．4．1　性能问题　17
1．4．2　虚拟网络功能间的连接问题　17
1．4．3　网络安全问题　18
1．4．4　NFV的标准问题　18
1．4．5　系统集成问题　19
1．4．6　运营商业务引入NFV问题　19
第2章　NFV体系架构　20
2．1　NFV设计目标　20
2．2　NFV系统结构　22
2．3　NFV参考架构　23
2．3．1　NFVI　23
2．3．2　VNF　24
2．3．3　NFV MANO　26
2．3．4　服务、VNF以及基础设施描述符　29
2．3．5　EM　29
2．3．6　OSS/BSS　30
2．3．7　参考点　30
2．4　网络功能虚拟化　33
2．4．1　网络功能虚拟化的实现　33
2．4．2　VFBs映射到HFBs的功能块方法　35
2．5　NFV域　37
2．6　NFVI域　39
2．6．1　NFVI目标　39
2．6．2　NFVI域　40
2．7　NFVI和云计算　43
2．7．1　云计算的基本特征应用于NFVI　43
2．7．2　云计算的服务模式应用于NFVI　45
2．7．3　云部署模型应用于NFVI　45
第3章　SDN与OpenDaylight　47
3．1　SDN架构　47
3．1．1　数据转发层　48
3．1．2　控制层　49
3．1．3　应用层　50
3．2　SDN控制器　51
3．2．1　NOX/POX　51
3．2．2　Floodlight　52
3．2．3　Ryu　52
3．2．4　OpenContrail　52
3．2．5　OpenDaylight　52
3．2．6　ONOS　53
3．2．7　其他类型控制器　53
3．2．8　多控制器模型　53
3．3　SDN南北向接口　55
3．3．1　SDN北向REST接口　55
3．3．2　SDN南向接口与协议　58
3．4　OpenDaylight控制器　60
3．4．1　OpenDaylight架构　60
3．4．2　OpenDaylight工作流程分析　61
3．4．3　OpenDaylight版本　62
3．4．4　OpenDaylight与OpenStack　63
3．5　OpenDaylight中部分重点项目　64
3．5．1　数据建模语言YANG　64
3．5．2　L2Switch项目　67
3．5．3　功能服务链项目　69
3．6　SDN与NFV　72
3．6．1　SDN与NFV的关系　72
3．6．2　IEEE SDN/NFV的标准化　73
3．6．3　NFV架构中的SDN　74
第4章　云管理平台OpenStack　76
4．1　云管理平台　76
4．1．1　云管理平台功能　76
4．1．2　主流的云管理平台　77
4．2　OpenStack发展历程　77
4．3　OpenStack架构　79
4．4　OpenStack核心组件　80
4．4．1　计算（Nova）　82
4．4．2　网络（Neutron）　84
4．4．3　对象存储（Swift）　85
4．4．4　块存储（Cinder）　88
4．4．5　认证（Keystone）　89
4．4．6　镜像服务（Glance）　91
4．4．7　界面（Horizon）　91
4．5　OpenStack与NFV　92
第5章　OPNFV　96
5．1　OPNFV简介　96
5．2　OPNFV与NFV产业　97
5．2．1　OPNFV目标　97
5．2．2　OPNFV对NFV产业的推进作用　97
5．3　OPNFV架构　98
5．3．1　OPNFV架构　98
5．3．2　OPNFV其他组件　99
5．3．3　OPNFV模块交互接口　102
5．3．4　Arno版本　103
5．3．5　Brahmaputra版本　104
5．3．6　Colorado版本　106
5．4　OPNFV安装　107
5．4．1　安装方式　107
5．4．2　安装过程介绍　107
第6章　NFV系统测试　111
6．1　NFV系统测试原理和方法　111
6．1．1　测试需求分析　111
6．1．2　测试方法　113
6．1．3　平台测试　114
6．1．4　业务测试　119
6．1．5　系统可用性测试　122
6．2　NFV系统测试分析　125
6．2．1　平台测试方案　125
6．2．2　平台测试结果分析　128
6．2．3　业务测试方案　130
6．2．4　业务测试结果分析　132
6．3　OPNFV Functest测试　134
6．3．1　Functest配置引导　135
6．3．2　Functest使用引导　139
6．3．3　执行Functest测试　144
第7章　NFV应用场景　146
7．1　网络功能虚拟化基础设施即服务（NFVIaaS）　146
7．1．1　概述　147
7．1．2　虚拟化目标　149
7．1．3　虚拟化网络功能的共存　150
7．2　虚拟网络功能即服务（VNFaaS）　150
7．2．1　动机　150
7．2．2　描述　151
7．2．3　vE-CPE　151
7．2．4　虚拟化目标　152
7．3　虚拟网络平台即服务（VNPaaS）　153
7．4　VNF转发图（VNF-FG）　154
7．4．1　动机　154
7．4．2　描述　155
7．4．3　虚拟化目标　157
7．5　移动核心网虚拟化　158
7．5．1　动机　158
7．5．2　描述　159
7．5．3　虚拟化目标　159
7．5．4　物理和虚拟化网络功能的共存　160
7．6　移动基站虚拟化　162
7．6．1　动机　162
7．6．2　描述　162
7．6．3　虚拟化目标　163
7．6．4　物理和虚拟化网络功能的共存　164
7．7　家庭网络虚拟化　164
7．7．1　动机　165
7．7．2　描述　165
7．7．3　物理和虚拟化网络功能的共存　166
7．8　虚拟化内容分发网络（vCDN）　168
7．8．1　动机　169
7．8．2　描述　169
7．8．3　虚拟化目标　170
7．8．4　物理和虚拟化网络功能的共存　170
7．9　固定接入网络功能虚拟化　171
7．9．1　动机　171
7．9．2　描述　171
7．9．3　挑战　172
7．9．4　虚拟化目标　173
7．9．5　物理和虚拟化网络功能的共存　173
第8章　5G中的NFV/SDN　175
8．1　5G发展背景　175
8．2　5G研发进展　176
8．2．1　5G的标准组织　176
8．2．2　各国政府及组织对5G的支持　178
8．3　5G网络的需求和挑战　179
8．4　基于NFV/SDN的5G网络架构设想　181
8．4．1　NFV/SDN在5G中的优势　181
8．4．2　基于NFV/SDN的5G网络架构设计　182
8．5　5G网络架构　183
8．5．1　NGMN 5G网络架构　183
8．5．2　IMT-2020 5G推进组网络架构　184
8．5．3　移动5G网络架构　187
8．5．4　联通5G网络架构　189
8．5．5　电信5G网络架构　189
第9章　NFV与移动核心网　192
9．1　基于NFV的核心网演进　193
9．2　IMS网络虚拟化系统架构研究（中国移动）　194
9．2．1　虚拟化IMS网络系统架构　194
9．2．2　虚拟化IMS网络主要接口　195
9．2．3　虚拟化IMS网络主要设备及设备形态研究　195
9．3　EPS业务链虚拟化方案研究（华为）　196
9．3．1　业务链架构　196
9．3．2　业务链关键功能模块与接口　197
9．4　NFV开源软件　198
9．4．1　EPC/IMS开源软件　198
9．4．2　虚拟路由和交换　199
9．4．3　其他开源网络设备　200
9．5　NFV开启现网试点　200
9．5．1　AT&T　200
9．5．2　中国移动　200
9．5．3　中国联通　201
9．5．4　中国电信　201
9．5．5　相关报道　202
第10章　NFV与移动边缘计算（MEC）　203
10．1　背景　203
10．2　MEC工作原理及优势　204
10．3　MEC关键技术　205
10．3．1　虚拟化技术　205
10．3．2　无线接入技术　205
10．4　MEC特点　206
10．5　ISG MEC工作组工作　207
10．5．1　ISG MEC的基本理念与目标　207
10．5．2　MEC服务器部署方案　207
10．5．3　MEC体系架构　208
10．6　应用　210
10．6．1　应用分类　210
10．6．2　应用例　211
10．6．3　5G中的MEC应用　216
10．7　MEC与触感互联网　217
10．8　MEC的挑战　218
10．8．1　安全问题　218
10．8．2　平台管理和应用可移植性　219
10．8．3　顽健性和弹性　219
10．8．4　用户隐私和计费挑战　220
10．8．5　网络整合和服务器部署　220
10．8．6　能源效率　220
第11章　MEC应用实例——WiCloud　221
11．1　WiCloud架构　221
11．2　WiCloud应用　223
11．2．1　商铺客流分析服务　224
11．2．2　智能客户分析服务　226
11．2．3　个性化定制服务　227
11．2．4　公共场所人员空间分析服务　228
11．2．5　无线网络质量分析与优化服务　229
主要概念术语　231
参考文献　241
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>网络功能虚拟化
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spark内核设计的艺术
目录  Contents
本书赞誉
前言
第1章　环境准备 ········································1
1.1　运行环境准备 ···········································2
1.1.1　安装JDK ·········································2
1.1.2　安装Scala ········································2
1.1.3　安装Spark ·······································3
1.2　Spark初体验 ···································4
1.2.1　运行spark-shell ·······························4
1.2.2　执行word count ······························5
1.2.3　剖析spark-shell ·······························9
1.3　阅读环境准备 ·········································14
1.3.1　安装SBT ·······································15
1.3.2　安装Git ·········································15
1.3.3　安装Eclipse Scala IDE插件 ········15
1.4　Spark源码编译与调试 ·························17
1.5　小结 ···························23
第2章　设计理念与基本架构 ···············24
2.1　初识Spark ··································25
2.1.1　Hadoop MRv1的局限···················25
2.1.2　Spark的特点 ·································26
2.1.3 Spark使用场景 ·····························28
2.2　Spark基础知识 ······································29
2.3　Spark基本设计思想 ·····························31
2.3.1　Spark模块设计 ·····························32
2.3.2　Spark模型设计 ·····························34
2.4　Spark基本架构 ···································36
2.5　小结 ·································38
第3章　Spark基础设施 ·························39
3.1　Spark配置 ········································40
3.1.1　系统属性中的配置 ·······················40
3.1.2　使用SparkConf配置的API ·········41
3.1.3　克隆SparkConf配置 ····················42
3.2　Spark内置RPC框架 ····························42
3.2.1　RPC配置TransportConf ··············45
3.2.2　RPC客户端工厂Transport- ClientFactory ·······················47
3.2.3　RPC服务端TransportServer ········53
3.2.4　管道初始化 ···································56
3.2.5　TransportChannelHandler详解 ·····57
3.2.6　服务端RpcHandler详解 ··············63
3.2.7　服务端引导程序Transport-ServerBootstrap ·····················68
3.2.8　客户端TransportClient详解 ········71
3.3　事件总线 ····································78
3.3.1　ListenerBus的继承体系 ···············79
3.3.2　SparkListenerBus详解 ··················80
3.3.3　LiveListenerBus详解 ····················83
3.4　度量系统 ···········································87
3.4.1　Source继承体系 ···························87
3.4.2　Sink继承体系 ·······························89
3.5　小结 ·········································92
第4章　SparkContext的初始化 ·········93
4.1　SparkContext概述 ·································94
4.2　创建Spark环境 ·····································97
4.3　SparkUI的实现 ····································100
4.3.1　SparkUI概述 ·······························100
4.3.2　WebUI框架体系 ·························102
4.3.3　创建SparkUI ·······························107
4.4　创建心跳接收器 ··································111
4.5　创建和启动调度系统··························112
4.6　初始化块管理器BlockManager ·······114
4.7　启动度量系统 ·······························114
4.8　创建事件日志监听器··························115
4.9　创建和启动ExecutorAllocation-Manager ··························116
4.10　ContextCleaner的创建与启动 ········120
4.10.1　创建ContextCleaner ·················120
4.10.2　启动ContextCleaner ·················120
4.11　额外的SparkListener与启动事件总线 ··························122
4.12　Spark环境更新 ··································123
4.13　SparkContext初始化的收尾 ···········127
4.14　SparkContext提供的常用方法 ·······128
4.15　SparkContext的伴生对象················130
4.16　小结 ····································131
第5章　Spark执行环境 ························132
5.1　SparkEnv概述 ·································133
5.2　安全管理器SecurityManager ············133
5.3　RPC环境 ·········································135
5.3.1　RPC端点RpcEndpoint ···············136
5.3.2　RPC端点引用RpcEndpointRef ···139
5.3.3　创建传输上下文TransportConf ···142
5.3.4　消息调度器Dispatcher ···············142
5.3.5　创建传输上下文Transport-Context ·························154
5.3.6　创建传输客户端工厂Transport-ClientFactory ····················159
5.3.7　创建TransportServer ···················160
5.3.8　客户端请求发送 ·························162
5.3.9　NettyRpcEnv中的常用方法 ·······173
5.4　序列化管理器SerializerManager ·····175
5.5　广播管理器BroadcastManager ·········178
5.6　map任务输出跟踪器 ··························185
5.6.1　MapOutputTracker的实现 ··········187
5.6.2　MapOutputTrackerMaster的实现原理 ·······················191
5.7　构建存储体系 ·······································199
5.8　创建度量系统 ·······································201
5.8.1　MetricsCon?g详解 ·····················203
5.8.2　MetricsSystem中的常用方法 ····207
5.8.3　启动MetricsSystem ····················209
5.9　输出提交协调器 ··································211
5.9.1　OutputCommitCoordinator-Endpoint的实现 ··················211
5.9.2　OutputCommitCoordinator的实现 ··························212
5.9.3　OutputCommitCoordinator的工作原理 ························216
5.10　创建SparkEnv ····································217
5.11　小结 ·····································217
第6章　存储体系 ·····································219
6.1　存储体系概述 ·······································220
6.1.1　存储体系架构 ·····························220
6.1.2　基本概念 ·····································222
6.2　Block信息管理器 ································227
6.2.1　Block锁的基本概念 ···················227
6.2.2　Block锁的实现 ···························229
6.3　磁盘Block管理器 ······························234
6.3.1　本地目录结构 ·····························234
6.3.2　DiskBlockManager提供的方法 ···························236
6.4　磁盘存储DiskStore ·····························239
6.5　内存管理器 ·····································242
6.5.1　内存池模型 ·································243
6.5.2　StorageMemoryPool详解 ···········244
6.5.3　MemoryManager模型 ················247
6.5.4　Uni?edMemoryManager详解 ····250
6.6　内存存储MemoryStore ······················252
6.6.1　MemoryStore的内存模型 ··········253
6.6.2　MemoryStore提供的方法 ··········255
6.7　块管理器BlockManager ····················265
6.7.1　BlockManager的初始化 ·············265
6.7.2　BlockManager提供的方法 ·········266
6.8　BlockManagerMaster对Block-Manager的管理 ·················285
6.8.1　BlockManagerMaster的职责 ······285
6.8.2　BlockManagerMasterEndpoint详解 ·································286
6.8.3　BlockManagerSlaveEndpoint详解 ·····························289
6.9　Block传输服务 ····································290
6.9.1　初始化NettyBlockTransfer-Service ···························291
6.9.2　NettyBlockRpcServer详解 ·········292
6.9.3　Shuf?e客户端 ·····························296
6.10　DiskBlockObjectWriter详解 ···········305
6.11　小结 ·······································308
第7章　调度系统 ·····································309
7.1　调度系统概述 ·······································310
7.2　RDD详解 ·····································312
7.2.1　为什么需要RDD ························312
7.2.2　RDD实现的初次分析 ················313
7.2.3　RDD依赖 ····································316
7.2.4　分区计算器Partitioner················318
7.2.5　RDDInfo ······································320
7.3　Stage详解 ········································321
7.3.1　ResultStage的实现 ·····················322
7.3.2　Shuf?eMapStage的实现 ·············323
7.3.3　StageInfo ······································324
7.4　面向DAG的调度器DAGScheduler ···326
7.4.1　JobListener与JobWaiter ·············326
7.4.2　ActiveJob详解 ····························328
7.4.3　DAGSchedulerEventProcessLoop的简要介绍 ·······················328
7.4.4　DAGScheduler的组成 ················329
7.4.5　DAGScheduler提供的常用方法 ···330
7.4.6　DAGScheduler与Job的提交 ····334
7.4.7　构建Stage····································337
7.4.8　提交ResultStage  ························341
7.4.9　提交还未计算的Task ·················343
7.4.10　DAGScheduler的调度流程 ······347
7.4.11　Task执行结果的处理  ··············348
7.5　调度池Pool ······································351
7.5.1　调度算法 ·······························352
7.5.2　Pool的实现 ·································354
7.5.3　调度池构建器 ·····························357
7.6　任务集合管理器TaskSetManager ···363
7.6.1　Task集合 ·····································363
7.6.2　TaskSetManager的成员属性 ······364
7.6.3　调度池与推断执行 ·····················366
7.6.4　Task本地性 ·································370
7.6.5　TaskSetManager的常用方法 ······373
7.7　运行器后端接口LauncherBackend ···383
7.7.1　BackendConnection的实现 ········384
7.7.2　LauncherBackend的实现 ···········386
7.8　调度后端接口SchedulerBackend ····389
7.8.1　SchedulerBackend的定义 ··········389
7.8.2　LocalSchedulerBackend的实现分析 ································390
7.9　任务结果获取器TaskResultGetter ···394
7.9.1　处理成功的Task ·························394
7.9.2　处理失败的Task ·························396
7.10　任务调度器TaskScheduler ··············397
7.10.1　TaskSchedulerImpl的属性 ·····397
7.10.2　TaskSchedulerImpl的初始化 ···399
7.10.3　TaskSchedulerImpl的启动 ·····399
7.10.4　TaskSchedulerImpl与Task的提交 ·······················400
7.10.5　TaskSchedulerImpl与资源分配 ···························402
7.10.6　TaskSchedulerImpl的调度流程 ······························405
7.10.7　TaskSchedulerImpl对执行结果的处理 ·····························406
7.10.8　TaskSchedulerImpl的常用方法 ···409
7.11　小结 ·······································412
第8章　计算引擎 ·····································413
8.1　计算引擎概述 ·······································414
8.2　内存管理器与执行内存 ·····················417
8.2.1　ExecutionMemoryPool详解 ·······417
8.2.2　MemoryManager模型与执行内存 ··························420
8.2.3　Uni?edMemoryManager与执行内存 ·······················421
8.3　内存管理器与Tungsten ·····················423
8.3.1　MemoryBlock详解 ·····················423
8.3.2　MemoryManager模型与Tungsten ···························425
8.3.3　Tungsten的内存分配器 ··············425
8.4　任务内存管理器 ··································431
8.4.1　TaskMemoryManager详解 ·········431
8.4.2　内存消费者 ·······················439
8.4.3　执行内存整体架构 ·····················441
8.5　Task详解 ······································443
8.5.1　任务上下文TaskContext ············443
8.5.2　Task的定义 ·································446
8.5.3　Shuf?eMapTask的实现 ··············449
8.5.4　ResultTask的实现 ·······················450
8.6　IndexShuf?eBlockResolver详解 ······451
8.7　采样与估算 ···········································455
8.7.1　SizeTracker的实现分析 ·············455
8.7.2　SizeTracker的工作原理 ·············457
8.8　特质WritablePartitionedPair- Collection ······················458
8.9　AppendOnlyMap的实现分析 ···········460
8.9.1　AppendOnlyMap的容量增长 ····461
8.9.2　AppendOnlyMap的数据更新 ····462
8.9.3　AppendOnlyMap的缓存聚合算法 ·····························464
8.9.4　AppendOnlyMap的内置排序 ····466
8.9.5　AppendOnlyMap的扩展 ············467
8.10　PartitionedPairBuffer的实现分析 ···469
8.10.1　PartitionedPairBuffer的容量增长 ······················469
8.10.2　PartitionedPairBuffer的插入 ···470
8.10.3　PartitionedPairBuffer的迭代器 ···471
8.11　外部排序器 ·········································472
8.11.1　ExternalSorter详解 ·················473
8.11.2　Shuf?eExternalSorter详解 ······487
8.12　Shuf?e管理器 ····································490
8.12.1　Shuf?eWriter详解 ··················491
8.12.2　Shuf?eBlockFetcherIterator详解 ······························502
8.12.3　BlockStoreShuf?eReader详解 ···510
8.12.4　SortShuf?eManager详解 ········513
8.13　map端与reduce端的Shuf?e组合 ······························516
8.14　小结 ·········································519
第9章　部署模式 ········································520
9.1　心跳接收器HeartbeatReceiver ·········521
9.2　Executor的实现分析 ··························527
9.2.1　Executor的心跳报告 ··················528
9.2.2　运行Task ·····································530
9.3　local部署模式 ······································535
9.4　持久化引擎PersistenceEngine ··········537
9.4.1　基于文件系统的持久化引擎 ·····539
9.4.2　基于ZooKeeper的持久化引擎 ···541
9.5　领导选举代理 ·······································542
9.6　Master详解 ···········································546
9.6.1　启动Master ·································549
9.6.2　检查Worker超时························553
9.6.3　被选举为领导时的处理 ·············554
9.6.4　一级资源调度 ·····························558
9.6.5　注册Worker·································568
9.6.6　更新Worker的最新状态············570
9.6.7　处理Worker的心跳····················570
9.6.8　注册Application··························571
9.6.9　处理Executor的申请 ·················573
9.6.10　处理Executor的状态变化 ·······573
9.6.11　Master的常用方法 ···················574
9.7　Worker详解 ································578
9.7.1　启动Worker·································581
9.7.2　向Master注册Worker ···············584
9.7.3　向Master发送心跳 ····················589
9.7.4　Worker与领导选举·····················591
9.7.5　运行Driver ··································593
9.7.6　运行Executor ······························594
9.7.7　处理Executor的状态变化 ·········599
9.8　StandaloneAppClient实现 ·················600
9.8.1　ClientEndpoint的实现分析 ········601
9.8.2　StandaloneAppClient的实现分析 ······························606
9.9　StandaloneSchedulerBackend的实现分析 ························607
9.9.1　StandaloneSchedulerBackend的属性 ····························607
9.9.2　DriverEndpoint的实现分析 ·······609
9.9.3　StandaloneSchedulerBackend的启动 ··························614
9.9.4　StandaloneSchedulerBackend的停止 ·························617
9.9.5　StandaloneSchedulerBackend与资源分配 ················618
9.10　CoarseGrainedExecutorBackend详解 ····························619
9.10.1　CoarseGrainedExecutorBackend进程 ··························620
9.10.2　CoarseGrainedExecutorBackend的功能分析 ·························622
9.11　local-cluster部署模式 ·······················625
9.11.1　启动本地集群 ····························625
9.11.2　local-cluster部署模式的启动过程 ·································627
9.11.3　local-cluster部署模式下Executor的分配过程 ·················628
9.11.4　local-cluster部署模式下的任务提交执行过程 ····························629
9.12　Standalone部署模式 ·························631
9.12.1　Standalone部署模式的启动过程 ························632
9.12.2　Standalone部署模式下Executor的分配过程 ················634
9.12.3　Standalone部署模式的资源回收 ·····························635
9.12.4　Standalone部署模式的容错机制 ······························636
9.13　其他部署方案 ·····································639
9.13.1　YARN·········································639
9.13.2　Mesos ·········································644
9.14　小结 ·······································646
第10章　Spark API ································647
10.1　基本概念·····································648
10.2　数据源DataSource ····························650
10.2.1　DataSourceRegister详解 ··········650
10.2.2　DataSource详解 ························651
10.3　检查点的实现 ···································655
10.3.1　CheckpointRDD的实现············655
10.3.2　RDDCheckpointData的实现 ····660
10.3.3　ReliableRDDCheckpointData的实现 ························662
10.4　RDD的再次分析 ·······························663
10.4.1　转换API ····································663
10.4.2　动作API ····································665
10.4.3　检查点API的实现分析 ···········667
10.4.4　迭代计算 ···································669
10.5　数据集合Dataset ·······························671
10.6　DataFrameReader详解 ·····················673
10.7　SparkSession详解 ·····························676
10.7.1　SparkSession的构建器Builder ···676
10.7.2　SparkSession的API ·················679
10.8　word count例子 ·································679
10.8.1　Job准备阶段 ·····························680
10.8.2　Job的提交与调度 ·····················685
10.9　小结 ········································689
附录 ···········································690
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spark内核设计的艺术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>讓角色活起來！最強漫畫故事講座
序言01 如何創作精彩的漫畫故事
序言02 製作漫畫的分級
序言03 本書的使用方法
第一章 角色設定
Lesson01 請記住角色設定的模式
Lesson02 製作角色設定表
Lesson03 深入挖掘角色的背景故事
Lesson04 傳達角色的背景
第二章 思考企劃
Lesson05 以文章結構寫企劃
Lesson06 在企劃中穿插「精彩性」
Lesson07 企劃不「出錯」
Lesson08 在企劃中發揮自己的強項
第三章 擬定故事大綱
Lesson09 分割故事大綱，思考情節發展
Lesson10 移情作用
Lesson11 讓主角成長
Lesson12 以道具連接故事情節
第四章 透過分鏡演出
Lesson13 以分解作業畫分鏡
Lesson14 摻入作者的情感
Lesson15 以讀者的觀點重新檢視
Lesson16 推敲分鏡表
角色．故事確認清單
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>讓角色活起來！最強漫畫故事講座
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>上台有魅力的說話邏輯
推薦序一   提升口語魅力，讓你人生更成功！
推薦序二   教你如何抓住觀眾目光的說話藝術
前言：說話不有趣的人，其實很吃虧！
第１章  上台沒有魅力，是因為你……
原來台上那些有趣的梗，是這樣架構出來的
哪兩種人，讓聽者覺得就算你說得好，他也興趣缺缺？
①一直講自己才聽得懂情節的人
②以自己為中心自吹自擂的人
哪兩種話，會讓人頻打哈欠、睡意無限？
①流水帳式的交代所有細節
②露餡說話方式讓別人沒有期待
第２章  為何成功者總能讓話題有趣，還能環環相扣不冷場？
有趣是什麼？決定「有趣」、「無趣」的是聽者是否有共鳴的感動
該選擇什麼話題？美食是最容易且不會退流行的「同感話題」
想要聊不停？那就學成功者都在用的「同感金字塔」吧！
用自己的故事，讓對方覺得你是同一國的3個訣竅
悲慘法：自己的悲慘經驗能縮短距離，讓人感同身受
譬喻法：將艱澀難懂，轉化為簡單又鮮活的故事
自嘲法：攤開自己的尷尬經驗，馬上增加親切感
第３章　說話有邏輯，只要3方法+3技巧就可以搞定
說話幽默有邏輯，其實有正確的順序
鋪陳結尾的方法一：捕鼠器方式
鋪陳結尾的方法二：可是方程式
鋪陳結尾的方法三：練習再練習
３個步驟讓你說話變有趣
步驟1：找出想表達的「那一句話」
步驟2：使用「可是方程式」
步驟3：按照「先鋪陳再結尾」的順序排列
精彩的話術，絕對不可缺少的「鋪陳結尾」模式
建立完美說話架構的技巧一：預告法
建立完美說話架構的技巧二：提示卡法
建立完美說話架構的技巧三：提問法
第４章　上台、聊天加上8種訣竅，讓你說話有爆點還能受歡迎
1.同時性法──有意外共同點，因為「巧合」是可以製造出來的
2.反差法──製造反差，讓對方想像不到
3.擬聲擬態發聲法──用從未聽過的聲音，讓你的表現更生動
4.愛的毒舌法──毒舌並不是說人壞話，而是……
注意點1.帶有感情，不刺傷他人
注意點2.不指名道姓
5.譬喻吐槽法──先加油添醋，再灑點天椒
6.獨腳戲法──一個人扮演好幾個角色
7.適當溫度笑話法──用「黃色笑話」舒緩緊繃
8.雜學知識賣弄法──給人博學多聞的印象
再次叮嚀：讓說話變有趣的３個階段
第１階段：挑選同感題材
第２階段：鋪陳結尾
第３階段：加強趣味的香辛料
後記　「有趣、有邏輯的話」是永恆不變的武器
附錄：上台有魅力，你得存一本笑梗筆記
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>上台有魅力的說話邏輯
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>SDN\NFV(重构网络架构建设未来网络)
第1章　网络重构解读　　1
1.1　网络发展的历史趋势　　1
1.1.1　网络变革的历史　　1
1.1.2　网络演进的趋势　　3
1.2　网络重构的驱动力　　4
1.2.1　运营商面临的挑战　　4
1.2.2　IT架构发展的经验　　4
1.2.3　新兴业务的驱动　　5
1.3　网络重构愿景　　6
1.3.1　新一代网络关键特征　　6
1.3.2　新一代网络参考架构　　6
1.4　网络重构的关键技术　　8
1.4.1　SDN　　8
1.4.2　NFV　　10
1.4.3　云计算　　11
1.4.4　SDN与NFV的关系　　12
1.4.5　部署面临问题　　13
1.5　网络重构小结　　15
1.5.1　网络重构成为发展主题　　15
1.5.2　推进网络重构的策略　　16
第2章　SDN技术概述　　19
2.1　SDN的概念与发展　　19
2.1.1　SDN的起源　　19
2.1.2　SDN的概念　　21
2.1.3　SDN的优势　　22
2.2　SDN架构解读　　23
2.3　SDN产业生态　　24
2.4　SDN相关组织　　26
2.4.1　开源与标准　　26
2.4.2　开源组织　　27
2.4.3　标准化组织　　29
2.5　SDN发展中的挑战　　32
第3章　SDN控制器解析　　34
3.1　SDN控制器主要功能　　34
3.2　SDN控制器性能指标　　35
3.3　SDN控制器接口协议　　36
3.3.1　南向接口　　36
3.3.2　南向接口总结比较　　43
3.3.3　北向接口　　44
3.3.4　东西向接口　　46
3.4　主流SDN控制器　　47
3.4.1　ODL　　47
3.4.2　ONOS　　50
3.4.3　ODL与ONOS的比较　　53
3.4.4　其他开源控制器　　54
3.5　SDN控制器与传统网管的区别　　56
3.5.1　传统网管技术特征　　56
3.5.2　SDN控制器与网管的融合发展　　57
第4章　NFV技术概述　　59
4.1　NFV的概念与影响　　59
4.1.1　产生的背景　　59
4.1.2　NFV的概念　　60
4.1.3　NFV的影响　　61
4.2　NFV的参考架构　　62
4.2.1　主要模块　　62
4.2.2　主要接口　　63
4.2.3　部署方式　　64
4.3　NFV转发性能提升　　65
4.3.1　影响因素　　66
4.3.2　优化方法　　68
4.3.3　提升建议　　70
4.4　NFV分层解耦与集成　　71
4.4.1　NFV解耦现状　　71
4.4.2　技术挑战　　72
4.4.3　实施建议　　72
4.5　NFV MANO　　73
4.5.1　系统架构　　73
4.5.2　管理模式　　74
4.5.3　VNFM类型　　76
4.5.4　NFVO部署　　78
4.6　NFV组织与项目　　79
4.6.1　ETSI　　79
4.6.2　3GPP　　80
4.6.3　ITU-T　　81
4.6.4　IETF　　81
4.6.5　CCSA　　81
4.6.6　OPNFV　　81
4.6.7　OSM　　84
4.6.8　OpenStack　　84
4.7　NFV发展展望　　85
第5章　编排器技术概述　　86
5.1　编排器概述　　86
5.1.1　编排器的概念　　86
5.1.2　编排器的作用　　87
5.2　编排器的类型　　88
5.2.1　SDN编排器　　88
5.2.2　NFV编排器　　89
5.2.3　协同/业务编排器　　89
5.3　主流编排器项目　　89
5.3.1　OPEN-O　　90
5.3.2　ECOMP　　92
5.3.3　ONAP　　94
5.3.4　LSO　　94
5.4　编排器发展展望　　95
5.4.1　编排器的关键技术　　95
5.4.2　编排器标准与开源的关系　　96
5.4.3　编排器与OSS的关系　　96
第6章　云计算技术概述　　98
6.1　云计算概述　　98
6.1.1　起源与发展　　98
6.1.2　概念与特点　　99
6.1.3　服务模型与架构　　100
6.1.4　部署模式　　101
6.1.5　发展现状　　102
6.2　云计算与网络重构　　103
6.2.1　云计算是网络重构的关键驱动力　　103
6.2.2　云计算是网络重构的基础　　104
6.2.3　云计算应对网络重构不断演进　　104
6.2.4　云计算和网络一体化发展　　105
6.2.5　云计算和网络密切协同　　105
6.3　云计算关键技术　　106
6.3.1　分布式计算　　106
6.3.2　服务器虚拟化　　107
6.3.3　云存储　　107
6.3.4　云数据中心网络　　108
6.3.5　云管理平台　　110
6.3.6　云安全　　110
6.4　云计算标准化与开源技术　　112
6.4.1　云计算标准化　　112
6.4.2　云计算开源技术　　114
6.5　云计算发展趋势　　117
第7章　运营商网络重构策略　　119
7.1　概述　　119
7.2　国外运营商网络重构　　120
7.2.1　北美　　120
7.2.2　欧洲　　121
7.2.3　日本　　122
7.3　国内运营商网络重构　　123
7.3.1　中国电信CTNet2025　　123
7.3.2　中国移动NovoNet 2020　　126
7.3.3　中国联通CUBE-Net 2.0　　129
7.4　网络重构的切入点　　132
7.4.1　构建泛在、高速、智能的基础网络　　132
7.4.2　借中心机房DC化推进云计算基础设施建设　　135
7.4.3　建立网络与IT融合的新一代运营支撑系统　　136
7.4.4　推出云网协同的新型信息基础设施服务　　136
7.5　网络重构的演进路径　　137
7.5.1　近期（起步阶段）　　137
7.5.2　中远期（深化阶段）　　138
7.6　国内运营商网络重构举措和场景　　138
7.6.1　中国电信网络重构　　138
7.6.2　中国移动网络重构　　139
7.6.3　中国联通网络重构　　142
7.7　网络重构对运营商转型升级的影响　　145
7.7.1　业务重构　　145
7.7.2　运营重构　　149
7.7.3　管理重构　　149
7.7.4　开发运营一体化　　150
7.7.5　标准和开源并存　　150
7.7.6　采购模式的转变　　151
第8章　运营商网络重构实践　　152
8.1　网络中心从CO向DC转变　　152
8.1.1　多级DC网络架构与CO重构　　152
8.1.2　开源网络重构项目CORD　　153
8.1.3　中国电信的演进方案　　155
8.1.4　中国移动的演进方案　　158
8.1.5　中国联通的演进方案　　159
8.2　SDN/NFV在随选网络中的应用　　161
8.2.1　随选网络产生的背景　　161
8.2.2　随选网络的特征与价值　　162
8.2.3　随选网络的核心功能　　162
8.2.4　随选网络的应用案例　　164
8.2.5　随选网络技术小结　　165
8.3　SDN/NFV在云网协同中的应用　　166
8.3.1　云服务的价值依赖于网络　　166
8.3.2　云网协同的含义　　166
8.3.3　SDN/NFV是云网协同的关键手段　　167
8.3.4　面向企业用户的典型云网协同场景　　168
8.4　SDN/NFV在云数据中心的应用　　169
8.4.1　在云数据中心内部的应用　　169
8.4.2　利用SDN+VxLAN技术构建vDC　　171
8.4.3　利用SDN进行DC之间的流量调优　　173
8.5　SDN/NFV在广域网的应用　　174
8.5.1　SD-WAN概述　　174
8.5.2　SD-WAN应用场景　　175
8.5.3　SD-WAN发展展望　　177
8.6　SDN/NFV在城域网的应用　　177
8.6.1　城域网发展面临的挑战　　177
8.6.2　vBRAS的发展　　179
8.6.3　vBRAS技术架构　　181
8.6.4　vBRAS的实现方式　　183
8.6.5　vBRAS典型部署场景分析　　184
8.6.6　vBRAS未来发展分析　　186
8.7　SDN/NFV在传送网的应用　　187
8.7.1　传送网引入SDN的需求　　187
8.7.2　传送网引入SDN的优势与挑战　　187
8.7.3　软件定义传送网的典型场景　　188
8.7.4　传送网重构实践　　190
8.8　SDN/NFV在接入网的应用　　192
8.8.1　接入网面临的问题　　192
8.8.2　应用场景分析　　193
8.8.3　接入网的重构目标架构　　194
8.8.4　关键技术　　195
8.9　SDN/NFV在核心网的应用　　196
8.9.1　核心网的重构目标架构　　197
8.9.2　核心网重构策略　　197
8.10　SDN/NFV在5G网络的应用　　201
8.10.1　5G网络架构　　201
8.10.2　切片的概念　　202
8.10.3　切片的特点　　203
8.10.4　切片的分类与部署　　204
8.10.5　切片的全生命周期管理　　204
8.10.6　切片的技术基础　　205
8.10.7　切片后续需研究的关键技术　　205
总结与展望　　206
缩略语　　207
参考文献　　216
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>SDN\NFV(重构网络架构建设未来网络)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java高手真经（系统架构卷）
绪论  软件设计与架构概述  一、Java与UML建模  二、Java设计模式    1.创建型模式    2.结构型模式    3.行为型模式  三、系统架构    1.面向服务架构SOA    2.面向资源架构ROA    3.面向云架构COA第1部分  Java与UML建模  第1课  UML快速入门    1.1  UML建模概述      1.1.1  面向对象方法      1.1.2  面向对象建模OMT      1.1.3  统一建模语言UML      1.1.4  UML的起源和发展      1.1.5  为什么要使用UML    1.2  UML基本构成元素      1.2.1  4种事物        1.结构事物(Structural Things)        2.行为事物(Behavioral Things)        3.分组事物(Grouping Things)        4.注释事物(Annotational Things)      1.2.2  4种关系        1.依赖(Dependencies)        2.关联(Association)        3.泛化(Generalization)        4.实现(Realization)      1.2.3  10种图        1.用例图(UsecaseDiagram)        2.类图(ClassDiagram)        3.对象图(Object Diagram)        4.包图(Package Diagram)        5.组件图(Compoment Diagram)        6.部署图(Deployment Diagram)        7.状态图(Statechart Diagram)        8.活动图(Activity Diagram)        9.序列图(Sequence Diagram)        10.协作图(Collaboration Diagram)        1.2.4  UML图的分类    1.3  UML设计工具      1.3.1  使用Rose进行UML建模      1.3.2  使用Visio进行UML建模    1.4  本课小结      1.4.1  本课图例打包UML.mdl      1.4.2  总结本课的知识点      1.4.3  要掌握的关键点      1.4.4  课后上机作业      1.4.5  继续下一课：用例图  第2课  用例图    2.1  用例概述      2.1.1  什么是用例      2.1.2  为什么要使用用例      2.1.3  用例图的基本模型元素    2.2  用例图的绘制      2.2.1  参与者的表示法      2.2.2  用例的表示法      2.2.3  系统边界的表示法      2.2.4  通信关联的表示法    2.3  用例图的建立过程      2.3.1  发现参与者及检查标准      2.3.2  发现用例及检查标准      2.3.3  编写用例规约      2.3.4  用例图创建技巧    2.4  本课小结      2.4.1  本课图例打包usecase.mdl      2.4.2  总结本课的知识点      2.4.3  要掌握的关键点      2.4.4  课后上机演练——企业产品生产销售管理系统      2.4.5  继续下一课：静态图一类图、对象图、包图  第3课  静态图——类图、对象图、包图    3.1  类图的绘制      3.1.1  类图的表示法        1.类图的表示法        2.类图属性的表示法        3.类图操作的表示法        3.1.2  接口的表示法        3.1.3  类图之问的4种关系        1.泛化关系(Generalization)——表示类的继承        2.关联关系(Association)——表示类的变量        3.依赖关系(Dependency)——表示局部变量        4.实现关系(Realization)——表示接口的实现    3.2  对象图的绘制      3.2.1  对象图的表示法      3.2.2  对象图的使用场景一序列图和协作图    3.3  包图的绘制      3.3.1  包图的表示法      3.3.2  使用包包含类      3.3.3  使用包包含子包      3.3.4  包的依赖关系    3.4  本课小结      3.4.1  本课图例打包class.mdl      3.4.2  总结本课的知识点      3.4.3  课后上机演练一企业信息管理系统用户登录和注册模块      3.4.4  继续下一课：实现图——组件图与部署图  第4课  实现图——组件图与部署图    4.1  组件图的绘制      4.1.1  组件的表示法      4.1.2  程序的表示法        1.子程序规范        2.子程序体        3.主程序        4.1.3  包的表示法        1.包规范        2.包体        4.1.4  任务的表示法        1.任务规范        2.任务体        4.1.5  组件之间的依赖    4.2  部署图的绘制      4.2.1  处理器节点的表示法      4.2.2  设备节点的表示法      4.2.3  节点之间的关联    4.3  本课小结      4.3.1  本课图例打包component.mdl      4.3.2  总结本课的知识点      4.3.3  要掌握的关键点      4.3.4  课后上机演练一企业信息管理系统部署图      4.3.5  继续下一课：行为图一状态图  第5课  行为图——状态图    5.1  状态图的绘制      5.1.1  状态图的基本模型      5.1.2  状态的表示法      5.1.3  转换的表示法    5.2  状态的绘制      5.2.1  初始状态的表示法      5.2.2  终止状态的表示法      5.2.3  子状态的表示法      5.2.4  历史状态的表示法    5.3  本课小结      5.3.1  本课图例打包statechart.mdl      5.3.2  总结本课的知识点      5.3.3  要掌握的关键点      5.3.4  课后上机演练        1.Bug管理系统状态图        2.ATM机存取款状态图        3.Java线程类Thread的状态图        5.3.5继续下一课：行为图——活动图  第6课  行为图——活动图    6.1  活动图的绘制      6.1.1  活动图的基本模型      6.1.2  活动的表示法      6.1.3  转换的表示法      6.1.4  分支与合并的表示法      6.1.5  分叉与汇合的表示法      6.1.6  泳道的表示法    6.2  本课小结      6.2.1  本课图例打包activity.mdl      6.2.2  总结本课的知识点      6.2.3  要掌握的关键点      6.2.4  课后上机演练        1.Bug管理系统活动图        2.ATM机存取款活动图        3.Java线程类Thread的活动图  第7课  交互图——序列图    7.1  序列图的绘制      7.1.1  序列图的基本模型      7.1.2  对象生命线的表示法      7.1.3  激活的表示法      7.1.4  消息的表示法      7.1.5  自调用消息的表示法    7.2  本课小结      7.2.1  本课图例打包sequence.mdl      7.2.2  总结本课的知识点      7.2.3  要掌握的关键点      7.2.4  课后上机演练        1.Bug管理系统序列图        2.ATM机存取款序列图        3.打电话序列图        7.2.5  继续下一课：交互图——协作图  第8课  交互图——协作图    8.1  协作图的绘制      8.1.1  协作图的基本模型      8.1.2  对象的表示法      8.1.3  连接的表示法      8.1.4  消息的表示法      8.1.5  自调用消息的表示法    8.2  本课小结      8.2.1  本课图例打包collaboration.mdl      8.2.2  总结本课的知识点      8.2.3  要掌握的关键点      8.2.4  课后上机演练        1.Bug管理系统协作图        2.ATM机存取款协作图        3.打电话协作图        8.2.5  继续下一课：使用UML进行系统设计——Bug管理系统  第9课  使用UML进行系统设计——Bug管理系统    9.1  UML系统设计概述      9.1.1  软件开发的驱动方法        1.数据库驱动开发DDD(Database-Driven Development)        2.测试驱动开发TDD(Test-Driven Development)        3.模型驱动开发MDD(Model.Driven Development)        9.1.2  正向工程与逆向工程        1.正向工程(Forward Engineering)        2.逆向工程(Reverse Engineering)      9.1.3  UML建模的受众分析      9.1.4  UML建模的过程    9.2  Bug管理系统的模型驱动开发过程      9.2.1  需求分析一用例图      9.2.2  系统分析：分析业务规则一状态图      9.2.3  系统分析：分析业务流程一活动图      9.2.4  系统设计：设计静态结构——类图和包图      9.2.5  系统设计：Action类被调用关系——序列图      9.2.6  系统设计：用户调用Action类的过程一协作图      9.2.7  系统架构一组件图和部署图      9.2.8  编码实现      9.2.9  UML图例打包bug.mdl    9.3  本课小结      9.3.1  总结本课的知识点      9.3.2  要掌握的关键点      9.3.3  课后上机演练      9.3.4  继续下一课：Java设计模式第2部分  Java设计模式  第10课  设计模式概述    10.1  了解设计模式      10.1.1  设计模式的概念      10.1.2  设计模式的产生——23种设计模式与GoF“四人帮”      10.1.3  设计模式不是技术而是思想——构建可重用的程序  ……  第11课  5种创建型模式  第12课  7种结构型模式  第13课  11种行为型模式第3部分  面各服务架构SOA  第14课  Web服务协议——SOAP、WSDL、UDDI和WS协议集  第15课  Web服务开发技术——使用JAX-WS开发Web服务  第16课  Web服务开发框架——使用Axis框架开发Web服务  第17课  SOA面向服务架构——Sun的JBI和IBM/BEA的SCA/SDO  第18课  JBI业务集成架构——Java实现SOA的标准途径  第19课  SCA服务组件架构——实现SOA的最佳方式  第20课  SDO服务数据对象——SCA数据服务组件  第21课  OSGi体系架构——SCA的一种实现方式  第22课  SOA延伸技术——BPEL业务流程管理、ESB企业服务总线与EAI企业应用集成  第23课  SOA扩展应用——Portal门户组件与Portlet窗口组件  第24课  SOA服务架构开发实战——基于Tuscany+Spring企业信息管理系统  第25课  ROA面向资源架构——基于REST风格的Web服务第5部分  面向云架构COA  第26课  COA面向架构——云计算与云架构第6部分  架构师之路  第27课  软件架构师职业规划《高手真经》系列后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java高手真经（系统架构卷）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Netty权威指南（第2版）
基础篇走进Java NIO
第1 章Java 的I/O 演进之路.2
1.1 I/O 基础入门...............3
1.1.1 Linux 网络I/O 模型简介.......3
1.1.2 I/O 多路复用技术.................6
1.2 Java 的I/O 演进..........8
1.3 总结............................ 10
第2 章NIO 入门.................... 11
2.1 传统的BIO 编程....... 11
2.1.1 BIO 通信模型图.................. 12
2.1.2 同步阻塞式I/O 创建的TimeServer 源码分析............. 13
2.1.3 同步阻塞式I/O 创建的TimeClient 源码分析.......... 16
2.2 伪异步I/O 编程........ 18
2.2.1 伪异步I/O 模型图.............. 19
2.2.2 伪异步I/O 创建的TimeServer 源码分析..... 19
2.2.3 伪异步I/O 弊端分析........... 21
2.3 NIO 编程.................... 24
2.3.1 NIO 类库简介.. 24
2.3.2 NIO 服务端序列图.............. 28
2.3.3 NIO 创建的TimeServer 源码分析................ 30
2.3.4 NIO 客户端序列图.............. 36
2.3.5 NIO 创建的TimeClient 源码分析................ 39
2.4 AIO 编程.................... 45
2.4.1 AIO 创建的TimeServer 源码分析................ 46
2.4.2 AIO 创建的TimeClient 源码分析................ 51
2.4.3 AIO 版本时间服务器运行结果.................... 56
2.5 4 种I/O 的对比......... 58
2.5.1 概念澄清.......... 58
2.5.2 不同I/O 模型对比.............. 59
2.6 选择Netty 的理由..... 60
2.6.1 不选择Java 原生NIO 编程的原因............... 61
2.6.2 为什么选择Netty ................ 62
2.7 总结............................ 63
入门篇 Netty NIO 开发指南
第3 章Netty 入门应用.......... 66
3.1 Netty 开发环境的搭建................ 66
3.1.1 下载Netty 的软件包........... 67
3.1.2 搭建Netty 应用工程........... 67
3.2 Netty 服务端开发...... 68
3.3 Netty 客户端开发...... 73
3.4 运行和调试................ 76
3.4.1 服务端和客户端的运行...... 76
3.4.2 打包和部署...... 77
3.5 总结............................ 77
第4 章TCP 粘包/拆包问题的解决之道...... 79
4.1 TCP 粘包/拆包.......... 79
4.1.1 TCP 粘包/拆包问题说明..... 80
4.1.2 TCP 粘包/拆包发生的原因....... 80
4.1.3 粘包问题的解决策略.......... 81
4.2 未考虑TCP 粘包导致功能异常案例................. 82
4.2.1 TimeServer 的改造.............. 82
4.2.2 TimeClient 的改造............... 83
4.2.3 运行结果.......... 84
4.3 利用LineBasedFrameDecoder 解决TCP 粘包问题................ 85
4.3.1 支持TCP 粘包的TimeServer ....................... 86
4.3.2 支持TCP 粘包的TimeClient........................ 88
4.3.3 运行支持TCP 粘包的时间服务器程序........ 90
4.3.4 LineBasedFrameDecoder 和StringDecoder 的原理分析........... 91
4.4 总结............................ 92
第5 章分隔符和定长解码器的应用...... 93
5.1 DelimiterBasedFrameDecoder 应用开发............. 94
5.1.1 DelimiterBasedFrameDecoder 服务端开发.... 94
5.1.2 DelimiterBasedFrameDecoder 客户端开发.... 97
5.1.3 运行DelimiterBasedFrameDecoder 服务端和客户端............... 99
5.2 FixedLengthFrameDecoder 应用开发............... 101
5.2.1 FixedLengthFrameDecoder 服务端开发...... 101
5.2.2 利用telnet 命令行测试EchoServer 服务端......103
5.3 总结.......................... 104
中级篇 Netty 编解码开发指南
第6 章编解码技术.............. 106
6.1 Java 序列化的缺点 ...... 107
6.1.1 无法跨语言.... 107
6.1.2 序列化后的码流太大........ 107
6.1.3 序列化性能太低................ 110
6.2 业界主流的编解码框架............ 113
6.2.1 Google 的Protobuf 介绍.... 113
6.2.2 Facebook 的Thrift 介绍.... 115
6.2.3 JBoss Marshalling 介绍..... 116
6.3 总结.......................... 117
第7 章MessagePack 编解码............... 118
7.1 MessagePack 介绍... 118
7.1.1 MessagePack 多语言支持.. 119
7.1.2 MessagePack Java API 介绍........................ 119
7.1.3 MessagePack 开发包下载. 120
7.2 MessagePack 编码器和解码器开发................. 120
7.2.1 MessagePack 编码器开发....... 120
7.2.2 MessagePack 解码器开发 ...... 121
7.2.3 功能测试........ 121
7.3 粘包/半包支持......... 124
7.4 总结.......................... 127
第8 章Google Protobuf 编解码.......... 128
8.1 Protobuf 的入门....... 129
8.1.1 Protobuf 开发环境搭建..... 129
8.1.2 Protobuf 编解码开发......... 131
8.1.3 运行Protobuf 例程............ 133
8.2 Netty 的Protobuf 服务端开发.. 133
8.2.1 Protobuf 版本的图书订购服务端开发........ 134
8.2.2 Protobuf 版本的图书订购客户端开发........ 136
8.2.3 Protobuf 版本的图书订购程序功能测试.... 139
8.3 Protobuf 的使用注意事项......... 140
8.4 总结.......................... 142
第9 章JBoss Marshalling 编解码....... 143
9.1 Marshalling 开发环境准备........ 143
9.2 Netty 的Marshalling 服务端开发..................... 144
9.3 Netty 的Marshalling 客户端开发..................... 147
9.4 运行Marshalling 客户端和服务端例程........... 149
9.5 总结.......................... 150
高级篇 Netty 多协议开发和应用
第10 章HTTP 协议开发应用............... 154
10.1 HTTP 协议介绍..... 155
10.1.1 HTTP 协议的URL .......... 155
10.1.2 HTTP 请求消息（HttpRequest）.............. 155
10.1.3 HTTP 响应消息（HttpResponse）........... 158
10.2 Netty HTTP 服务端入门开发....... 159
10.2.1 HTTP 服务端例程场景描述..................... 160
10.2.2 HTTP 服务端开发........... 160
10.2.3 Netty HTTP 文件服务器例程运行结果.... 166
10.3 Netty HTTP+XML 协议栈开发....................... 170
10.3.1 开发场景介绍................. 171
10.3.2 HTTP+XML 协议栈设计.......174
10.3.3 高效的XML 绑定框架JiBx ..................... 175
10.3.4 HTTP+XML 编解码框架开发.................. 183
10.3.5 HTTP+XML 协议栈测试....... 199
10.3.6 小结............. 201
10.4 总结........................ 202
第11 章WebSocket 协议开发............. 203
11.1 HTTP 协议的弊端....... 204
11.2 WebSocket 入门..... 204
11.2.1 WebSocket 背景............... 205
11.2.2 WebSocket 连接建立....... 206
11.2.3 WebSocket 生命周期....... 207
11.2.4 WebSocket 连接关闭....... 208
11.3 Netty WebSocket 协议开发..... 209
11.3.1 WebSocket 服务端功能介绍..................... 209
11.3.2 WebSocket 服务端开发.... 210
11.3.3 运行WebSocket 服务端... 218
11.4 总结........................ 219
第12 章私有协议栈开发.... 221
12.1 私有协议介绍........ 221
12.2 Netty 协议栈功能设计............ 223
12.2.1 网络拓扑图.. 223
12.2.2 协议栈功能描述.............. 224
12.2.3 通信模型...... 224
12.2.4 消息定义...... 225
12.2.5 Netty 协议支持的字段类型...................... 226
12.2.6 Netty 协议的编解码规范. 227
12.2.7 链路的建立.. 229
12.2.8 链路的关闭.. 230
12.2.9 可靠性设计.. 230
12.2.10 安全性设计 232
12.2.11 可扩展性设计................ 232
12.3 Netty 协议栈开发.. 233
12.3.1 数据结构定义................. 233
12.3.2 消息编解码.. 237
12.3.3 握手和安全认证.............. 241
12.3.4 心跳检测机制................. 245
12.3.5 断连重连...... 248
12.3.6 客户端代码.. 249
12.3.7 服务端代码.. 251
12.4 运行协议栈............ 252
12.4.1 正常场景...... 252
12.4.2 异常场景：服务端宕机重启.................... 253
12.4.3 异常场景：客户端宕机重启.................... 256
12.5 总结........................ 256
第13 章服务端创建............ 258
13.1 原生NIO 类库的复杂性......... 259
13.2 Netty 服务端创建源码分析.... 259
13.2.1 Netty 服务端创建时序图. 260
13.2.2 Netty 服务端创建源码分析...................... 263
13.3 客户端接入源码分析.............. 272
13.4 总结........................ 275
第14 章客户端创建............ 276
14.1 Netty 客户端创建流程分析.... 276
14.2.1 Netty 客户端创建时序图. 276
14.2.2 Netty 客户端创建流程分析...................... 277
14.2 Netty 客户端创建源码分析.... 278
14.2.1 客户端连接辅助类Bootstrap.................... 278
14.2.2 客户端连接操作.............. 281
14.2.3 异步连接结果通知.......... 283
14.2.4 客户端连接超时机制...... 284
14.3 总结........................ 286
源码分析篇 Netty 功能介绍和源码分析
第15 章ByteBuf 和相关辅助类........... 288
15.1 ByteBuf 功能说明. 288
15.1.1 ByteBuf 的工作原理........ 289
15.1.2 ByteBuf 的功能介绍........ 294
15.2 ByteBuf 源码分析. 308
15.2.1 ByteBuf 的主要类继承关系..................... 309
15.2.2 AbstractByteBuf 源码分析........................ 310
15.2.3 AbstractReferenceCountedByteBuf 源码分析.................. 319
15.2.4 UnpooledHeapByteBuf 源码分析.............. 321
15.2.5 PooledByteBuf 内存池原理分析............... 326
15.2.6 PooledDirectByteBuf 源码分析................. 329
15.3 ByteBuf 相关的辅助类功能介绍.................... 332
15.3.1 ByteBufHolder................. 332
15.3.2 ByteBufAllocator ............. 333
15.3.3 CompositeByteBuf ........... 334
15.3.4 ByteBufUtil .. 336
15.4 总结........................ 337
第16 章Channel 和Unsafe ................. 338
16.1 Channel 功能说明. 338
16.1.1 Channel 的工作原理........ 339
16.1.2 Channel 的功能介绍........ 340
16.2 Channel 源码分析. 343
16.2.1 Channel 的主要继承关系类图.................. 343
16.2.2 AbstractChannel 源码分析........................ 344
16.2.3 AbstractNioChannel 源码分析.................. 347
16.2.4 AbstractNioByteChannel 源码分析........... 350
16.2.5 AbstractNioMessageChannel 源码分析..... 353
16.2.6 AbstractNioMessageServerChannel 源码分析.............. 354
16.2.7 NioServerSocketChannel 源码分析........... 355
16.2.8 NioSocketChannel 源码分析..................... 358
16.3 Unsafe 功能说明... 364
16.4 Unsafe 源码分析... 365
16.4.1 Unsafe 继承关系类图...... 365
16.4.2 AbstractUnsafe 源码分析. 366
16.4.3 AbstractNioUnsafe 源码分析.................... 375
16.4.4 NioByteUnsafe 源码分析. 379
16.5 总结........................ 387
第17 章ChannelPipeline 和ChannelHandler........... 388
17.1 ChannelPipeline 功能说明....... 389
17.1.1 ChannelPipeline 的事件处理.................... 389
17.1.2 自定义拦截器................. 391
17.1.3 构建pipeline 392
17.1.4 ChannelPipeline 的主要特性.................... 393
17.2 ChannelPipeline 源码分析....... 393
17.2.1 ChannelPipeline 的类继承关系图............. 393
17.2.2 ChannelPipeline 对ChannelHandler 的管理........... 393
17.2.3 ChannelPipeline 的inbound 事件.............. 396
17.2.4 ChannelPipeline 的outbound 事件............ 397
17.3 ChannelHandler 功能说明....... 398
17.3.1 ChannelHandlerAdapter 功能说明............ 399
17.3.2 ByteToMessageDecoder 功能说明............ 399
17.3.3 MessageToMessageDecoder 功能说明...... 400
17.3.4 LengthFieldBasedFrameDecoder 功能说明............... 400
17.3.5 MessageToByteEncoder 功能说明............. 404
17.3.6 MessageToMessageEncoder 功能说明....... 404
17.3.7 LengthFieldPrepender 功能说明............... 405
17.4 ChannelHandler 源码分析....... 406
17.4.1 ChannelHandler 的类继承关系图............. 406
17.4.2 ByteToMessageDecoder 源码分析............ 407
17.4.3 MessageToMessageDecoder 源码分析...... 410
17.4.4 LengthFieldBasedFrameDecoder 源码分析............ 411
17.4.5 MessageToByteEncoder 源码分析............. 415
17.4.6 MessageToMessageEncoder 源码分析....... 416
17.4.7 LengthFieldPrepender 源码分析............... 417
17.5 总结........................ 418
第18 章EventLoop 和EventLoopGroup.................... 419
18.1 Netty 的线程模型.. 419
18.1.1 Reactor 单线程模型......... 420
18.1.2 Reactor 多线程模型......... 421
18.1.3 主从Reactor 多线程模型 422
18.1.4 Netty 的线程模型............ 423
18.1.5 最佳实践...... 424
18.2 NioEventLoop 源码分析......... 425
18.2.1 NioEventLoop 设计原理.. 425
18.2.2 NioEventLoop 继承关系类图................... 426
18.2.3 NioEventLoop.................. 427
18.3 总结........................ 436
第19 章Future 和Promise .................. 438
19.1 Future 功能............ 438
19.2 ChannelFuture 源码分析......... 443
19.3 Promise 功能介绍. 445
19.4 Promise 源码分析. 447
19.4.1 Promise 继承关系图........ 447
19.4.2 DefaultPromise ................ 447
19.5 总结........................ 449
架构和行业应用篇 Netty 高级特性
第20 章Netty 架构剖析..... 452
20.1 Netty 逻辑架构...... 452
20.1.1 Reactor 通信调度层......... 453
20.1.2 职责链ChannelPipeline ... 453
20.1.3 业务逻辑编排层（Service ChannelHandler）........... 454
20.2 关键架构质量属性.................. 454
20.2.1 高性能.......... 454
20.2.2 可靠性.......... 457
20.2.3 可定制性...... 460
20.2.4 可扩展性...... 460
20.3 总结........................ 460
第21 章Java 多线程编程在Netty 中的应用............. 461
21.1 Java 内存模型与多线程编程.. 461
21.1.1 硬件的发展和多任务处理........................ 461
21.1.2 Java 内存模型................. 462
21.2 Netty 的并发编程实践............ 464
21.2.1 对共享的可变数据进行正确的同步......... 464
21.2.2 正确使用锁.. 465
21.2.3 volatile 的正确使用......... 467
21.2.4 CAS 指令和原子类......... 470
21.2.5 线程安全类的应用.......... 472
21.2.6 读写锁的应用................. 476
21.2.7 线程安全性文档说明...... 477
21.2.8 不要依赖线程优先级...... 478
21.3 总结........................ 479
第22 章高性能之道............ 480
22.1 RPC 调用性能模型分析.......... 480
22.1.1 传统RPC 调用性能差的三宗罪............... 480
22.1.2 I/O 通信性能三原则........ 481
22.2 Netty 高性能之道.. 482
22.2.1 异步非阻塞通信.............. 482
22.2.2 高效的Reactor 线程模型 482
22.2.3 无锁化的串行设计.......... 485
22.2.4 高效的并发编程.............. 486
22.2.5 高性能的序列化框架...... 486
22.2.6 零拷贝.......... 487
22.2.7 内存池.......... 491
22.2.8 灵活的TCP 参数配置能力....................... 494
22.3 主流NIO 框架性能对比......... 495
22.4 总结........................ 497
第23 章可靠性.................... 498
23.1 可靠性需求............ 498
23.1.1 宕机的代价.. 498
23.1.2 Netty 可靠性需求............ 499
23.2 Netty 高可靠性设计................ 500
23.2.1 网络通信类故障.............. 500
23.2.2 链路的有效性检测.......... 507
23.2.3 Reactor 线程的保护......... 510
23.2.4 内存保护...... 513
23.2.5 流量整形...... 516
23.2.6 优雅停机接口................. 519
23.3 优化建议................ 520
23.3.1 发送队列容量上限控制... 520
23.3.2 回推发送失败的消息...... 521
23.4 总结........................ 521
第24 章安全性.................... 522
24.1 严峻的安全形势.... 522
24.1.1 OpenSSL Heart bleed 漏洞.......... 522
24.1.2 安全漏洞的代价.............. 523
24.1.3 Netty 面临的安全风险..... 523
24.2 Netty SSL 安全特性................. 525
24.2.1 SSL 单向认证.................. 525
24.2.2 SSL 双向认证.................. 532
24.2.3 第三方CA 认证.............. 536
24.3 Netty SSL 源码分析................. 538
24.3.1 客户端.......... 538
24.3.2 服务端.......... 541
24.3.3 消息读取...... 544
24.3.4 消息发送...... 545
24.4 Netty 扩展的安全特性............ 546
24.4.1 IP 地址黑名单机制.......... 547
24.4.2 接入认证...... 548
24.4 总结........................ 550
第25 章Netty 未来展望..... 551
25.1 应用范围................ 551
25.2 技术演进................ 552
25.3 社区活跃度............ 552
25.4 Road Map ............... 552
25.5 总结........................ 553
附录A Netty 参数配置表.... 554
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Netty权威指南（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>VMWARE VSPHERE 5.0虚拟化架构实战指南
第1章　VMware vSphere概述
1.1　虚拟化技术介绍
1.1.1　虚拟化介绍
1.1.2　为什么要进行虚拟化
1.1.3　虚拟化基础架构简介
1.2　VMware vSphere虚拟化架构简介
1.2.1　私有云资源池/公有云
1.2.2　架构服务
1.2.3　应用服务
1.2.4　VMware vCenter Server
1.2.5　虚拟机
1.2.6　物理体系结构与虚拟体系结构的差异
1.2.7　vSphere虚拟化架构与云计算的关系
1.2.8　vSphere 5.0新增功能
1.3　实战环境搭建
1.4　安装ESXi 5.0
1.4.1　ESXi主机安装条件
1.4.2　安装介质的准备
1.4.3　使用光盘安装ESXi 5.0主机
1.5　安装后的必要配置
1.5.1　配置ESXi主机管理地址
1.5.2　使用vSphere Client管理ESXi主机
1.5.3　使用SSH命令行管理ESXi主机
1.6　本章小结
第2章　安装VMware vCenter Server
2.1　VMware vCenter Server介绍
2.1.1　理解vCenter Server
2.1.2　vCenter Server体系结构
2.1.3　vCenter Server组件
2.2　安装Windows版VMware vCenter Server
2.2.1　准备安装环境
2.2.2　安装vCenter Server
2.2.3　ESXi主机加入vCenter Server
2.3　安装Linux版VMware vCenter Server Appliance
2.3.1　准备安装环境
2.3.2　安装vCenter Server Appliance
2.3.3　配置vCenter Server Appliance
2.4　安装VMware vSphere Web Client
2.4.1　安装vSphere Web Client
2.4.2　配置vSphere Web Client
2.5　安装VMware vCenter Server Heartbeat
2.5.1　准备安装环境
2.5.2　安装vCenter Server Heartbeat
2.6　添加授权
2.6.1　添加vCenter Server授权
2.6.2　添加ESXi主机授权
2.7　本章小结
第3章　配置虚拟交换机
3.1　虚拟交换机介绍
3.1.1　标准交换机
3.1.2　分布式交换机
3.2　ESXi主机网络组件介绍
3.2.1　物理网卡
3.2.2　虚拟机通信端口
3.2.3　核心通信端口
3.2.4　多网卡负载均衡
3.3　配置标准交换机
3.3.1　多网卡绑定以及负载均衡
3.3.2　创建基于VMkernel的标准交换机
3.3.3　分离管理网络
3.4　配置分布式交换机
3.4.1　分布式交换机创建
3.4.2　分布式交换机应用
3.5　本章小结
第4章　配置vSphere存储
4.1　常用存储设备介绍
4.1.1　直连式存储
4.1.2　网络存储
4.1.3　存储区域网络
4.1.4　小型计算机系统接口
4.1.5　以太网光纤通道
4.2　vSphere存储介绍
4.2.1　vSphere支持的存储类型
4.2.2　vSphere支持的存储文件格式
4.3　配置vSphere存储
4.3.1　配置iSCSI外部存储
4.3.2　创建iSCSI外部存储多路径访问
4.3.3　配置NFS外部存储
4.4　本章小结
第5章　部署Openfiler外部存储
5.1　安装Openfiler
5.1.1　安装介质的准备
5.1.2　安装Openfiler 2.99
5.2　安装完成后的必要配置
5.2.1　创建卷组
5.2.2　创建iSCSI逻辑卷
5.2.3　创建多路径访问iSCSI存储
5.3　本章小结
第6章　创建管理虚拟机
6.1　虚拟机介绍
6.1.1　什么是虚拟机
6.1.2　组成虚拟机文件
6.1.3　虚拟机硬件介绍
6.2　创建虚拟机
6.2.1　创建虚拟机
6.2.2　在虚拟机上安装操作系统
6.2.3　开机状态调整虚拟机硬件配置
6.2.4　挂载虚拟机到ESXi主机
6.3　虚拟机模板的使用
6.3.1　虚拟机转换为模板几个重要的问题
6.3.2　创建虚拟机模板
6.3.3　使用虚拟机模板
6.4　虚拟机快照的使用
6.4.1　创建虚拟机快照
6.4.2　使用虚拟机快照
6.5　本章小结
第7章　虚拟机实时迁移
7.1　实时迁移介绍
7.1.1　实时迁移的原理
7.1.2　实时迁移对虚拟机的要求
7.1.3　实时迁移对ESXi主机的要求
7.1.4　实时迁移对CPU的限制
7.2　迁移虚拟机
7.2.1　创建实时迁移通信端口
7.2.2　开机状态迁移虚拟机
7.2.3　关机状态迁移虚拟机
7.3　迁移虚拟机存储
7.3.1　存储迁移介绍
7.3.2　开机状态迁移存储
7.3.3　关机状态迁移存储
7.4　本章小结
第8章　使用分布式资源调配
8.1　分布式资源调配集群介绍
8.1.1　分布式资源调配集群的主要功能
8.1.2　EVC介绍
8.2　使用分布式资源调配
8.2.1　配置分布式资源调配
8.2.2　使用分布式资源调配
8.3　存储分布式资源调配
8.3.1　存储分布式资源调配介绍
8.3.2　存储分布式资源调配支持的规则
8.4　本章小结
第9章　使用虚拟机资源池
9.1　CPU虚拟化概念
9.1.1　逻辑CPU概念
9.1.2　CPU超线程
9.2　内存虚拟化概念
9.2.1　内存虚拟化的基础
9.2.2　虚拟机内存使用机制
9.3　使用资源池
9.3.1　资源池介绍
9.3.2　创建资源池
9.3.3　使用资源池
9.4　本章小结
第10章　使用虚拟机高可用性
10.1　高可用性介绍
10.1.1　vSphere提供的保护级别
10.1.2　高可用性原理
10.1.3　不同层面的高可用性介绍
10.2　配置使用高可用性
10.2.1　高可用性实施的条件
10.2.2　配置高可用性
10.3　本章小结
第11章　使用虚拟机双机热备
11.1　虚拟机双机热备技术介绍
11.1.1　vLockstep技术
11.1.2　FT的特性
11.2　使用虚拟机双机热备
11.2.1　虚拟机双机热备的要求与限制
11.2.2　配置虚拟机双机热备
11.2.3　通过调整参数配置虚拟机双机热备
11.3　本章小结
第12章　VMware vSphere安全管理
12.1　ESXi主机安全管理
12.1.1　配置ESXi主机访问权限
12.1.2　配置ESXi与AD集成
12.1.3　配置通过主机名访问ESXi主机
12.1.4　配置vCenter Server权限
12.2　配置ESXi防火墙
12.2.1　配置ESXi防火墙
12.2.2　配置ESXi主机锁定模式
12.3　本章小结
第13章　VMware vSphere性能监控与管理
13.1　使用警告管理
13.1.1　系统默认警告
13.1.2　创建自定义警告
13.2　vCenter Server性能面板
13.2.1　查看ESXi主机性能面板
13.2.2　查看虚拟机性能面板
13.3　计划任务管理
13.3.1　计划任务能够管理的工作
13.3.2　创建计划任务
13.4　本章小结
第14章　虚拟机的备份与恢复
14.1　使用VDR备份恢复虚拟机
14.1.1　VDR备份恢复原理
14.1.2　安装介质的准备
14.1.3　安装VDR
14.1.4　使用VDR备份虚拟机
14.1.5　使用VDR恢复虚拟机
14.2　使用VM Explore备份恢复
14.2.1　安装介质的准备
14.2.2　安装VM Explorer
14.2.3　使用VM Explorer备份虚拟机
14.2.4　使用VM Explorer恢复虚拟机
14.3　本章小结
第15章　物理机到虚拟机的转换
15.1　物理服务器转换为虚拟机的常见问题
15.1.1　操作系统常见问题
15.1.2　USB设备常见问题
15.1.3　外部存储设备常见问题
15.1.4　应用程序常见问题
15.2　使用VMware Converter Standalone转换物理机
15.2.1　安装介质的准备
15.2.2　安装Converter Standalone
15.2.3　使用Converter Standalone转换物理机
15.3　本章小结
第16章　VMware vSphere虚拟化架构规划实战
16.1　项目设计1：全新虚拟化架构规划
16.1.1　项目背景
16.1.2　需求分析
16.1.3　规划设计
16.1.4　实施方案
16.2　项目设计2：传统架构升级为虚拟化架构
16.2.1　项目背景
16.2.2　需求分析
16.2.3　规划设计
16.3　VMware vSphere 5.0授权方式
16.3.1　ESXi授权方式
16.3.2　vCenter Server授权方式
16.4　本章小结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>VMWARE VSPHERE 5.0虚拟化架构实战指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>RabbitMQ实战
第1章 天降奇兵 1
1.1 住在别人的地下城堡 3
1.2 救世主AMQP 5
1.3 RabbitMQ简史 5
1.4 百里挑一 8
1.5 在UNIX系统上安装RabbitMQ 8
1.5.1 为什么环境很重要--生活在Erlang 的世界里 9
1.5.2 获取安装包 9
1.5.3 设置文件夹结构 9
1.5.4 首次运行Rabbit 10
1.6 总结 12
第2章 理解消息通信13
2.1 消费者和生产者（这可不是经济学课程哦） 14
2.2 从底部开始构造：队列 17
2.3 联合起来：交换器和绑定 22
2.4 多租户模式：虚拟主机和隔离 27
2.5 我的消息去哪儿了呢？持久化和你的策略 28
2.6 把所有内容结合起来：一条消息的一生 32
2.7 使用发送方确认模式来确认投递 37
2.8 总结 40
第3章 运行和管理Rabbit 42
3.1 服务器管理 43
3.1.1 启动节点 43
3.1.2 停止节点 45
3.1.3 关闭和重启应用程序：有何差别 46
3.1.4 Rabbit 配置文件 46
3.2 请求许可 48
3.2.1 管理用户 49
3.2.2 Rabbit 的权限系统 50
3.3 检查 54
3.3.1 查看数据统计 54
3.3.2 理解RabbitMQ 日志 59
3.4 修复Rabbit：疑难解答 63
由badrpc、nodedown 和其他Erlang 引起的问题 63
3.5 总结 68
第4章 解决Rabbit相关问题：编码与模式69
4.1 解耦风雨路：谁将我们推向消息通信 70
4.1.1 异步状态思维（分离请求和动作） 70
4.1.2 提供扩展性：没有负载均衡器的世界 73
4.1.3 零成本API ：语言不应成为枷锁 73
4.2 发后即忘模型 74
4.2.1 发送告警 75
4.2.2 并行处理 84
4.3 别忘了：用RabbitMQ实现RPC并等待响应 92
4.3.1 私有队列和发送确认 93
4.3.2 使用reply_to 来实现简单的JSON RPC 93
4.4 总结 98
第5章 集群并处理失败99
5.1 开足马力：RabbitMQ集群 100
5.2 集群架构 101
5.2.1 集群中的队列 101
5.2.2 分布交换器 103
5.2.3 是内存节点还是磁盘节点 104
5.3 在你的笔记本电脑上设置集群 106
5.4 将节点分布到更多的机器上 110
5.5 升级集群节点 114
5.6 镜像队列和保留消息 115
5.6.1 声明并使用镜像队列 115
5.6.2 镜像队列工作原理 118
5.7 总结 120
第6章 从故障中恢复121
6.1 为Rabbit做负载均衡 122
6.1.1 安装HAProxy 124
6.1.2 配置HAProxy 125
6.2 连接丢失和故障转移 127
6.3 总结 134
第7章 warren和Shovel：故障转移和复制 135
7.1 warren：另一种集群方式 136
7.2 设定负载均衡器--基于主/从的集群 138
7.3 远距离通信和复制 142
7.3.1 给Rabbit 装备Shovel ：Shovel 插件介绍 142
7.3.2 安装Shovel 145
7.3.3 配置并运行Shovel 146
7.4 总结 152
第8章 从Web端管理RabbitMQ 154
8.1 超越rabbitmqctl：RabbitMQ Management插件 155
8.1.1 为何需要Management 插件 155
8.1.2 Management 插件功能 155
8.1.3 启用Management 插件 156
8.2 从Web控制台来管理RabbitMQ 158
8.2.1 监控Erlang VM 158
8.2.2 从JSON 文件导入配置 159
8.3 从Web控制台管理用户 160
8.3.1 创建用户 161
8.3.2 管理用户的权限 162
8.4 从Web控制台管理交换器和队列 163
8.4.1 列出队列信息 165
8.4.2 创建队列 166
8.5 回到命令行 168
8.5.1 为什么需要另一个CLI 168
8.5.2 CLI 管理：一种更简单的方式 170
8.5.3 安装rabbitmqadmin 脚本 170
8.5.4 清空队列、创建交换器等 171
8.6 总结 172
第9章 使用REST API控制Rabbit 173
9.1 能用RabbitMQ REST API做什么 175
9.2 对客户端授权访问 177
9.3 访问数据统计 178
9.4 自动化vhost和用户配置 181
9.5 总结 .186
第10章 监控187
10.1 监控RabbitMQ：密切关注你的warren 188
10.1.1 为Nagios 编写健康检测 188
10.1.2 使用AMQP 模拟检测来确认RabbitMQ 是否运行 190
10.1.3 使用REST API 来检测 193
10.1.4 监控配置文件修改 196
10.1.5 监控集群状态 201
10.2 确保消费者正常工作 206
10.2.1 通过AMQP 监控队列等级 208
10.2.2 使用REST API 来监控队列级别 212
10.2.3 建立队列的消息计数基准经验法则 215
10.3 总结216
第11章 提升性能，保障安全217
11.1 对速度的需求 218
11.1.1 消息持久化 218
11.1.2 消息确认 219
11.1.3 路由算法和绑定规则 219
11.1.4 投递消息 221
11.2 内存使用率和进程限制 223
11.2.1 内存使用率 223
11.2.2 Erlang 进程计数 226
11.3 SSL连接 ..227
11.3.1 SSL 证书.228
11.3.2 设置证书颁发机构 ..229
11.3.3 生成根证书 233
11.3.4 生成服务器端证书 234
11.3.5 生成客户端证书 235
11.3.6 启用RabbitMQ 的SSL 监听器 236
11.3.7 测试你的RabbitMQ SSL 设置 237
11.4 总结 239
第12章 聪明的Rabbit：扩展RabbitMQ241
12.1 RabbitMQ插件 242
12.1.1 你可以用插件做什么 242
12.1.2 在哪里可以找到插件 244
12.1.3 安装插件 244
12.1.4 移除插件 245
12.2 制作你自己的插件 247
12.2.1 获取RabbitMQ Public Umbrella 248
12.2.2 设置文件夹结构 249
12.2.3 包含插件构建系统 250
12.2.4 创建Erlang 应用文件 250
12.3 创建自定义交换器模块 252
12.3.1 将交换器注册到RabbitMQ 254
12.3.2 实现交换器behaviour 257
12.3.3 编译自定义交换器 264
12.3.4 测试你的插件 267
12.4 总结 271
附录A 在Java和.NET上使用Rabbit 273
附录B 在线资源302
附录C 在Windows上安装RabbitMQ 307
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>RabbitMQ实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式服务框架：原理与实践
第1章　应用架构演进 1
1.1 传统垂直应用架构 2
1.1.1 垂直应用架构介绍 2
1.1.2 垂直应用架构面临的挑战 4
1.2 RPC架构 6
1.2.1　RPC框架原理 6
1.2.2　最简单的RPC框架实现 8
1.2.3　业界主流RPC框架 14
1.2.4　RPC框架面临的挑战 17
1.3 SOA服务化架构 18
1.3.1　面向服务设计的原则 18
1.3.2　服务治理 19
1.4 微服务架构 21
1.4.1　什么是微服务 21
1.4.2　微服务架构对比SOA 22
1.5　总结 23
第2章　分布式服务框架入门 25
2.1　分布式服务框架诞生背景 26
2.1.1 应用从集中式走向分布式 26
2.1.2 亟需服务治理 28
2.2 业界分布式服务框架介绍 29
2.2.1　阿里Dubbo 30
2.2.2　淘宝HSF 33
2.2.3　亚马逊Coral Service 35
2.3 分布式服务框架设计 36
2.3.1　架构原理 36
2.3.2　功能特性 37
2.3.3　性能特性 39
2.3.4　可靠性 39
2.3.5　服务治理 40
2.4 总结 41
第3章　通信框架 42
3.1　关键技术点分析 43
3.1.1 长连接还是短连接 43
3.1.2 BIO还是NIO 43
3.1.3 自研还是选择开源NIO框架 46
3.2 功能设计 47
3.2.1　服务端设计 48
3.2.2　客户端设计 50
3.3 可靠性设计 53
3.3.1　链路有效性检测 54
3.3.2　断连重连机制 56
3.3.3　消息缓存重发 57
3.3.4　资源优雅释放 58
3.4 性能设计 59
3.4.1　性能差的三宗罪 59
3.4.2　通信性能三原则 60
3.4.3　高性能之道 61
3.5 最佳实践 61
3.6 总结 64
第4章　序列化与反序列化 65
4.1　几个关键概念澄清 66
4.1.1 序列化与通信框架的关系 66
4.1.2 序列化与通信协议的关系 66
4.1.3 是否需要支持多种序列化方式 67
4.2 功能设计 67
4.2.1　功能丰富度 67
4.2.2　跨语言支持 68
4.2.3　兼容性 69
4.2.4　性能 70
4.3 扩展性设计 71
4.3.1　内置的序列化/反序列化功能类 71
4.3.2　反序列化扩展 72
4.3.3　序列化扩展 75
4.4 最佳实践 77
4.4.1　接口的前向兼容性规范 77
4.4.2　高并发下的稳定性 78
4.5 总结 78
第5章　协议栈 79
5.1　关键技术点分析 80
5.1.1 是否必须支持多协议 80
5.1.2 公有协议还是私有协议 80
5.1.3 集成开源还是自研 81
5.2 功能设计 82
5.2.1　功能描述 82
5.2.2　通信模型 82
5.2.3　协议消息定义 84
5.2.4　协议栈消息序列化支持的字段类型 85
5.2.5　协议消息的序列化和反序列化 86
5.2.6　链路创建 89
5.2.7　链路关闭 90
5.3 可靠性设计 90
5.3.1　客户端连接超时 90
5.3.2　客户端重连机制 91
5.3.3　客户端重复握手保护 91
5.3.4　消息缓存重发 92
5.3.5　心跳机制 92
5.4 安全性设计 92
5.5 最佳实践—协议的前向兼容性 94
5.6 总结 95
第6章　服务路由 96
6.1　透明化路由 97
6.1.1 基于服务注册中心的订阅发布 97
6.1.2 消费者缓存服务提供者地址 98
6.2 负载均衡 98
6.2.1　随机 98
6.2.2　轮循 99
6.2.3　服务调用时延 99
6.2.4　一致性哈希 100
6.2.5　粘滞连接 101
6.3 本地路由优先策略 102
6.3.1　injvm模式 102
6.3.2　innative模式 102
6.4 路由规则 103
6.4.1　条件路由规则 103
6.4.2　脚本路由规则 104
6.5　路由策略定制 105
6.6　配置化路由 106
6.7　最佳实践—多机房路由 107
6.8 总结 108
第７章　集群容错 109
7.1　集群容错场景 110
7.1.1 通信链路故障 110
7.1.2 服务端超时 111
7.1.3 服务端调用失败 111
7.2 容错策略 112
7.2.1　失败自动切换（Failover） 112
7.2.2　失败通知（Failback） 113
7.2.3　失败缓存（Failcache） 113
7.2.4　快速失败（Failfast） 114
7.2.5　容错策略扩展 114
7.3 总结 115
第8章　服务调用 116
8.1　几个误区 117
8.1.1 NIO就是异步服务 117
8.1.2 服务调用天生就是同步的 118
8.1.3 异步服务调用性能更高 120
8.2 服务调用方式 120
8.2.1　同步服务调用 120
8.2.2　异步服务调用 121
8.2.3　并行服务调用 125
8.2.4　泛化调用 129
8.3 最佳实践 130
8.4 总结 131
第９章　服务注册中心 132
9.1　几个概念 133
9.1.1 服务提供者 133
9.1.2 服务消费者 133
9.1.3 服务注册中心 133
9.2 关键功能特性设计 134
9.2.1　支持对等集群 135
9.2.2　提供CRUD接口 136
9.2.3　安全加固 136
9.2.4　订阅发布机制 137
9.2.5　可靠性 138
9.3　基于ZooKeeper的服务注册中心设计 139
9.3.1　服务订阅发布流程设计 139
9.3.2　服务健康状态检测 141
9.3.3　对等集群防止单点故障 142
9.3.4　变更通知机制 144
9.4 总结 144
第10章　服务发布和引用 145
10.1　服务发布设计 146
10.1.1　服务发布的几种方式 146
10.1.2　本地实现类封装成代理 148
10.1.3　服务发布成指定协议 148
10.1.4　服务提供者信息注册 149
10.2 服务引用设计 150
10.2.1　本地接口调用转换成远程服务调用 150
10.2.2　服务地址本地缓存 151
10.2.3　远程服务调用 151
10.3　最佳实践 152
10.3.1　对等设计原则 152
10.3.2　启动顺序问题 153
10.3.3　同步还是异步发布服务 153
10.3.4　警惕网络风暴 154
10.3.5　配置扩展 154
10.4 总结 156
第11章　服务灰度发布 157
11.1　服务灰度发布流程设计 158
11.1.1　灰度环境准备 158
11.1.2　灰度规则设置 159
11.1.3　灰度规则下发 160
11.1.4　灰度路由 161
11.1.5　失败回滚 162
11.1.6　灰度发布总结 163
11.2　总结 163
第12章　参数传递 164
12.1　内部传参 165
12.1.1　业务内部参数传递 165
12.1.2　服务框架内部参数传递 168
12.2　外部传参 169
12.2.1　通信协议支持 169
12.2.2　传参接口定义 170
12.3　最佳实践 171
12.3.1　防止参数互相覆盖 171
12.3.2　参数生命周期管理 171
12.4　总结 172
第13章　服务多版本 173
13.1　服务多版本管理设计 174
13.1.1　服务版本号管理 174
13.1.2　服务提供者 175
13.1.3　服务消费者 175
13.1.4　基于版本号的服务路由 176
13.1.5　服务热升级 177
13.2　与OSGi的对比 178
13.2.1　模块化开发 179
13.2.2　插件热部署和热升级 184
13.2.3　不使用OSGi的其他理由 185
13.3　总结 185
第14章　流量控制 186
14.1　静态流控 187
14.1.1　传统静态流控设计方案 187
14.1.2　传统方案的缺点 188
14.1.3　动态配额分配制 188
14.1.4　动态配额申请制 190
14.2　动态流控 191
14.2.1　动态流控因子 192
14.2.2　分级流控 192
14.3　并发控制 193
14.3.1　服务端全局控制 193
14.3.2　服务消费者流控 194
14.4　连接控制 195
14.4.1　服务端连接数流控 195
14.4.2　服务消费者连接数流控 195
14.5　并发和连接控制算法 195
14.6　总结 197
第15章　服务降级 198
15.1　屏蔽降级 199
15.1.1　屏蔽降级的流程 199
15.1.2　屏蔽降级的设计实现 200
15.2　容错降级 202
15.2.1　容错降级的工作原理 202
15.2.2　运行时容错降级 204
15.3　业务层降级 205
15.4　总结 205
第16章　服务优先级调度 207
16.1　设置服务优先级 208
16.2　线程调度器方案 209
16.3　Java优先级队列 210
16.4　加权优先级队列 211
16.5　服务迁入迁出 212
16.6　总结 213
第17章　服务治理 214
17.1　服务治理技术的历史变迁 215
17.1.1　SOA Governance 215
17.1.2　分布式服务框架服务治理 217
17.1.3　AWS云端微服务治理 217
17.2　应用服务化后面临的挑战 218
17.2.1　跨团队协作问题 219
17.2.2　服务的上下线管控 220
17.2.3　服务安全 220
17.2.4　服务SLA保障 221
17.2.5　故障快速定界定位 221
17.3　服务治理 222
17.3.1　服务治理架构设计 223
17.3.2　运行态服务治理功能设计 225
17.3.3　线下服务治理 232
17.3.4　安全和权限管理 234
17.4　总结 237
第18章　分布式消息跟踪 239
18.1　业务场景分析 240
18.1.1　故障的快速定界定位 240
18.1.2　调用路径分析 241
18.1.3　调用来源和去向分析 242
18.2　分布式消息跟踪系统设计 242
18.2.1　系统架构 243
18.2.2　埋点日志 244
18.2.3　采样率 247
18.2.4　采集和存储埋点日志 248
18.2.5　计算和展示 249
18.2.6　调用链扩展 251
18.3　总结 251
第19章　可靠性设计 253
19.1　服务状态检测 254
19.1.1　基于服务注册中心状态检测 254
19.1.2　链路有效性状态检测机制 255
19.2　服务健康度检测 256
19.3　服务故障隔离 257
19.3.1　进程级故障隔离 257
19.3.2　VM级故障隔离 259
19.3.3　物理机故障隔离 260
19.3.4　机房故障隔离 261
19.4　其他可靠性特性 262
19.4.1　服务注册中心 262
19.4.2　监控中心 262
19.4.3　服务提供者 262
19.5　总结 263
第20章　微服务架构 264
20.1　微服务架构产生的历史背景 265
20.1.1　研发成本挑战 265
20.1.2　运维成本高 267
20.1.3　新需求上线周期长 268
20.2　微服务架构带来的改变 268
20.2.1　应用解耦 268
20.2.2　分而治之 270
20.2.3　敏捷交付 271
20.3　微服务架构解析 271
20.3.1　微服务划分原则 272
20.3.2　开发微服务 272
20.3.3　基于Docker容器部署微服务 274
20.3.4　治理和运维微服务 277
20.3.5　特点总结 278
20.4　总结 279
第21章　服务化最佳实践 280
21.1　性能和时延问题 281
21.1.1　RPC框架高性能设计 281
21.1.2　业务最佳实践 285
21.2　事务一致性问题 286
21.2.1　分布式事务设计方案 287
21.2.2　分布式事务优化 288
21.3　研发团队协作问题 289
21.3.1　共用服务注册中心 290
21.3.2　直连提供者 290
21.3.3　多团队进度协同 291
21.3.4　服务降级和Mock测试 291
21.3.5　协同调试问题 292
21.3.6　接口前向兼容性 292
21.4　总结 292
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式服务框架：原理与实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker容器实战：原理、架构与应用
第1篇  Docker基础知识介绍
第１章　云计算简介	2
1.1  虚拟化技术的分类和历史	3
1.1.1  硬件级虚拟化历史	3
1.1.2  操作系统级虚拟化历史	4
1.2  云计算服务模式	4
1.3  Docker介绍	5
1.3.1  Docker主要解决什么问题	6
1.3.2  Docker的历史	6
1.3.3  Docker是什么	6
1.4  Linux快速入门	7
1.4.1  选取什么发行版本	7
1.4.2  使用图形界面还是命令行界面	8
1.4.3  英文还是中文	8
1.4.4  安装Ubuntu 14.04	8
1.4.5  Linux常用工具	11
1.4.6  启用root 用户	12
1.4.7  使用vim	12
1.4.8  配置网络	13
1.4.9  启用SSH Server	13
1.4.10  通过客户端远程连接Linux主机	14
1.4.11  免密码登录Linux主机	15
1.4.12  安装软件	15
1.4.13  公有云主机快速入门	16
1.4.14  购买云主机	17
1.4.15  连接到云主机	19
1.5  习题	21
第2章　Docker的安装	22
2.1  在Ubuntu下安装Docker	22
2.1.1  前置条件	22
2.1.2  更新apt源	23
2.1.3  Ubuntu 14.04特殊处理	24
2.1.4  正式安装	24
2.2  在CentOS下安装	26
2.2.1  前置条件	26
2.2.2  更新yum	26
2.2.3  添加仓库	26
2.2.4  正式安装	26
2.3  通过Ghostcloud进行安装	27
2.3.1  注册Ghostcloud账号	28
2.3.2  接入新主机	28
2.3.3  获取安装脚本	28
2.3.4  验证Docker安装是否成功	30
2.3.5  运行第一个容器	30
2.4  通过官方的安装脚本安装	31
2.5  在非Linux系统下安装Docker	32
2.6  习题	32
第3章　使用Docker	33
3.1  运行hello-world	33
3.2  容器和镜像	35
3.2.1  什么是容器	35
3.2.2  什么是镜像	35
3.2.3  容器和镜像的关系	36
3.3  Docker入门操作	36
3.3.1  查看Docker基本信息	36
3.3.2  下载第一个基础镜像	37
3.3.3  运行一个含shell终端的容器	38
3.3.4  查看容器运行	38
3.3.5  运行长时间容器	38
3.3.6  查看所有容器	39
3.4  习题	40
第2篇  Docker的基本使用
第4章　Docker深入解析	42
4.1  Docker的架构	42
4.2  Docker如何工作	43
4.2.1  Docker Image工作方式	43
4.2.2  Docker Registry工作方式	44
4.2.3  容器工作方式	44
4.2.4  底层的技术	45
4.3  Docker Client和Daemon	46
4.4  通过容器运行Web应用	47
4.4.1  使用国内仓库	48
4.4.2  拉取apache-php镜像	48
4.4.3  运行镜像	48
4.4.4  网页访问	48
4.4.5  修改页面内容	49
4.4.6  持久化容器	50
4.5  镜像制作	50
4.5.1  查看本机镜像	50
4.5.2  获取镜像的三种方式	51
4.5.3  查找DockerHub镜像	51
4.5.4  查找其他仓库镜像	52
4.5.5  push镜像	54
4.5.6  根据Dockerfile编译镜像	55
4.5.7  删除镜像	56
4.6  docker run命令	56
4.6.1  docker run的语法格式	56
4.6.2  前后台运行	57
4.6.3  容器的标识	57
4.6.4  PID设置	58
4.6.5  UTS(--uts)设置	58
4.6.6  IPC(--ipc)设置	59
4.6.7  网络设置	59
4.6.8  重启策略（--restart）	60
4.6.9  Clean up (--rm)	61
4.6.10  CGroups控制	61
4.6.11  特权模式和Capabilities	61
4.6.12  日志驱动（--log-driver）	62
4.6.13  覆盖image的默认参数	62
4.7  习题	63
第5章　容器的网络	64
5.1  容器自带网络	64
5.2  网络详情	65
5.3  用户自定义网络	67
5.3.1  桥接网络	67
5.3.2  Overlay网络	68
5.4  习题	71
第6章　容器的数据	72
6.1  数据卷	72
6.1.1  创建一个数据卷	72
6.1.2  映射一个外部卷	73
6.2  使用数据型容器	73
6.3  备份、还原和迁移数据卷	73
6.4  容器和代码进行关联	74
6.5  习题	74
第7章　镜像仓库	75
7.1  仓库相关的Docker命令	75
7.1.1  登录	75
7.1.2  查找	76
7.1.3  拉取	76
7.1.4  提交	76
7.2  习题	76
第3篇  Docker的高级使用
第8章　镜像和容器的存储结构	78
8.1  镜像、容器和存储驱动的关系	78
8.1.1  镜像和镜像层	78
8.1.2  镜像存储方式	80
8.1.3  一个迁移例子	81
8.1.4  容器和容器层	82
8.1.5  写时复制策略	83
8.1.6  使用共享技术减小镜像体积	83
8.1.7  使用复制技术加快容器启动时间	86
8.1.8  数据卷和存储驱动	90
8.2  如何选择存储驱动	90
8.2.1  存储设备和存储驱动	92
8.2.2  如何存储驱动	92
8.3  AUFS存储驱动	94
8.3.1  AUFS中的镜像	94
8.3.2  AUFS中的容器读写	95
8.3.3  在AUFS中删除文件	95
8.3.4  如何配置AUFS	96
8.3.5  镜像的存储方式	96
8.3.6  容器的存储方式	97
8.3.7  AUFS的性能	99
8.4  Devicemapper存储驱动	99
8.4.1  Devicemapper中的镜像	100
8.4.2  Devicemapper中的读操作	101
8.4.3  Devicemapper中的写操作	102
8.4.4  如何配置Devicemapper	103
8.4.5  在生产环境中配置direct-lvm模式	104
8.4.6  Devicemapper的存储方式	107
8.4.7  动态扩容loop-lvm模式下的thin pool	108
8.4.8  动态扩容direct-lvm模式下的thin pool	110
8.4.9  Devicemapper的性能	110
8.5  Btrfs存储驱动	111
8.5.1  Btrfs中的镜像	112
8.5.2  Btrfs的存储方式	114
8.5.3  Btrfs中的读写	114
8.5.4  如何配置Btrfs	115
8.5.5  Btrfs的性能	116
8.6  ZFS存储驱动	117
8.6.1  ZFS中的镜像	117
8.6.2  ZFS中的读写	118
8.6.3  如何配置ZFS	119
8.6.4  ZFS的性能	121
8.7  Overlay存储驱动	122
8.7.1  Overlay中的镜像	122
8.7.2  Overlay2中的镜像	125
8.7.3  Overlay中的读写	127
8.7.4  如何配置Overlay/Overlay2	127
8.7.5  Overlay的性能	128
8.8  习题	129
第9章　定制Docker Daemon	130
9.1  修改Docker Daemon的三种方式	130
9.1.1  直接启动Docker Daemon	132
9.1.2  修改Docker Daemon启动项	132
9.1.3  自定义Docker Daemon配置文件	135
9.2  仓库相关配置	137
9.2.1  --disable-legacy-registry选项	137
9.2.2  --registry-mirror选项	138
9.2.3  --insecure-registry选项	139
9.3  安全相关配置	139
9.3.1  -p, --pidfile选项	139
9.3.2  -H, --host选项	139
9.3.3  --tls, --tlscacert, --tlscert, --tlskey, --tlsverify选项	141
9.4  日志相关	145
9.4.1  -D，--debug选项	145
9.4.2  --log-level选项	145
9.4.3  --log-driver和--log-opt选项	146
9.5  存储相关配置	148
9.5.1  -g, --graph选项	148
9.5.2  --storage-driver选项	148
9.5.3  --storage-opt选项	149
9.6  网桥相关配置	154
9.6.1  --bip选项	154
9.6.2  --fixed-cidr，--fixed- cidr-v6选项	154
9.6.3  --mtu选项	155
9.6.4  -b, --bridge选项	155
9.7  容器与外部通信	156
9.7.1  --ip-forward选项	156
9.7.2  --iptables选项	156
9.7.3  --ip, --ipv6选项	156
9.8  其他网络配置	157
9.8.1  --default-gateway、--default-gateway-v6选项	157
9.8.2  --dns，--dns-opt，--dns-search选项	158
9.9  execdriver配置	158
9.9.1  --exec-opt选项	158
9.9.2  --exec-root选项	159
9.10  其他配置	159
9.11  习题	159
第10章　如何编写Dockerfile	160
10.1  本地编译镜像	160
10.2  dockerignore文件	162
10.3  Dockerfile格式	163
10.4  Dockerfile指令详解	163
10.4.1  FROM指令	163
10.4.2  MAINTAINER指令	164
10.4.3  RUN指令	164
10.4.4  CMD指令	164
10.4.5  LABEL指令	165
10.4.6  EXPOSE指令	166
10.4.7  ENV指令	166
10.4.8  ADD指令	168
10.4.9  COPY指令	169
10.4.10  ENTRYPOINT指令	170
10.4.11  VOLUME指令	173
10.4.12  USER指令	174
10.4.13  WORKDIR指令	174
10.4.14  ARG指令	175
10.4.15  ONBUILD指令	177
10.4.16  STOPSIGNAL指令	178
10.5  CMD、ENTRYPOINT和RUN的区别	178
10.6  习题	179
第11章　Dockerfile最佳实践	181
11.1  基本原则	181
11.2  Dockerfile指令最佳实践	183
11.2.1  FROM指令最佳实践	183
11.2.2  RUN指令最佳实践	183
11.2.3  CMD指令最佳实践	185
11.2.4  EXPOSE指令最佳实践	186
11.2.5  ENV指令最佳实践	188
11.2.6  ADD和COPY指令最佳实践	189
11.2.7  ENTRYPOINT指令最佳实践	191
11.2.8  VOLUME指令最佳实践	194
11.2.9  UESR指令最佳实践	196
11.2.10  使用gosu工具	196
11.2.11  WORKDIR指令最佳实践	198
11.2.12  ONBUILD指令最佳实践	199
11.3  如何减小镜像体积	199
11.4  一些官方镜像的Dockerfile	205
11.4.1  Golang镜像	205
11.4.2  Perl镜像	208
11.4.3  Hy镜像	209
11.4.4  Rails镜像	210
11.5  习题	211
第12章　使用容器提供服务	212
12.1  使用容器提供数据库服务	212
12.1.1  使用容器提供MySQL	212
12.1.2  使用容器提供MongoDB	215
12.2  如何使用容器提供Web服务	217
12.2.1  使用容器提供Apache HTTP服务	217
12.2.2  使用容器提供Django服务	218
12.2.3  使用容器提供Gitlab服务	219
12.3  如何使用容器提供编程环境	220
12.3.1  使用容器提供Java环境	221
12.3.2  使用容器提供Golang环境	222
12.4  习题	225
第13章　建立私有镜像仓库	226
13.1  镜像仓库配置详解	227
13.2  version选项	231
13.3  log选项	231
13.4  hooks选项	231
13.5  storage选项	232
13.5.1  filesystem选项	233
13.5.2  azure选项	234
13.5.3  gcs选项	234
13.5.4  s3选项	234
13.5.5  swift选项	235
13.5.6  oss选项	236
13.5.7  delete选项	237
13.5.8  cache选项	237
13.5.9  maintenance选项	237
13.5.10  redirect选项	238
13.6  auth选项	238
13.6.1  silly选项	239
13.6.2  token选项	239
13.6.3  htpasswd选项	239
13.7  middleware选项	240
13.8  reporting选项	241
13.8.1  bugsnag选项	241
13.8.2  newrelic选项	241
13.9  http选项	242
13.9.1  tls选项	242
13.9.2  debug选项	243
13.9.3  headers选项	243
13.10  notifications选项	243
13.11  redis选项	244
13.12  health选项	245
13.12.1  storagedriver选项	245
13.12.2  file选项	246
13.12.3  http选项	246
13.12.4  tcp选项	246
13.13  proxy选项	247
13.14  镜像仓库配置实例	247
13.14.1  启动容器数据持久化	247
13.14.2  使用文件系统保存镜像	248
13.14.3  使用对象存储保存镜像	248
13.14.4  通过中间件使用CDN服务	249
13.15  习题	250
第4篇  Docker常见问题
第14章　Docker常见问题	252
14.1  Docker基础问题	252
14.1.1  什么是虚拟化技术	252
14.1.2  虚拟化有哪些分类	252
14.1.3  Docker目前支持哪些操作系统	253
14.1.4  哪种系统最适合运行Docker	253
14.1.5  Docker有什么好处	253
14.1.6  容器化技术是什么时候出现的	253
14.1.7  Docker和虚拟机有什么区别	253
14.1.8  使用Docker容器需要什么基础知识	254
14.1.9  如何学习Docker	254
14.2  Docker高级问题	255
14.2.1  Docker是否安全	255
14.2.2  如何修改已经运行的容器	255
14.2.3  容器有哪些网络模式	255
14.2.4  容器如何进行持久化	256
14.2.5  为什么进入容器，但退出后容器就停止了	256
14.2.6  容器停止了，如何分析原因	256
14.2.7  Link容器是什么意思	256
14.2.8  容器环境变量有什么用途	256
14.2.9  容器中CPU、磁盘IO、网络损耗大吗	257
14.3  镜像相关	257
14.3.1  什么是Dockerfile	257
14.3.2  Dockerfile书写的最佳实践是什么	257
14.3.3  容器运行中Entrypoint和CMD的区别	258
14.3.4  Docker中容器镜像的区别	258
14.3.5  Docker的镜像仓库有哪些	259
14.3.6  如何拥有私有仓库	259
14.4  Docker三剑客	260
14.4.1  什么是Docker Machine	260
14.4.2  什么是Docker Compose	260
14.4.3  什么是Docker Swarm	260
14.5  习题	260
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker容器实战：原理、架构与应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>开源IT系统及应用架构宝典
第1章　开源协议简介　1
第2章　网络存储系统配置与应用　5
2.1　freenas：将普通pc变成网络存储服务器的操作系统　7
2.1.1　freenas安装　7
2.1.2　freenas磁盘配置　11
2.1.3　freenas服务配置　16
2.1.4　freenas其他配置　28
2.2　openfiler：linux下基于浏览器的网络存储服务器　31
2.2.1　openfiler安装　32
2.2.2　openfiler磁盘配置　36
2.2.3　openfiler服务配置　38
2.2.4　openfiler其他配置　44
2.3　网络存储系统应用案例　46
2.4　网络存储系统解决方案比较　54
第3章　文件服务配置与应用　59
3.1　proftpd：易于配置的ftp服务器　60
3.1.1　proftpd安装　60
3.1.2　proftpd配置　61
3.1.3　proftpd防病毒　70
3.2　vsftpd：小巧轻快/安全的ftp服务器　72
.3.2.1　vsftpd安装　72
3.2.2　vsftpd配置　73
3.3　samba：功能强大的文件打印共享服务器　82
3.3.1　samba安装　82
3.3.2　samba配置　82
3.3.3　samba防病毒　103
3.4　文件服务器实用配置案例　104
3.4.1　企业全功能ftp配置案例　104
3.4.2　企业全功能samba配置案例　108
3.5　文件服务器解决方案比较　111
第4章　web服务器配置与应用　113
4.1　apache：流行的web服务器　114
4.1.1　apache安装　115
4.1.2　apache配置　115
4.1.3　apache安全　142
4.1.4　apache实用工具　144
4.2　nginx：高性能的http和反向代理服务器　152
4.2.1　nginx安装　153
4.2.2　nginx配置　163
4.2.3　负载均衡配置　167
4.3　lighttpd：高性能的web服务器　175
4.3.1　lighttpd安装　176
4.3.2　lighttpd配置　181
4.4　web服务器比较　184
第5章　代理服务配置与应用　185
5.1　squid：功能强大的代理服务器　186
5.1.1　squid 2.6安装　187
5.1.2　squid 2.6基本配置　187
5.1.3　squid 2.6高级配置　196
5.1.4　squid 3.0安装　207
5.1.5　squid 3.0配置　209
5.1.6　squid实用工具　210
5.2　havp：支持病毒过滤的代理服务器　213
5.3　apache+nginx+squid大型web服务器架构搭建案例　214
5.3.1　配置数据库服务器　215
5.3.2　配置web服务器　216
5.3.3　配置后端反向代理服务器　220
5.3.4　配置前端反向代理服务器　221
第6章　邮件服务配置与应用　225
6.1　postfix：流行的邮件服务器　228
6.1.1　postfix安装　228
6.1.2　postfix配置　229
6.1.3　postfix安全　235
6.2　pop3/imap服务器　257
6.2.1　dovecot：易于配置的pop3/imap服务器　257
6.2.2　courier-imap：流行的pop3/imap服务器　258
6.3　webmail　259
6.3.1　squirrelmail：没有使用任何javascript代码的webmail　260
6.3.2　extmail：面向大容量应用的高性能webmail　261
6.4　iredmail：快速部署功能完善的shell脚本　261
6.5　大型企业全功能邮件服务器案例　267
第7章　数据库系统配置与应用　280
7.1　postgresql：大型对象-关系数据库管理系统　282
7.1.1　postgresql安装　282
7.1.2　postgresql配置　284
7.1.3　postgresql实用工具　307
7.2　mysql：流行的中/小型关系型数据库管理系统　308
7.2.1　mysql安装　309
7.2.2　mysql实用工具　309
7.3　数据库管理系统比较　316
第8章　vpn服务器配置及应用　318
8.1　openvpn：具备完全特征的ssl vpn　319
8.1.1　openvpn服务器端安装及配置　319
8.1.2　openvpn客户端安装及配置　322
8.2　pptpd：windows客户端默认支持的vpn　323
8.2.1　pptpd服务器端安装及配置　323
8.2.2　pptp客户端安装及配置　325
第9章　网络管理工具应用　327
9.1　wireshark/ethereal：网络数据采集分析工具　328
9.1.1　wireshark安装　328
9.1.2　wireshark使用　329
9.2　cacti：功能强大的监测分析工具　335
9.2.1　cacti安装　335
9.2.2　cacti使用　342
9.2.3　cacti脚本及模板　349
9.2.4　cacti插件　358
9.3　nagios：监视系统运行状态/网络信息的监视系统　358
9.3.1　nagios安装　359
9.3.2　nagios配置　362
第10章　应用服务配置与应用　372
10.1　bbs平台　379
10.1.1　dvbbs：国内最流行的bbs平台　379
10.1.2　discuz!：性能优异/功能全面的bbs平台　381
10.2　博客平台　383
10.2.1　wordpress：应用最广泛的博客平台　384
10.2.2　x-space：以博客功能为核心结合多种web 2.0应用元素　386
10.3　微博平台　391
10.3.1　statusnet　391
10.3.2　pagecookery　392
10.4　内容管理　394
10.4.1　dedecms：国内最流行的内容管理系统　395
10.4.2　mambo：功能丰富的动态门户引擎/内容管理系统　399
10.5　wiki知识库　402
10.6　社交/交友　405
10.7　电子商务平台　408
第11章　企业开源it系统案例　412
11.1　项目概要　413
11.2　项目实施　414
11.2.1　服务器操作系统安装　414
11.2.2　服务器初始配置　420
11.2.3　内部服务器配置　424
11.2.4　外围服务建立　453
后记　467
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>开源IT系统及应用架构宝典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>系统架构设计师考试试题分类精解与题型练习
第1章  操作系统　1.1  例题分析　1.2  同步练习　1.3  同步练习解析第2章  数据库系统　2.1  例题分析　2.2  同步练习　2.3  同步练习解析第3章  数据通信与计算机网络　3.1  例题分析　3.2  同步练习　3.3  同步练习解析第4章  多媒体基础知识　4.1  例题分析　4.2  同步练习　4.3  同步练习解析第5章  系统性能评价　5.1  例题分析　5.2  同步练习　5.3  同步练习解析第6章  信息系统基础知识　6.1  例题分析　6.2  同步练习　6.3  同步练习解析第7章  系统开发基础知识　7.1  例题分析　7.2  同步练习　7.3  同步练习解析第8章  面向对象方法　8.1  例题分析　8.2  同步练习　8.3  同步练习解析第9章  开发管理　9.1  例题分析　9.2  同步练习　9.3  同步练习解析第10章  软件架构设计　10.1  例题分析　10.2  同步练习　10.3  同步练习解析第11章  系统安全性和保密性　11.1  例题分析　11.2  同步练习　11.3  同步练习解析第12章  系统可靠性　12.1  例题分析　12.2  同步练习　12.3  同步练习解析第13章  知识产权与法律法规　13.1  例题分析　13.2  同步练习　13.3  同步练习解析第14章  标准化知识　14.1  例题分析　14.2  同步练习　14.3  同步练习解析第15章  应用数学　15.1  例题分析　15.2  同步练习　15.3  同步练习解析第16章  专业英语　16.1  例题分析　16.2  同步练习　16.3  同步练习解析第17章  系统架构设计案例分析　17.1  例题分析    17.1.1  例题1：系统建模　　17.1.2  例题2：嵌入式系统设计　　17.1.3  例题3：企业应用框架设计　　17.1.4  例题4：业务持续与灾难恢复　　17.1.5  例题5：系统可靠性设计　　17.1.6  例题6：工作流设计　　17.1.7  例题7：分布式系统设计　　17.1.8  例题8：软件产品线设计　17.2  同步练习　　17.2.1  练习1：三层架构设计　　17.2.2  练习2：嵌入式系统设计　　17.2.3  练习3：数据备份与恢复　　17.2.4  练习4：系统安全架构　　17.2.5  练习5：软件容错设计　　17.2.6  练习6：系统建模　　17.2.7  练习7：软件架构建模　　17.2.8  练习8：SOA架构设计　17.3  同步练习解析　　17.3.1  练习1解析　　17.3.2  练习2解析　　17.3.3  练习3解析　　17.3.4  练习4解析　　17.3.5  练习5解析　　17.3.6  练习6解析　　17.3.7  练习7解析　　17.3.8  练习8解析　17.4  同步练习解答要点　　17.4.1  练习1解答要点　　17.4.2  练习2解答要点　　17.4.3  练习3解答要点　　17.4.4  练习4解答要点　　17.4.5  练习5解答要点　　17.4.6  练习6解答要点　　17.4.7  练习7解答要点　　17.4.8  练习8解答要点第18章  系统架构设计论文　18.1  例题分析　　18.1.1  例题1：论软件的可复用性设计　　18.1.2  例题2：论工作流相关技术　　18.1.3  例题3：论设计模式在软件开发中的应用　　18.1.4  例题4：论开放系统应用的互操作性技术　　18.1.5  例题5：论系统的可靠性设计　　18.1.6  例题6：论系统的安全与保密设计　　18.1.7  例题7：论软件架构风格及其应用　　18.1.8  例题8：论SOA 在企业信息化中的应用　18.2  同步练习　　18.2.1  练习1：论中间件技术在软件开发中的作用　　18.2.2  练习2：论Web Service技术的应用与发展趋势　　18.2.3  练习3：论高可靠性系统中软件容错技术的应用　　18.2.4  练习4：论改进数据库应用系统的性能　　18.2.5  练习5：论电子商务的安全　　18.2.6  练习6：论基于场景的软件架构评估方法　　18.2.7  练习7：论图形用户界面技术　　18.2.8  练习8：论多层分布式结构系统的开发　18.3  同步练习解析　　18.3.1  练习1解析　　18.3.2  练习2解析　　18.3.3  练习3解析　　18.3.4  练习4解析　　18.3.5  练习5解析　　18.3.6  练习6解析　　18.3.7  练习7解析　　18.3.8  练习8解析　18.4  同步练习解答要点　　18.4.1  练习1解答要点　　18.4.2  练习2解答要点　　18.4.3  练习3解答要点　　18.4.4  练习4解答要点　　18.4.5  练习5解答要点　　18.4.6  练习6解答要点　　18.4.7  练习7解答要点　　18.4.8  练习8解答要点附录A  系统架构设计师考试大纲  一、考试说明　二、考试范围    考试科目1：信息系统综合知识　　考试科目2：系统架构设计案例分析　　考试科目3：系统架构设计论文　三、题型举例　　（一）选择题　　（二）问答题　　（三）论文题主要参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>系统架构设计师考试试题分类精解与题型练习
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构探险：轻量级微服务架构（下册）
第1章　轻量级的微服务
1.1　微服务将变得轻量级
1.1.1　架构与架构师
1.1.2　架构演进过程
1.1.3　微服务架构发展趋势
1.2　微服务架构前期准备
1.2.1　认识微服务架构冰山模型
1.2.2　冰山下的微服务基础设施
1.2.3　根据业务切分微服务边界
1.3　轻量级微服务架构图
1.3.1　轻量级微服务部署架构
1.3.2　轻量级微服务运行架构
1.3.3　轻量级微服务全局架构
1.4　本章小结
第2章　微服务日志
2.1　使用Spring Boot日志框架
2.1.1　使用Spring Boot Logging插件
2.1.2　集成Log4J日志框架
2.1.3　将日志输出到Docker容器外
2.2　使用Docker容器日志
2.2.1　Docker日志驱动
2.2.2　Linux日志系统：Syslog
2.2.3　Docker日志架构
2.3　搭建应用日志中心
2.3.1　开源日志中心：ELK
2.3.2　日志存储系统：Elasticsearch
2.3.3　日志收集系统：Logstash
2.3.4　日志查询系统：Kibana
2.3.5　搭建ELK日志中心
2.4  本章小结
第3章　微服务监控
3.1　使用Spring Boot监控系统
3.1.1　Spring Boot自带的监控功能
3.1.2　Spring Boot Admin开源监控系统
3.2　搭建系统监控中心
3.2.1　时序数据收集系统：cAdvisor
3.2.2　时序数据存储系统：InfluxDB
3.2.3　时序数据分析系统：Grafana
3.2.4　集成InfluxDB + cAdvisor + Grafana
3.3　搭建调用追踪中心
3.3.1　开源调用追踪中心：Zipkin
3.3.2　追踪微服务调用链
3.3.3　追踪数据库调用链
3.4  本章小结
第4章　微服务通信
4.1　使用HTTP实现同步调用
4.1.1　使用Spring Boot开发服务端
4.1.2　使用Spring RestTemplate开发客户端
4.1.3　使用OkHttp开发客户端
4.1.4　使用Retrofit开发客户端
4.2　使用RPC实现同步调用
4.2.1　RPC通信原理
4.2.2　初步体验gRPC
4.2.3　Spring Boot集成gRPC
4.3　搭建分布式RPC框架
4.3.1　架构设计
4.3.2　搭建模块代码框架
4.3.3　开发RPC服务端
4.3.4　开发RPC客户端
4.4　本章小结
第5章　微服务解耦
5.1　使用MQ实现异步调用
5.1.1　使用ActiveMQ实现JMS异步调用
5.1.2　使用RabbitMQ实现AMQP异步调用
5.2　使用请求应答模式实现RPC调用
5.2.1　请求应答模式简介
5.2.2  使用RabbitMQ实现RPC调用
5.2.3　封装RabbitMQ的RPC代码框架
5.3　解决分布式事务问题
5.3.1　什么是Event-Sourcing
5.3.2　使用Event-Sourcing与MQ实现分布式事务控制
5.4  本章小结
第6章　微服务测试
6.1　使用Spring Boot单元测试
6.1.1　搭建待测应用程序框架
6.1.2　测试Service层
6.1.3　测试REST API
6.2　搭建REST API自动化测试框架
6.2.1　使用Postman手工测试REST API
6.2.2　使用Newman批量测试REST API
6.2.3　搭建REST API自动化测试框架
6.3　自动生成REST API文档
6.3.1　使用Swagger生成REST API文档
6.3.2　REST API文档的另一选择：apiDoc
6.4　本章小结
第7章　微服务配置
7.1　Ansible入门与实战
7.1.1　Ansible是什么
7.1.2　准备Ansible实战环境
7.1.3　Ansible实战
7.2　搭建服务配置中心
7.2.1　如何管理微服务中的配置
7.2.2　设计Ansible配置中心
7.2.3　动手实现自动化部署框架
7.3　自注册服务配置
7.3.1　目前服务注册存在的问题
7.3.2　使用Registrator实现服务自注册
7.3.3　微服务平滑升级解决方案
7.4　本章小结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构探险：轻量级微服务架构（下册）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Spring 4.x
第1篇 基础篇
第1章 Spring概述\t2
1．1 认识Spring\t2
1．2 关于SpringSource\t4
1．3 Spring带给我们什么\t5
1．4 Spring体系结构\t6
1．5 Spring对Java版本的要求\t8
1．6 Spring 4．0新特性\t8
1．6．1 全面支持Java 8．0\t9
1．6．2 核心容器的增强\t11
1．6．3 支持用Groovy定义Bean\t12
1．6．4 Web的增强\t12
1．6．5 支持WebSocket\t12
1．6．6 测试的增强\t13
1．6．7 其他\t13
1．7 Spring子项目\t13
1．8 如何获取Spring\t15
1．9 小结\t16
第2章 快速入门\t17
2．1 实例概述\t17
2．1．1 比Hello World更适用的实例\t18
2．1．2 实例功能简介\t18
2．2 环境准备\t20
2．2．1 构建工具Maven\t20
2．2．2 创建库表\t22
2．2．3 建立工程\t23
2．2．4 类包及Spring配置文件规划\t28
2．3 持久层\t29
2．3．1 建立领域对象\t29
2．3．2 UserDao\t30
2．3．3 LoginLogDao\t33
2．3．4 在Spring中装配DAO\t34
2．4 业务层\t35
2．4．1 UserService\t35
2．4．2 在Spring中装配Service\t37
2．4．3 单元测试\t38
2．5 展现层\t40
2．5．1 配置Spring MVC框架\t40
2．5．2 处理登录请求\t42
2．5．3 JSP视图页面\t44
2．6 运行Web应用\t46
2．7 小结\t48
第3章 Spring Boot\t49
3．1 Spring Boot概览\t49
3．1．1 Spring Boot发展背景\t50
3．1．2 Spring Boot特点\t50
3．1．3 Spring Boot启动器\t50
3．2 快速入门\t52
3．3 安装配置\t54
3．3．1 基于Maven环境配置\t54
3．3．2 基于Gradle环境配置\t56
3．3．3 基于Spring Boot CLI环境
配置\t57
3．3．4 代码包结构规划\t58
3．4 持久层\t59
3．4．1 初始化配置\t59
3．4．2 UserDao\t61
3．5 业务层\t62
3．6 展现层\t64
3．6．1 配置pom．xml依赖\t64
3．6．2 配置Spring MVC框架\t65
3．6．3 处理登录请求\t65
3．7 运维支持\t67
3．8 小结\t70
第2篇 核心篇
第4章 IoC容器\t72
4．1 IoC概述\t72
4．1．1 通过实例理解IoC的概念\t73
4．1．2 IoC的类型\t75
4．1．3 通过容器完成依赖关系的
注入\t77
4．2 相关Java基础知识\t78
4．2．1 简单实例\t78
4．2．2 类装载器ClassLoader\t80
4．2．3 Java反射机制\t83
4．3 资源访问利器\t85
4．3．1 资源抽象接口\t85
4．3．2 资源加载\t88
4．4 BeanFactory和ApplicationContext\t91
4．4．1 BeanFactory介绍\t92
4．4．2 ApplicationContext介绍\t94
4．4．3 父子容器\t103
4．5 Bean的生命周期\t103
4．5．1 BeanFactory中Bean的生命
周期\t103
4．5．2 ApplicationContext中Bean
的生命周期\t112
4．6 小结\t114
第5章 在IoC容器中装配Bean\t115
5．1 Spring配置概述\t116
5．1．1 Spring容器高层视图\t116
5．1．2 基于XML的配置\t117
5．2 Bean基本配置\t120
5．2．1 装配一个Bean\t120
5．2．2 Bean的命名\t120
5．3 依赖注入\t121
5．3．1 属性注入\t121
5．3．2 构造函数注入\t124
5．3．3 工厂方法注入\t128
5．3．4 选择注入方式的考量\t130
5．4 注入参数详解\t130
5．4．1 字面值\t130
5．4．2 引用其他Bean\t131
5．4．3 内部Bean\t133
5．4．4 null值\t133
5．4．5 级联属性\t134
5．4．6 集合类型属性\t134
5．4．7 简化配置方式\t138
5．4．8 自动装配\t141
5．5 方法注入\t142
5．5．1 lookup方法注入\t142
5．5．2 方法替换\t143
5．6 ＜bean＞之间的关系\t144
5．6．1 继承\t144
5．6．2 依赖\t145
5．6．3 引用\t146
5．7 整合多个配置文件\t147
5．8 Bean作用域\t148
5．8．1 singleton作用域\t148
5．8．2 prototype作用域\t149
5．8．3 与Web应用环境相关的Bean
作用域\t150
5．8．4 作用域依赖问题\t152
5．9 FactoryBean\t153
5．10 基于注解的配置\t155
5．10．1 使用注解定义Bean\t155
5．10．2 扫描注解定义的Bean\t156
5．10．3 自动装配Bean\t157
5．10．4 Bean作用范围及生命过程
方法\t162
5．11 基于Java类的配置\t164
5．11．1 使用Java类提供Bean定义
信息\t164
5．11．2 使用基于Java类的配置信息
启动Spring容器\t167
5．12 基于Groovy DSL的配置\t169
5．12．1 使用Groovy DSL提供Bean
定义信息\t169
5．12．2 使用GenericGroovyApplication
Context启动Spring容器\t171
5．13 通过编码方式动态添加Bean\t172
5．13．1 通过DefaultListableBean
Factory\t172
5．13．2 扩展自定义标签\t173
5．14 不同配置方式比较\t175
5．15 小结\t177
第6章 Spring容器高级主题\t178
6．1 Spring容器技术内幕\t178
6．1．1 内部工作机制\t179
6．1．2 BeanDefinition\t182
6．1．3 InstantiationStrategy\t183
6．1．4 BeanWrapper\t183
6．2 属性编辑器\t184
6．2．1 JavaBean的编辑器\t185
6．2．2 Spring默认属性编辑器\t188
6．2．3 自定义属性编辑器\t189
6．3 使用外部属性文件\t192
6．3．1 PropertyPlaceholderConfigurer
属性文件\t192
6．3．2 使用加密的属性文件\t195
6．3．3 属性文件自身的引用\t198
6．4 引用Bean的属性值\t199
6．5 国际化信息\t201
6．5．1 基础知识\t201
6．5．2 MessageSource\t206
6．5．3 容器级的国际化信息资源\t209
6．6 容器事件\t210
6．6．1 Spring事件类结构\t211
6．6．2 解构Spring事件体系的具体
实现\t213
6．6．3 一个实例\t214
6．7 小结\t215
第7章 Spring AOP基础\t216
7．1 AOP概述\t216
7．1．1 AOP到底是什么\t217
7．1．2 AOP术语\t219
7．1．3 AOP的实现者\t221
7．2 基础知识\t222
7．2．1 带有横切逻辑的实例\t222
7．2．2 JDK动态代理\t224
7．2．3 CGLib动态代理\t228
7．2．4 AOP联盟\t229
7．2．5 代理知识小结\t230
7．3 创建增强类\t230
7．3．1 增强类型\t230
7．3．2 前置增强\t231
7．3．3 后置增强\t235
7．3．4 环绕增强\t236
7．3．5 异常抛出增强\t237
7．3．6 引介增强\t239
7．4 创建切面\t243
7．4．1 切点类型\t243
7．4．2 切面类型\t244
7．4．3 静态普通方法名匹配切面\t246
7．4．4 静态正则表达式方法匹配
切面\t248
7．4．5 动态切面\t251
7．4．6 流程切面\t254
7．4．7 复合切点切面\t256
7．4．8 引介切面\t258
7．5 自动创建代理\t259
7．5．1 实现类介绍\t259
7．5．2 BeanNameAutoProxyCreator\t260
7．5．3 DefaultAdvisorAutoProxy
Creator\t261
7．5．4 AOP无法增强疑难问题
剖析\t262
7．6 小结\t267
第8章 基于@AspectJ和Schema的
AOP\t269
8．1 Spring对AOP的支持\t269
8．2 Java 5．0注解知识快速进阶\t270
8．2．1 了解注解\t270
8．2．2 一个简单的注解类\t271
8．2．3 使用注解\t272
8．2．4 访问注解\t273
8．3 着手使用@AspectJ\t274
8．3．1 使用前的准备\t275
8．3．2 一个简单的例子\t275
8．3．3 如何通过配置使用@AspectJ
切面\t277
8．4 @AspectJ语法基础\t278
8．4．1 切点表达式函数\t278
8．4．2 在函数入参中使用通配符\t279
8．4．3 逻辑运算符\t280
8．4．4 不同增强类型\t281
8．4．5 引介增强用法\t282
8．5 切点函数详解\t283
8．5．1 @annotation()\t284
8．5．2 execution()\t285
8．5．3 args()和@args()\t287
8．5．4 within()\t288
8．5．5 @within()和@target()\t289
8．5．6 target()和this()\t290
8．6 @AspectJ进阶\t291
8．6．1 切点复合运算\t292
8．6．2 命名切点\t292
8．6．3 增强织入的顺序\t294
8．6．4 访问连接点信息\t294
8．6．5 绑定连接点方法入参\t295
8．6．6 绑定代理对象\t297
8．6．7 绑定类注解对象\t298
8．6．8 绑定返回值\t299
8．6．9 绑定抛出的异常\t299
8．7 基于Schema配置切面\t300
8．7．1 一个简单切面的配置\t300
8．7．2 配置命名切点\t302
8．7．3 各种增强类型的配置\t303
8．7．4 绑定连接点信息\t305
8．7．5 Advisor配置\t306
8．8 混合切面类型\t307
8．8．1 混合使用各种切面类型\t308
8．8．2 各种切面类型总结\t308
8．9 其他\t309
8．9．1 JVM Class文件字节码转换
基础知识\t309
8．9．2 使用LTW织入切面\t311
8．10 小结\t314
第9章 Spring SpEL\t316
9．1 JVM动态语言\t316
9．2 SpEL表达式概述\t318
9．3 SpEL核心接口\t319
9．3．1 EvaluationContext接口\t320
9．3．2 SpEL编译器\t321
9．4 SpEL基础表达式\t323
9．4．1 文本字符解析\t323
9．4．2 对象属性解析\t323
9．4．3 数组、集合类型解析\t324
9．4．4 方法解析\t326
9．4．5 操作符解析\t327
9．4．6 安全导航操作符\t329
9．4．7 三元操作符\t330
9．4．8 Elvis操作符\t331
9．4．9 赋值、类型、构造器、变量\t332
9．4．10 集合过滤\t335
9．4．11 集合转换\t335
9．5 在Spring中使用SpEL\t336
9．5．1 基于XML的配置\t336
9．5．2 基于注解的配置\t337
9．6 小结\t338
第3篇 数据篇
第10章 Spring对DAO的支持\t340
10．1 Spring的DAO理念\t340
10．2 统一的异常体系\t341
10．2．1 Spring的DAO异常体系\t341
10．2．2 JDBC的异常转换器\t343
10．2．3 其他持久化技术的异常
转换器\t344
10．3 统一数据访问模板\t344
10．3．1 使用模板和回调机制\t345
10．3．2 Spring为不同持久化技术
所提供的模板类\t347
10．4 数据源\t348
10．4．1 配置一个数据源\t348
10．4．2 获取JNDI数据源\t352
10．4．3 Spring的数据源实现类\t353
10．5 小结\t353
第11章 Spring的事务管理\t355
11．1 数据库事务基础知识\t355
11．1．1 何为数据库事务\t356
11．1．2 数据并发的问题\t357
11．1．3 数据库锁机制\t359
11．1．4 事务隔离级别\t360
11．1．5 JDBC对事务的支持\t361
11．2 ThreadLocal基础知识\t362
11．2．1 ThreadLocal是什么\t363
11．2．2 ThreadLocal的接口方法\t363
11．2．3 一个TheadLocal实例\t364
11．2．4 与Thread同步机制的比较\t366
11．2．5 Spring使用ThreadLocal解决
线程安全问题\t366
11．3 Spring对事务管理的支持\t368
11．3．1 事务管理关键抽象\t369
11．3．2 Spring的事务管理器实现类\t371
11．3．3 事务同步管理器\t374
11．3．4 事务传播行为\t375
11．4 编程式的事务管理\t376
11．5 使用XML配置声明式事务\t377
11．5．1 一个将被实施事务增强的
服务接口\t379
11．5．2 使用原始的TransactionProxy
FactoryBean\t379
11．5．3 基于aop/tx命名空间的配置\t382
11．6 使用注解配置声明式事务\t385
11．6．1 使用@Transactional注解\t385
11．6．2 通过AspectJ LTW引入事务
切面\t389
11．7 集成特定的应用服务器\t390
11．7．1 BEA WebLogic\t390
11．7．2 WebSphere\t390
11．8 小结\t390
第12章 Spring的事务管理难点剖析\t392
12．1 DAO和事务管理的牵绊\t393
12．1．1 JDBC访问数据库\t393
12．1．2 Hibernate访问数据库\t395
12．2 应用分层的迷惑\t398
12．3 事务方法嵌套调用的迷茫\t401
12．3．1 Spring事务传播机制回顾\t401
12．3．2 相互嵌套的服务方法\t402
12．4 多线程的困惑\t405
12．4．1 Spring通过单实例化Bean
简化多线程问题\t405
12．4．2 启动独立线程调用事务
方法\t405
12．5 联合军种作战的混乱\t408
12．5．1 Spring事务管理器的应对\t408
12．5．2 Hibernate+Spring JDBC
混合框架的事务管理\t408
12．6 特殊方法成漏网之鱼\t412
12．6．1 哪些方法不能实施Spring
AOP事务\t412
12．6．2 事务增强遗漏实例\t413
12．7 数据连接泄露\t416
12．7．1 底层连接资源的访问问题\t416
12．7．2 Spring JDBC数据连接泄露\t417
12．7．3 事务环境下通过DataSource
Utils获取数据连接\t420
12．7．4 无事务环境下通过DataSource
Utils获取数据连接\t422
12．7．5 JdbcTemplate如何做到对连接
泄露的免疫\t424
12．7．6 使用TransactionAwareData
SourceProxy\t425
12．7．7 其他数据访问技术的等价类\t426
12．8 小结\t426
第13章 使用Spring JDBC访问
数据库\t428
13．1 使用Spring JDBC\t428
13．1．1 JdbcTemplate小试牛刀\t429
13．1．2 在DAO中使用Jdbc
Template\t429
13．2 基本的数据操作\t431
13．2．1 更改数据\t431
13．2．2 返回数据库的表自增主键值\t434
13．2．3 批量更改数据\t436
13．2．4 查询数据\t437
13．2．5 查询单值数据\t440
13．2．6 调用存储过程\t442
13．3 BLOB/CLOB类型数据的操作\t444
13．3．1 如何获取本地数据连接\t445
13．3．2 相关的操作接口\t446
13．3．3 插入LOB类型的数据\t448
13．3．4 以块数据方式读取LOB
数据\t450
13．3．5 以流数据方式读取LOB
数据\t451
13．4 自增键和行集\t452
13．4．1 自增键的使用\t452
13．4．2 如何规划主键方案\t454
13．4．3 以行集返回数据\t456
13．5 NamedParameterJdbcTemplate
模板类\t456
13．6 小结\t459
第14章 整合其他ORM框架\t460
14．1 Spring整合ORM技术\t460
14．2 在Spring中使用Hibernate\t462
14．2．1 配置SessionFactory\t462
14．2．2 使用HibernateTemplate\t465
14．2．3 处理LOB类型的数据\t469
14．2．4 添加Hibernate事件监听器\t470
14．2．5 使用原生的Hibernate API\t471
14．2．6 使用注解配置\t472
14．2．7 事务处理\t474
14．2．8 延迟加载问题\t475
14．3 在Spring中使用MyBatis\t476
14．3．1 配置SqlMapClient\t476
14．3．2 在Spring中配置MyBatis\t478
14．3．3 编写MyBatis的DAO\t479
14．4 DAO层设计\t482
14．4．1 DAO基类设计\t482
14．4．2 查询接口方法设计\t484
14．4．3 分页查询接口设计\t486
14．5 小结\t487
第4篇 应用篇
第15章 Spring Cache\t490
15．1 缓存概述\t490
15．1．1 缓存的概念\t490
15．1．2 使用Spring Cache\t493
15．2 掌握Spring Cache抽象\t498
15．2．1 缓存注解\t498
15．2．2 缓存管理器\t504
15．2．3 使用SpEL表达式\t506
15．2．4 基于XML的Cache声明\t506
15．2．5 以编程方式初始化缓存\t507
15．2．6 自定义缓存注解\t509
15．3 配置Cache存储\t509
15．3．1 EhCache\t510
15．3．2 Guava\t510
15．3．3 HazelCast\t511
15．3．4 GemFire\t511
15．3．5 JSR-107 Cache\t511
15．4 实战经验\t513
15．5 小结\t514
第16章 任务调度和异步执行器\t516
16．1 任务调度概述\t516
16．2 Quartz快速进阶\t517
16．2．1 Quartz基础结构\t518
16．2．2 使用SimpleTrigger\t520
16．2．3 使用CronTrigger\t522
16．2．4 使用Calendar\t526
16．2．5 任务调度信息存储\t527
16．3 在Spring中使用Quartz\t530
16．3．1 创建JobDetail\t530
16．3．2 创建Trigger\t533
16．3．3 创建Scheduler\t534
16．4 在Spring中使用JDK Timer\t536
16．4．1 Timer和TimerTask\t536
16．4．2 Spring对Java Timer的支持\t539
16．5 Spring对Java 5．0 Executor的
支持\t540
16．5．1 了解Java 5．0的Executor\t541
16．5．2 Spring对Executor所提供的
抽象\t543
16．6 实际应用中的任务调度\t544
16．6．1 如何产生任务\t545
16．6．2 任务调度对应用程序集群的
影响\t547
16．6．3 任务调度云\t547
16．6．4 Web应用程序中调度器的
启动和关闭问题\t549
16．7 小结\t552
第17章 Spring MVC\t553
17．1 Spring MVC体系概述\t554
17．1．1 体系结构\t554
17．1．2 配置DispatcherServlet\t555
17．1．3 一个简单的实例\t560
17．2 注解驱动的控制器\t565
17．2．1 使用@RequestMapping
映射请求\t565
17．2．2 请求处理方法签名\t569
17．2．3 使用矩阵变量绑定参数\t570
17．2．4 请求处理方法签名详细说明\t571
17．2．5 使用HttpMessageConverter
＜T＞\t575
17．2．6 使用@RestController和AsyncRestTemplate\t584
17．2．7 处理模型数据\t586
17．3 处理方法的数据绑定\t591
17．3．1 数据绑定流程剖析\t592
17．3．2 数据转换\t592
17．3．3 数据格式化\t598
17．3．4 数据校验\t602
17．4 视图和视图解析器\t611
17．4．1 认识视图\t611
17．4．2 认识视图解析器\t612
17．4．3 JSP和JSTL\t613
17．4．4 模板视图\t618
17．4．5 Excel\t621
17．4．6 PDF\t623
17．4．7 输出XML\t625
17．4．8 输出JSON\t626
17．4．9 使用XmlViewResolver\t626
17．4．10 使用ResourceBundleView
Resolver\t627
17．4．11 混合使用多种视图技术\t628
17．5 本地化解析\t630
17．5．1 本地化的概念\t630
17．5．2 使用CookieLocaleResolver\t631
17．5．3 使用SessionLocaleResolver\t632
17．5．4 使用LocaleChange
Interceptor\t632
17．6 文件上传\t633
17．6．1 配置MultipartResolver\t633
17．6．2 编写控制器和文件上传表单
页面\t633
17．7 WebSocket支持\t634
17．7．1 使用WebSocket\t634
17．7．2 WebSocket的限制\t638
17．8 杂项\t639
17．8．1 静态资源处理\t639
17．8．2 装配拦截器\t643
17．8．3 异常处理\t644
17．8．4 RequestContextHolder的
使用\t646
17．9 小结\t646
第18章 实战案例开发\t648
18．1 论坛案例概述\t648
18．1．1 论坛整体功能结构\t648
18．1．2 论坛用例描述\t649
18．1．3 主要功能流程描述\t651
18．2 系统设计\t655
18．2．1 技术框架选择\t655
18．2．2 采用Maven构建项目\t656
18．2．3 单元测试类包结构规划\t657
18．2．4 系统架构图\t658
18．2．5 PO类设计\t658
18．2．6 持久层设计\t659
18．2．7 服务层设计\t660
18．2．8 Web层设计\t661
18．2．9 数据库设计\t662
18．3 开发前的准备\t663
18．4 持久层开发\t664
18．4．1 PO类\t664
18．4．2 DAO基类\t666
18．4．3 通过扩展基类定义DAO类\t670
18．4．4 DAO Bean的装配\t672
18．4．5 使用Hibernate二级缓存\t673
18．5 对持久层进行测试\t675
18．5．1 配置Unitils测试环境\t675
18．5．2 准备测试数据库及测试
数据\t676
18．5．3 编写DAO测试基类\t677
18．5．4 编写BoardDao测试用例\t678
18．6 服务层开发\t680
18．6．1 UserService的开发\t680
18．6．2 ForumService的开发\t681
18．6．3 服务类Bean的装配\t683
18．7 对服务层进行测试\t684
18．7．1 编写Service测试基类\t685
18．7．2 编写ForumService测试
用例\t685
18．8 Web层开发\t687
18．8．1 BaseController的基类\t687
18．8．2 用户登录和注销\t689
18．8．3 用户注册\t691
18．8．4 论坛管理\t692
18．8．5 论坛普通功能\t694
18．8．6 分页显示论坛版块的主题
帖子\t696
18．8．7 web．xml配置\t700
18．8．8 Spring MVC配置\t702
18．9 对Web层进行测试\t703
18．9．1 编写Web测试基类\t703
18．9．2 编写ForumManageController
测试用例\t704
18．10 开发环境部署\t705
18．11 项目配置实战经验\t708
18．11．1 “传统的”Web项目属性
文件\t708
18．11．2 如何规划便于部署的Web
项目属性文件\t709
18．11．3 数据源的配置\t710
18．12 小结\t712
第5篇 提高篇
第19章 Spring OXM\t714
19．1 认识XML解析技术\t714
19．1．1 什么是XML\t714
19．1．2 XML的处理技术\t715
19．2 XML处理利器：XStream\t717
19．2．1 XStream概述\t717
19．2．2 快速入门\t718
19．2．3 使用XStream别名\t720
19．2．4 XStream转换器\t721
19．2．5 XStream注解\t723
19．2．6 流化对象\t725
19．2．7 持久化API\t726
19．2．8 额外功能：处理JSON\t727
19．3 其他常见的O/X Mapping开源
项目\t729
19．3．1 JAXB\t729
19．3．2 Castor\t733
19．3．3 JiBX\t738
19．3．4 总结比较\t741
19．4 与Spring OXM整合\t742
19．4．1 Spring OXM概述\t742
19．4．2 整合OXM实现者\t744
19．4．3 如何在Spring中进行配置\t744
19．4．4 Spring OXM简单实例\t747
19．5 小结\t749
第20章 实战型单元测试\t750
20．1 单元测试概述\t751
20．1．1 为什么需要单元测试\t751
20．1．2 单元测试之误解\t752
20．1．3 单元测试之困境\t754
20．1．4 单元测试基本概念\t755
20．2 TestNG快速进阶\t757
20．2．1 TestNG概述\t757
20．2．2 TestNG生命周期\t758
20．2．3 使用TestNG\t758
20．3 模拟利器Mockito\t763
20．3．1 模拟测试概述\t763
20．3．2 创建Mock对象\t763
20．3．3 设定Mock对象的期望行为
及返回值\t764
20．3．4 验证交互行为\t766
20．4 测试整合之王Unitils\t767
20．4．1 Unitils概述\t767
20．4．2 集成Spring\t770
20．4．3 集成Hibernate\t773
20．4．4 集成DbUnit\t774
20．4．5 自定义扩展模块\t775
20．5 使用Unitils测试DAO层\t776
20．5．1 数据库测试的难点\t776
20．5．2 扩展DbUnit用Excel准备
数据\t776
20．5．3 测试实战\t779
20．6 使用Unitils测试Service层\t789
20．7 测试Web层\t794
20．7．1 对LoginController进行单元
测试\t794
20．7．2 使用Spring Servlet API模拟
对象\t795
20．7．3 使用Spring RestTemplate
测试\t797
20．8 小结\t798
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Spring 4.x
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式系统概念与设计
第1章 分布式系统的特征 1
1.1 简介 1
1.2 分布式系统的实例 2
1.2.1 因特网 2
1.2.2 企业内部网 3
1.2.3 移动计算和无处不在计算 3
1.3 资源共享和Web 5
1.4 挑战 10
1.4.1 异构性 11
1.4.2 开放性 11
1.4.3 安全性 12
1.4.4 可伸缩性 13
1.4.5 故障处理 14
1.4.6 并发性 15
1.4.7 透明性 15
1.5 小结 16
练习 17
第2章 系统模型 19
2.1 简介 19
2.2 体系结构模型 20
2.2.1 软件层 20
2.2.2 系统体系结构 22
2.2.3 变体 23
2.2.4 接口和对象 27
2.2.5 分布式体系结构的设计需求 27
2.3 基础模型 30
2.3.1 交互模型 31
2.3.2 故障模型 34
2.3.3 安全模型 36
2.4 小结 39
练习 40
第3章 网络和网际互连 42
3.1 简介 42
3.2 网络类型 44
3.3 网络原理 46
3.3.1 数据包的传输 47
3.3.2 数据流 47
3.3.3 交换模式 47
3.3.4 协议 48
3.3.5 路由 52
3.3.6 拥塞控制 54
3.3.7 网际互连 55
3.4 因特网协议 57
3.4.1 IP寻址 59
3.4.2 IP协议 60
3.4.3 IP路由 62
3.4.4 IPv6 65
3.4.5 移动IP 67
3.4.6 TCP和UDP 68
3.4.7 域名 69
3.4.8 防火墙 70
3.5 实例研究：以太网、WiFi、蓝牙和ATM 72
3.5.1 以太网 73
3.5.2 IEEE 802.11无线LAN 76
3.5.3 IEEE 802.15.1蓝牙无线PAN 78
3.5.4 异步传输模式网络 80
3.6 小结 82
练习 82
第4章 进程间通信 84
4.1 简介 84
4.2 因特网协议的API 85
4.2.1 进程间通信的特征 85
4.2.2 套接字 86
4.2.3 UDP数据报通信 87
4.2.4 TCP流通信 90
4.3 外部数据表示和编码 93
4.3.1 CORBA的公共数据表示 94
4.3.2 Java对象序列化 95
4.3.3 可扩展标记语言 97
4.3.4 远程对象引用 99
4.4 客户－服务器通信 100
4.5 组通信 105
4.5.1 IP组播—组通信的实现 106
4.5.2 组播的可靠性和排序 108
4.6 实例研究：UNIX中的进程间通信 108
4.6.1 数据报通信 109
4.6.2 流通信 110
4.7 小结 110
练习 111
第5章 分布式对象和远程调用 114
5.1 简介 114
5.2 分布式对象间的通信 116
5.2.1 对象模型 117
5.2.2 分布式对象 117
5.2.3 分布式对象模型 118
5.2.4 RMI的设计问题 120
5.2.5 RMI的实现 122
5.2.6 分布式无用单元收集 125
5.3 远程过程调用 126
5.4 事件和通知 129
5.4.1 分布式事件通知的参与者 131
5.4.2 实例研究：Jini分布式事件规约 132
5.5 实例研究：Java RMI 133
5.5.1 创建客户和服务器程序 136
5.5.2 Java RMI的设计和实现 138
5.6 小结 139
练习 139
第6章 操作系统支持 142
6.1 简介 142
6.2 操作系统层 143
6.3 保护 144
6.4 进程和线程 145
6.4.1 地址空间 146
6.4.2 新进程的生成 147
6.4.3 线程 149
6.5 通信和调用 157
6.5.1 调用性能 158
6.5.2 异步操作 162
6.6 操作系统的体系结构 164
6.7 小结 167
练习 167
第7章 安全性 169
7.1 简介 169
7.1.1 威胁和攻击 170
7.1.2 保护电子事务 172
7.1.3 设计安全系统 173
7.2 安全技术概述 174
7.2.1 密码学 175
7.2.2 密码学的应用 175
7.2.3 证书 177
7.2.4 访问控制 178
7.2.5 凭证 180
7.2.6 防火墙 181
7.3 密码算法 181
7.3.1 密钥（对称）算法 184
7.3.2 公钥（不对称）算法 186
7.3.3 混合密码协议 188
7.4 数字签名 188
7.4.1 公钥数字签名 189
7.4.2 密钥数字签名—MAC 189
7.4.3 安全摘要函数 190
7.4.4 证书标准和证书权威机构 191
7.5 密码实用学 192
7.5.1 密码算法的性能 192
7.5.2 密码学的应用和政治障碍 193
7.6 案例研究：Needham-Schroeder、Kerberos、TLS和802.11 WiFi 194
7.6.1 Needham-Schroeder认证协议 194
7.6.2 Kerberos 195
7.6.3 使用安全套接字确保电子交易安全 199
7.6.4 IEEE 802.11 WiFi 安全设计中的缺陷 201
7.7 小结 203
练习 204
第8章 分布式文件系统 205
8.1 简介 205
8.1.1 文件系统的特点 207
8.1.2 分布式文件系统的需求 208
8.1.3 实例研究 209
8.2 文件服务体系结构 210
8.3 实例研究：SUN网络文件系统 214
8.4 实例研究：Andrew文件系统 222
8.4.1 实现 223
8.4.2 缓存的一致性 225
8.4.3 其他方面 227
8.5 最新进展 228
8.6 小结 232
练习 232
第9章 名字服务 234
9.1 简介 234
9.2 名字服务和域名系统 236
9.2.1 名字空间 237
9.2.2 名字解析 239
9.2.3 域名系统 241
9.3 目录服务 246
9.4 实例研究：全局名字服务 246
9.5 实例研究：X.500目录服务 248
9.6 小结 251
练习 252
第10章 对等系统 253
10.1 简介 253
10.2 Napster及其遗留系统 256
10.3 对等中间件 257
10.4 路由覆盖 259
10.5 路由覆盖实例研究：Pastry和Tapestry 261
10.5.1 Pastry 261
10.5.2 Tapestry 266
10.6 应用实例研究：Squirrel、OceanStore和Ivy 267
10.6.1 Squirrel Web缓存 267
10.6.2 OceanStore文件存储 269
10.6.3 Ivy文件系统 272
10.7 小结 274
练习 275
第11章 时间和全局状态 277
11.1 简介 277
11.2 时钟、事件和进程状态 278
11.3 同步物理时钟 279
11.3.1 同步系统中的同步 280
11.3.2 同步时钟的Cristian方法 281
11.3.3 Berkeley算法 281
11.3.4 网络时间协议 282
11.4 逻辑时间和逻辑时钟 284
11.5 全局状态 286
11.5.1 全局状态和一致割集 287
11.5.2 全局状态谓词、稳定性、安全性和活性 288
11.5.3 Chandy和Lamport的“快照”算法 289
11.6 分布式调试 291
11.6.1 观察一致的全局状态 293
11.6.2 判定可能的f 294
11.6.3 判定明确的f 294
11.6.4 在同步系统中判定可能的f和明确的f 295
11.7 小结 296
练习 296
第12章 协调和协定 298
12.1 简介 298
12.2 分布式互斥 300
12.3 选举 305
12.4 组播通信 308
12.4.1 基本组播 309
12.4.2 可靠组播 310
12.4.3 有序组播 312
12.5 共识和相关问题 317
12.5.1 系统模型和问题定义 317
12.5.2 同步系统中的共识问题 320
12.5.3 同步系统中的拜占庭将军问题 320
12.5.4 异步系统的不可能性 323
12.6 小结 324
练习 325
第13章 事务和并发控制 327
13.1 简介 327
13.1.1 简单的同步机制（无事务） 328
13.1.2 事务的故障模型 329
13.2 事务 329
13.2.1 并发控制 332
13.2.2 事务放弃时的恢复 334
13.3 嵌套事务 336
13.4 锁 337
13.4.1 死锁 342
13.4.2 在加锁机制中增加并发度 345
13.5 乐观并发控制 346
13.6 时间戳排序 349
13.7 并发控制方法的比较 353
13.8 小结 354
练习 355
第14章 分布式事务 359
14.1 简介 359
14.2 平面分布式事务和嵌套分布式事务 359
14.3 原子提交协议 361
14.3.1 两阶段提交协议 362
14.3.2 嵌套事务的两阶段提交协议 364
14.4 分布式事务的并发控制 367
14.4.1 加锁 367
14.4.2 时间戳并发控制 368
14.4.3 乐观并发控制 368
14.5 分布式死锁 369
14.6 事务恢复 374
14.6.1 日志 375
14.6.2 影子版本 377
14.6.3 为何恢复文件需要事务状态和意图列表 378
14.6.4 两阶段提交协议的恢复 378
14.7 小结 380
练习 381
第15章 复制 383
15.1 简介 383
15.2 系统模型和组通信 385
15.2.1 系统模型 385
15.2.2 组通信 386
15.3 容错服务 390
15.3.1 被动（主备份）复制 392
15.3.2 主动复制 393
15.4 高可用服务的实例研究：gossip体系结构、Bayou和Coda 394
15.4.1 gossip体系结构 395
15.4.2 Bayou系统和操作变换方法 401
15.4.3 Coda文件系统 402
15.5 复制数据上的事务 407
15.5.1 复制事务的体系结构 407
15.5.2 可用拷贝复制 409
15.5.3 网络分区 410
15.5.4 带验证的可用拷贝 411
15.5.5 法定数共识方法 411
15.5.6 虚拟分区算法 413
15.6 小结 415
练习 415
第16章 移动计算和无处不在计算 417
16.1 简介 417
16.2 关联 423
16.2.1 发现服务 424
16.2.2 物理关联 427
16.2.3 小结和前景 428
16.3 互操作 428
16.3.1 易变系统的面向数据编程 429
16.3.2 间接关联和软状态 432
16.3.3 小结和前景 433
16.4 感知和上下文敏感 433
16.4.1 传感器 434
16.4.2 感知体系结构 434
16.4.3 位置感知 438
16.4.4 小结和前景 441
16.5 安全和私密性 442
16.5.1 背景 442
16.5.2 一些解决办法 443
16.5.3 小结和前景 447
16.6 自适应 447
16.6.1 内容的上下文敏感自适应 448
16.6.2 适应变化的系统资源 449
16.6.3 小结和前景 450
16.7 Cooltown实例研究 450
16.7.1 Web存在 451
16.7.2 物理超链接 452
16.7.3 互操作和eSquirt协议 454
16.7.4 小结和前景 455
16.8 小结 455
练习 456
第17章 分布式多媒体系统 458
17.1 简介 458
17.2 多媒体数据的特征 461
17.3 服务质量管理 462
17.3.1 服务质量协商 464
17.3.2 许可控制 467
17.4 资源管理 468
17.5 流适应 469
17.5.1 调整 470
17.5.2 过滤 471
17.6 实例研究：Tiger视频文件服务器 471
17.7 小结 474
练习 474
第18章 分布式共享内存 476
18.1 简介 476
18.1.1 消息传递机制和DSM 477
18.1.2 DSM的实现方法 478
18.2 设计和实现问题 479
18.2.1 结构 479
18.2.2 同步模型 480
18.2.3 一致性模型 481
18.2.4 更新选项 483
18.2.5 粒度 485
18.2.6 系统颠簸 485
18.3 顺序一致性和lvy实例研究 485
18.3.1 系统模型 486
18.3.2 写失效 487
18.3.3 失效协议 488
18.3.4 一个动态分布式管理器算法 489
18.3.5 系统颠簸 490
18.4 释放一致性和Munin实例研究 491
18.4.1 内存访问 491
18.4.2 释放一致性 492
18.4.3 Munin 493
18.5 其他一致性模型 494
18.6 小结 495
练习 496
第19章 Web服务 498
19.1 简介 498
19.2 Web服务 499
19.2.1 SOAP 501
19.2.2 Web服务与分布式对象模型的比较 504
19.2.3 在Java中使用SOAP 505
19.2.4 Web服务和CORBA的比较 508
19.3 服务描述和Web服务接口定义语言 509
19.4 Web服务使用的目录服务 512
19.5 XML安全性 513
19.6 Web服务的协作 516
19.7 实例研究：网格 517
19.7.1 World-Wide Telescope—一种网格应用 518
19.7.2 数据密集型科学应用的特征 518
19.7.3 开放的网格服务体系结构 519
19.7.4 一些网格应用的例子 521
19.7.5 Globus工具包 522
19.8 小结 523
练习 524
第20章 CORBA实例研究 526
20.1 简介 526
20.2 CORBA RMI 527
20.2.1 CORBA客户和服务器实例 529
20.2.2 CORBA体系结构 532
20.2.3 CORBA接口定义语言 534
20.2.4 CORBA远程对象引用 537
20.2.5 CORBA语言映射 538
20.2.6 CORBA与Web的集成 538
20.3 CORBA服务 539
20.3.1 CORBA名字服务 540
20.3.2 CORBA事件服务 542
20.3.3 CORBA通知服务 543
20.3.4 CORBA安全服务 544
20.4 小结 544
练习 545
索引 548
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式系统概念与设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>重构网络：SDN架构与实现
第1章 SDN重塑网络  1
1.1 SDN是什么  1
1.2 为什么需要SDN 4
1.3 网络可编程探索之路  6
1.4 SDN发展历史  10
1.5 SDN重塑网络  15
1.6 本章小结  16
参考资料 16
第2章 SDN南向协议  21
2.1 SDN南向协议简介 21
2.2 狭义SDN南向协议  23
2.3 广义SDN南向协议  30
2.3.1 OF-Config  31
2.3.2 OVSDB  34
2.3.3 NETCONF 36
2.3.4 OpFlex 38
2.3.5 XMPP  39
2.3.6 PCEP 40
2.4 完全可编程南向协议 41
2.4.1 POF  41
2.4.2 P4  46
2.5 SDN南向协议标准之战  53
2.6 本章小结  55
参考资料 55
第3章 SDN控制平面  57
3.1 SDN控制平面简介 57
3.2 SDN开源控制器  59
3.2.1 NOX/POX  59
3.2.2 Ryu 63
3.2.3 Floodlight  68
3.2.4 OpenDaylight  72
3.2.5 ONOS  78
3.3 选择SDN控制器 85
3.3.1 评价控制器的要素  85
3.3.2 选择正确的控制器  89
3.4 SDN控制平面发展趋势  91
3.5 本章小结  96
参考资料 97
第4章 SDN数据平面  99
4.1 SDN数据平面简介 99
4.2 通用可编程转发模型  101
4.2.1 通用硬件模型  103
4.2.2 通用处理指令  112
4.2.3 小结  115
4.3 探索通用可编程数据平面  116
4.4 SDN数据平面的发展趋势  120
4.4.1 发展历史 120
4.4.2 白盒交换机 123
4.5 本章小结 125
参考资料. 126
第5章 从零开始实践  129
5.1 Mininet实践 129
5.1.1 Mininet简介  130
5.1.2 Mininet系统架构  130
5.1.3 Mininet安装  132
5.1.4 Mininet示例  134
5.2 Open vSwitch实践  140
5.2.1 OVS简介 141
5.2.2 OVS架构 141
5.2.3 OVS安装 142
5.2.4 OVS示例 144
5.3 Ryu实践 150
5.3.1 Ryu简介  150
5.3.2 Ryu架构  151
5.3.3 Ryu安装  152
5.3.4 Ryu示例  153
5.4 网络虚拟化平台实践  162
5.4.1 OpenVirteX简介 162
5.4.2 OpenVirteX架构 163
5.4.3 OpenVirteX安装 164
5.4.4 OpenVirteX示例 165
5.4.5 其他网络虚拟化产品  170
5.5 其他工具 170
5.5.1 Cbench简介  171
5.5.2 OFTest简介  173
5.5.3 Wireshark简介 174
5.5.4 发包工具简介  175
5.6 本章小结 177
参考资料. 177
第6章 SDN应用案例 179
6.1 SDN在数据中心网络的应用 179
6.1.1 面临的问题 179
6.1.2 现有商业方案  181
6.2 SDN在WAN中的应用 187
6.2.1 面临的问题 187
6.2.2 现有商业方案  189
6.3 其他领域的应用 192
6.3.1 SDN在园区网中的应用 193
6.3.2 SDN在局域网中的应用 195
6.3.3 SDN在蜂窝网络中的应用  195
6.4 本章小结 197
参考资料. 197
第7章 SDN与网络虚拟化  200
7.1 网络虚拟化  200
7.1.1 为什么需要虚拟化技术  201
7.1.2 网络虚拟化 203
7.2 SDN与网络虚拟化  208
7.2.1 SDN与网络虚拟化  208
7.2.2 SDN实现网络虚拟化  209
7.3 网络虚拟化产品 213
7.3.1 开源产品 214
7.3.2 商业产品 220
7.4 未来研究方向  223
7.5 本章小结 225
参考资料. 225
第8章 SDN浪潮  227
8.1 SDN对学术界的影响 227
8.2 SDN对工业界的影响 231
8.3 如何应对SDN的变革  234
8.4 SDN浪潮  238
8.5 本章小结 238
参考资料. 239
附录A 我是一个SDN控制器  243
附录B 我是一个SDN交换机  250
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>重构网络：SDN架构与实现
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算基础架构及关键应用
本书编委会
推荐序
前　言
第1章　云计算 1
1.1　云计算定义 1
1.2　云计算发展历史 2
1.3　云计算的特征 3
1.4　IT建设的云计算趋势 4
1.5　云计算模型 6
1.6　IaaS 7
1.7　计算虚拟化简介 9
1.7.1　计算虚拟化 9
1.7.2　计算虚拟化的作用 10
1.7.3　计算虚拟化解疑 10
1.7.4　计算虚拟化厂家 12
1.8　存储虚拟化简介 13
1.8.1　存储虚拟化 13
1.8.2　存储虚拟化的特点 14
1.8.3　自动精简配置 14
1.8.4　存储虚拟引擎 15
1.9　网络虚拟化简介 15
1.9.1　网络设备虚拟化 15
1.9.2　链路虚拟化 16
1.9.3　虚拟网络 17
1.9.4　基于SDN的网络虚拟化 18
第2章　计算虚拟化技术 19
2.1　计算虚拟化技术简介 19
2.1.1　Hypervisor虚拟化 19
2.1.2　容器虚拟化 23
2.2　KVM 25
2.3　Xen 27
2.4　VMware 27
2.5　Docker 29
2.6　计算虚拟化技术对比及应用场景 32
2.7　计算虚拟化与云管理平台的关联实现 34
2.7.1　Libvirt-KVM 34
2.7.2　Libvirt-Docker 35
2.7.3　XenAPI 35
2.7.4　VMware Driver 37
2.8　小结 40
第3章　存储虚拟化技术 41
3.1　Ceph简介 41
3.2　Ceph的架构 42
3.2.1　RADOS集群存储节点 43
3.2.2　Librados库 47
3.2.3　RADOSGW 48
3.2.4　RBD 49
3.2.5　Ceph FS 50
3.3　Ceph和OpenStack 50
3.4　Ceph的部署 51
3.4.1　部署需要准备的系统环境 51
3.4.2　Ceph部署的步骤 52
3.5　分布式文件系统 54
3.6　Swift对象存储 56
3.7　存储网关技术 57
3.8　对象存储方案简介 58
3.9　小结 62
第4章　网络虚拟化技术 63
4.1　SDN架构简介 63
4.1.1　OpenFlow标准 65
4.1.2　OpenStack与SDN集成 66
4.1.3　OpenDaylight 67
4.2　OVS与Linux Bridge 71
4.2.1　Open vSwitch虚拟网络 71
4.2.2　Linux Bridge 74
4.3　Overlay协议 74
4.3.1　VXLAN 75
4.3.2　NVGRE 79
4.3.3　VXLAN与NVGRE的异同 81
4.4　虚拟网络设备 81
4.4.1　Firewall 81
4.4.2　LoadBalance 82
4.4.3　DVR 85
4.5　小结 86
第5章　桌面 & 应用虚拟化 87
5.1　概述 87
5.2　桌面虚拟化 89
5.2.1　应用场景 89
5.2.2　系统架构&原理 89
5.2.3　关键技术 90
5.3　应用虚拟化 100
5.3.1　应用场景 100
5.3.2　实现原理 101
5.3.3　关键技术 102
5.3.4　典型厂商产品 102
5.4　VOI 108
5.4.1　基本概念 108
5.4.2　VDI & VOI 比较 108
5.5　小结 109
第6章　云管理平台概述 110
6.1　主流云管理平台对比 111
6.2　OpenStack简介 115
6.2.1　OpenStack设计原理和体系结构 115
6.2.2　OpenStack社区和项目开发流程 119
6.2.3　OpenStack应用现状与发展趋势 120
6.3　OpenStack入门体验 123
6.3.1　初探OpenStack 123
6.3.2　创建OpenStack 虚拟机实例 124
6.3.3　创建虚拟机流程概述 126
第7章　通用云平台部署 130
7.1　背景 130
7.2　公有云 131
7.2.1　概述 131
7.2.2　公有云典型服务 132
7.2.3　公有云平台比较 134
7.3　私有云 138
7.3.1　概述 138
7.3.2　建设私有云需要考虑的问题 139
7.3.3　基于OpenStack搭建私有云 140
7.4　混合云 143
7.4.1　概述 143
7.4.2　典型场景 146
7.4.3　主要挑战 148
7.4.4　架构 151
7.4.5　关键技术 153
7.4.6　混合云业务部署实践 156
7.5　小结 158
第8章　NFV云部署 159
8.1　NFV概述 159
8.1.1　NFV定义 160
8.1.2　与SDN的关系 161
8.1.3　NFV的技术基础 162
8.1.4　NFV的挑战 162
8.2　NFV架构 164
8.2.1　NFV 架构框架 164
8.2.2　NFV 典型用例 168
8.3　NFV关键组成 170
8.3.1　NFV 基础设施 170
8.3.2　NFV 管理和编排 171
8.3.3　NFV 软件架构 173
8.3.4　NFV 可靠性和可用性 174
8.3.5　NFV 性能和可移植性 175
8.3.6　NFV 安全 175
8.4　NFV性能提升关键技术 176
8.4.1　SR-IOV虚拟化技术 176
8.4.2　NUMA多通道处理 178
8.4.3　DPDK包处理技术 178
8.5　小结 179
第9章　业务链实现技术 180
9.1　概述 180
9.2　业务链基本概念 180
9.3　IETF SFC架构简介 181
9.3.1　SFC包解析 182
9.3.2　业务功能链的相关动作 184
9.4　云数据中心业务链实现方案 185
9.4.1　业务功能的创建过程 186
9.4.2　基于Traffic Steering进行业务链引流 187
9.4.3　 API 188
9.4.4　业务链示例 193
9.5　小结 194
第10章　PaaS平台 195
10.1PaaS平台概述 195
10.1.1　PaaS定义 195
10.1.2　PaaS的功能与特点 196
10.1.3　PaaS的应用场景 196
10.1.4　业界开源PaaS平台 197
10.2Cloud Foundry平台 197
10.2.1　Cloud Foundry的功能和特点 197
10.2.2　Cloud Foundry社区现状 199
10.2.3　Cloud Foundry应用场景 200
10.3　Cloud Foundry架构和功能 200
10.3.1　Cloud Foundry架构 201
10.3.2　Router 202
10.3.3　UAA 202
10.3.4　Cloud Controller 203
10.3.5　Health Manager 203
10.3.6　DEA 203
10.3.7　Message Bus 204
10.3.8　Metrics & Logging 204
10.3.9　Buildpack 204
10.3.10　Service Broker 206
10.3.11　Cloud Foundry V1与Cloud Foundry V2的区别 207
10.4　Cloud Foundry工作机制 207
10.5　Cloud Foundry应用部署与使用 209
10.6　Cloud Foundry V3 212
10.7　Cloud Foundry与容器 213
10.7.1　Cloud Foundry的容器技术 213
10.7.2　Warden与Docker 215
10.8　Cloud Foundry与OpenStack 215
10.9　小结 217
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算基础架构及关键应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java架构师指南
第　1章 编程基础　1
1．1　程序员进阶　1
1．2　选择开发工具　3
1．3　安装JDK　5
1．4　安装Tomcat服务器　6
1．5　Hello World程序　8
1．6　小结　9
第　2章 需求调研　10
2．1　搭建关系　10
2．2　正式立项　11
2．3　需求调研　11
2．4　输出文档　12
2．5　技术选型　16
2．6　数据流图　16
2．7　UML建模　16
2．8　项目开工会　17
2．9　小结　18
第3章　项目开发　19
3．1　定义范围和WBS分解　19
3．2　企业管理系统框架搭建　20
3．3　Servlet方式开发　20
3．3．1　前端验证　22
3．3．2　后端验证　25
3．3．3　注册功能　28
3．3．4　综合调试　39
3．3．5　Servlet注解　43
3．4　不依赖框架的开发　45
3．4．1　销售数据导入报表　46
3．4．2　销售数据查询报表　53
3．5　月度版本　57
3．6　小结　57
第4章　项目部署　58
4．1　项目打包　58
4．2　项目发布　62
4．3　构建工具　63
4．3．1　Ant环境搭建　63
4．3．2　Ant经典实例　64
4．3．3　Maven环境搭建　66
4．3．4　Maven经典实例　66
4．4　部署工具　70
4．4．1　mstsc　71
4．4．2　VMware　71
4．4．3　Xmanager　75
4．4．4　WinSCP　79
4．4．5　JD-GUI　80
4．5　小结　81
第5章　编程环境　82
5．1　Linux系统介绍　82
5．2　Linux系统安装　83
5．3　Linux常用命令　84
5．3．1　基本命令　84
5．3．2　高级命令　90
5．3．3　部署命令　93
5．3．4　shell脚本入门　100
5．4　DOS介绍　101
5．4．1　基本命令　102
5．4．2　高级命令　104
5．5　SVN与Git版本控制　105
5．5．1　SVN常用操作　106
5．5．2　Git常用操作　110
5．6　Visio画图　114
5．7　Axure原型设计　115
5．8　代码编辑器　116
5．9　小结　119
第6章　架构师思想　120
6．1　数据类型　120
6．1．1　Object　121
6．1．2　byte和Byte　122
6．1．3　short和Short　122
6．1．4　int和Integer　122
6．1．5　long和Long　123
6．1．6　float和Float　123
6．1．7　char和Character　124
6．1．8　double和Double　124
6．1．9　boolean和Boolean　125
6．2　类与对象　125
6．2．1　三大特性　126
6．2．2　属性和方法　126
6．2．3　抽象类和接口　128
6．3　数组　129
6．3．1　创建数组　129
6．3．2　数组的初始化　130
6．3．3　数组的排序　130
6．4　集合类　130
6．4．1　Collection接口　131
6．4．2　Set接口　132
6．4．3　List接口　134
6．4．4　Queue接口　135
6．4．5　Map接口　136
6．4．6　HashMap实现类　136
6．4．7　TreeMap实现类　137
6．4．8　Hashtable实现类　137
6．4．9　Iterator迭代器　137
6．5　文件与流　139
6．5．1　File类　139
6．5．2　字节流　140
6．5．3　字符流　142
6．6　异常处理　145
6．6．1　try catch捕获　145
6．6．2　throw throws抛出　147
6．6．3　自定义异常　147
6．7　代码调试　148
6．7．1　Web调试方式　148
6．7．2　Java调试方式　149
6．8　多线程　150
6．8．1　线程创建　150
6．8．2　线程调度　152
6．8．3　线程同步　152
6．9　监听器　155
6．9．1　实现Listener　155
6．9．2　配置Listener　155
6．9．3　测试Listener　156
6．10　过滤器　157
6．10．1　实现Filter　157
6．10．2　配置Filter　158
6．10．3　测试Filter　159
6．11　反射机制　160
6．11．1　ReflectDemo　160
6．11．2　InvokeDemo　162
6．12　XML　163
6．12．1　创建XML　163
6．12．2　解析XML　164
6．13　WebService　166
6．13．1　实现服务端　167
6．13．2　实现客户端　168
6．14　Ajax传递　169
6．14．1　Ajax是什么　169
6．14．2　Ajax的JavaScript语法　171
6．14．3　Ajax的jQuery语法　174
6．15　JSP内置对象　175
6．15．1　request　175
6．15．2　response　176
6．15．3　session　177
6．15．4　application　179
6．15．5　out　180
6．15．6　pageContext　180
6．15．7　config　181
6．15．8　page　182
6．15．9　exception　183
6．16　Log4j配置　184
6．16．1　配置Log4j　184
6．16．2　配置Logback　186
6．17　小结　188
第7章　数据库　189
7．1　MySQL　189
7．1．1　安装　189
7．1．2　命令　191
7．1．3　profiling　196
7．1．4　SQLyog　198
7．2　Oralce　199
7．2．1　安装　200
7．2．2　命令　202
7．2．3　PLSQL　205
7．3　NoSQL　207
7．3．1　MongoDB　207
7．3．2　Redis　210
7．4　MyBatis　212
7．4．1　MyBatis环境搭建　212
7．4．2　MyBatis配置参数　215
7．5　Hibernate　219
7．5．1　Hibernate环境搭建　219
7．5．2　Hibernate配置参数　222
7．6　函数　222
7．7　游标　223
7．8　存储过程　224
7．9　小结　225
第8章　Struts Spring Hibernate　226
8．1　框架搭建　226
8．1．1　整体规划　226
8．1．2　MVC理念　227
8．2　框架集成　233
8．2．1　Struts 2的集成　233
8．2．2　Spring 3的集成　234
8．2．3　Hibernate的集成　235
8．2．4　前端插件的集成　236
8．3　权限管理　236
8．3．1　业务设计　237
8．3．2　程序设计　238
8．3．3　数据库设计　247
8．4　架构设计　250
8．4．1　逻辑层　250
8．4．2　业务层　255
8．4．3　持久层　256
8．4．4　架构优化　258
8．4．5　架构拓展　259
8．4．6　配置文件　268
8．5　报表导出　282
8．5．1　POI介绍　282
8．5．2　POI导出前端实现　283
8．5．3　POI导出后端实现　284
8．5．4　下载Excel文件　289
8．5．5　CSV介绍　290
8．5．6　CSV导出前端实现　291
8．5．7　CSV导出后端实现　292
8．5．8　下载CSV文件　295
8．5．9　导出功能XML文件配置　297
8．6　加入缓存机制　297
8．6．1　Ehcache的搭建　297
8．6．2　Ehcache的使用　300
8．7　解决并发问题　301
8．7．1　连接池　301
8．7．2　Nginx　302
8．8　小结　306
第9章　Spring MVC　307
9．1　框架搭建　307
9．1．1　整体规划　307
9．1．2　技术选型　308
9．1．3　项目结构　309
9．2　详细设计　309
9．2．1　业务设计　310
9．2．2　原型设计　310
9．2．3　数据库设计　310
9．3　架构设计　311
9．3．1　逻辑层　311
9．3．2　业务层　315
9．3．3　持久层　316
9．3．4　配置文件　323
9．4　POI导入　334
9．4．1　POI导入前端实现　334
9．4．2　POI导入后端实现　336
9．5　小结　342
第　10章 电商平台　343
10．1　框架搭建　343
10．1．1　整体规划　343
10．1．2　技术选型　344
10．2　详细设计　344
10．2．1　业务设计　344
10．2．2　原型设计　344
10．2．3　数据库设计　345
10．3　架构设计　346
10．3．1　逻辑层　346
10．3．2　业务层　348
10．3．3　持久层　349
10．3．4　数据通道　350
10．4　支付接口　352
10．4．1　开发账号　352
10．4．2　支付接口集成　354
10．4．3　支付接口调试　357
10．5　JDBC连接类　361
10．6　小结　364
第　11章 产品思维　365
11．1　何谓产品化　365
11．1．1　三个标准　365
11．1．2　软件服务　366
11．2　软件产品化　368
11．2．1　开发文档　368
11．2．2　产品风格　368
11．2．3　前端框架　369
11．2．4　后端框架　371
11．3　图表项目　372
11．3．1　Bootstrap插件　372
11．3．2　ECharts图表　374
11．4　小结　376
第　12章 项目运维　377
12．1　平台维护　377
12．1．1　系统上线　378
12．1．2　运维报告　380
12．2　SonarQube代码扫描　381
12．2．1　环境搭建　381
12．2．2　PMD模板方式　381
12．2．3　Java自定义规则　386
12．3　Jenkins自动化部署　394
12．3．1　部署介绍　394
12．3．2　搭配使用　394
12．4　数据迁移　397
12．4．1　场景分析　397
12．4．2　ETL工具　397
12．5　小结　399
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java架构师指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>国外议会组织架构和运作程序
第一编 当代英国议会组织架构和运作程序第二编 当代法国议会组织架构和动作程序第三编 当代美国国会组织架构和动作程序第四编 当代德国议会组织架构和动作程序第五编 当代意大利议会组织架构和动作程序第六编 当代日本国会组织架构和运作程序附录交献后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>国外议会组织架构和运作程序
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>集团企业IT架构治理实践
第1章 集团企业信息化的挑战与应对
1.1 集团企业信息化建设的特点与难点
1.1.1 信息化是集团企业管控的利器
1.1.2 集团企业信息化建设遇到的挑战
1.2 解开集团企业信息化难题的钥匙
1.2.1 集团企业信息化建设的两翼
1.2.2 应对集团企业信息化挑战的总体思路
第2章 中国企业的IT治理体系
2.1 IT治理的概念与体系结构
2.2 中国企业的IT治理模型
2.2.1 中国企业IT治理总体框架
2.2.2 IT治理的十大内容体系
2.2.3 IT治理内容体系之间的关系
第3章 集团企业IT治理模式探析
3.1 集团企业的三大管控模式
3.1.1 资本管控型集团企业特点
3.1.2 战略管控型集团企业特点
3.1.3 运营管控型集团企业特点
3.2 集团企业IT治理模式总述
3.2.1 集团企业IT组织模式分析
3.2.2 IT决策与控制机制分析
3.3 资本管控型集团企业IT治理模式分析
3.3.1 资本管控型集团企业IT组织结构
3.3.2 资本管控型集团企业IT建设模式分析
3.3.3 资本管控型集团企业IT责权体系
3.4 战略管控型集团企业IT治理模式分析
3.4.1 战略管控型集团企业IT组织结构
3.4.2 战略管控型集团企业IT建设模式分析
3.4.3 战略管控型集团企业IT责权体系
3.5 运营管控型集团企业IT治理模式分析
3.5.1 运营管控型集团企业IT组织结构
3.5.2 运营管控型集团企业IT建设模式分析
3.5.3 运营管控型集团企业IT责权体系
3.6 集团企业IT治理面临的共性难题
第4章 企业架构解析
4.1 企业架构概念解析
4.1.1 企业架构的内涵与外延
4.1.2 企业架构的作用与价值
4.2 四大主流架构框架比较
4.2.1 Zachman框架：架构框架的开山鼻祖
4.2.2 TOGAF：企业架构的“集大成者
4.2.3 DoDAF：最”实战“的架构框架
4.2.4 FEA：美国联邦政府IT投资指南
4.2.5 四大架构框架评价与对比
4.3 企业架构框架分解与分块架构
4.3.1 企业架构的内容框架与地位
4.3.2 业务架构是企业架构的先导
4.3.3 数据架构是企业架构的核心
4.3.4 应用架构是企业IT的缩影
4.3.5 基础架构是数据和应用的支撑
4.3.6 新技术对IT架构设计的影响
4.3.7 业务架构与IT架构的融合
4.3.8 IT标准是企业架构落地的保障
第5章 企业架构在集团企业的落地
5.1 企业架构实施的情境分析
5.1.1 中国企业实施企业架构面临的挑战
5.1.2 企业架构实施的动力
5.1.3 实施企业架构的时机选择
5.1.4 企业架构实施的组织保证
5.2 企业架构的优化与实施方法论
5.2.1 企业架构的”时“、”空“分析
5.2.2 企业架构实施的策略与原则
5.2.3 企业架构实施的”四步走“模型
5.3 企业架构成熟度提升策略
第6章 基于企业架构的IT治理
6.1 基于企业架构的IT治理框架
6.1.1 信息化生命周期中的IT治理
6.1.2 基于企业架构的IT生命周期治理
6.2 企业架构在IT需求立项治理中的应用
6.2.1 IT需求立项治理遇到的问题与挑战
6.2.2 基于企业架构的IT立项治理
6.3 企业架构在IT方案选型治理中的应用
6.3.1 IT选型的问题与挑战
6.3.2 基于企业架构的IT方案选型
6.4 企业架构在IT项目实施治理中的应用
6.4.1 IT项目实施中的管控流程与问题
6.4.2 基于企业架构的IT项目治理结构
6.5 企业架构在IT运维变更中的应用
6.5.1 IT运维与服务中的变更难题
6.5.2 基于企业架构的IT变更管控
第7章 X集团企业架构优化与治理案例
7.1 X集团信息化面临的挑战
7.1.1 X集团简介与管控模式分析
7.1.2 X集团信息化现状与问题
7.2 X集团企业架构优化与治理实践
7.2.1 企业架构管理体系优化的准备工作
7.2.2 第一阶段：总部架构规划
7.2.3 第二阶段：产业集团架构规划
7.3 X集团企业架构规划的收益与不足
7.3.1 企业架构实施是一个长期的过程
7.3.2 对其他企业实施企业架构的几点建议
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>集团企业IT架构治理实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据架构师的PostgreSQL修炼：高效设计、开发与维护数据库应用
作者简介
审校者简介
前　言
第1章　安装PostgreSQL 1
1.1　安装选项 1
1.1.1　下载并提取源码 2
1.1.2　检查源码内容 3
1.2　编译源码的各种依赖 3
1.3　配置和创建makefile 4
1.4　建立和创建可执行文件 6
1.5　安装和移动文件到指定的位置 7
1.6　初始化集群 9
1.6.1　快速了解各个目录 11
1.6.2　已创建的进程 13
1.6.3　创建的重要文件 14
1.7　与扩展程序相互协作 14
1.8　小结 15
第2章　服务器架构 16
2.1　从守护进程开始 16
2.2　理解共享缓冲区 18
2.3　检查点 23
2.4　WAL与WAL写进程 25
2.4.1　恢复 26
2.4.2　增量备份和基于时间点的恢复 26
2.4.3　复制 27
2.5　后台写入器 28
2.6　自动清空加载器进程 29
2.7　日志进程 32
2.8　统计信息收集器进程 35
2.9　WAL发送器和WAL接收器 38
2.10　使用work_mem在内存中进行排序 38
2.11　使用maintenance_work_mem进行维护 40
2.12　小结 42
第3章　PostgreSQL——对象层次和角色 43
3.1　PostgreSQL集群 43
3.2　了解表空间 44
3.2.1　使用临时表空间管理临时对象 46
3.2.2　视图 48
3.3　数据库、模式与search_path 48
3.4　角色和权限 53
3.5　小结 56
第4章　使用事务进行工作 57
4.1　了解事务 57
4.2　PostgreSQL和MVCC 67
4.3　小结 70
第5章　使用SQL Power Architect进行数据建模 71
5.1　数据库工具及其用途 71
5.2　数据库设计工具 72
5.2.1　下载与安装SQL Power Architect 73
5.2.2　创建表 74
5.3　生成SQL 75
5.3.1　逆向工程及变更操作 77
5.3.2　导出数据模型 78
5.3.3　分析 78
5.4　小结 79
第6章　客户端工具 80
6.1　GUI工具与命令行工具 80
6.2　下载与安装pgAdmin 80
6.2.1　添加一台服务器 81
6.2.2　pgAdmin主窗口 82
6.2.3　查询工具 84
6.3　psql——在命令行模式下工作 86
6.3.1　psql——连接选项 86
6.3.2　\d的功能 87
6.3.3　更多元命令 89
6.3.4　设置环境 91
6.3.5　命令的历史记录 92
6.4　小结 92
第7章　SQL调优 93
7.1　了解数据库的基本事实 93
7.1.1　事实1，数据库中读比写更频繁 93
7.1.2　事实2，数据始终在块或页面中读取，而不是作为单独的记录或列 94
7.1.3　减少读/写块的数量的方法 94
7.2　查询执行组件 95
7.2.1　计划器 95
7.2.2　访问方法 95
7.2.3　连接策略 96
7.3　发现执行计划 96
7.4　优化指南和捕捉 98
7.4.1　外键索引 99
7.4.2　使用SELECT* 100
7.4.3　使用ORDER BY 100
7.4.4　使用DISTINCT 101
7.4.5　使用UNION ALL代替UNION 102
7.4.6　在FILTER子句中使用函数 102
7.4.7　减少SQL语句数量 104
7.4.8　减少函数执行 105
7.4.9　不使用索引的情况 107
7.4.10　部分索引 108
7.4.11　优化函数 109
7.5　小结 110
第8章　服务器调优 111
8.1　服务器端内存设置 111
8.1.1　shared_buffers 111
8.1.2　effective_cache_size 112
8.2　管理写入、连接和维护操作 113
8.3　查找/扫描开销及统计参数 114
8.4　物化视图 119
8.5　分区表 121
8.6　小结 125
第9章　PostgreSQL写入与读取数据工具 126
9.1　考虑建立生产数据库 126
9.2　COPY 命令 127
9.3　使用pg_bulkload快速加载 130
9.4　pg_dump 命令 131
9.5　过滤选项 133
9.5.1　pg_dumpall 工具 133
9.5.2　pg_restore 工具 133
9.6　小结 135
第10章　扩展、复制、备份和恢复 136
10.1　可扩展性 136
10.1.1　垂直扩展 137
10.1.2　水平扩展 138
10.2　基于时间点的恢复 154
10.3　小结 157
第11章　PostgreSQL 故障排除 158
11.1　连接问题 158
11.2　验证和权限问题 159
11.3　参数更改无效 161
11.4　查询无响应 162
11.5　小结 165
第12章　PostgreSQL额外功能 166
12.1　有趣的数据类型 166
12.1.1　range 166
12.1.2　XML 174
12.1.3　几何与地理数据 175
12.1.4　外部数据封装器 175
12.1.5　pgbadger 178
12.2　变化中的产品特性 180
12.3　小结 183
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据架构师的PostgreSQL修炼：高效设计、开发与维护数据库应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>汽车悬架构件的设计计算
前言
第一章汽车悬架的基本知识1
第一节汽车悬架构件1
一、导向机构1
二、弹性元件1
三、梯形机构2
四、阻尼元件2
五、稳定装置2
第二节汽车悬架型式3
一、悬架的基本要求3
二、悬架的分类3
（一）按功能原理划分3
（二）按导向机构划分4
（三）按弹性元件划分11
第三节汽车悬架型式的发展20
一、导向机构悬架型式的发展20
（一）单臂悬架的发展20
（二）从单臂到双臂22
（三）麦弗逊悬架22
（四）平衡悬架23
二、弹性元件悬架型式的发展23
（一）钢板弹簧悬架23
（二）螺旋弹簧悬架31
（三）扭杆弹簧悬架32
（四）空气弹簧悬架34
（五）油气弹簧悬架38
第二章汽车悬架的基础理论40
第一节汽车悬架术语和力矩中心40
一、特定术语40
二、力矩中心41
（一）定义41
（二）相关定理42
（三）悬架的侧倾力矩中心46
（四）悬架的纵倾力矩中心49
第二节多轴汽车的特性参数50
一、特性参数50
（一）外心距50
（二）组合线刚度51
（三）中性面52
（四）内心距54
（五）换算线刚度54
二、角刚度与角刚度比56
（一）角刚度56
（二）角刚度比59
第三节汽车平顺性的评价指标64
一、ISO2631标准64
二、常用评价指标66
第四节汽车操纵稳定性的评价指标68
一、定义及研究对象68
二、评价指标69
三、车身稳定性69
第三章汽车悬架构件的设计计算70
第一节汽车导向机构70
一、车轮定位参数70
（一）轮距70
（二）车轮外倾角71
（三）前束72
二、麦弗逊悬架的导向机构73
（一）悬架中心和力矩中心74
（二）换算线刚度和角刚度74
（三）受力分析74
三、半拖臂悬架的导向机构77
（一）相关参数77
（二）线刚度与角刚度80
（三）设计要点81
四、双横臂悬架的导向机构83
（一）空间模型83
（二）运动学特性86
（三）弹性元件受力90
（四）换算线刚度与角刚度93
（五）摆臂临界角100
五、单纵臂悬架的导向机构100
六、钢板弹簧悬架的导向机构102
（一）对称板簧的运动特性102
（二）非对称板簧的运动特性104
（三）中心扩展法的作图步骤及其修正方法104
（四）两点偏转法的作图步骤及其修正方法107
第二节汽车弹性元件108
一、钢板弹簧109
（一）普通钢板弹簧110
（二）变断面钢板弹簧133
（三）渐变刚度钢板弹簧153
（四）非对称钢板弹簧163
二、螺旋弹簧168
（一）普通压缩螺旋弹簧171
（二）变参数压缩螺旋弹簧174
（三）变节距压缩螺旋弹簧184
（四）变圈径等节距压缩螺旋弹簧185
（五）等螺旋角圆锥压缩螺旋弹簧187
（六）变丝径等内径压缩螺旋弹簧194
三、扭杆弹簧200
（一）端部结构和相关参数200
（二）变形及刚度202
（三）扭杆直径的确定203
（四）容量与容量比204
（五）材料和应力205
四、空气弹簧205
（一）空气弹簧的特点205
（二）空气弹簧的类型206
（三）空气弹簧的刚度计算207
五、油气弹簧212
六、橡胶弹簧212
（一）橡胶弹簧的类型和弹性特性217
（二）橡胶弹簧的静刚度计算219
第三节汽车稳定装置227
一、稳定装置的设计规范227
二、稳定装置的设计计算230
三、结构及布置233
四、普通型杆体变形公式的推导233
第四节汽车梯形机构236
一、普通梯形机构236
（一）内外轮转角关系236
（二）转弯半径的计算237
（三）梯形机构的转向特性237
（四）转向机构附加牵动轮转向241
二、断开式梯形机构245
（一）机构的设计245
（二）内外轮转角关系247
（三）侧倾牵动车轮偏转角250
第五节汽车阻尼元件259
一、汽车阻尼元件的分类及发展259
（一）减振器的分类259
（二）减振器的发展261
二、汽车阻尼元件的选用设计267
（一）阻尼特性267
（二）阻尼比267
（三）阻尼系数268
（四）最大卸荷力280
（五）工作缸直径的确定280
（六）合理的布置位置280
附表282
附表1变丝径等圈径等螺旋角压缩螺旋弹簧（———）282
附表2等丝径变节距等圈径压缩螺旋弹簧（——）283
附表3等丝径等节距圆锥压缩螺旋弹簧（——）284
附表4等丝径等螺旋角圆锥压缩螺旋弹簧（——）285
附表5变丝径等簧径变节距变螺角压缩螺旋弹簧（—）286
附表6变丝径等节距变圈径压缩螺旋弹簧（—）287
附表7变丝径等螺角圆锥压缩螺旋弹簧（—）288
附表8变丝径等螺旋角圆锥压缩螺旋弹簧 （—）289
附表9变丝径变节距变螺角圆锥压缩螺旋弹簧（）290
附表10变丝径等螺角中凹双圆锥压簧，变丝径变节距中凸变圈径压缩螺旋弹簧（，）291
附表11无簧圈叠压变丝径等螺角圆锥压缩螺旋弹簧292
附表12变丝径等螺角上直下锥压缩螺旋弹簧（）293
附表13变丝径等内径组合式压缩螺旋弹簧294
附表14各种截面形状的扭杆弹簧的设计计算公式295
参考文献296
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>汽车悬架构件的设计计算
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Service Mesh微服务架构设计
前言
第一篇　基　础　篇
第1章　微服务架构 …… 2
1.1　为什么需要微服务 …… 2
1.1.1　传统单体服务的问题 …… 2
1.1.2　微服务的定义 …… 3
1.1.3　微服务与康威定律 …… 3
1.1.4　微服务的收益 …… 4
1.2　微服务架构的挑战 …… 4
1.2.1　服务拆分 …… 4
1.2.2　开发挑战 …… 5
1.2.3　测试挑战 …… 5
1.2.4　运维挑战 …… 6
1.3　微服务化的具体时机 …… 6
1.4　微服务化开展前的准备工作 …… 8
1.4.1　微服务开发框架 …… 8
1.4.2　微服务标准化 …… 15
1.4.3　持续集成与发布 …… 17
1.5　微服务实施 …… 17
1.5.1　微服务拆分 …… 17
1.5.2　微服务通信 …… 19
1.5.3　微服务稳定性保障 …… 20
1.6　本章小结 …… 25
第2章　微服务治理 …… 26
2.1　微服务治理基础 …… 26
2.1.1　服务治理由来 …… 26
2.1.2　服务治理的目标与愿景 …… 27
2.1.3　服务治理的工作范畴 …… 28
2.1.4　服务治理闭环体系 …… 29
2.2　正向服务治理 …… 29
2.2.1　效率治理 …… 30
2.2.2　稳定性治理 …… 31
2.3　效果治理 …… 34
2.4　可见可观测 …… 35
2.4.1　服务可见性 …… 35
2.4.2　变更可见性 …… 36
2.4.3　可观测性 …… 36
2.5　量化分析体系 …… 41
2.5.1　稳定性风险度量 …… 41
2.5.2　基于多维度监控的故障定位 …… 42
2.5.3　风险分析 …… 43
2.6　线上治理 …… 43
2.6.1　线上预案体系 …… 43
2.6.2　基于Metric的预案自动触发 …… 44
2.6.3　治理参数动态调整 …… 44
2.7　线下治理 …… 47
2.7.1　链路稳定性治理 …… 47
2.7.2　架构与资源治理 …… 50
2.8　服务治理演进 …… 50
2.8.1　远程Proxy方式 …… 51
2.8.2　基于智能客户端的服务框架 …… 52
2.8.3　本地Proxy …… 52
2.9　理想的服务治理架构 …… 53
2.10　本章小结 …… 54
第3章　下一代微服务框架Service Mesh概要 …… 55
3.1　Service Mesh基础 …… 55
3.1.1　什么是Service Mesh …… 55
3.1.2　Service Mesh的基本模式 …… 56
3.2　Service Mesh的发展历程 …… 58
3.3　Service Mesh项目Linkerd …… 60
3.3.1　Linkerd演进 …… 60
3.3.2　Linkerd路由机制 …… 62
3.3.3　Linkerd 2.0核心架构 …… 63
3.4　Service Mesh项目Istio …… 64
3.4.1　Envoy …… 64
3.4.2　Istio …… 66
3.5　Service Mesh其他解决方案 …… 67
3.5.1　国外其他Service Mesh项目 …… 67
3.5.2　Service Mesh在中国的发展 …… 68
3.6　Service Mesh云上产品 …… 69
3.6.1　AWS App Mesh …… 69
3.6.2　Azure Service Fabric Mesh …… 69
3.6.3　Google Cloud Service Mesh …… 70
3.6.4　SuperGloo …… 70
3.7　Service Mesh标准化 …… 71
3.8　本章小结 …… 71
第二篇　架　构　篇
第4章　Envoy架构剖析 …… 74
4.1　Envoy整体架构 …… 74
4.1.1　关键设计约束 …… 74
4.1.2　设计原则 …… 75
4.1.3　整体架构 …… 76
4.2　Envoy网络模型 …… 78
4.2.1　Envoy事件调度模型 …… 78
4.2.2　Envoy线程模型 …… 81
4.2.3　线程本地存储机制 …… 81
4.3　Envoy扩展模型 …… 84
4.3.1　插件扩展机制 …… 84
4.3.2　网络相关插件 …… 86
4.3.3　其他扩展插件 …… 88
4.4　Envoy数据平面API …… 88
4.4.1　XDS协议语义 …… 88
4.4.2　XDS协议通信 …… 90
4.5　Envoy启动管理 …… 91
4.5.1　正常启动 …… 92
4.5.2　热重启 …… 94
4.6　Envoy与Nginx架构层面的对比 …… 95
4.6.1　功能与定位 …… 96
4.6.2　网络模型 …… 96
4.6.3　连接处理 …… 97
4.6.4　插件机制 …… 98
4.6.5　配置管理 …… 99
4.6.6　内存管理 …… 99
4.6.7　部署与运维 …… 100
4.6.8　观测与诊断 …… 100
4.7　本章小结 …… 100
第5章　Istio架构剖析 …… 101
5.1　Istio整体架构 …… 101
5.1.1　数据平面组件 …… 102
5.1.2　控制平面组件 …… 103
5.2　Istio的Kubernetes基础 …… 104
5.2.1　Kubernetes综述 …… 104
5.2.2　Kubernetes网络访问模型 …… 107
5.2.3　Kubernetes API管理 …… 110
5.2.4　Istio与Kubernetes的相互关系 …… 111
5.3　Istio流量控制模型 …… 112
5.3.1　流量管理API …… 112
5.3.2　Istio Mesh模型 …… 116
5.4　Mixer模型 …… 118
5.4.1　Mixer基本概念 …… 119
5.4.2　Mixer通用配置模型 …… 119
5.4.3　Mixer架构演进以及对性能的影响 …… 121
5.5　Istio安全 …… 122
5.5.1　Istio安全基础 …… 122
5.5.2　Istio认证架构 …… 123
5.6　Istio配置处理框架 …… 124
5.6.1　配置验证 …… 125
5.6.2　配置变更处理和分发 …… 125
5.7　本章小结 …… 125
第6章　Istio控制流设计 …… 126
6.1　Envoy生命周期管理 …… 126
6.1.1　Envoy注入 …… 126
6.1.2　Envoy启动管理 …… 128
6.1.3　Envoy配置和运行状态监控 …… 131
6.2　Istio配置变更管理 …… 133
6.2.1　通用模型和机制 …… 133
6.2.2　Kubernetes具体实现 …… 137
6.3　控制平面和数据平面的XDS交互 …… 138
6.3.1　控制平面的gRPC Server启动 …… 139
6.3.2　Envoy的XDS请求 …… 140
6.3.3　Istio XDS配置下发 …… 140
6.3.4　Envoy的XDS消息接收 …… 143
6.4　XDS配置生成 …… 143
6.4.1　可见性 …… 143
6.4.2　配置生成机制 …… 145
6.4.3　XDS配置生成实现 …… 147
6.5　XDS配置的Envoy处理 …… 149
6.5.1　XDS配置变更的判断 …… 149
6.5.2　CDS配置的延迟处理 …… 150
6.5.3　集群和节点配置处理 …… 152
6.5.4　路由配置处理 …… 153
6.5.5　监听器配置处理 …… 153
6.6　本章小结 …… 155
第7章　Istio数据流设计 …… 156
7.1　Iptables …… 156
7.1.1　Iptables的基本原理 …… 156
7.1.2　Iptables在Istio中的使用 …… 158
7.2　监听管理 …… 158
7.2.1　监听器建立 …… 158
7.2.2　监听器和工作线程绑定 …… 159
7.3　连接管理 …… 160
7.3.1　监听器匹配 …… 160
7.3.2　协议过滤器匹配 …… 161
7.3.3　创建新连接 …… 161
7.4　网络I/O和缓冲区管理 …… 162
7.4.1　传输层数据读取 …… 162
7.4.2　插件处理 …… 163
7.5　Thrift协议处理 …… 164
7.5.1　Thrift插件的整体架构 …… 164
7.5.2　协议解析 …… 165
7.5.3　协议相关的插件机制 …… 166
7.6　HTTP请求处理 …… 168
7.6.1　HTTP请求处理流程 …… 168
7.6.2　协议解析 …… 169
7.6.3　路由管理 …… 171
7.6.4　HTTP过滤链处理 …… 174
7.6.5　负载均衡 …… 176
7.6.6　连接池实现 …… 179
7.7　本章小结 …… 182
第8章　Istio微服务治理 …… 183
8.1　链路稳定性治理 …… 183
8.1.1　超时机制 …… 183
8.1.2　重试机制和重试策略 …… 185
8.1.3　节点熔断和健康检查机制 …… 188
8.1.4　资源限制机制 …… 189
8.1.5　全局限流机制 …… 190
8.2　链路可观测性 …… 190
8.2.1　Envoy分布式跟踪支持 …… 190
8.2.2　Envoy Metric支持 …… 194
8.2.3　Envoy Log支持 …… 198
8.3　本章小结 …… 200
第9章　Service Mesh架构的工程化设计 …… 201
9.1　复用和解耦 …… 201
9.2　架构扩展机制 …… 203
9.2.1　服务注册中心插件机制 …… 203
9.2.2　Envoy Filter插件机制 …… 203
9.3　性能设计 …… 204
9.3.1　基于TLS的无锁设计 …… 204
9.3.2　多级缓存机制 …… 205
9.3.3　批量更新机制 …… 205
9.4　架构设计的权衡 …… 206
9.5　API和SDK设计 …… 207
9.5.1　声明式API设计 …… 207
9.5.2　代码自动生成机制 …… 207
9.6　配置管理 …… 208
9.6.1　基于Protobuf 3的配置Scheme描述 …… 208
9.6.2　配置动态加载机制 …… 210
9.7　本章小结 …… 210
第10章　Service Mesh与云原生架构 …… 211
10.1　Service Mesh和Serverless …… 211
10.1.1　Serverless基础 …… 211
10.1.2　Knative …… 213
10.2　东西向和南北向通信的统一 …… 215
10.3　云原生时代的Service Mesh …… 216
10.4　Service Mesh现状和展望 …… 217
10.5　本章小结 …… 218
附录　Service Mesh迁移的要点与原则 …… 219
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Service Mesh微服务架构设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Windows Server 2008网络基础架构
第1章 IP协议及配置方法  课前准备  第1课 网络连接及其配置方法    1．1．1 何为网络层次    1．1．2 探究TCP／IP网络模型的各层次    1．1．3 WindowsVista或WindowsServer2008客户端网络属性的配置    1．1．4 练习：TCP／IP地址的配置    1．1．5 本课摘要    1．1．6 复习题  第2课 理解IP版本4(IPv4)寻址    1．2．1 IPv4地址的结构    1．2．2 理解路由选择与默认网关    1．2．3 理解IPv4地址范围    1．2．4 何为划分子网    1．2．5 划分子网的益处    1．2．6 子网的ID    1．2．7 确定子网数    1．2．8 使用可变长度的子网掩码(VLSM)    1．2．9 练习：学习地址块的使用    1．2．10 本课摘要    1．2．11 复习题  第3课 理解IP版本6(IPv6)寻址    1．3．1 IPv6地址概述    1．3．2 理解IPv6地址类型    1．3．3 IPv6转换技术    1．3．4 练习：测试IPv6连通性    1．3．5 本课摘要    1．3．6 复习题  本章回顾    本章摘要    关键术语    情景分析    提高练习    模拟测试第2章 名称解析的配置  课前准备  第1课 理解WindowsServer2008中的名称解析    2．1．1 Windows中的名称解析方法    2．1．2 什么是“链路局部多播名称解析”(LLMNR)    2．1．3 什么是NetBIOS名称解析    2．1．4 什么是DNS名称解析    2．1．5 DNS的组成    2．1．6 理解DNS查询的工作方式    2．1．7 理解缓存的工作机理    2．1．8 练习：探索局域网中的自动名称解析    2．1．9 本课摘要    2．1．10 复习题  第2课 DNS服务器的部署    2．2．1 在域控制器上部署DNS服务器    2．2．2 在独立的服务器或成员服务器上部署DNS服务器    2．2．3 在WindowsServer2008“服务器核心”安装上部署DNS服务器    2．2．4 仅用于缓存DNS服务器的配置    2．2．5 服务器属性的配置    2．2．6 练习：探索ActiveDirectory环境中的DNS    2．2．7 本课摘要    2．2．8 复习题  第3课 DNS客户端的配置    2．3．1 指定DNS服务器    2．3．2 指定计算机名和DNS后缀    2．3．3 后缀查找列表的配置    2．3．4 动态更新设置的配置    2．3．5 DNS客户端缓存的查看与清空    2．3．6 练习：管理DNS客户端缓存    2．3．7 木课摘要    2．3．8 复习题  本章回顾    本章摘要    关键术语    情景分析    提高练习    模拟测试第3章 DNS区域基础设施的配置  课前准备  第1课 区域的创建与配置    3．1．1 区域的创建    3．1．2 内建的资源记录    3．1．3 资源记录的创建    3．1．4 使DNS能够使用WINS解析    3．1．5 老化与清理    3．1．6 使用GlobalNames区域    3．1．7 练习：GlobalNames区域的部署    3．1．8 本课摘要    3．1．9 复习题  第2课 区域复制与传送的配置    3．2．1 为ActiveDirectory集成的区域配置区域复制    3．2．2 使用区域传送    3．2．3 存根区域的实现    3．2．4 练习：创建DNS应用程序目录分区    3．2．5 练习：部署辅助区域    3．2．6 本课摘要    3．2．7 复习题    木章回颐    本章摘要    关键术语    情景分析    提高练习    模拟测试第4章 DHCP基础架构的建立  课前准备  第1课 DHCP服务器的安装    4．1．1 理解DHCP地址分配    4．1．2 “DHCP服务器”角色的添加    4．1．3 练习：部署DHCP服务器    4．1．4 本课摘要    4．1．5 复习题  第2课 DHCP服务器的配置    4．2．1 安装之后的任务    4．2．2 理解DHCP选项类别    4．2．3 在“服务器核心”安装上安装和配置DHCP    4．2．4 练习：创建排除范围    4．2．5 本课摘要    4．2．6 复习题  本章回顾    本章摘要    关键术语    情景分析    提高练习    模拟测试第5章 仰路由的配置  课前准备  第1课 路由    路由概述    检查网络路由    路由协议    静态路由    练习：分析与配置路由    本课摘要    复习题  本章回顾    本章摘要    关键术语    情景分析    提高练习    模拟测试第6章 使用IPSec保护网络通信  课前准备  第1课 IPSec的配置    什么是IPSec    在隧道模式下使用IPSec    IPSec的身份验证方法    分配预定义的IPSec策略    新“IPSec策略”的创建    连接安全规则的创建与配置    练习：通过lPSec策略和连接安全    规则来部署IPSec    本课摘要    复习题  本章回顾    本章摘要    关键术语    情景分析    提高练习    模拟测试第7章 网络连接  课前准备  第1课 网络地址转换的配置    7．1．1 网络地址转换概述    7．1．2 Internet连接共享的配置    7．1．3 配置使用“路由和远程访问”的“网络地址转换”    7．1．4 网络地址转换故障的排除    7．1．5 练习：配置NAT    7．1．6 本课摘要    7．1．7 复习题  第2课 无线网络的配置    7．2．1 无线网络概述    7．2．2 无线网络标准    7．2．3 无线安全标准    7．2．4 基础无线网络与临时无线网络    7．2．5 公钥基础结构的配置    7．2．6 使用WindowsServer2008对无线网络进行身份验证    7．2．7 无线网络的连接    7．2．8 部署具有WPA-EAP功能的无线网络    7．2．9 无线网络最佳实践    7．2．10 练习：为无线接入点配置WPA-EAP身份验证    7．2．11 本课摘要    7．2．12 复习题  第3课 远程网络的连接    7．3．1 远程访问概述    7．3．2 拨号连接的配置    7．3．3 VPN连接的配置    7．3．4 VPN连接故障的排除    7．3．5 连接限制的配置    7．3．6 连通性测试    7．3．7 练习：建立远程访问VPN连接    7．3．8 本课摘要    7．3．9 复习题  本章回顾    本章摘要    关键术语    情景分析    提高练习    模拟测试第8章 Windows防火墙与网络访问保护的配置  课前准备  第1课 Windows防火墙的配置    8．1．1 防火墙的重要性    8．1．2 防火墙配置文件    8．1．3 入站通信的筛选    8．1．4 出站通信的筛选    8．1．5 作用域的配置    8．1．6 连接的授权    8．1．7 使用“组策略”配置防火墙设置    8．1．8 启用Windows防火墙的日志记录    8．1．9 网络通信的识别    8．1．10 练习：配置Windows防火墙    8．1．11 本课摘要    8．1．12 复习题  第2课 网络访问保护的配置    8．2．1 网络访问保护概述    8．2．2 NAP部署的规划    8．2．3 网络策略服务器的安装与配置    8．2．4 NAP强制的配置    8．2．5 NAP组件的配置    8．2．6 NAP日志记录    8．2．7 练习：配置DHCPNAP强制    8．2．8 本课摘要    8．2．9 复习题  本章回顾    本章摘要    关键术语    情景分析    提高练习    模拟测试第9章 软件更新的管理  课前准备  第1课 理解Windows Server Update Services    9．1．1 WSUS概述    9．1．2 Windows Update客户端    9．1．3 WSUS的架构    9．1．4 WSUS的要求    9．1．5 WSUS安装的规划    9．1．6 更新的审核    9．1．7 本课摘要    9．1．8 复习题  第2课 使用WindowsServer Update Services    9．2．1 如何安装WindowsServer Update Services    9．2．2 如何配置WindowsServer Update Services    9．2．3 如何排除更新安装故障    9．2．4 如何移除更新    9．2．5 练习：使用WSUS部署更新    9．2．6 本课摘要    9．2．7 复习题  本章回顾    本章摘要    关键术语    情景分析    提高练习    模拟测试第10章 计算机的监视  课前准备  第1课事件日志的监视    10．1．1 事件转发概述    10．1．2 如何配置事件转发    10．1．3 练习：收集事件    10．1．4 本课摘要    10．1．5 复习题  第2课 性能与可靠性的监视    10．2．1 性能监视器    10．2．2 可靠性监视器    10．2．3 数据收集器集    10．2．4 练习：运行数据收集器集并分析结果    10．2．5 本课摘要    10．2．6 复习题  第3课 使用NetworkMonitor    10．3．1 NetworkMonitor的安装    10．3．2 网络通信的捕获与分析    10．3．3 练习：捕获和分析网络通信    10．3．4 本课摘要    10．3．5 复习题  本章回顾    本章摘要    关键术语    情景分析    提高练习    模拟测试第11章 文件的管理  课前准备  第1课 文件安全的管理    11．1．1 NTFS文件权限    11．1．2 文件系统的加密    11．1．3 练习：加密和恢复文件    11．1．4 本课摘要    11．1．5 复习题  第2课 文件夹的共享    11．2．1 “文件访问”服务器角色的安装    11．2．2 使用配额    11．2．3 文件夹的共享    11．2．4 DFS概述    11．2．5 脱机文件    11．2．6 练习：使用共享文件夹    11．2．7 本课摘要    11．2．8 复习题  第3课 文件的备份与恢复    11．3．1 卷影副本    11．3．2 Windows Server Backup    11．3．3 练习：备份和还原文件    11．3．4 本课摘要    11．3．5 复习题  本章回顾    本章摘要    关键术语    情景分析    提高练习    模拟测试第12章 打印机的管理  课前准备  第1课打印机的管理    “打印服务”服务器角色的安装    打印机的安装    打印机的共享    打印机权限的配置    打印机驱动程序的添加    打印机池的配置    打印机优先级的配置    Internet打印的管理    通知的生成    使用“组策略”来部署打印机    打印机的迁移    使用命令提示符或脚本来管理    打印机    打印机的监视    练习：安装和共享打印机    本课摘要    复习题  本章回顾    本章摘要    关键术语    情景分析    提高练习    模拟测试答案术语表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Windows Server 2008网络基础架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>“互联网+”时代的IT战略、架构与治理
前言
序
第1章传统企业进入“互联网+”转型时代
1.1企业“互联网+”转型大幕已经拉开
1.1.1当“互联网+”成为国家战略
1.1.2众说纷纭话“互联网+”
1.2传统企业的“互联网+”转型
1.2.1互联网向产业互联阶段进化
1.2.2传统企业的互联网焦虑症
1.2.3“互联网+”时代的四大特征
1.2.4“互联网+”转型的三个层次
1.2.5“互联网+”转型的四重境界
1.3“互联网+”转型推动企业信息化进入新常态
1.3.1企业信息化建设的三大发展阶段
1.3.2企业信息化3.0阶段的五大新常态
1.3.3企业信息化转型的六个重点
1.4推动企业信息化转型的四大IT新技术解读
1.4.1云计算：从云里雾里到必备品
1.4.2大数据：当数据成为战略资产
1.4.3移动信息化：泛在化的智能应用
1.4.4物联网：从智慧城市到智能制造
1.4.5IT新技术之间的关系分析
第2章企业信息化“互联网+”转型需要顶层设计
2.1以顶层设计思维指导企业信息化转型
2.1.1企业信息化转型遭遇的困惑
2.1.2以顶层设计指导企业信息化转型
2.2企业信息化转型顶层设计的三大要素
2.2.1要素一：信息化战略——信息化转型的指路明灯
2.2.2要素二：企业架构——绘制转型的美好蓝图
2.2.3要素三：治理机制——为转型保驾护航
第3章“互联网+”时代的企业信息化战略规划
3.1“互联网+”时代的业务战略转型
3.1.1企业战略管理的总体框架
3.1.2“互联网+”时代的战略制定
案例1：小米科技的四次战略转型
3.1.3传统企业的“互联网+”战略转型
案例2：TCL集团“互联网+”战略转型探索
3.2“互联网+”时代的企业信息化战略转型
3.2.1企业信息化战略与企业战略的关系
3.2.2专业化战略阶段的信息化战略
3.2.3多元化战略阶段的信息化战略
3.2.4平台化战略阶段的信息化战略
3.2.5企业信息化战略的制定与更新
案例3：某企业IT战略的演进历程
第4章“互联网+”时代的企业业务架构设计
4.1传统企业业务架构设计方法
4.1.1业务架构的内涵与总体框架
4.1.2商业模式分析与设计
4.1.3业务域与业务流程分析
4.1.4业务能力与创新分析
4.1.5组织结构与绩效分析
4.1.6IT需求汇总与分析
4.1.7业务架构设计思路
4.2“互联网+”时代的业务架构转型
4.2.1“互联网+”时代的业务架构之变
4.2.2“互联网+”时代的盈利模式之变
4.2.3“互联网+”时代的运营模式之变
4.2.4“互联网+”时代的组织结构之变
案例4：海尔“互联网+”转型探索之路
第5章“互联网+”时代的企业应用架构设计
5.1传统企业应用架构设计方法
5.1.1应用架构的内涵与内容框架
5.1.2总体应用布局规划
5.1.3总体应用框架及功能模块
5.1.4应用交互与集成分析
5.1.5应用集成平台设计
5.1.6应用/业务分布分析
5.1.7应用部署模式规划
5.1.8应用架构设计思路
5.2互联网时代的应用架构转型
5.2.1“互联网+”时代应用架构的创新
5.2.2用户交互系统的架构设计
5.2.3B2C电商交易系统架构设计
案例5：尚品宅配定制化O2O变革之路
第6章“互联网+”时代的企业数据架构设计
6.1传统企业数据架构设计方法
6.1.1数据架构设计的必要性
6.1.2企业数据架构的总体框架
6.1.3数据域/数据子域
6.1.4数据模型与数据标准
6.1.5数据业务/系统分布
6.1.6数据管理平台架构设计
6.2大数据时代的数据架构转型
6.2.1大数据技术总体架构框架
6.2.2大数据对传统数据架构的影响
6.2.3传统企业大数据平台建设
案例6：大数据时代农业银行金融创新
第7章“互联网+”时代的企业技术架构设计
7.1传统企业技术架构设计方法
7.1.1IT技术架构的内涵与框架
7.1.2企业软件系统技术框架
7.1.3IT基础设施设计框架
7.1.4IT总体技术框架与标准
7.2IT新技术环境下技术架构的转型
7.2.1互联网环境下IT技术的创新
案例7：华为IT技术创新应用实践分享
7.2.2云计算背景下的IT基础设施建设
案例8：新奥集团基础架构云实践
7.2.3基于PaaS平台的软件开发
7.2.4移动应用平台总体架构设计
第8章“互联网+”时代的IT治理转型
8.1IT治理机制的创新与完善
8.1.1IT治理体系的框架与内容
8.1.2“互联网+”时代IT治理的创新
8.2数据治理机制的构建与完善
8.2.1数据治理的内涵与总体框架
8.2.2数据治理的组织与运作机制
8.2.3数据全生命周期管理
8.2.4数据标准治理优化建议
8.2.5数据质量治理优化建议
8.2.6数据安全治理优化建议
8.3企业架构治理与管控
8.3.1企业架构治理的内涵与框架
8.3.2企业架构管理组织机构设置
8.3.3企业架构治理的内容与对象
8.3.4企业架构治理的过程模型
8.3.5企业架构治理的工具与技术
第9章企业信息化转型顶层设计的思路与方法
9.1企业信息化转型的总体思路
9.1.1企业信息化转型时机的选择
9.1.2企业信息化转型的四重境界
9.1.3企业信息化转型的四大原则
9.2“互联网+”转型顶层设计的方法
9.2.1企业信息化转型顶层设计的阶段划分
9.2.2现状调研与评估阶段的主要工作
9.2.3未来架构设计阶段的主要工作
9.2.4项目实施计划阶段的主要工作
附录：企业架构相关资源
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>“互联网+”时代的IT战略、架构与治理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业级Java EE架构设计精深实践
第1章  虚拟文件系统实践
1.1  背景介绍
1.2  什么是VFS
1.3  VFS对比
1.3.1  Apache VFS
1.3.2  Tiny VFS
1.4  VFS框架设计思想
1.5  VFS实现讲解
1.5.1  VFS管理器
1.5.2  SchemaProvider模式提供者
1.5.3  FileObject虚拟文件
1.5.4  FileObjectFilter过滤接口
1.6  VFS应用示例
1.6.1  本地文件
1.6.2  Jar文件
1.6.3  FTP文件
1.6.4  ZIP文件
1.7  本章总结
第2章  缓存实践
2.1  缓存简介
2.1.1  问题的提出及其解决方案分析
2.1.2  用户需求
2.1.3  Tiny缓存解决思路
2.2  字节码缓存设计
2.2.1  字节码操作工程
2.2.2  预编译工程
2.2.3  缓存实现工程
2.2.4  技术特点
2.3  动态代理缓存设计
2.3.1  缓存接口定义
2.3.2  切面缓存工程
2.3.3  技术特点
2.4  缓存方案实践
2.4.1  字节码方案配置
2.4.2  字节码方案示例
2.4.3  动态代理方案配置
2.4.4  动态代理方案示例
2.5  本章总结
2.5.1  关键点：缓存实现方案的可替换性
2.5.2  关键点：缓存代码与业务代码的解耦
2.5.3  关键点：模板语言的应用
第3章  文件处理框架实践
3.1  概述
3.1.1  FileProcessor接口
3.1.2  FileResolver接口
3.1.3  FileMonitorProcessor类
3.2  基础文件扫描器
3.2.1  XStreamFileProcessor类
3.2.2  I18nFileProcessor类
3.2.3  Annotation扫描器
3.2.4  SpringBeansFileProcessor类
3.3  完整示例
3.3.1  单独使用
3.3.2  通过配置文件配置
3.4  本章总结
第4章  模板语言实践
4.1  模板语言简介
4.1.1  模板语言构成
4.1.2  模板语言应用场景
4.2  常见的模板语言
4.2.1  Velocity模板语言
4.2.2  FreeMarker模板语言
4.2.3  Tiny模板语言
4.3  Tiny模板语言设计
4.3.1  Tiny模板语言的构建原因
4.3.2  模板语言执行方式
4.3.3  模板语言架构
4.3.4  Tiny模板语言实现与扩展
4.3.5  模板语言语法解析
4.3.6  模板语言渲染机制
4.4  模板语言的使用
4.4.1  依赖配置
4.4.2  模板语言的配置
4.4.3  模板语言的Eclipse插件
4.4.4  Hello,TinyTemplate
4.5  模板语言语法介绍
4.5.1  变量
4.5.2  取值表达式
4.5.3  Map常量
4.5.4  数组常量
4.5.5  其他表达式
4.5.6  索引表达式
4.5.7  #set指令
4.5.8  条件判断
4.5.9  ==相等运算
4.5.10  AND运算
4.5.11  OR运算
4.5.12  NOT运算
4.5.13  循环语句
4.5.14  循环状态变量
4.5.15  循环中断：#break
4.5.16  循环继续：# continue
4.5.17  while循环
4.5.18  模板嵌套语句#include
4.5.19  宏定义语句#macro
4.5.20  宏引入语句#import
4.5.21  布局重写语句#layout #@layout
4.5.22  停止执行#stop
4.5.23  返回指令#return
4.5.24  行结束指令
4.5.25  读取文本资源函数read和readContent
4.5.26  解析模板parser
4.5.27  格式化函数fmt、format和formatter
4.5.28  宏调用方法call和callMacro
4.5.29  实例判断函数is、instanceOf和instance
4.5.30  求值函数eval和evaluate
4.5.31  随机数函数rand和random
4.5.32  类型转换函数
4.5.33  日期格式转换formatDate
4.6  模板语言扩展
4.6.1  资源加载器的使用
4.6.2  宏的使用
4.6.3  函数的使用
4.6.4  国际化的使用
4.6.5  静态类和静态方法的使用
4.6.6  Servlet集成
4.6.7  SpringMVC集成
4.7  本章总结
第5章  数据库访问层实践
5.1  数据访问层简介
5.2  常见数据库访问层介绍
5.2.1  Hibernate简介
5.2.2  Ibatis简介
5.2.3  JPA简介
5.2.4  DSL数据库访问层简介
5.3  TinyDsl设计方案
5.3.1  SQL抽象化设计
5.3.2  DSL风格SQL设计
5.3.3  SQL执行接口设计
5.3.4  执行接口实现介绍
5.4  数据库访问层示例
5.4.1  工程创建
5.4.2  准备工作
5.4.3  Hibernate示例
5.4.4  Ibatis示例
5.4.5  JPA示例
5.4.6  TinyDsl示例
5.5  本章总结
第6章  数据库扩展实践
6.1  数据库扩展简介
6.2  常见数据库扩展方案
6.2.1  DAO层
6.2.2  DataSource层
6.2.3  JDBC层
6.2.4  Proxy层
6.3  读写分离
6.3.1  读写分离
6.3.2  负载均衡
6.3.3  数据同步
6.4  分库分表
6.4.1  同库分表
6.4.2  不同库分表
6.5  开源方案介绍
6.5.1  TDDL
6.5.2  Routing4DB
6.5.3  TinyDbRouter
6.5.4  开源方案的对比
6.6  TinyDbRouter的设计和实现
6.6.1  设计目标
6.6.2  设计原理之接入层设计
6.6.3  设计原理之SQL解析层设计
6.6.4  设计原理之路由决策层设计
6.6.5  设计原理之执行层设计
6.6.6  实现
6.7  应用实践
6.7.1  读写分离示例
6.7.2  分库分表示例
6.7.3  集群事务示例
6.7.4  元数据示例
6.7.5  自定义扩展
6.7.6  常见FAQ
6.8  本章总结
第7章  服务层实践
7.1  服务层简介
7.1.1  传统服务层
7.1.2  Tiny服务层
7.2  Tiny服务层介绍
7.2.1  服务声明
7.2.2  服务注册
7.2.3  小结
7.3  本地服务层实践
7.3.1  服务描述
7.3.2  服务定义
7.3.3  服务收集与注册
7.3.4  服务执行
7.3.5  小结
7.4  远程服务实践
7.4.1  传统的远程服务
7.4.2  新的远程服务模式
7.4.3  多服务中心支持
7.4.4  新的远程服务实现
7.4.5  小结
7.5  本地服务调用示例
7.5.1  非Tiny框架调用示例
7.5.2  Tiny框架应用调用
7.6  远程服务配置示例
7.6.1  非Tiny框架配置示例
7.6.2  Tiny框架应用配置
7.7  本章总结
第8章  流程引擎实践
8.1  流程引擎简介
8.1.1  流程引擎的来历
8.1.2  解决方案
8.1.3  特性简介
8.2  流程引擎实现
8.2.1  流程组件
8.2.2  流程组件配置
8.2.3  流程组件管理
8.2.4  流程配置
8.2.5  流程管理
8.2.6  流程执行
8.3  流程引擎特性
8.3.1  流程可继承性
8.3.2  灵活的EL表达式
8.3.3  流程可重入
8.3.4  流程可转出
8.3.5  强大异常处理
8.4  流程编辑器
8.4.1  创建流程
8.4.2  界面说明
8.4.3  操作说明
8.5  本章总结
第9章  元数据实践
9.1  元数据简介
9.1.1  问题背景
9.1.2  解决途径
9.2  基础元数据设计
9.2.1  支持语言类型
9.2.2  标准数据类型
9.2.3  业务数据类型
9.2.4  标准字段
9.3  数据库元数据设计
9.3.1  表及索引
9.3.2  视图
9.4  元数据开发指南
9.4.1  元数据加载机制
9.4.2  元数据处理器
9.5  元数据开发实践
9.5.1  Eclipse插件
9.5.2  应用配置
9.5.3  生成方言模板
9.5.4  生成标准数据类型
9.5.5  生成业务数据类型
9.5.6  生成标准字段
9.5.7  生成数据库表
9.5.8  定义元数据
9.5.9  生成Java代码
9.5.10  生成SQL
9.6  本章总结
第10章  展现层开发实践
10.1  展示层简介
10.1.1  Servlet
10.1.2  JSP
10.1.3  模板语言
10.1.4  展示层常见问题
10.2  展示层方案设计
10.2.1  UI组件包开发
10.2.2  资源合并实践
10.2.3  避免重复代码
10.2.4  国际化问题
10.3  前端访问方案实践
10.3.1  组件包封装
10.3.2  宏接口定义
10.3.3  页面和布局编写
10.3.4  前端参数配置
10.4  本章总结
10.4.1  关键点：DRY原则的实现
10.4.2  关键点：JS文件的合并
10.4.3  关键点：CSS文件的合并
第11章  Web扩展实践
11.1  背景简介
11.2  监听器设计原理
11.2.1  应用配置管理
11.2.2  应用处理器（ApplicationProcessor）
11.2.3  Web监听器
11.2.4  监听器配置管理
11.3  过滤器设计原理
11.3.1  请求上下文（WebContext）
11.3.2  TinyFilter介绍
11.4  处理器设计原理
11.4.1  过滤器配置（TinyProcessorConfig）
11.4.2  过滤器配置管理（TinyProcessorConfigManager）
11.4.3  处理器管理接口（TinyProcessorManager)
11.5  BasicTinyFilter类
11.5.1  拦截器接口
11.5.2  默认拦截器
11.6  SetLocaleTinyFilter类
11.6.1  Locale基础
11.6.2  Charset编码基础
11.6.3  Locale和charset的关系
11.6.4  设置locale和charset
11.6.5  使用方法
11.7  ParserTinyFilter类
11.7.1  基本使用方法
11.7.2  上传文件
11.7.3  高级选项
11.8  BufferedTinyFilter类
11.8.1  实现原理
11.8.2  使用方法
11.8.3  关闭buffer机制
11.9  LazyCommitTinyFilter类
11.9.1  什么是提交
11.9.2  实现原理
11.9.3  使用方法
11.10  RewriteTinyFilter类
11.10.1  概述
11.10.2  取得路径
11.10.3  匹配rules
11.10.4  匹配conditions
11.10.5  替换路径
11.10.6  替换参数
11.10.7  后续操作
11.10.8  重定向
11.10.9  自定义处理器
11.11  SessionTinyFilter类
11.11.1  概述
11.11.2  Session框架
11.11.3  Cookie Store
11.11.4  总结
11.12  SpringMVCTinyProcessor介绍
11.12.1  基于扩展协议的内容协商
11.12.2  约定开发
11.12.3  扩展协议
11.13  TinyWeb实践
11.13.1  准备工作
11.13.2  使用TinyHttpFilter
11.13.3  使用TinyProcessor
11.14  本章总结
第12章  Tiny统一界面框架实践
12.1  UIML简介
12.2  UIML开发指南
12.3  UIML使用实践
12.4  常见FAQ
12.5  本章总结
第13章  RESTful实践
13.1  RESTful简介
13.2  Spring RESTful实践
13.3  Tiny RESTful风格实践
13.4  Tiny RESTful实践
13.5  本章总结
附录A  相关资源
附录B  配置运行指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业级Java EE架构设计精深实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MongoDB实战 架构、开发与管理
第1章  大数据 1
1.1  入门指南 1
1.2  大数据 3
1.3  大数据源 4
1.4  大数据的三个V 5
1.4.1  数量 6
1.4.2  多样性 6
1.4.3  速率 7
1.5  大数据的使用 7
1.5.1  可见性 8
1.5.2  发现和分析信息 8
1.5.3  市场细分和产品定制 8
1.5.4  协助决策 8
1.5.5  创新 8
1.6  大数据的挑战 9
1.6.1  政策与程序 9
1.6.2  访问数据 9
1.6.3  技术与技能 9
1.7  传统系统与大数据 10
1.7.1  大数据的结构 10
1.7.2  数据存储 10
1.7.3  数据处理 10
1.8  大数据技术 10
1.9  本章小结 11
第2章  NoSQL 13
2.1  SQL 13
2.2  NoSQL 13
2.2.1  定义 14
2.2.2  NoSQL简史 14
2.3  ACID对比BASE 15
2.3.1  CAP定理 15
2.3.2  BASE 16
2.4  NoSQL的优缺点 17
2.4.1  NoSQL的优点 17
2.4.2  NoSQL的缺点 18
2.5  SQL与NoSQL数据库的
对比 18
2.6  NoSQL数据库的种类 21
2.7  本章小结 22
第3章  MongoDB介绍 23
3.1  历史 23
3.2  MongoDB设计原则 24
3.2.1  高速、可扩展性与敏捷性 24
3.2.2  非关系型方法 24
3.2.3  基于JSON的文档存储 25
3.2.4  性能与功能对比 25
3.2.5  随处都能运行数据库 25
3.3  与SQL的对比 26
3.4  本章小结 26
第4章  MongoDB数据模型 27
4.1  数据模型 27
4.1.1  JSON和BSON 28
4.1.2  标识符(_id) 29
4.1.3  固定集合 30
4.2  多态模式 30
4.2.1  面向对象编程 30
4.2.2  模式演化 31
4.3  本章小结 32
第5章  MongoDB-安装与配置 33
5.1  选择你的版本 33
5.2  在Linux上安装MongoDB 33
5.2.1  使用仓储进行安装 34
5.2.2  手动安装 34
5.3  在Windows上安装
MongoDB 35
5.4  运行MongoDB 35
5.4.1  先决条件 35
5.4.2  开启服务 36
5.5  验证安装结果 36
5.6  MongoDB Shell 36
5.7  保障部署安全 37
5.7.1  使用身份验证和授权 37
5.7.2  控制网络访问 42
5.8  使用MongoDB云管理器进行
配置 46
5.9  本章小结 50
第6章  使用MongoDB Shell 51
6.1  基本查询 51
6.1.1  创建和插入 56
6.1.2  显式创建集合 58
6.1.3  使用循环插入文档 58
6.1.4  通过显式指定_id进行插入 59
6.1.5  更新 59
6.1.6  删除 61
6.1.7  读取 62
6.1.8  使用索引 68
6.2  进阶介绍 78
6.2.1  使用条件操作符 78
6.2.2  正则表达式 80
6.2.3  MapReduce 81
6.2.4  aggregate() 83
6.3  设计应用程序的数据模型 84
6.3.1  关系型数据模型与标准化 84
6.3.2  MongoDB文档数据模型
方法 86
6.4  本章小结 93
第7章  MongoDB架构 95
7.1  核心程序 95
7.1.1  mongod 95
7.1.2  mongo 95
7.1.3  mongos 96
7.2  MongoDB工具 96
7.3  独立部署 96
7.4  复制 97
7.4.1  主/从复制 97
7.4.2  副本集 98
7.4.3  实现带有副本集的高级
群集 115
7.5  分片 124
7.5.1  分片组件 126
7.5.2  数据分发过程 127
7.5.3  数据平衡过程 130
7.5.4  操作 133
7.5.5  实现分片 134
7.5.6  控制集合分布
(基于标签分片) 142
7.5.7  在将数据导入到分片环境时
要记住的要点 152
7.5.8  监控分片 153
7.5.9  监控配置服务器 153
7.6  生产环境群集架构 153
7.6.1  场景1 154
7.6.2  场景2 155
7.6.3  场景3 156
7.6.4  场景4 157
7.7  本章小结 158
第8章  MongoDB阐释 159
8.1  数据存储引擎 159
8.2  (与MMAPv1相关的)数据
文件 161
8.3  (与WiredTiger相关的)数据
文件 168
8.4  读取和写入 170
8.5  使用日志时如何写入数据 172
8.6  GridFS——MongoDB文件
系统 176
8.6.1  GridFS的基本原理 177
8.6.2  GridFS的底层机制 177
8.6.3  使用GridFS 179
8.7  索引 182
8.7.1  索引类型 183
8.7.2  行为和限制 188
8.8  本章小结 189
第9章  管理MongoDB 191
9.1  管理工具 191
9.1.1  mongo 191
9.1.2  第三方管理工具 191
9.2  备份和恢复 191
9.2.1  数据文件备份 192
9.2.2  mongodump和
mongorestore 192
9.2.3  fsync和锁 196
9.2.4  从备份 198
9.3  导入和导出 198
9.3.1  mongoimport 198
9.3.2  mongoexport 199
9.4  管理服务器 199
9.4.1  启动一台服务器 199
9.4.2  停止服务器运行 200
9.4.3  浏览日志文件 200
9.4.4  服务器状态 201
9.4.5  识别和修复MongoDB 203
9.4.6  识别和修复集合级别的数据 204
9.5  监控MongoDB 205
9.5.1  mongostat 205
9.5.2  mongod网络接口 206
9.5.3  第三方插件 206
9.5.4  MongoDB云管理器 206
9.6  本章小结 212
第10章  MongoDB用例 213
10.1  用例1——性能监控 213
10.1.1  模式设计 213
10.1.2  操作 214
10.1.3  分片 218
10.1.4  管理数据 219
10.2  用例2——社交网络 220
10.2.1  模式设计 220
10.2.2  操作 222
10.2.3  分片 225
10.3  本章小结 225
第11章  MongoDB使用限制 227
11.1  MongoDB的空间过大(对于MMAPv1而言) 227
11.2  内存问题(对于MMAPv1而言) 228
11.3  32位与64位对比 228
11.4  BSON文档 228
11.5  命名空间使用限制 229
11.6  索引使用限制 229
11.7  固定集合使用限制——固定集合中文档的最大数量 229
11.8  分片使用限制 229
11.8.1  及早分片以避免出现问题 230
11.8.2  不能更新分片键 230
11.8.3  分片集合使用限制 230
11.8.4  选择合适的分片键 230
11.9  安全性限制 230
11.9.1  默认情况下没有身份验证 230
11.9.2  与MongoDB的交互通信没有被加密 231
11.10  写入和读取限制 231
11.10.1  大小写敏感的查询 231
11.10.2  类型敏感的字段 231
11.10.3  没有联结 231
11.10.4  事务 231
11.11  MongoDB不适用的范围 232
11.12  本章小结 232
第12章  MongoDB的最佳实践 233
12.1  部署 233
12.1.1  MongoDB网站的硬件
配置建议 234
12.1.2  要注意的一些要点 235
12.2  编码 235
12.3  应用程序响应时间优化 238
12.4  数据安全性 238
12.5  管理 239
12.6  复制延迟 239
12.7  分片 240
12.8  监控 240
12.9  本章小结 241
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MongoDB实战 架构、开发与管理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>领域驱动设计模式、原理与实践
第1部分领域驱动设计的原则与实践
第1章什么是领域驱动设计
1.1为复杂问题域创建软件的挑战
1.1.1未使用通用语言创建的代码
1.1.2组织结构的缺乏
1.1.3泥球模式将扼杀开发
1.1.4缺乏对问题域的关注
1.2领域驱动设计模式如何管理复杂性
1.2.1DDD的战略模式
1.2.2DDD的战术模式
1.2.3问题空间与解空间
1.3领域驱动设计的实践与原则
1.3.1专注于核心领域
1.3.2通过协作进行学习
1.3.3通过探索和实验来创建模型
1.3.4通信
1.3.5理解模型的适用性
1.3.6让模型持续发展
1.4领域驱动设计的常见误区
1.4.1战术模式是DDD的关键
1.4.2DDD是一套框架
1.4.3DDD是一颗灵丹妙药
1.5要点
第2章提炼问题域
2.1知识提炼与协作
2.1.1通过通用语言达成共识
2.1.2领域知识的重要性
2.1.3业务分析员的角色
2.1.4一个持续过程
2.2与领域专家一起获得领域见解
2.2.1领域专家与业务相关人员的对比
2.2.2对于业务的更深刻理解
2.2.3与你的领域专家互动
2.3有效提炼知识的模式
2.3.1专注在最有意思的对话上
2.3.2从用例开始
2.3.3提出有力的问题
2.3.4草图
2.3.5CRC卡
2.3.6延迟对模型中概念的命名
2.3.7行为驱动开发
2.3.8快速成型
2.3.9查看基于纸面的系统
2.4查看现有模型
2.4.1理解意图
2.4.2事件风暴
2.4.3影响地图
2.4.4理解业务模型
2.4.5刻意发现
2.4.6模型探讨漩涡
2.5要点
第3章专注于核心领域
3.1为何要分解一个问题域
3.2如何捕获问题的实质
3.2.1超越需求
3.2.2为达成什么是核心内容的共识而捕获领域愿景
3.3如何专注于核心问题
3.3.1提炼问题域
3.3.2核心领域
3.3.3将你的核心领域当作一款产品而非一个项目
3.3.4通用域
3.3.5支撑域
3.4子域如何决定解决方案的形成
3.5并非一个系统的所有部分都会经过良好设计
3.5.1专注于清晰边界而非完美模型
3.5.2一开始核心领域不必总是需要是完美的
3.5.3构建用于替代而非重用的子域
3.6如果没有核心领域怎么办
3.7要点
第4章模型驱动设计
4.1什么是领域模型
4.1.1领域与领域模型的对比
4.1.2分析模型
4.1.3代码模型
4.1.4代码模型是领域模型的主要表现
4.2模型驱动设计
4.2.1预先设计的挑战
4.2.2团队建模
4.3使用通用语言将分析和代码模型绑定在一起
4.3.1语言的生存周期将大于软件
4.3.2业务语言
4.3.3开发人员和业务之间的转译
4.4基于通用语言进行协作
4.4.1通过使用具体示例来定制出语言
4.4.2教导你的领域专家专注在问题上而不要跳到解决方案
4.4.3塑造语言的最佳实践
4.5如何创建有效的领域模型
4.5.1不要让实情妨碍一个好模型
4.5.2仅对相关内容建模
4.5.3领域模型都是暂时有用的
4.5.4要十分清楚专业术语
4.5.5限制你的抽象
4.6何时应用模型驱动设计
4.6.1如果它不值得花费精力，则不要尝试对其建模
4.6.2专注于核心领域
4.7要点
第5章领域模型实现模式
5.1领域层
5.2领域模型实现模式
5.2.1领域模型
5.2.2事务脚本
5.2.3表模块
5.2.4活动记录
5.2.5贫血领域模型
5.2.6贫血领域模型和函数编程
5.3要点
第6章使用有界上下文维护领域模型的完整性
6.1单个模型的挑战
6.1.1模型的复杂性可能会增加
6.1.2多个团队处理单个模型
6.1.3模型语言中的歧义
6.1.4领域概念的适用范围
6.1.5集成遗留代码或第三方代码
6.1.6领域模型并非企业模型
6.2使用有界上下文划分和破除大模型
6.2.1定义模型的边界
6.2.2子域和有界上下文之间的差异
6.3实现有界上下文
6.4要点
第7章上下文映射
7.1一个现实情况的映射
7.1.1技术的现实
7.1.2组织的现实
7.1.3映射一个相关现实情况
7.1.4用X标记核心领域的位置
7.2认识有界上下文之间的关系
7.2.1防止损坏层
7.2.2共享内核
7.2.3开放宿主服务
7.2.4分道扬镳
7.2.5合作关系
7.2.6一种上游／下游关系
7.3传递上下文映射
7.4上下文映射的战略重要性
7.4.1保持完整性
7.4.2解决计划的基础
7.4.3理解所有权和职责
7.4.4揭示业务工作流中的混乱区域
7.4.5识别非技术障碍
7.4.6鼓励良好的沟通
7.4.7帮助加入的新员工
7.5要点
第8章应用程序架构
8.1应用程序架构
8.1.1分离应用程序的问题
8.1.2从领域的复杂性中进行抽象
8.1.3分层架构
8.1.4依赖倒置
8.1.5领域层
8.1.6应用程序服务层
8.1.7基础架构层
8.1.8跨层通信
8.1.9隔离测试
8.1.10不要在有界上下文之间共享数据结构
8.1.11应用程序架构与用于有界上下文的架构的对比
8.2应用程序服务
8.2.1应用程序逻辑与领域逻辑的对比
8.2.2定义和公开能力
8.2.3业务用例协作
8.2.4应用程序服务表示的是用例，而不是创建、读取、更新和删除
8.2.5作为实现详情的领域层
8.2.6领域报告
8.2.7读取模型与事务模型的对比
8.3应用程序客户端
8.4要点
第9章团队开始应用领域驱动设计通常会遭到的问题
9.1过分强调战术模式的重要性
9.1.1将相同架构用于所有的有界上下文
9.1.2力求战术模式尽善尽美
9.1.3错误估计构造块对于DDD的价值
9.1.4专注于代码而非DDD的原则
9.2缺失了DDD的真实价值：协作、通信和上下文
9.2.1由于低估上下文的重要性而产生大泥球
9.2.2未能成功创建UL将造成歧义和误解
9.2.3由于缺乏协作将只能设计专注于技术的解决方案
9.3在不重要的部分花费太多时间
9.4简单问题复杂化
9.4.1将DDD原则应用到具有少量业务预期的琐碎领域
9.4.2别将CRUD作为反模式
9.4.3将领域模型模式用于每一个有界上下文
9.4.4问一问自己：额外的复杂性是否值得
9.5低估应用DDD的成本
9.5.1尝试在没有积极专注的团队的情况下取得成功
9.5.2项目背后没有领域专家时的协作尝试
9.5.3在非迭代式开发方法中进行学习
9.5.4将DDD应用到每一个问题
9.5.5为不必要的纯粹性而牺牲实用主义
9.5.6寻求验证会浪费精力
9.5.7永远力求代码之美
9.5.8DDD关乎的是提供价值
9.6要点
第10章应用DDD的原则、实践与模式
10.1推广使用DDD
10.1.1培训团队
10.1.2与业务人员进行交流
10.2应用DDD的原则
10.2.1理解愿景
10.2.2捕获所需的行为
10.2.3理解环境的现实情况
10.2.4对解决方案建模
10.3探究和实验
10.3.1质疑假设
10.3.2建模是一项持续性活动
10.3.3不存在错误的模型
10.3.4灵活的代码有助于探索发现
10.4让隐式内容变得显式
10.4.1处理歧义
10.4.2为事物命名
10.5问题解决人先行，技术专家后行
10.6如何才能知道我在正确地工作
10.6.1好用就足够了
10.6.2实践、实践、实践
10.7要点
第Ⅱ部分战略模式：在有界上下文之间通信
第11章有界上下文集成介绍
11.1如何集成有界上下文
11.1.1有界上下文是独立自主的
11.1.2在代码层面集成有界上下文的挑战
11.1.3使用物理边界来强制实现整洁的模型
11.1.4集成遗留系统
11.2集成分布式有界上下文
11.2.1集成用于分布式有界上下文的策略
11.2.2数据库集成
11.2.3平面文件集成
11.2.4RPC
11.2.5消息传递
11.2.6REST
11.3DDD使用分布式系统的挑战
11.4分布式事务将损害可扩展性和可靠性
11.4.1有界上下文不必彼此保持一致
11.4.2最终一致性
11.5事件驱动响应式DDD
11.5.1展示响应式解决方案的弹性和可扩展性
11.5.2异步消息传递的挑战和取舍
11.5.3RPC还有价值吗
11.6SOA和响应式DDD
11.6.1将你的有界上下文视作SOA服务
11.6.2进一步处理微服务架构
11.7要点
第12章通过消息传递集成
12.1消息传递基础
12.1.1消息总线
12.1.2可靠的消息传递
12.1.3存储转发
12.1.4命令和事件
12.1.5最终一致性
12.2使用NServiceBus构建一个电子商务应用程序
12.2.1系统设计
12.2.2从Web应用程序发送命令
12.2.3处理命令和发布事件
12.2.4使用消息传递网关让外部HTTP调用变得可靠
12.2.5实践中的最终一致性
12.2.6有界上下文会存储其本地所需的所有数据
12.2.7把所有内容都放在UI中
12.3维护消息传递应用程序
12.3.1消息版本管理
12.3.2监控和扩展
12.4将有界上下文与公共传输集成
12.4.1消息传递桥
12.4.2公共传输
12.5要点
第13章通过使用RPC和REST的HTTP来集成
13.1为何选用HTTP
13.1.1没有平台耦合
13.1.2每个人都理解HTTP
13.1.3大量的成熟工具和库
13.1.4内部测试你的API
13.2RPC
13.2.1在HTTP上实现RPC
13.2.2选择一种RPC风格
13.3REST
13.3.1深入浅出地解释REST
13.3.2用于有界上下文集成的REST
13.3.3维护REST应用程序
13.3.4将REST用于有界上下文集成的缺点
13.4要点
……
第Ⅲ部分战术模式：创建有效的领域模型
第Ⅳ部分有效应用程序的设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>领域驱动设计模式、原理与实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>手把手教你架构3D游戏引擎
第1章 游戏引擎简介 （1）
1.1 引擎的原理 （1）
1.2 开发3D引擎具备的条件 （4）
总结 （6）
第2章 数学知识 （8）
2.1 向量 （8）
2.1.1 向量加法及运用 （9）
2.1.2 向量减法及运用 （10）
2.1.3 向量点积及应用 （10）
2.1.4 向量的叉乘及应用 （12）
2.1.5 向量的长度及应用 （13）
2.1.6 向量的归一化及应用 （14）
2.2 矩阵运算 （14）
2.2.1 矩阵加法和减法 （14）
2.2.2 矩阵乘法及运用 （15）
2.3 3D坐标系 （19）
2.4 齐次坐标 （19）
2.5 四元数 （20）
总结 （20）
第3章 材质和光照 （22）
3.1 材质 （22）
3.2 光照 （23）
总结 （26）
第4章 固定流水线 （27）
4.1 局部坐标到世界坐标的变换 （27）
4.2 世界坐标到相机坐标的变换 （29）
4.3 物体剔除 （31）
4.4 相机坐标到透视坐标的变换 （32）
4.5 透视坐标到视口坐标的变换 （33）
4.6 光栅化 （33）
总结 （34）
第5章 游戏引擎架构 （35）
5.1 模块功能细分 （36）
5.2 GDI含义 （36）
5.3 整个引擎渲染思路 （37）
总结 （38）
第6章 3D引擎底层封装 （39）
6.1 自定义结构体 （39）
6.2 矩阵定义 （45）
6.3 通用类定义 （54）
6.4 向量运算 （59）
6.5 灯光 （72）
6.6 视景体 （77）
6.7 矩阵转换 （83）
6.8 图形渲染系统 （89）
6.9 材质 （100）
6.10 坐标系之间的转换 （109）
总结 （158）
第7章 3D引擎封装 （159）
7.1 相机的实现 （160）
7.2 监听事件 （166）
7.3 模型分析 （168）
7.4 模型加载 （169）
7.5 模型操作 （180）
7.6 场景管理 （191）
7.7 绘图接口 （206）
7.8 游戏窗口 （207）
总结 （217）
第8章 游戏设计实现 （218）
8.1 游戏架构 （218）
8.2 坦克设计 （219）
8.3 AI坦克 （230）
8.4 子弹设计 （235）
8.5 玩家控制 （240）
8.6 游戏类封装 （246）
8.7 游戏管理 （253）
8.8 主循环 （276）
总结 （278）
第9章 地图编辑器 （280）
9.1 编辑器实现 （281）
9.2 模型插件实现 （282）
总结 （284）
第10章 3D可编程流水线 （285）
10.1 GPU编程语言 （287）
10.2 灯光的Shader渲染 （287）
10.3 CelShading渲染 （291）
10.4 环境映射 （298）
10.5 Phong着色 （302）
10.6 Bloom渲染 （305）
10.7 PSSM阴影 （314）
总结 （323）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>手把手教你架构3D游戏引擎
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ODL技术内幕：架构设计与实现原理
前言
第一部分　基础环境篇
第1章　阅读源代码前的准备  2
1.1　ODL项目介绍  2
1.1.1　ODL框架之争  3
1.1.2　SAL的演进  3
1.1.3　ODL的子项目及分类  4
1.1.4　ODL项目的管理  6
1.2　搭建ODL编译构建环境  6
1.2.1　安装JDK  6
1.2.2　安装及配置Maven  8
1.3　阅读和调试ODL源代码  9
1.3.1　ODL项目源码下载  9
1.3.2　IntelliJ IDEA安装  10
1.3.3　IntelliJ IDEA调试ODL的项目源码  11
1.4　ODL设计目标  12
1.5　ODL总体架构  13
1.6　本章小结  15
第2章　ODL项目管理设计详解  16
2.1　问题的提出  16
2.2　解决思路  17
2.3　实现详解  20
2.3.1　基础parent设计  20
2.3.2　模块构建  23
2.3.3　feature组织  24
2.3.4　版本打包  25
2.4　项目模板  26
2.4.1　项目目录布局设计  26
2.4.2　ODL模板项目  27
2.5　本章小结  28
第二部分　核心原理篇
第3章　ODL基本对象的设计与实现  30
3.1　QName  30
3.1.1　QName定义  30
3.1.2　QName对象比较  36
3.1.3　QName对象创建  37
3.2　YangInstanceIdentifier  38
3.2.1　Path接口定义  38
3.2.2　YangInstanceIdentifier的类定义  39
3.2.3　YangInstanceIdentifier的比较42
3.2.4　InstanceIdentifier类  44
3.3　NomalizedNode  44
3.3.1　NormalizedNode类的定义  45
3.3.2　NormalizedNode实例的创建48
3.4　本章小结  49
第4章　数据树的设计与实现  50
4.1　基本概念  50
4.1.1　配置树与状态树  51
4.1.2　标识与定位  51
4.1.3　快照与MVCC  52
4.2　数据树的设计与实现  52
4.2.1　Tree结构的设计  52
4.2.2　DataTree相关接口定义  55
4.2.3　DataTree的创建  57
4.3　数据树的读写过程  59
4.3.1　快照实现原理  61
4.3.2　数据校验的实现  61
4.4　MVCC机制与实现  63
4.4.1　版本号变更规则  63
4.4.2　并发控制  65
4.5　本章小结  67
第5章　MD-SAL DataStore接口设计  68
5.1　基本概念  69
5.1.1　事务和事务链  70
5.1.2　数据分片  70
5.1.3　三阶段提交  71
5.2　DataStore SPI设计  72
5.2.1　DOMStore  73
5.2.2　DOMStoreThreePhase-CommitCohort  75
5.2.3　DOMStoreTreePublisher  76
5.3　DataStore DOM API设计  77
5.3.1　DOMDataBroker  77
5.3.2　DOMDataTreeSharding-Service  78
5.3.3　DOMDataTreeChange-Service  80
5.4　DataStore Binding API设计  82
5.4.1　Binding基本对象接口  82
5.4.2　DataBroker  84
5.4.3　DataTreeChangeService  87
5.5　本章小结  87
第6章　MD-SAL DataStore的实现原理  88
6.1　概述  89
6.1.1　背景知识  89
6.1.2　实现原理  91
6.2　Raft算法及其实现  92
6.2.1　Raft算法介绍  93
6.2.2　RaftActor设计与实现  98
6.3　DataStore后端实现详解  106
6.3.1　Shard的实现  106
6.3.2　ShardManager  110
6.3.3　ShardStrategy及实现  112
6.4　DataStore前端实现详解  113
6.4.1　DOMStore的实现  113
6.4.2　DOMDataBroker的实现  121
6.4.3　事务链实现  124
6.5　Binding DataBroker的实现  125
6.5.1　Adapter设计  125
6.5.2　BindingDOMDataBroker-Adapter的初始化  126
6.6　本章小结  130
第7章　MD-SAL RPC的设计与实现  131
7.1　一个实例  131
7.1.1　RPC的YANG模型定义  131
7.1.2　RPC的生成接口  133
7.1.3　RPC的实现与调用  135
7.2　RPC机制的总体设计  136
7.2.1　Binding接口设计  136
7.2.2　DOM接口设计  137
7.2.3　总体实现流程  139
7.3　RPC机制实现详解  141
7.3.1　DOMBroker实现详解  141
7.3.2　BindingBroker实现详解  144
7.4　Remote RPC实现详解  149
7.4.1　Gossip协议的实现  150
7.4.2　远程RPC注册及调用  152
7.4.3　Actor设计实现总结  154
7.5　本章小结  155
第8章　MD-SAL Notification的设计与实现  156
8.1　一个实例  156
8.1.1　YANG模型定义  156
8.1.2　生成的接口  157
8.1.3　消息发布  157
8.1.4　消息订阅  158
8.2　MD-SAL Notification接口设计  158
8.2.1　DOM接口  159
8.2.2　Binding接口  160
8.3　MD-SAL Notification实现剖析  161
8.3.1　DOM层实现详解  161
8.3.2　Binding适配实现  169
8.4　本章小结  171
第9章　MD-SAL Mount机制与NETCONF  172
9.1　Mount服务接口设计  172
9.1.1　DOM接口  173
9.1.2　Binding接口  174
9.2　Mount机制的实现  175
9.2.1　DOM接口实现  176
9.2.2　NETCONF南向插件的实现  178
9.3　本章小结  186
第10章　MD-SAL Cluster Service  187
10.1　EntityOwnershipService  187
10.1.1　基本概念  187
10.1.2　接口设计  188
10.1.3　实现说明  192
10.2　ClusterSingletonService  195
10.2.1　接口设计  195
10.2.2　实现说明  196
10.3　本章小结  198
第三部分　公共组件篇
第11章　AAA  200
11.1　Shiro框架介绍  201
11.1.1　Shiro是什么  201
11.1.2　Shiro的架构  202
11.1.3　Shiro核心处理流程  204
11.2　AAA实现原理  210
11.2.1　Shiro配置优化  210
11.2.2　Realm的8个实现  212
11.2.3　Filter的实现  214
11.2.4　加解密服务  216
11.2.5　数字证书管理  218
11.3　本章小结  219
第12章　RESTCONF  220
12.1　RFC 8040解读  220
12.1.1　操作  221
12.1.2　消息  222
12.1.3　资源  223
12.2　RESTCONF的实现  226
12.2.1　Jersey框架简介  226
12.2.2　RESTCONF资源接口定义  228
12.2.3　Wrapper设计模式  231
12.2.4　初始化过程  233
12.2.5　客户端访问  235
12.3　本章小结  236
第13章　Blueprint及其扩展  237
13.1　Blueprint  238
13.1.1　基础知识  238
13.1.2　运行原理  240
13.1.3　命名空间扩展  241
13.2　Blueprint的使用  244
13.3　本章小结  247
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ODL技术内幕：架构设计与实现原理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>事务处理
第一部分  事务处理基础
第一章  概述
第二章  计算机系统基本术语
第二部分  容错基础知识
第三章  容错
第三部分  面向事务的计算
第四章  事务模型
第五章  事务处理监控器：概述
第六章  事务处理监控器
第四部分  并发控制
第七章  隔离性的概念
第八章  锁的实现
第五部分  恢复
第九章  日志管理程序
第十章  事务管理器概念
第十一章  事务管理器结构
第十二章  高级事务管理器主题
第六部分  事务型文件系统：一个资源管理器实例
第十三章  文件和缓冲区管理
第十四章  面向元组的文件系统
第十五章  存取路径
第七部分  系统概览
第十六章  TP系统概览
第八部分  附录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>事务处理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构电子商务系统实例教程
第1章　　模式的介绍
1.l　　电子商务模式
l.2　　用户对在线（User-to-Online）的购买模式
1.3　　怎么使用模式
1.4　　电子商务网站的模式
1.5　　电子商务应用框架
1.6　　电子商务解决方案的综合观点
l.7　　对本书User－tO－Online（用户到在线）购物模式的结构 第2章　　选择应用程序拓扑结构
2.l　　应用程序拓扑结构1

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构电子商务系统实例教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>管理会计的理论思考与架构
第一章 管理会计理论体系和学科系统的基本思考
第二章 经济环境、经济理论与管理会计的发展
第三章 管理会计与相关课程之间关系的研究
第四章 价值链分析与管理会计的架构
第五章 纵向价值链分析
第六章 横向价值链分析
第七章 企业内部价值链分析
第八章 人力资本投资的决策
第九章 战略成本问题研究
第十章 全面预算的编制与管理
第十一章 管理者业绩评价的理论与方法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>管理会计的理论思考与架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Fusion Middleware 11g架构与管理
目    录

第Ⅰ部分  Oracle Fusion Middleware 11g架构与管理
第1章  Fusion Middleware入门	3
1.1  企业应用程序和中间件	3
1.2  Oracle Fusion Middleware产品	5
1.2.1  集成开发环境与框架	5
1.2.2  应用网格	7
1.2.3  身份管理	8
1.2.4  面向服务的架构	8
1.2.5  用户体验	9
1.2.6  内容管理、数据集成与
商业智能	9
1.3  小结	11
第2章  Oracle WebLogic Server	13
2.1  Oracle WebLogic Server简介	14
2.1.1  服务器、群集和域	14
2.1.2  安装和域组件	15
2.1.3  服务器启动和节点管理器	18
2.2  应用程序容器和部署	19
2.2.1  应用程序容器	20
2.2.2  应用程序部署	25
2.2.3  共享库	28
2.2.4  部署模式	28
2.2.5  部署计划	28
2.3  管理功能	30
2.3.1  域创建和模板	30
2.3.2  WebLogic Java Management
Extension MBean Server	31
2.3.3  WebLogic Server Scripting
Tool	33
2.4  身份验证和授权服务	34
2.4.1  嵌入式LDAP	35
2.4.2  安全提供者	35
2.4.3  用户、组、角色和授权
策略	36
2.5  JDBC服务	38
2.6  JMS服务	41
2.6.1  JMS服务器	41
2.6.2  JMS模块	43
2.7  WebLogic Server请求管理	44
2.7.1  连接和端口管理	44
2.7.2  Work Manager	45
2.8  本章用例	47
2.8.1  用例描述	47
2.8.2  理解应用程序及其环境	47
2.8.3  设计评估环境	49
2.9  小结	52
第3章  Fusion Middleware公共基础
设施	53
3.1  Fusion Middleware公共基础
设施简介	53
3.1.1  系统组件、实例和场	54
3.1.2  OPMN	55
3.1.3  安装和配置工件	56
3.2  Enterprise Manager Fusion
Middleware Control	60
3.3  元数据存储库服务	65
3.3.1  元数据管理	65
3.3.2  部署模型	66
3.3.3  运行时架构	67
3.4  Oracle Web Services Manager	68
3.4.1  策略管理	68
3.4.2  运行时架构	70
3.5  本章用例	72
3.5.1  用例描述	72
3.5.2  创建扩展的应用程序域	74
3.5.3  将应用程序作为Oracle HTTP
Server的前端	76
3.5.4  使用Oracle Web Services Manager
保护应用程序Web服务的
安全	78
3.6  小结	79
第4章  Oracle Fusion Middleware
平台安全服务和身份管理	81
4.1  Oracle平台安全服务简介	82
4.1.1  体系结构概述	82
4.1.2  身份、身份存储和
身份认证提供者	83
4.1.3  策略和策略存储	83
4.1.4  凭据和凭据存储	85
4.1.5  User & Role API	85
4.1.6  审计框架	86
4.1.7  Oracle Security Developer
Tools	87
4.1.8  OPSS策略模型和Oralce
Authorization Policy
Manager	88
4.2  Oracle身份管理简介	91
4.2.1  Oracle Internet Directory	92
4.2.2  Oracle Directory Server
Enterprise Edition	92
4.2.3  Oracle Virtual Directory	92
4.2.4  Oracle Access Manager	93
4.2.5  Oracle Identity Federation	95
4.2.6  Oracle Enterprise Single
Sign-On	95
4.2.7  Oracle Adaptive Access
Manager	96
4.2.8  Oracle Entitlements Server	97
4.2.9  Oracle Identity Manager	97
4.2.10  Oracle Identity Analytics	99
4.3  本章用例	99
4.3.1  配置身份存储	100
4.3.2  使用User & Role API	101
4.3.3  使用OAM配置单点登录	102
4.3.4  管理凭据存储	103
4.3.5  配置组件审计	103
4.4  小结	105
第5章  Oracle面向服务的
架构套件	107
5.1  Oracle SOA套件介绍	108
5.1.1  SOA平台方案	108
5.1.2  SOA套件组件	109
5.2  SOA基础设施	110
5.2.1  组合容器	111
5.2.2  服务组件架构入门	112
5.2.3  组合的生命周期	114
5.2.4  部署组合	115
5.2.5  组合服务和引用	118
5.2.6  组合管理	123
5.2.7  传感器和传感器动作	126
5.2.8  WebLogic脚本工具	127
5.3  Oracle业务活动监控	128
5.3.1  Oracle BAM组件和架构	128
5.3.2  Oracle BAM管理	131
5.4  用户消息服务	134
5.5  本章用例	136
5.5.1  用例描述	136
5.5.2  设置适当的用户、群组
及角色	138
5.5.3  设置SOA组合	139
5.5.4  配置Oracle BAM	141
5.6  小结	141
第6章  Oracle应用程序开发框架	143
6.1  ADF简介	143
6.2  架构	144
6.2.1  视图层	145
6.2.2  控制器层	146
6.2.3  ADF Binding层	146
6.2.4  ADF业务组件	146
6.2.5  ADF元数据和自定义	147
6.3  管理ADF应用程序	148
6.3.1  部署ADF应用程序	148
6.3.2  配置ADF应用程序	150
6.3.3  配置连接	150
6.3.4  配置ADF业务组件	151
6.3.5  配置MDS	152
6.3.6  配置MDS自定义	155
6.4  升级应用程序和最佳做法	155
6.5  本章用例	156
6.6  小结	158
第7章  Oracle WebCenter	159
7.1  Oracle WebCenter简介	159
7.1.1  安装WebCenter	160
7.1.2  WebCenter Composer	162
7.1.3  WebCenter Composer管理	163
7.1.4  WebCenter Enterprise 2.0
服务	167
7.2  管理Enterprise 2.0服务	168
7.2.1  连接	169
7.2.2  服务属性	172
7.2.3  服务任务流	172
7.2.4  Enterprise 2.0服务中的
测试—生产迁移	173
7.3  WebCenter门户技术	174
7.3.1  管理门户生产者连接	175
7.3.2  门户自定义设置和个性化
设置	178
7.3.3  门户应用程序的测试—生产
迁移	179
7.3.4  WebCenter门户元数据	179
7.3.5  高级功能	181
7.4  WebCenter空间	181
7.4.1  管理Oracle WebCenter
空间	182
7.4.2  Spaces应用程序管理	183
7.4.3  空间的测试—生产迁移	189
7.5  本章用例	192
7.6  小结	195
第Ⅱ部分  部署和管理Fusion Middleware中的企业
应用程序
第8章  部署Fusion Middleware
企业应用程序	199
8.1  定价应用程序概述	200
8.2  创建单个节点的拓扑结构	201
8.2.1  用于创建环境的整体
事件流	203
8.2.2  安装Fusion Middleware
软件	203
8.2.3  配置初始环境	208
8.2.4  部署定价应用程序工件	224
8.2.5  配置Oracle HTTP服务器	231
8.3  扩展群集用于可扩展性	232
8.3.1  扩展WebLogic Server定价
群集	232
8.3.2  配置客户端	236
8.4  小结	237
第9章  保护Fusion Middleware
企业应用程序	239
9.1  保护定价应用程序	240
9.2  保护部署时的整体事件流	241
9.3  保护物理主机	241
9.4  保护SSL通信	243
9.4.1  密钥库和钱包管理	245
9.4.2  在Web层配置SSL	245
9.4.3  在Oracle Internet Directory中为
Oracle平台安全性服务配置
SSL	248
9.4.4  其他SSL考虑	251
9.5  保护访问Oracle Internet Directory
的Oracle平台安全服务	251
9.6  配置单点登录	252
9.6.1  安装WebGate	252
9.6.2  创建并注册WebGate
实例	253
9.7  保护Web服务	254
9.8  配置审核	255
9.8.1  安装审核架构	255
9.8.2  配置审核存储库	256
9.8.3  配置审核策略	259
9.8.4  设置Business Intelligence
Publisher	259
9.9  小结	261
第10章  优化Fusion Middleware
企业应用程序	263
10.1  性能优化	264
10.2  余下部分的结构	264
10.3  优化Java Virtual Machine和
WebLogic Server	265
10.3.1  Java Virtual Machine	265
10.3.2  WebLogic Server	269
10.3.3  优化定价应用程序的Java
Virtual Machine和WebLogic
Server配置	271
10.4  优化Fusion Middleware共享
基础设施	277
10.4.1  Oracle Web Services
Manager	277
10.4.2  元数据存储库服务	279
10.5  优化分层的Fusion Middleware
组件	281
10.5.1  SOA Suite	281
10.5.2  应用程序开发框架	282
10.5.3  WebCenter	283
10.6  小结	286
第11章  监控和诊断Fusion Middleware
企业应用程序	287
11.1  理解Fusion Middleware
日志	288
11.1.1  WebLogic Server日志
基础设施	288
11.1.2  Oracle Diagnostics
Logging	293
11.2  使用WebLogic Diagnostics
Framework	297
11.2.1  诊断图像	298
11.2.2  诊断模块	300
11.2.3  Administration Console
监控	305
11.3  配置和使用节点管理器	306
11.4  小结	309
第12章  虚拟化Fusion Middleware
企业应用程序	311
12.1  Oracle Virtual Machine	312
12.2  JRockit和WebLogic Server
Virtual Edition	315
12.2.1  JRockit Virtual Edition	315
12.2.2  WebLogic Server Virtual
Edition	316
12.2.3  JRockit VE上的定价
应用程序	318
12.3  Oracle Virtual Assembly
Builder	318
12.4  Oracle Exalogic	320
12.4.1  Exalogic硬件	320
12.4.2  Exalogic软件	321
12.4.3  Exalogic虚拟平台	322
12.5  小结	323

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Fusion Middleware 11g架构与管理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>vmware vsphere 6.0虚拟化架构实战指南
第1章　软件定义数据中心　1
1．1　传统数据中心介绍　1
1．1．1　传统数据中心的概念　1
1．1．2　传统数据中心面临的问题　2
1．2　软件定义数据中心介绍　3
1．2．1　软件定义数据中心的概念　3
1．2．2　软件定义数据中心对基础设施的影响　3
1．2．3　硬件和软件供应商之间的竞争　4
1．2．4　软件定义数据中心与云计算　4
1．2．5　转型中的传统数据中心架构　5
1．3　VMware软件定义数据中心介绍　6
1．3．1　VMware vSphere介绍　6
1．3．2　VMware SAN介绍　8
1．3．3　VMware NSX介绍　10
1．3．4　VMware vCloud介绍　11
1．4　本章小结　12
第2章　安装配置VMware ESXi 6．0　13
2．1　VMware vSphere 6．0虚拟化介绍　13
2．1．1　什么是VMware vSphere　13
2．1．2　VMware vSphere的用途　14
2．1．3　VMware vSphere的优势　14
2．1．4　VMware vSphere 6．0新增功能　14
2．2　本书实战环境搭建　18
2．2．1　实战环境配置　18
2．2．2　实战环境拓扑　19
2．2．3　实战环境IP分配　19
2．2．4　非物理实战环境硬件配置　20
2．3　安装VMware ESXi 6．0　20
2．3．1　安装ESXi 6．0硬件要求　20
2．3．2　安装介质的准备　21
2．3．3　制作U盘安装介质　21
2．3．4　全新安装ESXi 6．0　23
2．4　全新安装后的必要配置　26
2．4．1　配置ESXi主机管理地址　27
2．4．2　使用vSphere Client管理ESXi主机　30
2．4．3　开启SSH命令行管理　34
2．4．4　ESXi 6．0主机其他常用设置　38
2．5　ESXi 5．5主机升级至ESXi 6．0主机　43
2．5．1　升级ESXi 5．5主机前的准备工作　43
2．5．2　使用重新安装升级ESXi 5．5主机　44
2．5．3　使用vSphere Update Manager升级ESXi 5．5主机　49
2．6　本章小结　61
第3章　安装配置vCenter Server 6．0　62
3．1　vCenter Server介绍　62
3．1．1　什么是vCenter Server　62
3．1．2　什么是SSO　62
3．1．3　什么是PSC　63
3．1．4　SSO与PSC之间的关系　63
3．2　vCenter Server版本及运行环境的选择　63
3．2．1　vCenter Server版本的选择　63
3．2．2　vCenter Server运行环境的选择　64
3．2．3　vCenter Server安装要求　64
3．3　选择vCenter Server数据库　65
3．3．1　vCenter Server支持的数据库介绍　65
3．3．2　嵌入式数据库和独立数据库的选择　65
3．3．3　SQL Server数据库和Oracle数据库的选择　65
3．4　使用SQL Server作为VC 6．0数据库　66
3．4．1　安装SQL Server 2012　66
3．4．2　创建VC 6．0所需数据库　76
3．5　使用Oracle作为VCSA 6．0数据库　77
3．5．1　安装Oracle 11g　78
3．5．2　创建VCSA 6．0所需数据库　82
3．5．3　配置Oracle监听程序　89
3．6　安装配置VC 6．0　92
3．6．1　配置ODBC数据源　92
3．6．2　安装配置VC 6．0　96
3．6．3　访问VC 6．0　102
3．7　安装配置VCSA 6．0　105
3．7．1　安装配置VCSA 6．0　105
3．7．2　访问VCSA 6．0　115
3．8　升级vCenter Server 5．5至vCenter Server 6．0　118
3．8．1　升级VC 5．5至VC 6．0　118
3．8．2　升级VCSA 5．5至VCSA 6．0　125
3．9　vCenter Server 6．0基本配置　133
3．9．1　添加ESXi主机到vCenter Server　134
3．9．2　添加活动目录用户到vCenter Server　139
3．9．3　添加许可授权　144
3．10　本章小结　151
第4章　配置VMware vSphere 6．0网络　153
4．1　VMware vSphere 6．0网络介绍　153
4．1．1　ESXi主机通信原理介绍　153
4．1．2　ESXi主机网络组件介绍　154
4．1．3　ESXi主机网络VLAN实现方式　157
4．1．4　ESXi主机网络NIC Teaming　158
4．2　配置使用标准交换机　162
4．2．1　创建基于虚拟机流量标准交换机　162
4．2．2　创建基于VMkernel流量标准交换机　167
4．2．3　多VLAN环境交换机的配置　171
4．2．4　虚拟交换机NIC Teaming配置　175
4．3　配置使用分布式交换机　179
4．3．1　创建分布式交换机　179
4．3．2　分布式交换机多VLAN配置　182
4．3．3　分布式交换机添加ESXi主机　185
4．3．4　分布式交换机LACP配置　193
4．4　本章小结　202
第5章　配置VMware vSphere 6．0存储　204
5．1　VMware vSphere 6．0存储介绍　204
5．1．1　vSphere 6．0支持的存储类型　204
5．1．2　FC SAN存储介绍　205
5．1．3　FCoE介绍　206
5．1．4　iSCSI存储介绍　207
5．1．5　NFS介绍　207
5．2　配置使用FC SAN存储　208
5．2．1　Open-E存储服务器安装　208
5．2．2　Open-E FC SAN存储配置　218
5．2．3　FC SAN存储交换机配置　228
5．2．4　配置ESXI主机使用FC SAN存储　229
5．2．5　配置ESXI主机使用FC SAN BOOT　234
5．3　配置使用iSCSI存储　241
5．3．1　Open-E iSCSI存储配置　241
5．3．2　配置ESXi 6．0主机使用iSCSI存储　245
5．3．3　扩展iSCSI存储容量　251
5．3．4　绑定iSCSI存储网络　253
5．4　配置使用NFS存储　258
5．4．1　Open-E NFS存储配置　258
5．4．2　配置ESXi 6．0主机使用NFS存储　264
5．5　配置使用Virtual SAN存储　267
5．5．1　软件定义存储介绍　267
5．5．2　什么是Virtual SAN　268
5．5．3　Virtual SAN常用术语　269
5．5．4　Virtual SAN存储策略剖析　271
5．5．5　Virtual SAN部署要求　274
5．5．6　Virtual SAN基本配置-启用VSAN　274
5．5．7　Virtual SAN常用存储策略配置　288
5．5．8　Virtual SAN日常操作　301
5．6　本章小结　310
第6章　创建使用虚拟机　311
6．1　虚拟机介绍　311
6．1．1　什么是虚拟机　311
6．1．2　组成虚拟机文件　311
6．1．3　虚拟机硬件介绍　312
6．2　创建Windows虚拟机　314
6．2．1　新建Windows虚拟机　314
6．2．2　为Windows虚拟机安装VMware Tools工具　321
6．3　创建Linux虚拟机　323
6．3．1　新建Linux虚拟机　324
6．3．2　为Linux虚拟机安装VMware Tools工具　331
6．4　创建使用Windows虚拟机模板　335
6．4．1　创建Windows虚拟机模板的准备工作　335
6．4．2　创建Windows虚拟机模板　335
6．4．3　使用Windows虚拟机模板创建虚拟机　339
6．5　创建使用Linux虚拟机模板　349
6．5．1　创建Linux虚拟机模板的准备工作　349
6．5．2　创建Linux虚拟机模板　349
6．5．3　使用Linux虚拟机模板创建虚拟机　352
6．6　创建使用虚拟机快照　356
6．6．1　虚拟机快照介绍　356
6．6．2　创建虚拟机快照　357
6．6．3　使用虚拟机快照　359
6．7　创建使用虚拟机内容库　361
6．7．1　虚拟机内容库介绍　361
6．7．2　创建虚拟机内容库　362
6．7．3　添加虚拟机模板到内容库　365
6．7．4　使用内容库部署虚拟机　367
6．8　虚拟机常用操作　368
6．8．1　调整虚拟机硬件　368
6．8．2　向虚拟机添加原始LUN　371
6．8．3　从vCenter Server清单中取消注册虚拟机　375
6．8．4　从vCenter Server清单中注册虚拟机　376
6．8．5　从vCenter Server清单中删除虚拟机　380
6．9　本章小结　382
第7章　配置使用高级特性vMotion　383
7．1　vMotion介绍　383
7．1．1　vMotion迁移的原理　383
7．1．2　vMotion迁移对虚拟机的要求　384
7．1．3　vMotion迁移对主机的要求　384
7．1．4　vMotion迁移对CPU的限制　384
7．2　使用vMotion迁移虚拟机　385
7．2．1　配置vMotion通信端口　385
7．2．2　使用vMotion迁移虚拟机　386
7．3　使用vMotion迁移虚拟机存储　390
7．3．1　Storage vMotion介绍　390
7．3．2　使用vMotion迁移虚拟机存储　390
7．4　本章小结　392
第8章　配置使用高级特性DRS　393
8．1　DRS介绍　393
8．1．1　DRS群集主要功能介绍　393
8．1．2　EVC介绍　394
8．1．3　DRS自动化级别介绍　398
8．1．4　DRS迁移阈值介绍　398
8．1．5　DRS规则介绍　399
8．2　配置使用DRS　400
8．2．1　启用DRS　400
8．2．2　调整DRS自动化级别　401
8．2．3　应用DRS负载均衡　403
8．2．4　配置EVC特性　405
8．2．5　配置使用虚拟机规则　408
8．2．6　配置使用主机规则　412
8．3　本章小结　415
第9章　配置使用高级特性HA　417
9．1　HA介绍　417
9．1．1　vSphere提供的保护级别　417
9．1．2　HA运行原理　418
9．1．3　理解不同层面的HA　420
9．1．4　HA接入控制策略介绍　420
9．1．5　Client客户端与Web Client客户端HA接入控制策略的差异　423
9．1．6　如何选择HA接入控制策略　424
9．2　配置vSphere HA　425
9．2．1　配置HA基础条件　425
9．2．2　启用vSphere HA　426
9．2．3　按静态主机数量定义故障切换容量策略配置　430
9．2．4　通过预留一定百分比的群集资源来定义故障切换容量配置　438
9．2．5　使用专用故障切换主机配置　441
9．3　本章小结　445
第10章　配置使用高级特性FT　446
10．1　虚拟机FT介绍　446
10．1．1　5．X版本FT使用的vLockstep技术　446
10．1．2　6．X版本FT使用的Fast Checkpointing技术　447
10．1．3　FT工作方式　447
10．1．4　新版本FT的特性　448
10．1．5　FT不支持的vSphere功能　448
10．2　配置使用虚拟机FT　448
10．2．1　配置虚拟机FT的基础条件　449
10．2．2　配置使用虚拟机FT　449
10．3　本章小结　456
第11章　VMware vSphere性能监控　457
11．1　配置使用警报　457
11．1．1　vSphere系统内置警报　457
11．1．2　创建自定义警报　460
11．2　使用性能图表　466
11．2．1　查看数据中心性能图表　466
11．2．2　查看群集性能图表　468
11．2．3　查看ESXi主机性能图表　470
11．2．4　查看虚拟机性能图表　473
11．3　配置使用Operation Management　476
11．3．1　Operation Management介绍　477
11．3．2　部署Operation Management　477
11．3．3　配置Operation Management　483
11．3．4　使用Operation Management　494
11．4　本章小结　499
第12章　备份恢复虚拟机　500
12．1　vSphere Data Protection介绍　500
12．1．1　vSphere Data Protection介绍　500
12．1．2　映像级备份和恢复介绍　501
12．2　部署vSphere Data Protection　501
12．2．1　部署vSphere Data Protection　502
12．2．2　配置vSphere Data Protection　507
12．3　使用vSphere Data Protection备份恢复虚拟机　516
12．3．1　使用vSphere Data Protection备份虚拟机　516
12．3．2　使用vSphere Data Protection恢复虚拟机　521
12．4　本章小结　523
附录A　VMware认证体系介绍　524
A．1　VMware认证分类及体系结构　524
A．2　VMware认证流程　524
附录B　虚拟化知识学习路线图　526
B．1　评估基础知识　526
B．2　掌握系统的安装调试　526
B．3　掌握网络交换的知识　527
B．4　掌握一种数据库的安装调试　527
B．5　掌握一种虚拟化平台　527
B．6　多进行实践操作　527
B．7　查阅官方文档　527
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>vmware vsphere 6.0虚拟化架构实战指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件系统架构与开发环境
《软件系统架构与开发环境》
前言
致谢
第1章 软件系统架构与软件工程	1
1.1 计算机及其软件系统	1
1.1.1 系统及其基本特性	1
1.1.2 分布式计算机系统	2
1.1.3 rm-odp及其视点模型	4
1.1.4 软件系统及其质量属性	5
1.2 软件系统的流程要素	7
1.2.1 系统工程概要	7
1.2.2 软件工程概要	9
1.2.3 cmm及其关键实践	13
1.2.4 软件配置管理工具	18
1.3 软件系统的架构要素	22
1.3.1 软件设计的模块化、形式化与层次化	22
1.3.2 软件架构与软件框架	24
1.3.3 面向对象软件开发vs.软件架构	29
1.3.4 基于组件的软件开发vs.软件架构	32
1.3.5 面向切面编程vs.软件架构	34
1.4 uml语言与uml工具	36
1.4.1 uml vs.软件架构视图模型	36
1.4.2 基于uml的软件架构设计	37
1.4.3 uml与4+1视图	41
1.4.4 uml工具与软件架构设计	48
1.5 软件设计风格与软件设计模式	49
1.5.1 概述	49
1.5.2 软件设计风格	49
1.5.3 面向对象的软件设计模式	53
第2章 软件开发平台与软件系统架构	58
2.1 软件系统开发语言	58
2.2 c++与java的对比综述	60
2.3 c++与java的开发工具与开发过程	67
2.3.1 c++的基本开发工具与开发过程	67
2.3.2 visual c++的开发平台与开发过程	70
2.3.3 java的基本开发工具与开发过程	72
2.3.4 java的三个开发平台	74
2.3.5 java集成开发工具	92
2.4 java se的架构相关技术	92
2.4.1 java的反射技术	93
2.4.2 java的对象序列化技术	98
2.4.3 java的异常处理技术	101
2.4.4 java线程的并发控制	104
2.4.5 java的集合类	105
2.5 visual c++的架构相关技术	107
2.5.1 windows api的窗口技术与消息处理技术	107
2.5.2 mfc的架构相关技术	112
2.5.3 visual c++的动态链接库	132
2.6 visual studio与.net框架	136
2.6.1 clr及其相关概念	136
2.6.2 关于c#	137
2.6.3 桌面应用框架	137
2.6.4 扩展的b-s架构	141
2.7 android平台	149
2.7.1 android操作系统	149
2.7.2 dalvik虚拟机	150
2.7.3 android应用软件框架及其activity构件	150
2.7.4 android应用开发例子	152
第3章 c-s架构的常用协议	154
3.1 概述	154
3.2 http及其扩展协议	155
3.2.1 http协议概要	155
3.2.2 url与uri	156
3.2.3 http协议的pdu	159
3.2.4 b-s架构与http协议封装	162
3.2.5 http的扩展协议webdav	164
3.3 jdbc/odbc协议	167
3.3.1 数据库应用系统及其c-s架构	167
3.3.2 数据库系统	168
3.3.3 jdbc客户端架构	171
3.3.4 odbc客户端架构	174
3.4 ldap协议与jndi	176
3.4.1 名字服务与目录服务	176
3.4.2 ldap协议及其模型	178
3.4.3 jndi	185
第4章 中立化信息交换语言	191
4.1 概述	191
4.2 asn.1	192
4.2.1 asn.1概述	192
4.2.2 asn.1的抽象语法	193
4.2.3 ber编码	199
4.2.4 der编码	202
4.3 html	203
4.3.1 html概述	203
4.3.2 html的高层元素	204
4.3.3 html的中层元素	205
4.3.4 html的基层元素	209
4.3.5 html的层叠样式表	214
4.3.6 html中的javascript程序	216
4.4 xml	218
4.4.1 xml概述	218
4.4.2 xml元素及其属性	220
4.4.3 基于dtd的元素与属性声明	221
4.4.4 基于dtd的xml文档的逻辑和物理结构	223
4.4.5 xml schema	228
4.4.6 xml解析器	238
第5章 中间件与分布式软件架构	245
5.1 概述	245
5.2 传统中间件	245
5.3 java ee中间件	253
5.3.1 java的rmi技术	253
5.3.2 ejb技术	257
5.3.3 jms技术	265
5.3.4 jdbc数据源与jta/jts	271
5.4 corba与web services	275
5.4.1 跨平台中间件概述	276
5.4.2 corba中间件	277
5.4.3 web services中间件	284
附录 演示程序清单	299
参考文献	302
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件系统架构与开发环境
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>淘宝天猫网店设计从入门到精通 店铺装修+广告海报+修图修片+架构布局+配色应用+设计模版
导读
01 本书怎么读？
02 五个步骤搞定网店装修
第一步：*替换源文件中的图片和文本信息
第二步：*在Photoshop中制作切片并优化处理
第三步：*将切片处理后的图片上传到网络空间
第四步：在Dreamweaver中添加链接并制作代码
第五步：*复制代码到店铺装修指定区域
========================================================
第一篇 网店装修前的准备工作
第1章 对店铺装修进行初步了解
1.1 什么是网店装修
1.2 网店装修的意义
1.2.1 获取店铺信息
1.2.2 直观掌握更多的商品信息
1.3 店铺装修与转化率的关系
1.4 常见电商平台及其配色
1.4.1 淘宝与天猫
1.4.2 唯品会
1.4.3 京东
1.4.4 当当网
1.5 如何确定装修的风格
1.5.1 网店整体色调的选择
1.5.2 详情页面橱窗照的设计
1.5.3 网店中各个模块的合理布局
1.6 网店装修中的误区
========================================================
第2章* 做好准备让装修有条不紊-前期工作
2.1 拍摄宝贝图片
2.1.1 摄影器材的选择
2.1.2 布置拍摄场地
2.1.3 多角度、重细节地拍摄宝贝
2.1.4 拍摄小窍门
2.1.5 后期修片原则
2.2 收集装修所需的设计素材
2.3 获得图片的存储空间
2.3.1 常用的免费空间相册
2.3.2 其他获取图片空间的方法
2.4 了解装修中遇到的文件格式
========================================================
第3章* 视觉营销三大要素——色彩、文字、版式
3.1 了解色彩的基本要点
3.1.1 色彩的种类
3.1.2 色彩三要素
3.1.3 色调的倾向
3.2 记忆中的色彩
3.2.1 暖色系色彩的性格和表现
3.2.2 冷色系色彩的性格和表现
3.3 常见配色方案
3.3.1 对比配色在网店装修中的应用
3.3.2 调和配色在网店装修中的应用
3.4 文字的重要表现
3.4.1 常见的字体风格
3.4.2 了解文字的编排准则
3.4.3 运用合理分割方式来安排文字
3.4.4 字体的创意设计
3.5 版式布局对网页界面的影响
3.5.1 版式设计的形式法则
3.5.2 版式布局中图片的处理
3.5.3 了解版式布局中的视觉流程
3.5.4 版式布局中的对齐方式
========================================================
第4章* 店铺装修的基础工具——美图秀秀和
4.1* 最易上手的商品图片修饰软件
——美图秀秀
========================================================
第5章 专业的网店装修利器——P
第二篇 网店装修六大核心区域的设计
第6章 打出过目不忘的招牌——店招
第7章 帮助顾客精确定位——导航条
第8章 第一印象很重要-首页欢迎模块
第9章* 巧用心思赢得回头客-店铺收藏区
第10章 给顾客解惑答疑——客服区
第11章* 体现宝贝的专业品质
========================================================
第三篇 统一整店风格强化客户对店铺及品牌的意识
第12章 服装类店铺装修大集合
第13章 鞋包配饰类店铺装修大集合
第14章 珠宝手表类店铺装修大集合
第15章 手机数码类店铺装修大集合
第16章 彩妆美肤类店铺装修大集合
第17章 家居家纺类店铺装修大集合
第18章 小商品类店铺装修大集合
========================================================
附录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>淘宝天猫网店设计从入门到精通 店铺装修+广告海报+修图修片+架构布局+配色应用+设计模版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>内容中心网络体系架构
目录
第1章CCN体系架构
1.1当前Internet的问题
1.2未来网络体系架构
1.3CCN概述
1.3.1CCN体系结构
1.3.2CCN工作机制
参考文献
第2章内容中心网络CCNx实现
2.1CCNx框架
2.1.1CCNx代码库
2.1.2CCN内容命名
2.2CCNx组件
2.2.1ccnd
2.2.2ccnr
2.2.3ccndc
2.3CCNx网络配置
2.3.1CCNx路由器启动
2.3.2CCNx路由器链路
2.3.3CCNx网络示例
2.4CCNx网包处理
2.4.1兴趣包定义
2.4.2兴趣包处理
2.4.3数据包处理
2.5CCN代码项目
2.6小结
参考文献
第3章CCNx安装指导
3.1CCNx网络结构
3.2CCNx代码安装
3.2.1获取代码
3.2.2安装编译
3.2.3CCNx工具
3.3代码开发
3.3.1起步
3.3.2可能的问题
3.4CCNx库
3.4.1共同组件
3.4.2Java库
3.4.3C库
参考文献
第4章内容中心网络流媒体
4.1视频分发需求及Internet架构现状
4.1.1互联网视频内容
4.1.2Internet架构问题
4.2HLS标准概述
4.2.1HLS客户端请求流程
4.2.2M3U8格式
4.2.3TS文件格式
4.3CCNHLS系统
4.3.1内容源转码及切分处理
4.3.2内容源转码
4.3.3内容切分
4.3.4M3U8文件的生成
4.3.5自动化脚本
4.4CCN2HTTP中间服务器
4.5小结
参考文献
第5章CCN隐私保护
5.1隐私的定义及概念
5.1.1隐私与机密、匿名的关系
5.1.2隐私与信任的关系
5.1.3隐私的基本问题和具体问题
5.1.4隐私问题限定
5.2CCN中的用户隐私
5.2.1用户的通信隐私
5.2.2用户的内容发布隐私
5.2.3用户的内容检索隐私
5.3CCN与IP体系结构的隐私问题比较
5.4影响用户隐私的CCN机制分析
5.4.1命名机制对隐私的影响
5.4.2数据签名机制对隐私的影响
5.4.3缓存机制对隐私的影响
5.4.4消费者驱动对隐私的影响
5.5隐私的攻击和保护代价分析
5.6基于OT的用户检索隐私保护方案
5.6.1协议设计目的
5.6.2协议设计假定和原则
5.6.3CCN？CPIR用户隐私保护机制
5.7结论
参考文献
第6章CCN与CDN网络的比较与融合
6.1CDN网络概念
6.1.1AkamaiCDN网络
6.1.2AkamaiHTTPLiveStreaming方案
6.1.3CCN与CDN网络不同之处
6.2CDN网络配置
6.2.1CDN网络结构
6.2.2CDN网络核心组件
6.2.3CDN网络安装及配置
6.2.4OpenCDN部署
6.3实验研究与设计
6.3.1CDN和CCN设计原则对比
6.3.2CDN网络实验环境
6.3.3CDN实验平台设计
6.3.4CCN实验平台设计
6.3.5实验设计
6.4实验结果与分析
6.4.1集群部署开销对比
6.4.2性能评估
6.4.3实验总结
6.5CCN与CDN融合
6.5.1CCNHLS系统架构
6.5.2CCNasCDN关键问题
6.6小结
参考文献
第7章CCN底层实现
7.1背景技术
7.2实验原理
7.2.1CCN的底层实现的架构
7.2.2CCN底层实现关键技术
7.2.3CCN底层实现实验步骤
7.3实现优势
7.4实验验证
7.4.1实验设置
7.4.2性能评估
7.4.3功能展示
7.5推广讨论
参考文献
第8章CCN总结展望
8.1未来工作
8.2未来展望
参考文献
附录A云计算平台搭建
A.1引言
A.2云技术综述
A.3VMware/CloudStack云平台的架构
A.4VMware/CloudStack云平台构建
参考文献
附录BCDN/CCN搭建
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>内容中心网络体系架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>UI设计必修课(交互+架构+视觉UE设计教程)
目    录
Chapter 01 网络交互与用户体验
1.1 关于用户体验 2
1.1.1 什么是用户体验 2
1.1.2 用户体验设计的历史与现状 2
1.1.3 6种基础体验 3
1.1.4 用户体验相关术语 5
1.2 用户体验设计范畴及其特点 6
1.2.1 用户体验设计范畴 6
1.2.2 用户体验设计的特点 7
1.2.3 用户体验设计的5个着手点 9
1.3 网站与用户体验 10
1.3.1 用户体验所包含的内容 10
1.3.2 用户体验对于网站的重要性 13
1.3.3 网站设计如何寻求突破 13
1.3.4 提升网站用户体验 14
1.4 交互设计的内容和习惯 16
1.4.1 什么是交互设计 16
1.4.2 需要考虑的内容 16
1.4.3 需要遵循的习惯 17
1.4.4 用户体验与交互设计 18
1.5 用户体验设计的原则 18
1.5.1 快速引导用户找到需要的内容 19
1.5.2 设置期望并提供反馈 21
1.5.3 基于人类工程学设计 21
1.5.4 与标准保持一致 22
1.5.5 提供纠错支持 22
1.5.6 靠辨识而非记忆 23
1.5.7 考虑到不同水平的用户 23
1.5.8 提供上下文帮助和文档 24
1.6 用户体验要素的应用 24
1.6.1 由现状决定的设计 24
1.6.2 由模仿决定的设计 25
1.6.3 由领导决定的设计 25
1.7 拓展阅读——用户体验设计师 25
1.8 本章小结 26
Chapter 02 认识用户
2.1 用户的感官特征 28
2.1.1 视觉 28
2.1.2 听觉 29
2.1.3 触觉 31
2.2 用户认知心理 31
2.2.1 设计心理学 31
2.2.2 设计心理学的设计原则 35
2.3 用户的心理需求 38
2.3.1 人的需求层次理论 38
2.3.2 用户体验的需求层次 39
2.3.3 用户体验的生命周期模型 42
2.4 以用户为中心设计 43
2.4.1 了解用户需要什么 43
2.4.2 遵循用户的习惯 44
2.4.3 颠覆用户的习惯 45
2.5 网站的目标与用户需求 46
2.6 用户激励机制 49
2.6.1 用户激励的方式 49
2.6.2 等级与积分激励方式的表现 49
2.6.3 网站常用的具体激励方法 51
2.7 拓展阅读——用户行为分析 54
2.8 本章小结 55

Chapter 03 用户体验要素
3.1 用户体验的分类 58
3.1.1 信息架构 58
3.1.2 交互设计 63
3.1.3 视觉形象设计 65
3.2 用户体验的要素模型 66
3.2.1 5个层面 66
3.2.2 要素模型 70
3.3 战略层详解 72
3.3.1 确定产品定位 72
3.3.2 了解用户需求 74
3.4 范围层详解 76
3.4.1 从哪里获得需求 76
3.4.2 对需求进行分析筛选 77
3.4.3 确定需求优先级 78
3.5 结构层详解 79
3.5.1 交互设计 80
3.5.2 信息架构 81
3.6 框架层详解 82
3.6.1 界面设计 82
3.6.2 导航设计 83
3.6.3 信息设计 87
3.6.4 线框图 88
3.7 表现层详解 90
3.7.1 如何评估网站的视觉设计 90
3.7.2 对比 91
3.7.3 一致性 92
3.7.4 配色方案 93
3.7.5 字体选择 94
3.8 拓展阅读——用户体验的一般设计流程 95
3.9 本章小结 97
Chapter 04 关注用户体验的交互设计
4.1 可用性设计 100
4.1.1 什么是可用性 100
4.1.2 可用性的表现 100
4.2 可用性设计原则 101
4.2.1 简洁性 101
4.2.2 易于学习 106
4.2.3 减少用户记忆 108
4.2.4 一致性 111
4.2.5 提供反馈 112
4.2.6 错误提示及避免错误的发生 114
4.2.7 高效率 115
4.3 心流体验 115
4.3.1 什么是心流体验 116
4.3.2 两种不同的心流体验类型 116
4.3.3 心流体验设计的要点 118
4.3.4 用户体验的经验设计 122
4.4 沉浸感设计 126
4.4.1 什么是沉浸感 126
4.4.2 沉浸感设计原则 126
4.4.3 沉浸感在游戏网站中的应用 129
4.5 情感化设计 131
4.5.1 什么是情感化设计 131
4.5.2 互联网产品设计的3层次 131
4.5.3 互联网产品的情感化设计 133
4.6 美感设计 135
4.6.1 什么是美感设计 135
4.6.2 交互设计中的美感体验 136
4.7 用户体验差异设计 137
4.7.1 可访问性设计 137
4.7.2 文化差异设计 139
4.7.3 经验水平差异设计 144
4.8 用户体验与前端设计 145
4.8.1 认识前端设计 146
4.8.2 前端设计优化与用户体验 150
4.9 拓展阅读——网站信息架构 151
4.10 本章小结 152
Chapter 05 Web产品用户体验
5.1 Web产品解构 154
5.1.1 网站解构 154
5.1.2 网站页面的构成元素 154
5.1.3 网站页面的视觉层次 157
5.1.4 基于用户体验的网站设计原则 161
5.2 网站界面设计的基本原则 165
5.2.1 对比突出 165
5.2.2 条理清晰 167
5.2.3 整齐平衡 168
5.2.4 简洁一致 169
5.3 Web用户体验设计 170
5.3.1 清晰的网站结构 170
5.3.2 合理的页面功能布局 173
5.3.3 优化网站内容 180
5.4 网站配色 182
5.4.1 色彩属性 183
5.4.2 网页配色的方法 184
5.4.3 网页文本配色 188
5.4.4 网页元素的色彩搭配 190
5.4.5 色彩情感在网页设计中的应用 192
5.5 网站用户体验设计细节 197
5.5.1 网站图标设计 197
5.5.2 网站按钮设计 200
5.5.3 网站Logo设计 206
5.5.4 网站导航设计 211
5.6 拓展阅读——创建网站
设计的标准 219
5.7 本章小结 220
Chapter 06 移动端用户体验
6.1 了解移动端用户体验 222
6.1.2 移动端与PC端的区别 222
6.1.3 移动设备用户体验发展趋势 224
6.1.4 移动设备的交互设计 225
6.1.5 移动端应用的用户体验设计 226
6.2 移动端设计流程及视觉设计 230
6.2.1 移动端设计流程 230
6.2.2 视觉设计 231
6.2.3 如何提升移动端应用的用户体验 232
6.3 移动端界面设计内容 234
6.3.1 视听元素设计 235
6.3.2 版式设计 244
6.4 移动端界面色彩搭配 247
6.4.1 色彩在移动端界面设计中的作用 247
6.4.2 移动端界面配色原则 249
6.5 移动端界面设计原则 251
6.5.1 实用性 251
6.5.2 统一的色彩与风格 252
6.5.3 合理的配色 252
6.5.4 规范的操作流程 253
6.5.5 视觉元素规范 253
6.6 拓展阅读——常见移动设备
尺寸标准 254
6.7 本章小结 256
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>UI设计必修课(交互+架构+视觉UE设计教程)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式的艺术
第1部分基 础 知 识
第1章从招式与内功谈起——设计模式概述
1.1设计模式从何而来
1.2设计模式是什么
1.3设计模式有什么用
1.4个人观点
1.5知识回顾
第2章预备知识——UML类图与面向对象设计原则
2.1UML概述
2.2类与类的UML图示
2.3类之间的关系
2.4面向对象设计原则概述
2.5单一职责原则
2.6开闭原则
2.7里氏代换原则
2.8依赖倒转原则
2.9接口隔离原则
2.10合成复用原则
2.11迪米特法则
2.12知识回顾
第2部分创建的艺术——创建型模式
第3章确保对象的唯一性——单例模式
3.1单例模式的动机
3.2单例模式概述
3.3负载均衡器的设计
3.4饿汉式单例与懒汉式单例的讨论
3.5一种更好的单例实现方法
3.6单例模式总结
3.7知识回顾
第4章集中式工厂的实现——简单工厂模式
4.1图表库的设计
4.2简单工厂模式概述
4.3完整解决方案
4.4方案的改进
4.5创建对象与使用对象
4.6简单工厂模式的简化
4.7简单工厂模式总结
4.8知识回顾
第5章多态工厂的实现——工厂方法模式
5.1日志记录器的设计
5.2工厂方法模式概述
5.3完整解决方案
5.4反射与配置文件
5.5重载的工厂方法
5.6工厂方法的隐藏
5.7工厂方法模式总结
5.8知识回顾
第6章产品族的创建——抽象工厂模式
6.1界面皮肤库的初始设计
6.2产品等级结构与产品族
6.3抽象工厂模式概述
6.4完整解决方案
6.5开闭原则的倾斜性
6.6抽象工厂模式总结
6.7知识回顾
第7章对象的克隆——原型模式
7.1大同小异的工作周报
7.2原型模式概述
7.3完整解决方案
7.4带附件的周报
7.5原型管理器的引入和实现
7.6原型模式总结
7.7知识回顾
第8章复杂对象的组装与创建——建造者模式
8.1游戏角色设计
8.2建造者模式概述
8.3完整解决方案
8.4关于Director的进一步讨论
8.5建造者模式总结
8.6知识回顾
第3部分组合的艺术——结构型模式
第9章不兼容结构的协调——适配器模式
9.1没有源码的算法库
9.2适配器模式概述
9.3完整解决方案
9.4类适配器模式
9.5双向适配器模式
9.6缺省适配器模式
9.7适配器模式总结
9.8知识回顾
第10章处理多维度变化——桥接模式
10.1跨平台图像浏览系统
10.2桥接模式概述
10.3完整解决方案
10.4适配器模式与桥接模式的联用
10.5桥接模式总结
10.6知识回顾
第11章树形结构的处理——组合模式
11.1设计杀毒软件的框架结构
11.2组合模式概述
11.3完整解决方案
11.4透明组合模式与安全组合模式
11.5Sunny公司组织结构
11.6组合模式总结
11.7知识回顾
第12章扩展系统功能——装饰模式
12.1图形界面构件库的设计
12.2装饰模式概述
12.3完整解决方案
12.4透明装饰模式与半透明装饰模式
12.5装饰模式注意事项
12.6装饰模式总结
12.7知识回顾
第13章提供统一入口——外观模式
13.1文件加密模块的设计
13.2外观模式概述
13.3完整解决方案
13.4抽象外观类的引入
13.5外观角色设计补充说明
13.6外观模式总结
13.7知识回顾
第14章实现对象的复用——享元模式
14.1围棋棋子的设计
14.2享元模式概述
14.3完整解决方案
14.4带外部状态的解决方案
14.5单纯享元模式和复合享元模式
14.6关于享元模式的几点补充
14.7享元模式总结
14.8知识回顾
第15章对象的间接访问——代理模式
15.1收费商务信息查询系统的设计
15.2代理模式概述
15.3完整解决方案
15.4远程代理
15.5虚拟代理
15.6Java动态代理
15.7代理模式总结
15.8知识回顾
第4部分交互的艺术——行为型模式
第16章请求的链式处理——职责链模式
16.1采购单的分级审批
16.2职责链模式概述
16.3完整解决方案
16.4纯与不纯的职责链模式
16.5职责链模式总结
16.6知识回顾
第17章请求发送者与接收者解耦——命令模式
17.1自定义功能键
17.2命令模式概述
17.3完整解决方案
17.4命令队列的实现
17.5撤销操作的实现
17.6请求日志
17.7宏命令
17.8命令模式总结
17.9知识回顾
第18章自定义语言的实现——解释器模式
18.1机器人控制程序
18.2文法规则和抽象语法树
18.3解释器模式概述
18.4完整解决方案
18.5再谈Context的作用
18.6解释器模式总结
18.7知识回顾
第19章遍历聚合对象中的元素——迭代器模式
19.1销售管理系统中数据的遍历
19.2迭代器模式概述
19.3完整解决方案
19.4使用内部类实现迭代器
19.5JDK内置迭代器
19.6迭代器模式总结
19.7知识回顾
第20章协调多个对象之间的交互——中介者模式
20.1客户信息管理窗口的初始设计
20.2中介者模式概述
20.3完整解决方案
20.4中介者与同事类的扩展
20.5中介者模式总结
20.6知识回顾
第21章撤销功能的实现——备忘录模式
21.1可悔棋的中国象棋
21.2备忘录模式概述
21.3完整解决方案
21.4实现多次撤销
21.5再谈备忘录的封装
21.6备忘录模式总结
21.7知识回顾
第22章对象间的联动——观察者模式
22.1多人联机对战游戏的设计
22.2观察者模式概述
22.3完整解决方案
22.4JDK对观察者模式的支持
22.5观察者模式与Java事件处理
22.6观察者模式与MVC
22.7观察者模式总结
22.8知识回顾
第23章对象状态及其转换——状态模式
23.1银行系统中的账户类设计
23.2状态模式概述
23.3完整解决方案
23.4共享状态
23.5使用环境类实现状态转换
23.6状态模式总结
23.7知识回顾
第24章算法的封装与切换——策略模式
24.1电影票打折方案
24.2策略模式概述
24.3完整解决方案
24.4策略模式的两个典型应用
24.5策略模式总结
24.6知识回顾
第25章定义算法的框架——模板方法模式
25.1银行利息计算模块
25.2模板方法模式概述
25.3完整解决方案
25.4钩子方法的使用
25.5模板方法模式总结
25.6知识回顾
第26章操作复杂对象结构——访问者模式
26.1OA系统中员工数据汇总
26.2访问者模式概述
26.3完整解决方案
26.4访问者模式与组合模式联用
26.5访问者模式总结
26.6知识回顾
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式的艺术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C#和.NET架构
第一部分　.NET架构
第1章　. NET简介
1. l　揭开. NET虚拟机的秘密
1. 2　Microsoft中间语言（IL）
1. 3　. NET内存管理
l. 4　. NET架构类型系统

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C#和.NET架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据运营服务型企业架构新思维

目录
第1章 筑巢：来自建筑行业的启示 4
1.1 谋划：像盖房子一样架构企业·· 5
以企业发展战略为指导，结合业务架构与技术架构，按照系统的方法论，将企业架构绘制成一座10个维度的小房子。
1.2 过程：企业是业务活动的集合体 7
按照分层分类的方法，从战略、建设、产品到运营的时间维和从市场需求到资源供给的空间维进行设计，业务过程框架表现为时空交叉的矩阵形式。
1.3 信息：企业业务活动的承载者·· 22
信息与业务过程是一体的、不可分割的，业务过程是动态的，信息是静态的，两者相互配合，组成了各种各样的业务活动。
1.4 应用：业务与技术之桥············ 27
应用即能力，它填平了业务与技术之间的鸿沟，是业务与技术之桥，应用框架又称为能力蓝图，体现了业务人员与技术人员的共同愿景。
1.5 功能：特定任务的执行单元····· 31
功能以应用/能力需求为输入，采用信息技术手段，将能力需求转化为用户可以使用的、具有特定规格要求的单元。
1.6 数据：信息社会的永恒记忆····· 33
“数据”是经过电子设备采集并存储后的载体，从业务需求到技术实现，通过概念模型、逻辑模型和物理模型来实现对数据的承载。
1.7 集成：价值网络时代的整合者·· 37
集成的目的就是将整体中的各个部分粘合起来, 借助业务服务，可以实现对业务过程、信息、应用、数据、技术等元素的有效集成。
1.8 技术：改变世界的源动力········· 40
构建技术架构的目标是保障系统的可靠性、可用性、可伸缩性、高性能以及安全性，分层、组件化和开放是技术架构设计的主要方法。
1.9 部署：让飞机平稳着陆············ 45
部署是设计方案和系统实现的落地，它将处于不同层级的“硬件”和“软件”有机地结合起来，最终实现可供用户使用的系统和服务。
1.10 安全：都是开放惹的祸·········· 54
坚持开放就必然会带来安全问题，可以沿着系统架构的“云+管+端”思路来分析引起安全问题和提供整体安全解决方案。
1.11 治理：没有规矩不成方圆······· 56
治理是对业务、应用与技术的管理，通过组织、人员、流程来保障，由于操作型应用与分析型应用的特点不同，治理重点也不一样。
1.12 本章主要内容回顾················· 58
第2章 联姻：当企业架构爱上大数据 60
2.1 大数据与决策：选择远比努力更重要 61
分析后形成的决策决定了企业发展的方向与道路，影响深远，正确的决策会让企业靠近成功，而错误的决策必然会导致失败。
2.2 张开想象的翅膀：大数据服务畅想 62
技术是手段，业务发展才是最终目标，企业首先需要从战略、建设、产品、客户、供应商、人才物等业务视角畅想可能需要的大数据服务。
2.3 对号入座：定位大数据发力点·· 81
立足于业务过程框架和业务过程块，不仅能够有利于快速发现新的大数据服务，又便于从业务角度来管理越来越多的大数据服务。
2.4 能力落地：大数据服务数据源及其关键实现活动 90
数据源是大数据服务的“根”，决定了大数据服务的能力，可以基于可能获取到的数据源，初步确定实现大数据服务的关键活动。
2.5 主要内容回顾·························· 108
第3章 孕育：凡事预则立，不预则废 109
3.1 大数据服务战略：大数据决定大未来 111
数据服务战略既是企业面向外部市场竞争的需要，又是企业释放自身能力的内在需求，是企业长远发展的必然选择。
3.2 大数据服务设计方法论：方法比努力更重要 122
首先分析大数据可能具备的能力，然后再分析问题域的特点，最后结合大数据能力与问题域特点，形成大数据服务需求。
3.3 大数据服务架构设计：在平衡中实现完美 129
大数据服务运营框架从业务角度出发，体现业务到数据的互动过程，大数据服务应用框架从能力角度出发，体现了大数据的管理过程。
3.4 大数据服务模型设计：默默无闻的贤内助 139
行成于思而毁于随，面向操作的数据模型侧重对“行”的支持，而面向分析的数据模型则侧重对“思”的支持。
3.5 大数据服务容量设计：海纳百川，有容乃大 156
与事务处理应用相比，大数据服务属于分析处理应用，由于两者的数据处理特点不同，因此容量估算方法也有一定的区别。
3.6 大数据服务过程设计：卓有成效的管理者 160
大数据服务过程包括服务目录管理、容量管理、可用性管理、连续性管理、服务等级管理、信息安全管理、供应商管理等。
3.7 大数据服务组织设计：分工不分家 164
按照专业化分工和关注点分离的原则，大数据服务业务分析师和大数据服务系统架构师是两个非常重要的角色。
3.8 主要内容回顾·························· 165
第4章 分娩：从幕后到台前的华丽转身 168
4.1 大数据服务转换原则················ 170
大数据服务转换充满了期待又存在着风险和挑战，需要综合权衡转换成本与收益、转换速度与风险。
4.2 大数据服务转换过程················ 171
大数据服务转换过程包括转换计划、变更管理、资产与配置管理、发布与部署管理、验证与测试、评估以及知识管理。
4.3 大数据服务转换组织设计········· 178
大数据服务转换中涉及的角色主要包括资产管理员、配置管理员、配置分析师、部署管理员、测试管理员。
4.4 主要内容回顾·························· 181
第5章 培育：调整、巩固、充实、提高 182
5.1 大数据服务运营：多、快、好、省 183
大数据服务运营既包括事件管理、事故管理、请求实现、问题管理、访问管理等过程，又包括服务台、技术管理、应用管理等职能。
5.2 大数据服务改进：自强不息止于至善 190
大数据服务不是一蹴而就的，是需要一个不断改进完善的过程，发现问题和差距并持续改进是提升企业决策能力的唯一途径。
5.3 主要内容回顾·························· 192
第6章 腾飞：在实践中检验真理··· 193
6.1 大数据在电信行业的应用········· 194
通信大数据既包含真实可靠的用户属性信息，又包括通话、上网等用户实时行为信息，可以反映个体与群体的社交关系、需求偏好、行为特征等。
6.2 大数据在金融行业的应用········· 203
金融的本质是信用，管理的难点是风险，金融企业应当能够驾驭大数据，提升运营效率并降低经营风险。
6.3 大数据在互联网行业的应用····· 211
互联网强调平等、协作、去中心化，通过搜索、社交、购物等互联网应用沉淀下来的海量数据，成为推动社会创新发展的催化剂。
6.4 大数据与隐私保护··················· 214
信息共享和数据开放既是把双刃剑，能否为造福人类关键要看我们的态度和行动，只有构建科学的组织、制度和流程，才能趋利避害，实现共赢。
6.5 大数据相关热点话题················ 217
云计算为大数据提供弹性的基础设施，移动互联网、物联网、电子商务既是大数据的提供者，又是大数据服务的消费者。
6.6 主要内容回顾·························· 224
第7章 框架体系：以不变应万变··· 227
7.1 企业架构：战略与运营之桥····· 229
从不同层次、不同视角刻画企业，形成既能够承接企业发展战略，又能够指导企业日常运营的企业架构框架。
7.2Frameworx框架体系：电信行业的灯塔 232
业务过程框架、信息框架、应用框架、系统集成框架从四个不同视角定义业务、能力以及业务服务需求，为四位一体的框架体系架构。
7.3ITIL/ITSM框架体系：IT行业的指南针 245
以服务方式管理IT，采用全生命周期的管理方式，分为服务战略、服务设计、服务转换、服务运营、服务持续优化5个阶段。
7.4 主要内容回顾·························· 258
第8章 大数据技术：他山之石，可以攻玉 261
8.1 开源框架Hadoop···················· 263
是一个基于分布式文件系统HDFS的框架体系，包括离线计算引擎MapReduce、实时计算引擎Storm、内存计算引擎Spark等。
8.2 大数据存储技术······················· 267
大数据借助分布式数据库存储，通过软件算法保证数据可靠性，分布式/列式数据库需要与关系型数据结合起来使用。
8.3 大数据分析技术······················· 272
大数据典型分析技术为离线计算技术MapReduce，它以大数据块为操作单位，首先对数据进行微分Map，然后再对集合内数据进行聚类运算。
8.4 大数据展示技术······················· 285
从多个维度、多个视角、全方位、直观地发现大数据背后隐藏的规律，相当于大数据挖掘的“最后一公里”。
8.5 主要内容回顾·························· 297
附录A 重点概念及其定义·············· 300
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据运营服务型企业架构新思维
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微电网——架构与控制
译者序
原书序
原书前言
作者简介
第1章微电网的概念
1.1引言
1.2微电网是分布式电源接入的工具
1.3微电网含义的澄清
1.3.1什么是微电网
1.3.2什么不是微电网
1.3.3微电网与虚拟发电厂
1.4微电网的运行与控制
1.4.1微电网中的可控元素
1.4.2微电网的运行策略
1.5微电网的市场模型
1.5.1简介
1.5.2微电网的内部市场与商务模型
1.5.3微电网的外部市场与监管
1.6微电网的应用现状与展望
参考文献
第2章微电网控制
2.1引言
2.2控制功能
2.3信息与通信技术的作用
2.4微电网控制架构
2.4.1分层控制
2.4.2微电网运营商
2.5集中控制与分散控制
2.6预测
2.6.1简介
2.6.2负荷预测
2.6.3风电与光伏发电预测
2.6.4热需求预测
2.6.5电价预测
2.6.6预测的不确定性评价
2.7集中控制
2.7.1经济运行
2.7.2电能市场的参与
2.7.3数学模型
2.7.4求解方法
2.7.5研究案例
2.7.6案例结果
2.8分散控制
2.8.1多代理系统理论
2.8.2代理通信与发展
2.8.3代理通信语言
2.8.4代理本体与数据模型
2.8.5微电网控制的协调算法
2.8.6博弈论与市场规则的算法
2.8.7可扩展性与先进架构
2.9状态估计
2.9.1简介
2.9.2微电网状态估计
2.9.3模糊状态估计
2.10小结
附录2.A微电网案例研究
参考文献
第3章智能本地控制器
3.1引言
3.2微电网逆变器控制
3.2.1有功功率控制
3.2.2电压调节
3.3多逆变器的控制策略
3.3.1主从控制
3.3.2多主逆变器控制
3.3.3VSI的下垂控制
3.3.4辅助服务
3.3.5二次控制（可选）
3.4线路参数对频率和电压下垂控制的影响
3.4.1低压电网的功率传输
3.4.2低压电网中下垂控制的比较
3.4.3下垂控制的间接实现
3.5提高稳定性的新型本地控制方法的发展与评价
3.5.1控制算法
3.5.2孤岛模式的稳定性
3.5.3互联运行的稳定性
3.6小结
参考文献
第4章微电网保护
4.1引言
4.2微电网保护所面临的挑战
4.2.1配电系统保护
4.2.2配电网馈线过电流保护
4.2.3配电网馈线过电流保护和分布式电源
4.2.4并网模式下的微电网外部故障
4.2.5并网模式下的微电网内部故障
4.2.6并网模式下的用户终端故障
4.2.7孤岛模式下的微电网内部故障
4.2.8孤岛模式下的用户端故障
4.3微电网自适应保护
4.3.1简介
4.3.2基于提前计算整定值的自适应保护
4.3.3并网模式下不含分布式电源的微电网保护
4.3.4并网和孤岛模式下有同步型分布式电源接入的微电网
4.3.5基于实时计算整定值的自适应保护系统
4.3.6自适应保护的通信体系和协议
4.4利用故障电流源实现孤岛模式下的有效保护
4.5微电网故障电流限制
4.6小结
附录4.A.1中压/低压微电网集中式自适应保护系统
附录4.A.2FCS样机的描述
参考文献
第5章多微电网的协调运行
5.1引言
5.2多微电网控制与管理架构
5.3电压/无功协调控制
5.3.1简述
5.3.2数学模型
5.3.3推荐方法
5.3.4微电网稳态等值
5.3.5工具的开发
5.3.6主要成果
5.4频率协调控制
5.4.1分层控制概述
5.4.2分层控制细节
5.4.3主要成果
5.5紧急功能（黑启动）
5.5.1恢复规则
5.5.2黑启动程序案例
5.6动态等值
5.6.1微电网动态等值方法
5.6.2微电网系统的定义
5.6.3微电网动态等值方法的发展
5.6.4仿真主要结果
5.7小结
参考文献
第6章典型试点：成功案例与经验教训
6.1引言
6.2欧洲微电网项目综述
6.2.1在Gaidouromandra的Kythnos岛微电网（希腊）现场试验：孤岛系统的分散、智能负荷控制
6.2.2在曼海姆（Mannheim）市的现场试验:从并网模式切换为孤岛模式
6.2.3Bronsbergen微电网（荷兰）：孤岛运行和智能储能
参考文献
6.3美国的智能电网项目概述
6.3.1研发项目和示范项目
6.3.2项目总结
参考文献
6.4日本微电网项目概述
6.4.1区域电网项目
6.4.2电网技术项目
6.4.3新墨西哥州的示范项目
6.5中国微电网项目概述
6.5.1岛屿上的微电网
6.5.2工业、商业和住宅区的微电网
6.5.3偏远地区的微电网
参考文献
6.6智利的离网微电网
6.6.1项目描述
6.6.2需求侧管理
参考文献
第7章微电网的技术、经济、环境与社会效益量化
7.1微电网潜在效益概述
7.1.1微电网经济效益
7.1.2微电网技术效益
7.1.3微电网环境和社会效益
7.2效益量化研究方案
7.2.1仿真与分析方法
7.2.2欧洲微电网研究案例
7.3标准测试条件下的微电网效益量化
7.3.1标准测试条件定义
7.3.2能量平衡结果
7.3.3技术效益
7.3.4经济效益
7.3.5环境效益
7.3.6提高可靠性
7.3.7微电网发展的社会效益
7.4外部市场价格和定价策略的影响
7.4.1灵敏度分析
7.4.2能量平衡对外部市场价格和定价策略的灵敏度
7.4.3技术效益（损耗）对外部市场价格和定价策略的灵敏度
7.4.4经济效益对外部市场价格和定价策略的灵敏度
7.4.5环境效益对外部市场价格和定价策略的灵敏度
7.5微电网运行策略的影响
7.6欧洲微电网效益量化
7.7小结
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微电网——架构与控制
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>VIE架构境外间接上市税法问题研究
导言
第一章 VIE架构及其税务处理实践
第一节 VIE架构的产生和具体模式
一、VIE架构的产生和含义
二、VIE架构的具体模式
第二节 VIE架构面临的税法问题与税务风险概述
一、VIE架构的税法问题概述
二、VIE架构企业涉及税法问题的分类
第二章 VIE架构税法问题的分阶段考察
第一节 境外筹集资金回流阶段的税法问题
一、通过真实交易结汇的税负影响
二、通过虚假交易结汇引发的税法问题
第二节 境内运营实体向WFOE转移利润阶段的税法问题
一、流转税处理
二、VIE架构内关联交易与转让定价问题
第三节 wFOE向境外上市主体转移利润阶段的税法问题
一、香港子公司设立的目的
二、“受益所有人”的概念和我国反税收协定滥用措施中的相关规定
三、香港子公司“受益所有人”的认定分析
第三章 与境外上市主体相关的税法问题
第一节 境外上市主体的居民企业身份认定及其税负影响
一、我国居民企业身份认定的相关法律标准
二、境外上市主体的纳税主体身份判定
三、境外上市主体被认定为居民企业的影响
第二节 PFIC税制下的境外上市主体
一、美国PFIC税制简介
二、VIE架构下境外上市主体PFIC规则的适用分析
三、境外上市主体被归类为PFIC产生的税务后果
第三节 VIE架构内非居民企业股权间接转让的税法处理
一、非居民企业股权间接转让的税法规定
二、VIE架构内非居民企业间接转让合理商业目的分析
第四节 VIE架构股权激励计划的所得税处理
一、个人所得税处理
二、企业所得税处理
第四章 VIE架构红筹回归的税务处理
第一节 VIE架构企业红筹回归原因及过程
第二节 VIE架构红筹回归的涉税问题分析
一、股权、财产转让所得税问题
二、关于税务历史遗留问题的梳理
第五章 VIE架构的税负评价
第一节 VIE架构对企业税负的影响分析
一、VIE架构下企业的额外税收负担
二、税收优惠对VIE架构企业的积极影响
第二节 有效税率视角下VIE架构企业的税负水平
一、评价企业税负水平的方法：有效税率法
二、有效税率法下VIE架构企业的税负水平衡量
三、VIE架构企业的税法评价
第六章 VIE架构企业的税务风险防范
第一节 VIE架构的税务风险点
一、组织结构引发的税务风险
二、税法政策带来的风险
第二节 VIE架构税务风险防范措施
一、注重非税利益的衡量
二、增加交易安排的商业实质
三、加强与税务机关的沟通、协商
四、及时更新税法的变化，保持筹划方案的灵活性
第七章 对VIE架构企业税收监管的难点和建议
第一节 税务机关对VIE架构监管的难点
一、VIE架构的复杂性给监管带来了巨大的难度
二、涉税信息获取困难
三、涉及的税法问题处理难度大
第二节 对VIE架构企业税收监管的建议
一、总体监管模式——从VIE架构整体着眼的全局监管模式
二、关键监管措施——以拓宽涉税信息采集渠道为主，建立全面的涉税信息管理机制
结语
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>VIE架构境外间接上市税法问题研究
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务架构实战
第1章　微服务概述
1.1　什么是微服务
1.2　为什么微服务
1.2.1　区别
1.2.2　从单体应用说起
1.2.3　第一步切分
1.2.4　服务化所带来的问题
1.2.5　微服务的可扩展性
1.2.6　微服务与SOA的区别
1.3　常见的微服务组件
1.4　常用的微服务框架
1.4.1　Spring顶级项目
1.4.2　背景
1.4.3　社区活跃度
1.4.4　架构完整度
1.4.5　总结
1.5　微服务架构设计模式
1.6　如何实施微服务
1.7　小结
第2章　微服务设计原则
2.1　设计原则之分层架构
2.2　设计原则之统一通信协议
2.3　设计原则之单一职责
2.4　设计原则之服务拆分
2.5　设计原则之前后端分离
2.6　设计原则之版本控制
2.7　设计原则之围绕业务构建
2.8　设计原则之并发流量控制
2.9　设计原则之CAP
2.10　设计原则之EDA事件驱动
2.11　设计原则之CQRS
2.12　设计原则之基础设施自动化
2.13　设计原则之数据一致性
2.14　设计原则之设计模式
2.15　设计原则之DevOps
2.16　设计原则之无状态服务
2.17　小结
第3章　微服务之Spring Boot
3.1　一切从简单开始
3.2　快速集成第三方的Starter
3.3　降低开发复杂度之面向切面
3.3.1　前置通知
3.3.2　后置返回通知
3.3.3　后置异常通知
3.3.4　后置最终通知
3.3.5　环绕通知
3.3.6　AOP总结
3.4　并不复杂的持久化
3.4.1　单数据源
3.4.2　多数据源
3.4.3　JOOQ
3.4.4　事务处理
3.4.5　整合Redis
3.4.6　整合队列
3.4.7　操作MongoDB
3.5　Web开发
3.6　懒人的接口文档管理
3.7　优化的调度
3.8　健康是永恒的主题
3.9　强强联合之整合Dubbo
3.10　小结
第4章　微服务之Docker
4.1　Docker原理
4.2　更轻量级的虚拟化
4.3　三个概念理解Docker
4.3.1　镜像（Image）
4.3.2　容器（Container）
4.3.3　仓库（Repository）
4.4　Dockerfile定制一切
4.4.1　Dockerfile语法
4.4.2　Dockerfile命令
4.4.3　Dockerfile构建过程
4.4.4　构建Java环境
4.4.5　Dockerfile小结
4.5　Docker网络
4.5.1　网络模式
4.5.2　link
4.5.3　跨主机访问
4.6　Docker数据卷
4.6.1　数据卷
4.6.2　数据卷容器
4.7　Spring Boot与Docker
4.8　搭建自己的镜像仓库
4.8.1　安装和启动
4.8.2　使用
4.9　Kubernetes
4.10　私有云整体架构
4.11　小结
第5章　微服务之Spring Cloud
5.1　注册中心
5.1.1　常用的注册中心
5.1.2　Eureka介绍
5.1.3　服务发现
5.1.4　简单注册
5.2　负载均衡
5.2.1　Spring Cloud的负载实现
5.2.2　Ribbon
5.2.3　Feign
5.2.4　加入core
5.3　微服务容错（Hystrix）
5.3.1　雪崩的形成
5.3.2　应对方案
5.3.3　降级和熔断
5.3.4　Hystrix
5.3.5　集中监控
5.4　分布式配置中心
5.5　API网关
5.5.1　为什么需要网关
5.5.2　Zuul
5.6　消息总线（Spring Cloud Bus）
5.7　小结
第6章　微服务之Spring Cloud其他框架
6.1　Spring Cloud Consul
6.2　Spring Cloud ZooKeeper
6.3　Spring Cloud archaius
6.4　Spring Cloud Task
6.5　Spring Cloud Security
6.5.1　HTTP Basic Authentication
6.5.2　JWT
6.5.3　OAuth 2
6.5.4　Spring Cloud Security
6.6　Spring Cloud Sleuth
6.6.1　服务端
6.6.2　客户端
6.7　Spring Cloud Stream
6.8　Spring Cloud Data Flow
6.9　小结
第7章　微服务之自动化测试与质量管理
7.1　微服务测试
7.2　单元测试
7.2.1　单元测试及覆盖率评估
7.2.2　JUnit
7.2.3　Spring Boot单元测试
7.2.4　Mockito
7.3　API测试
7.3.1　Jmeter
7.3.2　压力测试
7.4　A/B测试
7.5　冒烟和回归测试
7.6　静态代码分析
7.6.1　Checkstyle
7.6.2　FindBugs
7.6.3　PMD
7.7　SonarQube质量监控
7.7.1　为什么使用
7.7.2　安装和使用
7.7.3　安装插件
7.7.4　运行流程
7.8　小结
第8章　微服务之JHipster
8.1　JHipster技术列表
8.1.1　客户端选项
8.1.2　服务端选项
8.1.3　部署选项
8.2　Angular简介
8.3　快速开始JHipster
8.3.1　安装
8.3.2　使用
8.3.3　构建单体应用
8.3.4　Entity sub-generator
8.3.5　开发和运行
8.3.6　插件安装
8.4　目录结构
8.5　构建微服务应用
8.5.1　注册中心
8.5.2　创建微服务网关
8.5.3　Traefik
8.5.4　JHipster UAA
8.5.5　构建微服务应用
8.6　基础配置
8.6.1　JHipster属性配置
8.6.2　作为Maven项目
8.6.3　数据库
8.6.4　DTO
8.6.5　分页
8.6.6　文档
8.7　小结
第9章　微服务之自动化部署
9.1　私有仓库搭建
9.1.1　Nexus介绍
9.1.2　安装与配置
9.1.3　在项目中使用
9.2　Ansible
9.3　持续集成
9.3.1　持续集成流程
9.3.2　Jenkins介绍与安装
9.3.3　Maven介绍
9.3.4　Jenkins系统设置
9.3.5　集成Sonar
9.3.6　构建工程
9.3.7　配置测试
9.4　灰度发布
9.5　小结
第10章　微服务之日志收集与监控
10.1　ELK搜集与分析
10.1.1　工作流程
10.1.2　日志格式
10.1.3　平台搭建
10.2　系统监控
10.2.1　监控策略和监控对象
10.2.2　进程监控
10.2.3　数据波动监控
10.2.4　常用监控命令
10.3　运维监控
10.3.1　Zabbix
10.3.2　Open-Falcon
10.4　APM监控
10.4.1　Pinpoint
10.4.2　SkyWalking
10.4.3　Zipkin
10.4.4　CAT
10.5　Pinpoint的安装与使用
10.5.1　Pinpoint的安装
10.5.2　Pinpoint的使用
10.5.3　Pinpoint实现邮件告警
10.6　小结
第11章　完整示例
11.1　安装Lombok
11.2　PiggyMetrics
11.3　整体架构
11.3.1　配置Spring Cloud Config
11.3.2　授权服务
11.3.3　API网关
11.3.4　服务发现
11.3.5　负载均衡器、断路器和HTTP客户端
11.3.6　监控仪表盘
11.3.7　日志分析
11.4　安装和运行
11.4.1　配置Maven并导入工程
11.4.2　安装
11.4.3　使用
11.4.4　如何变成自己的项目
11.5　小结
第12章　微服务核心功能推荐
12.1　工作流引擎
12.1.1　Activiti
12.1.2　UFLO
12.2　规则引擎
12.2.1　Drools
12.2.2　URule
12.3　调度系统
12.4　消息推送
12.5　网关中间件
12.5.1　Orange
12.5.2　Kong
12.5.3　Zuul
12.6　分库分表中间件
12.6.1　Sharding-JDBC
12.6.2　MyCat
12.7　报表引擎
12.8　数据处理
12.8.1　Spring Batch
12.8.2　Kettle
12.9　并发编程
12.10　分布式配置
12.10.1　Disconf
12.10.2　Apollo
12.11　CAS
12.12　WebFlux
12.13　小结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务架构实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>NUTANIX超融合基础架构权威指南
Nutanix企业云在中国
超越虚拟机和公有云
前言
第1章 超融合系统发展历程及概述
1.1 数据中心的演进
1.2 超融合系统概览
1.3 超融合市场格局
1.4 软件定义存储与超融合系统
1.5 数据中心面临的挑战
1.6 超融合出现的诱因
1.7 超融合适用的应用场景
1.8 引入超融合的时机
第2章 Nutanix超融合介绍
2.1 Nutanix公司介绍
2.2 Nutanix产品介绍
2.2.1 Acropolis软件
2.2.2 Prism软件
2.2.3 产品形态
2.3 Nutanix技术原理
2.3.1 Nutanix系统设计架构
2.3.2 高效性技术特性
2.3.3 存储容量优化技术特性
2.3.4 高可用性技术特性
2.3.5 备份与容灾技术特性
2.3.6 面向应用的扩展服务
第3章 HCI实验环境搭建
3.1 Nutanix Next社区介绍
3.1.1 Nutanix社区版介绍
3.1.2 Nutanix Next社区注册步骤
3.2 Intel NUC介绍
3.3 Nutanix社区版安装
3.3.1 下载及制作镜像盘
3.3.2 安装Nutanix社区版
3.3.3 AOS集群创建
3.3.4 登录Prism集群管理控制台
3.3.5 安装Prism Central
3.4 Nutanix社区版操作
3.4.1 Prism控制台操作
3.4.2 自助服务门户操作
3.4.3 Prism Central操作
3.4.4 常见排错操作
第4章 HCI规划与设计
4.1 计算规划设计
4.1.1 物理CPU到vCPU的换算
4.1.2 内存资源的换算
4.1.3 计算资源的数据收集
4.1.4 计算资源的损耗类型
4.1.5 超融合资源计算实战
4.2 存储规划设计
4.2.1 全闪存模式和混合模式
4.2.2 存储池设计
4.2.3 存储容器设计
4.2.4 数据安全
4.3 网络规划设计
4.3.1 超融合物理网络设计
4.3.2 虚拟网络设计
4.3.3 CVM的网络连接
4.3.4 NTP配置
4.4 安全规划设计
4.4.1 网络安全
4.4.2 访问控制
4.5 高可用规划设计
4.5.1 数据可用性设计
4.5.2 数据中心容灾
第5章 HCI部署与测试
5.1 集群部署
5.1.1 环境准备
5.1.2 使用Foundation部署Nutanix集群
5.2 性能测试
5.2.1 测试工具介绍
5.2.2 测试工具使用
第6章 HCI操作与管理
6.1 虚拟化支持概览
6.1.1 虚拟化系统的选择
6.1.2 Nutanix功能在Hypervisor上的差异
6.2 AHV环境操作
6.2.1 AHV最大配置
6.2.2 Acropolis动态调度
6.2.3 AHV高可用性配置
6.2.4 AHV支持Citrix XenDesktop
6.2.5 节点关闭
6.2.6 节点启动
6.3 vSphere环境操作
6.3.1 vSphere最大配置
6.3.2 vSphere HA/DRS配置
6.3.3 vSphere EVC配置
6.3.4 VAAI支持
6.3.5 节点关闭
6.3.6 节点启动
6.3.7 Nutanix预设配置
6.4 Hyper-V环境操作
6.4.1 Hyper-V最大配置
6.4.2 ODX存储优化特性支持
6.4.3 节点关闭
6.4.4 节点启动
6.4.5 SCVMM管理
6.5 XenServer环境操作
6.5.1 XenServer最大配置
6.5.2 XenServer要求与限制
6.5.3 节点关闭
6.5.4 节点启动
6.5.5 XenCenter管理
6.6 日常运维管理
6.6.1 集群操作
6.6.2 虚拟化层VLAN修改
6.6.3 CVM内存配置修改
6.6.4 主机操作与管理
6.6.5 日志集中处理
6.6.6 合规性管理与软件升级
6.6.7 监控与警报
6.7 应用迁移
6.7.1 同类Hypervisor迁移
6.7.2 异构Hypervisor迁移
6.7.3 镜像服务导入应用
6.8 自动化操作
6.8.1 Nutanix API介绍
6.8.2 CLI操作
6.8.3 命令行的批量操作
第7章 HCI应用场景介绍
7.1 关键应用平台
7.1.1 支持各类关键应用
7.1.2 Nutanix为关键应用带来的优势
7.2 数据保护方案
7.2.1 Nutanix平台内置的数据保护机制
7.2.2 Nutanix数据保护带来的优势
7.3 桌面虚拟化方案
7.3.1 Nutanix释放桌面虚拟化无穷潜力
7.3.2 Nutanix为桌面虚拟化带来的优势
7.4 大数据平台
7.4.1 Nutanix节约大数据平台运维成本
7.4.2 Nutanix为大数据平台带来的优势
7.5 分支机构方案
7.5.1 Nutanix打造简约的分支机构IT环境
7.5.2 Nutanix为分支机构IT环境带来的优势
7.6 开发测试环境
7.6.1 通过企业云架构开发测试环境
7.6.2 Nutanix云平台为开发测试环境带来的优势
附录A 超融合系统评估要点
附录B Nutanix软件版本和功能划分
B.1 Acropolis软件版本和功能划分
B.2 Prism软件版本功能划分
附录C 术语表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>NUTANIX超融合基础架构权威指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java代码与架构之完美优化
目录
序
前言
第1章 代码质量1
1.1 什么是代码质量1
1.2 什么是软件质量1
1.3 代码质量与软件质量1
1.4 代码质量优化理论2
1.5 提高代码质量手段3
小结3
第2章 代码质量静态检查工具4
2.1 静态分析技术概述4
2.2 静态分析技术原理4
2.3 静态分析技术给我们带来的好处5
2.4 常用重要静态分析工具6
2.5 如何优化静态分析工具6
小结11
第3章 代码质量优化通用准则12
3.1 避免使用空块12
3.2 避免使用空类15
3.3 去掉多余的import16
3.4 剪切无效代码17
3.5 制定命名体系规约18
编程解密一：完美规约20
优化技巧01：按照命名规约赋予名称20
3.6 去掉重复代码21
3.7 如何优雅使用switch语句22
3.8 用大写“L”代替小写“l”定义long变量24
3.9 避免在一条语句中声明或赋值多个变量25
3.10 去掉控制标志的临时变量26
优化技巧02：移除控制标志临时变量27
3.11 避免赋予临时变量过多的角色28
优化技巧03：赋予临时变量单一职责29
3.12 避免使用魔法数字29
优化技巧04：用常量取代魔法数字30
3.13 在for循环内修正增量因子有什么弊端31
3.14 用Enum代替Integer类型码常量32
优化技巧05：用枚举取代类型码34
3.15 用BigDecimal类型进行精确计算35
3.16 避免混用“+”36
3.17 避免混用复杂运算符37
3.18 避免使用复杂条件式或分支38
优化技巧06：用代码片段拆分复杂表达式41
优化技巧07：用卫语句代替嵌套条件表达式42
优化技巧08：用多态代替条件表达式43
3.19 如何深入理解“= ；=”的真正含义44
3.20 要习惯于用泛型代替原生类型48
3.21 如何正确使用通配符的边界53
3.22 如何发挥正则表达式的威力55
小结58
第4章 方法优化技巧59
4.1 最小化原则59
优化技巧09：封装类成员60
4.2 hashCode（）与equals（）是个孪生兄弟61
4.3 使用string.equals（"String"）带来的弊端66
4.4 避免命名不具有继承关系的同名方法67
4.5 检查参数的有效性68
4.6 避免使用可变参数69
4.7 如何优化过长参数72
优化技巧10：把参数提升成类成员变量73
优化技巧11：引入参数对象74
4.8 为什么不要重写静态方法75
4.9 避免使用过时的API77
4.10 优雅的集合运算方法知多少78
4.11 避免重复发明轮子81
4.12 如何对臃肿的方法进行瘦身82
优化技巧12：分解方法84
优化技巧13：合并方法85
小结85
第5章 如何保证多线程代码质量86
5.1 为什么不要重写start（）方法86
5.2 避免使用非线程安全的初始化方法87
5.3 用final成员对象作为同期化对象锁90
5.4 在synchronized内使用wait（）方法92
5.5 尽量缩小同期化代码范围93
小结94
第6章 如何优化类与接口95
6.1 避免创建不必要的对象95
6.2 避免使用对象的浅拷贝96
6.3 如何正确放置静态区位置100
6.4 为什么不要使用静态引入102
6.5 如何正确使用instanceof103
6.6 避免实例化特有工具类106
6.7 避免有深度耦合的类关系107
优化技巧14：移动变量110
优化技巧15：移动方法112
6.8 如何为臃肿的类进行手术114
优化技巧16：分解类116
6.9 如何优化冗赘类117
优化技巧17：合并类118
6.10 避免在接口中出现实现代码119
小结120
第7章 如何正确使用异常121
7.1 避免定义继承Error或Throwable子类121
7.2 避免抛出RuntimeException或Exception122
7.3 避免捕获NullPointerException或Error124
7.4 避免在finally块中处理返回值125
7.5 避免使失败失去原子性127
7.6 如何对异常进行封装128
优化技巧18：用异常代替错误码129
7.7 将优雅的异常信息反馈给用户130
7.8 避免乱用异常131
小结133
第8章 如何优化代码性能134
8.1 避免在大量字符串拼接时用“+”134
8.2 避免在循环体内生成临时对象135
8.3 在频繁插入与删除时使用LinkedList137
8.4 在文件操作后要进行清理动作139
编程解密四：完美改造140
8.5 避免显示调用finalized（）方法142
小结143
第9章 架构优化144
9.1 单一职责原则144
优化技巧19：梳理并分解类职责145
9.2 接口隔离原则147
优化技巧20：隔离接口149
9.3 依赖倒置原则151
优化技巧21：提炼接口152
9.4 里式替换原则154
9.5 最少知道原则155
9.6 如何扩展外部类功能159
优化技巧22：引入本地扩展160
9.7 如何梳理混杂的架构体系160
优化技巧23：以委托代替继承165
优化技巧24：封装向下转型165
优化技巧25：提炼继承体系167
优化技巧26：折叠继承体系169
小结170
第10章 包优化172
10.1 发布等价原则172
10.2 共同重用原则173
10.3 共同封闭原则174
10.4 无环依赖原则176
10.5 如何保持包的清晰179
优化技巧28：规整包中类位置180
编程解密五：完美优化181
10.6 如何抽出框架层次182
10.7 如何提取框架工程183
小结189
第11章 优良代码风格190
11.1 如何优化代码格式工具190
11.2 如何统一标准的代码格式193
11.3 养成良好的代码注释习惯194
编程解密六：完美突破196
小结198
结束语199
附录200
参考文献229
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java代码与架构之完美优化
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>系统架构设计师考试历年试题分析与解答
第1章  操作系统	1
1.1  考点分析	1
1.2  试题精解	1
第2章  数据库系统	18
2.1  考点分析	18
2.2  试题精解	19
第3章  计算机硬件基础及嵌入式
系统设计	37
3.1  考点分析	37
3.2  试题精解	38
第4章  数据通信与计算机网络	65
4.1  考点分析	65
4.2  试题精解	65
第5章  系统安全性与保密性设计	88
5.1  考点分析	88
5.2  试题精解	89
第6章  信息化基础	103
6.1  考点分析	103
6.2  试题精解	104
第7章  系统开发基础	126
7.1  考点分析	126
7.2  试题精解	128
第8章  软件架构设计	186
8.1  考点分析	186
8.2  试题精解	187
第9章  应用数学	253
9.1  考点分析	253
9.2  试题精解	254
第10章  知识产权与标准化	262
10.1  考点分析	262
10.2  试题精解	263
第11章  系统配置与性能评价	275
11.1  考点分析	275
11.2  试题精解	276
第12章  专业英语	289
12.1  考点分析	289
12.2  试题精解	289
第13章  案例分析	297
13.1  考点分析	297
13.2  试题精解	299
第14章  架构设计论文	392
14.1  考点分析	392
14.2  试题精解	393
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>系统架构设计师考试历年试题分析与解答
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>系统分析师和系统架构设计师软考辅导-3年真题精解与实战模拟
前言
第1篇 3年软考真题精解
第1章 2012年上半年真题精解
1.1 上午试卷
1.1.1 试题描述
1.1.2 要点解析
1.1.3 参考答案
1.2 下午试卷ⅰ
1.2.1 试题描述
1.2.2 要点解析
1.2.3 参考答案
1.3 下午试卷ⅱ
1.3.1 试题描述
1.3.2 写作要点
第2章 2011年下半年真题精解
2.1 上午试卷
2.1.1 试题描述
2.1.2 要点解析
2.1.3 参考答案
2.2 下午试卷i
2.2.1 试题描述
2.2.2 要点解析
2.2.3 参考答案
2.3 下午试卷ⅱ
2.3.1 试题描述
2.3.2 写作要点
第3章 2011年上半年真题精解
3.1 上午试卷
3.1.1 试题描述
3.1.2 要点解析
3.1.3 参考答案
3.2 下午试卷i
3.2.1 试题描述
3.2.2 要点解析
3.2.3 参考答案
3.3 下午试卷ⅱ
3.3.1 试题描述
3.3.2 写作要点
第4章 2010年下半年真题精解
4.1 上午试卷
4.1.1 试题描述
4.1.2 要点解析
4.1.3 参考答案
4.2 下午试卷ⅰ
4.2.1 试题描述
4.2.2 要点解析
4.2.3 参考答案
4.3 下午试卷ⅱ
4.3.1 试题描述
4.3.2 写作要点
第5章 2010年上半年真题精解
5.1 上午试卷
5.1.1 试题描述
5.1.2 要点解析
5.1.3 参考答案
5.2 下午试卷i
5.2.1 试题描述
5.2.2 要点解析
5.2.3 参考答案
5.3 下午试卷ii
5.3.1 试题描述
5.3.2 写作要点
第6章 2009年下半年真题精解
6.1 上午试卷
6.1.1 试题描述
6.1.2 要点解析
6.1.3 参考答案
6.2 下午试卷i
6.2.1 试题描述
6.2.2 要点解析
6.2.3 参考答案
6.3 下午试卷ii
6.3.1 试题描述
6.3.2 写作要点
第2篇 3次模拟巩固提升
第7章 实战模拟试卷1
7.1 上午试卷
7.1.1 试题描述
7.1.2 要点解析
7.1.3 参考答案
7.2 下午试卷i
7.2.1 试题描述
7.2.2 要点解析
7.2.3 参考答案
7.3 下午试卷ii
7.3.1 试题描述
7.3.2 写作要点
第8章 实战模拟试卷2
8.1 上午试卷
8.1.1 试题描述
8.1.2 要点解析
8.1.3 参考答案
8.2 下午试卷i
8.2.1 试题描述
8.2.2 要点解析
8.2.3 参考答案
8.3 下午试卷ii
8.3.1 试题描述
8.3.2 写作要点
第9章 实战模拟试卷3
9.1 上午试卷
9.1.1 试题描述
9.1.2 要点解析
9.1.3 参考答案
9.2 下午试卷i
9.2.1 试题描述
9.2.2 要点解析
9.2.3 参考答案
9.3 下午试卷ii
9.3.1 试题描述
9.3.2 写作要点
附录a 2012年下半年真题试卷
附录b 答题卡及答题纸示例
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>系统分析师和系统架构设计师软考辅导-3年真题精解与实战模拟
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>工业大数据：架构与应用
第1章绪论1
●1.1智能制造及技术体系4
1.1.1智能制造的定义4
1.1.2智能制造的目标5
1.1.3智能制造的技术体系6
●1.2工业大数据的战略作用8
1.2.1大数据与企业核心能力9
1.2.2大数据与价值链11
1.2.3大数据与制造模式13
●1.3工业大数据定义、特征18
1.3.1工业大数据定义18
1.3.2工业大数据特征19
●1.4工业大数据战略、实现路径及实施流程19
1.4.1不同类型的业务战略19
1.4.2工业大数据价值实现路径21
1.4.3工业大数据实施流程23
参考文献25
第2章工业大数据架构27
●2.1德国工业4.0参考架构30
2.1.1背景30
2.1.2RAMI4.0模型30
2.1.3功能层31
2.1.4生命周期与价值流33
2.1.5企业纵向层33
2.1.6工业4.0组件34
●2.2美国工业互联网参考架构37
2.2.1背景37
2.2.2工业互联网架构基本概念38
2.2.3业务视角39
2.2.4应用视角39
2.2.5功能视角40
2.2.6实施视角42
●2.3日本工业价值链参考架构43
2.3.1背景43
2.3.2IVRA模式44
2.3.3智能制造单元46
●2.4中国制造2025参考架构47
2.4.1背景47
2.4.2智能制造系统架构47
2.4.3智能制造标准体系结构49
●2.5工业大数据参考架构50
2.5.1生命周期与价值流51
2.5.2企业纵向层级52
2.5.3IT价值链55
参考文献58
第3章研发大数据59
●3.1研发大数据的类型61
●3.2研发大数据的应用62
3.2.1基于模型的研发设计62
3.2.2基于仿真的研发设计65
3.2.3基于产品生命周期的设计67
3.2.4融合消费者反馈的设计69
●3.3研发大数据的创新71
3.3.1产品创新研发的消费者驱动模式71
3.3.2产品创新的技术驱动模式71
3.3.3用数据让竞争创新透明化72
●3.4研发大数据服务技术平台74
参考文献76
第4章生产大数据77
●4.1企业资源管理（ERP）79
4.1.1ERP简介79
4.1.2ERP体系79
4.1.3融合大数据的ERP实施80
●4.2企业制造执行系统（MES）81
4.2.1MES简介81
4.2.2MES体系82
4.2.3结合大数据的MES应用84
●4.3客户关系管理（CRM）87
4.3.1CRM简介87
4.3.2运用大数据的CRM营销88
●4.4供应链管理（SCM）90
4.4.1SCM简介90
4.4.2基于大数据的SCM优化91
4.4.3大数据时代下的SCM变革92
参考文献96
第5章服务大数据97
●5.1服务大数据类型及价值体现99
5.1.1服务大数据的类型100
5.1.2服务大数据主要来源及其价值体现100
●5.2服务大数据应用103
5.2.1预测性维修103
5.2.2城市基础设施管理109
5.2.3企业能源管理114
参考文献118
第6章信息物理系统119
●6.1CPS的基本理论121
6.1.1CPS的定义121
6.1.2CPS的本质123
6.1.3CPS体系架构124
●6.2CPS在产品全生命周期中的应用126
6.2.1研发与设计127
6.2.2生产与供应链管理128
6.2.3运维与服务129
●6.3CPS下的智能工厂130
6.3.1自动化和互联的设备131
6.3.2产品智能化且可配置131
6.3.3智能的机器和流程132
6.3.4具有知识的人133
●6.4CPS下的智慧城市136
参考文献141
第7章企业管理信息系统143
●7.1企业管理信息系统的发展历程144
7.1.1信息技术在企业应用的发展历程145
7.1.2信息化管理的成熟度模型146
7.1.3企业管理信息系统的七个阶段147
7.1.4企业集成运行的成熟度模型148
●7.2管理信息系统构成149
7.2.1从信息角度149
7.2.2从职能角度150
7.2.3从应用角度151
●7.3两化融合下的管理信息系统集成153
7.3.1信息化集成标准153
7.3.2纵向集成155
7.3.3跨越整个价值链的端到端工程数字集成157
7.3.4价值网络的横向集成159
7.3.5信息化集成系统内的系统集成160
●7.4工业大数据下的关键应用164
7.4.1高级计划与排程164
7.4.2产品生命周期管控165
7.4.3供应链集成166
参考文献167
第8章“互联网 ”时代的工业转型169
●8.1理论基础171
8.1.1马斯洛需求理论171
8.1.2生产型消费者与共享经济172
8.1.3平台战略174
●8.2个性化定制177
8.2.1产生背景177
8.2.2个性化定制业务框架177
8.2.3应用案例180
●8.3网络化协同制造184
8.3.1产生背景184
8.3.2网络化协同制造业务框架184
8.3.3应用案例188
●8.4制造业分享经济190
8.4.1产生背景190
8.4.2制造业分享经济业务框架191
8.4.3应用案例194
参考文献197
第9章业务架构199
●9.1企业信息化发展阶段201
9.1.1部门级信息化应用阶段202
9.1.2企业级信息化应用阶段202
9.1.3基于网络的信息化应用阶段203
●9.2工业大数据创新业务模式206
9.2.1智能化生产应用206
9.2.2智能化设计应用207
9.2.3智能化营销208
9.2.4网络化应用209
9.2.5个性化应用209
9.2.6服务化应用210
9.2.7平台化应用212
9.2.8供应链优化应用214
●9.3工业大数据能力成熟度模型214
9.3.1工业大数据能力成熟度模型等级215
9.3.2工业大数据能力成熟度内容与要求216
●9.4工业大数据业务架构规划219
9.4.1工业大数据规划步骤220
9.4.2工业大数据业务架构221
参考文献226
第10章信息系统架构229
●10.1应用架构231
10.1.1应用架构的规划原则231
10.1.2工业大数据应用架构参考模型232
●10.2数据架构235
10.2.1元数据与主数据236
10.2.2数据生命周期与数据质量237
10.2.3数据架构规划239
10.2.4数据架构模型241
●10.3工业大数据信息系统架构的实现242
10.3.1制造企业信息系统分析242
10.3.2工业大数据的处理分析流程244
10.3.3工业大数据信息系统架构模型245
参考文献251
第11章信息技术架构253
●11.1工业云服务255
11.1.1工业云服务概念255
11.1.2工业云服务类型及典型服务255
●11.2大数据开源技术组件258
11.2.1数据采集阶段开源技术组件259
11.2.2数据存储阶段开源技术组件259
11.2.3数据计算阶段开源技术组件260
11.2.4数据分析与挖掘阶段开源技术组件261
11.2.5ETL阶段的开源技术组件262
11.2.6可视化阶段的开源技术组件263
●11.3工业大数据信息技术架构263
11.3.1数据层264
11.3.2数据采集层266
11.3.3数据存储层266
11.3.4计算层269
11.3.5应用层270
11.3.6展示层271
●11.4信息技术架构典型案例272
11.4.1行业级工业大数据整体信息技术架构案例272
11.4.2应用级工业大数据信息技术架构案例275
参考文献280
第12章工业大数据治理283
●12.1工业大数据治理框架284
12.1.1工业大数据治理原则285
12.1.2工业大数据治理范围286
12.1.3工业大数据治理的实施与评估289
●12.2工业大数据质量293
12.2.1数据质量的基本概念293
12.2.2工业大数据质量管理参考架构295
12.2.3工业大数据质量项目实施方法296
●12.3工业大数据安全298
12.3.1工业4.0世界中的威胁与挑战298
12.3.2工业大数据的安全目标和要求299
12.3.3典型的技术安全措施300
12.3.4实施方案303
参考文献306缩略语表307
名词索引313
图索引317
表索引323
案例索引325
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>工业大数据：架构与应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>未来架构师
第一篇  敢做不可能
我们5～10年后的未来生活将会被哪些脑洞大开的黑科技所改变？当那些看似神奇疯狂的想法再也不是科幻片中的想象，你还会说“未来已来”只是一句口号吗？
第1章  人机交互的新界面
即将到来的柔性世界
刘自鸿  柔宇科技创始人、CEO
增强现实，让我们玩转虚实世界
廖春元  亮风堂联合创始人、CEO
未来汽车，连接人与空间的新载体
段建军  北京梅赛德斯奔驰执行副总裁
脑机接口，意念操控不再是科幻
米格尔•尼科莱利斯  美国杜克大学教授，巴西世界杯“机械战甲”发明者，
《脑机接口》作者
第2章  让机器听懂、看懂、读懂你
智能语音，人机对话无障碍
胡  郁  科大讯飞执行总裁
机器视觉，让计算机更懂你
赵  勇  格灵深瞳创始人、CEO
未来我们可以有多懒
李志飞  出门问问创始人、CEO
第3章  你好，新物种
人工智能，是入侵？还是加持？
王小川  搜狗CEO
机器人，可以给你温暖的陪伴
周  剑  优必选创始人、CEO
第4章  无人，为更多人
刷脸支付+无人超市，开启购物新体验
漆  远  蚂蚁金服副总裁
共享经济，给予就是得到
毛大庆  优客工场创始人、CEO
跟踪、共享、万物互联的新世界
吴  军  计算机科学家、学者、投资人
第二篇  看见不可见
人之所以为人，我们在这个星球之所以能够以这样的方式不断延续发展着，是源于人类天生的好奇心和创造力。我们对自然规律的总结，对自身的认知，对人类社会发展史的研究，对科技的理解，对未知领域的探求……这些科学精神的光芒指引我们不断向前。
第5章  立足大地，仰望星空
太空探索永无止境
霍  金  著名物理学家
下一站，火星
郑永春  国家天文台对外传播中心主任、中国首位“卡尔•萨根奖”获得者
让我带你一同翱翔蓝天
蔡  俊  C919首飞机长
从陆地到深海，去探寻地球之谜
周怀阳  同济大学海洋与地球科学学院教授、中国首位搭乘“蛟龙号”下海的科学家
第6章  科学，那么近那么美
数学，是无远弗届的
丘成桐  国际数学大师、哈佛大学终身教授、美国科学院院士、清华大学丘成桐数学科学中心主任、中国科学院外籍院士
幸福，是探索未来的动力
彭凯平  清华大学社会科学学院院长、中国“积极心理学”第一人
用正确的打开方式，看见科学之光
吴  军  计算机科学家、学者、投资人
科学≠科技，科学是更深沉的力量
鲁  白  著名神经科学家，清华大学教授
科学与艺术，终将在山顶重逢
王国燕  中国科学技术大学科技传播系研究员、科学传播领域前沿工作者
第三篇  敢 未 来
每一个新奇的想法，每一项创新的发明，都是源自我们内心的执着——对历史的致敬、对人类的大爱。未来，从来都不是，从来不是茫然的征途，它是我们走过的路的延伸，它是一代又一代人对那一份“初心”的不懈追寻、它是执着开创的美好……
第7章  每个人都是未来架构师
“90后”的未来力：人机交互“新魔法”
张  洋  卡内基梅隆大学研究生，用一瓶喷雾让所有介质变成可触控的屏幕
“90后”的未来力：做有温度的高科技
肯尼思•篠塚  哈佛大学学生，发明防止阿尔兹海默症病人走失的监测器
“90后”的未来力：设计改变世界
范石钟  湖南大学研究生，“消防滑梯”和“新型消防车”等作品设计者，揽获全球120多项设计大奖
第8章  看得见多远的历史，就看得见多远的未来
倾尽半生只为梦回圆明园
郭黛姮  清华大学建筑学院教授
人类如何面对未来的挑战？
尤瓦尔•赫拉利  牛津大学历史学博士、《人类简史》《未来简史》作者
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>未来架构师
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Kafka权威指南
序 xiii
前言 xv
第 1 章　初识Kafka 1
1.1　发布与订阅消息系统 1
1.1.1　如何开始 2
1.1.2　独立的队列系统 3
1.2　Kafka登场 4
1.2.1　消息和批次 4
1.2.2　模式 4
1.2.3　主题和分区 5
1.2.4　生产者和消费者 5
1.2.5　broker和集群 6
1.2.6　多集群 7
1.3　为什么选择Kafka 8
1.3.1　多个生产者 8
1.3.2　多个消费者 8
1.3.3　基于磁盘的数据存储 9
1.3.4　伸缩性 9
1.3.5　高性能 9
1.4　数据生态系统 9
1.5　起源故事 11
1.5.1　LinkedIn的问题 11
1.5.2　Kafka的诞生 12
1.5.3　走向开源 12
1.5.4　命名 13
1.6　开始Kafka之旅 13
第 2 章　安装Kafka 14
2.1　要事先行 14
2.1.1　选择操作系统 14
2.1.2　安装Java 14
2.1.3　安装Zookeeper 15
2.2　安装Kafka Broker 17
2.3　broker配置 18
2.3.1　常规配置 18
2.3.2　主题的默认配置 19
2.4　硬件的选择 23
2.4.1　磁盘吞吐量 23
2.4.2　磁盘容量 23
2.4.3　内存 23
2.4.4　网络 24
2.4.5　CPU 24
2.5　云端的Kafka 24
2.6　Kafka集群 24
2.6.1　需要多少个broker 25
2.6.2　broker 配置 25
2.6.3　操作系统调优 26
2.7　生产环境的注意事项 28
2.7.1　垃圾回收器选项 28
2.7.2　数据中心布局 29
2.7.3　共享Zookeeper 29
2.8　总结 30
第 3 章　Kafka生产者——向Kafka写入数据 31
3.1　生产者概览 32
3.2　创建Kafka生产者 33
3.3　发送消息到Kafka 34
3.3.1　同步发送消息 35
3.3.2　异步发送消息 35
3.4　生产者的配置 36
3.5　序列化器 39
3.5.1　自定义序列化器 39
3.5.2　使用Avro序列化 41
3.5.3　在Kafka里使用Avro 42
3.6　分区 45
3.7　旧版的生产者API 46
3.8　总结 47
第 4 章　Kafka消费者——从Kafka读取数据 48
4.1　KafkaConsumer概念 48
4.1.1　消费者和消费者群组 48
4.1.2　消费者群组和分区再均衡 51
4.2　创建Kafka消费者 52
4.3　订阅主题 53
4.4　轮询 53
4.5　消费者的配置 55
4.6　提交和偏移量 57
4.6.1　自动提交 58
4.6.2　提交当前偏移量 59
4.6.3　异步提交 59
4.6.4　同步和异步组合提交 61
4.6.5　提交特定的偏移量 61
4.7　再均衡监听器 62
4.8　从特定偏移量处开始处理记录 64
4.9　如何退出 66
4.10　反序列化器 67
4.11　独立消费者——为什么以及怎样使用没有群组的消费者 71
4.12　旧版的消费者API 71
4.13　总结 72
第 5 章　深入Kafka 73
5.1　集群成员关系 73
5.2　控制器 74
5.3　复制 74
5.4　处理请求 76
5.4.1　生产请求 78
5.4.2　获取请求 78
5.4.3　其他请求 80
5.5　物理存储 81
5.5.1　分区分配 81
5.5.2　文件管理 82
5.5.3　文件格式 83
5.5.4　索引 84
5.5.5　清理 84
5.5.6　清理的工作原理 84
5.5.7　被删除的事件 86
5.5.8　何时会清理主题 86
5.9　总结 86
第 6 章　可靠的数据传递 87
6.1　可靠性保证 87
6.2　复制 88
6.3　broker配置 89
6.3.1　复制系数 89
6.3.2　不完全的首领选举 90
6.3.3　最少同步副本 91
6.4　在可靠的系统里使用生产者 92
6.4.1　发送确认 92
6.4.2　配置生产者的重试参数 93
6.4.3　额外的错误处理 94
6.5　在可靠的系统里使用消费者 94
6.5.1　消费者的可靠性配置 95
6.5.2　显式提交偏移量 95
6.6　验证系统可靠性 97
6.6.1　配置验证 98
6.6.2　应用程序验证 98
6.6.3　在生产环境监控可靠性 99
6.7　总结 100
第 7 章　构建数据管道 101
7.1　构建数据管道时需要考虑的问题 102
7.1.1　及时性 102
7.1.2　可靠性 102
7.1.3　高吞吐量和动态吞吐量 103
7.1.4　数据格式 103
7.1.5　转换 104
7.1.6　安全性 104
7.1.7　故障处理能力 104
7.1.8　耦合性和灵活性 105
7.2　如何在Connect API和客户端API之间作出选择 105
7.3　Kafka Connect 106
7.3.1　运行Connect 106
7.3.2　连接器示例——文件数据源和文件数据池 107
7.3.3　连接器示例——从MySQL到ElasticSearch 109
7.3.4　深入理解Connect 114
7.4　Connect之外的选择 116
7.4.1　用于其他数据存储的摄入框架 116
7.4.2　基于图形界面的ETL工具 117
7.4.3　流式处理框架 117
7.5　总结 117
第 8 章　跨集群数据镜像 118
8.1　跨集群镜像的使用场景 118
8.2　多集群架构 119
8.2.1　跨数据中心通信的一些现实情况 119
8.2.2　Hub和Spoke架构 120
8.2.3　双活架构 121
8.2.4　主备架构 123
8.2.5　延展集群 127
8.3　Kafka的MirrorMaker 128
8.3.1　如何配置 129
8.3.2　在生产环境部署MirrorMaker 130
8.3.3　MirrorMaker调优 132
8.4　其他跨集群镜像方案 134
8.4.1　优步的uReplicator 134
8.4.2　Confluent的Replicator 135
8.5　总结 135
第 9 章　管理Kafka 136
9.1　主题操作 136
9.1.1　创建主题 137
9.1.2　增加分区 138
9.1.3　删除主题 138
9.1.4　列出集群里的所有主题 139
9.1.5　列出主题详细信息 139
9.2　消费者群组 140
9.2.1　列出并描述群组 140
9.2.2　删除群组 142
9.2.3　偏移量管理 142
9.3　动态配置变更 143
9.3.1　覆盖主题的默认配置 143
9.3.2　覆盖客户端的默认配置 145
9.3.3　列出被覆盖的配置 145
9.3.4　移除被覆盖的配置 146
9.4　分区管理 146
9.4.1　首选的首领选举 146
9.4.2　修改分区副本 147
9.4.3　修改复制系数 150
9.4.4　转储日志片段 151
9.4.5　副本验证 152
9.5　消费和生产 153
9.5.1　控制台消费者 153
9.5.2　控制台生产者 155
9.6　客户端ACL 157
9.7　不安全的操作 157
9.7.1　移动集群控制器 157
9.7.2　取消分区重分配 157
9.7.3　移除待删除的主题 158
9.7.4　手动删除主题 158
9.8　总结 159
第 10 章　监控Kafka 160
10.1　度量指标基础 160
10.1.1　度量指标在哪里 160
10.1.2　内部或外部度量 161
10.1.3　应用程序健康检测 161
10.1.4　度量指标的覆盖面 161
10.2　broker的度量指标 162
10.2.1　非同步分区 162
10.2.2　broker度量指标 166
10.2.3　主题和分区的度量指标 173
10.2.4　Java虚拟机监控 174
10.2.5　操作系统监控 175
10.2.6　日志 176
10.3　客户端监控 177
10.3.1　生产者度量指标 177
10.3.2　消费者度量指标 179
10.3.3　配额 181
10.4　延时监控 182
10.5　端到端监控 183
10.6　总结 183
第 11 章　流式处理 184
11.1　什么是流式处理 185
11.2　流式处理的一些概念 186
11.2.1　时间 187
11.2.2　状态 188
11.2.3　流和表的二元性 188
11.2.4　时间窗口 189
11.3　流式处理的设计模式 190
11.3.1　单个事件处理 191
11.3.2　使用本地状态 191
11.3.3　多阶段处理和重分区 193
11.3.4　使用外部查找——流和表的连接 193
11.3.5　流与流的连接 195
11.3.6　乱序的事件 195
11.3.7　重新处理 196
11.4　Streams示例 197
11.4.1　字数统计 197
11.4.2　股票市场统计 199
11.4.3　填充点击事件流 201
11.5　Kafka Streams的架构概览 202
11.5.1　构建拓扑 202
11.5.2　对拓扑进行伸缩 203
11.5.3　从故障中存活下来 205
11.6　流式处理使用场景 205
11.7　如何选择流式处理框架 206
11.8　总结 208
附录A　在其他操作系统上安装Kafka 209
作者介绍 214
封面介绍 214
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Kafka权威指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>生产微服务
前言.  xii
第 1章　微服务简介.  1
从单体应用到微服务  1
微服务架构  7
微服务生态系统 9
第 1层：硬件层 10
第 2层：通信层 11
第 3层：应用平台层  13
第 4层：微服务层  15
组织的挑战  16
反康威定律 17
技术蔓延  18
更多失效的可能性  18
资源竞争  19
第 2章　生产就绪 21
微服务标准化的挑战 21
可用性：标准化的目标 22
生产就绪标准  23
稳定性  24
可靠性  24
伸缩性  25
容错和灾备 26
高性能  28
监控 28
文档化  29
实现生产就绪标准  31
第 3章　稳定性和可靠性.  33
微服务稳定性和可靠性的原则 33
开发周期 34
部署管道 36
staging  36
canary 40
生产 41
让稳定可靠的部署成为强制措施  41
服务依赖 42
路由和服务发现  44
服务和端点的解除  44
评估你的微服务  45
开发周期  45
部署管道  46
服务依赖  46
路由和服务发现 46
服务和端点的解除  46
第 4章　伸缩性和高性能.  47
关于微服务伸缩性和高性能的原则  47
了解增长规模  48
质的增长规模  48
量的增长规模  50
资源的有效利用  50
资源感知 51
资源需求  51
资源瓶颈  51
容量规划 52
依赖项的伸缩  53
流量管理 54
任务处理 55
编程语言的限制 55
高效地处理请求任务  56
可伸缩的数据存储  56
微服务生态系统的数据库选择  57
微服务架构在数据库方面面临的挑战. 57
评估你的微服务  58
增长规模  58
资源的有效利用 58
资源感知  58
容量规划  59
依赖项的伸缩  59
流量管理  59
任务处理  59
可伸缩的数据存储  59
第 5章　容错和灾备 61
用于构建具有容错能力微服务的原则  61
避免单点故障  62
故障场景 63
常见的生态系统故障  64
硬件故障  65
通信层和应用平台层的故障  66
依赖项故障 68
内部故障  69
弹性测试 70
代码测试  71
负载测试  72
混沌测试  74
故障检测和修复  75
事故和中断 76
处理事故的 5个步骤  78
评估你的微服务  80
避免故障点 80
故障场景  80
弹性测试  80
故障检测和修复 81
第 6章　监控 83
用于微服务监控的原则. 83
关键性度量指标  84
日志  86
仪表盘  87
告警  88
设置有效的告警 89
处理告警  89
轮班待命 90
评估你的微服务  91
关键性度量指标 91
日志 91
仪表盘  91
告警 91
轮班待命  92
第 7章　文档化和理解.  93
微服务文档和理解的原则  93
微服务文档  95
描述  96
架构图  96
轮班待命信息  97
链接 97
开发上手指南  97
请求消息流、端点和依赖项  98
运行手册  98
问答章节  99
理解微服务  99
架构评审  100
生产就绪审计  101
生产就绪路线图  101
生产就绪自动化  102
评估你的微服务  102
微服务文档 103
微服务理解 103
附录A　生产就绪检查列表 105
附录B　评估你的微服务 107
术语表 113
索引. 119
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>生产微服务
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>系统架构设计师考试考前冲刺预测卷及考点解析
第1章 系统架构设计师应试指南	1
1.1 考试目标	1
1.2 考试要求	1
1.3 考试形式	1
1.4 综合知识试卷	2
1.4.1 考核要求	2
1.4.2 真题特点综述	5
1.4.3 解题指南	7
1.4.4 专业英语解题思路	7
1.5 案例分析试卷	9
1.5.1 考核要求	9
1.5.2 真题特点综述	10
1.5.3 解题指南	12
1.6 论文试卷	14
1.6.1 考核要求	14
1.6.2 真题特点综述	15
1.6.3 论文评分标准	15
1.6.4 应试指南	16
1.7 备考思路的调整	20
第2章 考前冲刺预测卷1	25
.2.1 上午试卷	25
2.1.1 试题描述	25
2.1.2 要点解析	38
2.1.3 参考答案	50
2.2 下午试卷I	51
2.2.1 试题描述	51
2.2.2 要点解析	57
2.2.3 参考答案	68
2.3 下午试卷II	70
2.3.1 试题描述	71
2.3.2 写作要点	72
第3章 考前冲刺预测卷2	81
3.1 上午试卷	81
3.1.1 试题描述	81
3.1.2 要点解析	93
3.1.3 参考答案	107
3.2 下午试卷I	107
3.2.1 试题描述	107
3.2.2 要点解析	114
3.2.3 参考答案	121
3.3 下午试卷II	124
3.3.1 试题描述	125
3.3.2 写作要点	126
第4章 考前冲刺预测卷3	133
4.1 上午试卷	133
4.1.1 试题描述	133
4.1.2 要点解析	145
4.1.3 参考答案	161
4.2 下午试卷I	162
4.2.1 试题描述	162
4.2.2 要点解析	169
4.2.3 参考答案	178
4.3 下午试卷II	181
4.3.1 试题描述	182
4.3.2 写作要点	183
第5章 考前冲刺预测卷4	193
5.1 上午试卷	193
5.1.1 试题描述	193
5.1.2 要点解析	206
5.1.3 参考答案	219
5.2 下午试卷I	220
5.2.1 试题描述	220
5.2.2 要点解析	226
5.2.3 参考答案	238
5.3 下午试卷II	241
5.3.1 试题描述	241
5.3.2 写作要点	242
第6章 考前冲刺预测卷5	249
6.1 上午试卷	249
6.1.1 试题描述	249
6.1.2 要点解析	262
6.1.3 参考答案	277
6.2 下午试卷I	278
6.2.1 试题描述	278
6.2.2 要点解析	286
6.2.3 参考答案	293
6.3 下午试卷II	297
6.3.1 试题描述	297
6.3.2 写作要点	299
第7章 2009年下半年考试试卷及考点解析	305
7.1 上午试卷	305
7.1.1 试题描述	305
7.1.2 要点解析	316
7.1.3 参考答案	330
7.2 下午试卷I	330
7.2.1 试题描述	330
7.2.2 要点解析	335
7.2.3 参考答案	343
7.3 下午试卷II	347
7.3.1 试题描述	347
7.3.2 写作要点	349
附录A 案例主题分类索引	353
附录B 论文主题分类索引	355
附录C 答题卡及答题纸示例	357
C.1 上午试题答题卡示例	357
C.2 下午试卷Ⅰ答题纸示例	358
C.3 下午试卷Ⅱ答题纸示例	358
参考文献	359
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>系统架构设计师考试考前冲刺预测卷及考点解析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>系统架构设计师与系统分析师2009至2013年试题分析与解答
第1章 2009上半年系统分析师上午试题分析与解答
第2章 2009上半年系统分析师下午试卷I试题分析与解答
第3章 2009上半年系统分析师下午试卷II写作要点
第4章 2009下半年系统架构设计师上午试题分析与解答
第5章 2009下半年系统架构设计师下午试卷I试题分析与解答
第6章 2009下半年系统架构设计师下午试卷II写作要点
第7章 2010上半年系统分析师上午试题分析与解答
第8章 2010上半年系统分析师下午试卷I试题分析与解答
第9章 2010上半年系统分析师下午试卷II写作要点
第10章 2010下半年系统架构设计师上午试题分析与解答
第11章 2010下半年系统架构设计师下午试卷I试题分析与解答
第12章 2010下半年系统架构设计师下午试卷II写作要点
第13章 2011上半年系统分析师上午试题分析与解答
第14章 2011上半年系统分析师下午试卷I试题分析与解答
第15章 2011上半年系统分析师下午试卷II写作要点
第16章 2011下半年系统架构设计师上午试题分析与解答
第17章 2011下半年系统架构设计师下午试卷I试题分析与解答
第18章 2011下半年系统架构设计师下午试卷II写作要点
第19章 2012上半年系统分析师上午试题分析与解答
第20章 2012上半年系统分析师下午试卷I试题分析与解答
第21章 2012上半年系统分析师下午试卷II写作要点
第22章 2012下半年系统架构设计师上午试题分析与解答
第23章 2012下半年系统架构设计师下午试卷I试题分析与解答
第24章 2012下半年系统架构设计师下午试卷II写作要点
第25章 2013上半年系统分析师上午试题分析与解答
第26章 2013上半年系统分析师下午试卷I试题分析与解答
第27章 2013上半年系统分析师下午试卷II写作要点
第28章 2013下半年系统架构设计师上午试题分析与解答
第29章 2013下半年系统架构设计师下午试卷I试题分析与解答
第30章 2013下半年系统架构设计师下午试卷II写作要点
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>系统架构设计师与系统分析师2009至2013年试题分析与解答
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>信息架构设计
第一章  概述
第一节 关于信息架构
一、信息架构的出现
二、计算机中的信息架构
三、重要分水岭
第二节 信息架构的定义
一、信息架构的三要素
二、信息架构的两个主要因子
三、信息架构的五个内容
第三节 信息架构与导航
第四节 信息架构的设计流程
一、交互设计流程的步骤
二、信息架构的设计步骤
第五节 信息架构的意义和作用
一、信息架构的意义
二、信息架构的作用
第二章  用户研究
第一节 概述
一、用户研究的要点
二、用户研究的方法
三、分析数据的方法
四、用户考虑信息的行为
第二节 对产品/服务提供商的用户研究
一、亲和图
二、卡片分类
三、功能树
第三节 对产品和服务使用者的用户研究
一、角色
二、User Journey
三、场景
四、任务分析
五、案例
第四节信息架构设计网站实例
第三章 内容分析
第一节 什么是内容分析
第二节 内容分析的过程
第三节 内容规划
一、确定内容细节
二、为内容设置优先级
第四节 元数据与受控词表
一、专业术语
二、同义词环圈
三、规范文档
四、分类体系
五、叙词表
六、案例
第四章设计信息架构
第五章第一节  概念地图
第二节  选择分类方案
一、准确方案
二、模糊方案
第三节  选择Web信息架构
一、简单模式
二、混合模式
三、小结
第四节  设计概念结构
第五节  设计分类小组
第六节  设计标签
第七节  什么是好的IA
第五章  设计Web浏览结构和布局 99
第一节 设计过程
一、从内容页开始
二、考虑和内容页相连的页面
三、考虑主页
四、修订
第二节 选择导航类型
一、导航核心
二、其他导航
第三节 设计Web的浏览结构和布局
一、线框图
二、站点地图
三、任务流程图
第四节 高效的浏览结构特点
第五节 案例
第六章 设计移动端浏览结构和布局
第一节 移动设备交互原则
第二节 移动应用设计难点与要点
第三节 移动应用的使用方式
第四节 移动应用的信息组织方式
一、精确性组织体系
二、模糊性组织体系
第五节选择移动端信息架构
一、层级式
二、辐射式
三、套娃式
四、便签视图
五、便当盒及仪表盘
六、筛选视图
第六节 移动应用的导航模型
一、主要导航模式
二、次级导航模式
第七节 移动应用设计的其他部分
一、表格和列表
二、搜索
三、排序
四、筛选
第八节 绘制使用流程
一、故事板
二、OP图
第九节案例
一、项目简介
二、目的
三、步骤
第七章管理
第一节 基本概念
第二节 监控
一、监控的目的和内容
二、监控工具和谷歌分析
三、案例分析
第三节 内容更新
第四节 推广
第五节 优化
第六节 小结
参考文献
推荐阅读
后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>信息架构设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>局域网架构、管理、排困百事通
第1章 实战准备 认识局域网
1 典型的局域网结构
2 局域网的共享与交换
3 全双工与半双工方式
4 通信协议
本章小结
第2章 局域网的搭建
1 网线的制作
1.1 双绞线
1.2 同轴电缆
2 选择合适的网卡
2.1 网卡的类型与特点
2.2 网卡的安装
……
3 集线器与交换机的选择
……
第3章 局域网组建实例
……
第4章 从局域网到Internet
……
第5章 局域网提速技巧
……
第6章 局域网典型故障与排除方法
……
第7章 局域网服务器的安装与配置
……
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>局域网架构、管理、排困百事通
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>9)-重新架构一切-新材料
开篇语
1 材料与人类
人类历史的画卷――材料的发展史
现代文明社会的先导――新材料
材料、新材料和高技术新材料
2 材料的微观世界
材料内部质点的排列
晶体材料的微观世界
大晶体中有小晶体――多晶体
晶体的不同“角色”的变化――相变
晶体中的缺陷
非晶体的微观世界
3 古老而又新颖的金属材料
历史悠久的金属材料
奇妙的合金元素
魔术般的热处理工艺
“强度之最”的超高强度钢
什么是“超合金”
像塑料一样的金属“超塑性”
神奇的“形状记忆”合金
4 划时代的高分子材料
什么是高分子材料
曲折的发展历程
用途广泛的塑料
橡胶――汽车和飞机离不开的材料
琳琅满目的化学纤维
巧夺天工的功能高分子材料
5 异军突起的新型陶瓷
陶瓷概念的革命
发动机中的陶瓷
切削大王――陶瓷刀具
有没有高韧性陶瓷？
电光源领域的新秀
自动点火器中的压电陶瓷
电容器中的介电陶瓷
具有“知觉”的陶瓷
磁性陶瓷
6 信息技术的支柱――电子材料
信息技术与电子材料
集成电路的核心――半导体材料
集成电路的保护神――封装材料
千里眼与顺风耳――敏感元器件材料
电力电子技术的基石――磁性材料
八仙过海，各显神通――功能各异的其它电子材料
7 多彩多艺的薄膜材料
什么是薄膜材料
薄膜材料是如何制造的？
物理气相沉积制备薄膜材料
化学气相沉积制备薄膜材料
用途广泛的薄膜材料
神奇的超硬薄膜材料
海量存储的光记录薄膜材料
既透明又导电的ITO
无所不在的薄膜材料
8 未来的能源库――贮氢材料
氢能――一种新的“绿色”能源
会“呼吸”氢气的合金
新型贮氢合金
贮氢合金的妙用
一种新的“绿色”电池
9 造福未来的超导材料
惊人的发现――超导现象
超导奥秘的探索
在磁场作用下不同的两类超导材料
超导电性的微观奥秘
神奇的超导陶瓷
功力强大的超导磁体
飞起来的“火车”――磁浮列车
超导的约瑟夫逊效应及应用
超导材料家族的其它成员
10 信息时代的先导――光导纤维材料
光通信的神经――光导纤维
光导纤维的传光原理
光导纤维的光损耗
光导纤维的色散
通信光导纤维的制备
非氧化物玻璃光导纤维
能产生激光的光纤
光纤家族的其它成员
大有用武之地的光纤
11 “珠光宝气”的人工晶体材料
“宝石”与高新技术
人工晶体与激光
人工水晶与“电子战”
珍贵的钻石也可人工制造
现代军事装备离不开的光学晶体
未来能源与非线性光学晶体
为生活增色生辉的人造宝石
12 多功能的非晶态材料
由复印机说起
非晶态材料是如何制备的呢？
非晶态金属的特点和用途
非晶态半导体材料的特点及应用
非晶态材料在光盘中的应用
13 可流动的晶体液晶
什么是液晶
液晶的历史
液晶的种类
液晶特性与用途
14 奇妙的笼形碳
神秘传奇的身世
笼形碳的结构
笼形碳是如何获得的
丰富多变的形态
奇异诱人的性能
C60潜在的应用前景
15 未来的新材料纳米材料
沙漠中的异想天开
奇异的结构与性能
具有超塑性的陶瓷
强度韧性俱佳的纳米金属材料
可以隐形的纳米聚合物材料
功能齐全的纳米复合材料
纳诺技术――纳米材料的制备方法
广泛的应用前景
16 世人瞩目的环境材料
由白色污染说起
材料与环境
环境材料的诞生
环境材料的发展
环境材料的应用
环境材料的理论研究
结语
后记

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>9)-重新架构一切-新材料
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>WINDOWS NT通用网站架构实例
第1章 Windows NT人门

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>WINDOWS NT通用网站架构实例
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>PHP与SQL Server 2000 架构 Windows Web 数据库实务
第1章 安装前的准备
第2章 创建Web新家园
第3章 SQL Server 2000安装、服务及管理
第4章 创建SQL Server 2000家园
第5章 使PHP应用进入最佳状态
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>PHP与SQL Server 2000 架构 Windows Web 数据库实务
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>铁路信息系统架构
第一章 绪论
第一节 系统架构的概念及定义
第二节 铁路信息系统架构概述
第三节 铁路信息系统总体结构
复习思考题
第二章 铁路业务需求架构
第一节 铁路业务需求架构分析
第二节 业务需求建模方法
第三节 铁路客票发售与预订系统业务需求架构实例分析
复习思考题
第三章 铁路信息架构
第一节 铁路信息资源
第二节 铁路信息系统数据建模与数据分析
第三节 铁路信息资源集成与共享
第四节 分布式信息共享平台实例分析
复习思考题
第四章 铁路信息系统软件架构设计
第一节 软件架构
第二节 架构设计与基于架构的软件开发
第三节 软件架构的评估
复习思考题
第五章 铁路信息系统建模技术
第一节 问题分析与建模
第二节 结构化系统建模
第三节 面向对象系统建模
复习思考题
第六章 铁路信息系统设计模式
第一节 设计模式概述
第二节 设计模式及实现
第三节 铁路信息系统设计模式
复习思考题
第七章 铁路信息系统设计方法与技术
第一节 铁路信息系统设计方法概述
第二节 数据库系统设计
第三节 用户界面设计
第四节 信息系统可靠性与安全性设计
复习思考题
第八章 铁路信息系统架构设计案例
第一节 铁路智能运输系统体系框架设计
第二节 青藏铁路运营与安全综合监控系统架构设计
复习思考题
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>铁路信息系统架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>集成架构中型系统
前言
第1章罗克韦尔自动化集成架构中型系统的概述1
1.1集成架构中型系统的硬件基本组成2
1.2集成架构中型系统的应用开发软件9
第2章集成架构的EtherNet/IP网络11
2.1EtherNet/IP网络的基础知识11
2.1.1EtherNet/IP的模型和设备模式11
2.1.2数据包的传输模式和传输协议13
2.1.3网络组成和网络协议17
2.1.4EtherNet/IP网络上的连接25
2.1.5EtherNet/IP网络的拓扑结构31
2.2集成架构系统设备的IP地址设定33
2.2.1用BOOTPDHCP服务器设定设备的IP地址34
2.2.2用RSLinx Classic访问设备的组态36
2.2.3CompactLogix 5370控制器的IP地址设定39
2.2.4I/O适配器模块IP地址的设定43
2.2.5PowerFlex 525变频器的IP地址设定45
2.2.6Kinetix 5500运动控制模块的IP地址设定47
2.2.7PanelViewPlus 6人机界面的 IP地址设定50
2.2.8网络设备的IP地址设定51
2.3环网在集成架构中型系统中的运用54
2.3.1环网的设备54
2.3.2构建和组态环网58
2.3.3维护环网70
第3章CompactLogix 5370控制器79
3.1控制器硬件特性介绍79
3.1.1控制器面板状态指示灯80
3.1.2控制器位置开关及运行状态81
3.1.3控制器SD闪存卡83
3.1.4控制器对外通信接口85
3.1.5控制器的I/O模块87
3.1.6组的供电电源92
3.2控制器项目的组织结构92
3.2.1控制器项目的运行结构92
3.2.2控制器项目的数据结构96
3.3控制器项目的开发97
3.3.1控制器项目的离线创建97
3.3.2控制器项目的运行结构和数据标签的创建101
3.3.3控制器项目的在线操作110
3.4控制器I/O的组态和监视128
3.4.1控制器本地I/O模块的组态和监视129
3.4.2控制器远程I/O模块的组态和监视143
3.5控制器的通信162
3.5.1控制器之间的通信163
3.5.2控制器与非EtherNet/IP设备的通信169
3.6控制器系统固件更新172
3.6.1控制器固件更新172
3.6.2I/O模块固件更新179
第4章Stratix 5700管理型交换机的应用180
4.1Stratix 5700的硬件特性180
4.1.1Stratix 5700面板180
4.1.2Stratix 5700的启动初始化184
4.2Stratix 5700的软件特性187
4.3用设备管理Web对Stratix 5700组态199
4.3.1进入设备管理Web界面199
4.3.2Stratix 5700的组态203
4.3.3Stratix 5700的监视222
4.3.4Stratix 5700的维护227
4.4用Studio 5000软件对Stratix 5700组态231
4.4.1创建Stratix 5700模块232
4.4.2在线组态和监视Stratix 5700模块234
4.4.3使用RSLinx Classic软件249
第5章PowerFlex 525变频器的应用253
5.1PowerFlex 525变频器硬件功能254
5.1.1PowerFlex 525面板254
5.1.2变频器参数设置256
5.1.3使用PowerFlex4Class HIM访问参数257
5.1.4关于变频器参数的运用258
5.2在控制器项目中组态PowerFlex 525变频器262
5.2.1创建PowerFlex 525模块262
5.2.2在线组态和监视PowerFlex 525模块266
5.3在控制器中编程PowerFlex 525变频器293
5.3.1PowerFlex 525模块的I/O数据和编程293
5.3.2PowerFlex 525模块的显性数据和编程297
5.4多个PowerFlex 525变频器的应用301
5.4.1多变频器的模式301
5.4.2多变频器的组态和数据结构304
第6章Kinetix 5500驱动器系统的应用311
6.1Kinetix 5500伺服驱动系统的硬件组态311
6.2Kinetix 5500通信网络组态316
6.3Kinetix 5500驱动系统的设计和安装318
6.3.1Kinetix 5500驱动系统的设计准则318
6.3.2电子噪声的减少319
6.3.3Kinetix 5500驱动器的安装323
6.3.4Kinetix 5500的面板和控制信号325
6.3.5Kinetix 5500驱动系统的连接331
6.4启动Kinetix 5500驱动系统338
6.5与Kinetix 5500驱动器匹配的电动机342
6.6在控制器中组态和监视Kinetix 5500驱动器345
6.6.1在控制器项目中创建Kinetix 5500驱动器345
6.6.2Kinetix 5500驱动器的在线组态和监视351
6.7在控制器中组态运控组和运动轴属性355
6.7.1组态运控组355
6.7.2组态运动轴属性356
6.7.3Kinetix 5500驱动系统的运动轴测试和运动轴自整定371
6.7.4Kinetix 5500驱动器母线共享组的组态376
6.8Kinetix 5500驱动器的运控命令执行380
6.8.1使用运控命令执行动作380
6.8.2编程运控指令执行动作384
第7章PanelViewPlus 6人机界面的应用386
7.1使用FactoryTalk View Studio开发应用项目386
7.1.1创建一个应用项目386
7.1.2为应用项目创建操作员画面391
7.1.3应用项目的功能组态408
7.1.4应用项目系统组态421
7.1.5组合应用项目的操作员画面428
7.1.6测试下的操作员终端组态432
7.1.7应用项目的下载、上载和比较445
7.2操作员终端PanelView Plus6447
7.2.1操作员终端的启动448
7.2.2操作员终端的运行450
7.2.3操作员终端的组态453
7.3操作员终端的固件更新477
7.3.1下载固件文件478
7.3.2固件更新导向(FUW)和FUP的安装478
7.3.3操作员终端固件更新的操作过程480
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>集成架构中型系统
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算体系架构中的智能SOA平台
原书前言
第0章概述1
0.1分布式系统的演变1
0.2 yPBL:基于项目的学习方法4
0.3 yPBL需求驱动矩阵6
0.4 yPBL手册和方法数据模型7
0.5小结8
第1章ESBay案例研究9
1.1 ESBay:用例描述9
1.1.1系统概述9
1.1.2功能需求9
1.1.3其他需求11
1.2 yPBL初始阶段11
1.2.1功能需求11
1.2.2非功能性需求13
1.2.3需求矩阵14
1.3小结15
第2章面向服务和云计算架构16
2.1 SOA现状16
2.1.1通信中间件解决方案 16
2.1.2集成和互操作性的新方向 21
2.1.3中间件的解决方案 24
2.1.4SSOAPaaS 1.0手册29
2.2企业集成与事件驱动架构的演变29
2.2.1EDA模式30
2.2.2EDSOA 31
2.2.3SSOAPaaS 2.0手册32
2.3 SOA平台的性能与可伸缩性32
2.3.1ESB机制的可伸缩性和性能管理32
2.4 SOA平台的智能管理35
2.4.1云计算35
2.4.2自主计算37
2.4.3SSOAPaaS 3.0手册37
2.4.4SPaaS手册38
2.5小结38
第3章SPaaS 1.0手册41
3.1 SPaaS 1.0概述41
3.2创建虚拟化IT架构42
3.2.1创建Proxmox虚拟机43
3.2.2在VMWare虚拟机上安装Proxmox 46
3.2.3测试和浏览Proxmox的安装48
3.2.4创建Proxmox虚拟化组件49
3.2.5平台的维护54
3.3扩展平台55
3.3.1克隆平台55
3.3.2扩展Proxmox虚拟设备模板57
3.4管理平台58
3.4.1使用PVE Web-GUI监测Proxmox服务器和虚拟容器59
3.4.2使用Proxmox API监测Proxmox服务器和虚拟容器60
3.5伸缩平台63
3.5.1创建集群63
3.5.2虚拟化组件迁移65
3.6自动管理平台67
3.7小结68
第4章SSOAPaaS 1.0手册69
4.1 SSOAPaaS 1.0概述69
4.2 SPaaS 1.0的使用70
4.3添加集成性和互操作性支持70
4.3.1创建ESB虚拟容器71
4.3.2创建应用程序服务器虚拟容器75
4.3.3创建数据库服务器虚拟容器79
4.3.4创建电子邮件服务器虚拟容器81
4.3.5 OpenESB绑定组件管理85
4.3.6 OpenESB服务引擎管理87
4.3.7 Netbeans IDE / OpenESB连接安装89
4.4 ESB的集成性和交互性支持91
4.4.1集成应用程序服务器91
4.4.2在OpenESB中集成数据库服务器98
4.4.3在OpenESB中集成电子邮件服务器108
4.5小结116
第5章SSOAPaaS 2.0手册118
5.1 SSOAPaaS 2.0概述118
5.2 SSOAPaaS 1.0的使用119
5.3添加可用性支持120
5.3.1创建面向消息的中间件虚拟容器120
5.3.2可用性支持124
5.4添加主动性支持136
5.4.1复杂事件处理(CEP)引擎136
5.4.2主动性支持138
5.5小结145
第6章SSOAPaaS 3.0手册147
6.1 SSOAPaaS 3.0概述147
6.2 SSOAPaaS 2.0的使用148
6.3添加可管理性支持149
6.3.1建立监控虚拟容器149
6.3.2部署Jolokia代理并创建监控客户端150
6.4管理性支持152
6.4.1 Glassfish管理控制台监测152
6.4.2 JMX控制台监测156
6.5可伸缩性支持157
6.5.1 ESB实例集群157
6.5.2 ESB实例联盟162
6.6 SOA平台自主管理164
6.7小结165
第7章 总结与展望167
参考文献170
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算体系架构中的智能SOA平台
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业架构与IT战略规划设计教程
第1章 企业架构导论
1.1 什么是企业架构
1.2 为什么需要企业架构
1.3 企业架构理论
1.3.1 Zachman架构框架
1.3.2 TOGAF架构框架
1.3.3 FEA框架
1.3.4 DoDAF框架
1.4 总结
练习
第2章 业务架构
2.1 信息化与业务架构
2.2 企业业务模式
2.2.1 SWOT方法
2.2.2 PEST分析方法
2.2.3 波特五力模型方法
2.2.4 关键成功因素法
2.2.5 企业系统规划方法
2.2.6 竞争态势矩阵
2.3 业务架构迁移与信息化需求识别
2.3.1 企业的业务能力清单
2.3.2 企业的业务能力与信息化需求分析
2.4 企业组织变革
2.5 未来信息规划的关注点
2.6 总结
练习
第3章 数据架构
3.1 数据架构概述
3.1.1 什么是数据架构
3.1.2 数据架构的现状
3.1.3 数据环境分类
3.1.4 案例分析：商业银行企业的数据架构设计方案
3.2 数据分类
3.2.1 什么是数据分类
3.2.2 企业数据分类方法
3.2.3 企业数据分类规范
3.2.4 案例分析：某通信行业集团公司数据分类实例
3.3 数据分布
3.3.1 数据分布的策略
3.3.2 数据分布的两个原则
3.3.3 数据分布的应用
3.3.4 案例分析：淘宝公司数据库发展史
3.4 数据CRUD
3.4.1 什么是数据CRUD
3.4.2 数据CRUD与SQL
3.4.3 数据CRUD的意义
3.4.4 案例分析：某通信行业公司CRUD规范
3.5 数据模型
3.5.1 什么是数据模型
3.5.2 数据模型分类
3.5.3 企业数据模型
3.5.4 案例分析：某通信公司数据模型实例
3.5.5 常用数据建模工具
3.5.6 案例分析：使用Power Designer 15企业架构建模
3.6 数据管控
3.6.1 概念引入
3.6.2 企业数据管控环境
3.6.3 案例分析：我国银行业数据管控现状
3.7 总结
练习
第4章 应用架构
4.1 应用架构概念引入
4.2 应用架构风格
4.2.1 管道和过滤器架构风格
4.2.2 分层架构风格
4.2.3 面向构件架构风格
……
第5章 基础架构设计与优化
第6章 安全架构
第7章 架构迁移
第8章 需求管理
第9章 企业架构综合应用案例
课后练习参考答案
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业架构与IT战略规划设计教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大话代码架构
序言
前言
引言 1
一个架构师的例子 1
背景及人物介绍 3
我们的目标 3
第1篇 需求与三层架构
第1章 故事从一个电商网站开始 6
1.1 需求？需求！ 6
1.2 敏捷开发简介 8
1.3 UI——用户界面 9
1.3.1 从UE说起 9
1.3.2 HTML 5 & CSS 3 9
1.3.3 微信 10
1.4 数据库 10
1.4.1 PowerDesigner设计工具 11
1.4.2 关于SQL语句 12
第2章 为什么是三层 14
2.1 MOL带兄弟们去吃饭 14
2.2 动手写一个三层结构 16
2.2.1 DAL层的实现 17
2.2.2 BLL层的实现 18
2.2.3 UI层的实现 19
2.3 简说MVC 20
2.3.1 纠正一下老师的说法 20
2.3.2 MVC的第一个程序 21
2.3.3 为什么要用MVC之我见 25
2.4 向三层代码中加入面向对象 25
2.4.1 实例化数据库表 26
2.4.2 增加数据库操作类 29
2.4.3 加强版的数据库操作类 30
2.5 小说代码管理 33
2.5.1 什么是代码管理软件 34
2.5.2 TFS管理软件 36
2.5.3 SVN管理软件 40
2.5.4 Git管理软件 41
2.6 小结 51
第3章 ORM实体关系映射 52
3.1 说说OCP开放封闭原则 52
3.2 解耦第一步——接口要上位 53
3.2.1 代码结构的前提 53
3.2.2 创建接口层 56
3.3 解耦第二步——工厂模式解决new的问题 58
3.4 Spring.NET横空出世 61
3.4.1 酒文化发展史 61
3.4.2 神奇的IOC 62
3.4.3 引出Spring.NET 64
3.5 我不想写SQL语句 67
3.5.1 什么是ORM 68
3.5.2 ORM之iBATIS.NET 70
3.5.3 ORM之NHibernate 75
3.5.4 ORM之EF 86
3.5.5 懒人无敌 93
3.5.6 完成查询操作 106
3.5.7 数据库先行、模型先行、代码先行 109
3.6 小结 110
第2篇 NoSQL和测试
第4章 换个数据库试试 112
4.1 客户总有一些非分的想法 112
4.2 MongoDB简介 113
4.2.1 安装&配置 114
4.2.2 可视化工具 116
4.2.3 MongoDB的基本操作 119
4.3 .NET操作MongoDB 121
4.4 让NoSQL面向对象 123
4.4.1 实体抽象 124
4.4.2 操作抽象 132
4.5 NoSQL题外话 135
4.6 关于日志 136
4.6.1 为啥要写日志 136
4.6.2 如何写日志 138
4.6.3 注意事项 144
4.7 小结 145
第5章 越俎代庖搞搞测试 146
5.1 简单说测试 146
5.2 冒烟测试 147
5.3 黑盒测试 148
5.4 单元测试 149
5.4.1 单元测试是什么 150
5.4.2 如何进行单元测试 150
5.4.3 测试驱动开发 161
5.5 白盒测试 162
5.6 压力测试 163
5.7 其他测试 163
5.8 小结 163
第3篇 高精尖技术
第6章 神奇的缓存 166
6.1 网站崩溃了 166
6.2 缓存是什么 168
6.3 微软提供了缓存 170
6.4 自己做缓存 173
6.5 第三方缓存 176
6.5.1 MemCache缓存 178
6.5.2 Redis缓存 189
6.5.3 把缓存抽象出来 197
6.5.4 读写分离 198
6.6 利用模板引擎生成静态页面 198
6.6.1 初识NVelocity 200
6.6.2 使用NVelocity生成静态页面 207
6.6.3 静态页面带来的问题 211
6.7 CDN的加入会大大减少服务器的压力 212
6.8 小结 213
第7章 程序员眼中的前端 215
7.1 常见的前端框架 216
7.2 尝试EasyUI 220
7.2.1 基础框架 220
7.2.2 常用的控件 232
7.2.3 小说权限分配 247
7.3 其他的前端框架 264
7.3.1 Bootstrap框架 264
7.3.2 jQuery UI框架 265
7.4 小说HTML 5 265
7.5 小结 266
第8章 人生中的第一次高并发 267
8.1 网站又崩溃了！ 267
8.2 从相亲说起 268
8.3 简述消息队列 270
8.3.1 串行设计 270
8.3.2 多线程设计 271
8.3.3 消息队列设计 274
8.4 常见的消息队列 275
8.4.1 MSMQ消息队列 275
8.4.2 RabbitMQ消息队列 282
8.5 小结 288
第9章 微信公众号 289
9.1 李老板出场，请热烈鼓掌 289
9.2 初探微信公众号 290
9.2.1 申请订阅号 291
9.2.2 小机器人 294
9.2.3 把晋商卡挂到微信公众平台上 298
9.3 微信小程序 299
9.3.1 微信小程序是什么 299
9.3.2 写一个简单的Demo 300
9.4 微服务 310
9.5 MongoDB数据库 312
9.6 大数据 314
9.7 小结 316
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大话代码架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>系统架构设计师教程（第4版）
第1章  计算机组成与体系结构	1
1.1  计算机系统组成	1
1.1.1  计算机硬件的组成	1
1.1.2  计算机系统结构的分类	2
1.1.3  复杂指令集系统与精简指令集系统	3
1.1.4  总线	5
1.2  存储器系统	5
1.2.1  主存储器	6
1.2.2  辅助存储器	7
1.2.3  Cache存储器	8
1.3  流水线	13
1.3.1  流水线周期	13
1.3.2  计算流水线执行时间	13
1.3.3  流水线的吞吐率	14
1.3.4  流水线的加速比	14
第2章  操作系统	15
2.1  操作系统的类型与结构	15
2.1.1  操作系统的定义	15
2.1.2  操作系统分类	16
2.2  操作系统基本原理	16
2.2.1  进程管理	16
2.2.2  存储管理	23
2.2.3  设备管理	27
2.2.4  文件管理	28
2.2.5  作业管理	32
第3章  数据库系统	34
3.1  数据库管理系统的类型	34
3.2  数据库模式与范式	34
3.2.1  数据库的结构与模式	34
3.2.2  数据模型	37
3.2.3  关系代数	37
3.2.4  数据的规范化	40
3.2.5  反规范化	42
3.3  数据库设计	43
3.3.1  数据库设计的方法	43
3.3.2  数据库设计的基本步骤	45
3.3.3  需求分析	46
3.3.4  概念结构设计	47
3.3.5  逻辑结构设计	51
3.3.6  物理结构设计	56
3.4  事务管理	56
3.4.1  并发控制	57
3.4.2  故障与恢复	58
3.5  备份与恢复	60
3.6  分布式数据库系统	61
3.6.1  分布式数据库的概念	61
3.6.2  分布式数据库的架构	64
3.7  数据仓库	68
3.7.1  数据仓库的概念	69
3.7.2  数据仓库的结构	70
3.7.3  数据仓库的实现方法	72
3.8  数据挖掘	74
3.8.1  数据挖掘的概念	74
3.8.2  数据挖掘的功能	76
3.8.3  数据挖掘常用技术	76
3.8.4  数据挖掘的流程	78
3.9  NOSQL	79
3.10  大数据	81
第4章  计算机网络	83
4.1  网络架构与协议	83
4.1.1  网络互联模型	84
4.1.2  常见的网络协议	85
4.1.3  IPv6	87
4.2  局域网与广域网	89
4.2.1  局域网基础知识	89
4.2.2  无线局域网	91
4.2.3  广域网技术	93
4.2.4  网络接入技术	93
4.3  网络互连与常用设备	95
4.4  网络工程	97
4.4.1  网络规划	97
4.4.2  网络设计	99
4.4.3  网络实施	101
4.5  网络存储技术	102
4.6  综合布线	104
第5章  系统性能评价	106
5.1  性能指标	106
5.1.1  计算机	107
5.1.2  网络	109
5.1.3  操作系统	110
5.1.4  数据库管理系统	110
5.1.5  Web服务器	111
5.2  性能计算	111
5.3  性能设计	112
5.3.1  阿姆达尔解决方案	112
5.3.2  负载均衡	113
5.4  性能评估	116
5.4.1  基准测试程序	116
5.4.2  Web服务器的性能评估	117
5.4.3  系统监视	118
第6章  开发方法	120
6.1  软件生命周期	120
6.2  软件开发模型	121
6.2.1  瀑布模型	121
6.2.2  演化模型	124
6.2.3  螺旋模型	124
6.2.4  增量模型	125
6.2.5  构件组装模型	125
6.3  统一过程	126
6.4  敏捷方法	129
6.4.1  极限编程	129
6.4.2  特征驱动开发	133
6.4.3  Scrum	135
6.4.4  水晶方法	138
6.4.5  其他敏捷方法	139
6.5  软件重用	140
6.5.1  软件重用	140
6.5.2  构件技术	140
6.6  基于架构的软件设计	141
6.6.1  ABSD方法与生命周期	141
6.6.2  基于架构的软件开发模型	143
6.7  形式化方法	148
第7章  系统计划	150
7.1  项目的提出与选择	150
7.1.1  项目的立项目标和动机	150
7.1.2  项目的选择和确定	151
7.1.3  项目提出和选择的结果	154
7.2  可行性研究与效益分析	155
7.2.1  可行性研究的内容	156
7.2.2  成本效益分析	157
7.2.3  可行性分析报告	158
7.3  方案的制订和改进	159
7.4  新旧系统的分析和比较	161
7.4.1  遗留系统的评价方法	162
7.4.2  遗留系统的演化策略	165
第8章  系统分析与设计方法	167
8.1  定义问题与归结模型	167
8.1.1  问题分析	167
8.1.2  问题定义	170
8.2  需求分析与软件设计	172
8.2.1  需求分析的任务与过程	172
8.2.2  如何进行系统设计	174
8.2.3  软件设计的任务与活动	175
8.3  结构化分析与设计	176
8.3.1  结构化分析	176
8.3.2  结构化设计	180
8.3.3  模块设计	182
8.4  面向对象的分析与设计	184
8.4.1  面向对象的基本概念	184
8.4.2  面向对象分析	186
8.4.3  统一建模语言	188
8.5  用户界面设计	199
8.5.1  用户界面设计的原则	199
8.5.2  用户界面设计过程	200
8.6  工作流设计	200
8.6.1  工作流设计概述	201
8.6.2  工作流管理系统	202
8.7  简单分布式计算机应用系统的设计	203
8.8  系统运行环境的集成与设计	204
8.9  系统过渡计划	206
第9章  软件架构设计	208
9.1  软件架构概述	208
9.1.1  软件架构的定义	209
9.1.2  软件架构的重要性	210
9.1.3  架构的模型	211
9.2  架构需求与软件质量属性	213
9.2.1  软件质量属性	213
9.2.2  6个质量属性及实现	214
9.3  软件架构风格	221
9.3.1  软件架构风格分类	222
9.3.2  数据流风格	222
9.3.3  调用/返回风格	224
9.3.4  独立构件风格	226
9.3.5  虚拟机风格	227
9.3.6  仓库风格	228
9.4  层次系统架构风格	229
9.4.1  二层及三层C/S架构风格	229
9.4.2  B/S架构风格	230
9.4.3  MVC架构风格	231
9.4.4  MVP架构风格	233
9.5  面向服务的架构	234
9.5.1  SOA概述	234
9.5.2  SOA的关键技术	236
9.5.3  SOA的实现方法	238
9.5.4  微服务	241
9.6  架构设计	244
9.7  软件架构文档化	246
9.8  软件架构评估	250
9.8.1  软件架构评估的方法	250
9.8.2  架构的权衡分析法	250
9.8.3  成本效益分析法	252
9.9  构件及其复用	253
9.9.1  商用构件标准规范	253
9.9.2  应用系统簇与构件系统	255
9.9.3  基于复用开发的组织结构	255
9.10  产品线及系统演化	256
9.10.1  复用与产品线	256
9.10.2  基于产品线的架构	257
9.10.3  产品线的开发模型	258
9.10.4  特定领域软件架构	258
9.10.5  架构及系统演化	259
9.11  软件架构视图	260
9.11.1  软件视图的分类	260
9.11.2  模块视图类型及其风格	262
9.11.3  C&C视图类型及其风格	263
9.11.4  分配视图类型及其风格	265
9.11.5  各视图类型间的映射关系	267
第10章  设计模式	268
10.1  设计模式概述	268
10.1.1  设计模式的概念	268
10.1.2  设计模式的组成	269
10.1.3  GoF设计模式	269
10.1.4  其他设计模式	271
10.1.5  设计模式与软件架构	272
10.1.6  设计模式分类	272
10.2  设计模式及实现	273
10.2.1  Abstract Factory模式	273
10.2.2  Singleton模式	276
10.2.3  Decorator模式	277
10.2.4  Facade/Session Facade模式	279
10.2.5  Mediator模式	281
10.2.6  Observer模式	282
10.2.7  Intercepting Filter模式	284
10.3  设计模式总结	286
第11章  测试评审方法	288
11.1  测试方法	288
11.1.1  软件测试阶段	288
11.1.2  白盒测试和黑盒测试	290
11.1.3  缺陷的分类和级别	292
11.1.4  调试	293
11.2  评审方法	294
11.3  验证与确认	295
11.4  测试自动化	297
11.5  面向对象的测试	297
第12章  嵌入式系统设计	300
12.1  嵌入式系统概论	300
12.2  嵌入式系统的组成	301
12.2.1  硬件架构	301
12.2.2  软件架构	306
12.3  嵌入式开发平台与调试环境	307
12.3.1  嵌入式系统软件开发平台	307
12.3.2  嵌入式开发调试	309
12.4  嵌入式网络系统	312
12.4.1  现场总线网	312
12.4.2  家庭信息网	313
11.4.3  无线数据通信网	313
12.4.4  嵌入式Internet	314
12.5  嵌入式数据库管理系统	315
12.5.1  使用环境的特点	315
12.5.2  系统组成与关键技术	316
12.6  实时系统与嵌入式操作系统	319
12.6.1  嵌入式系统的实时概念	319
12.6.2  嵌入式操作系统概述	320
12.6.3  实时嵌入式操作系统	321
12.6.4  主流嵌入式操作系统介绍	324
12.7  嵌入式系统开发设计	325
12.7.1  嵌入式系统设计概述	325
12.7.2  开发模型与设计流程	327
12.7.3  嵌入式系统设计的核心技术	329
12.7.4  嵌入式开发设计环境	331
12.7.5  嵌入式软件设计模型	332
12.7.6  需求分析	335
12.7.7  系统设计	337
12.7.8  系统集成与测试	342
第13章  开发管理	344
13.1  项目的范围、时间与成本	344
13.1.1  项目范围管理	345
13.1.2  项目成本管理	345
13.1.3  项目时间管理	346
13.2  配置管理与文档管理	347
13.2.1  软件配置管理的概念	347
13.2.2  软件配置管理的解决方案	348
13.2.3  软件文档管理	351
13.3  软件需求管理	355
13.3.1  需求变更	355
13.3.2  需求跟踪	356
13.4  软件开发的质量与风险	356
13.4.1  软件质量管理	356
13.4.2  项目风险管理	359
13.5  人力资源管理	363
13.6  软件的运行与评价	368
13.7  软件过程改进	368
第14章  信息系统基础知识	371
14.1  信息系统概述	371
14.1.1  信息系统的组成	371
14.1.2  信息系统的生命周期	373
14.1.3  信息系统建设的原则	375
14.1.4  信息系统开发方法	376
14.2  信息系统工程	378
14.2.1  信息系统工程的概念	378
14.2.2  信息系统工程的内容	380
14.2.3  信息系统工程的总体规划	383
14.2.4  总体规划的方法论	389
14.3  政府信息化与电子政务	394
14.3.1  我国政府信息化的历程和策略	394
14.3.2  电子政务的内容	398
14.3.3  电子政务建设的过程模式和技术模式	399
14.4  企业信息化与电子商务	403
14.4.1  企业信息化概述	403
14.4.2  企业资源规划	406
14.4.3  客户关系管理	410
14.4.4  产品数据管理	413
14.4.5  企业门户	416
14.4.6  企业应用集成	418
14.4.7  供应链管理	421
14.4.8  电子商务概述	423
14.6  知识管理与商业智能	425
14.6.1  知识管理	425
14.6.2  商业智能	427
14.7  业务流程重组	427
第15章  基于中间件的开发	431
15.1  中间件技术	431
15.1.1  中间件的概念	432
15.1.2  中间件的分类	433
15.1.3  中间件产品介绍	434
15.2  应用服务器技术	435
15.2.1  应用服务器的概念	436
15.2.2  主要的应用服务器	438
15.3  J2EE	439
15.3.1  表示层	440
15.3.2  应用服务层	441
15.4  .NET	443
15.4.1  .NET平台	444
15.4.2  .NET框架	445
15.5  企业应用集成	450
15.6  轻量级架构和重量级架构	453
15.6.1  Struts框架	453
15.6.2  Spring框架	454
15.6.3  Hibernate框架	455
15.6.4  基于Struts、Spring和Hibernate的轻量级架构	456
15.6.5  轻量级架构和重量级架构的探讨	457
第16章  安全性和保密性设计	459
16.1  加密和解密	459
16.1.1  对称密钥加密算法	460
16.1.2  不对称密钥加密算法	461
16.2  数字签名与数字水印	463
16.2.1  数字签名	463
16.2.2  数字信封	465
16.3  数字证书与密钥管理	466
16.3.1  密钥分配中心	466
16.3.2  数字证书和公开密钥基础设施	467
16.4  安全协议	470
16.4.1  IPSec协议简述	471
16.4.2  SSL协议	474
16.4.3  PGP协议	477
16.5  计算机病毒与防治	480
16.5.1  计算机病毒概述	480
16.5.2  网络环境下的病毒发展新趋势	482
16.5.3  计算机病毒的检测与清除	483
16.5.4  计算机病毒的预防	485
16.6  身份认证与访问控制	486
16.6.1  身份认证技术	486
16.6.2  访问控制技术	492
16.7  网络安全体系	494
16.7.1  OSI安全架构	494
16.7.2  VPN在网络安全中的应用	496
16.8  系统的安全性设计	499
16.8.1  物理安全问题与设计	499
16.8.2  防火墙及其在系统安全中的应用	499
16.8.3  入侵检测系统	501
16.9  安全性规章	503
16.9.1  安全管理制度	503
16.9.2  计算机犯罪与相关法规	505
第17章  系统的可靠性分析与设计	508
17.1  可靠性概述	508
17.2  系统故障模型	509
17.2.1  故障的来源以及表现	509
17.2.2  几种常用的故障模型	510
17.3  系统配置方法	510
17.3.1  单机容错技术	511
17.3.2  双机热备份技术	511
17.3.3  服务器集群技术	512
17.4  系统可靠性模型	513
17.4.1  时间模型	513
17.4.2  故障植入模型	513
17.4.3  数据模型	514
17.5  系统的可靠性分析和可靠度计算	515
17.5.1  组合模型	515
17.5.2  马尔柯夫模型	517
17.6  提高系统可靠性的措施	519
17.6.1  硬件冗余	519
17.6.2  信息冗余	522
17.7  备份与恢复	523
第18章  软件的知识产权保护	525
18.1  著作权法及实施条例	525
18.1.1  著作权法客体	525
18.1.2  著作权法的主体	526
18.1.3  著作权	527
18.2  计算机软件保护条例	528
18.3  商标法及实施条例	529
18.4  专利法及实施细则	530
18.5  反不正当竞争法	532
第19章  标准化知识	534
19.1  标准化概论	534
19.2  标准分级与标准类型	534
19.2.1  标准分级	535
19.2.2  强制性标准与推荐性标准	536
第20章  应用数学	538
20.1  运筹方法	538
20.1.1  网络计划技术	538
20.1.2  线性规划	542
20.1.3  决策论	545
20.1.4  对策论	548
20.2  数学建模	549
第21章  虚拟化、云计算与物联网	551
21.1  虚拟化	551
21.1.1  虚拟化技术的分类	551
21.1.2  虚拟化的模式	553
21.2  云计算	554
21.2.1  云计算的特点	555
21.2.2  云计算的类型	556
21.2.3  云计算的应用	556
21.3  物联网	557
21.3.1  物联网的层次结构	558
21.3.2  物联网的相关领域与技术	559
21.3.3  物联网的应用	562
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>系统架构设计师教程（第4版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>疯狂Spring Cloud微服务架构实战
第1章　Spring Cloud概述	1
1.1　传统的应用	2
1.1.1　单体应用	2
1.1.2　架构演进	3
1.1.3　架构要求	4
1.2　微服务与Spring Cloud	5
1.2.1　什么是微服务	5
1.2.2　关于Netflix OSS	6
1.2.3　Spring Cloud与Netflix	6
1.2.4　Spring Cloud的主要模块	6
1.3　学习方面的准备工作	7
1.3.1　下载本书的软件及源码	7
1.3.2　导入本书的案例	7
1.4　本章小结	8
第2章　搭建开发环境	9
2.1　安装与配置Maven	10
2.1.1　关于Maven	10
2.1.2　下载与安装Maven	11
2.1.3　配置远程仓库	11
2.2　安装Eclipse	12
2.2.1　Eclipse版本	12
2.2.2　在Eclipse中配置Maven	12
2.3　Spring Boot	13
2.3.1　Spring Boot简介	13
2.3.2　新建Maven项目	14
2.3.3　编写启动类	15
2.3.4　编写控制器	16
2.3.5　发布REST WebService	17
2.4　Spring Boot配置文件	18
2.4.1　默认配置文件	18
2.4.2　指定配置文件位置	19
2.4.3　yml文件	19
2.4.4　运行时指定profiles配置	20
2.4.5　热部署	20
2.5　Spring Cloud的版本	21
2.6　本章小结	21
第3章　微服务发布与调用	22
3.1　Eureka介绍	23
3.1.1　关于Eureka	23
3.1.2　Eureka架构	23
3.1.3　服务器端	24
3.1.4　服务提供者	24
3.1.5　服务调用者	24
3.2　第一个Eureka应用	24
3.2.1　构建服务器	24
3.2.2　服务器注册开关	27
3.2.3　编写服务提供者	27
3.2.4　编写服务调用者	29
3.2.5　程序结构	32
3.3　Eureka集群搭建	33
3.3.1　本例集群结构图	33
3.3.2　改造服务器端	34
3.3.3　改造服务提供者	35
3.3.4　改造服务调用者	37
3.3.5　编写REST客户端进行测试	37
3.4　服务实例的健康自检	38
3.4.1　程序结构	39
3.4.2　使用Spring Boot Actuator	39
3.4.3　实现应用健康自检	39
3.4.4　服务查询	42
3.5　Eureka的常用配置	44
3.5.1　心跳检测配置	44
3.5.2　注册表抓取间隔	44
3.5.3　配置与使用元数据	45
3.5.4　自我保护模式	45
3.6　本章小结	46
第4章　负载均衡	47
4.1　Ribbon介绍	48
4.1.1　Ribbon简介	48
4.1.2　Ribbon子模块	48
4.1.3　负载均衡器组件	48
4.2　第一个Ribbon程序	49
4.2.1　编写服务	49
4.2.2　编写请求客户端	51
4.2.3　Ribbon的配置	52
4.3　Ribbon的负载均衡机制	53
4.3.1　负载均衡器	53
4.3.2　自定义负载规则	54
4.3.3　Ribbon自带的负载规则	56
4.3.4　Ping机制	57
4.3.5　自定义Ping	59
4.3.6　其他配置	59
4.4　在Spring Cloud中使用Ribbon	60
4.4.1　准备工作	60
4.4.2　使用代码配置Ribbon	61
4.4.3　使用配置文件设置Ribbon	63
4.4.4　Spring使用Ribbon的API	64
4.5　RestTemplate负载均衡	66
4.5.1　@LoadBalanced注解概述	66
4.5.2　编写自定义注解以及拦截器	66
4.5.3　使用自定义拦截器以及注解	68
4.5.4　在控制器中使用RestTemplate	69
4.6　本章小结	71
第5章　REST客户端Feign	72
5.1　REST客户端	73
5.1.1　使用CXF调用REST服务	73
5.1.2　使用Restlet调用REST服务	74
5.1.3　Feign框架介绍	75
5.1.4　第一个Feign程序	76
5.1.5　请求参数与返回对象	77
5.2　使用Feign	78
5.2.1　编码器	79
5.2.2　解码器	80
5.2.3　XML的编码与解码	80
5.2.4　自定义编码器与解码器	83
5.2.5　自定义Feign客户端	83
5.2.6　使用第三方注解	85
5.2.7　Feign解析第三方注解	86
5.2.8　请求拦截器	89
5.2.9　接口日志	89
5.3　在Spring Cloud中使用Feign	90
5.3.1　Spring Cloud整合Feign	91
5.3.2　Feign负载均衡	93
5.3.3　默认配置	93
5.3.4　自定义配置	94
5.3.5　可选配置	97
5.3.6　压缩配置	98
5.4　本章小结	98
第6章　Spring Cloud的保护机制	99
6.1　概述	100
6.1.1　实际问题	100
6.1.2　传统的解决方式	101
6.1.3　集群容错框架Hystrix	101
6.1.4　Hystrix的功能	102
6.2　第一个Hystrix程序	103
6.2.1　准备工作	103
6.2.2　客户端使用Hystrix	103
6.2.3　调用错误服务	105
6.2.4　Hystrix的运作流程	106
6.3　Hystrix的使用	108
6.3.1　命令执行	108
6.3.2　属性配置	110
6.3.3　回退	111
6.3.4　回退的模式	112
6.3.5　断路器开启	113
6.3.6　断路器关闭	116
6.3.7　隔离机制	118
6.3.8　合并请求	121
6.3.9　请求缓存	125
6.4　在Spring Cloud中使用Hystrix	127
6.4.1　整合Hystrix	128
6.4.2　命令配置	130
6.4.3　默认配置	131
6.4.4　缓存注解	132
6.4.5　合并请求注解	134
6.4.6　Feign与Hystrix整合	136
6.4.7　Hystrix监控	140
6.5　本章小结	142
第7章　微服务集群网关	143
7.1　Zuul框架介绍	144
7.1.1　关于Zuul	144
7.1.2　Zuul的功能	144
7.2　在Web项目中使用Zuul	145
7.2.1　Web项目整合Zuul	145
7.2.2　测试路由功能	145
7.2.3　过滤器运行机制	147
7.3　在微服务集群中初试Zuul	148
7.3.1　集群搭建	149
7.3.2　路由到集群服务	150
7.3.3　Zuul Http客户端	153
7.4　路由配置	153
7.4.1　简单路由	154
7.4.2　跳转路由	155
7.4.3　Ribbon路由	155
7.4.4　自定义路由规则	156
7.4.5　忽略路由	157
7.5　Zuul的其他配置	157
7.5.1　请求头配置	157
7.5.2　路由端点	158
7.5.3　Zuul与Hystrix	158
7.5.4　在Zuul中预加载Ribbon	161
7.6　Zuul功能进阶	161
7.6.1　过滤器优先级	161
7.6.2　自定义过滤器	162
7.6.3　动态加载过滤器	163
7.6.4　禁用过滤器	165
7.6.5　请求上下文	166
7.6.6　@EnableZuulServer注解	168
7.6.7　error过滤器	169
7.6.8　动态路由	171
7.7　本章小结	172
第8章　微服务与消息驱动	173
8.1　Spring Cloud Stream介绍	174
8.1.1　关于Stream框架	174
8.1.2　Stream框架的组成部分	174
8.1.3　消息代理中间件	174
8.2　RabbitMQ框架	175
8.2.1　RabbitMQ和AMQP	175
8.2.2　下载与运行	176
8.2.3　编写生产者	177
8.2.4　编写消费者	179
8.2.5　交换器、绑定与队列	180
8.3　Apache Kafka框架	181
8.3.1　关于Kafka	181
8.3.2　运行Kafka服务器	182
8.3.3　编写生产者	182
8.3.4　编写消费者	184
8.3.5　消费者组	185
8.4　开发消息微服务	185
8.4.1　准备工作	186
8.4.2　编写生产者	187
8.4.3　编写消费者	188
8.4.4　更换绑定器	189
8.4.5　Sink、Source与Processor	190
8.4.6　消费者组	191
8.5　本章小结	192
第9章　集群配置中心	193
9.1　概述	194
9.1.1　关于Spring Cloud Config	194
9.1.2　应用结构	195
9.1.3　引导程序简介	195
9.1.4　搭建SVN环境	196
9.2　构建第一个例子	196
9.2.1　创建服务器	196
9.2.2　配置SVN仓库	197
9.2.3　创建客户端	199
9.2.4　从客户端读取SVN配置	200
9.2.5　目录配置总结	201
9.2.6　刷新配置	202
9.2.7　刷新Bean	203
9.3　配置的加密和解密	205
9.3.1　为服务器安装JCE	205
9.3.2　加密和解密端点	205
9.3.3　SVN存储加密数据	206
9.3.4　非对称加密	207
9.4　其他配置	207
9.4.1　服务器健康指示器	207
9.4.2　客户端的错误提前与重试机制	208
9.4.3　安全配置	209
9.4.4　访问服务器配置	210
9.5　整合使用	210
9.5.1　准备工作	210
9.5.2　配置服务器、客户端整合Eureka	212
9.5.3　整合Zuul	214
9.5.4　整合Spring Cloud Bus刷新配置	216
9.5.5　刷新单个节点配置	217
9.6　本章小结	217
第10章　微服务跟踪	219
10.1　概述	220
10.1.1　实际问题与Sleuth	220
10.1.2　服务跟踪系统	220
10.1.3　Sleuth的基本概念	220
10.1.4　项目准备	221
10.2　Sleuth整合Zipkin	222
10.2.1　Zipkin简介	222
10.2.2　构建Zipkin服务器项目	223
10.2.3　配置微服务	224
10.2.4　查看数据	225
10.2.5　使用MySQL保存数据	228
10.2.6　使用消息采集数据	230
10.3　Sleuth整合ELK	232
10.3.1　关于ELK	232
10.3.2　下载ELK	233
10.3.3　运行Elasticsearch	233
10.3.4　使用Logstash读取JSON	234
10.3.5　使用Kibana展示数据	235
10.3.6　使用Logback转换JSON	237
10.4　本章小结	240
第11章　微服务数据库实战	241
11.1　概述	242
11.1.1　关于Spring Data	242
11.1.2　Spring Data的功能	243
11.1.3　Spring Data的模块	243
11.2　Spring Data与JPA	243
11.2.1　构建项目	244
11.2.2　数据访问层与业务层	245
11.2.3　自定义数据存储逻辑	247
11.2.4　方法名查询	248
11.2.5　使用@Query注解	249
11.3　Spring Data与MongoDB	250
11.3.1　安装MongoDB	250
11.3.2　配置权限	251
11.3.3　MongoDB的概念	252
11.3.4　构建项目	252
11.3.5　数据访问层与业务层	253
11.3.6　自定义数据存储逻辑	254
11.3.7　方法名查询	256
11.3.8　使用@Query注解	258
11.4　Spring Data与Redis	258
11.4.1　Redis的安装与配置	258
11.4.2　Redis的数据类型	259
11.4.3　使用Jedis	260
11.4.4　构建Spring Data项目	262
11.4.5　数据访问层与业务层	263
11.4.6　自定义数据存储逻辑	265
11.4.7　方法名查询	267
11.5　本章小结	268
第12章　案例实战	269
12.1　概述	270
12.1.1　表现层技术	270
12.1.2　案例概述	270
12.1.3　案例技术选型	270
12.2　Spring Boot与JSP	271
12.2.1　构建项目	271
12.2.2　配置	272
12.2.3　打包部署	273
12.3　模板引擎Thymeleaf	274
12.3.1　关于Thymeleaf	274
12.3.2　Spring Boot整合Thymeleaf	274
12.3.3　加载资源	275
12.3.4　获取请求数据	276
12.3.5　调用Bean方法	276
12.3.6　遍历集合	277
12.3.7　表单提交	277
12.4　图书管理案例	278
12.4.1　运行案例	278
12.4.2　案例模块	279
12.4.3　案例架构	279
12.4.4　数据库	280
12.4.5　用户登录	280
12.4.6　新建图书	284
12.4.7　图书展示	286
12.5　本章小结	287
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>疯狂Spring Cloud微服务架构实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>SOA架构
译者序
致谢
第1章　概述 1
1.1　本书中如何使用模式 2
1.2　涵盖第1版主题的系列书籍 2
1.3　本书的组织形式 3
1.4　原则、约束条件和设计模式 4
1.5　附加信息 5
第2章　案例研究背景知识 7
2.1　如何应用案例研究 7
2.2　案例研究背景1：Transit Line Systems, Inc. 7
2.3　案例研究背景2：Midwest University Association 7
第一部分　基本原理
第3章　理解面向服务 10
3.1　面向服务简介 10
3.1.1　业务自动化中的服务 11
3.1.2　服务是能力的集合 12
3.1.3　面向服务是一种设计范式 13
3.1.4　面向服务的设计原则 15
3.2　面向服务所解决的问题 16
3.2.1　竖井式应用架构 16
3.2.2　大量的浪费 18
3.2.3　缺乏效率 18
3.2.4　企业膨胀 19
3.2.5　产生复杂的基础设施和错综复杂的企业架构 19
3.2.6　系统间集成成为永恒的挑战 20
3.2.7　面向服务的需求 20
3.2.8　增加大量可复用解决方案逻辑 21
3.2.9　削减应用个性化业务逻辑 21
3.2.10　削减业务逻辑的总量 22
3.2.11　本征互操作性 22
3.3　面向服务对企业的影响 23
3.3.1　面向服务和“应用”的概念 23
3.3.2　面向服务和“集成”的概念 24
3.3.3　服务组合 25
3.4　面向服务计算的目的和优势 26
3.4.1　增强本征互操作性 27
3.4.2　增强联合 28
3.4.3　增加供应商多元化选择 29
3.4.4　同步提升业务与技术领域 30
3.4.5　提高投资回报率 31
3.4.6　提高组织的业务敏捷性 32
3.4.7　减少IT成本 34
3.5　面向服务的4个支撑点 34
3.5.1　团队合作 36
3.5.2　教育 36
3.5.3　纪律 36
3.5.4　平衡范围 37
第4章　理解面向服务架构 39
4.1　SOA的4个特性 40
4.1.1　业务驱动 40
4.1.2　供应商中立 41
4.1.3　企业中心化 42
4.1.4　组合中心化 44
4.1.5　设计优先级 45
4.2　SOA的4种常见类型 46
4.2.1　服务架构 47
4.2.2　服务组合架构 50
4.2.3　服务目录架构 55
4.2.4　面向服务的企业架构 58
4.3　面向服务和SOA的最终结果 58
4.4　SOA项目和生命周期 60
4.4.1　方法论和项目交付的策略 62
4.4.2　SOA项目阶段 62
4.4.3　SOA项目采用的计划 65
4.4.4　服务目录分析 65
4.4.5　面向服务分析　(服务建模) 66
4.4.6　面向服务设计(服务契约) 68
4.4.7　服务逻辑设计 69
4.4.8　服务开发 69
4.4.9　服务测试 69
4.4.10　服务部署和维护 71
4.4.11　服务使用和监控 71
4.4.12　服务发现 72
4.4.13　服务版本控制和退役 72
4.4.14　项目阶段和组织角色 72
第5章　理解服务与微服务的层次 74
5.1　服务层次简介 74
5.1.1　服务模型和服务层次 74
5.1.2　服务和候选服务能力 76
5.2　分解业务问题 76
5.2.1　功能分解 76
5.2.2　服务封装 76
5.2.3　不可知上下文 76
5.2.4　不可知能力 79
5.2.5　功能抽象 79
5.2.6　实体抽象 80
5.2.7　非不可知上下文 80
5.2.8　微任务抽象和微服务 81
5.2.9　流程抽象和任务服务 81
5.3　构建面向服务的解决方案 84
5.3.1　面向服务和服务组合 84
5.3.2　能力组合和能力再组合 84
5.3.3　逻辑集中与服务规范化 90
第二部分　面向服务的分析与设计
第6章　Web服务及微服务的分析与建模 94
6.1　Web服务建模过程 94
6.1.1　步骤1：分解业务流程（使之成为细粒度操作） 95
6.1.2　步骤2：过滤不适操作 98
6.1.3　步骤3：定义候选实体服务 99
6.1.4　步骤4：识别特定流程逻辑 101
6.1.5　步骤5：应用面向服务 102
6.1.6　步骤6：识别候选服务组合 102
6.1.7　步骤7：分析处理需求 103
6.1.8　步骤8：定义候选公共服务 104
6.1.9　步骤9：定义候选微服务 105
6.1.10　步骤10：应用面向服务 106
6.1.11　步骤11：修订候选服务组合 106
6.1.12　步骤12：修订候选能力分组 106
第7章　REST服务及微服务的分析与建模 107
7.1　REST服务建模过程 107
7.1.1　步骤1：分解业务流程（使之成为细粒度操作） 109
7.1.2　步骤2：滤掉不适操作 109
7.1.3　步骤3：定义候选实体服务 110
7.1.4　步骤4：识别特定流程逻辑 112
7.1.5　步骤5：识别资源 113
7.1.6　步骤6：将服务能力与资源和方法相关联 114
7.1.7　步骤7：应用面向服务 116
7.1.8　步骤8：识别候选服务组合 117
7.1.9　步骤9：分析处理需求 118
7.1.10　步骤10：定义候选公共服务（并且关联资源和方法） 119
7.1.11　步骤11：定义候选微服务(并且关联资源和方法) 121
7.1.12　步骤12：应用面向服务 121
7.1.13　步骤13：修订候选服务组合 121
7.1.14　步骤14：修改资源定义和候选能力分组 122
7.2　附加因素 123
7.2.1　统一契约建模和REST服务目录建模 123
7.2.2　REST约束条件和统一契约建模 125
7.2.3　REST服务能力粒度 125
7.2.4　资源与实体 126
第8章　Web服务的服务API与契约设计 128
8.1　服务模型设计关注点 129
8.1.1　实体服务设计 129
8.1.2　公共服务设计 130
8.1.3　微服务设计 131
8.1.4　任务服务设计 131
8.2　Web服务设计指南 140
8.2.1　应用命名标准 140
8.2.2　应用合适的服务契约API粒度 141
8.2.3　将Web服务的操作设计成原生可扩展的 143
8.2.4　考虑采用模块化WSDL文档 143
8.2.5　慎用命名空间 144
8.2.6　使用SOAP文档和Literal属性值 145
第9章　REST服务及微服务的服务API与契约设计 147
9.1　服务模型设计关注点 147
9.1.1　实体服务设计 148
9.1.2　公共服务设计 148
9.1.3　微服务设计 149
9.1.4　任务服务设计 150
9.2　REST服务设计指南 155
9.2.1　统一服务契约设计关注点 155
9.2.2　设计和标准化方法 155
9.2.3　设计和标准化HTTP报头 157
9.2.4　设计和标准化HTTP响应码 158
9.2.5　自定义响应码 160
9.2.6　设计媒介类型 162
9.2.7　设计媒介类型模式 163
9.2.8　复杂方法设计 164
9.2.9　无状态复杂方法 166
9.2.10　状态复杂方法 171
第10章　Web服务及REST服务的服务API与契约版本控制 176
10.1　版本控制的基本要素 176
10.1.1　Web服务版本控制 176
10.1.2　REST服务版本控制 177
10.1.3　粒度的精细与粗糙限制 177
10.2　版本控制和兼容性 178
10.2.1　后向兼容 178
10.2.2　前向兼容 180
10.2.3　兼容性变更 182
10.2.4　非兼容性变更 183
10.3　REST　服务兼容性关注点 184
10.4　版本标识符 186
10.5　版本控制策略 188
10.5.1　严格策略（新变更，新契约） 188
10.5.2　弹性策略（后向兼容） 189
10.5.3　松散策略（反向和前向兼容） 189
10.5.4　策略总结 190
10.6　REST服务版本控制关注点 190
第三部分　附录
附录A　面向服务原则参考 194
附录B　REST约束条件参考 199
附录C　SOA设计模式参考 203
附录D　注释版SOA声明 220
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>SOA架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Flux架构
前言 XIX
1 Flux是什么  1
Flux是一套模式 1
-- 数据入口  1
-- 状态管理  2
-- 保持同步更新  3
-- 信息架构  4
Flux并不是一个框架  4
Flux的设计思路问题解决方案 5
-- 数据流向  5
-- 可回溯性  7
-- 通知的一致性  8
-- 简捷的架构分层  9
-- 低耦合渲染 9
Flux组件  10
-- 动作  10
-- 分发器 11
-- 存储器 12
-- 视图  12
安装 Flux软件包 14
小结 16
2 Flux的原则  17
MV*所面临的挑战 17
-- 关注点分离  18
-- 级联更新  19
-- 模型更新的职责  20
单向数据  21
-- 从开始到结束 22
-- 无毒无害  23
显式优于隐式  23
-- 暗藏隐患的更新  24
-- 集中修改状态的地方 26
-- 太多动作？  26
分层优于嵌套  27
-- 多组件嵌套  27
-- 嵌套深度与副作用  28
-- 数据流和分层 28
应用数据和界面状态  29
-- 两个相同的东西  29
-- 强耦合转换  30
-- 功能中心化  31
小结 31
3 搭建骨架架构  32
总体组织  32
-- 目录结构  33
-- 依赖管理  33
信息设计  34
-- 用户不需要了解模型 34
-- 存储器映射用户看到的内容  35
-- 和哪些东西协同工作 36
在动作中注入存储器  36
-- 获取 API数据 36
-- 改变 API资源状态  42
-- 本地动作  47
存储器和功能域  50
-- 梳理顶层功能 50
-- 无关紧要的 API数据 51
-- 构造存储器数据  53
模拟视图  53
-- 找寻失去的数据  53
-- 定位动作  54
端到端场景 56
-- 动作清单  56
-- 存储器清单  56
-- 视图清单  57
小结 57
4 创建动作 58
动作的名称和常量 58
-- 动作命名约定 58
-- 静态动作数据 59
-- 组织动作常量 62
特性动作生成器  63
-- 什么时候需要模块化 63
-- 模块化架构  64
模拟数据  65
-- 模拟已存在的接口  65
-- 模拟新接口  66
-- 替换动作生成器  70
状态动作生成器  71
-- 整合其他系统 72
-- web socket连接 73
参数化动作生成器 76
-- 删除多余的动作  76
-- 保持动作的通用性  77
-- 创建衍生动作 80
小结 81
5 异步动作 83
保持 Flux同步  83
-- 为什么要同步 83
-- 压缩异步行为 84
-- 异步动作语义 85
创建 API调用  87
-- API是常见的情况  87
-- API调用和用户交互  88
结合 API调用  92
-- 复杂的动作生成器  93
-- 组合动作生成器  96
返回 promise  97
-- 不含 promise的同步  98
-- 组织异步行为 99
-- 错误处理 101
小结  103
6 改变 Flux存储器的状态 105
适应不断变化的信息 105
-- 变化的 API数据 105
-- 变化的功能  106
-- 受影响的组件  107
减少重复的存储器数据  107
-- 通用存储器数据 107
-- 注册通用存储器 108
-- 结合通用和专用数据  112
处理存储器的依赖关系  116
-- 等待存储器  116
-- 数据依赖 118
-- UI依赖 119
视图的更新顺序  125
-- 存储器的注册顺序  125
-- 视图渲染的优先级排序 125
处理存储器复杂度  126
-- 存储器太多  126
-- 反思功能域  126
小结  127
7 视图信息 128
传递视图数据 128
-- change事件中的数据  128
-- 视图决定何时渲染  132
保持视图无状态  135
-- UI状态属于存储器  135
-- 不用查询 DOM  135
视图的职责  136
-- 渲染存储器数据 136
-- 子视图结构  137
-- 用户交互 138
在 Flux中使用 ReactJS 138
-- 设置视图状态  139
-- 组成视图 143
-- 响应事件 146
-- 路由和动作  149
小结  154
8 信息的生命周期 155
组件生命周期难题  155
-- 回收不再使用的资源  156
-- 隐藏依赖 157
-- 内存泄漏 157
Flux结构是静态的  158
-- 单例模式 158
-- 与模型进行比较 161
-- 静态视图 161
扩展信息  165
-- 如何很好地扩展 165
-- 最小化所需信息 169
-- 扩展的动作  169
闲置的存储器 170
-- 删除存储器数据 170
-- 优化闲置的存储器  173
-- 保持存储器数据 174
小结  182
9 不可变的存储器 183
放弃隐藏的更新  183
-- 如何破坏 Flux架构  184
-- 获取存储器数据 186
-- 一切皆不可变  187
强制执行单向数据流 187
-- 纵横交错的单向数据流 188
-- 过多的存储器？ 189
-- 没有足够的动作 189
-- 强制不可变性  190
不可变数据的成本  195
-- 垃圾回收是昂贵的  196
-- 批量转换 196
-- 抵消成本 197
使用 Immutable.js 197
-- 不可变列表和映射  198
-- 不可变的转换  201
-- 变化检测 204
小结  208
10 实现分发器209
抽象分发器接口  209
-- 存储器的注册地 209
-- 分发负载 210
-- 依赖关系的处理 211
分发器所面临的挑战 212
-- 教育的目的  212
-- 单例模式的分发器  212
-- 手动注册存储器 213
-- 容易出错的依赖管理  213
构建分发器模块  214
-- 封装存储器的引用  214
-- 处理依赖 215
-- 分发动作 217
优化存储器的注册  220
-- 基础存储器类  221
-- 一个动作方法  222
小结  226
11 可替代的视图组件 227
ReactJS是适合 Flux的 227
-- ReactJS是单向的  227
-- 重新渲染数据很简单  229
-- 短小精悍的代码 229
ReactJS的缺点  230
-- 虚拟 DOM和内存 230
-- JSX和标记语言  231
-- 库锁定  232
使用 jQuery和 Handlebars  232
-- 为什么是 jQuery和 Handlebars  232
-- 渲染模板 233
-- 组合视图 236
-- 事件处理 238
使用 VanillaJS 244
-- 对可选择性保持开放  244
-- 迁移到 React 244
-- 新的技术热点  245
小结  245
12 使用 Flux库 247
实现核心 Flux组件 247
-- 自定义分发器  247
-- 实现一个基本的存储器 248
-- 创建动作 248
实现中遇到的痛点  249
-- 分发异步动作  249
-- 划分存储器  249
使用 Alt  250
-- 核心理念 250
-- 创建存储器  251
-- 声明动作生成器 253
-- 监听状态变化  254
-- 视图渲染以及分发动作 255
使用 Redux  258
-- 核心思想 258
-- 状态转换器和存储器  259
-- Redux动作 262
-- 渲染组件和分发动作  264
小结  269
13 测试和性能270
你好，Jest 270
测试动作生成器  272
-- 同步函数 273
-- 异步函数 274
测试存储器  277
-- 测试存储器监听器  277
-- 测试初始状态  280
性能目标  283
-- 用户感知的性能 283
-- 测量的性能  284
-- 性能需求 284
分析工具  285
-- 异步动作 285
-- 存储器内存  285
-- CPU占用  286
基准测试工具 286
-- 代码的基准测试 286
-- 状态转换 287
小结  290
14 Flux和软件开发的生命周期 291
Flux的开放性解释  291
-- 实现选项一：只是模式 292
-- 实现选项二：使用 Flux库  292
-- 实现并使用自己的 Flux 292
开发方法论  293
-- 在 Flux初期要考虑的事情  293
-- 成熟的 Flux应用  294
从 Flux中获得的启示  294
-- 单向数据流  295
-- 信息设计为王  295
打包 Flux组件  295
-- 完整独立的 Flux 296
-- 可安装的软件包 296
-- 可安装的 Flux组件  296
小结  304
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Flux架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>游戏服务器架构与优化
前　言
第一部分　网络和服务器
第1章　Python网络编程模块 2
1.1　Python Socket 3
1.1.1　Socket套接字 3
1.1.2　SOCK_STREAM、SOCK_DGRAM 4
1.1.3　阻塞和非阻塞模式 5
1.2　服务器端其他Socket方法 7
1.2.1　bind和listen 7
1.2.2　setsockopt 8
1.3　客户端Socket 10
1.4　通用的Socket方法 12
1.4.1　recv和send 12
1.4.2　recvfrom和sendto 13
1.5　SimpleHTTPServer和BaseHTTPServer 14
1.5.1　SimpleHTTPServer 15
1.5.2　BaseHTTPServer 15
1.6　urllib和urllib2 17
1.6.1　urllib.urlopen和urllib2.urlopen 18
1.6.2　urllib2中的GET和POST方法 19
1.7　事件驱动框架Twisted 20
1.7.1　Reactor模式 21
1.7.2　run、stop和callLater 23
1.7.3　Transports、Protocols、Protocol Factoies以及Deferred 24
第2章　通信加密 26
2.1　软件、通信加密的几种常用方案 27
2.1.1　异或位运算加密 27
2.1.2　其他对称加密 29
2.1.3　非对称加密 30
2.2　OpenSSL 33
2.2.1　生成证书 35
2.2.2　公钥和私钥的配置 40
2.3　SSL/TLS通信 43
2.3.1　SSL/TLS连接 45
2.3.2　SSL/TLS HTTPS通信 46
2.4　其他加密方式 49
2.4.1　散列算法 49
2.4.2　BASE64 52
2.4.3　多国语言 53
第3章　服务器实作 55
3.1　构建Python Websocket服务器 55
3.1.1　Websocket的应用场景 57
3.1.2　实作Websocket握手协议 59
3.1.3　MAGIC_STRING在Websocket中的作用 60
3.1.4　Websocket 启动 62
3.1.5　Websocket消息拆分和读取 63
3.2　多线程服务器 64
3.2.1　Python的多线程模式 65
3.2.2　锁 68
3.2.3　Python GIL 70
3.2.4　multiprocess的解决思路 72
3.2.5　给Websocket加上多线程 73
3.3　线程池 75
3.3.1　默认线程池和进程池 75
3.3.2　协程 76
3.3.3　第三方库 78
3.3.4　gevent的数据结构 85
第二部分　存储与数据库
第4章　基础内容存储 94
4.1　数据库存储的种类 95
4.2　SQL与NoSQL 96
4.2.1　SQL 96
4.2.2　SQL语句语法 97
4.2.3　NoSQL 101
4.2.4　NoSQL语句语法 106
4.3　内存与IO读写速度 108
4.4　同步内存数据 109
4.4.1　Redis数据库的持久性 111
4.4.2　Redis主从数据库复制 112
4.5　数据备份和恢复 113
4.5.1　备份的类型 114
4.5.2　使用Python编写备份代码 115
4.6　不可或缺的SQLite 117
第5章　存储方案 121
5.1　高并发服务器的存储方案 121
5.1.1　网站高并发服务器的策略 122
5.1.2　数据库的锁 125
5.2　高速缓存 127
5.2.1　Memcached 127
5.2.2　大文件缓存 129
5.2.3　分布式和集群 130
5.3　二进制存储方案 132
5.3.1　磁盘IO和缓存 133
5.3.2　图片和影音文件 134
5.4　大规模计算 135
5.4.1　图片服务器的架构 136
5.4.2　读取和写入文本 137
5.4.3　文本搜索方案 138
5.5　区块链技术 139
第三部分　服务器架构及其方案
第6章　游戏服务器初探 144
6.1　服务器消息和轮询 144
6.1.1　卡牌游戏和弱连接 145
6.1.2　消息的轮询 147
6.2　游戏服务器架构演变 149
6.2.1　“上古时代”的游戏服务器 149
6.2.2　近代的网络游戏服务器 153
6.2.3　近现代经典游戏服务器模型 155
6.3　地图的无缝连接 157
6.3.1　无缝连接的分析 158
6.3.2　无缝地图更深层次的问题 160
第7章　游戏服务器的交互 165
7.1　无状态和有状态的服务器设计方案 165
7.1.1　无状态的服务器设计方案 166
7.1.2　有状态的服务器设计方案 167
7.2　轮询 169
7.3　集群方案 171
7.3.1　集群的几种方式 171
7.3.2　集群的方案 172
7.3.3　数据库方案 173
7.3.4　Web服务和数据库 174
7.3.5　其他方案 176
7.4　定时任务 178
第8章　游戏大厅 181
8.1　大厅登录流程 181
8.1.1　登录和选择游戏区 182
8.1.2　注册和登录 183
8.2　中间件 185
8.2.1　中间件的相关概念 186
8.2.2　ElasticSearch 191
8.2.3　在Python中使用ES 193
8.3　聊天服务 195
8.3.1　聊天服务器的搭建 195
8.3.2　聊天内容的获取和分发 196
8.4　大厅与游戏的对接 198
8.4.1　创建房间 198
8.4.2　与游戏的对接 199
第9章　实时交互服务器 202
9.1　长连接和强交互 202
9.1.1　TCP连接 203
9.1.2　多线程 205
9.1.3　异步控制 206
9.1.4　加入队列 207
9.2　使用UDP的方案 210
9.2.1　什么是UDP协议 210
9.2.2　TCP协议和UDP协议的区别 212
9.2.3　使用Python编写UDP服务 214
9.2.4　加入多线程 216
9.3　协议包的设计和实现 218
9.3.1　协议包头和包身 219
9.3.2　协议包完整性 221
9.3.3　协议的加密和压缩 222
9.3.4　协议包混淆 223
9.4　断线重连 224
第10章　天梯和经济系统 227
10.1　什么是天梯 227
10.1.1　天梯的框架 229
10.1.2　数据载入 230
10.2　天梯层级 231
10.3　经济系统 234
10.3.1　经济系统简介 234
10.3.2　经济系统的设计 235
10.3.3　通货膨胀 236
10.4　预留接口和热更新 238
10.4.1　如何预留接口 238
10.4.2　代码热更新 241
第11章　服务器承载量和客户端优化方案 243
11.1　心跳服务 243
11.1.1　应用层的心跳服务 245
11.1.2　心跳包协议 246
11.2　同步校验 247
11.2.1　服务器数据包同步 248
11.2.2　游戏世界的同步 248
11.3　服务器承载 251
11.3.1　Python的多线程并发 251
11.3.2　混合C/C++之一 253
11.3.3　混合C/C++之二 257
11.4　守护者进程 266
11.4.1　Windows下的守护者进程 266
11.4.2　监控和重启进程 268
11.5　客户端优化方案 270
11.5.1　优化解决方案 270
11.5.2　游戏引擎 271
第12章　分布式服务器 273
12.1　什么是分布式系统 273
12.1.1　分布式文件系统 275
12.1.2　分布式服务 277
12.1.3　Python实现 278
12.2　流式处理 280
12.2.1　Storm 280
12.2.2　Spark 284
12.2.3　Samza 288
12.2.4　Flink 290
12.2.5　Trident 293
12.3　Python分布式框架 294
附录A　不同语言之间的区别 297
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>游戏服务器架构与优化
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>全球自贸架构与中国战略选择
目录导语上篇 全球主要自贸架构多边体系：全球贸易体系碎片化第一节 世界经济艰难复苏深刻影响全球贸易世界贸易组织多哈回合谈判陷入僵局聚焦早期收获，世贸取得新进展双边及区域贸易协定快速推进亚太体系：美国主导《跨太平洋伙伴关系协定》《跨太平洋伙伴关系协定》（TPP）的由来美国为何把TPP作为战略突破口TPP谈判的主要内容及美国的目标TPP谈判困难重重日韩与TPP美国以TPP为战略抓手的缺陷西方体系：美欧联手组建《跨大西洋贸易与投资协定》《跨大西洋贸易与投资协定》（TTIP）的发起和原因美欧各自的谈判立场和谈判内容谈判进展情况美欧协调有难处谈判的前景评估和影响下篇 中国的战略选择与周边国家构建自贸协定中国东盟自由贸易区带动亚太区域整合第二节  倡议开展中国东盟自贸区“升级版”谈判第三节  启动《区域贸易伙伴关系协定》（RCEP）谈判第四节  稳步推进中日韩自贸区建设第五节  着力打造亚太自贸区（FTAAP）与欧美的贸易和投资协定谈判中冰、中瑞自贸协定正式签署并实施中欧双边投资协定积极谈判中中美双边投资协定谈判取得实质性突破中国申请加入TISA谈判设立上海自贸区作为深化内外改革的试验场提出“丝绸之路经济带”和“海上丝绸之路”倡议第一节  借“经济带”加速推进上合组织的经济一体化进程重启中国海合会自贸区谈判经略南亚第四节  筹建亚洲基础设施银行附录 附录一：欧盟提议在WTO框架内开展《服务贸易协定》诸边谈判附录二：《关于深化互利共赢的中欧全面战略伙伴关系的联合声明》附录三：《中国与东盟全面经济合作框架协议》附录四：中国东盟自贸区建设进程回顾附录五：《上海合作组织成员国多边经贸合作纲要》附录六：中国智利自贸协定简介附录七：中国新西兰自贸协定概述附录八：中国新加坡自贸协定概述附录九：中国秘鲁签署自贸协定附录十：中国哥斯达黎加签署自贸协定附录十一：中国（上海）自由贸易试验区外商投资准入特别管理措施（负面清单）（2014年修订）缩略语 参考文献后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>全球自贸架构与中国战略选择
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud 微服务架构开发实战
内容简介
前言
第1章 微服务概述
1.1 传统软件行业面临的挑战
1.2 常见分布式系统架构
1.3 单块架构如何进化为微服务架构
1.4 微服务架构的设计原则
1.5 如何来设计微服务系统
第2章 微服务的基石——Spring Boot
2.1 Spring Boot 简介
2.2 开启第一个 Spring Boot 项目
2.3 Hello World
2.4 如何搭建开发环境
2.5 Gradle 与 Maven 的抉择
第3章 Spring Boot 的高级主题
3.1 构建 RESTful 服务
3.2 Spring Boot 的配置详解
3.3 内嵌 Servlet 容器
3.4 实现安全机制
3.5 允许跨域访问
3.6 消息通信
3.7 数据持久化
3.8 实现热插拔（hot swapping）
第4章 微服务的测试
4.1 测试概述
4.2 测试的类型和范围
4.3 如何进行微服务的测试
第5章 微服务的协调者——Spring Cloud
5.1 Spring Cloud 简介
5.2 Spring Cloud 入门配置
5.3 Spring Cloud 的子项目介绍
第6章 服务拆分与业务建模
6.1 从一个天气预报系统讲起
6.2 使用Redis提升应用的并发访问能力
6.3 实现天气数据的同步
6.4 给天气预报一个“面子”
6.5 如何进行微服务的拆分
6.6 领域驱动设计与业务建模
第7章 天气预报系统的微服务架构设计与实现
7.1 天气预报系统的架构设计
7.2 天气数据采集微服务的实现
7.3 天气数据API微服务的实现
7.4 天气预报微服务的实现
7.5 城市数据API微服务的实现
第8章 微服务的注册与发现
8.1 服务发现的意义
8.2 如何集成 Eureka Server
8.3 如何集成 Eureka Client
8.4 实现服务的注册与发现
第9章 微服务的消费
9.1 微服务的消费模式
9.2 常见微服务的消费者
9.3 使用 Feign 实现服务的消费者
9.4 实现服务的负载均衡及高可用
第10章 API 网关
10.1 API 网关的意义
10.2 常见 API 网关的实现方式
10.3 如何集成Zuul
10.4 实现 API 网关
第11章 微服务的部署与发布
11.1 部署微服务将面临的挑战
11.2 持续交付与持续部署微服务
11.3 基于容器的部署与发布微服务
11.4 使用 Docker 来构建、运行、发布微服务
第12章 微服务的日志与监控
12.1 微服务日志管理将面临的挑战
12.2 日志集中化的意义
12.3 常见日志集中化的实现方式
12.4 Elastic Stack 实现日志集中化
第13章 微服务的集中化配置
13.1 为什么需要集中化配置
13.2 使用 Config 实现的配置中心
第14章 微服务的高级主题——自动扩展
14.1 什么是自动扩展
14.2 自动扩展的意义
14.3 自动扩展的常见模式
14.4 如何实现微服务的自动扩展
第15章 微服务的高级主题——熔断机制
15.1 什么是服务的熔断机制
15.2 熔断的意义
15.3 熔断与降级的区别
15.4 如何集成 Hystrix
15.5 实现微服务的熔断机制
第16章 微服务的高级主题——分布式消息总线
16.1 什么是消息总线
16.2 Spring Cloud Bus 设计原理
16.3 如何集成 Bus
16.4 实现配置信息的自动更新
附录A：本书所涉及到的技术及相关版本
参考资料
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud 微服务架构开发实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务架构基础:Spring Boot+Spring Cloud+Docker
第1章认识微服务架构1
1.1 为什么需要微服务架构 2
1.1.1 传统单体应用架构的问题 2
1.1.2 如何解决传统应用架构的问题 3
1.2 微服务架构是什么 4
1.2.1 微服务架构的概念 4
1.2.2 微服务架构的优点 5
1.2.3 微服务架构的不足 6
1.2.4 微服务架构与SOA的区别 6
1.3 如何构建微服务架构 6
1.3.1 微服务的拆分 7
1.3.2 微服务架构的组件 7
1.3.3 微服务架构的搭建 7
1.3.4 微服务架构的技术选型 8
1.4 本章小结 10
第2章 初识Spring Boot 11
2.1 Spring Boot介绍 12
2.1.1 Spring Boot的由来和特点 12
2.1.2 Spring Boot的使用要求 12
2.2 Spring Boot入门 13
2.2.1 Spring Boot项目的快速搭建 13
2.2.2 第一个Spring Boot程序 18
2.3 Spring Boot的工作机制 20
2.3.1 @Spring BootApplication 20
2.3.2 Spring Application 21
2.4 本章小结 22
第3章 Spring Boot应用开发 23
3.1 Spring Boot与MyBatis的集成 24
3.2 Spring Boot与Redis的集成 29
3.2.1 添加Redis缓存 29
3.2.2 清除Redis缓存 31
3.3 Spring Boot与ActiveMQ的集成 31
3.3.1 使用内嵌的ActiveMQ 31
3.3.2 使用外部的ActiveMQ 33
3.4 Spring Boot应用的打包和部署 35
3.4.1 JAR包 35
3.4.2 WAR包 36
3.5 本章小结 37
第4章 Spring Cloud（上） 38
4.1 Spring Cloud简介 39
4.1.1 什么是Spring Cloud 39
4.1.2 Spring Cloud的特点 39
4.1.3 Spring Cloud的版本 39
4.2 服务发现 40
4.2.1 Eureka介绍 40
4.2.2 如何使用Eureka注册服务 41
4.2.3 如何实现服务间的调用 47
4.3 客户端负载均衡 50
4.3.1 Ribbon介绍 50
4.3.2 Ribbon的使用 51
4.4 本章小结 53
第5章 Spring Cloud（下） 54
5.1 服务容错保护 55
5.1.1 Spring Cloud Hystrix介绍 55
5.1.2 Spring Cloud Hystrix的使用 56
5.1.3 HystrixDashboard的使用 59
5.2 API网关服务 63
5.2.1 为什么需要API网关 63
5.2.2 如何使用Zuul构建API网关服务 64
5.3 分布式配置管理 68
5.3.1 Spring Cloud Config简介 68
5.3.2 使用本地存储的方式实现配置管理 69
5.3.3 使用Git存储的方式实现配置管理 73
5.4 本章小结 76
第6章 初识Docker 77
6.1 Docker概述 78
6.1.1 什么是Docker 78
6.1.2 Docker的特点 78
6.1.3 Docker与虚拟机的区别 79
6.2 Docker的安装要求 79
6.3 Docker的安装方式 80
6.3.1 在线安装 80
6.3.2 离线安装 82
6.3.3 脚本文件安装 83
6.3.4 安装时的问题及解决方法 84
6.4 Docker的运行机制 85
6.4.1 Docker的引擎 85
6.4.2 Docker的架构 85
6.5 Docker的底层技术 87
6.6 本章小结 87
第7章 Docker的使用 88
7.1 Docker入门程序 89
7.2 Dockerfile介绍 92
7.2.1 Dockerfile基本结构 92
7.2.2 Dockerfile常用指令 93
7.2.3 dockerignore文件 95
7.3 Docker客户端常用指令 96
7.3.1 Docker常用操作指令 96
7.3.2 Docker管理指令 101
7.4 Docker镜像管理 102
7.4.1 Docker镜像管理工具 102
7.4.2 Docker Hub远程镜像管理 103
7.4.3 Docker Registry本地私有仓库搭建 106
7.4.4 Docker Registry本地私有仓库配置 107
7.5 本章小结 112
第8章 Docker中的网络与数据管理 113
8.1 Docker网络管理 114
8.1.1 Docker默认网络管理 114
8.1.2 自定义网络介绍 115
8.1.3 自定义bridge网络 116
8.1.4 容器之间的网络通信 118
8.2 Docker Swarm集群 122
8.2.1 Docker Swarm概述 122
8.2.2 Docker Swarm使用 123
8.3 Docker数据管理 127
8.3.1 Docker数据存储机制 127
8.3.2 Docker数据存储方式 129
8.4 Volumes数据卷管理 129
8.4.1 Volumes数据卷的优势 129
8.4.2 Volumes数据卷使用 130
8.5 本章小结 134
第9章 微服务项目的整合与测试 135
9.1 微服务项目整合 136
9.1.1 微服务项目结构预览 136
9.1.2 微服务项目功能介绍 136
9.1.3 微服务项目的启动和测试 140
9.2 接口可视化工具—Swagger—UI 143
9.2.1 Swagger—UI使用方法 143
9.2.2 Swagger—UI使用测试 145
9.3 本章小结 147
第10章 微服务的部署 149
10.1 Docker Compose编排工具 150
10.1.1 Docker Compose介绍 150
10.1.2 Docker Compose的安装与卸载 150
10.1.3 Composefile文件的使用说明 151
10.2 微服务与Docker的整合 154
10.3 环境搭建以及镜像准备 159
10.3.1 环境搭建 159
10.3.2 镜像准备 161
10.4 微服务的手动部署 162
10.4.1 非集群环境下的服务部署 162
10.4.2 集群环境下服务部署 163
10.4.3 微服务测试 167
10.5 使用Jenkins自动部署微服务 169
10.5.1 Jenkins介绍 169
10.5.2 Jenkins安装 170
10.5.3 Jenkins集成插件配置 173
10.5.4 服务自动化部署 175
10.6 本章小结 180
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务架构基础:Spring Boot+Spring Cloud+Docker
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Unity与C++网络游戏开发实战：基于VR、AI与分布式架构
序言
前言
第1篇 Unity基础（客户端）
第1章 Unity介绍与相关环境的搭建和调试 2
1.1 Unity引擎介绍 2
1.1.1 Unity3D引擎部分 2
1.1.2 Unity3D编辑器部分 3
1.2 Unity引擎发展 5
1.3 Unity引擎应用场景和使用范围介绍 5
1.4 Unity软件安装 7
1.5 Unity Windows环境的安装和搭建 9
1.6 Unity Android环境的安装和搭建 11
1.7 Unity授权 15
1.8 Unity服务 16
第2章 编写Hello World与仿真系统体验 18
2.1 创建第一个空的工程 18
2.2 创建第一个脚本程序 20
2.3 编写第一个Hello Word程序 21
2.4 编译输出第一个程序 22
2.5 运行Hello World 23
2.6 打开仿真程序Demo 23
2.7 这是一个很好玩的仿真系统 25
2.8 进入训练场准备体验训练操作 25
2.9 控制人物行走 26
2.10 开动第一辆汽车 27
2.11 完成第一个仿真任务 27
2.12 本章小结与分析 28
第3章 Unity游戏开发语言 29
3.1 C#语言介绍 29
3.2 C#常用数据结构介绍 31
3.2.1 ArrayList链表结构 31
3.2.2 泛型List 31
3.2.3 Stack栈 32
3.2.4 队列Queue 33
3.2.5 字典Dictionary 34
3.3 C#的接口与继承 35
3.3.1 实现继承和接口继承 35
3.3.2 多重继承 35
3.3.3 结构的继承 35
3.4 C#的委托 37
3.5 C#多线程使用介绍 38
3.6 C#的反射机制 39
3.7 Unity中使用泛型 42
3.8 Unity中使用协程 42
3.9 Unity的序列化和网络协议库介绍 45
3.10 Unity中使用CLR进行Native交互 46
3.11 Unity中使用热更新语言Lua 47
3.12 本章小结与分析 50
第4章 在Unity中使用图形学知识 51
4.1 3D数学基本知识在游戏中的应用 51
4.2 三维坐标系 52
4.3 顶点坐标变换 53
4.3.1 向量是什么 53
4.3.2 矩阵是什么 54
4.3.3 如何操作向量 55
4.3.4 如何处理点或者向量与矩阵的乘法 55
4.3.5 点和向量通过矩阵的变换 56
4.4 光照与材质 58
4.4.1 什么是Shader的基本光照模型 59
4.4.2 什么是光照模型 59
4.4.3 什么是材质 61
4.5 Unity引擎中的渲染管线流程 67
4.6 Unity中实现模型的缩放和旋转等程序处理 70
4.7 Unity中计算射线相关的程序处理 74
4.8 Unity中制作一个简单的渲染特效 77
4.9 本章小结与分析 84
第5章 Unity编辑器的使用 86
5.1 创建一个空的工程 86
5.2 编辑器界面布局介绍 88
5.3 编辑器的常用功能介绍 89
5.4 编辑器模型编辑——旋转控制第一个模型 95
5.5 编辑器动作骨骼编辑——让人物动起来 96
5.6 编辑器光照和相机的编辑——让人物更真实 98
5.7 编辑器粒子特效编辑——让环境更绚丽 101
5.8 编辑器场景编辑——创建简单的战场 104
5.9 编辑器地形和光照贴图烘焙——让战场真实起来 105
5.10 编辑器遮挡剔除——提高战场的运行效率 107
5.11 编辑器资源管理——让工程更容易管理 109
5.12 编辑器控制台和调试——输出调试信息 110
5.13 编辑器资源商店和常用插件 111
5.14 编辑器材质编辑——让车辆变化一下样式 114
5.15 编辑器物理系统介绍——让人和车辆发生碰撞 116
5.16 本章小结与分析 118
第2篇 Unity实战（客户端）
第6章 虚拟仿真训练系统的架构和模块 122
6.1 什么是虚拟仿真训练 122
6.1.1 战斗模拟仿真训练 122
6.1.2 车辆仿真和工业操作 123
6.2 物理架构介绍——虚拟仿真训练系统 123
6.3 使用态势端发布授权任务 126
6.4 将分队长学员配置加入授权任务 127
6.5 启动仿真任务——完成一次美妙的任务体验 128
6.6 本章小结与分析 130
第7章 人物资源编辑与程序开发 132
7.1 模型资源的导入和整理编辑 132
7.2 人物动作资源的编辑和管理 134
7.3 数据资源的导入和整理 137
7.4 人物的控制和脚本程序开发 141
7.5 人物的行为状态机开发 147
7.6 人物特效的控制和状态交互 150
7.7 人物的物理状态和碰撞瞄准的程序交互 151
7.8 人物的属性和程序接口开发 154
7.9 在场景中运行人物资源和调试程序 158
7.10 本章小结与分析 159
第8章 场景资源编辑与程序开发 161
8.1 场景资源的导入和整理管理 161
8.2 场景数据资源的导入和场景程序管理 162
8.3 地形的编辑和程序相关功能开发 169
8.4 添加碰撞体树木和非碰撞体植被 172
8.5 创建光源和阴影渲染 174
8.6 添加场景静态物体和动态物体 176
8.7 添加场景水的插件并使用代码集成 182
8.8 添加天气系统插件并集成代码系统 187
8.9 添加场景道路插件并制作道路 192
8.10 添加天空盒和雾态效果 194
8.11 场景预览和渲染效率优化 196
8.12 场景系统加载切换和系统程序开发 198
8.13 本章小结与分析 202
第9章 资源组件和交互物品开发 203
9.1 资源组件的导入和整理管理 203
9.2 资源物品的数据导入和整理管理 205
9.3 AssetBundle的资源组成和功能API 207
9.4 开发自己的AssetBundle打包工具插件 208
9.5 加载和管理AssetBundle资源 212
9.6 车辆动力系统的插件使用和系统集成开发 216
9.7 关于飞行器直升机的开发和使用 223
9.8 地雷组件的开发和功能交互 225
9.9 物品管理器系统开发 230
9.10 本章小结与分析 235
第10章 NGUI组件开发和操作交互开发 236
10.1 NGUI插件介绍和导入工程 236
10.2 NGUI图集的使用和制作 237
10.3 NGUI图集的优化和DrawCall的优化策略 239
10.4 NGUI的底层实现原理和分析 240
10.5 UILable的使用 242
10.6 UISprite的使用 243
10.7 UIPanel的使用 244
10.8 UIScrollView的使用 245
10.9 UIButton的使用 247
10.10 UIRoot和UICamera的自适应 250
10.11 打造UI面向对象的动态加载和管理 251
10.12 登录UI功能开发 257
10.13 大厅任务信息系统UI功能开发 261
10.14 战场场景中主视角UI系统功能开发 268
10.15 VR开发——VR可以使用的VRGUI 276
10.16 本章小结与分析 277
第3篇 C++网络开发基础（服务器）
第11章 C++语言基础 280
11.1 C++简介 280
11.2 C++基本语法 281
11.3 C++数据结构 283
11.4 C++变量类型 289
11.5 C++修饰符类型 290
11.6 C++存储类 291
11.7 C++运算符和运算方式 294
11.8 C++函数 297
11.9 C++数组和高级功能 300
11.10 C++指针和高级功能 301
11.11 C++引用和常用方式 303
11.12 C++类和对象 305
11.13 C++继承和多态 307
11.14 C++接口和抽象 309
11.15 C++文件和流的处理 311
11.16 C++ STL库介绍 314
11.17 本章小结与分析 319
第12章 C++网络编程基础 321
12.1 Socket套接字 321
12.2 套接字寻址方式 326
12.3 Winsocket网络程序开发流程 328
12.4 在Visual Studio中创建网络工程 330
12.5 Winsocket编程准备 331
12.6 基于TCP的Socket编程 332
12.7 基于UDP的Socket编程 336
12.8 本章小结与分析 343
第13章 多线程和异步套接字 345
13.1 C++多线程开发 345
13.2 C++多线程互斥对象和同步 347
13.3 C++进程间通信 350
13.4 C++设置异步I/O的模式和方法 356
13.5 本章小结与分析 358
第14章 MySQL数据库的使用 359
14.1 MySQL数据库介绍和使用范围 359
14.2 安装MySQL数据库 360
14.3 MySQL可视化管理工具的使用 362
14.4 使用C++连接MySQL数据库 364
14.5 SQL语句和语法 369
14.6 MySQL备份导出数据和导入转移数据 371
14.7 本章小结与分析 374
第15章 网络协议Protobuf的使用 376
15.1 什么是Protobuf 376
15.2 Protobuf的功能是什么 378
15.3 Protobuf序列化的原理是什么 385
15.4 如何编写Protobuf的.proto文件 387
15.5 如何编译和生成Protobuf的编译程序 389
15.6 使用Protobuf协议制作一段网络小程序 392
15.7 本章小结与分析 399
第4篇 C++网络开发实战（服务器）
第16章 设计架构简单的互动服务器体系 402
16.1 Visio：一个绘制架构图的软件 402
16.2 如何使用图和连接线来表示架构 404
16.3 需要哪些服务来构建整个服务体系 406
16.4 登录服务器（LoginServer） 407
16.5 网关服务器（GateServer） 410
16.6 中心服务器（CenterServer） 413
16.7 战场服务器（BattleServer） 414
16.8 本章小结与分析 418
第17章 开发登录服务器LoginServer 420
17.1 登录服务器的作用 420
17.2 使用Protobuf生成登录授权文件和协议 421
17.3 创建LoginServer网络会话层底层模块 429
17.4 创建LoginServer服务逻辑模块 436
17.5 导入LoginServer的Protobuf协议 440
17.6 客户端Protobuf协议的导入和使用 443
17.7 从客户端登录到授权的逻辑处理过程 445
17.8 启动LoginServer，完成第一次授权登录 449
17.9 Redis缓存存储和信息处理 450
17.10 本章小结与分析 452
第18章 开发网关服务器GateServer 453
18.1 网关服务器及其作用 453
18.2 创建GateServer的框架主程序 454
18.3 创建网关转发和验证所需要的Protobuf协议脚本 461
18.4 生成服务器所需要的C++协议程序 464
18.5 生成客户端所需要的C#协议程序 466
18.6 完成网关服务器的逻辑功能开发 468
18.7 完成客户端从网关授权进入大厅的逻辑 478
18.8 本章小结与分析 481
第19章 开发中心服务器CenterServer 482
19.1 中心服务器及其作用 482
19.2 创建CenterServer框架主程序 484
19.3 创建中心服务器的Protobuf协议脚本 488
19.4 生成服务器所需要的C++协议程序 495
19.5 生成客户端所需要的C#协议程序 497
19.6 生成服务器data数据和协议代码 500
19.7 完成中心服务器的逻辑功能开发 504
19.8 启动客户端完成任务配置并开始仿真任务 513
19.9 本章小结与分析 520
第20章 开发战场服务器BattleServer 522
20.1 战场服务器及其作用 522
20.2 创建BattleServer框架主程序 524
20.3 创建战场服务器Protobuf协议脚本 527
20.4 生成服务器所需要的C++协议程序 537
20.5 生成客户端所需要的C#协议程序 539
20.6 生成服务器data数据和协议代码 550
20.7 创建战场服务器的聊天模块 553
20.8 创建战场逻辑模块 556
20.9 创建战场仿真人员同步模块 558
20.10 创建战场仿真车辆和飞行器模块 564
20.11 创建战场动态资源管理和监控模块 568
20.12 创建战场AI仿真敌人和飞行器AI状态机 571
20.13 调试战场服务器和客户端，启动仿真任务 576
20.14 本章小结与分析 579
第21章 一些仿真框架和人工智能的介绍 581
21.1 VR-LINK与HLA框架：高层体系模型框架的使用 581
21.2 游戏中常用的人工智能算法和深度学习引申 584
后记——全书总结与个人发展建议 588
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Unity与C++网络游戏开发实战：基于VR、AI与分布式架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>创新流程架构：产品创新战略
第一章企业需要产品创新战略1
有史以来最好的战略2
赢得一场战斗，但失去整个战争4
什么是产品创新战略12
为什么要有产品创新战略15
支持战略的证据17
产品创新战略的要素及其影响24
总结29
第二章目的和目标31
设置企业的目的和目标32
测量和指标37
定义新产品42
设置产品创新目标48
如何设定企业的产品创新目标57
总结63
第三章稳健的战略分析——选好着眼点的关键65
聚焦适合的战略领域66
选择领域的三个步骤68
战略分析——市场、技术和行业70
做一个“头朝上”的公司82
利用企业的核心竞争力93
总结：战略评估96
第四章战略领域——正确的方法97
寻找战略领域98
选择领域105
选择正确的领域108
战略图：规划战略领域114
总结：挑选目标领域119
第五章制订取胜的进攻计划121
制订进攻战略122
基于创新的战略类型122
基于竞争维度的战略131
全球战略与地区战略135
同一屋檐下的多种战略142
Chempro的进攻战略144
决定企业的入市战略144
开放式创新在企业战略中的作用150
总结：获胜的进攻计划157
第六章资源投入、部署和战略桶159
优化企业的新产品投资160
多少投入是够的——确定企业的产品创新工作的投资167
部署企业的开发资源：战略组合管理175
使用战略桶推动项目的正确组合和均衡182
总结：战略桶194
第七章企业的战略路线图195
什么是路线图196
路线图的类型200
制订企业的战略产品路线图208
初步选择主要的计划218
制订企业的技术路线图229
将企业的产品创新战略投入实践232
总结：战略路线图234
第八章治理——使企业的产品创新战略奏效237
治理和企业238
企业的治理方法需要改进吗239
影响采纳的障碍242
谁应该参与产品创新治理243
治理什么，为什么要治理，治理谁247
总结251
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>创新流程架构：产品创新战略
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE架构设计与开发实践
第1章JavaEE概述
1.1JavaEE简介
1.1.1什么是JavaEE
1.1.2JavaEE的新特性
1.2JavaEE应用分层架构
1.2.1分层模式概述
1.2.2JavaEE的结构
1.3JavaEE技术规范
1.4敏捷轻型框架
1.4.1Hibernate简介
1.4.2Struts2简介
1.4.3Spring简介
1.4.4JSF简介
1.4.5Tapestry简介
1.4.6WebWork简介
1.5JavaEE开发环境
1.5.1JDK的下载和安装
1.5.2Tomcat8.0的安装和配置
1.5.3集成开发环境的安装和使用
1.5.4MySQL数据库的安装和使用
1.5.5SQLServer数据库的安装和使用
1.6本章小结
1.7习题
实训1搭建JavaEE运行及开发环境
第2章JavaWeb开发概述
2.1JavaWeb概述
2.1.1Web程序基本知识
2.1.2Web程序开发过程
2.2HTTP协议
2.2.1HTTP方法的请求格式
2.2.2HTTP方法的响应格式
2.2.3HTTP协议主要特点
2.2.4GET/POST方法的比较
2.3JDBC简介
2.3.1常用的标准SQL语句
2.3.2JDBC结构
2.3.3JDBC驱动类型
2.3.4常用数据库JDBC连接写法
2.3.5创建JDBC应用程序具体步骤
2.4JavaWeb应用服务器
2.4.1Glassfish简介
2.4.2JBoss简介
2.4.3Tomcat简介
2.4.4WebSphere简介
2.4.5WebLogic简介
2.4.6在MyEclipse中配置Tomcat
2.5在MyEclipse中开发JavaWeb程序
2.5.1Web工程的创建
2.5.2Web工程的发布
2.5.3在Eclipse中调试程序
2.6常用开发工具
2.6.1Maven项目管理工具
2.6.2版本管理工具CVS
2.6.3日志工具
2.6.4报表图形引擎
2.7本章小结
2.8习题
实训2JDBC数据库连接及常用开发工具使用
第3章HTML、JavaScript简介
3.1任务1引入性案例
3.2任务2HTML的基本结构
3.3任务3文本及版面风格的控制
3.3.1文本控制
3.3.2版面风格控制
3.4任务4图像、超链接和表格
3.4.1图像和超链接
3.4.2表格
3.5任务5HTML的表单
3.5.1表单定义
3.5.2文本框控件
3.5.3单选按钮和复选框
3.5.4下拉菜单和列表
3.5.5按钮
3.5.6图像域、隐藏域和文件域
3.5.7分组标记
3.6任务6CSS使用
3.7任务7HTML5应用
3.8任务8JavaScript使用
3.8.1JavaScript概述
3.8.2函数
3.8.3事件处理
3.8.4JSON简介
3.9任务9jQuery基础
3.9.1jQuery安装
3.9.2jQuery语法
3.9.3jQuery选择器
3.9.4jQuery事件操作
3.10任务10AJAX基础应用
3.10.1AJAX概述
3.10.2XMLHttpRequest对象
3.10.3AJAX应用实例
3.10.4开源AJAX框架DWR介绍
3.11本章小结
3.12习题
实训3HTML和JavaScript综合应用
第4章JSP应用基础
4.1Servlet概述
4.1.1Servlet工作原理
4.1.2Servlet的特点
4.2Servlet编程基础
4.2.1Servlet接口
4.2.2Servlet程序的编译
4.2.3Servlet的配置
4.2.4Servlet的应用实例
4.3JSP简介
4.3.1工作原理
4.3.2一个简单的JSP程序
4.3.3JSP注释与声明
4.3.4JSP表达式和程序段
4.4JSP指令
4.4.1include指令
4.4.2page指令
4.4.3taglib指令
4.5JSP动作
4.5.1forward动作
4.5.2include动作
4.5.3plugin动作指令
4.5.4useBean动作
4.6JSP的内置对象
4.6.1输出对象out
4.6.24种属性范围
4.6.3请求对象request
4.6.4响应对象response
4.6.5会话对象session
4.6.6Web服务器对象application
4.7JSP中文乱码问题全解决方案
4.7.1JSP页面中文乱码
4.7.2URL传递参数中文乱码
4.7.3表单提交中文乱码
4.7.4使用请求编码格式过滤器Filter
4.8本章小结
4.9习题
实训4Servlet和JSP综合应用
第5章Struts2开发
5.1Struts2简介
5.1.1Struts的起源
5.1.2MVC设计模式简介
5.1.3Struts优、缺点
5.2Struts2安装
5.3Strut2工作原理
5.4Struts配置文件
5.4.1Struts.xml文件
5.4.2加载子配置文件
5.4.3Action配置
5.4.4struts.properties属性文件
5.5Struts2开发实例
5.6拦截器
5.6.1拦截器介绍
5.6.2拦截器实例
5.7类型转换OGNL
5.7.1OGNL简介
5.7.2类型转换实例
5.7.3OGNL小结
5.8Struts2常用标签
5.9输入校验
5.9.1手动输入完成校验
5.9.2使用Struts2框架校验
5.9.3校验器的配置风格
5.10Struts国际化
5.11本章小结
5.12习题
实训5用Struts实现图书管理系统中用户登录模块
第6章Hibernate基础
6.1Hibernate概述
6.1.1Hibernate简介
6.1.2Hibernate不同版本之间的区别
6.1.3  持久层与ORM
6.1.4  Hibernate体系结构
6.1.5  HibernateAPI简介
6.2Hibernate应用基础
6.2.1Hibernate应用开发步骤
6.2.2Hibernate配置文件
6.2.3Hibernate核心接口
6.2.4HQL查询
6.2.5  Hibernate开发实例
6.3Hibernate对象
6.3.1对象的特征
6.3.2对象的状态
6.3.3主键生成策略
6.3.4对象关系映射
6.3.5关系映射实例
6.4Hibernate事务编程
6.4.1  事务概述
6.4.2  JDBC中使用事务
6.4.3  Hibernate事务管理
6.5本章小结
6.6习题
实训6用Struts和Hibernate实现高校选课系统
第7章Spring基础与应用
7.1Spring概述
7.1.1Spring框架简介
7.1.2Spring的特点
7.1.3Spring框架结构
7.2Spring快速入门
7.2.1搭建Spring环境
7.2.2一个简单依赖注入实例
7.3依赖注入基本原理
7.3.1控制反转与依赖注入
7.3.2依赖注入的形式
7.3.3IoC装载机制
7.4SpringAOP概述
7.4.1AOP概念与术语
7.4.2AOP实现机制
7.4.3Spring中的AOP
7.5Spring事务管理
7.5.1事务简介
7.5.2事务管理器
7.5.3Spring事务管理机制
7.5.4事务的传播行为和隔离级别
7.6本章小结
7.7习题
实训7Struts2+Spring3集成示例
第8章SSH整合架构开发
8.1SSH集成开发简介
8.2SSH集成开发实例1
8.3SSH集成开发实例2
8.4本章小结
第9章JavaEE课程设计案例
9.1系统概述
9.2系统需求分析
9.2.1学习平台系统功能分析
9.2.2设计思想
9.3系统数据库设计
9.3.1数据库概念设计
9.3.2数据库逻辑设计
9.3.3数据库的连接原理
9.4平台功能实现
9.4.1创建项目工程
9.4.2三层开发过程
9.5本章小结
附录AJavaEE开发常见错误及解决
附录BJavaEE面试题及参考答案
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java EE架构设计与开发实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>無瑕的程式碼－整潔的軟體設計與架構篇
Part I 簡介
Chapter 1 什麼是設計與結構
Chapter 2 兩種價值觀的故事
Part II 從基礎開始：程式設計範式
Chapter 3 範式概述
Chapter 4 結構化程式設計
Chapter 5 物件導向程式設計
Chapter 6 函數式程式設計
Part III 設計原則
Chapter 7 SRP：單一職責原則
Chapter 8 OCP：開放－封閉原則
Chapter 9 LSP：Liskov 替換原則
Chapter 10 ISP：介面隔離原則
Chapter 11 DIP：依賴反向原則
Part IV 元件原則
Chapter 12 元件
Chapter 13 元件內聚性
Chapter 14 元件耦合性
Part V 架構
Chapter 15 什麼是架構
Chapter 16 獨立性
Chapter 17 邊界：畫線
Chapter 18 邊界剖析
Chapter 19 策略和層級
Chapter 20 業務規則
Chapter 21 會尖叫的架構
Chapter 22 整潔的架構
Chapter 23 Presenter 與Humble Object
Chapter 24 部分邊界
Chapter 25 層與邊界
Chapter 26 主元件
Chapter 27 服務：偉大與微小
Chapter 28 測試邊界
Chapter 29 整潔的嵌入式架構
Part VI 細節
Chapter 30 資料庫是細節
Chapter 31 Web是細節
Chapter 32 框架是細節
Chapter 33 案例研究：影片販售
Chapter 34 遺漏的章節
Part VII 附錄
Appendix A 架構考古學
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>無瑕的程式碼－整潔的軟體設計與架構篇
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务架构实战
第1章 微服务架构设计 1
1.1 直面微服务架构 1
1.1.1 分布式系统与微服务架构 1
1.1.2 微服务架构的优势与挑战 3
1.1.3 实施微服务架构 5
1.2 服务建模方法 6
1.2.1 服务的模型 6
1.2.2 服务的边界 7
1.2.3 服务的数据 7
1.3 服务拆分与集成 8
1.3.1 服务拆分 8
1.3.2 服务集成 9
1.4 微服务架构的基础组件和关键要素 10
1.4.1 微服务架构的基础组件 11
1.4.2 微服务架构的关键元素 11
1.5 实现微服务架构 13
1.5.1 微服务架构技术体系 13
1.5.2 微服务架构实现技术选型 14
1.6 案例分析 17
1.7 全书架构 18
1.8 本章小结 19
第2章 使用Spring Boot构建服务 21
2.1 引入Spring Boot 21
2.2 基于Spring Boot的第一个服务 23
2.2.1 环境准备 23
2.2.2 实现RESTful服务 24
2.3 Spring Boot常见功能 28
2.3.1 集成Spring Data 28
2.3.2 集成消息中间件 37
2.3.3 系统监控 39
2.4 Spring Boot基本原理 44
2.5 本章小结 46
第3章 Spring Cloud Netflix Eureka与服务治理 47
3.1 服务治理解决方案 48
3.1.1 服务治理的需求和模型 48
3.1.2 服务治理的基本方案 49
3.2 构建Eureka服务 52
3.2.1 构建单个Eureka服务器 52
3.2.2 构建Eureka服务器集群 55
3.3 使用Eureka注册和发现服务 57
3.3.1 通过配置实现服务注册 58
3.3.2 获取服务注册信息 59
3.4 Eureka基本架构 61
3.4.1 Eureka服务注册和发现架构 61
3.4.2 Eureka高可用架构 64
3.4.3 Eureka区域亲和性 65
3.5 本章小结 66
第4章 Spring Cloud Netflix Ribbon与负载均衡 67
4.1 负载均衡 68
4.1.1 负载均衡的类型 68
4.1.2 负载均衡的算法 70
4.2 使用Ribbon实现客户端负载均衡 71
4.2.1 Spring Cloud Netflix Ribbon简介 71
4.2.2 使用DiscoveryClient查找服务 72
4.2.3 通过RestTemplate调用服务 74
4.3 Ribbon基本架构 78
4.3.1 Ribbon核心机制 79
4.3.2 Ribbon负载均衡策略 81
4.3.3 @LoadBalanced注解与RestTemplate 82
4.3.4 @RibbonClient注解与自定义负载均衡策略 83
4.4 本章小结 85
第5章 Spring Cloud Netflix Hystrix与服务容错 86
5.1 服务消费者容错思想和模式 87
5.1.1 服务消费者容错的需求 87
5.1.2 服务隔离 88
5.1.3 服务熔断 90
5.1.4 服务回退 91
5.2 使用Hystrix实现服务容错 91
5.2.1 引入Hystrix 92
5.2.2 使用Hystrix实现服务隔离 93
5.2.3 使用Hystrix实现服务熔断 96
5.2.4 使用Hystrix实现服务回退 99
5.3 Hystrix基本原理 101
5.3.1 服务隔离 101
5.3.2 服务熔断 103
5.3.3 Hystrix配置项 105
5.4 本章小结 109
第6章 Spring Cloud Netflix Zuul与API网关 110
6.1 服务网关的设计理念 111
6.1.1 服务网关的作用 111
6.1.2 服务网关的结构和功能 112
6.2 使用Zuul构建服务网关 113
6.2.1 构建Zuul服务器 113
6.2.2 配置Zuul服务路由 115
6.3 Zuul基本架构 120
6.3.1 ZuulFilter组件架构 120
6.3.2 使用Zuul过滤器 124
6.4 本章小结 129
第7章 Spring Cloud Config与配置中心 130
7.1 分布式配置中心方案 131
7.1.1 分布式配置模型 131
7.1.2 配置中心实现工具 133
7.2 构建配置中心服务器 134
7.2.1 引入Spring Cloud Config 134
7.2.2 实现基于本地文件系统的配置方案 135
7.2.3 实现基于Git的配置方案 139
7.3 使用配置服务 140
7.3.1 访问配置项 141
7.3.2 配置数据安全性 145
7.4 Spring Cloud Config特性 148
7.4.1 Spring Cloud Config对比Zookeeper 148
7.4.2 Spring Cloud Config高可用 149
7.5 本章小结 150
第8章 Spring Cloud Stream与事件驱动 151
8.1 事件驱动架构与模型 152
8.1.1 基本事件驱动架构与实现机制 152
8.1.2 事件驱动与领域模型 155
8.2 引入Spring Cloud Stream 157
8.2.1 Spring Cloud Stream基本架构 157
8.2.2 Spring Cloud Stream与Spring Integration 159
8.2.3 Spring Cloud Stream与消息中间件 162
8.3 实现消息发布者 165
8.3.1 消息发送场景与实现流程 165
8.3.2 在服务中添加消息发布者 166
8.4 实现消息消费者 170
8.4.1 消息消费场景与实现流程 170
8.4.2 在服务中添加消息消费者 172
8.5 本章小结 177
第9章 Spring Cloud Security与服务安全 178
9.1 服务访问安全性与OAuth协议 178
9.1.1 微服务架构中的安全性设计 179
9.1.2 OAuth协议 180
9.2 构建OAuth认证服务器 184
9.2.1 引入Spring Cloud Security 185
9.2.2 初始化用户与客户端 186
9.2.3 生成Token 191
9.3 使用OAuth保护服务访问 195
9.3.1 集成OAuth认证服务 195
9.3.2 创建服务访问策略 196
9.3.3 使用OAuth2RestTemplate传播Token 201
9.4 本章小结 206
第10章 Spring Cloud Sleuth与服务监控 207
10.1 服务监控与Spring Cloud Sleuth 207
10.1.1 服务监控基本原理 207
10.1.2 引入Spring Cloud Sleuth 209
10.2 整合Spring Cloud Sleuth与Zipkin 215
10.2.1 Zipkin基本结构 215
10.2.2 引入Zipkin 216
10.2.3 使用Zipkin跟踪服务调用链路 218
10.2.4 使用Zipkin实现自定义跟踪 226
10.3 本章小结 228
第11章 Spring Test与服务测试 230
11.1 微服务测试的方法 231
11.1.1 单元测试 231
11.1.2 集成测试 233
11.1.3 端到端测试 233
11.2 测试Spring Boot应用程序 234
11.2.1 初始化测试环境 234
11.2.2 执行单元测试 237
11.3 使用Mock和注解实施集成测试 241
11.3.1 使用@JsonTest注解测试JSON数据 242
11.3.2 使用@DataJpaTest注解测试Repository层 244
11.3.3 使用Mock测试Service层 248
11.3.4 使用Mock和@WebMvcTest注解测试Controller层 252
11.4 消费者驱动的契约测试 254
11.4.1 面向契约的端对端测试 254
11.4.2 实现面向契约的端对端测试 257
11.5 本章小结 266
第12章 Docker与服务部署 267
12.1 Docker与微服务架构 267
12.1.1 Docker的优势 268
12.1.2 Docker组件与命令 268
12.2 使用Dockerfile构建服务镜像 272
12.2.1 Dockerfile命令 272
12.2.2 使用Dockerfile命令构建镜像 273
12.3 使用Docker Compose编排服务 276
12.3.1 Docker Compose组件与命令 276
12.3.2 使用Docker Compose 279
12.3.3 Docker Compose案例分析 281
12.4 本章小结 283
参考文献 284
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务架构实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>5G无线接入网架构及关键技术/5G丛书
第1章 5G网络需求与架构特征	001
1.1 5G全球研究进展	002
1.1.1 移动通信发展情况	002
1.1.2 5G全球研究进展	004
1.2 5G应用场景与性能指标	006
1.2.1 5G网络愿景	006
1.2.2 5G应用场景与性能目标	008
1.3 5G网络建设部署及运营维护需求	012
1.3.1 5G网络建设部署需求	012
1.3.2 5G网络运营维护需求	012
1.4 ITU定义的5G	013
1.5 3GPP定义的5G	015
1.6 5G网络架构特征	016
1.6.1 更高数据流量和用户体验	016
1.6.2 更低时延	021
1.6.3 海量终端连接	023
1.6.4 更低成本	024
1.6.5 更高能效	025
1.6.6 5G网络架构特征总结	026
参考文献	027
第2章 5G网络总体架构	031
2.1 4G网络总体架构	032
2.2 欧洲METIS 5G架构	034
2.2.1 网络功能架构	036
2.2.2 拓扑和功能部署架构	041
2.2.3 4G和5G架构比较	046
2.3 日本5G架构	047
2.4 韩国5G架构	049
2.4.1 架构综述	051
2.4.2 数据面	051
2.4.3 控制面	051
2.5 北美5G生态系统架构	052
2.6 NGMN 5G架构	054
2.6.1 5G设计原则	054
2.6.2 5G架构	057
2.6.3 网络切片	059
2.6.4 5G系统组件	061
2.7 中国IMT-2020 5G网络架构	062
2.7.1 “三朵云”概念架构	062
2.7.2 系统参考架构	070
2.7.3 部署架构示例	072
参考文献	083
第3章 5G无线接入网络架构	085
3.1 典型应用场景	086
3.1.1 室内热点场景	087
3.1.2 密集城区场景	088
3.1.3 城区宏覆盖场景	089
3.1.4 郊区场景	090
3.1.5 荒野场景（广覆盖和最小服务）	090
3.1.6 荒野场景（超广覆盖）	090
3.1.7 大规模连接城区覆盖场景	091
3.1.8 高速路场景	092
3.1.9 车联网场景	092
3.2 5G无线接入网需求分析	093
3.2.1 性能要求	093
3.2.2 功能需求	096
3.3 5G无线网络关键技术	101
3.3.1 无线控制承载分离	102
3.3.2 无线网络虚拟化	103
3.3.3 增强C-RAN	109
3.3.4 移动边缘计算	112
3.3.5 多制式协作与融合	112
3.3.6 融合资源协同管理	116
3.3.7 灵活移动性	118
3.3.8 网络频谱共享	120
3.3.9 邻近服务	121
3.3.10 无线mesh	121
3.4 5G无线接入网设计原则与网络架构	124
3.4.1 5G无线网络设计原则	124
3.4.2 5G无线网络逻辑架构	125
3.4.3 5G无线网络部署架构	130
3.5 典型场景下5G无线接入网部署策略	133
3.5.1 热点高容量场景下5G智能无线网络	133
3.5.2 低时延高可靠场景下5G智能无线网络	139
3.5.3 网络部署设计	145
参考文献	146
第4章 5G无线接入网控制承载分离技术	147
4.1 背景介绍	148
4.2 控制承载分离技术	150
4.3 宏微异构组网场景	158
4.3.1 多连接技术	160
4.3.2 移动性管理	166
4.3.3 连接增强技术	174
4.4 微—微组网场景	180
4.4.1 虚拟分层技术	180
4.4.2 虚拟层覆盖扩展技术	184
4.4.3 多系统组网下控制与承载分离	187
参考文献	188
第5章 5G无线接入网多网协同与融合技术	191
5.1 技术背景	192
5.2 移动网络与WLAN核心网侧互操作	195
5.2.1 技术方案	195
5.2.2 相关研究	201
5.3 移动网络与WLAN无线网侧互操作	202
5.3.1 网络场景	202
5.3.2 技术方案	203
5.3.3 相关研究	207
5.4 移动网络与WLAN无线网侧PDCP层融合	209
5.4.1 网络场景	209
5.4.2 共站部署技术方案	210
5.4.3 不共站部署技术方案	211
5.4.4 相关研究	219
5.5 基于IPSec隧道的LTE/WLAN无线集成	219
5.5.1 网络场景	219
5.5.2 技术方案	220
5.5.3 相关研究	223
5.6 基于MP-TCP的多连接技术	224
5.6.1 网络场景	224
5.6.2 技术方案	225
参考文献	228
第6章 5G无线接入网网络资源管理	231
6.1 5G无线接入网总体资源管理	232
6.1.1 资源管理与垂直功能	235
6.1.2 资源管理与水平概念	240
6.1.3 小结	244
6.2 UDN资源管理	245
6.2.1 UDN概述	245
6.2.2 干扰识别	246
6.2.3 干扰管理	247
6.2.4 回传资源管理	254
6.2.5 能耗管理	257
6.3 D2D无线资源管理	261
6.3.1 D2D技术概述	261
6.3.2 分簇化集中控制的5G网络D2D通信	263
6.3.3 集中控制的5G网络D2D通信无线资源管理研究	265
6.4 MMC无线资源管理	272
6.4.1 降低碰撞风险的MMC高效接入方式	273
6.4.2 MMC类型的D2D连接	275
6.4.3 降低信令负荷的MMC接入方式	275
6.5 MN无线资源管理	276
6.5.1 基于D2D方式V2V通信中的资源分配和功率控制	279
6.5.2 基于网络辅助资源分配方式的直接V2V通信	279
6.6 Ad Hoc网络	281
参考文献	282
第7章 5G移动边缘计算技术	289
7.1 MEC应用场景与标准进展	290
7.1.1 MEC技术应用场景	292
7.1.2 MEC技术标准研究进展	296
7.2 MEC部署策略与系统架构	296
7.2.1 MEC平台部署策略	296
7.2.2 MEC平台架构	298
7.3 MEC技术基础与挑战	299
7.3.1 MEC技术基础	299
7.3.2 MEC技术挑战	300
7.4 MEC在5G网络中的应用	303
7.4.1 增强无线宽带场景	303
7.4.2 低时延高可靠场景	305
7.4.3 大规模MTC终端连接场景	305
7.4.4 MEC技术在5G网络中的其他应用	306
7.5 基于MEC技术的本地分流	306
7.5.1 基于MEC技术的本地分流方案	306
7.5.2 LIPA/SIPTO本地分流方案	309
7.5.3 本地分流方案对比	311
7.5.4 基于MEC技术本地分流方案的挑战	311
参考文献	312
第8章 5G无线接入网虚拟化	315
8.1 网络虚拟化	316
8.1.1 网络虚拟化概念	316
8.1.2 NFV	317
8.2 无线接入网虚拟化	321
8.2.1 动机与触发点	322
8.2.2 虚拟化的维度与分类	324
8.2.3 无线网络虚拟化的若干层面	328
8.3 无线接入网平台虚拟化	331
8.3.1 x86虚拟化技术	331
8.3.2 基于通用处理器平台的虚拟化基站架构	333
8.3.3 BBU功能划分与硬件加速方案	334
8.4 无线接入网网络资源虚拟化	334
8.4.1 5G网络切片	335
8.4.2 基站资源切片	336
8.4.3 无线资源切片	337
8.5 面临的挑战	345
8.5.1 挑战一：资源隔离	345
8.5.2 挑战二：控制信令与接口的标准化	345
8.5.3 挑战三：物理和虚拟资源的分配	346
8.5.4 挑战四：移动性管理	347
8.5.5 挑战五：网络管理	347
8.5.6 挑战六：安全性	348
参考文献	348
第9章 5G频谱共享技术	351
9.1 独占授权式频谱分配	352
9.2 动态式频谱分配	353
9.2.1 相邻动态频谱分配	353
9.2.2 分片动态频谱分配	354
9.3 频谱共享	354
9.3.1 共存式频谱共享	354
9.3.2 覆盖式频谱共享	355
9.4 认知无线电系统	356
9.4.1 频谱检测	356
9.4.2 频谱共享池	358
9.4.3 功率控制	360
9.5 授权的频谱共享	361
9.5.1 LSA	361
9.5.2 LSA技术实现方式	364
9.6 LTE-U/LAA	366
9.6.1 LTE-U	366
9.6.2 LAA	369
9.6.3 LTE-U/LAA关键技术	370
9.6.4 LTE-U/LAA部署场景	378
参考文献	380
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>5G无线接入网架构及关键技术/5G丛书
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>系统架构设计师考试32小时通关
丛书序
前言
第一篇 架构设计基础
第1小时 系统架构设计师概述 2
1.0 章节考点分析 2
1.1 系统架构的概念及发展历史 3
1.2 系统架构设计师的定义及职业素质 3
1.3 系统架构设计师应具备的能力 5
1.4 从开发人员到系统架构设计师 5
1.5 练习题 6
第2小时 计算机与网络基础知识 8
2.0 章节考点分析 8
2.1 操作系统基础知识 9
2.2 数据库系统基础知识 15
2.3 计算机网络基础知识 20
2.4 多媒体技术及其应用 23
2.5 系统性能 24
2.6 练习题 24
第3小时 信息系统基础知识 28
3.0 章节考点分析 28
3.1 信息化概述 29
3.2 信息系统工程总体规划 31
3.3 信息化的典型应用 32
3.4 练习题 35
第4小时 系统开发基础知识 39
4.0 章节考点分析 39
4.1 软件开发方法 40
4.2 需求管理 43
4.3 开发管理 44
4.4 设计方法 45
4.5 软件的重用 45
4.6 逆向工程与重构工程 45
4.7 练习题 46
第二篇 架构设计高级知识
第5小时 软件架构设计 49
5.0 章节考点分析 49
5.1 软件架构的概念 50
5.2 基于架构的软件开发方法 51
5.3 软件架构风格 53
5.4 特定领域软件体系结构 55
5.5 系统架构的评估 55
5.6 练习题 57
第6小时 UML建模与架构文档化 58
6.0 章节考点分析 58
6.1 UML基础 59
6.2 UML软件开发过程 60
6.3 系统架构文档化 61
6.4 练习题 62
第7小时 设计模式 65
7.0 章节考点分析 65
7.1 设计模式的原则 66
7.2 创建型模式 66
7.3 结构型模式 68
7.4 行为型模式 71
7.5 练习题 73
第8小时 XML技术 77
8.0 章节考点分析 77
8.1 XML概述 78
8.2 XML命名空间 78
8.3 DTD 79
8.4 XML Schema 80
8.5 可扩展样式表语言 80
8.6 其他相关规范 80
8.7 练习题 81
第9小时 面向构件的软件设计 84
9.0 章节考点分析 84
9.1 构件的概念 85
9.2 构件的布线标准 85
9.3 构件框架 86
9.4 练习题 87
第10小时 构件平台与典型架构 93
10.0 章节考点分析 93
10.1 OMG方式 94
10.2 SUN公司的方式 95
10.3 Microsoft的方式 97
10.4 战略比较 98
10.5 练习题 99
第11小时 信息安全技术 102
11.0 章节考点分析 102
11.1 信息安全关键技术 103
11.2 信息安全管理和评估 105
11.3 信息安全保障体系 106
11.4 练习题 106
第12小时 系统安全架构设计 111
12.0 章节考点分析 111
12.1 信息系统安全架构描述 112
12.2 系统安全体系架构规划框架及其方法 113
12.3 网络安全体系架构设计 113
12.4 数据库系统的安全设计 114
12.5 数据库系统的安全设计 116
12.6 练习题 116
第13小时 系统的可靠性分析 120
13.0 章节考点分析 120
13.1 软件的可靠性 121
13.2 软件可靠性建模 122
13.3 软件可靠性评价 123
13.4 软件的可靠性设计与管理 124
13.5 练习题 124
第三篇 架构设计实践知识
第14小时 基于ODP的架构师实践 127
14.0 章节考点分析 127
14.1 基于ODP的架构开发过程 128
14.2 系统构想 128
14.3 需求分析 129
14.4 系统架构设计 129
14.5 系统转换、操作维护和系统移植 130
14.6 练习题 131
第15小时 架构师的管理实践 133
15.0 章节考点分析 133
15.1 VRAPS组织管理原则 134
15.2 概念框架 134
15.3 构想原则 135
15.4 节奏原则 136
15.5 预见原则 136
15.6 协作原则 137
15.7 简化原则 137
15.8 练习题 138
第16小时 层次式架构设计 139
16.0 章节考点分析 139
16.1 体系结构设计 140
16.2 表现层框框架设计 140
16.3 中间层架构设计 141
16.4 数据访问层设计（持久层架构设计） 142
16.5 数据架构规划与设计、标准BS分层式结构 143
16.6 练习题 144
第17小时 企业集成架构设计 147
17.0 章节考点分析 147
17.1 企业集成平台 148
17.2 企业集成平台的实现 150
17.3 企业集成的关键应用技术 151
17.4 面向整体解决方案的企业模型 151
17.5 练习题 152
第18小时 面向方面的编程 154
18.0 章节考点分析 154
18.1 方面编程的概念 155
18.2 AspectJ、Spring AOP 155
18.3 练习题 156
第19小时 嵌入式系统设计 157
19.0 章节考点分析 157
19.1 嵌入式系统基础 158
19.1.1 基础概念 158
19.1.2 系统基本结构 158
19.1.3 嵌入式操作系统 159
19.1.4 嵌入式数据库管理 159
19.1.5 嵌入式网络 159
19.2 嵌入式系统设计 160
19.2.1 开发模型与设计流程 160
19.2.2 嵌入式系统开发环境与设计模型 161
19.3 练习题 161
第20小时 面向服务的架构 164
20.0 章节考点分析 164
20.1 SOA的特性 165
20.2 SOA的用途 166
20.3 SOA的设计原则 166
20.4 SOA的实施过程 166
20.5 练习题 167
第21小时 案例研究 169
21.0 章节考点分析 169
21.1 价值驱动的体系架构 170
21.2 使用RUP和UML开发联邦企业体系框架 170
21.3 Web服务基础实现框架 170
21.4 案例分析实施步骤 171
21.5 练习题 171
第四篇 架构补充知识
第22小时 信息系统项目管理 174
22.0 章节考点分析 174
22.1 项目管理基础 175
22.2 项目管理知识体系构成 175
22.3 IPMP/PMP 176
22.4 PRINCE2 178
22.5 组织结构对项目的影响 179
22.6 信息系统项目的生命周期 181
22.7 信息系统项目典型生命周期模型 182
22.8 单个项目的管理过程 185
22.9 练习题 186
第23小时 信息技术服务知识 189
23.0 章节考点分析 189
23.1 产品、服务和信息技术服务 190
23.2 运维、运营和经营 190
23.3 IT治理 191
23.4 IT服务管理 191
23.5 项目管理 192
23.6 质量管理理论 193
23.7 信息安全管理 195
23.8 练习题 196
第24小时 管理科学基础知识 199
24.0 章节考点分析 199
24.1 最小生成树 200
24.2 最大流量 201
24.3 决策论 204
24.4 灵敏度分析 205
24.5 线性规划 206
24.6 动态规划 207
24.7 练习题 207
第25小时 知识产权与标准规范 211
25.0 章节考点分析 211
25.1 知识产权的基本范围 212
25.2 知识产权的特性 212
25.3 知识产权的内容 212
25.4 著作权法 213
25.5 商标法 215
25.6 商标法实施条例 215
25.7 计算机软件保护条例 215
25.8 软件工程国家标准 216
25.9 练习题 220
第26小时 专业英语 222
26.0 章节考点分析 222
26.1 架构风格 222
26.2 非功能需求 223
26.3 应用架构 223
26.4 软件架构重用 224
26.5 练习题 225
第五篇 典型模拟试题
第27小时 模拟试题I（上午基础知识） 227
第28小时 模拟试题I（下午案例分析题） 248
试题一（25分） 248
试题二（25分） 250
试题三（25分） 251
试题四（25分） 253
试题五（25分） 255
第29小时 模拟试题I（下午论文题） 258
试题一 论软件系统架构评估 258
试题二 论软件设计模式及其应用 260
试题三 论数据访问层设计技术及其应用 260
试题四 论微服务架构及其应用 261
试题五 论应用服务器基础软件 262
第30小时 模拟试题II（上午基础知识） 264
第31小时 模拟试题II（下午案例分析题） 288
试题一（25分） 288
试题二（25分） 289
试题三（25分） 292
试题四（25分） 294
试题五（25分） 296
第32小时 模拟试题II（下午论文题） 298
试题一 论企业信息化规划的实施与应用 298
试题二 论决策支持系统的开发与应用 299
试题三 论企业应用系统的数据持久层架构设计 301
试题四 论基于架构的软件设计方法及应用 302
参考文献 304
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>系统架构设计师考试32小时通关
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构Slash社群网站
序
前言
第一章 Slash：綜覽
1.1 Slashdot 的故事
1.2 成為 Slash 的宗師：教戰手冊
1.3 Slash 的使用者介面
1.4 Slash 的「作者」介面
1.5 Slash 的刊登週期
1.6 Slash 的內部架構
第二章 安裝 Slash
2.1 安裝須知
2.2 取得軟體
2.3 快速入門
2.4 安裝細節
2.5 進階安裝
第三章 基本管理
3.1 「管理員」選單
3.2 編輯「作者」
3.3 更改組態變數
第四章 編輯與更新「報導」
4.1 「報導」列表
4.2 「編輯報導」表單
4.3 陷阱
第五章 審閱核可「投稿」
5.1 「投稿」頁面
5.2 「投稿」列表
5.3 「審閱投稿」頁面
5.4 編輯使用者的「投稿」
第六章 「評論」、「過濾器」與「內容評比」
6.1 檢視評論
6.2 發表評論
6.3 評論過濾
6.4 評論評比
6.5 「評比」組態變數
第七章 管理「主題」與「專區」
7.1 管理「主題」
7.2 選擇「主題」與圖示
7.3 管理「專區」
7.4 慎選「專區」
第八章 管理 Slash 社群
8.1 如何扼殺社群發展
8.2 訂定社群基調
8.3 挖掘及生產內容
8.4 宣傳網站
8.5 管理「作者」
8.6 管理使用者
第九章 站台自訂入門
9.1 區塊與資訊框
9.2 管理使用者「投票」
第十章 進階自訂
10.1 更改外觀
10.2 自訂模板運作方式
10.3 風格套件與外掛套件
10.4 修改程式碼本身
10.5 國際化
第十一章 進階管理
11.1 任務
11.2 Slash 監控程式與任務
11.3 Slash 的工具
附錄 A Slash 的內部架構
附錄 B Slash 常用的資料庫表格
附錄 C Slash 的模版語言
附錄 D Slash 的應用程式介面
附錄 E Slash 的組態變數
附錄 F 中文版 Slash（Metalist）使用說明
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构Slash社群网站
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Serverless架构：无服务器应用与AWS Lambda
序一  XIII
序二  XV
前言  XVII
致谢  XIX
关于本书  XXI
关于作者  XXIII
关于封面  XXIV
第 1 部分..踏上征途  1
1 ..无服务器初探  3
1.1  来龙去脉  4
1.1.1  面向服务的架构与微服务  5
1.1.2  软件设计  6
1.2  无服务器架构原则  9
1.2.1  根据需要使用计算服务执行代码  9
1.2.2  编写单一用途的无状态函数  10
1.2.3  设计基于推送的、事件驱动的管道  10
1.2.4  创建更厚、更强大的前端  11
1.2.5  拥抱第三方服务  12
1.3  从服务器过渡到服务  12
1.4  无服务器的利与弊  13
1.4.1  决策驱动因素  13
1.4.2  什么时候使用无服务器  14
1.5  本章小结  15
2  架构与模式  17
2.1  使用场景  17
2.1.1  应用程序后端  18
2.1.2  数据处理与操作  18
2.1.3  实时分析  19
2.1.4  遗留 API 代理  19
2.1.5  计划服务  19
2.1.6  机器人（Bot）和技能（Skill）  20
2.2  架构  20
2.2.1  计算即后端  20
2.2.2  遗留 API 代理  25
2.2.3  混合  26
2.2.4  GraphQL  28
2.2.5  计算即胶水  29
2.2.6  实时处理  31
2.3  模式  32
2.3.1  命令模式  32
2.3.2  消息传输模式  33
2.3.3  优先级队列模式  35
2.3.4  扇出模式  36
2.3.5  管道和过滤器模式  37
2.4  本章小结  38
3 ..建立无服务器应用程序  39
3.1  24 小时视频  40
3.1.1  总体需求  41
3.1.2  Amazon Web Services（AWS）  42
3.1.3  创建第一个 Lambda 函数  44
3.1.4  命名你的 Lambda  46
3.1.5  本地测试  47
3.1.6  部署到 AWS  48
3.1.7  连接 S3 和 Lambda  50
3.1.8  在 AWS 中测试  51
3.1.9  观察日志  53
3.2  配置 Simple Notification Service  54
3.2.1  连接 SNS 和 S3  55
3.2.2  从 SNS 接收电子邮件  58
3.2.3  测试 SNS  58
3.3  设置视频权限  58
3.3.1  创建第二个函数  58
3.3.2  配置与安全  59
3.3.3  测试第二个函数  60
3.4  生成元数据  61
创建第三个函数和 FFprobe  61
3.5  收尾  64
3.6  练习  66
3.7  本章小结  67
4 ..设置你的云服务  69
4.1  安全模型和身份管理  70
4.1.1  创建和管理 IAM 用户  70
4.1.2  创建 IAM 组  73
4.1.3  创建角色  76
4.1.4  资源  77
4.1.5  权限和策略  77
4.2  日志与警报  79
4.2.1  设置日志  80
4.2.2  日志保留期  81
4.2.3  筛选器、指标和警报  81
4.2.4  搜索日志数据  83
4.2.5  S3 和日志  83
4.2.6  关于警报的更多操作  84
4.2.7  CloudTrail  88
4.3  成本  90
4.3.1  创建账单提醒  91
4.3.2  监控和优化成本  92
4.3.3  使用 Simple Monthly Calculator  93
4.3.4  计算 Lambda 和 API Gateway 的成本  94
4.4  练习  96
4.5  本章小结  97
第 2 部分..深入核心  99
5 ..身份认证和授权  101
5.1  无服务器环境中的身份认证  101
5.1.1  无服务器方法  102
5.1.2  Amazon Cognito  104
5.1.3  Auth0  105
5.2  为 24 小时视频增加身份认证  106
5.2.1  计划  106
5.2.2  直接调用 Lambda  107
5.2.3  24 小时视频网站  108
5.2.4  Auth0 配置  110
5.2.5  在网站中加入 Auth0  113
5.2.6  测试 Auth0 的集成  118
5.3  与 AWS 集成  119
5.3.1  用户信息 Lambda  120
5.3.2  API Gateway  124
5.3.3  映射  126
5.3.4  通过 API Gateway 调用 Lambda  130
5.3.5  自定义授权方  130
5.4  委托令牌  135
5.4.1  真实案例  136
5.4.2  开通委托令牌  136
5.5  练习  137
5.6  本章小结  137
6 ..编排者 Lambda  139
6.1  Lambda 内幕  139
6.1.1  事件模型和源  140
6.1.2  推送和拉取事件模型  141
6.1.3  并发执行  142
6.1.4  容器重用  143
6.1.5  冷 Lambda 和暖 Lambda  143
6.2  编程模型  145
6.2.1  函数处理程序  145
6.2.2  事件对象  145
6.2.3  上下文对象  147
6.2.4  回调函数  147
6.2.5  日志  148
6.3  版本管理、别名和环境变量  148
6.3.1  版本管理  148
6.3.2  别名  150
6.3.3  环境变量  152
6.4  使用命令行界面（CLI）  154
6.4.1  调用命令  155
6.4.2  创建和部署函数  155
6.5  Lambda 模式  157
6.5.1  异步瀑布  158
6.5.2  序列与并行  163
6.5.3  使用库  164
6.5.4  把逻辑移到另一个文件中  167
6.6  测试 Lambda 函数  167
6.6.1  在本地测试  167
6.6.2  编写测试  168
6.6.3  在 AWS 中测试  171
6.7  练习  173
6.8  本章小结  173
7 ..API.Gateway  175
7.1  作为接口的 API Gateway  176
7.1.1  和 AWS 服务集成  177
7.1.2  缓存、限制与日志  177
7.1.3  阶段和版本管理  178
7.1.4  脚本  178
7.2  使用 API Gateway  178
7.2.1  计划  180
7.2.2  创建资源和方法  181
7.2.3  配置方法执行  185
7.2.4  Lambda 函数  187
7.2.5  更新网站  191
7.3  优化网关  194
7.3.1  限制  194
7.3.2  日志  197
7.3.3  缓存  199
7.4  阶段和版本管理  202
7.4.1  创建阶段变量  202
7.4.2  使用阶段变量  203
7.4.3  版本管理  205
7.5  练习  205
7.6  本章小结  206
第 3 部分..拓展架构  207
8 ..存储  209
8.1  更智能的存储  209
8.1.1  版本控制  210
8.1.2  托管静态网站  212
8.1.3  存储类别  214
8.1.4  对象生命周期管理  216
8.1.5  转移加速  217
8.1.6  事件通知  219
8.2  安全上传  220
8.2.1  架构  221
8.2.2  上传策略 Lambda  222
8.2.3  S3 CORS 配置  228
8.2.4  在网站中上传  228
8.3  限制对文件的访问  233
8.3.1  禁止公开访问  233
8.3.2  生成预签名 URL  233
8.4  练习  234
8.5  本章小结  235
9 ..数据库  237
9.1  Firebase 简介  238
9.1.1  数据结构  238
9.1.2  安全规则  240
9.2  为 24 小时视频添加 Firebase  241
9.2.1  架构  242
9.2.2  设置 Firebase  243
9.2.3  修改转码视频 Lambda  245
9.2.4  Transcode Video Firebase Update 函数  250
9.2.5  连接 Lambda  251
9.2.6  网站  253
9.2.7  端到端测试  258
9.3  安全访问文件  259
9.3.1  签名 URL Lambda  260
9.3.2  API Gateway 设置  261
9.3.3  再次更新网站  262
9.3.4  提升性能  262
9.3.5  提升 Firebase 安全性  265
9.4  练习  270
9.5  本章小结  270
10 ..最后一英里  271
10.1  部署与框架  271
10.2  迈向更好的微服务  272
10.3  Step Functions  277
10.4  AWS Marketplace  283
10.5  未来之路  285
A ..为无服务器架构而生的服务  287
B ..安装和设置  293
C ..身份认证和授权的更多信息  305
D ..再探 Lambda 内幕  311
E ..模型和映射  317
F ..S3 事件消息结构  335
G ..Serverless.Framework 和 SAM  337
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Serverless架构：无服务器应用与AWS Lambda
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>RISC-V架构与嵌入式开发快速入门
第 1章 进入32位时代，谁能成为下一个80511
1.1 磨刀不误砍柴工—CPU基础知识介绍1
1.1.1 ISA—CPU的灵魂2
1.1.2 CISC与RISC3
1.1.3 32位与64位架构4
1.1.4 ISA众生相5
1.1.5 CPU的领域之分9
1.1.6 8位时代的传奇“前辈”—805110
1.1.7 IoT的崛起—32位时代的到来11
1.2 无敌是多么寂寞—ARM统治着的世界11
1.2.1 独乐乐与众乐乐—ARM公司的盈利模式12
1.2.2 小个子有大力量—无处不在的Cortex-M系列14
1.2.3 移动王者—Cortex-A系列在手持设备领域的巨大成功16
1.2.4 进击的巨人—ARM进军PC与服务器领域的雄心18
1.2.5 游戏终结者之ARM19
1.3 东边日出西边雨，道是无晴却有晴—RISC-V登场19
1.4 RISC-V和其他开放架构有何不同21
1.4.1 “平民英雄”—OpenRISC22
1.4.2 “豪门显贵”—SPARC22
1.4.3 “名校优生”—RISC-V23
1.5 结语：进入32位时代，谁能成为深嵌入式领域的下一个8051？23
第 2章 开源蜂鸟E203超低功耗RISC-V Core与SoC25
2.1 乱花渐欲迷人眼25
2.2 与众不同的蜂鸟E203处理器25
2.3 蜂鸟虽小，五脏俱全—蜂鸟E203简介26
2.4 蜂鸟E203性能指标27
2.5 蜂鸟E203配套SoC28
第3章 大道至简—RISC-V架构之魂29
3.1 简单就是美—RISC-V架构的设计哲学29
3.1.1 无病一身轻—架构的篇幅30
3.1.2 能屈能伸—模块化的指令集31
3.1.3 浓缩的都是精华—指令的数量31
3.2 RISC-V指令集架构简介32
3.2.1 模块化的指令子集32
3.2.2 可配置的通用寄存器组33
3.2.3 规整的指令编码33
3.2.4 简洁的存储器访问指令34
3.2.5 高效的分支跳转指令35
3.2.6 简洁的子程序调用36
3.2.7 无条件码执行36
3.2.8 无分支延迟槽37
3.2.9 零开销硬件循环37
3.2.10 简洁的运算指令38
3.2.11 优雅的压缩指令子集38
3.2.12 特权模式39
3.2.13 CSR寄存器40
3.2.14 中断和异常40
3.2.15 矢量指令子集40
3.2.16 自定制指令扩展40
3.2.17 总结与比较41
第4章 RISC-V架构的中断和异常43
4.1 中断和异常概述43
4.1.1 中断概述43
4.1.2 异常概述44
4.1.3 广义上的异常44
4.2 RISC-V架构异常处理机制46
4.2.1 进入异常47
4.2.2 退出异常50
4.2.3 异常服务程序50
4.3 RISC-V架构中断定义51
4.3.1 中断类型51
4.3.2 中断屏蔽54
4.3.3 中断等待55
4.3.4 中断优先级与仲裁55
4.3.5 中断嵌套56
4.3.6 总结比较57
4.4 RISC-V架构异常相关CSR寄存器57
4.5 蜂鸟E203的中断和异常实现58
第5章 开源蜂鸟E203 MCU SoC总体介绍59
5.1 Freedom E310 SoC简介59
5.2 蜂鸟E203 MCU SoC简介60
5.3 蜂鸟E203 MCU SoC框图60
5.4 蜂鸟E203 MCU SoC存储资源61
5.4.1 片上存储资源61
5.4.2 片外Flash存储资源61
5.5 蜂鸟E203 MCU SoC外设资源62
5.6 蜂鸟E203 MCU SoC地址分配62
5.7 蜂鸟E203 MCU SoC时钟域划分63
5.8 蜂鸟E203 MCU SoC电源域划分64
5.9 蜂鸟E203 MCU SoC低功耗模式64
5.10 蜂鸟E203 MCU SoC的全局复位65
5.11 蜂鸟E203 MCU SoC的上电流程控制66
5.12 蜂鸟E203 MCU SoC芯片引脚表67
5.13 蜂鸟E203 MCU SoC的GPIO引脚分配68
5.14 蜂鸟E203 MCU SoC的中断处理70
5.14.1 蜂鸟E203处理器核的异常和中断处理70
5.14.2 蜂鸟E203处理器的中断接口71
5.14.3 CLINT模块生成计时器中断和软件中断72
5.14.4 PLIC管理多个外部中断73
第6章 开源蜂鸟E203 MCU SoC外设介绍77
6.1 蜂鸟E203 MCU SoC外设总述77
6.2 PLIC78
6.3 CLINT78
6.4 LCLKGEN78
6.4.1 LCLKGEN简介78
6.4.2 LCLKGEN寄存器列表78
6.5 HCLKGEN79
6.5.1 HCLKGEN简介79
6.5.2 HCLKGEN寄存器列表79
6.6 GPIO79
6.6.1 GPIO特性79
6.6.2 GPIO寄存器列表80
6.6.3 I O结构和IOF模式80
6.6.4 SoC各外设复用GPIO引脚83
6.6.5 GPIO中断83
6.6.6 GPIO_VALUE寄存器84
6.6.7 GPIO_INPUT_EN寄存器84
6.6.8 GPIO_OUTPUT_EN寄存器85
6.6.9 GPIO_PORT寄存器85
6.6.10 GPIO_PUE寄存器85
6.6.11 GPIO_DS寄存器85
6.6.12 GPIO_OUTPUT_XOR寄存器85
6.6.13 GPIO_RISE_IE、GPIO_RISE_IP等寄存器85
6.7 SPI86
6.7.1 SPI背景知识简介86
6.7.2 SPI特性88
6.7.3 SPI寄存器列表89
6.7.4 SPI接口数据线90
6.7.5 通过SPI_SCKDIV寄存器配置SCK时钟频率90
6.7.6 通过SPI_SCKMODE寄存器配置SCK的极性与相位90
6.7.7 通过SPI_CSID寄存器配置SPI使能信号92
6.7.8 通过SPI_CSDEF寄存器配置使能信号的空闲值92
6.7.9 通过SPI_CSMODE寄存器配置使能信号的行为92
6.7.10 通过SPI_DELAY0和SPI_DELAY1寄存器配置使能信号的行为93
6.7.11 通过SPI_FCTRL寄存器使能QSPI0的Flash XiP模式94
6.7.12 通过SPI_FFMT寄存器控制QSPI0读取外部Flash95
6.7.13 通过SPI_FMT寄存器配置传输参数97
6.7.14 通过SPI_TXDATA寄存器发送数据97
6.7.15 通过SPI_RXDATA寄存器接收数据98
6.7.16 通过SPI_TXMARK寄存器配置发送中断阈值100
6.7.17 通过SPI_RXMARK寄存器配置接收中断阈值100
6.7.18 通过SPI_IE和SPI_IP寄存器控制中断101
6.8 I2C102
6.8.1 I2C背景知识简介102
6.8.2 I2C特性103
6.8.3 I2C寄存器列表103
6.8.4 I2C接口数据线104
6.8.5 通过I2C_PRERlo和I2C_PRERhi寄存器配置SCL时钟频率104
6.8.6 通过I2C_CTR寄存器配置功能和中断使能104
6.8.7 I2C模块产生中断105
6.8.8 通过I2C_TXR和I2C_RXR寄存器发送和接收数据105
6.8.9 通过I2C_CR和I2C_SR寄存器发起命令和查看状态106
6.8.10 初始化I2C模块的序列107
6.8.11 通过I2C模块向外部从设备写数据的常用序列107
6.8.12 通过I2C模块从外部从设备读数据的常用序列108
6.9 UART109
6.9.1 UART背景知识简介109
6.9.2 UART特性110
6.9.3 UART寄存器列表110
6.9.4 UART接口数据线111
6.9.5 通过UART_TXDATA寄存器发送数据111
6.9.6 通过UART_RXDATA寄存器接收数据112
6.9.7 通过UART_TXCTRL寄存器进行发送控制113
6.9.8 通过UART_RXCTRL寄存器进行接收控制113
6.9.9 通过UART_IE和UART_IP寄存器控制中断114
6.9.10 通过UART_DIV寄存器配置波特率115
6.10 PWM116
6.10.1 PWM背景知识简介116
6.10.2 PWM特性和结构图116
6.10.3 PWM寄存器列表117
6.10.4 通过PWMCFG寄存器进行配置118
6.10.5 计数器计数值PWMCOUNT寄存器和PWM周期119
6.10.6 计数器比较值PWMS寄存器120
6.10.7 PWM接口数据线121
6.10.8 产生左对齐或者右对齐的脉冲信号121
6.10.9 产生居中对齐的脉冲信号122
6.10.10 配置pwmcmpgang结连产生任意形状的脉冲信号124
6.10.11 配置pwmdeglitch防止输出毛刺124
6.10.12 PWM产生中断124
6.11 WDT125
6.11.1 WDT背景知识简介125
6.11.2 WDT特性和结构图125
6.11.3 WDT寄存器列表126
6.11.4 通过WDOGCFG寄存器进行配置127
6.11.5 计数器计数值WDOGCOUNT寄存器128
6.11.6 通过WDOGKEY寄存器解锁128
6.11.7 通过WDOGFEED寄存器喂狗129
6.11.8 计数器比较值WDOGS寄存器129
6.11.9 通过WDOGCMP寄存器配置阈值130
6.11.10 WDT产生全局复位130
6.11.11 WDT产生中断130
6.12 RTC131
6.12.1 RTC背景知识简介131
6.12.2 RTC特性和结构图131
6.12.3 RTC寄存器列表131
6.12.4 通过RTCCFG寄存器进行配置132
6.12.5 计数器计数值RTCHI RTCLO寄存器133
6.12.6 计数器比较值RTCS寄存器133
6.12.7 通过RTCCMP寄存器配置阈值134
6.12.8 RTC产生中断134
6.13 PMU134
6.13.1 PMU背景知识简介134
6.13.2 PMU特性和结构图135
6.13.3 PMU寄存器列表136
6.13.4 通过PMUKEY寄存器解锁136
6.13.5 通过PMUSLEEP寄存器进入休眠模式137
6.13.6 通过PMUSLEEPI寄存器配置休眠指令序列137
6.13.7 通过PMUBACKUP寄存器保存关键信息139
6.13.8 通过PMUIE寄存器配置唤醒条件139
6.13.9 通过PMUWAKEUPI寄存器配置唤醒指令序列140
6.13.10 通过PMUCAUSE寄存器查看唤醒原因141
第7章 开源蜂鸟E203 MCU开发板与调试器143
7.1 蜂鸟E203 MCU开发板143
7.2 蜂鸟E203 JTAG调试器143
第8章 编译过程简介145
8.1 GCC工具链介绍145
8.1.1 GCC工具链概述145
8.1.2 Binutils146
8.1.3 C运行库147
8.1.4 GCC命令行选项148
8.2 准备工作148
8.2.1 Linux安装148
8.2.2 准备Hello World程序148
8.3 编译过程149
8.3.1 预处理149
8.3.2 编译150
8.3.3 汇编150
8.3.4 链接151
8.3.5 一步到位的编译153
8.4 分析ELF文件153
8.4.1 ELF文件介绍153
8.4.2 ELF文件的段154
8.4.3 查看ELF文件154
8.4.4 反汇编155
8.5 嵌入式系统编译的特殊性156
8.6 本章小结156
第9章 嵌入式开发特点与RISC-V GCC工具链158
9.1 嵌入式系统开发特点158
9.1.1 交叉编译和远程调试158
9.1.2 移植newlib或newlib-nano作为C运行库159
9.1.3 嵌入式引导程序和中断异常处理160
9.1.4 嵌入式系统链接脚本160
9.1.5 减少代码体积161
9.1.6 支持printf函数161
9.1.7 提供板级支持包162
9.2 RISC-V GCC工具链简介162
9.2.1 RISC-V GCC工具链种类162
9.2.2 riscv-none-embed工具链下载163
9.2.3 RISC-V GCC工具链的（?Cmarch=）和（?Cmabi=）选项164
9.2.4 RISC-V GCC工具链的（?Cmcmodel=）选项168
9.2.5 RISC-V GCC工具链的其他选项169
9.2.6 RISC-V GCC工具链的预定义宏170
9.2.7 RISC-V GCC工具链使用实例170
第 10章 RISC-V汇编语言程序设计171
10.1 汇编语言简介171
10.2 RISC-V汇编程序概述172
10.3 RISC-V汇编指令173
10.4 RISC-V汇编程序伪操作173
10.5 RISC-V汇编程序示例177
10.5.1 定义标签177
10.5.2 定义宏178
10.5.3 定义常数178
10.5.4 立即数赋值178
10.5.5 标签地址赋值179
10.5.6 设置浮点舍入模式179
10.5.7 完整实例180
10.6 在C C 程序中嵌入汇编181
10.6.1 GCC内联汇编简述181
10.6.2 GCC内联汇编“输出操作数”和“输入操作数”部分182
10.6.3 GCC内联汇编“可能影响的寄存器或存储器”部分183
10.6.4 GCC内联汇编参考实例一184
10.6.5 GCC内联汇编参考实例二185
10.6.6 小结186
10.7 在汇编中调用C C 函数186
10.8 本章小结187
第 11章 基于HBird-E-SDK平台的软件开发与运行188
11.1 HBird-E-SDK平台简介188
11.2 HBird-E-SDK平台代码结构189
11.3 HBird-E-SDK板级支持包解析190
11.3.1 移植了Newlib桩函数190
11.3.2 支持了printf函数192
11.3.3 提供系统链接脚本193
11.3.4 系统启动引导程序198
11.3.5 系统异常和中断处理202
11.3.6 减少代码体积206
11.4 使用HBird-E-SDK开发和编译程序208
11.4.1 在HBird-E-SDK环境中安装工具链208
11.4.2 在HBird-E-SDK环境中开发程序210
11.4.3 编译使得程序从Flash直接运行211
11.4.4 编译使得程序从ITCM中运行212
11.4.5 编译使得程序从Flash上载至ITCM中运行213
11.5 使用HBird-E-SDK下载程序213
11.5.1 JTAG调试器与MCU原型开发板的连接213
11.5.2 设置JTAG调试器在Linux系统中的USB权限214
11.5.3 将程序下载至MCU原型开发板216
11.6 在MCU原型开发板上运行程序216
11.6.1 程序从Flash直接运行217
11.6.2 程序从ITCM中运行217
11.6.3 程序从Flash上载至ITCM中运行218
11.7 使用GDB远程调试程序218
11.7.1 调试器工作原理218
11.7.2 GDB常用操作示例220
11.7.3 使用GDB调试Hello World示例221
第 12章 开源蜂鸟E203 MCU的更多示例程序226
12.1 Dhrystone示例程序226
12.1.1 Dhrystone示例程序功能简介226
12.1.2 Dhrystone示例程序代码结构229
12.1.3 运行Dhrystone229
12.2 CoreMark示例程序231
12.2.1 CoreMark示例程序功能简介231
12.2.2 CoreMark示例程序代码结构232
12.2.3 运行CoreMark233
12.3 Demo_IASM示例程序234
12.3.1 Demo_IASM示例程序功能简介234
12.3.2 Demo_IASM示例程序代码结构234
12.3.3 Demo_IASM示例程序源码解析235
12.3.4 运行Demo_IASM235
12.4 Demo_GPIO示例程序236
12.4.1 Demo_GPIO示例程序功能简介236
12.4.2 Demo_GPIO示例程序代码结构237
12.4.3 Demo_GPIO示例程序源码分析237
12.4.4 运行Demo_GPIO243
12.5 中断嵌套244
第 13章 Windows IDE集成开发调试环境245
13.1 MCU Eclipse IDE简介与安装245
13.1.1 MCU Eclipse IDE简介245
13.1.2 RISC-V MCU Eclipse下载246
13.1.3 RISC-V MCU Eclipse安装247
13.2 启动Eclipse248
13.3 创建Hello World项目249
13.4 配置Hello World项目253
13.4.1 配置工具链路径253
13.4.2 配置项目的编译和链接选项256
13.4.3 配置项目的BSP262
13.4.4 配置项目的包含路径和文件265
13.5 编译Hello World项目267
13.6 运行Hello World项目269
13.6.1 安装JTAG调试器在Windows系统中的USB驱动269
13.6.2 通过Eclipse下载程序至MCU开发板270
13.6.3 在MCU开发板上运行程序274
13.7 调试Hello World项目276
13.8 拓展一：基于MCU Eclipse运行调试demo_gpio示例280
13.9 拓展二：基于MCU Eclipse运行调试dhrystone示例281
第 14章 开源蜂鸟E203 MCU开发板移植RTOS283
14.1 RTOS简述283
14.2 常用实时操作系统概述284
14.3 FreeRTOS简介285
14.4 蜂鸟E203 MCU移植RTOS286
附录A RISC-V架构指令集介绍287
A.1 RV32GC架构概述287
A.2 RV32E架构概述288
A.3 蜂鸟E203支持的指令列表288
A.4 寄存器组288
A.4.1 通用寄存器组289
A.4.2 CSR寄存器290
A.5 指令PC290
A.6 寻址空间划分290
A.7 大端格式或小端格式290
A.8 工作模式290
A.9 Hart概念291
A.10 复位状态291
A.11 中断和异常292
A.12 存储器地址管理292
A.13 存储器模型292
A.14 指令类型293
A.14.1 RV32IMAFDC指令列表293
A.14.2 基本整数指令（RV32I）293
A.14.3 整数乘法和除法指令（RV32M指令子集）302
A.14.4 浮点指令（RV32F，RV32D指令子集）304
A.14.5 存储器原子操作指令（RV32A指令子集）315
A.14.6 16位压缩指令（RV32C指令子集）318
A.15 伪指令320
A.16 指令编码320
附录B RISC-V架构CSR寄存器介绍321
B.1 蜂鸟E203支持的CSR寄存器列表321
B.2 RISC-V标准CSR322
B.2.1 misa322
B.2.2 mvendorid323
B.2.3 marchid323
B.2.4 mimpid323
B.2.5 mhartid324
B.2.6 fflags324
B.2.7 frm324
B.2.8 fcsr324
B.2.9 mstatus324
B.2.10 mtvec326
B.2.11 mepc326
B.2.12 mcause327
B.2.13 mtval (mbadaddr)327
B.2.14 mie328
B.2.15 mip328
B.2.16 mscratch328
B.2.17 mcycle和mcycleh329
B.2.18 minstret和minstreth329
B.2.19 mtime、mtimecmp和msip329
B.3 蜂鸟E203自定义CSR330mcounterstop330
附录C RISC-V架构的PLIC介绍331
C.1 概述331
C.2 PLIC中断目标332PLIC中断目标之阈值333
C.3 PLIC中断源333
C.3.1 PLIC中断源之闸口（Gateway）和IP334
C.3.2 PLIC中断源之编号（ID）334
C.3.3 PLIC中断源之优先级（Priority）334
C.3.4 PLIC中断源之中断使能（Enable）334
C.4 PLIC中断处理机制335
C.4.1 PLIC中断通知机制（Notification）335
C.4.2 PLIC中断响应机制（Claim）335
C.4.3 PLIC中断完成机制（Completion）336
C.4.4 PLIC中断完整流程336
C.5 PLIC寄存器总结337
C.6 总结与比较339
附录D 存储器模型背景介绍340
D.1 为何要有存储器模型的概念340
D.2 存储器模型定义了什么341
D.2.1 按序一致性模型341
D.2.2 松散一致性模型342
D.2.3 释放一致性模型342
D.2.4 存储器模型总结342
D.3 存储器模型应用实例343
D.4 RISC-V架构的存储器模型344
附录E 存储器原子操作指令背景介绍345
E.1 什么是“上锁”问题345
E.2 通过原子操作解决“上锁”问题346
E.3 通过互斥操作解决“上锁”问题346
E.4 RISC-V架构的相关指令348
附录F RISC-V指令编码列表349
F.1 RV32I指令编码349
F.2 RV32M指令编码350
F.3 RV32A指令编码350
F.4 RV32F指令编码350
F.5 RV32D指令编码351
F.6 RVC指令编码351
附录G RISC-V伪指令列表353
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>RISC-V架构与嵌入式开发快速入门
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>FPGA芯片架构设计与实现
第1 章 FPGA 架构总体设计 ????????????????????????????????????????????????????????????????????????? 1
1．1 FPGA 芯片研制流程?????????????????????????????????????????????????????????????????????????? 1
1．2 FPGA 架构设计流程?????????????????????????????????????????????????????????????????????????? 7
1．3 FPGA 规模和资源划分 ????????????????????????????????????????????????????????????????????? 17
1．4 FPGA 中功能模块划分 ????????????????????????????????????????????????????????????????????? 20
本章参考文献 ?????????????????????????????????????????????????????????????????????????????????????? 26
第2 章 FPGA 中时钟网络 ?????????????????????????????????????????????????????????????????????????? 30
2．1 简介 ???????????????????????????????????????????????????????????????????????????????????????????? 30
2．2 FPGA CDN 建模 ????????????????????????????????????????????????????????????????????????????? 33
2．3 时钟网络设计方法 ?????????????????????????????????????????????????????????????????????????? 43
2．4 时钟网络的灵活性 ?????????????????????????????????????????????????????????????????????????? 48
2．5 路由级联 ?????????????????????????????????????????????????????????????????????????????????????? 51
2．6 仿真实验 ?????????????????????????????????????????????????????????????????????????????????????? 55
2．7 时钟网络热学建模 ?????????????????????????????????????????????????????????????????????????? 61
2．8 仿真实验 ?????????????????????????????????????????????????????????????????????????????????????? 62
本章参考文献 ?????????????????????????????????????????????????????????????????????????????????????? 66
第3 章 FPGA 中电源/地线网络和漏电流 ??????????????????????????????????????????????????????? 68
3．1 电源/地线网络 ??????????????????????????????????????????????????????????????????????????????? 68
3．2 IR-DROP 分析与优化 ???????????????????????????????????????????????????????????????????????? 71
3．3 漏电流组成 ??????????????????????????????????????????????????????????????????????????????????? 73
3．4 降低漏电流的方法 ?????????????????????????????????????????????????????????????????????????? 74
3．5 基于VIA 分布的IR-DROP 分析 ??????????????????????????????????????????????????????????? 77
3．6 仿真实验 ?????????????????????????????????????????????????????????????????????????????????????? 81
3．7 不均匀测试点的IR-DROP 求解 ??????????????????????????????????????????????????????????? 87
3．8 FPGA 电源网络IR-DROP 分析 ???????????????????????????????????????????????????????????? 89
本章参考文献 ?????????????????????????????????????????????????????????????????????????????????????? 94
第4 章 FPGA 中可编程逻辑单元 ????????????????????????????????????????????????????????????????? 98
4．1 基于多路选择器的逻辑单元 ?????????????????????????????????????????????????????????????? 98
4．2 基于四输入LUT 的可编程逻辑单元的设计 ?????????????????????????????????????????? 102
4．3 LUT 的模型与实现 ???????????????????????????????????????????????????????????????????????? 103
4．4 LUT 的输入数目K 的确定 ??????????????????????????????????????????????????????????????? 106
4．5 进位逻辑 ????????????????????????????????????????????????????????????????????????????????????? 109
4．6 基于查找表结构的FPGA 的不足 ??????????????????????????????????????????????????????? 115
4．7 AIC 结构逻辑簇 ???????????????????????????????????????????????????????????????????????????? 117
4．8 基于AIC 结构FPGA 的逻辑簇 ????????????????????????????????????????????????????????? 120
4．9 面向AIC 的映射工具及结构评估平台 ???????????????????????????????????????????????? 124
4．10 结构特征匹配的AIC 簇互连优化 ???????????????????????????????????????????????????? 125
4．11 仿真分析和比较 ?????????????????????????????????????????????????????????????????????????? 131
本章参考文献 ????????????????????????????????????????????????????????????????????????????????????? 133
第5 章 FPGA 中可编程I/O 模块 ????????????????????????????????????????????????????????????????? 136
5．1 可编程I/O 系统结构 ?????????????????????????????????????????????????????????????????????? 136
5．2 IOE 中的可编程输入缓冲器设计 ??????????????????????????????????????????????????????? 138
5．3 IOE 中的可编程输出缓冲器设计 ??????????????????????????????????????????????????????? 144
5．4 可编程I/O 的后端版图设计?????????????????????????????????????????????????????????????? 156
5．5 高可靠I/O 模块的后端版图与测试 ????????????????????????????????????????????????????? 166
5．6 可编程I/O 的供电策略 ??????????????????????????????????????????????????????????????????? 172
5．7 全芯片IO 的ESD 技术 ??????????????????????????????????????????????????????????????????? 173
本章参考文献 ????????????????????????????????????????????????????????????????????????????????????? 179
第6 章 FPGA 中DDR 存储器接口 ?????????????????????????????????????????????????????????????? 182
6．1 DDR SDRAM 芯片的工作原理 ?????????????????????????????????????????????????????????? 182
6．2 FPGA 芯片中DDR 存储器接口系统设计 ????????????????????????????????????????????? 184
6．3 DDR 存储器接口控制器的设计和验证 ???????????????????????????????????????????????? 191
6．4 延时锁相技术 ??????????????????????????????????????????????????????????????????????????????? 194
6．5 延时锁定环电路的分析与对比 ?????????????????????????????????????????????????????????? 196
6．6 数字延时锁定环电路的性能分析与优化 ?????????????????????????????????????????????? 201
6．7 延时锁定环线性模型与稳定性分析 ???????????????????????????????????????????????????? 205
本章参考文献 ????????????????????????????????????????????????????????????????????????????????????? 209
第7 章 FPGA 中数字延时锁定环 ???????????????????????????????????????????????????????????????? 213
7．1 实现相移的全数字延迟锁定环 ?????????????????????????????????????????????????????????? 213
7．2 数字控制延时链 ???????????????????????????????????????????????????????????????????????????? 215
7．3 时间数字转换器 ???????????????????????????????????????????????????????????????????????????? 220
7．4 双向移位计数器 ???????????????????????????????????????????????????????????????????????????? 221
7．5 鉴相器与锁定逻辑 ????????????????????????????????????????????????????????????????????????? 222
7．6 延迟锁定环的版图设计 ??????????????????????????????????????????????????????????????????? 224
7．7 延迟锁定环环路的仿真 ??????????????????????????????????????????????????????????????????? 224
7．8 芯片的物理实现与测试平台 ????????????????????????????????????????????????????????????? 225
7．9 DDR 接口的数据通路的测试验证 ?????????????????????????????????????????????????????? 227
7．10 数字延时锁定环的测试 ????????????????????????????????????????????????????????????????? 229
7．11 数字占空比矫正电路的测试 ???????????????????????????????????????????????????????????? 232
本章参考文献 ????????????????????????????????????????????????????????????????????????????????????? 234
第8 章 FPGA 中连线连接盒 ?????????????????????????????????????????????????????????????????????? 236
8．1 引言 ??????????????????????????????????????????????????????????????????????????????????????????? 236
8．2 问题分析 ????????????????????????????????????????????????????????????????????????????????????? 237
8．3 利用模拟退火算法优化CB 拓扑结构 ?????????????????????????????????????????????????? 241
8．4 实验及结果分析 ???????????????????????????????????????????????????????????????????????????? 246
8．5 连线开关盒的电路结构设计方法 ??????????????????????????????????????????????????????? 251
本章参考文献 ????????????????????????????????????????????????????????????????????????????????????? 259
第9 章 FPGA 中互连线段长度分布 ????????????????????????????????????????????????????????????? 261
9．1 所提优化方法的基本思路 ???????????????????????????????????????????????????????????????? 261
9．2 以面积延时积最小为目标的优化 ??????????????????????????????????????????????????????? 265
9．3 针对所提优化方法的讨论 ???????????????????????????????????????????????????????????????? 268
9．4 设计实验 ????????????????????????????????????????????????????????????????????????????????????? 269
9．5 FPGA 芯片的设计实现 ???????????????????????????????????????????????????????????????????? 270
9．6 芯片的测试准备 ???????????????????????????????????????????????????????????????????????????? 272
本章参考文献 ????????????????????????????????????????????????????????????????????????????????????? 275
第10 章 FPGA 中的配置模块 ???????????????????????????????????????????????????????????????????? 277
10．1 配置系统的基本组成及特点 ???????????????????????????????????????????????????????????? 277
10．2 配置系统的功能需求 ???????????????????????????????????????????????????????????????????? 279
10．3 配置系统的硬件结构分析 ?????????????????????????????????????????????????????????????? 281
10．4 配置码流协议的结构及其对配置系统的影响 ??????????????????????????????????????? 286
10．5 配置系统总体框架 ??????????????????????????????????????????????????????????????????????? 292
10．6 配置码流协议的设计 ???????????????????????????????????????????????????????????????????? 297
10．7 配置系统的电路设计与实现 ???????????????????????????????????????????????????????????? 300
10．8 配置系统采用的验证工具与方法 ?????????????????????????????????????????????????????? 305
10．9 配置系统的验证方案与功能点的抽取 ???????????????????????????????????????????????? 310
10．10 配置系统功能验证平台的设计 ??????????????????????????????????????????????????????? 312
10．11 配置系统验证结果 ?????????????????????????????????????????????????????????????????????? 319
本章参考文献 ????????????????????????????????????????????????????????????????????????????????????? 324
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>FPGA芯片架构设计与实现
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实战Nginx
第1部分 基础篇
第1章 Nginx简介
1.1 常用的Web服务器简介
1.2 Nginx简介
1.3 选择Nginx的理由
1.4 Nginx与Apache、Lighttpd的综合对比
第2章 Nginx服务器的安装与配置
2.1 安装Nginx服务器所需要的系统资源
2.2 Nginx的下载
2.3 Nginx的安装
2.4 Nginx的启动、停止、平滑重启
2.5 Nginx的平滑重启
2.6 Nginx的信号控制
2.7 Nginx的平滑升级
第2部分 进阶篇
第3章 Nginx的基本配置与优化
3.1 Nginx的完整配置示例
3.2 Nginx的虚拟主机配置
3.3 Nginx的日志文件配置与切割
3.4 Nginx的压缩输出配置
3.5 Nginx的自动列目录配置
3.6 Nginx的浏览器本地缓存设置
第4章 Nginx与PHP（FastCGI）的安装、配置与优化
4.1 获取相关开源程序
4.2 安装PHP 5.2.10（FastCGI模式）
4.3 安装Nginx 0.8.15
4.4 配置开机自动启动Nginx + PHP
4.5 优化Linux内核参数
4.6 在不停止Nginx服务的情况下平滑变更Nginx配置
4.7 编写每天定时切割Nginx日志的脚本
第5章 Nginx与JSP、ASP.NET、Perl的安装与配置
5.1 Nginx与JSP（Tomcat）在Linux上的安装、配置
5.2 Nginx与ASP.NET（Mono+FastCGI）在Linux上的安装、配置
5.3 Nginx与Perl（FastCGI）在Linux上的安装、配置
第6章 Nginx HTTP负载均衡和反向代理的配置与优化
6.1 什么是负载均衡和反向代理
6.2 常见的Web负载均衡方法
6.3 Nginx负载均衡与反向代理的配置实例
6.4 Nginx负载均衡的HTTP Upstream 模块
6.5 Nginx负载均衡服务器的双机高可用
第7章 Nginx的Rewrite规则编写实例
7.1 什么是Nginx的Rewrite规则
7.2 Nginx Rewrite规则相关指令
7.3 PCRE正则表达式语法
7.4 Nginx的Rewrite规则编写实例
7.5 Nginx与Apache的Rewrite规则实例对比
第8章 Nginx模块开发
8.1 Nginx模块概述
8.2 Nginx模块编写实践
第9章 Nginx的Web缓存服务与新浪网的开源NCACHE模块
9.1 什么是Web缓存？
9.2 Nginx的Web缓存服务
9.3 新浪网开源软件项目——基于Nginx的NCache网页缓存系统
第3部分 实战篇
第10章 Nginx在国内知名网站中的应用案例
10.1 Nginx反向代理与负载均衡类网站应用案例
10.2 Nginx+PHP类网站应用案例
第11章 Nginx的非典型应用实例
11.1 用HTTPS（SSL）构建一个安全的Nginx Web服务器
11.2 采用Nginx搭建FLV视频服务器
11.3 Nginx+PHP+MySQL在小内存VPS服务器上的优化
11.4 采用Nginx搭建正向代理服务器
第4部分 模块篇
第12章 Nginx的核心模块
12.1 主模块指令
12.2 主模块变量
12.3 事件模块指令
第13章 Nginx的标准HTTP模块
13.1 HTTP的核心模块
13.2 HTTP Upstream模块
13.3 Http Access 模块
13.4 HTTP Auth Basic 模块
13.5 Http Autoindex 模块
13.6 Http Browser 模块
13.7 Http Charset 模块
13.8 Http Empty Gif模块
13.9 Http Fcgi 模块
13.10 geo 模块
13.11 Gzip 模块
13.12 Http Headers模块
13.13 Http Index模块
13.14 HTTP Referer模块
13.15 Http Limit Zone模块
13.16 Http Limit Req模块
13.17 Http Log模块
13.18 Http Map模块
13.19 Http Memcached模块
13.20 Http Proxy模块
第14章 Nginx的其他HTTP模块
14.1 Http Addition模块
14.2 Embedded Perl模块
14.3 Flv Stream模块
14.3 flv 指令
14.4 Http Gzip Static模块
14.5 Http Random Index模块
14.6 Http Geo IP模块
14.7 Http RealIp模块
14.8 Http SSL模块
14.9 Http Stub Status模块
14.10 Http Sub模块
14.11 Http Dav模块
14.12 Google Perftools模块
14.13 Http XSLT模块
14.14 Http Secure Link模块
14.15 Http Image Filter模块
第15章 Nginx的邮件模块
15.1 Nginx邮件核心模块
15.2 Nginx邮件认证模块
15.3 Nginx邮件代理模块
15.4 Nginx邮件SSL模块
15.5 Nginx邮件模块配置实例
索引
参考资料
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实战Nginx
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据系统构建
译 者 序
前　　言
关于本书
致　　谢
第1章　大数据的新范式1
1.1　本书是如何组织的2
1.2　扩展传统数据库3
1.2.1　用队列扩展3
1.2.2　通过数据库分片进行扩展4
1.2.3　开始处理容错问题4
1.2.4　损坏问题5
1.2.5　到底是哪里出错了5
1.2.6　大数据技术是如何起到帮助作用的5
1.3　NoSQL不是万能的6
1.4　基本原理6
1.5　大数据系统应有的属性7
1.5.1　鲁棒性和容错性7
1.5.2　低延迟读取和更新8
1.5.3　可扩展性8
1.5.4　通用性8
1.5.5　延展性8
1.5.6　即席查询9
1.5.7　最少维护9
1.5.8　可调试性9
1.6　全增量架构的问题10
1.6.1　操作复杂性10
1.6.2　实现最终一致性的极端复杂性11
1.6.3　缺乏容忍人为错误12
1.6.4　全增量架构解决方案与 Lambda架构解决方案13
1.7　Lambda架构14
1.7.1　批处理层15
1.7.2　服务层16
1.7.3　批处理层和服务层满足几乎所有属性16
1.7.4　速度层17
1.8　技术上的最新趋势19
1.8.1　CPU并不是越来越快20
1.8.2　弹性云20
1.8.3　大数据充满活力的开源生态系统20
1.9　示例应用：SuperWebAnalytics.com21
1.10　总结22
第一部分　批处理层
第2章　大数据的数据模型24
2.1　数据的属性25
2.1.1　数据是原始的28
2.1.2　数据是不可变的30
2.1.3　数据是永远真实的33
2.2　基于事实的数据表示模型34
2.2.1　事实的示例及属性34
2.2.2　基于事实的模型的优势36
2.3　图模式39
2.3.1　图模式的元素39
2.3.2　可实施模式的必要性40
2.4　SuperWebAnalytics.com的完整数据模型41
2.5　总结42
第3章　大数据的数据模型：示例44
3.1　为什么使用序列化框架44
3.2　Apache Thrift45
3.2.1　节点46
3.2.2　边46
3.2.3　属性47
3.2.4　把一切组合成数据对象47
3.2.5　模式演变48
3.3　序列化框架的局限性49
3.4　总结50
第4章　批处理层的数据存储51
4.1　主数据集的存储需求52
4.2　为批处理层选择存储方案53
4.2.1　使用键/值存储主数据集53
4.2.2　分布式文件系统54
4.3　分布式文件系统是如何工作的54
4.4　使用分布式文件系统存储主数据集56
4.5　垂直分区58
4.6　分布式文件系统的底层性质58
4.7　在分布式文件系统上存储SuperWebAnalytics.com的主数据集60
4.8　总结61
第5章　批处理层的数据存储：示例62
5.1　使用HDFS62
5.1.1　小文件问题64
5.1.2　转向更高层次的抽象64
5.2　使用Pail在批处理层存储数据65
5.2.1　Pail基本操作66
5.2.2　序列化对象到Pail中67
5.2.3　使用Pail进行批处理操作69
5.2.4　使用Pail进行垂直分区69
5.2.5　Pail文件格式与压缩71
5.2.6　Pail优点的总结71
5.3　存储SuperWebAnalytics.com的主数据集72
5.3.1　Thrift对象的结构化Pail73
5.3.2　SuperWebAnalytics.com的基础Pail74
5.3.3　用于垂直分区数据集的分片Pail75
5.4　总结78
第6章　批处理层79
6.1　启发性示例80
6.1.1　给定时间范围内的页面浏览量80
6.1.2　性别推理80
6.1.3　影响力分数81
6.2　批处理层上的计算82
6.3　重新计算算法与增量算法84
6.3.1　性能85
6.3.2　容忍人为错误86
6.3.3　算法的通用性86
6.3.4　选择算法的风格87
6.4　批处理层中的可扩展性87
6.5　MapReduce：一种大数据计算的范式88
6.5.1　可扩展性89
6.5.2　容错性91
6.5.3　MapReduce的通用性92
6.6　MapReduce的底层特性94
6.6.1　多步计算很怪异94
6.6.2　手动实现连接非常复杂94
6.6.3　逻辑和物理执行紧密耦合96
6.7　管道图—一种关于批处理计算的高级思维方式97
6.7.1　管道图的概念97
6.7.2　通过MapReduce执行管道图101
6.7.3　合并聚合器101
6.7.4　管道图示例102
6.8　总结103
第7章　批处理层：示例104
7.1　一个例证105
7.2　数据处理工具的常见陷阱106
7.2.1　自定义语言107
7.2.2　不良的可组合抽象107
7.3　JCascalog介绍108
7.3.1　JCascalog的数据模型109
7.3.2　JCascalog查询的结构110
7.3.3　查询多个数据集111
7.3.4　分组和聚合器113
7.3.5　对一个查询示例进行单步调试114
7.3.6　自定义谓词操作117
7.4　组合121
7.4.1　合并子查询122
7.4.2　动态创建子查询123
7.4.3　谓词宏125
7.4.4　动态创建谓词宏128
7.5　总结130
第8章　批处理层示例：架构和算法131
8.1　SuperWebAnalytics.com批处理层的设计132
8.1.1　所支持的查询132
8.1.2　批处理视图132
8.2　工作流概述135
8.3　获取新数据137
8.4　URL规范化137
8.5　用户标识符规范化138
8.6　页面浏览去重142
8.7　计算批处理视图142
8.7.1　给定时间范围内的页面浏览量143
8.7.2　给定时间范围内的独立访客143
8.7.3　跳出率分析144
8.8　总结145
第9章　批处理层示例：实现147
9.1　出发点147
9.2　准备工作流148
9.3　获取新数据149
9.4　URL规范化152
9.5　用户标识符规范化153
9.6　页面浏览去重159
9.7　计算批处理视图159
9.7.1　给定时间范围内的页面浏览量159
9.7.2　给定时间范围内的独立访客161
9.7.3　跳出率分析163
9.8　总结165
第二部分　服务层
第10章　服务层概述168
10.1　服务层的性能指标169
10.2　规范化/非规范化问题的服务层解决方案172
10.3　服务层数据库的需求173
10.4　设计SuperWebAnalytics.com的服务层174
10.4.1　给定时间范围内的页面浏览量175
10.4.2　给定时间范围内的独立访客175
10.4.3　跳出率分析176
10.5　对比全增量的解决方案177
10.5.1　给定时间范围内的独立访客的全增量方案177
10.5.2　与Lambda架构解决方案的比较182
10.6　总结183
第11章　服务层：示例184
11.1　ElephantDB的基本概念184
11.1.1　ElephantDB中的视图创建185
11.1.2　ElephantDB中的视图服务185
11.1.3　使用ElephantDB186
11.2　创建SuperWebAnalytics.com的服务层188
11.2.1　给定时间范围内的页面浏览量188
11.2.2　给定时间范围内的独立访客数量191
11.2.3　跳出率分析191
11.3　总结192
第三部分　速度层
第12章　实时视图194
12.1　计算实时视图195
12.2　存储实时视图197
12.2.1　最终一致性198
12.2.2　速度层中存储的状态总量198
12.3　增量计算的挑战199
12.3.1　CAP原理的有效性199
12.3.2　CAP原理和增量算法之间复杂的相互作用201
12.4　异步更新与同步更新202
12.5　过期实时视图203
12.6　总结205
第13章　实时视图：示例206
13.1　Cassandra的数据模型206
13.2　使用Cassandra208
13.3　总结210
第14章　队列和流处理211
14.1　队列211
14.1.1　单消费者队列212
14.1.2　多消费者队列214
14.2　流处理214
14.2.1　队列和工作节点215
14.2.2　队列和工作节点的缺陷216
14.3　更高层次的一次一个的流处理217
14.3.1　Storm模型217
14.3.2　保证消息处理221
14.4　SuperWebAnalytics.com速度层223
14.5　总结226
第15章　队列和流处理：示例227
15.1　使用Apache Storm定义拓扑结构227
15.2　Apache Storm集群及其部署230
15.3　保证消息处理232
15.4　实现SuperWebAnalytics.com给定时间范围内的独立访客的速度层233
15.5　总结237
第16章　微批量流处理239
16.1　实现有且仅有一次语义240
16.1.1　强有序处理240
16.1.2　微批量流处理241
16.1.3　微批量流处理的拓扑结构242
16.2　微批量流处理的核心概念244
16.3　微批量流处理的扩展管道图245
16.4　完成SuperWebAnalytics.com的速度层246
16.4.1　给定时间范围内的页面浏览量246
16.4.2　跳出率分析247
16.5　另一个跳出率分析示例251
16.6　总结252
第17章　微批量流处理：示例253
17.1　使用Trident253
17.2　完成SuperWebAnalytics.com的速度层257
17.2.1　给定时间范围内的页面浏览量257
17.2.2　跳出率分析259
17.3　完全容错、基于内存及微批量处理265
17.4　总结266
第18章　深入Lambda架构268
18.1　定义数据系统268
18.2　批处理层和服务层270
18.2.1　增量的批处理270
18.2.2　测量和优化批处理层的资源使用276
18.3　速度层280
18.4　查询层281
18.5　总结282
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据系统构建
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>京东基础架构建设之路（全彩）
第1 章 容器集群技术
1.1 概述 3
1.2 JDOS 1.0：“胖容器”时代 3
1.3 JDOS 2.0：新一代应用容器引擎 9
1.4 JDOS 3.0：服务融合平台 15
1.5 JDOS 4.0：弹性数据计算 18
1.6 总结 22
第2 章 数据库技术
2.1 发展历程 25
2.2 BinLake日志订阅服务 27
2.3 弹性数据库 33
第3 章 分布式存储技术
3.1 JFS：京东文件系统 47
3.2 JIMDB：内存是新的磁盘 52
3.3 FBase：大表存储 60
3.4 Container File System 66
第4 章 中间件技术
4.1 服务框架 75
4.2 消息队列 88
4.3 JMQ复制技术解析 101
4.4 CallGraph：分布式服务跟踪系统 112
第5 章 整体架构升级
5.1 ForceBot ：全链路军演机器人 125
5.2 异地多活 133
第6 章 机器学习技术
6.1 基于机器学习的商品数据治理 145
6.2 智能分单 155
6.3 列表页排序 157
6.4 语音识别与客服导航 159
6.5 商品上新助手 162
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>京东基础架构建设之路（全彩）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入Linux内核架构与底层原理
第一章 linux总览
1. 简介
2. Linux学习曲线和职业曲线
3. 如何形成一个内核
第二章 Linux内核架构
1. 常见架构范式与核心系统
2. 基础功能元素
3. 特殊硬件框架
4. 特殊软件机制
5. 系统调用
第三章 内核数据结构
1. 链表与哈希表
2. LRU
3. 树
4. 其他常见数据结构
第四章 Linux系统的启动
1. 启动的硬件支持
2. Bootloader和内核二进制
3. 启动原理
第五章 进程（重点）
1. 进程原理
2. 进程调度
3. 资源锁
4. 多进程与进程通信
5. 进程对资源的使用
第六章 内存管理（重点）
1. 内存的组织方式
2. 内核内存的申请和释放
3. 内核页面回收算法（PFRA）
4. 内核内存压缩技术
5. 其他内核内存基础服务
6. 用户端对内核内存管理系统的调整
7. 用户端进程的内存管理
8. 相关系统调用和API
第七章 安全
1. Linux安全体系概览
2. 安全的核心：加密与机制
3. Linux用户和权限系统
4. 分布于其他功能模块的安全机制
第八章 网络（重点）
1. Linux内核支持的网络特性概览
2. Linux网络架构与socket模型
3. IP实现架构
4. IP路由系统
5. TCP子系统
6. Filter子系统
7. 网络服务质量
第九章 总线
1. PCI
2. USB
3. Platform
第十章 二进制（重点）
1. 函数调用
2. 二进制的兼容性
3. ELF文件的执行原理
4. ELF安全性
第十一章 存储（重点）
1. 磁盘管理
2. 存储协议：linux下SCSI子系统架构
3. 通用块抽象层
4. 缓存层
5. 文件系统层
6. 分布式存储
7. 常用存储管理高级命令
第十二章 虚拟化与云
1. 常见虚拟化方案
2. 分布式文件系统
3. 虚拟化专用文件系统
4. Docker
第十三章 其他重要模块与高级管理工具
1. 内核到用户空间设备管理
2. 内核调试
3. 专用子系统
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入Linux内核架构与底层原理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>巧用PowerBuilder8.01和EAServer架构企业Web应用
第1章 PowerBuilder 8.01集成开发环境
第2章 数据库的连接和管理
第3章 PowerBuilder编程
第4章 事物对象和嵌入式SQL语句
第5章 应用程序对象
第6章 数据窗口
第7章 Web数据窗口
第8章 使用Web Target 
第9章 开发EAServer组件
第10章 EAServer简介
第11章 配置Jaguar CTS服务器 
第12章 应用程序、软件包和组件
第13章 定义组件接口
第14章 PowerDynamo简介
第15章 Web站点的配置和管理 
第16章 开发基于组件技术的Web应用程序
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>巧用PowerBuilder8.01和EAServer架构企业Web应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MCSE实现和管理Microsoft Windows2000目录服务基础架构考试精解与模拟试题
1，简介
2，中英文对照试题
3，中英文对照试题解析
4，英文模拟试题
5，英文模拟试题解析
6，最后冲刺MCSE-Exam7-217

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MCSE实现和管理Microsoft Windows2000目录服务基础架构考试精解与模拟试题
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Exchange 2000 Server 架构企业信息与协同操作平台
第1章Exchange2000Server总览
1－1与Windows 2000 Server集成
1－l－1Active Directory
l－l－ZMicrosoft Management Console――MMC
l－l－3Internet Information Services（IIS）
l－l－4Domain Name System（DNS）
1－2信息存储技术
l－2－1支持WebDAV
l－2－2多重信息数据库（Multiple Messaging Databases）
l－3高效率的管理构架
l－3－1Routing Group
1－3－2Administrative Group
1－3－3Policies
1－4与前版Exchange兼容
1－5与其他信息系统的数据交换
1－6实时协作（Real-Time Collaboration）
1－6－1Instant Messaging Services
1－6－2Chat Service
l－6－3Data Conferencing
1－7Outlook Web Access
1－8层次式公用文件夹（Public Folder）
第2章Exchange 2000和Active Directory的集成
2－1集成Exchange 2000与Active Directory的优点
2－l－l集中式的对象管理
2－l－2简化安全管理机制
2－l－3简化分布组（Distribution List）的建立
2－l－4便利的目录数据访问
2－2Exchange 2000存储在Active Directory中的数据
2－2－l域数据
2－2－2配置数据
2－2－3架构（Schema）信息
2－2－4通用地址列表（Global Address List，GAL）
2－2－5通用类别目录服务器上存储的对象属性
2－3Exchange 2000的目录访问
2－3－l客户端的访问
2－3－2目录访问过程
2－3－3以缓存（Cache）访问目录
2－4Active Directory中的组
2－4－1组的类型
2－4－2组的作用域
2－5Active Directory安装
2－5－l安装前的准备工作
2－5－2安装Active Directory的流程
2－6检查安装是否正确
第3章项目规划与系统安装
3－l项目现况
3－2项目规划
3－3Exchange 2000安装前的准备
3－3－l硬件要求
3－3－2升级到Service Pack1
3－3－3安装Network News Transfer Protocol（NNTP）
3－3－4测试NNTP安装
3－4安装Exchange 2000服务器
3－4－1开始安装
3－4－2Unattended安装
3－5测试安装
3－6安装时的故障排除和系统目录信息
第4章邮件系统基本架构
4－1Exchange 2000系统管理简介
4－l－l管理工具
4－1－2安装管理工具
4－1－3自定义MMC管理界面
4－1－4自定义MMC界面操作步骤及说明
4－l－5终端服务（Terminal Services）
4－1－6测试终端服务安装内容
4－1－7Exchange2000管理权限
4－1－8管理权限设置
4－2邮件信箱的规划与建立
42－l组织单位（OfganizationUnit，OU）的建立…………．
42－2组织单位建立步骤……………………………．
42－3移动组织单位………………………………．．
42－4不同种类的Recghent…………………………．．
4－2－5Mailbox－enabledUser的建立与复制………………．．
42．6Mail－enabledUser的建立………………………．
42．7Mail．enabledcontact的建立………………………
4．2－8DistributionList的建立…………………………
43客户端的连接……………………………………．
43－IOnilOOk2000的安装方式………………………，
4－3－2测试安装……………二……………………．．
第5章邮件系统高级管理…………………………………．
5－l个人信箱管理………………………………．
5－l－IExchangeGeneral选项卡………………………・・
5－1－2Outgoingmessapeslzeoncomingmessagesize…………．
5－l－3MessagefCsmctlons……………………，，…．．
5小4Sendonbehalf………………………………．．
5小5Forwardingaddress……………………………・
SAl6Recbentl讪its………………………………．
5－1－7Storage limits
5－1－8Deleted item retention
5－1－9E-mail Addresses选项卡
5－l－10Exchange Features选项卡
5－l－11Exchange Advanced选项卡
5－l－12Default character set选项
5－l－13Use Microsoft Exchange rich－text format选项
5－l－14Include all public folders when a folder list is requested选项
5－l－15Enable fast message retneval选项
5－2Distribution List管理
5－2－IExchange General选项卡
5－2－2E－mail Addresses选项卡
5－2－3Exchange AdvallCCd选项卡
5－3信箱的移动和删除
5－3－l移动信箱
5－3－2删除信箱
5－4通讯簿（Address List）的使用与建立
5－4－1自定义Address List
5－5自定义通讯簿字段

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Exchange 2000 Server 架构企业信息与协同操作平台
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架構導向系統分析與設計－使用UML軟體架

第一部份 導論篇

第1章 淺談系統分析與設計
第2章 軟體架構初解
第3章 非架構為中心的系統分析與設計
第4章 以架構為中心的系統分析與設計
第5章 軟體架構的工具

第二部份 結構角度的觀點

第6章 類別圖
第7章 資料庫
第8章 物件圖

第三部份 行為角度的觀點

第9章 使用個案圖
第10章 合作圖
第11章 順序圖

第四部份 系統分析篇

第12章 系統分析的原理
第13章 結構角度的分析觀點
第14章 行為角度的分析觀點

第五部份 系統設計篇

第15章 系統設計的原理
第16章 系統建置平台
第17章 結構角度的設計觀點
第18章 行為角度的設計觀點
第19章 驗證設計的架構為分析的架構之細部擴展
第20章 軟體實作

第六部份 範例篇

第21章 遞迴函數軟體系統
第22章 算數軟體系統
第23章 銷售進貨軟體系統
第24章Web Service軟體系統
第25章 趙老師公司ExtraNet軟體系統



>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架構導向系統分析與設計－使用UML軟體架
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>可重构无线电系统的网络架构和标准
译者序
原书前言
第1章多无线电接入网络
11引言
12无线电移动网络
121GSM/GPRS/EDGE网络架构
122GSM/GPRS/EDGE接入网络
123UMTS/HSPA/HSPA+网络架构
124UMTS/HSPA/HSPA+接入网络
125LTE网络架构
126LTE接入网络
127LTE高级版本
13无线网络
131WLAN
132WMAN
133WPAN
参考文献
第2章认知无线电：概念和能力
21认知系统
22频谱感知认知无线电
221频谱感知认知特征
23全感知无线电介绍
参考文献
第3章3GPP标准中的自组织网络特征
31自组织网络
311告警
312运营支撑系统自动化
313能量节省
32LTE概述
33LTE家庭eNB
34LTE和自组织网络
341一个新eNB的自建立过程
342自动邻居关系管理
343eNB自优化
344能量节省管理
345自愈
参考文献
第4章IEEE 80222：基于认知无线电的第一个标准
41白空间
411FCC规章制度
412ECC规章制度
42IEEE 80222
421IEEE 80222架构
43IEEE 802221
参考文献
第5章ETSI有关可重构无线电系统的标准
51引言
52ETSI可重构无线电系统
521可重构无线电基站架构
522可重构无线电设备架构
523认知引导信道
524ETSI RRS功能架构
53小结
参考文献
第6章IEEE 19004
61引言
62IEEE 动态频谱接入网络标准委员会（DySPANSC）
63IEEE 19004功能架构
631运营商频谱管理器实体
632网络重新配置管理器实体
633RAN重新配置控制器和RAN测量数据收集器实体
634终端设备实体
635IEEE 19004和ETSI RRS功能架构比较
636IEEE 19004功能架构的用例
64IEEE 19004a功能架构
641白空间管理器实体
642认知基站
643终端设备实体
644IEEE 19004a功能架构用例
65小结
参考文献
第7章可重构无线电系统的法规方面的挑战
71引言
72频谱管理
721动态频谱访问
722频谱管理中基于市场的方法
73可重构无线电系统对频谱管治的影响
74小结
参考文献
附录缩略语
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>可重构无线电系统的网络架构和标准
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务设计原理与架构
目　录
第 一篇　直面微服务　1
第 1　章　直面微服务架构　2
1.1　分布式系统　3
1.1.1　单块系统的问题　3
1.1.2　分布式系统的基本特征　6
1.2　微服务架构　8
1.2.1　微服务的概念　9
1.2.2　微服务架构基础　10
1.2.3　微服务架构与现有架构体系
对比　12
1.3　构建微服务架构的系统方法　14
1.3.1　服务模型　15
1.3.2　实现技术　15
1.3.3　基础设施　16
1.3.4　研发过程　16
1.4　微服务架构的优势　16
1.4.1　技术优势　16
1.4.2　业务与组织优势　18
1.5　微服务架构的挑战　20
1.5.1　技术架构挑战　20
1.5.2　研发过程挑战　21
1.6　实施微服务架构　22
1.6.1　微服务架构实施前提　22
1.6.2　微服务架构实施模式　23
1.7　本章小结　23
第二篇　服务建模　24
第 2　章　服务建模方法　25
2.1　服务分类　25
2.1.1　服务的基本类别　26
2.1.2　服务与业务　29
2.2　服务模型　30
2.2.1　服务的概念模型　31
2.2.2　服务的统一表现形式　32
2.3　服务边界　33
2.3.1　识别业务领域及边界　33
2.3.2　界限上下文　36
2.3.3　服务边界划分的原则　41
2.4　服务数据　41
2.4.1　规范化数据模型的问题　41
2.4.2　数据去中心化　42
2.5　本章小结　47
第3　章　服务拆分与集成　48
3.1　服务拆分　49
3.1.1　服务拆分的维度　49
3.1.2　服务拆分的策略　50
3.1.3　管理服务的依赖关系　53
3.1.4　管理服务的数据　56
3.1.5　管理事务的边界　59
3.2　服务集成　61
3.2.1　系统集成基础　61
3.2.2　RPC　62
3.2.3　REST　64
3.2.4　消息传递　70
3.2.5　服务总线　72
3.2.6　数据复制　74
3.2.7　客户端集成　76
3.2.8　外部集成　78
3.3　本章小结　80
第三篇　服务实现　81
第4　章　微服务架构基础组件　82
4.1　服务通信　82
4.1.1　网络连接　82
4.1.2　IO　模型　83
4.1.3　可靠性　85
4.1.4　同步与异步　85
4.2　事件驱动　88
4.2.1　基本事件驱动架构　88
4.2.2　事件驱动架构与领域模型　89
4.3　负载均衡　92
4.3.1　服务器端负载均衡　92
4.3.2　客户端负载均衡　93
4.3.3　负载均衡算法　94
4.4　服务路由　95
4.4.1　直接路由　95
4.4.2　间接路由　96
4.4.3　路由规则　96
4.5　API　网关　97
4.5.1　网关的作用　98
4.5.2　网关的功能　99
4.6　配置管理　100
4.6.1　配置中心模型　101
4.6.2　分布式协调机制　102
4.7　本章小结　104
第5　章　微服务架构关键要素　105
5.1　服务治理　106
5.1.1　服务注册中心　106
5.1.2　服务发布与注册　109
5.1.3　服务发现与调用　110
5.1.4　服务监控　111
5.2　数据一致性　113
5.2.1　分布式事务　113
5.2.2　CAP　理论与BASE　思想　116
5.2.3　可靠事件模式　118
5.2.4　补偿模式　124
5.2.5　Sagas　长事务模式　126
5.2.6　TCC　模式　127
5.2.7　最大努力通知模式　133
5.2.8　人工干预模式　135
5.2.9　数据一致性模式总结　135
5.3　服务可靠性　136
5.3.1　服务访问失败的原因　136
5.3.2　服务失败的应对策略　138
5.3.3　服务容错　139
5.3.4　服务隔离　140
5.3.5　服务限流　143
5.3.6　服务降级　145
5.4　本章小结　148
第6　章　微服务架构实现技术　149
6.1　微服务架构实现技术选型　149
6.1.1　技术选型的参考标准　150
6.1.2　微服务实现框架对比　152
6.2　Spring　Boot　153
6.2.1　Spring　Boot　概览　154
6.2.2　Spring　Boot　核心原理　155
6.3　Spring　Cloud　157
6.3.1　Spring　Cloud　概览　157
6.3.2　Spring　Cloud　Netflix　Eureka
与服务治理　159
6.3.3　Spring　Cloud　Netflix　Ribbon
与负载均衡　165
6.3.4　Spring　Cloud　Netflix　Hystrix
与服务容错　168
6.3.5　Spring　Cloud　Netflix　Zuul　与
API　网关　177
6.3.6　Spring　Cloud　Config　与配置
中心　180
6.4　案例分析　184
6.4.1　服务建模　184
6.4.2　服务架构设计　186
6.4.3　服务实现　188
6.5　本章小结　193
第7　章　微服务架构管理体系　194
7.1　服务测试　194
7.1.1　微服务测试的维度　195
7.1.2　微服务测试实现方法　198
7.1.3　消费者驱动的契约测试　200
7.2　服务交付与部署　205
7.2.1　微服务交付管理　205
7.2.2　基于Docker　部署微服务　209
7.3　服务监控　219
7.3.1　日志聚合　220
7.3.2　服务跟踪　224
7.4　服务安全　227
7.4.1　通用安全性技术　228
7.4.2　安全性协议　230
7.4.3　微服务中的安全性设计　235
7.5　本章小结　237
第四篇　服务转型　239
第8　章　向微服务架构转型　240
8.1　微服务架构转型过程与方法　241
8.1.1　调整架构的技术　242
8.1.2　微服务架构与现有系统　245
8.1.3　微服务实施最佳实践　251
8.2　微服务架构与研发过程转变　256
8.2.1　产品管理转变　256
8.2.2　组织架构转变　259
8.2.3　研发文化转变　262
8.3　微服务架构转型案例分析　264
8.3.1　系统描述　264
8.3.2　微服务架构改造整体方案　268
8.3.3　微服务架构改造第 一阶段　268
8.3.4　微服务架构改造第二阶段　273
8.3.5　微服务架构改造第三阶段　280
8.3.6　微服务架构改造第四阶段　285
8.4　本章小结　290
参考文献　291
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务设计原理与架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Android组件化架构
第1章  组件化基础
1.1  你知道组件化吗
1.2  基础组件化架构介绍
1.2.1  依赖
1.2.2  聚合和解耦
1.3  重新认识AndroidManifest
1.3.1  AndroidManifest属性汇总
1.3.2  AndroidManifest属性变更
1.4  你所不知道的Application
1.4.1  Applicaton的基础和作用
1.4.2  组件化Application
1.5  小结
第2章  组件化编程
2.1  本地广播
2.1.1  本地广播基础介绍
2.1.2  使用方法
2.1.3  本地广播源码分析
2.2  组件间通信机制
2.2.1  组件化层级障碍
2.2.2  事件总线
2.2.3  组件化事件总线的考量
2.3  组件间跳转
2.3.1  隐式跳转
2.3.2  ARouter路由跳转
2.3.3  Android路由原理
2.3.4  组件化最佳路由
2.3.5  空类索引
2.4  动态创建
2.4.1  反射基础
2.4.2  反射进阶
2.4.3  反射简化jOOR
2.4.4  动态创建Fragment
2.4.5  动态配置Application
2.5  数据存储
2.5.1  数据的存储方式
2.5.2  组件化存储
2.5.3  组件化数据库
2.6  权限管理
2.6.1  权限机制
2.6.2  组件化权限
2.6.3  动态权限框架
2.6.4  路由拦截
2.7  静态常量
2.7.1  资源限制
2.7.2  组件化的静态变量
2.7.3  R2.java的秘密
2.8  资源冲突
2.8.1  组件化的资源汇合
2.8.2  组件化资源冲突
2.9  组件化混淆
2.9.1  混淆基础
2.9.2  资源混淆
2.9.3  组件化混淆
2.10  多渠道模块
2.10.1  多渠道基础
2.10.2  批量打包
2.10.3  多渠道模块配置
2.11  小结
第3章  组件化优化
3.1  Gradle优化
3.1.1  Gradle基础
3.1.2  版本参数优化
3.1.3  调试优化
3.1.4  资源引用配置
3.1.5  Gradle 4.1依赖特性
3.2  Git组件化部署
3.2.1  submodule子模块
3.2.2  subtree
3.3  小结
第4章  组件化编译
4.1  Gradle编译
4.1.1  Android基础编译流程
4.1.2  Instant Run
4.1.3  更优的Gradle构建策略
4.2  极速增量编译
4.2.1  Freeline的使用
4.2.2  Freeline运行介绍
4.3  小结
第5章  组件化分发
5.1  Activity分发
5.1.1  Activity的生命周期
5.1.2  Acitity分发技术
5.2  Fragment分发
5.2.1  Fragment的生命周期
5.2.2  Fragment分发技术
5.3  View分发
5.3.1  View的生命周期
5.3.2  View分发技术
5.4  依赖倒置
5.4.1  依赖倒置原则
5.4.2  依赖倒置分发
5.5 组件化列表配置
5.5.1  Javapoet语法基础
5.5.2  编译时注解配置
5.5.3  集成配置列表
5.6 加载优化
5.6.1  线程加载
5.6.2  模块懒加载
5.7  层级限制
5.8  多模板设计
5.8.1  多模板注解
5.8.2  脚本配置
5.8.3  动态配置
5.9  小结
第6章  组件化流通
6.1  内部流通
6.1.1  Maven基础
6.1.2  本地缓存
6.1.3  远程仓库
6.2  组件化SDK
6.2.1  SDK基础知识
6.2.2  Python脚本合并
6.2.3  fat-aar脚本合并
6.3  JCenter共享
6.4  小结
第7章  架构模板
7.1  组件化模板
7.1.1  模板基础
7.1.2  模板制作
7.1.3  实时模板
7.1.4  头部注释模板
7.2  注解检测
7.3  小结
第8章  架构演化
8.1  基础架构
8.2  基础组件化
8.3  模块化
8.4  多模板化
8.5  插件化
8.6  进程化
8.7  小结
附录A  思维与架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Android组件化架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud与Docker高并发微服务架构设计实施
第一部分架 构 篇
1 微服务架构与 Spring Cloud  2
1.1 微服务概念的由来  2
1.2 微服务的定义  3
1.3 微服务架构与整体式架构的区别  5
1.4 微服务架构与SOA 的比较  8
1.5 为什么要使用微服务架构  9
1.6 为实施微服务架构做好准备  10
1.6.1 思想观念的转变  10
1.6.2 团队管理方式的改变  11
1.6.3 自动化基础设施的建设  11
1.7 为什么要使用Spring Cloud  12
1.8 Spring Cloud 组件介绍  13
1.9 Spring Cloud 的版本说明  15
1.10 小结  17
2 微服务架构最佳设计  18
2.1 合理划分微服务  19
2.2 微服务治理  19
2.3 Rest API 微服务设计  21
2.3.1 使用数据库集群  22
2.3.2 读写分离设计  22
2.3.3 使用缓存  22
2.3.4 保证Rest API 微服务的独立性  23
2.4 Web UI 微服务设计  23
2.4.1 使用FeignClient 实现负载均衡调用  23
2.4.2 使用Hystrix 实现容错设计  23
2.4.3 使用非阻塞的异步编程技术实现高并发调用  24
2.4.4 使用分布式文件系统  24
2.5 微服务之间调用规则设计  24
2.6 数据最终一致性设计  25
2.7 分布式集群架构设计  26
2.8 微服务运行环境安全设计  27
2.9 小结  27
3 电商平台微服务设计实例  29
3.1 电商平台总体设计  29
3.1.1 总体业务流程设计  29
3.1.2 总体业务功能设计  31
3.2 电商平台业务模型设计  32
3.2.1 移动商城业务模型  32
3.2.2 商家管理后台业务模型  33
3.2.3 平台管理后台业务模型  33
3.3 创建Rest API 微服务  34
3.4 创建Web UI 微服务  36
3.4.1 移动商城Web UI 微服务  36
3.4.2 商家管理后台的Web UI 微服务  37
3.4.3 平台管理后台Web UI 微服务  37
3.5 电商平台微服务体系结构  38
3.6 小结  39
第二部分 开 发 篇
4 开发工具选用及 Spring Boot 基础  41
4.1 开发工具选择  42
4.2 开发环境配置  42
4.3 创建Spring Boot 工程  43
4.4 使用JPA  47
4.4.1 数据源配置  48
4.4.2 JPA 配置  48
4.4.3 数据实体设计  49
4.4.4 存储库接口设计  49
4.4.5 单元测试  50
4.5 使用Thymeleaf  51
4.5.1 控制器设计  51
4.5.2 视图设计  52
4.6 运行与部署  52
4.7 小结  54
5 电商平台微服务工程设计  55
5.1 微服务工程结构  55
5.2 电商平台微服务工程组建  57
5.3 数据库选型  57
5.4 微服务工程创建步骤  58
5.5 项目基本配置  60
5.6 创建模块  64
5.7 小结  66
6 微服务治理基础服务开发  67
6.1 注册管理中心  68
6.1.1 创建注册管理中心  68
6.1.2 运行注册管理中心  70
6.1.3 微服务怎样使用注册管理中心  70
6.1.4 构建高可用的注册管理中心  72
6.2 配置管理中心  73
6.2.1 创建配置管理中心  73
6.2.2 微服务如何使用配置管理中心  76
6.2.3 在线更新配置信息  77
6.3 微服务监控中心  78
6.3.1 使用断路器仪表盘实现监控  79
6.3.2 聚合服务监控管理中心  81
6.4 服务跟踪分析中心  86
6.4.1 创建服务跟踪分析中心  86
6.4.2 在微服务中启用服务跟踪功能  90
6.5 日志分析平台  93
6.5.1 创建日志分析平台  93
6.5.2 使用日志分析平台  93
6.6 小结  94
7 Rest API 微服务开发  96
7.1 领域业务开发  96
7.1.1 使用Druid 数据源  98
7.1.2 JPA 及其配置  100
7.1.3 数据实体建模  101
7.1.4 查询对象设计  104
7.1.5 实体持久化设计  106
7.1.6 持久化测试  107
7.1.7 领域服务开发  109
7.1.8 领域服务的单元测试  111
7.1.9 使用Redis 实现缓存设计  112
7.2 Rest API 应用开发  117
7.2.1 Rest API 应用配置  117
7.2.2 启动程序设计  119
7.2.3 接口开发  119
7.3 使用消息处理事件  123
7.3.1 消息生产者设计  124
7.3.2 消息消费者设计  125
7.3.3 使用消息测试  128
7.4 小结  129
8 Web UI 微服务开发  131
8.1 高并发接口调用分层设计  131
8.2 通过FeignClient 调用Rest API  132
8.3 使用Hystrix 断路器  134
8.4 使用非阻塞异步编程方法  136
8.4.1 CompletableFuture 介绍  137
8.4.2 性能比较测试  140
8.5 Web 应用开发  145
8.5.1 项目引用配置  145
8.5.2 应用程序配置  146
8.5.3 业务功能开发  148
8.6 开发环境的热部署设置  154
8.7 使用分布式文件系统  157
8.7.1 分布式文件系统客户端开发  157
8.7.2 商品图片上传设计  159
8.7.3 富文本编辑器上传文件设计  160
8.7.4 建立本地文件信息库  163
8.8 小结  166
9 电商平台移动商城开发  167
9.1 移动商城首页设计  168
9.2 使用负载均衡的导航设计  174
9.3 按分类查询设计  176
9.4 商品详情页设计  179
9.5 购买下单实现  181
9.6 用户登录与账户切换设计  184
9.6.1 用户登录设计  184
9.6.2 切换账号设计  186
9.7 订单查询设计  188
9.8 集成测试  191
9.9 小结  192
10 商家管理后台与 SSO 设计  193
10.1 商家权限管理体系设计及开发  194
10.1.1 商家权限体系建模  195
10.1.2 商家权限体系的持久化设计  199
10.1.3 商家权限体系的领域服务开发  201
10.2 商家管理微服务开发  204
10.2.1 商家领域服务层单元测试  204
10.2.2 商家服务的接口开发  208
10.3 SSO 设计  213
10.3.1 SSO 基本配置  213
10.3.2 在SSO 中使用商家的权限体系  214
10.3.3 用户登录设计  216
10.3.4 有关验证码的说明  218
10.3.5 SSO 的主页设计  220
10.3.6 OAuth2 服务端设计  222
10.4 SSO 客户端设计  224
10.4.1 客户端的项目管理配置  224
10.4.2 客户端的安全管理配置  225
10.4.3 权限验证实现原理  226
10.4.4 如何在应用中接入SSO  228
10.4.5 有关跨站请求伪造防御的相关设置  230
10.4.6 根据用户权限自动分配菜单  230
10.5 小结  232
11 平台管理后台开发  233
11.1 平台管理后台领域设计  233
11.1.1 领域实体建模  233
11.1.2 实体的行为设计  236
11.1.3 领域服务开发  236
11.1.4 领域服务单元测试  239
11.2 平台管理后台访问控制设计  240
11.2.1 使用平台管理的用户体系  240
11.2.2 权限管理设计  242
11.3 商家的注册设计  245
11.4 商家菜单体系管理开发  248
11.4.1 分类菜单管理开发  248
11.4.2 模块菜单管理开发  249
11.4.3 访问资源管理开发  252
11.5 商家角色管理开发  255
11.6 小结  257
第三部分运 维 篇
12 服务器架构设计与 Docker 使用  259
12.1 服务器组建  259
12.2 安全的服务器架构设计  260
12.2.1 防火墙安装及配置  260
12.2.2 建立安全的局域网环境  264
12.3 服务器资源分配  266
12.4 CentOS 安装  269
12.4.1 IP 地址设置  270
12.4.2 安全设置  270
12.4.3 语言配置  270
12.4.4 时间同步配置  271
12.5 Docker 和docker-compose 安装  271
12.5.1 Docker 安装及使用  272
12.5.2 docker-compose 安装及使用  275
12.6 使用Docker 搭建微服务治理环境  279
12.6.1 服务器1 的部署配置  279
12.6.2 服务器2 的部署配置  281
12.7 使用Docker 部署日志分析平台  283
12.8 使用Docker 部署微服务应用  286
12.9 小结  286
13 数据库集群设计与高可用读写分离实施  288
13.1 MySQL 安装  289
13.2 主从同步设置  291
13.3 主主同步设置  294
13.4 数据库代理中间件选择  296
13.5 使用OneProxy 实现读写分离设计  297
13.5.1 OneProxy 安装  297
13.5.2 高可用读写分离配置  298
13.6 OneProxy 分库分区设计  302
13.6.1 按范围分库分表  303
13.6.2 按值分库分表  303
13.6.3 按哈希算法分库分表  304
13.7 双机热备设计  306
13.8 小结  307
14 分布式文件系统等基础设施安装与配置  308
14.1 高可用的分布式文件系统构建  308
14.1.1 FastDFS 安装  310
14.1.2 跟踪服务器配置  310
14.1.3 存储节点配置  311
14.1.4 上传文件测试  312
14.1.5 Nginx 安装及负载均衡配置  313
14.1.6 开机启动设置  317
14.2 GitLab 安装  322
14.3 Redis 安装  324
14.4 RabbitMQ 安装  326
14.5 小结  327
15 使用自动化构建工具 Jenkins 实现CI/CD  328
15.1 持续交付工作流程  330
15.2 Jenkins 安装  331
15.3 Jenkins 基本配置  333
15.4 Jenkins 自动部署实例  335
15.4.1 创建任务  336
15.4.2 任务配置  337
15.4.3 执行任务  340
15.5 小结  343
后记  345
参考文献  346
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud与Docker高并发微服务架构设计实施
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大型网站技术架构演进与性能优化
1 构建大型网站：分布式改造  1
1.1 为什么要做分布式化   1
1.2 典型的分布式架构  2
1.3 分布式配置框架  4
1.4 分布式RPC 框架   6
1.5 分布式消息框架  8
1.6 分布式数据层  11
1.7 分布式文件系统   12
1.8 应用的服务化改造  15
1.9 分布式化遇到的典型问题  16
1.10 分布式消息通道服务的设计  19
1.11 典型的分布式集群设计思路  21
1.12 总结   24
2 无线化：无线时代下的架构演进  26
2.1 无线环境下的新挑战  26
2.2 端的演进   28
2.3 无线链路的优化   32
2.4 服务端的演进  36
2.5 思考：开发语言选择的思考  44
2.5 总结  46
3 大型网站平台化演进：大中台小前台   49
3.1 为什么需要中台   49
3.2 什么是中台  53
3.3 提升中台的效率   55
3.4 中台是否能解决一切问题  64
3.5 总结  65
4 全球化下的网站演进：全球部署方案   66
4.1 国际化的背景  67
4.2 面临的技术挑战   68
4.3 全球部署的目标架构  69
4.4 何为单元化  69
4.5 单元化解决什么问题  70
4.6 单元化数据分片方案  70
4.7 数据路由方案  74
4.8 接入层路由  78
4.9 服务层路由  79
4.10 数据层路由   81
4.10 Sequence ID 的冲突问题  83
4.11 异地多活  84
4.12 多语言问题   85
4.14 多时区问题   86
4.15 全球数据同步与数据路由   89
4.16 通用版与定制版的选择  90
4.17 全球化部署中遇到的坑  91
4.18 总结   92
5 应用程序优化：代码级优化  93
5.1 优化思路   93
5.2 影响性能的关键因素  97
5.3 Java 特性的优化  102
5.4 减少并发冲突  104
5.5 减少序列化   105
5.6 减少字符到字节的转换  105
5.7 使用长连接   106
5.8 总结   106
6 应用架构探索：合并部署   108
6.1 什么是架构   108
6.2 什么是合并部署  110
6.3 能解决什么问题  112
6.4 如何解决  114
6.5 取得的效果  118
6.6 更进一步地做多版本部署  118
6.7 关于高密度部署的思考  121
6.8 总结   122
7 链路优化：大秒系统的极致优化思路  123
7.1 一些数据  123
7.2 热点隔离  124
7.3 动静分离  125
7.4 基于时间分片削峰   133
7.5 数据分层校验  134
7.6 实时热点发现  136
7.7 关键技术优化点  137
7.8 大促热点问题思考   140
7.9 总结   141
8 全局基础设施优化：资源调度优化  142
8.1 什么是资源调度  142
8.2 资源抽象层   144
8.3 物理资源调度  149
8.4 应用层调度   152
8.5 遇到的问题   155
8.6 总结   164
9 网站高可用建设：大型网站的稳定性建设  165
9.1 故障带来的影响  165
9.2 网站的可用性指标   166
9.3 稳定性建设思路  167
9.4 高可用体系化建设   171
9.5 研发人员的转变  180
9.5 稳定性组织保障  182
9.6 疑难问题排查思路   183
9.7 总结   190
附录 给新人成长的几点建议  191
参考资料  197
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大型网站技术架构演进与性能优化
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>创业公司董事会设计：架构+方法+案例范本
第一部分 如何定义创业公司董事会 / 1
第一章 为什么需要董事会 / 2
第二章 定义董事会 / 11
第二部分 如何组建创业公司董事会 / 25
第三章 创业公司董事会的职责与成员的角色 / 26
第四章 招募董事会成员 / 56
第五章 董事会的法定设立程序 / 73
第六章 如何让董事会达成一致 / 83
第七章 如何组建顾问委员会 / 90
第三部分 创业公司董事会的工作内容与流程 / 101
第八章 董事会会议完整流程 / 102
第九章 董事会上的动议和表决 / 120
第十章 董事会如何应对法律冲突与诉讼 / 131
第四部分 创业公司董事会成员间的沟通交流 / 137
第十一章 管理期望 / 138
第十二章 大胆尝试新的沟通方法 / 156
第十三章 如何应对沟通中的冲突 / 160
第十四章 更换CEO / 170
第五部分 创业公司董事会如何处理融资与退出问题 / 181
第十五章 融资 / 182
第十六章 出售公司 / 187
第十七章 公开上市 / 197
第十八章 停业 / 204
结 语 / 211
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>创业公司董事会设计：架构+方法+案例范本
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大型企业微服务架构实践与运营
第1章认识大象	2
1.1何谓大象	2
1.2电信业务支撑系统的发展历程	4
1.2.1“大算盘”时代 6
1.2.2C/S时代	6
1.2.3MVC垂直应用	7
1.2.4SOA服务化	9
1.2.5微服务架构（MSA）	10
1.3电信业务支撑困境	11
1.4电信与电商	13
第2章让大象学跳舞	15
2.1大象能跳舞吗	15
2.2大象的舞台	15
2.3大象跳舞“四步曲”	16
第二部分构建微服务架构
第3章微服务架构综述	18
3.1微服务的本质	18
3.1.1什么是微服务	18
3.1.2微服务架构特点	20
3.1.3SOA与微服务	21
3.2实现微服务架构	22
3.2.1微服务参考架构	23
3.2.2应用的拆分粒度	24
3.2.3微服务的集成	25
3.2.4微服务对交付模式的要求	27
3.2.5实现微服务面临的挑战	27
3.3微服务架构的实践	29
3.3.1建平台	29
3.3.2业务拆分	34
3.3.3容器化封装	35
3.3.4完善技术组件，提升稳定性	35
第4章分布式服务框架	37
4.1分布式服务框架的一般原理	37
4.2分布式服务调用框架的实现	39
4.2.1分布式服务框架总体架构	39
4.2.2通信框架	40
4.2.3序列化与反序列化	41
4.2.4客户端功能实现	42
4.2.5服务端功能实现	45
4.2.6注册中心	47
4.2.7服务治理	48
4.2.8API网关	51
4.3容量评估与性能保障	53
4.3.1容量评估常用指标	53
4.3.2容量指标估算方法	57
4.3.3性能保障	61
4.3.4如何评价系统性能	62
4.4一致性问题解决之道	63
4.4.1强一致性事务保障	63
4.4.2最终一致性事务保障	65
4.4.3事务补偿机制	66
第5章服务调用链日志跟踪	68
5.1服务调用链实现的一般原理	68
5.2实现调用链日志跟踪	71
5.2.1总体架构	71
5.2.2日志数据采集	72
5.2.3日志数据分析处理	77
5.2.4服务调用链信息展示	78
5.3调用链日志跟踪的应用	79
5.3.1总体监控	80
5.3.2监控预警	80
5.3.3安全审计	81
5.3.4故障定位及链路分析	82
5.4日志系统的容量和性能评估	82
第6章分布式数据访问平台	84
6.1传统数据库架构面临的挑战	84
6.1.1新业务支撑乏力	84
6.1.2持续的分库分表难以为继	85
6.1.3管理上的挑战	86
6.2数据库技术发展现状	86
6.2.1数据库发展历史回顾	86
6.2.2 SQL、NoSQL和NewSQL	87
6.2.3运营商去“O”实践	89
6.2.4数据架构发展方向	90
6.3数据库选型	91
6.3.1数据库的技术特性	91
6.3.2数据库应用特性	92
6.3.3应用特性与技术特性的对应关系	94
6.3.4数据库选择建议	94
6.4实现分布式数据访问平台	95
6.4.1分布式应用数据总线	95
6.4.2分库分表功能实现	96
6.4.3读写分离功能实现	97
6.4.4结果集合并功能实现	98
6.4.5数据库节点路由功能实现	98
6.4.6分布式事务功能保障	99
6.5异地多活数据同步平台	101
6.5.1异地多活架构设计	102
6.5.2数据同步平台架构设计	104
第7章消息平台	114
7.1消息中间件产品介绍	114
7.1.1 ActiveMQ	114
7.1.2 RocketMQ	115
7.1.3 Kafka	116
7.1.4 RabbitMQ	117
7.1.5消息中间件特性对比	118
7.2消息平台总体架构设计	119
7.3消息控制台	120
7.3.1配置管理	120
7.3.2监控管理	122
7.3.3运维管理	124
7.3.4系统管理	126
7.4消息客户端	127
7.4.1客户端功能介绍	127
7.4.2客户端关键流程	131
第8章分布式缓存平台	134
8.1　缓存中间件介绍	134
8.1.1　Memcached	134
8.1.2　Redis	135
8.1.3Coherence	137
8.1.4缓存中间件产品特性对比	137
8.2缓存策略	138
8.2.1热点缓存	138
8.2.2多级缓存	139
8.3缓存平台的架构与实现	141
8.3.1总体架构	141
8.3.2缓存管理控制平台Web	142
8.3.3缓存管理平台App	146
8.3.4缓存客户端SDK	148
第三部分构建企业级微服务架构
第9章企业级微服务架构综述	152
9.1　什么是企业级微服务架构	152
9.2　企业级微服务架构必备能力	152
9.2.1自动化软件交付	153
9.2.2智能化系统运维	153
9.2.3系统化业务运营	154
9.3实施企业级微服务架构的前提条件	155
第10章构建基于容器的应用托管和任务调度平台	157
10.1容器的发展历程	157
10.2Docker带来的改变	159
10.3基于Kubernetets的应用托管平台	160
10.3.1Kubernetes基本原理	160
10.3.2系统架构	165
10.3.3底层资源管理	166
10.3.4应用托管管理	167
10.3.5平台监控	173
10.4弹性任务调度平台	175
10.4.1总体架构	176
10.4.2任务配置管理	178
10.4.3任务调度管理	180
10.4.4 X86裸机集群任务调度流程	185
10.4.5容器化资源任务调度流程	189
第11章深化的服务治理体系	193
11.1服务治理演进历史	193
11.1.1 SOA服务治理	193
11.1.2分布式服务治理	194
11.1.3深化的服务治理	195
11.2构建“管、诊、治”服务治理体系	196
11.3“管、诊、治”总体思路	196
11.3.1服务治理总体架构	198
11.3.2服务资产管理	199
11.3.3服务关系管理	201
11.3.4服务生命周期管理	204
11.3.5服务监控	205
11.3.6分布式服务调用框架	206
11.3.7辅助工具	206
第12章DevOps打造软件生产流水线	208
12.1认识DevOps	208
12.1.1什么是DevOps	208
12.1.2 DevOps与敏捷	209
12.1.3 DevOps的兴起	210
12.2DevOps核心原则	210
12.2.1基础架构即代码	210
12.2.2持续交付	211
12.2.3协同工作	212
12.3DevOps的技术栈和工具链	212
12.4DevOps平台解决方案	214
12.4.1软件生产流水线	214
12.4.2 DevOps平台架构	215
12.4.3配置管理	217
12.4.4质量保障	221
12.4.5实现软件生产流水线	228
12.4.6数据度量	231
第四部分打造下一代基础架构平台
第13章多租户架构	234
13.1多租户的模型及体系结构	234
13.2租户隔离	236
13.3多租户管理平台	238
13.3.1管理平台架构	238
13.3.2多租户管理平台的实现原理	239
13.3.3多租户的访问控制	240
13.3.4多租户的安全访问	241
第14章能力开放平台	243
14.1总体设计	243
14.2能力开放门户	245
14.2.1开发者视图	245
14.2.2运营者视图	248
14.3沙箱环境	249
14.4安全管控	250
14.4.1 IP黑白名单校验	250
14.4.2流量配额控制	251
14.4.3服务升降级控制	253
14.4.4熔断控制	254
14.4.5流量控制	254
14.4.6传输安全控制	255
14.4.7用户授权	257
14.5服务管控	264
14.5.1服务注册	264
14.5.2服务编排与封装	265
14.5.3服务参数匹配	266
14.5.4服务路由	267
第15章智能运维	269
15.1大数据技术概述	269
15.1.1大数据技术特点	270
15.1.2大数据技术的未来发展	272
15.1.3大数据与人工智能	273
15.1.4大数据与智能运维	273
15.2智能运维平台架构设计	274
15.3智能运维整体流程	275
15.4智能化运维场景分析	276
15.5深度学习应用举例	278
15.5.1原理分析	278
15.5.2关键技术介绍	282
结束语	284
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大型企业微服务架构实践与运营
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Nginx实战：基于Lua语言的配置、开发与架构详解
第1章  Nginx学前必知  1
1.1  HTTP请求报文  1
1.2  HTTP响应报文  2
1.3  安装Nginx  2
1.4  支持HTTPS  4
1.5  添加模块  4
1.6  小结  4
第2章  基础配置  5
2.1  Nginx指令和指令块  5
2.2  Nginx基本配置说明  6
2.2.1  Main配置  6
2.2.2  与客户端有关的配置  7
2.2.3  server块  7
2.2.4  location块  8
2.3  include的使用  9
2.4  常见配置  9
2.4.1  常见配置注解  10
2.4.2  常见配置实战技巧  11
2.5  内置变量  13
2.5.1  常见内置变量  13
2.5.2  常见内置变量实战技巧  15
2.6  小结  16
第3章  强化基础配置  17
3.1  牢记Context标识  17
3.2  获取请求的IP地址  18
3.2.1  获取用户的真实IP地址  18
3.2.2  防止IP地址伪造  19
3.2.3  后端服务器对IP地址的需求  19
3.3  管理请求的行为  20
3.3.1  限制IP地址的访问  20
3.3.2  auth身份验证  21
3.3.3  利用LDAP服务加强安全  22
3.3.4  satisfy二选一的访问限制功能  23
3.4  proxy代理  23
3.4.1  proxy_pass请求代理规则  24
3.4.2  减少后端服务器的网络开销  24
3.4.3  控制请求头和请求体  25
3.4.4  控制请求和后端服务器的交互时间  26
3.5  upstream使用手册  26
3.5.1  代理多台服务器  27
3.5.2  故障转移  28
3.5.3  负载均衡  29
3.5.4  通过hash分片提升缓存命中率  29
3.5.5  利用长连接提升性能  30
3.5.6  利用resolver加速内部域名访问  31
3.6  rewrite使用手册  32
3.6.1  内部重定向  32
3.6.2  域名跳转  33
3.6.3  跳转POST请求  34
3.6.4  设置变量的值  34
3.7  限速白名单  35
3.8  日志  36
3.8.1  记录自定义变量  36
3.8.2  日志格式规范  36
3.8.3  日志存储  37
3.9  HTTP执行阶段  38
3.10  小结  39
第4章  常用模块精解  40
4.1  定制HTTP头信息  40
4.1.1  使用ngx_http_headers_module设置响应头  40
4.1.2  使用headers-more-nginx控制请求头和响应头  43
4.2  第三方模块set-misc-nginx  45
4.2.1  设置变量  46
4.2.2  防止SQL注入  46
4.2.3  字符串非转义和转义  47
4.2.4  基于键值的集群分片  48
4.2.5  base编码  48
4.2.6  md5编码  50
4.2.7  生成随机数  50
4.2.8  本地时间的输出  52
4.2.9  实战经验  52
4.3  图片的处理  53
4.3.1  image_filter图片处理  53
4.3.2  采用渐进式方式打开JPEG图片  55
4.3.3  WebP格式  56
4.3.4  优化图片  56
4.3.5  实战经验：动态切图  58
4.4  TCP和UDP代理  58
4.4.1  代理配置说明  58
4.4.2  DNS服务的反向代理  62
4.4.3  MySQL集群代理配置  62
4.4.4  实战经验  63
4.5  常用模块介绍  63
4.5.1  基于访问IP地址跳转到对应城市  63
4.5.2  修改响应内容  65
4.5.3  零像素文件的生成及其作用  66
4.5.4  图片的防盗链  67
4.6  小结  68
第5章  缓存系统  69
5.1  缓存配置说明  69
5.2  控制缓存有效期  71
5.3  性能优化  72
5.3.1  缓存未命中的最佳实践  72
5.3.2  横向扩展最佳实践  75
5.3.3  避免硬盘I/O阻塞  76
5.3.4  集群模式  77
5.4  高可用方案  77
5.5  proxy_cache配置模板  78
5.6  小结  81
第6章  引入Lua  82
6.1  为什么要引入Lua  82
6.2  Lua和LuaJIT  83
6.3  环境搭建  83
6.4  Lua的数据类型  84
6.4.1  类型说明  84
6.4.2  类型示例  85
6.5  表达式  89
6.5.1  算术运算符  89
6.5.2  关系运算符  90
6.5.3  逻辑运算符  91
6.5.4  字符串连接和字符串长度计算  92
6.5.5  运算符优先级  93
6.6  变量  93
6.6.1  全局变量  94
6.6.2  局部变量  94
6.6.3  变量赋值  94
6.7  流程控制  95
6.7.1  if-else  95
6.7.2  for循环  96
6.7.3  while循环  97
6.7.4  break和return  97
6.8  函数  98
6.8.1  函数格式  98
6.8.2  传参方式  99
6.8.3  函数的创建位置  100
6.9  模块  100
6.9.1  模块格式  101
6.9.2  加载模块  101
6.10  Lua常见操作  102
6.10.1  操作table  102
6.10.2  定义字符串  103
6.10.3  字符串连接  104
6.11  引入Lua的插曲  104
6.12  小结  105
第7章  Lua-Nginx-Module常用指令  106
7.1  Nginx和OpenResty  106
7.2  安装Ngx_Lua  107
7.3  牢记Context标识  108
7.4  Hello world  108
7.5  避免I/O阻塞  109
7.6  定义模块搜索路径  109
7.6.1  定义Lua模块的搜索路径  109
7.6.2  定义C模块的搜索路径  110
7.7  读/写Nginx的内置变量  110
7.8  控制请求头  111
7.8.1  添加请求头  111
7.8.2  清除请求头  112
7.8.3  获取请求头  112
7.9  控制响应头  113
7.9.1  获取响应头  113
7.9.2  修改响应头  114
7.9.3  清除响应头  116
7.10  读取请求体  116
7.10.1  强制获取请求体  116
7.10.2  用同步非阻塞方式获取请求体  117
7.10.3  使用场景示例  118
7.10.4  使用建议  121
7.11  输出响应体  121
7.11.1  异步发送响应体  121
7.11.2  同步发送响应体  122
7.12  正则表达式  124
7.12.1  单一捕获  124
7.12.2  全部捕获  125
7.12.3  更高效的匹配和捕获  126
7.12.4  替换数据  128
7.12.5  转义符号  129
7.13  子请求  130
7.13.1  请求方法  130
7.13.2  单一子请求  130
7.13.3  并发子请求  134
7.14  获取Nginx的环境变量  135
7.14.1  获取环境所在的模块  135
7.14.2  确认调试模式  136
7.14.3  获取prefix路径  136
7.14.4  获取Nginx的版本号  136
7.14.5  获取configure信息  136
7.14.6  获取Ngx_Lua的版本号  137
7.14.7  判断worker进程是否退出  137
7.14.8  获取worker进程的ID  137
7.14.9  获取worker进程的数量  137
7.15  定时任务  138
7.15.1  创建定时任务  138
7.15.2  性能优化  140
7.15.3  禁用的Lua API  141
7.16  常用指令  142
7.16.1  请求重定向  142
7.16.2  日志记录  144
7.16.3  请求中断处理  146
7.17  提升开发和测试效率  149
7.17.1  断开客户端连接  149
7.17.2  请求休眠  150
7.17.3  获取系统时间  150
7.17.4  编码与解码  152
7.17.5  防止SQL注入  154
7.17.6  判断是否为子请求  155
7.17.7  设置MIME类型  156
7.18  小结  156
第8章  Ngx_Lua的执行阶段  157
8.1  init_by_lua_block  157
8.1.1  阶段说明  157
8.1.2  初始化配置  158
8.1.3  控制初始值  159
8.1.4  init_by_lua_file  160
8.1.5  可使用的Lua API指令  160
8.2  init_worker_by_lua_block  160
8.2.1  阶段说明  160
8.2.2  启动Nginx的定时任务  161
8.2.3  动态进行后端健康检查  162
8.3  set_by_lua_block  165
8.3.1  阶段说明  165
8.3.2  变量赋值  165
8.3.3  rewrite阶段的混用模式  166
8.3.4  阻塞事件  167
8.3.5  被禁用的Lua API指令  167
8.4  rewrite_by_lua_block  168
8.4.1  阶段说明  168
8.4.2  利用rewrite_by_lua_no_postpone改变执行顺序  168
8.4.3  阶段控制  169
8.5  access_by_lua_block  169
8.5.1  阶段说明  169
8.5.2  利用access_by_lua_no_postpone改变执行顺序  170
8.5.3  阶段控制  170
8.5.4  动态配置黑白名单  170
8.6  content_by_lua_block  170
8.6.1  阶段说明  170
8.6.2  动态调整执行文件的路径  171
8.7  balancer_by_lua_block  171
8.7.1  阶段说明  171
8.7.2  被禁用的Lua API指令  172
8.8  header_filter_by_lua_block  172
8.8.1  阶段说明  172
8.8.2  被禁用的Lua API指令  173
8.9  body_filter_by_lua_block  173
8.9.1  阶段说明  173
8.9.2  控制响应体数据  173
8.9.3  被禁用的Lua API指令  175
8.10  log_by_lua_block  176
8.10.1  阶段说明  176
8.10.2  被禁用的Lua API指令  176
8.11  Lua和ngx.ssl  177
8.12  Ngx_Lua执行阶段  177
8.13  小结  180
第9章  Nginx与数据库的交互  181
9.1  安装cjson  181
9.2  与MySQL交互  183
9.2.1  安装lua-resty-mysql模块  183
9.2.2  读取MySQL数据  183
9.2.3  执行多条SQL语句  187
9.2.4  防止SQL注入  189
9.3  与Redis交互  189
9.3.1  安装lua-resty-redis  189
9.3.2  读/写Redis  189
9.3.3  管道命令  191
9.3.4  密码登录  193
9.3.5  其他执行命令  194
9.4  与数据库交互的常见问题  194
9.4.1  连接池  194
9.4.2  读/写分离  197
9.4.3  分离配置文件和代码  197
9.5  小结  198
第10章  缓存利器  199
10.1   worker进程的共享内存  200
10.1.1  创建共享内存区域  200
10.1.2  操作共享内存  201
10.1.3  制造消息队列  205
10.1.4  lua-resty-core  207
10.1.5  配置环境  208
10.2  Lua模块下的共享内存  209
10.2.1  安装lua-resty-lrucache  209
10.2.2  使用lua-resty-lrucache进行缓存的方法  209
10.3  当前请求在各执行阶段间的数据共享  213
10.3.1  ngx.ctx的使用  213
10.3.2  子请求和内部重定向的缓存区别  214
10.4  利用共享内存配置动态IP地址认证  215
10.5  缓存和数据库的交互  218
10.5.1  从数据库获取数据  218
10.5.2  避免因缓存失效引起的“风暴”  223
10.6  小结  228
第11章  动态管理upstream  229
11.1  实战需求分析  230
11.2  ngx_http_dyups_module  230
11.2.1  安装模块  230
11.2.2  动态管理upstream  230
11.2.3  确保upstream数据的完整性  232
11.3  nginx-upsync-module  233
11.3.1  安装nginx-upsync-module和Consul  233
11.3.2  Consul的键值操作  234
11.3.3  动态管理upstream  235
11.3.4  验证动态配置功能  237
11.3.5  高可用、高并发设计  237
11.4  基于balancer_by_lua_block的灵活控制  238
11.5  小结  239
第12章  Nginx日志分析系统  240
12.1  实战需求分析  240
12.2  ngxtop实时分析  241
12.3  Flume方案的日志分析  243
12.4  智能化nginx_log_analysis  244
12.4.1  架构重构  244
12.4.2  日志远程传输  245
12.4.3  时序数据库  245
12.4.4  日志规则设计  245
12.5  lua-resty-logger-socket传输方案  246
12.5.1  安装lua-resty-logger-socket  246
12.5.2  远程传输配置  247
12.5.3  参数解读  248
12.6  时序数据库InfluxDB  249
12.6.1  安装InfluxDB  249
12.6.2  基本概念和操作  249
12.6.3  数据分析之查询函数  250
12.6.4  数据存放之保留策略  251
12.6.5  定时任务之连续查询  251
12.6.6  客户端操作之API  252
12.6.7  使用UDP模式传输数据  253
12.7  利用lua-resty-http实现API交互  254
12.7.1  安装lua-resty-http  254
12.7.2  使用方式  254
12.8  提升InfluxDB性能  255
12.9  小结  255
第13章  静态容灾系统  256
13.1  荆棘之路  257
13.2  设计之路  259
13.3  架构流程图  261
13.3.1  反向代理系统  261
13.3.2  日志分析系统  261
13.3.3  后台系统  261
13.3.4  爬虫系统  262
13.3.5  容灾的缓存系统  262
13.3.6  时间版本的用途  263
13.3.7  异地容灾  263
13.4  核心代码解说  264
13.4.1  Ngx_Lua应用  264
13.4.2  爬虫和日志系统的关系  266
13.4.3  全部容灾和部分容灾功能  266
13.5  静态容灾的智能关闭方案  267
13.5.1  从日志分析系统中复制请求  267
13.5.2  利用goreplay复制流量  267
13.5.3  Nginx的镜像功能  268
13.5.4  灰度验证容灾系统缓存  269
13.6  小结  269
第14章  深入挖掘反向代理  270
14.1  验证码防御中心  270
14.2  鉴权管理中心  272
14.2.1  利用auth_request管理鉴权  272
14.2.2  利用Ngx_Lua子请求实现鉴权功能  273
14.3  并行访问  274
14.3.1  轻线程的启动和终止  275
14.3.2  等待和终止轻线程  276
14.3.3  URL的外部合并和内部并发  278
14.3.4  使用cosocket实现外部访问  281
14.4  小结  281
第15章  爬虫  282
15.1  区分搜索引擎爬虫和恶意爬虫  282
15.2  应对搜索引擎爬虫  284
15.2.1  搜索引擎的User-Agent  284
15.2.2  Robots协议  285
15.2.3  控制搜索引擎爬虫实战  286
15.3  应对恶意爬虫  288
15.3.1  发现恶意爬虫  288
15.3.2  抵御恶意爬虫之禁止访问  289
15.3.3  抵御恶意爬虫之验证码拦截  290
15.4  小插曲——使用假数据迷惑恶意爬虫  290
15.5  小结  291
第16章  性能分析和优化  292
16.1  性能分析场景搭建  292
16.1.1  安装SystemTap  292
16.1.2  LuaJIT的Debug模式  293
16.1.3  开启PCRE的Debug模式  294
16.1.4  分析工具下载  294
16.1.5  找出Debug不支持的包  295
16.2  流量复制  295
16.3  各项指标分析和优化建议  295
16.3.1  连接池使用状态分析  295
16.3.2  找出读/写频繁的文件  297
16.3.3  执行阶段耗时分析  297
16.3.4  连接数和文件打开数分析  298
16.3.5  找出CPU“偷窃者”  298
16.3.6  正则表达式耗时分析  299
16.3.7  找出消耗CPU资源较多的指令  301
16.3.8  利用火焰图展示和分析数据  303
16.4  检查全局变量  305
16.5  小结  305
第17章  值得拥有的OpenResty  306
17.1  OPM  307
17.2  使用DNS提升访问效率  309
17.3  TCP和UDP服务  310
17.4  多层级缓存  312
17.5  lua-resty-core扩展  313
17.6  字符串分割  313
17.7  Nginx进程管理  313
17.8  全局唯一标识符UUID  315
17.9  “全家福”awesome-resty  316
17.10  OpenResty，未来！  316
第18章  开发环境下的常见问题  317
18.1  被截断的响应体  317
18.2  “邪恶”的if  317
18.3  “贪婪”的正则匹配  318
18.4  规范HTTP状态码  319
18.5  规范URL  319
18.6  proxy_set_header的误操作  320
18.7  开发环境下的证书问题  320
18.8  深层次的错误重定向  323
18.9  压测环境下的限速和短连接  323
18.10  小结  323
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Nginx实战：基于Lua语言的配置、开发与架构详解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Cloud Native 分布式架构原理与实践
第1章 Cloud Native 概述
1.1 当今软件发展的现状
1.1.1 软件需求的发展
1.1.2 开发方式的巨变
1.1.3 云是大势所趋
1.2 Cloud Native 的特性
1.2.1 以云为基础架构
1.2.2 云服务
1.2.3 无服务
1.2.4 可扩展
1.2.5 高可用
1.2.6 敏捷
1.2.7 云优先
1.3 12-Factor
1.3.1 基准代码
1.3.2 依赖
1.3.3 配置
1.3.4 后端服务
1.3.5 构建、发布和运行
1.3.6 进程
1.3.7 端口绑定
1.3.8 并发
1.3.9 易处理
1.3.10 开发环境与线上环境等价
1.3.11 日志
1.3.12 管理进程
1.4 成功案例
1.4.1 Amazon
1.4.2    Netflix
1.4.3 淘宝网
1.5 Cloud Native 与微服务
1.5.1 微服务概述
1.5.2 从单块架构向微服务演进
1.5.3 Cloud Native 与微服务部署
1.6 总结
1.6.1 Cloud Native 的优点
1.6.2 Cloud Native 不是“银弹”
1.6.3 面临的挑战
第2章 REST API
2.1 REST 概述
2.1.1 REST 的定义
2.1.2 REST 设计原则
2.2 成熟度模型
2.2.1 第0级：使用 HTTP 作为传输方式
2.2.2 第1级：引入了资源的概念
2.2.3 第2级：根据语义使用 HTTP 动词
2.2.4 第3级：使用 HATEOAS
2.3 Java REST
2.3.1 JAX-RS 规范
2.3.2 Jersey 框架
2.3.3 Apache CXF 框架
2.3.4 Spring Web MVC 框架
2.4 内容协商
2.4.1 二进制数据
2.4.2 Google Protocol Buffers 传输协议
2.5 异常处理
2.5.1 HTTP 状态码
2.5.2 自定义异常信息
2.6 API 管理
2.6.1 版本化
2.6.2 文档化
2.6.3 可视化
2.7 客户端
2.7.1 浏览器插件
2.7.2 JAX-RS 客户端
2.7.3 Spring 客户端
2.8 实战：开启第一个微服务
2.8.1 初始化一个 Spring Boot 原型
2.8.2 用 Gradle 编译项目
2.8.3 探索项目
2.8.4 实现第一个服务
第3章 Cloud Native 测试
3.1 测试概述
3.1.1 传统测试所面临的问题
3.1.2 如何破解测试面临的问题
3.2 测试的类型、范围和比例
3.2.1 测试类型
3.2.2 测试范围
3.2.3 测试比例
3.3 如何进行微服务的测试
3.3.1 微服务的单元测试
3.3.2 Mock 与 Stub 的区别
3.3.3 微服务的集成测试
3.3.4 微服务的系统测试
3.3.5 保障代码覆盖率
3.4 Spring 测试框架
3.4.1 Spring TestContext 框架
3.4.2 Spring MVC Test 框架
3.4.3 Spring Boot Test 框架
第4章 服务路由
4.1 如何找到服务
4.1.1 DNS
4.1.2 服务注册与发现
4.1.3 客户端发现机制
4.1.4 服务端发现机制
4.2 实战：实现服务注册与发现
4.2.1 选择 Eureka的原因
4.2.2 集成 Eureka Server
4.2.3 集成 Eureka Client
4.2.4 服务的注册与发现
第5章 Cloud Native 安全
5.1 认证与授权
5.1.1 基本认证
5.1.2 摘要认证
5.1.3 摘要认证的密码加密
5.1.4 通用密码加密
5.1.5 基于散列的令牌方法
5.1.6 基于持久化的令牌方法
5.2 Java 安全框架
5.2.1 Apache Shiro
5.2.2 Spring Security
5.2.3 Spring Cloud Security
5.3 OAuth 2.0 认证
5.3.1 OAuth 2.0 的认证原理
5.3.2 OAuth 2.0 的核心概念
5.3.3 OAuth 2.0 的认证流程
5.4 实战：实现单点登录
5.4.1 项目依赖
5.4.2 编码实现
5.4.3 应用配置
5.4.4 运行
第6章 Cloud Native 数据管理
6.1 数据的存储方式
6.1.1 关系型数据库
6.1.2 NoSQL
6.2 DDD 与数据建模
6.2.1 DDD 概述
6.2.2 运用 DDD 进行数据建模
6.3 常用数据访问方式
6.3.1 JDBC
6.3.2 Spring JDBC
6.3.3 JPA
6.4 Spring Data
6.4.1 Spring Data 概述
6.4.2 Spring Data JPA
6.4.3 Spring Data Elasticsearch
6.4.4 Spring Data Redis
6.4.5 Spring Data MongoDB
6.4.6 实战：基于 MongoDB 的文件服务器
第7章 Cloud Native 消息通信
7.1 消息通信概述
7.1.1 消息通信的基本概念
7.1.2 JMS
7.1.3 事件驱动的架构
7.2 消息通信常用模式
7.2.1 点对点模式
7.2.2 发布—订阅模式
7.3 CQRS
7.3.1 CQRS 概述
7.3.2 CQRS 的好处
7.3.3 实战：实现 CQRS
7.4 Spring Cloud Stream
7.4.1 Spring Cloud Stream 概述
7.4.2 Spring Cloud Stream 实现发布者
7.4.3 Spring Cloud Stream 实现消费者
7.4.4 实战：基于 Spring Cloud Stream 的消息通信
第8章 Cloud Native 批处理
8.1 批处理概述
8.1.1 需要批处理的原因
8.1.2 常用批处理实现方式
8.2 JDBC Batch
8.2.1 Statement 与 PreparedStatement
8.2.2 实战：使用 JDBC Batch 的例子
8.3 Spring 批处理
8.3.1 使用 JdbcTemplate 实现批处理
8.3.2 批量更新 List
8.3.3 多个批次更新
8.4 Spring Batch
8.4.1 Spring Batch 概述
8.4.2 Job
8.4.3 JobLauncher
8.4.4 JobRepository
8.4.5 Step
8.4.6 ItemReader
8.4.7 ItemWriter
8.4.8 ItemProcessor
8.4.9 实战：使用 Spring Batch 的例子
第9章 Cloud Native 任务调度
9.1 任务执行与调度概述
9.2 Spring TaskExecutor
9.2.1 TaskExecutor 类型
9.2.2 TaskExecutor 应用
9.3 Spring TaskScheduler
9.3.1 Trigger 接口
9.3.2 Trigger 接口的实现
9.4 Spring 任务调度及异步执行
9.4.1 启用调度注解
9.4.2 @Scheduled 注解
9.4.3 @Async 注解
9.4.4 @Async 的异常处理
9.4.5 命名空间
9.5 使用 Quartz Scheduler
9.5.1 使用 JobDetailFactoryBean
9.5.2 使用 MethodInvokingJobDetailFactoryBean
9.6 实战：基于 Quartz Schedule 的天气预报系统
9.6.1 项目概述
9.6.2 后台编码实现
9.6.3 运行
第10章 Cloud Native 运营
10.1 CAP 理论
10.1.1 CAP 理论概述
10.1.2 CAP 只能三选二的原因
10.1.3 CAP 常见模型
10.1.4 CAP 的意义
10.1.5 CAP 的发展
10.2 服务的熔断
10.2.1 熔断的意义
10.2.2 Hystrix 概述
10.2.3 实战：实现微服务的熔断机制
10.3 代码管理
10.3.1 Git 简介
10.3.2 Git 核心概念
10.3.3 Git Flow
10.4 日志管理
10.4.1 日志框架概述
10.4.2 分布式下的日志管理
10.4.3 集中化日志分析
10.4.4 实战：基于 Elastic Stack 的集中化日志管理
10.5 配置管理
10.5.1 分布式下的配置管理的痛点
10.5.2 集中化配置
10.5.3  Spring Cloud Config
10.5.4 实战：基于 Config 实现的配置中心
10.6 应用监控
10.6.1 心跳
10.6.2 Eureka 监测机制
10.6.3 Spring Boot Actuator
10.6.4 实战：基于 Spring Boot Actuator 监测的例子
第11章 Cloud Native 持续发布
11.1 持续集成与持续交付
11.1.1 持续集成概述
11.1.2 持续交付与持续部署
11.1.3 持续交付与持续部署的意义
11.2 持续交付流水线
11.2.1 流水线概述
11.2.2 构建持续交付流水线
11.2.3 构建流水线的工具
11.3 微服务的管理与发布
11.3.1 两个比萨的故事
11.3.2 DevOps 文化
11.3.3 微服务的发布
11.4 容器
11.4.1 虚拟化技术
11.4.2 容器与虚拟机
11.4.3 基于容器的持续部署流程
11.4.4 实战：使用 Docker 来构建、运行和发布微服务
11.5 发布到云
11.5.1 常用云服务
11.5.2 实战：发布应用到云
附录 本书所涉及的技术及相关版本
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Cloud Native 分布式架构原理与实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构宝典
第1 篇 架构方法论
1 有关架构的概念认知  2
1.1 引言  2
1.2 认识架构  2
1.3 规划、架构与设计  4
1.3.1 三个不同层次的概念  4
1.3.2 规划与架构  4
1.3.3 架构与设计  5
1.4 解耦与服务化  6
1.5 分工与组件化  6
1.6 集中与分布  7
1.7 规划还是演化  8
1.8 简化也很必要  9
1.9 架构与软件开发（软件过程）  11
1.9.1 敏捷软件开发  11
1.9.2 敏捷软件开发与微服务架构  12
1.10 探讨传统企业IT 系统架构  12
1.10.1 从架构角度解决企业应用痛点  13
1.10.2 企业应用系统架构服务化迁移步骤  13
1.10.3 企业应用系统架构服务化参考模型  14
1.11 总结  15
2 以终为始的架构设计  16
2.1 缘起  16
2.2 我们的思考方式  17
2.3 为什么要做架构设计  18
2.3.1 由模型到实施  18
2.3.2 业务规模发展带来的复杂度  19
2.3.3 从沟通视角看软件架构  20
2.4 如何做架构设计  20
2.4.1 以终为始，不忘初心  21
2.4.2 PMC 框架  21
2.4.3 从多视角、多层次看架构  23
2.4.4 满足利益相关者的需要  25
2.4.5 聚焦SLA  26
2.4.6 抽象、协作、扩展、复用  28
2.4.7 分析全息视图  29
2.5 架构是什么  29
2.5.1 架构兼具组成和决策的特点  30
2.5.2 架构是演进来的  30
2.5.3 无纯粹的非功能特性  31
2.6 总结  32
3 闭环架构方法  34
3.1 系统提升的一般性方法和反馈环  34
3.2 产品创新闭环  36
3.3 组织闭环  37
3.4 研发流程闭环  39
3.5 系统架构闭环  40
3.6 一个反馈闭环实例  41
3.7 总结  44
4 复杂与架构演进的关系  46
4.1 什么是复杂  46
4.1.1 规模  47
4.1.2 结构  51
4.1.3 变化  58
4.2 用架构思维控制复杂  67
4.2.1 分而治之，控制规模  67
4.2.2 保持架构的清晰与一致  67
4.2.3 拥抱变化  70
4.3 总结  71
5 架构师的核心能力  72
5.1 架构师承担的职责  72
5.2 架构师的核心能力  73
5.2.1 经验  73
5.2.2 沟通  74
5.2.3 快速学习  74
5.2.4 解决问题的能力  76
5.3 架构能力的修炼  76
5.4 总结  77
第2 篇 面向架构的架构（微服务）
6 快速继承微服务实践  80
6.1 概述  80
6.2 我们希望的微服务是什么样子的  81
6.3 实现微服务  82
6.4 实现的考量及调研  83
6.4.1 gRPC 有什么问题  83
6.4.2 如何提高易用性  83
6.5 让微服务快速落地  87
6.6 总结  89
7 微服务架构下的事务处理  90
7.1 概述  90
7.2 使用传统的本地事务和分布式事务保证一致性  90
7.3 在微服务架构中应满足数据最终一致性原则  92
7.4 微服务架构实现最终一致性的三种模式  92
7.4.1 可靠事件模式  93
7.4.2 业务补偿模式  101
7.4.3 TCC（Try-Confirm-Cancel）模式  106
7.5 总结  109
8 微服务架构模式与实践  110
8.1 微服务的主要架构模式  110
8.1.1 一体化模式  110
8.1.2 聚合模式  110
8.1.3 代理模式  111
8.1.4 资源共享模式  112
8.1.5 异步消息模式  112
8.2 大量微服务带来的挑战  112
8.3 微服务在好雨的解决方案  113
8.3.1 服务发现和注册  113
8.3.2 弹性伸缩与负载均衡  115
8.3.3 容错处理（断路器与限流）  116
8.3.4 监控与报警  116
8.3.5 数据存储与共享  116
8.3.6 日志分析  117
8.4 总结  118
9 微服务与DevOps 架构实践  119
9.1 概述  119
9.2 某金融创业公司的微服务架构选型  122
9.3 设计思想  124
9.4 总体架构  125
9.4.1 总体架构的特性  125
9.4.2 具体实现  126
9.5 对微服务的支撑  128
9.6 DevOps 平台总体架构  130
9.7 面向微服务的研发团队介绍  131
9.8 总结  133
10 基于云的微服务架构  134
10.1 概述  134
10.2 德比软件数据对接平台的架构  134
10.3 德比软件微服务架构基础设施  135
10.4 API 网关  136
10.5 服务框架  136
10.5.1 高可用RPC  137
10.5.2 服务依赖管理  138
10.6 基础服务  140
10.6.1 配置中心  140
10.6.2 安全数据服务  141
10.6.3 数据存储服务  141
10.6.4 订单服务  142
10.7 服务降级  142
10.8 自动化  142
10.9 日志处理  143
10.10 调用链追踪  144
10.11 服务健康状态  144
10.11.1 报警  144
10.11.2 监控  145
10.12 发布管理  146
10.13 总结  147
11 Service Fabric：平台架构解析  148
11.1 Service Fabric 概述  148
11.1.1 Service Fabric 的特点  148
11.1.2 Service Fabric 的适用场景  149
11.2 Service Fabric 编程模式  150
11.3 Service Fabric 服务通信  152
11.3.1 Service Fabric 的微服务开发工具  153
11.3.2 对Service Fabric 的微服务进行监控和诊断  153
11.4 Service Fabric 可靠服务概述  154
11.4.1 Service Fabric 可靠服务——有状态服务的体系结构  154
11.4.2 Service Fabric 可靠服务——无状态服务的体系结构  156
11.4.3 Service Fabric 可靠服务——备份  157
11.5 Service Fabric 可靠执行组件  157
11.6 Service Fabric 容器应用程序  159
11.7 总结  160
第3 篇 面向业务的架构
12 如何搭建高可伸缩的移动电商架构  162
12.1 概述微服务的主要架构模式  162
12.2 移动端的混合架构  162
12.3 服务器端的SOA 架构  164
12.4 PC 端和移动端的开发协作管理  166
12.5 基于容器的虚拟化  166
12.6 关于电商的私有云建设  167
12.7 如何应用弹性云来应对电商大促  169
12.8 应对电商大促峰值的“独孤九剑”  170
13 消费信贷系统“白付美”是如何持续优化的  172
13.1 “白付美”介绍  172
13.2 “白付美”从0 到1  172
13.3 大促期间的性能保证  174
13.4 大促期间的稳定性保证  177
13.5 为服务多平台所做的优化  178
13.6 未来的优化方向  179
13.7 总结  180
14 美丽联合集团支付系统架构演进  182
14.1 概述  182
14.2 支付系统1.0  182
14.2.1 业务问题  183
14.2.2 系统问题  184
14.2.3 资金问题  185
14.3 支付系统2.0  185
14.3.1 拆分系统边界  185
14.3.2 支付系统2.0 系统详解  187
14.3.3 统一平台业务上下文  192
14.3.4 直面数据一致性挑战  192
14.4 性能提升  194
14.5 稳定性提升  201
14.5.1 监控先行  201
14.5.2 分离核心链路  201
14.5.3 服务依赖梳理  203
14.5.4 限流降级  203
14.6 压测  204
14.7 成效  204
14.7.1 业务支撑能力  204
14.7.2 系统服务能力  205
14.8 总结  206
15 金融撮合架构  207
15.1 概述  207
15.2 系统总体设计  208
15.2.1 系统核心模块  208
15.2.2 撮合算法设计  209
15.2.3 基于内存撮合  212
15.2.4 灾备的多机设计  212
15.2.5 状态机复制  213
15.2.6 系统架构  215
15.3 总结  218
第4 篇 面向性能的架构
16 一线架构师带你玩性能优化  220
16.1 什么是系统优化  220
16.2 系统优化的方法论、思路和原则  220
16.2.1 常用方法论  221
16.2.2 优化思路  221
16.2.3 优化原则  222
16.3 性能优化  222
16.3.1 常见的性能问题  222
16.3.2 性能优化的具体工作  223
16.3.3 JVM 优化  230
16.3.4 数据库优化  233
16.3.5 负载均衡优化  235
16.4 总结  237
17 性能优化的常见模式及趋势  238
17.1 性能优化的优缺点  238
17.2 性能优化的两种模式  239
17.3 单应用优化  239
17.3.1 优化的基本思路  239
17.3.2 确定性能瓶颈/热点的常见方法  240
17.3.3 压测时通常观察的内容及其所使用的工具  240
17.3.4 常见的优化手段及模式  240
17.4 结构型优化  241
17.5 两个结构型优化的案例  245
17.5.1 处理单点/网络瓶颈的可行方式  245
17.5.2 处理数据库连接池瓶颈的可行手段  245
17.6 总结  247
18 性能优化之几种常见的压测模型及其优缺点  248
18.1 压测模型抽象  248
18.1.1 压测环境准备  249
18.1.2 压测任务准备  249
18.1.3 压测执行闭环  249
18.2 线下压测模型  250
18.3 线上引流压测模型  251
18.4 线上全链路压测模型  252
18.5 总结  253
19 缓存为王——无线缓存架构优化  254
19.1 无线缓存的定义、限制条件及影响  254
19.2 无线缓存要从全局考虑  254
19.2.1 服务器端架构对无线缓存的影响  254
19.2.2 无线缓存对服务器端架构的影响  255
19.2.3 大流量下无线缓存作用的劣化  256
19.2.4 无线缓存与本机移动端组件的关系  256
19.2.5 无线缓存存储介质的选择  257
19.3 数据、资源缓存及失效策略  257
19.3.1 架构详论  257
19.3.2 实现失效策略  259
19.4 总结  263
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构宝典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务架构进阶
前言
第1章 微服务架构介绍1
1.1 微服务架构的出现1
1.1.1 单体应用架构1
1.1.2 SOA架构2
1.1.3 微服务架构3
1.2 微服务架构的流派5
1.3 云原生与微服务9
1.4 本章小结12
第2章 Spring Cloud总览13
2.1 Spring Cloud架构13
2.2 Spring Cloud特性16
2.2.1 Spring Cloud Context：应用上下文16
2.2.2 Spring Cloud Commons：公共抽象19
2.3 本章小结21
第3章 Spring Cloud的基础：Spring Boot22
3.1 Spring Boot简介22
3.2 构建一个微服务24
3.3 Spring Boot配置文件29
3.3.1 默认配置文件29
3.3.2 外部化配置29
3.3.3 YAML30
3.3.4 自动载入外部属性到Bean30
3.3.5 多Profile31
3.3.6 Starter32
3.3.7 自制一个Starter32
3.3.8 Actuator36
3.4 本章小结38
第4章 服务注册与发现：Eureka39
4.1 基础应用40
4.1.1 Eureka简介40
4.1.2 搭建Eureka服务注册中心40
4.1.3 搭建Eureka服务提供者42
4.1.4 搭建Eureka服务调用者43
4.1.5 Eureka服务注册和发现44
4.1.6 Consul的简单应用46
4.2 服务发现原理48
4.3 Eureka Client源码解析49
4.3.1 读取应用自身配置信息50
4.3.2 服务发现客户端52
4.3.3 拉取注册表信息56
4.3.4 服务注册61
4.3.5 初始化定时任务62
4.3.6 服务下线68
4.4 Eureka Server源码解析70
4.4.1 服务实例注册表70
4.4.2 服务注册72
4.4.3 接受服务心跳74
4.4.4 服务剔除75
4.4.5 服务下线77
4.4.6 集群同步78
4.4.7 获取注册表中服务实例信息82
4.5 进阶应用84
4.5.1 Eureka Instance和Client的元数据84
4.5.2 状态页和健康检查页端口设置85
4.5.3 区域与可用区85
4.5.4 高可用性服务注册中心86
4.6 本章小结87
第5章 声明式RESTful客户端：Spring Cloud OpenFeign88
5.1 基础应用88
5.1.1 微服务之间的交互88
5.1.2 OpenFeign简介89
5.1.3 代码示例89
5.2 源码分析91
5.2.1 核心组件与概念91
5.2.2 动态注册BeanDefinition92
5.2.3 实例初始化98
5.2.4 函数调用和网络请求107
5.3 进阶应用111
5.3.1 Decoder与Encoder的定制化111
5.3.2 请求/响应压缩112
5.4 本章小结113
第6章 断路器：Hystrix114
6.1 基础应用114
6.1.1 RestTemplate与Hystrix115
6.1.2 OpenFeign与Hystrix117
6.2 Hystrix原理118
6.2.1 服务雪崩118
6.2.2 断路器119
6.2.3 服务降级操作120
6.2.4 资源隔离121
6.2.5 Hystrix实现思路122
6.3 源码解析123
6.3.1 封装HystrixCommand123
6.3.2 HystrixCommand类结构129
6.3.3 异步回调执行命令129
6.3.4 异步执行命令和同步执行命令137
6.3.5 断路器逻辑137
6.3.6 资源隔离143
6.3.7 请求超时监控148
6.3.8 失败回滚逻辑150
6.4 进阶应用152
6.4.1 异步与异步回调执行命令152
6.4.2 继承HystrixCommand153
6.4.3 请求合并157
6.5 本章小结161
第7章 客户端负载均衡器：Spring Cloud Netflix Ribbon162
7.1 负载均衡162
7.2 基础应用163
7.3 源码分析165
7.3.1 配置和实例初始化165
7.3.2 与OpenFeign的集成167
7.3.3 负载均衡器LoadBalancerClient171
7.3.4 ILoadBalancer173
7.3.5 负载均衡策略实现177
7.4 进阶应用184
7.4.1 Ribbon API184
7.4.2 使用Netty发送网络请求185
7.4.3 只读数据库的负载均衡实现186
7.5 本章小结187
第8章 API网关：Spring Cloud Gateway189
8.1 Spring Cloud Gateway介绍189
8.2 基础应用190
8.2.1 用户服务191
8.2.2 网关服务192
8.2.3 客户端的访问195
8.3 源码解析195
8.3.1 初始化配置196
8.3.2 网关处理器197
8.3.3 路由定义定位器202
8.3.4 路由定位器205
8.3.5 路由断言208
8.3.6 网关过滤器216
8.3.7 全局过滤器227
8.3.8 API端点234
8.4 应用进阶235
8.4.1 限流机制235
8.4.2 熔断降级238
8.4.3 网关重试过滤器240
8.5 本章小结241
第9章 配置中心：Spring Cloud Config243
9.1 基础应用244
9.1.1 配置客户端244
9.1.2 配置仓库245
9.1.3 服务端246
9.1.4 配置验证248
9.1.5 配置动态更新249
9.2 源码解析250
9.2.1 配置服务器251
9.2.2 配置客户端261
9.3 应用进阶267
9.3.1 为Config Server配置多个repo268
9.3.2 客户端覆写远端的配置属性268
9.3.3 属性覆盖269
9.3.4 安全保护269
9.3.5 加密解密270
9.3.6 快速响应失败与重试机制272
9.4 本章小结272
第10章 消息驱动：Spring Cloud Stream274
10.1 消息队列274
10.2 基础应用276
10.2.1 声明和绑定通道276
10.2.2 自定义通道276
10.2.3 接收消息276
10.2.4 配置278
10.3 源码分析278
10.3.1 动态注册BeanDefinition279
10.3.2 绑定服务282
10.3.3 获取绑定器284
10.3.4 绑定生产者289
10.3.5 消息发送的流程291
10.3.6 StreamListener注解的处理293
10.3.7 绑定消费者298
10.3.8 消息的接收304
10.4 进阶应用306
10.4.1 Bin
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务架构进阶
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>开源网络模拟器ns-3 - 架构与实践
英文序
中文序
前言
第1篇  全 局 之 观
第1章  概述
1.1  什么是ns-3
1.2  Hello, world
1.3  ns-3社区
1.4  ns-3简史
1.5  写作习惯
第2章  通览
2.1  下载、编译与运行
2.2  源代码的目录结构
2.3  再谈编译：“./waf configure”命令
2.4  初识脚本
2.4.1  点对点有线网络：first脚本
2.4.2  Wi-Fi无线网络：third脚本
2.4.3  Python脚本
2.5  再探脚本：常用技术解析
2.5.1  脚本助理：助手类
2.5.2  参数输入：属性变量
2.5.3  数据输出：trace变量
2.5.4  行为控制：命令行
2.5.5  计划事件：Schedule函数
2.5.6  回调函数：Callback类
2.5.7  辅助信息：Log系统
2.6  网络是如何模拟的
2.7  信息入口：结点类
2.8  ns-3与编程之夏
第2篇  设 计 之 道
第3章  对象模型架构
第4章  Ptr智能指针
4.1  设计原理
4.2  使用实例
4.3  适用范围
第5章  对象模型的基石：元信息
5.1  什么是元信息
5.2  元信息存储：IidManager类
5.3  元信息管理接口：TypeId类
5.4  TypeId的使用
第6章  Object类
6.1  对象聚合
6.2  Object的创建与获取
第7章  ObjectBase类
7.1  属性配置
7.1.1  创建属性
7.1.2  属性类型
7.1.3  ConfigStore
7.1.4  全局属性
7.2  trace变量
7.2.1  创建trace
7.2.2  trace类型
第3篇  模 拟 之 路
第8章  应用层
8.1  架构与脚本
8.2  内置应用：Application
8.2.1  分组产生器
8.2.2  Internet应用
8.2.3  应用层trace
8.3  自定义应用层协议
8.3.1  Socket原理与使用
8.3.2  Application类
第9章  传输层
9.1  架构与脚本
9.2  TCP
9.2.1  属性与trace
9.2.2  TCP分组头结构
9.2.3  TCP连接建立与关闭
9.2.4  窗口管理
9.2.5  拥塞控制
9.3  UDP
9.3.1  属性与trace
9.3.2  UDP分组头结构
9.3.3  广播与多播
9.4  传输层协议开发
9.5  示例脚本
9.6  非发行版的传输层协议
第10章  网络层
10.1  架构与脚本
10.2  脚本配置与trace
10.3  IP分组头结构
10.4  IP地址分配
10.4.1  手动分配
10.4.2  自动分配
10.5  路由协议
10.5.1  列表路由
10.5.2  打印路由表
10.5.3  静态路由
10.5.4  全局路由
10.6  网络层协议开发
10.6.1  隧道协议
10.6.2  路由协议
第11章  链路与物理层
11.1  有线网络：PPP与CSMA
11.1.1  架构与脚本
11.1.2  属性与trace
11.1.3  队列与错误模型
11.2  无线局域网：Wi-Fi
11.2.1  架构与脚本
11.2.2  属性与trace
11.3  蜂窝网：LTE
11.3.1  网络架构
11.3.2  示例脚本1：无线接入网
11.3.3  示例脚本2：核心网
11.3.4  属性与trace
11.4  其他无线网络模块简介
第12章  数据收集与统计
12.1  一个例子
12.2  数据收集
12.3  数据统计
12.4  局限
第13章  与物理网络交互
13.1  TapBridge：模拟网络+物理结点
13.2  FdNetDevice：模拟结点+物理网络
第14章  网络分组Packet类
14.1  分组结构
14.2  分组创建
14.3  分组头与分组尾
14.4  分段与重组
14.5  标签：Tag类
附录
附录A  网络地址
附录B  第三方ns-3项目
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>开源网络模拟器ns-3 - 架构与实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux系统架构与运维实战
第1章  Linux日常运维管理  1
1.1  w命令  1
1.2  vmstat命令  2
1.3  top命令  3
1.4  sar命令  7
1.5  nload命令  9
1.6  监控I/O性能  9
1.7  free命令  11
1.8  ps命令  12
1.9  查看网络状态  15
1.10  Linux操作系统下的网络抓包  16
1.11  Firewalld和Netfilter  17
1.12  Netfilter 5表5链简介  18
1.13  iptables语法  19
1.14  iptables nat表应用  21
1.15  iptables规则备份与恢复  26
1.16  Firewalld的9个zone  27
1.17  Firewalld关于zone的操作  28
1.18  Firewalld关于services的操作  29
1.19  Linux任务计划  31
1.20  Linux系统服务管理工具chkconfig  33
1.21  systemd管理服务  34
1.22  unit和target简介  35
1.22.1  unit简介  35
1.22.2  target简介  36
1.23  Linux系统日志  37
1.23.1  dmesg命令  38
1.23.2  last命令  38
1.23.3  lastb命令  38
第2章  LAMP服务架构  39
2.1  LAMP服务架构介绍  39
2.2  MySQL和MariaDB数据库简介  39
2.3  MySQL和MariaDB数据库安装  40
2.3.1  MySQL数据库安装  40
2.3.2  MariaDB数据库安装  41
2.4  Apache服务安装  43
2.5  PHP源码编译安装  46
2.5.1  PHP版本介绍  46
2.5.2  PHP 5.6源码编译安装  46
2.5.3  PHP 7.X源码编译安装  48
2.6  Python源码编译安装  49
2.6.1  Python 3.6编译安装  49
2.6.2  安装Python扩展MySQL数据库  50
2.7  Apache结合PHP进行操作  52
2.8  Apache默认虚拟主机  54
2.9  Apache相关配置  56
2.9.1  Apache用户认证  56
2.9.2  域名跳转机制  59
2.9.3  Apache访问日志  60
2.9.4  静态文件不记录日期和时间  61
2.9.5  访问日志切割  62
2.9.6  静态元素过期时间  63
2.9.7  配置防盗链  64
2.9.8  访问控制Directory  64
2.9.9  访问控制FilesMatch  66
2.9.10  限定某个目录禁止解析PHP  66
2.9.11  限制user_agent  66
2.10  PHP相关配置  67
2.11  安装PHP扩展模块Redis  68
第3章  LNMP服务架构  70
3.1  LNMP服务架构简介  70
3.2  安装MySQL数据库  70
3.3  安装PHP  72
3.4  Nginx简介与安装  74
3.4.1  Nginx简介  74
3.4.2  Nginx安装  74
3.4.3  Nginx测试解析PHP  75
3.5  Nginx相关配置  76
3.5.1  Nginx默认虚拟主机  76
3.5.2  Nginx用户认证  78
3.5.3  Nginx域名跳转  80
3.5.4  Nginx访问日志  80
3.5.5  Nginx日志切割  81
3.5.6  静态文件不记录日期和时间  83
3.5.7  Nginx设置防盗链  83
3.5.8  Nginx进行访问控制  84
3.5.9  Nginx解析PHP相关设置  84
3.6  Nginx代理  85
3.7  Nginx负载均衡  86
3.8  Nginx配置SSL  88
3.8.1  生成SSL秘钥对  88
3.8.2  Nginx配置SSL  89
3.9  php-fpm配置  90
3.9.1  php-fpm的pool  90
3.9.2  php-fpm慢执行日志  92
3.9.3  open_basedir  93
3.9.4  php-fpm管理进程  94
3.10  部署phpMyAdmin  94
3.11  安装&设置Laravel框架  95
3.12  安装&设置Yii2框架  98
3.13  安装&设置ThinkPHP 5框架  100
3.14  安装&设置Django框架  102
3.14.1  安装Django框架  102
3.14.2  Django runserver  102
3.14.3  运行Hello World  105
3.15  安装&设置Flask框架  108
第4章  MySQL数据库技术实践  110
4.1  设置和更改root密码  110
4.1.1  设置MySQL数据库环境变量  110
4.1.2  设置MySQL数据库密码  110
4.1.3  修改MySQL数据库密码  111
4.1.4  重置MySQL数据库密码  111
4.2  连接MySQL的几种方式  113
4.3  MySQL常用命令  114
4.4  MySQL创建用户及授权  117
4.5  MySQL数据备份与恢复  118
4.6  MySQL主从复制监控  119
4.7  MySQL主从准备工作  119
4.8  设置MySQL主  119
4.9  设置MySQL从  121
4.10  测试MySQL主从同步  122
第5章  Tomcat服务  124
5.1  Tomcat介绍  124
5.2  安装JDK  124
5.3  安装Tomcat  125
5.4  设置Tomcat监听80端口  127
5.5  Tomcat虚拟主机  127
5.5.1  设置Tomcat虚拟主机  127
5.5.2  部署一个Java项目  128
5.6  Tomcat日志  130
第6章  Linux集群架构  131
6.1  Linux集群概述  131
6.2  Keepalived简介  131
6.3  Keepalived设置高可用集群  132
6.3.1  集群准备工作  132
6.3.2  设置Keepalived主服务器  132
6.3.3  设置Keepalived从服务器  134
6.3.4  区分主从Nginx服务  136
6.3.5  测试Keepalived高可用  137
6.4  负载均衡集群介绍  138
6.5  LVS介绍  139
6.6  LVS的调度算法  139
6.7  NAT模式的LVS搭建  140
6.7.1  NAT模式搭建准备工作  140
6.7.2  设置分发器  141
6.7.3  Real Server安装Nginx服务  142
6.8  DR模式的LVS搭建  143
6.8.1  DR模式的准备工作  143
6.8.2  设置LVS的DR模式  143
6.8.3  测试LVS的DR模式  145
6.9  Keepalived+LVS  145
第7章  Zabbix运维监控  149
7.1  Linux监控平台简介  149
7.2  Zabbix监控介绍  149
7.3  安装Zabbix监控  150
7.3.1  安装准备工作  150
7.3.2  ntpdate设置时间同步  151
7.3.3  安装Zabbix服务器端  151
7.3.4  Web界面安装Zabbix  153
7.3.5  修改Admin管理员密码  155
7.3.6  重置Admin管理员密码  155
7.3.7  安装Zabbix客户端  155
7.4  添加监控主机  156
7.4.1  Web界面添加Host主机  156
7.4.2  解决Zabbix页面乱码  158
7.5  使用SMTP发送邮件报警及定制报警  159
7.5.1  添加Triggers触发器  159
7.5.2  设置报警邮件发送  160
7.5.3  设置报警邮件接收  161
7.5.4  添加报警动作  163
7.5.5  设置邮件报警铃声  163
7.5.6  设置微信报警  164
7.6  Web监控和MySQL监控  170
7.6.1  Web监控  170
7.6.2  MySQL监控  172
7.7  TCP状态监控和Nginx监控  177
7.7.1  TCP状态监控  177
7.7.2  Nginx服务监控  178
7.8  Zabbix主动模式  179
7.8.1  添加主动模式模板  179
7.8.2  添加主动模式主机  181
第8章  NoSQL非关系型数据库  182
8.1  NoSQL非关系型数据库简介  182
8.2  Memcached  183
8.2.1  Memcached简介  183
8.2.2  安装Memcached  184
8.2.3  查看Memcached状态  185
8.2.4  Memcache命令行  186
8.2.5  Memcached数据的导入和导出  188
8.2.6  PHP连接Memcached  189
8.2.7  Memcached中存储Session  190
8.3  Redis  191
8.3.1  Redis简介  191
8.3.2  Redis安装  191
8.3.3  Redis持久化  192
8.3.4  Redis数据类型  193
8.3.5  Redis常用操作  197
8.3.6  Redis操作键值  203
8.3.7  Redis安全设置  206
8.3.8  Redis慢查询日志  207
8.3.9  PHP安装Redis扩展模块  208
8.3.10  Redis存储session  208
8.3.11  Redis主从配置  209
8.3.12  Redis集群简介  210
8.3.13  Redis集群搭建与配置  211
8.3.14  Redis集群操作  213
8.4  MongoDB  214
8.4.1  MongoDB简介  214
8.4.2  安装MongoDB  215
8.4.3  连接MongoDB  216
8.4.4  MongoDB用户管理  216
8.4.5  MongoDB创建集合和数据管理  219
8.4.6  PHP的MongoDB扩展  221
8.4.7  PHP的Mongo扩展  222
8.4.8  测试Mongo扩展  222
8.4.9  MongoDB副本集简介  223
8.4.10  MongoDB副本集搭建  223
8.4.11  MongoDB副本集测试  224
8.4.12  MongoDB分片介绍  226
8.4.13  MongoDB分片重要角色  227
8.4.14  MongoDB分片搭建  228
8.4.15  MongoDB分片测试  232
8.4.16  MongoDB备份与恢复  233
第9章  Jenkins持续化集成  236
9.1  Jenkins介绍  236
9.2  Jenkins安装  237
9.3  Jenkins发布PHP代码  239
9.4  Jenkins邮件设置  243
9.5  插件Email-ext  244
9.6  管理员密码破解  245
9.7  部署Java项目  246
9.7.1  部署Java项目之创建私有仓库  246
9.7.2  部署Java项目之下载Zrlog源码  247
9.7.3  安装Tomcat  248
9.7.4  部署Java项目之安装Maven  249
9.7.5  部署Java项目之安装插件  250
9.7.6  部署Java项目之构建Job  250
9.7.7  部署Java项目之手动安装JDK  253
9.7.8  部署Java项目之发布War包  253
第10章  Docker容器实践  255
10.1  Docker简介  255
10.1.1  Docker主要解决什么问题  255
10.1.2  Docker的历史  255
10.1.3  Docker是什么  256
10.2  Docker和KVM对比  257
10.3  Docker核心概念  257
10.4  安装Docker  257
10.4.1  Mac系统安装Docker  258
10.4.2  Windows系统安装Docker  260
10.4.3  CentOS 7系统安装Docker  261
10.5  Docker镜像管理  262
10.5.1  下载Docker镜像  262
10.5.2  设置阿里云Docker加速器  262
10.5.3  Docker基本命令  263
10.6  通过容器创建镜像  265
10.7  通过模板创建镜像  267
10.7.1  通过模板导入镜像  267
10.7.2  通过镜像导出文件  267
10.7.3  通过文件恢复镜像  267
10.8  Docker的基本管理  268
10.8.1  Docker容器管理  268
10.8.2  Docker仓库管理  270
10.8.3  Docker数据管理  272
10.9  Docker数据卷备份与恢复  273
10.9.1  Docker数据卷备份  273
10.9.2  Docker数据卷恢复  274
10.10  Docker网络模式与外部访问容器  274
10.10.1  Docker网络模式  274
10.10.2  外部访问容器  275
10.10.3  Operation Not Permitted解决方案  275
10.11  设置桥接网络  276
10.12  DockerFile创建镜像  278
10.12.1  DockerFile格式  278
10.12.2  DockerFile示例安装Nginx  280
10.13  docker compose部署服务与示例  281
第11章  搭建Kubernetes集群  284
11.1  Kubernetes（K8S）简介  284
11.2  Kubernetes基本概念  286
11.3  Kubernetes架构和组件功能  287
11.3.1  Master组件功能介绍  287
11.3.2  Node组件功能介绍  287
11.3.3  三方组件Etcd介绍  288
11.4  Kubernetes Cluster部署  288
11.4.1  集群环境规划  288
11.4.2  安装Docker服务  289
11.4.3  自签TLS证书  289
11.4.4  部署Etcd集群  291
11.4.5  Flannel集群网络工作原理  295
11.4.6  部署Flannel集群网络  296
11.4.7  创建Node的Kubeconfig文件  300
11.4.8  部署Master节点组件  302
11.4.9  部署Node组件  304
11.4.10  集群部署Nginx服务  306
11.5  Kubectl管理工具  309
11.5.1  Kubectl管理工具远程连接集群  309
11.5.2  Kubectl管理命令  311
11.5.3  Kubectl工具管理集群应用  312
第12章  Kubernetes管理维护与运用  320
12.1  YAML配置文件管理资源  320
12.2  Pod管理  322
12.2.1  Pod基本管理  322
12.2.2  Pod资源限制  325
12.2.3  Pod调度约束  327
12.2.4  Pod重启策略  329
12.2.5  Pod健康检查  329
12.2.6  Pod问题定位  332
12.3  Service  332
12.3.1  网络代理模式  332
12.3.2  服务代理  334
12.3.3  服务发现  337
12.3.4  发布服务  341
12.4  Ingress  343
12.4.1  部署Ingress  344
12.4.2  HTTP与HTTPS测试  345
12.4.3  部署Ingress TLS  348
12.5  数据管理  351
12.5.1  emptyDir  351
12.5.2  hostPath  353
12.5.3  NFS  355
12.5.4  GlusterFS  357
12.5.5  PersistentVolume  363
第13章  Kubernetes高可用架构和项目案例  371
13.1  Kubernetes Dashboard  371
13.2  部署集群应用  373
13.3  Kubernetes高可用架构  381
13.3.1  高可用架构详解  381
13.3.2  Master高可用部署  383
13.4  Kubernetes集群监控  388
13.5  Kubernetes集群日志管理与应用  395
13.5.1  日志系统方案介绍  395
13.5.2  部署ELK Stack  397
13.5.3  部署Filebeat日志收集工具  401
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux系统架构与运维实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>资产系统建设实务：城市商业银行科技架构研究与实践
目录
│目录
序一
序二
前言
第1章　银行科技发展历程  / 1
系统见证发展，科技改变银行
1.1　银行科技发展的简要历程  / 1
1.2　核心银行系统的建设历程  / 4
1.3　资产系统的建设历程  / 6
1.4　包商银行科技系统建设历程  / 8
第2章　资产业务概览  / 11
产品琳琅满目，创造业务价值
2.1　银行产品综述  / 11
2.2　资产产品简介  / 14
2.3　资产业务管理  / 18
第3章　SOA架构体系与资产系统  / 19
运筹核心设计，勾画未来全局
3.1　科技变革的必要性  / 19
3.2　系统建设原则与目标  / 21
3.3　选型方案  / 23
3.4　系统架构  / 25
3.5　资产系统架构  / 28
3.6　新系统的优势  / 32
第4章　前台资产系统  / 35
丰富多彩的前台功能，视觉全新的客户体验
4.1　信贷管理信息系统  / 35
4.2　快贷系统  / 43
4.3　贷后管理系统  / 52
4.4　商业汇票系统  / 61
4.5　信贷档案管理系统  / 68
4.6　征信查询管理系统  / 74
4.7　特定目的载体投资系统  / 80
4.8　理财资产管理系统  / 86
4.9　资产证券化系统  / 96
4.10　贸易金融系统  / 107
第5章　后台资产系统  / 119
包罗万象的后台服务，严谨周密的风险控制
5.1　贷款核算系统  / 119
5.2　额度系统  / 126
5.3　押品系统  / 136
5.4　智能决策平台  / 144
5.5　非零售内部评级系统  / 150
第6章　关联系统  / 160
纵横捭阖的渠道联动，浑如一体的平台协同
6.1　渠道系统  / 160
6.2　基础平台类系统  / 170
第7章　资产业务运维管理  / 195
系统建设开疆不易，运维服务守土更难
7.1　运维内容简介  / 196
7.2　运维管理体系  / 196
7.3　运维服务实例  / 199
7.4　小结  / 203
附录  / 204
参考文献  / 206
后记  / 208
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>资产系统建设实务：城市商业银行科技架构研究与实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>基于语料库的当代美国政治语篇的架构隐喻模式分析
第一章绪论
1.1研究背景
1.2研究内容
1.3研究的重难点
1.4全书结构
第二章文献综述
2.1引言
2.2相关核心概念界定
2.3国外相关研究综述
2.4国内相关研究综述
2.5以往研究的特点与不足
2.6小结
第三章理论基础
3.1引言
3.2架构理论
3.3概念隐喻理论
3.4美国的两党政治与架构隐喻特征
3.5小结
第四章研究方法
4.1引言
4.2研究的主要问题
4.3语料的选择与提取
4.4架构提取
4.5隐喻识别
4.6概念隐喻分布和隐喻疏密度分析
4.7架构隐喻分析方法
4.8小结
第五章与政治语篇的表层架构对比分析
5.1引言
5.2表层架构分析
5.3表层架构对比分析
5.4小结
第六章与政治语篇的深层架构对比分析
6.1引言
6.2深层架构对比分析
6.3小结
第七章当代美国政治语篇的架构隐喻模式分析
7.1引言
7.2道德模式
7.3道德伦理的隐喻性
7.4美国道德伦理概念的隐喻学分析
7.5严父慈亲模式的道德概念及其隐喻性
7.6美国政治语篇的架构隐喻模式
7.7小结
第八章结语
8.1本研究的主要发现
8.2本研究的意义和价值
8.3本研究的创新之处
8.4本研究的局限与展望
参考文献
附录
后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>基于语料库的当代美国政治语篇的架构隐喻模式分析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>KVM私有云架构设计与实践
第一篇 私有云现状
第1章 私有云行业现状
1.1 私有云概念
1.2 国内私有云企业与行业客户
1.2.1 行业垂直细分
1.2.2 落地场景
1.3 总结
第二篇 架构设计
第2章 基础架构设计
2.1 基本架构原则
2.1.1 合理的存储配置
2.1.2 稳定的网络基础
2.1.3 可靠的计算资源
2.2 架构安全
2.2.1 认证与授权
2.2.2 服务安全
2.3 “云”化架构
2.3.1 池化资源
2.3.2 SLA管理
2.4 OpenStack基础架构设计示例
2.5 总结
第3章 软件架构设计
3.1 开源云架构概览
3.1.1 混合云——OpenStack
3.1.2 IaaS——oVirt
3.1.3 PaaS——OpenShift
3.2 集群架构与软件设计原则
3.2.1 集群架构模型
3.2.2 控制单元与服务代理
3.2.3 管理平台设计
3.3 服务实现
3.3.1 基本服务元素
3.3.2 服务实现示例
3.3.3 IaaS拓展
3.3.4 PaaS拓展
3.4 Paas平台示例——OpenShift
3.5 总结
第三篇 私有云核心技术与应用
第4章 KVM虚拟化基础
4.1 QEMU
4.1.1 QEMU／KVM简介
4.1.2 机器模型
4.1.3 设备清单
4.1.4 QEMU控制台
4.1.5 QAPI
4.2 Libvirt
4.2.1 基本概念与用例
4.2.2 对象描述方法
4.2.3 Virsh控制台
4.2.4 编程示例
4.3 快速入门
4.3.1 搭建VirtManager
4.3.2 学习建议
第5章 容器技术基础
5.1 容器简介
5.1.1 技术历史
5.1.2 技术实现
5.2 Docker
5.2.1 基本架构
5.2.2 主要元素
5.2.3 周边工具
5.3 安全隐患与对应措施
第6章 私有云网络基础
6.1 网络模型关键字
6.2 经典虚拟化网络
6.2.1 桥接网络
6.2.2 NAT网络
6.2.3 VLAN网络
6.3 软件定义网络
6.3.1 技术基础
6.3.2 虚拟化组网示例
第7章 私有云存储基础
7.1 存储基本元素
7.1.1 VFS
7.1.2 文件系统
7.1.3 块设备
7.2 虚拟机硬盘存储
7.2.1 虚拟硬盘
7.2.2 无状态存储
7.2.3 存储池
7.3 分布式存储后端
7.3.1 Glusterfs
7.3.2 Ceph
第四篇 实践与拓展
第8章 行业案例简析
8.1 VMware与Citrix组建银行桌面云
8.1.1 用户需求
8.1.2 架构设计与分析
8.2 OpenStack构建大学私有云
8.2.1 用户需求
8.2.2 架构设计
8.3 iVit构建大学教学桌面云
8.3.1 用户需求
8.3.2 架构设计与分析
第9章 私有云特性功能
9.1 设备透传与重定向
9.1.1 PCI／PCI—E设备
9.1.2 SR-IOV
9.1.3 USB
9.1.4 串口与并口
9.2 GPU与桌面协议
9.2.1 物理显卡透传
9.2.2 开源vGPU实现
9.2.3 3D远程桌面协议
9.3 文件带外管理
9.3.1 技术基础
9.3.2 文件监控与审计
9.3.3 病毒集中扫描
9.3.4 软件增量分发
9.4 虚拟机体验优化
9.4.1 CPU
9.4.2 内存
9.4.3 硬盘
9.4.4 网络
9.4.5 virtio多队列
9.4.6 来宾工具
9.4.7 单点登录
9.4.8 QEMU FT
9.5 服务器系统优化
9.5.1 性能监控工具
9.5.2 存储
9.5.3 网络
9.5.4 主板选项
9.6 客户端部署
9.7 P-V互迁
9.8 数据备份
9.8.1 离线备份
9.8.2 在线备份
第10章 运维与测试工具
10.1 监视与日志管理
10.1.1 监视
10.1.2 日志管理
10.2 主机管理与配置
10.2.1 自动配置
10.2.2 主机管理
10.3 负载均衡与高可用
10.3.1 负载均衡
10.3.2 高可用
10.4 测试
10.4.1 性能测试
10.4.2 功能测试
结语
解决问题的建议
参考文献与开源项目
技术术语
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>KVM私有云架构设计与实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>持续演进的Cloud Native：云原生架构下微服务最佳实践
第1章  综述  1
1.1  Cloud Native的起源  1
1.2  Cloud Native的组成  4
1.3  Cloud Native背后的诉求  5
1.4  如何衡量Cloud Native的能力  5
1.5  Cloud Native的原则  6
第2章  微服务架构  11
2.1  微服务架构的起源  11
2.2  为什么采用微服务架构  12
2.2.1  单体架构与微服务架构  12
2.2.2  什么时候开始微服务架构  14
2.2.3  如何决定微服务架构的拆分粒度  14
2.3  微服务设计原则  15
2.4  微服务架构实施的先决条件  17
2.4.1  研发环境和流程上的转变  17
2.4.2  拆分前先做好解耦  18
2.5  微服务划分模式  20
2.5.1  基于业务复杂度选择服务划分方法  20
2.5.2  基于数据驱动划分服务  21
2.5.3  基于领域驱动划分服务  22
2.5.4  从已有单体架构中逐步划分服务  23
2.5.5  微服务拆分策略  24
2.5.6  如何衡量服务划分的合理性  25
2.6  微服务划分反模式  26
2.7  微服务API设计  28
2.7.1  优秀API的设计原则  28
2.7.2  服务间通信——RPC  28
2.7.3  序列化——Protobuf  30
2.7.4  服务间通信——RESTful  33
2.7.5  通过Swagger实现RESTful  36
2.7.6  通过Spring Boot、Springfox、Swagger实现RESTful  41
2.7.7  HTTP协议的进化——HTTP/2  46
2.7.8  HTTP/2和Protobuf的组合——gRPC  48
2.8  微服务框架  53
2.9  基于Dubbo框架实现微服务  54
2.10  基于Spring Cloud框架实现微服务  58
2.11  服务发现场景下的ZooKeeper与Etcd  67
2.12  微服务部署策略  68
2.12.1  服务独享数据库  69
2.12.2  服务独享虚拟机/容器  70
2.13  为什么总觉得微服务架构很别扭  70
第3章  敏捷基础设施及公共基础服务  73
3.1  传统基础设施面临的挑战  73
3.2  什么是敏捷基础设施  74
3.3  基于容器的敏捷基础设施  75
3.3.1  容器VS虚拟机  76
3.3.2  安装Docker  77
3.3.3  部署私有Docker Registry  79
3.3.4  基于Spring Boot、Maven、Docker构建微服务  79
3.3.5  基于docker-compose管理容器  84
3.4  基于公共基础服务的平台化  85
3.5  监控告警服务  86
3.5.1  监控数据采集  87
3.5.2  监控数据接收模式  87
3.5.3  通过时间序列数据库存储监控数据  88
3.5.4  开源监控系统实现Prometheus  88
3.5.5  通过Prometheus和Grafana监控服务  90
3.6  分布式消息中间件服务  96
3.6.1  分布式消息中间件的作用  97
3.6.2  业界常用的分布式消息中间件  98
3.6.3  Kafka的设计原理  99
3.6.4  为什么Kafka性能高  100
3.6.5  Kafka的数据存储结构  102
3.6.6  如何保证Kafka不丢消息  104
3.6.7  Kafka跨数据中心场景集群部署模式  106
3.7  分布式缓存服务  108
3.7.1  分布式缓存的应用场景  109
3.7.2  业界常用的分布式缓存Memcached  110
3.7.3  业界常用的分布式缓存——Redis  111
3.7.4  Redis常用的分布式缓存集群模式  112
3.7.5  基于Codis实现Redis分布式缓存集群  116
3.8  分布式任务调度服务  118
3.8.1  通过Tbschedule实现分布式任务调度  119
3.8.2  通过Elastic-Job实现分布式任务调度  123
3.9  如何生成分布式ID  126
3.9.1  UUID  126
3.9.2  SnowFlake  127
3.9.3  Ticket Server  128
3.9.4  小结  129
第4章  可用性设计  130
4.1  综述  130
4.1.1  可用性和可靠性的关系  130
4.1.2  可用性的衡量标准  131
4.1.3  什么降低了可用性  131
4.2  逐步切换  132
4.2.1  影子测试  132
4.2.2  蓝绿部署  133
4.2.3  灰度发布/金丝雀发布  134
4.3  容错设计  135
4.3.1  消除单点  136
4.3.2  特性开关  136
4.3.3  服务分级  137
4.3.4  降级设计  138
4.3.5  超时重试  139
4.3.6  隔离策略  152
4.3.7  熔断器  153
4.4  流控设计  157
4.4.1  限流算法  157
4.4.2  流控策略  159
4.4.3  基于Guava限流  160
4.4.4  基于Nginx限流  162
4.5  容量预估  163
4.6  故障演练  164
4.7  数据迁移  165
4.7.1  逻辑分离，物理不分离  166
4.7.2  物理分离  166
第5章  可扩展性设计  168
5.1  加机器能解决问题吗  168
5.2  横向扩展  169
5.3  AKF扩展立方体  170
5.4  如何扩展长连接  172
5.5  如何扩展数据库  175
5.5.1  X轴扩展——主从复制集群  175
5.5.2  Y轴扩展——分库、垂直分表  176
5.5.3  Z轴扩展——分片（sharding）  177
5.5.4  为什么要带拆分键  182
5.5.5  分片后的关联查询问题  183
5.5.6  分片扩容（re-sharding）  184
5.5.7  精选案例  187
5.6  如何扩展数据中心  190
5.6.1  两地三中心和同城多活  190
5.6.2  同城多活  191
5.6.3  异地多活  192
第6章  性能设计  194
6.1  性能指标  195
6.2  如何树立目标  195
6.3  如何寻找平衡点  196
6.4  如何定位瓶颈点  197
6.5  服务通信优化  198
6.5.1  同步转异步  198
6.5.2  阻塞转非阻塞  199
6.5.3  序列化  200
6.6  通过消息中间件提升写性能  201
6.7  通过缓存提升读性能  202
6.7.1  基于ConcurrentHashMap实现本地缓存  203
6.7.2  基于Guava Cache实现本地缓存  204
6.7.3  缓存的常用模式  205
6.7.4  应用缓存的常见问题  207
6.8  数据库优化  208
6.8.1  通过执行计划分析瓶颈点  208
6.8.2  为搜索字段创建索引  209
6.8.3  通过慢查询日志分析瓶颈点  210
6.8.4  通过提升硬件能力优化数据库  211
6.9  简化设计  212
6.9.1  转移复杂度  212
6.9.2  从业务角度优化  212
第7章  一致性设计  214
7.1  问题起源  214
7.2  基础理论  215
7.2.1  什么是分布式事务  216
7.2.2  CAP定理  218
7.2.3  BASE理论  219
7.2.4  Quorum机制（NWR模型）  219
7.2.5  租约机制（Lease）  220
7.2.6  状态机（Replicated State Machine）  221
7.3  分布式系统的一致性分类  222
7.3.1  以数据为中心的一致性模型  223
7.3.2  以用户为中心的一致性模型  226
7.3.3  业界常用的一致性模型  229
7.4  如何实现强一致性  230
7.4.1  两阶段提交  230
7.4.2  三阶段提交（3PC）  231
7.5  如何实现最终一致性  232
7.5.1  重试机制  232
7.5.2  本地记录日志  233
7.5.3  可靠事件模式  233
7.5.4  Saga事务模型  235
7.5.5  TCC事务模型  237
7.6  分布式锁  238
7.6.1  基于数据库实现悲观锁和乐观锁  239
7.6.2  基于ZooKeeper的分布式锁  241
7.6.3  基于Redis实现分布式锁  242
7.7  如何保证幂等性  244
7.7.1  幂等令牌（Idempotency Key）  244
7.7.2  在数据库中实现幂等性  246
第8章  未来值得关注的方向  247
8.1  Serverless  247
8.1.1  什么是Serverless  247
8.1.2  Serverless的现状  248
8.1.3  Serverless的应用场景  249
8.2  Service Mesh  250
8.2.1  什么是Service Mesh  250
8.2.2  为什么需要Service Mesh  252
8.2.3  Service Mesh的现状  253
8.2.4  Istio架构分析  255
第9章  研发流程  258
9.1  十二因子  258
9.2  为什么选择DevOps  261
9.3  自动化测试  263
9.3.1  单元测试  263
9.3.2  TDD  264
9.3.3  提交即意味着可测试  265
9.4  Code Review  265
9.4.1  Code Review的意义  265
9.4.2  Code Review的原则  266
9.4.3  Code Review的过程  267
9.5  流水线  267
9.5.1  持续交付  267
9.5.2  持续部署流水线  268
9.5.3  基于开源打造流水线  268
9.5.4  Amazon的流水线  271
9.5.5  开发人员自服务  271
9.6  为什么需要AIOps  272
9.7  基于数据和反馈持续改进  273
9.8  拥抱变化  274
9.9  代码即设计  274
第10章  团队文化  276
10.1  为什么团队文化如此重要  276
10.2  组织结构  278
10.2.1  团队规模导致的问题  278
10.2.2  康威定律  278
10.2.3  扁平化的组织  279
10.2.4  独裁的管理方式还是民主的管理方式  280
10.2.5  民主的团队如何做决策  282
10.3  环境氛围  282
10.3.1  公开透明的工作环境  282
10.3.2  学习型组织  283
10.3.3  减少正式的汇报  284
10.3.4  高效的会议  284
10.3.5  量化指标致死  286
10.4  管理风格  287
10.4.1  下属请假你会拒绝吗  287
10.4.2  为什么你招不到你想要的人  288
10.4.3  得到了所有人的认可，说明你并不是一个好的管理者  291
10.4.4  尽量避免用自己的权力去做决策  291
10.4.5  一屋不扫也可助你“荡平天下”  292
10.4.6  如何留下你想要的人293
10.5  经典案例  294
10.5.1  Instagram的团队文化  294
10.5.2  Netflix的团队文化  294
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>持续演进的Cloud Native：云原生架构下微服务最佳实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker微服务架构实战
第一部分  Docker与微服务基础	1
第1章  微服务架构概述	2
1.1  什么是微服务	2
1.1.1  CORBA	3
1.1.2  DCOM	4
1.1.3  RMI	5
1.1.4  SOA	7
1.2  为什么要使用微服务	9
1.2.1  scale cube	9
1.2.2  API网关	13
1.3  微服务架构设计原则	15
1.3.1  业务架构	15
1.3.2  逻辑架构	16
1.3.3  技术架构	19
1.3.4  基础架构	20
1.4  从单体到微服务	21
1.4.1  止损	22
1.4.2  前后端分离	23
1.4.3  提取服务	24
第2章  微服务中的技术选型	26
2.1  服务治理	27
2.1.1  Dubbo	27
2.1.2  Spring Cloud	30
2.2  服务网关	35
2.2.1  OpenResty	35
2.2.2  Orange	38
2.2.3  Kong	40
2.2.4  Zuul	41
2.3  服务注册发现	43
2.3.1  ZooKeeper	43
2.3.2  Eureka	49
2.4  配置中心	51
2.5  请求链路追踪	57
第3章  Service Mesh	64
3.1  初识Service Mesh	64
3.1.1  什么是Service Mesh	64
3.1.2  为什么使用Service Mesh	65
3.2  Service Mesh的发展过程	66
3.2.1  早期的分布式计算	66
3.2.2  微服务时代的分布式计算	68
3.3  主流的Service Mesh框架	73
第4章  Docker技术简介	75
4.1  Docker是什么	75
4.2  Docker的作用	77
4.2.1  用Docker快速搭建环境	78
4.2.2  用Docker降低运维成本	83
4.2.3  Docker下自动发布	84
4.3  Docker的生态圈	86
4.4  微服务与Docker	89
第二部分  Docker架构与生态	93
第5章  Docker技术架构	94
5.1  Docker的进程模型	94
5.1.1  容器中进程启动的两种模式	96
5.1.2  容器中的进程隔离模型	101
5.1.3  容器的自重启	102
5.1.4  容器中用户权限的隔离和传递	103
5.1.5  Docker守护进程宕机的处理机制	104
5.2  容器的本质	104
5.2.1  Namespace解惑	105
5.2.2  Rootfs解惑	106
5.2.3  CGroups解惑	109
5.3  Docker容器的运行时模型	111
第6章  Docker逻辑架构	113
6.1  Docker Registry的技术选型	114
6.2  Harbor的部署	115
第7章  Docker网络架构	120
7.1  Docker的单机网络模式	120
7.1.1  Bridge模式	120
7.1.2  Host模式	123
7.1.3  Container模式	124
7.1.4  None模式	125
7.2  Docker的集群网络模式	126
7.2.1  Bridge端口转发	126
7.2.2  扁平网络	127
7.2.3  Flannel模式	130
第8章  Docker安全架构	135
8.1  Docker安全问题	135
8.2  Docker安全措施	138
第9章  Docker与DevOps	148
9.1  DevOps概要	148
9.2  Docker容器的代码挂载机制	149
9.2.1  静态导入	149
9.2.2  动态导入	150
9.3  Docker与服务发现	150
9.4  Dockerfile怎么写	164
9.5  Docker与日志	172
9.6  Docker与监控	176
9.7  Docker与CI/CD	182
9.8  Docker给运维团队带来的挑战	184
第10章  容器编排	186
10.1  容器编排概述	186
10.2  容器编排技术选型	189
10.2.1  Docker Swarm	189
10.2.2  Kubernetes	191
10.2.3  Marathon	194
10.3  Kubernetes实战	197
10.3.1  Kubernetes快速安装	198
10.3.2  在Kubernetes上部署应用	203
10.4  Docker Swarm实战	210
10.4.1  Docker Swarm的快速安装	212
10.4.2  在Decker Swarm上部署应用	214
第三部分  Docker落地之路	221
第11章  企业级Docker容器云架构	222
11.1  宏观系统视角下的架构	222
11.2  容器云平台逻辑架构图	223
第12章  基于Rancher的容器云管理平台	226
12.1  Rancher概述	226
12.2  Rancher的安装	227
12.3  Rancher对IaaS的管理	228
12.4  Rancher下多租户多环境的管理	236
12.5  Rancher对SaaS的管理	240
12.6  Rancher对容器的管理	242
12.7  Rancher的L2-FLAT网络	248
12.8  Rancher 的服务治理	249
第13章  微服务与Docker化实战	258
13.1  整体架构鸟瞰	258
13.2  基于log-pilot的日志收集	261
13.3  基于Zabbix的容器监控	263
13.4  简单的DevOps架构图	264
13.5  推进方案和成本	266
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker微服务架构实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务架构开发实战
第1篇  微服务开发基础——Spring Boot框架及使用
第1章  微服务架构开发    2
1.1  单体架构应用的困境   2
1.2  微服务架构   3
1.2.1  如何定义微服务架构       4
1.2.2  微服务架构的优点   5
1.2.3  微服务架构的缺点   6
1.3  微服务架构设计   7
1.3.1  微服务粒度       7
1.3.2  微服务拆分原则       8
1.3.3  微服务自治原则       9
1.3.4  微服务交互原则       10
1.3.5  微服务架构迁移       10
1.4  不应使用微服务架构的情形      11
第2章  微服务基础——Spring Boot 12
2.1  Spring与Spring Boot  12
2.2  快速启动Spring Boot  13
2.2.1  编写pom.xml文件   14
2.2.2  编写应用引导类       16
2.2.3  编写配置文件   17
2.2.4  运行项目   17
2.3  使用Spring Boot构建示例项目 19
2.3.1  经典三层应用架构   19
2.3.2  设计领域对象   20
2.3.3  实现数据管理   23
2.3.4  编写业务逻辑层       29
2.3.5  编写RESTful API     31
2.3.6  数据库初始化   35
2.3.7  启动测试   36
2.4  Spring Boot特性  37
2.4.1  Spring Boot自动配置机制      37
2.4.2  Spring Boot扩展属性配置      38
2.4.3  Spring Boot日志配置      39
2.5  关于敏捷开发      40
2.6  关于RESTful API设计       41
2.6.1  以资源为中心进行URL设计  42
2.6.2  正确使用HTTP方法及状态码       42
2.6.3  查询及分页处理原则       43
2.6.4  其他指导原则   43
第2篇  Spring Cloud组件实战
第3章  Spring Cloud简介  46
3.1  微服务架构的核心关键点   46
3.2  Spring Cloud技术概览       49
3.2.1  Spring Cloud子项目 50
3.2.2  为何选择Spring Cloud     53
3.3  Spring Cloud版Hello World示例      54
第4章  服务治理与负载均衡    58
4.1  什么是服务治理   58
4.2  构建服务治理——Eureka   59
4.2.1  搭建微服务Parent工程   60
4.2.2  搭建服务治理服务器——Eureka服务器       62
4.2.3  搭建服务提供者——注册服务       64
4.2.4  搭建服务消费者——获取服务       68
4.3  使用客户端负载均衡——Ribbon      72
4.3.1  什么是客户端负载均衡   72
4.3.2  启用Ribbon      74
4.3.3  负载均衡测试   75
4.4  使用Feign简化微服务调用       77
4.5  深入Eureka  80
4.5.1  服务注册及相关原理       80
4.5.2  Eureka自我保护模式       82
4.5.3  注册一个服务实例需要的时间       84
4.5.4  Eureka高可用集群及示例       84
4.5.5  多网卡及IP指定      88
4.5.6  Eureka服务访问安全       89
4.6  深入Ribbon  90
4.6.1  Ribbon客户端负载均衡原理   90
4.6.2  Ribbon负载均衡策略及配置   92
4.6.3  直接使用Ribbon API       94
4.7  深入Feign    96
4.7.1  Feign的参数绑定     96
4.7.2  Feign中的继承  97
4.7.3  Feign与Swagger的冲突  98
4.8  微服务健康监控   99
4.9  异构服务解决方案——Sidecar   101
第5章  微服务容错保护——Hystrix       102
5.1  什么是微服务容错保护      102
5.2  快速启动Hystrix  103
5.2.1  引入Hystrix依赖     104
5.2.2  开启Hystrix支持     104
5.2.3  修改UserService实现      104
5.2.4  容错测试   105
5.2.5  服务降级的两种实现方式       107
5.2.6  在Feign中使用Hystrix回退   109
5.3  Hystrix容错机制分析  110
5.3.1  Hystrix整体处理流程      111
5.3.2  HystrixCommand与HystrixObservableCommand   113
5.3.3  断路器原理分析       115
5.3.4  Hystrix异常——HystrixBadRequestException       117
5.4  服务隔离      117
5.4.1  线程池隔离与信号量隔离       118
5.4.2  服务隔离的颗粒度   119
5.4.3  服务隔离配置   119
5.4.4  小结   120
5.5  服务降级模式      121
5.5.1  快速失败   121
5.5.2  静默失败   121
5.5.3  返回默认值       122
5.5.4  返回组装的值   122
5.5.5  返回远程缓存   123
5.5.6  主/从降级模式  124
5.6  请求缓存      127
5.7  请求合并      128
5.8  Hystrix监控  130
5.8.1  Hystrix仪表盘   131
5.8.2  Turbine仪表盘集群监控  133
5.8.3  Turbine与消息服务器集成      136
……
第6章  API服务网关——Zuul 137
第7章  统一配置中心——Config     166
第8章  分布式服务跟踪——Sleuth  192
第9章  消息驱动——Stream    215
第10章  微服务应用安全——Security    258
第3篇  微服务与Docker容器技术
第11章  微服务与Docker  288
11.1  Docker简介 288
11.2  Docker的使用    289
11.3  Docker与Spring Cloud微服务 301
11.4  微服务与Jenkins       305
11.5  微服务编排 315
显示部分信息
前　　言
前言　　2014年3月，Martin Fowler在其博客上发表了Microservices（微服务）一文，对过去几年逐渐开始流行的微服务架构开发模式给出了正式的定义。同年，Netflix OSS将自己多年来在实际开发中所使用的微服务基础组件开源。随后，Pivotal在Netflix OSS的基础上对这些组件进行了封装和集成，推出了Spring Cloud。到如今，微服务架构已逐渐普及，在技术生态上也得到了不断完善和更新，其在容器、应用框架、发布管理及监控等方面都有了长足进步。微服务在日常开发中也崭露头角，逐渐得到了开发者的认同。与此同时，Spring Cloud在过去几年中快速发展，不断迭代和更新，已经形成了微服务开发“全家桶”式的解决方案，逐渐在微服务开发领域奠定了坚实的基础。
当我第一次接触微服务的概念时，以为这又是一个“新瓶装旧酒”的把戏。就像当年一些大公司为解决分布式大型应用所提出的COBRA、EJB、DCOM和ESB等概念一样难以使用，它们甚至还没有来得及等用户完全掌握就退出了历史的舞台。当我再次注意到微服务时，是因为Spring Cloud的推出。在大致阅读了相关文档之后顺便“跑”了一下示例项目，我就被其深深吸引了。正是这次接触，使我改变了对微服务的看法。正巧接下来的一段时间，公司内部正在做架构调整，也发现了微服务有其可用之处，所以便在架构调整中引入了Spring Cloud，并最终在项目中取得了不错的效果。这加深了我对微服务的好感，所以后续对Spring Cloud进行了更加深入和系统的学习与研究。
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务架构开发实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>最强Android书：架构大剖析
关于本书  XIV
第1 章 Android 体系结构的变革之路  1
1.1 Android 系统版本的历史变迁  2
Froyo（冻酸奶）  3
Gingerbread（姜饼人）  3
Honeycomb（蜂巢）  4
Ice Cream Sandwich（冰激凌三明治）  5
JellyBean（果冻豆）  5
KitKat（奇巧）  6
Lollipop（棒棒糖）  7
Marshmallow（棉花糖）  8
Nougat（牛轧糖）  9
1.2 Android 与Linux  11
并非另一个Linux 发布版本  11
然后Android 就登场了  12
与Linux 的异同  13
Android 的框架  15
Dalvik 虚拟机  18
JNI  19
原生二进制可执行文件  20
Bionic  22
Android 的原生库  25
源自其他项目的原生库  27
硬件抽象层  28
Linux 内核  29
1.3 Android 的衍生产品  30
谷歌官方的衍生产品  30
非谷歌官方的衍生品  33
1.4 对前方道路的思考  36
兼容64 位  36
ART（Android 运行时）  37
多画面  38
把Android 用作台式机操作系统  38
Android 和ARA 项目  39
Brillo  40
本章小结  40
参考文献  41
第2 章 Android 的分区和文件系统  43
2.1 分区架构  43
需要许多单独分区的原因  44
GUID 分区表  45
闪存（Flash Storage）系统  46
文件系统  46
Android 设备中的分区  49
2.2 Android 文件系统中存储的内容  53
root 文件系统  53
/system 分区  54
/data 分区  65
/cache 分区  71
/vendor 目录  72
SD 卡  73
2.3 受保护的文件系统  74
OBB：Opaque Binary Blobs  74
ASec：Android 安全存储（Android Secure Storage）  76
2.4 Linux 伪文件系统  78
cgroupfs  78
debugfs  79
functionfs(/dev/usb-ffs/adb)  80
procfs(/proc)  81
pstore(/sys/fs/pstore)  81
selinuxfs(/sys/fs/selinux)  82
sysfs(/sys)  83
本章小结  84
参考文献  84
第3 章 Android 的启动、备份和重置  86
3.1 Android 系统镜像  87
Boot Loader  89
Boot 镜像  93
内核  95
RAM disk  97
/System 和/Data 分区镜像  99
3.2 启动过程  101
固件启动过程  101
内核启动过程  105
3.3 关机和重启  109
3.4 应用的备份和恢复  112
命令行工具  113
本地备份  114
监视备份操作  117
3.5 系统重置（recovery）和升级  119
OTA（Over-The-Air）升级包  121
制作你自己的ROM  124
制作ROM 时可用的网上资源  128
本章小结  130
参考文献  130
第4 章 init  132
4.1 init 的角色和任务  132
系统属性  134
.rc 文件  140
总结：init 的执行流程  146
4.2 init 和USB  150
4.3 init 的其他角色  152
ueventd  153
watchdogd  154
本章小结  154
XIV ┃ 最强Android 书：架构大剖析
本章讨论所涉及的文件  155
第5 章 Android 的守护进程  156
5.1 core 类中的服务  156
adbd  156
servicemanager  160
healthd  161
lmkd（Android L）  165
logd（Android L）  168
vold  173
5.2 网络相关服务  182
netd  182
mdnsd  187
mtpd  187
racoon  188
rild  189
5.3 图形及多媒体服务  190
surfaceflinger  190
bootanimation  192
mediaserver  194
drmserver  196
5.4 其他服务  197
installd  197
keystore  200
debuggerd[64]  204
gatekeeper（Android M）  207
sdcard  208
Zygote[64]  211
本章小结  214
本章讨论涉及的文件  214
参考文献  215
第6 章 框架服务的架构  216
6.1 再探servicemanager  217
6.2 服务调用的模式  222
优点和缺点  224
序列化和Android 接口定义语言（AIDL）  225
6.3 Binder  228
简明历史  228
那么，Binder 究竟是什么  229
使用Binder  230
分析Binder 的当前使用情况  231
6.4 system_server  232
启动及执行流程  232
修改启动时的行为  234
本章小结  237
本章讨论涉及的文件  237
参考文献  237
第７章 从Linux 角度看Android  238
7.1 重温/proc  239
符号链接：cwd、exe 和root  240
fd  243
fdinfo  245
status  247
7.2 用户模式内存管理  254
虚拟内存的分类和生命周期  254
内存的相关术语  258
内存不足时的应对方案  266
7.3 跟踪系统调用  269
toolbox ps 工具  269
wchan 和syscall 文件  270
strace 工具  271
本章小结  272
参考文献  272
第8 章 Android 安全性  274
8.1 移动安全威胁建模  275
攻击向量  275
攻击之道  278
8.2 Linux 层上的安全措施  281
Android 使用Linux 权限的方式  281
Linux 权能  289
SELinux  294
其他值得注意的特性  301
8.3 Dalvik 层上的安全措施  305
Dalvik 层上的权限  305
Dalvik 代码签名  310
8.4 用户层上的安全措施  312
锁屏机制  312
支持多用户  316
密钥管理  318
证书管理  318
密钥和私钥管理  322
8.5 存储安全  323
加密/data 分区  323
基于文件的加密（Nougat 7.1）  326
Direct Boot （Nougat 的新特性）  326
启动过程中加强验证  327
8.6 Root Android 设备  328
在设备启动环节中root  329
利用安全漏洞root  331
Root 对安全的影响  332
本章小结  334
参考文献  334
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>最强Android书：架构大剖析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>雾计算：技术、架构及应用
目录
译者序
前言
第一部分雾的通信与管理
第1章ParaDrop：家用网关的边缘计算平台2
1.1引言2
1.1.1通过ParaDrop实现无线网关的多重任务管理及相关应用3
1.1.2ParaDrop平台的性能4
1.2在ParaDrop平台上实现服务5
1.3为ParaDrop平台开发服务7
1.3.1依托ParaDrop平台实现监控摄像头业务7
1.3.2依托ParaDrop平台实现环境传感器业务10
参考文献10
第2章管理带宽11
2.1引言11
2.1.1利用雾12
2.1.2家庭问题的解决方案12
2.2相关研究14
2.3信用分配和最优信用支出15
2.3.1信用分配15
2.3.2最优信用支出17
2.4在线带宽分配算法18
2.4.1估计其他网关的支出18
2.4.2在线信用支出决策和应用优先级设置20
2.5设计与实现20
2.5.1流量和设备分类22
2.5.2速率限制引擎22
2.5.3流量优先级设置引擎23
2.6实验结果24
2.6.1速率限制24
2.6.2流量优先级设置25
2.7网关共享结果26
2.8结论29
致谢30
附录2.A30
参考文献33
第3章面向雾网络的社交感知协作D2D与D4D通信35
3.1引言35
3.1.1从社交信任和社交互惠到D2D协作36
3.1.2智能电网：社交感知协作的D2D和D4D通信的物联网案例37
3.1.3主要结论39
3.2相关研究39
3.3系统模型40
3.3.1物理（通信）图模型40
3.3.2社交图模型42
3.4面向雾网络的社交感知协作D2D和D4D通信概述42
3.4.1基于社交信任的中继选择43
3.4.2基于社交互惠的中继选择43
3.4.3基于社交信任和社交互惠的中继选择47
3.5网络辅助中继选择机制48
3.5.1互惠中继选择循环发现48
3.5.2NARS机制49
3.5.3NARS机制的特性51
3.6仿真53
3.6.1ER社交图53
3.6.2基于实际追踪的社交图56
3.7结论58
致谢59
参考文献59
第4章你值得拥有更好的性能（来自你的智能设备）62
4.1为什么需要提供更好的性能62
4.2需要在哪里提供更好的性能63
4.3需要提供什么性能并且怎样提供64
4.3.1透明度64
4.3.2可预测性能68
4.3.3开放性73
4.4结论74
致谢75
参考文献75
第二部分雾的存储与计算
第5章提高通信效率的分布式缓存80
5.1引言80
5.2微微缓存81
5.2.1系统模型81
5.2.2来自帮助者节点的
自适应流84
5.3用户缓存85
5.3.1基于簇的缓存和D2D通信85
5.3.2基于ITLinQ的缓存和通信…88
5.3.3编码组播93
5.4结论和展望96
参考文献96
第6章无线视频雾网络：错误可恢复的实时协作数据流99
6.1引言99
6.2相关研究102
6.3系统运行和网络模型103
6.4问题建模和复杂度105
6.4.1NC数据包选择优化106
6.4.2广播者选择优化107
6.4.3复杂度分析108
6.5VBCR:一种用于实时视频且能实现协作恢复的分布启发式算法108
6.5.1初始信息交换108
6.5.2协作恢复109
6.5.3更新信息交换111
6.5.4视频数据包转发112
6.6仿真结果113
6.7结论116
参考文献117
第7章弹性移动终端云：借助移动终端提供边缘的云计算服务119
7.1引言119
7.2设计领域及实例121
7.2.1Mont-Blanc121
7.2.2计算与充电并行处理122
7.2.3FemtoCloud123
7.2.4Serendipity125
7.3FemtoCloud性能评估126
7.3.1实验设置126
7.3.2FemtoCloud仿真结果127
7.3.3FemtoCloud原型评估130
7.4Serendipity性能评估131
7.4.1实验设置131
7.4.2Serendipity性能增益132
7.4.3网络环境的影响132
7.4.4工作属性的影响136
7.5挑战137
参考文献138
第三部分雾的应用
第8章雾计算在未来汽车行业中的作用142
8.1引言142
8.2当前的汽车电子架构143
8.3汽车E/E架构的未来挑战及解决策略145
8.4未来汽车——车轮上的雾节点149
8.5凭借实时计算和时间触发技术实现车轮上的确定性雾节点150
8.5.1通过虚拟化解决可扩展性挑战的确定性雾节点151
8.5.2解决连接和安全挑战的确定性雾节点152
8.5.3汽车应用中确定性雾节点的新用例——全车虚拟化154
8.6结论155
参考文献155
第9章现场网络的位置寻址156
9.1引言156
9.1.1现场网络156
9.1.2现场网络面临的挑战157
9.2位置寻址158
9.3SAGP:现场的无线位置寻址160
9.3.1SAGP处理流程160
9.3.2SAGP重传启发式算法161
9.3.3SAGP数据包传播示例162
9.3.4跟随发送:有效的SAGP数据流动163
9.3.5迎接挑战164
9.4地理路由:将GA延伸到云端165
9.5SGAF:大规模GA的一种多层架构166
9.5.1不同层之间的桥接167
9.5.2混合安全架构168
9.6AT&T实验室的位置辅助多播架构169
9.7两个GA应用实例170
9.7.1PSCommander170
9.7.2位置辅助多播游戏172
9.8结论174
参考文献174
第10章面向智慧星球的分布式在线学习和流处理175
10.1引言：智慧星球175
10.2实例问题：交通运输177
10.3流处理特征178
。。。。。。
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>雾计算：技术、架构及应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构之美：行业思想领袖揭秘软件设计之美（评注版）
序 xix
Stephen J. Mellor
前言 xxiii
第1 部分 论架构
第1 章 何谓架构 3
John Klein 与David Weiss
简介 3
创建软件架构 10
架构结构 14
好的架构 19
美丽架构 20
致谢 23
参考文献 23
第2 章 两个系统的故事：摩登时代的软件神话 25
Pete Goodliffe
混乱大都市 26
设计之城 33
然后呢 41
轮到你了 41
参考文献 42
第2 部分 企业应用架构
第3 章 可伸缩架构 45
Jim Waldo
简介 45
上下文 47
架构 51
对架构的思考 57
第4 章 记忆留存 63
Michael Nygard
功能与约束 64
工作流 65
架构要素 66
用户反应 87
结论 88
参考文献 88
第5 章 面向资源架构：在Web 之中 89
Brian Sletten
简介 89
传统的Web 服务 90
Web 92
面向资源架构 98
数据驱动应用 102
运用面向资源架构 103
结论 109
第6 章 数据增长：Facebook 平台的架构 111
Dave Fetterman
简介 111
创建社交Web 服务 117
创建社交数据查询服务 124
创建社交Web 门户：FBML 133
系统的支持功能 146
总结 151
第3 部分 系统架构
第7 章 XEN 与虚拟化之美 155
Derek Murray 与Keir Fraser
简介 155
Xenoservers 156
虚拟化的挑战 159
半虚拟化 159
Xen 的变化 163
变化中的硬件，变化中的Xen 169
前车之鉴 172
延伸阅读 173
第8 章 Guardian：一个容错操作系统环境 175
Greg Lehey
Tandem/16：未来所有计算机都将像这样构建 176
硬件 176
机械设计 178
处理器架构 179
处理器间总线 184
输入/输出 184
进程结构 185
消息系统 186
文件系统 190
逸闻趣事 195
弊端 195
后继者 197
延伸阅读 198
第9 章 JPC：纯Java 的X86 PC 模拟器 199
Rhys Newman 与Christopher Dennis
简介 200
概念验证 202
PC 架构 205
Java 性能技巧 206
4GB 放入4GB：这不会奏效 207
保护模式的危险 210
屡败屡战 214
劫持JVM 217
终极灵活性 229
终极安全性 231
吃一堑长一智 232
第10 章 元循环虚拟机的力量：Jikes RVM 235
Ian Rogers 与Dave Grove
背景 236
运行时环境之谜 237
Jikes RVM 简史 240
自部署运行时的自举 241
运行时组件 246
前车之鉴 259
参考文献 259
第4 部分 终端用户应用架构
第11 章 GNU Emacs：滋生的特性为其优势 263
Jim Blandy
Emacs 在使用 264
Emacs 的架构 266
滋生的特性 272
另外两个架构 275
第12 章 当集市开始构建教堂 279
Till Adam 与Mirko Boehm
简介 279
KDE 项目的历史与架构 282
Akonadi 287
ThreadWeaver 303
第5 部分 语言与架构
第13 章 软件架构：面向对象 vs. 面向函数 315
Bertrand Meyer
概览 315
函数式示例 318
评估函数式解决方案的模块化 321
面向对象视图 330
评估和改进面向对象的模块化 336
代理：将操作包裹到对象中 341
致谢 345
参考文献 346
第14 章 重读经典 349
Panagiotis Louridas
万物皆对象 353
类型被隐式定义 361
问题 367
土木建筑架构 372
参考文献 380
跋 383
William J. Mitchell
贡献者 387
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构之美：行业思想领袖揭秘软件设计之美（评注版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>游戏架构：核心技术与面试精粹
第一部分 架构与封装
第1 章 UI 交互 .............................................................................................................. 2
1.1 绑定事件响应 ........................................................................................................ 2
1.2 事件传递流程 ........................................................................................................ 7
1.3 事件响应接口 ...................................................................................................... 11
第2 章 玩法底层 ......................................................................................................... 16
2.1 游戏循环 .............................................................................................................. 16
2.2 时间记录 .............................................................................................................. 23
2.3 动画事件 .............................................................................................................. 27
2.4 游戏同步 .............................................................................................................. 31
第3 章 辅助系统 ......................................................................................................... 36
3.1 有限状态机 .......................................................................................................... 36
3.2 脚本系统 .............................................................................................................. 43
第二部分 艺术资源
第4 章 资源分类 ......................................................................................................... 50
4.1 贴图种类 .............................................................................................................. 50
4.2 材质效果 .............................................................................................................. 54
4.3 动画分类 .............................................................................................................. 63
4.4 流动效果 .............................................................................................................. 66
第5 章 后处理效果 ...................................................................................................... 71
5.1 模糊效果 .............................................................................................................. 71
5.2 泛光效果 .............................................................................................................. 79
5.3 辉光效果 .............................................................................................................. 83
5.4 景深 ...................................................................................................................... 94
第6 章 资源工作流 .................................................................................................... 108
6.1 图片格式更改 .................................................................................................... 108
6.2 动画抽取 ............................................................................................................ 111
6.3 文件移动检测 .................................................................................................... 116
第三部分 底层核心
第7 章 渲染原理 ....................................................................................................... 120
7.1 渲染管线 ............................................................................................................ 120
7.2 渲染顺序 ............................................................................................................ 126
第8 章 3D 数学基础 .................................................................................................. 129
8.1 点和向量 ............................................................................................................ 129
8.2 向量的运算 ........................................................................................................ 130
8.3 区域检测 ............................................................................................................ 138
8.4 平面移动 ............................................................................................................ 142
第９章 寻路算法 ........................................................................................................ 147
9.1 寻路这件事 ........................................................................................................ 147
9.2 A*算法 ............................................................................................................... 150
9.3 Navigation 系统 .................................................................................................. 158
9.4 任务调配 ............................................................................................................ 161
第四部分 自定义扩展
第10 章 调试工具 ..................................................................................................... 168
10.1 GM 命令 ........................................................................................................... 168
10.2 绘制曲线 .......................................................................................................... 174
10.3 指示绘制 .......................................................................................................... 181
第11 章 日志工具 ...................................................................................................... 190
11.1 出错暂停 .......................................................................................................... 190
11.2 日志接口优化 .................................................................................................. 195
11.3 频道化日志 ...................................................................................................... 199
11.4 崩溃日志上报 .................................................................................................. 204
第12 章 快捷功能 ..................................................................................................... 207
12.1 自定义菜单 ...................................................................................................... 207
12.2 定制UI ............................................................................................................. 213
12.3 回退操作 .......................................................................................................... 217
第13 章 后台服务 ..................................................................................................... 221
13.1 编辑器服务 ...................................................................................................... 221
13.2 自动注册框架 .................................................................................................. 225
13.3 遍历文件 .......................................................................................................... 228
第五部分 独立游戏
第14 章 角色分工 ..................................................................................................... 234
14.1 产品策划 .......................................................................................................... 234
14.2 美术设计 .......................................................................................................... 237
14.3 运营知识 .......................................................................................................... 241
14.3.1 用户规模数据 ................................................................................... 241
14.3.2 用户价值数据 ................................................................................... 244
14.4 总结 .................................................................................................................. 245
参考文献 ...................................................................................................................... 247
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>游戏架构：核心技术与面试精粹
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据时代的互联网架构设计
第一章 绪论
第一节 大数据概述
第二节 大数据的相关概念与理论
第二章 大数据处理流程与系统架构
第一节 大数据处理流程
第二节 大数据系统架构设计
第三章 大数据基础技术支持
第一节 大数据与云计算
第二节 虚拟化技术
第三节 数据采集
第四章 大数据存储
第一节 分布式文件系统概述
第二节 列式存储
第三节 文档存储
第四节 Key—Value存储
第五章 大数据处理
第一节 批处理
第二节 流式计算
第三节 数据分析与挖掘
第六章 大数据架构设计实例
第一节 大数据应用实例
第二节 行业应用架构设计实例
第三节 企业大数据系统架构实例
参考文献
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据时代的互联网架构设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构修炼之道——亿级网关、平台开放、分布式、微服务、容错等核心技术修炼实践
第1章  网关之道
1.1  认识API网关
1.1.1  API网关是什么
1.1.2  API网关涵盖的基本功能
1.1.3  API网关架构示例
1.2  一个API的生命周期
1.2.1  什么是API
1.2.2  生命周期
1.2.3  生命周期的过程
1.3  API网关的基石—泛化调用
1.4  如何发布API到网关系统
1.5  管道技术
1.5.1  管道实现
1.5.2  如何获取管道
1.5.3  管道信息传递
1.5.4  管道的优点
1.5.5  责任链模式
1.6  一个传统网关系统有几种“死”法
1.6.1  关注CPU
1.6.2  关注磁盘
1.6.3  关注网络
1.7  Servlet 3异步原理与实践
1.7.1  什么是Servlet
1.7.2  什么是Servlet规范
1.7.3  同步、异步、阻塞、非阻塞
1.7.4  Servlet 3的异步流程
1.7.5  Servlet 3的异步使用步骤
1.7.6  Servlet 3的异步使用示例
1.7.7  Tomcat NIO Connector、Servlet 3.0 Async和Spring MVC Async的关系
1.7.8  Servlet 3非阻塞I/O
1.8  全异步网关
1.9  脱库与多级缓存
1.9.1  脱库
1.9.2  多级缓存
1.10  热更新
1.11  网关系统的七种武器
1.12  本章小结
第2章  开放之道
2.1  认识OAuth 2.0
2.1.1  什么是OAuth 2.0
2.1.2  角色
2.1.3  OAuth 2.0协议流程
2.1.4  采用OAuth 2.0协议的开放平台
2.1.5  京东宙斯开放（授权码方式场景）
2.2  开放平台
2.2.1  一名开发者的基本需求
2.2.2  完整性
2.2.3  稳定性
2.2.4  安全性
2.2.5  整体技术架构
2.2.6  意义
2.3  如何设计一套SPI应用架构
2.3.1  API和SPI区别
2.3.2  术语约定
2.3.3  业务场景
2.3.4  架构实现
2.3.5  测试
2.3.6  SPI是一种思想
2.4  讲一讲越权
2.4.1  什么是越权访问
2.4.2  越权访问的种类
2.4.3  发生越权访问的根本原因
2.4.4  如何避免与解决
2.4.5  开放平台环境下的越权访问
2.5  从Facebook数据泄漏谈开放安全
2.5.1  OAuth 2.0授权
2.5.2  数据加/解密
2.5.3  IP地址白名单
2.5.4  平台内环境
2.6  API治理
2.6.1  性能
2.6.2  可用率
2.6.3  文档可读性
2.7  API经济
2.7.1  API盈利模式
2.7.2  API市场
2.7.3  API经济价值链
2.8  沙箱环境
2.8.1  协同
2.8.2  维护
2.9  本章小结
第3章  分布式之道
3.1  认识分布式
3.2  分布式事务
3.2.1  什么是分布式事务
3.2.2  CAP和BASE理论
3.3  分布式锁
3.3.1  为什么需要分布式锁
3.3.2  分布式锁的实现方式
3.4  分布式限流
3.4.1  计数器
3.4.2  限速器
3.4.3  限流的维度
3.4.4  流量包
3.4.5  再来谈令牌桶
3.5  衡量性能的指标QPS、TPS等
3.5.1  什么是QPS
3.5.2  什么是TPS
3.5.3  什么是RT
3.5.4  什么是并发数
3.6  本章小结
第4章  MQ之道
4.1  认识JMS
4.1.1  JMS的组成
4.1.2  JMS编程模型
4.1.3  JMS消息结构
4.1.4  JMS消息模型
4.2  带着思考理解MQ下的基本概念
4.2.1  生产者—消费者（Producer-Consumer）
4.2.2  空间解耦
4.2.3  时间解耦
4.2.4  观察者模式与发布/订阅
4.3  消费幂等
4.3.1  什么是幂等操作
4.3.2  是什么引起我们关注消费幂等
4.3.3  如何处理消费幂等
4.4  详述MQ各种功能场景
4.4.1  解耦
4.4.2  削峰填谷
4.4.3  最终一致性
4.4.4  广播消费
4.4.5  使用集群消费模拟广播
4.4.6  重试之坑
4.5  数据异构的武器—MQ+canal
4.5.1  定义
4.5.2  常见应用场景
4.5.3  数据异构方向
4.5.4  数据异构的常用方法
4.5.5  binlog和MQ方式
4.6  关于MQ再问自己几个问题
4.6.1  我想自己控制开始消费如何做
4.6.2  为什么需要消息过滤
4.6.3  过期消息是怎么处理的
4.6.4  消息重试的注意点
4.6.5  为什么需要事务消息
4.6.6  消息为什么没有了顺序
4.7  本章小结
第5章  消息推送之道
5.1  认识消息推送
5.2  构建长连接推送系统之HTTP实践
5.2.1  Web网络结构及配置
5.2.2  基本配置
5.2.3  Transfer-Encoding: chunked
5.2.4  HTTP长连接系统组成结构
5.2.5  Session管理
5.2.6  心跳
5.2.7  消息接收的概念
5.2.8  消息推送的概念
5.2.9  消息追踪
5.2.10  HTTP长连接系统时序调用
5.2.11  创建会话（连接）
5.2.12  心跳逻辑
5.2.13  消息接收实例
5.2.14  消息推送实例
5.2.15  半推半拉
5.2.16  系统优化
5.2.17  测试
5.3  构建消息推送系统之Netty实践
5.3.1  启动
5.3.2  创建会话
5.3.3  心跳
5.3.4  发送消息
5.3.5  注销会话
5.3.6  黏包
5.4  一台服务器可以“跑”多少个连接
5.5  一台服务器可以“跑”多少个线程
5.6  弱网络环境
5.7  发送APNs
5.7.1  认识APNs
5.7.2  HTTP/2
5.7.3  Pushy的使用
5.8  本章小结
第6章  RPC之道
6.1  认识RPC
6.2  RPC是如何实现通信的
6.2.1  动态代理
6.2.2  反射
6.2.3  序列化
6.2.4  网络编程
6.3  一次RPC调用时间都去哪儿了
6.4  异步RPC
6.4.1  异步调用
6.4.2  异步监听
6.4.3  callback调用
6.5  本章小结
第7章  I/O之道
7.1 认识I/O
7.2  解读I/O多路复用技术
7.2.1  I/O多路复用概述
7.2.2  用户进程和内核
7.2.3  select和recvfrom
7.2.4  阻塞、非阻塞
7.2.5  适用场景
7.3  解读Tomcat中的NIO模型
7.3.1  Tomcat对I/O模型的支持
7.3.2  Tomcat中NIO的配置与使用
7.3.3  NioEndpoint组件关系图解读
7.3.4  NioEndpoint执行序列图
7.3.5  关于性能
7.4  本章小结
第8章  微服务之道
8.1  认识微服务
8.2  微服务后如何做一次系统梳理
8.2.1  系统分类与演进
8.2.2  梳理目的要搞清楚
8.2.3  如何做
8.2.4  核心功能的核心流程梳理
8.3  朝着微服务的方向去做一次数据库拆分
8.3.1  现状
8.3.2  方法
8.3.3  拆库的步骤（MySQL）
8.4  本章小结
第9章  容错之道
9.1  认识容错
9.2  降级与限流
9.3  线程池隔离
9.3.1  为什么要做线程池隔离
9.3.2  实现一个线程池隔离
9.3.3  线程池隔离的优点
9.3.4  线程池隔离的缺点
9.4  快速失败
9.5  熔断
9.5.1  熔断器介绍
9.5.2  熔断使用注意
9.6  Hystrix的使用
9.6.1  认识Hystrix
9.6.2  线程池隔离
9.6.3  信号量隔离
9.6.4  熔断
9.6.5  回退降级
9.7  大促备战都“备”什么
9.7.1  分离技术
9.7.2  缓存技术
9.7.3  SQL优化
9.7.4  快速失败
9.7.5  降级限流
9.7.6  性能压测
9.8  本章小结
第10章  程序之外
10.1  程序与健身
10.2  程序员的硬件装备
10.3  程序员应该看的四本技术书籍
10.4  程序员应该熟悉的常用定律法则
10.5  知识、数据、工具
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>架构修炼之道——亿级网关、平台开放、分布式、微服务、容错等核心技术修炼实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hyperledger Fabric 技术内幕：架构设计与实现原理
前言
第1章　区块链基础与Hyperledger Fabric架构1
1.1　区块链背景、概念与现状1
1.1.1　区块链产生的背景及研究热潮1
1.1.2　区块链概念与核心技术6
1.1.3　区块链典型平台现状及趋势12
1.2　Hyperledger Fabric基本概念与架构15
1.2.1　基本概念15
1.2.2　Hyperledger Fabric架构22
1.2.3　安装基础环境与部署Fabric系统25
1.2.4　Fabric初始化启动流程30
1.2.5　Fabric交易处理流程58
1.3　Hyperledger Fabric源码分析说明60
1.3.1　源码分析思路60
1.3.2　配置机制64
1.4　小结66
第2章　Orderer排序节点67
2.1　功能概述68
2.2　Orderer节点启动流程70
2.2.1　加载orderer.yaml配置文件71
2.2.2　初始化日志与本地MSP组件73
2.2.3　启动Orderer排序节点74
2.3　Broadcast交易广播服务92
2.3.1　概述92
2.3.2　Broadcast服务消息处理93
2.4　Orderer共识排序服务（配置交易消息）102
2.4.1　概述102
2.4.2　Solo共识组件103
2.4.3　Kafka共识组件110
2.5　Orderer共识排序服务（普通交易消息）122
2.5.1　概述122
2.5.2　Solo共识组件123
2.5.3　Kafka共识组件126
2.6　Deliver区块分发服务131
2.6.1　概述132
2.6.2　Deliver服务消息处理133
2.6.3　Deliver服务客户端140
2.7　小结150
第3章　Peer节点151
3.1　功能概述152
3.1.1　链码生命周期管理152
3.1.2　系统链码155
3.1.3　用户链码156
3.2　Peer节点启动流程157
3.2.1　启动流程概述157
3.2.2　定义、注册命令与初始化配置157
3.2.3　初始化本地MSP组件159
3.2.4　执行启动Peer节点命令161
3.3　peer channel通道子命令183
3.3.1　定义注册channel子命令183
3.3.2　创建通道命令create189
3.3.3　Peer节点加入通道命令join193
3.3.4　获取区块命令fetch198
3.3.5　获取区块链信息getinfo201
3.3.6　获取已加入通道列表list205
3.3.7　签名配置交易文件signconfigtx207
3.3.8　更新通道配置update210
3.4　peer chaincode链码子命令212
3.4.1　定义注册chaincode子命令213
3.4.2　安装链码命令install216
3.4.3　实例化链码命令instantiate224
3.4.4　调用链码命令invoke232
3.4.5　查询链码命令query237
3.4.6　升级链码命令upgrade239
3.4.7　查询链码列表命令list244
3.4.8　打包链码命令package250
3.4.9　签名链码包命令signpackage254
3.5　其他子命令257
3.5.1　状态查询子命令257
3.5.2　版本子命令257
3.5.3　日志子命令257
3.6　小结258
第4章　Endorser背书节点259
4.1　功能概述259
4.2　Endorser背书服务261
4.3　预处理签名提案消息264
4.3.1　验证消息格式与签名合法性265
4.3.2　检查是否为允许外部调用的系统链码266
4.3.3　检查签名提案消息的唯一性266
4.3.4　检查是否满足通道的访问权限策略267
4.4　模拟执行提案268
4.4.1　检查实例化策略270
4.4.2　启动链码容器概述271
4.4.3　准备启动链码容器276
4.4.4　启动系统链码inprocContainer容器285
4.4.5　启动用户链码Docker容器290
4.4.6　消息处理核心函数300
4.4.7　请求链码执行311
4.4.8　停止链码容器321
4.4.9　处理模拟执行结果323
4.5　对模拟执行结果签名背书326
4.6　小结330
第5章　Committer记账节点331
5.1　功能概述332
5.2　创建与调用Committer功能模块333
5.2.1　创建Committer功能模块333
5.2.2　调用Committer功能模块335
5.3　交易验证器341
5.3.1　验证交易数据的合法性342
5.3.2　VSCC验证交易背书策略353
5.4　账本提交器370
5.4.1　验证与准备数据374
5.4.2　提交账本数据388
5.5　小结397
第6章　Gossip消息模块398
6.1　功能概述399
6.2　Gossip消息模块启动流程402
6.2.1　创建与初始化Gossip服务器实例402
6.2.2　初始化通道上的Gossip服务模块410
6.3　Gossip消息通信与处理机制418
6.3.1　Gossip消息概述418
6.3.2　Gossip消息通信与处理机制420
6.3.3　Gossip服务实例中的消息处理462
6.3.4　state模块中的数据消息处理485
6.3.5　state模块中的远程状态与隐私数据消息处理490
6.3.6　Fetcher组件中的隐私数据请求与响应消息处理494
6.3.7　election选举模块中的主节点选举消息处理499
6.4　Gossip节点管理机制501
6.4.1　管理新加入Peer节点501
6.4.2　选举Leader主节点503
6.4.3　更新节点相关信息机制508
6.5　Gossip数据分发与状态同步机制513
6.5.1　分发区块数据流程513
6.5.2　分发隐私数据流程515
6.5.3　更新通道状态信息521
6.5.4　更新数据消息522
6.6　Gossip反熵算法523
6.6.1　获取当前最大的账本高度523
6.6.2　分批发送远程状态请求消息525
6.6.3　处理远程状态请求消息527
6.7　小结530
第7章　公共功能模块531
7.1　账本数据存储模块531
7.1.1　Peer节点账本532
7.1.2　idStore数据库541
7.1.3　区块数据文件与隐私数据库542
7.1.4　区块索引数据库565
7.1.5　状态数据库565
7.1.6　历史数据库579
7.1.7　transient隐私数据库580
7.2　安全服务模块600
7.2.1　MSP（成员关系服务模块）600
7.2.2　BCCSP（区块链密码服务模块）609
7.3　Events事件模块611
7.3.1　创建事件服务器611
7.3.2　订阅与发布事件613
7.3.3　注册与注销事件616
7.4　小结618
附录A　Hyperledger Fabric配置文件619
附录B　e2e_cli示例相关文件情况628
参考文献633
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Hyperledger Fabric 技术内幕：架构设计与实现原理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务架构与实践（第2版）
第1 部分 基础篇
第1 章 微服务架构综述 ................................................................................................. 2
1.1 软件架构发展历史 .......................................................................................................... 2
1.2 微服务的诞生背景 .......................................................................................................... 8
1.3 什么是微服务架构 ........................................................................................................ 15
1.4 微服务架构的本质 ........................................................................................................ 23
1.5 微服务架构的特征 ........................................................................................................ 28
1.6 微服务架构不是“银弹” ............................................................................................ 34
1.7 微服务架构与SOA ....................................................................................................... 39
1.8 微服务与Serverless ....................................................................................................... 40
1.9 微服务与Service Mesh ................................................................................................. 46
1.10 小结 .............................................................................................................................. 53
第2 部分 策略篇
第2 章 微服务生态系统 ............................................................................................... 57
2.1 为什么定义生态系统 .................................................................................................... 57
2.2 微服务生态系统的核心内容 ........................................................................................ 59
2.3 生态系统的工程实践 .................................................................................................... 66
2.4 小结 ............................................................................................................................... 73
第3 章 微服务关键技术 ............................................................................................... 74
3.1 服务设计 ........................................................................................................................ 74
3.2 服务治理 ...................................................................................................................... 116
3.3 服务运维 ...................................................................................................................... 131
3.4 小结 .............................................................................................................................. 142
第4 章 微服务参考模型 ............................................................................................. 143
4.1 为什么需要参考模型 .................................................................................................. 143
4.2 参考模型的核心内容 .................................................................................................. 144
4.3 如何使用参考模型 ...................................................................................................... 172
4.4 小结 .............................................................................................................................. 183
第5 章 基于参考模型的实践 ...................................................................................... 184
5.1 微服务团队 .................................................................................................................. 184
5.2 核心敏捷实践 .............................................................................................................. 192
5.3 服务设计与实现 .......................................................................................................... 198
5.4 运维管理 ...................................................................................................................... 212
5.5 测试管理 ...................................................................................................................... 235
5.6 交付流水线 .................................................................................................................. 269
5.7 部署管理实践 .............................................................................................................. 288
5.8 小结 .............................................................................................................................. 333
第6 章 遗留系统的微服务改造 .................................................................................. 334
6.1 遗留系统综述 .............................................................................................................. 334
6.2 遗留系统改造策略 ...................................................................................................... 336
6.3 遗留系统改造场景 ...................................................................................................... 341
6.4 遗留系统改造案例 ...................................................................................................... 347
6.5 小结 .............................................................................................................................. 354
第3 部分 实战篇
第7 章 微服务开发框架ServiceComb ...................................................................... 356
7.1 ServiceComb 综述 ....................................................................................................... 356
7.2 Java Chassis .................................................................................................................. 361
7.3 Go Chassis 详解 ........................................................................................................... 364
7.4 注册中心ServiceCenter .............................................................................................. 365
7.5 数据一致性框架Saga ................................................................................................. 372
7.6 小结 .............................................................................................................................. 376
第8 章 微服务云应用平台ServiceStage ................................................................... 377
8.1 ServiceStage 综述 ........................................................................................................ 377
8.2 CCE 云容器引擎服务 ................................................................................................. 379
8.3 CSE 微服务引擎 .......................................................................................................... 384
8.4 SWR 软件镜像仓库 .................................................................................................... 386
8.5 AOS 编排服务 ............................................................................................................. 387
8.6 APM 应用性能管理 .................................................................................................... 389
8.7 小结 .............................................................................................................................. 391
第9 章 SockShop 系统分析与设计 ............................................................................ 392
9.1 系统综述 ...................................................................................................................... 392
9.2 需求理解与分析 .......................................................................................................... 395
9.3 服务划分与设计 .......................................................................................................... 396
9.4 架构设计 ...................................................................................................................... 401
9.5 基础设施塔建 .............................................................................................................. 404
9.6 小结 .............................................................................................................................. 407
第10 章 实现SockShop 系统的第一个服务 .............................................................. 408
10.1 使用Java Chassis 实现商品服务 .............................................................................. 408
10.2 使用Docker-Compose 本地运行服务 ...................................................................... 415
10.3 商品服务自动化测试 ................................................................................................ 416
10.4 搭建交付流水线 ........................................................................................................ 419
10.5 小结 ............................................................................................................................ 423
第11 章 实现SockShop 系统的其他服务 .................................................................. 424
11.1 实现用户服务 ............................................................................................................ 425
11.2 实现购物车服务 ........................................................................................................ 432
11.3 实现订单服务 ............................................................................................................ 434
11.4 实现支付服务 ............................................................................................................ 437
11.5 实现物流服务 ............................................................................................................ 438
11.6 实现用户界面服务 .................................................................................................... 440
11.7 使用Pact 验证服务 ................................................................................................... 451
11.8 运行SockShop 系统 .................................................................................................. 456
11.9 小结 ............................................................................................................................ 459
第12 章 部署SockShop 系统 ................................................................................... 460
12.1 SockShop 系统的TOSCA 模板 ................................................................................ 460
12.2 部署SockShop 系统 .................................................................................................. 465
第13 章 运维SockShop 系统 ................................................................................... 468
13.1 监控告警 .................................................................................................................... 468
13.2 日志聚合 .................................................................................................................... 475
13.3 服务治理 .................................................................................................................... 476
13.4 小结 ............................................................................................................................ 479
附录A ServiceStage 相关概念 .................................................................................. 481
附录B TOSCA 模板介绍 ........................................................................................... 483
写在最后 ...................................................................................................................... 486
参考文献 ...................................................................................................................... 488
资源列表 ...................................................................................................................... 490
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务架构与实践（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件架构
前言
教学建议
上篇　基础理论篇
第1章　软件架构概述 …… 2
1.1　软件架构产生的背景 …… 2
1.2　软件架构的主要思想和特征 …… 3
1.2.1　软件架构的主要思想 …… 3
1.2.2　软件架构的特征 …… 3
1.3　软件架构的发展阶段 …… 4
1.3.1　基础研究阶段（1968—1994） …… 4
1.3.2　概念体系和核心技术形成阶段（1991—2000） …… 6
1.3.3　理论体系完善与发展阶段（1996年至今） …… 7
1.3.4　普及应用阶段（1999年至今） …… 7
1.4　软件架构研究和应用现状 …… 7
1.4.1　软件架构理论和方法研究 …… 8
1.4.2　软件架构的应用研究 …… 11
1.5　本章小结 …… 13
思考题 …… 13
参考文献 …… 14
第2章　软件架构的概念 …… 17
2.1　引言 …… 17
2.2　组成派的主要定义 …… 18
2.3　决策派的主要定义 …… 19
2.4　其他定义 …… 20
2.5　参考定义框架 …… 20
2.6　本章小结 …… 21
思考题 …… 22
参考文献 …… 22
第3章　软件架构模型 …… 23
3.1　引言 …… 23
3.2　软件架构的可视化建模方法 …… 24
3.2.1　基于图形可视化的建模方法 …… 24
3.2.2　基于UML的建模方法 …… 25
3.3　软件架构的形式化建模方法 …… 31
3.3.1　基于形式化规格说明语言的建模方法 …… 32
3.3.2　基于UML的形式化建模方法 …… 36
3.4　其他建模方法 …… 45
3.4.1　文本语言建模方法 …… 45
3.4.2　模型驱动的架构建模方法 …… 47
3.5　软件架构建模方法的发展趋势分析 …… 49
3.5.1　第1层：文本模型 …… 50
3.5.2　第2层：图形可视化模型 …… 50
3.5.3　第3层：UML模型 …… 50
3.5.4　第4层：形式化模型 …… 51
3.5.5　第5层：未来模型 …… 52
3.6　本章小结 …… 52
思考题 …… 53
参考文献 …… 53
第4章　软件架构的风格与模式 …… 59
4.1　软件架构风格的定义 …… 59
4.2　软件架构风格的分类 …… 60
4.3　典型的软件架构风格 …… 60
4.3.1　管道-过滤器风格 …… 60
4.3.2　主程序/子程序风格 …… 62
4.3.3　面向对象风格 …… 64
4.3.4　层次化风格 …… 65
4.3.5　事件驱动风格 …… 67
4.3.6　解释器风格 …… 69
4.3.7　基于规则的系统风格 …… 71
4.3.8　仓库风格 …… 73
4.3.9　黑板系统风格 …… 75
4.3.10　C2风格 …… 77
4.3.11　客户机/服务器风格 …… 79
4.3.12　浏览器/服务器风格 …… 83
4.3.13　平台/插件风格 …… 85
4.3.14　面向Agent风格 …… 87
4.3.15　面向方面架构风格 …… 91
4.3.16　面向服务架构风格 …… 93
4.3.17　正交架构风格 …… 95
4.3.18　异构风格 …… 97
4.3.19　基于层次消息总线的架构风格 …… 99
4.3.20　模型-视图-控制器风格 …… 101
4.4　软件架构模式 …… 103
4.5　本章小结 …… 103
思考题 …… 104
参考文献 …… 104
第5章　软件架构描述语言 …… 107
5.1　引言 …… 107
5.2　ADL的核心设计元素 …… 107
5.2.1　组件 …… 108
5.2.2　连接件 …… 108
5.2.3　架构配置 …… 109
5.3　几种典型的ADL …… 109
5.3.1　Aesop …… 109
5.3.2　C2 SADL …… 110
5.3.3　UniCon …… 114
5.3.4　Wright …… 116
5.3.5　XYZ/ADL …… 117
5.3.6　ACME …… 118
5.3.7　XBA …… 118
5.3.8　ABC/ADL …… 120
5.3.9　MetaH …… 121
5.3.10　Rapide …… 121
5.3.11　Darwin …… 122
5.3.12　xADL 2.0 …… 122
5.4　本章小结 …… 123
思考题 …… 123
参考文献 …… 123
第6章　软件架构与敏捷开发 …… 125
6.1　软件开发的发展简史 …… 125
6.2　敏捷开发 …… 127
6.2.1　敏捷开发的基本理念 …… 127
6.2.2　敏捷开发实践 …… 128
6.3　敏捷开发过程中的软件架构设计 …… 130
6.3.1　需求分析 …… 130
6.3.2　初始设计 …… 130
6.3.3　迭代过程 …… 130
6.3.4　敏捷的设计思想 …… 131
6.4　两类常见的敏捷软件架构设计方法 …… 132
6.4.1　敏捷开发初始阶段设计 …… 133
6.4.2　敏捷开发迭代过程中的设计 …… 134
6.5　本章小结 …… 136
思考题 …… 137
参考文献 …… 137
中篇　工程实践篇
第7章　架构驱动的软件开发 …… 140
7.1　架构驱动的软件开发简介 …… 140
7.2　架构需求获取 …… 140
7.3　架构设计、文档化和评估 …… 144
7.3.1　架构设计、文档化和评估是一个迭代过程 …… 144
7.3.2　什么是架构的结构 …… 147
7.3.3　从架构需求出发的评估 …… 148
7.3.4　寻找ATAM中的“权衡点”和“敏感点” …… 149
7.4　架构的实现与维护 …… 151
7.4.1　架构的实现 …… 151
7.4.2　架构的维护 …… 152
7.5　本章小结 …… 152
思考题 …… 152
参考文献 …… 153
第8章　软件架构设计和实现 …… 154
8.1　从需求分析到架构设计 …… 154
8.1.1　软件架构对需求的影响 …… 155
8.1.2　基于软件需求的软件架构设计 …… 156
8.1.3　需求与架构的协同演化 …… 163
8.2　从软件架构到详细设计 …… 163
8.2.1　详细设计对软件架构的影响 …… 164
8.2.2　从软件架构映射到详细设计 …… 166
8.2.3　软件架构视图 …… 168
8.3　软件架构设计原则 …… 169
8.3.1　架构设计的一些基本原则 …… 169
8.3.2　架构设计的关键原则 …… 170
8.4　软件架构设计面临的主要威胁及对策 …… 171
8.4.1　被忽略的重要非功能需求 …… 171
8.4.2　频繁变化的需求 …… 172
8.4.3　考虑不全面的架构设计 …… 172
8.4.4　不及时的架构验证 …… 173
8.4.5　较高的创造性架构比重 …… 173
8.4.6　架构的低可执行性 …… 174
8.5　本章小结 …… 174
思考题 …… 174
参考文献 …… 174
第9章　软件架构的演化和维护 …… 178
9.1　软件架构演化和软件架构定义的关系 …… 179
9.1.1　对象演化 …… 179
9.1.2　消息演化 …… 180
9.1.3　复合片段演化 …… 184
9.1.4　约束演化 …… 186
9.2　软件架构演化方式的分类 …… 186
9.2.1　软件架构静态演化 …… 187
9.2.2　软件架构动态演化 …… 190
9.3　软件架构演化原则 …… 197
9.4　软件架构维护 …… 201
9.4.1　软件架构知识管理 …… 201
9.4.2　软件架构修改管理 …… 202
9.4.3　软件架构版本管理 …… 202
9.5　本章小结 …… 202
思考题 …… 203
参考文献 …… 203
第10章　软件架构恢复 …… 207
10.1　引言 …… 207
10.1.1　软件架构的恢复过程 …… 208
10.1.2　架构信息提取 …… 208
10.1.3　架构恢复技术 …… 209
10.2　架构信息提取 …… 212
10.2.1　相关定义 …… 212
10.2.2　从源代码提取架构信息 …… 212
10.2.3　从编译构建过程提取架构信息 …… 215
10.2.4　从目录层次提取架构信息 …… 217
10.2.5　基于架构文档的架构信息提取 …… 219
10.3　基于多规则聚类的架构恢复 …… 220
10.3.1　聚类理论基础 …… 220
10.3.2　架构恢复流程 …… 222
10.3.3　具体恢复技术 …… 223
10.4　本章小结 …… 232
思考题 …… 233
参考文献 …… 233
第11章　软件架构质量 …… 237
11.1　引言 …… 237
11.2　软件架构与质量属性 …… 239
11.3　软件架构质量指标 …… 240
11.3.1　内部质量指标 …… 240
11.3.2　外部质量指标 …… 243
11.4　软件架构质量保障和评估方法 …… 245
11.4.1　评估准备 …… 246
11.4.2　利益相关者 …… 247
11.4.3　参与者 …… 248
11.4.4　评估时机 …… 249
11.4.5　评估技术 …… 250
11.4.6　软件架构评估的收益与成本 …… 253
11.5　本章小结 …… 254
思考题 …… 254
参考文献 …… 254
第12章　软件架构仿真 …… 256
12.1　软件仿真的概念 …… 256
12.1.1　连续型仿真 …… 256
12.1.2　离散型仿真 …… 257
12.1.3　混合型仿真 …… 257
12.2　软件架构仿真流程 …… 258
12.3　UML软件架构仿真 …… 259
12.3.1　基于UML类图和顺序图的软件架构仿真 …… 259
12.3.2　基于UML用例图和活动图的软件架构仿真 …… 259
12.3.3　从带有注释的UML图产生OPNET仿真模型 …… 260
12.4　非UML软件架构仿真 …… 261
12.4.1　SASIM仿真：用于系统功能分析 …… 261
12.4.2　面向对象数据库的架构仿真 …… 263
12.5　软件架构仿真实践 …… 264
12.5.1　软件架构描述文档 …… 264
12.5.2　SSD和SD转化为事件执行图 …… 266
12.5.3　局部仿真和整体仿真 …… 269
12.5.4　仿真结果的分析 …… 275
12.6　本章小结 …… 276
思考题 …… 276
参考文献 …… 277
第13章　软件架构度量和评估 …… 279
13.1　引言 …… 279
13.1.1　单版本的软件架构度量和评估 …… 280
13.1.2　多版本的软件架构度量和评估 …… 281
13.2　典型的软件架构度量和评估方法 …… 283
13.2.1　SAEM方法 …… 283
13.2.2　SAABNet方法 …… 283
13.2.3　SACMM方法 …… 285
13.2.4　SASAM方法 …… 287
13.2.5　ALRRA方法 …… 288
13.2.6　AHP方法 …… 290
13.2.7　COSMIC+UML方法 …… 291
13.2.8　基于Shannon信息论的方法 …… 292
13.3　软件架构度量和评估过程 …… 293
13.3.1　质量属性选择 …… 293
13.3.2　软件架构可维护性度量及评估 …… 294
13.3.3　软件架构可靠性度量及评估 …… 297
13.4　软件架构演化度量和评估实践 …… 302
13.4.1　演化过程已知的软件架构演化评估 …… 302
13.4.2　演化过程未知的软件架构演化评估 …… 305
13.4.3　实例分析 …… 305
13.5　本章小结 …… 313
思考题 …… 313
参考文献 …… 313
第14章　软件架构形式化验证 …… 317
14.1　引言 …… 317
14.2　形式化验证 …… 317
14.2.1　形式语义 …… 318
14.2.2　规约语言 …… 318
14.2.3　求精分析 …… 319
14.2.4　验证方法 …… 320
14.2.5　形式化验证方法的优缺点 …… 320
14.3　软件架构验证 …… 322
14.3.1　静态软件架构验证 …… 322
14.3.2　动态软件架构验证 …… 323
14.3.3　运行态软件架构验证 …… 323
14.4　基于SPIN的静态软件架构验证实践 …… 324
14.4.1　SPIN简介 …… 324
14.4.2　基于SPIN的验证过程 …… 325
14.4.3　架构模型 …… 326
14.4.4　验证模型 …… 332
14.4.5　验证结果 …… 334
14.5　架构演化验证案例分析——以MVC为例 …… 335
14.5.1　演化案例 …… 335
14.5.2　场景1演化评估 …… 337
14.5.3　场景2演化评估 …… 341
14.6　本章小结 …… 344
思考题 …… 345
参考文献 …… 345
第15章　软件架构分析与测试 …… 347
15.1　引言 …… 347
15.2　软件架构分析方法 …… 347
15.2.1　SAAM …… 348
15.2.2　SAAMCS …… 350
15.2.3　ESAAMI …… 351
15.2.4　SAAMER …… 352
15.2.5　ATAM …… 352
15.2.6　QAW …… 356
15.2.7　OATAM …… 358
15.2.8　ARID …… 358
15.2.9　SBAR …… 361
15.2.10　ALPSM …… 362
15.2.11　SNA …… 362
15.2.12　ALMA …… 363
15.2.13　PSAEM …… 364
15.2.14　ASAAM …… 365
15.2.15　PASA …… 365
15.2.16　SALUTA …… 367
15.2.17　HoPLAA …… 368
15.2.18　CBAM …… 370
15.2.19　CPASA …… 370
15.3　软件架构测试 …… 371
15.4　本章小结 …… 371
思考题 …… 372
参考文献 …… 372
第16章　软件架构重构 …… 375
16.1　引言 …… 375
16.2　软件重构现状 …… 376
16.2.1　软件重构概念 …… 376
16.2.2　重构点识别和定位方法 …… 376
16.2.3　重构实施技术 …… 379
16.2.4　现状分析 …… 380
16.3　基于度量的软件架构重构 …… 381
16.3.1　软件架构度量评估 …… 382
16.3.2　产生重构需求 …… 385
16.3.3　分析重构需求 …… 385
16.3.4　建议重构操作 …… 387
16.3.5　实施重构操作 …… 389
16.4　面向模式的软件架构重构 …… 392
16.4.1　模式选择 …… 392
16.4.2　重构点定位 …… 393
16.4.3　重构实施 …… 394
16.5　本章小结 …… 397
思考题 …… 398
参考文献 …… 398
下篇　未来主题篇
第17章　软件架构的腐蚀和对策 …… 402
17.1　引言 …… 402
17.2　软件架构腐蚀的含义 …… 403
17.3　软件架构腐蚀的预防控制策略 …… 403
17.3.1　腐蚀最小化方法 …… 403
17.3.2　腐蚀预防方法 …… 406
17.3.3　腐蚀修补方法 …… 407
17.4　软件架构实践中面临的主要威胁及其对策 …… 408
17.4.1　主要威胁 …… 408
17.4.2　有效对策 …… 409
17.5　本章小结 …… 409
思考题 …… 409
参考文献 …… 409
第18章　软件架构解耦 …… 412
18.1　引言 …… 412
18.2　分层架构及其解耦 …… 413
18.2.1　模式描述 …… 413
18.2.2　架构解耦 …… 413
18.2.3　实例分析 …… 414
18.3　微内核架构及其解耦 …… 414
18.3.1　模式描述与解耦 …… 415
18.3.2　实例分析 …… 415
18.4　微服务架构及其解耦 …… 416
18.4.1　模式描述与解耦 …… 416
18.4.2　设计原则 …… 417
18.4.3　实例分析 …… 417
18.5　黑板架构风格及其解耦 …… 418
18.6　干净架构及其解耦 …… 419
18.6.1　模式描述 …… 419
18.6.2　架构解耦 …… 421
18.7　管道-过滤器风格及其解耦 …… 421
18.7.1　模式描述与解耦 …… 421
18.7.2　实例分析 …… 422
18.8　基于元模型的架构及其解耦 …… 422
18.9　REST架构风格及其解耦 …… 422
18.10　本章小结 …… 424
思考题 …… 424
参考文献 …… 424
第19章　软件架构技术债 …… 426
19.1　引言 …… 426
19.2　技术债简介 …… 426
19.2.1　技术债的定义 …… 426
19.2.2　技术债的分类 …… 427
19.2.3　技术债的产生 …… 428
19.3　设计债 …… 429
19.3.1　设计债的定义 …… 429
19.3.2　设计债的识别方法 …… 429
19.3.3　架构技术债 …… 430
19.4　代码债 …… 432
19.5　测试债 …… 432
19.6　文档债 …… 433
19.7　技术债的处理 …… 433
19.7.1　发现技术债 …… 433
19.7.2　管理技术债 …… 433
19.7.3　偿还技术债 …… 435
19.8　本章小结 …… 435
思考题 …… 435
参考文献 …… 436
第20章　软件架构坏味道 …… 438
20.1　引言 …… 438
20.2　典型的代码坏味道 …… 439
20.2.1　应用级坏味道 …… 439
20.2.2　类级坏味道 …… 440
20.2.3　方法级坏味道 …… 441
20.3　典型的设计坏味道 …… 442
20.3.1　架构坏味道 …… 442
20.3.2　架构坏味道的检测 …… 447
20.4　本章小结 …… 450
思考题 …… 451
参考文献 …… 451
第21章　软件架构脆弱性 …… 453
21.1　引言 …… 453
21.2　什么是软件脆弱性 …… 453
21.2.1　软件脆弱性定义 …… 453
21.2.2　软件脆弱性的特点和产生的原因 …… 454
21.2.3　软件脆弱性的生命周期 …… 455
21.3　典型的软件架构脆弱性 …… 455
21.3.1　分层架构 …… 456
21.3.2　C/S架构 …… 457
21.3.3　B/S架构 …… 457
21.3.4　事件驱动架构 …… 458
21.3.5　MVC架构 …… 460
21.3.6　微内核架构 …… 461
21.3.7　管道-过滤器架构 …… 461
21.3.8　黑板模式架构 …… 462
21.3.9　微服务架构 …… 462
21.3.10　基于空间的架构 …… 463
21.3.11　PAC架构 …… 464
21.4　本章小结 …… 465
思考题 …… 466
参考文献 …… 466
第22章　软件架构模式识别 …… 468
22.1　引言 …… 468
22.2　模式识别方法现状 …… 468
22.2.1　设计模式识别现状 …… 468
22.2.2　架构模式识别现状 …… 469
22.3　两种典型的架构模式识别方法 …… 470
22.3.1　IDAPO方法 …… 470
22.3.2　基于DSL的架构模式识别方法 …… 472
22.4　基于本体的架构模式识别方法 …… 473
22.4.1　可行性分析 …… 473
22.4.2　识别过程 …… 474
22.4.3　典型步骤 …… 475
22.5　本章小结 …… 481
思考题 …… 481
参考文献 …… 481
第23章　结束语 …… 484
23.1　软件架构是早期阶段质量保障的基础 …… 484
23.2　软件架构的作用 …… 485
23.2.1　好的架构设计能够满足系统的多种品质 …… 485
23.2.2　架构设计能够使利益相关者达成一致的目标 …… 485
23.2.3　架构设计能够支持计划编制过程 …… 485
23.2.4　架构设计能够有效地管理复杂性 …… 486
23.2.5　架构设计为重用奠定了基础 …… 486
23.2.6　架构设计能够降低维护费用 …… 487
23.2.7　架构设计能够支持冲突分析 …… 487
23.2.8　架构设计的其他作用 …… 487
23.3　软件架构发展趋势 …… 487
思考题 …… 489
参考文献 …… 489
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大型系统应用架构实战：部署、容灾、性能优化
第 1 章 总体技术方案 ................................................ 1
1.1  分析建模 ............................................ 1
1.2  系统的总体架构 .................................................. 7
1.3  小结 .................................................................................................... 8
第 2 章 全球区域化部署技术 ................................................................ 9
2.1  总体架构 ............................................................................................ 9
2.2  路由服务 .......................................................................................... 13
2.2.1  路由表原理 .......................................................................... 16
2.2.2  路由表的更新机制 .............................................................. 23
2.2.3  用户路由更新方案 .............................................................. 30
2.3  多层路由实现 .................................................................................. 37
2.3.1  统一接入层路由技术 .......................................................... 37
2.3.2  服务层路由技术 .................................................................. 43
2.3.3  消息层路由技术 .................................................................. 49
2.3.4  数据层跨区域路由技术 ...................................................... 56
2.3.5  数据层一致性校验技术 ...................................................... 60
2.4  全球实时分流技术和区域化容灾技术 ........................................... 62
2.4.1  全球实时分流技术和按需路由技术 .................................. 63
2.4.2  区域化容灾技术 .................................................................. 66
2.5  其他关键技术 .................................................................................. 70
2.5.1 全局 ID 服务 ........................................................................ 70
2.5.2  库存区域写 ......................................................................... 74
2.5.3  全球建站方案 ..................................................................... 77
第 3 章 全球网络调度技术 ................................................................. 83
3.1  网络基础设施 .................................................................................. 84
3.2  网络调度实现 .................................................................................. 88
第 4 章 性能优化 .............................................................................. 94
4.1  为什么要做性能优化 ...................................................................... 94
4.2  一次请求的漫游 ............................................................................ 100
4.3  寻找性能瓶颈 ................................................................................ 105
4.4  快速跨越互联网大门 .................................................................... 113
4.4.1 DNS 背后的奥秘 .............................................................. 113
4.4.2 加速 DNS 解析 ................................................................. 117
4.5  让数据更快地到达用户端 ............................................................ 120
4.5.1 可靠的 TCP ....................................................................... 123
4.5.2 应用层协议之 HTTP ......................................................... 129
4.5.3 安全协议之 HTTPS .......................................................... 131
4.5.4  数据传输可以更快............................................................ 133
4.6  加速浏览器呈现 ............................................................................ 153
4.7  克服无线网络的痛 ........................................................................ 160
第 5 章 SRE .................................................................................. 166
5.1 SRE 介绍 ........................................................................................ 166
5.2 SRE 的总体思路 ............................................................................ 169
5.3  基础治理方案 ................................................................................ 174
5.4  监控实践 ........................................................................................ 175
5.5 SRE 规范 ........................................................................................ 181
5.5.1  写作目的 ........................................................................... 181
5.5.2  重要名词解释 ................................................................... 181
5.5.3  总体原则 ............................................................................ 183
5.5.4  KPIGuideline ...................................................................... 185
5.5.5  稳定性规范详细介绍 ........................................................ 185
5.6  飞虎队作战手册 ............................................................................ 197
5.6.1  总体思路 ............................................................................ 197
5.6.2  角色定义 ............................................................................ 198
5.6.3  飞虎队作战流程 ................................................................ 199
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大型系统应用架构实战：部署、容灾、性能优化
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据架构之道与项目实战
第 1章  企业级大数据平台服务的总体设计
1.1平台架构设计的总体技术要求
1.2微服务引擎的可扩展性设计
1.3微服务引擎的优秀解决方案
1.3.1  高并发采集微服务
1.3.2  灵活转发微服务
1.3.3  高可扩展海量存储服务
1.3.4  高并发海量存储服务
1.3.5  高可靠海量存储服务
1.3.6  实时计算服务
1.3.7  基于机器学习的智能分析服务
1.3.8  自定义迁移服务
1.4设计小结· 17
第 2章  大数据高并发采集微服务引擎
2.1核心需求分析和优秀解决方案
2.2服务引擎的技术架构设计
2.2.1  Maven与 Eclipse集成配置
2.2.2  Mina2.0框架以及业务设计
2.2.3  设备协议规范制定及数据包设计
2.2.4  按照设备和数据类型进行业务树构建
2.2.5  按照设备的数据包状态进行解析
2.2.6  按照通用方式进行高并发入库
2.3核心技术讲解及模块化设计
2.3.1  Spring Maven Web服务构建
2.3.2  Spring Boot微服务构建
2.3.3  数据包定义和实现
2.3.4  业务树构建和实现
2.3.5  数据包状态进行解析实现
2.3.6  按照通用方式进行高并发入库实现
2.3.7  客户端模拟器工具类进行高并发测试
2.4项目小结·
第 3章  大数据灵活转发微服务引擎
3.1核心需求分析和优秀解决方案
3.2服务引擎的技术架构设计
3.3核心技术讲解及模块化实现
3.3.1  Spring MVC Web服务构建
3.3.2  Spring Boot微服务构建
3.3.3  灵活配置和通用工具类构建
3.3.4  创建发送数据主题，注册观察者对象
3.3.5  启动多线程进行数据发送
3.3.6  采用 Post策略模式进行数据发送
3.3.7  采用 ActiveMQ策略模式进行数据发送
3.4项目小结· 173
4.1核心需求分析和优秀解决方案
4.2服务引擎的技术架构设计
4.3核心技术讲解及模块化实现
4.3.1 Spring MVC的工作原理及执行流程
4.3.2  Spring MVC Web服务构建
4.3.3  Spring Boot Web微服务构建
4.3.4  统一对外数据接收接口及通用类
4.3.5  MySQL对智能终端运动数据的分状态和分策略处理
4.3.6  MySQL对智能终端运动数据的分职责处理
4.3.7  MySQL对智能终端运动数据的统一入库处理
4.4项目小结
第 5章  大数据高并发海量存储微服务引擎
5.1核心需求分析和优秀解决方案
5.2服务引擎的技术架构设计
5.3核心技术讲解及模块化实现
5.3.1  Spring MVC和 Spring Boot集成 MongoDB
5.3.2  MongoTemplate核心类实现 Dao层接口
5.3.3  基于 MongoDB处理智能终端运动数据
5.3.4  基于 MongoDB管道技术处理体检数据
5.3.5  基于 AngularJS架构可视化体检数据
5.4项目小结·
第 6章  大数据高可靠海量存储微服务引擎
6.1核心需求分析和优秀解决方案
6.2服务引擎的技术架构设计
6.3核心技术讲解及模块化实现
6.3.1  Hadoop完全分布式集群构建
6.3.2  Spring MVC和 Spring Boot集成 Hbase
6.3.3 HbaseTemplate核心类实现 Dao层接口
6.3.4  Hbase集群的智能终端运动数据 Controller接口
6.3.5  Hbase集群的智能终端运动数据 Service接口
6.3.6  Hbase集群的智能终端运动数据 Dao接口
6.4项目小结
第 7章  大数据实时计算微服务引擎
7.1核心需求分析和优秀解决方案
7.2服务引擎的技术架构设计
7.3核心技术讲解及模块化实现
7.3.1 分布式采集服务 Flume部署及数据采集
7.3.2  分布式消息服务 Kafka部署及数据发送
7.3.3  创建 HBase数据库和 Spark环境
7.3.4  分布式实时处理引擎 Spark Streaming原理及数据处理
7.3.5  构建 BD_RTPServer_DP工程实现数据处理
7.3.6  构建 BD_RTPServer_Boot服务实现可视化
7.4项目小结
第 8章  大数据智能分析微服务引擎
8.1核心需求分析和优秀解决方案
8.2服务引擎的技术架构设计
8.3核心机器学习算法讲解和应用
8.3.1 逻辑回归的原理分析
8.3.2  支持向量机原理分析
8.3.3  决策树原理分析
8.3.4  聚类算法原理分析
8.3.5  关联规则算法原理分析
8.3.6  协同过滤原理分析
8.4  Spark架构原理与数据预测
8.4.1  YARN运行架构工作原理
8.4.2 Spark Mlib核心技术
8.4.3  Spring Maven工程构建
8.4.4  决策树预测体检费用
8.4.5  逻辑回归预测体检费用
8.4.6  随机森林预测体检费用
8.4.7  支持向量机预测疾病概率
8.4.8  协同过滤推荐药品
8.5项目小结
第 9章  大数据自定义迁移微服务引擎
9.1核心需求分析和优秀解决方案
9.2服务引擎的技术架构设计
9.3核心技术讲解及模块化实现
9.3.1  Hadoop生态的核心组件
9.3.2  HBase工作原理
9.3.3  Sqoop工作原理
9.3.4  MapReduce工作原理
9.3.5  Sqoop抽取历史数据到 HDFS
9.3.6  构建工程 BD_CustomTransfer_Maven
9.3.7  智能终端运动数据从 MySQL数据迁移到 Hive
9.4项目小结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据架构之道与项目实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业内部控制架构设计实操手册
第一部分企业内部控制与顶层设计/1
第一章企业内部控制的顶层设计路线图/3
第一节 企业内控需求的挖掘 / 5
第二节 获取顶层资源支持 / 16
第三节 顶层关系维护 / 34
第二章企业内部控制的前瞻性从哪来/39
第一节 内控方向与战略方向的一致性检查 / 41
第二节 企业现有能力与战略所期望能力的匹配度检查 / 49
第二部分企业内部控制与数据底层设计/61
第三章管理信息系统的铺谋设计/63
第一节 管理信息系统的框架搭建 / 66
第二节 管理信息系统模块的运营 / 79
第四章数据的养和用/87
第一节养数据：数据采集与持续更新 / 89
第二节 用数据：数据利用与产品开发 / 96
第三部分企业内部控制与运营中间层设计/109
第五章搭建内控执行的基础架构/111
第一节 建立职能本位 / 113
第二节 打造执行网络 / 122
第六章制定内控执行的个性化解决方案/131
第一节 找好落地点 / 133
第二节 把握落地的时机 / 139
第三节 顺势而为 / 142
第四节 轻鉴证、重咨询 / 146
第七章扩展内控执行的人际圈层/154
第一节 联结利益相关方 / 156
第二节 完善内部信息沟通系统 / 161
第三节 寻找并培育内控执行的关键据点 / 166
第四节 做事重要，做人更重要 / 172
第八章把握内控的度/179
第一节 刚柔并济 / 181
第二节 变与不变之间 / 188
第三节 几组平衡 / 193
第九章案例解析/202
后记/211
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>企业内部控制架构设计实操手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Serverless架构应用开发：Python实现
第1章　Serverless范式　　1
1.1　了解Serverless架构　　1
1.2　了解微服务　　3
1.3　Serverless架构不仅仅是实时的　　3
1.4　Serverless的优缺点　　5
1.5　小结　　7
第2章　在AWS中构建Serverless应用程序　　8
2.1　AWS Lambda的触发器　　8
2.2　Lambda函数　　12
2.3　函数即容器　　13
2.4　配置函数　　14
2.5　测试Lambda函数　　21
2.6　Lambda函数的版本控制　　24
2.7　创建部署包　　27
2.8　小结　　31
第3章　设置Serverless架构　　32
3.1　S3触发器　　32
3.2　SNS触发器　　40
3.3　SQS触发器　　49
3.4　CloudWatch触发器　　56
3.5　小结　　61
第4章　部署Serverless API　　63
4.1　API方法与资源　　63
4.2　设置集成　　70
4.3　为API部署Lambda函数　　77
4.4　处理身份验证与用户控制　　82
4.5　小结　　87
第5章　日志与监控　　88
5.1　了解CloudWatch　　88
5.2　了解CloudTrail　　97
5.3　CloudWatch的Lambda指标　　103
5.4　CloudWatch的Lambda日志　　111
5.5　Lambda的日志语句　　114
5.6　小结　　117
第6章　扩展Serverless架构　　118
6.1　第三方编排工具　　118
6.2　服务器的创建和终止　　124
6.3　最佳安全实践　　130
6.4　扩展的难点及解决方案　　135
6.5　小结　　137
第7章　AWS Lambda的安全性　　138
7.1　了解AWS VPC　　138
7.2　了解VPC中的子网　　143
7.3　在私有子网内保护Lambda　　147
7.4　Lambda函数的访问控制　　150
7.5　在Lambda中使用STS执行安全会话　　150
7.6　小结　　150
第8章　使用SAM部署Lambda函数　　151
8.1　SAM简介　　151
8.2　将CloudFormation用于Serverless服务　　154
8.3　使用SAM进行部署　　155
8.4　了解SAM中的安全性　　162
8.5　小结　　166
第9章　微软Azure Functions简介　　167
9.1　微软Azure Functions简介　　167
9.2　创建你的第一个Azure Function　　169
9.3　了解触发器　　172
9.4　Azure Functions的日志记录和监控　　176
9.5　编写微软Azure Functions的最佳实践　　178
9.6　小结　　180
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Serverless架构应用开发：Python实现
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>游戏引擎架构（第2版）
第2 版序言• • • • • • • • • • • • • • • •  xxxiii
第1 版序言• • • • • • • • • • • • • • • •  xxxv
第2 版前言• • • • • • • • • • • • • • • •  xxxvii
第1 版前言• • • • • • • • • • • • • • • • xxxviii
致谢 • • • • • • • • • • • • • • • • •  xl
第I 部分 基 础
第1 章 导论• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 3
1.1 典型游戏团队的结构 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 4
1.1.1 工程师 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 5
1.1.2 艺术家 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 5
1.1.3 游戏设计师 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 6
1.1.4 制作人 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 7
1.1.5 其他工作人员• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 7
1.1.6 发行商及工作室• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 7
1.2 游戏是什么 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 8
1.2.1 电子游戏作为软实时模拟• • • • • • • • • • • • • • • • • • • • • • • • • • • • • 8
1.3 游戏引擎是什么• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 10
1.4 不同游戏类型的引擎差异• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 11
1.4.1 第一人称射击游戏• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 12
1.4.2 平台及其他第三人称游戏• • • • • • • • • • • • • • • • • • • • • • • • • • • • • 13
1.4.3 格斗游戏 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 15
1.4.4 竞速游戏 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 17
1.4.5 实时策略游戏• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 18
1.4.6 大型多人在线游戏• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 20
1.4.7 玩家创作内容†• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 21
1.4.8 其他游戏类型• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 23
1.5 游戏引擎概览 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 24
1.5.1 雷神之锤引擎家族• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 24
1.5.2 虚幻引擎 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 25
1.5.3 Source 引擎• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 26
1.5.4 DICE 的寒霜引擎† • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 26
1.5.5 CryEngine† • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 26
1.5.6 索尼的PhyreEngine† • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 27
1.5.7 微软的XNA Game Studio• • • • • • • • • • • • • • • • • • • • • • • • • • • • 27
1.5.8 Unity† • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 27
1.5.9 供非程序员使用的二维游戏引擎† • • • • • • • • • • • • • • • • • • • • • • • • • 28
1.5.10 其他商业引擎 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 29
1.5.11 专有内部引擎 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 29
1.5.12 开源引擎• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 29
1.6 运行时引擎架构• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 30
1.6.1 目标硬件 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 32
1.6.2 设备驱动程序• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 32
1.6.3 操作系统 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 32
1.6.4 第三方软件开发包和中间件• • • • • • • • • • • • • • • • • • • • • • • • • • • • 33
1.6.5 平台独立层 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 36
1.6.6 核心系统 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 36
1.6.7 资源管理器 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 37
1.6.8 渲染引擎 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 37
1.6.9 剖析和调试工具• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 41
1.6.10 碰撞和物理• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 42
1.6.11 动画• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 43
1.6.12 人体学接口设备 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 44
1.6.13 音频• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 45
1.6.14 在线多人/网络游戏• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 46
1.6.15 游戏性基础系统 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 47
1.6.16 个别游戏专用子系统 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 50
1.7 工具及资产管道• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 50
1.7.1 数字内容创作工具• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 50
1.7.2 资产调节管道• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 52
1.7.3 世界编辑器 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 54
1.7.4 资源数据库† • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 55
1.7.5 一些构建工具的方法• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 55
第2 章 专业工具• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 58
2.1 版本控制• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 58
2.1.1 为何使用版本控制• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 58
2.1.2 常见的版本控制系统• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 59
2.1.3 Subversion 和TortoiseSVN 概览• • • • • • • • • • • • • • • • • • • • • • • • • 60
2.1.4 在Google 上设置代码版本库• • • • • • • • • • • • • • • • • • • • • • • • • • • 61
2.1.5 安装TortoiseSVN• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 61
2.1.6 文件版本、更新和提交• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 63
2.1.7 多人签出、分支及合并• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 64
2.1.8 删除 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 66
2.2 微软Visual Studio• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 66
2.2.1 源文件、头文件及翻译单元• • • • • • • • • • • • • • • • • • • • • • • • • • • • 67
2.2.2 程序库、可执行文件及动态链接库• • • • • • • • • • • • • • • • • • • • • • • • • 67
2.2.3 项目及解决方案• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 68
2.2.4 生成配置 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 69
2.2.5 调试代码 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 75
2.3 剖析工具• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 81
2.3.1 剖析器列表 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 83
2.4 内存泄漏和损坏检测 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 83
2.5 其他工具• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 84
第3 章 游戏软件工程基础 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 85
3.1 重温C++ 及最佳实践 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 85
3.1.1 扼要重温面向对象编程• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 85
3.1.2 编码标准: 为什么及需要多少• • • • • • • • • • • • • • • • • • • • • • • • • • • 91
3.1.3 C++11† • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 92
3.2 C/C++ 的数据、代码及内存• • • • • • • • • • • • • • • • • • • • • • • • • • • • 99
3.2.1 数值表达形式• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 99
3.2.2 声明、定义及链接规范• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 109
3.2.3 C/C++ 内存布局• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 115
3.2.4 成员变量 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 119
3.2.5 对象的内存布局• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 121
3.2.6 kilobyte 及kibibyte • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 129
3.3 捕捉及处理错误• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 129
3.3.1 错误类型 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 129
3.3.2 错误处理 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 130
3.3.3 实现错误检测及处理• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 132
3.4 流水线、缓存及优化• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 136
3.4.1 并行范式转移• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 136
3.4.2 内存缓存 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 137
3.4.3 指令流水线及超纯量CPU • • • • • • • • • • • • • • • • • • • • • • • • • • • • 142
第4 章 游戏所需的三维数学• • • • • • • • • • • • • • • • • • • • • • • • • • • • • 146
4.1 在二维中解决三维问题 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 146
4.2 点和矢量• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 146
4.2.1 点和笛卡儿坐标• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 147
4.2.2 左手坐标系与右手坐标系的比较 • • • • • • • • • • • • • • • • • • • • • • • • • 148
4.2.3 矢量 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 149
4.2.4 矢量运算 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 150
4.2.5 点和矢量的线性插值• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 160
4.3 矩阵 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 160
4.3.1 矩阵乘法 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 161
4.3.2 以矩阵表示点和矢量• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 162
4.3.3 单位矩阵 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 163
4.3.4 逆矩阵 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 163
4.3.5 转置矩阵 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 163
4.3.6 齐次坐标 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 164
4.3.7 基础变换矩阵• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 165
4.3.8 4 × 3 矩阵 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 168
4.3.9 坐标空间 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 168
4.3.10 基的变更• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 171
4.3.11 变换法矢量• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 175
4.3.12 在内存中存储矩阵 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 175
4.4 四元数• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 177
4.4.1 把单位四元数视为三维旋转• • • • • • • • • • • • • • • • • • • • • • • • • • • • 178
4.4.2 四元数运算 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 178
4.4.3 以四元数旋转矢量• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 180
4.4.4 等价的四元数和矩阵• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 181
4.4.5 旋转性的线性插值• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 183
4.5 比较各种旋转表达方式 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 185
4.5.1 欧拉角 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 185
4.5.2 3 × 3 矩阵 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 186
4.5.3 轴角 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 186
4.5.4 四元数 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 187
4.5.5 SQT 变换• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 187
4.5.6 对偶四元数 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 188
4.5.7 旋转和自由度• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 188
4.6 其他数学对象 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 189
4.6.1 直线、光线及线段 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 189
4.6.2 球体 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 190
4.6.3 平面 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 190
4.6.4 轴对齐包围盒• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 192
4.6.5 定向包围盒 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 193
4.6.6 平截头体 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 193
4.6.7 凸多面体区域• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 194
4.7 硬件加速的SIMD 运算• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 194
4.7.1 SSE 寄存器• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 195
4.7.2 __m128 数据类型• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 196
4.7.3 用SSE 内部函数编码 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 197
4.7.4 用SSE 实现矢量与矩阵的相乘• • • • • • • • • • • • • • • • • • • • • • • • • • 199
4.8 产生随机数 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 203
4.8.1 线性同余产生器• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 204
4.8.2 梅森旋转 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 204
4.8.3 所有伪随机数产生器之母及Xorshift • • • • • • • • • • • • • • • • • • • • • • • 205
第II 部分 底层引擎系统
第5 章 游戏支持系统 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 209
5.1 子系统的启动和终止 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 209
5.1.1 C++ 的静态初始化次序(是不可用的) • • • • • • • • • • • • • • • • • • • • • • 209
5.1.2 行之有效的简单方法• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 212
5.1.3 一些实际引擎的例子• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 214
5.2 内存管理• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 218
5.2.1 优化动态内存分配• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 218
5.2.2 内存碎片 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 227
5.3 容器 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 231
5.3.1 容器操作 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 232
5.3.2 迭代器 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 233
5.3.3 算法复杂度 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 234
5.3.4 建立自定义的容器类• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 236
5.4 字符串• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 248
5.4.1 字符串的使用问题• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 248
5.4.2 字符串类 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 249
5.4.3 唯一标识符 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 249
5.4.4 本地化 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 253
5.5 引擎配置• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 263
5.5.1 读/写选项• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 263
5.5.2 个别用户选项• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 264
5.5.3 真实引擎中的配置管理• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 265
第6 章 资源及文件系统• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 270
6.1 文件系统• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 270
6.1.1 文件名和路径• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 271
6.1.2 基本文件I/O • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 274
6.1.3 异步文件I/O • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 277
6.2 资源管理器 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 281
6.2.1 离线资源管理及工具链• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 281
6.2.2 运行时资源管理• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 289
第7 章 游戏循环及实时模拟• • • • • • • • • • • • • • • • • • • • • • • • • • • • • 305
7.1 渲染循环• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 305
7.2 游戏循环• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 306
7.2.1 简单例子:《乓》• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 306
7.3 游戏循环的架构风格 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 308
7.3.1 视窗消息泵 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 308
7.3.2 回调驱动框架• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 309
7.3.3 基于事件的更新• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 311
7.4 抽象时间线 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 311
7.4.1 真实时间 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 311
7.4.2 游戏时间 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 311
7.4.3 局部及全局时间线• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 312
7.5 测量及处理时间• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 313
7.5.1 帧率及时间增量• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 313
7.5.2 从帧率到速率• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 314
7.5.3 使用高分辨率计时器测量实时时间 • • • • • • • • • • • • • • • • • • • • • • • • 317
7.5.4 时间单位和时钟变量• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 318
7.5.5 应对断点 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 321
7.5.6 一个简单的时钟类• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 322
7.6 多处理器的游戏循环 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 325
7.6.1 多处理器游戏机的架构• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 326
7.6.2 SIMD• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 331
7.6.3 分叉及汇合 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 331
7.6.4 每个子系统运行于独立线程• • • • • • • • • • • • • • • • • • • • • • • • • • • • 333
7.6.5 作业模型 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 334
7.6.6 异步程序设计• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 334
7.7 网络多人游戏循环• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 337
7.7.1 主从式模型 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 337
7.7.2 点对点模型 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 339
7.7.3 案例分析:《雷神之锤II》• • • • • • • • • • • • • • • • • • • • • • • • • • • • • 339
第8 章 人体学接口设备• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 342
8.1 各种人体学接口设备 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 342
8.2 人体学接口设备的接口技术• • • • • • • • • • • • • • • • • • • • • • • • • • • • • 344
8.2.1 轮询 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 344
8.2.2 中断 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 344
8.2.3 无线设备 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 345
8.3 输入类型• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 345
8.3.1 数字式按钮 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 345
8.3.2 模拟式轴及按钮• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 347
8.3.3 相对性轴 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 348
8.3.4 加速计 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 348
8.3.5 以Wii 遥控器或DualShock 做三维定向 • • • • • • • • • • • • • • • • • • • • • 349
8.3.6 摄像机 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 350
8.4 输出类型• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 352
8.4.1 震动反馈 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 352
8.4.2 力反馈 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 353
8.4.3 音频 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 353
8.4.4 其他输入/输出 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 353
8.5 游戏引擎的人体学接口设备系统 • • • • • • • • • • • • • • • • • • • • • • • • • • 353
8.5.1 典型需求 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 354
8.5.2 死区 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 354
8.5.3 模拟信号过滤• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 355
8.5.4 输入事件检测• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 357
8.5.5 为多位玩家管理多个HID • • • • • • • • • • • • • • • • • • • • • • • • • • • • 364
8.5.6 跨平台的HID 系统 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 364
8.5.7 输入的重新映射• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 366
8.5.8 上下文相关控制• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 367
8.5.9 禁用输入 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 368
8.6 人体学接口设备使用实践• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 368
第9 章 调试及开发工具• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 370
9.1 日志及跟踪 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 370
9.1.1 使用OutputDebugString() 做格式化输出• • • • • • • • • • • • • • • • • • • • • 371
9.1.2 冗长级别 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 372
9.1.3 频道 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 373
9.1.4 把输出同时抄写至日志文件• • • • • • • • • • • • • • • • • • • • • • • • • • • • 374
9.1.5 崩溃报告 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 374
9.2 调试用的绘图功能• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 375
9.2.1 调试绘图API • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 378
9.3 游戏内置菜单 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 382
9.4 游戏内置主控台• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 385
9.5 调试用摄像机和游戏暂停• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 386
9.6 作弊 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 386
9.7 屏幕截图及录像• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 387
9.8 游戏内置性能剖析• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 387
9.8.1 层阶式剖析 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 389
9.8.2 导出至Excel • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 394
9.9 游戏内置的内存统计和泄漏检测 • • • • • • • • • • • • • • • • • • • • • • • • • • 394
第III 部分 图形、运动与声音
第10 章 渲染引擎 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 401
10.1 采用深度缓冲的三角形光栅化基础 • • • • • • • • • • • • • • • • • • • • • • • • 401
10.1.1 场景描述• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 403
10.1.2 描述表面的视觉性质 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 410
10.1.3 光照基础• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 423
10.1.4 虚拟摄像机• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 432
10.2 渲染管道• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 442
10.2.1 渲染管道概览 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 443
10.2.2 工具阶段• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 444
10.2.3 资产调节阶段 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 446
10.2.4 GPU 简史• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 447
10.2.5 GPU 管道• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 448
10.2.6 可编程着色器 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 452
10.2.7 抗锯齿† • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 456
10.2.8 应用程序阶段 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 459
10.3 高级光照及全局光照• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 468
10.3.1 基于图像的光照 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 468
10.3.2 高动态范围光照 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 472
10.3.3 全局光照• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 473
10.3.4 延迟渲染• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 479
10.3.5 基于物理着色† • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 480
10.4 视觉效果和覆盖层• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 481
10.4.1 粒子效果• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 481
10.4.2 贴花• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 482
10.4.3 环境效果• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 483
10.4.4 覆盖层• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 486
10.4.5 伽马校正• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 487
10.4.6 全屏后期处理效果 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 488
10.5 延伸阅读• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 489
第11 章 动画系统 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 490
11.1 角色动画的类型 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 490
11.1.1 赛璐璐动画• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 490
11.1.2 刚性层阶式动画 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 491
11.1.3 每顶点动画及变形目标 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 492
11.1.4 蒙皮动画• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 493
11.1.5 把动画方法视为数据压缩技术• • • • • • • • • • • • • • • • • • • • • • • • • • 494
11.2 骨骼• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 495
11.2.1 骨骼层阶结构 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 496
11.2.2 在内存中表示骨骼 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 497
11.3 姿势• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 498
11.3.1 绑定姿势• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 498
11.3.2 局部姿势• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 499
11.3.3 全局姿势• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 501
11.4 动画片段• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 502
11.4.1 局部时间线• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 503
11.4.2 全局时间线• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 506
11.4.3 比较局部和全局时钟 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 508
11.4.4 简单的动画数据格式 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 511
11.4.5 连续的通道函数 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 512
11.4.6 元通道• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 513
11.5 蒙皮及生成矩阵调色板• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 514
11.5.1 每顶点的蒙皮信息 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 515
11.5.2 蒙皮涉及的数学知识 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 515
11.6 动画混合• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 519
11.6.1 线性插值混合 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 519
11.6.2 线性插值混合的应用 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 521
11.6.3 复杂的线性插值混合 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 526
11.6.4 骨骼分部混合 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 529
11.6.5 加法混合• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 531
11.6.6 加法混合的应用 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 533
11.7 后期处理• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 536
11.7.1 程序式动画• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 536
11.7.2 逆运动学• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 537
11.7.3 布娃娃• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 538
11.8 压缩技术• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 538
11.8.1 通道省略• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 539
11.8.2 量化• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 539
11.8.3 采样频率及键省略 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 543
11.8.4 基于曲线的压缩 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 543
11.8.5 选择性载入及串流 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 544
11.9 动画系统架构• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 544
11.10 动画管道 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 545
11.10.1 数据结构 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 546
11.10.2 扁平的加权平均混合表示法 • • • • • • • • • • • • • • • • • • • • • • • • • • 549
11.10.3 混合树 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 552
11.10.4 淡入/淡出架构 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 555
11.10.5 动画管道的优化• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 557
11.11 动作状态机 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 559
11.11.1 动画状态 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 559
11.11.2 过渡 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 565
11.11.3 状态层 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 568
11.11.4 控制参数 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 570
11.11.5 约束 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 571
11.12 动画控制器 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 579
第12 章 碰撞及刚体动力学• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 580
12.1 你想在游戏中加入物理吗 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 580
12.1.1 物理系统可以做的事情 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 581
12.1.2 物理好玩吗• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 582
12.1.3 物理对游戏的影响 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 583
12.2 碰撞/物理中间件• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 585
12.2.1 I-Collide、SWIFT、V-Collide 及RAPID • • • • • • • • • • • • • • • • • • • • 585
12.2.2 ODE • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 585
12.2.3 Bullet • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 586
12.2.4 TrueAxis • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 586
12.2.5 PhysX• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 586
12.2.6 Havok • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 587
12.2.7 PAL• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 587
12.2.8 DMM • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 587
12.3 碰撞检测系统• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 588
12.3.1 可碰撞的实体 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 588
12.3.2 碰撞/物理世界• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 589
12.3.3 关于形状的概念 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 590
12.3.4 碰撞原型• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 592
12.3.5 碰撞测试及解析几何 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 596
12.3.6 性能优化• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 604
12.3.7 碰撞查询• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 606
12.3.8 碰撞过滤• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 610
12.4 刚体动力学• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 611
12.4.1 基础• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 613
12.4.2 线性动力学• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 614
12.4.3 运动方程求解 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 616
12.4.4 数值积分• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 618
12.4.5 二维旋转动力学 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 622
12.4.6 三维旋转动力学 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 625
12.4.7 碰撞响应• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 629
12.4.8 约束• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 636
12.4.9 控制刚体的运动 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 640
12.4.10 碰撞/物理步 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 641
12.5 将物理引擎整合至游戏• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 643
12.5.1 连接游戏对象和刚体 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 643
12.5.2 更新模拟• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 646
12.5.3 游戏中碰撞及物理的应用例子• • • • • • • • • • • • • • • • • • • • • • • • • • 649
12.6 展望: 高级物理功能 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 656
第13 章 音频† • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 658
13.1 声音的物理• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 658
13.1.1 声波的属性• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 659
13.1.2 感知响度及分贝 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 660
13.1.3 声波的传播• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 663
13.1.4 位置的感知• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 668
13.2 声音中的数学知识• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 668
13.2.1 信号• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 669
13.2.2 处理信号• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 670
13.2.3 线性时不变系统 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 671
13.2.4 LTI 系统的脉冲响应 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 672
13.2.5 频域与傅里叶变换 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 677
13.3 声音技术• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 685
13.3.1 模拟音频技术 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 685
13.3.2 数字音频技术 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 690
13.4 三维音频渲染• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 696
13.4.1 三维声音渲染概览 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 697
13.4.2 为音频世界建模 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 698
13.4.3 基于距离的衰减 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 698
13.4.4 偏移• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 700
13.4.5 传播、混响及声学• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 705
13.4.6 多普勒频移• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 712
13.5 音频引擎架构• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 712
13.5.1 音频处理管道 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 714
13.5.2 概念及术语• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 714
13.5.3 音总线• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 715
13.5.4 主控混音器• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 718
13.5.5 主控输出总线 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 719
13.5.6 实现总线• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 720
13.5.7 资产管理• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 722
13.5.8 对游戏混音• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 724
13.5.9 音频引擎调查 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 727
13.6 游戏专用的音频功能• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 730
13.6.1 支持切割屏• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 731
13.6.2 角色对话• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 732
13.6.3 音乐• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 744
第IV 部分 游 戏 性
第14 章 游戏性系统简介• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 747
14.1 剖析游戏世界• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 748
14.1.1 世界元素• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 748
14.1.2 世界组块• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 750
14.1.3 高级游戏流程 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 751
14.2 实现动态元素: 游戏对象• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 752
14.2.1 游戏对象模型 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 753
14.2.2 工具方的设计和运行时的设计• • • • • • • • • • • • • • • • • • • • • • • • • • 754
14.3 数据驱动游戏引擎• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 754
14.4 游戏世界编辑器 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 755
14.4.1 游戏世界编辑器的典型功能• • • • • • • • • • • • • • • • • • • • • • • • • • • 758
4.4.2 集成的资产管理工具 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 763
第15 章 运行时游戏性基础系统• • • • • • • • • • • • • • • • • • • • • • • • • • • 766
15.1 游戏性基础系统的组件• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 766
15.2 各种运行时对象模型架构 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 768
15.2.1 以对象为中心的各种架构 • • • • • • • • • • • • • • • • • • • • • • • • • • • • 769
15.2.2 以属性为中心的各种架构 • • • • • • • • • • • • • • • • • • • • • • • • • • • • 781
15.3 世界组块的数据格式• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 785
15.3.1 二进制对象映像 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 786
15.3.2 序列化游戏对象描述 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 786
15.3.3 生成器及类型架构 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 788
15.4 游戏世界的加载和串流• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 792
15.4.1 简单的关卡加载 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 792
15.4.2 向无缝加载进发: 阻隔室 • • • • • • • • • • • • • • • • • • • • • • • • • • • • 792
5.4.3 游戏世界的串流 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 794
15.4.4 对象生成的内存管理 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 796
15.4.5 游戏存档• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 798
15.5 对象引用与世界查询• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 799
15.5.1 指针• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 799
15.5.2 智能指针• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 800
15.5.3 句柄• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 802
15.5.4 游戏对象查询 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 804
15.6 实时更新游戏对象• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 806
15.6.1 一个简单(但不可行) 的方式• • • • • • • • • • • • • • • • • • • • • • • • • • • 807
15.6.2 性能限制及批次式更新 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 809
15.6.3 对象及子系统的相互依赖 • • • • • • • • • • • • • • • • • • • • • • • • • • • • 811
15.6.4 为并行设计• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 819
15.7 事件与消息泵• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 821
15.7.1 静态类型的函数绑定带来的问题• • • • • • • • • • • • • • • • • • • • • • • • • 821
15.7.2 把事件封装成对象 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 822
15.7.3 事件类型• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 823
15.7.4 事件参数• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 824
15.7.5 事件处理器• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 826
15.7.6 取出事件参数 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 827
15.7.7 职责链• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 827
15.7.8 登记对事件的关注 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 829
15.7.9 要排队还是不要排队 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 830
15.7.10 即时传递事件带来的问题• • • • • • • • • • • • • • • • • • • • • • • • • • • • 835
15.7.11 数据驱动事件/消息传递系统• • • • • • • • • • • • • • • • • • • • • • • • • • 836
15.8 脚本• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 839
15.8.1 运行时与数据定义的对比 • • • • • • • • • • • • • • • • • • • • • • • • • • • • 839
15.8.2 编程语言特性 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 839
15.8.3 一些常见的游戏脚本语言 • • • • • • • • • • • • • • • • • • • • • • • • • • • • 841
15.8.4 脚本所需的架构 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 846
15.8.5 运行时游戏脚本语言的功能• • • • • • • • • • • • • • • • • • • • • • • • • • • 847
15.9 高层次的游戏流程• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 858
第V 部分 总 结
第16 章 还有更多内容吗• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 863
16.1 一些未谈及的引擎系统• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 863
16.1.1 影片播放器• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 863
16.1.2 多人网络• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 864
16.2 游戏性系统• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 864
16.2.1 玩家机制• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 864
16.2.2 摄像机• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 864
16.2.3 人工智能• • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 865
16.2.4 其他游戏性系统 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 866
参考文献 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 867
中文索引 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 871
英文索引 • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • • 900
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>游戏引擎架构（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>移动开发架构设计实战
第1章  什么是架构	1
1.1  架构设计理念	1
1.1.1  软件架构的起源	1
1.1.2  架构设计三要素	2
1.1.3  什么是优秀的软件架构设计	2
1.1.4  软件架构设计的关注点	3
1.2  软件架构设计的本质和目的	3
1.2.1  做出决策	3
1.2.2  降低软件熵	4
1.3  架构设计思维	4
1.3.1  简化思维	4
1.3.2  分层思维	5
1.3.3  分治思维	6
1.3.4  迭代思维	6
1.4  架构设计模式原则	7
1.4.1  单一职责原则	7
1.4.2  开放封闭原则	8
1.4.3  里氏替换原则	9
1.4.4  依赖倒置原则	9
1.4.5  接口分离原则	10
1.5  架构设计步骤	11
1.5.1  认识系统	11
1.5.2  设计系统	12
1.5.3  创建系统	14
1.5.4  收集反馈	14
1.6  小结	15
第2章  MVC架构：表现层分离	16
2.1  什么是MVC	16
2.1.1  MVC的诞生	16
2.1.2  MVC的分层与职责	17
2.1.3  MVC在移动开发中的争议	18
2.2  MVC的模式	19
2.2.1  被动模式	19
2.2.2  主动模式	19
2.2.3  观察者模式	20
2.2.4  被动模式与主动模式的区别	21
2.3  MVC的核心思想	21
2.4  小结	22
第3章  实战：基于MVC架构设计的日记App	23
3.1  层级职责划分	23
3.2  准备阶段	24
3.2.1  准备、创建View	24
3.2.2  清单文件Manifest配置	26
3.2.3  初始化Fragment	27
3.3  创建View	28
3.4  数据处理	31
3.4.1  创建Model	31
3.4.2  创建本地数据源	32
3.4.3  数据持久化工具	33
3.4.4  实现本地数据源	34
3.4.5  填充测试数据	36
3.4.6  使用数据仓库管理数据	37
3.5  创建Controller	40
3.5.1  Controller初始化	40
3.5.2  创建Adapter	41
3.5.3  创建ViewHolder	43
3.5.4  Controller的协调工作	44
3.6  运行App	48
3.7  实现主动模式的MVC	49
3.7.1  改造Model	49
3.7.2  注册观察者	50
3.8  小结	50
第4章  MVP架构：开始解耦	52
4.1  什么是MVP	52
4.1.1  MVP架构的起源	52
4.1.2  MVP的分层与职责	52
4.2  MVP的核心思想	53
4.2.1  面向接口编程	53
4.2.2  德墨忒尔定律	54
4.3  MVP与MVC的区别	55
4.4  MVP模式存在的问题	56
4.4.1  责任过重的Presenter	56
4.4.2  业务逻辑无法复用	56
4.4.3  急剧扩增的接口数量	57
4.5  如何解决Presenter的复用问题	57
4.5.1  提供工具类	57
4.5.2  提供多对一的Presenter	57
4.5.3  分离出Interactor层	58
4.6  小结	59
第5章  实战：MVP架构设计	60
5.1  层级职责划分	60
5.2  准备工作	60
5.2.1  定义基础View接口	60
5.2.2  定义基础Presenter接口	61
5.3  重构：从MVC到MVP	61
5.3.1  创建Presenter	61
5.3.2  改造View	62
5.3.3  传入Presenter实例	63
5.3.4  开发过程中Presenter和View的直接依赖	63
5.3.5  Presenter生命周期的处理	64
5.3.6  列表Adapter的处理	64
5.3.7  展示数据的处理	65
5.3.8  对话框展示的处理	67
5.3.9  菜单的处理	68
5.3.10  实现面向接口设计	69
5.3.11  建立契约类	69
5.4  实现MVP模式：日记修改功能	70
5.4.1  创建日记修改Activity	71
5.4.2  创建日记修改Fragment	72
5.4.3  添加“完成”按钮	74
5.4.4  创建日记修改Presenter	75
5.4.5  日记操作处理	76
5.4.6  页面跳转处理	77
5.4.7  删除旧有的修改日记UI	78
5.4.8  修改为面向接口设计	79
5.5  小结	79
第6章  MVVM架构：双向绑定	81
6.1  什么是MVVM	81
6.1.1  MVVM架构的起源	81
6.1.2  MVVM的分层与职责	82
6.2  MVVM的核心思想	82
6.2.1  进一步解耦	82
6.2.2  数据驱动	83
6.2.3  双向绑定	83
6.3  架构模式对比	84
6.3.1  MVC与MVVM	84
6.3.2  MVP与MVVM	85
6.4  MVVM存在的问题	86
6.4.1  ViewModel难以复用	86
6.4.2  学习成本高	86
6.4.3  调试困难	86
6.5  小结	87
第7章  实战：MVVM架构设计	88
7.1  什么是DataBinding	88
7.2  重构：从MVP到MVVM	88
7.2.1  配置DataBinding支持	89
7.2.2  修改Presenter为ViewModel	89
7.2.3  消除契约类	90
7.2.4  转换布局文件	92
7.2.5  在布局中加入变量和表达式	93
7.2.6  ViewModel继承BaseObservable	94
7.2.7  在XML布局文件中定义列表数据属性	95
7.2.8  使用BindingAdapter处理自定义属性	97
7.2.9  绘制View布局	98
7.2.10  为View属性赋值	99
7.2.11  找到XML中的View	100
7.2.12  ObservableField原理	100
7.2.13  使用ObservableField	101
7.2.14  使用ObservableList	103
7.3  小结	104
第8章  依赖注入：Dagger2锋利的“匕首”	105
8.1  什么是Dagger	105
8.1.1  依赖注入	105
8.1.2  编译时注解解析	107
8.2  实现：将Dagger2加入MVP	108
8.2.1  配置Dagger2	108
8.2.2  确定数据仓库改造目标	108
8.2.3  改造数据仓库	109
8.2.4  Inject注解	110
8.2.5  Component注解	111
8.2.6  Module注解	114
8.2.7  Provides注解	115
8.2.8  Scope注解	117
8.2.9  Singleton注解	117
8.2.10  Scope注解和Singleton注解的实现原理	118
8.2.11  日记列表模块依赖关系分析	120
8.2.12  创建日记列表模块Component	120
8.2.13  创建日记列表Presenter Module	121
8.2.14  Component的dependencies属性	123
8.3  存在的问题	125
8.3.1  学习成本极高	125
8.3.2  短期内开发效率低	125
8.3.3  灵活性不良好	126
8.4  小结	126
第9章  函数响应式框架：优雅的RxJava2	127
9.1  什么是RxJava	127
9.2  RxJava2的核心思想	128
9.2.1  函数响应式编程	128
9.2.2  背压	129
9.2.3  链式调用	129
9.3  实战：将RxJava2加入MVP	130
9.3.1  配置RxJava2	130
9.3.2  Flowable	131
9.3.3  响应式拉取	132
9.3.4  修改数据源接口	133
9.3.5  修改本地数据源	133
9.3.6  Just操作符	134
9.3.7  Empty操作符	135
9.3.8  FromIterable操作符	135
9.3.9  To操作符	136
9.3.10  Subscriber和事件流	137
9.3.11  修改数据仓库	137
9.3.12  FlatMap操作符	139
9.3.13  Map操作符	140
9.3.14  修改Presenter	141
9.3.15  CompositeDisposable和Disposable	142
9.3.16  Presenter生命周期	143
9.4  存在的问题	144
9.5  小结	144
第10章  AAC：搭建生命周期感知架构	145
10.1  什么是AAC	145
10.2  AAC的核心思想	146
10.2.1  关注点分离	146
10.2.2  模型驱动界面	147
10.3  ViewModel+LiveData	148
10.3.1  DataBinding	148
10.3.2  Gradle依赖配置	149
10.3.3  AAC中的ViewModel	149
10.3.4  使用ViewModel	150
10.3.5  使用ViewModelProviders创建ViewModel	151
10.3.6  什么是LiveData	152
10.3.7  MutableLiveData	153
10.3.8  创建LiveData	154
10.3.9  LiveData更新	155
10.3.10  LiveData接收变化	156
10.4  LifeCycle	156
10.4.1  生命周期	157
10.4.2  LifecycleObserver	158
10.4.3  LifecycleOwner	159
10.5  Room	160
10.5.1  Room的组成	160
10.5.2  实体	161
10.5.3  数据访问对象DAO	163
10.5.4  Room依赖配置	164
10.5.5  定义实体	164
10.5.6  创建Dao	165
10.5.7  创建数据库管理器	166
10.5.8  线程处理	168
10.5.9  修改本地数据源	169
10.5.10  数据库升级	172
10.6  小结	173
第11章  组件化架构：极速运行	174
11.1  什么是组件化	174
11.2  组件化的核心思想	175
11.2.1  软件复用	175
11.2.2  信息隐藏	176
11.2.3  快速运行	177
11.3  组件分离	178
11.3.1  组件层级划分	178
11.3.2  组件划分	179
11.3.3  创建Module	180
11.3.4  组件依赖关系	183
11.3.5  复用Gradle配置	187
11.3.6  公共资源组件	189
11.3.7  基础组件	191
11.3.8  移动依赖	194
11.3.9  Gradle版本号管理	194
11.3.10  处理Context	197
11.3.11  公共组件	198
11.3.12  日记列表展示组件	200
11.3.13  日记添加修改组件	202
11.3.14  Gradle Plugin冲突	204
11.3.15  运行主Module	204
11.4  使用路由	206
11.4.1  路由配置	206
11.4.2  使用Route跳转	207
11.4.3  携带参数跳转	208
11.5  组件运行	210
11.5.1  切换开关	210
11.5.2  组件配置	212
11.5.3  Manifest文件配置	212
11.5.4  集成运行	215
11.6  组件合并	216
11.6.1  组件命名冲突	216
11.6.2  Manifest文件合并策略	217
11.6.3  资源文件冲突	218
11.6.4  资源文件合并策略	219
11.7  小结	  220
第12章  The Clean Architecture：整洁的架构	221
12.1  什么是The Clean Architecture	221
12.2  The Clean Architecture的核心思想	222
12.2.1  单向依赖规则	222
12.2.2  业务规则分离	223
12.2.3  简单数据结构跨界	224
12.3  MVP-Clean架构	224
12.3.1  用例的请求数据和响应数据	224
12.3.2  用例的数据处理	226
12.3.3  用例的线程切换	228
12.3.4  创建用例	229
12.3.5  执行用例	230
12.3.6  封装请求数据	231
12.3.7  创建日记更新用例	234
12.3.8  重构日记修改Presenter	235
12.4  VIPER架构	238
12.4.1  什么是VIPER架构	238
12.4.2  VIPER架构的层级划分	239
12.4.3  创建Interactor	240
12.4.4  在协议中加入Interactor	241
12.4.5  使用Interactor	242
12.4.6  创建Router	242
12.4.7  在协议中加入Router	244
12.4.8  使用Router	244
12.5  Riblets架构	245
12.5.1  什么是Riblets架构	245
12.5.2  Riblets架构的组件	246
12.6  小结	247
第13  Fragmentless：Fragment反对者	248
13.1  什么是Fragmentless	248
13.2  Fragmentless实战	249
13.2.1  创建View	249
13.2.2  View附加状态判断	252
13.2.3  修改布局文件	253
13.2.4  修改Activity	254
13.3  小结	255
第14章  Conductor：短兵利刃	257
14.1  什么是Conductor	257
14.2  Conductor实战	258
14.2.1  配置Conductor	259
14.2.2  Controller基类处理	259
14.2.3  重构Fragment	260
14.2.4  Controller的上下文	261
14.2.5  Controller活跃态	262
14.2.6  使用路由	262
14.2.7  日记修改页面处理	263
14.2.8  Controller构造方法	265
14.2.9  页面销毁	266
14.2.10  页面跳转	266
14.3  小结	267
第15章  插件化：模块插拔	268
15.1  什么是插件化	268
15.2  插件化实战	269
15.2.1  配置插件化框架	269
15.2.2  配置主模块	270
15.2.3  验证环境配置	270
15.2.4  框架初始化	271
15.2.5  指定插件类型	272
15.2.6  配置路由信息	272
15.2.7  创建加载页面	275
15.2.8  路由携带参数跳转	276
15.2.9  配置插件的Launcher	276
15.2.10  编译	277
15.3  小结	278
第16章  总结	279
16.1  架构演进	279
16.1.1  MVX系列架构	279
16.1.2  The Clean Architecture系列架构	280
16.1.3  模块化系列架构	281
16.2  选择合适的架构	282
16.2.1  认清你的团队规模	282
16.2.2  目前存在的问题	283
16.2.3  大型技术团队架构选型	283
16.2.4  中小型技术团队架构选型	284
16.2.5  独立开发者架构选型	285
16.3  复盘	285
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>移动开发架构设计实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务：灵活的软件架构
第一部分　动机和基础知识
第1章　预备知识　　2
1.1　微服务概述　　2
1.2　为什么采用微服务　　3
1.3　挑战　　5
1.4　总结　　6
第2章　微服务应用案例　　7
2.1　遗留电商应用的技术更新　　7
2.2　开发一个新的信号系统　　13
2.3　总结　　15
第二部分　微服务是什么，用还是不用
第3章　什么是微服务　　18
3.1　微服务的大小　　18
3.2　康威定律　　24
3.3　领域驱动设计与限界上下文　　27
3.4　为什么要远离标准数据模型　　32
3.5　微服务要不要包含UI　　34
3.6　总结　　35
第4章　采用微服务的原因　　37
4.1　技术优势　　37
4.2　组织上的优势　　42
4.3　业务方面的优势　　44
4.4　总结　　45
第5章　挑战　　47
5.1　技术挑战　　47
5.2　架构　　50
5.3　基础设施与运维　　52
5.4　总结　　53
第6章　微服务与SOA　　55
6.1　什么是SOA　　55
6.2　SOA与微服务的区别　　59
6.3　总结　　62
第三部分　微服务的实现
第7章　微服务系统架构　　68
7.1　领域架构　　68
7.2　架构管理　　71
7.3　调整架构的技术　　75
7.4　增长的微服务系统　　81
7.5　别错过出口：如何避免微服务的退化　　84
7.6　微服务与遗留应用　　86
7.7　潜在的依赖　　91
7.8　事件驱动架构　　92
7.9　技术架构　　93
7.10　配置与协调　　95
7.11　服务发现　　97
7.12　负载均衡　　99
7.13　可伸缩性　　102
7.14　安全性　　104
7.15　文档与元数据　　109
7.16　总结　　110
第8章　集成与通信　　112
8.1　Web与UI　　112
8.2　REST　　121
8.3　SOAP与RPC　　123
8.4　消息　　124
8.5　数据复制　　126
8.6　内部接口与外部接口　　128
8.7　总结　　130
第9章　单个微服务架构　　133
9.1　领域架构　　133
9.2　CQRS　　134
9.3　事件溯源　　136
9.4　六边形架构　　138
9.5　容错性和稳定性　　141
9.6　技术架构　　144
9.7　总结　　146
第10章　微服务与微服务系统的测试　　148
10.1　为什么需要测试　　148
10.2　如何测试　　149
10.3　降低部署的风险　　153
10.4　系统整体的测试　　154
10.5　遗留应用与微服务的测试　　157
10.6　各个微服务的测试　　159
10.7　消费者驱动的契约测试　　160
10.8　技术标准的测试　　163
10.9　总结　　164
第11章　微服务的运维及持续交付　　165
11.1　微服务运维的挑战　　165
11.2　日志　　167
11.3　监控　　171
11.4　部署　　176
11.5　联合部署还是独立部署　　179
11.6　控制　　180
11.7　基础设施　　180
11.8　总结　　184
第12章　微服务架构的组织效应　　186
12.1　微服务的组织效益　　186
12.2　康威定律的替代方案　　189
12.3　微观架构与宏观架构　　191
12.4　技术领导力　　196
12.5　DevOps　　197
12.6　当微服务遇上传统的IT组织　　198
12.7　与客户的接洽　　201
12.8　可复用代码　　202
12.9　能否采用微服务而不改变组织　　204
12.10　总结　　206
第四部分　技术
第13章　微服务架构示例　　210
13.1　领域架构　　210
13.2　基本技术　　212
13.3　构建　　216
13.4　使用Docker进行部署　　217
13.5　Vagrant　　218
13.6　Docker Machine　　222
13.7　Docker Compose　　223
13.8　服务发现　　226
13.9　通信　　228
13.10　容错性　　230
13.11　负载均衡　　234
13.12　集成其他技术　　235
13.13　测试　　236
13.14　基于JVM的微服务在Amazon Cloud中运行的实践　　237
13.15　总结　　239
第14章　纳米服务技术　　241
14.1　为什么采用纳米服务　　241
14.2　纳米服务：定义　　243
14.3　Amazon Lambda　　244
14.4　OSGi　　245
14.5　Java EE　　248
14.6　Vert.x　　251
14.7　Erlang　　252
14.8　Seneca　　255
14.9　总结　　257
第15章　把微服务用起来　　259
15.1　为什么选择微服务　　259
15.2　微服务实践之路　　260
15.3　微服务：能否落地　　260
15.4　总结　　261
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务：灵活的软件架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MySQL DBA工作笔记：数据库管理、架构优化与运维开发
第1 章 MySQL 发展和技术选型
1.1 如何看待MySQL..............................................................................................................1
1.1.1 MySQL 始出...........................................................................................................1
1.1.2 MySQL 学习周期和难度........................................................................................1
1.1.3 解读DB-Engines 的正确姿势................................................................................2
1.1.4 MySQL 主要的一些分支........................................................................................3
1.1.5 如何看待MySQL 的技术发展...............................................................................3
1.2 如何看待MySQL 存储引擎..............................................................................................5
1.2.1 InnoDB 发展时间线...............................................................................................6
1.2.2 存储引擎之战.........................................................................................................7
1.2.3 存储引擎矩阵图.....................................................................................................7
1.3 MySQL 软件和版本选型...................................................................................................8
1.3.1 选择官方版的原因.................................................................................................9
1.3.2 Percona 分支的优劣对比........................................................................................9
1.3.3 选择MariaDB 的原因..........................................................................................10
1.3.4 MySQL 版本选型.................................................................................................10
1.3.5 分支选择的参考和标准........................................................................................11
1.3.6 初步结论...............................................................................................................13
1.4 MySQL 常用工具选择和建议.........................................................................................13
1.4.1 运维管理类工具...................................................................................................14
1. 主流运维管理工具...........................................................................................14
2. 数据备份恢复工具...........................................................................................14
3. MySQL 审计插件............................................................................................15
1.4.2 应用工具...............................................................................................................15
1. 客户端工具......................................................................................................15
2. 数据库版本管理工具.......................................................................................15
1.4.3 监控管理类工具...................................................................................................16
1. 操作系统监控..................................................................................................16
2. 性能监控工具..................................................................................................16
1.4.4 诊断和优化工具...................................................................................................16
1. 诊断工具..........................................................................................................16
2. 性能测试工具..................................................................................................18
3. 慢日志分析工具..............................................................................................18
1.4.5 初步结论...............................................................................................................18
1.5 MySQL 安装....................................................................................................................19
1.5.1 常见的三种安装方式............................................................................................19
1.5.2 MySQL 安装规范.................................................................................................20
1.5.3 MySQL 5.7 安装部署实践与总结........................................................................20
1.5.4 搭建从库...............................................................................................................23
案例1-1：MySQL 频繁停库的问题分析........................................................................25
第2 章理解MySQL 体系结构
2.1 通过文件来了解MySQL 体系结构.................................................................................29
2.1.1 从例子来理解MySQL 存储结构.........................................................................32
2.1.2 慢日志诊断...........................................................................................................32
案例2-1：MySQL 日志故障的处理和分析....................................................................35
2.2 玩转MySQL 数据字典....................................................................................................38
2.2.1 MySQL 巡检模块：Sys Schema 的设计..............................................................39
2.2.2 解惑：MySQL 关于数据字典的一个疑问...........................................................47
2.3 InnoDB 体系结构............................................................................................................50
2.3.1 InnoDB 体系结构图.............................................................................................51
2.3.2 查看InnoDB 状态的小技巧.................................................................................52
2.3.3 InnoDB 的多线程技术..........................................................................................53
2.3.4 InnoDB 的缓存池管理技术..................................................................................55
2.3.5 InnoDB 中的脏页管理..........................................................................................58
2.3.6 InnoDB 的日志管理.............................................................................................60
2.3.7 InnoDB 中的检查机制..........................................................................................62
2.3.8 MySQL 是如何保证数据完整性的......................................................................63
2.4 换个角度看MySQL.........................................................................................................66
2.4.1 MySQL 里的一些极限值......................................................................................66
案例2-2：关于MySQL 中的一些极限值的初步验证纠错............................................. 67
2.4.2 mysql. service 启动脚本浅析................................................................................68
2.4.3 MySQL 待改进的一些问题..................................................................................71
2.5 MySQL 参数解析............................................................................................................72
2.5.1 MySQL 参数变化分析..........................................................................................73
2.5.2 MySQL 5.7 参数解析............................................................................................74
第3 章 MySQL 基础运维面面观
3.1 环境部署和构建..............................................................................................................76
3.1.1 源码安装MySQL.................................................................................................76
3.1.2 在eclipse 中配置MySQL 源码环境....................................................................80
3.1.3 分分钟搭建MySQL 一主多从环境......................................................................87
3.2 MySQL 服务管理............................................................................................................88
3.2.1 Socket 连接...........................................................................................................88
3.2.2 TCP/IP 连接..........................................................................................................89
3.2.3 MySQL 访问模式的演进......................................................................................89
3.2.4 无密码登录...........................................................................................................90
案例3-1：通过shell 脚本检测MySQL 服务信息.......................................................... 91
案例3-2：MySQL 密码加密认证的简单脚本................................................................. 93
案例3-3：MySQL 中如何得到权限信息........................................................................94
方法1：重新导出导入整个数据库......................................................................94
方法2：导出mysql 的权限配置..........................................................................94
方法3：pt 工具导出............................................................................................95
3.3 MySQL 备份恢复............................................................................................................97
3.3.1 数据安全警示录...................................................................................................97
3.3.2 常规备份方案.......................................................................................................98
备份工具1：mysqldump......................................................................................99
备份工具2：xtrabackup 工具............................................................................101
备份工具3：mysqlpump ....................................................................................102
备份工具4：mysqlbackup..................................................................................104
备份工具5：binlog 备份工具............................................................................105
数据导出小技巧.................................................................................................105
数据导入小技巧.................................................................................................106
3.3.3 MySQL 数据恢复...............................................................................................106
恢复方法1：使用xtrabackup 进行数据全量恢复............................................. 107
恢复方法2：使用xtrabackup 进行数据增量恢复............................................. 109
恢复方法3：使用mysqlbinlog 手工恢复.......................................................... 112
恢复方法4：使用开源工具恢复数据 binlog2sql.............................................. 115
恢复方法5：使用参数innodb_force_recovery.................................................. 117
恢复方法6：基于逻辑的数据恢复....................................................................117
恢复方法7：基于冷热数据分离的恢复思路.................................................... 118
恢复方法8：基于句柄的无备份恢复................................................................ 119
恢复方法9：直接恢复物理文件........................................................................121
3.4 MySQL 安全审计..........................................................................................................122
3.4.1 常用方法.............................................................................................................122
3.4.2 性能测试结果.....................................................................................................123
3.4.3 测试小结.............................................................................................................123
第4 章 SQL 开发规范和基础
4.1 数据库开发规范............................................................................................................124
4.1.1 配置规范.............................................................................................................124
4.1.2 建表规范.............................................................................................................125
iv MySQL DBA 工作笔记：数据库管理、架构优化与运维开发
4.1.3 命名规范.............................................................................................................125
4.1.4 索引规范.............................................................................................................125
4.1.5 应用规范.............................................................................................................126
4.1.6 分表规范.............................................................................................................127
4.1.7 存储过程规范.....................................................................................................127
4.1.8 安全规范.............................................................................................................127
4.1.9 数据安全规范.....................................................................................................128
案例4-1：MySQL 无法创建表的问题分析..................................................................131
4.2 解读MySQL 数据类型..................................................................................................135
4.2.1 MySQL 整数类型...............................................................................................135
案例4-2：数值类型在binlog 中需要注意的细节......................................................... 136
4.2.2 MySQL 小数类型...............................................................................................138
4.2.3 MySQL 字符串类型...........................................................................................139
案例4-3：MySQL 中需要注意的字段长度..................................................................140
4.2.4 MySQL 日期类型...............................................................................................142
案例4-4：MySQL 多版本的时间类型问题..................................................................143
4.2.5 JSON 类型..........................................................................................................144
4.3 MySQL 特有的SQL......................................................................................................146
4.3.1 新增类................................................................................................................146
4.3.2 删除类................................................................................................................147
4.3.3 修改类................................................................................................................148
专题4-1：解读Replace into 语句.................................................................................148
4.3.4 查询类................................................................................................................153
4.4 MySQL 常用函数..........................................................................................................153
4.4.1 数学函数.............................................................................................................154
案例4-5：MySQL 字符串中抽取数值的方法............................................................... 155
案例4-6：order by 的妙用.............................................................................................156
4.4.2 字符串函数.........................................................................................................157
案例4-7：MySQL 字符函数的压力测试......................................................................160
案例4-8：字符串动态匹配...........................................................................................162
4.4.3 条件控制函数.....................................................................................................162
4.4.4 日期和时间函数.................................................................................................163
案例4-9：Now()和sysdate()的差别..............................................................................166
4.4.5 系统信息函数.....................................................................................................169
4.4.6 其他常用的MySQL 函数...................................................................................169
第5 章 MySQL 运维管理实践
5.1 数据变更管理................................................................................................................171
5.1.1 MySQL 脚本部署的四种策略............................................................................171
案例5-1：实战对比四种脚本部署策略的优劣............................................................. 172
5.1.2 通过对比来了解onlineDDL..............................................................................175
案例5-2：MySQL 5.5 版本原生的DDL 代价测试....................................................... 176
案例5-3：MySQL 5.7 版本原生的DDL 代价测试....................................................... 176
5.1.3 Online DDL 的两种算法.....................................................................................177
案例5-4：对比测试online DDL 的两种算法（copy 和inplace） ............................... 177
5.1.4 pt-osc 的原理和实现...........................................................................................181
案例5-5：源码分析pt-osc 的实现原理........................................................................181
案例5-6：平滑删除数据的小技巧................................................................................184
5.2 MySQL 复制管理..........................................................................................................186
5.2.1 MySQL 复制的四种类型....................................................................................186
5.2.2 MySQL 半同步复制...........................................................................................187
案例5-7：简单测试半同步复制....................................................................................190
5.2.3 GTID 的管理模式...............................................................................................191
案例5-8：修复GTID 复制失败的分析.........................................................................195
5.2.4 如何看待主从延迟.............................................................................................200
案例5-9：MySQL 5.6、5.7 版本并行复制测试............................................................ 203
5.2.5 主从数据不一致的分析......................................................................................209
案例5-10：经典的自增列问题测试..............................................................................210
案例5-11：主从不一致的修复过程..............................................................................212
第6 章MySQL 查询优化
6.1 MySQL 优化基础..........................................................................................................215
6.1.1 MySQL 索引解析...............................................................................................216
6.1.2 推理SQL 的解析过程........................................................................................221
案例6-1：group by 问题浅析........................................................................................224
6.1.3 读懂执行计划.....................................................................................................227
6.1.4 使用MySQL Profile 定位性能瓶颈....................................................................234
案例6-2：合理评估新特性的使用................................................................................238
6.2 SQL 查询优化................................................................................................................240
6.2.1 MySQL 中的派生表...........................................................................................240
6.2.2 MySQL 中的半连接...........................................................................................243
6.2.3 MySQL 反连接...................................................................................................247
6.2.4 行值表达式优化.................................................................................................250
6.3 MySQL 优化技巧..........................................................................................................251
6.3.1 MySQL 分页逻辑优化.......................................................................................251
6.3.2 数据隐式转换.....................................................................................................254
案例6-3：一条update 语句引发的“血案”................................................................ 256
第7 章 MySQL 事务和锁
7.1 MySQL 并发控制..........................................................................................................263
7.1.1 为什么需要事务.................................................................................................263
7.1.2 MySQL 并发控制技术方案................................................................................265
7.1.3 MySQL 中的MVCC...........................................................................................266
7.2 事务隔离级别................................................................................................................269
7.2.1 MySQL 中的隔离级别RR 和RC.......................................................................270
7.2.2 RR 隔离级别下的unique 失效...........................................................................272
7.2.3 RR 隔离级别下的更新冲突................................................................................274
7.3 MySQL 锁机制..............................................................................................................275
7.3.1 MySQL 锁的类型...............................................................................................275
7.3.2 索引加锁过程的差异..........................................................................................278
7.3.3 这样分析一个死锁问题......................................................................................280
7.4 经典的死锁案例集........................................................................................................283
场景1：3 条insert 语句导致的死锁问题......................................................................283
场景2：事务回滚导致的死锁.......................................................................................285
场景3：自增列导致的死锁...........................................................................................287
场景4：事务提交导致的死锁问题...............................................................................288
场景5：delete 和insert 混合的死锁..............................................................................291
场景6：2 条delete 语句导致的死锁问题.....................................................................293
7.5 事务降维........................................................................................................................294
降维策略1：存储过程调用转换为透明的SQL 调用................................................... 295
降维策略2：Drop 操作转换为可逆的DDL 操作......................................................... 295
降维策略3：Truncate 操作转换为安全的DDL 操作................................................... 295
降维策略4：DDL 操作转换为DML 操作....................................................................296
降维策略5：Delete 操作转换为高效操作....................................................................296
降维策略6：Update 操作转换为Insert 操作................................................................ 296
第8 章 MySQL 集群和高可用设计
8.1 MySQL 高可用方案.......................................................................................................297
8.1.1 MySQL 高可用方案概览....................................................................................298
8.1.2 MySQL 高可用方案的建议................................................................................298
8.1.3 MySQL 高可用的迭代方案思考........................................................................299
8.2 MySQL 高可用方案之MHA.........................................................................................300
8.2.1 MHA 原理和架构...............................................................................................300
8.2.2 如何系统的测试MHA.......................................................................................303
8.2.3 快速测试MHA 的步骤......................................................................................304
8.2.4 从代码关系图理清MHA 的脉络.......................................................................308
8.2.5 我们可能不知道的MHA 逻辑...........................................................................312
8.2.6 MHA 的缺点和局限性.......................................................................................313
8.2.7 MHA 的补充和改进...........................................................................................314
8.3 MySQL 高可用方案之InnoDB Cluster......................................................................... 315
8.3.1 InnoDB Cluster 三大件.......................................................................................316
8.3.2 快速入手InnoDB Cluster 的建议.......................................................................317
8.3.3 使用sandbox 快速部署InnoDBCluster............................................................. 318
8.3.4 InnoDb Cluster 核心组件：MGR....................................................................... 323
8.3.5 部署MGR 的几种姿势.......................................................................................324
方法1：分分钟搭建MGR 单主/多主测试环境................................................ 324
方法2：线上环境规范部署...............................................................................325
8.3.6 常见的MGR 问题..............................................................................................327
问题1：单主模式加入节点失败........................................................................328
问题2：模式配置错误导致无法启动集群........................................................ 328
问题3：节点配置不统一导致集群无法启动.................................................... 328
问题4：数据写入失败修复...............................................................................329
问题5：模拟灾难..............................................................................................329
问题6：如何判断一个复制组中的主节点........................................................ 330
8.3.7 迁移到MGR 需要思考的问题...........................................................................331
案例8-1：切换到MGR 的参考步骤.................................................................332
案例8-2：大事务导致的运维系统无法访问..................................................... 336
8.4 基于consul 的高可用扩展方案.....................................................................................339
8.4.1 基于consul 服务的高可用方案..........................................................................339
8.4.2 基于MHA Consul 的MySQL 高可用设计.......................................................340
8.4.3 MySQL 高可用方案：MGR consul 组合测试...................................................341
第9 章 MySQL 性能测试
9.1 sysbench 压测MySQL...................................................................................................344
9.1.1 压测MySQL——环境部署和硬件压测.............................................................344
9.1.2 压测MySQL 起步..............................................................................................348
9.1.3 压测MySQL——提高吞吐量测试.....................................................................351
9.1.4 压测MySQL——定位压测瓶颈........................................................................356
9.1.5 定制sysbench 的Lua 模板.................................................................................360
9.2 批量初始化数据性能测试.............................................................................................363
9.2.1 批量初始化数据初步想法..................................................................................363
9.2.2 批量初始化数据的方案......................................................................................363
方案1：存储过程导入.......................................................................................363
方案2：使用内存表...........................................................................................364
方案3：使用程序/脚本生成数据，批量导入................................................... 365
方案4：使用内存表和外部文件导入混合........................................................ 365
viii MySQL DBA 工作笔记：数据库管理、架构优化与运维开发
方案5：存储过程显式事务提交........................................................................365
方案6：批量生成insert 语句使用管道导入..................................................... 366
方案7：批量生成insert 语句显式事务提交..................................................... 366
方案8：sysbench 工具生成...............................................................................366
方案9：Oracle 的极简方案...............................................................................367
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MySQL DBA工作笔记：数据库管理、架构优化与运维开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Serverless架构：从原理、设计到项目实战
第1章　初识Serverless	1
1.1　什么是Serverless	2
1.2　优势与劣势	6
1.3　影响力和价值	11
1.4　技术难点与挑战	14
1.5　典型应用场景	18
1.5.1　视频转码服务	18
1.5.2　数据ETL处理服务	19
1.5.3　网站（服务）后端	20
1.5.4　人工智能推理预测	20
1.5.5　物联网相关应用	21
1.6　发展与展望	21
第2章　Serverless入门	24
2.1　Serverless基础	25
2.2　Serverless架构规范	28
2.2.1　处理模型	28
2.2.2　函数相关规范	29
2.2.3　函数生命周期	32
2.2.4　工作流程	37
2.3　事件与规范	39
2.3.1　相关术语	39
2.3.2　上下文属性	40
2.4　开源项目与技术	44
2.4.1　OpenWhisk项目	44
2.4.2　Fission项目	54
2.4.3　Kubeless项目	70
2.5　工业化产品	78
2.5.1  AWS Lambda	78
2.5.2  Google Cloud Function	80
2.5.3  Azure Functions	80
2.5.4  腾讯云SCF	82
2.6　开发运维工具	83
2.6.1  CLI命令行工具	83
2.6.2  插件	91
第3章　Web与监控告警场景实践	94
3.1　运维、监控与告警	95
3.1.1　网站状态监控告警	95
3.1.2  服务状态监控告警	107
3.2  Web后端与应用服务端	114
3.2.1  上传图片加水印	114
3.2.2  用IP地址查天气并在小程序中应用	122
3.2.3  简易用户反馈功能与快应用实践	136
第4章　大数据与人工智能场景实践	147
4.1　大数据技术之MapReduce的简单实现	148
4.2  人工智能领域的实践	158
4.2.1  自然语言处理为你的网站赋能	158
4.2.2  智能客服与微信小程序	163
4.2.3  简单的车牌识别系统	174
4.2.4  视觉：对象检测系统	178
第5章　物联网和其他场景实践	190
5.1  物联网相关—定制智能音箱小工具	191
5.2  其他场景实践	197
5.2.1  OJ判题机/小程序在线编程系统实现	197
5.2.2　Serverless与高可用服务—使用云函数实现双机存储	202
5.2.3　Serverless与高可用服务—基于Serverless架构的高可用模型	206
5.2.4　微信公众号机器人	215
第6章　实战：Serverless与CMS	224
6.1　项目背景	225
6.2　项目设计	225
6.2.1　功能设计	225
6.2.2　数据库设计	229
6.2.3　接口设计	231
6.3　数据库开发	239
6.4　后端开发	241
6.5　前端开发	253
6.6　功能演示	257
6.7　项目总结	260
第7章　实战：小程序图片管理系统	261
7.1　项目背景	262
7.2　项目设计	262
7.2.1　功能设计	262
7.2.2　数据库设计	266
7.2.3　接口设计	268
7.3　数据库开发	275
7.4　后端开发	277
7.5　前端开发	298
7.6　效果展示	301
7.7　项目总结	304
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Serverless架构：从原理、设计到项目实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大型互联网企业安全架构
第一部分   安全理论体系
第1章  安全理念  2
1.1  安全组织与标准  2
1.2  企业安全风险综述  6
1.2.1  业务与运维安全  7
1.2.2  企业内部安全  8
1.2.3  法律法规与隐私保护  10
1.2.4  供应链安全  11
1.3  业界理念最佳实践  12
第2章  国际著名安全架构理论  16
2.1  P2DR模型  16
2.2  IPDRR模型  17
2.3  IATF  19
2.4  CGS框架  20
2.5  自适应安全架构  21
2.6  IACD  22
2.7  网络韧性架构  23
2.8  总结  26
第3章  大型安全体系建设指南  27
3.1  快速治理阶段  27
3.1.1  选择合适的安全负责人  27
3.1.2  识别主要的安全风险  29
3.1.3  实施快速消减策略  34
3.2  系统化建设阶段  36
3.2.1  依据ISMS建立安全管理体系  36
3.2.2  基于BSIMM构建安全工程的能力  38
3.2.3  参考Google云平台设计安全技术体系  42
3.3  全面完善与业界协同阶段  50
3.3.1  强化安全文化建设  51
3.3.2  完善安全韧性架构  51
3.3.3  建立协同安全生态  52
第二部分  基础安全运营平台
第4章  威胁情报  54
4.1  公共情报库  55
4.2  漏洞预警  57
4.3  信息泄露  59
第5章  漏洞检测  60
5.1  网络漏洞  60
5.2  主机漏洞  62
5.3  网站漏洞  64
第6章  入侵感知  73
6.1  网络流量分析（NTA）  73
6.2  主机入侵检测（HIDS）  75
6.3  欺骗（Deception）技术  111
第7章  主动防御  122
7.1  主机入侵防御（HIPS）  122
7.2  Web应用防火墙（WAF）  136
7.3  运行时应用自保护（RASP）  171
7.4  数据库防火墙（DBF）  185
第8章  后门查杀（AV）  187
8.1  Rootkit  187
8.2  主机后门  193
8.3  Webshell  197
第9章  安全基线  204
第10章  安全大脑  207
10.1  安全态势感知  208
10.2  安全信息和事件管理  208
10.3  安全编排与自动化响应  212
第三部分   综合安全技术
第11章  安全开发生命周期  215
11.1  计划阶段  215
11.2  编码阶段  218
11.3  测试阶段  219
11.3.1  自动化安全测试  219
11.3.2  人工安全测试  222
11.4  部署阶段  224
第12章  企业办公安全  226
12.1  人员管理  226
12.2  终端设备  227
12.3  办公服务  227
12.4  实体场地  230
第13章  互联网业务安全  231
13.1  业务风控  231
13.2  数据安全与隐私  234
第14章  全栈云安全  239
14.1  可信计算  239
14.2  内核热补丁（KLP）  244
14.3  虚拟化安全（VMS）  247
14.4  容器安全（CS）  250
14.5  安全沙盒（Sandbox）  252
第15章  前沿安全技术  257
15.1  AI与安全  257
15.1.1  AI技术在安全领域中的应用  260
15.1.2  AI技术自身的安全性  261
15.2  其他技术  262
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大型互联网企业安全架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>前端技术架构与工程
第1章  前端工程化	1
1.1  前端的时代意义	2
1.2  架构与工程	9
1.3  零散的前端架构	12
1.4  模糊的前端工程边界	14
1.5  前端架构师的职责	16
1.5.1  技术架构	16
1.5.2  工程服务体系	20
1.6  总结	23
第2章  编程语言	24
2.1  HTML	25
2.1.1  SSR	26
2.1.2  CSR	28
2.2  CSS	34
2.2.1  从编程语言的角度思考CSS	37
2.2.2  LESS和PostCSS	40
2.2.3  CSS-in-JS	42
2.2.4  Houdini	45
2.3  JavaScript	46
2.3.1  静态类型	48
2.3.2  不可变性	51
2.3.3  异步编程	53
2.4  总结	59
第3章  技术规范	61
3.1  技术选型	62
3.2  资源管理	65
3.2.1  目录结构	66
3.2.2  命名规范	70
3.3  编码风格	73
3.3.1  JavaScript的高性能与易读性	77
3.3.2  CSS编程范式与面向对象	79
3.4  总结	85
第4章  组件化	87
4.1  组件与模块	88
4.2  Web Components	93
4.2.1  自定义元素	94
4.2.2  Shadow DOM	104
4.2.3  HTML template	109
4.3  更友好的编码方式	115
4.3.1  多文件组件	116
4.3.2  单文件组件	120
4.4  设计模式	121
4.4.1  重新思考DOM	122
4.4.2  生命周期的设计艺术	123
4.5  总结	124
第5章  前后端分离	125
5.1  关注点分离	126
5.2  SPA与路由管理	129
5.2.1  Hash模式	130
5.2.2  History模式	136
5.3  Node.js中间层与同构编程	138
5.3.1  同构JavaScript	140
5.3.2  React同构方案	141
5.4  总结	150
第6章  性能	151
6.1  性能评估模型	152
6.2  从URL到图像	156
6.2.1  网络	159
6.2.2  渲染	166
6.3  内存管理	170
6.3.1  GC算法	171
6.3.2  内存泄漏	177
6.4  极限运算性能	180
6.5  总结	184
第7章  工程思维与服务支撑	185
7.1  工程思维	186
7.2  开发支撑	189
7.2.1  脚手架	190
7.2.2  构建	192
7.2.3  dev server	200
7.2.4  源码管理	201
7.3  测试支撑	207
7.3.1  测试模型	208
7.3.2  依赖注入	213
7.3.3  前后端集成	214
7.4  运维支撑	215
7.4.1  一键部署	216
7.4.2  日志埋点	217
7.4.3  性能监控	221
7.5  总结	222
第8章  DevOps与Serverless	223
8.1  DevOps与敏捷开发	224
8.1.1  敏捷开发	224
8.1.2  DevOps	228
8.2  持续交付	230
8.2.1  持续集成	230
8.2.2  低风险发布	234
8.3  Serverless与前端	236
8.3.1  BFF	236
8.3.2  Serverless	239
8.4  总结	242
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>前端技术架构与工程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大型互联网应用轻量级架构实战
1章 轻量级架构概述  1
1.1 大型互联网应用的特征  2
1.2 传统企业级应用技术的不足  5
1.3 Lite框架简介  7
2章 Servlet  10
2.1 Servlet概述  11
2.2 请求  16
2.3 Servlet上下文  19
2.4 响应  24
2.5 实战：基于Servlet的Web程序  26
2.6 Jetty  31
2.7 实战：在应用中内嵌Jetty容器  36
3章 Spring  基础  42
3.1 Spring概述  43
3.2 IoC  47
3.3 AOP  67
3.4 资源处理  76
3.5 表达式语言SpEL  80
4章 Spring单元测试  90
4.1 Mock对象  91
4.2 测试工具类  91
5章 Spring集成测试  93
5.1 集成测试概述  94
5.2 测试相关的注解  95
5.3 Spring  TestContext框架  106
5.4 Spring  MVC  Test框架  118
6章 Spring事务管理  128
6.1 事务管理概述  129
6.2 通过事务实现资源同步  132
6.3 声明式事务管理  133
6.4 编程式事务管理  146
7章 Spring  Web  MVC  148
7.1 Spring  Web  MVC  概述  149
7.2 DispatcherServlet  149
7.3 过滤器  153
7.4 控制器  155
7.5 异常处理  161
7.6 CORS处理  163
7.7 HTTP缓存  167
7.8 MVC配置  169
7.9 实战：基于Spring  Web  MVC的REST接口  177
8章 Spring  Security  183
8.1 基于角色的权限管理  184
8.2 Spring  Security基础  187
8.3 实战：基于Spring  Security的安全认证功能  194
9章 MyBatis  基础  202
9.1 MyBatis  概述  203
9.2 与Hibernate对比  203
9.3 大核心概念  204
9.4 生命周期及作用域  207
10章 MyBatis高级应用  209
10.1 配置文件  210
10.2 Mapper映文件  227
10.3 动态SQL  240
10.4 常用API  244
11章 Lite技术集成  253
11.1 技术集成概述  254
11.2 MySQL的安装及基本作  254
11.3 Spring与MyBatis集成  258
11.4 集成Spring  Web  MVC  264
11.5 集成Spring  Security  272
11.6 集成日志框架  276
12章 Lite架构分层  280
12.1 分层架构概述  281
12.2 数据访问层  286
12.3 事务处理  287
12.4 权限验证  287
12.5 接口访问层  288
12.6 实战：Lite框架的搭建  290
12.7 发布Lite框架到Maven仓库  306
13章 实战：基于Lite框架的互联网应用  318
13.1 lite-news概述  319
13.2 模型设计  322
13.3 接口设计与实现  324
13.4 实现权限管理  332
13.5 前端lite-news-ui设计  337
13.6 实现lite-news-ui原型  338
13.7 实现路由器  344
13.8 实现用户登录  349
13.9 实现新闻编辑器  353
13.10 实现新闻列表展示  358
13.11 实现新闻详情展示  361
13.12 总结  364
14章 使用NGINX实现高可用  365
14.1 NGINX概述  366
14.2 部署Angular应用  370
14.3 实现负载均衡及高可用  372
15章 使用Redis实现高并发  377
15.1 为什么需要缓存  378
15.2 了解Redis服务器  378
15.3 使用Redis  384
15.4 lite-news实现缓存  389
16章 Spring  Boot概述  395
16.1 构建RESTful服务  396
16.2 Spring  Boot的配置详解  405
16.3 内嵌  Servlet  容器  408
16.4 实现安全机制  409
17章 基于Spring  Boot的Lite框架  421
17.1 Lite  Spring  Boot  Starter项目搭建  422
17.2 集成Jetty  427
17.3 集成Spring  Security  428
17.4 集成MyBatis  431
17.5 总结  436
附录  437
参  考  文  献  438
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大型互联网应用轻量级架构实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>发布！软件的设计与部署
第1章　引言　　1
1.1　瞄准正确的目标　　1
1.2　使用决断力　　2
1.3　生活的质量　　3
1.4　挑战的范围　　3
1.5　随手一松就是一百万　　3
1.6　务实的架构　　4
第一部分　稳定性
第2章　案例研究：航空系统宕机的异常　　8
2.1　事故　　9
2.2　结果　　12
2.3　事后调查　　12
2.4　确凿的证据　　15
2.5　一点预防　　17
第3章　稳定性概述　　19
3.1　定义稳定性　　20
3.2　故障模式　　22
3.3　裂痕扩散　　22
3.4　故障链　　23
3.5　模式与反模式　　24
第4章　稳定性反模式　　26
4.1　集成点　　27
4.2　连锁反应　　37
4.3　连锁故障　　40
4.4　用户　　42
4.5　阻塞的线程　　50
4.6　自我否定攻击　　55
4.7　尺度效应　　57
4.8　不平衡的容量　　60
4.9　慢响应　　63
4.10　SLA倒置　　64
4.11　无边界结果集　　67
第5章　稳定性模式　　70
5.1　使用超时　　70
5.2　断路器　　73
5.3　隔板　　75
5.4　稳定状态　　78
5.5　快速失效　　83
5.6　握手　　85
5.7　测试装置　　87
5.8　去耦合中间件　　90
第6章　稳定性总结　　93
第二部分　容量
第7章　案例研究：被客户压迫　　96
7.1　发布倒计时　　96
7.2　瞄准QA　　97
7.3　负载测试　　99
7.4　被大量会话所杀　　101
7.5　测试的鸿沟　　102
7.6　后果　　103
第8章　容量概述　　105
8.1　定义容量　105
8.2　约束　　106
8.3　关联　　107
8.4　可扩展性　　107
8.5　容量的神话　　108
8.6　总结　　114
第9章　容量反模式　　115
9.1　资源池竞争　　115
9.2　泛滥的JSP碎片　　118
9.3　AJAX过度之伤　　119
9.4　驻留过久的会话　　121
9.5　HTML中浪费的空间　　122
9.6　刷新按钮　　125
9.7　手工的SQL语句　　126
9.8　数据库富营养化　　128
9.9　集成点延迟　　130
9.10　Cookie怪兽　　131
9.11　总结　　133
第10章　容量模式　　134
10.1　连接池　　134
10.2　谨慎使用缓存　　136
10.3　预计算容量　　137
10.4　调整垃圾回收器　　140
10.5　总结　　142
第三部分　一般设计问题
第11章　网络连接　　144
11.1　多宿主服务器　　144
11.2　路由　　146
11.3　虚拟IP地址　　146
第12章　安全　149
12.1　最少特权原则　　149
12.2　配置的密码　　150
第13章　可用性　　151
13.1　收集可用性需求　　151
13.2　记录可用性需求　　152
13.3　负载均衡　　153
13.4　集群　　157
第14章　管理　　159
14.1　“测试和产品匹配吗？”　　159
14.2　配置文件　　161
14.3　启动和关闭　　163
14.4　管理接口　　164
第15　章　设计总结.　165
第四部分　运营
第16章　案例研究：惊人的宇宙　　168
16.1　旺季　　168
16.2　婴儿的第一个圣诞　　169
16.3　切脉　　169
16.4　感恩节　　170
16.5　黑色星期五　　170
16.6　重要的信号　　172
16.7　诊断测试　　172
16.8　专家打来电话　173
16.9　比较解救方案　174
16.10　条件是否会响应处理　　175
16.11　收尾　　176
第17章　透明度　　177
17.1　视角　　178
17.2　透明度设计　　184
17.3　使用各种技术　184
17.4　日志　　185
17.5　监控系统　　190
17.6　法律上及事实上的标准　　194
17.7　操作数据库　　201
17.8　支持流程　　205
17.9　总结　　208
第18章　适应　　209
18.1　与时俱进　　209
18.2　适应性的软件设计　　210
18.3　适应性的企业架构　　215
18.4　发布应无害　　220
18.5　总结　　224
参考书目　　226
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>发布！软件的设计与部署
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>构建可扩展的Web站点
前言
第1章：绪论
什么是WEB应用程序
如何构建你的WEB应用程序
什么是体系结构
怎样开始呢
第2章：WEB应用程序体系结构
层次化软件体系结构
层次化技术
软件接口设计
从A到B
软件/硬件的划分
硬件平台
硬件平台的增长
硬件冗余
网络
语言，技术和数据库
第3章：开发环境
三大规则
使用源码控制
单步构建
问题跟踪
扩展开发模型
编码规范
测试
第4章：国际化、本地化和UNICODE
国际化和本地化
UNICODE简述
UTF-8编码
基于UTF-8的WEB应用程序
在PHP中使用UTF-8
在其他语言中使用UTF-8
在MYSQL中使用UTF-8
在电子邮件中使用UTF-8
在JAVASCRIPT中使用UTF-8
在API中使用UTF-8
第5章：数据一致性和安全性
数据完整性策略
好的、有效的和无效的
过滤UTF-8数据
过滤控制字符
过滤HTML
跨站脚本攻击
SQL注入攻击
第6章：电子邮件
接收电子邮件
在应用程序中加入电子邮件功能
MIME格式
解析简单的MIME电子邮件
解析UU编码的附件
TNEF附件
无线通信运营商会讨厌你
字符集与编码
识别你的用户
单元测试
第7章：远程服务
远程服务小组
套接字
使用HTTP
远程服务冗余性
异步系统
XML交换
轻型协议
第8章：瓶颈
找出瓶颈
CPU的使用
I/O
内存和SWAP
外部服务和黑盒
数据库
第9章：扩展WEB应用程序
扩展之谜
网络扩展
扩展PHP
负载平衡
扩展MYSQL
MYSQL复制
数据库分区
扩展大型数据库
存储扩展
扩展综述
第10章：统计数据、监测与警告
跟踪WEB统计数据
应用程序监测
警告
第11章：APIS
数据订阅源
移动内容
WEB服务
API传输方式
API的滥用
认证
展望未来
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>构建可扩展的Web站点
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>游戏编程算法与技巧
第1 章游戏编程概述. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
游戏编程的发展2
Atari 时期（1977—1985 年） 2
NES 和SNES 时期（1985—1995 年） 3
PS 和PS2 时期（1995—2005 年） 3
Xbox360、PS3 和Wii 时期（2005—2013 年） 3
游戏的未来4
游戏循环4
传统的游戏循环4
多线程下的游戏循环6
时间和游戏8
真实时间和游戏时间8
通过处理时间增量来表示游戏逻辑8
游戏对象10
游戏对象的类型10
游戏循环中的游戏对象11
总结13
习题13
相关资料14
游戏编程的发展14
游戏循环14
游戏对象14
第2 章2D 图形. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
2D 渲染基础16
CRT 显示器基础16
像素缓冲区和垂直同步17
精灵18
绘制精灵18
动画精灵20
精灵表单23
滚屏24
单轴滚屏24
无限滚屏26
平行滚屏27
四向滚屏28
砖块地图29
简单的砖块地图29
斜视等视角砖块地图31
总结32
习题32
相关资料33
Cocos2D 33
SDL 33
第3 章游戏中的线性代数. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
向量35
加法36
减法37
长度、单位向量和正规化38
标量乘积39
点乘40
问题举例：向量反射41
叉乘43
问题举例：旋转一个2D 角色45
线性插值46
坐标系47
矩阵48
加法/减法48
标量乘法49
乘法49
逆矩阵50
转置50
用矩阵变换3D 向量51
总结52
习题52
相关资料53
第4 章3D 图形. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54
基础55
多边形55
坐标系55
模型坐标系56
世界坐标系56
视角/摄像机坐标系60
投影坐标系62
光照与着色64
颜色64
顶点属性65
光照67
Phong 光照模型68
着色70
可见性71
再探画家算法72
深度缓冲区73
再探世界变换74
四元数75
3D 游戏对象的表示77
总结77
习题77
相关资料78
第5 章游戏输入. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79
输入设备80
数字输入80
模拟输入82
基于事件的输入系统84
基础事件系统85
一个更复杂的系统87
移动设备输入89
触屏和手势89
加速器和陀螺仪91
其他移动设备输入92
总结92
习题92
相关资料93
第6 章声音. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94
基本声音95
原始数据95
声音事件95
3D 声音98
监听者和发射者98
衰减100
环绕声100
数字信号处理101
常见数字信号处理效果102
区域标记102
其他声音话题103
多普勒效应103
声音遮挡104
总结105
目录xiii
习题106
参考资料106
第7 章物理. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107
平面、射线和线段108
平面108
射线和线段109
碰撞几何体110
包围球110
轴对齐包围盒111
朝向包围盒111
胶囊体112
凸多边形113
组合碰撞几何体113
碰撞检测113
球与球的交叉113
AABB 与AABB 交叉114
线段与平面交叉115
线段与三角片交叉117
球与平面交叉119
球形扫掠体检测120
响应碰撞124
优化碰撞125
基于物理的移动126
线性力学概览127
可变时间步长带来的问题128
力的计算128
欧拉和半隐式欧拉积分129
Verlet 积分法129
其他积分方法130
角力学130
物理中间件130
总结131
习题131
相关资料131
第8 章摄像机. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
摄像机的类型133
固定摄像机133
第一人称摄像机134
跟随摄像机134
场景切换摄像机135
透视投影135
视场136
宽高比137
摄像机的实现138
基础的跟随摄像机138
弹性跟随摄像机139
旋转摄像机142
第一人称摄像机144
样条摄像机146
摄像机支持算法149
摄像机碰撞149
拣选149
总结151
习题151
相关资料151
第9 章人工智能. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152
“真”AI 与游戏AI 153
寻路153
搜索空间的表示154
可接受的启发式算法156
贪婪最佳优先算法157
A* 寻路161
Dijkstra 算法163
基于状态的行为164
AI 的状态机164
基础的状态机实现165
状态机设计模式167
策略和计划168
策略168
计划169
总结170
习题170
相关资料172
通用AI 172
寻路172
状态172
第10 章用户界面. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173
菜单系统174
菜单栈174
按钮175
打字176
HUD 元素177
路点箭头177
准心180
雷达181
其他需要考虑的UI 问题186
支持多套分辨率186
本地化187
UI 中间件189
用户体验189
总结189
习题189
相关资料190
第11 章脚本语言和数据格式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
脚本语言192
折中192
脚本语言的类型193
Lua 194
UnrealScript 195
可视化脚本系统196
实现一门脚本语言197
标记化197
正则表达式198
语法分析199
代码的执行和生成200
数据格式202
折中202
二进制格式203
INI 203
XML 203
JSON 204
案例学习：《魔兽世界》中的UI Mod 205
布局和事件205
行为206
问题：玩家自动操作206
问题：UI 兼容性206
结论207
总结207
习题207
相关资料208
第12 章网络游戏. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209
协议210
IP 210
ICMP 211
TCP 212
UDP 214
网络拓扑215
服务器/客户端216
点对点218
作弊219
信息作弊219
游戏状态作弊220
中间人攻击220
总结221
习题221
相关资料222
第13 章游戏示例：横向滚屏者（iOS） . . . . . . . . . . . . . . . . . . . . . . . . . . 223
概览224
Objective-C 224
Cocos2D 225
代码分析226
AppDelegate 226
MainMenuLayer 227
GameplayScene 227
ScrollingLayer 227
Ship 228
Projectile 229
Enemy 229
ObjectLayer 229
练习230
总结231
第14 章游戏示例：塔防（PC/Mac）. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 232
概览233
C# 233
XNA 235
MonoGame 235
xviii 目录
代码分析236
设置236
单件236
游戏类237
游戏状态237
游戏对象238
关卡239
计时器239
寻路240
摄像机和投影241
输入241
物理242
本地化242
图形242
声音243
用户界面243
练习245
总结246
附录A 习题答案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 247
附录B 对开发者有用的工具. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 260
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>游戏编程算法与技巧
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Tomcat内核设计剖析
第1章 Web服务器机制 1
1.1 通信协议 1
1.1.1 HTTP/HTTPS 1
1.1.2 HTTP请求/响应模型 3
1.1.3 解析HTTP报文 4
1.2 套接字通信 7
1.2.1 单播通信 8
1.2.2 组播通信 9
1.2.3 广播通信 12
1.3 服务器模型 13
1.3.1 单线程阻塞I/O模型 14
1.3.2 多线程阻塞I/O模型 15
1.3.3 单线程非阻塞I/O模型 16
1.3.4 多线程非阻塞I/O模型 19
第2章 Servlet规范 22
2.1 Servlet接口 22
2.2 ServletRequest接口 23
2.3 ServletContext接口 23
2.4 ServletResponse接口 24
2.5 Filter接口 24
2.6 会话 25
2.7 注解 25
2.8 可插拔性 26
2.9 请求分发器 26
2.10 Web应用 26
2.11 Servlet映射 27
2.12 部署描述文件 28
第3章 Tomcat的启动与关闭 29
3.1 Tomcat的批处理 29
3.1.1 startup.bat 29
3.1.2 shutdown.bat 31
3.1.3 catalina.bat 31
3.1.4 setclasspath.bat 39
3.2 Tomcat中的变量及属性 40
3.2.1 环境变量 41
3.2.2 JVM系统变量 41
3.2.3 Tomcat属性 44
第4章 从整体预览Tomcat 45
4.1 整体结构及组件介绍 45
4.2 请求处理的整体过程 50
第5章 Server组件与Service组件 52
5.1 Server组件 52
5.1.1 生命周期监听器 53
5.1.2 全局命名资源 57
5.1.3 监听SHUTDOWN命令 58
5.2 Service组件 59
第6章 Connector组件 63
6.1 HTTP阻塞模式协议—Http11Protocol 64
6.1.1 套接字接收终端—JIoEndpoint 65
6.1.2 HTTP阻塞处理器—Http11Processor 73
6.2 HTTP非阻塞模式协议—Http11NioProtocol 102
6.2.1 非阻塞接收终端—NioEndpoint 102
6.2.2 HTTP非阻塞处理器—Http11NioProcessor 111
6.3 HTTP APR模式协议—Http11AprProtocol 114
6.3.1 APR接收终端—AprEndpoint 114
6.3.2 HTTP APR处理器—Http11AprProcessor 119
6.4 AJP Connector 121
6.4.1 AJP阻塞模式协议—AjpProtocol 123
6.4.2 AJP APR模式协议—AjpAprProtocol 125
6.5 HTTP三种模式的Connector 126
6.6 AJP三种模式的Connector 126
第7章 Engine容器 127
第8章 Host容器 129
8.1 Web应用—Context 129
8.2 访问日志—AccessLog 130
8.3 管道—Pipeline 130
8.4 Host集群—Cluster 130
8.5 Host域—Realm 130
8.6 生命周期监听器—HostConfig 131
8.6.1 Descriptor描述符类型 131
8.6.2 WAR包类型 132
8.6.3 目录类型 133
第9章 Context容器 134
9.1 Context容器的配置文件 134
9.2 包装器—Wrapper 135
9.3 Context域—Realm 135
9.4 访问日志—AccessLog 135
9.5 错误页面—ErrorPage 135
9.6 会话管理器—Manager 137
9.7 目录上下文—DirContext 137
9.8 安全认证 138
9.9 Jar扫描器—JarScanner 138
9.10 过滤器 139
9.11 命名资源—NamingResource 140
9.12 Servlet映射器—Mapper 141
9.13 管道—Pipeline 141
9.14 Web应用载入器—WebappLoader 142
9.15 ServletContext的实现—ApplicationContext 143
9.16 实例管理器—InstanceManager 145
9.17 ServletContainerInitializer初始化器 145
9.18 Context容器的监听器 147
9.18.1 ContextConfig监听器 148
9.18.2 TldConfig监听器 151
9.18.3 NamingContextListener监听器 151
9.18.4 MemoryLeakTrackingListener监听器 151
第10章 Wrapper容器 154
10.1 Servlet工作机制 154
10.2 Servlet对象池 156
10.3 过滤器链 157
10.4 Servlet种类 158
10.5 Comet模式的支持 161
10.6 WebSocket协议的支持 163
10.7 异步Servlet 166
第11章 生命周期管理 169
11.1 生命周期统一接口—Lifecycle 169
11.2 生命周期的状态转化 170
11.3 生命周期事件监听机制 172
第12章 日志框架及其国际化 177
12.1 系统内日志 177
12.2 日志的国际化 179
12.3 客户端访问日志 181
12.3.1 访问日志组件的设计 182
12.3.2 访问日志格式的自定义 184
第13章 公共与隔离的类加载器 186
13.1 类加载器 186
13.2 自定义类加载器 189
13.3 Tomcat中的类加载器 192
13.4 类加载器工厂—ClassLoaderFactory 194
13.5 遭遇ClassNotFoundException 196
第14章 请求URI映射器Mapper 200
14.1 请求的映射模型 200
14.2 Mapper的实现 201
14.3 局部路由Mapper 203
14.4 全局路由Mapper 204
第15章 Tomcat的JNDI 205
15.1 JNDI简介 205
15.2 JNDI运行机制 206
15.3 在Tomcat中集成JNDI 210
15.4 在Tomcat中使用JNDI 222
15.4.1 Web应用的局部配置方式 222
15.4.2 服务器的全局配置方式 223
15.5 Tomcat的标准资源 226
第16章 JSP编译器Jasper 227
16.1 从JSP到Servlet 228
16.1.1 语法树的生成—语法解析 228
16.1.2 语法树的遍历—访问者模式 230
16.1.3 JSP编译后的Servlet 232
16.2 从Servlet到Class字节码 235
16.2.1 JSR45标准 235
16.2.2 JDT Compiler编译器 236
16.2.3 Jasper自动检测机制 241
第17章 运行、通信及访问的安全管理 243
17.1 运行安全管理 243
17.1.1 Java安全管理器—SecurityManager 243
17.1.2 Tomcat的系统安全管理 246
17.1.3 安全管理器特权 248
17.2 安全的通信 249
17.2.1 SSL/TLS协议 249
17.2.2 Java安全套接字扩展—JSSE 251
17.2.3 Tomcat中SSL安全信道的实现 264
17.3 客户端访问认证机制 266
17.3.1 Web资源认证原理 266
17.3.2 认证模式 267
17.3.3 Realm域 272
17.3.4 Tomcat如何实现资源安全管理 273
17.3.5 如何让你的Web具备权限认证 274
第18章 处理请求和响应的管道 276
18.1 管道模式—管道与阀门 276
18.2 Tomcat中的管道 280
18.3 Tomcat中的定制阀门 282
第19章 多样化的会话管理器 285
19.1 Web容器的会话机制 286
19.2 标准会话对象—StandardSession 287
19.3 增量会话对象—DeltaSession 288
19.4 标准会话管理器—StandardManager 290
19.5 持久化会话管理器—PersistentManager 291
19.5.1 FileStore 292
19.5.2 JDBCStore 293
19.6 集群增量会话管理器—DeltaManager 294
19.7 集群备份会话管理器—BackupManager 296
19.7.1 机制与原理 297
19.7.2 高可用性及故障转移机制 299
19.7.3 集群RPC通信 301
19.8 Tomcat会话管理器的集成 308
第20章 高可用的集群实现 311
20.1 从单机到集群的会话管理 311
20.1.1 单机模式 311
20.1.2 集群模式 313
20.2 Cluster组件 315
20.3 Tomcat的Cluster工作机制 317
20.4 Tomcat中Cluster的级别 318
20.5 如何让Tomcat实现集群功能 318
第21章 集群通信框架 320
21.1 Tribes简介 320
21.2 集群成员维护服务—MembershipService 321
21.3 平行的消息发送通道—ChannelSender 325
21.4 消息接收通道—ChannelReceiver 327
21.5 通道拦截器—ChannelInterceptor 328
21.6 应用层处理入口—MembershipListener与ChannelListener 331
21.7 如何使用Tribes进行数据传输 332
21.8 Tomcat使用Tribes同步会话 334
21.9 Tomcat使用Tribes部署集群应用 334
第22章 监控与管理 337
22.1 Java管理扩展—JMX 337
22.1.1 JMX的基本结构 337
22.1.2 JMX例子 338
22.2 JMX管理下的Tomcat 339
22.3 ManagerServlet 343
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Tomcat内核设计剖析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>简约之美
目录
第1 章 　引言　　1
1.1 　计算机出了什么问题？　　3
1.2 　程序究竟是什么？　　5
第2 章 　缺失的科学　　9
2.1 　程序员也是设计师　　12
2.2 　软件设计的科学　　13
2.3 　为什么不存在软件设计科学　　15
第3 章 　软件设计的推动力　　19
第4 章 　未来　　27
4.1 　软件设计的方程式　　29
4.1.1 　价值　　30
4.1.2 　成本　　31
4.1.3 　维护　　32
4.1.4 　完整的方程式　　33
4.1.5 　化简方程式　　33
4.1.6 　你需要什么，不需要什么　　34
4.2 　设计的质量　　36
4.3 　不可预测的结果　　37
第5 章 　变化　　41
5.1 　真实世界中程序的变化　　43
5.2 　软件设计的三大误区　　46
5.2.1 　编写不必要的代码　　46
5.2.2 　代码难以修改　　48
5.2.3 　过分追求通用　　51
5.3 　渐进式开发及设计　　53
第6 章 　缺陷与设计　　55
6.1 　如果这不是问题……　　57
6.2 　避免重复　　59
第7 章 　简洁　　61
7.1 　简洁与软件设计方程式　　65
7.2 　简洁是相对的　　65
7.3 　简洁到什么程度？　　67
7.4 　保持一致　　69
7.5 　可读性　　71
7.5.1 　命名　　72
7.5.2 　注释　　73
7.6 　简洁离不开设计　　74
第8 章 　复杂性　　77
8.1 　复杂性与软件的用途　　81
8.2 　糟糕的技术　　83
8.2.1 　生存潜力　　83
8.2.2 　互通性　　84
8.2.3 　对品质的重视　　84
8.2.4 　其他原因　　85
8.3 　复杂性及错误的解决方案　　85
8.4 　复杂问题　　86
8.5 　应对复杂性　　87
8.5.1 　把某个部分变简单　　89
8.5.2 　不可解决的复杂性　　90
8.6 　推倒重来　　90
第9 章 　测试　　93
附录A 　软件设计的规则　　97
附录B 　事实、规则、条例、定义　　101
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>简约之美
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Kubernetes进阶实战
前言
第1章 Kubernetes系统基础 1
1.1 容器技术概述 1
1.1.1 容器技术的功用 2
1.1.2 容器简史 3
1.1.3 Docker的功能限制 4
1.2 Kubernetes概述 4
1.2.1 Kubernetes简史 4
1.2.2 Kubernetes特性 5
1.2.3 Kubernetes概念和术语 6
1.3 Kubernetes集群组件 10
1.3.1 Master组件 10
1.3.2 Node组件 12
1.3.3 核心附件 13
1.4 Kubernetes网络模型基础 13
1.4.1 网络模型概述 13
1.4.2 集群上的网络通信 15
1.5 本章小结 16
第2章 Kubernetes快速入门 17
2.1 Kubernetes的核心对象 17
2.1.1 Pod资源对象 18
2.1.2 Controller 19
2.1.3 Service 20
2.1.4 部署应用程序的主体过程 21
2.2 部署Kubernetes集群 22
2.2.1 kubeadm部署工具 22
2.2.2 集群运行模式 24
2.2.3 准备用于实践操作的集群环境 25
2.2.4 获取集群环境相关的信息 26
2.3 kubectl使用基础与示例 26
2.4 命令式容器应用编排 29
2.4.1 部署应用（Pod） 30
2.4.2 探查Pod及应用详情 33
2.4.3 部署Service对象 36
2.4.4 扩容和缩容 38
2.4.5 修改及删除对象 40
2.5 本章小结 41
第3章 资源管理基础 42
3.1 资源对象及API群组 42
3.1.1 Kubernetes的资源对象 43
3.1.2 资源及其在API中的组织形式 46
3.1.3 访问Kubernetes REST API 48
3.2 对象类资源格式 49
3.2.1 资源配置清单 50
3.2.2 metadata嵌套字段 51
3.2.3 spec和status字段 52
3.2.4 资源配置清单格式文档 53
3.2.5 资源对象管理方式 54
3.3 kubectl命令与资源管理 56
3.3.1 资源管理操作概述 56
3.3.2 kubectl的基本用法 57
3.4 管理名称空间资源 59
3.4.1 查看名称空间及其资源对象 60
3.4.2 管理Namespace资源 61
3.5 Pod资源的基础管理操作 61
3.5.1 陈述式对象配置管理方式 62
3.5.2 声明式对象配置管理方式 64
3.6 本章小结 65
第4章 管理Pod资源对象 66
4.1 容器与Pod资源对象 66
4.2 管理Pod对象的容器 68
4.2.1 镜像及其获取策略 69
4.2.2 暴露端口 70
4.2.3 自定义运行的容器化应用 71
4.2.4 环境变量 72
4.2.5 共享节点的网络名称空间 73
4.2.6 设置Pod对象的安全上下文 74
4.3 标签与标签选择器 75
4.3.1 标签概述 75
4.3.2 管理资源标签 77
4.3.3 标签选择器 78
4.3.4 Pod节点选择器nodeSelector 79
4.4 资源注解 80
4.4.1 查看资源注解 81
4.4.2 管理资源注解 82
4.5 Pod对象的生命周期 82
4.5.1 Pod的相位 82
4.5.2 Pod的创建过程 83
4.5.3 Pod生命周期中的重要行为 84
4.5.4 容器的重启策略 87
4.5.5 Pod的终止过程 87
4.6 Pod存活性探测 88
4.6.1 设置exec探针 89
4.6.2 设置HTTP探针 90
4.6.3 设置TCP探针 92
4.6.4 存活性探测行为属性 93
4.7 Pod就绪性探测 94
4.8 资源需求及资源限制 96
4.8.1 资源需求 96
4.8.2 资源限制 98
4.8.3 容器的可见资源 99
4.8.4 Pod的服务质量类别 100
4.9 本章小结 101
第5章 Pod控制器 103
5.1 关于Pod控制器 103
5.1.1 Pod控制器概述 104
5.1.2 控制器与Pod对象 105
5.1.3 Pod模板资源 106
5.2 ReplicaSet控制器 106
5.2.1 ReplicaSet概述 107
5.2.2 创建ReplicaSet 108
5.2.3 ReplicaSet管控下的Pod对象 109
5.2.4 更新ReplicaSet控制器 111
5.2.5 删除ReplicaSet控制器资源 114
5.3 Deployment控制器 114
5.3.1 创建Deployment 115
5.3.2 更新策略 116
5.3.3 升级Deployment 119
5.3.4 金丝雀发布 121
5.3.5 回滚Deployment控制器下的应用发布 123
5.3.6 扩容和缩容 123
5.4 DaemonSet控制器 124
5.4.1 创建DaemonSet资源对象 124
5.4.2 更新DaemonSet对象 126
5.5 Job控制器 127
5.5.1 创建Job对象 128
5.5.2 并行式Job 129
5.5.3 Job扩容 130
5.5.4 删除Job 130
5.6 CronJob控制器 131
5.6.1 创建CronJob对象 131
5.6.2 CronJob的控制机制 132
5.7 ReplicationController 133
5.8 Pod中断预算 133
5.9 本章小结 134
第6章 Service和Ingress 136
6.1 Service资源及其实现模型 136
6.1.1 Service资源概述 136
6.1.2 虚拟IP和服务代理 138
6.2 Service资源的基础应用 140
6.2.1 创建Service资源 140
6.2.2 向Service对象请求服务 141
6.2.3 Service会话粘性 142
6.3 服务发现 143
6.3.1 服务发现概述 143
6.3.2 服务发现方式：环境变量 145
6.3.3 ClusterDNS和服务发现 146
6.3.4 服务发现方式：DNS 146
6.4 服务暴露 147
6.4.1 Service类型 147
6.4.2 NodePort类型的Service资源 149
6.4.3 LoadBalancer类型的Service资源 150
6.4.4 ExternalName Service 151
6.5 Headless类型的Service资源 152
6.5.1 创建Headless Service资源 153
6.5.2 Pod资源发现 153
6.6 Ingress资源 154
6.6.1 Ingress和Ingress Controller 154
6.6.2 创建Ingress资源 155
6.6.3 Ingress资源类型 157
6.6.4 部署Ingress控制器（Nginx） 159
6.7 案例：使用Ingress发布tomcat 161
6.7.1 准备名称空间 161
6.7.2 部署tomcat实例 162
6.7.3 创建Service资源 163
6.7.4 创建Ingress资源 164
6.7.5 配置TLS Ingress资源 165
6.8 本章小结 168
第7章 存储卷与数据持久化 169
7.1 存储卷概述 169
7.1.1 Kubernetes支持的存储卷类型 170
7.1.2 存储卷的使用方式 171
7.2 临时存储卷 172
7.2.1 emptyDir存储卷 172
7.2.2 gitRepo存储卷 175
7.3 节点存储卷hostPath 176
7.4 网络存储卷 178
7.4.1 NFS存储卷 178
7.4.2 RBD存储卷 180
7.4.3 GlusterFS存储卷 182
7.4.4 Cinder存储卷 183
7.5 持久存储卷 184
7.5.1 创建PV 186
7.5.2 创建PVC 188
7.5.3 在Pod中使用PVC 190
7.5.4 存储类 191
7.5.5 PV和PVC的生命周期 194
7.6 downwardAPI存储卷 196
7.6.1 环境变量式元数据注入 197
7.6.2 存储卷式元数据注入 199
7.7 本章小结 201
第8章 配置容器应用：ConfigMap和Secret 202
8.1 容器化应用配置方式 202
8.2 通过命令行参数配置容器应用 204
8.3 利用环境变量配置容器应用 206
8.4 应用程序配置管理及ConfigMap资源 208
8.4.1 创建ConfigMap对象 209
8.4.2 向Pod环境变量传递ConfigMap对象键值数据 212
8.4.3 ConfigMap存储卷 215
8.4.4 容器应用重载新配置 219
8.4.5 使用ConfigMap资源的注意事项 220
8.5 Secret资源 221
8.5.1 Secret概述 221
8.5.2 创建Secret资源 222
8.5.3 Secret存储卷 224
8.5.4 imagePullSecret资源对象 225
8.6 本章小结 226
第9章 StatefulSet控制器 227
9.1 StatefulSet概述 227
9.1.1 Stateful应用和Stateless应用 227
9.1.2 StatefulSet控制器概述 228
9.1.3 StatefulSet的特性 230
9.2 StatefulSet基础应用 231
9.2.1 创建StatefulSet对象 232
9.2.2 Pod资源标识符及存储卷 234
9.3 StatefulSet资源扩缩容 237
9.4 StatefulSet资源升级 238
9.4.1 滚动更新 238
9.4.2 暂存更新操作 239
9.4.3 金丝雀部署 240
9.4.4 分段更新 241
9.4.5 其他话题 241
9.5 案例：etcd集群 242
9.5.1 创建Service资源 242
9.5.2 etcd StatefulSet 243
9.6 本章小结 247
第10章 认证、授权与准入控制 248
10.1 访问控制概述 248
10.1.1 用户账户与用户组 249
10.1.2 认证、授权与准入控制基础 250
10.2 服务账户管理与应用 253
10.2.1 Service Account自动化 253
10.2.2 创建服务账户 255
10.2.3 调用imagePullSecret资源对象 256
10.3 X.509数字证书认证 256
10.3.1 Kubernetes中的SSL/TLS认证 257
10.3.2 客户端配置文件kubeconfig 259
10.3.3 TLS bootstrapping机制 262
10.4 基于角色的访问控制：RBAC 263
10.4.1 RBAC授权插件 264
10.4.2 Role和RoleBinding 266
10.4.3 ClusterRole和ClusterRoleBin-ding 269
10.4.4 聚合型ClusterRole 271
10.4.5 面向用户的内建ClusterRole 273
10.4.6 其他的内建ClusterRole和ClusterRoleBinding 274
10.5 Kubernetes Dashboard 275
10.5.1 部署HTTPS通信的Dashboard 275
10.5.2 配置token认证 277
10.5.3 配置kubeconfig认证 277
10.6 准入控制器与应用示例 279
10.6.1 LimitRange资源与LimitRanger准入控制器 279
10.6.2 ResourceQuota资源与准入控制器 281
10.6.3 PodSecurityPolicy 283
10.7 本章小结 288
第11章 网络模型与网络策略 289
11.1 Kubernetes网络模型及CNI插件 289
11.1.1 Docker容器的网络模型 289
11.1.2 Kubernetes网络模型 291
11.1.3 Pod网络的实现方式 293
11.1.4 CNI插件及其常见的实现 295
11.2 flannel网络插件 297
11.2.1 flannel的配置参数 297
11.2.2 VxLAN后端和direct routing 298
11.2.3 host-gw后端 301
11.3 网络策略 302
11.3.1 网络策略概述 302
11.3.2 部署Canal提供网络策略功能 303
11.3.3 配置网络策略 305
11.3.4 管控入站流量 306
11.3.5 管控出站流量 308
11.3.6 隔离名称空间 310
11.3.7 网络策略应用案例 311
11.4 Calico网络插件 315
11.4.1 Calico工作特性 316
11.4.2 Calico系统架构 318
11.4.3 Calico部署要点 320
11.4.4 部署Calico提供网络服务和网络策略 321
11.4.5 客户端工具calicoctl 324
11.5 本章小结 325
第12章 Pod资源调度 326
12.1 Kubernetes调度器概述 326
12.1.1 常用的预选策略 327
12.1.2 常用的优选函数 330
12.2 节点亲和调度 332
12.2.1 节点硬亲和性 332
12.2.2 节点软亲和性 335
12.3 Pod资源亲和调度 337
12.3.1 位置拓扑 338
12.3.2 Pod硬亲和调度 338
12.3.3 Pod软亲和调度 341
12.3.4 Pod反亲和调度 342
12.4 污点和容忍度 343
12.4.1 定义污点和容忍度 344
12.4.2 管理节点的污点 345
12.4.3 Pod对象的容忍度 346
12.4.4 问题节点标识 347
12.5 Pod优选级和抢占式调度 347
12.6 本章小结 348
第13章 Kubernetes系统扩展 349
13.1 自定义资源类型（CRD） 349
13.1.1 创建CRD对象 350
13.1.2 自定义资源格式验证 351
13.1.3 子资源 353
13.1.4 使用资源类别 355
13.1.5 多版本支持 355
13.1.6 自定义控制器基础 356
13.2 自定义API Server 359
13.2.1 自定义API Server概述 359
13.2.2 APIService对象 360
13.3 Kubernetes集群高可用 361
13.3.1 etcd高可用 362
13.3.2 Controller Manager和Scheduler高可用 363
13.4 Kubernetes的部署模式 364
13.4.1 关键组件 365
13.4.2 常见的部署模式 366
13.5 容器时代的DevOps概述 369
13.5.1 容器：DevOps协作的基础 369
13.5.2 泛型端到端容器应用程序生命周期工作流 370
13.5.3 基于Kubernetes的DevOps 371
13.6 本章小结 372
第14章 资源指标及HPA控制器 373
14.1 资源监控及资源指标 373
14.1.1 资源监控及Heapster 374
14.1.2 新一代监控架构 376
14.2 资源指标及其应用 378
14.2.1 部署metrics-server 378
14.2.2 kubectl top命令 380
14.3 自定义指标与Prometheus 381
14.3.1 Prometheus概述 382
14.3.2 部署Prometheus监控系统 384
14.3.3 自定义指标适配器k8s-prometheus-adapter 388
14.4 自动弹性缩放 390
14.4.1 HPA概述 390
14.4.2 HPA（v1）控制器 391
14.4.3 HPA（v2）控制器 393
14.5 本章小结 397
第15章 Helm程序包管理器 398
15.1 Helm基础 398
15.1.1 Helm的核心术语 399
15.1.2 Helm架构 400
15.1.3 安装Helm Client 400
15.1.4 安装Tiller server 401
15.1.5 Helm快速入门 402
15.2 Helm Charts 405
15.2.1 Charts文件组织结构 405
15.2.2 Chart.yaml文件组织格式 406
15.2.3 Charts中的依赖关系 407
15.2.4 模板和值 408
15.2.5 其他需要说明的话题 409
15.2.6 自定义Charts 410
15.3 Helm实践：部署EFK日志管理系统 415
15.3.1 ElasticSearch集群 416
15.3.2 日志采集代理fluentd 421
15.3.3 可视化组件Kibana 422
15.4 本章小结 424
附录A　部署Kubernetes集群 425
附录B　部署GlusterFS及Heketi 437
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Kubernetes进阶实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>领域驱动设计精粹
第1章  DDD对我而言  1
DDD很难掌握吗  2
优秀设计、糟糕设计和有效设计  3
战略设计  8
战术设计  9
学习过程与知识提炼  10
让我们开始吧!  11
第2章  运用限界上下文与通用语言进行战略设计  13
领域专家和业务驱动  20
案例分析  24
战略设计是必要的根基  28
在质疑中统一  32
发展通用语言  38
应用场景  42
如何持续  45
架构  46
本章小结  50
第3章  运用子域进行战略设计  51
什么是子域  52
子域类型  53
应对复杂性  54
本章小结  56
第4章  运用上下文映射进行战略设计  57
映射的种类  60
合作关系  60
共享内核  61
客户—供应商  62
跟随者  63
防腐层  64
开放主机服务  65
已发布语言  65
各行其道  66
大泥球  67
善用上下文映射  69
基于SOAP的RPC  70
RESTful HTTP  72
消息机制  74
上下文映射示例  79
本章小结  83
第5章  运用聚合进行战术设计  85
为什么使用它  86
聚合的经验法则  91
规则一：在聚合边界内保护业务规则不变性  92
规则二：聚合要设计得小巧  93
规则三：只能通过标识符引用其他聚合  95
规则四：利用最终一致性更新其他聚合  96
建立聚合模型  99
慎重选择抽象级别  104
大小适中的聚合  106
可测试的单元  108
本章小结  108
第6章  运用领域事件进行战术设计  111
设计、实现并运用领域事件  113
事件溯源  119
本章小结  121
第7章  加速和管理工具  123
事件风暴  124
其他工具  134
在敏捷项目中管理DDD  135
运用SWOT分析法  137
建模Spike和建模债务  139
任务识别与工作量估算  140
限制建模时间  143
如何实施  144
和领域专家打交道  145
本章小结  147
参考文献  148
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>领域驱动设计精粹
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring实战（第3版）
第一部分 Spring的核心
第1章 Spring之旅 2
1.1 简化Java开发 3
1.1.1 激发POJO的潜能 4
1.1.2 依赖注入 5
1.1.3 应用切面 9
1.1.4 使用模板消除样板式代码 13
1.2 容纳你的Bean 15
1.2.1 与应用上下文共事 16
1.2.2 Bean的生命周期 17
1.3 俯瞰Spring风景线 19
1.3.1 Spring模块 19
1.3.2 Spring Portfolio 22
1.4 Spring新功能 25
1.4.1 Spring 2.5新特性 26
1.4.2 Spring 3.0新特性 26
1.4.3 Spring Portfollo新特性 27
1.5 小结 28
第2章 装配Bean 29
2.1 声明Bean 30
2.1.1 创建Spring配置 30
2.1.2 声明一个简单Bean 31
2.1.3 通过构造器注入 33
2.1.4 Bean的作用域 37
2.1.5 初始化和销毁Bean 38
2.2 注入Bean属性 40
2.2.1 注入简单值 41
2.2.2 引用其他Bean 42
2.2.3 使用Spring的命名空间p装配属性 45
2.2.4 装配集合 46
2.2.5 装配空值 50
2.3 使用表达式装配 51
2.3.1 SpEL的基本原理 51
2.3.2 在SpEL值上执行操作 54
2.3.3 在SpEL中筛选集合 58
2.4 小结 62
第3章 最小化Spring XML配置 63
3.1 自动装配Bean属性 64
3.1.1 4种类型的自动装配 64
3.1.2 默认自动装配 68
3.1.3 混合使用自动装配和显式装配 68
3.2 使用注解装配 69
3.2.1 使用@Autowired 70
3.2.2 借助@Inject实现基于标准的自动装配 74
3.2.3 在注解注入中使用表达式 76
3.3 自动检测Bean 77
3.3.1 为自动检测标注Bean 78
3.3.2 过滤组件扫描 79
3.4 使用Spring基于Java的配置 80
3.4.1 创建基于Java的配置 80
3.4.2 定义一个配置类 81
3.4.3 声明一个简单的Bean 81
3.4.4 使用Spring的基于Java的配置进行注入 82
3.5 小结 83
第4章 面向切面的Spring 84
4.1 什么是面向切面编程 85
4.1.1 定义AOP术语 86
4.1.2 Spring对AOP的支持 88
4.2 使用切点选择连接点 90
4.2.1 编写切点 91
4.2.2 使用Spring的bean()指示器 92
4.3 在XML中声明切面 93
4.3.1 声明前置和后置通知 94
4.3.2 声明环绕通知 96
4.3.3 为通知传递参数 98
4.3.4 通过切面引入新功能 100
4.4 注解切面 102
4.4.1 注解环绕通知 104
4.4.2 传递参数给所标注的通知 105
4.4.3 标注引入 105
4.5 注入AspectJ切面 107
4.6 小结 109
第二部分 Spring应用程序的核心组件
第5章 征服数据库 112
5.1 Spring的数据访问哲学 113
5.1.1 了解Spring的数据访问异常体系 114
5.1.2 数据访问模板化 116
5.1.3 使用DAO支持类 118
5.2 配置数据源 119
5.2.1 使用JNDI数据源 119
5.2.2 使用数据源连接池 120
5.2.3 基于JDBC驱动的数据源 121
5.3 在Spring中使用JDBC 122
5.3.1 应对失控的JDBC代码 122
5.3.2 使用JDBC模板 125
5.4 在Spring中集成Hibernate 130
5.4.1 Hibernate概览 131
5.4.2 声明Hibernate的Session工厂 132
5.4.3 构建不依赖于Spring的Hibernate代码 134
5.5 Spring与Java持久化API 136
5.5.1 配置实体管理器工厂 136
5.5.2 编写基于JPA的DAO 140
5.6 小结 142
第6章 事务管理 144
6.1 理解事务 145
6.1.1 用4个词来表示事务 146
6.1.2 理解Spring对事务管理的支持 147
6.2 选择事务管理器 147
6.2.1 JDBC事务 149
6.2.2 Hibernate事务 149
6.2.3 Java持久化API事务 150
6.2.4 JTA(Java Transaction API)事务 151
6.3 在Spring中的编码事务 151
6.4 声明式事务 153
6.4.1 定义事务属性 154
6.4.2 在XML中定义事务 157
6.4.3 定义注解驱动的事务 159
6.5 小结 160
第7章 使用Spring MVC构建Web应用程序 162
7.1 Spring MVC起步 163
7.1.1 跟踪Spring MVC的请求 163
7.1.2 搭建Spring MVC 165
7.2 编写基本的控制器 166
7.2.1 配置注解驱动的Spring MVC 167
7.2.2 定义首页的控制器 168
7.2.3 解析视图 171
7.2.4 定义首页的视图 175
7.2.5 完成Spring应用上下文 177
7.3 处理控制器的输入 178
7.3.1 编写处理输入的控制器 179
7.3.2 渲染视图 181
7.4 处理表单 183
7.4.1 展现注册表单 183
7.4.2 处理表单输入 185
7.4.3 校验输入 187
7.5 处理文件上传 191
7.5.1 在表单上添加文件上传域 191
7.5.2 接收上传的文件 192
7.5.3 配置Spring支持文件上传 195
7.6 小结 196
第8章 使用Spring Web Flow 197
8.1 安装Spring Web Flow 198
8.1.1 在Spring中使用Web Flow 198
8.2 流程的组件 201
8.2.1 状态 201
8.2.2 转移 204
8.2.3 流程数据 205
8.3 组合起来：披萨流程 207
8.3.1 定义基本流程 207
8.3.2 收集顾客信息 211
8.3.3 构建订单 216
8.3.4 支付 219
8.4 保护Web流程 211
8.5 小结 221
第9章 保护Spring应用 223
9.1 Spring Security介绍 224
9.1.1 Spring Security起步 224
9.1.2 使用Spring Security配置命名空间 225
9.2 保护Web请求 226
9.2.1 代理Servlet过滤器 226
9.2.2 配置最小化的Web安全性 227
9.2.3 拦截请求 231
9.3 保护视图级别的元素 234
9.3.1 访问认证信息的细节 234
9.3.2 根据权限渲染 235
9.4 认证用户 237
9.4.1 配置内存用户存储库 238
9.4.2 基于数据库进行认证 239
9.4.3 基于LDAP进行认证 240
9.4.4 启用remember-me功能 244
9.5 保护方法调用 245
9.5.1 使用@Secured注解保护方法调用 245
9.5.2 使用JSR-250的@RolesAllowed注解 246
9.5.3 使用SpEL实现调用前后的安全性 246
9.5.4 声明方法级别的安全性切点 250
9.6 小结 251
第三部分 Spring集成
第10章 使用远程服务 254
10.1 Spring远程调用概览 255
10.2 使用RMI 257
10.2.1 发布一个RMI服务 257
10.2.2 装配RMI服务 260
10.3 使用Hessian和Burlap发布远程服务 262
10.3.1 使用Hessian和Burlap发布Bean的功能 263
10.3.2 访问Hessian/Burlap服务 266
10.4 使用Spring的HttpInvoker 267
10.4.1 将把Bean发布为HTTP服务 267
10.4.2 通过HTTP访问服务 269
10.5 发布和使用Web服务 270
10.5.1 创建JAX-WS端点 271
10.5.2 在客户端代理JAX-WS服务 275
10.6 小结 276
第11章 为Spring添加REST功能 277
11.1 了解REST 278
11.1.1 REST的基本原理 278
11.1.2 Spring是如何支持REST的 279
11.2 编写面向资源的控制器 279
11.2.1 剖析RESTless的控制器 280
11.2.2 处理RESTful URL 281
11.2.3 执行REST动作 284
11.3 表述资源 287
11.3.1 协商资源表述 287
11.3.2 使用HTTP信息转换器 290
11.4 编写REST客户端 293
11.4.1 了解RestTemplate的操作 295
11.4.2 GET资源 296
11.4.3 PUT资源 298
11.4.4 DELETE资源 300
11.4.5 POST资源数据 301
11.4.6 交换资源 303
11.5 提交RESTful表单 305
11.5.1 在JSP中渲染隐藏的方法域 306
11.5.2 发布真正的请求 307
11.6 小结 308
第12章 Spring消息 310
12.1 JMS简介 311
12.1.1 构建JMS 312
12.1.2 评估JMS的优点 314
12.2 在Spring中搭建消息代理 316
12.2.1 创建连接工厂 316
12.2.2 声明ActiveMQ消息目的地 317
12.3 使用Spring的JMS模板 318
12.3.1 处理失控的JMS代码 318
12.3.2 使用JMS模板 319
12.4 创建消息驱动的POJO 324
12.4.1 创建消息监听器 325
12.4.2 配置消息监听器 326
12.5 使用基于消息的RPC 327
12.5.1 使用Spring基于消息的RPC 328
12.5.2 使用Lingo实现异步RPC 330
12.6 小结 332
第13章 使用JMX管理Spring Bean 333
13.1 将Spring Bean导出为MBean 334
13.1.1 通过名称发布方法 337
13.1.2 使用接口定义MBean的操作和属性 339
13.1.3 使用注解驱动的MBean 340
13.1.4 处理MBean冲突 342
13.2 远程MBean 343
13.2.1 发布远程MBean 343
13.2.2 访问远程MBean 344
13.2.3 代理MBean 346
13.3 处理通知 347
13.3.1 监听通知 348
13.4 小结 349
第14章 其他Spring技巧 350
14.1 外部化配置 351
14.1.1 替换属性占位符 351
14.1.2 重写属性 354
14.1.3 加密外部属性 355
14.2 装配JNDI对象 357
14.2.1 JNDI的传统用法 357
14.2.2 装配JNDI对象 359
14.2.3 将EJB装配到Spring中 362
14.3 发送邮件 363
14.3.1 配置邮件发送器 363
14.3.2 构建邮件 365
14.4 调度和后台任务 370
14.4.1 声明调度方法 371
14.4.2 声明异步方法 372
14.5 小结 373
14.6 结束语 374
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring实战（第3版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>RESTful Web Services Cookbook中文版
前言 i
第1章 使用统一接口 1
1.1 如何保持交互的可见性 2
1.2 何时需要权衡可见性 4
1.3 如何维护应用程序状态 6
1.4 如何在服务器端实现安全和幂等的方法 9
1.5 如何在客户端处理安全和幂等方法 12
1.6 何时使用get方法 13
1.7 何时使用post方法 15
1.8 如何使用post方法创建资源 17
1.9 何时使用put方法创建新资源 19
1.10 如何使用post方法实现异步任务 20
1.11 如何使用delete方法实现异步删除 23
1.12 何时使用自定义http方法 24
1.13 何时及如何使用自定义http标头 26
第2章 识别资源 29
2.1 如何从领域名词中识别资源 30
2.2 如何选择资源粒度 31
2.3 如何将资源组织为集合 32
.2.4 何时将资源合并为复合资源 35
2.5 如何支持计算或处理函数 37
2.6 何时及如何使用控制器来操作资源 40
第3章 设计表述 45
3.1 如何使用实体头来注解表述 46
3.2 如何解释实体头 50
3.3 如何避免字符编码不匹配 51
3.4 如何选择表述格式和媒体类型 52
3.5 如何设计xml表述 56
3.6 如何设计json表述 58
3.7 如何设计集合表述 59
3.8 如何保持同构的集合 61
3.9 如何在表述中使用可移植的数据格式 63
3.10 何时使用实体标识符 65
3.11 如何在表述中编码二进制数据 66
3.12 何时以及如何提供html表述 68
3.13 如何返回错误 70
3.14 如何在客户端处理错误 74
第4章 设计uri 77
4.1 如何设计uri 77
4.2 如何将uri用做模糊标识符 81
4.3 如何让客户端将uri视为模糊标识符 83
4.4 如何保持酷的uri 85
第5章 web链接 88
5.1 如何在xml表述中使用链接 89
5.2 如何在json表述中使用链接 92
5.3 何时以及如何使用链接标头 93
5.4 如何分配链接关系类型 94
5.5 如何使用链接来管理应用程序的流程 97
5.6 如何处理临时uri 101
5.7 何时以及如何使用uri模板 103
5.8 如何在客户端使用链接 105
第6章 atom和atompub 108
6.1 如何利用atom建模资源 109
6.2 何时使用atom 113
6.3 如何使用atompub服务和分类文件 117
6.4 如何针对feed和entry资源使用atompub 119
6.5 如何使用媒体资源 122
第7章 内容协商 125
7.1 如何标明客户端偏好 126
7.2 如何实现媒体类型协商 128
7.3 如何实现语言协商 129
7.4 如何实现字符编码协商 131
7.5 如何支持压缩 132
7.6 何时以及如何发送vary头 133
7.7 如何处理协商失败 134
7.8 如何使用代理驱动的内容协商 136
7.9 何时支持服务器驱动的协商 137
第8章 查询 139
8.1 如何针对查询设计uri 139
8.2 如何设计查询响应 142
8.3 如何支持有大量输入的查询请求 144
8.4 如何存储查询 146
第9章 web缓存 149
9.1 如何设置过期缓存头 150
9.2 何时设置过期缓存头 153
9.3 何时以及如何在客户端中使用过期缓存头 156
9.4 如何支持复合资源的缓存 157
9.5 如何保持新鲜且温暖的缓存 158
第10章 条件请求 161
10.1 如何生成last-modified和etag头 163
10.2 如何在服务器端实现条件get请求 164
10.3 如何从客户端提交条件get和head请求 167
10.4 如何在服务器端实现条件put请求 169
10.5 如何在服务器端实现条件delete请求 173
10.6 如何从客户端发起无条件get请求 175
10.7 如何从客户端提交条件put和delete请求 176
10.8 如何使post请求条件化 178
10.9 如何生成一次性uri 181
第11章 其他内容 184
11.1 如何复制资源 185
11.2 如何合并资源 187
11.3 如何移动资源 189
11.4 何时使用webdav方法 191
11.5 如何支持跨服务器的操作 193
11.6 如何获取资源的快照 195
11.7 如何撤销资源更新 198
11.8 如何为部分更新提炼资源 200
11.9 如何使用patch方法 203
11.10 如何批量处理相似的资源 206
11.11 如何触发批量操作 209
11.12 何时使用post来合并多个请求 211
11.13 如何支持批量请求 215
11.14 如何支持事务 217
第12章 安全 220
12.1 如何使用基本身份验证来验证客户端 221
12.2 如何使用摘要身份验证来验证客户端 224
12.3 如何使用三方oauth 226
12.4 如何使用两方oauth 232
12.5 如何处理uri中的敏感信息 235
12.6 如何维护表述的机密性与完整性 237
第13章 可扩展性与版本控制 239
13.1 如何维持uri的兼容性 240
13.2 如何维持xml和json表述的兼容性 242
13.3 如何扩展atom 245
13.4 如何维持链接的兼容性 249
13.5 如何实现支持可扩展性的客户端 250
13.6 何时需要版本化 251
13.7 如何版本化restful web服务 252
第14章 服务发现 256
14.1 如何编写restful web服务的文档 256
14.2 如何使用options 259
附录a 辅助读物 261
附录b rest概述 265
附录c http方法 268
附录d atom syndication format 273
附录e 链接关系类型 279
索引 287
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>RESTful Web Services Cookbook中文版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>J2EE核心模式
第一部分 模式和J2EE
第1章 导论
什么是J2EE
什么是模式
历史回顾
模式的定义
模式的分类
J2EE模式目录
演化过程
怎样使用J2EE模式目录
使用模式的益处
模式、框架和重用
小结
第2章 表现层设计考虑和不佳实践
表现层设计考虑
会话管理
控制客户端访问
验证
助手类属性—完整性和一致性
表现层不佳实践
多个视图中都包括控制代码
把表现层的数据结构暴露给业务层
把表现层数据结构暴露给业务领域对象
允许重复提交表单
把敏感资源暴露给客户端的直接访问
假定 <jsp:setProperty> 会重置Bean属性
创建出“胖控制器”
把视图助手当成scriplet使用
第3章 业务层设计考虑和不佳实践
业务层设计考虑
使用session bean
使用entity bean
缓存EJB的远程引用和句柄
业务层和集成层不佳实践
把对象模型直接映射为entity bean模型
把关系型模型直接映射为entity bean模型
把每个用例映射为一个session bean
通过Getter/Setter方法暴露EJB的所有属性
在客户端中包括服务寻址代码
把entity bean当成只读对象使用
把entity bean当成细粒度对象使用
存储entity-bean的整个从属对象拓扑结构
把EJB相关的异常暴露给非EJB客户端
使用entity bean finder方法返回大型结果集
客户端负责聚合来自业务组件的数据
把EJB用于长时间持续的事务
每次调用无状态session bean都要重建
对话状态
第4章 J2EE重构
表现层的重构
引入控制器
引入同步器令牌
隔离不同逻辑
对业务层隐藏表现细节
去除视图中的转换
对客户端隐藏资源
业务层和集成层的重构
用session bean包装entity bean
引入业务代表
合并session bean
减少entity bean之间的通信
将业务逻辑移至session bean
一般的重构
分离数据访问代码
按层重构系统架构
使用连接池
第二部分 J2EE模式目录
第5章 J2EE模式概览
什么是模式
发现模式
模式 vs. 策略
分层思路
J2EE模式
表现层模式
业务层模式
集成层模式
J2EE模式目录指南
术语
UML的使用
模式模板
J2EE模式关系
与现有其他模式的关系
模式路线图
小结
第6章 表现层模式
拦截过滤器
问题
约束
解决方案
效果
相关模式
前端控制器
问题
约束
解决方案
效果
相关模式
Context对象
问题
约束
解决方案
效果
相关模式
应用控制器
问题
约束
解决方案
效果
相关模式
视图助手
问题
约束
解决方案
效果
相关模式
复合视图
问题
约束
解决方案
效果
示例代码
相关模式
服务到工作者
问题
约束
解决方案
效果
示例代码
相关模式
分配器视图
问题
约束
解决方案
效果
示例代码
相关模式
第7章 业务层模式
业务代表
问题
约束
解决方案
效果
示例代码
相关模式
服务定位器
问题
约束
解决方案
效果
示例代码
相关模式
会话门面
问题
约束
解决方案
效果
示例代码
相关模式
应用服务
问题
约束
解决方案
效果
示例代码
相关模式
业务对象
问题
约束
解决方案
效果
示例代码
相关模式
复合实体
问题
约束
解决方案
效果
示例代码
相关模式
传输对象
问题
约束
解决方案
效果
示例代码
相关模式
传输对象组装器
问题
约束
解决方案
效果
示例代码
相关模式
值列表处理器
问题
约束
解决方案
效果
示例代码
相关模式
第8章 集成层模式
数据访问对象
问题
约束
解决方案
效果
相关模式
服务激活器
问题
约束
解决方案
效果
相关模式
业务领域存储
问题
约束
解决方案
效果
相关模式
Web Service中转
问题
约束
解决方案
效果
相关模式
尾声
Web Worker微架构纵览
工作流简介
Web Worker微架构
问题
约束
解决方案
效果
参考书目
Apache软件授权协议，1.1版
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>J2EE核心模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>OSGi原理与最佳实践
第1章 OSGi简介  1
1.1 梦想中“即插即用”的系统 1
1.2 OSGi，拯救Java模块化的规范 1
1.3 厚积薄发的OSGi 2
1.4 OSGi基本概念 3
1.4.1 Bundle 3
1.4.2 Service 4
1.4.3 Service-Oriented Component Model（SOCM） 4
1.4.4 Declarative Service 6
1.4.5 部署 6
第2章 OSGi框架简介 7
2.1 Equinox 7
2.1.1 简介 7
2.1.2 环境搭建 7
2.1.3 HelloWorld 10
2.1.4 开发传统类型的应用 17
2.1.5 从外部启动Equinox 35
2.2 Felix 38
2.2.1 简介 38
2.2.2 环境搭建 38
2.2.3 应用的部署 38
2.2.4 在Eclipse中调试Felix 39
2.3 Spring-DM 43
2.3.1 简介 43
2.3.2 环境搭建 44
2.3.3 HelloWorld 48
2.3.4 Web版HelloWorld 51
第3章 基于Spring-DM实现Petstore 57
3.1 “即插即用”的Petstore 57
3.1.1 Petstore的功能需求 57
3.1.2 OSGi框架的功能和设计思想 58
3.1.3 Petstore的设计 60
3.2 新一代Petstore的实现 70
3.2.1 环境准备 70
3.2.2 Utils模块 72
3.2.3 Bootstrap模块 74
3.2.4 ProductDal模块 79
3.2.5 ShoppingCartDal模块 80
3.2.6 ProductList模块 81
3.2.7 ShoppingCart模块 85
3.2.8 ProductManagement模块 85
3.3 部署 85
3.4 Petstore的扩展 85
第4章 基于Apache CXF实现分布式Petstore 87
4.1 分布式OSGi 87
4.2 分布式Petstore的设计 87
4.3 Apache CXF简介 90
4.3.1 CXF-DOSGi HelloWorld 90
4.3.2 集成Spring-DM的CXF-DOSGi HelloWorld 95
4.4 分布式Petstore的实现 101
4.5 部署 105
第5章 构建OSGi Bundle Repository 107
5.1 OSGi Bundle Repository的使用 107
5.2 Apache Felix OBR的使用 110
5.2.1 命令行方式的用法 110
5.2.2 代码方式使用OBR 113
5.3 构建OSGi Bundle Repository 117
第6章 OSGi规范解读 119
6.1 OSGi规范发展历程 119
6.2 Core规范解读.. 120
6.2.1 Module Layer 120
6.2.2 LifeCycle Layer 129
6.2.3 Service Layer 132
6.3 OSGi SERVICE规范解读 133
6.3.1 Log Service 134
6.3.2 Http Service 137
6.3.3 Configuration Admin Service 139
6.3.4 Declarative Services 142
6.3.5 Event Admin Service 145
第7章 Equinox实现分析 149
7.1 模块化 149
7.1.1 加载并解析jar为Bundle 149
7.1.2 Bundle类共享及类加载机制 152
7.2 动态化 159
第8章 Felix实现分析 173
8.1 模块化 173
8.1.1 加载并解析jar为Bundle 173
8.1.2 Bundle类共享及类加载机制 174
8.2 动态化 177
第9章 Spring-DM实现分析 189
9.1 Spring Dynamic Module概述 189
9.2 Bean发布为OSGi服务实现分析 190
9.2.1 Extender Bundle启动 190
9.2.2 Bundle中的NamespaceHandler处理 192
9.2.3 ExtenderConfiguration处理 194
9.2.4 ApplicationContext处理 200
9.3 将OSGi Service引入为Bean 209
9.3.1 OSGi:service的处理 209
9.3.2 OSGi:set和OSGi:list的处理 211
9.4 将Bundle部署到Web服务器 214
9.4.1 WebExtender的启动 214
9.4.2 部署Bundle到Web服务器 215
第10章 CXF实现分析 217
10.1 Apache CXF-DOSGi实现分析 217
10.2 SingleBundle发行包 217
10.2.1 SingleBundle发行包的启动 218
10.3 把Bundle暴露为远程服务 221
10.3.1 DSW Bundle启动 221
10.3.2 RegisterDistributionProviderService 222
10.3.3 创建Hook对象及注册Listener 224
10.3.4 处理当前框架中的Bundle 225
10.3.5 发布远程服务 225
10.4 使用远程服务 231
10.4.1 Discovery Bundle启动 231
10.4.2 处理当前框架中的Bundle 232
10.4.3 注册远程服务的本地存根 234
第11章 先睹为快：OSGi R 4.2草稿版 237
11.1 Core 238
11.1.1 Module Layer 238
11.1.2 Lifecycle Layer 238
11.1.3 Service Layer 242
11.1.4 Framework API 243
11.2 Compendium 243
11.2.1 Declarative Services Specification 243
11.2.2 Deployment Admin Specification 244
11.2.3 Monitor Admin Service Specification 247
第12章 OSGi展望 251
12.1 Java企业应用领域 251
12.2 Java标准领域 252
12.3 OSGi R5 253
索引  255
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>OSGi原理与最佳实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>iOS软件开发揭密
第1章  iPhone开发环境设置	1
1.1  安装雪豹操作系统	2
1.2  安装iPhone SDK	5
1.3  无证书开发环境Xcode设置	7
1.4  有证书开发环境Xcode设置	11
1.5  安装源代码版本管理工具	12
1.6  安装Wine	12
1.7  使用Wine安装Source Insight	13
1.8  相关网络资源	14
第2章  Objective-C编程基础	15
2.1  Objective-C介绍	16
2.2  第一个iPhone程序	16
2.3  Objective-C基本类型	17
2.3.1  id	17
2.3.2  SEL	17
2.3.3  BOOL	18
2.3.4  nil、NULL和NSNull	18
2.4  常量声明和预处理宏	20
2.5  使用#import包含头文件	22
2.6  使用#pragma mark分隔代码块	22
2.7  Objective-C内存管理：retain和release	22
2.8  字符串操作	26
2.8.1  字符串常量	26
2.8.2  获取子字符串	27
2.8.3  合并和格式化字符串	28
2.8.4  分隔字符串	28
2.8.5  NSString和char*之间的转换	29
2.8.6  字符串比较	29
2.9  处理数值对象	30
2.10  处理日期时间NSDate	31
2.11  处理NSData类型	32
2.12  集合操作	32
2.12.1  数组操作：NSArray和NSMutableArray	32
2.12.2  字典操作：NSDictionary和NSMutableDictionary	42
2.12.3  集合操作：NSSet和NSMutableSet	47
2.12.4  堆栈操作	49
2.13  面向对象编程：类、实例和消息	50
2.13.1  类定义	50
2.13.2  类构造和构析函数	51
2.13.3  Singleton模式	53
2.13.4  @class、@protocol前向声明	53
2.13.5  self和super	54
2.13.6  实例方法和类方法	54
2.13.7  对象属性（@property）	55
2.13.8  静态属性（static attributes）	58
2.14  类扩展（Class Categories）	59
2.15  Objective-C接口编程	60
2.15.1  接口编程之@protocol	60
2.15.2  接口编程之后台线程	63
2.15.3  接口编程之Notifications	65
2.15.4  接口编程之NSOperationQueue	68
2.15.5  接口编程之私有方法	69
2.15.6  接口编程之静态库隐藏类	70
2.15.7  接口编程之@protocol封装类	72
2.15.8  接口稳定性和接口继承	73
2.16  定时器（NSTimer）编程	77
2.17  序列化和反序列化	78
2.17.1  序列化方法之Property List	78
2.17.2  序列化方法之NSKeyedArchiver	78
2.17.3  序列化方法之Core Data	79
2.18  Objective-C和C、C++混合编程	80
2.19  消息和NSInvocation	87
2.20  方法混合（Method Swizzling）	90
2.21  使用NSAssert进行代码调试	93
2.22  本章总结	93
2.23  参考书籍	93
第3章  iPhone SDK开发基础	95
3.1  iPhone SDK介绍	96
3.2  第一个iPhone 界面程序	99
3.3  iPhone程序启动过程	105
3.4  iPhone程序生命周期	107
3.5  掌握iPhone程序通信中心UIApplication和UIApplicationDelegate	110
3.6  iPhone坐标系统	111
3.7  UIView层次管理	116
3.8  触控（Touch）测试	120
3.9  多点触控（MultiTouch）和物体移动	122
3.10  UIView旋转和缩放	125
3.11  UIScrollView编程	127
3.12  iPhone程序框架	129
3.12.1  使用UINavigationController组织和管理UIView	130
3.12.2  使用UITabBarController组织和管理UIView	130
3.12.3  使用UISplitViewController组织和管理UIView	133
3.13  旋转屏幕（Screen Rotations）	135
3.14  掌握UIButton编程	138
3.15  管理界面字体	139
3.16  使用UILabel管理界面文本	141
3.17  管理界面颜色	143
3.18  界面风格（TRANSITIONING STYLES）	148
3.19  单词排序表格编程	149
3.20  NSUserDefaults和Property List文件	150
3.21  文件系统和外部资源管理	152
3.22  简单动画制作	155
3.23  闪屏制作——程序启动动画	157
3.24  多行文本输入控件制作	159
3.25  图片处理	162
3.26  Core Audio编程	163
3.27  UITableView编程	165
3.28  UISegmentedControl编程	167
3.29  OpenFlow编程	169
3.30  UIPageControl编程	172
3.31  自定义仪表控件	175
3.32  本章总结	180
第4章  iPhone SDK高级编程	181
4.1  Base64编解码	182
4.2  Web Service和XML数据解析	183
4.3  JSON数据解析	184
4.4  掌握SQLite管理用户数据	187
4.5  缓存（Caching）及Core Data数据管理	191
4.6  使用AES算法进行数据加解密	207
4.7  电子商务安全基础——RSA算法和数据加密	210
4.7.1  开发.NET版本RSA算法库	210
4.7.2  建立iPhone版本RSA算法库	217
4.8  自定义用户界面控件制作	220
4.8.1  ComboBox控件和UIPikerView设计	220
4.8.2  自定义UIDatePicker制作	224
4.9  UIWebView和JavaScript高级编程	229
4.10  本章总结	236
第5章  iPhone企业应用实例分析	237
5.1  综合应用概述	238
5.2  系统介绍	238
5.3  系统需求和主要用例	239
5.4  程序处理流程	241
5.5  主要实现类和相互关系	242
5.6  程序框架分析	244
5.7  技术要点分析	249
5.7.1  异步网络通信	249
5.7.2  Core Data缓存数据	252
5.7.3  RSA算法加解密	258
5.7.4  自定义控件制作	258
5.7.5  表格控件定制	260
5.7.6  自定义UIToolbar	266
5.7.7  目录浏览器制作	268
5.7.8  文件上传和下载	273
5.8  本章总结	277
第6章  iPad软件开发基础	279
6.1  iPad软件开发介绍	280
6.2  UISplitViewController编程	280
6.3  UIPopoverController编程	287
6.4  定制MPMoviePlayerController进行视频播放	290
6.5  开发调色板（Palette）控件	294
6.6  发送邮件	296
6.7  Google地图编程	297
6.8  本章总结	314
第7章  iPad商业软件实例分析	317
7.1  综合应用概述	318
7.2  系统介绍	318
7.3  系统需求和主要用例	319
7.4  程序处理流程	321
7.5  主要实现类和相互关系	321
7.6  程序框架	323
7.7  技术要点分析	335
7.7.1  图片分页和滚动显示	335
7.7.2  动态管理多国语言界面	340
7.7.3  播放网络视频	341
7.8  本章总结	344
第8章  iOS游戏开发基础	345
8.1  概述	346
8.2  cocos2d系统介绍	346
8.3  cocos2d编程基础	349
8.3.1  第一个cocos2d程序	349
8.3.2  基本动画	353
8.4  Box2D物理引擎	356
8.4.1  核心概念	356
8.4.2  碰撞检测	357
8.5  Chipmuck物理引擎	361
8.5.1  重要概念	361
8.5.2  物理模拟和碰撞检测	363
8.6  粒子系统	365
8.6.1  轨道卫星（Orbit Satellite）	366
8.6.2  太空陨石（Space Rocks）	367
8.7  本章总结	369
第9章  iOS商业游戏实例分析	371
9.1  概述	372
9.2  闪回（Flash Back）	372
9.3  法术的释放（Ghost Castle）	376
9.3.1  GhostCastle中的Tile Map管理	378
9.3.2  cocos2d中的Tile Map管理	381
9.4  甜蜜的梦（Sweet Dreams）	384
9.5  毁灭之战（RavagedByWar）	391
9.5.1  A*算法	392
9.5.2  毁灭之战中的A*算法实现	397
9.6  吹吹鱼（PuffPuff）	399
9.7  本章总结	403
第10章  iPhone软件发布	405
10.1  App Store概述	406
10.2  iPhone软件发布步骤	406
10.3  ipa安装包制作	410
10.4  iOS配置文件和Settings系统编程	411
10.5  本章总结	415
附录	417
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>iOS软件开发揭密
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>海量运维、运营规划之道
第1部分　质量
第1章　规划
1.1　架构规划
1.1.1　新趋势、新机遇、新挑战
1.1.2　产品、架构、成本的生命周期
1.1.3　质量、速度、成本
1.1.4　专业化、平台化、持续化
1.1.5　可伸缩、可调度、可扩展
1.1.6　Set模型，集装箱改变世界
1.1.7　全网调度，速度与容灾并进
1.1.8　海量导致架构取向，适用是王道
1.1.9　大系统简单做、小做
1.2　IDC规划
1.2.1　全球最复杂的基础网络
1.2.2　IDC属性、瓶颈分析及建议
1.2.3　IDC策略，分布制胜、速度第一
1.3　CDN规划
1.3.1　CDN发展现状与趋势分析
1.3.2　CDN厂商分析及外包细节
1.3.3　CDN节点分布及解析策略
1.3.4　CDN外包质量和风险控制
1.4　预算规划
1.4.1　预算的作用及预算推导
1.4.2　服务器定制，切合应用与性价比
1.4.3　服务器需求，用数据说话
第2章　速度
2.1　网站速度优化介绍
2.1.1　什么是网站速度优化
2.1.2　网站速度优化的价值
2.1.3　网站速度关键指标
2.1.4　影响网站速度的因素
2.2　网站速度监测实践
2.2.1　网站速度监测概述
2.2.2　网站速度主动监测
2.2.3　网站速度被动监测
2.3　网站速度分析实践
2.3.1　网站速度分析概述
2.3.2　网站速度分析工具
2.3.3　网站速度分析案例
2.4　网站速度优化实践
2.4.1　网站速度优化概述
2.4.2　网络速度优化及案例
2.4.3　系统速度优化及案例
2.4.4　前端速度优化及案例
2.5　防止网站速度退化
2.5.1　通过规范防止速度退化
2.5.2　通过工具防止速度退化
第3章　监控
3.1　监控概述
3.1.1　监控定义和价值
3.1.2　监控体系和实现途径
3.2　用户监控实践
3.2.1　访问监控，获取用户访问速度
3.2.2　URL监控，服务实时访问状态
3.2.3　劫持监控，了解全国劫持状态
3.2.4　内容监控，掌握网页元素变化
3.3　机器监控实践
3.4　网络监控实践
3.4.1　网络监控，时刻掌控广域网变化
3.4.2　响应监控，IDC内服务响应监控
3.4.3　域名监控，做精准的DNS解析
3.5　应用监控实践
3.5.1　模块监控，动态应用模块监控
3.5.2　数据库监控，数据库运行可视化
第4章　告警
4.1　告警概述
4.1.1　告警定义和途径
4.1.2　告警问题和规避方法
4.2　告警模型
4.2.1　告警分类，将告警分类区分对待
4.2.2　告警模型，如何建立告警模型
4.3　告警优化
4.3.1　告警收敛，规避被告警淹没
4.3.2　告警关联，让告警更具价值
4.3.3　告警分析，用数据说话
第5章　安全
5.1　Web漏洞扫描
5.2　域名劫持扫描
5.3　DDoS攻击扫描
5.4　敏感信息扫描
5.5　网页篡改扫描
第2部分　效率
第6章　管理
6.1　配置管理，标识所有的资源并记录在册
6.2　事件管理，记录、分类、诊断、解决问题
6.3　问题管理，消除引起问题的根本原因
6.4　变更管理，串联变更原因、过程、结果
6.5　容量管理，对运营指标未来的量化、预测
第7章　流程
7.1　业务运维管理规范
7.2　系统用户管理规范
7.3　设备使用管理规范
7.4　应用安全管理规范
7.5　开发与编译环境安全规范
7.6　故障分级和处罚规范
第8章　预案
8.1　预案，从容有序应对危机
8.2　预演，提高故障执行力
第9章　考核
9.1　运维能力考核
9.2　架构能力考核
9.3　运营预算考核
第3部分　成本
第10章　基础
10.1　规模化导致运营成本凸显
10.2　运营成本优化方向和策略
10.3　工具协助成本可持续优化
第11章　设备
11.1　服务器分类、分级、分层定制
11.2　业务分类平台化减少运营成本
11.3　混布最大限度提高资源利用率
第12章　带宽
12.1　通过改变产品形态减少数百万成本
12.2　通过降低带宽单价减少成本
12.3　通过自动优化减少带宽成本
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>海量运维、运营规划之道
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>SOA实践指南
前言
第1章：动机
1.1 大型分布式系统的特征
1.2 魔术总线故事
1.3 魔术总线故事给我们的启示
1.4 SOA历史
1.5 五页幻灯讲完SOA
第2章：SOA
2.1 SOA定义
2.2 SOA驱动因素
2.3 SOA概念
2.4 SOA要素
2.5 SOA不是银弹
2.6 SOA不是特定技术
2.7 对比SOA与分布式对象
2.8 SOA术语
2.9 总结
第3章：服务
3.1 服务
3.2 接口和契约
3.3 额外的服务特性
3.4 总结
第4章：松耦合
4.1 对容错的需求
4.2 松耦合的形式
4.3 处理松耦合
4.4 总结
第5章：企业服务总线
5.1 ESB职责
5.2 异质的ESB
5.3 ESB的差异
5.4 ESB增值服务
5.5 总结
第6章：服务分类
6.1 基础服务分类
6.2 基本服务
6.3 组合服务
6.4 流程服务
6.5 其他服务分类法
6.6 技术服务和基础设施服务
6.7 服务之外
6.8 总结
第7章：业务流程管理
7.1 BPM术语
7.2 BPM和SOA
7.3 用于服务的BPM的例子
7.4 业务流程建模
7.5 识别服务的其他方法
7.6 配制和编排
7.7 更多思考
7.8 总结
第8章：SOA和组织
8.1 角色和组织
8.2 出资模型
8.3 总结
第9章：上下文环境中的SOA
9.1 基于SOA的架构模型
9.2 处理前端和后端
9.3 总结
第10章：消息交换模式
10.1 MEP简介
10.2 基本MEP
10.3 更复杂的MEP
10.4 处理可靠性和错误
10.5 处理不同MEP层
10.6 事件驱动的架构
10.7 总结
第11章：服务生命周期
11.1 开发中的服务
11.2 生产中的服务
11.3 总结
第12章：版本划分
12.1 版本划分需求
12.2 领域驱动的版本划分
12.3 数据类型的版本划分
12.4 配置管理驱动的版本划分
12.5 实践中的版本划分
12.6 总结
第13章：SOA和性能
13.1 性能在哪儿重要
13.2 从远程存储过程到服务
13.3 性能和可重用性
13.4 性能和向后兼容性
13.5 总结
第14章：SOA和安全
14.1 安全需求
14.2 处理安全需求
14.3 实践中的SOA安全.
14.4 XML和Web Services的安全
14.5 安全问题何时凸现
14.6 总结
第15章：技术细节
15.1 服务和状态
15.2 幂等性
15.3 测试和调试
15.4 处理技术性数据（头数据）
15.5 数据类型
15.6 错误处理
15.7 总结
第16章：Web Services
16.1 使用Web Services的动机
16.2 基础Web Services标准
16.3 实践中的Web Services
16.4 结束按语
16.5 总结
第17章：服务管理
17.1 服务中间人的历史
17.2 业务库和注册中心
17.3 总结
第18章：模型驱动的服务开发
18.1 生成的服务代码
18.2 建模服务
18.3 实践中的元模型
18.4 建立MDSD过程
18.5 工具
18.6 避免瓶颈
18.7 总结
第19章：建立SOA和SOA监管
19.1 引入SOA
19.2 SOA监管
19.3 按部就班SOA
19.4 其他SOA方法
19.5 其他建议
19.6 总结
第20章：后记
20.1 SOA是新东西吗？
20.2 SOA增加了复杂性吗？
20.3 SOA关键的成功要素是什么？
20.4 SOA在哪些地方不合适？
20.5 SOA替代了OOP吗？
参考文献
词汇表
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>SOA实践指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>构建高可用Linux服务器
推荐序一
推荐序二
推荐序三
前言
第1章　Linux服务器构建基础/1
1.1　Linux服务器的安装方法/2
1.1.1　光盘安装Centos5.5 x86_64/2
1.1.2　使用PXE+DHCP+Apache+KickStart无人值守安装RHEL/12
1.1.3　Linux的其他安装方法/17
1.2　全面了解Linux服务器/18
1.2.1　查看Linux服务器的CPU详细情况/18
1.2.2　查看Linux服务器的内存使用情况/19
1.2.3　查看Linux服务器的硬盘使用情况/20
1.2.4　查看Linux系统的平均负载/24
1.2.5　查看Linux系统的其他参数/25
1.3　Linux服务器的网络配置/28
1.3.1　配置Linux服务器的网络/28
1.3.2　查看Linux服务器的网络连接/31
1.3.3　查看Linux服务器的进程/39
1.3.4　在Centos5.5、FreeBSD8.1及Windows下添加静态路由/43
1.4　Linux服务器的日志管理/45
1.4.1　系统日志syslog.conf的配置详解/46
1.4.2　Linux下的日志维护技巧/47
1.4.3　用shell脚本分析Nginx日志/51
1.5　Linux服务器的优化/53
1.5.1　根据服务器应用来选购服务器/54
1.5.2　Centos5.5最小化安装后的优化/58
1.5.3　优化Linux下的内核TCP参数以提高系统性能/63
1.5.4　生产服务器应尽量选择编译安装软件包/65
1.6　用开源工具Nagios监控Linux服务器/66
1.6.1　Centos5.5下的监控工具简介/66
1.6.2　Nagios应该监控的服务器基础选项/67
1.6.3　Nagios监控Windows 2003时应注意的事项/67
1.6.4　用Nagios监控Nginx脚本/68
1.6.5　Nagios使用心得/74
1.7　项目实施中应该注意的事项/75
1.8　小结/77
第2章　FreeBSD8.1在企业中的部署应用/78
2.1　最小化安装FreeBSD8.1/79
2.2　最小化安装FreeBSD8.1后的升级优化部署/90
2.2.1　最小化安装FreeBSD8.1服务器后建议做的事/90
2.2.2　系统管理员应该知道的FreeBSD8.1的一些事项/95
2.2.3　在FreeBSD8.1下高效地安装和卸载软件/99
2.2.4　查看FreeBSD8.1的硬件配置/100
2.3　在FreeBSD8.1下部署jail虚拟机/103
2.3.1　FreeBSD8.1下的jail概述/103
2.3.2　FreeBSD8.1下安装jail的详细步骤/104
2.3.3　FreeBSD8.1下jail的管理/105
2.3.4　通过ezjail来创建和管理jail虚拟机/106
2.3.5　jail在生产环境下的注意事项/109
2.4　在FreeBSD8.1下搭建版本控制服务器/109
2.4.1　版本控制软件的概念/109
2.4.2　在FreeBSD8.1下搭建CVS服务器/109
2.4.3　在FreeBSD8.1下搭建SVN服务器/113
2.4.4　在FreeBSD8.1下搭建Git服务器/117
2.5　在FreeBSD8.1下搭建Samba文件服务器/121
2.5.1　Samba概述/121
2.5.2　在FreeBSD8.1下安装配置Samba3.4/121
2.5.3　Samba的详细语法配置/122
2.5.4　Samba在工作中的总结/124
2.5.5　Linux下的高级权限文件控制/125
2.5.6　Samba在企业开发环境中的常用案例之一/127
2.5.7　Samba在企业开发环境中的应用案例之二/128
2.6　在FreeBSD8.1下配置NFS文件服务器/131
2.7　在FreeBSD8.1与Centos5.5下搭建rsync服务器/134
2.7.1　rsync的概念/134
2.7.2　在Centos5.5下配置rsync服务器/134
2.7.3　在FreeBSD8.1下配置rsync服务器/138
2.7.4　rsync+Inotify实现数据的实时同步更新/140
2.8　在FreeBSD8.1下搭建vsftpd服务器/143
2.8.1　vsftpd服务器的特点/143
2.8.2　vsftpd的运行模式/144
2.8.3　vsftpd的数据连接模式/144
2.8.4　vsftpd到底安全在哪里/145
2.8.5　在FreeBSD8.1下配置vsftpd服务器/146
2.8.6　用vsftpd作Linux/Unix之间的异地备份/147
2.9　在FreeBSD8.1和Centos5.5下搭建PHP和Java应用环境/149
2.9.1　在FreeBSD8.1下搭建FAMP环境/149
2.9.2　在生产环境下配置LNMP环境/152
2.9.3　在Centos5.5下搭建Java运行环境/172
2.10　小结/176
第3章　Linux服务器虚拟化/177
3.1　在Windows Server 2003下安装VMware GSX Server/178
3.2　用Windows 2003+VMware Server搭建64位系统测试环境/181
3.3　在Centos5.6 x86_64下安装Xen虚拟机/183
3.3.1　XEN在Centos5.6 x86_64下的安装步骤/183
3.3.2　XEN虚拟机的优势/185
3.4　XEN在生产环境下的应用/185
3.4.1　XEN虚拟化的基本概念/185
3.4.2　在Centos5.5下安装XEN虚拟机/187
3.4.3　安装第一台虚拟机(模板机)/189
3.4.4　XEN寄宿服务器的管理/191
3.4.5　XEN在生产环境下的应用/194
3.5　Citrix XenServer5.6虚拟机试用手记/196
3.6　小结/202
第4章　生产环境下服务器的故障诊断与排除/203
4.1　快速排障的重要性和必要性/204
4.2　安装系统时容易发生的错误描述与处理方法/204
4.2.1　忘记了Centos5.5的root密码怎么办/204
4.2.2　正确重设root密码/206
4.2.3　安装FreeBSD8.1时不要设置/boot分区/207
4.2.4　Centos5.5的Grub引导程序出错/207
4.2.5　安装Centos5.5时忘了关闭iptables和SELinux/208
4.2.6　如何解决Putty或PieTTY的乱码问题/209
4.2.7　安装双系统时不小心删除了Grub所在的分区/209
4.3　网络配置时容易发生的错误描述与处理方法/211
4.3.1　安装Centos5.5时忘了激活网卡/211
4.3.2 　Centos5.5网卡文件备份的正确方法/212
4.3.3　解决远程桌面超出最大连接数的问题/213
4.3.4　在Centos5.5下如何正确配置网关/214
4.3.5　VMware的机器应该如何配置自动对时/214
4.3.6　防火墙初始化的注意事项/215
4.4　系统维护时的注意事项/215
4.4.1　尽量源码安装，谨慎操作yum/215
4.4.2　服务器硬件改动进入了Emergency模式/216
4.4.3　如何以普通用户的身份编辑无权限的文件/216
4.4.4　在Linux下配置最大文件打开数的方法/216
4.4.5　在Crontab下运行PHP程序的正确方法/218
4.4.6　在Crontab下正确防止脚本运行冲突/218
4.5　紧急处理线上服务器故障的办法/219
4.5.1　更改Administrator密码导致计划任务无法执行/219
4.5.2　FreeBSD8.1下的sudoer文件意外损坏/219
4.5.3　Centos5.5的root密码被恶意篡改/219
4.5.4　bash损坏该如何正确处理/220
4.5.5　正确操作nohup让程序始终在后台运行/221
4.5.6　负载均衡器出现故障/221
4.6　检查机房应注意的位置和细节问题/221
4.7　系统维护时应注意的非技术因素/222
4.8　小结/222
第5章　生产环境下的SHELL脚本/223
5.1　Vim的基础用法及进阶心得/224
5.2　Sed的基础用法及实用举例/228
5.2.1　Sed的基础语法格式/228
5.2.2　Sed的用法举例说明/230
5.3　基础正则表达式/235
5.4　Linux下强大的查找命令find/240
5.5　汇总Linux/Unix下的bash快捷键/248
5.6　生产环境下的SHELL脚本分类/249
5.6.1　生产环境下的SHELL脚本备份类/250
5.6.2　生产环境下的开发类SHELL脚本/257
5.6.3　生产环境下的统计类SHELL脚本/259
5.6.4　生产环境下的监控类SHELL脚本/262
5.6.5　生产环境下的自动化类SHELL脚本/265
5.6.6　生产环境下的安全类SHELL脚本/269
5.7　小结/272
第6章　构建高可用的Linux集群/273
6.1　负载均衡高可用的核心概念和常用软件/274
6.1.1　什么是负载均衡高可用/274
6.1.2　以F5 BIG-IP作为负载均衡器/275
6.1.3　以LVS作为负载均衡器/275
6.1.4　以Nginx作为负载均衡器/281
6.1.5　以HAProxy作为负载均衡器/281
6.1.6　高可用软件Keepalived/283
6.1.7　高可用软件Heartbeat/283
6.1.8　高可用块设备DRBD/284
6.2　负载均衡中的名词解释/285
6.2.1　什么是Session/285
6.2.2　什么是Session共享及实现的方法/285
6.2.3　什么是会话保持/286
6.3　负载均衡器的会话保持机制/287
6.3.1　F5 Big-IP的会话保持机制/287
6.3.2　LVS的会话保持机制/288
6.4　Linux集群的项目案例分享/299
6.4.1　项目案例一：用Nginx+Keepalived实现在线票务系统/299
6.4.2　项目案例二：企业级Web负载均衡高可用之Nginx+Keepalived/302
6.4.3　项目案例四：用LVS+Keepalived构建高可用JSP集群/313
6.4.4　项目案例五：生产环境下的高可用NFS文件服务器/322
6.4.5　项目案例六：HAProxy双机高可用方案之HAProxy+Heartbeat/331
6.5　项目实践中Linux集群的总结和思考/336
6.6　网站架构应关注和研究的方向/338
6.7　MySQL数据库的优化/339
6.7.1　服务器物理硬件的优化/339
6.7.2　MySQL应该采用编译安装的方法/340
6.7.3　MySQL配置文件的优化/340
6.7.4　MySQL上线后根据status状态进行适当优化/346
6.7.5　MySQL数据库的可扩展性架构方案/352
6.7.6　MySQL数据库的Replication高可用架构/352
6.7.7　MySQL Cluster集群配置方案/354
6.7.8　生产环境下的MySQL数据库主从Replication同步/360
6.7.9　可扩展性设计之数据切分/368
6.8　生产环境下的MySQL数据库备份/369
6.9　部分项目施工图纸/372
6.10　小结/374
第7章　VPN在企业中的部署应用/375
7.1　流行的VPN技术及其分类/376
7.2　如何选择自己需要的VPN/378
7.3　IPSec VPN的不足/378
7.4　OpenVPN的应用范畴/379
7.5　经典企业VPN部署案例/379
7.5.1　案例一：在Centos5.5 x86_64下单网卡配置PPTPD服务器/379
7.5.2　案例二：在Centos5.5 x86_64下路由模式配置OpenVPN服务器/386
7.5.3　案例三：在FreeBSD8 x86_64下网桥模式配置OpenVPN服务器/396
7.6　部署OpenVPN服务器的注意事项/402
7.6.1　OpenVPN如何注销用户/402
7.6.2　OpenVPN服务器的安全问题/403
7.6.3　OpenVPN服务器的负载均衡/404
7.7　小结/404
第8章　Linux防火墙及系统安全篇/405
8.1　基础网络知识/406
8.1.1　OSI网络参考模型/406
8.1.2　TCP/IP三次握手/四次挥手的过程详解/407
8.1.3　其他基础网络知识/409
8.2　Linux防火墙的概念/409
8.3　Linux防火墙在企业中的作用/410
8.4　Linux防火墙的语法/410
8.5　iptables的基础知识/414
8.5.1　iptables的状态state/414
8.5.2　iptables的Conntrack记录/416
8.5.3　关于iptables模块的说明/416
8.5.4　iptables防火墙初始化的注意事项/416
8.5.5　如何保存运行中的iptables规则/417
8.6　如何流程化编写iptables脚本/418
8.7　学习iptables应该掌握的工具/420
8.7.1　命令行的抓包工具TCPDump/420
8.7.2　图形化抓包工具Wireshark/421
8.7.3　强大的命令行扫描工具Nmap/424
8.7.4　安全工具hping/426
8.8　iptables的简单脚本学习/428
8.8.1　普通的Web主机防护脚本/429
8.8.2　如何让别人ping不到自己而自己能ping通别人/430
8.8.3　建立安全的vsftpd服务器/432
8.9　线上生产服务器的iptables脚本/436
8.9.1　安全的主机iptables防火墙脚本/437
8.9.2　自动分析黑名单及白名单的iptables脚本/439
8.9.3　利用recent模块限制同一IP的连接数/441
8.9.4　利用DenyHosts工具和脚本来防止SSH暴力破解/444
8.9.5　将iptables作为企业的NAT路由器/448
8.9.6　如何使用工具精确地监控NAT路由器/451
8.10　TCP_wrappers应用级防火墙的介绍和应用/458
8.11　工作中的Linux防火墙总结/460
8.12　Linux系统自身的安全防护/461
8.12.1　SELinux简介/461
8.12.2　SELinux的相关设置/461
8.13　Linux系统安全相关的工具/462
8.13.1　Rootkit检测工具Chkrootkit/462
8.13.2　文件系统完整性检查工具Tripwire/464
8.13.3　防恶意扫描软件PortSentry/470
8.14　Linux服务器基础防护篇/474
8.15　如何防止入侵/475
8.16　小结/476
第9章　如何构建开源免费的企业级邮件系统/477
9.1　DNS服务器的架设/478
9.1.1　邮件服务器与DNS的关系/478
9.1.2　如何架设内部DNS服务器/480
9.1.3　如何以源码方式安装公网DNS服务器/487
9.1.4　维护DNS服务器应该注意的事项/494
9.2　电子邮件的传输过程/496
9.3　如何搭建开发邮件服务器/498
9.3.1　搭建Sendmail+Dovecot邮件系统/498
9.3.2　搭建Postfix+Dovecot邮件系统/501
9.4　搭建iRedmail企业级邮件服务器/504
9.4.1　iRedmail企业级邮件服务器的介绍/504
9.4.2　在Centos5.2 x86_64上安装iRedmail0.4.0/505
9.4.3　Postfix本身的防垃圾功能/508
9.4.4　iRedmail0.4.0特有的防垃圾技术/513
9.4.5　iRedmail0.4.0是如何利用ClamAV防病毒的/517
9.4.6　iRedmail0.4.0邮件服务器的网络安全/517
9.4.7　iRedmail0.4.0邮件服务器系统的监控/520
9.4.8　iRedmail0.4.0的系统文件备份/522
9.4.9　iRedmail0.4.0的MySQL数据库备份方案/526
9.4.10　维护iRedmail0.4.0邮件服务器的一些注意事项/532
9.5　小结/533
第10章　系统管理员在企业中的职业定位及发展方向/534
10.1　系统管理员的概念和工作职责/535
10.2　系统管理员应该熟悉的系统/536
10.3　系统管理员应该熟悉的工具/540
10.4　Linux的学习及进阶之路/544
10.5　系统管理员应该如何工作/547
10.6　给Linux/Unix新人的建议/549
10.7　系统管理员之企业生存守则/550
10.8　小结/553
附录A　Xmanager 3.0企业版实用技巧集锦/554
附录B　使用Screen管理远程会话/564
附录C　自动化部署管理工具Puppet/566
附录D　漫谈CDN系统运维与电子商务运维/572
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>构建高可用Linux服务器
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高扩展性网站的50条原则
目　 　 录
第1章　 化简方程　 　 1
1.1　 原则1：不要过度设计　 　 2
1.2　 原则2：设计时就考虑扩展性（D-I-D方法）　 　 6
1.2.1　 设计　 　 7
1.2.2　 实现　 　 8
1.2.3　 部署　 　 8
1.3　 原则3：把方案一简再简　 　 10
1.3.1　 如何简化范围　 　 10
1.3.2　 如何简化设计　 　 11
1.3.3　 如何简化实施　 　 12
1.4　 原则4：减少DNS查找　 　 13
1.5　 原则5：尽可能减少对象　 　 16
1.6　 原则6：使用同一品牌的网络设备　 　 19
1.7　 小结　 　 21
参考资料　 　 21
第2章　 分布工作　 　 23
2.1　 原则7：横向复制（X轴原则）　 　 25
2.2　 原则8：拆分不同的东西（Y轴原则）　 　 29
2.3　 原则9：拆分相近的东西（Z轴原则）　 　 32
2.4　 小结　 　 34
参考资料　 　 34
第3章　 横向扩展设计　 　 35
3.1　 原则10：设计横向扩展方案　 　 36
3.2　 原则11：采用经济型系统　 　 39
3.3　 原则12：横向扩展数据中心　 　 42
3.4　 原则13：利用云技术进行设计　 　 48
3.5　 小结　 　 50
参考资料　 　 50
第4章　 使用正确的工具　 　 51
4.1　 原则14：合理使用数据库　 　 52
4.2　 原则15：防火墙，到处都是防火墙　 　 59
4.3　 原则16：积极利用日志文件　 　 63
4.4　 小结　 　 66
参考资料　 　 66
第5章　 不要重复工作　 　 67
5.1　 原则17：不要立即检查刚做过的工作　 　 68
5.2　 原则18：停止重定向　 　 72
5.3　 原则19：放松时序约束　 　 77
5.4　 小结　 　 80
参考资料　 　 80
第6章　 积极利用缓存　 　 81
6.1　 原则20：利用CDN　 　 82
6.2　 原则21：使用过期头　 　 85
6.3　 原则22：缓存Ajax调用　 　 90
6.4　 原则23：利用页面缓存　 　 95
6.5　 原则24：利用应用缓存　 　 98
6.6　 原则25：利用对象缓存　 　 102
6.7　 原则26：把对象缓存放在自己的“层”上　 　 105
6.8　 小结　 　 107
参考资料　 　 107
第7章　 从错误中吸取教训　 　 109
7.1　 原则27：积极地学习　 　 110
7.2　 原则28：不要依靠QA发现失误　 　 113
7.3　 原则29：没有回退功能的设计是失败的设计　 　 117
7.4　 原则30：讨论失败并从中吸取教训　 　 120
7.5　 小结　 　 124
参考资料　 　 124
第8章　 数据库原则　 　 125
8.1　 原则31：注意代价高的关系　 　 126
8.2　 原则32：使用类型正确的数据库锁　 　 130
8.3　 原则33：不要使用多阶段提交　 　 133
8.4　 原则34：不要使用SELECT FOR UPDATE　 　 135
8.5　 原则35：不要选择所有数据　 　 137
8.6　 小结　 　 140
参考资料　 　 140
第9章　 容错设计与故障控制　 　 141
9.1　 原则36：采用隔离故障的“泳道”　 　 142
9.2　 原则37：绝对不要信任单点故障　 　 148
9.3　 原则38：避免系统串联　 　 151
9.4　 原则39：确保能够启用/禁用功能　 　 155
9.5　 小结　 　 158
第10章　 避免或分发状态　 　 159
10.1　 原则40：努力实现无状态　 　 161
10.2　 原则41：尽可能在浏览器端维护会话　 　 164
10.3　 原则42：利用分布式缓存存放状态　 　 167
10.4　 小结　 　 170
参考资料　 　 170
第11章　 异步通信和消息总线　 　 171
11.1　 原则43：尽可能使用异步通信　 　 172
11.2　 原则44：确保消息总线能够扩展　 　 175
11.3　 原则45：避免让消息总线过度拥挤　 　 179
11.4　 小结　 　 182
第12章　 其他原则　 　 183
12.1　 原则46：慎用第三方解决方案扩展　 　 184
12.2　 原则47：清除、归档和成本合理的存储　 　 187
12.3　 原则48：删除事务处理中的商业智能　 　 192
12.4　 原则49：设计能够监控的应用　 　 195
12.5　 原则50：要能胜任　 　 199
12.6　 小结　 　 202
参考资料　 　 202
第13章　 原则回顾和优先级划分　 　 203
13.1　 评估扩展项目和主动权的风险?收益模型　 　 204
13.2　 扩展原则的收益/优先级等级　 　 235
13.3　 小结　 　 238
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高扩展性网站的50条原则
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>J2EE设计开发编程指南
第1章 J2EE体系结构
第2章 J2EE项目的选择与风险
第3章 J2EE应用的测试
第4章 J2EE项目的设计技术与编程标准
第5章 示例应用的需求
第6章 应用J2EE技术
第7章 J2EE应用中的数据存取
第8章 使用实体组件进行数据存取
第9章 实际的数据存取
第10章 会话组件
第11章 基础结构与应用实现
第12章 Web层的MVC设计
第13章 Web层中的视图
第14章 应用的包装与部署
第15章 应用的性能测试与调整
第16章 结论：让J2EE为我所用
附录A 实现视图技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>J2EE设计开发编程指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>24小时365天不间断服务
第1章　服务器及基础设施搭建入门
冗余及负载分流的基础　　1
1.1　冗余的基础　　2
1.1.1　冗余概述　　2
1.1.2　冗余的本质　　2
①设想可能发生的故障　　2
②预先准备好备份设备　　3
③部署工作机制……当故障发生时，切换到备份设备　　3
1.1.3　应对路由器故障的情况　　4
冷备份　　4
1.1.4　应对Web服务器故障的情况　　4
热备份　　5
1.1.5　故障转移　　6
VIP　　6
IP地址的映射　　6
1.1.6　检测故障……健康检查　　7
Web服务器的健康检查　　8
路由器的健康检查　　8
1.1.7　搭建Active/Backup的拓扑结构　　8
IP地址的映射操作　　10
1.1.8　还想更有效地使用服务器……负载分发　　10
1.2　实现Web服务器的冗余……DNS轮询　　12
1.2.1　DNS轮询　　12
1.2.2　DNS轮询的冗余拓扑结构示例　　13
1.2.3　还想更轻松地扩充系统……负载均衡器　　16
1.3　实现Web服务器的冗余……基于IPVS的负载均衡器　　17
1.3.1　DNS轮询与负载均衡器的不同点　　17
1.3.2　IPVS……基于Linux的负载均衡器　　18
负载均衡器的种类与IPVS的功能　　18
1.3.3　调度算法　　18
1.3.4　使用IPVS　　20
ipvsadm　　20
keepalived　　20
1.3.5　搭建负载均衡器　　21
配置Web服务器　　22
启动keepalived　　23
确认负载分流　　23
确认冗余的拓扑结构　　24
1.3.6　四层交换机与七层交换机　　24
1.3.7　四层交换机的NAT模型与DSR模型　　26
1.3.8　同一子网下的服务器进行负载分流时需要注意的地方　　28
1.4　路由器及负载均衡器的冗余　　30
1.4.1　负载均衡器的冗余　　30
1.4.2　虚拟路由器冗余协议（VRRP）　　30
1.4.3　VRRP的拓扑模型　　30
VRRP报文　　31
虚拟路由器ID　　32
优先顺序　　32
抢占模式　　33
虚拟MAC地址　　33
1.4.4　安装keepalived时可能遇到的问题　　34
延迟发送gratuitous ARP（GARP）　　34
1.4.5　keepalived的冗余　　35
确认VIP　　36
确认VRRP的运行情况　　37
分离VRRP实例　　37
同步VRRP实例　　38
1.4.6　keepalived的应用　　38
第2章　优化服务器及基础设施的拓扑结构
冗余、负载分流、高性能的实现　　39
2.1　引入反向代理……Apache模块 　　40
2.1.1　反向代理入门　　40
2.1.2　根据HTTP请求的内容来控制系统的行为　　41
根据IP地址进行控制　　42
根据User-Agent进行控制　　42
网址的重写　　42
2.1.3　优化系统整体的内存使用率　　43
例：动态页面中的请求详情　　43
2.1.4　缓存Web服务器的应答数据　　45
HTTP的Keep-Alive　　45
例：内存消耗与Keep-Alive的开启/关闭　　46
2.1.5　使用Apache模块控制处理规则　　47
增设反向代理的判断　　48
2.1.6　增设反向代理　　48
使用Apache 2.2　　48
以worker模式启动httpd　　49
httpd.conf的配置　　49
设定最大进程/线程数　　49
Keep-Alive的配置　　51
载入必要的模块　　52
设定RewriteRule 　　52
2.1.7　进一步对RewriteRule进行设置　　53
禁止来自特定主机的请求　　54
对于来自搜索引擎机器人的请求使用缓存服务器　　54
2.1.8　使用mod_proxy_balancer向多台主机分流　　55
mod_proxy_balancer的使用示例　　56
2.2　增设缓存服务器……Squid、memcached 　　58
2.2.1　引入缓存服务器　　58
HTTP与缓存　　58
通过Live HTTP Headers得知缓存效果　　58
2.2.2　Squid缓存服务器　　59
使用Squid搭建反向代理　　60
Squid缓存什么　　61
Squid的设定示例　　62
2.2.3　使用memcached进行缓存　　64
2.3　MySQL同步……发生故障时的快速恢复　　66
2.3.1　万一数据库服务器停止　　66
导致数据库停止的原因　　66
短时间内恢复的办法　　66
2.3.2　MySQL的同步功能的特性和注意点　　67
单主与多从　　67
异步数据同步　　68
被同步的数据内容　　68
2.3.3　同步的结构　　69
Slave 的I/O线程与SQL线程　　69
二进制日志与中继日志　　69
位置信息　　70
2.3.4　搭建同步结构　　70
同步条件　　70
my.cnf　　71
建立同步专用的用户　　71
同步开始时所必需的数据　　72
2.3.5　启动同步　　73
Master和Slave的my.cnf文件的差异　　73
Slave开始运行&确认　　73
2.3.6　确认同步的状态　　74
Master的状态确认　　74
Slave的状态确认　　75
2.4　MySQL的Slave+内部负载均衡器的灵活应用示例　　78
2.4.1　MySQL的Slave的运用方法　　78
Slave的运用策略　　78
分发到多台Slave上　　78
2.4.2　通过负载均衡器将请求分发到多台Slave的方法　　79
概况图　　79
内部负载均衡器的配置　　80
MySQL Slave的设定　　82
体验将请求分发到多台Slave的负载均衡　　83
2.4.3　内部负载均衡器的注意点……基于DSR的分发方法　　83
2.5　选择轻量高速的存储服务器 　　85
2.5.1　存储服务器的必要性　　85
存储服务器容易导致单点故障　　86
存储服务器容易造成瓶颈　　86
2.5.2　理想的存储服务器　　88
减轻负载　　88
2.5.3　将HTTP作为存储协议使用 　　88
轻量Web服务器的选择　　89
利用HTTP的优势　　89
2.5.4　遗留的问题　　90
第3章　进一步完善不间断的基础设施
DNS服务器、存储服务器、网络　　93
3.1　DNS服务器的冗余 　　94
3.1.1　DNS服务器冗余的重要性　　94
3.1.2　使用解析库实现冗余及存在的问题　　94
解析库存在的问题　　95
性能下降的危险性……以邮件服务器为例　　95
DNS故障会造成很大的影响　　96
3.1.3　基于服务器集群的DNS冗余　　96
3.1.4　使用VRRP的拓扑结构　　96
3.1.5　DNS服务器的负载分发　　98
3.1.6　小结　　100
3.2　存储服务器的冗余……利用DRBD实现镜像 　　101
3.2.1　存储服务器的故障排解　　101
3.2.2　存储服务器同步的难点　　101
3.2.3　DRBD　　102
DRBD架构　　102
3.2.4　DRBD的设置与启动　　103
启动DRBD的Master服务器　　104
启动DRBD的备份服务器　　105
3.2.5　DRBD的故障转移　　105
手动切换　　105
keepalived的配置　　106
利用daemontools来控制keepalived　　108
3.2.6　NFS服务器故障转移时的注意事项　　109
3.2.7　备份的必要性　　110
3.3　网络的冗余……驱动绑定、RSTP　　111
3.3.1　L1/L2上部件的冗余　　111
3.3.2　故障点　　111
3.3.3　链路冗余与驱动绑定　　112
驱动绑定　　112
3.3.4　交换机的冗余　　114
链路故障时的行为　　114
交换机故障时的行为　　115
交换机间遭遇连接故障时的情况　　115
3.3.5　增设交换机　　116
实现多重冗余　　117
3.3.6　RSTP　　117
网桥的优先顺序及根网桥　　118
RSTP中端口的作用　　119
RSTP的行为　　119
3.3.7　总结　　120
3.4　引入VLAN……使网络更加灵活　　121
3.4.1　基于服务器集群的高灵活性网络　　121
3.4.2　引入VLAN的优点　　121
交换机的有效使用　　122
故障服务器的恢复机制 …灵活使用一台备用机　　123
使用VLAN，仅用一台备用机就能实现恢复　　123
3.4.3　VLAN的基础知识　　124
3.4.4　VLAN的种类　　125
端口VLAN　　126
标记VLAN　　127
3.4.5　在服务器集群中的使用　　128
不使用VLAN的拓扑结构　　128
使用端口VLAN的拓扑结构　　129
使用VLAN标签的拓扑结构　　130
3.4.6　 即便在复杂的VLAN结构下，也需要让物理层面的设备
结构尽可能简易化　　132
第4章　性能优化、调整
Linux单个主机、Apache、MySQL　　133
4.1　基于Linux单个主机的负载评估　　134
4.1.1　充分发挥单个主机的性能　　134
清楚何为性能、何为负载　　134
4.1.2　别臆断，请监控　　135
4.1.3　确认瓶颈的基本流程　　136
观察load average　　136
观察CPU、I/O是否存在瓶颈　　137
当CPU负载较高时　　137
当I/O负载较高时　　137
4.1.4　何为负载　　138
两种负载　　138
多任务操作系统与负载　　139
搞清负载的本来面目=知晓内核的行为　　140
进程调度和进程状态　　140
进程状态变迁的具体例子　　142
进程状态迁移汇总　　144
换算到load average的等待状态　　144
load average表述的负载意义　　145
4.1.5　计算load average的内核编码　　146
4.1.6　通过load average判断CPU使用率和I/O等待时间　　148
使用sar来查看CPU使用率及I/O等待时间　　149
CPU的用户模式和系统模式　　149
I/O密集型服务器的sar　　150
4.1.7　多核CPU与CPU使用率　　151
4.1.8　如何计算CPU的使用率　　152
4.1.9　进程记账的内核编码　　153
4.1.10　线程和进程　　156
内核中的进程和线程　　157
ps和线程　　158
LinuxThreads和NPTL　　159
4.1.11　ps、sar、vmstat的使用方法　　159
ps……输出进程信息　　159
VSZ与RSS……虚拟内存和物理内存的指标　　160
TIME……CPU占用时间　　162
通过ps命令查看Blocking和Busy Loop的差异　　162
sar……查看系统报告的各项指标　　163
sar -u……查看CPU的使用率　　165
sar -q……查看load average　　165
sar -r……查看内存的使用状况　　166
减轻I/O负载及页面缓存　　166
通过页面缓存减轻I/O负载的实施效果　　167
将所需的数据整个放到页面缓存上　　168
sar -W……查看交换区的吞吐状况　　169
vmstat……查看虚拟内存的相关信息　　170
4.1.12　找到系统负载的症结并解决　　171
4.2　Apache的优化 　　172
4.2.1　Web服务器的优化　　172
4.2.2　Web服务器遭遇瓶颈怎么办　　172
4.2.3　Apache的并发处理与MPM　　173
prefork与worker，进程与线程　　175
从编程模型看多进程/多线程的差异　　175
从性能的观点来看多进程/多线程的差异　　176
一个客户端对应一个进程/线程　　177
4.2.4　httpd.conf的配置　　177
Apache的安全阀MaxClients　　177
在prefork模式的情况下　　178
父子进程共享内存的写时复制技术　　180
查看写时复制时共享的内存大小　　181
MaxRequestsPerChild　　183
在worker模式的情况下　　183
在系统超载的情况下，改变MaxClients前需要了解　　185
4.2.5　Keep-Alive　　186
4.2.6　Apache以外的选择　　186
lighttpd　　187
4.3　MySQL的调优诀窍　　189
4.3.1　MySQL的调优诀窍　　189
基于调优视角的分类　　189
1 服务器方面　　189
2 服务器之外的其他方面　　190
3 周边系统　　190
本章接下来要处理的内容　　191
4.3.2　内存相关的参数优化　　191
缓冲的种类……优化时的注意事项①　　191
不能分配太多……优化时的注意事项②　　192
内存的相关参数　　192
4.3.3　内存相关的检查工具……mymemcheck　　194
第5章　高效运行
确保服务的稳定提供　　197
5.1　服务状态监控Nagios　　198
5.1.1　稳定的服务运营与服务状态监控　　198
5.1.2　状态监控的种类　　198
1 存活状态的监控　　198
2 负载状态的监控　　199
3 可用率的统计　　200
5.1.3　Nagios概述　　201
安装Nagios　　201
5.1.4　Nagios的配置　　201
配置文件　　202
host……主机的配置　　202
service……服务的定义　　203
command……命令的定义　　204
contact与contactgroup……通知对象和通知对象组　　205
配置的测试　　206
5.1.5　Web管理界面　　206
5.1.6　Nagios的基本使用方法　　208
主机和服务的定义　　208
通知　　209
5.1.7　实用的使用方法　　212
可用率的测定　　212
独立插件　　214
5.1.8　小结　　216
5.2　服务器资源的监控……Ganglia　　217
5.2.1　服务器资源的监控　　217
监控的目的　　217
5.2.2　检测工具的讨论　　218
5.2.3　Ganglia……面向大量节点的图表化工具　　218
5.2.4　将Apache的进程状态图表化　　220
在Ganglia中增加图表的方法　　222
尝试增加多个图表　　222
其他的自定义图表　　223
5.3　高效的服务器管理……Puppet　　225
5.3.1　实现高效的服务器管理的工具Puppet　　225
5.3.2　Puppet的概要　　225
5.3.3　Puppet的配置　　226
节点的定义　　227
类的定义　　227
确认配置是否有效　　229
5.3.4　配置文件的语法　　230
资源的定义　　230
资源　　231
对各个服务器的配置进行微调　　232
资源间的依赖关系　　233
通过模板完成Manifest文件的定义　　233
5.3.5　通知操作日志　　237
5.3.6　运用　　238
5.3.7　自动配置管理工具的利与弊　　239
5.4　守护进程的工作管理……Daemontools　　241
5.4.1　守护进程的异常终止　　241
5.4.2　daemontools　　241
使用daemontools的原因　　242
成为守护进程的条件……在前台运行　　243
5.4.3　守护进程的管理方法　　243
创建守护进程　　243
启动守护进程　　244
停止、继续、重新启动守护进程　　245
停用守护进程　　245
发送信号　　245
Keepalived……run文件的例子①　　246
自编的监控脚本……run文件的例子②　　246
5.4.4　daemontools的实用技巧　　248
控制所依赖的服务的启动顺序　　248
常用的shell函数　　249
5.5　网络引导的应用……PXE、initramfs　　252
5.5.1　网络引导　　252
网络引导的特性及优势　　252
5.5.2　网络引导的行为……PXE　　253
5.5.3　网络引导的应用实例　　255
负载均衡器　　255
数据库服务器/文件服务器　　256
维护用的引导映像　　256
5.5.4　构建网络引导　　257
initramfs的通用化和作用的识别　　257
无盘结构中需要注意的事项　　258
Master文件的安全性 　　259
5.6　远程维护……维护线路、Serial Console、IPMI 　　260
5.6.1　轻松实现远程登录　　260
5.6.2　网络故障的应对　　260
维护线路　　260
交换机故障的应对　　262
5.6.3　Serial Console　　263
Serial Console的实现　　264
5.6.4　IPMI　　266
IPMI的功能　　266
使用IPMI　　267
5.6.5　总结 　　267
5.7　Web服务器的日志处理……syslog、syslog-ng、cron、rotatelogs　　268
5.7.1　Web服务器日志的分拣·收集　　268
5.7.2　分拣与收集　　268
5.7.3　日志的分拣……syslog和syslog-ng　　269
使用syslog进行日志的分拣　　269
syslog-ng　　270
5.7.4　日志的收集　　272
Apache日志的转储……cron与rotatelogs　　272
5.7.5　日志服务器的作用与构成　　273
5.7.6　总结　　274
第6章　服务后台
自律的基础设施、稳健的系统　　275
6.1　Hatena网站的内容　　276
6.1.1　Hatena的基础设施　　276
6.1.2　可扩展性和稳定性　　277
反向代理　　278
数据库　　279
文件服务器　　281
6.1.3　提高运营效率　　282
安装Kickstart　　282
软件包管理和Puppet　　282
服务器的管理和监控　　283
使用Capistrano部署　　284
6.1.4　用电效率·提高资源的利用率　　285
重视服务器每1A所发挥的性能　　285
充分利用每台服务器的性能　　286
不安装无用的零件　　287
6.1.5　为了自律的基础设施而努力　　288
6.2　DSAS的内容　　290
6.2.1　什么是DSAS　　290
6.2.2　DSAS的特征　　291
一个系统容纳多个网站　　291
使用开源软件搭建　　291
无论切断任何地方，网络服务都不会停止　　294
服务器增设非常方便　　295
故障修复非常简单　　295
6.2.3　系统架构的详情　　296
使用驱动绑定的原因　　296
DRBP实现故障转移时的注意事项　　297
配置SSL加速器　　299
扩展健康检查功能　　301
既方便又安全地使用负载均衡器　　303
处理会话数据　　306
memcached　　307
repcached　　307
6.2.4　DSAS的未来　　309
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>24小时365天不间断服务
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>简单之美
场景故事人物关系图本书赞誉前言为什么写本书本书面向的读者如何阅读本书第1章  无极生太极  1.1  创造的根源  1.2  本质的把握  1.3  简单的追求第2章  关于软件开发方法论的思考  2.1  方法论的实践场景  2.2  CMM的精髓    2.2.1  过程定义    2.2.2  成熟之路  2.3  敏捷软件开发的精髓    2.3.1  人与实践    2.3.2  海岸灯塔  2.4  最好的软件开发方法    2.4.1  中庸    2.4.2  聚焦  2.5  方法论的执行    2.5.1  关于执行    2.5.2  约束与习惯第3章  关于需求的思考  3.1  需求的实践场景  3.2  需求开发    3.2.1  准确表达    3.2.2  信息传递  3.3  需求管理    3.3.1  变化之道    3.3.2  应对之道第4章  关于软件架构设计的思考  4.1  架构设计的实践场景  4.2  软件架构的本质  4.3  软件架构的设计    4.3.1  业界技术成果    4.3.2  软件框架    4.3.3  隐喻的价值    4.3.4  架构模式    4.3.5  软件架构师的素质第5章  关于软件实现的思考  5.1  软件实现的实践场景  5.2  模型的设计    5.2.1  领域模型    5.2.2  计算模型  5.3  软件开发    5.3.1  写给新手    5.3.2  掌握编程  5.4  负责制度  5.5  软件决策  5.6  质量保证第6章  关于软件测试的思考  6.1  软件测试的实践场景  6.2  软件测试的本质  6.3  破坏的意义    6.3.1  软件测试的第一个原则：聚焦    6.3.2  软件测试的第二个原则：积累    6.3.3  软件测试的第三个原则：自动化    6.3.4  软件测试的第四个原则：目标一致  6.4  一个典型的破坏：性能测试  6.5  其他第7章  关于团队的思考  7.1  团队的实践场景  7.2  湘江战役  7.3  团队建设    7.3.1  思想准备    7.3.2  如何组建团队    7.3.3  现实与理想  7.4  团队管理    7.4.1  论人    7.4.2  稳定的价值    7.4.3  团队文化第8章  关于项目管理的思考  8.1  项目管理的实践场景  8.2  项目管理的本质  8.3  关于项目经理  8.4  计划的本质  8.5  风险的问题  8.6  管理的境界第9章  关于软件维护的思考  9.1  软件维护的实践场景  9.2  软件维护的本质  9.3  组件化开发  9.4  版本依赖  9.5  妥协的方案第10章  关于组织发展的思考  10.1  组织发展的实践场景  10.2  知识积累  10.3  行业成熟  10.4  知识资产
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>简单之美
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>RESTful Web APIs中文版
序 ................................................................................xix
前言 .............................................................................xxi
第1 章 网上冲浪 ............................................................ 1
场景1 ：广告牌 ......................................................................................................2
资源和表述 .....................................................................................................2
可寻址性 .........................................................................................................3
场景2 ：主页 .........................................................................................................3
短会话（Short Session） ..................................................................................5
自描述消息（self-descriptive message） ..........................................................5
场景3 ：链接 .........................................................................................................6
标准方法 .........................................................................................................8
场景4 ：表单和重定向 ..........................................................................................9
应用状态（Application State） ....................................................................... 11
资源状态（resource state） ............................................................................12
连通性（connectedness） ...............................................................................13
与众不同的Web ............................................................................................14
Web API 落后于Web ....................................................................................15
语义挑战 .......................................................................................................16
第2 章 一个简单的API ................................................ 17
HTTP GET ：安全的投注 .....................................................................................18
如何读取HTTP 响应 ...........................................................................................19
JSON ....................................................................................................................20
Collection+JSON ..................................................................................................21
向API 写入数据 ..................................................................................................23
HTTP POST: 资源是如何生成的 ..........................................................................24
由约束带来解放 ...................................................................................................26
应用语义所产生的语义鸿沟 ................................................................................27
第3 章 资源和表述 ...................................................... 29
万物皆可为资源 ...................................................................................................30
表述描述资源状态 ...............................................................................................30
往来穿梭的表述 ...................................................................................................31
资源有多重表述 ...................................................................................................32
HTTP 协议语义（Protocol Semantics） .............................................................33
GET ...............................................................................................................35
DELETE ........................................................................................................36
幂等性（Idempotence） ..................................................................................36
POST-to-Append ............................................................................................37
PUT ...............................................................................................................38
PATCH ..........................................................................................................39
LINK 和UNLINK .........................................................................................40
HEAD ............................................................................................................40
OPTIONS ......................................................................................................41
Overloaded POST ..........................................................................................41
应该使用哪些方法？ ...........................................................................................42
第4 章 超媒体 ............................................................. 45
将HTML 作为超媒体格式...................................................................................46
URI 模板 ..............................................................................................................49
URI vs URL .........................................................................................................50
Link 报头 .............................................................................................................51
超媒体的作用 ......................................................................................................52
引导请求 .......................................................................................................52
对响应做出承诺 ............................................................................................54
工作流控制 ...................................................................................................55
当心冒牌的超媒体！ ...........................................................................................56
语义挑战：我们该怎么做？ ................................................................................57
第5 章 领域特定设计 ................................................... 59
Maze+XML ：领域特定设计 ................................................................................60
Maze+XML 是如何工作的 ...................................................................................61
链接关系 .......................................................................................................62
访问链接来改变应用状态 .............................................................................64
迷宫集合 ..............................................................................................................65
Maze+XML 是API 吗？ ......................................................................................67
客户端1 ：游戏 ....................................................................................................68
Maze+XML 服务器 ..............................................................................................72
客户端2 ：地图生成器 ........................................................................................74
客户端3 ：吹牛者 ................................................................................................76
客户端做自己想要做的事 ....................................................................................77
对标准进行扩展 ............................................................................................77
地图生成器的缺陷 ...............................................................................................80
修复（以及修复后的瑕疵） ...........................................................................81
迷宫的暗喻 ..........................................................................................................83
解决语义鸿沟 ......................................................................................................83
领域特定设计在哪里？ ........................................................................................83
最终的奖赏 ...................................................................................................84
报头中的超媒体 ............................................................................................84
抄袭应用语义 ................................................................................................84
如果找不到相关的领域特定设计，不要自己制造 ...............................................86
API 客户端的种类 ...............................................................................................86
人类驱动的客户端 ........................................................................................86
自动化客户端 ................................................................................................87
第6 章 集合模式（Collection Pattern） ......................... 91
什么是集合？ ......................................................................................................93
链向子项的集合 ............................................................................................93
Collection+JSON ..................................................................................................94
子项的表示 ...................................................................................................95
写入模板（Write Template） ..........................................................................98
搜索模板 .......................................................................................................99
一个（通用的）集合是如何工作的 ................................................................... 100
GET ............................................................................................................. 101
POST-to-Append .......................................................................................... 101
PUT 和PATCH ............................................................................................ 101
DELETE ...................................................................................................... 102
分页 ............................................................................................................. 102
搜索表单 ..................................................................................................... 103
Atom 发布协议（AtomPub） .............................................................................. 103
AtomPub 插件标准 ...................................................................................... 105
为什么不是每个人都选择使用AtomPub ？ ................................................ 106
语义挑战：我们应该怎么做？ .......................................................................... 107
第7 章 纯- 超媒体设计 .............................................. 111
为什么是HTML? ............................................................................................... 111
HTML 的能力 .................................................................................................... 112
超媒体控件 ................................................................................................. 112
应用语义插件 .............................................................................................. 113
微格式 ................................................................................................................ 115
hMaze 微格式 .................................................................................................... 116
微数据 ................................................................................................................ 118
改变资源状态 .................................................................................................... 119
为表单添加应用语义 ................................................................................... 121
与超媒体相对是普通媒体 .................................................................................. 125
HTML 的局限性 ................................................................................................ 126
拯救者HTML5? .......................................................................................... 127
超文本应用语言 ................................................................................................. 128
Siren ................................................................................................................... 131
语义挑战：我们现在要怎么做？ ....................................................................... 133
第8 章 Profile ........................................................... 135
客户端如何找寻文档？ ...................................................................................... 136
什么是Profile ？ ................................................................................................ 137
链接到Profile .................................................................................................... 137
Profile 链接关系 .......................................................................................... 137
Profile 媒体类型参数 .................................................................................. 138
特殊用途的超媒体控件 ............................................................................... 139
Profile 对协议语义的描述 .................................................................................. 139
Profile 对应用语义的描述 .................................................................................. 140
链接关系 ..................................................................................................... 141
不安全的链接关系 ...................................................................................... 142
语义描述符 ................................................................................................. 142
XMDP ：首个机器可读的Profile 格式 .............................................................. 143
ALPS .................................................................................................................. 146
ALPS 的优势 ............................................................................................... 150
ALPS 并不是万金油 .................................................................................... 152
JSON-LD ........................................................................................................... 153
内嵌的文档 ........................................................................................................ 156
总结 ................................................................................................................... 158
第9 章 API 设计流程 ................................................. 161
两个步骤的设计流程 ......................................................................................... 161
七步骤设计流程 ................................................................................................. 162
第1 步：罗列语义描述符 ........................................................................... 163
第2 步：画状态图 ...................................................................................... 164
第3 步：调整命名 ...................................................................................... 168
第4 步：选择一种媒体类型 ....................................................................... 172
第5 步：编写Profile .................................................................................. 173
第6 步：实现 .............................................................................................. 174
第7 步：发布 .............................................................................................. 174
实例：You Type It, We Post It ............................................................................ 177
罗列语义描述符 .......................................................................................... 177
画状态图 ..................................................................................................... 178
调整名称 ..................................................................................................... 179
选择一种媒体类型 ...................................................................................... 180
编写Profile ................................................................................................. 181
设计建议 ............................................................................................................ 182
资源是实现的内部细节 ............................................................................... 182
不要掉入集合陷阱 ...................................................................................... 183
不要从表述格式着手 ................................................................................... 184
URL 设计并不重要 ..................................................................................... 184
标准名称优于自定义名称 ........................................................................... 186
设计媒体类型 .............................................................................................. 187
当你的API 改变时 ...................................................................................... 189
为现有API 添加超媒体 ..................................................................................... 194
改进基于XML 的API ................................................................................ 195
值不值得？ ................................................................................................. 196
Alice 的第二次探险 ........................................................................................... 196
场景1 ：没有意义的表述 ............................................................................ 196
场景2 ：Profile ............................................................................................ 198
Alice 明白了 ................................................................................................ 200
第10 章 超媒体动物园 ............................................... 203
领域特定格式 .................................................................................................... 204
Maze+XML ................................................................................................. 204
OpenSearch ................................................................................................. 205
问题细节文档 .............................................................................................. 205
SVG ............................................................................................................. 206
VoiceXML ................................................................................................... 208
集合模式的格式 ................................................................................................. 210
Collection+JSON ......................................................................................... 211
Atom 发布协议 ............................................................................................ 211
OData .......................................................................................................... 212
纯超媒体格式 .................................................................................................... 219
HTML .......................................................................................................... 219
HAL ........................................................................................................... 220
Link 报头 .................................................................................................... 222
Location 和Content-Location 报头 ............................................................. 222
URL 列表 .................................................................................................... 223
JSON 主文档（Home Documents） .............................................................. 223
Link-Template 报头 ..................................................................................... 224
WADL ......................................................................................................... 225
XLink .......................................................................................................... 226
XForms ........................................................................................................ 227
GeoJSON ：一个令人困惑的类型 ...................................................................... 228
GeoJSON 没有通用的超媒体控件 ............................................................... 230
GeoJSON 没有媒体类型 ............................................................................. 232
从GeoJSON 学习到的经验 ......................................................................... 233
语义动物园 ........................................................................................................ 234
链接关系的IANA 注册表 ........................................................................... 234
微格式WiKi ................................................................................................ 235
来自微格式Wiki 的链接关系 ...................................................................... 236
第11 章 API 中的HTTP ............................................ 241
新HTTP/1.1 规范 .............................................................................................. 242
响应码 ................................................................................................................ 242
报头 ................................................................................................................... 243
表述选择 ............................................................................................................ 243
内容协商（Content Negotiation） ................................................................ 243
超媒体菜单 ................................................................................................. 244
标准URL（Canonical URL） ...................................................................... 245
HTTP 性能 ......................................................................................................... 246
缓存（Caching） .......................................................................................... 246
条件GET 请求（Conditional GET） ............................................................ 247
Look-Before-You-Leap 请求 ........................................................................ 249
压缩 ............................................................................................................. 250
部分GET 请求（Partial GET） .................................................................... 250
Pipelining .................................................................................................... 251
避免更新丢失问题 ............................................................................................. 252
认证 ................................................................................................................... 254
WWW-Authenticate 报头和Authorization 报头 .......................................... 255
Basic 认证 ................................................................................................... 255
OAuth 1.0 .................................................................................................... 256
OAuth 1.0 的缺点 ........................................................................................ 259
OAuth 2.0 .................................................................................................... 260
何时不采用OAuth ...................................................................................... 261
HTTP 扩展 ......................................................................................................... 261
PATCH 方法 ................................................................................................ 262
LINK 和UNLINK 方法 ............................................................................... 262
WebDAV ...................................................................................................... 263
HTTP 2.0 ..................................................................................................... 264
第12 章 资源描述和Linked Data ............................... 267
RDF ................................................................................................................... 268
RDF 将URL 作为URI 对待........................................................................ 270
什么时候使用描述策略 ...................................................................................... 271
资源类型 ............................................................................................................ 273
RDF Schema ...................................................................................................... 274
Linked Data 运动 ............................................................................................... 277
JSON-LD ........................................................................................................... 278
将JSON-LD 作为一种表述格式 ................................................................. 279
Hydra ................................................................................................................. 280
XRD 家族........................................................................................................... 285
XRD 和JRD ................................................................................................ 285
Web 主机元数据文档 .................................................................................. 286
WebFinger ................................................................................................... 287
本体动物园（Ontology Zoo） ............................................................................. 289
schema.org RDF .......................................................................................... 289
FOAF .......................................................................................................... 290
vocab.org .................................................................................................... 290
总结：描述策略生机盎然！ ....................................................................... 290
第13 章 CoAP: 嵌入式系统的REST .......................... 293
CoAP 请求 ......................................................................................................... 294
CoAP 响应 ......................................................................................................... 294
消息种类 ............................................................................................................ 295
延迟响应（Delayed Response） .......................................................................... 296
多播消息（Multicast Message） ......................................................................... 296
CoRE Link Format ............................................................................................. 297
结论：非HTTP 协议的REST ........................................................................... 298
附录A 状态法典 ........................................................ 301
附录B HTTP 报头法典 .............................................. 325
附录C 为API 设计者准备的Fielding 论文导读 ........... 349
词汇表 ....................................................................... 365
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>RESTful Web APIs中文版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>系统分析与设计方法
译者序前言致谢第一部分  系统开发项目环境第1章  系统分析和设计方法的环境  1.1  系统分析和设计框架  1.2  参与者——系统关联人员    1.2.1  系统所有者    1.2.2  系统用户    1.2.3  系统设计人员    1.2.4  系统构造人员    1.2.5  系统分析员    1.2.6  外部服务提供者    1.2.7  项目经理  1.3  现代信息系统的企业驱动力    1.3.1  经济全球化    1.3.2  电子商务和电子业务    1.3.3  安全和隐私    1.3.4  协作与合伙经营    1.3.5  知识产权管理    1.3.6  持续改进和全面质量管理    1.3.7  业务过程重构  1.4  信息系统的技术推动力    1.4.1  网络和因特网    1.4.2  移动和无线技术    1.4.3  对象技术    1.4.4  协作技术    1.4.5  企业应用软件  1.5  一个简单的系统开发过程    1.5.1  系统启动    1.5.2  系统分析    1.5.3  系统设计    1.5.4  系统实现    1.5.5  系统支持和持续改进第2章  信息系统构件  2.1  产品——信息系统  2.2  信息系统架构框架    2.2.1  “知识”构件    2.2.2  “过程”构件    2.2.3  “通信”构件  2.3  网络技术和IS构件第3章  信息系统开发  3.1  系统开发过程    3.1.1  能力成熟度模型    3.1.2  系统生命周期和系统开发方法    3.1.3  系统开发基本原理  3.2  系统开发过程    3.2.1  项目确定    3.2.2  FAST项目阶段    3.2.3  跨生命周期活动    3.2.4  顺序开发和迭代开发  3.3  选择开发路线和策略    3.3.1  模型驱动开发策略    3.3.2  快速应用开发策略    3.3.3  商用应用软件包实现策略    3.3.4  混合策略    3.3.5  系统维护  3.4  自动化工具和技术    3.4.1  计算机辅助系统工程    3.4.2  应用开发环境    3.4.3  过程和项目管理器第4章  项目管理  4.1  什么是项目管理    4.1.1  项目失败的原因    4.1.2  项目管理知识体系  4.2  项目管理生命周期    4.2.1  活动1——协商范围    4.2.2  活动2——确定任务    4.2.3  活动3——估计任务工期    4.2.4  活动4——说明任务之间的依赖关系    4.2.5  活动5——分配资源    4.2.6  活动6——指导团队工作    4.2.7  活动7——监督和控制进展    4.2.8  活动8——评估项目结果和经验第二部分  系统分析方法第5章  系统分析  5.1  什么是系统分析  5.2  系统分析方法    5.2.1  模型驱动分析法    5.2.2  加速系统分析法    5.2.3  需求获取法    5.2.4  业务过程重构法    5.2.5  FAST系统分析策略  5.3  范围定义阶段    5.3.1  任务1.1——列出问题和机会    5.3.2  任务1.2——协商项目的初步范围    5.3.3  任务1.3——评估项目价值    5.3.4  任务1.4——计划项目进度表和预算    5.3.5  任务1.5——汇报项目计划  5.4  问题分析阶段    5.4.1  任务2.1——研究问题领域    5.4.2  任务2.2——分析问题和机    5.4.3  任务2.3——分析业务过程    5.4.4  任务2.4——制定系统改进目标    5.4.5  任务2.5——修改项目计划    5.4.6  任务2.6——汇报调查结果和建议  5.5  需求分析阶段    5.5.1  任务3.1——定义需求    5.5.2  任务3.2——排列需求的优先次序    5.5.3  任务3.3——修改项目计划    5.5.4  任务3.4——交流需求陈述    5.5.5  持续不断的需求管理  5.6  逻辑设计阶段    5.6.1  任务4.1 a——结构化功能需求    5.6.2  任务4.1 b——建立功能需求的原型(可选)    5.6.3  任务4.2——验证功能需求    5.6.4  任务4.3——定义验收测试用例  5.7  决策分析阶段    5.7.1  任务5.1——确定候选方案    5.7.2  任务5.2——分析候选方案    5.7.3  任务5.3——比较候选方案    5.7.4  任务5.4——修改项目计划    5.7.5  任务5.5——推荐一种系统方案  5.8  系统分析的未来第6章  需求获取的调查研究技术  6.1  需求获取简介  6.2  需求获取过程    6.2.1  发现和分析问题    6.2.2  获取需求    6.2.3  归档和分析需求    6.2.4  需求管理  6.3  调查研究技术    6.3.1  对现有文档、表和文件进行抽样    6.3.2  调研和实地访问    6.3.3  观察工作环境    6.3.4  调查表    6.3.5  面谈    6.3.6  如何进行面谈    6.3.7  获取原型    6.3.8  联合需求计划  6.4  调查研究策略第7章  使用用例建模系统需求  7.1  用例建模概述  7.2  用例建模的系统概念    7.2.1  用例    7.2.2  参与者    7.2.3  关系  7.3  需求用例建模过程    7.3.1  第1步：确定业务参与者    7.3.2  第2步：确定业务需求用例    7.3.3  第3步：构造用例模型图    7.3.4  第4步：记录业务需求用例描述  7.4  用例和项目管理    7.4.1  分级和评估用例    7.4.2  确定用例依赖关系第8章  数据建模和分析  8.1  数据建模简介  8.2  数据建模的系统概念    8.2.1  实体    8.2.2  属性    8.2.3  关系  8.3  逻辑数据建模过程    8.3.1  战略数据建模    8.3.2  系统分析期间的数据建模    8.3.3  对系统设计的考虑    8.3.4  数据建模的自动化工具  8.4  如何构造数据模型    8.4.1  获取实体    8.4.2  上下文数据模型    8.4.3  基于键的数据模型    8.4.4  泛化层次体系    8.4.5  具有完整属性的数据模型  8.5  分析数据模型    8.5.1  好的数据模型的标准    8.5.2  数据分析    8.5.3  规范化举例  8.6  将数据需求映射到地点第9章  过程建模  9.1  系统建模简介  9.2  过程建模的系统概念    9.2.1  外部代理    9.2.2  数据存储    9.2.3  过程概念    9.2.4  数据流  9.3  逻辑过程建模的过程    9.3.1  战略系统规划    9.3.2  用于业务过程重构的过程建模    9.3.3  系统分析期间的过程建模    9.3.4  对系统设计的考虑    9.3.5  用于过程建模的调查研究和信息收集    9.3.6用于过程建模的计算机辅助系统工程  9.4  如何构造过程模型    9.4.1  上下文数据流图    9.4.2  功能分解图    9.4.3  事件响应或用例清单    9.4.4  事件分解图    9.4.5  事件图    9.4.6  系统图    9.4.7  基本图    9.4.8  完成规格说明  9.5  系统模型的同步.    9.5.1  数据模型和过程模型的同步    9.5.2  过程分布第10章  使用UML进行面向对象分析和建模  10.1  面向对象分析概述  10.2  对象建模的历史  10.3  对象建模的系统概念    10.3.1  对象、属性、方法和封装    10.3.2  类、泛化和特化    10.3.3  对象/类关系    10.3.4  消息和消息发送    10.3.5  多态性  10.4  UNL模型图  10.5  对象建模过程    10.5.1  建模系统的功能性描述    10.5.2  构造分析用例模型    10.5.3  建模用例活动    10.5.4  构造活动图指南    10.5.5  绘制系统顺序图    10.5.6  构造系统顺序图指南    10.5.7  发现和确定业务对象    10.5.8  组织对象并确定其关系第11章  可行性分析和系统方案建议  11.1  可行性分析和系统方案建议    11.1.1  可行性分析——逐步投入法    11.1.2  系统分析——范围定义阶段的检查点    11.1.3  系统分析——问题分析阶段的检查点    11.1.4  系统设计——决策分析阶段的检查点  11.2  可行性的6个准则    11.2.1  运行可行性    11.2.2  文化(或者政治)可行性    11.2.3  技术可行性    11.2.4  进度可行性    11.2.5  经济可行性    11.2.6  法律可行性    11.2.7  底线  11.3  成本效益分析技术    11.3.1  系统将花费多少.    11.3.2  系统将提供什么收益    11.3.3  建议的系统合算吗  11.4  候选系统的可行性分析    11.4.1  候选系统矩阵    11.4.2  可行性分析矩阵  11.5  系统方案建议    11.5.1  书面报告    11.5.2  正式汇报第三部分  系统设计方法第12章  系统设计  12.1  什么是系统设计  12.2  系统设计方法    12.2.1  模型驱动方法    12.2.2  快速应用开发    12.2.3  FASI、系统设计策略  12.3  系统设计之内部开发——“构造”方案    12.3.1  任务5.1——设计应用架构    12.3.2  任务5.2——设计系统数据库    12.3.3  任务5.3——设计系统接口    12.3.4  任务5.4——打包设计说明    12.3.5  任务5.5—修改项目计划  12.4  系统设计之集成商用软件——“购买”方案    12.4.1  任务4.1——研究技术评价准则和选项    12.4.2  任务4.2—二向供应商征求建议(或报价)    12.4.3  任务5A.1——验证供应商的声明和性能    12.4.4  任务5A.2——评价和分级供应商建议    12.4.5  任务5A.3——签订合同并听取供应商汇报    12.4.6  购买决定对剩余生命周期阶段的影响第13章  应用架构和建模  13.1  应用架构  13.2  物理数据流图    13.2.1  物理过程    13.2.2  物理数据流    13.2.3  物理外部代理    13.2.4  物理数据存储  13.3  信息技术架构    13.3.1  分布式系统    13.3.2  数据架构——分布式关系数据库    13.3.3  接口架构——输入、输出和中间件    13.3.4  过程架构——软件开发环境  13.4  系统设计的应用架构策略    13.4.1  企业应用架构策略    13.4.2  战术应用架构策略  13.5  建模信息系统应用架构    13.5.1  绘制物理数据流图    13.5.2  前置条件    13.5.3  网络架构    13.5.4  数据分布和技术确定    13.5.5  过程分布和技术确定    13.5.6  人/机边界第14章  数据库设计  14.1  常规文件和数据库    14.1.1  常规文件的优缺点    14.1.2  数据库的优缺点  14.2  系统分析员的数据库概念    14.2.1  字段    14.2.2  记录    14.2.3  文件和表    14.2.4  数据库  14.3  数据库设计的前置条件——规范化  14.4  常规文件设计  14.5  现代数据库设计    14.5.1  数据库设计的目标和前置条件    14.5.2  数据库模式    14.5.3  数据完整性和访问完整性    14.5.4  角色    14.5.5  数据库分布和复制    14.5.6  数据库原型    14.5.7  规划数据库容量    14.5.8  数据库结构生成  14.6  数据库设计的前景第15章  输出设计和原型化  15.1  输出设计概念和指南    15.1.1  输出的分布和观众    15.1.2  输出的实现方法  15.2  如何设计和原型化输出    15.2.1  用于输出设计和原型化的自动化工具    15.2.2  输出设计指南    15.2.3  输出设计过程    15.2.4  基于Web的输出和电子业务第16章  输入设计和原型化  16.1  输入设计概念和指南    16.1.1  数据收集、数据录入和数据处理    16.1.2  输入方法和实现    16.1.3  输入设计的系统用户问题    16.1.4  内部控制——输入数据的编辑  16.2  输入设计的GUI控件    16.2.1  常用GUI输入控件    16.2.2  高级输入控件  16.3如何设计和原型化输入    16.3.1  输入设计和原型化的自动化工具    16.3.2  输入设计过程    16.3.3  基于Web的输入和电子业务第17章  用户界面设计  17.1  用户界面设计概念和指南    17.1.1  计算机用户的类型    17.1.2  人的因素    17.1.3  人类工程学指南    17.1.4  对话语气和词汇  17.2  用户界面技术    17.2.1  操作系统和Web浏览器    17.2.2  显示器    17.2.3  键盘和指点设备  17.3  图形用户界面风格    17.3.1  窗口和框    17.3.2  菜单驱动的界面    17.3.3  指令驱动的界面    17.3.4  提问一回答对话    17.3.5  用户界面设计的特殊考虑  17.4  如何设计用户界面    17.4.1  用于用户界面设计和原型化的自动化工具    17.4.2  用户界面设计过程第18章  使用UML进行面向对象设计和建模  18.1  设计面向对象系统    18.1.1  实体类    18.1.2  接口类    18.1.3  控制类    18.1.4  持续类    18.1.5  系统类    18.1.6  设计关系    18.1.7  属性和方法可见性    18.1.8  对象责任  18.2  面向对象设计过程    18.2.1  精炼用例模型    18.2.2  建模支持用例情境的类交互、行为和状态    18.2.3  修改对象模型以反映实现环境  18.3  对象复用和设计模式  18.4  设计模式    18.4.1  策略模式    18.4.2  适配器模式    18.4.3  对象框架和组件  18.5  其他UML设计图和实现图第四部分  系统分析和设计完成后的工作第19章  系统构造和实现  19.1  什么是系统构造和实现  19.2  构造阶段    19.2.1  任务6.1——构建和测试网络(如果需要)    19.2.2  任务6.2——构建和测试数据库    19.2.3  任务6.3——安装和测试新软件包(如果需要)    19.2.4  任务6.4——编写和测试新程序  19.3  实现阶段    19.3.1  任务7.1——进行系统测试    19.3.2  任务7.2——准备转换计划    19.3.3  任务7.3——安装数据库    19.3.4  任务7.4——培训用户    19.3.5  任务7.5——转换到新系统第20章  系统运行和支持  20.1  系统运行和支持的上下文  20.2  系统维护    20.2.1  任务8.1.1——验证问题    20.2.2  任务8.1.2——对程序进行基准测试    20.2.3  任务8.1.3——研究和调试程序    20.2.4  任务8.1.4——测试程序  20.3  系统恢复  20.4  技术支持  20.5  系统改进    20.5.1  任务8.4.1——分析改进请求    20.5.2  任务8.4.2——快速修复    20.5.3  任务8.4.3——恢复现有物理系统  20.6  系统退役词汇表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>系统分析与设计方法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>领域驱动设计与模式实战
第一部分　背景知识  第1章　应重视的价值，也是对过去几年的沉重反思    1.1　总体价值    1.2　应重视的架构风格      1.2.1　焦点之一：模型      1.2.2　焦点之二：用例      1.2.3　如果重视模型，就可以使用领域模型模式      1.2.4　慎重处理数据库      1.2.5　领域模型与关系数据库之间的阻抗失配      1.2.6　谨慎处理分布式      1.2.7　消息传递很重要    1.3　对过程的各个组成部分的评价      1.3.1　预先架构设计      1.3.2　领域驱动设计      1.3.3　测试驱动开发      1.3.4　重构      1.3.5　选择一种还是选择组合    1.4　　持续集成      1.4.1　解决方案(或至少是正确方向上的一大步)      1.4.2　从我的组织汲取的教训      1.4.3　更多信息    1.5　不要忘记运行机制      1.5.1　有关何时需要运行机制的一个例子      1.5.2　运行机制的一些例子      1.5.3　它不仅仅是我们的过错    1.6　小结  第2章　模式起步　32    ……  第3章　TDD与重构第二部分　应用DDD  第4章　新的默认架构  第5章　领域驱动设计进阶  第6章　准备基础架构  第7章　应用规则第三部分　应用PoEAA  第8章　用于持久化的基础架构  第9章　应用NHibernate第四部分　下一步骤  第10章　博采其他设计技术  第11章　关注UI第五部分　附录  附录A　其他领域模型风格  附录B　已讨论的模式的目录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>领域驱动设计与模式实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>构建高可用Linux服务器（第2版）
推荐序一
推荐序二
推荐序三
推荐序四
前言
第1章Linux服务器构建基础/1
1.1Linux服务器的安装方法/2
1.1.1光盘安装CentOS 5.5 x86_64/2
1.1.2使用PXE+DHCP+Apache+KickStart无人值守安装RHEL/12
1.1.3Linux的其他安装方法/17
1.2全面了解Linux服务器/18
1.2.1查看Linux服务器的CPU详细情况/18
1.2.2查看Linux服务器的内存使用情况/19
1.2.3查看Linux服务器的硬盘使用情况/20
1.2.4查看Linux系统的平均负载/23
1.2.5查看Linux系统的其他参数/24
1.3Linux服务器的网络配置/27
1.3.1配置Linux服务器的网络/27
1.3.2查看Linux服务器的网络连接/30
1.3.3查看Linux服务器的进程/38
1.3.4在CentOS 5.5、FreeBSD 8.1及Windows下添加静态路由/42
1.4Linux服务器的日志管理/45
1.4.1系统日志syslog.conf的配置详解/45
1.4.2Linux下的日志维护技巧/46
1.4.3用Shell脚本分析Nginx日志/50
1.5Linux服务器的优化/53
1.5.1根据服务器应用来选购服务器/53
1.5.2CentOS 5.5最小化安装后的优化/57
1.5.3优化Linux下的内核TCP参数以提高系统性能/61
1.5.4生产服务器应尽量选择编译安装软件包/63
1.6用开源工具Nagios监控Linux服务器/64
1.6.1CentOS 5.5下的监控工具简介/64
1.6.2Nagios应该监控的服务器基础选项/65
1.6.3Nagios监控Windows 2003时应注意的事项/66
1.6.4Nagios使用心得/67
1.7项目实施中应该注意的事项/68
1.8小结/70
第2章Linux服务器虚拟化/71
2.1FreeBSD下的jail虚拟机/72
2.1.1jail虚拟机的特点/72
2.1.2在FreeBSD 8.1下安装jail的详细步骤/73
2.1.3使用jexec工具管理jail虚拟机/74
2.1.4使用ezjail工具创建和管理jail虚拟机/75
2.1.5jail在生产环境下的注意事项/78
2.2Linux系统自带的Xen虚拟机/78
2.2.1Xen虚拟机的工作原理及优势/79
2.2.2在CentOS 5.6 x86_64下安装Xen虚拟机/81
2.2.3在CentOS 5.5下安装Xen虚拟机/83
2.2.4安装第一台虚拟机（模板机）/86
2.2.58分钟快速部署虚拟机/88
2.2.6Xen虚拟机的管理/89
2.2.7Xen寄宿服务器的管理/89
2.2.8Xen在生产环境下的应用/92
2.3Citrix XenServer 5.6虚拟机使用心得/95
2.4用VMware Server搭建64位系统测试环境/97
2.5小结/100
第3章生产环境下服务器的故障诊断与排除/101
3.1快速排障的重要性和必要性/102
3.2安装系统时容易发生的错误描述与处理方法/102
3.2.1忘记了CentOS 5.5的root密码怎么办/102
3.2.2正确重设root密码/104
3.2.3安装FreeBSD 8.1时不要设置/boot分区/105
3.2.4CentOS 5.5的Grub引导程序出错/105
3.2.5安装CentOS 5.5时忘了关闭iptables和SELinux/106
3.2.6如何解决PuTTY或PieTTY的乱码问题/107
3.2.7安装双系统时不小心删除了Grub所在的分区/107
3.3网络配置时容易发生的错误描述与处理方法/109
3.3.1安装CentOS 5.5时忘了激活网卡/109
3.3.2 CentOS 5.5网卡文件备份的正确方法/110
3.3.3解决远程桌面超出最大连接数的问题/111
3.3.4在CentOS 5.5下如何正确配置网关/112
3.3.5VMware的机器应该如何配置自动对时/112
3.3.6防火墙初始化的注意事项/113
3.4系统维护时的注意事项/113
3.4.1尽量源码安装，谨慎操作yum/113
3.4.2服务器硬件改动进入了Emergency模式/114
3.4.3如何以普通用户的身份编辑无权限的文件/114
3.4.4在Linux下配置最大文件打开数的方法/114
3.4.5在Crontab下运行PHP程序的正确方法/116
3.4.6在Crontab下正确防止脚本运行冲突/116
3.5紧急处理线上服务器故障的办法/117
3.5.1更改Administrator密码导致计划任务无法执行/117
3.5.2FreeBSD 8.1下的sudoer文件意外损坏/117
3.5.3CentOS 5.5的root密码被恶意篡改/117
3.5.4bash损坏该如何正确处理/118
3.5.5正确操作nohup让程序始终在后台运行/119
3.5.6负载均衡器出现故障/119
3.6检查机房应注意的位置和细节问题/119
3.7系统维护时应注意的非技术因素/120
3.8小结/121
第4章生产环境下的Shell脚本/122
4.1Vim的基础用法及进阶心得/123
4.2Sed的基础用法及实用举例/127
4.2.1Sed的基础语法格式/127
4.2.2Sed的用法举例说明/129
4.3基础正则表达式/134
4.4Linux下强大的查找命令find/139
4.5汇总Linux/UNIX下的bash快捷键/147
4.6生产环境下的Shell脚本分类/148
4.6.1生产环境下的Shell脚本备份类/149
4.6.2生产环境下的开发类Shell脚本/157
4.6.3生产环境下的统计类Shell脚本/159
4.6.4生产环境下的监控类Shell脚本/162
4.6.5生产环境下的自动化类Shell脚本/166
4.6.6生产环境下的安全类Shell脚本/170
4.7小结/173
第5章构建高可用的Linux集群/174
5.1负载均衡高可用的核心概念和常用软件/175
5.1.1什么是负载均衡高可用/175
5.1.2以F5 BIGIP作为负载均衡器/176
5.1.3以LVS作为负载均衡器/176
5.1.4以Nginx作为负载均衡器/182
5.1.5以HAProxy作为负载均衡器/182
5.1.6高可用软件Keepalived/184
5.1.7高可用软件Heartbeat/184
5.1.8高可用块设备DRBD/185
5.2负载均衡中的名词解释/186
5.2.1什么是Session/186
5.2.2什么是Session共享及实现的方法/186
5.2.3什么是会话保持/187
5.3负载均衡器的会话保持机制/188
5.3.1F5 BigIP的会话保持机制/188
5.3.2LVS的会话保持机制/189
5.4Linux集群的项目案例分享/200
5.4.1项目案例一：用Nginx+Keepalived实现在线票务系统/200
5.4.2项目案例二：企业级Web负载均衡高可用之Nginx+Keepalived/207
5.4.3项目案例三：用LVS+Keepalived构建高可用JSP集群/218
5.4.4项目案例四：Nginx主主负载均衡架构/225
5.4.5项目案例五：生产环境下的高可用NFS文件服务器/231
5.4.6项目案例六：HAProxy双机高可用方案之HAProxy+Keepalived/239
5.4.7项目案例七：百万级PV高可用网站架构设计/246
5.4.8项目案例八：千万级PV高性能高并发网站架构设计/247
5.5软件级负载均衡器的特点对比/251
5.6项目实践中Linux集群的总结和思考/252
5.7细分五层解说网站架构/254
5.8网站架构应关注和研究的方向/256
5.9MySQL数据库的优化/258
5.9.1服务器物理硬件的优化/258
5.9.2MySQL应该采用编译安装的方法/258
5.9.3MySQL配置文件的优化/258
5.9.4MySQL上线后根据status状态进行适当优化/264
5.9.5MySQL数据库的可扩展性架构方案/273
5.9.6MySQL双主多从高可用配置方案/274
5.9.7生产环境下的MySQL数据库主从Replication同步/276
5.9.8CentOS 5.6 x86_64下MySQL Proxy 0.8.2的安装及测试/285
5.10生产环境下的MySQL数据库备份/289
5.11部分项目施工图纸/293
5.12小结/295
第6章VPN在企业中的部署应用/296
6.1流行的VPN技术及其分类/297
6.2如何选择自己需要的VPN/299
6.3IPSec VPN的不足/299
6.4OpenVPN的应用范畴/300
6.5经典企业VPN部署案例/300
6.5.1案例一：在CentOS 5.5 x86_64下单网卡配置PPTPD服务器/300
6.5.2案例二：在CentOS 5.5 x86_64下路由模式配置OpenVPN服务器/307
6.5.3案例三：在FreeBSD 8 x86_64下网桥模式配置OpenVPN服务器/317
6.6部署OpenVPN服务器的注意事项/323
6.6.1OpenVPN如何注销用户/323
6.6.2OpenVPN服务器的安全问题/324
6.6.3OpenVPN服务器的负载均衡/325
6.7小结/325
第7章Linux防火墙及系统安全/326
7.1基础网络知识/327
7.1.1OSI网络参考模型/327
7.1.2TCP/IP三次握手/四次挥手的过程详解/328
7.1.3其他基础网络知识/330
7.2Linux防火墙的概念/330
7.3Linux防火墙在企业中的作用/331
7.4Linux防火墙的语法/331
7.5iptables基础知识/335
7.5.1iptables的状态state/335
7.5.2iptables的Conntrack记录/337
7.5.3关于iptables模块的说明/337
7.5.4iptables防火墙初始化的注意事项/337
7.5.5如何保存运行中的iptables规则/338
7.6如何流程化编写iptables脚本/339
7.7学习iptables应该掌握的工具/341
7.7.1命令行的抓包工具TCPDump/341
7.7.2图形化抓包工具Wireshark/342
7.7.3强大的命令行扫描工具Nmap/345
7.7.4安全工具hping/347
7.8iptables的简单脚本学习/349
7.8.1普通的Web主机防护脚本/350
7.8.2如何让别人ping不到自己而自己能ping通别人/351
7.8.3建立安全的vsftpd服务器/353
7.9线上生产服务器的iptables脚本/357
7.9.1安全的主机iptables防火墙脚本/358
7.9.2自动分析黑名单及白名单的iptables脚本/359
7.9.3利用recent模块限制同一IP的连接数/362
7.9.4利用DenyHosts工具和脚本来防止SSH暴力破解/364
7.9.5将iptables作为企业的NAT路由器/368
7.9.6如何使用工具精确地监控NAT路由器/371
7.10TCP_wrappers应用级防火墙的介绍和应用/376
7.11系统运维工作中的Linux防火墙总结/378
7.12Linux系统自身的安全防护/379
7.12.1SELinux简介/379
7.12.2SELinux的相关设置/379
7.13Linux系统安全相关的工具/380
7.13.1Rootkit检测工具Chkrootkit/381
7.13.2文件系统完整性检查工具Tripwire/383
7.13.3防恶意扫描软件PortSentry/388
7.14Linux服务器基础防护篇/393
7.15如何防止入侵/394
7.16小结/395
第8章如何构建开源免费的企业级邮件系统/396
8.1DNS服务器的架设/397
8.1.1邮件服务器与DNS的关系/397
8.1.2如何架设内部DNS服务器/399
8.1.3如何以源码方式安装公网DNS服务器/406
8.1.4维护DNS服务器应该注意的事项/413
8.2电子邮件的传输过程/416
8.3如何搭建开发邮件服务器/417
8.3.1搭建Sendmail+Dovecot邮件系统/417
8.3.2搭建Postfix+Dovecot邮件系统/420
8.4搭建iRedMail企业级邮件服务器/423
8.4.1iRedMail企业级邮件服务器的介绍/423
8.4.2在CentOS 5.2 x86_64上安装iRedMail 0.4.0/424
8.4.3Postfix本身的防垃圾功能/427
8.4.4iRedMail 0.4.0特有的防垃圾技术/432
8.4.5iRedMail 0.4.0如何利用ClamAV防病毒/436
8.4.6iRedMail 0.4.0邮件服务器的网络安全/437
8.4.7iRedMail 0.4.0邮件服务器系统的监控/439
8.4.8iRedMail 0.4.0的系统文件备份/441
8.4.9iRedMail 0.4.0的MySQL数据库备份方案/445
8.4.10维护iRedMail 0.4.0邮件服务器的一些注意事项/451
8.5小结/452
第9章系统管理员在企业中的职业定位及发展方向/454
9.1系统管理员的概念和工作职责/455
9.2系统管理员应该熟悉的系统/456
9.3系统管理员应该熟悉的工具/460
9.4Linux的学习及进阶之路/464
9.5系统管理员应该如何工作/467
9.6系统管理员的发展方向/469
9.7系统管理员如何进阶为系统架构师/470
9.8系统管理员之企业生存守则/471
9.9小结/474
附录AXmanager 3.0企业版实用技巧集锦/475
附录B使用Screen管理远程会话/485
附录C自动化部署管理工具Puppet/487
附录D在CentOS 5.5下配置rsync服务器/493
附录Ersync+inotify实现数据的实时同步更新/498
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>构建高可用Linux服务器（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件构架实践
第Ⅰ部分 预想构架
第1章 构架商业周期
1.1 构架的产生
1.2 软件过程和构架商业周期
1.3 什么样的构架才算好
1.4 小结
1.5 讨论题
第2章 什么是软件构架
2.1 软件构架概念澄清
2.2 其他观点
2.3 构架模式、参考模型和参考构架
2.4 为什么说软件构架非常重要
2.5 构架结构和视图
2.6 小结
2.7 可进一步参阅的文献
2.8 讨论题
第3章 A-7E案例分析：各种构架结构的运用
3.1 与构架商业周期的关系
3.2 需求与质量
3.3 A-7E航空电子系统的构架
3.4 小结
3.5 可进一步参阅的文献
3.6 讨论题
第Ⅱ部分 创建构架
第4章 理解质量属性
4.1 功能性和构架
4.2 构架和质量属性
4.3 系统的质量属性
4.4 实践中的质量属性场景
4.5 其他系统质量属性
4.6 商业质量属性
4.7 构架的质量属性
4.8 小结
4.9 可进一步参阅的文献
4.10 讨论题
第5章 实现质量属性
5.1 战术介绍
5.2 可用性战术
5.3 可修改性战术
5.4 性能战术
5.5 安全性战术
5.6 可测试性战术
5.7 易用性战术
5.8 战术与构架模式的关系
5.9 构架模式和样式
5.10 小结
5.11 可进一步参阅的文献
5.12 讨论题
第6章 空中交通管制：高可用性设计案例分析
6.1 与构架商业周期的关系
6.2 需求与质量
6.3 构架解决方案
6.4 小结
6.5 可进一步参阅的文献
6.6 讨论题
第7章 设计构架
7.1 生命期中的构架
7.2 设计构架
7.3 形成团队结构
7.4 创建骨架系统
7.5 小结
7.6 可进一步参阅的文献
7.7 讨论题
第8章 飞行模拟：构架可集成性案例分析
8.1 与构架商业周期的关系
8.2 需求与质量
8.3 构架解决方案
8.4 小结
8.5 可进一步参阅的文献
8.6 讨论题
第9章 构架编档
9.1 构架编档的使用
9.2 视图
9.3 选择相关视图
9.4 视图编档
9.5 跨视图的文档
9.6 统一建模语言
9.7 小结
9.8 可进一步参阅的文献
9.9 讨论题
第10章 软件构架重构
10.1 介绍
10.2 信息提取
10.3 数据库构造
10.4 视图融合
10.5 重构
10.6 示例
10.7 小结
10.8 可进一步参阅的文献
10.9 讨论题
第Ⅲ部分 分析构架
第11章 ATAM：一种进行构架评估的综合方法
11.1 ATAM的参与人员
11.2 ATAM的结果
11.3 ATAM的阶段
11.4 Nightingale系统：应用ATAM的案例分析
11.5 小结
11.6 可进一步参阅的文献
11.7 讨论题
第12章 CBAM：构架设计决策制定的定量方法
12.1 制定决策的上下文
12.2 CBAM的基础
12.3 实现CBAM
12.4 案例分析：NASA ECS项目
12.5 CBAM评估的结果
12.6 小结
12.7 可进一步参阅的文献
12.8 讨论题
第13章 万维网：可互操作性案例分析
13.1 与构架商业周期的关系
13.2 需求和质量
13.3 构架解决方案
13.4 基于Web的电子商务构架的演变
13.5 实现质量属性
13.6 当今的构架商业周期
13.7 小结
13.8 可进一步参阅的文献
13.9 讨论题
第Ⅳ部分 从一个系统到多个系统
第14章 软件产品线：重用构架资产
14.1 概述
14.2 软件产品线有效的原因
14.3 确定范围
14.4 产品线构架
14.5 采用软件产品线的困难之处
14.6 小结
14.7 可进一步参阅的文献
14.8 讨论题
第15章 CelsiusTech公司：产品线开发案例分析
15.1 与构架商业周期的关系
15.2 需求与质量
15.3 构架解决方案
15.4 小结
15.5 可进一步参阅的文献
15.6 讨论题
第16章 J2EE/EJB：工业标准计算基础结构的案例分析
16.1 与构架商业周期的关系
16.2 需求和质量
16.3 构架解决方案
16.4 系统部署决策
16.5 小结
16.6 可进一步参阅的文献
16.7 讨论题
第17章 Luther构架：使用J2EE的移动应用案例分析
17.1 与构架商业周期的关系
17.2 需求和质量
17.3 构架解决方案
17.4 Luther如何实现其质量目标
17.5 小结
17.6 可进一步参阅的文献
17.7 讨论题
第18章 用商业组件构建系统
18.1 组件对构架的影响
18.2 构架不匹配
18.3 作为搜索的基于组件的设计
18.4 ASEILM示例
18.5 小结
18.6 可进一步参阅的文献
第19章 未来的软件构架
19.1 重新认识构架商业周期
19.2 创建构架
19.3 生命期中的构架
19.4 商业组件的影响
19.5 小结
附录A 缩略语表
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件构架实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>日志管理与分析权威指南
译者序
作者简介
序言
前言
第1章　木材、树木、森林 1
1.1　概述 1
1.2　日志数据基础 2
1.2.1　什么是日志数据 2
1.2.2　日志数据是如何传输和收集的 3
1.2.3　什么是日志消息 5
1.2.4　日志生态系统 6
1.3　看看接下来的事情 12
1.4　被低估的日志 13
1.5　日志会很有用 14
1.5.1　资源管理 14
1.5.2　入侵检测 14
1.5.3　故障排除 17
1.5.4　取证 17
1.5.5　无聊的审计，有趣的发现 18
1.6　人、过程和技术 19
1.7　安全信息和事件管理（siem） 19
1.8　小结 22
参考文献 22
第2章　日志是什么 23
2.1　概述 23
2.2　日志的概念 25
2.2.1　日志格式和类型 27
2.2.2　日志语法 32
2.2.3　日志内容 35
2.3　良好日志记录的标准 36
2.4　小结 38
参考文献 38
第3章　日志数据来源 39
3.1　概述 39
3.2　日志来源 39
3.2.1　syslog 40
3.2.2　snmp 45
3.2.3　windows事件日志 48
3.3　日志来源分类 50
3.3.1　安全相关主机日志 50
3.3.2　安全相关的网络日志 52
3.3.3　安全主机日志 52
3.4　小结 54
第4章　日志存储技术 55
4.1　概述 55
4.2　日志留存策略 55
4.3　日志存储格式 57
4.3.1　基于文本的日志文件 57
4.3.2　二进制文件 59
4.3.3　压缩文件 59
4.4　日志文件的数据库存储 60
4.4.1　优点 61
4.4.2　缺点 61
4.4.3　定义数据库存储目标 61
4.5　hadoop日志存储 63
4.5.1　优点 63
4.5.2　缺点 64
4.6　云和hadoop 64
4.6.1　amazon elastic mapreduce入门 64
4.6.2　浏览amazon 64
4.6.3　上传日志到amazon简单存储服务（s3） 65
4.6.4　创建一个pig脚本分析apache访问日志 67
4.6.5　在amazon elastic mapreduce (emr)中处理日志数据 68
4.7　日志数据检索和存档 70
4.7.1　在线存储 70
4.7.2　近线存储 70
4.7.3　离线存储 70
4.8　小结 70
参考文献 71
第5章　syslog-ng案例研究 72
5.1　概述 72
5.2　获取syslog-ng 72
5.3　什么是syslog-ng 73
5.4　部署示例 74
5.5　syslog-ng故障排除 77
5.6　小结 79
参考文献 79
第6章　隐蔽日志 80
6.1　概述 80
6.2　完全隐藏日志设置 82
6.2.1　隐藏日志生成 82
6.2.2　隐藏日志采集 82
6.2.3　ids日志源 83
6.2.4　日志收集服务器 83
6.2.5　“伪”服务器或“蜜罐” 85
6.3　在“蜜罐”中的日志记录 85
6.3.1　蜜罐网络的隐蔽shell击键记录器 86
6.3.2　蜜罐网络的sebek2案例研究 87
6.4　隐蔽日志通道简述 88
6.5　小结 89
参考文献 89
第7章　分析日志的目标、规划和准备 90
7.1　概述 90
7.2　目标 90
7.2.1　过去的问题 91
7.2.2　未来的问题 92
7.3　规划 92
7.3.1　准确性 92
7.3.2　完整性 93
7.3.3　可信性 93
7.3.4　保管 94
7.3.5　清理 94
7.3.6　规范化 94
7.3.7　时间的挑战 95
7.4　准备 96
7.4.1　分解日志消息 96
7.4.2　解析 96
7.4.3　数据精简 96
7.5　小结 98
第8章　简单分析技术 99
8.1　概述 99
8.2　一行接一行：绝望之路 100
8.3　简单日志查看器 101
8.3.1　实时审核 101
8.3.2　历史日志审核 102
8.3.3　简单日志操纵 103
8.4　人工日志审核的局限性 105
8.5　对分析结果做出响应 105
8.5.1　根据关键日志采取行动 106
8.5.2　根据非关键日志的摘要采取行动 107
8.5.3　开发行动计划 109
8.5.4　自动化的行动 109
8.6　示例 110
8.6.1　事故响应的场景 110
8.6.2　例行日志审核 110
8.7　小结 111
参考文献 111
第9章　过滤、规范化和关联 112
9.1　概述 112
9.2　过滤 114
9.3　规范化 115
9.3.1　ip地址验证 116
9.3.2　snort 116
9.3.3　windows snare 117
9.3.4　通用cisco ios消息 117
9.3.5　正则表达式性能考虑因素 118
9.4　关联 119
9.4.1　微观关联 121
9.4.2　宏观关联 122
9.4.3　使用环境中的数据 125
9.4.4　简单事件关联器 126
9.4.5　状态型规则示例 127
9.4.6　构建自己的规则引擎 132
9.5　常见搜索模式 139
9.6　未来 140
9.7　小结 140
参考文献 140
第10章　统计分析 141
10.1　概述 141
10.2　频率 141
10.3　基线 142
10.3.1　阈值 145
10.3.2　异常检测 145
10.3.3　开窗 145
10.4　机器学习 146
10.4.1　knn算法 146
10.4.2　将knn算法应用到日志 146
10.5　结合统计分析和基于规则的关联 147
10.6　小结 148
参考文献 148
第11章　日志数据挖掘 149
11.1　概述 149
11.2　数据挖掘简介 150
11.3　日志数据挖掘简介 153
11.4　日志数据挖掘需求 155
11.5　挖掘什么 155
11.6　深入感兴趣的领域 157
11.7　小结 158
参考文献 158
第12章　报告和总结 159
12.1　概述 159
12.2　定义最佳报告 160
12.3　身份认证和授权报告 160
12.4　变更报告 161
12.5　网络活动报告 163
12.6　资源访问报告 164
12.7　恶意软件活动报告 165
12.8　关键错误和故障报告 166
12.9　小结 167
第13章　日志数据可视化 168
13.1　概述 168
13.2　视觉关联 168
13.3　实时可视化 169
13.4　树图 169
13.5　日志数据合成 170
13.6　传统日志数据图表 175
13.7　小结 176
参考文献 176
第14章　日志法则和日志错误 177
14.1　概述 177
14.2　日志法则 177
14.2.1　法则1——收集法则 178
14.2.2　法则2——留存法则 178
14.2.3　法则3——监控法则 178
14.2.4　法则4——可用性法则 179
14.2.5　法则5——安全性法则 179
14.2.6　法则6——不断变化法则 179
14.3　日志错误 179
14.3.1　完全没有日志 180
14.3.2　不查看日志数据 181
14.3.3　保存时间太短 182
14.3.4　在收集之前排定优先顺序 183
14.3.5　忽略应用程序日志 184
14.3.6　只搜索已知的不良条目 184
14.4　小结 185
参考文献 185
第15章　日志分析和收集工具 186
15.1　概述 186
15.2　外包、构建或者购买 186
15.2.1　构建一个解决方案 187
15.2.2　购买 187
15.2.3　外包 188
15.2.4　问题 189
15.3　日志分析基本工具 189
15.3.1　grep 189
15.3.2　awk 191
15.3.3　microsoft日志解析器 192
15.3.4　其他可以考虑的基本工具 193
15.3.5　基本工具在日志分析中的作用 194
15.4　用于集中化日志分析的实用工具 195
15.4.1　syslog 195
15.4.2　rsyslog 196
15.4.3　snare 197
15.5　日志分析专业工具 197
15.5.1　ossec 198
15.5.2　ossim 200
15.5.3　其他值得考虑的分析工具 201
15.6　商业化日志工具 202
15.6.1　splunk 202
15.6.2　netiq sentinel 203
15.6.3　ibm q1labs 203
15.6.4　loggly 204
15.7　小结 204
参考文献 204
第16章　日志管理规程 205
16.1　概述 205
16.2　假设、需求和预防措施 206
16.2.1　需求 206
16.2.2　预防措施 207
16.3　常见角色和职责 207
16.4　pci和日志数据 208
16.4.1　关键需求10 208
16.4.2　与日志记录相关的其他需求 211
16.5　日志记录策略 213
16.6　审核、响应、升级规程 初始基线 217
16.6.3　人工构建初始基线 219
16.6.4　主要工作流程：每天日志审核 220
16.6.5　异常调查与分析 222
16.6.6　事故响应和升级 225
16.7　日志审核的验证 225
16.7.1　日志记录的证据 226
16.7.2　日志审核的证据 226
16.7.3　异常处理的证据 226
16.8　日志簿——异常调查的证据 227
16.8.1　日志簿推荐格式 227
16.8.2　日志簿条目示例 228
16.9　pci依从性证据包 230
16.10　管理报告 230
16.11　定期运营任务 231
16.11.1　每日任务 231
16.11.2　每周任务 232
16.11.3　每月任务 232
16.11.4　季度任务 233
16.11.5　年度任务 233
16.12　其他资源 233
16.13　小结 233
参考文献 234
第17章　对日志系统的攻击 235
17.1　概述 235
17.2　各类攻击 235
17.2.1　攻击什么 236
17.2.2　对机密性的攻击 236
17.2.3　对完整性的攻击 241
17.2.4　对可用性的攻击 245
17.3　小结 252
参考文献 252
第18章　供程序员使用的日志 253
18.1　概述 253
18.2　角色与职责 253
18.3　程序员所用的日志记录 254
18.3.1　日志应该记录哪些信息 255
18.3.2　程序员使用的日志记录api 256
18.3.3　日志轮转 257
18.3.4　不好的日志消息 259
18.3.5　日志消息格式 259
18.4　安全考虑因素 261
18.5　性能考虑因素 262
18.6　小结 263
参考文献 263
第19章　日志和依从性 264
19.1　概述 264
19.2　pci dss 265
19.3　iso 2700x系列 269
19.4　hipaa 271
19.5　fisma 276
19.6　小结 281
第20章　规划自己的日志分析系统 282
20.1　概述 282
20.2　规划 282
20.2.1　角色和职责 283
20.2.2　资源 284
20.2.3　目标 284
20.2.4　选择日志记录的系统和设备 285
20.3　软件选择 285
20.3.1　开源软件 285
20.3.2　商业化软件 286
20.4　策略定义 287
20.4.1　日志记录策略 287
20.4.2　日志文件轮转 288
20.4.3　日志数据收集 288
20.4.4　留存/存储 288
20.4.5　响应 289
20.5　架构 289
20.5.1　基本模型 289
20.5.2　日志服务器和日志收集器 290
20.5.3　日志服务器和具备长期存储的日志收集器 290
20.5.4　分布式部署 290
20.6　扩展 291
20.7　小结 291
第21章　云日志 292
21.1　概述 292
21.2　云计算 293
21.2.1　服务交付模型 293
21.2.2　云部署模型 294
21.2.3　云基础设施特性 295
21.2.4　标准？我们不需要讨厌的标准 295
21.3　云日志 296
21.4　监管、依从性和安全问题 300
21.5　云中的大数据 301
21.6　云中的siem 303
21.7　云日志的优缺点 304
21.8　云日志提供者目录 305
21.9　其他资源 305
21.10　小结 305
参考文献 306
第22章　日志标准和未来的趋势 307
22.1　概述 307
22.2　从今天推知未来 308
22.2.1　更多的日志数据 308
22.2.2　更多动力 309
22.2.3　更多分析 310
22.3　日志的未来和标准 310
22.4　渴望的未来 314
22.5　小结 314
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>日志管理与分析权威指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MySQL内核：InnoDB存储引擎 卷1
第1章　概览
1.1　InnoDB 存储引擎历史
1.2　源码版本
1.3　源码风格
1.3.1　源码结构
1.3.2　代码风格
1.4　代码编译
1.5　阅读源码次序
1.6　思考题
1.7　继续阅读
第2章　基本数据结构与算法
2.1　相关文件
2.2　内存管理系统
2.2.1　内存管理
2.2.2　通用内存池
2.3　哈希表
2.3.1　哈希算法
2.3.2　数据结构
2.4　双链表
2.4.1　内存双链表
2.4.2　磁盘双链表
2.5　其他数据结构和算法
2.5.1　动态数组
2.5.2　排序
2.6　小结
2.7　思考题
2.8　继续阅读
第3章　同步机制
3.1　相关文件
3.2　基础知识
3.2.1　memory model
3.2.2　mutual exclution
3.2.3　Atomic Read-Modify-Write Operation
3.2.4　spin lock
3.2.5　死锁
3.3　InnoDB 同步机制
3.3.1　mutex
3.3.2　rw-lock
3.3.3　wait array
3.3.4　死锁检测
3.4　小结
3.5　思考题
3.6　继续阅读
第4章　重做日志
4.1　相关文件
4.2　相关概念
4.2.1　简介
4.2.2　物理逻辑日志
4.2.3　LSN
4.2.4　检查点
4.2.5　归档日志
4.2.6　恢复
4.3　物理存储结构
4.3.1　重做日志物理架构
4.3.2　重做日志块
4.3.3　重做日志组与文件
4.4　相关数据结构
4.4.1　log_group_struct
4.4.2　log_struct
4.5　组提交
4.6　恢复
4.6.1　数据结构
4.6.2　重做日志恢复
4.7　总结
4.8　思考题
4.9　继续阅读
第5章　mini-transaction
5.1　相关文件
5.2　mini-transaction 介绍
5.2.1　基本概念
5.2.2　The FIX Rules
5.2.3　Write-Ahead Log（WAL）
5.2.4　Force-log-at-commit
5.3　具体实现
5.3.1　数据结构
5.3.2　物理逻辑日志的实现
5.3.3　mini-transaction 的使用
5.4　示例
5.5　小结
5.6　思考题
5.7　继续阅读
第6章　存储管理
6.1　相关文件
6.2　物理存储
6.2.1　页
6.2.2　区
6.2.3　段
6.2.4　表空间
6.3　数据结构
6.3.1　概述
6.3.2　fil_system_struct
6.3.3　fil_space_struct
6.3.4　fil_node_struct
6.4　异步 I/O
6.4.1　异步 I/O 数据结构
6.4.2　异步 I/O 线程
6.5　总结
6.6　思考题
6.7　继续阅读
第 7 章　记录
7.1　相关文件
7.2　概述
7.3　物理记录
7.3.1　物理记录格式
7.3.2　大记录格式
7.3.3　伪记录
7.4　逻辑记录
7.5　记录之间的比较
7.6　行记录版本
7.7　小结
7.8　思考题
7.9　继续阅读
第8章　索引页
8.1　相关文件
8.2　页
8.3　存储结构
8.3.1　Page Header
8.3.2　Page Directory
8.3.3　示例
8.4　Page Cursor
8.4.1　定位记录
8.4.2　插入记录
8.4.3　删除记录
8.4.4　并发控制
8.5　小结
8.6　思考题
8.7　继续阅读
第9章　锁
9.1　相关文件
9.2　锁与事务
9.2.1　隔离性
9.2.2　事务的隔离级别
9.2.3　幻读
9.3　InnoDB 存储引擎中锁的类型与算法
9.4　锁的内部实现
9.4.1　数据结构
9.4.2　锁的并发控制
9.4.3　锁的类型与模式
9.4.4　锁的兼容性
9.5　显式锁和隐式锁
9.5.1　显式锁与隐式锁的区别
9.5.2　聚集索引记录的隐式锁
9.5.3　辅助索引记录的隐式锁
9.6　加锁操作
9.6.1　加锁流程
9.6.2　加锁过程
9.7　行锁的维护
9.7.1　插入
9.7.2　更新
9.7.3　PURGE
9.7.4　一致性的锁定读
9.7.5　页的分裂
9.7.6　页的合并
9.8　自增锁
9.9　死锁
9.9.1　死锁的概念
9.9.2　死锁概率
9.9.3　死锁的示例
9.10　小结
9.11　思考题
9.12　继续阅读
第10章　B+树索引
10.1　B+ 树
10.1.1　概述
10.1.2　插入
10.1.3　删除
10.2　B+ 树索引
10.2.1　索引的特点
10.2.2　聚集索引
10.2.3　辅助索引
10.2.4　填充因子
10.3　InnoDB 存储引擎 B+ 树索引实现
10.3.2　相关 latch
10.3.3　整理
10.3.4　分裂
10.3.5　合并
10.4　查找
10.4.1　mode
10.4.2 latch_mode
10.4.3　cursor
10.5　DML 操作
10.5.1　插入
10.5.2　非主键更新
10.5.3　主键更新
10.5.4　删除
10.6　持久游标
10.7　自适应哈希索引
10.7.1　实现原理
10.7.2　创建哈希索引
10.7.3　哈希索引的维护
10.7.4　自适应哈希索引的优缺点
10.8　小结
10.9　思考题
10.10　继续阅读
第11章　Insert Buffer
11.1　相关文件
11.2　基本概念
11.3　架构实现
11.3.1　存储结构
11.3.2　逻辑控制
11.3.3　示例
11.4　相关数据结构
11.5　死锁
11.5.1　latch 顺序
11.5.2　并发控制
11.5.3　异步 I/O 线程
11.6　维护
11.6.1　记录合并
11.6.2　空间收缩
11.7　小结
11.8　思考题
11.9　继续阅读
第12章　缓冲池
12.1　相关文件
12.2　概述
12.2.1　缓冲池
12.2.2　LRU、Free 和 Flush 链表
12.2.3　基本数据结构
12.3　缓冲池的管理
12.3.1　LRU 算法
12.3.2　LRU 链表维护
12.3.3　页的分配
12.4　页的读取
12.4.1　物理读取
12.4.2　随机预读
12.4.3　线性预读
12.4.4　逻辑读取
12.5　页的刷新
12.5.1　检查点
12.5.2　部分写的问题
12.5.3　刷新的实现
12.6　小结
12.7　思考题
12.8　继续阅读
第13章　事务处理
13.1 相关文件
13.2 事务
13.2.1 概述
13.2.2 分类
13.2.1 隔离级别
13.3 事务系统结构
13.3.1 事务系统段
13.3.2 数据结构
13.4 DOUBLEWRITE 段
13.5 UNDO 日志存储
13.5.1 简介
13.5.2 实现结构
13.5.3 回滚段
13.5.4 UNDO 段
13.6 UNDO 记录
13.6.1 存储结构
13.6.2 INSERT UNDO LOG RECORD
13.6.3 UPDATE UNDO LOG RECORD
13.7 PURGE
13.7.1 清理操作
13.7.2 实现原理
13.8 ROLLBACK
13.8.1 回滚指针
13.8.2 回滚操作
13.9 COMMIT
13.10 kernel_mutex 与并发控制
13.11 小结
13.12 思考题
13.13 继续阅读
第14章　数据字典
14.1 相关文件
14.2 数据字典概述
14.3 主要数据对象
14.3.1 数据字典系统
14.3.2 表定义
14.3.3 索引定义
14.3.4 外键约束定义
14.3.5 其他数据对象定义
14.4 InnoDB 系统表对象
14.4.1 SYS_TABLES
14.4.2 SYS_COLUMNS
14.4.3 SYS_INDEXES
14.4.4 SYS_FIELDS
14.4.5 其他表对象
14.5 数据字典创建
14.5.1 数据字典段
14.5.2 数据字典物理结构
14.5.3 数据字典初始化
14.5.4 数据字典缓存组织
14.6 数据字典对象加载
14.6.1 用户表加载
14.6.2 用户索引和外键约束加载
14.7 小结
14.8 思考题
14.9 继续阅读
第15章　服务管理
15.1 相关文件
15.2 初始化 InnoDB 存储引擎
15.2.1 相关重要参数
15.2.2 服务管理相关数据结构
15.2.3 文件创建和加载
15.2.4 启动后台线程
15.3 关闭 InnoDB 存储引擎
15.3.1 数据持久化
15.3.2 资源释放
15.4 master 线程
15.4.1 主要功能
15.4.2 数据刷盘策略
15.5 锁超时监控线程
15.6 思考题
15.7 继续阅读
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MySQL内核：InnoDB存储引擎 卷1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算
第一章  序  要点：变革无处不在,不可预期之事至关重要  风起云涌  变革无处不在  革新,公司的生命线  应付商业阵痛的灵丹妙药  云计算不仅仅是一个超级计算机  参考文献第二章  风乍起：将自己置于云雾之中  要点：云究竟是什么？  什么是云？  云背后隐藏的技术  回溯过去  近距离观察  可扩展性  云不仅仅为车库里的创业型小公司而存在，它也为财富强及其他公司而存在  追古溯今  要点小结  参考文献第三章  云：有何用处？你将用它来干什么？  要点：你将拿云来做什么？  SO与万物兼服务  SO与商业糅合：墙壁倒塌了  Web 2.0与大简化  Web 2.0及智能代理  要点小结  参考文献第四章  云中如何完成工作  要点：云中的工作到底是怎么完成的  什么是商业流程？  由流程管理的企业  在云中完成工作  工作处理器  商业流程工具  云中的商业运营平台  要点小结  参考文献第五章  创新之子  要点：云中的开放式创新  创新有何新意？  全球化与知识的商品化  开放式创新  客户驱动的创新  正在兴起的创新科学  创新型文化  在云中求知  要点小结  参考文献第六章  Work 2.0：人际交互管理  要点：云中的人际交互  让云来驯服信息过剩  隐式合作中的人际交流  利用人际交互管理系统实现显式合作  将这一切串起来  要点小结  参考文献第七章  管理的终结  要点：云中的领导方式  管理的终结  当团队支配这个世界  生物团队  要点小结  参考文献第八章  跋  要点：云作为一个商业平台  不要再为Gret Depression 2.0而哀嚎  认认真真地想想云  参考文献附录一  本书术语一览附录二  TehTrget关于云的有趣术语附录三  安迪·穆荷兰的技术预言
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>互联网运营智慧
目 录
第1章 引子：拥抱开源，上上之选 1
第2章 定制化安装操作系统 3
2.1 概述 4
2.1.1 为什么需要定制化安装操作系统 4
2.1.2 定制化安装操作系统所包含的主要项目 4
2.1.3 定制化安装操作系统的原则 5
2.2 定制安装centos 5 5
2.2.1 初始引导阶段 6
2.2.2 定制分区阶段 7
2.2.3 系统配置阶段 9
2.2.4 包选择阶段 12
2.2.5 正式安装阶段 14
2.2.6 第一次重启设定阶段 14
2.3 定制化安装freebsd 15
2.3.1 初始引导阶段 15
2.3.2 定制阶段 15
2.3.3 安装介质选择阶段 20
2.3.4 安装阶段 21
2.3.5 系统设定阶段 21
.2.3.6 安装检查 23
2.4 从u盘引导安装centos到服务器 23
2.4.1 基本思路和需求 24
2.4.2 安装前的处理 24
2.4.3 开始安装 29
2.5 高级特性以及非技术策略 29
2.5.1 安装系统经验之谈 29
2.5.2 选择哪一种操作系统更好 30
2.5.3 规避失败 30
第3章 动态网站 31
3.1 概述 32
3.2 部署apache服务 33
3.2.1 安装apache 33
3.2.2 检验安装情况 34
3.3 安装mysql 35
3.3.1 安装mysql客户端程序 35
3.4 apache整合php 36
3.4.1 安装php 36
3.4.2 验证安装 39
3.4.3 牛刀小试：部署一个blog 40
3.4.4 整合自动化 43
3.5 apache整合tomcat 51
3.5.1 安装jdk 51
3.5.2 安装tomcat 51
3.5.3 整合 52
3.5.4 整合验证 54
3.6 动态站点的运行维护 55
3.6.1 状态查看及监控 55
3.6.2 故障处理 56
3.6.3 数据备份/恢复/站点迁移 57
3.7 动态站点故障处理实例汇集 58
3.7.1 案例一： httpd-2.2.0虚拟主机目录权限问题 58
3.7.2 案例二：一次故障处理过程 60
3.7.3 案例三：数据库引起的故障 63
第4章 域名系统bind 65
4.1 bind基本功能的实现 66
4.1.1 安装bind 66
4.1.2 配置bind 68
4.1.3 启动和验证bind服务 77
4.2 多域名dns服务 80
4.2.1 主配置文件的更新 80
4.2.2 撰写区数据文件formyz.net.zone 80
4.2.3 bind启动和验证 81
4.3 带视图功能view的dns系统 81
4.3.1 场景描述 81
4.3.2 配置bind view 82
4.4 辅助dns服务 87
4.4.1 tsig key 88
4.4.2 主配置文件named.conf 89
4.4.3 区数据文件 94
4.4.4 启动和验证主从dns服务 94
4.5 dns运行维护 95
4.5.1 数据备份 95
4.5.2 状态监控 95
4.5.3 故障处理 96
第5章 postfix电子邮件系统 97
5.1 需求及所需环境 98
5.2 前期准备工作 100
5.2.1 下载所需的软件 100
5.2.2 清理系统 100
5.2.3 创建邮件系统运行时所需的用户和组 101
5.3 安装web应用环境 102
5.3.1 安装apache 102
5.3.2 安装mysql 103
5.3.3 安装php 104
5.4 安装和配置sasl及authlib 106
5.4.1 安装和配置courier-authlib 106
5.4.2 安装和配置sasl 108
5.5 安装和配置postfixadmin 110
5.5.1 修改相关的配置文件 111
5.5.2 在mysql中创建postfix所需的数据库 115
5.5.3 测试postfixadmin 115
5.6 postfix的安装和配置 117
5.6.1 安装postfix 117
5.6.2 配置postfix 118
5.7 courier-imap的安装和配置 125
5.7.1 安装courier-imap 125
5.7.2 修改配置文件 125
5.7.3 复制文件 courier-imap.sysvinit 126
5.7.4 测试imap服务 126
5.7.5 使用pop3 over ssl 126
5.8 安装courier-maildrop 127
5.9 邮件病毒检查和垃圾邮件过滤 129
5.9.1 安装和配置clamav 130
5.9.2 安装和配置amavis-new 131
5.10 webmail的安装和配置 133
5.10.1 安装extmail 133
5.10.2 配置extmail 134
5.11 验证所有的配置 139
5.11.1 apache、mysql和php环境验证 139
5.11.2 authlib验证 139
5.11.3 病毒库和垃圾邮件列表更新 140
5.11.4 postfix及imap 140
5.11.5 防病毒及反垃圾邮件 140
5.11.6 总体功能验证 141
5.12 邮件系统维护 142
5.12.1 状态及服务监控 142
5.12.2 故障处理 142
5.12.3 数据备份 142
5.12.4 帐号管理 145
5.12.5 安全防护 145
5.13 高级特性和杂项 148
5.13.1 多邮件域及用户限额 148
5.13.2 密码不匹配问题 149
5.13.3 来自网友的博文——配置postfix成功之后想说的事情 150
5.13.4 某个专门的postfix邮件服务器运行时的进程快照 151
第6章 负载均衡及服务器集群（lvs） 155
6.1 lvs核心ipvs 158
6.1.1 安装ipvs 158
6.1.2 lvs客户端 159
6.1.3 lvs客户端的验证 161
6.2 故障隔离、失败切换框架keepalived 164
6.2.1 keepalived的体系结构 164
6.2.2 keepalived的安装 165
6.2.3 keepalived的安装验证 166
6.2.4 配置文件keepalived.conf 170
6.3 cdn缓存服务器的负载均衡（lvs+keepalived） 174
6.3.1 cdn缓存服务器集群场景 175
6.3.2 cdn缓存服务器集群部署 175
6.3.3 负载均衡服务的启用和验证 181
6.4 多vrrp_instance 负载均衡的应用 186
6.4.1 多vrrp_instance负载均衡的需求描述 186
6.4.2 多vrrp负载均衡集群部署 187
6.4.3 多vrrp_instance负载均衡集群功能测试 194
6.5 lvs负载均衡集群的运行维护 195
6.5.1 对象的新增、变更及删除 196
6.5.2 状态监控 197
6.5.3 故障的排查处理 198
6.5.4 数据备份 199
6.6 杂项 200
6.6.1 lvs负载均衡转发模式及调度算法 200
6.6.2 负载均衡器的调度算法 201
6.6.3 lvs负载均衡环境的安全问题 201
6.6.4 同义词 201
6.6.5 关于负载均衡器后面真实服务器的数量 201
6.6.6 话题讨论 202
第7章 简单cdn 203
7.1 cdn概 述 204
7.1.1 为什么使用cdn 204
7.1.2 cdn适用的场合 205
7.1.3 cdn的组成 205
7.1.4 cdn的基本特点 207
7.1.5 什么是简单cdn 207
7.2 简单cdn的设计 208
7.2.1 简单cdn设计的基本原则 209
7.2.2 需求描述 209
7.2.3 简单cdn的设计 209
7.3 简单cdn的实现 212
7.3.1 源站的部署和运行 212
7.3.2 缓存服务器的部署和运行 216
7.3.3 智能dns的部署和运行 223
7.4 简单cdn的整体效果测试 240
7.5 简单cdn的平台监控 241
7.5.1 主机资源监控 241
7.5.2 服务监控 241
7.5.3 页面内容监控 242
7.6 简单cdn系统上线 242
7.7 简单cdn的运行维护 242
7.7.1 缓存刷新操作 242
7.7.2 备份数据 244
7.7.3 故障处理与恢复 244
7.7.4 增加cdn布点 244
7.8 杂项 244
7.8.1 部署cdn的重点和难点 244
7.8.2 取得和归类中国大陆ip地址列表 245
7.8.3 应急处理 246
第8章 分布式文件系统moosefs 247
8.1 关于moosefs 249
8.1.1 mfs的特性 249
8.1.2 mfs文件系统的组成 250
8.1.3 mfs读写处理过程 250
8.2 元数据服务器的安装和配置 252
8.2.1 安装元数据服务 252
8.2.2 配置元数据服务 252
8.2.3 启动元数据服务器master 254
8.2.4 关闭元数据服务器 255
8.3 元数据日志服务器的安装和配置 255
8.3.1 安装元数据日志服务器 256
8.3.2 配置元数据日志服务器 256
8.3.3 运行及关闭元数据日志服务 257
8.4 数据存储服务器的安装和配置 258
8.4.1 安装数据存储服务器 258
8.4.2 配置数据存储服务器 259
8.4.3 启动数据存储服务器 260
8.4.4 关闭数据存储服务器 260
8.5 mfs客户端的安装和配置 261
8.5.1 centos作为mfs的客户端 261
8.5.2 freebsd作为mfs的客户端 263
8.6 破坏性测试 267
8.6.1 测试数据存储服务器 267
8.6.2 测试元数据服务器 268
8.7性能测试 269
8.8 mfs系统维护 271
8.9 mfs安装向导 271
8.9.1 概述 272
8.9.2 在专用服务器安装moosefs的基本步骤 272
8.9.3 主控服务器master server的安装 272
8.9.4 备份服务器的安装 274
8.9.5 存储块服务器chunk server的安装 276
8.9.6 客户端users’ computers的安装 277
8.9.7 在同一个主机上安装moosefs 278
8.9.8 moosefs的基本用法 281
8.9.9 停止 moosefs 283
第9章 mysql数据库 283
9.1 安装mysql 284
9.1.1 安装软件 284
9.1.2 mysql配置 285
9.1.3 mysql服务器的启动及检验 287
9.2 mysql主从复制 288
9.2.1 场景描述 289
9.2.2 主从复制配置 289
9.3 mysql的备份与恢复 292
9.3.1 完全备份 293
9.3.2 增量备份 296
9.3.3 备份策略 298
9.3.4 数据恢复实例 299
9.4 mysql数据库的监控 299
9.4.1 模拟用户访问的监控 300
9.4.2 mysql主从复制的监控 300
9.5 mysql数据库的维护 302
第10章 云计算之hadoop 303
10.1 hadoop概述 304
10.2 hadoop项目状况 305
10.3 部署hadoop 306
10.3.1 名称节点无密码访问各数据节点 306
10.3.2 安装jdk 307
10.3.3 安装和配置hadoop 307
10.3.4 初始化和启动/停止hadoop集群 312
10.3.5 hadoop功能测试 314
10.4 hadoop部署hive 315
10.5 部署hadoop桌面工具 317
cloudera-desktop 317
10.6 hadoop应用实例 318
10.7 hadoop杂项 324
第11章 网关服务 325
11.1 内部网络出口网关 326
11.1.1 某小公司的出口网关概况 326
11.1.2 撰写运行网关服务所需的shell脚本 326
11.1.3 启用网关服务 329
11.2 vpn网关 330
11.2.1 安装 330
11.2.2 vpn的拓扑结构 330
11.2.3 vpn服务器端的配置 331
11.2.4 运行vpn网关服务 332
11.2.5 客户端配置（windows） 332
11.2.6 拨号登录 332
11.2.7 设置路由及ip伪装 335
11.3 gre隧道服务 336
11.3.1 gre隧道场景描述 336
11.3.2 gre配置 337
11.3.3 gre隧道功能验证 338
11.4 vpn及gre隧道安全问题 338
第12章 监控系统nagios 339
12.1 nagios概述 340
12.2 nagios监控场景描述 340
12.3 nagios服务器的自我监控实现 342
12.3.1 配置邮件发送功能 342
12.3.2 测试短信发送 342
12.3.3 安装apache 344
12.3.4 部署nagios服务 346
12.3.5 部署nrpe 356
12.3.6 启动nagios服务 359
12.4 nagios监控mysql服务器 360
12.4.1 在mysql服务器上安装nrpe 361
12.4.2 创建mysql访问用户nagios 361
12.4.3 nagios服务器上的操作 361
12.5 nagios监控mysql主从复制 363
12.6 nagios监控其他服务器 363
12.7 监控错误日志实例 363
12.8 使用脚本部署nrpe 364
12.9 nagios故障处理汇集 366
12.9.1 nagios不能发送飞信报警 367
12.9.2 freebsd下解决nagios不发送报警邮件的问题 368
12.10 nagios监控策略 372
12.10.1 策略一：监控对象的选择 372
12.10.2 策略二：故障报警方式的选择 372
12.10.3 策略三：故障报警时效和间隔的选择 373
12.10.4 策略四：监控平台地点的选择 373
12.10.5 策略五：流量控制和安全 373
第13章 高可用、可扩展、负载均衡解决方案的设计与实践 375
13.1 高考中国网现行的运行架构 376
13.2 功能需求 377
13.2.1 高可用 377
13.2.2 可扩展 377
13.2.3 负载均衡 378
13.2.4 平台状态可视化 378
13.3 方案选择 379
13.3.1 主机部件扩容 379
13.3.2 应用分拆 380
13.3.3 高可用、可扩展、负载均衡解决方案 381
13.3.4 方案选定 382
13.4 高可用、可扩展、负载均衡解决方案的设计 382
13.4.1 系统总体架构 382
13.4.2 总体架构中各层的作用 383
13.4.3 网络划分 386
13.4.4 系统架构评价 386
13.5 部件/工具的选择 387
13.5.1 负载均衡层的部件选择 387
13.5.2 应用层的部件选择 388
13.5.3 分布式文件系统及数据库层的部件选择 390
13.5.4 网络设备的选择 391
13.6 辅助功能——监控系统的设计 391
13.6.1 监控平台的选择 391
13.6.2 nagios的监控对象 392
13.7 高可用、可扩展、负载均衡总体架构的技术实现 394
13.7.1 选择服务商及硬件上架 394
13.7.2 安装操作系统及部署相关软件 394
13.7.3 测试 397
13.7.4 加固和平台运行 398
13.8 方案实施后的效果 398
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>互联网运营智慧
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大道至易
目　 　 录
总论　 领域角色的关注　 　 1
第一节　 什么是领域角色的关注　 　 2
第二节　 基于组织视角的观察　 　 11
第三节　 工程的本质问题是组织　 　 25
第一篇　 具体工程下的组织与行为
引言　 管理中的逻辑　 　 33
第一章　 任人治事：组织行为的基本认知　 　 35
第一节　 刺秦与灭秦　 　 36
第二节　 看到别人能做什么　 　 43
第三节　 要做事，不要管理　 　 51
第四节　 伯夷与叔齐是怎么死的　 　 59
第二章　 谋定后动：项目的存在权　 　 67
第一节　 试错通常是无能的托辞　 　 68
第二节　 合法的山大王为什么没能成功　 　 78
第三节　 自己想办法　 　 86
第三章　 具体而微：工程是系统而不是事　 　 93
第一节　 做事的选择　 　 94
第二节　 你要什么　 　 102
附录一　 行在道上，从局部到全局　 　 109
附录二　 本来面目——大教堂、集市，与作坊　 　 111
附录三　 杀不死的人狼——我读《人月神话》　 　 113
第二篇　 程序源流：从计算到系统（上）
引言　 简单的本源　 　 117
第四章　 计算系统　 　 119
第一节　 数，以及对数据的性质的思考　 　 120
第二节　 逻辑　 　 126
第三节　 抽象　 　 129
第五章　 语言及其面临的系统　 　 133
第一节　 语言　 　 134
第二节　 从功能到系统　 　 141
第六章　 程序设计的核心思想　 　 151
第一节　 数据结构：顺序存储　 　 153
第二节　 数据结构：散列存储　 　 160
第三节　 执行体及其执行过程中的环境　 　 167
第四节　 语法树及其执行过程　 　 174
第五节　 对象系统：表达、使用与模式　 　 181
第三篇　 程序源流：从计算到系统（下）
第七章　 应用开发基础　 　 199
第一节　 应用开发的背景与成因　 　 200
第二节　 应用开发技术　 　 207
第三节　 开发视角下的工程问题　 　 216
第四节　 应用程序设计语言的复杂性　 　 223
第八章　 系统的基础部件　 　 231
第一节　 分布　 　 232
第二节　 依赖　 　 241
第三节　 消息　 　 245
第四节　 系统　 　 250
第九章　 系统的基本组织方法与原理　 　 253
第一节　 行为的组织及其抽象　 　 254
第二节　 领域间的组织　 　 257
附录一　 “主要编程范式”及其语言特性关系　 　 273
附录二　 继承与混合，略谈系统的构建方式　 　 275
附录三　 像大师们一样思考——从“UML何时死掉”谈起　 　 277
附录四　 VCL已死，RAD已死　 　 279
第四篇　 架构的思想与指导原则
引言　 架构师的思维　 　 285
第十章　 你所关注的系统　 　 287
第一节　 了解系统的过程　 　 288
第二节　 知识的构建　 　 295
第三节　 最初的事实　 　 307
第十一章　 架构是过程，而非结果　 　 315
第一节　 架构师的能力结构　 　 316
第二节　 系统架构与决策　 　 324
第三节　 架构的表达与逻辑　 　 338
第十二章　 架构原则，技艺、艺术与美　 　 355
第一节　 架构原则　 　 356
第二节　 技艺、艺术与美　 　 368
附录一　 做人、做事，做架构师——架构师能力模型解析　 　 373
附录二　 专访：谈企业软件架构设计（节选）　 　 375
参考资料　 　 377
图表索引　 　 382
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大道至易
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式系统原理与范型
第1章 绪论
第2章 通信
第3章 进程 
第4章 命名 
第5章 同步
第6章 一致性和复制
第7章 容错性
第8章 安全性
第9章 基于对象的分布式系统 
第10章 分布式文件系统 
第11章 基于文档的分布式系统 
第12章 基于协作的分布式系统 
第13章 阅读材料和参考书目
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式系统原理与范型
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>NoSQL数据库入门
译者简介：
罗勇  专业从事对日软件设计研发工作，曾于2007年至2009年赴日学习工作。精通J2EE及数据库开发。
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>NoSQL数据库入门
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实用负载均衡技术
目 　 　录
第1章 　引言　　1
1.1 　性能问题　　1
1.2 　解决方案　　2
1.3 　什么是负载均衡　　3
1.3.1 　负载均衡的前世　　3
1.3.2 　负载均衡的今生　　3
1.3.3 　纵向扩展　　3
1.3.4 　横向扩展　　4
1.4 　负载均衡的实现　　4
1.4.1 　网络的构成　　4
1.4.2 　缓存：网站的曲速引擎　　5
1.4.3 　使用DNS进行负载均衡　　5
1.4.4 　内容分发网络　　5
1.4.5 　6P原则　　6
1.4.6 　基础知识　　6
1.4.7 　HTTP负载均衡　　6
1.4.8 　对数据库进行负载均衡　　7
1.4.9 　对网络连接进行负载均衡　　7
1.4.10 　SSL负载均衡　　7
1.4.11 　建立高可用性集群　　7
1.4.12 　云平台上的负载均衡　　7
1.4.13 　IPv6：实现和概念　　8
1.4.14 　下一步做什么　　8
1.5 　总结　　8
第2章 　网站工作原理　　9
2.1 　开始我们的旅程　　10
2.1.1 　来自非IT背景　　10
2.1.2 　开始浏览的过程　　10
2.1.3 　通过DNS查找网站　　11
2.1.4 　最终连接到服务器　　11
2.1.5 　服务器自身　　12
2.1.6 　连接到数据库　　12
2.1.7 　缓存技术速览　　12
2.1.8 　回传到客户端　　13
2.2 　进一步了解　　13
2.3 　网络　　14
2.3.1 　TCP　　14
2.3.2 　DNS　　16
2.3.3 　速度、带宽和延迟　　17
2.3.4 　网络连接小结　　19
2.4 　HTML和Web　　19
2.4.1 　HTML　　20
2.4.2 　为什么基于文本很重要　　20
2.4.3 　为什么链接很重要　　21
2.4.4 　HTML小结　　22
2.4.5 　浏览器　　22
2.5 　Web内容　　23
2.5.1 　静态内容　　23
2.5.2 　动态内容　　24
2.5.3 　创建动态内容　　24
2.5.4 　Web内容小结　　25
2.6 　数据库：最薄弱的环节　　26
2.7 　总结　　26
第3章 　内容缓存：保持低负载　　28
3.1 　什么是缓存　　29
3.2 　走马观花　　29
3.2.1 　基于浏览器的缓存　　29
3.2.2 　Web加速器　　30
3.2.3 　Web代理　　31
3.2.4 　透明Web代理　　32
3.2.5 　边缘缓存　　33
3.2.6 　平台缓存　　34
3.2.7 　应用缓存　　35
3.2.8 　数据库缓存　　36
3.2.9 　仅仅是个开始……　　36
3.3 　缓存理论：缓存为什么这么难　　36
3.3.1 　HTTP 1.0对缓存的支持　　37
3.3.2 　HTTP 1.1加强的缓存支持　　37
3.3.3 　解决方案　　38
3.3.4 　缓存不像看起来那么简单　　39
3.4 　Web代理　　39
3.4.1 　Squid代理服务器　　39
3.4.2 　开始了　　40
3.4.3 　故障排除　　41
3.4.4 　透明代理　　42
3.4.5 　发生了什么　　42
3.4.6 　获得帮助　　44
3.4.7 　Squid，代理中的瑞士军刀　　44
3.5 　边缘缓存：Varnish　　45
3.5.1 　默认保守缓存　　46
3.5.2 　安装Varnish　　46
3.5.3 　配置并运行　　47
3.5.4 　定制Varnish　　49
3.6 　总结　　49
第4章 　基于DNS的负载均衡　　51
4.1 　DNS内幕　　51
4.1.1 　IP地址　　51
4.1.2 　问题　　52
4.1.3 　解决方案　　52
4.1.4 　回退一步　　53
4.2 　DNS详解　　53
4.2.1 　亲自查询　　54
4.2.2 　DNS查询进阶　　55
4.3 　DNS缓存　　56
4.3.1 　查询DNS缓存　　56
4.3.2 　Linux系统上的DNS缓存　　58
4.3.3 　实质内容　　58
4.4 　BIND9　　58
4.4.1 　DNS DB的头　　60
4.4.2 　DNS数据库记录　　61
4.4.3 　加载数据库　　62
4.4.4 　检查配置文件　　63
4.4.5 　常见问题　　63
4.4.6 　测试DNS　　63
4.5 　基于DNS的负载均衡　　64
4.5.1 　基于DNS的负载均衡的优势　　65
4.5.2 　基于DNS的负载均衡的问题　　65
4.6 　总结　　66
第5章 　内容分发网络　　67
5.1 　选择CDN服务提供商　　68
5.2 　开始使用Rackspace　　68
5.3 　向CDN账户添加内容　　69
5.4 　Rackspace云文件API　　72
5.4.1 　将API集成到PHP中　　72
5.4.2 　用API密钥进行认证　　72
5.4.3 　建立连接和断开连接　　73
5.4.4 　对容器进行操作　　74
5.4.5 　对文件进行操作　　79
5.4.6 　其他有用的函数　　84
5.5 　总结　　86
第6章 　性能和可靠性计划　　87
6.1 　yoU MAke DInner In TiME　　87
6.1.1 　理解　　88
6.1.2 　决策　　90
6.1.3 　设计与实现　　91
6.1.4 　安装　　92
6.1.5 　测试、维护、评估　　93
6.1.6 　计划的重要性　　95
6.2 　备份　　96
6.2.1 　为什么备份如此重要　　96
6.2.2 　前方可能有麻烦　　97
6.2.3 　必须实现自动化　　98
6.2.4 　战术备份　　98
6.2.5 　战略备份　　98
6.2.6 　增量备份与全备份　　99
6.2.7 　一定，一定要测试恢复！　　99
6.3 　总结　　100
第7章 　负载均衡基础　　101
7.1 　什么是负载均衡　　101
7.2 　有哪些可用的计算资源　　102
7.2.1 　处理器　　102
7.2.2 　内存　　103
7.2.3 　使用top命令查看CPU和RAM的性能　　103
7.2.4 　网络　　104
7.2.5 　存储（磁盘）　　105
7.3 　负载均衡实战　　105
7.4 　指导原则　　106
7.4.1 　深入理解系统　　106
7.4.2 　规划　　106
7.4.3 　监测和测试　　107
7.5 　总结　　107
第8章 　对网站进行负载均衡　　108
8.1 　测量Web服务器的性能　　108
8.2 　加速Apache HTTP　　110
8.2.1 　禁用空载模块　　111
8.2.2 　禁用DNS查询　　111
8.2.3 　采用压缩　　112
8.2.4 　FollowSymLinks和SymLinksIfOwnerMatch选项　　113
8.3 　加速nginx　　114
8.3.1 　worker_processes和worker_cpu_affinity　　114
8.3.2 　Gzip压缩　　115
8.4 　对Web服务器进行负载均衡　　116
8.4.1 　配置　　117
8.4.2 　准备IPVS服务器　　118
8.4.3 　准备工作服务器　　120
8.4.4 　测试负载均衡器　　121
8.5 　划分动态和静态内容　　122
8.6 　总结　　123
第9章 　对数据库进行负载均衡　　124
9.1 　搭建MySQL Cluster　　124
9.1.1 　安装管理程序　　126
9.1.2 　配置管理程序　　126
9.1.3 　准备集群数据节点　　129
9.1.4 　安装MySQL Server和NDB守护进程　　129
9.1.5 　配置NDB守护进程　　130
9.1.6 　启动集群节点上的服务　　131
9.1.7 　更新MySQL的root用户　　132
9.1.8 　测试上述安装和配置　　133
9.2 　实施负载均衡　　135
9.2.1 　建立负载均衡　　135
9.2.2 　设置负载均衡服务器　　136
9.2.3 　设置工作服务器　　137
9.2.4 　测试负载均衡服务器　　138
9.3 　总结　　139
第10章 　对网络进行负载均衡　　140
10.1 　分担负载　　140
10.2 　TCP/IP　　141
10.2.1 　TCP　　141
10.2.2 　IP　　142
10.3 　路由　　142
10.4 　负载均衡服务器　　144
10.5 　IPVS　　146
10.5.1 　IPVS的调度方式　　146
10.5.2 　在Ubuntu上安装IPVS　　148
10.5.3 　在CentOS上安装IPVS　　149
10.6 　IPVSADM　　150
10.7 　扩展IPVS　　151
10.8 　IPVS进阶　　153
10.8.1 　修改调度算法　　153
10.8.2 　分配权值　　154
10.8.3 　协议与多台虚拟服务器　　155
10.8.4 　增加IP地址　　156
10.9 　保存设置　　158
10.10 　总结　　159
第11章 　对SSL进行负载均衡　　160
11.1 　什么是SSL和TLS　　160
11.2 　公钥密码学　　161
11.3 　信任和数字证书认证机构　　162
11.4 　TLS加密　　162
11.5 　TLS负载均衡　　162
11.6 　配置Web服务器上的SSL　　163
11.6.1 　配置Apache服务器上的SSL　　165
11.6.2 　配置nginx服务器上的SSL　　166
11.7 　SSL加速　　166
11.7.1 　在Apache上启用SSL加速　　166
11.7.2 　在nginx上启用SSL加速　　166
11.8 　SSL前端　　167
11.9 　测试SSL　　168
11.10 　进一步配置　　170
11.10.1 　在SSL前端中启用SSL加速　　170
11.10.2 　启用缓存　　171
11.10.3 　指定要支持的协议　　172
11.10.4 　指定加密方法　　172
11.11 　LVS和SSL终结前端　　173
11.12 　将负载均衡服务器/SSL终端功能集成到同一台服务器上　　175
11.13 　总结　　175
第12章 　使用集群提高可用性　　176
12.1 　高可用性　　177
12.2 　单一故障点　　178
12.3 　集群化　　179
12.4 　IPVS故障恢复　　180
12.4.1 　在Ubuntu上安装集群软件包　　181
12.4.2 　在CentOS上安装集群软件包　　182
12.4.3 　配置集群　　182
12.4.4 　常见配置问题　　185
12.4.5 　检查系统　　186
12.5 　测试　　187
12.6 　Web服务器细节配置　　189
12.6.1 　Ubuntu　　189
12.6.2 　CentOS　　189
12.7 　高级配置选项　　189
12.7.1 　ha.cf　　189
12.7.2 　ldirectord.cf　　190
12.7.3 　Web服务器　　190
12.8 　总结　　190
第13章 　云端负载均衡　　191
13.1 　云计算　　191
13.2 　虚拟化　　192
13.3 　虚拟化资源　　195
13.4 　管理虚拟资源　　196
13.4.1 　平衡　　197
13.4.2 　超量供给　　198
13.4.3 　计划　　199
13.5 　云的弹性　　200
13.6 　用云服务器工作　　201
13.7 　总结　　203
第14章 　IPv6：影响和概念　　204
14.1 　IPv6　　204
14.2 　十六进制表示　　204
14.3 　缩略表示　　205
14.4 　IPv4地址的耗尽　　205
14.5 　部署IPv6　　205
14.6 　IPv6的优势　　206
14.7 　实现　　206
14.8 　互联网连接　　208
14.9 　DNS　　208
14.10 　操作系统　　208
14.11 　网络　　208
14.11.1 　单一网关的网络　　209
14.11.2 　双重网络　　209
14.12 　软件支持　　209
14.12.1 　Apache　　209
14.12.2 　nginx　　210
14.12.3 　Varnish　　210
14.12.4 　Memcached　　210
14.12.5 　IPVS　　211
14.12.6 　ldirectord　　211
14.12.7 　heartbeat　　211
14.13 　总结　　212
第15章 　何去何从　　213
15.1 　回顾　　213
15.2 　监控　　214
15.3 　安全　　215
15.3.1 　访问控制　　215
15.3.2 　视图　　216
15.3.3 　常见的攻击防护　　216
15.4 　操作系统性能　　217
15.4.1 　自己编译　　217
15.4.2 　裁剪　　218
15.4.3 　高性能操作系统　　218
15.5 　计划　　218
15.6 　总结　　219
索引　　220
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实用负载均衡技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻量级Java EE企业应用实战
第1章  Java EE应用和开发环境  1.1  Java EE应用概述    1.1.1  Java EE应用的分层模型    1.1.2  Java EE应用的组件    1.1.3  Java EE应用结构和优势    1.1.4  常用的Java EE服务器  1.2  轻量级Java EE应用相关技术    1.2.1  JSP、Servlet 3.0和JavaBean及替代技术    1.2.2  Struts 2.2及替代技术    1.2.3  Hibernate 3.6及替代技术    1.2.4  Spring 3.0及替代技术  1.3  Tomcat的下载和安装    1.3.1  安装Tomcat服务器    1.3.2  配置Tomcat的服务端口    1.3.3  进入控制台    1.3.4  部署Web应用    1.3.5  配置Tomcat的数据源  1.4  Eclipse的安装和使用    1.4.1  Eclipse的下载和安装    1.4.2  在线安装Eclipse插件    1.4.3  从本地压缩包安装插件    1.4.4  手动安装Eclipse插件    1.4.5  使用Eclipse开发Java EE应用    1.4.6  导入Eclipse项目    1.4.7  导入非Eclipse项目  1.5  Ant的安装和使用    1.5.1  Ant的下载和安装    1.5.2  使用Ant工具    1.5.3  定义生成文件    1.5.4  Ant的任务(task)  1.6  使用CVS进行协作开发    1.6.1  安装CVS服务器    1.6.2  配置CVS资源库    1.6.3  安装CVS客户端    1.6.4  发布项目到服务器    1.6.5  从服务器下载项目    1.6.6  同步(Update)本地文件    1.6.7  提交(Commit)修改    1.6.8  添加文件和目录    1.6.9  删除文件和目录    1.6.10  查看文件的版本变革    1.6.11  提取文件以前版本的内容    1.6.12  从以前版本重新开始    1.6.13  创建标签    1.6.14  创建分支    1.6.15  沿着分支开发    1.6.16  使用Eclipse作为CVS客户端  1.7  本章小结第2章  JSP/Servlet及相关技术详解  ……第3章  Struts 2的基本用法第4章  深入使用Struts 2第5章  Hibernate的基本用法第6章  深入使用Hibernate第7章  Spring的基本用法第8章  深入使用Spring第10章  简单工作流系统
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻量级Java EE企业应用实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解OSGi
前言
第一部分　走近OSGi
第1章　Java模块化之路 / 2
1.1　什么是OSGi / 2
1.1.1　OSGi规范的演进 / 4
1.1.2　Java模块化规范之争 / 7
1.2　为什么使用OSGi / 11
1.2.1　OSGi能让软件开发变得更容易吗 / 12
1.2.2　OSGi能让系统变得更稳定吗 / 13
1.2.3　OSGi能让系统运行得更快吗 / 14
1.2.4　OSGi能支撑企业级开发吗 / 15
1.3　本章小结 / 16
第二部分　OSGi规范与原理
第2章　模块层规范与原理 / 18
2.1　OSGi规范概要 / 18
2.2　Bundle / 20
2.3　描述元数据 / 21
2.3.1　预定义标记 / 21
2.3.2　使用可视化工具 / 27
2.4　Bundle的组织与依赖 / 31
2.4.1　导出和导入Package / 31
2.4.2　约束规则与示例 / 38
2.4.3　校验Bundle有效性 / 44
2.5　OSGi的类加载架构 / 45
2.5.1　父类加载器 / 46
2.5.2　Bundle类加载器 / 47
2.5.3　其他类加载器 / 49
2.5.4　类加载顺序 / 50
2.6　定义执行环境 / 51
2.7　本地化 / 54
2.8　本章小结 / 55
第3章　生命周期层规范与原理 / 56
3.1　Bundle标识 / 56
3.2　Bundle状态及转换 / 57
3.2.1　安装过程 / 59
3.2.2　 解析过程 / 61
3.2.3　启动过程 / 62
3.2.4　更新过程 / 63
3.2.5　停止过程 / 64
3.2.6　卸载过程 / 65
3.3　启动级别 / 65
3.3.1　设置启动级别 / 66
3.3.2　调整活动启动级别 / 67
3.4　事件监听 / 68
3.4.1　事件类型 / 69
3.4.2　事件分派 / 70
3.5　系统Bundle / 71
3.6　Bundle上下文 / 72
3.7　本章小结 / 73
第4章　服务层规范与原理 / 74
4.1　服务 / 74
4.2　OSGi服务示例 / 75
4.3　服务属性 / 80
4.3.1　属性过滤器 / 82
4.3.2　预定义属性 / 83
4.3.3　修改属性 / 84
4.4　服务工厂 / 85
4.5　服务跟踪器 / 86
4.6　引用服务 / 89
4.7　释放和注销服务 / 91
4.8　服务层事件 / 91
4.8.1　事件类型 / 92
4.8.2　事件分派 / 92
4.8.3　ServiceRegistration对象的提前请求 / 93
4.9　远程服务 / 94
4.9.1　准备远程服务环境 / 94
4.9.2　远程服务示例 / 96
4.9.3　远程服务属性 / 99
4.9.4　实现分析 / 100
4.10　服务钩子 / 101
4.10.1　EventListenerHook / 101
4.10.2　FindHook / 101
4.10.3　ListenerHook / 102
4.10.4　服务钩子示例 / 102
4.11　本章小结 / 105
第三部分　基于Equinox的OSGi应用与实践
第5章　Equinox启航 / 108
5.1　建立Equinox开发环境 / 109
5.1.1　建立运行环境 / 109
5.1.2　建立编译及调试环境 / 110
5.1.3　建立开发环境 / 112
5.2　Equinox常用组件简介 / 117
5.3　Equinox启动器 / 119
5.4　使用代码启动Equinox / 124
5.5　本章小结 / 125
第6章　Equinox基础应用与源码解析 / 126
6.1　实践项目—Neonat论坛 / 126
6.1.1　背景与需求 / 126
6.1.2　模块划分 / 127
6.1.3　基础资料模块 / 129
6.1.4　持久化模块 / 133
6.1.5　用户交互模块 / 135
6.1.6　运行效果 / 140
6.2　Equinox源码解析 / 142
6.2.1　OSGi容器启动 / 142
6.2.2　Bundle状态恢复 / 147
6.2.3　解析Bundle依赖关系 / 153
6.2.4　OSGi类加载器实现 / 157
6.3　本章小结 / 162
第7章　服务器端OSGi / 163
7.1　OSGi与Web服务器 / 163
7.2　HTTP Service规范简介 / 166
7.2.1　服务目标 / 166
7.2.2　服务接口 / 168
7.2.3　资源映射规则 / 169
7.2.4　请求处理过程 / 171
7.3　实践项目—Neonat论坛的Web模块 / 171
7.3.1　准备依赖项 / 172
7.3.2　使用HTTP Service / 174
7.3.3　实现Web交互功能 / 176
7.3.4　运行效果 / 178
7.4　HTTP Service源码解析 / 180
7.4.1　BridgeServlet与OSGi容器启动 / 180
7.4.2　BridgeServlet与HTTP请求委派 / 186
7.4.3　DelegateServlet实现原理 / 188
7.5　本章小结 / 192
第8章　用户管理服务 / 193
8.1　User Admin服务规范简介 / 193
8.1.1　服务目标与基础概念 / 193
8.1.2　验证用户身份 / 195
8.1.3　验证用户权限 / 196
8.1.4　User Admin事件 / 197
8.2　实践项目—Neonat论坛用户管理模块 / 198
8.2.1　需求与依赖项分析 / 198
8.2.2　用户与用户组的实现 / 200
8.2.3　页面权限 / 201
8.2.4　用户登录与身份验证 / 202
8.3　User Admin源码解析 / 206
8.3.1　用户管理实现 / 206
8.3.2　外部服务使用实践 / 208
8.4　本章小结 / 211
第9章　Preferences服务 / 212
9.1　Preferences服务规范简介 / 212
9.1.1　服务目标 / 212
9.1.2　数据结构 / 214
9.1.3　属性 / 215
9.1.4　并发处理 / 216
9.1.5　清理遗留数据 / 217
9.2　实践项目—Neonat论坛持久化模块 / 217
9.2.1　编码实现 / 217
9.2.2　模块热切换 / 220
9.3　Preferences源码解析 / 222
9.3.1　数据结构实现 / 224
9.3.2　属性存取 / 228
9.3.3　后端存储系统 / 229
9.4　本章小结 / 234
第10章　声明式服务 / 235
10.1　声明式服务规范简介 / 236
10.1.1　服务目标 / 236
10.1.2　定义Component / 236
10.1.3　Component类型 / 237
10.1.4　Component生命周期 / 240
10.1.5　Component属性 / 245
10.1.6　绑定与发布服务 / 245
10.1.7　激活与钝化方法 / 252
10.1.8　Component配置总结 / 254
10.2　实践项目—使用声明式服务改造Neonat论坛 / 259
10.2.1　可视化编辑工具 / 259
10.2.2　DS容器管理 / 263
10.3　DS容器源码解析 / 264
10.3.1　容器启动 / 264
10.3.2　加载Bundle中的Component / 267
10.3.3　动态依赖解析 / 272
10.4　本章小结 / 274
第11章　Subsystems服务 / 276
11.1　服务目标 / 276
11.2　Subsystem格式 / 277
11.3　Subsystem元数据 / 278
11.3.1　SUBSYSTEM.MF标识 / 278
11.3.2　DEPLOYMENT.MF标识 / 281
11.4　Subsystem类型与共享策略 / 283
11.5　组织管理Subsystem / 285
11.6　Subsystem部署与依赖策略 / 289
11.7　Subsystem生命周期 / 291
11.7.1　安装 / 292
11.7.2　解析 / 293
11.7.3　启动 / 294
11.7.4　停止 / 294
11.7.5　卸载 / 295
11.8　本章小结 / 295
第四部分　最佳实践
第12章　OSGi最佳实践 / 298
12.1　Bundle相关名称命名 / 298
12.2　Bundle划分原则 / 300
12.2.1　恰如其分地分配Bundle粒度 / 300
12.2.2　分离OSGi代码 / 300
12.2.3　分离接口和实现 / 300
12.3　依赖关系实践 / 301
12.3.1　依赖分析工具 / 301
12.3.2　避免Require-Bundle / 303
12.3.3　最小化依赖 / 304
12.3.4　避免循环依赖 / 304
12.3.5　Equinox x-*依赖 / 305
12.4　Equinox专有类加载机制 / 306
12.4.1　Buddy Loading类加载机制 / 306
12.4.2　ClassLoaderDelegateHook类加载机制 / 307
12.5　Bundle生命周期实践 / 309
12.5.1　启动 / 309
12.5.2　停止 / 309
12.6　服务工厂的特殊性 / 309
12.7　处理非OSGi的JAR包 / 311
12.8　启动顺序实践 / 313
12.8.1　避免启动顺序依赖 / 313
12.8.2　Start Level的使用 / 313
12.9　Fragment Bundle实践 / 314
12.10　保持OSGi动态性 / 315
12.11　API Tools实践 / 317
12.11.1　API Baselines / 317
12.11.2　API Tools 注解 / 319
12.11.3　API Version版本管理 / 322
12.11.4　二进制文件不兼容 / 322
12.12　本章小结 / 322
第13章　Spring Dynamic Modules实践 / 324
13.1　Spring DM入门 / 324
13.1.1　Spring DM项目简介 / 324
13.1.2　安装Spring DM / 325
13.1.3　简单的Spring DM示例 / 326
13.1.4　Bundle和Spring上下文 / 331
13.1.5　<osgi:*>命名空间 / 333
13.2　Spring DM进阶 / 337
13.2.1　Spring DM扩展配置 / 337
13.2.2　Web Extender / 344
13.2.3　Spring DM服务约束 / 345
13.2.4　在Spring上下文中使用BundleContext / 346
13.3　Spring DM企业应用 / 346
13.3.1　规划OSGi组件 / 347
13.3.2　在Spring DM中使用JPA / 348
13.3.3　事务管理 / 353
13.3.4　OSGi企业规范中的JPA / 358
13.4　Spring DM和Blueprint / 359
13.5　本章小结 / 360
第14章　构建可测试的OSGi系统 / 361
14.1　单元测试的必要性 / 362
14.2　单元测试的重要性 / 363
14.3　可测试代码的特征 / 364
14.4　OSGi单元测试 / 365
14.4.1　如何组织测试代码 / 366
14.4.2　如何进行OSGi单元测试 / 367
14.5　OSGi集成测试 / 373
14.5.1　Eclipse JUnit Plug-in Test / 374
14.5.2　Spring DM Test / 379
14.5.3　Pax Exam / 383
14.6　本章小结 / 384
附录A　Java类加载器简介 / 385
附录B　Equinox控制台命令 / 392
附录C　OSGi子规范目录 / 397
附录D　OSGi相关项目 / 399
附录E　Equinox启动配置参数 / 401
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解OSGi
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring MVC学习指南
目录
第一章  Spring框架	1
1.1  XML配置文件	4
1.2  Spring控制反转容器的使用	4
1.2.3  通过构造器来创建一个bean实例	5
1.2.2  通过工厂方法来创建一个bean实例	5
1.2.3  Destroy Method的使用	6
1.2.4  向构造器传参	6
1.2.5  Setter方式依赖注入	7
1.2.3  构造器方式依赖注入	10
1.3  小结	10
第二章  模型2和MVC模式	11
2.1  模型1介绍	11
2.2  模型2介绍	11
2.3  模型2之Servlet控制器	13
2.3.1  Product类	15
2.3.2  ProductForm类	15
2.3.3  ControllerServlet类	16
2.3.4  视图	20
2.3.5  测试应用	22
2.4  解耦控制器代码	23
2.5  校验器	27
2.6  后端	32
2.7  本章小结	33
第三章  Spring MVC介绍	34
3.1  采用Spring MVC的好处	34
3.2  Spring MVC的DispatcherServlet	35
3.3  Controller接口	36
3.4  第一个Spring MVC应用	37
3.4.1  目录结构	37
3.4.2  部署描述符文件和Spring MVC配置文件	38
3.4.3  Controller	39
3.4.4  View	40
3.4.5  测试应用	42
3.5  View Resolver	43
3.6  本章小结	45
第四章  基于注解的控制器	46
4.1  Spring MVC注解类型	46
4.1.1  Controller注解类型	46
4.1.2  RequestMapping注解类型	47
4.2  编写请求处理方法	50
4.3  应用基于注解的控制器	52
4.3.1  目录结构	52
4.3.2  配置文件	52
4.3.3  Controller类	55
4.3.4  View	56
4.3.5  测试应用	57
4.4  应用@Autowired和@Service进行依赖注入	58
4.5  重定向和Flash属性	62
4.6  请求参数和路径变量	63
4.7  @ModelAttribute	66
4.8  小结	67
第五章  数据绑定和form标签库	68
5.1  数据绑定概览	68
5.2  form标签库	69
5.2.1  form标签	70
5.2.2  input标签	71
5.2.3  password标签	72
5.2.4  hidden标签	72
5.2.5  textarea标签	73
5.2.6  checkbox标签	73
5.2.7  radiobutton标签	74
5.2.8  checkboxes标签	74
5.2.9  radiobuttons标签	75
5.2.10  select标签	76
5.2.11  option标签	76
5.2.12  options标签	77
5.2.13  errors标签	77
5.3  数据绑定范例	78
5.3.1  目录结构	78
5.3.2  Domain类	78
5.3.3  Controller类	80
5.3.4  Service类	82
5.3.5  配置文件	85
5.3.6  视图	86
5.3.7  测试应用程序范例	88
5.4  小结	90
第六章  Converter和Formatter	91
6.1  converter	91
6.2  formatter	97
6.3  用registrar注册formatter	99
6.4  选择converter，还是formatter？	101
6.5  小结	101
第七章  验证器	102
7.1  验证概览	102
7.2  Spring验证器	103
7.3  ValidationUtils类	104
7.4  Spring的Validator范例	105
7.5  源文件	107
7.6  Controller类	107
7.7  测试验证器	109
7.8  JSR 303验证	110
7.9  JSR 303 Validator范例	112
7.10  小结	114
第八章  表达式语言（EL）	115
8.1  表达式语言（EL）的语法	115
8.1.1  关键字	116
8.1.2  [ ]和.运算符	116
8.1.3  取值规则	117
8.2  访问JavaBean	118
8.3  EL隐式对象	118
8.3.1  pageContext	119
8.4  使用其他EL运算符	122
8.4.1  算术运算符	122
8.3.3  关系运算符	123
8.4.2  逻辑运算符	123
8.4.3  关系运算符	123
8.4.4  empty运算符	124
8.5  如何在JSP 2.0及其更高版本中配置EL	124
8.5.1  实现免脚本的JSP页面	124
8.5.2  禁用EL计算	125
8.6  小结	126
第九章  JSTL	127
9.1  下载JSTL	127
9.2  JSTL库	127
9.3  一般行为	129
9.3.1  out标签	129
9.3.2  set标签	130
9.3.3  remove标签	132
9.4  条件行为	132
9.4.1  if标签	133
9.4.2  choose、when和otherwise标签	134
9.5  遍历行为	135
9.5.1  forEach标签	135
9.5.2  forTokens标签	143
9.6  与URL相关的行为	144
9.6.1  url标签	144
9.6.2  redirect标签	146
9.7  格式化行为	146
9.7.1  formatNumber标签	146
9.7.2  formatDate标签	149
9.7.3  timeZone标签	150
9.7.4  setTimeZone标签	152
9.7.5  parseNumber	152
9.7.6  parseDate标签	153
9.8  函数	155
9.8.1  contains函数	155
9.8.2  containsIgnoreCase函数	155
9.8.3  endsWith函数	156
9.8.4  escapeXml函数	156
9.8.5  indexOf函数	156
9.8.6  join函数	156
9.8.7  length函数	157
9.8.8  replace函数	157
9.8.9  split函数	157
9.8.10  startsWith函数	158
9.8.11  substring函数	158
9.8.12  substringAfter函数	158
9.8.13  substringBefore函数	158
9.8.14  toLowerCase函数	159
9.8.15  toUpperCase函数	159
9.8.16  trim函数	159
9.9  小结	159
第十章  国际化	160
10.1  语言区域	161
10.2  国际化Spring MVC应用程序	163
10.3  将文本元件隔离成属性文件	163
10.4  读取属性文件	165
10.5  告诉Spring MVC要使用哪个语言区域	166
10.6  使用message标签	167
10.7  范例	167
10.8  小结	173
第十一章  上传文件	174
11.1  客户端编程	174
11.2  MultipartFile接口	175
11.3  用Commons FileUpload上传文件	176
11.4  Domain类	177
11.5  控制器	178
11.6  配置文件	179
11.7  JSP页面	181
11.8  应用程序的测试	183
11.9  用Servlet 3及其更高版本上传文件	184
11.10  客户端上传	188
11.11  小结	196
第十二章  下载文件	197
12.1  文件下载概览	197
12.2  范例1：隐藏资源	198
12.3  范例2：防止交叉引用	202
12.4  小结	206
附录A  Tomcat	207
附录B  servlet	211
附录C  JavaServer Pages	236
附录D  部署描述符	258
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring MVC学习指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>交易系统
第一章 多见阙殆：2007年前的全球著名交易系统调研
一、全球证券交易所格局以及中外异同
二、纽约证券交易所交易系统
三、纳斯达克证券交易所交易系统
四、泛欧证券交易所交易系统
五、德意志交易所集团交易系统
六、北欧证券交易所交易系统
第二章 拙守于前：上交所新交易系统核心平台选型回顾
一、上交所新交易系统平台选择与基准测试
二、主流后台设备历史发展回顾
三、关于设备和操作系统层面的考虑
第三章 形而上者：大型系统建设中的技术管理
一、团队组织
二、质量保证
三、面向变更
四、沟通与工具
第四章 巧夺天工：应用架构设计与持续优化
一、应用架构核心设计目标
二、交易系统应用架构宏观设计概述
三、调优关键技巧回顾
第五章 运筹帷幄：系统就绪以及切换上线
一、持续扬弃与百折不挠
二、系统、业务、市场全方位的就绪准备
三、压力下的破坏性测试
四、切换策略的确定
五、上线过程实录
六、72小时连续作战
第六章 运气+行动：容量管理以及事件处置
一、上线前后性能容量变迁以及持续的容量管理方法
二、报盘程序线程安全
三、存储设备的打嗝
四、谁该对ETF篮子文件的内容负责?
五、一台交易主机真的坏了
第七章 中国特色：扩展后的现货交易技术支撑体系
一、新一代交易系统所支持的总体业务框架
二、融资融券技术体系
三、交易所交易基金技术体系
四、债券回购技术体系
五、发行技术体系
六、指定交易技术体系
第八章 日新月异：2007年之后的全球交易系统发展
一、交易所技术战略发展趋势研究
二、国际上各主要交易所近年来的技术发展
三、上海证券交易所核心交易系统后续规划
四、市场参与者系统接口之历史与未来
第九章 技术战略：证券行业的宏观思考
一、证券行业参与者发展趋势预判
二、证券公司典型系统架构
三、基金公司典型系统架构
四、证券公司未来技术架构探讨
参考文献
后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>交易系统
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java设计模式
序	xv
第1章  绪论	1
为何需要模式	1
为何需要设计模式	2
为何选择Java	3
UML	3
挑战	4
本书的组织	4
欢迎来到Oozinoz公司	6
小结	6
第1部分  接口型模式
第2章  接口型模式介绍	8
接口与抽象类	8
接口与职责	10
小结	11
超越普通接口	12
第3章  适配器（Adapter）模式	13
接口适配	13
类与对象适配器	17
JTable对数据的适配	20
识别适配器	24
小结	25
第4章  外观（Facade）模式	27
外观类、工具类和示例类	27
重构到外观模式	29
小结	38
第5章  合成（Composite）模式	39
常规组合	39
合成模式中的递归行为	40
组合、树与环	42
含有环的合成模式	47
环的影响	50
小结	51
第6章  桥接（Bridge）模式	52
常规抽象：桥接模式的一种方法	52
从抽象到桥接模式	54
使用桥接模式的驱动器	57
数据库驱动	57
小结	59
第2部分  职责型模式
第7章  职责型模式介绍	62
常规的职责型模式	62
根据可见性控制职责	64
小结	65
超越普通职责	65
第8章  单例（Singleton）模式	67
单例模式机制	67
单例和线程	68
识别单例	70
小结	71
第9章  观察者（Observer）模式	72
经典范例：GUI中的观察者模式	72
模型/视图/控制器	76
维护Observable对象	82
小结	84
第10章  调停者（Mediator）模式	85
经典范例：GUI调停者（Mediator）	85
关系一致性中的调停者模式	89
小结	96
第11章  代理（Proxy）模式	97
经典范例：图像代理	97
重新思考图片代理	102
远程代理	104
动态代理	109
小结	114
第12章  职责链（Chain of Responsibility）模式	115
现实中的职责链模式	115
重构为职责链模式	117
固定职责链	119
没有组合结构的职责链模式	121
小结	121
第13章  享元（Flyweight）模式	122
不变性	122
抽取享元中不可变的部分	123
共享享元	125
小结	128
第3部分  构造型模式
第14章  构造型模式介绍	130
构造函数的挑战	130
小结	132
超出常规的构造函数	132
第15章  构建者（Builder）模式	134
常规的构建者	134
在约束条件下构建对象	137
可容错的构建者	139
小结	140
第16章  工厂方法（Factory Method）模式	141
经典范例：迭代器	141
识别工厂方法	142
控制要实例化的类	143
并行层次结构中的工厂方法模式	145
小结	147
第17章  抽象工厂（Abstract Factory）模式	148
经典范例：图形用户界面工具箱	148
抽象工厂和工厂方法	153
包和抽象工厂	157
小结	157
第18章  原型（Prototype）模式	158
作为工厂的原型	158
利用克隆进行原型化	159
小结	162
第19章  备忘录（Memento）模式	163
经典范例：使用备忘录模式执行撤销操作	163
备忘录的持久性	170
跨会话的持久性备忘录	170
小结	174
第4部分  操作型模式
第20章  操作型模式介绍	176
操作和方法	176
签名	177
异常	178
算法和多态	179
小结	180
超越常规的操作	181
第21章  模板方法（Template Method）模式	182
经典范例：排序	182
完成一个算法	186
模板方法钩子	188
重构为模板方法模式	189
小结	191
第22章  状态（State）模式	193
对状态进行建模	193
重构为状态模式	197
使状态成为常量	201
小结	203
第23章  策略（Strategy）模式	204
策略建模	204
重构到策略模式	207
比较策略模式与状态模式	211
比较策略模式和模板方法模式	211
小结	212
第24章  命令（Command）模式	213
经典范例：菜单命令	213
使用命令模式来提供服务	216
命令钩子	217
命令模式与其他模式的关系	219
小结	220
第25章  解释器（Interpreter）模式	221
一个解释器示例	221
解释器、语言和解析器	233
小结	234
第5部分  扩展型模式
第26章  扩展型模式介绍	236
面向对象设计的原则	236
Liskov替换原则	237
迪米特法则	238
消除代码的坏味道	239
超越常规的扩展	240
小结	241
第27章  装饰器（Decorator）模式	242
经典范例：流和输出器	242
函数包装器	250
装饰器模式和其他设计模式的关系	257
小结	258
第28章  迭代器（Iterator）模式	259
普通的迭代	259
线程安全的迭代	261
基于合成结构的迭代	267
小结	277
第29章  访问者（Visitor）模式	278
访问者模式机制	278
常规的访问者模式	280
Visitor环	286
访问者模式的危机	290
小结	292
附录A  指南	293
附录B  答案	297
附录C  Oozinoz源代码	366
附录D  UML概览	369
参考文献	375
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式系统设计
作者简介
译者序
前言
第1章 概论
第2章 分布式程序设计语言
第3章 分布式系统设计的形式方法
第4章 互斥和选举算法
第5章 死锁的预防、避免和检测
第6章 分布式路由算法
第7章 自适应、无死锁和容错路由
第8章 分布式系统的可靠性
第9章 静态负载分配
第10章 动态负载分配
第11章 分布式数据管理
第12章 分布式系统的应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式系统设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高性能网站构建实战
第一篇 架构规划篇
第1章 网站架构简介 2
1.1 网站的硬架构 2
1.1.1 机房的选择 2
1.1.2 带宽的大小 2
1.1.3 服务器的划分 3
1.2 网站的软架构 3
1.2.1 框架的选择 3
1.2.2 逻辑的分层 4
1.3 网站架构需要考虑的几个问题 5
1.3.1 HTML静态化 5
1.3.2 图片服务器分离 5
1.3.3 数据库集群和库表散列 6
1.3.4 缓存 6
1.3.5 镜像 7
1.3.6 负载均衡 7
1.4 操作系统的选择及参数优化 7
1.4.1 用U盘自动安装操作系统 7
1.4.2 系统初始化 13
1.5 小结 17
第二篇 负载应用篇
第2章 LVS+KeepAlived实现高可用集群 20
2.1 软硬负载应用介绍 20
2.1.1 Linux集群简介 20
2.1.2 硬件负载介绍 21
2.1.3 软件负载介绍 23
2.2 搭建LVS+KeepAlived环境 24
2.2.1 LVS的模式原理以及算法 24
2.2.2 KeepAlived简介 28
2.2.3 LVS+KeepAlived环境的实践 29
2.3 FAQ 36
2.4 小结 37
第3章 高性能负载均衡器HAProxy 38
3.1 HAProxy简介及定位 38
3.2 HAProxy的环境配置 38
3.2.1 HAProxy的编译安装 38
3.2.2 HAProxy配置文件详解 44
3.2.3 HAProxy参数优化 49
3.3 配置HAProxy日志 50
3.4 FAQ 51
3.5 小结 52
第4章 轻量级的负载Nginx 53
4.1 Nginx和LVS的比较 53
4.2 Nginx和HAProxy对比 54
4.3 Nginx的负载实现 55
4.3.1 Nginx的安装 55
4.3.2 Nginx配置文件详解 58
4.4 FAQ 63
4.5 小结 64
第三篇 页面缓存篇
第5章 经久不衰的Squid 68
5.1 Squid缓存简介 68
5.1.1 网站缓存简介 68
5.1.2 Squid缓存 69
5.2 Squid实践部署 71
5.2.1 Squid的编译安装 71
5.2.2 Squid透明缓存的配置 73
5.2.3 Squid反向代理的配置 75
5.2.4 Squid配置文件详解 76
5.2.5 Squid缓存管理 78
5.3 Sarg使用简介 78
5.4 FAQ 80
5.5 小结 81
第6章 高性能缓存服务器Varnish 82
6.1 Varnish缓存简介 82
6.1.1 Varnish的结构特点 82
6.1.2 Varnish和Squid的对比 83
6.2 Varnish实践部署 83
6.2.1 Varnish编译安装 83
6.2.2 Varnish缓存的配置 84
6.2.3 Varnish配置文件详解 88
6.2.4 Varnish启动等管理工具 93
6.3 FAQ 95
6.4 小结 96
第7章 轻量级缓存服务器Nginx 97
7.1 Nginx缓存简介 97
7.1.1 Nginx的缓存方式 97
7.1.2 三种缓存的对比 98
7.2 Nginx实践部署 99
7.2.1 Nginx编译安装 99
7.2.2 Nginx缓存的配置 99
7.2.3 Nginx配置文件详解 102
7.2.4 Nginx缓存命中率配置 104
7.3 FAQ 105
7.4 小结 107
第四篇 Web服务器篇
第8章 Apache组建高稳定性Web服务器 110
8.1 Apache简介 110
8.2 Apache的实践 111
8.2.1 Apache的安装 111
8.2.2 Apache的配置 112
8.2.3 Apache启动与停止 115
8.2.4 Apache配置文件详解 116
8.2.5 Apache日志切割 122
8.2.6 Apache实用第三方模块 123
8.3 小结 127
第9章 两款常用的小型Web服务器 128
9.1 Nginx的Web实践 128
9.1.1 Nginx的安装 128
9.1.2 Nginx的Web配置 128
9.1.3 Nginx配置文件详解 131
9.2 Nginx小结 134
9.3 Lighttpd简介 134
9.4 Lighttpd实践 135
9.4.1 Lighttpd安装 135
9.4.2 Lighttpd配置 135
9.4.3 Lighttpd配置文件详解 136
9.5 FAQ 138
9.6 小结 139
第五篇 数据缓存篇
第10章 高性能内存对象缓存Memcached 142
10.1 NoSQL简介 142
10.1.1 什么是NoSQL 142
10.1.2 NoSQL的特点 142
10.1.3 NoSQL开源软件介绍 144
10.2 Memcached实践 148
10.2.1 Memcached简介 148
10.2.2 Memcached的原理 148
10.2.3 Memcached的使用 150
10.2.4 Memcache安装启动 150
10.2.5 Memcached的复制功能 152
10.2.6 Memcached管理 153
10.2.7 Memcached的安全 156
10.3 小结 157
第11章 高性能的key-value数据库Redis 158
11.1 Redis简介 158
11.1.1 什么是Redis 158
11.1.2 Redis的数据结构 158
11.1.3 Redis性能 161
11.2 Redis的实践 161
11.2.1 Redis的安装 161
11.2.2 Redis的配置 162
11.2.3 Redis的启动停止 164
11.2.4 Redis的配置文件详解 166
11.2.5 Redis的管理 170
11.3 FAQ 207
11.4 小结 208
第12章 MongoDB构建分布式文件存储的数据库 209
12.1 MongoDB简介 209
12.1.1 什么是MongoDB 209
12.1.2 MongoDB的特点 209
12.1.3 MongoDB适用场景 210
12.2 MongoDB的实践 211
12.2.1 MongoDB安装启动 211
12.2.2 MongoDB常用命令 215
12.2.3 MongoDB主从配置 221
12.2.4 MongoDB管理工具 223
12.3 FAQ 231
12.4 小结 232
第六篇 文件服务篇
第13章 MFS组建分布式文件系统 234
13.1 分布式文件系统简介 234
13.1.1 分布式文件系统概述 234
13.1.2 分布式文件系统架构 235
13.1.3 常见的开源分布式文件系统 236
13.2 MFS的实践 241
13.2.1 MFS简介 241
13.2.2 MFS安装启动 244
13.2.3 MFS配置文件详解 251
13.2.4 MFS操作 254
13.3 FAQ 257
13.4 小结 258
第14章 云计算之Hadoop的组建 259
14.1 Hadoop简介 259
14.1.1 Hadoop特点 259
14.1.2 Hadoop架构 260
14.1.3 Hadoop主要子项目 261
14.2 Hadoop实践部署 262
14.2.1 Hadoop安装 262
14.2.2 Hadoop集群的配置 263
14.2.3 Hadoop启动 267
14.2.4 Hadoop测试 272
14.2.5 安装第三台slave服务器 273
14.2.6 安装pig 274
14.2.7 安装hive 274
14.2.8 安装jobtracker服务器 276
14.3 Hadoop参数优化 278
14.4 FAQ 281
14.5 小结 283
第七篇 监控应用篇
第15章 服务器监控之Cacti 286
15.1 Cacti概述 286
15.2 Cacti实践部署 287
15.2.1 Cacti编译安装 287
15.2.2 Cacti的使用 297
15.2.3 Cacti的模板使用 305
15.2.4 Cacti的插件使用 308
15.3 FAQ 314
15.4 小结 315
第16章 组建企业级分布式监控系统之Zabbix 316
16.1 Zabbix简介 316
16.1.1 Zabbix的组成 317
16.1.2 Zabbix监控功能优劣对比 317
16.2 Zabbix的实践 319
16.2.1 Zabbix的安装配置 319
16.2.2 为Zabbix添加新主机 330
16.3 Linux流量监控工具iftop 334
16.4 性能监视和分析工具Nmon 336
16.5 FAQ 338
16.6 小结 339
附录A ipvsadm命令参考 340
附录B HAProxy关键字列表 343
附录C Squid客户端命令行参考 346
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高性能网站构建实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高流量网站CSS开发技术
序
技术审稿
致谢
前言
背景
第1章 流程的价值
第2章 CSS格式指导标准
第3章 基本原理
第4章 框架和整合
第5章 品牌实施
第6章 CSS与无障碍访问
第7章 设备
第8章 性能
第9章 动态CSS
第10章 测试与调试
第11章 创建你自己的CSS框架
附录1 CSS指导标准
附录2 无障碍访问指导标准
附录3 浏览器支持指南
附录4 开发流程
译者工具：词汇表
to复审与译者
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高流量网站CSS开发技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实用英语语法
第一章 概论
1．语法的内容（1）
2，词类（2―5）
3．句子成分（6，7）
第二章 构词法
1．概说（8）
2．转化（9―14）
3．派生（15―20）
4、合成（21―24）
5．一些次要的构词法（25，26）
第三章 名词
1．名词的分类（27～30）
2．名词的数（31―35）
3．名词的格（36－43）
4，名词的性（ 44，45）
5．名词在句中的作用（46―48）
第四章 冠词
1．概说（49，50）
2．不走冠词的基本用法（51―55）
3．定冠词的基本用法（56―60）
4，专有名词前冠词的用法（61―64）
5，抽象名词前冠词的用法（65―67）
6．物质名词前冠词的用法（68―70）
7．冠词的其他用法（71―75）
第五章 代词
1．代词的分类（76）
2．人称代词（77，78）
3．物主代词（79，80）
4．自身代词（81―83）
5．相互代词（84，85）
6．指示代词（86―88）
7．疑问代词（89）
8．关系代词（90―95）
9．连接代词（96―98）
10．不定代词（99―109）
第六章 数词
1．基数词（110―113）
2．序数词（114―116）
3．分数词（117―120）
第七章 动词（I）概说
1．动词的分类（121―123）
2. 动词的限定形式和非限定形式（124，125）
3．动词的基本形式（126―128）
第八章 动词（II）时态
1．概说（129―131）
2．一般现在时（132―137）
3，现在进行时（138―142）
4．一般将来时（143―146）
5．一般过去时（147，148）
6．现在完成时（149―154）
7．过去进行时（155―157）
8．过去完成时（158―160）
9．一般过去将来时（161，162）
10．现在完成进行时和过去完成进行时（163，164）
11．其他时态的用法（165―170）
12．时态的呼应（171―174）
第九章 动词（III）被动语态
1．被动语态的基本用法（175―178）
2．一些特殊的被动结构（179―181）
3．被动结构和带表语的结构（182）
第十章 动词（IV）虚拟语气
1．概说（183）
2．虚拟语气在条件句中的应用（184―188）
3.虚拟语气在某些从句中的应用（189-191）
4，虚拟语气在其他情况下的应用（192，193）
第十一章 动词（V）助动词和情态动词
1．助动词的用法（194―201）
2．情态动词的用法（202―210）
3，情态动词后的某些动词形式（211―213）
第十二章 动词（VI）不定式
1．概说（214，215）
2．作主语、宾语和表语用的不定式（216―218）
3．作定语用的不定式（219―222）
4．作状语用的不定式（223―226）
5．在复合结构中用的不定式（227―232）
6．不定式的完成式、进行式和完成进行式（233―235）
7．不定式的被动形式（236―238）
8．有关不定式短语结构的几个问题（239―244）
第十三章 动词（VII）动名词
1．概说（245，246）
2．作主语和表语用的动名词（247，248）
3．作宾语用的动名词（249―251）
4．作介词宾语用的动名词（252―255）
5．前面带有代词或名词的动名词结构（256，257）
6．动名词的完成形式与被动形式（258，259）
7．名词化的动名词（260）
第十四章 动词（VIII）分词
1．概说（261―263）
2．作表语用的分词（264，265）
3．作定语用的分词（266―271）
4．作状语用的分词（272―280）
5．用在复合结构中的分词（281―283）
6．现在分词的完成形式和被动形式（284，285）
第十五章 形容词
1．形容词在句中的作用（286，287）
2．形容词的比较级和最高级（288―295）
3．名词化的形容词（296）
第十六章 副词
1．副词的分类（297―303）
2．副词在句中的作用（304―306）
3．副词在句中的位置（307―311）
4．副词的比较级和最高级（312一316）
第十七章 介词
1．概说（317―319）
2．介词短语在句中的作用（320）
3.一些常用介词的基本用法（321―369）
第十八章 连词
1．概说（370―372）
2．并列连词（373―375）
3．从属连词（376―383）
第十九章 感叹词
1．概说（384）
2．一些常用的感叹词（385）
第二十章 句子
1．句子及其分类（386―388）
2．陈述句、疑问句、祈使句和感叹句（389―396）
3．简单句、并列句和复合句（397―400）
第二十一章 主语
1．主语表示法（401）
2．以it作主语的句子（402―410）
3．以从句作主语的句子（411―414）
4．以there引起的句子（415―417）
第二十二章 谓语
1．谓语的类型（418）
2．复合谓语（419―424）
3．表语表示法（425―431）
4．主语和谓语的一致（432―437）
第二十三章 宾语
1．直接宾语和间接宾语（438―441）
2．宾语表示法（442―445）
3．复合宾语（446―452）
4．宾语从句（453―460）
5．直接引语和间接引语（461―467）
第二十四章 定语
1. 定语表示法（468―472）
2．介语短语作定语（473―476）
3．定语从句（477―485）
4．同位语（486―491）
第二十五章 状语
1．状语表示法（492―495）
2．分词作状语（496，497）
3．形容词作状语（498）
4．词组作状语（499―502）
5．复合结构作状语（503―506）
6．状语从句（507―517）
第二十六章 独立成分
1．独立成分的类型（518）
2．插入语（519―523）
第二十七章 语序
1．主语和谓语的位置（524―532）
2．宾语的位置（533―536）
3．定语的位置（537―540）
4．状语的位置（541―548）
第二十八章 省略句
1．概说（549―551）
2．简单句中的省略（552，553）
3．复合句中的省略（554―557）
4．并列句中的省略（558，559）
第二十九章 句型转换
1．概说（560，561）
2．简单句句型的转换（562―567）
3．复合句和并列句句型的转换（568，569）
4．简单句和复合句的互变（570－578）
5．句子的合并（579―582）
第三十章 句子分析
1．概论（583―585）
2．简单句的分析举例（586，587）
3．并列句分析举例（588，589）
4．复合句分析举例（590，591）
第三十一章 标点符号
1．概说（592）
2．用在句子末尾的标点符号（593，594）
3．用在句子当中的标点符号（595―602）
4．用在一个词内部的符号（603）
附录
1．不规则动词表
2．常用语法术语表
3．关于语法体系的一些说明
参考书目
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实用英语语法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>构建高性能可扩展ASP.NET网站
第1章 原则和方法	1
1.1 性能和可扩展性的差异	2
1.2 为什么需要高性能和高可扩展性	2
1.2.1 优化	3
1.2.2 过程	3
1.2.3 体验	4
1.3 完整的页面处理过程	4
1.4 原则概述	6
1.4.1 性能原则	6
1.4.2 次要技术	7
1.5 本书使用的环境和工具	8
1.5.1 软件工具和版本	8
1.5.2 术语	9
1.5.3 排版约定	9
1.5.4 作者网站	9
1.6 小结	10
第2章 客户端性能	11
2.1 浏览器页面处理	12
2.1.1 网络连接和初始HTTP请求	12
2.1.2 页面解析和新的资源请求	13
2.1.3 页面资源的顺序以及重新排序	14
2.2 浏览器缓存	15
2.3 网络优化	16
2.4 脚本包含文件的处理	18
2.4.1 通过在脚本之前排队资源请求提高并行化	18
2.4.2 减少脚本文件的数量	19
2.4.3 在页面剩余时间里请求对象	21
2.4.4 脚本延迟	22
2.4.5 针对脚本的服务器端方法	22
2.5 少下载	22
2.5.1 减少每个页面中资源的数量	22
2.5.2 降低HTML、CSS和JavaScript的大小	24
2.5.3 最大化压缩	25
2.5.4 图片优化	25
2.5.5 网站图标文件	29
2.5.6 HTML、CSS和JavaScript的一般优化	29
2.6 使用JavaScript限定页面请求	32
2.6.1 提交按钮	33
2.6.2 链接	33
2.7 使用JavaScript降低HTML大小	34
2.7.1 生成重复的HTML	34
2.7.2 为标签添加重复文本	35
2.8 减少上传	36
2.9 CSS优化	38
2.10 图片精灵和集群	41
2.11 利用DHTML	43
2.12 使用Ajax	43
2.13 使用Silverlight	45
2.13.1 创建HTML控件	46
2.13.2 在JavaScript中调用Silverlight内代码	48
2.13.3 使用Silverlight改进性能的其他方式	49
2.14 提高呈现速度	50
2.15 预缓存	51
2.15.1 预缓存图片	51
2.15.2 预缓存CSS和JavaScript	52
2.16 使用CSS实现无表格的布局	53
2.17 优化JavaScript的性能	56
2.18 小结	57
第3章 缓存	59
3.1 在所有层中缓存	59
3.2 浏览器缓存	60
3.2.1 缓存静态内容	61
3.2.2 缓存动态内容	63
3.3 ViewState	65
3.4 Cookie	71
3.4.1 设置会话Cookie	71
3.4.2 单个Cookie中多个名称/值对	72
3.4.3 Cookie属性	72
3.5 Silverlight独立存储	80
3.5.1 示例程序：“欢迎回来”	80
3.5.2 部署并更新Silverlight应用	84
3.6 代理缓存	85
3.6.1 使用Cache-Control HTTP头	85
3.6.2 管理相同内容的不同版本	87
3.7 Web服务器缓存	87
3.7.1 Windows内核缓存	87
3.7.2 IIS 7输出缓存	92
3.7.3 ASP.NET输出缓存	93
3.7.4 ASP.NET对象缓存	98
3.8 SQL Server缓存	103
3.9 分布式缓存	104
3.10 缓存过期时间	105
3.10.1 动态内容	105
3.10.2 静态内容	105
3.11 小结	106
第4章 IIS 7	108
4.1 应用程序池和Web园	108
4.2 请求处理管道	110
4.3 Windows系统资源管理器	111
4.4 常见的HTTP问题	113
4.4.1 HTTP重定向	114
4.4.2 HTTP头	115
4.5 压缩	118
4.5.1 启用压缩	118
4.5.2 设置压缩选项	120
4.5.3 使用web.config配置压缩	121
4.5.4 缓存压缩的内容	121
4.5.5 使用编程方式启用压缩	122
4.6 HTTP Keep-Alive	122
4.7 优化URL	122
4.7.1 虚拟目录	123
4.7.2 URL重写	123
4.8 管理流量	126
4.8.1 使用robots.txt	126
4.8.2 网站地图	127
4.8.3 带宽节流	128
4.9 跟踪失败请求	130
4.10 IIS性能调校提示	133
4.11 小结	134
第5章 ASP.NET线程与会话	135
5.1 线程影响可扩展性	135
5.2 ASP.NET页面生命周期	136
5.3 应用程序线程池	137
5.3.1 同步页面	138
5.3.2 异步页面	138
5.3.3 负载测试	140
5.3.4 改进已有的同步页面的可扩展性	142
5.3.5 从单个页面上执行多个异步任务	143
5.3.6 超时处理	144
5.3.7 异步Web服务	145
5.3.8 异步文件I/O	148
5.3.9 异步Web请求	149
5.4 后台工作线程	151
5.4.1 使用后台线程记录日志	152
5.4.2 任务串行化	157
5.5 锁定指南和使用ReaderWriterLock	157
5.6 会话状态	158
5.6.1 会话ID	159
5.6.2 InProc模式	159
5.6.3 使用StateServer	160
5.6.4 使用SQL Server	160
5.6.5 有选择的启用会话状态，使用ReadOnly模式	161
5.6.6 可扩展性会话状态支持	162
5.6.7 调校	167
5.6.8 完全自定义会话状态	167
5.6.9 会话序列化	168
5.7 会话状态的其他方案	168
5.8 小结	169
第6章 使用ASP.NET实现和管理优化技术	170
6.1 母版页	170
6.2 用户控件	173
6.2.1 示例	173
6.2.2 注册和使用控件	175
6.2.3 将控件放在DLL中	175
6.3 主题	176
6.3.1 静态文件	176
6.3.2 皮肤	176
6.3.3 动态设定主题	176
6.3.4 可以放在主题里的属性	177
6.3.5 示例	178
6.3.6 预缓存主题图片	179
6.4 特定于浏览器的代码	179
6.4.1 使用Request.Browser	181
6.4.2 特定于浏览器属性前缀	182
6.4.3 缓存特定于浏览器的页面	183
6.4.4 控件适配器	184
6.4.5 浏览器提供程序	185
6.4.6 伪装	187
6.5 动态生成JavaScript和CSS	187
6.5.1 示例	188
6.5.2 从JavaScript里访问ASP.NET控件	189
6.6 给静态文件设置多个域名	190
6.7 修改图片大小	191
6.8 小结	193
第7章 管理ASP.NET应用程序策略	194
7.1 自定义HttpModule	194
7.1.1 示例HttpModule的需求	195
7.1.2 Init() 方法	195
7.1.3 PreRequestHandlerExecute事件处理器	197
7.1.4 BeginAuthenticateRequest事件处理器	197
7.1.5 EndAuthenticateRequest事件处理器	199
7.1.6 EndRequest事件处理器	200
7.1.7 数据库表和存储过程	201
7.1.8 在web.config中注册该HttpModule	202
7.2 自定义HttpHandler	202
7.2.1 开始请求	203
7.2.2 结束请求	204
7.3 页面基类	205
7.4 页面适配器	206
7.4.1 示例：PageStatePersister	206
7.4.2 PageAdapter类	207
7.4.3 注册PageAdapter	208
7.5 URL重写	208
7.5.1 在HttpModule中重写URL	208
7.5.2 修改表单使用重写的URL	209
7.6 标签转换	210
7.7 深入理解控件适配器	211
7.8 重定向	212
7.8.1 传统的重定向	212
7.8.2 永久重定向	213
7.8.3 使用Server.Transfer()	213
7.9 尽早刷新响应	214
7.9.1 标记	214
7.9.2 隐藏文件	214
7.9.3 包跟踪	215
7.9.4 块编码	216
7.9.5 小结	217
7.10 过滤空格	218
7.11 避免不必要工作的其他方法	220
7.11.1 检查Page.IsPostBack	220
7.11.2 确定页面是否刷新	220
7.11.3 避免在回发之后重定向	220
7.11.4 检查Response.IsClient- Connected	221
7.11.5 关闭调试模式	221
7.11.6 批量编译	222
7.12 小结	222
第8章 SQL Server关系数据库	224
8.1 SQL Server如何管理内存	224
8.1.1 内存组织	225
8.1.2 读和写	225
8.1.3 性能影响	226
8.2 存储过程	226
8.3 批量命令	228
8.3.1 使用SqlDataAdapter	228
8.3.2 构建参数化命令串	231
8.4 事务	233
8.5 多结果集	238
8.5.1 使用SqlDataReader. NextResult()	238
8.5.2 使用SqlDataAdapter和DataSet	239
8.6 数据预缓存	240
8.6.1 方法	240
8.6.2 预缓存基于表单的数据	241
8.6.3 预缓存每次一个页面的数据	241
8.7 数据访问层	242
8.8 查询和结构优化	243
8.9 其他查询优化指导原则	251
8.10 数据分页	251
8.10.1 公用表表达式	251
8.10.2 数据分页的详细示例	252
8.11 对象关系模型	258
8.12 XML列	259
8.12.1 XML架构	260
8.12.2 创建示例表	261
8.12.3 基本XML查询	262
8.12.4 修改XML数据	263
8.12.5 XML索引	263
8.12.6 其他XML查询技巧	264
8.13 数据分区	264
8.13.1 分区函数	265
8.13.2 分区架构	265
8.13.3 生成测试数据	266
8.13.4 添加索引，配置锁升级	268
8.13.5 存档旧数据	269
8.13.6 小结	269
8.14 全文搜索	269
8.14.1 创建全文目录和索引	270
8.14.2 全文查询	271
8.14.3 获得搜索分级的细节	271
8.14.4 全文搜索语法小结	271
8.15 Service Broker	272
8.15.1 启用和配置Service Broker	273
8.15.2 发送消息的存储过程	274
8.15.3 使用存储过程接收消息	274
8.15.4 测试示例	275
8.15.5 避免中毒消息	276
8.16 通过Service Broker发送E-mail	276
8.16.1 创建后台工作线程	277
8.16.2 读取并处理信息	278
8.16.3 排队消息和发送邮件的Web窗体	280
8.16.4 结果	282
8.17 数据变化通知	283
8.17.1 查询约束	283
8.17.2 示例：简单的配置系统	284
8.18 Resource Governor	287
8.18.1 配置	287
8.18.2 测试	290
8.19 横向扩展与纵向扩展	290
8.19.1 纵向扩展	290
8.19.2 横向扩展	291
8.19.3 确定系统瓶颈	292
8.20 高可用性	293
8.21 其他方面的性能提示	294
8.22 小结	295
第9章 SQL Server Analysis Services	297
9.1 分析服务概览	297
9.2 MDDB示例	299
9.2.1 RDBMS结构	299
9.2.2 数据源视图	300
9.2.3 Cube	303
9.2.4 时间维度	303
9.2.5 Items和Users维度	305
9.2.6 计算的成员	306
9.2.7 部署和测试	307
9.3 示例MDX查询	307
9.4 ADOMD.NET	313
9.4.1 单个单元格结果示例	313
9.4.2 使用GridView显示多行结果	315
9.5 使用SSIS更新Cube	316
9.6 预先缓存	319
9.6.1 数据存储选项	319
9.6.2 缓存模式	320
9.7 使用中间数据库	323
9.8 小结	324
第10章 基础和运维	325
10.1 插桩	325
10.2 容量规划	329
10.3 磁盘子系统	330
10.3.1 随机每秒钟I/O次数与顺序每秒钟I/O次数	330
10.3.2 NTFS碎片	331
10.3.3 磁盘分区设计	333
10.3.4 RAID选项	334
10.3.5 存储阵列网络	336
10.3.6 控制器缓存	337
10.3.7 固态磁盘	337
10.4 网络设计	338
10.4.1 巨型帧	338
10.4.2 链接集成	339
10.5 防火墙和路由器	340
10.5.1 Windows防火墙和防病毒软件	341
10.5.2 使用路由器作为硬件防火墙的替代方案	341
10.6 负载均衡器	341
10.7 DNS	342
10.8 临时环境	343
10.9 部署	343
10.9.1 数据层升级	344
10.9.2 提高部署速度	344
10.9.3 页面编译	345
10.9.4 预热缓存	345
10.10 服务器监控	346
10.11 小结	347
第11章 综合起来	348
11.1 从何处入手	348
11.2 开发过程	349
11.2.1 组织	350
11.2.2 项目阶段和里程碑	350
11.2.3 编码	351
11.2.4 测试	351
11.2.5 Bug跟踪	351
11.2.6 用户反馈	352
11.2.7 高性能的技巧	352
11.3 League	354
11.4 工具	355
11.5 架构	356
11.6 备忘录	357
11.6.1 原则和方法（第1章）	357
11.6.2 客户端性能（第2章）	357
11.6.3 缓存（第3章）	359
11.6.4 IIS 7（第4章）	360
11.6.5 ASP.NET线程和会话（第5章）	361
11.6.6 使用ASP.NET实现并管理优化技术（第6章）	361
11.6.7 管理ASP.NET应用策略（第7章）	362
11.6.8 SQL Server关系数据库（第8章）	363
11.6.9 SQL Server分析服务（第9章）	364
11.6.10 基础设施和运维（第10章）	364
11.7 小结	365
词汇表	367

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>构建高性能可扩展ASP.NET网站
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>玩转电商系统：深入剖析智慧电商平台
第1 章 引言 ................................ 1
1.1 电商的本质是什么 ................ 2
1.2 电商系统的组成 .................... 4
1.3 电商系统如何规划 ................ 6
第2 章 初始阶段 ........................ 9
2.1 玩转电商，系统先行 .......... 10
2.2 从0 到1，系统升级 ........... 11
第3 章 成长阶段 ...................... 14
3.1 打造业界一流的顾客体验 ... 15
3.1.1 体验一日客服 .................. 15
3.1.2 CPO 是反映顾客服务水平的综合指标 ..................... 18
3.1.3 订单异常监控系统 ........... 19
3.1.4 顾客自助服务系统 ........... 19
3.2 搜索 ...................................... 20
3.3 构建信息安全屏障 .............. 35
3.3.1 账户安全 ........................ 35
3.3.2 反爬虫 ............................ 35
3.3.3 网盟反作弊 ..................... 37
3.3.4 防作弊系统 ..................... 38
3.4 让营销变得更聪明 .............. 39
3.4.1 确定自主研发自动化营销系统 ............................... 39
3.4.2 SEM 让更多的人“下岗” .......................... 41
3.5 商城生意的爆炸式增长 ...... 47
3.5.1 商家——新鲜血液的注入 ............................... 47
3.5.2 入驻手段——让商家放心的“安家”流程 .............. 48
3.5.3 打造明星商家 .................. 48
3.5.4 购物狂欢节 ..................... 49
3.6 如何管理数百万的SKU——PIS 系统的诞生 ........... 50
3.6.1 为什么要比价 .................. 50
3.6.2 智能调价模型的探索 ........ 66
3.7 BI 的发展历程 ..................... 67
3.7.1 什么是BI ........................ 67
3.7.2 电商BI 跟传统BI 的关系 ............................... 68
3.7.3 BI 跟大数据的关系 .......... 68
3.7.4 BI 应用的强大支撑——IDW ........................ 69
3.7.5 数据的应用典型案例——数据魔方 ................. 72
3.7.6 数据应用的未来 .............. 75
3.8 智能供应链管理及系统搭建 ..................................... 75
3.8.1 仓库管理系统——穿越仓库“丛林” ................. 77
3.8.2 运输管理系统——看车水马龙之势 ........................ 89
3.8.3 采购管理系统——柳明花却暗 .............................. 102
3.8.4 供应链服务系统——惊现“天外天” ..................... 113
第4 章 迈向未来阶段 ............ 119
4.1 创新的供应链优化 ........... 120
4.1.1 区域化运营 .................... 120
4.1.2 多地多仓系统 ................ 123
4.2 超大型电商系统布局 ....... 126
4.2.1 SOA 架构 ...................... 126
4.2.2 开放平台 ....................... 131
4.2.3 电商云 .......................... 133
4.2.4 电商怎么做O2O ............ 136
4.3 移动电商展望 .................... 142
4.3.1 移动购物行业现状 ......... 142
4.3.2 移动电商之个性化 ......... 143
4.3.3 移动电商之全员无线化 ... 146
第5 章 电商之魂——技术 .... 151
5.1 上千人的技术团队怎么管 ............................... 152
5.1.1 开放、共享、追求极致的工程师文化................ 152
5.1.2 多地研发中心的管理 ..... 156
5.1.3 敏捷开发模式................ 161
5.2 大数据驱动的开发工作平台 ................................... 175
5.2.1 平台介绍 ....................... 176
5.2.2 应用场景 ...................... 176
5.3 技术引领业务的道与术 .... 189
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>玩转电商系统：深入剖析智慧电商平台
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>品悟性能优化
目录回到顶部↑
《品悟性能优化》
第1章 从两个案例开始 1
1.1 关于案例的说明 2
1.2 体验日本人工作风格 2
1.2.1 问题现象及解决过程 2
1.2.2 日本人严谨、细致的工作风格 3
1.2.3 日本人的it投入观 3
1.2.4 该系统的总体感觉 4
1.2.5 在日本企业暖意洋洋的一幕 4
1.2.6 也谈强国梦 5
1.3 国内某大型银行故障的解决 5
1.3.1 天塌下来一样的故障 5
1.3.2 故障原因其实很简单 6
1.3.3 故障的启示 7
1.3.4 2010年银行案例的进一步感悟 8
第2章 oracle数据库性能优化方法论 9
2.1 关于性能优化的误区 10
2.1.1 “你调了哪些参数” 10
2.1.2 “性能优化主要是dba和系统管理员的工作” 10
2.1.3 “开发阶段无须太多考虑性能问题” 11
.2.1.4 “优化sql，就是如何编写sql” 11
2.1.5 “多表连接性能太差” 11
2.1.6 “cpu利用率越低越好” 12
2.1.7 “大内存能解决性能问题” 12
2.1.8 “性能分析就是分析低层细节” 13
2.2 性能优化过程——自顶向下 13
2.2.1 为时已晚 13
2.2.2 什么叫自顶向下方法论 13
2.2.3 体验方法论 15
2.3 高质量it系统的正确认识 15
2.3.1 高质量it系统的目标 15
2.3.2 目标的综合平衡 16
2.3.3 你只管进，不管出啊 16
2.4 20/80规则 17
2.4.1 性能优化中也有20/80规则 17
2.4.2 用数据诠释20/80规则 18
2.5 性能优化过程——自底向上 19
2.5.1 什么叫自底向上方法论？ 19
2.5.2 客户要给我上课 20
2.6 性能优化中的角色分工 20
2.6.1 老外的角色分工 20
2.6.2 国内的角色分工 21
2.7 应用开发指导思想 22
2.7.1 管理重于技术 22
2.7.2 我听后，开心死了 22
2.8 合理运用技术的重要性 22
2.8.1 联机事务处理系统（oltp）和决策支持系统（olap） 22
2.8.2 “你们oracle给我们出一个开发规范和指南吧” 23
2.8.3 4分钟如何优化到1秒钟 24
第3章 性能优化分析基本工具的使用 29
3.1 性能优化中的量化分析 30
3.1.1 隔靴抓痒 30
3.1.2 sql语句到底是怎么执行的 30
3.1.3 性能分析都分析哪些量化指标 32
3.2 工欲善其事，必先利其器 32
3.2.1 sql量化分析和优化工具 32
3.2.2 oracle有大量实用的小工具和命令 33
3.3 sql语句到底是怎么被执行的 34
3.3.1 最经典的执行计划分析工具 34
3.3.2 这种老掉牙的东西，还用啊 34
3.3.3 10g新功能：dbms_xplan 34
3.4 如何配套使用sql*trace和tkprof 35
3.4.1 又一对老古董 35
3.4.2 其实功能非常强 35
3.4.3 报告分析比如何产生报告更重要 37
3.5 最常用的工具：autotrace 37
3.6 一个洋“忽悠”的故事 42
3.6.1 洋和尚到中国来念梵文了 42
3.6.2 洋大“忽悠”啊 43
3.7 性能优化与“三个代表” 43
3.7.1 重温“三个代表” 43
3.7.2 案例背景 43
3.7.3 自底向上方法论的运用 44
3.7.4 关键应用问题的解决 45
3.7.5 诠释“三个代表” 47
第4章 基本索引的使用 49
4.1 索引既简单又复杂 50
4.1.1 关于索引的需求 50
4.1.2 索引其实好简单 50
4.1.3 索引其实好难 50
4.1.4 想做个懂oracle索引的专家，难上加难 51
4.2 索引设计基本建议 52
4.2.1 oracle索引长什么样 52
4.2.2 b*树单字段索引设计建议 53
4.2.3 一招鲜，吃遍天 53
4.3 如何避免索引被抑制 56
4.3.1 无从下手，郁闷至极！ 56
4.3.2 幸亏父母都是数学老师 57
4.3.3 慎用自定义函数 58
4.3.4 关于函数索引使用的建议 58
4.3.5 其实是数据库设计问题 59
4.4 一把双刃剑：复合索引 59
4.4.1 复合索引的重要性 59
4.4.2 我如何“戏弄”客户 60
4.4.3 复合索引原理和设计建议 61
4.4.4 it系统是面向客户的，不是给领导看的 63
4.5 一个既简单又复杂的故事 64
4.5.1 女儿说我吹牛了 64
4.5.2 故事上集 65
4.5.3 故事中集 66
4.5.4 故事下集 66
4.6 如何进行索引监控分析和优化 68
4.6.1 为什么索引i/o那么高 68
4.6.2 别乱建索引 68
4.6.3 如何发现多余的索引 69
4.6.4 如何进行索引碎片分析和整理 70
第5章 为应用软件设计更好的性能和可扩展性 71
5.1 基本概念和原理 72
5.1.1 本章标题有点大吧 72
5.1.2 一个屡见不鲜的错误 72
5.1.3 解剖sql语句执行过程 73
5.2 语句共享性原理 74
5.2.1 再说联机事务处理系统（oltp）
和决策支持系统（olap） 74
5.2.2 如何实现语句共享化 74
5.2.3 开发人员永远比oracle聪明 75
5.2.4 技术服务工作，越做胆子越小 75
5.2.5 如何量化评估语句共享性 76
5.3 回到日本企业案例 77
5.3.1 深入分析技术原因 77
5.3.2 被日本人较真的滋味其实不好受 79
5.4 语句共享性的深入分析 79
5.4.1 语句共享性和查询统计系统的关系 79
5.4.2 语句共享性与扩展性的关系 80
第6章 如何提高排序、表连接性能 81
6.1 如何提高排序性能 82
6.1.1 能不排序就不排序——废话一句 82
6.1.2 查询欠费最高的前100名手机客户 83
6.1.3 痛心疾首的一刻 84
6.1.4 ibm和oracle：亦敌亦友 88
6.2 oracle表连接技术和应用 89
6.2.1 数据库精髓之一：表连接 89
6.2.2 最经典、最常用的表连接技术——嵌套循环 90
6.2.3 嵌套循环连接与索引 91
6.2.4 嵌套循环连接的应用场景及效率 93
6.2.5 适合于大批量数据处理的连接技术 94
6.3 多表连接优化的基本思路 96
6.3.1 总体思路 96
6.3.2 oltp应用的表连接优化 96
6.4 如何使用子查询 96
6.4.1 使用子查询好不好 96
6.4.2 到底是使用in还是exists 97
6.5 回到20/80规则 99
6.5.1 优化详细过程 100
6.5.2 技术方面总结 106
6.5.3 每项工作做到最好都不容易 107
第7章 应用综合优化及总结 108
7.1更多的优化案例 109
7.1.1数据类型不一致导致的问题 109
7.1.2 多此一举的操作 111
7.1.3 错误使用hint 113
7.1.4 oracle和ibm又一次成功合作 117
7.2 可怕的笛卡儿乘积 118
7.2.1 问题的发生和初步解决 119
7.2.2 其实是设计和开发中更深层次问题 120
7.3 说说全表扫描 122
7.3.1 导致数据库性能问题的常见原因 122
7.3.2 何谓全表扫描 122
7.3.3 数据增长与全表扫描的关系 123
7.3.4 硬件太多了 124
7.3.5 导致技术运用复杂化的其他问题 124
7.3.6 更多的类比和感慨 125
7.4 导致性能问题的其他原因 125
7.5 一个应用软件的综合优化 126
7.5.1 优化前的状况 126
7.5.2 优化策略及分工合作 127
7.5.3 优化效果及原因分析 127
7.5.4 主管部门的反应 128
7.5.5 美妙的三降预言同时实现 129
7.5.6 优化工作的艰巨性和长期性 129
7.6 一个朴实无华的好系统 130
7.6.1 国人也能做出精良的好系统 130
7.6.2 巨大升值空间 131
7.6.3 瑕不掩瑜 131
第8章 oracle分区技术及应用 133
8.1 硅谷之行 134
8.1.1 it人的圣地：硅谷 134
8.1.2 我在oracle总部中邪了 135
8.2 我对oracle分区技术的认知过程 135
8.2.1 初尝分区甜头 135
8.2.2 分区给我的痛苦体验 137
8.2.3 全面理解分区技术 138
8.3 分区表技术 138
8.3.1 分区技术原理：分而治之 138
8.3.2 分区表技术概述 140
8.3.3 11g的分区新技术 144
8.4 分区索引技术 146
8.4.1 分区索引技术好难哦 146
8.4.2 10分钟让你理解最难的分区索引 149
8.4.3 分区索引设计指南 151
8.5 更多的分区技术 153
8.5.1 一个神奇的分区技术 153
8.5.2 oracle分区技术发展史 154
8.6 如何实施和评估分区 155
8.6.1 分区设计建议 155
8.6.2 分区效果评估 156
8.6.3 如何在生产系统实施分区 156
8.7 某行业分区方案设计的曲折过程 159
8.7.1 第一阶段：出师不利 159
8.7.2 第二阶段：经验主义错误 160
8.7.3 第三阶段：初见成效 160
8.7.4 第四阶段：日臻完善 160
8.8 分区方案中常见问题探讨 161
8.8.1 问题1：目标方面的误区 161
8.8.2 问题2：分区表设计方面的误区 162
8.8.3 问题3：没有充分考虑应用设计和开发的误区 162
8.8.4 问题4：分区表空间设计方面的误区 163
8.8.5 问题5：分区在大批量数据处理中的误区 164
8.8.6 问题6：分区索引设计方面的误区 164
8.8.7 无止境的分区技术 165
第9章 架构与性能优化 166
9.1 该谈谈架构了 167
9.1.1 架构与性能的关系 167
9.1.2 oracle高端架构产品与性能的关系 167
9.1.3 oracle架构的重要性 168
9.2 基本概念很重要 169
9.2.1 什么是oracle数据库 169
9.2.2 服务器、实例和数据库的关系 170
9.2.3 关于架构方面的误区 172
9.3 it系统架构现状分析 173
9.3.1 一副并不美妙的大蜘蛛网 173
9.3.2 现有体系结构特点分析 174
9.3.3 现有体系结构评估 174
9.4 oracle网格计算 176
9.4.1 oracle 10g = 网格计算 176
9.4.2 按网格计算设计数据库架构 176
9.4.3 乌托邦式架构就是好 178
9.4.4 初级阶段的设计建议 179
9.4.5 关于真正大集中的疑虑 179
9.5 云计算与性能优化 182
9.5.1 满天翻滚的云 182
9.5.2 oracle的红云 182
9.5.3 客户关注的云计算话题 183
9.6 oracle数据库分布式架构 184
9.6.1 数据复制技术 184
9.6.2 data guard技术简介 186
9.6.3 streams技术简介 187
9.6.4 其他数据同步技术 188
9.6.5 数据同步技术的定位和比较 188
9.7 我看分布式架构 190
9.7.1 我不喜欢分布式架构 190
9.7.2 数据大集中与分布式架构 191
9.7.3 分布式架构的用武之地 192
9.7.4 真正的返璞归真 192
9.8 誓做抗拒拆迁的刁民 193
9.8.1 拆迁大锤已高高举起 193
9.8.2 统一战线发挥重要作用 193
9.8.3 人民战争的汪洋大海 195
9.9 一个本来平淡的日子 195
9.9.1 什么专家，拿了钱就跑？ 195
9.9.2 艰难的问题诊断过程 196
9.9.3 一根救命稻草 197
9.9.4 技术方面的教训和感悟 197
9.9.5 犹豫半天的话语 198
第10章 rac与性能优化 200
10.1 关于rac的一些误解和疑虑 201
10.2 rac技术原理 203
10.2.1 系统介绍rac架构和原理 203
10.2.2 rac到底有什么好处 204
10.2.3 10g rac架构新特性 205
10.2.4 我害怕oracle什么技术工作 206
10.3 rac架构的优势 207
10.3.1 为什么rac架构比ha架构好 207
10.3.2 客户的方案不一定是最优的 209
10.4 rac实施方法论 210
10.4.1 还是方法论重要 210
10.4.2 “你打个补丁要三天啊？” 211
10.4.3 如何降低rac实施和运行风险 212
10.4.4 rac其实背了好多黑锅 212
10.5 rac性能优化原理 213
10.5.1 rac性能优化等同于单事例 213
10.5.2 rac性能问题与应用关系 214
10.5.3 应用在rac环境下部署的最佳方式 216
10.6 rac环境下的性能分析 217
10.6.1 rac性能分析基本策略 217
10.6.2 awr报告中的rac性能分析 217
10.6.3 addm报告中的rac问题原因分析 218
10.6.4 gcs性能分析 219
10.6.5 ges性能分析 221
10.6.6 下得去，还要上得来 222
10.7 rac高可用性 222
10.7.1 rac高可用性技术其实很复杂 222
10.7.2 rac高可用性实施思路 223
10.7.3 rac高可用性测试案例和测试过程 223
10.8 rac可扩展性 225
10.8.1 rac不能超过4个节点？ 225
10.8.2 oracle总部rac专家的观点 225
10.8.3 某大型交易系统的扩展性测试 226
10.8.4 如何实施rac扩展性 227
10.9 rac运行维护和故障诊断 228
10.9.1 rac运行维护建议 228
10.9.2 rac故障诊断经验谈 228
10.9.3 瞎猫碰上死耗子 229
第11章 数据仓库中的性能优化 231
11.1 我看数据仓库 232
11.1.1 数据仓库不是仓库管理软件 232
11.1.2 数据仓库鼻祖的精确定义 232
11.1.3 数据仓库的应用特点 233
11.1.4 我所理解的数据仓库 233
11.1.5 本书讲述的数据仓库 234
11.2 数据仓库应用开发指导思想 235
11.2.1 数据仓库应用开发指导思想建议 235
11.2.2 案例为证 235
11.2.3 如何贯彻大批量、并行处理？ 238
11.3 并行处理技术的应用 238
11.3.1 oracle并行处理技术无处不在 238
11.3.2 并行处理举例 239
11.3.3 并行技术的几个层面 240
11.3.4 并行处理经验 242
11.3.5 榨干所有硬件资源 243
11.4 oracle是个大计算器 244
11.4.1 告别农耕时代 244
11.4.2 oracle不仅是一个存数据的大容器 244
11.5 大批量数据etl案例 245
11.5.1 vip客户判断标准 245
11.5.2 外部表 246
11.5.3 merge语句 247
11.5.4 vip计算总体流程图 248
11.5.5 简述一个流程 249
11.5.6 方案评估 250
11.6 “非典”期间的一个典型性问题 250
11.6.1 一个应用开发中的典型性问题 250
11.6.2 oracle系统级临时表 253
11.7 一种快速高效的数据仓库加载方案 253
11.7.1 让洋鬼子激动地蹦到桌子上去 253
11.7.2 快速高效的数据仓库加载方案 255
11.8 报表优化技术 259
11.8.1 我的第一次软件开发经历 259
11.8.2 现在的报表处理状况 260
11.8.3 报表优化核心技术：物化视图和语句重写 261
11.8.4 为什么不要自己编写汇总表 263
11.8.5 报表优化的基本思路及示例 263
11.8.6 报表优化示例 264
11.8.7 为什么没有实现语句重写 268
11.8.8 it行业到底是买方市场还是卖方市场 269
第12章 统计信息采集与性能优化 272
12.1 我闯大祸了 273
12.1.1 常在河边走，哪有不湿鞋的 273
12.1.2 太急于表现了 273
12.1.3 建一个索引，搞死一个系统 274
12.1.4 我被骂得满地找地缝 274
12.1.5 初识问题原因 275
12.1.6 问题根本原因 275
12.2 优化器原理和统计信息采集作用 276
12.2.1 sql语句执行过程 276
12.2.2 基于规则优化器（rbo）简介 277
12.2.3 基于成本优化器（cbo）简介 278
12.2.4 如何将葫芦和瓢都按下 278
12.2.5 为什么要进行统计信息采集 279
12.3 自动采集统计信息 279
12.3.1 自动采集统计信息的特点 279
12.3.2 自动还是手工 280
12.3.3 超长的自动统计信息采集 280
12.3.4 一次变味的数据库升级技术研讨会 282
12.4 定制采集统计信息 282
12.4.1 统计信息采集基本策略 282
12.4.2 统计信息采集实施策略 283
12.4.3 统计信息采集具体方法 283
12.4.4 oracle 10g鬼精鬼精的 285
12.5 若干最佳实践经验 286
12.5.1 自动和手工结合进行统计信息采集 286
12.5.2 锁住统计信息采集 286
12.5.3 数据分布统计（histogram）建议 286
12.5.4 批处理中的统计信息采集 287
12.5.5 铁路警察，各管一段 288
第13章 感悟性能优化分析的高级工具 290
13.1 oracle 10g = oracle 10a 291
13.1.1 外部手工管理变内部自动管理 291
13.1.2 oracle 10g都有哪些自动的东西 292
13.2 awr是个好东西 292
13.2.1 awr原理 292
13.2.2 awr基本操作 293
13.2.3 把awr功能用个够 295
13.3 addm：oracle能自动诊断监控吗 298
13.3.1 addm能干啥 298
13.3.2 dba要失业了吗 300
13.4 sql优化进入工业化时代 301
13.4.1 传统模式到工业化 301
13.4.2 sql tuning advisor能做哪些优化 302
13.4.3 sql access advisor能做哪些优化 304
13.4.4 sql tuning advisor和sql access advisor的差异 304
13.4.5 oem中的每条命令我都会敲 304
13.4.6 it工业化时代的初级阶段 305
第14章 参数配置与性能优化 307
14.1 神奇的“魔术师” 308
14.1.1 不调系统参数 308
14.1.2 调错系统参数 308
14.2 漫谈初始化参数 309
14.2.1 神奇的初始化参数 309
14.2.2 参数设置基本思路和经验 310
14.2.3 将log buffer设它个几百兆 311
14.3 自动内存管理 311
14.3.1 dba真地快没活干了 311
14.3.2 自动内存管理技术管用吗 314
14.4 buffer cache优化 315
14.4.1 buffer cache参数设置思路 315
14.4.2 buffer cache优化技术 316
14.4.3 buffer cache的其他优化技术 318
14.5 shared pool优化 319
14.5.1 shared pool参数设置思路 319
14.5.2 shared pool优化技术 320
14.5.3 再撞一次墙 321
14.6 pga优化 321
14.6.1 pga参数设置思路 321
14.6.2 匪夷所思的做法 323
14.7 奇妙的oracle内部参数 325
14.7.1 oracle有神奇的内部参数吗？ 325
14.7.2 内部参数的一次神奇作用 325
14.7.3 不要滥用内部参数 327
14.7.4 令人眼花缭乱的内部参数和event 327
第15章 存储技术与性能优化 330
15.1 什么时候才考虑i/o优化 331
15.2 裸设备？文件系统？asm？ 331
15.2.1 裸设备有那么神奇吗？ 331
15.2.2 客户期望值太高了 332
15.2.3 文件系统和裸设备的原理分析 332
15.2.4 文件系统同样好 333
15.3 raid与性能优化 334
15.3.1 也说raid 334
15.3.2 ibm太慷慨了 334
15.4 oracle管存储了 336
15.4.1 关于asm的疑虑 336
15.4.2 asm是什么？ 336
15.4.3 asm有什么技术优势？ 337
15.4.4 oracle即将不支持裸设备了 338
15.5 asm优化策略 338
15.5.1 裸设备与asm的性能对比 338
15.5.2 如何保证asm实施的高性能 340
15.5.3 asm事例的参数设置建议 341
15.6 asm实施案例 343
15.6.1 我所见过的真正海量数据库 343
15.6.2 裸设备还是asm文件系统？ 344
15.6.3 asm、omf、大表空间技术的完美结合 344
15.6.4 年轻教授被asm气得直跳脚 345
15.6.5 宽容平和的心态 346
第16章 数据保护中的性能优化 348
16.1 oracle丰富的数据保护技术 349
16.1.1 oracle高可用性解决方案全景图 349
16.1.2 相关技术和产品的定位 349
16.2 rman实施现状分析 350
16.2.1 备份恢复只是磁带库厂商的事情？ 350
16.2.2 rman实施中常见问题分析 351
16.3 rman备份的优化 353
16.3.1 rman备份优化的基本策略 353
16.3.2 rman备份优化的传统技术 353
16.3.3 在表空间级进行rman备份 354
16.3.4 10g的快速增量备份技术 356
16.3.5 备份压缩技术 358
16.4 rman恢复的优化 358
16.4.1 头疼医头，脚疼医脚 358
16.4.2 降低日志恢复量 360
16.4.3 增量更新备份 361
16.5 快速恢复数据的新技术：flashback 361
16.5.1 人为逻辑错误是最大的单一因素 361
16.5.2 传统的数据恢复技术及缺陷 362
16.5.3 flashback技术概述 363
16.5.4 flashback技术综合对比 364
16.5.5 flashback技术与传统数据恢复技术综合运用 365
16.6 data guard实施中的优化 365
16.6.1 容灾系统与生产系统是紧密相关的 365
16.6.2 还是原理最重要 366
16.6.3 日志传输的优化 366
16.6.4 日志恢复的优化 371
16.6.5 容灾系统与生产系统的配置关系 372
16.6.6 也谈data guard与硬件存储镜像技术 372
16.6.7 data guard和存储镜像技术的综合 374
第17章 故障诊断与性能优化 375
17.1 故障诊断与性能优化的区别 376
17.1.1 故障诊断与性能优化不完全是一回事 376
17.1.2 故障诊断需要一个伟大的心脏 376
17.2 大汗淋漓的故障诊断 377
17.2.1 一个“ctrl + c”几乎搞死一个系统 377
17.2.2 啼笑皆非的故障处理过程 378
17.2.3 胁从犯的自责 379
17.3 可别小看数据坏块处理 379
17.3.1 “关于oracle腐败问题的处理” 379
17.3.2 飞机落地了，资料还未看完 380
17.3.3 收集信息、制定处理方案最重要 380
17.3.4 数据坏块处理的八卦图 381
17.3.5 别乱用dul 383
17.3.6 如何防范数据坏块 384
17.4 堪比好来坞大片的情节 385
17.4.1 我的女同事被吓坏了 385
17.4.2 惊心动魄的时刻！ 385
17.4.3 事件远没有结束 386
17.4.4 其实原因很简单 387
17.5 oracle buuuuuuuuuuuuuug 388
17.5.1 我看oracle bug 388
17.5.2 手工作坊与大工厂的差别 389
17.5.3 一个展板都画不下的流程图 389
17.6 软件版本管理和补丁实施 390
17.6.1 相关术语和概念 390
17.6.2 未雨绸缪的补丁实施计划 391
17.6.3 打补丁那点事 392
17.6.4 补丁冲突分析像侦探推理 393
第18章 dba职责及性能管理 395
18.1 我的专职dba经历 396
18.1.1 不太安心的“dba” 396
18.1.2 无所事事的“dba” 396
18.1.3 手忙脚乱的“dba” 397
18.1.4 无所事事的dba 397
18.2 dba职责建议 398
18.2.1 dba的十大任务 398
18.2.2 dba的工作比例 400
18.2.3 不太懂sql的dba 400
18.2.4 一位技术实力超强的dba 401
18.3 dba在性能方面的工作 402
18.3.1 每日的工作 402
18.3.2 每周的工作 403
18.3.3 每月的工作 403
18.3.4 其他的工作 403
18.4 性能管理更重要 404
18.4.1 性能问题其实是管理问题 404
18.4.2 开发人员永远都长不大？ 404
18.4.3 oracle核心技术开发团队的故事 405
18.5 开发与运行维护的脱节 405
18.5.1 开发与运行维护部门的独立性 406
18.5.2 开发与运行维护工作的脱节 406
18.6 客户/开发商/oracle的分工合作 407
18.6.1 目前的分工和定位 407
18.6.2 客户在it系统中的作用 408
18.6.3 建议的分工和定位 409
18.6.4 包含3种角色的项目组 411
18.7 分工合作的成功案例 412
18.7.1 系统运行情况 412
18.7.2 系统主要技术特点 412
18.7.3 项目成功因素分析 413
18.7.4 oracle公司的服务经验 413
18.7.5 项目的不足 414
第19章 软件就是服务 415
19.1 oracle服务体系概述 416
19.1.1 oracle公司组织结构一瞥 416
19.1.2 oracle丰富的服务产品 417
19.2 我看oracle标准服务 419
19.2.1 标准服务不仅仅是法律条款 419
19.2.2 标准服务的益处 419
19.3 爱不释手的metalink 420
19.3.1 幸亏有metalink 420
19.3.2 初尝oracle服务甜头 420
19.3.3 metalink是个大宝藏 421
19.3.4 metalink是个自助式的知识库 422
19.3.5 在metalink中提交sr的经验 423
19.3.6 把metalink当成学习工具 425
19.4 oracle高级客户服务 426
19.4.1 acs服务概述 426
19.4.2 基于itil理念的acs服务 427
19.4.3 我们不是钟点工 430
19.4.4 acs的运行维护服务 430
19.4.5 it系统挑战和acs解决方案服务 432
19.4.6 几种acs解决方案服务 432
19.5 又一次救火之后的感慨 435
19.5.1 又着火了 435
19.5.2 再次感谢metalink 435
19.5.3 客户把系统重新安装了 436
19.5.4 其实还是服务问题 436
第20章 一个更全面的案例 438
20.1 为升级而来 439
20.1.1 初识客户 439
20.1.2 升级方案遇到阻力 439
20.2 以性能优化开路 440
20.2.1 性能是升级的第一大风险 440
20.2.2 调整服务思路 440
20.3 性能整体评估 441
20.3.1 先看操作系统数据 441
20.3.2 数据库基准指标的采集 441
20.3.3 性能分析策略和原则 442
20.4 若干典型问题 443
20.4.1 还是索引这样基础的问题 443
20.4.2 发现了最大的性能瓶颈 445
20.4.3 我把开发人员吓住了 449
20.4.4 参数可调的余地太小 450
20.5 难以解决的问题：中间表 451
20.5.1 又一类典型问题 451
20.5.2 9i没有合适的招 451
20.5.3 10g的有效解决办法 452
20.6 又说分区方案设计 453
20.6.1 分区表太多了 453
20.6.2 分区设计的其他问题 453
20.6.3 综合平衡考虑问题不简单 454
20.7 再说升级 454
20.7.1 对升级的两种极端看法 454
20.7.2 为什么要升级 455
20.7.3 常见的升级方法 456
20.7.4 oracle升级服务包 457
20.7.5 如何降低性能风险 458
第21章 综合类 460
21.1 oracle出硬件了 461
21.1.1 我快变成硬件工程师了 461
21.1.2 我看exadata 461
21.1.3 acs在exadata方面的服务 464
21.2 oracle全文检索技术 465
21.2.1 oracle能做搜索引擎 465
21.2.2 茅塞顿开的解决方案 467
21.2.3 林子大了，什么鸟都有 469
21.3 什么是it系统最宝贵的财富 470
21.3.1 it系统最宝贵的财富是信息本身 470
21.3.2 也谈信息中心的作用 470
21.4 如何阅读oracle联机文档 471
21.4.1 oracle联机文档的确是个宝藏 471
21.4.2 合理分类阅读和利用 471
21.4.3 按工作角色和任务去阅读 473
21.5 it行业中的“伪”科学 474
21.5.1 什么叫it“伪”科学 474
21.5.2 费力不讨好的事情 474
21.5.3 我也是“伪”it科学的吹鼓手 475
21.6 性能优化与桥牌 477
21.6.1 大局观的重要 477
21.6.2 实施计划的重要性 478
21.6.3 应善于捕捉、利用信息 478
21.6.4 合作、沟通的重要性 479
21.6.5 简简单单，平平淡淡就是真 479
21.7 it业其实还是个孩子 480
21.8 大话南游记 481
结束语 484
参考文献 486
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>品悟性能优化
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算与SOA
第1章 大势所趋        1
1.1 事情因何而失控        2
1.2 SOA来拯救        3
1.3 SOA究竟是什么？关我何事        4
1.4 SOA遇见云计算        6
1.5 定义云计算        7
1.6 云计算的组件        9
1.7 云计算与SOA的梦幻组合        11
1.8 SOA可从云计算中学到什么        13
1.8.1 服务设计        13
1.8.2 服务的可扩充性        13
1.9 云计算可从SOA中学到什么        14
1.9.1 服务治理        14
1.9.2 由架构驱动        14
1.10 跨入云计算世界        14
1.11 立足于积极的颠覆性变化        15
第2章 理解云计算        17
2.1 深入理解云计算        18
2.2 云计算有何新意        20
2.3 云的潜在价值        23
2.4 云计算的优缺点        23
2.4.1 优点        23
2.4.2 缺点        25
2.5 何时适合使用云计算        27
2.6 做点与众不同的事        29
第3章 面向企业的云        31
3.1 存储即服务        33
3.2 数据库即服务        34
3.3 信息即服务        36
3.4 流程即服务        41
3.5 应用即服务        43
3.6 平台即服务        45
3.7 集成即服务        46
3.8 安全即服务        47
3.9 管理/治理即服务        48
3.10 测试即服务        48
3.11 基础设施即服务        49
3.12 下一步        49
第4章 云计算的商业案例        51
4.1 定义整体价值        52
4.1.1 运维成本的降低        52
4.1.2 节约资本        56
4.1.3 随需扩容        57
4.1.4 随需收缩        58
4.1.5 风险转移        58
4.1.6 被提供商抛弃的风险        60
4.1.7 敏捷和重用        60
4.1.8 “酷”技术的价值        62
4.1.9 设计商业案例        63
4.2 一切都是商业        67
第5章 云计算与数据        69
5.1 旧还是新        70
5.2 数据为要        71
5.3 选择问题域        73
5.4 定义信息模型        74
5.4.1 理解本体        75
5.4.2 理解数据        77
5.4.3 标识数据        79
5.4.4 数据目录        85
5.5 创建信息模型        87
5.5.1 逻辑模型        87
5.5.2 物理模型        88
5.6 数据在融合云计算的SOA架构中的重要性        89
第6章 云计算与服务        91
6.1 服务包含可移动部分        95
6.2 服务是什么        99
6.3 理解云的耦合性        100
6.4 你的架构是松耦合的吗        102
6.5 定义元服务        103
6.6 创建服务目录        104
6.7 从服务级认识问题域的必要性        107
第7章 云计算与流程        109
7.1 何为BPM        110
7.2 将流程移入云        112
7.3 定义流程        114
7.4 SOA、敏捷及流程        117
7.5 BPM对于云的价值        119
7.6 深入探讨BPM        121
7.7 BPM和云计算        122
第8章 可控的云计算        123
8.1 人员与流程        125
8.2 云中的治理        126
8.3 建立治理模型        130
8.3.1 定义策略        130
8.3.2 设计策略        131
8.3.3 实现策略        132
8.4 治理技术        134
8.5 服务治理的价值        136
第9章 SOA与云计算        137
9.1 为何我们需要尝试新的测试        138
9.2 从企业到云平台的测试和反向测试        139
9.2.1 如何测试整个架构        139
9.2.2 服务层测试        141
9.2.3 安全层测试        144
9.2.4 流程层测试        144
9.2.5 治理层测试        144
9.2.6 集成层测试        144
9.2.7 信息层测试        145
9.3 制定测试计划        146
9.4 黑盒云测试        147
9.5 测试相当重要        149
第10章 在云平台中定义候选数据、服务和流程        151
10.1 应用程序在哪里        152
10.2 云计算何时适用        156
10.2.1 数据、服务、流程和应用非常独立（或松耦合）的场合        157
10.2.2 集成点定义良好的场景        158
10.2.3 较低级别的安全就已足够的场景        158
10.2.4 核心的内部企业架构非常健壮的场合        159
10.2.5 期望的用户接口是浏览器的情况        159
10.2.6 资金紧缺时        162
10.3 应用程序和服务较新时        163
10.4 迈向云计算        164
第11章 迈向云计算        165
11.1 选择平台        166
11.2 向云计算迁移之过程        171
11.2.1 列出候选平台        172
11.2.2 分析及测试候选平台        176
11.2.3 选择目标平台        177
11.2.4 部署至目标平台        178
11.3 何为私有云        180
11.4 新“云化”平台        181
第12章 拥抱未来        183
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算与SOA
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java RESTful Web Service实战
第一篇　够用就好--JAX-RS 2.0 基础
第1 章　JAX-RS 2.0 入门
1.1　解读REST
1.1.1　一种架构风格
1.1.2　基本实现形式
1.2　解读REST 服务
1.3　解读JAX-RS
1.4　Jersey 项目概要
1.5　Java 领域的其他REST 实现
1.5.1　其他JAX-RS 实现
1.5.2　其他REST 实现
1.6　本章小结
第2 章　JAX-RS 2.0 快速实现
2.1　第一个Java REST 服务
2.1.1　环境准备
2.1.2　创建服务
2.1.3　扩展服务
2.1.4　测试和运行服务
2.2　第一个Servlet 容器服务
2.2.1　创建和分析Web 服务
2.2.2　Jetty 插件与REST 服务
2.2.3　运行在Servlet 容器
2.2.4　运行在Java EE 容器
2.3　REST 服务类型
2.4　REST 应用描述
2.4.1　应用的描述
2.4.2　资源的描述
2.4.3　WADL 的配置
2.5　第一个完整的REST 服务
2.5.1　定义资源
2.5.2　集成Spring
2.5.3　集成JPA
2.5.4　集成jQuery
2.5.5　请求处理流程分析
2.6　REST 调试工具
2.6.1　命令行调试工具cURL
2.6.2　基于浏览器的图形化调试插件
2.7　本章小结
第3 章　REST API 设计
3.1　REST 统一接口
3.1.1　GET 方法
3.1.2　PUT 方法
3.1.3　DELETE 方法
3.1.4　POST 方法
3.1.5　WebDAV 扩展方法
3.2　REST 资源定位
3.2.1　资源地址设计
3.2.2　@QueryParam 注解
3.2.3　@PathParam 注解
3.2.4　@FormParam 注解
3.2.5　@BeanParam 注解
3.2.6　@CookieParam 注解
3.2.7　@Context 注解
3.3　REST 传输格式
3.3.1　基本类型
3.3.2　文件类型
3.3.3　InputStream 类型
3.3.4　Reader 类型
3.3.5　XML 类型
3.3.6　JSON 类型
3.4　REST 连通性
3.4.1　过渡型链接
3.4.2　结构型链接
3.5　REST 响应处理
3.5.1　返回类型
3.5.2　处理异常
3.6　REST 内容协商
3.6.1 @Produces 注解
3.6.2 @Consumes 注解
3.7　本章小结
第4 章　REST 请求处理
4.1　REST 和AOP
4.2　Providers 详解
4.2.1　实体Providers
4.2.2　上下文Providers
4.3　REST 请求流程
4.4　REST 过滤器
4.4.1　ClientRequestFilter
4.4.2　ContainerRequestFilter
4.4.3　ContainerResponseFilter
4.4.4　ClientResponseFilter
4.4.5　访问日志
4.5　REST 拦截器
4.6　绑定机制
4.7　优先级
4.8　本章小结
第5 章　REST 客户端
5.1　客户端接口
5.1.1　Client 接口
5.1.2　WebTarget 接口
5.1.3　Invocation 接口
5.2　资源释放
5.3　连接器
5.4　封装Client
5.5　本章小结
第二篇　全面掌握--JAX-RS 2.0 进阶
第6 章　REST 安全
6.1　身份认证
6.1.1　基本认证
6.1.2　摘要认证
6.1.3　表单认证
6.1.4　证书认证
6.2　资源授权
6.2.1　容器管理权限
6.2.2　应用管理权限
6.3　认证与授权实现
6.3.1　基本认证与JDBCRealm
6.3.2　摘要认证与UserDatabase-Realm
6.3.3　表单认证与DataSource-Realm
6.3.4　表单认证与JAASRealm
6.3.5　证书认证与UserDatabase-Realm
6.4　JAX-RS 2.0 实现
6.5　其他安全考虑
6.6　本章小结
第7 章　REST 测试
7.1　Jersey 测试框架
7.2　单元测试
7.2.1　集成Spring 的单元测试
7.2.2　异步测试
7.3　集成测试
7.4　日志增强
7.5　本章小结
第8 章　REST 推送与异步通信
8.1　服务器-浏览器通信
8.1.1　Polling 技术
8.1.2　Comet 技术
8.1.3　SSE 技术
8.1.4　WebSocket 技术
8.2　SSE 详述
8.2.1　Java 并发
8.2.2　SSE 流程
8.2.3　SSE 实现
8.3　异步通信
8.4　JAX-RS 2.0 实现异步通信
8.4.1　服务端实现
8.4.2　客户端实现和测试
8.5　本章小结
第9 章　Jersey 1.x 迁移
9.1　变更Maven 依赖定义
9.2　客户端迁移
9.2.1　Client 接口迁移
9.2.2　WebTarget 接口迁移
9.2.3　QueryParam
9.3　服务器端迁移
9.4　本章小结
第10 章　JAX-RS 调优
10.1　使用缓存优化负载
10.1.1　缓存协商
10.1.2　条件GET
10.1.3　REST 缓存实践
10.1.4　ab 测试
10.2　使用版本号优化服务
10.2.1　何时使用版本号
10.2.2　如何使用版本号
10.3　使用参数配置优化服务
10.3.1　通用配置
10.3.2　服务器端配置
10.3.3　客户端配置
10.4　Java 虚拟机调优
10.4.1　虚拟机概述
10.4.2　内存溢出与内存泄漏
10.5　本章小结
第三篇　实践分享--JAX-RS 2.0 综合
第11 章　统一自动化测试平台
11.1　ATUP 的定义
11.1.1　需求仓库
11.1.2　需求分析
11.1.3　迭代规划
11.2　ATUP 的设计
11.2.1　开发和部署环境
11.2.2　模块定义和拓扑
11.2.3　持续集成流程
11.3　ATUP 的实现
11.3.1　Sprint1 核心功能
11.3.2　Sprint2 模块功能
11.3.3　Iteration1 的演示和回顾
11.3.4　Sprint3 持续交付
11.3.5　交付和总结
11.4　本章小结
附录　Web 简史
参考资料
后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java RESTful Web Service实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux 0.01内核分析与操作系统设计
第一章 GNU和LINUX简介
第二章 操作系统设计入门
第三章 操作系统设计基础
第四章 LINUX 0.01内核简介
第五章 操作系统引导
第六章 存储管理分析
第七章 进程管理和调度
第八章 设备管理和调度
第九章 磁盘文件系统
第十章 SHELL编程技术和实例
第十一章 系统调用和C语言库的实现
第十二章 LINUX网络实现分析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux 0.01内核分析与操作系统设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>图解基础设施设计模式
第1章 什么是基础设施设计模式
1.1 什么是基础设施
1.2 基础设施故障引发的后果
1.3 基础设施构建中哪个阶段最重要
1.4 需求定义的重要性与难点
1.5 非功能性需求等级 克服非功能性需求定义困难 的工具
1.6 基础设施设计模式 研究能够满足需求的设计方式的工具
1.7 本书的内容安排
第2章 可用性需求的实现策略 防止 系统宕机
2.1 可用性策略的基础
2.2 Web/AP服务器的高可用性设计方式
2.3 DB服务器的可用性设计方式
2.4 虚拟服务器冗余的设计方式
2.5 LAN的可用性设计方式
2.6 WAN的可用性设计方式
2.7 互联网连接的设计方式
2.8 数据备份的可用性设计方式
2.9 灾害应对策略的设计方式
2.10 总结
第3章 安全性需求的实现策略 保护系统不受威胁
3.1 安全性策略的基础
3.2 非法访问应对策略的设计方式
3.3 身份认证的设计方式
3.4 ID管理和维护的设计方式
3.5 信息泄露应对策略的设计方式
3.6 总结
第4章 性能与可扩展性需求的实现策略 防止 系统性能下降
4.1 性能与可扩展性策略的基础
4.2 可扩展性策略的设计方式
4.3 超负荷应对策略的设计方式
4.4 总结
第5章 运用与维护性需求的实现策略不放过系统故障
5.1 运用与维护性策略的基础
5.2 运用与维护体制的设计方式
5.3 构成管理的设计方式
5.4 系统监控的设计方式
5.5 任务管理的设计方式
5.6 时钟同步、杀毒软件更新的设计方式
5.7 总结
第6章 基础设施构成的设计方式
6.1 Web系统的网络构成的设计方式
6.2 存储设备构成的设计方式
6.3 报表生成的设计方式
6.4 报表输出的设计方式
6.5 报表基础设施配置的设计方式
6.6 数据使用和信息分析的设计方式
6.7 基础设施交互结构的设计方式
6.8 总结
第7章 使用云计算服务的实现策略
7.1 云服务中性能与可扩展性的设计方式
7.2 云服务中备份的可用性设计方式
7.3 云服务中虚拟服务器的可用性设计方式
7.4 总结
第8 章 基于模式的设计实践
8.1 基础设施构成的讨论步骤
8.2 地理信息系统
8.3 综合 DB系统
8.4 总结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>图解基础设施设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式解析
第一部分　面向对象软件开发简介
第1章　面向对象范型	2
1.1 概览	2
1.2 面向对象范型之前：功能分解	2
1.3 需求问题	4
1.4 应对变化：使用功能分解	5
1.5 应对需求变更	7
1.6 面向对象范型	10
1.7 面向对象程序设计实践	15
1.8 特殊对象方法	17
1.9 小结	18
复习题	19
简答题	19
阐述题	20
观点与应用题	20
第2章　UML	21
2.1 概览	21
2.2 什么是UML	21
2.3 为什么使用UML	22
2.4 类图	22
2.5 交互图	28
2.6 小结	30
复习题	30
简答题	30
阐述题	30
观点与应用题	30
第二部分 传统面向对象设计的局限
第3章　对代码灵活性要求很高的问题	33
3.1 概览	33
3.2 提取CAD/CAM系统的信息	33
3.3 了解专业术语	34
3.4 问题描述	35
3.5 挑战及其解决方案	37
3.6 小结	39
复习题	40
简答题	40
阐述题	40
观点与应用题	40
第4章　标准的面向对象解决方案	41
4.1 概览	41
4.2 作为特例来解决	41
4.3 小结	48
复习题	48
简答题	48
阐述题	49
观点与应用题	49
第三部分 设 计 模 式
第5章　设计模式简介	53
5.1 概览	53
5.2 设计模式源自建筑学和人类学	53
5.3 从建筑模式到软件设计模式	57
5.4 为什么学习设计模式	58
5.5 学习设计模式的其他好处	62
5.6 小结	63
复习题	63
简答题	63
阐述题	64
观点与应用题	64
第6章　Facade模式	65
6.1 概览	65
6.2 Facade模式简介	65
6.3 学习Facade模式	65
6.4 实践注记：Facade模式	68
6.5 Facade模式与CAD／CAM问题的联系	69
6.6 小结	70
复习题	70
简答题	70
阐述题	70
观点与应用题	71
第7章　Adapter模式	72
7.1 概览	72
7.2 Adapter模式简介	72
7.3 学习Adapter模式	73
7.4 实践注记：Adapter模式	77
7.5 Adapter模式与CAD/CAM问题的联系	80
7.6 小结	80
复习题	80
简答题	80
阐述题	81
观点与应用题	81
第8章　开拓视野	82
8.1 概览	82
8.2 对象：传统看法与新看法	83
8.3 封装：传统看法与新看法	84
8.4 发现变化并将其封装	87
8.5 共性和可变性分析与抽象类	90
8.6 敏捷编程的品质	92
8.7 小结	95
复习题	96
简答题	96
阐述题	96
观点与应用题	97
第9章　Strategy模式	98
9.1 概览	98
9.2 处理新需求的一种途径	98
9.3 国际电子商务系统案例研究：最初的需求	100
9.4 处理新的需求	101
9.5 Strategy模式	108
9.6 实践注记：使用Strategy模式	110
9.7 小结	111
复习题	111
简答题	111
阐述题	112
观点与应用题	112
第10章　Bridge模式	113
10.1 概览	113
10.2 Bridge模式简介	113
10.3 学习Bridge模式：示例	114
10.4 对使用设计模式的观察	123
10.5 学习Bridge模式：通过将它推演出来	124
10.6 Bridge模式回顾	131
10.7 实践注记：使用Bridge模式	132
10.8 小结	135
复习题	137
简答题	137
阐述题	137
观点与应用题	137
第11章　Abstract Factory模式	138
11.1 概览	138
11.2 Abstract Factory模式简介	138
11.3 学习Abstract Factory模式：示例	138
11.4 学习Abstract Factory模式：实现该模式	144
11.5 实践注记：Abstract Factory模式	149
11.6 将Abstract Factory模式与CAD/CAM问题联系起来	151
11.7 小结	151
复习题	152
简答题	152
阐述题	152
观点与应用题	152
第四部分 组合起来：用模式思考
第12章　专家设计之道	154
12.1 概览	154
12.2 添加特征的创建方式	154
12.3 小结	160
复习题	160
简答题	160
阐述题	161
观点与应用题	161
第13章　用模式解决CAD/CAM问题	162
13.1 概览	162
13.2 对CAD/CAM问题的回顾	162
13.3 用模式思考	163
13.4 用模式思考：步骤1	164
13.5 用模式思考：步骤2a	165
13.6 用模式思考：步骤2b	169
13.7 用模式思考：步骤2c	172
13.8 用模式思考：重复步骤2a和步骤2b（Facade模式）	173
13.9 用模式思考：重复步骤2a和步骤2b（Adapter模式）	174
13.10 用模式思考：重复步骤2a和步骤2b（Abstract Factory模式）	174
13.11 用模式思考：步骤3	175
13.12 与原解决方案的比较	175
13.13 小结	176
复习题	177
简答题	177
阐述题	177
观点与应用题	177
第五部分 迈向新的设计方式
第14章　设计模式的原则与策略	180
14.1 概览	180
14.2 开闭原则	181
14.3 从背景设计原则	181
14.4 封装变化原则	185
14.5 抽象类与接口	186
14.6 理性怀疑原则	187
14.7 小结	187
复习题	188
简答题	188
阐述题	188
观点与应用题	188
第15章　共性与可变性分析	189
15.1 概览	189
15.2 共性和可变性分析与应用程序设计	189
15.3 用CVA解决CAD/CAM问题	190
15.4 小结	194
复习题	194
简答题	194
阐述题	194
观点与应用题	195
第16章　分析矩阵	196
16.1 概览	196
16.2 现实世界：充满变化	196
16.3 国际电子商务系统案例研究：应对变化	197
16.4 实践注记	203
16.5 小结	206
复习题	206
简答题	206
阐述题	206
观点与应用题	206
第17章　Decorator模式	207
17.1 概览	207
17.2 更多细节	207
17.3 Decorator模式	209
17.4 将Decorator模式应用到我们的案例研究	210
17.5 另一个例子：输入/输出	213
17.6 实践注记：使用Decorator模式	215
17.7 Decorator模式的本质	216
17.8 小结	217
复习题	217
简答题	217
阐述题	217
观点与应用题	217
第六部分 其他重要模式
第18章　Observer模式	220
18.1 概览	220
18.2 模式的分类	220
18.3 国际电子商务案例的更多需求	221
18.4 Observer模式	222
18.5 将Observer模式应用到我们的案例研究	223
18.6 实践注记：使用Observer模式	227
18.7 小结	229
复习题	229
简答题	229
阐述题	230
观点与应用题	230
第19章　Template Method模式	231
19.1 概览	231
19.2 案例研究的更多需求	231
19.3 Template Method模式	232
19.4 将Template Method模式应用到我们的案例研究	232
19.5 使用Template Method模式减少冗余	233
19.6 实践注记：使用Template Method模式	238
19.7 小结	239
复习题	240
简答题	240
阐述题	240
第七部分 各种工厂模式
第20章　来自设计模式的教益：各种工厂模式	242
20.1 概览	242
20.2 工厂	242
20.3 再谈背景	243
20.4 工厂遵循我们的准则	245
20.5 限制变化的影响	246
20.6 对工厂的另一种思考方式	246
20.7 工厂的不同角色	247
20.8 实践注记	247
20.9 小结	248
复习题	248
简答题	248
阐述题	248
观点与应用题	248
第21章　Singleton模式和Double-Checked Locking模式	249
21.1 概览	249
21.2 Singleton模式简介	249
21.3 将Singleton模式应用到我们的案例研究	250
21.4 一种变体：Double-Checked Locking模式	252
21.5 反思	255
21.6 实践注记：使用Singleton模式和Double-Checked Locking模式	255
21.7 小结	256
复习题	256
简答题	256
阐述题	256
观点与应用题	256
第22章　Object Pool模式	257
22.1 概览	257
22.2 一个需要对对象进行管理的问题	257
22.3 Object Pool模式	263
22.4 观察：工厂的作用不仅是实例化	263
22.5 小结	265
复习题	265
简答题	265
阐述题	266
观点与应用题	266
第23章　Factory Method模式	267
23.1 概览	267
23.2 案例研究的更多需求	267
23.3 Factory Method模式	268
23.4 Factory Method模式与面向对象语言	268
23.5 实践注记：使用Factory Method模式	269
23.6 小结	270
复习题	271
简答题	271
阐述题	271
观点与应用题	271
第24章　工厂模式的总结	272
24.1 概览	272
24.2 软件开发过程中的步骤	272
24.3 工厂与极限编程实践殊途同归	273
24.4 系统的扩展性	273
第八部分 终点与起点
第25章　设计模式回顾：总结与新起点	276
25.1 概览	276
25.2 面向对象原则的总结	276
25.3 设计模式如何封装实现	277
25.4 共性和可变性分析与设计模式	277
25.5 按责任分解问题域	278
25.6 模式和从背景设计	279
25.7 模式内部的关联	279
25.8 设计模式与敏捷编程实践	281
25.9 实践注记	281
25.10 小结	281
复习题	282
简答题	282
阐述题	282
观点与应用题	282
第26章　参考书目	283
26.1 本书配套网站	283
26.2 推荐阅读	284
26.3 针对Java程序员的推荐读物	285
26.4 针对C++程序员的推荐读物	286
26.5 针对COBOL程序员的推荐读物	287
26.6 极限编程的推荐读物	287
26.7 程序设计的一般性推荐读物	287
26.8 个人推荐	288
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式解析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件设计重构
第1章　技术债务　　1
1.1　何为技术债务　　2
1.2　技术债务的组成部分　　2
1.3　技术债务的影响　　3
1.4　引发技术债务的因素　　5
1.5　如何管理技术债务　　6
第2章　设计坏味　　7
2.1　为何要关心坏味　　8
2.2　导致坏味的原因　　9
2.2.1　违反设计原则　　10
2.2.2　不恰当地使用模式　　10
2.2.3　语言的局限性　　11
2.2.4　面向对象中的过程型思维　　11
2.2.5　粘滞性　　11
2.2.6　未遵循最佳实践和过程　　12
2.3　如何消除坏味　　12
2.4　本书涵盖的坏味　　12
2.5　一种设计坏味分类方案　　13
2.5.1　基于设计原则的坏味分类　　13
2.5.2　坏味命名方案　　14
2.5.3　坏味记录模板　　15
第3章　抽象型坏味　　16
3.1　缺失抽象　　19
3.1.1　理据　　19
3.1.2　潜在的原因　　19
3.1.3　示例　　20
3.1.4　重构建议　　21
3.1.5　影响的质量指标　　22
3.1.6　别名　　22
3.1.7　现实考虑　　23
3.2　命令式抽象　　23
3.2.1　理据　　23
3.2.2　潜在的原因　　23
3.2.3　示例　　24
3.2.4　重构建议　　25
3.2.5　影响的质量指标　　26
3.2.6　别名　　28
3.2.7　现实考虑　　28
3.3　不完整的抽象　　28
3.3.1　理据　　28
3.3.2　潜在的原因　　29
3.3.3　示例　　29
3.3.4　重构建议　　31
3.3.5　影响的质量指标　　32
3.3.6　别名　　33
3.3.7　现实考虑　　33
3.4　多方面抽象　　34
3.4.1　理据　　34
3.4.2　潜在的原因　　34
3.4.3　示例　　35
3.4.4　重构建议　　36
3.4.5　影响的质量指标　　37
3.4.6　别名　　37
3.4.7　现实考虑　　37
3.5　不必要的抽象　　37
3.5.1　理据　　38
3.5.2　潜在的原因　　38
3.5.3　示例　　38
3.5.4　重构建议　　40
3.5.5　影响的质量指标　　41
3.5.6　别名　　41
3.5.7　现实考虑　　41
3.6　未用的抽象　　42
3.6.1　理据　　42
3.6.2　潜在的原因　　42
3.6.3　示例　　43
3.6.4　重构建议　　44
3.6.5　影响的质量指标　　45
3.6.6　别名　　46
3.6.7　现实考虑　　46
3.7　重复的抽象　　46
3.7.1　理据　　47
3.7.2　潜在的原因　　47
3.7.3　示例　　48
3.7.4　重构建议　　50
3.7.5　影响的质量指标　　51
3.7.6　别名　　51
3.7.7　现实考虑　　52
第4章　封装型坏味　　53
4.1　不充分的封装　　55
4.1.1　理据　　55
4.1.2　潜在的原因　　55
4.1.3　示例　　56
4.1.4　重构建议　　60
4.1.5　影响的质量指标　　62
4.1.6　别名　　62
4.1.7　现实考虑　　62
4.2　泄露的封装　　63
4.2.1　理据　　63
4.2.2　潜在的原因　　64
4.2.3　示例　　64
4.2.4　重构建议　　67
4.2.5　影响的质量指标　　69
4.2.6　别名　　69
4.2.7　现实考虑　　69
4.3　缺失封装　　70
4.3.1　理据　　70
4.3.2　潜在的原因　　71
4.3.3　示例　　71
4.3.4　重构建议　　73
4.3.5　影响的质量指标　　76
4.3.6　别名　　77
4.3.7　现实考虑　　77
4.4　未利用封装　　77
4.4.1　理据　　77
4.4.2　潜在的原因　　78
4.4.3　示例　　78
4.4.4　重构建议　　80
4.4.5　影响的质量指标　　80
4.4.6　别名　　82
4.4.7　现实考虑　　82
第5章　模块化型坏味　　83
5.1　拆散的模块化　　85
5.1.1　理据　　86
5.1.2　潜在的原因　　86
5.1.3　示例　　86
5.1.4　重构建议　　88
5.1.5　影响的质量指标　　90
5.1.6　别名　　90
5.1.7　现实考虑　　91
5.2　不充分的模块化　　91
5.2.1　理据　　91
5.2.2　潜在的原因　　92
5.2.3　示例　　92
5.2.4　重构建议　　95
5.2.5　影响的质量指标　　96
5.2.6　别名　　96
5.2.7　现实考虑　　96
5.3　循环依赖式模块化　　97
5.3.1　理据　　97
5.3.2　潜在的原因　　98
5.3.3　示例　　99
5.3.4　重构建议　　101
5.3.5　影响的质量指标　　105
5.3.6　别名　　106
5.3.7　现实考虑　　106
5.4　轮毂式模块化　　107
5.4.1　理据　　107
5.4.2　潜在的原因　　107
5.4.3　示例　　107
5.4.4　重构建议　　109
5.4.5　影响的质量指标　　110
5.4.6　别名　　110
5.4.7　现实考虑　　110
第6章　层次结构型坏味　　111
6.1　缺失层次结构　　115
6.1.1　理据　　115
6.1.2　潜在的原因　　115
6.1.3　示例　　115
6.1.4　重构建议　　117
6.1.5　影响的质量指标　　119
6.1.6　别名　　120
6.1.7　现实考虑　　120
6.2　不必要的层次结构　　121
6.2.1　理据　　121
6.2.2　潜在的原因　　121
6.2.3　示例　　122
6.2.4　重构建议　　125
6.2.5　影响的质量指标　　126
6.2.6　别名　　126
6.2.7　现实考虑　　127
6.3　未归并的层次结构　　127
6.3.1　理据　　127
6.3.2　潜在的原因　　128
6.3.3　示例　　128
6.3.4　重构建议　　132
6.3.5　影响的质量指标　　134
6.3.6　别名　　135
6.3.7　现实考虑　　135
6.4　过宽的层次结构　　136
6.4.1　理据　　136
6.4.2　潜在的原因　　137
6.4.3　示例　　137
6.4.4　重构建议　　138
6.4.5　影响的质量指标　　139
6.4.6　别名　　139
6.4.7　现实考虑　　140
6.5　凭空想象的层次结构　　140
6.5.1　理据　　140
6.5.2　潜在的原因　　140
6.5.3　示例　　141
6.5.4　重构建议　　141
6.5.5　影响的质量指标　　142
6.5.6　别名　　142
6.5.7　现实考虑　　143
6.6　过深的层次结构　　143
6.6.1　理据　　143
6.6.2　潜在的原因　　143
6.6.3　示例　　144
6.6.4　重构建议　　145
6.6.5　影响的质量指标　　146
6.6.6　别名　　147
6.6.7　现实考虑　　148
6.7　叛逆型层次结构　　148
6.7.1　理据　　148
6.7.2　潜在的原因　　148
6.7.3　示例　　149
6.7.4　重构建议　　150
6.7.5　影响的质量指标　　153
6.7.6　别名　　154
6.7.7　现实考虑　　154
6.8　支离破碎的层次结构　　157
6.8.1　理据　　158
6.8.2　潜在的原因　　158
6.8.3　示例　　158
6.8.4　重构建议　　163
6.8.5　影响的质量指标　　164
6.8.6　别名　　164
6.8.7　现实考虑　　165
6.9　多路径层次结构　　166
6.9.1　理据　　166
6.9.2　潜在的原因　　167
6.9.3　示例　　167
6.9.4　重构建议　　170
6.9.5　影响的质量指标　　171
6.9.6　别名　　171
6.9.7　现实考虑　　171
6.10　循环层次结构　　172
6.10.1　理据　　172
6.10.2　潜在的原因　　173
6.10.3　示例　　173
6.10.4　重构建议　　173
6.10.5　影响的质量指标　　175
6.10.6　别名　　176
6.10.7　现实考虑　　176
第7章　坏味生态系统　　177
7.1　具体情况的影响　　177
7.2　坏味的相互影响　　180
7.2.1　坏味通常不单独出现　　180
7.2.2　坏味可能昭示着存在更深层的问题　　183
第8章　技术债务偿还实战　　185
8.1　工具　　185
8.1.1　理解工具　　186
8.1.2　评估工具、代码克隆检测器和度量工具　　186
8.1.3　技术债务量化和可视化工具　　187
8.1.4　重构工具　　187
8.1.5　实际使用工具　　187
8.2　流程　　188
8.2.1　重构面临的挑战　　188
8.2.2　让人认可重构　　188
8.2.3　IMPACT——一个重构流程模型　　189
8.2.4　技术债务偿还重构最佳实践　　192
8.3　人员　　193
8.3.1　培训　　193
8.3.2　研讨会和讲座　　193
8.3.3　以身作则　　193
附录A　软件设计原则　　194
附录B　技术债务偿还工具　　197
附录C　示意图使用的表示法　　200
附录D　推荐读物　　202
参考文献　　204

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件设计重构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>服务设计模式
译者序
Martin Fowler所作的序
Ian Robinson所作的序
前言
致谢
第1章　从对象到Web服务
1.1　Web服务是什么
1.2　从本地对象到分布式对象
1.3　为什么使用Web服务
1.4　Web服务的考虑因素和替代方案
1.5　服务和松散耦合的承诺
1.6　SOA是什么
1.7　总结
第2章　Web服务API风格
2.1　引言
2.2　设计Web服务API的考虑因素
2.3　RPC API
2.4　消息API
2.5　资源API
第3章　客户端与服务之间的交互
3.1　引言
3.2　请求/响应模式
3.3　请求/确认模式
3.4　媒体类型协商模式
3.5　链接服务
第4章　请求和响应管理
4.1　引言
4.2　服务控制器
4.3　数据传输对象
4.3.1　数据绑定考虑因素
4.3.2　总体考虑因素
4.4　请求映射器
4.5　响应映射器
第5章　Web服务实现风格
5.1　引言
5.2　Web服务实现的设计考虑因素
5.3　事务脚本
5.4　数据源适配器
5.5　操作脚本
5.6　命令调用器
5.7　工作流连接器
第6章　Web服务基础结构
6.1　引言
6.2　服务连接器
6.3　服务描述符
6.4　异步响应处理器
6.5　服务拦截器
6.6　幂等重试
6.7　SOA基础结构模式简述
6.7.1　服务注册表
6.7.2　企业服务总线
6.7.3　编排引擎
第7章　Web服务的演化
7.1　导言
7.2　导致破坏性变化的因素
7.2.1　对媒体类型或者消息的结构性修改
7.2.2　服务描述符变化
7.3　常见版本控制策略
7.4　单消息参数
7.5　数据集修改
7.6　宽容阅读器
7.7　消费者驱动契约
7.8　模式对服务演化的促进或者妨碍
附录　对外部模式的引用
词汇表
参考书目
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>服务设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>mysql管理之道：性能调优、高可用与监控
前言
第一部分　mysql5.5 新特性篇
第1章　mysql5.5介绍 2
1.1　性能上的显著改变 2
1.1.1　mysql5.5默认存储引擎的调整 2
1.1.2　充分利用cpu多核的处理能力 7
1.1.3　提高刷新脏页数量和合并插入数量，改善磁盘i/o处理能力 8
1.1.4　增加自适应刷新脏页功能 9
1.1.5　让innodb_buffer_pool缓冲池中的热数据存活更久 9
1.1.6　innodb的数据恢复时间加快 11
1.1.7　innodb同时支持多个bufferpool实例 15
1.1.8　可关闭自适应哈希索引 17
1.1.9　在innodb中可选择使用内存分配程序 18
1.1.10　提高默认innodb线程并发数 21
1.1.11　预读算法的变化 22
1.1.12　首次在linux上实现了异步i/o 23
1.1.13　恢复组提交 24
1.1.14　innodb使用多个回滚段提升性能 26
1.1.15　改善清除程序进度 26
.1.1.16　添加删除缓冲和清除缓冲 27
1.1.17　控制自旋锁spin lock轮训间隔 28
1.1.18　快速创建、删除、更改索引 29
1.1.19　innodb支持创建压缩数据页 30
1.1.20　可动态关闭innodb更新元数据的统计功能 37
1.2　安全性、稳定性的显著改变 38
1.2.1　复制功能加强 38
1.2.2　中继日志relay-log可自我修复 39
1.2.3　开启innodb严格检查模式 39
1.3　动态更改系统配置参数 39
1.3.1　支持动态更改独立表空间 39
1.3.2　支持动态更改innodb锁超时时间 40
1.4　innodb新参数汇总 40
1.5　同步复制新参数汇总 48
1.6　sql语句写法的改变 53
1.6.1　delete表连接语法改变 53
1.6.2　mysql5.5存储过程支持limit变量 54
1.7　mysql5.1升级为mysql5.5 55
1.7.1　采用mysql_upgrade升级授权表方式升级 55
1.7.2　直接安装mysql5.5，采用数据导出/导入方式升级 59
1.8　性能测试：mysql5.5与mysql5.1 60
第2章　半同步复制 62
2.1　半同步复制简介 62
2.2　半同步复制安装配置 63
2.3　参数说明 63
2.4　功能测试 64
2.4.1　如何验证半同步复制是否正常工作 64
2.4.2　半同步复制与异步复制的切换 65
2.5　性能测试 68
2.6　小结 70
第二部分　故障诊断与性能优化篇
第3章　故障诊断 72
3.1　影响mysql性能的因素 72
3.2　系统性能评估标准 73
3.2.1　影响linux服务器性能的因素 73
3.2.2　系统性能评估指标 74
3.2.3　开源监控和评估工具介绍 76
3.3　故障与处理 79
3.3.1　连接数过多导致程序连接报错的原因 79
3.3.2　记录子查询引起的宕机 84
3.3.3　诊断事务量突高的原因 87
3.3.4　谨慎设置binlog_format=mixed 90
3.3.5　未设置swap分区导致内存耗尽，主机死机 94
3.3.6　mysql故障切换之事件调度器注意事项 95
3.3.7　人工误删除innodb ibdata数据文件，如何恢复 97
3.3.8　update忘加where条件误操作恢复（模拟oracle闪回功能） 99
3.3.9　delete忘加where条件误操作恢复（模拟oracle闪回功能） 108
第4章　同步复制报错故障处理 112
4.1　最常见的3种故障 112
4.1.1　在master上删除一条记录时出现的故障 112
4.1.2　主键重复 114
4.1.3　在master上更新一条记录，而slave上却找不到 115
4.2　特殊情况：slave的中继日志relay-log损坏 116
4.3　人为失误 118
4.4　避免在master上执行大事务 119
4.5　slave_exec_mode参数可自动处理同步复制错误 120
4.6　如何验证主从数据一致 121
4.7　binlog_ignore_db引起的同步复制故障 123
4.8　mysql5.5.19/20同步一个bug 124
4.9　恢复slave从机上的某几张表的简要方法　 126
4.10　如何干净地清除slave同步信息 127
第5章　性能调优 129
5.1　表设计 129
5.2　字段类型的选取 133
5.2.1　数值类型 134
5.2.2　字符类型 139
5.2.3　时间类型 141
5.2.4　小技巧：快速修改表结构 148
5.2.5　pt-online-schema-change在线更改表结构 152
5.2.6　mysql5.6在线ddl更改表测试 158
5.3　采用合适的锁机制 161
5.3.1　表锁的演示 161
5.3.2　行锁的演示 164
5.3.3　innodb引擎与myisam引擎的性能对比 166
5.4　选择合适的事务隔离级别 168
5.4.1　事务的概念 168
5.4.2　事务的实现 169
5.4.3　事务隔离级别介绍 171
5.5　sql优化与合理利用索引 177
5.5.1　如何定位执行很慢的sql语句 177
5.5.2　sql优化案例分析 178
5.5.3　合理使用索引 188
5.6　my.cnf配置文件调优 198
5.6.1　per_thread_buffers优化 198
5.6.2　global_buffers优化 200
5.6.3　query cache在不同环境下的使用 201
5.6.4　tuning-primer.sh性能调试工具的使用 205
5.6.5　72 gb内存的my.cnf配置文件 208
5.6.6　谨慎使用分区表功能 211
5.7　mysql5.6同步复制新特性详解 213
第6章　备份与恢复 223
6.1　冷备份 224
6.2　逻辑备份 224
6.2.1　mysqldump增加了一个重要参数 225
6.2.2　取代mysqldump的新工具mydumper 226
6.2.3　逻辑备份全量、增量备份脚本 229
6.3　热备份与恢复 230
第三部分　高可用集群管理篇
第7章　目前流行的4种高可用架构 236
7.1　采用mysql自带的replication架构 237
7.1.1　keepalived+mysql replication架构的搭建演示 237
7.1.2　mmm+mysql replication架构的搭建演示 241
7.2　heartbeat+drbd+mysql架构的搭建演示 249
7.3　红帽rhcs共享存储架构的搭建演示 254
7.3.1　安装过程 257
7.3.2　红帽rhcs集群的维护 265
7.4　mysql高可用集群ha解决方案的测试评估 267
第8章　批量管理服务器 270
8.1　开源工具pssh的使用方法 270
8.2　自己编写的ssh服务器批量管理工具 273
第四部分　监控篇
第9章　性能监控 278
第10章　服务监控 283
10.1　nagios搭建与维护 283
10.2　mysql数据库的监控脚本 288
第五部分　项目案例
第11章　项目案例讲解 292
11.1　数据碎片整理方案 292
11.2　用户信息表水平拆表方案 296
11.3　阿里巴巴中间件cobar水平拆表方案 299
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>mysql管理之道：性能调优、高可用与监控
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>飞天开放平台编程指南
第1章 绪论	1
1.1 云计算的背景	1
1.1.1 云计算的概念	1
1.1.2 云计算的类型	3
1.1.3 业界主要的云计算提供商	4
1.2 阿里云的定位	5
1.3 云生态系统	6
1.4 内容总览	7
第2章 飞天开放平台总览	8
2.1 飞天平台体系架构	8
2.2 飞天平台内核	9
2.2.1 分布式系统底层服务	9
2.2.2 分布式文件系统（盘古）	11
2.2.3 资源管理和任务调度（伏羲）	13
2.2.4 集群监控和部署	14
2.3 飞天开放服务	16
2.3.1 弹性计算服务（ECS）	16
2.3.2 开放存储服务（OSS）	17
2.3.3 开放结构化数据服务（OTS）	17
2.3.4 关系型数据库服务（RDS）	18
2.3.5 开放数据处理服务（ODPS）	18
2.3.6 云服务引擎（ACE）	19
第3章 弹性计算服务ECS	20
3.1 术语及概念	21
3.2 云服务器使用流程	22
3.2.1 购买并创建云服务器	23
3.2.2 启动、停止和重启云服务器	23
3.2.3 重置云服务器	24
3.2.4 修改云服务器密码	24
3.2.5 远程登录云服务器	24
3.2.6 数据盘分区、格式化和挂载	26
3.3 利用API管理ECS	28
3.3.1 公共参数和返回结果	28
3.3.2 云服务器控制	30
3.3.3 镜像和快照	36
3.3.4 安全组	39
3.4 负载均衡（SLB）	41
3.5 云盾	42
3.6 云监控	43
3.7 自动故障恢复	43
3.8 应用架构修改	44
3.9 应用案例	44
第4章 开放存储服务OSS	46
4.1 术语及概念	46
4.1.1 Object	46
4.1.2 Bucket	47
4.1.3 访问控制	47
4.1.4 外链规则	48
4.1.5 Access ID和Access Key	48
4.1.6 使用OSS	49
4.2 RESTful API	50
4.2.1 Service操作	50
4.2.2 Bucket操作	50
4.2.3 Object操作	52
4.2.4 分块上传（Multipart Upload）操作	56
4.3 Python SDK的使用	59
4.3.1 Bucket操作	60
4.3.2 Object操作	68
4.3.3 分块上传（Multipart Upload）操作	76
4.3.4 签名URL	80
4.4 应用案例	81
第5章 开放结构化数据服务OTS	82
5.1 术语及概念	83
5.1.1 表	83
5.1.2 视图	84
5.1.3 表组	85
5.1.4 命名和限额	86
5.1.5 事务	86
5.1.6 访问权限控制	86
5.2 RESTful API	87
5.2.1 表操作	87
5.2.2 插入和修改操作	88
5.2.3 查询操作	88
5.2.4 事务操作	88
5.3 Python SDK的使用	89
5.3.1 表操作	91
5.3.2 插入和修改操作	96
5.3.3 查询数据	101
5.3.4 事务操作	104
5.4 应用案例	106
第6章 关系型数据库服务RDS	107
6.1 术语及概念	108
6.2 自动故障恢复	109
6.3 分布式RDS	110
6.4 利用客户端软件进行数据库管理	110
6.4.1 实例管理	111
6.4.2 数据库管理	112
6.4.3 连接数据库	112
6.4.4 表管理	113
6.4.5 备份恢复	114
6.4.6 数据迁移	114
6.4.7 性能分析	115
6.5 利用API进行数据库管理	115
6.5.1 公共参数和返回结果	116
6.5.2 API接口的使用	117
6.6 应用案例	127
第7章 开放数据处理服务ODPS	128
7.1 术语及概念	129
7.2 应用开发框架	130
7.2.1 体系架构	130
7.2.2 应用开发模式	131
7.3 ODPS SQL开发	132
7.3.1 应用示例描述	133
7.3.2 数据导入	134
7.3.3 基本功能	135
7.3.4 高级功能	136
7.4 ODPS MapReduce开发	140
7.4.1 入门实例WordCount	140
7.4.2 开发实战	155
7.5 应用案例	172
第8章 典型应用案例解析	173
8.1 传统互联网应用	173
8.1.1 中国网络电视台体育台	173
8.1.2 御泥坊	175
8.1.3 够快	175
8.2 移动互联网应用	176
8.2.1 DeNA	176
8.2.2 壹人壹本	176
8.2.3 金立	177
8.3 企业级SaaS应用	177
8.3.1 用友畅捷通	177
8.3.2 商派	178
8.4 新型互联网应用和服务	179
8.4.1 阿里云搜索	179
8.4.2 阿里金融	180
附录A 飞天开放服务开通流程	181
附录B RESTful API和身份验证	184
B.1 RESTful API	184
B.2 ECS身份认证	185
B.3 OSS身份认证	186
B.3.1 在Header中包含签名	186
B.3.2 在URL中包含签名	188
B.4 OTS身份认证	189
B.4.1 OTS请求的签名	189
B.4.2 OTS响应的签名	190
B.5 RDS身份认证	191
附录C 用OSS构建同步备份网盘	193
C.1 网盘功能、设计与使用	193
C.1.1 网盘功能：自动备份和同步多个设备	193
C.1.2 网盘设计	193
C.1.3 网盘安装和使用	194
C.2 源代码	195
C.2.1 netdisk.py	196
C.2.2 fs/filesystem.py	198
C.2.3 fs/hddfs.py	201
C.2.4 fs/ossfs.py	204
C.2.5 fs/couldnotconnectserverexception.py	207
C.2.6 eventhandlers/netdiskeventhandler.py	207
附录D 云应用引擎CAE编程	211
D.1 云应用开发入门	212
D.1.1 快速创建一个云应用	212
D.1.2 云应用文件结构	215
D.1.3 页面生命周期	215
D.1.4 新建页面	216
D.1.5 页面之间相互跳转	217
D.1.6 引入第三方类库	218
D.1.7 调用云端接口	219
D.1.8 调用CloudAPI	222
D.1.9 监听云应用的挂起和唤醒	223
D.1.10 请求和操作XML	224
D.1.11 在线调试	225
D.2 用户界面开发	227
D.2.1 滚动条	227
D.2.2 提示框	228
D.2.3 jQTouch	229
D.2.4 Sencha Touch	230
D.3 云应用开发实例	232
D.3.1 花名册程序	232
D.3.2 地图程序	237
D.4 设计指南与注意事项	239
D.4.1 云应用设计指南	239
D.4.2 设计中的注意事项	240
D.4.3 云应用审核指南	240
参考文献	241
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>飞天开放平台编程指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算的关键技术与应用实例
第1篇  从并行计算到云计算   第1章  并行计算与云计算  1.1  并行计算到云计算的演变  1.2  云计算需要定义吗？   1.3  云计算是否是新瓶装旧酒  1.4  MPI与Hadoop，不同学科学者的选择  1.5  云计算与浏览器  第2章  MPI并行计算环境的建立  2.1  配置前的准备工作   2.2  挂载NFS文件系统  2.3  配置ssh实现MPI节点间用户的无密码访问  2.4  安装MPICH2   2.5  建立并行计算环境时的注意事项  第3章  并行计算时代的程序设计方法  3.1  最简单的并行程序  3.2  获取进程标志和机器名  3.3  有消息传递功能的并行程序  3.4  Monte Carlo法在并行程序设计中的应用   3.5  并行计算中节点间的Reduce操作  3.6  用MPI的6个基本函数实现Reduce函数功能   3.7  计算与通信的并行  3.8  节点间自定义复杂数据结构的传输  3.9  MPI与MySQL数据库的结合应用  3.10  设计MPI并行程序时的注意事项  第4章  从MPI走向云计算  4.1  MPI没有分布式文件系统支持  4.2  MPI无法应对节点的失效  4.3  假如用MPI来构建云计算系统第2篇  云计算的关键技术   第5章  Map/Reduce是云计算的选择吗  5.1  Map/Reduce跨越50年的历史  5.2  实现Map/Reduce的C语言实例  5.3  采用MPI实现并行化的Map/Reduce功能  第6章  Hadoop技术  6.1  Hadoop与MPI在数据处理上的对比   6.2  Hadoop的主从式结构  6.2.1  主从式文件系统HDFS  6.2.2  主从式计算系统Map/Reduce   6.2.3  文件分块策略分析    6.3  Hadoop文件系统HDFS的前辈GFS   6.4  构建云文件系统需要解决的关键问题  6.5  云计算不相信节点服务器  6.6  揭密云计算架构下的典型服务器——Google服务器     6.6.1  Google服务器概述    6.6.2  揭开Google服务器的神秘面纱4   6.6.3  Google服务器的配置情况    6.6.4  Google服务器的性能评测   第7章  Hadoop环境的建立  7.1  Hadoop配置环境  7.2  配置ssh实现Hadoop节点间用户的无密码访问  7.3  JDK的安装配置  7.4  Hadoop的安装配置  7.5  Hadoop中的Hello World    7.6  C语言程序在Hadoop上运行  第8章  动手做自己的云计算V0.01系统     8.1  系统总体分析    8.1.1  系统架构    8.1.2  文件分布式存储流程    8.1.3  计算与存储的整合流程    8.2  管理节点程序设计与分析   8.2.1  管理节点服务器程序主函数    8.2.2  管理节点各线程函数的设计    8.2.3  主服务器中其他函数的设计   8.3  子节点程序分析  8.3.1  子节点主函数  8.3.2  子节点各线程函数设计    8.4  客户端API设计     8.4.1  客户端文件的存储    8.4.2  客户端启动子节点计算    8.4.3  客户端应用的简单实例  8.5  客户端应用开发实例第3篇  云计算应用实例   第9章  基于不可信服务器节点的云计算基础架构  9.1  云计算基础架构的应用场景     9.2  云计算基础架构    9.3  基于单向指针目录映射的分层用户隔离    9.4  云文件系统的物理存储管理   9.5  云存储的安全级别划分     9.6  计算和存储的整合  9.7  计算和存储的迁移    9.8  任务的可并行性和分类分析   9.9  简化的服务器级粗粒度计算和存储资源分配方案  9.10  数据的云计算系统之旅    第10章  云计算与智能  10.1  云计算的智能与人类智能的比较  10.2  云计算提升终端智能   10.3  云计算智能与Monte Carlo方法    10.4  云计算时代不确定性智能算法示例——模拟谐振子算法  10.4.1  简谐振动的描述   10.4.2  模拟谐振子算法描述     10.4.3  模拟谐振子算法流程    10.4.4  模拟谐振子算法分析  10.4.5  模拟谐振子算法应用于旅行商问题  10.4.6  模拟谐振子算法在连续和非线性优化问题中的应用   10.4.7  模拟谐振子算法的隐含并行性  10.5  云计算中的人工智能  第11章  云计算企业之间的竞争性分析    11.1  云计算技术流派分析  11.1.1  存储型——数据密集云计算平台  11.1.2  计算型——计算密集云计算平台    11.1.3  综合云计算平台    11.2  国际云计算公司分析  11.2.1  云计算技术的提出者Google  11.2.2  “端”的霸主微软  11.2.3  蓝色巨人IBM的蓝云   11.2.4  云计算的市场先行者Amazon公司  11.2.5  Salesforce从SaaS走入云中  11.2.6  热爱白皮书的Sun    11.2.7  EMC云计算的核心是虚拟化     11.2.8  渔翁得利的思科  11.3  国内云计算公司分析  11.3.1  拥有基础设施的世纪互联    11.3.2  阿里巴巴下决心入云   11.3.3  中国移动的BigCloud     11.3.4  国产旗帜友友云计算平台  11.3.5  曙光高性能与云计算  11.3.6  展览也要云  11.4  开源云计算平台分析  11.5  国际国内云计算平台提供商对比研究  11.6  产业综合分析    11.6.1  云计算与网络设备商的关系  11.6.2  云计算与移动通信运营商的关系   11.6.3  云计算与服务器提供商的关系    11.6.4  云计算与应用程序开发商的关系后记  未来的计算——不确定性和隐含并行计算 附录  计算力的标准Linpack测试详细指南参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云计算的关键技术与应用实例
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Web服务
出版者的话
前言
致谢
第一部分 基 本 原 理
第1章 Web Service基础 ... 1
1.1 引言 ... 1
1.1.1 Web Service是什么 ... 2
1.1.2 Web Service的典型场景 ... 3
1.2 “软件即为服务”的理念 ... 5
1.3 Web Service的完整定义 ... 6
1.4 Web Service的特性 ... 7
1.4.1 Web Service的类型 ... 7
1.4.2 功能属性和非功能属性 ... 9
1.4.3 状态属性 ... 9
1.4.4 松耦合 ... 10
1.4.5 服务粒度 ... 11
1.4.6 同步 ... 11
1.4.7 良定义 ... 11
1.4.8 服务的使用环境 ... 12
1.5 服务接口和实现 ... 12
.1.6 面向服务的体系结构 ... 14
1.6.1 SOA中进行交互的角色 ... 14
1.6.2 SOA中的操作 ... 15
1.6.3 SOA： 一个涉及综合服务的样例 ... 16
1.6.4 SOA中的层次 ... 17
1.7 Web Service的技术架构 ... 21
1.8 服务质量（QoS） ... 23
1.9 Web Service的互操作性 ... 25
1.10 Web Service与组件的比较 ... 26
1.11 Web Service的优与劣 ... 28
1.12 小结 ... 30
复习题 ... 30
练习 ... 31
第二部分 核心基础架构
第2章 分布式计算的基础架构 ... 33
2.1 分布式计算与互联网协议 ... 33
2.1.1 互联网协议 ... 34
2.1.2 中间件 ... 37
2.2 客户-服务器模型 ... 38
2.3 进程间通信的特性 ... 39
2.3.1 消息发送 ... 39
2.3.2 消息目的地和socket ... 40
2.3.3 同步方式的消息发送和异步方式的消息发送 ... 40
2.4 中间件的同步方式 ... 41
2.4.1 远程过程调用 ... 41
2.4.2 远程方法调用 ... 43
2.5 中间件的异步方式 ... 43
2.5.1 消息的存储与转发 ... 44
2.5.2 消息的发布与订阅 ... 45
2.5.3 事件驱动的处理机制 ... 46
2.5.4 点到点排队 ... 47
2.6 请求/应答的消息传送方式 ... 48
2.7 面向消息的中间件 ... 49
2.7.1 集成代理 ... 51
2.7.2 Java消息服务（JMS） ... 52
2.8 面向事务的中间件 ... 53
2.9 企业应用程序与电子商务的集成 ... 54
2.10 小结 ... 56
复习题 ... 57
练习 ... 57
第3章 XML概览 ... 59
3.1 XML文档结构 ... 59
3.1.1 XML声明 ... 60
3.1.2 元素 ... 60
3.1.3 属性 ... 61
3.2 URI和XML命名空间 ... 61
3.3 定义XML文档中的结构 ... 63
3.3.1 XML模式定义语言 ... 63
3.3.2 XML模式文档 ... 63
3.3.3 类型定义、元素和属性声明 ... 66
3.3.4 简单类型 ... 67
3.3.5 复合类型 ... 67
3.4 XML模式复用 ... 67
3.4.1 派生的复合类型 ... 67
3.4.2 导入模式与包含模式 ... 69
3.5 文档的导航与转换 ... 74
3.5.1 XML路径语言 ... 74
3.5.2 使用xslt进行文档转换 ... 75
3.6 小结 ... 76
复习题 ... 77
练习 ... 77
第三部分 核心功能与标准
第4章 SOAP： 简单对象访问协议 ... 79
4.1 应用程序间的通信与连接协议 ... 79
4.2 SOAP作为消息传送协议 ... 80
4.3 SOAP消息的结构 ... 83
4.3.1 SOAP信封 ... 84
4.3.2 SOAP头部 ... 85
4.3.3 SOAP消息体 ... 88
4.4 SOAP通信模型 ... 89
4.4.1 RPC类型的Web Service ... 89
4.4.2 文档（消息）类型的Web Service ... 90
4.4.3 通信方式与消息交换的模式 ... 92
4.5 SOAP中的出错处理 ... 92
4.6 基于HTTP的SOAP ... 93
4.7 SOAP的优缺点 ... 95
4.8 小结 ... 96
复习题 ... 96
练习 ... 96
第5章 描述Web Service ... 98
5.1 为何需要服务描述 ... 98
5.2 WSDL： Web Service描述语言 ... 99
5.2.1 WSDL的接口定义 ... 100
5.2.2 WSDL的实现 ... 104
5.2.3 WSDL的消息交换模式 ... 110
5.3 使用WSDL生成客户端stub ... 112
5.4 WSDL中的非功能性描述 ... 114
5.5 小结 ... 114
复习题 ... 115
练习 ... 115
第6章 Web Service的注册与发现 ... 117
6.1 服务注册 ... 117
6.2 服务发现 ... 118
6.3 UDDI： 统一描述、 发现和集成 ... 119
6.3.1 UDDI数据结构 ... 120
6.3.2 WSDL到UDDI的映射模型 ... 130
6.3.3 UDDI API ... 137
6.3.4 UDDI模型的查询 ... 139
6.3.5 UDDI用例模型与部署的多样性 ... 140
6.4 小结 ... 141
复习题 ... 142
练习 ... 142
第四部分 事件通知与面向服务的体系结构
第7章 寻址与通知 ... 143
7.1 Web Service与有状态的资源 ... 143
7.2 Web Service资源框架简介 ... 144
7.2.1 Web Service寻址 ... 146
7.2.2 Web Service资源 ... 149
7.2.3 资源属性 ... 151
7.2.4 资源生命周期 ... 154
7.2.5 服务组 ... 155
7.3 Web Service通知 ... 155
7.3.1 P2P通知 ... 156
7.3.2 通知主题 ... 160
7.3.3 代理通知 ... 163
7.4 Web Service事件 ... 165
7.5 小结 ... 166
复习题 ... 166
练习 ... 166
第8章 面向服务的体系结构 ... 169
8.1 软件体系结构是什么 ... 169
8.1.1 系统质量属性 ... 170
8.1.2 体系结构方面的常见议题 ... 171
8.2 SOA回顾 ... 171
8.3 SOA中的服务角色 ... 173
8.4 可靠的消息传送 ... 175
8.4.1 可靠的消息传送的定义和范围 ... 176
8.4.2 WS-ReliableMessaging ... 176
8.5 企业服务总线 ... 180
8.5.1 SOA的事件驱动特性 ... 182
8.5.2 ESB的关键特征 ... 184
8.5.3 ESB的集成类型 ... 187
8.5.4 ESB解决方案中的各要素 ... 188
8.5.5 连接和转换基础架构 ... 194
8.5.6 遗留资产的使用 ... 195
8.5.7 ESB中的可伸缩性 ... 196
8.5.8 使用ESB的集成模式 ... 198
8.6 扩展的SOA ... 199
8.7 小结 ... 202
复习题 ... 202
练习 ... 202
第五部分 服务组合与服务事务
第9章 流程与工作流 ... 205
9.1 业务流程及其管理 ... 205
9.2 工作流 ... 207
9.3 业务流程的集成与管理 ... 209
9.4 跨企业的业务流程 ... 211
9.5 服务组合元模型 ... 213
9.5.1 流模型的理念 ... 213
9.5.2 Web Service的组合 ... 216
9.6 Web Service的编配与编排 ... 219
9.7 业务流程执行语言（BPEL） ... 221
9.7.1 BPEL的结构 ... 221
9.7.2 BPEL的简单样例 ... 233
9.8 编排 ... 241
9.8.1 编排描述的使用 ... 241
9.8.2 Web Service编排描述语言 ... 242
9.9 其他的一些提案和语言 ... 244
9.10 小结 ... 244
复习题 ... 245
练习 ... 245
第10章 事务处理 ... 247
10.1 什么是事务 ... 247
10.1.1 事务的属性 ... 248
10.1.2 并发控制机制 ... 249
10.2 分布式事务 ... 250
10.2.1 分布式事务体系结构 ... 250
10.2.2 两阶段提交协议 ... 253
10.3 嵌套事务 ... 255
10.3.1 封闭嵌套事务 ... 256
10.3.2 开放嵌套事务 ... 259
10.4 事务型Web Service ... 262
10.4.1 Web Service事务的定义和一般特性 ... 263
10.4.2 Web Service事务的操作特性 ... 264
10.4.3 Web Service事务的类型 ... 265
10.4.4 评议小组与介入 ... 267
10.4.5 Web Service事务的状态 ... 269
10.4.6 Web Service事务框架 ... 270
10.5 WS-Coordination和WS-Transaction ... 271
10.5.1 WS-Coordination ... 271
10.5.2 WS-Transaction ... 278
10.6 Web Service组合应用框架 ... 283
10.6.1 Web Service上下文 ... 284
10.6.2 Web Service协调框架 ... 285
10.6.3 Web Service事务管理 ... 286
10.7 小结 ... 287
复习题 ... 288
练习 ... 288
第六部分 服务安全性与策略 ...
第11章 安全的Web Service ... 291
11.1 Web Service安全性 ... 291
11.1.1 Web Service面临的安全性威胁 ... 292
11.1.2 对策 ... 294
11.2 网络层的安全性机制 ... 294
11.2.1 防火墙 ... 294
11.2.2 入侵检测系统和漏洞评估 ... 298
11.2.3 安全的网络通信 ... 298
11.3 应用层的安全性机制 ... 303
11.3.1 认证 ... 303
11.3.2 授权 ... 304
11.3.3 完整性与机密性 ... 305
11.3.4 不可抵赖性 ... 306
11.3.5 审计 ... 306
11.3.6 应用层安全性协议 ... 306
11.3.7 安全性基础架构 ... 308
11.4 安全性布局 ... 310
11.5 XML安全性标准 ... 312
11.5.1 XML Signature ... 312
11.5.2 XML Encryption ... 315
11.5.3 XML密钥管理规范（XKMS） ... 316
11.5.4 安全声明标记语言 ... 318
11.5.5 XML访问控制标记语言 ... 322
11.6 安全的Web Service ... 326
11.6.1 Web Service应用层面临的挑战 ... 326
11.6.2 Web Service安全性路线图 ... 327
11.6.3 Web Service安全性模型 ... 329
11.6.4 WS-Security ... 330
11.6.5 安全性策略的管理 ... 339
11.6.6 安全会话的管理 ... 340
11.6.7 信任管理 ... 341
11.6.8 隐私管理 ... 342
11.6.9 联邦身份标识的管理 ... 342
11.6.10 授权管理 ... 343
11.7 小结 ... 344
复习题 ... 344
练习 ... 344
参考文献 ... 346
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Web服务
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ASP.NET设计模式
目    录

第Ⅰ部分  模式与设计原则
第1章  成功应用程序的模式	3
1.1  设计模式释义	3
1.1.1  起源	4
1.1.2  必要性	4
1.1.3  有效性	4
1.1.4  局限性	5
1.2  设计原则	5
1.2.1  常见设计原则	5
1.2.2  S.O.L.I.D.设计原则	6
1.3  Fowler的企业设计模式	7
1.3.1  分层	7
1.3.2  领域逻辑模式	7
1.3.3  对象关系映射	8
1.3.4  Web表示模式	9
1.3.5  基本模式、行为模式和结构模式	9
1.4  其他有名的设计实践	10
1.4.1  测试驱动设计	10
1.4.2  领域驱动设计	10
1.4.3  行为驱动设计	10
1.5  小结	11
第2章  剖析模式的模式	13
2.1  如何阅读设计模式	13
2.1.1  GoF模式模板	13
2.1.2  简化模板	14
2.2  设计模式分组	14
2.2.1  创建型	14
2.2.2  结构型	15
2.2.3  行为型	15
2.3  如何选择和运用设计模式	16
2.4  快速模式示例	17
2.4.1  根据设计原则进行重构	19
2.4.2  根据Adapter模式进行重构	21
2.4.3  利用企业模式	24
2.5  小结	25
第Ⅱ部分  剖析ASP.NET应用程序：
学习并应用模式
第3章  应用程序分层与关注点分离	29
3.1  应用程序体系结构与设计	29
3.1.1  反模式：智能UI	29
3.1.2  分离关注点	35
3.2  小结	51
第4章  业务逻辑层：组织	53
4.1  理解业务组织模式	53
4.1.1  Transaction Script	53
4.1.2  Active Record	55
4.1.3  Domain Model	65
4.1.4  Anemic Domain Model	86
4.1.5  领域驱动设计	88
4.2  小结	91
第5章  业务逻辑层：模式	93
5.1  应用设计模式	93
5.1.1  Factory Method模式	93
5.1.2  Decorator模式	97
5.1.3  Template Method模式	103
5.1.4  State模式	107
5.1.5  Strategy模式	113
5.2  应用企业模式	117
5.2.1  Specification模式	117
5.2.2  Composite模式	119
5.2.3  Layer Supertype模式	124
5.3  应用设计原则	127
5.3.1  依赖倒置原则和依赖注入模式	127
5.3.2  接口分离原则	133
5.3.3  里氏替换原则	137
5.4  小结	147
第6章  服务层	149
6.1  服务层介绍	149
6.1.1  SOA	149
6.1.2  SOA的4项信条	152
6.1.3  Facade设计模式	152
6.2  应用Messaging模式	153
6.2.1  Document Message和
Request-Response模式	154
6.2.2  Reservation模式	155
6.2.3  Idempotent模式	156
6.3  SOA示例	156
6.3.1  领域模型和资源库	157
6.3.2  服务层	166
6.3.3  客户端代理	180
6.3.4  客户端	183
6.4  小结	187
第7章  数据访问层	189
7.1  DAL介绍	189
7.2  数据访问策略	189
7.2.1  Repository模式	190
7.2.2  Data Access Objects模式	191
7.3  数据访问模式	191
7.3.1  Unit of Work模式	191
7.3.2  数据并发控制	198
7.3.3  Lazy Loading和Proxy模式	201
7.3.4  Identity Map模式	206
7.3.5  Query Object模式	208
7.4  使用对象关系映射器	218
7.4.1  NHibernate	219
7.4.2  MS Entity Framework	219
7.4.3  ORM代码示例	219
7.5  小结	280
第8章  表示层	283
8.1  反转控制	283
8.1.1  Factory Method设计模式	283
8.1.2  Service Locator	285
8.1.3  IoC容器	286
8.1.4  StructureMap	286
8.2  Model-View-Presenter	290
8.3  Front Controller	313
8.3.1  Command模式	314
8.3.2  Chain of Responsibility模式	336
8.4  Model-View-Controller	344
8.4.1  ViewModel模式	344
8.4.2  ASP.NET MVC框架	345
8.4.3  利用AutoMapper映射ViewModel	357
8.4.4  Castle MonoRail	362
8.5  Page Controller模式	369
8.6  小结	370
第9章  用户体验层	371
9.1  什么是AJAX	371
9.2  使用JavaScript库	372
9.3  理解AJAX模式	372
9.3.1  Periodic Refresh和Timeout	372
9.3.2  Unique URL	390
9.3.3  利用JavaScript Template实现数据
绑定	390
9.3.4  Predictive Fetch	408
9.4  小结	414
第Ⅲ部分  案例研究：
在线电子商务商店
第10章  需求和基础设施	417
10.1  Agatha服装店需求	417
10.1.1  Product Catalog和Basket截屏	418
10.1.2  顾客账号屏幕	420
10.1.3  结账屏幕	422
10.1.4  缓存和日志	423
10.2  架构	423
10.3  小结	443
第11章  创建商品目录	445
11.1  创建产品目录	445
11.1.1  Product Catalog模型	445
11.1.2  Product Catalog数据表	450
11.1.3  Product Catalog资源库	451
11.1.4  Product服务	465
11.1.5  控制器	480
11.1.6  Product Catalog视图	490
11.1.7  设置IoC	513
11.2  小结	516
第12章  实现购物车	519
12.1  实现购物车	519
12.1.1  Basket领域模型	519
12.1.2  创建购物车数据表	529
12.1.3  NHibernate映射	530
12.1.4  购物车服务	533
12.1.5  购物车控制器和购物车视图	543
12.2  小结	565
第13章  顾客会员	567
13.1  顾客会员	567
13.1.1  Customer模型	568
13.1.2  Customer数据表	573
13.1.3  Customer NHibernate映射	573
13.1.4  Customer服务	576
13.1.5  身份验证服务	585
13.1.6  Customer控制器	593
13.1.7  Account控制器	597
13.1.8  顾客关系视图	607
13.1.9  身份验证视图	611
13.2  小结	617
第14章  订购和支付	619
14.1  结账	619
14.1.1  Order模型	620
14.1.2  Order数据表	635
14.1.3  Order NHibernate映射	636
14.1.4  Order服务	639
14.1.5  利用PalPay进行支付	648
14.1.6  Order、Payment与Checkout
控制器	657
14.1.7  Order和Checkout视图	666
14.2  小结	676

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ASP.NET设计模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Microsoft SQL Server企业级平台管理实践
第1章 数据库空间管理
1.1 文件的分配方式及文件空间检查方法
1.2 数据文件空间使用与管理
1.3 日志文件不停增长
1.4 文件自动增长和自动收缩
1.5 小结
第2章 数据库备份与恢复
2.1 备份概述
2.2 选择备份策略和恢复模式
2.3 选择数据库还原方案
2.4 应对由于备份损坏导致的还原错误
2.5 系统数据库备份与恢复
2.6 实例：将数据库系统在一台新服务器上恢复
第3章 SQL Server服务或数据库不可访问
3.1 SQL Server服务启动顺序
3.2 数据库状态切换及Recovery
3.3 系统数据库不能启动的常见原因和解决方法
3.4 用户数据库常见问题和解决方法
3.5 实例：修复Recovery失败的数据库
第4章 数据库损坏修复
4.1 常见错误解读
4.2 DBCC CHECKDB
4.3 数据库反复损坏问题应对
第5章 连接与认证
5.1 协议的选择与别名
5.2 连接失败检测步骤——命名管道
5.3 连接失败检测步骤——TCP/IP
5.4 一般性网络错误（General Network Error）
5.5 认证与代理问题
第6章 SQL Server内存分配理念和常见内存问题
6.1 从操作系统层面看SQL Server内存分配
6.2 SQL Server内部独特的内存管理模式
6.3 SQL Server内存使用状况分析方法
6.4 数据页缓冲区压力分析
6.5 Stolen Memory缓存压力分析
6.6 Multi-page缓存区压力分析
6.7 常见内存错误与解决办法
6.8 小结
第7章 SQL Server IO问题
7.1 SQL Server的I/O操作
7.2 系统级I/O问题判断
7.3 数据库引擎错误833
7.4 IO问题的SQL Server内部分析
7.5 硬盘压力测试
7.6 小结
第8章 任务调度与CPU问题
8.1 SQL Server独特的任务调度算法(SQLOS)
8.2 SQL CPU %问题
8.3 OLTP和Data Warehouse系统差别及常用性能阀值
8.4 小结
第9章 阻塞与死锁——知识准备
9.1 锁产生的背景
9.2 锁资源模式和兼容性
9.3 事务隔离级别与锁的申请和释放
9.4 如何监视锁的申请、持有和释放
9.5 锁的数量和数据库调优的关系
9.6 结论
9.7 数据库引擎中基于行版本控制的隔离级别
第10章 阻塞与死锁——问题定位与解决
10.1 阻塞问题定位方法及实例演示
10.2 常见阻塞原因与解决方法
10.3 案例分析：连接池（Connection Pooling）与阻塞
10.4 死锁问题定位及解决方法
第11章 从等待状态判断系统资源瓶颈
11.1 LCK_xx类型
11.2 PAGEIOLATCH_x 与WRITELOG
11.3 PAGELATCH_x
11.4 Tempdb上的PAGELATCH
11.5 其他资源等待
11.6 最后一道瓶颈：许多任务处于Runnable状态
11.7 小结
第12章 语句调优——知识准备
12.1 索引与统计信息
12.2 编译与重编译
12.3 读懂执行计划
12.4 读懂语句运行统计信息
第13章 语句调优-问题定位与解决方法
13.1 是否是因为做了物理IO而导致的性能不佳
13.2 是否是因为编译时间长而导致性能不佳
13.3 判断执行计划是否合适
13.4 Parameter Sniffing
13.5 调整数据库设计来优化语句性能
13.6 调整语句设计提高性能
第14章 常用SQL Server系统信息与搜集方法
14.1 Windows 事件日志（Event Log）
14.2 SQL Server Errorlog文件
14.3 性能监视器（Performance Monitor）
14.4 SQL Trace文件
14.5 系统管理视图跟踪
14.6 自动化信息收集：SQLDiag工具
14.7 系统自动监视工具 - Performance Dashboard
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Microsoft SQL Server企业级平台管理实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>毫无保留
中文版序   读万卷书，行万里路，识万般人	前言   伟大企业的承诺  第一部分  不忘初心，万豪坚守“以人为本”	你的成功并不是凭空而来的。任何公司想要繁荣发展都离不开人，不管是朋友还是敌人，有了人的支持才能成为赢家。	第1 章  同伴永远在第一位  第2 章  闭上嘴巴，张开耳朵，打开思维  第3 章  人人为我，我为人人  第二部分天使成绩，万豪追求卓越的收获	要想真正做到优秀，就必须从*小的细节开始关注，即便你的顾客根本看不见它们。如果细节中有折磨人之处，那么就如通常所说的那样，那里明显就是*值得关注之处。	第4 章  走出办公室，走进一线：做一个实践型的领导者	第5 章  魔鬼细节，完美是万豪对任何事情的*低预期	第6 章  下定决心做决定	第三部分万豪进步的艺术，用创新挑战现状	在创新面前，我们愿意抛弃公司苦苦经营获得的名声，不管以怎样的方式、不管结果是好是坏，因为创新有可能重塑万豪的核心文化。	第7 章  在变革中保持秩序	第8 章  在秩序中保持变革	第四部分行正直之道，万豪人的永恒追求	即便是*良好的初衷也可能遭人误解，但你选择面对误解的态度却至关重要。如果你确定自己并没有做错，那么无论如何也要坚持到底，然而，采用的方式要值得人们尊敬，要能够体现出你的原则。	第9 章  危机风暴中，仍要摸索前行	第10 章  站在决策的分岔路口：是倾听内心召唤，还是浪费时间去遗憾？	第五部分善举无处不在，只因万豪“感恩回报”的信条	我们绝大多数同事的内心都渴望做一个对他人有用的人，不然，他们一开始也不会选择到万豪工作。正是因为万豪同事心中的大爱，多年来，我们一直参与到许多伟大的事业之中，不管是从个人角度出发，还是作为公司整体。	第11 章  大爱无疆，富足人生	第12 章  过程即回报	结语   成功没有终点，万豪仍一直在探寻	附录   万豪=m-a-r-r-i-o-t-t 译者后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>毫无保留
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Web设计大全
译者序前言第一部分

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Web设计大全
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大型门户网站是这样炼成的！
第1篇 技术篇　第1章 大型门户网站架构分析　　1.1 大型门户网站与小型企业网站的区别　　1.2 高性能、高负载门户网站架构剖析　　　1.2.1 服务器操作系统的选择　　　1.2.2 DNS服务器BIND　　　1.2.3 Cache服务器Squid　　　1.2.4 带负载均衡的HTTP服务器Apache　　　1.2.5 支持集群功能的Web服务器Tomcat　　　1.2.6 开源数据库服务器之骄子MySQL　　　1.2.7 功能强大的FlV流媒体服务器RED5　　1.3 门户网站开发指导思想　　1.4 SSH 2组合框架—门户网站开发之首选　　　1.4.1 MVC混血宠儿Struts 2　　　1.4.2 幕后的财政部长Spring 2.5　　　1.4.3 ORM中间件香馍馍Hibernate 3.2　　1.5 小结　第2章 MVC混血宠儿Struts 2　　2.1 初识MVC新秀Struts 2　　　2.1.1 MVC概述　　　2.1.2 Struts 2的MVC实现　　　2.1.3 Struts 2的基本组成　　　2.1.4 Struts 2的常用类介绍　　　2.1.5 Struts 2的业务控制器Action实现　　　2.1.6 Struts 2的处理结果Result　　　2.1.7 功能强大的表达式语言OGNL　　　2.1.8 Struts 2的运行流程分析—HelloWorld　　　2.1.9 Struts 2的异常处理　　2.2 Struts 2配置精要　　　2.2.1 web.xml中Struts 2的配置实现　　　2.2.2 Struts 2属性配置文件struts.properties详解　　　2.2.3 Struts 2核心配置文件struts.xml详解　　2.3 Struts 2应用开发实务　　　2.3.1 Struts 2应用开发环境的搭建　　　2.3.2 Struts 2应用基本开发步骤—搭建ePortal应用　　　2.3.3 Struts 2中集成FCKeditor　　　2.3.4 Struts 2中集成DisplayTag　　2.4 Struts 2国际化实现　　　2.4.1 Web应用的中文本地化　　　2.4.2 Struts 2应用的国际化　　　2.4.3 Struts 2国际化语言的动态切换　　2.5 Struts 2的校验框架　　　2.5.1 在Action中实现手动校验　　　2.5.2 调用校验框架进行自动校验　　　2.5.3 自定义国际化Struts 2校验错误消息　　　2.5.4 Struts 2的自带校验器　　2.6 Struts 2的拦截器　　　2.6.1 Struts 2内建拦截器介绍　　　2.6.2 定义和使用拦截器栈　　　2.6.3 使用自定义拦截器　　2.7 小结　第3章 Struts 2标签库详解与AJAX技术应用　　3.1 Struts 2主题与模板　　3.2 Struts 2控制标签详解　　　3.2.1 if/elseif/else标签详解　　　3.2.2 iterator标签详解　　　3.2.3 append标签详解　　　3.2.4 generator标签详解　　　3.2.5 merge标签详解　　　3.2.6 subset标签详解　　　3.2.7 sort标签详解　　3.3 Struts 2数据标签详解　　　3.3.1 action标签详解　　　3.3.2 bean标签详解　　　3.3.3 date标签详解　　　3.3.4 debug标签详解　　　3.3.5 i18n标签详解　　　3.3.6 include标签详解　　　3.3.7 param标签详解　　　3.3.8 push标签详解　　　3.3.9 set标签详解　　　3.3.10 text标签详解　　　3.3.11 url标签详解　　　3.3.12 property标签详解　　3.4 Struts 2表单标签详解　　　3.4.1 checkbox标签详解　　　3.4.2 checkboxlist标签详解　　　3.4.3 combobox标签详解　　　3.4.4 doubleselect标签详解　　　3.4.5 file标签详解　　　3.4.6 form标签详解　　　3.4.7 hidden标签详解　　　3.4.8 select标签详解　　　3.4.9 optgroup标签详解　　　3.4.10 optiontransferselect标签详解　　　3.4.11 password标签详解　　　3.4.12 radio标签详解　　　3.4.13 reset与submit标签详解　　　3.4.14 textarea标签详解　　　3.4.15 textfield标签详解　　　3.4.16 token标签详解　　　3.4.17 updownselect标签详解　　3.5 Struts 2 AJAX标签详解　　　3.5.1 a与submit标签详解　　　3.5.2 autocompleter标签详解　　　3.5.3 datetimepicker标签详解　　　3.5.4 div标签详解　　　3.5.5 head标签详解　　　3.5.6 tabbedPanel标签详解　　3.6 Struts 2其他标签详解　　　3.6.1 actionerror与actionmessage标签详解　　　3.6.2 fielderror标签详解　　　3.6.3 tree与treenode标签详解　　3.7 Struts 2全力支持AJAX　　　3.7.1 Struts 2中原始AJAX技术应用　　　3.7.2 基于DWR的AJAX实现　　　3.7.3 基于DWR的AJAX表单验证　　　3.7.4 基于JSON插件的AJAX实现　　3.8 小结　第4章 ORM中间件名流Hibernate 3接管持久层　　4.1 ORM简介　　　4.1.1 持久化与持久层　　　4.1.2 JDBC劣势　　　4.1.3 实体域模型与关系数据模型　　　4.1.4 ORM中间件　　4.2 Hibernate简介　　　4.2.1 Hibernate体系结构　　　4.2.2 Hibernate API简介　　　4.2.3 配置Hibernate　　　4.2.4 Hibernate的映射配置文件　　　4.2.5 体验Hibernate（会员管理）　　4.3 Hibernate的映射机制　　　4.3.1 Hibernate的基本映射数据类型　　　4.3.2 Hibernate的主键映射　　　4.3.3 Hibernate的实体映射　　　4.3.4 映射一对一关联关系　　　4.3.5 映射多对一单向关联关系　　　4.3.6 映射一对多双向关联关系　　　4.3.7 映射一对多双向自身关联关系　　　4.3.8 映射多对多单向关联关系　　　4.3.9 映射多对多双向关联关系　　　4.3.10 映射组成关系　　　4.3.11 映射继承关系　　　4.3.12 Hibernate的集合映射　　4.4 小结　第5章 Hibernate 3持久化技术实践与性能优化　　5.1 操作持久化对象的常用方法介绍　　　5.1.1 使用Session的beginTransaction()方法　　　5.1.2 使用Session的close()方法　　　5.1.3 使用Session的connection()方法　　　5.1.4 使用Session的delete()方法　　　5.1.5 使用Session的get()方法　　　5.1.6 使用Session的load()方法　　　5.1.7 使用Session的save()方法　　　5.1.8 使用Session的update()方法　　　5.1.9 使用Session的saveOrUpdate()方法　　　5.1.10 使用Hibernate的isInitialized()与initialize()方法　　　5.1.11 持久化对象间的级联操作　　5.2 Hibernate的检索策略　　　5.2.1 立即检索　　　5.2.2 延迟检索　　　5.2.3 迫切左外连接检索　　5.3 HQL查询方式　　　5.3.1 基本查询　　　5.3.2 条件查询　　　5.3.3 分页查询　　　5.3.4 连接查询　　　5.3.5 子查询　　　5.3.6 动态实例化查询结果　　5.4 QBC查询方式　　　5.4.1 基本查询　　　5.4.2 QBE查询　　　5.4.3 分页查询　　　5.4.4 复合查询　　　5.4.5 离线查询　　5.5 本地SQL查询　　5.6 Hibernate的批量处理　　　5.6.1 批量插入　　　5.6.2 批量更新　　　5.6.3 批量删除　　5.7 Hibernate的事务管理　　　5.7.1 事务边界声明　　　5.7.2 并发控制　　　5.7.3 悲观锁　　　5.7.4 乐观锁　　5.8 Hibernate的缓存机制　　　5.8.1 Hibernate的缓存分类　　　5.8.2 Hibernate的缓存范围　　　5.8.3 Hibernate的缓存管理　　　5.8.4 Hibernate二级缓存的并发访问策略　　　5.8.5 Hibernate的二级缓存配置　　5.9 Hibernate应用的性能优化　　5.10 多数据源的应用　　5.11 JDBC的应用　　5.12 Hibernate调用存储过程　　5.13 XML数据持久化　　5.14 小结　第6章 充分利用Spring 2.5的IoC利器统管Bean世界　　6.1 Java程序员的春天厚礼—Spring 2.5　　　6.1.1 爱上Spring 2.5的十大理由　　　6.1.2 一睹Spring 2.5芳容　　　6.1.3 Spring 2.5拿手戏——控制反转与依赖注入　　　6.1.4 何为“面向切面编程AOP”　　　6.1.5 Spring 2.5圣经——面向接口编程　　　6.1.6 开始Spring 2.5旅程—Hello World　　6.2 Spring 2.5核心技术　　　6.2.1 Bean工厂之BeanFactory介绍　　　6.2.2 实用的Bean工厂ApplicationContext　　　6.2.3 Spring 2.5配置文件详解　　　6.2.4 Bean的作用域与生命周期　　　6.2.5 基于XML方式的Bean装配　　　6.2.6 基于Annotation方式的Bean装配　　　6.2.7 基于XML方式的AOP实现　　　6.2.8 基于Annotation方式的AOP实现　　6.3 Spring 2.5事务管理机制　　　6.3.1 Spring 2.5的声明式事务管理　　　6.3.2 基于XML方式的事务管理配置　　　6.3.3 基于Annotation方式的事务管理配置　　6.4 “桃园三结义”——SSH 2组合开发框架始成　　　6.4.1 Spring 2.5集成ORM中间件Hibernate 3.2　　　6.4.2 Spring 2.5集成MVC框架Struts 2　　　6.4.3 SSH 2组合框架的基本开发步骤—ePortal启程　　6.5 小结第2篇 实践篇　第7章 SSH 2热身——构建新闻发布系统　　7.1 门户网站新闻资讯基本分类　　7.2 新闻发布系统需求分析　　7.3 新闻发布系统功能设计　　7.4 新闻栏目后台管理　　　7.4.1 展示层JSP 2+Struts 2 标签库实现　　　7.4.2 控制层Struts2实现　　　7.4.3 持久层Hibernate3实现　　　7.4.4 Spring2接管业务逻辑层　　7.5 新闻内容后台管理　　　7.5.1 展示层JSP2+Struts2标签库实现　　　7.5.2 控制层Struts 2实现　　　7.5.3 持久层Hibernate3实现　　　7.5.4 Spring2接管业务逻辑层　　7.6 新闻资讯前台展现　　　7.6.1 文本新闻列表自定义标签类TextnewsTag　　　7.6.2 文本新闻列表分页控制自定义标签类TextnewsPageTag　　　7.6.3 图片新闻列表自定义标签类PicnewsTag　　　7.6.4 幻灯片新闻列表自定义标签类SlidenewsTag　　　7.6.5 Struts2与AJAX完全结合实现点击数加一　　7.7 基于HttpClient构建通用静态页面发布引擎　　　7.7.1 优秀的模拟浏览器HttpClient　　　7.7.2 构建通用静态页面发布引擎　　7.8 小结　第8章 通用新闻采集系统　　8.1 新闻采集系统需求分析　　8.2 新闻采集系统功能设计　　8.3 使用正则表达式与HTMLParser采集新闻内容　　　8.3.1 正则表达式基本知识　　　8.3.2 体验HTMLParser　　8.4 量身定制采集规则　　　8.4.1 展示层JSP 2+Struts 2标签库实现　　　8.4.2 控制层Struts 2实现　　　8.4.3 持久层Hibernate3实现　　　8.4.4 Spring 2接管业务逻辑层　　8.5 新闻采集功能实现　　8.6 小结　第9章 会员注册及会员管理系统　　9.1 会员管理系统需求分析　　9.2 会员管理系统功能设计　　9.3 会员级别后台管理　　　9.3.1 展示层JSP 2+Struts 2标签库实现　　　9.3.3 持久层Hibernate 3实现　　　9.3.4 Spring 2接管业务逻辑层　　9.4 注册会员后台管理　　　9.4.1 展示层JSP 2+Struts 2标签库实现　　　9.4.2 控制层Struts2实现　　　9.4.3 持久层Hibernate3实现　　　9.4.4 Spring 2接管业务逻辑层　　9.5 前台会员注册与登录　　9.6 小结　第10章 举一反三—实现商品分类管理　　10.1 商品管理系统需求分析　　10.2 商品管理系统功能设计　　10.3 商品类别后台管理　　　10.3.1 展示层JSP 2+Struts 2标签库实现　　　10.3.2 控制层Struts 2实现　　　10.3.3 持久层Hibernate3实现　　　10.3.4 Spring2接管业务逻辑层　　10.4 商品后台管理　　　10.4.1 展示层JSP 2+Struts 2标签库实现　　　10.4.2 控制层Struts 2实现　　　10.4.3 持久层Hibernate3实现　　　10.4.4 Spring 2接管业务逻辑层　　10.5 小结　第11章 温故知新—打造购物车与订单管理系统　　11.1 购物车与订单管理系统需求分析　　11.2 购物车及订单管理系统功能设计　　11.3 购物车自助管理　　　11.3.1 展示层JSP2+Struts2标签库实现　　　11.3.2 控制层Struts 2实现　　　11.3.3 持久层Hibernate3实现　　　11.3.4 Spring2接管业务逻辑层　　11.4 订单管理　　　11.4.1 展示层JSP 2+Struts 2标签库实现　　　11.4.2 控制层Struts 2实现　　　11.4.3 持久层Hibernate 3实现　　　11.4.4 Spring 2接管业务逻辑层　　11.5 小结　第12章 站务必备—系统用户管理与流量统计　　12.1 系统用户管理与流量统计需求分析　　12.2 系统用户管理与流量统计功能设计　　12.3 系统用户管理　　　12.3.1 展示层JSP 2+Struts 2标签库实现　　　12.3.2 控制层Struts 2实现　　　12.3.3 持久层Hibernate3实现　　　12.3.4 Spring2接管业务逻辑层　　12.4 流量统计分析　　　12.4.1 展示层JSP 2+Struts 2标签库实现　　　12.4.2 控制层Struts 2实现　　　12.4.3 持久层Hibernate3实现　　　12.4.4 Spring2接管业务逻辑层　　12.5 小结第3篇 部署篇　第13章 门户网站的搜索引擎优化—SEO技术　　13.1 为什么要进行搜索引擎优化　　　13.1.1 搜索引擎概述　　　13.1.2 网络营销催生SEO　　　13.1.3 SEO让你的网站脱颖而出　　13.2 搜索引擎到底喜欢什么样的网站　　　13.2.1 影响网站自然排名的主要因素　　　13.2.2 评价网站优劣的重要指标　　　13.2.3 正确看待SEO　　　13.2.4 远离Google的“沙盒”　　13.3 搜索引擎优化最佳实践　　　13.3.1 如何快速被搜索引擎收录　　　13.3.2 建立合理的网站结构与网站地图的应用　　　13.3.3 设计良好的网页结构　　　13.3.4 SEO基本功——关键词的选用　　　13.3.5 域名与空间对SEO的影响　　　13.3.6 搜索引擎偏爱“勤快”的网站　　13.4 搜索引擎优化辅助工具大本营　　　13.4.1 关键字选词辅助工具　　　13.4.2 关键字排名查询　　　13.4.3 关键字密度查询　　　13.4.4 热门关键字及搜索量查询　　　13.4.5 PR值查询　　　13.4.6 Alexa世界排名查询　　　13.4.7 搜索引擎收录页面数查询　　　13.4.8 搜索引擎反向链接查询　　　13.4.9 网站地图制作工具　　　13.4.10 百度指数查询　　　13.4.11 网页中无效链接检测工具　　13.5 小结　第14章 基于RHEL 5的服务器架构　　14.1 Red Hat Enterprise Linux 5安装与优化　　14.2 Linux客户端工具Secure SSH安装与应用　　14.3 RHEL5服务器维护的基本操作　　　14.3.1 系统维护相关的Linux命令　　　14.3.2 文件操作相关的Linux命令　　　14.3.3 网络维护相关的Linux命令　　　14.3.4 日志查看相关的Linux命令　　　14.3.5 用户管理相关的Linux命令　　　14.3.6 应用软件安装相关的Linux命令　　14.4 RHEL5中的JDK1.6安装　　14.5 RHEL5中的MySQL5安装与性能优化　　14.6 基于vsftpd搭建FTP服务器　　14.7 RHEL5中的Tomcat6安装与性能优化　　14.8 RHEL5中的Apache2.2安装与性能优化　　14.9 Apache2.2配置文件httpd.conf详解　　14.10 使用subversion搭建SVN版本控制服务器　　14.11 利用Red5搭建Flash流媒体服务器　　14.12 利用vncserver服务实现远程桌面　　14.13 小结　第15章 负载均衡与服务器集群　　15.1 Web服务器集群概述　　15.2 搭建Apache2.2+Tomcat6分工协作服务器架构　　15.3 构建Apache2.2负载均衡与Tomcat6集群　　15.4 搭建主从结构的MySQL数据库集群　　15.5 基于MySQL Proxy的负载均衡与读写分离　　15.6 小结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大型门户网站是这样炼成的！
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件开发本质论
版权声明
评论
前言
致谢
引言
第一部分　价值的循环
第 1 章　寻找价值
第 2 章　价值就是那些我们想要的东西
第 3 章　根据功能特性可以指导得更好
第 4 章　根据功能特性组织团队
第 5 章　根据功能特性进行计划
第 6 章　根据功能特性构建产品
第 7 章　同时构建功能特性与基础
第 8 章　零缺陷与良好的设计
第 9 章　价值的完整循环
第二部分　说明与论述
第 10 章　价值是什么
第 11 章　如何衡量价值
第 12 章　是的，软件开发很难！
第 13 章　事情并非那么简单
第 14 章　组建强大的团队
第 15 章　使用五卡法进行初步的预测
第 16 章　自然软件开发的管理之道
第 17 章　监督员工更加努力地工作
第 18 章　能力是提高速度的前提
第 19 章　重构
第 20 章　敏捷方法
第 21 章　大规模敏捷
第 22 章　结论
参考书目
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件开发本质论
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大型网站性能监测、分析与优化
第 1 部分　基础篇
第1 章　应用性能管理概述 / 2
1.1　关于应用性能 / 2
1.2　关于应用性能管理 / 2
1.3　基本意识 / 3
1.3.1　价值与意义 / 4
1.3.2　出发点 / 6
1.3.3　相关的人 / 7
1.3.4　解决的问题 / 9
1.3.5　前提条件 / 11
1.3.6　组织形式 / 12
1.4　如何正确开始 / 14
1.5　投入与收益平衡 / 16
1.6　优秀企业的经验 / 17
第 2 部分　监测、工具篇
第2 章　应用性能监测实践 / 20
2.1　应用性能监测概述 / 20
2.2　应用性能持续监测 / 23
2.2.1　移动监测 / 24
2.2.2　Web监测 / 37
2.2.3　系统监测 / 56
2.2.4　应用监测 / 62
2.2.5　日志监测 / 89
2.3　应用性能即时监测 / 94
2.3.1　PC即时监测 / 101
2.3.2　移动Web App即时评测 / 104
2.3.3　移动Native App即时评测 / 106
2.3.4　网络即时监测 / 109
第3 章　性能监测工具介绍 / 113
3.1　监测工具概述 / 113
3.2　持续监测工具 / 115
3.2.1　Keynote / 116
3.2.2　Dynatrace / 117
3.2.3　App dynamics / 119
3.2.4　Newrelic / 120
3.2.5　基调 / 122
3.2.6　博睿 / 124
3.2.7　OneAPM / 125
3.2.8　云智慧 / 128
3.3　即时监测工具 / 130
3.3.1　YSlow / 130
3.3.2　Pagespeed Insights / 131
3.3.3　WebPageTest / 132
3.3.4　ChromeDevTools / 133
3.3.5　PhantomJS / 135
3.3.6　Jsperf / 136
3.4　其他工具 / 136
3.5　应用性能指标 / 140
3.5.1　用户指标 / 140
3.5.2　服务器指标 / 147
3.5.3　移动指标 / 149
3.5.4　其他指标 / 150
第 4 章　性能监测平台搭建实践 / 152
4.1　为什么要搭建监测平台 / 152
4.2　如何搭建性能监测平台 / 154
第 3 部分　分析、优化篇
第 5 章　应用性能分析实践 / 160
5.1　产生性能问题的因素 / 160
5.1.1　产品逻辑及用户行为 / 161
5.1.2　中国基础网络 / 161
5.1.3　PC端环境 / 163
5.1.4　移动端环境 / 164
5.1.5　代码及应用 / 165
5.1.6　服务器及云环境 / 166
5.2　应用性能分析概述 / 166
5.2.1　从用户及生产环境着手 / 167
5.2.2　常见的分析方法 / 176
5.2.3　主要分析视图 / 182
5.2.4　横向对比的意义 / 202
5.2.4.2　按行业分析 / 203
第 6 章　应用性能优化实践 / 205
6.1　应用性能优化概述 / 205
6.1.1　确保优化方向正确 / 206
6.1.2　确定优化带来的收益 / 207
6.1.3　功能与性能的平衡 / 209
6.1.4　防止过早和过渡优化 / 209
6.2　网络优化 / 210
6.2.1　IDC优化 / 211
6.2.2　ISP优化 / 217
6.2.3　CDN优化 / 221
6.2.4　BGP优化 / 229
6.2.5　DNS优化 / 231
6.3　系统优化 / 234
6.3.1　压缩优化 / 236
6.3.2　缓存优化 / 237
6.3.3　分离优化 / 240
6.3.4　内核优化 / 242
6.3.5　传输优化 / 245
6.3.6　并发优化 / 248
6.3.7　隔离优化 / 250
6.3.8　网卡优化 / 251
6.3.9　硬件优化 / 254
6.4　前端优化 / 257
6.4.1　首屏优化 / 259
6.4.2　内容优化 / 261
6.4.3　请求优化 / 263
6.4.4　CSS优化 / 266
6.4.5　JavaScript优化 / 269
6.4.6　图片优化 / 271
6.5　后端优化 / 275
6.5.1　架构优化 / 275
6.5.2　并行优化 / 276
6.5.3　异步优化 / 276
6.5.4　基础优化 / 276
6.5.5　算法优化 / 277
6.5.6　程序优化 / 277
6.5.7　缓存优化 / 278
6.6　移动优化 / 278
6.6.1　网络优化 / 279
6.6.2　请求优化 / 282
6.6.3　缓存优化 / 283
6.6.4　策略优化 / 284
6.6.5　启动优化 / 286
6.6.6　交互优化 / 286
6.6.7　内存优化 / 287
6.7　其他优化 / 290
6.7.1　SPDY / 290
6.7.2　HTTP/2 / 291
6.7.3　ESI / 293
6.7.4　SDCH / 294
6.7.5　BigPipe / 294
6.7.6　DNS Prefetch / 295
6.7.7　HHVM / 295
第 7 章　性能优化平台搭建实践 / 296
7.1　为什么要搭建优化平台 / 296
7.2　如何搭建性能优化平台 / 297
第 4 部分　标准、保持篇
第 8 章　应用性能优化标准 / 304
8.1　防止应用性能退化概述 / 304
8.2　通过规范防止性能退化 / 304
8.3　通过流程防止性能退化 / 307
8.3.1　应用性能准入 / 307
8.3.2　应用性能认证 / 308
8.3.3　应用性能巡检 / 309
8.4　业界优秀企业的经验 / 310
8.4.1　雅虎Web优化最佳实践 / 310
8.4.2　谷歌Web优化最佳实践 / 310
第 9 章　应用性能优化保持 / 313
9.1　性能优化保持概述 / 313
9.2　通过平台防止性能退化 / 313
9.2.1　自动优化开发框架 / 313
9.2.2　自动优化基础平台 / 314
9.3　通过告警防止性能退化 / 314
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大型网站性能监测、分析与优化
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>涂抹MySQL
又见涂抹（推荐序）
轮扁斫轮（自序）
第1 章 开源运动与开源软件MySQL 1
1.1 开源软件的故事 1
1.1.1 GNU 说，我代表着一个梦想 3
1.1.2 FSF 说，兄弟我顶你 4
1.1.3 兄弟，你是“自由软件”吗 4
1.1.4 GPL 说，持证上岗光荣 5
1.1.5 开源软件说，队长别开枪，咱们是一伙的 6
1.2 MySQL 的悄然而至 7
1.2.1 起源 7
1.2.2 根据地成立 9
1.2.3 快速发展，大踏步向前 9
1.2.4 世事难料，不经历风雨怎能见彩虹 12
1.2.5 向前向前向前 14
1.2.6 以开源的心态学开源 15
第2 章 安装MySQL 数据库软件 17
2.1 Windows 平台安装 18
2.1.1 安装包方式安装 19
2.1.2 压缩包方式安装 28
2.1.3 Windows 平台的一些限制 29
2.2 Linux 平台安装 30
2.2.1 RPM 包方式安装 31
2.2.2 源码编译方式安装 37
2.2.3 二进制包方式安装 40
第3 章 管理MySQL 数据库服务 45
3.1 Windows 平台下的MySQL 服务 46
3.2 Linux 平台下的MySQL 服务 47
3.2.1 创建数据库服务 47
3.2.2 启动数据库服务 51
3.2.3 配置MySQL 数据库 51
3.3 MySQL 服务管理配置 54
3.3.1 创建管理脚本 55
3.3.2 开机自动启动 56
第4 章 管理MySQL 库与表 58
4.1 上帝说，要有库 58
4.1.1 说删咱就删 60
4.1.2 说建咱就建 61
4.2 上帝说，要有表 64
4.2.1 想建咱就建 66
4.2.2 想看咱就看 71
4.2.3 想改咱就改 74
4.2.4 想删咱就删 78
第5 章 MySQL 数据库中的权限体系 81
5.1 谈谈权限处理逻辑 81
5.1.1 能不能连接 81
5.1.2 能不能执行操作 82
5.1.3 权限变更何时生效 82
5.2 权限授予与回收 83
5.2.1 创建用户 84
5.2.2 授予权限 91
5.2.3 查看和收回用户权限 95
5.2.4 删除用户 98
5.3 权限级别 99
5.3.1 全局 99
5.3.2 数据库 103
5.3.3 表 108
5.3.4 列 110
5.3.5 程序 112
5.4 账户安全管理 113
5.4.1 用户与权限设定原则 113
5.4.2 小心历史文件泄密 114
5.4.3 管理员口令丢失怎么办 115
第6 章 字符，还有个集 118
6.1 基础扫盲 118
6.1.1 关于字符集 119
6.1.2 关于校对规则 120
6.2 支持的字符集和校对规则 120
6.3 指定字符集和校对规则 123
6.3.1 服务端设置默认字符集 124
6.3.2 连接时指定 126
6.3.3 保存时指定 132
6.4 字符集操作示例 136
6.5 角落里的字符集设置 139
6.5.1 字符串的字符集 139
6.5.2 错误提示的字符集 140
6.5.3 国家字符集 142
第7 章 选择对象的存储引擎 144
7.1 存储引擎体系结构 145
7.2 常见存储引擎 148
7.2.1 MEMORY 存储引擎 149
7.2.2 CSV 存储引擎 152
7.2.3 ARCHIVE 存储引擎 153
7.2.4 BLACKHOLE 存储引擎154
7.2.5 MERGE 存储引擎 157
7.2.6 FEDERATED 存储引擎 159
7.3 MyISAM 存储引擎 165
7.3.1 MyISAM 引擎特性167
7.3.2 MyISAM 引擎存储格式 169
7.4 InnoDB 存储引擎 171
7.4.1 默认的存储引擎 173
7.4.2 InnoDB 引擎配置 175
7.4.3 创建和使用InnoDB 表对象 182
7.4.4 逻辑存储结构185
7.4.5 多版本机制 188
7.4.6 联机修改表对象结构 189
7.4.7 InnoDB 表对象的限制条件 201
第8 章 MySQL 数据库文件结构 204
8.1 初始化选项文件 204
8.2 错误日志文件 208
8.3 查询日志文件 209
8.3.1 慢查询日志 209
8.3.2 普通查询日志211
8.3.3 配置查询日志212
8.4 二进制日志文件 215
8.4.1 这个必须有 215
8.4.2 它不是随便的人 216
8.4.3 想说懂你不容易 217
8.5 中继日志及复制状态文件 219
8.6 表对象数据文件 221
8.7 其他文件 221
8.7.1 进程id 文件221
8.7.2 套接字文件 222
8.7.3 自动配置文件222
第9 章 数据导出与导入 223
9.1 利用CSV 存储引擎加载数据 223
9.2 mysqlimport 命令行工具导入数据 224
9.2.1 导入超简单 225
9.2.2 分列超轻松 226
9.2.3 换行很容易 228
9.3 SQL 语句导入数据 229
9.3.1 快来认识下LOAD DATA INFILE 230
9.3.2 字符集咋处理的呐 232
9.3.3 要导入的数据文件放哪儿 234
9.3.4 数据文件的前N 行记录不想导咋办 236
9.3.5 列和行的精确处理 236
9.3.6 对象结构与数据文件不符咋整 246
9.4 SQL 语句导出数据 249
9.4.1 这些知识，不学都会 250
9.4.2 这些知识，一学就会 251
第10 章 MySQL 数据备份和数据恢复 254
10.1 备份与恢复名词解释 254
10.1.1 物理备份VS 逻辑备份 255
10.1.2 联机备份VS 脱机备份 256
10.1.3 本地备份VS 远程备份 257
10.1.4 完整备份VS 增量备份 257
10.1.5 完整恢复VS 增量恢复 258
10.2 备份工具知多少 258
10.2.1 复制表对象相关文件的方式创建备份集 258
10.2.2 使用mysqlhotcopy 命令行工具创建备份 259
10.2.3 使用mysqldump 命令行工具创建逻辑备份 259
10.2.4 使用SQL 语句创建备份 260
10.2.5 冷复制方式创建物理备份 260
10.2.6 二进制日志创建增量备份260
10.2.7 第三方工具创建联机备份260
10.3 Hey Jude, Don't be afraid, 备份咱有mysqldump 261
10.3.1 单个数据库的备份任务 261
10.3.2 备份多个数据库 263
10.3.3 输出定界格式文件 263
10.3.4 恢复mysqldump 创建的备份集 265
10.3.5 多学些mysqldump 命令行参数 266
10.3.6 自动化备份策略 272
10.4 冷备、增量备和备份恢复策略 275
10.4.1 创建冷备份275
10.4.2 创建增量备份 276
10.4.3 备份和恢复策略 278
10.5 XtraBackup 联机备份 280
10.5.1 关于XtraBackup 280
10.5.2 先试试xtrabackup 命令 282
10.5.3 再用用innobackupex 命令 284
10.5.4 创建增量备份 287
10.5.5 执行恢复 290
10.5.6 打包和压缩备份集 295
10.5.7 自动化备份脚本 296
第11 章 MySQL 复制特性 298
11.1 创建复制环境 300
11.1.1 最简单的复制环境部署方法 300
11.1.2 复制环境配置宝典 307
11.1.3 常用的复制环境管理命令310
11.2 复制特性的实施原理和关键因素315
11.2.1 复制格式 315
11.2.2 中继日志文件和状态文件319
11.2.3 复制过滤规则 322
11.3 高级应用技巧 332
11.3.1 通过XtraBackup 创建Slave节点 333
11.3.2 利用Slave 节点创建备份 336
11.3.3 部署级联Slave 增强复制性能 340
11.3.4 半同步机制 343
11.3.5 复制环境中的故障切换 348
11.3.6 延迟复制 352
第12 章 五花八门的MySQL 管理工具 354
12.1 这些年MySQL 提供的命令行工具 354
12.1.1 mysql_install_db—MySQL建库工具 355
12.1.2 mysqld_safe—MySQL 启动工具 356
12.1.3 mysqld—MySQL 主进程 357
12.1.4 mysqld_multi—MySQL 多实例管理工具 360
12.1.5 mysql—专业命令行工具 362
12.1.6 mysqladmin—管理工具 368
12.1.7 其他常用命令 371
12.2 phpMyAdmin 372
12.2.1 安装phpMyAdmin 372
12.2.2 配置phpMyAdmin 376
12.2.3 试用phpMyAdmin 379
12.3 MySQL Workbench 383
12.3.1 执行SQL 查询 384
12.3.2 数据建模 386
12.3.3 服务管理 391
12.4 其他第三方图形管理工具 394
第13 章 性能调优与诊断 396
13.1 测试方法 397
13.1.1 关键性指标 398
13.1.2 获取关键性指标 402
13.1.3 TPCC 测试 411
13.2 数据库参数配置优化 416
13.2.1 连接相关参数 417
13.2.2 文件相关参数 418
13.2.3 缓存控制参数 420
13.2.4 MyISAM 专用参数423
13.2.5 InnoDB 专用参数 425
13.2.6 参数优化案例 428
13.3 分析慢查询日志 432
13.3.1 mysqldumpslow 命令433
13.3.2 mysqlsla 命令 434
13.4 关注系统状态 438
13.4.1 MySQL 服务在做什么 438
13.4.2 MySQL 语句在做什么 440
13.4.3 实战优化案例 448
第14 章 部署MySQL 服务监控平台 451
14.1 监控状态，我用Nagios 452
14.1.1 初始化环境452
14.1.2 初识监控项454
14.1.3 配置监控项460
14.1.4 监控服务列表 462
14.2 监控性能，我有Cacti 464
14.2.1 初始化环境与安装Cacti 466
14.2.2 配置MySQL 监控模板 474
14.2.3 监控MySQL 实例 478
第15 章 搭建MySQL 高可用体系 483
15.1 追求更高稳定性的服务体系 483
15.1.1 可扩展性 484
15.1.2 高可用性 485
15.2 Slave+LVS+Keepalived 实现高可用 488
15.2.1 配置LVS 489
15.2.2 配置RealServer491
15.2.3 增加高可用能力 494
15.3 Dual-Master 高可用环境 497
15.3.1 故障随便切换 498
15.3.2 IP 自动飘移 504
15.3.3 架构设计有讲究 510
15.4 DRBD，为Master 节点数据提供更高保障 512
15.4.1 基础知识扫扫盲 512
15.4.2 一个好汉多个帮 515
15.5 官方集群正统MySQL Cluster 518
15.5.1 Cluster 体系结构概述 518
15.5.2 Cluster 安装与配置520
15.5.3 Cluster 应用初体验524
15.6 继续扩展数据库服务 527
15.6.1 该拆分时要拆分 528
15.6.2 处理策略得想清 532
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>涂抹MySQL
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据技术丛书
前言
作者简介
第1章 分布式单词计数
1.1 Storm topology的组成部分——stream、spout和bolt
1.1.1 Storm
1.1.2 spout
1.1.3 bolt
1.2 单词计数topology的数据流
1.2.1 语句生成bolt
1.2.2 语句分割bolt
1.2.3 单词计割bolt
1.2.4 上报bolt
1.3 实现单词计数top
1.3.1 配置开发环境
1.3.2 实现Sentence
1.3.3 实现语句分割bolt
1.3.4 实现单词计割bolt
1.3.5 实现上报bolt
1.3.6 实现单词计数topo
1.4 Storm的并发机制
1.4.1 WordCountTopology的并发机制
1.4.2 给topology增加woker
1.4.3 配置executor和task
1.5 理解数据流分组
1.6 有保障机制的数据处理
1.6.1 spout的可靠性
1.6.2 bolt的可靠性
1.6.3 可靠的单词计数
总结
第2章 配置Storm集群
2.1 Storm集群的框架
2.1.1 理解nimbus守护进程
2.1.2 supervisor守护进程的工作方式
2.1.3 Apache ZooKeeper简介
……
第3章 Trident和传感器数据
第4章 实时趋势分析
第5章 实时图形分析
第6章 人工智能
第7章 整合Druid进行金融分析
第8章 自然语言处理
第9章 在Hadoop上部署Storm进行广告分析
第10章 云环境下的S
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大数据技术丛书
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Web2.0Mashup开发实战/Web开发系列/图灵程序设计丛书
第一部分混编信息，无需编程
第1章从具体的混搭中学习
1.1寻找混搭的模式
1.2Housingmaps.com
1.3Flickr中的GoogleMaps
1.4LibraryLookup书签小工具
1.5跟踪其他的混搭
1.6小结
第2章发现Web站点混搭的潜质
2.1是什么使Web站点和应用能被混搭
2.2Web站点的URL语言
2.3已知混搭的简要回顾
2.4基于URL模板和URL嵌入的混搭模式
2.5GoogleMaps
2.6Amazon
2.7del.icio.us
2.8屏幕抓取和机器人
2.9小结
第3章理解标签和分众标签
3.1Flickr的标签机制
3.2del.icio.us的标签机制
3.3在Technorati中基于标签收集内容
3.4使用标签混搭Flickr和del.icio.us
3.5其他使用标签的系统
3.6标签与正规分类模式的关系
3.7小结
第4章使用提要、RSS和Atom
4.1什么是提要，它为何如此重要
4.2RSS2.0
4.3RSS1.0
4.4Atom1.0
4.5RSS2.0和Atom1.0的扩展
4.6来自Flickr的提要
4.7来自其他Web站点的提要
4.8新闻聚合器：在别处显示Flickr提要
4.9提要的验证
4.10使用GUI工具抓取提要
4.11使用Feedburner混编提要
4.12使用Yahoo!Pipes混编提要
4.13小结
第5章博客的集成
5.1博客集成的场景
5.2将Flickr照片发送到博客
5.3桌面博客发布工具
5.4组合提要与博客发布工具来生成反馈流
5.5Flock：博客与Flickr的结合
5.6RSD：博客API的可发现性
5.7反向链接
5.8初级Wiki集成
5.9小结
第二部分使用API混编单个Web应用
第6章通过Flickr学习Web服务API
6.1FlickrAPI简介
6.2API文档、社群与策略
6.3使用FlickrAPIExplorer及其文档
6.4使用PHP调用基本的FlickrAPI方法
6.5一般的FlickrAPI
6.6请求与响应格式
6.7Flickr授权
6.8使用FlickrAPI工具包
6.9FlickrAPI的局限性
6.10小结
第7章其他WebAPI
7.1XML-RPC
7.2SOAP
7.3学习具体的WebAPI
7.4小结
第8章Ajax/JavaScript微件及其API
8.1必要的知识
8.2Ajax带来了什么
8.3Firebug，DOMInspector和JavaScriptShell
8.4使用JavaScript库
8.5YUI微件
8.6了解GoogleMaps
8.7使用JavaScript访问Flickr
8.8使用Greasemonkey访问《纽约时报》的永久链接
8.9更多地了解JavaScript和Ajax
8.10小结
第三部分创建混搭
第9章从API和可混编元素到混搭
9.1ProgrammableWeb
9.2查看特定的混搭概要信息
9.3从特定的API到混搭
9.4示例：准备用混搭解决的问题
9.5小结
第10章创建多个服务的混搭
10.1设计
10.2背景回顾：Flickr中的地理标签
10.3背景回顾：XMLHttpRequest及其所包含的库
10.4建立一个服务器端代理
10.5建立一个简单的客户端框架
10.6将客户端框架与Flickr挂接
10.7混搭GoogleMapsAPI和Flickr
10.8显示Flickr照片的GoogleMapplet
10.9小结
第11章使用工具创建混搭
11.1混搭工具所解决的问题
11.2本章将创建的混搭
11.3一步步生成混搭
11.4关于GME和Yahoo!Pipes的权衡
11.5其他混搭工具
11.6小结
第12章使你的Web站点可混搭
12.1为什么要使Web站点可混搭
12.2不依赖于API的技术手段
12.3创建对混搭友好的API
12.4易于理解的数据标准
12.5小结
第四部分混搭的其他主题
第13章混编在线地图与3D数字化地球
13.1在线地图的数量
13.2基于地图的混搭示例
13.3无需编程制作地图
13.4数据交换格式
13.5通过API编程创建地图
13.6地理编码
13.7GoogleEarth与KML
13.8Mapstraction与OpenLayers
13.9综合示例：在GoogleEarth中显示Flickr图片
13.10小结
第14章探索社会化书签与目录系统
14.1社会化书签发展场景
14.2del.icio.us
14.3Yahoo!Bookmarks与Yahoo!MyWeb
14.4Connotea
14.5Flickr与del.icio.us的混搭
14.6小结
第15章访问在线日历与事件聚合器
15.1GoogleCalendar
15.2boxes.com
15.3事件聚合器
15.4对iCalendar编程
15.5向iCalendar和GoogleCalendar导出一个事件日历
15.6小结
第16章使用在线存储服务
16.1AmazonS3简介
16.2S3的基本原理
16.3AmazonS3的概念结构
16.4Firefox的S3扩展：初步使用S3
16.5使用S3的REST接口
16.6使用S3的SOAP接口
16.7AmazonS3的API工具包
16.8小结
第17章混搭桌面和基于Web的办公套件
17.1办公套件的混搭场景
17.2文档的混搭
17.3OpenDocument格式
17.4ODF的API工具包
17.5ECMAOfficeOpenXML(OOXML)
17.6比较ODF和OOXML
17.7在线办公套件
17.8GoogleSpreadsheetsAPI
17.9ZohoAPI
17.10小结
第18章可嵌入数据格式：微格式和RDFa
18.1使用Operator学习微格式
18.2微格式的定义及其设计目标
18.3微格式的设计模式
18.4各种微格式
18.5实际应用中的微格式
18.6对微格式编程
18.7编写Operator脚本
18.8资源(RDFa)：有望成为微格式的补充
18.9进一步学习的参考资料
18.10小结
第19章搜索的集成
19.1GoogleAjaxSearch
19.2Yahoo!Search
19.3MicrosoftLive.comSearch
19.4OpenSearch
19.5GoogleDesktopHTTP/XML网关
19.6小结
附录知识产权、可重用性与知识共享
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Web2.0Mashup开发实战/Web开发系列/图灵程序设计丛书
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>成就存储专家之路:存储从入门到精通
第1章 存储基础知识
1.1 概述
1.1.1 存储的分类
1.1.2 存储的概念
1.1.3 外置存储设备
1.2 存储的物理结构
1.2.1 简介
1.2.2 存储的磁盘技术
1.2.3 存储的内部结构
1.2.4 存储的外部连接设备
1.3 存储的基础结构
1.3.1 直接附加存储
1.3.2 存储区域网络
1.3.3 网络附加存储
1.3.4 内容地址存储
1.3.5 磁盘库与虚拟磁带库
1.4 存储的保护方式
1.4.1 RAID
1.4.2 冗余设计
1.4.3 备份
1.4.4 本地复制
1.4.5 远程复制和容灾
1.5 存储管理和应用基础
1.5.1 存储管理的基本结构和标准
1.5.2 常见的存储应用方法
1.6 小结
第2章 存储相关技术
2.1 概述
2.2 主机与操作系统
2.2.1 主机
2.2.2 开放性操作系统
2.2.3 小结
2.3 逻辑卷管理与文件系统
2.4 数据库与中间件
2.4.1 Oracle
2.4.2 DB2
2.4.3 SQLServer
2.4.4 Sybase
2.4.5 Informix
2.4.6 内存数据库
2.4.7 WebSphere
2.4.8 WebLogic
2.5 备份软件
2.6 管理软件
2.7 存储测试技术
2.7.1 SPC的SPC1和SPC2
2.7.2 IOMeter
2.7.3 IOZone
2.7.4 dd
2.8 其他相关技术及标准
2.8.1 OracleOrion
2.8.2 SNIAXAM
2.9 小结
第3章 主流存储厂商及其存储产品简介
3.1 EMC公司
3.1.1 Symmetrix系列
3.1.2 CLARiiON系列
3.1.3 Celerra系列IP存储
3.1.4 磁带库系列
3.1.5 Centera系列
3.1.6 软件产品和其他系列产品
3.2 HP公司
3.2.1 磁盘阵列系统
3.2.2 网络连接存储系统
3.2.3 磁带存储系统
3.2.4 刀片存储系统
3.2.5 存储网络
3.2.6 存储软件
3.3 H3C公司
3.3.1 万兆存储系列
3.3.2 中低端存储系列
3.3.3 虚拟磁带库系列
3.3.4 数据管理平台系列
3.4 IBM公司
3.4.1 磁盘系统
3.4.2 磁带系统
3.4.3 存储网络产品
3.4.4 存储软件
3.5 Brocade公司
3.5.1 企业级产品
3.5.2 部门级交换机
3.5.3 路由及延伸产品
3.5.4 管理软件
3.5.5 数据迁移管理器
3.5.6 服务器连接产品
3.6 HuaweiSymantec公司
3.6.1 存储系统
3.6.2 集群NAS存储系统
3.6.3 T3000系列云存储节点
3.6.4 虚拟带库系统
3.6.5 虚拟化设备
3.6.6 数据保护解决方案产品
3.6.7 存储管理平台
3.7 Infortrend公司
3.7.1 EonStoriSCSI系列
3.7.2 EonStorFC系列
3.7.3 EonStorSAS系列
3.7.4 EonStorMINISAS系列
3.8 Finisar公司
3.8.1 Xgig系统
3.8.2 MLTT测试软件
3.9 NEC公司
3.9.1 E系列
3.9.2 D系列
第4章 存储客户的需求特点与存储规划
4.1 电信行业
4.1.1 行业概述
4.1.2 电信业存储系统需求
4.1.3 电信业存储系统规划
4.1.4 电信业存储系统使用维护
4.2 金融行业
4.2.1 银行行业
4.2.2 保险行业
4.2.3 证券行业
4.3 政府（税务、公安、海关）行业
4.3.1 税务行业
4.3.2 公安行业
4.3.3 海关行业
4.4 公众事业行业
4.4.1 高等教育行业
4.4.2 医疗行业
4.5 大型企业
4.5.1 行业概述
4.5.2 大型企业IT特点
4.5.3 大型企业存储系统需求
4.5.4 大型企业管理分析
4.5.5 大型企业存储系统规划
4.6 中小型企业
4.6.1 行业概述
4.6.2 中小型企业IT特点
4.6.3 中小型企业应用挑战
4.6.4 中小型企业存储系统需求
4.6.5 中小型企业存储系统规划
4.7 其他行业
4.7.1 广电行业
4.7.2 环保行业
4.7.3 视频监控行业
4.7.4 互联网行业
4.7.5 安防行业
4.8 小结
第5章 存储典型解决方案和应用场景
5.1 存储技术解决方案
5.1.1 直连存储解决方案
5.1.2 网络存储解决方案
5.1.3 存储整合解决方案
5.1.4 高可用性解决方案
5.1.5 分层存储管理方案
5.1.6 虚拟存储解决方案
5.1.7 备份恢复解决方案
5.1.8 业务连续性解决方案
5.1.9 存储安全解决方案
5.1.1 0信息生命周期管理解决方案
5.1.1 1绿色数据中心解决方案
5.2 存储行业解决方案
5.2.1 电信行业存储解决方案
5.2.2 金融行业存储解决方案
5.2.3 教育行业存储解决方案
5.2.4 互联网行业存储解决方案
5.2.5 广电行业存储解决方案
5.2.6 电力行业存储解决方案
5.2.7 制造行业存储解决方案
5.2.8 公安行业存储解决方案
5.2.9 零售行业存储解决方案
5.2.1 0视频监控行业存储解决方案
5.2.1 1安防行业存储解决方案
5.3 厂商解决方案典型案例
5.3.1 EMC公司典型解决方案
5.3.2 HP公司典型解决方案
5.3.3 H3C公司典型解决方案
5.3.4 IBM公司典型解决方案
5.3.5 Brocade公司典型解决方案
5.3.6 HuaweiSymantec公司典型解决方案
5.3.7 Infortrend公司典型解决方案
第6章 存储架构和IT架构规划
6.1 存储架构趋势
6.2 IT架构和IT架构视图
6.2.1 IT架构简介
6.2.2 IT架构的重要性
6.2.3 IT架构的不同视图
6.3 IT架构的现状
6.4 IT架构规划与IT规划
6.4.1 IT架构物理整合
6.4.2 IT架构虚拟化
6.4.3 IT规划
6.5 典型IT架构
6.5.1 面向服务的架构
6.5.2 企业开放架构
6.5.3 企业架构
6.6 IT架构师
6.6.1 IT架构师的定义和类型
6.6.2 企业IT架构师
6.7 IT架构组织和标准
6.7.1 TOGAF
6.7.2 EUP
6.7.3 Zachman框架
第7章 存储的市场前景与技术趋势
7.1 存储市场现状和前景分析
7.2 存储技术趋势
7.2.1 固态硬盘
7.2.2 存储整合
7.2.3 存储虚拟化
7.2.4 万兆存储架构
7.2.5 信息生命周期管理
7.2.6 重复数据删除（Deduplication）
7.2.7 RaidX
7.2.8 绿色存储与绿色数据中心
7.3 小结
第8章 存储职业发展与技术学习
8.1 市场需求推动行业发展，存储行业的光明前景
8.2 存储行业人才需求的情况
8.2.1 存储用户中的人才需求
8.2.2 存储厂商中的人才需求
8.3 存储学习、培训、认证情况
8.3.1 校园存储教育
8.3.2 SNCP认证体系
8.3.3 EMC认证培训体系
8.3.4 HP认证培训体系
8.3.5 H3C认证培训体系
8.3.6 IBM认证培训体系
8.3.7 Brocade认证培训体系
8.3.8 HuaweiSymantec认证培训体系
8.4 存储行业职业规划探讨
附录A 部分存储厂商简介
A1.易安信电脑系统（中国）有限公司（EMC）
A2.中国惠普有限公司（HP）
A3.杭州华三通信技术有限公司（H3C）
A4.国际商业机器公司（IBM）
A5.博科通讯系统（中国）有限公司（Brocade）
A6.华为赛门铁克科技有限公司（HuaweiSymantec）
A7.普安科技股份有限公司（Infortrend）
A8.Finisar公司
A9.NEC公司
附录B 术语表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>成就存储专家之路:存储从入门到精通
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>特定领域应用框架
第1章 简介
1.1 应用框架分类
1.2 本书的组织
1.3 小结
1.4 参考文献
第1部分 计算机集成制造框架

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>特定领域应用框架
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件定义数据中心：技术与实践
编委会
序
前　言
第一部分　总体介绍
第1章　基本概念  2
1.1　数据中心的历史  3
1.2　继续发展的推动力  6
1.3　软件定义的必要性  8
1.4　架构分析  13
1.4.1　基本功能模块  14
1.4.2　层次细分  14
1.4.3　接口与标准  17
1.5　现状与发展  18
1.6　第三平台：SDDC上的IT新浪潮  20
第二部分　关键技术
第2章　软件定义的计算  26
2.1　虚拟化的定义与基本概念  26
2.1.1　虚拟化定义  26
2.1.2　虚拟化产生背景  26
2.1.3　计算虚拟化  27
2.1.4　VMM的要求与基本特征  30
2.1.5　虚拟化平台的不同架构  30
2.2　虚拟化技术分类  31
2.2.1　x86平台虚拟化面临的问题与挑战  31
2.2.2　全虚拟化  32
2.2.3　半虚拟化  32
2.2.4　硬件虚拟化  33
2.2.5　小结  33
2.3　CPU虚拟化  34
2.3.1　二进制翻译  34
2.3.2　硬件解决方案  35
2.4　内存虚拟化  36
2.4.1　软件解决方案  36
2.4.2　硬件解决方案  37
2.4.3　内存虚拟化管理面临的挑战  38
2.5　I/O虚拟化  38
2.5.1　背景介绍  38
2.5.2　基于软件的I/O虚拟化  39
2.5.3　基于硬件的I/O虚拟化  42
2.6　实例剖析  46
2.6.1　VMware ESX  46
2.6.2　Xen  53
第3章　软件定义存储  59
3.1　新的存储管理模式  59
3.1.1　传统存储面临的挑战  59
3.1.2　新的管理模式：软件定义存储  61
3.2　与存储虚拟化的比较  63
3.3　架构、功能与特性  66
3.3.1　数据模块与控制模块  67
3.3.2　系统架构设计  68
3.4　解决方案：分类与比较  72
3.4.1　分类方法  72
3.4.2　现有产品简介  74
3.4.3　分类映射  77
3.5　市场现状与分析  78
3.5.1　技术影响  79
3.5.2　软件定义存储的商业价值  80
3.5.3　市场展望  81
3.6　典型实现  81
3.6.1　基于传统外置存储：ViPR  81
3.6.2　基于服务器内置存储：ScaleIO  85
第4章　软件定义网络  91
4.1　概述  91
4.1.1　什么是SDN  92
4.1.2　SDN的架构和特征  94
4.1.3　SDN相关组织介绍  97
4.1.4　各大厂商对SDN的态度和应用  101
4.2　SDN的技术实现  108
4.2.1　以网络为中心的实现  109
4.2.2　以主机为中心的实现  120
4.3　SDN的典型实现：OpenStack中的网络组件Neutron  131
4.3.1　Neutron在OpenStack中的架构  132
4.3.2　Neutron在OpenStack中的工作机制  134
4.3.3　Nicira NVP插件  134
4.3.4　小结  137
第5章　自动化资源管理  138
5.1　资源管理定义  138
5.2　资源管理对象  140
5.3　资源管理策略  143
5.3.1　资源管理一般性评价指标和标准  143
5.3.2　资源管理的主要策略  144
5.4　多租户管理  147
5.4.1　网络多租户管理  148
5.4.2　计算多租户管理  149
5.4.3　存储多租户管理  149
5.5　性能管理  150
5.6　对外服务接口  153
5.7　资源管理典型实现  156
第6章　流程控制  163
6.1　概述  163
6.2　架构和功能  168
6.2.1　数据中心Orchestrator的架构  168
6.2.2　数据中心Orchestrator的功能  170
6.3　实现数据中心自动化  171
6.3.1　数据中心的自动化势在必行  171
6.3.2　自动化的好处  171
6.3.3　自动化实施的对象  173
6.3.4　如何实现自动化  173
6.4　实例分析  175
6.4.1　VMware vCloud Orchestrator  175
6.4.2　System Center Orchestrator  178
第7章　软件定义数据中心的安全  184
7.1　数据中心安全设计原则  184
7.2　物理基础设施的安全  186
7.3　软件定义层的安全  187
7.3.1　安全的计算  187
7.3.2　安全的存储  193
7.3.3　安全的网络  197
7.4　软件资源协调层的安全  203
7.4.1　统一的身份与访问授权管理  203
7.4.2　安全技术的统一运用  205
7.5　小结  207
第8章　软件定义的高可用性  208
8.1　高可用性系统设计  209
8.1.1　不可用的常见原因  209
8.1.2　冗余的组件部署  210
8.1.3　高可用性集群  210
8.1.4　典型的冗余配置  211
8.2　软件定义之路——计算的高可用性  213
8.2.1　高可用性对应用的需求  213
8.2.2　高可用性集群——VMware HA  214
8.2.3　零停机保障——VMware FT  218
8.3　软件定义之路——存储的高可用性  219
8.3.1　基于VPLEX的高可用性  219
8.3.2　ScaleIO的高可用性  222
8.3.3　ViPR的控制器集群与HA数据服务  223
8.4　软件定义之路——网络的高可用性  224
8.4.1　网络虚拟化  225
8.4.2　逻辑端口镜像  226
8.4.3　网络控制器集群  226
8.4.4　网关服务的高可用性  227
8.5　软件定义数据中心的高可用性  228
8.5.1　整合的解决方案  229
8.5.2　持续可用性  230
8.5.3　分布式快速数据恢复  231
8.6　典型实现  232
8.6.1　VMware SDDC的高可用性  232
8.6.2　OpenStack的高可用性设计  234
第三部分　解决方案与应用
第9章　总体解决方案  238
9.1　SDDC的基本要素  238
9.2　SDDC实例：VMware解决方案  239
9.2.1　VMware SDDC的计算  242
9.2.2　VMware SDDC的存储  243
9.2.3　VMware SDDC的网络  246
9.2.4　VMware SDDC的高可用性和容错  249
9.2.5　VMware SDDC的自动化  250
9.2.6　VMware SDDC的安全机制  251
9.2.7　VMware SDDC的管理  252
9.2.8　VMware SDDC实现小结  253
9.3　SDDC实例：OpenStack解决方案  254
9.3.1　Horizon控制面板  256
9.3.2　Nova计算组件  256
9.3.3　Swift对象存储  257
9.3.4　Glance镜像存储  257
9.3.5　KeyStone身份控制  257
9.3.6　Quantum网络  257
9.3.7　Cinder块存储  258
9.4　小结  258
第10章　云存储应用  259
10.1　云存储案例  259
10.2　云存储实现  260
10.2.1　可管理性  262
10.2.2　云存储系统的类型  262
10.2.3　访问方法  263
10.2.4　性能  263
10.2.5　多租户  264
10.2.6　可扩展性  264
10.2.7　可用性  264
10.2.8　可控性  265
10.2.9　效率  265
10.2.10　成本  266
10.3　云存储模式  266
10.3.1　公有云存储  266
10.3.2　私有云存储  267
10.3.3　混合云存储  267
10.3.4　三种云存储模式比较  267
10.4　主要云存储服务提供商  268
10.4.1　企业级云存储  268
10.4.2　个人云存储  269
第11章　虚拟化大数据平台  270
11.1　概述  270
11.2　VMware Serengeti  272
11.3　AWS EMR  280
11.4　小结  283
第四部分　大型实例分析
第12章　AWS数据中心实例  286
12.1　AWS概述  286
12.2　EC2管理计算能力  287
12.2.1　EC2概述  287
12.2.2　EC2架构  287
12.2.3　EC2存储  288
12.2.4　自动缩放  289
12.2.5　网络路由  289
12.2.6　EC2实例  289
12.3　可扩展的存储  291
12.3.1　块存储  291
12.3.2　对象存储  292
12.3.3　冷数据归档  293
12.3.4　云存储网关  294
12.4　弹性十足的网络  295
12.4.1　亚马逊的VPC  296
12.4.2　VPC的特性  296
12.4.3　VPC的应用场景  298
12.4.4　VPC对SDN的践行  301
12.5　自动化的管理和部署  302
12.6　效益分析与未来发展  305
第13章　PPTV基础平台管理体系  306
13.1　系统概述  306
13.1.1　云部署模型  306
13.1.2　自建IDC部署概述  307
13.1.3　系统架构和组成  307
13.2　IaaS部署和管理实践  308
13.2.1　基于CloudStack的IaaS管理平台  308
13.2.2　存储服务  310
13.2.3　基于CloudStack的私有云平台最佳实践  310
13.3　MaaS管理和基础服务体系  311
13.3.1　MaaS管理架构  311
13.3.2　自动化基础设施管理架构概述  312
13.3.3　开源工具链  312
参考文献  319
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件定义数据中心：技术与实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解大数据：大数据处理与编程实践
推荐序一
推荐序二
推荐序三
丛书序言
前　　言
第一部分　Hadoop系统
第1章　大数据处理技术简介  2
1.1　并行计算技术简介  2
1.1.1　并行计算的基本概念  2
1.1.2　并行计算技术的分类  6
1.1.3　并行计算的主要技术问题  10
1.2　大数据处理技术简介  13
1.2.1　大数据的发展背景和研究意义  13
1.2.2　大数据的技术特点  16
1.2.3　大数据研究的主要目标、基本原则和基本途径  17
1.2.4　大数据计算模式和系统  18
1.2.5　大数据计算模式的发展趋势  21
1.2.6　大数据的主要技术层面和技术内容  22
1.3　MapReduce并行计算技术简介  25
1.3.1　MapReduce的基本概念和由来  25
1.3.2　MapReduce的基本设计思想  26
1.3.3　MapReduce的主要功能和技术特征  28
1.4　Hadoop系统简介  30
1.4.1　Hadoop的概述与发展历史  30
1.4.2　Hadoop系统分布式存储与并行计算构架  31
1.4.3　Hadoop平台的基本组成与生态系统  33
1.4.4　Hadoop的应用现状和发展趋势  37
第2章　Hadoop系统的安装与操作管理  39
2.1　Hadoop系统安装方法简介  39
2.2　单机和单机伪分布式Hadoop系统安装基本步骤  39
2.2.1　安装和配置JDK  40
2.2.2　创建Hadoop用户  40
2.2.3　下载安装Hadoop  40
2.2.4　配置SSH  41
2.2.5　配置Hadoop环境  42
2.2.6　Hadoop的运行  43
2.2.7　运行测试程序  43
2.2.8　查看集群状态  44
2.3　集群分布式Hadoop系统安装基本步骤  44
2.3.1　安装和配置JDK  44
2.3.2　创建Hadoop用户  45
2.3.3　下载安装Hadoop  45
2.3.4　配置SSH  45
2.3.5　配置Hadoop环境  46
2.3.6　Hadoop的运行  48
2.3.7　运行测试程序  48
2.3.8　查看集群状态  49
2.4　Hadoop MapReduce程序开发过程  49
2.5　集群远程作业提交与执行  53
2.5.1　集群远程作业提交和执行过程  53
2.5.2　查看作业执行结果和集群状态  53
第3章　大数据存储——分布式文件系统HDFS  56
3.1　HDFS的基本特征与构架  56
3.1.1　HDFS的基本特征  57
3.1.2　HDFS的基本框架与工作过程  57
3.2　HDFS可靠性设计  60
3.2.1　HDFS数据块多副本存储设计  60
3.2.2　HDFS可靠性的设计实现  61
3.3　HDFS文件存储组织与读写  63
3.3.1　文件数据的存储组织  63
3.3.2　数据的读写过程  65
3.4　HDFS文件系统操作命令  68
3.4.1　HDFS启动与关闭  68
3.4.2　HDFS文件操作命令格式与注意事项  69
3.4.3　HDFS文件操作命令  69
3.4.4　高级操作命令和工具  77
3.5　HDFS基本编程接口与示例  83
3.5.1　HDFS编程基础知识  83
3.5.2　HDFS基本文件操作API  84
3.5.3　HDFS基本编程实例  87
第4章　Hadoop MapReduce并行编程框架  91
4.1　MapReduce基本编程模型和框架  91
4.1.1　MapReduce并行编程抽象模型  91
4.1.2　MapReduce的完整编程模型和框架  93
4.2　Hadoop MapReduce基本构架与工作过程  96
4.2.1　Hadoop系统构架和MapReduce程序执行过程  96
4.2.2　Hadoop MapReduce执行框架和作业执行流程  98
4.2.3　Hadoop MapReduce作业调度过程和调度方法  102
4.2.4　MapReduce执行框架的组件和执行流程  106
4.3　Hadoop MapReduce主要组件与编程接口  107
4.3.1　数据输入格式InputFormat  107
4.3.2　输入数据分块InputSplit  109
4.3.3　数据记录读入RecordReader  110
4.3.4　Mapper类  112
4.3.5　Combiner  114
4.3.6　Partitioner  115
4.3.7　Sort  116
4.3.8　Reducer类  119
4.3.9　数据输出格式OutputFormat  120
4.3.10　数据记录输出RecordWriter  122
第5章　分布式数据库HBase  123
5.1　HBase简介  123
5.1.1　为什么需要NoSQL数据库  123
5.1.2　HBase的作用和功能特点  125
5.2　HBase的数据模型  126
5.2.1　HBase的基本数据模型  126
5.2.2　HBase的查询模式  128
5.2.3　HBase表设计  129
5.3　HBase的基本构架与数据存储管理方法  132
5.3.1　HBase在Hadoop生态中的位置和关系  132
5.3.2　HBase的基本组成结构  133
5.3.3　HBase Region  133
5.3.4　Region Server  135
5.3.5　HBase的总体组成结构  138
5.3.6　HBase的寻址和定位  139
5.3.7　HBase节点的上下线管理  142
5.4　HBase安装与操作  145
5.4.1　安装一个单机版的HBase  145
5.4.2　HBase Shell操作命令  146
5.4.3　基于集群的HBase安装和配置  149
5.5　HBase的编程接口和编程示例  152
5.5.1　表创建编程接口与示例  152
5.5.2　表数据更新编程接口与示例  153
5.5.3　数据读取编程接口与示例  155
5.5.4　HBase MapReduce支持和编程示例  157
5.6　HBase的读写操作和特性  161
5.6.1　HBase的数据写入  161
5.6.2　HBase的数据读取  171
5.7　其他HBase功能  173
5.7.1　Coprocessor  173
5.7.2　批量数据导入Bulk Load  176
第6章　分布式数据仓库Hive  179
6.1　Hive的作用与结构组成  179
6.2　Hive的数据模型  181
6.2.1　Hive的数据存储模型  181
6.2.2　Hive的元数据存储管理  182
6.2.3　Hive的数据类型  183
6.3　Hive的安装  184
6.3.1　下载Hive安装包  184
6.3.2　配置环境变量  184
6.3.3　创建Hive数据文件目录  185
6.3.4　修改Hive配置文件  185
6.4　Hive查询语言——HiveQL  188
6.4.1　DDL语句  188
6.4.2　DML语句  189
6.4.3　SELECT查询语句  190
6.4.4　数据表操作语句示例  190
6.4.5　分区的使用  192
6.4.6　桶的使用  193
6.4.7　子查询  194
6.4.8　Hive的优化和高级功能  194
6.5　Hive JDBC编程接口与程序设计  196
第7章　Intel Hadoop系统优化与功能增强  200
7.1　Intel Hadoop系统简介  200
7.1.1　Intel Hadoop系统的主要优化和增强功能  200
7.1.2　Intel Hadoop的系统构成与组件  201
7.2　Intel Hadoop系统的安装和管理  202
7.3　Intel Hadoop HDFS的优化和功能扩展  202
7.3.1　HDFS的高可用性  203
7.3.2　Intel Hadoop系统高可用性配置服务  204
7.3.3　Intel Hadoop系统高可用性配置服务操作  206
7.3.4　自适应数据块副本调整策略  208
7.4　Intel Hadoop HBase的功能扩展和编程示例  211
7.4.1　HBase大对象存储（LOB）  211
7.4.2　加盐表  212
7.4.3　HBase跨数据中心大表  213
7.5　Intel Hadoop Hive的功能扩展和编程示例  216
7.5.1　开源Hive的不足  216
7.5.2　Intel Hadoop“Hive over HBase”优化设计  216
7.5.3　Hive over HBase的架构  216
第二部分　MapReduce的编程和算法设计
第8章　MapReduce基础算法程序设计  220
8.1　WordCount  220
8.1.1　WordCount算法编程实现  220
8.2　矩阵乘法  223
8.2.1　矩阵乘法原理和实现思路  223
8.2.2　矩阵乘法的MapReduce程序实现  224
8.3　关系代数运算  227
8.3.1　选择操作  227
8.3.2　投影操作  228
8.3.3　交运算  229
8.3.4　差运算  230
8.3.5　自然连接  231
8.4　单词共现算法  233
8.4.1　单词共现算法的基本设计  233
8.4.2　单词共现算法的实现  234
8.4.3　单词共现算法实现中的细节问题  235
8.5　文档倒排索引  237
8.5.1　简单的文档倒排索引  237
8.5.2　带词频等属性的文档倒排索引  239
8.6　PageRank网页排名算法  242
8.6.1　PageRank的简化模型  243
8.6.2　PageRank的随机浏览模型  244
8.6.3　PageRank的MapReduce实现  245
8.7　专利文献分析算法  249
8.7.1　构建专利被引用列表  250
8.7.2　专利被引用次数统计  251
8.7.3　专利被引用次数直方图统计  252
8.7.4　按照年份或国家统计专利数  254
第9章　MapReduce高级程序设计技术  256
9.1　简介  256
9.2　复合键值对的使用  257
9.2.1　把小的键值对合并成大的键值对  257
9.2.2　巧用复合键让系统完成排序  259
9.3　用户定制数据类型  262
9.3.1　Hadoop内置的数据类型  263
9.3.2　用户自定义数据类型的实现  263
9.4　用户定制数据输入输出格式  264
9.4.1　Hadoop内置的数据输入格式与RecordReader  265
9.4.2　用户定制数据输入格式与RecordReader  265
9.4.3　Hadoop内置的数据输出格式与RecordWriter  269
9.4.4　用户定制数据输出格式与RecordWriter  269
9.4.5　通过定制数据输出格式实现多集合文件输出  270
9.5　用户定制Partitioner和Combiner  271
9.5.1　用户定制Partitioner  272
9.5.2　用户定制Combiner  273
9.6　组合式MapReduce计算作业  274
9.6.1　迭代MapReduce计算任务  274
9.6.2　顺序组合式MapReduce作业的执行  275
9.6.3　具有复杂依赖关系的组合式MapReduce作业的执行  275
9.6.4　MapReduce前处理和后处理步骤的链式执行  276
9.7　多数据源的连接  278
9.7.1　基本问题数据示例  279
9.7.2　用DataJoin类实现Reduce端连接  279
9.7.3　用全局文件复制方法实现Map端连接  285
9.7.4　带Map端过滤的Reduce端连接  287
9.7.5　多数据源连接解决方法的限制  288
9.8　全局参数/数据文件的传递与使用  288
9.8.1　全局作业参数的传递  288
9.8.2　查询全局的MapReduce作业属性  290
9.8.3　全局数据文件的传递  291
9.9　关系数据库的连接与访问  292
9.9.1　从数据库中输入数据  292
9.9.2　向数据库中输出计算结果  292
第10章　MapReduce数据挖掘基础算法  295
10.1　K-Means聚类算法  295
10.1.1　K-Means聚类算法简介  295
10.1.2　基于MapReduce的K-Means算法的设计实现  297
10.2　KNN最近邻分类算法  300
10.2.1　KNN最近邻分类算法简介  300
10.2.2　基于MapReduce的KNN算法的设计实现  301
10.3　朴素贝叶斯分类算法  303
10.3.1　朴素贝叶斯分类算法简介  303
10.3.2　朴素贝叶斯分类并行化算法的设计  304
10.3.3　朴素贝叶斯分类并行化算法的实现  306
10.4　决策树分类算法  310
10.4.1　决策树分类算法简介  310
10.4.2　决策树并行化算法的设计  313
10.4.3　决策树并行化算法的实现  317
10.5　频繁项集挖掘算法  327
10.5.1　频繁项集挖掘问题描述  327
10.5.2 　Apriori频繁项集挖掘算法简介  328
10.5.3　Apriori频繁项集挖掘并行化算法的设计  329
10.5.4　Apriori频繁项集挖掘并行化算法的实现  331
10.5.5　基于子集求取的频繁项集挖掘算法的设计  335
10.5.6　基于子集求取的频繁项集挖掘并行化算法的实现  336
10.6　隐马尔科夫模型和最大期望算法  340
10.6.1　隐马尔科夫模型的基本描述  340
10.6.2　隐马尔科夫模型问题的解决方法  341
10.6.3　最大期望算法概述  345
10.6.4　并行化隐马尔科夫算法设计  345
10.6.5　隐马尔科夫算法的并行化实现  348
第11章　大数据处理算法设计与应用编程案例  352
11.1　基于MapReduce的搜索引擎算法  352
11.1.1　搜索引擎工作原理简介  353
11.1.2　基于MapReduce的文档预处理  354
11.1.3　基于MapReduce的文档倒排索引构建  356
11.1.4　建立Web信息查询服务  363
11.2　基于MapReduce的大规模短文本多分类算法  365
11.2.1　短文本多分类算法工作原理简介  365
11.2.2　并行化分类训练算法设计实现  366
11.2.3　并行化分类预测算法设计实现  369
11.3　基于MapReduce的大规模基因序列比对算法  371
11.3.1　基因序列比对算法简介  371
11.3.2　并行化BLAST算法的设计与实现  373
11.4　基于MapReduce的大规模城市路径规划算法  379
11.4.1　问题背景和要求  379
11.4.2　数据输入  380
11.4.3　程序设计要求  384
11.4.4　算法设计总体框架和处理过程  385
11.4.5　并行化算法的设计与实现  386
11.5　基于MapReduce的大规模重复文档检测算法  396
11.5.1　重复文档检测问题描述  396
11.5.2　重复文档检测方法和算法设计  397
11.5.3　重复文档检测并行化算法设计实现  401
11.6　基于内容的并行化图像检索算法与引擎  404
11.6.1　基于内容的图像检索问题概述  404
11.6.2　图像检索方法和算法设计思路  405
11.6.3　并行化图像检索算法实现  407
11.7　基于MapReduce的大规模微博传播分析  412
11.7.1　微博分析问题背景与并行化处理过程  413
11.7.2　并行化微博数据获取算法的设计实现  414
11.7.3　并行化微博数据分析算法的设计实现  416
11.8　基于关联规则挖掘的图书推荐算法  422
11.8.1　图书推荐和关联规则挖掘简介  422
11.8.2　图书频繁项集挖掘算法设计与数据获取  423
11.8.3　图书关联规则挖掘并行化算法实现  425
11.9　基于Hadoop的城市智能交通综合应用案例  432
11.9.1　应用案例概述  432
11.9.2　案例一：交通事件检测  433
11.9.3　案例二：交通流统计分析功能  435
11.9.4　案例三：道路旅行时间分析  435
11.9.5　案例四：HBase实时查询  436
11.9.6　案例五：HBase Endpoint快速统计  437
11.9.7　案例六：利用Hive高速统计  439
附　　录
附录A　OpenMP并行程序设计简介  442
附录B　MPI并行程序设计简介  448
附录C　英特尔Apache Hadoop*系统安装手册  457
参考文献  486
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解大数据：大数据处理与编程实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C#企业应用开发艺术
第1章 分布式架构 1
1.1 逻辑和物理架构 1
1.1.1 N层和SOA 3
1.1.2 复杂性 3
1.1.3 逻辑模型和物理模型之间的关系 4
1.1.4 5层逻辑架构 8
1.1.5 应用逻辑框架 12
1.1.6 展望未来 15
1.2 管理业务逻辑 15
1.2.1 可能的业务逻辑位置 16
1.2.2 业务对象 18
1.2.3 移动对象 21
1.3 架构和框架 27
1.4 小结 28
第2章 框架设计 29
2.1 基本设计目标 30
2.1.1 验证规则和业务规则 31
2.1.2 跟踪对象是否改变 32
2.1.3 集成授权 32
2.1.4 子对象的强类型集合 33
2.1.5 多级撤销能力 34
2.1.6 用户界面开发者的简单抽象模型 35
2.1.7 支持数据绑定 40
2.1.8 对象持久性和对象—关系映射 43
2.1.9 自定义身份验证 48
2.2 设计框架 49
2.2.1 创建业务对象 49
2.2.2 多级撤销功能 56
2.2.3 数据绑定支持 58
2.2.4 业务和验证规则 60
2.2.5 数据门户 62
2.2.6 自定义身份验证 74
2.2.7 整合授权 75
2.2.8 辅助类型和类 76
2.3 命名空间组织 79
2.4 小结 80
第3章 面向对象应用程序设计 82
3.1 责任驱动设计 83
3.1.1 用例或基于故事的分析 83
3.1.2 带有责任的对象 83
3.1.3 为用例存在的对象 83
3.1.4 行为的标准化 84
3.2 应用程序需求 84
3.3 对象设计 88
3.3.1 最初的设计 88
3.3.2 修订设计 89
3.3.3 自定义身份验证 99
3.4 使用CSLA.NET 99
3.5 数据库设计 102
3.5.1 创建数据库 103
3.5.2 PTracker数据库 104
3.5.3 Security数据库 112
3.6 小结 113
第4章 CSLA.NET对象构造型 114
4.1 基本术语和对象图的结构 114
4.2 业务对象生命周期 116
4.2.1 对象的创建 117
4.2.2 取得对象 121
4.2.3 更新可编辑的对象 123
4.2.4 销毁和终结对象 128
4.3 业务类结构 130
4.3.1 Serializable或DataContract特性 130
4.3.2 通用区域 132
4.3.3 非公有的默认构造函数 136
4.4 小结 136
第5章 CSLA.NET对象模板 137
5.1 业务类的结构 137
5.1.1 可编辑的根业务对象 137
5.1.2 可编辑的子业务对象 143
5.1.3 可切换的对象 147
5.1.4 可编辑的根集合 150
5.1.5 可编辑的子集合 152
5.1.6 只读的业务对象 153
5.1.7 只读子对象 155
5.1.8 只读集合 156
5.1.9 只读子集合 157
5.1.10 命令对象 158
5.1.11 名称/值列表对象 159
5.1.12 动态可编辑集合 161
5.1.13 动态可编辑根对象 162
5.1.14 条件对象 163
5.2 小结 165
第6章 业务框架实现 166
6.1 CSLA.NET项目结构 167
6.1.1 项目目录结构 167
6.1.2 项目设定 167
6.1.3 项目签名 168
6.1.4 支持本地化 169
6.2 Csla命名空间 170
6.2.1 ApplicationContext 171
6.2.2 BusinessBase 175
6.2.3 BusinessListBase 177
6.2.4 CommandBase 179
6.2.5 CriteriaBase 179
6.2.6 DataPortal 180
6.2.7 EditableRootListBase 180
6.2.8 NameValueListBase 180
6.2.9 PropertyInfo 181
6.2.10 ReadOnlyBase 182
6.2.11 ReadOnlyListBase 183
6.2.12 SingleCriteria 184
6.2.13 SmartDate 184
6.2.14 Utilities 185
6.3 Csla.Core命名空间 185
6.3.1 BusinessBase 186
6.3.2 ExtendedBindingList 186
6.3.3 IBusinessObject接口 187
6.3.4 ICommandObject接口 188
6.3.5 IEditableBusinessObject
接口 188
6.3.6 IEditableCollection接口 188
6.3.7 IReadOnlyObject接口 188
6.3.8 IReadOnlyCollection接口 188
6.3.9 ISavable接口 189
6.3.10 ISmartField接口 189
6.3.11 ISupportUndo接口 190
6.3.12 ITrackStatus接口 190
6.3.13 IUndoableObject接口 190
6.3.14 ObjectCloner类 191
6.3.15 ReadOnlyBindingList 192
6.4 小结 193
第7章 属性声明 194
7.1 声明属性 194
7.1.1 属性声明的选项 196
7.1.2 RegisterProperty和继承 200
7.2 PropertyInfoManager 202
7.3 字段管理器 204
7.3.1 FieldManager属性 204
7.3.2 FieldDataManager类 205
7.4 小结 211
第8章 对象状态管理 212
8.1 对象状态属性 212
8.1.1 ITrackStatus接口 212
8.1.2 IsNew 213
8.1.3 IsSelfDirty 214
8.1.4 IsDirty 217
8.1.5 IsSelfValid 217
8.1.6 IsValid 218
8.1.7 IsSavable 218
8.1.8 IsDeleted 219
8.2 小结 220
第9章 父子关系 221
9.1 可编辑的父对象 221
9.1.1 父子对象之间的交互 222
9.1.2 IParent接口 226
9.1.3 声明Child属性 226
9.2 可编辑的父集合 229
9.3 小结 232
第10章 数据绑定 233
10.1 Windows窗体 233
10.1.1 对象数据绑定 233
10.1.2 集合数据绑定 240
10.1.3 控件和辅助对象 240
10.1.4 与多个根对象协同工作 254
10.2 WPF 255
10.2.1 对象数据绑定 255
10.2.2 集合数据绑定 257
10.2.3 控件和帮助对象 258
10.3 Web窗体 269
10.4 小结 271
第11章 业务和验证规则 272
11.1 规则类型 272
11.2 Csla.Validation命名空间 273
11.2.1 RuleHandler委托 273
11.2.2 RuleArgs类 274
11.2.3 DecoratedRuleArgs类 274
11.2.4 RuleMethod类 275
11.2.5 RuleDescription类 277
11.2.6 ValidationRules类 277
11.2.7 BrokenRule类 283
11.2.8 BrokenRulesCollection类 284
11.2.9 ValidationException 286
11.3 通用验证规则 286
11.4 小结 290
第12章 身份验证和授权 291
12.1 身份验证 291
12.1.1 Csla.ApplicationContext.
User属性 292
12.1.2 Windows身份验证 292
12.1.3 自定义身份验证 293
12.2 授权 297
12.2.1 类型级别授权 297
12.2.2 属性和方法级别的授权 300
12.3 小结 304
第13章 多级撤销 305
13.1 使用撤销 306
13.2 实现撤销 306
13.2.1 ISupportUndo接口 307
13.2.2 NotUndoableAttribute类 308
13.2.3 UndoableBase类 308
13.2.4 BusinessBase类 317
13.2.5 BusinessListBase类 319
13.3 小结 329
第14章 LINQ to CSLA 330
14.1 使用LINQ降低代码量 330
14.2 LINQ to CSLA.NET概览 331
14.2.1 将来自于LINQ to Objects的结果进行绑定 331
14.2.2 索引的LINQ查询 331
14.3 LINQ和投影 331
14.3.1 标识投影和
LinqBindingList＜T＞ 332
14.3.2 理解LinqBindingList 332
14.4 使用CSLA.NET进行索引检索的
概览 333
14.4.1 序列化和索引 334
14.4.2 索引模式 334
14.5 CSLA.NET的IQueryable实现 335
14.5.1 理解表达式树 335
14.5.2 深入探索IQueryProvider 336
14.5.3 LinqBindingList 338
14.6 被索引的LINQ和CSLA.NET 338
14.6.1 管理索引集 338
14.6.2 表达式求值 339
14.6.3 索引对象模型 340
14.7 小结 345
第15章 持久性和数据门户 346
15.1 数据门户设计 346
15.1.1 业务逻辑和数据访问的分离 347
15.1.2 根对象和子对象的统一编码模型 347
15.1.3 通道适配器和消息路由器模式 348
15.1.4 分布式事务支持 352
15.1.5 上下文和位置透明性 353
15.1.6 授权服务调用 356
15.1.7 异步行为 357
15.1.8 对象工厂 357
15.2 基类的支持 358
15.2.1 工厂方法和条件 359
15.2.2 Save方法 361
15.2.3 使用字段管理器更新子对象 364
15.2.4 更新可编辑的集合 365
15.3 反射和动态方法调用 366
15.3.1 MethodCaller类 366
15.3.2 LateBoundObject类 367
15.4 通道适配器 368
15.4.1 RunLocal特性 368
15.4.2 DataPortal类 369
15.4.3 DataPortal＜T＞类 377
15.4.4 IDataPortalServer接口 379
15.4.5 IDataPortalProxy接口 380
15.4.6 LocalProxy类 380
15.4.7 WcfProxy类 381
15.4.8 WcfPortal类 382
15.5 分布式事务支持 383
15.5.1 Transactional特性 383
15.5.2 Csla.Server.DataPortal对象 384
15.5.3 ServicedDataPortal类 387
15.5.4 TransactionalDataPortal类 389
15.6 消息路由器 389
15.6.1 DataPortalSelector类 390
15.6.2 SimpleDataPortal类 391
15.6.3 FactoryDataPortal类 396
15.6.4 FactoryLoader属性 396
15.6.5 ChildDataPortal类 399
15.7 上下文和位置透明性 400
15.7.1 DataPortalContext类 400
15.7.2 DataPortalResult类 403
15.7.3 Csla.Server.DataPortal-
Exception 403
15.8 小结 404
第16章 其他框架特性 405
16.1 使用SmartDate处理日期 406
16.1.1 初始化结构体 408
16.1.2 支持空日期 408
16.1.3 转换函数 409
16.1.4 文本函数 410
16.1.5 日期函数 411
16.1.6 数据库格式 411
16.2 数据访问 412
16.2.1 管理数据库连接和上下文 412
16.2.2 SafeDataReader 417
16.2.3 DataMapper 420
16.3 Windows工作流基础 425
16.3.1 从对象中启动工作流 426
16.3.2 WorkflowManager类 426
16.4 小结 431
第17章 对业务对象的实现 432
17.1 ProjectTracker对象 432
17.2 设置项目 433
17.3 业务类的实现 434
17.3.1 Project 434
17.3.2 ProjectResources 443
17.3.3 ProjectResource 445
17.3.4 Assignment 447
17.3.5 RoleList 448
17.3.6 Resource和相关的对象 449
17.3.7 ProjectList和ResourceList 450
17.3.8 Roles 451
17.3.9 Role 453
17.3.10 实现Exists方法 455
17.4 自定义身份验证 455
17.4.1 PTPrincipal 455
17.4.2 PTIdentity 457
17.5 小结 458
第18章 数据访问的示例 459
18.1 数据访问层设计 459
18.1.1 数据访问模型 459
18.1.2 平衡设计问题 465
18.2 数据访问对象 467
18.2.1 使用LINQ to SQL 467
18.2.2 ProjectTracker.DalLinq项目 468
18.3 业务类的实现 469
18.3.1 Project 470
18.3.2 ProjectResources 478
18.3.3 ProjectResource 479
18.3.4 RoleList 482
18.3.5 ProjectList和ResourceList 484
18.3.6 Roles 485
18.3.7 实现Exists方法 487
18.4 小结 488
第19章 WPF用户界面 490
19.1 WPF中的自定义身份验证 490
19.2 界面设计 491
19.2.1 用户控件框架 492
19.2.2 值转换器 496
19.2.3 应用程序配置 498
19.2.4 PTWpf项目设定 501
19.2.5 MainForm窗口 501
19.2.6 登录窗口 504
19.2.7 RolesEdit窗体 505
19.2.8 ResourceList窗体 512
19.2.9 ProjectList窗体 513
19.2.10 ProjectEdit窗体 514
19.3 小结 517
第20章 Web窗体用户界面 518
20.1 Web开发和对象 518
20.2 状态管理 520
20.2.1 将状态存储在Web服务器上 521
20.2.2 将状态传送到客户端，或从
客户端传回 523
20.2.3 状态在文件或者数据库中 523
20.3 界面设计 524
20.3.1 应用程序配置 526
20.3.2 PTWeb站点设置 529
20.3.3 母版页 530
20.3.4 登录页面 534
20.4 业务功能 540
20.4.1 RolesEdit窗体 540
20.4.2 ProjectList窗体 549
20.4.3 ProjectEdit窗体 552
20.5 小结 562
第21章 WCF服务界面 564
21.1 客户端/服务器还是SOA 564
21.2 WCF服务概览 565
21.2.1 WCF服务的元素 566
21.2.2 自定义身份验证 572
21.3 设计WCF服务界面 585
21.3.1 服务设计 586
21.3.2 应用程序配置 586
21.3.3 PTWcfService站点设置 588
21.3.4 服务契约和实现 589
21.4 Web服务消费应用程序实现 594
21.4.1 生成WCF信息页面 594
21.4.2 简单的智能客户端 595
21.5 小结 599
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C#企业应用开发艺术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计原本
I Models of Designing  1
Chapter 1  The Design Question（新增评注19条）  3
Chapter 2  How Engineers Think of Design—The Rational Model（新增评注10条）  13
Chapter 3  What’s Wrong with This Model?（新增评注29条）  21
Chapter 4  Requirements, Sin, and Contracts（新增评注12条）  39
Chapter 5  What Are Better Design Process Models?（新增评注13条）  51
II Collaboration and Telecollaboration（新增评注1条）  61
Chapter 6  Collaboration in Design（新增评注42条）  63
Chapter 7  Telecollaboration（新增评注16条）  89
III Design Perspectives  103
Chapter 8  Rationalism versus Empiricism in Design（新增评注11条）  105
Chapter 9  User Models—Better Wrong than Vague（新增评注8条）  113
Chapter 10  Inches, Ounces, Bits, Dollars—The Budgeted Resource（新增评注10条）  119
Chapter 11  Constraints Are Friends（新增评注16条）  127
Chapter 12  Esthetics and Style in Technical Design（新增评注26条）  139
Chapter 13  Exemplars in Design（新增评注26条）  153
Chapter 14  How Expert Designers Go Wrong（新增评注18条）  167
Chapter 15  The Divorce of Design（新增评注13条）  175
Chapter 16  Representing Designs’ Trajectories and Rationales（新增评注28条）  185
IV  A Computer Scientist’s Dream System for Designing Houses  201
Chapter 17  A Computer Scientist’s Dream System for Designing Houses—Mind to Machine（新增评注35条）  203
Chapter 18  A Computer Scientist’s Dream System for Designing Houses—Machine to Mind（新增评注17条）  219
V  Great Designers  229
Chapter 19  Great Designs Come from Great Designers（新增评注27条）  231
Chapter 20  Where Do Great Designers Come From?（新增评注28条）  243
VI  Trips through Design Spaces: Case Studies（新增评注1条）  257
Chapter 21  Case Study: Beach House “View/360”（新增评注19条）  259
Chapter 22  Case Study: House Wing Addition（新增评注14条）  279
Chapter 23  Case Study: Kitchen Remodeling（新增评注10条）  297
Chapter 24  Case Study: System/360 Architecture（新增评注18条）  313
Chapter 25  Case Study: IBM Operating System/360（新增评注14条）  331
Chapter 26  Case Study: Book Design of Computer Architecture: Concepts and Evolution（新增评注7条）  347
Chapter 27  Case Study: A Joint Computer Center Organization: Triangle Universities Computation Center（新增评注11条）  355
Chapter 28  Recommended Reading（新增评注8条）  367
Acknowledgments  371
Bibliography  375
People Index  393
Subject Index  401
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计原本
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring攻略
第1章 Spring简介
1.1 实例化Spring IoC容器
1.1.1 问题
1.1.2 解决方案
1.1.3 工作原理
1.2 配置Spring IoC容器中的Bean
1.2.1 问题
1.2.2 解决方案
1.2.3 工作原理
1.3 调用构造程序创建Bean
1.3.1 问题
1.3.2 解决方案
1.3.3 工作原理
1.4 解决构造程序歧义
1.4.1 问题
1.4.2 解决方案
1.4.3 工作原理
1.5 指定Bean引用
1.5.1 问题
1.5.2 解决方案
1.5.3 工作原理
1.6 为集合元素指定数据类型
1.6.1 问题
1.6.2 解决方案
1.6.3 工作原理
1.7 使用Spring的FactoryBean创建Bean
1.7.1 问题
1.7.2 解决方案
1.7.3 工作原理
1.8 使用工厂Bean和Utility Schema定义集合
1.8.1 问题
1.8.2 解决方案
1.8.3 工作原理
1.9 用依赖检查属性
1.9.1 问题
1.9.2 解决方案
1.9.3 工作原理
1.10 用@Required注解检查属性
1.10.1 问题
1.10.2 解决方案
1.10.3 工作原理
1.11 用XML配置自动装配Bean
1.11.1 问题
1.11.2 解决方案
1.11.3 工作原理
1.12 用@Autowired和@Resource自动装配Bean
1.12.1 问题
1.12.2 解决方案
1.12.3 工作原理
1.13 继承Bean配置
1.13.1 问题
1.13.2 解决方案
1.13.3 工作原理
1.14 从Classpath中扫描组件
1.14.1 问题
1.14.2 解决方案
1.14.3 工作原理
1.15 小结
第2章 高级Spring IoC容器
2.1 调用静态工厂方法创建Bean
2.1.1 问题
2.1.2 解决方案
2.1.3 工作原理
2.2 调用一个实例工厂方法创建Bean
2.2.1 问题
2.2.2 解决方案
2.2.3 工作原理
2.3 从静态字段中声明Bean
2.3.1 问题
2.3.2 解决方案
2.3.3 工作原理
2.4 从对象属性中声明Bean
2.4.1 问题
2.4.2 解决方案
2.4.3 工作原理
2.5 使用Spring表达式语言
2.5.1 问题
2.5.2 解决方案
2.5.3 工作原理
2.6 设置Bean作用域
2.6.1 问题
2.6.2 解决方案
2.6.3 工作原理
2.7 自定义Bean初始化和析构
2.7.1 问题
2.7.2 解决方案
2.7.3 工作原理
2.8 用Java Config简化XML配置
2.8.1 问题
2.8.2 解决方案
2.8.3 工作原理
2.9 使Bean感知容器
2.9.1 问题
2.9.2 解决方案
2.9.3 工作原理
2.10 加载外部资源
2.10.1 问题
2.10.2 解决方案
2.10.3 工作原理
2.11 创建Bean后处理器
2.11.1 问题
2.11.2 解决方案
2.11.3 工作原理
2.12 外部化Bean配置
2.12.1 问题
2.12.2 解决方案
2.12.3 工作原理
2.13 解析文本消息
2.13.1 问题
2.13.2 解决方案
2.13.3 工作原理
2.14 使用应用事件进行通信
2.14.1 问题
2.14.2 解决方案
2.14.3 工作原理
2.15 在Spring中注册属性编辑器
2.15.1 问题
2.15.2 解决方案
2.15.3 工作原理
2.16 创建自定义属性编辑器
2.16.1 问题
2.16.2 解决方案
2.16.3 工作原理
2.17 使用TaskExecutor实现并发性
2.17.1 问题
2.17.2 解决方案
2.17.3 工作原理
2.18 小结
第3章 Spring AOP和AspectJ支持
3.1 启用Spring的AspectJ注解支持
3.1.1 问题
3.1.2 解决方案
3.1.3 工作原理
3.2 用AspectJ注解声明aspect
3.2.1 问题
3.2.2 解决方案
3.2.3 工作原理
3.3 访问连接点信息
3.3.1 问题
3.3.2 解决方案
3.3.3 工作原理
3.4 指定aspect优先级
3.4.1 问题
3.4.2 解决方案
3.4.3 工作原理
3.5 重用切入点定义
3.5.1 问题
3.5.2 解决方案
3.5.3 工作原理
3.6 编写AspectJ切入点表达式
3.6.1 问题
3.6.2 解决方案
3.6.3 工作原理
3.7 在你的Bean中引入行为
3.7.1 问题
3.7.2 解决方案
3.7.3 工作原理
3.8 为你的Bean引入状态
3.8.1 问题
3.8.2 解决方案
3.8.3 工作原理
3.9 用基于XML的配置声明aspect
3.9.1 问题
3.9.2 解决方案
3.9.3 工作原理
3.10 Spring中的AspectJ加载时织入aspect
3.10.1 问题
3.10.2 解决方案
3.10.3 工作原理
3.11 在Spring中配置AspectJ aspect
3.11.1 问题
3.11.2 解决方案
3.11.3 工作原理
3.12 将Spring Bean注入领域对象
3.12.1 问题
3.12.2 解决方案
3.12.3 工作原理
3.13 小结
第4章 Spring中的脚本
4.1 用脚本语言实现Bean
4.1.1 问题
4.1.2 解决方案
4.1.3 工作原理
4.2 将Spring Bean注入脚本中
4.2.1 问题
4.2.2 解决方案
4.2.3 工作原理
4.3 从脚本中刷新Bean
4.3.1 问题
4.3.2 解决方案
4.3.3 工作原理
4.4 定义内联脚本源码
4.4.1 问题
4.4.2 解决方案
4.4.3 工作原理
4.5 小结
第5章 Spring Security
5.1 加强URL访问安全
5.1.1 问题
5.1.2 解决方案
5.1.3 工作原理
5.2 登录到Web应用
5.2.1 问题
5.2.2 解决方案
5.2.3 工作原理
5.3 验证用户
5.3.1 问题
5.3.2 解决方案
5.3.3 工作原理
5.4 做出访问控制决策
5.4.1 问题
5.4.2 解决方案
5.4.3 工作原理
5.5 加强方法调用的安全
5.5.1 问题
5.5.2 解决方案
5.5.3 工作原理
5.6 处理视图中的安全性
5.6.1 问题
5.6.2 解决方案
5.6.3 工作原理
5.7 处理领域对象安全性
5.7.1 问题
5.7.2 解决方案
5.7.3 工作原理
5.8 小结
第6章 将Spring与其他Web框架集成
6.1 在一般Web应用中访问Spring
6.1.1 问题
6.1.2 解决方案
6.1.3 工作原理
6.2 在你的Servlet和过滤器中使用Spring
6.2.1 问题
6.2.2 解决方案
6.2.3 工作原理
6.3 将Spring与Struts 1.x集成
6.3.1 问题
6.3.2 解决方案
6.3.3 工作原理
6.4 将Spring与JSF集成
6.4.1 问题
6.4.2 解决方案
6.4.3 工作原理
6.5 将Spring与DWR集成
6.5.1 问题
6.5.2 解决方案
6.5.3 工作原理
6.6 小结
第7章 Spring Web Flow
7.1 用Spring Web Flow管理简单的UI流程
7.1.1 问题
7.1.2 解决方案
7.1.3 工作原理
7.2 用不同状态类型建立Web流程模型
7.2.1 问题
7.2.2 解决方案
7.2.3 工作原理
7.3 加强Web流程安全
7.3.1 问题
7.3.2 解决方案
7.3.3 工作原理
7.4 持续存储Web流程中的对象
7.4.1 问题
7.4.2 解决方案
7.4.3 工作原理
7.5 将Spring Web Flow与JSF集成
7.5.1 问题
7.5.2 解决方案
7.5.3 工作原理
7.6 使用RichFaces与Spring WebFlow协作
7.6.1 问题
7.6.2 解决方案
7.6.3 方法
7.7 小结
第8章 Spring @MVC
8.1 用Spring MVC开发简单的Web应用
8.1.1 问题
8.1.2 解决方案
8.1.3 工作原理
8.2 用@RequestMapping映射请求
8.2.1 问题
8.2.2 解决方案
8.2.3 工作原理
8.3 用处理程序拦截器拦截请求
8.3.1 问题
8.3.2 解决方案
8.3.3 工作原理
8.4 解析用户区域
8.4.1 问题
8.4.2 解决方案
8.4.3 工作原理
8.5 外部化区分区域的文本信息
8.5.1 问题
8.5.2 解决方案
8.5.3 工作原理
8.6 按照名称解析视图
8.6.1 问题
8.6.2 解决方案
8.6.3 工作原理
8.7 视图和内容协商
8.7.1 问题
8.7.2 解决方案
8.7.3 工作原理
8.8 映射异常视图
8.8.1 问题
8.8.2 解决方案
8.8.3 工作原理
8.9 用@Value在控制器中赋值
8.9.1 问题
8.9.2 解决方案
8.9.3 工作原理
8.10 用控制器处理表单
8.10.1 问题
8.10.2 解决方案
8.10.3 工作原理
8.11 用向导表单控制器处理多页表单
8.11.1 问题
8.11.2 解决方案
8.11.3 工作原理
8.12 使用注解(JSR-303)的Bean校验
8.12.1 问题
8.12.2 解决方案
8.12.3 工作原理
8.13 创建Excel和PDF视图
8.13.1 问题
8.13.2 解决方案
8.13.3 工作原理
8.14 小结
第9章 Spring REST
9.1 用Spring发布一个REST服务
9.1.1 问题
9.1.2 解决方案
9.1.3 工作原理
9.2 用Spring访问REST服务
9.2.1 问题
9.2.2 解决方案
9.2.3 工作原理
9.3 发布RSS和Atom信息源
9.3.1 问题
9.3.2 解决方案
9.3.3 工作原理
9.4 用REST服务发布JSON
9.4.1 问题
9.4.2 解决方案
9.4.3 工作原理
9.5 访问具有复杂XML响应的REST服务
9.5.1 问题
9.5.2 解决方案
9.5.3 工作原理
9.6 小结
第10章 Spring和Flex
10.1 Flex入门
10.1.1 问题
10.1.2 解决方案
10.1.3 工作原理
10.2 离开沙箱
10.2.1 问题
10.2.2 解决方案
10.2.3 工作原理
10.3 为应用添加Spring BlazeDS支持
10.3.1 问题
10.3.2 解决方案
10.3.3 工作原理
10.4 通过BlazeDS/Spring暴露服务
10.4.1 问题
10.4.2 解决方案
10.4.3 工作原理
10.5 使用服务器端对象
10.5.1 问题
10.5.2 解决方案
10.5.3 工作原理
10.6 使用BlazeDS和Spring消费面向消息的服务
10.6.1 问题
10.6.2 解决方案
10.6.3 工作原理
10.7 将依赖注入带给你的ActionScript客户
10.7.1 问题
10.7.2 解决方案
10.7.3 工作原理
10.8 小结
第11章 Grails
11.1 获取和安装Grails
11.1.1 问题
11.1.2 解决方案
11.1.3 工作原理
11.2 创建Grails应用
11.2.1 问题
11.2.2 解决方案
11.2.3 工作原理
11.3 Grails插件
11.3.1 问题
11.3.2 解决方案
11.3.3 工作原理
11.4 在Grails环境中开发、生产和测试
11.4.1 问题
11.4.2 解决方案
11.4.3 工作原理
11.5 创建应用的领域类
11.5.1 问题
11.5.2 解决方案
11.5.3 工作原理
11.6 为一个应用的领域类生成CRUD控制器和视图
11.6.1 问题
11.6.2 解决方案
11.6.3 工作原理
11.7 国际化(I18n)信息属性
11.7.1 问题
11.7.2 解决方案
11.7.3 工作原理
11.8 改变永久性存储系统
11.8.1 问题
11.8.2 解决方案
11.4.3 工作原理
11.9 日志
11.9.1 问题
11.9.2 解决方案
11.9.3 工作原理
11.10 运行单元和集成测试
11.10.1 问题
11.10.2 解决方案
11.10.3 工作原理
11.11 使用自定义布局和模板
11.11.1 问题
11.11.2 解决方案
11.11.3 工作原理
11.12 使用GORM查询
11.12.1 问题
11.12.2 解决方案
11.12.3 工作原理
11.13 创建自定义标记
11.13.1 问题
11.13.2 解决方案
11.13.3 工作原理
11.14 小结
第12章 Spring Roo
12.1 设置Spring Roo开发环境
12.1.1 问题
12.1.2 解决方案
12.1.3 工作原理
12.2 创建第一个Spring Roo项目
12.2.1 问题
12.2.2 解决方案
12.2.3 工作原理
12.3 把现有项目导入SpringSource Tool Suite
12.3.1 问题
12.3.2 解决方案
12.3.3 工作原理
12.4 更快地构建更好的应用程序
12.4.1 问题
12.4.2 解决方案
12.4.3 工作原理
12.5 从项目中删除Spring Roo
12.5.1 问题
12.5.2 解决方案
12.5.3 工作原理
12.6 小结
第13章 Spring测试
13.1 用JUnit and TestNG创建测试
13.1.1 问题
13.1.2 解决方案
13.1.3 工作原理
13.2 创建单元测试和集成测试
13.2.1 问题
13.2.2 解决方案
13.2.3 工作原理
13.3 Spring MVC控制器的单元测试
13.3.1 问题
13.3.2 解决方案
13.3.3 工作原理
13.4 管理集成测试中的应用上下文
13.4.1 问题
13.4.2 解决方案
13.4.3 工作原理
13.5 向集成测试注入测试夹具
13.5.1 问题
13.5.2 解决方案
13.5.3 工作原理
13.6 管理集成测试中的事务
13.6.1 问题
13.6.2 解决方案
13.6.3 工作原理
13.7 在集成测试中访问数据库
13.7.1 问题
13.7.2 解决方案
13.7.3 工作原理
13.8 使用Spring的常用测试注解
13.8.1 问题
13.8.2 解决方案
13.8.3 工作原理
13.9 小结
第14章 Spring Portlet MVC框架
14.1 用Spring Portlet MVC开发一个简单的Portlet
14.1.1 问题
14.1.2 解决方案
14.1.3 工作原理
14.2 将Portlet请求映射到处理程序
14.2.1 问题
14.2.2 解决方案
14.2.3 工作原理
14.3 用简单的表单控制器处理portlet表单
14.3.1 问题
14.3.2 解决方案
14.3.3 工作原理
14.4 小结
第15章 数据访问
15.1 Direct JDBC的问题
15.1.1 建立应用数据库
15.1.2 理解数据访问对象设计模式
15.1.3 用JDBC实现DAO
15.1.4 在Spring中配置数据源
15.1.5 运行DAO
15.1.6 更进一步
15.2 使用JDBC模板更新数据库
15.2.1 问题
15.2.2 解决方案
15.2.3 工作原理
15.3 使用JDBC模板查询数据库
15.3.1 问题
15.3.2 解决方案
15.3.3 工作原理
15.4 简化JDBC模板创建
15.4.1 问题
15.4.2 解决方案
15.4.3 工作原理
15.5 在Java 1.5中使用简单的JDBC模板
15.5.1 问题
15.5.2 解决方案
15.5.3 工作原理
15.6 在JDBC模板中使用命名参数
15.6.1 问题
15.6.2 解决方案
15.6.3 工作原理
15.7 在Spring JDBC框架中处理异常
15.7.1 问题
15.7.2 解决方案
15.7.3 工作原理
15.8 直接使用ORM框架的问题
15.8.1 问题
15.8.2 解决方案
15.8.3 工作原理
15.8.4 使用Hibernate API，用Hibernate XML映射持续化对象
15.8.5 使用Hibernate API，以JPA注解持续化对象
15.8.6 使用JPA，以Hibernate为引擎持续化对象
15.9 在Spring中配置ORM资源工厂
15.9.1 问题
15.9.2 解决方案
15.9.3 工作原理
15.10 用Spring ORM模板持续化对象
15.10.1 问题
15.10.2 解决方案
15.10.3 工作原理
15.11 用Hibernate的上下文会话持续化对象
15.11.1 问题
15.11.2 解决方案
15.11.3 工作原理
15.12 用JPA的上下文注入持续化对象
15.12.1 问题
15.12.2 解决方案
15.12.3 工作原理
15.13 小结
第16章 Spring中的事务管理
16.1 事务管理的问题
16.2 选择一个事务管理器实现
16.2.1 问题
16.2.2 解决方案
16.2.3 工作原理
16.3 用事务管理器API编程管理事务
16.3.1 问题
16.3.2 解决方案
16.3.3 工作原理
16.4 用事务模板编程管理事务
16.4.1 问题
16.4.2 解决方案
16.4.3 工作原理
16.5 用事务通知声明式地管理事务
16.5.1 问题
16.5.2 解决方案
16.5.3 工作原理
16.6 用@Transactional注解声明式地管理事务
16.6.1 方法
16.6.2 解决方案
16.6.3 工作原理
16.7 设置事务传播属性
16.7.1 问题
16.7.2 解决方案
16.7.3 工作原理
16.8 设置隔离事务属性
16.8.1 问题
16.8.2 解决方案
16.8.3 工作原理
16.9 设置Rollback事务属性
16.9.1 问题
16.9.2 解决方案
16.9.3 工作原理
16.10 设置超时和只读事务属性
16.10.1 问题
16.10.2 解决方案
16.10.3 工作原理
16.11 用加载时织入管理事务
16.11.1 问题
16.11.2 解决方案
16.11.3 工作原理
16.12 小结
第17章 EJB、Spring Remoting和Web服务
17.1 通过RMI暴露和调用服务
17.1.1 问题
17.1.2 解决方案
17.1.3 工作原理
17.2 用Spring创建EJB 2.x组件
17.2.1 问题
17.2.2 解决方案
17.2.3 工作原理
17.3 在Spring中访问遗留的EJB 2.x组件
17.3.1 问题
17.3.2 解决方案
17.3.3 工作原理
17.4 在Spring中创建EJB 3.0组件
17.4.1 问题
17.4.2 解决方案
17.4.3 工作原理
17.5 在Spring中访问EJB 3.0组件
17.5.1 问题
17.5.2 解决方案
17.5.3 工作原理
17.6 通过HTTP暴露和调用服务
17.6.1 问题
17.6.2 解决方案
17.6.3 工作原理
17.7 选择SOAP Web服务开发方法
17.7.1 问题
17.7.2 解决方案
17.7.3 工作原理
17.8 使用JAX-WS暴露和调用Contract-Last SOAP Web服务
17.8.1 问题
17.8.2 解决方案
17.8.3 工作原理
17.9 定义Web服务契约
17.9.1 问题
17.9.2 解决方案
17.9.3 工作原理
17.10 使用Spring-WS实现Web服务
17.10.1 问题
17.10.2 解决方案
17.10.3 工作原理
17.11 使用Spring-WS调用Web服务
17.11.1 问题
17.11.2 解决方案
17.11.3 工作原理
17.12 用XML编组开发Web服务
17.12.1 问题
17.12.2 解决方案
17.12.3 工作原理
17.13 用注解创建服务端点
17.13.1 问题
17.13.2 解决方案
17.13.3 工作原理
17.14 小结
第18章 企业中的Spring
18.1 将Spring Bean输出为JMX MBean
18.1.1 问题
18.1.2 解决方案
18.1.3 工作原理
18.2 发布和监听JMX通知
18.2.1 问题
18.2.2 解决方案
18.2.3 工作原理
18.3 在Spring中访问远程JMX MBean
18.3.1 问题
18.3.2 解决方案
18.3.3 工作原理
18.4 用Spring电子邮件支持发送邮件
18.4.1 问题
18.4.2 解决方案
18.4.3 工作原理
18.5 用Spring的Quartz支持进行调度
18.5.1 问题
18.5.2 解决方案
18.5.3 工作原理
18.6 用Spring 3.0的调度命名空间进行调度
18.6.1 问题
18.6.2 解决方案
18.6.3 工作原理
18.7 小结
第19章 消息
19.1 用Spring发送和接收JMS消息
19.1.1 问题
19.1.2 解决方案
19.1.3 工作原理
19.2 转换JMS消息
19.2.1 问题
19.2.2 解决方案
19.2.3 方法
19.3 管理JMS事务
19.3.1 问题
19.3.2 方法
19.3.3 解决方案
19.4 在Spring中创建消息驱动POJO
19.4.1 问题
19.4.2 解决方案
19.4.3 工作原理
19.5 建立连接
19.5.1 问题
19.5.2 解决方案
19.5.3 工作原理
19.6 小结
第20章 Spring Integration
20.1 用EAI集成一个系统到另一个系统
20.1.1 问题
20.1.2 解决方案
20.1.3 工作原理
20.2 使用JMS集成两个系统
20.2.1 问题
20.2.2 解决方案
20.2.3 工作原理
20.3 查询Spring Integration消息得到上下文信息
20.3.1 问题
20.3.2 解决方案
20.3.3 工作原理
20.4 用一个文件系统集成两个系统
20.4.1 问题
20.4.2 解决方案
20.4.3 工作原理
20.5 将消息从一种类型转换为另一种类型
20.5.1 问题
20.5.2 解决方案
20.5.3 工作原理
20.6 使用Spring Integration进行错误处理
20.6.1 问题
20.6.2 解决方案
20.6.3 工作原理
20.7 集成控制分支：分解器和聚合器
20.7.1 问题
20.7.2 解决方案
20.7.3 工作原理
20.8 用路由器实现条件路由
20.8.1 问题
20.8.2 解决方案
20.8.3 工作原理
20.9 使外部系统适应总线
20.9.1 问题
20.9.2 解决方案
20.9.3 工作原理
20.10 用Spring Batch产生事件
20.10.1 问题
20.10.2 解决方案
20.10.3 工作原理
20.11 使用网关
20.11.1 问题
20.11.2 解决方案
20.11.3 工作原理
20.12 小结
第21章 Spring Batch
21.1 建立Spring Batch的基础架构
21.1.1 问题
21.1.2 解决方案
21.1.3 工作原理
21.2 读取和写入(无计算)
21.2.1 问题
21.2.2 解决方案
21.2.3 工作原理
21.3 编写自定义ItemWriter和ItemReader
21.3.1 问题
21.3.2 解决方案
21.3.3 工作原理
21.4 在写入前处理输入
21.4.1 问题
21.4.2 解决方案
21.4.3 工作原理
21.5 通过事务改善生活
21.5.1 问题
21.5.2 解决方案
21.5.3 工作原理
21.6 重试
21.6.1 问题
21.6.2 解决方案
21.6.3 工作原理
21.7 控制步骤异常
21.7.1 问题
21.7.2 解决方案
21.7.3 工作原理
21.8 启动一个作业
21.8.1 问题
21.8.2 解决方案
21.8.3 工作原理
21.9 参数化一个作业
21.9.1 问题
21.9.2 解决方案
21.9.3 工作原理
21.10 小结
第22章 网格上的Spring
22.1 使用Terracotta聚合对象状态
22.1.1 问题
22.1.2 解决方案
22.1.3 工作原理
22.2 将执行分布到网格上
22.2.1 问题
22.2.2 解决方案
22.2.3 方法
22.3 方法的负载平衡
22.3.1 问题
22.3.2 解决方案
22.3.3 方法
22.4 并行处理
22.4.1 问题
22.4.2 解决方案
22.4.3 方法
22.5 在GridGain上部署
22.5.1 问题
22.5.2 解决方案
22.5.3 工作原理
22.6 小结
第23章 jBPM和Spring
软件过程
23.1 理解工作流模型
23.1.1 问题
23.1.2 解决方案
23.1.3 工作原理
23.2 安装jBPM
23.2.1 问题
23.2.2 解决方案
23.2.3 工作原理
23.3 将jBPM4与Spring整合
23.3.1 问题
23.3.2 解决方案
23.3.3 工作原理
23.4 用Spring构建一个服务
23.4.1 问题
23.4.2 解决方案
23.4.3 工作原理
23.5 构建业务过程
23.5.1 问题
23.5.2 解决方案
23.5.3 工作原理
23.6 小结
第24章 OSGi和Spring
24.1 OSGi入门
24.1.1 问题
24.1.2 解决方案
24.1.3 工作原理
24.2 开始使用Spring Dynamic Modules
24.2.1 问题
24.2.2 解决方案
24.2.3 工作原理
24.3 用Spring Dynamic Modules输出服务
24.3.1 问题
24.3.2 解决方案
24.3.3 工作原理
24.4 在OSGi注册表中寻找一个具体服务
24.4.1 问题
24.4.2 解决方案
24.4.3 工作原理
24.5 发布多个接口的一个服务
24.5.1 问题
24.5.2 解决方案
24.5.3 工作原理
24.6 定制Spring Dynamic Modules
24.6.1 问题
24.6.2 解决方案
24.6.3 工作原理
24.7 使用SpringSource dm Server
24.7.1 问题
24.7.2 解决方案
24.7.3 工作原理
24.8 SpringSource的各类工具
24.8.1 问题
24.8.2 解决方案
24.8.3 工作原理
24.9 小结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring攻略
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Framework的设计与应用
第1章 设计模式与开发模式
第2章 .NET Framework 2.0概论
第3章 ADO.NET 2.0
第4章 Windows Forms
第5章 .NET Remoting
第6章 Framework架构
第7章 Configuration Framework
第8章 Plug-ln Framework
第9章 Cache Framework
第10章 Business Logic Framework
第11章 Factory Framework
第12章 Data Connection Framework
第13章 Settings Framework
第14章 设计Domain Application Framework
第15章 来实现吧，小型进销存系统
第16章 UI的设计
第17章 报表
第18章 回顾与展望
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Framework的设计与应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件体系结构
第1章  绪论  1.1  什么是软件体系结构       软件设计层次  1.2  软件体系结构研究的内容和范畴    1.2.1  体系结构研究领域    1.2.2  风格、设计模式、框架  1.3  体系结构设计原则  1.4  软件体系结构研究的现状  1.5  全书的安排第2章  体系结构风格  2.1  体系结构风格  2.2  管道过滤器  2.3  数据抽象和面向对象组织结构  2.4  事件驱动,隐式调用  2.5  分层系统  2.6  知识库  2.7  解释器  2.8  过程控制    2.8.1  过程控制范例    2.8.2  过程控制软件范例  2.9  其他常见的体系结构  2.10  异构体系结构  2.10  异构体系结构第3章  案例研究  3.1  上下文关键字    3.1.1  解决方案1：使用共享数据的主程序/子程序    3.1.2  解决方案2：抽象数据类型    3.1.3  解决方案3：隐式调用    3.1.4  解决方案4：管道过滤器    3.1.5  各种方案的比较  3.2  仪器软件    3.2.1  面向对象模型    3.2.2  分层模型    3.2.3  管道过滤器模型    3.2.4  改进后的管道过滤器秩型    3.2.5  专用化模型    3.2.6总结  3.3  移动机器人    3.3.1  设计考虑因素    3.3.2  解决方案1：控制环路    3.3.3  解决方案2：分层体系结构    3.3.4  解决方案3：隐式调用    3.3.5  解决方案4：黑板体系结构    3.3.6  各种方案的比较  3.4  定速巡航控制    3.4.1  定速巡航控制的面向对象观点    3.4.2  定速巡航控制的过程控制观点    3.4.3  分析和讨论    3.4.4总结  3.5  复合混合风格的三个案例    3.5.1  具有多种风格的分层设计    3.5.2  使用不同构件风格的解释器    3.5.3  一个黑板风格的解释器第4章  共享信息系统  4.1  共享信息系统概述  4.2  数据库集成    4.2.1  批序列    4.2.2  简单知识库(Repository)    4.2.3  虚拟知识库    4.2.4  多级分层结构    4.2.5  业务数据处理的共享信息系统的演刊  4.3  软件开发环境集成    4.3.1  批序列    4，3.2  从批序列到知识库的转化    4.3.3  知识库    4.3.4  多级分层结构    4.3.5  软件开发环境的共享信息系统的演仙  4.4  建筑设计集成     4.4.1  知识库    4.4.2  智能控制    4.4.3  建筑设计的共享信息系统的演化  4.5  共享信息系统的体系结构    4.5.1  各种数据流系统的比较    4.5.2  各种知识库系统的比较  4.6  结论第5章  软件体系结构描述  5.1  综述       IEEE软件体系结构描述框架标准  5.2  体系结构描述语言(ADL)    5.2.1  典型的软件体系结构描述语言简介  5.3  体系结构形式化模型和规格说明    5.3.1  体系结构形式化的价值    5.3.2  形式化一个特殊系统的体系结构    5.3.3  形式化体系结构风格    5.3.4  Z标记形式化描述语言  5.4  使用UML描述体系结构第6章  软件体系结构的分析与评估  6.1  体系结构评估概述  6.2  体系结构评估方法  6.3  体系结构权衡分析方法(ATAM)    6.3.1  ATAM评估步骤    6.3.2  ATAM评估工具  6.4  软件体系结构分析方法(SAAM)    6.4.1  SAAM评估步骤    6.4.2  SAAM评估工具第7章  特定领域的软件体系结构  7.1  特定领域的软件体系结构概述    7.1.1  特定领域的软件体系结构的定义    7.1.2  DSSA的组成  7.2  研究DSSA及其开发方法的意义  7.3  DSSA的螺旋型演化过程  7.4  基于DSSA的软件开发    7.4.1  DSSA的建模    7.4.2  基于DSSA的开发流程  7.5  基于DSSA的DRICSM系统建模    7.5.1  面向DRICSM的领域模型概述    7.5.2  开发DRICSM系统的特征    7.5.3  DRICSMSA的体系结构模型第8章  流行的软件体系结构  8.1  概述  8.2  基于CORBA的分布式构件技术  8.3  基于Java的分布式构件技术  8.4  基于.NET平台的分布式构件技术  8.5  面向服务的体系结构    8.5.1  什么是面向服务的体系结构    8.5.2  基于Web服务的SOA实现参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件体系结构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>领域驱动设计C# 2008实现
第1章 介绍项目：SmartGA系统　1.1 问题　1.2 设计　　1.2.1 可靠性和可得性　　1.2.2 伸缩性　　1.2.3 可维护性　　1.2.4 富客户应用功能　　1.2.5 离线可得　　1.2.6 Web访问　　1.2.7 智能安装和自动更新功能　　1.2.8 附加客户设备支持　1.3 解决方案　　1.3.1 满足可靠性、可得性、伸缩性、离线可得和附加客户设备支持需求　　1.3.2 满足可维护性需求　　1.3.3 满足富客户应用功能需求　　1.3.4 满足Web访问需求　　1.3.5 满足智能安装和自动更新功能需求　1.4 总结第2章 设计分层架构　2.1 问题　2.2 设计　　2.2.1 设计Visual Studio解决方案　　2.2.2 设计基础设施层　2.3 解决方案　　2.3.1 实现Visual Studio解决方案　　2.3.2 实现架构层　2.4 总结第3章 管理项目　3.1 问题　3.2 设计　　3.2.1 设计领域模型　　3.2.2 定义项目聚合　　3.2.3 定义聚合边界　　3.2.4 设计仓储　　3.2.5 编写单元测试　3.3 解决方案　　3.3.1 Project类　　3.3.2 实现仓储　　3.3.3 实现服务类　　3.3.4 实现项目信息视图模型　　3.3.5 实现项目信息视图　3.4 总结第4章 公司和联系人　4.1 问题　4.2 设计　　4.2.1 设计领域模型　　4.2.2 定义Company聚合和Contact聚合　　4.2.3 定义聚合边界　　4.2.4 设计仓储　　4.2.5 编写单元测试　4.3 解决方案　　4.3.1 Company类　　4.3.2 Contact类　　4.3.3 ProjectContact类　　4.3.4 实现仓储　　4.3.5 实现服务类　　4.3.6 Company视图模型　　4.3.7 Company视图　　4.3.8 项目联系人视图模型　　4.3.9 项目联系人视图　4.4 总结第5章 递交传送　5.1 问题　5.2 设计　　5.2.1 设计领域模型　　5.2.2 定义Submittal聚合　　5.2.3 定义聚合边界　　5.2.4 设计仓储　　5.2.5 编写单元测试　5.3 解决方案　　5.3.1 实现Submittal仓储　　5.3.2 实现Submittal服务类　　5.3.3 Submittal视图模型　　5.3.4 Submittal视图　5.4 总结第6章 信息请求　6.1 问题　6.2 设计　　6.2.1 设计领域模型　　6.2.2 定义RFI聚合　　6.2.3 定义聚合边界　　6.2.4 设计仓储　　6.2.5 编写单元测试　6.3 解决方案　　6.3.1 实现RFI仓储　　6.3.2 实现RFI服务类　　6.3.3 RFI视图模型类　　6.3.4 RFI视图　6.4 总结第7章 提案请求　7.1 问题　7.2 设计　　7.2.1 设计领域模型　　7.2.2 设计提案请求聚合　　7.2.3 定义聚合边界　　7.2.4 设计仓储　　7.2.5 编写单元测试　7.3 解决方案　　7.3.1 提案请求类的私有字段和构造器　　7.3.2 ProposalRequest属性　　7.3.3 Validate方法　　7.3.4 实现提案请求仓储　　7.3.5 实现提案请求服务类　　7.3.6 提案请求视图模型类　　7.3.7 提案请求视图　7.4 总结第8章更改单  8.1 问题  8.2 设计    8.2.1 设计领域模型    8.2.2 设计更改单聚合    8.2.3 定义聚合边界    8.2.4 设计仓储    8.2.5 编写单元测试  8.3 解决方案    8.3.1 实现更改单仓储    8.3.2 实现更改单服务类    8.3.3 更改单视图模型类    8.3.4 更改单视图  8.4 总结第9章 施工更改指令  9.1 问题  9.2 设计    9.2.1 设计领域模型    9.2.2 设计施工更改指令聚合    9.2.3 定义聚合边界    9.2.4 设计仓储    9.2.5 编写单元测试  9.3 解决方案    9.3.1 施工更改指令类的私有字段和构造器    9.3.2 实现施工更改指令仓储    9.3.3 实现施工更改指令服务类    9.3.4 施工更改指令视图模型类    9.3.5 施工更改指令视图  9.4 总结第10章 和服务器同步  10.1 问题  10.2 设计    10.2.1 重新设计工作单元    10.2.2 设计同步    10.2.3 编写单元测试  10.3 解决方案    10.3.1 工作单元重构    10.3.2 和Synchronizer类同步  10.4 总结第11章 客户会员管理系统  11.1 问题  11.2 设计    11.2.1 密码安全    11.2.2 设计客户会员管理系统  11.3 解决方案    11.3.1 客户会员管理系统领域模型类    11.3.2 客户会员管理系统单元测试  11.4 总结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>领域驱动设计C# 2008实现
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向对象的思考过程（原书第4版）
译者序
作者简介
前言
第1章　面向对象的概念简介　1
1.1　基本概念　1
1.2　对象及遗留系统　2
1.3　过程式编程与面向对象编程　3
1.4　由面向过程开发过渡到面向对象开发　5
1.4.1　过程式编程　5
1.4.2　面向对象编程　6
1.5　究竟什么是对象　6
1.5.1　对象数据　6
1.5.2　对象行为　7
1.6　究竟什么是类　10
1.6.1　创建对象　10
1.6.2　属性　11
1.6.3　方法　11
1.6.4　消息　12
1.7　使用类图作为可视化工具　12
1.8　封装和数据隐藏　12
1.8.1　接口　13
1.8.2　实现　13
1.8.3　接口/实现范式的一个真实示例　14
1.8.4　接口/实现范式的模型　14
1.9　继承　15
1.9.1　超类和子类　16
1.9.2　抽象　16
1.9.3　is-a关系　17
1.10　多态　18
1.11　组合　21
1.11.1　抽象　21
1.11.2　has-a关系　21
1.12　结语　21
1.13　本章中使用的示例代码　22
1.13.1　C#.NET版本的TestPerson类　22
1.13.2　C#.NET版本的TestShape类　23
第2章　如何以面向对象的方式进行思考　25
2.1　清楚接口和实现之间的区别　26
2.1.1　接口　27
2.1.2　实现　27
2.1.3　一个接口/实现示例　28
2.2　使用抽象思维设计接口　31
2.3　尽可能提供最小化的用户接口　32
2.3.1　确定用户?　33
2.3.2　对象行为　33
2.3.3　环境约束　34
2.3.4　识别公共接口　34
2.3.5　识别实现　34
2.4　结语　35
2.5　引用　35
第3章　高级的面向对象概念　36
3.1　构造函数　36
3.1.1　什么是构造函数调用　37
3.1.2　构造函数中包含什么　37
3.1.3　默认构造函数　37
3.1.4　使用多个构造函数　38
3.1.5　设计构造函数　41
3.2　错误处理　41
3.2.1　忽略问题　42
3.2.2　检查问题并中止应用程序　42
3.2.3　检查问题并试图恢复　42
3.2.4　抛出异常　43
3.3　作用域的重要性　45
3.3.1　局部属性?　45
3.3.2　对象属性　46
3.3.3　类属性　48
3.4　操作符重载　49
3.5　多重继承　49
3.6　对象操作　50
3.7　结语　51
3.8　引用　51
3.9　本章中使用的示例代码　51
第4章　类的剖析　53
4.1　类名　53
4.2　注释　55
4.3　属性　55
4.4　构造函数　56
4.5　访问器　58
4.6　公共接口方法　60
4.7　私有实现方法　60
4.8　结语　61
4.9　引用　61
4.10　本章中使用的示例代码　61
第5章　类设计指导　63
5.1　对现实世界系统建模　63
5.2　识别公共接口　64
5.2.1　最小化公共接口　64
5.2.2　隐藏实现　65
5.3　设计健壮的构造函数（以及析构函数）　65
5.4　在类中设计错误处理　66
5.4.1　使用注释给类加上文档　66
5.4.2　构造可以合作的对象　67
5.5　设计时请考虑重用　67
5.6　设计时请考虑扩展性　67
5.6.1　使用描述性的名称　67
5.6.2　抽象不可移植的代码　68
5.6.3　提供一种方式来复制和比较对象　68
5.6.4　保持尽可能小的作用域　69
5.6.5　类的职责与自身高度相关　70
5.7　设计时请考虑可维护性　71
5.7.1　在开发过程中使用迭代　71
5.7.2　测试接口　72
5.8　使用对象持久化　73
5.9　结语　75
5.10　引用　75
5.11　本章中使用的示例代码　75
第6章　使用对象进行设计　77
6.1　设计指导　77
6.1.1　提供正确的分析　79
6.1.2　编写工作陈述文档　80
6.1.3　收集需求　80
6.1.4　开发用户接口的原型　81
6.1.5　识别类　81
6.1.6　确定每个类的职责　81
6.1.7　确定类之间如何协作　81
6.1.8　创建类模型来描述系统　81
6.1.9　建立用户接口原型　82
6.2　对象包装　82
6.2.1　结构化代码　83
6.2.2　包装结构化代码　84
6.2.3　包装不可移植的代码　85
6.2.4　包装已有类　86
6.3　结语　87
6.4　引用　87
第7章　精通继承和组合　88
7.1　重用对象　88
7.2　继承　89
7.2.1　通用和特例　91
7.2.2　设计决策　92
7.3　组合　93
7.4　为什么封装是面向对象的本质　95
7.4.1　继承如何减弱封装　96
7.4.2　关于多态的一个具体例子　97
7.4.3　对象职责　98
7.4.4　抽象类、虚方法和协议　101
7.5　结语　102
7.6　引用　103
7.7　本章中使用的示例代码　103
第8章　框架和重用：使用接口和抽象类进行设计　105
8.1　代码：重用还是不重用　105
8.2　什么是框架　106
8.3　什么是契约　107
8.3.1　抽象类　108
8.3.2　接口　110
8.3.3　综合运用　112
8.3.4　编译器佐证　114
8.3.5　创建契约　115
8.3.6　系统插接点　117
8.4　一个电子商务示例　117
8.4.1　一个电子商务问题　117
8.4.2　非重用方式　118
8.4.3　电子商务解决方案　119
8.4.4　UML对象模型　120
8.5　结语　124
8.6　引用　124
8.7　本章中使用的示例代码　124
第9章　创建对象及面向对象设计　128
9.1　组合关系　129
9.2　分阶段构建　129
9.3　组合类型　131
9.3.1　聚合　131
9.3.2　联合　132
9.3.3　同时使用联合和聚合　133
9.4　避免依赖　133
9.5　基数　134
9.5.1　多个对象联合　136
9.5.2　可选的联合　137
9.6　一个综合性示例　137
9.7　结语　138
9.8　引用　138
第10章　创建对象模型　139
10.1　什么是UML　139
10.2　类图结构　140
10.3　属性和方法　141
10.3.1　属性　142
10.3.2　方法　142
10.4　访问符号　142
10.5　继承　143
10.6　接口　145
10.7　组合　145
10.7.1　聚合　145
10.7.2　联合　146
10.8　基数　147
10.9　结语　148
10.10　引用　149
第11章　对象与可移植数据：XML和JSON　150
11.1　可移植数据　150
11.2　XML　152
11.3　XML与HTML　152
11.4　XML和面向对象的语言　153
11.5　在企业间共享数据　154
11.6　使用DTD验证文档　155
11.7　将DTD集成到XML文档中　156
11.8　使用层叠样式表　161
11.9　JavaScript对象标记　163
11.10　结语　167
11.11　引用　167
第12章　持久化对象：序列化、封送及关系型数据库　168
12.1　持久化对象基础　168
12.2　将对象保存到平面文件中　169
12.2.1　序列化文件　170
12.2.2　再次讨论实现和接口　172
12.2.3　为什么不保存方法　173
12.3　序列化过程中使用XML　173
12.4　写入关系型数据库　176
12.5　结语　179
12.6　引用　179
12.7　本章中使用的示例代码　179
第13章　Web服务、移动应用及混合应用中的对象　183
13.1　分布式计算的演进　183
13.2　基于对象的脚本语言　184
13.3　JavaScript验证示例　186
13.4　网页中的对象　189
13.4.1　JavaScript对象　189
13.4.2　网页控制器　191
13.4.3　声音播放器　192
13.4.4　电影播放器　192
13.4.5　Flash动画　193
13.5　分布式对象及企业　193
13.5.1　公共对象请求代理体系结构　195
13.5.2　Web服务的定义　197
13.5.3　Web服务代码　201
13.5.4　表征状态转移　202
13.6　结语　203
13.7　引用　203
第14章　对象及客户端/服务器端应用程序　204
14.1　客户端/服务器端方式　204
14.2　私有方式　205
14.2.1　序列化对象代码　205
14.2.2　客户端代码　206
14.2.3　服务器端代码　208
14.2.4　运行该私有的客户端/服务器端示例　209
14.3　非私有方式　210
14.3.1　对象定义代码　211
14.3.2　客户端代码　212
14.3.3　服务器端代码　213
14.3.4　运行非私有客户端/服务器端示例　215
14.4　结语　215
14.5　引用　216
14.6　本章中使用的示例代码　216
第15章　设计模式　217
15.1　为什么使用设计模式　218
15.2　Smalltalk的模型/视图/控制器　219
15.3　设计模式类型　220
15.3.1　创建型模式?　220
15.3.2　结构型模式　224
15.3.3　行为型模式　227
15.4　反模式　228
15.5　结语　229
15.6　引用　229
15.7　本章中使用的示例代码?　229
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>面向对象的思考过程（原书第4版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>日本新建筑系列丛书 14  新兴结构
深圳湾体育中心
MOOM张拉膜结构
爱马仕之家临时展馆
宫下公园
日本女子大学西生田校区中庭改建
饭田木工系统东京工厂
金泽UMIMIRAI图书馆
石田眼科
唐木田菖蒲馆
唐木田社区中心·儿童馆·图书馆
东急大井町线上野毛车站
大阪车站城
AlSIN AW技术中心
TECHNICA FUKUI新办公楼
日本惠普总部HP Gamge Tokyo
ATAGO深谷工厂
日东药品Cento anni Hall
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>日本新建筑系列丛书 14  新兴结构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Apache Kylin权威指南
Contents?目　　录
推荐序一
推荐序二
推荐序三
推荐序四
前　言
第1章　Apache Kylin概述  1
1.1　背景和历史  1
1.2　Apache Kylin的使命  3
1.2.1　为什么要使用Apache Kylin  3
1.2.2　Apache Kylin怎样解决关键问题  4
1.3　Apache Kylin的工作原理  5
1.3.1　维度和度量简介  5
1.3.2　Cube和Cuboid  5
1.3.3　工作原理  6
1.4　Apache Kylin的技术架构  7
1.5　Apache Kylin的主要特点  9
1.5.1　标准SQL接口  9
1.5.2　支持超大数据集  9
1.5.3　亚秒级响应  10
1.5.4　可伸缩性和高吞吐率  10
1.5.5　BI及可视化工具集成  11
1.6　与其他开源产品比较  11
1.7　小结  12
第2章　快速入门  13
2.1　核心概念  13
2.1.1　数据仓库、OLAP与BI  13
2.1.2　维度和度量  14
2.1.3　事实表和维度表  14
2.1.4　Cube、Cuboid和Cube Segment  15
2.2　在Hive中准备数据  15
2.2.1　星形模型  15
2.2.2　维度表的设计  16
2.2.3　Hive表分区  16
2.2.4　了解维度的基数  17
2.2.5　Sample Data  17
2.3　设计Cube  17
2.3.1　导入Hive表定义  18
2.3.2　创建数据模型  18
2.3.3　创建Cube  21
2.4　构建Cube  25
2.4.1　全量构建和增量构建  27
2.4.2　历史数据刷新  28
2.4.3　合并  29
2.5　查询Cube  30
2.6　SQL参考  31
2.7　小结  32
第3章　增量构建  33
3.1　为什么要增量构建  33
3.2　设计增量Cube  35
3.2.1　设计增量Cube的前提  35
3.2.2　增量Cube的创建  36
3.3　触发增量构建  37
3.3.1　Web GUI触发  37
3.3.2　构建相关的Rest API  39
3.4　管理Cube碎片  45
3.4.1　合并Segment  46
3.4.2　自动合并  47
3.4.3　保留Segment  48
3.4.4　数据持续更新  49
3.5　小结  50
第4章　流式构建  51
4.1　为什么要流式构建  51
4.2　准备流式数据  52
4.2.1　数据格式  52
4.2.2　消息队列  53
4.2.3　创建Schema  53
4.3　设计流式Cube  56
4.3.1　创建Model  56
4.3.2　创建Cube  57
4.4　流式构建原理  59
4.5　触发流式构建  61
4.5.1　单次触发  61
4.5.2　自动化多次触发  61
4.5.3　出错处理  62
4.6　小结  63
第5章　查询和可视化  64
5.1　Web GUI  64
5.1.1　查询  64
5.1.2　显示结果  65
5.2　Rest API  67
5.2.1　查询认证  67
5.2.2　查询请求参数  67
5.2.3　查询返回结果  68
5.3　ODBC  69
5.4　JDBC  71
5.4.1　获得驱动包  71
5.4.2　认证  71
5.4.3　URL格式  71
5.4.4　获取元数据信息  72
5.5　通过Tableau访问Kylin  72
5.5.1　连接Kylin数据源  73
5.5.2　设计数据模型  73
5.5.3　通过Live方式连接  73
5.5.4　自定义SQL  75
5.5.5　可视化  75
5.5.6　发布到Tableau Server  76
5.6　Zeppelin集成  77
5.6.1　Zeppelin架构简介  77
5.6.2　KylinInterpreter的工作原理  77
5.6.3　如何使用Zeppelin访问Kylin  78
5.7　小结  80
第6章　Cube优化  81
6.1　Cuboid剪枝优化  81
6.1.1　维度的诅咒  81
6.1.2　检查Cuboid数量  82
6.1.3　检查Cube大小  83
6.1.4　空间与时间的平衡  84
6.2　剪枝优化的工具  85
6.2.1　使用衍生维度  85
6.2.2　使用聚合组  87
6.3　并发粒度优化  89
6.4　Rowkeys优化  90
6.4.1　编码  90
6.4.2　按维度分片  91
6.4.3　调整Rowkeys顺序  92
6.5　其他优化  93
6.5.1　降低度量精度  93
6.5.2　及时清理无用的Segment  94
6.6　小结  94
第7章　应用案例分析  95
7.1　基本多维分析  95
7.1.1　数据集  95
7.1.2　数据导入  97
7.1.3　创建数据模型  99
7.1.4　创建Cube  102
7.1.5　构建Cube  108
7.1.6　SQL查询  110
7.2　流式分析  112
7.2.1　Kafka数据源  112
7.2.2　创建数据表  113
7.2.3　创建数据模型  115
7.2.4　创建Cube  117
7.2.5　构建Cube  118
7.2.6　SQL查询  119
7.3　小结  119
第8章　扩展Apache Kylin  120
8.1　可扩展式架构  120
8.1.1　工作原理  121
8.1.2　三大主要接口  122
8.2　计算引擎扩展  124
8.2.1　EngineFactory  124
8.2.2　MRBatchCubingEngine2  125
8.2.3　BatchCubingJobBuilder2  126
8.2.4　IMRInput  128
8.2.5　IMROutput2  129
8.3　数据源扩展  130
8.4　存储扩展  132
8.5　聚合类型扩展  134
8.5.1　聚合的JSON定义  134
8.5.2　聚合类型工厂  135
8.5.3　聚合类型的实现  136
8.6　维度编码扩展  140
8.6.1　维度编码的JSON定义  140
8.6.2　维度编码工厂  141
8.6.3　维度编码的实现  142
8.7　小结  143
第9章　Apache Kylin的企业级功能  144
9.1　身份验证  144
9.1.1　自定义验证  145
9.1.2　LDAP验证  146
9.1.3　单点登录  150
9.2　授权  151
9.3　小结  153
第10章　运维管理  154
10.1　安装和配置  154
10.1.1　必备条件  154
10.1.2　快速启动Apache Kylin  157
10.1.3　配置Apache Kylin  160
10.1.4　企业部署  162
10.2　监控和诊断  165
10.2.1　日志  165
10.2.2　任务报警  167
10.2.3　诊断工具  169
10.3　日常维护  170
10.3.1　基本运维  170
10.3.2　元数据备份  170
10.3.3　元数据恢复  171
10.3.4　系统升级  172
10.3.5　垃圾清理  174
10.4　常见问题和修复  175
10.5　获得社区帮助  176
10.5.1　邮件列表  177
10.5.2　JIRA  177
10.6　小结  177
第11章　参与开源  178
11.1　Apache Kylin的开源历程  178
11.2　为什么参与开源  179
11.3　Apache开源社区简介  179
11.3.1　简介  179
11.3.2　组织构成与运作模式  180
11.3.3　项目角色  181
11.3.4　孵化项目及顶级项目  182
11.4　如何贡献到开源社区  183
11.4.1　什么是贡献  183
11.4.2　如何贡献  183
11.5　礼仪与文化  184
11.6　如何参与Apache Kylin  185
11.7　小结  185
第12章　Apache Kylin的未来  186
12.1　大规模流式构建  186
12.2　拥抱Spark技术栈  187
12.3　更快的存储和查询  187
12.4　前端展现及与BI工具的整合  187
12.5　高级OLAP函数  188
12.6　展望  188
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Apache Kylin权威指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Lighttpd源码分析
前言
第1章 lighttpd介绍与分析准备工作 1
1.1 lighttpd介绍 1
1.1.1 什么是lighttpd 1
1.1.2 lighttpd功能概述 1
1.2 源码分析的准备工作 3
1.2.1 lighttpd源码下载与组织结构 3
1.2.2 lighttpd源码分析工具 4
1.2.3 系统编译环境 6
1.2.4 lighttpd编译运行 6
1.2.5 其他准备 7
1.3 本书内容综述 7
1.4 本章总结 8
第2章 lighttpd网络服务主模型 9
2.1 概述 9
2.2 lighttpd主进程执行流程 10
2.2.1 lighttpd进程守护化 10
2.2.2 lighttpd多进程网络服务模型 14
2.3 lighttpd信号处理机制 20
2.3.1 信号的概念 20
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Lighttpd源码分析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java微服务
前言	XV
1  一种解决方法	1
微服务的演变	2
整体式架构概述	3
整体式架构的局限性与它的微服务解决方案的对比	3
一维的可扩展性	6
在出故障时回滚版本	7
采用新技术时的问题	7
与敏捷实践的契合	8
减轻开发工作量——可以做得更好	9
微服务的构建管道	10
使用诸如Docker的容器部署	11
容器	11
Docker	12
Docker的架构	13
Docker容器	14
部署	14
小结	14
2  设置开发环境	17
Spring Boot配置	18
Spring Boot概述	18
把Spring Boot添加至REST示例	19
添加一个嵌入式Jetty服务器	21
示例REST程序	22
编写REST控制器类	24
@RestController	25
@RequestMapping	25
@RequestParam	25
@PathVariable	26
制作一个示例REST可执行应用程序	29
设置应用程序构建	30
运行Maven工具	30
用Java命令执行	31
使用Postman Chrome扩展测试REST API	31
更多的正向测试场景	34
反向的测试场景	35
NetBeans IDE安装和设置	37
参考资料	42
小结	42
3  领域驱动设计	43
领域驱动设计基本原理	44
组成部分	45
普遍存在的语言	45
多层架构	45
表示层	46
应用程序层	46
领域层	46
基础架构层	47
领域驱动设计的工件	47
实体	47
值对象	48
服务	49
聚合	50
存储库	52
工厂	53
模块	54
战略设计和原则	55
有界上下文	55
持续集成	56
上下文映射	57
共享内核模式	58
客户和供应商模式	58
顺从者模式	59
反腐层	59
独立方法	59
开放主机服务	60
精馏	60
示例领域服务	60
实体的实现	61
存储库的实现	63
服务的实现	66
小结	67
4  实现微服务	69
OTRS概述	70
开发和实现微服务	71
餐馆微服务	72
控制器类	73
服务类	76
存储库类	79
实体类	82
预订和用户服务	85
注册和发现服务（Eureka服务）	85
执行	87
测试	87
参考资料	92
小结	92
5  部署和测试	93
使用Netflix OSS的微服务架构概述	93
负载均衡	95
客户端的负载均衡	95
服务器端的负载均衡	98
电路断路器与监控	102
使用Hystrix的回退方法	102
监控	103
设置Hystrix仪表板	105
设置Turbine	107
使用容器部署微服务	109
安装和配置	109
具有4 GB内存的Docker机器	110
使用Maven构建Docker映像	110
使用 Maven 运行Docker	114
使用Docker执行集成测试	115
把映像推送到注册表	118
管理Docker容器	119
参考资料	121
小结	121
6  实现微服务的安全性	123
启用安全套接字层	123
身份验证和授权	127
OAuth 2.0	127
OAuth的用法	128
OAuth 2.0规范——简明详细信息	128
OAuth 2.0角色	129
OAuth 2.0客户端注册	131
OAuth 2.0协议端点	135
OAuth 2.0授权类型	137
使用Spring Security的OAuth实现	144
授权码许可	150
隐式许可	153
资源所有者密码凭据许可	154
客户端凭据许可	155
参考资料	155
小结	156
7  利用微服务Web应用程序来使用服务	157
AngularJS框架概述	157
MVC	158
MVVM	158
模块	158
提供程序和服务	160
作用域	161
控制器	161
过滤器	161
指令	162
UI-Router	162
OTRS 功能的开发	163
主页/餐馆列表页	163
index.html	164
app.js	169
restaurants.js	172
restaurants.html	179
搜索餐馆	180
餐馆详细信息与预订选项	181
restaurant.html	181
登录页面	183
login.html	184
login.js	185
预订确认	186
设置web应用程序	187
小结	201
8  最佳做法和一般原则	203
概述和心态	203
最佳做法和原则	205
Nanoservice（不推荐）、规模和整体性	205
持续集成和部署	206
系统/端到端测试自动化	207
自我监控和记录	207
每个微服务都使用独立的数据存储区	209
事务边界	210
微服务框架和工具	210
Netflix开放源码软件（OSS）	210
构建——Nebula	211
部署和交付——Spinnaker与Aminator	211
服务注册和发现——Eureka	211
服务沟通——Ribbon	212
电路断路器——Hystrix	212
边缘（代理）服务器——Zuul	212
业务监控——Atlas	213
可靠性监控服务——Simian Army	213
AWS资源监控——Edda	214
主机性能监控——Vector	215
分布式配置管理——Archaius	215
Apache Mesos调度器——Fenzo	215
成本和云利用率——Ice	216
其他安全工具——Scumblr和FIDO	216
参考资料	217
小结	218
9  故障排除指南	219
日志记录和ELK环境	219
简要概述	221
Elasticsearch	221
Logstash	221
Kibana	222
ELK环境安装	222
安装Elasticsearch	223
安装Logstash	224
安装Kibana	225
服务调用关联ID的使用	226
让我们看看怎样解决这个问题	226
依赖项和版本	227
循环依赖关系及其影响	227
设计系统时需要分析它	227
维护不同版本	227
让我们了解更多	228
参考资料	228
小结	228
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java微服务
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>辩论阶梯
序言
第一篇 辩论与辩论赛
第二篇 辩手基本能力训练
第三篇 辩论基本技能训练
第四篇 辩论实战技能训练
第五篇 辩论的思考

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>辩论阶梯
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大话企业级Android应用开发实战
第1话  大话Android  1  智能手机与3G  2  智能手机平台  3  智能手机与手机厂商  4  Android详解  5  Android的盈利方式  6  Android学习之道第2话  Android开发之道第3话  Android之UI（用户界面）开发第4话  “机器人”的核心组件第5话  数据，数据第6话  Android与网络第7话  Android之娱乐多媒体开发第8话  Android之硬件操作第9话  Android之GPS开发第10话  Android之图形图像处理第11话  Android之优化之道第12话  Android之项目开发附录A
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大话企业级Android应用开发实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>可伸缩敏捷开发
第1部分 软件敏捷概述
第1章 敏捷方法介绍
1.1 在软件经济中获得竞争优势软件开发方法与行业一起发展
1.2 走进敏捷方法
1.3 敏捷的规模
1.4 了解敏捷方法敏捷宣言
1.5 采用敏捷方法的趋势
1.6 软件敏捷的企业效益
1.6.1 提高生产力
1.6.2 提高质量
1.6.3 提升团队士气和工作满意度
1.6.4 更快地面市
1.7 XP、Scrum及RUP的简介
1.7.1 极限编程（XP）
1.7.2 Scrum
1.7.3 Rational统一过程
1.8 小结
第2章 为什么瀑布模型不适用
2.1 瀑布模型的问题
2.2 瀑布模型的假设
2.2.1 假设1：如果我们花时间来理解的话，存在着一套定义相当明确的需求
2.2.2 假设2：改变是小型且便于管理的
2.2.3 假设3：系统集成会顺利进行
2.2.4 假设4：我们完全可以按计划交付
2.3 利用敏捷方法来纠正行为
第3章 XP的本质
3.1 什么是XP
3.2 有关XP的争议
3.3 有关XP的极限
3.4 XP的基本原则
3.5 XP的价值、原则及实践方法
3.5.1 XP的5个核心价值
3.5.2 基本原则
3.5.3 XP的13个关键实践技巧
3.5.4 对结对编程的注释
3.6 XP的过程模型
3.7 XP方法的应用
阅读参考
第4章 Scrum的本质
4.1 Scrum是什么
4.2 Scrum的角色
4.3 Scrum的哲学根基
4.4 Scrum的价值观、原则及实践方法
4.5 Scrum的关键实践方法
4.6 Scrum的基本原则：经验过程控制
4.7 Scrum的过程模型
4.8 对Scrum和组织的变更
4.9 方法的应用
阅读参考
第5章 RUP的本质
5.1 什么是RUP
5.2 RUP的关键特征
5.3 RUP的根源
5.3.1 RUP的原理与实践
5.3.2 迭代：RUP的基本原则
5.3.3 架构驱动和用例中心化
5.3.4 RUP开发过程模型
5.3.5 时间轴
5.3.6 规程轴
5.3.7 RUP生命周期迭代类型
5.4 敏捷RUP变体
5.4.1 开放统一过程（OpenUP）
5.4.2 敏捷统一过程
5.5 方法的适用性
阅读参考
第6章 精益软件开发、DSDM和FDD
6.1 精益软件开发关于精益软件开发的阅读参考
6.2 动态系统开发方法
6.2.1 背景
6.2.2 DSDM的基本原则
6.2.3 DSDM的核心实践
6.2.4 访问DSDM
6.3 特征驱动开发FDD的最佳实践
第7章 敏捷的本质
7.1 敏捷正在改变什么
7.1.1 成功的新措施
7.1.2 不同的管理文化
7.1.3 需求、架构和设计的不同方法
7.1.4 修正编码和实现实践
7.1.5 测试和质量保证实践的转变
7.1.6 规划和进度安排的新方法
7.1.7 最大的变化：范畴VS日期，优先考虑日期
7.2 敏捷的重要动力：短时间盒内的工作代码
7.3 总结
第8章 可伸缩敏捷的挑战
8.1 方法的明显障碍
8.1.1 小团队规模
8.1.2 客户是团队的一部分
8.1.3 配置
8.1.4 架构形成
8.1.5 缺乏需求分析和规范文档
8.1.6 文化和物理环境
8.2 企业的障碍
8.2.1 过程和项目管理组织
8.2.2 现有正式的策略和流程
8.2.3 企业文化
8.2.4 固定日程、固定功能授权
8.2.5 开发部门和用户/客户代理团队之间的摩擦
8.2.6 通过纪律组织人力而不是生产线
8.2.7 高度分布
8.3 总结
第2部分 7种可伸缩的敏捷团队实践
第9章 定义/构建/测试模块团队
9.1 什么是定义/构建/测试模块团队
简单故事的生命周期
9.2 解除功能单元
9.3 敏捷模块团队的角色和职责
9.4 创建自组织、自管理的定义/构建/测试团队
9.4.1 团队中有合适的人
9.4.2 团队是被领导而不是被管理
9.4.3 团队了解任务
9.4.4 团队不断交流与合作
9.4.5 团队为结果负责
9.5 分布式的团队
第10章 计划和追踪两个级别
10.1 通用敏捷框架
10.1.1 定义迭代
10.1.2 剖析迭代
10.1.3 定义发布
10.1.4 剖析发布
10.1.5 计划发布
10.1.6 为发布分配需求
10.1.7 发布计划
10.2 小结：两个级别的计划
第11章 掌握迭代
11.1 迭代：敏捷的推动力
11.2 标准的两周迭代
11.3 计划和执行迭代
11.4 迭代计划
11.4.1 为迭代计划会做准备
11.4.2 参与者
11.4.3 迭代计划会议
11.4.4 结果：迭代计划
11.4.5 附加的迭代计划指导原则
11.4.6 分布式团队的迭代计划
11.5 迭代执行
11.5.1 承担职责
11.5.2 开发
11.5.3 交付故事
11.5.4 宣布故事完成
11.5.5 接收迭代
11.6 迭代追踪和调整
11.6.1 追踪每日站立例会
11.6.2 每日站立例会指导原则
11.6.3 追踪迭代状态
11.6.4 追踪剩余时间表
11.7 迭代节奏日历
第12章 更小、更频繁的发布
12.1 小型发布的好处
12.2 定义发布和制定发布的日程
12.2.1 日程驱动发布
12.2.2 最简单的模型：固定周期发布日期
12.2.3 估算特征集
12.3 计划发布
12.3.1 参与者
12.3.2 准备
12.3.3 发布计划过程
12.3.4 结果：发布计划
12.3.5 附加的发布计划指导原则
12.4 发布追踪
12.4.1 为发布状态审查做准备
12.4.2 发布状态审查会
12.4.3 成果/文档
12.5 发布路线图
12.6 大规模敏捷的预览：全面的发布计划和追踪
12.6.1 组织大规模的敏捷
12.6.2 多团队发布计划
12.6.3 发布追踪
第13章 并发测试
13.1 敏捷测试介绍构建本质上可测试的系统
13.2 敏捷测试原则
13.3 单元测试
13.3.1 迭代过程中的单元测试
13.3.2 单元测试和测试驱动开发
13.4 接收测试自动接收测试实例：FIT方法
13.5 组件测试
13.6 系统和性能测试
13.7 小结：简述敏捷测试策略迭代和发布测试模式
第14章 持续集成
14.1 什么是持续集成非持续集成：微观世界的问题
14.2 持续集成
14.3 实现持续集成的3个步骤
14.3.1 源代码集成
14.3.2 自动化构建管理
14.3.3 自动构建验证测试
14.4 什么是持续集成成功
第15章 定期反省和调整
15.1 迭代回顾
15.1.1 迭代回顾的形式
15.1.2 定量评估
15.1.3 定性评估
15.1.4 要求行动
15.2 发布回顾
15.2.1 定量评估
15.2.2 定性评估
15.2.3 利用迭代回顾消除组织的障碍
第3部分 创建敏捷企业
第16章 有意识的架构
16.1 什么是软件架构
16.2 敏捷和架构
16.2.1 极限编程：架构形成
16.2.2 Scrum
16.2.3 在FDD中的架构
16.2.4 RUP：以架构为中心
16.3 关于重构和可伸缩系统
16.4 你在创建什么
16.5 用于企业级系统的敏捷架构方法基于组件的系统：组织遵从架构
16.6 创建架构跑道
16.6.1 架构的脆弱性和临时性本质
16.6.2 扩展架构跑道
16.6.3 通过产品记录重构
16.6.4 扩展架构跑道：与迭代同步
16.6.5 扩展架构跑道：一种精益的、基于拉的方法
第17章 伸缩时的精益需求：愿景、路线图、适时的细化
17.1 概述：需求金字塔
17.1.1 利益相关者的需要
17.1.2 解决方案的“特性”
17.1.3 软件需求
17.1.4 传统的需求方法
17.2 敏捷方法中需求的不同
17.2.1 在XP中的需求
17.2.2 Scrum、产品拥有者和产品记录
17.2.3 在RUP中的需求
17.3 一种可测量的、敏捷的需求方法：概要、路线图以及适时的细化
17.3.1 细化用户故事
17.3.2 细化用例
17.3.3 细化接收测试用例
17.4 小结
第18章 系统的系统及敏捷发布序列
18.1 敏捷组件发布日程
18.1.1 驱动敏捷序列的经验教训
18.1.2 敏捷发布序列的原则
18.2 敏捷发布序列
18.2.1 序列是同步的
18.2.2 序列是由愿景、主题和端到端用例驱动的
18.2.3 保持序列被跟踪并符合日程
18.2.4 测量过程和速度
18.2.5 观察系统级模式
18.2.6 管理相互依赖关系
18.3 发布序列审查
第19章 管理高度分布式开发
19.1 在规模上，所有的开发都是分布式开发
19.2 案例研究1PINGIDENTITY公司：
分布式定义/构建/测试组件团队
19.2.1 PingIdentity案例研究背景
19.2.2 学到的其他经验教训
19.3 案例研究2BMC软件公司：高度分布式的、大规模企业中的敏捷改革
19.3.1 背景
19.3.2 IMD应用敏捷
19.3.3 结果
19.3.4 从编码到编程：大范围采用敏捷
19.3.5 吸取的经验：贯穿大型组织的可伸缩敏捷实践
19.3.6 下一步骤：敏捷成功的第一年后
19.4 重视沟通
19.4.1 穿梭访问
19.4.2 通信基础设施
19.5 企业级敏捷的基础设施建设
19.5.1 源代码管理
19.5.2 网络基础设施
19.5.3 在早期迭代中提供基础设施
19.6 小结
第20章 对客户和操作的影响
20.1 敏捷方法对销售和市场的好处
20.2 对产品市场/产品管理的影响
20.3 更小、更频繁的发布更小、更频繁发布的挑战
20.4 优化敏捷发布过程
20.4.1 发布选择1：忽略敏捷
20.4.2 发布选择2：追求敏捷
20.4.3 发布选择3：通过从外部发布中分离出开发发布，进行优化
20.5 来自真正的销售和市场执行人员关于敏捷的真实挑战和错觉
第21章 组织变更
21.1 概述
21.2 为何敏捷需要改变组织
21.3 为Scrum和敏捷做准备
21.3.1 让软件过程和组织都“Scrumming”
21.3.2 让执行主管成为组织变更的Scrum主管
21.3.3 当心：变更是很困难的
21.4 消除软件生产率的障碍
21.5 给执行管理层的敏捷模型
21.5.1 支持采用敏捷
21.5.2 实践你宣扬的理论：把敏捷作为执行管理层实践
21.6 在大型组织中全面开展Scrum/敏捷
21.6.1 概观、评估和先导准备
21.6.2 先导项目
21.6.3 组织扩张
21.6.4 获得影响
21.6.5 度量、评估和调整
21.6.6 扩展和胜利
21.7 小结
第22章 度量业绩
22.1 敏捷测量：主要区别
22.2 测量团队业绩
22.2.1 敏捷项目度量
22.2.2 敏捷过程度量
22.2.3 评估成果
22.3 关于度量、“过程策略”和团队自评估
22.4 扩展至组织业绩：综合评价卡方法
22.4.1 效率
22.4.2 质量
22.4.3 价值交付
22.4.4 敏捷性
22.5 可伸缩的敏捷度量:为企业实现一个灵活的、自动化的和有意义的BSC
22.5.1 第1步：量化BSC矩阵元素
22.5.2 第2步：转为字母等级
22.5.3 第3步：聚合成产品线、业务单元和企业
结论：敏捷是可伸缩的
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>可伸缩敏捷开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C#线程参考手册
第1章 定义线程
1.1 线程的定义
1.1.1 多任务
1.1.2 进程
1.1.3 线程
1.2 .NET和C#对线程的支持
1.2.1 System.Appdomai

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>C#线程参考手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大型软件体系结构
第1章  导论	1
1.1  什么是软件体系结构	1
1.1.1  软件体系结构不是什么	3
1.1.2  软件体系结构属性	4
1.1.3  与体系结构有关的其他关键术语的定义	5
1.1.4  其他类型的

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大型软件体系结构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>SOA核心技术及应用
第1章　SOA的技术决策
1.1　公司IT部门面临的困境
1.2　决策者的决策——部署SOA
1.2.1　什么是SOA
1.2.2　SOA实施的主要困难
1.3　SOA的技术抉择
1.3.1　相关技术概览
1.3.2　服务
1.3.3　数据和消息模型
1.3.4　服务编排和流程整合
1.4　本章小结
第2章　为什么需要SCA
2.1 SCA的起源
2.1.1 Web服务技术的兴起
2.1.2 Web服务调用框架的任务
2.1.3 SCA的提出
2.2 WPS中SCA实现简介
2.2.1 服务组件（Service Component）
2.2.2 导入（Import）、导出（Export）和绑定（Binding）
2.2.3 同步调用和异步调用
2.2.4 SCA的静态调用和动态调用
2.2.5 接口映射（Interface M印）
2.2.6 服务模块（Module）
2.3 为什么需要SCA
2.4 本章小结
第3章 SCA基本概念
3.1 SCA编程模型
3.2 SCA组件（component）
3.2.1 组件的实现（implementation）
3.2.2 组件中的接口
3.2.3 组件中的绑定
3.2.4 组件的服务（service）
3.2.5 组件的引用（reference）
3.2.6 组件的属性（property）
3.2.7 组件中的服务质量
3.3 SCA构件（composite）
3.3.1 构件的属性（property）
3.3.2 构件的服务（service）
3.3.3 构件的引用（reference）
3.3.4 构件的连接（wire）
3.3.5 将构件用做组件的实现
3.4 打包（package）和部署（deployment）
3.4.1 SCA域（domain）
3.4.2 Contribution
3.5 SCA中的常见绑定
3.5.1 SCA绑定
3.5.2 Web服务绑定
3.5.3 JMS绑定
3.6 策略框架（policy framework）
3.6.1 框架模型
3.6.2 策略意向和策略集的应用
3.6.3 角色和分工
3.6.4 安全策略
3.6.5 可靠性策略
3.7 扩展模型（extension model）
3.8 本章小结
第4章 Tuscany SCA简介
4.1 Tuscany与Apache开源
4.2 Tuscany与Apache Maven
4.3 Maven简介
4.3.1 Maven及其所解决的问题
4.3.2 Maven的安装
4.3.3 命令行的使用
4.3.4 Maven与Eclipse的结合使用
4.3.5 从源代码构建Tuscany SCA Java
4.4 Maven原型（Archetype）与Tuscany SCA开发
4.4.1 Maven原型（Archetype）简介
4.4.2 创建Maven原型
4.4.3 Tuscany SCA的安装
4.5 本章小结
第5章 SCA实践起步
5.1 SCA初接触
5.2 SCA项目的创建
5.3 定义一个SCA组件
5.4 SCA组件的单元测试
5.4.1 JUnit与单元测试”
5.4.2 SCA单元测试的编写
5.4.3 单元测试的运行
5.5 接口与实现
5.5.1 接口的重用
5.5.2 接口与实现的分离
5.5.3 业务逻辑与技术的分离
5.6 实现一个Web服务
5.6.1 使用Web服务绑定
5.6.2 Java接口到WSDL接口的转化
5.6.3 Web服务测试用例
5.6.4 部署Web服务到Tomcat服务器
5.7 在一个SCA中使用Web服务
5.7.1 引用的定义
5.7.2 在实现中使用引用
5.7.3 引用使用的测试用例
5.7.4 测试驱动的学习模式
5.8 本章小结
第6章 使用SCA构建SOA应用
6.1 SCA服务整合的特点
6.1.1 对服务整合技术的要求
6.1.2 SCA服务整合的特点
6.1.3 组件、构件和SCA域
6.1.4 两个主要的核心问题
6.2 SCA绑定
6.2.1 默认服务绑定
6.2.2 显式地获取服务
6.2.3 使用引用获取服务
6.2.4 服务的命名约定
6.2.5 引用的使用与多接口
6.2.6 服务的无状态实现
6.3 服务实现的不同作用域
6.3.1 EJB会话Bean的无状态和有状态
6.3.2 一个错误的计数器实现
6.3.3 实现实例创建和销毁的时机
6.3.4　构件作用域
6.3.5　请求作用域
6.3.6　会话作用域
6.4　可会话服务
6.4.1　可会话的例子
6.4.2　会话的标识
6.4.3　可会话服务的生命周期
6.4.4　会话的属性
6.4.5　服务的显式引用
6.5　异步调用与可会话编程
6.5.1　单向异步
6.5.2　延迟响应
6.5.3　组件上下文和请求上下文
6.5.4　请求回调（Callback）
6.6　不同类型的绑定
6.6.1　web服务绑定
6.6.2　企业会话Bean绑定
6.6.3　JMS绑定
6.7　组件的不同类型的实现
6.7.1　Java实现
6.7.2　SCA对脚本语言的支持
6.7.3　使用构件作为组件实现
6.8　SCA的服务接口
6.8.1　WSDL接口
6.8.2　Java接口
6.9　SCA其他语言的实现
6.9.1 SCA的C++实现
6.9.2 SCA的PHP实现
6.9.3 SCA不同语言实现小结
6.10 本章小结
第7章 SCA与其他技术
7.1 SCA与Spring
7.1.1　Spring的新主张
7.1.2　从Spring到Tuscany
7.1.3　在SCA里使用Spring
7.2　SCA与OSGi
7.2.1　OSGi的成功
7.2.2 OSGi与SCA的异同
7.2.3 SCA和OSGi的关系
7.3 SCA与SDO
7.3.1 SDO简介
7.3.2 SCA里使用SDO
7.3.3　数据整合和服务整合的目的
7.4　本章小结
第8章　什么是SDO
8.1　产生背景
8.1.1　SDO的历史
8.1.2　产品支持
8.1.3　基本结构
8.2　设计思想
8.2.1　为什么需要SDO
8.2.2　设计需求
8.3　SDO、EJB和Hibernate
8.3.1 SDO和EJB
8.3.2 SDO和Hibernate
8.4 Data Access Service（DAS）
8.4.1 DAS的功能
8.4.2 关系数据库数据访问服务（RDBDAS）
8.5 本章小结
第9章 SDO的基本概念
9.1 数据图和数据对象
9.1.1 数据图（DataGraph）
9.1.2 数据对象（DataObject）概念和特性
9.1.3 数据对象的接口定义
9.1.4 XPath表达式
9.2 变更摘要
9.2.1 内容和范围
9.2.2 序列化
9.2.3 接口定义
9.3 类型、属性和序列
9.3.1 类型（Type）
9.3.2 类型和属性的模型
9.3.3 属性（Property）
9.3.4 序列（Sequence）
9.4 Helper（帮助）类
9.4.1 DataFactory
9.4.2 TypeHelper
9.4.3 CopyHelper
9.4.4 EqualityHelper
9.4.5 XMLHelper
9.4.6 XMLDocument
9.4.7 XSDHelper
9.4.8 DataHelper
9.4.9 HelperContext和HelperProvider
9.5 序列化
9.5.1 Java序列化
9.5.2 XML序列化
9.6 本章小结
第10章 SDO和XSD的关系
10.1 XSD基本概念
10.1.1 XML概念
10.1.2 XSD介绍
10.2 XSD和SDO的映射
10.3 本章小结
第11章 在Tuscany上使用SDO
11.1 搭建Tuscany环境
11.2 定义SDO模型
11.2.1 静态模型的定义
11.2.2 动态模型的定义
11.3 创建和使用SDO实例
11.4 SDO和SCA的集成使用
11.5 本章小结
第12章 SDO的深入实践
12.1 ChangeSummary
12.1.1　应用场景描述
12.1.2　使用介绍
12.1.3　总结
12.2　序列化服务
12.2.1　应用场景描述
12.2.2　使用介绍
12.2.3 总结
12.3 比较和复制服务
12.3.1　应用场景描述
12.3.2　使用介绍
12.3.3 总结
12.4　本章小结
第13章　业务对象介绍
13.1 WPS简介
13.2 WID简介
13.3 业务对象
13.3.1　业务对象介绍
13.3.2　业务对象（BO）模型的开发
13.3.3　总结
13.4　本章小结
第14章 BPEL概述
14.1 BPEL及其发展历程
14.2 BPEL相关技术
14.3 初识BPEL
14.4 BPEL引擎
14.5 BPEL与SOA
14.6 BPEL与业务过程管理
14.7 本章小结
第15章 BPEL详解
15.1 BPEL总体结构
15.2 BPEL中的交互
15.3 BPEL中的数据
15.4 消息关联
15.5 BPEL活动
15.5.1 BPEL基本活动（BaActivities）
15.5.2 BPEL结构化活动
15.6　作用域（Scope）的概念
15.7　错误处理与补偿（Fault Handling and Compensation）
15.8　事件处理（Event Handling）
15.9　BPEL的扩展机制
15.10　本章小结
第16章　IBM业务过程产品简介
16.1　业务过程管理及其产品概述
16.2 WebSphere Process Server（WPS）
16.3 WebSphere Integration Developer（WID）
16.4 本章小结
第17章 实例分析
17.1 背景介绍
17.1.1 业务需求
17.1.2 技术架构考虑
17.2　方案设计
17.3　开发过程
17.3.1　创建库和模块
17.3.2　创建业务对象
17.3.3　创建服务接口
17.3.4　创建业务状态机
17.3.5　创建业务流程和人员任务
17.3.6　送货服务系统的开发
17.3.7　银行业务系统的开发
17.3.8　创建调解流程
17.3.9　Web应用程序的开发
17.3.10　整合服务
17.4　系统调试
17.4.1　功能测试
17.4.2　系统测试
17.5　监控管理
17.5.1　流程的监控管理
17.5.2　通用事件的监控管理
17.5.3　失败事件的监控管理
17.6　本章小结
附录A　数据对象的接口
附录B ExtemaIizable Delegator
附录C　数据图序列化的XSD
附录D　XSD和SDO的映射表格
附录E　BPEL的Schema定义
技术术语表
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>SOA核心技术及应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入网站开发与运维
目录
第1 章 成功网站的开发运维原则　　1
1.1 深入理解网站开发与运维　3
1.1.1 展开协作　7
1.1.2 提升效率　10
1.1.3 推进协作　11
1.1.4 处理变更　13
1.1.5 展望未来　17
1.2 来自专家的见解　18
1.2.1 软件工程师眼里的开发运维　18
1.2.2 运维工程师眼里的开发运维　21
1.3 本章小结　22
第2 章 协调开发人员与业务运维人员　　25
2.1 平衡技术人员与业务人员的关系　26
2 | 深入网站开发和运维
2.2 理解开发者文化　27
2.2.1 专业技能分类　29
2.2.2 人才与激励　30
2.3 业务人员与IT 人员之间的健康关系　31
2.3.1 业务人员要理解技术能力　31
2.3.2 业务成功符合工程人员的既得利益　32
2.3.3 业务人员与IT 人员要相互理解　32
2.3.4 业务管理层要让IT 人员参与决策制定过程　32
2.3.5 利用工具形成通用词汇表　34
2.3.6 跑在截止日期之前　35
2.3.7 释放紧张环境的压力　36
2.3.8 让业务部门感受到激励　36
2.4 内部敌人　36
2.4.1 认清形势　37
2.4.2 向主管提建议可能很困难　38
2.4.3 突破界限　39
2.5 改善业务人员与工程人员的沟通　40
2.5.1 定义与执行　41
2.5.2 广开言路　41
2.6 本章小结　42
第3 章 Web 测试实践　　43
3.1 Web 测试实践　45
3.1.1 最大容量测试　46
3.1.2 持续负载测试　47
3.2 行为驱动开发　48
3.2.1 Santiago Suarez Ordo?ez 的自动化Web 测试　52
3.2.2 将安全性视为测试实践　54
3.3 确定测试对象　54
3.4 指标吻合度测试：确定测试目标　55
3.4.1 网站的业务指标　56
3.4.2 Web 应用性能指标　60
3.4.3 基于指标模板的应用程序性能指标监控实践　60
3.5 测试各个组件，快速修复故障　63
3.6 逐层保存历史性能数据　65
3.7 本章小结　68
第4 章 设计聪明的文档　　69
4.1 鲜为人知的文档优点　70
4.2 文档编写的拦路虎　72
4.2.1 场景1：时间不够　72
4.2.2 场景2：只有技术文档　74
4.2.3 场景3：文档很快会过时　76
4.3 文档类型与模板　77
4.3.1 API 规范与参考文档　78
4.3.2 入门指南　80
4.3.3 用例文档　82
4.3.4 用户交互工作流程　84
4.3.5 架构图　85
4.3.6 基础架构设计文档　87
4.4 自动化文档编写　89
4.5 本章小结　89
第5 章 基础架构与应用程序的自动分配　　91
5.1 回顾Web 层次　92
5.1.1 通过自动化实现统一的Web 环境　93
5.1.2 提前计算自动化的效果　95
5.2 选择自动化流程　97
5.3 一个自动化场景　101
5.4 降低复杂性　104
5.5 选择配置管理和分配框架　105
5.6 审核基础架构　106
5.7 使用配置管理系统实现自动部署　108
5.8 本章小结　109
第6 章 生产发布　　111
6.1 认识整个过程　112
6.2 网站的概念开发：概念设计　113
6.2.1 概念设计要解决的基本问题　114
6.2.2 成本/收益分析　116
6.2.3 特别项目团队　117
6.3 营销　118
6.4 设计发布元素　119
6.5 灵感与愿景　122
6.6 开发　123
6.6.1 处理偏离计划的问题　123
6.6.2 研发性网站　124
6.7 测试　124
6.7.1 最终用户测试　125
6.7.2 性能测试　125
6.7.3 代码分析　128
6.7.4 生产环境测试　129
6.7.5 安全测试　131
6.7.6 携带负载的压力测试　132
6.8 发布前阶段　134
6.9 发布阶段的负面因素：常见的人员问题　135
6.9.1 不够重视　136
6.9.2 人手不足　136
6.9.3 睡眠不足　137
6.10 成功发布：防止耗竭　138
6.10.1 专责团队　138
6.10.2 特别项目团队的轮转　139
6.10.3 准备应付最坏情况　140
6.10.4 在产品发布过程中保持旺盛斗志　140
6.10.5 成功标准　141
6.11 实现一次成功的产品发布　142
6.12 本章小结　143
第7 章 整合移动Web　　145
7.1 为不同设备提供不同体验　146
7.2 移动Web 的局限性与用户期望　147
7.2.1 用户无耐心　147
7.2.2 延迟时间长　148
7.3 理解使用模式　149
7.4 对比原生应用和移动Web 应用　152
7.5 创建一致体验　153
7.5.1 转换服务　154
7.5.2 整合原生应用　155
7.5.3 通过API 整合　155
7.6 跟踪API 使用率　157
7.7 本章小结　158
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入网站开发与运维
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>OpenStack开源云王者归来
第1篇 基础篇
第1章 OpenStack概述
1.1 云计算简介
1.1.1 什么是云计算
1.1.2 什么是云存储
1.1.3 私有云与公有云
1.2 为什么使用云计算
1.2.1 方案1：简单的服务部署
1.2.2 方案2：分布式服务部署
1.2.3 方案3：基于虚拟化的服务部署
1.2.4 方案4：云计算的解决方案
1.3 OpenStack架构
1.3.1 OpenStack与云计算
1.3.2 OpenStack发展与现状
1.3.3 OpenStack优势
1.3.4 OpenStack学习建议
1.4 OpenStack各个组件及功能
1.4.1 虚拟机管理系统Nova
1.4.2 磁盘存储系统Glance与Swift
1.4.3 虚拟网络管理Quantum
1.4.4 OpenStack三大组件
1.5 小结
第2章 虚拟化技术
2.1 虚拟化技术简介
2.1.1 KVM
2.1.2 Xen
2.1.3 Libvirt
2.2 安装Libvirt虚拟化工具
2.2.1 安装KVM
2.2.2 安装Libvirt
2.3 虚拟机配置文件详解
2.3.1 xml描述hypervisor
2.3.2 虚拟机整体信息
2.3.3 系统信息
2.3.4 硬件资源特性
2.3.5 突发事件处理
2.3.6 raw格式image
2.3.7 qcow2格式image
2.3.8 格式的选择
2.3.9 多个image
2.3.10 虚拟光盘
2.3.11 虚拟网络
2.3.12 vnc配置
2.4 制作image
2.4.1 virt-manager创建image
2.4.2 virsh命令创建image
2.5 快速启动虚拟机
2.5.1 手动安装
2.5.2 直接复制
2.5.3 qcow2快速创建
2.5.4 修改qcow2 image
2.5.5 大批量创建虚拟机
2.6 虚拟机桌面显示
2.6.1 准备工作
2.6.2 创建Windows 7 Image
2.6.3 创建Windows 7虚拟机
2.6.4 spice桌面显示
2.7 常见错误与分析
2.8 小结
2.8.1 常用的virsh命令
2.8.2 磁盘快照管理
第2篇 安装篇
第3章 安装Keystone安全认证服务
3.1 Keystone简介
3.2 搭建局域网源
3.2.1 局域网apt-get源搭建方法
3.2.2 局域网python源搭建方法
3.2.3 Ubuntu-12.10局域网源
……
第4章 安装Swift存储服务
第5章 安装Glance镜像服务
第6章 安装Quantum虚拟网络服务
第7章 安装Cinder块存储服务
第8章 安装Nova虚拟机管理系统
第9章 安装Dashboard Web界面
第10章 OpenStack部署示例
第3篇 剖析篇
第11章 OpenStack服务分析
第12章 Keystone的安全认证
第13章 Swift存储服务
第14章 Quantum虚拟网络
第15章 Nova框架
第16章 Nova Compute服务
第4篇 扩展篇
第17章 从OpenStack到云应用
第18章 基于Nova的扩展
第19章 添加自定义组件
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>OpenStack开源云王者归来
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Mashup模式
译者序
前言
第1章 理解mashup(混搭)模式
1.1 介绍
1.2 Web 2.0
1.3 Enterprise 2.0
1.4 mashup的诞生
1.5 mashup的类型
1.6 从Web获取数据
1.7 长尾
1.8 满足用户要求
1.9 mashup和企业门户网站
1.10 mashup与面向服务的架构
1.11 mashup与EAI/EII
1.12 mashup与软件服务化
1.13 mashup与用户
1.14 模式入门
1.15 脆弱的因素
1.16 mashup的未来
第2章 mashup模式术语
2.1 介绍
2.2 语义
2.3 结构
2.4 UML在哪里
2.5 小结
第3章 核心活动
3.1 介绍
3.2 对开放标准的支持
3.3 数据提取
3.3.1 你是否确切知道你想找的是什么
3.3.2 你是否要挖掘动态更新的页面
3.3.3 内容中是否有二进制格式的文件
3.3.4 能否访问另一种数据视图
3.4 数据输入
3.5 数据可视化
3.6 调度与监视
3.7 剪裁
3.8 转换与充实
3.9 动作
3.10 发布与推广
3.11 组装画布
3.12 小结
第4章 收割模式
4.1 介绍
4.2 警告器
4.2.1 问题
4.2.2 解决方案
4.3 API使能器
4.3.1 问题
4.3.2 解决方案
4.4 竞争分析
4.4.1 问题
4.4.2 解决方案
4.5 无数猴子
4.5.1 问题
4.5.2 解决方案
4.6 领先指标
4.6.1 问题
4.6.2 解决方案
4.7 现实挖掘
4.7.1 问题
4.7.2 解决方案
4.8 声誉管理
4.8.1 问题
4.8.2 解决方案
4.9 时间序列
4.9.1 问题
4.9.2 解决方案
第5章 增强模式
5.1 介绍
5.2 可访问性
5.2.1 问题
5.2.2 解决方案
5.3 源工厂..
5.3.1 问题
5.3.2 解决方案
5.4 战地医生
5.4.1 问题
5.4.2 解决方案
5.5 大众分类使能器
5.5.1 问题
5.5.2 解决方案
5.6 脆弱程度减轻器
5.6.1 问题
5.6.2 解决方案
5.7 智能建议
5.7.1 问题
5.7.2 解决方案
5.8 超级搜索
5.8.1 问题
5.8.2 解决方案
5.9 翻译
5.9.1 问题
5.9.2 解决方案
5.10 有用性增强器
5.10.1 问题
5.10.2 解决方案
5.11 工作流
5.11.1 问题
5.11.2 解决方案
第6章 组装模式
6.1 介绍
6.2 交流与协作
6.2.1 问题
6.2.2 解决方案
6.3 内容聚合
6.3.1 问题
6.3.2 解决方案
6.4 内容集成
6.4.1 问题
6.4.2 解决方案
6.5 分布式向下钻取
6.5.1 问题
6.5.2 解决方案
6.6 紧急响应
6.6.1 问题
6.6.2 解决方案
6.7 过滤器
6.7.1 问题
6.7.2 解决方案
6.8 位置映射
6.8.1 问题
6.8.2 解决方案
6.9 碎片
6.9.1 问题
6.9.2 解决方案
第7章 管理模式
7.1 介绍
7.2 内容移植
7.2.1 问题
7.2.2 解决方案
7.3 仪表板
7.3.1 问题
7.3.2 解决方案
7.4 门户使能器
7.4.1 问题
7.4.2 解决方案
7.5 快速概念验证
7.5.1 问题
7.5.2 解决方案
7.6 单点登录
7.6.1 问题
7.6.2 解决方案
7.7 构件使能器
7.7.1 问题
7.7.2 解决方案
第8章 测试模式
8.1 介绍
8.2 审计
8.2.1 问题
8.2.2 解决方案
8.3 负载测试
8.3.1 问题
8.3.2 解决方案
8.4 回归测试
8.4.1 问题
8.4.2 解决方案
第9章 反模式
9.1 介绍
9.2 瘦窗口
9.2.1 问题
9.2.2 草率的解决方案
9.2.3 诱人之处
9.2.4 纠正
9.3 喝海水
9.3.1 问题
9.3.2 草率的解决方案
9.3.3 诱人之处
9.3.4 纠正
9.4 惯偷
9.4.1 问题
9.4.2 草率的解决方案
9.4.3 诱人之处
9.4.4 纠正
9.5 影子集成
9.5.1 问题
9.5.2 草率的解决方案
9.5.3 诱人之处
9.5.4 纠正
9.6 肮脏的洗衣店
9.6.1 问题
9.6.2 草率的解决方案
9.6.3 诱人之处
9.6.4 纠正
9.7 打开和服
9.7.1 问题
9.7.2 草率的解决方案
9.7.3 诱人之处
9.7.4 纠正
9.8 昙花一现
9.8.1 问题
9.8.2 草率的解决方案
9.8.3 诱人之处
9.8.4 纠正
9.9 恶意的搭便车者
9.9.1 问题
9.9.2 草率的解决方案
9.9.3 诱人之处
9.9.4 纠正
第10章 最后总结
10.1 介绍
10.2 混搭二进制类型
10.3 安全性
10.3.1 阻止mashup
10.3.2 使mashup安全
10.4 结论
附录 企业案例研究
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Mashup模式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Android系统源代码情景分析（修订版）（含CD光盘1张）
罗升阳:1984年出生，2007年毕业于浙江大学计算机系，取得学士学位，2010年毕业于上海交通大学计算机系，取得硕士学位。毕业后一直从事于互联网软件开发，并且致力于移动平台的研究，特别是对Android平台有深入的理解和研究。在国内知名IT技术社区CSDN上发表了数十篇高质量的Android系统原创性文章，并且开设博客专栏--《老罗的Android之旅》，积极与网友互动，深受大家喜爱，访问量一直居于前茅。
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Android系统源代码情景分析（修订版）（含CD光盘1张）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>IT管理体系
第一章 IT管理体系发展概述第二章 IT治理第三章 IT组织结构第四章 CIO与IT人力资源管理第五章 IT战略第六章 企业架构第七章 IT投资管理第八章 IT项目管理第九章 IT服务管理第十章 IT外包管理第十一章 IT绩效管理第十二章 信息安全管理第十三章 IT风险管理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>IT管理体系
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js微服务
1　微服务架构	1
微服务应运而生	1
单块软件	2
现实世界中的微服务	2
面向微服务的架构	3
为什么面向微服务的架构更好	3
不足之处	3
关键设计原则	4
从组件到业务单元	5
智能的服务，愚蠢的通信管道	7
去中心化	8
技术对比	10
多微才是足够的微	10
关键的好处	11
弹性	11
可伸缩性	11
技术多样性	13
可替换性	14
独立性	15
SOA与微服务的比较	16
为什么选择Node.js	18
API聚合	18
展望Node.js	19
小结	20
2　基于Seneca和PM2构建Node.js微服务	21
选择Node.js的理由	21
安装Node.js、npm、Seneca和PM2	22
第一个程序——Hello World	25
Node.js的线程模型	27
模块化组织的最佳实践	27
微服务框架Seneca	32
实现控制反转	35
Seneca的模式匹配	35
PM2——Node.js的任务执行器	46
单线程应用及异常	46
PM2——业界标准的任务执行器	47
小结	52
3　从单块软件到微服务	53
首先，我们拥有一个单块软件	53
如何控制自然增长	54
多抽象才是过度抽象	57
微服务的出现	58
微服务的缺陷	64
分割单块软件	64
数据才是分割单块软件的主要问题	65
组织架构适配	66
小结	67
4　编写你的第一个Node.js微服务	69
微电子商务概览	69
商品管理服务——双重核心	71
获取商品信息	72
获取指定类别的商品	73
根据ID获取商品	74
添加商品	75
删除商品	75
编辑商品	76
整合各模块	76
集成Express与Seneca——如何创建REST API	81
邮件服务：一个常见的问题	82
如何发送邮件	82
接口定义	83
设置Mandrill	84
亲自动手在微服务中集成Mandrill	86
回退策略	91
订单管理服务	92
根据如何获取非本地数据来定义微服务	93
订单管理服务代码	95
UI——API聚合的产物	99
前端微服务的必要性	99
代码	99
服务降级——当出现非灾难性故障时	107
断路器	108
Seneca——一块使我们工作变得更容易的拼图	109
Seneca和promise	111
调试	115
小结	118
5　安全性和可追溯性	119
基础设施的逻辑安全	119
利用SSH来对通信加密	120
应用程序安全	122
保持安全方面的与时俱进来应对常见威胁	123
有效的代码审阅	131
可追溯性	132
日志	132
请求追踪	134
审计	135
HTTP状态码	136
小结	138
6　Node.js微服务的测试及文档化	140
功能性测试	141
自动化测试的金字塔	142
采用Node.js测试微服务	145
对微服务进行文档化	175
采用Swagger对API进行文档化	175
根据Swagger定义来生成项目	182
小结	184
7　微服务的监控	185
服务监控	185
采用PM2和Keymetrics进行监控	186
类人猿大军—来自Netflix的主动监控	201
吞吐量和性能的降级	204
小结	206
8　微服务的部署	208
软件部署的一些概念	208
持续集成	209
持续交付	209
采用PM2进行部署	209
PM2中的“生态系统”	210
采用PM2来部署微服务	212
Docker——一种可用于软件交付的容器	213
组装容器	215
部署Node.js应用	221
将Docker容器的创建过程自动化	223
Node.js事件循环—入门容易精通难	225
Node.js应用的集群化	228
为应用增加负载均衡	233
NGINX的健康检查	238
小结	239
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js微服务
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>OSGi与Equinox
第一部分　简介
第1章　OSGi、Equinox和Eclipse　　2
1.1 　简史　　2
1.2 　合作　　3
1.3 　实战的模块性和自由性　　4
1.4 　平台　　4
1.5 　生态系统　　5
1.6 　OSGi的来龙去脉　　5
1.6.1 　Java的谎言　　5
1.6.2 　现状核实　　6
1.6.3 　OSGi的寿命　　6
1.7 　实践中的OSGi和Equinox　　7
1.8 　总结　　8
第2章　OSGi基本概念　　9
2.1 　bundle环境　　9
2.2 　为何选择OSGi　　10
2.3 　bundle剖析　　13
2.4 　模块化　　14
2.4.1 　导出包　　14
2.4.2 　导入包　　14
2.4.3 　需要的bundle　　15
2.4.4 　强化模块化特性　　16
2.5 　模块化设计概念　　16
2.6 　生命周期　　17
2.7 　协作　　18
2.7.1 　服务　　18
2.7.2 　扩展和扩展点　　19
2.8 　OSGi框架　　20
2.9 　安全性　　20
2.10 　OSGi框架实现　　21
2.11 　总结　　21
第二部分　OSGi示例
第3章　教程介绍　　24
3.1 　何为Toast　　24
3.2 　Toast的演变　　26
3.3 　开发环境安装　　27
3.4 　示例代码　　28
3.4.1 　在章与章之间切换　　28
3.4.2 　比较　　29
3.5 　目标平台设置　　30
3.5.1 　预定义的目标　　31
3.5.2 　定义目标平台　　32
3.6 　通过示例进行学习　　35
3.7 　总结　　36
第4章　你好，Toast　　37
4.1 　简单的场景　　37
4.1.1 　创建工程　　37
4.1.2 　Gps　　38
4.1.3 　Airbag和IAirbagListener　　40
4.1.4 　EmergencyMonitor　　41
4.1.5 　Main　　43
4.1.6 　运行　　43
4.1.7 　检查点　　43
4.2 　将Toast划分为Bundle　　43
4.2.1 　GPS bundle　　45
4.2.2 　安全气囊bundle　　47
4.2.3 　紧急情况监视器bundle　　47
4.2.4 　启动　　49
4.3 　总结　　50
第5章　服务　　52
5.1 　转移到服务　　52
5.2 　注册GPS服务　　54
5.3 　注册安全气囊服务　　58
5.4 　获取服务示例代码　　61
5.5 　启动　　64
5.6 　故障排解　　64
5.7 　总结　　65
第6章　动态服务　　66
6.1 　动态服务简介　　66
6.2 　使用服务追踪器　　67
6.2.1 　修改bundle激活器　　67
6.2.2 　启动　　70
6.2.3 　服务追踪器小结　　72
6.3 　使用服务激活器工具包　　73
6.3.1 　在目标平台上安装SAT　　73
6.3.2 　修改GPS bundle激活器　　73
6.3.3 　修改安全气囊bundle激活器　　74
6.3.4 　修改紧急情况监视器bundle激活器　　74
6.3.5 　启动　　75
6.3.6 　SAT小结　　76
6.4 　使用声明式服务　　76
6.4.1 　修改GPS bundle　　77
6.4.2 　修改安全气囊bundle　　79
6.4.3 　修改紧急情况监视器bundle　　80
6.4.4 　运行　　82
6.4.5 　声明式服务总结　　83
6.5 　总结　　83
第7章　客户端/服务器端交互　　84
7.1 　后台　　84
7.1.1 　核心bundle　　84
7.1.2 　后台应急bundle　　85
7.2 　客户端　　88
7.2.1 　信道bundle　　88
7.2.2 　紧急情况监视器bundle　　92
7.3 　工具类　　94
7.3.1 　常量　　94
7.3.2 　属性　　94
7.3.3 　日志　　95
7.4 　运行Toast　　95
7.4.1 　运行后台　　96
7.4.2 　运行客户端　　97
7.5 　总结　　97
第8章　测试　　99
8.1 　使Toast具备可测试性　　99
8.2 　对Toast进行单元测试　　100
8.2.1 　测试方案　　100
8.2.2 　编写测试用例　　101
8.2.3 　运行单元测试　　103
8.3 　系统测试Toast　　104
8.3.1 　测试规划　　104
8.3.2 　创建测试工具　　105
8.3.3 　编写测试用例　　107
8.3.4 　运行系统测试　　110
8.4 　总结　　111
第9章　打包　　112
9.1 　定义Toast产品　　112
9.1.1 　创建产品配置　　112
9.1.2 　概述页　　114
9.1.3 　依赖页　　115
9.1.4 　配置页　　116
9.1.5 　启动页　　116
9.1.6 　运行产品　　118
9.1.7 　产品化客户端　　118
9.2 　导出Toast　　118
9.3 　为其他平台打包　　121
9.4 　认真考虑组件定义　　123
9.4.1 　版本和版本范围　　123
9.4.2 　导出包和友元　　124
9.5 　总结　　126
第10章　插件化服务　　127
10.1 　分离接口与接口的实现　　127
10.1.1 　将Fake Airbag与其接口相互分离　　128
10.1.2 　将模拟GPS与其接口相分离　　129
10.1.3 　回归测试　　129
10.2 　设备模拟　　130
10.2.1 　概念　　130
10.2.2 　设备模拟器框架　　131
10.3 　作为插件式服务的模拟设备　　131
10.3.1 　模拟安全气囊　　131
10.3.2 　模拟GPS　　133
10.4 　运行模拟设备　　134
10.5 　总结　　135
第11章　可扩展的用户界面　　136
11.1 　Crust　　136
11.1.1 　Crust shell　　136
11.1.2 　Crust工具　　137
11.2 　紧急情况处理　　138
11.2.1 　创建可插拔的用户界面　　138
11.2.2 　重构紧急情况处理业务逻辑　　139
11.2.3 　紧急情况处理用户界面　　140
11.2.4 　运行用户界面　　141
11.3 　车载气候系统和音响系统　　142
11.3.1 　车载气候系统与音响设备　　142
11.3.2 　空调和音响屏幕　　144
11.3.3 　运行用户界面　　144
11.4 　OSGi应用模型　　145
11.5 　导航和地图　　148
11.5.1 　谷歌地球集成　　148
11.5.2 　地图支持　　151
11.5.3 　应用可扩展性和导航支持　　152
11.5.4 　运行用户界面　　152
11.6 　总结　　154
第12章　动态配置　　155
12.1 　跟踪场景　　155
12.2 　安装跟踪代码　　156
12.2.1 　Core Tracking Bundle　　156
12.2.2 　后台跟踪bundle　　157
12.2.3 　客户端跟踪bundle　　157
12.3 　运行基本的跟踪场景　　158
12.4 　配置　　159
12.4.1 　OSGi的管理控制　　159
12.4.2 　客户端跟踪bundle　　159
12.4.3 　运行可配置的Toast　　161
12.4.4 　具备持久化配置的运行　　162
12.5 　总结　　162
第13章　Web门户　　163
13.1 　门户　　163
13.2 　PortalServlet　　164
13.3 　使用服务进行操作查询　　165
13.4 　声明门户操作　　168
13.5 　白板模式的利与弊　　170
13.6 　总结　　170
第14章　使用p2进行系统开发　　171
14.1 　Equinox p2 简介　　171
14.1.1 　架构　　172
14.1.2 　p2元数据——可安装的单元　　172
14.1.3 　组件　　173
14.1.4 　仓库　　173
14.1.5 　模式　　174
14.1.6 　指挥者　　174
14.1.7 　引擎　　174
14.2 　细化Toast结构　　174
14.2.1 　使用特性定义产品　　175
14.2.2 　后台特性　　175
14.2.3 　客户端特性　　177
14.2.4 　重构小结　　180
14.3 　编写一个配置器　　180
14.3.1 　配置器　　181
14.3.2 　配置后台　　184
14.3.3 　后台小结　　184
14.4 　增加一个Web部署页面　　184
14.4.1 　创建动作　　185
14.4.2 　管理动作　　185
14.4.3 　安装卸载动作　　186
14.4.4 　安装配置UI　　186
14.5 　导出、运行以及配置　　186
14.5.1 　引入一个p2仓库　　186
14.5.2 　运行Toast后台　　189
14.5.3 　创建并配置汽车　　190
14.6 　客户端动态部署　　191
14.7 　总结　　192
第三部分　进阶篇
第15章　声明式服务　　194
15.1 　声明式服务模型　　194
15.2 　常见场景　　195
15.2.1 　最简单的组件　　195
15.2.2 　引用服务　　197
15.2.3 　提供服务　　198
15.2.4 　引用和提供服务　　199
15.2.5 　立刻激活组件　　201
15.2.6 　白板模式　　202
15.2.7 　工厂组件　　207
15.3 　启动和调试DS应用　　213
15.4 　PDE工具　　214
15.5 　总结　　216
第16章　扩展　　217
16.1 　扩展注册　　217
16.2 　扩展点　　219
16.3 　扩展　　221
16.4 　高级扩展主题　　222
16.4.1 　扩展ID　　222
16.4.2 　命名扩展和匿名扩展　　222
16.4.3 　扩展工厂　　223
16.5 　扩展注册机制的生命周期　　223
16.6 　动态扩展的应用场景　　224
16.6.1 　场景一：没有缓存　　225
16.6.2 　场景二：缓存扩展　　225
16.6.3 　场景三：缓存对象　　227
16.7 　服务与扩展　　229
16.8 　扩展注册的神话　　231
16.9 　总结　　231
第17章　日志　　232
17.1 　日志服务规范　　232
17.1.1 　日志级别　　232
17.1.2 　记录日志　　233
17.1.3 　读取日志　　233
17.1.4 　监听日志　　234
17.2 　在Toast中使用LogService　　234
17.3 　使用LogReaderService　　237
17.4 　Toast的LogUtility类　　239
17.5 　Equinox的LogService实现　　240
17.6 　总结　　242
第18章　HTTP支持　　243
18.1 　HttpService　　243
18.2 　注册和注销Servlet　　245
18.3 　声明式HTTP内容注册　　248
18.4 　使用Jetty　　248
18.5 　HTTP上下文和JAAS集成　　249
18.5.1 　基于HTTP的认证和登录　　249
18.5.2 　运行具备安全机制的客户端　　252
18.6 　疑难解答　　253
18.6.1 　BindException　　253
18.6.2 　HttpService在监听哪个端口　　253
18.7 　总结　　254
第19章　服务器端　　255
19.1 　服务器端和OSGi　　255
19.2 　在Web应用中嵌入Toast后台系统　　257
19.2.1 　更新产品　　257
19.2.2 　Web应用的Root文件　　259
19.2.3 　构建Web应用　　261
19.2.4 　运行Web应用　　262
19.2.5 　疑难解答　　264
19.2.6 　<init-param>参数说明　　265
19.3 　OSGi中的远程服务　　265
19.3.1 　Eclipse通信框架　　266
19.3.2 　远程服务　　266
19.3.3 　分布式Toast　　266
19.3.4 　远程服务主机　　267
19.3.5 　远程服务客户端　　268
19.3.6 　服务发现　　269
19.3.7 　运行分布式系统　　270
19.4 　总结　　271
第20章　发布工程　　272
20.1 　什么是PDE构建　　272
20.2 　build.properties bundle　　273
20.2.1 　控制属性　　274
20.2.2 　使用自定义构建脚本　　275
20.3 　创建构建器　　275
20.3.1 　调整PDE构建的目标　　276
20.3.2 　build.properties　　276
20.4 　运行构建器　　279
20.5 　调整构建　　282
20.5.1 　自定义构建脚本　　282
20.5.2 　仓库和附加依赖项　　283
20.5.3 　从SCM（软件配置管理）系统中提取内容　　283
20.5.4 　获取map文件　　285
20.5.5 　自动替换版本号　　286
20.5.6 　设定版本号　　286
20.5.7 　定位和放置根目录文件　　287
20.6 　构建附加特征　　288
20.6.1 　创建特征构建器　　288
20.6.2 　build.properties　　288
20.6.3 　运行特征构建　　290
20.7 　构建WAR包　　291
20.8 　总结　　291
第四部分　参考篇
第21章　动态性的最佳实践　　294
21.1 　动态性与你　　294
21.2 　Toast的动态性　　295
21.3 　动态性的挑战　　296
21.4 　动态性意识　　297
21.4.1 　对象处理　　298
21.4.2 　bundle监听器　　299
21.5 　扩展者模式和BundleTracker　　300
21.6 　动态性启用　　300
21.7 　启动和停止的动态性　　302
21.7.1 　启动级别　　303
21.7.2 　正确使用服务　　304
21.7.3 　关闭也不总是易事　　304
21.8 　总结　　305
第22章　整合代码库　　306
22.1 　bundle形式的JAR　　306
22.2 　采用注入的方式进行bundle化　　307
22.3 　通过包装的方式进行bundle化　　309
22.4 　通过引用的方式进行bundle化　　310
22.5 　使用bnd进行bundle化　　312
22.6 　解决类加载问题　　312
22.6.1 　Class.forName()　　312
22.6.2 　与上下文类加载器有关的问题　　316
22.6.3 　管理JRE类　　317
22.6.4 　序列化　　318
22.7 　总结　　318
第23章　高级主题　　319
23.1 　Equinox控制台　　319
23.2 　OSGi中的角色　　322
23.3 　bundle的形态　　323
23.4 　片段　　325
23.5 　单例　　327
23.6 　bundle生命周期　　328
23.6.1 　生命周期状态　　328
23.6.2 　BundleActivator　　329
23.6.3 　激活器的弊端　　330
23.6.4 　激活器的使用　　330
23.7 　bundle激活策略　　331
23.8 　控制bundle启动　　332
23.8.1 　持久化启动　　332
23.8.2 　启用激活策略　　333
23.8.3 　osgi.bundles　　333
23.9 　类加载　　334
23.9.1 　类查找算法　　334
23.9.2 　声明导入和导出　　335
23.9.3 　导入包与需要的bundle　　335
23.9.4 　可选性　　336
23.9.5 　use指令　　336
23.9.6 　再导出　　337
23.9.7 　x-internal和x-friends　　337
23.9.8 　引导代理　　337
23.10 　配置和运行Equinox　　338
23.10.1 　config.ini　　338
23.10.2 　可执行程序　　339
23.11 　数据区　　341
23.12 　总结　　343
第24章　声明式服务引用　　344
24.1 　组件XML模式v1.0.0　　344
24.1.1 　声明XML的命名空间和模式　　344
24.1.2 　<component>元素　　345
24.1.3 　<implementation>元素　　347
24.1.4 　<property>元素　　347
24.1.5 　<properties>元素　　348
24.1.6 　<service>元素　　349
24.1.7 　<provide>元素　　349
24.1.8 　<reference>元素　　349
24.2 　组件的生命周期　　351
24.2.1 　满足组件的配置　　351
24.2.2 　组件的激活、注销与修改　　353
24.2.3 　访问引用服务　　355
24.2.4 　组件的即时性　　357
24.2.5 　组件属性　　357
24.3 　总结　　359
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>OSGi与Equinox
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件可靠性工程
译者序
前言
第1章 软件可靠性工程概论
第2章 定义必要的可靠性
第3章 开发操作剖面
第4章 测试准备
第5章 执行测试
第6章 将失效数据应用于指导决策
第7章 部署软件可靠性工程
第8章 软件可靠性模型
附录A 软件可靠性工程过程步骤
附录B 研讨会模板
附录C 术语表
附录D 有用公式小结
……
参考文献

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件可靠性工程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实战Windows Azure
目    录
第1章  云计算技术简介	1
1.1  云计算所要解决的问题	2
1.2  云计算平台的分类	4
1.3  微软云计算平台Windows Azure	5
1.3.1  高可用性	5
1.3.2  易于部署和伸缩	6
1.3.3  全球化	6
1.3.4  开发语言和开发模型	7
第2章  Windows Azure云计算平台	9
2.1  Windows Azure平台的组成部分和主要功能	9
2.1.1  Windows Azure	10
2.1.2  Windows Azure相关名词	11
2.1.3  SQL Azure	15
2.1.4  Windows Azure AppFabric	16
2.1.5  Windows Azure Connect	17
2.2  Windows Azure收费模式	18
2.2.1  Windows Azure账户	18
2.2.2  Windows Azure的计费模式	19
2.3  Windows Azure平台成本及性能案例分析	21
2.3.1  北欧某健康资讯网站	22
2.3.2  挪威某零售业管理系统	23
2.3.3  XLR8企业应用平台	24
第3章  Windows Azure计算服务	25
3.1  准备Windows Azure开发环境	25
3.2  第一个Windows Azure应用程序	28
3.2.1  创建Cloud Project和Web Role	28
3.2.2  使用本地模拟器运行和调试Azure应用程序	30
3.2.3  购买Windows Azure	32
3.2.4  通过Developer Portal创建Hosted Service	34
3.2.5  向Staging环境部署Windows Azure应用	39
3.2.6  向Production环境切换	43
3.3  Windows Azure项目组成	45
3.3.1  Windows Azure Project介绍	45
3.3.2  Role及其生命周期模型	54
3.3.3  Configuration的变更和通知机制	58
3.3.4  Windows Azure本地模拟器	62
第4章  Windows Azure存储服务	64
4.1  创建新的Storage Service	65
4.2  使用Table Service	68
4.2.1  Table Service的特点	69
4.2.2  使用Table Storage保存相册信息	72
4.2.3  基于Repository模式的Table Service数据访问层	89
4.2.4  使用Table Service的事务操作	96
4.3  使用BLOB Service	101
4.3.1  BLOB Service的特点	102
4.3.2  使用BLOB Service保存照片	107
4.3.3  使用Shared Access Signatures	119
4.3.4  使用Cloud Drive	123
4.4  使用Queue Service	131
4.4.1  Queue Service的组成及特点	131
4.4.2  在创建照片部分加入生成缩略图的Queue Message	133
4.4.3  创建生成缩略图的Worker Role	135
4.4.4  实现生成缩略图操作	137
第5章  Windows Azure部署与管理	146
5.1  使用Visual Studio部署Azure应用	146
5.1.1  Windows Azure Management API介绍	146
5.1.2  配置Management API证书	149
5.1.3  通过Visual Studio部署	153
5.2  管理Windows Azure	156
5.2.1  Windows Azure平台高可用性的实现	156
5.2.2  部署与就地升级	158
5.2.3  VIP转换	158
5.2.4  Windows Azure平台的管理工具	159
5.3  使用Windows Azure诊断服务	170
5.3.1  Diagnostics Monitor介绍	171
5.3.2  通过代码启动Diagnostics Monitor	174
5.3.3  通过代码配置Diagnostics Monitor	177
5.3.4  通过远程API配置Diagnostics Monitor	181
5.3.5  使用NLog扩展在Windows Azure平台输出日志	185
5.3.6  使用Intellitrace获取异常信息	190
5.4  回顾与总结	194
第6章  SQL Azure	196
6.1  SQL Azure特点	197
6.1.1  易于维护和高可用性	197
6.1.2  弹性和伸缩性	197
6.1.3  开发方式的一贯性	198
6.2  SQL Azure的订阅模式	198
6.3  SQL Azure服务器端架构	199
6.4  SQL Azure与SQL Server的差异	201
6.5  创建SQL Azure服务	202
6.5.1  创建SQL Azure Server	203
6.5.2  通过Developer Portal创建数据库	205
6.6  使用工具管理SQL Azure	207
6.6.1  使用SQL Server Management Studio管理SQL Azure	207
6.6.2  使用Project Houston管理SQL Azure	210
6.7  使用SQL Azure	213
6.7.1  创建Aurora的SQL Azure数据库	214
6.7.2  向SQL Azure导入数据	217
6.7.3  在应用程序中使用SQL Azure	220
6.7.4  基于Windows Azure和SQL Azure的开发部署流程	224
6.8  回顾与总结	226
第7章  Windows Azure Appfabric	227
7.1  服务总线（Service Bus）	228
7.1.1  Service Bus的工作方式	229
7.1.2  使用Service Remoting开放本地的地理位置服务	232
7.1.3  使用Eventing模式	241
7.1.4  配置Service Bus运行环境	246
7.2  访问控制服务（Access Control Service）	247
7.2.1  访问控制服务的原理	248
7.2.2  为地理位置服务加入访问控制	250
7.3  回顾与总结	260
第8章  Windows Azure平台高级应用	261
8.1  Role Endpoint和内部通信	261
8.1.1  Role Endpoint介绍	262
8.1.2  基于Input Endpoint通过Worker Role发布WCF服务	263
8.1.3  动态指定WCF的发布地址	266
8.1.4  使用Internal Endpoint实现Role的内部通信	269
8.1.5  总结	272
8.2  通过远程桌面功能访问Windows Azure的虚拟机	273
8.2.1  通过Visual Studio配置远程桌面功能	273
8.2.2  总结	278
8.3  通过Windows Azure Connect实现本地计算机和云端虚拟机的互连	279
8.3.1  什么是Windows Azure Connect	279
8.3.2  申请Windows Azure Beta Program	281
8.3.3  将本地计算机和Azure VM加入Connect	281
8.3.4  Windows Azure Connect的功能	286
8.4  Web Role的Full IIS特性	289
8.4.1  基于Hosted Web Core方式部署Web Role	289
8.4.2  基于Full IIS部署Web Role	291
8.4.3  使用Full IIS时的注意事项	293
8.4.4  使用Full IIS模式部署多站点和虚拟目录	294
8.4.5  总结	297
8.5  通过Startup功能实现COM组件调用	298
8.5.1  使用Startup功能执行简单的命令	298
8.5.2  Startup配置项介绍	300
8.5.3  使用Startup功能注册COM组件	300
8.6  使用Windows Azure CDN	302
8.6.1  Windows Azure CDN的原理	302
8.6.2  使用Blob Service CDN	306
8.6.3  使用Hosted Service CDN	309
8.6.4  总结	312
8.7  云端的分布式缓存服务AppFabric Cache	312
8.7.1  缓存与分布式缓存	312
8.7.2  创建Windows Azure Appfabric Cache	314
8.7.3  使用Windows Azure AppFabric Cache	316
8.7.4  总结	323
8.8  Access Control Service 2.0	324
8.8.1  ACS v2和统一认证	324
8.8.2  ACS v2的认证流程	326
8.8.3  基于Live ID和Google ID的ASP.NET MVC网站	329
8.8.4  控制ACS的验证逻辑	337
8.9  云端的报表：SQL Azure Reporting CTP	344
8.10  为SQL Azure实现备份和恢复功能	352
8.10.1  使用Database Copy	353
8.10.2  使用Data-tier Application Framework 2.0	355
8.10.3  使用SQL Azure Data Sync CTP	363
8.10.4  三种SQL Azure备份恢复实现的对比	370
8.11  基于SQL Azure数据库的Odata服务	370
8.12  Windows Azure与扩展性	373
8.12.1  横向扩展和纵向扩展	374
8.12.2  应用程序层的横向扩展	376
8.12.3  数据层的横向扩展	380
8.12.4  SQL Azure Federation预览	385
8.12.5  总结	389
8.13  异步工作模型	390
8.13.1  什么是异步工作模型	390
8.13.2  Windows Azure中的异步工作模型	393
8.13.3  在Aurora项目中实现异步工作模型	400
8.13.4  总结	411
本书参考资料	412
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>实战Windows Azure
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>技术团队启示录:TOP100实践案例
第1篇 产品创新/用户体验 1
产品技术之道—漫谈UC浏览器 2
“车机”用户体验研究及设计 5
与海外高端运营商联合创新—中兴设计实践 13
借力商业技术于空间机器人 21
Netflix在亚马逊AWS云平台上的应用和创新案例 26
第2篇 团队管理/组织发展 33
快速提升初建团队需求分析能力 34
大型研发团队的知识管理实践 38
自组织团队的实践与讨论 43
从绩效考核到绩效管理 50
IT技术团队管理中的反激励和应对措施 56
游戏式管理系统—盛大网络的管理方法 62
全球研发中心创新实践—解读惠普全球研发管理方法 69
一个跨国银行的敏捷转型 73
敏捷驱动—方正新产品研发的敏捷之道 80
第3篇 架构设计/技术战略 87
从零开始搭建大数据平台—乐视网TV开放平台构建总结 88
大数据下的OLAP平台构建实践—腾云天下OLAP平台构建总结 101
云计算的前世今生—微软首席安全架构师看云计算 105
有道云笔记的云端架构设计—有道云笔记开发体会 114
百万账户同时在线的58即时通信系统架构—58帮帮开发总结 118
海量实时记录的快速索引方法 123
打造端到端的智能设备安全解决方案—联想解决终端问题总结 132
第4篇 设计匠艺/流程再造 143
持续交付是由问题倒逼而产生—豆瓣网持续交付实践总结 144
集成与交付方案目标—去哪儿网快速开发实践总结 148
如何进行多终端Web前端优化—QQ互联多终端前端优化实践总结 156
淘宝定向广告算法创新案例介绍—淘宝网广告创新算法总结 162
TCPCOPY击败DOUBLE CLICK的利器—网易广告投放系统开发实践总结 166
柔性流程设计—一种真正面向业务价值的软件开发过程体系 171
使用Adobe AIR进行跨平台桌面软件开发 176
基于ZooKeeper和Storm的车载流式计算框架—富士通实践总结 182
程序蓝图可视自动化逆向工程技术 187
敏捷转型初体验—开发自测实践 196
第5篇 测试管理/质量平台 203
使用Javascript创建测试文化—谷歌的测试文化 204
基于Java Script产品的TA框架的六次改进—支付宝无线统一测试平台 211
从25个月到10个月—移动终端产品的精益方法质量保证实践 218
接口自动化测试方案及平台—飞信项目接口测试实践 222
敏捷的Web UI自动化测试框架 229
面向对象在自动化UI测试中的应用 234
人工智能技术在UI自动化测试中的应用 239
H3C多层次自动化拦截体系—数通自动化运用模式介绍 244
构筑系统的Web安全性测试体系 250
基于持续交付的移动互联应用测试平台 263
TCL嵌入式测试技术在网络设备测试中的应用 266
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>技术团队启示录:TOP100实践案例
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Akka应用模式：分布式应用程序设计实践指南
前言 .......................................................................................... xvii
第1 章 Actor 模型 ........................................................................1
现实是最终一致的 .................................................................................................1
解构Actor 模型 .....................................................................................................3
所有的计算都在一个actor 中执行 .........................................................................4
actor 之间只能通过消息进行通信 .........................................................................5
actor 可以创建子actor ...........................................................................................6
actor 可以改变自己的状态或行为 .........................................................................8
一切都是actor .......................................................................................................9
Actor 模型的使用 .................................................................................................10
定义清晰的边界 ................................................................................................... 11
何时适合使用Actor 模型 ....................................................................................13
结论 .....................................................................................................................13
第2 章 Akka 简介 .......................................................................15
Akka 是什么......................................................................................................... 15
Akka 是开源的 .............................................................................................. 15
Akka 正在蓬勃发展 .......................................................................................16
Akka 是为分布式设计的 ...............................................................................16
Akka 组件 ............................................................................................................17
Akka actor .....................................................................................................17
子actor .......................................................................................................... 18
remoting ：不同JVM 上的actor ....................................................................20
clustering ：集群成员的自动化管理 ..............................................................20
Akka HTTP ...................................................................................................24
TestKit ........................................................................................................... 25
contrib ........................................................................................................... 25
Akka OSGi ................................................................................................... 25
Akka HTTP ...................................................................................................26
Akka Streams ................................................................................................26
Akka 实现的Actor 模型 ......................................................................................26
Actor 模型中的Akka actor ..................................................................................26
消息传递 .......................................................................................................27
actor 系统 ...................................................................................................... 28
Akka Typed 项目 .................................................................................................. 28
结论 ....................................................................................................................29
第3 章 分布式领域驱动设计 ........................................................31
DDD 概述 ............................................................................................................31
DDD 的好处 .........................................................................................................32
DDD 组件 ............................................................................................................33
域实体 ..................................................................................................................34
域值对象 .............................................................................................................34
聚合与聚合根 ..................................................................................................... 35
仓储 .....................................................................................................................37
工厂和对象创建 ................................................................................................... 38
域服务 .................................................................................................................. 38
有界上下文 ..........................................................................................................39
结论 ....................................................................................................................41
第4 章 优秀的Actor 设计 ...........................................................43
大系统小做 ..........................................................................................................43
封装actor 中的状态 ............................................................................................44
使用字段封装状态 .......................................................................................44
使用“状态”容器封装状态 ........................................................................47
使用become 封装状态 ................................................................................. 48
将futures 与actors 混合 ............................................................................... 50
Ask 模式和替代方案 ............................................................................................ 54
Ask 模式的问题 ........................................................................................... 55
附带的复杂性 ................................................................................................ 57
Ask 的替代方案 ........................................................................................... 57
命令与事件 .......................................................................................................... 59
构造函数的依赖注入 ....................................................................................61
使用路径查找actor ......................................................................................61
结论 ....................................................................................................................62
第5 章 数据流 ............................................................................63
吞吐量与延迟 ......................................................................................................63
流 .........................................................................................................................64
路由器 ..................................................................................................................66
邮箱 ..................................................................................................................... 68
无界邮箱 ...................................................................................................... 68
有界邮箱 ......................................................................................................69
拉取的工作模式 ..................................................................................................70
背压 .....................................................................................................................73
ack .................................................................................................................73
高水位标记 ...................................................................................................73
队列长度监控 ................................................................................................74
速率监控 ......................................................................................................74
Akka 数据流.........................................................................................................74
源 .................................................................................................................. 75
汇 ..................................................................................................................77
RunnableGraph ............................................................................................. 78
流 ..................................................................................................................79
交叉点 ........................................................................................................... 80
Akka 流中的背压 ......................................................................................... 81
Akka 流的使用 ............................................................................................. 82
结论 .................................................................................................................... 84
第6 章 一致性和可扩展性 ...........................................................85
事务和一致性 ...................................................................................................... 85
强一致性与最终一致性 ....................................................................................... 86
并发性与并行性 ................................................................................................... 86
为什么全局一致的分布式状态影响可扩展性 ...................................................... 86
位置透明性 ......................................................................................................... 87
交付保证 ............................................................................................................. 87
最多投递一次 ................................................................................................ 87
最少投递一次 ................................................................................................ 88
恰好一次交付是不可能的（但可以近似做到） .............................................91
如何近似做到恰好一次交付 .........................................................................91
集群单例 .......................................................................................................92
可扩展性 ..............................................................................................................94
避免全局状态 ............................................................................................... 98
避免共享状态 ............................................................................................... 98
遵循Actor 模型 .............................................................................................99
避免顺序操作 ...............................................................................................99
隔离阻塞型操作 ...........................................................................................99
监控和调优 ..................................................................................................99
集群分片和一致性 ...............................................................................................99
分片 ............................................................................................................. 100
Akka 中的分片 ........................................................................................... 101
分片键的生成 ............................................................................................. 102
分片的分布 ................................................................................................ 103
一致性边界 ................................................................................................. 103
可扩展性边界 ............................................................................................. 104
分片聚合根 ................................................................................................ 105
持久化 ......................................................................................................... 106
钝化 ............................................................................................................. 106
使用集群分片保证一致性 ........................................................................... 107
结论 .................................................................................................................. 109
第7 章 容错 .............................................................................111
故障类型 ........................................................................................................... 112
异常 ............................................................................................................ 112
JVM 中的致命错误 .................................................................................... 113
外部服务故障 ............................................................................................. 113
不符合服务等级协议 .................................................................................. 113
操作系统和硬件级故障 .............................................................................. 114
故障隔离 ........................................................................................................... 114
舱壁模式 .................................................................................................... 114
优雅降级 ..................................................................................................... 117
使用Akka 集群隔离故障 ............................................................................ 119
使用熔断器控制故障 ................................................................................... 119
故障处理 ............................................................................................................ 122
异常处理 ..................................................................................................... 123
外部服务的故障处理 .................................................................................. 128
结论 ................................................................................................................... 131
第8 章 可用性 ..........................................................................133
微服务和单体式应用 ........................................................................................ 133
用有界上下文划分微服务 ................................................................................. 134
细粒度的微服务 ................................................................................................. 135
集群感知路由器 ................................................................................................. 135
分布式数据 ....................................................................................................... 137
优雅降级 ............................................................................................................ 140
部署 ................................................................................................................... 141
分阶段部署/ 滚动重启 ..................................................................................... 142
蓝/ 绿部署 ........................................................................................................ 142
崩溃恢复/ 运维监测 ......................................................................................... 143
健康检查和应用状态页面 .......................................................................... 143
度量 ............................................................................................................ 145
日志 ............................................................................................................. 146
看门狗工具 ................................................................................................. 146
结论 .................................................................................................................. 147
第9 章 性能 ...........................................................................149
隔离瓶颈 ........................................................................................................... 150
优化Akka ......................................................................................................... 150
减少或隔离阻塞型操作 .............................................................................. 150
缩短消息处理时间 ...................................................................................... 151
增加处理消息的actor ................................................................................ 151
派发器 ................................................................................................................ 151
标准派发器 ................................................................................................. 151
固定派发器 ................................................................................................. 153
平衡派发器 ................................................................................................ 154
calling-thread 派发器 .................................................................................. 154
何时使用单独的派发器 .............................................................................. 155
提高并行性 ................................................................................................ 157
结论 .................................................................................................................. 158
后记 ..........................................................................................159
参考文献 ...................................................................................161
关于作者 ...................................................................................162
封面介绍 ...................................................................................163
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Akka应用模式：分布式应用程序设计实践指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通.NET核心技术
第1章  . NET和. NET框架概览
1. 1  什么是. NET
1. 2  什么是. NET框架
1. 2. 1  公共语言运行库的功能
1. 2. 2  . NET框架类库

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通.NET核心技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务设计模式和最佳实践
目录
第1章 微服务概念 1
1.1 理解应用程序 2
1.1.1 领域驱动设计 2
1.1.2 单一职责原则 4
1.1.3 显式发布的接口 5
1.2 独立部署、更新、扩展以及替换 7
1.2.1 独立部署 7
1.2.2 更新 7
1.2.3 可扩展性 8
1.3 轻量级通信 12
1.3.1 同步 13
1.3.2 异步 13
1.4 异质/多语言 14
1.5 通信的文档化 14
1.6 Web应用程序端点 15
1.7 移动应用程序端点 15
1.8 缓存客户端 16
1.9 调节客户端 17
1.10 确定贫血域 17
1.11 确定fat域 18
1.12 针对业务确定微服务域 18
1.13 从域到实体 19
1.14 本章小结 20
第2章 微服务工具 21
2.1 编程语言 21
2.1.1 熟练程度 22
2.1.2 性能 22
2.1.3 实践开发 23
2.1.4 生态圈 23
2.1.5 扩展性的开销 24
2.1.6 选取编程语言 24
2.2 微服务框架 27
2.2.1 Python语言 27
2.2.2 Go语言 29
2.3 二进制通信—服务间的直接通信 31
2.3.1 理解通信方式 31
2.3.2 直接通信间的警示信息 35
2.4 消息代理—服务间的异步通信 37
2.4.1 ActiveMQ 38
2.4.2 RabbitMQ 39
2.4.3 Kafka 40
2.5 缓存工具 40
2.5.1 Memcached 42
2.5.2 Redis 42
2.6 故障警示工具 44
2.6.1 性能 44
2.6.2 构建 45
2.6.3 组件 46
2.6.4 实现鸿沟 47
2.7 数据库 47
2.8 本地性能度量 48
2.8.1 Apache Benchmark 49
2.8.2 WRK 50
2.8.3 Locust 51
2.9 本章小结 53
第3章 内部模式 55
3.1 开发结构 55
3.1.1 数据库 55
3.1.2 编程语言和工具 56
3.1.3 项目结构 56
3.2 缓存策略 71
3.2.1 缓存机制的应用 72
3.2.2 缓存优先 78
3.2.3 队列任务 79
3.2.4 异步机制和worker 81
3.3 CQRS—查询策略 87
3.3.1 CQRS的概念 87
3.3.2 理解CQRS 88
3.3.3 CQRS的优点和缺陷 90
3.4 事件源—数据完整性 91
3.5 本章小结 92
第4章 微服务生态环境 93
4.1 容器中的分离机制 93
4.1.1 分层服务架构 95
4.1.2 分离UsersService 96
4.2 存储分布 103
4.2.1 折旧数据 103
4.2.2 区域化数据 103
4.3 隔离—使用生态系统防止故障的出现 104
4.3.1 冗余设计 104
4.3.2 临界分区 109
4.3.3 隔离设计 110
4.3.4 快速故障 111
4.4 断路器 112
4.5 本章小结 113
第5章 共享数据微服务设计模式 115
5.1 理解模式 115
5.2 将单体应用程序划分为微服务 116
5.2.1 定义优先级 117
5.2.2 设置期限 117
5.2.3 定义应用程序域 117
5.2.4 试验操作 117
5.2.5 制定标准 118
5.2.6 构建原型 118
5.2.7 发送产品 118
5.2.8 开发新的微服务 118
5.3 数据编排 130
5.4 响应整合 132
5.5 微服务通信 132
5.6 存储共享反模式 133
5.7 最佳实践 133
5.8 测试机制 133
5.9 共享数据模式的利弊 135
5.10 本章小结 136
第6章 聚合器微服务设计模式 137
6.1 理解聚合器设计模式 137
6.2 使用CQRS和事件源 139
6.2.1 分离数据库 139
6.2.2 重构微服务 140
6.3 微服务通信 153
6.3.1 创建编排器 154
6.3.2 使用消息代理 159
6.4 模式扩展 163
6.5 瓶颈反模式 164
6.6 最佳实践 166
6.7 测试 167
6.7.1 功能测试 167
6.7.2 集成测试 168
6.8 聚合器设计模式的优缺点 170
6.8.1 聚合器设计模式的优点 170
6.8.2 聚合器设计模式的缺点 170
6.9 本章小结 170
第7章 代理微服务设计模式 171
7.1 代理方案 171
7.1.1 哑代理 172
7.1.2 智能代理 172
7.1.3 理解当前代理 173
7.2 编排器的代理策略 175
7.3 微服务通信 176
7.4 模式扩展性 176
7.5 最佳实践 177
7.5.1 纯粹的模式 177
7.5.2 瓶颈问题 178
7.5.3 代理制的缓存机制 178
7.5.4 简单的响应 178
7.6 代理设计模式的优缺点 179
7.7 本章小结 179
第8章 链式微服务设计模式 181
8.1 理解模式 181
8.2 数据编排和响应整合 184
8.3 微服务通信 185
8.4 模式扩展性 185
8.5 “大泥球”反模式 186
8.6 最佳实践方案 188
8.6.1 纯微服务 188
8.6.2 请求一致性数据 188
8.6.3 深入理解链式设计模式 189
8.6.4 关注通信层 189
8.7 链式设计模式的优缺点 189
8.8 本章小结 190
第9章 分支微服务设计模式 191
9.1 理解模式 191
9.2 数据编排和响应整合 194
9.3 微服务通信 195
9.4 模式扩展 197
9.5 最佳实践方案 198
9.5.1 域定义 198
9.5.2 遵守规则 198
9.5.3 关注物理组件 198
9.5.4 简化行为 199
9.6 分支设计模式的优缺点 199
9.7 本章小结 199
第10章 异步消息微服务 201
10.1 理解当前模式 201
10.2 域定义—RecommendationService 203
10.3 域定义—RecommendationService 204
10.4 微服务编码 204
10.5 微服务通信 211
10.5.1 使用消息代理和队列 211
10.5.2 准备pub/sub结构 212
10.6 模式的可扩展性 214
10.7 进程序列反模式 214
10.8 最佳实践方案 215
10.8.1 应用程序定义 215
10.8.2 不要尝试创建响应 216
10.8.3 保持简单性 216
10.9 异步消息传递设计模式的优缺点 216
10.10 本章小结 217
第11章 微服务间的协同工作 219
11.1 理解当前应用程序状态 219
11.1.1 公共饰面层 220
11.1.2 内部层 222
11.1.3 理解通用工具 223
11.2 通信层和服务间的委托 224
11.2.1 理解服务间的数据合约 225
11.2.2 使用二进制通信 228
11.3 模式分布 235
11.4 故障策略 236
11.5 API集成 237
11.6 本章小结 239
第12章 微服务测试 241
12.1 单元测试 241
12.2 针对集成测试配置容器 249
12.3 集成测试 251
12.4 端到端测试 253
12.5 发布管线 259
12.6 签名测试 259
12.7 Monkey测试 260
12.8 Chaos Monkey 260
12.9 本章小结 262
第13章 安全监测和部署方案 263
13.1 监测微服务 263
13.1.1 监测单一服务 264
13.1.2 监测多项服务 266
13.1.3 查看日志 267
13.1.4 应用程序中的错误 268
13.1.5 度量方法 271
13.2 安全问题 272
13.2.1 理解JWT 272
13.2.2 单点登录 275
13.2.3 数据安全 276
13.2.4 预防恶意攻击—识别攻击行为 277
13.2.5 拦截器 277
13.2.6 容器 278
13.2.7 API网关 279
13.3 部署 279
13.3.1 持续集成和持续交付/持续部署 280
13.3.2 蓝/绿部署模式和Canary发布 281
13.3.3 每台主机包含多个服务实例 282
13.3.4 每台主机的服务实例 283
13.4 本章小结 285
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务设计模式和最佳实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件开发方式
第1章 引言
第2章 面向对象――初学者要理解的概念
第3章 分析
第4章 设计
第5章 UML基础
附录A 术语表
附录B 参考文献
附录C UML框图
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件开发方式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Windows Azure从入门到精通
第1章 云计算基础
1.1 云计算的方式
1.1.1 基础结构即服务
1.1.2 软件即服务
1.1.3 平台即服务
1.1.4 定义云服务
1.2 长期展望
1.3 Windows Azure作为PaaS方案
1.3.1 小公司的大好机遇
1.3.2 大公司的大好机遇
1.4 Windows Azure和云计算
1.5 小结
第2章 Windows Azure平台基础
2.1 操作系统
2.2 服务创建
2.3 Windows Azure存储
2.4 工作者角色
2.5 虚拟机角色
2.6 Windows Azure AppFabric
2.6.1 服务总线
2.6.2 访问控制
2.6.3 缓存服务
2.6.4 集成服务
2.6.5 复合应用程序
2.7 SQL Azure
2.8 小结
第3章 创建Web角色项目
3.1 SDK
3.2 Windows Azure Tools for Visual Studio
3.3 WebRole项目模板
3.4 云项目
3.5 部署到Windows Azure
3.6 配置和升级
3.7 服务定义文件
3.8 角色属性
3.9 小结
3.10 快速参考
第4章 Windows Azure存储
4.1 本地存储
4.2 Windows Azure存储帐户
4.3 Windows Azure Management Tool
4.4 Bolb API
4.5 小结
4.6 快速参考
第5章 表、队列和工作者角色
5.1 表服务
5.2 队列服务
5.3 小结
5.4 快速参考
第6章 Windows Azure操作系统
6.1 Live ID、订阅和记帐
6.2 地缘组
6.3 内容交付网络(CDN)
6.4 证书
6.5 诊断
6.6 小结
6.7 快速参考
第7章 构建AppFabric解决方案
7.1 Windows Azure AppFabric组件
7.2 服务总线
7.3 直接连接
7.4 绑定
7.5 HTTP for Management URI
7.6 小结
7.7 快速参考
第8章 WCF数据服务和OData
8.1 Astoria项目
8.2 WCF数据服务
8.3 基本构建单元
8.4 WCF数据服务
8.5 查询和关系
8.6 筛选、排序和分页
8.7 WCF数据服务客户端
8.8 .NET Framework客户端
8.9 安全性简介
8.10 小结
8.11 快速参考
第9章 使用SQL Azure
9.1 SQL Azure功能
9.2 SQL Azure数据库访问
9.3 在云端创建数据库服务器
9.4 SQL Azure访问
9.5 SQL Azure关系引擎功能
9.6 现有数据库的迁移
9.7 SQL Azure迁移向导
9.8 小结
9.9 快速参考
第10章 从任何地方访问Azure服务
10.1 创建存储帐户项目
10.2 从PHP访问存储帐户
10.3 使用HTTP和REST
10.4 小结
10.5 快速参考
第11章 应用程序构架
11.1 多层解决方案的特征
11.2 数据访问层
11.3 服务代理
11.4 小结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Windows Azure从入门到精通
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式沉思录
第1章 介绍	1
11　对模式的十大误解	2
12　观察	9
第2章 运用模式进行设计	11
21　基础	12
22　孤儿、孤儿的收养以及代用品	16
23　“但是应该如何引入代用品呢？”	22
24　访问权限	27
25　关于Visitor的一些警告	35
26　单用户文件系统的保护	37
27　多用户文件系统的保护	44
28　小结	56
第3章 主体和变体	59
31　终止Singleton	59
32　Observer的烦恼	70
33　重温Visitor	77
34　GENERATION GAP	82
35　Type Laundering	98
36　感谢内存泄漏	106
37　推拉模型	111
第4章 爱的奉献	119
第5章 高效模式编写者的7个习惯	143
51　习惯1：经常反思	143
52　习惯2：坚持使用同一套结构	145
53　习惯3：尽早且频繁地涉及具体问题	146
54　习惯4：保持模式间的区别和互补性	146
55　习惯5：有效地呈现	147
56　习惯6：不懈地重复	148
57　习惯7：收集并吸取反馈	149
58　没有银弹	149
参考文献	151
索　　引	155
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>设计模式沉思录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>系统分析师考试论文试题分类分析与范文
第1章 软件开发方法　1.1 论快速原型技术　　1.1.1 试题描述　　1.1.2 要点评述　　1.1.3 解答要点　1.2　 论软件开发平台的演变和选用　　1.2.1 试题描述　　1.2.2 要点评述　　1.2.3 解答要点　1.3 论软件开发范式的选用原则　　1.3.1 试题描述　　1.3.2 要点评述　　1.3.3 解答要点　1.4 论软件的选用和二次开发　　1.4.1 试题描述　　1.4.2 要点评述　　1.4.3 解答要点　1.5 论嵌入式操作系统的功能与特性　　1.5.1 试题描述　　1.5.2 要点评述　　1.5.3 解答要点　1.6 论软件的复用　　1.6.1 试题描述　　1.6.2 要点评述　　1.6.3 解答要点　1.7 论面向对象开发技术及其应用　　1.7.1 试题描述　　1.7.2 要点评述　　1.7.3 解答要点　1.8 论软件开发环境的选用和建立　　1.8.1 试题描述　　1.8.2 要点评述　　1.8.3 解答要点　1.9 论自由软件的合理使用　　1.9.1 试题描述　　1.9.2 要点评述　　1.9.3 解答要点　1.10 论迭代式软件开发过程与方法　　1.10.1 试题描述　　1.10.2 要点评述　　1.10.3 解答要点　1.11 论敏捷开发方法的应用　　1.11.1 试题描述　　1.11.2 要点评述　　1.11.3 解答要点第2章 需求分析　2.1 论面向对象的需求分析或设计　　2.1.1 试题描述　　2.1.2 要点评述　　2.1.3 解答要点　2.2 论软件需求分析方法和工具的选用　　2.2.1 试题描述　　2.2.2 要点评述　　2.2.3 解答要点　2.3 论软件需求分析的方法与策略　　2.3.1 试题描述　　2.3.2 要点评述　　2.3.3 解答要点　2.4 论用例的获取方法　　2.4.1 试题描述　　2.4.2 要点评述　　2.4.3 解答要点　2.5 论应用系统开发范围和功能的确定　　2.5.1 试题描述　　2.5.2 要点评述　　2.5.3 解答要点　2.6 论需求获取技术　　2.6.1 试题描述　　2.6.2 要点评述　　2.6.3 解答要点　2.7 论有效的需求分析过程　　2.7.1 试题描述　　2.7.2 要点评述　　2.7.3 解答要点第3章 软件设计　3.1 论图形用户界面技术　　3.1.1 试题描述　　3.1.2 要点评述　　3.1.3 解答要点　3.2 论应用软件的输入/输出设计技术　　3.2.1 试题描述　　3.2.2 要点评述　　3.2.3 解答要点　3.3 论信息管理系统的Client/Server结构　　3.3.1 试题描述　　3.3.2 要点评述　　3.3.3 解答要点　3.4 论开放系统应用的互操作性技术　　3.4.1 试题描述　　3.4.2 要点评述　　3.4.3 解答要点　3.5 论软件的可重用性设计　　3.5.1 试题描述　　3.5.2 要点评述　　3.5.3 解答要点　3.6 论多层分布式结构系统的开发　　3.6.1 试题描述　　3.6.2 要点评述　　3.6.3 解答要点　3.7 论设计模式在软件开发中的应用　　3.7.1 试题描述　　3.7.2 要点评述　　3.7.3 解答要点　3.8 论软件体系结构风格及其应用　　3.8.1 试题描述　　3.8.2 要点评述　　3.8.3 解答要点　3.9 论基于场景的软件体系结构评估方法　　3.9.1 试题描述　　3.9.2 要点评述　　3.9.3 解答要点第4章 软件测试与性能　4.1 论系统测试　　4.1.1 试题描述　　4.1.2 要点评述　　4.1.3 解答要点　4.2 论软件测试的策略与环境　　4.2.1 试题描述　　4.2.2 要点评述　　4.2.3 解答要点　4.3 论软件测试完成的标准　　4.3.1 试题描述　　4.3.2 要点评述　　4.3.3 解答要点　4.4 论软件测试计划的制订　　4.4.1 试题描述　　4.4.2 要点评述　　4.4.3 解答要点　4.5 论软件排错　　4.5.1 试题描述　　4.5.2 要点评述　　4.5.3 解答要点　4.6 论系统的可靠性　　4.6.1 试题描述　　4.6.2 要点评述　　4.6.3 解答要点　4.7 论系统的健壮性设计　　4.7.1 试题描述　　4.7.2 要点评述　　4.7.3 解答要点　4.8 论系统的可修改性　　4.8.1 试题描述　　4.8.2 要点评述　　4.8.3 解答要点　4.9 论Web应用程序的测试　　4.9.1 试题描述　　4.9.2 要点评述　　4.9.3 解答要点　4.10 论高可靠性系统中软件容错技术的应用　　4.10.1 试题描述　　4.10.2 要点评述　　4.10.3 解答要点……第5章 软件维护第6章 数据库技术第7章 计算机网络与信息安全第8章 软件项目管理第9章 企业应用集成第10章 新技术应用要点主要参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>系统分析师考试论文试题分类分析与范文
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ASP.NET分布式数据应用程序高级编程
第一章 分布式应用程序
第二章 组织和数据访问
第三章 访问XML文档
第四章 应用程序管道化
第五章 处理低端客户机
第六章 处理胖客户机
第七章 远程访问.NET客户机
第八章 在低端客户机上更新数据
第九章 更新远程高速缓存数据
第十章 更新数据的组件
第十一章 胖客户机更新应用程序
第十二章 协调更新错误
第十三章 远程.NET应用程序的数据更新

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ASP.NET分布式数据应用程序高级编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件测试之道
第一篇 工程实践 //1
第1章 让大象跳舞――Office移动版的性能开发周期 //2
一、背景介绍 //3
二、问题提出 //3
三、解决思路 //4
四、实践过程 //6
五、案例启示 //14
第2章 软件设计发展路线和设计能力提升训练营实践 //16
一、为什么要做软件设计 //17
二、软件设计发展路线 //17
三、理论与演练结合提高软件设计能力 //22
第3章 代码评审，从武侠式到军团式的转变 //23
一、背景 //24
二、导言 //24
三、反思 //25
四、案例 //26
五、心理 //31
六、启示 //32
第4章 猿题库IOS客户端架构设计 //33
一、MVC //34
二、MVVM //34
三、在两种架构中权衡而产生的架构 //35
四、Show me the code //36
五、总结 //44
后记 //45
第5章 从铁通App的开发看企业级移动平台的架构选择 //46
一、企业移动化平台的选择 //47
二、铁通开发App的实践过程 //47
三、案例思考 //50
第6章 百度外卖物流智能调度 //54
一、案例简述 //55
二、案例背景 //56
三、实践过程 //56
四、待解决的问题 //60
五、案例启示 //61
第7章 1号店用户画像系统实践 //63
一、问题提出 //64
二、解决思路 //64
三、实践过程 //65
四、效果评价 //72
五、推广建议 //73
第8章 当当推荐团队机器学习实践 //74
一、案例特点 //75
二、背景 //75
三、简述小团队 //76
四、推荐系统架构 //77
五、系统构建 //79
六、关键经验教训 //83
七、作为软件系统的挑战 //86
八、总结 //88
第二篇 互联网高可用架构变迁 //89
第9章 大型电商网站系统架构优化实践 //90
一、引言 //91
二、电商行业发展趋势 //91
三、架构优化实践 //92
四、总结 //98
第10章 移动互联网的挑战：敬畏每一分钱 //99
一、滴滴每次业务都涉及支付 //100
二、出行界的�丝逆袭 //100
第11章 魅族应用商店服务器端架构实践 //103
一、应用商店的简介 //104
二、第一代架构 //104
三、微服务架构 //105
四、多机房架构 //108
五、未来的展望 //109
第12章 当当分布式作业框架elastic-job解密 //110
一、为什么需要作业 //111
二、当当之前使用的作业系统 //112
三、elastic-job的来历 //113
四、elastic-job的功能 //113
五、elastic-job的具体模块的底层及实现 //115
六、elastic-job部署和使用 //116
七、对开源产品的开发理念 //117
八、未来展望 //118
第13章 软硬结合，新旧并举――美团云网络演化进程 //119
一、美团网――一家完全云化的电商平台 //120
二、作为电商平台的美团为什么要做云 //120
三、美团云网络演进过程 //120
四、新旧并举，以最小代价解决最大问题 //125
第14章 架构演化和业务增长的领悟之道 //126
一、什么是架构和业务 //127
二、软件架构的起点 //127
三、软件架构的演化 //127
四、解耦是架构演化的核心问题 //128
五、处理架构的瓶颈 //129
六、现代软件的架构SOA //130
七、微服务化的趋势 //130
八、架构的角色篇 //131
九、架构师如何处理复杂问题 //131
第15章 Mico的朴素架构之旅 //132
一、产品背景 //133
二、初起炉灶 //134
三、高速发展 //139
四、步入正轨 //144
五、未来愿景 //148
第16章 Hulu全平台视频系统的演进――MPEG-DASH及其他 //150
一、Hulu为用户带来无缝体验 //151
二、Hulu自主研发的技术发展之路 //151
三、视频系统的需求与挑战 //152
四、技术选型之路 //154
五、视频系统的架构 //158
六、总结 //160
第17章 基于PerReq技术，精准提升微博图片访问质量 //162
一、案例复现 //163
二、传统的解决办法 //165
三、我们的思考 //165
四、案例解决方法 //166
五、PerRequest诊断技术带来的变化 //169
六、案例启示 //170
第三篇 云计算和大数据 //171
第18章 “大象”起舞带来的启示――云计算的核心业务系统 //172
一、基于云计算的核心业务系统 //173
二、让“大象”起舞 //173
三、研发的案例和目标 //174
四、架构设计思想 //176
五、复杂系统建设实践 //178
第19章 某大型财务咨询公司云迁移案例分析 //181
一、项目背景 //182
二、数据迁移 //182
三、应用程序迁移 //187
四、业务迁移 //189
第20章 基于Ceph的云存储设计 //194
一、问题的提出 //195
二、实践过程 //197
三、效果评价 //205
四、推广建议 //206
第21章 东软SaCa Aclome云管理平台架构演进之路 //207
一、案例简述 //208
二、案例情景 //208
三、成功要点 //211
四、案例效果 //215
五、案例启示 //215
第22章 计算广告大数据核心技术 //217
一、大数据技术难点分析 //218
二、广告技术平台解密 //219
三、Hadoop生态系统在广告大数据应用中选型分析 //220
四、真实案例分析 //222
五、应用案例分析 //223
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件测试之道
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务分布式构架开发实战
1 微服务介绍 1
1.1 什么是微服务架构 2
1.2 垂直应用与微服务 2
1.3 实现一个最简单的微服务框架 3
1.3.1 公共接口 4
1.3.2 服务端 4
1.3.3 客户端 7
1.3.4 完善框架 8
1.4 主流微服务框架介绍 9
1.4.1 Dubbo 9
1.4.2 Spring Cloud 10
2 模块拆分 12
2.1 拆分逻辑 13
2.2 单模块 14
2.3 基础模块 14
2.4 复杂模块 15
3 Spring Boot 16
3.1 目录结构 17
3.2 主要文件 18
3.3 编辑器集成 18
4 Dubbo 20
4.1 注册中心 21
4.2 接口工程 22
4.3 服务端 23
4.4 消费方 28
4.5 网关 30
4.6 监控中心 33
4.7 服务管理 35
4.8 负载均衡 36
4.9 服务降级 37
4.10 集群容错 38
5 Spring Cloud 40
5.1 注册中心 41
5.2 注册服务 44
5.3 调用服务 45
5.3.1 Ribbon 46
5.3.2 Feign 49
5.4 Zuul网关 51
5.5 Hystrix 断路器 54
5.5.1 Ribbon 54
5.5.2 Fegin 57
5.6 服务监控 58
5.7 应用监控 61
5.8 熔断器监控 62
5.8.1 单应用的熔断数据 63
5.8.2 使用Turbine聚合数据 64
5.8.3 Cloud Admin整合Turbine 65
5.9 统一管理配置文件 66
6 数据持久化 70
6.1 Spring Data MySQL 71
6.1.1 依赖与配置 71
6.1.2 实体映射 72
6.1.3 Repository 76
6.1.4 JdbcTemplate 79
6.1.5 事务管理 80
6.2 Spring Data MongoDB 81
6.2.1 依赖与配置 81
6.2.2 实体映射 82
6.2.3 Repository 83
6.2.4 MongoTemplate 84
6.3 Spring Data ElasticSearch 85
6.3.1 基本概念 85
6.3.2 安装与运行 86
6.3.3 基于HTTP交互 87
6.3.4 配置分词器 91
6.3.5 依赖与配置 94
6.3.6 实体映射 94
6.3.7 Repository 95
6.3.8 ElasticsearchTemplate 96
6.4 TCC 分布式事务 98
6.5 Spring Data Redis 100
6.5.1 安装运行 100
6.5.2 依赖与配置 101
6.5.3 缓存支持 102
6.5.4 RedisTemplate 106
6.5.5 全局锁 107
7 表单验证 110
8 定时任务 113
8.1 Spring Task 单机定时任务 114
8.2 Cron 表达式 114
8.3 QuartZ 分布式定时任务 116
9 分布式会话 122
10 消息队列 124
10.1 安装及配置RabbitMQ 125
10.2 配置及使用 128
11 构建Web应用 130
12 异常处理 133
13 安全认证 139
13.1 OAuth2.0 协议介绍 140
13.2 shouquan模式 141
13.3 在Dubbo中使用OAuth 2.0 142
13.4 在Spring Cloud 中使用OAuth 2.0 151
13.4.1 shouquan中心 151
13.4.2 服务模块配置 154
13.4.3 网关配置 157
13.4.4 测试运行 159
14 日志管理 161
14.1 Spring Boot 日志 162
14.1.1 日志格式 162
14.1.2 输出到文件 163
14.1.3 扩展配置 163
14.2 分布式日志管理 166
14.2.1 ELK 搭建 167
14.2.2 Spring Boot 配置 169
15 热部署 171
16 接口文档管理 173
16.1 Dubbo中使用Swagger2 174
16.2 Spring Cloud中使用Swagger2 178
16.2.1 微服务模块配置 179
16.2.2 网关模块配置 181
17 Nexus私库 184
17.1 Nexus 安装 185
17.2 从Nexus私库下载jar包 187
17.3 上传jar包到Nexus私库 189
18 发布系统 191
18.1 Jenkins 安装配置 192
18.2 构建任务 194
19 分布式架构总结 201
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务分布式构架开发实战
