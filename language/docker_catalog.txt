>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>第一本Docker书
第1 章 简介····································1
1.1 Docker 简介·····························2
1.1.1 提供一个简单、轻量的建模方式·························2
1.1.2 职责的逻辑分离················3
1.1.3 快速、高效的开发生命周期··3
1.1.4 鼓励使用面向服务的架构·····3
1.2 Docker 组件·····························3
1.2.1 Docker 客户端和服务器·······4
1.2.2 Docker 镜像······················4
1.2.3 Registry ···························5
1.2.4 容器·······························5
1.3 我们能用Docker 做什么·············6
1.4 Docker 与配置管理····················7
1.5 Docker 的技术组件····················8
1.6 本书的内容·····························9
1.7 Docker 资源··························· 10
第2 章 安装Docker ······················· 11
2.1 安装Docker 的先决条件··········· 12
2.2 在Ubuntu 中安装Docker ·········· 13
2.2.1 检查前提条件················· 14
2.2.2 安装Docker ···················· 16
2.2.3 Docker 与UFW ··············· 17
2.3 在Red Hat 和Red Hat 系发行版中安装Docker ···························17
2.3.1 检查前提条件················· 18
2.3.2 安装Docker···················· 19
2.3.3 在Red Hat 系发行版中启动Docker 守护进程·············· 20
2.4 在OS X 中安装Boot2Docker ····· 21
2.4.1 在OS X 中安装Boot2Docker ··················· 21
2.4.2 在OS X 中启动Boot2Docker ··················· 22
2.4.3 测试Boot2Docker ············ 23
2.5 在Windows 中安装Boot2Docker 23
2.5.1 在Windows 中安装Boot2Docker ··················· 23
2.5.2 在Windows 中启动Boot2Docker ··················· 24
2.5.3 测试Boot2Docker ············ 25
2.6 使用本书的Boot2Docker 示例···· 25
2.7 Docker 安装脚本····················· 26
2.8 二进制安装··························· 27
2.9 Docker 守护进程····················· 28
2.9.1 配置Docker 守护进程······· 28
2.9.2 检查Docker 守护进程是否正在运行······················· 30
2.10 升级Docker ························· 31
2.11 Docker 图形用户界面············· 31
2.12 小结··································· 32
第3 章 Docker 入门······················ 33
3.1 确保Docker 已经就绪·············· 33
3.2 运行我们的第一个容器············ 34
3.3 使用第一个容器····················· 36
3.4 容器命名······························ 38
3.5 重新启动已经停止的容器·········· 39
3.6 附着到容器上························ 39
3.7 创建守护式容器····················· 40
3.8 容器内部都在干些什么············ 41
3.9 查看容器内的进程·················· 42
3.10 在容器内部运行进程·············· 43
3.11 停止守护式容器···················· 44
3.12 自动重启容器······················· 44
3.13 深入容器····························· 45
3.14 删除容器····························· 46
3.15 小结··································· 47
第4 章 使用Docker 镜像和仓库······· 49
4.1 什么是Docker 镜像················· 49
4.2 列出镜像······························ 51
4.3 拉取镜像······························ 54
4.4 查找镜像······························ 56
4.5 构建镜像······························ 57
4.5.1 创建Docker Hub 账号······· 58
4.5.2 用Docker 的commit 命令创建镜像······················· 59
4.5.3 用Dockerfile构建镜像······················· 61
4.5.4 基于Dockerfile构建新镜像····················· 64
4.5.5 指令失败时会怎样············ 66
4.5.6 Dockerfile 和构建缓存·· 67
4.5.7 基于构建缓存的Dockerfile模板····························· 67
4.5.8 查看新镜像···················· 68
4.5.9 从新镜像启动容器··········· 69
4.5.10 Dockerfile 指令········· 72
4.6 将镜像推送到Docker Hub········· 83
4.7 删除镜像······························ 88
4.8 运行自己的Docker Registry······· 90
4.8.1 从容器运行Registry ········· 90
4.8.2 测试新Registry ··············· 91
4.9 其他可选Registry 服务············· 92
4.10 小结··································· 92
第5 章 在测试中使用Docker··········· 93
5.1 使用Docker 测试静态网站········ 93
5.1.1 Sample 网站的初始Dockerfile ················· 94
5.1.2 构建Sample 网站和Nginx镜像····························· 96
5.1.3 从Sample 网站和Nginx 镜像构建容器······················· 97
5.1.4 修改网站······················ 100
5.2 使用Docker 构建并测试Web应用程序·············································· 101
5.2.1 构建Sinatra 应用程序······ 101
5.2.2 创建Sinatra 容器············ 102
5.2.3 构建Redis 镜像和容器····· 104
5.2.4 连接到Redis 容器··········· 106
5.2.5 连接Redis····················· 108
5.2.6 让Docker 容器互连········· 110
5.2.7 使用容器连接来通信······· 114
5.3 Docker 用于持续集成·············· 116
5.3.1 构建Jenkins 和Docker服务器························· 117
5.3.2 创建新的Jenkins 作业······121
5.3.3 运行Jenkins 作业············124
5.3.4 与Jenkins 作业有关的下一步·························126
5.3.5 Jenkins 设置小结·············126
5.4 多配置的Jenkins····················126
5.4.1 创建多配置作业·············126
5.4.2 测试多配置作业·············130
5.4.3 Jenkins 多配置作业小结····132
5.5 其他选择·····························132
5.5.1 Drone ···························132
5.5.2 Shippable ······················132
5.6 小结···································132
第6 章 使用Docker 构建服务·········133
6.1 构建第一个应用····················133
6.1.1 Jekyll 基础镜像···············134
6.1.2 构建Jekyll 基础镜像········135
6.1.3 Apache 镜像···················135
6.1.4 构建Jekylll Apache 镜像···136
6.1.5 启动Jekylll 网站·············137
6.1.6 更新Jekyll 网站··············140
6.1.7 备份Jekyll 卷·················141
6.1.8 扩展Jekyll 示例网站········142
6.2 使用Docker 构建一个Java应用服务·····························143
6.2.1 WAR 文件的获取器·········143
6.2.2 获取WAR 文件··············144
6.2.3 Tomecat7 应用服务器·······145
6.2.4 运行WAR 文件··············146
6.2.5 基于Tomcat 应用服务器的构建服务······················147
6.3 多容器的应用栈····················150
6.3.1 Node.js 镜像··················150
6.3.2 Redis 基础镜像··············· 153
6.3.3 Redis 主镜像·················· 154
6.3.4 Redis 从镜像·················· 155
6.3.5 创建Redis 后端集群········ 156
6.3.6 创建Node 容器·············· 160
6.3.7 捕获应用日志················ 161
6.3.8 Node 程序栈的小结········· 164
6.4 不使用SSH 管理Docker 容器··· 164
6.5 小结··································· 166
第7 章 使用Fig 编配Docker·········· 167
7.1 Fig ····································· 168
7.1.1 安装Fig ······················· 168
7.1.2 获取示例应用················ 169
7.1.3 fig.yml 文件··············· 172
7.1.4 运行Fig ······················· 173
7.1.5 使用Fig ······················· 175
7.1.6 Fig 小结······················· 178
7.2 Consul、服务发现和Docker ····· 178
7.2.1 构建Consul 镜像············ 179
7.2.2 在本地测试Consul 容器··· 182
7.2.3 使用Docker 运行Consul集群···························· 184
7.2.4 启动具有自启动功能的Consul 节点··················· 186
7.2.5 启动其余节点················ 188
7.2.6 配合Consul，在Docker里运行一个分布式服务···· 193
7.3 其他编配工具和组件·············· 201
7.3.1 Fleet 和etcd··················· 202
7.3.2 Kubernetes····················· 202
7.3.3 Apache Mesos················· 202
7.3.4 Helios ·························· 202
7.3.5 Centurion ······················ 203
7.3.6 Libswarm ······················203
7.4 小结···································203
第8 章 使用Docker API ················205
8.1 Docker API ···························205
8.2 初识Remote API····················206
8.3 测试Docker Remote API ··········207
8.3.1 通过API 来管理Docker镜像····························208
8.3.2 通过API 管理Docker容器····························211
8.4 改进TProv 应用····················213
8.5 对Docker Remote API 进行认证··217
8.5.1 建立证书授权中心···········218
8.5.2 创建服务器的证书签名请求和密钥·························220
8.5.3 配置Docker 守护进程······222
8.5.4 创建客户端证书和秘钥·····223
8.5.5 配置Docker 客户端开启认证功能······················224
8.6 小结···································226
第9 章 获得帮助和对Docker进行改进··························· 227
9.1 获得帮助····························· 227
9.1.1 Docker 用户和开发邮件列表······················ 228
9.1.2 IRC 上的Docker ············· 228
9.1.3 GitHub 上的Docker ········· 228
9.2 报告Docker 的问题················ 229
9.3 搭建构建环境······················· 229
9.3.1 安装Docker··················· 229
9.3.2 安装源代码和构建工具···· 229
9.3.3 检出源代码··················· 230
9.3.4 贡献文档······················ 230
9.3.5 构建开发环境················ 231
9.3.6 运行测试······················ 232
9.3.7 在开发环境中使用Docker··· 233
9.3.8 发起pull request ············· 234
9.3.9 批准合并和维护者·········· 236
9.4 小结··································· 236
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>第一本Docker书
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Kubernetes权威指南
第1章 Kubernetes 入门   1
1.1 Kubernetes 是什么   1
1.2 为什么要用Kubernetes   4
1.3 从一个简单的例子开始   5
1.3.1 环境准备   6
1.3.2 启动MySQL 服务   7
1.3.3 启动Tomcat 应用   9
1.3.4 通过浏览器访问网页   11
1.4 Kubernetes 基本概念和术语   12
1.4.1 Master   12
1.4.2 Node   13
1.4.3 Pod   15
1.4.4 Label（标签）   19
1.4.5 Replication Controller（RC）   22
1.4.6 Deployment   25
1.4.7 Horizontal Pod Autoscaler（HPA）   27
1.4.8 Service（服务）   29
1.4.9 Volume（存储卷）   35
1.4.10 Persistent Volume   39
1.4.11 Namespace（命名空间）   40
1.4.12 Annotation（注解）   42
1.4.13 小结   42
第2章 Kubernetes 实践指南   43
2.1 Kubernetes 安装与配置   43
2.1.1 安装Kubernetes   43
2.1.2 配置和启动Kubernetes 服务   45
2.1.3 Kubernetes 集群的安全设置   51
2.1.4 Kubernetes 的版本升级   57
2.1.5 内网中的Kubernetes 相关配置   57
2.1.6 Kubernetes 核心服务配置详解   58
2.1.7 Kubernetes 集群网络配置方案   72
2.2 kubectl 命令行工具用法详解   80
2.2.1 kubectl 用法概述   80
2.2.2 kubectl 子命令详解   82
2.2.3 kubectl 参数列表   84
2.2.4 kubectl 输出格式   84
2.2.5 kubectl 操作示例   86
2.3 Guestbook 示例：Hello World   87
2.3.1 创建redis-master RC 和Service   89
2.3.2 创建redis-slave RC 和Service   91
2.3.3 创建frontend RC 和Service   93
2.3.4 通过浏览器访问frontend 页面   96
2.4 深入掌握Pod   97
2.4.1 Pod 定义详解   97
2.4.2 Pod 的基本用法   102
2.4.3 静态Pod   107
2.4.4 Pod 容器共享Volume   108
2.4.5 Pod 的配置管理   110
2.4.6 Pod 生命周期和重启策略   123
2.4.7 Pod 健康检查   124
2.4.8 玩转Pod 调度   126
2.4.9 Pod 的扩容和缩容   135
2.4.10 Pod 的滚动升级   139
2.5 深入掌握Service   143
2.5.1 Service 定义详解   143
2.5.2 Service 基本用法   145
2.5.3 集群外部访问Pod 或Service   150
2.5.4 DNS 服务搭建指南   153
2.5.5 Ingress：HTTP 7 层路由机制   161
第3章 Kubernetes 核心原理   165
3.1 Kubernetes API Server 原理分析   165
3.1.1 Kubernetes API Server 概述   165
3.1.2 独特的Kubernetes Proxy API 接口   168
3.1.3 集群功能模块之间的通信   169
3.2 Controller Manager 原理分析   170
3.2.1 Replication Controller   171
3.2.2 Node Controller   173
3.2.3 ResourceQuota Controller   174
3.2.4 Namespace Controller   176
3.2.5 Service Controller 与Endpoint Controller   176
3.3 Scheduler 原理分析   177
3.4 kubelet 运行机制分析   181
3.4.1 节点管理   181
3.4.2 Pod 管理   182
3.4.3 容器健康检查   183
3.4.4 cAdvisor 资源监控   184
3.5 kube-proxy 运行机制分析   186
3.6 深入分析集群安全机制   190
3.6.1 API Server 认证   190
3.6.2 API Server 授权   192
3.6.3 Admission Control 准入控制   194
3.6.4 Service Account   195
3.6.5 Secret 私密凭据   200
3.7 网络原理   203
3.7.1 Kubernetes 网络模型   203
3.7.2 Docker 的网络基础   205
3.7.3 Docker 的网络实现   217
3.7.4 Kubernetes 的网络实现   225
3.7.5 开源的网络组件   229
3.7.6 网络实战   234
第4章 Kubernetes 开发指南   247
4.1 REST 简述   247
4.2 Kubernetes API 详解   249
4.2.1 Kubernetes API 概述   249
4.2.2 API 版本   254
4.2.3 API 详细说明   254
4.2.4 API 响应说明   256
4.3 使用Java 程序访问Kubernetes API   258
4.3.1 Jersey   258
4.3.2 Fabric8   270
4.3.3 使用说明   271
第5章 Kubernetes 运维指南   292
5.1 Kubernetes 集群管理指南   292
5.1.1 Node 的管理   292
5.1.2 更新资源对象的Label   294
5.1.3 Namespace：集群环境共享与隔离   295
5.1.4 Kubernetes 资源管理   299
5.1.5 Kubernetes 集群高可用部署方案   333
5.1.6 Kubernetes 集群监控   343
5.1.7 kubelet 的垃圾回收（GC）机制   361
5.2 Kubernetes 高级案例   362
5.2.1 ElasticSearch 日志搜集查询和展现案例   362
5.2.2 Cassandra 集群部署案例   371
5.3 Trouble Shooting 指导   376
5.3.1 查看系统Event 事件   377
5.3.2 查看容器日志   379
5.3.3 查看Kubernetes 服务日志   379
5.3.4 常见问题   381
5.3.5 寻求帮助   384
5.4 Kubernetes v1.3 开发中的新功能   385
5.4.1 Pet Set（有状态的容器）   385
5.4.2 Init Container（初始化容器）   388
5.4.3 Cluster Federation（集群联邦）   391
第6章 Kubernetes 源码导读   396
6.1 Kubernetes 源码结构和编译步骤   396
6.2 kube-apiserver 进程源码分析   400
6.2.1 进程启动过程   400
6.2.2 关键代码分析   402
6.2.3 设计总结   417
6.3 kube-controller-manager 进程源码分析   420
6.3.1 进程启动过程   420
6.3.2 关键代码分析   423
6.3.3 设计总结   431
6.4 kube-scheduler 进程源码分析   433
6.4.1 进程启动过程   434
6.4.2 关键代码分析   438
6.4.3 设计总结   445
6.5 kubelet 进程源码分析   447
6.5.1 进程启动过程   447
6.5.2 关键代码分析   452
6.5.3 设计总结   475
6.6 kube-proxy 进程源码分析   476
6.6.1 进程启动过程   476
6.6.2 关键代码分析   478
6.6.3 设计总结   493
6.7 kubectl 进程源码分析   494
6.7.1 kubectl create 命令   495
6.7.2 rolling-update 命令   499
后记   505
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Kubernetes权威指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>第一本Docker书 修订版
第1章 简介　1
1.1　Docker简介　2
1.1.1　提供一个简单、轻量的建模方式　2
1.1.2　职责的逻辑分离　3
1.1.3　快速、高效的开发生命周期　3
1.1.4　鼓励使用面向服务的架构　3
1.2　Docker组件　3
1.2.1　Docker客户端和服务器　4
1.2.2　Docker镜像　5
1.2.3　Registry　5
1.2.4　容器　5
1.3　能用Docker做什么　6
1.4　Docker与配置管理　7
1.5　Docker的技术组件　8
1.6　本书的内容　9
1.7　Docker资源　10
第2章 安装Docker　11
2.1 安装Docker的先决条件　12
2.2 在Ubuntu和Debian中安装Docker　13
2.2.1 检查前提条件　14
2.2.2　安装Docker　16
2.2.3　Docker与UFW　17
2.3　在Red Hat和Red Hat系发行版中安装Docker　17
2.3.1　检查前提条件　18
2.3.2　安装Docker　19
2.3.3　在Red Hat系发行版中启动Docker守护进程　21
2.4　在OS X中安装Docker Toolbox　22
2.4.1　在OS X中安装Docker Toolbox　22
2.4.2　在OS X中启动Docker Toolbox　23
2.4.3　测试Docker Toolbox　24
2.5　在Windows中安装Docker Toolbox　24
2.5.1　在Windows中安装Docker Toolbox　25
2.5.2　在Windows中启动Docker Toolbox　25
2.5.3　测试Docker Toolbox　26
2.6　使用本书的Docker Toolbox示例　26
2.7　Docker安装脚本　27
2.8　二进制安装　28
2.9　Docker守护进程　28
2.9.1　配置Docker守护进程　29
2.9.2　检查Docker守护进程是否正在运行　30
2.10　升级Docker　31
2.11　Docker用户界面　32
2.12　小结　32
第3章 Docker入门　33
3.1　确保Docker已经就绪　33
3.2　运行我们的第一个容器　34
3.3　使用第一个容器　36
3.4　容器命名　38
3.5　重新启动已经停止的容器　39
3.6　附着到容器上　40
3.7　创建守护式容器　40
3.8　容器内部都在干些什么　41
3.9 Docker日志驱动　42
3.10　查看容器内的进程　43
3.11 Docker统计信息　44
3.12　在容器内部运行进程　44
3.13　停止守护式容器　45
3.14　自动重启容器　46
3.15　深入容器　47
3.16　删除容器　48
3.17　小结　49
第4章 使用Docker镜像和仓库　50
4.1　什么是Docker镜像　50
4.2　列出镜像　52
4.3　拉取镜像　55
4.4　查找镜像　57
4.5　构建镜像　58
4.5.1　创建Docker Hub账号　59
4.5.2　用Docker的commit命令创建镜像　60
4.5.3　用Dockerfile构建镜像　62
4.5.4　基于Dockerfile构建新镜像　65
4.5.5　指令失败时会怎样　67
4.5.6　Dockerfile和构建缓存　68
4.5.7　基于构建缓存的Dockerfile模板　69
4.5.8　查看新镜像　70
4.5.9　从新镜像启动容器　70
4.5.10　Dockerfile指令　74
4.6　将镜像推送到Docker Hub　88
4.7　删除镜像　92
4.8　运行自己的Docker Registry　94
4.8.1　从容器运行Registry　94
4.8.2　测试新Registry　95
4.9　其他可选Registry服务　96
4.10　小结　96
第5章 在测试中使用Docker　97
5.1　使用Docker测试静态网站　97
5.1.1　Sample网站的初始Dockerfile　98
5.1.2　构建Sample网站和Nginx镜像　100
5.1.3　从Sample网站和Nginx镜像构建容器　102
5.1.4　修改网站　104
5.2　使用Docker构建并测试Web应用程序　105
5.2.1　构建Sinatra应用程序　105
5.2.2　创建Sinatra容器　107
5.2.3　扩展Sinatra应用程序来使用Redis　110
5.2.4　将Sinatra应用程序连接到Redis容器　113
5.2.5 Docker内部连网　114
5.2.6　Docker Networking　119
5.2.7　使用容器连接来通信　131
5.2.8 连接容器小结　132
5.3　Docker用于持续集成　132
5.3.1　构建Jenkins和Docker服务器　133
5.3.2　创建新的Jenkins作业　137
5.3.3　运行Jenkins作业　141
5.3.4　与Jenkins作业有关的下一步　143
5.3.5　Jenkins设置小结　143
5.4　多配置的Jenkins　143
5.4.1　创建多配置作业　143
5.4.2　测试多配置作业　147
5.4.3　Jenkins多配置作业小结　149
5.5　其他选择　149
5.5.1　Drone　149
5.5.2　Shippable　149
5.6　小结　149
第6章 使用Docker构建服务　151
6.1　构建第一个应用　151
6.1.1　Jekyll基础镜像　152
6.1.2　构建Jekyll基础镜像　153
6.1.3　Apache镜像　153
6.1.4　构建Jekyll Apache镜像　154
6.1.5　启动Jekyll网站　155
6.1.6　更新Jekyll网站　158
6.1.7　备份Jekyll卷　159
6.1.8　扩展Jekyll示例网站　161
6.2　使用Docker构建一个Java应用服务　161
6.2.1　WAR文件的获取程序　161
6.2.2　获取WAR文件　162
6.2.3　Tomecat7应用服务器　163
6.2.4　运行WAR文件　165
6.2.5　基于Tomcat应用服务器的构建服务　166
6.3　多容器的应用栈　169
6.3.1　Node.js镜像　169
6.3.2　Redis基础镜像　172
6.3.3　Redis主镜像　173
6.3.4　Redis副本镜像　174
6.3.5　创建Redis后端集群　174
6.3.6　创建Node容器　178
6.3.7　捕获应用日志　180
6.3.8　Node程序栈的小结　183
6.4　不使用SSH管理Docker容器　183
6.5　小结　185
第7章 Docker编配和服务发现　186
7.1　Docker Compose　187
7.1.1　安装Docker Compose　187
7.1.2　获取示例应用　188
7.1.3　docker-compose.yml文件　191
7.1.4　运行Compose　193
7.1.5　使用Compose　195
7.1.6　Compose小结　197
7.2　Consul、服务发现和Docker　197
7.2.1　构建Consul镜像　199
7.2.2　在本地测试Consul容器　202
7.2.3　使用Docker运行Consul集群　203
7.2.4　启动具有自启动功能的Consul节点　206
7.2.5　启动其余节点　207
7.2.6　配合Consul，在Docker里运行一个分布式服务　212
7.3 Docker Swarm　221
7.3.1 安装Swarm　222
7.3.2 创建Swarm集群　222
7.3.3 创建容器　225
7.3.4 过滤器　227
7.3.5 策略　229
7.3.6 小结　230
7.4　其他编配工具和组件　230
7.4.1　Fleet和etcd　230
7.4.2　Kubernetes　231
7.4.3　Apache Mesos　231
7.4.4　Helios　231
7.4.5　Centurion　231
7.5　小结　231
第8章 使用Docker API　233
8.1　Docker API　233
8.2　初识Remote API　234
8.3　测试Docker Remote API　236
8.3.1　通过API来管理Docker镜像　237
8.3.2　通过API管理Docker容器　239
8.4　改进TProv应用　242
8.5　对Docker Remote API进行认证　246
8.5.1　建立证书授权中心　246
8.5.2　创建服务器的证书签名请求和密钥　248
8.5.3　配置Docker守护进程　250
8.5.4　创建客户端证书和密钥　251
8.5.5　配置Docker客户端开启认证功能　253
8.6　小结　254
第9章 获得帮助和对Docker进行改进　255
9.1　获得帮助　255
9.1.1　Docker用户、开发邮件列表及论坛　255
9.1.2　IRC上的Docker　256
9.1.3　GitHub上的Docker　256
9.2　报告Docker的问题　257
9.3　搭建构建环境　257
9.3.1　安装Docker　257
9.3.2　安装源代码和构建工具　257
9.3.3　检出源代码　258
9.3.4　贡献文档　258
9.3.5　构建开发环境　259
9.3.6　运行测试　261
9.3.7　在开发环境中使用Docker　261
9.3.8　发起pull request　262
9.3.9　批准合并和维护者　263
9.4　小结　264
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>第一本Docker书 修订版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker——容器与容器云（第2版）
第一部分　Docker深入解读
第1章　从容器到容器云　　2
1.1　云计算平台　　2
1.2　容器，新的革命　　3
1.3　进化：从容器到容器云　　7
第2章　Docker 基础　　8
2.1　Docker的安装　　8
2.2　Docker操作参数解读　　9
2.3　搭建你的第一个Docker应用栈　　16
2.3.1　Docker集群部署　　16
2.3.2　第一个Hello World　　17
2.3.3　开发、测试和发布一体化　　27
第3章　Docker核心原理解读　　28
3.1　Docker背后的内核知识　　28
3.1.1　namespace资源隔离　　28
3.1.2　cgroups资源限制　　45
3.2　Docker架构概览　　53
3.2.1　Docker daemon　　54
3.2.2　Docker client　　54
3.2.3　镜像管理　　54
3.2.4　execdriver、volumedriver、graphdriver　　55
3.2.5　network　　55
3.3　client和daemon　　56
3.3.1　client模式　　56
3.3.2　daemon模式　　58
3.3.3　从client到daemon　　64
3.4　libcontainer　　67
3.4.1　libcontainer的工作方式　　69
3.4.2　libcontainer实现原理　　70
3.4.3　使用runC与libcontainer进行交互　　75
3.5　Docker镜像管理　　77
3.5.1　什么是Docker镜像　　77
3.5.2　Docker镜像关键概念　　80
3.5.3　Docker镜像构建操作　　81
3.5.4　Docker镜像的分发方法　　84
3.6　Docker存储管理　　87
3.6.1　Docker镜像元数据管理　　87
3.6.2　Docker存储驱动　　89
3.7　Docker数据卷　　99
3.7.1　数据卷的使用方式　　100
3.7.2　数据卷原理解读　　105
3.8　Docker网络管理　　108
3.8.1　Docker网络基础　　108
3.8.2　Docker daemon网络配置原理　　116
3.8.3　libcontainer网络配置原理　　119
3.8.4　传统的link原理解析　　125
3.8.5　新的link介绍　　127
3.9　Docker与容器安全　　129
3.9.1　Docker的安全机制　　129
3.9.2　Docker安全问题　　135
3.9.3　Docker安全的解决方案　　139
第4章　Docker 高级实践技巧　　151
4.1　容器化思维　　151
4.1.1　SSH服务器的替代方案　　151
4.1.2　Docker内应用日志管理方案　　152
4.1.3　容器化思维及更多　　153
4.2　Docker高级网络实践　　153
4.2.1　玩转Linux networknamespace　　154
4.2.2　pipework原理解析　　159
4.2.3　pipework跨主机通信　　165
4.2.4　OVS划分VLAN　　170
4.2.5　OVS隧道模式　　174
4.3　Dockerfile最佳实践　　187
4.3.1　Dockerfile的使用　　187
4.3.2　Dockerfile实践心得　　191
4.4　Docker容器的监控手段　　193
4.4.1　Docker容器监控维度　　194
4.4.2　容器监控命令　　195
4.4.3　常用的容器监控工具　　197
4.5　容器化应用构建的基础：高可用配置中心　　201
4.5.1　etcd经典应用场景　　201
4.5.2　etcd实现原理　　206
第二部分　Docker云平台解读
第5章　构建自己的容器云　　222
5.1　再谈云平台的层次架构　　222
5.2　从小工到专家　　225
第6章　专注编排与部署：三剑客与Fleet　　230
6.1　编排小神器Fig/Compose　　230
6.1.1　再谈容器编排与部署　　230
6.1.2　Compose原理：一探究竟　　233
6.2　跨平台宿主环境管理工具Machine　　237
6.2.1　Machine与虚拟机软件　　237
6.2.2　Machine与IaaS平台　　238
6.2.3　Machine小结　　239
6.3　集群抽象工具Swarm　　240
6.3.1　Swarm简介　　240
6.3.2　试用Swarm　　241
6.3.3　Swarm集群的多种创建方式　　243
6.3.4　Swarm对请求的处理　　245
6.3.5　Swarm集群的调度策略　　245
6.3.6　Swarm集群高可用（HA）　　246
6.3.7　Swarm与Machine　　247
6.3.8　Swarm小结　　248
6.4　编排之秀Fleet　　248
6.4.1　旧问题新角度：Docker distro　　249
6.4.2　Fleet的原理剖析　　252
第7章　专注应用支撑和运行时：Flynn和Deis　　258
7.1　Flynn，一个小而美的两层架构　　258
7.1.1　第0层：容器云的基础设施　　259
7.1.2　第1层：容器云的功能框架　　259
7.1.3　Flynn体系架构与实现原理　　260
7.2　谈谈Deis与Flynn　　270
7.2.1　应用发布上的比较　　271
7.2.2　关于Deis的一些思考　　273
第8章　一切皆容器：Kubernetes　　274
8.1　Kubernetes是个什么样的项目　　274
8.2　Kubernetes的设计解读　　275
8.2.1　一个典型案例：Guestbook　　275
8.2.2　pod设计解读　　277
8.2.3　replication controller设计解读　　288
8.2.4　service的设计解读　　294
8.2.5　新一代副本控制器replica set　　306
8.2.6　Deployment　　307
8.2.7　DaemonSet　　312
8.2.8　ConfigMap　　312
8.2.9　Job　　317
8.2.10　Horizontal Pod Autoscaler　　318
8.3　Kubernetes核心组件解读　　320
8.3.1　Kubernetes的整体架构　　320
8.3.2　APIServer　　321
8.3.3　scheduler　　328
8.3.4　controller manager　　338
8.3.5　kubelet　　346
8.3.6　kube-proxy　　352
8.3.7　核心组件协作流程　　362
8.4　Kubernetes存储核心原理　　366
8.4.1　volume设计解读　　366
8.4.2　volume实现原理分析　　367
8.4.3　volume使用案例　　368
8.4.4　persistent volume　　371
8.5　Kubernetes网络核心原理　　372
8.5.1　单pod单IP模型　　373
8.5.2　pod和网络容器　　374
8.5.3　实现Kubernetes的网络模型　　377
8.6　Kubernetes多租户管理与资源控制　　381
8.6.1　namespace设计解读　　381
8.6.2　Kubernetes用户认证机制　　385
8.6.3　Kubernetes用户授权机制　　387
8.6.4　Kubernetes多维资源管理机制admission control　　390
8.7　Kubernetes高级实践　　402
8.7.1　应用健康检查　　402
8.7.2　高可用性　　405
8.7.3　日志　　408
8.7.4　集成DNS　　410
8.7.5　容器上下文环境　　412
8.8　Kubernetes未来动向　　414
8.8.1　Ubernetes　　414
8.8.2　petSet　　415
8.8.3　performance　　417
8.8.4　rescheduler　　417
8.8.5　OCI标准　　419
8.9　不要停止思考　　419
第三部分　附录
附录A　Docker的安装　　424
附录B　阅读Docker源代码的神兵利器　　432
附录C　快速熟悉开源项目　　441
附录D　cgroups的测试与使用　　444
附录E　cgroups子系统配置参数介绍　　448
附录F　Kubernetes的安装　　453
后记　　457

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker——容器与容器云（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>自己动手写Docker
第1章　容器与开发语言………………………………………………………………………1
1.1　Docker ………………………………………………………………………………1
1.1.1　简介 …………………………………………………………………………1
1.1.2　容器和虚拟机比较 …………………………………………………………2
1.1.3　容器加速开发效率 …………………………………………………………3
1.1.4　利用容器合作开发 …………………………………………………………4
1.1.5　利用容器快速扩容 …………………………………………………………4
1.1.6　安装使用Docker ……………………………………………………………4
1.2　Go ……………………………………………………………………………………5
1.2.1　描述 …………………………………………………………………………5
1.2.2　安装Go ………………………………………………………………………6
1.2.3　配置GOPATH ………………………………………………………………6
1.3　小结 …………………………………………………………………………………7
第2章　基础技术………………………………………………………………………………8
2.1　Linux Namespace 介绍 ………………………………………………………………8
2.1.1　概念 …………………………………………………………………………8
2.1.2　UTS Namespace ………………………………………………………………10
2.1.3　IPC Namespace ………………………………………………………………11
2.1.4　PID Namespace ………………………………………………………………13
2.1.5　Mount Namespace ……………………………………………………………14
2.1.6　User Namespace ………………………………………………………………16
XII 自己动手写 Docker
2.1.7　Network Namespace ………………………………………………………… 18
2.2　Linux Cgroups 介绍 ………………………………………………………………… 20
2.2.1　什么是Linux Cgroups ……………………………………………………… 20
2.2.2　Docker 是如何使用Cgroups 的 …………………………………………… 24
2.2.3　用Go 语言实现通过cgroup 限制容器的资源 …………………………… 25
2.3　Union File System …………………………………………………………………… 26
2.3.1　什么是Union File System …………………………………………………… 26
2.3.2　AUFS ………………………………………………………………………… 27
2.3.3　Docker 是如何使用AUFS 的 ……………………………………………… 27
2.3.4　自己动手写AUFS…………………………………………………………… 34
2.4　小结 ………………………………………………………………………………… 37
第3 章　构造容器……………………………………………………………………………… 38
3.1　构造实现run 命令版本的容器 …………………………………………………… 38
3.1.1　Linux proc 文件系统介绍 …………………………………………………… 38
3.1.2　实现 run 命令 ……………………………………………………………… 39
3.2　增加容器资源限制 ………………………………………………………………… 45
3.2.1　定义Cgroups 的数据结构 ………………………………………………… 45
3.2.2　在启动容器时增加资源限制的配置 ……………………………………… 51
3.3　增加管道及环境变量识别 ………………………………………………………… 53
3.4　小结 ………………………………………………………………………………… 58
第4 章　构造镜像……………………………………………………………………………… 59
4.1　使用busybox 创建容器 …………………………………………………………… 59
4.1.1　busybox ……………………………………………………………………… 59
4.1.2　pivot_root …………………………………………………………………… 60
4.2　使用AUFS 包装busybox …………………………………………………………… 63
4.3　实现volume 数据卷 ………………………………………………………………… 67
4.4　实现简单镜像打包 ………………………………………………………………… 75
4.5　小结 ………………………………………………………………………………… 77
第5 章　构建容器进阶………………………………………………………………………… 78
5.1　实现容器的后台运行 ……………………………………………………………… 78
5.2　实现查看运行中容器 ……………………………………………………………… 82
5.2.1　准备数据 …………………………………………………………………… 82
5.2.2　实现mydocker ps …………………………………………………………… 87
5.3　实现查看容器日志 ………………………………………………………………… 90
5.4　实现进入容器Namespace ………………………………………………………… 93
5.4.1　setns ………………………………………………………………………… 94
5.4.2　Cgo …………………………………………………………………………… 94
5.4.3　实现命令 …………………………………………………………………… 94
5.5　实现停止容器 ……………………………………………………………………… 100
5.6　实现删除容器 ……………………………………………………………………… 104
5.7　实现通过容器制作镜像 …………………………………………………………… 105
5.8　实现容器指定环境变量运行 ……………………………………………………… 117
5.8.1　修改runCommand …………………………………………………………… 117
5.8.2　修改Run 函数 ……………………………………………………………… 117
5.8.3　修改NewParentProcess 函数 ……………………………………………… 118
5.8.4　修改mydocker exec 命令 …………………………………………………… 119
5.9　小结 ………………………………………………………………………………… 121
第6 章　容器网络……………………………………………………………………………… 122
6.1　网络虚拟化技术介绍 ……………………………………………………………… 122
6.1.1　Linux 虚拟网络设备 ………………………………………………………… 122
6.1.2　Linux 路由表 ………………………………………………………………… 124
6.1.3　Linux iptables ………………………………………………………………… 126
6.1.4　Go 语言网络库介绍 ………………………………………………………… 127
6.2　构建容器网络模型 ………………………………………………………………… 128
6.2.1　模型 ………………………………………………………………………… 128
6.2.2　调用关系 …………………………………………………………………… 130
6.3　容器地址分配 ……………………………………………………………………… 137
6.3.1　bitmap 算法介绍 …………………………………………………………… 138
6.3.2　数据结构定义 ……………………………………………………………… 138
6.3.3　地址分配的实现 …………………………………………………………… 140
6.3.4　地址释放的实现 …………………………………………………………… 142
6.3.5　测试 ………………………………………………………………………… 142
6.4　创建Bridge 网络 …………………………………………………………………… 144
6.4.1　Bridge Driver Create 实现 …………………………………………………… 144
6.4.2　Bridge Driver 初始化Linux Bridge 流程 …………………………………… 144
6.4.3　Bridge Driver Delete 实现 …………………………………………………… 148
6.4.4　测试 ………………………………………………………………………… 148
6.5　在Bridge 网络创建容器 …………………………………………………………… 149
6.5.1　挂载容器端点的流程 ……………………………………………………… 150
6.5.2　测试 ………………………………………………………………………… 156
6.6　容器跨主机网络 …………………………………………………………………… 159
6.6.1　跨主机容器网络的IPAM …………………………………………………… 160
6.6.2　跨主机容器网络通信的常见实现方式 …………………………………… 161
6.7　小结 ………………………………………………………………………………… 163
第7 章　高级实践……………………………………………………………………………… 164
7.1　使用mydocker 创建一个可访问的nginx 容器 …………………………………… 164
7.1.1　获取nginx tar 包 …………………………………………………………… 164
7.1.2　构建自己的nginx 镜像 ……………………………………………………… 165
7.1.3　运行mynginx 容器 ………………………………………………………… 167
7.2　使用mydocker 创建一个flask + redis 的计数器 ………………………………… 169
7.2.1　创建redis 容器 ……………………………………………………………… 169
7.2.2　制作flask 镜像 ……………………………………………………………… 173
7.2.3　创建myflask 容器 …………………………………………………………… 176
7.3　runC ………………………………………………………………………………… 177
7.3.1　简介 ………………………………………………………………………… 177
7.3.2　OCI 标准包（bundle） ……………………………………………………… 177
目录XV
7.3.3　config.json …………………………………………………………………… 178
7.3.4　mounts ……………………………………………………………………… 178
7.3.5　process ……………………………………………………………………… 179
7.3.6　user …………………………………………………………………………… 179
7.3.7　hostname …………………………………………………………………… 180
7.3.8　platform ……………………………………………………………………… 180
7.3.9　钩子（Hook） ……………………………………………………………… 181
7.4　runC 创建容器流程 ………………………………………………………………… 182
7.5　Docker containerd 项目介绍 ………………………………………………………… 186
7.5.1　架构 ………………………………………………………………………… 187
7.5.2　特性和路线图 ……………………………………………………………… 188
7.5.3　containerd 和Docker 之间的关系 ………………………………………… 188
7.5.4　containerd、OCI 和runC 之间的关系 ……………………………………… 188
7.5.5　containerd 和容器编排系统的关系 ………………………………………… 189
7.6　Kubernetes CRI 容器引擎 …………………………………………………………… 189
7.6.1　什么是CRI ………………………………………………………………… 189
7.6.2　为什么需要CRI …………………………………………………………… 193
7.6.3　为什么CRI 是接口且是基于容器的而不是基于Pod 的 ………………… 193
7.6.4　如何使用CRI ……………………………………………………………… 193
7.6.5　CRI 的目标 ………………………………………………………………… 194
7.6.6　已知的问题 ………………………………………………………………… 194
7.7　小结 ………………………………………………………………………………… 195
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>自己动手写Docker
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker——容器与容器云
第一部分　Docker深入解读
第1章　从容器到容器云　　2
1.1　云计算平台　　2
1.2　容器，新的革命　　3
1.3　进化：从容器到容器云　　7
第2章　Docker基础　　8
2.1　Docker的安装　　8
2.2　Docker操作参数解读　　9
2.3　搭建你的第一个Docker应用栈　　16
2.3.1　Docker集群部署　　16
2.3.2　第一个Hello World　　17
2.3.3　开发、测试和发布一体化　　27
第3章　Docker核心原理解读　　28
3.1　Docker背后的内核知识　　28
3.1.1　namespace资源隔离　　28
3.1.2　cgroups资源限制　　45
3.2　Docker架构概览　　53
3.3　client和daemon　　55
3.3.1　client模式　　55
3.3.2　daemon模式　　57
3.3.3　从client到daemon　　63
3.4　libcontainer　　66
3.4.1　libcontainer的工作方式　　68
3.4.2　libcontainer实现原理　　69
3.4.3　使用nsinit与libcontainer进行交互　　74
3.5　Docker镜像管理　　76
3.5.1　什么是Docker镜像　　76
3.5.2　Docker镜像关键概念　　78
3.5.3　Docker镜像操作解析　　80
3.5.4　Docker容器的迁移方法　　84
3.6　Docker存储驱动　　85
3.6.1　存储驱动的功能与管理　　86
3.6.2　aufs与Device Mapper驱动　　87
3.7　Docker数据卷　　93
3.7.1　数据卷的使用方式　　94
3.7.2　数据卷原理解读　　98
3.8 Docker网络管理　　102
3.8.1　Docker网络基础　　102
3.8.2　Docker daemon网络配置原理　　107
3.8.3　libcontainer网络配置原理　　111
3.8.4　Link原理解析　　115
3.9 Docker与容器安全　　118
3.9.1　Docker的安全机制　　118
3.9.2　Docker安全问题　　122
3.9.3　Docker安全的解决方案　　126
第4章　Docker高级实践技巧　　138
4.1　容器化思维　　138
4.1.1　SSH服务器的替代方案　　139
4.1.2　Docker内应用日志管理方案　　139
4.1.3　其他技巧汇总　　140
4.2　Docker高级网络实践　　142
4.2.1　玩转Linux network namespace　　143
4.2.2　pipework原理解析　　148
4.2.3　pipework跨主机通信　　154
4.2.4　OVS划分VLAN　　159
4.2.5　OVS隧道模式　　163
4.3　Dockerfile最佳实践　　175
4.3.1　Dockerfile的使用　　176
4.3.2　Dockerfile实践心得　　180
4.4　Docker容器的监控手段　　182
4.4.1　Docker容器监控维度　　182
4.4.2　容器监控命令　　183
4.4.3　常用的容器监控工具　　186
4.5　容器化应用构建的基础：高可用配置中心　　189
4.5.1　etcd经典应用场景　　190
4.5.2　etcd实现原理　　194
第二部分　Docker云平台解读
第5章　构建自己的容器云　　210
5.1　再谈云平台的层次架构　　210
5.2　从小工到专家　　213
第6章　专注编排与部署：三剑客与Fleet　　218
6.1　编排小神器Fig　　218
6.1.1　再谈容器编排与部署　　218
6.1.2　Compose原理：一探究竟　　221
6.2　环境透明化工具Machine　　225
6.2.1　Machine与虚拟机软件　　226
6.2.2　Machine与IaaS平台　　227
6.2.3　Machine小结　　228
6.3　集群抽象工具Swarm　　229
6.3.1　Swarm简介　　229
6.3.2　试用Swarm　　230
6.3.3　Swarm集群的多种创建方式　　231
6.3.4　Swarm对请求的处理　　233
6.3.5　Swarm集群的调度策略　　233
6.3.6　Swarm与Machine　　234
6.4　编排之秀Fleet　　235
6.4.1　旧问题新角度：Docker distro　　235
6.4.2　Fleet的原理剖析　　239
第7章　专注应用支撑和运行时：Flynn 和Deis　　245
7.1　Flynn，一个小而美的两层架构　　245
7.1.1　第0层：容器云的基础设施　　 246
7.1.2　第1层：容器云的功能框架　　 246
7.1.3　Flynn体系架构与实现原理　　 247
7.2　谈谈Deis与Flynn　　 257
7.2.1　应用发布上的比较　　 258
7.2.2　关于Deis的一些思考　　 260
第8章　一切皆容器：Kubernetes　　 261
8.1　Kubernetes简介　　 261
8.2　Kubernetes的设计解读　　 262
8.2.1　一个典型案例：Guestbook. 263
8.2.2　Kubernetes核心概念剖析　　 265
8.3　Kubernetes核心组件解读　　 294
8.3.1　APIServer　　 294
8.3.2　Scheduler　　 301
8.3.3　Controller Manager　　 309
8.3.4　kubelet　　 314
8.3.5　kube-proxy　　 320
8.3.6　核心组件协作流程　　 325
8.4　Kubernetes用户认证授权与资源管理　　 328
8.4.1　namespace解析　　 328
8.4.2　基于token文件或客户端证书的认证机制　　 333
8.4.3　基于访问规则的授权机制　　 334
8.4.4　基于资源的授权控制AdmissionControl　　 336
8.5　Kubernetes网络核心原理　　 347
8.5.1　单pod单IP模型　　 348
8.5.2　pod和网络容器　　 350
8.5.3　实现Kubernetes的网络模型　　 353
8.6　Kubernetes高级实践　　 356
8.6.1　Kubernetes高级实践之应用健康检查　　 356
8.6.2　Kubernetes高级实践之高可用性　　 358
8.6.3　Kubernetes高级实践之日志　　 362
8.6.4　Kubernetes高级实践之集成DNS　　 364
8.6.5　Kubernetes高级实践之容器上下文环境　　 366
8.7　不要停止思考　　368
第三部分　附录
附录A　Docker的安装　　 372
附录B　阅读Docker源代码的神兵利器　　 379
附录C　快速熟悉开源项目　　 388
附录D　cgroups的测试与使用　　 391
附录E　cgroups子系统配置参数介绍　　 395
附录F　Kubernetes的安装　　 400
后记　　 403
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker——容器与容器云
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker 技术入门与实战
序一
序二
前言
作者简介
第一部分　Docker入门
第1章　初识Docker	3
1.1　什么是Docker	3
1.2　为什么要使用Docker	5
1.3　虚拟化与Docker	7
1.4　本章小结	8
第2章　Docker的核心概念和安装	9
2.1　核心概念	9
2.2　安装Docker	11
2.3　本书环境介绍	14
2.4　本章小结	15
第3章　镜像	16
3.1　获取镜像	16
3.2　查看镜像信息	17
3.3　搜寻镜像	20
3.4　删除镜像	21
3.5　创建镜像	23
3.6　存出和载入镜像	24
3.7　上传镜像	25
3.8　本章小结	25
第4章　容器	26
4.1　创建容器	26
4.2　终止容器	28
4.3　进入容器	29
4.4　删除容器	31
4.5　导入和导出容器	31
4.6　本章小结	32
第5章　仓库	33
5.1　Docker Hub	33
5.2　Docker Pool简介	35
5.3　创建和使用私有仓库	36
5.4　本章小结	38
第6章　数据管理	39
6.1　数据卷	39
6.2　数据卷容器	40
6.3　利用数据卷容器迁移数据	42
6.4　本章小结	42
第7章　网络基础配置	43
7.1　端口映射实现访问容器	43
7.2　容器互联实现容器间通信	45
7.3　本章小结	47
第8章　使用Dockerfile创建镜像	48
8.1　基本结构	48
8.2　指令	49
8.3　创建镜像	53
8.4　本章小结	53
第二部分　实战案例
第9章　操作系统	57
9.1　Busybox	57
9.2　Debian/Ubuntu	60
9.3　CentOS/Fedora	62
9.4　CoreOS	64
9.5　本章小结	69
第10章　创建支持SSH服务的镜像	70
10.1　基于commit命令创建	70
10.2　使用Dockerfile创建	74
10.3　本章小结	79
第11章　Web服务器与应用	80
11.1　Apache	80
11.2　Nginx	86
11.3　Tomcat	95
11.4　Weblogic	102
11.5　LAMP	119
11.5.1　下载LAMP镜像	119
11.5.2　使用默认方式启动LAMP容器	119
11.5.3　部署自己的PHP应用	120
11.5.4　在PHP程序中连接数据库	120
11.6　CMS	121
11.7　本章小结	123
第12章　数据库应用	124
12.1　MySQL	124
12.2　Oracle XE	129
12.3　MongoDB	130
12.4　本章小结	134
第13章　编程语言	136
13.1　PHP	136
13.1.1　PHP技术栈	136
13.1.2　PHP常用框架	142
13.1.3　相关资源	147
13.2　C/C++	147
13.2.1　GCC	147
13.2.2　LLVM	150
13.2.3　Clang	150
13.3　Java	151
13.4　Python	153
13.4.1　Python技术栈	153
13.4.2　Flask	155
13.4.3　Django	157
13.4.4　相关资源	159
13.5　Perl	160
13.5.1　Perl技术栈	160
13.5.2　Catalyst	161
13.5.3　相关资源	161
13.6　Ruby	162
13.6.1　Ruby技术栈	162
13.6.2　JRuby	163
13.6.3　Ruby on Rails	164
13.6.4　Sinatra	165
13.6.5　相关资源	166
13.7　JavaScript	166
13.7.1　JavaScript技术栈	166
13.7.2　Node.js	167
13.7.3　Express	168
13.7.4　AngularJS	170
13.7.5　相关资源	171
13.8　Go	172
13.8.1　Go技术栈	172
13.8.2　Beego	174
13.8.3　Revel	175
13.8.4　Martini	177
13.8.5　相关资源	179
13.9　本章小结	180
第14章　使用私有仓库	181
14.1　使用docker-registry	181
14.2　用户认证	183
14.3　使用私有仓库批量上传镜像	186
14.4　仓库配置文件	189
14.5　本章小结	196
第15章　构建Docker容器集群	197
15.1　使用自定义网桥连接跨主机容器	197
15.2　使用Ambassador容器	199
15.3　本章小结	200
第16章　在公有云上使用Docker	202
16.1　公有云上安装Docker	202
16.1.1　CentOS 6.5系统	202
16.1.2　Ubuntu 14.04系统	207
16.2　阿里云Docker的特色服务	207
16.3　本章小结	213
第17章　Docker实践之道	214
17.1　个人学习之道	214
17.1.1　温故而知新	215
17.1.2　众人拾柴火焰高	216
17.2　技术创业之道	217
17.3　中小型企业实践之道	218
17.3.1　开发、测试和发布中应用Docker	218
17.3.2　应用Docker到生产环境	220
17.4　本章小结	220
第三部分　高级话题
第18章　Docker核心技术	223
18.1　基本架构	223
18.2　命名空间	225
18.3　控制组	227
18.4　联合文件系统	229
18.5　Docker网络实现	230
18.6　本章小结	232
第19章　Docker安全	233
19.1　命名空间隔离的安全	233
19.2　控制组资源控制的安全	234
19.3　内核能力机制	234
19.4　Docker服务端的防护	235
19.5　其他安全特性	236
19.6　本章小结	237
第20章　高级网络配置	238
20.1　网络启动与配置参数	238
20.2　配置容器DNS和主机名	240
20.3　容器访问控制	241
20.4　映射容器端口到宿主主机的实现	243
20.5　配置docker0网桥	244
20.6　自定义网桥	245
20.7　创建一个点到点连接	246
20.8　工具和项目	247
20.9　本章小结	251
第21章　Docker相关项目	252
21.1　平台即服务方案	252
21.2　持续集成	253
21.3　管理工具	256
21.4　编程开发	261
21.5　其他项目	262
21.6　本章小结	267
附　　录
附录A　常见问题汇总	270
附录B　常见仓库	276
附录C　Docker命令查询	294
附录D　Docker资源链接	299
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker 技术入门与实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud与Docker微服务架构实战
1 微服务架构概述. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.1 单体应用架构存在的问题1
1.2 如何解决单体应用架构存在的问题3
1.3 什么是微服务3
1.4 微服务架构的优点与挑战5
1.4.1 微服务架构的优点5
1.4.2 微服务架构面临的挑战5
1.5 微服务设计原则6
1.6 如何实现微服务架构7
1.6.1 技术选型7
1.6.2 架构图及常用组件8
2 微服务开发框架——Spring Cloud . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2.1 Spring Cloud 简介10
2.2 Spring Cloud 特点10
2.3 Spring Cloud 版本11
2.3.1 版本简介11
2.3.2 子项目一览12
2.3.3 Spring Cloud/Spring Boot 版本兼容性13
3 开始使用Spring Cloud 实战微服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
3.1 Spring Cloud 实战前提14
3.1.1 技术储备14
3.1.2 工具及软件版本15
3.2 服务提供者与服务消费者16
3.3 编写服务提供者16
3.3.1 手动编写项目17
3.3.2 使用Spring Initializr 快速创建Spring Boot 项目21
3.4 编写服务消费者23
3.5 为项目整合Spring Boot Actuator 25
3.6 硬编码有哪些问题27
4 微服务注册与发现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
4.1 服务发现简介29
4.2 Eureka 简介31
4.3 Eureka 原理31
4.4 编写Eureka Server 33
4.5 将微服务注册到Eureka Server 上35
4.6 Eureka Server 的高可用36
4.6.1 将应用注册到Eureka Server 集群上38
4.7 为Eureka Server 添加用户认证39
4.7.1 将微服务注册到需认证的Eureka Server 40
4.8 理解Eureka 的元数据41
4.8.1 改造用户微服务41
4.8.2 改造电影微服务41
4.9 Eureka Server 的REST 端点43
4.9.1 示例45
4.9.2 注销微服务实例49
4.10 Eureka 的自我保护模式51
4.11 多网卡环境下的IP 选择52
4.11.1 忽略指定名称的网卡52
4.11.2 使用正则表达式，指定使用的网络地址52
4.11.3 只使用站点本地地址53
4.11.4 手动指定IP 地址53
4.12 Eureka 的健康检查53
5 使用Ribbon 实现客户端侧负载均衡. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
5.1 Ribbon 简介56
5.2 为服务消费者整合Ribbon 57
5.3 使用Java 代码自定义Ribbon 配置60
5.4 使用属性自定义Ribbon 配置63
5.5 脱离Eureka 使用Ribbon 64
6 使用Feign 实现声明式REST 调用. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
6.1 Feign 简介67
6.2 为服务消费者整合Feign 67
6.3 自定义Feign 配置69
6.4 手动创建Feign 72
6.4.1 修改用户微服务72
6.4.2 修改电影微服务76
6.5 Feign 对继承的支持78
6.6 Feign 对压缩的支持79
6.7 Feign 的日志80
6.8 使用Feign 构造多参数请求82
6.8.1 GET 请求多参数的URL 82
6.8.2 POST 请求包含多个参数83
7 使用Hystrix 实现微服务的容错处理. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
7.1 实现容错的手段85
7.1.1 雪崩效应85
7.1.2 如何容错86
7.2 使用Hystrix 实现容错88
7.2.1 Hystrix 简介88
7.2.2 通用方式整合Hystrix 89
7.2.3 Hystrix 断路器的状态监控与深入理解91
7.2.4 Hystrix 线程隔离策略与传播上下文93
7.2.5 Feign 使用Hystrix 96
7.3 Hystrix 的监控101
7.3.1 Feign 项目的Hystrix 监控102
7.4 使用Hystrix Dashboard 可视化监控数据103
7.5 使用Turbine 聚合监控数据105
7.5.1 Turbine 简介105
7.5.2 使用Turbine 监控多个微服务105
7.5.3 使用消息中间件收集数据108
8 使用Zuul 构建微服务网关. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
8.1 为什么要使用微服务网关113
8.2 Zuul 简介115
8.3 编写Zuul 微服务网关115
8.4 Zuul 的路由端点118
8.5 Zuul 的路由配置详解119
8.6 Zuul 的安全与Header 122
8.6.1 敏感Header 的设置122
8.6.2 忽略Header 123
8.7 使用Zuul 上传文件124
8.7.1 编写文件上传微服务124
8.8 Zuul 的过滤器127
8.8.1 过滤器类型与请求生命周期127
8.8.2 编写Zuul 过滤器128
8.8.3 禁用Zuul 过滤器130
8.9 Zuul 的容错与回退130
8.9.1 为Zuul 添加回退131
8.10 Zuul 的高可用133
8.10.1 Zuul 客户端也注册到了Eureka Server 上133
8.10.2 Zuul 客户端未注册到Eureka Server 上133
8.11 使用Sidecar 整合非JVM 微服务134
8.11.1 编写Node.js 微服务135
8.11.2 编写Sidecar 136
8.11.3 Sidecar 的端点138
8.11.4 Sidecar 与Node.js 微服务分离部署139
8.11.5 Sidecar 原理分析139
9 使用Spring Cloud Config 统一管理微服务配置. . . . . . . . . . . . . . . . . . . . . . . 142
9.1 为什么要统一管理微服务配置142
9.2 Spring Cloud Config 简介143
9.3 编写Config Server 144
9.3.1 Config Server 的端点145
9.4 编写Config Client 147
9.5 Config Server 的Git 仓库配置详解149
9.6 Config Server 的健康状况指示器152
9.7 配置内容的加解密153
9.7.1 安装JCE 153
9.7.2 Config Server 的加解密端点153
9.7.3 对称加密153
9.7.4 存储加密的内容154
9.7.5 非对称加密155
9.8 使用/refresh 端点手动刷新配置155
9.9 使用Spring Cloud Bus 自动刷新配置157
9.9.1 Spring Cloud Bus 简介157
9.9.2 实现自动刷新158
9.9.3 局部刷新159
9.9.4 架构改进159
9.9.5 跟踪总线事件160
9.10 Spring Cloud Config 与Eureka 配合使用161
9.11 Spring Cloud Config 的用户认证162
9.11.1 Config Client 连接需用户认证的Config Server 163
9.12 Config Server 的高可用164
9.12.1 Git 仓库的高可用164
9.12.2 RabbitMQ 的高可用164
9.12.3 Config Server 自身的高可用165
10 使用Spring Cloud Sleuth 实现微服务跟踪. . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
10.1 为什么要实现微服务跟踪167
10.2 Spring Cloud Sleuth 简介168
10.3 整合Spring Cloud Sleuth 170
10.4 Spring Cloud Sleuth 与ELK 配合使用172
10.5 Spring Cloud Sleuth 与Zipkin 配合使用176
10.5.1 Zipkin 简介176
10.5.2 编写Zipkin Server 176
10.5.3 微服务整合Zipkin 178
10.5.4 使用消息中间件收集数据181
10.5.5 存储跟踪数据183
11 Spring Cloud 常见问题与总结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186
11.1 Eureka 常见问题186
11.1.1 Eureka 注册服务慢186
11.1.2 已停止的微服务节点注销慢或不注销187
11.1.3 如何自定义微服务的Instance ID 188
11.1.4 Eureka 的UNKNOWN 问题总结与解决189
11.2 Hystrix/Feign 整合Hystrix 后首次请求失败190
11.2.1 原因分析191
11.2.2 解决方案191
11.3 Turbine 聚合的数据不完整191
11.3.1 解决方案192
11.4 Spring Cloud 各组件配置属性193
11.4.1 Spring Cloud 的配置193
11.4.2 原生配置193
11.5 Spring Cloud 定位问题思路总结194
12 Docker 入门. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197
12.1 Docker 简介197
12.2 Docker 的架构197
12.3 安装Docker 199
12.3.1 系统要求199
12.3.2 移除非官方软件包199
12.3.3 设置Yum 源199
12.3.4 安装Dokcer 200
12.3.5 卸载Docker 201
12.4 配置镜像加速器201
12.5 Docker 常用命令202
12.5.1 Docker 镜像常用命令202
12.5.2 Docker 容器常用命令204
13 将微服务运行在Docker 上. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209
13.1 使用Dockerfile 构建Docker 镜像209
13.1.1 Dockerfile 常用指令210
13.1.2 使用Dockerfile 构建镜像215
13.2 使用Docker Registry 管理Docker 镜像217
13.2.1 使用Docker Hub 管理镜像217
13.2.2 使用私有仓库管理镜像219
13.3 使用Maven 插件构建Docker 镜像220
13.3.1 快速入门221
13.3.2 插件读取Dockerfile 进行构建222
13.3.3 将插件绑定在某个phase 执行223
13.3.4 推送镜像224
13.4 常见问题与总结226
14 使用Docker Compose 编排微服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227
14.1 Docker Compose 简介227
14.2 安装Docker Compose 227
14.2.1 安装Compose 228
14.2.2 安装Compose 命令补全工具228
14.3 Docker Compose 快速入门229
14.3.1 基本步骤229
14.3.2 入门示例229
14.3.3 工程、服务、容器230
14.4 docker-compose.yml 常用命令230
14.4.1 build 230
14.4.2 command 231
14.4.3 dns 231
14.4.4 dns_search 231
14.4.5 environment 231
14.4.6 env_file 232
14.4.7 expose 232
14.4.8 external_links 232
14.4.9 image 232
14.4.10 links 232
14.4.11 networks 233
14.4.12 network_mode 233
14.4.13 ports 233
14.4.14 volumes 233
14.4.15 volumes_from 234
14.5 docker-compose 常用命令234
14.5.1 build 234
14.5.2 help 235
14.5.3 kill 235
14.5.4 logs 235
14.5.5 port 235
14.5.6 ps 235
14.5.7 pull 235
14.5.8 rm 236
14.5.9 run 236
14.5.10 scale 236
14.5.11 start 236
14.5.12 stop 236
14.5.13 up 236
14.6 Docker Compose 网络设置237
14.6.1 基本概念237
14.6.2 更新容器237
14.6.3 links 238
14.6.4 指定自定义网络238
14.6.5 配置默认网络239
14.6.6 使用已存在的网络239
14.7 综合实战：使用Docker Comose 编排Spring Cloud 微服务240
14.7.1 编排Spring Cloud 微服务240
14.7.2 编排高可用的Eureka Server 243
14.7.3 编排高可用Spring Cloud 微服务集群及动态伸缩245
14.8 常见问题与总结247
后记. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 248
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud与Docker微服务架构实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker开发指南
前言　　xi
第一部分　背景与基础
第1章　何谓容器，为何需要它　　3
1.1　容器与虚拟机的比较　　4
1.2　Docker与容器　　5
1.3　Docker的历史　　7
1.4　插件与基础设施　　8
1.5　64位Linux　　9
第2章　安装　　10
2.1　在Linux上安装 Docker　　10
2.1.1　将SELinux置于宽容模式下运行　　11
2.1.2　不使用sudo命令执行 Docker　　11
2.2　在 Mac OS及Windows上安装 Docker　　12
2.3　快速确认　　13
第3章　迈出第一步　　15
3.1　运行第一个镜像　　15
3.2　基本命令　　16
3.3　通过Dockerfile创建镜像　　20
3.4　使用寄存服务　　22
3.5　使用Redis官方镜像　　24
3.6　总结　　27
第4章　Docker基本概念　　28
4.1　Docker系统架构　　28
4.1.1　底层技术　　29
4.1.2　周边技术　　30
4.1.3　Docker托管　　31
4.2　镜像是如何生成的　　32
4.2.1　构建环境的上下文　　32
4.2.2　镜像层　　33
4.2.3　缓存　　35
4.2.4　基础镜像　　35
4.2.5　Dockerfile指令　　37
4.3　使容器与世界相连　　39
4.4　容器互联　　40
4.5　利用数据卷和数据容器管理数据　　41
4.5.1　共享数据　　43
4.5.2　数据容器　　44
4.6　Docker常用命令　　45
4.6.1　run命令　　46
4.6.2　容器管理　　48
4.6.3　Docker信息　　50
4.6.4　容器信息　　50
4.6.5　镜像管理　　52
4.6.6　使用寄存服务器　　54
4.7　总结　　55
第二部分　Docker与软件生命周期
第5章　在开发中应用Docker　　59
5.1　说声“Hello World!”　　59
5.2　通过Compose实现自动化　　67
5.3　总结　　69
第6章　创建一个简单的Web应用　　71
6.1　创建一个基本网页　　72
6.2　利用现有镜像　　73
6.3　实现缓存功能　　78
6.4　微服务　　81
6.5　总结　　81
第7章　镜像分发　　82
7.1　镜像及镜像库的命名方式　　82
7.2　Docker Hub　　83
7.3　自动构建　　85
7.4　私有分发　　86
7.4.1　运行自己的寄存服务　　86
7.4.2　商业寄存服务　　92
7.5　缩减镜像大小　　92
7.6　镜像出处　　94
7.7　总结　　94
第8章　Docker持续集成与测试　　95
8.1　为identidock添加单元测试　　95
8.2　创建Jenkins容器　　100
8.3　推送镜像　　106
8.3.1　给镜像正确的标签　　106
8.3.2　准生产及生产环境　　108
8.3.3　镜像数量激增的问题　　108
8.3.4　使用Docker部署Jenkins slaves　　109
8.4　备份Jenkins数据　　109
8.5　持续集成的托管解决方案　　109
8.6　测试与微服务　　110
8.7　总结　　111
第9章　部署容器　　113
9.1　通过Docker Machine配置资源　　114
9.2　使用代理　　117
9.3　执行选项　　122
9.3.1　shell脚本　　122
9.3.2　使用进程管理器（或用systemd控制所有进程）　　124
9.3.3　使用配置管理工具　　127
9.4　主机配置　　130
9.4.1　选择操作系统　　130
9.4.2　选择存储驱动程序　　130
9.5　专门的托管方案　　132
9.5.1　Triton　　132
9.5.2　谷歌容器引擎　　134
9.5.3　亚马逊EC2容器服务　　135
9.5.4　Giant Swarm　　136
9.6　持久性数据和生产环境容器　　138
9.7　分享秘密信息　　139
9.7.1　在镜像中保存秘密信息　　139
9.7.2　通过环境变量传递密钥　　139
9.7.3　通过数据卷传递密钥　　140
9.7.4　使用键值存储　　140
9.8　网络连接　　141
9.9　生产环境的寄存服务　　141
9.10　持续部署/交付　　141
9.11　总结　　142
第10章　日志记录和监控　　143
10.1　日志记录　　144
10.1.1　Docker默认的日志记录　　144
10.1.2　日志汇总　　145
10.1.3　使用ELK 进行日志记录　　146
10.1.4　通过syslog实现日志管理　　155
10.1.5　从文件抓取日志　　160
10.2　监控和警报　　161
10.2.1　使用Docker工具进行监测　　161
10.2.2　cAdvisor　　162
10.2.3　集群解决方案　　163
10.3　商用的监听及日志记录解决方案　　166
10.4　总结　　166
第三部分　工具和技术
第11章　联网和服务发现　　169
11.1　大使容器　　170
11.2　服务发现　　173
11.2.1　etcd　　173
11.2.2　SkyDNS　　177
11.2.3　Consul　　181
11.2.4　服务注册　　185
11.2.5　其他解决方案　　186
11.3　联网选项　　187
11.3.1　网桥模式　　187
11.3.2　主机模式　　188
11.3.3　容器模式　　188
11.3.4　 未联网模式　　188
11.4　全新的Docker联网功能　　188
11.5　网络解决方案　　190
11.5.1　Overlay　　191
11.5.2　Weave　　193
11.5.3　Flannel　　196
11.5.4　Calico项目　　201
11.6　总结　　205
第12章　编排、集群和管理　　207
12.1　集群和编排工具　　208
12.1.1　Swarm　　208
12.1.2　fleet　　214
12.1.3　Kubernetes　　219
12.1.4　Mesos和Marathon　　226
12.2　容器管理平台　　235
12.2.1　Rancher　　236
12.2.2　Clocker　　237
12.2.3　Tutum　　238
12.3　总结　　239
第13章　容器安全与限制容器　　241
13.1　需要考虑的事项　　242
13.2　纵深防御　　244
13.3　如何保护identidock　　245
13.4　以主机隔离容器　　246
13.5　进行更新　　246
13.6　镜像出处　　249
13.6.1　Docker摘要　　250
13.6.2　Docker的内容信任机制　　250
13.6.3　可复制及可信任的Dockerfile　　254
13.7　安全建议　　256
13.7.1　设置用户　　256
13.7.2　限制容器联网　　257
13.7.3　删除setuid和setgid的二进制文件　　258
13.7.4　限制内存使用　　259
13.7.5　限制CPU 使用　　260
13.7.6　限制重新启动　　261
13.7.7　限制文件系统　　261
13.7.8　限制内核能力　　262
13.7.9　应用资源限制　　263
13.8　运行加固内核　　264
13.9　Linux安全模块　　265
13.9.1　SELinux　　265
13.9.2　AppArmor　　268
13.10　审核　　268
13.11　事件响应　　269
13.12　未来特性　　269
13.13　总结　　270
作者简介　　271
关于封面　　271
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker开发指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Kubernetes权威指南
第1章Kubernetes入门	1
1.1  Kubernetes是什么	1
1.2  为什么要用Kubernetes	4
1.3  从一个不简单的Hello World例子说起	5
1.3.1  创建redis-master Pod和服务	7
1.3.2  创建redis-slave Pod和服务	10
1.3.3  创建frontend Pod和服务	12
1.3.4  通过浏览器访问网页	15
1.4  Kubernetes基本概念和术语	16
1.4.1  Node（节点）	16
1.4.2  Pod	18
1.4.3  Label（标签）	20
1.4.4  Replication Controller（RC）	24
1.4.5  Service（服务）	26
1.4.6  Volume（存储卷）	30
1.4.7  Namespace（命名空间）	34
1.4.8  Annotation（注解）	35
1.4.9  小结	36
1.5  Kubernetes总体架构	36
1.6  Kubernetes安装与配置	38
1.6.1  安装Kubernetes	38
1.6.2  配置和启动Kubernetes服务	39
1.6.3  Kubernetes的版本升级	46
1.6.4  内网中的Kubernetes相关配置	46
1.6.5  Kubernetes对Docker镜像的要求——启动命令前台执行	48
第2章Kubernetes核心原理	49
2.1  Kubernetes API Server 分析	49
2.1.1  如何访问Kubernetes API	49
2.1.2  通过API Server 访问Node、Pod和Service	52
2.1.3  集群功能模块之间的通信	55
2.2  调度控制原理	56
2.2.1  Replication Controller	57
2.2.2  Node Controller	60
2.2.3  ResourceQuota Controller	62
2.2.4  Namespace Controller	64
2.2.5  ServiceAccount Controller与Token Controller	64
2.2.6  Service Controller与Endpoint Controller	65
2.2.7  Kubernetes Scheduler	71
2.3  Kubelet运行机制分析	75
2.3.1  节点管理	75
2.3.2  Pod管理	76
2.3.3  容器健康检查	77
2.3.4  cAdvisor资源监控	78
2.4  安全机制的原理	80
2.4.1  Authentication认证	80
2.4.2  Authorization授权	83
2.4.3  Admission Control准入控制	84
2.4.4  Secret私密凭据	88
2.4.5  Service Account	92
2.5  网络原理	95
2.5.1  Kubernetes网络模型	95
2.5.2  Docker的网络基础	97
2.5.3  Docker的网络实现	109
2.5.4  Kubernetes的网络实现	117
2.5.5  开源的网络组件	127
2.5.6  Kubernetes网络试验	131
第3章Kubernetes开发指南	145
3.1  REST简述	145
3.2  Kubernetes API详解	147
3.2.1  Kubernetes API概述	147
3.2.2  API版本	152
3.2.3  API详细说明	152
3.2.4  API响应说明	154
3.3  使用Java程序访问Kubernetes API	156
3.3.1  Jersey	156
3.3.2  Fabric8	168
3.3.3  使用说明	169
第4章Kubernetes运维指南	191
4.1  Kubernetes核心服务配置详解	191
4.1.1  基础公共配置参数	191
4.1.2  kube-apiserver	192
4.1.3  kube-controller-manager	195
4.1.4  kube-scheduler	196
4.1.5  Kubelet	197
4.1.6  kube-proxy	199
4.2  关键对象定义文件详解	200
4.2.1  Pod定义文件详解	200
4.2.2  RC定义文件详解	203
4.2.3  Service定义文件详解	204
4.3  常用运维技巧集锦	206
4.3.1  Node的隔离和恢复	206
4.3.2  Node的扩容	207
4.3.3  Pod动态扩容和缩放	208
4.3.4  更新资源对象的Label	208
4.3.5  将Pod调度到指定的Node	209
4.3.6  应用的滚动升级	210
4.3.7  Kubernetes集群高可用方案	213
4.4  资源配额管理	217
4.4.1  指定容器配额	217
4.4.2  全局默认配额	218
4.4.3  多租户配额管理	221
4.5  Kubernetes网络配置方案详解	223
4.5.1  直接路由方案	224
4.5.2  使用flannel叠加网络	226
4.5.3  使用Open vSwitch	228
4.6  Kubernetes集群监控	232
4.6.1  使用kube-ui查看集群运行状态	232
4.6.2  使用cAdvisor查看容器运行状态	236
4.7  Trouble Shooting指导	241
4.7.1  对象的Event事件	242
4.7.2  容器日志	243
4.7.3  Kubernetes系统日志	244
4.7.4  常见问题	246
4.7.5  寻求帮助	249
第5章Kubernetes高级案例进阶	250
5.1  Kubernetes DNS服务配置案例	250
5.1.1  skydns配置文件	251
5.1.2  修改每个Node上的Kubelet启动参数	254
5.1.3  创建skydns Pod和服务	254
5.1.4  通过DNS查找Service	255
5.1.5  DNS服务的工作原理解析	256
5.2  Kubernetes集群性能监控案例	257
5.2.1  配置Kubernetes集群的ServiceAccount和Secret	258
5.2.2  部署Heapster、InfluxDB、Grafana	261
5.2.3  查询InfluxDB数据库中的数据	265
5.2.4  Grafana页面查看和操作	268
5.3  Cassandra集群部署案例	269
5.3.1  自定义SeedProvider	270
5.3.2  通过Service动态查找Pod	271
5.3.3  Cassandra集群新节点的自动添加	274
5.4  集群安全配置案例	275
5.4.1  双向认证配置	275
5.4.2  简单认证配置	279
5.5  不同工作组共享Kubernetes集群的案例	280
5.5.1  创建namespace	281
5.5.2  定义Context（运行环境）	281
5.5.3  设置工作组在特定Context环境中工作	282
第6章Kubernetes源码导读	285
6.1  Kubernetes源码结构和编译步骤	285
6.2  kube-apiserver进程源码分析	289
6.2.1  进程启动过程	289
6.2.2  关键代码分析	291
6.2.3  设计总结	306
6.3  kube-controller-manager进程源码分析	310
6.3.1  进程启动过程	310
6.3.2  关键代码分析	313
6.3.3  设计总结	321
6.4  kube-scheduler进程源码分析	323
6.4.1  进程启动过程	323
6.4.2  关键代码分析	328
6.4.3  设计总结	335
6.5  Kubelet进程源码分析	337
6.5.1  进程启动过程	337
6.5.2  关键代码分析	342
6.5.3  设计总结	365
6.6  kube-proxy进程源码分析	366
6.6.1  进程启动过程	367
6.6.2  关键代码分析	368
6.6.3  设计总结	383
6.7  Kubectl进程源码分析	384
6.7.1  kubectl create命令	385
6.7.2  rolling-upate命令	389
后记	396
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Kubernetes权威指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>每天5分钟玩转Docker容器技术
第1篇 启 程
第1章 鸟瞰容器生态系统 3
1.1 容器生态系统 3
1.2 本教程覆盖的知识范围 10
1.3 准备实验环境 10
1.3.1 环境选择 10
1.3.2 安装 Docker 10
1.4 运行第1个容器 11
1.5 小结 12
第二篇 容器技术
第2章 容器核心知识概述 15
2.1 What —— 什么是容器 15
2.2 Why —— 为什么需要容器 16
2.2.1 容器解决的问题 16
2.2.2 Docker 的特性 20
2.2.3 容器的优势 20
2.3 How —— 容器是如何工作的 21
2.4 小结 24
第3章 Docker 镜像 26
3.1 镜像的内部结构 26
3.1.1 hello-world —— 最小的镜像 26
3.1.2 base 镜像 27
3.1.3 镜像的分层结构 30
3.2 构建镜像 32
3.2.1 docker commit 32
3.2.2 Dockerfile 34
3.3 RUN vs CMD vs ENTRYPOINT 42
3.3.1 Shell 和 Exec 格式 42
3.3.2 RUN 44
3.3.3 CMD 44
3.3.4 ENTRYPOINT 45
3.3.5 最 佳实践 46
3.4 分发镜像 46
3.4.1 为镜像命名 46
3.4.2 使用公共 Registry 49
3.4.3 搭建本地 Registry 51
3.5 小结 52
第4章 Docker 容器 55
4.1 运行容器 55
4.1.1 让容器长期运行 56
4.1.2 两种进入容器的方法 57
4.1.3 运行容器的最 佳实践 59
4.1.4 容器运行小结 59
4.2 stop/start/restart 容器 60
4.3 pause / unpause 容器 61
4.4 删除容器 61
4.5 State Machine 62
4.6 资源限制 65
4.6.1 内存限额 65
4.6.2 CPU 限额 66
4.6.3 Block IO 带宽限额 68
4.7 实现容器的底层技术 69
4.7.1 cgroup 70
4.7.2 namespace 70
4.8 小结 72
第5章 Docker 网络 74
5.1 none 网络 74
5.2 host 网络 75
5.3 bridge 网络 76
5.4 user-defined 网络 78
5.5 容器间通信 84
5.5.1 IP通信 84
5.5.2 Docker DNS Server 85
5.5.3 joined 容器 85
5.6 将容器与外部世界连接 87
5.6.1 容器访问外部世界 87
5.6.2 外部世界访问容器 90
5.7 小结 91
第6章 Docker 存储 92
6.1 storage driver 92
6.2 Data Volume 94
6.2.1 bind mount 94
6.2.2 docker managed volume 96
6.3 数据共享 99
6.3.1 容器与 host 共享数据 99
6.3.2 容器之间共享数据 99
6.4 volume container 100
6.5 data-packed volume container 102
6.6 Data Volume 生命周期管理 103
6.6.1 备份 104
6.6.2 恢复 104
6.6.3 迁移 104
6.6.4 销毁 104
6.7 小结 105
第三篇 容器进阶知识
第7章 多主机管理 109
7.1 实验环境描述 110
7.2 安装 Docker Machine 111
7.3 创建 Machine 112
7.4 管理Machine 114
第8章 容器网络 117
8.1 libnetwork & CNM 117
8.2 overlay 119
8.2.1 实验环境描述 120
8.2.2 创建overlay网络 121
8.2.3 在overlay中运行容器 122
8.2.4 overlay 网络连通性 124
8.2.5 overlay 网络隔离 126
8.2.6 overlay IPAM 127
8.3 macvlan 127
8.3.1 准备实验环境 127
8.3.2 创建 macvlan 网络 128
8.3.3 macvlan 网络结构分析 130
8.3.4 用 sub-interface 实现多 macvlan 网络 131
8.3.5 macvlan 网络间的隔离和连通 132
8.4 flannel 136
8.4.1 实验环境描述 137
8.4.2 安装配置 etcd 137
8.4.3 build flannel 138
8.4.4 将 flannel 网络的配置信息保存到 etcd 139
8.4.5 启动 flannel 139
8.4.6 配置 Docker 连接 flannel 141
8.4.7 将容器连接到 flannel 网络 143
8.4.8 flannel 网络连通性 144
8.4.9 flannel 网络隔离 146
8.4.10 flannel 与外网连通性 146
8.4.11 host-gw backend 146
8.5 weave 148
8.5.1 实验环境描述 148
8.5.2 安装部署 weave 149
8.5.3 在host1中启动weave 149
8.5.4 在 host1 中启动容器 150
8.5.5 在host2中启动weave并运行容器 153
8.5.6 weave 网络连通性 154
8.5.7 weave 网络隔离 155
8.5.8 weave 与外网的连通性 156
8.5.9 IPAM 158
8.6 calico 158
8.6.1 实验环境描述 159
8.6.2 启动 etcd 159
8.6.3 部署 calico 160
8.6.4 创建calico网络 161
8.6.5 在 calico 中运行容器 161
8.6.6 calico 默认连通性 164
8.6.7 calico policy 167
8.6.8 calico IPAM 169
8.7 比较各种网络方案 170
8.7.1 网络模型 171
8.7.2 Distributed Store 171
8.7.3 IPAM 171
8.7.4 连通与隔离 172
8.7.5 性能 172
第9章 容器监控 173
9.1 Docker自带的监控子命令 173
9.1.1 ps 173
9.1.2 ...74
9.1.3 stats 175
9.2 sysdig 175
9.3 Weave Scope 179
9.3.1 安装 179
9.3.2 容器监控 181
9.3.3 监控 host 184
9.3.4 多主机监控 186
9.4 cAdvisor 189
9.4.1 监控 Docker Host 189
9.4.2 监控容器 191
9.5 Prometheus 194
9.5.1 架构 194
9.5.2 多维数据模型 195
9.5.3 实践 196
9.6 比较不同的监控工具 204
9.7 几点建议 205
第10章 日志管理 207
10.1 Docker logs 207
10.2 Docker logging driver 209
10.3 ELK 211
10.3.1 日志处理流程 211
10.3.2 安装 ELK 套件 212
10.3.3 Filebeat 214
10.3.4 管理日志 216
10.4 Fluentd 220
10.4.1 安装 Fluentd 221
10.4.2 重新配置 Filebeat 221
10.4.3 监控容器日志 221
10.5 Graylog 222
10.5.1 Graylog 架构 222
10.5.2 部署 Graylog 223
10.5.3 配置 Graylog 225
10.5.4 监控容器日志 227
10.6 小结 229
第11章 数据管理 230
11.1 从一个例子开始 230
11.2 实践 Rex-Ray driver 232
11.2.1 安装 Rex-Ray 232
11.2.2 配置 VirtualBox 234
11.2.3 创建Rex-Ray volume 236
11.2.4 使用 Rex-Ray volume 237
写在最后 243
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>每天5分钟玩转Docker容器技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>PaaS实现与运维管理
第一部分　概念模型
第1章　分布式PaaS平台介绍	2
1.1　什么是PaaS	2
1.1.1　开发与运维之间的困局	2
1.1.2　DevOps的自动化	3
1.1.3　云计算的IaaS	4
1.1.4　PaaS的到来	4
1.1.5　PaaS的约束与开放	4
1.1.6　PaaS解决的具体问题	5
1.2　什么是分布式计算	6
1.2.1　分布式计算与PaaS	6
1.2.2　分布式平台的挑战	7
第2章　PaaS模型与特征	10
2.1　主流PaaS平台架构	10
2.1.1　谷歌GAE	10
2.1.2　AEB	11
2.1.3　Cloud Foundry	13
2.1.4　Heroku	14
2.2　PaaS与12-Factor	15
2.2.1　基准代码（Codebase）	15
2.2.2　依赖（Dependency）	16
2.2.3　配置（Config）	17
2.2.4　后端服务（Backing Services）	18
2.2.5　构建（Build）、发布（Release）、运行（Run）	19
2.2.6　进程（Process）	20
2.2.7　端口绑定（Port Binding）	21
2.2.8　并发（Concurrency）	21
2.2.9　快捷性（Disposable）	22
2.2.10　开发/生产环境等价（Dev/Prod Parity）	23
2.2.11　日志（Log）	24
2.2.12　管理进程（Admin Process）	25
2.3　PaaS与Reaction宣言	26
2.3.1　响应（Responsive）	26
2.3.2　韧性（Resilient）	26
2.3.3　弹性（Elastic）	27
2.3.4　消息驱动（Message Driven）	28
第二部分　基础原理
第3章　计算资源	30
3.1　图灵机与冯•诺伊曼模型	30
3.2　服务器的种类	34
3.3　一切都是二进制	37
3.3.1　整数表示法	38
3.3.2　文本表示法	39
3.3.3　音频信息表示法	41
3.4　操作系统——计算机系统的指挥官	42
3.4.1　操作系统解决的问题	42
3.4.2　企业级操作系统	43
3.4.3　服务器虚拟化	47
3.5　进程——资源聚合的抽象体	49
3.5.1　计算单元的构建	49
3.5.2　计算请求的拆解	51
第4章　网络资源	53
4.1　协议分层	53
4.1.1　OSI网络体系模型	54
4.1.2　OSI与TCP/IP协议簇	55
4.1.3　交换、选路与传输	56
4.2　网络物理设备	58
4.2.1　连线与接口	59
4.2.2　二层交换机	62
4.2.3　路由及三层交换	63
4.2.4　四～七层网络设备	64
4.2.5　现实网络构成	65
4.3　网络逻辑拓扑	65
4.4　对网络拓扑的考虑	66
4.5　对物理布线的考虑	67
4.6　网络虚拟化与SDN	70
第5章　存储资源	73
5.1　俯瞰存储系统	73
5.1.1　数据存储功能分类	73
5.1.2　文件存储的三个层级	74
5.2　磁盘与磁盘阵列	77
5.2.1　硬盘的物理构造	77
5.2.2　磁盘阵列	79
5.2.3　SCSI协议	81
5.3　存储、计算分离	82
5.3.1　磁盘柜与盘阵	82
5.3.2　FC存储网络	83
5.3.3　FC协议栈	86
5.3.4　FC寻址过程	87
5.3.5　FC交换机与适配器	88
5.3.6　FCoE与iSCSI	89
5.4　存储访问类型	90
5.4.1　NAS与SAN	90
5.4.2　分布式存储	92
第三部分　平台实现
第6章　平台功能与架构	96
6.1　平台运维需求	96
6.1.1　软件配置	96
6.1.2　服务部署	97
6.1.3　服务发现	97
6.1.4　监控恢复	97
6.2　平台功能划分	97
6.3　平台高阶架构	100
6.4　企业应用迁移	102
6.4.1　企业应用很“厚重”	102
6.4.2　应用部署架构	102
6.4.3　企业应用调整	104
第7章　计算单元Docker	108
7.1　Docker介绍	108
7.1.1　Docker是什么	108
7.1.2　Docker术语	109
7.1.3　Docker安装	111
7.2　Docker容器命令	112
7.2.1　run命令	112
7.2.2　start命令	115
7.2.3　stop命令	116
7.2.4　restart命令	116
7.2.5　attach命令	116
7.2.6　ps命令	116
7.2.7　inspect命令	117
7.3　Docker镜像命令	119
7.3.1　search、pull、push命令	120
7.3.2　commit命令	120
7.3.3　image、diff、rmi命令	121
7.3.4　save、load、export、import命令	121
7.4　Docker网络与链接	122
7.4.1　Docker网络模式	122
7.4.2　pipework管理网络	125
7.4.3　容器链接与数据卷	127
7.5　Dockerfile	129
7.5.1　基本指令集	130
7.5.2　环境指令集	131
7.5.3　数据指令集	132
7.5.4　ENTRYPOINT指令	132
第8章　分布式协调ZooKeeper	134
8.1　ZooKeeper介绍	134
8.1.1　ZooKeeper是什么	134
8.1.2　ZooKeeper架构	135
8.1.3　数据模型	136
8.1.4　监听与通知	139
8.1.5　API集合	139
8.1.6　会话	140
8.1.7　观察者	141
8.2　ZooKeeper使用	141
8.2.1　快速安装	141
8.2.2　基本操作	143
8.2.3　配置参数	145
8.2.4　动态重配置	149
8.2.5　监控	152
8.3　ZooKeeper进阶	157
8.3.1　分组与权重	158
8.3.2　Paxos算法	159
8.3.3　ZAB协议	163
8.3.4　分布式协调场景	165
第9章　资源管理Mesos	167
9.1　Mesos介绍	167
9.1.1　资源管理需求	167
9.1.2　Mesos的起源	169
9.2　Mesos架构与工作流	169
9.2.1　Mesos架构组件	169
9.2.2　Mesos资源管理的工作流程	170
9.3　Mesos安装配置	172
9.3.1　安装预先准备	172
9.3.2　构建Mesos	173
9.3.3　启动Mesos	174
9.3.4　高可用Mesos	178
9.3.5　Slave移除限速	182
9.4　Mesos运维	183
9.4.1　认证管理	183
9.4.2　监控管理	186
9.4.3　容器网络限速	192
9.4.4　Framework API限速	194
9.4.5　Restful接口	195
9.4.6　配置参数	196
9.5　Mesos资源分配	197
9.5.1　DRF算法	197
9.5.2　DRF权重	199
第10章　服务调度框架 Marathon	200
10.1　Marathon介绍	200
10.1.1　服务调度平台	200
10.1.2　Marathon实体模型	201
10.2　Marathon使用	203
10.2.1　安装启动	203
10.2.2　运行Shell程序	204
10.2.3　运行远程资源	208
10.2.4　Artifact Store	209
10.3　Docker容器运行	211
10.3.1　前提准备条件	211
10.3.2　端口资源分配	212
10.3.3　容器端口分配	215
10.3.4　其他使用方法	216
10.4　Marathon管理	217
10.4.1　应用组	217
10.4.2　策略约束	219
10.4.3　健康检查	221
10.4.4　应用部署	223
10.4.5　事件总线	227
10.4.6　命令行参数	229
10.5　服务发现	231
10.5.1　服务发现方法	231
10.5.2　Marathon方案	232
10.5.3　Mesos-DNS	235
10.5.4　Bamboo	239
10.6　Chronos作业调度	241
10.6.1　作业调度框架	241
10.6.2　安装运行	241
10.6.3　作业示例	242
10.6.4　REST API	243
第11章　大数据调度框架Spark	245
11.1　Apache Spark介绍	245
11.1.1　Apache Spark是什么	245
11.1.2　Lambda架构	246
11.1.3　Spark生态系统	247
11.2　Spark数据处理	248
11.2.1　Spark 运行模式	248
11.2.2　Spark Standalone模式	252
11.2.3　Spark on Mesos	255
11.2.4　Spark Streaming	257
第12章　日志集中管理ELK	261
12.1　日志集中	261
12.1.1　日志集中介绍	261
12.1.2　日志集中架构	262
12.1.3　日志集中框架	264
12.2　Logstash	266
12.2.1　Logstash介绍	266
12.2.2　快速安装	267
12.2.3　配置说明	269
12.2.4　部署架构	282
12.2.5　处理流程	285
12.2.6　input插件	286
12.2.7　output插件	292
12.2.8　filter插件	296
12.2.9　codec插件	299
12.3　Elasticsearch	300
12.3.1　基本概念	300
12.3.2　安装与使用	304
12.3.3　REST API	305
12.3.4　集群设置	309
12.3.5　备份恢复	314
12.3.6　监控管理	315
12.4　Kibana	317
12.4.1　Kibana介绍	317
12.4.2　discover功能	319
12.4.3　visualize功能	324
12.4.4　Dashboard功能	327
第四部分　运维管理
第13章　配置管理	330
13.1　配置管理系统分析	331
13.1.1　服务模型进行分层	331
13.1.2　各IDC团队发现CI	332
13.1.3　IDC管理团队定义CI属性	333
13.1.4　确定CI之间的关联	336
13.2　配置管理系统设计	338
13.2.1　用户界面设计	339
13.2.2　权限控制、规则定义和OPENAPI	341
13.2.3　数据模型的设计	343
13.3　配置管理数据准确性的保证	345
13.3.1　识别CI的OWNER	345
13.3.2　识别CI的生命周期、关联运维流程	346
13.3.3　数据有效性的审计	346
第14章　监控管理	348
14.1　运维监控管理的问题与价值	348
14.1.1　监控管理的无形价值	349
14.1.2　监控平台建立的基础	350
14.1.3　监控管理的WANT原则	350
14.2　对运维监控平台的需求分析	352
14.2.1　一次监控过程，调度、规则、告警	352
14.2.2　数据图形化：百分位裁剪、趋势分析、正态分布	358
14.2.3　开源的借鉴与选择：Zabbix和Nagios	361
14.2.4　商业与开源：最后的决策	372
14.3　JMX监控原理解析	373
14.3.1　JMX的体系结构	374
14.3.2　一个完整的JMX体系架构实例	376
14.3.3　通过JMX访问WebLogic Server MBean	379
14.4　SNMP监控原理解析	383
14.4.1　SNMP协议解析：MIB库与消息类型	383
14.4.2　使用SNMP4J实现服务器监控	386
14.4.3　Linux下的监控实现：NET-SNMP	390
14.4.4　MIB库浏览工具：ManageEngine	391
第15章　运维管理	392
15.1　服务级别管理，IT与业务的一致性	392
15.1.1　客户满意度与期望	393
15.1.2　服务目录——IT服务的菜谱	396
15.1.3　从宏观到可操作性的服务	397
15.2　变更管理，使服务有效传递	399
15.2.1　变更控制的角色、阶段	399
15.2.2　变更管理的六个原则	401
15.2.3　变更分类与风险定级	402
15.2.4　表单、步骤、模板与日历	405
15.3　事件管理	409
15.3.1　分类管理与评价体系	409
15.3.2　任务分发、协同与时效	411
15.3.3　内部上报要求	412
15.3.4　重大事件处理	413
15.4　人员管理：开放与分享	415
15.4.1　企业社交管理	415
15.4.2　目标管理，做好绩效	417
15.4.3　知识管理，人员成长	417
15.4.4　时间管理，个人效率	420
15.5　PaaS下的运维发展之路	421
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>PaaS实现与运维管理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker进阶与实战
序
前　言
第1章　Docker简介    1
1.1　引言    1
1.1.1　Docker的历史和发展    1
1.1.2　Docker的架构介绍    2
1.2　功能和组件    3
1.2.1　Docker客户端    3
1.2.2　Docker daemon    3
1.2.3　Docker容器    3
1.2.4　Docker镜像    4
1.2.5　Registry    4
1.3　安装和使用    5
1.3.1　Docker的安装    5
1.3.2　Docker的使用    6
1.4　概念澄清    8
1.4.1　Docker在LXC基础上做了什么工作    8
1.4.2　Docker容器和虚拟机之间有什么不同    9
1.5　本章小结    10
第2章　关于容器技术    11
2.1　容器技术的前世今生    11
2.1.1　关于容器技术    11
2.1.2　容器技术的历史    12
2.2　一分钟理解容器    14
2.2.1　容器的组成    14
2.2.2　容器的创建原理    15
2.3　Cgroup介绍    16
2.3.1　Cgroup是什么    16
2.3.2　Cgroup的接口和使用    17
2.3.3　Cgroup子系统介绍    18
2.4　Namespace介绍    20
2.4.1　Namespace是什么    20
2.4.2　Namespace的接口和使用    21
2.4.3　各个Namespace介绍    22
2.5　容器造就Docker    26
2.6　本章小结    27
第3章　理解Docker镜像    28
3.1　Docker image概念介绍    28
3.2　使用Docker image    29
3.2.1　列出本机的镜像    29
3.2.2　Build：创建一个镜像    31
3.2.3　Ship：传输一个镜像    32
3.2.4　Run：以image为模板启动一个容器    32
3.3　Docker image的组织结构    33
3.3.1　数据的内容    33
3.3.2　数据的组织    35
3.4　Docker image扩展知识    37
3.4.1　联合挂载    37
3.4.2　写时复制    37
3.4.3　Git式管理    40
3.5　本章小结    40
第4章　仓库进阶    41
4.1　什么是仓库    41
4.1.1　仓库的组成    41
4.1.2　仓库镜像    42
4.2　再看Docker Hub    43
4.2.1　Docker Hub的优点    43
4.2.2　网页分布    44
4.2.3　账户管理系统    46
4.3　仓库服务    49
4.3.1　Registry功能和架构    49
4.3.2　Registry API    50
4.3.3　Registry API传输过程分析    53
4.3.4　鉴权机制    57
4.4　部署私有仓库    61
4.4.1　运行私有服务    61
4.4.2　构建反向代理    61
4.5　Index及仓库高级功能    64
4.5.1　Index的作用和组成    64
4.5.2　控制单元    65
4.5.3　鉴权模块    66
4.5.4　数据库    67
4.5.5　高级功能    68
4.5.6　Index客户端界面    69
4.6　本章小结    69
第5章　Docker网络    71
5.1　Docker网络现状    71
5.2　基本网络配置    73
5.2.1　Docker网络初探    73
5.2.2　Docker网络相关参数    80
5.3　高级网络配置    85
5.3.1　容器跨主机多子网方案    85
5.3.2　容器跨主机多子网配置方法    86
5.4　网络解决方案进阶    90
5.4.1　Weave    90
5.4.2　Flannel    91
5.4.3　SocketPlane    94
5.5　本章小结    98
第6章　容器卷管理    99
6.1　Docker卷管理基础    99
6.1.1　增加新数据卷    99
6.1.2　将主机目录挂载为数据卷    100
6.1.3　创建数据卷容器    100
6.1.4　数据卷的备份、转储和迁移    101
6.1.5　Docker卷管理的问题    101
6.2　使用卷插件    102
6.2.1　卷插件简介    102
6.2.2　卷插件的使用    102
6.3　卷插件剖析    103
6.3.1　卷插件工作原理    104
6.3.2　卷插件API接口    105
6.3.3　插件发现机制    105
6.4　已有的卷插件    106
6.5　本章小结    107
第7章　Docker API    108
7.1　关于 Docker API    108
7.1.1　REST 简介    108
7.1.2　Docker API 初探    109
7.1.3　Docker API 种类    110
7.2　RESTful API应用示例    110
7.2.1　前期准备    111
7.2.2　Docker API的基本示例    116
7.3　API的高级应用    123
7.3.1　场景概述    123
7.3.2　场景实现    124
7.4　本章小结    131
第8章　Docker安全    132
8.1　深入理解Docker的安全    132
8.1.1　Docker的安全性    132
8.1.2　Docker容器的安全性    132
8.2　安全策略    133
8.2.1　Cgroup    133
8.2.2　ulimit    135
8.2.3　容器组网    135
8.2.4　容器+全虚拟化    136
8.2.5　镜像签名    136
8.2.6　日志审计    136
8.2.7　监控    137
8.2.8　文件系统级防护    137
8.2.9　capability    137
8.2.10　SELinux    138
8.2.11　AppArmor    142
8.2.12　Seccomp    144
8.2.13　grsecurity    145
8.2.14　几个与Docker安全相关的项目    146
8.3　安全加固    146
8.3.1　主机逃逸    147
8.3.2　安全加固之capability    150
8.3.3　安全加固之SELinux    151
8.3.4　安全加固之AppArmor    152
8.4　Docker安全遗留问题    153
8.4.1　User Namespace    153
8.4.2　非root运行Docker daemon    153
8.4.3　Docker热升级    153
8.4.4　磁盘限额    154
8.4.5　网络I/O    154
8.5　本章小结    154
第9章　Libcontainer简介    155
9.1　引擎的引擎    155
9.1.1　关于容器的引擎    155
9.1.2　对引擎的理解    156
9.2　Libcontainer的技术原理    157
9.2.1　为容器创建新的命名空间    158
9.2.2　为容器创建新的Cgroup    159
9.2.3　创建一个新的容器    160
9.2.4　Libcontainer的功能    164
9.3　关于runC    166
9.3.1　runC和Libcontainer的关系    166
9.3.2　runC的工作原理    167
9.3.3　runC的未来    168
9.4　本章小结    169
第10章　Docker实战    170
10.1　Dockerfile简介    170
10.1.1　一个简单的例子    171
10.1.2　Dockerfile指令    171
10.1.3　再谈Docker镜像制作    173
10.2　基于Docker的Web应用和发布    174
10.2.1　选择基础镜像    174
10.2.2　制作HTTPS服务器镜像    175
10.2.3　将Web源码导入Tomcat镜像中    178
10.2.4　部署与验证    179
10.3　为Web站点添加后台服务    180
10.3.1　代码组织结构    180
10.3.2　组件镜像制作过程    183
10.3.3　整体部署服务    183
10.4　本章小结    184
第11章　Docker集群管理    185
11.1　Compose    185
11.1.1　Compose概述    185
11.1.2　Compose配置简介    186
11.2　Machine    187
11.2.1　Machine概述    187
11.2.2　Machine的基本概念及运行流程    188
11.3　Swarm    188
11.3.1　Swarm概述    188
11.3.2　Swarm内部架构    189
11. 4　Docker在OpenStack上的集群实战    190
11.5　本章小结    196
第12章　Docker生态圈    197
12.1　Docker生态圈介绍    197
12.2　重点项目介绍    198
12.2.1　编排    198
12.2.2　容器操作系统    203
12.2.3　PaaS平台    206
12.3　生态圈的未来发展    208
12.3.1　Docker公司的发展和完善方向    208
12.3.2　OCI组织    209
12.3.3　生态圈格局的分化和发展    210
12.4　本章小章    211
第13章　Docker测试    212
13.1　Docker自身测试    212
13.1.1　Docker自身的测试框架    212
13.1.2　运行Docker测试    213
13.1.3　在容器中手动运行测试用例    215
13.1.4　运行集成测试中单个或多个测试用例    215
13.1.5　Docker测试用例集介绍    216
13.1.6　Docker测试需要改进的方面    217
13.1.7　构建和测试文档    217
13.1.8　其他Docker测试套    218
13.2　Docker技术在测试中的应用    220
13.2.1　Docker对测试的革命性影响    221
13.2.2　Docker技术适用范围    222
13.2.3　Jenkins+Docker自动化环境配置    223
13.3　本章小结    229
第14章　参与Docker开发    230
14.1　改进Docker    230
14.1.1　报告问题    230
14.1.2　提交补丁    231
14.2　编译自己的Docker    235
14.2.1　使用make工具编译    235
14.2.2　手动启动容器编译    235
14.2.3　编译动态链接的可执行文件    237
14.2.4　跑测试用例及小结    237
14.3　开源的沟通和交流    238
14.3.1　Docker沟通和交流的途径    238
14.3.2　开源沟通和交流的建议    238
14.4　Docker项目的组织架构    239
14.4.1　管理模型    239
14.4.2　组织架构    240
14.5　本章小章    242
附录A　FAQ    243
附录B　常用Dockerfile    247
附录C　Docker信息获取渠道    250
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker进阶与实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker源码分析
目录
赞誉
序
前言
第1章　Docker架构	1
1.1　引言	1
1.2　Docker总架构图	2
1.3　Docker各模块功能与实现分析	3
1.3.1　Docker Client	4
1.3.2　Docker Daemon	4
1.3.3　Docker Registry	6
1.3.4　Graph	7
1.3.5　Driver	7
1.3.6　libcontainer	10
1.3.7　Docker Container	10
1.4　Docker运行案例分析	11
1.4.1　docker pull	11
1.4.2　docker run	12
1.5　总结	14
第2章　Docker Client创建与命令执行	15
2.1　引言	15
2.2　创建Docker Client	16
2.2.1　Docker命令的flag参数解析	17
2.2.2　处理flag信息并收集Docker Client的配置信息	20
2.2.3　如何创建Docker Client	22
2.3　Docker命令执行	24
2.3.1　Docker Client解析请求命令	24
2.3.2　Docker Client执行请求命令	25
2.4　总结	27
第3章　启动Docker Daemon	28
3.1　引言	28
3.2　Docker Daemon的启动流程	29
3.3　mainDaemon()的具体实现	30
3.3.1　配置初始化	30
3.3.2　flag参数检查	32
3.3.3　创建engine对象	33
3.3.4　设置engine的信号捕获	34
3.3.5　加载builtins	35
3.3.6　使用goroutine加载daemon
对象并运行	38
3.3.7　打印Docker版本及驱动信息	41
3.3.8　serveapi的创建与运行	42
3.4　总结	42
第4章　Docker Daemon之NewDaemon实现	43
4.1　引言	43
4.2　NewDaemon具体实现	44
4.3　应用配置信息	45
4.3.1　配置Docker容器的MTU	45
4.3.2　检测网桥配置信息	46
4.3.3　查验容器间的通信配置	46
4.3.4　处理网络功能配置	47
4.3.5　处理PID文件配置	47
4.4　检测系统支持及用户权限	48
4.5　配置工作路径	49
4.6　加载并配置graphdriver	49
4.6.1　创建graphdriver	49
4.6.2　验证btrfs与SELinux的兼容性	51
4.6.3　创建容器仓库目录	51
4.6.4　迁移容器至aufs类型	51
4.6.5　创建镜像graph	52
4.6.6　创建volumesdriver以及volumes graph	53
4.6.7　创建TagStore	53
4.7　配置Docker Daemon网络环境	54
4.7.1　创建Docker网络设备	55
4.7.2　启用iptables功能	55
4.7.3　启用系统数据包转发功能	56
4.7.4　创建DOCKER链	56
4.7.5　注册处理方法至Engine	57
4.8　创建graphdb并初始化	57
4.9　创建execdriver	58
4.10　创建daemon实例	59
4.11　检测DNS配置	60
4.12　启动时加载已有Docker容器	61
4.13　设置shutdown的处理方法	61
4.14　返回daemon对象实例	62
4.15　总结	62
第5章　Docker Server的创建	63
5.1　引言	63
5.2　Docker Server创建流程	63
5.2.1　创建名为“serveapi”的Job	64
5.2.2　配置Job环境变量	64
5.2.3　运行Job	65
5.3　ServeApi运行流程	65
5.4　ListenAndServe实现	68
5.4.1　创建router路由实例	69
5.4.2　创建listener监听实例	74
5.4.3　创建http.Server	74
5.4.4　启动API服务	75
5.5　总结	75
第6章　Docker Daemon网络	76
6.1　引言	76
6.2　Docker Daemon网络介绍	77
6.3　Docker Daemon网络配置接口	78
6.4　Docker Daemon网络初始化	79
6.4.1　启动Docker Daemon传递flag参数	80
6.4.2　解析网络flag参数	80
6.4.3　预处理flag参数	80
6.4.4　确定Docker网络模式	81
6.5　创建Docker网桥	82
6.5.1　提取环境变量	83
6.5.2　确定Docker网桥设备名	83
6.5.3　查找bridgeIface网桥设备	83
6.5.4　bridgeIface已创建	84
6.5.5　bridgeIface未创建	85
6.5.6　获取网桥设备的网络地址	88
6.5.7　配置Docker Daemon的iptables	88
6.5.8　配置网络设备间数据报转发功能	88
6.5.9　注册网络Handler	89
6.6　总结	89
第7章　Docker容器网络	90
7.1　引言	90
7.2　Docker容器网络模式	93
7.2.1　bridge桥接模式	93
7.2.2　host模式	95
7.2.3　other container模式	96
7.2.4　none模式	97
7.3　Docker Client配置容器网络模式	97
7.3.1　使用Docker Client	98
7.3.2　runconfig包解析	98
7.3.3　CmdRun执行	102
7.4　Docker Daemon创建容器网络流程	103
7.4.1　创建容器之网络配置	103
7.4.2　启动容器之网络配置	105
7.5　execdriver网络执行流程	111
7.5.1　创建libcontainer的Config对象	112
7.5.2　调用libcontainer的namespaces启动容器	116
7.6　libcontainer实现内核态网络配置	117
7.6.1　创建exec.Cmd	118
7.6.2　启动exec.Cmd创建进程	119
7.6.3　为容器进程初始化网络环境	120
7.7　总结	122
第8章　Docker镜像	123
8.1　引言	123
8.2　Docker镜像介绍	124
8.3　rootfs	124
8.4　Union Mount	125
8.5　image	127
8.6　layer	128
8.7　总结	129
第9章　Docker镜像下载	130
9.1　引言	130
9.2　Docker镜像下载流程	131
9.3　Docker Client	131
9.3.1　解析镜像参数	132
9.3.2　配置认证信息	136
9.3.3　发送API请求	137
9.4　Docker Server	138
9.4.1　解析请求参数	138
9.4.2　创建并配置Job	139
9.4.3　触发执行Job	139
9.5　Docker Daemon	140
9.5.1　解析Job参数	140
9.5.2　创建session对象	141
9.5.3　执行镜像下载	142
9.6　总结	147
第10章　Docker镜像存储	149
10.1　引言	149
10.2　镜像注册	150
10.3　验证镜像ID	151
10.4　创建镜像路径	152
10.4.1　创建mnt、diff和layers子目录	153
10.4.2　挂载祖先镜像并返回根目录	155
10.5　存储镜像内容	157
10.5.1　解压镜像内容	158
10.5.2　收集镜像大小并记录	160
10.5.3　存储jsonData信息	161
10.6　注册镜像ID	162
10.7　总结	163
第11章　docker build实现	164
11.1　引言	164
11.2　docker build执行流程	165
11.2.1　Docker Client与docker build	166
11.2.2　Docker Server与docker build	170
11.2.3　Docker Daemon与docker build	171
11.3　Dockerfile命令解析流程	174
11.4　Dockerfile命令分析	177
11.4.1　FROM命令	177
11.4.2　RUN命令	178
11.4.3　ENV命令	182
11.5　总结	182
第12章　Docker容器创建	183
12.1　引言	183
12.2　Docker容器运行流程	184
12.3　Docker Daemon创建容器对象	185
12.3.1　LookupImage	186
12.3.2　CheckDepth	188
12.3.3　mergeAndVerifyConfig	188
12.3.4　newContainer	189
12.3.5　createRootfs	190
12.3.6　ToDisk	190
12.3.7　Register	191
12.4　Docker Daemon启动容器	191
12.4.1　setupContainerDns	192
12.4.2　Mount	193
12.4.3　initializeNetworking	194
12.4.4　verifyDaemonSetting	194
12.4.5　prepareVolumesForContainer	195
12.4.6　setupLinkedContainers	196
12.4.7　setupWorkingDirectory	199
12.4.8　createDaemonEnvironment	199
12.4.9　populateCommand	200
12.4.10　setupMountsForContainer	200
12.4.11　waitForStart	201
12.5　总结	202
第13章　dockerinit启动	203
13.1　引言	203
13.2　dockerinit介绍	204
13.2.1　dockerinit初始化内容	204
13.2.2　dockerinit与Docker Daemon	204
13.3　dockerinit执行入口	205
13.3.1　createCommand分析	205
13.3.2　namespace.exec	207
13.4　dockerinit运行	208
13.4.1　reexec.Init()的分析	208
13.4.2　dockerinit的执行流程	210
13.5　libcontainer的运行	211
13.5.1　Docker Daemon设置cgroups参数	213
13.5.2　Docker Daemon创建网络栈资源	213
13.5.3　dockerinit配置网络栈	213
13.5.4　dockerinit初始化mount namespace	215
13.5.5　dockerinit完成namespace配置	215
13.5.6　dockerinit执行用户命令Entrypoint	217
13.6　总结	218
第14章　libcontainer介绍	219
14.1　引言	219
14.2　Docker、libcontainer以及LXC的关系	220
14.3　libcontainer模块分析	221
14.3.1　namespace	221
14.3.2　cgroup	224
14.3.3　网络	225
14.3.4　挂载	226
14.3.5　设备	227
14.3.6　nsinit	227
14.3.7　其他模块	227
14.4　总结	228
第15章　Swarm架构设计与实现	229
15.1　引言	229
15.2　Swarm架构	230
15.2.1　Swarm Node	231
15.2.2　Docker Node	231
15.2.3　node discovery	231
15.2.4　scheduler	232
15.3　Swarm命令	232
15.3.1　swarm create	232
15.3.2　swarm manage	232
15.3.3　swarm join	233
15.3.4　swarm list	234
15.4　总结	234
第16章　Machine架构设计与实现	235
16.1　引言	235
16.2　Machine架构	236
16.2.1　Machine	237
16.2.2　Store	237
16.2.3　Host	237
16.2.4　Driver	238
16.2.5　Provisioner	238
16.2.6　Machine运行流程	239
16.3　Machine与Swarm的结合	240
16.4　总结	241
第17章　Compose架构设计与实现	242
17.1　引言	242
17.2　Compose介绍	242
17.3　Compose架构	243
17.4　Compose评价	246
17.4.1　Compose单机能力	246
17.4.2　Compose跨节点能力	247
17.4.3　Compose与Swarm	247
17.5　总结	247
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker源码分析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入浅出Docker
第一部分　Docker概览
第1章　容器发展之路 2
1.1　落后的旧时代 2
1.2　你好，VMware！ 2
1.3　虚拟机的不足 3
1.4　你好，容器！ 3
1.5　Linux容器 3
1.6　你好，Docker！ 4
1.7　Windows容器 4
1.8　Windows容器vs Linux容器 4
1.9　Mac容器现状 5
1.10　Kubernetes 5
1.11　本章小结 6
第2章　走进Docker 7
2.1　Docker—简介 7
2.2　Docker公司 7
2.3　Docker运行时与编排引擎 8
2.4　Docker开源项目（Moby） 9
2.5　容器生态 10
2.6　开放容器计划 11
2.7　本章小结 12
第3章　Docker安装 13
3.1　Windows版Docker（DfW） 13
3.2　Mac版Docker（DfM） 17
3.3　在Linux上安装Docker 19
3.4　在Windows Server 2016上安装Docker 21
3.5　Docker引擎（Engine）升级 22
3.5.1　在Ubuntu 16.04上升级Docker CE 23
3.5.2　在Windows Server 2016上升级Docker EE 24
3.6　Docker存储驱动的选择 25
3.6.1　Device Mapper配置 26
3.6.2　让Docker自动设置direct-lvm 26
3.6.3　手动配置Device Mapper的direct-lvm 28
3.7　本章小结 28
第4章　纵观Docker 29
4.1　运维视角 29
4.1.1　镜像 30
4.1.2　容器 31
4.1.3　连接到运行中的容器 34
4.2　开发视角 35
4.3　本章小结 38
第二部分　Docker技术
第5章　Docker引擎 40
5.1　Docker引擎—简介 40
5.2　Docker引擎—详解 41
5.2.1　摆脱LXC 41
5.2.2　摒弃大而全的Docker daemon 42
5.2.3　开放容器计划（OCI）的影响 43
5.2.4　runc 43
5.2.5　containerd 43
5.2.6　启动一个新的容器（示例） 44
5.2.7　该模型的显著优势 45
5.2.8　shim 45
5.2.9　在Linux中的实现 46
5.2.10　daemon的作用 46
5.3　本章小结 46
第6章　Docker镜像 48
6.1　Docker镜像—简介 48
6.2　Docker镜像—详解 48
6.2.1　镜像和容器 49
6.2.2　镜像通常比较小 49
6.2.3　拉取镜像 49
6.2.4　镜像命名 51
6.2.5　镜像仓库服务 51
6.2.6　镜像命名和标签 52
6.2.7　为镜像打多个标签 54
6.2.8　过滤docker image ls的输出内容 55
6.2.9　通过CLI方式搜索Docker Hub 56
6.2.10　镜像和分层 57
6.2.11　共享镜像层 60
6.2.12　根据摘要拉取镜像 61
6.2.13　镜像散列值（摘要） 63
6.2.14　多层架构的镜像 63
6.2.15　删除镜像 65
6.3　镜像—命令 67
6.4　本章小结 67
第7章　Docker容器 68
7.1　Docker容器—简介 68
7.2　Docker容器—详解 69
7.2.1　容器vs虚拟机 69
7.2.2　虚拟机的额外开销 71
7.2.3　运行的容器 71
7.2.4　检查Docker daemon 71
7.2.5　启动一个简单容器 72
7.2.6　容器进程 74
7.2.7　容器生命周期 75
7.2.8　优雅地停止容器 78
7.2.9　利用重启策略进行容器的自我修复 78
7.2.10　Web服务器示例 80
7.2.11　查看容器详情 82
7.2.12　快速清理 82
7.3　容器—命令 83
7.4　本章小结 84
第8章　应用的容器化 85
8.1　应用的容器化—简介 85
8.2　应用的容器化—详解 86
8.2.1　单体应用容器化 86
8.2.2　生产环境中的多阶段构建 95
8.2.3　最佳实践 98
8.3　应用的容器化—命令 100
8.4　本章小结 101
第9章　使用Docker Compose部署应用 102
9.1　使用Docker Compose部署应用—简介 102
9.2　使用Docker Compose部署应用—详解 103
9.2.1　Docker Compose的背景 103
9.2.2　安装Docker Compose 103
9.2.3　Compose文件 105
9.2.4　使用Docker Compose部署应用 107
9.2.5　使用Docker Compose管理应用 110
9.3　使用Docker Compose部署应用—命令 115
9.4　本章小结 116
第10章　Docker Swarm 117
10.1　Docker Swarm—简介 117
10.2　Docker Swarm—详解 118
10.2.1　Swarm的初步介绍 118
10.2.2　搭建安全Swarm集群 119
10.2.3　Swarm服务 125
10.2.4　故障排除 133
10.3　Docker Swarm—命令 134
10.4　本章小结 135
第11章　Docker网络 136
11.1　Docker网络—简介 136
11.2　Docker网络—详解 137
11.2.1　基础理论 137
11.2.2　单机桥接网络 140
11.2.3　多机覆盖网络 146
11.2.4　接入现有网络 146
11.2.5　服务发现 152
11.2.6　Ingress网络 153
11.3　Docker网络—命令 156
11.4　本章小结 156
第12章　Docker覆盖网络 157
12.1　Docker覆盖网络—简介 157
12.2　Docker覆盖网络—详解 157
12.2.1　在Swarm模式下构建并测试Docker覆盖网络 158
12.2.2　工作原理 164
12.3　Docker覆盖网络—命令 168
12.4　本章小结 168
第13章　卷与持久化数据 169
13.1　卷与持久化数据—简介 169
13.2　卷与持久化数据—详解 169
13.2.1　容器与非持久数据 170
13.2.2　容器与持久化数据 170
13.2.3　在集群节点间共享存储 175
13.3　卷与持久化数据—命令 176
13.4　本章小结 176
第14章　使用Docker Stack部署应用 177
14.1　使用Docker Stack部署应用—简介 177
14.2　使用Docker Stack部署应用—详解 178
14.2.1　简单应用 178
14.2.2　深入分析Stack文件 180
14.2.3　部署应用 186
14.2.4　管理应用 191
14.3　使用Docker Stack部署应用—命令 193
14.4　本章小结 194
第15章　Docker安全 195
15.1　Docker安全—简介 195
15.2　Docker安全—详解 196
15.2.1　Linux安全技术 197
15.2.2　Docker平台安全技术 201
15.3　本章小结 212
第16章　企业版工具 213
16.1　企业版工具—简介 213
16.2　企业版工具—详解 214
16.2.1　Docker EE引擎 214
16.2.2　Docker通用控制平面（UCP） 216
16.2.3　Docker可信镜像仓库服务（DTR） 227
16.3　本章小结 233
第17章　企业级特性 234
17.1　企业级特性—简介 234
17.2　企业级特性—详解 234
17.2.1　基于角色的权限控制（RBAC） 235
17.2.2　集成活动目录 239
17.2.3　Docker内容信任机制（DCT） 241
17.2.4　配置Docker可信镜像仓库服务（DTR） 243
17.2.5　使用Docker可信镜像仓库服务 244
17.2.6　提升镜像 247
17.2.7　HTTP路由网格（HRM） 250
17.3　本章小结 253
附录A　安全客户端与daemon的通信 255
附录B　DCA考试 265
附录C　延伸 270
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入浅出Docker
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker开发实践
第一篇　基础篇：Docker基础
第1章　Docker简介　　2
1.1　Docker简介　　2
1.1.1　Docker的概念　　5
1.1.2　Docker的背景　　5
1.1.3　容器与虚拟机　　7
1.1.4　Docker与容器　　8
1.1.5　Docker的应用场景　　9
1.2　Docker的组件　　10
1.3　Docker的相关技术　　11
1.4　Docker的安装　　12
1.4.1　Ubuntu下的安装　　12
1.4.2　Red Hat下的安装　　13
1.4.3　OS X下的安装　　14
1.4.4　Windows下的安装　　15
第2章　容器　　17
2.1　容器的管理操作　　17
2.1.1　创建容器　　17
2.1.2　查看容器　　20
2.1.3　启动容器　　21
2.1.4　终止容器　　22
2.1.5　删除容器　　22
2.2　容器内信息获取和命令执行　　23
2.2.1　依附容器　　23
2.2.2　查看容器日志　　24
2.2.3　查看容器进程　　25
2.2.4　查看容器信息　　25
2.2.5　容器内执行命令　　26
2.3　容器的导入和导出　　26
第3章　镜像　　28
3.1　镜像的概念　　28
3.1.1　镜像与容器　　28
3.1.2　镜像的系统结构　　29
3.1.3 镜像的写时复制机制　　30
3.2　本地镜像的管理　　30
3.2.1 查看　　30
3.2.2　下载　　31
3.2.3　删除　　33
3.3　创建本地镜像　　33
3.3.1　使用commit命令创建本地镜像　　33
3.3.2　使用Dockerfile创建镜像　　34
3.4　Docker Hub　　40
3.4.1　Docker Hub简介　　41
3.4.2　镜像的分发　　41
3.4.3　自动化构建　　43
3.4.4　创建注册服务器　　47
第4章　数据卷及容器连接　　49
4.1　容器网络基础　　49
4.1.1　暴露网络端口　　50
4.1.2　查看网络配置　　53
4.2　数据卷　　54
4.2.1　创建数据卷　　54
4.2.2　挂载主机目录作为数据卷　　55
4.2.3　挂载主机文件作为数据卷　　57
4.2.4　数据卷容器　　57
4.2.5　数据的备份与恢复　　59
4.3　容器连接　　60
4.3.1　容器命名　　60
4.3.2　容器连接　　60
4.3.3　代理连接　　62
第二篇　案例篇：综合案例
第5章　创建SSH服务镜像　　66
5.1　基于commit命令的方式　　66
5.2　基于Dockerfile的方式　　70
第6章　综合案例1：Apache+PHP+MySQL　　72
6.1　构建mysql 镜像　　72
6.1.1　编写镜像Dockerfile　　73
6.1.2　构建和上传镜像　　75
6.2　构建apache+php镜像　　76
6.2.1　编写镜像Dockerfile　　77
6.2.2　构建和上传镜像　　79
6.3　启动容器　　80
第7章　综合案例2：DLNNM　　82
7.1　构建mongodb镜像　　83
7.1.1　编写镜像Dockerfile　　84
7.1.2　构建和上传镜像　　84
7.2　构建Node.js镜像　　86
7.2.1　项目源文件　　86
7.2.2　编写镜像Dockerfile　　88
7.2.3　构建和上传镜像　　89
7.3　连接Node.js服务和MongoDB服务　　89
7.3.1　制作代理镜像mongoabassador　　89
7.3.2　启动MongoDB服务　　91
7.3.3　启动Node-Web-API服务　　92
7.4　搭建前端Nginx　　93
7.4.1　构建镜像并运行　　93
7.4.2　验证Web应用　　95
第8章　阿里云Docker开发实践　　97
8.1　阿里云Docker介绍　　99
8.2　部署镜像注册服务器　　102
8.3　开发　　103
8.3.1　项目开发　　103
8.3.2　制作和上传镜像　　104
8.4　测试　　105
8.5　部署　　105
第9章　在阿里云上部署WordPress　　107
9.1　初始化阿里云Docker环境　　107
9.2　部署MySQL容器　　109
9.3　部署WordPress容器　　109
第10章　使用私有仓库　　112
10.1　使用docker-registry　　112
10.2　用户认证　　115
第11章　使用Docker部署Hadoop集群　　118
11.1　Hadoop简介　　118
11.2　构建Hadoop镜像　　119
11.3　构建Hadoop集群　　122
11.3.1　Ambari简介　　123
11.3.2　部署Hadoop集群　　123
第三篇　高级篇：高级话题、API、工具及集群管理
第12章　容器网络　　128
12.1　容器网络的原理　　128
12.1.1　基础网络工具　　128
12.1.2　网络空间虚拟化　　131
12.1.3　网络设备虚拟化　　132
12.1.4　容器运行的4 种网络模式　　 135
12.1.5　手动配置容器的网络环境　　 137
12.2　配置及原理　　138
12.2.1　基本配置　　138
12.2.2　容器互联配置及原理　　140
12.2.3　容器内访配置及原理　　142
12.2.4　容器外访配置及原理　　143
12.2.5　创建点对点连接　　144
12.3　网桥　　146
12.3.1　配置网桥　　146
12.3.2　构建自己的网桥　　146
第13章　安全　　148
13.1　命名空间　　148
13.2　cgroups　　151
13.3　Linux能力机制　　152
第14章　DockerAPI　　154
14.1　API 概述　　154
14.2　绑定Docker后台监听接口　　155
14.3　远程API　　158
14.3.1　容器相关的API　　158
14.3.2　镜像相关的API　　164
14.4　平台API　　167
14.4.1　注册服务器架构及流程　　167
14.4.2　操作Hub API　　169
14.5　API 实战：docker-py库编程　　173
14.5.1　docker-py开发环境的搭建　　173
14.5.2　docker-py库编程　　174
第15章　Fig　　177
15.1　Fig简介　　177
15.2　Fig安装　　177
15.3　Rails开发环境配置　　178
15.4　Django开发环境配置　　180
15.5　WordPress开发环境配置　　182
15.6　Flocker：跨主机的Fig应用　　184
第16章　Kubernetes　　189
16.1　Kubernetes简介　　189
16.2　核心概念　　190
16.2.1　节点　　190
16.2.2　Pod　　190
16.2.3　服务　　191
16.2.4　标签　　194
16.3　架构和组件　　195
16.3.1　主控节点　　195
16.3.2　从属节点　　198
16.3.3　组件交互流程　　198
16.4　Kubernetes实战　　200
16.4.1　环境部署　　201
16.4.2　应用操作　　207
第17章　shipyard　　214
17.1　简介　　214
17.2　shipyard操作　　217
17.2.1　鉴权　　217
17.2.2　引擎　　217
17.2.3　容器　　220
17.2.4　服务密钥　　222
17.2.5　Web钩子密钥　　223
17.2.6　事件　　223
17.2.7　集群信息　　224
第18章　Machine+Swarm+Compose225
18.1　Machine　　225
18.2　Swarm　　227
18.2.1　架构和组件　　228
18.2.2　实操　　230
18.2.3　发现服务和调度　　233
18.3　Compose　　239
第四篇　附录
附录A　常见镜像　　242
附录B　Docker API列表　　262
附录C　参考资料　　278
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker开发实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud与Docker微服务架构实战（第2版）
1 微服务架构概述  1
1.1 单体应用架构存在的问题  . 1
1.2 如何解决单体应用架构存在的问题  3
1.3 什么是微服务  . 3
1.4 微服务架构的优点与挑战  . 4
1.4.1 微服务架构的优点  5
1.4.2 微服务架构面临的挑战  5
1.5 微服务设计原则  6
1.6 如何实现微服务架构  7
1.6.1 技术选型  7
1.6.2 架构图及常用组件  8
2 微服务开发框架——Spring Cloud  . 9
2.1 Spring Cloud 简介  . 9
2.2 Spring Cloud 特点  . 10
2.3 Spring Cloud 版本  . 10
2.3.1 版本简介  10
2.3.2 子项目一览  . 12
2.3.3 Spring Cloud/Spring Boot 版本兼容性  . 13
3 开始使用Spring Cloud 实战微服务  14
3.1 Spring Cloud 实战前提  14
3.1.1 技术储备  14
3.1.2 工具及软件版本  . 15
3.2 服务提供者与服务消费者  . 16
3.3 编写服务提供者  16
3.3.1 手动编写项目  . 17
3.3.2 使用Spring Initializr 快速创建Spring Boot 项目  . 21
3.4 编写服务消费者  23
3.5 为项目整合Spring Boot Actuator  . 25
3.6 硬编码有哪些问题  28
4 微服务注册与发现  30
4.1 服务发现简介  . 30
4.2 Eureka 简介  . 32
4.3 Eureka 原理  . 32
4.4 编写Eureka Server  34
4.5 将微服务注册到Eureka Server 上  36
4.6 Eureka Server 的高可用  38
4.6.1 编写高可用Eureka Server  38
4.6.2 将应用注册到Eureka Server 集群上  41
4.7 用户认证  . 41
4.7.1 为Eureka Server 添加用户认证  . 41
4.7.2 将微服务注册到需认证的Eureka Server  43
4.8 Eureka 的元数据  43
4.8.1 改造用户微服务  . 43
4.8.2 改造电影微服务  . 44
4.9 Eureka Server 的REST 端点  46
4.9.1 示例  47
4.9.2 注销微服务实例  . 52
4.10 Eureka 的自我保护模式  . 53
4.11 多网卡环境下的IP 选择  . 54
4.12 Eureka 的健康检查  56
4.13 排除Jersey 依赖  . 57
5 使用Ribbon 实现客户端侧负载均衡  . 59
5.1 Ribbon 简介  59
5.2 为服务消费者整合Ribbon  . 60
5.3 Ribbon 配置自定义  63
5.3.1 使用Java 代码自定义Ribbon 配置  63
5.3.2 使用属性自定义Ribbon 配置  67
5.4 脱离Eureka 使用Ribbon  68
5.5 饥饿加载  . 70
6 使用Feign 实现声明式REST 调用  . 72
6.1 Feign 简介  73
6.2 为服务消费者整合Feign  73
6.3 自定义Feign 配置  . 75
6.3.1 使用Java 代码自定义Feign 配置  . 75
6.3.2 使用属性自定义Feign 配置  79
6.4 手动创建Feign  80
6.4.1 修改用户微服务  . 80
6.4.2 修改电影微服务  . 84
6.5 Feign 对继承的支持  . 86
6.6 Feign 对压缩的支持  . 87
6.7 Feign 的日志  87
6.7.1 编码方式设置日志级别  88
6.7.2 使用属性配置日志级别  89
6.8 使用Feign 构造多参数请求  90
6.8.1 GET 请求多参数的URL  . 90
6.8.2 POST 请求包含多个参数  91
6.9 使用Feign 上传文件  92
7 使用Hystrix 实现微服务的容错处理  . 94
7.1 实现容错的手段  94
7.1.1 雪崩效应  95
7.1.2 如何容错  95
7.2 使用Hystrix 实现容错  . 97
7.2.1 Hystrix 简介  . 97
7.2.2 通用方式整合Hystrix  98
7.2.3 Hystrix 断路器的状态监控与深入理解  102
7.2.4 Hystrix 线程隔离策略与传播上下文  103
7.2.5 Feign 使用Hystrix  . 106
7.3 Hystrix 的监控  112
7.4 使用Hystrix Dashboard 可视化监控数据  . 113
7.5 使用Turbine 聚合监控数据  116
7.5.1 Turbine 简介  116
7.5.2 使用Turbine 监控多个微服务  117
7.5.3 使用消息中间件收集数据  119
8 使用Zuul 构建微服务网关  124
8.1 为什么要使用微服务网关  . 124
8.2 Zuul 简介  . 126
8.3 编写Zuul 微服务网关  . 126
8.4 管理端点  . 129
8.4.1 routes 端点  129
8.4.2 filters 端点  131
8.5 路由配置详解  . 132
8.6 Zuul 的安全与Header  . 136
8.6.1 敏感Header 的设置  . 136
8.6.2 忽略Header  . 136
8.7 使用Zuul 上传文件  . 137
8.8 Zuul 的过滤器  140
8.8.1 过滤器类型与请求生命周期  . 140
8.8.2 内置过滤器详解  . 141
8.8.3 编写Zuul 过滤器  144
8.8.4 禁用Zuul 过滤器  146
8.9 Zuul 的容错与回退  146
8.10 饥饿加载  . 149
8.11 Query String 编码  . 150
8.12 Hystrix 隔离策略与线程池  . 150
8.12.1 隔离策略  150
8.12.2 线程池配置  . 151
8.13 Zuul 的高可用  152
8.13.1 Zuul 客户端也注册到了Eureka Server 上  . 152
8.13.2 Zuul 客户端未注册到Eureka Server 上  152
8.14 使用Sidecar 整合非JVM 微服务  . 154
8.14.1 编写Node.js 微服务  . 154
8.14.2 编写Sidecar  . 155
8.14.3 Sidecar 的端点  . 157
8.14.4 Sidecar 与Node.js 微服务分离部署  . 158
8.14.5 Sidecar 原理分析  158
8.15 使用Zuul 聚合微服务  . 160
9 使用Spring Cloud Config 统一管理微服务配置  166
9.1 为什么要统一管理微服务配置  . 166
9.2 Spring Cloud Config 简介  167
9.3 编写Config Server  . 168
9.4 编写Config Client  . 171
9.5 Config Server 的Git 仓库配置详解  . 173
9.5.1 占位符支持  . 173
9.5.2 模式匹配  174
9.5.3 搜索目录  174
9.5.4 启动时加载配置文件  175
9.6 Config Server 的健康状况指示器  . 176
9.7 配置内容的加解密  177
9.7.1 安装JCE  177
9.7.2 Config Server 的加解密端点  177
9.7.3 对称加密  177
9.7.4 存储加密的内容  . 178
9.7.5 非对称加密  . 179
9.8 使用/refresh 端点手动刷新配置  180
9.9 使用Spring Cloud Bus 自动刷新配置  . 181
9.9.1 Spring Cloud Bus 简介  181
9.9.2 实现自动刷新  . 182
9.9.3 局部刷新  183
9.9.4 架构改进  184
9.9.5 跟踪总线事件  . 184
9.10 Spring Cloud Config 与Eureka 配合使用  186
9.11 Spring Cloud Config 的用户认证  . 187
9.12 Config Server 的高可用  188
9.12.1 Git 仓库的高可用  188
9.12.2 RabbitMQ 的高可用  . 189
9.12.3 Config Server 自身的高可用  189
10 使用Spring Cloud Sleuth 实现微服务跟踪  . 191
10.1 为什么要实现微服务跟踪  . 191
10.2 Spring Cloud Sleuth 简介  . 192
10.3 整合Spring Cloud Sleuth  . 194
10.4 Spring Cloud Sleuth 与ELK 配合使用  . 196
10.5 Spring Cloud Sleuth 与Zipkin 配合使用  . 200
10.5.1 Zipkin 简介  . 200
10.5.2 编写Zipkin Server  . 200
10.5.3 微服务整合Zipkin  . 202
10.5.4 Zipkin 与Eureka 配合使用  . 205
10.5.5 使用消息中间件收集数据  206
10.5.6 使用Elasticsearch 存储跟踪数据  209
10.5.7 依赖关系图  . 211
11 Spring Cloud 常见问题与总结  . 213
11.1 Eureka 常见问题  213
11.1.1 Eureka 注册服务慢  213
11.1.2 已停止的微服务节点注销慢或不注销  214
11.1.3 如何自定义微服务的Instance ID  . 215
11.1.4 Eureka 的UNKNOWN 问题总结与解决  217
11.2 整合Hystrix 后首次请求失败  218
11.2.1 原因分析  218
11.2.2 解决方案  218
11.3 Turbine 聚合的数据不完整  219
11.4 Spring Cloud 各组件超时  220
11.4.1 RestTemplate 的超时  . 221
11.4.2 Ribbon 的超时  . 221
11.4.3 Feign 的超时  221
11.4.4 Hystrix 的超时  222
11.4.5 Zuul 的超时  . 222
11.5 Spring Cloud 各组件重试  223
11.5.1 重试步骤  224
11.5.2 基于HTTP 响应码重试  224
11.5.3 关闭重试  224
11.5.4 注意点  224
11.6 Spring Cloud 各组件调优  225
11.6.1 Tomcat 参数  . 225
11.6.2 Hystrix 参数  . 225
11.6.3 Feign 参数  226
11.6.4 Zuul 参数  . 226
11.7 Spring Cloud 各组件配置属性  228
11.7.1 Spring Boot 的配置  228
11.7.2 Spring Cloud 的配置  . 228
11.7.3 原生配置  229
11.8 Spring Cloud 定位问题思路总结  . 229
12 Docker 入门  232
12.1 Docker 简介  232
12.2 版本与迭代计划  232
12.2.1 版本区别  233
12.2.2 迭代计划  233
12.3 Docker 的架构  234
12.4 安装Docker  236
12.4.1 CentOS 7 安装Docker  . 236
12.4.2 Ubuntu 安装Docker  . 239
12.4.3 Windows 安装Docker  244
12.4.4 Mac OS 安装Docker  . 245
12.5 配置镜像加速器  245
12.6 Docker 常用命令  246
12.6.1 Docker 镜像常用命令  246
12.6.2 Docker 容器常用命令  252
13 将微服务运行在Docker 上  260
13.1 使用Dockerfile 构建Docker 镜像  260
13.1.1 Dockerfile 常用指令  . 261
13.1.2 使用Dockerfile 构建镜像  266
13.2 使用Docker Registry 管理Docker 镜像  . 268
13.2.1 使用Docker Hub 管理镜像  . 268
13.2.2 使用私有仓库管理镜像  270
13.3 使用Maven 插件构建Docker 镜像  . 271
13.3.1 快速入门  272
13.3.2 插件读取Dockerfile 进行构建  273
13.3.3 将插件绑定在某个phase 执行  274
13.3.4 推送镜像  275
13.4 常见问题与总结  277
14 使用Docker Compose 编排微服务  . 278
14.1 Docker Compose 简介  . 278
14.2 安装Docker Compose  . 279
14.2.1 安装Compose  . 279
14.2.2 安装Compose 命令补全工具  . 279
14.3 Docker Compose 快速入门  . 280
14.3.1 基本步骤  280
14.3.2 入门示例  280
14.3.3 工程、服务、容器  281
14.4 docker-compose.yml 常用命令  . 281
14.5 docker-compose 常用命令  . 285
14.6 Docker Compose 网络设置  . 286
14.6.1 基本概念  286
14.6.2 更新容器  287
14.6.3 links  287
14.6.4 指定自定义网络  . 288
14.6.5 配置默认网络  . 289
14.6.6 使用已存在的网络  289
14.7 综合实战：使用Docker Comose 编排Spring Cloud 微服务  289
14.7.1 编排Spring Cloud 微服务  289
14.7.2 编排高可用的Eureka Server  293
14.7.3 编排高可用Spring Cloud 微服务集群及动态伸缩  . 295
14.8 常见问题与总结  297
后记  298
附录A：本书配套代码  . 299
附录B：Spring Cloud YES——快速开发脚手架  300
附录C：使用Docker 快速安装本书中的组件  301
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud与Docker微服务架构实战（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Kubernetes权威指南：从Docker到Kubernetes实践全接触（第4版）
第1章  Kubernetes入门	1
1.1  Kubernetes是什么	2
1.2  为什么要用Kubernetes	5
1.3  从一个简单的例子开始	6
1.3.1  环境准备	7
1.3.2  启动MySQL服务	7
1.3.3  启动Tomcat应用	10
1.3.4  通过浏览器访问网页	12
1.4  Kubernetes的基本概念和术语	13
1.4.1  Master	16
1.4.2  Node	16
1.4.3  Pod	19
1.4.4  Label	24
1.4.5  Replication Controller	28
1.4.6  Deployment	31
1.4.7  Horizontal Pod Autoscaler	34
1.4.8  StatefulSet	36
1.4.9  Service	37
1.4.10  Job	45
1.4.11  Volume	45
1.4.12  Persistent Volume	49
1.4.13  Namespace	51
1.4.14  Annotation	52
1.4.15  ConfigMap	53
1.4.16  小结	54
第2章  Kubernetes安装配置指南	55
2.1  系统要求	56
2.2  使用kubeadm工具快速安装Kubernetes集群	57
2.2.1  安装kubeadm和相关工具	57
2.2.2  kubeadm config	58
2.2.3  下载Kubernetes的相关镜像	59
2.2.4  运行kubeadm init命令安装Master	59
2.2.5  安装Node，加入集群	61
2.2.6  安装网络插件	62
2.2.7  验证Kubernetes集群是否安装完成	63
2.3  以二进制文件方式安装Kubernetes集群	64
2.3.1  Master上的etcd、kube-apiserver、kube-controller-manager、
kube-scheduler服务	66
2.3.2  Node上的kubelet、kube-proxy服务	71
2.4  Kubernetes集群的安全设置	73
2.4.1  基于CA签名的双向数字证书认证方式	73
2.4.2  基于HTTP Base或Token的简单认证方式	78
2.5  Kubernetes集群的网络配置	80
2.6  内网中的Kubernetes相关配置	80
2.6.1  Docker Private Registry（私有Docker镜像库）	80
2.6.2  kubelet配置	81
2.7  Kubernetes的版本升级	81
2.7.1  二进制升级	81
2.7.2  使用kubeadm进行集群升级	82
2.8  Kubernetes核心服务配置详解	84
2.8.1  公共配置参数	84
2.8.2  kube-apiserver启动参数	85
2.8.3  kube-controller-manager启动参数	97
2.8.4  kube-scheduler启动参数	107
2.8.5  kubelet启动参数	113
2.8.6  kube-proxy启动参数	128
2.9  CRI（容器运行时接口）详解	132
2.9.1  CRI概述	132
2.9.2  CRI的主要组件	133
2.9.3  Pod和容器的生命周期管理	133
2.9.4  面向容器级别的设计思路	135
2.9.5  尝试使用新的Docker-CRI来创建容器	136
2.9.6  CRI的进展	137
2.10  kubectl命令行工具用法详解	137
2.10.1  kubectl用法概述	137
2.10.2  kubectl子命令详解	139
2.10.3  kubectl参数列表	142
2.10.4  kubectl输出格式	143
2.10.5  kubectl操作示例	145
第3章  深入掌握Pod	149
3.1  Pod定义详解	150
3.2  Pod的基本用法	156
3.3  静态Pod	161
3.4  Pod容器共享Volume	162
3.5  Pod的配置管理	165
3.5.1  ConfigMap概述	165
3.5.2  创建ConfigMap资源对象	165
3.5.3  在Pod中使用ConfigMap	173
3.5.4  使用ConfigMap的限制条件	179
3.6  在容器内获取Pod信息（Downward API）	180
3.6.1  环境变量方式：将Pod信息注入为环境变量	180
3.6.2  环境变量方式：将容器资源信息注入为环境变量	182
3.6.3  Volume挂载方式	184
3.7  Pod生命周期和重启策略	186
3.8  Pod健康检查和服务可用性检查	187
3.9  玩转Pod调度	190
3.9.1  Deployment或RC：全自动调度	193
3.9.2  NodeSelector：定向调度	194
3.9.3  NodeAffinity：Node亲和性调度	197
3.9.4  PodAffinity：Pod亲和与互斥调度策略	198
3.9.5  Taints和Tolerations（污点和容忍）	202
3.9.6  Pod Priority Preemption：Pod优先级调度	206
3.9.7  DaemonSet：在每个Node上都调度一个Pod	209
3.9.8  Job：批处理调度	211
3.9.9  Cronjob：定时任务	215
3.9.10  自定义调度器	219
3.10  Init Container（初始化容器）	220
3.11  Pod的升级和回滚	224
3.11.1  Deployment的升级	225
3.11.2  Deployment的回滚	231
3.11.3  暂停和恢复Deployment的部署操作，以完成复杂的修改	234
3.11.4  使用kubectl rolling-update命令完成RC的滚动升级	236
3.11.5  其他管理对象的更新策略	239
3.12  Pod的扩缩容	240
3.12.1  手动扩缩容机制	240
3.12.2  自动扩缩容机制	241
3.13  使用StatefulSet搭建MongoDB集群	264
3.13.1  前提条件	264
3.13.2  创建StatefulSet	265
3.13.3  查看MongoDB集群的状态	269
3.13.4  StatefulSet的常见应用场景	271
第4章  深入掌握Service	276
4.1  Service定义详解	277
4.2  Service的基本用法	279
4.2.1  多端口Service	282
4.2.2  外部服务Service	283
4.3  Headless Service	284
4.3.1  自定义SeedProvider	285
4.3.2  通过Service动态查找Pod	286
4.3.3  Cassandra集群中新节点的自动添加	289
4.4  从集群外部访问Pod或Service	291
4.4.1  将容器应用的端口号映射到物理机	291
4.4.2  将Service的端口号映射到物理机	292
4.5  DNS服务搭建和配置指南	294
4.5.1  在创建DNS服务之前修改每个Node上kubelet的启动参数	296
4.5.2  创建CoreDNS应用	297
4.5.3  服务名的DNS解析	301
4.5.4  CoreDNS的配置说明	302
4.5.5  Pod级别的DNS配置说明	304
4.6  Ingress：HTTP 7层路由机制	306
4.6.1  创建Ingress Controller和默认的backend服务	307
4.6.2  定义Ingress策略	311
4.6.3  客户端访问http://mywebsite.com/demo	313
4.6.4  Ingress的策略配置技巧	316
4.6.5  Ingress的TLS安全设置	320
第5章  核心组件运行机制	326
5.1  Kubernetes API Server原理解析	327
5.1.1  Kubernetes API Server概述	327
5.1.2  API Server架构解析	330
5.1.3  独特的Kubernetes Proxy API接口	334
5.1.4  集群功能模块之间的通信	336
5.2  Controller Manager原理解析	337
5.2.1  Replication Controller	338
5.2.2  Node Controller	339
5.2.3  ResourceQuota Controller	341
5.2.4  Namespace Controller	343
5.2.5  Service Controller与Endpoints Controller	343
5.3  Scheduler原理解析	344
5.4  kubelet运行机制解析	348
5.4.1  节点管理	349
5.4.2  Pod管理	349
5.4.3  容器健康检查	351
5.4.4  cAdvisor资源监控	352
5.5  kube-proxy运行机制解析	354
第6章  深入分析集群安全机制	358
6.1  API Server认证管理	359
6.2  API Server授权管理	361
6.2.1  ABAC授权模式详解	362
6.2.2  Webhook授权模式详解	365
6.2.3  RBAC授权模式详解	368
6.3  Admission Control	384
6.4  Service Account	388
6.5  Secret私密凭据	393
6.6  Pod的安全策略配置	396
6.6.1  PodSecurityPolicy的工作机制	397
6.6.2  PodSecurityPolicy配置详解	399
6.6.3  Pod的安全设置详解	406
第7章  网络原理	410
7.1  Kubernetes网络模型	411
7.2  Docker网络基础	413
7.2.1  网络命名空间	413
7.2.2  Veth设备对	416
7.2.3  网桥	419
7.2.4  iptables和Netfilter	421
7.2.5  路由	424
7.3  Docker的网络实现	426
7.4  Kubernetes的网络实现	435
7.4.1  容器到容器的通信	435
7.4.2  Pod之间的通信	436
7.5  Pod和Service网络实战	439
7.6  CNI网络模型	454
7.6.1  CNM模型	454
7.6.2  CNI模型	455
7.6.3  在Kubernetes中使用网络插件	467
7.7  Kubernetes网络策略	467
7.7.1  网络策略配置说明	468
7.7.2  在Namespace级别设置默认的网络策略	470
7.7.3  NetworkPolicy的发展	472
7.8  开源的网络组件	472
7.8.1  Flannel	472
7.8.2  Open vSwitch	477
7.8.3  直接路由	483
7.8.4  Calico容器网络和网络策略实战	486
第8章  共享存储原理	508
8.1  共享存储机制概述	509
8.2  PV详解	510
8.2.1  PV的关键配置参数	511
8.2.2  PV生命周期的各个阶段	515
8.3  PVC详解	516
8.4  PV和PVC的生命周期	518
8.4.1  资源供应	518
8.4.2  资源绑定	519
8.4.3  资源使用	519
8.4.4  资源释放	519
8.4.5  资源回收	519
8.5  StorageClass详解	521
8.5.1  StorageClass的关键配置参数	521
8.5.2  设置默认的StorageClass	524
8.6  动态存储管理实战：GlusterFS	524
8.6.1  准备工作	525
8.6.2  创建GlusterFS管理服务容器集群	525
8.6.3  创建Heketi服务	528
8.6.4  为Heketi设置GlusterFS集群	530
8.6.5  定义StorageClass	533
8.6.6  定义PVC	534
8.6.7  Pod使用PVC的存储资源	536
8.7  CSI存储机制详解	537
8.7.1  CSI的设计背景	538
8.7.2  CSI存储插件的关键组件和部署架构	539
8.7.3  CSI存储插件的使用示例	540
8.7.4  CSI的发展	556
第9章  Kubernetes开发指南	560
9.1  REST简述	561
9.2  Kubernetes API详解	563
9.2.1  Kubernetes API概述	563
9.2.2  Kubernetes API版本的演进策略	570
9.2.3  API Groups（API组）	571
9.2.4  API REST的方法说明	573
9.2.5  API Server响应说明	575
9.3  使用Java程序访问Kubernetes API	577
9.3.1  Jersey	577
9.3.2  Fabric8	590
9.3.3  使用说明	591
9.3.4  其他客户端库	615
9.4  Kubernetes API的扩展	616
9.4.1  使用CRD扩展API资源	617
9.4.2  使用API聚合机制扩展API资源	626
第10章  Kubernetes集群管理	635
10.1  Node的管理	636
10.1.1  Node的隔离与恢复	636
10.1.2  Node的扩容	637
10.2  更新资源对象的Label	638
10.3  Namespace：集群环境共享与隔离	639
10.3.1  创建Namespace	639
10.3.2  定义Context（运行环境）	640
10.3.3  设置工作组在特定Context环境下工作	641
10.4  Kubernetes资源管理	643
10.4.1  计算资源管理	645
10.4.2  资源配置范围管理（LimitRange）	655
10.4.3  资源服务质量管理（Resource QoS）	662
10.4.4  资源配额管理（Resource Quotas）	670
10.4.5  ResourceQuota和LimitRange实践	676
10.4.6  资源管理总结	685
10.5  资源紧缺时的Pod驱逐机制	686
10.5.1  驱逐策略	686
10.5.2  驱逐信号	686
10.5.3  驱逐阈值	688
10.5.4  驱逐监控频率	689
10.5.5  节点的状况	689
10.5.6  节点状况的抖动	690
10.5.7  回收Node级别的资源	690
10.5.8  驱逐用户的Pod	691
10.5.9  资源最少回收量	692
10.5.10  节点资源紧缺情况下的系统行为	692
10.5.11  可调度的资源和驱逐策略实践	694
10.5.12  现阶段的问题	694
10.6  Pod Disruption Budget（主动驱逐保护）	695
10.7  Kubernetes集群的高可用部署方案	697
10.7.1  手工方式的高可用部署方案	698
10.7.2  使用kubeadm的高可用部署方案	709
10.8  Kubernetes集群监控	717
10.8.1  通过Metrics Server监控Pod和Node的CPU和内存资源使用数据	717
10.8.2  Prometheus+Grafana集群性能监控平台搭建	720
10.9  集群统一日志管理	732
10.9.1  系统部署架构	733
10.9.2  创建Elasticsearch RC和Service	733
10.9.3  在每个Node上启动Fluentd	736
10.9.4  运行Kibana	738
10.10  Kubernetes的审计机制	742
10.11  使用Web UI（Dashboard）管理集群	746
10.12  Helm：Kubernetes应用包管理工具	750
10.12.1  Helm概述	750
10.12.2  Helm的主要概念	751
10.12.3  安装Helm	751
10.12.4  Helm的常见用法	752
10.12.5  --set的格式和限制	756
10.12.6  更多的安装方法	757
10.12.7  helm upgrade和helm rollback：应用的更新或回滚	757
10.12.8  helm install/upgrade/rollback命令的常用参数	758
10.12.9  helm delete：删除一个Release	759
10.12.10  helm repo：仓库的使用	759
10.12.11  自定义Chart	759
10.12.12  对Chart目录结构和配置文件的说明	759
10.12.13  对Chart.yaml文件的说明	760
10.12.14  快速制作自定义的Chart	761
10.12.15  搭建私有Repository	761
第11章  Trouble Shooting指导	763
11.1  查看系统Event	764
11.2  查看容器日志	766
11.3  查看Kubernetes服务日志	767
11.4  常见问题	769
11.4.1  由于无法下载pause镜像导致Pod一直处于Pending状态	769
11.4.2  Pod创建成功，但RESTARTS数量持续增加	771
11.4.3  通过服务名无法访问服务	772
11.5  寻求帮助	773
第12章  Kubernetes开发中的新功能	777
12.1  对Windows容器的支持	778
12.1.1  Windows Node部署	778
12.1.2  Windows容器支持的Kubernetes特性和发展趋势	790
12.2  对GPU的支持	791
12.2.1  环境准备	792
12.2.2  在容器中使用GPU资源	795
12.2.3  发展趋势	797
12.3  Pod的垂直扩缩容	797
12.3.1  前提条件	798
12.3.2  安装Vertical Pod Autoscaler	798
12.3.3  为Pod设置垂直扩缩容	798
12.3.4  注意事项	800
12.4  Kubernetes的演进路线和开发模式	801
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Kubernetes权威指南：从Docker到Kubernetes实践全接触（第4版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker生产环境实践指南
第1章　入门 1
1.1 术语 1
1.1.1 镜像与容器 1
1.1.2 容器与虚拟机 1
1.1.3 持续集成/持续交付 2
1.1.4 宿主机管理 2
1.1.5 编排 2
1.1.6 调度 2
1.1.7 发现 2
1.1.8 配置管理 2
1.2 从开发环境到生产环境 3
1.3 使用Docker的多种方式 3
1.4 可预期的情况 4
第2章　技术栈 7
2.1 构建系统 8
2.2 镜像仓库 8
2.3 宿主机管理 8
2.4 配置管理 9
2.5 部署 9
2.6 编排 9
第3章　示例：极简环境 11
3.1 保持各部分的简单 11
3.2 保持流程的简单 13
3.3 系统细节 14
3.4 集群范围的配置、通用配置及本地配置 18
3.5 部署服务 19
3.6 支撑服务 21
3.7 讨论 21
3.8 未来 22
3.9 小结 22
第4章　示例：Web环境 23
4.1 编排 24
4.1.1 让服务器上的Docker进入准备运行容器的状态 25
4.1.2 让容器运行 25
4.2 连网 28
4.3 数据存储 28
4.4 日志 29
4.5 监控 30
4.6 无须担心新依赖 30
4.7 零停机时间 30
4.8 服务回滚 31
4.9 小结 31
第5章　示例：Beanstalk环境 33
5.1 构建容器的过程 34
5.2 日志 35
5.3 监控 36
5.4 安全 36
5.5 小结 36
第6章　安全 37
6.1 威胁模型 37
6.2 容器与安全性 38
6.3 内核更新 39
6.4 容器更新 39
6.5 suid及guid二进制文件 40
6.6 容器内的root 40
6.7 权能 41
6.8 seccomp 41
6.9 内核安全框架 42
6.10 资源限制及cgroup 42
6.11 ulimit 43
6.12 用户命名空间 43
6.13 镜像验证 44
6.14 安全地运行Docker守护 进程 45
6.15 监控 45
6.16 设备 45
6.17 挂载点 45
6.18 ssh 46
6.19 私钥分发 46
6.20 位置 46
第7章　构建镜像 49
7.1 此镜像非彼镜像 49
7.1.1 写时复制与高效的镜像存储与分发 50
7.1.2 Docker对写时复制的使用 51
7.2 镜像构建基本原理 52
7.2.1 分层的文件系统和空间控管 54
7.2.2 保持镜像小巧 57
7.2.3 让镜像可重用 58
7.2.4 在进程无法被配置时，通过环境变量让镜像可配置 59
7.2.5 让镜像在Docker变化时对自身进行重新配置 62
7.2.6 信任与镜像 67
7.2.7 让镜像不可变 67
7.3 小结 68
第8章　存储Docker镜像 69
8.1 启动并运行存储的Docker镜像 69
8.2 自动化构建 70
8.3 私有仓库 71
8.4 私有registry的扩展 71
8.4.1 S3 72
8.4.2 本地存储 72
8.4.3 对registry进行负载均衡 72
8.5 维护 73
8.6 对私有仓库进行加固 73
8.6.1 SSL 73
8.6.2 认证 73
8.7 保存/载入 74
8.8 最大限度地减小镜像体积 74
8.9 其他镜像仓库方案 75
第9章　CI/CD 77
9.1 让所有人都进行镜像构建与推送 79
9.2 在一个构建系统中构建所有镜像 80
9.3 不要使用或禁止使用非标准做法 80
9.4 使用标准基础镜像 80
9.5 使用Docker进行集成测试 81
9.6 小结 81
第10章　配置管理 83
10.1 配置管理与容器 83
10.2 面向容器的配置管理 84
10.2.1 Chef 85
10.2.2 Ansible 87
10.2.3 Salt Stack 89
10.2.4 Puppet 90
10.3 小结 92
第11章　Docker存储引擎 93
11.1 AUFS 94
11.2 DeviceMapper 99
11.3 BTRFS 104
11.4 OverlayFS 108
11.5 VFS 112
11.6 小结 114
第12章　Docker网络实现 115
12.1 网络基础知识 116
12.2 IP地址的分配 119
12.3 域名解析 124
12.4 服务发现 128
12.5 Docker高级网络 132
12.5.1 网络安全 132
12.5.2 多主机的容器间通信 136
12.5.3 共享网络命名空间 138
12.6 IPv6 141
12.7 小结 142
第13章　调度 145
13.1 什么是调度 146
13.2 调度策略 147
13.3 Mesos 147
13.4 Kubernetes 148
13.5 OpenShift 149
第14章　服务发现 153
14.1 DNS服务发现 155
14.2 Zookeeper 159
14.3 基于Zookeeper的服务发现 160
14.4 etcd 161
14.5 consul 165
14.5.1 基于consul的服务发现 167
14.5.2 registrator 168
14.6 Eureka 171
14.7 Smartstack 174
14.7.1 基于Smartstack的服务发现 175
14.7.2 Nerve 175
14.7.3 Synapse 176
14.8 nsqlookupd 177
14.9 小结 177
第15章　日志和监控 179
15.1 日志 179
15.1.1 Docker原生的日志 支持 180
15.1.2 连接到Docker容器 181
15.1.3 将日志导出到宿主机 182
15.1.4 发送日志到集中式的日志 平台 183
15.1.5 在其他容器一侧收集 日志 184
15.2 监控 185
15.2.1 基于宿主机的监控 187
15.2.2 基于Docker守护进程的 监控 188
15.2.3 基于容器的监控 191
15.3 小结 194
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker生产环境实践指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Mesos：大数据资源调度与大规模容器运行最佳实践
目录
前言 xiv
第1章运行Mesos 1
1.1 现代数据中心 1
1.2 集群计算框架 2
1.3 Mesos简介 2
1.3.1 master 3
1.3.2 slave 4
1.3.3 框架 4
1.4 为什么使用Mesos 4
1.5 单节点Mesos集群 5
1.5.1 Mac OS 5
1.5.2 Fedora 6
1.5.3 安装依赖软件包 6
1.5.4 构建Mesos 8
1.5.5 启动Mesos 10
1.6 运行测试框架 11
1.7 Mesos Web UI 15
1.8 多节点Mesos集群 15
1.9 Amazon EC2 上的Mesos集群 16
1.10 使用 Vagrant 运行Mesos 18
1.11 Mesos社区 19
1.11.1 案例研究 19
1.11.2 邮件列表 20
1.12小结 20
第 2 章在Mesos上运行 Hadoop 21
2.1 Hadoop 介绍 21
2.2 Mesos上的 Hadoop 22
2.3 在Mesos上安装 Hadoop 23
2.4 Hadoop 作业示例 26
2.5 Mesos上 Hadoop 的高级配置 27
2.5.1 任务资源分配 27
2.5.2 度量报告 29
2.5.3 认证 32
2.5.4 容器隔离 33
2.5.5 其他配置参数 33
2.6 小结 34
第 3 章在Mesos上运行 Spark 35
3.1 Spark 介绍 35
3.2 Spark 作业调度 36
3.3 Spark Standalone模式 38
3.4 在Mesos上的 Spark 40
3.5 在Mesos上 Spark 的调优 41
3.6 小结 43
第 4 章Mesos上的复杂数据分析44
4.1 复杂数据和 Lambda 架构的兴起 44
4.2 Storm 46
4.2.1 Mesos上的 Storm 47
4.2.2 Storm-Mesos配置 49
4.3 Spark Streaming 50
4.3.1 在Mesos上运行 Spark Streaming 52
4.3.2 Spark Streaming 调优 53
4.4 Mesos上的 NoSQL 55
4.4.1 Mesos上的 Cassandra 55
4.5 小结 57
第 5 章在Mesos上运行服务 59
5.1 服务的介绍 59
5.2 Marathon 60
5.2.1 Marathon API 61
5.2.2运行 Marathon 62
5.2.3 Marathon 样例 63
5.2.4约束条件 65
5.2.5事件总线 66
5.2.6 artifact store 66
5.2.7应用组 66
5.2.8应用程序健康检查 67
5.3 Chronos 68
5.3.1 Chronos REST API 68
5.3.2运行Chronos 70
5.3.3 Chronos样例 71
5.4 Aurora 71
5.4.1 作业的生命周期 73
5.4.2运行 Aurora 74
5.4.3 Aurora 集群配置 75
5.4.4 Aurora 作业配置 76
5.4.5 Aurora 客户端 80
5.4.6 Aurora 样例 82
5.4.7 Aurora cron作业 83
5.5 服务发现 83
5.5.1 Mesos-DNS 83
5.5.2安装Mesos-DNS 84
5.5.3 Mesos-DNS 配置 85
5.5.4运行Mesos-DNS 86
5.6 打包 87
5.7 小结 87
第 6 章理解Mesos内部机制 88
6.1Mesos架构 88
6.1.1 Mesos slave 90
6.1.2 Mesos master 91
6.1.3框架 92
6.1.4通信 92
6.1.5附属服务 93
6.2 资源分配 94
6.2.1 Mesos调度器 95
6.2.2 加权 DRF 96
6.2.3 资源预留 97
6.3 资源隔离 101
6.3.1 Mesos容器机 102
6.3.2 Docker 容器机 103
6.3.3 外部容器机 105
6.4 容错 107
6.4.1 ZooKeeper 108
6.4.2 故障检测及处理 109
6.4.3 Registry 111
6.5 扩展Mesos 112
6.5.1 Mesos模块 112
6.5.2分配模块 116
6.5.3 Mesos hook 和修饰器 119
6.5.4任务标签 119
6.6 小结 119
第 7 章开发Mesos框架 120
7.1 Mesos API 120
7.1.1 Mesos消息 121
7.1.2调度器 API 122
7.1.3调度器驱动 API 124
7.1.4执行器 API 125
7.1.5调度器驱动 API 126
7.2 开发一个Mesos框架 127
7.2.1 搭建开发环境 127
7.2.2加入框架调度器 128
7.2.3加入框架启动器 130
7.2.4部署框架 131
7.3 构建框架 133
7.3.1 给框架加入执行器 137
7.3.2 更新框架调度器 141
7.3.3 运行多个执行器 144
7.4 高级主题 147
7.4.1 一致性调解 147
7.4.2 有状态应用 148
7.5 开发者资料 148
7.5.1 框架设计模式 149
7.5.2 框架测试 149
7.5.3 RENDLER 149
7.5.4 Akka-mesos 150
7.6 小结 150
第 8 章管理Mesos 151
8.1 部署 151
8.2 升级 152
8.3 监控 153
8.3.1 容器网络监控 153
8.4 多租户 155
8.4.1 授权和鉴权 155
8.4.2 API 速率限制 158
8.5 高可用 160
8.5.1 master 高可用 160
8.5.2 限制 slave 移除速率 162
8.5.3 slave 恢复 162
8.6 维护状态 163
8.7 Mesos接口 165
8.7.1 Mesos REST 接口 165
8.7.2 Mesos CLI 167
8.8配置 170
8.8.1 Mesos master 171
8.8.2 Mesos slave 174
8.8.3 Mesos构建选项 179
小结 181
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Mesos：大数据资源调度与大规模容器运行最佳实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker经典实例
本书赞誉 xi
前言 xiii
第1章　Docker 入门　　1
1.0　简介　　1
1.1　在Ubuntu　　14.04 上安装Docker　　2
1.2　在CentOS　　6.5 上安装Docker　　3
1.3　在CentOS　　7 上安装Docker　　4
1.4　使用Vagrant 创建本地Docker 主机　　4
1.5　在树莓派上安装Docker　　6
1.6　在OS X 上通过Docker Toolbox 安装Docker　　7
1.7　在OS X 上通过Boot2Docker 安装Docker　　9
1.8　在Windows　　8.1 台式机上运行Boot2Docker　　13
1.9　使用Docker Machine 在云中创建Docker 主机　　14
1.10　使用Docker 实验版二进制文件　　18
1.11　在Docker 中运行Hello World　　18
1.12　以后台方式运行Docker 容器　　20
1.13　创建、启动、停止和移除容器　　21
1.14　使用Dockerfile 构建Docker 镜像　　22
1.15　在单一容器中使用Supervisor 运行WordPress　　24
1.16　使用两个链接在一起的容器运行WordPress 博客程序　　26
1.17　备份在容器中运行的数据库　　28
1.18　在宿主机和容器之间共享数据　　30
1.19　在容器之间共享数据　　31
1.20　对容器进行数据复制　　32
第2章　创建和共享镜像　　34
2.0　简介　　34
2.1　将对容器的修改提交到镜像　　35
2.2　将镜像和容器保存为tar 文件进行共享　　36
2.3　编写你的第一个Dockerfile　　37
2.4　将Flask 应用打包到镜像　　40
2.5　根据最佳实践优化Dockerfile　　42
2.6　通过标签对镜像进行版本管理　　43
2.7　使用Docker provider 从Vagrant 迁移到Docker　　45
2.8　使用Packer 构建Docker 镜像　　47
2.9　将镜像发布到Docker Hub　　50
2.10　使用ONBUILD 镜像　　53
2.11　运行私有registry　　54
2.12　为持续集成/部署在Docker Hub 上配置自动构建　　56
2.13　使用Git 钩子和私有registry 建立本地自动构建环境　　60
2.14　使用Conduit 进行持续部署　　61
第3章　Docker网络　　63
3.0　简介　　63
3.1　查看容器的IP地址　　64
3.2　将容器端口暴露到主机上　　65
3.3　在Docker中进行容器链接　　67
3.4　理解Docker容器网络　　69
3.5　选择容器网络模式　　72
3.6　配置Docker 守护进程iptables 和IP 转发设置　　74
3.7　通过Pipework 理解容器网络　　75
3.8　定制Docker 网桥设备　　80
3.9　在Docker 中使用OVS　　81
3.10　在Docker 主机间创建GRE 隧道　　83
3.11　在Weave 网络上运行容器　　85
3.12　在AWS 上运行Weave 网络　　87
3.13　在Docker 主机上部署flannel 覆盖网络　　89
3.14　在多台Docker 主机中使用Docker Network　　90
3.15　深入Docker Network 命名空间配置　　94
第4章　开发和配置Docker　　96
4.0　简介　　96
4.1　管理和配置Docker 守护进程　　97
4.2　从源代码编译自己的Docker 二进制文件　　98
4.3　为开发Docker 运行Docker 测试集　　100
4.4　使用新的Docker 二进制文件替换当前的文件　　101
4.5　使用nsenter　　102
4.6　runc 简介　　104
4.7　远程访问Docker 守护进程　　106
4.8　通过Docker 远程API 完成自动化任务　　107
4.9　从远程安全访问Docker 守护进程　　109
4.10　使用docker-py 访问远程Docker 守护进程　　111
4.11　安全使用docker-py　　113
4.12　更改存储驱动程序　　113
第5章　Kubernetes　　116
5.0　简介　　116
5.1　理解Kubernetes 架构　　118
5.2　用于容器间连接的网络pod　　120
5.3　使用Vagrant 创建一个多节点的Kubernetes 集群　　121
5.4　在Kubernetes 集群上通过pod 启动容器　　124
5.5　利用标签查询Kubernetes 对象　　126
5.6　使用replication controller 管理pod 的副本数　　127
5.7　在一个pod 中运行多个容器　　129
5.8　使用集群IP 服务进行动态容器链接　　131
5.9　使用Docker Compose 创建一个单节点Kubernetes 集群　　135
5.10　编译Kubernetes 构建自己的发布版本　　139
5.11　使用hyperkube 二进制文件启动Kubernetes 组件　　141
5.12　浏览Kubernetes API　　142
5.13　运行Kubernetes 仪表盘　　146
5.14　升级老版本API　　147
5.15　为Kubernetes 集群添加身份验证支持　　149
5.16　配置Kubernetes 客户端连接到远程集群　　150
第6章　为Docker 优化的操作系统　　152
6.0　简介　　152
6.1　在Vagrant 中体验CoreOS Linux 发行版　　153
6.2　使用cloud-init 在CoreOS 上启动容器　　155
6.3　通过Vagrant 启动CoreOS 集群，在多台主机上运行容器　　157
6.4　在CoreOS 集群上通过fleet 启动容器　　160
6.5　在CoreOS 实例之间部署flannel 覆盖网络　　162
6.6　使用Project Atomic 运行Docker 容器　　164
6.7　在AWS 上启动Atomic 实例运行Docker　　165
6.8　快速体验在Ubuntu Core Snappy 上运行Docker　　167
6.9　在AWS EC2 上启动Ubuntu Core Snappy 实例　　169
6.10　在RancherOS 中运行Docker 容器　　173
第7章　Docker 生态环境：工具　　175
7.0　简介　　175
7.1　使用Docker Compose创建WordPress站点　　176
7.2　使用Docker Compose在Docker上对Mesos和Marathon进行测试　　179
7.3　在Docker Swarm 集群上运行容器　　181
7.4　使用Docker Machine创建跨云计算服务提供商的Swarm集群　　183
7.5　使用Kitematic UI 管理本地容器　　185
7.6　使用Docker UI 管理容器　　187
7.7　使用Wharfee 交互式shell　　189
7.8　使用Ansible 的Docker模块对容器进行编排　　190
7.9　在Docker主机集群中使用Rancher管理容器　　193
7.10　使用Lattice 在集群中运行容器　　196
7.11　通过Apache Mesos 和Marathon 运行容器　　198
7.12　在Mesos 集群上使用Mesos Docker 容器化　　202
7.13　使用registrator 发现Docker 服务　　204
第8章　云计算中的Docker　　208
8.0　简介　　208
8.1　在公有云中运行Docker　　209
8.2　在AWS EC2 上启动Docker 主机　　212
8.3　在Google GCE 上启动Docker 主机　　215
8.4　在Microsoft Azure 上启动Docker 主机　　218
8.5　在AWS 上使用Docker Machine 启动Docker 主机　　220
8.6　在Azure 上使用Docker Machine 启动Docker 主机　　222
8.7　在Docker 容器中运行云服务提供商的CLI　　224
8.8　使用Google Container registry 存储Docker 镜像　　226
8.9　在GCE Google-Container 实例中使用Docker　　229
8.10　通过GCE 在云中使用Kubernetes　　231
8.11　配置使用EC2 Container Service　　234
8.12　创建一个ECS 集群　　237
8.13　在ECS 集群中启动Docker 容器　　240
8.14　利用AWS Beanstalk 对Docker 的支持在云中运行应用程序　　244
第9章　监控容器　　248
9.0　简介　　248
9.1　使用docker inspect 命令获取容器的详细信息　　249
9.2　获取运行中容器的使用统计信息　　251
9.3　在Docker 主机上监听Docker 事件　　252
9.4　使用docker logs 命令获取容器的日志　　254
9.5　使用Docker 守护进程之外的日志记录驱动程序　　254
9.6　使用Logspout 采集容器日志　　257
9.7　管理Logspout 路由来存储容器日志　　259
9.8　使用Elasticsearch 和Kibana 对容器日志进行存储和可视化　　261
9.9　使用Collectd 对容器指标进行可视化　　262
9.10　使用cAdvisor 监控容器资源使用状况　　267
9.11　通过InfluxDB、Grafana 和cAdvisor 监控容器指标　　269
9.12　使用Weave Scope 对容器布局进行可视化　　270
第10章　应用用例　　272
10.0　简介　　272
10.1　CI/CD：构建开发环境　　273
10.2　CI/CD：使用Jenkins 和Apache Mesos 构建持续交付工作流　　276
10.3　ELB：使用confd 和registrator 创建动态负载平衡器　　280
10.4　DATA：使用Cassandra 和Kubernetes 构建兼容S3 的对象存储　　286
10.5　DATA：使用Docker Network 构建MySQL Galera 集群　　290
10.6　DATA：以动态方式为MySQL Galera 集群配置负载平衡器　　292
10.7　DATA：构建Spark 集群　　294
关于作者　　298
关于封面　　298

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker经典实例
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker实战
第1 部分 保持一台整洁的机器
第1 章 欢迎来到Docker 世界  2
1.1 什么是Docker 3
1.1.1 容器  3
1.1.2 容器不是虚拟化  4
1.1.3 在隔离的容器中运行软件  4
1.1.4 分发容器  6
1.2 Docker 解决了什么问题 6
1.2.1 组织有序  7
1.2.2 提高可移植性  8
1.2.3 保护你的机器  9
1.3 为什么Docker 如此重要 10
1.4 何时何处使用Docker  11
1.5 案例：“Hello World”  11
1.6 小结  13
第2 章 在容器中运行软件  14
2.1 从Docker 命令行工具获得帮助 14
2.2 控制容器：建立一个网站的监控器  15
2.2.1 创建和启动一个新的容器 16
2.2.2 运行交互式容器  17
2.2.3 列举、停止、重新启动和查看容器输出 18
2.3 已解决的问题和PID 命名空间 20
2.4 消除元数据冲突：构建一个网站农场 23
2.4.1 灵活的容器标识  24
2.4.2 容器的状态和依赖 26
2.5 构建与环境无关的系统  28
2.5.1 只读文件系统  29
2.5.2 环境变量的注入  31
2.6 建立持久化的容器 34
2.6.1 自动重启容器  35
2.6.2 使用init 和supervisor 进程维持容器的运行状态 36
2.7 清理  38
2.8 小结  39
第3 章 软件安装的简化  40
3.1 选择所需的软件 41
3.1.1 什么是仓库 41
3.1.2 使用标签  42
3.2 查找和安装软件 43
3.2.1 命令行使用Docker Hub  43
3.2.2 通过网站访问Docker Hub 45
3.2.3 使用替代注册服务器  47
3.2.4 镜像文件  47
3.2.5 从Dockerfile 安装 49
3.3 安装文件和隔离 49
3.3.1 镜像层实战 50
3.3.2 分层关系  51
3.3.3 容器文件系统抽象和隔离 52
3.3.4 分层文件系统及其工具的优点 53
3.3.5 Union 文件系统的不足 53
3.4 小结  54
第4 章 持久化存储和卷间状态共享  55
4.1 存储卷的简介  56
4.1.1 存储卷提供容器无关的数据管理方式 56
4.1.2 NoSQL 数据库使用存储卷 57
4.2 存储卷的类型  60
4.2.1 绑定挂载卷 60
4.2.2 Docker 管理卷 63
4.3 共享存储卷  65
4.3.1 主机依赖的共享  65
4.3.2 共享和volumes-from 标志 66
4.4 管理卷的生命周期 68
4.4.1 管理卷的权限  68
4.4.2 存储卷的清理  69
4.5 存储卷的高级容器模式  70
4.5.1 卷容器模式 70
4.5.2 数据打包的存储卷容器  72
4.5.3 多态容器模式  73
4.6 小结  74
第5 章 网络访问 75
5.1 网络相关的背景知识  76
5.1.1 基础：协议，接口和端口 76
5.1.2 高级：网络，NAT 和端口转发  77
5.2 Docker 的网络  79
5.2.1 本地Docker 网络的拓扑结构 79
5.2.2 四种网络容器原型 80
5.3 Closed 容器  81
5.4 Bridged 容器 83
5.4.1 访问外部网络  84
5.4.2 自定义命名解析  85
5.4.3 开放对容器的访问 88
5.4.4 跨容器通信 91
5.4.5 修改网桥接口的配置  92
5.5 Joined 容器  93
5.6 Open 容器 95
5.7 跨容器依赖  96
5.7.1 链接——本地服务发现  97
5.7.2 链接别名  98
5.7.3 环境变量的改动  99
5.7.4 链接的本质和缺点  101
5.8 小结  102
第6 章 隔离——限制危险  103
6.1 资源分配 104
6.1.1 内存限制  104
6.1.2 CPU 105
6.1.3 设备的访问权 108
6.2 共享内存 108
6.2.1 跨容器的进程间通信 109
6.2.2 开放内存容器 110
6.3 理解用户 111
6.3.1 Linux 用户命令空间  111
6.3.2 run-as 用户 111
6.3.3 用户和卷  114
6.4 能力——操作系统功能的授权 116
6.5 运行特权容器  117
6.6 使用加强工具创建更健壮的容器 118
6.6.1 指定额外的安全选项 119
6.6.2 微调LXC 120
6.7 因地制宜地构建容器 121
6.7.1 应用  121
6.7.2 高层的系统服务  122
6.7.3 低层的系统服务  122
6.8 小结  122
第2 部分 镜像发布：如何打包软件
第7 章 在镜像中打包软件  126
7.1 从容器构建镜像  126
7.1.1 打包Hello World  127
7.1.2 打包Git  128
7.1.3 审查文件系统的改动 128
7.1.4 Commit——创建新镜像 129
7.1.5 可配置的镜像属性  130
7.2 深入Docker 镜像和层  131
7.2.1 深入联合文件系统  132
7.2.2 重新认识镜像、层、仓库和标签 134
7.2.3 镜像体积和层数限制 137
7.3 导出和导入扁平文件系统  139
7.4 版本控制的最佳实践 141
7.5 小结  143
第8 章 构建自动化和高级镜像设置  144
8.1 使用Dockerfile 打包Git  144
8.2 Dockerfile 入门 148
8.2.1 元数据指令  148
8.2.2 文件系统指令 152
8.3 注入下游镜像在构建时发生的操作  155
8.4 使用启动脚本和多进程容器  158
8.4.1 验证环境相关的先决条件  158
8.4.2 初始化进程  160
8.5 加固应用镜像  161
8.5.1 内容可寻址镜像标识符  161
8.5.2 用户权限  162
8.5.3 SUID 和SGID 权限  164
8.6 小结  166
第9 章 公有和私有软件分发  168
9.1 选择一个分发方法 169
9.1.1 分发选项图谱 169
9.1.2 选择标准  169
9.2 通过托管Registry 发布  172
9.2.1 通过公有仓库发布：你好！Docker Hub  172
9.2.2 使用自动构建发布公有项目 174
9.2.3 私有托管仓库 176
9.3 私有Registry 介绍 178
9.3.1 使用Registry 镜像 180
9.3.2 从Registry 使用镜像 181
9.4 镜像的手动发布和分发 181
9.5 镜像源代码分发工作流程  186
9.6 小结  189
第10 章 运行自定义Registry  190
10.1 运行个人Registry 191
10.1.1 再度介绍镜像  192
10.1.2 介绍V2 API  193
10.1.3 定制镜像 195
10.2 集中式Registry 的增强 196
10.2.1 创建一个反向代理  197
10.2.2 在反向代理上配置HTTPS（TLS） 199
10.2.3 添加身份认证层 202
10.2.4 客户端兼容性  206
10.2.5 应用于生产环境之前  208
10.3 持久化的BLOB 存储  210
10.3.1 微软Azure 托管远程存储  211
10.3.2 AWS S3 托管远程存储  212
10.3.3 RADOS（Ceph）的内部远程存储 214
10.4 扩展访问和延迟的改进 215
10.4.1 与元数据缓存集成  215
10.4.2 使用存储中间件简化BLOB 传输  217
10.5 通过通知集成 219
10.6 小结 224
第3 部分 多容器和多主机环境
第11 章 Docker Compose 声明式环境 228
11.1 Docker Compose：第一天的启动并运行  228
11.1.1 用一个简单的开发环境入门 229
11.1.2 一个复杂的架构：分布式系统和Elasticsearch 的集成  231
11.2 环境内的迭代 233
11.2.1 构建、启动和重新构建服务 234
11.2.2 服务伸缩和删除 237
11.2.3 迭代和持久化状态  238
11.2.4 网络和连接问题 239
11.3 开始一个新项目：三个示例中的Compose YAML  240
11.3.1 启动前的构建、环境、元数据和网络 240
11.3.2 已知的组件和绑定挂载卷  241
11.3.3 卷容器和扩展服务  242
11.4 小结 243
第12 章 Docker Machine 和Swarm 集群  245
12.1 介绍Docker Machine 246
12.1.1 构建和管理Docker Machine 246
12.1.2 配置Docker 客户端与远程Daemon 工作 249
12.2 Docker Swarm 介绍 252
12.2.1 借助于Docker Machine 构建Swarm 集群 252
12.2.2 Swarm 扩展了Docker 远程API  255
12.3 Swarm 调度  258
12.3.1 Spread 算法  258
12.3.2 用过滤器调整调度  260
12.3.3 BinPack 和随机调度算法  263
12.4 Swarm 服务发现 265
12.4.1 Swarm 和单主机网络  266
12.4.2 服务发现生态系统和权宜之计 268
12.4.3 展望多主机网络 269
12.5 小结 270
后记 271
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高性能Docker
前言 ....................................................................................................XI
1 准备Docker 宿主机 ................................................................................... 1
准备一个Docker 宿主机 ......................................................................................................1
使用Docker 镜像 ..................................................................................................................2
编译Docker 镜像 ............................................................................................................. 3
推送Docker 镜像到资源库 ............................................................................................. 4
从资源库中拉取Docker 镜像 ......................................................................................... 6
运行Docker 容器 ..................................................................................................................7
暴露容器端口 ................................................................................................................... 7
发布容器端口 ................................................................................................................... 9
链接容器 ........................................................................................................................ 11
交互式容器 ..................................................................................................................... 12
小结 ...............................................................................................14
2 优化Docker 镜像 .................................................................................... 15
降低部署时间 .....................................................................................................................15
改善镜像编译时间 ..........................................................................................................18
采用registry 镜像 .......................................................................................................... 19
复用镜像层 ..................................................................................................................... 21
减小构建上下文大小 ..................................................................................................... 28
使用缓存代理 ................................................................................................................. 29
减小Docker 镜像的尺寸 ...............................................................................................32
链式指令 ..................................................................................................... 32
分离编译镜像和部署镜像 ............................................................................................. 34
小结 ..................................................................................................................37
3 用Chef 自动化部署Docker ..................................................................... 39
配置管理简介 ..................................................................................................................39
使用Chef ........................................................................................................................40
注册Chef 服务器 ........................................................................................................... 41
搭建工作站 ..................................................................................................................... 43
启动节点 ................................................................................................................... 45
配置Docker 宿主机 ..........................................................................................................47
部署Docker 容器 ..............................................................................................................51
可选方案 ...................................................................................................................55
小结 .....................................................................................................................56
4 监控Docker 宿主机和容器 ...................................................................... 57
监控的重要性 ....................................................................................................................57
收集数据到Graphite .........................................................................................................58
生产系统中的Graphite .................................................................................................. 63
用collectd 监控 .................................................................................................................63
收集Docker 相关数据 ................................................................................................... 65
在ELK 栈中整合日志 ......................................................................................................69
转发Docker 容器日志 ......................................................................................................72
其他监控和日志方案 .........................................................................................................75
小结 .........................................................................................................................76
5 性能基准测试 ........................................................................................... 77
配置Apache JMeter ...........................................................................................................77
部署一个简单应用 ......................................................................................................... 78
安装JMeter ..................................................................................................................... 81
生成性能负载 .....................................................................................................................82
在JMeter 中生成测试计划 ............................................................................................ 83
分析基准测试结果 .............................................................................................................84
检查JMeter 运行结果 .................................................................................................... 85
在Graphite 和Kibana 中观察性能 ............................................................................... 87
性能调优 ..................................................................................................................91
增加并发 .......................................................................................................91
运行分布式测试 ............................................................................................................. 92
其他性能基准工具 ........................................................................................................... 93
小结 ......................................................................................................................94
6 负载均衡 .................................................................................................. 95
准备Docker 宿主机集群 ...................................................................................................95
使用Nginx 来做负载均衡 .................................................................................................97
水平扩展Docker 应用 .....................................................................................................100
零停机部署 ................................................................................................................... 101
其他负载均衡器 ................................................................................................................105
小结 ....................................................................................................................106
7 容器的故障检测和排除 .......................................................................... 107
检查容器 ...............................................................................................................107
从外部调试 .......................................................................................................................111
追踪系统调用 ............................................................................................................... 111
分析网络数据包 ........................................................................................................... 114
观察块设备 ................................................................................................................... 116
故障检测和排除工具 ........................................................................................................119
小结 .....................................................................................................................120
8 应用到生产环境 ..................................................................................... 121
Web 运维 ..................................................................................................................121
使用Docker 支持Web 应用 ........................................................................................... 123
部署应用 ................................................................................................................... 124
扩展应用 ............................................................................................................... 125
更多阅读资料 .......................................................................................................... 126
小结 ........................................................................................................ 126
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高性能Docker
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker从入门到实战
前言
第1篇 容器技术与Docker概念
第1章 容器技术 2
1.1 什么是容器 2
1.2 容器技术的前世今生 4
1.3 容器的原理 7
1.4 容器云 12
1.5 容器与Docker 13
1.6 本章小结 13
第2章 Docker简介 14
2.1 什么是Docker 14
2.2 Docker的功能及优缺点 18
2.3 Docker和虚拟机 19
2.4 Docker与runC 21
2.5 Docker基本架构 24
2.6 本章小结 26
第3章 安装Docker 27
3.1 Linux系统 27
3.2 Windows与Mac OS系统 38
3.3 二进制安装 43
3.4 本章小结 46
第2篇 Docker基础知识
第4章 Docker基础 48
4.1 Docker基本操作 48
4.2 启动第一个Docker容器 79
4.3 构建第一个Docker镜像 80
4.4 本章小结 81
第5章 Docker镜像 82
5.1 认识镜像 82
5.2 创建镜像 86
5.3 导出和导入镜像 91
5.4 发布镜像 91
5.5 删除镜像 93
5.6 Docker镜像扩展 94
5.7 本章小结 96
第6章 Dockerfile文件 97
6.1 Dockerfile基本结构 97
6.2 Dockerfile指令 99
6.3 镜像构建实战 106
6.4 本章小结 108
第7章 Docker仓库 109
7.1 官方仓库Docker Hub 109
7.2 国内镜像仓库 111
7.3 私有仓库 117
7.4 Registry原理 118
7.5 本章小结 120
第8章 Docker容器 121
8.1 容器基本操作 121
8.2 进入容器内部 128
8.3 导出和导入容器 130
8.4 容器结构 131
8.5 本章小结 133
第9章 数据卷 134
9.1 数据卷是什么 134
9.2 为容器挂载数据卷 135
9.3 备份、恢复、迁移数据卷 139
9.4 容器数据卷扩展 140
9.5 本章小结 142
第10章 网络管理 143
10.1 Docker网络基础 143
10.2 Docker网络模式 147
10.3 Docker网络配置 152
10.4 本章小结 154
第3篇 Docker进阶实战
第11章 操作系统 156
11.1 Alpine发行版 156
11.2 Busybox发行版 159
11.3 Debian/Ubuntu发行版 160
11.4 CentOS/Fedora发行版 162
11.5 CoreOS发行版 163
11.6 RancherOS发行版 165
11.7 本章小结 167
第12章 编排工具Compose 169
12.1 安装Docker Compose 169
12.2 Compose命令基础 170
12.3 Compose配置文件 186
12.4 Compose实战 200
12.5 本章小结 205
第13章 Web服务器与应用 206
13.1 Apache服务器 206
13.2 Nginx服务器 212
13.3 Tomcat服务器 216
13.4 其他Web服务器 220
13.5 本章小结 223
第14章 数据库 224
14.1 MySQL数据库 224
14.2 PostgreSQL数据库 228
14.3 Redis数据库 235
14.4 MongoDB数据库 238
14.5 其他 240
14.6 本章小结 244
第15章 编程语言 245
15.1 C/C++语言 245
15.2 Golang语言 247
15.3 Java语言 253
15.4 JavaScript（Node.js）语言 258
15.5 PHP语言 265
15.6 Python语言 275
15.7 Swift语言 277
15.8 本章小结 280
第16章 Docker API介绍 281
16.1 认识Docker API 281
16.2 Docker Remote API介绍 286
16.3 其他API 299
16.4 本章小结 304
第17章 私有仓库 305
17.1 Docker Registry介绍 305
17.2 认证与前端 312
17.3 企业级私有仓库Harbor 316
17.4 私有仓库前端授权工具Portus 321
17.5 本章小结 323
第18章 集群网络 324
第19章 Docker安全 340
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker从入门到实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker即学即用
序
前言
第1章 引言
Docker的诞生
Docker带来的希望
Docker不是什么
第2章 Docker概览
简化业务流程
广泛支持和采用
架构
充分理解Docker
Docker式工作流程
小结
第3章 安装Docker
重要的术语
安装Docker客户端
测试安装的Docker
小结
第4章 使用Docker映像
剖析Dockerfile文件
构建映像
运行映像
定制基础映像
存储映像
第5章 使用Docker容器
容器是什么？
创建容器
启动容器
自动重启容器
停止容器
清除容器
暂停和恢复容器
清理容器和映像
接下来
第6章 探索Docker的其他功能
打印Docker的版本号
服务器信息
下载映像的更新
审查容器
进入运行中的容器
在shell中探索
返回结果
Docker的日志
监控Docker
小结
第7章 在生产环境中使用容器
部署
测试容器
第8章 调试容器
列出进程
检查进程
管理进程
检查网络
查看映像的历史
检查容器
检查文件系统
接下来
第9章 大规模使用Docker
Docker Swarm
Centurion
Amazon EC2 Container Service
小结
第10章 高级话题
可更换的后端
容器详解
安全性
网络
第11章 自己设计存储容器的线上平台
应用的十二要素
响应式宣言
小结
第12章 总结
挑战
Docker式工作流程
简化用于部署的构建产物
使用最佳方式存储和获取映像
回报
结语
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker即学即用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>如何启动黄金圈思维
前言    启动黄金圈思维
引言    为什么要找到为什么
第1章    从为什么开始入门指南
第2章    找到你的为什么
第3章    找到为什么的个人指南
第4章    找到为什么的团队指南第 1 部分
第5章    找到为什么的团队指南第 2 部分
第6章    说出你的怎么做
第7章    践行你的主张:按你相信的付诸行动
附录 1    工作坊中的常见问题
附录 2    找到个人为什么的伙伴小贴士
附录 3    找到团队为什么的促进者小贴士
致谢
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>如何启动黄金圈思维
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker容器实战：原理、架构与应用
第1篇  Docker基础知识介绍
第１章　云计算简介	2
1.1  虚拟化技术的分类和历史	3
1.1.1  硬件级虚拟化历史	3
1.1.2  操作系统级虚拟化历史	4
1.2  云计算服务模式	4
1.3  Docker介绍	5
1.3.1  Docker主要解决什么问题	6
1.3.2  Docker的历史	6
1.3.3  Docker是什么	6
1.4  Linux快速入门	7
1.4.1  选取什么发行版本	7
1.4.2  使用图形界面还是命令行界面	8
1.4.3  英文还是中文	8
1.4.4  安装Ubuntu 14.04	8
1.4.5  Linux常用工具	11
1.4.6  启用root 用户	12
1.4.7  使用vim	12
1.4.8  配置网络	13
1.4.9  启用SSH Server	13
1.4.10  通过客户端远程连接Linux主机	14
1.4.11  免密码登录Linux主机	15
1.4.12  安装软件	15
1.4.13  公有云主机快速入门	16
1.4.14  购买云主机	17
1.4.15  连接到云主机	19
1.5  习题	21
第2章　Docker的安装	22
2.1  在Ubuntu下安装Docker	22
2.1.1  前置条件	22
2.1.2  更新apt源	23
2.1.3  Ubuntu 14.04特殊处理	24
2.1.4  正式安装	24
2.2  在CentOS下安装	26
2.2.1  前置条件	26
2.2.2  更新yum	26
2.2.3  添加仓库	26
2.2.4  正式安装	26
2.3  通过Ghostcloud进行安装	27
2.3.1  注册Ghostcloud账号	28
2.3.2  接入新主机	28
2.3.3  获取安装脚本	28
2.3.4  验证Docker安装是否成功	30
2.3.5  运行第一个容器	30
2.4  通过官方的安装脚本安装	31
2.5  在非Linux系统下安装Docker	32
2.6  习题	32
第3章　使用Docker	33
3.1  运行hello-world	33
3.2  容器和镜像	35
3.2.1  什么是容器	35
3.2.2  什么是镜像	35
3.2.3  容器和镜像的关系	36
3.3  Docker入门操作	36
3.3.1  查看Docker基本信息	36
3.3.2  下载第一个基础镜像	37
3.3.3  运行一个含shell终端的容器	38
3.3.4  查看容器运行	38
3.3.5  运行长时间容器	38
3.3.6  查看所有容器	39
3.4  习题	40
第2篇  Docker的基本使用
第4章　Docker深入解析	42
4.1  Docker的架构	42
4.2  Docker如何工作	43
4.2.1  Docker Image工作方式	43
4.2.2  Docker Registry工作方式	44
4.2.3  容器工作方式	44
4.2.4  底层的技术	45
4.3  Docker Client和Daemon	46
4.4  通过容器运行Web应用	47
4.4.1  使用国内仓库	48
4.4.2  拉取apache-php镜像	48
4.4.3  运行镜像	48
4.4.4  网页访问	48
4.4.5  修改页面内容	49
4.4.6  持久化容器	50
4.5  镜像制作	50
4.5.1  查看本机镜像	50
4.5.2  获取镜像的三种方式	51
4.5.3  查找DockerHub镜像	51
4.5.4  查找其他仓库镜像	52
4.5.5  push镜像	54
4.5.6  根据Dockerfile编译镜像	55
4.5.7  删除镜像	56
4.6  docker run命令	56
4.6.1  docker run的语法格式	56
4.6.2  前后台运行	57
4.6.3  容器的标识	57
4.6.4  PID设置	58
4.6.5  UTS(--uts)设置	58
4.6.6  IPC(--ipc)设置	59
4.6.7  网络设置	59
4.6.8  重启策略（--restart）	60
4.6.9  Clean up (--rm)	61
4.6.10  CGroups控制	61
4.6.11  特权模式和Capabilities	61
4.6.12  日志驱动（--log-driver）	62
4.6.13  覆盖image的默认参数	62
4.7  习题	63
第5章　容器的网络	64
5.1  容器自带网络	64
5.2  网络详情	65
5.3  用户自定义网络	67
5.3.1  桥接网络	67
5.3.2  Overlay网络	68
5.4  习题	71
第6章　容器的数据	72
6.1  数据卷	72
6.1.1  创建一个数据卷	72
6.1.2  映射一个外部卷	73
6.2  使用数据型容器	73
6.3  备份、还原和迁移数据卷	73
6.4  容器和代码进行关联	74
6.5  习题	74
第7章　镜像仓库	75
7.1  仓库相关的Docker命令	75
7.1.1  登录	75
7.1.2  查找	76
7.1.3  拉取	76
7.1.4  提交	76
7.2  习题	76
第3篇  Docker的高级使用
第8章　镜像和容器的存储结构	78
8.1  镜像、容器和存储驱动的关系	78
8.1.1  镜像和镜像层	78
8.1.2  镜像存储方式	80
8.1.3  一个迁移例子	81
8.1.4  容器和容器层	82
8.1.5  写时复制策略	83
8.1.6  使用共享技术减小镜像体积	83
8.1.7  使用复制技术加快容器启动时间	86
8.1.8  数据卷和存储驱动	90
8.2  如何选择存储驱动	90
8.2.1  存储设备和存储驱动	92
8.2.2  如何存储驱动	92
8.3  AUFS存储驱动	94
8.3.1  AUFS中的镜像	94
8.3.2  AUFS中的容器读写	95
8.3.3  在AUFS中删除文件	95
8.3.4  如何配置AUFS	96
8.3.5  镜像的存储方式	96
8.3.6  容器的存储方式	97
8.3.7  AUFS的性能	99
8.4  Devicemapper存储驱动	99
8.4.1  Devicemapper中的镜像	100
8.4.2  Devicemapper中的读操作	101
8.4.3  Devicemapper中的写操作	102
8.4.4  如何配置Devicemapper	103
8.4.5  在生产环境中配置direct-lvm模式	104
8.4.6  Devicemapper的存储方式	107
8.4.7  动态扩容loop-lvm模式下的thin pool	108
8.4.8  动态扩容direct-lvm模式下的thin pool	110
8.4.9  Devicemapper的性能	110
8.5  Btrfs存储驱动	111
8.5.1  Btrfs中的镜像	112
8.5.2  Btrfs的存储方式	114
8.5.3  Btrfs中的读写	114
8.5.4  如何配置Btrfs	115
8.5.5  Btrfs的性能	116
8.6  ZFS存储驱动	117
8.6.1  ZFS中的镜像	117
8.6.2  ZFS中的读写	118
8.6.3  如何配置ZFS	119
8.6.4  ZFS的性能	121
8.7  Overlay存储驱动	122
8.7.1  Overlay中的镜像	122
8.7.2  Overlay2中的镜像	125
8.7.3  Overlay中的读写	127
8.7.4  如何配置Overlay/Overlay2	127
8.7.5  Overlay的性能	128
8.8  习题	129
第9章　定制Docker Daemon	130
9.1  修改Docker Daemon的三种方式	130
9.1.1  直接启动Docker Daemon	132
9.1.2  修改Docker Daemon启动项	132
9.1.3  自定义Docker Daemon配置文件	135
9.2  仓库相关配置	137
9.2.1  --disable-legacy-registry选项	137
9.2.2  --registry-mirror选项	138
9.2.3  --insecure-registry选项	139
9.3  安全相关配置	139
9.3.1  -p, --pidfile选项	139
9.3.2  -H, --host选项	139
9.3.3  --tls, --tlscacert, --tlscert, --tlskey, --tlsverify选项	141
9.4  日志相关	145
9.4.1  -D，--debug选项	145
9.4.2  --log-level选项	145
9.4.3  --log-driver和--log-opt选项	146
9.5  存储相关配置	148
9.5.1  -g, --graph选项	148
9.5.2  --storage-driver选项	148
9.5.3  --storage-opt选项	149
9.6  网桥相关配置	154
9.6.1  --bip选项	154
9.6.2  --fixed-cidr，--fixed- cidr-v6选项	154
9.6.3  --mtu选项	155
9.6.4  -b, --bridge选项	155
9.7  容器与外部通信	156
9.7.1  --ip-forward选项	156
9.7.2  --iptables选项	156
9.7.3  --ip, --ipv6选项	156
9.8  其他网络配置	157
9.8.1  --default-gateway、--default-gateway-v6选项	157
9.8.2  --dns，--dns-opt，--dns-search选项	158
9.9  execdriver配置	158
9.9.1  --exec-opt选项	158
9.9.2  --exec-root选项	159
9.10  其他配置	159
9.11  习题	159
第10章　如何编写Dockerfile	160
10.1  本地编译镜像	160
10.2  dockerignore文件	162
10.3  Dockerfile格式	163
10.4  Dockerfile指令详解	163
10.4.1  FROM指令	163
10.4.2  MAINTAINER指令	164
10.4.3  RUN指令	164
10.4.4  CMD指令	164
10.4.5  LABEL指令	165
10.4.6  EXPOSE指令	166
10.4.7  ENV指令	166
10.4.8  ADD指令	168
10.4.9  COPY指令	169
10.4.10  ENTRYPOINT指令	170
10.4.11  VOLUME指令	173
10.4.12  USER指令	174
10.4.13  WORKDIR指令	174
10.4.14  ARG指令	175
10.4.15  ONBUILD指令	177
10.4.16  STOPSIGNAL指令	178
10.5  CMD、ENTRYPOINT和RUN的区别	178
10.6  习题	179
第11章　Dockerfile最佳实践	181
11.1  基本原则	181
11.2  Dockerfile指令最佳实践	183
11.2.1  FROM指令最佳实践	183
11.2.2  RUN指令最佳实践	183
11.2.3  CMD指令最佳实践	185
11.2.4  EXPOSE指令最佳实践	186
11.2.5  ENV指令最佳实践	188
11.2.6  ADD和COPY指令最佳实践	189
11.2.7  ENTRYPOINT指令最佳实践	191
11.2.8  VOLUME指令最佳实践	194
11.2.9  UESR指令最佳实践	196
11.2.10  使用gosu工具	196
11.2.11  WORKDIR指令最佳实践	198
11.2.12  ONBUILD指令最佳实践	199
11.3  如何减小镜像体积	199
11.4  一些官方镜像的Dockerfile	205
11.4.1  Golang镜像	205
11.4.2  Perl镜像	208
11.4.3  Hy镜像	209
11.4.4  Rails镜像	210
11.5  习题	211
第12章　使用容器提供服务	212
12.1  使用容器提供数据库服务	212
12.1.1  使用容器提供MySQL	212
12.1.2  使用容器提供MongoDB	215
12.2  如何使用容器提供Web服务	217
12.2.1  使用容器提供Apache HTTP服务	217
12.2.2  使用容器提供Django服务	218
12.2.3  使用容器提供Gitlab服务	219
12.3  如何使用容器提供编程环境	220
12.3.1  使用容器提供Java环境	221
12.3.2  使用容器提供Golang环境	222
12.4  习题	225
第13章　建立私有镜像仓库	226
13.1  镜像仓库配置详解	227
13.2  version选项	231
13.3  log选项	231
13.4  hooks选项	231
13.5  storage选项	232
13.5.1  filesystem选项	233
13.5.2  azure选项	234
13.5.3  gcs选项	234
13.5.4  s3选项	234
13.5.5  swift选项	235
13.5.6  oss选项	236
13.5.7  delete选项	237
13.5.8  cache选项	237
13.5.9  maintenance选项	237
13.5.10  redirect选项	238
13.6  auth选项	238
13.6.1  silly选项	239
13.6.2  token选项	239
13.6.3  htpasswd选项	239
13.7  middleware选项	240
13.8  reporting选项	241
13.8.1  bugsnag选项	241
13.8.2  newrelic选项	241
13.9  http选项	242
13.9.1  tls选项	242
13.9.2  debug选项	243
13.9.3  headers选项	243
13.10  notifications选项	243
13.11  redis选项	244
13.12  health选项	245
13.12.1  storagedriver选项	245
13.12.2  file选项	246
13.12.3  http选项	246
13.12.4  tcp选项	246
13.13  proxy选项	247
13.14  镜像仓库配置实例	247
13.14.1  启动容器数据持久化	247
13.14.2  使用文件系统保存镜像	248
13.14.3  使用对象存储保存镜像	248
13.14.4  通过中间件使用CDN服务	249
13.15  习题	250
第4篇  Docker常见问题
第14章　Docker常见问题	252
14.1  Docker基础问题	252
14.1.1  什么是虚拟化技术	252
14.1.2  虚拟化有哪些分类	252
14.1.3  Docker目前支持哪些操作系统	253
14.1.4  哪种系统最适合运行Docker	253
14.1.5  Docker有什么好处	253
14.1.6  容器化技术是什么时候出现的	253
14.1.7  Docker和虚拟机有什么区别	253
14.1.8  使用Docker容器需要什么基础知识	254
14.1.9  如何学习Docker	254
14.2  Docker高级问题	255
14.2.1  Docker是否安全	255
14.2.2  如何修改已经运行的容器	255
14.2.3  容器有哪些网络模式	255
14.2.4  容器如何进行持久化	256
14.2.5  为什么进入容器，但退出后容器就停止了	256
14.2.6  容器停止了，如何分析原因	256
14.2.7  Link容器是什么意思	256
14.2.8  容器环境变量有什么用途	256
14.2.9  容器中CPU、磁盘IO、网络损耗大吗	257
14.3  镜像相关	257
14.3.1  什么是Dockerfile	257
14.3.2  Dockerfile书写的最佳实践是什么	257
14.3.3  容器运行中Entrypoint和CMD的区别	258
14.3.4  Docker中容器镜像的区别	258
14.3.5  Docker的镜像仓库有哪些	259
14.3.6  如何拥有私有仓库	259
14.4  Docker三剑客	260
14.4.1  什么是Docker Machine	260
14.4.2  什么是Docker Compose	260
14.4.3  什么是Docker Swarm	260
14.5  习题	260
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker容器实战：原理、架构与应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker基础与实战
第1章　Docker　　1
1.1　虚拟机与Docker　　3
1.1.1　虚拟机　　4
1.1.2　Docker　　5
1.1.3　Linux容器　　6
1.2　Docker镜像与容器　　8
第2章　安装Docker　　11
2.1　Linux　　11
2.1.1　自动安装脚本　　11
2.1.2　Ubuntu　　11
2.1.3　RedHat Enterprise Linux、CentOS　　12
2.1.4　使用最新二进制文件　　12
2.2　Mac OS X　　13
2.3　Windows　　16
第3章　使用Docker　　23
3.1　使用search命令搜索镜像　　23
3.2　使用pull命令下载镜像　　25
3.3　使用images命令列出镜像目录　　25
3.4　使用run命令创建容器　　25
3.5　使用ps命令查看容器列表　　26
3.6　使用start命令启动容器　　26
3.7　使用restart命令重启容器　　27
3.8　使用attach命令连接容器　　27
3.9　使用exec命令从外部运行容器内的命令　　27
3.10　使用stop命令终止容器　　28
3.11　使用rm命令删除容器　　28
3.12　使用rmi命令删除镜像　　29
第4章　创建Docker镜像　　31
4.1　熟悉Bash　　31
4.2　编写Dockerfile　　36
4.3　使用build命令创建镜像　　37
第5章　查看Docker　　39
5.1　使用history命令查看镜像历史　　39
5.2　使用cp命令复制文件　　40
5.3　使用commit命令从容器的修改中创建镜像　　40
5.4　使用diff命令检查容器文件的修改　　40
5.5　使用inspect命令查看详细信息　　41
第6章　灵活使用Docker　　43
6.1　搭建Docker私有仓库　　43
6.1.1　存储镜像数据到本地　　43
6.1.2　使用push命令上传镜像　　44
6.1.3　存储镜像数据到Amazon S3　　45
6.1.4　使用默认认证　　46
6.2　连接Docker的容器　　52
6.3　连接到其他服务器的Docker 容器　　53
6.4　使用Docker数据卷　　56
6.5　使用Docker数据卷容器　　59
6.6　创建Docker基础镜像　　60
6.6.1　创建Ubuntu基础镜像　　60
6.6.2　创建CentOS基础镜像　　61
6.6.3　创建空基础镜像　　62
6.7　在Docker内运行Docker　　64
第7章　详细了解Dockerfile　　67
7.1　.dockerignore　　68
7.2　FROM　　68
7.3　MAINTAINER　　69
7.4　RUN　　69
7.5　CMD　　70
7.6　ENTRYPOINT　　71
7.7　EXPOSE　　73
7.8　ENV　　73
7.9　ADD　　74
7.10　COPY　　76
7.11　VOLUME　　77
7.12　USER　　77
7.13　WORKDIR　　78
7.14　ONBUILD　　79
第8章　使用Docker部署应用程序　　81
8.1　向一台服务器部署应用程序　　81
8.1.1　在开发者PC安装Git并创建仓库　　82
8.1.2　在开发者PC中使用Node.js编写Web服务器　　83
8.1.3　在开发者PC中编写Dockerfile文件　　84
8.1.4　在开发者PC中生成SSH 密钥　　85
8.1.5　在服务器端安装Git并创建仓库　　86
8.1.6　在服务器中安装Docker　　87
8.1.7　在服务器中安装SSH密钥　　88
8.1.8　在服务器中安装Git Hook　　89
8.1.9　在开发者PC中推送源代码　　90
8.2　向多台服务器部署应用程序　　91
8.2.1　在开发者PC安装Git并创建仓库　　92
8.2.2　在开发者PC中使用Node.js编写Web 服务器　　93
8.2.3　在开发者PC中编写Dockerfile文件　　94
8.2.4　在开发者PC中生成SSH密钥　　95
8.2.5　在部署服务器安装Git并创建仓库　　96
8.2.6　在部署服务器中生成SSH密钥　　97
8.2.7　在部署服务器中安装Docker　　98
8.2.8　在部署服务器中安装Docker注册服务器　　99
8.2.9　在部署服务器中安装SSH密钥　　100
8.2.10　在部署服务器中安装Git Hook　　101
8.2.11　在应用程序服务器中安装Docker　　103
8.2.12　在应用程序服务器中安装SSH 密钥　　104
8.2.13　在开发者PC中推送源代码　　105
第9章　Docker监控　　107
9.1　编写监控服务器Dockerfile　　108
9.2　编写应用程序服务器Dockerfile　　111
9.3　在Web 浏览器中查看图表　　114
第10章　在Amazon Web Services中使用Docker　　117
10.1　在Amazon EC2中使用Docker　　117
10.2　在AWS Elastic Beanstalk中使用Docker　　119
10.2.1　在AWS控制台部署Docker应用程序　　119
10.2.2　使用Docker Hub公开仓库镜像　　129
10.2.3　使用Docker Hub私有仓库的镜像　　131
10.2.4　使用Git部署Elastic Beanstalk Docker应用程序　　139
第11章　在Google Cloud Platform中使用Docker　　145
11.1　安装Goolge Cloud SDK　　145
11.2　在Compute Engine中使用Docker　　147
11.3　在Container Engine中使用Docker　　148
第12章　使用Docker Hub　　151
12.1　加入Docker Hub　　151
12.2　使用push命令上传镜像　　153
12.3　创建Docker Hub私有仓库　　155
12.4　使用Docker Hub Automated Build　　157
第13章　使用Docker Remote API　　167
13.1　使用Docker Remote API Python库　　169
13.1.1　创建并启动容器　　169
13.1.2　创建镜像　　173
13.1.3　显示容器列表　　175
13.1.4　显示镜像列表　　176
13.1.5　其他示例与函数　　176
13.2　使用Docker Remote API Python库进行HTTPS通信　　187
13.2.1　创建证书　　187
13.2.2　使用Python库　　191
第14章　使用CoreOS　　193
14.1　在VirtualBox中安装CoreOS　　196
使用systemd运行服务　　205
14.2　使用Vagrant安装CoreOS　　206
14.3　使用etcd　　211
14.3.1　创建etcd键与目录　　211
14.3.2　输出etcd键与目录列表　　212
14.3.3　设置自动删除etcd键与目录　　212
14.3.4　监视etcd键　　213
14.3.5　etcd其他命令　　214
14.4　使用fleet　　214
14.4.1　输出fleet机器列表　　215
14.4.2　使用fleet运行Unit　　215
14.4.3　输出fleet Unit列表　　217
14.4.4　查看fleet Unit状态　　217
14.4.5　测试fleet的自动恢复功能　　218
14.4.6　使用fleet专用选项　　219
14.4.7　灵活使用fleet Unit文件模板　　222
14.4.8　灵活使用fleet sidekick模型　　224
14.4.9　fleet其他命令　　227
14.5　在云服务中使用CoreOS　　227
14.5.1　在Amazon EC2中使用CoreOS　　227
14.5.2　在Google Compute Engine中使用CoreOS　　229
第15章　使用Docker搭建WordPress 博客　　231
15.1　编写WordPress Dockerfile文件　　232
15.2　编写MySQL数据库Dockerfile文件　　233
15.3　创建WordPress与数据库容器　　236
第16章　使用Docker构建Ruby on Rails应用　　237
16.1　安装Ruby与Rails　　238
16.2　编写Rails Dockerfile　　240
16.3　编写PostgreSQL数据库Dockerfile 文件　　245
16.4　创建Rails与数据库容器　　247
第17章　使用Docker构建Django应用　　249
17.1　安装Django　　250
17.2　编写Django Dockerfile文件　　253
17.3　编写Oracle数据库Dockerfile文件　　258
17.4　创建Django与数据库容器　　261
第18章　Docker应用案例　　263
18.1　与负载平衡相关的自动伸缩　　263
18.2　整合开发、测试、运营　　264
18.3　轻松迁移服务　　265
18.4　用于测试　　267
第19章　Docker命令与选项列表　　269
19.1　attach　　270
19.2　build　　271
19.3　Commit　　273
19.4　cp　　273
19.5　create　　274
19.6　diff　　277
19.7　events　　277
19.8　exec　　278
19.9　export　　280
19.10　history　　280
19.11　images　　281
19.12　import　　281
19.13　info　　282
19.14　inspect　　283
19.15　kill　　284
19.16　load　　284
19.17　login　　285
19.18　logout　　286
19.19　logs　　286
19.20　port　　287
19.21　pause　　287
19.22　ps　　287
19.23　pull　　288
19.24　push　　289
19.25　restart　　289
19.26　rm　　289
19.27　rmi　　290
19.28　run　　291
19.29　save　　296
19.30　search　　297
19.31　start　　297
19.32　stop　　298
19.33　tag　　298
19.34　top　　299
19.35　unpause　　299
19.36　version　　300
19.37　wait　　300
附录　编译Docker　　301
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker基础与实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker全攻略
第一篇 Docker简介
第1章 Docker的前世今生	2
1.1 什么是LXC	2
1.2 Docker为什么选择了AUFS	2
1.3 Docker是如何产生的	3
第2章 Docker现状	5
2.1 Docker应用范围	5
2.2 Docker的优缺点	6
第3章 Docker将如何改变未来	8
第二篇 Docker基础
第4章 如何安装Docker	12
4.1 安装Docker前需要知道的事	12
4.2 Linux平台安装Docker	13
4.3 MAC/OS平台安装Docker	15
4.4 Windows平台如何支持Docker	20
4.5 在其他平台中安装Docker	23
第5章 Docker基本命令	28
5.1 Docker操作命令	28
5.2 Docker网络命令	83
5.3 Docker 安全命令	86
5.4 Docker 资源命令	87
5.5 Docker RestFul命令	95
5.6 Docker组件命令	190
第6章 Docker命令剖析	205
6.1 Docker操作命令	216
6.2 Docker网络命令	389
6.3 Docker安全命令	416
6.4 Docker资源命令	422
第7章 Dockerfile介绍	468
7.1 Dockerfile有什么用	468
7.2 如何编写Dockerfile	470
第8章 Dockerfile最佳实践	481
第9章 Docker部署案例	489
第三篇 Docker进阶
第10章 Docker运行剖析	494
10.1 Docker的生命周期	494
10.2 Docker Daemon	496
10.3 Docker CLI	498
第11章 Docker内核讲解	500
11.1 Docker背后的Namespace	500
11.2 Docker的文件系统	505
11.3 Docker的image管理	508
第12章 Docker资源调度	513
12.1 Docker如何管理资源	513
12.2 Docker资源管理器	516
第四篇 Docker生态圈
第13章 Docker的云生态环境	520
13.1 Docker的开发语言	520
13.2 支持Docker的开源组件	525
13.3 CoreOS、Vagrant和Amazon如何支持Docker	526
第五篇 Docker案例
第14章 基于Amazon的Docker部署案例	530
第15章 基于CoreOS的Docker部署案例	532
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker全攻略
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>后现代与大众文化
插图目录前言导论第一部分 处于矛盾中的现代主义  第一章 建筑的现代主义：勒·柯布西耶  第二章 文学的现代主义  第三章 现代主义/流行文学  第四章 法兰克福学派/瓦尔特·本雅明  第五章 正统观念的繁荣  第六章 起源的神话：20世纪70年代的影视理论与文学史第二部分 现代主义与后现代主义  第七章 建筑的后现代主义：《向拉斯维加斯学习》  第八章 从拉斯维加斯到悉尼  第九章 我们生活在一个后现代的年代吗?  第十章 描绘弗雷德里克·詹姆逊的宏大叙述  第十一章 从结构主义到后结构主义  第十二章 文化研究：从现代主义到后现代主义的过渡时期第三部分 狂欢理论  第十三章 巴赫金的狂欢理论  第十四章 颠倒世界的困境  第十五章 愚人：狂欢-戏剧-杂耍-电视  第十六章 愚人，恶作剧者，社会的观察者：侦探  第十七章 作为转变体裁的犯罪小说  第十八章 情节剧、闹剧和肥皂剧  第十九章 动作情节剧：《囚犯》，或称《监狱H分区》(与安·科索伊斯合著)总结 狂欢和当代流行文化
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>后现代与大众文化
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Kubernetes权威指南
第1章  Kubernetes入门	1
1.1  Kubernetes是什么	1
1.2  为什么要用Kubernetes	4
1.3  从一个简单的例子开始	5
1.3.1  环境准备	6
1.3.2  启动MySQL服务	6
1.3.3  启动Tomcat应用	9
1.3.4  通过浏览器访问网页	10
1.4  Kubernetes基本概念和术语	12
1.4.1  Master	12
1.4.2  Node	12
1.4.3  Pod	15
1.4.4  Label（标签）	18
1.4.5  Replication Controller	22
1.4.6  Deployment	26
1.4.7  Horizontal Pod Autoscaler	28
1.4.8  StatefulSet	29
1.4.9  Service（服务）	30
1.4.10  Volume（存储卷）	37
1.4.11  Persistent Volume	41
1.4.12  Namespace（命名空间）	42
1.4.13  Annotation（注解）	43
1.4.14  小结	44
第2章  Kubernetes实践指南	45
2.1  Kubernetes安装与配置	45
2.1.1  系统要求	45
2.1.2  使用kubeadm工具快速安装Kubernetes集群	46
2.1.3  以二进制文件方式安装Kubernetes集群	51
2.1.4  Kubernetes集群的安全设置	59
2.1.5  Kubernetes集群的网络配置	64
2.1.6  内网中的Kubernetes相关配置	64
2.1.7  Kubernetes的版本升级	65
2.1.8  Kubernetes核心服务配置详解	66
2.2  kubectl命令行工具用法详解	86
2.2.1  kubectl用法概述	86
2.2.2  kubectl子命令详解	88
2.2.3  kubectl参数列表	90
2.2.4  kubectl输出格式	90
2.2.5  kubectl操作示例	92
2.3  深入掌握Pod	93
2.3.1  Pod定义详解	93
2.3.2  Pod的基本用法	98
2.3.3  静态Pod	103
2.3.4  Pod容器共享Volume	104
2.3.5  Pod的配置管理	106
2.3.6  在容器内获取Pod信息（Downward API）	119
2.3.7  Pod生命周期和重启策略	124
2.3.8  Pod健康检查	125
2.3.9  玩转Pod调度	127
2.3.10  Init Container（初始化容器）	149
2.3.11  Pod的升级和回滚	152
2.3.12  Pod的扩容和缩容	166
2.3.13  使用StatefulSet搭建MongoDB集群	171
2.4  深入掌握Service	180
2.4.1  Service定义详解	181
2.4.2  Service基本用法	182
2.4.3  Headless Service	187
2.4.4  集群外部访问Pod或Service	192
2.4.5  DNS服务搭建指南	196
2.4.6  自定义DNS和上游DNS服务器	204
2.4.7  Ingress：HTTP 7层路由机制	208
第3章  Kubernetes核心原理	226
3.1  Kubernetes API Server 原理分析	226
3.1.1  Kubernetes API Server概述	226
3.1.2  独特的Kubernetes Proxy API接口	229
3.1.3  集群功能模块之间的通信	230
3.2  Controller Manager 原理分析	231
3.2.1  Replication Controller	232
3.2.2  Node Controller	234
3.2.3  ResourceQuota Controller	235
3.2.4  Namespace Controller	237
3.2.5  Service Controller与Endpoint Controller	237
3.3  Scheduler原理分析	238
3.4  kubelet运行机制分析	242
3.4.1  节点管理	242
3.4.2  Pod管理	243
3.4.3  容器健康检查	244
3.4.4  cAdvisor资源监控	245
3.5  kube-proxy 运行机制分析	247
3.6  深入分析集群安全机制	251
3.6.1  API Server认证管理（Authentication）	251
3.6.2  API Server授权管理（Authorization）	253
3.6.3  Admission Control（准入控制）	272
3.6.4  Service Account	274
3.6.5  Secret私密凭据	279
3.7  网络原理	282
3.7.1  Kubernetes网络模型	282
3.7.2  Docker的网络基础	284
3.7.3  Docker的网络实现	296
3.7.4  Kubernetes的网络实现	304
3.7.5  Pod和Service网络实战	308
3.7.6  CNI网络模型	321
3.7.7  Kubernetes网络策略	331
3.7.8  开源的网络组件	333
3.8  共享存储原理	363
3.8.1  共享存储机制概述	363
3.8.2  PV详解	364
3.8.3  PVC详解	368
3.8.4  PV和PVC的生命周期	370
3.8.5  StorageClass详解	373
3.8.6  动态存储管理实战：GlusterFS	376
第4章  Kubernetes开发指南	388
4.1  REST简述	388
4.2  Kubernetes API详解	390
4.2.1  Kubernetes API概述	390
4.2.2  API版本	395
4.2.3  API Groups（API组）	395
4.2.4  API方法说明	397
4.2.5  API响应说明	398
4.3  使用Java程序访问Kubernetes API	400
4.3.1  Jersey	401
4.3.2  Fabric8	412
4.3.3  使用说明	413
第5章  Kubernetes运维指南	434
5.1  Kubernetes集群管理指南	434
5.1.1  Node的管理	434
5.1.2  更新资源对象的Label	436
5.1.3  Namespace：集群环境共享与隔离	437
5.1.4  Kubernetes资源管理	441
5.1.5  资源紧缺时的Pod驱逐机制	475
5.1.6  Pod Disruption Budget（主动驱逐保护）	483
5.1.7  Kubernetes集群的高可用部署方案	485
5.1.8  Kubernetes集群监控	496
5.1.9  集群统一日志管理	513
5.1.10  Kubernetes审计日志（Audit Log）	522
5.1.11  使用Web UI（Dashboard）管理集群	523
5.1.12  Helm：Kubernetes应用包管理工具	527
5.2  Trouble Shooting指导	538
5.2.1  查看系统Event事件	538
5.2.2  查看容器日志	540
5.2.3  查看Kubernetes服务日志	541
5.2.4  常见问题	542
5.2.5  寻求帮助	546
5.3  Kubernetes开发中的新功能	546
5.3.1  Pod Preset（运行时参数注入策略）	546
5.3.2  Cluster Federation（集群联邦）	553
5.3.3  容器运行时接口（Container Runtime Interface-CRI）	557
5.3.4  对GPU的支持	561
5.3.5  Kubernetes的演进路线（Roadmap）和开发模式	565
第6章  Kubernetes源码导读	568
6.1  Kubernetes源码结构和编译步骤	568
6.2  kube-apiserver进程源码分析	572
6.2.1  进程启动过程	572
6.2.2  关键代码分析	574
6.2.3  设计总结	589
6.3  kube-controller-manager进程源码分析	592
6.3.1  进程启动过程	592
6.3.2  关键代码分析	595
6.3.3  设计总结	603
6.4  kube-scheduler进程源码分析	605
6.4.1  进程启动过程	605
6.4.2  关键代码分析	610
6.4.3  设计总结	617
6.5  kubelet进程源码分析	619
6.5.1  进程启动过程	619
6.5.2  关键代码分析	624
6.5.3  设计总结	647
6.6  kube-proxy进程源码分析	648
6.6.1  进程启动过程	648
6.6.2  关键代码分析	650
6.6.3  设计总结	665
6.7  kubectl进程源码分析	666
6.7.1  kubectl create命令	667
6.7.2  rolling-update命令	671
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Kubernetes权威指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker技术入门与实战 第3版
第3版前言
第一部分　基础入门
第1章　初识Docker与容器 3
1.1　什么是Docker 3
1.2　为什么要使用Docker 6
1.3　Docker与虚拟化 8
1.4　本章小结 9
第2章　核心概念与安装配置 10
2.1　核心概念 10
2.2　安装Docker引擎 11
2.2.1　Ubuntu 环境下安装 Docker 12
2.2.2　CentOS 环境下安装 Docker 14
2.2.3　通过脚本安装 15
2.2.4　macOS环境下安装 Docker 15
2.2.5　Windows环境下安装Docker 23
2.3　配置 Docker 服务 26
2.4　推荐实践环境 27
2.5　本章小结 27
第3章　使用Docker镜像 28
3.1　获取镜像 28
3.2　查看镜像信息 30
3.3　搜寻镜像 32
3.4　删除和清理镜像 33
3.5　创建镜像 35
3.6　存出和载入镜像 36
3.7　上传镜像 37
3.8　本章小结 38
第4章　操作Docker容器 39
4.1　创建容器 39
4.2　停止容器 44
4.3　进入容器 46
4.4　删除容器 47
4.5　导入和导出容器 48
4.6　查看容器 49
4.7　其他容器命令 50
4.8　本章小结 52
第5章　访问 Docker 仓库 53
5.1　Docker Hub 公共镜像市场 53
5.2　第三方镜像市场 55
5.3　搭建本地私有仓库 56
5.4　本章小结 58
第6章　Docker数据管理 59
6.1　数据卷 59
6.2　数据卷容器 60
6.3　利用数据卷容器来迁移数据 62
6.4　本章小结 62
第7章　端口映射与容器互联 63
7.1　端口映射实现容器访问 63
7.2　互联机制实现便捷互访 64
7.3　本章小结 67
第8章　使用Dockerfile创建镜像 68
8.1　基本结构 68
8.2　指令说明 70
8.2.1　配置指令 71
8.2.2　操作指令 74
8.3　创建镜像 75
8.3.1　命令选项 76
8.3.2　选择父镜像 77
8.3.3　使用.dockerignore文件 77
8.3.4　多步骤创建 78
8.4　最佳实践 79
8.5　本章小结 80
第二部分　实战案例
第9章　操作系统 83
9.1　BusyBox 83
9.2　Alpine 85
9.3　Debian/Ubuntu 86
9.4　CentOS/Fedora 88
9.5　本章小结 89
第10章　为镜像添加SSH服务 90
10.1　基于commit命令创建 90
10.2　使用Dockerfile创建 93
10.3　本章小结 95
第11章　Web服务与应用 96
11.1　Apache 96
11.2　Nginx 100
11.3　Tomcat 104
11.4　Jetty 108
11.5　LAMP 109
11.6　持续开发与管理 111
11.7　本章小结 114
第12章　数据库应用 115
12.1　MySQL 115
12.2　Oracle Database XE 117
12.3　MongoDB 118
12.4　Redis 124
12.5　Cassandra 126
12.6　本章小结 129
第13章　分布式处理与大数据平台 130
13.1　Hadoop 130
13.2　Spark 133
13.3　Storm 136
13.4　Elasticsearch 140
13.5　本章小结 141
第14章　编程开发 142
14.1　C/C++ 142
14.2　Java 146
14.3　Python 149
14.3.1　使用Python官方镜像 150
14.3.2　使用PyPy 151
14.3.3　使用 Flask 151
14.3.4　相关资源 154
14.4　JavaScript 154
14.4.1　使用Node.js 154
14.4.2　相关资源 158
14.5　Go 158
14.6　本章小结 161
第15章　容器与云服务 162
15.1　公有云容器服务 162
15.1.1　AWS 162
15.1.2　Google Cloud Platform 163
15.1.3　Azure 164
15.1.4　腾讯云 165
15.1.5　阿里云 165
15.1.6　华为云 166
15.1.7　UCloud 167
15.2　容器云服务 168
15.3　阿里云容器服务 172
15.4　时速云介绍 174
15.5　本章小结 175
第16章　容器实战思考 176
16.1　Docker 为什么会成功 176
16.2　研发人员该如何看待容器 177
16.3　容器化开发模式 178
16.4　容器与生产环境 180
16.5　本章小结 182
第三部分　进阶技能
第17章　核心实现技术 185
17.1　基本架构 185
17.2　命名空间 187
17.3　控制组 191
17.4　联合文件系统 193
17.5　Linux网络虚拟化 195
17.6　本章小结 197
第18章　配置私有仓库 199
18.1　安装Docker Registry 199
18.2　配置TLS证书 201
18.3　管理访问权限 202
18.4　配置Registry 205
18.5　批量管理镜像 211
18.6　使用通知系统 214
18.7　本章小结 217
第19章　安全防护与配置 218
19.1　命名空间隔离的安全 218
19.2　控制组资源控制的安全 219
19.3　内核能力机制 219
19.4　Docker服务端的防护 221
19.5　更多安全特性的使用 221
19.6　使用第三方检测工具 222
19.6.1　Docker Bench 222
19.6.2　clair 223
19.7　本章小结 224
第20章　高级网络功能 225
20.1　启动与配置参数 225
20.2　配置容器DNS和主机名 227
20.3　容器访问控制 228
20.4　映射容器端口到宿主主机的实现 229
20.5　配置容器网桥 231
20.6　自定义网桥 232
20.7　使用OpenvSwitch网桥 233
20.8　创建一个点到点连接 235
20.9　本章小结 236
第21章　libnetwork插件化网络功能 237
21.1　容器网络模型 237
21.2　Docker网络命令 238
21.3　构建跨主机容器网络 241
21.4　本章小结 243
第四部分　开源项目
第22章　Etcd—高可用的键值数据库 247
22.1　Etcd简介 247
22.2　安装和使用Etcd 248
22.3　使用客户端命令 253
22.3.1　数据类操作 255
22.3.2　非数据类操作 258
22.4　Etcd集群管理 260
22.4.1　构建集群 260
22.4.2　集群参数配置 263
22.5　本章小结 264
第23章　Docker三剑客之Machine 265
23.1　Machine简介 265
23.2　安装Machine 265
23.3　使用Machine 266
23.4　Machine命令 268
23.5　本章小结 272
第24章　Docker三剑客之Compose 273
24.1　Compose简介 273
24.2　安装与卸载 274
24.3　Compose模板文件 277
24.4　Compose命令说明 292
24.5　Compose环境变量 299
24.6　Compose应用案例一：Web负载均衡 300
24.7　Compose应用案例二：大数据Spark集群 304
24.8　本章小结 309
第25章　Docker三剑客之Swarm 310
25.1　Swarm简介 310
25.2　基本概念 311
25.3　使用Swarm 313
25.4　使用服务命令 316
25.5　本章小结 319
第26章　Mesos—优秀的集群资源调度平台 321
26.1　简介 321
26.2　Mesos安装与使用 322
26.3　原理与架构 330
26.3.1　架构 330
26.3.2　基本单元 331
26.3.3　调度 331
26.3.4　高可用性 332
26.4　Mesos配置解析 333
26.4.1　通用项 333
26.4.2　master专属配置项 333
26.4.3　slave专属配置项 335
26.5　日志与监控 338
26.6　常见应用框架 340
26.7　本章小结 341
第27章　Kubernetes—生产级容器集群平台 343
27.1　简介 343
27.2　核心概念 345
27.3　资源抽象对象 348
27.3.1　容器组 348
27.3.2　服务 349
27.3.3　存储卷 350
27.4　控制器抽象对象 351
27.5　其他抽象对象 353
27.6　快速体验 355
27.7　重要组件 359
27.7.1　Etcd 360
27.7.2　kube-apiserver 360
27.7.3　kube-scheduler 361
27.7.4　kube-controller-manager 362
27.7.5　kubelet 363
27.7.6　kube-proxy 364
27.8　使用kubectl 365
27.8.1　获取kubectl 365
27.8.2　命令格式 366
27.8.3　全局参数 367
27.8.4　通用子命令 369
27.9　网络设计 372
27.10　本章小结 374
第28章　其他相关项目 375
28.1　持续集成 375
28.2　容器管理 377
28.2.1　Portainer 377
28.2.2　Panamax 378
28.2.3　Seagull 378
28.3　编程开发 380
28.4　网络支持 381
28.4.1　Pipework 381
28.4.2　Flannel项目 382
28.4.3　Weave Net项目 382
28.4.4　Calico项目 383
28.5　日志处理 383
28.6　服务代理 385
28.7　标准与规范 389
28.8　其他项目 392
28.9　本章小结 396
附录
附录A　常见问题总结 398
附录B　Docker命令查询 404
附录C　参考资源链接 411
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker技术入门与实战 第3版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务架构实战
第1章 微服务架构设计 1
1.1 直面微服务架构 1
1.1.1 分布式系统与微服务架构 1
1.1.2 微服务架构的优势与挑战 3
1.1.3 实施微服务架构 5
1.2 服务建模方法 6
1.2.1 服务的模型 6
1.2.2 服务的边界 7
1.2.3 服务的数据 7
1.3 服务拆分与集成 8
1.3.1 服务拆分 8
1.3.2 服务集成 9
1.4 微服务架构的基础组件和关键要素 10
1.4.1 微服务架构的基础组件 11
1.4.2 微服务架构的关键元素 11
1.5 实现微服务架构 13
1.5.1 微服务架构技术体系 13
1.5.2 微服务架构实现技术选型 14
1.6 案例分析 17
1.7 全书架构 18
1.8 本章小结 19
第2章 使用Spring Boot构建服务 21
2.1 引入Spring Boot 21
2.2 基于Spring Boot的第一个服务 23
2.2.1 环境准备 23
2.2.2 实现RESTful服务 24
2.3 Spring Boot常见功能 28
2.3.1 集成Spring Data 28
2.3.2 集成消息中间件 37
2.3.3 系统监控 39
2.4 Spring Boot基本原理 44
2.5 本章小结 46
第3章 Spring Cloud Netflix Eureka与服务治理 47
3.1 服务治理解决方案 48
3.1.1 服务治理的需求和模型 48
3.1.2 服务治理的基本方案 49
3.2 构建Eureka服务 52
3.2.1 构建单个Eureka服务器 52
3.2.2 构建Eureka服务器集群 55
3.3 使用Eureka注册和发现服务 57
3.3.1 通过配置实现服务注册 58
3.3.2 获取服务注册信息 59
3.4 Eureka基本架构 61
3.4.1 Eureka服务注册和发现架构 61
3.4.2 Eureka高可用架构 64
3.4.3 Eureka区域亲和性 65
3.5 本章小结 66
第4章 Spring Cloud Netflix Ribbon与负载均衡 67
4.1 负载均衡 68
4.1.1 负载均衡的类型 68
4.1.2 负载均衡的算法 70
4.2 使用Ribbon实现客户端负载均衡 71
4.2.1 Spring Cloud Netflix Ribbon简介 71
4.2.2 使用DiscoveryClient查找服务 72
4.2.3 通过RestTemplate调用服务 74
4.3 Ribbon基本架构 78
4.3.1 Ribbon核心机制 79
4.3.2 Ribbon负载均衡策略 81
4.3.3 @LoadBalanced注解与RestTemplate 82
4.3.4 @RibbonClient注解与自定义负载均衡策略 83
4.4 本章小结 85
第5章 Spring Cloud Netflix Hystrix与服务容错 86
5.1 服务消费者容错思想和模式 87
5.1.1 服务消费者容错的需求 87
5.1.2 服务隔离 88
5.1.3 服务熔断 90
5.1.4 服务回退 91
5.2 使用Hystrix实现服务容错 91
5.2.1 引入Hystrix 92
5.2.2 使用Hystrix实现服务隔离 93
5.2.3 使用Hystrix实现服务熔断 96
5.2.4 使用Hystrix实现服务回退 99
5.3 Hystrix基本原理 101
5.3.1 服务隔离 101
5.3.2 服务熔断 103
5.3.3 Hystrix配置项 105
5.4 本章小结 109
第6章 Spring Cloud Netflix Zuul与API网关 110
6.1 服务网关的设计理念 111
6.1.1 服务网关的作用 111
6.1.2 服务网关的结构和功能 112
6.2 使用Zuul构建服务网关 113
6.2.1 构建Zuul服务器 113
6.2.2 配置Zuul服务路由 115
6.3 Zuul基本架构 120
6.3.1 ZuulFilter组件架构 120
6.3.2 使用Zuul过滤器 124
6.4 本章小结 129
第7章 Spring Cloud Config与配置中心 130
7.1 分布式配置中心方案 131
7.1.1 分布式配置模型 131
7.1.2 配置中心实现工具 133
7.2 构建配置中心服务器 134
7.2.1 引入Spring Cloud Config 134
7.2.2 实现基于本地文件系统的配置方案 135
7.2.3 实现基于Git的配置方案 139
7.3 使用配置服务 140
7.3.1 访问配置项 141
7.3.2 配置数据安全性 145
7.4 Spring Cloud Config特性 148
7.4.1 Spring Cloud Config对比Zookeeper 148
7.4.2 Spring Cloud Config高可用 149
7.5 本章小结 150
第8章 Spring Cloud Stream与事件驱动 151
8.1 事件驱动架构与模型 152
8.1.1 基本事件驱动架构与实现机制 152
8.1.2 事件驱动与领域模型 155
8.2 引入Spring Cloud Stream 157
8.2.1 Spring Cloud Stream基本架构 157
8.2.2 Spring Cloud Stream与Spring Integration 159
8.2.3 Spring Cloud Stream与消息中间件 162
8.3 实现消息发布者 165
8.3.1 消息发送场景与实现流程 165
8.3.2 在服务中添加消息发布者 166
8.4 实现消息消费者 170
8.4.1 消息消费场景与实现流程 170
8.4.2 在服务中添加消息消费者 172
8.5 本章小结 177
第9章 Spring Cloud Security与服务安全 178
9.1 服务访问安全性与OAuth协议 178
9.1.1 微服务架构中的安全性设计 179
9.1.2 OAuth协议 180
9.2 构建OAuth认证服务器 184
9.2.1 引入Spring Cloud Security 185
9.2.2 初始化用户与客户端 186
9.2.3 生成Token 191
9.3 使用OAuth保护服务访问 195
9.3.1 集成OAuth认证服务 195
9.3.2 创建服务访问策略 196
9.3.3 使用OAuth2RestTemplate传播Token 201
9.4 本章小结 206
第10章 Spring Cloud Sleuth与服务监控 207
10.1 服务监控与Spring Cloud Sleuth 207
10.1.1 服务监控基本原理 207
10.1.2 引入Spring Cloud Sleuth 209
10.2 整合Spring Cloud Sleuth与Zipkin 215
10.2.1 Zipkin基本结构 215
10.2.2 引入Zipkin 216
10.2.3 使用Zipkin跟踪服务调用链路 218
10.2.4 使用Zipkin实现自定义跟踪 226
10.3 本章小结 228
第11章 Spring Test与服务测试 230
11.1 微服务测试的方法 231
11.1.1 单元测试 231
11.1.2 集成测试 233
11.1.3 端到端测试 233
11.2 测试Spring Boot应用程序 234
11.2.1 初始化测试环境 234
11.2.2 执行单元测试 237
11.3 使用Mock和注解实施集成测试 241
11.3.1 使用@JsonTest注解测试JSON数据 242
11.3.2 使用@DataJpaTest注解测试Repository层 244
11.3.3 使用Mock测试Service层 248
11.3.4 使用Mock和@WebMvcTest注解测试Controller层 252
11.4 消费者驱动的契约测试 254
11.4.1 面向契约的端对端测试 254
11.4.2 实现面向契约的端对端测试 257
11.5 本章小结 266
第12章 Docker与服务部署 267
12.1 Docker与微服务架构 267
12.1.1 Docker的优势 268
12.1.2 Docker组件与命令 268
12.2 使用Dockerfile构建服务镜像 272
12.2.1 Dockerfile命令 272
12.2.2 使用Dockerfile命令构建镜像 273
12.3 使用Docker Compose编排服务 276
12.3.1 Docker Compose组件与命令 276
12.3.2 使用Docker Compose 279
12.3.3 Docker Compose案例分析 281
12.4 本章小结 283
参考文献 284
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务架构实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>循序渐进学Docker
前言
第一部分　基础篇
第1章　全面认识Docker 2
1.1　Docker是什么 2
1.1.1　Docker的由来 2
1.1.2　Docker为什么这么火 4
1.1.3　Docker究竟是什么 6
1.2　Docker的结构与特性 8
1.2.1　Docker构成 8
1.2.2　Docker化应用的存在形式 10
1.2.3　Docker对变更的管理 14
1.3　为什么使用Docker 15
1.3.1　从代码管理说起 16
1.3.2　当前的优化策略 17
1.3.3　Github版的应用部署解决方案 18
1.3.4　Docker应用场景 19
1.3.5　Docker可以解决哪些痛点 21
1.3.6　Docker的使用成本 22
1.4　本章小结 23
第2章　初步体验Docker 24
2.1　Windows下安装Docker 24
2.2　利用Docker搭建个人博客 27
2.2.1　传统的安装方法 27
2.2.2　使用Docker进行安装 27
2.2.3　解惑 31
2.2.4　其他注意事项 32
2.3　本章小结 32
第3章　Ubuntu下使用Docker 33
3.1　Docker的运行平台 33
3.2　安装Windows和Ubuntu双系统 34
3.2.1　制作Ubuntu安装U盘 35
3.2.2　通过U盘安装Ubuntu 36
3.3　在Ubuntu下安装Docker 38
3.4　再次体验Docker 40
3.4.1　再看个人博客WordPress的搭建 40
3.4.2　开源的版本控制利器——GitLab 40
3.4.3　项目管理系统——Redmine 42
3.5　本章小结 44
第4章　Docker的基础知识 45
4.1　Docker的基本概念和常用操作指令 45
4.1.1　Docker三大基础组件 46
4.1.2　常用的Docker指令 47
4.1.3　Docker的组织结构 49
4.2　10分钟的动手教程 50
4.3　本章小结 60
第二部分　高级篇
第5章　Docker容器管理 62
5.1　单一容器管理 62
5.1.1　容器的标示符 63
5.1.2　查询容器信息 64
5.1.3　容器内部命令 65
5.2　多容器管理 66
5.2.1　Docker Compose 67
5.2.2　配置文件 69
5.3　本章小结 73
第6章　Docker镜像管理 74
6.1　认识Docker镜像 74
6.2　Dockerf?ile 78
6.3　项目中的镜像分层 83
6.4　定制私有的基础镜像 84
6.5　本章小结 85
第7章　Docker仓库管理 86
7.1　镜像的公有仓库 86
7.1.1　创建Docker Hub账户 86
7.1.2　基本操作 87
7.2　私有仓库 88
7.2.1　安装docker-registry 88
7.2.2　配置文件 91
7.3　构建安全的私有仓库 92
7.3.1　Nginx安装与配置 92
7.3.2　SSL证书 94
7.3.3　客户端配置 96
7.4　本章小结 97
第8章　Docker网络和存储管理 98
8.1　Docker网络 98
8.1.1　Docker的通信方式 98
8.1.2　网络配置 100
8.2　Docker数据管理 101
8.2.1　基本介绍 101
8.2.2　数据卷 102
8.2.3　数据卷容器 105
8.2.4　备份、恢复和迁移数据卷 107
8.3　Docker存储驱动 108
8.3.1　Docker存储驱动历史 108
8.3.2　Docker overlayfs driver 109
8.4　本章小结 112
第9章　Docker项目日常维护 113
9.1　宿主机的管理 113
9.1.1　安装Docker并启动 113
9.1.2　网桥模式 115
9.2　GitLab的日常维护 116
9.2.1　项目的创建 116
9.2.2　代码版本控制 118
9.2.3　日常维护 119
9.3　本章小结 122
第10章　Docker Swarm容器集群 123
10.1　Swarmkit核心设计 123
10.2　Swarmkit集群搭建 124
10.2.1　创建Manager节点 125
10.2.2　创建Worker节点 126
10.3　Swarmkit基本功能 127
10.3.1　service创建与删除 127
10.3.2　service扩容与缩容 128
10.3.3　service灰度升级 128
10.3.4　service网络配置、域名解析和负载均衡 129
10.3.5　Swarmkit节点管理 131
10.3.6　Manager节点和Worker节点角色切换 133
10.4　Swarmkit负载均衡原理分析 134
10.5　本章小节 137
第11章　Docker插件开发 138
11.1　Docker插件工作机制 138
11.1.1　Docker插件接口 138
11.1.2　插件发现机制 139
11.1.3　JSON文件格式 139
11.1.4　插件的生命周期 140
11.1.5　利用systemd socket activation功能管理插件 140
11.1.6　API格式 141
11.2　Docker volume插件开发 141
11.2.1　cgroupfs使用方法和工作原理 142
11.2.2　docker volume接口 143
11.2.3　实现cgroupfs-volume volume插件 145
11.3　本章小节 147
第三部分　案例篇
第12章　Docker离线系统应用案例 150
12.1　为什么使用Docker 150
12.2　离线系统业务架构 152
12.3　Clip名字服务 153
12.4　Clip名字服务与Docker应用 156
12.5　本章小结 158
第13章　Etcd、Cadvisor和Kubernetes实践 159
13.1　Etcd实践 159
13.1.1　安装Etcd 160
13.1.2　使用方法 160
13.2　Cadvisor实践 164
13.2.1　安装Cadvisor 164
13.2.2　Cadvisor API 165
13.3　Kubernetes实践 166
13.3.1　基本概念 167
13.3.2　环境说明 168
13.3.3　环境部署 169
13.3.4　API常用操作 173
13.3.5　创建pod单元 173
13.3.6　实战案例 176
13.4　本章小结 181
第14章　构建Docker高可用及自动发现架构实践 182
14.1　架构优势 182
14.2　架构介绍 183
14.3　架构搭建 184
14.3.1　组件环境部署 185
14.3.2　Etcd配置 186
14.3.3　Confd配置 186
14.3.4　容器提交注册 190
14.4　业务上线 195
14.5　本章小结 198
第15章　Docker Overlay Network实践 199
15.1　环境介绍 199
15.2　容器与容器之间通信 200
15.2.1　启动docker daemon 200
15.2.2　创建网络 200
15.2.3　启动容器 201
15.3　Docker的VXLAN实现 204
15.3.1　VXLAN帧结构 205
15.3.2　Docker内部实现 205
15.3.3　Linux VXLAN设备 207
15.4　容器访问外部网络 207
15.5　外部网络访问容器 209
15.6　本章小结 212
第四部分　源码探索篇
第16章　Docker源码探索 214
16.1　Docker源码目录结构 214
16.2　源码编译Docker 219
16.2.1　修改Dockerf?ile 220
16.2.2　其他 222
16.2.3　编译源码的好处 222
16.3　输出函数调用关系 223
16.4　本章小结 225
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>循序渐进学Docker
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务架构与实践
第1部分 基础篇
第1章 单块架构及其面临的挑战  3
1.1 三层应用架构  4
1.1.1 三层应用架构的发展  4
1.1.2 什么是三层架构  5
1.1.3 三层架构的优势  6
1.2 单块架构  6
1.2.1 什么是单块架构  6
1.2.2 单块架构的优势  7
1.2.3 单块架构面临的挑战  8
1.3 小结  12
第2章 微服务架构综述  13
2.1 什么是微服务架构  13
2.1.1 多微才够微  14
2.1.2 单一职责  17
2.1.3 轻量级通信  17
2.1.4 独立性  19
2.1.5 进程隔离  20
2.2 微服务的诞生背景  22
2.2.1 互联网行业的快速发展  23
2.2.2 敏捷、精益方法论的深入人心 23
2.2.3 单块架构系统面临的挑战  23
2.2.4 容器虚拟化技术  23
2.3 微服务架构与 SOA  24
2.3.1 SOA概述  24
2.3.2 微服务与 SOA  25
2.4 微服务的本质  26
2.4.1 服务作为组件  27
2.4.2 围绕业务组织团队  28
2.4.3 关注产品而非项目  29
2.4.4 技术多样性  31
2.4.5 业务数据独立  32
2.4.6 基础设施自动化  33
2.4.7 演进式架构  33
2.5 微服务不是银弹  34
2.5.1 分布式系统的复杂度  35
2.5.2 运维成本  36
2.5.3 部署自动化  36
2.5.4 DevOps与组织架构  37
2.5.5 服务间的依赖测试  37
2.5.6 服务间的依赖管理  37
2.6 小结  38
第2部分 实践篇
第3章 构建第一个服务  41
3.1 场景分析  41
3.2 任务拆分  43
第4章 Hello World API  45
4.1 API实现  45
4.1.1 开发语言 ——Ruby  45
4.1.2 Web框架——Grape  46
4.1.3 API的具体实现  47
4.2 代码测试与静态检查  50
4.2.1 代码测试  50
4.2.2 测试覆盖率统计  53
4.2.3 静态检查  54
4.2.4 代码复杂度检查  57
第5章 构建 Docker映像  61
5.1 定义 Dockerfile  61
5.2 配置 Docker主机  63
5.3 构建 Docker映像  64
5.4 运行 Docker容器  64
5.5 发布 Docker映像  65
5.6 小结  69
第6章 部署 Docker映像  71
6.1基础设施 AWS  71
6.2基础设施自动化  73
6.3 部署 Docker映像  80
6.4自动化部署  81
6.5 小结  84
第7章 持续交付流水线  85
7.1 持续集成环境  85
7.2 提交阶段  87
7.3 验证阶段  91
7.4 构建阶段  91
7.5 发布阶段  94
7.6 小结  96
第8章 日志聚合  97
8.1 日志聚合工具简介  97
8.2 Splunk的核心  99
8.3 安装 Splunk索引器  100
8.4 安装 Splunk转发器  101
8.5 日志查找  102
8.6 告警设置  103
8.7 小结  104
第9章 监控与告警  105
9.1 Nagios简介  105
9.2 Nagios的工作原理  107
9.3 Nagios安装  108
9.4 Nagios的配置  109
9.5 监控 products-service  111
9.6 告警  113
9.7 小结  114
第10章 功能迭代  115
10.1 定义模型  116
10.2 持久化模型  117
10.3 定义表现形式  119
10.4 实现 API  122
10.5 服务描述文件  125
10.6 小结  127
第3部分 进阶篇
第11章 微服务与持续交付  131
11.1 持续交付的核心  132
11.2 微服务架构与持续交付  133
11.2.1 开发  133
11.2.2 测试  137
11.2.3 持续集成  139
11.2.4 构建  139
11.2.5 部署  140
11.2.6 运维  143
11.3 小结  144
第12章 微服务与轻量级通信机制  145
12.1 同步通信与异步通信  145
12.1.1 概述  145
12.1.2 同步通信与异步通信的选择 146
12.2 远程调用 RPC  147
12.2.1 远程过程调用的核心  147
12.2.2 远程方法调用  148
12.2.3 远程过程调用的弊端  148
12.3 REST  149
12.3.1 概述  149
12.3.2 REST的核心  150
12.3.3 REST的优势  152
12.3.4 REST的不足  152
12.3.5 本节小结  155
12.4 HAL  155
12.4.1 概述  155
12.4.2 HAL的核心  156
12.4.3 HAL浏览器  160
12.5 消息队列  161
12.5.1 核心部分  162
12.5.2 访问方式  163
12.5.3 消息队列的优缺点  164
12.6 后台任务处理系统  165
12.6.1 核心部分  165
12.6.2 服务回调  166
12.6.3 一个例子  167
12.6.4 后台任务与微服务  169
12.7 小结  170
第13章 微服务与测试  171
13.1 微服务的结构  171
13.2 微服务的测试策略  173
13.3 微服务的单元测试  175
13.3.1 单元测试综述  175
13.3.2 单元测试的内容  176
13.4 微服务的集成测试  179
13.4.1 集成测试综述  179
13.4.2 集成测试的实施方法  179
13.4.3 集成测试的内容  180
13.5 基于消费者驱动的契约测试  181
13.5.1 集成测试存在的弊端  181
13.5.2 什么是契约  183
13.5.3 什么是契约测试  184
13.5.4 契约测试的方法  185
13.5.5 Pact实现契约测试  187
13.5.6 一个例子  192
13.5.7 本节小结  205
13.6 微服务的组件测试  205
13.6.1 组件测试概述  205
13.6.2 组件测试的方法  206
13.6.3 本节小结  207
13.7 微服务的端到端测试  208
13.7.1 端到端测试概述  208
13.7.2 端到端测试的内容  208
13.7.3 本节小结  209
13.8 小结  210
第14章 使用微服务架构改造遗留系统  211
14.1 背景与挑战  211
14.2 改造策略  212
14.2.1 昀小修改  212
14.2.2 功能剥离  212
14.2.3 数据解耦  213
14.2.4 数据同步  213
14.2.5 迭代替换  214
14.3 快速开发实践  215
14.3.1 快速开发模板  215
14.3.2 代码生成工具  217
14.3.3 持续集成模板  217
14.3.4 一键部署工具  217
14.4 微服务架构下的新系统  218
14.5 小结  220
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务架构与实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker实践
版权
版权声明
内容提要
译者简介
序
前言
致谢
关于本书
关于封面插画
第一部分　Docker基础
第1章　Docker初探
第2章　理解Docker——深入引擎室
第二部分　Docker与开发
第3章 将Docker用作轻量级虚拟机
第4章 Docker日常
第5章 配置管理——让一切井然有序
第三部分　Docker与DevOps
第6章 持续集成：加快开发流水线
第7章 持续交付：与Docker 原则完美契合
第8章　网络模拟：无痛的现实环境测试
第四部分　生产环境中的Docker
第9章　容器编排：管理多个Docker容器
第10章 Docker与安全
第11章 一帆风顺——生产环境中的Docker以及运维上的考量
第12章 Docker生产环境实践——应对各项挑战
附录A 安装并使用Docker
附录B Docker配置
附录C Vagrant
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Swarm容器编排与Docker原生集群
第1章  欢迎来到Docker Swarm	1
集群工具和容器管理器	3
Swarm的目标	3
为什么使用Swarm	4
真实的示例	5
-- 宠物模型vs牛群模型	5
Swarm特性	6
类似项目	7
-- Kubernetes	7
-- CoreOS Fleet	8
-- Apache Mesos	9
-- Kubernetes vs Fleet vs Mesos	10
-- Swarm vs所有	10
Swarm v1架构	10
-- 术语	12
开始使用Swarm	13
-- Mac系统上的Docker	14
-- Windows系统上的Docker	16
-- 使用Linux	18
-- 检查Docker Machine是否可用——所有系统	19
以前的Swarm	19
-- Boot2Docker	21
-- 使用Docker Machine创建4个集群节点	21
-- 配置Docker主机	24
-- 启动Docker Swarm	25
-- 测试Swarm集群	29
-- 如今的Swarm	31
本章小结	35
第2章  探索发现服务	36
发现服务	37
Token	38
-- 使用token重新架构第1章示例	38
-- Token的限制	43
Raft	43
-- Raft理论	43
-- 实际的Raft	45
Etcd	47
-- 使用Etcd重新架构第1章示例	47
ZooKeeper	50
Consul	50
-- 使用Consul重新架构第1章示例	50
实现去中心化的发现服务	52
本章小结	52
第3章  遇见Docker Swarm Mode	53
SwarmKit	53
-- 版本和支持	54
-- SwarmKit架构	54
-- SwarmKit的核心：swarmd	56
-- SwarmKit的控制器：swarmctl	57
-- 使用Ansible预配SwarmKit集群	58
-- 在SwarmKit上创建服务	62
Swarm Mode	63
-- Swarm v1 vs Swarm Mode vs SwarmKit	64
-- 深入了解Swarm Mode部署	65
本章小结	72
第4章  创建生产级别Swarm	73
工具	73
Swarm2k的HA拓扑	74
-- 管理器配置	75
-- Raft恢复场景	75
-- Raft文件	76
-- 运行任务	76
-- 管理器拓扑	76
使用belt预配基础架构	79
使用Docker Machine保护管理器安全	81
理解Swarm内部机制	83
-- 加入worker	84
-- 升级管理器	85
监控Swarm2k	87
-- InfluxDB时间序列数据库	87
Swarm3k	90
-- Swarm3k的搭建和工作负载	90
-- 大规模Swarm的性能	92
总结Swarm2k和Swarm3k的经验教训	95
本章小结	96
第5章  管理Swarm集群	97
Docker Swarm standalone	97
Docker Swarm Mode	98
-- 手动添加节点	99
-- 管理器	99
-- Worker数量	100
-- 添加脚本化节点	100
-- belt	102
-- 使用Ansible	103
集群管理	105
-- 操作节点	106
降级和升级	107
-- 标记节点	108
-- 移除节点	110
Swarm健康	111
备份集群配置	111
灾难恢复	112
Swarm的图形化界面	112
-- Shipyard	112
-- Portainer	114
本章小结	115
第6章  Swarm上真实应用的部署	116
微服务	116
部署一个复制的Nginx	117
-- 一个极简的Swarm	118
-- Docker Service	120
overlay网络	124
集成的负载均衡	124
服务的连接：用WordPress例子展示	124
-- Swarm的调度策略	127
-- 现在，WordPress	127
Docker Compose和Swarm Mode	130
Docker stacks介绍	130
-- 分布式应用包	131
-- Docker deploy	132
另外一个应用：Apache Spark	133
-- 为什么要在Docker上运行Spark	134
-- 没有Swarm的Spark单机	134
-- 在Swarm上的Spark单机	137
-- 在Swarm上启动Spark	138
本章小结	140
第7章  平台的向上伸缩	141
再次登场的Spark例子	142
Docker插件	142
实验室环境	143
-- 一个独一无二的秘钥	143
-- Docker Machine	144
-- 安全组	145
-- 网络配置	146
-- 存储配置和架构	146
安装Flocker	148
-- 生成Flocker证书	149
-- 安装软件	151
-- 安装控制节点	153
-- 安装集群节点	153
-- 测试一切是否正常	154
安装并配置Swarm	156
-- 为Spark添加一个卷	157
再次部署Spark	157
-- 测试Spark	159
-- 使用Flocker存储	161
伸缩Spark	164
监控Swarm托管的应用	165
-- Prometheus	165
-- 安装一个监控系统	166
-- 在Grafana中导入Prometheus	167
本章小结	169
第8章  Swarm附加特性的探索	171
Libnetwork	171
-- Networking插件	172
-- 容器网络模型	173
加密和路由矩阵	174
MacVLAN	174
-- overlay网络	175
网络控制面板	177
Libkv	179
-- 如何使用libkv	180
本章小结	181
第9章  Swarm集群和Docker软件供应链的安全加固	182
软件供应链	182
Swarm集群的安全加固	183
安全加固Swarm：最佳实践	184
-- 证书颁发机构	185
-- 证书和相互TLS	185
-- 集群加入令牌	185
-- 在Docker Machine中添加TLS	186
Docker Notary	187
Docker Secret介绍	190
本章小结	192
第10章  Swarm和云	193
Docker for AWS和Docker for Azure	193
-- Docker for AWS	194
-- Docker for Azure	198
Docker Datacenter	201
OpenStack上的Swarm	202
-- OpenStack Nova	204
-- 当下现实：OpenStack友好的方式	205
-- OpenStack Heat	205
-- OpenStack Magnum	206
本章小结	215
第11章  Swarm的未来展望	216
Provisioning的挑战	216
软件定义基础设施	216
-- Infrakit	217
-- TUF—— The Update Framework	219
Docker Stacks和Compose	220
Caas ——容器即服务	220
Unikernel	220
为Docker做贡献	222
-- Github	222
-- 提交issue	222
-- 代码	223
-- belt和其他项目	223
本章小结	223
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Swarm容器编排与Docker原生集群
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Python Docker实战
第1章 容器化简介 1
1.1 什么是Docker 1
1.1.1 Docker公司 1
1.1.2 软件技术层面的Docker 2
1.1.3 理解Docker所解决的问题 2
1.2 容器化历程 3
1.2.1 1979年：chroot 3
1.2.2 2000年：FreeBSD jail 4
1.2.3 2005年：OpenVZ 4
1.2.4 2006年：cgroups 4
1.2.5 2008年：LXC 5
1.3 理解容器和虚拟机之间的区别 5
1.4 本章小结 6
第2章 Docker入门 7
2.1 安装Docker 7
2.1.1 在Windows上安装Docker 8
2.1.2 在macOS上安装Docker 10
2.1.3 在Linux上安装Docker 11
2.1.4 理解Docker相关术语 13
2.1.5 Docker实践 19
2.2 本章小结 31
第3章 构建Python应用程序 33
3.1 项目介绍 33
3.1.1 设置Telegram Messenger 34
3.1.2 BotFather：Telegram的机器人创建接口 35
3.1.3 newsbot：Python应用程序 38
3.2 本章小结 42
第4章 理解Dockerfile 43
4.1 Dockerfile 43
4.1.1 构建上下文 44
4.1.2 dockerignore 45
4.1.3 使用docker build进行构建 46
4.1.4 Dockerfile指令 48
4.1.5 编写Dockerfile的原则和建议 65
4.1.6 多阶段构建 66
4.1.7 Dockerfile练习 66
4.2 本章小结 74
第5章 理解Docker卷 75
5.1 数据持久化 75
5.1.1 Docker容器内部数据丢失的例子 76
5.1.2 Docker卷练习 88
5.2 本章小结 98
第6章 理解Docker网络 99
6.1 为何需要容器网络 99
6.1.1 默认的Docker网络驱动 100
6.1.2 使用Docker网络 102
6.2 Docker网络练习 117
6.3 本章小结 123
第7章 理解Docker Compose 125
7.1 Docker Compose概述 125
7.1.1 安装Docker Compose 126
7.1.2 Docker Compose基础 127
7.1.3 Docker Compose文件参考 132
7.1.4 Docker Compose CLI参考 137
7.1.5 Docker Compose练习 138
7.2 本章小结 150
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Python Docker实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker技术入门与实战（第2版）
第2版前言
第1版前言
第一部分　基础入门
第1章　初识容器与Docker 3
1.1　什么是Docker 3
1.2　为什么要使用Docker 5
1.3　Docker与虚拟化 7
1.4　本章小结 9
第2章　核心概念与安装配置 10
2.1　核心概念 10
2.2　安装Docker 11
2.2.1　Ubuntu环境下安装Docker 12
2.2.2　CentOS环境下安装Docker 14
2.2.3　通过脚本安装 14
2.2.4　Mac OS环境下安装Docker 15
2.2.5　Windows环境下安装Docker 20
2.3　配置Docker服务 21
2.4　推荐实践环境 22
2.5　本章小结 22
第3章　使用Docker镜像 23
3.1　获取镜像 23
3.2　查看镜像信息 25
3.3　搜寻镜像 28
3.4　删除镜像 29
3.5　创建镜像 31
3.6　存出和载入镜像 32
3.7　上传镜像 33
3.8　本章小结 33
第4章　操作Docker容器 34
4.1　创建容器 34
4.2　终止容器 39
4.3　进入容器 40
4.4　删除容器 42
4.5　导入和导出容器 42
4.6　本章小结 44
第5章　访问Docker仓库 45
5.1　Docker Hub公共镜像市场 45
5.2　时速云镜像市场 47
5.3　搭建本地私有仓库 48
5.4　本章小结 50
第6章　Docker数据管理 51
6.1　数据卷 51
6.2　数据卷容器 52
6.3　利用数据卷容器来迁移数据 53
6.4　本章小结 54
第7章　端口映射与容器互联 55
7.1　端口映射实现访问容器 55
7.2　互联机制实现便捷互访 57
7.3　本章小结 59
第8章　使用Dockerfile创建镜像 60
8.1　基本结构 60
8.2　指令说明 62
8.3　创建镜像 67
8.4　使用.dockerignore文件 67
8.5　最佳实践 67
8.6　本章小结 68
第二部分　实战案例
第9章　操作系统 71
9.1　BusyBox 71
9.2　Alpine 72
9.3　Debian/Ubuntu 74
9.4　CentOS/Fedora 76
9.5　本章小结 77
第10章　为镜像添加SSH服务 78
10.1　基于commit命令创建 78
10.2　使用Dockerfile创建 80
10.3　本章小结 82
第11章　Web服务与应用 83
11.1　Apache 83
11.2　Nginx 87
11.3　Tomcat 88
11.4　Jetty 92
11.5　LAMP 93
11.6　CMS 94
11.6.1　WordPress 94
11.6.2　Ghost 96
11.7　持续开发与管理 96
11.7.1　Jenkins 97
11.7.2　Gitlab 98
11.8　本章小结 99
第12章　数据库应用 100
12.1　MySQL 100
12.2　MongoDB 102
12.2.1　使用官方镜像 102
12.2.2　使用自定义Dockerfile 104
12.3　Redis 106
12.4　Memcached 108
12.5　CouchDB 108
12.6　Cassandra 109
12.7　本章小结 110
第13章　分布式处理与大数据平台 111
13.1　RabbitMQ 111
13.2　Celery 113
13.3　Hadoop 114
13.4　Spark 115
13.4.1　使用官方镜像 116
13.4.2　验证 116
13.5　Storm 117
13.6　Elasticsearch 119
13.7　本章小结 120
第14章　编程开发 121
14.1　C/C++ 121
14.1.1　GCC 121
14.1.2　LLVM 122
14.1.3　Clang 122
14.2　Java 123
14.3　Python 124
14.3.1　使用官方的Python镜像 124
14.3.2　使用PyPy 124
14.4　JavaScript 125
14.5　Go 127
14.5.1　搭建并运行Go容器 127
14.5.2　Beego 130
14.5.3　Gogs：基于Go的Git服务 130
14.6　PHP 130
14.7　Ruby 132
14.7.1　使用Ruby官方镜像 132
14.7.2　JRuby 133
14.7.3　Ruby on Rails 134
14.8　Perl 135
14.9　R 136
14.10　Erlang 138
14.11　本章小结 140
第15章　容器与云服务 141
15.1　公有云容器服务 141
15.1.1　AWS 141
15.1.2　Google Cloud Platform 142
15.1.3　Azure 143
15.1.4　腾讯云 144
15.1.5　阿里云 144
15.1.6　华为云 144
15.1.7　UCloud 145
15.2　容器云服务 145
15.2.1　基本要素与关键特性 146
15.2.2　网易蜂巢 146
15.2.3　时速云 147
15.2.4　Daocloud 148
15.2.5　灵雀云 148
15.2.6　数人云 149
15.3　阿里云容器服务 150
15.4　时速云容器平台 151
15.5　本章小结 153
第16章　容器实战思考 154
16.1　Docker为什么会成功 154
16.2　研发人员该如何看容器 155
16.3　容器化开发模式 156
16.4　容器与生产环境 158
16.5　本章小结 160
第三部分　进阶技能
第17章　Docker核心实现技术 163
17.1　基本架构 163
17.2　命名空间 165
17.3　控制组 167
17.4　联合文件系统 169
17.5　Linux网络虚拟化 171
17.6　本章小结 174
第18章　配置私有仓库 175
18.1　安装Docker Registry 175
18.2　配置TLS证书 177
18.3　管理访问权限 178
18.4　配置Registry 181
18.4.1　示例配置 181
18.4.2　选项 183
18.5　批量管理镜像 188
18.6　使用通知系统 190
18.6.1　相关配置 190
18.6.2　Notif?ication的使用场景 192
18.7　本章小结 193
第19章　安全防护与配置 194
19.1　命名空间隔离的安全 194
19.2　控制组资源控制的安全 195
19.3　内核能力机制 195
19.4　Docker服务端的防护 197
19.5　更多安全特性的使用 197
19.6　使用第三方检测工具 198
19.6.1　Docker Bench 198
19.6.2　clair 199
19.7　本章小结 199
第20章　高级网络功能 201
20.1　网络启动与配置参数 201
20.2　配置容器DNS和主机名 203
20.3　容器访问控制 204
20.4　映射容器端口到宿主主机的实现 206
20.5　配置docker0网桥 207
20.6　自定义网桥 208
20.7　使用OpenvSwitch网桥 209
20.8　创建一个点到点连接 211
20.9　本章小结 212
第21章　libnetwork插件化网络功能 213
21.1　容器网络模型 213
21.2　Docker网络相关命令 215
21.3　构建跨主机容器网络 216
21.4　本章小结 219
第四部分　开源项目
第22章　Etcd——高可用的键值数据库 223
22.1　简介 223
22.2　安装和使用Etcd 224
22.3　使用etcdctl客户端 228
22.3.1　数据类操作 230
22.3.2　非数据类操作 233
22.4　Etcd集群管理 236
22.4.1　构建集群 236
22.4.2　集群参数配置 238
22.5　本章小结 240
第23章　Docker三剑客之Docker Machine 241
23.1　简介 241
23.2　安装Machine 241
23.3　使用Machine 243
23.4　Machine命令 244
23.5　本章小结 247
第24章　Docker三剑客之Docker Compose 248
24.1　简介 248
24.2　安装与卸载 249
24.3　Compose命令说明 252
24.4　Compose环境变量 257
24.5　Compose模板文件 257
24.6　Compose应用案例一：Web负载均衡 266
24.7　Compose应用案例二：大数据Spark集群 271
24.8　本章小结 273
第25章　Docker三剑客之Docker Swarm 274
25.1　简介 274
25.2　安装Swarm 275
25.3　使用Swarm 277
25.4　使用其他服务发现后端 281
25.5　Swarm中的调度器 282
25.6　Swarm中的过滤器 284
25.7　本章小结 286
第26章　Mesos——优秀的集群资源调度平台 287
26.1　简介 287
26.2　Mesos安装与使用 288
26.3　原理与架构 296
26.3.1　架构 296
26.3.2　基本单元 297
26.3.3　调度 297
26.3.4　高可用性 298
26.4　Mesos配置项解析 299
26.4.1　通用项 299
26.4.2　master专属项 299
26.4.3　slave专属项 301
26.5　日志与监控 304
26.6　常见应用框架 306
26.7　本章小结 307
第27章　Kubernetes——生产级容器集群平台 308
27.1　简介 308
27.2　核心概念 309
27.2.1　集群组件 311
27.2.2　资源抽象 312
27.2.3　辅助概念 315
27.3　快速体验 318
27.4　安装部署 322
27.5　重要组件 331
27.5.1　Etcd 332
27.5.2　kube-apiserver 332
27.5.3　kube-scheduler 333
27.5.4　kube-controller-manager 333
27.5.5　kubelet 334
27.5.6　kube-proxy 335
27.6　使用kubectl 337
27.6.1　获取kubectl 337
27.6.2　命令格式 337
27.6.3　全局参数 338
27.6.4　子命令 339
27.7　网络设计 351
27.8　本章小结 353
第28章　其他相关项目 354
28.1　平台即服务方案 354
28.1.1　Deis 354
28.1.2　Flynn 355
28.2　持续集成平台Drone 355
28.3　容器管理 357
28.3.1　Citadel 357
28.3.2　Shipyard 358
28.3.3　DockerUI 358
28.3.4　Panamax 358
28.3.5　Seagull 359
28.3.6　Dockerboard 361
28.4　编程开发 362
28.5　网络支持 363
28.5.1　pipework 363
28.5.2　Flannel 364
28.5.3　Weave Net 364
28.5.4　Calico 365
28.6　日志处理 366
28.6.1　Docker-Fluentd 366
28.6.2　Logspout 367
28.6.3　Sematext-agent-docker 368
28.7　服务代理工具 368
28.7.1　Traefik 369
28.7.2　Muguet 370
28.7.3　nginx-proxy 370
28.8　标准与规范 372
28.9　其他项目 375
28.9.1　CoreOS 375
28.9.2　OpenStack支持 375
28.9.3　dockerize 376
28.9.4　Unikernel 378
28.9.5　容器化的虚拟机 378
28.10　本章小结 379
附录
附录A　常见问题总结 382
附录B　Docker命令查询 388
附录C　参考资源链接 393
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker技术入门与实战（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Dockerによるアプリケーション開発環境構築ガイド
Chapter01 Dockerとは
1-1 本書の目的
1-1-1 本書で想定しているユーザー
1-2 Dockerとは
1-2-1 コンテナ型の仮想化
1-2-2 イメージを用いたimmutable infrastructure
1-2-3 Dockerと関連したサービスやアプリケーション
1-3 Kubernetesとは
1-3-1 オーケストレーション
1-3-2 Kubernetesを使うメリット
1-4 Dockerイメージをビルドしてみよう
1-4-1 イメージのビルドで得られるメリット
1-4-2 現場で想定される課題
1-5 2章以降を読み進めるにあたって
1-5-1 想定しているPC環境
1-5-2 周辺知識について
Chapter02 Dockerの基本的な使い方
2-1 Dockerのインストール
2-1-1 Dockerのインストール(Linux)
2-1-2 Dockerのインストール(Windows)
2-1-3 Dockerのインストール(Mac)
2-2 Dockerの基本的なコマンド
2-2-1 Dockerのコマンド一覧とその意味
2-2-2 Dockerコマンドのシーンごとの利用例
2-3 DockerfileでオリジナルのDockerイメージを作成する
2-3-1 Dockerfileとは
2-3-2 Dockerfileで使えるコマンド
2-3-3 Dockerfileで使えるコマンドの詳細
2-3-4 Dockerfileからイメージを作成する
2-3-5 Dockerイメージのレイヤーとキャッシュについて
2-4 作成したDockerイメージをレジストリで共有する
2-4-1 Docker Hub
2-5 Docker Composeで複数コンテナをまとめて管理する
2-5-1 docker-composeとは
2-5-2 docker-composeのインストール
2-5-3 docker-composeコマンド一覧とその意味
2-5-4 docker-composeでWordPress環境を構築する
Chapter03 オンプレの構成をコピーしたDocker環境を作成する
3-1 サーバーの環境一式を全部入りコンテナに移行する
3-1-1 コンテナで複数のプロセスを動かす場合の注意
3-1-2 Baseimage-dockerについて
3-2 Baseimage-dockerを使ってみる
3-2-1 イメージをpullする
3-2-2 コンテナを実行する
3-2-3 コンテナ内部で動作しているサービスを制御する
3-2-4 コンテナ内部で新しいサービスを動かしてみる
3-3 Dockerイメージを構築する
3-3-1 イメージのビルドに必要なリソースやスクリプトを用意する
3-3-2 必要なパッケージがインストールされるようにする(プロビジョニング)
3-3-3 インストールしたサービスの動作確認
3-3-4 必要なサービスが自動で立ち上がるようにする
3-3-5 アプリケーションがデプロイされた状態にする
3-3-6 データベースと設定ファイルを用意する
3-3-7 コンテナへSSHログインできるようにする
Chapter04 本番環境からローカルのDocker環境にポーティングする
4-1 AWSを利用したサービスをローカル環境上にDockerで構築する
4-1-1 機能要件およびデータ構造、システム要件、構成図
4-1-2 AWSアカウントを新規作成する
4-1-3 Webアプリケーションサーバーの作成
4-1-4 データベースサーバーの作成
4-1-5 セキュリティグループの設定
4-1-6 キャッシュサーバーの作成
4-1-7 ファイルストレージの作成
4-1-8 アプリケーションコードの作成
4-2 クラウドに構築した環境をローカルの開発環境にポーティングする
4-2-1 Dockerによるデータベースサーバーの構築
4-2-2 Dockerによるキャッシュサーバーの構築
4-2-3 Dockerによるファイルサーバーの構築
4-2-4 Dockerによるアプリケーションサーバーの構築
Chapter05 ローカルのDocker環境を本番環境にデプロイする
5-1 Kubernetesとは
5-2 Kubernetesの概念
5-2-1 Pod
5-2-2 Deployment
5-2-3 Service
5-2-4 Volume
5-2-5 ConfigMap
5-2-6 Secret
5-2-7 Ingress
5-2-8 Namespace
5-3 minikubeで始めるKubernetes
5-3-1 minikubeのインストールとQuick Start
5-3-2 minikubeで4章で作成した環境をローカルに作成
5-4 Google Cloud Platform(GCP)を使う
5-4-1 GCPとは?
5-4-2 Googleアカウントの作成とGCPアカウントの作成
5-4-3 Google Container Engine(GKE)の環境を作ろう
5-5 GCP上に4章で作ったアプリケーションをデプロイしよう
5-5-1 Single Node File Serverの環境を作成する
5-5-2 GKEのKubernetesにアプリケーションをデプロイする
Chapter06 Appendix
6-1 ログ機能
6-1-1 volumeマウント機能で外部ストレージに保存する
6-1-2 外部サービスにログを送信する
6-2 複数コンテナがある場合のkubectl execについて
6-3 Dockerfileのデバッグ方法
6-4 継続的インテグレーションサービスによるイメージの自動ビルド
6-4-1 CircleCI
6-5 Docker in Docker
6-6 Dockerホストの容量が少なくなってきたとき
6-6-1 TAGがnoneのものを全て削除
6-6-2 リンク切れボリュームの一括削除
6-6-3 終了済みコンテナの一括削除
6-7 プロキシの設定について
6-7-1 Dockerデーモン側の設定
6-7-2 コンテナ環境のプロキシ設定
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Dockerによるアプリケーション開発環境構築ガイド
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务架构基础:Spring Boot+Spring Cloud+Docker
第1章认识微服务架构1
1.1 为什么需要微服务架构 2
1.1.1 传统单体应用架构的问题 2
1.1.2 如何解决传统应用架构的问题 3
1.2 微服务架构是什么 4
1.2.1 微服务架构的概念 4
1.2.2 微服务架构的优点 5
1.2.3 微服务架构的不足 6
1.2.4 微服务架构与SOA的区别 6
1.3 如何构建微服务架构 6
1.3.1 微服务的拆分 7
1.3.2 微服务架构的组件 7
1.3.3 微服务架构的搭建 7
1.3.4 微服务架构的技术选型 8
1.4 本章小结 10
第2章 初识Spring Boot 11
2.1 Spring Boot介绍 12
2.1.1 Spring Boot的由来和特点 12
2.1.2 Spring Boot的使用要求 12
2.2 Spring Boot入门 13
2.2.1 Spring Boot项目的快速搭建 13
2.2.2 第一个Spring Boot程序 18
2.3 Spring Boot的工作机制 20
2.3.1 @Spring BootApplication 20
2.3.2 Spring Application 21
2.4 本章小结 22
第3章 Spring Boot应用开发 23
3.1 Spring Boot与MyBatis的集成 24
3.2 Spring Boot与Redis的集成 29
3.2.1 添加Redis缓存 29
3.2.2 清除Redis缓存 31
3.3 Spring Boot与ActiveMQ的集成 31
3.3.1 使用内嵌的ActiveMQ 31
3.3.2 使用外部的ActiveMQ 33
3.4 Spring Boot应用的打包和部署 35
3.4.1 JAR包 35
3.4.2 WAR包 36
3.5 本章小结 37
第4章 Spring Cloud（上） 38
4.1 Spring Cloud简介 39
4.1.1 什么是Spring Cloud 39
4.1.2 Spring Cloud的特点 39
4.1.3 Spring Cloud的版本 39
4.2 服务发现 40
4.2.1 Eureka介绍 40
4.2.2 如何使用Eureka注册服务 41
4.2.3 如何实现服务间的调用 47
4.3 客户端负载均衡 50
4.3.1 Ribbon介绍 50
4.3.2 Ribbon的使用 51
4.4 本章小结 53
第5章 Spring Cloud（下） 54
5.1 服务容错保护 55
5.1.1 Spring Cloud Hystrix介绍 55
5.1.2 Spring Cloud Hystrix的使用 56
5.1.3 HystrixDashboard的使用 59
5.2 API网关服务 63
5.2.1 为什么需要API网关 63
5.2.2 如何使用Zuul构建API网关服务 64
5.3 分布式配置管理 68
5.3.1 Spring Cloud Config简介 68
5.3.2 使用本地存储的方式实现配置管理 69
5.3.3 使用Git存储的方式实现配置管理 73
5.4 本章小结 76
第6章 初识Docker 77
6.1 Docker概述 78
6.1.1 什么是Docker 78
6.1.2 Docker的特点 78
6.1.3 Docker与虚拟机的区别 79
6.2 Docker的安装要求 79
6.3 Docker的安装方式 80
6.3.1 在线安装 80
6.3.2 离线安装 82
6.3.3 脚本文件安装 83
6.3.4 安装时的问题及解决方法 84
6.4 Docker的运行机制 85
6.4.1 Docker的引擎 85
6.4.2 Docker的架构 85
6.5 Docker的底层技术 87
6.6 本章小结 87
第7章 Docker的使用 88
7.1 Docker入门程序 89
7.2 Dockerfile介绍 92
7.2.1 Dockerfile基本结构 92
7.2.2 Dockerfile常用指令 93
7.2.3 dockerignore文件 95
7.3 Docker客户端常用指令 96
7.3.1 Docker常用操作指令 96
7.3.2 Docker管理指令 101
7.4 Docker镜像管理 102
7.4.1 Docker镜像管理工具 102
7.4.2 Docker Hub远程镜像管理 103
7.4.3 Docker Registry本地私有仓库搭建 106
7.4.4 Docker Registry本地私有仓库配置 107
7.5 本章小结 112
第8章 Docker中的网络与数据管理 113
8.1 Docker网络管理 114
8.1.1 Docker默认网络管理 114
8.1.2 自定义网络介绍 115
8.1.3 自定义bridge网络 116
8.1.4 容器之间的网络通信 118
8.2 Docker Swarm集群 122
8.2.1 Docker Swarm概述 122
8.2.2 Docker Swarm使用 123
8.3 Docker数据管理 127
8.3.1 Docker数据存储机制 127
8.3.2 Docker数据存储方式 129
8.4 Volumes数据卷管理 129
8.4.1 Volumes数据卷的优势 129
8.4.2 Volumes数据卷使用 130
8.5 本章小结 134
第9章 微服务项目的整合与测试 135
9.1 微服务项目整合 136
9.1.1 微服务项目结构预览 136
9.1.2 微服务项目功能介绍 136
9.1.3 微服务项目的启动和测试 140
9.2 接口可视化工具—Swagger—UI 143
9.2.1 Swagger—UI使用方法 143
9.2.2 Swagger—UI使用测试 145
9.3 本章小结 147
第10章 微服务的部署 149
10.1 Docker Compose编排工具 150
10.1.1 Docker Compose介绍 150
10.1.2 Docker Compose的安装与卸载 150
10.1.3 Composefile文件的使用说明 151
10.2 微服务与Docker的整合 154
10.3 环境搭建以及镜像准备 159
10.3.1 环境搭建 159
10.3.2 镜像准备 161
10.4 微服务的手动部署 162
10.4.1 非集群环境下的服务部署 162
10.4.2 集群环境下服务部署 163
10.4.3 微服务测试 167
10.5 使用Jenkins自动部署微服务 169
10.5.1 Jenkins介绍 169
10.5.2 Jenkins安装 170
10.5.3 Jenkins集成插件配置 173
10.5.4 服务自动化部署 175
10.6 本章小结 180
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务架构基础:Spring Boot+Spring Cloud+Docker
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud与Docker高并发微服务架构设计实施
第一部分架 构 篇
1 微服务架构与 Spring Cloud  2
1.1 微服务概念的由来  2
1.2 微服务的定义  3
1.3 微服务架构与整体式架构的区别  5
1.4 微服务架构与SOA 的比较  8
1.5 为什么要使用微服务架构  9
1.6 为实施微服务架构做好准备  10
1.6.1 思想观念的转变  10
1.6.2 团队管理方式的改变  11
1.6.3 自动化基础设施的建设  11
1.7 为什么要使用Spring Cloud  12
1.8 Spring Cloud 组件介绍  13
1.9 Spring Cloud 的版本说明  15
1.10 小结  17
2 微服务架构最佳设计  18
2.1 合理划分微服务  19
2.2 微服务治理  19
2.3 Rest API 微服务设计  21
2.3.1 使用数据库集群  22
2.3.2 读写分离设计  22
2.3.3 使用缓存  22
2.3.4 保证Rest API 微服务的独立性  23
2.4 Web UI 微服务设计  23
2.4.1 使用FeignClient 实现负载均衡调用  23
2.4.2 使用Hystrix 实现容错设计  23
2.4.3 使用非阻塞的异步编程技术实现高并发调用  24
2.4.4 使用分布式文件系统  24
2.5 微服务之间调用规则设计  24
2.6 数据最终一致性设计  25
2.7 分布式集群架构设计  26
2.8 微服务运行环境安全设计  27
2.9 小结  27
3 电商平台微服务设计实例  29
3.1 电商平台总体设计  29
3.1.1 总体业务流程设计  29
3.1.2 总体业务功能设计  31
3.2 电商平台业务模型设计  32
3.2.1 移动商城业务模型  32
3.2.2 商家管理后台业务模型  33
3.2.3 平台管理后台业务模型  33
3.3 创建Rest API 微服务  34
3.4 创建Web UI 微服务  36
3.4.1 移动商城Web UI 微服务  36
3.4.2 商家管理后台的Web UI 微服务  37
3.4.3 平台管理后台Web UI 微服务  37
3.5 电商平台微服务体系结构  38
3.6 小结  39
第二部分 开 发 篇
4 开发工具选用及 Spring Boot 基础  41
4.1 开发工具选择  42
4.2 开发环境配置  42
4.3 创建Spring Boot 工程  43
4.4 使用JPA  47
4.4.1 数据源配置  48
4.4.2 JPA 配置  48
4.4.3 数据实体设计  49
4.4.4 存储库接口设计  49
4.4.5 单元测试  50
4.5 使用Thymeleaf  51
4.5.1 控制器设计  51
4.5.2 视图设计  52
4.6 运行与部署  52
4.7 小结  54
5 电商平台微服务工程设计  55
5.1 微服务工程结构  55
5.2 电商平台微服务工程组建  57
5.3 数据库选型  57
5.4 微服务工程创建步骤  58
5.5 项目基本配置  60
5.6 创建模块  64
5.7 小结  66
6 微服务治理基础服务开发  67
6.1 注册管理中心  68
6.1.1 创建注册管理中心  68
6.1.2 运行注册管理中心  70
6.1.3 微服务怎样使用注册管理中心  70
6.1.4 构建高可用的注册管理中心  72
6.2 配置管理中心  73
6.2.1 创建配置管理中心  73
6.2.2 微服务如何使用配置管理中心  76
6.2.3 在线更新配置信息  77
6.3 微服务监控中心  78
6.3.1 使用断路器仪表盘实现监控  79
6.3.2 聚合服务监控管理中心  81
6.4 服务跟踪分析中心  86
6.4.1 创建服务跟踪分析中心  86
6.4.2 在微服务中启用服务跟踪功能  90
6.5 日志分析平台  93
6.5.1 创建日志分析平台  93
6.5.2 使用日志分析平台  93
6.6 小结  94
7 Rest API 微服务开发  96
7.1 领域业务开发  96
7.1.1 使用Druid 数据源  98
7.1.2 JPA 及其配置  100
7.1.3 数据实体建模  101
7.1.4 查询对象设计  104
7.1.5 实体持久化设计  106
7.1.6 持久化测试  107
7.1.7 领域服务开发  109
7.1.8 领域服务的单元测试  111
7.1.9 使用Redis 实现缓存设计  112
7.2 Rest API 应用开发  117
7.2.1 Rest API 应用配置  117
7.2.2 启动程序设计  119
7.2.3 接口开发  119
7.3 使用消息处理事件  123
7.3.1 消息生产者设计  124
7.3.2 消息消费者设计  125
7.3.3 使用消息测试  128
7.4 小结  129
8 Web UI 微服务开发  131
8.1 高并发接口调用分层设计  131
8.2 通过FeignClient 调用Rest API  132
8.3 使用Hystrix 断路器  134
8.4 使用非阻塞异步编程方法  136
8.4.1 CompletableFuture 介绍  137
8.4.2 性能比较测试  140
8.5 Web 应用开发  145
8.5.1 项目引用配置  145
8.5.2 应用程序配置  146
8.5.3 业务功能开发  148
8.6 开发环境的热部署设置  154
8.7 使用分布式文件系统  157
8.7.1 分布式文件系统客户端开发  157
8.7.2 商品图片上传设计  159
8.7.3 富文本编辑器上传文件设计  160
8.7.4 建立本地文件信息库  163
8.8 小结  166
9 电商平台移动商城开发  167
9.1 移动商城首页设计  168
9.2 使用负载均衡的导航设计  174
9.3 按分类查询设计  176
9.4 商品详情页设计  179
9.5 购买下单实现  181
9.6 用户登录与账户切换设计  184
9.6.1 用户登录设计  184
9.6.2 切换账号设计  186
9.7 订单查询设计  188
9.8 集成测试  191
9.9 小结  192
10 商家管理后台与 SSO 设计  193
10.1 商家权限管理体系设计及开发  194
10.1.1 商家权限体系建模  195
10.1.2 商家权限体系的持久化设计  199
10.1.3 商家权限体系的领域服务开发  201
10.2 商家管理微服务开发  204
10.2.1 商家领域服务层单元测试  204
10.2.2 商家服务的接口开发  208
10.3 SSO 设计  213
10.3.1 SSO 基本配置  213
10.3.2 在SSO 中使用商家的权限体系  214
10.3.3 用户登录设计  216
10.3.4 有关验证码的说明  218
10.3.5 SSO 的主页设计  220
10.3.6 OAuth2 服务端设计  222
10.4 SSO 客户端设计  224
10.4.1 客户端的项目管理配置  224
10.4.2 客户端的安全管理配置  225
10.4.3 权限验证实现原理  226
10.4.4 如何在应用中接入SSO  228
10.4.5 有关跨站请求伪造防御的相关设置  230
10.4.6 根据用户权限自动分配菜单  230
10.5 小结  232
11 平台管理后台开发  233
11.1 平台管理后台领域设计  233
11.1.1 领域实体建模  233
11.1.2 实体的行为设计  236
11.1.3 领域服务开发  236
11.1.4 领域服务单元测试  239
11.2 平台管理后台访问控制设计  240
11.2.1 使用平台管理的用户体系  240
11.2.2 权限管理设计  242
11.3 商家的注册设计  245
11.4 商家菜单体系管理开发  248
11.4.1 分类菜单管理开发  248
11.4.2 模块菜单管理开发  249
11.4.3 访问资源管理开发  252
11.5 商家角色管理开发  255
11.6 小结  257
第三部分运 维 篇
12 服务器架构设计与 Docker 使用  259
12.1 服务器组建  259
12.2 安全的服务器架构设计  260
12.2.1 防火墙安装及配置  260
12.2.2 建立安全的局域网环境  264
12.3 服务器资源分配  266
12.4 CentOS 安装  269
12.4.1 IP 地址设置  270
12.4.2 安全设置  270
12.4.3 语言配置  270
12.4.4 时间同步配置  271
12.5 Docker 和docker-compose 安装  271
12.5.1 Docker 安装及使用  272
12.5.2 docker-compose 安装及使用  275
12.6 使用Docker 搭建微服务治理环境  279
12.6.1 服务器1 的部署配置  279
12.6.2 服务器2 的部署配置  281
12.7 使用Docker 部署日志分析平台  283
12.8 使用Docker 部署微服务应用  286
12.9 小结  286
13 数据库集群设计与高可用读写分离实施  288
13.1 MySQL 安装  289
13.2 主从同步设置  291
13.3 主主同步设置  294
13.4 数据库代理中间件选择  296
13.5 使用OneProxy 实现读写分离设计  297
13.5.1 OneProxy 安装  297
13.5.2 高可用读写分离配置  298
13.6 OneProxy 分库分区设计  302
13.6.1 按范围分库分表  303
13.6.2 按值分库分表  303
13.6.3 按哈希算法分库分表  304
13.7 双机热备设计  306
13.8 小结  307
14 分布式文件系统等基础设施安装与配置  308
14.1 高可用的分布式文件系统构建  308
14.1.1 FastDFS 安装  310
14.1.2 跟踪服务器配置  310
14.1.3 存储节点配置  311
14.1.4 上传文件测试  312
14.1.5 Nginx 安装及负载均衡配置  313
14.1.6 开机启动设置  317
14.2 GitLab 安装  322
14.3 Redis 安装  324
14.4 RabbitMQ 安装  326
14.5 小结  327
15 使用自动化构建工具 Jenkins 实现CI/CD  328
15.1 持续交付工作流程  330
15.2 Jenkins 安装  331
15.3 Jenkins 基本配置  333
15.4 Jenkins 自动部署实例  335
15.4.1 创建任务  336
15.4.2 任务配置  337
15.4.3 执行任务  340
15.5 小结  343
后记  345
参考文献  346
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud与Docker高并发微服务架构设计实施
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>找到你的為什麼
作者序 邀請你踏上尋找為什麼之旅
序章    找到為什麼行動計畫
第一章 如果我們先問，為什麼？
第二章 如何找到為什麼
第三章 探索你的為什麼
第四章 探索團體的為什麼──參與
第五章 探索團體的為什麼──對話
第六章 找出怎麼做，發現你的強項
第七章 跟隨你所相信的價值，勇敢行動
附錄一 常見問題Q&A
附錄二 給個人探索搭檔的重點筆記
附錄三 給團隊探索主持人的重點筆記
謝辭
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>找到你的為什麼
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js实战：使用Egg.js+Vue.js+Docker构建渐进式、可持续集成与交付应用
第1章  Node.js的优势  1
1.1  为什么是JavaScript语言  1
1.2  为什么经常说Node.js不适合大型应用  3
第2章  Egg.js框架核心原理与实现  6
2.1  异步基础  6
2.2  Koa.js基础知识  15
2.2.1  Koa.js 中间件核心代码  16
2.2.2  Koa.js插件  18
2.3  Egg.js 基础知识  21
2.3.1  实现 egg-core  22
2.3.2  实现 egg-init  26
2.3.3  实现egg-cluster  30
2.4  Egg.js插件  33
2.4.1  egg-socket.io  33
2.4.2  原理解读  39
2.5  制作一个Egg.js插件  43
第3章  构建后端API服务  52
3.1  安装相关组件  52
3.2  发布一个插件  59
3.2.1  创建Flash插件  59
3.2.2  使用egg-msg-flash  72
3.2.3  使用egg-y-validator  73
3.3  规范化  73
3.3.1  添加新的scripts支持ESLint自修复  74
3.3.2  添加插件支持  74
3.3.3  prettier格式化工具  76
3.3.4  同步代码编辑器配置  76
3.4  第一个JSON请求  77
3.4.1  给全局添加一些方法  77
3.4.2  全局化一些东西  84
3.4.3  自动路由  86
3.4.4  创建 PostMan 测试  88
3.5  注册服务  91
3.5.1  Invitation模型  91
3.5.2  注释  93
3.5.3  User模型  96
3.5.4  修改控制器  97
3.5.5  添加验证逻辑  98
3.5.6  帮助方法  99
3.5.7  User服务  101
3.5.8  PostMan测试  103
3.6  登录服务  104
3.7  邮件与调试  115
3.7.1  理解发送邮件的原理  115
3.7.2  安装邮件插件  115
3.7.3  环境与调试  116
3.7.4  全局调试  118
3.7.5  VSCode全局调试  121
3.7.6  发送验证邮件  122
3.7.7  添加逻辑  125
3.7.8  验证  135
3.8  构建 RESTful API  137
3.8.1  什么是RESTful API  137
3.8.2  创建RESTController基础类便于继承  138
3.8.3  测试Images RESTful API  141
3.8.4  构建后台的REST路由  143
3.8.5  构建控制器  145
3.8.6  测试后台路由  148
3.8.7  关于验证  149
3.9  安全地开放API  151
3.10  实现OAuth接口  158
3.10.1  实现授权码官方文档所要求的接口  158
3.10.2  实现刷新验证码接口  167
3.10.3  实现 authenticate 所需接口  169
3.11  完善OAuth与测试  170
3.11.1  发放Token  170
3.11.2  新建客户端项目  172
3.11.3  测试OAuth  173
3.12  支付宝支付  176
3.12.1  什么是非对称加密  176
3.12.2  注册支付宝  176
3.12.3  生成非对称秘钥  176
3.12.4  实现  177
3.12.5  添加路由  180
3.12.6  内网穿透  180
3.12.7  测试  182
3.13  社会化登录  183
第4章  构建后台管理页面  189
4.1  后端开发  189
4.1.1  安装VSCode插件  189
4.1.2  获取脚手架  189
4.1.3  安装依赖  190
4.1.4  修改代码  190
4.1.5  跨域请求  191
4.1.6  修改后端代码支持跨域  192
4.1.7  在前端添加存储  198
4.2  模型列表  200
4.3  添加数据  209
4.4  修改逻辑  220
第5章  前端界面设计与实现  228
5.1  搭建前端开发环境  228
5.1.1  开始  228
5.1.2  创建Header头部  229
5.1.3  将变量提取出来  234
5.1.4  添加路径重写  235
5.2  AppFooter组件  237
5.2.1  做一些配置  237
5.2.2  创建src/components/layouts/AppFooter.vue  238
5.2.3  网络识别信息  247
5.2.4  修改一下全局样式  247
5.2.5  查看页面  248
5.2.6  提升编译速度  248
5.3  首页  249
5.4  替换成为真实数据  269
5.4.1  完成后端Image API  269
5.4.2  修改首页的代码  271
5.4.3  添加API逻辑  276
5.4.4  效果  278
5.5  图片详情页  278
5.5.1  创建路由  279
5.5.2  安装依赖  279
5.5.3  创建视图  279
5.5.4  添加插件  285
5.5.5  创建评论组件  286
5.5.6  测试  290
5.5.7  关于服务端访问DOM  290
5.6  注册页面  294
5.6.1  注册路由  294
5.6.2  新建signup.vue页面  295
5.6.3  增强错误提示  299
5.7  登录页面  299
5.8  完善详情与评论  310
5.9  个人中心  321
5.10  创建图片  336
5.10.1  创建又拍云存储  336
5.10.2  添加后端API  338
5.10.3  前端界面  340
5.10.4  测试  348
5.11  团队  349
5.11.1  功能是如何工作的  350
5.11.2  数据库  350
5.11.3  后端  356
5.11.4  前端  363
5.11.5  测试  372
第6章  部署与运维  374
6.1  认识Docker  374
6.1.1  解决了什么问题  374
6.1.2  使用Docker的流程  375
6.1.3  安装Docker  378
6.1.4  使用加速器  378
6.1.5  下载一个基础镜像  379
6.1.6  hello world  379
6.2  手动构建镜像  380
6.3  编写Dockerfile文件  384
6.4  Docker Compose  387
6.4.1  安装docker-compose  387
6.4.2  命令行接口  388
6.4.3  Egg.js简单实例  389
6.4.4  增加服务  391
6.5  集群  396
6.5.1  Docker集群  396
6.5.2  集群初始化  396
6.5.3  实例  397
6.6  持续部署  400
6.6.1  部署主机免密码登录  400
6.6.2  客户端钩子  401
6.6.3  使用服务端钩子进行部署  403
6.6.4  使用 shipit  404
6.6.5  使用 Ansible 部署  406
6.7  持续集成  409
6.8  Kubernetes集群  423
6.8.1  简单使用  423
6.8.2  如何创建应用  425
6.8.3  命令行管理  430
6.8.4  通过UI创建应用  433
6.8.5  添加持续集成  439
6.8.6  固定IP地址  441
6.8.7  部署前端  442
第7章  性能分析与优化  448
7.1  服务器性能分析与测试  448
7.2  用户追踪  458
7.2.1  百度分析  458
7.2.2  Google分析  460
7.2.3  其他付费服务  461
7.3  前端性能分析与优化  461
7.3.1  lighthouse  461
7.3.2  sonarwhal  462
7.3.3  图片压缩  464
7.3.4  错误上报  465
7.3.5  接收用户反馈  466
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js实战：使用Egg.js+Vue.js+Docker构建渐进式、可持续集成与交付应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>容器云运维实战——Docker与Kubernetes集群
第1章  Linux 运维基础  1
1.1  Linux基础  2
1.1.1  systemd  2
1.1.2  Shell脚本  6
1.2  自动化运维  14
1.2.1  自动化运维之Ansible  14
1.2.2  Ansible的使用  16
1.2.3  Ansible模块  23
1.2.4  playbook  27
1.3  本章小结  38
第2章  高可用的Linux集群  39
2.1  高可用集群基础  40
2.1.1  高可用衡量标准  40
2.1.2  高可用层次结构  40
2.1.3  常见的高可用方案  41
2.2  虚拟服务的实现  44
2.2.1  DNS轮询  44
2.2.2  客户端调度  45
2.2.3  应用层负载调度  46
2.2.4  IP层负载调度  46
2.3  LVS负载均衡  46
2.3.1  LVS体系结构  47
2.3.2  IP负载均衡  48
2.3.3  负载调度算法  54
2.3.4  ipvsadm工具详解  56
2.3.5  LVS集群实践  58
2.4  Nginx负载均衡  63
2.4.1  Nginx配置文件详解  63
2.4.2  Nginx负载均衡模块  68
2.5  本章小结  75
第3章  Docker容器引擎  76
3.1  容器技术  77
3.1.1  虚拟化技术  77
3.1.2  容器技术与Docker  79
3.1.3  容器技术原理  84
3.2  Docker基础  89
3.2.1  Docker架构  89
3.2.2  Docker安装  91
3.2.3  Docker命令  96
3.3  Docker镜像  97
3.3.1  认识镜像  97
3.3.2  镜像操作  99
3.3.3  Dockerfile详解  103
3.3.4  镜像仓库  118
3.4  Docker容器  121
3.4.1  认识容器  121
3.4.2  容器操作  123
3.4.3  数据卷  134
3.5  插件与存储驱动  138
3.5.1  Docker插件  138
3.5.2  存储驱动  139
3.6  容器与操作系统  140
3.6.1  为容器而打造：Container Linux（CoreOS）  140
3.6.2  定制化容器系统：RancherOS  142
3.7  本章小结  143
第4章  容器网络  144
4.1  Docker网络基础  145
4.1.1  端口映射  145
4.1.2  端口暴露  146
4.1.3  容器互联  147
4.2  Docker网络模式  152
4.2.1  none模式  152
4.2.2  container模式  154
4.2.3  host模式  155
4.2.4  bridge模式  156
4.2.5  overlay模式  157
4.3  Docker网络配置  158
4.3.1  Daemon网络参数  158
4.3.2  配置DNS  159
4.4  本章小结  159
第5章  容器编排  160
5.1  安装Docker Compose  161
5.1.1  二进制安装  161
5.1.2  使用Python pip安装  161
5.2  Compose命令基础  162
5.2.1  指定配置文件  162
5.2.2  指定项目名称  163
5.2.3  Compose环境变量  163
5.2.4  build：构建服务镜像  164
5.2.5  bundle：生成DAB包  165
5.2.6  config：检查配置语法  165
5.2.7  create：创建服务容器  166
5.2.8  down：清理项目  167
5.2.9  events：查看事件  168
5.2.10  exec：进入服务容器  168
5.2.11  kill：杀死服务容器  169
5.2.12  logs：查看服务容器日志  169
5.2.13  pause：暂停服务容器  170
5.2.14  port：查看服务容器端口状态  170
5.2.15  ps/images：查看容器与镜像  171
5.2.16  pull：拉取项目镜像  172
5.2.17  push：推送项目镜像  172
5.2.18  restart：重启服务容器  173
5.2.19  rm：删除项目容器  173
5.2.20  run：执行一次性命令  174
5.2.21  scale：设置服务容器数量  177
5.2.22  start：启动服务容器  178
5.2.23  stop：停止服务容器  178
5.2.24  top：查看进程状态  178
5.2.25  unpause：取消暂停  179
5.2.26  up：启动项目  179
5.3  Compose配置文件  183
5.3.1  配置文件基础  183
5.3.2  基本配置  184
5.3.3  网络配置  199
5.3.4  配置扩展  200
5.4  Compose实战  204
5.4.1  WordPress博客部署  204
5.4.2  Django框架部署  205
5.5  本章小结  207
第6章  Docker集群管理  208
6.1  Swarm 基础  209
6.1.1  Docker Swarm 命令  209
6.1.2  Docker Node 命令  211
6.1.3  Docker Stack 命令  213
6.1.4  Docker集群网络  214
6.2  集群进阶  223
6.2.1  Swarm：高可用的Docker集群管理工具  223
6.2.2  Shipyard：集群管理面板  225
6.2.3  Portainer：容器管理面板  227
6.3  本章小结  229
第7章  Docker生态  230
7.1  宿主管理工具：Machine  231
7.1.1  Machine的安装  231
7.1.2  宿主环境管理  231
7.2  容器编排调度  233
7.2.1  Rancher：集群管理面板  233
7.2.2  Nomad：行业领先的调度系统  235
7.2.3  DC/OS：一切皆可调度  237
7.2.4  服务发现  238
7.3  私有镜像仓库  239
7.3.1  私有仓库的部署  239
7.3.2  VMware Harbor：企业私有仓库  250
7.3.3  SUSE Portus：镜像仓库前端分布认证  254
7.4  Docker插件  256
7.4.1  授权插件  256
7.4.2  Flocker存储插件  257
7.4.3  网络驱动插件  257
7.5  Docker安全  259
7.5.1  Docker安全机制  259
7.5.2  Docker资源控制  261
7.5.3  Docker安全工具  264
7.6  监控与日志  265
7.6.1  cAdvisor：原生集群监控  265
7.6.2  Logspout：日志处理  266
7.6.3  Grafana：数据可视化  267
7.6.4  其他监控工具  269
7.7  基于Docker的PaaS平台  270
7.7.1  Deis：轻量级PaaS平台  270
7.7.2  Tsuru：可扩展PaaS平台  270
7.7.3  Flynn：模块化PaaS平台  271
7.8  Docker持续集成  271
7.8.1  Drone：轻量级CI工具  271
7.8.2  Travis CI：著名的CI/CD服务商  273
7.9  其他  274
7.10  本章小结  276
第8章  Kubernetes入门  277
8.1  Kubernetes介绍  278
8.1.1  什么是Kubernetes  278
8.1.2  Kubernetes架构  278
8.1.3  Kubernetes的优势  280
8.2  Kubernetes概念  281
8.2.1  Kubernetes资源  281
8.2.2  调度中心：Master  281
8.2.3  工作节点：Node  281
8.2.4  最小调度单位：Pod  283
8.2.5  资源标签：Label  284
8.2.6  弹性伸缩：RC与RS  286
8.2.7  部署对象：Deployment  287
8.2.8  水平扩展：HPA  288
8.2.9  服务对象：Service  290
8.2.10  数据卷资源：Volume  293
8.2.11  数据持久化：Persistent Volume  299
8.2.12  命名空间：Namespace  304
8.2.13  注释：Annotation  304
8.3  Kubernetes部署  305
8.3.1  使用Minikube安装Kubernetes  305
8.3.2  使用Kubeadm安装Kubernetes  307
8.4  Kubernetes命令行详解  309
8.4.1  基本命令（初级）  310
8.4.2  基本命令（中级）  318
8.4.3  部署命令  320
8.4.4  集群管理命令  323
8.4.5  故障排除与调试命令  326
8.4.6  高级命令  329
8.4.7  设置命令  330
8.4.8  其他命令  332
8.4.9  kubectl全局选项  334
8.5  本章小结  335
第9章  Kubernetes运维实践  336
9.1  Pod详解  337
9.1.1  Pod配置详解  337
9.1.2  Pod生命周期  340
9.1.3  共享Volume  343
9.1.4  Pod配置管理  343
9.1.5  Pod健康检查  346
9.1.6  Pod扩容和缩容  348
9.2  Service详解  349
9.2.1  Service的定义  349
9.2.2  Service的创建  350
9.2.3  集群外部访问  351
9.2.4  Ingress负载网络  353
9.3  集群进阶  3559.3.1  资源管理  355
9.3.2  kubelet垃圾回收机制  359
9.4  监控与日志  359
9.4.1  原生监控：Heapster  359
9.4.2  星火燎原：Prometheus  360
9.4.3  王牌组合：EFK  366
9.4.4  后起之秀：Filebeat  374
9.5  本章小结  376
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>容器云运维实战——Docker与Kubernetes集群
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker微服务架构实战
第一部分  Docker与微服务基础	1
第1章  微服务架构概述	2
1.1  什么是微服务	2
1.1.1  CORBA	3
1.1.2  DCOM	4
1.1.3  RMI	5
1.1.4  SOA	7
1.2  为什么要使用微服务	9
1.2.1  scale cube	9
1.2.2  API网关	13
1.3  微服务架构设计原则	15
1.3.1  业务架构	15
1.3.2  逻辑架构	16
1.3.3  技术架构	19
1.3.4  基础架构	20
1.4  从单体到微服务	21
1.4.1  止损	22
1.4.2  前后端分离	23
1.4.3  提取服务	24
第2章  微服务中的技术选型	26
2.1  服务治理	27
2.1.1  Dubbo	27
2.1.2  Spring Cloud	30
2.2  服务网关	35
2.2.1  OpenResty	35
2.2.2  Orange	38
2.2.3  Kong	40
2.2.4  Zuul	41
2.3  服务注册发现	43
2.3.1  ZooKeeper	43
2.3.2  Eureka	49
2.4  配置中心	51
2.5  请求链路追踪	57
第3章  Service Mesh	64
3.1  初识Service Mesh	64
3.1.1  什么是Service Mesh	64
3.1.2  为什么使用Service Mesh	65
3.2  Service Mesh的发展过程	66
3.2.1  早期的分布式计算	66
3.2.2  微服务时代的分布式计算	68
3.3  主流的Service Mesh框架	73
第4章  Docker技术简介	75
4.1  Docker是什么	75
4.2  Docker的作用	77
4.2.1  用Docker快速搭建环境	78
4.2.2  用Docker降低运维成本	83
4.2.3  Docker下自动发布	84
4.3  Docker的生态圈	86
4.4  微服务与Docker	89
第二部分  Docker架构与生态	93
第5章  Docker技术架构	94
5.1  Docker的进程模型	94
5.1.1  容器中进程启动的两种模式	96
5.1.2  容器中的进程隔离模型	101
5.1.3  容器的自重启	102
5.1.4  容器中用户权限的隔离和传递	103
5.1.5  Docker守护进程宕机的处理机制	104
5.2  容器的本质	104
5.2.1  Namespace解惑	105
5.2.2  Rootfs解惑	106
5.2.3  CGroups解惑	109
5.3  Docker容器的运行时模型	111
第6章  Docker逻辑架构	113
6.1  Docker Registry的技术选型	114
6.2  Harbor的部署	115
第7章  Docker网络架构	120
7.1  Docker的单机网络模式	120
7.1.1  Bridge模式	120
7.1.2  Host模式	123
7.1.3  Container模式	124
7.1.4  None模式	125
7.2  Docker的集群网络模式	126
7.2.1  Bridge端口转发	126
7.2.2  扁平网络	127
7.2.3  Flannel模式	130
第8章  Docker安全架构	135
8.1  Docker安全问题	135
8.2  Docker安全措施	138
第9章  Docker与DevOps	148
9.1  DevOps概要	148
9.2  Docker容器的代码挂载机制	149
9.2.1  静态导入	149
9.2.2  动态导入	150
9.3  Docker与服务发现	150
9.4  Dockerfile怎么写	164
9.5  Docker与日志	172
9.6  Docker与监控	176
9.7  Docker与CI/CD	182
9.8  Docker给运维团队带来的挑战	184
第10章  容器编排	186
10.1  容器编排概述	186
10.2  容器编排技术选型	189
10.2.1  Docker Swarm	189
10.2.2  Kubernetes	191
10.2.3  Marathon	194
10.3  Kubernetes实战	197
10.3.1  Kubernetes快速安装	198
10.3.2  在Kubernetes上部署应用	203
10.4  Docker Swarm实战	210
10.4.1  Docker Swarm的快速安装	212
10.4.2  在Decker Swarm上部署应用	214
第三部分  Docker落地之路	221
第11章  企业级Docker容器云架构	222
11.1  宏观系统视角下的架构	222
11.2  容器云平台逻辑架构图	223
第12章  基于Rancher的容器云管理平台	226
12.1  Rancher概述	226
12.2  Rancher的安装	227
12.3  Rancher对IaaS的管理	228
12.4  Rancher下多租户多环境的管理	236
12.5  Rancher对SaaS的管理	240
12.6  Rancher对容器的管理	242
12.7  Rancher的L2-FLAT网络	248
12.8  Rancher 的服务治理	249
第13章  微服务与Docker化实战	258
13.1  整体架构鸟瞰	258
13.2  基于log-pilot的日志收集	261
13.3  基于Zabbix的容器监控	263
13.4  简单的DevOps架构图	264
13.5  推进方案和成本	266
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Docker微服务架构实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务运维实战（第二卷）
第1章  利用Docker容器持续集成 1
1.1  完全Docker化的手动持续集成流程 3
1.2  运行单元测试并构建服务的二进制文件 5
1.3  构建服务镜像 7
1.4  运行模拟测试 10
1.5  推送镜像到镜像库 12
第2章  搭建并运行Swarm集群 17
2.1  可扩展性 18
2.2  轴向扩展 19
X轴扩展 20
Y轴扩展 21
Z轴扩展 22
2.3  集群 22
2.4  Docker Swarm模式 23
2.5  搭建一个Swarm集群 25
2.6  在Swarm集群上部署服务 28
2.7  扩展服务 30
2.8  故障转移 31
2.9  现在怎么办 32
第3章  Docker Swarm网络和反向代理 33
3.1  搭建一个集群 34
3.2  以高可用性运行安全的和容错的服务需求 35
3.3  隔离数据库的运行 37
3.4  通过反向代理运行服务 41
3.5  创建一个反向代理服务负责根据基URL路由请求 42
3.6  对一个服务的所有实例实施负载均衡的请求 47
3.7  现在怎么办 50
第4章  Swarm集群内的服务发现 51
4.1  没有注册中心Docker Swarm会怎样 51
4.2  独立的Docker Swarm加上服务发现会是什么样的 55
4.3  Swarm集群中的服务发现 56
4.4  我们需要服务发现吗 57
4.5  将Consul设置为Swarm集群内的服务注册中心 58
4.6  缩放有状态实例时出现的问题 63
4.7  使用服务注册中心来存储状态 64
4.8  发现组成服务的所有实例的地址 69
4.9  使用服务注册中心或键值存储来存储服务状态 71
4.10  现在怎么办 74
第5章  使用Docker容器进行持续交付和部署 75
5.1  定义持续交付环境 76
5.2  搭建持续交付集群 77
5.3  使用节点标签来约束服务 80
5.4  创建服务 83
5.5  示范持续交付步骤 85
5.6  从持续交付到持续部署走得更远 90
5.7  现在怎么办 91
第6章  使用Jenkins自动化持续部署流程 93
6.1  Jenkins架构 93
6.2  搭建生产环境 94
6.3  Jenkins服务 95
6.4  Jenkins故障转移 99
6.5  Jenkins代理 100
6.6  在生产和类生产环境中创建服务 108
6.7  使用Jenkins自动化持续部署流程 110
6.8  创建Jenkins流水线作业 111
6.9  定义流水线节点 113
6.10  定义流水线阶段 115
6.11  定义流水线步骤 116
6.12  现在怎么办 121
第7章  探索Docker远程API 123
7.1  搭建环境 124
7.2  通过Docker Remote API操作Docker Swarm 125
7.3  使用Docker Remote API自动配置代理 134
7.4  将Swarm Listener与代理相结合 135
7.5  自动重新配置代理 136
7.6  从代理中删除服务 138
7.7  现在怎么办 138
第8章  使用Docker Stack和Compose YAML文件来
部署Swarm Services 141
8.1  搭建Swarm集群 142
8.2  通过Docker Stack命令创建Swarm服务 142
8.3  部署更多stack 145
8.4  stack，用还是不用 147
8.5  清理 147
第9章  定义日志策略 149
9.1  集中日志的需求 151
9.2  将ElasticSearch设置为日志数据库 153
9.3  将LogStash设置为日志解析器和转发器 154
9.4  从Swarm集群内任意位置运行的所有容器转发日志 157
9.5  探索日志 161
9.6  讨论其他日志解决方案 166
9.7  现在怎么办 167
第10章  收集指标与监控集群 169
10.1  集群监控系统的需求 169
10.2  选择正确的数据库来存储系统指标 171
10.3  创建集群 173
10.4  Prometheus指标 175
10.5  导出系统范围的指标 176
10.6  拉取、查询和可视化Prometheus指标 181
10.7  使用Grafana创建看板 188
10.8  在Grafana中探索Docker Swarm和容器概览仪表板 195
10.9  通过仪表板指标调整服务 201
10.10  监控最佳实践 204
10.11  现在怎么办 205
第11章  拥抱毁灭：宠物与牛 207
11.1  现在怎么办 209
第12章  在Amazon Web Services中创建和管理Docker Swarm集群 211
12.1  安装AWS CLI并设置环境变量 212
12.2  使用Docker Machine和AWS CLI来配置Swarm集群 215
12.3  使用Docker在AWS中建立Swarm集群 223
12.4  在AWS中使用Docker自动配置Swarm集群 232
12.5  使用Packer和Terraform来创建Swarm集群 236
12.6  使用Packer创建Amazon机器镜像 236
12.7  在AWS中使用Terraform创建Swarm集群 241
12.8  在AWS中选择正确的工具创建和管理Swarm集群 257
12.9  是使用还是不使用Docker Machine 257
12.10  是使用还是不使用Docker for AWS 258
12.11  是使用还是不使用Terraform 260
12.12  最后的结论 263
第13章  在DigitalOcean中创建和管理Docker Swarm集群 265
13.1  设置环境变量 267
13.2  使用Docker Machine和DigitalOcean API创建Swarm集群 269
13.3  使用Packer和Terraform创建Swarm集群 275
13.4  使用Packer创建DigitalOcean快照 276
13.5  在DigitalOcean中使用Terraform创建一个Swarm集群 280
13.6  选择合适的工具创建和管理DigitalOcean中的Swarm集群 298
13.7  是使用还是不使用Docker Machine 299
13.8  是使用还是不使用Terraform 300
13.9  最后的结论 301
13.10  是使用还是不使用DigitalOcean 302
第14章  在Swarm集群中创建和管理有状态的服务 303
14.1  探索十二因素应用程序方法论 303
14.2  设置Swarm集群和代理 308
14.3  运行不需要数据持久性的有状态服务 312
14.4  在主机上持久化有状态的服务 317
14.5  在网络文件系统上持久化有状态服务 318
14.6  数据卷的编排 323
14.7  使用REX-Ray持久化有状态服务 323
14.8  为有状态服务选择持久性方法 329
14.9  在Packer和Terraform中加入REX-Ray 331
14.10  无复制的有状态服务持久化 337
14.11  使用同步和复制持久化有状态服务 337
14.12  持久化Docker Flow Proxy的状态 338
14.13  持久化MongoDB的状态 340
14.14  通过Swarm服务初始化MongoDB副本集 349
14.15  现在怎么办 353
第15章  在Docker Swarm集群中管理secrets 355
15.1  创建secrets 355
15.2  使用secrets 357
15.3  一个使用secrets的真实世界的例子 358
15.4  在Docker Compose中使用secrets 359
15.5  使用secrets的常用方法 361
15.6  现在怎么办 362
附录A  使用Docker和Prometheus监控你的GitHub库 363
A.1  Docker、Prometheus和Grafana 363
A.2  入门 364
A.3  配置 364
A.4  后续配置 365
A.5  安装dashboard 366
A.6  结论 367
索引 369
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务运维实战（第二卷）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>每天5分钟玩转openstack
目录
第一篇 预备知识
第 1 章 虚拟化 2
1.1 1型虚拟化 2
1.2 2型虚拟化 2
1.3 KVM 3
1.3.1 基本概念 3
1.3.2 KVM实操 4
1.4 KVM 虚拟化原理 11
1.4.1 CPU 虚拟化 11
1.4.2 内存虚拟化 12
1.4.3 存储虚拟化 13
1.5 网络虚拟化 19
1.5.1 Linux Bridge 19
1.5.2 VLAN 28
1.5.3 Linux Bridge + VLAN = 虚拟交换机 35
第 2 章 云 计 算 36
2.1 基本概念 36
2.2 云计算和 OpenStack 38
第二篇 OpenStack 核心
第 3 章 OpenStack 架构 41
3.1 Conceptual Architecture 41
3.2 Logical Architecture 42
第 4 章 搭建实验环境 45
4.1 部署拓扑 45
4.2 物理资源需求 46
4.3 网络规划 47
4.4 部署 DevStack 47
第 5 章 Identity Service——Keystone 55
5.1 概念 55
5.1.1 User 55
5.1.2 Credentials 57
5.1.3 Authentication 57
5.1.4 Token 57
5.1.5 Project 58
5.1.6 Service 59
5.1.7 Endpoint 60
5.1.8 Role 60
5.2 通过例子学习 62
5.2.1 第1步 登录 62
5.2.2 第2步 显示操作界面 62
5.2.3 第3步 显示image列表 63
5.2.4 Troubleshoot 64
第 6 章 Image Service——Glance 65
6.1 理解 Image 65
6.2 理解 Image Service 66
6.3 Glance 架构 66
6.4 Glance 操作 69
6.4.1 创建 image 70
6.4.2 删除 image 72
6.5 如何使用 OpenStack CLI 74
6.6 如何 Troubleshooting 77
第 7 章 Compute Service——Nova 79
7.1 Nova架构 80
7.1.1 架构概览 80
7.1.2 物理部署方案 82
7.1.3 从虚机创建流程看 nova-* 子服务如何协同工作 84
7.1.4 OpenStack 通用设计思路 85
7.2 Nova 组件详解 88
7.2.1 nova-api 88
7.2.2 nova-scheduler 90
7.2.3 nova-compute 97
7.2.4 nova-conductor 104
7.3 通过场景学习 Nova 105
7.3.1 看懂 OpenStack 日志 105
7.3.2 Launch 108
7.3.3 Shut Off 108
7.3.4 Start 112
7.3.5 Soft/Hard Reboot 114
7.3.6 Lock/Unlock 114
7.3.7 Terminate 115
7.3.8 Pause/Resume 116
7.3.9 Suspend/Resume 118
7.3.10 Rescue/Unrescue 119
7.3.11 Snapshot 122
7.3.12 Rebuild 125
7.3.13 Shelve 128
7.3.14 Unshelve 130
7.3.15 Migrate 133
7.3.16 Resize 139
7.3.17 Live Migrate 144
7.3.18 Evacuate 150
7.3.19 Instance 操作总结 154
7.4 小节 156
第 8 章 Block Storage Service ——Cinder 157
8.1 理解 Block Storage 157
8.2 理解 Block Storage Service 157
8.2.1 Cinder 架构 158
8.2.2 物理部署方案 159
8.2.3 从volume创建流程看cinder-*子服务如何协同工作 160
8.2.4 Cinder 的设计思想 161
8.2.5 Cinder组件详解 163
8.2.6 通过场景学习 Cinder 170
8.3 小节 220
第 9 章 Networking Service ——Neutron 221
9.1 Neutron 概述 221
9.1.1 Neutron 功能 221
9.1.2 Neutron 网络基本概念 222
9.2 Neutron 架构 224
9.2.1 物理部署方案 227
9.2.2 Neutron Server 228
9.2.3 Neutron 如何支持各种 network provider 229
9.2.4 ML2 Core Plugin 231
9.2.5 Service Plugin / Agent 234
9.2.6 小结 235
9.3 为Neutron 准备物理基础设施 237
9.3.1 1控制节点 + 1 计算节点的部署方案 237
9.3.2 配置多个网卡区分不同类型的网络数据 238
9.3.3 网络拓扑 239
9.3.4 安装和配置节点 240
9.4 Linux Bridge 实现 Neutron 网络 244
9.4.1 配置 linux-bridge mechanism driver 244
9.4.2 初始网络状态 245
9.4.3 了解Linux Bridge 环境中的各种网络设备 247
9.4.4 local network 248
9.4.5 flat network 262
9.4.6 DHCP 服务 270
9.4.7 vlan network 274
9.4.8 Routing 285
9.4.9 vxlan network 307
9.4.10 Securet Group 321
9.4.11 Firewall as a Service 328
9.4.12 Load Balancing as a Service 337
9.5 Open vSwitch 实现 Neutron 网络 358
9.5.1 网络拓扑 358
9.5.2 配置 openvswitch mechanism driver 359
9.5.3 初始网络状态 360
9.5.4 了解 Open vSwitch 环境中的各种网络设备 362
9.5.5 local network 362
9.5.6 flat network 377
9.5.7 vlan network 386
9.5.8 Routing 399
9.5.9 vxlan network 411
9.6 总结 421
写在最后 422
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>每天5分钟玩转openstack
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Kubernetes实战
第 1部分 Kubernetes基础篇
第 1章 Kubernetes介绍 ......................................... 2
1.1为什么会有 Kubernetes ................................................. 2
1.1.1云计算大潮 . 2
1.1.2不温不火的 PaaS ............................................... 5
1.1.3 Docker的逆袭 .................................................... 5
1.2 Kubernetes 是什么 . 7
1.3 Kubernetes的发展历史 ................................................. 8
1.4 Kubernetes的核心概念 ................................................. 9
1.4.1 Pod ............... 9
1.4.2 Replication Controller ......................................... 9
1.4.3 Service ......... 9
1.4.4 Label ............ 9
1.4.5 Node ............. 9
第 2章 Kubernetes的架构和部署 ......................... 10
2.1 Kubernetes的架构和组件 ........................................... 10
2.2 部署 Kubernetes .... 13
2.2.1环境准备 ... 14
2.2.2 运行 Etcd ... 15
2.2.3 获取 Kubernetes发布包 .................................. 16
2.2.4 运行 Kubernetes Master组件 .......................... 16
2.2.5 运行 Kubernetes Node组件 ............................. 17
2.2.6 查询 Kubernetes的健康状态 .......................... 18
2.2.7 创建 Kubernetes覆盖网络 .............................. 19
2.3 安装 Kubernetes扩展插件 .......................................... 22
2.3.1 安装 Cluster DNS............................................. 23
2.3.2 安装 Cluster Monitoring ................................... 28
2.3.3 安装 Cluster Logging ....................................... 36
2.3.4 安装 Kube UI ................................................... 43
第 3章 Kubernetes快速入门 ................................ 46
3.1示例应用 Guestbook .................................................... 46
3.2准备工作 ............... 47
3.3 运行 Redis ............. 48
3.3.1 创建 Redis Master Pod ..................................... 48
3.3.2 创建 Redis Master Service ............................... 49
3.3.3 创建 Redis Slave Pod ....................................... 51
3.3.4 创建 Redis Slave Service ................................. 53
3.4 运行 Frontend ........ 54
3.4.1 创建 Frontend Pod ............................................ 54
3.4.2 创建 Frontend Service...................................... 57
3.5 设置 Guestbook外网访问 ........................................... 57
3.6 清理 Guestbook ..... 59
第 4章 Pod .... 60
4.1国际惯例的 Hello World .............................................. 60
4.2 Pod的基本操作 .... 62
4.2.1 创建 Pod .... 62
4.2.2 查询 Pod .... 62
4.2.3 删除 Pod .... 65
4.2.4 更新 Pod .... 65
4.3 Pod与容器 ............ 65
4.3.1 镜像 ........... 66
4.3.2启动命令 ... 69
4.3.3环境变量 ... 70
4.3.4 端口 ........... 72
4.3.5数据持久化和共享 .......................................... 73
4.4 Pod的网络 ............ 74
4.5 Pod的重启策略 .... 75
4.6 Pod的状态和生命周期 ............................................... 77
4.6.1容器状态 ... 77
4.6.2 Pod的生命周期阶段 ....................................... 78
4.6.3生命周期回调函数 .......................................... 79
4.7自定义检查 Pod .... 81
4.7.1 Pod的健康检查 ............................................... 83
4.7.2 Pod的准备状况检查 ....................................... 84
4.8 调度 Pod ................ 85
4.9问题定位指南 ....... 87
4.9.1事件查询 ... 88
4.9.2日志查询 ... 88
4.9.3 Pod的临终遗言 ............................................... 89
4.9.4远程连接容器 .................................................. 90
第 5章 Replication Controller................................ 92
5.1持续运行的 Pod .... 92
5.2 Pod模板 ................ 94
5.3 Replication Controller和 Pod的关联 .......................... 96
5.4弹性伸缩 ............... 99
5.5自动伸缩 ............. 101
5.6滚动升级 ............. 104
5.7 Deployment .......... 107
5.8一次性任务的 Pod ..................................................... 112
第 6章 Service .................................................... 114
6.1 Service代理 Pod . 114
6.2 Service的虚拟 IP  118
6.3服务代理 ............. 119
6.4服务发现 ............. 123
6.4.1环境变量 . 124
6.4.2 DNS ......... 125
6.5 发布 Service ........ 128
6.5.1 NodePort Service ............................................ 128
6.5.2 LoadBalancer Service..................................... 129
6.5.3 Ingress ...... 130
第 7章 数据卷 ..................................................... 134
7.1  Kubernetes数据卷 ..................................................... 134
7.2本地数据卷 ......... 135
7.2.1 EmptyDir . 135
7.2.2 HostPath ... 136
7.3网络数据卷 ......... 137
7.3.1 NFS .......... 137
7.3.2 iSCSI ........ 138
7.3.3 GlusterFS . 140
7.3.4 RBD（Ceph Block Device）......................... 141
7.3.5 Flocker ..... 142
7.3.6 AWS Elastic Block Store................................ 143
7.3.7 GCE Persistent Disk ....................................... 144
7.4 Persistent Volume和 Persistent Volume Claim.......... 145
7.4.1 创建 Persistent Volume ................................... 147
7.4.2 创建 Persistent Volume Claim ........................ 149
7.5信息数据卷 ......... 151
7.5.1 Secret ....... 151
7.5.2 Downward API ............................................... 153
7.5.3 Git Repo ... 155
第 8章 访问 Kubernetes API ............................... 157
8.1 API对象与元数据 ..................................................... 157
8.2如何访问 Kubernetes API.......................................... 159
8.3使用命令行工具 kubectl ............................................ 160
8.3.1 配置 Kubeconfig............................................. 161
8.3.2 Kubernetes操作 ............................................. 163
8.3.3 API对象操作 ................................................. 164
8.3.4 Pod操作 .. 168
8.3.5 Replication Controller操作 ............................ 169
8.3.6 Service操作 ................................................... 170
第 2部分 Kubernetes高级篇
第 9章 Kubernetes网络 ..................................... 172
9.1 Docker网络模型 . 172
9.2 Kubernetes网络模型 ................................................. 173
9.3容器间通信 ......... 174
9.4 Pod间通信 .......... 176
9.4.1 Flannel实现 Kubernetes覆盖网络 ............... 177
9.4.2 使用 Open vSwitch实现 Kubernetes覆盖网络 ................................................... 180
9.5 Service到 Pod通信 ................................................... 183
9.5.1 Userspace模式 ............................................... 184
9.5.2 Iptables模式 ................................................... 186
第 10章 Kubernetes安全 ................................... 189
10.1 Kubernetes安全原则 ............................................... 189
10.2 Kubernetes API的安全访问 .................................... 189
10.2.1 HTTPS . 190
10.2.2认证与授权 ................................................ 191
10.2.3 准入控制 Admission Controller................. 194
10.3 Service Account . 195
10.3.1 使用默认 Service Account ......................... 196
10.3.2创建自定义 Service Account ..................... 199
10.3.3 Service Account添加 Image Pull Secret .... 201
10.4容器安全 ........... 202
10.4.1 Linux Capability ......................................... 202
10.4.2 SELinux ...................................................... 204
10.5 多租户 ............... 204
第 11章 Kubernetes资源管理 ............................ 206
11.1 Kubernetes资源模型 ............................................... 206
11.2资源请求和限制  207
11.3 Limit Range ....... 210
11.4 Resource Quota.. 215
第 12章 管理和运维 Kubernetes ......................... 219
12.1 Daemon Pod ....... 219
12.1.1 Static Pod .................................................... 219
12.1.2 Daemon Set ................................................ 221
12.2 Kubernetes的高可用性 ........................................... 222
12.3平台监控 ........... 224
12.3.1 cAdvisor ..................................................... 224
12.3.2 Heapster ...................................................... 228
12.4平台日志 ........... 230
12.5垃圾清理 ........... 234
12.5.1 镜像清理 .................................................... 235
12.5.2 容器清理 .................................................... 235
12.6 Kubernetes的 Web界面 .......................................... 235
第 3部分 Kubernetes生态篇
第 13章 CoreOS ................................................. 240
13.1 CoreOS介绍 ..... 240
13.2 CoreOS工具链 . 241
13.2.1 Etcd ...... 241
13.2.2 Flannel . 241
13.2.3 Rocket .. 241
13.2.4 Systemd ...................................................... 241
13.2.5 Fleet ..... 241
13.3 CoreOS实践 ..... 242
13.3.1 安装 CoreOS .............................................. 242
13.3.2 使用 CoreOS运行 Kubernetes .................. 245
第 14章 Etcd 247
14.1 Etcd介绍 ........... 247
14.2 Etcd的结构 .............................................................. 248
14.2.1 Client-to-Server .......................................... 249
14.2.2 Peer-to-Peer ................................................ 250
14.3 Etcd实践 ........... 250
14.3.1 运行 Etcd .................................................... 250
14.3.2 Etcd集群化 ................................................ 251
14.3.3 Etcd Proxy模式 ......................................... 258
14.3.4 Etcd的安全模式 ........................................ 259
第 15章 Mesos ................................................... 262
15.1 Mesos介绍 ........ 262
15.2 Mesos的架构 .... 263
15.3 Marathon和 K8SM介绍 ......................................... 264
15.3.1 Marathon..................................................... 264
15.3.2 K8SM .. 265
15.4 Mesos实践 ........ 266
15.4.1 运行 Mesos ................................................. 266
15.4.2 运行 Marathon ............................................ 268
15.4.3 运行 K8SM ................................................ 270
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Kubernetes实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>用Mesos框架构建分布式应用
序  ix
第1 章 Mesos 介绍 1
如何使用Mesos2
Mesos 作为部署系统 3
Mesos 作为执行平台 4
本书是如何组织的4
本章小结 5
第2 章 开启Mesos 之旅 7
框架7
Master 和Slave 8
Master8
Slave 10
资源13
配置自定义资源 15
配置slave 属性16
角色16
静态和动态slave 预留 17
任务和执行器 20
CommandExecutor 21
理解mesos.proto 21
不通过Mesos 管理 24
本章小结 25
第3 章 将已有应用程序迁移到Mesos 上27
将Web 应用程序迁移到Mesos 上27
搭建Marathon 28
使用Marathon 30
扩展应用程序 35
使用位置约束 35
运行容器化的应用程序37
挂载主机卷38
健康检查40
应用版本化和滚动升级42
事件总线43
搭建Marathon 上的HAProxy43
在Marathon 上运行Mesos 框架 47
Chronos 是什么47
在Marathon 上运行Chronos48
Chronos 运维注意事项 49
Marathon 上的Chronos ：小结 50
Marathon+Chronos 的备选方案50
Singularity50
Aurora51
本章小结 51
第4 章 为Mesos 创建新的框架53
调度器 53
服务器池调度器 54
工作队列调度器 54
作业处理器调度器 55
没什么用的远程BASH 56
实现基本的作业处理器 62
将任务匹配到Offer 上65
搭建Offers 和Jobs 之间语义差别的桥梁68
增加高可用性 70
添加核对 76
高级调度器技术77
分布式通信78
强制故障转移 79
合并Offer79
加固调度器80
检查点82
CommandInfo 83
启动进程83
配置进程环境 83
本章小结 84
第5 章 构建Mesos 执行器85
执行器 85
构建工作队列worker 86
运行pickled 任务 86
共享资源86
更好地看护87
增强的日志88
重写CommandExecutor88
引导执行器的安装97
添加心跳 99
高级执行器特性 102
进度报告 103
添加远程日志  104
多个任务 104
本章小结  106
第6 章 Mesos 的进阶主题 107
libprocess 和actor 模型  107
一致性模型  108
如何处理slave 的故障  109
如何处理master（或者registry）的故障 110
故障转移期间的核对 111
容器机  112
使用Docker. 113
新的Offer API 114
框架动态预留API 114
数据库使用的持久化卷 118
本章小结  119
第7 章 Mesos 的未来121
多租户工作负载 121
超配 123
数据库和Turnkey 基础架构  125
基于容器的IP  125
本章小结  126
索引 129
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>用Mesos框架构建分布式应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务运维实战（第一卷）
第1章  DevOps的理想 1
1.1  持续集成、交付和部署 2
架构 3
部署 4
编排 5
1.2  部署流水线的曙光 5
第2章  实现突破——持续部署、微服务和容器 7
2.1  持续集成 7
推送到代码库 9
静态分析 10
部署前测试 12
打包并部署到测试环境 13
部署后测试 13
2.2  持续交付和部署 15
微服务 18
容器 18
2.3  三个火枪手——持续部署、微服务和容器的协作 20
第3章  系统架构 23
3.1  单块应用 24
微服务 27
3.2  单块应用与微服务的比较 29
运维和部署的复杂性 30
规模 31
部署、回滚和故障隔离 32
承诺期限 32
3.3  微服务的最佳实践 41
容器 41
3.4  代理微服务或API网关 44
反向代理 44
极简主义方法 45
配置管理 45
跨职能团队 45
API版本化 46
最后的思考 46
第4章  使用Vagrant和Docker搭建开发环境 49
4.1  结合微服务架构和容器技术 50
Vagrant与Docker 52
4.2  开发环境搭建 55
开发环境使用 58
第5章  部署流水线的实现——初始阶段 63
5.1  启动持续部署虚拟机 63
5.2  部署流水线步骤 65
构建Docker容器 67
第6章  Docker世界中的配置管理 79
6.1  CFEngine 79
Puppet 80
Chef 80
最后几点思考 82
配置生产环境 83
设置Ansible Playbook 86
第7章  部署管道的实现——中间阶段 91
7.1  在生产服务器上部署容器 92
检查清单 97
第8章  发现服务——分布式服务的关键 99
8.1  服务注册表 101
服务注册 101
主动注册 102
注册服务 103
服务发现 103
服务发现工具 104
手动配置 106
Zookeeper 106
etcd 107
配置Registrator 130
Consul Health Checks、Web UI和数据中心 138
8.2  服务发现工具的比较 141
第9章  代理服务 143
9.1  反向代理服务 144
代理服务对我们的项目有何帮助 146
nginx 146
nginx 146
HAProxy 158
9.2  代理工具的比较 163
第10章  部署流水线的实现——后期阶段 167
10.1  启动容器 169
10.2  集成服务 170
10.3  运行部署后测试 171
10.4  将测试容器推送到镜像库 172
10.5  检查表 173
第11章  部署流水线的自动化实现 175
11.1  部署流水线的步骤 175
Playbook和Role 178
部署前任务 179
部署任务 182
部署后任务 185
11.2  运行自动部署流水线 186
第12章  持续集成、交付和部署的工具 187
12.1  CI/CD工具对比 188
CI/CD工具的简史 189
运行Jenkins作业 203
创建Jenkins Workflow作业 206
安装Jenkins Multibranch Workflow和Jenkinsfile 215
最后的想法 217
第13章  蓝绿部署 219
13.1  蓝绿部署的流程 220
13.2  手动执行蓝绿部署 223
部署蓝色版本 224
集成蓝色版本 226
部署绿色版本 228
集成绿色版本 230
移除蓝色版本 231
发现应部署哪个版本以及回滚 233
13.3  使用Jenkins workflow自动化蓝绿部署 239
蓝绿部署角色 240
运行蓝绿部署 245
第14章  服务集群和扩展 249
14.1  可扩展性 250
轴线扩展 252
集群 254
Docker集群工具大比拼——Kubernetes、Docker Swarm和
Mesos对比 256
搭建 258
运行容器 260
选择 262
14.2  Docker Swarm漫步 263
14.3  搭建Docker Swarm 268
使用Docker Swarm部署 274
使用Docker Swarm无链接部署 275
使用Docker Swarm和Docker Networking部署 276
使用Docker Swarm扩展服务 283
根据预留的CPU和内存调度容器 284
14.4  使用Docker Swarm和Ansible自动化部署 288
检验Swarm部署playbook 290
第15章  自我修复系统 297
15.1  自我修复等级和类型 298
应用程序级别的自我修复 299
系统级别的自我修复 300
硬件级别的自我修复 302
反应式自我修复 303
预防式自我修复 303
15.2  自我修复架构 305
15.3  Docker、Consul Watches和Jenkins组成的自我修复系统 311
搭建环境 311
15.4  自动设置Consul健康检查和watches来监测硬件 322
15.5  预设扩展和收缩的预防式自我修复 334
采用Docker重启策略的预防式自我修复 339
将On-Premise与云节点结合 341
15.6  自我修复系统（到目前为止）总结 342
第16章  集中日志和监控 343
16.1  集中日志的需求 344
16.2  向ElasticSearch发送日志条目 347
解析文件条目 354
发送日志条目到集中式LogStash 358
发送Docker日志条目到集中式LogStash实例 363
16.3  基于软件数据的自修复系统 375
硬件状态日志 381
基于硬件数据的自修复系统 388
最后的想法 388
第17章  结语 391
附录A  Docker Flow 393
A.1  背景 394
标准搭建环境 394
问题 396
Docker Flow漫谈 398
零停机事件部署新版本 404
索引 415
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务运维实战（第一卷）
