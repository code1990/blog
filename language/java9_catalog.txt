>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Java并发编程（第2版）
第1章　第一步：并发设计原理　　1
1.1　基本的并发概念　　1
1.1.1　并发与并行　　1
1.1.2　同步　　2
1.1.3　不可变对象　　2
1.1.4　原子操作和原子变量　　3
1.1.5　共享内存与消息传递　　3
1.2　并发应用程序中可能出现的问题　　3
1.2.1　数据竞争　　3
1.2.2　死锁　　4
1.2.3　活锁　　4
1.2.4　资源不足　　4
1.2.5　优先权反转　　5
1.3　设计并发算法的方法论　　5
1.3.1　起点：算法的一个串行版本　　5
1.3.2　第1步：分析　　5
1.3.3　第2步：设计　　5
1.3.4　第3步：实现　　6
1.3.5　第4步：测试　　6
1.3.6　第5步：调整　　6
1.3.7　结论　　7
1.4　Java 并发API　　8
1.4.1　基本并发类　　8
1.4.2　同步机制　　8
1.4.3　执行器　　9
1.4.4　Fork/Join 框架　　9
1.4.5　并行流　　9
1.4.6　并发数据结构　　9
1.5　并发设计模式　　10
1.5.1　信号模式　　10
1.5.2　会合模式　　11
1.5.3　互斥模式　　11
1.5.4　多元复用模式　　12
1.5.5　栅栏模式　　12
1.5.6　双重检查锁定模式　　12
1.5.7　读?写锁模式　　13
1.5.8　线程池模式　　14
1.5.9　线程局部存储模式　　14
1.6　设计并发算法的提示和技巧　　14
1.6.1　正确识别独立任务　　14
1.6.2　在尽可能高的层面上实施并发处理　　15
1.6.3　考虑伸缩性　　15
1.6.4　使用线程安全API　　15
1.6.5　绝不要假定执行顺序　　16
1.6.6　在静态和共享场合尽可能使用局部线程变量　　16
1.6.7　寻找更易于并行处理的算法版本　　17
1.6.8　尽可能使用不可变对象　　17
1.6.9　通过对锁排序来避免死锁　　17
1.6.10 使用原子变量代替同步　　18
1.6.11 占有锁的时间尽可能短　　19
1.6.12 谨慎使用延迟初始化　　19
1.6.13 避免在临界段中使用阻塞操作　　19
1.7　小结　　20
第2章　使用基本元素：Thread 和Runnable　　21
2.1　Java 中的线程　　21
2.1.1　Java 中的线程：特征和状态　　22
2.1.2　Thread 类和Runnable 接口　　23
2.2　第一个例子：矩阵乘法　　24
2.2.1　公共类　　24
2.2.2　串行版本　　25
2.2.3　并行版本　　25
2.3　第二个例子：文件搜索　　32
2.3.1　公共类　　32
2.3.2　串行版本　　32
2.3.3　并发版本　　33
2.3.4　对比解决方案　　37
2.4　小结　　38
第3章　管理大量线程：执行器　　39
3.1　执行器简介　　39
3.1.1　执行器的基本特征　　39
3.1.2　执行器框架的基本组件　　40
3.2　第一个例子：k-最近邻算法　　40
3.2.1　k-最近邻算法：串行版本　　41
3.2.2　k-最近邻算法：细粒度并发版本　　42
3.2.3　k-最近邻算法：粗粒度并发版本　　45
3.2.4　对比解决方案　　46
3.3　第二个例子：客户端/服务器环境下的并发处理　　48
3.3.1　客户端/服务器：串行版　　48
3.3.2　客户端/服务器：并行版本　　51
3.3.3　额外的并发服务器组件　　54
3.3.4　对比两种解决方案　　59
3.3.5　其他重要方法　　61
3.4　小结　　62
第4章　充分利用执行器　　63
4.1　执行器的高级特性　　63
4.1.1　任务的撤销　　63
4.1.2　任务执行调度　　64
4.1.3　重载执行器方法　　64
4.1.4　更改一些初始化参数　　64
4.2　第一个例子：高级服务器应用程序　　65
4.2.1　ServerExecutor 类　　65
4.2.2　命令类　　70
4.2.3　服务器部件　　72
4.2.4　客户端部件　　78
4.3　第二个例子：执行周期性任务　　79
4.3.1　公共部件　　79
4.3.2　基础阅读器　　81
4.3.3　高级阅读器　　84
4.4　有关执行器的其他信息　　87
4.5　小结　　87
第5章　从任务获取数据：Callable接口与Future 接口　　88
5.1　Callable 接口和Future 接口简介　　88
5.1.1　Callable 接口　　88
5.1.2　Future 接口　　89
5.2　第一个例子：单词最佳匹配算法　　89
5.2.1　公共类　　90
5.2.2　最佳匹配算法：串行版本　　91
5.2.3　最佳匹配算法：第一个并发版本　　92
5.2.4　最佳匹配算法：第二个并发版本　　95
5.2.5　单词存在算法：串行版本　　96
5.2.6　单词存在算法：并行版本　　98
5.2.7　对比解决方案　　100
5.3　第二个例子：为文档集创建倒排索引　　102
5.3.1　公共类　　103
5.3.2　串行版本　　104
5.3.3　第一个并发版本：每个文档一个任务　　105
5.3.4　第二个并发版本：每个任务多个文档　　109
5.3.5　对比解决方案　　112
5.3.6　其他相关方法　　113
5.4　小结　　113
第6章　运行分为多阶段的任务：Phaser 类　　115
6.1　Phaser 类简介　　115
6.1.1　参与者的注册与注销　　116
6.1.2　同步阶段变更　　116
6.1.3　其他功能　　116
6.2　第一个例子：关键字抽取算法　　117
6.2.1　公共类　　118
6.2.2　串行版本　　121
6.2.3　并发版本　　123
6.2.4　对比两种解决方案　　128
6.3　第二个例子：遗传算法　　129
6.3.1　公共类　　130
6.3.2　串行版本　　132
6.3.3　并发版本　　134
6.3.4　对比两种解决方案　　139
6.4　小结　　141
第7章　优化分治解决方案： Fork/Join 框架　　142
7.1　Fork/Join 框架简介　　142
7.1.1　Fork/Join 框架的基本特征　　143
7.1.2　Fork/Join 框架的局限性　　143
7.1.3　Fork/Join 框架的组件　　144
7.2　第一个例子：k-means 聚类算法　　144
7.2.1　公共类　　145
7.2.2　串行版本　　149
7.2.3　并发版本　　151
7.2.4　对比解决方案　　155
7.3　第二个例子：数据筛选算法　　157
7.3.1　公共特性　　157
7.3.2　串行版　　157
7.3.3　并发版本　　159
7.3.4　对比两个版本　　165
7.4　第三个例子：归并排序算法　　166
7.4.1　共享类　　166
7.4.2　串行版本　　167
7.4.3　并发版本　　169
7.4.4　对比两个版本　　172
7.5　Fork/Join 框架的其他方法　　172
7.6　小结　　173
第8章　使用并行流处理大规模数据集：MapReduce 模型　　174
8.1　流的简介　　174
8.1.1　流的基本特征　　174
8.1.2　流的组成部分　　175
8.1.3　MapReduce 与MapCollect　　177
8.2　第一个例子：数值综合分析应用程序　　178
8.2.1　并发版本　　178
8.2.2　串行版本　　185
8.2.3　对比两个版本　　186
8.3　第二个例子：信息检索工具　　186
8.3.1　约简操作简介　　187
8.3.2　第一种方式：全文档查询　　188
8.3.3　第二种方式：约简的文档查询　　191
8.3.4　第三种方式：生成一个含有结果的HTML 文件　　191
8.3.5　第四种方式：预先载入倒排索引　　194
8.3.6　第五种方式：使用我们的执行器　　195
8.3.7　从倒排索引获取数据：ConcurrentData 类　　196
8.3.8　获取文件中的单词数　　196
8.3.9　获取文件的平均tfxidf 值　　196
8.3.10 获取索引中的最大tfxidf值和最小tfxidf 值　　197
8.3.11 ConcurrentMain 类　　198
8.3.12 串行版　　199
8.3.13 对比两种解决方案　　199
8.4　小结　　202
第9章　使用并行流处理大规模数据集：MapCollect 模型　　203
9.1　使用流收集数据　　203
9.2　第一个例子：无索引条件下的数据搜索　　205
9.2.1　基本类　　205
9.2.2　第一种方式：基本搜索　　207
9.2.3　第二种方式：高级搜索　　209
9.2.4　本例的串行实现　　211
9.2.5　对比实现方案　　211
9.3　第二个例子：推荐系统　　212
9.3.1　公共类　　212
9.3.2　推荐系统：主类　　213
9.3.3　ConcurrentLoaderAccumulator 类　　215
9.3.4　串行版　　216
9.3.5　对比两个版本　　216
9.4　第三个例子：社交网络中的共同联系人　　217
9.4.1　基本类　　218
9.4.2　并发版本　　219
9.4.3　串行版本　　223
9.4.4　对比两个版本　　223
9.5　小结　　224
第10章　异步流处理：反应流　　225
10.1　Java 反应流简介　　225
10.1.1　Flow.Publisher 接口　　226
10.1.2　Flow.Subscriber 接口　　226
10.1.3　Flow.Subscription 接口　　226
10.1.4　SubmissionPublisher 类　　226
10.2　第一个例子：面向事件通知的集中式系统　　 227
10.2.1　Event 类　　227
10.2.2　Producer 类　　 227
10.2.3　Consumer 类　　 228
10.2.4　Main 类　　230
10.3　第二个例子：新闻系统　　231
10.3.1　News 类　　232
10.3.2　发布者相关的类　　232
10.3.3　Consumer 类　　 235
10.3.4　Main 类　　236
10.4　小结　　238
第11章　探究并发数据结构和同步工具　　240
11.1　并发数据结构　　240
11.1.1　阻塞型数据结构和非阻塞型数据结构　　241
11.1.2　并发数据结构　　241
11.1.3　使用新特性　　244
11.1.4　原子变量　　251
11.1.5　变量句柄　　252
11.2　同步机制　　254
11.2.1　CommonTask 类　　255
11.2.2　Lock 接口　　255
11.2.3　Semaphore 类　　256
11.2.4　CountDownLatch 类　　258
11.2.5　CyclicBarrier 类　　259
11.2.6　CompletableFuture 类　　261
11.3　小结　　268
第12章　测试与监视并发应用程序　　269
12.1　监视并发对象　　269
12.1.1　监视线程　　269
12.1.2　监视锁　　270
12.1.3　监视执行器　　272
12.1.4　监视Fork/Join 框架　　273
12.1.5　监视Phaser　　274
12.1.6　监视流API　　275
12.2　监视并发应用程序　　276
12.2.1　Overview 选项卡　　278
12.2.2　Memory 选项卡　　279
12.2.3　Threads 选项卡　　280
12.2.4　Classes 选项卡　　280
12.2.5　VM Summary 选项卡　　281
12.2.6　MBeans 选项卡　　283
12.2.7　About 选项卡　　284
12.3　测试并发应用程序　　284
12.3.1　使用MultithreadedTC 测试并发应用程序　　285
12.3.2　使用Java Pathfinder 测试并发应用程序　　288
12.4　小结　　293
第13章　JVM 中的并发处理：Clojure、带有GPars 库的Groovy 以及Scala　　294
13.1　Clojure 的并发处理　　294
13.1.1　使用Java 元素　　295
13.1.2　引用类型　　295
13.1.3　Ref 对象　　298
13.1.4　Delay　　299
13.1.5　Future　　300
13.1.6　Promise　　301
13.2　Groovy 及其GPars 库的并发处理　　302
13.3　软件事务性内存　　302
13.3.1　使用Java 元素　　302
13.3.2　数据并行处理　　303
13.3.3　Fork/Join 处理　　307
13.3.4　Actor　　308
13.3.5　Agent　　315
13.3.6　Dataf low　　316
13.4　Scala 的并发处理　　322
13.4.1　Scala 中的Future 对象　　322
13.4.2　Promise　　328
13.5　小结　　329
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Java并发编程（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 9模块化开发
目录
前言  1
第一部分 Java模块系统介绍
第1章 模块化概述  8
1.1 什么是模块化  9
1.2 在Java 9之前  10
1.2.1 将JAR作为模块？  11
1.2.2 类路径地狱  13
1.3 Java 9模块  14
第2章 模块和模块化JDK  18
2.1 模块化JDK  19
2.2 模块描述符  22
2.3 可读性  23
2.4 可访问性  24
2.5 隐式可读性  25
2.6 限制导出  29
2.7 模块解析和模块路径  29
2.8 在不使用模块的情况下使用模块化JDK  31
第3章 使用模块  33
3.1 第一个模块  33
3.1.1 剖析模块  33
3.1.2 命名模块  35
3.1.3 编译  36
3.1.4 打包  37
3.1.5 运行模块  37
3.1.6 模块路径  39
3.1.7 链接模块  40
3.2 任何模块都不是一座孤岛  41
3.2.1 EasyText示例介绍  41
3.2.2 两个模块  43
3.3 使用平台模块  46
3.3.1 找到正确的平台模块  46
3.3.2 创建GUI模块  47
3.4 封装的限制  51
第4章 服务  54
4.1 工厂模式  54
4.2 用于实现隐藏的服务  57
4.2.1 提供服务  57
4.2.2 消费服务  59
4.2.3 服务生命周期  61
4.2.4 服务提供者方法  62
4.3 工厂模式回顾  64
4.4 默认服务实现  65
4.5 服务实现的选择  66
4.6 具有服务绑定的模块解析  68
4.7 服务和链接  70
第5章 模块化模式  73
5.1 确定模块边界  74
5.2 精益化模块  76
5.3 API模块  76
5.3.1 API模块中应该包含什么  77
5.3.2 隐式可读性  78
5.3.3 带有默认实现的API模块  81
5.4 聚合器模块  82
5.4.1 在模块上构建一个外观  83
5.4.2 安全拆分模块  84
5.5 避免循环依赖  86
5.5.1 拆分包  86
5.5.2 打破循环  87
5.6 可选的依赖关系  90
5.6.1 编译时依赖关系  91
5.6.2 使用服务实现可选依赖关系  95
5.7 版本化模块  96
5.8 资源封装  99
5.8.1 从模块加载资源  100
5.8.2 跨模块加载资源  101
5.8.3 使用ResourceBundle类  102
第6章 高级模块化模式  104
6.1 重温强封装性  104
6.1.1 深度反射  105
6.1.2 开放式模块和包  106
6.1.3 依赖注入  109
6.2 对模块的反射  111
6.2.1 内省  112
6.2.2 修改模块  113
6.2.3 注释  114
6.3 容器应用程序模式  115
6.3.1 层和配置  116
6.3.2 层中的类加载  119
6.3.3 插件体系结构  122
6.3.4 容器体系结构  127
6.3.5 解析容器中的平台模块  132
第二部分 迁移
第7章 没有模块的迁移  134
7.1 类路径已经“死”了？  135
7.2 库、强封装和JDK 9类路径  135
7.3 编译和封装的API  138
7.4 删除的类型  141
7.5 使用JAXB和其他Java EE API  142
7.6 jdk.unsupported模块  145
7.7 其他更改  146
第8章 迁移到模块  148
8.1 迁移策略  148
8.2 一个简单示例  149
8.3 混合类路径和模块路径  150
8.4 自动模块  152
8.5 开放式包  155
8.6 开放式模块  157
8.7 破坏封装的VM参数  158
8.8 自动模块和类路径  158
8.9 使用jdeps  161
8.10 动态加载代码  164
8.11 拆分包  166
第9章 迁移案例研究：Spring和Hibernate  167
9.1 熟悉应用程序  167
9.2 使用Java 9在类路径上运行  172
9.3 设置模块  173
9.4 使用自动模块  174
9.5 Java平台依赖项和自动模块  176
9.6 开放用于反射的包  176
9.7 解决非法访问问题  177
9.8 重构到多个模块  178
第10章 库迁移  180
10.1 模块化之前  181
10.2 选择库模块名称  181
10.3 创建模块描述符  184
10.4 使用模块描述符更新库  186
10.5 针对较旧的Java版本  187
10.6 库模块依赖关系  188
10.6.1 内部依赖关系  188
10.6.2 外部依赖关系  191
10.7 针对多个Java版本  192
10.7.1 多版本JAR  192
10.7.2 模块化多版本JAR  195
第三部分 模块化开发工具
第11章 构建工具和IDE  198
11.1 Apache Maven  198
11.1.1 多模块项目  200
11.1.2 使用Apache Maven创建EasyText示例  200
11.1.3 使用Apache Maven运行模块化的应用程序  204
11.2 Gradle  205
11.3 IDE  205
第12章 测试模块  207
12.1 黑盒测试  208
12.2 使用JUnit进行黑盒测试  210
12.3 白盒测试  212
12.4 测试工具  216
第13章 使用自定义运行时映像进行缩减  217
13.1 静态链接和动态链接  218
13.2 使用jlink  219
13.3 查找正确的服务提供者模块  223
13.4 链接期间的模块解析  223
13.5 基于类路径应用程序的jlink  224
13.6 压缩大小  225
13.7 提升性能  227
13.8 跨目标运行时映像  228
第14章 模块化的未来  229
14.1 OSGi  230
14.2 Java EE  232
14.3 微服务  232
14.4 下一步  233
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 9模块化开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 9 口袋指南（第4版）
前言  XIII
第1 部分 语言
第1 章 命名约定  3
缩略词  3
注解名  3
类名  4
常量名  4
枚举名称  4
泛型类型参数名  4
实例与静态变量名  5
接口名  5
方法名  5
包名  5
模块名  6
参数和本地变量名  6
第2 章 词法元素  9
Unicode 与ASCII  9
压缩字符串  11
注释  11
关键字  12
识别符  13
分隔符  14
操作符  15
字面量  16
转义序列  19
Unicode 货币符号  20
第3 章 基本类型  23
原始类型  23
原始类型的字面量  24
浮点实体  26
原始类型的数值提升  28
包装类  29
自动装箱和拆箱  30
第4 章 引用类型  33
引用类型与原始类型的对比  34
默认值  34
引用对象的转换  36
原始类型与引用类型的转换  37
传递引用类型到方法中  37
引用类型的对比  38
拷贝引用类型  40
引用类型的内存分配与垃圾回收  42
第5 章 面向对象编程  43
类和对象  43
可变长度的参数列表  49
抽象类与抽象方法  50
静态数据成员、静态方法、静态常量以及静态初始化器  51
接口  52
枚举  53
注解类型  54
函数式接口  56
第6 章 语句和代码块  57
表达式语句  57
空语句  58
代码块  58
条件语句  58
迭代语句  60
控制转移  62
synchronized 语句  63
断言语句  63
异常处理语句  64
第7 章 异常处理  65
异常层级结构  65
检查型/ 非检查型异常和错误  66
常见的检查型/ 非检查型异常和错误  67
异常处理的关键字  69
异常处理的过程  74
定义自己的异常类  74
打印异常信息  75
第8 章 Java 修饰符  77
访问修饰符  78
其他（非访问）修饰符  79
修饰符的编码  80
第2 部分 平台
第9 章 Java 平台，标准版  83
常用的Java SE API 库  83
第10 章 开发的基础工具  97
Java 运行时环境  97
Java 开发工具集  97
Java 程序结构  99
命令行工具  100
类路径  105
第11 章 内存管理  107
垃圾收集器  107
内存管理工具  109
命令行参数  110
调整Java 堆的大小  113
元空间  113
与GC 进行交互  113
第12 章 基本输入和输出  115
标准的流in、out 和err  115
标准输入和输出类的层级结构  116
文件读取和写入  117
Socket 读取和写入  118
序列化  120
压缩和解压文件  121
第13 章 新I/O API（NIO.2）  123
Path 接口  123
Files 类  124
其他特性  125
第14 章 并发  127
创建线程  127
线程状态  128
线程优先级  129
常用方法  129
同步  130
并发工具集  132
第15 章 Java 集合框架  135
Collection 接口  135
实现  136
集合框架方法  136
集合类的算法  137
算法的效率  138
Comparator 函数式接口  139
便利的工厂方法  142
第16 章 泛型框架  143
泛型类与接口  143
具有泛型的构造器  144
替换原则  145
类型参数、通配符与边界  145
Get 和Put 原则  146
泛型具体化  147
非泛型类型中的泛型方法  148
第17 章 Java 脚本API  149
脚本语言  149
脚本引擎实现  149
搭建脚本语言和引擎环境  151
第18 章 日期和时间API  155
与遗留系统的互操作  156
区域性日历  156
ISO 日历  156
第19 章 Lambda 表达式  163
λE 基础  163
特定用途的函数式接口  166
通用的函数式接口  167
关于λE 的资源  168
第20 章 JShell ：Java Shell  171
起步  171
片段  172
使用JShell  173
JShell 的特性  180
JShell 命令小结  184
第21 章 Java 模块系统  187
Jigsaw 项目  187
Java 模块  188
编译模块  190
模块化JDK  191
jdeps  194
定义模块  196
导出包  196
声明依赖  197
传递性依赖  197
定义服务提供者  198
jlink  200
第3 部分 附录
附录A Fluent API  203
附录B 第三方工具  205
附录C UML 基础  215
索引  225
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 9 口袋指南（第4版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 9 并发编程实战
第 1章 线程管理 1
1.1 简介 1
1.2 线程的创建、运行和设置 2
1.3 线程中断 8
1.4 控制线程中断 11
1.5 线程的休眠和唤醒 14
1.6 等待线程执行结束 16
1.7 守护线程的创建与运行 19
1.8 处理线程中的不可控异常 23
1.9 使用线程本地变量 26
1.10 线程分组及线程组中不可控异常的处理 29
1.11 使用工厂创建线程 33
第 2章 线程同步基础 37
2.1 简介 37
2.2 方法同步 38
2.3 在同步代码块中使用条件 46
2.4　在同步代码块中使用锁机制 51
2.5 用读/写锁保护同步代码块 57
2.6 在一个锁中使用多个条件 62
2.7 高阶知识：StampedLock的使用 70
第3章 线程同步工具 78
3.1 简介 78
3.2 控制对资源的一个或多个副本的并发访问 79
3.3 等待多个并发事件 85
3.4 在指定状态点同步任务 90
3.5 运行阶段性并发任务 98
3.6 阶段性并发任务中阶段转变的控制 108
3.7 两个并发任务间的数据交换 114
3.8 异步地完成和关联任务 118
第4章 线程执行器 128
4.1 简介 128
4.2 创建一个线程执行器并实现其拒绝策略 129
4.3 在一个执行器里执行任务并返回结果 136
4.4 运行多个任务并处理第 一个返回结果 140
4.5 运行多个任务并处理全部返回结果 146
4.6 在执行器内延迟运行任务 150
4.7 在执行器内周期性地运行任务 154
4.8 在执行器内取消任务 157
4.9 在执行器内控制任务的完成 160
4.10 在执行器内分离任务的启动并处理返回结果 164
第5章 fork/join框架 171
5.1 简介 171
5.2 创建一个fork/join池 173
5.3 合并任务的执行结果 180
5.4 异步地运行任务 189
5.5 在任务中抛出异常 196
5.6 取消一个任务 200
第6章 并行反应式流 208
6.1 简介 208
6.2 使用不同的源创建流 210
6.3 归约一个流的元素 217
6.4 收集流中的元素 224
6.5 把一个动作应用到流的每个元素上 231
6.6 过滤流中的元素 234
6.7 转换流中的元素 237
6.8 排序流中的元素 241
6.9 在流中的元素上验证条件 244
6.10 在反应式流上反应式编程 248
第7章 并发集合 256
7.1 简介 256
7.2 运用非阻塞线程安全的双端队列 257
7.3 运用阻塞线程安全的双端队列 262
7.4 运用按优先级排序的阻塞线程安全队列 265
7.5 运用带延迟元素的线程安全列表 271
7.6 运用线程安全的跳表 276
7.7 运用线程安全的HashMap 281
7.8 运用原子性变量 287
7.9 运用原子性数组 294
7.10 运用volatile关键字 298
7.11 运用变量句柄 302
第8章 自定义并发类 307
8.1 简介 307
8.2 自定义ThreadPoolExecutor类 308
8.3 实现一个基于优先级的Executor类 313
8.4 实现ThreadFactory接口来生成自定义线程 317
8.5 在一个Executor对象中使用ThreadFactory 322
8.6 自定义在一个周期调度性线程池中运行的任务 324
8.7 实现一个ThreadFactory以生成fork/join框架的自定义线程 331
8.8 自定义运行于fork/join框架中的任务 338
8.9 实现一个自定义Lock类 342
8.10 实现一个基于优先级的传递队列 348
8.11 实现自己的原子性对象 359
8.12 实现自己的流生成器 363
8.13 实现自己的异步流 369
第9章 并发程序的测试 378
9.1 简介 378
9.2 监测Lock接口 379
9.3　监测Phaser类 383
9.4　监测Executor框架 387
9.5 监测fork/join任务池 390
9.6 监测流 395
9.7　输出有效日志信息 397
9.8　利用FindBugs分析并发程序代码 402
9.9　使用Eclipse调试并发程序代码 406
9.10　使用NetBeans调试并发程序代码 408
9.11 使用MultithreadedTC调试并发程序代码 413
9.12 使用JConsole监测 416
第 10章 附加信息 421
10.1 简介 421
10.2 在Executor框架中处理Runnable对象的结果 421
10.3 在ForkJoinPool类中处理未控制的异常 427
10.4 使用线程安全的阻塞队列在生产者和消费者之间进行交互 431
10.5 监测Thread类 436
10.6 监测Semaphore类 440
10.7 生成并发随机数 443
第 11章 并发编程设计 445
11.1 简介 445
11.2 尽可能使用不可变对象 446
11.3 对锁排序以避免死锁 449
11.4 使用原子变量替代同步 451
11.5 尽可能短地持有锁 455
11.6 委托执行器管理线程 459
11.7 使用并发数据结构替代手动编程 462
11.8 使用延迟初始化预防问题 464
11.9 使用fork/join框架替代执行器 466
11.10 避免在锁中使用阻塞操作 470
11.11 避免使用已弃用的方法 472
11.12 使用执行器替代线程组 473
11.13 使用流处理大数据集 474
11.14 其他提示和技巧 479
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 9 并发编程实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java核心技术·卷1：基础知识（原书第9版）
译者序
前言
致谢
第1章 Java程序设计概述
1.1 Java程序设计平台
1.2 Java“白皮书”的关键术语
1.2.1 简单性
1.2.2 面向对象
1.2.3 网络技能
1.2.4 健壮性
1.2.5 安全性
1.2.6 体系结构中立
1.2.7 可移植性
1.2.8 解释型
1.2.9 高性能
1.2.10 多线程
1.2.11 动态性
1.3 Java applet与Internet
1.4 Java发展简史
1.5 关于Java的常见误解
第2章 Java程序设计环境
2.1 安装Java开发工具箱
2.1.1 下载JDK
2.1.2 设置执行路径
2.1.3 安装库源文件和文档
2.1.4 安装本书中的示例
2.1.5 导航Java目录
2.2 选择开发环境
2.3 使用命令行工具
2.4 使用集成开发环境
2.5 运行图形化应用程序
2.6 建立并运行applet
第3章 Java的基本程序设计结构
3.1 一个简单的Java应用程序
3.2 注释
3.3 数据类型
3.3.1 整型
3.3.2 浮点类型
3.3.3 char类型
3.3.4 boolean类型
3.4 变量
3.4.1 变量初始化
3.4.2 常量
3.5 运算符
3.5.1 自增运算符与自减运算符
3.5.2 关系运算符与boolean运算符
3.5.3 位运算符
3.5.4 数学函数与常量
3.5.5 数值类型之间的转换
3.5.6 强制类型转换
3.5.7 括号与运算符级别
3.5.8 枚举类型
3.6 字符串
3.6.1 子串
3.6.2 拼接
3.6.3 不可变字符串
3.6.4 检测字符串是否相等
3.6.5 空串与Null串
3.6.6 代码点与代码单元
3.6.7 字符串API
3.6.8 阅读联机API文档
3.6.9 构建字符串
3.7 输入输出
3.7.1 读取输入
3.7.2 格式化输出
3.7.3 文件输入与输出
3.8 控制流程
3.8.1 块作用域
3.8.2 条件语句
3.8.3 循环
3.8.4 确定循环
3.8.5 多重选择：switch语句
3.8.6 中断控制流程语句
3.9 大数值
3.10 数组
3.10.1 for each循环
3.10.2 数组初始化以及匿名数组
3.10.3 数组拷贝
3.10.4 命令行参数
3.10.5 数组排序
3.10.6 多维数组
3.10.7 不规则数组
第4章 对象与类
4.1 面向对象程序设计概述
4.1.1 类
4.1.2 对象
4.1.3 识别类
4.1.4　类之间的关系
4.2 使用预定义类
4.2.1 对象与对象变量
4.2.2 Java类库中的Gregorian-Calendar类
4.2.3 更改器方法与访问器方法
4.3 用户自定义类
4.3.1 Employee类
4.3.2 多个源文件的使用
4.3.3 剖析Employee类
4.3.4 从构造器开始
4.3.5 隐式参数与显式参数
4.3.6 封装的优点
4.3.7 基于类的访问权限
4.3.8 私有方法
4.3.9 final实例域
4.4 静态域与静态方法
4.4.1 静态域
4.4.2 静态常量
4.4.3 静态方法
4.4.4 工厂方法
4.4.5 main方法
4.5 方法参数
4.6 对象构造
4.6.1 重载
4.6.2 默认域初始化
4.6.3 无参数的构造器
4.6.4 显式域初始化
4.6.5 参数名
4.6.6 调用另一个构造器
4.6.7 初始化块
4.6.8 对象析构与finalize方法
4.7 包
4.7.1 类的导入
4.7.2 静态导入
4.7.3 将类放入包中
4.7.4 包作用域
4.8 类路径
4.9 文档注释
4.9.1 注释的插入
4.9.2 类注释
4.9.3 方法注释
4.9.4 域注释
4.9.5 通用注释
4.9.6 包与概述注释
4.9.7 注释的抽取
4.10 类设计技巧
第5章 继承
5.1 类、超类和子类
5.1.1 继承层次
5.1.2 多态
5.1.3 动态绑定
5.1.4 阻止继承：final类和方法
5.1.5 强制类型转换
5.1.6 抽象类
5.1.7 受保护访问
5.2 Object：所有类的超类
5.2.1 equals方法
5.2.2 相等测试与继承
5.2.3 hashCode方法
5.2.4 toString方法
5.3 泛型数组列表
5.3.1 访问数组列表元素
5.3.2 类型化与原始数组列表的兼容性
5.4 对象包装器与自动装箱
5.5 参数数量可变的方法
5.6 枚举类
5.7 反射
5.7.1 Class类
5.7.2 捕获异常
5.7.3 利用反射分析类的能力
5.7.4 在运行时使用反射分析对象
5.7.5 使用反射编写泛型数组代码
5.7.6 调用任意方法
5.8 继承设计的技巧
第6章 接口与内部类
6.1 接口
6.1.1 接口的特性
6.1.2 接口与抽象类
6.2 对象克隆
6.3 接口与回调
6.4 内部类
6.4.1 使用内部类访问对象状态
6.4.2 内部类的特殊语法规则
6.4.3 内部类是否有用、必要和安全
6.4.4 局部内部类
6.4.5 由外部方法访问final变量
6.4.6 匿名内部类
6.4.7 静态内部类
6.5 代理
第7章 图形程序设计
7.1 Swing概述
7.2 创建框架
7.3 框架定位
7.3.1 框架属性
7.3.2 确定合适的框架大小
7.4 在组件中显示信息
7.5 处理2D图形
7.6 使用颜色
7.7 文本使用特殊字体
7.8 显示图像
第8章 事件处理
8.1 事件处理基础
8.1.1 实例：处理按钮点击事件
8.1.2 建议使用内部类
8.1.3 创建包含一个方法调用的监听器
8.1.4 实例：改变观感
8.1.5 适配器类
8.2 动作
8.3 鼠标事件
8.4 AWT事件继承层次
第9章 Swing用户界面组件
9.1 Swing和模型-视图-控制器设计模式
9.1.1 设计模式
9.1.2 模型-视图-控制器模式
9.1.3 Swing按钮的模型-视图-控制器分析
9.2 布局管理概述
9.2.1 边框布局
9.2.2 网格布局
9.3 文本输入
9.3.1 文本域
9.3.2 标签和标签组件
9.3.3 密码域
9.3.4 文本区
9.3.5 滚动窗格
9.4 选择组件
9.4.1 复选框
9.4.2 单选按钮
9.4.3 边框
9.4.4 组合框
9.4.5 滑动条
9.5 菜单
9.5.1 菜单创建
9.5.2 菜单项中的图标
9.5.3 复选框和单选按钮菜单项
9.5.4 弹出菜单
9.5.5 快捷键和加速器
9.5.6 启用和禁用菜单项
9.5.7 工具栏
9.5.8 工具提示
9.6 复杂的布局管理
9.6.1 网格组布局
9.6.2 组布局
9.6.3 不使用布局管理器
9.6.4 定制布局管理器
9.6.5 遍历顺序
9.7 对话框
9.7.1 选项对话框
9.7.2 创建对话框
9.7.3 数据交换
9.7.4 文件对话框
9.7.5 颜色选择器
第10章 部署应用程序和applet
10.1 JAR文件
10.1.1 清单文件
10.1.2 可运行JAR文件
10.1.3 资源
10.1.4 密封
10.2 Java Web Start
10.2.1 沙箱
10.2.2 签名代码
10.2.3 JNLP API
10.3 applet
10.3.1 一个简单的applet
10.3.2 applet的HTML标记和属性
10.3.3 object标记
10.3.4 使用参数向applet传递信息
10.3.5 访问图像和音频文件
10.3.6 applet上下文
10.4 应用程序首选项存储
10.4.1 属性映射
10.4.2 Preferences API
第11章 异常、断言、日志和调试
11.1 处理错误
11.1.1 异常分类
11.1.2 声明已检查异常
11.1.3 如何抛出异常
11.1.4 创建异常类
11.2 捕获异常
11.2.1 捕获多个异常
11.2.2 再次抛出异常与异常链
11.2.3 finally子句
11.2.4 带资源的try语句
11.2.5 分析堆栈跟踪元素
11.3 使用异常机制的技巧
11.4 使用断言
11.4.1 启用和禁用断言
11.4.2 使用断言完成参数检查
11.4.3 为文档假设使用断言
11.5 记录日志
11.5.1 基本日志
11.5.2 高级日志
11.5.3 修改日志管理器配置
11.5.4 本地化
11.5.5 处理器
11.5.6 过滤器
11.5.7 格式化器
11.5.8 日志记录说明
11.6 调试技巧
11.7 GUI程序排错技巧
11.8 使用调试器
第12章 泛型程序设计
12.1 为什么要使用泛型程序设计
12.2 定义简单泛型类
12.3 泛型方法
12.4 类型变量的限定
12.5 泛型代码和虚拟机
12.5.1 翻译泛型表达式
12.5.2 翻译泛型方法
12.5.3 调用遗留代码
12.6 约束与局限性
12.6.1 不能用基本类型实例化类型参数
12.6.2 运行时类型查询只适用于原始类型
12.6.3 不能创建参数化类型的数组
12.6.4 Varargs警告
12.6.5 不能实例化类型变量
12.6.6 泛型类的静态上下文中类型变量无效
12.6.7 不能抛出或捕获泛型类的实例
12.6.8 注意擦除后的冲突
12.7 泛型类型的继承规则
12.8 通配符类型
12.8.1 通配符的超类型限定
12.8.2 无限定通配符
12.8.3 通配符捕获
12.9 反射和泛型
12.9.1 使用Class参数进行类型匹配
12.9.2 虚拟机中的泛型类型信息
第13章 集合
13.1 集合接口
13.1.1 将集合的接口与实现分离
13.1.2 Java类库中的集合接口和迭代器接口
13.2 具体的集合
13.2.1 链表
13.2.2 数组列表
13.2.3 散列集
13.2.4 树集
13.2.5 对象的比较
13.2.6 队列与双端队列
13.2.7 优先级队列
13.2.8 映射表
13.2.9 专用集与映射表类
13.3 集合框架
13.3.1 视图与包装器
13.3.2 批操作
13.3.3 集合与数组之间的转换
13.4 算法
13.4.1 排序与混排
13.4.2 二分查找
13.4.3 简单算法
13.4.4 编写自己的算法
13.5 遗留的集合
13.5.1 Hashtable类
13.5.2 枚举
13.5.3 属性映射表
13.5.4 栈
13.5.5 位集
第14章 多线程
14.1 什么是线程
14.2 中断线程
14.3 线程状态
14.3.1 新创建线程
14.3.2 可运行线程
14.3.3 被阻塞线程和等待线程
14.3.4 被终止的线程
14.4 线程属性
14.4.1 线程优先级
14.4.2 守护线程
14.4.3 未捕获异常处理器
14.5 同步
14.5.1 竞争条件的一个例子
14.5.2 竞争条件详解
14.5.3 锁对象
14.5.4 条件对象
14.5.5 synchronized关键字
14.5.6 同步阻塞
14.5.7 监视器概念
14.5.8 Volatile域
14.5.9 final变量
14.5.10 原子性
14.5.11 死锁
14.5.12 线程局部变量
14.5.13 锁测试与超时
14.5.14 读/写锁
14.5.15 为什么弃用stop和suspend方法
14.6 阻塞队列
14.7 线程安全的集合
14.7.1 高效的映射表、集合和队列
14.7.2 写数组的拷贝
14.7.3 较早的线程安全集合
14.8 Callable与Future
14.9 执行器
14.9.1 线程池
14.9.2 预定执行
14.9.3 控制任务组
14.9.4 Fork-Join框架
14.10 同步器
14.10.1 信号量
14.10.2 倒计时门栓
14.10.3 障栅
14.10.4 交换器
14.10.5 同步队列
14.11 线程与Swing
14.11.1 运行耗时的任务
14.11.2 使用Swing工作线程
14.11.3 单一线程规则
附录　Java关键字
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java核心技术·卷1：基础知识（原书第9版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java核心技术（卷2）：高级特性（原书第9版）
译者序
前言
第1章　流与文件	1
1.1　流	1
1.1.1　读写字节	1
1.1.2　完整的流家族	3
1.1.3　组合流过滤器	7
1.2　文本输入与输出	10
1.2.1　如何写出文本输出	10
1.2.2　如何读入文本输入	13
1.2.3　以文本格式存储对象	13
1.2.4　字符集	16
1.3　读写二进制数据	20
1.4　ZIP文档	27
1.5　对象流与序列化	29
1.5.1　理解对象序列化的文件格式	34
1.5.2　修改默认的序列化机制	39
1.5.3　序列化单例和类型安全的枚举	40
1.5.4　版本管理	42
1.5.5　为克隆使用序列化	44
1.6　操作文件	46
1.6.1　Path	46
1.6.2　读写文件	48
1.6.3　复制、移动和删除文件	49
1.6.4　创建文件和目录	50
1.6.5　获取文件信息	51
1.6.6　迭代目录中的文件	53
1.6.7　ZIP文件系统	55
1.7　内存映射文件	56
1.7.1　缓冲区数据结构	62
1.7.2　文件加锁机制	64
1.8　正则表达式	66
第2章　XML	76
2.1　XML概述	76
2.2　解析XML文档	81
2.3　验证XML文档	91
2.3.1　文档类型定义	92
2.3.2　XML Schema	98
2.3.3　实用示例	101
2.4　使用XPath来定位信息	113
2.5　使用命名空间	119
2.6　流机制解析器	121
2.6.1　使用SAX解析器	122
2.6.2　使用StAX解析器	126
2.7　生成XML文档	129
2.7.1　不带命名空间的文档	130
2.7.2　带命名空间的文档	130
2.7.3　写出文档	131
2.7.4　示例：生成SVG文件	131
2.7.5　使用StAX写XML文档	133
2.8　XSL转换	140
第3章　网络	151
3.1　连接到服务器	151
3.1.1　套接字超时	155
3.1.2　因特网地址	156
3.2　实现服务器	157
3.2.1　为多个客户端服务	160
3.2.2　半关闭	163
3.3　可中断套接字	164
3.4　获取Web数	171
3.4.1　URL和URI	171
3.4.2　使用URLConnection获取信息	173
3.4.3　提交表单数据	181
3.5　发送E-mail	187
第4章　数据库编程	191
4.1　JDBC的设计	191
4.1.1　JDBC驱动程序类型	192
4.1.2　JDBC的典型用法	193
4.2　结构化查询语言	194
4.3　JDBC配置	198
4.3.1　数据库URL	199
4.3.2　驱动程序JAR文件	199
4.3.3　启动数据库	199
4.3.4　注册驱动器类	200
4.3.5　连接到数据库	201
4.4　执行SQL语句	203
4.4.1　管理连接、语句和结果集	206
4.4.2　分析SQL异常	207
4.4.3　组装数据库	209
4.5　执行查询操作	212
4.5.1　预备语句	212
4.5.2　读写LOB	218
4.5.3　SQL转义	219
4.5.4　多结果集	220
4.5.5　获取自动生成键	221
4.6　可滚动和可更新的结果集	222
4.6.1　可滚动的结果集	222
4.6.2　可更新的结果集	224
4.7　行集	228
4.7.1　构建行集	228
4.7.2　被缓存的行集	229
4.8　元数据	231
4.9　事务	240
4.9.1　保存点	241
4.9.2　批量更新	241
4.9.3　高级SQL类型	243
4.10　Web与企业应用中的连接管理	244
第5章　国际化	246
5.1　Locales 	246
5.2　数字格式	251
5.3　日期和时间	257
5.4　排序	264
5.4.1　排序强度	265
5.4.2　分解	265
5.5　消息格式化	270
选择格式	272
5.6　文本文件和字符集	273
源文件的字符编码	274
5.7　资源包	275
5.7.1　定位资源包	275
5.7.2　属性文件	276
5.7.3　包类	277
5.8　一个完整的例子	278
第6章　高级Swing	293
6.1　列表	293
6.1.1　JList构件	293
6.1.2　列表模式	298
6.1.3　插入和移除值	302
6.1.4　值的绘制	304
6.2　表格	307
6.2.1　简单表格	307
6.2.2　表格模型	310
6.2.3　对行和列的操作	314
6.2.4　单元格的绘制和编辑	328
6.3　树	338
6.3.1　简单的树	339
6.3.2　节点枚举	352
6.3.3　绘制节点	353
6.3.4　监听树事件	356
6.3.5　定制树模型	362
6.4　文本构件	370
6.4.1　文本构件中的修改跟踪	371
6.4.2　格式化的输入框	373
6.4.3　JSpinner构件	388
6.4.4　用JEditorPane显示HTML	395
6.5　进度指示器	401
6.5.1　进度条	401
6.5.2　进度监视器	404
6.5.3　监视输入流的进度	407
6.6　构件组织器和装饰器	411
6.6.1　分割面板	411
6.6.2　选项卡面板	414
6.6.3　桌面面板和内部框体	419
6.6.4　级联与平铺	422
6.6.5　否决属性设置	425
第7章　高级AWT	440
7.1　绘图操作流程	440
7.2　形状	442
7.3　区域	456
7.4　笔划	458
7.5　着色	465
7.6　坐标变换	466
7.7　剪切	471
7.8　透明与组合	473
7.9　绘图提示	481
7.10　图像的读取器和写入器	486
7.10.1　获得图像文件类型的读取器和写入器	487
7.10.2　读取和写入带有多个图像的文件	488
7.11　图像处理	496
7.11.1　构建光栅图像	496
7.11.2　图像过滤	502
7.12　打印	510
7.12.1　图形打印	510
7.12.2　打印多页文件	518
7.12.3　打印预览	520
7.12.4　打印服务程序	528
7.12.5　流打印服务程序	531
7.12.6　打印属性	532
7.13　剪贴板	538
7.13.1　用于数据传递的类和接口	539
7.13.2　传递文本	540
7.13.3　Transferable接口和数据风格	543
7.13.4　构建一个可传递的图像	545
7.13.5　通过系统剪贴板传递Java对象	548
7.13.6　使用本地剪贴板来传递对象引用	552
7.14　拖放操作	552
7.14.1　Swing对数据传递的支持	553
7.14.2　拖曳源	557
7.14.3　放置目标	559
7.15　平台集成	566
7.15.1　闪屏	566
7.15.2　启动桌面应用程序	571
7.15.3　系统托盘	576
第8章　JavaBean构件	581
8.1　为何使用Bean	581
8.2　编写Bean的过程	583
8.3　使用Bean构造应用程序	585
8.3.1　将Bean打包成JAR文件	585
8.3.2　在开发环境中组合Bean	586
8.4　Bean属性与事件的命名模式	591
8.5　Bean属性的类型	594
8.5.1　简单属性	594
8.5.2　索引属性	594
8.5.3　绑定属性	595
8.5.4　约束属性	596
8.6　BeanInfo类	603
8.7　属性编辑器	607
8.8　定制器	616
8.9　JavaBean持久化	624
8.9.1　JavaBean持久化可用于任何数据	628
8.9.2　一个JavaBean持久化的完整示例	633
第9章　安全	644
9.1　类加载器	645
9.1.1　类加载器的层次结构	646
9.1.2　将类加载器作为命名空间	647
9.1.3　编写你自己的类加载器	648
9.2　字节码校验	653
9.3　安全管理器与访问权限	657
9.3.1　Java平台安全性	658
9.3.2　安全策略文件	661
9.3.3　定制权限	667
9.3.4　实现权限类	669
9.4　用户认证	674
9.5　数字签名	687
9.5.1　消息摘要	688
9.5.2　消息签名	691
9.5.3　校验签名	693
9.5.4　认证问题	695
9.5.5　证书签名	697
9.5.6　证书请求	698
9.6　代码签名	699
9.6.1　JAR文件签名	699
9.6.2　软件开发者证书	702
9.7　加密	704
9.7.1　对称密码	705
9.7.2　密钥生成	706
9.7.3　密码流	710
9.7.4　公共密钥密码	711
第10章　脚本、编译与注解处理	716
10.1　Java平台的脚本	716
10.1.1　获取脚本引擎	716
10.1.2　脚本赋值与绑定	717
10.1.3　重定向输入和输出	719
10.1.4　调用脚本的函数和方法	720
10.1.5　编译脚本	722
10.1.6　一个示例：用脚本处理GUI事件	722
10.2　编译器API	727
10.2.1　编译便捷之法	727
10.2.2　使用编译工具	727
10.2.3　一个示例：动态Java代码生成	732
10.3　使用注解	737
10.4　注解语法	743
10.5　标准注解	746
10.5.1　用于编译的注解	747
10.5.2　用于管理资源的注解	748
10.5.3　元注解	748
10.6　源码级注解处理	750
10.7　字节码工程	756
第11章　分布式对象	765
11.1　客户与服务器的角色	765
11.2　远程方法调用	767
11.3　RMI编程模型	769
11.3.1　接口与实现	769
11.3.2　RMI注册表	770
11.3.3　部署程序	774
11.3.4　记录RMI活动的日志	776
11.4　远程方法中的参数和返回值	778
11.4.1　传递远程对象	778
11.4.2　传递非远程对象	779
11.4.3　动态类加载	781
11.4.4　具有多重接口的远程引用	785
11.4.5　远程对象与equals、hashCode和clone方法	786
11.5　远程对象激活	786
第12章　本地方法	792
12.1　从Java程序中调用C函数	793
12.2　数值参数与返回值	797
12.3　字符串参数	799
12.4　访问域	804
12.4.1　访问实例域	804
12.4.2　访问静态域	808
12.5　编码签名	809
12.6　调用Java方法	810
12.6.1　实例方法	810
12.6.2　静态方法	813
12.6.3　构造器	814
12.6.4　替代方法调用	815
12.7　访问数组元素	816
12.8　错误处理	820
12.9　使用调用API	824
12.10　完整的示例：访问Windows注册表	829
12.10.1　Windows注册表概述	829
12.10.2　访问注册表的Java平台接口	830
12.10.3　以本地方法方式实现注册表访问函数	830
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java核心技术（卷2）：高级特性（原书第9版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 8编程参考官方教程
第Ⅰ部分 Java 语言
第1章 Java的历史和演变
1.1 Java的家世
1.1.1 现代编程语言的诞生：C语言
1.1.2 C++：下一个阶段
1.1.3 Java出现的时机已经成熟
1.2 Java的诞生
1.3 Java改变Internet的方式
1.3.1 Java
1.3.2 安全性
1.3.3 可移植性
1.4 Java的魔力：字节码
1.5 servlet：服务器端的
1.6 Java的关键特性
1.6.1 简单性
1.6.2 面向对象
1.6.3 健壮性
1.6.4 多线程
1.6.5 体系结构中立
1.6.6 解释执行和高性能
1.6.7 分布式
1.6.8 动态性
1.7 Java的演变历程
1.8 Java
1.9 文化革新
第2章 Java综述
2.1 面向对象编程
2.1.1 两种范式
2.1.2 抽象
2.1.3 OOP三原则
2.2第一个简单程序
2.2.1 输入程序
2.2.2 编译程序
2.2.3 深入分析第一个示例程序
2.3第二个简短程序
2.4 两种控制语句
2.4.1 if语句
2.4.2 for循环
2.5 使用代码块
2.6 词汇问题
2.6.1 空白符
2.6.2 标识符
2.6.3 字面值
2.6.4 注释
2.6.5 分隔符
2.6.6 Java关键字
2.7 Java类库
第3章 数据类型、变量和数组
3.1 Java是强类型化的语言
3.2 基本类型
3.3 整型
3.3.1
3.3.2
3.3.
3.3.4
3.4 浮点型
3.4.1
3.4.2
3.5 字符型
3.6 布尔型
3.7 深入分析字面值
3.7.1 整型字面值
3.7.2 浮点型字面值
3.7.3 布尔型字面值
3.7.4 字符型字面值
3.7.5 字符串字面值
3.8 变量
3.8.1 变量的声明
3.8.2 动态初始化
3.8.3 变量的作用域和生存期
3.9 类型转换和强制类型转换
3.9.1 Java的自动类型转换
3.9.2 强制转换不兼容的类型
3.10 表达式中的自动类型提升
3.11 数组
3.11.1 一维数组
3.11.2 多维数组
3.11.3 另一种数组声明语法
3.12 关于字符串的一些说明
3.13 向C/C++程序员提供指针方面的说明
第4章 运算符
4.1 算术运算符
4.1.1 基本算术运算符
4.1.2 求模运算符
4.1.3 算术与赋值复合运算符
4.1.4 自增与自减运算符
4.2 位运算符
4.2.1 位逻辑运算符
4.2.2 左移
4.2.3 右移
4.2.4 无符号右移
4.2.5 位运算符与赋值的组合
4.3 关系运算符
4.4 布尔逻辑运算符
4.5 赋值运算符
4.6 “？”运算符
4.7 运算符的优先级
4.8 使用圆括号
第5章 控制语句
5.1 Java的选择语句
19.18.2 java.util.fun
19.18.3 java.uti
19.18.4 java.util.lo
19.18.5 java.util.
19.18.6 java.util.
19.18.7 java.uti
19.18.8 java.util.s
19.18.9 java.uti
第20章 输入/输出：探究ja
20.1 I/O类和接口
20.2 File类
20.2.1 目录
20.2.2 使用FilenameFilter接口
20.2.3 listFiles（）方法
20.2.4 创建目录
20.3 AutoCloseable、Closeable和Flushable接口
20.4 I/O异常
20.5 关闭流的两种方式
20.6 流类
20.7 字节流
20.7.1 InputStream类
20.7.2 OutputStream类
20.7.3 FileInputStream类
20.7.4 FileOutputStream类
20.7.5 ByteArrayInputStream类
20.7.6 ByteArrayOutputStream类
20.7.7 过滤的字节流
20.7.8 缓冲的字节流
20.7.9 SequenceInputStream类
20.7.10 PrintStream类
20.7.11 DataOutputStream和DataInputStream类
20.7.12 RandomAccessFile类
20.8 字符流
20.8.1 Reader类
20.8.2 Writer类
20.8.3 FileReader类
20.8.4 FileWriter类
20.8.5 CharArrayReader类
20.8.6 CharArrayWriter类
20.8.7 BufferedReader类
20.8.8 BufferedWriter类
20.8.9 PushbackReader类
20.8.10 PrintWriter类
20.9 Console类
20.10 串行化
20.10.1 Serializable接口
20.10.2 Externalizable接口
20.10.3 ObjectOutput接口
20.10.4 ObjectOutputStream类
20.10.5 ObjectInput接口
20.10.6 ObjectInputStream类
20.10.7 串行化示例
20.11 流的优点
第21章 探究
21.1 NIO类
21.2 NIO的基础知识
21.2.1 缓冲区
21.2.2 通道
21.2.3 字符集和选择器
21.3 JDK 7对NIO的增强
21.3.1 Path接口
21.3.2 Files类
21.3.3 Path接口
21.3.4 文件属性接口
21.3.5 FileSystem、FileSystems和FileStore类
21.4 使用NIO系统
21.4.1 为基于通道的I/O使用
21.4.2 为基于流的I/O使用
21.4.3 为路径和文件系统操作使用
21.5 JDK 7之前基于通道的例子
21.5.1 读文件（JDK 7之前
21.5.2 写文件（JDK 7之前
第22章 联网
22.1 联网的基础知识
22.2 联网类和接口
22.3 InetAddress类
22.3.1 工厂方法
22.3.2 实例方法
22.4 Inet4Address类和Inet6Address类
22.5 TCP/IP客户端套接字
22.6 URL类
22.7 URLConnection类
22.8 HttpURLConnection类
22.9 URI类
22.10 c
22.11 TCP/IP服务器套接字
22.12 数据报
22.12.1 DatagramSocket类
22.12.2 DatagramPacket类
22.12.3 数据报示例
第23章 Applet类
23.1 applet的两种类型
23.2 applet的基础知识
23.3 applet的架构
23.4 applet的骨架
23.4.1 applet的初始化和终止
23.4.2 重写update（）方法
23.5 简单的applet显示方法
23.6 请求重画
23.7 使用状态栏窗口
23.8 HTML APPLET标记
23.9 向applet传递参数
23.10 getDocumentBase（）和getCodeB
23.11 AppletContext接口和showDocument（）方法
23.12 AudioClip接口
23.13 AppletStub接口
23.14 向控制台输出
第24章 事件处理
24.1 两种事件处理机制
24.2 委托事件模型
24.2.1 事件
24.2.2 事件源
24.2.3 事件监听器
24.3 事件类
24.3.1 ActionEvent类
24.3.2 AdjustmentEvent类
24.3.3 ComponentEvent类
24.3.4 ContainerEvent类
24.3.5 FocusEvent类
24.3.6 InputEvent类
24.3.7 ItemEvent类
24.3.8 KeyEvent类
24.3.9 MouseEvent类
24.3.10 MouseWheelEvent类
24.3.11 TextEvent类
24.3.12 WindowEvent类
24.4 事件源
24.5 事件监听器接口
24.5.1 ActionListener接口
24.5.2 AdjustmentListener接口
24.5.3 ComponentListener接口
24.5.4 ContainerListener接口
24.5.5 FocusListener接口
24.5.6 ItemListener接口
24.5.7 KeyListener接口
24.5.8 MouseListener接口
24.5.9 MouseMotionListener接口
24.5.10 MouseWheelListener接口
24.5.11 TextListener接口
24.5.12 WindowFocusListener接口
24.5.13 WindowListener接口
24.6 使用委托事件模型
24.6.1 处理鼠标事件
24.6.2 处理键盘事件
24.7 适配器类
24.8 内部类
第25章 AWT介绍：使用窗口、图形和文本
25.1 AWT类
25.2 窗口基本元素
25.2.1 Component类
25.2.2 Container类
25.2.3 Panel类
25.2.4 Window类
25.2.5 Frame类
25.2.6 Canvas类
25.3 使用框架窗口
25.3.1 设置窗口的尺寸
25.3.2 隐藏和显示窗口
25.3.3 设置窗口的标题
25.3.4 关闭框架窗口
25.4 在基于AWT的applet中创建框架窗口
25.5 创建基于窗口的程序
25.6 在窗口中显示信息
25.7 使用图形
25.7.1 绘制直线
25.7.2 绘制矩形
25.7.3 绘制椭圆和圆
25.7.4 绘制弧形
25.7.5 绘制多边形
25.7.6 演示绘制方法
25.7.7 改变图形的大小
25.8 使用颜色
25.8.1 Color类的方法
25.8.2 设置当前图形的颜色
25.8.3 一个演示颜色的a
25.9 设置绘图模式
25.10 使用字体
25.10.1 确定可用字体
25.10.2 创建和选择字体
25.10.3 获取字体信息
25.11 使用FontMetrics管理文本输出
25.11.1 显示多行文本
25.11.2 居中显示文本
25.11.3 对齐多行文本
第26章 使用AWT控件、布局管理器和菜单
26.1 AWT控件的基础知识
26.1.1 添加和移除控件
26.1.2 响应控件
26.1.3 HeadlessException异常
26.2 使用标签
26.3 使用命令按钮
26.4 使用复选框
26.5 使用复选框组
26.6 使用下拉列表
26.7 使用列表框
26.8 管理滚动条
26.9 使用Text
26.10 使用Tex
26.11 理解布局管理器
26.11.1 FlowLayout布局管理器
26.11.2 BorderLayout布局管理器
26.11.3 使用I
26.11.4 GridLayout布局管理器
26.11.5 CardLayout布局管理器
26.11.6 GridBagLayout布局管理器
26.12 菜单栏和菜单
26.13 对话框
26.14 FileDialog类
26.15 关于重写paint（）方法
第27章 图像
27.1 文件格式
27.2 图像基础：创建、加载与显示
27.2.1 创建Image对象
27.2.2 加载图像
27.2.3 显示图像
27.3 ImageObserver接口
27.4 双缓冲
27.5 MediaTracker类
27.6 ImageProducer接口
27.7 ImageConsumer接口
27.8 ImageFilter类
27.8.1 CropImageFilter类
27.8.2 RGBImageFilter类
27.9 其他图像类
第28章 并发实用工具
28.1 并发API包
28.1.1 java.util.concurrent包
28.1.2 java.util.concurrent.atomic包
28.1.3 java.util.concurrent.locks包
28.2 使用同步对象
28.2.1 Semaphore类
28.2.2 CountDownLatch类
28.2.3 CyclicBarrier类
28.2.4 Exchanger类
28.2.5 Phaser类
28.3 使用执行器
28.3.1 一个简单的执行器示例
28.3.2 使用Callable和Future接口
28.4 TimeUnit枚举
28.5 并发集合
28.6 锁
28.7 原子操作
28.8 通过Fork/Join框架进行并行编程
28.8.1 主要的Fork/Join类
28.8.2 分而治之的策略
28.8.3 一个简单的Fork/Join示例
28.8.4 理解并行级别带来的影响
28.8.5 一个使用RecursiveTask[V]的例子
28.8.6 异步执行任务
28.8.7 取消任务
28.8.8 确定任务的完成状态
28.8.9 重新启动任务
28.8.10 深入研究
28.8.11 关于Fork/Join框架的一些提示
28.9 并发实用工具与Java传统方式的比较
第29章 流
29.1 流的基础知识
29.1.1 流接口
29.1.2 如何获得流
29.1.3 一个简单的流示例
29.2 缩减操作
29.3 使用并行流
29.4 映射
29.5 收集
29.6 迭代器和流
29.6.1 对流使用迭代器
29.6.2 使用Splite
29.7 流API中更多值得探究的地方
第30章 正则表达式和其他包
30.1 核心Java API包
30.2 正则表达式处理
30.2.1 Pattern类
30.2.2 Matcher类
30.2.3 正则表达式的语法
30.2.4 演示模式匹配
30.2.5 模式匹配的两个选项
30.2.6 探究正则表达式
30.3 反射
30.4 远程方法调用
30.5 使用java.text格式化日期和时间
30.5.1 DateFormat类
30.5.2 SimpleDateFormat类
30.6 JDK 8新增的时间和日？
30.6.1 时间和日期的基础知识
30.6.2 格式化日期和时间
30.6.3 解析日期和时间字符串
30.7 探究java.time包的其他方面
第Ⅲ部分 使用Swing进行 GUI编程
第31章 Swing简介
31.1 Swing的起源
31.2 Swing以AWT为基础
31.3 两个关键的Swing特性
31.3.1 Swing组件是轻量级的
31.3.2 Swing支持可插入外观
31.4 MVC连接
31.5 组件与容器
31.5.1 组件
31.5.2 容器
31.5.3 顶级容器窗格
31.6 Swing包
31.7 一个简单的Swing应用程序
31.8 事件处理
31.9 创建Swing ap
31.10 在Swing中绘图
31.10.1 绘图的基础知识
31.10.2 计算可绘制区域
31.10.3 一个绘图示例
第32章 探究S
32.1 JLabel与Image
32.2 JTextF
32.3 Swing按钮
32.3.1 JBu
32.3.2 JToggleBu
32.3.3 复选框
32.3.4 单选按钮
32.4 JTabbed
32.5 JScroll
32.6 J
32.7 JComb
32.8 树
32.9 JT
第33章 Swing菜单简介
33.1 菜单的基础知识
33.2 JMenuBar、JMenu和JMenuItem概述
33.2.1 JMen
33.2.2 J
33.2.3 JMenu
33.3 创建主菜单
33.4 向菜单项添加助记符和加速键
33.5 向菜单项添加图片和工具提示
33.6 使用JRadioButtonMenuItem和JCheckBoxMenu
33.7 创建弹出菜单
33.8 创建工具栏
33.9 使用动作
33.10 完整演示MenuDemo程序
33.11 继续探究S
第Ⅳ部分 使用JavaFX进行GUI编程
第34章 JavaFX GUI编程简介
34.1 JavaFX的基础概念
34.1.1 JavaFX包
34.1.2 Stage和Scene类
34.1.3 节点和场景图
34.1.4 布局
34.1.5 Application类和生命周期方法
34.1.6 启动JavaFX应用程序
34.2 JavaFX应用程序的骨架
34.3 编译和运行JavaFX程序
34.4 应用程序线程
34.5 一个简单的JavaFX控件：L
34.6 使用按钮和事件
34.6.1 事件的基础知识
34.6.2 按钮控件简介
34.6.3 演示事件处理和按钮
34.7 直接在画布上绘制
第35章 探究JavaFX控件
35.1 使用Image和Image
35.1.1 向标签添加图片
35.1.2 在按钮中使用图片
35.2 ToggleBu
35.3 RadioBu
35.3.1 处理开关组中的变化事件
35.3.2 处理单选按钮的另一种方式
35.4 Chec
35.5 List
35.5.1 ListView的滚动条
35.5.2 启用多项选择
35.6 Comb
35.7 TextF
35.8 Scroll
35.9 Tree
35.10 效果和变换简介
35.10.1 效果
35.10.2 变换
35.10.3 演示效果和变换
35.11 添加工具提示
35.12 禁用控件
第36章 JavaFX菜单简介
36.1 菜单的基础知识
36.2 MenuBar、Menu和MenuItem概述
36.2.1 Men
36.2.2
36.2.3 Menu
36.3 创建主菜单
36.4 向菜单项添加助记符和加速键
36.5 向菜单项添加图片
36.6 使用RadioMenuItem和CheckMenu
36.7 创建上下文菜单
36.8 创建工具栏
36.9 完整的MenuDemo程序
36.10 继续探究Ja
第Ⅴ部分 应用
第37章 Java
37.1 Java Bean是什么
37.2 Java Bean的优势
37.3 内省
37.3.1 属性的设计模式
37.3.2 事件的设计模式
37.3.3 方法与设计模式
37.3.4 使用BeanInfo接口
37.4 绑定属性与约束属性
37.5 持久性
37.6 定制器
37.7 Java Bean
37.7.1 Introspector类
37.7.2 PropertyDescriptor类
37.7.3 EventSetDescriptor类
37.7.4 MethodDescriptor类
37.8 一个Bean示例
第38章 ser
38.1 背景
38.2 servelet的生命周期
38.3 servlet开发选项
38.4 使用To
38.5 一个简单的ser
38.5.1 创建和编译servlet源代码
38.5.2 启动To
38.5.3 启动Web浏览器并请求ser
38.6 Servlet
38.7 javax.servlet包
38.7.1 Servlet接口
38.7.2 ServletConfig接口
38.7.3 ServletContext接口
38.7.4 ServletRequest接口
38.7.5 ServletResponse接口
38.7.6 GenericServlet类
38.7.7 ServletInputStream类
38.7.8 ServletOutputStream类
38.7.9 servlet异常类
38.8 读取servlet参数
38.9 javax.servlet.http包
38.9.1 HttpServletRequest接口
38.9.2 HttpServletResponse接口
38.9.3 HttpSession接口
38.9.4 Cookie类
38.9.5 HttpServlet类
38.10 处理HTTP请求和响应
38.10.1 处理HTTP GET请求
38.10.2 处理HTTP POST请求
38.11 使用co
38.12 会话跟踪
附录 使用Java的文档注释
5.1.1 if语句
5.1.2 switch语句
5.2 迭代语句
5.2.1 while语句
5.2.2 do-while语句
5.2.3 for语句
5.2.4 for循环的for-each版本
5.2.5 嵌套的循环
5.3 跳转语句
5.3.1 使用break语句
5.3.2 使用continue语句
5.3.3 return语句
第6章 类
6.1 类的基础知识
6.1.1 类的一般形式
6.1.2 一个简单的类
6.2 声明对象
6.3 为对象引用变量赋值
6.4 方法
6.4.1 为Box类添加方法
6.4.2 返回值
6.4.3 添加带参数的方法
6.5 构造函数
6.6 this关键字
6.7 垃圾回收
6.8 finalize（）方法
6.9 堆栈类
第7章 方法和类的深入分析
7.1 重载方法
7.2 将对象用作参数
7.3 参数传递的深入分析
7.4 返回对象
7.5 递归
7.6 访问控制
7.7 理解st
7.8 final介绍
7.9 重新审视数组
7.10 嵌套类和内部类
7.11 String类介绍
7.12 使用命令行参数
7.13 varargs：可变长度参数
7.13.1 重载varargs方法
7.13.2 varargs方法与模糊性
第8章 继承
8.1 继承的基础知识
8.1.1 成员访问与继承
8.1.2 一个更实际的例子
8.1.3 超类变量可以引用子类对象
8.2 使用super关键字
8.2.1 使用super调用超类的构造函数
8.2.2 super的另一种用法
8.3 创建多级继承层次
8.4 构造函数的调用时机
8.5 方法重写
8.6 动态方法调度
8.6.1 重写方法的目的
8.6.2 应用方法重写
8.7 使用抽象类
8.8 在继承中使用final关键字
8.8.1 使用final关键字阻止重写
8.8.2 使用final关键字阻止继承
8.9 Object类
第9章 包和接口
9.1 包
9.1.1 定义包
9.1.2 包查找与CLAS
9.1.3 一个简短的包示例
9.2 访问保护
9.3 导入包
9.4 接口
9.4.1 定义接口
9.4.2 实现接口
9.4.3 嵌套接口
9.4.4 应用接口
9.4.5 接口中的变量
9.4.6 接口可以扩展
9.5 默认接口方法
9.5.1 默认方法的基础知识
9.5.2 一个更加实用的例子
9.5.3 多级继承的问题
9.6 在接口中使用静态方法
9.7 关于包和接口的最后说明
第10章 异常处理
10.1 异常处理的基础知识
10.2 异常类型
10.3 未捕获的异常
10.4 使用try和
10.5 多条catch子句
10.6 嵌套的try语句
10.7
10.8 t
10.9 fi
10.10 Java的内置异常
10.11 创建自己的异常子类
10.12 链式异常
10.13 3个近期添加的异常特性
10.14 使用异常
第11章 多线程编程
11.1 Java线程模型
11.1.1 线程优先级
11.1.2 同步
11.1.3 消息传递
11.1.4 Thread类和Runnable接口
11.2 主线程
11.3 创建线程
11.3.1 实现Runnable接口
11.3.2 扩展Thread类
11.3.3 选择一种创建方式
11.4 创建多个线程
11.5 使用isAlive（）和join（）方法
11.6 线程优先级
11.7 同步
11.7.1 使用同步方法
11.7.2 synchronized语句
11.8 线程间通信
11.9 挂起、恢复与停止线程
11.10 获取线程的状态
11.11 使用多线程
第12章 枚举、自动装箱与注解（元数据
12.1 枚举
12.1.1 枚举的基础知识
12.1.2 values（）和valueOf（）方法
12.1.3 Java枚举是类类型
12.1.4 枚举继承自Enum类
12.1.5 另一个枚举示例
12.2 类型封装器
12.2.1 Character封装器
12.2.2 Boolean封装器
12.2.3 数值类型封装器
12.3 自动装箱
12.3.1 自动装箱与方法
12.3.2 表达式中发生的自动装箱/拆箱
12.3.3 布尔型和字符型数值的自动装箱/拆箱
12.3.4 自动装箱/拆箱有助于防止错误
12.3.5 一些警告
12.4 注解（元数据
12.4.1 注解的基础知识
12.4.2 指定保留策略
12.4.3 在运行时使用反射获取注解
12.4.4 AnnotatedElement接口
12.4.5 使用默认值
12.4.6 标记注解
12.4.7 单成员注解
12.4.8 内置注解
12.5 类型注解
12.6 重复注解
第13章 I/O、applet以及其他主题
13.1 I/O的基础知识
13.1.1 流
13.1.2 字节流和字符流
13.1.3 预定义流
13.2 读取控制台输入
13.2.1 读取字符
13.2.2 读取字符串
13.3 向控制台写输出
13.4 PrintWriter类
13.5 读/写文件
13.6 自动关闭文件
13.7 applet的基础知识
13.8 transient和volatile修饰符
13.9 使用instanceof运算符
13.10 str
13.11 本地方法
13.12 使用a
13.13 静态导入
13.14 通过this（）调用重载的构造函数
13.15 紧凑API配置文件
第14章 泛型
14.1 什么是泛型
14.2 一个简单的泛型示例
14.2.1 泛型只使用引用类型
14.2.2 基于不同类型参数的泛型类型是不同的
14.2.3 泛型提升类型安全性的原理
14.3 带两个类型参数的泛型类
14.4 泛型类的一般形式
14.5 有界类型
14.6 使用通配符参数
14.7 创建泛型方法
14.8 泛型接口
14.9 原始类型与遗留代码
14.10 泛型类层次
14.10.1 使用泛型超类
14.10.2 泛型子类
14.10.3 泛型层次中的运行时类型比较
14.10.4 强制转换
14.10.5 重写泛型类的方法
14.11 泛型的类型推断
14.12 擦除
14.13 模糊性错误
14.14 使用泛型的一些限制
14.14.1 不能实例化类型参数
14.14.2 对静态成员的一些限制
14.14.3 对泛型数组的一些限制
14.14.4 对泛型异常的限制
第15章 lambda表达式
15.1 lambda表达式简介
15.1.1 lambda表达式的基础知识
15.1.2 函数式接口
15.1.3 几个lambda表达式示例
15.2 块lambda表达式
15.3 泛型函数式接口
15.4 作为参数传递lambda表达式
15.5 lambda表达式与异常
15.6 lambda表达式和变量捕获
15.7 方法引用
15.7.1 静态方法的方法引用
15.7.2 实例方法的方法引用
15.7.3 泛型中的方法引用
15.8 构造函数引用
15.9 预定义的函数式接口
第Ⅱ部分 Java库
第16章 字符串处理
16.1 String类的构造函数
16.2 字符串的长度
16.3 特殊的字符串操作
16.3.1 字符串字面值
16.3.2 字符串连接
16.3.3 字符串和其他数据类型的连接
16.3.4 字符串转换和toString（）方法
16.4 提取字符
16.4.1 cha
16.4.2 getCh
16.4.3 getBy
16.4.4 toCharAr
16.5 比较字符串
16.5.1 equals（）和equalsIgnoreC
16.5.2 regionMatc
16.5.3 startsWith（）和endsW
16.5.4 equals（）与
16.5.5 compar
16.6 查找字符串
16.7 修改字符串
16.7.1 substr
16.7.2 con
16.7.3 repl
16.7.4 t
16.8 使用valueOf（）转换数据
16.9 改变字符串中字符的大小写
16.10 连接字符串
16.11 其他String方法
16.12 StringBuffer类
16.12.1 StringBuffer类的构造函数
16.12.2 length（）与capac
16.12.3 ensureCapac
16.12.4 setLen
16.12.5 charAt（）与setCha
16.12.6 getCh
16.12.7 app
16.12.8 ins
16.12.9 reve
16.12.10 delete（）与deleteCha
16.12.11 repl
16.12.12 substr
16.12.13 其他StringBuffer方法
16.13 StringBuilder类
第17章 探究java
17.1 基本类型封装器
17.1.1 N
17.1.2 Double与
17.1.3 理解isInfinite（）与is
17.1.4 Byte、Short、Integer？
17.1.5 Char
17.1.6 对Unicode代码点的附加支持
17.1.7 Bo
17.2 Void类
17.3 Process类
17.4 Runtime类
17.4.1 内存管理
17.4.2 执行其他程序
17.5 ProcessBuilder类
17.6 System类
17.6.1 使用currentTimeMillis（）计时程序的执行
17.6.2 使用arrayc
17.6.3 环境属性
17.7 Object类
17.8 使用clone（）方法和Cloneable接口
17.9 Class类
17.10 ClassLoader类
17.11 Math类
17.11.1 三角函数
17.11.2 指数函数
17.11.3 舍入函数
17.11.4 其他数学方法
17.12 StrictMath类
17.13 Compiler类
17.14 Thread类、ThreadGroup类和Runnable接口
17.14.1 Runnable接口
17.14.2 Thread类
17.14.3 ThreadGroup类
17.15 ThreadLocal和
InheritableThreadLocal类
17.16 Package类
17.17 RuntimePermission类
17.18 Throwable类
17.19 SecurityManager类
17.20 StackTraceElement类
17.21 Enum类
17.22 ClassValue类
17.23 CharSequence接口
17.24 Comparable接口
17.25 Appendable接口
17.26 Iterable接口
17.27 Readable接口
17.28 AutoCloseable接口
17.29 Thread.UncaughtExceptionHandler接口
17.30 java.lang子包
17.30.1 java.lang.annot
17.30.2 java.lang.instr
17.30.3 java.lang.i
17.30.4 java.lang.manag
17.30.5 java.lan
17.30.6 java.lang.re
第18章 java.util第1部分：集合框架
18.1 集合概述
18.2 JDK 5对集合框架的修改
18.2.1 泛型从根本上改变了集合框架
18.2.2 自动装箱使得使用基本类型更加容易
18.2.3 for-each风格的for循环
18.3 集合接口
18.3.1 Collection接口
18.3.2 List接口
18.3.3 Set接口
18.3.4 SortedSet接口
18.3.5 NavigableSet接口
18.3.6 Queue接口
18.3.7 Deque接口
18.4 集合类
18.4.1 ArrayList类
18.4.2 LinkedList类
18.4.3 HashSet类
18.4.4 LinkedHashSet类
18.4.5 TreeSet类
18.4.6 PriorityQueue类
18.4.7 ArrayDeque类
18.4.8 EnumSet类
18.5 通过迭代器访问集合
18.5.1 使用迭代器
18.5.2 使用for-each循环替代迭代器
18.6 Splite
18.7 在集合中存储用户定义的类
18.8 RandomAccess接口
18.9 使用映射
18.9.1 映射接口
18.9.2 映射类
18.10 比较器
18.11 集合算法
18.12 Arrays类
18.13 遗留的类和接口
18.13.1 Enumeration接口
18.13.2 Vector类
18.13.3 Stack类
18.13.4 Dictionary类
18.13.5 Hashtable类
18.13.6 Properties类
18.13.7 使用store（）和l
18.14 集合小结
第19章 java.util第2部分：更多实用工具类
19.1 StringTokenizer类
19.2 BitSet类
19.3 Optional、OptionalDouble、OptionalInt和Optiona
19.4 Date类
19.5 Calendar类
19.6 GregorianCalendar类
19.7 TimeZone类
19.8 SimpleTimeZone类
19.9 Locale类
19.10 Random类
19.11 Observable类
19.11.1 Observer接口
19.11.2 Observer示例
19.12 Timer和TimerTask类
19.13 Currency类
19.14 Formatter类
19.14.1 Formatter类的构造函数
19.14.2 Formatter类的方法
19.14.3 格式化的基础知识
19.14.4 格式化字符串和字符
19.14.5 格式化数字
19.14.6 格式化时间和日期
19.14.7 %n和%%说明符
19.14.8 指定最小字段宽度
19.14.9 指定精度
19.14.10 使用格式标志
19.14.11 对齐输出
19.14.12 空格、“+”、“0”以及“（”标志
19.14.13 逗号标志
19.14.14 “#”标志
19.14.15 大写选项
19.14.16 使用参数索引
19.14.17 关闭Formatter对象
19.14.18 printf（）方法
19.15 Scanner类
19.15.1 Scanner类的构造函数
19.15.2 扫描的基础知识
19.15.3 一些Scanner示例
19.15.4 设置定界符
19.15.5 其他Scanner特性
19.16 ResourceBundle、ListResourceBundle和
19.17 其他实用工具类和接口
19.18 java.util子包
19.18.1 java.util.concurrent、java.util.concurrent.atomic和 java.util.concurrent.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 8编程参考官方教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java攻略
译者序　　ix
序　　xi
前言　　xiii
第1章　基础知识　　1
1.1　lambda 表达式　　2
1.2　方法引用　　5
1.3　构造函数引用　　8
1.4　函数式接口　　12
1.5　接口中的默认方法　　14
1.6　接口中的静态方法　　17
第2章　java.util.function 包　　20
2.1　Consumer 接口　　20
2.2　Supplier 接口　　22
2.3　Predicate 接口　　25
2.4　Function 接口　　28
第3章　流式操作　　31
3.1　流的创建　　31
3.2　装箱流　　35
3.3　利用reduce 方法实现归约操作　　36
3.4　利用reduce 方法校验排序　　44
3.5　利用peek 方法对流进行调试　　45
3.6　字符串与流之间的转换　　47
3.7　获取元素数量　　50
3.8　汇总统计　　52
3.9　查找流的第一个元素　　54
3.10　使用anyMatch、allMatch 与noneMatch 方法　　58
3.11　使用flatMap 与map 方法　　60
3.12　流的拼接　　63
3.13　惰性流　　66
第4章　比较器与收集器　　69
4.1　利用比较器实现排序　　69
4.2　将流转换为集合　　72
4.3　将线性集合添加到映射　　75
4.4　对映射排序　　77
4.5　分区与分组　　79
4.6　下游收集器　　81
4.7　查找最大值和最小值　　83
4.8　创建不可变集合　　85
4.9　实现Collector 接口　　87
第5章　流式操作、lambda 表达式与方法引用的相关问题　　91
5.1　java.util.Objects 类　　91
5.2　lambda 表达式与效果等同于final 的变量　　93
5.3　随机数流　　96
5.4　Map 接口的默认方法　　97
5.5　默认方法冲突　　101
5.6　集合与映射的迭代　　103
5.7　利用Supplier 创建日志消息　　105
5.8　闭包复合　　107
5.9　利用提取的方法实现异常处理　　110
5.10　受检异常与lambda 表达式　　112
5.11　泛型异常包装器的应用　　114
第6章　Optional 类　　117
6.1　Optional 的创建　　118
6.2　从Optional 中检索值　　120
6.3　getter 和setter 方法中的Optional　　122
6.4　Optional.flatMap 与Optional.map 方法　　124
6.5　Optional 的映射　　127
第7章　文件I/O　　131
7.1　文件处理　　132
7.2　以流的形式检索文件　　134
7.3　文件系统的遍历　　135
7.4　文件系统的搜索　　137
第8章　java.time 包　　139
8.1　Date-Time API 中的基本类　　140
8.2　根据现有实例创建日期和时间　　143
8.3　调节器与查询　　147
8.4　将java.util.Date 转换为java.time.LocalDate　　152
8.5　解析与格式化　　155
8.6　查找具有非整数小时偏移量的时区　　158
8.7　根据UTC 偏移量查找地区名　　160
8.8　获取事件之间的时间　　162
第9章　并行与并发　　165
9.1　将顺序流转换为并行流　　166
9.2　并行流的优点　　169
9.3　调整线程池大小　　173
9.4　Future 接口　　175
9.5　完成CompletableFuture　　178
9.6　多个CompletableFuture 之间的协调（第1 部分）　　181
9.7　多个CompletableFuture 之间的协调（第2 部分）　　186
第10章　Java 9 新特性　　193
10.1　Jigsaw 中的模块　　194
10.2　接口中的私有方法　　198
10.3　创建不可变集合　　200
10.4　新增的Stream 方法　　204
10.5　下游收集器：filtering 与flatMapping　　207
10.6　新增的Optional 方法　　210
10.7　日期范围　　212
附录A　泛型与Java 8　　215
作者简介　　230
封面介绍　　230
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java攻略
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java JDK 9学习笔记
Chapter 1 Java平台概论 1
1.1 Java不只是语言 2
1.1.1 前世今生 2
1.1.2 三大平台 5
1.1.3 JCP与JSR 6
1.1.4 Oracle JDK与OpenJDK 7
1.1.5 建议的学习路径 8
1.2 JVM/JRE/JDK 12
1.2.1 什么是JVM 12
1.2.2 区分JRE与JDK 14
1.2.3 下载、安装JDK 15
1.2.4 认识JDK安装内容 18
1.3 重点复习 19
Chapter 2 从JDK到IDE 21
2.1 从Hello World开始 22
2.1.1 撰写Java原始码 22
2.1.2 PATH是什么 24
2.1.3 JVM(java)与CLASSPATH 27
2.1.4 编译程序(javac)与
CLASSPATH 29
2.2 管理原始码与位码文档 30
2.2.1 编译程序(javac)与
SOURCEPATH 30
2.2.2 使用package管理类 32
2.2.3 使用import偷懒 34
2.3 初识模块平台系统 36
2.3.1 JVM(java)与module-
path 37
2.3.2 编译程序(javac)与
module-path 39
2.3.3 编译程序(javac)与
module-source-path 40
2.4 使用IDE 41
2.4.1 IDE项目管理基础 41
2.4.2 使用了哪个JRE 47
2.4.3 类文档版本 49
2.5 重点复习 51
Chapter 3 基础语法 53
3.1 类型、变量与运算符 54
3.1.1 类型 54
3.1.2 变量 57
3.1.3 运算符 60
3.1.4 类型转换 65
3.2 流程控制 68
3.2.1 if...else条件式 68
3.2.2 switch条件式 70
3.2.3 for循环 72
3.2.4 while循环 73
3.2.5 break、continue 74
3.3 重点复习 76
3.4 课后练习 77
Chapter 4 认识对象 78
4.1 类与对象 79
4.1.1 定义类 79
4.1.2 使用标准类 81
4.1.3 对象指定与相等性 84
4.2 基本类型打包器 86
4.2.1 打包基本类型 86
4.2.2 自动装箱、拆箱 87
4.2.3 自动装箱、拆箱的内幕 88
4.3 数组对象 90
4.3.1 数组基础 91
4.3.2 操作数组对象 93
4.3.3 数组复制 98
4.4 字符串对象 100
4.4.1 字符串基础 101
4.4.2 字符串特性 103
4.4.3 字符串编码 107
4.5 查询Java API文件 108
4.6 重点复习 113
4.7 课后练习 114
Chapter 5 对象封装 116
5.1 何谓封装 117
5.1.1 封装对象初始流程 117
5.1.2 封装对象操作流程 119
5.1.3 封装对象内部数据 121
5.2 类语法细节 123
5.2.1 public权限修饰 123
5.2.2 关于构造函数 125
5.2.3 构造函数与方法重载 126
5.2.4 使用this 128
5.2.5 static类成员 130
5.2.6 不定长度自变量 135
5.2.7 内部类 136
5.2.8 传值调用 138
5.3 重点复习 140
5.4 课后练习 141
Chapter 6 继承与多态 142
6.1 何谓继承 143
6.1.1 继承共同行为 143
6.1.2 多态与is-a 147
6.1.3 重新定义行为 150
6.1.4 抽象方法、抽象类 153
6.2 继承语法细节 154
6.2.1 protected成员 154
6.2.2 重新定义的细节 156
6.2.3 再看构造函数 157
6.2.4 再看final关键字 159
6.2.5 java.lang.Object 160
6.2.6 关于垃圾收集 165
6.2.7 再看抽象类 167
6.3 重点复习 169
6.4 课后练习 170
Chapter 7 接口与多态 171
7.1 何谓接口 172
7.1.1 接口定义行为 172
7.1.2 行为的多态 175
7.1.3 解决需求变化 178
7.2 接口语法细节 183
7.2.1 接口的默认 183
7.2.2 匿名内部类 187
7.2.3 使用enum枚举常数 190
7.3 重点复习 192
7.4 课后练习 193
Chapter 8 异常处理 194
8.1 语法与继承架构 195
8.1.1 使用try、catch 195
8.1.2 异常继承架构 197
8.1.3 要抓还是要抛 202
8.1.4 贴心还是造成麻烦 205
8.1.5 认识堆栈追踪 206
8.1.6 关于assert 210
8.2 异常与资源管理 213
8.2.1 使用finally 213
8.2.2 自动尝试关闭资源 215
8.2.3 java.lang.AutoCloseable
接口 217
8.3 重点复习 221
8.4 课后练习 222
Chapter 9 Collection与Map 223
9.1 使用Collection收集对象 224
9.1.1 认识Collection架构 224
9.1.2 具有索引的List 225
9.1.3 内容不重复的Set 228
9.1.4 支持队列操作的Queue 232
9.1.5 使用泛型 234
9.1.6 简介Lambda表达式 238
9.1.7 Interable与
Iterator 240
9.1.8 Comparable与
Comparator 243
9.2 键值对应的Map 248
9.2.1 常用Map操作类 249
9.2.2 访问Map键值 252
9.3 不可变的Collection
与Map 255
9.3.1 浅谈不可变特性 255
9.3.2 Collections的
unmodifiableXXX()
方法 256
9.3.3 List、Set、Map的of()
方法 258
9.4 重点复习 260
9.5 课后练习 262
Chapter 10 输入/输出 263
10.1 InputStream与
OutputStream 264
10.1.1 串流设计的概念 264
10.1.2 串流继承架构 266
10.1.3 串流处理装饰器 269
10.2 字符处理类 273
10.2.1 Reader与Writer继承
架构 274
10.2.2 字符处理装饰器 275
10.3 重点复习 277
10.4 课后练习 278
Chapter 11 线程与并行API 279
11.1 线程 280
11.1.1 线程简介 280
11.1.2 Thread与Runnable 282
11.1.3 线程生命周期 284
11.1.4 关于ThreadGroup 290
11.1.5 synchronized与
volatile 292
11.1.6 等待与通知 301
11.2 并行API 305
11.2.1 Lock、ReadWriteLock与
Condition 305
11.2.2 使用Executor 313
11.2.3 并行Collection简介 323
11.3 重点复习 326
11.4 课后练习 327
Chapter 12 Lambda 328
12.1 认识Lambda语法 329
12.1.1 Lambda语法概览 329
12.1.2 Lambda表达式与函数
接口 332
12.1.3 Lambda遇上this与
final 334
12.1.4 方法与构造函数参考 336
12.1.5 接口默认方法 338
12.2 Functional与Stream API 343
12.2.1 使用Optional取代
null 343
12.2.2 标准API的函数接口 345
12.2.3 使用Stream进行管道
操作 348
12.2.4 进行Stream的reduce
与collect 351
12.2.5 关于flatMap()方法 356
12.2.6 Stream相关API 359
12.2.7 JDK9 Optional与
Stream增强 360
12.3 Lambda、平行化与异步
处理 362
12.3.1 Stream与平行化 362
12.3.2 Arrays与平行化 366
12.3.3 CompletableFuture
非同步处理 367
12.3.4 JDK9 CompletableFuture
增强 369
12.4 重点复习 370
12.5 课后练习 371
Chapter 13 时间与日期 372
13.1 认识时间与日期 373
13.1.1 时间的度量 373
13.1.2 年历简介 374
13.1.3 认识时区 375
13.2 认识Date与Calendar 376
13.2.1 时间轴上瞬间的Date 376
13.2.2 格式化时间日期的
DateFormat 377
13.2.3 处理时间日期的
Calendar 379
13.2.4 设定TimeZone 382
13.3 新时间日期API 383
13.3.1 机器时间观点的API 383
13.3.2 人类时间观点的API 385
13.3.3 对时间的运算 387
13.3.4 年历系统设计 389
13.4 重点复习 390
13.5 课后练习 391
Chapter 14 NIO与NIO2 393
14.1 认识NIO 394
14.1.1 NIO概述 394
14.1.2 Channel架构与操作 395
14.1.3 Buffer架构与操作 396
14.2 NIO2文件系统 398
14.2.1 NIO2架构 398
14.2.2 操作路径 399
14.2.3 属性读取与设定 401
14.2.4 操作文档与目录 404
14.2.5 读取、访问目录 406
14.2.6 过滤、搜索文档 410
14.3 重点复习 412
14.4 课后练习 413
Chapter 15 通用API 414
15.1 日志 415
15.1.1 日志API简介 415
15.1.2 指定日志层级 417
15.1.3 使用Handler与
Formatter 419
15.1.4 自定义Handler、Formatter
与Filter 420
15.1.5 使用logging.
properties 422
15.2 国际化基础 423
15.2.1 使用ResourceBundle 423
15.2.2 使用Locale 424
15.3 规则表示式 426
15.3.1 规则表示式简介 426
15.3.2 Pattern与Matcher 433
15.4 处理数字 435
15.4.1 使用BigInteger 435
15.4.2 使用BigDecimal 437
15.4.3 数字的格式化 439
15.5 再谈堆栈追踪 441
15.5.1 获取
StackTraceElement 441
15.5.2 JDK9的Stack-
Walking API 443
15.6 重点复习 447
15.7 课后练习 448
Chapter 16 整合数据库 449
16.1 JDBC入门 450
16.1.1 JDBC简介 450
16.1.2 连接数据库 454
16.1.3 使用Statement、
ResultSet 459
16.1.4 使用PreparedStatement、
CallableStatement 464
16.2 JDBC进阶 468
16.2.1 使用DataSource取得
联机 468
16.2.2 使用ResultSet卷动、
更新数据 471
16.2.3 批次更新 473
16.2.4 Blob与Clob 474
16.2.5 交易简介 474
16.2.6 metadata简介 481
16.2.7 RowSet简介 484
16.3 重点复习 486
16.4 课后练习 487
Chapter 17 反射与类加载器 489
17.1 运用反射 490
17.1.1 Class与.class文档 490
17.1.2 使用Class.
forName() 492
17.1.3 从Class获得信息 494
17.1.4 从Class建立对象 496
17.1.5 操作对象方法与成员 499
17.1.6 动态代理 501
17.1.7 当反射遇上模块 505
17.1.8 使用ServiceLoader 511
17.2 了解类加载器 513
17.2.1 JDK9类加载器层级 513
17.2.2 建立ClassLoader
实例 516
17.3 重点复习 517
17.4 课后练习 519
Chapter 18 自定义泛型、枚举与注释 520
18.1 自定义泛型 521
18.1.1 使用extends与? 521
18.1.2 使用super与? 525
18.2 自定义枚举 528
18.2.1 了解java.lang.Enum类 528
18.2.2 enum高级运用 531
18.3 关于注释 536
18.3.1 常用标准注释 536
18.3.2 自定义注释类型 540
18.3.3 执行时期读取注释信息 545
18.4 重点复习 548
18.5 课后练习 549
Chapter 19 深入模块化 550
19.1 运用模块 551
19.1.1 模块的种类 551
19.1.2 requires、exports与
opens细节 554
19.1.3 修补模块 557
19.1.4 放宽模块封装与依赖 558
19.2 模块API 560
19.2.1 使用Module 560
19.2.2 使用
ModuleDescriptor 562
19.2.3 浅谈ModuleLayer 562
19.3 打包模块 564
19.3.1 使用jar打包 564
19.3.2 使用jmod打包 566
19.3.3 使用jlink建立执行时期
映像 568
19.4 重点复习 569
19.5 课后练习 570
Appendix 571
A.1 项目环境配置 572
A.2 打开案例 572
Java SE 9 新功能索引
Java SE 9后的特性版本时间轴变动 15
JDK 9文档实体布局变动 18
初探模块平台系统 36
javac新增-release参数 50
支持Unicode 8.0 54
内建jshell 56
Java API文件支持搜索功能 112
StackTraceElement新增方法 207
Try-with-resources语法改进 217
定义匿名类别时的泛型语法改进 239
List、Set、Map新增of( )方法 258
接口支持定义private方法 340
Collectors新增filtering( )方法 356
Collectors新增flatMapping( )方法 359
Optional与Stream增强 360
CompletableFuture增强 369
支持UTF-8编码的.properities文件 425
Stack-Walking API 443
反射与类加载器机制 490
@Deprecated增强 537
ElementType新增MODULE 545
深入模块化 551
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java JDK 9学习笔记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>写给大忙人的Java SE 9核心技术
第1章  基本的编程结构  1
1.1  第一个程序  2
1.1.1  "Hello,World!"程序解析  2
1.1.2  编译与运行Java程序  3
1.1.3  方法调用  5
1.1.4  JShell  7
1.2  基本类型  11
1.2.1  有符号整型  11
1.2.2  浮点类型  12
1.2.3  char型  13
1.2.4  布尔型  14
1.3  变量  14
1.3.1  变量的声明  14
1.3.2  名称  14
1.3.3  初始化  15
1.3.4  常量  15
1.4  算术操作  17
1.4.1  赋值  18
1.4.2  基本运算  18
1.4.3  数学方法  20
1.4.4  数字类型转换  21
1.4.5  关系操作符和逻辑操作符  22
1.4.6  大数  24
1.5  字符串  24
1.5.1  字符串的连接  25
1.5.2  子字符串  26
1.5.3  字符串比较  26
1.5.4  数字与字符串转换  28
1.5.5  String类API  29
1.5.6  编码点和编码单元  31
1.6  输入与输出  33
1.6.1  读取输入  33
1.6.2  格式化输出  35
1.7  控制流  37
1.7.1  分支  37
1.7.2  循环  39
1.7.3  跳出循环与继续循环  41
1.7.4  局部变量作用域  43
1.8  数组和数组列表  44
1.8.1  使用数组  44
1.8.2  构造数组  45
1.8.3  数组列表  47
1.8.4  基本类型包装类  48
1.8.5  增强的for循环  48
1.8.6  数组与数组列表的复制  49
1.8.7  数组算法  50
1.8.8  命令行参数  51
1.8.9  多维数组  52
1.9  功能分解  55
1.9.1  静态方法的声明与调用  55
1.9.2  数组参数与返回值  55
1.9.3  可变参数  56
练习  57
第2章  面向对象编程  61
2.1  使用对象  62
2.1.1  访问器方法和修改器方法  64
2.1.2  对象引用  65
2.2  实现类  67
2.2.1  实例变量  67
2.2.2  方法头  67
2.2.3  方法体  68
2.2.4  实例方法调用  69
2.2.5  this引用  69
2.2.6  值调用  70
2.3  构造对象  72
2.3.1  实现构造函数  72
2.3.2  重载  73
2.3.3  调用另一个构造函数  74
2.3.4  默认初始化  74
2.3.5  实例变量的初始化  75
2.3.6  final实例变量  76
2.3.7  无参构造函数  76
2.4  静态变量和方法  77
2.4.1  静态变量  77
2.4.2  静态常量  78
2.4.3  静态初始块  79
2.4.4  静态方法  80
2.4.5  工厂方法  81
2.5  包  82
2.5.1  包的声明  82
2.5.2  jar命令  83
2.5.3  类路径  84
2.5.4  包访问权限  86
2.5.5  导入类  87
2.5.6  静态导入  88
2.6  嵌套类  89
2.6.1  静态嵌套类  89
2.6.2  内部类  91
2.6.3  内部类的特殊语法  93
2.7  文档注释  95
2.7.1  插入注释  95
2.7.2  类注释  96
2.7.3  方法注释  97
2.7.4  变量注释  97
2.7.5  通用注释  98
2.7.6  链接  98
2.7.7  包、模块和概述注释  99
2.7.8  注释的提取  99
练习  100
第3章  接口和lambda表达式  105
3.1  接口  106
3.1.1  声明接口  106
3.1.2  实现接口  107
3.1.3  转换为接口类型  109
3.1.4  强制类型转换和instanceof操作符  109
3.1.5  继承接口  110
3.1.6  实现多个接口  111
3.1.7  常量  111
3.2  静态方法、默认方法和私有方法  112
3.2.1  静态方法  112
3.2.2  默认方法  112
3.2.3  解决默认方法冲突的问题  113
3.2.4  私有方法  115
3.3  接口示例  115
3.3.1  Comparable接口  115
3.3.2  Comparator接口  117
3.3.3  Runnable接口  118
3.3.4  UI回调  119
3.4  lambda表达式  120
3.4.1  lambda表达式语法  121
3.4.2  函数式接口  122
3.5  方法引用和构造函数引用  123
3.5.1  方法引用  123
3.5.2  构造函数引用  125
3.6  使用lambda表达式  126
3.6.1  实现延迟执行  126
3.6.2  选择函数式接口  127
3.6.3  实现自己的函数式接口  129
3.7  lambda表达式和变量作用域  130
3.7.1  lambda表达式的作用域  130
3.7.2  访问来自闭合作用域的变量  131
3.8  高阶函数  133
3.8.1  返回函数的方法  134
3.8.2  修改函数的方法  134
3.8.3  Comparator方法  135
3.9  局部类和匿名类  136
3.9.1  局部类  136
3.9.2  匿名类  137
练习  138
第4章  继承与反射  143
4.1  继承一个类  144
4.1.1  父类与子类  144
4.1.2  定义和继承子类方法  145
4.1.3  方法覆盖  145
4.1.4  子类的构造  147
4.1.5  父类赋值  147
4.1.6  转换  148
4.1.7  final方法和类  149
4.1.8  抽象方法和类  149
4.1.9  受保护访问  150
4.1.10  匿名子类  151
4.1.11  继承和默认方法  152
4.1.12  带super的方法表达式  153
4.2  Object：终极父类  153
4.2.1  toString方法  154
4.2.2  equals方法  156
4.2.3  hashCode方法  159
4.2.4  克隆对象  160
4.3  枚举  163
4.3.1  枚举方法  164
4.3.2  构造函数、方法和域  165
4.3.3  实例的实现体  165
4.3.4  静态成员  166
4.3.5  switch枚举对象  167
4.4  运行时类型信息和资源  168
4.4.1  Class类  168
4.4.2  资源加载  172
4.4.3  类加载器  172
4.4.4  上下文类加载器  174
4.4.5  服务加载器  176
4.5  反射  178
4.5.1  枚举类成员  178
4.5.2  对象检查  179
4.5.3  方法调用  180
4.5.4  对象构造  181
4.5.5  JavaBeans  182
4.5.6  使用数组  183
4.5.7  代理  185
练习  187
第5章  异常、断言和日志处理  191
5.1  异常处理  192
5.1.1  异常抛出  192
5.1.2  异常继承层次  193
5.1.3  已检查异常的声明  195
5.1.4  异常捕获  196
5.1.5  try-with-resources语句  197
5.1.6  finally子句  199
5.1.7  异常重抛和链接  200
5.1.8  未捕获的异常和堆栈踪迹  202
5.1.9  Objects.requireNonNull方法  203
5.2  断言  204
5.2.1  使用断言  205
5.2.2  启用和禁用断言  205
5.3  记录日志  206
5.3.1  采用日志记录器  206
5.3.2  日志记录器  207
5.3.3  日志级别  207
5.3.4  其他日志记录方法  208
5.3.5  日志记录的配置项  210
5.3.6  日志处理器  211
5.3.7  过滤器和格式化器  214
练习  215
第6章  泛型编程  219
6.1  泛型类  220
6.2  泛型方法  221
6.3  类型限定  222
6.4  类型变异和通配符  223
6.4.1  子类型通配符  224
6.4.2  父类型通配符  225
6.4.3  带类型变量的通配符  226
6.4.4  无限定通配符  228
6.4.5  通配符捕获  228
6.5  Java虚拟机中的泛型  229
6.5.1  类型擦除  229
6.5.2  转换插入  230
6.5.3  桥方法  230
6.6  泛型约束  232
6.6.1  无基本类型参数  232
6.6.2  所有类型在运行时都是原始的  233
6.6.3  不能实例化类型变量  234
6.6.4  不能构造参数化类型的数组  236
6.6.5  静态上下文中的类类型变量不是有效的  237
6.6.6  类型擦除后的方法可能不冲突  238
6.6.7  异常与泛型  239
6.7  反射与泛型  240
6.7.1  Class<T>类  240
6.7.2  虚拟机中的泛型类型信息  242
练习  243
第7章  集合  249
7.1  集合框架概要  249
7.2  迭代器  254
7.3  set  256
7.4  map  257
7.5  其他集合  261
7.5.1  Properties  261
7.5.2  位组  262
7.5.3  枚举set和枚举map  264
7.5.4  栈、队列、双端队列、优先级队列  264
7.5.5  弱哈希映射表  266
7.6  视图  266
7.6.1  小集合  267
7.6.2  范围  268
7.6.3  不可修改的视图  268
练习  269
第8章  Stream  273
8.1  从迭代到Stream操作  274
8.2  创建Stream  275
8.3  filter、map和flatMap方法  277
8.4  提取子流和组合流  279
8.5  其他流转换  280
8.6  简单归约  281
8.7  Optional类型  282
8.7.1  如何使用Optional类型值  282
8.7.2  如何不使用Optional类型值  284
8.7.3  创建Optional类型值  284
8.7.4  使用flatMap来组合可选值函数  285
8.7.5  将Optional转变为流  286
8.8  收集结果  287
8.9  将结果收集到map中  289
8.10  分组和分片  290
8.11  下游收集器  291
8.12  归约操作  294
8.13  基本类型流  296
8.14  并行流  297
练习  300
第9章  输入与输出处理  305
9.1  输入/输出流、Reader和Writer  306
9.1.1  获取流对象  306
9.1.2  读取字节  307
9.1.3  写字节  308
9.1.4  字符编码  308
9.1.5  文本输入  311
9.1.6  文本输出  313
9.1.7  读/写二进制数据  314
9.1.8  随机存取文件  315
9.1.9  内存映射文件  315
9.1.10  文件锁  316
9.2  路径、文件和目录  317
9.2.1  路径  317
9.2.2  创建文件和目录  319
9.2.3  复制、移动和删除文件  320
9.2.4  访问目录内容  321
9.2.5  ZIP文件系统  324
9.3  HTTP连接  325
9.3.1  URLConnection类和HttpURLConnection类  326
9.3.2  HTTP Client API  327
9.4  正则表达式  330
9.4.1  正则表达式概述  330
9.4.2  找到一个匹配  334
9.4.3  找到所有匹配  335
9.4.4  分组  336
9.4.5  以分隔符号分割  337
9.4.6  替换匹配结果  338
9.4.7  标记  339
9.5  序列化  339
9.5.1  Serializable接口  340
9.5.2  瞬态实例变量  342
9.5.3  readObject和writeObject方法  342
9.5.4  readResolve和writeReplace方法  343
9.5.5  版本化  345
练习  346
第10章  并发编程  351
10.1  并发任务  352
10.1.1  运行任务  352
10.1.2  Future  354
10.2  异步计算  357
10.2.1  可完成的Future  357
10.2.2  组合可完成的Future  359
10.2.3  UI回调中的长时间运行任务  362
10.3  线程安全  364
10.3.1  可见性  364
10.3.2  竞争条件  366
10.3.3  安全并发的策略  369
10.3.4  不可变类  369
10.4  并行算法  370
10.4.1  并行流  370
10.4.2  并行数组操作  371
10.5  线程安全的数据结构  372
10.5.1  ConcurrentHashMap  373
10.5.2  阻塞队列  374
10.5.3  其他线程安全的数据结构  375
10.6  原子计数器和累加器  376
10.7  锁和条件  379
10.7.1  锁  379
10.7.2  synchronized关键字  380
10.7.3  条件等待  382
10.8  线程  385
10.8.1  启动线程  385
10.8.2  线程中断  386
10.8.3  线程变量  388
10.8.4  线程的其他属性  388
10.9  进程  389
10.9.1  构建进程  389
10.9.2  运行进程  391
10.9.3  ProcessHandle  392
练习  393
第11章  注解  401
11.1  使用注解  402
11.1.1  注解元素  402
11.1.2  多注解和重复注解  403
11.1.3  注解声明  404
11.1.4  注解类型用途  405
11.1.5  明确接收者  406
11.2  定义注解  408
11.3  标准注解  410
11.3.1  编译相关的注解  411
11.3.2  资源管理相关的注解  412
11.3.3  元注解  412
11.4  运行时注解处理  414
11.5  源码级注解处理  418
11.5.1  注解处理器  418
11.5.2  语言模型API  419
11.5.3  使用注解生成源码  419
练习  423
第12章  日期和时间API  427
12.1  时间线  428
12.2  本地日期  430
12.3  日期调整器  433
12.4  本地时间  435
12.5  时区时间  436
12.6  格式化和解析  439
12.7  应对遗留代码  442
练习  443
第13章  国际化  447
13.1  本地化  448
13.1.1  指定本地化  448
13.1.2  默认的locale  451
13.1.3  显示名称  452
13.2  数字格式化  453
13.3  货币符号  454
13.4  日期和时间格式化  455
13.5  排序和规范化  457
13.6  消息格式化  459
13.7  资源束  461
13.7.1  组织资源束  462
13.7.2  资源束类  464
13.8  字符编码  465
13.9  首选项  466
练习  468
第14章  编译与脚本  471
14.1  编译器API  471
14.1.1  调用编译器  472
14.1.2  启动编译任务  472
14.1.3  从内存读取源文件  473
14.1.4  向内存写入字节码  474
14.1.5  捕获诊断信息  476
14.2  脚本API  476
14.2.1  获取脚本引擎  476
14.2.2  绑定  477
14.2.3  重定向输入与输出  478
14.2.4  调用脚本函数和方法  479
14.2.5  编译脚本  480
14.3  Nashorn脚本引擎  481
14.3.1  从命令行运行Nashorn  481
14.3.2  调用getter、setter和重载方法  482
14.3.3  构造Java对象  483
14.3.4  JavaScript和Java中的字符串  485
14.3.5  数字  485
14.3.6  使用数组  486
14.3.7  列表与映射  487
14.3.8  lambda表达式  488
14.3.9  继承Java类与实现Java接口  489
14.3.10  异常  491
14.4  shell脚本与Nashorn  491
14.4.1  执行shell命令  492
14.4.2  字符串插值  492
14.4.3  脚本输入  493
练习  494
第15章  Java平台模块系统  499
15.1  模块的概念  500
15.2  模块命名  501
15.3  模块化“Hello, World!”程序  502
15.4  引入模块  504
15.5  导出包  506
15.6  模块化和反射访问  510
15.7  模块化的JAR  513
15.8  自动模块和未命名模块  515
15.9  用于迁移的命令行标识  516
15.10  传递和静态引入  518
15.11  限定导入和打开  520
15.12  服务加载  521
15.13  模块化用的工具  522
练习  525
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>写给大忙人的Java SE 9核心技术
