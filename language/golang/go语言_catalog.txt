>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go语言编程
序 为什么我们需要一门新的语言？
第1章 初识Go语言
1.1 Go语言简史
1.2 语言特性
1.3 “Hello, world!”
1.4 编译环境
1.5 开发工具
1.6 工程管理
1.7 问题追踪和调试
1.8 如何寻求帮助
本章小结
第2章 顺序编程
2.1 变量、常量和类型
2.1.1 变量
2.1.2 常量
2.1.3 类型
2.2 流程控制
2.2.1 条件语句
2.2.2 选择语句
2.2.3 循环
2.2.4 跳转语句
2.3 函数
2.3.1 函数调用
2.3.2 不定参数
2.3.3 多返回值
2.3.4 匿名函数与闭包
2.4 错误处理
2.4.1 error接口
2.4.2 defer
2.4.3 panic和recover
本章小结
第3章 面向对象编程
3.1 类型系统
3.1.1 给类型添加方法
3.1.2 值语义和引用语义
3.2 结构体
3.2.1 初始化
3.2.2 匿名组合
3.2.3 成员可访问性
3.3 接口
3.3.1 其他语言中的接口
3.3.2 非侵入式接口
3.3.3 接口赋值
3.3.4 接口查询
3.3.5 类型查询
3.3.6 Any类型
本章小结
第4章 工程管理
4.1 Go命令行工具
4.2 代码风格
4.3 工程组织
4.4 单元测试
4.5 文档管理
4.6 工程构建
4.7 包的管理与分发
4.8 跨平台开发
4.8.1 Go语言的跨平台能力
4.8.2 交叉编译
4.8.3 Android支持
本章小结
第5章 并发编程
5.1 初识Goroutine
5.1.1 基本用法
5.1.2 Goroutine通信
5.2 Channel
5.2.1 基本用法
5.2.2 关闭
5.2.3 变量的传递
5.2.4 单向Channel
5.2.5 超时处理
5.3 多核并行化
5.4 同步机制
5.4.1 sync包简介
5.4.2 同步锁
5.4.3 Once类型
本章小结
第6章 网络编程
6.1 HTTP编程
6.1.1 客户端编程
6.1.2 开发HTTP服务器
6.2 JSON
6.2.1 JSON简介
6.2.2 编码
6.2.3 解码
6.2.4 未知类型的解码
6.2.5 流式读写
6.3 网站开发
6.3.1 一个最简单的网站
6.3.2 开发一个相册网站
6.3.2.1 新建工程
6.3.2.2 实现网络服务
6.3.2.3 网页模板渲染
6.3.2.4 缓存
6.3.2.5 错误处理
6.3.2.6 防止程序崩溃
6.3.2.7 资源分离
6.3.2.8 重构
6.4 更多资源
本章小结
第7章 进阶话题
7.1 Go语言中的内存管理
7.2 反射
7.3 语言交互性CGO
7.4 链接符号
7.5 Goroutine实现机制
7.6 接口的奥秘
本章小结
第8章 开发工具
8.1 Go语言开发工具
8.2 gEdit
8.3 Goclipse - 使用Eclipse开发和调试Go程序
8.4 VIM
8.5 Nodepad++，Windows上的Go开发环境搭建
8.6 GolangIDE
本章小结
附录 Go语言包参考
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go语言编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go语言实战
第1章　关于Go语言的介绍　1
1．1　用Go解决现代编程难题　2
1．1．1　开发速度　2
1．1．2　并发　3
1．1．3　Go语言的类型系统　5
1．1．4　内存管理　7
1．2　你好，Go　7
1．3　小结　8
第2章　快速开始一个Go程序　9
2．1　程序架构　9
2．2　main包　11
2．3　search包　13
2．3．1　search．go　13
2．3．2　feed．go　21
2．3．3　match．go default．go　24
2．4　RSS匹配器　30
2．5　小结　36
第3章　打包和工具链　37
3．1　包　37
3．1．1　包名惯例　38
3．1．2　main包　38
3．2　导入　39
3．2．1　远程导入　40
3．2．2　命名导入　40
3．3　函数init　41
3．4　使用Go的工具　42
3．5　进一步介绍Go开发工具　44
3．5．1　go vet　44
3．5．2　Go代码格式化　45
3．5．3　Go语言的文档　45
3．6　与其他Go开发者合作　48
3．7　依赖管理　48
3．7．1　第三方依赖　49
3．7．2　对gb的介绍　50
3．8　小结　52
第4章　数组、切片和映射　53
4．1　数组的内部实现和基础功能　53
4．1．1　内部实现　53
4．1．2　声明和初始化　54
4．1．3　使用数组　55
4．1．4　多维数组　58
4．1．5　在函数间传递数组　59
4．2　切片的内部实现和基础功能　60
4．2．1　内部实现　60
4．2．2　创建和初始化　61
4．2．3　使用切片　63
4．2．4　多维切片　74
4．2．5　在函数间传递切片　75
4．3　映射的内部实现和基础功能　76
4．3．1　内部实现　76
4．3．2　创建和初始化　78
4．3．3　使用映射　79
4．3．4　在函数间传递映射　81
4．4　小结　82
第5章　Go语言的类型系统　83
5．1　用户定义的类型　83
5．2　方法　87
5．3　类型的本质　90
5．3．1　内置类型　91
5．3．2　引用类型　91
5．3．3　结构类型　93
5．4　接口　95
5．4．1　标准库　96
5．4．2　实现　98
5．4．3　方法集　99
5．4．4　多态　103
5．5　嵌入类型　105
5．6　公开或未公开的标识符　113
5．7　小结　121
第6章　并发　122
6．1　并发与并行　122
6．2　goroutine　125
6．3　竞争状态　132
6．4　锁住共享资源　135
6．4．1　原子函数　135
6．4．2　互斥锁　138
6．5　通道　140
6．5．1　无缓冲的通道　141
6．5．2　有缓冲的通道　146
6．6　小结　149
第7章　并发模式　150
7．1　runner　150
7．2　pool　158
7．3　work　168
7．4　小结　174
第8章　标准库　176
8．1　文档与源代码　177
8．2　记录日志　178
8．2．1　log包　179
8．2．2　定制的日志记录器　182
8．2．3　结论　186
8．3　编码 解码　187
8．3．1　解码JSON　187
8．3．2　编码JSON　192
8．3．3　结论　193
8．4　输入和输出　193
8．4．1　Writer和Reader接口　194
8．4．2　整合并完成工作　195
8．4．3　简单的curl　199
8．4．4　结论　200
8．5　小结　200
第9章　测试和性能　201
9．1　单元测试　201
9．1．1　基础单元测试　202
9．1．2　表组测试　205
9．1．3　模仿调用　208
9．1．4　测试服务端点　212
9．2　示例　217
9．3　基准测试　220
9．4　小结　224
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go语言实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go语言学习笔记
上卷 语言详解
第1 章 概述 ................................................................................................................. 3
1.1 特征 ......................................................................................................................... 3
1.2 简介 ......................................................................................................................... 6
第2 章 类型 ............................................................................................................... 18
2.1 变量 ....................................................................................................................... 18
2.2 命名 ....................................................................................................................... 22
2.3 常量 ....................................................................................................................... 24
2.4 基本类型 ............................................................................................................... 28
2.5 引用类型 ............................................................................................................... 31
2.6 类型转换 ............................................................................................................... 33
2.7 自定义类型 ........................................................................................................... 34
第3 章 表达式 ........................................................................................................... 38
3.1 保留字 ................................................................................................................... 38
3.2 运算符 ................................................................................................................... 38
3.3 初始化 ................................................................................................................... 44
3.4 流控制 ................................................................................................................... 45
第4 章 函数 ............................................................................................................... 59
4.1 定义 ....................................................................................................................... 59
4.2 参数 ....................................................................................................................... 63
4.3 返回值 ................................................................................................................... 67
4.4 匿名函数 ............................................................................................................... 69
4.5 延迟调用 ............................................................................................................... 76
4.6 错误处理 ............................................................................................................... 80
第5 章 数据 ............................................................................................................... 86
5.1 字符串 ................................................................................................................... 86
5.2 数组 ....................................................................................................................... 95
5.3 切片 ..................................................................................................................... 100
5.4 字典 ..................................................................................................................... 110
5.5 结构 ..................................................................................................................... 118
第6 章 方法 ............................................................................................................. 130
6.1 定义 ..................................................................................................................... 130
6.2 匿名字段 ............................................................................................................. 133
6.3 方法集 ................................................................................................................. 134
6.4 表达式 ................................................................................................................. 136
第7 章 接口 ............................................................................................................. 141
7.1 定义 ..................................................................................................................... 141
7.2 执行机制 ............................................................................................................. 145
7.3 类型转换 ............................................................................................................. 150
7.4 技巧 ..................................................................................................................... 151
第8 章 并发 ............................................................................................................. 153
8.1 并发的含义 ......................................................................................................... 153
8.2 通道 ..................................................................................................................... 163
8.3 同步 ..................................................................................................................... 183
第9 章 包结构 ......................................................................................................... 187
9.1 工作空间 ............................................................................................................. 187
9.2 导入包 ................................................................................................................. 188
9.3 组织结构 ............................................................................................................. 192
9.4 依赖管理 ............................................................................................................. 197
第10 章 反射 ........................................................................................................... 200
10.1 类型 ................................................................................................................... 200
10.2 值 ....................................................................................................................... 207
10.3 方法 ................................................................................................................... 210
10.4 构建 ................................................................................................................... 212
10.5 性能 ................................................................................................................... 213
第11 章 测试 ........................................................................................................... 216
11.1 单元测试 ........................................................................................................... 216
11.2 性能测试 ........................................................................................................... 221
11.3 代码覆盖率 ....................................................................................................... 224
11.4 性能监控 ........................................................................................................... 226
第12 章 工具链 ........................................................................................................ 229
12.1 安装 ................................................................................................................... 229
12.2 工具 ................................................................................................................... 231
12.3 编译 ................................................................................................................... 234
下卷 源码剖析
第13 章 准备 ............................................................................................................ 243
第14 章 引导 ............................................................................................................ 244
第15 章 初始化 ........................................................................................................ 247
第16 章 内存分配 ..................................................................................................... 255
16.1 概述 ................................................................................................................... 255
16.2 初始化 ............................................................................................................... 259
16.3 分配 ................................................................................................................... 265
16.4 回收 ................................................................................................................... 279
16.5 释放 ................................................................................................................... 283
16.6 其他 ................................................................................................................... 285
第17 章 垃圾回收 ...................................................................................................... 291
17.1 概述 ................................................................................................................... 291
17.2 初始化 ............................................................................................................... 293
17.3 启动 ................................................................................................................... 294
17.4 标记 ................................................................................................................... 300
17.5 清理 ................................................................................................................... 311
17.6 监控 ................................................................................................................... 314
17.7 其他 ................................................................................................................... 317
第18 章 并发调度 ...................................................................................................... 326
18.1 概述 ................................................................................................................... 326
18.2 初始化 ............................................................................................................... 327
18.3 任务 ................................................................................................................... 332
18.4 线程 ................................................................................................................... 344
18.5 执行 ................................................................................................................... 353
18.6 连续栈 ............................................................................................................... 370
18.7 系统调用 ........................................................................................................... 385
18.8 监控 ................................................................................................................... 390
18.9 其他 ................................................................................................................... 396
第19 章 通道 ............................................................................................................. 407
19.1 创建 ................................................................................................................... 407
19.2 收发 ................................................................................................................... 408
19.3 选择 ................................................................................................................... 418
第20 章 延迟 ............................................................................................................. 427
20.1 定义 ................................................................................................................... 427
20.2 性能 ................................................................................................................... 433
20.3 错误 ................................................................................................................... 434
第21 章 析构 ............................................................................................................. 438
21.1 设置 ................................................................................................................... 438
21.2 清理 ................................................................................................................... 443
21.3 执行 ................................................................................................................... 445
第22 章 缓存池 ......................................................................................................... 450
22.1 初始化 ............................................................................................................... 450
22.2 操作 ................................................................................................................... 453
22.3 清理 ................................................................................................................... 455
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go语言学习笔记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go语言高级编程
第1章 语言基础
1.1 Go语言创世纪
1.2 Hello, World 的革命
1.3 数组、字符串和切片
1.4 函数、方法和接口
1.5 面向并发的内存模型
1.6 常见的并发模式
1.7 错误和异常
1.8 补充说明
第2章 CGO编程
2.1 快速入门
2.2 CGO基础
2.3 类型转换
2.4 函数调用
2.5 内部机制
2.6 实战: 封装qsort
2.7 CGO内存模型
2.8 C++类包装
2.9 静态库和动态库
2.10 编译和链接参数
2.11 补充说明
第3章 汇编语言
3.1 快速入门
3.2 计算机结构
3.3 常量和全局变量
3.4 函数
3.5 控制流
3.6 再论函数
3.7 汇编语言的威力
3.8 例子：Goroutine ID
3.9 Delve调试器
3.10 补充说明
第4章 RPC和Protobuf
4.1 RPC入门
4.2 Protobuf
4.3 玩转RPC
4.4 gRPC入门
4.5 gRPC进阶
4.6 gRPC和Protobuf扩展
4.7 pbgo: 基于Protobuf的框架
4.8 grpcurl工具
4.9 补充说明
第5章 Go和Web
5.1 Web开发简介
5.2 请求路由
5.3 中间件
5.4 请求校验
5.5 和数据库打交道
5.6 服务流量限制
5.7 大型Web项目分层
5.8 接口和表驱动开发
5.9 灰度发布和A/B测试
5.10 补充说明
第6章 分布式系统
6.1 分布式 id 生成器
6.2 分布式锁
6.3 延时任务系统
6.4 分布式搜索引擎
6.5 负载均衡
6.6 分布式配置管理
6.7 分布式爬虫
6.8 补充说明
附录
附录A: Go语言常见坑
附录B: 有趣的代码片段
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go语言高级编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go语言趣学指南
版权
版权声明
内容提要
译者序
前言
致谢
关于本书
关于作者
资源与支持
第0单元　入门
第1章　各就各位，预备，Go！
1.1　什么是Go
1.2　Go Playground
1.3　包和函数
1.4　唯一允许的大括号放置风格
1.5　小结
第1单元　命令式编程
第2章　被美化的计算器
2.1　执行计算
2.2　格式化输出
2.3　常量和变量
2.4　走捷径
2.4.1　一次声明多个变量
2.4.2　增量并赋值操作符
2.5　数字游戏
2.6　小结
第3章　循环和分支
3.1　真或假
3.2　比较
3.3　使用if实现分支判断
3.4　逻辑运算符
3.5　使用switch实现分支判断
3.6　使用循环实现重复执行
3.7　小结
第4章　变量作用域
4.1　审视作用域
4.2　简短声明
4.3　作用域的范围
4.4 小结
第5章　单元实验：前往火星的航行票
第2单元　类型
第6章　实数
6.1　声明浮点类型变量
6.1.1　单精度浮点数
6.1.2　零值
6.2　打印浮点类型
6.3　浮点精确性
6.4　比较浮点数
6.5　小结
第7章　整数
7.1　声明整数类型变量
7.1.1　为不同场合而设的整数类型
7.1.2　了解类型
7.2　为8位颜色使用uint8类型
7.3　整数回绕
7.3.1　聚焦二进制位
7.3.2　避免时间回绕
7.4　小结
第8章　大数
8.1　击中天花板
8.2　big包
8.3　大小非同寻常的常量
8.4　小结
第9章　多语言文本
9.1　声明字符串变量
9.2　字符、代码点、符文和字节
9.3　拉弦
9.4　使用凯撒加密法处理字符
9.5　将字符串解码为符文
9.6　小结
第10章　类型转换
10.1　类型不能混合使用
10.2　数字类型转换
10.3　类型转换的危险之处
10.4　字符串转换
10.5　转换布尔值
10.6　小结
第11章　单元实验：维吉尼亚加密法
第3单元　构建块
第12章　函数
12.1　函数声明
12.2　编写函数
12.3　小结
第13章　方法
13.1　声明新类型
13.2　引入自定义类型
13.3　通过方法为类型添加行为
13.4　小结
第14章　一等函数
14.1　将函数赋值给变量
14.2　将函数传递给其他函数
14.3　声明函数类型
14.4　闭包和匿名函数
14.5　小结
第15章　单元实验：温度表
第4单元　收集器
第16章　劳苦功高的数组
16.1　声明数组并访问其元素
16.2　小心越界
16.3　使用复合字面量初始化数组
16.4　迭代数组
16.5　数组被复制
16.6　由数组组成的数组
16.7　小结
第17章　切片：指向数组的窗口
17.1　切分数组
17.2　切片的复合字面量
17.3　切片的威力
17.4　带有方法的切片
17.5　小结
第18章　更大的切片
18.1　append函数
18.2　长度和容量
18.3　详解append函数
18.4　三索引切分操作
18.5　使用make函数对切片实行预分配
18.6　声明可变参数函数
18.7　小结
第19章　无所不能的映射
19.1　声明映射
19.2　映射不会被复制
19.3　使用make函数对映射实行预分配
19.4　使用映射进行计数
19.5　使用映射和切片实现数据分组
19.6　将映射用作集合
19.7　小结
第20章　单元实验：切片人生
20.1　开天辟地
20.1.1　观察世界
20.1.2　激活细胞
20.2　适者生存
20.2.1　存活还是死亡
20.2.2　统计邻近细胞
20.2.3　游戏逻辑
20.3　平行世界
第5单元　状态与行为
第21章　结构
21.1　声明结构
21.2　通过类型复用结构
21.3　通过复合字面量初始化结构
21.4　结构被复制
21.5　由结构组成的切片
21.6　将结构编码为JSON
21.7　使用结构标签定制JSON
21.8　小结
第22章　Go没有类
22.1　将方法绑定到结构
22.2　构造函数
22.3　类的替代品
22.4　小结
第23章　组合与转发
23.1　合并结构
23.2　实现自动的转发方法
23.3　命名冲突
23.4　小结
第24章　接口
24.1　接口类型
24.2　探索接口
24.3　满足接口
24.4　小结
第25章　单元实验：火星上的动物避难所
第6单元　深入Go语言
第26章　关于指针的二三事
26.1　&和*
26.2　指针的作用就是指向
26.2.1　指向结构的指针
26.2.2　指向数组的指针
26.3　实现修改
26.3.1　将指针用作形参
26.3.2　指针接收者
26.3.3　内部指针
26.3.4　修改数组
26.4　隐式指针
26.4.1　映射也是指针
26.4.2　切片指向数组
26.5　指针和接口
26.6　明智地使用指针
26.7　小结
第27章　关于nil的纷纷扰扰
27.1　通向惊恐的nil指针
27.2　保护你的方法
27.3　nil函数值
27.4　nil切片
27.5　nil映射
27.6　nil接口
27.7　nil之外的另一个选择
27.8　小结
第28章　孰能无过
28.1　处理错误
28.2　优雅的错误处理
28.2.1　文件写入
28.2.2　关键字defer
28.2.3　创造性的错误处理
28.3　新的错误
28.3.1　按需返回错误
28.3.2　自定义错误类型
28.4　不要惊恐
28.4.1　其他语言中的异常
28.4.2　如何引发惊恐
28.4.3　处理惊恐
28.5　小结
第29章　单元实验：数独规则
第7单元　并发编程
第30章　goroutine和并发
30.1　启动goroutine
30.2　不止一个goroutine
30.3　通道
30.4　使用select处理多个通道
30.5　阻塞和死锁
30.6　地鼠装配线
30.7　小结
第31章　并发状态
31.1　互斥锁
互斥锁的隐患
31.2　长时间运行的工作进程
31.3　小结
第32章　单元实验：寻找火星生命
32.1　可供活动的网格
32.2　报告发现
结语：何去何从
未覆盖内容
告别Go Playground
还有更多
习题答案
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go语言趣学指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go程序设计语言
出版者的话
译者序
前言
第1章 入门 1
1.1 hello，world 1
1.2 命令行参数 3
1.3 找出重复行 6
1.4 GIF动画 10
1.5 获取一个URL 12
1.6 并发获取多个URL 13
1.7 一个Web服务器 14
1.8 其他内容 17
第2章 程序结构 20
2.1 名称 20
2.2 声明 21
2.3 变量 22
2.3.1 短变量声明 22
2.3.2 指针 23
2.3.3 new函数 25
2.3.4 变量的生命周期 26
2.4 赋值 27
2.4.1 多重赋值 27
2.4.2 可赋值性 28
2.5 类型声明 29
2.6 包和文件 30
2.6.1 导入 31
2.6.2 包初始化 33
2.7 作用域 34
第3章 基本数据 38
3.1 整数 38
3.2 浮点数 42
3.3 复数 45
3.4 布尔值 47
3.5 字符串 47
3.5.1 字符串字面量 49
3.5.2 Unicode 49
3.5.3 UTF-8 50
3.5.4 字符串和字节slice 53
3.5.5 字符串和数字的相互转换 56
3.6 常量 56
3.6.1 常量生成器iota 57
3.6.2 无类型常量 59
第4章 复合数据类型 61
4.1 数组 61
4.2 slice 63
4.2.1 append函数 66
4.2.2 slice就地修改 69
4.3 map 71
4.4 结构体 76
4.4.1 结构体字面量 78
4.4.2 结构体比较 80
4.4.3 结构体嵌套和匿名成员 80
4.5 JSON 82
4.6 文本和HTML模板 87
第5章 函数 92
5.1 函数声明 92
5.2 递归 93
5.3 多返回值 96
5.4 错误 98
5.4.1 错误处理策略 99
5.4.2 文件结束标识 101
5.5 函数变量 102
5.6 匿名函数 104
5.7 变长函数 110
5.8 延迟函数调用 111
5.9 宕机 115
5.10 恢复 118
第6章 方法 120
6.1 方法声明 120
6.2 指针接收者的方法 122
6.3 通过结构体内嵌组成类型 124
6.4 方法变量与表达式 127
6.5 示例：位向量 128
6.6 封装 130
第7章 接口 133
7.1 接口即约定 133
7.2 接口类型 135
7.3 实现接口 136
7.4 使用flag.Value来解析参数 139
7.5 接口值 141
7.6 使用sort.Interface来排序 144
7.7 http.Handler接口 148
7.8 error接口 152
7.9 示例：表达式求值器 154
7.10 类型断言 160
7.11 使用类型断言来识别错误 161
7.12 通过接口类型断言来查询特性 162
7.13 类型分支 164
7.14 示例：基于标记的XML解析 166
7.15 一些建议 168
第8章 goroutine和通道 170
8.1 goroutine 170
8.2 示例：并发时钟服务器 171
8.3 示例：并发回声服务器 174
8.4 通道 176
8.4.1 无缓冲通道 177
8.4.2 管道 178
8.4.3 单向通道类型 180
8.4.4 缓冲通道 181
8.5 并行循环 183
8.6 示例：并发的Web爬虫 187
8.7 使用select多路复用 190
8.8 示例：并发目录遍历 192
8.9 取消 195
8.10 示例：聊天服务器 198
第9章 使用共享变量实现并发 201
9.1 竞态 201
9.2 互斥锁：sync.Mutex 205
9.3 读写互斥锁：sync.RWMutex 208
9.4 内存同步 208
9.5 延迟初始化：sync.Once 210
9.6 竞态检测器 212
9.7 示例：并发非阻塞缓存 212
9.8 goroutine与线程 218
9.8.1 可增长的栈 219
9.8.2 goroutine调度 219
9.8.3 GOMAXPROCS 219
9.8.4 goroutine没有标识 220
第10章 包和go工具 221
10.1 引言 221
10.2 导入路径 221
10.3 包的声明 222
10.4 导入声明 223
10.5 空导入 223
10.6 包及其命名 225
10.7 go工具 226
10.7.1 工作空间的组织 227
10.7.2 包的下载 228
10.7.3 包的构建 229
10.7.4 包的文档化 231
10.7.5 内部包 232
10.7.6 包的查询 233
第11章 测试 235
11.1 go test工具 235
11.2 Test函数 236
11.2.1 随机测试 239
11.2.2 测试命令 240
11.2.3 白盒测试 242
11.2.4 外部测试包 245
11.2.5 编写有效测试 246
11.2.6 避免脆弱的测试 247
11.3 覆盖率 248
11.4 Benchmark函数 250
11.5 性能剖析 252
11.6 Example函数 254
第12章 反射 256
12.1 为什么使用反射 256
12.2 reflect.Type和reflect.Value 257
12.3 Display：一个递归的值显示器 259
12.4 示例：编码S表达式 263
12.5 使用reflect.Value来设置值 266
12.6 示例：解码S表达式 268
12.7 访问结构体字段标签 271
12.8 显示类型的方法 273
12.9 注意事项 274
第13章 低级编程 276
13.1 unsafe.Sizeof、Alignof 和Offsetof 276
13.2 unsafe.Pointer 278
13.3 示例：深度相等 280
13.4 使用cgo调用C代码 282
13.5 关于安全的注意事项 286
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go程序设计语言
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go语言·云动力
目  录
第1章　 快速入门　 　 1
1.1　 编辑和编译　 　 2
1.2　 世界，你好！　 　 9
1.3　 自我复制　 　 11
1.4　 猜数游戏　 　 14
1.5　 图灵机　 　 19
1.6　 排版工具　 　 23
1.7　 游乐场　 　 30
1.8　 位钱　 　 36
1.9　 小结　 　 43
第2章　 静态类型　 　 44
2.1　 数制　 　 45
2.1.1　 整数　 　 45
2.1.2　 二进制补码　 　 46
2.1.3　 整数比较　 　 47
2.1.4　 按位运算　 　 48
2.1.5　 浮点数　 　 50
2.1.6　 复数　 　 51
2.1.7　 优先级　 　 52
2.1.8　 表达式　 　 53
2.2　 字符和字符串　 　 54
2.2.1　 UTF-8编码　 　 54
2.2.2　 Unicode字符　 　 55
2.2.3　 转义字符　 　 56
2.2.4　 字符串　 　 56
2.2.5　 字符串转换　 　 57
2.3　 数组　 　 60
2.3.1　 声明　 　 60
2.3.2　 下标　 　 61
2.3.3　 赋值　 　 61
2.4　 切片　 　 63
2.5　 结构体　 　 67
2.5.1　 项　 　 68
2.5.2　 内置　 　 69
2.6　 指针　 　 71
2.7　 小结　 　 73
第3章　 流程控制　 　 74
3.1　 简单语句　 　 75
3.2　 判断语句if　 　 77
3.3　 多分支语句switch　 　 79
3.4　 循环语句for 　 　 82
3.5　 遍历　 　 84
3.6　 标号和跳转　 　 85
3.7　 作用域　 　 86
3.8　 小结　 　 88
第4章　 函数　 　 89
4.1　 签名　 　 90
4.2　 参数　 　 91
4.3　 返回语句　 　 93
4.4　 函数调用　 　 95
4.5　 闭包　 　 97
4.6　 压后　 　 99
4.7　 派错和恢复　 　 100
4.8　 方法　 　 102
4.9　 包　 　 105
4.10　 导入　 　 107
4.11　 程序初始化　 　 108
4.12　 小结　 　 110
第5章　 动态类型　 　 111
5.1　 映射　 　 112
5.2　 界面类型　 　 116
5.3　 界面值　 　 119
5.4　 error界面　 　 122
5.5　 有界无类　 　 124
5.6　 排序　 　 126
5.7　 类型断言　 　 130
5.8　 类型分支　 　 133
5.9　 反射　 　 135
5.10　 小结　 　 141
第6章　 面向对象　 　 142
6.1　 背景　 　 143
6.2　 术语　 　 146
6.3　 与C++对比　 　 149
6.3.1　 继承　 　 149
6.3.2　 抽象类　 　 151
6.3.3　 泛型　 　 153
6.4　 小结　 　 154
第7章　 并发编程　 　 155
7.1　 背景　 　 156
7.2　 同步通信　 　 158
7.3　 去程　 　 162
7.4　 程道　 　 164
7.5　 遍历与关闭　 　 166
7.6　 MapReduce　 　 168
7.7　 select语句　 　 170
7.8　 程道值　 　 173
7.9　 互斥　 　 175
7.10　 小结　 　 177
第8章　 云计算　 　 178
8.1　 背景　 　 179
8.2　 GAE　 　 181
8.3　 Hello 世界！　 　 183
8.4　 画胡子　 　 185
8.5　 留言录　 　 191
8.6　 用户API　 　 195
8.7　 数据库API　 　 196
8.7.1　 术语　 　 197
8.7.2　 Go数据库API　 　 197
8.7.3　 实体键　 　 199
8.7.4　 查询和索引　 　 200
8.7.5　 实体组　 　 201
8.7.6　 限制　 　 201
8.8　 交易　 　 203
8.9　 散段　 　 205
8.10　 内存缓冲　 　 208
8.11　 大件库　 　 210
8.12　 URL抓取　 　 213
8.13　 任务队列　 　 214
8.13.1　 任务　 　 216
8.13.2　 任务执行　 　 217
8.13.3　 队列　 　 218
8.14　 后端　 　 220
8.15　 能力API 　 　 221
8.16　 电子邮件API 　 　 222
8.16.1　 发送　 　 222
8.16.2　 接收　 　 223
8.17　 信道API　 　 224
8.18　 小结　 　 226
第9章　 标准包　 　 227
9.1　 格式包　 　 228
9.1.1　 格式输出Printf　 　 229
9.1.2　 动词表　 　 230
9.1.3　 宽度和精度　 　 231
9.1.4　 报错　 　 232
9.1.5　 额外标记　 　 232
9.1.6　 格式输入　 　 233
9.1.7　 字符串格式　 　 234
9.2　 字节包　 　 236
9.3　 模板包　 　 239
9.4　 正则表达式包　 　 245
9.5　 时间包　 　 253
9.6　 超链接包　 　 258
9.6.1　 http服务器和客户机　 　 258
9.6.2　 https加密通信　 　 260
9.6.3　 Get　 　 263
9.6.4　 Post　 　 265
9.6.5　 Cookie　 　 268
9.7　 编码包　 　 271
9.7.1　 gob　 　 271
9.7.2　 json　 　 275
附录A　 Go的安装和使用　 　 277
附录B　 EBNF　 　 284
附录C　 中英术语对照表　 　 291
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go语言·云动力
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go语言并发之道
前言 1
第1章 并发概述 9
摩尔定律，Web Scale和我们所陷入的混乱 10
为什么并发很难？ 12
竞争条件 13
原子性 15
内存访问同步 17
死锁、活锁和饥饿 20
确定并发安全 28
面对复杂性的简单性 31
第2章 对你的代码建模：通信顺序进程 33
并发与并行的区别 33
什么是CSP 37
如何帮助你 40
Go语言的并发哲学 43
第3章 Go语言并发组件 47
goroutine 47
sync包 58
WaitGroup 58
互斥锁和读写锁 60
cond 64
once 69
池 71
channel 76
select 语句 92
GOMAXPROCS控制 97
小结 98
第4章 Go语言的并发模式 99
约束 99
for-select循环103
防止goroutine泄漏 104
or-channel 109
错误处理112
pipeline 116
构建pipeline的最佳实践 120
一些便利的生成器 126
扇入，扇出 132
or-done-channel 137
tee-channel 139
桥接channel模式 140
队列排队143
context包 151
小结 168
第5章 大规模并发 169
异常传递169
超时和取消 178
心跳 184
复制请求197
速率限制199
治愈异常的goroutine 215
小结 222
第6章 goroutine和Go语言运行时 223
工作窃取223
窃取任务还是续体 231
向开发人员展示所有这些信息 240
尾声 240
附录A 241
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go语言并发之道
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go 语言程序设计
Go语言程序设计》
第1章　5个例子　1
1.1　开始　1
1.2　编辑、编译和运行　3
1.3　Hello Who?　6
1.4　大数字——二维切片　8
1.5　栈——自定义类型及其方法　12
1.6　americanise示例——文件、映射和闭包　18
1.7　从极坐标到笛卡儿坐标——并发　28
1.8　练习　33
第2章　布尔与数值类型　35
2.1　基础　35
2.2　布尔值和布尔表达式　39
2.3　数值类型　40
2.3.1　整型　42
2.3.2　浮点类型　46
2.4　例子：statistics　53
2.4.1　实现一个简单的统计函数　54
2.4.2　实现一个基本的HTTP服务器　55
2.5　练习　58
第3章　字符串　60
3.1　字面量、操作符和转义　61
3.2　比较字符串　63
3.3　字符和字符串　65
3.4　字符串索引与切片　67
3.5　使用fmt包来格式化字符串　69
3.5.1　格式化布尔值　73
3.5.2　格式化整数　74
3.5.3　格式化字符　75
3.5.4　格式化浮点数　75
3.5.5　格式化字符串和切片　76
3.5.6　为调试格式化　78
3.6　其他字符处理相关的包　80
3.6.1　strings包　81
3.6.2　strconv包　86
3.6.3　utf8包　90
3.6.4　unicode包　91
3.6.5　regexp包　92
3.7　例子：m3u2pls　101
3.8　练习　106
第4章　集合类型　108
4.1　值、指针和引用类型　108
4.2　数组和切片　115
4.2.1　索引与分割切片　119
4.2.2　遍历切片　119
4.2.3　修改切片　121
4.2.4　排序和搜索切片　125
4.3　映射　128
4.3.1　创建和填充映射　129
4.3.2　映射查询　131
4.3.3　修改映射　132
4.3.4　键序遍历映射　132
4.3.5　映射反转　133
4.4　例子　134
4.4.1　猜测分隔符　134
4.4.2　词频统计　136
4.5　练习　141
第5章　过程式编程　144
5.1　语句基础　144
5.1.1　类型转换　147
5.1.2　类型断言　148
5.2　分支　149
5.2.1　if语句　150
5.2.2　switch语句　151
5.3　for循环语句　158
5.4　通信和并发语句　160
5.5　defer、panic和recover　166
5.6　自定义函数　171
5.6.1　函数参数　172
5.6.2　init()函数和main()函数　175
5.6.3　闭包　176
5.6.4　递归函数　178
5.6.5　运行时选择函数　181
5.6.6　泛型函数　183
5.6.7　高阶函数　187
5.7　例子：缩进排序　192
5.8　练习　197
第6章　面向对象编程　199
6.1　几个关键概念　199
6.2　自定义类型　201
6.2.1　添加方法　203
6.2.2　验证类型　207
6.3　接口　209
6.4　结构体　217
6.5　例子　224
6.5.1　FuzzyBool——一个单值自定义类型　224
6.5.2　Shapes——一系列自定义类型　229
6.5.3　有序映射——一个通用的集合类型　240
6.6　练习　248
第7章　并发编程　251
7.1　关键概念　252
7.2　例子　256
7.2.1　过滤器　256
7.2.2　并发的Grep　260
7.2.3　线程安全的映射　266
7.2.4　Apache报告　271
7.2.5　查找副本　278
7.3　练习　285
第8章　文件处理　287
8.1　自定义数据文件　287
8.1.1　处理JSON文件　290
8.1.2　处理XML文件　295
8.1.3　处理纯文本文件　301
8.1.4　处理Go语言二进制文件　307
8.1.5　处理自定义的二进制文件　309
8.2　归档文件　317
8.2.1　创建zip归档文件　317
8.2.2　创建可压缩的tar包　319
8.2.3　解开zip归档文件　321
8.2.4　解开tar归档文件　322
8.3　练习　324
第9章　包　326
9.1　自定义包　326
9.1.1　创建自定义的包　327
9.1.2　导入包　333
9.2　第三方包　334
9.3　Go命令行工具简介　335
9.4　Go标准库简介　336
9.4.1　归档和压缩包　336
9.4.2　字节流和字符串相关的包　336
9.4.3　容器包　337
9.4.4　文件和操作系统相关的包　339
9.4.5　图像处理相关的包　341
9.4.6　数学处理包　341
9.4.7　其他一些包　341
9.4.8　网络包　342
9.4.9　反射包　343
9.5　练习　346
附录A　后记　348
附录B　软件专利的危害　350
附录C　精选书目　353
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go 语言程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>GO语言公链开发实战
推荐序一
推荐序二
前言
第1章　公链设计架构
第2章　交互工具
第3章　守护进程的初始化与运行
第4章　接口层
第5章　内核层：区块与区块链
第6章　内核层：交易
第7章　内核层：智能合约
第8章　内核层：虚拟机
第9章　钱包层
第10章　P2P分布式网络
第11章　数据存储
第12章　共识算法
第13章　矿池及挖矿流程
第14章　展望
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>GO语言公链开发实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go语言入门经典
第1章 起步 1
1.1 Go简介 1
1.1.1 Go语言简史 1
1.1.2 Go是编译型语言 2
1.2 安装Go 2
1.2.1 在Windows系统中安装 3
1.2.2 在macOS或Linux系统中安装 4
1.3 设置环境 4
1.4 编写第一个Go程序——Hello World 5
1.4.1 使用 go run 编译并运行程序 6
1.4.2 Go吉祥物 6
1.5 小结 6
1.6 问与答 7
1.7 作业 7
1.7.1 小测验 7
1.7.2 答案 7
1.8 练习 7
第2章 理解类型 8
2.1 数据类型是什么 8
2.2 区分静态类型和动态类型 8
2.3 使用布尔类型 11
2.4 理解数值类型 12
2.4.1 带符号整数和无符号整数 13
2.4.2 浮点数 14
2.4.3 字符串 14
2.4.4 数组 14
2.5 检查变量的类型 15
2.6 类型转换 16
2.7 小结 17
2.8 问与答 17
2.9 作业 17
2.9.1 小测验 17
2.9.2 答案 17
2.10 练习 18
第3章 理解变量 19
3.1 变量是什么 19
3.2 快捷变量声明 21
3.3 理解变量和零值 21
3.4 编写简短变量声明 22
3.5 变量声明方式 23
3.6 理解变量作用域 24
3.7 使用指针 25
3.8 声明常量 27
3.9 小结 28
3.10 问与答 28
3.11 作业 29
3.11.1 小测验 29
3.11.2 答案 29
3.12 练习 29
第4章 使用函数 30
4.1 函数是什么 30
4.1.1 函数的结构 30
4.1.2 返回单个值 31
4.1.3 返回多个值 32
4.2 定义不定参数函数 33
4.3 使用具名返回值 34
4.4 使用递归函数 35
4.5 将函数作为值传递 36
4.6 小结 38
4.7 问与答 38
4.8 作业 38
4.8.1 小测验 38
4.8.2 答案 38
4.9 练习 39
第5章 控制流程 40
5.1 使用if语句 40
5.2 使用else语句 42
5.3 使用else if语句 43
5.4 使用比较运算符 44
5.5 使用算数运算符 45
5.6 使用逻辑运算符 45
5.7 使用switch语句 46
5.8 使用for语句进行循环 47
5.8.1 包含初始化语句和后续语句的for语句 49
5.8.2 包含range子句的for语句 49
5.9 使用defer语句 50
5.10 小结 52
5.11 问与答 52
5.12 作业 53
5.12.1 小测验 53
5.12.2 答案 53
5.13 练习 53
第6章 数组、切片和映射 54
6.1 使用数组 54
6.2 使用切片 56
6.2.1 在切片中添加元素 56
6.2.2 在切片中删除元素 58
6.2.3 赋值切片中的元素 58
6.3 使用映射 59
6.3.1 从映射中删除元素 60
6.4 小结 61
6.5 问与答 61
6.6 作业 62
6.6.1 小测验 62
6.6.2 答案 62
6.7 练习 62
第7章 使用结构体和指针 63
7.1 结构体是什么 63
7.2 创建结构体 65
7.3 嵌套结构体 68
7.4 自定义结构体数据字段的默认值 69
7.5 比较结构体 71
7.6 理解共有和私有值 72
7.7 区分指针引用和值引用 73
7.8 小结 75
7.9 问与答 75
7.10 作业 76
7.10.1 小测验 76
7.10.2 答案 76
7.11 练习 76
第8章 创建方法和接口 77
8.1 使用方法 77
8.2 创建方法集 79
8.3 使用方法和指针 80
8.4 使用接口 83
8.5 小结 86
8.6 问与答 86
8.7 作业 87
8.7.1 小测验 87
8.7.2 答案 87
8.8 练习 87
第9章 使用字符串 88
9.1 创建字符串 88
9.2 理解rune字面量 89
9.3 拼接字符串 90
9.3.1 使用缓冲区拼接字符串 92
9.3.2 理解字符串是什么 93
9.3.3 处理字符串 94
9.4 小结 97
9.5 问与答 97
9.6 作业 97
9.6.1 小测验 97
9.6.2 答案 97
9.7 练习 98
第10章 错误处理 99
10.1 错误处理及Go语言的独特之处 99
10.2 理解错误类型 101
10.3 创建错误 101
10.4 设置错误格式 102
10.5 从函数返回错误 103
10.6 错误和可用性 104
10.7 慎用panic 104
10.8 小结 106
10.9 问与答 106
10.10 作业 106
10.10.1 小测验 106
10.10.2 答案 106
10.11 练习 107
第11章 使用Goroutine 108
11.1 理解并发 108
11.2 并发和并行 110
11.3 通过Web浏览器来理解并发 110
11.4 阻塞和非阻塞代码 111
11.5 使用Goroutine处理并发操作 112
11.6 定义Goroutine 114
11.7 小结 114
11.8 问与答 114
11.9 作业 115
11.9.1 小测验 115
11.9.2 答案 115
11.10 练习 115
第12章 通道简介 116
12.1 使用通道 116
12.2 使用缓冲通道 119
12.3 阻塞和流程控制 120
12.4 将通道用作函数参数 123
12.5 使用select语句 123
12.6 退出通道 126
12.7 小结 128
12.8 问与答 128
12.9 作业 128
12.9.1 小测验 129
12.9.2 答案 129
12.10 练习
第13章 使用包实现代码重用 130
13.1 导入包 130
13.2 理解包的用途 131
13.3 使用第三方包 132
13.4 安装第三方包 132
13.5 管理第三方依赖 133
13.6 创建包 135
13.7 小结 137
13.8 问与答 137
13.9 作业 137
13.9.1 小测验 137
13.9.2 答案 138
13.10 练习 138
第14章 Go语言命名约定 139
14.1 Go代码格式设置 139
14.2 使用gofmt 140
14.3 配置文本编辑器 141
14.4 命名约定 142
14.5 使用golint 143
14.6 使用godoc 144
14.7 工作流程自动化 147
14.8 小结 148
14.9 问与答 149
14.10 作业 149
14.10.1 小测验 149
14.10.2 答案 149
14.11 练习 149
第15章 测试和性能 150
15.1 测试：软件开发最重要的方面 150
15.1.1 单元测试 151
15.1.2 集成测试 151
15.1.3 功能测试 151
15.1.4 测试驱动开发 151
15.2 testing包 151
15.3 运行表格测试驱动 154
15.4 基准测试 156
15.5 提供测试覆盖率 158
15.6 小结 159
15.7 问与答 159
15.8 作业 159
15.8.1 小测验 159
15.8.2 答案 159
15.9 练习 160
第16章 调试 161
16.1 日志 161
16.2 打印数据 164
16.3 使用fmt包 165
16.4 使用Delve 168
16.5 使用gdb 170
16.6 小结 171
16.7 问与答 171
16.8 作业 171
16.8.1 小测验 171
16.8.2 答案 172
16.9 练习 172
第17章 使用命令行程序 173
17.1 操作输入和输出 174
17.2 访问命令行参数 174
17.3 分析命令行标志 176
17.4 指定标志的类型 177
17.5 自定义帮助文本 178
17.6 创建子命令 179
17.7 POSIX兼容性 182
17.8 安装分享命令行程序 182
17.9 小结 184
17.10 问与答 184
17.11 作业 184
17.11.1小测验 185
17.11.2 答案 185
17.12 练习 185
第18章 创建HTTP服务器 186
18.1 通过Hello World Web服务器宣告您的存在 186
18.2 查看请求和响应 187
18.2.1 使用curl发出请求 188
18.2.2 详谈路由 189
18.3 使用处理程序函数 189
18.4 处理404错误 190
18.5 设置报头 191
18.6响应以不同类型的内容 192
18.7 响应不同类型的请求 194
18.8 获取GET和POST请求中的数据 195
18.9 小结 197
18.10 问与答 198
18.11 作业 198
18.11.1 小测验 198
18.11.2 答案 198
18.12 练习 199
第19章 创建HTTP客户端 200
19.1 理解HTTP 200
19.2 发出GET请求 201
19.3 发出POST请求 202
19.4 进一步控制HTTP请求 204
19.5 调试HTTP请求 205
19.6 处理超时 207
19.7 小结 208
19.8 问与答 209
19.9 作业 209
19.9.1 小测验 209
19.9.2 答案 209
19.10 练习 210
第20章 处理JSON 211
20.1 JSON简介 211
20.2 使用JSON API 213
20.3 在Go语言中使用JSON 213
20.4 解码JSON 217
20.5 映射数据类型 219
20.6 处理通过HTTP收到的JSON 220
20.7 小结 221
20.8 问与答 221
20.9 作业 222
20.9.1 小测验 222
20.9.2 答案 222
20.10 练习 222
第21章 处理文件 223
21.1 文件的重要性 223
21.2 使用ioutil包读写文件 224
21.2.1 读取文件 224
21.2.2 创建文件 225
21.3 写入文件 227
21.4 列出目录的内容 228
21.5 复制文件 229
21.6 删除文件 230
21.7 使用文件来管理配置 231
21.7.1 使用JSON文件 231
21.7.2 使用TOML文件 232
21.8 小结 234
21.9 问与答 234
21.10 作业 234
21.10.1 小测验 235
21.10.2 答案 235
21.11 练习 235
第22章 正则表达式简介 236
22.1定义正则表达式 236
22.2 熟悉正则表达式 238
22.3 使用正则表达式验证数据 239
22.4 使用正则表达式来变换数据 240
22.5 小结 241
22.6 问与答 241
22.7 作业 241
22.7.1 小测验 242
22.7.2 答案 242
22.8 练习 242
第23章 Go语言时间编程 243
23.1 时间元素编程 243
23.2 让程序休眠 245
23.3 设置超时时间 245
23.4 使用ticker 246
23.5 以字符串格式表示时间 247
23.6 使用结构体Time 248
23.7时间加减 249
23.8 比较两个不同的Time结构体 249
23.9 小结 250
23.10 问与答 250
23.11 作业 251
23.11.1 小测验 251
23.11.2 答案 251
23.12 练习 251
第24章 部署Go语言代码 252
24.1 理解目标 252
24.2 压缩二进制文件大小 255
24.3 使用Docker 256
24.4 下载二进制文件 258
24.5 使用go get 259
24.6 通过包管理器发布代码 260
24.7 小结 260
24.8 问与答 260
24.9 作业 261
24.9.1 小测验 261
24.9.2 答案 261
24.10 练习
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go语言入门经典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>机器学习：Go语言实现
译者序
前言
第1章　数据的收集和组织 1
1.1　数据处理-Gopher方式 2
1.2　Go语言收集和组织数据的最佳实践 4
1.3　CSV文件 5
1.3.1　从文件中读取CSV数据 5
1.3.2　处理非预期的域 6
1.3.3　处理非预期的类型 7
1.3.4　用数据帧操作CSV数据 9
1.4　JSON 11
1.4.1　JSON的解析 11
1.4.2　JSON的输出 14
1.5　SQL-like数据库 14
1.5.1　连接到一个SQL数据库 15
1.5.2　查询数据库 15
1.5.3　修改数据库 17
1.6　缓存 17
1.6.1　在内存中缓存数据 17
1.6.2　在本地磁盘中缓存数据 18
1.7　数据版本控制 19
1.7.1　Pachyderm术语 20
1.7.2　部署/安装Pachyderm 20
1.7.3　创建用于数据版本控制的数据仓库 21
1.7.4　把数据存储到数据仓库中 21
1.7.5　从版本化的数据仓库中获取数据 22
1.8　参考书目 22
1.9　小结 23
第2章　矩阵、概率论和统计学 24
2.1　矩阵和向量 24
2.1.1　向量 24
2.1.2　向量操作 25
2.1.3　矩阵 26
2.1.4　矩阵操作 27
2.2　统计学 29
2.2.1　分布 29
2.2.2　统计方法 30
2.2.3　分布可视化 34
2.3　概率论 39
2.3.1　随机变量 40
2.3.2　概率测量 40
2.3.3　独立和条件概率 40
2.3.4　假设检验 41
2.4　参考书目 43
2.5　小结 44
第3章　评估和验证 45
3.1　评估 45
3.1.1　连续指标 46
3.1.2　分类指标 49
3.2　验证 55
3.2.1　训练和测试集 56
3.2.2　保留集 59
3.2.3　交叉验证 60
3.3　参考书目 61
3.4　小结 62
第4章　回归 63
4.1　理解回归模型的术语 63
4.2　线性回归 64
4.2.1　线性回归概述 64
4.2.2　线性回归假设和陷阱 66
4.2.3　线性回归示例 66
4.3　多元线性回归 78
4.4　非线性和其他类型的回归 81
4.5　参考书目 85
4.6　小结 86
第5章　分类 87
5.1　理解分类模型的术语 87
5.2　逻辑回归 88
5.2.1　逻辑回归概述 88
5.2.2　逻辑回归的假设和陷阱 91
5.2.3　逻辑回归示例 92
5.3　k-最近邻 103
5.3.1　kNN概述 103
5.3.2　kNN假设和陷阱 104
5.3.3　kNN示例 105
5.4　决策树和随机森林 106
5.4.1　决策树和随机森林概述 107
5.4.2　决策树和随机森林的假设及陷阱 107
5.4.3　决策树示例 108
5.4.4　随机森林的例子 109
5.5　朴素贝叶斯 109
5.5.1　朴素贝叶斯概念及其重要假设 110
5.5.2　朴素贝叶斯例子 110
5.6　参考书目 111
5.7　小结 112
第6章　集群 113
6.1　理解集群模型术语 113
6.2　距离或相似度的度量 114
6.3　集群技术的评估 115
6.3.1　内部集群评估 115
6.3.2　外部集群评估 120
6.4　k-均值集群 120
6.4.1　k-均值集群综述 120
6.4.2　k-均值的假设和陷阱 122
6.4.3　k-均值集群的例子 123
6.5　其他集群技术 129
6.6　参考书目 130
6.7　小结 130
第7章　时间序列和异常检测 131
7.1　在Go中表示时序数据 131
7.2　理解时间序列的术语 134
7.3　与时间序列有关的统计 135
7.3.1　自相关 135
7.3.2　偏自相关 139
7.4　预测的自回归模型 141
7.4.1　自回归模型概述 141
7.4.2　自回归模型假设和陷阱 142
7.4.3　自回归模型示例 142
7.5　自回归移动平均和其他时间序列模型 151
7.6　异常检测 151
7.7　参考书目 153
7.8　小结 154
第8章　神经网络和深度学习 155
8.1　理解神经网络术语 155
8.2　构建一个简单的神经网络 157
8.2.1　网络中的节点 157
8.2.2　网络架构 158
8.2.3　为什么期望这种架构有作用 159
8.2.4　训练神经网络 160
8.3　使用简单的神经网络 165
8.3.1　在实际数据上训练神经网络 166
8.3.2　评估神经网络 168
8.4　引入深度学习 169
8.4.1　什么是深度学习模型 170
8.4.2　基于Go语言的深度学习 171
8.5　参考书目 177
8.6　小结 178
第9章　部署、分布分析和模型 179
9.1　在远程机器上可靠地运行模型 179
9.1.1　Docker和Docker术语简介 180
9.1.2　Docker化机器学习的应用 181
9.2　构建可拓展和可重现的机器学习流水线 191
9.2.1　搭建Pachyderm和Kubernetes集群 192
9.2.2　构建一个Pachyderm机器学习流水线 193
9.2.3　更新流水线并检查出处 202
9.2.4　缩放流水线阶段 204
9.3　参考书目 206
9.4　小结 206
附录　与机器学习相关的算法/技术 207
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>机器学习：Go语言实现
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go语言从入门到进阶实战（视频教学版）
配套学习资源
前言
第1章  初识Go语言
1.1  Go语言特性
1.2  使用Go的开源项目
1.3  学会安装Go
1.3.1  Windows版安装
1.3.2  Linux版安装
1.4  搭建开发环境
1.4.1  集成开发环境Jetbrains Goland
1.4.2  方便定义功能的编辑器Visual Studio Code
第2章 基本语法与使用
2.1  变量
2.1.1  声明变量
2.1.2  初始化变量
2.1.3  多个变量同时赋值
2.1.4  匿名变量 ——没有名字的变量
2.2  类型
2.2.1  整形
2.2.2  浮点——小数点
2.2.3  示例：输出正弦（sin）图像
2.2.4  布尔——是或否
2.2.5  字符串
2.2.6  字符
2.2.7  切片——能动态分配的空间
2.3  转换不同的数据类型
2.4  指针
2.4.1  认识指针地址和指针类型
2.4.2  从指针获取指针指向的值
2.4.3  使用指针修改值
2.4.4  示例：使用指针变量获取命令行的输入信息
2.4.5  创建指针的另一种方法——new函数
2.5  变量生命期
2.5.1  什么是栈？
2.5.2  什么是堆？
2.5.3  变量逃逸分析（Escape Analysis）——自动决定变量分配位置，提高运行效率
2.6  字符串应用
2.6.1  计算字符串长度
2.6.2  遍历字符串——获取每一个字符串元素
2.6.3  获取字符串的某一段字符
2.6.4  修改字符串
2.6.5  连接字符串
2.6.6  格式化字符串——按照指定格式生成字符串
2.6.7  示例：Base64编码——电子邮件的基础编码格式
2.6.8  示例：从INI配置文件中查询需要的值
2.7  常量——恒定不会改变的值
2.7.2  枚举——一组常量值
2.7.3  将枚举值转换为字符串
2.8  类型别名（Type Alias）
2.8.1  区分类型别名与类型定义
2.8.2  非本地类型不能定义方法
2.8.3  在结构体成员嵌入时使用别名
第3章  容器：存储和组织数据的方式
3.1  数组——固定大小的连续空间
3.1.1  声明数组
3.1.2  初始化数组
3.1.3  遍历数组——访问每一个数组元素
3.2  切片（slice）——动态分配大小的连续空间
3.2.1  从数组或切片生成新的切片
3.2.2  声明切片
3.2.3  使用make构造切片
3.2.4  使用append为切片添加元素
3.2.5  复制切片元素到另一个切片
3.2.6  从切片中删除元素
3.3  映射（map）——建立事物关联的容器
3.3.1  添加关联到map并访问关联和数据
3.3.3  遍历map的“键值对”——访问每一个map中的关联关系
3.3.4  从map中删除键值对（delete）
3.3.5  清空map中的所有元素
3.3.6  能够在并发环境中使用的map——sync.Map
3.4  列表（list）——可以快速增删的非连续空间的容器
3.4.1  初始化列表
3.4.2  在列表中插入元素
3.4.3  从列表中删除元素
3.4.4  遍历列表——访问列表的每一个元素
第4章  流程控制
4.2  构建循环（for）
4.2.1  for中的初始语句——开始循环时执行的语句
4.2.2  for中的条件表达式——控制是否循环的开关
4.2.3  for中的结束语句——每次循环结束时执行的语句
4.3  示例: 九九乘法表
4.4  键值循环（for range）——直接获得对象的索引和数据
4.4.1  遍历数组、切片——获得索引和元素
4.4.2  遍历字符串——获得字符
4.4.3  遍历map——获得map的键和值
4.4.4  遍历通道（channel）——接收通道数据
4.4.5  在遍历中选择希望获得的变量
4.5  分支选择（switch）——拥有多个条件分支的判断
4.5.1  基本写法
4.5.2  跨越case的fallthrough——兼容C语言的case设计
4.6  跳转到指定代码标签（goto）
4.6.1  使用goto退出多层循环
4.6.2  使用goto集中处理错误
4.7  跳出指定循环（break）——可以跳出多层循环
4.8  继续下一次循环（continue）
第5章  函数（function）
5.1  声明函数
5.1.1  普通函数的声明形式
5.1.2  参数类型的简写
5.1.3  函数的返回值
5.1.4  调用函数
5.1.5  示例：将“秒”解析为时间单位
5.1.6  示例：函数中的参数传递效果测试
5.2  函数变量——把函数作为值保存到变量
5.3  示例：字符串的链式处理——操作与数据分离的设计技巧
5.4  匿名函数——没有函数名字的函数
5.4.1  定义一个匿名函数
5.4.1  匿名函数用作回调函数
5.4.2  使用匿名函数实现操作封装
5.5  函数类型实现接口——把函数当做接口调用
5.5.1  结构体实现接口
5.5.2  函数体实现接口
5.5.3  http包中的例子
5.6  闭包（Closure）——引用了外部变量的匿名函数
5.6.1  在闭包内部修改引用的变量
5.6.2  示例：闭包的记忆效应
5.6.3  示例：闭包实现生成器
5.7  可变参数——参数数量不固定的函数形式
5.7.1  fmt包中的例子
5.7.1  遍历可变参数列表——获取每一个参数的值
5.7.2  获得可变参数类型——获得每一个参数的类型
5.7.3  在多个可变参数函数中传递参数
5.8  延迟执行语句（defer）
5.8.1  多个延迟执行语句的处理顺序
5.8.1  使用延迟执行语句在函数退出时释放资源
5.9  处理运行时发生的错误
5.9.1  net包中例子
5.9.1  错误接口的定义格式
5.9.2  自定义一个错误
5.9.3  示例：在解析中使用自定义错误
5.10  宕机（panic）——程序终止运行
5.10.1  手动触发宕机
5.10.2  在运行依赖的必备资源缺失时主动触发宕机
5.10.3  在宕机时触发延迟执行语句
5.11   宕机恢复（recover）——防止程序崩溃
5.11.1  让程序在崩溃时继续执行
5.11.2  panic和recover的关系
第6章  结构体（struct）
6.1  定义结构体
6.2  实例化结构体——为结构体分配内存并初始化
6.2.1  基本的实例化形式
6.2.2  创建指针类型的结构体
6.2.3  取结构体的地址实例化
6.3  初始化结构体的成员变量
6.3.1  使用“键值对”初始化结构体
6.3.2  使用多个值的列表初始化结构体
6.3.3  初始化匿名结构体
6.4  构造函数——结构体和类型的一系列初始化操作的函数封装
6.4.1  多种方式创建和初始化结构体——模拟构造函数重载
6.4.2  带有父子关系的结构体的构造和初始化——模拟父级构造调用
6.5  方法
6.5.1  为结构体添加方法
6.5.2  接收器——方法作用的目标
6.5.3  示例：使用二维矢量模拟玩家移动
6.5.4  为类型添加方法
6.5.5  示例：使用事件系统实现事件的响应和处理
6.6  结构体内嵌
6.6.1  声明结构体内嵌和内嵌的特性
6.6.2  使用组合思想描述对象特性
6.6.3  初始化结构体内嵌
6.6.4  初始化内嵌匿名结构体
6.6.6  成员名字冲突
6.7  示例：使用匿名结构体分离JSON数据
第7章  接口（interface）
7.1  声明接口
7.1.1  接口声明的格式
7.1.2  开发中常见的接口及写法
7.1  实现接口的条件
7.1.1  接口被实现的条件一：接口的方法与实现接口的类型方法格式一致
7.1.2  条件二：接口中所有方法均被实现
7.2  理解类型与接口的关系
7.2.1  一个类型可以实现多个接口
7.2.2  多个类型可以实现相同的接口
7.3  示例：便于扩展输出方式的日志系统
7.4  示例：使用接口进行数据的排序
7.4.1  使用sort.Interface接口进行排序
7.4.2  常见类型的便捷排序
7.4.3  对结构体数据进行排序
7.5  接口的嵌套组合	——将多个接口放在一个接口内
7.6  在接口和类型间转换
7.6.1  类型断言的格式
7.6.2  将接口转换为其他接口
7.6.3  将接口转换为其他类型
7.7  空接口类型（interface{}）——能保存所有值的类型
7.7.1  将值保存到空接口
7.7.2  从空接口获取值
7.7.3  空接口间的值比较
7.8  示例：使用空接口实现可以保存任意值的字典
7.9  类型分支——批量判断空接口中变量的类型
7.9.1  类型断言的书写格式
7.9.2  使用类型分支判断基本类型
7.9.3  使用类型分支判断接口类型
7.10  示例：实现有限状态机（FSM）
第8章  包（package）
8.1  工作目录（GOPATH）
8.1.1  使用命令行查看GOPATH信息
8.1.2  使用GOPATH的工程结构
8.1.2  设置和使用GOPATH
8.1.3  在多项目工程中使用GOPATH
8.2  创建包（package）——编写自己的代码扩展
8.3  包在程序启动前的初始化入口：init
8.4  导出标示符——让外部访问包的类型和值
8.4.1  导出包内标示符
8.4.2  导出结构体及接口成员
8.5  导入包（import）——在代码中使用其他的代码
8.5.1  默认导入的写法
8.5.2  导入包后自定义引用的包名
8.5.2  匿名导入包——只导入包但不使用包内类型和数值
8.5.3  理解包导入初始化顺序
8.6 示例：工厂模式自动注册	——管理多个包的结构体
第9章  并发
9.1  轻量级线程（goroutine）——根据需要随时创建的“线程”
9.1.1  使用普通函数创建goroutine
9.1.2  使用匿名函数创建goroutine
9.1.3  调整并发的运行性能（GOMAXPROCS）
9.1.4  理解并发和并行
9.1.5  理解Go的协作程序（goroutine）和普通的协作程序（coroutine）
9.2  通道（channel）	——在多个goroutine间通信的管道
9.2.1  通道的特性
9.2.2  声明通道类型
9.2.3  创建通道
9.2.4  使用通道发送数据
9.2.5  使用通道接收数据
9.2.6  关闭通道后继续使用通道
9.2.7  示例：并发打印
9.2.8  单向通道——通道中的单行道
9.2.9  带缓冲的通道——允许在通道中保存一定数量的数据
9.2.10  通道的多路复用——同时处理接收和发送多个通道的数据
9.2.11  示例：模拟远程过程调用（RPC）
9.2.12  示例：使用通道响应计时器的事件
9.3  示例：Telnet回音服务器——TCP服务器的基本结构
9.4  同步——保证并发环境下数据访问的正确性
9.4.1  竞态检测——检测代码在并发环境下可能出现的问题
9.4.2  互斥锁（sync.Mutex）——保证同时只有一个goroutine可以访问共享资源
9.4.3  读写互斥锁（sync.RWMutex）——在读比写多的环境下比互斥锁更高效
9.4.4  等待组（sync.WaitGroup）——保证在并发环境中完成指定数量的任务
第10章  反射
10.1  反射的类型对象（reflect.Type）
10.1.1  理解反射的类型（Type）与种类（Kind）
10.1.2  指针与指针指向的元素
10.1.3  使用反射获取结构体的成员类型
10.1.4  结构体标记（Struct Tag）——对结构体字段的额外信息标记
10.2  反射的值对象(reflect.Value)
10.2.1  使用反射值对象包装任意值
10.2.2  从反射值对象获取被包装的值
10.2.3  使用反射访问结构体的成员字段的值
10.2.4  判定反射的零值和空
10.2.5  使用反射值对象修改变量的值
10.2.6  通过类型创建类型的实例
10.2.7  使用反射调用函数
10.3  示例：将结构体的数据保存为JSON格式的文本数据
第11章  编译与工具
11.1  编译（go build）
11.1.1  go build无参数编译
11.1.2  go build + 文件列表
11.1.3  go build + 包
11.1.4  go build编译时的附加参数
11.2  编译后运行（go run）
11.3  编译并安装（go install）
11.2  一键获取代码、编译并安装（go get）
11.2.1  远程包的路径格式
11.2.2  go get + 远程包
11.2.3  go get使用时的附加参数
11.3  测试（go test）
11.3.1  单元测试——测试和验证代码的框架
11.3.2  基准测试——获得代码内存占用和运行效率的性能数据
11.4  性能分析（go pprof）——发现代码性能问题的调用位置
11.4.1  安装第三方图形化显式分析数据工具（Graphviz）
11.4.2  安装第三方性能分析分析代码包
11.4.3  性能分析代码
第12章  避坑与技巧
12.1  合理的使用并发特性
12.1.1  了解goroutine的生命期时再创建goroutine
12.1.2  避免在不必要的地方使用通道
12.2  反射：性能和灵活性的双刃剑
12.3  接口的nil判断
12.4  map的多键索引——多个数值条件可以同时查询
12.4.1  基于哈希值的多键索引及查询
12.4.2  利用map特性的多键索引及查询
12.4.3  总结
12.5  优雅的处理TCP粘包——一套完备的TCP协议的客户端和服务器框架
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go语言从入门到进阶实战（视频教学版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go语言编程入门与实战技巧
第1章  认识Go语言  1
1.1  Go语言简介  1
1.1.1  Go语言简史  1
1.1.2  Go语言特性  2
1.1.3  谁适合使用Go语言  2
1.2  Go语言的开发环境部署  3
1.2.1  Go语言环境变量  3
1.2.2  在Linux上安装Go语言环境  3
1.2.3  在Mac OS上安装Go语言环境  5
1.2.4  在Windows上安装Go语言环境  5
1.3  Go语言的基本命令及使用  5
1.3.1  GOROOT结构  6
1.3.2  GOPATH结构  7
1.3.3  Go语言命令行参数  8
1.3.4  第一个Go语言程序  12
1.4  Go语言的开发工具  14
1.4.1  Code/Atom  14
1.4.2  VIM-Go  17
1.4.3  Gogland  18
1.4.4  LiteIDE  18
1.4.5  Cloud IDE  19
1.5  本章小结  23
第2章  程序结构  24
2.1  Go语言程序元素  24
2.1.1  标识符  24
2.1.2  关键字  25
2.1.3  字面量  25
2.1.4  分隔符  25
2.1.5  运算符  26
2.1.6  注释  27
2.2  Go语言基本概念  28
2.2.1  常量  28
2.2.2  变量  32
2.3  本章小结  37
第3章  基础数据类型  38
3.1  整型  39
3.1.1  整型的表示  39
3.1.2  整型的运算  39
3.2  浮点型  41
3.2.1  浮点型的表示  41
3.2.2  浮点型的运算  42
3.2.3  复数  42
3.3  字符与字符串  44
3.3.1  字符串的表示  44
3.3.2  操作字符串  46
3.3.3  字符串格式化  60
3.4  布尔型  61
3.4.1  布尔型的表示  61
3.4.2  布尔型的运算  62
3.5  基本数据类型的扩展  63
3.5.1  强制类型转换  63
3.5.2  自定义类型  64
3.5.3  类型别名  64
3.5.4  指针  65
3.6  本章小结  69
第4章  流程控制  70
4.1  条件语句  70
4.1.1  if判断  71
4.1.2  if-else判断  71
4.1.3  else-if判断  73
4.1.4  初始化子语句  74
4.2  选择语句  75
4.2.1  switch语句  75
4.2.2  switch初始化语句  78
4.2.3  select语句  79
4.3  循环语句  80
4.3.1  for的子语句  81
4.3.2  range子语句  82
4.4  延迟语句  84
4.5  标签  87
4.5.1  break  87
4.5.2  continue  89
4.5.3  goto  90
4.6  本章小结  91
第5章  函数  92
5.1  认识函数  92
5.1.1  函数的声明  92
5.1.2  函数的参数  93
5.1.3  函数的返回值  94
5.2  函数的基础  95
5.2.1  多返回值  96
5.2.2  函数作为参数  97
5.2.3  函数作为类型  98
5.2.4  可变参数  99
5.2.5  匿名函数与闭包  102
5.2.6  递归函数  106
5.2.7  内置函数  108
5.3  函数进阶  108
5.3.1  参数传递机制  108
5.3.2  defer与跟踪  111
5.3.3  错误与恢复  116
5.4  本章小结  122
第6章  复合数据类型  123
6.1  数组  123
6.1.1  声明数组  123
6.1.2  访问与修改  124
6.1.3  多维数组  126
6.1.4  将数组传递给函数  127
6.2  切片  128
6.2.1  创建数组切片  129
6.2.2  切片的使用  131
6.2.3  多维切片  137
6.2.4  将切片传递给函数  137
6.3  映射  138
6.3.1  映射的实现  138
6.3.2  映射的创建  139
6.3.3  映射的使用  139
6.3.4  将映射传递给函数  141
6.4  本章小结  142
第7章  包  144
7.1  包的基础  144
7.1.1  包的结构  146
7.1.2  包的导入  147
7.1.3  包的使用  153
7.1.4  Go语言工具箱  154
7.2  自定义包  156
7.2.1  包的制作  157
7.2.2  特定平台的代码  157
7.2.3  godoc生成文档  158
7.2.4  包的打包与发布  159
7.2.5  自定义包的导入  164
7.3  本章小结  165
第8章  结构体与方法  166
8.1  结构体  166
8.1.1  结构体定义  166
8.1.2  结构体使用  172
8.1.3  带标签的结构体  175
8.1.4  匿名字段和内嵌结构体  176
8.2  类型系统  179
8.2.1  用户自定义类型  179
8.2.2  值语义和引用语义  182
8.3  方法  184
8.3.1  方法声明  184
8.3.2  为类型添加方法  187
8.3.3  工厂方法创建结构体  188
8.3.4  基于指针对象的方法  190
8.3.5  方法值和方法表达式  191
8.3.6  方法和未导出字段  193
8.3.7  嵌入类型的方法和继承  194
8.4  本章小结  197
第9章  接口与反射  198
9.1  接口  198
9.1.1  接口是什么  199
9.1.2  接口类型与约定  204
9.1.3  接口实现  208
9.1.4  嵌套接口  210
9.1.5  接口赋值  211
9.1.6  接口查询  213
9.1.7  接口组合  214
9.2  反射  215
9.2.1  方法和类型的反射  215
9.2.2  通过反射修改设置值  216
9.2.3  反射结构  218
9.2.4  Printf和反射  220
9.3  本章小结  222
第10章  并发编程  223
10.1  并发编程基础  223
10.1.1  并发与并行  223
10.1.2  指定使用核心数  225
10.2  协程（goroutine）  227
10.2.1  协程基础  228
10.2.2  协程间通信  229
10.3  通道（channel）  231
10.3.1  基本语法  232
10.3.2  select  232
10.3.3  缓冲机制  233
10.3.4  超时和计时器  234
10.3.5  channel的传递  235
10.3.6  单向channel  236
10.3.7  关闭channel  237
10.4  并发进阶  237
10.4.1  多核并行化  237
10.4.2  协程同步  239
10.4.3  协程和恢复  242
10.5  本章小结  243
第11章  网络编程  244
11.1  Socket编程  244
11.1.1  什么是Socket  244
11.1.2  Dial()函数  246
11.1.3  ICMP示例  247
11.1.4  TCP Socket  249
11.1.5  UDP Socket  253
11.2  HTTP编程  255
11.2.1  HTTP客户端  255
11.2.2  HTTP服务器端  260
11.3  RPC编程  262
11.3.1  Go RPC  263
11.3.2  HTTP RPC  263
11.3.3  TCP RPC  266
11.3.4  JSON RPC  268
11.3.5  RPC接口  271
11.4  数据库  272
11.4.1  database/sql接口  272
11.4.2  使用MySQL数据库  277
11.4.3  使用SQLite数据库  280
11.4.4  使用PostgreSQL数据库  282
11.4.5  NoSQL数据库操作  286
11.5  Go语言使用Cookie  287
11.5.1  设置Cookie  287
11.5.2  读取Cookie  288
11.6  本章小结  288
第12章  I/O编程  289
12.1  输入/输出  289
12.1.1  io：基本I/O接口  289
12.1.2  fmt：格式化I/O  292
12.1.3  文本处理  298
12.2  文件系统  298
12.2.1  os：系统功能实现  298
12.2.2  path：兼容路径操作  299
12.3  数据结构与算法  303
12.3.1  排序  304
12.3.2  container  310
12.4  本章小结  314
第13章  文件处理  315
13.1  文件操作  315
13.1.1  创建文件与查看状态  316
13.1.2  重命名与移动  319
13.1.3  打开与关闭  319
13.1.4  删除与截断  321
13.1.5  读写文件  321
13.1.6  权限控制  325
13.1.7  文件链接  328
13.2  XML处理  330
13.2.1  解析XML  330
13.2.2  生成XML  333
13.3  JSON处理  336
13.3.1  解析JSON  336
13.3.2  生成JSON  338
13.4  日志记录  340
13.4.1  Logrus  341
13.4.2  Seelog  342
13.5  压缩  343
13.5.1  打包与解包  343
13.5.2  压缩与解压  345
13.6  本章小结  347
第14章  安全与测试  348
14.1  安全  348
14.1.1  安全相关的基础概念  348
14.1.2  通信安全  350
14.2  测试  354
14.2.1  单元测试  354
14.2.2  基准测试  362
14.3   本章小结  368
第15章  内存管理  369
15.1  内存分配  369
15.1.1  内存管理基本概念  369
15.1.2  逃逸分析  373
15.2  TCMalloc  376
15.2.1  整体结构  377
15.2.2  小内存分配  378
15.2.3  CentralCache  379
15.2.4  大内存分配  381
15.3  Mspan（内存管理器）  384
15.4  垃圾回收  398
15.4.1  标记清理算法  399
15.4.2  标记实现  403
15.4.3  清理  406
15.4.4  监控  408
15.5  本章小结  408
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go语言编程入门与实战技巧
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go语言核心编程
第1章  基础知识
1.1  语言简介
1.1.1  Go语言的诞生背景
1.1.2  语言特性
1.1.3  Go语言的特性
1.1.4  总结
1.2  初识Go程序
1.3  Go词法单元
1.3.1  token
1.3.2  标识符
1.3.3  操作符（operators）和分隔符（delimiters）
1.3.4  字面常量
1.3.5  总结
1.4  变量和常量
1.4.1  变量
1.4.2  常量
1.5  基本数据类型
1.5.1  布尔类型
1.5.2  整型
1.5.3  浮点型
1.5.4  复数类型
1.5.5  字符串
1.5.6  rune类型
1.6  复合数据类型
1.6.1  指针
1.6.2  数组
1.6.3  切片
1.6.4  map
1.6.5  struct
1.7  控制结构
1.7.1  if语句
1.7.2  switch语句
1.7.3  for语句
1.7.4  标签和跳转
第2章  函数
2.1  基本概念
2.1.1  函数定义
2.1.2  多值返回
2.1.3  实参到形参的传递
2.1.4  不定参数
2.2  函数签名和匿名函数
2.2.1  函数签名
2.2.2  匿名函数
2.3  defer
2.4  闭包
2.4.1  概念
2.4.2  闭包的价值
2.5  panic和recover
2.5.1  基本概念
2.5.2  使用场景
2.6  错误处理
2.6.1  error
2.6.2  错误和异常
2.7  底层实现
2.7.1  函数调用规约
2.7.2  汇编基础
2.7.3  多值返回分析
2.7.4  闭包底层实现
第3章  类型系统
3.1  类型简介
3.1.1  命名类型和未命名类型
3.1.2  底层类型
3.1.3  类型相同和类型赋值
3.1.4  类型强制转换
3.2  类型方法
3.2.1  自定义类型
3.2.2  方法
3.3  方法调用
3.3.1  一般调用
3.3.2  方法值（method value）
3.3.3  方法表达式（method expression）
3.3.4  方法集（method set）
3.3.5  值调用和表达式调用的方法集
3.4  组合和方法集
3.4.1  组合
3.4.2  组合的方法集
3.5  函数类型
第4章  接口
4.1  基本概念
4.1.1  接口声明
4.1.2  接口初始化
4.1.3  接口方法调用
4.1.4  接口的动态类型和静态类型
4.2  接口运算
4.2.1  类型断言（Type Assertion）
4.2.2  类型查询（Type Switches）
4.2.3  接口优点和使用形式
4.3  空接口
4.3.1  基本概念
4.3.2  空接口的用途
4.3.3  空接口和nil
4.4  接口内部实现
4.4.1  数据结构
4.4.2  接口调用过程分析
4.4.3  接口调用代价
4.4.4  空接口数据结构
第5章  并发
5.1  并发基础
5.1.1  并发和并行
5.1.2  goroutine
5.1.3  chan
5.1.4  WaitGroup
5.1.5  select
5.1.6  扇入（Fan in）和扇出（Fan out）
5.1.7  通知退出机制
5.2  并发范式
5.2.1  生成器
5.2.2  管道
5.2.3  每个请求一个goroutine
5.2.4  固定worker工作池
5.2.5  future模式
5.3  context标准库
5.3.1  context的设计目的
5.3.2  基本数据结构
5.3.3  API函数
5.3.4  辅助函数
5.3.5  context的用法
5.3.6  使用context传递数据的争议
5.4  并发模型
5.4.1  CSP简介
5.4.2  调度模型
5.4.3  并发和调度
第6章  反射
6.1  基本概念
6.1.1  基本数据结构和入口函数
6.1.2  基础类型
6.1.3  类型汇总
6.2  反射规则
6.2.1  反射API
6.2.2  反射三定律
6.3  inject库
6.3.1  inject是什么
6.3.2  依赖注入和控制反转
6.3.3  inject实践
6.3.4  inject原理分析
6.4  反射的优缺点
6.4.1  反射的优点
6.4.2  反射的缺点
6.4.3  反射的最佳实践
第7章  语言陷阱
7.1  多值赋值和短变量声明
7.1.1  多值赋值
7.1.2  短变量的声明和赋值
7.2  range复用临时变量
7.3  defer陷阱
7.4  切片困惑
7.4.1  数组
7.4.2  切片
7.5  值、指针和引用
7.5.1  传值还是传引用
7.5.2  函数名的意义
7.5.3  引用语义
7.6  习惯用法
7.6.1  干净与强迫症
7.6.2  comma,ok表达式
7.6.3  简写模式
7.6.4  包中的函数或方法设计
7.6.5  多值返回函数
第8章  工程管理
8.1  编程环境
8.1.1  环境搭建
8.1.2  工程结构
8.1.3  交叉编译
8.2  命名空间和作用域
8.2.1  命名空间
8.2.2  作用域
8.2.3  变量覆盖
8.3  包的基本概念
8.3.1  基本概念
8.3.2  包引用
8.3.3  包加载
8.4  第三方包管理
8.4.1  vendor
8.4.2  dep
第9章  编程哲学
9.1  Go语言设计哲学
9.1.1  少即是多
9.1.2  世界是并行的
9.1.3  组合优于继承
9.1.4  非侵入式的接口
9.1.5  总结
9.2  Go语言发展史
9.2.1  站在巨人的肩膀上
9.2.2  里程碑
9.3  未来
9.3.1  争议
9.3.2  Go 2
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go语言核心编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件故事
版权声明
献辞
译者序
致谢
第1章　引言：软件和编程艺术的兴起
第2章　FORTRAN：早期的“转折点”
第3章　20世纪60年代的惨痛教训：从繁盛到COBOL和IBM 360计划成为现实
第4章　打破巨型计算机的控制：Unix和C
第5章　为大众编程：从达特茅斯的BASIC到Visual Basic
第6章　欧洲的影响力：从Algol到Pascal再到C++
第7章　属于自己的计算机：PC产业的起步及Word的故事
第8章　服务于大众的计算机：从Gooey到Macintosh的漫漫长路
第9章　为每一个人编程：让用户自己动手
第10章　Java：杂乱中诞生的新语言
第11章　一定有更好的方式：Apache和开源运动
后记
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>软件故事
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式缓存
第 1部分 基本功能
第　1章 基于HTTP的内存缓存服务　3
1．1　缓存服务的接口　3
1．1．1　REST接口　3
1．1．2　缓存Set流程　5
1．1．3　缓存Get流程　6
1．1．4　缓存Del流程　7
1．2　Go语言实现　8
1．2．1　main包的实现　8
1．2．2　cache包的实现　9
1．2．3　HTTP包的实现　14
1．3　功能演示　19
1．4　与Redis比较　21
1．4．1　Redis介绍　21
1．4．2　redis-benchmark介绍　23
1．4．3　cache-benchmark介绍　24
1．4．4　性能对比　26
1．5　小结　30
第　2章 基于TCP的内存缓存服务　32
2．1　基于TCP的缓存协议规范　33
2．1．1　协议范式　33
2．1．2　缓存Set流程　35
2．1．3　缓存Get流程　36
2．1．4　缓存Del流程　36
2．2　Go语言实现　37
2．2．1　main函数的变化　37
2．2．2　TCP包的实现　38
2．2．3　客户端的实现　44
2．3　功能演示　45
2．4　性能测试　47
2．5　小结　48
第3章　数据持久化　50
3．1　RocksDB简介　50
3．2　RocksDB性能测试　51
3．2．1　基本读写性能　52
3．2．2　大容量测试　52
3．3　用cgo调用C++库函数　55
3．4　Go语言实现　58
3．4．1　main函数的实现　58
3．4．2　cache包的实现　59
3．5　功能演示　65
3．6　性能测试　67
3．7　小结　69
第　2部分 性能相关
第4章　用pipelining加速性能　73
4．1　pipelining原理　73
4．2　redis pipelining性能对比　75
4．3　Go语言实现　77
4．3．1　main包的实现　77
4．3．2　cacheClient包的实现　86
4．4　性能测试　97
4．5　小结　99
第5章　批量写入　101
5．1　批量写入能够提升写入性能的原理　101
5．2　RocksDB批量写入性能测试　102
5．3　Go语言实现　103
5．4　性能测试　108
5．5　小结　112
第6章　异步操作　113
6．1　异步操作能够提升读取性能的原理　114
6．2　Go语言实现　117
6．3　性能测试　122
6．4　小结　127
第3部分　服务集群
第7章　分布式缓存　131
7．1　为什么我们需要集群服务　131
7．2　负载均衡和一致性散列　133
7．3　获取节点列表的接口　140
7．4　Go语言实现　140
7．4．1　main函数的实现　140
7．4．2　cluster包的实现　141
7．4．3　HTTP包的实现　145
7．4．4　TCP包的实现　147
7．5　功能演示　149
7．6　小结　152
第8章　节点再平衡　154
8．1　节点再平衡的技术细节　154
8．2　节点再平衡的接口　155
8．3　Go语言实现　155
8．3．1　HTTP包的实现　155
8．3．2　cache包的实现　157
8．4　功能演示　162
8．5　小结　164
第9章　缓存生存时间　166
9．1　缓存生存时间的作用　166
9．2　Go语言实现　167
9．2．1　main函数的实现　167
9．2．2　cache包的实现　168
9．3　功能演示　172
9．4　小结　174
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>分布式缓存
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go Web编程
第1章 GO语言环境配置
1.1 Go语言安装
Go语言的三种安装方式
Go语言源码安装
Go语言标准包安装
第三方工具安装
1.2 GOPATH与工作空间
GOPATH设置
应用目录结构
编译应用
获取远程包
程序的整体结构
1.3 Go语言命令
Go语言命令
go build
go clean
go fmt
go get
go install
go test
go doc
其他命令
1.4 Go语言开发工具
LiteIDE
Sublime Text
Vim
Emacs
Eclipse
IntelliJ IDEA
1.5 总结
第2章 Go语言基础
2.1 你好，Go
程序
详解
小结
2.2 Go语言基础
定义变量
常量
内置基础类型
一些技巧
array、slice、map
2.3 流程和函数
流程控制
函数
2.4 struct类型
struct
2.5 面向对象
method
2.6 interface
interface
2.7 并发
goroutine
channels
Buffered Channels
Range和Close
Select
超时
runtime goroutine
2.8 总结
第3章 Web基础
3.1 Web工作方式
URL和DNS解析
HTTP协议详解
请求实例
3.2 GO语言搭建一个Web服务器
http包建立Web服务器
3.3 Go语言如何使Web工作
Web工作方式的几个概念
分析http包运行机制
3.4 Go语言的http包详解
Conn的goroutine
ServeMux的自定义
Go语言代码的执行流程
3.5 总结
第4章 表单
4.1 处理表单的输入
4.2 验证表单的输入
必填字段
数字
中文
英文
电子邮件地址
手机号码
下拉菜单
单选按钮
复选框
日期和时间
身份证号码
4.3 预防跨站脚本
4.4 防止多次递交表单
4.5 处理文件上传
客户端上传文件
4.6 总结
第5章 访问数据库
5.1 database/sql接口
sql.Register
driver.Driver
driver.Conn
driver.Stmt
driver.Tx
driver.Execer
driver.Result
driver.Rows
driver.RowsAffected
driver.Value
driver.ValueConverter
driver.Valuer
database/sql
5.2 使用MySQL数据库
MySQL驱动
示例代码
5.3 使用SQLite数据库
驱动
实例代码
5.4 使用PostgreSQL数据库
驱动
实例代码
5.5 使用beedb库进行ORM开发
安装
如何初始化
插入数据
更新数据
查询数据
删除数据
关联查询
Group By和Having
进一步的发展
5.6 NOSQL数据库操作
redis
MongoDB
5.7 总结
第6章 Session和数据存储
6.1 Session和Cookie
Cookie
Session
小结
6.2 Go语言如何使用Session
Session创建过程
Go语言实现Session管理
6.3 Session存储
6.4 预防Session劫持
Session劫持过程
Session劫持防范
6.5 总结
第7章 文本处理
7.1 XML处理
解析XML
输出XML
7.2 JSON处理
解析JSON
生成JSON
7.3 正则处理
通过正则判断是否匹配
通过正则获取内容
7.4 模板处理
什么是模板
Go语言模板使用
模板中如何插入数据
Must操作
嵌套模板
小结
7.5 文件操作
目录操作
文件操作
7.6 字符串处理
字符串操作
字符串转换
7.7 总结
第8章 Web服务
8.1 Socket编程
什么是Socket
Socket如何通信
Socket基础知识
TCP Socket
UDP Socket
小结
8.2 WebSocket
WebSocket原理
Go语言实现WebSocket
8.3 REST
什么是REST
RESTful的实现
小结
8.4 RPC
RPC工作原理
Go RPC
小结
8.5 总结
第9章 安全与加密
9.1 预防CSRF攻击
什么是CSRF
CSRF的原理
如何预防CSRF
总结
9.2 确保输入过滤
识别数据
过滤数据
区分过滤数据
小结
9.3 避免XSS攻击
什么是XSS
XSS的原理
如何预防XSS
小结
9.4 避免SQL注入
什么是SQL注入
SQL注入实例
如何预防SQL注入
小结
9.5 存储密码
普通方案
进阶方案
专家方案
总结
9.6 加密和解密数据
base64加解密
高级加解密
小结
9.7 总结
第10章 国际化和本地化
10.1 设置默认地区
什么是Locale
设置Locale
小结
10.2 本地化资源
本地化文本信息
本地化日期和时间
本地化货币值
本地化视图和资源
小结
10.3 国际化站点
管理多个本地包
自动加载本地包
template mapfunc
小结
10.4 总结
第11章 错误处理，调试和测试
11.1 错误处理
Error类型
自定义error
错误处理
小结
11.2 使用GDB调试
GDB调试简介
常用命令
调试过程
小结
11.3 Go语言怎么写测试用例
如何编写测试用例
如何编写压力测试
小结
11.4 总结
第12章 部署与维护
12.1 应用日志
seelog介绍
基于seelog的自定义日志处理
发生错误发送邮件
使用应用日志
小结
12.2 网站错误处理
错误处理的目标
如何处理错误
如何处理异常
小结
12.3 应用部署
daemon
Supervisord
小结
12.4 备份和恢复
应用备份
MySQL备份
MySQL恢复
redis备份
redis恢复
小结
12.5 总结
第13章 如何设计一个Web框架
13.1 项目规划
gopath以及项目设置
应用程序流程图
目录结构
框架设计
总结
13.2 自定义路由器设计
HTTP路由
默认的路由实现
beego框架路由实现
13.4 日志和配置设计
日志和配置的重要性
beego的日志设计
beego的配置设计
应用指南
13.5 实现博客的增删改
博客目录
博客路由
数据库结构
控制器
model层
view层
13.6 总结
第14章 扩展Web框架
14.1 静态文件支持
beego静态文件实现和设置
Bootstrap集成
14.2 Session支持
Session集成
Session使用
14.3 表单及验证支持
表单和验证
表单类型
表单验证
14.4 用户认证
HTTP Basic和HTTP Digest认证
oauth和oauth2的认证
自定义认证
14.5 多语言支持
i18n集成
多语言开发使用
14.6 pprof支持
beego支持pprof 使用入门
14.7 小结
附录A 参考资料
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go Web编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go并发编程实战（第2版）
第1章　初识Go语言　　1
1.1　语言特性　　1
1.2　安装和设置　　2
1.3　工程结构　　3
1.3.1　工作区　　3
1.3.2　GOPATH　　4
1.3.3　源码文件　　5
1.3.4　代码包　　8
1.4　标准命令简述　　11
1.5　问候程序　　13
1.6　小结　　14
第2章　语法概览　　15
2.1　基本构成要素　　15
2.1.1　标识符　　15
2.1.2　关键字　　16
2.1.3　字面量　　17
2.1.4　操作符　　17
2.1.5　表达式　　19
2.2　基本类型　　20
2.3　高级类型　　22
2.3.1　数组　　23
2.3.2　切片　　23
2.3.3　字典　　24
2.3.4　函数和方法　　25
2.3.5　接口　　28
2.3.6　结构体　　29
2.4　流程控制　　30
2.4.1　代码块和作用域　　30
2.4.2　if语句　　32
2.4.3　switch语句　　32
2.4.4　for语句　　34
2.4.5　defer语句　　36
2.4.6　panic和recover　　38
2.5　聊天机器人　　40
2.6　小结　　44
第3章　并发编程综述　　45
3.1　并发编程基础　　45
3.1.1　串行程序与并发程序　　46
3.1.2　并发程序与并行程序　　46
3.1.3　并发程序与并发系统　　47
3.1.4　并发程序的不确定性　　47
3.1.5　并发程序内部的交互　　47
3.2　多进程编程　　48
3.2.1　进程　　48
3.2.2　关于同步　　55
3.2.3　管道　　60
3.2.4　信号　　65
3.2.5　socket　　74
3.3　多线程编程　　97
3.3.1　线程　　98
3.3.2　线程的同步　　107
3.4　多线程与多进程　　125
3.5　多核时代的并发编程　　126
3.6　小结　　130
第4章　Go的并发机制　　131
4.1　原理探究　　131
4.1.1　线程实现模型　　132
4.1.2　调度器　　142
4.1.3　更多细节　　158
4.2　goroutine　　160
4.2.1　go语句与goroutine　　160
4.2.2　主goroutine的运作　　166
4.2.3　runtime包与goroutine　　166
4.3　channel　　169
4.3.1　channel的基本概念　　169
4.3.2　单向channel　　180
4.3.3　for语句与channel　　184
4.3.4　select语句　　185
4.3.5　非缓冲的channel　　190
4.3.6　time包与channel　　192
4.4　实战演练：载荷发生器　　198
4.4.1　参数和结果　　199
4.4.2　基本结构　　201
4.4.3　初始化　　206
4.4.4　启动和停止　　212
4.4.5　调用器和功能测试　　221
4.5　小结　　231
第5章　同　　步　　232
5.1　锁的使用　　232
5.1.1　互斥锁　　232
5.1.2　读写锁　　236
5.1.3　锁的完整示例　　238
5.2　条件变量　　244
5.3　原子操作　　247
5.3.1　增或减　　247
5.3.2　比较并交换　　249
5.3.3　载入　　250
5.3.4　存储　　251
5.3.5　交换　　251
5.3.6　原子值　　252
5.3.7　应用于实际　　256
5.4　只会执行一次　　257
5.5　WaitGroup　　258
5.6　临时对象池　　262
5.7　实战演练——Concurrent Map　　265
5.8　小结　　280
第6章　网络爬虫框架设计和实现　　281
6.1　网络爬虫与框架　　281
6.2　功能需求和分析　　283
6.3　总体设计　　284
6.4　详细设计　　286
6.4.1　基本数据结构　　286
6.4.2　接口的设计　　293
6.5　工具的实现　　309
6.5.1　缓冲器　　309
6.5.2　缓冲池　　311
6.5.3　多重读取器　　317
6.6　组件的实现　　318
6.6.1　内部基础接口　　319
6.6.2　组件注册器　　321
6.6.3　下载器　　323
6.6.4　分析器　　325
6.6.5　条目处理管道　　328
6.7　调度器的实现　　329
6.7.1　基本结构　　329
6.7.2　初始化　　331
6.7.3　启动　　333
6.7.4　停止　　343
6.7.5　其他方法　　344
6.7.6　总结　　345
6.8　一个简单的图片爬虫　　346
6.8.1　概述　　346
6.8.2　命令参数　　346
6.8.3　初始化调度器　　348
6.8.4　监控调度器　　354
6.8.5　启动调度器　　364
6.9　扩展与思路　　365
6.10　本章小结　　368
附录A　Go语言的学习资源　　369
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Go并发编程实战（第2版）
