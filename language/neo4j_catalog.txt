>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Neo4j权威指南（图数据库技术丛书）
第1章Neo4j图数据库基础1
1.1图数据库的产生背景2
1.2图数据库基础7
1.2.1图数据库介绍7
1.2.2图数据模型7
1.2.3图计算引擎8
1.2.4图数据库的历史9
1.3图数据库与关系数据库的对比10
1.3.1关系数据库的弊端10
1.3.2图数据模型的优势10
1.4图数据库与其他NoSQL数据库的对比12
1.4.1其他NoSQL数据库的弊端12
1.4.2将键值对存储与图数据库相关联12
1.4.3将文档存储与图数据库相关联13
1.5Neo4j概述13
1.6Neo4j的体系结构15
1.6.1免索引邻接16
1.6.2Neo4j底层存储结构17
1.6.3Neo4j的遍历方式21
1.6.4Neo4j的存储优化22
第2章Neo4j基础入门24
2.1Neo4j的安装部署24
2.1.1Neo4j安装包的下载24
2.1.2在各个操作系统上的安装26
2.1.3Neo4j的启动32
2.2Neo4j管理平台的使用33
2.2.1Web管理平台的使用33
2.2.2neo4j-shell的使用37
2.3Neo4j图数据中基本元素与概念41
2.3.1节点41
2.3.2关系41
2.3.3属性42
2.3.4路径42
2.3.5遍历（Traversal）43
2.4官方入门实例介绍43
2.4.1创建图数据44
2.4.2检索节点46
2.4.3查询关系49
2.4.4思考与练习52
2.4.5清空数据库54
2.5批量导入工具的使用54
2.5.1获取CSV文件54
2.5.2使用LoadCSV指令导入到Neo4j58
2.5.3使用neo4j-import工具导入到Neo4j61
第3章Neo4j之Cypher63
3.1Cypher概述63
3.1.1Cypher是什么63
3.1.2模式（Patterns）65
3.1.3查询和更新图66
3.1.4事务67
3.1.5唯一性68
3.1.6兼容性69
3.2基本语法70
3.2.1类型70
3.2.2表达式70
3.2.3变量73
3.2.4参数73
3.2.5运算符77
3.2.6注释78
3.2.7模式（Patterns）78
3.2.8列表81
3.2.9空值87
3.3语句89
3.3.1MATCH89
3.3.2OPTINALMATCH101
3.3.3WHERE102
3.3.4START113
3.3.5Aggregation114
3.3.6LOADCSV121
3.3.7CREATE125
3.3.8MERGE129
3.3.9SET138
3.3.10DELETE142
3.3.11REMOVE143
3.3.12FOREACH145
3.3.13CREATEUNIQUE146
3.3.14RETURN149
3.3.15ORDERBY153
3.3.16LIMIT155
3.3.17SKIP156
3.3.18WITH158
3.3.19UNWIND160
3.3.20UNION161
3.3.21CALL163
3.4函数167
3.4.1断言（Predicate）函数167
3.4.2标量（Scalar）函数170
3.4.3列表（List）函数177
3.4.4数学函数182
3.4.5字符串函数193
3.4.6自定义函数199
3.5模式（Schema）200
3.5.1索引200
3.5.2约束203
3.5.3统计209
3.6查询调优210
3.6.1查询如何执行210
3.6.2查询性能分析211
3.6.3查询调优举例211
3.6.4USING213
3.7执行计划220
3.7.1开始点运算符221
3.7.2Expand运算符224
3.7.3组合运算符226
3.7.4行运算符234
3.7.5更新运算符241
3.7.6*短路径规划243
第4章Neo4j程序开发246
4.1Neo4j开发入门246
4.1.1Java嵌入式开发模式246
4.1.2各语言驱动包开发模式246
4.2JavaAPI嵌入式开发模式247
4.2.1Java开发前的准备工作248
4.2.2创建Neo4j图实例253
4.2.3图数据遍历功能257
4.2.4数据索引264
4.2.5过程273
4.2.6事务管理280
4.2.7使用Java在线备份Neo4j286
4.2.8使用JMX监控Neo4j286
4.3各语言驱动包开发模式288
4.3.1驱动开发入门289
4.3.2配置和连接292
4.3.3执行Cypher语句297
4.3.4返回结果301
4.3.5数据类型308
4.3.6异常310
4.3.7其他语言驱动311
4.4Neo4jHTTPAPI312
4.4.1流312
4.4.2认证和授权312
4.4.3在一个请求中使用事务316
4.4.4执行多条语句317
4.4.5运行一个事务318
4.4.6在打开的事务中执行语句319
4.4.7重置超时事务319
4.4.8提交事务320
4.4.9回滚事务321
4.4.10查询统计信息321
4.4.11以图格式返回结果322
4.4.12错误处理324
4.4.13在事务中处理错误325
4.5其他开发技术介绍326
4.5.1Spring-Data-Neo4j326
4.5.2Spring-Data-Neo4在项目中的部署326
4.5.3使用Neo4j-OGM的对象图映射327
4.5.4使用JDBC连接Neo4j328
4.5.5JCypher329
4.5.6Groovy＆Grails：Neo4jGrails插件329
4.5.7Clojure：Neocons329
4.5.8Scala：AnormCypher330
4.5.9JPA：HibernateOGM330
第5章Neo4j数据库管理331
5.1部署331
5.1.1系统需求331
5.1.2文件位置332
5.1.3重要端口333
5.1.4设置初始密码334
5.1.5等待Neo4j启动334
5.1.6使用数据收集器335
5.1.7配置Neo4j连接器336
5.1.8安装证书337
5.2监控338
5.2.1指标340
5.2.2日志344
5.2.3查询管理346
5.2.4因果集群监控相关方法348
5.3安全管理350
5.3.1Neo4j社区版用户管理350
5.3.2认证和授权352
5.3.3与LDAP集成362
5.3.4子图访问控制366
5.3.5安全清单367
5.4Neo4j数据库运维与优化368
5.4.1内存调优368
5.4.2事务日志371
5.4.3压缩存储371
5.4.4Linux文件系统调优373
5.4.5磁盘、内存及相关提示373
5.5Neo4j数据库的备份与恢复374
5.5.1备份简介374
5.5.2执行备份375
5.5.3恢复备份377
5.6Neo4j数据库管理相关工具378
5.6.1导入工具378
5.6.2CypherShell382
5.6.3Neo4j数据转储和加载384
5.6.4一致性检查工具385
第6章Neo4j集群技术387
6.1因果集群387
6.1.1初识因果集群388
6.1.2操作视图388
6.1.3应用视图389
6.1.4因果集群的生命周期390
6.1.5创建一个新的因果集群395
6.1.6数据中心灾难恢复398
6.1.7因果集群的数据迁移和恢复400
6.1.8因果集群的其他设置401
6.2高可用性集群401
6.2.1高可用性集群概述402
6.2.2建立Neo4j高可用性集群404
6.2.3状态信息端点406
6.2.4HAProxy用于负载均衡408
6.3集群的备份与恢复410
6.4Neo4j单实例和高可用性集群版本升级411
6.4.1单实例升级411
6.4.2从高可用性集群升级412
第7章Neo4j应用案例413
7.1应用案例概述413
7.2欺诈检测416
7.2.1第一方银行欺诈417
7.2.2保险欺诈424
7.2.3电子商务欺诈427
7.2.4小结428
7.3科研导图428
7.4电子邮件监测437
7.5工商企业图谱442
7.6社交网络449
第8章Neo4j高级应用458
8.1高级索引458
8.1.1空间索引（Neo4jSpatial）458
8.1.2自定义中文全文索引468
8.2在Docker环境下部署Neo4j471
8.2.1概览472
8.2.2Docker配置472
8.2.3Neo4j配置473
8.3自定义批量导入476
8.4Neo4j与图计算479
8.4.1Neo4j-Spark-Connector480
8.4.2Neo4j-Spark-Connector提供的API482
8.5Neo4j与自然语言处理483
8.5.1计算聚合相关性484
8.5.2将文本数据建模为邻接图484
8.5.3加载数据486
8.5.4挖掘单词之间的关系488
8.6其他高级应用490
第9章Neo4j简体中文版491
9.1简介491
9.2下载及安装496
9.3启动及浏览497
9.4指定节点图片499
9.5指定节点尺寸501
9.6指定节点颜色502
9.7指定关系粗细503
9.8指定关系颜色504
9.9智能查询505
9.10导入精灵508
9.10.1安装导入精灵508
9.10.2启动导入精灵509
9.10.3准备Excel样本文件510
9.10.4导入Excel样本文件511
9.10.5准备MySQL样本数据库513
9.10.6导入MySQL样本数据库515
9.10.7查看导入结果516
9.10.8导入精灵映射机制517
附录ANeo4j配置设置521
附录BNeo4j内建过程550
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Neo4j权威指南（图数据库技术丛书）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Neo4j 实战
译者序
序　言
前　言
作者简介
第一部分　Neo4j概述
第1章 Neo4j数据库的一个应用案例 3
1.1 为什么要有Neo4j 4
1.2 关系数据库中的图形数据 4
1.3 Neo4j中的图形数据 8
1.4 大数据下的SQL联接操作与Neo4j图形遍历的对比 10
1.5 图形 13
1.6 Neo4j在NoSQL领域的地位 13
1.6.1 主键值存储 14
1.6.2 列族存储 14
1.6.3 面向文档的数据库 15
1.6.4 图形数据库 15
1.6.5 与NoSQL类数据库的比较 15
1.7 Neo4j具有与ACID兼容的数据格式 16
1.8 本章小结 17
第2章 Neo4j的数据模型 18
2.1 Neo4j中数据模型的类型 18
2.1.1 图表建模的一个简单实例 19
2.1.2 图表建模的一个复杂实例 20
2.2 领域建模 22
2.3 更多实例 26
2.3.1 地铁车站实例 26
2.3.2 乐队成员实例 27
2.4 本章小结 29
第3章 Neo4j开发入门 30
3.1 图形数据结构建模 30
3.2 使用Neo4j API 34
3.2.1 创建节点 34
3.2.2 创建关系 36
3.2.3 为节点添加属性 38
3.2.4 节点类型策略 40
3.2.5 为关系添加属性 41
3.3 节点标签 43
3.4 本章小结 46
第4章 强大的图形遍历功能 47
4.1 使用Neo4j核心Java API进行遍历 47
4.1.1 寻找起始节点 48
4.1.2 遍历直接关系 49
4.1.3 遍历深度为2的关系 51
4.1.4 内存使用注意事项 53
4.2 使用Neo4j的遍历API进行遍历 55
4.2.1 使用Neo4j的内置遍历结构 55
4.2.2 实现一个自定义评估函数 56
4.3 本章小结 59
第5章 数据索引 60
5.1 创建索引项 60
5.2 通过邮箱地址查找用户 62
5.3 对多个匹配结果的处理 64
5.4 对索引过的数据进行修改的处理 65
5.5 自动索引 66
5.5.1 模式索引 66
5.5.2 自动索引 69
5.6 索引的成本/效益权衡 70
5.6.1 索引查询的性能优势 71
5.6.2 当更新和插入数据时索引对性能的影响 72
5.6.3 索引的存储 73
5.7 本章小结 73
第二部分　Neo4j应用开发
第6章 Neo4j的查询语言Cypher 77
6.1 Cypher简介 77
6.1.1 Cypher入门 78
6.1.2 执行Cypher查询 79
6.2 Cypher的基本句法 85
6.2.1 模式匹配 85
6.2.2 查找起始节点 89
6.2.3 过滤数据 92
6.2.4 获得结果 93
6.3 用Cypher更新图形数据 96
6.3.1 创建新图形实体 97
6.3.2 删除数据 99
6.3.3 更新节点和关系属性 99
6.4 高级Cypher 100
6.4.1 聚合 100
6.4.2 函数 101
6.4.3 with语句的管道功能 103
6.4.4 Cypher的兼容性 104
6.5 本章小结 104
第7章 事务 105
7.1 事务的基础知识 105
7.1.1 添加事务 107
7.1.2 打好基础，循序渐进 108
7.2 事务的高级功能 109
7.2.1 事务的语义 109
7.2.2 事务中的读取与显式读锁 111
7.2.3 事务中的写入与显式写锁 112
7.2.4 无效锁的危害 114
7.3 与其他事务管理系统的集成 114
7.4 事务事件 116
7.5 本章小结 117
第8章 深度遍历 118
8.1 遍历的顺序 118
8.1.1 深度优先 119
8.1.2 广度优先 121
8.1.3 深度优先与广度优先顺序的比较 122
8.2 扩展关系 124
8.2.1 标准扩展器 124
8.2.2 用于扩展的顺序关系 126
8.2.3 自定义扩展器 127
8.3 管理唯一性 130
8.3.1 NODE_GLOBAL唯一性 130
8.3.2 NODE_PATH唯一性 132
8.3.3 其他唯一性类型 133
8.4 双向遍历 134
8.5 本章小结 137
第9章 Spring Data Neo4j 138
9.1 SDN适合做什么 138
9.1.1 什么是Spring以及Spring与SDN是怎样关联的 140
9.1.2 SDN适合做什么（及不适合做什么） 140
9.1.3 从哪里获得SDN 141
9.1.4 从哪里获得更多的信息 141
9.2 用SDN建模 141
9.2.1 原始POJO域建模 142
9.2.2 注释域模型 144
9.2.3 建模节点实体 145
9.2.4 建模关系实体 148
9.2.5 建模节点实体之间的关系 150
9.3 访问和持久化实体 152
9.3.1 支持Spring的配置 152
9.3.2 Neo4jTemplate类 153
9.3.3 资源库 154
9.3.4 其他选项 157
9.4 对象图形映射选项 158
9.4.1 简单映射 158
9.4.2 基于AspectJ的高级映射 161
9.4.3 对象映射总结 164
9.5 执行查询和遍历 164
9.5.1 注释查询 164
9.5.2 动态派生查询 166
9.5.3 遍历 168
9.6 本章小结 168
第三部分　Neo4j应用实例
第10章 Neo4j的嵌入式模式与服务器模式 171
10.1 使用模式概述 171
10.2 嵌入式模式 173
10.2.1 核心Java集成 173
10.2.2 其他基于JVM的集成 176
10.3 服务器模式 177
10.3.1 Neo4j服务器概述 178
10.3.2 使用细粒度Neo4j服务器模式的REST API 179
10.3.3 使用Cypher Neo4j服务器模式REST API端点 181
10.3.4 使用远程客户端库帮助访问Neo4j服务器 182
10.3.5 服务器插件和非托管扩展 184
10.4 权衡选项 184
10.4.1 对架构的考虑 185
10.4.2 对性能的考虑 187
10.4.3 其他需要考虑的事项 190
10.5 充分利用服务器模式 190
10.5.1 避免细粒度操作 191
10.5.2 使用Cypher 192
10.5.3 服务器插件 194
10.5.4 非托管扩展 196
10.5.5 流REST API 198
10.6 本章小结 199
第11章 Neo4j的架构与应用 200
11.1 高层Neo4j架构 200
11.1.1 设置场景 202
11.1.2 硬盘 202
11.1.3 存储文件 203
11.1.4 Neo4j缓存 205
11.1.5 事务日志及可恢复性 210
11.1.6 编程API 211
11.2 Neo4j的高可用性 212
11.2.1 Neo4j集群概述 213
11.2.2 设置Neo4j集群 216
11.2.3 复制——读和写的策略 218
11.2.4 缓存分区 222
11.2.5 HA小结 224
11.3 备份 225
11.3.1 离线备份 225
11.3.2 在线备份 227
11.3.3 从备份中还原数据 229
11.4 本书可能没有涵盖但你可能会关注的问题 229
11.4.1 安全 229
11.4.2 监控 229
11.5 本章小结 230
11.6 最后的设想 230
附录A 安装Neo4j服务器 231
附录B 设置和运行示例程序 236
附录C 设置使用SDN的项目环境 241
附录D 获得更多的帮助 247
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Neo4j 实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Neo4j全栈开发
第1章  Neo4j概述	1
1.1  Neo4j数据的特点	2
1.2  Neo4j数据的表现形式	2
1.3  Neo4j的优势	5
1.3.1  查询的高性能	5
1.3.2  设计的灵活性	6
1.3.3  开发的敏捷性	6
1.3.4  与其他数据库的比较	6
1.3.5  综合表现	7
1.4  哪些领域更适合使用Neo4j	8
1.4.1  社区网络	8
1.4.2  推荐引擎	9
1.4.3  交通运输	9
1.4.4  物流管理	9
1.4.5  主数据管理	10
1.4.6  访问控制	10
1.4.7  欺诈检测	10
1.5  哪些领域不适合使用Neo4j	10
1.6  哪些企业在使用Neo4j	11
1.6.1  阿迪达斯的购物网站	12
1.6.2  沃尔玛的内部管理系统	12
1.6.3  eBay的电子商务	13
1.7  丰富的学习资源	13
1.7.1  精选的GraphGists	13
1.7.2  GraphGists门户	15
1.8  小结	16
第2章  Neo4j API应用	18
2.1  创建项目工程	18
2.1.1  项目工程配置	19
2.1.2  引用Neo4j开发包	19
2.2  使用Neo4j API	20
2.2.1  使用嵌入式数据库	20
2.2.2  创建节点和关系	21
2.2.3  查询及更新	22
2.2.4  删除关系和节点	23
2.3  使用标签	25
2.4  使用索引	26
2.4.1  手动索引	26
2.4.2  模式索引	27
2.4.3  模式约束	28
2.5  图的遍历	31
2.5.1  广度优先遍历	32
2.5.2  深度优先遍历	32
2.5.3  遍历的路径	34
2.6  使用Cypher查询语言	37
2.7  连接Neo4j服务器	40
2.8  关于事务	42
2.8.1  Neo4j支持完整的事务管理特性	42
2.8.2  交互周期	43
2.8.3  隔离级别	44
2.8.4  关于死锁	44
2.9  其他开发语言实例	44
2.9.1  Node.js访问Neo4j	45
2.9.2  Python访问Neo4j	46
2.10  小结	47
第3章  Neo4j的安装及使用	48
3.1  安装要求及推荐	48
3.2  安装Neo4j服务器	49
3.2.1  下载Neo4j	49
3.2.2  在Linux操作系统中安装Neo4j	50
3.2.3  在Windows操作系统中安装Neo4j	51
3.3  Neo4j基本配置	52
3.4  Neo4j配置优化	53
3.4.1  页面高速缓存	53
3.4.2  堆大小	54
3.4.3  垃圾收集器	54
3.5  使用Neo4j的Web控制台	55
3.5.1  使用命令行输入框	56
3.5.2  数据库管理信息	57
3.5.3  使用收藏夹	59
3.5.4  使用帮助手册	63
3.5.5  使用浏览器同步功能	65
3.5.6  使用浏览器设置	67
3.5.7  关于Neo4j	68
3.6  小结	69
第4章  Cypher查询语言简介	71
4.1  Cypher语法基础	71
4.1.1  变量定义	72
4.1.2  可用运算符	72
4.2  Cypher读/写查询结构	73
4.2.1  用CREATE创建节点	74
4.2.2  用CREATE创建关系	74
4.2.3  用MERGE创建节点	75
4.2.4  用MERGE创建关系	76
4.2.5  用SET更新数据	76
4.2.6  用DELETE删除数据	77
4.2.7  用REMOVE移除数据	78
4.2.8  使用循环FOREACH	79
4.3  使用索引	79
4.3.1  创建和使用索引	80
4.3.2  删除索引	81
4.4  使用约束	81
4.4.1  创建约束	81
4.4.2  删除约束	81
4.5  使用标签	82
4.6  Cypher只读查询结构	83
4.6.1  条件过滤WHERE	83
4.6.2  联合查询UNION	84
4.6.3  使用链接WITH	84
4.6.4  返回结果RETURN	85
4.7  使用CASE子句	86
4.8  遍历的路径	86
4.8.1  最短路径	87
4.8.2  所有最短路径	88
4.9  使用函数	90
4.10  使用CALL调用存储过程	92
4.11  查询语句性能分析	93
4.12  Cypher的使用范围	95
4.12.1  在neo4j-shell中使用Cypher查询语言	96
4.12.2  在Rest API中使用Cypher查询语言	98
4.13  小结	101
第5章  使用SDN建模和设计存储库接口	103
5.1  SDN简介	103
5.1.1  SDN的特点	103
5.1.2  SDN存储库接口	104
5.2  数据模型设计	105
5.2.1  用户访问控制数据模型	105
5.2.2  购物网站数据模型	106
5.3  数据建模的误区	108
5.4  Neo4j的数据类型	109
5.5  在项目中使用SDN	110
5.5.1  在项目工程中引用SDN依赖	110
5.5.2  建模中可用的OGM注解	111
5.5.3  日期类型转换实例	112
5.6  使用SDN建模	113
5.6.1  节点建模	113
5.6.2  关系建模	116
5.7  使用SDN设计存储库接口	118
5.7.1  创建存储库接口	118
5.7.2  在标准方法中使用路径	120
5.7.3  自定义声明方法	120
5.7.4  使用底层方法	122
5.8  SDN配置	124
5.8.1  配置域对象和存储库接口	125
5.8.2  使用SDN驱动连接数据库	125
5.9  小结	127
第6章  应用实例一：NBA季后赛预测	128
6.1  应用背景分析	129
6.1.1  胜负预测的依据	129
6.1.2  NBA季后赛数据模型	129
6.2  实体对象建模	131
6.2.1  节点实体建模	131
6.2.2  关系实体建模	134
6.3  实体持久化和查询设计	135
6.3.1  东部球队存储库接口	136
6.3.2  西部球队存储库接口	137
6.3.3  比赛存储库接口	138
6.3.4  赢得关系存储库接口	139
6.4  预测算法设计	140
6.4.1  NBA季后赛的年度历史查询	141
6.4.2  一支球队的比赛历史查询	141
6.4.3  胜负比率排名算法	142
6.4.4  输赢预测算法	143
6.5  SDN配置及数据库连接	144
6.5.1  数据库连接配置	145
6.5.2  SDN配置	145
6.6  数据库设计验证	146
6.7  创建Web应用	149
6.8  Web前后端设计	150
6.8.1  Web后端设计	150
6.8.2  Web前端设计	154
6.9  比赛结果编辑设计	168
6.9.1  比赛结果编辑的访问控制设计	168
6.9.2  比赛结果的录入界面设计	171
6.10  胜率排名的Web设计	176
6.10.1  胜率排名的访问控制设计	176
6.10.2  胜率排名的界面设计	177
6.11  输赢预测的Web设计	180
6.11.1  输赢预测的访问控制设计	181
6.11.2  输赢预测的界面设计	182
6.12  使用GraphGists的测试数据	187
6.13  实例工程使用	188
6.13.1  工程配置	189
6.13.2  运行应用	189
6.14  小结	191
第7章  应用实例二：电影社区推荐引擎	192
7.1  应用背景分析	192
7.1.1  发现商业价值	193
7.1.2  建立数据模型	193
7.2  数据对象建模	194
7.2.1  节点建模	194
7.2.2  关系建模	199
7.3  存储库接口设计	201
7.3.1  影院存储库接口设计	201
7.3.2  电影存储库接口设计	202
7.3.3  节目存储库接口设计	203
7.3.4  观众存储库接口设计	204
7.4  Cypher查询算法设计	204
7.4.1  电影排名查询算法设计	205
7.4.2  电影推荐查询算法设计	205
7.5  数据访问服务类设计	208
7.5.1  分页查询公共服务类	209
7.5.2  数据访问服务类	210
7.6  数据库连接配置	212
7.6.1  SDN驱动的依赖引用	212
7.6.2  连接数据库配置	213
7.6.3  SDN配置	213
7.7  数据库设计验证	214
7.8  Web设计	217
7.8.1  访问控制设计	218
7.8.2  界面设计	222
7.9  电影评分的Web设计	242
7.9.1  电影评分访问控制设计	242
7.9.2  电影评分界面设计	244
7.10  电影排名的Web设计	247
7.10.1  电影排名访问控制设计	247
7.10.2  电影排名界面设计	248
7.11  电影推荐的Web设计	252
7.11.1  推荐电影给观众的Web设计	252
7.11.2  推荐电影给朋友的Web设计	257
7.12  管理后台的导航栏设计	258
7.13  实例工程使用	260
7.13.1  运行配置	260
7.13.2  应用发布	261
7.14  小结	262
第8章  Neo4j企业版安装及使用	263
8.1  分布式服务器安装	264
8.1.1  在不同机器上安装分布式服务器	264
8.1.2  在同一台机器上安装分布式服务器	272
8.2  使用Haproxy实施负载均衡服务	275
8.2.1  普通负载均衡配置	275
8.2.2  Haproxy服务监控	279
8.3  实现读/写分离的负载均衡服务	280
8.4  小结	284
第9章  Neo4j的数据安全及备份	286
9.1  数据的备份与恢复	286
9.1.1  数据备份	286
9.1.2  清理备份日志	288
9.1.3  数据恢复	289
9.2  数据库安全保障	290
9.3  数据的导入与导出	290
9.3.1  使用neo4j-import导入数据	291
9.3.2  使用Cypher导入数据	294
9.3.3  导出数据	295
9.4  故障恢复与事务日志	297
9.5  数据库升级	297
9.5.1  从2.x 升级到3.0.3	297
9.5.2  在3.x之间升级	299
9.6  小结	300
结束语	301
附录A  参考资料	302
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Neo4j全栈开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Neo4j 3.x入门经典
第1章 图论和数据库 1
1.1 Neo4j 3.x简介和图的历史 1
1.2 图论的定义和用途 3
1.2.1 社会学研究 5
1.2.2 生物学研究 6
1.2.3 计算机科学 6
1.2.4 流量问题 7
1.2.5 路径问题 8
1.2.6 网页搜索 9
1.3 背景 10
1.3.1 导航数据库 11
1.3.2 关系数据库 13
1.3.3 NoSQL数据库 15
1.4 图数据库的属性图模型 18
1.4.1 节点标签 20
1.4.2 关系类型 20
1.5 使用图数据库的注意事项 20
1.5.1 为什么使用图数据库 20
1.5.2 什么时候不用图数据库以及用什么替代 22
1.6 问答 23
1.7 小结 23
第2章 Neo4j基础入门 25
2.1 Neo4j的关键概念和特点 25
2.1.1 从头开始创建图 25
2.1.2 基于事务的ACID数据库 26
2.1.3 可用于联机事务处理 27
2.1.4 扩展性能 28
2.1.5 声明式查询语言Cypher 28
2.2 Neo4j典型案例 29
2.2.1 复杂的连接密集型查询 29
2.2.2 路径查询 29
2.2.3 开源解决方案 29
2.3 特性 30
2.4 许可协议 31
2.5 安装Neo4j 32
2.5.1 在Windows系统上安装Neo4j 32
2.5.2 在Mac和Linux系统上安装Neo4j 35
2.6 在云平台使用Neo4j 37
2.7 沙盒模式 41
2.8 在Docker容器中使用Neo4j 47
2.8.1 安装Docker 48
2.8.2 准备文件 48
2.8.3 在Docker容器中运行Neo4j 48
2.9 问答 50
2.10 小结 51
第3章 Neo4j数据模型 52
3.1 四种基础数据结构 52
3.2 图数据库建模基础 53
3.2.1 ER图和关系模式 53
3.2.2 通过连接表引入复杂性 54
3.3 图模型—一个简单、高保真的现实模型 55
3.4 图建模—*佳实践和陷阱 57
3.4.1 图建模*佳实践 57
3.4.2 图数据库建模陷阱 61
3.5 问答 64
3.6 小结 65
第4章 Cypher入门 66
4.1 Cypher的语法 66
4.2 Cypher的关键特性 67
4.3 与数据很好地结合 68
4.3.1 创建数据 68
4.3.2 读取数据 69
4.3.3 更新数据 70
4.3.4 删除数据 71
4.4 Cypher的关键操作词 72
4.5 语法约定 73
4.6 高级知识 74
4.7 Cypher参考卡 78
4.8 openCypher工程 79
4.9 小结 79
第5章 过程—APOC 80
5.1 安装APOC 80
5.1.1 机器安装 81
5.1.2 Docker容器安装 81
5.2 检查APOC安装 81
5.3 函数和过程 82
5.4 习惯用法 82
5.4.1 来自朋友的建议 82
5.4.2 图概述 83
5.5 关键用法 85
5.5.1 安装 85
5.5.2 随机图生成器 85
5.5.3 网站排名 86
5.5.4 Cypher语句限时执行 86
5.5.5 节点集合连接 87
5.5.6 更多APOC 87
5.6 问答 88
5.7 小结 89
第6章 Cypher扩展 90
6.1 构建扩展工程 90
6.1.1 创建函数 91
6.1.2 创建过程 92
6.2 定制聚合器 95
6.3 非托管扩展 96
6.3.1 HTTP和JAX-RS refreshers 97
6.3.2 JSON响应流式化 98
6.4 小结 101
第7章 查询性能优化 102
7.1 Explain和Profile指令 102
7.1.1 查询计划 102
7.1.2 运算符 104
7.2 索引 105
7.2.1 强制使用索引 105
7.2.2 强制使用标签 105
7.3 经验法则 106
7.3.1 Explain所有查询 106
7.3.2 行 106
7.3.3 不要过度消耗资源 106
7.3.4 返回笛卡儿积级别的数据 106
7.3.5 简单 106
7.4 小结 107
第8章 Neo4j数据导入 108
8.1 导入CSV文件 108
8.2 导入JSON源 111
8.3 导入JDBC源 114
8.3.1 测试安装 114
8.3.2 导入所有系统数据 114
8.4 导入XML源 115
8.5 小结 116
第9章 空间 118
9.1 空间简介 118
9.1.1 回顾 118
9.1.2 无缺陷塔 119
9.1.3 什么是空间 119
9.2 Neo4j的空间特性 119
9.3 APOC的空间特性 120
9.4 地理编码 121
9.4.1 设置OSM为提供商 121
9.4.2 设置谷歌为提供商 121
9.5 Neo4j Spatial 122
9.5.1 在线示例 122
9.5.2 Neo4j Spatial特性 122
9.6 导入OpenStreetMap数据 124
9.7 大型OSM数据导入 126
9.7.1 简易方法 126
9.7.2 更直接的数据导入方法 127
9.8 查询卫生间 127
9.9 理解WKT和BBOX 128
9.10 删除所有地理数据 128
9.11 小结 129
第10章 安全认证 130
10.1 认证与授权 130
10.2 角色 131
10.3 用户管理 132
10.4 Neo4j连接到LDAP目录 132
10.5 使用LDAP配置Neo4j 135
10.6 问答 136
10.7 小结 136
第11章 Neo4j 可视化 137
11.1 可视化的重要作用 137
11.1.1 为什么图数据可视化很重要 137
11.1.2 直观地与数据进行交互 137
11.1.3 模式识别 138
11.1.4 发现重点 139
11.2 图数据可视化的基本原则 139
11.2.1 开源可视化组件库 140
11.2.2 将可视化组件库应用到项目中 143
11.2.3 可视化解决方案 144
11.2.4 问题和陷阱 148
11.2.5 Cytoscape实例 149
11.3 问答 152
11.4 小结 153
第12章 Neo4j数据重构 154
12.1 预备步骤 154
12.2 简单改变 154
12.2.1 重命名 154
12.2.2 添加数据 155
12.2.3 删除数据 156
12.3 重大改变 156
12.3.1 知道我们的模型 156
12.3.2 重构工具 157
12.3.3 属性变标签 157
12.3.4 属性变节点 157
12.3.5 相关节点变标签 158
12.3.6 合并节点 158
12.3.7 关系 159
12.4 结论 162
12.5 小结 162
第13章 集群 163
13.1 为什么需要Neo4j集群 163
13.2 Neo4j集群的概念 164
13.2.1 核心服务器 164
13.2.2 只读副本服务器 164
13.2.3 高吞吐量 164
13.2.4 数据冗余 165
13.2.5 高可用 165
13.2.6 Bolt协议 165
13.3 构建Neo4j集群 165
13.3.1 核心服务器 165
13.3.2 只读副本服务器 167
13.3.3 bolt routing协议 168
13.4 在Neo4j集群中实现灾难恢复 169
13.5 小结 169
第14章 案例—推荐系统 170
14.1 推荐系统剖析 170
14.2 推荐系统的图模型应用 171
14.3 推荐系统查询示例 173
14.3.1 基于商品购买的推荐 173
14.3.2 基于品牌忠诚度的推荐 175
14.3.3 基于社交关系的推荐 176
14.3.4 组合推荐 176
14.4 推荐系统的业务变化 177
14.5 欺诈检测系统 178
14.6 访问控制系统 179
14.7 社交网络系统 179
14.8 问答 180
14.9 小结 181
第15章 案例—影响分析与模拟 182
15.1 影响分析系统解析 182
15.1.1 影响分析在业务流程管理中的应用 183
15.1.2 业务图建模 183
15.2 成本计算环境中的影响模拟 187
15.2.1 产品层次结构的图建模 187
15.2.2 产品层次结构图的应用 188
15.3 问答 192
15.4 小结 193
附录 应用技巧介绍 194
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Neo4j 3.x入门经典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>股市长线法宝
推荐序
前言
致谢
第一部分　历史的判断
第1章　1802年以来的股票和债券回报率
第2章　风险、收益和资产配置：为什么长期股票风险小于债券
第3章　股票指数：市场代言人
第4章　标准普尔500指数：半个世纪的美国企业史
第5章　税收对股票和债券回报率的影响：股票的优势
第6章　股票投资的不同观点：市场变化如何超越历史事实
第二部分　价值、风格化投资和全球市场
第7章　股票市场价值的来源和衡量方法
第8章　经济增长对市值的影响以及即将来临的老龄化社会：一位专业投机者的历程
第9章　战胜大盘：规模、股利收益和市盈率的重要性
第10章　全球化投资和中国、印度及新兴市场的崛起
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>股市长线法宝
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>图数据库
第1章 简介	1
1．1　图是什么　1
1．2　图领域概览　3
1．2．1　图数据库　4
1．2．2　图计算引擎　6
1．3　图数据库的威力　7
1．3．1　性能　7
1．3．2　灵活性　7
1．3．3　敏捷性　7
1．4　小结　8
第2章　关联数据的存储选择　9
2．1　关系型数据库缺少联系　9
2．2　NoSQL数据库也缺少联系　12
2．3　图数据库拥抱联系　15
2．4　小结　20
第3章　使用图进行数据建模　21
3．1　模型和目标　21
3．2　带标签的属性图模型　22
3．3　查询图：Cypher简介　23
3．3．1　Cypher的理念　23
3．3．2　MATCH　25
3．3．3　RETURN　26
3．3．4　其他Cypher子句　26
3．4　关系建模和图建模对比　27
3．4．1　系统管理领域中的关系建模　29
3．4．2　系统管理领域中的图建模　32
3．4．3　测试模型　34
3．5　跨域模型　35
3．5．1　创建莎士比亚图　38
3．5．2　开始查询　40
3．5．3　声明查找的信息模式　41
3．5．4　约束匹配　42
3．5．5　处理结果　43
3．5．6　查询链　44
3．6　建模时常见的陷阱　45
3．6．1　电子邮件起源问题域　45
3．6．2　敏感的第一个迭代　45
3．6．3　第二次的魅力　47
3．6．4　发展中的领域　50
3．7　辨别节点和联系　55
3．8　避免反模式　55
3．9　小结　56
第4章　构建基于图数据库的应用　57
4．1　数据建模　57
4．1．1　根据应用程序的需要描述模型　57
4．1．2　用节点表示事物，用联系表示结构　58
4．1．3　细粒度联系与通用联系　59
4．1．4　将事实建模为节点　59
4．1．5　将复杂的值类型表示为节点　62
4．1．6　时间　62
4．1．7　迭代开发和增量开发　65
4．2　应用程序架构　66
4．2．1　嵌入式与服务器　66
4．2．2　集群　71
4．2．3　负载均衡　71
4．3　测试　74
4．3．1　测试驱动的数据模型开发　74
4．3．2　性能测试　80
4．4　容量规划　83
4．4．1　优化条件　84
4．4．2　性能　84
4．4．3　冗余　86
4．4．4　负载　86
4．5　导入和批量加载数据　87
4．5．1　初始导入　87
4．5．2　批量导入　88
4．6　小结　91
第5章　现实世界中的图　92
5．1　为什么选择图　92
5．2　常见用例　93
5．2．1　社交　93
5．2．2　推荐　94
5．2．3　地理空间　95
5．2．4　主数据管理　95
5．2．5　网络和数据中心管理　95
5．2．6　授权和访问控制（通信）　96
5．3　实际示例　97
5．3．1　社交推荐（专业社交网络）　97
5．3．2　授权和访问控制　107
5．3．3　地理空间和物流　115
5．4　小结　127
第6章　图数据库的内部结构　128
6．1　原生图处理　128
6．2　原生图存储　131
6．3　用于编程的API　135
6．3．1　内核API　136
6．3．2　核心API　136
6．3．3　遍历框架　137
6．4　非功能型特性　139
6．4．1　事务　139
6．4．2　可恢复性　140
6．4．3　可用性　141
6．4．4　可扩展性　142
6．5　小结　145
第7章　使用图论预分析　146
7．1　深度优先搜索和广度优先搜索　146
7．2　使用Dijkstra算法寻找路径　147
7．3　A*算法　155
7．4　图论和预测建模　155
7．4．1　三元闭包　156
7．4．2　结构平衡　158
7．5　局部桥　161
7．6　小结　163
附录　NoSQL概览　164
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>图数据库
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Visual C++ 技术内幕（第四版）
目录
前言
第一部分 Windows、VisualC＋＋和应用程序框架基础
第一章 MicrosoftWindows 和VisualC＋＋
1.1Windows的编程模式
1.1.1消息处理
1.1.2Windows的图形设备接口（GDI）
1.1.3基于资源的程序设计
1.1.4内存管理
1.1.5动态连接库（DLL）
1.1.6Win32应用程序编程接口
1.2VisualC＋＋的组成
1.2.1MicrosoftDeveloperStudio97和创建过程
1.2.2资源编辑器――WorkspaceResourceView
1.2.3C/C＋＋编译器
1.2.4资源编译器
1.2.5连接器
1.2.6调试器
1.2.7AppWizard
1.2.8ClassWizard
1.2.9源程序浏览器
1.2.10联机帮助
1.2.11Windows诊断工具
1.2.12源代码控制
1.2.13Gallery
1.2.14Microsoft基本类库4.21版
1.2.15MicrosoftActiveX 模板库
第二章 Microsoft基本类库应用程序框架
2.1为什么要使用应用程序框架
2.1.1学习曲线
2.2什么是应用程序框架
2.2.1应用程序框架和MFC库
2.2.2应用程序框架示例
2.3MFC库消息映射
2.3.1文档和视图
第二部分 MFC 库中的视图类
第三章 从“Hello，world！”着手学习AppWizard
3.1什么是视图
3.2单文档界面（SDI）和多文档界面（MDI）
3.3“不做任何事情”的应用程序
3.4CEx03aView视图类
3.5在视窗内绘图――Windows的图形设备接口
3.5.1OnDraw成员函数
3.5.2Windows设备环境
3.5.3往EX03A程序中加入绘制代码
3.6资源编辑器简介
3.6.1ex03a.rc的内容
3.6.2运行对话框资源编辑器
3.7Win32Debug目标和Win32Release目标
3.8允许诊断宏
3.9对预编译头文件的理解
3.10两种方法运行程序
第四章 基本事件处理、映射模式和滚动视图
4.1获取用户输入――消息映射函数
4.1.1消息映射
4.1.2保存视图的状态－类数据成员
4.1.3初始化视图类数据成员
4.1.4使矩形区域无效
4.1.5Windows 的客户区域
4.1.6CRect，CPoint和CSize类的运算
4.1.7一个点是否在矩形内
4.1.8CRect的LPRECT操作符
4.1.9一个点是否在椭圆内
4.2Ex04A示例程序
4.3对EX04A使用ClassWizard
4.3.1同时使用AppWizard 和Clas sWizard
4.4映射模式
4.4.1MM_TEXT映射模式
4.4.2“固定比例”映射模式
4.4.3“可变比例”映射模式
4.4.4坐标变换
4.4.5EX04B示例程序――转换到MM_HIMETRIC映射模式
4.5滚动视窗
4.5.1窗口比人们所见到的要大
4.5.2滚动条
4.5.3滚动方式的选择
4.5.4 OnInitialUpdate函数
4.5.5接收键盘输入
4.5.6EX04C滚动示例程序
4.6其他Windows消息
4.6.1WM_CREATE消息
4.6.2WM_CLOSE消息
4.6.3WM_QUERYENDSESSION消息
4.6.4WM_DESTROY消息
4.6.5WM_NCDESTROY消息
第五章 图形设备接口（GDI）、颜色及字体
5.1设备环境类
5.1.1显示设备环境类CClientDC和CWindowDC
5.1.2构造和析构CDC对象
5.1.3设备环境的状态
5.1.4CPaintDC类
5.2GDI对象
5.2.1GDI对象的构造与析构
5.2.2跟踪GDI对象
5.2.3库存的GDI对象
5.2.4GDI选择的有效期
5.3Windows的颜色映射
5.3.1标准视频图形阵列（V以）显示卡
5.3.2256色显示卡
5.3.316位颜色显示卡
5.3.424位颜色显示卡
5.4字体
5.4.1字体是GDI对象
5.4.2选择字体
5.4.3打印字体
5.4.4 显示字体
5.4.5显示器的逻辑英寸和物理英寸
5.4.6计算字符高度
5.5EXO5A示例程序
5.5.1EX05A程序的组成元素
5.6EX05B程序
5.6.1EX0 5B程序的组成元素
5.7EX05C示例程序――再次使用CScrollView
5.7.1EX0 5C程序的组成元素
5.7.2CScrollView的SetScaleToFitSize模式
5.7.3在滚动视图中使用逻辑twips映射模式
第六章 模式对话框和Windows通用控件
6.1模式和无模式对话框
6.2资源和控件
6.3模式对话框的编程
6.4包罗万象的对话框――EX06A示例程序
6.4.1创建对话框资源
6.4.2ClassWizard和对话框类
6.4.3将对话框与视图相连接
6.4.4深入理解EX06A应用程序
6.5对话框程序的改进
6.5.1获得OnOK退出控制
6.5.2OnCancel处理
6.5.3和滚动条控件挂上钩
6.6控件的标识：CWnd指针和控件ID
6.7设置对话框的背景色和其中控件的颜色
6.8在对话框窗口内绘图
6.9在运行时加入对话框控件
6.10利用其他的控件特性
6.11Windows通用控件
6.11.1进度指示器控件
6.11.2滑杆条（Trackbar）控件
6.11.3微调按钮控件
6.11.4列表控件
6.11.5树状控件
6.11.6WM NOTIFY消息
6.12EX06B示例程序
6.13其他Windows 通用控件
第七章 无模式对话框和Windows通用对话框类
7.1无模式对话框
7.1.1创建无模式对话框
7.1.2用户定义的消息
7.1.3对话框的归属
7.1.4无模式对话框的例子――EX07A
7.2CFormView类――另外一种可供选择的无模式对话框
7.3Windows通用对话框
7.3.1直接使用CFileDialog类
7.3.2从通用对话框类进行派生
7.3.3嵌套对话框
7.3.4使用CFileDialog的一个例子――EX07B
7.3.5CFileDialog的其他可定制特性
第八章 使用ActiveX控件
8.1ActiveX控件和普通的Windows控件
8.1.1普通的Windows 控件――参考体系
8.1.2ActiveX控件与普通控件的相同点
8.1.3ActiveX控件与普通控件的不同点――属性和方法
8.2安装ActiveX控件
8.3日历控件
8.4ActiveX控件包容器编程
8.4.1属性访问
8.4.2ClassWizard为ActiveX控件产生的C＋＋类
8.4.3AppWizard对ActiveX控件的支持
8.4.4ClassWizard和包容器对话框
8.4.5对话框类数据成员和控件类的用法
8.4.6映射ActiveX控件事件
8.4.7把ActiveX控件锁定在内存里
8.5EX08A示例程序――ActiveX控件对话框包容器
8.6ActiveX控件在HTML文件中的使用
8.7在运行时创建ActiveX控件
8.8EX08B示例程序――Web浏览器ActiveX控件
8.9EX08C示例程序――一个完整的双窗口浏览器
8.10图形属性
8.11约束属性――改变通知
8.12其他的ActiveX控件
第九章 Win32内存管理
9.1进程和内存空间
9.1.1Windows95进程地址空间
9.1.2WindowsNT进程地址空间
9.2虚拟内存如何工作
9.3VirtualAlloc函数――占用和保留内存
9.4Windows 堆和GlobalAlloc 函数族
9.5小内存堆，C＋＋的new和delete操作符，_heapmin
9.6内存映射文件
9.7访问资源
9.8管理动态内存的一些提示
9.9常量数据的优化存储
第十章 位图
10.1GDI位图和与设备无关的位图
10.2彩色位图和单色位图
10.3使用GDI位图
10.3.1从资源中装人GDI位图
10.3.2显示映射模式的作用
10.3.3对位进行伸缩处理
10.3.4EX10A示例程序
10.4利用位图改进屏幕显示
10.4.1EX10B示例程序
10.4.2Windows动画
10.5DIB和CDib类
10.5.1关于调色板编程的术语
10.5.2DIB、象素和颜色表
10.5.3BMP文件中DIB的结构
10.5.4DIB访问函数
10.5.5CDib类
10.5.6DIB显示性能
10.5.7EX10C示例程序
10.6进一步使用DIB
10.6.1Load Image函数
10.6.2DrawDibDraw函数
10.7在按钮上设置位图
10.7.1EX10D示例程序
10.7.2进一步使用位图按钮
第十一章 Wind0ws消息处理和多线程编程
11.1Windows消息处理
11.1.1单线程程序处理消息的过程
11.1.2交出控制
11.1.3计时器
11.1.4EX11A示例程序
11.2空状态处理
11.3多线程编程
11.3.1编写辅助线程函数和启动线程
11.3.2主线程如何和辅助线程通话
11.3.3辅助线程如何和主线程通话
11.3.4EX11B示例程序
11.3.5用事件使线程同步
11.3.6EX11C示例程序
11.3.7线程阻塞
11.3.8排斥区
11.3.9互斥体（mutex）和信号
11.3.10用户界面线程（UI线程）
第三部分 文档－视图结构
第十二章 菜单、键盘加速键、复文本编辑控件和属性表
12.1主框架窗口和文档类
12.2Windows的菜单
12.3键盘加速键
12.4命令处理
12.4.1派生类中的命令消息控制
12.4.2更新命令用户界面消息控制函数
12.4.3对话框发送的命令
12.5应用程序框架的内含菜单项
12.6菜单项的允许/禁用
12.7MFC文本编辑选择
12.7.1CE出tView类
12.7.2CRichEditView类
12.7.3CRichEditCtrl类
12.8ex12A示例程序
12.9属性表
12.9.1创建属性表
12.9.2属性表数据交换
12.10改进EX12A示例程序
12.11Apply按钮的处理过程
12.12CMenu类
12.13创建浮动的弹出式菜单
12.14扩展命令处理
第十三章 工具栏和状态栏
13.1控制栏和应用程序框架
13.2工具栏
13.2.1工具栏位图
13.2.2按钮的状态
13.2.3工具栏和命令消息
13.2.4工具栏更新命令UI消息控制函数
13.3工具提示
13.4寻找主框架窗口
13.5EX13A工具栏示例程序
13.6状态栏
13.6.1状态栏的定义
13.6.2信息行
13.6.3状态指示器
13.6.4获得对状态栏的控制
13.7EX13B状态栏示例程序
第十四章 可重用框架窗口基类
14.1为什么可重用基类难以设计
14.2CPersistentFrame类
14.3CFrameWnd类和ActivateFrame成员函数
14.4PreCreateWindow成员函数
14.5Windows注册表
14.6使用CString类
14.7最大化窗口的位置
14.8控制栏状态和注册表
14.9静态数据成员
14.10默认窗口矩形
14.11EX14A示例程序
14.12MDI应用程序中的持续框架
第十五章 文档与视图的分离
15.1文档－视图之间的相互作用函数
15.1.1CView∷GetDocument函数
15.1.2CDocumeat∷UpdateAllViews 函数
15.1.3CView∷OnUpdate函数
15.1.4CView∷OnInitialUpdate函数
15.1.5CDocument∷OnNewDocument函数
15.2最简单的文档－视图应用程序
15.3CFormViiew类
15.4CObject类
15.5诊断信息转储
15.5.1TRACE宏
15.5.2atxDump对象
15.5.3信息转储环境及CObjct类
15.5.4未被删除对象的自动信息转储
15.6EX15A示例程序
15.7更加高级的文档－视图之间的相互作用
15.8CDocument∷DeleteContents函数
15.9CObList集合类
15.9.1对先人先出列表使用CObList类
15.9.2在COblIst中进行迭代――POSITION变量
15.9.3CTypedPtrList模板集合类
15.9.4信息转储环境及集合类
15.10 EX15B示例程序
15.10.1资源要求
15.10.2代码要求
15.10.3CStudentDoc
15.10.4CStudentView
15.10.5测试EX15B应用程序
15.11留给读者的两个练习
第十六章 读和写文档――SDI应用程序
16.1什么是序列化
16.1.1磁盘文件和归档（Archives）
16.1.2使类可序列化
16.1.3编写Serialize函数
16.1.4 从归档中载人――内嵌对象和指针
16.1.5使集合序列化
16.1.6Serialize函数和应用程序框架
16.2SDI应用程序
16.2.1Windows应用程序对象
16.2.2文档模板类
16.2.3文档模板资源
16.2.4SDI文档的多视图
16.2.5创建空文档――CWinApp∷OnFileNew函数
16.2.6文档类的OnNewDocument函数
16.2.7连接FileOpe n与序列化代码――OnFileOpen函数
16.2.8文档类的DeleteContents函数
16.2.9将FileSave和FileSaveAs与序列化代码相连接
16.2.10 文档的“脏”标志
16.3EX16A――序列化SDI示例程序
16.3.1CStudent
16.3.2CEx16aApp
16.3.3CFrameWnd
16.3.4CStudentDoc
16.3.5cStudentView
16.3.6测试EX16A应用程序
16.4从Explorer启动及拖放
16.4.1程序注册
16.4.2在文档上双击鼠标
16.4.3允许拖放
16.4.4程序启动参数
16.4.5试验用Explorer启动程序及拖放功能
第十七章 读和写文档――MDI应用程序
17.1MDI应用程序
17.1.1一个典型的具有MFC库风格的MDI应用程序
17.1.2MDI应用程序对象
17.1.3MDI文档模板类
17.1.4MDI框架窗口和MDI子窗口
17.1.5主框架和文档模板资源
17.1.6创建空文档――CWinApp OnFileNew函数
17.1.7为现有文档创建新的视图
17.1.8载人和存储文档
17.1.9多文档模板
17.1.10Explorer启动及拖放
17.2EX17A示例程序
17.2.1CEx17aApp
17.2.2CMainFrame
17.2.3CChildFrame
17.2.4 测试EX17A应用程序
第十八章 打印和打印预览
18.1Windows的打印
18.1.1标准打印对话框
18.1.2交互选择打印页码
18.1.3显示页和打印页
18.2打印预览
18.3有关打印机的程序设计
18.3.1打印机设备环境和CViewOnDraw函数
18.3.2CView OnPrint函数
18.3.3准备设备环境――CView OnPrePareDC函数
18.3.4打印任务的开始和结束
18.4EX18A示例程序――一个所见即所得的打印程序
18.5读取打印机矩形框
18.6再看模板集合类――CArray类
18.7EX18B示例程序――多页打印程序
第十九章 切分窗口和多视图
19.1切分窗口
19.2多视图选择
19.3动态和静态切分窗口
19.4EX19A示例程序――具有单个视图类的SDI动态切分
19.4.1与切分有关的资源
19.4.2CMainFrame
19.4.3测试EX19A应用程序
19.5EX19B示例程序――双视图类SDI静态切分
19.5.1CHexView
19.5.2CMainFrame
19.5.3测试EX19B应用程序
19.6EX19C示例程序――切换没有切分的视图类
19.6.1资源要求
19.6.2CMainFrame
19.6.3测试Ex19C应用程序
19.7Ex19D示例程序――多视图类MDI应用程序
19.7.1资源要求
19.7.2CEx19dApp
19.7.3CMainFrame
19.7.4测试EX19D应用程序
第二十章 上下文相关帮助
20.1Windows 的WinHe lp程序
20.1.1复文本格式（RTF）
20.1.2编写简单的帮助文件
20.1.3改进的TableOfContents
20.2应用程序框架与WinHelp
20.2.1调用WinHelp
20.2.2使用搜索字符串
20.2.3从应用程序的菜单调用WinHelp
20.2.4帮助上下文别名
20.2.5确定帮助上下文
20.2.6F1帮助
20.2.7Shift－F1帮助
20.2.8消息框帮助――AfxMessageBox 函数
20.2.9一般的帮助
20.3帮助示例――不需要任何编程
20.4MAKEHEL处理
20.5帮助命令处理
20.5.1F1处理过程
2.5.2Shift－F1处理过程
20.6帮助命令处理示例程序――EX20 B
20.6.1头文件要求
20.6.2CStringView
20.6.3CHexView
20.6.4资源要求
20.6.5帮助文件要求
20.6.6测试EX20B应用程序
第二十一章 动态连接库
21.1基本DLL理论
21.1.1导人如何与导出相匹配
21.1.2隐式连接和显式连接
21.1.3符号连接和序号连接
21.1.4DLL人口点――DllMain
21.1.5实例句柄――装载资源
21.1.6客户程序如何找到DLL
21.1.7调试DLL
21.2MFcDLL――扩展的和正规的
21.2.1共享的MFCDLL和WindowsDLL
21.2.2MFC扩展DLL――导出类
21.2.3MFC扩展DLL资源搜索的顺序
21.2.4EX21A示例程序――MFC扩展DLL
21.2.5EX21B示例程序――DLL测试客户程序
21.2.6MFC正规DLL――CWinApp派生类
21.2.7使用AFX_MANAGE_STATE宏
21.2.8MFC正规DLL资源搜索顺序
21.2.9EX21C示例程序――MFC正规DLL
21.2.10修改EX21B示例程序――加入代码以测试ex21c.dll
21.3自定义控件DLL
21.3.1什么是自定义控件
21.3.2自定义控件的窗口类
21.3.3MFC库和WndProc函数
21.3.4自定义控件通知消息
21.3.5发送给控件的用户定义消息
21.3.6EX2 1D示例程序――自定义控件
21.3.7再修改EX2 1B示例程序――加入代码以测试ex21d.dll
第二十二章 不带文档或视图类的MFC程序
22.1EX22A示例程序――一个基于对话框的应用程序
22.1.1应用程序类InitInstance函数
22.1.2对话框类和程序图标
22.2EX22B示例――一个SDI应用程序
22.2.1应用程序类InitInstance函数
22.2.2CMainFrame类
22.3EX22C示例程序――一个MDI应用程序
22.3.1应用类程序InitInstance函数
22.3.2CMainFrame类
22.3.3CChildFrame类
22.3.4资源要求
22.4定制（Custom）AppWizard
第四部分 ActiveX：组件对象模型、自动化和OLE
第二十三章 组件对象模型
23.1ActiveX技术背景
23.2组件对象模型（COM）
23.2.1COM所解决的问题
23.2.2COM的本质
23.2.3什么是COM接口
23.2.4IUnknown接口和QueryInterface成员函数
23.2.5引用计数：AddRdf和Release函数
23.2.6类厂（classfactory）
23.2.7CCmdTarget类
23.2.8EX23A示例程序――一个模拟的COM
23.3MFC库中实际的COM
23.3.1COM的CoGetClassObject函数
23.3.2COM和Windows注册表
23.3.3运行时对象注册
23.3.4COM客户程序如何调用进程内组件
23.3.5COM客户程序如何调用进程外组件
23.3.6MFC接口宏
23.3.7MFC的COleObjectFactory类
23.3.8AppWizard/ClassWizard对COM进程内组件的支持
23.3.9MFCCOM客户程序
23.3.10EX23B示例程序――MFCCOM进程内组件
23.3.11EX23C示例程序――MFCCOM客户
23.4包容、集合和继承
第二十四章 自动化
24.1C＋＋与VisualBasicforApplications（VBA）之间的连接
24.2自动化客户和自动化组件
24.3MicrosoftExcel――一种比VisualBasic还好的VisualBasic
24.4属性（property）、方法（method）和集合
24.5自动化所解决的问题
24.6IDispatch接口
24.7自动化程序设计的选择
24.8MFCIDispatch的实现
24.9一个MFC自动化组件
24.10一个MFC自动化客户程序
24.11使用编译器＃import指令的自动化客户程序
24.12VARIANT类型
24.13COleVariant类
24.14Invoke的参数和返回值的类型转换
24.15自动化示例
24.15.1EX24A自动化组件EXE示例――不带任何用户界面
24.15.2EX24B自动化组件DLL示例程序
24.15.3EX24CSDI自动化组件EXE示例――带用户界面
24.15.4EX24D自动化客户示例程序
24.15.5EX24E自动化客户示例程序
24.16VBA早绑定
24.16.1注册类型库
24.16.2组件如何注册自己的类型库
24.16.3ODL文件
24.16.4Excel如何使用类型库
24.16.5为什么使用早绑定
24.16.6客户－组件的快速连接
第二十五章 统一数据传输――剪贴板传输以及OL拖放
25.1IDataO bject接口
25.2IDataObject如何增强标准剪贴板的支持
25.3FORMATETC和STGMEDIUM结构
25.3.1FORMATETC
25.3.2STGMEDTUM
25.3.3IDataObject接口成员函数
25.4MFC统一数据传输支持
25.4.1COleDataSource类
25.4.2COleDataObject类
25.4.3MFC数据对象剪贴板传输
25.5MFCCRectTracker类
25.5.1CRectTracker类成员函数
25.5.2CRectTracker类矩形坐标转换
25.6EX25A示例程序――数据对象剪贴板
25.6.1CMainFrame类
25.6.2CE25aDoc类
25.6.3CEx25aView类
25.7MFC拖放
25.7.1传输的源方
25.7.2传输的目标方
25.7.3拖放的顺序
25.8EX25B示例程序――OLE拖放
25.8.1CEx25bDoc类
25.8.2CEx25bView类
25.9Windows应用程序和拖放――Dobjview
第二十六章 结构化存储
26.1复合文件
26.2存储（Storage）和IStorage接口
26.2.1获取IStorage指针
26.2.2释放STATSTG内存
26.2.3对存储对象的元素进行枚举
26.2.4进程间共享存储
26.3流（Stream）和IStream接口
26.3.1IStream接口成员函数
26.3.2IStream编程
26.4ILockBytes接口
26.5EX26A示例程序――结构化存储
26.5.1菜单
26.5.2CEx26aView类
26.5.3辅助线程
26.6结构化存储和持久COM对象
26.6.1IPersistStorage 接口
26.6.2IPersistStream接口
26.6.3IpersistStream编程
26.7EX2 6B示例程序――一个持久DLL组件
26.8EX26C示例程序――一个持久存储客户程序
26.9复合文件碎片的处理
26.10复合文件的其他优点
第二十七章 OLE嵌入组件和包容器
27.1嵌入和实地激活（可视编辑）
27.2最小服务器和完备服务器（组件）――链接
27.3可视编辑前景暗淡的一面
27.4Windows 图元文件和内嵌对象
27.5组件程序的MFCOLE结构
27.6EX27A示例程序――MFC实地激活最小服务器
27.6.1MDI嵌入组件
27.6.2实地组件调整大小的思路
27.7包容器－组件相互作用
27.7.1使用组件的IOleObject接口
27.7.2装人和保存组件自身的数据――组件文档
27.7.3剪贴板数据传输
27.7.4获得组件的图元文件
27.7.5进程内控制器的角色
27.8组件状态
27.8.1包容器接口
27.8.2通报连接
27.8.3剪贴板图元文件
27.9接口简要说明
27.9.1IOleObject接口
27.9.2IViewObject2接口
27.9.3IOleClientSite接口
27.9.4IAdviseSink接口
27.10OLE辅助函数
27.11OLE嵌入包容器应用程序
27.11.1MFC对OLE包容器的支持
27.11.2一些包容器限制
27.11.3包容器特性
27.12EX27B示例程序――嵌入包容器
27.12.1CEx27bView类
27.12.2CEx27bDoc类
27.13 EX27C示例程序――OLE嵌入组件
27.13.1CEx27cView类
27.13.2CEx27cDoc类
第五部分 数据库管理
第二十八章 MicrosoftODBC数据库管理
28.1数据库管理的优势
28.2结构化查询语言
28.3ODBC标准
28.3.1ODBC结构
28.3.2ODBCDK编程
28.4MFCODBC类――CRecordset和CDatabase
28.4.1记录集中关于行的计数
28.4.2处理odbc异常
28.5学生注册数据库
28.6EX28A记录集示例程序
28.7Ex28A示例程序中的元素
28.7.1记录集类与应用程序之间的连接
28.7.2CEx28aView类的OnInitialUpdate成员函数
28.7.3CEx28aView类的OnDraw成员函数
28.8筛选器和排序字符串
28.9连接两个数据库表
28.10MFCCRecordView类
28.11EX28B记录查看示例程序
28.12多记录集
28.12.1EX28C多记录集示例程序
28.12.2参数化查询
28.13ODBC多线程
28.14大批行数据获取（bulkrow fetch）
28.15使用不带绑定的记录集
第二十九章 MicrosoftDataAccessObjbjects数据库管理
29.1DAO、COM和MicrosoftJet数据库引擎
29.2DAO和VBA
29.3DAO和MFC
29.4利用DAO可以打开什么样的数据库
29.5按ODBC模式使用DAO――快照和动态集
29.6DAO表类型记录集
29.7DAOQue ryDef和TableDef
29.8DAO多线程情况
29.9在滚动窗口中显示数据库的行
29.9.1滚动显示方法
29.9.2一个行－视图类
29.9.3基类和派生类的分工处理
29.9.4CRowView的纯虚成员函数
29.9.5其他的CRowView函数
29.10 动态记录集的编程
29.11EX29A示例程序
29.11.1CEx29aApp
29.11.2CMainFrame和CChildFrame
29.11.3CEx29aDoc
29.11.4CEx29aView
29.11.5CTableSelect
29.11.6CIsamSelect
29.12EX29A资源文件
29.13运行EX29A程序
第六部分 Interne t程序设计
第三十章 TCP/IP、Winsock和WinInet
30.1既针对COM也可以不需要COM
30.2Internet基础
30.2.1网络协议――层
30.2.2Internet协议
30.2.3用户报文协议
30.2.4IP地址格式――网络字节顺序
30.2.5传输控制协议
30.2.6域名系统
30.2.7HTTP基础
30.2.8FTP基础
30.2.9Internet和Intranet
30.3建立自己的价值＄99的Intranet
30.3.1NT文件系统和文件分配表
30.3.2网络硬件
30.3.3对Windows进行网络配置
30.3.4Intranet的主机名――HOSTS文件
30.3.5测试Intranet――Ping程序
30.3.6只有一台计算机的Intranet――TCP/IP环形地址
30.4Winsock
30.4.1同步和异步Winsock编程
30.4.2MFCWinsock类
30.4.3BlockingSocket类
30.4.4一个简化了的HrTP服务器程序
30.4.5一个简化了的HTTP客户端程序
30.5用CHttpBlockingSocket创建一个Web服务器程序
30.5.1EX30A服务器限制
30.5.2Ex30A服务器结构
30.5.3使用Win32TransmitFile函数
30.5.4编译和测试EX30A
30.5.5使用Telnet
30.6用CHttpBlockingSocket创建一个Web客户端程序
30.6.1EX30AWinsock客户
30.6.2EX30A对代理服务器的支持
30.6.3测试EX30AWinsock客户
30.7WinInet
30.7.1WinInet相对于Winsock的优势
30.7.2MFCWinInet类
30.7.3Intenet会话状态回调
30.7.4一个简化了的WinInet客户程序
30.8用MFcWinInet类创建一个Web客户
30.8.1Ex30AWinInetClient ＃1――使用CHttpConnection
30.8.2测试WinInetClient＃1
30.8.3EX3 OAWinInetClient ＃2――使用OpenURL
30.8.4测试WinInetClient＃2
30.9异步Moniker文件
30.9.1Moniker
30.9.2MFCCAsyncMonikerFile类
30.9.3在程序中使用CAsyncMonikerFile类
30.9.4 异步moniker文件和WinInet编程
第三十一章 MicrosoftInternetInformationServer编程
31.1IIs的替代产品
31.2MicrosoftIIS
31.2.1安装和控制IIS
31.2.2运行InternetServiceManager
31.2.3IIS的安全性
31.2.4IIS目录
31.2.5IIS日志记录
31.2.6测试IIS
31.3ISAPI服务器扩展
31.3.1通用网关接口和ISAPI
31.3.2一个简单的ISSAPI服务器扩展GET请求
31.3.3HTML窗体――GEt和POST
31.3.4编写ISAPI服务器扩展DLL
31.3.5MFCISAPI服务器扩展类
31.4一个实际的ISAPI服务器扩展――ex31a.dll
31.4.1第一步――获取定单
31.4.2第二步――处理确认窗体
31.4.3编译并测试ex31a.dll
31.4.4调试EX31ADLL
31.5ISAPI数据库访问
31.6使用HTTPCookie来连接事务
31.6.1Cookie如何工作
31.6.2ISAPI服务器扩展如何处理Cookie
31.6.3使用cookie的一些问题
31.7WWW鉴定
31.7.1基本鉴定
31.7.2WindowsNT问讯/应答鉴定
31.7.3安全套接字层（SSL）
31.8ISAPI过滤器
31.8.1编写ISAPI过滤器DLL
31.8.2MFCISAPI过滤器类
31.9ISAPI过滤器示例――ex3lb.dll、ex3lc.exe
31.9.1选择通知
31.9.2把事务数据发送到显示程序
31.9.3显示程序
31.9.4 编译并测试EX31BISAPI过滤器
第三十二章 ActiveX文档服务器和Internet
32.1ActiveX文档理论
32.1.1ActiveX文档服务器和OLE嵌入服务器
32.1.2从IE3中运行ActiveX文档服务器
32.1.3ActiveX文档服务器和ActiveX控件
32.1.4ActiveX文档服务器和包容器的OLE接口
32.1.5MFC对ActiveX文档服务器的支持
32.2ActiveX文档服务器示例程序EX32A
32.2.1EX32A第一阶段――简单的服务器
32.2.2调试ActiveX文档服务器
32.2.3Ex32A第二阶段――加入WinInet调用
32.3ActiveX文档服务器示例程序EX32B
32.3.1在程序控制下产生POST请求
32.3.2EX32B视图类
32.3.3编译并测试EX32B
32.3.4ActiveX文档服务器和VBScript
32.4进一步使用ActiveX文档服务器
附录A Microsoft基本类（MFc）库中的消息映射函数
附录B MFC库运行时类识型和动态对象创建

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Visual C++ 技术内幕（第四版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>哈利·波特（共4册）
一、哈利・波特与魔法石
二、哈利・波特与密室
三、哈利・波特与阿兹卡班的囚徒
四、哈利・波特与火焰杯
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>哈利·波特（共4册）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>技术分析习题集
如何使用本习题集/
第1章市场周期模型 /
第2章金融市场与商业周期 /
第3章道氏理论 /
第4章中期趋势的典型参数 /
第5章价格形态 /
第6章小型的价格形态 /
第7章单棒与双棒价格形态 /
第8章趋势线 /
第9章移动均线 /
第10章动能原理 /
第11章动能指标1 /
第12章动能指标2 /
第13章K线图 /
第14章点数图 /
第15章判定趋势的其他技巧 /
第16章相对强度 /
第18章价格：主要的价格指数 /
第19章价格：板块轮动 /
第20章时间：长期周期 /
第21章识别周期的实用方法 /
第22章成交量：基本原理 /
第23章成交量摆荡指标 /
第24章市场广度 /
第25章利率为何会影响股票市场 /
第26章人气指标 /
第27章技术分析在相反定理中的应用 /
第29章自动交易系统 /
第30章全球股市技术分析 /
第31章个股技术分析 /
华章经典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>技术分析习题集
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>计算机系统：核心概念及软硬件实现（原书第4版）
出版者的话
中文版序
译者序
前言
第一部分应用层（第7层）
第1章计算机系统2
1.1　抽象层次2
1.1.1　艺术中的抽象3
1.1.2　文档中的抽象4
1.1.3组织中的抽象5
1.1.4机器中的抽象6
1.1.5计算机系统中的抽象6
1.2　硬件8
1.2.1输入设备9
1.2.2输出设备11
1.2.3主存储器12
1.2.4中央处理单元13
1.3软件13
1.3.1操作系统14
1.3.2软件分析和设计15
1.4数据库系统16
1.4.1关系17
1.4.2查询18
1.4.3语言结构19
总结20
练习21
第二部分高级语言层（第6层）
第2章C++24
2.1　变量24
2.1.1C++编译器24
2.1.2　机器无关性24
2.1.3C++的内存模型25
2.1.4全局变量和赋值语句26
2.1.5局部变量28
2.2控制流29
2.2.1if/else语句29
2.2.2switch语句30
2.2.3while循环30
2.2.4do循环31
2.2.5数组和for循环31
2.3函数32
2.3.1空函数和传值调用的参数32
2.3.2函数的例子33
2.3.3传引用调用的参数34
2.4递归36
2.4.1阶乘函数37
2.4.2递归的思考方式39
2.4.3递归加法40
2.4.4二项式系数函数41
2.4.5逆转数组元素顺序45
2.4.6汉诺塔45
2.4.7　相互递归48
2.4.8递归的成本48
2.5动态内存分配49
2.5.1指针49
2.5.2结构50
2.5.3链式数据结构51
总结52
练习53
问题54
第三部分指令集架构层（第3层）
第3章信息的表示58
3.1　无符号二进制表示58
3.1.1二进制存储器58
3.1.2整数59
3.1.3基本转换60
3.1.4无符号整数的范围61
3.1.5无符号加法62
3.1.6　进位位62
3.2补码二进制表示63
3.2.1补码的表数范围65
3.2.2基数转换66
3.2.3　数轴66
3.2.4溢出位68
3.2.5负数和零位69
3.3　二进制运算69
3.3.1逻辑运算符69
3.3.2寄存器传送语言70
3.3.3算术运算符70
3.3.4循环移位运算符72
3.4十六进制和符号表示72
3.4.1十六进制72
3.4.2基数转换73
3.4.3字符75
3.5浮点数表示77
3.5.1二进制小数77
3.5.2余码表示78
3.5.3隐藏位79
3.5.4特殊值80
3.5.5IEEE 754浮点数标准83
3.6跨层的表示方法85
3.6.1另一种表示87
3.6.2模型88
总结90
练习90
问题95
第4章计算机体系结构97
4.1硬件97
4.1.1中央处理单元98
4.1.2主存储器98
4.1.3　输入设备99
4.1.4　输出设备99
4.1.5　数据和控制100
4.1.6　指令格式100
4.2直接寻址102
4.2.1　停止指令102
4.2.2装入指令103
4.2.3存储指令103
4.2.4加法指令104
4.2.5减法指令105
4.2.6与和或指令105
4.2.7按位取反和取负指令106
4.2.8装入字节和存储字节指令107
4.2.9字符输入和输出指令108
4.3冯·诺依曼机器109
4.3.1　冯·诺依曼执行周期109
4.3.2一个字符输出程序110
4.3.3冯·诺依曼漏洞113
4.3.4一个字符输入程序113
4.3.5十进制转换为ASCII113
4.3.6一个修改自身的程序114
4.4ISA3层编程115
4.4.1只读内存117
4.4.2Pep/8操作系统117
4.4.3使用Pep/8系统119
总结119
练习120
问题121
第四部分汇编层（第5层）
第5章汇编语言124
5.1汇编程序124
5.1.1指令助记符124
5.1.2伪操作126
5.1.3.ASCII和.END伪操作126
5.1.4汇编器127
5.1.5.BLOCK伪操作128
5.1.6.WORD和.BYTE伪操作129
5.1.7使用Pep/8汇编器129
5.1.8交叉汇编器130
5.2立即数寻址和陷阱指令131
5.2.1立即数寻址131
5.2.2DECI、DECO和BR指令131
5.2.3STRO指令133
5.2.4解释位模式134
5.2.5反汇编器135
5.3符号137
5.3.1带符号的程序137
5.3.2一个冯·诺依曼示例138
5.4从HOL6层翻译139
5.4.1cout语句139
5.4.2变量和类型140
5.4.3全局变量和赋值语句141
5.4.4类型兼容143
5.4.5Pep/8符号跟踪器144
5.4.6　算术移位和循环移位指令145
5.4.7常量和.EQUATE147
5.4.8指令和数据的放置149
总结149
练习150
问题152
第6章编译到汇编层155
6.1　栈寻址和局部变量155
6.1.1栈相对寻址155
6.1.2访问运行时栈156
6.1.3局部变量158
6.2转移指令和控制流159
6.2.1　翻译if语句160
6.2.2　优化编译器161
6.2.3翻译if/else语句162
6.2.4翻译while循环163
6.2.5翻译do循环164
6.2.6　翻译for循环165
6.2.7　面条代码166
6.2.8早期语言中的控制流168
6.2.9结构化编程定律169
6.2.10goto争论169
6.3　函数调用和参数171
6.3.1翻译函数调用171
6.3.2用全局变量翻译传值调用参数173
6.3.3　用局部变量翻译传值调用参数176
6.3.4翻译非空函数调用178
6.3.5　用全局变量翻译传引用调用参数180
6.3.6用局部变量翻译传引用调用参数183
6.3.7翻译布尔类型186
6.4　变址寻址和数组188
6.4.1　翻译全局数组189
6.4.2翻译局部数组191
6.4.3翻译作为参数传递的数组193
6.4.4翻译switch语句198
6.5　动态内存分配200
6.5.1翻译全局指针200
6.5.2翻译局部指针204
6.5.3翻译结构207
6.5.4翻译链式数据结构210
总结214
练习214
问题215
第7章语言翻译原理222
7.1语言、语法和语法分析222
7.1.1连接223
7.1.2　语言223
7.1.3　语法224
7.1.4　C++标识符的语法225
7.1.5有符号整数的语法226
7.1.6上下文相关的语法227
7.1.7语法分析问题227
7.1.8表达式的语法228
7.1.9C++语法的一部分229
7.1.10　C++的上下文相关性232
7.2　有限状态机233
7.2.1用FSM来分析标识符233
7.2.2　简化的有限状态机234
7.2.3非确定性有限状态机234
7.2.4　具有空转移的状态机235
7.2.5语言符号识别器237
7.3实现有限状态机239
7.3.1查找表分析器240
7.3.2直接编码分析器241
7.3.3输入缓冲区类244
7.3.4多token分析器244
7.4　代码生成249
7.4.1语言翻译器249
7.4.2　语法分析器特性259
总结260
练习260
问题262
第五部分　操作系统层（第4层）
第8章　进程管理266
8.1　装载器266
8.1.1　Pep/8操作系统266
8.1.2　Pep/8装载器267
8.1.3　程序的终止269
8.2　陷阱269
8.2.1　陷阱机制269
8.2.2　RETTR指令270
8.2.3　陷阱处理程序271
8.2.4　陷阱寻址方式断言273
8.2.5　陷阱操作数地址计算274
8.2.6　空操作陷阱处理程序277
8.2.7　DECI陷阱处理程序277
8.2.8　DECO陷阱处理程序282
8.2.9　STRO陷阱处理程序和OS向量284
8.3　并发进程286
8.3.1　异步中断286
8.3.2　操作系统中的进程287
8.3.3　多处理288
8.3.4　并发处理程序289
8.3.5　临界区290
8.3.6　第一次尝试实现互斥291
8.3.7　第二次尝试实现互斥291
8.3.8　Peterson互斥算法292
8.3.9　信号量293
8.3.10　带信号量的临界区295
8.4　死锁296
8.4.1　资源分配图296
8.4.2　死锁策略298
总结298
练习299
问题302
第9章　存储管理305
9.1　内存分配305
9.1.1　单道程序设计305
9.1.2　固定分区多道程序设计306
9.1.3　逻辑地址306
9.1.4　可变分区多道程序设计308
9.1.5　分页310
9.2　虚拟内存312
9.2.1　大程序的行为312
9.2.2　虚拟内存313
9.2.3　按需取页315
9.2.4　替换页315
9.2.5　页替换算法316
9.3　文件管理318
9.3.1　磁盘驱动器318
9.3.2　文件抽象319
9.3.3　分配技术319
9.4　错误检测和纠错码321
9.4.1　错误检测码321
9.4.2　编码要求322
9.4.3　纠正一位错编码324
9.5　RAID存储系统325
9.5.1　RAID 0级：非冗余条带化326
9.5.2　RAID 1级：镜像326
9.5.3　RAID 01级和10级：条带化和镜像327
9.5.4　RAID 2级：内存风格的ECC328
9.5.5　RAID 3级：位交叉奇偶校验329
9.5.6　RAID 4级：块交叉奇偶校验329
9.5.7　RAID 5级：块交叉分布奇偶校验330
总结331
练习331
第六部分　逻辑门层（第1层）
第10章　组合电路334
10.1　布尔代数和逻辑门334
10.1.1　组合电路335
10.1.2　真值表335
10.1.3　布尔代数336
10.1.4　布尔代数定理337
10.1.5　互补证明338
10.1.6　逻辑图339
10.1.7　其他表达方式341
10.2　组合分析341
10.2.1　布尔表达式和逻辑图342
10.2.2　真值表和布尔表达式343
10.2.3　两级电路345
10.2.4　无所不在的NAND346
10.3　组合设计347
10.3.1　范式348
10.3.2　三变量卡诺图349
10.3.3　四变量卡诺图353
10.3.4　对偶卡诺图355
10.3.5　无关条件356
10.4　组合设备356
10.4.1　视角356
10.4.2　复用器358
10.4.3　二进制译码器358
10.4.4　多路分配器359
10.4.5　加法器359
10.4.6　加法器/减法器361
10.4.7　算术逻辑单元362
10.4.8　LG1层的抽象367
总结368
练习368
第11章　时序电路374
11.1　锁存器和时钟触发器374
11.1.1　SR锁存器374
11.1.2　钟控SR触发器376
11.1.3　主-从SR触发器377
11.1.4　基本触发器380
11.1.5　JK触发器381
11.1.6　D触发器382
11.1.7　T触发器383
11.1.8　激励表384
11.2　时序分析和设计384
11.2.1　时序分析问题385
11.2.2　预设置和清除387
11.2.3　时序设计387
11.2.4　一个时序设计问题388
11.3　计算机子系统390
11.3.1　寄存器390
11.3.2　总线391
11.3.3　内存子系统392
11.3.4　地址译码396
11.3.5　双端口寄存器体400
总结401
练习402
第七部分　微代码层（第2层）
第12章　计算机组成406
12.1　构造ISA3层机器406
12.1.1　中央处理单元406
12.1.2　冯·诺依曼周期408
12.1.3　实现存储字节指令412
12.1.4　实现加法指令412
12.1.5　实现装入指令413
12.1.6　实现算术右移指令415
12.2　性能问题416
12.2.1　总线宽度417
12.2.2　特殊的硬件单元419
12.2.3　3个优化领域421
12.2.4　微代码423
12.3　MIPS机器425
12.3.1　装入/存储体系结构425
12.3.2　指令集427
12.3.3　高速缓存431
12.3.4　MIPS的计算机组成437
12.3.5　流水线439
12.4　结论445
12.4.1　模型简化446
12.4.2　更大的景象446
总结447
练习448
附录Pep/8体系结构451
部分练习参考答案457
索引468
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>计算机系统：核心概念及软硬件实现（原书第4版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>我们世界的历史 4
第五版序言
作者介绍
卷七  欧洲时代的终结
导论
第1章	体系内的压力
第2章	第一次世界大战时期
第3章	新亚洲的形成
第4章	奥斯曼帝国的遗产和西方的伊斯兰地区
第5章	第二次世界大战
第6章	一个新世界的形成
卷八 新纪元
导论
第1章	概观
第2章	世界新秩序
第3章	破碎的必然
第4章	一个时代的终止
第5章	开始与终结
译后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>我们世界的历史 4
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>供应链物流管理(原书第4版)
目录
作者简介
译者序
前言
第一部分 供应链物流管理
第1章 21世纪的供应链／2
1.1 供应链革命／3
1.2 整合创造价值的原因／4
1.3 供应链的基本模式／5
1.4 信息系统的功能／6
1.5 供应链信息系统的组成模块／9
1.6 一体化管理与供应链流程／12
1.7 响应性／15
1.8 优化的财务管理／19
1.9 全球一体化／21
本章小结／22
学习型思考题／22
挑战型思考题／22
注释／22
第2章 物流／24
2.1 物流业务的重要性／25
2.2 物流的价值构成／26
2.3 物流过程／28
2.4 物流运作／32
2.5 物流整合目标／34
2.6 物流的运作模式／35
2.7 柔性结构／38
2.8 供应链的同步化／39
本章小结／43
学习型思考题／44
挑战型思考题／44
注释／44
第3章 客户关系管理／45
3.1 以客户为中心的市场营销／46
3.2 客户服务／49
3.3 客户满意度／54
3.4 客户成功／59
3.5 客户关系管理策略／61
本章小结／63
学习型思考题／64
挑战型思考题／64
注释／65
第4章 采购／66
4.1 采购观点／67
4.2 采购策略／69
4.3 供应商的甄选与评估／74
4.4 物流与采购对接／77
本章小结／78
学习型思考题／79
挑战型思考题／79
注释／79
第5章 制造／80
5.1 质量要求／80
5.2 制造概述／83
5.3 制造策略／86
5.4 当代制造理论的发展／90
本章小结／94
学习型思考题／95
挑战型思考题／95
注释／95
第6章 一体化运作计划／96
6.1 供应链计划／96
6.2 供应链计划应用系统／98
6.3 销售和作业计划／99
6.4 高级计划与排程系统概况／103
6.5 协同计划、预测和补货／108
6.6 预测／109
本章小结／119
学习型思考题／120
挑战型思考题／120
注释／120
第二部分 供应链物流运作
第7章 库存管理／122
7.1 库存的功能与定义／122
7.2 库存维持成本／128
7.3 库存计划／129
7.4 不确定性管理／133
7.5 库存管理政策／141
7.6 库存管理实践／149
本章小结／151
学习型思考题／152
挑战型思考题／152
注释／152
第8章 运输基础设施／153
8.1 运输的作用和参与者／153
8.2 从运输管制到自由运输市场／156
8.3 运输的组成／157
8.4 专业化运输服务／164
8.5 运输的经济性与定价／168
8.6 运输管理／176
8.7 单据／180
8.8 产品定价与运输／182
本章小结／184
学习型思考题／184
挑战型思考题／184
注释／185
第9章 仓储／186
9.1 战略仓储／186
9.2 仓库作业／191
9.3 仓库所有权的分类／194
9.4 仓库决策／196
本章小结／203
学习型思考题／204
挑战型思考题／204
注释／204
第10章 包装和物料处理／205
10.1 包装作业的前景／205
10.2 包装促进物料处理效率／207
10.3 物料处理／211
本章小结／219
学习型思考题／219
挑战型思考题／219
注释／220
第三部分 供应链物流设计
第11章 全球战略定位／222
11.1 经济全球化／222
11.2 全球供应链一体化／223
11.3 国际采购／230
本章小结／232
学习型思考题／232
挑战型思考题／233
注释／233
第12章 网络设计／234
12.1 企业设施网络／235
12.2 仓库的要求／236
12.3 系统概念及分析／238
12.4 总成本整合／239
12.5 物流战略规划／246
12.6 物流网络设计的其他问题／250
本章小结／251
学习型思考题／251
挑战型思考题／252
注释／252
第13章 物流运作分析／253
13.1 计划方法／253
13.2 阶段i：问题定义和计划／254
13.3 阶段ii：数据收集和分析／260
13.4 阶段iii：建议和实施／263
13.5 供应链运作分析方法和技巧／264
本章小结／274
学习型思考题／276
挑战型思考题／276
注释／276
第四部分 供应链的行政管理
第14章 协作关系管理／278
14.1 物流组织／278
14.2 发展供应链合作关系／283
14.3 关系管理／289
本章小结／292
学习型思考题／293
挑战型思考题／293
注释／293
第15章 绩效测量／294
15.1 测量系统目标／294
15.2 运作评价／295
15.3 财务评价／304
15.4 财务报告的要求／310
本章小结／312
学习型思考题／312
挑战型思考题／312
注释／313
第16章 供应链风险与可持续发展／314
16.1 供应链管理职责的演化／314
16.2 流程与资源／315
16.3 风险与安全管理／318
16.4 可持续发展／322
本章小结／331
学习型思考题／332
挑战型思考题／332
注释／332
结束语／334
术语表／336
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>供应链物流管理(原书第4版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>母子市场营销：如何向4I4L进行营销
目录
前言
第一部分 市场现状
第一章 母子新型消费者
20世纪早期的育儿情况 / 9
20世纪中期的育儿思想 / 10
20世纪70年代的育儿思想 / 10
呼唤纪律 / 12
90年代以及21世纪初的育儿理念 / 13
第二章 改变的发生
街上的新潮孩子 / 15
家中的新型妈妈 / 23
新型妈妈的生活 / 27
她们所缺乏的 / 34
必然结果 / 39
未来的妈妈是？ / 40
第三章 四眼四腿型消费者（4i4l）
妈妈主导的互动方式 / 46
孩子主导的互动方式 / 48
完全依赖阶段 / 49
怀孕期 / 50
婴儿期 / 52
有条件的依赖阶段 / 54
学龄前期（2~5岁） / 55
儿童期（4~7岁） / 56
相互依赖阶段 / 58
第四章 母子动力，走向双赢
妈妈的动机 / 63
孩子的动机 / 65
卡夫方便套餐的故事 / 68
第五章 4i4l消费者的决策过程
孩子对妈妈的影响 / 73
孩子对儿童产品购买的影响 / 75
孩子对家庭用品购买的影响 / 78
孩子对大人专用物品购买的影响 / 79
故事的全部 /80
不是每个妈妈都喜欢孩子的帮助 / 84
孩子同意，他们也有部分决定权！ / 85
妈妈对孩子的影响 / 88
受商品种类影响的母／子影响力 / 93
第六章 母子4i4l消费者市场
4i4l消费者能潜在影响的商品有多少？ / 99
这是一个怎样的市场？ / 101
4i4l消费者能消费多少？ / 102
孩子是购物主角的其他原因 / 105
第七章 4i4l消费者的思维方式
从出生到2岁的时期 / 110
3~6岁的儿童时期 / 111
7~12岁的少年时期 / 115
青少年时期 / 117
第二部分 营销技巧
第八章 4i4l消费者营销
第九章 深入洞察——研究你的4i4l消费者
有关焦点小组的建议 / 125
挖掘洞见的其他技巧 / 129
观察 / 130
第十章 如何拦截消费者——4i4l消费者和媒体
今天的孩子与媒体 / 135
“我的主张”娃娃 / 141
第三屏 / 146
多任务处理 / 147
妈妈与媒体 / 150
拦截哪一部分4i4l消费者（孩子或妈妈）？ / 155
如何拦截 / 157
青少年，另一码事 / 161
第十一章 吸引法则——如何交流
如何吸引孩子 / 167
眼光高的孩子 / 181
如何吸引妈妈 / 181
第十二章 激励消费者
什么是新事物？ / 188
在4i4l消费者中见效卓著的促销活动 / 189
新产品 / 194
第十三章 不同寻常的4i4l消费者营销案例
零售业 / 199
休闲与旅游行业 / 201
汽车产业 / 204
家庭内部设计及装饰 / 207
作者简介 / 210
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>母子市场营销：如何向4I4L进行营销
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>How to Make Money in Stocks (Chinese Edition)
Part　I　贏家系統：CAN SLIM
簡介　要多金：請向美國百年超級飆股取經
第一章　最神奇的選股祕密
第二章　解盤像行家，選股審時一把罩
第三章 C＝當期每股盈餘與每股營收很高，或是成長率逐季上升
第四章 A＝年度盈餘增加：尋找大成長
第五章 N＝較新的公司、新產品、新管理；從良好底部起漲，並創新高
第六章 S＝籌碼的供需：關鍵點需要大成交量
第七章 L＝強勢股或弱勢股：你的股票是哪一種？
第八章 I＝法人機構支持
第九章 M＝市場方向：你要如何判斷
Part　II　一開始就要精明
第十章　當你必須賣出股票，並執行所有停損時……沒有例外
第十一章　何時該賣出股票，保住優渥利潤
第十二章　資金管理：該分散投資、長期投資、使用融資、放空或購買選擇權、首次公開承銷股票、避稅、那斯達克股票、外國股票、債券，或其他資產嗎？
第十三章　二十一個大多數投資人都會犯的昂貴錯誤
Part　III　投資像專家
第十四章　更多股市飆股典範
第十五章　選擇最佳市場題材、類股與產業族群
第十六章　用《投資人財經日報》尋找潛在飆股
第十七章　觀察市場，回應消息
第十八章　靠基金賺進一百萬
第十九章　改善退休金與機構投資組合管理
第二十章　莫忘重要法則與指南
成功故事回饋
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>How to Make Money in Stocks (Chinese Edition)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>中文版Excel 2013应用宝典(第4版)——提示、技巧与省时妙招
第Ⅰ部分  工作簿和文件	1
技巧1：改变Excel外观	1
1. 修饰外观	1
2. 隐藏功能区	2
3. 使用视图选项卡中的选项	2
4. 隐藏其他元素	3
5. 隐藏状态栏	3
技巧2：自定义快速访问工具栏	4
1. 关于快速访问工具栏	4
2. 向快速访问工具栏添加新命令	4
3. 快速访问工具栏的其他一些功能	6
技巧3：自定义功能区	7
技巧4：理解“受保护的视图”	9
1. “受保护的视图”出现的原因	9
2. 打印和复制	10
3. 强制将文件以正常视图打开	10
技巧5：理解“自动恢复”	11
1. 当前工作簿的恢复版本	12
2. 恢复未保存的文件	12
技巧6：在浏览器中使用工作簿	13
技巧7：保存为只读格式	14
1. 发送打印版副本	14
2. 以PDF文件的形式发送电子版副本	14
3. 发送MHTML文件	16
技巧8：生成文件名列表	16
技巧9：生成工作表名列表	18
技巧10：应用文档主题	20
1. 应用文档主题	22
2. 自定义文档主题	23
技巧11：理解Excel兼容性问题	24
1. Excel 2013文件格式	25
2. Office兼容包	25
3. 检查兼容性	25
技巧12：更改打印机设置	26
第Ⅱ部分  格式	29
技巧13：合并单元格	29
1. 其他合并操作	30
2. 合并的单元格含有的潜在问题	31
3. 定位所有合并后的单元格	31
4. 解除所有单元格的合并	32
5. 合并单元格的替代方式	32
技巧14：调整单元格中内容的缩进	33
技巧15：使用命名样式	35
1. 使用样式表	36
2. 修改现有的样式	36
3. 新建样式	37
4. 从其他工作簿中合并样式	38
技巧16：创建自定义数字格式	38
1. 数字格式字符串的组成部分	39
2. 自定义数字格式代码	40
技巧17：使用自定义数字格式缩放数值	41
技巧18：创建项目符号列表	43
1. 使用点符号	43
2. 使用SmartArt	44
技巧19：使用条件格式对行进行交替着色	45
1. 单行交替着色	45
2. 创建棋盘着色	46
3. 多行交替着色	46
技巧20：对单元格中的个别字符进行格式设置	47
技巧21：使用格式刷	47
1. 格式刷的基本操作	48
2. 格式刷的其他用途	48
技巧22：插入水印	49
技巧23：在一个单元格中显示文本和数值	51
1. 使用连接	51
2. 使用TEXT函数	51
3. 使用自定义数字格式	51
技巧24：避免小字体时出现字体替换	52
技巧25：更新旧的字体	54
第Ⅲ部分  公式	57
技巧26：调整编辑栏的大小	58
技巧27：从任意位置监控公式单元格	59
1. 关于“监视窗口”	59
2. 定制“监视窗口”	60
3. 使用“监视窗口”导航	60
技巧28：“自动求和”技巧	60
技巧29：使用绝对引用和混合引用	62
1. 使用绝对引用	63
2. 使用混合引用	64
技巧30：避免公式显示错误信息	64
1. 使用IFERROR函数	65
2. 使用ISERROR函数	66
技巧31：创建工作表层次的名称	66
技巧32：使用命名常量	68
技巧33：从Excel发送个人电子邮件	69
1. HYPERLINK函数	69
2. HYPERLINK实例	70
技巧34：精确查找某个值	72
技巧35：双向查找	73
1. 使用公式查找	73
2. 使用隐式交叉	75
技巧36：双列查找	75
技巧37：计算节假日	77
1. 元旦	78
2. 马丁·路德·金纪念日	78
3. 总统日	78
4. 复活节	78
5. 阵亡将士纪念日	78
6. 美国独立日	78
7. 美国劳工节	79
8. 哥伦布发现美洲纪念日	79
9. 退伍老兵节	79
10. 感恩节	79
11. 圣诞节	79
技巧38：计算年龄	79
1. 方法1	79
2. 方法2	80
3. 方法3	80
技巧39：处理1900年以前的日期	81
1. 三列法表示日期	81
2. 使用自定义函数	82
3. 使用其他产品	83
技巧40：在单元格区域中显示日历	84
技巧41：返回某列或某行中最后一个非空单元格	86
1. 单元格计数法	86
2. 数组公式的方法	86
3. 标准公式法	87
技巧42：数字舍入的几种方法	87
1. 舍入到最接近的倍数	88
2. 舍入货币值	88
3. 使用INT和TRUNC函数	89
4. 舍入为n位有效数字	89
技巧43：在不同度量系统间转换	90
技巧44：计算某个区域内非重复项的个数	91
技巧45：使用AGGREGATE函数	92
技巧46：精确复制某个区域内的公式	95
技巧47：使用“后台错误检查”特性	96
技巧48：使用Inquire加载项	98
1. 工作簿分析	98
2. 图表工具	99
3. 比较文件	100
4. 杂项	100
技巧49：隐藏或锁定公式	100
1. 隐藏并锁定公式单元格	101
2. 解锁所有非公式单元格	101
3. 保护工作表	102
技巧50：使用INDIRECT函数	103
1. 直接指定相应的行	103
2. 间接指定工作表名称	104
3. 固化区域引用	104
技巧51：在对话框中编辑公式	105
技巧52：将垂直区域转换为表格	106
第Ⅳ部分  处理数据	109
技巧53：高效选取单元格	109
1. 使用Shift键和方向键来选择区域	110
2. 选择当前区域	110
3. 使用Shift键+单击的方法选定区域	110
4. 选择非连续区域	110
5. 选取整行	111
6. 选取整列	111
7. 选取多个工作表的多个区域	112
技巧54：用序列自动填充区域	112
技巧55：固定显示尾负号	116
技巧56：限制输入单元格内光标的行为	116
技巧57：数据变换与公式	118
1. 不借助公式变换	118
2. 使用临时公式变换数据	119
技巧58：在单元格中创建下拉列表框	120
技巧59：利用条件格式比较两个区域	122
技巧60：使用条件格式找到重复内容	124
技巧61：处理信用卡号码	126
1. 手动输入信用卡号码	127
2. 导入信用卡号码	127
技巧62：识别多余的空格	128
技巧63：转置区域	130
1. 使用选择性粘贴	130
2. 使用TRANSPOSE函数	131
技巧64：使用快速填充提取数据	132
1. 改变文本大小写	132
2. 提取姓氏	133
3. 提取名字	133
4. 提取中间名	134
5. 从URL中提取域名	134
6. 潜在问题	134
技巧65：使用“快速填充”组合数据	135
技巧66：插入股票信息	136
1. 隐藏不相关的行和列	137
2. 本源	137
技巧67：从网页上获取数据	138
1. 粘贴静态信息	139
2. 粘贴可刷新信息	139
3. 直接打开网页	142
技巧68：将文本文件导入到工作表区域中	142
技巧69：使用“快速分析”特性	143
技巧70：填补报表中的空隙	145
技巧71：进行模糊搜索	147
技巧72：利用声音验证数据	148
1. 向功能区添加朗读命令	149
2. 使用这些朗读命令	150
技巧73：从PDF文件中获取数据	150
1. 使用复制粘贴	150
2. 使用Word 2013作为中介	151
第Ⅴ部分  表格和数据透视表	153
技巧74：使用表格	153
1. 什么是“表格”	153
2. 区域与表格	155
3. 表格的局限性	155
技巧75：在表格中使用公式	155
1. 使用“汇总”行	156
2. 在表格中使用公式	157
3. 引用表格中数据	159
技巧76：在表格中显示行的序号	160
技巧77：判断某个数据表是否适用于数据透视表	161
技巧78：用数据透视表取代公式	165
1. 插入汇总	165
2. 使用公式	166
3. 使用数据透视表格	167
技巧79：控制对数据透视表格内单元格的引用	168
技巧80：快速创建频度表	170
技巧81：将数据透视表格内的项按日期进行组合	172
技巧82：使用多个分组创建数据透视表	175
技巧83：使用数据透视表切片和日程表	177
1. 使用切片器	177
2. 使用日程表	179
第Ⅵ部分  图表和图片	181
技巧84：理解“推荐的图表”	181
技巧85：定制图表	183
1. 添加或移除图表元素	183
2. 修改图表样式或颜色	183
3. 筛选图表数据	184
技巧86：使各图表大小一致	185
技巧87：创建图表模板	186
1. 创建模板	187
2. 使用模板	187
技巧88：创建组合图表	188
1. 插入预配置好的组合图表	189
2. 定制组合图	190
技巧89：处理图表中缺失的数据	191
技巧90：在图表中使用高低线	192
技巧91：使用多级分类标签	193
技巧92：链接图表中的文本与单元格	195
技巧93：冻结图表	196
1. 将图表转换为图片	197
2. 将区域引用转换为数组	198
技巧94：直接在区域中创建图表	199
1. 使用条件格式化数据条	199
2. 使用公式以重复的字符显示数据	200
技巧95：创建极简风格的图表	202
1. 简单的柱状图	202
2. 简单的饼图	203
3. 简单的折线图	204
4. 表盘图	205
技巧96：在图表使用来自区域的数据标签	206
技巧97：组合图表和其他对象	207
1. 组合图表	207
2. 组合其他对象	209
技巧98：将单元格区域转换成图片	211
1. 为区域创建静态图像	211
2. 创建一个区域的实时图像	212
3. 将区域保存为图片	212
技巧99：改变单元格批注的外观	213
1. 设置“快速访问工具栏”	214
2. 设置批注的格式	214
3. 改变批注形状	215
4. 向单元格批注中添加图片	215
技巧100：图片增强	215
技巧101：将形状、图表和区域保存为图片	217
第Ⅶ部分  额外技巧	219
本部分包括：	219
额外技巧102：了解一些有用的快捷键	220
额外技巧103：重置工作表中已使用的区域	221
额外技巧104：隐藏行或列	221
1. 隐藏	222
2. 显示	222
额外技巧105：隐藏单元格内容	223
额外技巧106：限定工作表中的可用范围	223
1. 设置ScrollArea属性	223
2. 使用工作表保护	225
额外技巧107：另一种形式单元格批注	225
额外技巧108：使工作表“完全隐藏”	226
额外技巧109：输入数据后单元格指针的移动方式	227
额外技巧110：保持标题可见	228
额外技巧111：处理分数	229
额外技巧112：控制自动超链接	231
1. 取消自动超链接	231
2. 关闭自动超链接	231
3. 删除已有的超链接	232
额外技巧113：控制Office剪贴板	232
额外技巧114：显示数值大于24小时的时间	233
额外技巧115：给单元格区域添加边框	234
额外技巧116：用网格线、边框和下划线进行格式处理	235
额外技巧117：查看字体中的所有字符	237
额外技巧118：在不使用批注的情况下注释公式	238
额外技巧119：显示及打印公式	239
额外技巧120：创建名称列表	240
额外技巧121：舍入时间值	242
额外技巧122：温度单位换算	242
额外技巧123：计算根	243
额外技巧124：计算余数	243
额外技巧125：创建迷你图	244
额外技巧126：使用图片作为折线图的标记点	246
额外技巧127：使列表随机排列	248
额外技巧128：显示工作簿的完整路径	249
1. 通过后台查看	249
2. 使用公式	249
3. 向“快速访问工具栏”添加新控件	249
4. 使用宏	250
额外技巧129：关闭所有工作簿	250
额外技巧130：跨工作表复制页面设置	251
额外技巧131：打印单元格批注	252
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>中文版Excel 2013应用宝典(第4版)——提示、技巧与省时妙招
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Android 5.0开发范例代码大全：第4版
目    录
第1章  布局和视图	1
1.1  样式化常见组件	1
1.1.1  问题	1
1.1.1  解决方案	1
1.1.3  实现机制	2
1.2  切换系统UI元素	10
1.2.1  问题	10
1.2.2  解决方案	10
1.2.3  实现机制	11
1.3  创建并显示视图	14
1.3.1  问题	14
1.3.2  解决方案	14
1.3.3  实现机制	14
1.4  动画视图	20
1.4.1  问题	20
1.4.2  解决方案	21
1.4.3  实现机制	21
1.5  布局变化时的动画	26
1.5.1  问题	26
1.5.2  解决方案	26
1.5.3  实现机制	27
1.6  实现针对具体场景的布局	30
1.6.1  问题	30
1.6.2  解决方案	30
1.6.3  实现机制	30
1.7  自定义AdapterView的空视图	38
1.7.1  问题	38
1.7.2  解决方案	38
1.7.3  实现机制	38
1.8  自定义ListView中的行	40
1.8.1  问题	40
1.8.2  解决方案	40
1.8.3  实现机制	40
1.9  制作ListView的节头部	44
1.9.1  问题	44
1.9.2  解决方案	44
1.9.3  实现机制	44
1.10  创建组合控件	52
1.10.1  问题	52
1.10.2  解决方案	52
1.10.3  实现机制	52
1.11  自定义过渡动画	56
1.11.1  问题	56
1.11.2  解决方案	56
1.11.3  实现机制	56
1.12  创建视图变换	65
1.12.1  问题	65
1.12.2  解决方案	65
1.12.3  实现机制	65
1.13  建立可扩展的集合视图	71
1.13.1  问题	71
1.13.2  解决方案	72
1.13.3  实现机制	72
1.14  小结	82
第2章  用户交互	83
2.1  利用Action Bar	83
2.1.1  问题	83
2.1.2  解决方案	83
2.1.3  实现机制	84
2.2  锁定Activity方向	91
2.2.1  问题	91
2.2.2  解决方案	91
2.2.3  实现机制	91
2.3  动态方向锁定	92
2.3.1  问题	92
2.3.2  解决方案	92
2.3.3  实现机制	92
2.4  手动处理旋转	94
2.4.1  问题	94
2.4.2  解决方案	94
2.4.3  实现机制	95
2.5  创建上下文动作	98
2.5.1  问题	98
2.5.2  解决方案	98
2.5.3  实现机制	98
2.6  显示一个用户对话框	103
2.6.1  问题	103
2.6.2  解决方案	103
2.6.3  实现机制	103
2.7  自定义菜单和动作	108
2.7.1  问题	108
2.7.2  解决方案	108
2.7.3  实现机制	109
2.8  自定义BACK按键	114
2.8.1  问题	114
2.8.2  解决方案	114
2.8.3  实现机制	114
2.9  模拟HOME按键	117
2.9.1  问题	117
2.9.2  解决方案	117
2.9.3  实现机制	118
2.10  监控TextView的变动	118
2.10.1  问题	118
2.10.2  解决方案	118
2.10.3  实现机制	119
2.11  自定义键盘动作	121
2.11.1  问题	121
2.11.2  解决方案	121
2.11.3  实现机制	121
2.12  消除软键盘	124
2.12.1  问题	124
2.12.2  解决方案	124
2.12.3  实现机制	124
2.13  处理复杂的触摸事件	125
2.13.1  问题	125
2.13.2  解决方案	125
2.13.3  实现机制	126
2.14  转发触摸事件	142
2.14.1  问题	142
2.14.2  解决方案	142
2.14.3  实现机制	142
2.15  阻止触摸窃贼	146
2.15.1  问题	146
2.15.2  解决方案	146
2.15.3  实现机制	146
2.16  创建拖放视图	149
2.16.1  问题	149
2.16.2  解决方案	150
2.16.3  实现机制	151
2.17  构建导航Drawer	157
2.17.1  问题	157
2.17.2  解决方案	157
2.17.3  实现机制	157
2.18  在视图之间滑动	167
2.18.1  问题	167
2.18.2  解决方案	167
2.18.3  实现机制	168
2.19  使用选项卡导航	177
2.19.1  问题	177
2.19.2  解决方案	177
2.19.3  实现机制	178
2.20  小结	185
第3章  通信和联网	187
3.1  显示Web信息	187
3.1.1  问题	187
3.1.2  解决方案	187
3.1.3  实现机制	187
3.2  拦截WebView事件	192
3.2.1  问题	192
3.2.2  解决方案	192
3.2.3  实现机制	192
3.3  访问带JavaScript的WebView	193
3.3.1  问题	193
3.3.2  解决方案	194
3.3.3  实现机制	194
3.4  下载图片文件	196
3.4.1  问题	196
3.4.2  解决方案	197
3.4.3  实现机制	197
3.5  完全在后台下载	200
3.5.1  问题	200
3.5.2  解决方案	200
3.5.3  实现机制	200
3.6  访问REST API	203
3.6.1  问题	203
3.6.2  解决方案	204
3.6.3  实现机制	204
3.7  解析JSON	222
3.7.1  问题	222
3.7.2  解决方案	222
3.7.3  实现机制	222
3.8  解析XML	225
3.8.1  问题	225
3.8.2  解决方案	225
3.8.3  实现机制	226
3.9  接收短信	235
3.9.1  问题	235
3.9.2  解决方案	235
3.9.3  实现机制	236
3.10  发送短信	238
3.10.1  问题	238
3.10.2  解决方案	238
3.10.3  实现机制	239
3.11  蓝牙通信	241
3.11.1  问题	241
3.11.2  解决方案	241
3.11.3  实现机制	241
3.12  查询网络连接状态	250
3.12.1  问题	250
3.12.2  解决方案	250
3.12.3  实现机制	250
3.13  使用NFC传输数据	253
3.13.1  问题	253
3.13.2  解决方案	253
3.13.3  实现机制	253
3.14  USB连接	260
3.14.1  问题	260
3.14.2  解决方案	261
3.14.3  实现机制	261
3.15  小结	270
第4章  实现设备硬件交互与媒体交互	271
4.1  整合设备位置	271
4.1.1  问题	271
4.1.2  解决方案	271
4.1.3  实现机制	272
4.2  地图位置	277
4.2.1  问题	277
4.2.2  解决方案	277
4.2.3  实现机制	280
4.3  在地图上标记位置	285
4.3.1  问题	285
4.3.2  解决方案	285
4.3.3  实现机制	286
4.4  监控位置地区	301
4.4.1  问题	301
4.4.2  解决方案	301
4.4.3  实现机制	302
4.5  拍摄照片和视频	311
4.5.1  问题	311
4.5.2  解决方案	311
4.5.3  实现机制	311
4.6  自定义摄像头覆盖层	316
4.6.1  问题	316
4.6.2  解决方案	316
4.6.3  实现机制	317
4.7  录制音频	323
4.7.1  问题	323
4.7.2  解决方案	323
4.7.3  实现机制	323
4.8  自定义视频采集	325
4.8.1  问题	325
4.8.2  解决方案	325
4.8.3  实现机制	326
4.9  添加语音识别	330
4.9.1  问题	330
4.9.2  解决方案	330
4.9.3  实现机制	330
4.10  播放音频/视频	332
4.10.1  问题	332
4.10.2  解决方案	332
4.10.3  实现机制	332
4.11  播放音效	341
4.11.1  问题	341
4.11.2  解决方案	341
4.11.3  实现机制	341
4.12  创建倾斜监控器	344
4.12.1  问题	344
4.12.2  解决方案	344
4.12.3  实现机制	344
4.13  监控罗盘的方向	347
4.13.1  问题	347
4.13.2  解决方案	348
4.13.3  实现机制	348
4.14  从媒体内容中获取元数据	351
4.14.1  问题	351
4.14.2  解决方案	351
4.14.3  实现机制	352
4.15  检测用户移动	355
4.15.1  问题	355
4.15.2  解决方案	355
4.15.3  实现机制	356
4.16  小结	366
第5章  数据持久化	367
5.1  制作首选项界面	367
5.1.1  问题	367
5.1.2  解决方案	367
5.1.3  实现机制	367
5.2  显示自定义首选项	373
5.2.1  问题	373
5.2.2  解决方案	373
5.2.3  实现机制	374
5.3  简单数据存储	378
5.3.1  问题	378
5.3.2  解决方案	379
5.3.3  实现机制	379
5.4  读写文件	383
5.4.1  问题	383
5.4.2  解决方案	383
5.4.3  实现机制	383
5.5  以资源的形式使用文件	390
5.5.1  问题	390
5.5.2  解决方案	390
5.5.3  实现机制	391
5.6  管理数据库	393
5.6.1  问题	393
5.6.2  解决方案	393
5.6.3  实现机制	393
5.7  查询数据库	398
5.7.1  问题	398
5.7.2  解决方案	398
5.7.3  实现机制	399
5.8  备份数据	400
5.8.1  问题	400
5.8.2  解决方案	400
5.8.3  实现机制	400
5.9  分享数据库	405
5.9.1  问题	405
5.9.2  解决方案	405
5.9.3  实现机制	405
5.10  分享SharedPreference	412
5.10.1  问题	412
5.10.2  解决方案	412
5.10.3  实现机制	412
5.11  分享其他数据	421
5.11.1  问题	421
5.11.2  解决方案	421
5.11.3  实现机制	422
5.12  集成系统文档	428
5.12.1  问题	428
5.12.2  解决方案	428
5.12.3  实现机制	429
5.13  小结	442
第6章  与系统交互	443
6.1  后台通知	443
6.1.1  问题	443
6.1.2  解决方案	443
6.1.3  实现机制	443
6.2  创建定时和周期任务	459
6.2.1  问题	459
6.2.2  解决方案	460
6.2.3  实现机制	460
6.3  定时执行周期任务	461
6.3.1  问题	461
6.3.2  解决方案	461
6.3.3  实现机制	462
6.4  创建粘性操作	469
6.4.1  问题	469
6.4.2  解决方案	469
6.4.3  实现机制	470
6.5  长时间运行的后台操作	474
6.5.1  问题	474
6.5.2  解决方案	474
6.5.3  实现机制	475
6.6  启动其他应用程序	480
6.6.1  问题	480
6.6.2  解决方案	480
6.6.3  实现机制	481
6.7  启动系统应用程序	484
6.7.1  问题	484
6.7.2  解决方案	484
6.7.3  实现机制	485
6.8  让其他应用程序启动你的应用程序	489
6.8.1  问题	489
6.8.2  解决方案	489
6.8.3  实现机制	489
6.9  与联系人交互	491
6.9.1  问题	491
6.9.2  解决方案	491
6.9.3  实现机制	492
6.10  读取设备媒体和文档	500
6.10.1  问题	500
6.10.2  解决方案	500
6.10.3  实现机制	500
6.11  保存设备媒体和文档	504
6.11.1  问题	504
6.11.2  解决方案	504
6.11.3  实现机制	504
6.12  读取消息数据	509
6.12.1  问题	509
6.12.2  解决方案	509
6.12.3  实现机制	510
6.13  与日历交互	521
6.13.1  问题	521
6.13.2  解决方案	521
6.13.3  实现机制	521
6.14  执行日志代码	527
6.14.1  问题	527
6.14.2  解决方案	528
6.14.3  实现机制	528
6.15  创建后台工作线程	530
6.15.1  问题	530
6.15.2  解决方案	530
6.15.3  实现机制	530
6.16  自定义任务栈	535
6.16.1  问题	535
6.16.2  解决方案	535
6.16.3  实现机制	535
6.17  实现AppWidget	543
6.17.1  问题	543
6.17.2  解决方案	543
6.17.3  实现机制	544
6.18  支持受限制的配置文件	564
6.18.1  问题	564
6.18.2  解决方案	564
6.18.3  实现机制	565
6.19  小结	577
第7章  图形和绘图	579
7.1  用Drawable做背景	579
7.1.1  问题	579
7.1.2  解决方案	579
7.1.3  实现机制	580
7.2  创建自定义状态的Drawable	586
7.2.1  问题	586
7.2.2  解决方案	586
7.2.3  实现机制	586
7.3  将遮罩应用于图片	591
7.3.1  问题	591
7.3.2  解决方案	591
7.3.3  实现机制	592
7.4  在视图内容上绘制	601
7.4.1  问题	601
7.4.2  解决方案	601
7.4.3  实现机制	601
7.5  高性能绘制	617
7.5.1  问题	617
7.5.2  解决方案	617
7.5.3  实现机制	617
7.6  提取图片调色板	628
7.6.1  问题	628
7.6.2  解决方案	628
7.6.3  实现机制	629
7.7  平铺Drawable元素	633
7.7.1  问题	633
7.7.2  解决方案	633
7.7.3  实现机制	634
7.8  使用可缩放的向量资源	639
7.8.1  问题	639
7.8.2  解决方案	639
7.8.3  实现机制	639
7.9  小结	648
第8章  使用Android NDK和
RenderScript	649
8.1  Android NDK	649
8.2  使用JNI添加原生位	651
8.2.1  问题	651
8.2.2  解决方案	651
8.2.3  实现机制	652
8.3  构建纯原生Activity	660
8.3.1  问题	660
8.3.2  解决方案	660
8.3.3  实现机制	660
8.4  RenderScript	670
8.5  使用RenderScript过滤图片	671
8.5.1  问题	671
8.5.2  解决方案	672
8.5.3  实现机制	672
8.6  使用RenderScript操作图片	677
8.6.1  问题	677
8.6.2  解决方案	677
8.6.3  实现机制	677
8.7  使用模糊滤镜仿造透明覆盖层	683
8.7.1  问题	683
8.7.2  解决方案	683
8.7.3  实现机制	683
8.8  小结	693
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Android 5.0开发范例代码大全：第4版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>新手学JavaScript编程(第4版)
目    录
第1章  JavaScript简介	1
1.1  预备知识	2
1.1.1  HTML和CSS基础知识	2
1.1.2  文本编辑器和Web浏览器基础知识	3
1.1.3  版本	5
1.1.4  与Java的区别	5
1.1.5  与其他语言的相似之处	5
1.2  开始学习JavaScript	7
1.2.1  基于原型	7
1.2.2  客户端	7
1.2.3  脚本语言	8
1.3  汇总	8
1.4  在线资源	9
1.5  动手尝试1-1：使用JavaScript输出文本	9
1.6  自测题	10
第2章  在HTML文件中添加JavaScript	13
2.1  使用HTML脚本标记	14
2.1.1  识别脚本语言	14
2.1.2  调用外部脚本	15
2.1.3  指定脚本加载时间	15
2.1.4  使用<noscript></noscript>标记	16
2.2  创建第一个脚本	17
2.2.1  编写“Hello World”脚本	18
2.2.2  为脚本创建HTML文档	18
2.2.3  在HTML文档中插入脚本	19
2.3  动手尝试2-1：在HTML文档中插入脚本	20
2.4  使用外部JavaScript文件	21
2.4.1  创建JavaScript文件	21
2.4.2  创建HTML文件	22
2.4.3  在浏览器中查看页面	23
2.5  动手尝试2-2：从HTML文档调用外部脚本	24
2.6  使用JavaScript注释	24
2.6.1  添加单行注释	25
2.6.2  添加多行注释	25
2.7  自测题	26
第3章  使用变量	29
3.1  变量简介	30
3.2  变量的作用	30
3.2.1  用作未知值的占位符	30
3.2.2  节省编程时间	31
3.2.3  使代码更清晰	31
3.3  定义变量	31
3.3.1  声明变量	31
3.3.2  变量赋值	32
3.3.3  命名变量	33
3.4  数据类型	35
3.4.1  数字	36
3.4.2  字符串	36
3.4.3  布尔类型	40
3.4.4  null	41
3.4.5  undefined	41
3.5  动手尝试3-1：声明变量	42
3.6  在脚本中使用变量	43
3.6.1  访问变量	43
3.6.2  将变量添加到文本字符串中	43
3.7  编写JavaScript页面	44
3.7.1  创建框架	45
3.7.2  定义变量	45
3.7.3  添加命令	46
3.7.4  修改页面	47
3.8  动手尝试3-2：创建使用JavaScript的HTML文档	48
3.9  自测题	50
第4章  使用函数	53
4.1  函数的定义	54
4.2  函数的作用	54
4.3  构建函数	55
4.3.1  声明函数	55
4.3.2  定义函数代码	55
4.3.3  命名函数	56
4.3.4  添加函数参数	57
4.3.5  添加函数返回语句	58
4.4  在脚本中调用函数	59
4.4.1  script标记：头部分或主体部分	60
4.4.2  嵌套调用函数	62
4.4.3  调用包含参数的函数	64
4.4.4  调用包含return语句的函数	67
4.4.5  定义函数的其他方式	68
4.5  动手尝试4-1：创建包含函数的HTML页面	71
4.6  作用域/上下文基础知识	72
4.6.1  全局上下文	72
4.6.2  函数上下文	73
4.7  动手尝试4-2：编写自己的函数	74
4.8  自测题	75
第5章  JavaScript运算符	77
5.1  理解运算符类型	78
5.2  理解算术运算符	78
5.2.1  加法运算符(+)	79
5.2.2  减法运算符(-)	82
5.2.3  乘法运算符(*)	83
5.2.4  除法运算符(/)	83
5.2.5  取模运算符(%)	84
5.2.6  自增运算符(++)	84
5.2.7  自减运算符	85
5.2.8  一元加运算符(+)	86
5.2.9  一元减运算符(-)	86
5.3  理解赋值运算符	87
5.3.1  赋值运算符	87
5.3.2  加法赋值运算符	88
5.3.3  减法赋值运算符	88
5.3.4  乘法赋值运算符	89
5.3.5  除法赋值运算符	89
5.3.6  取模赋值运算符	89
5.4  动手尝试5-1：修改变量值	89
5.5  理解比较运算符	90
5.5.1  相等运算符(==)	91
5.5.2  不等运算符(!=)	92
5.5.3  恒等运算符(===)	93
5.5.4  非恒等运算符(!==)	93
5.5.5  大于运算符(>)	93
5.5.6  小于运算符(<)	94
5.5.7  大于等于运算符(>=)	94
5.5.8  小于等于运算符	95
5.6  理解逻辑运算符	95
5.6.1  逻辑与运算(&&)	96
5.6.2  逻辑或运算符(||)	96
5.6.3  逻辑非运算符(！)	96
5.6.4  位运算符	97
5.7  特殊运算符	97
5.8  理解运算符的执行顺序	98
5.9  动手尝试5-2：true还是false	99
5.10  自测题	100
第6章  条件语句和循环	103
6.1  条件语句的定义	104
6.1.1  条件语句的定义	104
6.1.2  条件语句的作用	104
6.2  条件语句的使用	105
6.2.1  使用if/else语句	105
6.2.2  使用switch语句	112
6.2.3  使用条件运算符	114
6.2.4  提示框中获得的用户输入	115
6.3  动手尝试6-1：处理用户的输入	117
6.4  定义循环	118
6.4.1  循环的定义	118
6.4.2  循环的作用	119
6.5  使用循环	119
6.5.1  for	119
6.5.2  while	126
6.5.3  do while循环	128
6.5.4  for in和for each in循环	128
6.5.5  使用break和continue	128
6.6  动手尝试6-2：使用for循环和while循环	130
6.7  自测题	132
第7章  JavaScript数组	135
7.1  数组的定义	136
7.2  数组的作用	136
7.3  定义和访问数组	137
7.3.1  命名数组	137
7.3.2  定义数组	137
7.3.3  访问数组元素	138
7.3.4  使用length属性和循环	139
7.3.5  修改数组元素值和数组长度	141
7.4  动手尝试7-1：使用循环遍历数组	142
7.5  数组属性和方法	143
7.5.1  属性	143
7.5.2  方法	144
7.6  嵌套数组	157
7.6.1  定义嵌套数组	157
7.6.2  循环和嵌套数组	158
7.7  动手尝试7-2：嵌套数组练习	160
7.8  自测题	161
第8章  对象	163
8.1  定义对象	164
8.2  创建对象	164
8.2.1  命名	164
8.2.2  单一对象	164
8.3  动手尝试8-1：创建computer对象	168
8.4  对象结构	168
8.4.1  构造函数	169
8.4.2  使用原型	173
8.5  帮助访问对象的语句	176
8.5.1  for-in循环	176
8.5.2  with语句	177
8.6  动手尝试8-2：练习使用构造函数/原型结合模式	178
8.7  理解JavaScript预定义对象	179
8.7.1  navigator对象	180
8.7.2  history对象	182
8.8  自测题	183
第9章  document对象	185
9.1  定义document对象	186
9.2  使用文档对象模型	186
9.3  使用document对象的属性	187
9.3.1  集合	189
9.3.2  cookie属性	189
9.3.3  dir属性	190
9.3.4  lastModified属性	190
9.3.5  referrer属性	191
9.3.6  title属性	191
9.3.7  URL属性	192
9.3.8  URLUnencoded属性	192
9.4  使用document对象的方法	193
9.4.1  针对元素的get方法	195
9.4.2  open()和close()方法	197
9.4.3  write()和writeln()方法	199
9.5  使用DOM节点	200
9.5.1  DOM节点属性	200
9.5.2  DOM节点方法	202
9.6  动手尝试9-1：向文档中添加DOM节点	206
9.7  创建动态脚本	207
9.7.1  JavaScript中的样式	207
9.7.2  简单事件处理	208
9.7.3  编写动态脚本	209
9.8  动手尝试9-2：尝试修改属性	211
9.9  自测题	212
第10章  事件处理程序	215
10.1  事件处理程序的含义	216
10.2  事件处理程序的作用	216
10.3  理解事件处理程序位置和用法	216
10.3.1  在HTML元素中使用事件处理程序	217
10.3.2  在脚本代码中使用事件处理程序	218
10.4  学习事件	219
10.4.1  单击事件	221
10.4.2  获得焦点和失去焦点事件	222
10.4.3  加载和卸载事件	224
10.4.4  重置和提交事件	226
10.4.5  鼠标事件	226
10.4.6  键盘事件	227
10.5  动手尝试10-1：获得焦点和失去焦点	228
10.6  注册事件的其他方式	229
10.6.1  addEventListener()方法	230
10.6.2  attachEvent()方法	231
10.7  event对象	231
10.7.1  DOM和Internet Explorer：DOM级别0注册	231
10.7.2  使用最新事件注册方法处理事件	232
10.7.3  属性和方法	233
10.7.4  事件信息	234
10.8  动手尝试10-2：使用addEventListener()	234
10.9  使用事件处理程序创建脚本	235
10.9.1  显示隐藏内容	235
10.9.2  修改内容	237
10.10  自测题	241
第11章  window对象	243
11.1  window全局对象	244
11.2  使用window对象的属性	244
11.2.1  closed属性	246
11.2.2  frames属性	246
11.2.3  innerWidth和innerHeight属性	246
11.2.4  length属性	247
11.2.5  location属性	247
11.2.6  name属性	247
11.2.7  opener属性	248
11.2.8  parent、self和top属性	248
11.2.9  status和defaultStatus属性	248
11.3  动手尝试11-1：使用location和innerWidth属性	249
11.4  使用Window对象的方法	250
11.4.1  alert()、prompt()和confirm()方法	251
11.4.2  find()方法	253
11.4.3  home()方法	253
11.4.4  print()方法	253
11.4.5  setInterval()和clearInterval()方法	254
11.4.6  setTimeout()和clearTimeout()方法	255
11.5  动手尝试11-2：使用setTimeout()和confirm()方法	257
11.6  主窗口和新窗口	258
11.6.1  弹出窗口的使用	258
11.6.2  打开新窗口	258
11.6.3  关闭新窗口	261
11.6.4  移动、重置和滚动新窗口	262
11.7  自测题	267
第12章  Math、Number和Date对象	269
12.1  使用Math对象	270
12.1.1  Math对象的定义	270
12.1.2  如何使用Math对象	270
12.1.3  属性	270
12.1.4  方法	272
12.2  动手尝试12-1：在页面中显示随机链接	283
12.3  理解Number对象	284
12.3.1  属性	284
12.3.2  方法	286
12.4  使用Date对象	289
12.4.1  属性和方法	289
12.4.2  用于获取值的方法	291
12.4.3  用于设置值的方法	293
12.4.4  其他方法	294
12.4.5  创建日期脚本	295
12.5  动手尝试12-2：创建JavaScript时钟	298
12.6  自测题	299
第13章  处理字符串	301
13.1  String对象简介	302
13.1.1  String对象	302
13.1.2  字符串字面量	302
13.1.3  区别	302
13.2  使用String对象的属性和方法	303
13.3  String对象的方法	304
13.4  动手尝试13-1：使用indexOf()测试地址	314
13.5  使用cookie	315
13.5.1  设置cookie	316
13.5.2  读取cookie	318
13.6  动手尝试13-2：记住名字	320
13.7  使用正则表达式	321
13.7.1  创建正则表达式	321
13.7.2  使用正则表达式测试字符串	322
13.7.3  添加标志	323
13.7.4  创建强大的模式	324
13.7.5  分组表达式	327
13.7.6  replace()、match()和search()方法	328
13.7.7  更多信息	330
13.8  自测题	331
第14章  JavaScript和表单	333
14.1  访问表单	334
14.1.1  使用表单数组	334
14.1.2  使用表单名	337
14.1.3  使用id	338
14.2  使用表单对象的属性和方法	339
14.2.1  属性	339
14.2.2  方法	342
14.3  确保表单的可访问性	343
14.3.1  使用正确的元素和标签顺序	343
14.3.2  使用<label>和</label>标记	344
14.3.3  使用<fieldset></fieldset>标记	344
14.3.4  不要假设客户端会支持客户端脚本	345
14.4  验证	345
14.4.1  简单验证	346
14.4.2  技术	347
14.4.3  复选框和单选按钮	348
14.5  动手尝试14-1：请求数字	350
14.6  HTML5和表单	351
14.6.1  新元素	351
14.6.2  新输入类型	355
14.6.3  新特性	356
14.6.4  HTML5表单验证	357
14.7  动手尝试14-2：使用HTML5或JavaScript验证电话号码	358
14.8  自测题	359
第15章  高级技术简介	361
15.1　使用图像	362
15.2  动手尝试15-1：访问性更强的翻转效果	364
15.3　JavaScript和框架	365
15.3.1　框架的用法	365
15.3.2　访问框架	365
15.3.3  打破框架限制	368
15.4  调试脚本	368
15.4.1  错误类型	368
15.4.2  使用警告和控制台	371
15.4.3  使用Lint工具	372
15.4.4  浏览器开发工具	373
15.5  JavaScript和可访问性	374
15.5.1  将内容与显示分离	374
15.5.2  内容增强	376
15.6  动手尝试15-2：使该代码具有可访问性	377
15.7  JavaScript安全	378
15.7.1  安全和签名脚本	379
15.7.2  页面保护	379
15.8  AJAX和JSON	381
15.8.1  AJAX	381
15.8.2  JSON	386
15.9  自测题	390
第16章  JavaScript库、HTML5和Harmony	393
16.1  使用jQuery	394
16.1.1  获取jQuery	394
16.1.2  开始使用jQuery：document.ready()	394
16.1.3  使用选择器	395
16.1.4  修改类	396
16.1.5  用于创建特效的方法	398
16.1.6  深入阅读	400
16.2  动手尝试16-1：使用jQuery创建特效	400
16.3  其他JavaScript库	401
16.3.1  jQuery Mobile	401
16.3.2  php.js	401
16.3.3  node.js	401
16.3.4  MooTools	401
16.3.5  Three.js	401
16.4  JavaScript和HTML5	402
16.4.1  <canvas>元素	402
16.4.2  拖放	408
16.5  动手尝试16-2：拖放	411
16.6  ECMAScript Harmony	413
16.6.1  关键字const和let	413
16.6.2  默认参数值	415
16.6.3  类	416
16.6.4  关于Harmony的更多内容	417
16.7  深入阅读	417
16.8  自测题	418
附录A　自测题答案	421
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>新手学JavaScript编程(第4版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ASP.NET 4.5 高级编程（第8版）
目    录
第Ⅰ部分  ASP.NET基础
第1章  One ASP.NET	3
1.1  One ASP.NET简介	3
1.1.1  ASP.NET的演变史	4
1.1.2  Web的演化史	5
1.2  简化复杂的生态系统	6
1.2.1  Web生态系统	7
1.2.2  起步是很简单的	8
1.2.3  整合生态系统是很简单的	8
1.2.4  真实示例	10
1.3  如何从One ASP.NET中获益	13
1.3.1  ASP.NET使起步很简单	13
1.3.2  ASP.NET支持Web生态系统	13
1.3.3  ASP.NET更容易查找、添加、更新站点的各个模块	14
1.3.4  ASP.NET帮助把一个框架的概念应用于另一个框架	14
1.3.5  ASP.NET与Web的发展一样快	14
1.4  本章小结	15
第2章  使用ASP.NET进行HTML5和CSS3设计	17
2.1  警告	18
2.2  HTML5概述	18
2.2.1  HTML5中的新元素、特性和值	19
2.2.2  使用新的HTML5标记	21
2.2.3  HTML5中新的API	23
2.3  CSS3概述	24
2.3.1  创建样式表	24
2.3.2  CSS规则	27
2.3.3  CSS继承	36
2.3.4  元素的布局和定位	37
2.3.5  CSS3中的新功能	43
2.3.6  HTML和CSS的兼容	47
2.4  在Visual Studio中使用HTML和CSS	48
2.4.1  在Visual Studio中使用CSS	48
2.4.2  指定ASP.NET控件的样式	51
2.4.3  VS 2012中对HTML和CSS的改进	53
2.4.4  Page Inspector	54
2.5  本章小结	55
第3章  ASP.NET Web窗体的结构	57
3.1  应用程序的位置选项	57
3.1.1  使用文件系统(IIS Express)	58
3.1.2  使用IIS	59
3.1.3  使用FTP	60
3.2  ASP.NET页面的结构选项	61
3.2.1  内联编码	61
3.2.2  隐藏代码模型	63
3.3  ASP.NET 4.5的Page指令	65
3.3.1  Page指令	66
3.3.2  Master指令	68
3.3.3  Control指令	69
3.3.4  Import指令	69
3.3.5  Implements指令	72
3.3.6  Register指令	72
3.3.7  Assembly指令	73
3.3.8  PreviousPageType指令	73
3.3.9  MasterType指令	74
3.3.10  OutputCache指令	74
3.3.11  Reference指令	75
3.4  ASP.NET的页面事件	75
3.5  处理回送	76
3.6  跨页面传送	77
3.7  ASP.NET应用程序文件夹	80
3.7.1  App_Code文件夹	80
3.7.2  App_Data文件夹	84
3.7.3  App_GlobalResources文件夹	84
3.7.4  App_LocalResources文件夹	84
3.7.5  App_WebReferences文件夹	84
3.7.6  App_Browsers文件夹	85
3.8  编译	85
3.9  Build Provider	88
3.9.1  使用内置的Build Provider	90
3.9.2  使用自己的Build Provider	90
3.10  Global.asax	94
3.11  通过Visual Studio 2012使用类	96
3.12  本章小结	99
第Ⅱ部分  控    件
第4章  ASP.NET服务器控件和客户端脚本	103
4.1  ASP.NET服务器控件	103
4.1.1  服务器控件的类型	104
4.1.2  使用服务器控件构建页面	105
4.1.3  处理服务器控件的事件	106
4.2  给服务器控件应用样式	107
4.3  CSS在ASP.NET 4.5中的改变	109
4.4  HTML服务器控件	109
4.4.1  HtmlControl基类	110
4.4.2  HtmlContainerControl类	111
4.4.3  所有的HTML类	111
4.4.4  使用HtmlGenericControl类	113
4.5  识别ASP.NET服务器控件	114
4.6  通过JavaScript处理页面和服务器控件	116
4.6.1  使用Page.ClientScript.RegisterClientScriptBlock	117
4.6.2  使用Page.ClientScript.RegisterStartupScript	118
4.6.3  使用Page.ClientScript.RegisterClientScriptInclude	120
4.7  本章小结	120
第5章  ASP.NET Web服务器控件	121
5.1  Web服务器控件概述	121
5.2  Label服务器控件	122
5.3  Literal服务器控件	124
5.4  TextBox服务器控件	125
5.4.1  使用Focus()方法	125
5.4.2  使用AutoPostBack	126
5.4.3  使用AutoCompleteType	127
5.5  Button服务器控件	127
5.5.1  CausesValidation属性	128
5.5.2  CommandName属性	128
5.5.3  使用客户端JavaScript的按钮	129
5.6  LinkButton服务器控件	130
5.7  ImageButton服务器控件	131
5.8  HyperLink服务器控件	131
5.9  DropDownList服务器控件	132
5.10  从集合中可视化地删除数据项	134
5.11  ListBox服务器控件	135
5.11.1  允许用户选择多项	136
5.11.2  使用ListBox控件的例子	136
5.11.3  给集合添加项	137
5.12  CheckBox服务器控件	138
5.12.1  如何确定复选框是否被选中	139
5.12.2  给复选框赋值	139
5.12.3  排列复选框中的文本	140
5.13  CheckBoxList服务器控件	140
5.14  RadioButton服务器控件	142
5.15  RadioButtonList服务器控件	144
5.16  Image服务器控件	145
5.17  Table服务器控件	146
5.18  Calendar服务器控件	148
5.18.1  从Calendar控件中选择日期	149
5.18.2  从Calendar控件中选择要输出的日期格式	150
5.18.3  选择日期、星期或月份	150
5.18.4  使用日期范围	151
5.18.5  修改日历的样式和操作方式	152
5.19  AdRotator服务器控件	155
5.20  Xml服务器控件	157
5.21  Panel服务器控件	157
5.22  PlaceHolder服务器控件	159
5.23  BulletedList服务器控件	160
5.24  HiddenField服务器控件	165
5.25  FileUpload服务器控件	166
5.25.1  使用FileUpload控件上传文件	166
5.25.2  给上传文件指定正确的ASP.NET权限	168
5.25.3  理解文件的大小限制	169
5.25.4  从同一个页面上传多个文件	171
5.25.5  把上传的文件放在Stream对象中	173
5.25.6  把文件内容从Stream对象移到Byte数组中	173
5.26  MultiView和View服务器控件	174
5.27  Wizard服务器控件	177
5.27.1  定制边栏导航	178
5.27.2  AllowReturn属性	179
5.27.3  使用StepType属性	179
5.27.4  给Wizard控件添加标题	180
5.27.5  使用向导的导航系统	181
5.27.6  使用Wizard控件的事件	181
5.27.7  使用Wizard控件显示窗体元素	183
5.28  ImageMap服务器控件	186
5.29  本章小结	188
第6章  验证服务器控件	189
6.1  有效性验证	189
6.2  客户端和服务器端的验证	190
6.3  ASP.NET验证服务器控件	191
6.3.1  验证原因	192
6.3.2  ASP.NET 4.5中的隐含验证	192
6.3.3  RequiredFieldValidator服务器控件	195
6.3.4  CompareValidator服务器控件	199
6.3.5  RangeValidator服务器控件	202
6.3.6  RegularExpressionValidator服务器控件	205
6.3.7  CustomValidator服务器控件	206
6.3.8  ValidationSummary服务器控件	210
6.4  关闭客户端验证功能	213
6.5  为错误通知使用图像和声音	214
6.6  使用验证组	215
6.7  本章小结	218
第7章  用户控件和服务器控件	219
7.1  用户控件	219
7.1.1  创建用户控件	220
7.1.2  与用户控件交互	222
7.1.3  动态加载用户控件	222
7.2  服务器控件	226
7.2.1  Server Control项目	226
7.2.2  控件的特性	230
7.2.3  控件的显示	231
7.2.4  添加标记特性	234
7.2.5  关于控件ID	235
7.2.6  给HTML设置样式	236
7.2.7  添加客户端功能	238
7.2.8  浏览器功能	244
7.2.9  使用ViewState	246
7.2.10  引发回送事件	249
7.2.11  处理回送数据	251
7.2.12  复合控件	253
7.2.13  模板化控件	254
7.2.14  在设计期间创建控件	257
7.3  本章小结	268
第Ⅲ部分  数 据 访 问
第8章  数据绑定	271
8.1  数据源控件	271
8.1.1  SqlDataSource控件	273
8.1.2  AccessDataSource控件	278
8.1.3  LinqDataSource控件	278
8.1.4  EntityDataSource 控件	278
8.1.5  给复杂的过滤使用QueryExtender	280
8.1.6  XmlDataSource控件	281
8.1.7  ObjectDataSource控件	282
8.1.8  SiteMapDataSource控件	283
8.2  数据源控件的高速缓存	284
8.3  数据绑定控件	284
8.3.1  GridView控件	284
8.3.2  编辑GridView中的数据行	293
8.3.3  删除GridView数据	298
8.3.4  DetailsView控件	300
8.3.5  使用DetailsView插入、更新和删除数据	302
8.3.6  ListView控件	303
8.3.7  FormView控件	309
8.4  其他数据绑定控件	312
8.4.1  TreeView控件	312
8.4.2  Menu控件	313
8.4.3  Chart控件	313
8.5  内联数据绑定语法	316
8.5.1  数据绑定语法	317
8.5.2  XML数据绑定	318
8.6  表达式和表达式生成器	318
8.7  本章小结	321
第9章  模型绑定	323
9.1  模型绑定	323
9.1.1  选择数据	324
9.1.2  分页	324
9.1.3  过滤	325
9.1.4  使用值提供程序	325
9.1.5  插入数据	326
9.1.6  更新数据	327
9.2  使用强类型化的控件	329
9.3  扩展模型绑定	330
9.3.1  定制的值提供程序	330
9.3.2  定制的模型绑定器	331
9.3.3  定制的ModelDataSource	332
9.4  本章小结	334
第10章  使用LINQ查询	335
10.1  LINQ to Objects	336
10.1.1  传统的查询方法	336
10.1.2  使用LINQ替代传统的查询	338
10.1.3  使用LINQ分组数据	345
10.1.4  使用其他LINQ运算符	345
10.1.5  建立LINQ连接	346
10.1.6  使用LINQ分页数据	347
10.2  LINQ to XML	347
10.2.1  一个简单的LINQ to XML示例	348
10.2.2  连接XML数据	350
10.3  LINQ to SQL	351
10.3.1  使用O/R映射器	351
10.3.2  访问和查询数据	353
10.3.3  使用其他SQL查询方法	356
10.3.4  通过LINQ插入、更新和删除查询	358
10.4  LINQ to Entities	361
10.4.1  创建Entity Framework数据模型	362
10.4.2  访问数据	363
10.4.3  编写LINQ查询	363
10.5  本章小结	365
第11章  Entity Framework	367
11.1  能否使用同一种语言	368
11.1.1  开发工作流选项	369
11.1.2  实体数据模型	369
11.2  创建第一个实体数据模型	370
11.2.1  使用EDM向导	371
11.2.2  使用Entity Framework设计器	373
11.2.3  使用EDM建立ASP.NET Web页面	374
11.3  理解关系	376
11.3.1  一对一和一对多关系	376
11.3.2  多对一和多对多关系	379
11.4  在EDM中使用继承功能	381
11.5  使用EntityDataSource控件	384
11.5.1  创建基本页面	384
11.5.2  配置数据源控件	385
11.6  Entity Framework Code First	387
11.6.1  创建Code First模型	387
11.6.2  约定-配置	390
11.6.3  Code First中的关系	391
11.6.4  Code First Migrations	392
11.7  本章小结	394
第12章  ASP.NET Dynamic Data	395
12.1  Dynamic Data功能	395
12.1.1  默认应用程序中创建的核心文件	395
12.1.2  应用程序特性	396
12.1.3  运行应用程序	397
12.1.4  运行应用程序的结果	397
12.1.5  向已有页面中添加动态数据	400
12.2  理解模型绑定	401
12.2.1  特性驱动的UI	401
12.2.2  特性驱动的验证	403
12.3  本章小结	404
第13章  使用服务	405
13.1  不同系统之间的通信	405
13.2  建立一个简单的XML Web服务	407
13.2.1  WebService页面指令	408
13.2.2  Web服务的基类文件	409
13.2.3  把定制的DataSet显示为SOAP	409
13.2.4  XML Web服务接口	411
13.3  使用简单的XML Web服务	413
13.3.1  添加Web引用	413
13.3.2  在客户端应用程序中调用Web服务	415
13.4  重载WebMethod	417
13.5  高速缓存Web服务的响应	420
13.6  使用SOAP报头	421
13.6.1  使用SOAP报头建立Web服务	421
13.6.2  通过SOAP报头使用Web服务	422
13.6.3  使用SOAP 1.2请求Web服务	424
13.7  异步使用Web服务	425
13.8  WCF	427
13.8.1  WCF概述	427
13.8.2  建立WCF服务	428
13.8.3  建立WCF使用者	433
13.8.4  添加服务引用	434
13.8.5  使用数据协定	436
13.8.6  定义名称空间	440
13.8.7  使用WCF数据服务	440
13.8.8  创建第一个服务	441
13.8.9  查询接口	447
13.8.10  在ASP.NET中使用WCF数据服务	458
13.9  ASP.NET Web API	460
13.9.1  建立第一个Web API项目	461
13.9.2  理解Web API路由	464
13.9.3  使用Web API	465
13.10  本章小结	468
第Ⅳ部分  提 供 程 序
第14章  提供程序模型概述	471
14.1  提供程序概述	472
14.2  ASP.NET 4.5中的提供程序模型	473
14.2.1  设置提供程序以使用SQL Server 2005、2008或2012	474
14.2.2  成员资格提供程序	479
14.2.3  角色提供程序	483
14.2.4  个性化提供程序	486
14.2.5  站点地图提供程序	488
14.2.6  会话状态提供程序	489
14.2.7  Web事件提供程序	491
14.2.8  提供程序的配置	498
14.3  本章小结	500
第15章  扩展提供程序模型	501
15.1  提供程序是较大体系结构中的一层	501
15.2  通过基于特性的编程修改提供程序的行为	502
15.2.1  通过SqlMembership-Provider建立简单的密码结构	502
15.2.2  通过SqlMembership-Provider建立强类型的密码结构	505
15.3  ProviderBase类	506
15.4  建立自己的提供程序	508
15.4.1  创建CustomProviders应用程序	508
15.4.2  构造需要的类架构	509
15.4.3  创建XML用户数据存储	512
15.4.4  在web.config文件中定义提供程序实例	512
15.4.5  不实现MembershipProvider类的方法和属性	513
15.4.6  实现MembershipProvider类的方法和属性	514
15.4.7  使用XmlMembership-Provider进行用户登录	519
15.5  扩展预定义的提供程序	520
15.5.1  用新的LimitedSql-RoleProvider提供程序限制角色功能	521
15.5.2  使用新的LimitedSqlRoleProvider提供程序	523
15.6  本章小结	526
第Ⅴ部分  ASP.NET特性
第16章  使用母版页	529
16.1  需要母版页的原因	529
16.2  母版页的基础知识	531
16.3  编写母版页	532
16.4  编写内容页面	534
16.4.1  混合页面类型和语言	538
16.4.2  指定要使用的母版页	539
16.4.3  将母版页应用于页面子集	540
16.4.4  使用页面标题	540
16.4.5  使用母版页中的控件和属性	540
16.5  在母版页中指定默认内容	545
16.6  以编程方式将母版页赋予内容页面	547
16.7  母版页的嵌套	547
16.8  浏览器特定的母版页	551
16.9  事件的触发顺序	552
16.10  高速缓存母版页	553
16.11  ASP.NET AJAX和母版页	554
16.12  本章小结	556
第17章  站点导航	557
17.1  基于XML的站点地图	557
17.2  SiteMapPath服务器控件	559
17.2.1  PathSeparator属性	561
17.2.2  PathDirection 属性	563
17.2.3  ParentLevelsDisplayed属性	563
17.2.4  ShowToolTips属性	564
17.2.5  SiteMapPath控件的子元素	564
17.3  TreeView服务器控件	565
17.3.1  标识TreeView控件的内置样式	568
17.3.2  研究TreeView控件的各个部分	569
17.3.3  将TreeView控件绑定到XML文件	570
17.3.4  在TreeView中选择多个选项	572
17.3.5  在TreeView控件中指定定制的图标	575
17.3.6  指定用于连接节点的线	576
17.3.7  以编程方式使用TreeView控件	577
17.4  Menu服务器控件	582
17.4.1  对Menu控件应用不同的样式	583
17.4.2  Menu事件	587
17.4.3  把Menu控件绑定到XML文件	588
17.5  SiteMap数据提供程序	589
17.5.1  ShowStartingNode属性	589
17.5.2  StartFromCurrentNode属性	590
17.5.3  StartingNodeOffset属性	591
17.5.4  StartingNodeUrl属性	592
17.6  SiteMap API	592
17.7  URL映射	594
17.8  站点地图的本地化	595
17.8.1  为本地化构建Web.sitemap文件	595
17.8.2  修改web.config文件	596
17.8.3  创建程序集资源(.resx)文件	596
17.8.4  测试结果	597
17.9  安全补偿	598
17.9.1  启动管理员的角色管理功能	598
17.9.2  建立管理员的配置部分	600
17.9.3  启用安全补偿功能	601
17.10  嵌套站点地图文件	602
17.11  本章小结	604
第18章  个性化	605
18.1  个性化模型	605
18.2  创建个性化属性	606
18.2.1  添加简单的个性化属性	607
18.2.2  使用个性化属性	607
18.2.3  添加一组个性化属性	610
18.2.4  使用分组的个性化属性	611
18.2.5  为个性化属性定义类型	611
18.2.6  使用定制的类型	612
18.2.7  提供默认值	613
18.2.8  把个性化属性指定为只读	614
18.3  匿名个性化	614
18.3.1  支持终端用户的匿名身份	614
18.3.2  使用匿名身份识别事件	617
18.3.3  个性化属性的匿名选项	617
18.3.4  有关匿名用户配置信息的警告	618
18.4  编程访问个性化功能	618
18.4.1  迁移匿名用户	619
18.4.2  配置信息的个性化	619
18.4.3  确定是否继续自动保存配置信息	620
18.4.4  在Web Application Projects中使用配置信息	621
18.5  个性化提供程序	622
18.5.1  使用SQL Server Express Edition	622
18.5.2  使用SQL Server	623
18.5.3  使用多个提供程序	625
18.5.4  使用通用提供程序	626
18.6  管理应用程序的配置信息	626
18.6.1  ProfileManager类的属性	627
18.6.2  ProfileManager类的方法	627
18.6.3  建立配置信息管理页面	628
18.6.4  研究配置信息管理页面的代码	630
18.6.5  运行配置信息管理页面	631
18.7  本章小结	631
第19章  成员资格和角色管理	633
19.1  ASP.NET 4.5的身份验证	634
19.1.1  为成员资格建立Web站点	634
19.1.2  添加用户	637
19.1.3  请求凭据	649
19.1.4  处理验证用户	655
19.1.5  显示在线用户数	657
19.1.6  处理密码	658
19.2  ASP.NET 4.5的授权	662
19.2.1  使用LoginView服务器控件	662
19.2.2  为角色管理建立Web站点	664
19.2.3  添加和检索应用程序角色	667
19.2.4  删除角色	669
19.2.5  给角色添加用户	669
19.2.6  获取某个角色的所有用户	670
19.2.7  获取包含某个用户的所有角色	671
19.2.8  从角色中删除用户	672
19.2.9  检查角色中的用户	672
19.2.10  角色的高速缓存方式	673
19.3  使用SimpleMembership API	674
19.4  使用Web Site Administration Tool	675
19.5  Membership API的公有方法	675
19.6  Roles API的公有方法	676
19.7  集成OAuth和OpenID身份验证	677
19.7.1  使用OpenID	677
19.7.2	使用OAuth	681
19.8  本章小结	685
第20章  安全性	687
20.1  应用身份验证措施	688
20.1.1  <authentication>节点	688
20.1.2  基于Windows的身份验证	689
20.1.3  基于表单的身份验证	696
20.2  验证特定的文件和文件夹	703
20.3  以编程方式授权	704
20.3.1  使用User.Identity属性	705
20.3.2  使用IsInRole方法	706
20.3.3  使用WindowsIdentity显示更多信息	706
20.4  身份和模拟	708
20.5  通过IIS进行保护	710
20.5.1  使用文件扩展名	710
20.5.2  使用IIS 7.x/8 Manager	712
20.5.3  使用ASP.NET MMC
管理单元	713
20.6  本章小结	714
第Ⅵ部分  应用程序状态
第21章  状态管理	717
21.1  如何选择会话状态	717
21.2  理解ASP.NET中的Session对象	719
21.2.1  会话和事件模型	720
21.2.2  配置会话状态的管理	721
21.2.3  进程中的会话状态	721
21.2.4  进程外的会话状态	727
21.2.5  SQL支持的会话状态	732
21.2.6  使用其他提供程序扩展会话状态	734
21.2.7  无cookie的会话状态	735
21.2.8  选择维护状态的正确方式	736
21.3  Application对象	737
21.4  查询字符串	737
21.5  cookie	738
21.6  回送和跨页面回送	738
21.7  隐藏字段、ViewState和ControlState	740
21.8  为短时间状态存储应用HttpContext.Current.Items	743
21.9  本章小结	744
第22章  高速缓存	745
22.1  高速缓存	745
22.1.1  输出高速缓存	746
22.1.2  部分页面(UserControl)的高速缓存	749
22.1.3  Post-Cache Substitution	750
22.1.4  HttpCachePolicy和客户端高速缓存	752
22.2  使用编程方式进行高速缓存	753
22.2.1  使用Cache对象高速缓存数据	754
22.2.2  控制ASP.NET高速缓存	754
22.2.3  高速缓存依赖性	755
22.2.4  .NET 4.x中新的对象高速缓存选项	758
22.3  使用SQL Server高速缓存依赖性	761
22.3.1  使数据库支持SQL Server高速缓存禁用功能	762
22.3.2  使表支持SQL Server高速缓存禁用功能	762
22.3.3  对SQL Server的影响	763
22.3.4  查看支持SQL Server高速缓存禁用功能的表	764
22.3.5  使表不支持SQL Server高速缓存禁用功能	764
22.3.6  使数据库不支持SQL Server高速缓存禁用功能	764
22.3.7  SQL Server高速缓存禁用功能	765
22.4  配置ASP.NET应用程序	766
22.5  测试SQL Server高速缓存禁用功能	767
22.5.1  给页面添加多个表	769
22.5.2  给SQL Server高速缓存依赖性和Request对象建立关联	770
22.5.3  给SQL Server高速缓存依赖性和Cache对象
建立关联	770
22.6  本章小结	773
第Ⅶ部分  客户端开发
第23章  ASP.NET AJAX	777
23.1  理解对AJAX的需求	777
23.1.1  AJAX出现之前的请求/响应过程	777
23.1.2  AJAX改变了请求/响应过程	778
23.2  ASP.NET AJAX和Visual Studio 2012	780
23.2.1  客户端技术	781
23.2.2  服务器端技术	781
23.2.3  使用ASP.NET AJAX进行开发	782
23.3  创建ASP.NET AJAX应用程序	782
23.3.1  建立没有使用AJAX的简单ASP.NET页面	784
23.3.2  建立使用AJAX的简单ASP.NET页面	785
23.4  ASP.NET AJAX的服务器控件	790
23.4.1  ScriptManager控件	791
23.4.2  ScriptManagerProxy控件	793
23.4.3  Timer控件	794
23.4.4  UpdatePanel控件	795
23.4.5  UpdateProgress控件	799
23.5  使用多个UpdatePanel控件	801
23.6  使用页面历史记录	804
23.7  脚本合并	809
23.8  本章小结	813
第24章  AJAX控件工具集	815
24.1  下载和安装AJAX控件
工具集	816
24.2  ASP.NET AJAX控件	818
24.2.1  AJAX控件工具集的扩展程序	819
24.2.2  AJAX控件工具集中的服务器控件	863
24.3  本章小结	873
第25章  jQuery	875
25.1  jQuery简介	876
25.2  选择元素	880
25.3  修改元素	882
25.3.1  修改内容	882
25.3.2  添加和删除元素	884
25.4  事件处理	886
25.5  AJAX	888
25.6  jQuery UI	895
25.7  本章小结	898
第26章  实时通信	899
26.1  传统的实时通信选项	899
26.1.1  使用Comet	900
26.1.2  Polling	901
26.1.3  服务器发送的事件	901
26.1.4  现有方法的缺点	901
26.2  HTML5 WebSockets	902
26.2.1  WebSockets的概念	902
26.2.2  TCP/IP	903
26.2.3  TCP/HTTP	903
26.2.4  WebSockets协议简介	904
26.2.5  WebSockets数据传输	905
26.2.6  WebSockets API	906
26.2.7  ASP.NET 4.5中的WebSockets	907
26.2.8  使用WebSockets的优点	910
26.3  SignalR	911
26.3.1  什么是SignalR?	911
26.3.2  ASP.NET中的服务器端SignalR	912
26.3.3  ASP.NET中的客户端SignalR	913
26.4  本章小结	914
第27章  开发移动网站	915
27.1  移动Web设计的挑战	916
27.2  响应式设计和适应式设计	916
27.2.1  修改视口	917
27.2.2  使用CSS媒介查询	918
27.3  ASP.NET移动应用程序	920
27.3.1  检测移动浏览器和设备	921
27.3.2  处理移动母版页	921
27.3.3  创建移动Web窗体	923
27.3.4  ASP.NET Web窗体中的FriendlyURLs	924
27.4  ASP.NET MVC 4 移动应用程序	925
27.4.1  ASP.NET MVC 4中的适应式显示功能	925
27.4.2  创建移动专用的视图	928
27.4.3  提供显示模式	929
27.4.4  包含jQuery Mobile和ViewSwitcher	931
27.4.5  使用Mobile Application项目模板	934
27.5  测试移动应用程序	934
27.6  本章小结	935
第Ⅷ部分  应用程序的配置与开发
第28章  配置	939
28.1  配置概述	939
28.1.1  服务器配置文件	940
28.1.2  应用程序配置文件	943
28.1.3  应用配置设置	943
28.1.4  检测配置文件发生的改动	944
28.1.5  配置文件的格式	944
28.2  公共配置设置	945
28.2.1  连接字符串	945
28.2.2  配置会话状态	946
28.2.3  编译配置	950
28.2.4  定制错误	952
28.2.5  身份验证	952
28.2.6  匿名身份	955
28.2.7  授权	956
28.2.8  锁定配置设置	958
28.2.9  ASP.NET页面配置	958
28.2.10  包含文件	960
28.2.11  配置ASP.NET运行时设置	961
28.2.12  配置ASP.NET工作者进程	963
28.2.13  存储与应用程序相关的设置	966
28.2.14  对配置文件编程	966
28.2.15  保护配置设置	970
28.2.16  编辑配置文件	973
28.3  创建定制部分	975
28.3.1  使用NameValueFile-SectionHandler对象	975
28.3.2  使用Dictionary-SectionHandler对象	976
28.3.3  使用SingleTag-SectionHandler对象	977
28.3.4  使用定制的配置处理程序	977
28.4  使用配置转换	979
28.4.1  添加web.config 转换	979
28.4.2  更新配置转换文件	981
28.5  打包和压缩功能	983
28.5.1  什么是打包和压缩功能	983
28.5.2  启用打包和压缩功能	984
28.6  本章小结	985
第29章  调试和错误处理技术	987
29.1  设计期间的支持	987
29.1.1  语法通知	988
29.1.2  Immediate和Command窗口	989
29.1.3  任务列表	989
29.2  跟踪	990
29.2.1  System.Diagnostics.Trace和ASP.NET的Page.Trace	990
29.2.2  页面级的跟踪	991
29.2.3  应用程序的跟踪	991
29.2.4  查看跟踪数据	991
29.2.5  在组件中跟踪	994
29.2.6  跟踪的传送	995
29.2.7  TraceListener	995
29.2.8  诊断选项	999
29.2.9  Web事件	1000
29.3  调试	1001
29.3.1  需要的内容	1002
29.3.2  启动调试会话	1003
29.3.3  有助于调试的工具	1004
29.3.4  使用IntelliTrace执行历史调试	1007
29.3.5  调试多个线程	1008
29.3.6  客户端的JavaScript调试	1008
29.3.7  SQL存储过程的调试	1009
29.4  异常和错误处理	1010
29.4.1  处理页面上的异常	1010
29.4.2  处理应用程序异常	1011
29.4.3  HTTP状态码	1011
29.5  用Page Inspector进行调试	1012
29.6  本章小结	1015
第30章  模块和处理程序	1017
30.1  处理HTTP请求	1017
30.1.1  IIS 6和ASP.NET	1017
30.1.2  IIS 7、IIS 8和
ASP.NET	1018
30.1.3  ASP.NET请求处理	1019
30.2  HttpModule	1019
30.3  HttpHandler	1024
30.3.1  一般的处理程序	1024
30.3.2  在IIS中映射文件扩展名	1028
30.4  本章小结	1029
第31章  异步通信	1031
31.1  异步编程	1031
31.1.1  使用异步方式的原因	1031
31.1.2  编写异步代码的场合	1032
31.1.3  异步简史	1032
31.2  ASP.NET中的异步	1034
31.2.1  线程池	1035
31.2.2  编写异步代码	1036
31.2.3  并行	1039
31.2.4  服务器配置	1040
31.2.5  使用异步模式的缺点	1040
31.3  本章小结	1041
第32章  国际化应用程序的建立	1043
32.1  区域性和地区	1043
32.1.1  了解区域性类型	1044
32.1.2  ASP.NET线程	1045
32.1.3  服务器端的区域性声明	1046
32.1.4  客户端的区域性声明	1048
32.1.5  翻译值和行为	1049
32.2  ASP.NET 4.5资源文件	1056
32.2.1  使用本地资源	1056
32.2.2  使用全局资源	1061
32.3  本章小结	1064
第33章  打包和部署ASP.NET应用程序	1065
33.1  部署各个部分	1066
33.2  部署之前的准备步骤	1066
33.3  部署Web应用程序的方法	1067
33.3.1  使用XCopy	1067
33.3.2  使用Copy Web Site选项	1069
33.3.3  部署预编译的Web应用程序	1072
33.3.4  创建ASP.NET Web Package	1073
33.3.5	发布配置文件详解	1076
33.4  部署Windows Azure Web Sites	1082
33.5  本章小结	1084
第Ⅸ部分  其他ASP.NET技术
第34章  ASP.NET MVC	1087
34.1  MVC的定义	1087
34.2  当今Web上的MVC	1088
34.3  MVC和ASP.NET	1089
34.3.1  为方法而不是文件服务	1089
34.3.2  ASP.NET MVC是Web Forms 4.5？	1089
34.3.3  为什么不是Web窗体	1090
34.3.4  ASP.NET MVC是完全不同的	1090
34.3.5  为什么“(ASP.NET>ASP.NET MVC)==True”	1090
34.3.6  约定胜于配置	1092
34.3.7  第三个请求是Charm	1095
34.4  理解路由和URL	1097
34.4.1  路由选择与URL重写的比较	1097
34.4.2  路由的定义	1098
34.5  控制器	1103
34.5.1  控制器的定义：
IController接口	1103
34.5.2  控制器类和操作	1104
34.5.3  处理参数	1105
34.5.4  处理多个参数	1106
34.6  视图	1106
34.6.1  指定视图	1108
34.6.2	ASP.NET MVC布局	1109
34.6.3  强类型化视图	1112
34.6.4  使用HTML辅助方法	1113
34.6.5  HtmlHelper类和扩展方法	1113
34.7  本章小结	1114
第35章  ASP.NET Web Pages和Razor	1115
35.1  ASP.NET Web Pages概述	1116
35.2  使用Razor创建HTML窗体	1116
35.3  显示数据	1120
35.3.1  验证	1123
35.3.2  使用布局	1125
35.4  使用辅助方法	1127
35.4.1  核心辅助方法	1127
35.4.2  使用辅助方法添加功能	1130
35.4.3  创建定制的辅助方法	1132
35.5  本章小结	1133
附录A  迁移ASP.NET旧项目	1137
附录B  COM集成	1145
附录C  ASP.NET终极工具	1155
附录D  管理	1165
附录E  动态类型与语言	1189
附录F  ASP.NET联机资源	1197
附录G  使用NuGet扩展Visual Studio	1201
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ASP.NET 4.5 高级编程（第8版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Android 4.X开发完全上手—— 手把手构建完整Android App范例\
目    录
第1章  Android开发简介	1
1.1  了解Android的优势	1
1.2  构建本地应用程序	2
1.3  Android的历史	2
1.4  Android用户界面	7
1.5  Android应用程序	8
1.6  Google Play简介	8
1.7  小结	10
第2章  搭建开发环境	11
2.1  在Windows上安装Java JDK和JRE	11
2.2  在Windows上安装Eclipse集成开发环境	13
2.2.1  安装Eclipse	13
2.2.2  在Eclipse中配置Java JRE	14
2.2.3  熟悉Eclipse	14
2.3  在Windows上安装Android SDK	16
2.4  Mac系统上安装和使用Java	19
2.4.1  在Mac电脑上下载并安装JDK	20
2.4.2  在Mac上下载并安装Eclipse IDE	20
2.4.3  在Mac上下载并安装Android SDK	20
2.4.4  在Mac上安装Android Developer Tools插件	21
2.5  小结	22
第3章  创建第一个Android应用程序	23
3.1  创建Android应用程序	23
3.2  运行Android项目	25
3.2.1  创建Android虚拟设备	25
3.2.2  在AVD中运行应用程序	26
3.2.3  使用Android虚拟设备的最佳实践	28
3.2.4  在实际设备上安装Android应用程序	28
3.3  在Android项目中使用Lint	29
3.4  Android项目文件	29
3.4.1  XML布局文件	29
3.4.2  XML资源文件	31
3.4.3  XML文件中的ID属性及其在生成的文件中的作用	32
3.4.4  Activity文件	33
3.4.5  Activity的生命周期	35
3.4.6  访问Activity中的TextView	35
3.4.7  应用程序日志	37
3.4.8  Android清单文件	39
3.5  小结	40
第4章  创建Android用户界面	41
4.1  重构代码	41
4.2  实施Strict模式	43
4.3  创建一个简单的用户界面	44
4.3.1  线性布局的用法	45
4.3.2  创建按钮事件处理程序	48
4.3.3  更新计时器显示	51
4.3.4  显示正在运行的计时器	53
4.4  Activity生命周期	55
4.4.1  Android Activity生命周期	57
4.4.2  修复Activity生命周期问题	59
4.5  实现Android设备的振动	59
4.6  保存用户首选项	61
4.6.1  创建新的Activity	61
4.6.2  显示新的Activity	62
4.6.3  保存应用程序的状态	63
4.6.4  使用Shared Preferences	65
4.7  小结	67
第5章  提高Android应用程序可用性	69
5.1  重构代码	69
5.2  改善Setting Activity	75
5.2.1  显示Toast弹出窗口	75
5.2.2  使用后退按钮从Settings Activity返回	78
5.3  操作栏和菜单	80
5.3.1  创建菜单	80
5.3.2  创建一个操作栏	82
5.3.3  返回Home画面	84
5.4  使用通知	86
5.4.1  创建通知	86
5.4.2  显示或替换一个新的通知	89
5.4.3  定期显示通知	89
5.5  创建数据库	92
5.5.1  创建数据模型	93
5.5.2  创建数据库及其表	93
5.5.3  检查表的创建	96
5.5.4  创建表间的关系	97
5.5.5  创建路线列表视图	101
5.6  小结	106
第6章  自定义Android应用程序	107
6.1  重构应用程序	107
6.2  了解屏幕的差异	108
6.2.1  屏幕尺寸和屏幕密度	108
6.2.2  了解设备	109
6.3  使应用程序与分辨率无关	110
6.4  使用配置限定符	112
6.4.1  创建启动图标	114
6.4.2  创建通知图标	115
6.4.3  让应用程序适合不同的屏幕尺寸	116
6.4.4  使用资源尺寸	118
6.4.5  在Java代码中改变文字的大小	120
6.4.6  修改横屏模式的布局	122
6.4.7  修改平板电脑的布局	123
6.4.8  创建并排的视图	124
6.5  使用样式和主题	126
6.5.1  启用夜间模式	128
6.5.2  切换主题	130
6.5.3  检测亮度级别	134
6.5.4  处理不稳定的传感器值	136
6.6  小结	138
第7章  使应用程序支持位置感知	139
7.1  重构代码	139
7.2  定位设备的位置	143
7.2.1  在虚拟设备中测试GPS	148
7.2.2  GPS定位的精度	149
7.2.3  提高GPS定位的用户体验	150
7.2.4  显示Google Maps	153
7.3  处理不精确的位置数据	161
7.4  保存GPS数据	167
7.4.1  插入、更新和删除数据	167
7.4.2  更新模型	170
7.4.3  在应用程序中使用数据库	176
7.5  显示GPS数据	179
7.5.1  使用ListActivity	179
7.5.2  在Google地图中显示GPS数据	184
7.6  小结	189
第8章  集成社交网络	191
8.1  重构代码	191
8.2  将照片整合到Android应用程序中	191
8.2.1  拍照	192
8.2.2  检查是否可以拍照	194
8.2.3  在应用程序中显示相片	198
8.2.4  获得Activity的结果	203
8.3  与朋友分享内容	207
8.3.1  显示选择器	207
8.3.2  分享文本和图片	210
8.4  小结	212
第9章  优化性能、内存和电源管理	213
9.1  重构代码	213
9.2  让应用程序以服务形式运行	213
9.2.1  处理方向改变	214
9.2.2  创建服务	217
9.3  延长电池寿命	229
9.3.1  确定用电量	230
9.3.2  根据电量水平进行响应	231
9.3.3  定期检查电池	237
9.4  加快数据库运行速度	239
9.4.1  通过索引加速数据库	239
9.4.2  使用异步方式加速数据库	241
9.5  小结	244
第10章  测试应用程序	247
10.1  重构代码	247
10.2  使用JUnit进行测试	247
10.2.1  创建一个新的测试应用程序	248
10.2.2  提高测试覆盖率	253
10.2.3  加快测试速度	254
10.2.4  通过重构使测试更容易	258
10.3  使用Android JUnit 扩展来测试	259
10.3.1  测试Android Activity	260
10.3.2  创建Mock应用程序	263
10.3.3  测试Activity生命周期	265
10.3.4  进一步测试Activity	267
10.3.5  通过与UI的交互来测试	269
10.4  测试服务	270
10.5  使用Monkey测试	272
10.6  自动运行测试	275
10.6.1  从命令行运行测试	275
10.6.2  安装Jenkins	277
10.6.3  使用Git版本控制	278
10.6.4  Git Bash命令概述	280
10.6.5  使用Jenkins	280
10.7  在多种设备上测试	281
10.8  小结	283
第11章  针对不同设备和国家进行优化	285
11.1  重构代码	285
11.2  国际化	287
11.2.1  支持多语言	287
11.2.2  从简单的机器翻译开始	288
11.2.3  在用户的帮助下改善翻译结果	292
11.2.4  添加更多语言版本	294
11.3  适应各种方言	298
11.3.1  添加区域码	298
11.3.2  处理单词的变化：Route、Path、Trail和Track	299
11.4  处理各种语言格式	300
11.4.1  支持从右至左布局	300
11.4.2  处理日期、数字和货币的变体	301
11.5  支持向后兼容	303
11.5.1  使用Android支持库	303
11.5.2  Android版本检查	303
11.6  为各种屏幕尺寸进行构建	306
11.7  使用Fragment	309
11.8  小结	314
第12章  使用Google Play和Amazon Appstore来销售应用程序	317
12.1  建立媒体策略	317
12.1.1  使用Google Play	317
12.1.2  使用服务和API实现Google许可	321
12.2  在应用程序中使用广告	322
12.3  使用Amazon Appstore	325
12.4  小结	327
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Android 4.X开发完全上手—— 手把手构建完整Android App范例\
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ESI PMP考试全真模拟试题集(第4版)
一 项目整体管理
二 项目范围管理
三 项目时间管理
四 项目成本管理
五 项目质量管理
六 项目人力资源管理
七 项目沟通管理
八 项目风险管理
九 项目采购管理
十 专业职责
十一 模拟测试
附录 学习矩阵
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ESI PMP考试全真模拟试题集(第4版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>HTML 4.0从入门到精通
第一部分  基础知识
第1章  了解HTML. 相关工具和Web
Internet上的发表
发表到Intranet上
开发帮助文件
开发kiosk应用程序
开发基于网络的应

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>HTML 4.0从入门到精通
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>魔鬼经济学合集（共4册）
《魔鬼经济学1》
揭示隐藏在表象之下的真实世界
本书的由来
前 言 万事万物的隐秘一面
第一章 教师与相扑力士有何共同点？
第二章 为何三K党和房地产中介是一路货色？
第三章 为何毒贩还在与母亲同住？
第四章 罪犯都去哪儿了？
第五章 怎样才算完美父母？
第六章 完美父母续章
《魔鬼经济学2》
拥有清晰思维的艺术
推荐序 趣味横生的魔鬼经济学 // 比尔·盖茨
写在前面
导 言 魔鬼经济学=荒谬怪诞经济学？
第一章 遏制气候变暖：火山爆发，用烟囱捅破天，还是架一根18英里长的管子？
第二章 恐怖分子的银行账户有什么特点？
第三章 难以置信：犯罪率升高是因为电视看多了？
第四章 疫苗、安全带和飓风：不一样的事情，一样的逻辑
第五章 街头妓女与百货商店圣诞老人有何相似之处？
结 语
致 谢
《魔鬼经济学3》
用反常思维解决问题
第一章 什么是“魔鬼式思考”？
第二章 承认自己不知道
第三章 你的问题是什么？
第四章 真相在问题的根源
第五章 像孩子一样思考
第六章 爱吃糖的孩子
第七章 所罗门王和大卫· 李·罗斯有什么共同点？
第八章 如何说服不想被说服的人？
第九章 放弃的好处
致谢
《魔鬼经济学4》
用“有色眼镜”看清世界
引言 博客与瓶装水有何共同点？
第一章 我们只是想帮忙
第二章 手淫者林伯翰与灾星韦恩
第三章 高油价万岁！
第四章 竞猜
第五章 如何杞人忧天
第六章 没有作弊，就意味着没有努力
第七章 但这是否有益于地球？
第八章 痛失21点
第九章 何日宜抢银行
第十章 性事宜多谈，我们可是经济学家
第十一章 万花筒
第十二章 一日火箭……
致谢
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>魔鬼经济学合集（共4册）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>利瑪竇全集（第4卷）
1599年 241
1602年 261
1605年 263
1606年 319
1607年 327
1608年 353
1609年 407
附錄：與「天主教傳入中國史」及利氏書信有密切關係而為曾出版過的文獻
1578年 423
1580年 425
1581年 429
1582年 439
1583年 445
1584年 455
1585年 475
1586年 491
1587年 495
1589年 497
1591年 499
1592年 505
1598年 513
1604年 527
1610年 535
1590年 549
1601年 551
1617年 555
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>利瑪竇全集（第4卷）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>J2EE 1.4基础教程
第I部分  J2EE 1. 4与企业Web服务导论
第1章  J2EE概述
1. 1  在J2EE中以企业作为目标
1. 1. 1  定义企业
1. 1. 2  企业应用开发的考验与困难
1. 2  J2EE

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>J2EE 1.4基础教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>科学同步练习(4上升级版)(J)/义教课程标准实验教材
天气  1．我们关心天气  2．天气日历  3．温度与气温  4．风向和风速  5．降水量的测  6．云的观测  7．总结我们的天气观察溶解  1．水能溶解一些物质  2．物质在水中是怎样溶解的    3．液体之间的溶解现象  4．不同物质在水中的溶解能力    5．溶解的快与慢  6．100毫升水能溶解多少克食盐  7．分离食盐与水的方法声音  1．听听声音  2．声音是怎样产生的  3．声音的变化  4．探索尺子的音高变化  5．声音的传播  6．我们是怎样听到声音的  7．保护我们的听力我们的身体  1．身体的结构  2．骨骼、关节和肌肉  3．运动起来会怎样(一)  4．运动起来会怎样(二)  5．食物在体内的旅行  6．食物在口腔里的变化  7．相互协作的人体器官
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>科学同步练习(4上升级版)(J)/义教课程标准实验教材
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>笑傲股市（原书第4版·典藏版）
目录
推荐语
译者序
｜第一部分｜
股海淘金的CAN SLIM法则
引言　百年以来美国股市超级牛股的有益启示 / 2
第1章　最重要的选股秘诀 / 9
第2章　学会识图以提高选股和选时能力 / 110
第3章　C=可观或者加速增长的当季每股收益和每股销售收入 / 161
第4章　A=年度收益增长率：寻找收益大牛 / 171
第5章　N=新公司、新产品、新管理层、股价新高 / 182
第6章　S=供给与需求：关键点上的大量需求 / 193
第7章　L=领军股或拖油瓶：孰优孰劣 / 200
第8章　I=机构认同度 / 209
第9章　M=判断市场走势 / 217
｜第二部分｜
赢在起跑处
第10章　抛售止损策略 / 262
第11章　卖出获利策略 / 281
第12章　资产配置策略问题 / 304
第13章　投资者常犯的21个错误 / 338
｜第三部分｜
像专家一样投资
第14章　解读更多典型的牛股 / 346
第15章　强势行业孕育超级牛股 / 362
第16章　如何运用《投资者商业日报》寻找潜在的牛股 / 382
第17章　紧跟大盘采取行动 / 431
第18章　投资共同基金成为百万富翁 / 446
第19章　熟悉专业机构的投资管理 / 459
第20章　谨记重要的投资法则 / 485
投资领域的成功范例 / 490
译者简介 / 508
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>笑傲股市（原书第4版·典藏版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数学启蒙阶段4（全8册）
猜猜谁会赢：估算
随着书中两位好朋友猜猜，公车上有几位乘客？货架上的商品总共多少钱？糖果罐里总共有多少颗软糖？你一定也学会了估算，而且乐在其中！
宇宙无敌舰长：立体
在惊险万分的星际冒险中，宇宙无敌舰长必须使用立体几何图形来帮助他安全返回地球。
游乐嘉年华：除法
在游乐嘉年华中，11位好朋友搭乘云霄飞车一路尖叫而下，在旋转咖啡杯里转得晕头转向。一起来跟他们轻松愉快地学习除法的初步概念，就能知道如何又快又好地补满座位。
柠檬汁大拍卖：条形统计图
学习正确制作好喝的柠檬汁和有趣的条形图，跟着几位孩子和他们的宠物鹦鹉，一起经营别开生面的柠檬汁摊位，并追踪记录他们的销售量。
小胡椒日记：月历
和一只刚出生的小猫一起生活，会有意想不到的惊奇，丽莎完整记录了小猫充满趣味的一年日记，小朋友可以学习有关日历的日、周（星期）、月和年这些时间概念。
地球日，万岁：位值
瑞安、凯莉和卢克需要回收5000个空铝罐，才能有足够的钱在吉尔罗伊公园种花。小朋友可以通过地球日故事中的计数活动，学习有关资源回收的知识和数学的位值概念。
艾迪来猜龄：大于或小于
艾迪在学校游园会设立一个摊位，来猜人们的年龄，如果他猜错了，就要下水。只要比较所有的数字，了解比什么大，比什么小，就不会变成落汤鸡。
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数学启蒙阶段4（全8册）
