>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 8实战
第一部分 基础知识
第1章　为什么要关心Java 8　　2
1.1　Java怎么还在变　　4
1.1.1　Java在编程语言生态系统中的位置　　4
1.1.2　流处理　　6
1.1.3　用行为参数化把代码传递给方法　　7
1.1.4　并行与共享的可变数据　　7
1.1.5　Java需要演变　　8
1.2　Java中的函数　　8
1.2.1　方法和Lambda作为一等公民　　9
1.2.2　传递代码：一个例子　　11
1.2.3　从传递方法到Lambda　　12
1.3　流　　13
1.4　默认方法　　17
1.5　来自函数式编程的其他好思想　　18
1.6　小结　　19
第2章　通过行为参数化传递代码　　20
2.1　应对不断变化的需求　　21
2.1.1　初试牛刀：筛选绿苹果　　21
2.1.2　再展身手：把颜色作为参数　　21
2.1.3　第三次尝试：对你能想到的每个属性做筛选　　22
2.2　行为参数化　　23
2.3　对付啰嗦　　27
2.3.1　匿名类　　28
2.3.2　第五次尝试：使用匿名类　　28
2.3.3　第六次尝试：使用Lambda表达式　　30
2.3.4　第七次尝试：将List类型抽象化　　31
2.4　真实的例子　　31
2.4.1　用Comparator来排序　　31
2.4.2　用Runnable执行代码块　　32
2.4.3　GUI事件处理　　32
2.5　小结　　33
第3章　Lambda表达式　　34
3.1　Lambda管中窥豹　　35
3.2　在哪里以及如何使用Lambda　　37
3.2.1　函数式接口　　37
3.2.2　函数描述符　　39
3.3　把Lambda付诸实践：环绕执行模式　　41
3.3.1　第1步记得行为参数化　　41
3.3.2　第2步：使用函数式接口来传递行为　　42
3.3.3　第3步：执行一个行为　　42
3.3.4　第4步：传递Lambda　　42
3.4　使用函数式接口　　43
3.4.1　Predicate　　44
3.4.2　Consumer　　44
3.4.3　Function　　45
3.5　类型检查、类型推断以及限制　　49
3.5.1　类型检查　　49
3.5.2　同样的Lambda，不同的函数式接口　　50
3.5.3　类型推断　　51
3.5.4　使用局部变量　　52
3.6　方法引用　　53
3.6.1　管中窥豹　　53
3.6.2　构造函数引用　　55
3.7　Lambda和方法引用实战　　57
3.7.1　第1步：传递代码　　58
3.7.2　第2步：使用匿名类　　58
3.7.3　第3步：使用Lambda表达式　　58
3.7.4　第4步：使用方法引用　　59
3.8　复合Lambda表达式的有用方法　　59
3.8.1　比较器复合　　60
3.8.2　谓词复合　　60
3.8.3　函数复合　　61
3.9　数学中的类似思想　　62
3.9.1　积分　　62
3.9.2　与Java 8的Lambda联系起来　　63
3.10　小结　　64
第二部分 函数式数据处理
第4章　引入流　　68
4.1　流是什么　　68
4.2　流简介　　72
4.3　流与集合　　74
4.3.1　只能遍历一次　　75
4.3.2　外部迭代与内部迭代　　76
4.4　流操作　　78
4.4.1　中间操作　　78
4.4.2　终端操作　　79
4.4.3　使用流　　80
4.5　小结　　81
第5章　使用流　　82
5.1　筛选和切片　　83
5.1.1　用谓词筛选　　83
5.1.2　筛选各异的元素　　83
5.1.3　截短流　　84
5.1.4　跳过元素　　85
5.2　映射　　86
5.2.1　对流中每一个元素应用函数　　86
5.2.2　流的扁平化　　87
5.3　查找和匹配　　90
5.3.1　检查谓词是否至少匹配一个元素　　90
5.3.2　检查谓词是否匹配所有元素　　90
5.3.3　查找元素　　91
5.3.4　查找第一个元素　　92
5.4　归约　　92
5.4.1　元素求和　　93
5.4.2　最大值和最小值　　94
5.5　付诸实践　　97
5.5.1　领域：交易员和交易　　98
5.5.2　解答　　99
5.6　数值流　　101
5.6.1　原始类型流特化　　101
5.6.2　数值范围　　102
5.6.3　数值流应用：勾股数　　103
5.7　构建流　　105
5.7.1　由值创建流　　106
5.7.2　由数组创建流　　106
5.7.3　由文件生成流　　106
5.7.4　由函数生成流：创建无限流　　107
5.8　小结　　110
第6章　用流收集数据　　111
6.1　收集器简介　　112
6.1.1　收集器用作高级归约　　112
6.1.2　预定义收集器　　113
6.2　归约和汇总　　114
6.2.1　查找流中的最大值和最小值　　114
6.2.2　汇总　　115
6.2.3　连接字符串　　116
6.2.4　广义的归约汇总　　117
6.3　分组　　120
6.3.1　多级分组　　121
6.3.2　按子组收集数据　　122
6.4　分区　　126
6.4.1　分区的优势　　126
6.4.2　将数字按质数和非质数分区　　128
6.5　收集器接口　　129
6.5.1　理解Collector接口声明的方法　　130
6.5.2　全部融合到一起　　134
6.6　开发你自己的收集器以获得更好的性能　　135
6.6.1　仅用质数做除数　　136
6.6.2　比较收集器的性能　　139
6.7　小结　　140
第7章　并行数据处理与性能　　141
7.1　并行流　　141
7.1.1　将顺序流转换为并行流　　142
7.1.2　测量流性能　　144
7.1.3　正确使用并行流　　147
7.1.4　高效使用并行流　　148
7.2　分支/合并框架　　149
7.2.1　使用RecursiveTask　　149
7.2.2　使用分支/合并框架的最佳做法　　153
7.2.3　工作窃取　　154
7.3　Spliterator　　155
7.3.1　拆分过程　　155
7.3.2　实现你自己的Spliterator　　157
7.4　小结　　162
第三部分 高效Java 8编程
第8章　重构、测试和调试　　164
8.1　为改善可读性和灵活性重构代码　　164
8.1.1　改善代码的可读性　　165
8.1.2　从匿名类到Lambda表达式的转换　　165
8.1.3　从Lambda表达式到方法引用的转换　　166
8.1.4　从命令式的数据处理切换到Stream　　167
8.1.5　增加代码的灵活性　　168
8.2　使用Lambda重构面向对象的设计模式　　170
8.2.1　策略模式　　171
8.2.2　模板方法　　172
8.2.3　观察者模式　　173
8.2.4　责任链模式　　175
8.2.5　工厂模式　　177
8.3　测试Lambda表达式　　178
8.3.1　测试可见Lambda函数的行为　　179
8.3.2　测试使用Lambda的方法的行为　　179
8.3.3　将复杂的Lambda表达式分到不同的方法　　180
8.3.4　高阶函数的测试　　180
8.4　调试　　181
8.4.1　查看栈跟踪　　181
8.4.2　使用日志调试　　183
8.5　小结　　184
第9章　默认方法　　 185
9.1　不断演进的API　　 187
9.1.1　初始版本的API　　188
9.1.2　第二版API　　188
9.2　概述默认方法　　190
9.3　默认方法的使用模式　　192
9.3.1　可选方法　　192
9.3.2　行为的多继承　　192
9.4　解决冲突的规则　　196
9.4.1　解决问题的三条规则　　196
9.4.2　选择提供了最具体实现的默认方法的接口　　197
9.4.3　冲突及如何显式地消除歧义　　198
9.4.4　菱形继承问题　　200
9.5　小结　　201
第10章　用Optional取代null　　202
10.1　如何为缺失的值建模　　 203
10.1.1　采用防御式检查减少Null-PointerException　　203
10.1.2　null带来的种种问题　　204
10.1.3　其他语言中null的替代品　　205
10.2　Optional类入门　　206
10.3　应用Optional的几种模式　　 207
10.3.1　创建Optional对象　　208
10.3.2　使用map从Optional对象中提取和转换值　　208
10.3.3　使用flatMap链接Optional对象　　209
10.3.4　默认行为及解引用Optional对象　　213
10.3.5　两个Optional对象的组合　　213
10.3.6　使用filter剔除特定的值　　214
10.4　使用Optional的实战示例　　 216
10.4.1　用Optional封装可能为null的值　　216
10.4.2　异常与Optional的对比　　217
10.4.3　把所有内容整合起来　　218
10.5　小结　　219
第11章　CompletableFuture：组合式异步编程　　220
11.1　Future接口　　222
11.1.1　Future接口的局限性　　223
11.1.2　使用CompletableFuture构建异步应用　　223
11.2　实现异步API　　 224
11.2.1　将同步方法转换为异步方法　　225
11.2.2　错误处理　　227
11.3　让你的代码免受阻塞之苦　　228
11.3.1　使用并行流对请求进行并行操作　　229
11.3.2　使用CompletableFuture发起异步请求　　230
11.3.3　寻找更好的方案　　232
11.3.4　使用定制的执行器　　233
11.4　对多个异步任务进行流水线操作　　234
11.4.1　实现折扣服务　　235
11.4.2　使用Discount服务　　236
11.4.3　构造同步和异步操作　　237
11.4.4　将两个Completable-Future对象整合起来，无论它们是否存在依赖　　239
11.4.5　对Future和Completable-Future的回顾　　241
11.5　响应CompletableFuture的completion事件　　242
11.5.1　对最佳价格查询器应用的优化　　243
11.5.2　付诸实践　　244
11.6　小结　　245
第12章　新的日期和时间API　　246
12.1　LocalDate、LocalTime、Instant、Duration以及Period　　247
12.1.1　使用LocalDate和LocalTime　　247
12.1.2　合并日期和时间　　248
12.1.3　机器的日期和时间格式　　249
12.1.4　定义Duration或Period　　249
12.2　操纵、解析和格式化日期　　251
12.2.1　使用TemporalAdjuster　　253
12.2.2　打印输出及解析日期－时间对象　　255
12.3　处理不同的时区和历法　　256
12.3.1　利用和UTC/格林尼治时间的固定偏差计算时区　　257
12.3.2　使用别的日历系统　　258
12.4　小结　　259
第四部分 超越Java 8
第13章　函数式的思考　　262
13.1　实现和维护系统　　262
13.1.1　共享的可变数据　　263
13.1.2　声明式编程　　264
13.1.3　为什么要采用函数式编程　　265
13.2　什么是函数式编程　　265
13.2.1　函数式Java编程　　266
13.2.2　引用透明性　　268
13.2.3　面向对象的编程和函数式编程的对比　　 268
13.2.4　函数式编程实战　　269
13.3　递归和迭代　　271
13.4　小结　　274
第14章　函数式编程的技巧　　275
14.1　无处不在的函数　　275
14.1.1　高阶函数　　275
14.1.2　科里化　　277
14.2　持久化数据结构　　278
14.2.1　破坏式更新和函数式更新的比较　　279
14.2.2　另一个使用Tree的例子　　281
14.2.3　采用函数式的方法　　282
14.3　Stream的延迟计算　　283
14.3.1　自定义的Stream　　 283
14.3.2　创建你自己的延迟列表　　286
14.4　模式匹配　　290
14.4.1　访问者设计模式　　291
14.4.2　用模式匹配力挽狂澜　　292
14.5　杂项　　295
14.5.1　缓存或记忆表　　295
14.5.2　“返回同样的对象”意味着什么　　296
14.5.3　结合器　　296
14.6　小结　　297
第15章　面向对象和函数式编程的混合：Java 8和Scala的比较　　 299
15.1　Scala简介　　300
15.1.1　你好，啤酒　　300
15.1.2　基础数据结构：List、Set、Map、Tuple、Stream以及Option　　302
15.2　函数　　306
15.2.1　Scala中的一等函数　　307
15.2.2　匿名函数和闭包　　307
15.2.3　科里化　　309
15.3　类和trait　　310
15.3.1　更加简洁的Scala类　　310
15.3.2　Scala的trait与Java 8的接口对比　　311
15.4　小结　　312
第16章　结论以及Java的未来　　313
16.1　回顾Java 8的语言特性　　 313
16.1.1　行为参数化（Lambda 以及方法引用）　　314
16.1.2　流　　314
16.1.3　CompletableFuture　　315
16.1.4　Optional　　315
16.1.5　默认方法　　316
16.2　Java 的未来　　316
16.2.1　集合　　316
16.2.2　类型系统的改进　　317
16.2.3　模式匹配　　318
16.2.4　更加丰富的泛型形式　　319
16.2.5　对不变性的更深层支持　　321
16.2.6　值类型　　322
16.3　写在最后的话　　325
附录A　其他语言特性的更新　　326
附录B　类库的更新　　330
附录C　如何以并发方式在同一个流上执行多种操作　　338
附录D　Lambda表达式和JVM 字节码　　346
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 8实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 8函数式编程
前言　　IX
第1章　简介　　1
1.1　为什么需要再次修改Java　　1
1.2　什么是函数式编程　　2
1.3　示例　　2
第2章　Lambda 表达式　　5
2.1　第一个Lambda 表达式　　5
2.2　如何辨别Lambda 表达式　　6
2.3　引用值，而不是变量　　8
2.4　函数接口　　9
2.5　类型推断　　10
2.6　要点回顾　　12
2.7　练习　　12
第3章　流　　15
3.1　从外部迭代到内部迭代　　15
3.2　实现机制　　17
3.3　常用的流操作　　19
3.3.1　collect(toList())　　19
3.3.2　map　　19
3.3.3　filter　　21
3.3.4　flatMap　　22
3.3.5　max 和min　　23
3.3.6　通用模式　　24
3.3.7　reduce　　24
3.3.8　整合操作　　26
3.4　重构遗留代码　　27
3.5　多次调用流操作　　30
3.6　高阶函数　　31
3.7　正确使用Lambda 表达式　　31
3.8　要点回顾　　32
3.9　练习　　32
3.10　进阶练习　　33
第4章　类库　　35
4.1　在代码中使用Lambda 表达式　　35
4.2　基本类型　　36
4.3　重载解析　　38
4.4　@FunctionalInterface　　40
4.5　二进制接口的兼容性　　40
4.6　默认方法　　41
4.7　多重继承　　45
4.8　权衡　　46
4.9　接口的静态方法　　46
4.10　Optional　　47
4.11　要点回顾　　48
4.12　练习　　48
4.13　开放练习　　49
第5章　高级集合类和收集器　　51
5.1　方法引用　　51
5.2　元素顺序　　52
5.3　使用收集器　　54
5.3.1　转换成其他集合　　54
5.3.2　转换成值　　55
5.3.3　数据分块　　55
5.3.4　数据分组　　56
5.3.5　字符串　　57
5.3.6　组合收集器　　58
5.3.7　重构和定制收集器　　60
5.3.8　对收集器的归一化处理　　65
5.4　一些细节　　66
5.5　要点回顾　　67
5.6　练习　　67
第6章　数据并行化　　69
6.1　并行和并发　　69
6.2　为什么并行化如此重要　　70
6.3　并行化流操作　　71
6.4　模拟系统　　72
6.5　限制　　75
6.6　性能　　75
6.7　并行化数组操作　　78
6.8　要点回顾　　80
6.9　练习　　80
第7章　测试、调试和重构　　81
7.1　重构候选项　　81
7.1.1　进进出出、摇摇晃晃　　82
7.1.2　孤独的覆盖　　82
7.1.3　同样的东西写两遍　　83
7.2　Lambda 表达式的单元测试　　85
7.3　在测试替身时使用Lambda 表达式　　87
7.4　惰性求值和调试　　89
7.5　日志和打印消息　　89
7.6　解决方案：peak　　90
7.7　在流中间设置断点　　90
7.8　要点回顾　　90
第8章　设计和架构的原则　　91
8.1　Lambda 表达式改变了设计模式　　92
8.1.1　命令者模式　　92
8.1.2　策略模式　　95
8.1.3　观察者模式　　97
8.1.4　模板方法模式　　100
8.2　使用Lambda 表达式的领域专用语言　　102
8.2.1　使用Java 编写DSL　　103
8.2.2　实现　　104
8.2.3　评估　　106
8.3　使用Lambda 表达式的SOLID 原则　　106
8.3.1　单一功能原则　　107
8.3.2　开闭原则　　109
8.3.3　依赖反转原则　　 111
8.4　进阶阅读　　114
8.5　要点回顾　　114
第9章　使用Lambda 表达式编写并发程序　　115
9.1　为什么要使用非阻塞式I/O　　115
9.2　回调　　116
9.3　消息传递架构　　119
9.4　末日金字塔　　120
9.5　Future　　122
9.6　CompletableFuture　　123
9.7　响应式编程　　126
9.8　何时何地使用新技术　　128
9.9　要点回顾　　129
9.10　练习　　129
第10章　下一步该怎么办　　131
封面介绍　　133
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 8函数式编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 8编程入门官方教程
目录
第1章 Java基础 1
1.1 Java的起源 2
1.1.1 Java与C和C++的关系 3
1.1.2 Java与C#的关系 3
1.2 Java对Internet的贡献 4
1.2.1 Java applet 4
1.2.2 安全性 4
1.2.3 可移植性 5
1.3 Java的魔法：字节码 5
1.4 Java的主要术语 6
1.5 面向对象程序设计 7
1.5.1 封装 8
1.5.2 多态性 8
1.5.3 继承 9
1.6 获得Java开发工具包 9
1.7 第一个简单的程序 10
1.7.1 输入程序 10
1.7.2 编译程序 11
1.7.3 逐行分析第一个程序 11
1.8 处理语法错误 13
1.9 第二个简单程序 14
1.10 另一种数据类型 16
1.11 两条控制语句 18
1.11.1 if语句 18
1.11.2 for循环语句 20
1.12 创建代码块 21
1.13 分号和定位 22
1.14 缩进原则 23
1.15 Java关键字 25
1.16 Java标识符 25
1.17 Java类库 26
第2章 数据类型与运算符 29
2.1 数据类型为什么重要 30
2.2 Java的基本类型 30
2.2.1 整数类型 31
2.2.2 浮点型 32
2.2.3 字符型 33
2.2.4 布尔类型 34
2.3 字面值 36
2.3.1 十六进制、八进制和二进制字面值 36
2.3.2 字符转义序列 37
2.3.3 字符串字面值 37
2.4 变量详解 38
2.4.1 初始化变量 39
2.4.2 动态初始化 39
2.5 变量的作用域和生命期 39
2.6 运算符 42
2.7 算术运算符 42
2.8 关系运算符和逻辑运算符 44
2.9 短路逻辑运算符 46
2.10 赋值运算符 47
2.11 速记赋值 47
2.12 赋值中的类型转换 48
2.13 不兼容类型的强制转换 50
2.14 运算符优先级 51
2.15 表达式 53
2.15.1 表达式中的类型转换 53
2.15.2 间距和圆括号 55
第3章 程序控制语句 57
3.1 从键盘输入字符 58
3.2 if语句 59
3.2.1 嵌套if语句 60
3.2.2 if-else-if阶梯状结构 61
3.3 switch语句 62
3.4 for循环 68
3.4.1 for循环的一些变体 69
3.4.2 缺失部分要素的for循环 70
3.4.3 无限循环 71
3.4.4 没有循环体的循环 72
3.4.5 在for循环内部声明循环控制变量 72
3.4.6 增强型for循环 73
3.5 while循环 73
3.6 do-while循环 75
3.7 使用break语句退出循环 79
3.8 将break语句作为一种goto语句使用 81
3.9 使用continue语句 85
3.10 嵌套循环 89
第4章 类、对象和方法 93
4.1 类的基础知识 94
4.1.1 类的基本形式 94
4.1.2 定义类 95
4.2 如何创建对象 98
4.3 引用变量和赋值 98
4.4 方法 99
4.5 从方法返回值 101
4.6 返回值 102
4.7 使用形参 104
4.8 构造函数 112
4.9 带形参的构造函数 113
4.10 深入介绍new运算符 115
4.11 垃圾回收 115
4.12 this关键字 119
第5章 其他数据类型与运算符 123
5.1 数组 124
5.2 多维数组 129
5.3 不规则数组 130
5.3.1 三维或更多维的数组 131
5.3.2 初始化多维数组 131
5.4 另一种声明数组的语法 132
5.5 数组引用赋值 133
5.6 使用length成员 134
5.7 for-each形式的循环 139
5.7.1 迭代多维数组 142
5.7.2 应用增强型for循环 143
5.8 字符串 144
5.8.1 构造字符串 144
5.8.2 操作字符串 145
5.8.3 字符串数组 147
5.8.4 字符串是不可变的 148
5.8.5 使用String控制switch语句 149
5.9 使用命令行实参 150
5.10 位运算符 151
5.10.1 位运算符的与、或、异
或和非 151
5.10.2 移位运算符 155
5.10.3 位运算符的赋值速记符 157
5.11 ?运算符 160
第6章 方法和类详解 163
6.1 控制对类成员的访问 164
6.2 向方法传递对象 169
6.3 返回对象 173
6.4 方法重载 174
6.5 重载构造函数 179
6.6 递归 184
6.7 理解static关键字 186
6.8 嵌套类和内部类 192
6.9 varargs(可变长度实参) 195
6.9.1 varargs基础 195
6.9.2 重载varargs方法 198
6.9.3 varargs和歧义 199
第7章 继承 203
7.1 继承的基础知识 204
7.2 成员访问与继承 207
7.3 构造函数和继承 209
7.4 使用super调用超类构造函数 211
7.5 使用super访问超类成员 215
7.6 创建多级层次结构 218
7.7 何时调用构造函数 221
7.8 超类引用和子类对象 222
7.9 方法重写 227
7.10 重写的方法支持多态性 229
7.11 为何使用重写方法 231
7.12 使用抽象类 235
7.13 使用final 239
7.13.1 使用final防止重写 239
7.13.2 使用final防止继承 239
7.13.3 对数据成员使用final 240
7.14 Object类 241
第8章 包和接口 243
8.1 包 244
8.1.1 定义包 244
8.1.2 寻找包和CLASSPATH 245
8.1.3 一个简短的包示例 245
8.2 包和成员访问 247
8.3 理解被保护的成员 249
8.4 导入包 251
8.5 Java的类库位于包中 252
8.6 接口 253
8.7 实现接口 254
8.8 使用接口引用 257
8.9 接口中的变量 264
8.10 接口能够被扩展 265
8.11 默认接口方法 266
8.11.1 默认方法的基础知识 266
8.11.2 默认方法的实际应用 268
8.11.3 多继承问题 269
8.12 在接口中使用静态方法 270
8.13 有关包和接口的最后思考 271
第9章 异常处理 273
9.1 异常的层次结构 274
9.2 异常处理基础 274
9.2.1 使用关键字try和catch 275
9.2.2 一个简单的异常示例 276
9.3 未捕获异常的结果 277
9.4 使用多个catch语句 280
9.5 捕获子类异常 281
9.6 try代码块可以嵌套 282
9.7 抛出异常 283
9.8 Throwable详解 285
9.9 使用finally 286
9.10 使用throws语句 288
9.11 新增的3种异常功能 289
9.12 Java的内置异常 291
9.13 创建异常子类 293
第10章 使用I/O 299
10.1 Java的I/O基于流 300
10.2 字节流和字符流 300
10.3 字节流类 301
10.4 字符流类 301
10.5 预定义流 302
10.6 使用字节流 302
10.6.1 读取控制台输入 303
10.6.2 写入控制台输出 304
10.7 使用字节流读写文件 305
10.7.1 从文件输入 305
10.7.2 写入文件 309
10.8 自动关闭文件 311
10.9 读写二进制数据 313
10.10 随机访问文件 317
10.11 使用Java字符流 319
10.11.1 使用字符流的控制台输入 320
10.11.2 使用字符流的控制台输出 323
10.12 使用字符流的文件I/O 324
10.12.1 使用FileWriter 324
10.12.2 使用FileReader 325
10.13 使用Java的类型封装器转换数值字符串 326
第11章 多线程程序设计 337
11.1 多线程的基础知识 338
11.2 Thread类和Runnable接口 339
11.3 创建一个线程 339
11.4 创建多个线程 346
11.5 确定线程何时结束 348
11.6 线程的优先级 351
11.7 同步 354
11.8 使用同步方法 354
11.9 同步语句 357
11.10 使用notify( )、wait( )和notifyAll( )的线程通信 360
11.11 线程的挂起、继续执行和停止 365
第12章 枚举、自动装箱、静态导入和注释 371
12.1 枚举 372
12.2 Java语言中的枚举是类类型 374
12.3 values( )和valueOf( )方法 374
12.4 构造函数、方法、实例变量和枚举 376
12.5 枚举继承enum 378
12.6 自动装箱 384
12.7 类型封装器 385
12.8 自动装箱的基础知识 386
12.9 自动装箱和方法 387
12.10 发生在表达式中的自动装箱/自动拆箱 388
12.11 静态导入 390
12.12 注解(元数据) 393
第13章 泛型 397
13.1 泛型的基础知识 398
13.2 一个简单的泛型示例 399
13.2.1 泛型只能用于引用类型 402
13.2.2 泛型类型是否相同基于其类型实参 402
13.2.3 带有两个类型形参的泛型类 402
13.2.4 泛型类的一般形式 404
13.3 约束类型 404
13.4 使用通配符实参 407
13.5 约束通配符 410
13.6 泛型方法 413
13.7 泛型构造函数 415
13.8 泛型接口 416
13.9 原类型和遗留代码 422
13.10 使用菱形运算符进行类型推断 425
13.11 擦除特性 426
13.12 歧义错误 426
13.13 一些泛型限制 427
13.13.1 类型形参不能实例化 427
13.13.2 对静态成员的限制 428
13.13.3 泛型数组限制 428
13.13.4 泛型异常限制 429
13.14 继续学习泛型 429
第14章 lambda表达式和方法引用 431
14.1 lambda表达式简介 432
14.1.1 lambda表达式的基础知识 432
14.1.2 函数式接口 433
14.1.3 几个lambda表达式示例 435
14.2 块lambda表达式 440
14.3 泛型函数式接口 441
14.4 lambda表达式和变量捕获 447
14.5 从 lambda表达式中抛出异常 448
14.6 方法引用 449
14.6.1 静态方法的方法引用 449
14.6.2 实例方法的方法引用 451
14.7 构造函数引用 455
14.8 预定义的函数式接口 457
第15章 applet、事件和其他主题 461
15.1 applet的基础知识 462
15.2 applet的组织和基本构件 465
15.3 applet架构 465
15.4 完整的applet框架 465
15.5 applet的初始化与终止 467
15.6 请求重绘 467
15.7 使用状态窗口 472
15.8 向applet传递形参 473
15.9 Applet类 474
15.10 事件处理 476
15.11 委派事件模型 476
15.12 事件 476
15.12.1 事件源 476
15.12.2 事件侦听器 477
15.12.3 事件类 477
15.12.4 事件侦听器接口 478
15.13 使用委派事件模型 479
15.13.1 处理鼠标事件和鼠标移动事件 479
15.13.2 一个简单的鼠标事件applet 480
15.14 其他Java关键字 482
15.14.1 transient和volatile修饰符 483
15.14.2 instanceof 483
15.14.3 strictfp 483
15.14.4 assert 483
15.14.5 native方法 484
第16章 Swing介绍 487
16.1 Swing的起源和设计原则 488
16.2 组件和容器 490
16.2.1 组件 490
16.2.2 容器 491
16.2.3 顶级容器窗格 491
16.3 布局管理器 491
16.4 第一个简单的Swing程序 492
16.5 使用JButton 497
16.6 使用JTextField 500
16.7 使用JCheckBox 504
16.8 使用JList 507
15.9 使用匿名内部类或lambda表达式来处理事件 515
16.10 创建Swing applet 517
第17章 JavaFX简介 521
17.1 JavaFX的基本概念 522
17.1.1 JavaFX包 522
17.1.2 Stage和Scene类 523
17.1.3 节点和场景图 523
17.1.4 布局 523
17.1.5 Application类和生命周期方法 523
17.1.6 启动JavaFX应用程序 524
17.2 JavaFX应用程序的骨架 524
17.3 编译和运行JavaFX程序 527
17.4 应用程序线程 527
17.5 使用简单的JavaFX控件Label 528
17.6 使用按钮和事件 530
17.6.1 事件基础 530
17.6.2 按钮控件简介 531
17.6.3 演示事件处理和按钮 531
17.7 其他3个JavaFX控件 534
17.7.1 CheckBox 534
17.7.2 ListView 538
17.7.3 TextField 543
17.8 效果和变换简介 546
17.8.1 效果 546
17.8.2 变换 548
17.8.3 演示效果和变换 549
17.9 进一步学习 552
附录A 自测题答案 555
附录B 使用Java的文档注释 599
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 8编程入门官方教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 8编程参考官方教程
第Ⅰ部分 Java 语言
第1章 Java的历史和演变
1.1 Java的家世
1.1.1 现代编程语言的诞生：C语言
1.1.2 C++：下一个阶段
1.1.3 Java出现的时机已经成熟
1.2 Java的诞生
1.3 Java改变Internet的方式
1.3.1 Java
1.3.2 安全性
1.3.3 可移植性
1.4 Java的魔力：字节码
1.5 servlet：服务器端的
1.6 Java的关键特性
1.6.1 简单性
1.6.2 面向对象
1.6.3 健壮性
1.6.4 多线程
1.6.5 体系结构中立
1.6.6 解释执行和高性能
1.6.7 分布式
1.6.8 动态性
1.7 Java的演变历程
1.8 Java
1.9 文化革新
第2章 Java综述
2.1 面向对象编程
2.1.1 两种范式
2.1.2 抽象
2.1.3 OOP三原则
2.2第一个简单程序
2.2.1 输入程序
2.2.2 编译程序
2.2.3 深入分析第一个示例程序
2.3第二个简短程序
2.4 两种控制语句
2.4.1 if语句
2.4.2 for循环
2.5 使用代码块
2.6 词汇问题
2.6.1 空白符
2.6.2 标识符
2.6.3 字面值
2.6.4 注释
2.6.5 分隔符
2.6.6 Java关键字
2.7 Java类库
第3章 数据类型、变量和数组
3.1 Java是强类型化的语言
3.2 基本类型
3.3 整型
3.3.1
3.3.2
3.3.
3.3.4
3.4 浮点型
3.4.1
3.4.2
3.5 字符型
3.6 布尔型
3.7 深入分析字面值
3.7.1 整型字面值
3.7.2 浮点型字面值
3.7.3 布尔型字面值
3.7.4 字符型字面值
3.7.5 字符串字面值
3.8 变量
3.8.1 变量的声明
3.8.2 动态初始化
3.8.3 变量的作用域和生存期
3.9 类型转换和强制类型转换
3.9.1 Java的自动类型转换
3.9.2 强制转换不兼容的类型
3.10 表达式中的自动类型提升
3.11 数组
3.11.1 一维数组
3.11.2 多维数组
3.11.3 另一种数组声明语法
3.12 关于字符串的一些说明
3.13 向C/C++程序员提供指针方面的说明
第4章 运算符
4.1 算术运算符
4.1.1 基本算术运算符
4.1.2 求模运算符
4.1.3 算术与赋值复合运算符
4.1.4 自增与自减运算符
4.2 位运算符
4.2.1 位逻辑运算符
4.2.2 左移
4.2.3 右移
4.2.4 无符号右移
4.2.5 位运算符与赋值的组合
4.3 关系运算符
4.4 布尔逻辑运算符
4.5 赋值运算符
4.6 “？”运算符
4.7 运算符的优先级
4.8 使用圆括号
第5章 控制语句
5.1 Java的选择语句
19.18.2 java.util.fun
19.18.3 java.uti
19.18.4 java.util.lo
19.18.5 java.util.
19.18.6 java.util.
19.18.7 java.uti
19.18.8 java.util.s
19.18.9 java.uti
第20章 输入/输出：探究ja
20.1 I/O类和接口
20.2 File类
20.2.1 目录
20.2.2 使用FilenameFilter接口
20.2.3 listFiles（）方法
20.2.4 创建目录
20.3 AutoCloseable、Closeable和Flushable接口
20.4 I/O异常
20.5 关闭流的两种方式
20.6 流类
20.7 字节流
20.7.1 InputStream类
20.7.2 OutputStream类
20.7.3 FileInputStream类
20.7.4 FileOutputStream类
20.7.5 ByteArrayInputStream类
20.7.6 ByteArrayOutputStream类
20.7.7 过滤的字节流
20.7.8 缓冲的字节流
20.7.9 SequenceInputStream类
20.7.10 PrintStream类
20.7.11 DataOutputStream和DataInputStream类
20.7.12 RandomAccessFile类
20.8 字符流
20.8.1 Reader类
20.8.2 Writer类
20.8.3 FileReader类
20.8.4 FileWriter类
20.8.5 CharArrayReader类
20.8.6 CharArrayWriter类
20.8.7 BufferedReader类
20.8.8 BufferedWriter类
20.8.9 PushbackReader类
20.8.10 PrintWriter类
20.9 Console类
20.10 串行化
20.10.1 Serializable接口
20.10.2 Externalizable接口
20.10.3 ObjectOutput接口
20.10.4 ObjectOutputStream类
20.10.5 ObjectInput接口
20.10.6 ObjectInputStream类
20.10.7 串行化示例
20.11 流的优点
第21章 探究
21.1 NIO类
21.2 NIO的基础知识
21.2.1 缓冲区
21.2.2 通道
21.2.3 字符集和选择器
21.3 JDK 7对NIO的增强
21.3.1 Path接口
21.3.2 Files类
21.3.3 Path接口
21.3.4 文件属性接口
21.3.5 FileSystem、FileSystems和FileStore类
21.4 使用NIO系统
21.4.1 为基于通道的I/O使用
21.4.2 为基于流的I/O使用
21.4.3 为路径和文件系统操作使用
21.5 JDK 7之前基于通道的例子
21.5.1 读文件（JDK 7之前
21.5.2 写文件（JDK 7之前
第22章 联网
22.1 联网的基础知识
22.2 联网类和接口
22.3 InetAddress类
22.3.1 工厂方法
22.3.2 实例方法
22.4 Inet4Address类和Inet6Address类
22.5 TCP/IP客户端套接字
22.6 URL类
22.7 URLConnection类
22.8 HttpURLConnection类
22.9 URI类
22.10 c
22.11 TCP/IP服务器套接字
22.12 数据报
22.12.1 DatagramSocket类
22.12.2 DatagramPacket类
22.12.3 数据报示例
第23章 Applet类
23.1 applet的两种类型
23.2 applet的基础知识
23.3 applet的架构
23.4 applet的骨架
23.4.1 applet的初始化和终止
23.4.2 重写update（）方法
23.5 简单的applet显示方法
23.6 请求重画
23.7 使用状态栏窗口
23.8 HTML APPLET标记
23.9 向applet传递参数
23.10 getDocumentBase（）和getCodeB
23.11 AppletContext接口和showDocument（）方法
23.12 AudioClip接口
23.13 AppletStub接口
23.14 向控制台输出
第24章 事件处理
24.1 两种事件处理机制
24.2 委托事件模型
24.2.1 事件
24.2.2 事件源
24.2.3 事件监听器
24.3 事件类
24.3.1 ActionEvent类
24.3.2 AdjustmentEvent类
24.3.3 ComponentEvent类
24.3.4 ContainerEvent类
24.3.5 FocusEvent类
24.3.6 InputEvent类
24.3.7 ItemEvent类
24.3.8 KeyEvent类
24.3.9 MouseEvent类
24.3.10 MouseWheelEvent类
24.3.11 TextEvent类
24.3.12 WindowEvent类
24.4 事件源
24.5 事件监听器接口
24.5.1 ActionListener接口
24.5.2 AdjustmentListener接口
24.5.3 ComponentListener接口
24.5.4 ContainerListener接口
24.5.5 FocusListener接口
24.5.6 ItemListener接口
24.5.7 KeyListener接口
24.5.8 MouseListener接口
24.5.9 MouseMotionListener接口
24.5.10 MouseWheelListener接口
24.5.11 TextListener接口
24.5.12 WindowFocusListener接口
24.5.13 WindowListener接口
24.6 使用委托事件模型
24.6.1 处理鼠标事件
24.6.2 处理键盘事件
24.7 适配器类
24.8 内部类
第25章 AWT介绍：使用窗口、图形和文本
25.1 AWT类
25.2 窗口基本元素
25.2.1 Component类
25.2.2 Container类
25.2.3 Panel类
25.2.4 Window类
25.2.5 Frame类
25.2.6 Canvas类
25.3 使用框架窗口
25.3.1 设置窗口的尺寸
25.3.2 隐藏和显示窗口
25.3.3 设置窗口的标题
25.3.4 关闭框架窗口
25.4 在基于AWT的applet中创建框架窗口
25.5 创建基于窗口的程序
25.6 在窗口中显示信息
25.7 使用图形
25.7.1 绘制直线
25.7.2 绘制矩形
25.7.3 绘制椭圆和圆
25.7.4 绘制弧形
25.7.5 绘制多边形
25.7.6 演示绘制方法
25.7.7 改变图形的大小
25.8 使用颜色
25.8.1 Color类的方法
25.8.2 设置当前图形的颜色
25.8.3 一个演示颜色的a
25.9 设置绘图模式
25.10 使用字体
25.10.1 确定可用字体
25.10.2 创建和选择字体
25.10.3 获取字体信息
25.11 使用FontMetrics管理文本输出
25.11.1 显示多行文本
25.11.2 居中显示文本
25.11.3 对齐多行文本
第26章 使用AWT控件、布局管理器和菜单
26.1 AWT控件的基础知识
26.1.1 添加和移除控件
26.1.2 响应控件
26.1.3 HeadlessException异常
26.2 使用标签
26.3 使用命令按钮
26.4 使用复选框
26.5 使用复选框组
26.6 使用下拉列表
26.7 使用列表框
26.8 管理滚动条
26.9 使用Text
26.10 使用Tex
26.11 理解布局管理器
26.11.1 FlowLayout布局管理器
26.11.2 BorderLayout布局管理器
26.11.3 使用I
26.11.4 GridLayout布局管理器
26.11.5 CardLayout布局管理器
26.11.6 GridBagLayout布局管理器
26.12 菜单栏和菜单
26.13 对话框
26.14 FileDialog类
26.15 关于重写paint（）方法
第27章 图像
27.1 文件格式
27.2 图像基础：创建、加载与显示
27.2.1 创建Image对象
27.2.2 加载图像
27.2.3 显示图像
27.3 ImageObserver接口
27.4 双缓冲
27.5 MediaTracker类
27.6 ImageProducer接口
27.7 ImageConsumer接口
27.8 ImageFilter类
27.8.1 CropImageFilter类
27.8.2 RGBImageFilter类
27.9 其他图像类
第28章 并发实用工具
28.1 并发API包
28.1.1 java.util.concurrent包
28.1.2 java.util.concurrent.atomic包
28.1.3 java.util.concurrent.locks包
28.2 使用同步对象
28.2.1 Semaphore类
28.2.2 CountDownLatch类
28.2.3 CyclicBarrier类
28.2.4 Exchanger类
28.2.5 Phaser类
28.3 使用执行器
28.3.1 一个简单的执行器示例
28.3.2 使用Callable和Future接口
28.4 TimeUnit枚举
28.5 并发集合
28.6 锁
28.7 原子操作
28.8 通过Fork/Join框架进行并行编程
28.8.1 主要的Fork/Join类
28.8.2 分而治之的策略
28.8.3 一个简单的Fork/Join示例
28.8.4 理解并行级别带来的影响
28.8.5 一个使用RecursiveTask[V]的例子
28.8.6 异步执行任务
28.8.7 取消任务
28.8.8 确定任务的完成状态
28.8.9 重新启动任务
28.8.10 深入研究
28.8.11 关于Fork/Join框架的一些提示
28.9 并发实用工具与Java传统方式的比较
第29章 流
29.1 流的基础知识
29.1.1 流接口
29.1.2 如何获得流
29.1.3 一个简单的流示例
29.2 缩减操作
29.3 使用并行流
29.4 映射
29.5 收集
29.6 迭代器和流
29.6.1 对流使用迭代器
29.6.2 使用Splite
29.7 流API中更多值得探究的地方
第30章 正则表达式和其他包
30.1 核心Java API包
30.2 正则表达式处理
30.2.1 Pattern类
30.2.2 Matcher类
30.2.3 正则表达式的语法
30.2.4 演示模式匹配
30.2.5 模式匹配的两个选项
30.2.6 探究正则表达式
30.3 反射
30.4 远程方法调用
30.5 使用java.text格式化日期和时间
30.5.1 DateFormat类
30.5.2 SimpleDateFormat类
30.6 JDK 8新增的时间和日？
30.6.1 时间和日期的基础知识
30.6.2 格式化日期和时间
30.6.3 解析日期和时间字符串
30.7 探究java.time包的其他方面
第Ⅲ部分 使用Swing进行 GUI编程
第31章 Swing简介
31.1 Swing的起源
31.2 Swing以AWT为基础
31.3 两个关键的Swing特性
31.3.1 Swing组件是轻量级的
31.3.2 Swing支持可插入外观
31.4 MVC连接
31.5 组件与容器
31.5.1 组件
31.5.2 容器
31.5.3 顶级容器窗格
31.6 Swing包
31.7 一个简单的Swing应用程序
31.8 事件处理
31.9 创建Swing ap
31.10 在Swing中绘图
31.10.1 绘图的基础知识
31.10.2 计算可绘制区域
31.10.3 一个绘图示例
第32章 探究S
32.1 JLabel与Image
32.2 JTextF
32.3 Swing按钮
32.3.1 JBu
32.3.2 JToggleBu
32.3.3 复选框
32.3.4 单选按钮
32.4 JTabbed
32.5 JScroll
32.6 J
32.7 JComb
32.8 树
32.9 JT
第33章 Swing菜单简介
33.1 菜单的基础知识
33.2 JMenuBar、JMenu和JMenuItem概述
33.2.1 JMen
33.2.2 J
33.2.3 JMenu
33.3 创建主菜单
33.4 向菜单项添加助记符和加速键
33.5 向菜单项添加图片和工具提示
33.6 使用JRadioButtonMenuItem和JCheckBoxMenu
33.7 创建弹出菜单
33.8 创建工具栏
33.9 使用动作
33.10 完整演示MenuDemo程序
33.11 继续探究S
第Ⅳ部分 使用JavaFX进行GUI编程
第34章 JavaFX GUI编程简介
34.1 JavaFX的基础概念
34.1.1 JavaFX包
34.1.2 Stage和Scene类
34.1.3 节点和场景图
34.1.4 布局
34.1.5 Application类和生命周期方法
34.1.6 启动JavaFX应用程序
34.2 JavaFX应用程序的骨架
34.3 编译和运行JavaFX程序
34.4 应用程序线程
34.5 一个简单的JavaFX控件：L
34.6 使用按钮和事件
34.6.1 事件的基础知识
34.6.2 按钮控件简介
34.6.3 演示事件处理和按钮
34.7 直接在画布上绘制
第35章 探究JavaFX控件
35.1 使用Image和Image
35.1.1 向标签添加图片
35.1.2 在按钮中使用图片
35.2 ToggleBu
35.3 RadioBu
35.3.1 处理开关组中的变化事件
35.3.2 处理单选按钮的另一种方式
35.4 Chec
35.5 List
35.5.1 ListView的滚动条
35.5.2 启用多项选择
35.6 Comb
35.7 TextF
35.8 Scroll
35.9 Tree
35.10 效果和变换简介
35.10.1 效果
35.10.2 变换
35.10.3 演示效果和变换
35.11 添加工具提示
35.12 禁用控件
第36章 JavaFX菜单简介
36.1 菜单的基础知识
36.2 MenuBar、Menu和MenuItem概述
36.2.1 Men
36.2.2
36.2.3 Menu
36.3 创建主菜单
36.4 向菜单项添加助记符和加速键
36.5 向菜单项添加图片
36.6 使用RadioMenuItem和CheckMenu
36.7 创建上下文菜单
36.8 创建工具栏
36.9 完整的MenuDemo程序
36.10 继续探究Ja
第Ⅴ部分 应用
第37章 Java
37.1 Java Bean是什么
37.2 Java Bean的优势
37.3 内省
37.3.1 属性的设计模式
37.3.2 事件的设计模式
37.3.3 方法与设计模式
37.3.4 使用BeanInfo接口
37.4 绑定属性与约束属性
37.5 持久性
37.6 定制器
37.7 Java Bean
37.7.1 Introspector类
37.7.2 PropertyDescriptor类
37.7.3 EventSetDescriptor类
37.7.4 MethodDescriptor类
37.8 一个Bean示例
第38章 ser
38.1 背景
38.2 servelet的生命周期
38.3 servlet开发选项
38.4 使用To
38.5 一个简单的ser
38.5.1 创建和编译servlet源代码
38.5.2 启动To
38.5.3 启动Web浏览器并请求ser
38.6 Servlet
38.7 javax.servlet包
38.7.1 Servlet接口
38.7.2 ServletConfig接口
38.7.3 ServletContext接口
38.7.4 ServletRequest接口
38.7.5 ServletResponse接口
38.7.6 GenericServlet类
38.7.7 ServletInputStream类
38.7.8 ServletOutputStream类
38.7.9 servlet异常类
38.8 读取servlet参数
38.9 javax.servlet.http包
38.9.1 HttpServletRequest接口
38.9.2 HttpServletResponse接口
38.9.3 HttpSession接口
38.9.4 Cookie类
38.9.5 HttpServlet类
38.10 处理HTTP请求和响应
38.10.1 处理HTTP GET请求
38.10.2 处理HTTP POST请求
38.11 使用co
38.12 会话跟踪
附录 使用Java的文档注释
5.1.1 if语句
5.1.2 switch语句
5.2 迭代语句
5.2.1 while语句
5.2.2 do-while语句
5.2.3 for语句
5.2.4 for循环的for-each版本
5.2.5 嵌套的循环
5.3 跳转语句
5.3.1 使用break语句
5.3.2 使用continue语句
5.3.3 return语句
第6章 类
6.1 类的基础知识
6.1.1 类的一般形式
6.1.2 一个简单的类
6.2 声明对象
6.3 为对象引用变量赋值
6.4 方法
6.4.1 为Box类添加方法
6.4.2 返回值
6.4.3 添加带参数的方法
6.5 构造函数
6.6 this关键字
6.7 垃圾回收
6.8 finalize（）方法
6.9 堆栈类
第7章 方法和类的深入分析
7.1 重载方法
7.2 将对象用作参数
7.3 参数传递的深入分析
7.4 返回对象
7.5 递归
7.6 访问控制
7.7 理解st
7.8 final介绍
7.9 重新审视数组
7.10 嵌套类和内部类
7.11 String类介绍
7.12 使用命令行参数
7.13 varargs：可变长度参数
7.13.1 重载varargs方法
7.13.2 varargs方法与模糊性
第8章 继承
8.1 继承的基础知识
8.1.1 成员访问与继承
8.1.2 一个更实际的例子
8.1.3 超类变量可以引用子类对象
8.2 使用super关键字
8.2.1 使用super调用超类的构造函数
8.2.2 super的另一种用法
8.3 创建多级继承层次
8.4 构造函数的调用时机
8.5 方法重写
8.6 动态方法调度
8.6.1 重写方法的目的
8.6.2 应用方法重写
8.7 使用抽象类
8.8 在继承中使用final关键字
8.8.1 使用final关键字阻止重写
8.8.2 使用final关键字阻止继承
8.9 Object类
第9章 包和接口
9.1 包
9.1.1 定义包
9.1.2 包查找与CLAS
9.1.3 一个简短的包示例
9.2 访问保护
9.3 导入包
9.4 接口
9.4.1 定义接口
9.4.2 实现接口
9.4.3 嵌套接口
9.4.4 应用接口
9.4.5 接口中的变量
9.4.6 接口可以扩展
9.5 默认接口方法
9.5.1 默认方法的基础知识
9.5.2 一个更加实用的例子
9.5.3 多级继承的问题
9.6 在接口中使用静态方法
9.7 关于包和接口的最后说明
第10章 异常处理
10.1 异常处理的基础知识
10.2 异常类型
10.3 未捕获的异常
10.4 使用try和
10.5 多条catch子句
10.6 嵌套的try语句
10.7
10.8 t
10.9 fi
10.10 Java的内置异常
10.11 创建自己的异常子类
10.12 链式异常
10.13 3个近期添加的异常特性
10.14 使用异常
第11章 多线程编程
11.1 Java线程模型
11.1.1 线程优先级
11.1.2 同步
11.1.3 消息传递
11.1.4 Thread类和Runnable接口
11.2 主线程
11.3 创建线程
11.3.1 实现Runnable接口
11.3.2 扩展Thread类
11.3.3 选择一种创建方式
11.4 创建多个线程
11.5 使用isAlive（）和join（）方法
11.6 线程优先级
11.7 同步
11.7.1 使用同步方法
11.7.2 synchronized语句
11.8 线程间通信
11.9 挂起、恢复与停止线程
11.10 获取线程的状态
11.11 使用多线程
第12章 枚举、自动装箱与注解（元数据
12.1 枚举
12.1.1 枚举的基础知识
12.1.2 values（）和valueOf（）方法
12.1.3 Java枚举是类类型
12.1.4 枚举继承自Enum类
12.1.5 另一个枚举示例
12.2 类型封装器
12.2.1 Character封装器
12.2.2 Boolean封装器
12.2.3 数值类型封装器
12.3 自动装箱
12.3.1 自动装箱与方法
12.3.2 表达式中发生的自动装箱/拆箱
12.3.3 布尔型和字符型数值的自动装箱/拆箱
12.3.4 自动装箱/拆箱有助于防止错误
12.3.5 一些警告
12.4 注解（元数据
12.4.1 注解的基础知识
12.4.2 指定保留策略
12.4.3 在运行时使用反射获取注解
12.4.4 AnnotatedElement接口
12.4.5 使用默认值
12.4.6 标记注解
12.4.7 单成员注解
12.4.8 内置注解
12.5 类型注解
12.6 重复注解
第13章 I/O、applet以及其他主题
13.1 I/O的基础知识
13.1.1 流
13.1.2 字节流和字符流
13.1.3 预定义流
13.2 读取控制台输入
13.2.1 读取字符
13.2.2 读取字符串
13.3 向控制台写输出
13.4 PrintWriter类
13.5 读/写文件
13.6 自动关闭文件
13.7 applet的基础知识
13.8 transient和volatile修饰符
13.9 使用instanceof运算符
13.10 str
13.11 本地方法
13.12 使用a
13.13 静态导入
13.14 通过this（）调用重载的构造函数
13.15 紧凑API配置文件
第14章 泛型
14.1 什么是泛型
14.2 一个简单的泛型示例
14.2.1 泛型只使用引用类型
14.2.2 基于不同类型参数的泛型类型是不同的
14.2.3 泛型提升类型安全性的原理
14.3 带两个类型参数的泛型类
14.4 泛型类的一般形式
14.5 有界类型
14.6 使用通配符参数
14.7 创建泛型方法
14.8 泛型接口
14.9 原始类型与遗留代码
14.10 泛型类层次
14.10.1 使用泛型超类
14.10.2 泛型子类
14.10.3 泛型层次中的运行时类型比较
14.10.4 强制转换
14.10.5 重写泛型类的方法
14.11 泛型的类型推断
14.12 擦除
14.13 模糊性错误
14.14 使用泛型的一些限制
14.14.1 不能实例化类型参数
14.14.2 对静态成员的一些限制
14.14.3 对泛型数组的一些限制
14.14.4 对泛型异常的限制
第15章 lambda表达式
15.1 lambda表达式简介
15.1.1 lambda表达式的基础知识
15.1.2 函数式接口
15.1.3 几个lambda表达式示例
15.2 块lambda表达式
15.3 泛型函数式接口
15.4 作为参数传递lambda表达式
15.5 lambda表达式与异常
15.6 lambda表达式和变量捕获
15.7 方法引用
15.7.1 静态方法的方法引用
15.7.2 实例方法的方法引用
15.7.3 泛型中的方法引用
15.8 构造函数引用
15.9 预定义的函数式接口
第Ⅱ部分 Java库
第16章 字符串处理
16.1 String类的构造函数
16.2 字符串的长度
16.3 特殊的字符串操作
16.3.1 字符串字面值
16.3.2 字符串连接
16.3.3 字符串和其他数据类型的连接
16.3.4 字符串转换和toString（）方法
16.4 提取字符
16.4.1 cha
16.4.2 getCh
16.4.3 getBy
16.4.4 toCharAr
16.5 比较字符串
16.5.1 equals（）和equalsIgnoreC
16.5.2 regionMatc
16.5.3 startsWith（）和endsW
16.5.4 equals（）与
16.5.5 compar
16.6 查找字符串
16.7 修改字符串
16.7.1 substr
16.7.2 con
16.7.3 repl
16.7.4 t
16.8 使用valueOf（）转换数据
16.9 改变字符串中字符的大小写
16.10 连接字符串
16.11 其他String方法
16.12 StringBuffer类
16.12.1 StringBuffer类的构造函数
16.12.2 length（）与capac
16.12.3 ensureCapac
16.12.4 setLen
16.12.5 charAt（）与setCha
16.12.6 getCh
16.12.7 app
16.12.8 ins
16.12.9 reve
16.12.10 delete（）与deleteCha
16.12.11 repl
16.12.12 substr
16.12.13 其他StringBuffer方法
16.13 StringBuilder类
第17章 探究java
17.1 基本类型封装器
17.1.1 N
17.1.2 Double与
17.1.3 理解isInfinite（）与is
17.1.4 Byte、Short、Integer？
17.1.5 Char
17.1.6 对Unicode代码点的附加支持
17.1.7 Bo
17.2 Void类
17.3 Process类
17.4 Runtime类
17.4.1 内存管理
17.4.2 执行其他程序
17.5 ProcessBuilder类
17.6 System类
17.6.1 使用currentTimeMillis（）计时程序的执行
17.6.2 使用arrayc
17.6.3 环境属性
17.7 Object类
17.8 使用clone（）方法和Cloneable接口
17.9 Class类
17.10 ClassLoader类
17.11 Math类
17.11.1 三角函数
17.11.2 指数函数
17.11.3 舍入函数
17.11.4 其他数学方法
17.12 StrictMath类
17.13 Compiler类
17.14 Thread类、ThreadGroup类和Runnable接口
17.14.1 Runnable接口
17.14.2 Thread类
17.14.3 ThreadGroup类
17.15 ThreadLocal和
InheritableThreadLocal类
17.16 Package类
17.17 RuntimePermission类
17.18 Throwable类
17.19 SecurityManager类
17.20 StackTraceElement类
17.21 Enum类
17.22 ClassValue类
17.23 CharSequence接口
17.24 Comparable接口
17.25 Appendable接口
17.26 Iterable接口
17.27 Readable接口
17.28 AutoCloseable接口
17.29 Thread.UncaughtExceptionHandler接口
17.30 java.lang子包
17.30.1 java.lang.annot
17.30.2 java.lang.instr
17.30.3 java.lang.i
17.30.4 java.lang.manag
17.30.5 java.lan
17.30.6 java.lang.re
第18章 java.util第1部分：集合框架
18.1 集合概述
18.2 JDK 5对集合框架的修改
18.2.1 泛型从根本上改变了集合框架
18.2.2 自动装箱使得使用基本类型更加容易
18.2.3 for-each风格的for循环
18.3 集合接口
18.3.1 Collection接口
18.3.2 List接口
18.3.3 Set接口
18.3.4 SortedSet接口
18.3.5 NavigableSet接口
18.3.6 Queue接口
18.3.7 Deque接口
18.4 集合类
18.4.1 ArrayList类
18.4.2 LinkedList类
18.4.3 HashSet类
18.4.4 LinkedHashSet类
18.4.5 TreeSet类
18.4.6 PriorityQueue类
18.4.7 ArrayDeque类
18.4.8 EnumSet类
18.5 通过迭代器访问集合
18.5.1 使用迭代器
18.5.2 使用for-each循环替代迭代器
18.6 Splite
18.7 在集合中存储用户定义的类
18.8 RandomAccess接口
18.9 使用映射
18.9.1 映射接口
18.9.2 映射类
18.10 比较器
18.11 集合算法
18.12 Arrays类
18.13 遗留的类和接口
18.13.1 Enumeration接口
18.13.2 Vector类
18.13.3 Stack类
18.13.4 Dictionary类
18.13.5 Hashtable类
18.13.6 Properties类
18.13.7 使用store（）和l
18.14 集合小结
第19章 java.util第2部分：更多实用工具类
19.1 StringTokenizer类
19.2 BitSet类
19.3 Optional、OptionalDouble、OptionalInt和Optiona
19.4 Date类
19.5 Calendar类
19.6 GregorianCalendar类
19.7 TimeZone类
19.8 SimpleTimeZone类
19.9 Locale类
19.10 Random类
19.11 Observable类
19.11.1 Observer接口
19.11.2 Observer示例
19.12 Timer和TimerTask类
19.13 Currency类
19.14 Formatter类
19.14.1 Formatter类的构造函数
19.14.2 Formatter类的方法
19.14.3 格式化的基础知识
19.14.4 格式化字符串和字符
19.14.5 格式化数字
19.14.6 格式化时间和日期
19.14.7 %n和%%说明符
19.14.8 指定最小字段宽度
19.14.9 指定精度
19.14.10 使用格式标志
19.14.11 对齐输出
19.14.12 空格、“+”、“0”以及“（”标志
19.14.13 逗号标志
19.14.14 “#”标志
19.14.15 大写选项
19.14.16 使用参数索引
19.14.17 关闭Formatter对象
19.14.18 printf（）方法
19.15 Scanner类
19.15.1 Scanner类的构造函数
19.15.2 扫描的基础知识
19.15.3 一些Scanner示例
19.15.4 设置定界符
19.15.5 其他Scanner特性
19.16 ResourceBundle、ListResourceBundle和
19.17 其他实用工具类和接口
19.18 java.util子包
19.18.1 java.util.concurrent、java.util.concurrent.atomic和 java.util.concurrent.
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 8编程参考官方教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 8高级应用与开发
第1章文件及IO流
任务驱动
学习路线
本章目标
1.1文件
1.1.1文件系统和路径
1.1.2File类
1.1.3FilenameFilter接口
1.2IO流
1.2.1流的分类
1.2.2流的体系结构
1.3字节流
1.3.1InputStream
1.3.2OutputStream
1.4字符流
1.4.1Reader
1.4.2Writer
1.5过滤流和转换流
1.5.1过滤流
1.5.2转换流
1.6对象流
1.6.1对象序列化与反序列化
1.6.2ObjectlnputStream和ObjectOutputStream
1.7NIO
1.7.1NIO概述
1.7.2Buffer
1.7.3Channel
1.7.4NIO.2
1.8贯穿任务实现
1.8.1实现（任务1—1）
1.8.2实现（任务1—2）
1.8.3实现（任务1—3）
1.8.4实现（任务1—4）
本章总结
小结
Q&A
章节练习
习题
上机
第2章JDBC编程
任务驱动
学习路线
本章目标
2.1JDBC基础
2.1.1JDBC简介
2.1.2JDBC驱动
2.1.3JDBC API
2.2数据库环境搭建
2.2.1创建数据库表
2.2.2设置Oracle驱动类路径
2.3数据库访问
2.3.1加载数据库驱动
2.3.2建立数据连接
2.3.3创建Statement对象
2.3.4执行SQL语句
2.3.5访问结果集
2.4操作数据库
2.4.1exectlte（）方法
2.4.2executeUpdate（）和executeLargeUpdate（）方法
2.4.3PreparedStatement接口
2.4.4CallableStatement接口
2.4.5数据库访问优化
2.5集元数据
2.5.1DatabaseMetaData接口
2.5.2ResultSetMetaData接口
2.6事务处理
2.6.1事务
2.6.2保存点
2.6.3批量更新
2.7贯穿任务实现
2.7.1实现（任务2—1）
2.7.2实现（任务2—2）
2.7.3实现（任务2—3）
2.7.4实现（任务2—4）
本章总结
小结
Q&A
章节练习
习题
上机
第3章Swing UI设计
任务驱动
学习路线
本章目标
3.1GUI概述
3.1.1AWT和Swing
3.1.2Swing组件层次
3.2容器
3.2.1……
3.2.2JPanel中间容器
3.3布局
3.3.1FlowLayout流布局
3.3.2BorderLayout边界布局
3.3.3GridLayout网格布局
3.3.4CardLayout卡片布局
3.3.5BoxLayout盒布局
3.3.6NULL空布局
3.4事件处理
3.4.1Java事件处理机制
3.4.2事件类
3.4.3监听接口
3.4.4事件处理步骤
3.4.5键盘事件
3.4.6鼠标事件
3.4.7适配器
3.5基本组件
3.5.1Icon图标
3.5.2JButton按钮
3.5.3JLabel标签
3.5.4文本组件
3.5.5JCornboBox组合框
3.5.6JList列表框
3.5.7JRadioButton单选按钮
3.5.8JCheckBox复选框
3.5.9计算器
3.6贯穿任务实现
3.6.1实现（任务3—1）
3.6.2实现（任务3—2）
3.6.3实现（任务3—3）
本章总结
小结
Q&A
章节练习
习题
上机
第4章高级UI组件
任务驱动
学习路线
本章目标
4.1对话框
4.1.1JDialog对话框
4.1.2JOptionPane标准对话框
4.1.3JFileChooser文件对话框
4.1.4JColorChooser颜色对话框
4.2菜单
4.2.1下拉式菜单
4.2.2弹出式菜单
4.3工具栏
4.4表格
4.4.1JTable类及相关接口
4.4.2使用表格
4.5树
4.5.1JTree类及相关接口
4.5.2使用树
4.6贯穿任务实现
4.6.1实现（任务4—1）
4.6.2实现（任务4—2）
4.6.3实现（任务4—3）
4.6.4实现（任务4—4）
本章总结
小结
Q&A
章节练习
习题
上机
第5章线程
任务驱动
学习路线
本章目标
5.1线程概述
5.1.1线程和进程
5.1.2Java线程模型
5.1.3主线程
5.2创建线程
5.2.1继承Thread类
5.2.2实现Runnable接口
5.2.3使用Callabte和Future接口
5.3线程生命周期
5.3.1新建和就绪状态
5.3.2运行和阻塞状态
5.3.3死亡状态
5.4线程优先级
5.5线程同步
5.5.1同步代码块
5.5.2同步方法
5.5.3同步锁
5.6线程通信
5.7Timer和Swing Timer
5.7.1Timer
5.7.2Swing Timer
5.8贯穿任务实现
5.8.1实现（任务5—1）
本章总结
小结
Q&A
章节练习
习题
上机
第6章网络编程
任务驱动
学习路线
本章目标
6.1网络基础
6.1.1网络类型
6.1.2TCP／IP协议
6.1.3IP地址和端口
6.1.4域名DNS
6.2Java网络API
6.2.1InetAddress类
6.2.2URL类
6.2.3URLConnection类
6.2.4URLDecoder雨URLEncoder类
6.3基于TCP的网络编程
6.3.1Socket类
6.3.2ServerSocket类
6.3.3聊天室
6.4贯穿任务实现
6.4.1实现（任务6—1）
6.4.2实现（任务6—2）
6.4.3实现（任务6—3）
本章总结
小结
Q&A
章节练习
习题
上机
第7章Java高级应用
任务驱动
学习路线
本章目标
7.1类加载
7.1.1Class类
7.1.2类加载步骤
7.1.3类加载器
7.1.4ClassLoader类
7.2反射
7.2.1Executable抽象类
7.2.2Constructor类
7.2.3Method类
7.2.4Field类
7.2.5Parameter类
7.3枚举
7.3.1定义枚举类
7.3.2包含属性和方法的枚举类
7.3.3Enum类
7.4注解
7.4.1基本注解
7.4.2定义注解
7.4.3使用注解
7.4.4元注解
7.5国际化
7.5.1Locale类
7.5.2ResourceBundle类
7.6格式化处理
7.6.1数字格式化
7.6.2货币格式化
7.6.3日期格式化
7.6.4Java 8新增的DateTimeFormatter
7.6.5消息格式化
7.7贯穿任务实现
7.7.1实现（任务7—1）
7.7.2实现（任务7—2）
本章总结
小结 Q&A
章节练习
习题
上机
……
第8章Java 8新特性
附录AWindowBuilder插件
附录B数据库连接池
附录CRowSet
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 8高级应用与开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java攻略
译者序　　ix
序　　xi
前言　　xiii
第1章　基础知识　　1
1.1　lambda 表达式　　2
1.2　方法引用　　5
1.3　构造函数引用　　8
1.4　函数式接口　　12
1.5　接口中的默认方法　　14
1.6　接口中的静态方法　　17
第2章　java.util.function 包　　20
2.1　Consumer 接口　　20
2.2　Supplier 接口　　22
2.3　Predicate 接口　　25
2.4　Function 接口　　28
第3章　流式操作　　31
3.1　流的创建　　31
3.2　装箱流　　35
3.3　利用reduce 方法实现归约操作　　36
3.4　利用reduce 方法校验排序　　44
3.5　利用peek 方法对流进行调试　　45
3.6　字符串与流之间的转换　　47
3.7　获取元素数量　　50
3.8　汇总统计　　52
3.9　查找流的第一个元素　　54
3.10　使用anyMatch、allMatch 与noneMatch 方法　　58
3.11　使用flatMap 与map 方法　　60
3.12　流的拼接　　63
3.13　惰性流　　66
第4章　比较器与收集器　　69
4.1　利用比较器实现排序　　69
4.2　将流转换为集合　　72
4.3　将线性集合添加到映射　　75
4.4　对映射排序　　77
4.5　分区与分组　　79
4.6　下游收集器　　81
4.7　查找最大值和最小值　　83
4.8　创建不可变集合　　85
4.9　实现Collector 接口　　87
第5章　流式操作、lambda 表达式与方法引用的相关问题　　91
5.1　java.util.Objects 类　　91
5.2　lambda 表达式与效果等同于final 的变量　　93
5.3　随机数流　　96
5.4　Map 接口的默认方法　　97
5.5　默认方法冲突　　101
5.6　集合与映射的迭代　　103
5.7　利用Supplier 创建日志消息　　105
5.8　闭包复合　　107
5.9　利用提取的方法实现异常处理　　110
5.10　受检异常与lambda 表达式　　112
5.11　泛型异常包装器的应用　　114
第6章　Optional 类　　117
6.1　Optional 的创建　　118
6.2　从Optional 中检索值　　120
6.3　getter 和setter 方法中的Optional　　122
6.4　Optional.flatMap 与Optional.map 方法　　124
6.5　Optional 的映射　　127
第7章　文件I/O　　131
7.1　文件处理　　132
7.2　以流的形式检索文件　　134
7.3　文件系统的遍历　　135
7.4　文件系统的搜索　　137
第8章　java.time 包　　139
8.1　Date-Time API 中的基本类　　140
8.2　根据现有实例创建日期和时间　　143
8.3　调节器与查询　　147
8.4　将java.util.Date 转换为java.time.LocalDate　　152
8.5　解析与格式化　　155
8.6　查找具有非整数小时偏移量的时区　　158
8.7　根据UTC 偏移量查找地区名　　160
8.8　获取事件之间的时间　　162
第9章　并行与并发　　165
9.1　将顺序流转换为并行流　　166
9.2　并行流的优点　　169
9.3　调整线程池大小　　173
9.4　Future 接口　　175
9.5　完成CompletableFuture　　178
9.6　多个CompletableFuture 之间的协调（第1 部分）　　181
9.7　多个CompletableFuture 之间的协调（第2 部分）　　186
第10章　Java 9 新特性　　193
10.1　Jigsaw 中的模块　　194
10.2　接口中的私有方法　　198
10.3　创建不可变集合　　200
10.4　新增的Stream 方法　　204
10.5　下游收集器：filtering 与flatMapping　　207
10.6　新增的Optional 方法　　210
10.7　日期范围　　212
附录A　泛型与Java 8　　215
作者简介　　230
封面介绍　　230
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java攻略
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言规范
出版者的话
译者序
前言
第1章　概述 1
1.1　本书结构 1
1.2　样例程序 4
1.3　表示法 4
1.4　与预定义的类和接口的关系 4
1.5　反馈 5
1.6　参考文献 5
第2章　文法 6
2.1　上下文无关文法 6
2.2　词法 6
2.3　句法 6
2.4　文法表示法 6
第3章　词法结构 9
3.1　Unicode 9
3.2　词法翻译 10
3.3　Unicode转义字符 10
3.4　行终止符 11
3.5　输入元素和符号 12
3.6　空白字符 12
3.7　注释 13
3.8　标识符 14
3.9　关键字 15
3.10　字面常量 15
3.10.1　整数字面常量 15
3.10.2　浮点数字面常量 19
3.10.3　布尔字面常量 21
3.10.4　字符字面常量 21
3.10.5　字符串字面常量 22
3.10.6　字符和字符串字面常量的
转义序列 23
3.10.7　空字面常量 24
3.11　分隔符 24
3.12　操作符 24
第4章　类型、值和变量 25
4.1　类型和值的种类 25
4.2　简单类型和值 25
4.2.1　整数类型和值 26
4.2.2　整数操作 26
4.2.3　浮点数类型、格式和值 27
4.2.4　浮点数操作 29
4.2.5　boolean类型和布尔值 31
4.3　引用类型和值 32
4.3.1　对象 33
4.3.2　Object类 35
4.3.3　String类 35
4.3.4　当引用类型相同时 35
4.4　类型变量 36
4.5　参数化类型 37
4.5.1　参数化类型的类型引元 38
4.5.2　参数化类型的成员和构造器 40
4.6　类型擦除 40
4.7　可具化类型 41
4.8　原生类型 42
4.9　交集类型 45
4.10　子类型化 45
4.10.1　简单类型之间的子类型化 46
4.10.2　类与接口类型之间的子类型化 46
4.10.3　数组类型之间的子类型化 47
4.10.4　最低上边界 47
4.11　使用类型之处 49
4.12　变量 52
4.12.1　简单类型的变量 52
4.12.2　引用类型的变量 52
4.12.3　变量的种类 54
4.12.4　final变量 55
4.12.5　变量的初始值 56
4.12.6　类型、类和接口 57
第5章　类型转换与上下文 59
5.1　转换的种类 61
5.1.1　标识转换 61
5.1.2　拓宽简单类型转换 61
5.1.3　窄化简单类型转换 62
5.1.4　拓宽和窄化简单类型转换 64
5.1.5　拓宽引用类型转换 64
5.1.6　窄化引用类型转换 64
5.1.7　装箱转换 65
5.1.8　拆箱转换 66
5.1.9　非受检转换 67
5.1.10　捕获转换 67
5.1.11　字符串转换 69
5.1.12　被禁止的转换 69
5.1.13　值集转换 70
5.2　赋值上下文 70
5.3　方法调用上下文 74
5.4　字符串上下文 75
5.5　强制类型转换上下文 75
5.5.1　引用类型强制类型转换 77
5.5.2　受检强制类型转换和非受检强制类型转换 79
5.5.3　运行时的受检强制类型转换 80
5.6　数字上下文 81
5.6.1　一元数字提升 82
5.6.2　二元数字提升 83
第6章　名字 84
6.1　声明 84
6.2　名字与标识符 89
6.3　声明的作用域 91
6.4　遮蔽和遮掩 93
6.4.1　遮蔽 94
6.4.2　遮掩 96
6.5　确定名字的含义 97
6.5.1　根据上下文的名字的句法分类 98
6.5.2　对上下文歧义名字的重分类 100
6.5.3　包名的含义 101
6.5.4　PackageOrTypeNames的含义 102
6.5.5　类型名的含义 102
6.5.6　表达式名的含义 103
6.5.7　方法名的含义 105
6.6　访问控制 106
6.6.1　确定可访问性 107
6.6.2　受保护访问权限的细节 110
6.7　完全限定名和规范名 111
第7章　包 113
7.1　包成员 113
7.2　主机对包的支持 114
7.3　编译单元 115
7.4　包声明 116
7.4.1　具名包 116
7.4.2　不具名包 116
7.4.3　包的可观察性 117
7.5　导入声明 117
7.5.1　单类型导入声明 118
7.5.2　按需类型导入声明 119
7.5.3　单静态导入声明 120
7.5.4　按需静态导入声明 120
7.6　顶层类型声明 121
第8章　类 123
8.1　类声明 124
8.1.1　类修饰符 124
8.1.2　泛化类和类型参数 126
8.1.3　内部类和包围实例 128
8.1.4　超类和子类 130
8.1.5　超接口 132
8.1.6　类体和成员声明 134
8.2　类成员 135
8.3　域声明 138
8.3.1　域修饰符 141
8.3.2　域的初始化 145
8.3.3　在域初始化过程中的向前引用 146
8.4　方法声明 148
8.4.1　形参 149
8.4.2　方法签名 152
8.4.3　方法修饰符 152
8.4.4　泛化方法 156
8.4.5　方法的结果 157
8.4.6　方法抛出异常 157
8.4.7　方法体 158
8.4.8　继承、覆盖和隐藏 159
8.4.9　重载 166
8.5　成员类型声明 168
8.5.1　静态成员类型声明 169
8.6　实例初始化器 169
8.7　静态初始化器 169
8.8　构造器声明 170
8.8.1　形参 170
8.8.2　构造器签名 171
8.8.3　构造器修饰符 171
8.8.4　泛化构造器 172
8.8.5　构造器抛出异常 172
8.8.6　构造器的类型 172
8.8.7　构造器体 172
8.8.8　构造器重载 176
8.8.9　缺省构造器 176
8.8.10　阻止类的实例化 177
8.9　枚举类型 177
8.9.1　枚举常量 178
8.9.2　枚举体声明 178
8.9.3　枚举成员 180
第9章　接口 184
9.1　接口声明 184
9.1.1?接口修饰符 185
9.1.2　泛化接口和类型参数 185
9.1.3　超接口和子接口 186
9.1.4　接口体和成员声明 187
9.2　接口成员 187
9.3　域（常量）声明 187
9.3.1　接口中域的初始化 189
9.4　方法声明 189
9.4.1　继承和覆盖 190
9.4.2　重载 193
9.4.3　接口方法体 193
9.5　成员类型声明 193
9.6　注解类型 194
9.6.1　注解类型元素 195
9.6.2　注解类型元素的缺省值 197
9.6.3　可重复的注解类型 198
9.6.4　预定义的注解类型 200
9.7　注解 204
9.7.1　普通注解 205
9.7.2　标记注解 207
9.7.3　单元素注解 207
9.7.4　注解可以出现在何处 208
9.7.5　同种类型的多重注解 211
9.8　函数型接口 212
9.9 　函数类型 214
第10章　数组 218
10.1　数组类型 218
10.2　数组变量 219
10.3　数组创建 220
10.4　数组访问 220
10.5　数组存储异常 220
10.6　数组初始化器 221
10.7　数组成员 222
10.8　数组的Class对象 223
10.9　字符数组不是String 224
第11章　异常 225
11.1　异常的种类和成因 225
11.1.1　异常的种类 225
11.1.2　异常的成因 226
11.1.3　异步异常 226
11.2　异常的编译时检查 227
11.2.1　表达式异常分析 228
11.2.2　语句异常分析 228
11.2.3　异常检查 229
11.3　异常的运行时处理 230
第12章　执行 233
12.1　Java虚拟机启动 233
12.1.1　加载Test类 233
12.1.2　链接Test：校验、准备、（可选的）解析 233
12.1.3　初始化Test：执行初始化器 234
12.1.4　调用Test.main 234
12.2　加载类和接口 235
12.2.1　加载过程 235
12.3　链接类和接口 236
12.3.1　二进制表示的校验 236
12.3.2　类或接口类型的准备 236
12.3.3　符号引用的解析 237
12.4　初始化类和接口 237
12.4.1　当初始化发生时 238
12.4.2　详细的初始化过程 239
12.5　创建新的类实例 241
12.6　类实例的终结 243
12.6.1　实现终结 244
12.6.2　与内存模型的交互 245
12.7　卸载类和接口 246
12.8　程序退出 247
第13章　二进制兼容性 248
13.1　二进制形式 249
13.2　二进制兼容性到底是什么 252
13.3　包的演化 252
13.4　类的演化 253
13.4.1　abstract类 253
13.4.2　final类 253
13.4.3　public类 253
13.4.4　超类和超接口 253
13.4.5　类的类型参数 254
13.4.6　类体和成员声明 255
13.4.7　对成员和构造器的访问权限 256
13.4.8　域声明 257
13.4.9　final域和static
常量变量 258
13.4.10　static域 260
13.4.11　transient域 260
13.4.12　方法和构造器声明 260
13.4.13　方法和构造器的类型参数 261
13.4.14　方法和构造器的形式参数 261
13.4.15　方法返回类型 262
13.4.16　abstract方法 262
13.4.17　final方法 262
13.4.18　native方法 263
13.4.19　static方法 263
13.4.20　synchronized方法 263
13.4.21　方法和构造器的抛出物 263
13.4.22　方法和构造器体 263
13.4.23　方法和构造器的重载 264
13.4.24　方法覆盖 264
13.4.25　静态初始化器 264
13.4.26　枚举的演化 265
13.5　接口的演化 265
13.5.1　public接口 265
13.5.2　超接口 265
13.5.3　接口成员 265
13.5.4　接口的类型参数 266
13.5.5　域声明 266
13.5.6　接口方法声明 266
13.5.7　注解类型的演化 267
第14章　块和语句 268
14.1　语句的正常结束和猝然结束 268
14.2　块 269
14.3　局部类声明 269
14.4　局部变量声明语句 270
14.4.1　局部变量声明符和类型 271
14.4.2　局部变量声明的执行 271
14.5　语句 271
14.6　空语句 272
14.7　标号语句 273
14.8　表达式语句 274
14.9　if语句 274
14.9.1　if-then语句 274
14.9.2　if-then-else语句 275
14.10　assert语句 275
14.11　switch语句 277
14.12　while语句 280
14.12.1　while语句的猝然结束 280
14.13　do语句 281
14.13.1　do语句的猝然结束 281
14.14　for语句 282
14.14.1　基本for语句 282
14.14.2　增强for语句 284
14.15　break语句 285
14.16　continue语句 287
14.17　return语句 288
14.18　throw语句 289
14.19　synchronized语句 290
14.20　try语句 291
14.20.1　try-catch的执行 293
14.20.2　try-finally和try-catch-finally的执行 294
14.20.3　带资源的try 296
14.21　不可达语句 299
第15章　表达式 303
15.1　计算、表示和结果 303
15.2　表达式的形式 303
15.3　表达式的类型 304
15.4　FP-严格的表达式 304
15.5　表达式和运行时检查 305
15.6　计算的正常和猝然结束 306
15.7　计算顺序 307
15.7.1　首先计算左操作数 307
15.7.2　在操作之前计算操作数 308
15.7.3　计算遵循括号和优先级 309
15.7.4　引元列表是自左向右计算的 310
15.7.5　其他表达式的计算顺序 310
15.8　基本表达式 311
15.8.1　词法上的字面常量 312
15.8.2　类字面常量 312
15.8.3　this 313
15.8.4　限定的this 313
15.8.5　带括号的表达式 314
15.9　类实例创建表达式 314
15.9.1　确定要实例化的类 315
15.9.2　确定包围实例 316
15.9.3　选择构造器及其引元 317
15.9.4　类实例创建表达式的运行时计算 319
15.9.5　匿名类声明 320
15.10　数组创建和访问表达式 321
15.10.1　数组创建表达式 321
15.10.2　数组创建表达式的运行时执行 322
15.10.3　数组访问表达式 324
15.10.4　数组访问表达式的运行时计算 324
15.11　域访问表达式 326
15.11.1　使用基本表达式访问域 326
15.11.2　使用super访问超类成员 328
15.12　方法调用表达式 329
15.12.1　编译时的步骤1：确定要搜索的类或接口 330
15.12.2　编译时的步骤2：确定方法签名 332
15.12.3　编译时的步骤3：选中的方法是否合适 342
15.12.4　方法调用的运行时计算 343
15.13　方法引用表达式 350
15.13.1　方法引用的编译时声明 352
15.13.2　方法引用的类型 355
15.13.3　方法引用的运行时计算 356
15.14　后缀表达式 359
15.14.1　表达式名字 359
15.14.2　后缀递增操作符++ 359
15.14.3　后缀递减操作符-- 359
15.15　一元操作符 360
15.15.1　前缀递增操作符++ 361
15.15.2　前缀递减操作符-- 361
15.15.3　一元加号操作符+ 362
15.15.4　一元减号操作符- 362
15.15.5　按位取反操作符~ 362
15.15.6　逻辑取反操作符! 362
15.16　强制类型转换表达式 363
15.17　乘除操作符 364
15.17.1　乘法操作符* 364
15.17.2　除法操作符/ 365
15.17.3　取余操作符% 366
15.18　加减操作符 367
15.18.1　字符串连接操作符+ 368
15.18.2　用于数字类型的加减操作符　（+和-） 369
15.19　移位操作符 371
15.20　关系操作符 371
15.20.1　数字比较操作符<、<=、>和>= 372
15.20.2　类型比较操作符instanceof 372
15.21　判等操作符 373
15.21.1　数字判等操作符==和!= 373
15.21.2　布尔判等操作符==和!= 374
15.21.3　引用判等操作符==和!= 374
15.22　位操作符与逻辑操作符 375
15.22.1　整数位操作符&、^和| 375
15.22.2　布尔逻辑操作符&、^和| 376
15.23　条件与操作符&& 376
15.24　条件或操作符|| 376
15.25　条件操作符? : 377
15.25.1　布尔条件表达式 381
15.25.2　数字型条件表达式 381
15.25.3　引用条件表达式 382
15.26　赋值操作符 383
15.26.1　简单赋值操作符= 383
15.26.2　复合赋值操作符 387
15.27　lambda表达式 391
15.27.1　lambda参数 393
15.27.2　lambda体 394
15.27.3　lambda表达式的类型 397
15.27.4　lambda表达式的运行时计算 398
15.28　常量表达式 399
第16章　明确赋值 400
16.1　明确赋值和表达式 404
16.1.1　布尔常量表达式 404
16.1.2　条件与操作符&& 404
16.1.3　条件或操作符|| 404
16.1.4　逻辑取反操作符! 405
16.1.5　条件操作符? : 405
16.1.6　其他boolean类型的表达式 405
16.1.7　赋值表达式 406
16.1.8　操作符++和-- 406
16.1.9　其他表达式 406
16.2　明确赋值与语句 407
16.2.1　空语句 407
16.2.2　块 407
16.2.3　局部类声明语句 408
16.2.4　局部变量声明语句 408
16.2.5　标号语句 409
16.2.6　表达式语句 409
16.2.7　if语句 409
16.2.8　assert语句 409
16.2.9　switch语句 410
16.2.10　while语句 410
16.2.11　do语句 410
16.2.12　for语句 411
16.2.13　break、continue、return和throw语句 412
16.2.14　synchronized语句 412
16.2.15　try语句 412
16.3　明确赋值与参数 413
16.4　明确赋值与数组初始化器 413
16.5　明确赋值与枚举常量 413
16.6　明确赋值与匿名类 414
16.7　明确赋值与成员类型 414
16.8　明确赋值与静态初始化器 414
16.9　明确赋值、构造器和实例初始化器 415
第17章　线程与锁 416
17.1　同步 416
17.2　等待集和通知 417
17.2.1　等待 417
17.2.2　通知 418
17.2.3　中断 418
17.2.4　等待、通知和中断的交互 418
17.3　睡眠和让步 419
17.4　内存模型 419
17.4.1　共享变量 421
17.4.2　动作 421
17.4.3　程序和程序顺序 422
17.4.4　同步顺序 422
17.4.5　“之前发生”顺序 423
17.4.6　执行 425
17.4.7　良构执行 425
17.4.8　执行和因果关系要求 426
17.4.9　可观察的行为和不终止的执行 428
17.5　final域的语义 429
17.5.1　final域的语义 430
17.5.2　在构造阶段读final域 430
17.5.3　对final域的后续修改 431
17.5.4　写受保护的域 432
17.6　字撕裂 432
17.7　double和long的非原子化处理 433
第18章　类型推断 434
18.1　概念与表示法 435
18.1.1　推断变量 435
18.1.2　约束公式 435
18.1.3　边界 435
18.2　归纳 436
18.2.1　表达式可兼容性约束 437
18.2.2　类型可兼容性约束 440
18.2.3　子类型化约束 440
18.2.4　类型相等性约束 442
18.2.5　受检异常约束 442
18.3　合并 443
18.3.1　互补的边界对 444
18.3.2　涉及捕获转换的边界 444
18.4　解析 445
18.5　推断的使用 446
18.5.1　调用可应用性的推断 447
18.5.2　调用类型的推断 448
18.5.3　函数型接口的参数化版本推断 451
18.5.4　更具体方法的推断 452
第19章　语法 454
索引 470
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言规范
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言导学（英文版第6版）
第1章快速入门
关于Java技术
Java程序语言
Java平台
Java技术的功能
Java技术的优势
“Hello World！”示例程序
用NetBeans IDE开发“Hello World！”
在Microsoft Windows中开发“Hello World！”
在Solaris和Linux中开发“Hello World！”
“Hello World！”示例程序剖析
源码注释
HelloWorldApp类定义
main方法
常见问题（及其解决方案）
编译器问题
运行时问题
问题和练习：快速入门
问题
练习
答案
第2章面向对象的编程概念
对象
类
继承
接口
包
问题和练习：面向对象的编程概念
问题
练习
答案
第3章语言基础
变量
命名
基本数据类型
数组
小结
问题和练习：变量
运算符
赋值运算符、算术运算符和一元运算符
等式运算符、关系运算符和条件运算符
位运算符和移位运算符
小结
问题和练习：运算符
表达式、语句和块
表达式
语句
块
问题和练习：表达式、语句和块
控制流语句
if—then语句和if—then—else语句
switch语句
while语句和do—while语句
for语句
分支语句
小结
问题和练习：控制流语句
第4章类和对象
类
声明类
声明成员变量
定义方法
构建构造器
将消息传给方法或构造器
对象
创建对象
使用对象
类的更多细节
方法的返回值
使用this关键字
控制对类成员的访问
类成员
初始化字段
小结
问题和练习：类
问题和练习：对象
嵌套类
为什么使用嵌套类
静态嵌套类
内部类
隐藏
序列化
内部类示例
局部类和匿名类
修饰符
局部类
匿名类
Lambda表达式
何时使用嵌套类、局部类、匿名类和
Lambda表达式
问题和练习：嵌套类
枚举类型
问题和练习：枚举类型
第5章注解
注解的基本概念
注解格式
哪些地方使用注解
声明注解类型
预定义注解类型
Java语言使用的注解类型
应用于其他注解的注解类型
类型注解和可插拔类型系统
重复注解
步骤1：声明可重复的注解类型
步骤2：声明包含的注解类型
检索注解
设计注意事项
问题和练习：注解
问题
练习
答案
第6章接口与继承
接口
Java语言的接口
将接口用作API
定义接口
实现接口
将接口用作类型
演化接口
默认方法
小结
问题和练习：接口
继承
Java平台中类的层次结构
继承示例
子类能做什么
超类的私有成员
转换对象
状态、实现和类型的多继承
覆盖和屏蔽方法
多态性
屏蔽字段
使用super关键字
将对象用作超类
编写final类和方法
抽象方法和类
小结
问题和练习：继承
第7章泛型
为什么用泛型
泛型类型
一个简单的Box类
Box类的泛型版本
类型参数命名约定
泛型类型的调用和实例化
钻石运算符
多个类型参数
参数化类型
原生类型
泛型方法
受限类型参数
多重限制
泛型方法和受限类型参数
泛型、继承和子类型
泛型类和子类型
类型推导
类型推导与泛型方法
类型推导与泛型类的实例化
类型推导与泛型类和非泛型类的泛型
构造器
目标类型
通配符
上界通配符
界通配符
下界通配符
通配符和予类型
通配符匹配和辅助方法
通配符使用指南
类型擦除
泛型类型的擦除
泛型方法的擦除
类型擦除效果和桥方法
不可具体化类型和可变长参数方法
泛型的局限性
不能用基本数据类型实例化泛型类型
不能创建类型参数实例
不能声明类型为“类型参数”的静态字段
对参数化类型不能用类型转换或运算符
不能创建参数化类型数组
不能创建、捕获或抛出参数化类型的对象
不能重载方法，若方法每次重载的形式
参数类型都被擦为相同的原生类型
问题和练习：泛型
答案
第8章程序包
创建和使用程序包
创建程序包
命名程序包
使用程序包成员
管理源文件和类文件
小结
问题和练习：创建和使用程序包
问题
练习
答案
第9章，数和字符串
数
Number类
格式化数字打印输出
其他数学运算方法
自动装箱和拆箱
小结
问题和练习：数
字符
转义字符
字符串
创建字符串
字符串长度
字符串连接
创建格式字符串
数字和字符串之间的转换
操作字符串中的字符
比较字符串和字符串的子串
StringBuilder类
小结
问题和练习：字符和字符串
第10章异常
什么是异常
捕获或指明规定
三类异常
绕过捕获或指明
捕获和处理异常
try块
catch块
finally块
try—with—resources语句
汇总
指明一个方法抛出的异常
如何抛出异常
throw语句
Throwable类及其子类
Error类
Exception类
链式异常
创建异常类
未检查异常：争议
异常的优点
优点1：从正规代码中分离出错误处理代码
优点2：根据调用栈上传错误
优点3：分组和区分错误类型
小结
问题和练习
问题
练习
答案
第11章基本I／O和NIO.2
I／O流
字节流
字符流
缓冲流
扫描和格式化
命令行I／o
数据流
对象流
文件I／O（以NIO.2为特征）
什么是路径（以及其他文件系统情况）
Path类
文件操作
检查文件或目录
删除文件或目录
复制文件或目录
移动文件或目录
管理元数据（文件和文件存储属性）
读取、写入和创建文件
随机存取文件
创建和读取目录
符号链接或其他方式的链接
遍历文件树
查找文件
监视目录的变化
其他有用的方法
遗留文件的I／O代码
小结
问题和练习：基本I／O
问题
练习
答案
……
第12章集合
第13章并发
第14章正则表达式
第15章平台环境
第16章在JAR文件中打包程序
第17章Java WebStan
第18章印plet
第19章Java富互联网应用系统
第20章深入理解部署
第21章日期／时间API
第22章JavaFX简介
附录Java程序语言认证复习大纲
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java语言导学（英文版第6版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>写给大忙人看的Java核心技术
第1章　基本的编程结构............................................................................................. 1
1.1　第一个程序 ............................................................................................... 2
1.1.1　“Hello，World”程序解析 ............................................................................. 2
1.1.2　编译与运行Java程序 ......................................................................................... 3
1.1.3　方法调用 ............................................................................................................ 5
1.2　基本类型 ................................................................................................. 7
1.2.1　整型 .................................................................................................................... 7
1.2.2　浮点类型 ............................................................................................................ 8
1.2.3　char型 ................................................................................................................. 9
1.2.4　布尔型 .............................................................................................................. 10
1.3　变量 .......................................................................................... 10
1.3.1　变量的声明 ...................................................................................................... 10
1.3.2　名称 .................................................................................................................. 10
1.3.3　初始化 ...............................................................................................................11
1.3.4　常量 ...................................................................................................................11
1.4　算术操作 .................................................................................................... 13
1.4.1　赋值 .................................................................................................................. 13
1.4.2　基本运算 .......................................................................................................... 14
1.4.3　数学方法 .......................................................................................................... 15
1.4.4　数字类型转换 .................................................................................................. 16
1.4.5　关系和逻辑操作符 .......................................................................................... 17
1.4.6　大数 .................................................................................................................. 19
1.5　字符串 ................................................................................................. 19
1.5.1　字符串连接 ...................................................................................................... 20
1.5.2　子字符串 .......................................................................................................... 21
1.5.3　字符串比较 ...................................................................................................... 21
1.5.4　数字与字符串转换 .......................................................................................... 23
1.5.5　String类API ...................................................................................................... 24
1.5.6　编码点（code point）和编码单元（code unit） ........................................... 25
1.6　输入与输出 .......................................................................................... 26
1.6.1　读取输入 .......................................................................................................... 27
1.6.2　格式化输出 ...................................................................................................... 28
1.7　控制流 ........................................................................................................... 30
1.7.1　分支 .................................................................................................................. 30
1.7.2　循环 .................................................................................................................. 32
1.7.3　跳出循环与继续循环 ...................................................................................... 34
1.7.4　局部变量作用域 .............................................................................................. 36
1.8　数组和数组列表 ................................................................................. 38
1.8.1　使用数组 .......................................................................................................... 38
1.8.2　构造数组 .......................................................................................................... 39
1.8.3　数组列表 .......................................................................................................... 39
1.8.4　基本类型包装类 .............................................................................................. 41
1.8.5　增强的for循环 ................................................................................................. 41
1.8.6　数组与数组列表的复制 .................................................................................. 42
1.8.7　数组算法 .......................................................................................................... 43
1.8.8　命令行参数 ...................................................................................................... 44
1.8.9　多维数组 .......................................................................................................... 45
1.9　功能分解 ............................................................................................. 48
1.9.1　静态方法的声明与调用 .................................................................................. 48
1.9.2　数组参数与返回值 .......................................................................................... 48
1.9.3　可变参数 .......................................................................................................... 49
练习 ..................................................................................................................... 50
第2章　面向对象编程............................................................................................... 53
2.1　使用对象 .............................................................................................. 54
2.1.1　Accessor（访问器）和Mutator（更改器）方法 ........................................... 56
2.1.2　对象引用 .......................................................................................................... 56
2.2　实现类 ............................................................................................... 58
2.2.1　实例变量 .......................................................................................................... 58
2.2.2　方法头 .............................................................................................................. 59
2.2.3　方法体 .............................................................................................................. 59
2.2.4　实例方法调用 .................................................................................................. 60
2.2.5　this引用 ............................................................................................................ 61
2.2.6　值调用 .............................................................................................................. 62
2.3　构造对象 .......................................................................................... 63
2.3.1　实现构造函数 .................................................................................................. 64
2.3.2　重载 .................................................................................................................. 64
2.3.3　调用另一个构造函数 ...................................................................................... 65
2.3.4　默认初始化 ...................................................................................................... 66
2.3.5　实例变量初始化 .............................................................................................. 66
2.3.6　final实例变量 ................................................................................................... 67
2.3.7　无参构造函数 .................................................................................................. 68
2.4　静态变量和方法 ...................................................................... 69
2.4.1　静态变量 .......................................................................................................... 69
2.4.2　静态常量 .......................................................................................................... 70
2.4.3　静态初始块 ...................................................................................................... 71
2.4.4　静态方法 .......................................................................................................... 71
2.4.5　工厂方法 .......................................................................................................... 73
2.5　包 ........................................................................................................ 73
2.5.1　包的声明 .......................................................................................................... 74
2.5.2　类路径 .............................................................................................................. 75
2.5.3　包作用域 .......................................................................................................... 77
2.5.4　导入包 .............................................................................................................. 78
2.5.5　静态导入 .......................................................................................................... 79
2.6　嵌套类 .............................................................................................. 80
2.6.1　静态嵌套类 ...................................................................................................... 80
2.6.2　内部类 .............................................................................................................. 82
2.6.3　内部类的特殊语法 .......................................................................................... 85
2.7　文档注释 ......................................................................................... 86
2.7.1　插入注释 .......................................................................................................... 86
2.7.2　类注释 .............................................................................................................. 87
2.7.3　方法注释 .......................................................................................................... 88
2.7.4　变量注释 .......................................................................................................... 88
2.7.5　通用注释 .......................................................................................................... 89
2.7.6　链接 .................................................................................................................. 89
2.7.7　包和概述注释 .................................................................................................. 90
2.7.8　注释的提取 ...................................................................................................... 90
练习 ................................................................................................................. 91
第3章　接口和lambda表达式................................................................................... 95
3.1　接口 ....................................................................................................... 96
3.1.1　声明接口 .......................................................................................................... 96
3.1.2　实现接口 .......................................................................................................... 97
3.1.3　转换为接口类型 .............................................................................................. 99
3.1.4　强制类型转换（cast）和instanceof操作符 ................................................... 99
3.1.5　继承接口 ........................................................................................................ 100
3.1.6　实现多个接口 ................................................................................................ 101
3.1.7　常量 ................................................................................................................ 101
3.2　静态方法和默认方法 ....................................................................... 101
3.2.1　静态方法 ........................................................................................................ 102
3.2.2　默认方法 ........................................................................................................ 102
3.2.3　解决默认方法冲突 ........................................................................................ 103
3.3　接口示例 ........................................................................................ 105
3.3.1　Comparable接口 ............................................................................................. 105
3.3.2　Comparator接口 ............................................................................................. 107
3.3.3　Runable接口 ................................................................................................... 108
3.3.4　UI（User Interface）回调 ............................................................................. 109
3.4　lambda表达式 .........................................................................................110
3.4.1　lambda表达式语法 .........................................................................................110
3.4.2　函数式接口 .....................................................................................................111
3.5　方法引用和构造函数引用 .........................................................112
3.5.1　方法引用 .........................................................................................................113
3.5.2　构造函数引用 ......................................................................114
3.6　使用lambda表达式 ...............................................................................115
3.6.1　实现延迟执行 .................................................................................................115
3.6.2　选择函数式接口 .............................................................................................116
3.6.3　实现自己的函数式接口 .................................................................................118
3.7　lambda表达式和变量作用域 .....................................................119
3.7.1　lambda表达式的作用域 .................................................................................119
3.7.2　访问来自闭合作用域的变量 ........................................................................ 120
3.8　高阶函数 .......................................................................................... 123
3.8.1　返回函数的方法 ............................................................................................ 123
3.8.2　修改函数的方法 ............................................................................................ 123
3.8.3　Comparator方法 ............................................................................................. 124
3.9　局部内部类 ....................................................................... 125
3.9.1　局部类 ............................................................................................................ 125
3.9.2　匿名类 ............................................................................................................ 126
练习 .................................................................................................................................... 127
第4章　继承与反射................................................................................................ 131
4.1　继承一个类 ......................................................................................... 132
4.1.1　父类与子类 .................................................................................................... 132
4.1.2　定义和继承子类方法 .................................................................................... 132
4.1.3　方法覆盖 ........................................................................................................ 133
4.1.4　子类的构造 .................................................................................................... 134
4.1.5　父类赋值 ........................................................................................................ 135
4.1.6　转换 ................................................................................................................ 136
4.1.7　final方法和类 ................................................................................................. 136
4.1.8　抽象方法和类 ................................................................................................ 137
4.1.9　受保护访问 .................................................................................................... 138
4.1.10　匿名子类 ...................................................................................................... 139
4.1.11　继承和默认方法 .......................................................................................... 140
4.1.12　带super的方法表达式 ................................................................................. 141
4.2　Object：终极父类...................................................................................................... 141
4.2.1　toString方法 ................................................................................................... 142
4.2.2　equals方法 ...................................................................................................... 144
4.2.3　hashCode方法 ................................................................................................ 147
4.2.4　克隆对象 ........................................................................................................ 148
4.3　枚举 ...................................................................................................... 151
4.3.1　枚举方法 ........................................................................................................ 152
4.3.2　构造函数、方法和域 .................................................................................... 153
4.3.3　实例的实现体 ................................................................................................ 153
4.3.4　静态成员 ........................................................................................................ 154
4.3.5　switch枚举对象 .............................................................................................. 155
4.4　运行时类型信息和资源 ........................................................................... 156
4.4.1　Class类 ........................................................................................................... 156
4.4.2　资源加载 ........................................................................................................ 160
4.4.3　类加载器 ........................................................................................................ 160
4.4.4　上下文类加载器 ............................................................................................ 162
4.4.5　服务加载器 .................................................................................................... 164
4.5　反射 .............................................................................................. 165
4.5.1　枚举类成员 .................................................................................................... 165
4.5.2　对象检查 ........................................................................................................ 167
4.5.3　方法调用 ........................................................................................................ 167
4.5.4　对象构造 ........................................................................................................ 168
4.5.5　JavaBeans ....................................................................................................... 169
4.5.6　使用数组 ........................................................................................................ 170
4.5.7　代理 ................................................................................................................ 172
练习 .................................................................................................................................... 174
第5章　异常、断言和日志处理.............................................................................. 177
5.1　异常处理 ............................................................................................. 178
5.1.1　异常抛出 ........................................................................................................ 178
5.1.2　异常继承层次 ................................................................................................ 179
5.1.3　已检查异常的声明 ........................................................................................ 181
5.1.4　异常捕获 ........................................................................................................ 182
5.1.5　try-with-resources语句 ................................................................................... 183
5.1.6　finally子句 ...................................................................................................... 185
5.1.7　异常重抛和链接 ............................................................................................ 186
5.1.8　堆栈踪迹 ........................................................................................................ 188
5.1.9　Objects.requireNonNull方法 .......................................................................... 189
5.2　断言 ........................................................................................................ 189
5.2.1　使用断言 ........................................................................................................ 190
5.2.2　启用和禁用断言 ............................................................................................ 191
5.3　记录日志 .................................................................................... 191
5.3.1　采用Logger ..................................................................................................... 192
5.3.2　日志记录器 .................................................................................................... 192
5.3.3　日志级别 ........................................................................................................ 192
5.3.4　其他日志记录方法 ........................................................................................ 193
5.3.5　日志记录的配置项 ........................................................................................ 195
5.3.6　日志处理器 .................................................................................................... 196
5.3.7　过滤器和格式化器 ........................................................................................ 199
练习 ......................................................................................................... 199
第6章　泛型编程.................................................................................................... 203
6.1　泛型类 ...................................................................................................... 204
6.2　泛型方法 ................................................................................................. 205
6.3　类型限定 .................................................................................................................. 206
6.4　类型变异和通配符 ................................................................................................. 207
6.4.1　子类型通配符 ................................................................................................ 208
6.4.2　父类型通配符 ................................................................................................ 209
6.4.3　带类型变量的通配符 .................................................................................... 210
6.4.4　无限定通配符 ................................................................................................ 212
6.4.5　通配符捕获 .................................................................................................... 212
6.5　Java虚拟机中的泛型 ............................................................................................ 213
6.5.1　类型擦除 ........................................................................................................ 213
6.5.2　转换插入 ........................................................................................................ 214
6.5.3　桥方法 ............................................................................................................ 215
6.6　泛型约束 .............................................................................................................. 216
6.6.1　无基本类型参数 ............................................................................................ 217
6.6.2　所有类型在运行时都是原始的 .................................................................... 217
6.6.3　不能实例化类型变量 .................................................................................... 218
6.6.4　不能构造参数化类型的数组 ........................................................................ 220
6.6.5　静态上下文中的类类型变量不是有效的 .................................................... 221
6.6.6　类型擦除后的方法可能不冲突 .................................................................... 222
6.6.7　异常与泛型 .................................................................................................... 223
6.7　反射与泛型 .................................................................................................. 224
6.7.1　Class<T>类 .................................................................................................... 224
6.7.2　虚拟机中的泛型类型信息 ............................................................................ 225
练习 .................................................................................................................................... 227
第7章　集合........................................................................................................... 233
7.1　集合类框架概要 ........................................................................................ 234
7.2　迭代器 ............................................................................................... 238
7.3　set ............................................................................................................................... 240
7.4　map .......................................................................................................................... 241
7.5　其他集合 ......................................................................................................... 245
7.5.1　Properties ........................................................................................................ 245
7.5.2　位组 ................................................................................................................ 247
7.5.3　枚举set和枚举map ......................................................................................... 248
7.5.4　栈、队列、双端队列、优先级队列 ............................................................ 249
7.5.5　弱哈希映射表 ................................................................................................ 250
7.6　视图 ......................................................................................................................... 251
7.6.1　范围（range） ............................................................................................... 251
7.6.2　空视图和单例视图 ........................................................................................ 252
7.6.3　不可修改的视图 ............................................................................................ 252
练习 ................................................................................................................................. 253
第8章　Stream....................................................................................................... 257
8.1　从迭代到Stream操作 .............................................................................................. 258
8.2　创建Stream .............................................................................................................. 259
8.3　filter、map和flatMap方法 ...................................................................................... 261
8.4　提取子流和组合流 ......................................................................................... 262
8.5　其他流转换 ................................................................................................... 263
8.6　简单归约 .................................................................................................... 264
8.7　Optional类型 ................................................................................................. 265
8.7.1　如何使用Optional类型值 .............................................................................. 265
8.7.2　如何不使用Optional类型值 .......................................................................... 266
8.7.3　创建Optional类型值 ...................................................................................... 267
8.7.4　使用flatMap来组合可选值函数 .................................................................... 267
8.8　收集结果 ................................................................................................... 268
8.9　将结果收集到map中 ................................................................................... 270
8.10　分组和分片 ........................................................................................... 271
8.11　下游收集器 .............................................................................................. 272
8.12　归约操作 ............................................................................................................... 274
8.13　基本类型流 ........................................................................................................... 276
8.14　并行流 ................................................................................................................... 278
练习 .................................................................................................................................. 280
第9章　输入与输出处理......................................................................................... 285
9.1　输入/输出流：Reader和Writer ................................................................................. 286
9.1.1　获取流对象 .................................................................................................... 286
9.1.2　读取字节 ........................................................................................................ 287
9.1.3　写字节 ............................................................................................................ 288
9.1.4　字符集编码 .................................................................................................... 288
9.1.5　文本输入 ........................................................................................................ 291
9.1.6　文本输出 ........................................................................................................ 292
9.1.7　读写二进制数据 ............................................................................................ 294
9.1.8　随机存取文件 ................................................................................................ 295
9.1.9　内存映射文件 ................................................................................................ 295
9.1.10　文件锁 .......................................................................................................... 296
9.2　路径、文件和目录 ............................................................................................... 297
9.2.1　路径 ................................................................................................................ 297
9.2.2　创建文件和目录 ............................................................................................ 299
9.2.3　复制、移动和删除文件 ................................................................................ 300
9.2.4　访问目录内容 ................................................................................................ 301
9.2.5　ZIP文件系统 .................................................................................................. 304
9.3　URL连接 ................................................................................................................ 305
9.4　正则表达式 ............................................................................................................ 307
9.4.1　正则表达式语法 ............................................................................................ 307
9.4.2　匹配一个或多个 .............................................................................................311
9.4.3　分组 ................................................................................................................ 312
9.4.4　消除或替换匹配结果 .................................................................................... 313
9.4.5　标记 ................................................................................................................ 314
9.5　序列化 ..................................................................................................... 315
9.5.1　Serializable接口 ............................................................................................. 315
9.5.2　瞬态实例变量 ................................................................................................ 317
9.5.3　readObject和writeObject方法 ........................................................................ 317
9.5.4　readResolve和writeReplace方法 ................................................................... 319
9.5.5　版本化 ............................................................................................................ 320
练习 ..................................................................................................................... 321
第10章　并发编程.................................................................................................. 325
10.1　并发任务 ................................................................................................. 326
10.1.1　运行任务 .................................................................................................... 326
10.1.2　Future和Executor服务 ............................................................................... 328
10.2　线程安全 ................................................................................................. 331
10.2.1　可见性 ........................................................................................................ 331
10.2.2　竞争条件 .................................................................................................... 333
10.2.3　安全并发的策略 ........................................................................................ 336
10.2.4　不可变类 .................................................................................................... 336
10.3　并行算法 ............................................................................................ 337
10.3.1　并行流 ........................................................................................................ 338
10.3.2　并行数组操作 ............................................................................................ 338
10.4　线程安全的数据结构 .............................................................................. 339
10.4.1　ConcurrentHashMap .................................................................................. 340
10.4.2　阻塞队列 .................................................................................................... 341
10.4.3　其他线程安全的数据结构 ........................................................................ 343
10.5　原子值 ................................................................................................... 344
10.6　锁 ........................................................................................................ 346
10.6.1　可重入锁（ReentrantLock） .................................................................... 347
10.6.2　synchronized关键字................................................................................... 348
10.6.3　条件等待 .................................................................................................... 350
10.7　线程 ...................................................................................................... 352
10.7.1　启动线程 .................................................................................................... 352
10.7.2　线程中断 .................................................................................................... 353
10.7.3　线程变量 .................................................................................................... 355
10.7.4　线程的其他属性 ........................................................................................ 356
10.8　异步计算 ....................................................................................................... 356
10.8.1　UI回调中的长期运行任务 ........................................................................ 356
10.8.2　可完成的future .......................................................................................... 358
10.9　进程 .............................................................................................. 361
10.9.1　构建进程 .................................................................................................... 361
10.9.2　运行进程 .................................................................................................... 363
练习 .................................................................................................. 364
第11章　注解......................................................................................................... 371
11.1　使用注解 ......................................................................................... 372
11.1.1　注解元素 .................................................................................................... 372
11.1.2　多注解和重复注解 .................................................................................... 373
11.1.3　注解声明 .................................................................................................... 374
11.1.4　注解类型用途 ............................................................................................ 375
11.1.5　明确接收者 ................................................................................................ 376
11.2　定义注解 ......................................................................................... 378
11.3　标准注解 ................................................................................................ 380
11.3.1　编译相关的注解 ........................................................................................ 381
11.3.2　资源管理相关的注解 ................................................................................ 382
11.3.3　元注解 ........................................................................................................ 382
11.4　运行时注解处理 ................................................................................. 384
11.5　源码级注解处理 .................................................................................. 387
11.5.1　注解处理器 ................................................................................................ 388
11.5.2　语言模型API.............................................................................................. 388
11.5.3　使用注解生成源码 .................................................................................... 389
练习 ............................................................................................. 392
第12章　日期和时间API......................................................................................... 395
12.1　时间线 ....................................................................................................... 396
12.2　本地日期 ........................................................................................... 398
12.3　日期调整器 ............................................................................................. 401
12.4　本地时间 ................................................................................................. 402
12.5　时区时间 ................................................................................ 403
12.6　格式化和解析 .............................................................................. 406
12.7　应对遗留代码 ................................................................................. 409
练习 ............................................................................................................411
第13章　国际化...................................................................................................... 413
13.1　本地化 ............................................................................................ 414
13.1.1　指定本地化 ................................................................................................ 414
13.1.2　默认locale .................................................................................................. 417
13.1.3　显示名称 .................................................................................................... 418
13.2　数字格式化 ........................................................................................... 418
13.3　货币符号 ................................................................................................. 419
13.4　日期和时间格式化 ......................................................................... 420
13.5　排序和规格化 ........................................................................................... 422
13.6　消息格式化 ........................................................................................ 424
13.7　资源束 ................................................................................................... 426
13.7.1　组织资源束 ................................................................................................ 426
13.7.2　资源束类 .................................................................................................... 428
13.8　字符集编码 ................................................................................. 429
13.9　首选项 ............................................................................................... 430
练习 ................................................................................................................ 432
第14章　编译与脚本.............................................................................................. 435
14.1　编译器API ................................................................................................................ 435
14.1.1　调用编译器 ................................................................................................ 436
14.1.2　启动编译任务 ............................................................................................ 436
14.1.3　从内存读取源文件 .................................................................................... 437
14.1.4　向内存写入字节码 .................................................................................... 438
14.1.5　捕获诊断信息 ............................................................................................ 440
14.2　脚本API .................................................................................................................... 440
14.2.1　获取脚本引擎 ............................................................................................ 440
14.2.2　绑定 ............................................................................................................ 441
14.2.3　重定向输入与输出 .................................................................................... 442
14.2.4　调用脚本函数和方法 ................................................................................ 443
14.2.5　编译脚本 .................................................................................................... 444
14.3　Nashorn脚本引擎 .............................................................................. 445
14.3.1　从命令行运行Nashorn .............................................................................. 445
14.3.2　调用get、set和重载方法 .......................................................................... 446
14.3.3　构造Java对象 ............................................................................................. 447
14.3.4　JavaScript和Java中的字符串 .................................................................... 449
14.3.5　数字 ............................................................................................................ 449
14.3.6　使用数组 .................................................................................................... 450
14.3.7　列表与映射 ................................................................................................ 451
14.3.8　lambda表达式 ............................................................................................ 452
14.3.9　继承Java类与实现Java接口 ...................................................................... 453
14.3.10　异常 .......................................................................................................... 455
14.4　shell脚本与Nashorn .............................................................................. 455
14.4.1　执行shell命令 ............................................................................................ 456
14.4.2　字符串插值 ................................................................................................ 456
14.4.3　脚本输入 .................................................................................................... 457
练习 .................................................................................................... 458
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>写给大忙人看的Java核心技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java虚拟机规范（Java SE 8版）
译者序
前　言
第1章　引言1
1.1　简史1
1.2　Java虚拟机2
1.3　各章节摘要2
1.4　说明3
1.5　反馈3
第2章　Java虚拟机结构4
2.1　class文件格式4
2.2　数据类型5
2.3　原始类型与值5
2.3.1　整数类型与整型值6
2.3.2　浮点类型、取值集合及浮点值6
2.3.3　returnAddress类型和值8
2.3.4　boolean类型8
2.4　引用类型与值9
2.5　运行时数据区9
2.5.1　pc寄存器9
2.5.2　Java虚拟机栈10
2.5.3　Java堆10
2.5.4　方法区11
2.5.5　运行时常量池11
2.5.6　本地方法栈12
2.6　栈帧12
2.6.1　局部变量表13
2.6.2　操作数栈14
2.6.3　动态链接14
2.6.4　方法调用正常完成15
2.6.5　方法调用异常完成15
2.7　对象的表示15
2.8　浮点算法15
2.8.1　Java虚拟机和IEEE 754中的浮点算法15
2.8.2　浮点模式16
2.8.3　数值集合转换17
2.9　特殊方法18
2.10　异常19
2.11　字节码指令集简介20
2.11.1　数据类型与Java虚拟机21
2.11.2　加载和存储指令23
2.11.3　算术指令24
2.11.4　类型转换指令25
2.11.5　对象的创建与操作27
2.11.6　操作数栈管理指令27
2.11.7　控制转移指令27
2.11.8　方法调用和返回指令28
2.11.9　抛出异常28
2.11.10　同步28
2.12　类库29
2.13　公有设计、私有实现30
第3章　Java虚拟机编译器31
3.1　示例的格式说明31
3.2　常量、局部变量和控制结构的使用32
3.3　算术运算36
3.4　访问运行时常量池36
3.5　与控制结构有关的更多示例37
3.6　接收参数40
3.7　方法调用41
3.8　使用类实例43
3.9　数组44
3.10　编译switch语句46
3.11　使用操作数栈48
3.12　抛出异常和处理异常48
3.13　编译finally语句块51
3.14　同步54
3.15　注解55
第4章　class文件格式56
4.1　ClassFile结构57
4.2　各种名称的内部表示形式61
4.2.1　类和接口的二进制名称61
4.2.2　非限定名61
4.3　描述符62
4.3.1　语法符号62
4.3.2　字段描述符62
4.3.3　方法描述符63
4.4　常量池64
4.4.1　CONSTANT_Class_info结构65
4.4.2　CONSTANT_Fieldref_info、CONSTANT_Methodref_info和CONSTANT_InterfaceMethodref_info结构66
4.4.3　CONSTANT_String_info结构67
4.4.4　CONSTANT_Integer_info和CONSTANT_Float_info结构67
4.4.5　CONSTANT_Long_info和CONSTANT_Double_info结构68
4.4.6　CONSTANT_NameAnd-Type_info结构69
4.4.7　CONSTANT_Utf8_info结构70
4.4.8　CONSTANT_MethodHandle_info结构72
4.4.9　CONSTANT_MethodType_info结构73
4.4.10　CONSTANT_Invoke-Dynamic_info结构74
4.5　字段74
4.6　方法76
4.7　属性78
4.7.1　自定义和命名新的属性82
4.7.2　ConstantValue属性82
4.7.3　Code属性83
4.7.4　StackMapTable属性86
4.7.5　Exceptions属性92
4.7.6　InnerClasses属性93
4.7.7　EnclosingMethod属性95
4.7.8　Synthetic属性96
4.7.9　Signature属性96
4.7.10　SourceFile属性100
4.7.11　SourceDebugExtension属性101
4.7.12　LineNumberTable属性102
4.7.13　LocalVariableTable属性103
4.7.14　LocalVariableTypeTable属性104
4.7.15　Deprecated属性106
4.7.16　RuntimeVisibleAnnota-tions属性106
4.7.17　RuntimeInvisible-Annotations属性110
4.7.18　RuntimeVisibleParameterAnnotations属性111
4.7.19　RuntimeInvisiblePara-meterAnnotations属性112
4.7.20　RuntimeVisibleTypeAnnotations属性114
4.7.21　RuntimeInvisibleType-Annotations属性124
4.7.22　AnnotationDefault属性125
4.7.23　BootstrapMethods属性126
4.7.24　MethodParameters属性127
4.8　格式检查129
4.9　Java虚拟机代码约束129
4.9.1　静态约束130
4.9.2　结构化约束132
4.10　class文件校验135
4.10.1　类型检查验证136
4.10.2　类型推导验证200
4.11　Java虚拟机限制206
第5章　加载、链接与初始化208
5.1　运行时常量池208
5.2　虚拟机启动210
5.3　创建和加载211
5.3.1　使用引导类加载器来加载类型212
5.3.2　使用用户自定义类加载器来加载类型212
5.3.3　创建数组类213
5.3.4　加载限制214
5.3.5　从class文件表示得到类214
5.4　链接215
5.4.1　验证216
5.4.2　准备216
5.4.3　解析217
5.4.4　访问控制225
5.4.5　方法覆盖225
5.5　初始化226
5.6　绑定本地方法实现228
5.7　Java虚拟机退出228
第6章　Java虚拟机指令集229
6.1　设定：“必须”的含义229
6.2　保留操作码229
6.3　虚拟机错误230
6.4　指令描述格式230
6.5　指令集描述232
第7章　操作码助记符320
附录A　Limited License Grant327
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java虚拟机规范（Java SE 8版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>写给大忙人看的Java SE 8
第1章  lambda表达式	0
1.1  为什么要使用lambda表达式	2
1.2  lambda表达式的语法	4
1.3  函数式接口	6
1.4  方法引用	8
1.5  构造器引用	10
1.6  变量作用域	10
1.7  默认方法	14
1.8  接口中的静态方法	17
练习	18
第2章  Stream API	20
2.1  从迭代器到Stream操作	22
2.2  创建Stream	23
2.3  filter、map和flatMap方法	25
2.4  提取子流和组合流	26
2.5  有状态的转换	27
2.6  简单的聚合方法	28
2.7  Optional类型	29
2.7.1  使用Optional值	29
2.7.2  创建可选值	30
2.7.3  使用flatMap来组合可选值函数	31
2.8  聚合操作	32
2.9  收集结果	33
2.10  将结果收集到Map中	35
2.11  分组和分片	37
2.12  原始类型流	40
2.13  并行流	42
2.14  函数式接口	44
练习	45
第3章使用lambda编程	48
3.1  延迟执行	50
3.2  lambda表达式的参数	51
3.3  选择一个函数式接口	52
3.4  返回函数	55
3.5  组合	56
3.6  延迟	58
3.7  并行操作	59
3.8  处理异常	60
3.9  lambda表达式和泛型	63
3.10  一元操作	65
练习	67
第4章  JavaFX	72
4.1  Java GUI编程简史	74
4.2  你好，JavaFX！	75
4.3  事件处理	76
4.4  JavaFX属性	77
4.5  绑定	80
4.6  布局	85
4.7  FXML	91
4.8  CSS	95
4.9  动画和特殊效果	97
4.10  不寻常的控件	100
练习	103
第5章新的日期和时间API	106
5.1  时间线	108
5.2  本地日期	110
5.3  日期校正器	113
5.4  本地时间	114
5.5  带时区的时间	115
5.6  格式化和解析	119
5.7  与遗留代码互操作	122
练习	123
第6章并发增强	126
6.1  原子值	128
6.2  ConcurrentHashMap改进	131
6.2.1  更新值	132
6.2.2  批量数据操作	134
6.2.3  Set视图	136
6.3  并行数组操作	137
6.4  可完成的Future	138
6.4.1  Future	138
6.4.2  编写Future	139
6.4.3  Future流水线	139
6.4.4  编写异步操作	141
练习	143
第7章  JavaScript引擎——Nashorn	146
7.1  从命令行运行Nashorn	148
7.2  从Java运行Nashorn	149
7.3  调用方法	150
7.4  构造对象	151
7.5  字符串	153
7.6  数字	153
7.7  使用数组	154
7.8  列表和映射	155
7.9  lambda表达式	156
7.10  继承Java类及实现Java接口	157
7.11  异常	158
7.12  Shell脚本	159
7.12.1  执行Shell命令	159
7.12.2  字符串插值	160
7.12.3  脚本输入	161
7.13  Nashorn和JavaFX	162
练习	164
第8章杂项改进	166
8.1  字符串	168
8.2  数字类	168
8.3  新的数学函数	169
8.4  集合	170
8.4.1  集合类中添加的方法	170
8.4.2  比较器	171
8.4.3  Collections类	173
8.5  使用文件	173
8.5.1  读取文件行的流	173
8.5.2  遍历目录项的流	175
8.5.3  Base64编码	176
8.6  注解	177
8.6.1  可重复的注解	177
8.6.2  可用于类型的注解	179
8.6.3  方法参数反射	181
8.7  其他一些细微的改进	182
8.7.1  Null检查	182
8.7.2  延迟消息	182
8.7.3  正则表达式	183
8.7.4  语言环境	183
8.7.5  JDBC	185
练习	185
第9章你可能错过的Java 7特性	188
9.1  异常处理改进	190
9.1.1  try-with-resources语句	190
9.1.2  忽略异常	191
9.1.3  捕获多个异常	192
9.1.4  更简单地处理反射方法的异常	193
9.2  使用文件	193
9.2.1  Path	194
9.2.2  读取和写入文件	196
9.2.3  创建文件和目录	197
9.2.4  复制、移动和删除文件	198
9.3  实现equals、hashCode和compareTo方法	198
9.3.1  安全的Null值相等测试	198
9.3.2  计算哈希码	199
9.3.3  比较数值类型对象	200
9.4  安全需要	201
9.5  其他改动	204
9.5.1  将字符串转换为数字	204
9.5.2  全局Logger	204
9.5.3  Null检查	205
9.5.4  ProcessBuilder	205
9.5.5  URLClassLoader	206
9.5.6  BitSet	206
练习	207
索引	209
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>写给大忙人看的Java SE 8
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java完全参考手册
目 录
第Ⅰ部分 Java语言
第1章 Java的历史和演变 .................... 3
1.1 Java的家世 ................................. 4
1.1.1 现代编程语言的诞生：
C语言 ...................................... 4
1.1.2 C++：下一个阶段 ................... 5
1.1.3 Java出现的时机已经成熟 ..... 6
1.2 Java的诞生 ................................. 6
1.3 Java改变Internet的方式 ........... 8
1.3.1 Java applet ................................ 8
1.3.2 安全性 ...................................... 8
1.3.3 可移植性 .................................. 9
1.4 Java的魔力：字节码 ................. 9
1.5 servlet：服务器端的Java ......... 10
1.6 Java的关键特性 ....................... 10
1.6.1 简单性 ................................... 10
1.6.2 面向对象 ............................... 11
1.6.3 健壮性 ................................... 11
1.6.4 多线程 ................................... 11
1.6.5 体系结构中立 ....................... 11
1.6.6 解释执行和高性能................ 12
1.6.7 分布式 ................................... 12
1.6.8 动态性 ................................... 12
1.7 Java的演变历程 ....................... 12
1.8 文化革新 ................................... 15
Java 完全参考手册(第 8 版)
VIII
第2章 Java综述 ................................ 17
2.1 面向对象编程 ........................... 17
2.1.1 两种范式 ................................ 18
2.1.2 抽象........................................ 18
2.1.3 OOP三原则 ........................... 19
2.2 第一个简单程序 ....................... 23
2.2.1 输入程序 ................................ 23
2.2.2 编译程序 ................................ 23
2.2.3 深入分析第一个示例程序 .... 24
2.3 第二个简短程序 ....................... 26
2.4 两种控制语句 ........................... 28
2.4.1 if语句 .................................... 28
2.4.2 for循环 .................................. 29
2.5 使用代码块 ............................... 30
2.6 词汇问题 ................................... 32
2.6.1 空白符 .................................... 32
2.6.2 标识符 .................................... 32
2.6.3 字面值 .................................... 32
2.6.4 注释........................................ 32
2.6.5 分隔符 .................................... 33
2.6.6 Java关键字 ............................ 33
2.7 Java类库 ................................... 34
第3章 数据类型、变量和数组 ............ 35
3.1 Java是强类型化的语言 ........... 35
3.2 基本类型 ................................... 36
3.3 整型 ........................................... 36
3.3.1 byte ......................................... 37
3.3.2 short........................................ 37
3.3.3 int ........................................... 37
3.3.4 long ........................................ 37
3.4 浮点型 ....................................... 38
3.4.1 float ........................................ 38
3.4.2 double ..................................... 39
3.5 字符型 ....................................... 39
3.6 布尔型 ....................................... 41
3.7 深入分析字面值 ....................... 42
3.7.1 整型字面值 ............................ 42
3.7.2 浮点型字面值 ....................... 43
3.7.3 布尔型字面值 ....................... 44
3.7.4 字符型字面值 ....................... 44
3.7.5 字符串字面值 ....................... 44
3.8 变量 ........................................... 45
3.8.1 变量的声明 ........................... 45
3.8.2 动态初始化 ........................... 45
3.8.3 变量的作用域和生命周期.... 46
3.9 类型转换和强制类型转换 ........ 48
3.9.1 Java的自动类型转换 ........... 49
3.9.2 强制转换不兼容的类型 ........ 49
3.10 表达式中的自动类型提升 ...... 50
3.11 数组 .......................................... 52
3.11.1 一维数组 ............................ 52
3.11.2 多维数组 ............................ 54
3.11.3 另一种数组声明语法 ........ 58
3.12 关于字符串的一些说明 .......... 59 3.13 向C/C++程序员提供指针
方面的注解 ............................. 60
第4章 运算符 ...................................... 61
4.1 算术运算符................................ 61
4.1.1 基本算术运算符 ................... 62
4.1.2 求模运算符 ........................... 63
4.1.3 算术与赋值复合运算符 ........ 64
4.1.4 自增与自减运算符................ 65
4.2 位运算符 ................................... 66
4.2.1 位逻辑运算符 ....................... 68
4.2.2 左移 ....................................... 70
4.2.3 右移 ....................................... 71
4.2.4 无符号右移 ........................... 73
4.2.5 位运算符与赋值的组合 ........ 74
4.3 关系运算符................................ 75
4.4 布尔逻辑运算符 ........................ 76
4.5 赋值运算符................................ 78
4.6 “?”运算符 .............................. 78
4.7 运算符的优先级 ........................ 79
4.8 使用圆括号................................ 80
目 录
IX
第5章 控制语句 .................................. 83
5.1 Java的选择语句 ....................... 83
5.1.1 if语句 .................................... 84
5.1.2 switch语句 ............................ 87
5.2 迭代语句 ................................... 91
5.2.1 while语句 .............................. 92
5.2.2 do-while语句......................... 93
5.2.3 for语句 .................................. 96
5.2.4 for循环的for-each版本 .... 100
5.2.5 嵌套的循环 ......................... 105
5.3 跳转语句 ................................. 106
5.3.1 使用break语句 .................. 106
5.3.2 使用continue语句 .............. 110
5.3.3 return语句 ........................... 111
第6章 类........................................... 113
6.1 类的基础知识 ......................... 114
6.1.1 类的一般形式 ...................... 114
6.1.2 一个简单的类 ...................... 115
6.2 声明对象 ................................. 117
6.3 为对象引用变量赋值 ............. 119
6.4 方法 ......................................... 120
6.4.1 为Box类添加方法 ............ 120
6.4.2 返回值 ................................. 122
6.4.3 添加带参数的方法 ............. 124
6.5 构造函数 ................................. 126
6.6 this关键字 .............................. 129
6.7 垃圾回收 ................................. 130
6.8 finalize()方法 ........................... 130
6.9 堆栈类 ..................................... 131
第7章 方法和类的深入分析.............. 135
7.1 重载方法 ................................. 135
7.2 将对象用作参数 ..................... 140
7.3 参数传递的深入分析 ............. 143
7.4 返回对象 ................................. 145
7.5 递归 ......................................... 146
7.6 访问控制 ................................. 148
7.7 理解static ................................ 151
7.8 final介绍 ................................. 153
7.9 重新审视数组.......................... 154
7.10 嵌套类和内部类 .................... 156
7.11 String类介绍 ......................... 158
7.12 使用命令行参数 .................... 161
7.13 varargs：可变长度参数 ........ 162
7.13.1 重载varargs方法 ............ 165
7.13.2 varargs方法与模糊性 ..... 166
第8章 继承 ....................................... 169
8.1 继承的基础知识 ...................... 169
8.1.1 成员访问与继承 ................. 171
8.1.2 一个更实际的例子.............. 172 8.1.3 超类变量可以引用子类
对象 ..................................... 174
8.2 使用super关键字 ................... 175 8.2.1 使用super调用超类的
构造函数 ............................. 176
8.2.2 super的另一种用法 ............ 179
8.3 创建多级继承层次 .................. 180
8.4 构造函数的调用时机 .............. 183
8.5 方法重写 ................................. 184
8.6 动态方法调度.......................... 187
8.6.1 重写方法的目的 ................. 189
8.6.2 应用方法重写 ..................... 189
8.7 使用抽象类.............................. 191
8.8 在继承中使用final关键字 .... 193 8.8.1 使用final关键字阻止
重写 ..................................... 194 8.8.2 使用final关键字阻止
继承 ..................................... 194
8.9 Object类 .................................. 195
第9章 包和接口 ............................... 197
9.1 包 ............................................. 198
9.1.1 定义包 ................................. 198
9.1.2 包查找与CLASSPATH....... 199
9.1.3 一个简短的包示例.............. 199
9.2 访问保护 ................................. 200
Java 完全参考手册(第 8 版)
X
9.3 导入包 ..................................... 204
9.4 接口 ......................................... 206
9.4.1 定义接口 ............................. 207
9.4.2 实现接口 ............................. 207
9.4.3 嵌套接口 ............................. 210
9.4.4 应用接口 .............................. 211
9.4.5 接口中的变量 ..................... 214
9.4.6 接口可以扩展 ..................... 216
第10章 异常处理 .............................. 219
10.1 异常处理的基础知识 ........... 219
10.2 异常类型 ............................... 220
10.3 未捕获的异常 ....................... 221
10.4 使用try和catch ................... 222
10.5 多条catch子句 ..................... 224
10.6 嵌套的try语句 ..................... 226
10.7 throw ...................................... 228
10.8 throws .................................... 229
10.9 finally ..................................... 230
10.10 Java的内置异常 ................. 232
10.11 创建自己的异常子类 ......... 233
10.12 链式异常 ............................. 235 10.13 JDK 7中3个新的
异常特性 ............................. 237
10.14 使用异常 ............................. 238
第11章 多线程编程 .......................... 239
11.1 Java线程模型 ....................... 240
11.1.1 线程优先级 ..................... 241
11.1.2 同步 ................................. 242
11.1.3 消息传递 ......................... 242 11.1.4 Thread类和Runnable
接口 ................................. 242
11.2 主线程 ................................... 243
11.3 创建线程 ............................... 244
11.3.1 实现Runnable接口 ........ 245
11.3.2 扩展Thread类 ............... 247
11.3.3 选择一种创建方式 ......... 248
11.4 创建多个线程 ....................... 248
11.5 使用isAlive()和join()方法 .... 250
11.6 线程优先级 ............................ 252
11.7 同步 ........................................ 253
11.7.1 使用同步方法 ................. 253
11.7.2 synchronized语句 ........... 255
11.8 线程间通信 ............................ 257
11.9 挂起、恢复与停止线程 ........ 263 11.9.1 Java 1.1以前使用的挂起、
恢复和停止线程的方式 .... 264 11.9.2 挂起、恢复与停止线程的
现代方式.......................... 266
11.10 获取线程的状态 .................. 268
11.11 使用多线程 .......................... 270 第12章 枚举、自动装箱与注解
(元数据) ............................... 271
12.1 枚举 ....................................... 271
12.1.1 枚举的基础知识 ............. 272 12.1.2 values()和valueOf()
方法 ................................. 274
12.1.3 Java枚举是类类型 ......... 275
12.1.4 枚举继承自Enum类 ...... 278
12.1.5 另一个枚举示例 ............. 279
12.2 类型封装器............................ 281
12.2.1 Character封装器 ............. 281
12.2.2 Boolean封装器 ............... 282
12.2.3 数值类型封装器 ............. 282
12.3 自动装箱 ............................... 283
12.3.1 自动装箱与方法 ............. 284 12.3.2 表达式中发生的
自动装箱/拆箱................. 285 12.3.3 布尔型和字符型数值的
自动装箱/拆箱................. 287 12.3.4 自动装箱/拆箱有助于
防止错误.......................... 287
12.3.5 一些警告 ......................... 288
12.4 注解(元数据) ......................... 289
12.4.1 注解的基础知识 ............. 289
目 录
XI
12.4.2 指定保留策略 ................. 289 12.4.3 在运行时使用反射获取
注解 ................................. 290
12.4.4 AnnotatedElement接口 .... 296
12.4.5 使用默认值 ..................... 296
12.4.6 标记注解......................... 297
12.4.7 单成员注解 ..................... 298
12.4.8 内置注解......................... 300
12.4.9 一些限制......................... 301
第13章 I/O、applet以及其他主题 ...... 303
13.1 I/O的基础知识 ..................... 304
13.1.1 流 .................................... 304
13.1.2 字节流和字符流 ............. 304
13.1.3 预定义流......................... 306
13.2 读取控制台输入 ................... 307
13.2.1 读取字符......................... 307
13.2.2 读取字符串 ..................... 308
13.3 向控制台写输出 ................... 310
13.4 PrintWriter类 ........................ 311
13.5 读/写文件 .............................. 312
13.6 自动关闭文件 ....................... 318
13.7 applet的基础知识................. 321
13.8 transient和volatile修饰符 .... 324
13.9 使用instanceof运算符 ......... 324
13.10 strictfp .................................. 327
13.11 本地方法 ............................. 327
13.12 使用断言 ............................. 331
13.13 静态导入 ............................. 334 13.14 通过this()调用重载的
构造函数 ............................. 336
第14章 泛型 ..................................... 339
14.1 什么是泛型 ........................... 340
14.2 一个简单的泛型示例 ........... 340
14.2.1 泛型只使用对象 ............. 344 14.2.2 基于不同类型参数的
泛型类型是不同的 ......... 344 14.2.3 泛型提升类型安全性的
原理 ................................. 344
14.3 带两个类型参数的泛型类 .... 347
14.4 泛型类的一般形式 ................ 348
14.5 有界类型 ............................... 349
14.6 使用通配符参数 .................... 351
14.7 创建泛型方法........................ 359
14.8 泛型接口 ............................... 362
14.9 原始类型与遗留代码 ............ 364
14.10 泛型类层次.......................... 367
14.10.1 使用泛型超类 ............. 367
14.10.2 泛型子类 ..................... 369 14.10.3 泛型层次中的运行时
类型比较 ..................... 370
14.10.4 强制转换 ..................... 373
14.10.5 重写泛型类的方法 ..... 373
14.11 泛型的类型推断 .................. 374
14.12 擦拭 ..................................... 376
14.13 模糊性错误.......................... 379
14.14 使用泛型的一些限制 .......... 381
14.14.1 不能实例化类型参数 ... 381 14.14.2 对静态成员的一些
限制 ............................. 381 14.14.3 对泛型数组的一些
限制 ............................. 382
14.14.4 对泛型异常的限制 ..... 383 第Ⅱ部分 Java库
第15章 字符串处理 .......................... 387
15.1 String类的构造函数 ............. 388
15.2 字符串的长度........................ 390
15.3 特殊的字符串操作 ................ 391
15.3.1 字符串字面值 ................. 391
15.3.2 字符串连接 ..................... 391 15.3.3 字符串和其他数据
类型的连接 ..................... 392 15.3.4 字符串转换和toString()
方法 ................................. 393
Java 完全参考手册(第 8 版)
XII
15.4 提取字符 ............................... 394
15.4.1 charAt() ........................... 394
15.4.2 getChars() ........................ 394
15.4.3 getBytes() ........................ 395
15.4.4 toCharArray() .................. 395
15.5 比较字符串 ........................... 395 15.5.1 equals()和
equalsIgnoreCase() .......... 395
15.5.2 regionMatches() .............. 396 15.5.3 startsWith()和
endsWith() ....................... 397
15.5.4 equals()与== ................... 397
15.5.5 compareTo() .................... 398
15.6 查找字符串 ........................... 399
15.7 修改字符串 ........................... 401
15.7.1 substring() ....................... 401
15.7.2 concat() ........................... 402
15.7.3 replace() .......................... 402
15.7.4 trim() ............................... 403
15.8 使用valueOf()转换数据 ....... 404 15.9 改变字符串中字符的
大小写 ................................... 404
15.10 其他String方法 .................. 405
15.11 StringBuffer类 .................... 406 15.11.1 StringBuffer类的
构造函数 .................... 406
15.11.2 length()与capacity() ... 407
15.11.3 ensureCapacity() ......... 407
15.11.4 setLength() .................. 408 15.11.5 charAt()与
setCharAt() ................. 408
15.11.6 getChars() ................... 409
15.11.7 append() ...................... 409
15.11.8 insert() ......................... 409
15.11.9 reverse() ...................... 410 15.11.10 delete()与
deleteCharAt()............ 411
15.11.11 replace() ..................... 411
15.11.12 substring() .................. 412 15.11.13 其他StringBuffer
方法 ........................... 412
15.12 StringBuilder类 ................... 413
第16章 探究java.lang ..................... 415
16.1 基本类型封装器 .................... 416
16.1.1 Number ............................ 416
16.1.2 Double与Float ............... 417 16.1.3 理解isInfinite()与
isNaN() ............................ 420 16.1.4 Byte、Short、Integer和
Long ................................. 420
16.1.5 Character .......................... 427 16.1.6 对Unicode代码点的
附加支持 ......................... 430
16.1.7 Boolean ............................ 431
16.2 Void类 ................................... 432
16.3 Process类 .............................. 432
16.4 Runtime类 ............................. 433
16.4.1 内存管理 ......................... 434
16.4.2 执行其他程序 ................. 435
16.5 ProcessBuilder类 .................. 436
16.6 System类 ............................... 439 16.6.1 使用currentTimeMillis()
计时程序的执行 ............. 440
16.6.2 使用arraycopy() .............. 441
16.6.3 环境属性 ......................... 442
16.7 Object类 ................................ 442 16.8 使用clone()方法和Cloneable
接口 ....................................... 443
16.9 Class类 .................................. 445
16.10 ClassLoader类 ..................... 448
16.11 Math类 ................................ 448
16.11.1 三角函数 ..................... 448
16.11.2 指数函数 ..................... 449
16.11.3 舍入函数 ..................... 449
16.11.4 其他数学方法 ............. 450
目 录
XIII
16.12 StrictMath类 ....................... 452
16.13 Compiler类 ......................... 452 16.14 Thread类、ThreadGroup类
和Runnable接口 ................ 452
16.14.1 Runnable接口 ............ 452
16.14.2 Thread类 .................... 452
16.14.3 ThreadGroup类 .......... 454 16.15 ThreadLocal和
InheritableThreadLocal类 .... 459
16.16 Package类 ........................... 459
16.17 RuntimePermission类 ......... 460
16.18 Throwable类 ....................... 460
16.19 SecurityManager类 ............. 460
16.20 StackTraceElement类 ......... 460
16.21 Enum类 ............................... 461
16.22 ClassValue类 ...................... 462
16.23 CharSequence接口 ............. 462
16.24 Comparable接口 ................. 462
16.25 Appendable接口 ................. 463
16.26 Iterable接口 ........................ 463
16.27 Readable接口 ..................... 464
16.28 AutoCloseable接口 ............. 464 16.29 Thread.UncaughtException-
Handler接口 ....................... 464
16.30 java.lang子包 ...................... 464
16.30.1 java.lang.annotation .... 465
16.30.2 java.lang.instrument .... 465
16.30.3 java.lang.invoke .......... 465
16.30.4 java.lang.management ... 465
16.30.5 java.lang.ref ................ 465
16.30.6 java.lang.reflect........... 465 第17章 java.util第1部分：
集合框架 .............................. 467
17.1 集合概述 ............................... 468
17.2 JDK 5对集合框架的修改 .... 469 17.2.1 泛型从根本上改变了
集合框架 ......................... 470 17.2.2 自动装箱使得使用基本
类型更加容易 ................. 470
17.2.3 for-each风格的循环 ....... 470
17.3 集合接口 ............................... 470
17.3.1 Collection接口 ................ 471
17.3.2 List接口 .......................... 473
17.3.3 Set接口 ........................... 474
17.3.4 SortedSet接口 ................. 474
17.3.5 NavigableSet接口 ........... 475
17.3.6 Queue接口 ...................... 476
17.3.7 Deque接口 ...................... 477
17.4 集合类 ................................... 479
17.4.1 ArrayList类 ..................... 480
17.4.2 LinkedList类 ................... 483
17.4.3 HashSet类 ....................... 484
17.4.4 LinkedHashSet类 ............ 486
17.4.5 TreeSet类 ........................ 486
17.4.6 PriorityQueue类 .............. 487
17.4.7 ArrayDeque类 ................. 488
17.4.8 EnumSet类 ...................... 489
17.5 通过迭代器访问集合 ............ 490
17.5.1 使用迭代器 ..................... 491 17.5.2 使用for-each循环替代
迭代器 ............................. 493 17.6 在集合中存储用户
定义的类................................ 494
17.7 RandomAccess接口 .............. 495
17.8 使用映射 ............................... 496
17.8.1 映射接口 ......................... 496
17.8.2 映射类 ............................. 500
17.9 比较器 ................................... 505
17.10 集合算法.............................. 508
17.11 Arrays类 .............................. 513
17.12 需要泛型集合的原因 .......... 518
17.13 遗留的类和接口 .................. 521
17.13.1 Enumeration接口 ....... 521
17.13.2 Vector类 ..................... 521
17.13.3 Stack类 ....................... 525
Java 完全参考手册(第 8 版)
XIV
17.13.4 Dictionary类 .............. 527
17.13.5 Hashtable类 ............... 528
17.13.6 Properties类 ............... 532
17.13.7 使用store()和load() .... 535
17.14 集合小结 ............................. 537 第18章 java.util第2部分：更多实用
工具类 ................................. 539
18.1 StringTokenizer类 ................. 539
18.2 BitSet类 ................................ 541
18.3 Date类 ................................... 544
18.4 Calendar类 ............................ 546
18.5 GregorianCalendar类 ............ 549
18.6 TimeZone类 .......................... 550
18.7 SimpleTimeZone类 .............. 551
18.8 Locale类 ............................... 552
18.9 Random类 ............................. 554
18.10 Observable类 ...................... 555
18.10.1 Observer接口 ............. 556
18.10.2 Observer示例 ............. 556
18.11 Timer和TimerTask类 ........ 559
18.12 Currency类 ......................... 561
18.13 Formatter类 ........................ 562 18.13.1 Formatter类的
构造函数 .................... 563
18.13.2 Formatter类的方法 .... 563
18.13.3 格式化的基础知识 .... 564
18.13.4 格式化字符串和字符 ... 566
18.13.5 格式化数字 ................ 566
18.13.6 格式化时间和日期 .... 567
18.13.7 %n和%%说明符 ....... 569
18.13.8 指定最小字段宽度 .... 569
18.13.9 指定精度 .................... 571
18.13.10 使用格式标志 .......... 572
18.13.11 对齐输出 .................. 572 18.13.12 空格、“+”、“0”以及
“(”标志 ................... 573
18.13.13 逗号标志 .................. 574
18.13.14 “#：”标志 ............... 574
18.13.15 大写选项 ................... 574
18.13.16 使用参数索引 ........... 575
18.13.17 关闭Formatter对象 ... 577
18.13.18 printf()方法 ............... 577
18.14 Scanner类 ............................ 577 18.14.1 Scanner类的
构造函数 ..................... 577
18.14.2 扫描的基础知识 ......... 578
18.14.3 一些Scanner示例 ...... 581
18.14.4 设置定界符 ................. 585
18.14.5 其他Scanner特性 ...... 587 18.15 ResourceBundle、 ListResourceBundle和
PropertyResourceBundle类.... 588
18.16 其他实用工具类和接口 ...... 592
18.17 java.util子包........................ 593 18.17.1 java.util.concurrent、 java.util.concurrent.atomic 和java.util.concurrent.
locks ............................ 593
18.17.2 java.util.jar ................... 593
18.17.3 java.util.logging ........... 593
18.17.4 java.util.prefs ............... 593
18.17.5 java.util.regex .............. 594
18.17.6 java.util.spi .................. 594
18.17.7 java.util.zip .................. 594
第19章 输入/输出：探究Java.io ...... 595
19.1 I/O类和接口 ......................... 596
19.2 File类 .................................... 597
19.2.1 目录 ................................. 600 19.2.2 使用FilenameFilter
接口 ................................. 601
19.2.3 listFiles()方法 .................. 602
19.2.4 创建目录 ......................... 602 19.3 AutoCloseable、Closeable和
Flushable接口 ....................... 602
目 录
XV
19.4 I/O异常 ................................. 603
19.5 关闭流的两种方式 ............... 604
19.6 流类 ....................................... 605
19.7 字节流 ................................... 605
19.7.1 InputStream类 ................ 605
19.7.2 OutputStream类 ............. 606
19.7.3 FileInputStream类 .......... 606
19.7.4 FileOutputStream类 ....... 609 19.7.5 ByteArrayInputStream
类 ..................................... 611 19.7.6 ByteArrayOutputStream
类 .................................... 613
19.7.7 过滤的字节流 ................. 614
19.7.8 缓存的字节流 ................. 614
19.7.9 SequenceInputStream类 .... 618
19.7.10 PrintStream类 ............... 620 19.7.11 DataOutputStream和
DataInputStream类 ...... 622
19.7.12 RandomAccessFile类 ... 624
19.8 字符流 ................................... 625
19.8.1 Reader类 ........................ 625
19.8.2 Writer类 ......................... 626
19.8.3 FileReader类 .................. 627
19.8.4 FileWriter类 ................... 627
19.8.5 CharArrayReader类 ....... 628
19.8.6 CharArrayWriter类 ........ 630
19.8.7 BufferedReader类 .......... 631
19.8.8 BufferedWriter类 ........... 633
19.8.9 PushbackReader类 ......... 633
19.8.10 PrintWriter类 ................ 634
19.9 Console类 ............................. 635
19.10 串行化 ................................. 637
19.10.1 Serializable接口 ........ 637
19.10.2 Externalizable接口 .... 637
19.10.3 ObjectOutput接口 ...... 638 19.10.4 ObjectOutputStream
类 ................................ 638
19.10.5 ObjectInput接口 ........ 639
19.10.6 ObjectInputStream类 .... 640
19.10.7 串行化示例 ................. 641
19.11 流的优点 .............................. 642
第20章 探究NIO ............................. 643
20.1 NIO类 ................................... 643
20.2 NIO的基础知识 ................... 644
20.2.1 缓存 ................................. 644
20.2.2 通道 ................................. 646
20.2.3 字符集和选择器 ............. 647
20.3 JDK 7对NIO的增强 ........... 648
20.3.1 Path接口 ......................... 648
20.3.2 Files类 ............................ 649
20.3.3 Path接口 ......................... 651
20.3.4 文件属性接口 ................. 652 20.3.5 FileSystem、FileSystems
和FileStore类 ................ 654
20.4 使用NIO系统 ...................... 654 20.4.1 为基于通道的I/O使用
NIO .................................. 654 20.4.2 为基于流的I/O
使用NIO ......................... 663 20.4.3 为路径和文件系统操作
使用NIO ......................... 666 20.5 JDK 7之前基于通道的
例子 ....................................... 674
20.5.1 读文件(JDK 7之前) ....... 674
20.5.2 写文件(JDK 7之前) ....... 677
第21章 联网 ..................................... 681
21.1 联网的基础知识 .................... 682
21.2 联网类和接口........................ 683
21.3 InetAddress类 ....................... 683
21.3.1 工厂方法 ......................... 684
21.3.2 实例方法 ......................... 685 21.4 Inet4Address类和
Inet6Address类...................... 685
21.5 TCP/IP客户端套接字 ........... 686
21.6 URL类 .................................. 689
Java 完全参考手册(第 8 版)
XVI
21.7 URLConnection类 ................ 691
21.8 HttpURLConnection类 ......... 694
21.9 URI类 ................................... 696
21.10 cookie................................... 696
21.11 TCP/IP服务器套接字 ........ 696
21.12 数据报 ................................. 697
21.12.1 DatagramSocket类 ..... 697
21.12.2 DatagramPacket类 ..... 698
21.12.3 数据报示例 ................ 699
第22章 Applet类 ............................. 701
22.1 applet的两种类型................. 701
22.2 applet的基础知识................. 702
22.3 applet的架构 ........................ 704
22.4 applet的骨架 ........................ 705
22.4.1 applet的初始化和终止 ... 706
22.4.2 重写update()方法 .......... 707
22.5 简单的applet显示方法 ........ 707
22.6 请求重画 ............................... 709
22.7 使用状态栏窗口 ................... 712
22.8 HTML APPLET标签 ............ 713
22.9 向applet传递参数................ 714 22.10 getDocumentBase()和
getCodeBase() ...................... 718 22.11 AppletContext接口和
showDocument()方法 .......... 718
22.12 AudioClip接口 ................... 720
22.13 AppletStub接口 .................. 720
22.14 向控制台输出 ..................... 720
第23章 事件处理 .............................. 721
23.1 两种事件处理机制 ............... 722
23.2 委托事件模型 ....................... 722
23.2.1 事件 ................................ 722
23.2.2 事件源 ............................ 723
23.2.3 事件监听器 ..................... 723
23.3 事件类 ................................... 724
23.3.1 ActionEvent类 ............... 725
23.3.2 AdjustmentEvent类 ........ 726
23.3.3 ComponentEvent类 ........ 726
23.3.4 ContainerEvent类 ........... 727
23.3.5 FocusEvent类 ................. 727
23.3.6 InputEvent类................... 728
23.3.7 ItemEvent类 .................... 729
23.3.8 KeyEvent类 .................... 730
23.3.9 MouseEvent类 ................ 730
23.3.10 MouseWheelEvent类 .... 732
23.3.11 TextEvent类 .................. 733
23.3.12 WindowEvent类 ........... 733
23.4 事件源 ................................... 734
23.5 事件监听器接口 .................... 735
23.5.1 ActionListener接口 ........ 736 23.5.2 AdjustmentListener
接口 ................................. 736 23.5.3 ComponentListener
接口 ................................. 736
23.5.4 ContainerListener接口 .... 736
23.5.5 FocusListener接口 .......... 736
23.5.6 ItemListener接口 ............ 736
23.5.7 KeyListener接口 ............. 737
23.5.8 MouseListener接口 ........ 737 23.5.9 MouseMotionListener
接口 ................................. 737 23.5.10 MouseWheelListener
接口 ............................... 737
23.5.11 TextListener接口 .......... 738 23.5.12 WindowFocusListener
接口 ............................... 738
23.5.13 WindowListener接口 .... 738
23.6 使用委托事件模型 ................ 738
23.6.1 处理鼠标事件 ................. 739
23.6.2 处理键盘事件 ................. 741
23.7 适配器类 ............................... 744
23.8 内部类 ................................... 746 第24章 AWT介绍：使用窗口、
图形和文本 .......................... 749
24.1 AWT类 .................................. 750
24.2 窗口基本元素........................ 752
24.2.1 Component类 .................. 752
目 录
XVII
24.2.2 Container类 .................... 753
24.2.3 Panel类 ........................... 753
24.2.4 Window类 ...................... 753
24.2.5 Frame类 ......................... 753
24.2.6 Canvas类 ........................ 753
24.3 使用框架窗口 ....................... 753
24.3.1 设置窗口的尺寸 ............. 754
24.3.2 隐藏和显示窗口 ............. 754
24.3.3 设置窗口的标题 ............. 754
24.3.4 关闭框架窗口 ................. 754
24.4 在applet中创建框架窗口 .... 755
24.5 创建基于窗口的程序 ........... 761
24.6 在窗口中显示信息 ............... 763
24.7 使用图形 ............................... 763
24.7.1 绘制直线......................... 764
24.7.2 绘制矩形......................... 765
24.7.3 绘制椭圆和圆 ................. 765
24.7.4 绘制弧形......................... 766
24.7.5 绘制多边形 ..................... 767
24.7.6 改变图形的大小 ............. 767
24.8 使用颜色 ............................... 768
24.8.1 Color类的方法 ............... 769
24.8.2 设置当前图形的颜色 ..... 770
24.8.3 一个演示颜色的applet ... 770
24.9 设置绘图模式 ....................... 771
24.10 使用字体 ............................. 773
24.10.1 确定可用字体 ............ 774
24.10.2 创建和选择字体 ........ 775
24.10.3 获取字体信息 ............ 777 24.11 使用FontMetrics管理文本
输出 ...................................... 778
24.11.1 显示多行文本 ............ 779
24.11.2 居中显示文本 ............ 781
24.11.3 对齐多行文本 ............ 782 第25章 使用AWT控件、布局
管理器和菜单 ...................... 787
25.1 控件的基础知识 ................... 788
25.1.1 添加和移除控件 ............. 788
25.1.2 响应控件 ......................... 788
25.1.3 HeadlessException异常 ... 788
25.2 使用标签 ............................... 789
25.3 使用命令按钮........................ 790
25.4 使用复选框............................ 793
25.5 使用复选框组........................ 795
25.6 使用下拉列表........................ 796
25.7 使用列表框............................ 798
25.8 管理滚动条............................ 801
25.9 使用TextField ....................... 804
25.10 使用TextArea ...................... 807
25.11 理解布局管理器 .................. 808 25.11.1 FlowLayout布局
管理器 ......................... 809 25.11.2 BorderLayout布局
管理器 ......................... 811
25.11.3 使用Insets ................... 812 25.11.4 GridLayout布局
管理器 ......................... 814 25.11.5 CardLayout布局
管理器 ......................... 815 25.11.6 GridBagLayout布局
管理器 ......................... 818
25.12 菜单栏和菜单 ...................... 823
25.13 对话框 ................................. 829
25.14 FileDialog类 ....................... 834 25.15 扩展AWT控件以处理
事件 ..................................... 835
25.15.1 扩展按钮 ..................... 836
25.15.2 扩展复选框 ................. 837
25.15.3 扩展复选框组 ............. 838
25.15.4 扩展下拉列表 ............. 839
25.15.5 扩展列表框 ................. 840
25.15.6 扩展滚动条 ................. 841
25.16 关于重载paint()方法 .......... 842
Java 完全参考手册(第 8 版)
XVIII
第26章 图像 ..................................... 843
26.1 文件格式 ............................... 844 26.2 图像基础：创建、加载与
显示 ....................................... 844
26.2.1 创建Image对象 ............. 844
26.2.2 加载图像......................... 845
26.2.3 显示图像......................... 845
26.3 ImageObserver接口 .............. 846
26.4 双缓存 ................................... 848
26.5 MediaTracker类 .................... 850
26.6 ImageProducer接口 .............. 853
26.7 ImageConsumer接口 ............ 855
26.8 ImageFilter类 ........................ 857
26.8.1 CropImageFilter类 ......... 858
26.8.2 RGBImageFilter类 ......... 860
26.9 单元格动画 ........................... 870
26.10 其他图像类 ......................... 873
第27章 并发实用工具 ...................... 875
27.1 并发API包 ........................... 876
27.1.1 java.util.concurrent包 ..... 876 27.1.2 java.util.concurrent.atomic
包 .................................... 877 27.1.3 java.util.concurrent.locks
包 .................................... 877
27.2 使用同步对象 ....................... 877
27.2.1 Semaphore类 .................. 878
27.2.2 CountDownLatch类 ....... 884
27.2.3 CyclicBarrier类 .............. 885
27.2.4 Exchanger类................... 888
27.2.5 Phaser类 ......................... 890
27.3 使用执行器 ........................... 898 27.3.1 一个简单的执行器
示例 ............................ 898 27.3.2 使用Callable和Future
接口 ................................ 900
27.4 TimeUnit枚举 ....................... 903
27.5 并发集合 ............................... 904
27.6 锁 ........................................... 905
27.7 原子操作 ............................... 908 27.8 通过Fork/Join Framework
进行并行编程 ........................ 909
27.8.1 主要的Fork/Join类 ........ 909
27.8.2 分而治之的策略 ............. 912 27.8.3 一个简单的Fork/Join
示例 ................................. 913 27.8.4 理解并行级别带来的
影响 ................................. 915 27.8.5 一个使用RecursiveTask<V>
的例子 ............................. 918
27.8.6 异步执行任务 ................. 921
27.8.7 取消任务 ......................... 921
27.8.8 确定任务的完成状态 ..... 921
27.8.9 重新启动任务 ................. 922
27.8.10 深入研究 ....................... 922 27.8.11 关于Fork/Join Framework
的一些提示 ................... 923 27.9 并发实用工具与Java传统
方式的比较............................ 924
第28章 正则表达式和其他包 ........... 925
28.1 核心Java API包 ................... 926
28.2 正则表达式处理 .................... 927
28.2.1 Pattern类 ......................... 928
28.2.2 Matcher类 ....................... 928
28.2.3 正则表达式的语法 ......... 929
28.2.4 演示模式匹配 ................. 929
28.2.5 模式匹配的两个选项 ..... 935
28.2.6 探究正则表达式 ............. 935
28.3 反射 ....................................... 936
28.4 远程方法调用........................ 939
28.5 文本格式化............................ 943
28.5.1 DateFormat类 ................. 943
28.5.2 SimpleDateFormat类 ...... 945
目 录
XIX
第Ⅲ部分 使用Java开发软件
第29章 Java Bean ............................. 951
29.1 Java Bean是什么 .................. 952
29.2 Java Bean的优势 .................. 952
29.3 反省 ....................................... 952
29.3.1 属性的设计模式 ............. 952
29.3.2 事件的设计模式 ............. 954
29.3.3 方法与设计模式 ............. 954
29.3.4 使用BeanInfo接口 ........ 955
29.4 绑定属性与约束属性 ........... 955
29.5 持久性 ................................... 955
29.6 定制器 ................................... 956
29.7 Java Bean API ........................ 956
29.7.1 Introspector类 ................ 958
29.7.2 PropertyDescriptor类 ..... 958
29.7.3 EventSetDescriptor类 .... 958
29.7.4 MethodDescriptor类 ...... 958
29.8 一个Bean示例 ..................... 958
第30章 Swing简介 .......................... 963
30.1 Swing的起源 ........................ 964
30.2 Swing以AWT为基础 ......... 964
30.3 两个关键的Swing特性 ....... 964
30.3.1 Swing组件是轻量级的 ... 964
30.3.2 Swing支持可插入外观 ... 965
30.4 MVC连接 ............................. 965
30.5 组件与容器 ........................... 966
30.5.1 组件 ................................ 966
30.5.2 容器 ................................ 967
30.5.3 顶级容器窗格 ................. 967
30.6 Swing包 ................................ 967 30.7 一个简单的Swing
应用程序 ............................... 968
30.8 事件处理 ............................... 972
30.9 创建Swing applet ................. 975
30.10 在Swing中绘图 ................. 977
30.10.1 绘图的基础知识 ........ 977
30.10.2 计算可绘制区域 ........ 978
30.10.3 一个绘图示例 ............. 979
第31章 探究Swing .......................... 983
31.1 JLabel与ImageIcon .............. 984
31.2 JTextField ............................... 985
31.3 Swing按钮 ............................ 987
31.3.1 JButton ............................. 988
31.3.2 JToggleButton .................. 990
31.3.3 复选框 ............................. 992
31.3.4 单选按钮 ......................... 994
31.4 JTabbedPane .......................... 996
31.5 JScrollPane ............................. 998
31.6 JList ...................................... 1000
31.7 JComboBox.......................... 1003
31.8 树 ......................................... 1006
31.9 JTable ................................... 1009
31.10 继续研究Swing ................ 1011
第32章 servlet ............................... 1013
32.1 背景 ..................................... 1013
32.2 sevelet的生命周期 ............. 1014
32.3 Servlet开发选项 ................. 1015
32.4 使用Tomcat ......................... 1015
32.5 一个简单的servlet .............. 1017 32.5.1 创建和编译servlet
源代码 .......................... 1017
32.5.2 启动Tomcat ................. 1018 32.5.3 启动Web浏览器并
请求servlet ................... 1018
32.6 servlet API ............................ 1018
32.7 javax.servlet包 .................... 1018
32.7.1 Servlet接口 .................. 1019
32.7.2 ServletConfig接口 ....... 1020
32.7.3 ServletContext接口 ..... 1020
32.7.4 ServletRequest接口 ..... 1020
32.7.5 ServletResponse接口 ... 1021
32.7.6 GenericServlet类 ......... 1022
32.7.7 ServletInputStream类 ... 1022
32.7.8 ServletOutputStream类 ... 1022
Java 完全参考手册(第 8 版)
XX
32.7.9 servlet异常类 ............... 1022
32.8 读取servlet参数 ................. 1022
32.9 javax.servlet.http包 ............. 1024 32.9.1 HttpServletRequest
接口 .............................. 1025 32.9.2 HttpServletResponse
接口 .............................. 1025
32.9.3 HttpSession接口 .......... 1026 32.9.4 HttpSessionBindingListener
接口 .............................. 1027
32.9.5 Cookie类 ...................... 1027
32.9.6 HttpServlet类 ............... 1028
32.9.7 HttpSessionEvent类 ..... 1029 32.9.8 HttpSessionBindingEvent
类 .................................. 1030
32.10 处理HTTP请求和响应 ... 1030 32.10.1 处理HTTP GET
请求 .......................... 1030 32.10.2 处理HTTP POST
请求 .......................... 1032
32.11 使用cookie ........................ 1033
32.12 会话跟踪 ........................... 1035 第Ⅳ部分 Java应用
第33章 applet和servlet在金融领域的 应用 ................................... 1039
33.1 计算贷款的还款额 ............. 1040
33.1.1 RegPay中声明的变量 ... 1044
33.1.2 init()方法....................... 1044
33.1.3 makeGUI()方法 ............ 1044
33.1.4 actionPerformed()方法 .... 1047
33.1.5 compute()方法 .............. 1048
33.2 计算投资的未来收益 ......... 1048 33.3 计算为达到未来收益所需
要的初始投资额 ................. 1052 33.4 计算为拿到期望的养老金
所需要的初始投资额 ......... 1056
33.5 计算给定投资的最大收益 ... 1060
33.6 计算贷款余额 ..................... 1064 33.7 创建应用于金融领域的
servlet ................................... 1068 33.7.1 将RegPay applet转换为
servlet............................ 1069
33.7.2 RegPayS servlet ............ 1069
33.8 一些尝试 ............................. 1072
第34章 使用Java创建下载管理器 ... 1073
34.1 理解Internet下载 ............... 1074
34.2 下载管理器概述 .................. 1074
34.3 DownLoad类....................... 1075
34.3.1 DownLoad类的变量 ... 1079 34.3.2 DownLoad类的
构造函数 ...................... 1079
34.3.3 download()方法 ............ 1079
34.3.4 run()方法 ...................... 1079
34.3.5 stateChanged()方法 ...... 1083
34.3.6 动作和访问器方法 ...... 1083
34.4 ProgressRenderer类 ............ 1083
34.5 DownloadsTableModel类 ... 1084
34.5.1 addDownload()方法 ..... 1086
34.5.2 clearDownload()方法 ... 1087
34.5.3 getColumnClass()方法 ... 1087
34.5.4 getValueAt()方法 .......... 1087
34.5.5 update()方法 ................. 1088
34.6 DownloadManager类 .......... 1088 34.6.1 DownloadManager类的
变量 .............................. 1094 34.6.2 DownloadManager类的
构造函数 ...................... 1095
34.6.3 verifyUrl()方法 ............. 1095 34.6.4 tableSelectionChanged()
方法 .............................. 1096
34.6.5 updateButtons()方法 ..... 1096
34.6.6 处理动作事件 .............. 1097
34.7 编译和运行下载管理器 ...... 1098
34.8 进一步完善下载管理器 ...... 1098
附录 使用Java的文档注释 ............. 1099
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java完全参考手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java虚拟机规范
目录
前言
1 Introduction
1.1 A Bit of History
1.2 The Java Virtual Machine
1.3 Organization of the Specification
1.4 Notation
1.5 Feedback
2 The Structure of the Java Virtual Machine
2.1 The  class File Format
2.2 Data Types
2.3 Primitive Types and Values
2.3.1 Integral Types and Values
2.3.2 Floating-Point Types, Value Sets, and Values
2.3.3 The  returnAddress Type and Values
2.3.4 The  boolean Type
2.4 Reference Types and Values
2.5 Run-Time Data Areas
2.5.1 The  pc Register
2.5.2 Java Virtual Machine Stacks
2.5.3 Heap
2.5.4 Method Area
2.5.5 Run-Time Constant Pool
2.5.6 Native Method Stacks
2.6 Frames
2.6.1 Local Variables
2.6.2 Operand Stacks
2.6.3 Dynamic Linking
2.6.4 Normal Method Invocation Completion
2.6.5 Abrupt Method Invocation Completion
2.7 Representation of Objects
2.8 Floating-Point Arithmetic
2.8.1 Java Virtual Machine Floating-Point Arithmetic and IEEE 754
2.8.2 Floating-Point Modes
2.8.3 Value Set Conversion
2.9 Special Methods
2.10 Exceptions
2.11 Instruction Set Summary
2.11.1 Types and the Java Virtual Machine
2.11.2 Load and Store Instructions
2.11.3 Arithmetic Instructions
2.11.4 Type Conversion Instructions
2.11.5 Object Creation and Manipulation
2.11.6 Operand Stack Management Instructions
2.11.7 Control Transfer Instructions
2.11.8 Method Invocation and Return Instructions
2.11.9 Throwing Exceptions
2.11.10 Synchronization
2.12 Class Libraries
2.13 Public Design, Private Implementation
3 Compiling for the Java Virtual Machine
3.1 Format of Examples
3.2 Use of Constants, Local Variables, and Control Constructs
3.3 Arithmetic
3.4 Accessing the Run-Time Constant Pool
3.5 More Control Examples
3.6 Receiving Arguments
3.7 Invoking Methods
3.8 Working with Class Instances
3.9 Arrays
3.10 Compiling Switches
3.11 Operations on the Operand Stack
3.12 Throwing and Handling Exceptions
3.13 Compiling finally
3.14 Synchronization
3.15 Annotations
4 The class File Format
4.1 The ClassFile Structure
4.2 The Internal Form of Names
4.2.1 Binary Class and Interface Names
4.2.2 Unqualified Names
4.3 Descriptors
4.3.1 Grammar Notation
4.3.2 Field Descriptors
4.3.3 Method Descriptors
4.4 The Constant Pool
4.4.1 The CONSTANT_Class_info Structure
4.4.2 The CONSTANT_Fieldref_info, CONSTANT_Methodref_info, and CONSTANT_InterfaceMethodref_info Structures
4.4.3 The CONSTANT_String_info Structure
4.4.4 The CONSTANT_Integer_info and CONSTANT_Float_info Structures
4.4.5 The CONSTANT_Long_info and CONSTANT_Double_info Structures
4.4.6 The CONSTANT_NameAndType_info Structure
4.4.7 The CONSTANT_Utf8_info Structure
4.4.8 The CONSTANT_MethodHandle_info Structure
4.4.9 The CONSTANT_MethodType_info Structure
4.4.10 The CONSTANT_InvokeDynamic_info Structure
4.5 Fields
4.6 Methods
4.7 Attributes
4.7.1 Defining and Naming New Attributes
4.7.2 The ConstantValue Attribute
4.7.3 The Code Attribute
4.7.4 The StackMapTable Attribute
4.7.5 The Exceptions Attribute
4.7.6 The InnerClasses Attribute
4.7.7 The EnclosingMethod Attribute
4.7.8 The Synthetic Attribute
4.7.9 The Signature Attribute
4.7.9.1 Signatures
4.7.10 The SourceFile Attribute
4.7.11 The SourceDebugExtension Attribute
4.7.12 The LineNumberTable Attribute
4.7.13 The LocalVariableTable Attribute
4.7.14 The LocalVariableTypeTable Attribute
4.7.15 The Deprecated Attribute
4.7.16 The RuntimeVisibleAnnotations Attribute
4.7.16.1 The element_value structure
4.7.17 The RuntimeInvisibleAnnotations Attribute
4.7.18 The RuntimeVisibleParameterAnnotations Attribute
4.7.19 The RuntimeInvisibleParameterAnnotations Attribute
4.7.20 The RuntimeVisibleTypeAnnotations Attribute
4.7.20.1 The target_info union
4.7.20.2 The type_path structure
4.7.21 The RuntimeInvisibleTypeAnnotations Attribute
4.7.22 The AnnotationDefault Attribute
4.7.23 The BootstrapMethods Attribute
4.7.24 The MethodParameters Attribute
4.8 Format Checking
4.9 Constraints on Java Virtual Machine Code
4.9.1 Static Constraints
4.9.2 Structural Constraints
4.10 Verification of class Files
4.10.1 Verification by Type Checking
4.10.1.1 Accessors for Java Virtual Machine Artifacts
4.10.1.2 Verification Type System
4.10.1.3 Instruction Representation
4.10.1.4 Stack Map Frame Representation
4.10.1.5 Type Checking Abstract and Native Methods
4.10.1.6 Type Checking Methods with Code
4.10.1.7 Type Checking Load and Store Instructions
4.10.1.8 Type Checking for protected Members
4.10.1.9 Type Checking Instructions
4.10.2 Verification by Type Inference
4.10.2.1 The Process of Verification by Type Inference
4.10.2.2 The Bytecode Verifier
4.10.2.3 Values of Types long and double
4.10.2.4 Instance Initialization Methods and Newly Created Objects
4.10.2.5 Exceptions and finally
4.11 Limitations of the Java Virtual Machine
5 Loading, Linking, and Initializing
5.1 The Run-Time Constant Pool
5.2 Java Virtual Machine Startup
5.3 Creation and Loading
5.3.1 Loading Using the Bootstrap Class Loader
5.3.2 Loading Using a User-defined Class Loader
5.3.3 Creating Array Classes
5.3.4 Loading Constraints
5.3.5 Deriving a Class from a class File Representation
5.4 Linking
5.4.1 Verification
5.4.2 Preparation
5.4.3 Resolution
5.4.3.1 Class and Interface Resolution
5.4.3.2 Field Resolution
5.4.3.3 Method Resolution
5.4.3.4 Interface Method Resolution
5.4.3.5 Method Type and Method Handle Resolution
5.4.3.6 Call Site Specifier Resolution
5.4.4 Access Control
5.4.5 Overriding
5.5 Initialization
5.6 Binding Native Method Implementations
5.7 Java Virtual Machine Exit
6 The Java Virtual Machine Instruction Set
6.1 Assumptions: The Meaning of "Must"
6.2 Reserved Opcodes
6.3 Virtual Machine Errors
6.4 Format of Instruction Descriptions
mnemonic
6.5 Instructions
aaload
aastore
aconst_null
aload
aload_<n>
anewarray
areturn
arraylength
astore
astore_<n>
athrow
baload
bastore
bipush
caload
castore
checkcast
d2f
d2i
d2l
dadd
daload
dastore
dcmp<op>
dconst_<d>
ddiv
dload
dload_<n>
dmul
dneg
drem
dreturn
dstore
dstore_<n>
dsub
dup
dup_x1
dup_x2
dup2
dup2_x1
dup2_x2
f2d
f2i
f2l
fadd
faload
fastore
fcmp<op>
fconst_<f>
fdiv
fload
fload_<n>
fmul
fneg
frem
freturn
fstore
fstore_<n>
fsub
getfield
getstatic
goto
goto_w
i2b
i2c
i2d
i2f
i2l
i2s
iadd
iaload
iand
iastore
iconst_<i>
idiv
if_acmp<cond>
if_icmp<cond>
if<cond>
ifnonnull
ifnull
iinc
iload
iload_<n>
imul
ineg
instanceof
invokedynamic
invokeinterface
invokespecial
invokestatic
invokevirtual
ior
irem
ireturn
ishl
ishr
istore
istore_<n>
isub
iushr
ixor
jsr
jsr_w
l2d
l2f
l2i
ladd
laload
land
lastore
lcmp
lconst_<l>
ldc
ldc_w
ldc2_w
ldiv
lload
lload_<n>
lmul
lneg
lookupswitch
lor
lrem
lreturn
lshl
lshr
lstore
lstore_<n>
lsub
lushr
lxor
monitorenter
monitorexit
multianewarray
new
newarray
nop
pop
pop2
putfield
putstatic
ret
return
saload
sastore
sipush
swap
tableswitch
wide
7 Opcode Mnemonics by Opcode
Index
A Limited License Grant
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java虚拟机规范
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计概念:对象先行(原书第8版)
出版者的话
译者序
前言
学习辅助手段介绍
致谢
特色内容
第一部分基础知识
第1章引言2
1.1计算机程序2
1.2计算机剖析3
计算与社会1.1计算机无处不在4
1.3Java编程语言5
1.4熟悉你的编程环境7
编程技巧1.1备份副本10
1.5分析你的第一个程序10
常见错误1.1缺少分号13
1.6错误14
常见错误1.2单词拼写错误15
1.7解决问题：算法设计15
1.7.1算法概念16
1.7.2解决一个投资问题的算法16
1.7.3伪代码17
1.7.4从算法到程序18
操作指南1.1用伪代码描述算法19
实用示例1.1编写一个铺地板瓷砖的算法21
第2章使用对象31
2.1对象和类31
2.1.1使用对象32
2.1.2类32
2.2变量33
2.2.1变量声明33
2.2.2类型35
2.2.3名35
2.2.4注释36
2.2.5赋值37
常见错误2.1使用未声明或未初始化的变量39
常见错误2.2混淆变量声明和赋值语句39
编程技巧2.1选择描述性的变量名39
2.3调用方法40
2.3.1类的公共接口40
2.3.2方法参数40
2.3.3返回值42
2.3.4方法声明43
编程技巧2.2通过尝试来学习44
2.4构造对象45
常见错误2.3试图如调用方法一样调用构造函数47
2.5访问器和修改器方法47
2.6API文档48
2.6.1浏览API文档49
2.6.2包50
编程技巧2.3不要强记，使用在线帮助51
2.7实现一个测试程序51
专题2.1在交互环境中测试类53
实用示例2.1你活了多少天？54
实用示例2.2处理图片54
2.8对象引用54
计算与社会2.1计算机垄断57
2.9图形应用57
2.9.1帧窗口58
2.9.2在组件上绘制59
2.9.3在帧窗口中显示组件61
2.10椭圆、线、文本和颜色62
2.10.1椭圆和圆63
2.10.2线63
2.10.3绘制文本64
2.10.4颜色64
第3章实现类78
3.1实例变量和封装78
3.1.1实例变量78
3.1.2Counter类的方法80
3.1.3封装80
3.2指定类的公共接口82
3.2.1指定方法82
3.2.2指定构造函数83
3.2.3使用公共接口85
3.2.4为公共接口加注释85
常见错误3.1将构造函数声明为void88
编程技巧3.1javadoc工具88
3.3提供类实现89
3.3.1提供实例变量89
3.3.2提供构造函数89
3.3.3提供方法91
常见错误3.2忽略参数变量93
操作指南3.1实现一个类94
实用示例3.1建立一个简单的菜单97
3.4单元测试98
计算与社会3.1电子投票机99
3.5解决问题：跟踪对象100
3.6局部变量102
常见错误3.3在局部变量中重复实例变量103
常见错误3.4提供不必要的实例变量104
常见错误3.5忘记在构造函数中初始化对象引用105
3.7this引用105
专题3.1从一个构造函数调用另一个构造函数108
3.8图形类108
操作指南3.2绘制图形112
第4章基本数据类型127
4.1数字127
4.1.1数字类型127
4.1.2常量129
专题4.1大数134
编程技巧4.1不要使用魔法数134
4.2算术运算135
4.2.1算术操作符135
4.2.2自增和自减135
4.2.3整除和求余135
4.2.4幂和平方根136
4.2.5浮点数转换为整数138
常见错误4.1意外的整除139
常见错误4.2小括号不匹配140
编程技巧4.2表达式中的空格140
Java8说明4.1避免负余数140
专题4.2结合赋值和算术运算141
专题4.3实例方法和静态方法141
计算与社会4.1奔腾处理器的浮点数bug141
4.3输入和输出143
4.3.1读取输入143
4.3.2格式化输出144
操作指南4.1完成计算147
实用示例4.1计算金字塔的体积和表面积150
4.4解决问题：先手动完成150
实用示例4.2计算旅行时间152
4.5字符串152
4.5.1String类型152
4.5.2字符串连接153
4.5.3字符串输入154
4.5.4转义序列154
4.5.5字符串和字符154
4.5.6子串155
编程技巧4.3阅读异常报告157
专题4.4使用对话框提供输入和输出158
计算与社会4.2国际字母表和Unicode158
第5章判断174
5.1if语句174
编程技巧5.1大括号布局177
编程技巧5.2总是使用大括号178
常见错误5.1if条件后有分号178
编程技巧5.3制表符178
专题5.1条件操作符179
编程技巧5.4避免不同分支中重复179
5.2比较值180
5.2.1关系操作符180
5.2.2比较浮点数181
5.2.3比较字符串182
5.2.4比较对象183
5.2.5测试null184
常见错误5.2使用==比较字符串185
操作指南5.1实现一个if语句186
实用示例5.1抽取中间字符188
计算与社会5.1丹佛机场的行李处理系统188
5.3多个候选条件189
专题5.2switch语句192
5.4嵌套分支193
编程技巧5.5手动跟踪196
常见错误5.3空悬else问题197
专题5.3块作用域198
专题5.4枚举类型199
5.5解决问题：流程图200
5.6解决问题：选择测试用例202
编程技巧5.6制订计划并为意料外的问题留出时间204
专题5.5记录日志205
5.7布尔变量和操作符205
常见错误5.4结合多个关系操作符208
常见错误5.5混淆&&和||条件209
专题56布尔操作符的短路计算209
专题5.7德·摩根定律210
5.8应用：输入验证211
计算与社会5.2人工智能213
第6章循环233
6.1while循环233
常见错误6.1不要想“我们到了吗？”239
常见错误6.2无限循环239
常见错误6.3差一错误240
6.2解决问题：手动跟踪241
计算与社会6.1数字盗版244
6.3for循环245
编程技巧6.1按其预期用途使用for循环250
编程技巧6.2选择满足任务要求的循环边界251
编程技巧6.3统计迭代251
专题6.1for循环首部中声明的变量252
6.4do循环253
编程技巧6.4画出循环的流程图254
6.5应用：处理卫哨值254
专题6.2输入和输出重定向257
专题6.3“半循环”问题258
专题6.4break和continue语句259
6.6解决问题：故事板260
6.7常用循环算法263
6.7.1求和与平均值263
6.7.2匹配计数263
6.7.3找到第一个匹配264
6.7.4提示用户输入，直到找到匹配265
6.7.5最大值和最小值265
6.7.6比较相邻值265
操作指南61写一个循环267
实用示例6.1信用卡处理270
6.8嵌套循环270
实用示例6.2处理图像中的像素273
6.9应用：随机数和仿真273
6.9.1生成随机数273
6.9.2蒙特卡罗方法275
6.10使用调试器277
操作指南6.2调试279
实用示例6.3示例调试会话281
计算与社会6.2第一个bug281
第7章数组和数组列表303
7.1数组303
7.1.1声明和使用数组303
7.1.2数组引用306
7.1.3利用方法使用数组307
7.1.4部分填充的数组307
常见错误7.1边界错误309
常见错误7.2未初始化和未填充的数组309
编程技巧7.1对相关数据项的序列使用数组309
编程技巧7.2将并行数组重组为对象数组310
专题7.1参数数目可变的方法311
计算与社会7.1计算机病毒311
7.2增强的for循环312
7.3常用数组算法
7.3.1填充314
7.3.2求和与平均值314
7.3.3最大值和最小值314
7.3.4元素分隔符315
7.3.5线性查找315
7.3.6删除一个元素316
7.3.7插入一个元素316
7.3.8交换元素317
7.3.9复制数组318
7.3.10读取输入319
常见错误7.3低估数据集的大小322
专题7.2利用Java库排序322
7.4解决问题：调整算法323
操作指南77处理数组325
实用示例7.1掷骰子327
7.5解决问题：通过管理实体对象发现算法327
7.6二维数组330
7.6.1声明二维数组331
7.6.2访问元素332
7.6.3定位相邻元素333
7.6.4访问行和列333
实用示例72世界人口表336
专题7.3行长度可变的二维数组336
专题7.4多维数组337
7.7数组列表338
7.7.1声明和使用数组列表338
7.7.2对数组列表使用增强的for循环340
7.7.3复制数组列表341
7.7.4包装器和自动装箱341
7.7.5对数组列表使用数组算法342
7.7.6在数组列表中存储输入值343
7.7.7删除匹配元素343
7.7.8在数组列表和数组间选择344
常见错误7.4长度和大小346
专题7.5钻石语法346
7.8回归测试346
编程技巧7.3批文件和Shel脚本349
计算与社会7.2Therac—25事件349
……
第二部分面向对象设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java程序设计概念:对象先行(原书第8版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle8i Java组件编程
译者序
序言
前言
第一篇 概述
第二篇 创建企业JavaBean组件
第三篇 创建CORBA组件
第四篇 使用Java Server Page创建Web应用程序
第五篇 附录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle8i Java组件编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java SE8 程序设计（第3版）英文版
推荐序
前言
阅读本书之前的准备
1 Introduction to Java and Test-Driving a Java Application
1.1 Introduction
1.2 Object Technology Concepts
1.2.1 The Automobile as an Object
1.2.2 Methods and Classes
1.2.3 Instantiation
1.2.4 Reuse
1.2.5 Messages and Method Calls
1.2.6 Attributes and Instance Variables
1.2.7 Encapsulation and Information Hiding
1.2.8 Inheritance
1.2.9 Interfaces
1.2.10 Object-Oriented Analysis and Design (OOAD)
1.2.11 The UML (Unified Modeling Language)
1.3 Open Source Software
1.4 Java
1.5 A Typical Java Development Environment
1.6 Test-Driving a Java Application
1.7 Software Technologies
1.8 Keeping Up-to-Date with Information Technologies
2 Introduction to Java Applications; Input/Output and Operators
2.1 Introduction
2.2 Your First Program in Java: Printing a Line of Text
2.3 Modifying Your First Java Program
2.4 Displaying Text with printf
2.5 Another Application: Adding Integers
2.6 Arithmetic
2.7 Decision Making: Equality and Relational Operators
2.8 Wrap-Up
3 Introduction to Classes, Objects, Methods and Strings
3.1 Introduction
3.2 Instance Variables, set Methods and get Methods
3.2.1 Account Class with an Instance Variable, a set Method and a get Method
3.2.2 AccountTest Class That Creates and Uses an Object of Class Account
3.2.3 Compiling and Executing an App with Multiple Classes
3.2.4 Account UML Class Diagram with an Instance Variable and set and get Methods
3.2.5 Additional Notes on Class AccountTest
3.2.6 Software Engineering with private Instance Variables and public set and get Methods
3.3 Primitive Types vs. Reference Types
3.4 Account Class: Initializing Objects with Constructors
3.4.1 Declaring an Account Constructor for Custom Object Initialization
3.4.2 Class AccountTest : Initializing Account Objects When They’re Created
3.5 Account Class with a Balance; Floating-Point Numbers
3.5.1 Account Class with a balance Instance Variable of Type double
3.5.2 AccountTest Class to Use Class Account
3.6 Wrap-Up
4 Control Statements: Part 1; Assignment, ++ and -- Operators
4.1 Introduction
4.2 Control Structures
4.3 if Single-Selection Statement
4.4 if … else Double-Selection Statement
4.5 Student Class: Nested if … else Statements
4.6 while Repetition Statement
4.7 Counter-Controlled Repetition
4.8 Sentinel-Controlled Repetition
4.9 Nested Control Statements
4.10 Compound Assignment Operators
4.11 Increment and Decrement Operators
4.12 Primitive Types
4.13 Wrap-Up
5 Control Statements: Part 2; Logical Operators
5.1 Introduction
5.2 Essentials of Counter-Controlled Repetition
5.3 for Repetition Statement
5.4 Examples Using the for Statement
5.5 do … while Repetition Statement
5.6 switch Multiple-Selection Statement
5.7 Class AutoPolicy Case Study: String s in switch Statements
5.8 break and continue Statements
5.9 Logical Operators
5.10 Wrap-Up
6 Methods: A Deeper Look
6.1 Introduction
6.2 Program Modules in Java
6.3 static Methods, static Fields and Class Math
6.4 Declaring Methods with Multiple Parameters
6.5 Notes on Declaring and Using Methods
6.6 Argument Promotion and Casting
6.7 Java API Packages
6.8 Case Study: Secure Random-Number Generation
6.9 Case Study: A Game of Chance; Introducing enum Types
6.10 Scope of Declarations
6.11 Method Overloading
6.12 Wrap-Up
7 Arrays and ArrayLists
7.1 Introduction
7.2 Arrays
7.3 Declaring and Creating Arrays
7.4 Examples Using Arrays
7.4.1 Creating and Initializing an Array
7.4.2 Using an Array Initializer
7.4.3 Calculating the Values to Store in an Array
7.4.4 Summing the Elements of an Array
7.4.5 Using Bar Charts to Display Array Data Graphically
7.4.6 Using the Elements of an Array as Counters
7.4.7 Using Arrays to Analyze Survey Results
7.5 Exception Handling: Processing the Incorrect Response
7.5.1 The try Statement
7.5.2 Executing the catch Block
7.5.3 toString Method of the Exception Parameter
7.6 Case Study: Card Shuffling and Dealing Simulation
7.7 Enhanced for Statement
7.8 Passing Arrays to Methods
7.9 Pass-By-Value vs. Pass-By-Reference
7.10 Case Study: Class GradeBook Using an Array to Store Grades
7.11 Multidimensional Arrays
7.12 Case Study: Class GradeBook Using a Two-Dimensional Array
7.13 Variable-Length Argument Lists
7.14 Using Command-Line Arguments
7.15 Class Arrays
7.16 Introduction to Collections and Class ArrayList
7.17 Wrap-Up
8 Classes and Objects: A Deeper Look
8.1 Introduction
8.2 Time Class Case Study
8.3 Controlling Access to Members
8.4 Referring to the Current Object’s Members with the this Reference
8.5 Time Class Case Study: Overloaded Constructors
8.6 Default and No-Argument Constructors
8.7 Notes on Set and Get Methods
8.8 Composition
8.9 enum Types
8.10 Garbage Collection
8.11 static Class Members
8.12 static Import
8.13 final Instance Variables
8.14 Time Class Case Study: Creating Packages
8.15 Package Access
8.16 Using BigDecimal for Precise Monetary Calculations
8.17 Wrap-Up
9 Object-Oriented Programming: Inheritance
9.1 Introduction
9.2 Superclasses and Subclasses
9.3 protected Members
9.4 Relationship Between Superclasses and Subclasses
9.4.1 Creating and Using a CommissionEmployee Class
9.4.2 Creating and Using a BasePlusCommissionEmployee Class
9.4.3 Creating a CommissionEmployee – BasePlusCommissionEmployee Inheritance Hierarchy
9.4.4 CommissionEmployee – BasePlusCommissionEmployee Inheritance Hierarchy Using protected Instance Variables
9.4.5 CommissionEmployee – BasePlusCommissionEmployee Inheritance Hierarchy Using private Instance Variables
9.5 Constructors in Subclasses
9.6 Class Object
9.7 Wrap-Up
10 Object-Oriented Programming: Polymorphism and Interfaces
10.1 Introduction
10.2 Polymorphism Examples
10.3 Demonstrating Polymorphic Behavior
10.4 Abstract Classes and Methods
10.5 Case Study: Payroll System Using Polymorphism
10.5.1 Abstract Superclass Employee
10.5.2 Concrete Subclass SalariedEmployee
10.5.3 Concrete Subclass HourlyEmployee
10.5.4 Concrete Subclass CommissionEmployee
10.5.5 Indirect Concrete Subclass BasePlusCommissionEmployee
10.5.6 Polymorphic Processing, Operator instanceof and Downcasting
10.6 Allowed Assignments Between Superclass and Subclass Variables
10.7 final Methods and Classes
10.8 A Deeper Explanation of Issues with Calling Methods from Constructors
10.9 Creating and Using Interfaces
10.9.1 Developing a Payable Hierarchy
10.9.2 Interface Payable
10.9.3 Class Invoice
10.9.4 Modifying Class Employee to Implement Interface Payable
10.9.5 Modifying Class SalariedEmployee for Use in the Payable Hierarchy
10.9.6 Using Interface Payable to Process Invoice s and Employees Polymorphically
10.9.7 Some Common Interfaces of the Java API
10.10 Java SE 8 Interface Enhancements
10.10.1 default Interface Methods
10.10.2 static Interface Methods
10.10.3 Functional Interfaces
10.11 Wrap-Up
11 Exception Handling: A Deeper Look
11.1 Introduction
11.2 Example: Divide by Zero without Exception Handling
11.3 Exception Handling: ArithmeticExceptions and InputMismatchExceptions
11.4 When to Use Exception Handling
11.5 Java Exception Hierarchy
11.6 finally Block
11.7 Stack Unwinding and Obtaining Information from an Exception Object 322
11.8 Chained Exceptions
11.9 Declaring New Exception Types
11.10 Preconditions and Postconditions
11.11 Assertions
11.12 try -with-Resources: Automatic Resource Deallocation
11.13 Wrap-Up
12 Swing GUI Components: Part
12.1 Introduction
12.2 Java’s Nimbus Look-and-Feel
12.3 Simple GUI-Based Input/Output with JOptionPane
12.4 Overview of Swing Components
12.5 Displaying Text and Images in a Window
12.6 Text Fields and an Introduction to Event Handling with Nested Classes
12.7 Common GUI Event Types and Listener Interfaces
12.8 How Event Handling Works
12.9 JButton
12.10 Buttons That Maintain State
12.10.1 JCheckBox
12.10.2 JRadioButton
12.11 JComboBox ; Using an Anonymous Inner Class for Event Handling
12.12 JList
12.13 Multiple-Selection Lists
12.14 Mouse Event Handling
12.15 Adapter Classes
12.16 JPanel Subclass for Drawing with the Mouse
12.17 Key Event Handling
12.18 Introduction to Layout Managers
12.18.1 FlowLayout
12.18.2 BorderLayout
12.18.3 GridLayout
12.19 Using Panels to Manage More Complex Layouts
12.20 JTextArea
12.21 Wrap-Up
13 Graphics and Java 2D
13.1 Introduction
13.2 Graphics Contexts and Graphics Objects
13.3 Color Control
13.4 Manipulating Fonts
13.5 Drawing Lines, Rectangles and Ovals
13.6 Drawing Arcs
13.7 Drawing Polygons and Polylines
13.8 Java 2D API
13.9 Wrap-Up
14 Strings, Characters and Regular Expressions
14.1 Introduction
14.2 Fundamentals of Characters and Strings
14.3 Class String
14.3.1 String Constructors
14.3.2 String Methods length , charAt and getChars
14.3.3 Comparing Strings
14.3.4 Locating Characters and Substrings in Strings
14.3.5 Extracting Substrings from Strings
14.3.6 Concatenating Strings
14.3.7 Miscellaneous String Methods
14.3.8 String Method valueOf
14.4 Class StringBuilder
14.4.1 StringBuilder Constructors
14.4.2 StringBuilder Methods length , capacity , setLength and ensureCapacity
14.4.3 StringBuilder Methods charAt , setCharAt , getChars and reverse
14.4.4 StringBuilder append Methods
14.4.5 StringBuilder Insertion and Deletion Methods
14.5 Class Character
14.6 Tokenizing String s
14.7 Regular Expressions, Class Pattern and Class Matcher
14.8 Wrap-Up
15 Files, Streams and Object Serialization
15.1 Introduction
15.2 Files and Streams
15.3 Using NIO Classes and Interfaces to Get File and Directory Information
15.4 Sequential-Access Text Files
15.4.1 Creating a Sequential-Access Text File
15.4.2 Reading Data from a Sequential-Access Text File
15.4.3 Case Study: A Credit-Inquiry Program
15.4.4 Updating Sequential-Access Files
15.5 Object Serialization
15.5.1 Creating a Sequential-Access File Using Object Serialization
15.5.2 Reading and Deserializing Data from a Sequential-Access File
15.6 Opening Files with JFileChooser
15.7 (Optional) Additional java.io Classes
15.7.1 Interfaces and Classes for Byte-Based Input and Output
15.7.2 Interfaces and Classes for Character-Based Input and Output
15.8 Wrap-Up
16 Generic Collections
16.1 Introduction
16.2 Collections Overview
16.3 Type-Wrapper Classes
16.4 Autoboxing and Auto-Unboxing
16.5 Interface Collection and Class Collections
16.6 Lists
16.6.1 ArrayList and Iterator
16.6.2 LinkedList
16.7 Collections Methods
16.7.1 Method sort
16.7.2 Method shuffle
16.7.3 Methods reverse , fill , copy , max and min
16.7.4 Method binarySearch
16.7.5 Methods addAll , frequency and disjoint
16.8 Stack Class of Package java.util
16.9 Class PriorityQueue and Interface Queue
16.10 Sets
16.11 Maps
16.12 Properties Class
16.13 Synchronized Collections
16.14 Unmodifiable Collections
16.15 Abstract Implementations
16.16 Wrap-Up
17 Java SE 8 Lambdas and Streams
17.1 Introduction
17.2 Functional Programming Technologies Overview
17.2.1 Functional Interfaces
17.2.2 Lambda Expressions
17.2.3 Streams
17.3 IntStream Operations
17.3.1 Creating an IntStream and Displaying Its Values with the forEach Terminal Operation
17.3.2 Terminal Operations count , min , max , sum and average
17.3.3 Terminal Operation reduce
17.3.4 Intermediate Operations: Filtering and Sorting IntStream Values
17.3.5 Intermediate Operation: Mapping
17.3.6 Creating Streams of int s with IntStream Methods range and rangeClosed
17.4 Stream<Integer> Manipulations
17.4.1 Creating a Stream<Integer>
17.4.2 Sorting a Stream and Collecting the Results
17.4.3 Filtering a Stream and Storing the Results for Later Use
17.4.4 Filtering and Sorting a Stream and Collecting the Results
17.4.5 Sorting Previously Collected Results
17.5 Stream<String> Manipulations
17.5.1 Mapping String s to Uppercase Using a Method Reference
17.5.2 Filtering String s Then Sorting Them in Case-Insensitive Ascending Order
17.5.3 Filtering String s Then Sorting Them in Case-Insensitive Descending Order
17.6 Stream<Employee> Manipulations
17.6.1 Creating and Displaying a List<Employee>
17.6.2 Filtering Employee s with Salaries in a Specified Range
17.6.3 Sorting Employee s By Multiple Fields
17.6.4 Mapping Employee s to Unique Last Name String s
17.6.5 Grouping Employee s By Department
17.6.6 Counting the Number of Employee s in Each Department
17.6.7 Summing and Averaging Employee Salaries
17.7 Creating a Stream<String> from a File
17.8 Generating Streams of Random Values
17.9 Lambda Event Handlers
17.10 Additional Notes on Java SE 8 Interfaces
17.11 Java SE 8 and Functional Programming Resources
17.12 Wrap-Up
18 Generic Classes and Methods
18.1 Introduction
18.2 Motivation for Generic Methods
18.3 Generic Methods: Implementation and Compile-Time Translation
18.4 Additional Compile-Time Translation Issues: Methods That Use a Type Parameter as the Return Type
18.5 Overloading Generic Methods
18.6 Generic Classes
18.7 Raw Types
18.8 Wildcards in Methods That Accept Type Parameters
18.9 Wrap-Up
19 Swing GUI Components: Part
19.1 Introduction
19.2 JSlider
19.3 Understanding Windows in Java
19.4 Using Menus with Frames
19.5 JPopupMenu
19.6 Pluggable Look-and-Feel
19.7 JDesktopPane and JInternalFrame
19.8 JTabbedPane
19.9 BoxLayout Layout Manager
19.10 GridBagLayout Layout Manager
19.11 Wrap-Up
20 Concurrency
20.1 Introduction
20.2 Thread States and Life Cycle
20.2.1 New and Runnable States
20.2.2 Waiting State
20.2.3 Timed Waiting State
20.2.4 Blocked State
20.2.5 Terminated State
20.2.6 Operating-System View of the Runnable State
20.2.7 Thread Priorities and Thread Scheduling
20.2.8 Indefinite Postponement and Deadlock
20.3 Creating and Executing Threads with the Executor Framework
20.4 Thread Synchronization
20.4.1 Immutable Data
20.4.2 Monitors
20.4.3 Unsynchronized Mutable Data Sharing
20.4.4 Synchronized Mutable Data Sharing—Making Operations Atomic
20.5 Producer/Consumer Relationship without Synchronization
20.6 Producer/Consumer Relationship: ArrayBlockingQueue
20.7 (Advanced) Producer/Consumer Relationship with synchronized , wait , notify and notifyAll
20.8 (Advanced) Producer/Consumer Relationship: Bounded Buffers
20.9 (Advanced) Producer/Consumer Relationship: The Lock and Condition Interfaces
20.10 Concurrent Collections
20.11 Multithreading with GUI: SwingWorker
20.11.1 Performing Computations in a Worker Thread: Fibonacci Numbers
20.11.2 Processing Intermediate Results: Sieve of Eratosthenes
20.12 sort / parallelSort Timings with the Java SE 8 Date/Time API
20.13 Java SE 8: Sequential vs. Parallel Streams
20.14 (Advanced) Interfaces Callable and Future
20.15 (Advanced) Fork/Join Framework
20.16 Wrap-Up
21 Accessing Databases with JDBC
21.1 Introduction
21.2 Relational Databases
21.3 A books Database
21.4 SQL
21.4.1 Basic SELECT Query
21.4.2 WHERE Clause
21.4.3 ORDER BY Clause
21.4.4 Merging Data from Multiple Tables: INNER JOIN
21.4.5 INSERT Statement
21.4.6 UPDATE Statement
21.4.7 DELETE Statement
21.5 Setting up a Java DB Database
21.5.1 Creating the Chapter’s Databases on Windows
21.5.2 Creating the Chapter’s Databases on Mac OS X
21.5.3 Creating the Chapter’s Databases on Linux
21.6 Manipulating Databases with JDBC
21.6.1 Connecting to and Querying a Database
21.6.2 Querying the books Database
21.7 RowSet Interface
21.8 PreparedStatement s
21.9 Stored Procedures
21.10 Transaction Processing
21.11 Wrap-Up
22 JavaFX GUI
22.1 Introduction
22.2 JavaFX Scene Builder and the NetBeans IDE
22.3 JavaFX App Window Structure
22.4 Welcome App—Displaying Text and an Image
22.4.1 Creating the App’s Project
22.4.2 NetBeans Projects Window—Viewing the Project Contents
22.4.3 Adding an Image to the Project
22.4.4 Opening JavaFX Scene Builder from NetBeans
22.4.5 Changing to a VBox Layout Container
22.4.6 Configuring the VBox Layout Container
22.4.7 Adding and Configuring a Label
22.4.8 Adding and Configuring an ImageView
22.4.9 Running the Welcome App
22.5 Tip Calculator App—Introduction to Event Handling
22.5.1 Test-Driving the Tip Calculator App
22.5.2 Technologies Overview
22.5.3 Building the App’s GUI
22.5.4 TipCalculator Class
22.5.5 TipCalculatorController Class
22.6 Wrap-Up
23 ATM Case Study, Part 1: Object-Oriented Design with the UML
23.1 Case Study Introduction
23.2 Examining the Requirements Document
23.3 Identifying the Classes in a Requirements Document
23.4 Identifying Class Attributes
23.5 Identifying Objects’ States and Activities
23.6 Identifying Class Operations
23.7 Indicating Collaboration Among Objects
23.8 Wrap-Up
24 ATM Case Study Part 2: Implementing an Object-Oriented Design
24.1 Introduction
24.2 Starting to Program the Classes of the ATM System
24.3 Incorporating Inheritance and Polymorphism into the ATM System
24.4 ATM Case Study Implementation
24.4.1 Class ATM
24.4.2 Class Screen
24.4.3 Class Keypad
24.4.4 Class CashDispenser
24.4.5 Class DepositSlot
24.4.6 Class Account
24.4.7 Class BankDatabase
24.4.8 Class Transaction
24.4.9 Class BalanceInquiry
24.4.10 Class Withdrawal
24.4.11 Class Deposit
24.4.12 Class ATMCaseStudy
24.5 Wrap-Up
A Operator Precedence Chart
B ASCII Character Set
C Keywords and Reserved Words
D Primitive Types
E Using the Debugger
E.1 Introduction
E.2 Breakpoints and the run , stop , cont and print Commands
E.3 The print and set Commands
E.4 Controlling Execution Using the step , step up and next Commands
E.5 The watch Command
E.6 The clear Command
E.7 Wrap-Up
F Using the Java API Documentation
F.1 Introduction
F.2 Navigating the Java API
G Creating Documentation with javadoc
G.1 Introduction
G.2 Documentation Comments
G.3 Documenting Java Source Code
G.4 javadoc
G.5 Files Produced by javadoc
H Unicode®
H.1 Introduction
H.2 Unicode Transformation Formats
H.3 Characters and Glyphs
H.4 Advantages/Disadvantages of Unicode
H.5 Using Unicode
H.6 Character Ranges
I Formatted Output
I.1 Introduction
I.2 Streams
I.3 Formatting Output with printf
I.4 Printing Integers
I.5 Printing Floating-Point Numbers
I.6 Printing Strings and Characters
I.7 Printing Dates and Times
I.8 Other Conversion Characters
I.9 Printing with Field Widths and Precisions
I.10 Using Flags in the printf Format String
I.11 Printing with Argument Indices
I.12 Printing Literals and Escape Sequences
I.13 Formatting Output with Class Formatter
I.14 Wrap-Up
J Number Systems
J.1 Introduction
J.2 Abbreviating Binary Numbers as Octal and Hexadecimal Numbers
J.3 Converting Octal and Hexadecimal Numbers to Binary Numbers
J.4 Converting from Binary, Octal or Hexadecimal to Decimal
J.5 Converting from Decimal to Binary, Octal or Hexadecimal
J.6 Negative Binary Numbers: Two’s Complement Notation
K Bit Manipulation
K.1 Introduction
K.2 Bit Manipulation and the Bitwise Operators
K.3 BitSet Class
L Labeled break and continue Statements
L.1 Introduction
L.2 Labeled break Statement
L.3 Labeled continue Statement
M UML 2: Additional Diagram Types
M.1 Introduction
M.2 Additional Diagram Types
N Design Patterns
N.1 Introduction
N.2 Creational, Structural and Behavioral Design Patterns
N.2.1 Creational Design Patterns
N.2.2 Structural Design Patterns
N.2.3 Behavioral Design Patterns
N.2.4 Conclusion
N.3 Design Patterns in Packages java.awt and javax.swing
N.3.1 Creational Design Patterns
N.3.2 Structural Design Patterns
N.3.3 Behavioral Design Patterns
N.3.4 Conclusion
N.4 Concurrency Design Patterns
N.5 Design Patterns Used in Packages java.io and java.net
N.5.1 Creational Design Patterns
N.5.2 Structural Design Patterns
N.5.3 Architectural Patterns
N.5.4 Conclusion
N.6 Design Patterns Used in Package java.util
N.6.1 Creational Design Patterns
N.6.2 Behavioral Design Patterns
N.7 Wrap-Up
Index
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java SE8 程序设计（第3版）英文版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 11官方入门教程(第8版)

第1章  Java基础   1
1.1  Java的历史和基本原则   2
1.1.1  Java的起源   2
1.1.2  Java与C和C++的关系   3
1.1.3  Java对Internet的贡献   3
1.1.4  Java的魔法：字节码   4
1.1.5  超越applet   5
1.1.6  更快速的发布时间表   6
1.1.7  Java的主要术语   6
1.2  面向对象程序设计   6
1.2.1  封装   7
1.2.2  多态性   8
1.2.3  继承   8
1.3  Java开发工具包   8
1.4  第一个简单的程序   9
1.4.1  输入程序   9
1.4.2  编译程序   10
1.4.3  逐行分析第一个程序   10
1.5  处理语法错误   12
1.6  第二个简单程序   12
1.7  另一种数据类型   14
1.8  两个控制语句   16
1.8.1  if语句   16
1.8.2  for循环语句   18
1.9  创建代码块   19
1.10  分号和定位   20
1.11  缩进原则   20
1.12  Java关键字   22
1.13  Java标识符   23
1.14  Java类库   23
1.15  自测题   23
第2章  数据类型与运算符   25
2.1  数据类型为什么重要   26
2.2  Java的基本类型   26
2.2.1  整数类型   26
2.2.2  浮点型   27
2.2.3  字符型   28
2.2.4  布尔类型   29
2.3  字面值   31
2.3.1  十六进制、八进制和二进制字面值   31
2.3.2  字符转义序列   32
2.3.3  字符串字面值   32
2.4  变量详解   33
2.4.1  初始化变量   33
2.4.2  动态初始化   33
2.5  变量的作用域和生命期   34
2.6  运算符   36
2.7  算术运算符   36
2.8  关系运算符和逻辑运算符   37
2.9  短路逻辑运算符   39
2.10  赋值运算符   40
2.11  速记赋值   40
2.12  赋值中的类型转换   41
2.13  不兼容类型的强制转换   42
2.14  运算符的优先级   43
2.15  表达式   45
2.15.1  表达式中的类型转换   45
2.15.2  间距和圆括号   46
2.16  自测题   47
第3章  程序控制语句   49
3.1  从键盘输入字符   50
3.2  if语句   51
3.2.1  嵌套if语句   52
3.2.2  if-else-if阶梯状结构   53
3.3  switch语句   54
3.4  for循环   58
3.4.1  for循环的一些变体   60
3.4.2  缺失部分要素的for循环   61
3.4.3  无限循环   61
3.4.4  没有循环体的循环   62
3.4.5  在for循环内部声明循环控制变量   62
3.4.6  增强型for循环   63
3.5  while循环   63
3.6  do-while循环   64
3.7  使用break语句退出循环   69
3.8  将break语句作为一种goto语句使用   70
3.9  使用continue语句   73
3.10  嵌套循环   77
3.11  自测题   78
第4章  类、对象和方法   81
4.1  类的基础知识   82
4.1.1  类的基本形式   82
4.1.2  定义类   83
4.2  如何创建对象   85
4.3  引用变量和赋值   85
4.4  方法   86
4.5  从方法返回值   88
4.6  返回值   89
4.7  使用形参   90
4.8  构造函数   98
4.9  带形参的构造函数   99
4.10  深入介绍new运算符   100
4.11  垃圾回收   101
4.12  this关键字   101
4.13  自测题   103
第5章  其他数据类型与运算符   105
5.1  数组   106
5.2  多维数组   110
5.2.1  二维数组   110
5.2.2  不规则数组   111
5.2.3  三维或更多维的数组   112
5.2.4  初始化多维数组   112
5.3  另一种声明数组的语法   113
5.4  数组引用赋值   114
5.5  使用length成员   115
5.6  for-each形式的循环   119
5.6.1  迭代多维数组   122
5.6.2  应用增强型for循环   123
5.7  字符串   123
5.7.1  构造字符串   124
5.7.2  操作字符串   124
5.7.3  字符串数组   126
5.7.4  字符串是不可变的   127
5.7.5  使用String控制switch语句   128
5.8  使用命令行实参   128
5.9  使用局部变量的类型推断功能   130
5.9.1  引用类型的局部变量类型推断   131
5.9.2  在for循环中使用局部变量类型推断   132
5.9.3  var的一些限制   133
5.10  位运算符   133
5.10.1  位运算符的与、或、异或和非   134
5.10.2  移位运算符   137
5.10.3  位运算符的赋值速记符   139
5.11  ?运算符   141
5.12  自测题   143
第6章  方法和类详解   145
6.1  控制对类成员的访问   146
6.2  向方法传递对象   150
6.3  返回对象   153
6.4  方法重载   155
6.5  重载构造函数   159
6.6  递归   163
6.7  理解static关键字   165
6.8  嵌套类和内部类   170
6.9  varargs   173
6.9.1  varargs基础   173
6.9.2  重载varargs方法   175
6.9.3  varargs和歧义   177
6.10  自测题   178
第7章  继承   179
7.1  继承的基础知识   180
7.2  成员访问与继承   182
7.3  构造函数和继承   184
7.4  使用super调用超类构造函数   186
7.5  使用super访问超类成员   189
7.6  创建多级层次结构   192
7.7  何时调用构造函数   195
7.8  超类引用和子类对象   196
7.9  方法重写   200
7.10  重写的方法支持多态性   202
7.11  为何使用重写方法   203
7.12  使用抽象类   207
7.13  使用final   210
7.13.1  使用final防止重写   210
7.13.2  使用final防止继承   210
7.13.3  对数据成员使用final   211
7.14  Object类   212
7.15  自测题   213
第8章  包和接口   215
8.1  包   216
8.1.1  定义包   216
8.1.2  寻找包和CLASSPATH   217
8.1.3  一个简短的包示例   217
8.2  包和成员访问   218
8.3  理解被保护的成员   220
8.4  导入包   222
8.5  Java的类库位于包中   223
8.6  接口   223
8.7  实现接口   224
8.8  使用接口引用   227
8.9  接口中的变量   233
8.10  接口能够扩展   234
8.11  默认接口方法   235
8.11.1  默认方法的基础知识   235
8.11.2  默认方法的实际应用   236
8.11.3  多继承问题   237
8.12  在接口中使用静态方法   238
8.13  私有接口方法   239
8.14  有关包和接口的最后思考   240
8.15  自测题   240
第9章  异常处理   241
9.1  异常的层次结构   242
9.2  异常处理基础   242
9.2.1  使用关键字try和catch   242
9.2.2  一个简单的异常示例   243
9.3  未捕获异常的结果   245
9.4  使用多个catch语句   247
9.5  捕获子类异常   247
9.6  try代码块可以嵌套   248
9.7  抛出异常   249
9.8  Throwable详解   251
9.9  使用finally   252
9.10  使用throws语句   254
9.11  另外3种异常功能   255
9.12  Java的内置异常   256
9.13  创建异常子类   258
9.14  自测题   262
第10章  使用I/O   265
10.1  基于流的Java I/O   266
10.2  字节流和字符流   266
10.3  字节流类   266
10.4  字符流类   267
10.5  预定义流   267
10.6  使用字节流   268
10.6.1  读取控制台输入   269
10.6.2  写入控制台输出   269
10.7  使用字节流读写文件   270
10.7.1  从文件输入   270
10.7.2  写入文件   273
10.8  自动关闭文件   275
10.9  读写二进制数据   277
10.10  随机访问文件   281
10.11  使用Java字符流   283
10.11.1  使用字符流的控制台输入   284
10.11.2  使用字符流的控制台输出   286
10.12  使用字符流的文件I/O   287
10.12.1  使用FileWriter   287
10.12.2  使用FileReader   288
10.13  使用Java的类型封装器转换数值字符串   289
10.14  自测题   296
第11章  多线程程序设计   299
11.1  多线程的基础知识   300
11.2  Thread类和Runnable接口   300
11.3  创建一个线程   301
11.4  创建多个线程   309
11.5  确定线程何时结束   311
11.6  线程的优先级   314
11.7  同步   316
11.8  使用同步方法   317
11.9  同步语句   319
11.10  使用notify( )、wait( )和notifyAll( )的线程通信   321
11.11  线程的挂起、继续执行和停止   326
11.12  自测题   330
第12章  枚举、自动装箱、静态导入和注解   333
12.1  枚举   334
12.2  Java语言中的枚举是类类型   336
12.3  values( )和valueOf( )方法   336
12.4  构造函数、方法、实例变量和枚举   337
12.5  枚举继承enum   339
12.6  自动装箱   344
12.7  类型封装器   344
12.8  自动装箱的基础知识   346
12.9  自动装箱和方法   347
12.10  发生在表达式中的自动装箱/自动拆箱   348
12.11  静态导入   349
12.12  注解(元数据)   352
12.13  自测题   354
第13章  泛型   355
13.1  泛型的基础知识   356
13.2  简单的泛型示例   356
13.2.1  泛型只能用于引用类型   359
13.2.2  泛型类型是否相同基于其类型实参   359
13.2.3  带有两个类型形参的泛型类   360
13.2.4  泛型类的一般形式   361
13.3  受限类型   361
13.4  使用通配符实参   364
13.5  受限通配符   366
13.6  泛型方法   369
13.7  泛型构造函数   370
13.8  泛型接口   371
13.9  原类型和遗留代码   377
13.10  使用菱形运算符进行类型推断   379
13.11  局部变量类型推断和泛型   380
13.12  擦除特性   380
13.13  歧义错误   380
13.14  一些泛型限制   381
13.14.1  类型形参不能实例化   381
13.14.2  对静态成员的限制   381
13.14.3  泛型数组限制   382
13.14.4  泛型异常限制   383
13.15  继续学习泛型   383
13.16  自测题   383
第14章  lambda表达式和方法引用   385
14.1  lambda表达式简介   386
14.1.1  lambda表达式的基础知识   386
14.1.2  函数式接口   387
14.1.3  几个lambda表达式示例   389
14.2  块lambda表达式   392
14.3  泛型函数式接口   393
14.4  lambda表达式和变量捕获   398
14.5  从 lambda表达式中抛出异常   399
14.6  方法引用   401
14.6.1  静态方法的方法引用   401
14.6.2  实例方法的方法引用   402
14.7  构造函数引用   406
14.8  预定义的函数式接口   408
14.9  自测题   409
第15章  模块   411
15.1  模块基础   412
15.1.1  简单的模块示例   413
15.1.2  编译、运行第一个模块示例   416
15.1.3  requires和exports   417
15.2  java.base和平台模块   417
15.3  旧代码和未命名的模块   418
15.4  导出到特定的模块   419
15.5  使用requires transitive   420
15.6  使用服务   423
15.6.1  服务和服务提供程序的基础知识   423
15.6.2  基于服务的关键字   424
15.6.3  基于模块的服务示例   424
15.7  其他模块功能   430
15.7.1  open模块   430
15.7.2  opens语句   430
15.7.3  requires static   430
15.8  继续模块的学习   431
15.9  自测题   431
第16章  Swing介绍   433
16.1  Swing的起源和设计原则   434
16.2  组件和容器   435
16.2.1  组件   435
16.2.2  容器   436
16.2.3  顶级容器窗格   436
16.3  布局管理器   436
16.4  第一个简单的Swing程序   437
16.5  Swing事件处理   440
16.5.1  事件   441
16.5.2  事件源   441
16.5.3  事件监听器   441
16.5.4  事件类和监听器接口   441
16.6  使用JButton   442
16.7  使用JTextField   445
16.8  使用JCheckBox   448
16.9  使用JList   450
16.10  使用匿名内部类或lambda表达式来处理事件   458
16.11  自测题   459
附录A  自测题答案   461
附录B  使用Java的文档注释   495
附录C  编译运行简单的单文件程序   503
附录D  JShell简介   505
附录E  更多Java关键字   513


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java 11官方入门教程(第8版)
