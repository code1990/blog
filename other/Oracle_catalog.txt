>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>甲骨文
【古文物A】地下城市
第一章 中間人
【古文物B】 文字的世界
第二章 美國之音
第三章 斷橋
【古文物C】 城牆
第四章 一夜之城
第五章 澱粉
第六章 好萊塢
【古文物D】 龜之聲
第七章 夜空不寂寞
第八章 移民
第九章 四合院
【古文物E】 青銅馬首
第十章 週年慶
第十一章 四川人
【古文物F】 書
第十二章 政治庇護
【古文物G】 鑿不裂的骨片
第十三章 奧運會
第十四章 風沙
【古文物H】 文字
第十五章 翻譯
第十六章 國旗
第十七章 直接入鏡
【古文物I】 馬
第十八章 混沌西方
第十九章 選舉
第二十章 唐人街
【古文物J 】 批判主義
第二十一章 國事訪問
【古文物K】 遺失的字母
第二十二章 濃縮精華
【古文物L】 抄錯的字
第二十三章 巴頓將軍之墓
【古文物Z 】 賣掉的字
第二十四章 茶
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>甲骨文
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>上帝与拉里.埃里森的不同
前言
1埃里森其人
2拒绝传统智慧
3成为传奇的伙伴关系
4红杏出墙一枝独秀
5发生了什么事
6埃里森决定雇请女性
7不败的策略
8终极的Oracle
9祸起萧墙
10股东对埃里森提起诉讼
11埃里森会失去工作吗
12网上传“情”
13购苹果公司拉盖茨下马
14把计算机处理掉
15上帝与埃里森的不同
后记

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>上帝与拉里.埃里森的不同
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>涂抹Oracle
精彩不止一两抹
前言
致谢
第1章 Oracle传奇
1.1 起源
1.2 发展
1.3 挫折
1.4 兴旺
1.5 革新
1.6 前进
第一部分 初始化环境
第2章 安装Oracle数据库软件
2.1 Windows平台下安装Oracle10gR
2.1.1 安装条件
2.1.2 执行安装
2.2 Linux平台下安装Oracle10gR
2.2.1 系统要求
2.2.2 检查环境
2.2.3 配置安装环境
2.2.4 执行安装
第3章 创建Oracle数据库
3.1 创建Oracle数据库
3.1.1 DBCA是啥来头
3.1.2 执行数据库创建
3.2 配置监听
3.2.1 创建监听服务
3.2.2 启用监听服务
3.2.3 启动和停止监听服务
第4章 进入Oracle数据库
4.1 认识连接工具
4.2 第一次连接
4.3 启动和停止数据库
4.3.1 启动数据库
4.3.2 停止数据库
4.4 连接到远端数据库
4.4.1 配置Net服务名
4.4.2 通过网络服务名连接数据库
4.5 创建用户
第二部分 加载数据
第5章 SQL*Loader加载数据
5.1 认识SQL*Loader
5.2 SQL*Loader体系结构
5.2.1 控制文件
5.2.2 日志文件
5.2.3 错误文件
5.2.4 废弃文件
5.3 一千零一十一个怎么办
5.3.1 给我的是个Excel文件怎么办
5.3.2 要加载的文件不是以逗号分隔怎么办
5.3.3 要加载的数据中包含分隔符怎么办
5.3.4 数据文件没有分隔符怎么办
5.3.5 数据文件中的列比要导入的表中列少怎么办
5.3.6 数据文件中的列比要导入的表中列多怎么办
5.3.7 提供了多个数据文件,要导入同一张表怎么办
5.3.8 同一个数据文件,要导入不同表怎么办
5.3.9 数据文件前N行不想导入怎么办
5.3.10 要加载的数据中有换行符怎么办
5.3.11 要导入大字段（LOB类型）怎么办
5.3.12 某些字段无值导致加载报错怎么办
5.4 100万条记录的数据加载
5.4.1 生成百万级数据文件
5.4.2 初始化环境
5.4.3 执行导入
5.4.4 能不能快一点呢
5.4.5 能不能再快一点呢
5.4.6 有没有可能更快
5.5 SQL*Loader加载综述
第6章 外部表加载数据
6.1 如何创建外部表
6.1.1 CREATETABLE语句创建
6.1.2 SQL*Loader创建
6.2 解读外部表
6.2.1 第一部分指定表结构
6.2.2 第二部分指定访问驱动和路径
6.2.3 第三部分指定加载参数
6.2.4 第四部分指定数据来源
6.3 有问有答学用外部表
6.3.1 外部表有加载日志吗
6.3.2 能像普通表那样修改属性吗
6.3.3 有多个文件要加载怎么办
6.3.4 外部表加载实际效率怎么样
6.3.5 怎么用外部表实现数据加载/卸载
6.4 访问驱动的故事
6.4.1 ORACLE_DATAPUMP驱动
6.4.2 ORACLE_LOADER驱动
6.5 外部表加载综述
第三部分 保护数据
第7章 备份与恢复基础扫盲
7.1 什么是备份
7.1.1 备份类型
7.1.2 数据库状态
7.1.3 备份的状态
7.1.4 备份规模
7.2 什么是恢复
7.2.1 错误类型
7.2.2 恢复类型
7.2.3 恢复方式
7.2.4 恢复操作
7.2.5 RESETLOGS操作
7.3 常见备份与恢复技术
7.3.1 用户管理的备份和恢复（User-Managed Backups & Recovery）
7.3.2 RMAN备份和恢复（Recover Manager Backups & Recovery）
7.3.3 逻辑导入/导出（Export/Import和Data Pump)
7.3.4 闪回（Flashback）
7.3.5 数据卫士（Data Guard）
第8章 RMAN说,我能备份
8.1 进入RMAN
8.1.1 连接本地数据库
8.1.2 连接远程数据库
8.1.3 退出RMAN
8.2 熟悉RMAN操作
8.2.1 启动.关闭数据库
8.2.2 执行操作系统命令
8.2.3 执行SQL语句
8.2.4 RMAN备份类型
8.2.5 RMAN命令执行方式
8.3 RMAN备份初级演练
8.3.1 整库的备份
8.3.2 表空间的备份
8.3.3 数据文件的备份
8.3.4 控制文件的备份
8.3.5 归档文件的备份
8.3.6 初始化参数文件的备份
8.3.7 对备份集进行备份
8.3.8 综述
8.4 RMAN命令知多少
8.4.1 显示RMAN默认配置——SHOW命令
8.4.2 列出备份信息——LIST命令
8.4.3 删除备份——DELETE命令
8.4.4 报表显示——REPORT命令
8.4.5 执行检查——CROSSCHECK命令
8.4.6 修改状态——CHANGE命令
8.4.7 综述
8.5 RMAN备份演练进阶篇
8.5.1 是否选择增量备份
8.5.2 是否使用RMAN备份集的保留策略
8.5.3 是否使用多个通道
8.5.4 是否启用复合备份
8.5.5 是否设置备份集属性
8.5.6 是否使用RMAN恢复目录（Recovery Catalog）
8.5.7 是否启用备份优化
8.5.8 是否对备份集进行压缩
8.5.9 是否启用加密备份
8.6 实战RMAN备份
8.6.1 编写RMAN批处理文件
8.6.2 编写命令执行批处理
8.6.3 设定执行计划
8.7 RMAN基础知识补充
8.7.1 FORMAT字符串格式化
8.7.2 通过CONFIGURE命令创建预定义配置
8.7.3 通过SET命令进行会话级配置
8.7.4 增量备份的工作机制
8.7.5 备份加密模式
8.7.6 恢复目录数据库（Recovery Catalog）
8.7.7 RMAN备份相关的动态性能视图
8.8 制订备份策略
第9章 RMAN说,我能恢复
9.1 RMAN恢复操作扫盲
9.2 RMAN基础恢复操作
9.2.1 对数据库进行完全介质恢复
9.2.2 恢复表空间和数据文件
9.2.3 恢复归档日志文件
9.2.4 恢复控制文件和SPFILE初始化参数文件
9.3 RMAN恢复示例
9.3.1 归档模式有备份,丢失数据文件的恢复
9.3.2 归档模式无备份,丢失数据文件的恢复
9.3.3 丢失控制文件的恢复
9.3.4 丢失联机重做日志文件的恢复
9.3.5 不同故障下的恢复总结
9.4 通过RMAN备份恢复数据库到其他服务器
第10章 Data Guard说,我就是备份
10.1 Data Guard名词和术语
10.1.1 名词先混个脸熟
10.1.2 术语再了解大概
10.2 物理Standby说,我跟Primary一模一样
10.2.1 物理Standby创建前的准备工作
10.2.2 物理Standby创建时的操作步骤
10.2.3 物理Standby实际创建过程演示
10.2.4 玩转物理Standby的角色转换
10.2.5 用READONLY模式打开物理Standby
10.2.6 管理影响物理Standby的Primary数据库事件
10.2.7 监控Primary和物理Standby数据库
10.2.8 调整物理Standby端REDO数据应用频率
10.3 逻辑Standby说,我跟Primary看起来一样
10.3.1 逻辑Standby创建前的准备工作
10.3.2 逻辑Standby创建时的操作步骤
10.3.3 逻辑Standby实际创建过程演示
10.3.4 玩转逻辑Standby的角色转换
10.3.5 管理逻辑Standby的相关视图
10.3.6 逻辑Standby数据库的自定义配置
10.3.7 修改逻辑Standby端数据
10.3.8 优化逻辑Standby数据同步性能
10.4 Data Guard服务
10.4.1 REDO传输服务（Redo Transport Services）
10.4.2 Log应用服务（LogApply Services）
10.4.3 选择数据保护模式（Data Protection Mode）
第11章 Flashback说,恢复我最行
11.1 Flashback Query闪回查询
11.1.1 应用Flashback Query查询过去的数据
11.1.2 应用Flashback Query查询操作的事务
11.1.3 应用Flashback Query的注意事项
11.2 FlashbackTable闪回表
11.2.1 从Recycle Bin中恢复
11.2.2 从UNDO表空间中恢复
11.2.3 应用Flashback Table的注意事项
11.2.4 认识和管理RecycleBin（回收站）
11.3 Flashback Database闪回数据库
11.3.1 认识Flashback Database
11.3.2 Flashback Database操作示例
第四部分 迁移数据
第12章 Import/Export导入和导出数据
12.1 认识Import和Export
12.1.1 传说中的“备份”工具
12.1.2 初次调用示例
12.2 调用IMP和EXP
12.2.1 创建相关视图和角色
12.2.2 授予权限
12.2.3 调用方式
12.3 EXP说,我导出
12.3.1 我想导出表中的某些记录
12.3.2 我想导出某个SCHEMA下的某些表
12.3.3 我想导出某几个SCHEMA中的对象
12.3.4 整个痛快的,全库导出
12.3.5 我想（不想）要索引.约束.授权等
12.3.6 导出文件太大了,超出了操作系统限制怎么办
12.3.7 试试能否更快导出数据
12.3.8 EXP导出常见问题
12.4 IMP说,我导入
12.4.1 执行导入前务必搞清楚的几个问题
12.4.2 导入指定表到相同用户
12.4.3 导入指定表到其他用户
12.4.4 导入含LOB类型的表,且表空间与当前用户默认表空间不同
12.4.5 导入表结构到指定用户
12.4.6 IMP导入常见问题
12.4.7 试试能否更快导入数据
第13章 Data Pump导入和导出数据
13.1 认识Data Pump
13.1.1 Data Pump方式的导入和导出特性
13.1.2 Data Pump如何处理数据
13.2 调用IMPDP/EXPDP
13.2.1 调用方式
13.2.2 操作模式
13.3 过滤对象或数据
13.3.1 过滤数据
13.3.2 过滤对象
13.4 Data Pump执行导出
13.4.1 导出对象时指定过滤条件
13.4.2 跨数据库链方式导出数据
13.4.3 并行方式导出提高效率
13.5 Data Pump执行导入
13.5.1 导入对象到目标SCHEMA
13.5.2 重定义对象所属SCHEMA和表空间
13.5.3 通过NETWORK_LINK导出远端数据到本地数据库
13.5.4 优化导入效率
13.6 命令行交互方式管理和监控导入/导出任务
13.6.1 进入命令行交互模式的管理界面
13.6.2 执行管理操作
13.7 Data Pump API
13.7.1 使用DBMS_DATAPUMP导出指定SCHEMA
13.7.2 使用DBMS_DATAPUMP导出指定对象
第14章 使用传输表空间迁移数据
14.1 认识传输表空间
14.1.1 关于传输表空间特性
14.1.2 关于跨平台传输表空间
14.1.3 制约因素
14.2 实战传输表空间
14.2.1 操作步骤
14.2.2 传输实战
14.3 使用RMAN传输表空间
14.3.1 RMAN创建传输集概述
14.3.2 实战RMAN创建传输集
14.4 使用RMAN跨平台传输
14.4.1 跨平台传输的实现基础
14.4.2 实战跨平台传输
第15章 DUPLICATE复制数据库
15.1 DUPLICATE复制概述
15.1.1 认识DUPLICATE命令
15.1.2 创建Duplicate数据库过程
15.2 创建流程
15.2.1 相同路径结构的复制
15.2.2 异机不同路径结构的复制
15.2.3 本地创建Duplicate数据库
15.3 实战操作
15.3.1 准备工作
15.3.2 执行复制
15.3.3 验证结果
15.4 复制过程中的高级选项
15.4.1 跳过表空间
15.4.2 重命名Duplicate数据库中文件
15.4.3 同步副本数据库
15.5 创建物理Standby数据库
15.5.1 创建过程概述
15.5.2 实战DUPLICATE命令创建物理Standby
第五部分 基础部分
第16章 体系结构之数据库结构
16.1 数据库物理存储结构
16.1.1 控制文件（Control Files）
16.1.2 数据文件（Datafiles）
16.1.3 临时文件（Tempfiles）
16.1.4 日志文件（RedologFiles）
16.2 数据库逻辑存储结构
16.2.1 逻辑存储结构概述
16.2.2 块（Block）
16.2.3 区（Extent）
16.2.4 段（Segment）
16.2.5 表空间（Tablespace）
第17章 体系结构之实例结构
17.1 内存结构
17.1.1 SGA组成结构
17.1.2 自动SGA内存管理
17.1.3 数据缓冲区管理
17.1.4 共享池管理
17.1.5 其他缓冲区管理
17.1.6 SGA共享池和数据缓存池的分配
17.1.7 PGA组成结构
17.1.8 PGA内存管理
17.2 进程结构
17.2.1 Oracle进程
17.2.2 DBWn（数据库写进程）
17.2.3 LGWR(日志写进程)
17.2.4 CKPT（检查点进程）
17.2.5 SMON（系统监控进程）
17.2.6 PMON（进程监控进程）
17.2.7 ARCn（归档进程）
17.2.8 Jnnn（任务队列进程）
17.3 实例相关的文件
17.3.1 参数文件（Parameter Files）
17.3.2 警告文件（Alert File）
17.3.3 跟踪文件（Trace Files）
附录A SQLLDR命令的诸多参数
附录B IMP和EXP命令的诸多参数
附录C IMPDP和EXPDP命令的诸多参数
附录D DataGuard环境归档中断（GAP）或丢失的处理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>涂抹Oracle
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>西藏的神灵和鬼怪
再版导言 克瓦尔内
中译本序言 厄恩斯特・斯坦凯勒
中译本序言（二） 王尧
作者序
第一卷 保护神（护法神）的形貌
第一章 护法神的分类、形貌和标志
出世间护法神
第二章 班丹拉姆女神
第三章 大黑护法
第四章 多闻子、丑身、宝藏神
第五章 阎王及其相关的神灵
第六章 姊妹护法神
世间护法神
第七章 白哈尔及其伴神
第八章 金刚具力神
第九章 大梵天神
第十章 善金刚
第十一章 居士白毡神
第十二章 载乌玛保与“赞”系神魔
第十三章 长寿五姊妹及其相关的女神
第十四章 山神
第十五章 地方保护神
第十六章 厉神
第十七章 战神
第二卷 保护神的崇拜
第十八章 供品与圣器
第十九章 “垛”及其施“垛”仪式
第二十章 护法神崇拜
第二十一章 代言神巫（宣谕神）及其地位、装束、供养与预言幻迷
第二十二章 噶厦代言神巫
第二十三章 占卜术
第二十四章 天气咒师及其仪式
第二十五章 毁敌巫术（魔胜术）
第二十六章 御邪术
第二十七章 西藏萨满教的几点注释
藏文参考书目
译后记



>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>西藏的神灵和鬼怪
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>DBA的思想天空
目　　录
第一部分　 基础原理篇
第1章　 理解Oracle数据库和实例　　3
1.1　 什么是Oracle数据库　　3
1.2　 Oracle数据库的物理结构　　6
1.2.1　 Inventory　　6
1.2.2　 口令文件　　9
1.2.3　 参数文件　　10
1.2.4　 控制文件　　11
1.2.5　 在线日志文件　　12
1.2.6　 数据文件　　12
1.2.7　 归档日志文件　　12
1.3　 实例和多实例数据库　　13
1.3.1　 什么是数据库实例　　13
1.3.2　 多实例数据库　　16
1.4　 数据库后台进程　　18
1.4.1　 进程结构　　19
1.4.2　 后台进程的功能作介绍　　20
1.4.3　 哪些后台进程可以杀　　22
1.4.4　 是谁在执行SQL　　27
第2章　 理解DB Cache　　31
2.1　 什么是DB Cache　　33
2.2　 DB Cache的分配和DBWR的相关算法　　40
2.2.1　 DB_WRITER_PROCESSES参数　　41
2.2.2　 DB Cache的几个主要的链和CKPT算法　　43
2.2.3　 检索某个DB BLOCK的模拟算法　　45
2.3　 DB Cache相关的参数闩锁和等待事件　　48
2.4　 DB Cache优化的一些探讨　　51
2.4.1　 DB Cache和热块冲突　　51
2.4.2　 使用KEEP POOL能改善CBC争用吗　　54
2.4.3　 如何判断DB Cache是否足够　　55
2.4.4　 DB Cache优化要点　　59
第3章　 理解共享池　　62
3.1　 共享池堆的内部结构　　64
3.1.1　 进一步了解共享池　　68
3.1.2　 共享池的子池技术　　75
3.1.3　 字典缓存　　78
3.1.4　 库缓存和游标　　80
3.2　 共享池和游标　　85
3.2.1　 游标与游标共享　　86
3.2.2　 游标与SQL的执行　　90
3.2.3　 游标共享和绑定变量　　96
3.2.4　 OPEN CURSOR和OPEN_CURSORS参数　　101
3.2.5　 CURSOR_SPACE_FOR_TIME参数　　102
3.2.6　 SESSION_CACHED_CURSORS参数和OPEN_CURSORS　　103
3.2.7　 CURSOR_SHARING和游标共享　　109
3.2.8　 游标的关闭　　111
3.2.9　 互斥锁和游标　　112
3.3　 共享池的相关参数　　114
3.4　 共享池故障处理　　115
3.4.1　 著名的ORA-4031　　116
3.4.2　 其他共享池常见故障　　125
3.5　 共享池优化的主要思路　　128
第4章　 理解控制文件　　130
4.1　 控制文件的内部结构　　130
4.1.1　 控制文件和控制文件事务　　130
4.1.2　 控制文件自动扩展　　132
4.1.3　 如何转储和分析控制文件　　133
4.1.4　 文件头和控制文件信息　　135
4.2　 故障处理和优化　　136
4.2.1　 丢失或者损坏控制文件的处理方法　　136
4.2.2　 控制文件的优化　　138
第5章　 理解REDO日志　　140
5.1　 什么是REDO日志　　140
5.2　 REDO的基本原理　　141
5.2.1　 介质恢复和实例恢复的基本概念　　141
5.2.2　 变化矢量和REDO记录　　143
5.2.3　 日志缓冲和LGWR　　149
5.2.4　 日志切换和REDO日志文件　　152
5.2.5　 事务提交和回滚的过程　　156
5.3　 REDO优化　　157
5.3.1　 BULK操作能减少REDO吗　　157
5.3.2　 如何优化LOG FILE SYNC等待事件　　166
5.3.3　 SHUTDOWN ABORT无害吗　　168
5.3.4　 关于REDO日志优化的建议　　169
第6章　 理解UNDO　　172
6.1　 UNDO的基本原理　　172
6.1.1　 UNDO表空间和回滚段　　173
6.1.2　 ITL和UNDO　　175
6.1.3　 如何转储UNDO　　176
6.1.4　 UNDO自动管理是如何工作的　　177
6.1.5　 系统回滚段的作用　　178
6.1.6　 著名的ORA-1555　　179
6.1.7　 回滚段手工管理　　180
6.2　 如何分析和优化UNDO　　181
第7章　 理解PGA、临时表空间和排序　　183
7.1　 基本概念　　184
7.1.1　 临时表空间和临时段　　184
7.1.2　 PGA和排序　　185
7.1.3　 PGA和PGA_AGGREGATE_ TARGET　　187
7.1.4　 你应该知道的PGA自动管理内幕　　191
7.2　 PGA优化的要点　　193
第8章　 理解ASM的结构　　197
8.1　 什么是ASM　　197
8.2　 ASM的结构　　201
8.2.1　 ASM DISKHEADER的结构　　201
8.2.2　 ASM FILE DIRECTORY文件结构　　203
8.2.3　 ASM ALIAS DIRECTORY文件结构　　207
8.2.4　 ASM DISK DIRECTORY文件结构　　209
8.2.5　 从ASM存储结构谈ASM日常维护的要点　　210
8.3　 如何使用KFED分析和修改ASM数据　　211
8.4　 如何使用AMDU导出ASM文件　　216
第9章　 理解数据块结构　　224
9.1　 理解数据块头结构　　224
9.2　 理解ITL　　227
9.3　 理解记录结构　　231
9.4　 解析Oracle字段的内部数据存储格式　　234
9.5　 理解LOB的存储结构　　241
第10章　 理解表的结构　　246
10.1　 到底什么是“表”　　246
10.1.1　 PCTFREE和行链　　249
10.1.2　 那些逝去的老参数　　254
10.1.3　 减少热块冲突的方法　　257
10.2　 从数据块结构看目前主流容灾技术　　260
10.3　 案例——简单任务　　265
第11章　 理解索引　　278
11.1　 反转键索引的误区　　280
11.2　 索引访问的方式　　284
11.2.1　 小表用索引有意义吗　　286
11.2.2　 位图索引为什么不适合大并发量环境　　287
11.3　 重建索引的作用　　291
11.4　 索引使用的“三大纪律八项注意”　　294
11.5　 案例——索引危机　　296
第12章　 理解分区表　　305
12.1　 什么是分区表　　305
12.2　 分区表对海量数据的意义　　310
12.2.1　 分区表和历史数据归档　　311
12.2.2　 分区表和高水位推进　　315
12.2.3　 分区表和RAC环境　　316
12.2.4　 分区主键和分区粒度的选择　　317
第13章　 理解序列　　319
13.1　 什么是序列　　319
13.2　 序列的使用和优化　　320
第二部分　 分析思路篇
第14章　 问题分析综述　　324
14.1　 如何抓住蝴蝶效应中的那只蝴蝶　　325
14.2　 为什么要强调基础概念　　328
14.3　 工作中的好习惯带来的福利　　330
第15章　 DBA分析思路的探讨　　332
15.1　 问题分析总路线图　　332
15.2　 普通故障的分析路线　　335
15.3　 性能问题的分析路线　　340
15.4　 SQL语句的分析路线　　347
15.5　 利用你知道的原理缩小问题的范围　　351
15.6　 关闭问题的条件　　353
15.7　 灵活运用你的知识　　354
15.8　 DBA需要与时俱进　　356
15.9　 多表连接的优化技巧　　359
15.10　 理论如何联系实践　　364
第三部分　 典型案例篇
第16章　 RAC故障分析　　370
16.1　 LOG_ARCHIVE_MAX_PROCESS导致的RAC脑裂　　370
16.2　 RAC系统故障的处理过程　　377
16.3　 三天两次严重故障　　381
第17章　 ORA-600故障　　388
17.1　 ORA-600 [12700]错误的分析过程　　388
17.2　 ORA-600 [kdsgrp1]的处理案例　　401
第18章　 性能问题分析　　407
18.1　 压力测试遇到的问题　　407
18.2　 IMP导入性能问题的分析　　411
18.3　 并行操作为什么无法执行　　413
第19章　 SQL优化　　421
19.1　 一个常用的SQL优化方法　　421
19.2　 一个查找IP所属区域的SQL优化思路　　428
结束语　　433

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>DBA的思想天空
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 9i/10g/11g编程艺术
第1章 开发成功的Oracle应用	1
1.1 我的方法	2
1.2 黑盒方法	3
1.3 开发数据库应用的正确（和不正确）方法	10
1.3.1 了解Oracle体系结构	11
1.3.2 理解并发控制	19
1.3.3 多版本控制	22
1.3.4 数据库独立性	28
1.3.5 怎么能让应用运行得更快	42
1.3.6 DBA与开发人员的关系	44
1.4 小结	45
第2章 体系结构概述	46
2.1 定义数据库和实例	47
2.2 SGA和后台进程	52
2.3 连接Oracle	54
2.3.1 专用服务器	54
2.3.2 共享服务器	56
2.3.3 TCP/IP连接的基本原理	57
2.4 小结	59
第3章 文件	60
3.1 参数文件	61
3.1.1 什么是参数	62
3.1.2 遗留的init.ora参数文件	65
3.1.3 服务器参数文件	67
3.1.4 参数文件小结	72
3.2 跟踪文件	73
3.2.1 请求的跟踪文件	74
3.2.2 针对内部错误生成的跟踪文件	78
3.2.3 跟踪文件小结	82
3.3 警告文件	83
3.4 数据文件	85
3.4.1 简要回顾文件系统机制	86
3.4.2 Oracle数据库中的存储层次体系	87
3.4.3 字典管理和本地管理的表空间	90
3.5 临时文件	92
3.6 控制文件	94
3.7 重做日志文件	94
3.7.1 在线重做日志	95
3.7.2 归档重做日志	97
3.8 密码文件	99
3.9 修改跟踪文件	102
3.10 闪回日志	103
3.10.1 闪回数据库	103
3.10.2 闪回恢复区	104
3.11 DMP文件（EXP/IMP文件）	104
3.12 数据泵文件	105
3.13 平面文件	108
3.14 小结	109
第4章 内存结构	110
4.1 进程全局区和用户全局区	110
4.1.1 手动PGA内存管理	111
4.1.2 自动PGA内存管理	117
4.1.3 手动和自动内存管理的选择	127
4.1.4 PGA和UGA小结	129
4.2 系统全局区	129
4.2.1 固定SGA	133
4.2.2 重做缓冲区	134
4.2.3 块缓冲区缓存	135
4.2.4 共享池	141
4.2.5 大池	143
4.2.6 Java池	144
4.2.7 流池	145
4.2.8 自动SGA内存管理	145
4.2.9 自动内存管理	147
4.3 小结	148
第5章 Oracle进程	149
5.1 服务器进程	149
5.1.1 专用服务器连接	150
5.1.2 共享服务器连接	152
5.1.3 数据库常驻连接池	152
5.1.4 连接与会话	153
5.1.5 专用服务器与共享服务器	158
5.1.6 专用/共享服务器小结	161
5.2 后台进程	162
5.2.1 中心后台进程	163
5.2.2 工具后台进程	171
5.3 从属进程	173
5.3.1 I/O从属进程	173
5.3.2 Pnnn：并行查询执行服务器	174
5.4 小结	175
第6章 锁和闩	176
6.1 什么是锁	176
6.2 锁定问题	179
6.2.1 丢失更新	179
6.2.2 悲观锁定	180
6.2.3 乐观锁定	182
6.2.4 乐观锁定还是悲观锁定	188
6.2.5 阻塞	188
6.2.6 死锁	191
6.2.7 锁升级	195
6.3 锁类型	195
6.3.1 DML锁	196
6.3.2 DDL锁	204
6.3.3 闩	209
6.3.4 手动锁定和用户定义锁	217
6.4 小结	218
第7章 并发与多版本控制	219
7.1 什么是并发控制	219
7.2 事务隔离级别	220
7.2.1 READ UNCOMMITTED	221
7.2.2 READ COMMITTED	223
7.2.3 REPEATABLE READ	224
7.2.4 SERIALIZABLE	226
7.2.5 READ ONLY	228
7.3 多版本控制读一致性的含义	229
7.3.1 一种会失败的常用数据仓库技术	229
7.3.2 解释热表上超出期望的I/O	230
7.4 写一致性	233
7.4.1 一致读和当前读	233
7.4.2 查看重启动	235
7.4.3 为什么重启动对我们很重要	238
7.5 小结	239
第8章 事务	240
8.1 事务控制语句	240
8.2 原子性	242
8.2.1 语句级原子性	242
8.2.2 过程级原子性	244
8.2.3 事务级原子性	247
8.2.4 DDL与原子性	247
8.3 持久性	247
8.3.1 COMMIT的WRITE扩展	248
8.3.2 非分布式PL/SQL代码块中的COMMIT	249
8.4 完整性约束和事务	250
8.4.1 IMMEDIATE约束	251
8.4.2 DEFERRABLE约束和级联更新	251
8.5 不好的事务习惯	255
8.5.1 在循环中提交	255
8.5.2 使用自动提交	261
8.6 分布式事务	261
8.7 自治事务	263
8.7.1 自治事务如何工作	264
8.7.2 何时使用自治事务	265
8.8 小结	268
第9章 redo与undo	269
9.1 什么是redo	269
9.2 什么是undo	270
9.3 redo和undo如何协作	273
9.4 提交和回滚处理	277
9.4.1 COMMIT做什么	277
9.4.2 ROLLBACK做什么	283
9.5 分析redo	284
9.5.1 测量redo	284
9.5.2 能关掉重做日志生成程序吗	286
9.5.3 为什么不能分配一个新日志	289
9.5.4 块清除	291
9.5.5 日志竞争	294
9.5.6 临时表和redo/undo	296
9.6 分析undo	299
9.6.1 什么操作会生成最多和最少的undo	299
9.6.2 ORA-01555: snapshot too old 错误	301
9.7 小结	310
第10章 数据库表	311
10.1 表类型	311
10.2 术语	313
10.2.1 段	313
10.2.2 段空间管理	315
10.2.3 高水位线	316
10.2.4 FREELIST	317
10.2.5 PCTFREE和PCTUSED	320
10.2.6 LOGGING和NOLOGGING	323
10.2.7 INITRANS和MAXTRANS	324
10.3 堆组织表	324
10.4 索引组织表	327
10.5 索引聚簇表	340
10.6 散列聚簇表	347
10.7 有序散列聚簇表	355
10.8 嵌套表	357
10.8.1 嵌套表语法	358
10.8.2 嵌套表存储	364
10.8.3 嵌套表小结	367
10.9 临时表	368
10.10 对象表	374
10.11 小结	380
第11章 索引	382
11.1 Oracle索引概述	382
11.2 B*树索引	384
11.2.1 索引键压缩	386
11.2.2 反向键索引	389
11.2.3 降序索引	394
11.2.4 什么情况下应该使用B*树索引	396
11.2.5  B*树小结	405
11.3 位图索引	406
11.3.1 什么情况下应该使用位图索引	407
11.3.2 位图联结索引	410
11.3.3 位图索引小结	413
11.4 基于函数的索引	413
11.4.1 重要的实现细节	413
11.4.2 一个简单的基于函数的索引例子	414
11.4.3 只对部分行建立索引	422
11.4.4 实现有选择的唯一性	424
11.4.5 关于ORA-01743的警告	424
11.4.6 基于函数的索引小结	425
11.5 应用域索引	425
11.6 关于索引的常见问题和神话	426
11.6.1 视图能使用索引吗	427
11.6.2 Null和索引能协作吗	427
11.6.3 外键是否应该加索引	429
11.6.4 为什么没有使用我的索引	430
11.6.5 神话：索引中从不重用空间	435
11.6.6 神话：最有差别的元素应该在最前面	438
11.7 小结	441
第12章 数据类型	442
12.1 Oracle数据类型概述	442
12.2 字符和二进制串类型	444
12.2.1 NLS概述	445
12.2.2 字符串	448
12.3 二进制串：RAW类型	453
12.4 数值类型	455
12.4.1 NUMBER类型的语法和用法	457
12.4.2 BINARY_FLOAT/BINARY_DOUBLE类型的语法和用法	460
12.4.3 非固有数值类型	461
12.4.4 性能考虑	461
12.5 LONG类型	463
12.5.1 LONG和LONG RAW类型的限制	463
12.5.2 处理遗留的LONG类型	464
12.6 DATE、TIMESTAMP和INTERVAL类型	469
12.6.1 格式	469
12.6.2 DATE类型	470
12.6.3 TIMESTAMP类型	475
12.6.4 INTERVAL类型	482
12.7 LOB 类型	484
12.7.1 内部LOB	485
12.7.2 BFILE	495
12.8 ROWID/UROWID类型	497
12.9 小结	497
第13章 分区	499
13.1 分区概述	499
13.1.1 提高可用性	500
13.1.2 减少管理负担	502
13.1.3 改善语句性能	505
13.2 表分区机制	507
13.2.1 区间分区	508
13.2.2 散列分区	510
13.2.3 列表分区	513
13.2.4 间隔分区	515
13.2.5 引用分区	520
13.2.6 组合分区	524
13.2.7 行移动	526
13.2.8 表分区机制小结	528
13.3 索引分区	529
13.3.1 局部索引与全局索引	530
13.3.2 局部索引	530
13.3.3 全局索引	535
13.4 再论分区和性能	547
13.5 审计和段空间压缩	552
13.6 小结	553
第14章 并行执行	555
14.1 何时使用并行执行	556
14.2 Oracle Exadata	558
14.3 并行查询	558
14.4 并行DML	564
14.5 并行DDL	566
14.5.1 并行DDL和使用外部表的数据加载	567
14.5.2 并行DDL和区段截断	568
14.6 并行恢复	576
14.7 过程并行化	577
14.7.1 并行管道函数	578
14.7.2 DIY并行化	580
14.7.3 老式DIY并行化	583
14.8 小结	587
第15章 数据加载和卸载	588
15.1 SQLLDR	588
15.1.1 用SQLLDR加载数据的常见问题	592
15.1.2 SQLLDR警告	613
15.1.3 SQLLDR小结	614
15.2 外部表	614
15.2.1 建立外部表	615
15.2.2 处理错误	619
15.2.3 使用外部表加载不同的文件	622
15.2.4 多用户问题	623
15.2.5 外部表小结	624
15.3 平面文件卸载	624
15.4 数据泵卸载	631
15.5 小结	633
第16章 数据加密	634
16.1 加密类型	634
16.1.1 动态数据	634
16.1.2 静态数据	635
16.1.3 手动应用加密	638
16.1.4 Oracle钱夹	639
16.1.5 透明列级加密	641
16.1.6 透明表空间加密	644
16.2 加密不是访问控制	646
16.3 实现手动应用加密	647
16.3.1 避免使用手动方法的原因	648
16.3.2 手动方法的性能影响	648
16.3.3 何时使用手动方法	652
16.4 实现列级加密	652
16.4.1 如何使用列级加密	653
16.4.2 列级加密的数据存储	653
16.4.3 测量列级加密的性能影响	657
16.4.4 影响大小	657
16.4.5 列级加密的限制	662
16.5 实现表空间加密	663
16.5.1 如何使用表空间加密	663
16.5.2 表空间加密的数据存储	664
16.5.3 测量表空间加密的性能影响	665
16.6 决定采用哪种加密技术	670
16.7 小结	671
索引	672

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 9i/10g/11g编程艺术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 9i & 10g编程艺术
第1章　开发成功的Oracle应用
第2章　体系结构概述
第3章　文件
第4章　内存结构
第5章　Oracle进程
第6章　锁
第7章　并发与多版本
第8章　事务
第9章　redo与undo
第10章　数据库表
第11章　索引
第12章　数据类型
第13章　分区
第14章　并行执行
第15章　数据加载和卸载
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 9i & 10g编程艺术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>剑破冰山
第1章 大话数据库编程规范 1
1.1 编程规范概述 1
1.2 书写规范 2
1.2.1 大小写风格 2
1.2.2 缩进风格 2
1.2.3 空格及换行 3
1.2.4 其他 4
1.3 命名规范 4
1.3.1 表和字段命名规范 4
1.3.2 其他对象命名 5
1.4 变量命名 7
1.5 注释规范 8
1.6 语法规范 9
1.7 脚本规范 12
规则1.7.1 13
规则1.7.2 13
规则1.7.3 13
第2章 oracle开发常用工具及使用 14
2.1 awr工具与性能优化 14
2.1.1 awr介绍 14
.2.1.2 awr的安装与配置 15
2.1.3 awr报表使用 15
2.1.4 分析awr报表基本思路 17
2.1.5 案例 17
2.2 sql_trace/10046事件 24
2.2.1 sql_trace/10046事件是什么 24
2.2.2 总体流程介绍 24
2.2.3 sql_trace/10046事件具体使用方法 24
2.2.4 案例分析 28
2.2.5 小结 32
2.3 计时和剖析工具 32
2.3.1 plsql_profiler概述 34
2.3.2 剖析举例 37
2.3.3 安全性 45
第3章 探索merge方法 46
3.1 merge是什么 46
3.2 oracle 10g中merge的完善 48
3.2.1 update和insert动作可只出现其一 48
3.2.2 可对merge语句加条件 48
3.2.3 可用delete子句清除行 49
3.2.4 可采用无条件方式insert 49
3.3 merge误区探索 49
3.3.1 无法在源表中获得一组稳定的行 49
3.3.2 delete子句的where顺序必须在最后 51
3.3.3 delete 子句只可以删除目标表，而无法删除源表 52
3.3.4 更新同一张表的数据，需担心using的空值 53
3.4 merge的巧妙运用 54
第4章 神秘的null和令人讨厌的char 58
4.1 神秘的null 59
4.1.1 null概述 59
4.1.2 null与函数 64
4.1.3 null与索引 79
4.1.4 null与sql 87
4.1.5 null与pl/sql 97
4.1.6 再谈null和空字符串区别 101
4.1.7 null总结 101
4.2 令人讨厌的char 102
4.2.1 char与varchar2基础 102
4.2.2 char与sql 105
4.2.3 char与绑定变量 109
4.2.4 char与pl/sql 111
4.2.5 char总结 112
第5章 报表开发之扩展group by 113
5.1 扩展group by概述 113
5.2 rollup 114
5.2.1 union all实现rollup功能 114
5.2.2 rollup分组 116
5.2.3 部分rollup分组 120
5.2.4 rollup总结 121
5.3 cube 121
5.3.1 cube分组 121
5.3.2 部分cube分组 123
5.3.3 cube总结 124
5.4 grouping sets实现小计 124
5.4.1 grouping sets分组 124
5.4.2 部分grouping sets分组 126
5.4.3 cube、rollup作为grouping sets的参数 126
5.4.4 grouping sets总结 128
5.5 组合列分组、连接分组、重复列分组 128
5.5.1 组合列分组 130
5.5.2 连接分组 132
5.5.3 重复列分组 134
5.5.4 组合列分组、连接分组、重复列分组总结 134
5.6 3个扩展分组函数：grouping、grouping_id、group_id 135
5.6.1 grouping函数 135
5.6.2 grouping_id函数 138
5.6.3 group_id函数 142
5.6.4 扩展group by函数总结 144
5.7 扩展分组综合实例 144
第6章 探索oracle自动类型转换 149
6.1 为什么不建议使用自动类型转换 150
6.2 自动类型转换规则 156
6.3 自动类型转换常见错误 166
第7章 where in list问题解析 169
7.1 问题引入：动态sql构造 170
7.2 使用正则表达式解决 172
7.3 使用常规字符串函数及动态视图 173
7.4 使用集合构造伪表 176
7.5 where in list性能问题 178
7.6 where in list问题总结 188
第8章 例说数据库表设计和大量数据处理方法 189
8.1 根据业务需求规划表结构 189
8.2 主键的确定 195
8.3 表的拆分、合并及数据的规范和反规范化 199
8.4 数据类型的选择 199
8.5 表的分区 203
8.6 表的压缩 203
8.7 抽取数据 205
8.7.1 利用sql*plus的spool功能 205
8.7.2 利用utl_file 207
8.7.3 利用第三方工具 207
8.8 转换数据 207
8.8.1 数据的增删改 208
8.8.2 数据汇总 211
8.9 加载数据 227
8.9.1 利用sqlldr加载 227
8.9.2 利用外部表加载 229
8.9.3 利用数据库链接加载 233
8.9.4 利用分区交换技术加载 234
8.10 逻辑导入/导出数据 240
第9章 数据审核 242
9.1 审核的分类 242
9.2 列审核设计 243
9.2.1 直接使用sql语句 245
9.2.2 提高审核效率 248
9.2.3 管理审核关系 254
9.2.4 单个列的复杂审核 257
9.3 行审核设计 258
9.3.1 重码的审核 259
9.3.2 直接使用sql语句 260
9.3.3 管理审核关系 261
9.3.4 行间包含四则运算的审核思路 266
9.3.5 更复杂的行间审核思路 267
9.4 小结 267
第10章 趣谈oracle分析函数 269
10.1 概述 269
10.2 函数语法 270
10.3 函数列表 276
10.4 函数用法 277
10.4.1 最常见的分析函数应用场景 279
10.4.2 rows的具体用法 280
10.4.3 range的具体用法 281
10.4.4 keep的用法 283
10.5 函数功能详解 284
10.5.1 统计函数 284
10.5.2 排序函数 285
10.5.3 数据分布函数 287
10.5.4 统计分析函数 289
10.6 分析函数在bi及统计上的应用 290
10.6.1 现状分析 290
10.6.2 发展分析 297
10.7 自定义聚集函数 298
10.7.1 自定义聚集函数接口简介 298
10.7.2 应用场景一：字符串聚集 299
10.7.3 应用场景二：指数移动平均线 301
第11章 oracle层次查询 305
11.1 概述 305
11.2 样例数据 306
11.3 connect by和start with查询 306
11.3.1 概述 306
11.3.2 基本语法 306
11.3.3 样例 308
11.4 sys_connect_by_path函数 313
11.5 wmsys.wm_concat非公开函数 314
第12章 号段选取应用 316
12.1 问题的提出 316
12.2 相关基础知识 317
12.2.1 伪列rownum和level 317
12.2.2 利用层次查询构造连续的数 317
12.2.3 用lead和lag获得相邻行的字段值 318
12.3 解决问题 320
12.3.1 已知号码求号段 320
12.3.2 根据号段求出包含的数 324
12.3.3 求缺失的号 326
12.3.4 求尚未使用的号段 330
12.4 小结 334
第13章 分析sql执行计划的关注点 335
13.1 返回行与逻辑读的比率 335
13.2 聚合查询 338
13.3 返回行的数量 341
13.4 oracle预测行准确与否 342
13.5 predicate information 346
13.6 动态采样 348
13.7 谁是主要矛盾 349
第14章 oracle开发误区探索 352
14.1 避免对列运算 352
14.2 消除隐式转换 354
14.3 关注空格 354
14.4 存储过程与权限 355
14.5 提防ddl提交事务 357
14.6 insert into 错误 359
14.7 关于or 360
14.8 sequence中的cache 361
14.9 树形查询易错处 364
14.10 小心保留字 367
14.11 函数索引陷阱 371
14.12 外连接陷阱 374
14.13 标量子查询 375
第15章 提升pl/sql开发性能漫谈 378
15.1 重视解析 378
15.1.1 触发器尽量考虑内部代码过程封装 378
15.1.2 避免动态sql 380
15.1.3 oltp系统中尽量使用绑定变量 382
15.2 关注调用 384
15.2.1 减少对sysdate的调用 384
15.2.2 避免对mod函数的调用 385
15.2.3 设法减少表扫描次数 386
15.2.4 避免sql中的函数调用 391
15.3 简洁为王 395
15.3.1 尽量用简单sql替代pl/sql逻辑 395
15.3.2 避免不必要的排序 397
15.3.3 利用oracle现有功能 399
15.4 细致入微 400
15.4.1 使用pls_integer类型 400
15.4.2 避免数据类型转换 400
15.4.3 if的顺序有讲究 402
15.4.4 设计开发对列是否为空慎重决定 404
15.4.5 分布式应用开发不可不知的hint（driving_site） 407
第16章 管道函数的学习与实战应用 410
16.1 管道函数编写要点 410
16.2 功能描述及案例 411
16.2.1 可直接用table()操作符方式输出结果集 411
16.2.2 结果集可作为表来使用，直接和其他表相关联 411
16.2.3 实现实时跟踪 412
16.3 管道函数注意点 414
16.3.1 清楚管道函数只是表函数的一种 414
16.3.2 管道函数与dml 415
16.3.3 管道函数集合的限制 416
16.3.4 与管道函数相关的异常no_data_needed 417
第17章 巧用锁特性避免重复启动同一程序 420
17.1 基本技巧介绍 420
17.2 原理介绍 422
17.3 程序代码 423
17.4 测试 426
17.5 需要注意的点 427
第18章 11g r2 新特性之递归with编程精粹 428
18.1 上下级关系 429
18.2 构造数列 435
18.3 排列组合问题 441
18.4 沿路径计算 457
18.5 国际sql挑战赛 473
第19章 不可能的任务？超越oracle 479
19.1 为何选择cube 480
19.1.1 cube简介 480
19.1.2 cube优势 480
19.1.3 测试环境 481
19.2 newkid的设计思路和优化步骤 482
19.2.1 一次扫描求出16种分组 482
19.2.2 一次扫描求出1种分组，并基于此再一次扫描求出其余分组 484
19.2.3 一次扫描求出1种分组，并基于此再多次分层累计求出其余分组 485
19.2.4 变量长度和类型的优化 487
19.3 为何选择oci 488
19.3.1 汇总算法的翻译和改进 488
19.3.2 输入和输出的实现和改进 489
19.3.3 不要忽视物理存储对数据库操作的影响 490
19.3.4 不成功的优化教训 490
19.4 总结 493
第20章 动态sql扩展 494
20.1 动态sql用途和应用场景 494
20.2 execute immediate语法 495
20.2.1 执行ddl、dcl语句 495
20.2.2 构造通用sql处理 496
20.2.3 执行复杂业务逻辑查询 498
20.2.4 绑定变量 502
20.2.5 bulk collect动态sql 505
20.3 使用dbms_sql包 507
20.3.1 dbms_sql函数和过程说明 507
20.3.2 dbms_sql执行步骤 508
20.3.3 dbms_sql应用场景 509
20.3.4 dbms_sql与execute immediate比较 509
后记 511
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>剑破冰山
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle性能诊断艺术
第一部分 基础
第1章 性能问题
1.1 需要为性能做规划吗
1.1.1 需求分析
1.1.2 分析和设计
1.1.3 编码和单元测试
1.1.4 集成和验收测试
1.2 什么是性能问题
1.2.1 系统监控
1.2.2 响应时间监控
1.2.3 强迫调优失调症
1.3 如何解决性能问题
1.3.1 业务角度与系统角度
1.3.2 把问题分类
1.3.3 解决问题
1.4 小结
第2章 关键概念
2.1 选择性和基数
2.2 游标的生命周期
2.3 解析的过程
2.3.1 共享游标
2.3.2 绑定变量
2.4 读写数据块
2.5 小结
第二部分 找出问题
第3章 找出性能问题
3.1 分而治之
3.2 分析路线图
3.3 性能测量与剖析分析
3.4 性能测量
3.4.1 应用程序代码
3.4.2 数据库调用
3.5 剖析应用程序代码
3.5.1 简明的性能剖析
3.5.2 细节化性能剖析
3.6 跟踪数据库调用
3.6.1 SQL跟踪
3.6.2 跟踪文件的结构
3.6.3 使用TRCSESS
3.6.4 剖析工具
3.6.5 使用TKPROF
3.6.6 使用TVD$XTAT
3.7 剖析PL/SQL代码
3.7.1 安装剖析工具
3.7.2 安装输出表
3.7.3 收集剖析数据
3.7.4 报告剖析数据
3.7.5 GUI方式
3.8 小结
第三部分 查询优化器
第4章 系统和对象统计信息
4.1 工具包dbms_stats简介
4.2 系统统计
4.2.1 数据字典
4.2.2 非工作量统计信息
4.2.3 工作量统计信息
4.2.4 对查询优化器的影响
4.3 对象统计信息
4.3.1 有哪些对象统计信息可用
4.3.2 收集对象统计信息
4.3.3 锁定对象统计信息
4.3.4 比较对象统计信息
4.3.5 删除对象统计信息
4.3.6 保持统计信息时效性的策略
4.4 通用服务
4.4.1 统计信息历史
4.4.2 创建和删除备份表
4.4.3 导出、导入、获取和设置操作
4.4.4 日志
4.5 小结
第5章 配置查询优化器
5.1 配置还是不配置
5.2 配置路线图
5.3 设置正确的参数
5.3.1 查询优化器参数
5.3.2 PGA管理
5.4 小结
第6章 执行计划
6.1 获取执行计划
6.1.1 SQL语句EXPLAIN PLAN
6.1.2 动态性能视图
6.1.3 AWR和Statspack
6.1.4 跟踪功能
6.1.5 dbms_xplan包
6.2 解释执行计划
6.2.1 父子关系
6.2.2 操作类型
6.2.3 单独型操作
6.2.4 非相关联合型操作
6.2.5 相关联合型操作
6.2.6 分而治之
6.2.7 特殊的例子
6.3 识别低效的执行计划
6.3.1 错误的评估
6.3.2 未识别约束
6.4 小结
第7章 SQL优化技术
7.1 改变访问结构
7.1.1 运行机制
7.1.2 何时使用
7.1.3 缺陷和谬误
7.2 修改SQL语句
7.2.1 运行机制
7.2.2 何时使用
7.2.3 缺陷和谬误
7.3 提示
7.3.1 运行机制
7.3.2 何时使用
7.3.3 缺陷和谬误
7.4 改变执行环境
7.4.1 工作机制
7.4.2 何时使用
7.4.3 缺陷和谬误
7.5 SQL概要
7.5.1 工作机制
7.5.2 何时使用
7.5.3 缺陷和谬误
7.6 存储提纲
7.6.1 工作机制
7.6.2 何时使用
7.6.3 缺陷和谬误
7.7 SQL计划基线
7.7.1 工作机制
7.7.2 何时使用
7.7.3 缺陷和谬误
7.8 小结
第四部分 优化器
第8章 解析
8.1 识别解析问题
8.1.1 快速解析
8.1.2 长解析
8.2 解决解析问题
8.2.1 快速解析
8.2.2 长解析
8.3 应对解析问题
8.3.1 游标共享
8.3.2 服务器端语句缓存
8.4 使用应用编程接口
8.4.1 PL/SQL
8.4.2 OCI
8.4.3 JDBC
8.4.4 ODP.NET
8.5 小结
第9章 优化数据访问
9.1 找出不理想的访问路径
9.1.1 识别
9.1.2 陷阱
9.1.3 原因
9.1.4 解决办法
9.2 具有弱选择性的SQL语句
9.2.1 全表扫描
9.2.2 全分区扫描
9.2.3 范围分区
9.2.4 哈希与列表分区
9.2.5 组合分区
9.2.6 设计考虑
9.2.7 全索引扫描
9.3 具有强选择性的SQL语句
9.3.1 rowid访问
9.3.2 索引访问
9.3.3 单表哈希聚簇访问
9.4 小结
第10章 表连接优化
10.1 定义
10.1.1 连接树
10.1.2 连接的类型
10.1.3 限制条件与连接条件
10.2 嵌套循环连接
10.2.1 概念
10.2.2 两表连接
10.2.3 四表连接
10.2.4 块预取
10.2.5 其他可选的执行计划
10.3 合并连接
10.3.1 概念
10.3.2 两表连接
10.3.3 四表连接
10.3.4 工作区
10.4 哈希连接
10.4.1 概念
10.4.2 两表连接
10.4.3 四表连接
10.4.4 工作区
10.4.5 索引连接
10.5 外连接
10.6 选择连接方法
10.6.1 FIRST_ROWS优化目标
10.6.2 ALL_ROWS优化目标
10.6.3 支持的连接方法
10.6.4 并行连接
10.7 分区智能连接
10.7.1 完全分区智能连接
10.7.2 部分智能分区连接
10.8 转换
10.8.1 连接去除
10.8.2 外连接转换为内连接
10.8.3 子查询非嵌套化
10.8.4 星形转换
10.9 小结
第11章 高级优化技术
11.1 物化视图
11.1.1 运行机制
11.1.2 何时使用
11.1.3 缺陷与谬误
11.2 结果缓存
11.2.1 运行机制
11.2.2 何时使用
11.2.3 缺陷与谬误
11.3 并行处理
11.3.1 运行机制
11.3.2 何时使用
11.3.3 缺陷与谬误
11.4 直接路径插入
11.4.1 运行机制
11.4.2 何时使用
11.4.3 缺陷与谬误
11.5 行预取
11.5.1 运行机制
11.5.2 何时使用
11.5.3 缺陷与谬误
11.6 数组接口
11.6.1 运行机制
11.6.2 何时使用
11.6.3 缺陷与谬误
11.7 小结
第12章 优化物理设计
12.1 最佳字段顺序
12.2 最优数据类型
12.2.1 数据类型选择方面的陷阱
12.2.2 选择数据类型的最佳实践
12.3 行迁移与行链接
12.3.1 迁移与链接
12.3.2 问题描述
12.3.3 找出问题
12.3.4 解决方案
12.4 数据块争用
12.4.1 问题描述
12.4.2 找出问题
12.4.3 解决方案
12.5 数据压缩
第五部分 附录
附录A 可下载文件
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle性能诊断艺术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle DBA手记
第1篇 DBA工作手记	1
Eygle的DBA工作手记（作者：盖国强） 3
DBA 2.0的时代	4
DBA日常工作职责——我对DBA的7点建议	10
DBA最重要的素质有哪些	11
DBA职业生涯之误删除篇	12
DBA警世录——有些习惯DBA需要养成	13
RAC环境下故障处理一则	14
SQL_TRACE跟踪与诊断	16
临时表空间组导致递归SQL高度解析案例	19
使用闪回查询恢复误删除的数据	21
使用ErrorStack进行错误跟踪及诊断	24
断电故障导致ASM DiskGroup故障及恢复案例	26
共享池的改进与ORA-04031的变化	27
共享内存无法正常释放的处理	34
LOG_BUFFER设置与变迁	35
LOGMNR简单而强大的工具	36
从数据字典中获得更多知识	38
Yangtingkun的DBA工作手记（作者：杨廷琨）	45
利用SQL解释一个魔术	46
ORA-600(17069)错误的解决过程	47
V$SQL视图显示结果异常的诊断	51
存储过程ORA-4068之错误解析	54
一次网络连接错误的诊断	57
浅谈JOB和DATABASE LINK的一个特点	58
一次ORA-01041错误诊断	60
一个ORA-604错误的分析	61
ORA-7445(kdodpm)错误	62
函数索引产生隐藏列	65
用SQL解决一道有趣的题	67
老熊的DBA手记（作者：熊军）	71
TNS_ADMIN和OEM引起的血案	72
木马防护软件引起的DB Link故障	74
坏块与数据恢复	76
IP地址冲突引发的ORA-12541错误	82
ORA-8103错误的处理	83
BanPing的DBA工作手记（作者：邹德平）	87
SQL执行计划改变导致查询变慢	88
大数据量操作导致Data Guard延迟	91
Oracle重做日志切换频繁导致的性能问题	92
一次ORA-01438错误的解决办法	93
使用LogMiner查找日志信息	95
通过合并碎片来优化Oralce的存储结构	97
RAC环境下GES报警情况的处理	99
第2篇 诊断案例篇	101
ASM案例分析与诊断（作者：杨廷琨）	103
ASM实例连接之ORA-1012错误分析	104
ASM空间扩展故障解决	111
ASM创建表空间之ORA-569错误解决	115
一次监听故障的诊断与处理（作者：熊军）	121
问题诊断分析	122
监听的工作原理	123
问题的解决	127
总结	129
ORA系列错误与诊断（作者：杨廷琨）	131
解决ORA-600(16164)错误的过程	132
一次ORA-942错误的跟踪	139
删除表空间出现ORA-22868错误	150
一次ORA-1461错误处理过程	160
ORA-01200错误裸设备恢复（作者：盖国强）	169
问题的发现	170
问题的分析	171
控制文件与数据文件头	174
物理设备确认	176
解决方案的确定	176
恢复执行	177
使用rman管理裸设备文件	181
Oracle放弃对于裸设备的支持	184
Oracle数据库版本的含义	185
Oracle数据库无响应故障的处理（作者：熊军）	189
无响应故障现象分析	190
无响应故障成因分析	190
无响应故障处理流程	191
怎样避免数据库出现无响应故障	193
一个实际的案例处理过程	193
案例的总结分析	198
总结	201
RAC环境诊断案例一则（作者：杨廷琨）	203
第3篇 SQL调优篇	213
合理利用索引解决性能问题（作者：熊军）	215
案例一：利用复合索引解决性能问题	216
B Tree索引的结构及特点	218
Oracle如何扫描索引	223
案例二：巧用索引降序扫描解决性能问题	224
通过索引访问数据时的成本计算	225
案例三：降低clustering factor，解决性能问题	227
总结	228
SQL优化与调整实践（作者：杨廷琨）	229
HINT如何跨越视图生效	230
SQL优化引出的问题	236
SQL语句中常量的处理	244
一次更新操作的优化	247
索引访问与数据读取（作者：盖国强）	253
高DB Time使用之SQL发现	254
执行计划获取及索引优化	255
INDEX FAST FULL SCAN与排序	256
降序INDEX FULL SCAN消除排序的优化	260
INDEX FAST FULL SCAN的数据访问	262
INDEX FULL SCAN的数据访问	268
键值顺序与索引访问的性能	269
使用基于函数的索引提升查询性能	274
SQL优化之Everything is possible（作者：杨廷琨）	281
UNION效率比UNION ALL效率高	282
恒等查询条件对查询的影响	284
两层GROUP BY的效率反而比一层GROUP BY高	287
增加DISTINCT后查询效率反而提高	290
增加索引改变执行计划	292
第4篇 性能优化篇	295
执行计划与统计信息案例	（作者：杨廷琨）297
CBO使用CHECK的一个Bug	298
查询正常作为条件报错的问题	303
JOB调用DBMS_STATS包出错的诊断	308
长时间LATCH FREE等待——记一次系统异常的诊断过程	310
一次ORA-4030问题诊断及解决	317
Oracle数据库性能与统计信息（作者：熊军）	329
一个真实的案例	330
统计信息的重要性	334
统计信息的相关知识	335
面临的问题与挑战	337
关于统计信息的常见误区	339
总结	341
聚簇因子、柱状图与执行计划（作者：段林仲）	343
CLUSTERING_FACTOR对于执行计划的影响	344
CURSOR_SHARING与SQL的执行计划	348
Histograms对于执行计划的影响	352
表碎片及分页查询优化（作者：盖国强）	363
性能分析的起点	364
AWR与OSWatcher诊断案例	367
Statspack之案例分析	370
数据表之统计数据分析	371
碎片的消除与性能优化	374
Cache与Nocache对于性能的影响	379
ERP系统中Cache表案例分析	380
对于分页查询的优化	384
DBMS_PROFILER包用于诊断与优化	387
总结	390
一次排序的调整与优化（作者：段林仲）	391
Statspack之问题发现	392
SQL排序之问题定位	393
SQL优化与问题解决	394
优化后性能比较	400
参考文献	403
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle DBA手记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>收获，不止Oracle
上篇 开启惊喜之门——带意识地学Oracle
第1章 意识，少做事从学习开始 2
1.1 选择先学什么颇有学问 2
1.1.1 梁老师课堂爆笑开场 2
1.1.2 看似跑题的手机分类 4
1.1.3 学什么先了解做什么 5
1.2 善于规划分类才有效果 7
1.2.1 分类与角色密切相关 7
1.2.2 角色自我认识有讲究 9
1.3 明白学以致用方有意义 11
第2章 震惊，体验物理体系之旅 13
2.1 必须提及的系列知识 13
2.2 物理体系从老余开店慢慢铺开 16
2.2.1 老余的三个小故事 16
2.2.1.1 顾客的尺寸 16
2.2.1.2 有效的调整 17
2.2.1.3 记录的习惯 18
2.2.2 体系结构原理初探 20
2.2.2.1 从一普通查询SQL说起 20
2.2.2.2 老余故事终现用心良苦 23
2.2.2.3 一起体会Oracle代价 27
2.2.3 体系结构原理再探 30
2.2.3.1 从一普通更新语句说起 30
2.2.3.2 体系结构中提交的探讨 34
2.2.3.3 劳模的评选 38
2.2.3.4 回滚的研究 40
2.2.3.5 一致的查询 43
2.2.3.6 一致读的原理 46
2.2.3.7 实践的体会 49
2.3 体系学习让SQL性能提升千倍 65
2.3.1 一起探索体系学习的意义 65
2.3.1.1 同学们不知所学何用 66
2.3.1.2 实际上大有用武之地 67
2.3.2 单车到飞船的经典之旅 70
2.3.2.1 未优化前，单车速度 70
2.3.2.2 绑定变量，摩托速度 72
2.3.2.3 静态改写，汽车速度 74
2.3.2.4 批量提交，动车速度 75
2.3.2.5 集合写法，飞机速度 77
2.3.2.6 直接路径，火箭速度 78
2.3.2.7 并行设置，飞船速度 79
2.3.3 精彩的总结与课程展望 80
2.3.3.1 最大的收获应该是思想 80
2.3.3.2 老师的课程展望与规划 81
第3章 神奇，走进逻辑体系世界 84
3.1 长幼有序的逻辑体系 84
3.2 逻辑体系从老余养殖细细说起 85
3.2.1 农场之体系逻辑结构 85
3.2.2 农场之BLOCK漫谈 89
3.2.3 农场之区与段 91
3.2.4 农场之表空间的分类 93
3.2.4.1 表空间与系统农场 93
3.2.4.2 表空间与临时农场 93
3.2.4.3 表空间与回滚农场 94
3.2.5 逻辑结构之初次体会 94
3.2.5.1 逻辑结构之BLOCK 94
3.2.5.2 逻辑结构之TABLESPACE 95
3.2.5.3 逻辑结构之USER 97
3.2.5.4 逻辑结构之EXTENT 97
3.2.5.5 逻辑结构之SEGMENT 98
3.2.6 逻辑结构之二次体会 100
3.2.6.1 BLOCK的大小与调整 100
3.2.6.2 PCTFREE参数与调整 101
3.2.6.3 PCTFREE与生效范围 102
3.2.6.4 EXTENT尺寸与调整 103
3.2.7 逻辑结构之三次体会 104
3.2.7.1 已用与未用表空间情况 104
3.2.7.2 表空间大小与自动扩展 105
3.2.7.3 回滚表空间新建与切换 109
3.2.7.4 临时表空间新建与切换 111
3.2.7.5 临时表空间组及其妙用 114
3.3 课程结束你给程序安上了翅膀 117
3.3.1 过度扩展与性能 117
3.3.2 PCTFREE与性能 120
3.3.3 行迁移与优化 123
3.3.4 块的大小与应用 124
第4章 祝贺，表的设计成就英雄 131
4.1 表的设计之五朵金花 131
4.2 表的特性从老余一家展开描述 132
4.2.1 老余一家各施所长 132
4.2.2 普通堆表不足之处 132
4.2.2.1 表更新日志开销较大 133
4.2.2.2 delete无法释放空间 136
4.2.2.3 表记录太大检索较慢 139
4.2.2.4 索引回表读开销很大 140
4.2.2.5 有序插入却难有序读出 143
4.2.3 奇特的全局临时表 146
4.2.3.1 分析全局临时表的类型 146
4.2.3.2 观察各类DML的REDO量 147
4.2.3.3 全局临时表两大重要特性 149
4.2.4 神通广大的分区表 153
4.2.4.1 分区表类型及原理 155
4.2.4.2 分区表最实用的特性 165
4.2.4.3 分区索引类型简述 176
4.2.4.4 分区表之相关陷阱 177
4.2.5 有趣的索引组织表 184
4.2.6 簇表的介绍及应用 187
4.3 理解表设计的你成为项目组英雄 189
第5章 惊叹，索引天地妙不可言 191
5.1 看似简单无趣的索引知识 191
5.2 索引探秘从小余缉凶拉开帷幕 192
5.2.1 BTREE索引的精彩世界 192
5.2.1.1 BTREE索引结构图展现 192
5.2.1.2 到底是物理还是逻辑结构 194
5.2.1.3 索引结构三大重要特点 198
5.2.1.4 插播小余缉凶精彩故事 201
5.2.1.5 妙用三特征之高度较低 203
5.2.1.6 巧用三特征之存储列值 219
5.2.1.7 活用三特征之索引有序 248
5.2.1.8 不可不说的主外键设计 265
5.2.1.9 组合索引高效设计要领 272
5.2.1.10 变换角度看索引的危害 289
5.2.1.11 如何合理控制索引数量 295
5.2.2 位图索引的玫瑰花之刺 297
5.2.2.1 统计条数奋勇夺冠 297
5.2.2.2 即席查询一骑绝尘 302
5.2.2.3 遭遇更新苦不堪言 306
5.2.2.4 重复度低一败涂地 309
5.2.2.5 了解结构真相大白 311
5.2.3 小心函数索引步步陷阱 315
5.2.3.1 列运算让索引失去作用 315
5.2.3.2 函数索引是这样应用的 317
5.2.3.3 避免列运算的经典案例 319
5.3 索引让一系列最熟悉的SQL飞起来了 325
第6章 经典，表的连接学以致用 327
6.1 表的连接之江南三剑客 327
6.2 三大类型从小余跳舞一一道来 328
6.2.1 跳舞也能跳出连接类型 328
6.2.1.1 感觉怪异的嵌套循环 328
6.2.1.2 排序合并及哈希连接 329
6.2.2 各类连接访问次数差异 330
6.2.2.1 嵌套循环的表访问次数 330
6.2.2.2 哈希连接的表访问次数 337
6.2.2.3 排序合并的表访问次数 340
6.2.3 各类连接驱动顺序区别 341
6.2.3.1 嵌套循环的表驱动顺序 341
6.2.3.2 哈希连接的表驱动顺序 343
6.2.3.3 排序合并的表驱动顺序 345
6.2.4 各类连接排序情况分析 347
6.2.4.1 除嵌套循环都需排序 347
6.2.4.2 排序只需取部分字段 347
6.2.4.3 关于排序的经典案例 349
6.2.5 各类连接限制场景对比 350
6.2.5.1 哈希连接的限制 350
6.2.5.2 排序合并的限制 353
6.2.5.3 嵌套循环无限制 355
6.3 你动手装备的表连接威震三军 355
6.3.1 嵌套循环与索引 356
6.3.2 哈希连接与索引 362
6.3.3 排序合并与索引 363
下篇 飞翔意识天空——思想与案例的分享
第7章 搞定！不靠技术靠菜刀 368
7.1 SQL被一刀剁了 369
7.2 整个模块丢弃了 370
7.3 调用次数减少了 371
7.4 排序不再需要了 372
7.5 大表砍成小表了 373
7.6 排重操作消失了 373
7.7 插入阻碍小多了 374
7.8 迁移事情不做了 375
第8章 升级！靠技术改隐形刀 377
8.1 大表等同小表了 378
8.2 大表切成小表了 379
8.3 索引变身小表了 380
8.4 删除动作不做了 380
8.5 清表角度变换了 381
8.6 提交次数缩减了 382
8.7 迁移越来越快了 384
8.8 SQL语句精简了 385
第9章 提问，也是智慧的体现 391
9.1 描述要考虑周全 392
9.2 用词要尽量准确 393
9.3 说明要力求简洁 394
9.4 问过的避免再问 396
9.5 能搜能试不急问 396
第10章 买鱼，居然买出方法论 398
10.1 小余买鱼系列故事 398
10.1.1 诊断与改进 398
10.1.2 需求与设计 401
10.1.3 资源的利用 403
10.1.4 真正的需求 404
10.2 买鱼买出了方法论 405
10.2.1 一套流程 405
10.2.2 两大法宝 407
10.3 方法论的应用案例 408
10.3.1 从我们的这一套流程说起 408
10.3.1.1 诊断 408
10.3.1.2 改进优化（首次优化） 409
10.3.1.3 需求与设计（再次优化） 410
10.3.1.4 资源利用（花絮） 412
10.3.2 案例映衬了经典两大法宝 412
第11章 宝典，规范让你少做事 414
11.1 抓狂，为何事总忙不完 415
11.1.1 技术能力不足的新人们 415
11.1.2 不懂提问智慧的求助者 415
11.1.3 产生各种失误的粗心者 416
11.1.3.1 啊，小黄的DDL惹祸 416
11.1.3.2 惨，老师登错环境了 417
11.1.3.3 糟，小罗忘操作
11.1.4 解决问题缓慢的技术员 419
11.1.4.1 优化效率低下的小高 419
11.1.4.2 为何老师能快速解决 420
11.1.5 陷入种种困境的开发者 422
11.1.5.1 超长SQL使小郑烦恼 422
11.1.5.2 缺少注释让小叶沮丧 422
11.1.6 总是考虑不全的设计者 423
11.1.6.1 未提前规划的王工 423
11.1.6.2 不了解特性的刘工 424
11.2 淡定，规范少做无谓事 425
11.2.1 学习规范——促成新人快速成长 426
11.2.2 求助规范——引导求助不再迷糊 427
11.2.3 操作规范——协助粗心者不犯错 428
11.2.4 流程规范——保障问题快速解决 429
11.2.4.1 动态整体 429
11.2.4.2 动态局部 432
11.2.4.3 静态整体 439
11.2.4.4 静态局部 448
11.2.5 开发规范——让开发者驾轻就熟 451
11.2.5.1 SQL编写规范 452
11.2.5.2 PL/SQL编写规范 455
11.2.6 设计规范——助设计者运筹帷幄 457
11.2.6.1 表规范 458
11.2.6.2 索引规范 461
11.2.6.3 环境参数规范 467
11.2.6.4 命名规范469
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>收获，不止Oracle
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle PL/SQL实战
目　　录
第1章 　避免误用　　1
1.1 　逐行处理　　1
1.2 　嵌套的逐行处理　　3
1.3 　查找式查询　　5
1.4 　对DUAL的过度访问　　8
1.4.1 　日期的算术运算　　8
1.4.2 　访问序列　　9
1.4.3 　填充主—从行　　9
1.5 　过多的函数调用　　10
1.5.1 　不必要的函数调用　　10
1.5.2 　代价高昂的函数调用　　12
1.6 　数据库链接调用　　14
1.7 　过度使用触发器　　15
1.8 　过度提交　　15
1.9 　过度解析　　16
1.10 　小结　　16
第2章 　动态SQL：处理未知　　18
2.1 　动态SQL的三种方式　　19
2.1.1 　本地动态SQL　　19
2.1.2 　动态游标　　21
2.1.3 　DBMS_SQL　　25
2.2 　动态思考的样例　　26
2.3 　安全问题　　30
2.4 　性能和资源利用率　　33
2.4.1 　反模式　　34
2.4.2 　比较动态SQL的实现　　35
2.5 　对象的依赖关系　　37
2.5.1 　负面影响　　37
2.5.2 　正面影响　　37
2.6 　小结　　38
第3章 　PL/SQL和并行处理　　39
3.1 　为什么需要并行处理　　39
3.2 　影响并行处理的定律　　40
3.3 　大数据的崛起　　40
3.4 　并行与分布式处理　　41
3.5 　并行硬件体系结构　　41
3.6 　确定目标　　42
3.6.1 　加速　　42
3.6.2 　按比例扩展　　43
3.6.3 　并行度　　43
3.7 　用于并行处理的候选工作负载　　43
3.7.1 　并行和OLTP　　43
3.7.2 　并行和非OLTP工作负载　　44
3.8 　MapReduce编程模型　　44
3.9 　在使用PL/SQL之前　　45
3.10 　可用于并行活动的进程　　45
3.11 　使用MapReduce的并行执行服务器　　46
3.11.1 　管道表函数　　46
3.11.2 　指导　　60
3.11.3 　并行管道表函数小结　　61
3.12 　小结　　61
第4章 　警告和条件编译　　62
4.1 　PL/SQL 警告　　62
4.1.1 　基础　　62
4.1.2 　使用警告　　63
4.1.3 　升级警告为错误　　67
4.1.4 　忽略警告　　68
4.1.5 　编译和警告　　69
4.1.6 　关于警告的结束语　　72
4.2 　条件编译　　72
4.2.1 　基础　　72
4.2.2 　正在运行代码的哪部分　　75
4.2.3 　预处理代码的好处　　76
4.2.4 　有效性验证　　78
4.2.5 　控制编译　　80
4.2.6 　查询变量　　81
4.2.7 　关于条件编译的结束语　　82
4.3 　小结　　84
第5章 　PL/SQL单元测试　　85
5.1 　为什么要测试代码　　85
5.2 　什么是单元测试　　86
5.2.1 　调试还是测试　　86
5.2.2 　建立测试的时机　　86
5.3 　单元测试构建工具　　87
5.3.1 　utPLSQL：使用命令行代码　　87
5.3.2 　Quest Code Tester for Oracle　　87
5.3.3 　Oracle SQL Developer　　88
5.4 　准备和维护单元测试环境　　88
5.4.1 　创建单元测试资料档案库　　89
5.4.2 　维护单元测试资料档案库　　90
5.4.3 　导入测试　　91
5.5 　构建单元测试　　91
5.5.1 　使用单元测试向导　　91
5.5.2 　创建第一个测试实施　　92
5.5.3 　添加启动和拆除进程　　93
5.5.4 　收集代码覆盖率统计信息　　93
5.5.5 　指定参数　　93
5.5.6 　添加进程验证　　94
5.5.7 　保存测试　　95
5.5.8 　调试和运行测试　　95
5.6 　扩大测试的范围　　95
5.6.1 　创建查找值　　96
5.6.2 　植入测试实施　　97
5.6.3 　创建动态查询　　98
5.7 　支持单元测试功能　　99
5.7.1 　运行报告　　99
5.7.2 　创建组件库　　100
5.7.3 　导出、导入和同步测试　　103
5.7.4 　构建套件　　105
5.8 　从命令行运行测试　　105
5.9 　小结　　106
第6章 　批量SQL操作　　107
6.1 　五金商店　　107
6.2 　设置本章的例子　　108
6.3 　在PL/SQL中执行批量操作　　108
6.3.1 　批量获取入门　　110
6.3.2 　三种集合风格的数据类型　　112
6.3.3 　为什么要自找麻烦　　114
6.3.4 　监控批量收集的开销　　116
6.3.5 　重构代码以使用批量收集　　119
6.4 　批量绑定　　127
6.4.1 　批量绑定入门　　127
6.4.2 　度量批量绑定性能　　128
6.4.3 　监视内存的使用　　131
6.4.4 　11g中的改进　　133
6.5 　批量绑定的错误处理　　134
6.5.1 　SAVE EXCEPTIONS和分批操作　　137
6.5.2 　LOG ERRORS子句　　138
6.5.3 　健壮的批量绑定　　139
6.6 　大规模集合的正当理由　　143
6.7 　真正的好处：客户端批量处理　　145
6.8 　小结　　149
第7章 　透识你的代码　　151
7.1 　本章内容取舍　　152
7.2 　自动代码分析　　153
7.2.1 　静态分析　　154
7.2.2 　动态分析　　154
7.3 　执行分析的时机　　154
7.4 　执行静态分析　　156
7.4.1 　数据字典　　156
7.4.2 　PL/Scope　　163
7.5 　执行动态分析　　175
7.5.1 　DBMS_PROFILER和DBMS_TRACE　　175
7.5.2 　DBMS_HPROF　　184
7.6 　小结　　189
第8章 　合同导向编程　　190
8.1 　契约式设计　　190
8.1.1 　软件合同　　190
8.1.2 　基本合同要素　　191
8.1.3 　断言　　192
8.1.4 　参考文献　　192
8.2 　实现PL/SQL合同　　192
8.2.1 　基本的ASSERT程序　　192
8.2.2 　标准的包本地断言　　194
8.2.3 　使用ASSERT执行合同　　196
8.2.4 　其他改进　　198
8.2.5 　合同导向函数原型　　199
8.3 　示例：测试奇数和偶数　　200
8.4 　有用的合同模式　　202
8.4.1 　用NOT NULL输入且输出NOT NULL　　202
8.4.2 　函数返回NOT NULL　　203
8.4.3 　布尔型函数返回NOT NULL　　203
8.4.4 　检查函数：返回TRUE或ASSERTFAIL　　204
8.5 　无错代码的原则　　205
8.5.1 　严格地断言先决条件　　205
8.5.2 　一丝不苟地模块化　　206
8.5.3 　采用基于函数的接口　　206
8.5.4 　在ASSERTFAIL处崩溃　　207
8.5.5 　对后置条件进行回归测试　　207
8.5.6 　避免在正确性和性能之间取舍　　207
8.5.7 　采用Oracle 11g优化编译　　208
8.6 　小结　　209
第9章 　从SQL调用PL/SQL　　210
9.1 　在SQL中使用PL/SQL函数的开销　　210
9.1.1 　上下文切换　　211
9.1.2 　执行　　216
9.1.3 　欠理想的数据访问　　218
9.1.4 　优化器的难点　　222
9.1.5 　读一致性陷阱　　226
9.1.6 　其他问题　　228
9.2 　降低PL/SQL函数的开销　　228
9.2.1 　大局观　　229
9.2.2 　使用SQL的替代品　　230
9.2.3 　减少执行　　236
9.2.4 　协助CBO　　244
9.2.5 　调优PL/SQL　　255
9.3 　小结　　257
第10章 　选择正确的游标　　258
10.1 　显式游标　　258
10.1.1 　解剖显式游标　　260
10.1.2 　显式游标和批量处理　　261
10.1.3 　REF游标简介　　262
10.2 　隐式游标　　263
10.2.1 　解剖隐式游标　　264
10.2.2 　隐式游标和额外获取的理论　　265
10.3 　静态REF游标　　267
10.3.1 　详细的游标变量限制清单　　269
10.3.2 　客户端和REF游标　　270
10.3.3 　有关解析的话题　　271
10.4 　动态REF游标　　273
10.4.1 　例子和最佳用法　　273
10.4.2 　SQL注入的威胁　　275
10.4.3 　描述REF游标中的列　　276
10.5 　小结　　277
第11章 　大规模PL/SQL编程　　279
11.1 　将数据库作为基于PL/SQL的应用服务器　　279
11.1.1 　案例研究：Avaloq银行系统　　279
11.1.2 　在数据库中使用PL/SQL实现业务逻辑的优势　　281
11.1.3 　用数据库作为基于PL/SQL的应用程序服务器的限制　　283
11.1.4 　软因素　　284
11.2 　大规模编程的要求　　284
11.3 　通过规范实现一致性　　285
11.3.1 　缩写词　　286
11.3.2 　PL/SQL标识符的前缀和后缀　　289
11.4 　代码和数据的模块化　　291
11.4.1 　包和相关的表作为模块　　293
11.4.2 　含有多个包或子模块的模块　　297
11.4.3 　模式作为模块　　299
11.4.4 　在模式内部模块化　　303
11.4.5 　用模式模块化与在模式内模块化的比较　　306
11.5 　使用PL/SQL面向对象编程　　306
11.5.1 　使用用户定义类型的面向对象编程　　307
11.5.2 　使用PL/SQL记录面向对象编程　　310
11.5.3 　评估　　316
11.6 　内存管理　　317
11.6.1 　测量内存使用　　317
11.6.2 　集合　　322
11.7 　小结　　325
第12章 　渐进式数据建模　　326
12.1 　从二十年的系统开发中总结的经验　　327
12.2 　数据库和敏捷开发　　328
12.3 　渐进式数据建模　　329
12.4 　重构数据库　　331
12.5 　通过PL/SQL创建访问层　　335
12.6 　敏捷宣言　　347
12.7 　用PL/SQL进行渐进式数据建模　　349
12.7.1 　定义接口　　349
12.7.2 　思考可扩展性　　349
12.7.3 　测试驱动开发　　350
12.7.4 　明智地使用模式和用户　　350
12.8 　小结　　351
第13章 　性能剖析　　352
13.1 　何谓性能　　353
13.1.1 　功能需求　　353
13.1.2 　响应时间　　353
13.1.3 　吞吐量　　354
13.1.4 　资源利用率　　354
13.1.5 　性能是功能的一种　　355
13.2 　什么是剖析　　356
13.2.1 　顺序图　　356
13.2.2 　概要文件之神奇　　357
13.2.3 　性能剖析的好处　　357
13.3 　性能测量　　358
13.3.1 　这个程序为什么慢　　358
13.3.2 　测量嵌入　　360
13.3.3 　识别　　360
13.3.4 　条件编译　　364
13.3.5 　内建的剖析器　　365
13.3.6 　扩展的SQL跟踪数据（事件10046）　　365
13.3.7 　针对Oracle的测量工具库（ILO）　　366
13.4 　问题诊断　　368
13.4.1 　R方法　　369
13.4.2 　ILO示例　　371
13.4.3 　剖析示例　　373
13.5 　小结　　376
第14章 　编码规范和错误处理　　378
14.1 　为什么要制订编码规范　　378
14.2 　格式化　　379
14.2.1 　大小写　　379
14.2.2 　注释　　380
14.2.3 　比较　　380
14.2.4 　缩进　　380
14.3 　动态代码　　383
14.4 　包　　384
14.5 　存储过程　　385
14.5.1 　命名　　385
14.5.2 　参数　　386
14.5.3 　调用　　386
14.5.4 　局部变量　　386
14.5.5 　常量　　386
14.5.6 　类型　　387
14.5.7 　全局变量　　387
14.5.8 　本地存储过程和函数　　387
14.5.9 　存储过程元数据　　388
14.6 　函数　　388
14.7 　错误处理　　389
14.7.1 　错误捕获　　389
14.7.2 　错误报告　　390
14.7.3 　错误恢复　　391
14.7.4 　先测试再显示　　392
14.8 　小结　　392
第15章 　依赖关系和失效　　395
15.1 　依赖链　　395
15.2 　缩短依赖链　　401
15.3 　数据类型引用　　406
15.4 　用于表修改的视图　　407
15.5 　把组件添加到包　　410
15.6 　依赖链中的同义词　　413
15.7 　资源锁定　　414
15.8 　用触发器强制执行依赖　　415
15.9 　创建最初禁用的触发器　　418
15.10 　小结　　420

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle PL/SQL实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle编程入门经典
第一章 了解ORACLE
第二章 SQL*PLUS和基本查询
第三章 建立以及管理用户和表
第四章 新的9i示例模式
第五章 体系结构
第六章 在ORACLE中处理语句
第七章 表
第八章 索引
第九章 掌握SQL*PLUS
第十章 PL/SQL
……
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle编程入门经典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 10g数据库基础教程
第一篇  基础篇第1章  Oracle数据库概述  1.1  Oracle数据库系统    1.1.1  Oracle数据库简介    1.1.2  Oracle数据库发展史    1.1.3  Oracle数据库特点  1.2  Oracle数据库新特性  1.3  常见的关系数据库管理系统比较  1.4  Oracle数据库应用结构  小结  复习题第2章  数据库服务器的安装与卸载  2.1  安装前准备工作  2.2  安装Oracle 10g数据库服务器  2.3  数据库服务器安装疑难解析  2.4  检查数据库服务器的安装结果  2.5  卸载Oracle 10g产品  小结  复习题第3章  创建数据库  3.1  创建数据库前的准备  3.2  使用DBCA创建数据库  3.3  手动创建数据库  3.4  数据库服务器初始化参数文件    3.4.1  服务器参数文件概述    3.4.2  创建服务器初始化参数文件    3.4.3  修改服务器初始化参数文件中的参数    3.4.4  导出服务器初始化参数文件    3.4.5  查看初始化参数设置  小结  复习题第4章  Oracle企业管理器第5章  SQL*Plus    第二篇  体系结构篇第6章  物理存储结构第7章  逻辑存储结构第8章  数据库实例第9章  数据库服务工作模式与数据字典    第三篇  管理篇第10章  数据库启动与关闭第11章  模式对象第12章  安全管理第13章  备份与恢复第14章  闪回技术    第四篇  应用开发篇第15章  SQL语言基础第16章  PL/SQL程序设计第17章  基于Oracle数据库的应用开发参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 10g数据库基础教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle SQL高级编程
第1 章  SQL 核心　　1
1.1  SQL 语言　　1
1.2  数据库的接口　　2
1.3  SQL*Plus 回顾　　3
1.3.1  连接到数据库　　3
1.3.2  配置SQL*Plus 环境　　4
1.3.3  执行命令　　6
1.4 5  个核心的SQL 语句　　8
1.5  SELECT 语句　　8
1.5.1  FROM 子句　　9
1.5.2  WHERE 子句　　11
1.5.3  GROUP BY 子句　　11
1.5.4  HAVING 子句　　12
1.5.5  SELECT 列表　　12
1.5.6  ORDER BY 子句　　13
1.6  INSERT 语句　　14
1.6.1  单表插入　　14
1.6.2  多表插入　　15
1.7  UPDATE 语句　　17
1.8  DELETE 语句　　20
1.9  MERGE 语句　　22
1.10  小结　　24
第2 章  SQL 执行　　25
2.1  Oracle 架构基础　　25
2.2  SGA-共享池　　27
2.3  库高速缓存　　28
2.4  完全相同的语句　　29
2.5  SGA-缓冲区缓存　　32
2.6  查询转换　　35
2.7  视图合并　　36
2.8  子查询解嵌套　　39
2.9  谓语前推　　42
2.10  使用物化视图进行查询重写　　44
2.11  确定执行计划　　46
2.12  执行计划并取得数据行　　50
2.13  SQL 执行——总览　　52
2.14  小结　　53
第3 章  访问和联结方法　　55
3.1  全扫描访问方法　　55
3.1.1  如何选择全扫描操作　　56
3.1.2  全扫描与舍弃　　59
3.1.3  全扫描与多块读取　　60
3.1.4  全扫描与高水位线　　60
3.2  索引扫描访问方法　　65
3.2.1  索引结构　　66
3.2.2  索引扫描类型　　68
3.2.3  索引唯一扫描　　71
3.2.4  索引范围扫描　　72
3.2.5  索引全扫描　　74
3.2.6  索引跳跃扫描　　77
3.2.7  索引快速全扫描　　79
3.3  联结方法　　80
3.3.1  嵌套循环联结　　81
3.3.2  排序—合并联结　　83
3.3.3  散列联结　　84
3.3.4  笛卡儿联结　　87
3.3.5  外联结　　88
3.4  小结　　94
第4 章  SQL 是关于集合的　　95
4.1  以面向集合的思维方式来思考　　95
4.1.1  从面向过程转变为基于集合的思维方式　　96
4.1.2  面向过程vs.基于集合的思维方式：一个例子　　100
4.2  集合运算　　102
4.2.1  UNION 和UNION ALL　　103
4.2.2  MINUS　　106
4.2.3  INTERSECT 　　107
4.3  集合与空值　　108
4.3.1  空值与非直观结果　　108
4.3.2  集合运算中的空值行为　　110
4.3.3  空值与GROUP BY 和ORDER BY 　　112
4.3.4  空值与聚合函数　　114
4.4  小结　　114
第5 章  关于问题　　116
5.1  问出好的问题　　116
5.2  提问的目的　　117
5.3  问题的种类　　117
5.4  关于问题的问题　　119
5.5  关于数据的问题　　121
5.6  建立逻辑表达式　　126
5.7  小结　　136
第6 章  SQL 执行计划　　137
6.1  解释计划　　137
6.1.1  使用解释计划　　137
6.1.2  理解解释计划可能达不到目的的方式　　143
6.1.3  阅读计划　　146
6.2  执行计划　　148
6.2.1  查看最近生成的SQL 语句　　149
6.2.2  查看相关执行计划　　149
6.2.3  收集执行计划统计信息　　151
6.2.4  标识SQL 语句以便以后取回计划　　153
6.2.5  深入理解DBMS_XPLAN 的细节　　156
6.2.6  使用计划信息来解决问题　　161
6.3  小结　　169
第7 章  高级分组　　170
7.1  基本的GROUP BY 用法　　171
7.2  HAVING 子句　　 174
7.3  GROUP BY 的“新”功能　　175
7.4  GROUP BY 的CUBE 扩展　　175
7.5  CUBE 的实际应用　　 179
7.6  通过GROUPING()函数排除空值　　185
7.7  用GROUPING()来扩展报告　　186
7.8  使用GROUPING_ID()来扩展报告　　187
7.9  GROUPING SETS 与ROLLUP() 　　191
7.10  GROUP BY 局限性　　193
7.11  小结　　196
第8 章  分析函数　　 197
8.1  示例数据　　197
8.2  分析函数剖析　　 198
8.3  函数列表　　 199
8.4  聚合函数　　 200
8.4.1  跨越整个分区的聚合函数　　201
8.4.2  细粒度窗口声明　　201
8.4.3  默认窗口声明　　 202
8.5  Lead 和Lag 　　 202
8.5.1  语法和排序　　202
8.5.2  例1：从前一行中返回一个值　　203
8.5.3  理解数据行的位移　　204
8.5.4  例2：从下一行中返回一个值　　204
8.6  First_value 和Last_value 　　 205
8.6.1  例子：使用First_value 来计算最大值　　 206
8.6.2  例子：使用Last_value 来计算最小值　　 207
8.7  其他分析函数　　 207
8.7.1  Nth_value (11gR2) 　　 207
8.7.2  Rank 　　 209
8.7.3  Dense_rank 　　 210
8.7.4  Row_number 　　 211
8.7.5  Ratio_to_report 　　211
8.7.6  Percent_rank 　　212
8.7.7  Percentile_cont 　　213
8.7.8  Percentile_disc 　　215
8.7.9  NTILE　　215
8.7.10  Stddev 　　216
8.7.11  Listagg 　　217
8.8  性能调优　　218
8.8.1  执行计划　　218
8.8.2  谓语　　219
8.8.3  索引　　220
8.9  高级话题　　221
8.9.1  动态SQL 　　221
8.9.2  嵌套分析函数　　222
8.9.3  并行　　223
8.9.4  PGA 大小　　224
8.10  组织行为　　224
8.11  小结　　224
第9 章  Model 子句　　225
9.1  电子表格　　225
9.2  通过Model 子句进行跨行引用　　226
9.2.1  示例数据　　226
9.2.2  剖析Model 子句　　227
9.2.3  规则　　228
9.3  位置和符号引用　　229
9.3.1  位置标记　　229
9.3.2  符号标记　　230
9.3.3  FOR 循环　　231
9.4  返回更新后的行　　232
9.5  求解顺序　　233
9.5.1  行求解顺序　　233
9.5.2  规则求解顺序　　235
9.6  聚合　　237
9.7  迭代　　237
9.7.1  一个例子　　238
9.7.2  PRESENTV与空值　　239
9.8  查找表　　240
9.9  空值　　242
9.10  使用Model子句进行性能调优　　243
9.10.1  执行计划　　243
9.10.2  谓语前推　　246
9.10.3  物化视图　　247
9.10.4  并行　　249
9.10.5  Model 子句执行中的分区　　250
9.10.6  索引　　251
9.11  子查询因子化　　252
9.12  小结　　253
第10 章  子查询因子化　　254
10.1  标准用法　　254
10.2  SQL 优化　　257
10.2.1  测试执行计划　　257
10.2.2  跨多个执行的测试　　260
10.2.3  测试查询改变的影响　　263
10.2.4  寻找其他优化机会　　266
10.2.5  将子查询因子化应用到PL/SQL 中　　270
10.3  递归子查询　　273
10.3.1  一个CONNECT BY 的例子　　274
10.3.2  使用RSF 的例子　　275
10.3.3  RSF 的限制条件　　276
10.3.4  与CONNECT BY 的不同点　　276
10.4  复制CONNECT BY 的功能　　277
10.4.1  LEVEL 伪列　　278
10.4.2  SYS_CONNECT_BY_PATH 函数　　279
10.4.3  CONNECT_BY_ROOT 运算符　　281
10.4.4  CONNECT_BY_ISCYCLE伪列和NOCYCLE 参数　　284
10.4.5  CONNECT_BY_ISLEAF 伪列　　287
10.5  小结　　291
第11 章  半联结和反联结　　292
11.1  半联结　　292
11.2  半联结执行计划　　300
11.3  控制半联结执行计划　　305
11.3.1  使用提示控制半联结执行计划　　305
11.3.2  在实例级控制半联结执行计划　　308
11.4  半联结限制条件　　310
11.5  半联结必要条件　　312
11.6  反联结　　312
11.7  反联结执行计划　　317
11.8  控制反联结执行计划　　326
11.8.1  使用提示控制反联结执行计划　　326
11.8.2  在实例级控制反联结执行计划　　327
11.9  反联结限制条件　　330
11.10  反联结必要条件　　333
11.11  小结　　333
第12 章  索引　　334
12.1  理解索引　　335
12.1.1  什么时候使用索引　　335
12.1.2  列的选择　　337
12.1.3  空值问题　　338
12.2  索引结构类型　　339
12.2.1  B-树索引　　339
12.2.2  位图索引　　340
12.2.3  索引组织表　　341
12.3  分区索引　　343
12.3.1  局部索引　　343
12.3.2  全局索引　　345
12.3.3  散列分区与范围分区　　346
12.4  与应用特点相匹配的解决方案　　348
12.4.1  压缩索引　　348
12.4.2  基于函数的索引　　350
12.4.3  反转键索引　　353
12.4.4  降序索引　　354
12.5  管理问题的解决方案　　355
12.5.1  不可见索引　　355
12.5.2  虚拟索引　　356
12.5.3  位图联结索引　　357
12.6  小结　　359
第13 章  SELECT 以外的内容　　360
13.1  INSERT　　360
13.1.1  直接路径插入　　360
13.1.2  多表插入　　 363
13.1.3  条件插入　　 364
13.1.4  DML 错误日志　　 364
13.2  UPDATE　　371
13.3  DELETE　　376
13.4  MERGE 　　380
13.4.1  语法和用法　　380
13.4.2  性能比较　　 383
13.5  小结　　 385
第14 章  事务处理　　 386
14.1  什么是事务　　 386
14.2  事务的ACID 属性　　 387
14.3  事务隔离级别　　388
14.4  多版本读一致性　　 390
14.5  事务控制语句　　391
14.5.1  Commit（提交）　　391
14.5.2  Savepoint（保存点） 　　 391
14.5.3  Rollback（回滚） 　　 391
14.5.4  Set Transaction（设置事务） 　　 391
14.5.5  Set Constraints（设置约束） 　　 392
14.6  将运算分组为事务　　 392
14.7  订单录入模式　　393
14.8  活动事务　　 399
14.9  使用保存点　　 400
14.10  序列化事务　　 403
14.11  隔离事务　　 406
14.12  自治事务　　 409
14.13  小结　　413
第15 章  测试与质量保证　　 415
15.1  测试用例　　 416
15.2  测试方法　　 417
15.3  单元测试　　 418
15.4  回归测试　　 422
15.5  模式修改　　 422
15.6  重复单元测试　　425
15.7  执行计划比较　　426
15.8  性能测量　　 432
15.9  在代码中加入性能测量　　432
15.10  性能测试　　436
15.11  破坏性测试　　437
15.12  通过性能测量进行系统检修　　439
15.13  小结　　442
第16 章  计划稳定性与控制　　443
16.1  计划不稳定性：理解这个问题　　443
16.1.1  统计信息的变化　　444
16.1.2  运行环境的改变　　446
16.1.3  SQL 语句的改变　　447
16.1.4  绑定变量窥视　　448
16.2  识别执行计划的不稳定性　　450
16.2.1  抓取当前所运行查询的数据　　451
16.2.2  查看一条语句的性能历史　　452
16.2.3  按照执行计划聚合统计信息　　454
16.2.4  寻找执行计划的统计方差　　454
16.2.5  在一个时间点附近检查偏差　　456
16.3  执行计划控制：解决问题　　458
16.3.1  调整查询结构　　459
16.3.2  适当使用常量　　459
16.3.3  给优化器一些提示　　459
16.4  执行计划控制：不能直接访问代码　　466
16.4.1  选项1：改变统计信息　　467
16.4.2  选项2：改变数据库参数　　469
16.4.3  选项3：增加或移除访问路径　　469
16.4.4  选项4：应用基于提示的执行计划控制机制　　470
16.4.5  大纲　　470
16.4.6  SQL 概要文件　　481
16.4.7  SQL 执行计划基线　　496
16.4.8  基于提示的执行计划控制机制总结　　502
16.5  结论　　502
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle SQL高级编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>构建Oracle高可用环境
第1篇 高可用性篇	1
第1章 什么是Oracle高可用环境	3
1.1 理解Oracle数据库	5
1.2 Oracle高可用特性（High Availability）	40
1.3 搭建高可用的周边辅助环境	50
1.4 高可用应用设计	53
1.5 高可用数据库设计	55
1.6 高可用性案例	63
1.7 总结	66
第2章 Oracle高可用性之辅助环境	67
2.1 存储的选择与规划	68
2.2 网络存储技术	97
2.3 主机的选择与规划	105
2.4 操作系统与存储管理	115
2.5 高可用环境硬件选型案例分析	124
2.6 总结	126
第3章 Oracle高可用之容灾与分级存储	127
3.1 容灾	128
3.2 容灾案例分析	143
3.3 分级存储	146
3.4 总结	150
第4章 Oracle高可用之RAC介绍	151
4.1 RAC的构架	152
4.2 Oracle 10g/11g中RAC的新特性	158
4.3 RAC的负载均衡	161
4.4 RAC的内部结构与优化	166
4.5 RAC的维护管理	171
4.6 ASM介绍	182
4.7 总结	188
第5章 Oracle高可用之Standby介绍	191
5.1 备用数据库（Standby/Data guard）简介	192
5.2 决定归档的一些参数说明	202
5.3 最大保护模式与最大可用模式	205
5.4 日常管理	207
5.5 主库与备用库的切换	212
5.6 逻辑备用（Logical Standby）库	216
5.7 Standby其他高可用特性	223
5.8 总结	227
第6章 Oracle之Streams介绍	229
6.1 Streams介绍	230
6.2 Streams特性	235
6.3 Streams简单配置	237
6.4 SharePlex与DSG RealSync	251
6.5 总结	253
第7章 高可用性之主机HA	255
7.1 主机HA简介	256
7.2 IBM HACMP简介	262
7.3 Veritas VCS简介	270
7.4 是否应当选择主机HA	272
7.5 总结	273
第8章 Oracle其他高可用特性	275
8.1 Oracle Flashback	276
8.2 Oracle高可用之Logmnr	305
8.3 在线表重定义	311
8.4 总结	321
第2篇 数据处理篇	323
第9章 高可用环境备份方案与策略	325
9.1 高可用环境的备份体系构架	326
9.2 使用导出导入构建逻辑备份策略	333
9.3 使用RMAN构造物理备份策略	339
9.4 其他RMAN高可用特性	360
9.5 总结	367
第10章 高可用环境下数据迁移	369
10.1 数据迁移方案讨论	370
10.2 数据迁移案例分析	374
10.3 其他迁移方法	388
10.4 总结	398
第11章 高可用环境数据规划	399
11.1 表空间管理	400
11.2 数据规划分布	414
11.3 总结	421
第3篇 性能优化篇	423
第12章 高可用环境下性能优化	425
12.1 Statspack与AWR的介绍	426
12.2 Statspack与AWR的安装与配置	427
12.3 Statspack与AWR的使用	430
12.4 分析报表	432
12.5 Statspack与AWR的扩展	451
12.6 总结	453
第13章 高可用环境下优化案例	455
13.1 优化规则分析	456
13.2 表关联	464
13.3 优化案例分析	467
13.4 怎样选择最适合自己的环境	474
13.5 总结	477
第4篇 系统维护篇	479
第14章 高可用环境锁与并发控制	481
14.1 锁与阻塞	482
14.2 死锁分析	493
14.3 并发控制	503
14.4 总结	510
第15章 高可用环境之在线维护	513
15.1 高可用环境下修正数据（DML）	514
15.2 高可用环境下结构操作（DDL）	521
15.3 测试环境与统计分析数据	535
15.4 总结	539
第5篇 监控体系篇	541
第16章 高可用环境监控构架设计	543
16.1 监控构架设计	545
16.2 构建一个监控构架	554
16.3 分析功能的增强	565
16.4 监控与安全	570
16.5 辅助监控手段	573
16.6 其他监控手段与软件	577
16.7 总结	579
附录A 常见专有名称解释	581
附录B 公共代码	585
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>构建Oracle高可用环境
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle PL/SQL实例精解
译者序
致谢
作者简介
Oracle 11g中PL／SQL新特性简介
第1章 PL／SQL概念
1.1 在客户端／服务器架构中PL／SQL的应用
1.1.1 使用PL／SQL匿名语句块
1.1.2 理解如何执行PL／SQL
1.2 SQL Plus中的PL／SQL
1.2.1 使用替代变量
1.2.2 使用DBMSOUTPUT.PUT LINE语句
1.3 动手试验
第2章 通用编程语言基础
2.1 PL／SQL编程基础
2.1.1 充分利用PL／SQL语言组件
2.1.2 充分利用PL／SQL变量
2.1.3 合理使用PL／SQL保留字
2.1.4 在PL／SQL中使用标识符
2.1.5 使用Anchored数据类型
2.1.6 声明和初始化变量
2.1.7 理解语句块、嵌套语句块和标签的作用范围
2.2 动手试验
第3章 PL／SQL中的SQL
3.1 在PL／SQL中使用DML
3.1.1 变量初始化时使用SELECT INTO语法
3.1.2 在PL／SQL语句块中使用DML
3.1.3 在PL／SQL语句块中使用序列
3.2 使用SAVEPOINT
3.3 动手试验
第4章 条件控制：IF语句
4.1 IF语句
4.1.1 使用IF-THEN语句
4.1.2 使用IF-THEN-ELSE语句
4.2 ELSIF语句
4.3 嵌套IF语句
4.4 动手试验
第5章 条件控制：CASE语句
5.1 CASE语句
5.1.1 使用CASE语句
5.1.2 使用搜索式CASE语句
5.2 CASE表达式
5.3 NULLIF和COALESCE函数
5.3.1 NULLIF函数
5.3.2 使用COALEESCE函数
5.4 动手试验
第6章 迭代控制：第一部分
6.1 简单循环
6.1.1 使用带有EXIT条件的简单循环
6.1.2 使用带有EXITWHEN条件的简单循环
6.2 WHILE循环
6.3 数值型FOR循环
6.3.1 与IN选项一起使用数值型FOR循环
6.3.2 与REVERSE选项一起使用数值型FOR循环
6.4 动手试验
第7章 迭代控制：第二部分
7.1 CONTINUE语句
7.1.1 使用CONTINUE语句
7.1.2 使用CONTINUE WHEN语句
7.2 嵌套循环
7.3 动手试验
第8章 错误处理和内置异常
8.1 处理错误
8.2 内置异常
8.3 动手试验
第9章 异常
9.1 异常作用范围
9.2 用户定义异常
9.3 异常传播
9.3.1 理解异常的传播方式
9.3.2 再次抛出异常
9.4 动手试验
第10章 异常：高级概念
10.1 RAISE APPLICATION ERROR
10.2 EXCEPTtON It~编译指令
10.3 SQLCODE和SQLERRM
10.4 动手试验
第11章 游标简介
11.1 游标操作
11.1.1 充分利用记录类型
11.1.2 处理显式游标
11.1.3 充分利用游标属性
11.1.4 集成所做的工作
11.2 使用游标FOR循环和嵌套游标
11.2.1 使用游标FOR循环
11.2.2 处理嵌套的游标
11.3 动手试验
第12章 高级游标
12.1 在游标和复杂的嵌套游标中使用参数
12.1.1 在游标中使用参数
12.1.2 使用复杂的嵌套游标
12.2 FOR UPDATE和WHERECURRENT游标
第13章 触发器
13.1 什么是触发器
13.1.1 理解什么是触发器
13.1.2 使用BEFORE和AFTER触发器
13.2 触发器类型
13.2.1 使用行触发器和语句触发器
13.2.2 使用INSTEAD OF触发器
13.3 动手试验
第14章 复合触发器
14.1 变异表问题
14.2 复合触发器
14.3 动手试验
第15章集合
15.1 PL／SQL表
15.1.1 使用联合数组
15.1.2 使用嵌套表
15.2 变长数组
15.3 多层集合
15.4 动手试验
第16章 记录
16.1 记录类型
16.1.1 使用基于表的和基于游标的记录
16.1.2 使用用户定义的记录
16.2 嵌套记录
16.3 记录的集合
16.4 动手试验
第17章 本地动态SQL
17.1 EXECUTE IMMEDIATE语句
17.2 OPEN-FOR、FETCH和CLOSE语句
17.3 动手试验
第18章 批量8QL
18.1 FORAIL语句
18.2 BULK COLLECT子句
18.3 动手试验
第19章 过程
19.1 创建过程
19.1.1 创建过程
19.1.2 从数据字典查询有关过程的信息
19.2 过程传入和传出参数
19.3 动手试验
19.3.1 第一部分
19.3.2 第二部分
第20章 函数
20.1 创建和使用函数
20.1.1 创建存储函数
20.1.2 使用函数
20.1.3 在SQL语句中调用函数
20.1.4 编写复杂的函数
20.2 动手试验
第21章 包
21.1 使用包的好处
21.1.1 创建包规范
21.1.2 创建包体
21.1.3 调用存储包
21.1.4 创建私有对象
21.1.5 创建包变量和游标
21.2 游标变量
21.3 扩展包
21.4 动手试验
第22章 存储代码
22.1 收集有关存储代码的信息
22.1.1 从数据字典收集存储代码信息
22.1.2 使用RESTRICT REFERENCES编译指令实现纯度等级
22.1.3 重载模块
22.2 动手试验
第23章 Oracle中对象类型
23.1 对象类型
23.1.1 使用对象类型
23.1.2 使用集合和对象类型
23.2 对象类型方法
23.3 动手试验
第24章 Oracle提供的包
24.1 使用Oracle提供的包来配置PL／SQL、访问文件和调度作业
24.1.1 使用UTL FILE来访问文件
24.1.2 使用DBMS-JOB来调度作业
24.1.3 提交作业
24.2 使用Oracle提供的包来生成解释计划和创建HTML页面
24.3 使用Oracle Web Toolkit来创建Web页面
附录A PL／SQL格式化指南
附录B Student数据库模式
附录C ANSI SQL标准
附录D 动手试验部分的参考答案
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle PL/SQL实例精解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入解析Oracle
第1章 数据库的启动和关闭 1
1.1 数据库的启动 1
1.1.1 启动数据库到NOMOUNT状态的过程 2
1.1.2 启动数据库到MOUNT状态 18
1.1.3 启动数据库OPEN阶段 26
1.2 数据库的访问 37
1.2.1 客户端的TNSNAMES.ORA文件配置 37
1.2.2 服务器端的监听器文件listener.ora配置 39
1.2.3 通过不同服务器名对数据库的访问 41
1.2.4 动态监听器注册服务 42
1.3 数据库的关闭 46
1.3.1 数据库关闭的步骤 46
1.3.2 几种关闭方式的对比 48
第2章 控制文件与数据库初始化 51
2.1 控制文件的内容 51
2.2 SCN 53
2.2.1 SCN的定义 53
2.2.2 SCN的获取方式 53
2.2.3 SCN的进一步说明 54
2.3 检查点(Checkpoint) 57
2.3.1 检查点(Checkpoint)的工作原理 57
2.3.2 常规检查点与增量检查点 59
2.3.3 LOG_CHECKPOINT_TO_ALERT参数 63
2.3.4 控制文件与数据文件头信息 64
2.3.5 数据库的启动验证 66
2.3.6 使用备份的控制文件 70
2.3.7 FAST_START_MTTR_TARGET 71
2.3.8 关于检查点执行的案例 74
2.3.9 Oracle 10g自动检查点调整 75
2.3.10 检查点信息及恢复起点 78
2.3.11 正常关闭数据库的状况 78
2.3.12 数据库异常关闭的情况 80
2.3.13 数据库并行恢复案例一则 82
2.3.14 判断一个死事务的恢复进度 85
2.4 数据库的初始化 86
2.4.1 bootstrap$及数据库初始化过程 86
2.4.2 bootstrap$的定位 88
2.4.3 Oracle中独一无二的Cache对象 89
2.4.4 Oracle数据库的引导 91
2.4.5 系统对象与bootstrap$ 92
2.4.6 bootstrap$的重要性 94
2.4.7 BBED工具的简要介绍 95
2.4.8 坏块的处理与恢复 97
第3章 参数及参数文件 103
3.1 初始化参数的分类 103
3.1.1 推导参数(Derived Parameters) 103
3.1.2 操作系统依赖参数 104
3.1.3 可变参数 104
3.1.4 初始化参数的获取 105
3.2 参数文件 107
3.2.1 PFILE和SPFILE 108
3.2.2 获取参数的视图 110
3.2.3 SPFILE的创建 111
3.2.4 SPFILE的搜索顺序 112
3.2.5 使用PFILE/SPFILE启动数据库 112
3.2.6 修改参数 113
3.2.7 解决SPFILE参数修改错误 118
3.2.8 重置SPFILE中设置的参数 120
3.2.9 判断是否使用了SPFILE 120
3.2.10 SPFILE的备份与恢复 121
3.2.11 Oracle 11g参数文件恢复 127
3.2.12 如何设置Events事件 128
3.2.13 导出SPFILE文件 129
3.3 诊断案例之一：参数文件 131
3.3.1 登录系统检查告警日志文件 131
3.3.2 尝试重新启动数据库 132
3.3.3 检查数据文件 132
3.3.4 MOUNT数据库，检查系统参数 133
3.3.5 检查参数文件 133
3.3.6 再次检查alert文件 134
3.3.7 修正PFILE 135
3.3.8 启动数据库 135
3.4 诊断案例之二：RAC环境参数文件 135
3.4.1 数据库资源异常 135
3.4.2 问题的发现 136
3.4.3 参数文件问题的解决 137
第4章 数据字典 138
4.1 数据字典概述 138
4.2 内部RDBMS(X$)表 138
4.3 数据字典表 141
4.4 静态数据字典视图 145
4.4.1 静态数据字典视图的分类 145
4.4.2 静态数据字典视图的内部实现 146
4.4.3 常用数据字典视图举例 148
4.5 动态性能视图 151
4.5.1 GV$和V$视图 151
4.5.2 GV_$、V_$视图和V$、GV$同义词 152
4.5.3 进一步的说明 156
4.5.4 动态性能视图与数据库启动 157
4.6 最后的验证 157
4.6.1 V$PARAMETER的结构 157
4.6.2 视图还是同义词 158
4.6.3 Oracle如何通过同义词定位对象 159
第5章 内存管理 162
5.1 PGA管理 162
5.1.1 什么是PGA 162
5.1.2 UGA与CGA 163
5.1.3 PGA管理技术的变迁 165
5.1.4 参数的设置与内存分配 166
5.1.5 自动PGA管理实现原理 169
5.1.6 PGA的调整建议 173
5.1.7 PGA的转储 176
5.2 SGA管理 178
5.2.1 SGA的组成 179
5.2.2 SGA与共享内存 186
5.2.3 SGA管理的变迁 191
5.3 Oracle的内存分配和使用 204
5.3.1 诊断案例一：SGA与SWAP 205
5.3.2 诊断案例二：SGA设置过高导致的系统故障 208
5.3.3 诊断案例三：如何诊断和解决CPU高度消耗(100%)问题 212
第6章 Buffer Cache与Shared Pool原理 215
6.1 Buffer Cache原理 215
6.1.1 LRU与Dirty List 215
6.1.2 Cache Buffers LRU Chain闩锁竞争与解决 220
6.1.3 Cache Buffer Chain闩锁竞争与解决 221
6.2 Shared Pool的基本原理 233
6.2.1 Oracle 11g新特性：Result Cache 234
6.2.2 Shared Pool的设置说明 238
6.2.3 Oracle 9i子缓冲池的增强 243
6.2.4 Oracle 10g共享池管理的增强 245
6.2.5 了解X$KSMSP视图 247
6.2.6 Shared Pool的转储与分析 250
6.2.7 诊断和解决ORA-04031错误 262
6.2.8 Library Cache Pin及Library Cache Lock分析 273
6.2.9 诊断案例一：version_count过高造成的Latch竞争解决 281
6.2.10 V$SQL与V$SQLAREA视图 287
6.2.11 Oracle 10g中version_count过高的诊断 292
6.2.12 诊断案例二：临时表引发的竞争 297
6.2.13 小结 299
第7章 重做(Redo) 300
7.1 Redo的作用 300
7.2 Redo的原理 301
7.3 Redo与Latch 302
7.4 Oracle 9i Redo的增强 303
7.5 Oracle 10g Redo的增强 304
7.6 Redo的内容 307
7.7 产生多少Redo 310
7.8 Redo写的触发条件 314
7.8.1 每3秒超时(Timeout) 314
7.8.2 阈值达到 314
7.8.3 用户提交 315
7.8.4 在DBWn写之前 315
7.9 Redo Log Buffer的大小设置 316
7.10 commit做了什么? 317
7.11 日志的状态 318
7.12 日志的块大小 321
7.13 日志文件的大小 322
7.14 如何调整日志文件大小 324
7.15 为什么热备份期间产生的Redo要比正常的多 326
7.16 能否不生成Redo 329
7.17 Redo故障的恢复 333
7.17.1 丢失非活动日志组的故障恢复 333
7.17.2 丢失活动或当前日志文件的恢复 335
7.18 诊断案例一：通过Clear日志恢复数据库 339
7.19 诊断案例二：日志组过度激活的诊断 342
附录 数值在Oracle的内部存储 344
第8章 回滚与撤销 347
8.1 什么是回滚和撤销 347
8.2 回滚段存储的内容 348
8.3 并发控制和一致性读 349
8.4 回滚段的前世今生 350
8.5 Oracle 10g的UNDO_RETENTION管理增强 355
8.6 UNDO_RETENTION的内部实现 357
8.7 Oracle 10g In Memory Undo新特性 358
8.8 Oracle 11g UNDO表空间备份增强 360
8.9 回滚机制的深入研究 361
8.9.1 从DML更新事务开始 361
8.9.2 获得事务信息 362
8.9.3 获得回滚段名称并转储段头信息 362
8.9.4 获得跟踪文件信息 363
8.9.5 转储前镜像信息 364
8.9.6 转储数据块信息 367
8.9.7 块清除(Block Cleanouts) 369
8.9.8 提交之后的UNDO信息 373
8.10 Oracle 9i闪回查询的新特性 375
8.11 使用ERRORSTACK进行错误跟踪 377
8.12 Oracle 10g闪回查询特性的增强 378
8.13 ORA-01555成因与解决 382
8.14 Oracle 11g闪回数据归档 389
8.15 AUM下如何重建UNDO表空间 393
8.16 使用Flashback Query恢复误删除数据 394
8.17 诊断案例之一：释放过度扩展的UNDO空间 396
8.18 特殊情况的恢复 399
8.19 诊断案例之二：回滚段损坏的恢复 402
第9章 等待事件 406
9.1 等待事件的源起 406
9.2 从等待发现瓶颈 408
9.2.1 V$SESSION 和V$SESSION_WAIT 409
9.2.2 V$SESSION_EVENT和V$SYSTEM_EVENT 410
9.2.3 Oracle 11g实时SQL监控 411
9.2.4 从V$SQLTEXT中追踪 414
9.2.5 捕获相关SQL 415
9.3 Oracle 10g的增强 417
9.3.1 新增v$session_wait_history视图 418
9.3.2 ASH新特性 419
9.3.3 自动负载信息库：AWR的引入 425
9.3.4 自动数据库诊断监控：ADDM的引入 436
9.4 顶级等待事件 436
9.5 重要等待事件 439
9.5.1 db file sequential read(数据文件顺序读取) 439
9.5.2 db file scattered read等待事件 440
9.5.3 direct path read/write(直接路径读/写) 444
9.5.4 日志文件相关等待 453
9.5.5 Enqueue(队列等待) 458
9.5.6 Latch Free(闩锁释放) 462
9.5.7 Oracle 10g/11g Latch机制的变化 467
第10章 性能诊断与SQL优化 471
10.1 使用AUTOTRACE功能辅助SQL优化 471
10.1.1 AUTOTRACE功能的启用 471
10.1.2 Oracle 10g AUTOTRACE功能的增强 473
10.1.3 AUTOTRACE功能的内部操作 475
10.1.4 使用AUTOTRACE功能辅助SQL优化 477
10.2 获取SQL执行计划的方法 479
10.2.1 通过V$SQL_PLAN获得执行计划 479
10.2.2 EXPLAIN PLAN FOR与DBMS_XPLAN 483
10.2.3 通过AWR获取SQL执行计划 487
10.3 捕获问题SQL解决过度CPU消耗问题 488
10.3.1 使用vmstat检查系统当前情况 488
10.3.2 使用TOP工具辅助诊断 489
10.3.3 检查进程数量 490
10.3.4 登录数据库 490
10.3.5 捕获相关SQL 491
10.3.6 创建新的索引以消除全表扫描 494
10.3.7 观察系统状况 494
10.3.8 性能何以提高 495
10.3.9 小结 497
10.4 使用SQL_TRACE/10046事件进行数据库诊断 497
10.4.1 SQL_TRACE及10046事件的基础介绍 497
10.4.2 诊断案例之一：隐式转换与索引失效 502
10.4.3 诊断案例之二：跟踪后台错误 506
10.4.4 10046与等待事件 509
10.5 使用物化视图进行翻页性能调整 514
10.5.1 系统环境 514
10.5.2 问题描述 514
10.5.3 捕获排序SQL语句 515
10.5.4 确定典型问题SQL 515
10.5.5 选择解决办法 517
10.5.6 进一步的调整优化 518
10.5.7 小结 520
10.6 一次横跨两岸的问题诊断 520
10.6.1 第一封求助邮件 520
10.6.2 第一次回复 523
10.6.3 进一步信息提供 523
10.6.4 进一步的诊断 524
10.6.5 最后的问题定位 525
10.6.6 小结 525
10.7 总结 525
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入解析Oracle
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入浅出Oracle
第1章 数据库的启动和关闭
1.1 数据库的启动
1.1.1 启动数据库到nomount状态
1.1.2 启动数据库到mount状态
1.1.3 启动数据库open阶段
1.2 进阶内容
1.2.1 scn
1.2.2 检查点
1.2.3 正常关闭数据库的状况
1.2.4 数据库异常关闭的情况:
1.3 深入分析
1.3.1 获得数据库open的跟踪文件
1.3.2 bootstrap$及数据库初始化过程
1.3.3 bootstrap$的重要性
1.3.4 bbed工具的简要介绍
第2章 参数及参数文件
2.1 初始化参数的分类
2.1.1 推导参数（derived parameters）
2.1.2 操作系统依赖参数
2.1.3 可变参数
.2.1.4 初始化参数的获取
2.2 参数文件
2.2.1 pfile和spfile
2.2.2 spfile的创建
2.2.3 spfile的搜索顺序
2.2.4 使用pfile/spfile启动数据库
2.2.5 修改参数
2.2.6 重置spfile中设置的参数
2.2.7 是否使用了spfile
2.2.8 spfile的备份与恢复
2.2.9 如何设置events事件
2.2.10 导出spfile文件
2.3 诊断案例
2.3.1 登录系统检查alert.log文件
2.3.2 尝试重新启动数据库
2.3.3 检查数据文件
2.3.4 mount数据库，检查系统参数
2.3.5 检查参数文件
2.3.6 再次检查alert文件
2.3.7 修正pfile
2.3.8 启动数据库
第3章 数据字典
3.1 数据字典概述
3.2 内部rdbms（x$）表
3.3 数据字典表
3.4 动态性能视图
3.4.1 gv$和v$视图
3.4.2 gv_$、v_$视图和v$、gv$同义词
3.4.3 数据字典视图
3.4.4 进一步的说明
3.5 最后的验证
3.5.1 v$parameter的结构
3.5.2 视图还是同义词
3.5.3 oracle如何通过同义词定位对象
第4章 内存管理
4.1	sga管理
4.1.1	什么是sga
4.1.2	sga与共享内存
4.1.3	sga管理的变迁
4.2	pga管理
4.2.1	什么是pga
4.2.2	pga的调整建议
4.3	oracle的内存分配和使用
4.3.1	诊断案例一：sga与swap
4.3.2	诊断案例二：sga设置过高导致的系统故障
4.3.3	诊断案例三：如何诊断和解决cpu高度消耗（100%）问题
第5章 buffer cache与shared pool原理
5.1 buffer cache原理
5.1.1 lru与dirty list
5.1.2 cache buffers lru chain闩锁竞争与解决
5.1.3 cache buffer chain闩锁竞争与解决
5.2 shared pool的基本原理
5.2.1 shared pool的设置说明
5.2.2了解x$ksmsp视图
5.2.3	诊断和解决ora-04031错误
5.2.4 library cache pin及library cache lock分析
5.2.5诊断案例一：version_count过高造成的latch竞争解决
5.2.6诊断案例二：临时表引发的竞争
5.2.7小结
第6章 重做（redo）
6.1	redo的作用
6.2	redo的内容
6.3 产生多少redo
6.4 redo写的触发条件
6.4.1 每3秒钟超时（timeout）
6.4.2 阈值达到
6.4.3 用户提交
6.4.4 在dbwn写之前
6.5	redo log buffer的大小设置
6.6	commit做了什么
6.7日志的状态
6.8日志的块大小
6.9日志文件的大小
6.10 为什么热备份期间产生的redo要比正常的多
6.11 能否不生成redo
6.11.1 nologging对于数据库的影响
6.11.2 disable_logging对于数据库的影响
6.11.3 force logging-强制日志模式
6.12 redo故障的恢复
6.12.1 丢失非活动日志组的故障恢复
6.12.2 丢失活动或当前日志文件的恢复
6.13 诊断案例一：通过clear日志恢复数据库
6.14 诊断案例二：日志组过度激活的诊断
第7章 回滚与撤销
7.1 什么是回滚和撤消
7.2 回滚段存储的内容
7.3 并发控制和一致性读
7.4 回滚段的前世今生
7.5 回滚机制的深入研究
7.6 oracle 9i闪回查询的新特性
7.7 使用errorstack进行错误跟踪
7.8 oracle 10g闪回查询特性的增强
7.9 ora-01555错误
7.10 aum下如何重建undo表空间
7.11 诊断案例一：使用flashback query恢复误删除数据
7.12 诊断案例二：释放过度扩展的undo空间
7.13 特殊情况的恢复
7.14 数值在oracle的内部存储
第8章 等待事件
8.1 等待事件的源起
8.2 从等待发现瓶颈
8.2.1 v$session和v$session_wait
8.2.2 从v$sqltext中追踪
8.2.3 捕获相关sql
8.3 oracle 10g的增强
8.3.1 新增v$session_wait_history视图
8.3.2 ash新特性
8.3.3 自动负载信息库awr的引入
8.3.4 自动数据库诊断监控addm的引入
8.4 顶级等待事件
8.5 重要等待事件
8.5.1 db file sequential read（数据文件顺序读取）
8.5.2 db file scattered read（数据文件离散读取）
8.5.3 direct path read/write（直接路径读/写）
8.5.4 日志文件相关等待
8.5.5 enqueue（队列等待）
8.5.6 latch free（闩锁释放）
第9章 性能诊断与sql优化
9.1 使用autotrace功能辅助sql优化
9.1.1 autotrace功能的启用
9.1.2 oracle 10g autotrace功能的增强
9.1.3 autotrace功能的内部操作
9.1.4 使用autotrace功能辅助sql优化
9.2 捕获问题sql解决过度cpu消耗问题
9.2.1 使用vmstat检查系统当前情况
9.2.2 使用top工具辅助诊断
9.2.3 检查进程数量
9.2.4 登录数据库
9.2.5 捕获相关sql
9.2.6 创建新的索引以消除全表扫描
9.2.7 观察系统状况
9.2.8 性能何以提高
9.2.9 小结
9.3 使用sql_trace/10046事件进行数据库诊断
9.3.1 sql_trace及10046事件的基础介绍
9.3.2 诊断案例一：隐式转换与索引失效
9.3.3 诊断案例二：跟踪后台错误
9.3.4 10046与等待事件
9.4 使用物化视图进行翻页性能调整
9.4.1 系统环境
9.4.2 问题描述
9.4.3 捕获排序sql语句
9.4.4 确定典型问题sql
9.4.5 选择解决办法
9.4.6 进一步的调整优化
9.4.7 小结
9.5 一次横跨两岸的问题诊断
9.5.1 第一封求助邮件
9.5.2 第一次回复
9.5.3 进一步信息提供
9.5.4 进一步的诊断
9.5.5 最后的问题定位
9.5.6 小结
9.6 总结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入浅出Oracle
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>SQL案例解析
第1章  数据库的使用	1
1.1  什么是SQL	2
1.2  程序语言或数据库	3
1.3  SQL Server 概述	5
1.4  Oracle概述	7
第2章  SELECT查询语句	9
2.1  基本SELECT子句	10
2.2  字段选择(SELECT)	12
2.3  指定数据源(FROM)	14
2.4  指定查询限定条件(WHERE)	15
2.4.1  比较运算符	15
2.4.2  以逻辑运算符组合多个条件	17
2.4.3  列举项目(IN / NOT IN)	19
2.4.4  NULL选取	20
2.4.5  范围限制(BETWEEN...AND)	21
2.4.6  字符模糊匹配	22
2.5  查询结果的排序(ORDER BY)	23
2.6  数据分组(GROUP BY)	26
第3章  基本SQL用法	29
3.1  SQL编写风格	30
3.2  数据表连接的使用	33
3.2.1  内连接	34
3.2.2  外连接	37
3.2.3  交叉连接	39
3.3  子查询	41
3.3.1  嵌套子查询	42
3.3.2  相关子查询	43
3.4  集合的使用	45
3.4.1  并集(UNION)	47
3.4.2  交集(INTERSECT)	49
3.4.3  差集(MINUS)	49
3.5  CASE表达式	51
3.5.1  简单型CASE子句	51
3.5.2  搜索式CASE子句	52
3.6  HAVING子句的使用	55
3.7  DISTINCT语法的使用	57
3.8  特殊SQL排序法	59
3.8.1  CASE表达式	60
3.8.2  字符串位置函数(INSTR、CHARINDEX)	67
3.8.3  COUNT函数(聚合函数)	68
3.9  如何取得两数据集中非重复的数据	69
3.9.1  FULL OUTER JOIN	71
3.9.2  区域去除	72
3.10  如何避免除零错误(Avoid Diving by Zero)	76
第4章  数据变更处理	79
4.1  新增─INSERT	80
4.1.1  数据输入(INSERT...VALUES)	80
4.1.2  数据来自其他表(INSERT...SELECT)	82
4.2  序列值的使用	83
4.3  取得当前自动编号值	89
4.3.1  SCOPE_IDENTITY()	89
4.3.2  OUTPUT	91
4.3.3  RETURNING	92
4.4  更新数据─UPDATE	93
4.5  删除数据─DELETE	96
4.5.1  删除特定数据	96
4.5.2  使用连接删除数据(DELETE With JOIN)	97
4.5.3  删除重复的数据	98
4.5.4  删除大量数据	100
4.5.5  清空数据表(TRUNCATE TABLE)	101
第5章  数据类型	103
5.1  基本数据类型	104
5.1.1  字符类型	104
5.1.2  数值类型	106
5.1.3  日期类型	111
5.2  数据类型的选择	113
5.3  类型转换	115
5.4  NULL概述	116
第6章  字符串函数的使用	121
6.1  字符串函数介绍	123
6.1.1  字符串连接	123
6.1.2  截取子串	124
6.1.3  字符位置	127
6.1.4  获取字符串长度(字符个数)	128
6.1.5  删除空格(特定字符)	129
6.1.6  字符串替换	130
6.1.7  字符串填补	134
6.1.8  变换字符/字符ASCII码	135
6.1.9  变换大小写	136
6.2  字符串模糊比较	136
6.3  是否为数值字符串	141
6.4  中文字判断	143
6.5  筛选特定字符串前缀─以半导体实验生产批号为例	146
6.6  固定长度字符串─以特定字符补足长度	148
6.7  特定字符出现次数─以面板检测结果为例	149
第7章  日期函数的使用	155
7.1  格式转换	157
7.2  取得部分日期信息	161
7.3  日期运算的概念	164
7.4  日期加减运算	168
7.5  取得两个日期/时间的差	174
7.6  取得特定日期	176
7.7  找出下个周五	181
第8章  数值函数的使用	185
8.1  数值函数	186
8.1.1  余数(MOD)和商数	187
8.1.2  常用的数值运算函数	187
8.1.3  次方、平方根、自然对数、对数、EXP(e)	191
8.1.4  圆周率(PI)、三角函数(Sin、Cos、Tan)	192
8.2  转换函数	193
8.3  SQL Server数学运算时的注意事项	198
8.4  判断是否为整数─余数的应用	203
8.5  判断两个日期前后顺序─SIGN函数的应用	204
第9章  SQL用法进阶	207
9.1  数据行转置─Row To Column	210
9.1.1  通过SQL命令实现转置	210
9.1.2  使用PIVOT命令实现转置	214
9.2  数据列转置─Column To Row	220
9.3  员工专长明细	227
9.4  累计汇总	230
9.5  汇总数据	238
9.6  数据记录的排序——传回各种书籍订单订购数量排名	249
9.7  每个部门中薪水最高的员工	253
9.8  机群分组合并状态	257
9.9  个税计算	266
9.10  商品组合	270
9.11  求职网	279
9.12  Defect Overlap─缺陷重叠分析	284
9.13  职务代理关系表/系统异常处理人员顺序表	289
9.14  组织图─树型结构展开	294
第10章  日期区间报表	307
10.1  日报	309
10.1.1  日期类型	309
10.1.2  字符类型	312
10.2  月报	314
10.2.1  日期类型	314
10.2.2  字符类型	317
10.3  周报	318
10.3.1  周的特殊定义	319
10.3.2  运算差异分析	321
10.4  小时区间报表	323
10.4.1  3小时区间报表	324
10.4.2  5小时区间报表	328
10.4.3  利用序列产生报表	332
10.5  科学园区四二轮报表	334
10.5.1  四二轮报表－日报	337
10.5.2  四二轮报表－月报	340
10.5.3  四二轮报表－周报	345
10.5.4  综合日期报表	349
10.6  完整日期区间报表	361
10.6.1  完整日期报表－未转置	362
10.6.2  完整日期报表－以产品转置	365
10.6.3  完整日期报表－以日期转置	368
第11章  存储过程	371
11.1　存储过程	373
11.1.1　程序	373
11.1.2  函数	377
11.1.3　错误来源	380
11.1.4  加密	381
11.2　触发器	383
11.3  游标的使用	394
11.4  程序包	403
11.5  用户自定义聚合函数	407
第12章  异质数据源	421
12.1　分布式查询─Database Link	422
12.2  SQL Server串联其他数据源	438
12.2.1  查询	439
12.2.2  INSERT / UPDATE	441
12.2.3  对象及查询命令的差异	441
12.2.4  结合异质数据	443
12.3  SQL*Loader(SQLLDR)	446
第13章  特殊应用	453
13.1  Oracle CONNECT BY命令特殊应用	454
13.1.1  序列产生	455
13.1.2  Column To Row(UNPIVOT)	456
13.1.3  分组字符串合并	458
13.1.4  解析CSV字符串	461
13.2  通用表表达式的使用─CTE	462
13.2.1  非递归的运用─查询暂存	463
13.2.2  递归的运用	464
13.3  序列数据表的应用	468
13.4  随机数	469
13.5  IN-LIST的使用	475
13.6  制程能力指标	478
13.7  系统数据表的使用	482
13.8  在SQL Server中进行字符串分组串联─FOR XML应用	486
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>SQL案例解析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Oracle PL/SQL
第1章 高效能的PL/SQL
1.1 为何使用PL/SQL
1.1.1 PL/SQL贴近数据
1.1.2 最简单的通常是最好的
1.2 什么是高效能的PL/SQL
1.2.1 性能
1.2.2 影响
1.2.3 可论证性
1.3 达到高效能
1.3.1 绑定变量和解析的代价
1.3.2 使用PL/SQL的可用特性
1.3.3 不要使用PL/SQL来做SQL的工作
1.4 小结
第2章 全部打包
2.1 包的基本好处
2.1.1 包的重载
2.1.2 包中的公有变量和私有变量
2.1.3 初始化
2.1.4 信息隐藏
2.2 独立的过程和依赖危机
2.3 打破依赖链
2.4 使用递归
2.5 人们为何避而不用包
2.5.1 忽视分离的好处
2.5.2 这是个包，不是库
2.6 何时不能使用包
2.7 发布包
2.7.1 路径跟踪编程变得简单
2.7.2 其他有用的例程
2.7.3 检索DDL
2.7.4 DBMS_ROWID的有趣应用
2.7.5 后台任务
2.8 小结
第3章 令人困惑的游标
3.1 显式游标与隐式游标
3.1.1 单行的读取
3.1.2 多行处理
3.1.3 TOP-N处理
3.1.4 结论
3.2 跨架构的游标管理
3.2.1 游标变量
3.2.2 游标表达式
3.3 小结
第4章 高效数据处理
4.1 控制数据类型
4.1.1 使用%TYPE属性
4.1.2 使用包集中控制数据类型
4.1.3 避免隐式数据类型转换
4.2 从字段到行——使用%ROWTYPE
4.3 从记录到对象
4.3.1 对象类型
4.3.2 用集合扩展runstats
4.4 在PL/SQL中使用集合的动机
4.5 用集合来批处理
4.5.1 批收集
4.5.2 批量绑定
4.6 在PL/SQL程序间传递变量
4.6.1 将%TYPE和%ROWTYPE作为参数传递
4.6.2 将集合作为参数传递
4.7 PL/SQL中的事务处理
4.8 自治事务
4.8.1 在触发器中避免变异表错误
4.8.2 作为事务的一部分执行DDL
4.8.3 审计SELECT语句
4.8.4 回滚后保持审计
4.9 小结
第5章 PL/SQL优化技巧
5.1 尽量减少解析和内存消耗
5.1.1 触发器内的代码
5.1.2 调用者权限过程
5.1.3 解放思想：使用管道函数
5.2 数据类型：提示和技巧
5.2.1 关联数组
5.2.2 集合
5.2.3 使用基于记录的DML时的问题
5.3 调用PL/SQL
5.3.1 使用PL/SQL来显露数据模型，而不是扩展它
5.3.2 动态调用PL/SQL
5.4 PL/SQL中的SQL
5.4.1 SQL函数和递归SQL
5.4.2 高效的动态SQL
5.5 小结
第6章 触发器
6.1 触发器概念
6.1.1 触发器类型
6.1.2 事件属性
6.1.3 触发器计时
6.1.4 多个相似的触发器
6.1.5 DML行前与行后触发器的性能
6.1.6 权限
6.1.7 触发器和数据字典
6.1.8 触发器依赖性
6.1.9 触发器状态
6.1.10 触发器失败
6.1.11 触发器的局限性
6.2 DML触发器
6.2.1 存储审计信息
6.2.2 实现转变约束
6.2.3 生成代理键
6.3 替代触发器
6.4 变异表
6.4.1 延时处理方案
6.4.2 变异表和自治事务
6.4.3 其他变异表错误
6.5 数据审计
6.6 表的多版本
6.7 Oracle流
6.8 作业队列(临时事件触发器)
6.8.1 作业调度
6.8.2 作业和DML触发器
6.8.3 作业与共享池
6.8.4 作业错误
6.9 DDL触发器
6.9.1 DDL完整性触发器
6.9.2 DDL审计跟踪
6.10 数据库事件触发器
6.11 登录触发器
6.11.1 服务器错误触发器
6.11.2 挂起事件触发器
6.11.3 错误和数据库事件触发器
6.12 别“重造轮子”
6.13 小结
第7章 DBA包
7.1 警告文件包
7.1.1 包结构
7.1.2 警告文件的结构
7.1.3 警告文件作为外部表
7.1.4 处理警告文件
7.1.5 异常
7.1.6 通知的生命周期
7.1.7 更替警告文件
7.1.8 调度和并发
7.1.9 使用警告文件的警告
7.1.10 回顾警告文件的内容
7.1.11 小结
7.2 通知包
7.2.1 SEND_EMAIL过程
7.2.2 在数据库中保存警告消息
7.2.3 小结
7.3 主动监控包
7.3.1 备份
7.3.2 归档日志目录下的空闲空间
7.3.3 监控数据库中的空闲空间
7.3.4 小结
7.4 历史数据包
7.4.1 数据库大小
7.4.2 数据库会话
7.4.3 资源限制
7.4.4 小结
7.5 小结
第8章 安全包
8.1 设计问题
8.1.1 回顾定义者和调用者权限
8.1.2 包的构建
8.1.3 模式，到处都是模式
8.1.4 代码发布
8.2 触发器与安全因素
8.2.1 安全检查
8.2.2 登录触发器：第一道防线
8.3 保护源代码
8.3.1 查看过程和函数的源代码
8.3.2 包的源代码
8.3.3 PL/SQL封装工具
8.4 小结
第9章 Web包
9.1 PL/SQL Web工具包基础
9.1.1 架构
9.1.2 包的汇总
9.1.3 从SQL*Plus测试工具包
9.2 HTP和HTF包
9.3 使用环境变量
9.4 cookie
9.5 管理文件
9.6 通过Web管理表
9.7 来自数据库的HTTP
9.7.1 提取HTML
9.7.2 使用UTL_HTTP的Web服务客户端
9.8 小结
第10章 PL/SQL调试
10.1 防卫型的编码
10.1.1 异常
10.1.2 装备你的代码
10.1.3 写文档
10.2 工具
10.2.1 DBMS_OUTPUT
10.2.2 SQLCODE和SQLERRM
10.2.3 DBMS_UTILITY.FORMAT_CALL_STACK
10.2.4 DBMS_APPLICATION_INFO
10.2.5 自治事务
10.2.6 UTL_FILE
10.2.7 用管道函数实时调试
10.3 自定义BEBUG工具
10.3.1 需求
10.3.2 数据库设计和安装
10.3.3 包的布局
10.3.4 实现
10.3.5 基本操作
10.3.6 使用STATUS
10.3.7 有选择的调试
10.3.8 调试成品代码
10.3.9 DEBUG的用处
10.4 小结
附录A 构建DEBUG
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Oracle PL/SQL
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle9i参考手册（附1光盘）
第一部分  关键数据库概念
第二部分  SQL和SQL*PLUS
第三部分  PL/SQL
第四部分  对象关系数据库
第五部分  ORACLE中的JAVA
第六部分  附加的指南
第七部分  附录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle9i参考手册（附1光盘）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 10g数据库管理艺术
第一部分　背景知识、数据建模和unix/linux
第1章　oracle dba的世界
第2章　关系数据库建模及数据库设计
第3章　oracle dba的unix/linux基础
第二部分　oracle 10g的体系结构、模式和事务管理
第4章　oracle 10g体系结构介绍
第5章　模式管理
第6章　oracle事务管理
第三部分　安装oracle 10g，创建和升级数据库
第7章　安装oracle 10g rdbms
第8章　升级到oracle 10g
第9章　创建oracle数据库
第四部分　连接和用户管理
第10章　连接和网络
第11章　用户管理和数据库安全
第12章　使用sql*plus及isql*plus
第五部分　数据装载、备份和恢复
第13章　装载和转换数据
第14章　使用数据泵取导出和导入
第15章　备份数据库
. 第16章　数据库恢复
第六部分　管理运行中的oracle数据库
第17章　自动管理和联机功能
第18章　管理和监控运行中的数据库
第19章　使用oracle企业管理器
第20章　在windows和linux系统上管理oracle数据库
第七部分　性能调整
第21章　改进数据库性能：sql查询优化
第22章　性能调整：调整实例
第八部分　数据字典、动态视图和oracle提供的程序包
第23章　oracle数据字典和动态性能视图
第24章　使用oracle pl/sql程序包
附录a　oracle 10g sql和pl/sql：简明读本
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 10g数据库管理艺术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle优化日记
5月11日 出发 1
今日点评　　　　4
优化小技巧 性能优化项目 4
优化小技巧 优化常用知识1：诊断事件 6
5月12日 开始工作和CPU瓶颈 8
今日点评 11
优化小技巧 数据库优化的步骤 13
优化小技巧 按部就班是成功的关键 14
优化小技巧 优化常用知识2：常用诊断事件清单 15
5月13日 联席会议 20
今日点评　　　　22
优化小技巧 优化流程 23
优化小技巧 转储文件内容1：数据文件 27
5月14日 聚会 28
优化小技巧 系统级优化 29
优化小技巧 转储文件内容2：转储对象的段头 30
5月15日 业务支撑系统出问题了 32
今日点评　　　　34
优化小技巧 索引监控 35
优化小技巧 性能优化时常用的工具 35
.优化小技巧 转储文件内容3：转储控制文件 38
5月18日 Top SQL 39
优化小技巧 查找Top SQL 41
优化小技巧 索引设计的一些建议 42
优化小技巧 什么是索引的集群因子 43
优化小技巧 转储文件内容4：转储控制文件 43
5月19日 南京的死锁问题 49
今日点评　　　　52
优化小技巧 Oracle的死锁 53
优化小技巧 几个常用的与锁相关的脚本 54
5月20日 凌晨的邮件通知短信 61
今日点评　　　　63
优化小技巧 10027/10028事件 63
优化小技巧 PL/SQL优化工具profiler 64
5月22日 ODS系统和RAC 65
优化小技巧 以开放的心态做服务 67
优化小技巧 全局热块冲突 68
优化小技巧 PL/SQL中数据类型的性能 68
5月23日 实时ODS 71
今日点评　　　　73
优化小技巧 ODS系统中Oracle数据库设计管理要点 74
优化小技巧 ODS系统中的开发要点 75
优化小技巧 集合类型的效率 76
5月24日 任务提前 78
今日点评　　　　80
优化小技巧 占位操作与开关操作 81
优化小技巧 优化计划调整 81
优化小技巧 自动段存储空间管理1 82
5月25日 倾斜的索引字段 83
优化小技巧 倾斜字段的处理 85
优化小技巧 自动段存储空间管理2 87
5月26日 优化方案 99
优化小技巧 优化中的排队效应 101
优化小技巧 DB Cache调整方案如何制订 102
优化小技巧 自动段存储空间管理3 103
5月27日 无奈 105
今日点评　　　　107
优化小技巧 临时表空间和排序 107
优化小技巧 undo表空间和回滚段 108
5月28日 BBED的妙用 110
今日点评　　　　113
优化小技巧 如何启用BBED 114
优化小技巧 模拟ORA-8102及处理过程 121
优化小技巧 如何计算数据块中某个字段的位置 122
优化小技巧 如何计算索引块中某个字段的位置 125
优化小技巧 自己动手写一个dul 126
优化小技巧 bootstrap$的访问 149
优化小技巧 unloadBlock函数 152
优化小技巧 unloadRow函数 154
5月29日 突破困局 159
优化小技巧 查找“热的”缓冲区的常用脚本 161
优化小技巧 什么时候需要使用多缓冲 163
优化小技巧 AIX操作系统优化要点 164
5月30日 账务处理 168
今日点评　　　　170
优化小技巧 表访问的方式 171
5月31日 电脑坏了 174
今日点评　　　　176
优化小技巧 通过OEM录像采集数据 177
优化小技巧 调整游标相关参数 178
6月1日 ORA-4030和内存泄漏 181
今日点评　　　　184
优化小技巧 如何分析ORA-4030 184
6月2日 优化方案 187
今日点评　　　　188
优化小技巧 一个提供参考的优化方案 189
优化小技巧 游标的共享 190
6月3日 拆分大型SQL 195
优化小技巧 拆分复杂SQL 197
6月4日 TNS-12535 199
今日点评　　　　200
优化小技巧 防火墙和SQL*Net 200
优化小技巧 跟踪SQL*Net 201
6月5日 休息时总是最忙的 203
今日点评　　　　205
优化小技巧 使用hanganalyze 205
优化小技巧 重做日志文件优化的要点 208
6月6日 实施优化 209
今日点评　　　　211
优化小技巧 升级维护窗口的确定 212
优化小技巧 回退预案的作用 212
6月7日 突发事件 214
今日点评　　　　216
优化小技巧 使用HINT优化SQL 216
6月10日 使用自动采样比例引发的故障 219
今日点评　　　　221
优化小技巧 关于表分析比例的判定 221
优化小技巧 AIX下使用vmstat分析I/O问题的小技巧 222
6月11日 阶段总结 224
今日点评　　　　225
优化小技巧 STATSPACK报告在优化项目中的作用 226
优化小技巧 STATSPACK报告头的解读 227
6月12日 阴谋 229
今日点评　　　　231
优化小技巧 分析STATSPACK的负载数据 232
优化小技巧 重要的命中率指标 233
6月13日 演戏 235
今日点评　　　　237
优化小技巧 Top 5事件 237
优化小技巧 常见事件清单 238
6月14日 转机 245
今日点评　　　　249
优化小技巧 STATSPACK报告分析之DB Cache1 249
优化小技巧 STATSPACK报告分析之PGA 251
6月15日 青岛 256
今日点评　　　　260
优化小技巧 如何优化闩锁 261
6月16日 SQL优化效果 264
今日点评　　　　267
优化小技巧 如何转储数据块 268
优化小技巧 通过树转储来分析索引碎片 270
6月17日 完美的效果 279
今日点评　　　　281
优化小技巧 I/O系统优化的经验与体会 281
优化小技巧 STATSPACK报告之I/O 问题分析 285
6月18日 准备收工 287
优化小技巧 STATSPACK报告分析之DB Cache2 288
6月19日 ORA-1591 291
今日点评　　　　294
6月20日 好奇心惹的祸 297
优化小技巧 STATSPACK报告分析之共享池分析 298
7月20日 重回沈阳 302
优化小技巧 如何评估优化效果 304
优化小技巧 STATSPACK报告分析之undo分析 306
优化小技巧 STATSPACK报告分析之锁分析 308
7月21日 课堂风波 314
优化小技巧 平均事务响应时间的计算 316
优化小技巧 STATSPACK报告分析之闩锁分析 317
7月22日 世博园一日游和心想事成 321
优化小技巧 STATSPACK报告分析之Top对象 323
优化小技巧 STATSPACK报告分析之Top SQL 326
7月23日 漫长的一夜 331
优化小技巧 本案例的启示 336
后记，也算结束语 337
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle优化日记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>临危不惧
第1章 重做日志（Redo Log）
1.1 功能介绍
1.2 重做记录
1.3 在线重做日志（Online Redo Log）
1.4 检查点
1.5 实例恢复
1.6 归档重做日志
1.7 介质恢复
1.8 本章小结

第2章 控制文件（Control File）
2.1 功能介绍
2.2 数据库标识符（DBID）
2.3 数据库物理结构
2.4 其他信息
2.5 本章小结
第3章 补充日志 （Supplemental Logging）
3.1 功能介绍
3.2 数据库级补充日志
3.2.1 最小补充日志
3.2.2 标识关键字段补充日志
3.3 表级补充日志
3.4 本章小结
第4章 恢复管理器（RMAN）
4.1 RMAN体系结构
4.2 快速恢复区
4.2.1 概念
4.2.2 配置与监控
4.3 通道分配
4.3.1 工作原理
4.3.2 自动分配通道
4.3.3 手动分配通道
4.4 备份集备份
4.4.1 创建备份集
4.4.2 数据文件增量备份
4.5 镜像复制备份
4.6 RMAN备份的优化
4.6.1 备份集优化
4.6.2 镜像复制优化
4.7 安全性
4.8 监控
4.9 备份保留策略
4.10 RMAN资料库
4.11 本章小结
第5章 恢复编录（Recovery Catalog）
5.1 使用编录的原因
5.2 创建编录
5.3 使用编录
5.3.1 注册与同步
5.3.2 RMAN能力的增强
5.4 本章小结
第6章 数据泵（Data Pump）
6.1 目录对象
6.2 导出
6.3 导入
6.4 可传输表空间
6.5 本章小结
第7章 参数文件的备份与还原
7.1 参数文件损坏的后果
7.2 备份
7.2.1 手动备份
7.2.2 自动备份
7.3 恢复
7.3.1 实例启动时发现损坏
7.3.2 实例运行时发现损坏
7.4 本章小结
第8章 控制文件备份与恢复
8.1 控制文件损坏的后果
8.1.1 实例启动时发现损坏
8.1.2 实例运行时发现损坏
8.2 备份控制文件
8.2.1 在线镜像备份
8.2.2 自动备份
8.2.3 手动备份
8.3 恢复控制文件
8.3.1 控制文件备份的时间跨度分类
8.3.2 恢复前的准备
8.3.3 利用在线镜像备份恢复
8.3.4 利用自动备份恢复
8.3.5 利用手动备份恢复
8.3.6 利用历史备份恢复
8.3.7 缺失归档日志情况下的恢复
8.4 以noresetlogs收尾
8.5 本章小结
第9章 关键数据文件备份与恢复
9.1 关键数据文件损坏的后果
9.1.1 SYSTEM表空间数据文件损坏
9.1.2 undo_tablespace数据文件损坏
9.2 备份
9.3 恢复
9.3.1 恢复前的准备
9.3.2 恢复流程
9.4 本章小结
第10章 普通数据文件备份与恢复
10.1 普通数据文件损坏的后果
10.2 备份
10.3 恢复
10.3.1 恢复前的准备
10.3.2 非文件头部损坏后的恢复
10.3.3 文件头部损坏后的恢复
10.4 本章小结
第11章 只读数据文件备份与恢复
11.1 只读数据文件损坏的后果
11.2 备份
11.3 恢复
11.3.1 恢复前的准备
11.3.2 控制文件无损情况下的恢复
11.4 本章小结
第12章 不完全数据库恢复
12.1 工作原理
12.2 被动恢复
12.3 主动恢复
12.4 数据库的化身——Incarnation
12.5 小范围不完全恢复
12.6 本章小结
第13章 无备份情况下的恢复
13.1 恢复密码文件
13.2 恢复参数文件
13.3 无备份恢复控制文件
13.3.1 在线日志无损情况下的重建
13.3.2 在线日志损坏情况下的重建
13.3.3 具有只读数据文件情况下的重建
13.3.4 使用控制文件快照恢复
13.4 恢复数据文件
13.5 恢复临时文件
13.6 恢复在线重做日志
13.7 本章小结
第14章 闪回技术（Flashback）
14.1 闪回查询（Flashback Query）
14.1.1 闪回时间点查询246
14.1.2 闪回版本查询248
14.2 闪回数据归档（Flashback Data Archive）
14.3 闪回事务查询
14.4 闪回事务（Flashback Transaction）
14.5 闪回表（Flashback Table）
14.6 闪回删表（Flashback Drop）
14.7 闪回数据库
14.8 本章小结
第15章 恢复受损的数据块
15.1 示例表物理结构
15.2 数据块完整性定义
15.3 数据块完整性检查
15.3.1 db_block_checking参数
15.3.2 db_block_checksum参数
15.3.3 dbv命令
15.3.4 analyze命令
15.3.5 dbms_repair.check_object存储过程
15.3.6 dbms_hm.run_check存储过程
15.3.7 backup命令
15.4 恢复数据块
15.4.1 数据块级恢复
15.4.2 数据块修复包dbms_repair
15.5 本章小结
第16章 日志挖掘器（LogMiner）
16.1 v$logmnr_contents视图
16.2 使用LogMiner
16.2.1 启用最小补充日志
16.2.2 确定LogMiner字典的位置
16.2.3 注册重做日志
16.2.4 启动挖掘会话
16.2.5 挖掘
16.2.6 关闭挖掘会话
16.3 本章小结
第17章 总结
附录A 数据恢复顾问—— Data Recovery Advisor
附录B 示例数据库主要信息
附录C 测验
附录D 测验答案
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>临危不惧
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle高效设计
译者序
前言
第1章 构建应用程序的正确方法
1.1 团队协作
1.2 阅读资料文档
1.2.1 指南的指南
1.2.2 阅读路线
1.3 避免黑盒综合症
1.3.1 数据库独立与数据库依赖
1.3.2 黑盒综合症的危害
1.4 是数据库而不是一堆数据
1.4.1 使用主键和外部键
1.4.2 测试参考完整性的开销
1.4.3 中间层检查不是万能药
1.5 建立测试环境
1.5.1 用有代表性的数据进行测试
1.5.2 不要用单个用户进行测试
1.5.3 不要在无菌实验室中进行测试
1.6 设计出性能而不是调整出性能
1.6.1 不要使用通用数据模型
1.6.2 设计自己的高效数据模型
1.7 开始就定义性能目标
1.7.1 在清晰明确的标准下工作
1.7.2 随时收集并记录标准
1.7.3 别因为“所有人都知道你应该做”而做某件事情
1.8 测试.测试.再测试
1.8.1 小基准测试
1.8.2 大基准测试
1.9 仪表化系统
1.9.1 追踪asktom.oracle.com
1.9.2 远程调试仪表化
1.9.3 使用dbms_application_info
1.9.4 在pl／sql中使用debug.f
1.9.5 在应用系统中打开sql_trace
1.9.6 使用业内标准的api
1.9.7 建立自己的例程
1.9.8 审计不仅仅是个词
1.10 敢于怀疑权威
1.10.1 当心泛泛的“最好”
1.10.2 怀疑“法定”和“神话”
1.11 不要走捷径
1.12 保持简单
1.12.1 考虑备选方法
1.12.2 让数据库充分发挥自己的能力
1.13 使用已有的功能
1.13.1 我们听说x特性慢
1.13.2 我们听说x特性复杂
1.13.3 我们不想
1.13.4 我们以前不知道
1.13.5 我们希望数据库独立
1.14 本章小结
第2章 性能工具包
2.1 sql * plus
2.1.1 建立sql * plus
2.1.2 定制sql * plus环境
2.1.3 阅读文档
2.2 explain plan
2.2.1 设置explain plan
2.2.2 使用explain plan
2.2.3 如何阅读查询计划
2.2.4 避免explain plan陷阱
2.2.5 使用dbms_xplan和v$sql_plan
2.3 autotrace
2.3.1 建立autotrace
2.3.2 使用autotrace
2.3.3 格式化autotrace的输出
2.3.4 了解autotrace的输出
2.3.5 autotrace输出中感兴趣的内容
2.4 tkprof
2.4.1 启用tkprof
2.4.2 运行丁tkprof
2.4.3 读tkprof报告
2.4.4 各种群体对tkprof的使用
2.5 runstats
2.5.1 建立runstats
2.5.2 使用runstats
2.6 statspack
2.6.1 建立statspack
2.6.2 使用statspack
2.6.3 使用statspack易犯的错误
2.6.4 statspack概览
2.7 dbms_profiler
2.7.1 为什么要使用配置文件管理器
2.7.2 配置文件管理器的资源
2.8 jdeveloper(及调试)
2.9 本章小结
第3章 体系结构选择
3.1 了解共享服务器与专用服务器连接
3.1.1 专用服务器如何工作
3.1.2 共享服务器连接如何工作
3.1.3 关于共享服务器配置的常见错误观点
3.1.4 专用服务器与共享服务器小结
3.2 利用集群
3.2.1 rac如何工作
3.2.2 rac的优点
3.2.3 集群小结
3.3 了解何时使用分区
3.3.1 分区概念
3.3.2 神秘的分区
3.3.3 为什么使用分区
3.3.4 分区小结
3.4 知道何时使用并行操作
3.4.1 并行神话
3.4.2 并行管理
3.4.3 并行查询
3.4.4 并行dml
3.4.5 打造自己的并行
3.4.6 并行处理小结
3.5 本章小结
第4章 高效的管理
4.1 用spfile启动数据库
4.1.1 pfile的问题
4.1.2 spfile如何工作
4.1.3 让数据库使用spfile
4.1.4 保存系统参数的改动
4.1.5 pfile过时了吗
4.1.6 求助.我的spfile坏了.我不能启动了
4.1.7 spfile小结
4.2 让oracle来管理你的数据文件
4.2.1 何时使用omf
4.2.2 omf如何工作
4.2.3 omf小结
4.3 可靠的恢复
4.3.1 备份准则
4.3.2 备份和恢复小结
4.4 使用本地管理的表空间
4.4.1 为什么要废除dmt
4.4.2 在不知道对象会变得有多大时使用系统管理的lmt
4.4.3 在知道对象的最终尺寸时使用统一的区尺寸
4.4.4 关于lmt的某些忠告
4.4.5 lmt和dmt小结
4.5 让oracle管理你的段空间
4.5.1 理解可用列表和可用列表组
4.5.2 pctfree和pctused怎样控制可用列表
4.5.3 assm的案例
4.5.4 assm小结
4.6 让oracle管理回退段
4.6.1 设置undo retention
4.6.2 undo表空间忠告
4.6.3 undo表空间小结
4.7 本章小结..
第5章 语句处理
5.1 理解sql语句的类型
5.2 语句怎样执行
5.2.1 分析
5.2.2 优化和行资源生成
5.2.3 执行
5.2.4 语句执行小结
5.3 查询的处理过程
5.3.1 快速返回的查询
5.3.2 慢速返回的查询
5.3.3 一致性读取
5.4 dml语句的处理
5.5 ddl处理
5.6 使用绑定变量
5.6.1 绑定变量的优点
5.6.2 对java和vb使用绑定变量
5.6.3 每项规则都有例外
5.6.4 绑定变量窥视
5.7 尽可能少做分析
5.7.1 分析的成本
5.7.2 使用pl／sql减少分析
5.7.3 把sql移出触发器以减少分析
5.7.4 准备一次；执行多次
5.8 本章小结
第6章 从基于成本的优化程序获得最大输出
6.1 为什么停用rbo
6.2 使cbo发挥最大的作用
6.2.1 调整optimizer_index_caching和optimizer_index_cost_adj参数
6.2.2 使用system统计数据
6.3 优化cbo
6.3.1 为升级设置compatible
6.3.2 设置db_file_multiblock_read_count以减少全扫描的成本
6.3.3 设置hash_join_enabled控制散列连接
6.3.4 设置optimizer_dynamic_sampling动态收集统计数据
6.3.5 设置offimizer_features_enable控制特性选择
6.3.6 设置optimizer_max_permutations控制排列
6.3.7 设置optimizer_mode选择模式
6.3.8 用query_rewrite_enabled和query_rewrite_integrityt重写查询
6.3.9 用bitmap_merge_area_size、sort_area_size、hash_area_size控制pga内存
6.3.10 对星查询使用star_transformation_enabled
6.3.11 设置影响优化程序的其他几个参数
6.4 使用10 053事件跟踪cbo选择
6.5 本章小结
第7章 高效的模式设计
7.1 基本模式设计原则
7.1.1 让数据库实现数据完整性
7.1.2 使用正确的数据类型
7.1.3 对最经常提的问题进行优化
7.2 表类型概述
7.3 b*树索引集群表
7.3.1 创建群
7.3.2 使用群
7.3.3 群小结
7.4 索引组织表
7.4.1 用iot替代关联表以节省空间
7.4.2 利用iot集中放置随机插入的数据
7.4.3 iot小结
7.5 外部表
7.5.1 建立外部表
7.5.2 修改外部表
7.5.3 将外部表用于直接路径装载
7.5.4 将外部表用于并行直接路径装载
7.5.5 将外部表用于合并
7.5.6 处理外部表的错误
7.6 索引技术
7.6.1 使用fbi——打破常规
7.6.2 使用域索引
7.7 压缩
7.7.1 使用索引键压缩
7.7.2 对于只读或主要是读的表进行压缩
7.7.3 压缩小结
7.8 本章小结
第8章 高效的sql
8.1 编写高效sql所需的知识
8.2 访问路径
8.2.1 全扫描
8.2.2 rowid访问
8.2.3 索引扫描
8.2.4 群扫描
8.3 连接概念
8.3.1 嵌套循环
8.3.2 散列连接
8.3.3 排序合并连接
8.3.4 笛卡儿连接
8.3.5 反连接
8.3.6 全外部连接
8.4 模式问题(物理的)
8.5 真正理解sql
8.5.1 rownum伪列
8.5.2 标量子查询
8.5.3 分析函数
8.6 不调整查询
8.6.1 理解问题
8.6.2 概念验证的例子
8.7 其他sql技术概览
8.8 本章小结
第9章 高效的pl／sql程序设计
9.1 为什么要使用pl／sql
9.1.1 pl／sql是数据操纵的最高效语言
9.1.2 pl／sql。具有可移植性和可重用性
9.2 尽可能少地编写代码
9.2.1 不用程序实现
9.2.2 让代码行数适合于屏幕显示
9.3 使用程序包
9.3.1 程序包的优点
9.3.2 断开依赖链
9.3.3 程序包小结
9.4 使用静态sql
9.4.1 静态sql的优点
9.4.2 寻找替换动态sql的机会
9.4.3 静态sql小结
9.5 批量处理
9.5.1 使用批量处理效果很好时再使用它
9.5.2 对etl操作使用bulk处理
9.5.3 批量处理小结
9.6 返回数据
9.6.1 ref游标的优点
9.6.2 使用ref游标返回结果集
9.7 使用％type和％rowtype
9.7.1 基于表的记录类型
9.7.2 基于游标的记录类型
9.7.3 基于列的数据类型
9.8 使用调用者的权限
9.8.1 调用者权限和多模式
9.8.2 调用者权限的条件
9.9 使查找高效地工作
9.9.1 查找的单行取
9.9.2 查找的批量处理
9.9.3 查找的单语句操作
9.9.4 查找小结
9.10 当心独立事务处理
9.10.1 独立事务处理的条件
9.10.2 独立事务处理会影响数据完整性
9.11 选择使用隐式游标还是显式游标
9.11.1 将隐式游标用于单行选择
9.11.2 对有限行数的结果集使用隐式游标
9.11.3 隐式／显式游标小结
9.12 本章小结
第10章 故障排除
10.1 找出差异
10.1.1 开始收集今天的历史记录
10.1.2 侦探性工作
10.2 一次只更改一样东西
10.3 更改一样东西要有充分理由
10.3.1 有目标
10.3.2 验证你的假设
10.4 能够恢复到更改前的状态
10.5 建立测试用例
10.5.1 测试用例需求
10.5.2 使测试用例尽可能小
10.6 本章小结
附录 设置和一些脚本
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle高效设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库性能优化
第一篇 优化工具篇
第 1 章 dba 优化之路
1.1 学习的建议
1.2 工具推荐
1.3 关于操作系统方面的建议
1.4 关于oracle初始化参数的调整
1.5 关于statspack的若干建议
1.6 关于logmnr在调优中的运用
1.7 关于materialized view在调优中的运用
.1.8 关于stored outline在sql优化中的运用
1.9 用dbms_profiler调优存储过程 8
1.10 优化前的准备工作
1.11 如何对sql进行调整及优化
1.12 表结构优化实例
1.13 如何对session进行跟踪
1.14 基于等待事件的性能诊断方法
1.15 基于资源限制的性能诊断方法
1.16 如何减少共享池的碎片
1.17 监控表及索引的意义
1.18 通过优化sql消除temp表空间膨胀
1.19 理解compress选项在优化上的作用 19
1.20 关于在线重定义table的建议
1.21 关于分区表在数据库设计时的建议
1.22 关于dataguard在高可用方面的建议 20
第 2 章 statspack 高级调整 23
2.1 statspack高级调整译文
2.1.1 top 5 wait events
2.1.2 等待时间快捷参考
2.2 关于latch
第 3 章 statspack 使用的几个误区
3.1 以命中率为主衡量性能问题
3.2 快照的采样时间间隔问题
3.3 以偏概全
3.4 关于timed_statistics参数的设定
3.5 你成了泄密者
第 4 章 tkprof 工具使用简介
4.1 tkprof工具简介
4.2 tkprof工具的使用步骤
4.3 tkprof工具如何分析trace文件 41
第 5 章 使用 oracle 的等待事件检测性能瓶颈
5.1 判断等待事件的相关视图
5.1.1 系统级统计信息v$system_event
5.1.2 会话级统计信息v$session_event
5.1.3 会话详细性能信息 v$session_wait
5.1.4 会话等待事件的相关视图之间的关系
5.2 应该怎么考虑进行优化
5.3 主要等待事件
5.4 案例分析
5.5 小结
5.6 附录
第 6 章 使用 sql_trace/10046 事件进行数据库诊断
6.1 sql_trace及10046事件的基础介绍
6.1.1 sql_trace说明
6.1.2 10046事件说明
6.1.3 获取跟踪文件
6.1.4 读取当前session设置的参数
6.2 案例分析之一
6.2.1 问题描述
6.2.2 检查并跟踪数据库进程
6.2.3 检查trace文件
6.2.4 登录数据库检查相应表结构
6.2.5 解决方法
6.2.6 小结
6.3 案例分析之二
6.3.1 问题描述
6.3.2 drop user出现问题
6.3.3 跟踪问题
6.3.4 问题定位
6.3.5 实际处理
6.3.6 小结
6.4 10046与等待事件
6.4.1 10046事件的使用
6.4.2 10046 与db_file_multiblock_read_count
6.4.3 10046与执行计划的选择
6.4.4 db_file_multiblock_read_count与系统的io能力
6.4.5 小结
第二篇 存储优化篇
第 7 章 表空间的存储管理与优化技术
7.1 表空间的作用与分类
7.2 字典管理表空间
7.2.1 字典管理表空间的特性
7.2.2 字典管理表空间的缺点
7.2.3 字典管理表空间的优化
7.3 本地管理表空间
7.3.1 本地管理表空间的特性
7.3.2 管理位图块的内部结构
7.3.3 本地管理表空间的优点
7.4 段自动管理表空间
7.4.1 段自动管理表空间的特性
7.4.2 位图管理段内部结构
7.4.3 段自动管理表空间的优化
7.5 9i对表空间的管理优化
7.5.1 自动undo管理的表空间
7.5.2 完全本地的临时表空间
7.6 oracle 10g对表空间的优化
7.7 小结
7.8 附录
第 8 章 关于 oracle 数据库中行迁移 / 行链接的问题
8.1 行迁移/行链接的简介
8.2 行迁移/行链接的检测方法
8.3 行迁移/行链接的清除方法
第 9 章 hwm 与数据库性能的探讨
9.1 什么是hwm
9.2 初始创建的table中hwm的不同情况 122
9.3 insert数据时hwm的移动
9.4 hwm对性能的影响
9.5 何时应该降低hwm
9.5.1 对于lmt下的flm
9.5.2 对于assm
9.6 如何降低hwm
9.6.1 move
9.6.2 dbms_redefinition
9.6.3 shrink
9.6.4 小结
9.7 其他几种会移动hwm的操作
9.7.1 insert append
9.7.2 truncate
第 10 章 调整 i/o 相关的等待
10.1 oracle数据库i/o相关竞争等待简介 153
10.2 oracle数据库i/o相关竞争等待的处理方法
10.3 oracle数据库i/o相关的等待事件和相应的解决方法
10.3.1 数据文件相关的i/o等待事件
10.3.2 控制文件相关i/o等待事件
10.3.3 重做日志文件相关的等待事件
10.3.4 高速缓存区相关的i/o等待事件
10.4 小结
第 11 章 oracle 在 solaris 的 vxfs 上的异步 i/o 问题
11.1 vxfs文件系统的简介
11.2 vxfs文件系统上如何启用异步i/o
11.3 如何检测在vxfs文件系统上是否支持异步i/o
11.4 如何查看vxfs文件系统上异步i/o的性能 173
11.5 如何转换vxfs文件系统上数据文件为支持异步i/o的
数据文件
第 12 章 关于 freelists 和 freelist groups 的研究
12.1 什么是freelists
12.2 freelists是否已经过时
12.3 freelists存储在哪里
12.4 有多少种free list
12.5 进程请求空闲块的过程
12.6 块在free list间的移动
12.7 关于free list将导致大量空间浪费的误解
12.8 对于freelists和freelist groups的一个比喻
12.9 与freelists和freelist groups相关的等待事件
第三篇 内存调整篇
第 13 章 自动 pga 管理──原理及优化
13.1 什么是pga内存自动管理
13.2 pga advice功能
13.3 自动pga内存管理相关初始化参数
第 14 章 32bit oracle sga 扩展原理和 sga 与 pga 的制约
关系
14.1 如何识别32bit的oracle
14.2 为何存在1.7gb的限制
14.3 32bit下sga与pga之间的制约关系 207
第 15 章 keep 池和 recycle 池
15.1 oracle的数据缓冲池
15.2 keep池和recycle池
15.2.1 keep池
15.2.2 recycle池
15.3 小结
第 16 章 深度分析数据库的热点块问题
16.1 热点块的定义
16.2 数据缓冲区的结构
16.3 如何确定热点对象
16.4 热点问题的解决
16.5 热点块的其他相关症状
16.6 小结
第 17 章 shared pool 原理及性能分析
17.1 shared pool的基本原理
17.2 shared pool的设置说明
17.2.1 基本知识
17.2.2 shared pool的free list管理
17.2.3 了解x$ksmsp视图
17.3 诊断和解决ora-04031错误
17.3.1 什么是ora-04031错误
17.3.2 内存泄露
17.3.3 绑定变量和cursor_sharing
17.3.4 使用flush shared pool缓解共享池问题
17.3.5 shared_pool_reserved_size参数的设置及作用
17.3.6 其他
17.3.7 模拟ora-04031错误
17.4 library cache pin及library cache lock分析
17.4.1 library cache pin等待事件
17.4.2 library cache lock等待事件
17.5 诊断案例一
17.6 诊断案例二
17.7 小结
第四篇 诊断案例篇
第 18 章 一次性能调整过程总结
18.1 系统环境
18.2 基本的调优过程
18.2.1 db file scattered read
18.2.2 db file sequential read
18.2.3 enqueue
18.2.4 latch free
18.3 小结
第 19 章 电信业 oracle 优化手记
19.1 一条sql语句要运行2年怎么办
19.2 优化的传统定律和新时尚
19.2.1 index和表同一个表空间（过时）
19.2.2 定期重建索引（过时）
19.2.3 裸设备应该取代文件系统（过时）
19.2.4 初始参数设置cursor_sharing = similar（不一定
有效）
19.2.5 初始参数设置fast = true（有效） 289
19.3 联机重做日志的优化
19.3.1 联机重做日志组内创建多个成员
19.3.2 加大redo log的容量
第 20 章 一次诊断和解决 cpu 利用率高的问题分析
20.1 问题的具体描述
20.2 问题的详细诊断解决过程
20.3 小结
第 21 章 一次异常内存消耗问题的诊断及解决
21.1 问题发现
21.2 解决过程
21.2.1 环境介绍
21.2.2 问题现象
21.2.3 对比分析
21.2.4 假设和分析
21.2.5 找到根源
21.2.6 解决问题
21.3 小结
第 22 章 如何捕获问题 sql 解决过度 cpu 消耗问题
22.1 检查当前情况
22.2 使用top工具辅助诊断
22.3 检查进程数量
22.4 登录数据库
22.5 捕获相关sql
22.6 创建新的索引以消除全表扫描
22.7 观察系统状况
22.8 性能何以提高
22.9 小结
第 23 章 一条 sql 导致数据库整体性能下降的诊断及解决
23.1 现象
23.2 诊断与解决
第 24 章 library cache lock 成因和解决方法的探讨
24.1 几个相关的概念
24.1.1 什么是库高速缓存（library cache）
24.1.2 一个sql语句的处理流程
24.1.3 硬分析（hard parse）
24.1.4 软分析（soft parse）
24.1.5 分析树
24.1.6 执行计划
24.2 了解library cache lock 329
24.2.1 几种容易引起library cache lock的情况
24.2.2 几种防患的方法
24.3 解决问题的方法
24.3.1 使用x$kgllk和systemstate事件解决问题
24.3.2 使用v$session和systemstate事件解决问题
24.4 小结
第五篇 sql优化及其他
第 25 章 oracle 数据库优化之索引（ index ）简介
25.1 索引的作用
25.2 索引管理的常见问题
25.3 索引的管理
25.4 一些索引管理的脚本
第 26 章 cbo 成本计算初探
26.1 建立测试数据
26.2 cbo计算成本原理初探
26.3 初始化参数以及优化器模式对执行计划的影响 371
26.3.1 初始化参数db_file_multiblock_read_count
26.3.2 初始化参数optimizer_index_cost_adj
26.3.3 优化器模式first_rows对执行计划的影响
26.4 小结
第 27 章 bitmap 索引
27.1 bitmap索引的概念
27.2 建立测试例子
27.3 bitmap索引的特点
27.3.1 bitmap索引比b树索引要节省空间
27.3.2 bitmap索引建立的速度比较快
27.3.3 基于规则的优化器无法使用bitmap索引 382
27.3.4 bitmap索引存储null值
27.3.5 通过bitmap索引访问表记录
27.3.6 bitmap索引对批量dml操作只需要索引一次
27.3.7 bitmap索引的锁机制
27.4 bitmap索引的适用范围
27.5 bitmap索引的使用限制
27.6 bitmap join索引简介
第 28 章 翻页 sql 优化实例
28.1 系统环境
28.2 优化效果
第 29 章 使用物化视图进行翻页性能调整
29.1 系统环境
29.2 问题描述
29.3 捕获排序sql语句
29.4 确定典型问题sql
29.5 选择解决办法
29.6 进一步的调整优化
29.7 小结
第 30 章 如何给 large delete 操作提速近千倍
30.1 背景描述
30.1.1 任务描述
30.1.2 数量级统计和描述
30.2 背景知识——bulk binding
30.2.1 什么是bulk binding
30.2.2 bulk binding的优点是什么
30.2.3 如何进行批量绑定（bulk binds） 415
30.3 优化过程详解
30.3.1 第一次优化——处理庞大的in-list操作 420
30.3.2 第二次优化 —— 分段操作
30.3.3 第三次优化 —— 拆分 delete操作
30.3.4 第四次优化——使用forall处理批量作业 424
30.3.5 第五次优化——使用forall ＋ 原子级操作
30.4 小结
第 31 章 web 分页与优化技术 431
31.1 什么是web分页
31.2 表数据普通查询分页
31.3 first_rows对分页的影响
31.4 带排序需求的分页
31.5 分页的速度优化
31.6 分页中的注意事项
31.6.1 真实案例──表中存在union all的视图时，可能
选择错误的执行计划
31.6.2 真实案例──rowid分页中，执行计划的错误选
择与处理
31.6.3 真实案例──使用rownum得到意想不到的结果
31.7 小结
第 32 章 oracle 数据封锁机制研究 457
32.1 数据库锁的基本概念
32.2 oracle多粒度封锁机制介绍
32.2.1 oracle的tx锁（事务锁、行级锁）
32.2.2 tm锁（表级锁）
32.3 oracle 多粒度封锁机制的监控
32.3.1 系统视图介绍
32.3.2 监控脚本
32.4 oracle 多粒度封锁机制示例
32.4.1 操作同一行数据引发的锁阻塞
32.4.2 实体完整性引发的锁阻塞
32.4.3 参照完整性引发的锁阻塞
32.4.4 外键未加索引引发的锁阻塞
32.4.5 部分回滚对锁的影响
32.4.6 锁的排队机制
32.4.7 itl slot不足引发的锁阻塞
32.4.8 bitmap索引引发的锁阻塞
32.4.9 死锁分析
32.4.10 表级锁的使能
32.4.11 row_locking参数
32.5 oracle 多粒度封锁机制总结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库性能优化
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>让Oracle跑得更快
第1章 引起数据库性能问题的因素 1
1.1 软件设计对数据库的影响 1
1.1.1 软件架构设计对数据库性能的影响 1
1.1.2 软件代码的编写对数据库性能的影响 2
1.2 数据库的设计 8
1.2.1 OLTP数据库 9
1.2.2 OLAP数据库 10
1.3 数据库的硬件设计 14
1.3.1 存储容量 15
1.3.2 存储的物理设计 16
1.3.3 数据的安全 17
1.4 小结 19
第2章 锁和阻塞 20
2.1 关于锁 20
2.2 锁和阻塞 22
2.3 引起阻塞的其他情况 30
2.3.1 select for update 30
2.3.2 外键和索引 36
第3章 Latch和等待 44
3.1 共享池中的Latch争用 45
.3.2 数据缓冲池Latch争用 54
3.2.1 表数据块 54
3.2.2 索引数据块 59
3.2.3 索引根数据块 62
3.2.4 段头数据块 65
第4章 优化器 66
4.1 RBO基于规则的优化器 66
4.2 CBO基于成本的优化器 69
第5章 执行计划 85
5.1 Cardinality （基数） 85
5.2 SQL的执行计划 94
第6章 Hint 109
6.1 和优化器相关的Hint 115
6.1.1 all_rows和first_rows（CBO） 115
6.1.2 RULE Hint 117
6.2 访问路径相关的Hint 117
6.2.1 FULL Hint 118
6.2.2 INDEX Hint 118
6.2.3 NO_INDEX Hint 118
6.2.4 INDEX_DESC Hint 119
6.2.5 INDEX_COMBINE Hint 119
6.2.6 INDEX_FFS 119
6.2.7 INDEX_JOIN 120
6.2.8 INDEX_SS Hint 120
6.3 表关联顺序的Hint 125
6.3.1 LEADING Hint 125
6.3.2 ORDERED Hint 126
6.4 表关联操作的Hint 127
6.4.1 USE_HASH，USE_NL和USE_MERGE Hint 127
6.4.2 NO_USE_HASH Hint 132
6.4.3 NO_USE_MERGE Hint 133
6.4.4 NO_USE_NL Hint 133
6.5 并行执行相关的Hint 134
6.5.1 PARALLEL Hint 134
6.5.2 NO_PARALLEL Hint 134
6.6 其他方面的一些Hint 135
6.6.1 APPEND Hint 135
6.6.2 DYNAMIC_SAMPLING Hint 135
6.6.3 DRIVING_SITE Hint 136
6.6.4 CACHE Hint 136
6.7 小结 136
第7章 分析及动态采样 138
7.1 直方图 141
7.2 DBMS_STATS包 147
7.3 动态采样 176
7.3.1 什么是动态采样 176
7.3.2 动态采样的级别 182
7.3.3 什么时候使用动态采样？ 185
7.4 小结 185
第8章 并行执行 186
8.1 并行和OLAP系统 187
8.2 并行处理的机制 189
8.3 读懂一个并行处理的执行计划 191
8.4 一个很常见的并行执行等待事件 192
8.5 并行执行的适用范围 194
8.5.1 并行查询 194
8.5.2 并行DDL操作 195
8.5.3 并行DML操作 203
8.6 并行执行的设定 210
8.6.1 并行相关的初始化参数 210
8.6.2 并行度的设定 211
8.7 直接加载 213
8.7.1 直接加载和REDO 216
8.7.2 直接加载和索引 219
8.7.3 直接加载和并行 221
8.7.4 直接加载和SQL*LOADER 226
第9章 变量绑定 232
9.1 什么是变量绑定，为什么要做变量绑定 232
9.2 为什么说OLTP必须要求变量绑定而OLAP不应该绑定变量 241
9.3 bind peaking 248
第10章 SQL_TRACE和10046事件 254
10.1 SQL_TRACE 254
10.2 TKPROF工具 256
10.3 10046事件 268
第11章 10053事件 276
第12章 性能视图和性能参数 294
12.1 性能视图 294
12.1.1 V$SQL 295
12.1.2 V$SQL_SHARED_CURSOR 300
12.1.3 v$session 305
12.1.4 V$sessstat 309
12.1.5 V$session_wait 310
12.2 性能参数 312
12.2.1 Cursor_sharing 313
12.2.2 DB_FILE_MULTIBLOCK_READ_COUNT 328
12.2.3 PGA_AGGREGATE_TARGET和SGA_TARGET 334
12.2.4 OPTIMIZER_DYNAMIC_SAMPLING 334
第13章 性能报告 335
13.1 AWR性能报告 335
13.1.1 生成AWR性能报告 337
13.1.2 AWR性能报告分析 342
13.2 Statspack性能报告 386
13.2.1 Statspack的安装 386
13.2.2 Statspack性能采集 391
13.3 ASH性能报告 394
13.3.1 生成ASH性能报告 395
13.3.2 ASH性能报告分析 405
13.4 小结 416
附录A 常见的等待事件 417
后记 关于数据库的学习方法 434
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>让Oracle跑得更快
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 11g数据库管理艺术
第一部分 背景知识、数据建模、UNIX/Linux和SQL*Plus
第1章 Oracle DBA的世界 2
1.1 Oracle DBA的任务 2
1.1.1 DBA的安全任务 3
1.1.2 DBA的系统管理任务 3
1.1.3 DBA的数据库设计任务 5
1.2 不同的DBA工作分类 6
1.3 数据库的类型 6
1.3.1 联机事务处理和决策支持系统数据库 6
1.3.2 开发、测试和产品数据库 7
1.4 培训和认证 7
1.4.1 培训 7
1.4.2 认证 8
1.4.3 Oracle DBA的资源和组织 10
1.4.4 Oracle示例 11
1.4.5 Oracle数据库的两天DBA课程 11
1.4.6 Oracle MetaLink 11
1.4.7 Oracle Web Conference 12
1.5 普通Oracle DBA的日常工作 12
1.6 几点建议 12
1.6.1 知道何时寻求帮助 12
1.6.2 记住你并不孤单 13
1.6.3 站在全局看问题 13
1.6.4 首先是不要造成损害 13
第2章 关系数据库建模及数据库设计 14
2.1 关系数据库简介 14
2.2 关系数据库模型 15
2.2.1 数据库模式 15
2.2.2 关系代数 15
2.2.3 关系演算 16
2.2.4 SQL 16
2.3 关系数据库的生命周期 17
2.3.1 需求收集和分析 17
2.3.2 逻辑数据库设计 18
2.3.3 物理数据库设计 25
2.3.4 实现物理设计 27
2.4 反向设计数据库 28
2.5 对象-关系和对象数据库 28
2.5.1 关系模型 28
2.5.2 对象模型 28
2.5.3 对象-关系模型 29
2.5.4 半结构数据模型 30
第3章 Oracle DBA的UNIX/Linux基础 31
3.1 UNIX和Linux操作系统概述 31
3.1.1 UNIX 31
3.1.2 Linux 32
3.1.3 中档系统 32
3.2 理解UNIX shell 33
3.3 访问UNIX系统 33
3.4 基本UNIX命令概览 35
3.4.1 帮助信息：man命令 36
3.4.2 改变提示符 37
3.4.3 文件和目录的查找 37
3.4.4 命令输出的控制 38
3.4.5 显示文件的内容 38
3.4.6 比较文件 38
3.4.7 理解操作系统和Shell变量 38
3.4.8 UNIX中的输入和输出重定向 41
3.4.9 防止文件被覆盖 41
3.5 UNIX中文件和目录的浏览 42
3.5.1 UNIX系统中的文件 42
3.5.2 链接文件 42
3.5.3 管理文件 42
3.5.4 权限：读/写UNIX的文件 43
3.5.5 目录管理 45
3.6 用vi编辑器编写文件 46
3.6.1 利用vi创建和修改文件 46
3.6.2 用head和tail命令移动 47
3.7 文本的提取和排序 48
3.7.1 使用grep匹配模式 48
3.7.2 剪切、粘贴和联结文本 49
3.8 shell脚本 50
3.8.1 shell程序介绍 51
3.8.2 使用shell变量 51
3.8.3 用test命令求表达式的值 51
3.8.4 执行带命令行参数的shell程序 52
3.8.5 分析shell脚本 52
3.8.6 Korn shell编程中的流控制结构 53
3.9 管理UNIX进程 55
3.9.1 用ps命令收集进程信息 55
3.9.2 在注销后运行进程 56
3.9.3 在后台执行进程 56
3.9.4 用kill命令终止进程 56
3.10 UNIX系统管理和Oracle DBA 57
3.10.1 UNIX的备份和恢复实用程序 57
3.10.2 crontab和Automating脚本 57
3.10.3 使用telnet 58
3.10.4 远程登录和远程复制 59
3.10.5 使用SSH 59
3.10.6 使用FTP发送和接收文件 59
3.10.7 UNIX系统性能监控工具 60
3.11 UNIX中的磁盘和存储 64
3.11.1 磁盘存储配置选择 65
3.11.2 监控磁盘使用 65
3.11.3 磁盘存储、性能和可用性 66
3.12 RAID系统 67
3.12.1 RAID级别 67
3.12.2 选择理想的磁盘配置 69
3.12.3 冗余磁盘控制器 70
3.12.4 RAID和备份 70
3.12.5 RAID和Oracle 70
3.13 其他存储技术 70
3.13.1 SAN 71
3.13.2 NAS系统 71
3.13.3 InfiniBand 71
3.13.4 自动存储管理 72
3.13.5 Oracle与存储系统的兼容性 72
第4章 使用SQL*Plus和Oracle企业管理器 73
4.1 启动SQL*Plus会话 73
4.1.1 设置环境 73
4.1.2 从命令行启动SQL*Plus会话 74
4.1.3 用CONNECT命令进行连接 75
4.1.4 用/NOLOG的无连接SQL*Plus会话 76
4.1.5 通过Windows GUI连接SQL*Plus 76
4.1.6 在SQL*Plus中进行操作 77
4.2 退出SQL*Plus 77
4.3 SQL*Plus和SQL命令 77
4.3.1 SQL*Plus的安全性 78
4.3.2 用SET命令设置SQL*Plus环境 80
4.3.3 设置常用的SQL*Plus变量 81
4.3.4 SQL*Plus错误记录 84
4.3.5 SQL*Plus命令行选项 85
4.4 SQL*Plus管理命令 87
4.4.1 CLEAR命令 87
4.4.2 STORE命令 88
4.4.3 SHOW命令 88
4.5 关键的SQL*Plus“工作”命令 90
4.5.1 SQLPROMPT命令 90
4.5.2 DESCRIBE命令 91
4.5.3 HOST命令 91
4.5.4 SPOOL命令 92
4.5.5 ACCEPT和PROMPT命令 92
4.5.6 EXECUTE命令 92
4.5.7 PAUSE命令 93
4.6 格式化SQL*Plus的输出以及创建报告的命令 93
4.6.1 BREAK命令 93
4.6.2 COLUMN命令 94
4.6.3 COMPUTE命令 94
4.6.4 REPFOOTER命令 94
4.6.5 REPHEADER命令 94
4.6.6 BTITLE和TTITLE命令 94
4.7 在SQL*Plus中创建命令文件 95
4.7.1 将SQL缓冲区内容保存到文件中 95
4.7.2 在SQL*Plus中执行SQL脚本 95
4.7.3 创建Windows的批处理脚本 97
4.7.4 DEFINE和UNDEFINE命令 97
4.7.5 预定义SQL*Plus变量 97
4.7.6 在SQL*Plus中使用注释 98
4.7.7 显示SQL命令清单 98
4.8 在SQL*Plus中进行编辑 99
4.8.1 插入和删除行 100
4.8.2 添加文本 101
4.8.3 用REMARK命令加入注释 102
4.8.4 用COPY命令复制表 102
4.8.5 用SQL*Plus使DML的更改永久化 103
4.8.6 用SQL*Plus创建网页 103
4.9 主要的SQL*Plus数据库管理命令 104
4.9.1 RECOVER命令 104
4.9.2 STARTUP和SHOUTDOWN命令 104
4.9.3 ARCHIVE LOG命令 104
4.10 用SQL生成SQL 104
4.11 Oracle SQL Developer 105
4.12 OEM 106
4.12.1 使用OEM管理数据库的好处 106
4.12.2 OEM体系结构和组件 108
4.12.3 配置和使用Database Control 108
4.12.4 访问Database Control 111
4.12.5 Database Control的简要介绍 112
4.12.6 Performance 113
4.12.7 Availability 114
4.12.8 Server 114
4.12.9 Schema 115
4.12.10 Data Movement 115
4.12.11 Software and Support 115
4.12.12 Oracle软件克隆 115
4.12.13 配置使用Setup页 116
4.12.14 Related Links部分和Advisor Central页 117
4.12.15 创建Database Control角色 117
4.12.16 链接到MetaLink 118
4.12.17 基于策略的配置框架 118
4.12.18 跟踪数据库特性使用的统计数据 118
4.12.19 OEM Grid Control 120
4.12.20 管理Management Agent 122
4.12.21 OMS(Oracle Management Service，Oracle服务管理) 123
4.12.22 连接到Grid Control 123
4.12.23 登录到Grid Control 123
4.12.24 Grid Control的特性 124
4.12.25 使用Grid Control主页 124
4.12.26 用Grid Control监控整个系统 125
第二部分 Oracle Database 11g的体系结构、模式和事务管理
第5章 Oracle Database 11g体系结构 128
5.1 Oracle数据库的结构 128
5.1.1 逻辑数据库结构 128
5.1.2 物理数据库结构 134
5.1.3 其他文件 137
5.2 Oracle进程 139
5.2.1 用户和Oracle进程之间的交互 139
5.2.2 服务器进程 139
5.2.3 后台进程 140
5.3 Oracle内存结构 145
5.3.1 理解主存储器 145
5.3.2 SGA 146
5.3.3 PGA 151
5.4 简单的Oracle数据库事务 153
5.5 提交和回滚 154
5.5.1 提交一个事务 154
5.5.2 回滚一个事务 155
5.6 数据一致性和数据并发性 155
5.6.1 数据库写入器和写前协议 155
5.6.2 SCN 156
5.6.3 撤销管理 156
5.7 备份与恢复体系结构 157
5.7.1 用户管理的备份与恢复 157
5.7.2 RMAN 157
5.7.3 Oracle Secure Backup 158
5.7.4 闪回恢复技术 158
5.8 Oracle数据字典和动态性能视图 158
5.8.1 Oracle数据字典 159
5.8.2 动态性能(V$)视图 159
5.8.3 三组数据字典视图 159
5.8.4 如何创建数据字典 160
5.9 使用静态数据字典视图 160
5.10 与数据库对话 161
5.10.1 连接Oracle 161
5.10.2 OEM 161
5.10.3 SQL*Plus 162
5.11 Oracle实用程序 162
5.11.1 数据泵的导出和导入 162
5.11.2 SQL*Loader 162
5.11.3 LogMiner 162
5.11.4 自动诊断信息库控件接口 163
5.12 调度和资源管理工具 163
5.12.1 Oracle调度程序 163
5.12.2 数据库资源管理器 163
5.13 自动数据库管理 163
5.13.1 ADDM 163
5.13.2 自动撤销保留调优 164
5.13.3 自动优化程序统计数据收集 164
5.13.4 ASM 164
5.13.5 自动SQL调优 164
5.14 公共可管理基础设施 164
5.14.1 AWR 165
5.14.2 ASH 165
5.14.3 服务器产生的预警 166
5.14.4 自动任务特性 166
5.14.5 顾问程序的框架 166
5.14.6 更改管理 167
5.15 高效的管理和监控 167
第6章 管理表空间 169
6.1 表空间区尺寸和空间管理 169
6.1.1 分配区尺寸：自动分配与统一尺寸 169
6.1.2 自动与手动段空间管理 170
6.2 创建表空间 172
6.2.1 数据文件和表空间 172
6.2.2 区分配和解除分配 173
6.2.3 存储参数 174
6.2.4 数据库对象的存储分配 175
6.2.5 增加表空间的大小 176
6.2.6 删除表空间 177
6.2.7 用户表空间的数目 178
6.2.8 表空间限额 178
6.2.9 主动的表空间的空间预警 178
6.2.10 管理重做数据的生成 180
6.2.11 重新命名表空间 180
6.2.12 只读表空间 181
6.2.13 使表空间脱机 181
6.3 临时表空间 181
6.3.1 创建临时表空间 182
6.3.2 更改临时表空间 183
6.3.3 收缩临时表空间 183
6.3.4 默认临时表空间 184
6.3.5 临时表空间组 184
6.4 默认的永久表空间 186
6.5 大文件表空间 187
6.5.1 使用大文件表空间的限制 188
6.5.2 创建大文件表空间 188
6.5.3 更改大文件表空间 189
6.5.4 浏览大文件表空间的信息 189
6.6 管理Sysaux表空间 189
6.6.1 创建Sysaux表空间 190
6.6.2 Sysaux表空间的使用限制 190
6.7 表空间加密 190
6.7.1 为什么需要加密表空间 191
6.7.2 创建Oracle钱夹 191
6.7.3 创建一个加密的表空间 192
6.8 管理表空间的数据字典视图 193
6.8.1 DBA_TABLESPACE 193
6.8.2 DBA_FREE_SPACE 194
6.8.3 DBA_SEGMENTS 194
6.8.4 DBA_DATA_FILES 195
6.8.5 DBA_TABLESPACE_GROUPS 196
6.8.6 V$DATAFILE 196
6.8.7 V$FILESTAT 196
6.9 用Oracle管理的文件方便文件的管理 197
6.9.1 使用OMF的好处 198
6.9.2 创建Oracle管理的文件 198
6.9.3 不同类型的Oracle管理的文件 199
6.10 在两个数据库之间复制文件 202
6.10.1 COPY_FILE 202
6.10.2 GET_FILE 203
6.10.3 PUT_FILE 203
6.11 找出剩下多少可用空间 204
6.12 使用操作系统文件 205
6.12.1 使用UTL_FILE程序包 205
6.12.2 关键的UTL_FILE的过程和函数 206
6.12.3 异常处理程序 206
6.12.4 使用UTL_FILE程序包的简单例子 206
第7章 模式管理 209
7.1 SQL语句的类型 209
7.1.1 系统控制语句 210
7.1.2 会话控制语句 210
7.1.3 嵌入的SQL语句 210
7.1.4 数据操纵语句 210
7.1.5 事务控制语句 211
7.1.6 数据定义语言语句 211
7.2 Oracle模式 211
7.3 Oracle表 212
7.3.1 估计表的尺寸 213
7.3.2 创建简单表 214
7.3.3 什么是NULL值 215
7.3.4 列的默认值 216
7.3.5 虚拟列 216
7.3.6 添加表列 217
7.3.7 删除表列 217
7.3.8 重命名表列 217
7.3.9 重命名表 218
7.3.10 删除表中的所有数据 218
7.3.11 用CTAS选项创建新表 218
7.3.12 设置表为只读模式 219
7.3.13 表压缩 220
7.3.14 删除表 221
7.4 特殊的Oracle表 222
7.4.1 临时表 222
7.4.2 索引组织表 223
7.4.3 外部表 224
7.5 分区表 225
7.5.1 范围分区 225
7.5.2 间隔分区 226
7.5.3 散列分区 227
7.5.4 列表分区 227
7.5.5 引用分区 228
7.5.6 基于虚拟列的分区 229
7.5.7 系统分区 230
7.5.8 组合分区 231
7.5.9 分区维护操作 233
7.6 管理表的数据字典视图 235
7.7 群 237
7.8 散列群 238
7.9 Oracle索引 238
7.9.1 创建索引的准则 239
7.9.2 Oracle的索引模式 240
7.9.3 估算索引的尺寸 240
7.9.4 创建索引 241
7.10 特殊类型的索引 242
7.10.1 位图索引 242
7.10.2 反向键索引 242
7.10.3 键压缩索引 243
7.10.4 基于函数的索引 243
7.10.5 分区索引 243
7.10.6 不可见索引 244
7.11 监控索引的使用 245
7.12 索引的维护 246
7.13 管理数据库完整性约束 246
7.13.1 主键约束 247
7.13.2 非空约束 247
7.13.3 检查约束 247
7.13.4 唯一约束 248
7.13.5 引用完整性约束 248
7.13.6 完整性约束状态 248
7.13.7 信赖约束 249
7.13.8 暂缓和立即约束 250
7.14 与约束和索引有关的视图 250
7.14.1 DBA_CONSTRAINTS 250
7.14.2 DBA_CONS_COLUMNS 251
7.15 使用视图 251
7.16 使用实体化视图 253
7.16.1 查询重写 254
7.16.2 Rewrite_or_Error提示 255
7.16.3 重写的完整性 255
7.16.4 刷新实体化视图的数据 255
7.16.5 使用DBMS_MVIEW程序包 256
7.16.6 创建实体化视图 256
7.17 使用SQL访问顾问程序 258
7.17.1 使用OEM Database Control 259
7.17.2 使用DBMS_ADVISOR程序包 261
7.17.3 使用QUICK_TUNE过程 262
7.18 使用同义词 262
7.18.1 创建公共同义词 263
7.18.2 创建私有同义词 264
7.18.3 删除同义词 264
7.18.4 管理同义词 264
7.18.5 切换到另一个模式 264
7.19 使用序列 265
7.20 使用触发器 266
7.21 浏览对象信息 266
7.21.1 管理数据库对象的视图 266
7.21.2 DBA_OBJECTS 266
7.21.3 DBA_TABLES 267
7.21.4 DBA_EXTERNAL_TABLES 267
7.21.5 DBA_TAB_PARTITIONS 267
7.21.6 DBA_PART_TABLES 268
7.21.7 DBA_TAB_MODIFICATIONS 268
7.21.8 DBA_TAB_COLUMNS 269
7.21.9 DBA_VIEWS 269
7.21.10 DBA_MVIEWS 270
7.21.11 DBA_INDEXES 270
7.21.12 DBA_IND_COLUMNS 270
7.21.13 INDEX_STATS 271
第8章 Oracle事务管理 272
8.1 Oracle的事务 272
8.1.1 COMMIT语句 273
8.1.2 ROLLBACK语句 274
8.2 事务的特性 274
8.3 事务并发性控制 275
8.3.1 并发性带来的问题 275
8.3.2 进度表和串行性 276
8.4 隔离级别和ISO事务标准 276
8.5 Oracle的隔离级别 278
8.5.1 事务级和语句级一致性 279
8.5.2 改变默认隔离级别 279
8.6 实现Oracle的并发控制 280
8.6.1 Oracle的锁定方法 281
8.6.2 Oracle的锁类型 281
8.6.3 允许DDL锁等待DML锁 282
8.6.4 显式表锁定 283
8.6.5 Oracle中的显式锁定 283
8.6.6 管理Oracle锁 284
8.7 利用撤销数据提供读一致性 287
8.7.1 AUM 287
8.7.2 有保证的撤销保留 292
8.7.3 使用OEM管理撤销数据 295
8.8 使用撤销数据纠正闪回错误 296
8.9 用DBMS_FLASHBACK程序包进行闪回 297
8.10 闪回事务查询 301
8.10.1 同时使用闪回事务查询和闪回版本查询 302
8.10.2 闪回表特性 303
8.11 事务管理 307
8.11.1 离散事务 307
8.11.2 自主事务 307
8.12 可恢复的空间分配 309
8.12.1 可继续执行的操作 309
8.12.2 常见的可继续执行错误 310
8.12.3 使用可恢复的空间分配特性 310
8.12.4 挂起操作的通知 312
8.12.5 操作挂起的警告 312
8.12.6 监控可恢复的空间分配 312
8.13 管理长事务 312
8.13.1 使用Workspace Manager的好处 313
8.13.2 表版本和工作区 313
第三部分 安装和升级到Oracle Database 11g，创建数据库
第9章 安装和升级到Oracle Database 11g 316
9.1 安装Oracle 316
9.1.1 参阅文献 316
9.1.2 确定磁盘和内存需求 317
9.2 OFA 317
9.2.1 安装点 318
9.2.2 目录及文件命名约定 319
9.3 执行预安装任务 323
9.3.1 检查预安装需求 324
9.3.2 系统管理员的预安装任务 325
9.3.3 Oracle拥有者的预安装任务 332
9.4 安装的最终检查表 334
9.4.1 访问安装软件 334
9.4.2 安装软件 336
9.4.3 使用响应文件安装Oracle软件 340
9.5 安装后的任务 341
9.5.1 系统管理员的后安装任务 342
9.5.2 Oracle拥有者的后安装工作 342
9.6 卸载Oracle 343
9.6.1 删除运行在服务器上的所有Oracle数据库 343
9.6.2 删除Oracle软件 344
9.7 升级到Oracle Database 11g 344
9.8 升级到Oracle Database 11g的方法 345
9.9 升级方法和工具 345
9.9.1 手动升级过程 345
9.9.2 数据库升级助手 346
9.9.3 预升级信息工具 346
9.9.4 后升级状态工具 347
9.9.5 为升级准备数据库 347
9.10 用DBUA升级 348
9.10.1 启动DBUA 348
9.10.2 执行DBUA 348
9.10.3 复原升级前的数据库 350
9.11 手动升级 350
9.11.1 升级和降级脚本 350
9.11.2 创建假脱机文件 351
9.11.3 启动预升级信息工具 351
9.11.4 备份数据库 353
9.11.5 复制参数文件 353
9.11.6 启动新数据库 353
9.11.7 执行升级脚本 354
9.11.8 执行升级活动脚本 354
9.11.9 重启实例 355
9.11.10 运行后升级活动脚本 355
9.11.11 检查无效对象 355
9.11.12 重编译和使无效对象有效 355
9.11.13 运行后升级状态工具 356
9.11.14 结束假脱机文件 357
9.11.15 重启新数据库 357
9.12 升级之后 357
9.12.1 为加强密码保护而重新设置密码 357
9.12.2 降级到旧版本 357
第10章 创建Oracle数据库 359
10.1 准备创建数据库 359
10.1.1 安装Oracle软件 359
10.1.2 为数据库创建文件系统 360
10.1.3 分配足够的内存 361
10.1.4 得到必要的授权 361
10.1.5 设置OS环境变量 361
10.2 创建参数文件 362
10.2.1 数据库参数文件的类型 362
10.2.2 初始化参数文件 362
10.2.3 更改初始化参数值 363
10.2.4 重要的Oracle Database 11g初始化参数 364
10.2.5 文档未记载的初始化参数 382
10.2.6 查看当前初始化参数值 382
10.3 创建新数据库 383
10.3.1 手动创建 383
10.3.2 使用DBCA创建数据库 393
10.4 使用服务器参数文件 400
10.4.1 创建服务器参数文件 400
10.4.2 设置动态参数更改的范围 402
10.4.3 从内存创建SPFILE或PFILE 403
10.5 从SQL*Plus中启动和关闭数据库 403
10.5.1 启动数据库 403
10.5.2 自动启动数据库 405
10.5.3 限制数据库的访问 406
10.5.4 关闭数据库 407
10.5.5 停顿数据库 409
10.5.6 挂起数据库 410
10.5.7 删除数据库 410
10.5.8 使用数据字典监控数据库状态 411
10.5.9 接下来的工作 412
第四部分 连接和用户管理
第11章 连接和网络 414
11.1 Oracle网络和数据库连接 414
11.2 网络概念：Oracle网络如何工作 415
11.2.1 Web应用如何连接到Oracle数据库 416
11.2.2 数据库实例名 416
11.2.3 全局数据库名 416
11.2.4 数据库服务名 416
11.2.5 连接描述符 417
11.2.6 连接标识符 417
11.2.7 连接串 417
11.3 建立Oracle连接 418
11.4 Oracle客户机 419
11.4.1 安装Oracle客户机 420
11.4.2 使用TWO_TASK环境变量 420
11.5 即时客户机 421
11.6 监听器和连接 421
11.6.1 自动服务注册 422
11.6.2 监听器命令 423
11.6.3 监听器管理 424
11.7 命名和连接 425
11.7.1 本地命名方法 426
11.7.2 简易连接命名方法 429
11.7.3 数据库驻留连接池 431
11.7.4 外部命名方法 433
11.7.5 目录命名方法 433
11.8 Oracle和Java数据库连接 437
11.8.1 建立数据库连接 437
11.8.2 使用数据库 437
11.8.3 一个完整的程序 439
第12章 用户管理和数据库安全 441
12.1 管理用户 441
12.1.1 临时和默认表空间 442
12.1.2 创建新用户 442
12.1.3 更改用户 444
12.1.4 删除用户 445
12.1.5 创建和使用用户概要文件 445
12.1.6 管理资源 450
12.2 Database Resource Manager 450
12.2.1 使用Database Resource Manager 451
12.2.2 使用OEM管理Database Resource Manager 460
12.3 控制数据库访问 461
12.3.1 Oracle数据库中的权限 461
12.3.2 角色 466
12.3.3 使用视图和存储过程来管理权限 469
12.3.4 管理用户、角色和权限的DBA视图 469
12.3.5 细粒度数据访问 470
12.4 审计数据库使用 477
12.4.1 标准审计 477
12.4.2 细粒度审计 483
12.5 认证用户 485
12.5.1 数据库认证 486
12.5.2 外部认证 489
12.5.3 代理认证 490
12.5.4 集中式用户认证 490
12.6 企业用户安全 491
12.6.1 共享模式 491
12.6.2 单次注册 491
12.6.3 数据加密 491
12.6.4 表空间加密 495
12.6.5 Oracle Internet Directory 497
12.7 数据安全须知 497
12.7.1 自动保护配置 497
12.7.2 用户账号 498
12.7.3 密码 498
12.7.4 操作系统认证 498
12.7.5 数据库审计 498
12.7.6 授予权限 499
12.7.7 涉及多个DBA的环境 499
12.7.8 保护数据字典 499
12.7.9 设置权限 499
12.7.10 网络和监听程序 500
12.7.11 细粒度网络访问控制 501
12.7.12 Oracle的高级安全选项 503
12.7.13 应用安全 503
12.7.14 管理用户的有用技术 504
第五部分 数据装载、备份和恢复
第13章 装载和转换数据 508
13.1 提取、转换和装载概览 508
13.2 使用SQL*Loader实用程序 509
13.2.1 SQL*Loader控制文件 510
13.2.2 在装载中生成数据 517
13.2.3 调用SQL*Loader 517
13.2.4 装载日志文件 518
13.2.5 使用返回代码 519
13.2.6 使用直接装载方法 520
13.2.7 实用的SQL*Loader数据装载技术 522
13.3 使用外部表装载数据 524
13.3.1 创建外部表层 525
13.3.2 填充外部表 528
13.3.3 使用外部表 530
13.3.4 使用SQL*Loader生成外部表创建语句 531
13.4 转换数据 533
13.4.1 从现有表中派生数据 534
13.4.2 使用SQL转换数据 534
13.4.3 使用SQL MODEL子句 542
13.5 使用Oracle流复制和共享信息 545
13.5.1 研究流体系结构 545
13.5.2 设置Oracle流 546
第14章 使用数据泵导出和导入 549
14.1 数据泵技术的介绍 549
14.1.1 数据泵技术的优点 550
14.1.2 数据泵导出和导入的用途 551
14.1.3 数据泵的组成部分 551
14.1.4 数据访问方法 552
14.1.5 数据泵文件 552
14.1.6 数据泵权限 556
14.1.7 数据泵作业的结构 556
14.2 执行数据泵导出和导入 557
14.2.1 数据泵导出方法 557
14.2.2 数据泵导出的方式 558
14.2.3 数据泵导出参数 559
14.2.4 数据泵导出的例子 571
14.2.5 数据泵导入的类型和方式 572
14.2.6 数据泵导入参数 572
14.3 监控数据泵作业 578
14.3.1 浏览数据泵作业 579
14.3.2 浏览数据泵会话 579
14.3.3 浏览数据泵作业的进度 579
14.4 使用数据泵API 580
14.5 可移植表空间 581
14.5.1 可移植表空间的使用 581
14.5.2 移植表空间 581
14.5.3 在不同Endian格式的平台之间移植表空间 584
第15章 备份数据库 587
15.1 备份Oracle数据库 587
15.1.1 重要的备份术语 588
15.1.2 备份准则 590
15.1.3 测试备份 591
15.1.4 维护冗余集 591
15.1.5 备份策略 591
15.2 闪回恢复区 594
15.2.1 闪回恢复区的好处 595
15.2.2 设置闪回恢复区的大小 596
15.2.3 创建闪回恢复区的方法 596
15.2.4 备份闪回恢复区 599
15.2.5 使用闪回恢复区 599
15.3 恢复管理器 600
15.3.1 RMAN的好处 601
15.3.2 RMAN体系结构 602
15.3.3 连接到RMAN 603
15.3.4 RMAN脚本 605
15.3.5 重要的RMAN术语 609
15.3.6 指定备份标记和备份格式 610
15.3.7 做RMAN备份的副本 610
15.3.8 RMAN备份位置 611
15.3.9 RMAN命令 612
15.3.10 RMAN配置参数 617
15.3.11 使用恢复目录 621
15.3.12 维护恢复目录 623
15.3.13 虚拟专用目录 626
15.3.14 RMAN备份的例子 627
15.3.15 重新启动RMAN备份 630
15.3.16 限制备份时间 630
15.3.17 增量更新备份 630
15.3.18 快速增量备份 631
15.3.19 RMAN压缩备份 632
15.3.20 归档备份 632
15.3.21 监控和验证RMAN作业 634
15.4 备份控制文件 636
15.5 Oracle Secure Backup 637
15.5.1 Oracle Secure Backup的好处 637
15.5.2 Oracle Secure Backup管理域 637
15.5.3 安装Oracle Secure Backup 638
15.5.4 使用Oracle Backup Web Interface工具 639
15.5.5 配置Oracle Secure Backup 639
15.5.6 用Oracle Secure Backup执行备份 640
15.6 用户管理的备份 640
15.6.1 进行完全的数据库备份 641
15.6.2 制作部分数据库备份 644
15.6.3 监控用户管理的联机备份 645
15.7 数据库讹误检测 645
15.7.1 检测介质讹误 645
15.7.2 检测数据块讹误 645
15.8 加强数据保护以便进行灾难恢复 647
15.8.1 高可用性系统 647
15.8.2 Oracle Data Guard和备用数据库 648
第16章 数据库恢复 650
16.1 数据库故障类型 650
16.1.1 系统故障 650
16.1.2 数据中心的灾难 651
16.1.3 人为错误 651
16.1.4 介质故障 651
16.1.5 故障和数据修复 651
16.2 Oracle的恢复过程 652
16.2.1 崩溃和实例恢复 653
16.2.2 快速实例启动 654
16.2.3 介质恢复 654
16.2.4 介质恢复与非介质恢复 656
16.3 用RMAN执行恢复 657
16.3.1 使用RMAN恢复的好处 657
16.3.2 使用VALIDATE BACKUP命令验证RMAN备份 658
16.3.3 使用RESTORE...VALIDATE命令 658
16.3.4 使用RESTORE...PREVIEW命令 658
16.3.5 确定恢复必需的文件 659
16.3.6 RMAN恢复过程 659
16.3.7 用增量更新备份进行恢复 659
16.3.8 监控RMAN作业 660
16.3.9 用户管理的恢复过程 660
16.4 典型的介质恢复方案 661
16.4.1 整个数据库的完全恢复 661
16.4.2 恢复表空间 663
16.4.3 恢复数据文件 664
16.4.4 不完全恢复 666
16.4.5 从控制文件丢失中恢复 670
16.4.6 恢复没有备份的数据文件 673
16.5 数据恢复顾问 674
16.6 克隆数据库 678
16.6.1 使用RMAN克隆数据库 678
16.6.2 使用Database Control克隆数据库 681
16.6.3 手动克隆数据库 682
16.7 粒度恢复技术 683
16.7.1 表空间时间点恢复 683
16.7.2 使用LogMiner进行精确恢复 684
16.8 闪回技术和恢复 689
16.8.1 闪回级别 689
16.8.2 闪回与传统恢复技术 690
16.8.3 闪回删除 690
16.8.4 闪回数据库 694
16.9 使用复原点 700
16.9.1 有保证的复原点 701
16.9.2 查看复原点 702
16.10 修理数据讹误并试验恢复 702
16.10.1 块介质恢复 703
16.10.2 试验恢复 704
16.11 排除恢复错误 704
16.11.1 ORA-01194错误 704
16.11.2 ORA-01152错误 705
16.11.3 ORA-00376错误 706
16.11.4 事务取消特性 706
16.12 闪回数据存档 708
16.12.1 管理闪回数据存档 708
16.12.2 启用闪回数据存档 709
16.12.3 使用闪回数据存档：例子 710
第六部分 管理Oracle数据库
第17章 自动管理和联机功能 714
17.1 自动数据库诊断监控器(ADDM) 714
17.1.1 ADDM的用途 715
17.1.2 ADDM可以诊断的问题 715
17.1.3 ADDM判定 716
17.1.4 ADDM建议 717
17.1.5 管理ADDM 718
17.2 自动内存管理 728
17.2.1 内存管理的类型 729
17.2.2 开启自动内存管理 729
17.2.3 调优自动内存管理 731
17.2.4 自动内存参数的相关性 731
17.3 自动优化程序的统计数据收集 732
17.3.1 自动收集优化程序的统计数据 732
17.3.2 手动收集优化程序的统计数据 734
17.4 自动存储管理 734
17.4.1 ASM的优点 734
17.4.2 考察ASM架构 735
17.4.3 安装ASM 736
17.4.4 ASM和集群同步服务 736
17.4.5 创建ASM实例 737
17.4.6 ASM的快速镜像再同步特性 741
17.4.7 ASM首选的镜像读 742
17.4.8 改变ASM磁盘组属性 742
17.4.9 asmcmd命令行工具 743
17.4.10 管理ASM磁盘组 745
17.4.11 利用磁盘组增加性能和冗余 746
17.4.12 创建磁盘组 747
17.4.13 向磁盘组添加磁盘 747
17.4.14 删除磁盘和磁盘组 748
17.4.15 重新平衡磁盘组 748
17.4.16 管理ASM文件 748
17.4.17 ASM文件名的类型 749
17.4.18 使用ASM文件名 750
17.4.19 ASM文件模板 750
17.4.20 创建基于ASM的数据库 750
17.4.21 将数据库迁移到ASM 751
17.5 自动空间管理 752
17.5.1 自动撤销管理 753
17.5.2 使用OMF轻松管理文件 753
17.5.3 联机段收缩和段顾问 758
17.5.4 手动段收缩 759
17.5.5 使用Segment Advisor收缩段 759
17.5.6 自动Segment Advisor作业 761
17.5.7 自动检查点调优 761
17.6 Oracle Database 11g的联机功能 762
17.6.1 联机数据重组 762
17.6.2 联机数据重定义 764
17.6.3 动态资源管理 769
17.6.4 联机更改数据库块尺寸 770
17.6.5 为联机维护使用数据库停顿 772
17.6.6 挂起数据库 772
第18章 管理和监控运行中的数据库 773
18.1 Oracle性能统计的类型 773
18.1.1 累计统计 774
18.1.2 样本数据 774
18.1.3 基线数据 774
18.1.4 数据库度量 775
18.2 服务器产生的预警 777
18.3 基线度量和自适应阈值 779
18.3.1 管理预警 779
18.3.2 主动的表空间预警 781
18.3.3 使用预警日志和跟踪文件进行监控 782
18.3.4 与度量和预警有关的数据字典视图 782
18.4 AWR 783
18.4.1 AWR收集的数据的类型 784
18.4.2 AWR数据处理 784
18.4.3 管理AWR 784
18.4.4 移动窗基线 788
18.4.5 AWR基线模板 788
18.5 ASH 793
18.5.1 当前活动会话数据 794
18.5.2 旧的活动会话历史数据 794
18.5.3 生成ASH报告 795
18.6 管理顾问框架 797
18.6.1 管理顾问程序 798
18.6.2 顾问框架的管理 799
18.7 使用撤销和MTTR顾问程序 801
18.7.1 使用撤销顾问程序 801
18.7.2 使用MTTR顾问程序 802
18.8 管理联机重做日志 802
18.8.1 硬件镜像与Oracle的多路复用技术 803
18.8.2 联机重做日志组 803
18.8.3 创建联机重做日志组 803
18.8.4 增加重做日志组 803
18.8.5 重命名重做日志文件 804
18.8.6 删除联机重做日志 804
18.8.7 联机重做日志讹误 804
18.8.8 监控重做日志 805
18.9 管理数据库链接 805
18.9.1 创建私有数据库链接 805
18.9.2 创建公共数据库链接 806
18.9.3 使用Database Control创建数据库链接 807
18.10 比较和会聚数据库对象 807
18.10.1 比较数据 807
18.10.2 会聚数据 809
18.11 用数据库服务器复制文件 810
18.11.1 文件复制的要求 810
18.11.2 复制本地系统中的文件 811
18.11.3 将文件传送到不同的数据库 811
18.12 映射Oracle文件到物理设备 812
18.12.1 文件映射的结构 812
18.12.2 设置文件映射 813
18.13 使用Oracle的调度程序 813
18.13.1 基本的Scheduler部件 813
18.13.2 调度程序作业的类型 814
18.13.3 Scheduler的高级部件 815
18.13.4 Scheduler的体系结构 815
18.13.5 Scheduler的权限 816
18.13.6 管理Scheduler的基本组件 816
18.13.7 管理轻型作业 818
18.13.8 管理外部作业 820
18.13.9 管理Scheduler的高级部件 828
18.13.10 管理Scheduler属性 833
18.13.11 清除作业日志 834
18.13.12 默认的Scheduler作业 834
18.14 自动维护任务 835
18.14.1 预定义维护窗口 835
18.14.2 管理自动维护任务 835
18.14.3 监控自动维护任务 835
18.15 故障诊断 837
18.15.1 自动诊断信息库 838
18.15.2 ADRCI 839
18.15.3 意外事件打包服务 840
18.15.4 Support Workbench 842
18.15.5 Health Monitor 845
18.15.6 用SQL Repair Advisor修复SQL语句 848
18.15.7 SQL Test Case Builder 850
第七部分 性能调优
第19章 改进数据库性能：SQL查询优化 852
19.1 Oracle性能调优的方法 852
19.1.1 性能调优的系统性方法 853
19.1.2 被动的性能调优 853
19.2 优化Oracle查询处理 853
19.2.1 语法分析 854
19.2.2 优化 854
19.2.3 查询的执行 856
19.3 查询优化和Oracle CBO 857
19.3.1 选择优化方式 857
19.3.2 为优化程序提供统计数据 857
19.3.3 设置优化程序方式 859
19.3.4 设置优化程序级别 860
19.3.5 优化程序做些什么 860
19.3.6 CBO的缺点 862
19.3.7 为CBO提供统计数据 862
19.3.8 延迟统计数据公布 865
19.3.9 扩展统计数据 866
19.3.10 Oracle 优化程序的成本模型 868
19.3.11 收集系统统计数据 868
19.3.12 对字典对象收集统计数据 870
19.3.13 统计数据收集的频率 871
19.3.14 没有统计数据时会发生什么事情 871
19.3.15 使用OEM收集优化程序统计数据 871
19.4 编写高效的SQL 872
19.4.1 高效的WHERE子句 872
19.4.2 使用提示影响执行计划 874
19.4.3 选择最佳的联结方法 875
19.4.4 使用位图联结索引 875
19.4.5 选择最佳的联结次序 876
19.4.6 索引策略 877
19.4.7 监控索引的使用 879
19.4.8 删除不需要的索引 880
19.4.9 使用相似的SQL语句 880
19.4.10 通过内嵌函数减少SQL开销 880
19.4.11 使用绑定变量 881
19.4.12 避免不恰当地使用视图 881
19.4.13 避免不必要的全表扫描 881
19.5 DBA如何帮助改进SQL处理 881
19.5.1 使用分区表 882
19.5.2 使用压缩技术 882
19.5.3 使用实体化视图 882
19.5.4 使用存储大纲保证CBO的稳定性 883
19.6 SQL计划管理 885
19.6.1 SQL计划基线 886
19.6.2 捕捉SQL计划基线 886
19.6.3 SQL管理库 889
19.6.4 使用并行执行 890
19.6.5 其他DBA任务 890
19.7 自适应游标共享 891
19.7.1 自适应游标共享如何工作 892
19.7.2 监控自适应游标共享 893
19.8 SQL性能调优工具 894
19.8.1 使用EXPLAIN PLAN 894
19.8.2 使用Autotrace 898
19.8.3 使用SQL Trace和TKPROF 902
19.9 端到端跟踪 907
19.9.1 使用DBMS_MONITOR程序包 908
19.9.2 使用V$SQL视图查找低效的SQL 910
19.10 SQL Tuning Advisor 912
19.10.1 使用SQL Tuning Advisor 912
19.10.2 SQL Tuning Advisor如何工作 912
19.10.3 SQL Tuning Advisor实践 914
19.10.4 Automatic SQL Tuning Advisor 916
19.10.5 解释自动SQL调优报告 919
19.10.6 使用其他的GUI工具 919
19.11 使用结果高速缓存 920
19.11.1 管理结果高速缓存 920
19.11.2 设置RESULT_CACHE_MODE参数 920
19.11.3 管理结果高速缓存 922
19.11.4 PL/SQL函数结果高速缓存 923
19.11.5 客户机查询结果高速缓存 924
19.12 调优SQL语句的简单方法 925
19.12.1 识别问题语句 925
19.12.2 定位低效资源 925
19.12.3 调优SQL语句 926
19.12.4 比较性能 926
第20章 Oracle性能调优：调优实例 927
20.1 实例调优简介 927
20.2 自动性能调优与动态性能视图 929
20.3 Oracle内存调优 929
20.3.1 共享池调优 930
20.3.2 硬分析和软分析 932
20.3.3 调优缓冲区高速缓存 939
20.3.4 调优大池、流池和Java池 943
20.3.5 调优PGA内存 943
20.4 评估系统性能 947
20.4.1 CPU性能 947
20.4.2 内存 951
20.4.3 磁盘I/O 951
20.5 度量I/O性能 952
20.5.1 I/O是否最佳分布 952
20.5.2 减少磁盘争用 953
20.5.3 最佳磁盘使用的Oracle SAME准则 953
20.5.4 网络性能 954
20.6 度量实例性能 954
20.6.1 数据库命中率 954
20.6.2 数据库等待统计数据 955
20.6.3 等待事件和等待类 956
20.6.4 分析实例性能 956
20.6.5 检查系统性能 971
20.6.6 了解应用程序 972
20.6.7 使用ADDM分析性能问题 973
20.6.8 对各SQL语句使用AWR报告 974
20.6.9 操作系统内存管理 975
20.6.10 用ASH报告分析最近的会话活动 975
20.6.11 当数据库挂起时 976
20.6.12 处理被卡住的归档进程 976
20.6.13 系统使用问题 977
20.6.14 资源的过多争用 977
20.6.15 锁问题 978
20.6.16 进程尺寸的异常增加 978
20.6.17 由于共享池问题导致的延迟 980
20.6.18 由坏统计数据导致的问题 980
20.6.19 在数据库挂起期间收集信息 980
20.6.20 使用Database Control的Hang Analysis页 980
20.7 实例调优的一种简单方法 982
20.7.1 数据库怎么了 983
20.7.2 使用OEM Database Control查看数据库性能 983
20.7.3 存在运行时间很长的事务吗 989
20.7.4 Oracle有问题吗 989
20.7.5 网络正常吗 989
20.7.6 系统是否受到CPU限制 990
20.7.7 系统受到I/O限制吗 990
20.7.8 数据库负荷太高 991
20.7.9 检查与内存有关的问题 991
20.7.10 重做日志的尺寸设置正确吗 991
20.7.11 系统受到等待的限制吗 992
20.7.12 Compare Periods报告 992
20.7.13 排除争用 994
20.8 真应用测试 995
20.8.1 数据库重演 995
20.8.2 SQL性能分析器 1001
附录A Oracle Database 11g SQL和PL/SQL入门知识 1005
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 11g数据库管理艺术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle性能优化求生指南
目　录

第一部分　 方法、概念和工具
第1章　 Oracle性能调优：一种系统化方法　 　 2
1.1　 Oracle性能调优简史　 　 3
1.2　 超越表面分析法　 　 3
1.3　 第一阶段：最小化应用负载　 　 5
1.4　 第二阶段：降低争用和瓶颈　 　 6
1.5　 第三阶段：降低物理IO　 　 7
1.6　 第四阶段：优化磁盘IO　 　 8
1.7　 本章小结　 　 9
第2章　 Oracle体系结构与基本概念　 　 11
2.1　 Oracle API　 　 11
2.1.1　 创建游标　 　 13
2.1.2　 检查缓存的SQL语句　 　 13
2.1.3　 解析SQL语句　 　 13
2.1.4　 关联绑定变量　 　 14
2.1.5　 执行SQL语句　 　 15
2.1.6　 提取记录　 　 15
2.1.7　 使用批量提取　 　 15
2.1.8　 处理结果集　 　 16
2.1.9　 关闭游标　 　 16
2.1.10　 优化Oracle API调用　 　 16
2.2　 Oracle查询优化器　 　 16
2.2.1　 基于成本的优化　 　 17
2.2.2　 优化器目标　 　 18
2.2.3　 优化器统计信息　 　 18
2.2.4　 绑定变量窥视与自适应游标共享　 　 19
2.2.5　 提示　 　 19
2.2.6　 存储概要、SQL概要和SQL计划基线　 　 19
2.3　 事务和锁　 　 20
2.4　 Oracle服务器体系结构　 　 20
2.4.1　 实例与数据库　 　 21
2.4.2　 系统全局区　 　 22
2.4.3　 数据缓存　 　 22
2.4.4　 程序全局区　 　 22
2.4.5　 内存管理　 　 23
2.5　 段与文件　 　 23
2.5.1　 表　 　 23
2.5.2　 索引　 　 24
2.5.3　 块、区间、段以及分区　 　 24
2.5.4　 表空间与数据文件　 　 25
2.5.5　 回滚段　 　 25
2.5.6　 重做日志与归档日志　 　 25
2.5.7　 闪回日志　 　 25
2.6　 服务器进程　 　 26
2.7　 后台进程　 　 26
2.8　 真正应用集群　 　 27
2.9　 本章小结　 　 28
第3章　 实用工具　 　 29
3.1　 生成SQL语句的执行计划　 　 29
3.1.1　 计划表　 　 30
3.1.2　 研究缓存的SQL　 　 33
3.1.3　 DBMS_XPLAN　 　 35
3.1.4　 解释执行计划　 　 39
3.1.5　 虚拟索引　 　 43
3.2　 跟踪Oracle的执行　 　 44
3.2.1　 从当前会话中调用跟踪　 　 44
3.2.2　 识别跟踪文件　 　 45
3.2.3　 获取跟踪状态　 　 45
3.2.4　 在其他会话中调用跟踪　 　 46
3.2.5　 通过MODULE、ACTION或SERVICE进行跟踪　 　 47
3.2.6　 使用登录触发器来启用跟踪　 　 47
3.2.7　 定位跟踪文件　 　 48
3.2.8　 其他特殊化的跟踪　 　 48
3.3　 使用tkprof格式化跟踪文件　 　 49
3.3.1　 tkprof的排序选项　 　 49
3.3.2　 其他tkprof选项　 　 50
3.3.3　 合并多个SQL跟踪文件　 　 51
3.3.4　 解释tkprof的输出结果　 　 51
3.3.5　 tkprof中的执行计划　 　 53
3.3.6　 等待统计信息与tkprof　 　 54
3.3.7　 tkprof的替代品　 　 54
3.4　 在SQL*PLUS中使用AUTOTRACE　 　 55
3.5　 监控Oracle服务器　 　 56
3.5.1　 V$表接口　 　 56
3.5.2　 等待接口　 　 57
3.5.3　 时间模型　 　 59
3.5.4　 整合时间模型与等待接口　 　 61
3.5.5　 Oracle企业管理器　 　 62
3.5.6　 SPOTLIGHT ON ORACLE　 　 63
3.6　 本章小结　 　 64
第二部分　 应用和数据库设计
第4章　 数据库逻辑设计和物理设计　 　 66
4.1　 逻辑数据模型　 　 66
4.1.1　 标准化和第三范式　 　 66
4.1.2　 数据类型选择　 　 67
4.1.3　 人造键　 　 67
4.1.4　 数据仓库设计　 　 68
4.2　 逻辑模型到物理模型的映射　 　 68
4.2.1　 将实体或类映射成表　 　 69
4.2.2　 选择表的类型　 　 71
4.2.3　 数据类型和精度　 　 71
4.2.4　 可选的属性和NULL值　 　 72
4.2.5　 列的顺序　 　 73
4.2.6　 探索Oracle对象模型　 　 73
4.3　 反规范化　 　 74
4.3.1　 复制列值以避免表联结　 　 74
4.3.2　 概要表　 　 75
4.3.3　 垂直分区　 　 75
4.3.4　 实施反规范化　 　 76
4.4　 星型模式设计　 　 76
4.4.1　 星型模式基础　 　 76
4.4.2　 雪花模式　 　 77
4.4.3　 维度层次结构　 　 79
4.4.4　 聚集和物化视图　 　 80
4.4.5　 物化视图最佳实践　 　 81
4.5　 物理存储方案　 　 82
4.5.1　 数据段存储手工管理和自动管理　 　 82
4.5.2　 并行插入和空闲块链表　 　 82
4.5.3　 PCTFREE 与PCTUSED　 　 83
4.5.4　 压缩　 　 84
4.5.5　 大数据字段LOB的存储　 　 85
4.6　 分区　 　 86
4.6.1　 分区的类型　 　 86
4.6.2　 组合分区　 　 87
4.6.3　 选择一个分区策略　 　 87
4.6.4　 企业管理器的分区顾问　 　 87
4.7　 本章小结　 　 89
第5章　 索引与簇　 　 91
5.1　 Oracle索引与簇机制的概况　 　 91
5.2　 B*树索引　 　 91
5.2.1　 索引选择性　 　 93
5.2.2　 唯一索引　 　 93
5.2.3　 隐含索引　 　 94
5.2.4　 组合索引　 　 94
5.2.5　 索引跳跃扫描　 　 95
5.2.6　 创建组合索引的指导原则　 　 96
5.2.7　 索引合并　 　 96
5.2.8　 索引中的空值　 　 97
5.2.9　 反转键（Reverse Key）索引　 　 97
5.2.10　 索引压缩　 　 98
5.2.11　 函数索引　 　 98
5.2.12　 外键与锁　 　 99
5.2.13　 索引与分区　 　 100
5.3　 位图索引　 　 101
5.3.1　 位图索引的特性　 　 101
5.3.2　 位图索引的缺陷　 　 102
5.3.3　 位图索引与基数　 　 103
5.3.4　 位图索引合并　 　 104
5.3.5　 位图联结索引　 　 104
5.4　 索引的开销　 　 106
5.5　 索引组织表　 　 109
5.5.1　 配置溢出段　 　 111
5.5.2　 定期重建索引组织表（IOT）　 　 114
5.6　 簇　 　 114
5.6.1　 索引簇　 　 114
5.6.2　 散列簇　 　 116
5.7　 嵌套表　 　 121
5.8　 选择最优的索引策略　 　 123
5.9　 本章小结　 　 124
第6章　 应用设计与实现　 　 125
6.1　 SQL语句管理　 　 125
6.1.1　 优化解析　 　 125
6.1.2　 避免执行不必要的SQL语句　 　 129
6.2　 批量接口　 　 133
6.2.1　 实现批量提取　 　 133
6.2.2　 批量插入　 　 135
6.3　 事务设计　 　 135
6.3.1　 隔离级别　 　 136
6.3.2　 事务与锁　 　 137
6.3.3　 Oracle中的行级锁　 　 138
6.3.4　 应用的锁策略　 　 139
6.4　 使用存储过程来降低网络流量　 　 141
6.5　 本章小结　 　 145
第三部分　 SQL和PL/SQL调优
第7章　 优化器的优化　 　 148
7.1　 Oracle优化器　 　 148
7.1.1　 什么是成本　 　 148
7.1.2　 优化器目标　 　 149
7.1.3　 选择性和基数　 　 149
7.1.4　 查询转换　 　 149
7.1.5　 成本计算　 　 150
7.1.6　 对象统计信息　 　 151
7.1.7　 直方图　 　 152
7.1.8　 绑定变量窥探　 　 154
7.1.9　 自适应游标共享　 　 155
7.1.10　 数据库参数　 　 156
7.1.11　 系统统计信息　 　 159
7.1.12　 收集统计信息　 　 160
7.2　 使用DBMS_STAT　 　 162
7.2.1　 DBMS_STATS的储存过程和参数　 　 163
7.2.2　 设置DBMS_STATS的系统默认值　 　 165
7.2.3　 使用METHOD_OPT创建直方图　 　 165
7.2.4　 抽样　 　 166
7.2.5　 分区统计信息　 　 167
7.2.6　 扩展的统计信息　 　 167
7.2.7　 锁定统计信息　 　 169
7.2.8　 系统统计信息　 　 170
7.2.9　 导出和导入统计信息　 　 170
7.2.10　 操纵统计信息　 　 170
7.3　 本章小结　 　 171
第8章　 执行计划管理　 　 172
8.1　 提示　 　 172
8.1.1　 使用提示来改变访问路径　 　 174
8.1.2　 使用提示来改变联结顺序　 　 174
8.1.3　 提示详述中的错误　 　 175
8.2　 存储提纲　 　 175
8.2.1　 创建存储提纲以稳定执行计划　 　 176
8.2.2　 侵入存储提纲　 　 177
8.3　 SQL调优集　 　 179
8.3.1　 手动创建调优集　 　 180
8.3.2　 在企业管理器中创建调优集　 　 181
8.4　 SQL概要和SQL调优顾问　 　 182
8.4.1　 使用DBMS_SQLTUNE　 　 183
8.4.2　 索引建议　 　 185
8.4.3　 企业管理器中的SQL优化　 　 186
8.4.4　 使用SQL访问顾问进行交叉SQL调优　 　 187
8.5　 SQL基线　 　 189
8.5.1　 创建基线　 　 189
8.5.2　 进化基线　 　 191
8.5.3　 自动化和配置基线　 　 194
8.5.4　 固化的基线　 　 194
8.5.5　 在ORACLE 企业管理器中管理基线　 　 195
8.6　 本章小结　 　 195
第9章　 表访问调优　 　 197
9.1　 单值查询　 　 197
9.1.1　 在表和索引扫描间选择　 　 198
9.1.2　 位图索引和单值查询　 　 201
9.1.3　 散列聚簇和单值查询　 　 202
9.2　 避免“意外的”表扫描　 　 203
9.2.1　 不等条件　 　 203
9.2.2　 空值查询　 　 205
9.2.3　 查找非空值　 　 207
9.2.4　 在可为空的列上创建索引　 　 207
9.2.5　 无意中通过使用函数而禁用了索引　 　 208
9.2.6　 函数索引　 　 208
9.2.7　 函数索引和统计　 　 209
9.2.8　 虚拟列　 　 211
9.3　 多列查询　 　 212
9.3.1　 使用组合索引　 　 212
9.3.2　 索引合并　 　 213
9.3.3　 唯一性与覆盖索引　 　 213
9.4　 查找范围　 　 214
9.4.1　 无界范围扫描　 　 214
9.4.2　 有界范围扫描　 　 216
9.4.3　 范围查询　 　 217
9.5　 使用LIKE运算符　 　 219
9.6　 多值单列查找　 　 220
9.7　 优化必要的全表扫描　 　 221
9.7.1　 降低高水位线　 　 221
9.7.2　 优化PCTFREE和PCTUSED　 　 222
9.7.3　 减少记录长度　 　 223
9.7.4　 压缩表　 　 223
9.7.5　 使数据库IO更高效　 　 225
9.7.6　 使用抽样选项　 　 225
9.7.7　 并行查询　 　 226
9.7.8　 快速全索引扫描　 　 227
9.7.9　 分区　 　 228
9.8　 本章小结　 　 229
第10章　 联结与子查询　 　 231
10.1　 联结类型　 　 231
10.2　 联结方法　 　 232
10.2.1　 嵌套循环联结　 　 232
10.2.2　 排序合并联结　 　 233
10.2.3　 散列联结　 　 234
10.3　 选择正确的联结方法　 　 235
10.3.1　 排序合并/散列与嵌套循环的对比　 　 235
10.3.2　 排序合并和散列联结对比　 　 235
10.4　 优化联结　 　 239
10.4.1　 优化嵌套循环联结　 　 239
10.4.2　 优化排序合并联结与散列联结　 　 240
10.5　 避免联结　 　 241
10.5.1　 反范式化　 　 242
10.5.2　 索引聚簇　 　 242
10.5.3　 物化视图　 　 243
10.5.4　 位图联结索引　 　 244
10.6　 联结顺序　 　 244
10.7　 特殊联结　 　 246
10.7.1　 外联结　 　 246
10.7.2　 星型联结　 　 248
10.7.3　 层级查询　 　 252
10.8　 子查询　 　 254
10.8.1　 简单子查询　 　 254
10.8.2　 关联子查询　 　 256
10.8.3　 反联结子查询　 　 257
10.8.4　 半联结子查询　 　 259
10.9　 本章小结　 　 260
第11章　 排序、分组与集合操作　 　 261
11.1　 排序操作　 　 261
11.1.1　 最优、一次和多次排序　 　 262
11.1.2　 衡量排序活动　 　 263
11.1.3　 跟踪排序活动　 　 264
11.1.4　 使用索引规避排序　 　 265
11.2　 分组与聚合　 　 267
11.2.1　 聚合操作　 　 267
11.2.2　 最大值和最小值　 　 268
11.2.3　 “前N”查询　 　 269
11.2.4　 计算一张表的记录数　 　 271
11.2.5　 分组操作　 　 271
11.2.6　 HAVING与WHERE　 　 273
11.3　 集合操作　 　 274
11.3.1　 UNION与UNION ALL　 　 275
11.3.2　 INTERSECT　 　 275
11.3.3　 MINUS　 　 277
11.3.4　 集合操作和它们的替代方法　 　 278
11.4　 本章小结　 　 279
第12章　 使用和调优PL/SQL　 　 280
12.1　 PL/SQL的性能优势　 　 280
12.1.1　 过程化的方法　 　 280
12.1.2　 减少网络开销　 　 280
12.1.3　 分解并攻克海量的SQL语句　 　 281
12.2　 衡量PL/SQL的性能　 　 281
12.2.1　 衡量PL/SQL的开销　 　 281
12.2.2　 使用DBMS_PROFILER　 　 283
12.2.3　 11g的分层剖析器　 　 284
12.3　 数据访问优化　 　 287
12.3.1　 数组处理和BULK COLLECT　 　 287
12.3.2　 对INSERT语句进行数组处理　 　 289
12.3.3　 绑定变量和动态SQL　 　 290
12.4　 PL/SQL代码优化　 　 292
12.4.1　 首先调优SQL　 　 292
12.4.2　 PLSQL_OPTIMIZE_LEVEL　 　 292
12.4.3　 循环优化　 　 293
12.4.4　 “短路”表达式　 　 295
12.4.5　 在IF和CASE语句中表达式的顺序　 　 297
12.4.6　 递归　 　 298
12.4.7　 NOCOPY子句　 　 299
12.4.8　 关联数组　 　 301
12.5　 其他优化　 　 302
12.5.1　 本地编译　 　 302
12.5.2　 内联PL/SQL　 　 304
12.5.3　 数据类型　 　 306
12.5.4　 使用JAVA计算　 　 307
12.5.5　 函数缓存　 　 308
12.6　 DML触发器的性能　 　 309
12.6.1　 UPDATE OF和WHEN子句　 　 309
12.6.2　 BEFORE和AFTER ROW触发器　 　 310
12.7　 本章小结　 　 311
第13章　 并行SQL　 　 312
13.1　 理解并行SQL　 　 312
13.1.1　 并行进程和并行度　 　 314
13.1.2　 并行子进程池　 　 315
13.1.3　 并行查询IO　 　 316
13.1.4　 并行性能收益　 　 316
13.2　 决定何时使用并行处理　 　 317
13.2.1　 服务器计算机有多个CPU　 　 318
13.2.2　 被访问的数据放置在多个磁盘驱动器上　 　 318
13.2.3　 使用并行的SQL是长时间运行的或者资源敏感的　 　 318
13.2.4　 SQL执行最少一次全表、索引或分区扫描　 　 319
13.2.5　 主机有空闲的能力　 　 319
13.2.6　 SQL是调优过的　 　 319
13.3　 配置并行处理　 　 319
13.3.1　 确定并行度　 　 319
13.3.2　 并行提示　 　 321
13.3.3　 并行配置的参数　 　 321
13.4　 监控并行SQL　 　 323
13.4.1　 并行语句的执行计划　 　 323
13.4.2　 跟踪并行执行　 　 325
13.4.3　 V$PQ_TQSTAT视图　 　 326
13.4.4　 其他的统计数据　 　 327
13.5　 优化并行的性能　 　 328
13.5.1　 从一个优化过的串行执行的SQL开始　 　 328
13.5.2　 确保这个SQL适合并行执行　 　 329
13.5.3　 确保系统适合配置支持并行执行　 　 329
13.5.4　 确保执行计划的所有部分都做了并行化　 　 329
13.5.5　 确保请求的并行度是可实现的　 　 331
13.5.6　 监控实际的并行度　 　 331
13.5.7　 检查进程间数据和负载的偏差　 　 332
13.6　 其他的并行主题　 　 333
13.6.1　 RAC的并行执行　 　 333
13.6.2　 并行的索引查找　 　 334
13.6.3　 并行DML　 　 335
13.6.4　 并行DDL　 　 339
13.7　 本章小结　 　 340
第14章　 DML调优　 　 342
14.1　 DML性能基础　 　 342
14.1.1　 Where子句优化　 　 342
14.1.2　 索引开销　 　 343
14.1.3　 触发器开销　 　 344
14.1.4　 参照完整性　 　 345
14.2　 INSERT操作的特定优化　 　 346
14.2.1　 批量处理　 　 346
14.2.2　 直接路径插入　 　 347
14.2.3　 多表插入　 　 349
14.2.4　 手动段存储管理（MSSM）和空闲列表　 　 351
14.2.5　 并行DML　 　 351
14.3　 删除操作　 　 351
14.3.1　 TRUNCATE　 　 351
14.3.2　 分区　 　 352
14.3.3　 CREATE TABLE AS SELECT　 　 352
14.4　 更新和合并操作　 　 353
14.4.1　 关联更新　 　 353
14.4.2　 优化MERGE操作　 　 355
14.5　 COMMIT优化　 　 357
14.5.1　 COMMIT频率　 　 358
14.5.2　 批量和NOWAIT提交　 　 358
14.5.3　 NOLOGGING　 　 360
14.6　 本章小结　 　 361
第四部分　 最小化争用
第15章　 锁争用　 　 364
15.1　 锁的类型和模式　 　 364
15.2　 等待锁　 　 367
15.3　 监控和分析锁　 　 368
15.3.1　 锁等待的统计数据　 　 368
15.3.2　 发现导致锁争用的SQL　 　 371
15.3.3　 度量指定事务的锁争用　 　 373
15.3.4　 跟踪锁行为　 　 375
15.3.5　 阻塞者和等待者　 　 376
15.4　 应用程序的锁策略　 　 379
15.5　 行级锁什么时候会失败　 　 380
15.5.1　 没有索引的外键　 　 380
15.5.2　 事务表等待　 　 381
15.5.3　 位图索引　 　 382
15.5.4　 直接路径插入　 　 383
15.6　 系统锁　 　 383
15.6.1　 高水位标记enqueue　 　 384
15.6.2　 空间事务enqueue　 　 384
15.6.3　 序列缓存enqueue　 　 384
15.6.4　 用户锁enqueue　 　 385
15.6.5　 其他的系统锁　 　 385
15.7　 本章小结　 　 386
第16章　 闩锁和互斥争用　 　 387
16.1　 闩锁和互斥架构的简介　 　 387
16.1.1　 GETS、SPINS和SLEEPS　 　 388
16.1.2　 互斥　 　 388
16.2　 度量和诊断闩锁/互斥争用　 　 389
16.2.1　 识别单个的闩锁　 　 390
16.2.2　 发现与闩锁等待相关的SQL和段　 　 391
16.3　 特定的闩锁和互斥场景　 　 392
16.3.1　 Library Cache Mutex等待　 　 393
16.3.2　 Library Cache Pin　 　 394
16.3.3　 Shared Pool Latch　 　 395
16.3.4　 Cache Buffers Chains Latch　 　 395
16.3.5　 Row Cache Object闩锁　 　 397
16.3.6　 其他的闩锁场景　 　 398
16.4　 闩锁争用是不可避免的吗　 　 399
16.4.1　 改变_SPIN_COUNT怎么样　 　 399
16.4.2　 自旋计数、闩锁争用和吞吐量　 　 400
16.4.3　 设置单个闩锁的自旋计数　 　 402
16.5　 本章小结　 　 402
第17章　 共享内存争用　 　 404
17.1　 缓冲区高速缓存架构　 　 404
17.2　 空闲缓冲块等待　 　 406
17.2.1　 DBWR直接和异步IO　 　 407
17.2.2　 空闲缓冲块等待的其他补救措施　 　 409
17.3　 恢复写进程等待　 　 410
17.3.1　 提高闪回日志IO　 　 411
17.3.2　 增加闪回日志缓冲的大小　 　 412
17.4　 缓冲忙等待　 　 414
17.4.1　 度量缓冲忙　 　 414
17.4.2　 缓冲忙等待的传统原因　 　 414
17.4.3　 缓冲忙和热块　 　 415
17.5　 重做日志缓冲等待　 　 417
17.6　 本章小结　 　 419
第五部分　 优化内存
第18章　 缓冲区高速缓存调优　 　 422
18.1　 缓冲区高速缓存的原理　 　 422
18.1.1　 最近最少使用列表　 　 423
18.1.2　 表扫描处理　 　 423
18.1.3　 CACHE属性　 　 424
18.1.4　 直接路径IO　 　 424
18.2　 缓冲区高速缓存配置和调优　 　 425
18.2.1　 监控缓冲区高速缓存　 　 425
18.2.2　 缓冲区高速缓存命中率　 　 426
18.2.3　 多个缓冲区高速缓存　 　 428
18.2.4　 设置缓冲区高速缓存的大小　 　 430
18.3　 自动共享内存管理　 　 433
18.3.1　 实现ASMM　 　 433
18.3.2　 监控重设大小操作　 　 434
18.3.3　 调优ASMM　 　 435
18.3.4　 非默认池　 　 436
18.3.5　 内存抖动　 　 437
18.4　 本章小结　 　 439
第19章　 优化PGA内存　 　 440
19.1　 IO和PGA内存　 　 440
19.2　 PGA内存管理　 　 441
19.2.1　 PGA_AGGREGATE_TARGET　 　 441
19.2.2　 会话的PGA限制　 　 442
19.3　 测量PGA的使用和效率　 　 443
19.3.1　 会话的PGA利用率　 　 445
19.3.2　 测量临时IO等待时间　 　 446
19.3.3　 测量工作区活动　 　 448
19.4　 用V$PGA_TARGET_ADVICE来设置PGA的大小　 　 449
19.5　 覆写PGA总量目标　 　 452
19.6　 本章小结　 　 454
第20章　 其他的内存管理主题　 　 455
20.1　 优化整体的Oracle内存　 　 455
20.1.1　 IO等待时间和内存优化　 　 455
20.1.2　 使用顾问来分配PGA和缓冲区高速缓存的内存　 　 458
20.1.3　 Oracle 11g的自动化内存管理　 　 464
20.2　 结果集缓存　 　 470
20.2.1　 启用和配置结果集缓存　 　 471
20.2.2　 结果集缓存的统计数据　 　 471
20.2.3　 结果集缓存的依赖　 　 474
20.2.4　 结果集缓存闩锁　 　 474
20.3　 其他的内存优化　 　 476
20.3.1　 设置共享池的大小　 　 476
20.3.2　 设置大池的大小　 　 478
20.3.3　 重做日志缓存　 　 478
20.3.4　 锁定SGA　 　 478
20.4　 本章小结　 　 479
第六部分　 IO调优和集群
第21章　 磁盘IO调优基础　 　 482
21.1　 磁盘IO的概念　 　 482
21.1.1　 服务时间和吞吐量　 　 482
21.1.2　 排队　 　 483
21.1.3　 磁盘驱动器：慢和正在变得更慢　 　 483
21.1.4　 磁盘容量和数据分布　 　 484
21.2　 Oracle IO架构　 　 484
21.2.1　 数据文件单块读　 　 485
21.2.2　 多块读　 　 485
21.2.3　 直接路径读　 　 486
21.2.4　 临时直接路径IO　 　 486
21.2.5　 数据文件写IO　 　 486
21.2.6　 直接路径写　 　 487
21.2.7　 重做日志IO　 　 487
21.2.8　 归档日志IO　 　 487
21.2.9　 闪回IO　 　 488
21.2.10　 控制文件IO　 　 488
21.3　 度量和监控Oracle IO　 　 488
21.3.1　 IO等待次数　 　 488
21.3.2　 监控数据文件IO　 　 492
21.3.3　 IO基准测试　 　 494
21.4　 优化数据文件IO　 　 495
21.4.1　 最小化IO延时　 　 495
21.4.2　 最大化IO吞吐量　 　 496
21.4.3　 条带化策略　 　 497
21.4.4　 RAID阵列　 　 497
21.4.5　 隔离数据文件IO　 　 500
21.5　 重做和归档优化　 　 500
21.5.1　 交替和分发日志　 　 501
21.5.2　 重做和归档设备的细粒度条带化　 　 501
21.5.3　 对重做日志使用RAID5大声说不　 　 502
21.5.4　 重做日志大小　 　 503
21.6　 闪回日志　 　 506
21.7　 本章小结　 　 507
第22章　 高级IO技术　 　 508
22.1　 自动存储管理　 　 508
22.1.1　 ASM架构　 　 509
22.1.2　 ASM监控　 　 510
22.1.3　 ASM调优　 　 515
22.2　 固态磁盘（SSD）　 　 520
22.2.1　 基于闪存的SSD　 　 520
22.2.2　 基于随机存储器的DDR
SSD　 　 520
22.2.3　 混合的SSD　 　 521
22.2.4　 为Oracle数据库使用SSD　 　 521
22.3　 EXADATA存储服务器　 　 522
22.4　 数据库块大小　 　 522
22.5　 本章小结　 　 524
第23章　 优化RAC　 　 525
23.1　 RAC概览　 　 525
23.1.1　 全局缓存请求　 　 526
23.1.2　 RAC调优原则　 　 528
23.1.3　 单实例调优和RAC　 　 528
23.2　 度量集群开销　 　 529
23.3　 减少全局缓存延时　 　 532
23.3.1　 度量全局缓存延时　 　 532
23.3.2　 检查内部互连　 　 534
23.3.3　 内部互连问题的信号　 　 536
23.4　 优化内部互连　 　 537
23.4.1　 网络硬件和协议　 　 537
23.4.2　 以太网特大帧　 　 537
23.4.3　 UDP缓冲大小　 　 538
23.4.4　 LMS等待　 　 539
23.5　 集群负载均衡　 　 541
23.5.1　 评估集群负载均衡　 　 541
23.5.2　 集群负载均衡和服务　 　 544
23.5.3　 RAC负载均衡服务　 　 547
23.6　 最小化全局缓存请求　 　 548
23.6.1　 高的全局缓存请求比例的原因　 　 548
23.6.2　 度量全局缓存请求比例　 　 549
23.6.3　 减少全局缓存请求的技巧　 　 550
23.7　 本章小结　 　 551
参考书目　 　 552

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle性能优化求生指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle应用、开发与管理系列·OCP认证考试指南全册Oracle Database 10g
第Ⅰ部分  Oracle Database 10g AdministrativeⅠExam第1章  Oracle的基本概念	31.1  数据库入门与关系模型	41.1.1  数据库管理系统的关系模型	41.1.2  SQL：结构化查询语言	61.1.3  对象关系数据库管理系统	71.2  数据库对象	71.3  数据库管理员的职责	101.4  Oracle产品系列	111.5  章节回顾	121.5.1  问题	121.5.2  答案	13第2章  安装Oracle Database 10g	152.1  Oracle系统的要求	162.2  最优灵活体系结构	172.2.1  字典与装载点语法	172.2.2  文件命名语法	192.3  使用Oracle Universal Installer安装Oracle	202.3.1  操作系统的准备	202.3.2  安装Oracle软件	222.4  练习2-1：安装Oracle Database 10g	332.5  章节回顾	352.5.1  问题	352.5.2  答案	37第3章  创建Oracle数据库	393.1  Oracle服务器的体系结构	403.1.1  实例：存储结构与进程	413.1.2  数据库：物理结构	433.1.3  逻辑结构：表空间与段	443.1.4  数据字典	453.1.5  管理工具	453.1.6  外部文件	463.2  创建一个数据库	473.3  练习3-1：使用Database Configuration Assistant创建一个数据库	483.4  数据库创建脚本	503.5  DBCA的其他功能	543.6  章节回顾	553.6.1  问题	553.6.2  答案	57第4章  接合Oracle数据库	594.1  SQL的使用	604.1.1  SELECT语句	614.1.2  使用INSERT、UPDATE与DELETE语句操纵数据	654.1.3  数据定义语言	684.1.4  数据库、系统与会话管理命令	694.2  理解PL/SQL	694.3  Oracle 10g中的查询工具	714.3.1  SQL*Plus	714.3.2  iSQL*Plus	724.4  练习4-1：调用SQL*Plus	744.5  练习4-2：连接iSQL*Plus	754.6  接合Oracle数据库的其他方法	784.6.1  Oracle中的Java	784.6.2  Oracle调用接口	784.6.3  其他API	794.7  章节回顾	804.7.1  问题	804.7.2  答案	82第5章  管理Oracle进程	855.1  启动SQL*Plus	865.2  启动iSQL*Plus	865.3  启动Database Listener	875.4  启动Database Control端口监控程序	885.5  数据库的启动与关闭	905.5.1  使用正确的权限进行连接	905.5.2  SYSOPER与SYSDBA	915.5.3  startup命令	915.6  练习5-1：使用SQL*Plus启动和关闭数据库	935.6.1  shutdown命令	955.6.2  实例恢复	965.7  练习5-2：使用Database Control打开与关闭数据库	975.8  初始化文件	985.9  练习5-3：使用Database Control查看各种参数	995.10  章节回顾	995.10.1  问题	995.10.2  答案	101第6章  管理Oracle存储结构	1036.1  基本的Oracle存储结构：表空间与数据文件	1046.1.1  物理存储结构	1056.1.2  逻辑存储结构	1066.2  创建与管理表空间	1106.2.1  CREATE TABLESPACE命令	1116.2.2  修改表空间	1116.2.3  删除表空间	1126.3  练习6-1：使用Enterprise Manager创建表空间	1126.4  练习6-2：使用Enterprise Manager更改表空间	1186.5  练习6-3：使用Enterprise Manager删除表空间	12023.3.4  通道分配	45623.3.5  RMAN备份的内容	45723.3.6  配置备份的保留	45923.3.7  重写默认配置	45923.4  练习23-1：配置RMAN	46023.5  章节回顾	46023.5.1  问题	46123.5.2  答案	463第24章  使用RMAN备份数据库	46524.1  batch模式中的RMAN	46624.2  RMAN管道接口	46724.3  使用RMAN可执行程序进行备份	46724.3.1  独立命令与作业/命令块命令	46824.3.2  创建备份集	46824.4  练习24-1：创建备份集	47024.4.1  生成映像副本	47224.4.2  用于备份集与映像副本的标记	47324.4.3  增量备份	47324.4.4  合并增量备份与映像副本	47524.5  块变化跟踪	47624.6  管理与监视RMAN备份	47724.6.1  LIST、REPORT与DELETE命令	47724.6.2  动态视图	47924.7  练习24-2：管理备份	47924.8  章节回顾	48024.8.1  问题	48024.8.2  答案	483第25章  诊断Oracle数据库的问题	48525.1  告警日志	48625.2  后台跟踪文件	48825.3  服务器生成的告警	48925.3.1  告警类型	49025.3.2  告警系统体系结构	49025.3.3  查看告警信息	49125.3.4  建立通知规则	49325.3.5  编辑阈值	49425.4  练习25-1：设置、查看以及清除告警	49525.5  用户跟踪文件	49625.5.1  实例级别的SQL跟踪	49725.5.2  会话级别的SQL跟踪	49725.5.3  使用Database Control进行跟踪	49825.6  章节回顾	49925.6.1  问题	49925.6.2  答案	501第26章  恢复非关键的损失	50326.1  恢复受损的临时表空间	50426.1.1  临时数据	50426.1.2  临时空间的配置	50526.1.3  临时文件受损的情况	50526.1.4  还原临时表空间	50626.2  恢复受损的联机重做日志文件	50726.2.1  联机重做日志文件的配置	50726.2.2  联机重做日志文件成员受损的情况	50826.2.3  重建受损的联机重做日志文件成员	50926.3  恢复受损的索引表空间	51126.3.1  索引表空间	51126.3.2  索引表空间受损的情况	51226.3.3  恢复索引表空间	51326.4  练习26-1：使用索引表空间	51426.5  恢复受损的只读表空间	51526.5.1  备份只读表空间	51626.5.2  恢复只读表空间	51626.6  恢复受损的口令文件	51726.6.1  口令文件受损的情况	51726.6.2  替换口令文件	51826.7  章节回顾	51826.7.1  问题	51826.7.2  答案	520第27章  数据库的不完全恢复	52127.1  完全恢复	52227.2  需要进行不完全恢复的场合	52327.3  不完全恢复的方法	52427.3.1  不完全恢复的各种选项	52527.3.2  不完全恢复的最优方法	52627.4  使用用户托管的备份进行不完全恢复	52627.4.1  UNTIL TIME恢复	52627.4.2  UNTIL CANCEL恢复	52727.4.3  UNTIL CHANGE恢复	52727.5  使用RMAN的不完全恢复	52827.5.1  UNTIL TIME恢复	52827.5.2  UNTIL SEQUENCE恢复	52927.5.3  UNTIL SCN恢复	52927.6  练习27-1：使用RMAN执行不完全恢复	53027.7  使用Enterprise Manager进行不完全恢复	53127.8  控制文件的恢复	53327.8.1  创建新的控制文件	53327.8.2  使用用户托管的备份还原控制文件	53527.8.3  使用RMAN还原控制文件	53527.9  练习27-2：实现控制文件的自动备份与还原	53627.10  使用RESETLOGS操作进行恢复	53827.11  章节回顾	53827.11.1  问题	53927.11.2  答案	542第28章  使用Oracle Flashback Database	54528.1  不同的闪回方法	54628.1.1  Flashback Database	54628.1.2  Flashback Query(Versions、Transaction、Table)	54628.1.3  Flashback Drop	54728.1.4  使用闪回方法的场合	54828.2  Flashback Database的体系结构	54928.3  配置Flashback Database	55028.4  练习28-1：使用Database Control配置Flashback Database	55128.5  监视Flashback Database	55228.6  使用Flashback Database	55328.6.1  使用SQL*Plus进行闪回	55428.6.2  使用RMAN进行闪回	55528.6.3  使用Database Control进行闪回	55528.7  练习28-2：通过Database Control使用Flashback Database	55528.8  管理闪回恢复区	55728.8.1  闪回恢复区内的空间使用	55728.8.2  备份闪回恢复区	55928.9  限制所生成的闪回数据量	56028.9.1  将表空间排除在闪回之外	56028.9.2  在某些表空间没有生成闪回数据时所进行的闪回	56128.10  章节回顾	56128.10.1  问题	56228.10.2  答案	563第29章  恢复用户错误	56529.1  闪回与ACID测试	56629.2  Flashback Drop	56629.2.1  Flashback Drop的实现	56729.2.2  使用Flashback Drop	56829.3  练习29-1：通过SQL*Plus使用Flashback Drop	57029.4  管理回收站	57129.4.1  查询回收站	57129.4.2  收回回收站的空间	57229.5  Flashback Query	57429.5.1  基本的Flashback Query	57429.5.2  Flashback Table Query	57629.5.3  Flashback Versions Query	57829.5.4  Flashback Transaction Query	57929.6  练习29-2：通过Database Control使用Flashback Query	58129.7  闪回与撤销数据	58329.8  章节回顾	58429.8.1  问题	58429.8.2  答案	587第30章  检测与恢复数据库的讹误	58930.1  块讹误及其原因	59030.2  与块讹误相关的参数	59030.3  检测块讹误	59130.3.1  块讹误生成的错误消息	59130.3.2  DBVERIFY实用程序	59230.3.3  ANALYZE命令	59430.3.4  DBMS_REPAIR程序包	59430.4  练习30-1：检查块讹误	59630.5  使用RMAN恢复讹误块	59730.5.1  讹误块的检测	59830.5.2  块介质恢复	59830.5.3  BLOCKRECOVER命令	59930.6  练习30-2：实现块介质恢复	60030.7  处理讹误	60030.8  章节回顾	60130.8.1  问题	60230.8.2  答案	604第31章  用于调整Oracle Database 10g的工具	60531.1  顾问程序方法	60631.2  ADDM	60731.3  各种顾问程序	60831.3.1  SQL Tuning Advisor	60931.3.2  SQL Access Advisor	61131.3.3  Memory Advisor	61131.3.4  MTTR Advisor	61331.3.5  Segment Advisor	61331.3.6  Undo Advisor	61431.4  练习31-1：使用SQL Tuning Advisor	61431.5  自动的撤销保留调整	61631.6  章节回顾	61731.6.1  问题	61731.6.2  答案	618第32章  监视与管理存储结构	61932.1  联机与归档重做日志文件的存储	62032.1.1  磁盘I/O与联机重做日志文件	62032.1.2  日志切换与性能	62132.1.3  归档日志文件与性能	62232.2  空间错误与可恢复语句	62232.2.1  与空间相关的常见错误	62232.2.2  数据文件的自动扩展	62332.2.3  可恢复语句	62432.3  练习32-1：使用可恢复语句	62632.4  监视表空间使用的告警	62732.5  练习32-2：使用告警系统监视表空间的使用情况	62932.6  监视与管理段的大小	63032.6.1  估计段的大小	63132.6.2  缩小表段	63132.6.3  缩小索引段	63332.6.4  重构索引段	63432.6.5  监视索引的使用	63532.7  练习32-3：使用Database Control Segment Advisor缩小一个表	63632.8  交替的表存储结构	63732.8.1  索引组织表	63832.8.2  索引群集表	64132.8.3  散列群集表	64232.8.4  有序散列群集表	64232.9  章节回顾	64332.9.1  问题	64432.9.2  答案	646第33章  使用Automatic Storage Management管理存储结构	64933.1  逻辑卷管理器的目的	65033.1.1  RAID级别	65033.1.2  卷大小	65133.1.3  RAID级别的选择	65133.1.4  ASM与第三方LVM的比较	65233.2  ASM体系结构	65233.2.1  ASM磁盘与磁盘组	65233.2.2  ASM实例	65333.2.3  RDBMS实例	65433.2.4  ASM文件	65433.3  创建原始设备	65533.4  练习33-1：在Windows系统中创建原始设备	65633.5  创建、启动与停止ASM实例	65833.6  练习33-2：在Windows系统中创建一个ASM实例	66033.7  创建ASM磁盘组	66133.8  练习33-3：在Windows系统中创建一个磁盘组	66133.9  创建与使用ASM文件	66233.10  练习33-4：将ASM用于数据文件	66333.11  ASM与RMAN	66333.12  ASM与Linux	66433.13  章节回顾	66533.13.1  问题	66633.13.2  答案	668第34章  监视与管理内存	67134.1  系统全局区	67234.2  共享池	67334.3  数据库高速缓存区	67534.3.1  LRU列表与检查点队列	67634.3.2  默认池、保持池与回收池	67734.3.3  非标准块大小池	67834.3.4  分配数据库高速缓存区的大小	68034.4  日志缓冲区	68134.5  其他SGA区	68134.5.1  大池	68234.5.2  Java池	68234.5.3  流池	68334.6  Automatic Shared Memory Management	68334.7  练习34-1：使用Automatic Shared Memory Management	68634.8  程序全局区	68734.9  章节回顾	69034.9.1  问题	69034.9.2  答案	693第35章  管理Oracle数据库资源	69535.1  资源管理的需求	69635.2  Resource Manager的体系结构	69735.2.1  用户组	69735.2.2  Resource Manager计划	69835.2.3  Resource Manager配置工具	69935.3  管理用户与用户组	70035.4  练习35-1：管理资源用户组中的用户	70035.5  Resource Manager计划	70235.5.1  CPU方法	70335.5.2  活动会话池方法	70635.5.3  限制并行度	70735.5.4  通过执行时间控制作业	70835.5.5  通过空闲时间终止会话	70835.5.6  限制撤销数据的生成	71035.5.7  自动的用户组切换	71135.6  练习35-2：配置与测试自动的用户组切换	71135.7  Resource Manager的其他功能	71335.7.1  停顿数据库	71335.7.2  针对一个调用的用户组切换	71435.7.3  使用比例CPU方法	71535.7.4  创建一个简单的计划	71535.7.5  适应用户组映射	71635.8  章节回顾	71735.8.1  问题	71835.8.2  答案	721第36章  自动化管理任务	72336.1  Scheduler的体系结构	72436.2  Scheduler对象	72436.2.1  作业	72436.2.2  程序	72636.2.3  调度	72636.2.4  作业类	72736.2.5  窗口	72836.2.6  权限	72936.3  创建与调度作业	72936.4  练习36-1：使用Scheduler API创建一个作业	73036.5  使用程序与调度	73036.6  使用作业类、窗口与Resource Manager	73336.6.1  使用作业类	73336.6.2  使用窗口	73436.7  预配置的作业	73536.8  章节回顾	73736.8.1  问题	73736.8.2  答案	739附录  关于本书合作站点	741术语表		7436.6  查看表空间信息	1216.7  章节回顾	1226.7.1  问题	1236.7.2  答案	125第7章  管理数据库用户	1277.1  创建与管理数据库用户	1287.1.1  用户与模式	1287.1.2  创建用户	1287.1.3  修改用户属性	1307.1.4  删除用户	1317.2  练习7-1：使用Enterprise Manager创建数据库用户	1327.3  授予与取消权限	1347.3.1  系统权限	1347.3.2  对象权限	1377.4  练习7-2：使用Enterprise Manager授予系统权限	1407.5  练习7-3：使用Enterprise Manager授予对象权限	1447.6  创建与管理角色	1477.7  练习7-4：使用Enterprise Manager创建与管理角色	1547.8  利用配置文件控制资源的使用	1567.8.1  利用配置文件实施资源限制	1577.8.2  创建、更改以及删除配置文件	1587.8.3  为用户指派配置文件	1597.9  练习7-5：使用Enterprise Manager创建与管理配置文件	1597.10  章节回顾	1637.10.1  问题	1647.10.2  答案	166第8章  管理数据库对象	1698.1  用户、模式以及模式对象	1708.1.1  用户与模式	1708.1.2  命名模式对象	1708.1.3  对象命名空间	1728.2  数据类型	1738.3  创建表	1758.4  创建约束	1778.5  练习8-1：创建表与约束	1788.6  创建索引	1818.7  创建视图	1828.8  创建与使用序列	1848.9  练习8-2：使用约束、视图以及序列	1848.10  章节回顾	1858.10.1  问题	1868.10.2  答案	187第9章  操纵数据库数据	1899.1  数据库事务	1909.1.1  原子性(A)	1909.1.2  一致性(C)	1909.1.3  隔离性(I)	1909.1.4  持久性(D)	1919.2  执行SQL语句	1919.2.1  执行SELECT语句	1919.2.2  执行UPDATE语句	1929.2.3  执行INSERT与DELETE语句	1939.2.4  执行ROLLBACK命令	1939.2.5  执行COMMIT命令	1949.2.6  DDL与事务控制	1959.2.7  所谓的“自动提交”	1959.3  练习9-1：事务的隔离性、读一致性以及提交	1969.4  DML与完整性约束	1969.5  Data Pump	1979.5.1  Data Pump的体系结构	1989.5.2  目录	1999.5.3  直接路径与外部表路径	2009.5.4  在网络模式中使用Data Pump	2019.6  练习9-2：使用Data Pump通过Enterprise Manager Database Control导出表	2029.7  练习9-3：使用Data Pump通过impdp导入表	2049.8  SQL*Loader	2049.8.1  SQL*Loader控制文件	2059.8.2  数据加载方法	2079.9  练习9-4：使用SQL*Loader	2079.10  章节回顾	2089.10.1  问题	2089.10.2  答案	211第10章  使用PL/SQL进行Oracle编程	21310.1  编程语言与Oracle数据库	21410.1.1  SQL与过程语言	21410.1.2  存储的与匿名的PL/SQL程序块	21410.1.3  PL/SQL对象	21510.2  过程、函数以及程序包	21610.2.1  过程与函数	21610.2.2  程序包	21710.3  练习10-1：创建与使用函数、过程以及程序包	21810.4  数据库触发器	21910.5  练习10-2：使用DML触发器	22110.6  用于PL/SQL的实例参数	22210.7  章节回顾	22310.7.1  问题	22310.7.2  答案	224第11章  保护Oracle数据库的安全	22511.1  调整默认的安全设置	22611.1.1  默认的用户	22611.1.2  PUBLIC权限	22711.2  对安全性至关重要的实例参数	22811.2.1  UTL_FILE_DIR实例参数	22911.2.2  REMOTE_OS_AUTHENT与OS_AUTHEN_PREFIX实例参数	22911.2.3  O7_DICTIONARY_ACCESSIBILITY实例参数	23011.2.4  REMOTE_LOGIN_PASSWORDFILE实例参数	23111.3  口令配置文件	23211.3.1  口令配置文件的限制	23211.3.2  口令验证功能	23311.3.3  创建、指派以及修改口令配置文件	23411.4  练习11-1：创建与使用口令配置文件	23511.5  审计	23711.5.1  审计SYSDBA活动	23711.5.2  数据库审计	23811.5.3  基于值的审计	24111.5.4  细粒度审计	24211.6  练习11-2：启用审计	24311.7  安全更新	24511.8  章节回顾	24511.8.1  问题	24511.8.2  答案	246第12章  配置Oracle互联	24912.1  Oracle的客户/服务器实现	25012.2  Oracle Net与通信协议简介	25112.3  建立会话	25112.3.1  连接本地实例	25212.3.2  名称解析	25312.3.3  启动服务器进程	25312.4  创建与管理侦听器	25412.5  练习12-1：使用Database Control创建侦听器	25412.6  数据库注册	25512.6.1  静态注册	25612.6.2  动态注册	25712.7  侦听器控制实用程序	25712.8  名称解析技术	25912.8.1  Easy Connect名称解析方法	26012.8.2  本地名称解析方法	26012.8.3  目录名称解析方法	26112.8.4  外部名称解析方法	26112.9  配置服务别名	26112.10  练习12-2：创建一个Oracle Net服务别名	26212.11  练习12-3：配置动态服务注册	26312.12  高级的连接选项	26312.13  测试Oracle Net连接	26612.14  章节回顾	26712.14.1  问题	26712.14.2  答案	270第13章  管理共享服务器	27113.1  专用服务器体系结构的局限性	27213.2  共享服务器体系结构	27313.3  配置共享服务器	27513.4  练习13-1：配置与验证共享服务器	27713.5  监视共享服务器	27813.6  使用共享服务器的场合	27913.6.1  适合使用共享服务器的应用	27913.6.2  控制共享服务器的使用	28013.7  练习13-2：配置客户机选择连接类型	28013.8  章节回顾	28113.8.1  问题	28213.8.2  答案	284第14章  管理数据库性能	28714.1  无效的对象	28814.1.1  标识无效的对象	28814.1.2  修正无效的对象	28914.2  练习14-1：修正无效的对象	29014.3  无用的索引	29214.3.1  标识无用的索引	29214.3.2  修正无用的索引	29314.4  练习14-2：修正无用的索引	29414.5  优化器统计	29514.5.1  对象统计量	29614.5.2  收集统计量	29714.6  练习14-3：自动化统计量收集	30014.7  性能指标	30114.7.1  使用动态性能视图查看统计量	30114.7.2  使用Database Control查看性能指标	30314.8  对性能问题作出的反应	30314.9  章节回顾	30414.9.1  问题	30514.9.2  答案	306第15章  监视Oracle	30715.1  自动工作负荷仓库	30815.1.1  收集统计量	30815.1.2  AWR的大小与位置	30915.1.3  快照的保存	31015.2  诊断与调整顾问程序	31015.2.1  ADDM顾问程序	31015.2.2  SQL Tuning Advisor与SQL Access Advisor	31215.2.3  Memory Advisor	31315.2.4  MTTR Advisor	31315.2.5  Segment Advisor	31415.2.6  Undo Advisor	31415.3  练习15-1：生成ADDM报告	31415.4  服务器生成的告警	31615.4.1  告警系统体系结构	31615.4.2  设置阈值	31715.4.3  使用基线	31715.5  练习15-2：配置告警	31815.6  章节回顾	31915.6.1  问题	31915.6.2  答案	321第16章  管理撤销	32316.1  撤销数据的原因与实质	32416.2  撤销表空间	32516.3  练习16-1：使用Database Control创建撤销表空间	32616.4  事务与撤销段	32616.5  管理撤销	32816.5.1  与撤销相关的错误条件	32816.5.2  用于撤销管理与撤销保留保证的参数	32816.5.3  调整与监视撤销表空间	33016.5.4  删除与缩小撤销段	33116.6  练习16-2：使用SQL*Plus监视撤销	33216.7  章节回顾	33216.7.1  问题	33316.7.2  答案	335第17章  处理锁定	33717.1  共享锁与排他锁	33817.2  DML锁与DDL锁	33817.3  练习17-1：自动与手动锁定	33917.4  排队机制	34017.5  练习17-2：SELECT…FOR UPDATE命令	34017.6  锁定争用	34117.6.1  锁定争用的原因	34117.6.2  检测锁定争用	34317.6.3  解决锁定争用	34317.7  练习17-3：检测与解决锁定争用	34417.8  死锁	34417.9  练习17-4：自动解决死锁	34517.10  章节回顾	34617.10.1  问题	34617.10.2  答案	347第18章  配置数据库的备份与恢复	34918.1  备份与恢复问题	35018.2  失败类别	35118.2.1  语句失败	35118.2.2  用户进程失败	35318.2.3  网络失败	35318.2.4  用户错误	35418.2.5  介质失败	35518.2.6  实例失败	35618.3  实例恢复	35718.3.1  实例恢复的过程	35718.3.2  实例恢复不可能导致数据库出现讹误	35818.3.3  调整实例恢复	35918.4  练习18-1：实例恢复与MTTR	36018.5  MTTR顾问程序	36018.6  配置数据库的可恢复性	36118.6.1  保护控制文件	36118.6.2  保护联机重做日志文件	36318.6.3  archivelog模式与归档器进程	36518.7  练习18-2：复用重做日志	36618.8  练习18-3：将数据库转换至archivelog模式	36718.9  章节回顾	36818.9.1  问题	36818.9.2  答案	371第19章  备份Oracle数据库	37319.1  备份工具	37419.2  概念与术语	37419.2.1  全部备份与部分备份	37419.2.2  完整备份与增量备份	37519.2.3  脱机备份与联机备份	37619.2.4  映像副本与备份集	37719.3  RMAN的设置	37919.3.1  设备的设置	37919.3.2  备份集的设置	38019.3.3  策略的设置	38019.4  调度自动的备份	38119.5  练习19-1：运行数据库的一个完整备份	38219.6  控制文件备份	38319.7  练习19-2：使用SQL*Plus备份控制文件以便进行跟踪	38419.8  管理RMAN备份	38519.9  默认的备份目的地	38619.10  章节回顾	38719.10.1  问题	38719.10.2  答案	390第20章  恢复Oracle数据库	39120.1  恢复结构与进程	39220.2  介质失败后的恢复	39320.2.1  恢复受损的复用控制文件	39320.2.2  恢复受损的复用联机重做日志文件	39420.3  练习20-1：恢复受损的控制文件	39520.4  练习20-2：恢复受损的复用联机日志文件	39620.5  恢复受损的数据文件	39820.5.1  noarchivelog模式中数据文件的恢复	39820.5.2  archivelog模式中非重要文件的恢复	39820.5.3  恢复受损的重要数据文件	39920.6  练习20-3：恢复受损的非重要数据文件	39920.7  章节回顾	40220.7.1  问题	40220.7.2  答案	404第21章  管理Oracle数据库中的全球化特性	40721.1  全球化的需求	40821.2  全球化特性	40821.2.1  字符集	40821.2.2  语言支持	41021.2.3  地区支持	41121.2.4  其他NLS设置	41221.3  使用全球化支持功能	41321.3.1  选择字符集	41321.3.2  改变数据库字符集	41521.3.3  数据库内的全球化	41621.3.4  实例级别的全球化	41621.3.5  客户端环境设置	41621.3.6  会话级别的全球化设置	41721.3.7  语句级别的全球化设置	41721.4  练习21-1：全球化与客户机环境设置	41821.5  练习21-2：在会话内控制全球化设置	41921.6  语言排序与选择	42021.7  Locale Builder	42121.8  使用时区	42221.9  练习21-3：调整时区	42321.10  章节回顾	42421.10.1  问题	42421.10.2  答案	427第Ⅱ部分  Oracle Database 10g AdministrativeⅡExam第22章  配置侦听器的安全性	43122.1  保护侦听器的安全	43222.1.1  侦听器的操作系统身份验证	43222.1.2  侦听器的口令身份验证	43222.2  练习22-1：使用lsnrctl实用程序设置侦听器的口令	43422.3  控制对数据库的访问	43522.4  外部过程	43622.4.1  创建外部过程	43722.4.2  外部过程代理程序	43822.4.3  配置侦听器启动外部过程代理程序	43822.4.4  责任与流程控制概述	44022.5  练习22-2：创建一个用于外部过程调用的侦听器	44122.6  章节回顾	44222.6.1  问题	44222.6.2  答案	444第23章  开始使用Recovery Manager	44723.1  RMAN的功能	44823.2  RMAN的组件	44923.2.1  RMAN可执行程序	44923.2.2  目标数据库	44923.2.3  服务器进程与通道	45023.2.4  RMAN的存储仓库	45023.2.5  恢复目录	45023.2.6  介质管理库	45123.2.7  辅助数据库	45223.2.8  闪回恢复区	45223.3  配置RMAN	45223.3.1  环境变量与实例参数	45323.3.2  连接数据库	45423.3.3  配置RMAN的永久设置	455
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle应用、开发与管理系列·OCP认证考试指南全册Oracle Database 10g
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>运筹帷幄DB2
第1章 DBA与DB2运维
第2章 DB2安装与配置——瑜伽式的运维启航
第3章 雾里看花——DB2的管理和操作
第4章 芝麻开门——DB2数据仓库
第5章 运维中的锁处理与并发控制
第6章 DB2日常运维——监控
第7章 有备无患——数据库备份与恢复
第8章 数据移动——搬运的年代
第9章 数据库故障诊断
附录A Oracle和DB2机制对比
附录B Oracle和DB2术语对比
附录C Oracle和DB2命令对比
附录D 缩略语
后记
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>运筹帷幄DB2
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大话Oracle RAC
第1部分　集群理论篇
第1章　rac初体验　2
1.1　本书使用环境　3
1.1.1　硬件环境　3
1.1.2　软件环境　4
1.1.3　本书使用的环境　6
1.2　如何在pc机上搭建rac环境　8
1.2.1　需要下载的软件　8
1.2.2　安装过程　9
1.3　任务列表　28
1.4　规划阶段　28
1.4.1　确认主机名和3个ip地址　29
1.4.2　存储方案选型　29
1.5　实施阶段　30
1.5.1　主机配置　31
1.5.2　安装oracle clusterware　40
1.5.3　安装oracle database　51
1.5.4　配置listener　55
1.5.5　创建asm　59
1.5.6　创建数据库　63
1.6　客户端测试　71
1.6.1　客户端配置　71
1.6.2　体验failover　72
1.6.3　体验loadbalance　73
1.6.4　修改归档模式　74
第2章　什么是rac集群　76
2.1　集群分类　76
2.2　集群环境的特殊问题　76
2.2.1　并发控制　77
2.2.2　健忘症(amnesia)　77
2.2.3　脑裂(split brain)　77
2.2.4　io隔离(io fencing)　78
2.3　rac集群　78
2.3.1　存储层　79
2.3.2　网络层　79
2.3.3　集群件层　80
2.3.4　应用层　81
2.4　小结　81
第3章　oracle clusterware　82
3.1　clusterware和rac的关系　82
3.2　oracle clusterware组成　83
3.2.1　磁盘文件　83
3.2.2　clusterware后台进程　89
3.2.3　网络组件　91
3.3　clusterware的日志体系　95
3.4　小结　95
第4章　rac原理　96
4.1　数据库基本原理　96
4.1.1　并发访问和数据一致性　97
4.1.2　事务和隔离级别　98
4.1.3　oracle支持的隔离级别　99
4.2　oracle单实例的并发控制机制　100
4.2.1　lock　100
4.2.2　数据记录的行级锁　101
4.2.3　latch　105
4.2.4　latch和lock对比　106
4.2.5　进一步理解　106
4.3　rac下的并发控制　109
4.3.1　dlm中资源和锁　110
4.3.2　non-cache fusion资源　111
4.3.3　cache fusion资源　112
4.3.4　grd(global resource directory)　114
4.3.5　pcm lock　114
4.3.6　cache fusion　116
4.3.7　rac并发控制总结　121
4.4　rac架构　121
4.4.1　sga的变化　122
4.4.2　后台进程的变化　122
4.4.3　文件　124
4.4.4　scn　126
4.4.5　cache fusion、gcs、ges　127
4.5　rac和clusterware的交互　127
4.5.1　clusterware层　128
4.5.2　rac层　129
4.6　小结　132
第5章　存储方案——asm初步　133
5.1　shared-disk和shared-nothing架构　133
5.2　oracle 10g rac的存储方案介绍　134
5.3　asm架构　134
5.3.1　asm实例　135
5.3.2　文件　136
5.4　配置asm　136
5.4.1　安装位置　136
5.4.2　创建asm磁盘　136
5.4.3　配置asm实例　144
5.4.4　创建磁盘组　146
5.4.5　在数据库中使用asm的磁盘组　147
5.5　asm实例：将数据库迁移到asm　147
5.5.1　试验说明　147
5.5.2　操作步骤　148
5.5.3　最后验证　155
5.6　小结　156
第2部分　实战篇
第6章　rac维护工具集　158
6.1　oracle clusterware工具集　158
6.2　节点层　158
6.3　网络层　159
6.4　集群层　161
6.4.1　crsctl　162
6.4.2　ocr命令系列　167
6.5　应用层　176
6.5.1　crs_stat　176
6.5.2　onsctl　180
6.5.3　srvctl　186
6.5.4　恢复　192
6.6　小结　196
第7章　ha和lb　197
7.1　什么是高可用性　197
7.2　failover　198
7.2.1　client-side connect time failover　198
7.2.2　taf(transparent application failover)　198
7.2.3　client-side failover和taf的对照试验..　199
7.2.4　server-side taf　202
7.3　oracle clusterware ha框架　210
7.3.1　术语介绍　210
7.3.2　配置命令　213
7.3.3　完整实例　219
7.4　loadbalance　223
7.4.1　connection balancing　223
7.4.2　利用service分散负载　227
7.5　测试loadbalance　228
7.5.1　通过listener日志区分路由来源　228
7.5.2　测试方法　229
7.5.3　测试过程　230
7.6　小结　234
第8章　备份　235
8.1　概述　235
8.1.1　备份　235
8.1.2　恢复　236
8.1.3　rman工具　238
8.2　使用flash recovery area　238
8.2.1　配置flash recovery area　239
8.2.2　flash recovery area的空间监控　239
8.3　使用rman　240
8.3.1　rman工具的使用方法　240
8.3.2　rman配置　242
8.4　完全备份和增量备份　248
8.4.1　完全备份　249
8.4.2　增量备份　251
8.4.3　其他rman命令　254
8.5　rac的备份实例　261
8.6　小结　264
第9章　恢复　265
9.1　为什么oracle数据库能够恢复　265
9.2　日志　267
9.2.1　日志线程(redo thread)　268
9.2.2　rac的联机日志　268
9.3　恢复种类　269
9.3.1　instance recovery　269
9.3.2　media recovery　269
9.3.3　crash recovery　269
9.3.4　online block recovery　274
9.4　介质恢复　274
9.4.1　完全恢复　275
9.4.2　不完全恢复　280
9.4.3　恢复到单实例　294
9.5　小结　302
第10章　其他恢复技术　303
10.1　数据块恢复　303
10.2　如何检查数据块一致性　304
10.2.1　使用初始化参数　304
10.2.2　dbv工具　305
10.2.3　analyze命令　307
10.2.4　rman工具　307
10.2.5　dbms_repair包　308
10.3　模拟数据块不一致　309
10.4　数据块不一致处理办法　313
10.4.1　收集信息　313
10.4.2　设计恢复方法　314
10.4.3　恢复操作　316
10.5　数据块恢复实例　317
10.6　flashback家族介绍　326
10.7　flashback database　326
10.7.1　flashback database架构　326
10.7.2　启用flashback database　327
10.7.3　flashback database　329
10.7.4　命令和视图　332
10.8　flashback drop　333
10.8.1　tablespace recycle bin　333
10.8.2　flashback drop操作　335
10.8.3　recycly bin的维护　336
10.9　flashback query 和flashback table　337
10.9.1　oracle 9i的flashback query　337
10.9.2　flashback version query　339
10.9.3　flashback transaction query　354
10.9.4　flashback table　356
10.9.5　undo retntion　359
10.10　小结　360
第11章　rac和data guard　361
11.1　data guard介绍　361
11.1.1　data guard架构　362
11.1.2　日志发送(redo send)　362
11.1.3　日志接收(redo receive)　365
11.1.4　日志应用(redo apply)　367
11.1.5　数据保护模式　367
11.1.6　自动裂隙检测和解决　368
11.2　rac和standby配置实例　369
11.2.1　rac primary和single standby　370
11.2.2　rac primary和rac standby　381
11.3　小结　394
第12章　rac和stream replication　395
12.1　stream的工作原理　395
12.2　data guard和stream对比　396
12.3　rac stream配置实例　397
12.3.1　single(source)和rac(target)　398
12.3.2　rac对rac的复制　404
12.3.3　strmmon工具　425
12.4　小结　427
第13章　深入asm　428
13.1　非asm的存储结构　428
13.2　asm存储结构　429
13.3　asm文件系统　430
13.3.1　asm metadata　431
13.3.2　physical metadata　431
13.3.3　virtual metadata　433
13.3.4　disk recovery　434
13.4　条带化(asm striping)　435
13.4.1　asm文件模板(asm file template)　435
13.4.2　asm别名(asm file alias)　436
13.5　rdbms和asm之间的交互　445
13.6　asm的实例恢复　446
13.7　asm和os filesystem之间交互　447
13.7.1　dbms_file_transfer包　447
13.7.2　rman的convert方法　453
13.7.3　asm和tts　453
13.8　asm的限制　456
13.9　小结　457
第14章　性能与rac　458
14.1　rac的若干特点　459
14.2　awr　461
14.2.1　启用awr　462
14.2.2　修改awr配置　462
14.2.3　产生awr报告　462
14.3　ash　464
14.4　sql调整策略　466
14.4.1　sql语句的执行过程　466
14.4.2　sql性能调整的基本方法　467
14.4.3　pl/sql和sql　471
14.5　小结　473
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大话Oracle RAC
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>基于Oracle的SQL优化
第 1章  Oracle里的优化器 ...................................1
1.1 什么是 Oracle里的优化器 ...........................1
1.1.1 基于规则的优化器............................2
1.1.2 基于成本的优化器........................9
1.1.2.1 集的势 ..............................11
1.1.2.2 可选择率 ...............................11
1.1.2.3 可传递性..............................16
1.1.2.4 CBO的局限性...................................18
1.2 优化器的基础知识 .......................19
1.2.1 优化器的模式..................................19
1.2.2 结果集............................21
1.2.3 访问数据的方法................................22
1.2.3.1 访问表的方法.............................22
1.2.3.1.1 全表扫描 ....................................22
1.2.3.1.2 ROWID扫描 .....................................23
1.2.3.2 访问索引的方法 .....................................24
1.2.3.2.1 索引唯一性扫描 ...............................25
1.2.3.2.2 索引范围扫描 .......................................25
1.2.3.2.3 索引全扫描 ......................................28
1.2.3.2.4 索引快速全扫描 ...............................29
1.2.3.2.5 索引跳跃式扫描 ...............................31
1.2.4 表连接..........................33
1.2.4.1 表连接的类型......................................34
1.2.4.1.1 内连接.............................................34
1.2.4.1.2 外连接.................................................37
1.2.4.2 表连接的方法............................................47
1.2.4.2.1 排序合并连接 ..................................47
1.2.4.2.2 嵌套循环连接 ...................................48
1.2.4.2.3 哈希连接 ..........................................51
1.2.4.2.4 笛卡儿连接 ......................................56
1.2.4.3 反连接 ...........................................58
1.2.4.4 半连接 ................................63
1.2.4.5 星型连接............................................65
1.3 优化器模式对 CBO计算成本带来巨大影响的实例...............66
1.4 总结.......................80
第 2章  Oracle里的执行计划 ........................... 82
2.1 什么是执行计划.................................82
2.2 如何查看执行计划 ..........................85
2.2.1 explain plan命令....................................86
2.2.2 DBMS_XPLAN包............................89
2.2.3 AUTOTRACE开关 ...............................95
2.2.4 10046事件与 tkprof命令.............................99
2.3 如何得到真实的执行计划..................................102
2.4 如何查看执行计划的执行顺序.............................118
2.5 Oracle里的常见执行计划 .......................122
2.5.1 与表访问相关的执行计划.................................122
2.5.2 与 B树索引相关的执行计划.................................124
2.5.3 与位图索引相关的执行计划...................................129
2.5.4 与表连接相关的执行计划.......................................138
2.5.5 其他典型的执行计划...............................................146
2.5.5.1 AND-EQUAL（INDEX MERGE）.....................146
INDEX JOIN ................................148
2.5.5.2 VIEW.......................149
2.5.5.3FILTER ..................................151
2.5.5.4 SORT ....................................154
2.5.5.5
2.5.5.6 UNION/UNION ALL......................167
CONCAT..................................................168
2.5.5.7
CONNECT BY...................................................171
2.5.5.8
2.6 Oracle里执行计划的稳定 ................................172
2.6.1 使用 SQL Profile来稳定执行计划 ...........................173
2.6.1.1 Automatic类型的 SQL Profile ...............................173
2.6.1.2 Manual类型的 SQL Profile......................................179
2.6.2 使用 SPM来稳定执行计划........................................190
2.7 总结..............................203
第 3章  Oracle里的 Cursor和绑定变量 ......................... 204
3.1 Oracle里的 Cursor.............................204
3.1.1 Oracle里的 Shared Cursor.............................204
3.1.1.1 Shared Cursor的含义 ..........................................204
3.1.1.2 硬解析 ................................................212
3.1.1.3 软解析 ...................................214
3.1.2 Oracle里的 Session Cursor..............................215
3.1.2.1 Session Cursor的含义 .....................................215
3.1.2.2 Session Cursor的相关参数解析...........................218
OPEN_CURSORS.........................................218
3.1.2.2.1 SESSION_CACHED_CURSORS ............................219
3.1.2.2.2CURSOR_SPACE_FOR_TIME ..............................221
3.1.2.2.3
3.1.2.3 Session Cursor的种类和用法 .............................222
3.1.2.3.1 隐式游标 ........................................222
3.1.2.3.2 显式游标 ........................................225
3.1.2.3.3 参考游标 ........................................230
3.2 Oracle里的绑定变量 ...............................237
3.2.1 绑定变量的作用....................................237
3.2.2 绑定变量的典型用法.........................................238
3.2.3 绑定变量的使用原则和最佳实践..............................245
3.2.3.1 PL/SQL批量绑定模板一 ...................................245
3.2.3.2 PL/SQL批量绑定模板二 .....................................247
3.2.4 绑定变量窥探............................................258
3.2.5 绑定变量分级..................................270
3.2.6 绑定变量的个数不宜太多........................................276
3.2.7 批量绑定时如何处理错误.......................................280
3.2.8 如何得到已执行的目标 SQL中绑定变量的值 ..........283
3.3 Oracle里的游标共享 .......288
3.3.1 常规游标共享..............................289
3.3.2 自适应游标共享........................297
3.4 Oracle里的应用类型 ...............................320
3.4.1 Session Cursor的生命周期.........................................320
3.4.2 应用类型一（硬解析）................................................322
3.4.3 应用类型二（软解析）...............................................323
3.4.4 应用类型三（软软解析）..........................................323
3.4.5 应用类型四（一次解析、多次执行）....................324
3.4.6 四种应用类型的实测性能对比..............................325
3.5 总结.............................333
第 4章  Oracle里的查询转换 .......................... 335
4.1 Oracle里查询转换的作用 ................335
4.2 子查询展开.................................336
4.3 视图合并............................344
4.3.1 简单视图合并...........................345
4.3.2 外连接视图合并..................351
4.3.3 复杂视图合并.....................354
4.4 星型转换.....................365
4.5 连接谓词推入 ................372
4.6 连接因式分解 ................379
4.7 表扩展 .......................387
4.8 表移除 .............396
4.9 Oracle如何处理 SQL语句中的 IN.............401
IN-List Iterator .................402
4.9.1
4.9.2 IN-List Expansion / OR Expansion ................404
IN-List Filter .............409
4.9.3
4.9.4 对 IN做子查询展开/视图合并 .............410
4.10 查询转换的综合应用实例（逻辑读从 200万降到 6） .....413
4.11总结..............................420
第 5章  Oracle里的统计信息 ........ 422
5.1 什么是 Oracle里的统计信息...........422
5.2 Oracle里收集与查看统计信息的方法 .............423
5.2.1 收集统计信息...................423
5.2.1.1 用 ANALYZE命令收集统计信息...........423
5.2.1.2 用 DBMS_STATS包收集统计信息..........428
5.2.1.3 ANALYZE和 DBMS_STATS的区别........432
5.2.2 查看统计信息................433
5.3 表的统计信息 ..............435
5.3.1 表统计信息的种类和含义.........435
5.3.2 表统计信息不准导致 SQL性能问题的实例 .................437
5.4 索引的统计信息..............440
5.4.1 索引统计信息的种类和含义.................440
5.4.2 聚簇因子的含义及重要性............442
5.5 列的统计信息 ..................450
5.5.1 列统计信息的种类和含义..............450
5.5.2 列统计信息不准导致谓词越界的实例..........454
5.5.3 直方图........................460
5.5.3.1 直方图的含义...............460
5.5.3.2 直方图的类型.................462
5.5.3.2.1 Frequency类型的直方图 ...........463
5.5.3.2.2 Height Balanced类型的直方图 ..................471
5.5.3.3 直方图的收集方法................................475
5.5.3.4 直方图对 CBO的影响 ....................477
5.5.3.4.1 直方图对 Shared Cursor的影响 .............477
5.5.3.4.2 直方图对可选择率的影响 ................482
5.5.3.5 使用直方图的注意事项...........................495
5.6 全局统计信息 ............................496
5.7 动态采样............................507
5.8 多列统计信息 ...........................516
5.9 系统统计信息 .............................519
5.10 数据字典统计信息..................536
5.11内部对象统计信息 .............................539
5.12 Oracle里的自动统计信息收集 .........................546
5.13 Oracle里应如何收集统计信息 ..........................563
5.14 总结.........................567
第 6章  Oracle里的 Hint..................... 568
6.1 什么是 Hint .....................568
6.2 Hint的用法 ...............................576
6.3 Hint被 Oracle忽略的常见情形 ...............590
6.3.1 情形一：使用的 Hint有语法或者拼写错误.................591
6.3.2 情形二：使用的 Hint无效.........................592
6.3.3 情形三：使用的 Hint自相矛盾..............597
6.3.4 情形四：使用的 Hint受到了查询转换的干扰...........599
6.3.5 情形五：使用的 Hint受到了保留关键字的干扰.........602
6.4 常见的 Hint ...............605
6.4.1 与优化器模式相关的 Hint................606
6.4.1.1 ALL_ROWS ...............606
6.4.1.2 FIRST_ROWS(n)...................606
RULE........................608
6.4.1.3
6.4.2 与表访问相关的 Hint...................615
FULL .......................615
6.4.2.1 ROWID .............615
6.4.2.2
6.4.3 与索引访问相关的 Hint...................615
INDEX .........................615
6.4.3.1 NO_INDEX .....................616
6.4.3.2 INDEX_DESC ...............617
6.4.3.3 INDEX_COMBINE................618
6.4.3.4 INDEX_FFS ..................620
6.4.3.5
6.4.3.6 INDEX_JOIN.............621
6.4.3.7 AND_EQUAL.....................622
6.4.4 与表连接顺序相关的 Hint...................624
ORDERED ................................624
6.4.4.1 LEADING ........................626
6.4.4.2
6.4.5 与表连接方法相关的 Hint.............628
6.4.5.1 USE_MERGE ............628
NO_USE_MERGE .............631
6.4.5.2 USE_NL............633
6.4.5.3 NO_USE_NL .................634
6.4.5.4 USE_HASH.............635
6.4.5.5 NO_USE_HASH ..........635
6.4.5.6
6.4.5.7 MERGE_AJ.........636
NL_AJ............................637
6.4.5.8 HASH_AJ.................637
6.4.5.9 MERGE_SJ....................637
6.4.5.10 NL_SJ...........................638
6.4.5.11HASH_SJ .......................639
6.4.5.12
6.4.6 与查询转换相关的 Hint .....................639
USE_CONCAT ...............639
6.4.6.1 NO_EXPAND ...............640
6.4.6.2 MERGE................642
6.4.6.3 NO_MERGE................642
6.4.6.4 UNNEST ....................643
6.4.6.5
6.4.6.6 NO_UNNEST........................643
EXPAND_TABLE .................................644
6.4.6.7 NO_EXPAND_TABLE .......................644
6.4.6.8
6.4.7 与并行相关的 Hint ...........................645
PARALLEL...................................645
6.4.7.1 NO_PARALLEL ................................652
6.4.7.2
6.4.7.3 PARALLEL_INDEX ................................654
NO_PARALLEL_INDEX......................................656
6.4.7.4
6.4.8 其他常见 Hint ............................656
DRIVING_SITE..............................656
6.4.8.1 APPEND ...........................................659
6.4.8.2 APPEND_VALUES ........................................662
6.4.8.3
6.4.8.4 PUSH_PRED .......................664
NO_PUSH_PRED ................................666
6.4.8.5
6.4.8.6 PUSH_SUBQ....................................666
6.4.8.7 NO_PUSH_SUBQ................669
OPT_PARAM ..............................................670
6.4.8.8 OPTIMIZER_FEATURES_ENABLE ...............................672
6.4.8.9
6.4.8.10 QB_NAME ........................................674
CARDINALITY .................................674
6.4.8.11SWAP_JOIN_INPUTS .............................677
6.4.8.12
6.5 用 Cardinality Hint解决 ORA-01555错误的实例...............682
6.6 总结...............................693
第 7章  Oracle里的并行 ..................... 695
7.1 Oracle里并行的基本概念 ...............695
7.1.1 为什么要用并行.................695
7.1.2 并行的理论基础....................696
7.1.3 Oracle里能够并行执行的操作...............697
7.1.4 Oracle里与并行有关的术语及解释 ..................707
7.1.4.1 Query Coordinator .............708
7.1.4.2 Query Slaves和 Query Slave Set.............708
7.1.4.3 Table Queues.........716
7.1.4.4 数据传递方法.............721
7.1.4.5 granules............735
7.1.4.6 直接读取 ............737
7.1.5 深入解析并行执行计划的实例.............746
7.2 Oracle里并行的控制 ..........755
7.2.1 Oracle里如何开启并行 .............755
7.2.2 Oracle里并行度的控制 .............760
7.2.3 Oracle RAC环境下的并行...........771
7.2.4 Oracle里与并行相关的参数 ..............775
PARALLEL_MAX_SERVERS .........775
7.2.4.1 PARALLEL_MIN_SERVERS ......................776
7.2.4.2
7.2.4.3 自动并行相关的参数 ...................776
PARALLEL_DEGREE_POLICY ................................776
7.2.4.3.1 PARALLEL_MIN_TIME_THRESHOLD ...................................776
7.2.4.3.2
7.2.4.3.3 PARALLEL_DEGREE_LIMIT ..................777
PARALLEL_SERVERS_TARGET..................................777
7.2.4.3.4
7.2.4.4 自适应并行相关的参数...............778
PARALLEL_ADAPTIVE_MULTI_USER ...............778
7.2.4.4.1 PARALLEL_MIN_PERCENT ........................778
7.2.4.4.2 PARALLEL_AUTOMATIC_TUNING .........778
7.2.4.4.3
7.2.4.5 其他参数 ............................778
PARALLEL_THREADS_PER_CPU ...................................778
7.2.4.5.1 PARALLEL_EXECUTION_MESSAGE_SIZE.............779
7.2.4.5.2 PARALLEL_FORCE_LOCAL.........................779
7.2.4.5.3
7.2.5 绕开 Oracle并行执行 Bug大幅提升性能的实例 ................779
7.3 总结..........................805
第 8章  Oracle里 SQL优化的方法论 ................... 807
8.1 Oracle里如何做 SQL优化...................807
8.1.1 Oracle里 SQL优化的本质是基于对 CBO和执行计划的深刻理解 ......807
8.1.2 Oracle里 SQL优化需要联系实际的业务 ...................819
8.1.3 Oracle里 SQL优化需要适时使用绑定变量 ............824
8.2 Oracle里 SQL优化的方法论在实战中的验证...............824
8.3 总结......................841
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>基于Oracle的SQL优化
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle核心技术
目　录

第1章　准备开始　　1
1.1 　Oracle的流程　　1
1.2 　Oracle实战　　4
1.3 　小结　　4
第2章　redo和undo　　5
2.1 　基本数据改变　　5
2.1.1 　数据改变的方法　　6
2.1.2 　示例　　6
2.1.3 　任务报告　　9
2.1.4 　观察总结　　10
2.2 　ACID　　11
2.3 　redo复杂度　　13
2.4 　undo复杂度　　18
2.4.1 　读一致性　　19
2.4.2 　回滚　　19
2.5 　小结　　21
第3章　事务与一致性　　22
3.1 　冲突解决　　22
3.2 　事务与undo　　23
3.2.1 　事务的开始与结束　　24
3.2.2 　事务表　　25
3.2.3 　undo块回顾　　27
3.3 　数据块访问与undo　　30
3.3.1 　设置场景　　30
3.3.2 　事务列表　　31
3.3.3 　并发动作　　33
3.4 　提交SCN　　38
3.4.1 　提交清除　　39
3.4.2 　延迟块清除　　41
3.4.3 　事务表回滚　　44
3.5 　大对象　　48
3.6 　小结　　49
第4章　锁与闩锁　　50
4.1 　事情有先有后　　50
4.1.1 　数组　　50
4.1.2 　指针　　51
4.1.3 　链表　　51
4.1.4 　散列表　　53
4.2 　闩锁　　56
4.2.1 　闩锁背后的逻辑　　56
4.2.2 　闩锁活动统计　　59
4.2.3 　闩锁可扩展性　　63
4.3 　锁　　64
4.3.1 　基础结构　　65
4.3.2 　V$lock的图形展示　　66
4.3.3 　死锁　　69
4.3.4 　锁模式　　72
4.3.5 　保护锁的闩锁　　73
4.3.6 　KGL锁（和pin）　　75
4.3.7 　锁和pin　　75
4.4 　小结　　77
第5章　缓存和复制　　79
5.1 　内存管理　　79
5.1.1 　granule　　80
5.1.2 　granule和缓冲区　　81
5.2 　多个数据块缓存　　83
5.2.1 　granule和缓冲池　　84
5.2.2 　缓冲池　　85
5.3 　工作集　　86
5.4 　LRU/TCH算法　　88
5.4.1 　LRU/TCH实战　　89
5.4.2 　重新链接缓冲区　　90
5.5 　REPL_AUX　　92
5.6 　查找数据　　94
5.6.1 　pin住缓冲区　　96
5.6.2 　逻辑I/O　　98
5.6.3 　更新（update）　　99
5.6.4 　载入散列链　　100
5.6.5 　读一致性拷贝　　100
5.6.6 　物理I/O　　101
5.6.7 　表扫描　　102
5.7 　小结　　103
第6章　写入和恢复　　105
6.1 　目标　　105
6.2 　日志写进程　　106
6.2.1 　日志写进程写入　　108
6.2.2 　PL/SQL优化　　110
6.2.3 　ACID异常　　113
6.2.4 　提交改进　　113
6.2.5 　过程　　115
6.2.6 　重做日志浪费　　118
6.2.7 　私有重做　　119
6.3 　数据库写进程　　120
6.3.1 　缓冲区头部　　121
6.3.2 　检查点队列　　121
6.3.3 　增量检查点　　123
6.4 　数据库写进程的交互　　124
6.4.1 　数据库写进程与日志写进程　　124
6.4.2 　数据库写进程和LRU　　125
6.4.3 　检查点和队列　　128
6.4.4 　缓冲区头部队列　　132
6.4.5 　检查点和日志文件　　133
6.5 　恢复　　135
6.5.1 　介质恢复　　136
6.5.2 　备用数据库　　137
6.5.3 　闪回数据库　　137
6.5.4 　副作用　　138
6.6 　小结　　139
第7章　解析与优化　　141
7.1 　理解SQL代码　　141
7.1.1 　解析　　141
7.1.2 　优化　　142
7.1.3 　解释tkprof Summaries　　143
7.2 　数据字典缓存　　145
7.2.1 　结构　　149
7.2.2 　数据字典缓存活动　　151
7.3 　什么是解析调用　　154
7.3.1 　Cursor Caching　　155
7.3.2 　持有游标　　157
7.4 　库缓存　　158
7.4.1 　共享池结构　　160
7.4.2 　精妙的共享池结构　　163
7.4.3 　那么，行动吧！　　168
7.5 　解析和优化　　170
7.5.1 　executing、locking和pinning　　173
7.5.2 　互斥锁　　174
7.6 　小结　　175
第8章　RAC及“缺陷”　　176
8.1 　RAC示意图　　177
8.2 　重点是什么　　180
8.2.1 　高可用性　　180
8.2.2 　可扩展性　　181
8.2.3 　网格　　182
8.3 　它如何工作　　183
8.3.1 　全局资源目录　　183
8.3.2 　Master和Shadow　　186
8.3.3 　GCS和GES　　189
8.3.4 　缓存融合　　190
8.3.5 　后果　　193
8.4 　恢复　　195
8.5 　序列　　196
8.5.1 　缓存序列　　197
8.5.2 　深入解析序列　　197
8.5.3 　有序的序列　　199
8.5.4 　序列和索引　　201
8.6 　小结　　203
附录A 　转储与调试　　205
词汇表　　216
索引　　224
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle核心技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle RAC日记
基础知识篇第1章　RAC安装与关键技术　  1.1　Oracle 9i RAC安装及相关资源　    1.1.1　安装环境简介　    1.1.2　数据库安装配置规划　    1.1.3　安装后测试　  1.2　Oracle 10g RAC安装及相关资源　  1.3　CACHE FUSION的概念　  1.4　举例说明CACHE FUSION的算法　    1.4.1　场景（1）C节点申请访问DB1　    1.4.2　场景（2）B节点需要读DB1　    1.4.3　场景（3）B节点需要修改DB1　    1.4.4　场景（4）C节点需要修改DB1　    1.4.5　场景（5）B节点需要将DB1存盘　  1.5　什么是CRS　  1.6　RAC的主要性能指标　    1.6.1　总体负载与命中率指标　    1.6.2　消息传输相关的指标　    1.6.3　GLOBAL CACHE SERVICE的相关指标　  1.7　如何阅读SYSTEMSTATE DUMP　    1.7.1　标准的STATE OBJECT HEADER　    1.7.2　PROCESSSTATE DUMP （ksupr）　    1.7.3　SESSION STATE OBJECT　    1.7.4　CALL STATE OBJECT　    1.7.5　ENQUEUE STATE OBJECT　    1.7.6　TRANSACTION DUMP　    1.7.7　LIBRARY OBJECT LOCK/HANDLE　    1.7.8　使用ASS分析SYSTEMSTATE DUMP　    1.7.9　通过SYSTEMSTATE DUMP定位故障的案例　  1.8　AWR中的主要事件分析　  1.9　AWR中的主要WAIT EVENT分析　    1.9.1　WAIT EVENTS分析的一些常识　    1.9.2　LATCH FREE　    1.9.3　db file sequential read　    1.9.4　db file scattered read　    1.9.5　buffer busy waits　    1.9.6　REDO LOG相关等待　    1.9.7　ENQUEUE　    1.9.8　DFS LOCK HANDLE　    安装升级篇第2章　麻烦不断的安装历程　  2.1　月1日 安装这种活也找我　  2.2　月2日 倒霉的一天　  2.3　月3日 VAX6510和RDB数据库　  2.4　月4日 平静的一天　  2.5　月5日 存储优化　  2.6　案例启示：职场之道　第3章　单机升级到RAC　  3.1　月14日 各怀心思的研讨会　  3.2　月19日 令人目瞪口呆的方案　  3.3　月20日 令人沮丧的实验　  3.4　月21日 好事多磨　  3.5　月1日 一身冷汗　  3.6　值得总结的教训　    故障诊断篇第4章　经常宕机的RAC系统　  4.1　月2日 上海的紧急故障　  4.2　月3日 上海第一天　  4.3　月4日 决定　  4.4　月5日 平安无事了　  4.5　如何分析CRS宕机故障　  4.6　态度决定一切　第5章　好的方法是成功的一半　  5.1　月8日 又宕机了　  5.2　月9日 求人不如求己　  5.3　月9日 定位故障　  5.4　月10日 及时雨　  5.5　方法的正确性是成功的保障　第6章　性能故障还是BUG　  6.1　月21日 奇怪的性能问题　  6.2　月22日 如何解决问题　  6.3　小结　    性能优化篇第7章　EIA系统的性能问题　  7.1　月6日 紧急求援　  7.2　月7日 典型的RAC性能问题　  7.3　月8日 阿才的奇怪问题　  7.4　小结　  7.5　案例的启示：RAC环境下的常见优化方法　第8章　奇怪的RAC性能问题　  8.1　月4日 系统告急　  8.2　月5日 分析的方法　  8.3　月6日 extent pre-allocation　  8.4　小结负载均衡模式下的RAC优化要点　第9章　爱刨根问底的客户　  9.1　月15日 奇怪的性能下降　  9.2　月16日 系统级的调整　  9.3　月17日 负载均衡OR NOT　  9.4　RAC环境中的并行查询　  9.5　为什么在CPU出现瓶颈时要加大DB CACHE　第10章　外来的和尚好念经　  10.1　月25日 一封邮件引发的事端　  10.2　月27日 突生变故　  10.3　月29日 Richard Warham　  10.4　月30日 IO优化　  10.5　月1日 在家聊天　  10.6　月8日 危机再现　  10.7　月12日 Richard的180度大转弯　  10.8　月13日 系统扩容　  10.9　月14日 Richard请客　  10.10　月1日 新的起点　  10.11　月7日 孤独的唱反调的人　  10.12　月8日 ITL等待引发的RAC性能问题　  10.13　月9日 ORA-8104错误　  10.14　月15日 又陷危机　  10.15　月16日 IO负载均衡　  10.16　月18日 按下葫芦浮起了瓢　  10.17　月19日 实施优化　  10.18　后来　设计好的RAC应用，也算后记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle RAC日记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 11g基础教程
第一部分 数据库概念
第1章 关系数据库管理系统        2
1.1 什么是数据库        2
1.2 什么是关系数据库        3
1.2.1 关系的定义        4
1.2.2 网状数据库        4
1.2.3 关系数据库的定义        5
1.2.4 关系操作        6
1.2.5 结构化查询语言        8
1.2.6 关系操作的效率        9
1.2.7 查询优化        9
1.3 什么是数据库管理系统        10
1.3.1 事务管理        10
1.3.2 数据完整性        11
1.3.3 数据安全性        12
1.4 由什么构成关系数据库管理系统的关系        12
1.5 小结        13
1.6 练习        13
1.7 补充读物        14
第2章 SQL和PL/SQL        15
2.1 铁路图        16
2.2 SQL的类型        18
2.2.1 DDL        18
2.2.2 DML        19
2.3 嵌套的SQL        21
2.4 SQL*Plus和SQL Developer        22
2.5 PL/SQL介绍        28
2.6 小结        35
2.7 练习        36
2.8 补充读物        36
第3章 Oracle体系结构        38
3.1 数据库与实例        39
3.2 数据库        39
3.2.1 软件        39
3.2.2 配置文件        39
3.2.3 数据文件        40
3.2.4 临时文件        40
3.2.5 重做日志文件        40
3.2.6 归档重做日志文件        41
3.2.7 控制文件        41
3.2.8 事件日志        41
3.2.9 数据库备份        41
3.3 实例        41
3.3.1 SGA        42
3.3.2 前台进程        42
3.3.3 后台进程        42
3.4 数据库会话的生命周期        43
3.5 小结        44
3.6 练习        45
3.7 补充读物        45
第二部分 数据库实现
第4章 规划        48
4.1 许可证        48
4.1.1 实际例子        48
4.1.2 免费下载、免费学习、试用时间无限制        50
4.1.3 数据库版本        50
4.2 体系结构选择        51
4.2.1 专用服务器        51
4.2.2 共享服务器        51
4.2.3 连接池        52
4.2.4 真应用群        52
4.2.5 备用数据库        53
4.2.6 最大可用体系结构        53
4.3 大小估计        53
4.3.1 磁盘大小估计        54
4.3.2 关于磁盘的其他考虑        55
4.3.3 内存大小        55
4.3.4 CPU大小        55
4.3.5 网络大小        56
4.4 小结        56
4.5 练习        57
4.6 补充读物        57
第5章 软件安装        58
5.1 Oracle技术网        58
5.2 被遗忘的手册        58
5.3 先决条件和安装前的要求        59
5.4 客户机安装        59
5.5 服务器安装        63
5.6 Oracle Database的例子        66
5.7 Perl        66
5.8 小结        67
5.9 练习        67
5.10 补充读物        68
第6章 数据库创建        69
6.1 简易安装方法        70
6.2 配置监听程序        70
6.3 创建和配置数据库        74
6.3.1 欢迎屏幕        74
6.3.2 第1步：操作        74
6.3.3 第2步：数据库模板        75
6.3.4 第3步：数据库标识        75
6.3.5 第4步：管理选项        76
6.3.6 第5步：数据库认证        77
6.3.7 第6步：存储选项        78
6.3.8 第7步：数据库文件位置        78
6.3.9 第8步：恢复配置        79
6.3.10 第9步：数据库内容        80
6.3.11 第10步：初始化参数        81
6.3.12 第11步：安全设置        81
6.3.13 第12步：自动维护任务        82
6.3.14 第13步：数据库存储        83
6.3.15 第14步：创建选项        83
6.3.16 确认界面        84
6.3.17 成功消息        86
6.4 创建后的任务        86
6.5 创建数据库的其他方法        87
6.6 基本的数据库管理任务        89
6.7 小结        93
6.8 练习        94
6.9 补充读物        95
第7章 物理数据库设计        96
7.1 索引        96
7.1.1 唯一索引与非唯一索引        97
7.1.2 连接索引        97
7.1.3 基于函数的索引        98
7.1.4 索引结构        98
7.1.5 创建何种索引        98
7.1.6 索引组织表        100
7.1.7 高级内容        100
7.2 分区        100
7.2.1 分区的优点        101
7.2.2 列表分区        101
7.2.3 范围分区        102
7.2.4 间隔分区        102
7.2.5 散列分区        103
7.2.6 引用分区        103
7.2.7 组合分区        105
7.2.8 局部和全局索引        105
7.3 非规范化和实体化视图        105
7.4 群        107
7.5 小结        108
7.6 练习        109
7.7 补充读物        109
第8章 用户管理和数据装载        111
8.1 方案        111
8.2 用户管理        117
8.2.1 创建用户        117
8.2.2 用户授权        120
8.2.3 删除用户权限        124
8.2.4 修改用户属性        124
8.2.5 删除用户        125
8.3 数据装载        125
8.3.1 导出和导入实用程序        126
8.3.2 数据泵实用程序        129
8.3.3 SQL*Loader        133
8.4 小结        135
8.5 练习        135
8.6 补充读物        136
第三部分 数据库支持
第9章 控制        138
9.1 企业管理器        139
9.2 SQL Developer        141
9.3 Remote Diagnostic Agent        143
9.4 字典表和视图        145
9.5 第三方工具        148
9.6 小结        149
9.7 练习        149
9.8 补充读物        149
第10章 监控        151
10.1 监控数据库的可用性        151
10.2 监控更改        154
10.3 监控安全性        154
10.4 监控备份        156
10.5 监控增长        156
10.6 监控工作量        157
10.7 监控性能        160
10.8 监控容量        163
10.9 第三方工具        165
10.10 小结        165
10.11 练习        166
10.12 补充读物        166
第11章 解决问题        167
11.1 系统化的5步骤问题解决方法        168
11.2 渴求之书和问题管理的最佳实践        169
11.3 真实的例子——无反应的监听器        170
11.3.1 定义问题        170
11.3.2 研究和分析问题        171
11.3.3 解决问题和实现解决方案        172
11.3.4 一周后        173
11.3.5 待改进        173
11.4 意外事件管理与问题管理        173
11.5 网络资源        173
11.6 使用Oracle Support        177
11.6.1 RDA        179
11.6.2 ADR        179
11.7 错误代码        179
11.8 四个错误        181
11.8.1 ORA-01555: Snapshot Too Old        181
11.8.2 ORA-00060: Deadlock Detected        182
11.8.3 ORA-00600: Internal Error Code        184
11.8.4 ORA-07445: Exception Encountered        189
11.9 小结        189
11.10 练习        190
11.11 补充读物        191
第12章 备份        192
12.1 为什么需要备份        192
12.2 恐怖故事        193
12.3 各种备份        194
12.3.1 磁带备份与磁盘备份        194
12.3.2 完全备份与部分备份        195
12.3.3 0级备份与1级备份        195
12.3.4 物理备份与逻辑备份        195
12.3.5 一致备份与非一致备份        195
12.3.6 热备份与冷备份        195
12.3.7 Oracle管理的备份与用户管理的备份        196
12.4 具体演示：物理备份        196
12.5 具体演示：逻辑备份        201
12.6 常用的RMAN命令        202
12.7 “方便”按钮        206
12.8 小结        208
12.9 练习        208
12.10 补充读物        209
第13章 恢复        210
13.1 恐怖故事        210
13.2 恢复的类型        211
13.2.1 复原与恢复        211
13.2.2 完整恢复与部分恢复        211
13.2.3 完全恢复与不完全恢复        211
13.2.4 传统与闪回        212
13.2.5 物理恢复与逻辑恢复        212
13.3 闪回技术        213
13.3.1 闪回查询        213
13.3.2 闪回版本        214
13.3.3 闪回事务        214
13.3.4 闪回表        215
13.3.5 闪回删除        215
13.3.6 闪回数据档案        217
13.3.7 闪回数据库        217
13.4 LogMiner        218
13.5 数据恢复顾问        219
13.6 使用企业管理器进行恢复        225
13.7 文档及测试        227
13.8 小结        228
13.9 练习        228
13.10 补充读物        229
第14章 数据库维护        230
14.1 维护计划        230
14.2 备份        231
14.2.1 数据库备份的通用良策        231
14.2.2 Oracle数据库备份的最佳实践        231
14.3 统计数据        232
14.4 归档和清除        233
14.5 日志文件维护        236
14.6 审计        239
14.7 用户管理        241
14.8 容量管理        241
14.9 补丁        246
14.10 小结        249
14.11 练习        250
14.12 补充读物        250
第15章 大局观和10个交付物        251
15.1 一次求职面试的启示        251
15.2 我是怎样成为DBA的        253
15.3 ITIL        254
15.3.1 大局观        254
15.3.2 IT服务管理过程        255
15.4 以终为始：10个交付物        258
15.5 你真正需要的书籍以及SOP艺术        260
15.5.1 SOP的好处        260
15.5.2 SOP的结构        262
15.5.3 建议的SOP        264
15.6 小结        265
15.7 练习        265
15.8 补充读物        266
第四部分 数据库调优
第16章 实例调优        268
16.1 使用系统化的5步调优方法        268
16.2 分析DB时间        270
16.3 了解Oracle等待接口        274
16.3.1 V$SYSSTAT和V$SESSTAT        274
16.3.2 V$SESSION_EVENT和V$SYSTEM_EVENT        275
16.4 开采Statspack信息库        275
16.5 使用Statspack报表        283
16.6 小结        284
16.7 练习        285
16.8 补充读物        287
第17章 SQL调优        288
17.1 定义效率        288
17.2 确定低效率的SQL语句        288
17.3 SQL的低效原因        291
17.4 改进SQL的方法        291
17.4.1 索引        292
17.4.2 提示        293
17.4.3 统计数据        294
17.5 调优例子        295
17.5.1 创建和填充表        296
17.5.2 确定基线        296
17.5.3 查看查询计划        300
17.5.4 索引和统计数据        303
17.5.5 使用SQL Access Advisor        305
17.5.6 优化器提示        308
17.5.7 最后的调优        309
17.5.8 更进一步        312
17.6 小结        314
17.7 练习        315
17.8 补充读物        315
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 11g基础教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 10g DBA手册
第Ⅰ部分 数据库体系结构  第1章 Oracle体系结构概述     1.1 数据库和实例概述     1.2 Oracle逻辑存储结构     1.3 Oracle逻辑数据库结构    1.4 Oracle物理存储结构     1.5 多路传输数据库文件     1.6 Oracle内存结构     1.7 备份/恢复概述     1.8 安全功能     1.9 实时应用集群     1.10 Oracle流     1.11 Oracle企业管理器     1.12 Oracle初始参数     1.13 软件安装   第2章 Oracle Database 10g的升级     2.1 选择升级方法     2.2 升级前的准备工作     2.3 使用数据库升级助手     2.4 执行手工直接升级     2.5 使用Export和Import     2.6 使用数据复制方法     2.7 升级后的工作   第3章 计划和管理表空间     3.1 表空间的体系结构     3.2 Oracle安装表空间     3.3 段分离   第4章 物理数据库布局和存储管理     4.1 传统磁盘空间存储     4.2 自动存储管理 第Ⅱ部分 数据库管理  第5章 开发和实现应用程序     5.1 调整设计：最佳实践     5.2 资源管理和存储的概要     5.3 支持基于抽象数据类型的表     5.4 停顿并挂起数据库     5.5 支持迭代式开发     5.6 管理程序包开发   第6章 监控空间利用率     6.1 常见的空间管理问题     6.2 Oracle段、盘区和块     6.3 数据字典视图和动态性能视图     6.4 空间管理方法学     6.5 SYSAUX监控和使用     6.6 归档重做日志文件的管理     6.7 内置的空间管理工具     6.8 空间管理脚本     6.9 自动化和流水线化通知过程   第7章 使用撤销表空间管理事务     7.1 事务基础     7.2 撤销基础     7.3 管理撤销表空间     7.4 闪回特性     7.5 迁移到自动撤销管理   第8章 数据库调整     8.1 调整应用程序设计     8.2 调整SQL     8.3 调整内存使用率     8.4 调整数据访问     8.5 调整数据操作     8.6 调整物理存储     8.7 减少网络流量     8.8 使用STATSPACK和Automatic Workload Repository     8.9 调整解决方案   第9章 使用STATSPACK     9.1 安装STATSPACK     9.2 收集统计     9.3 运行统计报表     9.4 管理STATSPACK数据     9.5 卸载STATSPACK   第10章 数据库安全性和审计     10.1 非数据库的安全性     10.2 数据库验证方法     10.3 数据库授权方法     10.4 审计     10.5 数据加密技术 第Ⅲ部分 高可用性  第11章 实时应用集群     11.1 RAC概述     11.2 安装和配置     11.4 RAC维护   第12章 备份和恢复选项     12.1 功能     12.2 逻辑备份     12.3 物理备份     12.4 使用Data Pump Export和Data Pump Import     12.5 Data Pump Import选项     12.6 备份过程集成   第13章 使用恢复管理器(Recovery Manager，RMAN)     13.1 RMAN功能特性和组件     13.2 RMAN命令和选项概述     13.3 备份操作     13.4 恢复操作    13.5 其他操作   第14章 Oracle Data Guard(Oracle数据卫士)     14.1 Data Guard体系结构     14.2 LOG_ARCHIVE_DEST_n参数属性     14.3 创建备用数据库配置     14.4 使用实时应用     14.5 管理角色-- 切换和故障转移     14.6 管理数据库   第15章 其他各种高可用性特性     15.1 flashback table命令     15.2 flashback database命令     15.3 使用LogMiner     15.4 联机对象重组织 第Ⅳ部分 网络化的Oracle  第16章 Oracle网络(Oracle Net)     16.1 Oracle Net概述     16.2 使用Oracle Net Configuration Assistant(Oracle Net配置助手)     16.3 使用Oracle Net Manager     16.4 启动侦听程序服务器进程     16.5 对侦听程序服务器进程进行控制     16.6 使用Easy Connect Naming     16.7 使用数据库链接     16.8 调整Oracle Net   第17章 管理大型数据库     17.1 在VLDB环境中创建表空间     17.2 高级的Oracle表类型     17.4 Oracle Data Pump(Oracle数据泵)   第18章 管理分布式数据库     18.1 远程查询     18.2 远程数据处理：两阶段提交    18.3 动态数据复制     18.4 管理分布式数据     18.5 管理分布式事务处理     18.6 监控分布式数据库     18.7 调整分布式数据库 附录A 口令验证函数
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 10g DBA手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle PL/SQL最佳实践
前言
第1章 全局建议
成功的应用程序绝不是偶然事物
成功应用程序的最佳实践
第2章 真正的程序员会遵循标准
开发和使用标准的最佳实践
第3章 编译后的工作
测试、跟踪和调试
关于测试、跟踪和调试的最佳实践
第4章 没有变量的代码是什么样子
声明变量和数据结构的最佳实践
使用变量和数据结构的最佳实践
声明和使用包变量的最佳实践
第5章 作为交通警察的开发人员
条件和布尔逻辑的最佳实践
循环的最佳实践
分支逻辑的最佳实践
第6章 当杂乱无章时如何正确行事
第7章 摆脱对SQL的痴迷
SQL很糟糕
通用sQL的最佳实践
PL/SQL数据查询的最佳实践
PL/SQL数据修改的最佳实践
动态sQL的最佳实践
第8章 灵活掌控代码块
关于参数的最佳实践
关于过程和函数的最佳实践
关于包的最佳实践
关于触发器的最佳实践
第9章 我的代码运行速度高于你的代码
查找导致性能问题的SQL代码的最佳实践
实施最大程度解决性能问题的最佳实践
其他性能调整的最佳实践
附录A　最佳实践快速索引
附录B　PL/SQL开发人员资源
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle PL/SQL最佳实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深度挖掘
第一部分  集群理论篇  第1章  集群的概念和发展  第2章  RAC的结构和原理  第3章  存储和网络传输第二部分  运行维护篇  第4章  Oracle RAC安装配置  第5章  RAC管理和维护  第6章  RAC备份和恢复  第7章  Oracle故障诊断及工具第三部分  性能篇  第8章  RAC性能优化设计  第9章  Oracle最高可用架构设计附录  使用VMware Server在Linux上搭建Oracle 10g RAC学习环境
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深度挖掘
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle PL/SQL程序设计（上下册）
第1部分  PL/SQL编程
第1章  PL/SQL概述
第2章  创建并运行PL/SQL代码
第3章  语言基础
第2部分  PL/SQL程序结构
第4章  条件和顺序控制
第5章  用循环进行迭代处理
第6章  异常处理
第3部分  PL/SQL数据
第7章  使用数据
第8章  字符串
第9章  数字
第10章  日期和时间戳
第11章  记录类型
第12章  集合
第13章  其他数据类型
第4部分  PL/SQL中的SQL
第14章  DML和事务管理
第15章  数据提取
第16章  动态SQL和动态PL/SQL
第5部分  构造PL/SQL应用程序
第17章  过程、函数与参数
第18章  包
第19章  触发器
第20章  管理PL/SQL代码
第21章  PL/SQL的性能优化
第22章  I/O操作和PL/SQL
第6部分  高级PL/SQL主题
第23章  应用安全与PL/SQL
第24章  PL/SQL架构
第25章  PL/SQL的全球化和本地化
第26章  PL/SQL的面向对象特性
附录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle PL/SQL程序设计（上下册）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle从入门到精通
丛书序前言
第一篇　数据库安装篇
第1章　Oracle 11g数据库简介
第2章　Oracle 11g的安装与测试
第二篇 数据库基础篇
第3章　熟悉数据库
第4章　SQL基础
第5章 利用SELECT检索数据
第6章　Oracle内置函数
第7章　PL/SQL基础
第8章　游标—数据的缓存区
第9章　视图—数据库中虚拟的表
第10章　存储过程—提高程序执行的效率
第11章　触发器—保证数据的正确性
第12章　事务和锁—确保数据安全
第三篇 数据库管理篇
第13章　使用Oracle 11g Enterprise Manager
第14章　常用工具介绍
第15章　控制文件和日志文件
第16章　表空间的管理
第17章　与数据库安全性有关的对象
第18章　备份与恢复
第19章　使用RMAN工具
第四篇 数据库应用篇
第20章　在线考试系统数据库设计
第21章　在.NET中连接Oracle
第22章　在Java中连接Oracle
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle从入门到精通
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle从入门到精通
目  录
第1篇  基 础 知 识
第1章  Oracle 11g概述	3
视频讲解：1小时28分钟
1.1  Oracle发展史概述	4
1.2  关系型数据库的基本理论	5
1.2.1  关系型数据库与数据库管理系统	6
1.2.2  关系型数据库的E-R模型	7
1.2.3  关系型数据库的设计范式	8
1.3  Oracle 11g的新功能	11
1.4  Oracle 11g的安装与卸载	12
1.4.1  Oracle 11g的安装	12
1.4.2  Oracle 11g的卸载	18
1.5  Oracle 11g的管理工具	20
1.5.1  SQL*Plus工具	20
1.5.2  Oracle企业管理器	21
1.5.3  数据库配置助手	22
1.6  启动与关闭数据库实例	23
1.6.1  启动数据库实例	23
1.6.2  关闭数据库实例	25
1.7  小结	27
1.8  实践与练习	27
第2章  Oracle 11g体系结构	29
视频讲解：1小时30分钟
2.1  Oracle 11g体系结构概述	30
2.2  逻辑存储结构	30
2.2.1  数据块（Data Blocks）	31
2.2.2  数据区（Extent）	32
2.2.3  段（Segment）	32
2.2.4  表空间（TableSpace）	33
2.3  物理存储结构	34
2.3.1  数据文件	35
2.3.2  控制文件	36
2.3.3  日志文件	37
2.3.4  服务器参数文件	39
2.3.5  密码文件、警告文件和跟踪文件	41
2.4  Oracle 11g服务器结构	43
2.4.1  系统全局区（SGA）	43
2.4.2  程序全局区（PGA）	45
2.4.3  前台进程	46
2.4.4  后台进程	47
2.5  数据字典	50
2.5.1  Oracle数据字典概述	50
2.5.2  Oracle常用数据字典	50
2.6  小结	52
2.7  实践与练习	52
第3章  SQL*Plus命令	53
视频讲解：1小时24分钟
3.1  SQL*Plus与数据库的交互	54
3.2  设置SQL*Plus的运行环境	54
3.2.1  SET命令概述	55
3.2.2  使用SET命令设置运行环境	57
3.3  常用SQL*Plus命令	61
3.3.1  HELP命令	61
3.3.2  DESCRIBE命令	62
3.3.3  SPOOL命令	64
3.3.4  其他常用命令	65
3.4  格式化查询结果	67
3.4.1  COLUMN命令	68
3.4.2  TTITLE和BTITLE命令	70
3.5  小结	72
3.6  实践与练习	72
第4章  SQL语言基础	73
视频讲解：1小时12分钟
4.1  SQL语言概述	74
4.1.1  SQL语言的特点	74
4.1.2  SQL语言的分类	75
4.1.3  SQL语言的编写规则	75
4.2  用户模式	76
4.2.1  模式与模式对象	76
4.2.2  实例模式SCOTT	77
4.3  检索数据	78
4.3.1  简单查询	78
4.3.2  筛选查询	82
4.3.3  分组查询	86
4.3.4  排序查询	87
4.3.5  多表关联查询	88
4.4  Oracle常用系统函数	92
4.4.1  字符类函数	92
4.4.2  数字类函数	95
4.4.3  日期和时间类函数	97
4.4.4  转换类函数	98
4.4.5  聚合类函数	99
4.5  子查询的用法	99
4.5.1  子查询	100
4.5.2  单行子查询	101
4.5.3  多行子查询	101
4.5.4  关联子查询	102
4.6  操作数据库	103
4.6.1  插入数据（INSERT语句）	103
4.6.2  更新数据（UPDATE语句）	105
4.6.3  删除数据（DELETE语句和TRUNCATE
语句）	106
4.7  事务处理	107
4.7.1  事务概述	108
4.7.2  操作事务	108
4.8  小结	110
4.9  实践与练习	110
第5章  PL/SQL编程	111
视频讲解：1小时8分钟
5.1  PL/SQL概述	112
5.1.1  PL/SQL块结构	112
5.1.2  代码注释和标识符	113
5.2  数据类型与定义变量和常量	114
5.2.1  基本数据类型	115
5.2.2  特殊数据类型	116
5.2.3  定义变量和常量	119
5.3  流程控制语句	120
5.3.1  选择语句	120
5.3.2  循环语句	124
5.4  PL/SQL游标	127
5.4.1  显示游标	127
5.4.2  游标的属性	130
5.4.3  隐式游标	131
5.4.4  通过for语句循环游标	132
5.5  PL/SQL异常处理	133
5.5.1  预定义异常	134
5.5.2  自定义异常	135
5.6  小结	137
5.7  实践与练习	137
第6章  过程、函数、触发器和包	139
视频讲解：1小时36分钟
6.1  存储过程	140
6.1.1  创建存储过程	140
6.1.2  存储过程的参数	142
6.1.3  IN参数的默认值	147
6.2  函数	148
6.2.1  创建函数	148
6.2.2  调用函数	149
6.2.3  删除函数	150
6.3  触发器	150
6.3.1  触发器概述	150
6.3.2  语句级触发器	151
6.3.3  行级触发器	154
6.3.4  替换触发器	156
6.3.5  用户事件触发器	157
6.4  程序包	159
6.4.1  程序包的规范	160
6.4.2  程序包的主体	160

6.5  小结	163
6.6  实践与练习	163
第2篇  核 心 技 术
第7章  管理控制文件和日志文件	167
视频讲解：1小时16分钟
7.1  管理控制文件	168
7.1.1  控制文件概述	168
7.1.2  控制文件的多路复用	169
7.1.3  创建控制文件	171
7.1.4  备份和恢复控制文件	174
7.1.5  删除控制文件	176
7.1.6  查询控制文件的信息	177
7.2  管理重做日志文件	178
7.2.1  重做日志文件概述	178
7.2.2  增加日志组及其成员	179
7.2.3  删除重做日志	181
7.2.4  更改重做日志的位置或名称	182
7.2.5  查看重做日志信息	183
7.3  管理归档日志文件	184
7.3.1  日志模式分类	184
7.3.2  管理归档操作	186
7.3.3  设置归档文件位置	187
7.3.4  查看归档日志信息	190
7.4  小结	191
7.5  实践与练习	191
第8章  管理表空间和数据文件	193
视频讲解：58分钟
8.1  表空间与数据文件的关系	194
8.2  Oracle 11g的默认表空间	195
8.2.1  SYSTEM表空间	195
8.2.2  SYSAUX表空间	196
8.3  创建表空间	197
8.3.1  创建表空间的语法	197
8.3.2  通过本地化管理方式创建表空间	198
8.3.3  通过段空间管理方式创建表空间	199
8.3.4  创建非标准块表空间	200
8.3.5  建立大文件表空间	201
8.4  维护表空间与数据文件	202
8.4.1  设置默认表空间	202
8.4.2  更改表空间的状态	203
8.4.3  重命名表空间	203
8.4.4  删除表空间	204
8.4.5  维护表空间中的数据文件	204
8.5  管理撤销表空间	206
8.5.1  撤销表空间的作用	206
8.5.2  撤销表空间的初始化参数	207
8.5.3  撤销表空间的基本操作	208
8.6  管理临时表空间	212
8.6.1  临时表空间概述	212
8.6.2  创建临时表空间	212
8.6.3  查询临时表空间的信息	213
8.6.4  关于临时表空间组	213
8.7  小结	216
8.8  实践与练习	216
第9章  数据表对象	217
视频讲解：1小时10分钟
9.1  数据表概述	218
9.2  创建数据表	218
9.2.1  数据表的逻辑结构	218
9.2.2  创建一个数据表	220
9.2.3  数据表的特性	221
9.3  维护数据表	226
9.3.1  增加和删除字段	226
9.3.2  修改字段	228
9.3.3  重命名表	229
9.3.4  改变表空间和存储参数	229
9.3.5  删除表	230
9.3.6  修改表的状态	232
9.4  数据完整性和约束性	233
9.4.1  非空约束	233
9.4.2  主键约束	234
9.4.3  唯一性约束	237
9.4.4  外键约束	238
9.4.5  禁用和激活约束	241
9.4.6  删除约束	243
9.5  小结	243
9.6  实践与练习	244
第10章  其他数据对象	245
视频讲解：55分钟
10.1  索引对象	246
10.1.1  索引概述	246
10.1.2  创建索引	247
10.1.3  修改索引	251
10.1.4  删除索引	252
10.1.5  显示索引信息	253
10.2  视图对象	255
10.2.1  创建视图	255
10.2.2  管理视图	259
10.3  同义词对象	260
10.4  序列对象	262
10.4.1  创建序列	262
10.4.2  管理序列	264
10.5  小结	265
10.6  实践与练习	265
第11章  表分区与索引分区	267
视频讲解：46分钟
11.1  分区技术概述	268
11.2  创建表分区	268
11.2.1  范围分区	268
11.2.2  散列分区	270
11.2.3  列表分区	272
11.2.4  组合分区	273
11.2.5  Interval分区	274
11.3  表分区策略	275
11.4  管理表分区	275
11.4.1  添加表分区	275
11.4.2  合并分区	276
11.4.3  删除分区	276
11.4.4  并入分区	278
11.5  创建索引分区	280
11.5.1  索引分区概述	280
11.5.2  本地索引分区	280
11.5.3  全局索引分区	282
11.6  管理索引分区	282
11.6.1  索引分区管理的操作列表	282
11.6.2  索引分区管理的实际操作	283
11.7  小结	284
11.8  实践与练习	284
第12章  用户管理与权限分配	285
视频讲解：48分钟
12.1  用户与模式的关系	286
12.2  创建与管理用户	287
12.2.1  身份验证	287
12.2.2  创建用户	287
12.2.3  修改用户	289
12.2.4  删除用户	290
12.3  用户权限管理	291
12.3.1  权限简介	291
12.3.2  授权操作	291
12.3.3  回收系统权限	293
12.3.4  对象授权	294
12.3.5  回收对象权限	294
12.3.6  查询用户与权限	295
12.4  角色管理	295
12.4.1  角色概述	295
12.4.2  预定义角色	296
12.4.3  创建角色与授权	298
12.4.4  管理角色	299
12.4.5  角色与权限的查询	300
12.5  资源配置PROFILE	301
12.5.1  PROFILE概述	301
12.5.2  使用PROFILE管理密码	302
12.5.3  使用PROFILE管理资源	304
12.5.4  维护PROFILE文件	305
12.5.5  显示PROFILE信息	306

12.6  小结	307
12.7  实践与练习	307

第3篇  高 级 应 用
第13章  Oracle系统调优	311
视频讲解：28分钟
13.1  调整初始化参数	312
13.1.1  Oracle初始化参数分类	312
13.1.2  主要系统调优参数介绍	312
13.2  系统全局区（SGA）优化	314
13.2.1  调整内存分配	314
13.2.2  调整日志缓冲区	314
13.2.3  调整共享池	316
13.2.4  调整数据库缓冲区	319
13.2.5  SGA调优建议	319
13.3  排序区优化	319
13.3.1  排序区与其他内存区的关系	320
13.3.2  排序活动	320
13.3.3  专用模式下排序区的调整	321
13.3.4  共享模式下排序区的调整	323
13.4  小结	324
13.5  实践与练习	324
第14章  优化SQL语句	325
视频讲解：26分钟
14.1  常规SQL语句优化	326
14.1.1  建议不用“*”来代替所有列名	326
14.1.2  用TRUNCATE代替DELETE	326
14.1.3  在确保完整性的情况下多用COMMIT
语句	327
14.1.4  尽量减少表的查询次数	327
14.1.5  用[NOT] EXISTS代替[NOT] IN	327
14.2  表连接优化	328
14.2.1  驱动表的选择	328
14.2.2  WHERE子句的连接顺序	328
14.3  合理使用索引	329
14.3.1  何时使用索引	329
14.3.2  索引列和表达式的选择	329
14.3.3  选择复合索引主列	329
14.3.4  避免全表扫描大表	330
14.3.5  监视索引是否被使用	330
14.4  优化器的使用	331
14.4.1  优化器的概念	331
14.4.2  运行EXPLAIN PLAN	332
14.4.3  Oracle 11g中SQL执行计划的
管理	332
14.5  数据库和SQL重演	333
14.5.1  数据库重演	333
14.5.2  SQL重演	333
14.6  Oracle的性能顾问	334
14.6.1  SQL调优顾问	334
14.6.2  SQL访问顾问	335
14.7  小结	335
14.8  实践与练习	335
第15章  Oracle数据备份与恢复	337
视频讲解：44分钟
15.1  备份与恢复概述	338
15.2  RMAN工具概述	339
15.2.1  RMAN组件	339
15.2.2  RMAN通道	341
15.2.3  RMAN命令	343
15.3  使用RMAN工具备份	345
15.3.1  RMAN备份策略	345
15.3.2  使用RMAN备份数据库文件和归档
日志	346
15.3.3  增量备份	349
15.4  使用RMAN工具完全恢复	349
15.4.1  恢复处于NOARCHIVELOG模式的
数据库	350
15.4.2  恢复处于ARCHIVELOG模式的
数据库	351
15.5  使用RMAN工具部分恢复	352
15.5.1  基于时间的不完全恢复	352
15.5.2  基于更改的不完全恢复	354
15.6  小结	355
15.7  实践与练习	355
第16章  数据导出和导入	357
视频讲解：40分钟
16.1  EXPDP和IMPDP概述	358
16.2  EXPDP导出数据	358
16.2.1  执行EXPDP命令	358
16.2.2  EXPDP命令参数	361
16.3  IMPDP导入数据	363
16.3.1  执行IMPDP命令	363
16.3.2  IMPDP命令参数	364
16.4  SQL* Loader工具	366
16.4.1  SQL* Loader概述	366
16.4.2  加载数据	367

16.5  小结	369
16.6  实践与练习	369
第17章  Oracle 11g的闪回技术	371
视频讲解：30分钟
17.1  闪回技术概述	372
17.2  闪回数据库	372
17.2.1  闪回恢复区配置	373
17.2.2  闪回数据库配置	373
17.2.3  闪回数据库技术应用	374
17.3  闪回表	376
17.3.1  闪回表命令的语法	376
17.3.2  闪回表的应用	376
17.4  闪回丢弃	378
17.4.1  回收站概述	378
17.4.2  回收站的应用	378
17.5  其他闪回技术	379
17.5.1  闪回版本查询	380
17.5.2  闪回事务查询	380
17.5.3  闪回数据归档	380
17.6  小结	381
17.7  实践与练习	381
第4篇  项 目 实 战
第18章  企业人事管理系统	385
视频讲解：2小时43分钟
18.1  开发背景	386
18.2  系统分析	386
18.3  系统设计	386
18.3.1  系统目标	386
18.3.2  系统功能结构	387
18.3.3  系统预览	388
18.3.4  业务流程图	390
18.3.5  文件夹结构设计	390
18.4  数据库设计	391
18.4.1  数据库分析	391
18.4.2  数据库概念设计	391
18.4.3  数据库逻辑结构设计	392
18.5  主窗体设计	393
18.5.1  导航栏的设计	393
18.5.2  工具栏的设计	395
18.6  公共模块设计	397
18.6.1  编写Hibernate配置文件	398
18.6.2  编写Hibernate持久化类和映射
文件	398
18.6.3  编写通过Hibernate操作持久化对象的
常用方法	399
18.6.4  创建用于特殊效果的部门树对话框	400
18.6.5  创建通过部门树选取员工的面板和
对话框	402
18.7  人事管理模块设计	403
18.7.1  人事管理模块功能概述	404
18.7.2  人事管理模块技术分析	405
18.7.3  人事管理模块实现过程	405
18.8  待遇管理模块设计	410
18.8.1  待遇管理模块功能概述	410
18.8.2  待遇管理模块技术分析	411
18.8.3  待遇管理模块实现过程	411
18.9  系统维护模块设计	415
18.9.1  系统维护模块功能概述	415
18.9.2  系统维护模块技术分析	417
18.9.3  系统维护模块实现过程	417
18.10  Hibernate关联关系的建立方法	421
18.10.1  建立一对一关联	421
18.10.2  建立一对多关联	422
18.11  小结	424
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle从入门到精通
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Oracle Exadata
作者介绍	xxxi
技术审校者	xxxiii
致谢	xxxv
前言	xxxvii
第1章 exadata是什么	1
1.1 exadata概览	2
1.2 exadata的历史	3
1.3 不同的视角	4
1.3.1 数据仓库设备	4
1.3.2 联机事务处理机器	5
1.3.3 合并平台	5
1.4 可选配置	6
1.4.1 exadata database machine x2-2	6
1.4.2 exadata database machine x2-8	7
1.5 硬件组件	8
1.5.1 操作系统	9
1.5.2 数据库服务器	9
1.5.3 存储服务器	9
1.5.4 infiniband	10
.1.5.5 闪存	10
1.5.6 磁盘	10
1.5.7 其他杂项	10
1.6 软件组件	11
1.6.1 数据库服务器软件	11
1.6.2 存储服务器软件	14
1.7 软件架构	16
1.8 总结	20
第2章 卸载/智能扫描	21
2.1 为何卸载如此重要	21
2.2 卸载包含了什么	25
2.2.1 字段投影	25
2.2.2 谓词过滤	30
2.2.3 存储索引	32
2.2.4 简单连接（布隆过滤）	33
2.2.5 函数卸载	36
2.2.6 压缩/解压缩	38
2.2.7 加密/解密	40
2.2.8 虚拟列	40
2.2.9 数据挖掘模型评分	43
2.2.10 非智能扫描类型的卸载	44
2.3 智能扫描的先决条件	45
2.3.1 全扫描	45
2.3.2 直接路径读取	45
2.3.3 exadata存储	46
2.4 无法使用智能扫描的情况	49
2.4.1 未实现的功能	49
2.4.2 转换为块运输模式	49
2.4.3 跳过某些卸载操作	50
2.5 如何验证智能扫描确实发生	50
2.5.1 10046跟踪	52
2.5.2 性能统计（v$sessstat）	53
2.5.3 卸载适用字节	55
2.5.4 sql监控	60
2.6 参数	63
2.7 总结	67
第3章 混合列式压缩	69
3.1 oracle存储概述	69
3.2 oracle压缩机制	72
3.2.1 basic	72
3.2.2 oltp	72
3.2.3 hcc	72
3.3 hcc工作机制	76
3.4 hcc性能	77
3.4.1 加载性能	77
3.4.2 查询性能	82
3.4.3 dml性能	88
3.5 预期压缩率	98
3.5.1 压缩助手	98
3.5.2 真实案例	101
3.6 限制与挑战	107
3.6.1 迁移数据到非exadata平台	107
3.6.2 关闭串行直接路径读取	108
3.6.3 锁的问题	108
3.6.4 单行访问	109
3.7 常见的使用场景	110
3.8 总结	111
第4章 存储索引	113
4.1 结构	113
4.2 监控存储索引	114
4.2.1 数据库统计值	115
4.2.2 跟踪	116
4.2.3 总结	119
4.3 控制存储索引	119
4.3.1 _kcfis_storageidx_disabled	120
4.3.2 _kcfis_storageidx_diag_mode	120
4.3.3 _cell_storidx_mode	120
4.3.4 存储软件参数	121
4.4 行为	121
4.5 性能	122
4.5.1 为空值进行特殊优化	124
4.5.2 字段值的物理分布	125
4.6 潜在问题	127
4.6.1 不正确的结果	127
4.6.2 类型转换	128
4.6.3 分区大小	131
4.6.4 不兼容的编程技巧	131
4.7 总结	133
第5章 exadata智能闪存	135
5.1 硬件	135
5.2 cache vs. flash disk	136
5.2.1 使用闪存作为缓存	137
5.2.2 如何创建esfc	142
5.2.3 控制esfc的使用	144
5.3 监控	145
5.3.1 存储监控	145
5.3.2 数据库监控	148
5.4 性能	149
5.5 总结	151
第6章 exadata并行操作	153
6.1 参数	153
6.2 存储层的并行	154
6.3 自动并行度	155
6.3.1 操作和配置	155
6.3.2 i/o基准测试	158
6.3.3 自动并行度调整小结	162
6.4 并行语句队列	162
6.4.1 老方法	162
6.4.2 新方法	163
6.4.3 控制并行队列	167
6.4.4 并行语句队列小结	175
6.5 内存并行执行	176
6.6 总结	186
第7章 资源管理	187
7.1 数据库资源管理器	188
7.1.1 使用者组	189
7.1.2 计划指令	193
7.1.3 资源计划	194
7.1.4 资源管理器视图	195
7.1.5 等待事件：resmgr:cpu quantum	196
7.1.6 一个dbrm的例子	197
7.1.7 测试资源计划	202
7.2 实例隔离	210
7.2.1 配置和测试实例隔离	211
7.2.2 过量分配	215
7.3 i/o 资源管理器	216
7.3.1 iorm如何工作	218
7.3.2 exadata管理i/o的方法	221
7.3.3 把所有的一切组合在一起	227
7.3.4 iorm监控和指标	230
7.4 总结	244
第8章 exadata的配置	245
8.1 exadata的网络组件	245
8.1.1 管理网络	246
8.1.2 客户端访问网络	246
8.1.3 私有网络	247
8.2 关于配置过程	248
8.3 配置exadata	250
8.3.1 第1步：配置工作	250
8.3.2 第2步：dbm配置器	259
8.3.3 第3步：上传参数和部署文件	260
8.3.4 第4步：checkip（checkip.sh）	263
8.3.5 第5步：第一次引导firstboot	265
8.3.6 第6步：准备安装介质	268
8.3.7 第7步：运行onecommand	269
8.4 升级exadata	273
8.4.1 创建一个新的rac集群	273
8.4.2 升级现有的群集	275
8.5 总结	278
第9章 exadata的恢复	279
9.1 exadata的诊断工具	279
9.1.1 sun diagnostics:sundiag.sh	280
9.1.2 健康检查healthcheck	282
9.1.3 cellcli	283
9.2 exadata的备份	287
9.2.1 数据库服务器的备份	288
9.2.2 存储节点的备份	292
9.3 数据库的备份	298
9.3.1 基于磁盘的备份	298
9.3.2 基于磁带的备份	298
9.3.3 从standby数据库上进行备份	299
9.3.4 exadata对rman的优化	300
9.4 exadata的恢复	301
9.4.1 数据库服务器的恢复	301
9.4.2 存储节点的恢复	305
9.5 总结	325
第10章 exadata等待事件	327
10.1 exadata特有的事件	327
10.1.1 节点事件	328
10.1.2 触发事件的执行计划步骤	329
10.2 用户i/o类别中的exadata等待事件	331
10.2.1 cell smart table scan	332
10.2.2 cell smart index scan	335
10.2.3 cell single block physical read	337
10.2.4 cell multiblock physical read	339
10.2.5 cell list of blocks physical read	340
10.2.6 cell smart file creation	341
10.2.7 cell statistics gather	342
10.3 系统i/o类别中的exadata等待事件	343
10.3.1 cell smart incremental backup	343
10.3.2 cell smart restore from backup	344
10.4 其他类别和空闲类别中的exadata等待事件	346
10.4.1 cell smart flash unkeep	346
10.5 旧事件	347
10.5.1 direct path read	347
10.5.2 enq: ko—fast object checkpoint	348
10.5.3 reliable message	349
10.6 资源管理事件	350
10.6.1 resmgr:cpu quantum	350
10.6.2 resmgr:pq queued	351
10.7 总结	352
第11章 理解exadata的性能指标	353
11.1 exadata性能指标的衡量	353
11.2 重温exadata智能扫描的先决条件	354
11.2.1 exadata智能扫描的性能	354
11.2.2 理解exadata智能扫描指标和性能计数器	358
11.3 exadata的动态性能计数器	359
11.3.1 何时及如何使用性能计数器	359
11.3.2 exadata的性能计数器的含义和说明	363
11.3.3 exadata的性能计数器参考	366
11.4 了解sql语句的性能	383
11.5 总结	386
第12章 exadata性能监控	387
12.1 系统方法论	387
12.2 sql语句的响应时间监控	388
12.2.1 利用实时的sql 监控报告对sql语句进行监控	389
12.2.2 使用v$sql和v$sqlstats监控sql语句	400
12.3 监控存储节点	403
12.3.1 在存储节点利用cellcli访问性能指标	403
12.3.2 使用grid control的exadata存储服务器插件访问性能指标	404
12.3.3 使用哪些性能指标	413
12.3.4 监控exadata 存储节点的os性能	414
12.4 总结	427
第13章 迁移到exadata	429
13.1 迁移策略	430
13.2 逻辑迁移	430
13.2.1 抽取和加载	431
13.2.2 通过数据库链复制数据	437
13.2.3 基于同步复制的迁移	454
13.2.4 逻辑迁移小结	461
13.3 物理迁移	461
13.4 备份和恢复	462
13.4.1 全备份和恢复	462
13.4.2 增量备份	464
13.4.3 传输表空间（和跨平台传输表空间xtts）	465
13.4.4 物理standby	468
13.4.5 asm重平衡	470
13.4.6 迁移后的任务	473
13.4.7 物理迁移小结	474
13.5 总结	475
第14章 存储设计	477
14.1 exadata 磁盘架构	477
14.1.1 失效组	478
14.1.2 网格盘	480
14.1.3 存储分布	482
14.2 创建网格盘	486
14.2.1 创建网格盘	487
14.2.2 网格盘大小	488
14.2.3 创建基于闪存盘的网格盘	491
14.3 存储策略	493
14.3.1 配置选项	493
14.3.2 隔离存储节点访问	494
14.4 节点安全策略	496
14.4.1 节点安全策略的术语	496
14.4.2 节点安全策略最佳实践	497
14.4.3 配置asm范围安全策略	497
14.4.4 配置数据库范围安全策略	499
14.4.5 删除节点安全策略	501
14.5 总结	503
第15章 计算节点设计	505
15.1 配置考虑	505
15.2 non-rac环境配置	507
15.3 rac集群	511
15.4 exadata典型配置	514
15.5 exadata集群	515
15.6 总结	516
第16章 忘记已知	517
16.1 双系统记	517
16.2 类型负载	517
16.2.1 exadata smart flash cache (esfc)	518
16.2.2 可扩展性	519
16.2.3 写密集型oltp负载	519
16.3 dw类型负载	519
16.3.1 启用智能扫描	520
16.3.2 阻碍智能扫描的因素	522
16.3.3 其他注意事项	533
16.4 混合负载	535
16.4.1 要索引还是不要？	535
16.4.2 优化器的局限	536
16.4.3 使用资源管理器	540
16.5 总结	540
附录a cellcli和dcli	541
附录b exadata在线资源	553
附录c 诊断脚本	555
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Oracle Exadata
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle索引技术
第1章 　Oracle 索引　　1
1.1 　用索引提高性能　　2
1.2 　确定使用哪种类型的索引　　4
1.2.1 　B树索引　　5
1.2.2 　特定的索引类型　　7
1.3 　确定需要建立索引的列　　10
1.3.1 　主键列和唯一键列的索引　　11
1.3.2 　外键列的索引　　11
1.3.3 　其他适合创建索引的列　　12
1.4 　索引指南　　12
1.5 　小结　　13
第2章 　B树索引　　15
2.1 　Oracle如何使用B树索引　　15
2.1.1 　场景一：所有的数据位于索引块　　17
2.1.2 　场景二：索引中不包含所有信息　　19
2.1.3?场景三：只有表块被访问　　20
2.2 　准备创建B树索引　　21
2.2.1 　在创建前估计索引的大小　　21
2.2.2 　为索引创建单独的表空间　　22
2.2.3 　从表空间继承存储参数　　23
2.2.4 　命名标准　　24
2.3 　实现B树索引　　24
2.3.1 　创建B树索引　　24
2.3.2 　报告索引　　25
2.3.3 　显示创建索引的代码　　26
2.3.4 　删除B树索引　　27
2.4 　管理带约束的B树索引　　28
2.4.1 　在主键列上创建B树索引　　29
2.4.2 　在唯一键列上创建B树索引　　33
2.4.3 　索引外键列　　36
2.5 　小结　　39
第3章 　位图索引　　40
3.1 　位图索引　　41
3.2 　创建位图索引　　44
3.3 　创建分区的位图索引　　45
3.4 　在索引组织表上创建位图索引　　45
3.5 　位图索引对查询性能的影响　　46
3.6 　位图索引对数据载入性能的影响　　50
3.7 　了解位图连接索引　　53
3.8 　创建位图连接索引　　54
3.9 　报告位图索引　　55
3.10 　小结　　55
第4章 　索引组织表　　56
4.1 　索引组织表的结构　　56
4.2 　索引组织表的优势　　57
4.3 　创建索引组织表　　58
4.4 　添加溢出段　　60
4.5 　压缩索引组织表　　62
4.6 　构建二级索引　　63
4.7 　重建索引组织表　　66
4.8 　索引组织表报告　　67
4.9 　小结　　68
第5章 　专门索引　　69
5.1 　不可见索引　　69
5.1.1 　不可见索引的用途　　69
5.1.2 　创建不可见索引　　70
5.1.3 　在数据库中查找不可见索引　　71
5.1.4 　让优化器使用不可见索引　　71
5.1.5 　维护不可见索引　　72
5.2 　基于函数的索引　　72
5.2.1 　创建基于函数的索引　　73
5.2.2 　基于函数的索引的限制　　76
5.2.3 　收集基于函数的索引的统计信息　　77
5.3 　虚拟列上的索引　　78
5.4 　键压缩索引　　80
5.4.1 　键压缩的用途　　81
5.4.2 　创建压缩索引　　82
5.4.3 　键压缩和存储　　84
5.5 　复合索引　　85
5.5.1 　了解索引跳跃式扫描和复合索引　　85
5.5.2 　在复合索引中对列进行排列　　86
5.5.3 　为复合索引选择键　　87
5.6 　创建虚拟索引　　89
5.7 　反向键索引　　91
5.7.1 　反向键索引的缺点　　92
5.7.2 　反向键索引的用途　　94
5.7.3 　创建反向键索引　　94
5.8 　应用程序域索引　　94
5.9 　小结　　95
第6章 　分区索引　　96
6.1 　分区索引　　96
6.2 　创建本地分区索引　　97
6.2.1 　最简单的形式　　97
6.2.2 　分区级的需求　　98
6.2.3 　前缀和非前缀选项　　99
6.3 　管理主键和唯一索引　　99
6.4 　创建全局分区索引　　101
6.5 　为应用程序选择索引　　105
6.6 　维护分区表的索引　　106
6.6.1 　添加分区　　106
6.6.2 　截断分区　　107
6.6.3 　移动分区　　108
6.6.4 　拆分分区　　108
6.6.5 　交换分区　　110
6.6.6 　删除分区　　111
6.6.7 　合并分区　　111
6.7 　重建全局分区索引和非分区索引　　112
6.8 　把索引分区设置为不可用后重建　　113
6.9 　索引对间隔分区的影响　　115
6.10 　使旧的数据只读　　116
6.11 　报告分区索引　　116
6.12 　小结　　118
第7章 　索引使用调优　　119
7.1 　优化器访问路径　　119
7.2 　索引扫描　　120
7.2.1 　索引唯一扫描　　120
7.2.2 　索引范围扫描　　121
7.2.3 　索引跳跃式扫描　　123
7.2.4 　全索引扫描　　124
7.2.5 　索引快速全扫描　　125
7.3 　确定查询是否使用了索引　　125
7.4 　避免使用索引　　127
7.4.1 　在任何情况下都不使用某个索引　　127
7.4.2 　只避免快速扫描　　128
7.4.3 　强制表扫描　　128
7.5 　在索引和表扫描之间选择　　128
7.6 　优化器忽略索引的原因　　129
7.6.1 　不同的行数　　129
7.6.2 　索引聚簇因子　　130
7.7 　索引访问路径因没有新的统计信息而改变　　131
7.7.1 　使用不等条件　　131
7.7.2 　使用通配符查询　　133
7.7.3 　在谓词中引用空值　　134
7.7.4 　在查询中包含函数　　135
7.7.5 　跳过索引的前导部分　　136
7.8 　强制优化器使用索引　　136
7.8.1 　应用INDEX提示　　137
7.8.2 　应用相关的提示　　138
7.8.3 　对失败的索引提示进行诊断　　139
7.8.4 　调整optimizer_index_cost_adj参数　　140
7.8.5 　为索引收集准确的统计信息　　142
7.9 　并行化索引访问　　143
7.10 　小结　　144
第8章 　维护索引　　145
8.1 　收集索引统计信息　　145
8.1.1 　DBMS_STATS包　　145
8.1.2 　METHOD_OPT参数　　147
8.2 　处理不可用索引　　148
8.2.1 　使索引不可用　　149
8.2.2 　指定SKIP_UNUSABLE_INDEXES参数　　150
8.3 　管理索引使用的空间　　153
8.3.1 　重建索引以减少碎片　　153
8.3.2 　重建反向键索引　　154
8.3.3 　回收未使用的空间　　154
8.3.4 　重建分区索引　　154
8.3.5 　频繁重建索引　　157
8.4 　INDEX_STATS视图在重建索引时的作用　　157
8.4.1 　INDEX_STATS视图的优点　　158
8.4.2 　INDEX_STATS视图的问题　　160
8.5 　关于重建索引的争论　　162
8.5.1 　重建索引的理由　　162
8.5.2 　反对重建的理由　　163
8.5.3 　关于重建索引的建议　　163
8.6 　合并索引来减少碎片　　164
8.7 　收缩索引以减少碎片　　165
8.8 　移动表和索引　　166
8.9 　提高创建索引的效率　　167
8.9.1 　并行创建索引　　167
8.9.2 　避免在索引创建期间生成重做　　168
8.9.3 　使用较大的块　　169
8.9.4 　压缩索引　　169
8.9.5 　同时使用多个选项　　170
8.10 　生成DDL从而创建索引　　170
8.10.1 　使用DBMS_METADATA包　　170
8.10.2 　使用SESSION_TRANSFORM存储过程　　171
8.10.3 　使用SET_FILTER存储过程　　172
8.10.4 　使用数据泵　　173
8.11 　删除索引　　173
8.12 　小结　　174
第9章 　SQL调优顾问　　176
9.1 　工具之间的联系　　176
9.2 　自动SQL调优作业　　178
9.2.1 　验证自动作业在运行　　178
9.2.2 　查看自动SQL调优作业中的建议　　179
9.2.3 　生成SQL脚本来实施自动调优建议　　181
9.2.4 　禁用和启用自动SQL调优　　182
9.3 　管理SQL调优集　　183
9.3.1 　在AWR中查看占用大量资源的SQL　　184
9.3.2 　查看内存中使用大量资源的SQL　　186
9.3.3 　用AWR中占用大量资源的SQL填充SQL调优集　　187
9.3.4 　用内存中占用大量资源的SQL填充SQL调优集　　188
9.3.5 　用内存中所有的SQL来填充SQL调优集　　189
9.3.6 　显示SQL调优集的内容　　190
9.3.7 　选择性删除SQL调优集中的语句　　192
9.3.8 　将语句添加到现有的SQL调优集　　193
9.3.9 　删除SQL调优集　　193
9.4 　运行SQL调优顾问　　193
9.4.1 　创建调优任务　　195
9.4.2 　执行DBMS_SQLTUNE并查看建议　　197
9.4.3 　查看和删除调优任务　　197
9.4.4 　从SQL Developer中运行SQL调优顾问　　197
9.4.5 　从企业管理器运行SQL调优顾问　　198
9.5 　小结　　199
第10章 　SQL访问顾问　　200
10.1 　为单个SQL语句生成的建议　　201
10.2 　获得一组SQL语句的建议　　203
10.3 　查询顾问视图　　209
10.4 　小结　　210

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle索引技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>未公开的Oracle数据库秘密
第一部分 初始化参数
第1章 在文档中部分说明的参数 2
1.1 AUDIT_SYSLOG_LEVEL 2
1.1.1 syslog设备 2
1.1.2 审计简介 3
1.1.3 使用AUDIT_SYSLOG_LEVEL参数 4
1.1.4 审计非特权用户 5
1.1.5 小结 6
1.2 PGA_AGGREGATE_TARGET 6
1.2.1 自动PGA内存管理介绍 7
1.2.2 对PGA_AGGREGATE_TARGET的误解 8
1.2.3 研究PGA_AGGREGATE_TARGET 9
1.2.4 使用管道表函数创建一个大表 9
1.2.5 V$SQL_WORKAREA_ACTIVE 10
1.2.6 _PGA_MAX_SIZE 14
1.2.7 _SMM_MAX_SIZE 15
1.2.8 _SMM_PX_MAX_SIZE 15
1.2.9 共享服务器 15
1.2.10 并行执行 16
1.2.11 小结 17
1.3 EVENT 18
1.3.1 语法 18
1.3.2 在实例级别均衡事件 19
1.3.3 案例研究 19
1.4 OS_AUTHENT_PREFIX 19
1.4.1 OPS$数据库用户及密码文件身份认证 20
1.4.2 案例研究 20
1.4.3 小结 23
1.5 源代码库 23
第2章 隐藏的初始化参数 24
2.1 跟踪文件权限与_TRACE_FILES_PUBLIC参数 24
2.2 ASM测试环境与_ASM_ALLOW_ONLY_RAW_DISKS参数 26
2.2.1 ASM隐藏参数 26
2.2.2 为ASM配置Oracle集群件 27
2.2.3 ASM实例设置 28
2.2.4 磁盘失效模拟 31
2.3 源代码库 31
第二部分 数据字典基表
第3章 数据字典基表介绍 34
第4章 IND$、V$OBJECT_USAGE和索引监控 38
4.1 模式限制 38
4.2 索引使用监控案例研究 39
4.2.1 MONITOR_SCHEMA_INDEXES函数 40
4.2.2 为HR模式启动索引监控 40
4.2.3 小结 44
4.3 源代码库 45
第三部分 事件
第5章 10027事件和死锁诊断 48
5.1 死锁 48
5.2 10027事件 49
第6章 10046事件和扩展SQL跟踪 52
第7章 10053事件和基于成本的优化器 54
7.1 跟踪文件的内容 57
7.2 案例研究 57
7.2.1 查询块和对象标识符 58
7.2.2 考虑的查询转换 58
7.2.3 说明 60
7.2.4 绑定变量窥视的结果 61
7.2.5 优化器参数 61
7.2.6 系统统计信息 66
7.2.7 表和索引的对象统计信息 67
7.2.8 单表访问路径和成本 68
7.2.9 联结顺序 70
7.2.10 执行计划 73
7.2.11 谓词信息 74
7.2.12 提示和查询块名称 74
7.3 源代码库 75
第8章 10079事件和Oracle网络数据包的内容 76
第四部分 X$固定表
第9章 X$固定表介绍 80
9.1 X$固定表与C语言编程 80
9.2 分层系统结构 81
9.3 授权访问X$表与V$视图 82
9.4 从V$视图深入剖析X$固定表 83
9.5 X$表与V$视图之间的关系 88
9.6 源代码库 89
第10章 X$BH表及闩锁争用 90
第11章 X$KSLED以及增强的会话等待数据 96
11.1 深度探讨视图V$SESSION_WAIT 96
11.2 改进的V$SESSION_WAIT视图 97
11.3 源代码库 100
第12章 X$KFFXP与ASM元数据 101
12.1 固定表X$KFFXP 101
12.2 抢救SPFILE文件 102
12.3 映射数据段到ASM存储 104
第五部分 SQL语句
第13章 ALTER SESSION/SYSTEMSET EVENTS 108
13.1 跟踪你自己的会话 108
13.2 ALTER SESSION SET EVENTS 109
13.3 ALTER SYSTEM SET EVENTS 110
13.4 ALTER SESSION/SYSTEM SETEVENTS和诊断转储 111
13.5 立即转储 112
第14章 ALTER SESSION SETCURRENT_SCHEMA 113
14.1 特权用户与模式用户 113
14.2 ALTER SESSION SET CURRENT_SCHEMA限制 115
14.2.1 高级队列 116
14.2.2 RENAME 116
14.2.3 私有数据库链接 117
14.2.4 存储概要 118
第15章 ALTER USER IDENTIFIED BYVALUES 119
15.1 密码游戏 119
15.2 用ALTER USER IDENTIFIED BYVALUES锁定账户 121
15.3 ALTER USER和未加密的密码 122
第16章 SELECT FOR UPDATE SKIPLOCKED 124
16.1 高级队列 124
16.2 Contention和SELECT FOR UPDATESKIP LOCKED 126
16.3 DBMS_LOCK——题外话 133
16.4 源代码库 136
第六部分 提供的PL/SQL程序包
第17章 DBMS_BACKUP_RESTORE 138
17.1 恢复管理器 138
17.2 TDPO灾难恢复案例研究 142
17.3 源代码库 144
第18章 DBMS_IJOB 145
18.1 介绍DBMS_JOB 145
18.2 BROKEN过程 145
18.2.1 语法 145
18.2.2 参数 146
18.2.3 使用说明 146
18.2.4 范例 146
18.3 FULL_EXPORT过程 146
18.3.1 语法 147
18.3.2 参数 147
18.3.3 范例 147
18.4 REMOVE过程 148
18.4.1 语法 148
18.4.2 参数 148
18.4.3 范例 148
18.5 RUN过程 148
18.5.1 语法 148
18.5.2 参数 148
18.5.3 使用说明 149
18.5.4 范例 149
18.6 源代码库 150
第19章 DBMS_SCHEDULER 151
19.1 使用数据库调度器运行外部作业 151
19.1.1 退出代码处理 152
19.1.2 标准错误输出 153
19.2 UNIX系统上的外部作业 155
19.2.1 清除环境变量 155
19.2.2 命令行处理 157
19.2.3 外部作业与非特权用户 159
19.3 Windows系统上的外部作业 161
19.3.1 命令行参数处理 161
19.3.2 Windows环境变量 162
19.3.3 外部作业与非特权用户 163
19.3.4 ORADIM实用工具创建的服务 163
19.3.5 OracleJobScheduler服务 163
19.4 源代码库 164
第20章 DBMS_SYSTEM 165
20.1 GET_ENV过程 165
20.1.1 语法 165
20.1.2 参数 165
20.1.3 使用说明 166
20.1.4 范例 166
20.2 KCFRMS过程 166
20.2.1 语法 166
20.2.2 使用说明 166
20.2.3 范例 166
20.3 KSDDDT过程 168
20.3.1 语法 168
20.3.2 使用说明 168
20.3.3 范例 168
20.4 KSDFLS过程 169
20.4.1 语法 169
20.4.2 使用说明 169
20.4.3 范例 169
20.5 KSDIND过程 169
20.5.1 语法 169
20.5.2 参数 169
20.5.3 使用说明 169
20.5.4 范例 170
20.6 KSDWRT过程 170
20.6.1 语法 170
20.6.2 参数 170
20.6.3 使用说明 170
20.6.4 范例 171
20.7 READ_EV过程 171
20.7.1 语法 171
20.7.2 参数 172
20.7.3 使用说明 172
20.7.4 范例 172
20.8 SET_INT_PARAM_IN_SESSION过程 172
20.8.1 语法 173
20.8.2 参数 173
20.8.3 使用说明 173
20.8.4 示例 173
20.9 SET_BOOL_PARAM_IN_SESSION过程 174
20.9.1 语法 174
20.9.2 参数 174
20.9.3 使用说明 174
20.9.4 示例 174
20.10 SET_EV过程 175
20.10.1 语法 175
20.10.2 参数 175
20.10.3 使用说明 175
20.10.4 范例 175
20.11 SET_SQL_TRACE_IN_SESSION转储 177
20.11.1 语法 177
20.11.2 参数 177
20.11.3 使用说明 177
20.11.4 范例 177
20.12 WAIT_FOR_EVENT过程 177
20.12.1 语法 177
20.12.2 参数 178
20.12.3 使用说明 178
20.12.4 范例 178
第21章 DBMS_UTILITY 179
21.1 NAME_RESOLVE过程 179
21.1.1 语法 179
21.1.2 参数 180
21.1.3 使用说明 181
21.1.4 异常 181
21.1.5 范例 181
21.2 对象统计信息的名称解析和提取 183
21.3 源代码库 185
第七部分 应用程序开发
第22章 Perl DBI与DBD::Oracle 188
22.1 常见的Perl DBI陷阱 188
22.2 Perl与DBI简史 189
22.3 为Perl与DBI设置环境变量 189
22.3.1 UNIX环境 189
22.3.2 Windows环境 194
22.4 在UNIX系统上透明地运行Perl程序 196
22.5 在Windows系统上透明地运行Perl程序 197
22.6 连接到一个ORACLE DBMS实例 199
22.6.1 DBI连接语法 199
22.6.2 使用Bequeath适配器连接 200
22.6.3 使用IPC适配器连接 201
22.6.4 通过TCP/IP适配器连接 202
22.6.5 简易连接 203
22.6.6 使用SYSDBA或SYSOPER特权连接 203
22.6.7 使用操作系统认证连接 204
22.6.8 连接属性 205
22.7 完整Perl DBI示例程序 206
22.8 异常处理 210
22.9 源代码库 211
第23章 应用程序插桩及端到端跟踪 212
23.1 插桩简介 212
23.2 案例研究 214
23.3 程序编译 216
23.4 插桩的运行 217
23.5 TRCSESS的使用 221
23.6 插桩与程序调用栈 226
23.7 源代码库 227
第八部分 性能
第24章 扩展SQL跟踪文件格式参考 230
24.1 扩展SQL跟踪文件介绍 230
24.2 SQL和PL/SQL语句 231
24.3 递归调用深度 231
24.4 数据库调用 232
24.4.1 解析 232
24.4.2 PARSING IN CURSOR条目的格式 233
24.4.3 PARSE条目的格式 235
24.4.4 PARSE ERROR条目的格式 236
24.4.5 EXEC条目的格式 236
24.4.6 FETCH条目的格式 236
24.4.7 执行计划散列值 237
24.4.8 计划散列值案例研究 237
24.4.9 CLOSE条目的格式 240
24.5 COMMIT与ROLLBACK 241
24.6 UNMAP 242
24.7 执行计划、统计信息与STAT条目的格式 242
24.7.1 Oracle9i中STAT条目的格式 243
24.7.2 Oracle10g和Oracle11g中STAT条目的格式 243
24.8 等待事件 245
24.8.1 WAIT条目的格式 245
24.8.2 Oracle9i中的WAIT 246
24.8.3 Oracle10g和Oracle11g中的WAIT 246
24.9 绑定变量 247
24.9.1 BINDS条目的格式 247
24.9.2 语句调优、执行计划以及绑定变量 251
24.10 跟踪文件条目其他项 257
24.10.1 会话标识符 257
24.10.2 服务名称ID 258
24.10.3 应用程序插桩 259
24.10.4 ERROR条目的格式 261
24.10.5 应用程序插桩与并行执行进程 263
第25章 Statspack 265
25.1 Statspack介绍 265
25.1.1 检索捕获到的SQL语句文本 267
25.1.2 访问STATS$SQLTEXT 270
25.1.3 使用保留格式捕获SQL语句 275
25.2 未在文档中说明的Statspack报告参数 277
25.3 Statspack表 278
25.4 找出Statspack库中代价高的语句 281
25.5 识别使用过的索引 281
25.6 SQL Trace捕获语句的执行计划 282
25.7 找出高资源利用率的快照 284
25.7.1 高CPU使用 285
25.7.2 高DB时间 287
25.8 从另一数据库导入Statspack数据 290
25.9 源代码库 292
第26章 整合扩展SQL跟踪和AWR 294
26.1 检索执行计划 294
26.2 小结 296
26.3 源代码库 297
第27章 ESQLTRCPROF扩展SQL跟踪分析器 298
27.1 分类等待事件 298
27.2 计算响应时间和统计信息 299
27.2.1 案例研究 300
27.2.2 运行Perl程序 301
27.2.3 计算统计信息 303
27.2.4 计算响应时间 303
27.3 ESQLTRCPROF参考 304
27.3.1 命令行选项 305
27.3.2 ESQLTRCPROF报告部分 306
27.4 小结 314
27.5 源代码库 315
第28章 MERITS性能优化方法 316
28.1 MERITS方法简介 316
28.2 测量 317
28.3 评估 321
28.4 重现 323
28.5 改进 323
28.6 推断 324
28.7 安装 324
28.8 MERITS方法案例研究 325
28.8.1 阶段1——测量 325
28.8.2 阶段2——评估 325
28.8.3 阶段3——重现 332
28.8.4 阶段4——改进 335
28.8.5 阶段5——推断 339
28.8.6 阶段6——安装 339
28.8.7 小结 339
28.9 源代码库 340
第九部分 Oracle Net
第29章 TNS监听器IP地址绑定与IP=FIRST 342
29.1 IP地址绑定介绍 342
29.2 多宿主系统 344
29.3 IP=FIRST未启用 345
29.3.1 主机名 346
29.3.2 回环适配器 347
29.3.3 引导IP地址 348
29.3.4 服务IP地址 348
29.4 IP=FIRST开启 349
29.5 小结 350
第30章 TNS监听器TCP/IP有效结点检验 351
30.1 有效结点检验简介 351
30.2 在运行时打开和修改有效结点检验 353
第31章 本地命名参数ENABLE=BROKEN 356
第32章 Oracle Net配置中默认的主机名 359
32.1 默认主机名 359
32.2 关闭默认监听器 360
第十部分 实时应用集群
第33章 会话断开连接、负载均衡与TAF 364
33.1 透明应用故障转移介绍 364
33.2 改变系统断开会话设置 365
33.2.1 SELECT故障转移 366
33.2.2 在事务末的故障转移 369
33.3 会话中断和DBMS_SERVICE 371
33.3.1 使用DBMS_SERVICE创建服务 372
33.3.2 DBMS_SERVICE和TAF下的会话中断 374
33.4 小结 376
33.5 源代码库 376
第34章 不重装就移除RAC选项 377
34.1 连接ORACLE软件 377
34.2 案例研究 378
34.2.1 模拟表决磁盘失效 379
34.2.2 使用make工具移除RAC可选项 381
34.2.3 转换CRS环境为本地环境 383
34.2.4 重启适用于RAC的CRS环境 385
34.3 小结 386
第十一部分 实用工具
第35章 OERR 388
35.1 OERR脚本介绍 388
35.2 检索未在文档中说明的事件 390
35.3 源代码库 392
第36章 数据恢复管理器管道接口 393
36.1 数据恢复管理介绍 393
36.2 DBMS_PIPE介绍 394
36.3 RMAN_PIPE_IF包 395
36.4 RMAN_PIPE_IF包详述 395
36.5 使用RMAN_PIPE_IF包 396
36.6 验证备份块 401
36.7 跨节点并行备份与恢复 402
36.8 源码库 403
第37章 ORADEBUG SQL*Plus命令 404
37.1 ORADEBUG介绍 404
37.2 ORADEBUG使用步骤 405
37.3 ORADEBUG命令介绍 405
37.3.1 连接到一个进程 406
37.3.2 ORADEBUG IPC 408
37.3.3 ORADEBUG SHORT_STACK 409
37.3.4 诊断转储 410
37.4 小结 414
第十二部分 附录
附录A 启用和禁用DBMS可选项 416
附录B 参考书目 417
附录C 术语表 419
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>未公开的Oracle数据库秘密
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 10g性能调整与优化
第1章  Oracle Database 10g新功能介绍(针对DBA和开发人员)　1.1 安装改进　1.2 SYSAUX表空间　1.3 自动存储管理　1.4 集群就绪服务(CRS)　1.5 服务器生成的警报　1.6 自动工作量仓库(AWR)　1.7 自动数据库诊断监控程序(ADDM)　1.8 SQL调整顾问　1.9 自动共享内存管理(ASMM)　1.10 闪回恢复区　1.11 回收站　1.12 恢复管理器的改动　1.13 透明数据加密(10gR2)　1.14 LogMiner的改动　1.15 新的DBMS_STATS选项　1.16 跟踪增强　1.17 DBMS_SCHEDULER　1.18 默认的(永久)表空间　1.19 临时表空间组　1.20 重命名表空间　1.21 大文件表空间　1.22 收缩段　1.23 数据泵(Data Pump)　1.24 跨平台的可移植表空间　1.25 写入外部表　1.26 自动撤消保留调整　1.27 包括新信息的V$SESSION　1.28 OEM的改动　1.29 网格控制　1.30 10g版本中的新后台进程　1.31 版本比较表　1.32 新特性回顾　1.33 参考文档第2章  基本的索引原理(针对DBA和初级开发人员)第3章  磁盘实现方法和ASM(针对DBA)第4章  用初始参数调整数据库(针对DBA)第5章  企业管理器和网格控制(针对DBA和开发人员)第6章  使用EXPLAIN和STORED OUTLINES(针对DBA和开发人员)第7章  基本的提示语法(针对DBA和开发人员)第8章  调整查询(针对开发人员和初级DBA)第9章  表的连接和其他高级调整技术(针对DBA和开发人员)第10章  使用PL/SQL提高性能(针对DBA和开发人员)第11章  调整RAC和使用并行特性第12章  V$视图(针对开发人员和DBA)第13章  X$表(针对高级DBA)第14章  使用STATSPACK和AWR报表调整等待和闩锁第15章  执行快速系统检查(针对DBA)第16章  使用UNIX工具监控系统(针对DBA)附录A 主要的初始化参数(针对DBA)附录B V$视图(针对DBA和开发人员)附录C X$表(针对DBA)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 10g性能调整与优化
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle E-Business Suite
《oracle e-business suite：erp dba实践指南》
前　言
第1章　oracle 电子商务套件/1
1.1　oracle 电子商务套件的功能及其特点/2
1.2　oracle 电子商务套件r12 /3
1.2.1　r12包含的主要产品/3
1.2.2　r12 的结构/4
1.3　本章小结/5
第2章　erp系统规划/6
2.1　erp系统规划概述/7
2.1.1　erp系统规划的思路和步骤/7
2.1.2　erp系统架构的设计原则/8
2.1.3　erp系统基本规划/8
2.2　资源配置估算/9
2.2.1　系统应用规模调研/9
2.2.2　硬件配置的预估/11
2.2.3　硬件资源的预估方法/12
2.3　大型erp系统架构涉及的内容/14
2.3.1　存储架构/14
2.3.2　高可用性架构/15
.2.3.3　网络架构/16
2.3.4　客户端架构/19
2.3.5　集成架构/19
2.3.6　系统安全架构/23
2.3.7　备份与恢复规划/25
2.3.8　容灾架构/26
2.3.9　系统管理与监控/27
2.4　系统环境/28
2.5　本章小结/29
第3章　oracle erp部署/31
3.1　部署前准备/32
3.1.1　基础平台准备 /32
3.1.2　实验环境/34
3.1.3　软件准备/35
3.1.4　参考文档/37
3.1.5　工具和补丁/37
3.1.6　附加bug 修复/39
3.1.7　参数修改/40
3.2　oracle电子商务套件r12的安装/42
3.2.1　安装原理/42
3.2.2　安装的主要组件/43
3.2.3　安装步骤/43
3.2.4　特殊情况处理/60
3.3　安装后的基本配置、检查和备份/62
3.3.1　配置客户端软件/62
3.3.2　检查dns客户端/63
3.3.3　首次登录oracle电子商务套件/63
3.3.4　系统全备份/64
3.4　本章小结/66
第4章　语言包安装和erp配置调整/67
4.1　中文语言包安装/68
4.2　更改系统名称/81
4.3　安装在线帮助/83
4.4　更改默认密码/85
4.4.1　更改操作系统用户密码/86
4.4.2　更改数据库管理员用户密码/86
4.4.3　更改应用系统erp用户密码/87
4.5　更改日志和输出文件目录/89
4.6　调整数据库/89
4.6.1　调整数据库参数/90
4.6.2　调整数据库空间/92
4.6.3　调整redo 日志/95
4.6.4　更改归档模式/96
4.7　安全设置/98
4.7.1　数据库监听安全/98
4.7.2　数据库安全/99
4.7.3　应用服务器安全/100
4.7.4　应用系统安全/100
4.7.5　桌面层安全/101
4.8　工作流通知邮件配置 /101
4.8.1　相关概念/102
4.8.2　配置dns客户端/102
4.8.3　配置sendmail /103
4.8.4　配置imap服务器 /104
4.8.5　配置oracle alert /104
4.8.6　配置workflow mail /110
4.8.7　测试工作流邮件/115
4.9　配置 forms socket模式/121
4.10　其他常用选项配置/123
4.11　应用系统的启动及关闭 /124
4.11.1　启动顺序和方法/124
4.11.2　关闭顺序和方法/125
4.12　本章小结 /127
第5章　oracle电子商务套件架构和工具/128
5.1　oracle电子商务套件架构/129
5.1.1　桌面层/129
5.1.2　应用层/130
5.1.3　数据库层/131
5.1.4　网络连接/131
5.2　应用产品技术堆栈/131
5.2.1　oracle电子商务套件技术堆栈的组件/131
5.2.2　oracle电子商务套件文件系统/133
5.3　应用补丁程序/134
5.3.1　应用补丁前的注意事项和下载补丁/135
5.3.2　autopatch/136
5.3.3　autoconfig/138
5.4　rapid clone/141
5.4.1　克隆的应用场景及参考文档/141
5.4.2　源系统准备/142
5.4.3　目标系统检查/145
5.4.4　预clone操作 /146
5.4.5　复制源系统到目标系统/146
5.4.6　clone配置/148
5.4.7　clone配置完成后检查 /150
5.4.8　高级clone/157
5.5　oam监控/158
5.5.1　oam的主要作用/158
5.5.2　oam与应用产品的集成/158
5.5.3　访问方式和客户化/159
5.5.4　应用产品控制板的功能介绍/159
5.5.5　站点地图功能介绍/164
5.5.6　oam全局参数设置/168
5.6　本章小结/171
第6章　系统管理员基础/172
6.1　体验oracle电子商务套件/173
6.1.1　体验form和html界面/173
6.1.2　常用的设置和帮助/182
6.1.3　专题介绍/187
6.2　安全机制/192
6.2.1　功能安全性/193
6.2.2　数据安全性 /193
6.2.3　访问控制层/194
6.3　增加新功能模块/195
6.4　并发管理器/205
6.4.1　“并发”的几个概念/205
6.4.2　管理并发管理器/206
6.4.3　冲突域 /207
6.4.4　日志和产出文件 /208
6.4.5　清除日志和请求结果 /208
6.4.6　提交并发请求/209
6.4.7　提交并发请求集/218
6.4.8　定义工作班次/225
6.5　配置文件选项/237
6.5.1　个人配置文件/237
6.5.2　系统配置文件/239
6.6　本章小结/245
第7章　erp 运行管理和维护/246
7.1　erp系统运行管理/247
7.2　erp系统的管理职责/247
7.2.1　数据库管理员职责/248
7.2.2　应用系统管理员职责/248
7.2.3　基础环境管理员职责/249
7.2.4　网络管理员职责/249
7.3　系统的备份和恢复/249
7.3.1　erp系统的数据分类/249
7.3.2　备份分类/251
7.3.3　备份方法/251
7.3.4　备份内容/253
7.3.5　数据恢复/255
7.4　erp系统日常维护/255
7.4.1　数据库的日常维护/255
7.4.2　应用的日常维护/256
7.4.3　操作系统的日常维护/257
7.5　监控和跟踪erp系统/260
7.5.1　登录跟踪配置文件/260
7.5.2　监控用户/261
7.5.3　查看跟踪报表/262
7.5.4　清除登录跟踪数据/273
7.6　erp健康检查/280
7.6.1　检查x-windows/280
7.6.2　调整数据库参数/281
7.6.3　禁用登录审计触发器/281
7.6.4　调整redo 日志/282
7.6.5　调整opmn.xml参数/283
7.6.6　性能脚本的使用/283
7.6.7　调整apache参数/285
7.6.8　forms server socket模式确认/285
7.6.9　启用forms dead client 检测/286
7.6.10　禁用cancel query /287
7.6.11　清除过时的管理器数据/288
7.6.12　删除过时会话记录/293
7.6.13　启用 gsm设置/294
7.6.14　设置“icx：会话超时”/297
7.6.15　统计信息模式调整/298
7.6.16　并发管理器调整/302
7.7　系统优化思路/305
7.7.1　优化客户端/305
7.7.2　优化网络/305
7.7.3　优化应用层/305
7.7.4　优化并发管理器/306
7.7.5　优化数据库层/306
7.8　有效利用技术支持/306
7.8.1　什么是csi number /307
7.8.2　什么是sr /307
7.8.3　tar级别/307
7.8.4　有效搜索/307
7.9　本章小结/308
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle E-Business Suite
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle高性能SQL引擎剖析
序
前言
第一篇　执行计划
第1章　生成和显示执行计划 / 3
1.1　生成执行计划 / 3
1.2　显示执行计划 / 4
1.2.1　通过查询语句显示计划 / 4
1.2.2　通过包DBMS_XPLAN显示计划 / 4
1.2.3　AUTOTRACE / 12
1.2.4　其他方法 / 13
第2章　解读执行计划 / 15
2.1　执行计划的基本数据 / 15
2.2　内部函数与操作 / 17
2.3　执行计划各个列的含义 / 19
2.4　执行计划各个操作的含义 / 21
2.4.1　语句类型 / 21
2.4.2　访问路径方法 / 23
2.4.3　位图操作 / 31
2.4.4　排序操作 / 33
2.4.5　关联操作 / 36
2.4.6　层次查询操作 / 42
2.4.7　视图操作 / 45
2.4.8　数据集合操作 / 45
2.4.9　分区操作 / 48
2.4.10　并行查询操作 / 51
2.4.11　聚合操作 / 57
2.4.12　分析函数操作 / 58
2.4.13　模型化操作 / 60
2.4.14　数据和对象管理操作 / 63
2.4.15　其他操作 / 65
2.5　执行计划中其他信息的含义 / 69
2.5.1　查询块和对象别名 / 69
2.5.2　计划概要数据 / 70
2.5.3　绑定变量信息 / 70
2.5.4　分布式查询语句信息 / 72
2.5.5　注释 / 72
第二篇　SQL优化技术
第3章　查询转换 / 75
3.1　启发式查询转换 / 75
3.1.1　简单视图合并 / 76
3.1.2　子查询反嵌套 / 81
3.1.3　子查询推进 / 86
3.1.4　旧关联谓词推入 / 87
3.1.5　简单过滤谓词推入 / 90
3.1.6　谓词迁移 / 91
3.1.7　“或”操作扩张 / 91
3.1.8　物化视图查询重写 / 92
3.1.9　集合操作关联转变 / 94
3.1.10　由约束生成过滤谓词 / 95
3.1.11　星形转换 / 96
3.1.12　排序消除 / 98
3.1.13　DISTINCT消除 / 99
3.1.14　表消除 / 99
3.1.15　子查询合并 / 102
3.1.16　公共子表达式消除 / 104
3.1.17　计数函数转变 / 105
3.1.18　表达式和条件评估 / 105
3.1.19　聚集子查询消除 / 111
3.1.20　DISTINCT聚集函数转换 / 111
3.1.21　选择字段裁剪 / 113
3.1.22　DISTINCT消除 / 114
3.1.23　DISTINCT推入 / 114
3.1.24　集合分组查询转换 / 115
3.1.25　集合分组查询重写 / 115
3.1.26　集合分组裁剪 / 117
3.1.27　外关联消除 / 118
3.1.28　真正完全外关联 / 119
3.1.29　左（右）外关联转换为侧视图 / 120
3.2　基于代价的查询转换 / 123
3.2.1　复杂视图合并 / 123
3.2.2　关联谓词推入 / 124
3.2.3　谓词提取 / 126
3.2.4　GROUP BY配置 / 127
3.2.5　表扩张 / 128
3.2.6　关联因式分解 / 130
3.2.7　DISTINCT配置 / 131
3.2.8　WITH子查询转换 / 132
第4章　统计数据 / 134
4.1　系统统计数据 / 134
4.1.1　系统统计数据收集 / 136
4.1.2　系统统计数据管理 / 137
4.1.3　根据系统负载状况灵活管理 / 140
4.1.4　全局参数管理 / 142
4.1.5　项管理 / 143
4.2　对象统计数据 / 146
4.2.1　表统计数据 / 150
4.2.2　索引统计数据 / 150
4.2.3　字段统计数据 / 151
4.2.4　扩展统计数据 / 152
4.2.5　对象统计数据的管理 / 153
4.2.6　“待定”统计数据的管理 / 160
4.3　对象统计数据收集过程分析 / 161
4.3.1　表统计数据收集与计算 / 161
4.3.2　字段统计数据收集与计算 / 164
4.3.3　柱状图数据收集与计算 / 170
4.3.4　索引统计数据收集与计算 / 182
第5章　执行计划的代价估算 / 186
5.1　代价模型 / 187
5.2　基本代价计算公式 / 187
5.3　选择率计算 / 190
5.3.1　单过滤条件 / 190
5.3.2　绑定变量无具体数值 / 190
5.3.3　绑定变量有数值无柱状图 / 191
5.3.4　使用柱状图 / 192
5.3.5　过滤条件的组合 / 196
5.4　多数据块读操作代价计算 / 197
5.4.1　代价模型 / 197
5.4.2　IO代价计算 / 199
5.4.3　CPU代价计算 / 202
5.4.4　执行计划中其他数据的计算 / 209
5.4.5　全表扫描代价计算演示 / 209
5.5　并行扫描操作代价计算 / 218
5.5.1　IO代价计算 / 219
5.5.2　CPU代价计算 / 221
5.6　单数据块读操作代价计算 / 222
5.6.1　IO代价计算 / 222
5.6.2　CPU代价计算 / 226
5.6.3　单数据块读操作代价计算演示 / 228
5.7　排序操作代价计算 / 233
5.7.1　是否需要写入磁盘 / 233
5.7.2　IO代价计算 / 234
5.7.3　CPU代价计算 / 236
5.7.4　临时磁盘空间计算 / 236
5.7.5　排序代价计算演示 / 237
5.8　关联操作代价计算 / 241
5.8.1　关联选择率 / 242
5.8.2　嵌套循环关联代价计算 / 242
5.8.3　排序合并关联代价计算 / 249
5.8.4　哈希关联代价计算 / 252
5.9　并行模式下的关联代价计算 / 260
5.9.1　IO代价计算 / 262
5.9.2　CPU代价计算 / 263
5.9.3　代价计算演示 / 263
第三篇　SQL调优技术
第6章　SQL语句运行性能分析 / 270
6.1　性能统计数据 / 270
6.1.1　逻辑读 / 272
6.1.2　一致性获取 / 273
6.1.3　一致性直接获取 / 273
6.1.4　由缓存一致性获取 / 273
6.1.5　一致性修改 / 274
6.1.6　数据块修改 / 275
6.1.7　物理读入缓存 / 276
6.1.8　物理预提取读入缓存 / 276
6.1.9　排序数据行 / 277
6.1.10　递归调用 / 278
6.2　逻辑读分析 / 280
6.2.1　一致性读分析 / 280
6.2.2　当前模式读分析 / 309
6.3　物理读分析 / 319
6.3.1　物理直接读 / 319
6.3.2　物理读入缓存与LRU算法 / 378
第7章　Oracle调优技术 / 387
7.1　存储概要 / 387
7.1.1　什么是存储概要 / 388
7.1.2　创建存储概要 / 389
7.1.3　管理存储概要 / 391
7.1.4　使用存储概要 / 392
7.2　SQL执行计划管理 / 394
7.2.1　创建和增加执行计划基线 / 395
7.2.2　进化历史执行计划 / 405
7.2.3　优化器从基线中选择执行计划 / 407
7.3　Oracle自动调优 / 409
7.3.1　创建调优任务 / 410
7.3.2　SQL调优建议器的参数 / 410
7.3.3　自动调优分析 / 412
7.4　SQL性能分析器 / 423
7.4.1　性能分析过程 / 424
7.4.2　SQL性能分析示例 / 426
7.5　SQL访问建议器 / 428
7.5.1　建议器选择新索引分析过程 / 428
7.5.2　使用SQL访问建议器 / 433
第8章　快速调优思路 / 441
8.1　统计数据检查 / 441
8.2　从执行计划中找到潜在问题 / 444
8.2.1　是否存在多个游标 / 444
8.2.2　输出结果中特别注释 / 447
8.2.3　存在潜在性能问题的操作 / 448
8.2.4　谓词信息 / 452
8.2.5　概要数据以及优化器环境检查 / 455
8.3　物理设计优化 / 456
8.3.1　索引 / 456
8.3.2　分区 / 457
8.3.3　物化视图 / 458
8.3.4　约束 / 458
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle高性能SQL引擎剖析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 11g SQL开发指南
第1章 简介	1
1.1 关系数据库简介	2
1.2 结构化查询语言(SQL)简介	2
1.3 使用SQL*Plus	4
1.3.1 启动SQL*Plus	4
1.3.2 从命令行启动SQL*Plus	5
1.3.3 使用SQL*Plus执行SELECT语句	6
1.4 SQL Developer	7
1.5 创建store模式	9
1.5.1 运行SQL*Plus脚本创建store模式	9
1.5.2 用来创建store模式的DDL语句	10
1.6 添加、修改、删除行	18
1.6.1 向表中添加行	18
1.6.2 修改表中的现有行	19
1.6.3 从表中删除行	20
1.7 BINARY_FLOAT和BINARY_ DOUBLE数据类型	21
1.7.1 BINARY_FLOAT和BINARY_DOUBLE的优点	21
1.7.2 在表中使用BINARY_FLOAT和BINARY_DOUBLE	21
1.7.3 特殊值	22
1.8 退出SQL*Plus	23
1.9 Oracle PL/SQL简介	23
1.10 小结	24
第2章 从数据库表中检索信息	25
2.1 对单表执行SELECT语句	25
2.2 选择一个表中的所有列	26
2.3 使用WHERE子句过滤行	27
2.4 理解行标识符	27
2.5 理解行号	28
2.6 执行算术运算	28
2.6.1 日期运算	29
2.6.2 列运算	30
2.7 使用列别名	31
2.8 使用连接操作合并列的输出结果	32
2.9 理解空值	33
2.10 禁止显示重复行	34
2.11 比较值	35
2.12 使用SQL操作符	37
2.12.1 使用LIKE操作符	37
2.12.2 使用IN操作符	38
2.12.3 使用BETWEEN操作符	39
2.13 使用逻辑操作符	40
2.14 理解操作符的优先级	41
2.15 使用ORDER BY子句对行进行排序	41
2.16 执行使用两个表的SELECT语句	42
2.17 使用表别名	44
2.18 笛卡尔积	45
2.19 执行使用多于两个表的SELECT语句	46
2.20 连接条件和连接类型	47
2.20.1 不等连接	47
2.20.2 外连接	48
2.20.3 自连接	51
2.21 使用SQL/92语法执行连接	52
2.21.1 使用SQL/92标准语法执行两个表的内连接	53
2.21.2 使用USING关键字简化连接	53
2.21.3 使用SQL/92执行多于两个表的内连接	54
2.21.4 使用SQL/92执行多列的内连接	55
2.21.5 使用SQL/92执行外连接	55
2.21.6 使用SQL/92执行自连接	56
2.21.7 使用SQL/92执行交叉
连接	57
2.22 小结	57
第3章 使用SQL*Plus	59
3.1 查看表结构	60
3.2 编辑SQL语句	60
3.3 保存、检索并运行文件	62
3.4 格式化列	65
3.5 设置页面大小	67
3.6 设置行大小	68
3.7 清除列格式	68
3.8 使用变量	69
3.8.1 临时变量	69
3.8.2 已定义变量	72
3.9 创建简单报表	74
3.9.1 在脚本中使用临时变量	74
3.9.2 在脚本中使用已定义变量	75
3.9.3 向脚本中的变量传递值	75
3.9.4 添加页眉和页脚	76
3.9.5 计算小计	78
3.10 从SQL*Plus获取帮助信息	79
3.11 自动生成SQL语句	80
3.12 断开数据库连接并退出SQL*Plus	81
3.13 小结	81
第4章 使用简单函数	83
4.1 使用单行函数	84
4.1.1 字符函数	84
4.1.2 数字函数	92
4.1.3 转换函数	96
4.1.4 正则表达式函数	102
4.2 使用聚合函数	108
4.2.1 AVG函数	109
4.2.2 COUNT函数	110
4.2.3 MAX和MIN函数	110
4.2.4 STDDEV函数	111
4.2.5 SUM函数	111
4.2.6 VARIANCE函数	112
4.3 对行进行分组	112
4.3.1 使用GROUP BY子句对行进行分组	112
4.3.2 调用聚合函数的错误用法	115
4.3.3 使用HAVING子句过滤行组	116
4.3.4 组合使用WHERE和GROUP BY子句	117
4.3.5 组合使用WHERE、GROUP
BY和HAVING子句	117
4.4 小结	118
第5章 日期和时间的存储与处理	119
5.1 几个简单的存储和检索日期的例子	120
5.2 使用TO_CHAR()和
TO_DATE()转换时间值	121
5.2.1 使用TO_CHAR()将时间值转换为字符串	121
5.2.2 使用TO_DATE()将字符串转换为时间值	125
5.3 设置默认的日期格式	128
5.4 Oracle对2位年份的处理	129
5.4.1 使用YY格式	129
5.4.2 使用RR格式	130
5.5 使用时间值函数	131
5.5.1 ADD_MONTHS函数	131
5.5.2 LAST_DAY函数	132
5.5.3 MONTHS_BETWEEN函数	133
5.5.4 NEXT_DAY函数	133
5.5.5 ROUND函数	133
5.5.6 SYSDATE	134
5.5.7 TRUNC函数	134
5.6 理解时区	135
5.6.1 与时区有关的函数	136
5.6.2 数据库时区和会话时区	136
5.6.3 获取时区的时差	137
5.6.4 获取时区名	138
5.6.5 将时间值从一个时区转换为另一个时区	138
5.7 使用时间戳	139
5.7.1 使用时间戳类型	139
5.7.2 与时间戳有关的函数	143
5.8 使用时间间隔	148
5.8.1 使用INTERVAL YEAR TO MONTH类型	149
5.8.2 使用INTERVAL DAY TO
SECOND类型	150
5.8.3 与时间间隔有关的函数	152
5.9 小结	153
第6章 子查询	155
6.1 子查询的类型	155
6.2 编写单行子查询	156
6.2.1 在WHERE子句中使用子查询	156
6.2.2 使用其他单行操作符	157
6.2.3 在HAVING子句中使用子查询	157
6.2.4 在FROM子句中使用子查询(内联视图)	159
6.2.5 可能碰到的错误	159
6.3 编写多行子查询	160
6.3.1 在多行子查询中使用IN操作符	161
6.3.2 在多行子查询中使用ANY操作符	162
6.3.3 在多行子查询中使用ALL操作符	162
6.4 编写多列子查询	162
6.5 编写关联子查询	163
6.5.1 关联子查询的例子	163
6.5.2 在关联子查询中使用EXISTS和NOT EXISTS	164
6.6 编写嵌套子查询	166
6.7 编写包含子查询的UPDATE和DELETE语句	168
6.7.1 编写包含子查询的UPDATE语句	168
6.7.2 编写包含子查询的DELETE语句	168
6.8 小结	169
第7章 高级查询	171
7.1 使用集合操作符	172
7.1.1 示例表	172
7.1.2 使用UNION ALL操作符	173
7.1.3 使用UNION操作符	174
7.1.4 使用INTERSECT操作符	175
7.1.5 使用MINUS操作符	175
7.1.6 组合使用集合操作符	176
7.2 使用TRANSLATE函数	178
7.3 使用DECODE()函数	179
7.4 使用CASE表达式	181
7.4.1 使用简单CASE表达式	181
7.4.2 使用搜索CASE表达式	182
7.5 层次化查询	183
7.5.1 示例数据	183
7.5.2 使用CONNECT BY和
START WITH子句	185
7.5.3 使用伪列LEVEL	185
7.5.4 格式化层次化查询的结果	186
7.5.5 从非根节点开始遍历	187
7.5.6 在START WITH子句中使用子查询	187
7.5.7 从下向上遍历树	188
7.5.8 从层次查询中删除节点和分支	188
7.5.9 在层次化查询中加入其他条件	189
7.6 使用扩展的GROUP BY子句	190
7.7 使用ROLLUP子句	192
7.7.1 使用CUBE子句	194
7.7.2 使用GROUPING函数	195
7.7.3 使用GROUPING SETS子句	198
7.7.4 使用GROUPING_ID函数	199
7.7.5 在GROUP BY子句中多次使用一个列	201
7.7.6 使用GROUP_ID函数	201
7.8 使用分析函数	203
7.8.1 示例表	203
7.8.2 使用评级函数	204
7.8.3 使用反百分点函数	211
7.8.4 使用窗口函数	211
7.8.5 使用报表函数	216
7.8.6 使用LAG和LEAD函数	218
7.8.7 使用FIRST和LAST函数	219
7.8.8 使用线性回归函数	219
7.8.9 使用假想评级与分布函数	221
7.9 使用MODEL子句	221
7.9.1 MODEL子句示例	222
7.9.2 用位置标记和符号标记访问数据单元	223
7.9.3 用BETWEEN和AND返回特定范围内的数据单元	224
7.9.4 用ANY和IS ANY访问所有的数据单元	224
7.9.5 用CURRENTV()获取某个维度的当前值	225
7.9.6 用FOR循环访问数据单元	226
7.9.7 处理空值和缺失值	227
7.9.8 更新已有的单元	229
7.10 使用PIVOT和UNPIVOT子句	230
7.10.1 PIVOT子句示例	230
7.10.2 转换多个列	231
7.10.3 在转换中使用多个聚合函数	232
7.10.4 使用UNPIVOT子句	233
7.11 小结	234
第8章 修改表的内容	237
8.1 使用INSERT语句添加行	237
8.1.1 省略列的列表	239
8.1.2 为列指定空值	239
8.1.3 在列值中使用单引号和双引号	239
8.1.4 从一个表向另外一个表复制行	239
8.2 使用UPDATE语句修改行	240
8.3 RETURNING子句	241
8.4 使用DELETE语句删除行	242
8.5 数据库的完整性	242
8.5.1 主键约束	242
8.5.2 外键约束	243
8.6 使用默认值	244
8.7 使用MERGE合并行	245
8.8 数据库事务	247
8.8.1 事务的提交和回滚	247
8.8.2 事务的开始与结束	248
8.8.3 保存点	249
8.8.4 事务的ACID特性	251
8.8.5 并发事务	251
8.8.6 事务锁	252
8.8.7 事务隔离级别	253
8.8.8 SERIALIZABLE事务的一个例子	254
8.9 查询闪回	254
8.9.1 使用闪回的授权	254
8.9.2 时间查询闪回	255
8.9.3 系统变更号查询闪回	256
8.10 小结	258
第9章 用户、特权和角色	259
9.1 用户	260
9.1.1 创建用户	260
9.1.2 修改用户密码	261
9.1.3 删除用户	261
9.2 系统特权	262
9.2.1 向用户授予系统特权	263
9.2.2 检查授予用户的系统特权	263
9.2.3 使用系统特权	264
9.2.4 撤消用户的系统特权	264
9.3 对象特权	265
9.3.1 向用户授予对象特权	265
9.3.2 检查已授予的对象特权	266
9.3.3 检查已接受的对象特权	267
9.3.4 使用对象特权	269
9.3.5 同名对象	269
9.3.6 公共同名对象	270
9.3.7 撤消用户的对象特权	271
9.4 角色	271
9.4.1 创建角色	271
9.4.2 为角色授权	272
9.4.3 将角色授予用户	272
9.4.4 检查授予用户的角色	273
9.4.5 检查授予角色的系统特权	274
9.4.6 检查授予角色的对象特权	274
9.4.7 使用授予角色的特权	276
9.4.8 默认角色	276
9.4.9 撤消角色	277
9.4.10 从角色中撤消特权	277
9.4.11 删除角色	277
9.5 审计	277
9.5.1 执行审计需要的特权	277
9.5.2 审计示例	278
9.5.3 审计跟踪视图	279
9.6 小结	280
第10章 创建表、序列、索引和视图	281
10.1 表	282
10.1.1 创建表	282
10.1.2 获得有关表的信息	283
10.1.3 获得表中列的信息	284
10.1.4 修改表	285
10.1.5 重命名表	294
10.1.6 向表中添加注释	294
10.1.7 截断表	295
10.1.8 删除表	295
10.2 序列	295
10.2.1 创建序列	295
10.2.2 获取有关序列的信息	297
10.2.3 使用序列	298
10.2.4 使用序列填充主键	299
10.2.5 修改序列	300
10.2.6 删除序列	301
10.3 索引	301
10.3.1 创建B-树索引	302
10.3.2 创建基于函数的索引	303
10.3.3 获取有关索引的信息	303
10.3.4 获取列索引的信息	304
10.3.5 修改索引	304
10.3.6 删除索引	305
10.3.7 创建位图索引	305
10.4 视图	305
10.4.1 创建并使用视图	306
10.4.2 修改视图	313
10.4.3 删除视图	314
10.5 闪回数据归档	314
10.6 小结	316
第11章 PL/SQL编程简介	317
11.1 块结构	318
11.2 变量和类型	319
11.3 条件逻辑	320
11.4 循环	320
11.4.1 简单循环	321
11.4.2 WHILE循环	322
11.4.3 FOR循环	322
11.5 游标	323
11.5.1 步骤1：声明用于保存列值的变量	323
11.5.2 步骤2：声明游标	323
11.5.3 步骤3：打开游标	324
11.5.4 步骤4：从游标中取得记录	324
11.5.5 步骤5：关闭游标	325
11.5.6 完整的示例：product_cursor.sql	325
11.5.7 游标与FOR循环	326
11.5.8 OPEN-FOR语句	327
11.5.9 无约束游标	329
11.6 异常	330
11.6.1 ZERO_DIVIDE异常	332
11.6.2 DUP_VAL_ON_INDEX异常	333
11.6.3 INVALID_NUMBER异常	333
11.6.4 OTHERS异常	333
11.7 过程	334
11.7.1 创建过程	334
11.7.2 调用过程	337
11.7.3 获取有关过程的信息	338
11.7.4 删除过程	338
11.7.5 查看过程中的错误	338
11.8 函数	339
11.8.1 创建函数	339
11.8.2 调用函数	340
11.8.3 获取有关函数的信息	341
11.8.4 删除函数	341
11.9 包	341
11.9.1 创建包规范	342
11.9.2 创建包体	342
11.9.3 调用包中的函数和过程	344
11.9.4 获取有关包中函数和过程的信息	344
11.9.5 删除包	345
11.10 触发器	345
11.10.1 触发器运行的时机	345
11.10.2 设置示例触发器	345
11.10.3 创建触发器	346
11.10.4 激活触发器	347
11.10.5 获取有关触发器的信息	348
11.10.6 禁用和启用触发器	350
11.10.7 删除触发器	350
11.11 Oracle Database 11g新增加的PL/SQL特性	350
11.11.1 SIMPLE_INTEGER类型	350
11.11.2 在PL/SQL中使用序列	351
11.11.3 PL/SQL本地机器代码生成	352
11.12 小结	353
第12章 数据库对象	355
12.1 对象简介	356
12.2 创建对象类型	356
12.3 使用DESCRIBE获取有关对象类型的信息	358
12.4 在数据库表中使用对象类型	359
12.4.1 列对象	359
12.4.2 对象表	361
12.4.3 对象标识符和对象引用	365
12.4.4 比较对象值	367
12.5 在PL/SQL中使用对象	369
12.5.1 get_products()函数	370
12.5.2 display_product()过程	371
12.5.3 insert_product()过程	372
12.5.4 update_product_price()过程	373
12.5.5 get_product()函数	373
12.5.6 update_product()过程	374
12.5.7 get_product_ref()函数	375
12.5.8 delete_product()过程	375
12.5.9 product_lifecycle()过程	376
12.5.10 product_lifecycle2()过程	377
12.6 类型继承	378
12.7 用子类型对象代替超类型对象	380
12.7.1 SQL例子	380
12.7.2 PL/SQL例子	381
12.7.3 NOT SUBSTITUTABLE对象	382
12.8 其他有用的对象函数	383
12.8.1 IS OF()	383
12.8.2 TREAT()	387
12.8.3 SYS_TYPEID()	391
12.9 NOT INSTANTIABLE对象类型	391
12.10 用户自定义的构造函数	393
12.11 重载方法	396
12.12 通用调用	398
12.13 小结	400
第13章 集合	401
13.1 集合简介	401
13.2 创建集合类型	402
13.2.1 创建变长数组类型	402
13.2.2 创建嵌套表类型	403
13.3 使用集合类型定义表列	403
13.3.1 使用变长数组类型定义表列	403
13.3.2 使用嵌套表类型定义表列	404
13.4 获取集合信息	404
13.4.1 获取变长数组信息	404
13.4.2 获得嵌套表信息	405
13.5 填充集合元素	407
13.5.1 填充变长数组元素	407
13.5.2 填充嵌套表元素	407
13.6 检索集合元素	408
13.6.1 检索变长数组元素	408
13.6.2 检索嵌套表元素	409
13.7 使用TABLE()将集合视为一系列行	409
13.7.1 将TABLE()用于变长数组	410
13.7.2 将TABLE()用于嵌套表	411
13.8 更改集合元素	411
13.8.1 更改变长数组元素	411
13.8.2 更改嵌套表元素	412
13.9 使用映射方法比较嵌套表的内容	413
13.10 使用CAST()将集合从一种类型转换为另一种类型	415
13.10.1 使用CAST()将变长数组转换为嵌套表	416
13.10.2 使用CAST()将嵌套表转换为变长数组	416
13.11 在PL/SQL中使用集合	417
13.11.1 操作变长数组	417
13.11.2 操作嵌套表	419
13.11.3 PL/SQL集合方法	421
13.12 多级集合类型	431
13.13 Oracle Database 10g对集合的增强	433
13.13.1 关联数组	434
13.13.2 更改元素类型的大小	435
13.13.3 增加变长数组的元素数目	435
13.13.4 在临时表中使用变长数组	435
13.13.5 为嵌套表的存储表使用不同的表空间	435
13.13.6 嵌套表对ANSI的支持	436
13.14 小结	444
第14章 大对象	447
14.1 大对象(LOB)简介	448
14.2 示例文件	448
14.3 理解大对象类型	449
14.4 创建包含大对象的表	449
14.5 在SQL中使用大对象	450
14.5.1 使用CLOB和BLOB	450
14.5.2 使用BFILE	452
14.6 在PL/SQL中使用大对象	454
14.6.1 APPEND()	456
14.6.2 CLOSE()	457
14.6.3 COMPARE()	457
14.6.4 COPY()	458
14.6.5 CREATETEMPORARY()	459
14.6.6 ERASE()	460
14.6.7 FILECLOSE()	460
14.6.8 FILECLOSEALL()	461
14.6.9 FILEEXISTS()	461
14.6.10 FILEGETNAME()	462
14.6.11 FILEISOPEN()	462
14.6.12 FILEOPEN()	463
14.6.13 FREETEMPORARY()	463
14.6.14 GETCHUNKSIZE()	464
14.6.15 GET_STORAGE_LIMIT()	464
14.6.16 GETLENGTH()	464
14.6.17 INSTR()	465
14.6.18 ISOPEN()	466
14.6.19 ISTEMPORARY()	467
14.6.20 LOADFROMFILE()	467
14.6.21 LOADBLOBFROMFILE()	468
14.6.22 LOADCLOBFROMFILE()	469
14.6.23 OPEN()	470
14.6.24 READ()	471
14.6.25 SUBSTR()	471
14.6.26 TRIM()	473
14.6.27 WRITE()	473
14.6.28 WRITEAPPEND()	474
14.6.29 PL/SQL示例过程	475
14.7 理解LONG和LONG RAW类型	492
14.7.1 示例表	492
14.7.2 向LONG和LONG RAW列添加数据	492
14.7.3 将LONG和LONG RAW列转换为LOB	493
14.8 Oracle Database 10g对大对象的增强	494
14.8.1 CLOB和NCLOB对象之间的隐式转换	494
14.8.2 在触发器中使用LOB时：new属性的用法	495
14.9 Oracle Database 11g对大对象的增强	495
14.9.1 加密LOB数据	496
14.9.2 压缩LOB数据	499
14.9.3 删除LOB重复数据	499
14.10 小结	500
第15章 在Java程序中运行SQL	501
15.1 准备工作	502
15.2 配置计算机	502
15.2.1 设置ORACLE_HOME环境变量	502
15.2.2 设置JAVA_HOME环境变量	503
15.2.3 设置PATH环境变量	503
15.2.4 设置CLASSPATH环境变量	504
15.2.5 设置LD_LIBRARY_PATH环境变量	504
15.3 Oracle JDBC驱动程序	505
15.3.1 Thin驱动程序	505
15.3.2 OCI驱动程序	505
15.3.3 服务器端内部驱动程序	505
15.3.4 服务器端Thin驱动程序	505
15.4 导入JDBC包	506
15.5 注册Oracle JDBC驱动程序	506
15.6 打开数据库连接	506
15.6.1 使用getConnection()方法连接数据库	507
15.6.2 数据库URL	507
15.6.3 使用Oracle数据源连接数据库	508
15.7 创建JDBC Statement对象	511
15.8 从数据库中检索行	511
15.8.1 步骤1：创建和填充ResultSet对象	511
15.8.2 步骤2：从ResultSet对象中读取列值	512
15.8.3 步骤3：关闭ResultSet对象	514
15.9 向数据库中添加行	514
15.10 更改数据库的行	515
15.11 删除数据库的行	516
15.12 处理数字	516
15.13 处理数据库Null值	517
15.14 控制数据库事务	519
15.15 执行DDL语句	519
15.16 处理异常	520
15.17 关闭JDBC对象	521
15.18 示例程序：BasicExample1.java	522
15.18.1 编译BasicExample1	527
15.18.2 运行BasicExample1	527
15.19 预备SQL语句	529
15.20 示例程序：BasicExample2.java	531
15.21 Oracle JDBC扩展	534
15.21.1 oracle.sql包	534
15.21.2 oracle.jdbc包	537
15.21.3 示例程序：
BasicExample3.java	540
15.22 小结	543
第16章 SQL优化	545
16.1 SQL优化简介	545
16.2 使用WHERE子句过滤行	546
16.3 使用表连接而不是多个查询	546
16.4 执行连接时使用完全限定的列引用	547
16.5 使用CASE表达式而不是多个查询	548
16.6 添加表索引	549
16.7 使用WHERE而不是HAVING	550
16.8 使用UNION ALL而不是UNION	550
16.9 使用EXISTS而不是IN	552
16.10 使用EXISTS而不是DISTINCT	552
16.11 使用GROUPING SETS而不是CUBE	553
16.12 使用绑定变量	553
16.12.1 不相同的SQL语句	554
16.12.2 使用绑定变量定义相同SQL语句	554
16.12.3 列出和输出绑定变量	555
16.12.4 使用绑定变量存储PL/SQL函数的返回值	555
16.12.5 使用绑定变量存储REFCURSOR的行	556
16.13 比较执行查询的成本	556
16.13.1 检查执行计划	557
16.13.2 比较执行计划	562
16.14 为优化器传递提示	563
16.15 其他优化工具	564
16.15.1 Oracle Enterprise Manager
Diagnostics Pack	565
16.15.2 Automatic Database
Diagnostic Monitor	565
16.16 小结	566
第17章 XML和Oracle数据库	567
17.1 XML简介	567
17.2 从关系数据生成XML	568
17.2.1 XMLELEMENT()	568
17.2.2 XMLATTRIBUTES()	571
17.2.3 XMLFOREST()	571
17.2.4 XMLAGG()	573
17.2.5 XMLCOLATTVAL()	575
17.2.6 XMLCONCAT()	576
17.2.7 XMLPARSE()	576
17.2.8 XMLPI()	577
17.2.9 XMLCOMMENT()	577
17.2.10 XMLSEQUENCE()	578
17.2.11 XMLSERIALIZE()	579
17.2.12 PL/SQL范例：将XML数据写入文件	579
17.2.13 XMLQUERY()	581
17.3 将XML保存到数据库中	585
17.3.1 范例XML文件	585
17.3.2 创建范例XML模式	586
17.3.3 从范例XML模式检索信息	588
17.3.4 更新范例XML模式中的信息	592
17.4 小结	595
附录A Oracle数据类型	597
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 11g SQL开发指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Oracle 10g SQL和PL/SQL
第1章 开始使用oracle server.
1．1 安装oracle database 10g
1．2 数据库配置助手
1．3 net manager
1．3．1 配置监听程序
1．3．2 配置网络服务名
1．4 sql*plus
1．4．1 以命令行运行sql*plus
1．4．2 在windows环境中运行sql*plus
1．5 isql*plus
1．6 pl／sql developer
1．6．1 command window
1．6．2 program window
1．6．3 test window
1．7 小结
1．8 习题
第2章 sql和pl／sql综述
2．1 关系数据库
2．1．1 概念模型
2．1．2 数据模型
.2．2 sql综述
2．2．1 sql语言特点
2．2．2 sql语言分类
2．2．3 sql语句编写规则
2．3 pl／sql简介
2．4 oracle数据库对象
2．4．1 表(table)
2．4．2 索引(index)
2．4．3 约束(constraint)
2．4．4 视图(view)
2．4．5 序列(sequence)
2．4．6 同义词(synonym)
2．4．7 过程(procedure)
2．4．8 函数(function)
2．4．9 包(package)
2．4．10 触发器(trigger)
2．4．11 对象类型(object type)
2．5 小结
第3章 基本查询语句
3．1 查询所有列
3．2 查询特定列
3．3 查询日期列
3．4 排除重复行
3．5 使用算术运算符
3．6 处理null
3．7 连接字符串
3．8 使用列别名
3．9 小结
3．10 习题
第4章 限制数据
4．1 在where子句中使用常规比较符
4．2 在where子句中使用其他比较符
4．3 在where子句中使用逻辑操作符
4．4 小结
4．5 习题
第5章 排序数据
5．1 单列排序
5．2 多列排序
5．3 小结
5．4 习题
第6章 sql单行函数
6．1 数字函数
6．1．1 数字函数使用示例
6．1．2 数字函数清单
6．2 字符函数
6．2．1 字符函数使用示例
6．2．2 字符函数清单
6．3 日期时间函数
6．3．1 日期时间函数使用示例
6．3．2 日期时间函数清单
6．4 转换函数
6．4．1 转换函数使用示例
6．4．2 转换函数清单
6．5 正则表达式函数
6．6 对象函数
6．7 集合函数
6．8 其他函数
6．9 小结
6．10 习题
第7章 操纵数据
7．1 增加数据
7．1．1 增加单行数据
7．1．2 使用子查询复制数据
7．1．3 在into子句中使用于查询
7．1．4 使用多表插入
7．2 更新数据
7．2．1 使用表达式更新数据
7．2．2 使用子查询更新数据
7．2．3 使用merge语句
7．3 删除数据
7．4 控制事务
7．4．1 事务和锁
7．4．2 提交事务
7．4．3 回退事务
7．4．4 只读事务
7．4．5 顺序事务
7．5 小结
7．6 题
第8章 连接查询
8．1 相等连接
8．2 不等连接
8．3 自连接
8．4 外连接
8．5 sql：1999连接
8．6 小结
8．7 习题
第9章 数据分组
9．1 常用分组函数
9．2 使用group by和having子句
9．3 使用rollup和cube操作符
9．4 使用grouping sets操作符
9．5 连接分组
9．6 小结
9．7 习题
第10章 子查询
10．1 单行和多行子查询
10．1．1 单行子查询
10．1．2 多行子查询
10．2 多列子查询
10．3 相关于查询
10．4 在其他sql语句中引用子查询
10．4．1 在ddl语句中使用子查询
10．4．2 在from子句中使用子查询
10．4．3 标量子查询表达式
10．4．4 使用with子句重用于查询
10．5 小结
10．6 习题
第11章 其他复杂查询
11．1 使用集合操作符
11．2 层次查询
11．3 使用条件表达式
11．3．1 使用decode函数
11．3．2 使用case表达式
11．4 flashback查询
11．5 小结
11．6 题
第12章 建立和管理表
12．1 表简介
12．1．1 设计表
12．1．2 行格式
12．1．3 常用数据类型
12．1．4 伪列rowid和rownum
12．2 建表
12．3 修改表
12．4 截断和删除表
12．4．1 截断表
12．4．2 删除表
12．4．3 恢复被删除表
12．5 显示表信息
12．6 小结
12．7 习题
第13章 使用约束
13．1 约束简介
13．2 定义约束
13．3 维护约束
13．3．1 增加约束
13．3．2 修改约束名
13．3．3 删除约束
13．3．4 禁止约束
13．3．5 激活约束
13．4 显示约束信息
13．5 小结
13．6 习题
第14章 使用视图
14．1 视图简介
14．1．1 视图的作用
14．1．2 视图分类
14．1．3 在视图上执行dml操作的原则
14．2 建立视图
14．2．1 建立简单视图
14．2．2 建立复杂视图
14．2．3 建立连接视图
14．2．4 建立只读视图
14．2．5 在建立视图时定义check约束
14．2．6 在建立视图时定义列别名
14．3 维护视图
14．3．1 修改视图定义
14．3．2 重新编译视图
14．3．3 删除视图
14．4 显示视图信息
14．5小结
14．6 习题
第15章 使用其他对象
15．1 使用索引
15．1．1 索引的分类
15．1．2 使用索引的指导方针
15．1．3 建立索引
15．1．4 维护索引
15．1．5 显示索引信息
15．2 使用序列
15．2．1 建立序列
15．2．2 维护序列
15．2．3 显示序列信息
15．3 使用同义词
15．3．1 建立同义词
15．3．2 删除同义词
15．3．3 显示同义词信息
15．4 小结
15．5 习题
第三部分 pl/sql
第16章 pl／sql基础
16．1 pl／sql块简介
16．1．1 pl／sql块结构
16．1．2 pl／sql块分类
16．2 定义并使用变量
16．2．1 标量(scalar)变量
16．2．2复合(composite)变量
16．2．3 参照(reference)变量
16．2．4 lob(large object)变量
16．2．5 使用子类型定义变量
16．2．6 非pl／sql变量
16．3 编写pl／sql代码
16．3．1 pl／sql词汇单元
16．3．2 pl／sql代码编写规则
16．4 小结
16．5 习题
第17章 访问oracle
17．1 检索单行数据
17．1．1 使用标量变量接收数据
17．1．2 使用记录变量接收数据
17．1．3 嵌入select语句注意事项..
17．2 操纵数据
17．2．1 插入数据
17．2．2 更新数据
17．2．3 删除数据
17．2．4 sql游标
7．3 使用事务控制语句
7．4 小结
17．5 习题
第18章 编写控制结构
18．1 条件分支语句
18．1．1 简单条件判断
18．1．2 二重条件分支
18．1．3 多重条件分支
18．2 case语句
18．3 循环语句
18．3．1 基本循环
18．3．2 while循环
18．3．3 for循环
18．3．4 嵌套循环和标号
18．4 顺序控制语句
18．5 小结
18．6 习题
第19章 使用复合数据类型
19．1 pl／sql记录
19．1．1 定义pl／sql记录
19．1．2 使用pl／sql记录
19．2 pl／sql集合
19．2．1 pl／sql表
19．2．2 嵌套表
19．2．3 变长数组(varray)
19．2．4 pl／sql记录表
19．3 pl／sql集合方法
19．4 批量绑定
19．4．1 传统循环和批量绑定
19．4．2 使用bulk collect子句
19．4．3 使用forall语句
19．4．4 使用indices of和values of子句
19．5 pl／sql集合高级特性
19．5．1 集合赋值
19．5．2 集合比较
19．5．3 集合嵌套
19．6 小结
19．7 习题
第20章 使用游标
20．1 显式游标
20．1．1 显式游标属性
20．1．2 使用显式游标
20．1．3 游标for循环
20．1．4 参数游标
20．1．5 更新或删除游标行
20．2 游标变量
20．3 使用批量提取
20．4 使用cursor表达式
20．5 小结
20．6 习题
第21章 异常处理
21．1 异常简介
21．2 捕捉并处理异常
21．2．1 预定义异常
21．2．2 非预定义异常
21．2．3 自定义异常
21．3 使用异常处理函数
21．4 使用编译警告
21．5 小结
21．6 习题
第22章 本地动态sql
22．1 动态sql简介
22．2 使用execute immediate语句
22．2．1 处理ddl和dcl语句
22．2．2 处理dml语句
22．2．3 处理单行查询
22．3 处理多行查询
22．4 在动态sql中使用批量绑定
22．5 小结
22．6 习题
第23章 pl/sql过程
23．1 使用过程参数
23．2 调用过程
23．3 过程开发示例
23．3．1 为过程参数指定默认值
23．3．2 使用异常处理
23．3．3 自定义错误消息
23．3．4 使用记录变量作为输入参数
23．3．5 使用记录变量作为输出参数
23．3．6 使用集合变量作为输入参数
23．3．7 使用集合变量作为输出参数
23．4 维护过程
23．5 小结
23．6 习题
第24章 pl／sql函数
24．1 使用函数参数
24．2 调用函数
24．3 函数开发示例
24．3．1 使用异常处理
24．3．2 使用记录类型作为返回类型
24．3．3 使用集合类型作为返回类型
24．4 管理函数
24．5 小结
24．6 习题
第25章 pl/sql包
25．1 包组件
25．1．1 建立包规范
25．1．2 建立包体
25．2 调用包组件
25．3 包开发示例
25．3．1 使用记录类型
25．3．2 使用集合类型
25．3．3 使用重载
25．3．4 使用构造过程
25．3．5 使用纯度级别
25．4 维护包
25．5 小结
25．6 习题
第26章 触发器
26．1 dml触发器
26．1．1 语句触发器
26．1．2 行触发器
26．1．3 dml触发器开发示例
26．2 instead of触发器
26．3 事件触发器
26．3．1 事件属性函数
26．3．2 系统事件触发器
26．3．3 客户事件触发器
26．4 维护触发器
26．5 小结
26．6 习题
第27章 使用对象类型
27．1 对象类型简介
27．2 建立对象类型
27．3 使用对象方法
27．4 使用对象表
27．4．1 使用行对象和列对象
27．4．2 在对象表上引用对象方法
27．5 对象类型开发示例
27．5．1 嵌套对象类型
27．5．2 对象类型继承
27．5．3 参照对象类型
27．6 维护对象类型
27．7 小结
27．8 习题
第四部分 pl/sql系统包
第28章 使用大对象
28．1 lob简介
28．2 使用clob
28．3 使用bfile
28．4 使用blob
28．5 dbms_lob包
28．6 小结
第29章 读写os文件
29．1 写入os文件
29．2 读取os文件
29．3 utl_file包
29．4 小结
第30章 dbms_sql动态sql
30．1 实现动态sql
30．2 dbms_sql
30．3 小结
第31章 管理统计
31．1 管理表统计
31．2 管理索引统计
31．3 管理直方图统计
31．4 管理方案和数据库统计
31．5 管理系统统计
31．6 dbms_stats包
31．7 小结
第32章 使用数据库资源管理器
32．1 实现资源管理
32．2 dbms_resource_manager_privs包
32．3 dbms_resource_manager包
32．4 小结
第33章 数据加密和解密
33．1 实现数据加密和解密
33．2 dbms_obfuscation_toolkit
33．3 dbms crypto
33．4 小结
第34章 开发web应用
34．1 配置数据库访问描述符
34．2 web应用开发示例
34．3 htp和htf
34．4 owa_cookie
34．5 owa_image
34．6 owa_opt_lock
34．7 owa_pattern
34．8 owa_sec
34．9 owa_text
34．10 owa util
34．11 小结
第35章 使用调度程序
35．1 使用作业
35．2 使用程序
35．3 使用时间表
35．4 使用作业类
35．5 dbms_schedule包
35．6 小结
第36章 使用flashback
36．1 实现flashback
36．2 dbms_flashback
36．3 小结
第37章 使用重定义联机表
37．1 重定义联机表
37．2 dbms_redefinition
37．3 小结
第38章 修正损坏块
38．1 实现损坏块修正
38．2 dbms_repair
38．3 小结
第39章 使用日志挖掘
39．1 实现日志挖掘
39．2 dbms_logmnr d包
39．3 dbms_logmnr包
39．4 小结
第40章 使用管道
40．1 实现管道
40．2 dbms_pipe包
40．3 小结
第41章 使用精细访问控制
41．1 实现精细访问控制
41．2 dbms_rls
41．3 小结
第42章 使用精细审计
42．1 实现精细审计
42．2 dbms_fga包
42．3 小结
第43章 使用预警事件
43．1 实现预警事件
43．2 dbms_alert
43．3 小结
第44章 转换rowid
44．1 实现rowid转换
44．2 dbms_rowid
44．3 小结
第45章 其他常用包
45．1 dbms_ddl
45．2 dbms_output
45．3 dbms_random
45．4 dbms_session
45．5 dbms_shared_pool
45．6 dbms_space
45．7 dbms_space_admin
45．8 dbms_transaction
45．9 dbms_tts
45．10 dbms_utility
45．11 utl_inaddr
附录a 习题答案
附录b sql*plus命令...
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Oracle 10g SQL和PL/SQL
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>从实践中学习Oracle/SQL
第一章 简单查询语句
第二章 限制性查询和数据的排序
第三章 常用的SQL*PLUS命令
第四章 单行函数
第五章 NULL值的处理、逻辑操作和函数嵌套
第六章 综合数据和分组函数
第七章 多表查询
第八章 子查询
第九章 控制SQL*PLUS的环境和数据字典简介
第十章 创建录
第十一章 替代变量
第十二章 数据的维护
第十三章 索引与约束
第十四章 视图
第十五章 序列号和同义词
第十六章 用户管理

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>从实践中学习Oracle/SQL
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Oracle 10g PL/SQL编程
前言
第1章 PL/SQL综述
第2章 PL/SQL开发工具
第3章 PL/SQL基础
第4章 使用SQL语句
第5章 SQL函数
第6章 访问ORACLE
第7章 编写控制结构
第8章 使用复合数据类型
第9章 使用游标
第10章 处理例外
第11章 开发子程序
第12章 开发包
……
附录A 习题参考答案
附录B 使用SQL*PLUS

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Oracle 10g PL/SQL编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle DBA培训教程
第O章  Oracle的安装及相关配置  0.1  Oracle的安装  0.2  进入Oracle的SQL*Plus界面  0.3  scott用户及其对象维护  0.4  虚拟环境的创建  0.5  虚拟人物第1章  Oracle的体系结构  1.1  Oracle引入复杂的体系结构的原因  1.2  Oracle数据库中常用的术语  1.3  Oracle数据库管理系统的体系结构  1.4  Oracle服务器  1.5  Oracle实例  1.6  Oracle数据库  1.7  Oracle其他的关键文件  1.8  建立与Oracle实例的连接  1.9  各种不同的连接方式  1.10  服务器进程  1.11  Oracle执行SQL查询语句的步骤  1.12  共享池(shared pool)  1.13  数据库高速缓冲区(database buffer cache)  1.14  内存缓冲区顾问(v$db cache advice)  1.15  重做日志缓冲区(redo log buflfer)  1.16  大池(large pool)和Java池(Java pool)  1.17  内存缓冲区大小的设定  1.18  内存缓冲区信息的获取  1.19  重做日志写进程(LGWR)及快速提交(fast commit)  1.20  数据库写进程(DBWR/[)BWn)  1.21  系统监督进程(SMON)  1.22  进程监督进程(PMC)N)  1.23  校验点(checkpoint)和校验点进程  1.24  归档日志(ARCH/ARCn)进程  1.25  小结  1.26  您应该掌握的内容第2章  数据库管理工具  2.1  Oracle通用安装程序(Oracle Universal Installer)  ……第3章  Oracle实例的管理第4章  数据字典和控制文件第5章  重做日志文件第6章  表空间和数据文件的管理第7章  存储结构和它们之间的关系第8章  管理还原数据第9章  创建数据库第10章  管理表第11章  索引的管理与维护第12章  管理和维护数据完整性第13章  用户及系统资源和安全的管理第14章  管理权限第15章  管理角色第16章  非归档模式下的冷德份和恢复第17章  数据库的归档模式第18章  数据库的联机(热)备份第19章  归档模式下的数据库恢复第20章  数据的移动第21章  闪回技术、备份恢复与优化第22章  设计、程序及内存的优化第23章  图形工具简介和I/O优化结束语鸣谢参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle DBA培训教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle DBA手记3
Part1 DBA 之路0 人生就是如此—冯春培感悟之路 Part2 DBA 手记1 杨廷琨的DBA手记  TRUNCATE 语句时间过长的诊断  隐式转换影响物化视图查询重写  批量修改数据后应收集统计信息  如何监测一个PL/SQL 过程的运行情况  一次RAC 环境性能诊断过程  数据泵功能灵活运用案例2 姜龙的DBA 工作手记  同义词降低逻辑读优化一则  11gR2 中物化视图在真实案例中的应用  利用TimesTen 内存数据库大幅提升性能  参考文献3 面向程序员的数据库访问性能优化法则  数据库访问优化法则简介  Oracle 数据库的两个基本概念  数据库访问优化法则详解4 Linux 大内存页Oracle 数据库优化  案例的引入  操作系统中的CPU 使用分析  使用大内存页来解决问题  小结Part3 SQL与SQL优化5 SQL 执行计划解读与案例分析  得到SQL 的真实执行计划  执行计划的执行顺序  10g/11g 里执行计划的一些增强  绑定变量对执行计划的影响  10053 事件分析执行计划一例  看似正常的执行计划导致严重性能问  题的案例  监听连接时间过长案例外一则6 使用SQL Profile 改变和稳定SQL 执行计划  SQL Profile 与Outline  SQL Profile 是什么  手工创建SQL Profile  使用SQL Profile 稳定SQL 语句的执行计划  使用SQL Profile 更改SQL 语句的执行计划  一个使用SQL Profile 的案例7 Oracle 中的NULL 值解析  NULL 的基础概念和由来  NULL 的布尔运算的特点  NULL 的默认数据类型  空字符串‘’与NULL 的关系  NULL 和索引  NULL 的其他方面特点Part4 内部原理与优化8 B*Tree 索引中的数据块分裂  如何分裂  树的生长  存储参数  分裂事务控制  数据块分配  等待事件  附：10g 中如何构建“高”索引9 事务队列等待（TX Enqueue）深入分析  记录锁  ITL 争用  索引争用  唯一性约束  位图索引维护  外键约束  其他争用10 Oracle 的Latch 优化深入解析  Latch 相关的视图  Latch Free（闩锁释放）  Shared Pool Latch 的研究  row cache objects  Latch：row cache objects 案例  也许Bug 曾经来过  Oracle 的spare parameter  cursor: pin S wait on X 事件  为什么硬解析如此昂贵  Oracle 11g 的dc_object_ids  Row Cache 的进一步分析  总结  参考文献11 Oracle 逻辑读写深入分析  全表扫描I  全表扫描II  全表扫描III  一致性读  当前模式  排序  索引扫描12 隐含参数与Library Cache、Shared Pool Latch原理—— 一次由隐含参数引起性能问题的处理  案例之问题现象  问题分析  问题的解决  问题的验证  问题总结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle DBA手记3
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 11g完全参考手册
第Ⅰ部分 关键的数据库概念 1
第1章 Oracle Database 11g 体系结构 3
1.1 数据库和实例 4
1.2 数据库技术 5
1.2.1 存储数据 6
1.2.2 数据保护 8
1.2.3 可编程的结构 8
1.3 选择体系结构和选项 9
第2章 安装Oracle Database 11g 和创建数据库 11
2.1 许可证和安装选项 13
2.2 使用 OUI 安装 Oracle 软件 13
第3章 升级到 Oracle Database 11g 19
3.1 选择升级方法 20
3.2 升级之前的准备 21
3.3 运行升级前信息工具(Pre-Upgrade Information Tool) 22
3.4 使用数据库升级助手(DBUA) 23
3.5 执行手动直接升级 23
3.6 使用 Export 与Import 24
3.6.1 使用哪个 Export 和Import 版本 24
3.6.2 进行升级 25
3.7 使用数据复制法 25
3.8 升级完成之后的工作 26
第4章 规划Oracle 应用程序——方法、风险和标准 27
4.1 协作方法 28
4.2 每个人都有“数据” 29
4.3 熟悉的 Oracle 语言 30
4.3.1 存储信息的表 31
4.3.2 结构化查询语言 31
4.3.3 简单的Oracle 查询 32
4.3.4 为什么称作“关系” 33
4.4 一些通用的、常见的示例 35
4.5 风险所在 36
4.6 新视角的重要性 37
4.6.1 变化的环境 38
4.6.2 代码、缩写和命名标准 38
4.7 如何减少混淆 39
4.7.1 规范化 40
4.7.2 表和列的英文名称 44
4.7.3 数据中的英文单词 46
4.8 名称和数据中的大写 46
4.9 规范化名称 47
4.10 人性化和优秀的设计 47
4.10.1 理解应用程序的任务 48
4.10.2 任务概要 49
4.11 理解数据 51
4.11.1 原子数据模型 52
4.11.2 原子业务模型 53
4.11.3 业务模型 53
4.11.4 数据项 53
4.11.5 查询和报告 53
4.12 关于对象名称的规范化 54
4.12.1 级别-名称完整性 54
4.12.2 外键 55
4.12.3 单数名称 55
4.12.4 简洁 56
4.12.5 对象名辞典 56
4.13 智能键和列值 56
4.14 建议 57
第Ⅱ部分 SQL和SQL*Plus 59
第5章 SQL 中的基本语法 61
5.1 样式 63
5.2 创建 NEWSPAPER 表 63
5.3 用SQL 从表中选择数据 64
5.4 select 、from 、where和order by 67
5.5 逻辑和值 69
5.5.1 单值测试 70
5.5.2 值列表的简单测试 75
5.5.3 组合逻辑 77
5.6 where 的另一个用途：子查询 78
5.6.1 从子查询得到单值 79
5.6.2 从子查询得到值列表 80
5.7 组合表 82
5.8 创建视图 83
5.9 扩展视图 85
第6章 基本的 SQL*Plus报表和命令 87
6.1 构建简单的报表 89
6.1.1 ①remark 90
6.1.2 ②set headsep 92
6.1.3 ③ttitle 和btitle 92
6.1.4 column 92
6.1.5 ⑧break on 93
6.1.6 ⑨compute avg 94
6.1.7 ⑩set linesize 95
6.1.8 set pagesize 95
6.1.9 set newpage 95
6.1.10 ⑩11spool 96
6.1.11 ⑩12/* */ 97
6.1.12 关于列标题的一些说明 97
6.2 其他特性 98
6.2.1 命令行编辑器 98
6.2.2 设置停顿 101
6.2.3 保存 102
6.2.4 存储 102
6.2.5 编辑 102
6.2.6 host 103
6.2.7 添加SQL*Plus命令 104
6.2.8 启动 104
6.3 检查 SQL*Plus环境 104
6.4 构件块 106
第7章 文本信息的收集与更改 107
7.1 数据类型 108
7.2 什么是串 108
7.3 表示法 109
7.4 连接符(||) 110
7.5 剪切和粘贴串 112
7.5.1 RPAD 和LPAD 112
7.5.2 LTRIM、RTRIM和TRIM 113
7.5.3 组合两个函数 114
7.5.4 使用TRIM 函数 116
7.5.5 再次使用填充函数 117
7.5.6 LOWER、UPPER和INITCAP 117
7.5.7 LENGTH 119
7.5.8 SUBSTR 119
7.5.9 INSTR 122
7.5.10 ASCII和CHR 127
7.6 在order by 和where子句中使用串函数 127
7.6.1 SOUNDEX 128
7.6.2 国际语言支持 130
7.6.3 正则表达式支持 130
7.7 小结 130
第8章 正则表达式搜索 131
8.1 搜索串 132
8.2 REGEXP_SUBSTR 135
8.3 REGEXP_INSTR 137
8.4 REGEXP_LIKE 138
8.5 REPLACE 和REGEXP_REPLACE 139
8.6 REGEXP_COUNT 143
第9章 数值处理 145
9.1 三类数值函数 145
9.2 表示法 146
9.3 单值函数 146
9.3.1 加减乘除 147
9.3.2 NULL 147
9.3.3 NVL：空值置换函数 148
9.3.4 ABS ：绝对值函数 149
9.3.5 CEIL 149
9.3.6 FLOOR 150
9.3.7 MOD 150
9.3.8 POWER 151
9.3.9 SQRT ：求平方根 151
9.3.10 EXP、LN和LOG 151
9.3.11 ROUND和TRUNC 152
9.3.12 SIGN 153
9.3.13 SIN、SINH、COS、COSH、TAN、TANH、ACOS、ATAN、ATAN2 和ASIN 153
9.4 聚集函数 154
9.4.1 组值函数中的NULL 154
9.4.2 单值函数和组值函数的示例 155
9.4.3 AVG、COUNT、MAX、MIM和SUM 156
9.4.4 组值函数和单值函数的组合 156
9.4.5 STDDEV 和VARIANCE 158
9.4.6 组函数中的DISTINCT 159
9.5 列表函数 160
9.6 使用MAX或MIN 函数查找行 161
9.7 优先级和圆括号的应用 163
9.8 小结 164
第10章 日期：过去、现在及日期的差 165
10.1 日期算法 165
10.1.1 SYSDATE 、CURRENT_DATE及SYSTIMESTAMP 166
10.1.2 两个日期的差 167
10.1.3 添加月份 168
10.1.4 减少月份 168
10.1.5 GREATEST 和LEAST 168
10.1.6 NEXT_DAY 170
10.1.7 LAST_DAY 171
10.1.8 MOMTHS_BETWEEN 171
10.1.9 组合日期函数 172
10.2 日期计算中的ROUND和TRUNC 172
10.3 使用TO_DATE 和TO_CHAR设置日期格式 173
10.3.1 最常见的TO_CHAR 错误 178
10.3.2 NEW_TIME ：切换时区 178
10.3.3 TO_DATE 计算 179
10.4 where子句中的日期 181
10.5 处理多个世纪 182
10.6 使用 EXTRACT 函数 183
10.7 使用 TIMESTAMP 数据类型 183
第11章 转换函数与变换函数 185
11.1 基本的转换函数 187
11.1.1 数据类型的自动转换 189
11.1.2 关于自动转换的注意事项 192
11.2 特殊的转换函数 192
11.3 变换函数 193
11.3.1 TRANSLATE 193
11.3.2 DECODE 194
11.4 小结 195
第12章 分组函数 197
12.1 group by 和having 的用法 198
12.1.1 添加一个order by 199
12.1.2 执行顺序 200
12.2 分组视图 202
12.3 用别名重命名列 203
12.4 分组视图的功能 204
12.4.1 在视图中使用order by 205
12.4.2 having子句中的逻辑 206
12.4.3 对列和分组函数进行排序 207
12.4.4 连接列 208
12.5 更多分组可能性 208
第13章 当一个查询依赖于另一个查询时 209
13.1 高级子查询 209
13.1.1 相关子查询 210
13.1.2 并列的逻辑测试 211
13.1.3 EXISTS 及其相关子查询的使用 213
13.2 外部连接 214
13.2.1 Oracle 9i以前版本中的外部连接的语法 215
13.2.2 现在的外部连接语法 216
13.2.3 用外部连接代替NOT IN 218
13.2.4 用NOT EXISTS 代替NOT IN 219
13.3 自然连接和内部连接 220
13.4 UNION、INTERSECT和MINUS 221
13.4.1 IN 子查询 224
13.4.2 UNION、INTERSECT和MINUS的限制 224
第14章 一些复杂的技术 225
14.1 复杂的分组 225
14.2 使用临时表 227
14.3 使用ROLLUP、GROUPING和CUBE 228
14.4 家族树和 connect by 232
14.4.1 排除个体和分支 235
14.4.2 向根遍历 236
14.4.3 基本规则 238
第15章 更改数据：插入、更新、合并和删除 239
15.1 插入 240
15.1.1 插入时间 240
15.1.2 用select 插入 241
15.1.3 使用APPEND 提示改善插入性能 242
15.2 rollback、commit和autocommit命令 243
15.2.1 使用savepoint 243
15.2.2 隐式提交 245
15.2.3 自动回滚 245
15.3 多表插入 245
15.4 delete命令 249
15.5 update 命令 250
15.5.1 用嵌入式select 进行更新 251
15.5.2 用NULL 更新 252
15.6 使用 merge命令 253
15.7 处理错误 256
第16章 DECODE 和CASE：SQL中的if-then-else 259
16.1 if-then-else 260
16.2 通过 DECODE替换值 263
16.3 DECODE 中的DECODE 264
16.4 DECODE 中的大于和小于 267
16.5 使用 CASE 269
16.6 使用 PIVOT 272
第17章 创建和管理表、视图、索引、群集和序列 275
17.1 创建表 276
17.1.1 字符宽度和数值精度 277
17.1.2 在插入时进行舍入 279
17.1.3 create table的约束 281
17.1.4 指定索引表空间 282
17.1.5 命名约束 283
17.2 删除表 284
17.3 更改表 284
17.3.1 添加或修改列的规则 287
17.3.2 创建只读表 288
17.3.3 更改当前使用的表 288
17.3.4 创建虚拟列 288
17.3.5 删除列 289
17.4 根据一个表创建另一个表 290
17.5 创建索引编排表 292
17.6 创建视图 293
17.6.1 视图的稳定性 293
17.6.2 视图中的order by 294
17.6.3 创建只读视图 295
17.7 索引 295
17.7.1 创建索引 296
17.7.2 实施唯一性 296
17.7.3 创建唯一索引 297
17.7.4 创建位图索引 297
17.7.5 何时创建索引 298
17.7.6 创建不可见索引 299
17.7.7 索引列的变化 299
17.7.8 一个表能使用多少个索引 299
17.7.9 在数据库中放置索引 300
17.7.10 重建索引 300
17.7.11 基于函数的索引 301
17.8 群集 301
17.9 序列 303
第18章 分区 305
18.1 创建分区表 306
18.2 列表分区 308
18.3 创建子分区 309
18.4 创建范围和间隔分区 309
18.5 索引分区 311
18.6 管理分区表 311
第19章 Oracle 基本安全 313
19.1 用户、角色和权限 314
19.1.1 创建用户 314
19.1.2 密码管理 315
19.1.3 标准角色 318
19.1.4 grant 命令的格式 319
19.1.5 撤消权限 320
19.2 可以授予用户何种权限 320
19.2.1 利用connect移动到另一个用户 322
19.2.2 创建同义词 325
19.2.3 使用未授权的权限 325
19.2.4 权限的传递 325
19.2.5 创建角色 327
19.2.6 为角色授权 327
19.2.7 将一个角色授予另一个角色 328
19.2.8 为用户授予角色 328
19.2.9 为角色添加密码 329
19.2.10 删除角色的密码 329
19.2.11 启用和禁用角色 330
19.2.12 撤消角色的权限 331
19.2.13 删除角色 331
19.2.14 给指定的列授予UPDATE权限 331
19.2.15 撤消对象权限 331
19.2.16 用户安全性 332
19.2.17 给公众授予访问权 333
19.3 有限资源的授权 334
第Ⅲ部分 高 级 主 题 335
第20章 高级安全性——虚拟专用数据库 337
20.1 初始配置 338
20.2 创建应用程序上下文 339
20.3 创建登录触发器 341
20.4 创建安全策略 342
20.5 将安全策略应用于表 343
20.6 测试 VPD 343
20.7 如何实现列级别的 VPD 345
20.8 如何禁用 VPD 346
20.9 如何使用策略组 347
第21章 高级安全性：透明数据加密 349
21.1 列的透明数据加密 349
21.1.1 设置 350
21.1.2 RAC 数据库的额外设置 351
21.1.3 钱夹的打开和关闭 351
21.1.4 列的加密和解密 352
21.2 表空间的加密 353
21.2.1 设置 353
21.2.2 创建加密的表空间 354
第22章 使用表空间 355
22.1 表空间与数据库的结构 355
22.1.1 表空间内容 356
22.1.2 表空间中的RECYCLEBIN空间 358
22.1.3 只读表空间 359
22.1.4 无日志表空间 360
22.1.5 临时表空间 360
22.1.6 用于系统管理撤消的表空间 360
22.1.7 大文件表空间 361
22.1.8 加密的表空间 361
22.1.9 支持闪回数据库 361
22.1.10 移动表空间 362
22.2 规划表空间的使用 362
22.2.1 分离活动表与静态表 362
22.2.2 分离索引与表 362
22.2.3 分离大对象与小对象 363
22.2.4 将应用程序表与核心对象分开 363
第23章 用SQL*Loader 加载数据 365
23.1 控制文件 366
23.2 开始加载 367
23.3 逻辑记录与物理记录 370
23.4 控制文件语法注释 371
23.5 管理数据加载 373
23.6 重复数据加载 373
23.7 调整数据加载 374
23.8 直接路径加载 375
23.9 附加功能 377
第24章 使用Data Pump Export和Data Pump Import 379
24.1 创建目录 380
24.2 Data Pump Export选项 380
24.3 启动 Data Pump Export作业 383
24.3.1 停止和重新启动运行的作业 384
24.3.2 从另一个数据库中导出 385
24.3.3 使用EXCLUDE 、INCLUDE和QUERY 385
24.4 Data Pump Import选项 387
24.5 启动 Data Pump Import作业 389
24.5.1 停止和重新启动运行的作业 391
24.5.2 EXCLUDE、INCLUDE和QUERY 391
24.5.3 转换导入的对象 391
24.5.4 生成SQL 392
第25章 访问远程数据 395
25.1 数据库链接 395
25.1.1 数据库链接是如何工作的 396
25.1.2 利用数据库链接进行远程查询 396
25.1.3 对同义词和视图使用数据库链接 397
25.1.4 利用数据库链接进行远程更新 398
25.1.5 数据库链接的语法 399
25.2 为位置透明性使用同义词 402
25.3 在视图中使用 User 伪列 403
第26章 使用物化视图 405
26.1 功能 406
26.2 必需的系统权限 406
26.3 必需的表权限 407
26.4 只读物化视图与可更新的物化视图 407
26.5 创建物化视图的语法 408
26.5.1 物化视图的类型 411
26.5.2 基于RowID 和基于主键的物化视图 411
26.5.3 使用预建表 412
26.5.4 为物化视图表创建索引 412
26.6 用物化视图更改查询执行路径 412
26.7 使用 DBMS_ADVISOR 414
26.8 刷新物化视图 416
26.8.1 可执行何种刷新 417
26.8.2 用CONSIDER FRESH快速刷新 420
26.8.3 自动刷新 420
26.8.4 人工刷新 421
26.9 创建物化视图日志的语法 422
26.10 更改物化视图和日志 423
26.11 删除物化视图和日志 423
第27章 使用Oracle Text进行文本搜索 425
27.1 将文本添加到数据库中 426
27.2 文本查询和文本索引 427
27.2.1 文本查询 427
27.2.2 可使用的文本查询表达式 428
27.2.3 一个单词精确匹配的搜索 429
27.2.4 多个单词精确匹配的搜索 429
27.2.5 短语精确匹配的搜索 433
27.2.6 搜索互相接近的单词 434
27.2.7 在搜索中使用通配符 434
27.2.8 搜索具有相同词根的单词 435
27.2.9 模糊匹配搜索 436
27.2.10 搜索发音相似的单词 437
27.2.11 使用 ABOUT运算符 438
27.2.12 索引同步 439
27.3 索引集 439
第28章 使用外部表 441
28.1 访问外部数据 442
28.2 创建外部表 443
28.2.1 外部表创建选项 446
28.2.2 创建时加载外部表 451
28.3 更改外部表 452
28.3.1 Access Parameters 子句 452
28.3.2 Add Column 子句 452
28.3.3 Default Directory 子句 452
28.3.4 Drop Column 子句 452
28.3.5 Location 子句 452
28.3.6 Modify Column 子句 452
28.3.7 Parallel 子句 453
28.3.8 Project Column 子句 453
28.3.9 Reject Limit 子句 453
28.3.10 Rename To 子句 453
28.4 外部表的优缺点和潜在用途 453
第29章 使用闪回查询 455
29.1 基于时间的闪回示例 456
29.2 保存数据 457
29.3 基于 SCN 的闪回示例 458
29.4 闪回查询失败的后果 459
29.5 什么 SCN 与每一行关联 460
29.6 闪回版本查询 461
29.7 闪回计划 463
第30章 闪回：表和数据库 465
30.1 flashback table 命令 465
30.1.1 必需的权限 466
30.1.2 恢复删除的表 466
30.1.3 启用和禁用回收站 468
30.1.4 闪回 SCN 或者时间戳 468
30.1.5 索引和统计信息 469
30.2 flashback database 命令 469
第31章 SQL 重放 473
31.1 高级别配置 473
31.1.1 分离和连接 474
31.1.2 创建工作负载目录 474
31.2 捕获工作负载 475
31.2.1 定义过滤器 475
31.2.2 启动捕获 476
31.2.3 停止捕获 477
31.2.4 导出 AW R数据 477
31.3 处理工作负载 477
31.4 重放工作负载 478
31.4.1 控制和启动重放客户 478
31.4.2 初始化和运行重放 479
31.4.3 导出 AW R数据 480
第Ⅳ部分 PL/SQL 481
第32章 PL/SQL 简介 483
32.1 PL/SQL概述 483
32.2 声明部分 484
32.3 可执行命令部分 487
32.3.1 条件逻辑 489
32.3.2 循环 490
32.3.3 CASE 语句 499
32.4 异常处理部分 500
第33章 应用程序在线升级 503
33.1 高可用数据库 503
33.1.1 Oracle Data Guard( 数据卫士)体系结构 504
33.1.2 创建备用数据库配置 506
33.1.3 管理角色——切换和故障转移 507
33.2 最小化 DDL变更的影响 510
33.2.1 创建虚拟列 510
33.2.2 改变正在使用的表 511
33.2.3 添加 NOT NULL 列 512
33.2.4 在线对象重新组织 512
33.2.5 删除列 515
第34章 触发器 517
34.1 必需的系统权限 518
34.2 必需的表权限 518
34.3 触发器类型 518
34.3.1 行级触发器 518
34.3.2 语句级触发器 519
34.3.3 BEFORE和AFTER触发器 519
34.3.4 INSTEAD OF触发器 519
34.3.5 模式触发器 520
34.3.6 数据库级触发器 520
34.3.7 复合触发器 520
34.4 触发器语法 520
34.4.1 DML 触发器类型的组合 522
34.4.2 设置插入值 523
34.4.3 维护复制的数据 524
34.4.4 定制错误条件 525
34.4.5 在触发器中调用过程 527
34.4.6 命名触发器 527
34.4.7 创建 DDL事件触发器 528
34.4.8 创建数据库事件触发器 531
34.4.9 创建复合触发器 532
34.5 启用和禁用触发器 533
34.6 替换触发器 534
34.7 删除触发器 534
第35章 过程、函数与程序包 535
35.1 必需的系统权限 536
35.2 必需的表权限 537
35.3 过程与函数 538
35.4 过程与程序包 538
35.5 create procedure 语法 538
35.6 create function 语法 540
35.6.1 在过程中引用远程表 542
35.6.2 调试过程 543
35.6.3 创建自己的函数 544
35.6.4 定制错误条件 546
35.6.5 命名过程和函数 547
35.7 create package 语法 547
35.8 查看过程对象的源代码 550
35.9 编译过程、函数和程序包 551
35.10 替换过程、函数和程序包 552
35.11 删除过程、函数和程序包 552
第36章 使用本地动态SQL和DBMS_SQL 553
36.1 使用EXECUTE IMMEDIATE 553
36.2 使用绑定变量 555
36.3 使用 DBMS_SQL 556
36.3.1 OPEN_CURSOR 557
36.3.2 PARSE 557
36.3.3 BIND_VARIABLE和BIND_ARRAY 558
36.3.4 EXECUTE 558
36.3.5 DEFINE_COLUMN 558
36.3.6 FETCH_ROWS 、EXECUTE_AND_FETCH和COLUMN_VALUE 559
36.3.7 CLOSE_CURSOR 559
第37章 PL/SQL 调整 561
37.1 调整 SQL 561
37.2 调整 PL/SQL 的步骤 562
37.3 使用DBMS_PROFILE识别问题 563
37.4 将PL/SQL 特性用于批量操作 568
37.4.1 forall 操作 568
37.4.2 bulk collect操作 571
第Ⅴ部分 对象关系数据库 573
第38章 实现对象类型、对象视图和方法 575
38.1 使用对象类型 575
38.1.1 对象类型的安全性 576
38.1.2 索引对象类型属性 579
38.2 实现对象视图 581
38.2.1 通过对象视图操作数据 583
38.2.2 使用INSTEAD OF 触发器 584
38.3 方法 586
38.3.1 创建方法的语法 586
38.3.2 管理方法 588
第39章 收集器(嵌套表和可变数组) 589
39.1 可变数组 589
39.1.1 创建可变数组 590
39.1.2 描述可变数组 590
39.1.3 向可变数组中插入记录 592
39.1.4 从可变数组中选择数据 593
39.2 嵌套表 596
39.2.1 指定嵌套表的表空间 597
39.2.2 向嵌套表中插入记录 597
39.2.3 操作嵌套表 598
39.3 嵌套表与可变数组的附加函数 600
39.4 嵌套表和可变数组的管理问题 601
39.4.1 收集器的可变性 601
39.4.2 数据的位置 602
第40章 使用大对象 603
40.1 可用的数据类型 603
40.2 为LOB 数据指定存储参数 605
40.3 LOB 值的操作和选择 607
40.3.1 初始化值 608
40.3.2 用子查询插入数据 610
40.3.3 更新LOB值 610
40.3.4 使用串函数处理LOB 值 611
40.3.5 使用DBMS_LOB操作LOB 值 612
40.3.6 删除LOB 628
第41章 面向对象的高级概念 629
41.1 行对象和列对象 630
41.2 对象表和 OID 630
41.2.1 把行插入对象表 631
41.2.2 从对象表中选择值 632
41.2.3 从对象表中更新和删除数据 632
41.2.4 REF 函数 633
41.2.5 使用DEREF函数 633
41.2.6 VALUE 函数 636
41.2.7 无效引用 637
41.3 具有 REF 的对象视图 637
41.3.1 对象视图的简要回顾 637
41.3.2 包含引用的对象视图 638
41.4 对象 PL/SQL 641
41.5 数据库中的对象 643
第Ⅵ部分 Oracle 中的Java 645
第42章 Java简介 647
42.1 Java 与PL/SQL 概述 648
42.2 开始 648
42.3 声明 649
42.4 可执行命令 649
42.4.1 条件逻辑 651
42.4.2 循环 654
42.4.3 异常处理 656
42.4.4 保留字 657
42.5 类 657
第43章 JDBC 程序设计 663
43.1 使用 JDBC 类 664
43.2 使用 JDBC 进行数据操作 667
第44章 Java存储过程 671
44.1 将类加载到数据库中 673
44.2 如何访问类 677
44.2.1 直接调用Java 存储过程 679
44.2.2 在何处执行命令 680
第Ⅶ部分 指 南 681
第45章 Oracle 数据字典指南 683
45.1 关于名称的说明 684
45.2 Oracle Database 11g中引入的新视图 684
45.3 路线图：DICTIONARY(DICT)和DICT_COLUMNS 688
45.4 从表、列、视图、同义词和序列中选择 689
45.4.1 目录：USER_CATALOG(CAT) 689
45.4.2 对象：USER_OBJECTS(OBJ) 690
45.4.3 表：USER_TABLES(TABS) 691
45.4.4 列：USER_TAB_COLUMNS(COLS) 693
45.4.5 视图：USER_VIEWS 694
45.4.6 同义词：USER_SYNONYMS(SYN) 696
45.4.7 序列：USER_SEQUENCES(SEQ) 697
45.5 回收站：USER_RECYCLEBIN和DBA_RECYCLEBIN 697
45.6 约束和注释 697
45.6.1 约束：USER_CONSTRAINTS 698
45.6.2 约束列：USER_CONS_COLUMNS 699
45.6.3 约束异常：EXCEPTIONS 700
45.6.4 表注释：USER_TAB_COMMENTS 700
45.6.5 列注释：USER_COL_COMMENTS 701
45.7 索引和群集 702
45.7.1 索引：USER_INDEXES(IND) 702
45.7.2 索引列：USER_IND_COLUMNS 704
45.7.3 群集：USER_CLUSTERS(CLU) 705
45.7.4 群集列：USER_CLU_COLUMNS 705
45.8 抽象数据类型和 LOB 706
45.8.1 抽象数据类型：USER_TYPES 706
45.8.2 LOB ：USER_LOBS 708
45.9 数据库链接和物化视图 709
45.9.1 数据库链接：USER_DB_LINKS 709
45.9.2 物化视图 709
45.9.3 物化视图日志：USER_MVIEW_LOGS 711
45.10 触发器、过程、函数和程序包 711
45.10.1 触发器：USER_TRIGGERS 712
45.10.2 过程、函数和程序包：USER_SOURCE 712
45.11 维度 714
45.12 包括分区和子分区的空间分配和使用情况 715
45.12.1 表空间：USER_TABLESPACES 715
45.12.2 空间限额：USER_TS_ QUOTAS 715
45.12.3 段和区：USER_SEGMENTS和USER_EXTENTS 716
45.12.4 分区和子分区 717
45.12.5 可用空间：USER_FREE_SPACE 719
45.13 用户和权限 719
45.13.1 用户：USER_USERS 719
45.13.2 资源限制：USER_RESOURCE_LIMITS 719
45.13.3 表的权限：USER_TAB_PRIVS 720
45.13.4 列权限：USER_COL_PRIVS 720
45.13.5 系统权限：USER_SYS_PRIVS 721
45.14 角色 721
45.15 审计 722
45.16 其他视图 723
45.17 监控：V$动态性能表 723
45.17.1 CHAINED_ROWS 723
45.17.2 PLAN_TABLE 724
45.17.3 相互依赖性：USER_DEPENDENCIES和IDEPTREE 724
45.17.4 只属于DBA的视图 724
45.17.5 Oracle Label Security 724
45.17.6 SQL*Loader直接加载视图 725
45.17.7 全球支持视图 725
45.17.8 库 725
45.17.9 异构服务 725
45.17.10 索引类型和运算符 725
45.17.11 概要 726
45.17.12 顾问程序 726
45.17.13 调度程序 726
第46章 应用程序和 SQL 调整指南 727
46.1 Oracle Database 11g新增的调整功能 728
46.2 Oracle 11g新增的调整特性 728
46.3 调整——最优方法 729
46.3.1 尽可能少做 730
46.3.2 尽可能简单地完成 732
46.3.3 告诉数据库需要知道什么 733
46.3.4 最大化环境中的吞吐量 734
46.3.5 分开处理数据 735
46.3.6 正确测试 736
46.4 生成并读取说明计划(explain plan) 738
46.4.1 使用set autotrace on 738
46.4.2 使用explain plan 742
46.5 Explain Plan 中的主要操作 743
46.5.1 TABLE ACCESS FULL 743
46.5.2 TABLE ACCESS BY INDEX ROWID 744
46.5.3 相关提示 744
46.5.4 使用索引的操作 744
46.5.5 何时使用索引 746
46.5.6 操纵数据集的操作 751
46.5.7 执行连接的操作 757
46.5.8 Oracle如何处理两个以上表的连接 758
46.5.9 并行化和缓存问题 764
46.6 实现存储概要 764
46.7 小结 766
第47章 SQL 结果缓存和客户端查询缓存 767
47.1 SQL 结果缓存的数据库参数设置 774
47.2 DBMS_RESULT_CACHE程序包 775
47.3 SQL 结果缓存的字典视图 776
47.4 SQL 结果缓存的更多细节 777
47.5 Oracle 调用接口(OCI) 客户端查询缓存 777
47.6 Oracle 调用接口(OCI) 客户端查询缓存的限制 778
第48章 关于调整的示例分析 779
48.1 示例分析1 ：等待、等待、再等待 779
48.2 示例分析2 ：破坏应用程序的查询 782
48.3 示例分析3 ：长期运行的批处理作业 786
第49章 高级体系结构选项——DB保险库、内容DB和记录DB 789
49.1 Oracle 数据库保险库 790
49.1.1 Oracle数据库保险库的新概念 790
49.1.2 禁用Oracle 数据库保险库 791
49.1.3 启用Oracle 数据库保险库 792
49.1.4 数据库保险库安装的注意事项 793
49.2 Oracle 内容数据库套件 796
49.2.1 存储库 796
49.2.2 文档管理 797
49.2.3 用户安全性 797
49.3 Oracle 记录数据库 798
第50章 Oracle 实时应用群集 801
50.1 安装前的准备 802
50.2 安装 RAC 802
50.2.1 存储 803
50.2.2 初始化参数 803
50.3 启动和停止 RAC实例 805
50.4 透明应用程序故障切换 807
50.5 为群集添加节点和实例 808
第51章 数据库管理指南 811
51.1 创建数据库 812
51.2 启动和停止数据库 813
51.3 设置和管理内存区域大小 814
51.4 分配和管理对象的空间 816
51.4.1 存储子句的含义 817
51.4.2 表段 818
51.4.3 索引段 819
51.4.4 系统管理的撤消 819
51.4.5 临时段 820
51.4.6 可用空间 821
51.4.7 设置数据库对象的大小 822
51.5 监控撤消表空间 824
51.6 自动存储管理 824
51.7 段空间管理 825
51.8 移动表空间 826
51.8.1 生成可移动表空间集 826
51.8.2 插入可移动表空间集 827
51.9 进行备份 828
51.9.1 Data Pump Export 和Data Pump Import 828
51.9.2 脱机备份 829
51.9.3 联机备份 830
51.9.4 Recovery Manager 833
51.10 展望 834
第52章 Oracle 中的 XML指南 835
52.1 文档类型定义、元素及属性 836
52.2 XML 模式 839
52.3 使用XSU选择、插入、更新和删除XML值 841
52.3.1 使用XSU 进行插入、更新和删除 843
52.3.2 XSU 和Java 844
52.3.3 定制查询过程 845
52.4 使用 XMLType 846
52.5 其他功能 848
第Ⅷ部分 附 录 849
附录A 命令和术语参考 851
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 11g完全参考手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>让Oracle跑得更快2
开篇的话	1第一篇  分    区第1章  分区的渊源	8  1.1  DELETE与系统资源	9  1.2  DELETE与释放空间	17第2章  分区在海量数据库中的应用	22  2.1  分区的种类	23    2.1.1  范围分区	23    2.1.3  列表分区	51    2.1.4  组合分区	53  2.2  三种分区的比较	56    2.2.1  范围分区的适用情况	57    2.2.2  哈希分区的效率	57    2.2.3  列表分区与范围分区各自的优势	65  2.3  小结	72第二篇  索    引第3章  B树索引	74  3.1  B树索引概述	75  3.2  B数索引的效率	76    3.2.1  主键或者唯一性约束	76    3.2.2  键值重复率低的字段比较适合使用B树索引	88第4章  位图索引	97  4.1  位图索引概述	98  4.2  什么时候使用位图索引	110第5章  全文索引	123  5.1  全文索引概述	123    5.1.1  全文索引和普通索引的对比	124    5.1.2  全文索引的对象	128    5.1.3  全文索引在海量数据库中的应用	138  5.2  全文索引的空间	154  5.3  全文索引和DML操作	161    5.3.1  INSERT操作	161    5.3.2  DELETE操作	165    5.3.3  UPDATE操作	167  5.4  CTX_REPORT工具包	171    5.4.1  CTX_REPORT.DESCRIBE_INDEX	175    5.4.2  DESCRIBE_POLICY函数	178    5.4.3  CREATE_INDEX_SCRIPT函数	179    5.4.4  CREATE_POLICY_SCRIPT函数	181    5.4.5  INDEX_SIZE函数	182    5.4.6  INDEX_STATS存储过程	185    5.4.7  QUERY_LOG_SUMMARY存储过程	187  5.5  小结	194第三篇  对 象 属 性第6章  对象属性概述	196  6.1  Oracle数据库中的对象属性	196  6.2  对象属性和系统的关系	201第7章  并行度	204  7.1  对象属性上的并行	205  7.2  使用Hint方式并行执行	209  7.3  索引上的并行度	212第8章  数据压缩	218  8.1  数据压缩技术的应用	219  8.2  分区索引的压缩	223  8.3  数据压缩的优越性	226    8.3.1  节省空间	226    8.3.2  性能的提高	233  8.4  DML操作和数据压缩	241第9章  只读表空间	248  9.1  只读表空间与数据备份和恢复的关系	249  9.2  只读表空间对于数据库的启动和关闭的影响	253  9.3  只读表空间可以防止数据被意外删除和修改	258  9.4  只读表空间使表空间的管理更加方便	262第10章  数据库对象的分析	268  10.1  CBO和RBO	269  10.2  分析和动态采样	274  10.3  对象分析的频度	278    10.3.1  数据入库后不再改变	278    10.3.2  数据存在表中且经常改变	295第四篇  海量数据的数据库架构设计第11章  RAC架构	310  11.1  RAC在海量数据库中的应用	318  11.2  RAC架构之业务分割	320  11.3  RAC架构之负载均衡	333    11.3.1  客户端的负载均衡	333    11.3.2  服务器端的负载均衡	339  11.4  RAC架构之FAILOVER	341第12章  分布式数据库	344  12.1  分布式数据库的优越性	344  12.2  分布式数据库的数据处理	346  12.3  分布式数据库的字符集	348第13章  Data Guard	350  13.1  Data Guard概述	351  13.2  Data Guard的保护模式	354    13.2.1  最高数据保护模式	354    13.2.2  最高性能模式	354    13.2.3  最高可用性模式	355  13.3  Data Guard和RAC	356  13.4  Data Guard中Standby数据库的类型	357    13.4.1  物理Standby数据库	357    13.4.2  逻辑Standby数据库	358第14章  存储架构的设计（ASM+SAN）	360  14.1  ASM	361    14.1.1  方便存储管理	362    14.1.2  ASM的一个管理工具—asmcmd	370    14.1.3  存储的高可用性	373    14.1.4  提升存储性能	376  14.2  SAN	377第15章  海量数据的备份和恢复	380  15.1  传统的数据备份方案	380    15.1.1  通过数据导出方式备份数据	381    15.1.2  数据库冷备份	381    15.1.3  数据库热备份	382  15.2  海量数据的数据库备份和恢复方案	383    15.2.1  使用分布式数据库	383    15.2.2  以传递表空间的方式对表空间进行备份和恢复	384    15.2.3  对加载数据进行备份	395第五篇  初始化参数第16章  内存相关的参数	400  16.1  SGA_TARGET	400  16.2  PGA_AGGREGATE_TARGET	406第17章  I/O相关的参数	409  17.1  DB_FILE_MULTIBLOCK_READ_COUNT	410  17.2  和数据库I/O及数据文件相关的其他4个参数	415    17.2.1  DB_WRITER_PROCESSES	415    17.2.2  DISK_ASYNCH_IO	416    17.2.3  DBWR_IO_SLAVES	417    17.2.4  DB_FILES	417第18章  优化器相关的参数	418  18.1  CURSOR_SHARING	418  18.2  OPTIMIZER_DYNAMIC_SAMPLING	422  18.3  OPTIMIZER_MODE	425    18.3.1  ALL_ROWS	425    18.3.2  FIRST_ROWS_n	425    18.3.3  FIRST_ROWS	426第19章  其他的参数	428  19.1  并行相关的参数	428    19.1.1  在对象的属性中设置并行	429    19.1.2  Hint中使用并行	429  19.2  分布式数据库相关的参数	432附录A  Oracle字符集	434附录B  SHOW_SPACE存储过程	443附录C  一个典型的OLAP系统数据库的设计方案	447  C.1  架构	448  C.2  对象设计	449  C.3  初始化参数	460
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>让Oracle跑得更快2
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 11g初学者指南
目录
第1章 数据库基础 1
1.1 数据库定义 2
1.2 Oracle Database 11g的体系结构 3
1.2.1 控制文件 4
1.2.2 联机重做日志 4
1.2.3 System表空间 4
1.2.4 Sysaux表空间 4
1.2.5 默认的临时表空间 5
1.2.6 Undo表空间 5
1.2.7 服务器参数文件 5
1.2.8 后台进程 5
1.2.9 数据库管理员 7
1.3 Oracle Database 11g的基本数据类型 8
1.3.1 varchar2 8
1.3.2 数字 9
1.3.3 日期 9
1.3.4 时间戳 9
1.3.5 clob 10
1.3.6 blob 10
1.4 表 10
1.5 存储对象 11
1.5.1 视图 12
1.5.2 触发器 12
1.5.3 过程 13
1.5.4 函数 13
1.5.5 包 13
1.6 Oracle Database 11g的其他重要内容 14
1.6.1 索引 15
1.6.2 用户 15
1.6.3 表空间配额 15
1.6.4 同义词 16
1.6.5 角色 17
1.6.6 默认用户环境 17
1.7 对象和系统权限 18
1.7.1 select 18
1.7.2 insert 18
1.7.3 update 18
1.7.4 delete 18
1.7.5 系统权限 19
1.8 网格 19
1.9 综述 21
1.10 本章测验 22
第2章 Oracle安装 25
2.1 安装研究和安装计划 26
2.1.1 确定系统需求 26
2.1.2 Linux安装 27
2.2 操作系统设置 30
2.3 Linux简介 33
2.4 选择安装组件 35
2.5 安装Oracle软件 35
2.5.1 数据库配置助手 41
2.5.2 验证安装 44
2.6 综述 44
2.7 本章测验 45
第3章 Oracle网络连接 47
3.1 使用Oracle Net Services 48
3.1.1 网络协议 49
3.1.2 优化网络带宽 49
3.1.3 连接 49
3.1.4 保持连接 50
3.1.5 定义一个位置 50
3.2 专用和共享服务器体系结构之间的差别 51
3.2.1 专用服务器 51
3.2.2 共享服务器 52
3.2.3 设置分派进程 53
3.2.4 监视共享服务器的视图 54
3.3 定义连接 55
3.3.1 连接描述符 55
3.3.2 定义连接描述符 55
3.3.3 Oracle连接管理器 56
3.3.4 会话多路复用 56
3.3.5 防火墙访问控制 57
3.4 使用Oracle Net Listener 57
3.4.1 密码验证 59
3.4.2 多个监听进程 59
3.4.3 连接池 59
3.5 命名方法 60
3.5.1 目录命名方法 60
3.5.2 目录信息树 60
3.5.3 标识名 61
3.5.4 如何查找目录命名信息 61
3.5.5 网络服务别名条目 61
3.5.6 本地命名方法 62
3.5.7 简单命名方法 62
3.5.8 外部命名方法 62
3.5.9 使用哪种命名方法 62
3.6 使用Oracle配置文件 63
3.7 使用管理工具 64
3.7.1 OEM/网格控件 64
3.7.2 Oracle网络管理器 64
3.7.3 OEM控制台 65
3.7.4 OEM组件 65
3.7.5 Oracle网络配置助手 65
3.7.6 Oracle网络目录配置助手 65
3.7.7 命令行实用程序 66
3.7.8 Oracle高级安全选项 67
3.7.9 分派进程 67
3.8 使用配置文件 69
3.9 多层环境中的网络 70
3.10 安装Oracle 11g客户端软件 71
3.11 本章测验 75
第4章 SQL：结构化查询语言 77
4.1 SQL语句的组成 78
4.1.1 DDL 78
4.1.2 DML 79
4.2 基本的insert和select语句 79
4.2.1 insert 79
4.2.2 select 80
4.3 简单的where子句 81
4.3.1 带and/or的where子句 84
4.3.2 带NOT的where子句 85
4.3.3 带搜索范围的where子句 85
4.3.4 带搜索列表的where子句 85
4.3.5 带模式搜索的where子句 86
4.3.6 where子句中的常用操作符 86
4.4 基本的update和delete语句 87
4.4.1 update语句 87
4.4.2 delete语句 88
4.5 数据排序 90
4.6 函数：字符串函数、数字函数和聚集函数(不是分组) 91
4.6.1 字符串函数 91
4.6.2 数字函数 92
4.6.3 聚集函数 92
4.7 日期函数(格式化的和按时间排列的) 93
4.7.1 日期函数 93
4.7.2 特殊格式的日期数据类型 94
4.7.3 嵌套函数 94
4.8 连接(ANSI与Oracle对比)：内连接、外连接、自连接 95
4.8.1 内连接 95
4.8.2 外连接 98
4.8.3 自连接 102
4.9 group by和having子句 103
4.9.1 group by 103
4.9.2 having 104
4.10 子查询：简单子查询和带连接的相关比较 107
4.10.1 简单子查询 107
4.10.2 带连接的相关子查询 108
4.11 集合操作符：union、intersect和minus 108
4.11.1 union 109
4.11.2 union all 109
4.11.3 intersect 110
4.11.4 minus 110
4.12 视图 112
4.13 序列 113
4.14 约束：与实体模型的联系、类型、延迟 114
4.14.1 与实体模型的联系 115
4.14.2 类型 115
4.14.3 延迟 116
4.15 用SQL*Plus进行格式化输出 116
4.15.1 页和行大小 116
4.15.2 页标题 116
4.15.3 页脚 117
4.15.4 格式化列 117
4.15.5 将SQL*Plus输出结果写入文件 119
4.16 本章测验 119
第5章 PL/SQL 121
5.1 PL/SQL定义和使用PL/SQL的原因 122
5.2 基本PL/SQL编程结构 123
5.3 定义PL/SQL数据类型 124
5.3.1 有效字符集 124
5.3.2 算术操作符 125
5.3.3 varchar 2类型 126
5.3.4 数字类型 127
5.3.5 日期类型 127
5.3.6 布尔类型 128
5.4 在SQL*Plus中编写PL/SQL程序 129
5.4.1 PL/SQL程序中的SQL 131
5.4.2 PL/SQL游标 131
5.4.3 游标For循环 133
5.5 PL/SQL中的异常处理 134
5.6 程序中的控制结构 138
5.6.1 程序控制 138
5.6.2 IF逻辑结构 139
5.6.3 CASE语句 141
5.6.4 Loop循环 142
5.6.5 WHILE循环 143
5.6.6 FOR循环 143
5.7 如何创建存储过程以及创建存储过程的原因 146
5.8 函数的创建和使用 149
5.9 调用PL/SQL程序 151
5.10 本章测验 152
第6章 数据库管理员 153
6.1 了解DBA的工作 154
6.2 执行日常操作 154
6.2.1 体系结构和设计 155
6.2.2 容量规划 155
6.2.3 备份和恢复 155
6.2.4 安全 155
6.2.5 性能和调整 155
6.2.6 管理数据库对象 155
6.2.7 存储管理 156
6.2.8 变化管理 156
6.2.9 任务调度 156
6.2.10 网络管理 156
6.2.11 故障排查 156
6.3 Oracle Database 11g的基础结构 157
6.3.1 模式 157
6.3.2 存储结构 159
6.4 Oracle Database 11g的操作模式 160
6.4.1 操作模式 160
6.4.2 数据库和实例关闭 161
6.5 OEM使用初步 162
6.5.1 实例配置 163
6.5.2 用户会话 163
6.5.3 资源消费者组 163
6.5.4 模式、安全和存储管理 164
6.5.5 分布式管理 164
6.5.6 数据仓库特征 164
6.5.7 其他工具 164
6.6 数据库对象管理 165
6.6.1 控制文件 165
6.6.2 重做日志 165
6.6.3 撤消管理 166
6.6.4 模式对象 166
6.7 空间管理 168
6.7.1 归档日志 168
6.7.2 表空间和数据文件 168
6.8 用户管理 170
6.8.1 创建用户 170
6.8.2 编辑用户 171
6.9 数据库用户权限管理 171
6.9.1 授权 172
6.9.2 角色 172
6.9.3 配置文件 173
6.9.4 综述 174
6.10 本章测验 176
第7章 备份与恢复 177
7.1 Oracle备份和恢复基本原理 178
7.1.1 从何处着手 178
7.1.2 备份的体系结构 179
7.1.3 Oracle 二进制文件 179
7.1.4 参数文件 179
7.1.5 控制文件 180
7.1.6 重做日志 180
7.1.7 撤消段 180
7.1.8 检查点 180
7.1.9 归档日志 181
7.1.10 数据文件、表空间、段、分区和块 182
7.1.11 转储文件 183
7.2 Oracle用户管理的备份和恢复 183
7.2.1 用户管理的备份类型 184
7.2.2 冷备份 184
7.2.3 热备份 184
7.2.4 从冷备份中恢复 185
7.2.5 从热备份中恢复 186
7.2.6 恢复的7个步骤 187
7.2.7 用备份控制文件进行恢复 187
7.3 编写数据库备份脚本 188
7.4 备份归档重做日志 189
7.5 Oracle Data Pump简介 190
7.6 使用Oracle Data Pump Export 191
7.7 使用Oracle Data Pump Import 195
7.8 使用传统的导入和导出 200
7.9 Recovery Manager简介 201
7.9.1 RMAN的体系结构 201
7.9.2 设置恢复目录和目标数据库 203
7.9.3 RMAN的关键特性 204
7.9.4 备份 206
7.9.5 在OEM中使用RMAN 207
7.9.6 执行备份 209
7.9.7 还原和恢复 210
7.10 本章测验 213
第8章 高可用性：RAC、ASM和Data Guard 215
8.1 高可用性定义 216
8.2 了解RAC 216
8.3 安装RAC 217
8.4 测试RAC 221
8.4.1 负载平衡管理器 221
8.4.2 ASM 222
8.5 设置ASM实例 222
8.6 创建ASM磁盘组 227
8.7 使用ASMCMD和ASMLIB 228
8.8 把已有数据库转换为ASM 229
8.9 Data Guard简介 231
8.10 Data Guard保护模式 232
8.11 创建物理备用服务器 234
8.12 综述 236
8.13 本章测验 236
第9章 大型数据库特性 239
9.1 超大型数据库定义 240
9.2 使用数据分区的原因和时机 240
9.2.1 使用数据分区的原因 240
9.2.2 实现数据分区 243
9.3 数据压缩 258
9.3.1 数据压缩 258
9.3.2 索引键压缩 259
9.4 使用并行处理改善性能 260
9.4.1 并行处理的数据库组件 261
9.4.2 并行处理的配置 261
9.4.3 激活并行执行 262
9.5 使用物化视图 263
9.5.1 物化视图的用法 263
9.5.2 查询重写 264
9.5.3 何时创建物化视图 265
9.5.4 创建物化视图 265
9.6 使用SQL聚集函数和分析函数 266
9.6.1 聚集函数 266
9.6.2 分析函数 269
9.6.3 其他函数 275
9.7 创建SQL模型 275
9.8 本章测验 279
附录 各章测验答案 281
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 11g初学者指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle编程艺术：深入理解数据库体系结构（第3版）
第1章　开发成功的Oracle应用　　1
1.1　我的方法　　2
1.2　黑盒方法　　3
1.3　开发数据库应用的正确（和不正确）方法　　11
1.3.1　了解Oracle体系结构　　11
1.3.2　理解并发控制　　21
1.3.3　多版本控制　　25
1.3.4　数据库独立性　　31
1.3.5　怎么能让应用运行得更快45
1.3.6　DBA与开发人员的关系　　48
1.4　小结　　48
第2章　体系结构概述　　50
2.1　定义数据库和实例　　51
2.2　连接Oracle　　59
2.2.1　专用服务器　　59
2.2.2　共享服务器　　61
2.2.3　TCP/IP连接的基本原理　　63
2.3　可插拔式数据库　　65
2.3.1　降低资源用量　　66
2.3.2　降低维护开销　　66
2.4　可插拔式数据库的不同之处　　67
2.5　小结　　67
第3章　文件　　68
3.1　参数文件　　69
3.1.1　什么是参数　　70
3.1.2　init.ora参数文件　　73
3.1.3　服务器参数文件　　75
3.2　跟踪文件　　82
3.2.1　计划内的、由用户请求所产生的跟踪文件　　83
3.2.2　针对内部错误生成的跟踪文件　　88
3.2.3　跟踪文件小结　　92
3.3　警告文件　　92
3.4　数据文件　　95
3.4.1　简要回顾文件系统机制　　96
3.4.2　Oracle数据库中的存储层次体系　　97
3.4.3　字典管理和本地管理的表空间　　100
3.5　临时文件　　102
3.6　控制文件　　104
3.7　重做日志文件　　104
3.7.1　在线重做日志　　105
3.7.2　归档重做日志　　107
3.8　密码文件　　108
3.9　修改跟踪文件　　111
3.10　闪回日志　　112
3.10.1　闪回数据库　　112
3.10.2　快速恢复区　　113
3.11　DMP文件（EXP/IMP 文件）　　114
3.12　数据泵文件　　115
3.13　平面文件　　117
3.14　小结　　118
第4章　内存结构　　119
4.1　进程全局区和用户全局区　　120
4.1.1　手动PGA内存管理　　121
4.1.2　自动PGA内存管理　　127
4.1.3　如何选择手动和自动内存管理　　137
4.1.4　PGA和UGA小结　　138
4.2　系统全局区　　138
4.2.1　固定SGA 区　　143
4.2.2　重做缓冲区　　143
4.2.3　块缓冲区缓存　　145
4.2.4　共享池　　151
4.2.5　大池　　153
4.2.6　Java池　　154
4.2.7　流池　　155
4.2.8　SGA内存管理　　155
4.3　小结　　160
第5章　Oracle 进程　　161
5.1　服务器进程　　161
5.1.1　专用服务器连接　　162
5.1.2　共享服务器连接　　164
5.1.3　数据库常驻连接池　　165
5.1.4　连接与会话　　165
5.1.5　专用服务器、共享服务器和数据库常驻连接池　　170
5.1.6　专用/共享服务器小结　　173
5.2　后台进程　　174
5.2.1　特定任务后台进程　　175
5.2.2　工具后台进程　　185
5.3　从属进程　　188
5.3.1　I/O从属进程　　188
5.3.2　Pnnn：并行查询执行服务器　　189
5.4　小结　　189
第6章　锁和闩　　190
6.1　什么是锁　　190
6.2　锁的问题　　193
6.2.1　丢失更新　　193
6.2.2　悲观锁　　194
6.2.3　乐观锁　　195
6.2.4　乐观锁还是悲观锁　　201
6.2.5　阻塞　　202
6.2.6　死锁　　205
6.2.7　锁升级　　209
6.3　锁类型　　209
6.3.1　DML锁　　210
6.3.2　DDL锁　　219
6.3.3　闩　　223
6.3.4　互斥锁　　231
6.3.5　手动锁定和用户定义锁　　232
6.4　小结　　233
第7章　并发与多版本控制　　234
7.1　什么是并发控制　　234
7.2　事务隔离级别　　235
7.2.1　READ UNCOMMITTED　　236
7.2.2　READ COMMITTED　　238
7.2.3　REPEATABLE READ　　239
7.2.4　SERIALIZABLE　　241
7.2.5　READ ONLY　　243
7.3　多版本读一致性的含义　　244
7.3.1　数据仓库中一种常见但有问题的方法　　244
7.3.2　解释热表上超出期望的I/O　　245
7.4　写一致性　　247
7.4.1　一致读和当前读　　248
7.4.2　查看重启动　　250
7.4.3　为什么重启动对我们很重要　　252
7.5　小结　　253
第8章　事务　　255
8.1　事务控制语句　　255
8.2　原子性　　257
8.2.1　语句级原子性　　257
8.2.2　过程级原子性　　259
8.2.3　事务级原子性　　262
8.2.4　DDL与原子性　　262
8.3　持久性　　263
8.3.1　COMMIT的WRITE扩展　　263
8.3.2　非分布式PL/SQL代码块中的COMMIT　　264
8.4　完整性约束和事务　　266
8.4.1　IMMEDIATE约束　　266
8.4.2　DEFERRABLE约束和级联更新　　266
8.5　不好的事务习惯　　270
8.5.1　在循环中提交　　270
8.5.2　使用自动提交　　276
8.6　分布式事务　　277
8.7　自治事务　　278
8.7.1　自治事务如何工作　　279
8.7.2　何时使用自治事务　　280
8.8　小结　　283
第9章　redo与undo　　284
9.1　什么是redo　　285
9.2　什么是undo　　286
9.3　redo和undo如何协作　　289
9.4　提交和回滚处理　　293
9.4.1　COMMIT做什么　　293
9.4.2　ROLLBACK做什么　　299
9.5　分析redo　　300
9.5.1　测量redo　　301
9.5.2　能关掉重做日志的生成吗　　302
9.5.3　为什么我拿不到日志空间　　305
9.5.4　块清除　　307
9.5.5　日志竞争　　310
9.5.6　临时表和redo/undo　　312
9.6　分析undo　　317
9.6.1　什么操作会生成最多和最少的undo　　317
9.6.2　ORA-01555: snapshot too old错误　　319
9.7　小结　　328
第10章　数据库表　　329
10.1　表类型　　329
10.2　术语　　331
10.2.1　段　　331
10.2.2　段空间管理　　333
10.2.3　高水位线　　334
10.2.4　FREELIST　　336
10.2.5　PCTFREE和PCTUSED　　339
10.2.6　LOGGING和NOLOGGING　　342
10.2.7　INITRANS和MAXTRANS　　343
10.3　堆组织表　　343
10.4　索引组织表　　346
10.5　索引聚簇表　　359
10.6　散列聚簇表　　366
10.7　有序散列聚簇表　　375
10.8　嵌套表　　377
10.8.1　嵌套表语法　　378
10.8.2　嵌套表存储　　384
10.8.3　嵌套表小结　　387
10.9　临时表　　387
10.9.1　12c之前的统计信息　　391
10.9.2　12c之后的统计信息　　395
10.9.3　临时表小结　　398
10.10　对象表　　399
10.11　小结　　405
第11章　索引　　406
11.1　Oracle索引概述　　406
11.2　B*Tree索引　　408
11.2.1　索引键压缩　　411
11.2.2　反向键索引　　413
11.2.3　降序索引　　418
11.2.4　什么情况下应该使用B*Tree索引　　420
11.2.5　B*Tree小结　　430
11.3　位图索引　　430
11.3.1　什么情况下应该使用位图索引　　431
11.3.2　位图联结索引　　435
11.3.3　位图索引小结　　437
11.4　基于函数的索引　　438
11.4.1　一个简单的例子　　438
11.4.2　只对部分行建立索引　　446
11.4.3　实现有选择的唯一性　　448
11.4.4　关于ORA-01743的警告　　448
11.4.5　基于函数的索引小结　　449
11.5　应用域索引　　450
11.6　不可见的索引　　451
11.7　同列上的多个索引　　452
11.8　在扩展列上使用索引　　453
11.8.1　使用虚拟列的方法　　454
11.8.2　使用基于函数索引的方法　　456
11.9　关于索引的常见问题和各种传言　　457
11.9.1　视图能使用索引吗　　457
11.9.2　Null和索引能协作吗　　457
11.9.3　外键是否应该加索引　　460
11.9.4　为什么没有使用我的索引　　461
11.9.5　传言：索引中从不重用空间　　466
11.9.6　传言：最有差别的元素应该在最前面　　469
11.10　小结　　472
第12章　数据类型　　473
12.1　Oracle数据类型概述　　473
12.2　字符和二进制串类型　　475
12.2.1　NLS概述　　476
12.2.2　字符串　　479
12.3　二进制串：RAW类型　　485
12.4　扩展的数据类型　　487
12.5　数值类型　　489
12.5.1　NUMBER类型的语法和用法　　491
12.5.2　BINARY_FLOAT/BINARY_DOUBLE类型的语法和用法　　494
12.5.3　非固有数值类型　　495
12.5.4　性能考虑　　495
12.6　LONG类型　　497
12.6.1　LONG 和LONG RAW类型的限制　　497
12.6.2　处理遗留的LONG类型　　498
12.7　DATE、TIMESTAMP和INTERVAL类型　　502
12.7.1　格式　　503
12.7.2　DATE类型　　504
12.7.3　TIMESTAMP类型　　509
12.7.4　INTERVAL类型　　515
12.8　LOB类型　　518
12.8.1　内部LOB　　518
12.8.2　BFILE　　531
12.9　ROWID/UROWID类型　　533
12.10　小结　　533
第13章　分区　　535
13.1　分区概述　　535
13.1.1　提高可用性　　536
13.1.2　减少管理负担　　538
13.1.3　增强语句性能　　541
13.2　表分区机制　　543
13.2.1　区间分区　　544
13.2.2　散列分区　　546
13.2.3　列表分区　　550
13.2.4　间隔分区　　552
13.2.5　引用分区　　557
13.2.6　间隔引用分区　　561
13.2.7　虚拟列分区　　563
13.2.8　组合分区　　564
13.2.9　行移动　　566
13.2.10　表分区机制小结　　568
13.3　索引分区　　569
13.3.1　本地索引与全局索引　　570
13.3.2　本地索引　　570
13.3.3　全局索引　　575
13.4　再论分区和性能　　590
13.5　一些简化维护的特性　　595
13.5.1　多分区管理操作　　595
13.5.2　级联截断　　597
13.5.3　级联交换　　599
13.6　审计和段空间压缩　　600
13.7　小结　　601
第14章　并行执行　　603
14.1　何时使用并行执行　　604
14.2　Oracle Exadata　　606
14.3　并行查询　　606
14.4　并行DML　　612
14.5　并行DDL　　615
14.5.1　并行DDL和使用外部表的数据加载　　616
14.5.2　并行DDL和扩展截断　　617
14.6　过程并行化　　625
14.6.1　并行管道函数　　626
14.6.2　DIY并行化　　629
14.6.3　老式DIY并行化　　632
14.7　小结　　635
第15章　数据加载和卸载　　637
15.1　外部表　　637
15.1.1　建立外部表　　638
15.1.2　处理错误　　645
15.1.3　使用外部表加载不同的文件　　648
15.1.4　多用户问题　　649
15.1.5　预处理　　650
15.1.6　外部表总结　　658
15.2　数据泵卸载　　659
15.3　SQLLDR　　660
15.3.1　用SQLLDR加载数据的常见问题　　664
15.3.2　SQLLDR警告　　686
15.3.3　SQLLDR小结　　686
15.4　平面文件卸载　　687
15.5　小结　　694
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle编程艺术：深入理解数据库体系结构（第3版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle DBA手记2
Part 1  DBA之路
0  天道酬勤——从头细数来时路   003
Part 2  DBA手记
1   Eygle的DBA工作手记   017
承前启后——Failed Login Count带来的性能问题
OEM罪几何？—— 空间监控的性能问题
Grid Control的必要监控——进程累积导致的宕机
DBA诊断利器——Event 10046和 10053
ORA-00600 kcratr1_lostwrt之解决与原理分析
ORA-00600 kcratr_nab_less_than_odr案例一则
Cache-Low RBA与On-Disk RBA的恢复证明
定时任务带来的问题 —— auto_space_advisor_job_proc
定时任务GATHER_STATS_JOB与SQL执行
GATHER_STATS_JOB跨月的“BUG”
执行计划的cardinality (rows)评估
X$KTUXE与Oracle的死事务恢复
2  崔华的DBA工作手记   057
利用AWR报告的诊断案例一
利用AWR报告的诊断案例二
利用AWR报告的诊断案例三
一次逻辑读异常的诊断过程
3  电信运营商DBA工作手记   073
电信运营商数据库特点
电信运营商数据库维护原则及维护禁区
典型案例
小结
4  航空业DBA工作手记   091
SYS用户通过TNS连接出现ORA-01031异常
撤销用户访问ALL_USERS权限
Oracle 11g查看package导致ORA-03137错误的解决过程
使用SQL Profiles影响已经加入hints的SQL执行计划
使用SQL Plan Baselines影响已加入hints的SQL执行计划
探究Oracle的列长度统计
Part 3  开发基础
5  深入解析回滚段   107
回滚段基础知识
细看回滚段
回滚段的使用
Seq（序列值）、Wrap（环绕）和Extend（扩展）
回滚和提交
自己动手构造CR块
6  Connect by可以做什么？   133
Connect by是什么？
Connect by可以做什么？
小结
第四篇  诊断案例
7   DBA小故事之SQL诊断   149
困惑迷案
疑云重重
无所适从
峰回路转
大白天下
乘胜追击
余音绕梁
8  System State 转储分析案例一则   161
状态转储的常用命令
WAITED TOO LONG FOR A ROW CACHE
ENQUEUE LOCK!案例
DUMP转储文件分析定位问题
ROW CACHE对象的定位
使用ass109.awk脚本辅助分析
AWR报告的辅助诊断
状态转储的常用命令
9  Ora-600 错误深入探究案例两则   173
BBED的介绍与常用用法
如何解决ora-600[4000]错误
解决system回滚段损坏导致的ora-600[4193]错误
10  Eygle的数据恢复手记   201
备份恢复与数据字典检查
遭遇ORA-00600 25013 / 25015错误
来龙去脉——表空间创建
Drop Tablespace Internal
ORA-600 4348错误的成因
一致性损坏的显示错误
实际的处理过程
字典检查何时发生？
11  深入解析 DEPENDENCY$对象的恢复   235
重现Move表失效索引的故障
故障的解决思路
获得字典表信息
Index Cluster Internal
Oracle Update Internal
尝试恢复操作
手工的DDL维护工作
数据字典不一致问题的解决
参考文献   281
索引   282
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle DBA手记2
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle查询优化改写技巧与案例
第1章单表查询	1
1.1  查询表中所有的行与列	1
1.2  从表中检索部分行	2
1.3  查找空值	3
1.4  将空值转换为实际值	4
1.5  查找满足多个条件的行	5
1.6  从表中检索部分列	6
1.7  为列取有意义的名称	6
1.8  在WHERE子句中引用取别名的列	7
1.9  拼接列	7
1.10  在SELECT语句中使用条件逻辑	8
1.11  限制返回的行数	10
1.12  从表中随机返回n条记录	10
1.13  模糊查询	12
第2章给查询结果排序	14
2.1  以指定的次序返回查询结果	14
2.2  按多个字段排序	16
2.3  按子串排序	16
2.4  TRANSLATE	17
2.5  按数字和字母混合字符串中的字母排序	19
2.6  处理排序空值	20
2.7  根据条件取不同列中的值来排序	21
第3章操作多个表	23
3.1  UNION ALL与空字符串	23
3.2  UNION与OR	24
3.3  组合相关的行	31
3.4  IN、EXISTS和INNER JOIN	31
3.5  INNER JOIN、LEFT JOIN、RIGHT JOIN和FULL JOIN解析	34
3.6  自关联	37
3.7  NOT IN、NOT EXISTS和LEFT JOIN	38
3.8  外连接中的条件不要乱放	41
3.9  检测两个表中的数据及对应数据的条数是否相同	45
3.10  聚集与内连接	46
3.11  聚集与外连接	50
3.12  从多个表中返回丢失的数据	50
3.13  多表查询时的空值处理	53
第4章插入、更新与删除	55
4.1  插入新记录	55
4.2  阻止对某几列插入	56
4.3  复制表的定义及数据	57
4.4  用WITH CHECK OPTION限制数据录入	57
4.5  多表插入语句	58
4.6  用其他表中的值更新	62
4.7  合并记录	67
4.8  删除违反参照完整性的记录	70
4.9  删除名称重复的记录	71
第5章使用字符串	74
5.1  遍历字符串	74
5.2  字符串文字中包含引号	76
5.3  计算字符在字符串中出现的次数	77
5.4  从字符串中删除不需要的字符	78
5.5  将字符和数字数据分离	79
5.6  查询只包含字母或数字型的数据	80
5.7  提取姓名的大写首字母缩写	85
5.8按字符串中的数值排序	87
5.9根据表中的行创建一个分隔列表	88
5.10提取第n个分隔的子串	88
5.11分解IP地址	90
5.12将分隔数据转换为多值IN列表	90
5.13按字母顺序排列字符串	91
5.14判别可作为数值的字符串	94
第6章使用数字	100
6.1  常用聚集函数	100
6.2  生成累计和	102
6.3  计算累计差	106
6.4  更改累计和的值	108
6.5  返回各部门工资排名前三位的员工	110
6.6  计算出现次数最多的值	111
6.7  返回最值所在行数据	113
6.8  first_value	116
6.9  求总和的百分比	119
第7章日期运算	122
7.1  加减日、月、年	122
7.2  加减时、分、秒	123
7.3  日期间隔之时、分、秒	124
7.4  日期间隔之日、月、年	124
7.5  确定两个日期之间的工作天数	124
7.6  计算一年中周内各日期的次数	127
7.7  确定当前记录和下一条记录之间相差的天数	129
第8章日期操作	131
8.1  SYSDATE能得到的信息	131
8.2  INTERVAL	134
8.3  EXTRACT	135
8.4  确定一年是否为闰年	137
8.5  周的计算	138
8.6  确定一年内属于周内某一天的所有日期	139
8.7  确定某月内第一个和最后一个“周内某天”的日期	140
8.8  创建本月日历	141
8.9  全年日历	142
8.10  确定指定年份季度的开始日期和结束日期	145
8.11  补充范围内丢失的值	145
8.12  按照给定的时间单位进行查找	147
8.13  使用日期的特殊部分比较记录	148
8.14  识别重叠的日期范围	149
8.15  按指定间隔汇总数据	152
第9章范围处理	155
9.1  定位连续值的范围	155
9.2  查找同一组或分区中行之间的差	157
9.3  定位连续值范围的开始点和结束点	159
9.4  合并时间段	164
第10章高级查找	168
10.1  给结果集分页	168
10.2  重新生成房间号	170
10.3  跳过表中n行	173
10.4  排列组合去重	174
10.5  找到包含最大值和最小值的记录	176
第11章报表和数据仓库运算	179
11.1  行转列	179
11.2  列转行	184
11.3  将结果集反向转置为一列	188
11.4  抑制结果集中的重复值	190
11.5  利用“行转列”进行计算	191
11.6  给数据分组	192
11.7  对数据分组	195
11.8  计算简单的小计	195
11.9  判别非小计的行	198
11.10  计算所有表达式组合的小计	201
11.11  人员在工作间的分布	203
11.12  创建稀疏矩阵	204
11.13  对不同组/分区同时实现聚集	208
11.14  对移动范围的值进行聚集	209
11.15  常用分析函数开窗讲解	212
11.16  listagg与小九九	215
第12章分层查询	217
12.1  简单的树形查询	217
12.2  根节点、分支节点、叶子节点	218
12.3  sys_connect_by_path	219
12.4树形查询中的排序	220
12.5树形查询中的WHERE	221
12.6查询树形的一个分支	222
12.7剪去一个分支	223
12.8字段内list值去重	224
第13章应用案例实现	227
13.1  从不固定位置提取字符串的元素	227
13.2  搜索字母数字混合的字符串	230
13.3  把结果分级并转为列	230
13.4  构建基础数据的重要性	234
13.5  根据传入条件返回不同列中的数据	235
13.6  拆分字符串进行连接	237
13.7  整理垃圾数据	238
13.8  用“行转列”来得到隐含信息	243
13.9  用隐藏数据进行行转列	245
13.10  用正则表达式提取clob里的文本格式记录集	247
第14章改写调优案例分享	249
14.1  为什么不建议使用标量子查询	249
14.2  用LEFT JOIN优化标量子查询	252
14.3  用LEFT JOIN优化标量子查询之聚合改写	252
14.4  用LEFT JOIN及行转列优化标量子查询	255
14.5  标量中有ROWNUM =1	257
14.6  不等连接的标量子查询改写（一）	259
14.7  不等连接的标量子查询改写（二）	262
14.8  标量子查询与改写逻辑的一致性	267
14.9  用分析函数优化标量子查询（一）	269
14.10  用分析函数优化标量子查询（二）	271
14.11  用分析函数优化标量子查询（三）	274
14.12  用分析函数优化标量子查询（四）	277
14.13  用MERGE改写优化UPDATE	281
14.14  用MERGE改写有聚合操作的UPDATE（一）	283
14.15  用MERGE改写有聚合操作的UPDATE（二）	286
14.16  用MERGE改写UPDATE之多个子查询（一）	287
14.17  用MERGE改写UPDATE之多个子查询（二）	288
14.18  UPDATE改写为MERGE时遇到的问题	291
14.19  整理优化分页语句	294
14.20  让分页语句走正确的PLAN	296
14.21  去掉分页查询中的DISTINCT	297
14.22  用WITH语句减少自关联	300
14.23  用WITH改写优化查询	303
14.24  用WITH把OR改为UNION	308
14.25  错误的WITH改写	312
14.26  错误的分析函数用法	315
14.27  用LEFT JOIN优化多个子查询（一）	317
14.28  用LEFT JOIN优化多个子查询（二）	320
14.29  用LEFT JOIN优化多个子查询（三）	322
14.30  去掉EXISTS引起的FILTER	324
14.31  重叠时间计数	325
14.32  用分析函数改写优化	328
14.33  相等集合之零件供应商	334
14.34  相等集合之飞机棚与飞行员	335
14.35  用分析函数改写最值过滤条件	338
14.36  用树形查询找指定级别的数据	339
14.37  行转列与列转行	340
14.38  UPDATE、ROW_NUMBER与MERGE	343
14.39  改写优化UPDATE语句	345
14.40  改写优化UNION ALL语句	347
14.41  纠结的MERGE语句	349
14.42  用CASE WHEN去掉UNION ALL	351
14.43  不恰当的WITH及标量子查询	364
14.44  用分析函数加“行转列”来优化标量子查询	366
14.45  用分析函数处理问题	369
14.46  用列转行改写A表多列关联B表同列	372
14.47  用分析函数改写最值语句	375
14.48  多列关联的半连接与索引	377
14.49  巧用分析函数优化自关联	378
14.50  纠结的UPDATE语句	383
14.51  巧用JOIN条件合并UNION ALL语句	385
14.52  用分析函数去掉NOT IN	388
14.53  读懂查询中的需求之裁剪语句	392
14.54  去掉FILTER里的EXISTS之活学活用	393
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle查询优化改写技巧与案例
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle精髓
前言
第1章 认识Oracle数据库
关系型数据库的发展
Oracle数据库家族
Oracle特性概述
数据库应用程序开发特性
数据库连接特性
分布式数据库特性
数据移动特性
数据库性能特性
数据库管理特性
数据库安全特性
Oracle开发工具
嵌入式数据库
第2章 Oracle数据库体系结构
数据库与实例
部署物理组件
实例包含的内存和进程
数据库字典
第3章 安装和运行Oracle数据库
安装Oracle数据库
创建数据库
配置OracleNet
启动数据库
关闭数据库
访问数据库
Oracle的运行
第4章 Oracle数据库数据结构
数据类型
基本数据结构
其他数据结构
数据的扩展逻辑
数据设计
约束
触发器
查询优化
理解执行计划
SQL顾问工具
数据字典表
第5章 管理Oracle数据库
易管理特性
Oracle企业管理器
碎片和重组
备份和恢复
与Oracle支持人员协同工作
第6章 Oracle数据库的安全、审计和依从性
安全
审计
依从性
第7章 Oracle数据库性能
性能调优基础知识
Oracle与磁盘I／O资源
Oracle与并行性
Oracle与内存资源
Oracle与CPU资源
数据库资源管理器
第8章 Oracle多用户并发访问
并发访问的基础知识
Oracle与并发用户访问
Oracle的隔离级别
Oracle的并发特性
Oracle如何处理锁
并发访问与性能
工作空间
第9章 Oracle和事务处理
OLTP基础知识
OracleOLTP的继承性
OLTP体系结构
OracleOLTP特性
高可用性
Oracle流和高级队列
对象技术与分布式组件
第10章 Oralce数据仓库和商业智能
商业智能的基础知识
数据仓库的设计
查询优化
数据库的分析、OLTP和数据挖掘
管理数据仓库
其他数据仓库软件
元数据的挑战
最佳实践
第11章 Oracle和高可用性
什么是高可用性
系统故障
防止系统故障
故障恢复
完全站点故障
数据冗余解决方案
滚动升级
第12章 Oracle和硬件体系结构
系统基础
单处理器系统
对称多处理系统一
集群
非一致内存访问系统
网格计算
磁盘和存储技术
选择哪种平台部署方案
第13章 Oracle分布式数据库和数据分布
把多个数据库作为单个实体来访问
在分布式系统问迁移数据
第14章 OracIe扩展数据类型
面向对象的开发
可扩展特性和选项
使用Oracle可扩展框架
第15章 Oracle数据库之外的内容
应用程序快速浏览
OracleFusion中间件
OracleSOA套件
附录A 本书中有关Oracle数据库11g的新内容
附录B 附加资源
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle精髓
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle DBA手记4
《oracle dba手记4：数据安全警示录》
靡不有初，鲜克有终 1
以空间之由——误操作删除数据文件恢复案例两则 3
灾难描述 3
案例警示 4
技术回放 5
恢复过程——通过文件描述符进行数据恢复 7
技术难点 21
通过bbed获取文件号信息 21
通过od命令获得文件号信息 24
以拯救之因——强制恢复导致ora-600 4000错误案例 29
灾难描述 29
案例警示 30
技术回放 31
恢复过程 35
ora-600 4000错误揭秘 36
通过_minimum_giga_scn消除scn异常 41
ora-600 4194错误undo故障消除 45
以优化之名——存储优化导致表空间误删除案例 49
灾难描述 49
.案例警示 50
技术回放 51
以安全之期 57
validate实现备份验证 57
数据库备份加密 60
口令模式 61
透明模式 63
混合模式 66
透明加密（tde）技术 66
合抱之木，起于毫末 73
oracle数据库软件发布序列 75
一个逻辑坏块引发的灾难 79
案例警示 79
技术回放 80
一个硬盘坏块引发的灾难 81
灾难描述 81
案例警示 81
技术回放 83
aix系统odm简介 83
asm头块备份机制 84
kfed工具编译与使用 87
手工修复asm案例一则 91
灾难描述 91
技术回放 91
provisioned磁盘状态分析 92
使用kfed修改asm磁盘头信息 94
asm数据抽取恢复——通过amdu恢复数据案例一则 101
灾难描述 101
案例警示 101
技术回放 102
amdu工具 102
文件分析 105
amdu文件恢复 106
未雨绸缪，防患未然 109
dba四大守则 111
dba守则外两则 113
各种惨痛的案例 117
系统级误删除案例 117
数据库误删除案例 122
通过触发器实现ddl监控 123
主备环境错误案例 132
业务高峰误操作案例 136
备份级误操作案例 139
进程级别误操作案例 142
数据文件误操作案例 143
误关闭生产库案例 145
系统存储级误删除案例 148
亡羊补牢，未为迟也 151
数据篡改案例解析 153
案例描述 153
案例警示 153
技术回放 154
故障分析的过程 155
日志文件的转储 157
logmnr解析 162
案例之深入解析 164
技术难点 176
密码安全与加密 185
明察秋毫，见微知著 207
一次碰撞引发的灾难——asm保护式文件离线引发故障 209
灾难描述 209
案例警示 209
技术回放 210
恢复过程 214
又一次碰撞引发的灾难——文件离线与归档缺失案例 217
灾难描述 217
案例警示 217
技术回放 219
恢复过程 224
空间与文件离线——离线表空间加载修复 239
灾难描述 239
案例警示 239
技术回放 240
恢复过程 248
技术提示 254
关于归档空间的设置 254
关于检查点的一致性调整 258
心存目想，三思后行 265
truncate导致的灾难——核心字典表误操作truncate 267
灾难描述 267
案例警示 267
技术回放 268
恢复过程 274
脚本错误导致的灾难——数据库整体被删除故障 281
灾难描述 281
案例警示 281
技术回放 282
恢复过程 283
千里之堤，溃于蚁穴 291
一个字符引发的灾难——大小写字符疏忽导致的维护故障 293
灾难描述 293
案例警示 293
案情解析 294
技术回放 302
一个盘符引发的灾难——判断失误导致的误格式化故障 315
灾难描述 315
案例警示 315
技术回放 316
物尽其用，人尽其才 319
关库与关机——强制关机导致的写丢失故障 321
灾难描述 321
案例警示 321
恢复过程 322
技术提示 351
从小恙到灾难——重建控制文件失误导致的故障 353
灾难描述 353
案例警示 353
技术回放 354
尺有所短，物有不足——硬件故障导致的灾难一则 365
灾难描述 365
案例警示 365
技术回放 366
附录一 bbed的说明 369
附录二函数f_get_from_dump 372
参考资料 377
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle DBA手记4
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>OCA认证考试指南(1Z0-061)Oracle Database 12c SQL 基础
目    录
第1章  使用Oracle设计关系数据库	1
1.1  定位服务器技术	2
1.1.1  Oracle服务器的体系结构	3
1.1.2  Oracle WebLogic Server	4
1.1.3  Oracle Enterprise Manager	5
1.1.4  云计算	6
1.1.5  开发工具和语言	6
1.2  理解关系结构	7
1.2.1  真实的案例	7
1.2.2  数据建模	8
1.2.3  实体和关系	8
1.2.4  行和表	15
1.3  SQL语言概述	18
1.3.1  SQL标准	18
1.3.2  SQL命令	18
1.3.3  面向集合的语言	19
1.4  使用客户工具	19
1.4.1  SQL*Plus	20
1.4.2  SQL Developer	24
1.5  创建演示模式	28
1.5.1  用户和模式	28
1.5.2  HR和OE模式	29
1.5.3  创建演示模式	31
1.6  认证小结	32
1.7  本章知识点回顾	33
1.8  本章测试题	33
1.8.1  自测题	33
1.8.2  实验题	35
1.8.3  自测题答案	35
1.8.4  实验题答案	37
第2章  使用SQL SELECT语句检索数据	39
2.1  列出SQL SELECT语句的功能	40
2.1.1  SQL SELECT语句介绍	40
2.1.2  DESCRIBE表命令	40
2.1.3  SELECT语句的功能	44
2.2  执行基本的SELECT语句	44
2.2.1  基本的SELECT语句	45
2.2.2  必须遵守的规则	48
2.2.3  SQL表达式和运算符	52
2.2.4  空值的概念	61
2.3  认证小结	66
2.4  本章知识点回顾	66
2.5  本章测试题	67
2.5.1  自测题	67
2.5.2  实验题	69
2.5.3  自测题答案	70
2.5.4  实验题答案	71
第3章  限定和排序数据	75
3.1  限制查询检索的行	76
3.1.1  WHERE子句	76
3.1.2  比较运算符	82
3.1.3  布尔运算符	92
3.1.4  优先规则	97
3.2  排序查询所检索的行	100
3.3  和符号(&)替换	105
3.3.1  替换变量	105
3.3.2  定义和验证	110
3.4  认证小结	115
3.5  本章知识点回顾	115
3.6  本章测试题	116
3.6.1  自测题	116
3.6.2  实验题	118
3.6.3  自测题答案	118
3.6.4  实验题答案	119
第4章  单行函数	121
4.1  描述SQL中可用的不同类型的函数	122
4.1.1  定义函数	122
4.1.2  函数类型	124
4.2  在SELECT语句中使用字符、数字和日期函数	126
4.2.1  使用字符大小写转换函数	126
4.2.2  使用字符操作函数	131
4.2.3  使用数字函数	140
4.2.4  使用日期	144
4.2.5  使用日期函数	147
4.3  认证小结	155
4.4  本章知识点回顾	155
4.5  本章测试题	156
4.5.1  自测题	156
4.5.2  实验题	157
4.5.3  自测题答案	157
4.5.4  实验题答案	158
第5章  使用转换函数和条件表达式	161
5.1  SQL中可用的各种类型的转换函数介绍	162
5.2  使用TO_CHAR、TO_NUMBER和TO_DATE转换函数	164
5.3  在SELECT语句中应用条件表达式	174
5.3.1  嵌套函数	174
5.3.2  一般函数	175
5.3.3  条件函数	181
5.4  认证小结	186
5.5  本章知识点回顾	187
5.6  本章测试题	188
5.6.1  自测题	188
5.6.2  实验题	190
5.6.3  自测题答案	190
5.6.4  实验题答案	191
第6章  使用分组函数报告聚合数据	193
6.1  分组函数介绍	194
6.1.1  分组函数的定义	194
6.1.2  分组函数的类型和语法	195
6.2  确定可用的分组函数	197
6.2.1  使用分组函数	197
6.2.2  嵌套的分组函数	202
6.3  使用GROUP BY子句分组数据	203
6.3.1  创建数据组	204
6.3.2  GROUP BY子句	205
6.3.3  按多列分组	206
6.4  使用HAVING子句包含或者排除分组行	209
6.4.1  限制分组结果	209
6.4.2  HAVING子句	210
6.5  认证小结	213
6.6  本章知识点回顾	213
6.7  本章测试题	214
6.7.1  自测题	214
6.7.2  实验题	216
6.7.3  自测题答案	216
6.7.4  实验题答案	218
第7章  显示多个表中的数据	219
7.1  使用同等连接和非同等连接编写SELECT语句访问多个表的数据	220
7.1.1  连接的类型	220
7.1.2  使用ANSI SQL语法连接表	224
7.1.3  限定模糊的列名	225
7.1.4  NATURAL JOIN子句	226
7.1.5  JOIN USING子句	229
7.1.6  JOIN ON子句	230
7.1.7  N路连接和其他连接条件	232
7.1.8  非同等连接	234
7.2  使用自连接将表连接到自身	235
7.3  使用外连接查看不满足连接条件的数据	238
7.3.1  内连接和外连接	238
7.3.2  左外连接	238
7.3.3  右外连接	240
7.3.4  全外连接	241
7.4  生成两个或多个表的笛卡尔乘积	243
7.5  认证小结	246
7.6  本章知识点回顾	246
7.7  本章测试题	247
7.7.1  自测题	247
7.7.2  实验题	250
7.7.3  自测题答案	250
7.7.4  实验题答案	251
第8章  使用子查询解决问题	253
8.1  定义子查询	254
8.2  描述子查询能够解决的问题的类型	256
8.2.1  将子查询的结果集用于比较	256
8.2.2  星型转换	257
8.2.3  生成执行SELECT语句的表	259
8.2.4  生成投影值	259
8.2.5  生成传递给DML语句的行	259
8.3  列举子查询的类型	261
8.3.1  单行和多行子查询	261
8.3.2  关联子查询	262
8.4  编写单行和多行子查询	265
8.5  认证小结	269
8.6  本章知识点回顾	269
8.7  本章测试题	269
8.7.1  自测题	269
8.7.2  实验题	273
8.7.3  自测题答案	273
8.7.4  实验题答案	274
第9章  使用集合运算符	277
9.1  描述集合运算符	278
9.1.1  集合和维恩图	278
9.1.2  集合运算符的一般原则	279
9.2  使用集合运算符将多个查询合并为一个查询	281
9.2.1  UNION ALL运算符	281
9.2.2  UNION运算符	282
9.2.3  INTERSECT运算符	283
9.2.4  MINUS运算符	284
9.2.5  更复杂的示例	284
9.3  控制返回行的顺序	288
9.4  认证小结	291
9.5  本章知识点回顾	291
9.6  本章测试题	291
9.6.1  自测题	291
9.6.2  实验题	293
9.6.3  自测题答案	294
9.6.4  实验题答案	294
第10章  操作数据	297
10.1  描述各种DML语句	298
10.1.1  INSERT	298
10.1.2  UPDATE	299
10.1.3  DELETE	300
10.1.4  MERGE	300
10.1.5  TRUNCATE	301
10.1.6  DML语句失败	301
10.2  在表中插入行	304
10.3  更新表中的行	310
10.4  从表中删除行	313
10.4.1  使用DELETE删除行	313
10.4.2  使用TRUNCATE删除行	316
10.4.3  MERGE	316
10.5  控制事务	317
10.5.1  数据库事务	317
10.5.2  事务控制语句	320
10.6  认证小结	325
10.7  本章知识点回顾	325
10.8  本章测试题	326
10.8.1  自测题	326
10.8.2  实验题	329
10.8.3  自测题答案	330
10.8.4  实验题答案	331
第11章  使用DDL语句创建和管理表	333
11.1  分类主要的数据库对象	334
11.1.1  对象类型	334
11.1.2  用户和模式	336
11.1.3  命名模式对象	336
11.1.4  对象名称空间	337
11.2  回顾表结构	338
11.3  列举列可用的数据类型	339
11.4  创建简单的表	343
11.4.1  使用列规范创建表	343
11.4.2  从子查询创建表	344
11.4.3  在创建表后变更表定义	345
11.4.4  删除和截断表	346
11.5  讨论在创建表时如何创建约束	348
11.5.1  约束的类型	349
11.5.2  定义约束	351
11.6  认证小结	354
11.7  本章知识点回顾	354
11.8  本章测试题	355
11.8.1  自测题	355
11.8.2  实验题	357
11.8.3  自测题答案	357
11.8.4  实验题答案	358
术语表	361
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>OCA认证考试指南(1Z0-061)Oracle Database 12c SQL 基础
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Data Guard 11g完全参考手册
第1章  Data Guard架构	1
1.1  Data Guard概述	2
1.2  重做传输服务	4
1.2.1  同步重做传输	5
1.2.2  异步重做传输	6
1.2.3  重做传输压缩	8
1.2.4  自动处理间隔	8
1.3  应用服务	9
1.3.1  Redo Apply	10
1.3.2  SQL Apply	13
1.3.3  在难以取舍的情况下
同时使用二者	15
1.4  Data Guard保护模式	15
1.4.1  最高性能	16
1.4.2  最高可用性	16
1.4.3  最大保护	17
1.5  角色管理服务	17
1.5.1  切换	18
1.5.2  故障转移	19
1.6  Data Guard管理	22
1.7  活动的备用数据库	23
1.7.1  卸载只读查询和报表	23
1.7.2  卸载备份	24
1.7.3  测试	24
1.8  Data Guard和最高可用性
架构	25
1.9  小结	26
第2章  实现Oracle Data Guard	27
2.1  实现前的计划	28
2.1.1  确定需求	28
2.1.2  理解配置选项	31
2.1.3  将RPO和RTO与保护
模式联系起来	56
2.2  创建物理备用数据库	56
2.2.1  选择界面	56
2.2.2  准备工作	58
2.2.3  使用Oracle Enterprise
Manager Grid Control	59
2.2.4  高级用户方法	69
2.3  创建逻辑备用数据库	89
2.4  Data Guard和Oracle RAC	96
2.5  小结	97
第3章  重做处理	99
3.1  Oracle恢复的重要概念	100
3.1.1  ACID属性	100
3.1.2  Oracle恢复	101
3.1.3  事务生命周期	102
3.1.4  无日志操作	103
3.2  物理备用的组件	105
3.2.1  实时应用	108
3.2.2  缩放和调整Data Guard
应用恢复	109
3.2.3  并行介质恢复	110
3.2.4  监控物理备用恢复的
工具和视图	111
3.3  检测物理备用损坏	115
3.3.1  11g中数据保护的
新变化	115
3.3.2  物理备用上的数据保护
和检查	116
3.4  小结	117
第4章  逻辑备用	119
4.1  描述逻辑备用数据库中
可用的数据集	120
4.1.1  描述从主数据库复制的
数据集	120
4.1.2  保护逻辑备用上的
复制表	125
4.1.3  自定义逻辑备用数据库
(或在逻辑备用创建本地
数据集)	131
4.1.4  了解逻辑备用数据库的
运行情况	135
4.1.5  剖析SQL Apply	135
4.2  调整SQL Apply	146
4.2.1  一些经验法则	146
4.2.2  确定SQL Apply是否
滞后	147
4.2.3  确定SQL Apply是否
是瓶颈	147
4.2.4  确定哪个SQL Apply
组件是瓶颈	147
4.3  SQL Apply故障排除	152
4.3.1  理解SQL Apply中的
重新启动	152
4.3.2  SQL Apply停止时的
故障排除	155
4.4  小结	158
第5章  实现Oracle Data Guard
Broker	159
5.1  Data Guard Broker概述	160
5.1.1  Broker进程模型	160
5.1.2  Broker进程流	161
5.1.3  Broker配置文件	164
5.1.4  Broker命令行界面	165
5.2  Broker入门	166
5.2.1  配置Broker参数	166
5.2.2  Broker和Oracle Net
Services	170
5.2.3  RAC和Broker	174
5.2.4  连接到Broker	177
5.3  使用Broker管理
Data Guard	180
5.3.1  创建和启用Broker配置	180
5.3.2  更改Broker配置属性	188
5.3.3  更改数据库状态	197
5.3.4  更改保护模式	199
5.4  使用Broker监控
Data Guard	200
5.5  卸载Broker	203
5.6  小结	204
第6章  Oracle Enterprise Manager
Grid Control集成	205
6.1  访问Data Guard功能	206
6.1.1  利用OEM Grid Control
配置Data Guard Broker	207
6.1.2  验证配置和添加备用
重做日志	209
6.1.3  查看度量	211
6.1.4  修改度量	212
6.1.5  查看警报日志文件	212
6.1.6  启用闪回数据库	213
6.1.7  审阅性能	215
6.1.8  更改保护模式	217
6.1.9  编辑备用数据库属性	219
6.1.10  执行切换	220
6.1.11  执行手动故障转移	222
6.1.12  快速启动故障转移	225
6.1.13  创建逻辑备用数据库	226
6.1.14  管理活动的备用数据库	231
6.1.15  管理快照备用数据库	231
6.1.16  从Broker Control删除
备用数据库	231
6.2  分析可用性	232
6.3  小结	236
第7章  监控Data Guard实现	237
7.1  监控Data Guard环境	238
7.1.1  挖掘警报日志文件
(PS+LS)	238
7.1.2  从归档日志历史记录
收集统计信息(PS+LS)	244
7.1.3  检测归档日志间隔
(PS+LS)	246
7.1.4  确定重做传输中的延迟
时间(PS)	247
7.1.5  监控归档日志目的地
(PS+LS)	249
7.1.6  检查应用率和活动率
(PS)	251
7.1.7  审阅传输和应用滞后
(PS+LS)	251
7.1.8  确定备用数据库的
当前时间(PS)	252
7.1.9  管理恢复进程状态报告
(PS)	254
7.2  Data Guard Menu
实用程序	255
7.3  审阅当前Data Guard环境	256
7.3.1  检查密码文件(PS+LS)	258
7.3.2  检查Nologging活动
(PS+LS)	258
7.3.3  查看归档日志模式和
目的地(PS+LS)	262
7.3.4  检查备用文件管理(PS)	263
7.3.5  查看Data Guard状态
视图中的错误(PS)	264
7.3.6  逻辑备用Data Guard
Menu	265
7.4  小结	276
第8章  切换和故障转移	277
8.1  角色转换简介	278
8.1.1  切换	278
8.1.2  故障转移	280
8.1.3  对比切换和故障转移	285
8.2  闪回技术与Data Guard	286
8.3  执行切换	287
8.3.1  配置完整性检查	288
8.3.2  准备检查	288
8.3.3  预处理步骤	291
8.3.4  切换到物理备用数据库	292
8.3.5  切换到逻辑备用数据库	297
8.3.6  使用Broker或
Grid Control切换	300
8.3.7  检查切换状况	300
8.4  执行故障转移	301
8.4.1  发生故障后转移到物理
备用数据库	302
8.4.2  发生故障后转移到逻辑
备用数据库	305
8.4.3  重置旧的主数据库	305
8.4.4  使用Broker或Grid
Control进行故障转移	310
8.4.5  自动故障转移	311
8.5  关于多个备用数据库的
总结	323
8.6  小结	324
第9章  Active Data Guard	325
9.1  物理备用—— 只读模式
打开	326
9.1.1  使用只读方式的原因	327
9.1.2  只读或者读写模式的
缺陷	327
9.2  用于QA与测试环境的
快照备用	328
9.2.1  Oracle Database 10g
中的读写备用数据库	329
9.2.2  Oracle Database 11g
中的快照备用	333
9.3  真正应用测试	339
9.3.1  Database Replay	340
9.3.2  SQL Performance
Analyzer	345
9.4  Active Data Guard	347
9.5  小结	351
第10章  站点与客户端的自动故障
转移	353
10.1  定义问题	354
10.1.1  完全站点故障转移	354
10.1.2  部分站点故障转移	354
10.2  细节	355
10.2.1  连接负载平衡和
Connect-time故障
转移	355
10.2.2  出站连接超时	357
10.2.3  透明应用程序故障
转移	357
10.2.4  快速应用程序通知	360
10.2.5  DB_ROLE_CHANGE
系统事件	361
10.3  实现客户端故障转移	362
10.4  小结	369
第11章  利用Data Guard切换尽量
缩短计划内停机时间	371
11.1  计划内迁移概述	372
11.2  利用Data Guard切换
进行计划内迁移	372
11.2.1  案例1——全新数据
中心	372
11.2.2  案例2——移动到
ASM	373
11.3  利用Data Guard执行
数据库滚动升级	373
11.3.1  使用SQL Apply
进行滚动升级	374
11.3.2  使用临时逻辑备用
进行滚动升级	377
11.4  小结	383
第12章  备份和恢复注意事项	385
12.1  RMAN基础知识	386
12.2  RMAN与Data Guard
集成	387
12.2.1  块更改跟踪支持	387
12.2.2  控制文件管理	387
12.2.3  重新同步RMAN
目录	388
12.3  Data Guard中的RMAN
配置	388
12.3.1  主数据库配置示例	390
12.3.2  备份备用数据库
配置示例	390
12.3.3  其他物理备用数据库
配置示例	391
12.4  备份策略	391
12.5  备份方案	392
12.5.1  备份未备份的数据库	392
12.5.2  主数据库上的完整
备份	393
12.5.3  备份作为副本	394
12.5.4  镜像副本前滚	395
12.5.5  创建备用数据库	398
12.5.6  在备用数据库上备份	399
12.5.7  归档备份	401
12.6  一般恢复策略	402
12.6.1  介质故障	402
12.6.2  块损坏	402
12.6.3  用户错误	405
12.7  恢复方案	405
12.7.1  主数据库上的数据
文件丢失	406
12.7.2  备用数据库上的数据
文件丢失	407
12.7.3  备用控制文件丢失	407
12.7.4  主控制文件丢失	407
12.7.5  联机重做日志文件
丢失	408
12.7.6  主数据库不完全恢复	412
12.7.7  恢复误删的表	412
12.7.8  利用备用数据库上的
备份恢复缺少的数据
文件	413
12.8  一般最佳实践	416
12.9  小结	416
第13章  Data Guard故障排除	419
13.1  诊断信息	420
13.1.1  数据库警报日志	420
13.1.2  观察器日志文件	423
13.1.3  Data Guard跟踪文件	423
13.1.4  Data Guard Broker
日志文件与工具	423
13.1.5  动态性能视图	424
13.2  Data Guard配置和管理
错误	425
13.2.1  常见的管理问题	425
13.2.2  物理备用数据库问题	432
13.2.3  逻辑备用数据库故障	435
13.2.4  切换问题	437
13.2.5  故障转移问题	439
13.2.6  Data Guard Broker
问题	439
13.2.7  转换到快照备用时
出错	443
13.3  有用的提示和技巧	443
13.3.1  避免刷新备用控制
文件	443
13.3.2  避免使用NOLOGGING
子句	444
13.3.3  OMF——复制控制
文件	444
13.4  小结	445
第14章  部署架构	447
14.1  制造公司：HA配置	448
14.2  公用事业公司：零数据
丢失HA/DR	452
14.3  零售经纪公司：具有
零数据丢失和扩展地理
分离特点的HA/ DR	453
14.4  政府机构：防止多站点
威胁	455
14.5  制药公司：集中式HA/DR
与数据分布	457
14.6  网络零售商：使用
Reader-farm扩展的
HA/DR	458
14.7  保险公司：最高可用性
架构	460
14.8  小结	462
附录A  比较Data Gtuard与基于
阵列的远程镜像解决方案	465
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Data Guard 11g完全参考手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 11g性能优化攻略
目 　 　录
第1章 　优化表性能　　1
攻略1-1 　创建具有最优性能的数据库　　1
攻略1-2 　创建具有最优性能的表空间　　4
攻略1-3 　匹配表类型与业务需求　　6
攻略1-4 　选择有益于性能的表特性　　8
攻略1-5 　在创建数据表时避免盘区分配延迟　　9
攻略1-6 　数据加载速度最大化　　11
攻略1-7 　高效移除表中数据　　13
攻略1-8 　显示自动段顾问建议　　15
攻略1-9 　手工生成段顾问建议　　18
攻略1-10 　自动发送段顾问输出电子邮件　　22
攻略1-11 　重建跨多个数据块的数据行　　23
攻略1-12 　释放未使用的表存储空间　　26
攻略1-13 　压缩数据以进行直接路径加载　　27
攻略1-14 　为所有DML操作压缩数据　　30
攻略1-15 　在列级压缩数据　　31
攻略1-16 　监控表使用率　　33
第2章 　选择和优化索引　　35
攻略2-1 　理解B树索引　　36
攻略2-2 　选择需要建立索引的列　　41
攻略2-3 　创建主键索引　　44
攻略2-4 　创建唯一索引　　45
攻略2-5 　为外键列创建索引　　48
攻略2-6 　何时使用组合索引　　49
攻略2-7 　通过压缩减少索引大小　　51
攻略2-8 　实现基于函数的索引　　52
攻略2-9 　在虚拟列上创建索引　　54
攻略2-10 　平衡索引的I/O　　56
攻略2-11 　新增一个索引而不影响已有的应用　　57
攻略2-12 　创建支持星型架构的位图索引　　58
攻略2-13 　创建位图连接索引　　59
攻略2-14 　创建索引组织表　　60
攻略2-15 　监控索引使用　　62
攻略2-16 　索引创建速度最大化　　63
攻略2-17 　回收未使用的索引空间　　64
第3章 　优化实例内存　　68
攻略3-1 　自动内存管理　　68
攻略3-2 　管理多个缓冲池　　71
攻略3-3 　设定内存最小值　　73
攻略3-4 　监控内存调整操作　　74
攻略3-5 　优化内存使用　　75
攻略3-6 　调优PGA内存分配　　77
攻略3-7 　配置服务器查询缓存　　79
攻略3-8 　管理服务器结果缓存　　81
攻略3-9 　缓存SQL查询结果　　83
攻略3-10 　缓存客户端结果集　　86
攻略3-11 　缓存PL/SQL函数结果　　88
攻略3-12 　配置Oracle数据库智能闪存缓存　　91
攻略3-13 　调节重做日志缓冲区　　93
第4章 　监控系统性能　　95
攻略4-1 　实现AWR　　95
攻略4-2 　修改统计信息时间间隔和保存期限　　97
攻略4-3 　手工生成AWR报表　　99
攻略4-4 　通过企业管理器生成一份AWR报告　　101
攻略4-5 　为一条SQL语句生成AWR报告　　102
攻略4-6 　为数据库创建统计基线　　103
攻略4-7 　通过企业管理器管理AWR基线　　106
攻略4-8 　管理AWR统计信息库　　109
攻略4-9 　自动创建AWR基线　　110
攻略4-10 　快速分析AWR输出　　112
攻略4-11 　手工获取活动会话信息　　113
攻略4-12 　从企业管理器中获取ASH信息　　117
攻略4-13 　从数据字典中获取ASH信息　　119
第5章 　最小化系统资源争夺　　123
攻略5-1 　理解响应时间　　123
攻略5-2 　确定引起最多等待的SQL语句　　126
攻略5-3 　分析等待事件　　126
攻略5-4 　理解等待事件的分类　　128
攻略5-5 　检查会话等待　　128
攻略5-6 　按类型检查等待事件　　130
攻略5-7 　解决缓冲区忙等待　　132
攻略5-8 　解决日志文件同步等待　　134
攻略5-9 　被另一个会话读取等待事件的最小化　　135
攻略5-10 　减少直接路径读取等待事件　　136
攻略5-11 　恢复写入器等待最小化　　137
攻略5-12 　找出谁持有阻塞锁　　138
攻略5-13 　确定被阻塞和引起阻塞的会话　　140
攻略5-14 　处理引起阻塞的锁　　141
攻略5-15 　确定被锁定的对象　　142
攻略5-16 　解决enq:TM锁资源争夺　　143
攻略5-17 　确定最近被锁住的会话　　145
攻略5-18 　分析数据库中最近的等待事件　　147
攻略5-19 　确定由于锁定所花费的等待时间　　149
攻略5-20 　锁存器争夺的最小化　　151
攻略5-21 　通过Oracle企业管理器来管理锁　　154
攻略5-22 　通过Oracle企业管理器分析等待　　155
第6章 　分析操作系统性能　　157
攻略6-1 　检测磁盘空间问题　　159
攻略6-2 　确定系统瓶颈　　161
攻略6-3 　确定系统瓶颈（Solaris）　　163
攻略6-4 　确定消耗服务器资源最多的进程（top）　　164
攻略6-5 　确定CPU和内存瓶颈　　166
攻略6-6 　确定I/O瓶颈　　167
攻略6-7 　识别网络密集型进程　　170
攻略6-8 　检修数据库网络连接性　　171
攻略6-9 　将一个资源密集型进程映射到一个数据库进程　　172
攻略6-10 　终止一个资源密集型进程　　175
第7章 　检修数据库　　177
攻略7-1 　确定最优的撤销保留时间　　177
攻略7-2 　找出是什么消耗了最多的撤销空间　　181
攻略7-3 　解决ORA-01555错误　　182
攻略7-4 　监控临时表空间使用率　　184
攻略7-5 　确定是谁在使用临时表空间　　185
攻略7-6 　解决“无法扩展临时数据段”错误　　186
攻略7-7 　解决打开游标错误　　188
攻略7-8 　解决被挂起的数据库问题　　190
攻略7-9 　激活自动诊断库命令解释器　　194
攻略7-10 　从ADRCI中来查看报警日志　　198
攻略7-11 　使用ADRCI查看事件　　200
攻略7-12 　将事件打包发给Oracle技术支持团队　　202
攻略7-13 　运行一次数据库健康检查　　203
攻略7-14 　创建SQL测试用例　　205
攻略7-15 　生成一份AWR报告　　208
攻略7-16 　比较两个阶段的数据库性能　　210
攻略7-17 　分析一份AWR报告　　212
第8章 　创建高效的SQL　　216
攻略8-1 　获取一张表中的所有数据行　　216
攻略8-2 　获取一张表中的部分数据行　　218
攻略8-3 　通过相对应的行来连接表　　220
攻略8-4 　在没有相对应数据行的情况下连接表　　222
攻略8-5 　构造简单的子查询　　224
攻略8-6 　构建相关子查询　　228
攻略8-7 　比较两个表找出缺失的数据行　　230
攻略8-8 　比较两张表找出匹配的数据行　　231
攻略8-9 　将相似SELECT语句的结果集合并　　232
攻略8-10 　查找一定范围内的值　　234
攻略8-11 　处理空值　　237
攻略8-12 　搜索部分列值　　240
攻略8-13 　重用共享池中的SQL语句　　243
攻略8-14 　避免偶然的全表扫描　　246
攻略8-15 　创建高效的临时视图　　248
攻略8-16 　避免使用NOT子句　　250
攻略8-17 　控制事务大小　　252
第9章 　SQL手工调优　　255
攻略9-1 　显示查询的执行计划　　256
攻略9-2 　定制执行计划输出　　258
攻略9-3 　图形化显示执行计划　　261
攻略9-4 　解读一份执行计划　　262
攻略9-5 　监控运行时间较长的SQL语句　　264
攻略9-6 　确定当前正在执行的耗占资源的SQL语句　　265
攻略9-7 　查看当前正在运行的SQL语句的统计信息　　266
攻略9-8 　监控一个SQL执行计划的处理过程　　269
攻略9-9 　确定过去执行的SQL语句中最耗占资源的语句　　271
攻略9-10 　比较系统修改后的SQL性能　　273
第10章 　追踪SQL执行　　278
攻略10-1 　环境准备　　278
攻略10-2 　追踪一个特定的SQL语句　　280
攻略10-3 　在你所拥有的会话中启用追踪　　282
攻略10-4 　找到追踪文件　　283
攻略10-5 　检查原始SQL追踪文件　　284
攻略10-6 　分析Oracle追踪文件　　285
攻略10-7 　使用TKPROF设置追踪文件的格式　　286
攻略10-8 　分析TKPROF输出　　287
攻略10-9 　使用Oracle追踪分析器分析追踪文件　　290
攻略10-10 　追踪一个并行查询　　293
攻略10-11 　追踪特定的并行查询进程　　294
攻略10-12 　在RAC系统中追踪并行查询　　295
攻略10-13 　合并多个追踪文件　　296
攻略10-14 　找出正确的会话来进行追踪　　297
攻略10-15 　追踪一个SQL会话　　297
攻略10-16 　通过进程ID来追踪会话　　299
攻略10-17 　追踪多个会话　　300
攻略10-18 　追踪一个实例或数据库　　301
攻略10-19 　为会话生成事件10046追踪　　302
攻略10-20 　为实例生成事件10046追踪　　304
攻略10-21 　在一个正在运行的会话上设置追踪　　304
攻略10-22 　登录之后启用会话追踪　　305
攻略10-23 　追踪优化器的执行路径　　306
攻略10-24 　生成Oracle错误自动追踪　　309
攻略10-25 　追踪后台进程　　310
攻略10-26 　启用Oracle监听器追踪　　311
攻略10-27 　为数据卫士设置归档追踪　　312
第11章 　SQL自动调优　　314
攻略11-1 　显示自动SQL调优工作详细信息　　316
攻略11-2 　显示SQL自动调优建议　　318
攻略11-3 　生成SQL脚本来实现自动调优建议　　322
攻略11-4 　修改SQL自动调优特性　　323
攻略11-5 　禁用和启用SQL自动调优　　325
攻略11-6 　修改维护窗口属性　　326
攻略11-7 　创建SQL调优集对象　　327
攻略11-8 　查看AWR中的资源密集型SQL语句　　328
攻略11-9 　查看内存中的资源密集型SQL语句　　330
攻略11-10 　用AWR中高资源消耗的SQL来填充优化集　　332
攻略11-11 　用内存中高资源消耗的SQL来填充调优集　　333
攻略11-12 　将内存中所有SQL语句填充到SQL调优集　　334
攻略11-13 　显示SQL调优集的内容　　335
攻略11-14 　有选择地从SQL调优集中删除语句　　337
攻略11-15 　传输SQL调优集　　338
攻略11-16 　创建调优任务　　340
攻略11-17 　手工运行SQL调优顾问　　342
攻略11-18 　从数据库自动诊断监视器中获得SQL调优建议　　345
第12章 　执行计划优化与一致性　　348
攻略12-1 　创建并接受SQL概要　　351
攻略12-2 　自动接受SQL概要文件　　354
攻略12-3 　显示SQL概要文件信息　　356
攻略12-4 　禁用SQL概要文件　　358
攻略12-5 　删除SQL概要文件　　360
攻略12-6 　移动SQL概要文件　　361
攻略12-7 　自动增加计划基线　　363
攻略12-8 　为一条SQL语句创建计划基线　　365
攻略12-9 　为包含在SQL调优集中的SQL语句创建计划基线　　366
攻略12-10 　修改计划基线　　368
攻略12-11 　确认是否存在计划基线　　370
攻略12-12 　显示计划基线执行计划　　371
攻略12-13 　在计划基线中加入一个新的计划（扩展）　　372
攻略12-14 　禁用计划基线　　375
攻略12-15 　移除计划基线信息　　376
攻略12-16 　迁移计划基线　　377
第13章 　优化器配置　　380
攻略13-1 　选择优化器目标　　380
攻略13-2 　启用统计信息自动收集　　381
攻略13-3 　为统计信息收集设置首选参数　　383
攻略13-4 　手工生成统计信息　　388
攻略13-5 　锁定统计信息　　389
攻略13-6 　处理统计信息的缺失　　390
攻略13-7 　导出统计信息　　392
攻略13-8 　还原以前版本的统计信息　　393
攻略13-9 　收集系统统计信息　　394
攻略13-10 　验证新的统计信息　　397
攻略13-11 　强制优化器使用某个索引　　399
攻略13-12 　启用查询优化器特性　　400
攻略13-13 　阻止数据库创建柱状图　　402
攻略13-14 　不使用绑定变量提高性能　　403
攻略13-15 　理解自适应游标共享　　406
攻略13-16 　在表达式上创建统计信息　　411
攻略13-17 　为相关列创建统计信息　　412
攻略13-18 　自动创建列组　　413
攻略13-19 　维护分区表统计信息　　415
攻略13-20 　为大表并行收集统计信息　　416
第14章 　实现查询提示　　419
攻略14-1 　编写一个提示　　419
攻略14-2 　改变访问路径　　420
攻略14-3 　改变连接顺序　　424
攻略14-4 　改变连接方法　　425
攻略14-5 　改变优化器版本　　428
攻略14-6 　在快速响应和整体优化之间进行选择　　428
攻略14-7 　进行直接路径插入　　430
攻略14-8 　在视图中加入提示　　432
攻略14-9 　缓存查询结果　　434
攻略14-10 　将分布式查询引导到一个特定的数据库　　437
攻略14-11 　收集查询执行的扩展统计信息　　441
攻略14-12 　启用查询改写　　442
攻略14-13 　提升星型架构查询的性能　　444
第15章 　并行执行SQL　　447
攻略15-1 　为特定查询启用并行　　447
攻略15-2 　在创建对象时启用并行　　451
攻略15-3 　为已经存在的对象启用并行　　452
攻略15-4 　实现并行DML　　453
攻略15-5 　并行创建表　　456
攻略15-6 　并行创建索引　　458
攻略15-7 　并行重建索引　　459
攻略15-8 　并行移动分区　　460
攻略15-9 　并行拆分分区　　461
攻略15-10 　启用自动并行度　　462
攻略15-11 　检查并行解释计划　　463
攻略15-12 　监控并行操作　　466
攻略15-13 　找出并行进程中的瓶颈　　468
攻略15-14 　获取并行会话的详细信息　　469
索引　　471
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 11g性能优化攻略
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 11g DBA手册
目录
第Ⅰ部分 数据库体系结构
第1章 Oracle体系结构概述 3
1.1 数据库和实例概述 4
1.1.1 数据库 4
1.1.2 实例 5
1.2 Oracle逻辑存储结构 5
1.2.1 表空间 5
1.2.2 块 6
1.2.3 盘区 6
1.2.4 段 6
1.3 Oracle逻辑数据库结构 7
1.3.1 表 7
1.3.2 约束 14
1.3.3 索引 16
1.3.4 视图 18
1.3.5 用户和模式 19
1.3.6 配置文件 20
1.3.7 序列 20
1.3.8 同义词 20
1.3.9 PL/SQL 20
1.3.10 外部文件访问 21
1.3.11 数据库链接和远程数据库 22
1.4 Oracle物理存储结构 22
1.4.1 数据文件 23
1.4.2 重做日志文件 24
1.4.3 控制文件 24
1.4.4 归档的日志文件 24
1.4.5 初始参数文件 25
1.4.6 警报和跟踪日志文件 25
1.4.7 备份文件 26
1.4.8 Oracle管理文件 26
1.4.9 密码文件 26
1.5 多元复用数据库文件 27
1.5.1 自动存储管理 27
1.5.2 手动的多元复用 27
1.6 Oracle内存结构 29
1.6.1 系统全局区域 30
1.6.2 程序全局区域 32
1.6.3 软件代码区域 32
1.6.4 后台进程 32
1.7 备份/恢复概述 35
1.7.1 导出/导入 35
1.7.2 脱机备份 35
1.7.3 联机备份 35
1.7.4 RMAN 36
1.8 安全功能 36
1.8.1 权限和角色 36
1.8.2 审核 37
1.8.3 细粒度的审核 37
1.8.4 虚拟私有数据库 37
1.8.5 标号安全性 37
1.9 实时应用集群 38
1.10 Oracle流 38
1.11 Oracle企业管理器 39
1.12 Oracle初始参数 39
1.12.1 基本初始参数 39
1.12.2 高级初始参数 44
第2章 Oracle Database 11g的升级 45
2.1 选择升级方法 46
2.2 升级前的准备工作 48
2.3 使用数据库升级助手 48
2.4 执行手动直接升级 49
2.5 使用Export和Import 51
2.5.1 使用的Export和Import版本 52
2.5.2 执行升级 52
2.6 使用数据复制方法 53
2.7 升级后的工作 53
第3章 计划和管理表空间 55
3.1 表空间的体系结构 56
3.1.1 表空间类型 56
3.1.2 优化灵活体系结构 61
3.2 Oracle安装表空间 65
3.2.1 SYSTEM 65
3.2.2 SYSAUX 65
3.2.3 TEMP 65
3.2.4 UNDOTBS1 65
3.2.5 USERS 66
3.2.6 EXAMPLE 66
3.3 段分离 66
第4章 物理数据库布局和存储管理 67
4.1 传统磁盘空间存储 68
4.1.1 调整表空间和数据文件的大小 68
4.1.2 移动数据文件 81
4.1.3 移动联机重做日志文件 83
4.1.4 移动控制文件 85
4.2 自动存储管理 87
4.2.1 ASM体系结构 87
4.2.2 创建ASM实例 88
4.2.3 ASM实例组成部分 90
4.2.4 ASM动态性能视图 91
4.2.5 ASM文件名格式 92
4.2.6 ASM文件类型和模板 94
4.2.7 管理ASM磁盘组 95
第Ⅱ部分 数据库管理
第5章 开发和实现应用程序 109
5.1 调整设计：最佳实践 110
5.1.1 做尽可能少的工作 110
5.1.2 做尽可能简单的工作 112
5.1.3 告诉数据库需要知道的内容 114
5.1.4 最大化环境中的吞吐量 114
5.1.5 分开处理数据 115
5.1.6 正确进行测试 116
5.1.7 标准的可交付成果 118
5.2 资源管理和存储概要 120
5.2.1 实现数据库资源管理器 120
5.2.2 实现存储概要 124
5.2.3 调整数据库对象的大小 127
5.2.4 使用临时表 132
5.3 支持基于抽象数据类型的表 133
5.3.1 使用对象视图 134
5.3.2 抽象数据类型的安全性 136
5.3.3 对抽象数据类型属性创建索引 138
5.4 停顿并挂起数据库 139
5.5 支持迭代式开发 140
5.5.1 迭代式列定义 141
5.5.2 强制光标共享 142
5.6 管理程序包开发 142
5.6.1 生成图表 142
5.6.2 空间需求 142
5.6.3 调整目标 143
5.6.4 安全性需求 143
5.6.5 数据需求 143
5.6.6 版本需求 143
5.6.7 执行计划 143
5.6.8 验收测试过程 144
5.6.9 测试环境 144
第6章 监控空间利用率 145
6.1 常见的空间管理问题 146
6.1.1 用完表空间中的空闲空间 146
6.1.2 用于临时段的空间不充足 147
6.1.3 所分配的撤销空间过多或过少 147
6.1.4 分片的表空间和段 147
6.2 Oracle段、盘区和块 148
6.2.1 数据块 148
6.2.2 盘区 150
6.2.3 段 151
6.3 数据字典视图和动态性能视图 151
6.3.1 DBA_TABLESPACES 152
6.3.2 DBA_SEGMENTS 152
6.3.3 DBA_EXTENTS 153
6.3.4 DBA_FREE_SPACE 153
6.3.5 DBA_LMT_FREE_SPACE 154
6.3.6 DBA_THRESHOLDS 154
6.3.7 DBA_OUTSTANDING_ALERTS 154
6.3.8 DBA_ALERT_HISTORY 154
6.3.9 V$ALERT_TYPES 154
6.3.10 V$UNDOSTAT 155
6.3.11 V$OBJECT_USAGE 155
6.3.12 V$SORT_SEGMENT 155
6.3.13 V$TEMPSEG_USAGE 155
6.4 空间管理方法学 156
6.4.1 本地管理的表空间 156
6.4.2 使用OMF管理空间 157
6.4.3 大文件表空间 158
6.4.4 自动存储管理 159
6.4.5 撤销管理的考虑事项 161
6.5 SYSAUX监控和使用 162
6.6 归档重做日志文件的管理 164
6.7 内置的空间管理工具 164
6.7.1 段顾问 164
6.7.2 撤销顾问和自动工作负荷存储库 167
6.7.3 索引利用率 169
6.7.4 空间利用率警告级别 170
6.7.5 可恢复的空间分配 172
6.7.6 用ADR管理警报日志和跟踪文件 174
6.7.7 OS空间管理 176
6.8 空间管理脚本 176
6.8.1 无法分配额外盘区的段 176
6.8.2 表空间和数据文件已使用的空间和空闲的空间 177
6.9 自动化和流水线化通知过程 178
6.9.1 使用DBMS_SCHEDULER 178
6.9.2 OEM作业控制和监控 179
第7章 使用撤销表空间管理事务 185
7.1 事务基础 186
7.2 撤销基础 186
7.2.1 回滚 186
7.2.2 读一致性 187
7.2.3 数据库恢复 187
7.2.4 闪回操作 187
7.3 管理撤销表空间 187
7.3.1 创建撤销表空间 188
7.3.2 撤销表空间的动态性能视图 193
7.3.3 撤销表空间的初始参数 193
7.3.4 多个撤销表空间 194
7.3.5 撤销表空间的大小调整和监控 196
7.3.6 读一致性与成功的DML 199
7.4 闪回特性 199
7.4.1 Flashback Query(闪回查询) 200
7.4.2 DBMS_FLASHBACK 201
7.4.3 Flashback Transaction Backout(闪回事务停止) 203
7.4.4 Flashback Table(闪回表) 204
7.4.5 Flashback Version Query(闪回版本查询) 207
7.4.6 Flashback Transaction Query (闪回事务查询) 209
7.4.7 闪回数据归档 210
7.4.8 闪回与LOB 214
7.5 迁移到自动撤销管理 214
第8章 数据库调整 215
8.1 调整应用程序设计 216
8.1.1 有效的表设计 216
8.1.2 CPU需求的分布 217
8.1.3 有效的应用程序设计 218
8.2 调整SQL 219
8.2.1 顺序对加载速率的影响 220
8.2.2 其他的索引选项 221
8.2.3 生成解释计划 222
8.3 调整内存使用率 224
8.3.1 指定SGA的大小 227
8.3.2 使用基于成本的优化器 228
8.3.3 COMPUTE STATISTICS选项的含义 228
8.4 调整数据访问 229
8.4.1 本地管理的表空间 229
8.4.2 标识链行 230
8.4.3 增加Oracle块大小 231
8.4.4 使用索引组织表 231
8.4.5 索引组织表的调整问题 232
8.5 调整数据操作 233
8.5.1 大量插入：使用SQL*Loader
Direct Path选项 233
8.5.2 大量数据移动：使用外部表 234
8.5.3 大量插入：常见的陷阱和成功的技巧 235
8.5.4 大量删除：truncate命令 236
8.5.5 使用分区 237
8.6 调整物理存储 237
8.6.1 使用裸设备 237
8.6.2 使用自动存储管理 238
8.7 减少网络流量 238
8.7.1 使用物化视图复制数据 238
8.7.2 使用远程过程调用 240
8.8 使用自动工作负荷存储库(AWR) 241
8.8.1 管理快照 241
8.8.2 管理基线 242
8.8.3 生成AWR报表 242
8.8.4 运行Automatic Database Diagnostic Monitor报表 242
8.8.5 使用自动SQL调整顾问 244
8.9 调整解决方案 245
第9章 数据库安全性和审计 247
9.1 非数据库的安全性 248
9.2 数据库验证方法 249
9.2.1 数据库验证 249
9.2.2 数据库管理员验证 249
9.2.3 操作系统验证 252
9.2.4 网络验证 253
9.2.5 3层验证 254
9.2.6 客户端验证 255
9.2.7 Oracle身份管理 255
9.2.8 用户账户 256
9.3 数据库授权方法 261
9.3.1 配置文件的管理 261
9.3.2 系统权限 268
9.3.3 对象权限 270
9.3.4 创建、分配和维护角色 274
9.3.5 使用VPD实现应用程序安全策略 280
9.4 审计 296
9.4.1 审计位置 297
9.4.2 语句审计 297
9.4.3 权限审计 301
9.4.4 模式对象审计 301
9.4.5 细粒度的审计 303
9.4.6 与审计相关的数据字典视图 304
9.4.7 保护审计跟踪 305
9.4.8 启用增强的审计 305
9.5 数据加密技术 306
9.5.1 DBMS_CRYPTO程序包 307
9.5.2 透明数据加密 307
第Ⅲ部分 高 可 用 性
第10章 实时应用集群 315
10.1 实时应用集群概述 316
10.1.1 硬件配置 316
10.1.2 软件配置 317
10.1.3 网络配置 317
10.1.4 磁盘存储 318
10.2 安装和配置 318
10.2.1 操作系统配置 319
10.2.2 软件安装 325
10.3 RAC数据库特征 341
10.3.1 服务器参数文件特征 341
10.3.2 与RAC相关的初始化参数 342
10.3.3 动态性能视图 343
10.4 RAC维护 344
10.4.1 启动RAC数据库 345
10.4.2 RAC环境中的重做日志 345
10.4.3 RAC环境中的撤销表空间 345
10.4.4 故障转移情况和TAF 346
10.4.5 RAC节点失效的情况 347
10.4.6 调整RAC节点数据库 351
10.4.7 表空间管理 351
第11章 备份和恢复选项 353
11.1 功能 353
11.2 逻辑备份 354
11.3 物理备份 355
11.3.1 脱机备份 355
11.3.2 联机备份 355
11.4 使用Data Pump Export和Data Pump Import 356
11.4.1 创建目录 357
11.4.2 Data Pump Export选项 358
11.4.3 启动Data Pump Export作业 360
11.5 Data Pump Import选项 364
11.5.1 启动Data Pump Import作业 366
11.5.2 比较Data Pump Export/Import和Export/Import 370
11.5.3 实现脱机备份 371
11.5.4 实现联机备份 371
11.6 备份过程集成 374
11.6.1 集成逻辑备份和物理备份 374
11.6.2 集成数据库备份和操作系统备份 375
第12章 使用恢复管理器(RMAN) 377
12.1 RMAN的特性和组件 378
12.1.1 RMAN组件 378
12.1.2 RMAN与传统的备份方法 379
12.1.3 备份类型 381
12.2 RMAN命令和选项概述 382
12.2.1 常用的命令 382
12.2.2 设置存储库 384
12.2.3 注册数据库 386
12.2.4 维持RMAN设置 387
12.2.5 初始化参数 390
12.2.6 数据字典和动态性能视图 391
12.3 备份操作 392
12.3.1 完全数据库备份 392
12.3.2 表空间 398
12.3.3 数据文件 400
12.3.4 映像副本 400
12.3.5 控制文件和SPFILE备份 401
12.3.6 归档重做日志 402
12.3.7 增量备份 402
12.3.8 增量更新的备份 405
12.3.9 增量备份块变化跟踪 407
12.3.10 备份压缩 408
12.3.11 使用闪回恢复区 409
12.3.12 验证备份 409
12.4 恢复操作 411
12.4.1 块介质恢复 412
12.4.2 恢复控制文件 413
12.4.3 恢复表空间 413
12.4.4 恢复数据文件 415
12.4.5 恢复整个数据库 417
12.4.6 验证恢复操作 420
12.4.7 时间点恢复 421
12.4.8 数据恢复顾问 422
12.5 其他操作 426
12.5.1 编目其他的备份 426
12.5.2 目录维护 427
12.5.3 REPORT和LIST 429
第13章 Oracle Data Guard 431
13.1 Data Guard体系结构 431
13.1.1 物理备用数据库与逻辑备用数据库 432
13.1.2 数据保护模式 433
13.2 LOG_ARCHIVE_DEST_n参数属性 433
13.3 创建备用数据库配置 435
13.3.1 准备主数据库 435
13.3.2 创建逻辑备用数据库 439
13.4 使用实时应用 441
13.5 管理归档日志序列中的间隙 442
13.6 管理角色——切换和故障转移 442
13.6.1 切换 442
13.6.2 切换到物理备用数据库 443
13.6.3 切换到逻辑备用数据库 444
13.6.4 到物理备用数据库的故障转移 445
13.6.5 到逻辑备用数据库的故障转移 445
13.7 管理数据库 446
13.7.1 启动和关闭物理备用数据库 446
13.7.2 以只读模式打开物理备用数据库 446
13.7.3 在Data Guard环境下管理数据文件 447
13.7.4 在逻辑备用数据库上执行DDL 447
第14章 其他各种高可用性特性 449
14.1 使用闪回删除来恢复被删除的表 450
14.2 flashback database命令 451
14.3 使用LogMiner 453
14.3.1 LogMiner的工作方式 454
14.3.2 提取数据字典 454
14.3.3 分析一个或多个重做日志文件 455
14.3.4 Oracle Database 10g中引入的LogMiner特性 457
14.3.5 Oracle Database 11g中引入的LogMiner特性 457
14.4 联机对象重组织 458
14.4.1 联机创建索引 458
14.4.2 联机重建索引 458
14.4.3 联机合并索引 459
14.4.4 联机重建以索引组织的表 459
14.4.5 联机重新定义表 459
第Ⅳ部分 网络化的Oracle
第15章 Oracle网络(Oracle Net) 465
15.1 Oracle Net概述 465
15.1.1 连接描述符 468
15.1.2 网络服务名 469
15.1.3 使用Oracle Internet Directory(因特网目录)替换tnsnames.ora 469
15.1.4 侦听程序(Listener) 470
15.2 使用Oracle Net Configuration Assistant(Oracle Net配置助手) 473
15.3 使用Oracle Net Manager 477
15.4 启动侦听程序服务器进程 478
15.5 对侦听程序服务器进程进行控制 479
15.5.1 Oracle Connection Manager(Oracle连接管理器) 482
15.5.2 使用Connection Manager 482
15.5.3 使用Oracle Internet Directory的目录命名 485
15.6 使用Easy Connect Naming 487
15.7 使用数据库链接 488
15.8 调整Oracle Net 489
15.8.1 限制资源的使用 490
15.8.2 调试连接问题 491
第16章 管理大型数据库 493
16.1 在VLDB环境中创建表空间 494
16.1.1 大文件表空间的基本知识 495
16.1.2 创建和修改大文件表空间 495
16.1.3 大文件表空间ROWID格式 496
16.1.4 DBMS_ROWID和大文件表空间 497
16.1.5 将DBVERIFY用于大文件表空间 499
16.1.6 大文件表空间的初始化参数需要考虑的因素 500
16.1.7 大文件表空间数据字典的变化 501
16.2 高级的Oracle表类型 501
16.2.1 索引组织的表 502
16.2.2 全局临时表 502
16.2.3 外部表 504
16.2.4 分区表 506
16.2.5 物化视图 535
16.3 使用位图索引 535
16.3.1 理解位图索引 536
16.3.2 使用位图索引 536
16.3.3 使用位图连接索引 537
16.4 Oracle Data Pump(Oracle 数据泵) 537
16.4.1 Data Pump Export 538
16.4.2 Data Pump Import 539
16.4.3 使用可传输表空间 539
第17章 管理分布式数据库 545
17.1 远程查询 546
17.2 远程数据处理：两阶段提交 547
17.3 动态数据复制 548
17.4 管理分布式数据 549
17.4.1 基础设施：实施位置透明性 549
17.4.2 管理数据库链接 554
17.4.3 管理数据库触发器 555
17.4.4 管理物化视图 556
17.4.5 使用DBMS_MVIEW和DBMS_ADVISOR 559
17.4.6 可以执行什么类型的更新 568
17.4.7 使用物化视图改变查询执行路径 572
17.5 管理分布式事务处理 573
17.5.1 解决未确定的事务处理 573
17.5.2 提交点强度 574
17.6 监控分布式数据库 574
17.7 调整分布式数据库 575
附录A 安装和配置 579
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 11g DBA手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库性能优化的艺术
前言
第1章　综述：优化是一个系统工程 / 1
1.1　性能问题是一个系统工程 / 3
1.1.1　考虑性能问题的不同阶段 / 3
1.1.2　考虑性能问题的不同方面 / 4
1.1.3　性能架构中的问题分类 / 5
1.2　性能改进的工程方法 / 23
1.2.1　不要希望一步到位！ / 23
1.2.2　有时也能一步到位？ / 24
1.2.3　性能改进工作流程 / 26
1.2.4　建立性能分析流程图 / 28
1.2.5　编程中应尽量避免的问题 / 30
1.2.6　紧急事件性能处理 / 35
第2章　设计与优化：物理数据库结构设计 / 39
2.1　数据库的特定运行平台 / 40
2.2　物理设计与性能的关系 / 41
2.3　应用框架与性能特征 / 43
2.4　物理表设计的关注点 / 44
2.4.1　从逻辑模型到物理模型 / 44
2.4.2　物理数据库设计的范围 / 48
2.4.3　规范化的设计 / 49
2.4.4　反规范化设计 / 55
2.4.5　另类反规范化 / 59
2.4.6　是否反规范化 / 59
2.5　索引的初始设计 / 60
2.5.1　索引对象的基本结构 / 61
2.5.2　索引的可选择性指标 / 62
2.5.3　索引的双面性特征 / 62
2.5.4　索引的类型  / 64
2.5.5　索引的初始确定  / 69
2.5.6　临时表的使用 / 71
第3章　部署与优化：准备基本运行环境 / 73
3.1　性能问题在表象上的欺骗性 / 74
3.2　理解数据库需要的系统资源 / 76
3.2.1　I/O资源的使用  / 78
3.2.2　内存资源的使用 / 82
3.2.3　CPU资源的使用 / 86
3.2.4　解读内存与CPU状态 / 93
3.3　小型机数据库部署准备 / 94
3.3.1　AIX的部署准备 / 94
3.3.2　HP-UX的部署准备 / 98
3.3.3　Solaris的部署准备 / 102
3.4　X86系统数据库部署准备 / 107
3.4.1　Linux系统的部署准备 / 107
3.4.2　Windows系统的部署准备 / 110
第4章　部署与优化：数据库的优化部署 / 112
4.1　实例初始配置注意点 / 114
4.2　数据库空间使用关注 / 119
4.3　表空间的创建管理 / 130
4.4　创建表时的性能因素 / 135
4.5　数据导入与索引维护 / 144
第5章　实例优化：配置高效运行环境 / 145
5.1　实例配置与缓存优化 / 146
5.1.1　启用自动内存管理 / 148
5.1.2　主机内存分配原则 / 152
5.1.3　使用缓存顾问工具 / 155
5.1.4　缓存的命中率问题 / 158
5.1.5　缓存命中率分析 / 160
5.1.6　精细化缓存的配置  / 161
5.2　SQL与缓存的使用 / 165
5.2.1　缓存优化 / 165
5.2.2　查看数据缓存内容 / 165
5.2.3　共享池的效率检查 / 166
5.2.4　重做日志缓存问题 / 173
5.3　PGA内存分配原则 / 175
5.4　Oracle虚拟化关注点 / 176
5.4.1　I/O问题上的关注点 / 178
5.4.2　内存问题上的关注点 / 178
5.4.3　CPU问题上的关注点 / 179
5.4.4　故障恢复问题的解决 / 179
第6章　存储优化：配置高效存储环境 / 181
6.1　I/O问题的表象与内涵 / 182
6.2　存储介质的基础配置 / 183
6.2.1　使用逻辑卷技术 / 184
6.2.2　设定存储参数 / 187
6.3　存储I/O能力探究 / 197
6.3.1　Orion的安装 / 197
6.3.2　Orion的使用 / 198
第7章　综合部署：Oracle可靠性设置 / 201
7.1　数据库设置的综合考虑 / 202
7.1.1　设置数据库的内存使用 / 203
7.1.2　数据库的进程使用设置 / 208
7.1.3　设置数据库I/O模式 / 211
7.1.4　设置数据库的归档模式 / 213
7.1.5　使用闪回恢复区归档 / 214
7.1.6　设置冗余控制文件 / 215
7.1.7　保留控制文件信息 / 216
7.1.8　设置联机重做日志文件 / 217
7.1.9　设置联机重做日志组数 / 218
7.1.10　设置数据块校验和检查 / 220
7.1.11　打开性能时间统计 / 221
7.1.12　表空间和段管理方式 / 221
7.1.13　设定多临时表空间和组 / 222
7.1.14　使用自动撤销管理 / 223
7.1.15　设置空间错误延时 / 223
7.1.16　设置数据库闪回 / 224
7.2　RAC下的设置 / 225
7.2.1　注册远程监听器的实例 / 226
7.2.2　设置内部互联网络 / 226
7.3　加密表数据 / 227
7.4　加密表空间 / 231
第8章　对象优化：大表分区方式部署 / 232
8.1　分区技术适用的范围  / 233
8.2　分区技术的基本概念  / 234
8.2.1　分区表的结构 / 234
8.2.2　分区部署的收益 / 235
8.2.3　分区部署的成本 / 236
8.2.4　索引分区 / 237
8.3　分区表的管理操作 / 238
8.3.1　面向分区的管理 / 238
8.3.2　面向分区的操作 / 238
8.3.3　面向分区的恢复 / 239
8.4　分区的技术实现 / 239
8.4.1　基础分区的实现 / 240
8.4.2　组合分区的扩展 / 246
8.4.3　扩展分区技术 / 249
8.4.4　分区表的数据压缩 / 254
8.4.5　查看数据存储位置 / 255
8.4.6　分区键数据的改变 / 256
8.4.7　分区方式选择问题 / 257
8.4.8　使用分区顾问工具 / 258
第9章　索引定义：索引设置与执行计划 / 260
9.1　索引对象  / 261
9.2　Oracle优化器 / 263
9.2.1　优化器的选择  / 264
9.2.2　优化器的设置 / 266
9.2.3　数据扫描问题 / 268
9.3　索引的技术指标 / 285
9.3.1　索引的选择性  / 285
9.3.2　索引的簇化率 / 286
9.3.3　索引二元高度  / 289
9.3.4　直方图的使用  / 290
9.4　索引与SQL优化 / 294
9.5　避免索引不作为 / 296
9.5.1　非等式运算  / 297
9.5.2　Null值的比对  / 298
9.5.3　函数的调用  / 301
9.6　创建虚拟的索引 / 303
9.7　创建压缩的索引 / 305
9.8　索引的使用监测 / 305
9.8.1　创建不可视索引 / 305
9.8.2　索引的可用状态 / 308
9.8.3　监测索引的使用 / 309
9.9　对分区表建立索引  / 310
第10章　实例效率：识别数据库内部作为 / 312
10.1　研究数据库运行效率 / 313
10.1.1　定义和量化性能 / 314
10.1.2　统计分析的要素 / 314
10.1.3　性能状态的统计 / 327
10.1.4　其他相关统计 / 334
10.2　操作系统的使用方法 / 338
10.2.1　性能监视的手段 / 338
10.2.2　使用vmstat / 338
10.2.3　使用iostat / 341
10.2.4　使用sar / 345
10.2.5　使用nmon命令 / 347
10.3　调整计划探讨 / 349
第11章　优化践行：数据库层面的优化 / 351
11.1　Oracle自动统计 / 352
11.1.1　统计数据的解释  / 354
11.1.2　汇总的统计数据 / 355
11.2　使用AWR / 355
11.2.1　在OEM中访问AWR  / 357
11.2.2　用API管理AWR快照  / 359
11.2.3　使用度量基线 / 360
11.2.4　AWR工作报告 / 362
11.3　使用ADDM / 363
11.3.1　ADDM内部结构 / 364
11.3.2　ADDM使用示例 / 365
11.3.3　ADDM环境设置 / 367
11.3.4　ADDM手工获得 / 367
第12章　优化践行：操作系统层面的优化 / 369
12.1　平台的性能相关性 / 370
12.2　分配和调度内存资源 / 372
12.2.1　使用大的内存页面 / 373
12.2.2　设定内存替换阈值 / 375
12.2.3　设定内存空闲阈值 / 379
12.2.4　对应设置应用内存 / 380
12.3　设置系统进程资源 / 381
12.4　系统I/O资源的使用 / 382
12.4.1　优化使用异步I/O / 382
12.4.2　优化文件系统挂载 / 384
12.4.3　优化应用I/O模式 / 386
12.5　关闭系统中无用的服务 / 387
12.6　监控主机资源使用 / 387
12.6.1　服务器性能监控 / 388
12.6.2　分析系统的性能 / 389
写在最后 / 391
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库性能优化的艺术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ORACLE数据库精讲与疑难解析
第1篇 创建属于自己的Oracle数据库
第1章 认识Oracle的世界——Oracle的体系结构
1.1 Oracle的发家史
1.2 数据库
1.3 数据库管理系统（DBMS）
1.4 关系数据库的概念（RDBMS）
1.4.1 关系数据库模型
1.4.2 表
1.5 Oracle的总体框架结构
1.5.1 Oracle实例（Oracle Instance）
1.5.2 Oracle的存储结构
1.6 数据字典（Data Dictionary）
1.6.1 数据字典概述
1.6.2 数据字典的结构
1.6.3 数据字典的使用
第2章 迈出第1步——Oracle的安装/卸载
2.1 Oracle的安装
2.1.1 Oracle安装的几个概念
2.1.2 Oracle g（10.1）的安装——Windows篇
2.1.3 Oracle g的安装——Solaris篇
2.1.4 Oracle安装疑难解析
2.2 Oracle的卸载
2.2.1 Oracle完全卸载——Windows篇
2.2.2 Oracle完全卸载——UNIX篇
第3章 有米之炊——数据库的创建与删除
3.1 创建数据库
3.1.1 数据库创建概述
3.1.2 Solaris下用DBCA创建数据库
3.1.3 DIY——Solaris下手工创建数据库
3.1.4 数据库创建疑难解析
3.2 删除数据库
3.2.1 数据库删除概述
3.2.2 数据库删除——手工篇
3.2.3 数据库删除——DBCA篇
第2篇 网 络 管 理
第4章 Oracle网络管理并不难
4.1 Oracle网络体系结构
4.1.1 Oracle应用的几种网络结构
4.1.2 Oracle Net
4.1.3 OSI模型
4.1.4 Oracle Net的堆栈结构
4.1.5 Oracle监听器
4.1.6 连接描述符（connect identifier）
4.1.7 网络服务名（Net Service Name）
4.1.8 命名方法
4.1.9 配置Oracle网络的工具
4.2 Oracle网络管理
4.2.1 Oracle网络服务器端配置
4.2.2 Oracle网络客户端配置
4.3 Oracle网络管理疑难解析
4.3.1 Oracle网络服务器端配置疑难解析
4.3.2 Oracle网络客户端配置疑难解析
4.3.3 Oracle网络与防火墙（Firewall）
第3篇 系 统 管 理
第5章 系统管家婆——SQL*Plus的使用
5.1 系统管理工具SQL*Plus
5.2 SQL缓冲区（SQL Buffer）
5.3 SQL*Plus的环境配置
5.3.1 SQL*Plus的环境变量
5.3.2 SQL*Plus站点配置文件（Site Profile）
5.3.3 SQL*Plus用户配置文件（User Profile）
5.4 SQL*Plus的启动
5.5 SQL*Plus专有命令介绍
5.5.1 登录，注销命令
5.5.2 编辑命令
5.5.3 其他有用的SQL*Plus命令
5.6 SQL*Plus 与疑难解析
第6章 有始有终——数据库的启动与关闭
6.1 数据库启动
6.1.1 数据库启动原理
6.1.2 数据库启动
6.1.3 数据库启动疑难解析
6.2 数据库关闭
6.2.1 数据库关闭原理
6.2.2 数据库的关闭（SHUTDOWN）
6.2.3 数据库关闭疑难解析
第7章 理清两个模式问题——专有/共享服务器模式
7.1 理解专有服务器模式（Dedicated Server Mode）
7.2 共享服务器模式（Shared Server Mode）原理
7.2.1 共享服务器模式（Shared Server Mode）的架构
7.2.2 监听器和调度进程的关系
7.2.3 请求队列（Request Queue）/响应队列（Response Queue）
7.2.4 调度进程（Dispatcher Processes，Dnnn）
7.2.5 共享服务器进程（Shared Server Processes，Snnn）
7.3 共享服务器模式（Shared Server Mode）
7.4 共享服务器模式（Shared Server Mode）疑难解析
第8章 掌握两个管理问题——表空间和数据文件的管理
8.1 数据库存储结构
8.1.1 物理结构
8.1.2 逻辑结构
8.2 深刻理解表空间
8.2.1 大文件表空间
8.2.2 系统表空间
8.2.3 辅助表空间
8.2.4 回滚表空间（Undo Tablespace）
8.2.5 临时表空间
8.2.6 表空间中区的管理方式
8.2.7 表空间中段的管理方式
8.2.8 非标准块表空间
8.2.9 表空间的离线（Offline）与在线（Online）
8.2.10 只读表空间（Read-Only Tablespace）
8.3 深刻理解数据文件
8.3.1 数据文件的内容
8.3.2 数据文件的尺寸（Size）
8.3.3 离线数据文件
8.3.4 临时数据文件（Temporary Datafiles）
8.4 表空间管理 与疑难解析
8.4.1 永久表空间管理
8.4.2 临时表空间管理 与疑难解析
8.4.3 回滚表空间管理 与疑难解析
8.5 数据文件管理 与疑难解析
8.5.1 数据文件管理
8.5.2 数据文件管理疑难解析
第9章 进程管理
9.1 Oracle进程简介
9.2 用户进程
9.3 Oracle进程
9.3.1 服务器进程
9.3.2 后台进程
9.4 进程综合管理 与疑难解析
9.5 会话管理 与疑难解析
第10章 内存管理
10.1 Oracle内存结构简介
10.2 系统全局区
10.3 SGA自动管理
10.4 SGA组成介绍
10.4.1 数据库高速缓冲区
10.4.2 日志缓冲区
10.4.3 共享池
10.4.4 大池
10.4.5 Java池
10.4.6 流池
10.5 程序全局区
10.6 内存管理 与疑难解析
第11章 用户管理
11.1 用户验证
11.1.1 口令认证
11.1.2 外部认证
11.1.3 全局认证
11.2 Oracle的安全大门——权限（Privileges）
11.2.1 系统权限
11.2.2 对象权限
11.3 使权限管理变得更加容易——角色（Role）
11.4 限制用户的资源消耗——资源限制文件（Profile）
11.4.1 资源限制的级别
11.4.2 限制资源的参数
11.5 用户与权限管理 与疑难解析
11.5.1 用户管理 与疑难解析
11.5.2 权限管理 与疑难解析
11.5.3 角色管理 与疑难解析
11.5.4 资源限制文件管理 与疑难解析
第4篇 移动你的数据库
第12章 数据导出
12.1 数据导出方法介绍
12.1.1 Oracle最新导出工具——Data Pump Export
12.1.2 Oracle原来的导出工具——Export
12.2 数据导出
12.3 数据导出疑难解析
第13章 数据导入
13.1 数据导入方法介绍
13.1.1 Oracle最新导入工具——Data Pump Import
13.1.2 Oracle以前的导入方法——Import
13.2 数据导入
13.3 数据导入疑难解析
第5篇 Oracle文件管理
第14章 重中之重——控制文件的管理
14.1 控制文件的概念
14.2 控制文件管理 与疑难解析
第15章 成为数据库的最高统治者——口令文件（Password File）管理
15.1 超级用户权限（SYSDBA、SYSOPER）介绍
15.2 口令文件的基本概念
15.3 启用口令文件认证
15.4 口令文件管理 与疑难解析
第16章 联机日志文件管理
16.1 联机日志文件的概念
16.1.1 联机日志文件的内容
16.1.2 联机日志文件的循环利用
16.2 联机日志文件管理 与疑难解析
第17章 参数文件（PFILE/SPFILE）管理
17.1 参数文件的基本概念
17.2 初始化参数文件
17.3 服务器参数文件
17.4 初始化参数的修改
17.5 参数管理 与疑难解析
第6篇 Oracle高级专题
第18章 全球应用——分布式数据库疑难攻略
18.1 分布式数据库系统的概念
18.1.1 同构分布式数据库系统
18.1.2 异构分布式数据库系统
18.1.3 数据库链接（Database Link）
18.2 分布式数据库管理 与疑难解析
第19章 并不陌生的问题——裸设备
19.1 裸设备的概念
19.2 裸设备管理 与疑难解析
第7篇 数据库备份/恢复
第20章 备份/恢复之基石——归档（Archivelog）管理
20.1 归档的基本概念
20.1.1 非归档模式
20.1.2 归档模式
20.1.3 归档路径
20.2 归档管理 与疑难解析
第21章 必行之举——数据库备份
21.1 理解数据库备份
21.1.1 数据库失败的种类
21.1.2 备份和恢复的解决方案
21.1.3 备份和恢复的物理结构
21.1.4 备份的类型
21.1.5 执行用户管理的备份
21.2 恢复管理器（RMAN）
21.2.1 通道
21.2.2 备份集的维护
21.2.3 RMAN资料库
21.2.4 RMAN的使用
21.3 数据库备份 与疑难解析
21.4 恢复目录管理 与疑难解析
第22章 失而复得——数据库恢复
22.1 数据库恢复
22.1.1 实例恢复
22.1.2 介质恢复
22.1.3 用户错误（User Error）的恢复
22.2 数据库闪回（Flashback Database）
22.3 用户管理的恢复（User-managed Recovery）
22.4 联机日志文件丢失的恢复
22.5 控制文件损坏的恢复
22.6 数据文件损坏的恢复
22.7 表的恢复（用户错误的恢复）
第8篇 Oracle程序设计
第23章 数据库通用语言——SQL语句
23.1 结构化查询语言简介
23.2 SELECT语句
23.2.1 理解SELECT 语句
23.2.2 SELECT语句使用 与疑难解析
23.3 INSERT语句
23.3.1 理解INSERT语句
23.3.2 INSERT语句使用 与疑难解析
23.4 UPDATE语句
23.4.1 理解UPDATE语句
23.4.2 UPDATE语句使用 与疑难解析
23.5 DELETE语句
23.5.1 理解DELETE语句
23.5.2 DELETE语句的使用
23.6 SQL语句中，集合函数使用 与疑难解析
第24章 模式对象（Schema Object）的管理
24.1 模式（Schema）的概念
24.2 模式对象管理
24.2.1 表（Table）
24.2.2 索引（Index）
24.2.3 外部表（External Table）
24.2.4 临时表（Temporary Table）
24.2.5 分区表（Partition Table）
24.2.6 聚簇（Cluster）
24.2.7 索引组织表（Index-Organized Table，IOT）
24.2.8 视图
24.2.9 同义词
24.2.10 序列
第25章 PL／SQL应用程序开发
25.1 PL/SQL简述
25.1.1 PL/SQL块结构
25.1.2 数据类型
25.1.3 运算符
25.1.4 PL/SQL语句控制结构
25.2 存储过程（Stored Procedure）
25.2.1 存储过程的基本原理
25.2.2 存储过程管理 与疑难解析
25.3 函数（Function）
25.3.1 函数的基本原理
25.3.2 函数的管理 与疑难解析
25.4 包
25.4.1 包的基本原理
25.4.2 包管理 与疑难解析
25.5 触发器
25.5.1 触发器的基本原理
25.5.2 触发器管理 与疑难解析
25.6 游标
25.6.1 游标的基本原理
25.6.2 游标管理 与疑难解析
速查目录
第2章 迈出第1步——Oracle的安装/卸载
实务1 安装Oracle时，为什么不能启动安装界面
实务2 为什么Oracle安装界面无法显示中文，都是“□□□”
实务3 安装Oracle时，报告错误“ORA-12547：TNS：lost contact” 实务
实务4 如何下载Oracle的安装文件
实务5 Oracle安装完成后，用户sys与system默认的密码是什么 实务
实务6 如何找到Oracle安装时生成的日志文件
实务7 安装Oracle时，是否需要安装JDK
实务8 解压安装文件时，报告无权限 实务
实务9 安装Oracle软件并创建完数据库后，服务内的ORACLESID显示
实务9 “启动”而不是“已启动”
实务10 安装Oracle时，报告错误“Thrown when the IP address of a host
实务10 cannot be determined”
实务11 安装Oracle时，报告错误“无法读取C：/Program Files/Oracle/
实务11 Inventory/ ContentsXML/ comps.xml，丢失某些产品清单信息”
实务12 安装时，提示“安装程序交换区C：\Documents and Settings\
实务12 Administrator\Local Settings\Temp\OraInstall没有足够的磁盘空间，
实务12 请再装备一些磁盘空间，然后再试” 实务
实务13 创建数据库时，出现错误“ORA-03113： end-of-file on
实务13 communication channel”
实务14 安装Oracle时，报告错误“ORA-27102：out of memory”
实务15 在Linux（UNIX）环境下成功安装了Oracle g，从Windows
实务15 下用IE登录Oracle g的em时，按钮显示为“□□” 实务
实务16 在Linux AS4安装Oracle i（9.2.X.X），当执行runInstaller时，出现错误
实务17 是否可以在同一机器上既装Oracle i又装Oracle i 实务
实务18 安装Oracle i时，遇到错误“invalid end header format” 实务
实务19 在同一台机器上同时安装Oracle i与Oracle g
实务20 安装Oracle时，报告错误“ORA-27123：unable to attach to shared
实务20 memory segment”。 实务
实务21 安装Oracle时，报告错误，不能够写/tmp目录 实务
实务22 安装Oracle g时，报告操作系统版本（operating system version）
实务22 检查失败之案例一 实务
实务23 在安装Oracle g时，报告补丁包（Service Pack）检查失败 实务
实务24 安装Oracle时，报告显示器（monitor）设置检查失败
实务25 Oracle安装完成以后，为什么在提示符下输入sqlplus，提示命令不存在
实务26 安装Oracle时，报告打开共享对象文件libawt.so：libXp.so.6错误 实务
实务27 安装Oracle时，报告错误“…cannot restore segment prot after reloc：
实务27 Permission denied” 实务
实务28 安装Oracle时，报告错误“…libaio.so.1： cannot open shared object file” 实务
实务29 在Windows上安装Oracle，临时目录的空间充足，却报告不能够
实务29 写临时目录
实务30 安装Oracle到一定进度时，报告错误“加载数据库时出错：areasQueries”
实务31 Oracle i在奔腾4（P4）机器上安装的异常处理
实务32 安装Oracle时，报告先决条件检查失败
实务33 如何标识已经存在的Oracle根目录（Oracle Base Directory） 实务
实务34 如何标识已经存在的Oracle清单目录（Oracle Inventory Director）
实务35 如何标识已经存在的Oracle主目录（Oracle Home Directory） 实务
第3章 有米之炊——数据库的创建与删除
实务36 使用DBCA创建数据库时，报告错误“ORA-12547: TNS: lost contact” 实务
实务37 使用DBCA创建数据库时，报告错误“ORA-12571: TNS:packet writer failure”
实务38 使用DBCA创建数据库时，报告错误“ORA-27123: unable to attach to shared memory segment”
实务39 手工创建数据库时，如何查找数据库创建失败的原因
实务40 手工创建数据库时，报告错误“ORA-01504: database name 'TT' does not match parameter db_name 'man'”
实务41 手工创建数据库，启动实例时，报告错误“ORA-24324: service handle not initialized”
实务42 手工创建数据库时，报告错误“ORA-27038: created file already exists” 实务
实务43 手工创建数据库时，报告错误“ORA-01100: database already mounted”
实务44 手工重建数据库时，报告错误“ORA-01092: ORACLE instance terminated. Disconnection forced”之案例一 实务
实务45 手工重建数据库时，报告错误“ORA-01092: ORACLE instance terminated. Disconnection forced”之案例二 实务
实务46 手工重建数据库时，报告错误“ORA-01092: ORACLE instanceterminated. Disconnection forced”之案例三
实务47 手工创建数据库时，报告错误“ORA-01034: ORACLE not available”
实务48 手工创建数据库，启动实例时，后台进程启动失败（如ORA-00444:background process "LGWR" failed while starting）
实务49 手工创建数据库，启动实例时，报告参数user_dump_dest错误
第4章 Oracle网络管理并不难
实务50 启动监听器时，报告错误“无法找到指定的路径” 实务
实务51 连接数据库时，报告错误“TNS-12541：TNS:no listener”（没有监听器）之案例一
实务52 连接数据库时，报告错误“TNS-12541：TNS:no listener”（没有监听器）之案例二
实务53 连接数据库时，报告错误“TNS-12541：TNS:no listener”（没有监听器）之案例三
实务54 如何修改监听器的端口号
实务55 启动监听器时，报告错误“TNS-12545：Connect failed because target host or object does not exist”案例一 实务
实务56 启动监听器时，报告错误“TNS-12545：Connect failed because target host or object does not exist”案例二 实务
实务57 客户端连接数据库时，报告权限不足（ORA-01031：insufficient privileges）
实务58 以SYSDBA的身份登录数据库，报告错误“ORA-12518：TNS:listener could not hand off client connection” 实务
实务59 连接数据库时，报告错误“TNS-12538：TNS:no such protocol adapter”
实务60 如何禁止以操作系统认证方式登录Oracle 实务
实务61 连接数据库时，报告错误“ORA-12505: TNS:listener does not currently know of SID given in connect descriptor”
实务62 连接数据库时，报告错误“TNS-03505 Failed to resolve name”（无法解析服务名）之案例一
实务63 连接数据库时，报告错误“TNS-03505：Failed to resolve name”（无法解析服务名）之案例二
实务64 连接数据库时，报告错误“TNS-03505：Failed to resolve name”（无法解析服务名）之案例三
实务65 连接数据库时，报告错误“TNS-03505：Failed to resolve name”（无法解析服务名）之案例四
实务66 连接数据库时，报告错误“TNS-12535：TNS:operation timed out”之案例一 实务
实务67 连接数据库时，报告错误“TNS-12533：TNS:illegal ADDRESS parameters”
实务68 连接数据库时，报告错误“TNS-12504：TNS：listener was not given the SID in CONNECT_DATA”
实务69 协议适配器错误（ORA-12560: TNS:protocol adapter error）之案例一
实务70 协议适配器错误（ORA-12560: TNS:protocol adapter error）之案例二
实务71 连接数据库时，报告错误“ORA-03113: end-of-file on communication channel，ORA-24315: illegal attribute type” 实务
实务72 连接数据时，报告错误“ORA-12545：Connect failed because target host or object does not exist”之案例三 实务
实务73 连接数据库时，报告错误“ORA-12154: TNS:could not resolve the connect identifier specified”
实务74 连接数据库时，报告错误“ORA-12162: TNS:net service name is incorrectly specified”
实务75 连接数据库时，报告错误“ORA-12514: TNS:listener does not currently know of service”
实务76 连接数据库时，报告错误“ORA-12523: TNS:listener could not find instance appropriate for the client connection”
实务77 连接数据库时，报告错误“ORA-12520: TNS:listener could not find available handler for requested type of server” 实务
实务78 连接数据库时，报告错误“ORA-12170: TNS:Connect timeout occurred”
实务79 连接数据库时，报告错误“TNS-12535：TNS:operation timed out”之案例二 实务
实务80 连接数据库时，报告错误“ORA-12537: TNS:connection closed” 实务
第5章 系统管家婆——SQL*Plus的使用 实务
实务81 如何定义绑定变量（Bind Variables）
实务82 使用SQL*Plus，如何登录数据库
实务83 如何在SQL*Plus中执行SQL语句
实务84 如何把SQL*Plus设置成自动提交模式（AUTOCOMMIT）
实务85 在SQL*Plus中，如何终止SQL语句的执行
实务86 如何在SQL*Plus中执行操作系统命令（OS COMMANDS） 实务
实务87 在SQL*Plus中，如何执行一段PL/SQL块（PL/SQL Blocks）
实务88 如何在SQL*Plus中执行存储过程
实务89 如何重复执行一条SQL语句
实务90 如何在启动SQL*Plus时，不出现登录界面
实务91 如何修改Oracle日期显示格式
实务92 如何把SQL缓冲区的内容保存到操作系统文件中
实务93 如何编辑缓冲区中的SQL语句
实务94 如何运行一个SQL脚本文件
实务95 如何将查询结果保存到文件中
实务96 如何知道SQL语句的执行速度
实务97 如何查看SQL*Plus的系统变量
实务98 如何设置SQL*Plus的系统变量
实务99 如何改变SQL*Plus的启动选项
实务100 如何关闭SQL*Plus
实务101 如何禁止用户在SQL*Plus中执行指定命令
实务102 如何列出SQL缓冲区中的内容 实务
实务103 如何把SQL脚本文件的内容装载到SQL*Plus的缓冲区中
实务104 如何查出SQL*Plus默认使用哪个编辑器（editor）
实务105 如何设置SQL*Plus默认使用哪个编辑器（editor）
实务106 如何把SQL*Plus所有环境变量的设置保存到操作系统文件中
实务107 在SQL*Plus中，为什么无法显示小时
实务108 为什么SQL语句的返回结果非常零乱
第6章 有始有终——数据库的启动与关闭
实务109 如何使数据库自动启动/关闭之UNIX/Linux篇 实务
实务110 如何使数据库自动启动/关闭之Windows篇
实务111 如何把数据库启动到NOMOUNT状态
实务112 如何把数据库启动到MOUNT状态
实务113 如何打开数据库（Open）
实务114 如何一步一步启动数据库
实务115 如何用特定的初始化参数文件（Initialization Parameter File，FILE）启动数据库
实务116 如何把数据库启动到限制模式（RESTRICT） 实务
实务117 如何以只读模式（Read Only）打开数据库
实务118 如何把数据库启动到恢复模式（RECOVER） 实务
实务119 如何重新启动数据库（RESET）
实务120 启动数据库时，报告错误“LRM-00123: invalid character found in the input file”
实务121 启动数据库时，报告“权限不足”（ORA-01031: insufficient privileges）
实务122 启动数据库时，报告错误“ORA-07217: sltln: environment variable cannot be evaluated” 实务
实务123 连接数据库时，提示错误“ORA-27101: shared memory realm does not exist” 实务
实务124 启动数据库时，报告错误“ORA-00600:internal error code,arguments: [num],[?],[?],[?],[?] ”
实务125 如何判断数据库是否已经启动
实务126 如何知道数据库处于何种状态
实务127 打开数据库时，报告错误“ORA-01507: database not Mounted” 实务
实务128 启动数据库时，报告错误“未知参数名”（LRM-00101: unknownsarameter name 'ss'）
实务129 启动数据库时，报告错误“不能打开参数文件”（ORA-01078: failure in processing system parameters） 实务
实务130 启动数据库时，报告错误“LRM-00116: syntax error at 'DB_BLOCK_SIZE' following '='”
实务131 启动数据库时，报告错误“ORA-24323: value not allowed” 实务
实务132 启动数据库时，报告错误“标识控制文件时，发生错误”（ORA-00205: error in identifying control file, check alert log for more info） 实务
实务133 启动数据时，报告错误“ORA-00381: cannot use both new and old parameters for buffer cache size specification”
实务134 启动数据库时，报告错误“数据库已经运行”（ORA-01081: cannot start already-running ORACLE - shut it down first） 实务
实务135 启动数据库时，报告错误“ORA-19809: limit exceeded for recovery file”
实务136 启动数据库时，数据库被挂起之案例一
实务137 启动数据库时，数据库被挂起之案例二
实务138 启动数据库时，数据库被挂起之案例三
实务139 启动数据库时，报告错误“ORA-10997: another STARTUP/SHUTDOWN operation of this instance inprogress”
实务140 启动数据库时，报告错误“ORA-02778: Name given for the log directory is invalid” 实务
实务141 启动数据库时，报告错误“ORA-01565: error in identifying file 'E:\oracle\ product\10.2.0\db_1/dbs/SPFILEWM.ora'”
实务142 启动数据时，报告错误“ORA-27046: file size is not a multiple of logical block size”
实务143 启动数据库时，报告错误“ORA-00106: cannot STARTUP/SHUTDOWN database when connected to a dispatcher”
实务144 如何以NORMAL方式关闭数据库
实务145 如何以IMMEDIATE方式关闭数据库
实务146 如何以TRANSACTIONAL方式关闭数据库
实务147 如何以ABORT方式关闭数据库 实务
实务148 为什么关闭数据库如此慢
实务149 连接数据库时，报告错误“ORA-01090: SHUTDOWN in progress - connection is not permitted”
实务150 登录数据库时，报告错误“ORA-01033: Oracle initialization or shutdown in progress”
实务151 为什么使用SHUTDOWN IMMEDIATE命令不能关闭数据库 实务
第7章 理清两个模式问题——专有/共享服务器模式
实务152 如何把数据库配置成共享服务器模式（Shared Server）之手工篇 实务
实务153 如何把数据库配置成共享服务器模式（Shared Server）之DBCA篇
实务154 数据库已经被配置成共享服务器模式，如何请求一个专有服务器连接
实务155 如何确定数据库中有多少个共享服务器进程（Shared Server Processes） 实务
实务156 如何确定数据库中有多少个调度进程（Dispatcher）
实务157 如何增加调度进程（Dispatcher）的数量 实务
实务158 如何增加共享服务器进程（Shared Server Processes）的数量
实务159 如何关闭指定的调度进程
实务160 使用数据库时，报告错误“ORA-00104: deadlock detected; all public servers blocked waiting for resources”
实务161 关闭数据库时，报告错误“ORA-00106: cannot STARTUP/SHUTDOWN database when Connected to a dispatcher”
实务162 启动数据库时，报告错误“ORA-00132: syntax error or unresolved network name 'listeners_wm'” 实务
实务163 如何把数据库从共享服务器模式（Shared Server）改成专有服务器模式（Dedicatied Server）之手工篇
实务164 如何把数据库从共享服务器模式（Shared Server）改成专有服务器模式（dedicatied server）之DBCA篇
实务165 如何判断数据库是运行在专有服务器模式，还是共享服务器模式
实务166 数据库已经被配置成共享服务器模式，为什么客户端请求到的还是专有服务器连接？ 实务
实务167 如何判断客户端请求到的是专有服务器连接还是共享服务器连接
第8章 掌握两个管理问题——表空间和数据文件的管理
实务168 如何创建大文件表空间
实务169 如何创建表空间
实务170 如何删除表空间
实务171 如何知道表空间PRODUCT由哪些数据文件组成
实务172 如何创建非标准块表空间
实务173 如何把字典管理的表空间（Dictionary Extent Management）转换成本地管理的表空间Local Extent Management）
实务174 如何把本地管理的表空间（Local Extent Management）转换成字典管理的表空间（Dictionary Extent Management）
实务175 为什么表空间离线后无法在线
实务176 用DELETE语句删除表中数据以后，为什么表空间的空闲空间没有增加 实务
实务177 如何禁止任何人写表空间test
实务178 如何对一个表空间进行扩展
实务179 如何限制某个用户对表空间的使用（Tablespace Quota）
实务180 如何使只读表空间可读/写 实务
实务181 如何使一个表空间在线
实务182 如何使一个表空间离线
实务183 如何重命名表空间
实务184 如何知道数据库中有哪些表空间
实务185 如何知道一个表空间的存储参数（Storage Parameters）
实务186 如何知道表空间的空间使用情况
实务187 如何知道哪些表空间是本地管理的
实务188 把表空间设置成只读，为什么很长时间还没有完成
实务189 如何收缩表空间
实务190 如何使用户能够使用另外一个表空间
实务191 如何把永久表空间转换成临时表空间
实务192 如何知道数据库中所有用户的默认表空间
实务193 如何得到创建表空间的SQL语句
实务194 对表空间进行操作时，报告错误“表空间不存在”
实务195 删除表空间时，报告错误“ORA-22868: table with LOBs contains Segment in different Tablespaces”
实务196 创建表时，报告错误：ORA-01950: no privileges on Tablespace 'USERS'”
实务197 删除表空间时，报告错误“ORA-01549: Tablespace not empty, use INCLUDING CONTENTS option”
实务198 删除表空间时，报告错误“ORA-02429: cannot DROP index used for enforcement of unique/primary key” 实务
实务199 创建表时，报告错误“ORA-01536: space quota exceeded for Tablespace 'TBST'” 实务
实务200 创建表空间时，报告错误“ORA-27038: created file already exists（创建的数据文件已经存在） 实务 201 创建表空间时，报告错误“ORA-12913: Cannot create dictionary managed Tablespace”
实务202 报告错误“ORA-03212:temporary Segment cannot be create in locally-managed Tablespace”
实务203 创建表时，报告错误“ORA-01659: unable to allocate MINEXTENTS beyond in Tablespace TP”
实务204 创建表时，报告错误“Ora-01658:unable to create INITAL Extent for Segment in Tablespace TP”
实务205 删除表空间时，报告错误“ORA-23515: materialized views and/or their indices exist in the tablespac” 实务
实务206 不能删除表空间，报告错误“ORA-00942: table or view does not exist”
实务207 创建表空间时，报告错误“ORA-29339: Tablespace Block SIZE 16384 does not match configured Block Sizes”
实务208 删除表空间时，报告错误“ORA-25183: index-organized table top index Segment is in a different Tablespace”
实务209 往表空间中添加数据文件时，报告错误“ORA-00059: maximum
number of DB_FILES exceeded”
实务210 往表中插入数据时，报告错误“ORA-01653: unable to extend table REP.PHONE_ RESUME by in Tablespace TBS_PRO”
实务211 往表中插入数据时，报告错误“ORA-1654: unable to extend index PRODUCT. IND_STY by in Tablespace IND_TBS”
实务212 如何创建临时表空间
实务213 如何知道数据库中有哪些临时表空间
实务214 如何知道数据库使用哪个临时表空间作为默认临时表空间（Default Temporary Tablespace） 实务
实务215 如何改变数据库默认的临时表空间
实务216 如何重建临时表空间
实务217 临时表空间为空的错误（ORA-25153：temporary Tablespace is empty）
实务218 删除临时表空间时，报告错误“ORA-12906: cannot DROP default temporary Tablespace” 实务
实务219 改变临时文件时，报告错误“ORA-01516: nonexistent log file, datafile, or TEMPFILE”
实务220 报告错误“ORA-01652:unable to extend temp Segment by inTablespace TEMP”
实务221 创建临时表空间时，提示错误“ORA-25139: invalid option for CREATE TEMPORARY TABLESPACE”
实务222 如何创建回滚表空间
实务223 如何删除回滚表空间
实务224 如何查看数据库中回滚段的管理方式
实务225 如何往回滚表空间中增加数据文件
实务226 如何显示数据库当前正在使用的回滚表空间
实务227 如何切换回滚表空间
实务228 如何使用回滚段自动管理
实务229 如何知道数据库中有哪些回滚表空间
实务230 如何重建数据库正在使用的当前回滚表空间（活动回滚表空间）
实务231 使用数据库时，报告错误“ORA-01650: unable to extend rollback Segment RB01 by in Tablespace UNDOTBS1”
实务232 如何移动数据文件
实务233 如何删除数据文件
实务234 如何使数据文件离线
实务235 如何知道数据文件的使用情况
实务236 如何使数据文件PRODUCT1在线
实务237 如何重命名数据文件PRODUCT2
实务238 如何增加数据文件的尺寸
实务239 如何使数据文件自动扩展
实务240 如何知道整个数据库中有哪些数据文件
实务241 改变数据文件的尺寸时，报告错误“ORA-03297: file contains used data beyond requested RESIZE value”
实务242 不能扩展数据文件（ORA-01237: cannot extend datafile ） 实务
实务243 往表空间中添加数据文件时，报告错误“ORA-01641: Tablespace 'TBS_CONTRO' is not online - cannot add data file”
第9章 进程管理 实务
第10章 内存管理 实务
第11章 用户管理 实务
第12章 数据导出 实务
第13章 数据导入 实务
第14章 重中之重——控制文件的管理
第15章 成为数据库的最高统治者——口令文件（Password File）管理
第16章 联机日志文件管理 实务
第17章 参数文件（PFILE/SPFILE）管理
第18章 全球应用——分布式数据库疑难攻略 实务
第19章 并不陌生的问题——裸设备 实务
第20章 备份/恢复之基石——归档（Archivelog）管理 实务
第21章 必行之举——数据库备份
第22章 失而复得——数据库恢复
第23章 数据库通用语言——SQL语句
第24章 模式对象（Schema Object）的管理
第25章 PL/SQL应用程序开发 实务
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ORACLE数据库精讲与疑难解析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle WebLogic Server开发权威指南
目    录

第1章  在WebLogic中构建Web
应用程序	1
1.1  Java servlet和JSP中的重要
概念	1
1.1.1  servlet的特征	1
1.1.2  JSP的特征	6
1.2  Web应用程序最佳实践	11
1.2.1  保证正确的错误处理	11
1.2.2  使用JSTL标记减少scriptlet
代码	13
1.2.3  对选定的行为使用自定义标记	16
1.2.4  对常见行为使用servlet过滤器	18
1.2.5  使用servlet和JSP页面创建
Excel文件	22
1.2.6  查看产生的servlet代码	25
1.3  本章回顾	26
第2章  选择Web应用程序体系结构	27
2.1  体系结构的关键概念	27
2.1.1  Java EE应用程序的层次	27
2.1.2  MVC体系结构	28
2.1.3  通用Java EE设计模式	29
2.2  表示层体系结构的选择	29
2.2.1  表示层需求	29
2.2.2  有关体系结构的其他考虑	39
2.3  可选的表示层体系结构	39
2.3.1  以JSP为核心的体系结构	40
2.3.2  以servlet为核心的体系结构：
Struts	41
2.3.3  以servlet为核心的体系结构：
Spring MVC	42
2.4  本章回顾	45
第3章  设计Java EE应用程序示例	47
3.1  应用程序需求	47
3.2  业务领域模型	48
3.3  表示层需求	48
3.4  Web应用程序体系结构	50
3.5  表示方法	51
3.5.1  自组装	52
3.5.2  母版页组装	55
3.5.3  使用Tiles框架进行外部
视图组装	56
3.6  业务层接口	58
3.6.1  控制器调用业务服务	58
3.6.2  控制器为JSP填充表单	60
3.6.3  更新要求显式的服务调用	61
3.6.4  表示层组件之间的关系	61
3.7  本章回顾	62
第4章  构建Web应用程序示例	63
4.1  应用程序组件概述	63
4.2  构建应用程序骨架	65
4.3  构建用户站点组件	65
4.3.1  预订信息组件	65
4.3.2  核心预订流程组件	67
4.3.3  提供服务组件	90
4.4  管理站点组件的结构	91
4.4.1  身份验证和授权组件	91
4.4.2  酒店维护组件	94
4.5  本章回顾	107
第5章  打包和部署WebLogic Web
应用程序	109
5.1  打包Web应用程序	110
5.1.1  Web应用程序目录结构	110
5.1.2  Web应用程序描述符文件	112
5.1.3  预编译JSP组件	119
5.1.4  创建一个分解式 Web应用
程序	121
5.1.5  创建一个Web应用程序的
归档文件	125
5.2  部署Web应用程序	126
5.2.1  自动部署	126
5.2.2  WebLogic部署工具和Ant
任务	128
5.2.3  WebLogic控制台部署	130
5.2.4  为bigrez.com创建必要的用户
和组	132
5.3  本章回顾	133
第6章  在WebLogic Server中构建
企业JavaBean	135
6.1  EJB技术概述	135
6.2  EJB 3.0简介	136
6.3  EJB组件类型	137
6.3.1  无状态会话bean	137
6.3.2  有状态会话bean	139
6.3.3  消息驱动的bean	140
6.3.4  拦截器	141
6.4  Java持久化API	142
6.4.1  JPA的历史	142
6.4.2  JPA概念	144
6.4.3  一个JPA示例	144
6.4.4  应用JPA	164
6.5  WebLogic Server EJB容器	165
6.5.1  EJB容器基础	165
6.5.2  WebLogic Server中EJB的
生命周期	165
6.6  通用的WebLogic Server EJB
特性	167
6.6.1  EJB的部署和重新部署	167
6.6.2  动态EJB编译	167
6.6.3  EJB的远程业务接口和JNDI	168
6.6.4  EJB之间的引用	170
6.7  会话bean的特性	175
6.7.1  无状态会话EJB缓冲池	175
6.7.2  有状态会话EJB的缓存管理	176
6.7.3  有状态会话EJB的内存中
复制	178
6.7.4  指向会话bean的句柄	180
6.7.5  幂等方法	180
6.8  消息驱动的bean的特性	180
6.9  OpenJPA和Kodo特性	181
6.9.1  Kodo部署描述符文件	182
6.9.2  获取组	182
6.9.3  预先获取	184
6.9.4  乐观锁版本策略	184
6.9.5  大结果集	187
6.9.6  二级缓存	188
6.9.7  控制刷新行为	190
6.9.8  逆向管理	190
6.9.9  混合继承策略	191
6.9.10  预处理语句缓存	191
6.10  使用部署描述符还是标注	191
6.10.1  部署计划	192
6.10.2  标注、描述符、计划和
依赖注入	193
6.11  本章回顾	195
第7章  构建EJB应用程序示例	197
7.1  业务层需求	197
7.1.1  业务逻辑需求	197
7.1.2  对象关系映射需求	199
7.1.3  数据访问需求	203
7.1.4  其他业务层需求	203
7.1.5  业务层需求的回顾	203
7.2  可选的业务层体系结构	204
7.2.1  SLSB和会话外观模式的
需求	204
7.2.2  使用JDBC的无状态会话
EJB	205
7.2.3  使用EJB 2.1 CMP实体bean
的无状态会话EJB	207
7.2.4  使用JPA的无状态会话EJB	209
7.3  bigrez.com的实现	211
7.3.1  数据库模式	211
7.3.2  域模型	212
7.3.3  服务	217
7.3.4  单元测试	222
7.3.5  添加乐观锁	223
7.4  使用TopLink而不是Kodo	223
7.4.1  希望使用TopLink的理由	224
7.4.2  让bigrez.com使用TopLink	224
7.5  本章回顾	227
第8章  打包和部署WebLogic应用
程序	229
8.1  创建EJB归档文件	229
8.2  打包JPA持久化单元	236
8.3  企业应用程序	237
8.3.1  企业应用程序目录结构	239
8.3.2  企业应用程序的描述符文件	241
8.3.3  分解式部署	244
8.3.4  捆绑库	246
8.3.5  共享Java EE库和可选包	248
8.3.6  其他类型的模块	249
8.3.7  自定义类加载器	250
8.4  打包bigrez.com	251
8.5  部署应用程序	254
8.5.1  创建必需的服务	255
8.5.2  自动部署和weblogic.Deployer	256
8.5.3  WebLogic控制台部署	257
8.6  本章回顾	257
第9章  开发和部署Web服务	259
9.1 	总结Web服务标准	259
9.2  用WebLogic Server创建Web
服务	260
9.2.1  Web服务的容器框架	260
9.2.2  开发WebLogic Server的Web
服务	261
9.2.3  开发Web服务客户端	274
9.3  高级技术	278
9.3.1  使用JAX-RPC	278
9.3.2  理解style和use	278
9.3.3  影响调用哪个操作	280
9.3.4  创建更多动态的Web服务	282
9.3.5  使用Web服务的处理程序	288
9.3.6  使用SOAP附件	292
9.3.7  实现有状态的Web服务	296
9.3.8  实现异步的Web服务	297
9.3.9  自定义Java和XML之间的
映射	300
9.4  使用Web服务安全	301
9.4.1  定义安全策略	302
9.4.2  传输级安全	303
9.4.3  消息级安全	305
9.4.4  Web服务的安全配置	311
9.5  在bigrez.com中添加Web
服务	312
9.6  本章回顾	314
第10章  使用WebLogic JMS	315
10.1  JMS的重要概念	315
10.1.1  了解消息传递模型	315
10.1.2  回顾JMS API	316
10.2  WebLogic JMS提供程序	321
10.2.1  了解WebLogic JMS
服务器	321
10.2.2  群集WebLogic JMS	321
10.2.3  WebLogic JMS的客户端	330
10.2.4  配置WebLogic JMS	332
10.3  WebLogic JMS应用程序设计	344
10.3.1  选择一种目标类型	344
10.3.2  定位目标	344
10.3.3  选择合适的消息类型	345
10.3.4  压缩大消息	347
10.3.5  选择一种消息确认策略	347
10.3.6  设计消息选择器	348
10.3.7  选择消息的过期策略	351
10.3.8  处理有害消息	353
10.3.9  处理消息顺序的问题	355
10.3.10  使用事务	360
10.3.11  使用多播会话	361
10.3.12  处理请求/响应样式的
消息交换	362
10.4  WebLogic JMS应用程序编程	365
10.4.1  WebLogic JMS与EJB和
servlet的组合使用	365
10.4.2  在服务器中使用异步消息	367
10.5  外部JMS提供程序	372
10.5.1  了解消息传递桥	372
10.5.2  了解存储转发服务	373
10.5.3  使用消息驱动的bean	375
10.5.4  把外部JMS对象映射到
WebLogic JNDI上	375
10.5.5  集成Oracle高级队列	376
10.5.6  选择一种集成策略	378
10.6  本章回顾	379
第11章  使用WebLogic安全性	381
11.1  WebLogic安全概述	381
11.2  WebLogic安全框架	387
11.2.1  嵌入式LDAP服务器	387
11.2.2  安全领域和提供程序	389
11.3  使用外部安全存储	400
11.3.1  管理外部 LDAP 身份
验证	400
11.3.2  管理RDBMS身份验证	402
11.4  设置SSL/TLS	404
11.4.1  SSL和X.509证书概述	404
11.4.2  获取X.509证书	405
11.4.3  配置单向SSL	407
11.4.4  配置双向SSL	408
11.4.5  调试SSL的问题	411
11.5  编写安全敏感的Java客户端	412
11.5.1  编写使用JAAS的Java
客户端	412
11.5.2  编写使用SSL的Java
客户端	415
11.6  管理应用程序的安全	420
11.6.1  应用程序安全模型	420
11.6.2  配置Java EE应用程序的
安全	420
11.6.3  配置WebLogic Server应用
程序的安全	428
11.6.4  启动WebLogic Server	432
11.7  单点登录	432
11.7.1  SAML语言	433
11.7.2  配置跨域安全和单点登录	440
11.7.3  自定义身份验证提供程序	445
11.8  本章回顾	446
第12章  在WebLogic Server中管理
和部署应用程序	447
12.1  WebLogic体系结构的重要
概念	447
12.1.1  域体系结构	447
12.1.2  WebLogic Server体系结构	449
12.1.3  WebLogic Server群集体系
结构	456
12.1.4  管理服务器	463
12.1.5  节点管理器	465
12.2  WebLogic Server管理的重要
概念	466
12.2.1  服务器状态	466
12.2.2  服务器自我健康监控	467
12.2.3  网络信道	468
12.3  配置WebLogic Server的域	470
12.3.1  建立一个新域	472
12.3.2  配置服务器	473
12.3.3  配置群集	475
12.3.4  配置网络信道	478
12.3.5  建立节点管理器	481
12.3.6  操作系统的配置	486
12.3.7  Java虚拟机的配置	487
12.3.8  Web服务器插件的配置	487
12.3.9  管理端口和信道的配置	492
12.3.10  为WebLogic Server配置
应用程序	494
12.4  监视 WebLogic Server 应用
程序	511
12.4.1  使用WebLogic脚本工具	511
12.4.2  使用弃用的命令行管理
工具	515
12.4.3  通过WebLogic控制台进行
监视	516
12.4.4  通过JMX实现编程监视	518
12.4.5  通过SNMP监视	522
12.5  管理 WebLogic Server 应用
程序	529
12.5.1  诊断应用程序的问题	529
12.5.2  版本化应用程序	540
12.5.3  处理故障情况	542
12.6  本章回顾	551
第13章  优化WebLogic Server的
性能	553
13.1  系统性能概述	553
13.1.1  核心原则	554
13.1.2  基于WebLogic Server的
应用程序的调优	555
13.2  性能最佳实践	573
13.2.1  可提高性能的设计方法	573
13.2.2  理解 Web 容器的最佳
实践	574
13.2.3  理解EJB容器的最佳实践	576
13.2.4  应用数据库访问的最佳
实践	578
13.3  诊断性能问题	583
13.3.1  准备好故障诊断	583
13.3.2  识别瓶颈并消除瓶颈	584
13.3.3  解决问题	585
13.3.4  常见应用服务器性能问题	586
13.3.5  Java栈跟踪	588
13.4  本章回顾	593
第14章  开发环境的最佳实践	595
14.1  定义需要的硬件和软件	595
14.2  安装WebLogic Server软件	598
14.3  开发项目结构	600
14.4  优化开发周期	601
14.4.1  分解目录开发	601
14.4.2  FastSwap	603
14.5  建立构建过程	604
14.5.1  持续集成	605
14.5.2  代码检查和报告工具	606
14.6  集成开发环境	606
14.6.1  先决条件	607
14.6.2  为bigrez.com配置Eclipse	607
14.6.3  为bigrez.com配置
JDeveloper	612
14.6.4  通过IDE进行调试	615
14.7  创建一个单元测试基础设施	616
14.7.1  单元测试的重要性	616
14.7.2  JUnit测试框架	617
14.7.3  容器外测试	619
14.7.4  测试Web界面	622
14.7.5  Web服务	624
14.7.6  性能和并发性测试	624
14.8  本章回顾	625
第15章  生产环境的最佳实践	627
15.1  部署策略	627
15.1.1  评价部署策略	628
15.1.2  服务器部署策略	629
15.1.3  单站点部署策略	630
15.1.4  多站点部署策略	635
15.1.5  设计多站点WebLogic
群集	635
15.1.6  实现跨多站点的群集	638
15.1.7  在每一个站点实现一个
群集	639
15.2  全局和本地流量管理	642
15.2.1  使用负载均衡器	642
15.2.2  配合WebLogic Server使用
本地负载均衡器	643
15.2.3  配合WebLogic Server使用
全局负载均衡器	644
15.3  生产环境的安全策略	645
15.3.1  理解应用程序的数据流	645
15.3.2  理解防火墙布局	645
15.3.3  使用连接过滤器	647
15.3.4  锁定Web应用程序	648
15.3.5  检查其他安全因素	650
15.3.6  使用SSL硬件加速	651
15.4  本章回顾	651
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle WebLogic Server开发权威指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle基础教程
第1章 关系数据库系统与oracle 10g介绍
1.1 数据库管理系统
1.1.1 个人系统
1.1.2 基于服务器的系统
1.2 以实体和联系描述系统
1.3 理解关系数据库模型
1.3.1 主键
1.3.2 范式
1.3.3 联系和外键
1.3.4 对象关系模型
1.4 安装oracle工具
1.4.1 安装oracle数据库管理系统
1.4.2 删除oracle数据库管理系统
1.4.3 安装开发工具包
1.4.4 企业表单和报表服务
1.5 oracle环境研究
1.5.1 sql*plus和isql*plus
1.5.2 开发工具包
1.5.3 oracle企业管理器
1.6 对本书数据库的介绍
.　　1.6.1 redwood realty
1.6.2 coffee merchant
1.6.3 rowing ventures
1.6.4 broadcloth clothing
1.7 小结
第2章 sql和sql*plus概述
2.1 引言
2.1.1 sql命令的分类
2.1.2 剖析一个sql语句
2.1.3 获得联机帮助
2.2 与数据库的接口
2.3 使用dos命令行的sql*plus
2.3.1 登录oracle
2.3.2 输入并运行sql命令
2.3.3 编辑sql命令
2.4 使用sql*plus for windows
2.4.1 登录oracle
2.4.2 输入并运行sql命令
2.4.3 编辑sql命令
2.4.4 退出sql*plus
2.5 使用isql*plus
2.5.1 登录oracle
2.5.2 输入并运行sql命令
2.5.3 编辑sql命令
2.5.4 退出isql*plus
2.6 理解sql语句
2.6.1 运行sql查询
2.6.2 考察数据定义语言的语句
2.6.3 考察数据操纵语言的语句
2.6.4 考察事务控制语句
2.6.5 考察数据控制语言的语句
2.7 使用sql*plus命令扩展功能
2.7.1 显示表结构
2.7.2 用文件记录打印信息
2.7.3 格式化命令
2.7.4 定制sql*plus环境
2.7.5 执行脚本文件
2.7.6 使用变量
2.7.7 其他sql*plus命令
2.7.8 建立和运行脚本文件
2.8 小结
第3章 创建、修改、重命名和删除数据库的表
3.1 设计关系数据库
3.1.1 与数据库用户交谈
3.1.2 确定用户需求
3.1.3 确定业务对象
3.1.4 规范设计
3.2 理解oracle用户账号
3.3 针对personal oracle用户的进一步说明
3.3.1 创建用户
3.3.2 用另一个用户名和口令登录
3.3.3 更改用户的系统权限
3.3.4 更改用户口令
3.3.5 更改自己的口令
3.3.6 删除用户
3.4 创建表
3.4.1 oracle数据类型
3.4.2 用sql*plus创建表
3.4.3 添加表和列的注释
3.5 定义和使用约束
3.5.1 理解约束
3.5.2 命名约束
3.5.3 定义约束
3.5.4 创建列约束和表约束
3.5.5 给列赋默认值
3.6 更改表及约束
3.6.1 添加、启用或禁用约束
3.6.2 删除或重命名约束
3.6.3 更改列默认值或数据类型
3.6.4 添加、删除和重命名列
3.6.5 标记列为不使用并删除不使用的列
3.7 显示表名、结构及注释
3.7.1 列出数据库表
3.7.2 查看关于列的信息
3.7.3 查看表约束和列约束
3.7.4 查看表注释和列注释
3.8 删除、恢复和重命名表
3.8.1 删除表
3.8.2 恢复被删除的表
3.8.3 清除回收站
3.8.4 重命名表
3.9 基于其他表创建表
3.10 小结
第4章 修改数据以及审计表的操作
4.1 将数据行插入表中
4.1.1 指定列的列表
4.1.2 处理完整性约束
4.1.3 省略列名
4.1.4 插入日期和时间
4.1.5 从其他表中插入数据
4.1.6 创建和使用序列
4.2 更新数据
4.2.1 更新语句
4.2.2 case结构介绍
4.2.3 用case结构更新数据
4.2.4 替代变量
4.3 删除行和截断表
4.3.1 删除选择的行
4.3.2 删除所有行
4.4 合并行
4.5 数据库事务
4.5.1 提交
4.5.2 回退
4.5.3 保留点
4.6 创建和使用数据库触发器
4.6.1 触发器介绍
4.6.2 创建和使用before触发器
4.6.3 创建一个after触发器审计表操作
4.6.4 创建和使用语句级触发器
4.6.5 显示、更改、删除触发器
4.7 小结
第5章 查询数据库
5.1 显示单个数据库表中的数据
5.1.1 编写select语句
5.1.2 选择所有的列
5.1.3 使用distinct显示唯一的行
5.1.4 中断失控的查询
5.1.5 使用搜索条件过滤结果
5.1.6 排序
5.1.7 在查询中包含计算
5.2 sql函数介绍
5.2.1 在查询中使用单行函数
5.2.2 使用聚集函数
5.2.3 对结果进行分组
5.2.4 用having子句过滤组
5.2.5 格式化sql*plus的输出并创建简单的报表
5.3 小结
第6章 创建多表查询和视图
6.1 创建和使用多表查询
6.1.1 联结具有匹配列值的表
6.1.2 理解其他联结类型和联结条件
6.1.3 集合操作符
6.1.4 使用子查询
6.2 创建和使用视图
6.2.1 视图的用途
6.2.2 定义和查询一个表的视图
6.2.3 用一个表的视图修改表数据
6.2.4 创建复杂视图
6.2.5 创建同义词以简化表引用
6.2.6 列出视图定义
6.2.7 删除视图
6.3 小结
第7章 使用pl/sql
7.1 pl/sql介绍
7.1.1 pl/sql的优点
7.1.2 pl/sql块的类型
7.2 理解匿名块
7.2.1 考察声明部分
7.2.2 考察可执行部分
7.2.3 考察异常处理部分
7.3 创建匿名块
7.3.1 初始化redwood realty数据库
7.3.2 编写匿名块
7.3.3 建立sql*plus环境
7.3.4 运行匿名的pl/sql块
7.3.5 修改匿名块显示多行
7.3.6 处理异常情况
7.4 理解显式游标
7.4.1 pl/sql循环结构介绍
7.4.2 使用显式游标和循环处理行
7.4.3 使用for循环处理显式游标
7.4.4 if语句介绍
7.5 有名块的介绍
7.6 创建、使用、显示并删除函数
7.6.1 创建并存储函数
7.6.2 调用函数
7.6.3 修改函数
7.6.4 显示并删除函数
7.7 创建、使用、显示和删除过程
7.7.1 过程的优点
7.7.2 创建并存储过程
7.7.3 调用存储过程
7.7.4 修改过程并重新编译和保存过程
7.7.5 显示和删除过程
7.8 小结
第8章 理解和使用forms builder
8.1 表单介绍
8.1.1 种主要的表单类型
8.1.2 表单服务体系结构
8.1.3 oracle表单的基本结构
8.2 用forms builder创建一个简单的主表单
8.2.1 forms builder向导
8.2.2 用run form按钮测试表单
8.2.3 用表单查询显示数据
8.3 修改表单
8.3.1 布局编辑器
8.3.2 对象导航器
8.3.3 基本属性
8.3.4 添加图像
8.3.5 添加查找列
8.3.6 创建一个值列表
8.3.7 自动执行查询的步骤
8.3.8 单选按钮和复选框
8.4 创建表格式表单和子表单
8.4.1 创建表格式表单
8.4.2 创建主表单和子表单
8.4.3 给网格添加显示列
8.4.4 设置格式掩码
8.5 小结
第9章 定制表单
9.1 设置表单结构
9.1.1 创建画布和简单的数据块
9.1.2 创建查询数据块
9.1.3 完成搜索工作
9.2 设计表单触发器
9.2.1 定义表单事件
9.2.2 创建和编辑触发器
9.2.3 调试触发器
9.2.4 处理错误
9.2.5 理解表单程序的作用域和生命周期
9.3 建立有用的表单工具
9.3.1 创建序列
9.3.2 验证表单输入
9.3.3 计算网格数据小计
9.4 使用多个画布
9.4.1 添加一个画布
9.4.2 叠加画布
9.4.3 标签画布
9.4.4 表单样式的评论
9.5 用jdeveloper创建web表单
9.5.1 修改listings表并建立服务器文件
9.5.2 创建数据连接和工作区
9.5.3 创建业务组件数据模型
9.5.4 创建java服务器页面显示数据
9.5.5 添加搜索表单
9.6 小结
第10章 创建和修改报表
10.1 报表开发器介绍
10.1.1 网络发布和纸质报表
10.1.2 报表的类型
10.1.3 oracle报表服务
10.2 建立和修改报表
10.2.1 报表结构
10.2.2 report builder
10.2.3 纸质设计和布局窗口
10.2.4 对象导航器窗口
10.3 增强报表的功能
10.3.1 对齐和调整列
10.3.2 设置格式掩码和属性
10.3.3 添加阴影和边框
10.3.4 插入页号和日期
10.3.5 添加文本框
10.4 定制报表
10.4.1 数据模型
10.4.2 添加字段
10.4.3 数据组结构及框架
10.4.4 手工创建报表
10.4.5 显示数据库中的映像
10.5 控制报表中的数据
10.5.1 创建用户参数
10.5.2 使用过滤器限制报表
10.5.3 创建报表触发器
10.6 创建定制模板
10.6.1 设计定制模板
10.6.2 应用模板
10.6.3 注册模板
10.7 定制web报表
10.7.1 动态报表的环境
10.7.2 更改web报表
10.7.3 给web报表添加图表
10.8 小结
第11章 建立集成应用
11.1 设计一个集成数据库应用
11.1.1 组织redwood realty
11.1.2 一致的外观
11.1.3 创建模板表单
11.1.4 创建和应用属性类和可视属性
11.1.5 应用模板表单和属性
11.2 在应用中连接表单和报表
11.2.1 启动表单
11.2.2 打开所连接的表单
11.2.3 显示报表
11.2.4 在oracleas中部署表单和报表
11.3 创建菜单
11.3.1 菜单的作用
11.3.2 建立菜单
11.3.3 创建菜单动作
11.3.4 部署和使用菜单
11.4 创建帮助文件
11.4.1 oracle的web帮助系统
11.4.2 创建html帮助文件
11.4.3 部署并使用帮助文件
11.5 小结
第12章 维护数据库安全
12.1 创建和编辑用户账号
12.1.1 用户验证
12.1.2 用户角色
12.1.3 系统权限和对象权限
12.2 控制用户对对象的访问
12.2.1 创建角色
12.2.2 授予和撤销权限
12.3 利用视图和过程实施权限
12.3.1 对选定行和列的限制访问
12.3.2 利用过程限制更新
12.3.3 虚拟专用数据库和标签安全
12.3.4 限制应用内的访问
12.4 加密保护数据
12.4.1 安全的因特网传输
12.4.2 加密数据库中选定的数据
12.4.3 用wrap保护源代码
12.5 审计数据库
12.5.1 启用审计
12.5.2 查看审计跟踪
12.5.3 创建审计触发器
12.5.4 细粒度审计
12.6 小结
第13章 数据库管理
13.1 dba职责一览
13.2 使用企业管理器
13.3 理解oracle的存储文件
13.3.1 保护控制文件
13.3.2 创建表空间和数据文件
13.3.3 配置撤销和重做操作
13.4 为模式对象配置空间
13.4.1 设置表存储参数
13.4.2 定义群
13.4.3 创建分区
13.5 导出和导入数据
13.5.1 使用sql脚本
13.5.2 使用数据泵
13.5.3 使用sql*loader和外部表
13.6 维护dbms
13.6.1 补丁和升级
13.6.2 启动和关闭数据库
13.7 备份数据库
13.7.1 备份数据库的复杂性
13.7.2 关闭和系统备份（冷备份）
13.7.3 继续备份和归档（热备份）
13.8 监控和改善数据库性能
13.8.1 监控工具
13.8.2 优化查询
13.9 利用系统视图获得有用信息
13.10 小结
词汇表
索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle基础教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux系统案例精解
第1章 linux安装与启动	20
1.1 linux本地安装	20
1.1.1 从光盘安装linux	20
1.1.2 从硬盘安装linux	24
1.1.3 从网络安装linux	25
1.2 配置linux网络安装服务器	27
1.3 引导管理程序与系统修复	30
1.3.1 grub启动管理程序	30
1.3.2 grub应用	33
1.3.3 linux救援模式	36
第2章 常用命令简介	37
2.1 显示目录和文件	37
2.1.1 ls命令	37
2.1.2 dir命令	38
2.2 修改权限和所有者	39
2.2.1 chmod命令	39
2.2.2 chown命令	41
2.2.3 chgrp命令	41
2.3 创建和删除目录	42
2.3.1 mkdir命令	42
2.3.2 rmdir命令	42
2.4 创建和删除文件	43
2.4.1 touch命令	43
2.4.2 rm命令	44
2.5 重命名和移动	44
2.6 复 制 命 令	45
2.6.1 cp命令	46
2.6.2 scp命令	47
2.7 显示文件内容	47
2.7.1 cat命令	47
2.7.2 less命令	48
2.7.3 tail命令	49
2.8 查 找 命 令	49
2.8.1 find命令	49
2.8.2 locate命令	51
2.8.3 whereis命令	52
2.8.4 which命令	52
2.9 过 滤 命 令	53
2.10 关机和重启计算机	54
2.10.1 shutdown命令	54
2.10.2 init命令	55
2.10.3 reboot命令	56
2.10.4 halt命令	56
2.11 压缩和打包命令	57
2.11.1 tar命令	57
2.11.2 gzip命令	58
2.11.3 bzip2命令	59
2.12 用户操作命令	60
2.12.1 su命令	60
2.12.2 sudo命令	61
2.12.3 passwd命令	61
2.13 改变目录和查看当前目录	62
2.13.1 cd命令	62
2.13.2 pwd命令	63
2.14 文件链接命令	63
2.15 帮 助 命 令	64
2.15.1 man命令	64
2.15.2 info命令	65
2.15.3 --help参数	66
2.16 其 他 命 令	66
2.16.1 who命令	66
2.16.2 last命令	67
2.16.3 free命令	67
2.16.4 kill命令	68
第3章 linux编辑器	69
3.1 linux编辑器介绍	69
3.2 vim编辑器	70
3.2.1 打开文件	70
3.2.2 读文件	71
3.2.3 编辑文件	72
3.2.4 存盘和退出	74
3.2.5 查找和替换命令	75
3.2.6 设置vim环境	76
3.3 vim编辑器的高级功能	78
3.3.1 文本内容的局部选择与操作	79
3.3.2 编辑多个文档	80
3.3.3 多窗口功能	80
3.3.4 插入补全	81
3.3.5 打开目录	81
3.3.6 折叠隐藏文本	81
3.3.7 设置环境文件	82
3.3.8 文件恢复功能	83
第4章 用户管理	85
4.1 用户和工作组概述	85
4.2 创建用户和工作组	86
4.2.1 创建用户	86
4.2.2 创建工作组	88
4.3 管理用户和工作组	89
4.3.1 用户管理命令	89
4.3.2 用户管理文件	91
4.3.3 工作组群管理命令	93
4.3.4 工作组群管理文件	93
4.3.5 用户和工作组规则文件	94
4.4 深化用户管理	96
4.4.1 手工创建用户	96
4.4.2 手工删除用户	98
4.4.3 批量创建用户	98
第5章 linux软件安装	103
5.1 引言	103
5.2 rpm包管理系统	103
5.2.1 管理rpm包	104
5.2.2 管理rpm源码包	111
5.3 使用yum在线安装或升级rpm包	112
5.4 通过脚本安装软件包	114
5.5 通过源代码安装软件	115
5.6 deb包的安装与apt在线升级	117
5.7 直接解压安装	119
第6章 linux计划任务	122
6.1 at 命令	122
6.1.1 at功能介绍	122
6.1.2 at使用示例	123
6.2 cron服务	125
6.2.1 cron功能介绍	125
6.2.2 cron使用示例	127
6.3 自动运行配置文件	130
6.3.1 自动运行程序	130
6.3.2 实现自动运行配置文件	132
第7章 linux系统远程管理	135
7.1 telnet服务管理	136
7.1.1 telnet简介	136
7.1.2 telnet基本配置	136
7.1.3 telnet服务限制	138
7.1.4 允许root用户登录	138
7.2 ssh服务管理	139
7.2.1 ssh简介	139
7.2.2 ssh基本配置	140
7.2.3 使用sftp	142
7.2.4 ssh服务限制	144
7.2.5 使用putty管理linux服务器	144
7.3 vnc服务管理	145
7.3.1 vnc简介	145
7.3.2 vnc基本配置	145
7.3.3 以图形界面登录vnc	147
7.3.4 使用ssh和vnc共同进行远程管理	147
7.4 webmin软件管理	148
7.4.1 webmin简介	148
7.4.2 webmin基本使用	149
7.4.3 webmin管理模块功能	151
第8章 定制linux内核	157
8.1 linux内核组件介绍	157
8.2 /boot目录下文件介绍	158
8.2.1 vmlinuz内核文件	158
8.2.2 initrd.img映像文件	159
8.2.3 linux内核模块配置文件	161
8.2.4 linux内核符号列表文件	163
8.2.5 linux内核参数配置文件	163
8.3 内核操作命令	164
8.3.1 lsmod命令	164
8.3.2 modprobe命令	166
8.3.3 insmod命令	167
8.3.4 rmmod命令	167
8.3.5 depmod命令	168
8.3.6 modinfo命令	168
8.4 编译内核前的准备工作	169
8.4.1 内核升级所需依赖包	169
8.4.2 下载linux 2.6内核源码文件	170
8.4.3 解包解压缩linux内核文件	171
8.4.4 内核编译步骤	172
8.4.5 内核补丁编译步骤	173
8.5 配置内核选项	176
8.5.1 通过字符方式配置内核选项	176
8.5.2 通过菜单方式配置内核选项	177
8.5.3 通过qt图形方式配置内核选项	180
8.5.4 通过gtk图形方式配置内核选项	182
8.6 配置磁盘选项	184
8.6.1 ide硬盘及光驱选项配置	184
8.6.2 sata硬盘选项配置	185
8.6.3 lvm&raid选项配置	186
8.6.4 usb移动硬盘及光驱选项配置	187
8.7 配置cpu及电源选项	188
8.7.1 cpu类型选项配置	188
8.7.2 内存选项配置	191
8.7.3 电源选项配置	191
8.8 网络选项及网络设备配置	192
8.8.1 网络功能选项配置	192
8.8.2 网络设备驱动配置	192
8.8.3 isdn网络设备配置	195
8.8.4 irda网络协议和选项支持	195
8.8.5 蓝牙网络设备配置	196
8.9 设备驱动配置	197
8.9.1 多媒体设备驱动配置	197
8.9.2 声卡设备驱动配置	197
8.9.3 显卡设备驱动配置	199
8.10 文件系统选项配置	200
8.10.1 ext2/3/4文件系统选项配置	200
8.10.2 reiserfs/jfs/xfs文件系统选项配置	200
8.10.3 cluster文件系统选项配置	201
8.10.4 网络文件系统选项配置	201
8.10.5 光驱/fat/ntfs文件系统选项配置	202
8.10.6 磁盘配额及分区类型选项配置	203
8.11 linux内核安全及虚拟化选项配置	203
8.11.1 内核安全选项配置	203
8.11.2 内核虚拟化选项配置	204
8.12 基于linux2.6内核的升级方法	204
8.12.1 下载及解包解压缩内核源码	205
8.12.2 配置内核选项	206
8.12.3 编译内核选项	209
8.12.4 修改启动管理器的配置文件	210
8.12.5 测试新内核	211
第9章 磁盘管理、raid与lvm	213
9.1 创建文件系统	213
9.1.1 磁盘分区	213
9.1.2 格式化	222
9.1.3 挂载文件系统	225
9.2 linux的软raid管理	229
9.2.1 raid概念、分类及优缺点	230
9.2.2 raid配置实例	232
9.3 lvm配置与管理	238
9.3.1 lvm概述	238
9.3.2 lvm的创建和扩容	239
9.3.3 lvm的快照保护及恢复	248
9.4 raid、lvm及磁盘配额应用实例	251
第10章 linux连接磁盘阵列的配置	258
10.1 存储技术概述	258
10.1.1 磁盘阵列分类	259
10.1.2 das直连附加存储	261
10.1.3 nas网络附加存储	262
10.1.4 san存储区域网络	265
10.1.5 san网络分类	267
10.1.6 nas和san比较	268
10.2 主机与磁盘阵列的连接方式	269
10.2.1 通过fc接口连接	269
10.2.2 通过sas接口连接	274
10.2.3 通过iscsi接口连接	278
10.2.4 通过scsi接口连接	279
10.3 安装hba卡驱动	283
10.3.1 查看linux系统支持光纤驱动模块	284
10.3.2 配置linux系统以实现开机激活fc光纤驱动模块	286
10.4 linux与fc-san磁盘阵列的连接	287
10.4.1 登录磁盘阵列	288
10.4.2 配置磁盘阵列	289
10.4.3 配置主机服务器	294
10.5 linux与ip-san磁盘阵列的连接	295
10.5.1 iscsi概述	295
10.5.2 iscsi存储的安装	296
10.5.3 iscsi存储的配置文件	298
10.5.4 配置iscsi存储	300
10.5.5 安装iscsi客户端	302
10.5.6 iscsi客户端配置文件	303
10.5.7 连接iscsi存储	304
第11章 oracle在linux下的安装配置	306
11.1 oracle基本概念	306
11.2 oracle在linux的安装	307
11.2.1 系统级别准备工作	307
11.2.2 oracle安装前的准备工作	311
11.2.3 下载并解压oracle安装包	313
11.2.4 安装oracle 11g数据库系统	314
11.2.5 设置开机自动启动oracle	324
11.3 创建文件系统存储数据库	326
11.3.1 连接磁盘阵列	326
11.3.2 创建数据库	328
11.3.3 测试oracle数据库系统	332
11.4 创建自动存储管理数据库	333
11.4.1 配置磁盘阵列分区	333
11.4.2 安装oracleasm软件包	334
11.4.3 创建asm设备	335
11.4.4 创建基于asm存储的数据库	336
11.4.5 启动oracle数据库	337
11.5 oracle rac并行数据库安装	338
11.5.1 配置rac实验拓扑图	338
11.5.2 配置rac实验关系表	339
11.5.3 配置rac前的准备工作	339
11.5.4 设置共享磁盘阵列	341
11.5.5 创建仲裁盘和asm设备	344
11.5.6 创建用户及工作目录	345
11.5.7 安装crs集群服务	347
11.5.8 安装rac集群数据库	356
第12章 linux集群服务的安装部署	365
12.1 集群的优势及分类	365
12.2 集群系统规划	366
12.3 网 卡 绑 定	367
12.3.1 配置前的准备	367
12.3.2 网卡绑定配置	368
12.3.3 网卡绑定效果测试	371
12.4 磁盘多路径绑定	372
12.4.1 配置前的准备	372
12.4.2 磁盘多路径绑定配置	373
12.4.3 磁盘多路径绑定效果测试	376
12.5 i/o屏障技术	377
12.6 高可用集群	379
12.6.1 高可用集群原理	379
12.6.2 红帽集群套件rhcs的工作原理	380
12.6.3 rhcs+oracle配置实战图解	382
12.7 负载均衡集群	416
12.7.1 红帽lvs负载均衡集群原理	416
12.7.2 红帽lvs安装及配置	419
第13章 linux性能分析与优化	433
13.1 影响性能的因素	433
13.1.1 linux系统架构	433
13.1.2 硬盘i/o对性能的影响	434
13.1.3 cpu及进程处理对性能的影响	435
13.1.4 内存对性能的影响	436
13.1.5 进程间通信对性能的影响	436
13.1.6 网络对性能的影响	437
13.2 性能分析工具	437
13.2.1 性能数据收集命令	438
13.2.2 图形化数据的生成	446
13.3 性 能 优 化	452
13.3.1 cpu进程处理性能优化	452
13.3.2 内存性能优化	456
13.3.3 硬盘i/o性能优化	458
13.3.4 网络性能优化	462
13.3.5 应用层优化思路描述	462
第14章 linux系统日志管理	464
14.1 日 志 分 类	464
14.1.1 连接时间日志	464
14.1.2 进程统计日志	470
14.1.3 系统和服务日志	474
14.2 日 志 服 务	475
14.2.1 linux日志服务介绍	475
14.2.2 /etc/syslog.conf配置文件	477
14.2.3 /etc/sysconfig/syslog配置文件	479
14.2.4 配置日志服务器	480
14.3 日志转储服务	483
14.3.1 /etc/logrotate.conf配置文件	483
14.3.2 日志转储案例	485
14.3.3 自定义日志转储案例	486
14.4 常用系统日志分析	487
14.4.1 系统消息日志分析	487
14.4.2 系统安全日志分析	489
14.4.3 系统引导日志分析	491
14.4.4 硬件检测日志分析	492
14.4.5 计划任务日志分析	492
14.4.6 x-window日志分析	493
14.5 常用服务日志分析	494
14.5.1 web网站日志分析	494
14.5.2 邮件系统日志分析	496
14.5.3 代理服务器日志分析	496
14.5.4 文件服务器日志分析	498
14.5.5 ftp服务器日志分析	500
14.6 日志分析工具	501
14.6.1 awstats日志分析工具	501
14.6.2 webalizer日志分析工具	506
14.6.3 sarg日志分析软件	510
第15章 linux系统安全管理	519
15.1 系统安全概述	519
15.1.1 操作系统安全	520
15.1.2 网络安全	520
15.1.3 人员及设备安全管理	521
15.1.4 综合管理规范	521
15.2 linux系统账号安全	521
15.2.1 系统账号管理基?	503
15.2.2 pam可插拔验证模块	524
15.3 linux文件系统权限安全	525
15.3.1 linux文件系统权限管理基?	506
15.3.2 suid/sgid特殊权限管理	527
15.3.3 linux文件系统acl高级权限控制	527
15.4 应用软件安全	529
15.4.1 sudo权限	529
15.4.2 rpm安全验证	531
15.4.3 及时对系统软件进行更新	531
15.5 linux网络安全防护	532
15.5.1 linux内核防火墙的包过滤机制	532
15.5.2 iptables端口过滤实例	533
15.5.3 常见网络攻击预防	537
第16章 nas&san设备的安装与配置	538
16.1 openfiler功能介绍	538
16.2 安装openfiler	540
16.3 配置openfiler	549
16.3.1 登录openfiler系统	549
16.3.2 openfiler系统状态信息	550
16.3.3 openfiler系统配置菜单	550
16.3.4 openfiler卷管理配置菜单	556
16.3.5 openfiler磁盘配额配置菜单	561
16.3.6 openfiler共享配置菜单	563
16.3.7 openfiler服务管理配置菜单	565
16.3.8 openfiler用户账号管理菜单	568
16.4 openfiler配置实例	576
16.4.1 配置iscsi存储分区	576
16.4.2 配置lun快照功能	582
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Linux系统案例精解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 11g RAC手册
目    录

第Ⅰ部分  高可用性体系结构与
集群
第1章  高可用性和可伸缩性概述	3
1.1  高可用性	4
1.1.1  高可用性术语	4
1.1.2  计划内与计划外停机	5
1.1.3  端到端视角	6
1.1.4  停机时间的成本	6
1.1.5  构建冗余组件	9
1.1.6  实现高可用性的常用
解决方案	10
1.1.7  集群、冷故障转移和热故障
转移	10
1.1.8  高可用性选项的优缺点	13
1.2  可伸缩性	14
1.3  Oracle RAC解决方案	14
1.4  新兴趋势	15
1.5  小结	16
第2章  集群的基础知识与历史	17
2.1  用集群实现网格计算	19
2.2  集群中的共享存储	22
2.3  Oracle RAC的历史	27
2.4  Oracle并行服务器体系结构	29
2.5  OPS数据库的组件	30
2.5.1  集群组服务(CGS)	31
2.5.2  分布式锁管理器(DLM)	31
2.5.3  Oracle并行服务器中的
锁定概念	32
2.5.4  缓存融合第1阶段，CR
服务器	36
2.5.5  Oracle并行服务器的
局限性	37
2.6  Oracle RAC解决方案	38
2.6.1  可用性	38
2.6.2  可伸缩性	38
2.6.3  可负担性	39
2.7  小结	39
第3章  Oracle RAC体系结构	41
3.1  单实例环境与Oracle RAC
环境的对比	42
3.2  Oracle RAC组件	43
3.2.1  共享磁盘系统	44
3.2.2  Oracle集群件	50
3.2.3  Oracle集群件组件	50
3.2.4  联网栈组件	61
3.3  Oracle内核组件	65
3.3.1  全局缓存和全局队列服务	65
3.3.2  全局资源目录	65
3.3.3  Oracle RAC后台进程	66
3.4  小结	71
第Ⅱ部分  安装、配置和存储
第4章  Oracle Grid Infrastructure的
安装	75
4.1  安装之前的任务	77
4.1.1  配置网络	77
4.1.2  设置组和用户	79
4.1.3  配置共享存储	80
4.1.4  保护外壳和用户限制配置	82
4.1.5  配置内核参数	83
4.1.6  Oracle验证配置RPM	84
4.1.7  运行集群验证实用工具	84
4.1.8  Oracle Grid Infrastructure的
安装	88
4.1.9  安装Oracle Grid
Infrastructure	91
4.2  小结	108
第5章  Oracle RAC的安装	109
5.1  Oracle RAC的安装	111
5.2  小结	127
第6章  自动存储管理	129
6.1  有关自动存储管理的
一些事实	130
6.1.1  ASM的物理限制	131
6.1.2  操作中的ASM	131
6.1.3  ASM的组成模块	134
6.2  ASM管理	138
6.3  ASM工具	152
6.3.1  ASMCA：ASM配置助手	152
6.3.2  ASMCMD：ASM命令行
实用工具	152
6.3.3  ASM FTP实用工具	153
6.4  ASMLib	154
6.4.1  安装ASMLib	154
6.4.2  配置ASMLib	155
6.5  小结	156
第Ⅲ部分  Oracle RAC管理
第7章  Oracle RAC基本管理	159
7.1  初始化参数	160
7.1.1  特有参数	161
7.1.2  相同参数	163
7.1.3  实例特有的参数	166
7.1.4  管理参数文件	167
7.2  启动和停止实例	168
7.2.1  使用srvctl启动/停止实例	169
7.2.2  使用SQL*Plus启动/停止
实例	169
7.2.3  使用SRVCTL在OCR中
注册单实例数据库	170
7.3  管理撤销	170
7.3.1  自动撤销管理	170
7.3.2  手动撤销管理	171
7.4  管理临时表空间	171
7.5  管理联机重做日志	172
7.6  启动闪回区域	174
7.7  用SRVCTL管理数据库
配置	175
7.8  管理数据库对象	178
7.8.1  管理表空间	178
7.8.2  管理序列	178
7.8.3  管理表	178
7.8.4  管理索引	179
7.8.5  SQL命令的范围	179
7.8.6  数据库连接	179
7.9  小结	180
第8章  Oracle RAC高级管理	181
8.1  理解服务	182
8.2  管理服务	186
8.3  管理SCAN	189
8.4  管理集群就绪服务	190
8.4.1  集群件的启动过程
(Oracle 11g R1)	190
8.4.2  集群件的启动顺序	191
8.4.3  Oracle集群件自动启动	195
8.4.4  Oracle集群件手动启动	195
8.4.5  启动和停止CRS
(Oracle 11g R2)	195
8.4.6  验证CRS	196
8.4.7  禁用和启用CRS	197
8.4.8  CRS实用工具	197
8.5  管理OCR	205
8.6  管理Oracle本地注册表	207
8.7  管理表决磁盘	207
8.8  小结	208
第9章  Oracle RAC备份与恢复	209
9.1  备份简介	210
9.2  Oracle备份基础知识	211
9.3  Oracle RAC中的实例恢复	213
9.3.1  重做线程和重做流	214
9.3.2  重做记录和修改向量	214
9.3.3  检查点	214
9.4  崩溃恢复	216
9.4.1  崩溃恢复步骤(单实例)	216
9.4.2  Oracle RAC中的崩溃恢复	216
9.5  实例恢复	217
9.5.1  OPS中的实例恢复	217
9.5.2  Oracle RAC中的实例恢复	218
9.6  崩溃恢复和介质恢复	218
9.6.1  限定恢复	219
9.6.2  写块记录(BWR)	219
9.6.3  过去映像(PI)	219
9.6.4  两步恢复	220
9.6.5  缓存融合恢复	221
9.7  动态再配置和关联性主控
切换	222
9.7.1  Oracle RAC中的快速
再配置	222
9.7.2  缓存融合恢复内幕	225
9.8  表决磁盘和OCR的备份与
恢复	228
9.8.1  表决磁盘的备份和恢复	228
9.8.2  OCR的备份和恢复	229
9.9  小结	231
第10章  Oracle RAC性能管理	233
10.1  Oracle RAC设计考虑事项	234
10.1.1  Oracle最佳设计实践	234
10.1.2  Oracle RAC特有的最佳
设计实践	235
10.2  工作量分区	236
10.3  可伸缩性与性能	236
10.4  为Oracle RAC数据库选择块
大小	238
10.5  使用自动段空间管理	238
10.6  V$和GV$视图介绍	239
10.7  Oracle RAC等待事件	240
10.8  全局缓存统计信息	252
10.9  全局缓存服务时间	255
10.10  Oracle RAC中的队列
调优	258
10.11  Oracle AWR报表	259
10.11.1  AWR报表解读	260
10.11.2  GCS和GES消息发送
统计部分	264
10.11.3  STATSPACK	266
10.11.4  ADDM	266
10.12  集群互联调优	267
10.12.1  验证正在使用专用
互联	267
10.12.2  互联延迟	268
10.12.3  验证网络互联未饱和	269
10.13  小结	269
第Ⅳ部分  Oracle RAC中的
高级概念
第11章  全局资源目录	273
11.1  资源与队列	274
11.1.1  授权与转换	275
11.1.2  锁与队列	276
11.2  缓存一致性	276
11.3  全局队列服务	277
11.3.1  锁存器与队列	277
11.3.2  全局锁数据库和结构	279
11.3.3  Oracle RAC中的消息
发送	282
11.4  全局缓存服务	285
11.4.1  锁模式与锁角色	286
11.4.2  一致性读取处理	289
11.4.3  GCS资源主控	292
11.4.4  主读锁定	294
11.5  小结	299
第12章  缓存融合的深入探讨	301
12.1  缓存融合中的关键组件	303
12.1.1  ping	303
12.1.2  延期ping	304
12.1.3  过去映像(PI)块	304
12.1.4  锁主控	305
12.1.5  争用类型	305
12.2  缓存融合I或一致读
服务器	305
12.3  缓存融合II或写/写缓存
融合	308
12.3.1  操作中的缓存融合	310
12.3.2  缓存融合演练	316
12.3.3  资源主控和主控切换	334
12.4  后台进程和缓存融合	335
12.4.1  LMON：锁监控器进程	335
12.4.2  LMS：锁管理器服务器	335
12.4.3  LMD：锁管理器守护
进程(LMDn)	336
12.4.4  LCKn：锁进程(LCK0)	336
12.4.5  DIAG：诊断守护进程
(DIAG)	336
12.5  小结	336
第13章  工作量和连接管理	337
13.1  工作量分发与负载均衡	338
13.2  负载均衡和Oracle
网络服务	340
13.2.1  客户端负载均衡	340
13.2.2  服务器端负载均衡	344
13.3  透明应用程序故障转移	346
13.4  工作量管理	353
13.4.1  Oracle服务	353
13.4.2  负载均衡	355
13.4.3  高可用性功能	359
13.5  小结	367
第14章  Oracle RAC故障排除	369
14.1  安装日志文件	370
14.2  Oracle RDBMS中的日志目录
结构	370
14.3  Oracle Grid Infrastructure中的
日志目录结构	372
14.4  Oracle Grid Infrastructure安装
失败时的故障排除	373
14.5  数据库警告日志的内容	375
14.6  RAC的开与关	379
14.7  数据库性能问题	380
14.8  调试节点逐出问题	383
14.8.1  集群健康监控器	385
14.8.2  实例成员资格恢复	386
14.9  Oracle集群件模块的
高级调试	393
14.10  调试Oracle RAC中的各种
实用工具	395
14.11  小结	396
第Ⅴ部分  部署Oracle RAC
第15章  扩展Oracle RAC以实现最大
可用性	401
15.1  扩展的好处	403
15.1.1  全面利用资源	403
15.1.2  极快速恢复	403
15.2  设计考虑事项	403
15.2.1  光速	403
15.2.2  网络连通性	404
15.2.3  缓存融合性能	405
15.2.4  数据存储	405
15.3  常用数据镜像技术	406
15.3.1  基于阵列的镜像	406
15.3.2  基于主机的镜像	407
15.3.4  ASM优先读取	408
15.3.5  扩展集群中的挑战	408
15.4  扩展Oracle RAC的局限性	409
15.5  扩展Oracle RAC与Oracle
数据卫士的对比	409
15.6  小结	410
第16章  为Oracle RAC开发
应用程序	411
16.1  应用程序分区	414
16.2  数据分区	416
16.3  缓冲区繁忙等待/块争用	418
16.4  索引分区	419
16.4.1  缓冲区繁忙等待：
索引枝节/叶块争用	419
16.4.2  有序哈希集群	421
16.5  处理序列	422
16.5.1  CACHE和NOORDER	422
16.5.2  CACHE和ORDER	423
16.5.3  NOCACHE和ORDER	423
16.5.4  最佳实践：为每个实例
使用不同序列	423
16.6  连接管理	424
16.7  全表扫描	425
16.7.1  识别全表扫描	425
16.7.2  互联协议	426
16.8  分析中的库缓存效果	428
16.9  提交频率	428
16.10  小结	429
第Ⅵ部分  附    录
附录A  Oracle RAC参考	433
附录B  添加和删除集群节点	461
附录C  参考文献	467
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 11g RAC手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle DBA突击
第一部分　基础篇
第1章　数据建模　2
1.1　数据建模　3
1.1.1　创建逻辑模型　3
1.1.2　创建物理模型　7
1.2　规范化　12
1.2.1　1NF　13
1.2.2　2NF　14
1.2.3　3NF　15
1.3　如何表示树形结构　16
1.3.1　什么是树形结构　16
1.3.2　邻接模型　19
1.3.3　物化路径模型　26
1.3.4　嵌套集合模型　28
1.4　小结　34
第2章　Oracle体系架构　35
2.1　Oracle的网络配置　35
2.1.1　Oracle的网络架构　36
2.1.2　客户端安装　38
2.1.3　服务器端监听器配置　39
2.1.4　客户端配置　44
2.2　Oracle 10g架构　47
2.3　数据库　49
2.3.1　物理结构　49
2.3.2　OMF　55
2.3.3　逻辑结构　59
2.4　空间管理　70
2.4.1　段空间管理　71
2.4.2　Extent空间管理　74
2.5　实例　74
2.5.1　进程　75
2.5.2　后台进程　77
2.5.3　内存结构　83
2.5.4　PGA　87
2.6　未尽话题　88
第3章　备份恢复　89
3.1　归档模式和非归档模式　90
3.1.1　归档模式的优缺点　90
3.1.2　非归档模式的优缺点　91
3.1.3　非归档模式转换成归档模式　91
3.2　备份概述　92
3.3　物理备份　92
3.3.1　冷备份　92
3.3.2　热备份　93
3.3.3　RMAN备份　95
3.4　备份前的环境配置　98
3.4.1　连接到数据库　98
3.4.2　查看现有配置　99
3.4.3　配置控制文件自动备份　101
3.4.4　配置备份文件格式　101
3.4.5　配置备份保留策略　102
3.4.6　与保留策略相关的其他操作　104
3.4.7　删除配置　106
3.5　完全备份和增量备份　106
3.5.1　完全备份　106
3.5.2　增量备份　108
3.6　恢复　111
3.7　日志　112
3.7.1　改动向量(Change Vector)　112
3.7.2　Redo记录　112
3.7.3　检查点　115
3.7.4　SCN号　116
3.7.5　数据库恢复　118
3.7.6　恢复过程　120
3.8　Oracle MAA介绍　123
3.9　小结　125
第4章　OEM　126
4.1　Database Control　127
4.1.1　配置Database Control　127
4.1.2　Database Control的目录结构　129
4.1.3　手工配置Database Control　130
4.1.4　用Database Controle管理多个数据库　133
4.2　Grid Control架构　134
4.2.1　Grid Control Console　135
4.2.2　Oracle Management Agent　136
4.2.3　Oracle Management Service　136
4.2.4　Management Repository　137
4.2.5　OEM的原理和工作方式　137
4.2.6　Agent的工作方式　137
4.3　部署OEM Grid Control　138
4.3.1　部署OEM　139
4.3.2　OracleAS、OMS、OC4J的关系　145
4.3.3　OEM的目录结构　147
4.4　部署Agent　148
4.4.1　全新安装(Fresh安装)　148
4.4.2　使用命令行克隆方法部署Agent　152
4.4.3　部署Agent后DBCA的变化　157
4.4.4　emwd脚本　159
4.4.5　磁盘空间限制　159
4.5　OEM的维护工具　159
4.5.1　维护OMS　160
4.5.2　维护Agent　165
4.6　修改配置　166
4.6.1　修改Agent的监听端口　166
4.6.2　配置Agent使用新的OMS　166
4.6.3　修改OMS的监听端口　167
4.6.4　一次Trouble Shooting　167
4.7　小结　173
第二部分　中级篇
第5章　SQL优化原理　176
5.1　PGA　176
5.1.1　Session Area　177
5.1.2　Private SQL Area　177
5.2　SQL语句的执行过程　179
5.2.1　Parent Cursor和Child Cursor　180
5.2.2　V$SQL和V$SQLAREA的区别　182
5.2.3　与Cursor有关的参数　182
5.3　执行计划　185
5.3.1　Explain Plan For ...　185
5.3.2　SQL Trace和10046事件　186
5.3.3　从Library Cache中获取　190
5.4　如何阅读执行计划　198
5.4.1　SQL概要信息　199
5.4.2　执行计划　199
5.4.3　Query Block　200
5.4.4　数据过滤　208
5.4.5　列投影　209
5.5　小结　209
第6章　访问路径和连接　210
6.1　QUBE模型　210
6.2　单表访问——全表扫描还是索引　212
6.2.1　谓词(Predicate)　212
6.2.2　Selectivity和Cardinality　213
6.2.3　全表扫描　213
6.2.4　两种方式访问的成本比较　214
6.2.5　聚簇因子　215
6.3　连接　216
6.3.1　NEST LOOP　216
6.3.2　SORT MERGE　217
6.3.3　HASH JOIN　219
6.3.4　几种算法的比较　220
6.4　半连接　221
6.4.1　测试环境　221
6.4.2　合并与展开　222
6.4.3　(NOT)IN和(NOT)EXISTS的哲学思想　224
6.4.4　Exists和In　224
6.4.5　Not Exists　228
6.4.6　Not In　229
6.5　小结　234
第7章　并行操作　235
7.1　并行架构　235
7.1.1　进程　236
7.1.2　相关参数　239
7.2　启用并行处理　..244
7.2.1　对象级　244
7.2.2　语句级　245
7.2.3　会话级　246
7.3　解读执行计划　246
7.4　等待事件　250
7.5　小结　250
第8章　自动管理和性能指标　252
8.1　Oracle系统调整技术发展史　252
8.1.1　为什么要系统调整　253
8.1.2　方法论——从命中率到等待事件　253
8.1.3　工具：从STATSPACK到AWR　255
8.2　Oracle 10g的自动管理框架　257
8.2.1　AWR概述　258
8.2.2　ADDM概述　258
8.3　负载数据自动收集(AWR)　260
8.3.1　STATISTICS_LEVEL参数　261
8.3.2　AWR的收集机制　262
8.3.3　配置AWR　262
8.3.4　生成AWR报告　264
8.3.5　AWR的补充——ASH　267
8.4　对象信息的自动收集　272
8.4.1　对象信息的收集机制　275
8.4.2　Table Monitoring机制　278
8.4.3　动态收集对象信息　280
8.4.4　统计信息历史　281
8.4.5　导入导出统计信息　283
8.4.6　锁定统计信息　285
8.5　操作系统统计数据收集　287
8.5.1　无负载模式　289
8.5.2　负载模式数据　289
8.6　学会阅读原始数据　291
8.7　性能统计数据(Performance Statistics)　292
8.8　Oracle等待事件接口(OWI)　296
8.8.1　什么是等待事件　296
8.8.2　常见事件　297
8.8.3　OWI视图　298
8.9　Metric　305
8.10　Time Model　311
8.11　小结　318
第9章　自动诊断和顾问　319
9.1　ADDM　319
9.2　Auto SQL Tunning　323
9.2.1　ATO　323
9.2.2　Auto SQL Tunning架构　324
9.2.3　如何使用Automatic SQL Tunning　327
9.2.4　解读Auto SQL Tunning报告内容　330
9.3　其他自动管理特性　333
9.3.1　ASSM　333
9.3.2　顾问功能　337
9.3.3　Resumable Space Allocation　352
9.4　小结　354
第三部分　高级篇
第10章　Oracle的异构服务　356
10.1　异构服务的架构　356
10.2　Agent的分类　357
10.2.1　什么是ODBC　358
10.2.2　ODBC的组件　358
10.3　配置到MySQL的普通连接　359
10.3.1　环境介绍　360
10.3.2　MySQL服务器的配置　360
10.3.3　Oracle服务器的配置　371
10.4　配置到SQL Server 2000的普通连接　373
10.4.1　Windows服务器的配置　373
10.4.2　Linux服务器上的配置　374
10.5　配置到SQL Server 2000的透明网管连接　375
10.5.1　SQL Server服务器的配置　375
10.5.2　Linux服务器的配置　377
10.6　透明网关和普通连接的对比　377
10.6.1　普通连接不支持分布式事务　378
10.6.2　透明网关支持分布式事务　378
10.7　小结　379
第11章　数据安全　380
11.1　安全问题概述　382
11.2　Oracle的网络加密：SSL和PKI　383
11.2.1　加密算法：保证数据机密性　384
11.2.2　数字签名：保证数据完整性　385
11.2.3　证书保证数据不可抵赖性　386
11.2.4　可信CA和证书注销表　388
11.2.5　SSL　388
11.2.6　配置SSL　389
11.2.7　Secure External Password Store　405
11.3　透明数据加密　407
11.3.1　配置TDE　408
11.3.2　验证TDE　412
11.3.3　TDE的性能　417
11.4　小结　421
第12章　限制用户行为　423
12.1　IP地址限制　423
12.2　用户验证　424
12.3　利用登录触发器　425
12.4　数据访问控制　426
12.5　粗粒度数据访问控制：权限和角色　426
12.5.1　对象权限　427
12.5.2　系统权限　427
12.5.3　WITH ADMIN和WITH GRANT的比较　428
12.5.4　角色　430
12.5.5　判断权限来源　431
12.5.6　PRODUCT_USER_PROFILE　435
12.6　细粒度访问控制(FGAC)　436
12.6.1　背景知识　436
12.6.2　自主访问控制　437
12.6.3　强制访问控制　437
12.6.4　现实问题　438
12.7　视图　439
12.8　VPD　439
12.8.1　快速体验　440
12.8.2　深入RLS　442
12.8.3　敏感列的VPD　456
12.9　Oracle标签安全(OLS)　462
12.9.1　安装OLS　464
12.9.2　OLS的标签　466
12.9.3　实施OLS　467
12.10　小结　480
第13章　审计　483
13.1　审计的作用　483
13.2　Oracle的审计功能　484
13.2.1　标准审计　484
13.2.2　细粒度审计　495
13.2.3　FGA与标准审计　504
13.3　小结　504
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle DBA突击
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大话Oracle RAC
第1部分　集群理论篇
第1章　RAC初体验　2
1.1　本书使用环境　3
1.1.1　硬件环境　3
1.1.2　软件环境　4
1.1.3　本书使用的环境　6
1.2　如何在PC机上搭建RAC环境　7
1.2.1　需要下载的软件　7
1.2.2　安装过程　8
1.3　任务列表　16
1.4　规划阶段　17
1.4.1　确认主机名和3个IP地址　17
1.4.2　存储方案选型　17
1.5　实施阶段　19
1.5.1　主机配置　19
1.5.2　安装Oracle Clusterware　27
1.5.3　安装Oracle Database　33
1.5.4　配置Listener　35
1.5.5　创建ASM　38
1.5.6　创建数据库　40
1.6　客户端测试　43
1.6.1　客户端配置　43
1.6.2　体验Failover　44
1.6.3　体验LoadBalance　45
1.6.4　修改归档模式　46
第2章　集群、RAC和MAA　48
2.1　什么是集群　48
2.1.1　系统可靠性　49
2.1.2　系统性能　49
2.1.3　集群的技术基础　50
2.2　集群术语　51
2.2.1　两大关键特性：可扩展性和高可用性　51
2.2.2　两大核心能力：负载均衡和故障转移　52
2.2.3　集群组成元素　52
2.2.4　集群分类　52
2.3　Oracle的高可用架构(MAA)　53
2.3.1　MAA实例　54
2.3.2　双机热备——一个被遗漏的技术　55
2.4　RAC集群　56
2.4.1　存储层　57
2.4.2　网络层　57
2.4.3　集群件层　58
2.4.4　应用层　58
2.5　RAC集群环境的特殊问题　59
2.5.1　并发控制　59
2.5.2　健忘症(Amnesia)　59
2.5.3　脑裂(Split Brain)　59
2.5.4　IO隔离(IO Fencing)　60
2.6　RAC的前世今生　61
2.6.1　Oracle Database的历史　61
2.6.2　Oracle RAC的历史　62
2.6.3　OPS和RAC的区别　64
2.7　RAC的好处　65
2.7.1　增加可用性　66
2.7.2　扩展性　67
2.7.3　更容易管理　67
2.7.4　其他选择　68
2.8　小结　68
第3章　Oracle Clusterware　69
3.1　Clusterware和RAC的关系　69
3.2　Oracle Clusterware组成　70
3.2.1　磁盘文件　70
3.2.2　Clusterware后台进程　76
3.2.3　网络组件　83
3.3　Clusterware的日志体系　87
3.4　Clusterware和厂商集群的关系　88
3.5　小结　89
第4章　RAC原理　90
4.1　数据库基本原理　90
4.1.1　并发访问和数据一致性　91
4.1.2　事务和隔离级别　92
4.1.3　Oracle支持的隔离级别　93
4.2　Oracle单实例的并发控制机制　94
4.2.1　Lock　94
4.2.2　数据记录的行级锁　95
4.2.3　Latch　99
4.2.4　Latch和Lock对比　99
4.2.5　进一步理解　100
4.3　RAC下的并发控制　102
4.3.1　DLM中资源和锁　103
4.3.2　Non-Cache Fusion资源　104
4.3.3　Cache Fusion资源　105
4.3.4　GRD(Global Resource Directory)　106
4.3.5　PCM Lock　107
4.3.6　Cache Fusion　108
4.3.7　RAC并发控制总结　113
4.4　RAC架构　113
4.4.1　SGA的变化　114
4.4.2　后台进程的变化　114
4.4.3　文件　116
4.4.4　SCN　117
4.4.5　Cache Fusion、GCS、GES　118
4.5　RAC和Clusterware的交互　119
4.5.1　Clusterware层　119
4.5.2　RAC层　120
4.6　小结　123
第5章　存储方案——ASM初步　124
5.1　Shared-Disk和Shared-Nothing架构　124
5.2　Oracle 10g RAC的存储方案介绍　125
5.3　ASM架构　125
5.3.1　ASM实例　126
5.3.2　文件　127
5.4　配置ASM　127
5.4.1　安装位置　127
5.4.2　创建ASM磁盘　127
5.4.3　配置ASM实例　137
5.4.4　创建磁盘组　140
5.4.5　在数据库中使用ASM的磁盘组　140
5.4.6　如何从远程访问ASM实例　141
5.5　ASM实例：将数据库迁移到ASM　141
5.5.1　试验说明　141
5.5.2　操作步骤　141
5.5.3　最后验证　148
5.6　小结　148
第2部分　实战篇
第6章　RAC维护工具集　150
6.1　Oracle Clusterware工具集　150
6.2　节点层　150
6.3　网络层　151
6.3.1　公有网络　151
6.3.2　私有网络　151
6.3.3　私有网络的参数调整　154
6.3.4　oficfg命令　155
6.3.5　工程中解决不能识别心跳网络的故障　157
6.4　集群层　159
6.4.1　crsctl　159
6.4.2　OCR命令系列　164
6.4.3　一个Bug引起的系统重启　171
6.5　应用层　185
6.5.1　crs_stat　185
6.5.2　onsctl　188
6.5.3　srvctl　193
6.5.4　恢复　199
6.6　小结　202
第7章　HA和LB　203
7.1　什么是高可用性　203
7.2　Failover　204
7.2.1　Client-Side Connect Time Failover　204
7.2.2　TAF(Transparent Application Failover)　204
7.2.3　Client-Side Failover和TAF的对照试验　205
7.2.4　Server-Side TAF　208
7.2.5　深入TAF细节　214
7.3　Oracle Clusterware HA框架　221
7.3.1　术语介绍　221
7.3.2　配置命令　223
7.3.3　完整实例　228
7.4　LoadBalance　232
7.4.1　Connection Balancing　232
7.4.2　利用Service分散负载　235
7.5　测试LoadBalance　236
7.5.1　通过Listener日志区分路由来源　236
7.5.2　测试方法　237
7.5.3　测试过程　238
7.6　小结　242
第8章　备份　243
8.1　概述　243
8.1.1　归档模式和非归档模式　243
8.1.2　备份分类　245
8.1.3　User-Managed Backup　246
8.2　使用Flash Recovery Area　248
8.2.1　配置Flash Recovery Area　249
8.2.2　Flash Recovery Area的空间监控　249
8.3　RMAN架构　250
8.3.1　Target Database　250
8.3.2　Catalog Database　251
8.3.3　通道(Channel)　251
8.3.4　闪回恢复区(Flash Recovery Area)　251
8.3.5　备份集(Backup Set)和拷贝(Copy)　251
8.3.6　介质管理器　252
8.3.7　连接到数据库　252
8.4　使用RMAN　253
8.4.1　RMAN工具的使用方法　253
8.4.2　RMAN配置　255
8.5　完全备份和增量备份　264
8.5.1　完全备份　264
8.5.2　增量备份　267
8.5.3　其他RMAN命令　269
8.6　RAC的备份实例　275
8.7　小结　278
第9章　恢复　280
9.1　Oracle事务基本原理　280
9.1.1　SCN　282
9.1.2　检查点　284
9.2　日志　286
9.2.1　日志内容　286
9.2.2　日志线程(Redo Thread)　288
9.2.3　日志写　288
9.3　恢复种类　289
9.3.1　Instance Recovery　291
9.3.2　Crash Recovery　291
9.3.3　Media Recovery　295
9.3.4　Online Block Recovery　295
9.4　介质恢复　296
9.4.1　完全恢复　296
9.4.2　不完全恢复　300
9.4.3　恢复到单实例　312
9.5　其他一些有用的恢复演示　319
9.5.1　从自动备份的中恢复spfile　319
9.5.2　控制文件的恢复　320
9.6　利用恢复的控制文件进行数据库恢复　321
9.6.1　使用alter database open resetlogs的场合　321
9.6.2　重建控制文件　321
9.6.3　使用using backup controlfile的场合　322
9.6.4　例子1：使用备份的控制文件做恢复　322
9.6.5　例子2：用noresetlogs方法重建控制文件　326
9.6.6　例子3：用resetlogs方法重建控制文件　329
9.7　DBID的重要性和获得DBID的方法　330
9.7.1　通过数据文件、日志文件(联机或者归档)　330
9.7.2　根据自动备份的控制文件得到　331
9.8　小结　331
第10章　其他恢复技术　332
10.1　数据块恢复　332
10.2　如何检查数据块一致性　333
10.2.1　使用初始化参数　333
10.2.2　DBV工具　334
10.2.3　Analyze命令　336
10.2.4　RMAN工具　336
10.2.5　dbms_repair包　337
10.3　模拟数据块不一致　337
10.4　数据块不一致处理办法　341
10.4.1　收集信息　342
10.4.2　设计恢复方法　343
10.4.3　恢复操作　344
10.5　数据块恢复实例　346
10.6　Flashback家族介绍　353
10.7　Flashback Database　354
10.7.1　Flashback Database架构　354
10.7.2　启用Flashback Database　354
10.7.3　Flashback Database　356
10.7.4　命令和视图　359
10.8　Flashback Drop　360
10.8.1　Tablespace Recycle Bin　360
10.8.2　Flashback Drop操作　361
10.8.3　Recycly Bin的维护　363
10.9　Flashback Query和Flashback Table　364
10.9.1　Oracle 9i的Flashback Query　364
10.9.2　Flashback Version Query　365
10.9.3　Flashback Transaction Query　379
10.9.4　Flashback Table　381
10.9.5　UNDO Retntion　384
10.10　回滚段损坏后的修复　385
10.10.1　AUM(Automatic Undo Management)　385
10.10.2　如何处理回滚段损坏　397
10.11　小结　410
第11章　RAC和Data Guard　411
11.1　Data Guard介绍　411
11.1.1　Data Guard架构　412
11.1.2　日志发送(Redo Send)　412
11.1.3　日志接收(Redo Receive)　414
11.1.4　日志应用(Redo Apply)　415
11.1.5　Data Guard环境中的重要进程　415
11.1.6　Standby Log File(SRL)　416
11.1.7　数据保护模式　417
11.1.8　自动裂隙检测和解决　419
11.1.9　实时恢复(Real-Time Apply，RTA)　420
11.1.10　RTA引发的思考——关于同步的速度　421
11.1.11　如何监控恢复的性能　421
11.2　RAC和Standby配置实例　422
11.2.1　RAC Primary和Single Standby　423
11.2.2　RAC Primary和RAC Standby　433
11.3　角色转换　444
11.3.1　Switchover　445
11.3.2　Failover　448
11.3.3　Failover步骤　452
11.3.4　Failover的例子　454
11.3.5　Failover之收尾　460
11.4　Standby环境下维护联机日志　464
11.4.1　手工添加日志文件　464
11.4.2　手工删除日志文件　465
11.4.3　通过控制文件重新同步　465
11.5　小结　466
第12章　RAC和Stream Replication　467
12.1　Stream的工作原理　467
12.2　Data Guard和Stream对比　468
12.3　RAC Stream配置实例　469
12.3.1　Single(Source)和RAC(Target)　470
12.3.2　RAC对RAC的复制　474
12.3.3　STRMMON工具　492
12.4　小结　494
第13章　深入ASM　495
13.1　非ASM的存储结构　495
13.2　ASM存储结构　496
13.3　ASM文件系统　497
13.3.1　ASM Metadata　497
13.3.2　Physical Metadata　498
13.3.3　Virtual Metadata　499
13.3.4　Disk Recovery　501
13.3.5　条带化(ASM Striping)　501
13.4　ASM中的文件布局规律　502
13.4.1　OMF　502
13.4.2　OFA　505
13.4.3　FRA(Flash Recovery Area)和OMF　506
13.4.4　ASM文件模板(ASM File Template)　507
13.4.5　ASM别名(ASM File Alias)　507
13.5　RDBMS和ASM之间的交互　522
13.6　ASM的实例恢复　524
13.7　ASM和OS Filesystem之间交互　524
13.7.1　dbms_file_transfer包　525
13.7.2　RMAN的CONVERT方法　530
13.7.3　ASM和TTS　530
13.8　ASM的限制　533
13.9　小结　533
第14章　性能与RAC　534
14.1　RAC性能的若干特点　535
14.1.1　RAC环境的一些特殊注意点　537
14.1.2　RAC特有的性能指标　538
14.1.3　对于延迟时间的深入分析　542
14.1.4　RAC特有的等待事件　545
14.2　AWR　545
14.2.1　启用AWR　546
14.2.2　修改AWR配置　546
14.2.3　产生AWR报告　546
14.3　ASH　547
14.4　GC的调整策略　550
14.5　SQL调整策略　551
14.5.1　SQL语句的执行过程　552
14.5.2　SQL性能调整的基本方法　552
14.5.3　PL/SQL和SQL　555
14.6　小结　557
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大话Oracle RAC
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle内核技术揭密
前　言
第1章　存储结构	1
1.1　区：表空间中的基本单位	1
1.1.1　统一区大小表空间和区的使用规则	2
1.1.2　系统管理区大小	4
1.1.3　碎片：少到可以忽略的问题	7
1.2　段中块的使用	7
1.2.1　块中空间的使用	8
1.2.2　典型问题：堆表是有序的吗	9
1.2.3　ASSM与L3、L2、L1块的意义	10
1.2.4　值得注意的案例：ASSM真的能提高插入并发量吗	12
1.2.5　段头与Extent Map	21
1.2.6　索引范围扫描的操作流程	24
第2章　调优排故方法论	27
2.1　调优排故的一般步骤	28
2.1.1　常见DUMP和Trace文件介绍	28
2.1.2　等待事件	29
2.1.3　各种资料视图介绍	37
2.1.4　等待事件的注意事项	42
2.2　AWR概览	44
2.2.1　AWR报告的注意事项	44
2.2.2　AWR类视图	46
第3章　Buffer Cache内部原理与I/O	51
3.1　HASH链表	51
3.1.1　HASH链表与逻辑读	52
3.1.2　Cache Buffers Chain Latch与Buffer Pin锁	54
3.1.3　Cache Buffers Chain Latch的竞争	61
3.2　检查点队列链表	77
3.2.1　检查点队列	77
3.2.2　检查点队列与实例恢复	82
3.2.3　DBWR如何写脏块	89
3.2.4　如何提高DBWR的写效率	97
3.3　LRU队列	100
3.3.1　主LRU、辅助LRU链表	100
3.3.2　脏链表LRUW	115
3.3.3　Free Buffer Waits	132
3.3.4　谁“扣动”了DBWR的“扳机”	134
3.3.5　日志切换与写脏块	141
3.4　I/O总结	146
3.4.1　逻辑读资料分析	146
3.4.2　减少逻辑读—行的读取	148
3.4.3　物理I/O	161
3.4.4　存储物理I/O能力评估	162
第4章　共享池揭密	166
4.1　共享池内存结构	167
4.1.1　堆、区、Chunk与子堆	167
4.1.2　Chunk类型（x$ksmsp视图）	170
4.1.3　freeabl、recr与LRU链表	171
4.1.4　Free List链表	173
4.1.5　保留池	177
4.1.6　SQL的内存结构：父游标、子游标	178
4.1.7　SQL的内存结构：父游标句柄	181
4.1.8　SQL的Chunk：父游标堆0和DS	183
4.1.9　SQL的Chunk：子游标句柄	186
4.1.10　SQL的Chunk：子游标堆0与堆6	187
4.1.11　SQL所占共享池内存	189
4.1.12　LRU链表：我的共享池大了还是小了	191
4.1.13　ORA-4031的吊诡：错误的报错信息	195
4.1.14　解决ORA-4031之道：如何正确释放内存	201
4.1.15　Session Cached Cursor与内存占用	205
4.2　语句解析和执行	209
4.2.1　SQL执行流程	209
4.2.2　内存锁原理	211
4.2.3　Library Cache Lock/Pin	218
4.2.4　Library Cache Lock/Pin与硬解析	219
4.2.5　Library Cache Lock/Pin与软解析、软软解析	226
4.2.6　NULL模式Library Cache Lock与依赖链	229
4.2.7　存储过程与Library Cache Lock/Pin	229
4.2.8　断开依赖链	235
4.2.9　低级内存锁：Latch	237
4.2.10　Shared Pool Latch	239
4.3　Mutex	242
4.3.1　Mutex基本形式	242
4.3.2　Mutex获取过程：原子指令测试并交换	245
4.3.3　Mutex获取过程：竞争与Gets资料的更新	249
4.3.4　Mutex获取过程：共享Mutex与独占Mutex	250
4.3.5　独占Mutex的获取和释放过程	252
4.3.6　Mutex获取过程：Sleeps与CPU	254
4.4　Mutex与解析	261
4.4.1　Mutex类型	262
4.4.2　HASH Bucket与HASH链	262
4.4.3　Handle（句柄）与Library Cache Lock	262
4.4.4　HASH Table型Mutex	263
4.4.5　执行计划与Cursor Pin	264
4.5　通过Mutex判断解析问题	265
4.5.1 　硬解析时的竞争	265
4.5.2　软解析和软软解析	266
4.5.3　解决解析阶段的竞争	267
4.5.4　过度软软解析竞争的解决	268
4.5.5　Select与执行	271
第5章　Redo调优与备份恢复原理	277
5.1　非IMU与IMU Redo格式的不同	277
5.2　解析Redo数据流	282
5.3　IMU与非IMU相关的Redo Latch	287
5.4　Redo Allocation Latch	288
5.5　Log Buffer空间的使用	290
5.6　LGWR与Log File Sync和Log File Parallel Write	297
5.7　IMU什么情况下被使用	300
第6章　UNDO	302
6.1　事务基本信息	302
6.2　回滚段空间重用规则	307
6.2.1　UNDO块的SEQ值	308
6.2.2　UNDO段的Extend	310
6.2.3　Steal Undo Extent：诡异的UNDO空间不足问题	311
6.2.4　回滚空间重用机制：UNDO块重用规则	313
第7章　ASM	317
7.1　ASM文件格式	317
7.1.1　ASM文件	317
7.1.2　使用kfed挖掘ASM文件格式	319
7.2　AU与条带	328
7.2.1　粗粒度不可调条带	329
7.2.2　细粒度可调条带	329
7.2.3　AU与条带的作用	331
7.2.4　DG中盘数量对性能的影响	332
7.2.5　最大I/O与最小I/O	333
7.2.6　数据分布对性能的影响	334
7.2.7　案例精选：奇怪的IO问题	335
7.2.8　大AU和小AU性能对比	340
7.2.9　 AU与条带总结	341
7.2.10　OLTP与大条带	342
附录　HASH算法简单介绍	344
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle内核技术揭密
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>SQL优化最佳实践
前言
第一篇　引入篇
第0章　引言2
第1章　与SQL优化相关的几个案例4
案例1　一条SQL引发的血案4
案例2　糟糕的结构设计带来的问题6
案例3　规范SQL写法好处多9
案例4　“月底难过”11
案例5　COUNT(*)到底能有多快13
案例6　“抽丝剥茧”找出问题所在17
第二篇　原理篇
第2章　优化器与成本22
2.1　优化器22
2.1.1　基于规则的优化器23
2.1.2　基于成本的优化器25
2.1.3　对比两种优化器26
2.1.4　优化器相关参数27
2.1.5　优化器相关Hint30
2.2　成本35
2.2.1　基本概念35
2.2.2　计算公式36
2.2.3　计算示例36
第3章　执行计划40
3.1　概述40
3.1.1　什么是执行计划40
3.1.2　库执行计划存储方式42
3.2　解读执行计划43
3.2.1　执行顺序43
3.2.2　访问路径45
3.3　执行计划操作45
3.3.1　查看执行计划45
3.3.2　固定执行计划72
3.3.3　修改执行计划80
第4章　统计信息84
4.1　统计信息分类84
4.1.1　系统统计信息84
4.1.2　对象统计信息87
4.1.3　数据字典统计信息109
4.1.4　内部对象统计信息109
4.2　统计信息操作109
4.2.1　系统统计信息110
4.2.2　对象统计信息111
4.2.3　数据字典统计信息115
4.2.4　内部对象统计信息115
第5章　SQL解析与游标116
5.1　解析步骤116
5.2　解析过程117
5.3　游标示例119
第6章　绑定变量122
6.1　使用方法122
6.2　绑定变量与解析124
6.3　游标共享129
第7章　SQL优化相关对象131
7.1　表131
7.2　字段137
7.3　索引140
7.4　视图148
7.5　函数149
7.6　数据链（DB_LINK）150
第8章　SQL优化相关存储结构153
8.1　表空间153
8.2　段154
8.3　区155
8.4　块156
第9章　特有SQL160
9.1　MERGE160
9.2　INSERT ALL162
9.3　WITH162
9.4　CONNECT BY /START WITH163
第三篇　实战篇
第10章　查询转换166
10.1　查询转换的分类及说明166
10.2　查询转换—子查询类168
10.3　查询转换—视图类174
10.4　查询转换—谓词类178
10.5　查询转换—消除类180
10.6　查询转换—其他181
第11章　访问路径189
11.1　表访问路径189
11.1.1　全表扫描189
11.1.2　ROWID扫描193
11.1.3　采样扫描194
11.2　B树索引访问路径195
11.3　位图索引访问路径205
11.4　其他访问路径210
第12章　表间关联215
12.1　关联关系215
12.2　表关联实现方法218
12.3　嵌套循环连接220
12.4　排序合并连接226
12.5　哈希连接232
12.6　其他连接方式238
第13章　半连接与反连接243
13.1　半连接243
13.2　反连接246
第14章　排序250
14.1　引发排序的操作250
14.2　避免和减少排序251
14.2.1　优化原则及基本方法251
14.2.2　避免排序的示例252
14.3　排序过程及内存使用255
14.4　执行计划中的“Sort”258
第15章　子查询262
15.1　处理方式262
15.2　子查询分类263
15.2.1　按照语法分类263
15.2.2　按照谓词分类263
15.2.3　示例264
15.3　子查询优化266
15.4　子查询特殊问题272
15.4.1　空值问题272
15.4.2　OR问题274
15.4.3　[NOT] IN/EXISTS问题275
第16章　并行276
16.1　并行操作276
16.1.1　并行查询277
16.1.2　并行DML280
16.1.3　并行DDL283
16.2　并行级别286
16.3　并行原理286
16.3.1　从属进程286
16.3.2　粒度287
附录A　常用技巧290
附录B　SQL优化参数295
附录C　SQL优化数据字典298
附录D　SQL优化等待事件300
附录E　SQL优化提示303
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>SQL优化最佳实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle PL/SQL从入门到精通
第1篇  PL/SQL开发入门第1章  Oracle 11g数据库系统(教学视频：40分钟)  1.1  关系型数据库系统介绍    1.1.1  什么是关系型数据模型    1.1.2  数据库系统范式    1.1.3  关系型数据库管理系统    1.1.4  使用SQL语句与数据库管理系统通信  1.2  初识Oracle 11g    1.2.1  Oracle 11g简介    1.2.2  Oracle 11g体系结构    1.2.3  如何创建数据库    1.2.4  比较Oracle数据库与SQL Server数据库  1.3  什么是PL/SQL    1.3.1  PL/SQL是一种语言    1.3.2  PL/SQL的执行环境  1.4  搭建PL/SQL开发环境    1.4.1  使用SQL*Plus    1.4.2  使用Oracle SQL Developer    1.4.3  PL/SQL Developer开发PL/SQL    1.4.4  Quest Toad开发PL/SQL    1.4.5  使用Oracle文档库  1.5  小结第2章  PL/SQL基本概念(教学视频：30分钟)  2.1  功能特点    2.1.1  结构化程序设计    2.1.2  与SQL语言整合    2.1.3  面向对象开发    2.1.4  模块化应用程序开发    2.1.5  提高应用程序性能  2.2  语言特性    2.2.1  PL/SQL块结构    2.2.2  变量和类型    2.2.3  程序控制语句    2.2.4  过程、函数与包    2.2.5  触发器    2.2.6  结构化异常处理    2.2.7  集合与记录    2.2.8  游标    2.2.9  动态SQL  2.3  编码风格    2.3.1  PL/SQL词法单位    2.3.2  缩进    2.3.3  标识符命名规则    2.3.4  大小写风格    2.3.5  使用工具格式化代码  2.4  小结第3章  变量和类型(教学视频：14分钟)  3.1  变量    3.1.1  变量的声明    3.1.2  变量的赋值    3.1.3  使用%TYPE    3.1.4  使用%ROWTYPE    3.1.5  变量的作用域和可见性    3.1.6  常量的定义  3.2  数据类型    3.2.1  字符类型    3.2.2  数字类型    3.2.3  日期和时间类型    3.2.4  布尔类型    3.2.5  LOB对象类型    3.2.6  引用类型    3.2.7  复合类型    3.2.8  用户自定义子类型    3.2.9  数据类型转换  3.3  运算符和表达式    3.3.1  运算符类型    3.3.2  运算符的优先级    3.3.3  表达式类型  ……第4章  PL/SQL控制语句(教学视频：13分钟)第2篇  PL/SQL开发基础第5章  管理数据表(教学视频：33分钟)第6章  查询数据表(教学视频：33分钟)第7章  操纵数据表(教学视频：27分钟)第8章  记录与集合(教学视频：32分钟)第9章  SQL内置函数(教学视频：26分钟)第10章  使用游标(教学视频：20分钟)第11章  事务处理和锁定(教学视频：14分钟)第12章  异常处理机制(教学视频：19分钟)第3篇  PL/SQL进阶编程第13章  PL/SQL子程序(教学视频：18分钟)第14章  包(教学视频：10分钟)第15章  触发器(教学视频：23分钟)第16章  动态SQL语句(教学视频：17分钟)第4篇  PL/SQL高级编程第17章  面向对象编程(教学视频：24分钟)第18章  PL/SQL性能优化建议(教学视频：14分钟)第5篇  PL/SQL案例实战第19章  企业IC芯片欠料计算程序(教学视频：28分钟)第20章  PL/SQL邮件发送程序(教学视频：33分钟)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle PL/SQL从入门到精通
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>循序渐进Oracle
第1章　Oracle数据库的创建　1
1.1　Oracle软件的获取与安装　1
1.1.1　Oracle软件的获取　1
1.1.2　Oracle的补丁集　3
1.2　使用DBCA创建数据库　5
1.2.1　DBCA的启动　5
1.2.2　模板选择及EM选项　6
1.2.3　数据库安全与口令　8
1.2.4　存储管理及选件　8
1.2.5　初始化参数选择设定　10
1.2.6　文件存储及创建选项　11
1.2.7　告警日志及跟踪文件　12
1.3　数据库创建的脚本　13
1.3.1　数据库创建脚本　13
1.3.2　创建的起点　14
1.3.3　ORADIM工具的使用　14
1.3.4　ORACLE_SID的含义　15
1.3.5　INSTANCE_NAME的含义及作用　19
1.3.6　Oracle的口令文件　20
1.3.7　脚本的执行　24
1.3.8　db_name参数和instance_name参数　24
1.3.9　sql.bsq文件与数据库创建　28
1.3.10　数据文件及字典的创建　29
1.4　使用模板创建数据库　30
1.4.1　启动创建　31
1.4.2　数据库创建模板　31
1.4.3　rman的引入　32
1.4.4　克隆数据库　35
1.4.5　传输表空间技术　37
1.4.6　跨平台表空间传输　41
1.4.7　文件系统与ASM的切换　60
1.4.8　DBMS_FILE_TRANSFER的可选性　63
1.4.9　用户的锁定　66
1.4.10　最后的脚本　67
1.4.11　使用模板建库注意事项　68
1.5　案例与实践分析　70
1.5.1　auto_space_advisor_job_proc案例一则　70
1.5.2　systemstate转储案例分析一则　72
第2章　从OEM到Grid Control　79
2.1　Oracle的OEM工具　79
2.1.1　传统的OEM工具　80
2.1.2　安装Database Control选件　82
2.1.3　手工配置DBControl　83
2.1.4　启停DBConsole服务　86
2.1.5　关于DBControl乱码的解决　87
2.1.6　登录及口令文件认证　87
2.1.7　通过DBControl登录数据库　88
2.1.8　定义自动邮件告警　89
2.2　Oracle的iSQL*Plus工具　92
2.2.1　Oracle 9i的iSQL*Plus　92
2.2.2　Oracle 10g的iSQL*Plus工具　95
2.2.3　SQL*Plus的使用　99
2.3　Oracle的Grid Control工具　103
2.3.1　Grid Control体系结构简介　104
2.3.2　Grid Control OMS部署方法　104
2.3.3　Grid Control Agent部署方法　110
2.3.4　Grid Control部署注意事项及常见问题　114
2.3.5　Grid Control应用之物理Data Guard创建与管理　119
2.3.6　Grid Control 11g的增强　133
2.3.7　Grid Control小结　148
第3章　Oracle的字符集　149
3.1　字符集的基本知识　149
3.2　数据库的字符集　150
3.3　字符集文件及字符支持　151
3.4　NLS_LANG的设置与影响　153
3.5　导入导出及字符转换　155
3.6　字符集的更改　157
3.7　识别导出文件的字符集　161
3.8　使用csscan辅助字符集转换　166
3.9　乱码的产生　167
3.9.1　NLS_LANG字符集与数据库字符集不同　168
3.9.2　NLS_LANG字符集和数据库字符集相同　169
3.10　“靠”字的困惑　170
3.11　自定义字符的使用　173
3.12　更改字符集的内部方式　174
3.13　字符集更改的案例　176
第4章　用户的创建与管理　178
4.1　数据库的连接　178
4.2　用户的创建　181
4.3　口令的管理　184
4.3.1　Oracle 10g失败登录的记录　184
4.3.2　Oracle 11g口令大小写的区分　186
4.3.3　Oracle 11g缺省口令的跟踪　187
4.3.4　Oracle口令的复杂度校验　189
4.4　权限的授予　191
4.5　角色　197
4.6　Public的特殊作用　199
4.7　过度授权的风险　201
4.8　数据字典的访问　205
4.9　外部认证　208
4.10　SYS用户行为审计　210
4.11　用户行为审计与FGA　213
4.12　如何切换用户身份　217
4.13　通过代理用户(Proxy)连接数据库　217
第5章　表空间和数据文件　220
5.1　表空间的创建　221
5.2　表空间管理技术　222
5.2.1　字典管理表空间　222
5.2.2 本地管理表空间　225
5.3　段空间管理技术　231
5.3.1　手工段空间管理(Manual Segment Space Management)　232
5.3.2　自动段空间管理(Auto Segment Space Management)　233
5.3.3　延迟段空间创建(Deferred Segment Creation)　245
5.4　Oracle的存储信息　248
5.4.1　表空间信息记录(DBA_TABLESPACES)　248
5.4.2　数据文件信息记录(DBA_DATA_FILES)　249
5.4.3　数据段信息(DBA_SEGMENTS)　250
5.4.4　区间信息(DBA_EXTENTS)　264
5.4.5　段级统计信息(V$SEGMENT_STATISTICS)　266
5.4.6　度量信息(DBA_THRESHOLDS)　268
5.4.7　突出告警信息(DBA_OUT STANDING_ALERTS)　269
5.4.8　告警历史信息(DBA_ALERT_HISTORY)　269
5.5　使用DB Control进行空间管理　270
5.6　SYSTEM表空间　274
5.6.1　SYSTEM表空间及root dba　274
5.6.2　Oracle中独一无二的Cache对象　275
5.6.3　Oracle数据库的引导　280
5.7　SYSAUX表空间　282
5.7.1　SYSAUX表空间及其组件　282
5.7.2　SYSAUX空间组件的转移　284
5.7.3　SYSAUX的作用与意义　285
5.8　BigFile和SmallFile表空间技术　287
5.9　ROWID与RDBA的转换　289
5.9.1　Oracle的ROWID及数据库限制　289
5.9.2　BigFile表空间的ROWID　290
5.9.3　使用dbms_rowid包获得ROWID的详细信息　290
5.10　使用OMF管理数据文件　291
第6章　自动存储管理(ASM)　294
6.1　ASM的历史　294
6.2　ASM的安装配置　295
6.3　ASM实例　297
6.4　ASM的用户管理　299
6.5　ASM磁盘组　300
6.5.1　ASMLib管理磁盘　300
6.5.2　ASM存储Voting和OCR　306
6.5.3　强制删除磁盘组　308
6.6　手工创建ASM实例及磁盘组　309
6.7　ASM的空间管理　312
6.8　可变大小区(Variable-Size Extents)　315
6.9　ASM的元数据　321
6.10　ASM元数据的备份与恢复　326
6.11　ASM磁盘组的动态扩展能力　329
6.12　快速镜像同步(Fast Mirror Resync)　331
6.13　ASM的透明多版本支持　333
6.14　ASM的命令行管理工具asmcmd　334
6.15　通过EM管理ASM　334
6.16　ACFS(ASM Cluster File System)　336
6.17　ACFS的加载步骤　342
6.18　ASM管理的内部工具　344
6.18.1　KFED工具　344
6.18.2　KFOD工具　346
6.18.3　AMDU工具　346
第7章　临时表空间和临时文件　349
7.1　临时表空间原理　349
7.2　Oracle 8i的临时表空间　353
7.3　Oracle 9i的临时表空间　354
7.4　Oracle 9i中如何重建与切换临时表空间　355
7.5　Oracle 10g的临时表空间组　356
7.6　Oracle 10gR2使用RMAN恢复临时表空间的增强　360
7.7　临时表空间过度扩展的问题解决　361
7.8　从V$SORT_USAGE到V$TEMPSEG_USAGE　363
7.9　临时文件file#和db_files的关系　364
7.10　LOB对象与临时段　365
7.11　临时文件和稀疏文件　366
7.12　临时表空间诊断案例一则　369
第8章　备份与恢复　372
8.1　备份与恢复概述　372
8.2　备份方法　372
8.3　恢复原理　373
8.4　检查点与RBA　374
8.5　数据库的运行模式　376
8.6　逻辑备份与恢复　381
8.6.1　使用EXP进行逻辑备份　381
8.6.2　使用IMP进行逻辑恢复　386
8.6.3　使用数据泵(EXPDP/IMPDP)　389
8.7　物理备份与恢复　395
8.7.1　冷备份　395
8.7.2　热备份　396
8.7.3　RMAN的备份与恢复　405
第9章　备份方案与特例恢复　454
9.1　用Plus archvielog选项简化备份　454
9.2　Nocatalog方式的备份方案制定　457
9.3　使用逻辑备份辅助物理备份　459
9.4　使用控制文件快照辅助恢复　462
9.5　归档逐步应用辅助数据迁移　467
9.6　_allow_resetlogs_corruption参数　470
9.7　ORA-600 2662错误的应对　472
9.8　_corrupted_rollback_segments参数　474
9.9　Oracle 10g跨越Resetlogs时间点的恢复　477
9.10　使用RMAN进行基于数据块的恢复　480
9.11　Oracle 10g备份集压缩(Backupset Compression)　482
9.12　使用RMAN恢复备份集到不同主机　484
9.13　单机搭建DataGuard环境的测试　488
第10章　Oracle的闪回特性　495
10.1　Oracle 9i的闪回查询特性　495
10.1.1　闪回查询的使用　496
10.1.2　使用Oracle 9i闪回查询特性恢复案例　496
10.2　SMON_SCN_TIME与闪回查询　498
10.2.1　Oracle 9i中的SMON_SCN_TIME　498
10.2.2　Oracle 10g中的SMON_SCN_TIME　502
10.2.3　Oracle 10g中的SCN与时间的映射及转换　504
10.2.4　Oracle 11g中的进一步演进　506
10.3　Oracle log的闪回特性　507
10.3.1　Oracle的数据库级闪回　507
10.3.2　Oracle的flashback drop功能　511
10.3.3　Oracle 10g的Flashback Version Query　517
10.3.4　通过Flashback Transaction Query进行事务撤销　519
10.3.5　闪回表　520
10.3.6　Oracle 11g闪回数据归档　524
10.4　使用函数辅助闪回　528
10.4.1　Oracle 10g新的内建函数ora_rowscn　528
10.4.2　结合ora_rowscn进行闪回恢复　532
第11章　Oracle的数据加载与卸载　534
11.1　外部表与SQLLDR　534
11.2　使用外部表访问警告日志文件　538
11.2.1　创建Directory　538
11.2.2　创建及访问外部表　538
11.3　使用外部表访问监听日志　540
11.3.1　定位监听器日志文件　540
11.3.2　创建Directory　541
11.3.3　创建外部表　541
11.3.4　查询外部表　541
11.3.5　使用范例　542
11.4　使用外部表访问跟踪文件　547
11.5　使用外部表分析网站访问日志　549
11.6　获得操作系统文件列表　552
11.6.1　创建临时表　552
11.6.2　创建存储过程　553
11.6.3　执行获取数据　554
11.7　使用数据泵进行数据卸载　555
11.7.1　使用数据泵外部表卸载数据　555
11.7.2　通过并行处理提高性能　558
11.8　Oracle 11g外部表的增强　559
11.8.1　卸载数据压缩　559
11.8.2　卸载数据加密　560
11.9　使用工具ociuldr进行数据卸载　561
第12章　从Statspack到ADDM　563
12.1　Statspack概述　563
12.1.1　数据库参数修改　564
12.1.2　安装Statspack　564
12.1.3　spcreate的内容　568
12.1.4　测试Statspack　568
12.1.5　规划自动任务　569
12.1.6　生成分析报告　570
12.1.7　移除定时任务　571
12.1.8　删除历史数据　571
12.1.9　其他重要脚本　574
12.1.10　调整STATSPACK的收集门限　574
12.1.11　ORA-00001错误解决　575
12.1.12　Oracle 10g Statspack报告的增强　577
12.2　Statspack报告各部分说明　577
12.2.1　第一部分：数据库概要信息　578
12.2.2　第二部分：负载概要信息　578
12.2.3　第三部分：实例效率百分比　585
12.2.4　第四部分：数据库的响应时间　590
12.2.5　第五部分：主机系统信息　594
12.2.6　第六部分：详细信息　594
12.3　整理分析结果　597
12.3.1　物理读写IO操作　597
12.3.2　Buffer命中率　598
12.4　最重要的九大性能视图　599
12.4.1　我的命题　599
12.4.2　我的答案　600
12.5　session历史信息的记录　602
12.5.1　v$session视图的增强　603
12.5.2　新增v$session_wait_history视图　604
12.6　ASH新特性的引入　604
12.6.1　ASH概述　604
12.6.2　ASH报告　606
12.7　自动负载信息库(AWR)的引入　613
12.7.1　AWR概述　613
12.7.2　AWR信息的修改　615
12.7.3　AWR报告的生成　617
12.7.4　AWR比较报告的生成　619
12.7.5　基线(Baseline)　620
12.7.6　AWR报告的分析　621
12.7.7　通过EM生成AWR报告　623
12.7.8　AWR数据的导出导入　625
12.7.9　多数据库实例的对比报告　634
12.7.10　AWR报告的实现　635
12.8　自动数据库诊断监控(ADDM)的引入　638
12.8.1　ADDM概述　638
12.8.2　ADDM报告的生成　638
12.8.3　使用EM生成ADDM报告　640
12.9　理解等待事件　641
12.10　通过采样数据绘制趋势曲线　646
第13章　故障诊断及分析方法　651
13.1　故障树分析法　651
13.1.1　故障树分析法对于数据库故障解决的意义　651
13.1.2　故障树分析模型的建立　652
13.2　故障树分析法在故障解决中的应用　655
13.2.1　性能缓慢到CPU消耗的定位　655
13.2.2　CPU到进程的故障树分析　655
13.2.3　进一步诊断应用问题　656
13.2.4　从SQL到问题本质的诊断　658
13.2.5　调整并最终解决问题　659
13.2.6　性能何以提高　660
13.3　故障树分析法应用的总结　661
后记　662
新版后记　664
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>循序渐进Oracle
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle触发器与存储过程高级编程
第1章&nbsp; 关系数据库表&nbsp;11.1&nbsp; 关系表&nbsp;11.2&nbsp; SQL&nbsp;41.2.1&nbsp; ANSI标准&nbsp;41.2.2&nbsp; SQL数据库&nbsp;51.2.3&nbsp; SQL实现&nbsp;51.2.4&nbsp; SQL*Plus&nbsp;71.3&nbsp; 表&nbsp;81.3.1&nbsp; 数据模型视图

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle触发器与存储过程高级编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Oracle SQL（第2版）
第1章 SQL核心 1
1.1 SQL语言 1
1.2 数据库的接口 2
1.3 SQL*Plus回顾 3
1.3.1 连接到数据库 3
1.3.2 配置SQL*Plus环境 4
1.3.3 执行命令 6
1.4 5个核心的SQL语句 8
1.5 SELECT语句 8
1.5.1 FROM子句 10
1.5.2 WHERE子句 11
1.5.3 GROUP BY子句 11
1.5.4 HAVING子句 12
1.5.5 SELECT列表 13
1.5.6 ORDER BY子句 13
1.6 INSERT语句 14
1.6.1 单表插入 14
1.6.2 多表插入 15
1.7 UPDATE语句 17
1.8 DELETE语句 20
1.9 MERGE语句 22
1.10 小结 24
第2章 SQL执行 25
2.1 Oracle架构基础 25
2.2 SGA共享池 26
2.3 库高速缓存 27
2.4 完全相同的语句 28
2.5 SGA缓冲区缓存 31
2.6 查询转换 34
2.6.1 查询块 35
2.6.2 视图合并 37
2.6.3 子查询解嵌套 41
2.6.4 联结消除 43
2.6.5 排序消除 45
2.6.6 谓词推进 46
2.6.7 使用物化视图进行查询重写 48
2.7 确定执行计划 50
2.8 执行计划并取得数据行 54
2.9 SQL执行——总览 56
2.10 小结 57
第3章 访问和联结方法 58
3.1 全扫描访问方法 58
3.1.1 如何选择全扫描操作 59
3.1.2 全扫描与舍弃 62
3.1.3 全扫描与多块读取 63
3.1.4 全扫描与高水位线 63
3.2 索引扫描访问方法 68
3.2.1 索引结构 69
3.2.2 索引扫描类型 71
3.2.3 索引唯一扫描 75
3.2.4 索引范围扫描 76
3.2.5 索引全扫描 77
3.2.6 索引跳跃扫描 80
3.2.7 索引快速全扫描 81
3.3 联结方法 82
3.3.1 嵌套循环联结 83
3.3.2 排序—合并联结 85
3.3.3 散列联结 86
3.3.4 笛卡儿联结 89
3.3.5 外联结 90
3.4 小结 95
第4章 SQL是关于集合的 96
4.1 以面向集合的思维方式来思考 96
4.1.1 从面向过程转变为基于集合的思维方式 97
4.1.2 面向过程与基于集合的思维方式：例子 100
4.2 集合运算 102
4.2.1 UNION和UNION ALL 103
4.2.2 MINUS 106
4.2.3 INTERSECT 107
4.3 集合与空值 108
4.3.1 空值与非直观结果 108
4.3.2 空值与集合运算 111
4.3.3 空值与GROUP BY和ORDER BY 112
4.3.4 空值与聚合函数 114
4.4 小结 114
第5章 提出问题 115
5.1 问出好的问题 115
5.2 提问的目的 116
5.3 问题的种类 116
5.4 问题的问题 118
5.5 数据的问题 120
5.6 建立逻辑表达式 125
5.7 小结 130
第6章 SQL执行计划 131
6.1 解释计划 131
6.1.1 使用解释计划 131
6.1.2 PLAN_TABLE 133
6.1.3 分解计划 135
6.1.4 导致解释计划未达目的的原因 136
6.1.5 阅读计划 139
6.1.6 访问和筛选谓语 140
6.1.7 使计划便于阅读 141
6.2 执行计划 142
6.2.1 查看最近生成的SQL语句 142
6.2.2 查看相关执行计划 142
6.2.3 收集执行计划统计信息 144
6.2.4 标识SQL语句以便以后取回计划 146
6.2.5 深入理解DBMS_XPLAN 149
6.2.6 使用SQL监控报告 154
6.2.7 使用计划信息解决问题 157
6.3 小结 166
第7章 高级分组 167
7.1 基本的GROUP BY用法 167
7.2 HAVING子句 170
7.3 GROUP BY的“新”功能 172
7.4 GROUP BY的CUBE扩展 172
7.5 CUBE的实际应用 178
7.6 用GROUPING()函数排除空值 184
7.7 用GROUPING()扩展报告 185
7.8 用GROUPING_ID()扩展报告 186
7.9 GROUPING SETS与ROLLUP() 190
7.10 GROUP BY局限性 192
7.11 小结 195
第8章 分析函数 196
8.1 概览 196
8.2 示例数据 197
8.3 分析函数剖析 197
8.4 函数列表 198
8.5 聚合函数 199
8.5.1 跨越整个分区的聚合函数 200
8.5.2 细粒度窗口声明 201
8.5.3 默认窗口声明 201
8.6 lead和lag 201
8.6.1 语法和排序 202
8.6.2 例1：从前一行中返回一个值 202
8.6.3 理解数据行的位移 203
8.6.4 例2：从下一行中返回一个值 203
8.7 first_value和last_value 204
8.7.1 例子：使用first_value计算最大值 205
8.7.2 例子：使用last_value计算最小值 206
8.8 其他分析函数 206
8.8.1 nth_value 206
8.8.2 rank 208
8.8.3 dense_rank 209
8.8.4 row_number 210
8.8.5 ratio_to_report 211
8.8.6 percent_rank 212
8.8.7 percentile_cont 213
8.8.8 percentile_disc 215
8.8.9 NTILE 216
8.8.10 stddev 217
8.8.11 listagg 218
8.9 性能调优 219
8.9.1 执行计划 220
8.9.2 谓词 220
8.9.3 索引 221
8.10 高级话题 222
8.10.1 动态SQL 222
8.10.2 嵌套分析函数 224
8.10.3 并行 224
8.10.4 PGA大小 225
8.11 组织行为 225
8.12 小结 226
第9章 MODEL子句 227
9.1 电子表格 228
9.2 使用MODEL子句实现跨行引用 228
9.2.1 示例数据 228
9.2.2 剖析MODEL子句 229
9.2.3 规则 230
9.3 位置和符号引用 231
9.3.1 位置标记 231
9.3.2 符号标记 232
9.3.3 FOR循环 233
9.4 返回更新后的行 234
9.5 求解顺序 235
9.5.1 行求解顺序 235
9.5.2 规则求解顺序 237
9.6 聚合 239
9.7 迭代 240
9.7.1 示例 240
9.7.2 PRESENTV与空值 241
9.8 查找表 242
9.9 空值 244
9.10 使用MODEL子句进行性能调优 245
9.10.1 执行计划 245
9.10.2 谓词推进 248
9.10.3 物化视图 250
9.10.4 并行 251
9.10.5 MODEL子句执行中的分区 252
9.10.6 索引 253
9.11 子查询因子化 254
9.12 小结 255
第10章 子查询因子化 256
10.1 标准用法 256
10.2 用WITH定义PL/SQL函数 259
10.3 SQL优化 261
10.3.1 测试执行计划 261
10.3.2 测试查询改变的影响 265
10.3.3 寻找其他优化机会 268
10.3.4 将子查询因子化应用到PL/SQL中 272
10.4 递归子查询 275
10.4.1 CONNECT BY示例 275
10.4.2 RSF示例 277
10.4.3 RSF的限制条件 278
10.4.4 与CONNECT BY的不同点 278
10.5 复制CONNECT BY的功能 279
10.5.1 LEVEL伪列 280
10.5.2 SYS_CONNECT_BY_PATH函数 281
10.5.3 CONNECT_BY_ROOT运算符 283
10.5.4 CONNECT_BY_ISCYCLE伪列和NOCYCLE参数 285
10.5.5 CONNECT_BY_ISLEAF伪列 288
10.6 小结 292
第11章 半联结和反联结 294
11.1 半联结 294
11.2 半联结执行计划 302
11.3 控制半联结执行计划 307
11.3.1 使用提示控制半联结执行计划 307
11.3.2 在实例级控制半联结执行计划 309
11.4 半联结限制条件 311
11.5 半联结必要条件 313
11.6 反联结 314
11.7 反联结执行计划 318
11.8 控制反联结执行计划 327
11.8.1 使用提示控制反联结执行计划 327
11.8.2 在实例级控制反联结执行计划 328
11.9 反联结限制条件 331
11.10 反联结必要条件 334
11.11 小结 334
第12章 索引 335
12.1 理解索引 336
12.1.1 什么时候使用索引 336
12.1.2 列的选择 338
12.1.3 空值问题 339
12.2 索引结构类型 340
12.2.1 B-树索引 340
12.2.2 位图索引 341
12.2.3 索引组织表 342
12.3 分区索引 344
12.3.1 局部索引 344
12.3.2 全局索引 346
12.3.3 散列分区与范围分区 347
12.4 与应用特点相匹配的解决方案 350
12.4.1 压缩索引 350
12.4.2 基于函数的索引 352
12.4.3 反转键索引 354
12.4.4 降序索引 355
12.5 管理问题的解决方案 356
12.5.1 不可见索引 356
12.5.2 虚拟索引 358
12.5.3 位图联结索引 358
12.6 小结 360
第13章 SELECT以外的内容 361
13.1 INSERT 361
13.1.1 直接路径插入 361
13.1.2 多表插入 363
13.1.3 条件插入 365
13.1.4 DML错误日志 365
13.2 UPDATE 371
13.2.1 CTAS与UPDATE的差别 371
13.2.2 INSERT APPEND与UPDATE的差别 374
13.3 DELETE 377
13.4 MERGE 380
13.4.1 语法和用法 380
13.4.2 性能比较 384
13.5 小结 385
第14章 事务处理 387
14.1 什么是事务 387
14.2 事务的ACID属性 388
14.3 事务隔离级别 389
14.4 多版本读一致性 391
14.5 事务控制语句 392
14.5.1 Commit(提交) 392
14.5.2 Savepoint(保存点) 392
14.5.3 Rollback(回滚) 392
14.5.4 Set Transaction(设置事务) 392
14.5.5 Set Constraints(设置约束) 393
14.6 将运算分组为事务 393
14.7 订单录入模式 394
14.8 活动事务 400
14.9 使用保存点 401
14.10 序列化事务 404
14.11 隔离事务 407
14.12 自治事务 410
14.13 小结 414
第15章 测试与质量保证 415
15.1 测试用例 416
15.2 测试方法 417
15.2.1 单元测试 418
15.2.2 回归测试 421
15.2.3 模式修改 422
15.2.4 重复单元测试 425
15.3 执行计划比较 426
15.4 性能测量 431
15.4.1 在代码中加入性能测量 432
15.4.2 性能测试 436
15.5 破坏性测试 437
15.6 使用性能测量进行系统检修 439
15.7 小结 441
第16章 计划稳定性 443
16.1 计划不稳定性：理解这个问题 443
16.1.1 统计信息的变化 444
16.1.2 运行环境的改变 446
16.1.3 SQL语句的改变 448
16.1.4 绑定变量窥视 448
16.1.5 自适应游标共享 451
16.2 统计信息反馈 455
16.3 识别执行计划的不稳定性 459
16.3.1 抓取当前运行查询的数据 460
16.3.2 查看语句的性能历史 461
16.3.3 按照执行计划聚合统计信息 462
16.3.4 寻找执行计划的统计方差 463
16.3.5 在一个时间点附近检查偏差 464
16.4 小结 465
第17章 计划控制 466
17.1 执行计划控制：解决问题 466
17.1.1 调整查询结构 467
17.1.2 适当使用常量 467
17.1.3 给优化器一些提示 467
17.2 执行计划控制：不能直接访问代码 475
17.2.1 选项1：改变统计信息 475
17.2.2 选项2：改变数据库参数 477
17.2.3 选项3：增加或移除访问路径 478
17.2.4 选项4：应用基于提示的执行计划控制机制 478
17.2.5 大纲 479
17.2.6 SQL概要文件 482
17.2.7 SQL执行计划基线 498
17.2.8 SQL补丁 507
17.2.9 基于提示的计划控制机理小结 509
17.3 小结 509
第18章 其他SQL结构 510
18.1 条件逻辑结构 510
18.1.1 DECODE 510
18.1.2 CASE 511
18.1.3 NVL、NVL2和COALESCE 515
18.1.4 NULLIF 517
18.2 PIVOT/UNPIVOT查询 518
18.2.1 PIVOT 518
18.2.2 UNPIVOT 523
18.3 生成测试数据的SQL 526
18.3.1 想要得到什么样的数据 526
18.3.2 CONNECT BY 527
18.3.3 MODEL子句 529
18.3.4 递归WITH子句 529
18.3.5 数据生成小结 530
18.4 小结 530
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Oracle SQL（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle PL/SQL攻略
第1章 PL/SQL 基础　　1
1.1　 创建代码块　　1
问题　　1
解决方案　　1
原理分析　　1
1.2　 在SQL*Plus 里执行代码块　　2
问题　　2
解决方案　　2
原理分析　　2
1.3 　把代码保存到脚本中　　3
问题　　3
解决方案　　3
原理分析　　3
1.4 　执行脚本　　4
问题　　4
解决方案　　4
原理分析　　4
1.5　 接受用户键盘输入　　5
问题　　5
解决方案　　5
原理分析　　5
1.6 　在SQL*Plus 里显示结果　　7
问题　　7
解决方案　　7
原理分析　　7
1.7　 在代码中添加注释　　8
问题　　8
解决方案　　8
原理分析　　8
1.8 　引用代码块　　9
问题　　9
解决方案　　9
原理分析　　9
1.9 　从嵌套块中引用变量　　10
问题　　10
解决方案　　10
原理分析　　11
1.10 　忽略替换变量　　11
问题　　11
解决方案1　　11
解决方案2　　11
原理分析　　12
1.11 　改变替换变量字符 12
问题　　12
解决方案　　13
原理分析　　13
1.12 　创建匹配数据库列类型的变量　　13
问题　　13
解决方案　　13
原理分析　　14
第2章 基本的SQL 操作　　15
2.1　 从数据库检索单行数据　　15
问题　　15
解决方案1　　15
解决方案2　　16
原理分析　　17
2.2　 限定列名与变量名　　18
问题　　18
解决方案　　18
原理分析　　19
2.3　 声明与列类型匹配的变量类型　　19
问题　　19
解决方案　　19
原理分析　　20
2.4　 把查询结果返回到PL/SQL 记录中　　20
问题　　20
解决方案　　20
原理分析　　21
2.5　 创建自定义记录来接收查询结果　　21
问题　　21
解决方案　　22
原理分析　　22
2.6 　循环遍历查询的行结果　　23
问题　　23
解决方案1 　　23
解决方案2 　　23
原理分析　　24
2.7　 获取环境与会话信息　　24
问题　　24
解决方案　　24
原理分析　　25
2.8 　格式化查询结果　　27
问题　　27
解决方案　　27
原理分析　　28
2.9 　更新查询返回的结果行　　28
问题　　28
解决方案　　28
原理分析　　29
2.10 　更新游标返回的行结果　　30
问题　　30
解决方案　　30
原理分析　　31
2.11　 删除游标返回的行结果　　31
问题　　31
解决方案　　31
原理分析　　32
2.12 　执行事务　　32
问题　　32
解决方案　　32
原理分析　　33
2.13 　确保相同的数据对多个查询“可见”　　34
问题　　34
解决方案　　34
原理分析　　34
2.14 　从事务中执行另一个独立事务　　35
问题　　35
解决方案　　35
原理分析　　36
2.15 　找到并删除重复行数据　　37
问题　　37
解决方案　　37
原理分析　　38
第3章 循环与逻辑　　39
3.1 选择执行代码的时机　　39
问题　　39
解决方案　　39
原理分析　　40
3.2　 两个互斥条件中的抉择　　40
问题　　40
解决方案　　40
原理分析　　41
3.3 　多个互斥条件求值　　41
问题　　41
解决方案1　　41
解决方案2　　42
原理分析　　43
3.4　 一个有着多个输出结果的表达式　　44
问题　　44
解决方案　　44
原理分析　　45
3.5 　循环直至满足指定条件　　45
问题　　45
解决方案　　45
原理分析　　46
3.6 　遍历游标结果直到所有行结果都被返回　　46
问题　　46
解决方案　　46
原理分析　　47
3.7　 循环直到条件为FALSE　　47
问题　　47
解决方案　　47
原理分析　　48
3.8 　跳过当前循环迭代　　48
问题　　48
解决方案　　48
原理分析　　49
3.9　 迭代固定次数　　50
问题　　50
解决方案　　50
原理分析　　50
3.10　 逆向迭代　　51
问题　　51
解决方案　　51
原理分析　　51
3.11 　指定其他循环增量　　52
问题　　52
解决方案　　52
原理分析　　52
3.12　 使用奇数作为级数进行遍历　　52
问题　　52
解决方案　　53
原理分析　　53
3.13　 退出外层循环　　53
问题　　53
解决方案　　53
原理分析　　54
3.14 　跳转到代码中的指定位置　　55
问题　　55
解决方案　　55
原理分析　　56
第4章 函数、过程与包　　57
4.1 　创建存储函数　　57
问题　　57
解决方案　　57
原理分析　　58
4.2 　从查询中执行存储函数　　60
问题　　60
解决方案　　61
原理分析　　61
4.3 　优化对于某一输入总是返回相同结果的函数　　62
问题　　62
解决方案　　62
原理分析　　62
4.4　 创建存储过程　　63
问题　　63
解决方案　　63
原理分析　　64
4.5 　执行存储过程　　64
问题　　64
解决方案　　65
原理分析　　65
4.6 　在过程或代码块中创建函数　　66
问题　　66
解决方案　　66
原理分析　　67
4.7 　按名称传递参数　　67
问题　　67
解决方案　　67
原理分析　　67
4.8 　设置默认参数值　　68
问题　　68
解决方案　　68
原理分析　　68
4.9 　组织相关程序形成一个独立单元　　69
问题　　69
解决方案　　69
原理分析　　70
4.10 　为包编写初始化代码　　71
问题　　71
解决方案　　71
原理分析　　72
4.11　 授予存储程序的创建与执行权限　　73
问题　　73
解决方案　　73
原理分析　　73
4.12 　执行包中的过程和函数　　73
问题　　73
解决方案　　73
原理分析　　74
4.13 　为存储程序创建公有名称　　74
问题　　74
解决方案　　74
原理分析　　75
4.14 　依次执行包程序　　75
问题　　75
解决方案　　75
原理分析　　76
4.15 　使用失败标志　　77
问题　　77
解决方案　　77
原理分析　　78
4.16　 将数据访问限制在包内　　79
问题　　79
解决方案　　79
原理分析　　79
4.17　 在你的权限集合下运行存储代码　　80
问题　　80
解决方案　　80
原理分析　　80
4.18　 在一个函数中接受多个参数集合　　81
问题　　81
解决方案　　81
原理分析　　81
4.19 　列举模式中的函数、过程和包　　82
问题　　82
解决方案　　82
原理分析　　82
4.20　 查看存储程序源代码　　82
问题　　82
解决方案　　82
原理分析　　83
第5章 触发器　　85
5.1 　自动生成列值　　85
问题　　85
解决方案　　85
原理分析　　86
5.2　 保持关系数据同步　　87
问题　　87
解决方案　　87
原理分析　　88
5.3 　响应表的特定列更新　　89
问题　　89
解决方案　　89
原理分析　　89
5.4　 可更新的视图　　90
问题　　90
解决方案　　90
原理分析　　92
5.5 　改变应用程序的功能　　92
问题　　92
解决方案　　93
原理分析　　93
5.6 　验证输入数据　　94
问题　　94
解决方案　　95
原理分析　　95
5.7 　修正输入数据　　95
问题　　95
解决方案　　95
原理分析　　96
5.8 　替换列值　　96
问题　　96
解决方案　　96
原理分析　　97
5.9 　基于系统事件的触发器　　98
问题　　98
解决方案　　98
原理分析　　99
5.10 　与模式事件相关的触发器　　100
问题　　100
解决方案　　100
原理分析　　101
5.11　 同一事件激活两个触发器　　102
问题　　102
解决方案　　102
原理分析　　103
5.12 　创建响应多个事件的触发器　　103
问题　　103
解决方案　　103
原理分析　　105
5.13 　创建禁用状态的触发器106
问题　　106
解决方案　　106
原理分析　　107
第6章 类型转换　　108
6.1　 把字符串转换成数字　　108
问题　　108
解决方案　　108
原理分析　　109
6.2 　把字符串转换成日期　　109
问题　　109
解决方案　　109
原理分析　　110
6.3 　把数字转换成字符串　　111
问题　　111
解决方案　　111
原理分析　　111
6.4 　把日期转换成字符串　　112
问题　　112
解决方案　　112
原理分析　　113
6.5　 把字符串转换成时间戳　　115
问题　　115
解决方案　　115
原理分析　　116
6.6 　利用ANSI 兼容的方式进行格式转换　　116
问题　　116
解决方案　　116
原理分析　　117
6.7 　PLS_INTEGER 与NUMBER 之间的隐式转换　　118
问题　　118
解决方案　　118
原理分析　　119
第7章 数字、字符串和日期　　120
7.1 　字符串拼接　　120
问题　　120
解决方案　　120
原理分析　　121
7.2　 为日期增加天数　　121
问题　　121
解决方案　　121
原理分析　　121
7.3 　为日期增加月数　　122
问题　　122
解决方案　　122
原理分析　　123
7.4 　为日期增加年数　　123
问题　　123
解决方案　　123
原理分析　　124
7.5　 获取两个日期之间的间隔天数　　125
问题　　125
解决方案　　125
原理分析　　125
7.6 　为日期增加小时数、分钟数、秒数或天数　　126
问题　　126
解决方案　　126
原理分析　　127
7.7 　返回指定月份的第一天　　129
问题　　129
解决方案　　129
原理分析　　129
7.8　 返回月份的最后一天 130
问题　　130
解决方案　　130
原理分析　　130
7.9　 数字的四舍五入　　130
问题　　130
解决方案　　130
原理分析　　131
7.10 　对日期时间值进行四舍五入　　131
问题　　131
解决方案　　131
原理分析　　131
7.11 　以毫秒单位来跟踪时间　　132
问题　　132
解决方案　　132
原理分析　　133
7.12 　把时区与日期和时间关联　　133
问题　　133
解决方案　　133
原理分析　　133
7.13 　利用样式在字符串中搜索　　134
问题　　134
解决方案　　134
原理分析　　134
7.14　 确定指定样式在字符串中的位置　　135
问题　　135
解决方案　　135
原理分析　　136
7.15 　字符串的查找与替换　　137
问题　　137
解决方案　　137
原理分析　　138
第8章 动态SQL　　139
8.1 　执行编译时无法确定的单行查询　　139
问题　　139
解决方案1 　　139
解决方案2 　　140
原理分析1 　　141
原理分析2 　　142
8.2 　执行编译时无法确定的多行查询　　142
问题　　142
解决方案1 　　143
解决方案2 　　143
原理分析　　144
8.3　 编写动态INSERT 语句　　145
问题　　145
解决方案1 　　145
解决方案2 　　146
原理分析　　147
8.4　 编写动态更新语句　　148
问题　　148
解决方案　　148
原理分析　　151
8.5　 编写动态删除语句　　151
问题　　151
解决方案　　151
原理分析　　152
8.6 　把动态查询结果数据放入记录中　　153
问题　　153
解决方案　　153
原理分析　　154
8.7 　执行动态PL/SQL 块　　154
问题　　154
解决方案1　　154
解决方案2　　155
原理分析　　155
8.8 　运行时创建表　　156
问题　　156
解决方案　　156
原理分析　　156
8.9 　运行时修改表　　157
问题　　157
解决方案　　157
原理分析　　157
8.10 　查找出包含特殊字段值的所有表　　158
问题　　158
解决方案　　158
原理分析　　160
8.11　 在大对象中保存动态SQL　　161
问题　　161
解决方案1　　161
解决方案2　　162
原理分析　　162
8.12 　向动态SQL 传递NULL 值　　163
问题　　163
解决方案　　163
原理分析　　164
8.13　 在DMBS_SQL 与原生动态SQL 间切换　　164
问题　　164
解决方案　　164
原理分析　　166
8.14　 防止SQL 注入攻击166
问题　　166
解决方案　　166
原理分析　　167
第9章 异常　　169
9.1　 捕获异常　　169
问题　　169
解决方案　　169
原理分析　　171
9.2 　捕获未知异常　　173
问题　　173
解决方案　　173
原理分析　　175
9.3　 创建并抛出命名的自定义异常　　175
问题　　175
解决方案　　175
原理分析　　177
9.4　 判断OTHERS 处理程序中发生了哪个错误　　177
问题　　177
解决方案　　177
原理分析　　179
9.5 　抛出用户定义异常　　180
问题　　180
解决方案　　181
原理分析　　181
9.6　 在异常抛出后重定向控制权　　182
问题　　182
解决方案　　183
原理分析　　184
9.7　 抛出异常并继续处理　　184
问题　　184
解决方案　　184
原理分析　　185
9.8 　将无名异常与错误号关联　　185
问题　　185
解决方案　　186
原理分析　　186
9.9 　追踪异常源　　187
问题　　187
解决方案　　187
原理分析　　189
9.10　 显示PL/SQL 编译器警告　　190
问题　　190
解决方案　　190
原理分析　　191
第10章 PL/SQL 集合与记录　　193
10.1 　创建并访问VARRAY　　193
问题　　193
解决方案　　193
原理分析　　194
10.2 　创建并访问索引表　　194
问题　　194
解决方案　　194
原理分析　　195
10.3 　创建简单的记录　　195
问题　　195
解决方案　　195
原理分析　　195
10.4 　创建并访问记录集合　　196
问题　　196
解决方案　　196
原理分析　　196
10.5 　创建并访问哈希数组集合　　197
问题　　197
解决方案　　197
原理分析　　198
10.6　 创建并访问复杂的集合　　198
问题　　198
解决方案　　198
原理分析　　200
10.7 　将集合作为调用参数使用　　201
问题　　201
解决方案　　201
原理分析　　202
10.8 　将集合作为返回参数使用　　202
问题　　202
解决方案　　202
原理分析　　203
10.9 　计算集合元素个数　　203
问题　　203
解决方案　　204
原理分析　　204
10.10 　从集合中删除记录　　204
问题　　204
解决方案　　205
原理分析　　205
10.11　 检查集合中是否存在指定的元素　　206
问题　　206
解决方案　　206
原理分析　　207
10.12 　增加集合大小　　207
问题　　207
解决方案　　207
原理分析　　208
10.13　 集合导航　　208
问题　　208
解决方案　　208
原理分析　　209
10.14 　对集合进行修剪　　209
问题　　209
解决方案　　209
原理分析　　210
第11章 自动化日常任务　　211
11.1 　调度重复性作业　　211
问题　　211
解决方案　　211
原理分析　　211
11.2　 用电子邮件发送调度作业的输出　　212
问题　　212
解决方案　　212
原理分析　　213
11.3 　用电子邮件发送作业状态通知　　213
问题　　213
解决方案　　213
原理分析　　213
11.4　 按固定时间间隔刷新物化视图　　214
问题　　214
解决方案　　214
原理分析　　216
11.5 　与远程数据源保持数据同步　　216
问题　　216
解决方案　　217
原理分析　　218
11.6 　计划作业链　　218
问题　　218
解决方案　　218
原理分析　　221
第12章 Oracle SQL Developer　　223
12.1　 创建标准的授权数据库连接　　223
问题　　223
解决方案　　223
原理分析　　224
12.2 　获取表的信息　　225
问题　　225
解决方案　　225
原理分析　　226
12.3 　启用显示输出功能　　227
问题　　227
解决方案　　227
原理分析　　227
12.4 　编写并执行PL/SQL　　228
问题　　228
解决方案　　228
原理分析　　229
12.5 　创建并执行脚本　　231
问题　　231
解决方案　　231
原理分析　　232
12.6 　将用户的输入值当作替代变量　　233
问题　　233
解决方案　　233
原理分析　　233
12.7 　保存可以快速访问的代码片段　　234
问题　　234
解决方案　　234
原理分析　　234
12.8 　创建函数　　236
问题　　236
解决方案　　236
原理分析　　237
12.9 　创建存储过程　　239
问题　　239
解决方案　　239
原理分析　　240
12.10 　创建包说明和包体　　243
问题　　243
解决方案　　243
原理分析　　243
12.11 　创建触发器　　247
问题　　247
解决方案　　247
原理分析　　247
12.12 　调试存储代码　　250
问题　　250
解决方案　　250
原理分析　　250
12.13 　在导航器中编译代码　　252
问题　　252
解决方案　　253
原理分析　　253
第13章 性能分析与改进　　254
13.1　 安装DBMS_PROFILER　　254
问题　　254
解决方案　　254
原理分析　　255
13.2 　找出瓶颈　　255
问题　　255
解决方案　　255
原理分析　　256
13.3　 加速读写循环　　257
问题　　257
解决方案　　257
原理分析　　258
13.4 　将较大集合或复杂集合作为OUT参数使用　　259
问题　　259
解决方案　　259
原理分析　　260
13.5　 优化计算密集型代码　　260
问题　　260
解决方案　　261
原理分析　　261
13.6 　改善运行时的初始化时间　　262
问题　　262
解决方案　　262
原理分析　　262
第14章 在Web 中使用PL/SQL　　263
14.1　 在Web 上运行PL/SQL 过程　　263
问题　　263
解决方案　　263
原理分析　　264
14.2 　创建生成HTML 页面的公用过程集合　　265
问题　　265
解决方案　　265
原理分析　　266
14.3 　创建输入表单　　267
问题　　267
解决方案　　267
原理分析　　268
14.4 　用PL/SQL 创建基于Web 的报表　　270
问题　　270
解决方案　　270
原理分析　　272
14.5 　显示表中的数据　　273
问题　　273
解决方案　　273
原理分析　　274
14.6　 通过数据库查询创建Web 表单下拉列表　　274
问题　　274
解决方案　　274
原理分析　　275
14.7　 创建可排序Web 报表　　276
问题　　276
解决方案　　276
原理分析　　278
14.8　 在Web 页面之间传递数据　　279
问题　　279
解决方案　　279
原理分析　　280
14.9　 查看调试Web 程序时发生的错误信息　　280
问题　　280
解决方案　　281
原理分析　　281
14.10 　用PL/SQL 生成JavaScript　　282
问题　　282
解决方案　　282
原理分析　　283
14.11　 生成XML 数据　　284
问题　　284
解决方案　　284
原理分析　　285
14.12　 用Ajax 创建一个输入表单　　286
问题　　286
解决方案　　286
原理分析　　287
第15章 数据库中的Java 应用　　289
15.1 　创建Java 数据库类　　289
问题　　289
解决方案　　289
原理分析　　290
15.2 　把Java 类装载到数据库中　　291
问题　　291
原理分析　　293
15.3　 把编译后的Java 类装载到数据库中　　293
问题　　293
解决方案　　293
原理分析　　294
15.4 　把Java 类声明为存储过程　　294
问题　　294
解决方案　　295
原理分析　　295
15.5 　执行Java 存储过程　　295
问题　　295
解决方案　　295
原理分析　　296
15.6 　从PL/SQL 代码中调用Java 存储过程　　296
问题　　296
解决方案　　296
原理分析　　297
15.7 　在PL/SQL 与Java 之间传递参数　　298
问题　　298
解决方案　　298
原理分析　　299
15.8 　创建与调用Java 数据库函数　　300
问题　　300
解决方案　　300
原理分析　　301
15.9 　创建Java 数据库触发器　　301
问题　　301
解决方案　　301
原理分析　　303
15.10　 从PL/SQL 往Java 中传递数据对象　　303
问题　　303
解决方案　　303
原理分析　　305
15.11　 把Java 类嵌入PL/SQL 包　　306
问题　　306
解决方案　　306
原理分析　　307
15.12　 向数据库中装载Java 类库　　307
问题　　307
解决方案　　307
原理分析　　309
15.13 　删除Java 类　　309
问题　　309
解决方案　　310
原理分析　　310
15.14 　用Java 检索数据库元数据　　310
问题　　310
解决方案　　310
原理分析　　311
15.15 　查询数据库以解决Java 编译问题　　311
问题　　311
解决方案　　311
原理分析　　312
第16章 从JDBC、 HTTP、 Groovy 和Jython 中访问PL/SQL 　　313
16.1 　通过JDBC 访问PL/SQL 存储过程　　313
问题　　313
解决方案　　313
原理分析　　315
16.2　 从JDBC 中访问PL/SQL 存储函数　　316
问题　　316
解决方案　　316
原理分析　　317
16.3 　通过HTTP 访问PL/SQL 过程　　318
问题　　318
解决方案　　318
原理分析　　321
16.4 　从Jython 中访问PL/SQL　　322
问题　　322
原理分析　　324
16.5 　从Groovy 访问PL/SQL　　325
问题　　325
解决方案　　325
原理分析　　325
第17章 用utPLSQL 进行单元测试　　327
17.1 　使用单元测试来测试PL/SQL 代码　　327
问题　　327
解决方案　　327
原理分析　　329
17.2 　安装utPLSQL 单元测试框架　　329
问题　　329
解决方案　　329
原理分析　　330
17.3　 构建utPLSQL 测试包　　331
问题　　331
解决方案　　331
原理分析　　332
17.4　 编写utPLSQL 单元测试过程　　332
问题　　332
解决方案　　333
原理分析　　334
17.5 　运行utPLSQL 测试　　335
问题　　335
解决方案　　335
原理分析　　338
17.6 　构建utPLSQL 测试套件　　338
问题　　338
解决方案　　338
原理分析　　338
17.7 　运行utPLSQL 测试套件　　339
问题　　339
解决方案　　339
原理分析　　345
17.8 　重新配置utPLSQL 参数　　345
问题　　345
解决方案　　346
原理分析　　346
17.9 　将utPLSQL 测试结果重定向到文件　　348
问题　　348
解决方案　　348
原理分析　　348
17.10 　用Ant 自动运行PL/SQL 和Java存储过程的单元测试　　349
问题　　349
解决方案　　350
原理分析　　351
索引　　355
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle PL/SQL攻略
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高并发Oracle数据库系统的架构与设计
目　　录
推荐序一
推荐序二
前言
第一部分　内政篇
第1章　大道至简  2
1.1　初见高并发  2
1.1.1　从一次谈话说起  3
1.1.2　问题就在那里  4
1.1.3　你不是一个人在战斗  6
1.2　说句时髦话  8
1.2.1　谈谈去IOE  8
1.2.2　开源的作用域  9
1.3　在Oracle的世界里  10
1.3.1　数据库森林体系  10
1.3.2　大道至简  12
1.4　本章小结  13
第2章　高效B树索引  14
2.1　索引扫描识别  14
2.1.1　B树索引  15
2.1.2　全表扫描  16
2.1.3　ROWID扫描  17
2.1.4　索引唯一扫描  18
2.1.5　索引范围扫描  20
2.1.6　索引全扫描  21
2.1.7　索引快速全扫描  22
2.1.8　索引跳跃扫描  24
2.1.9　索引组合扫描  25
2.1.10　索引联立扫描  27
2.2　索引与排序  28
2.2.1　B树索引内部结构  28
2.2.2　输出排序  29
2.2.3　降序索引  34
2.2.4　聚合查询min()与max()  37
2.3　索引设计优化  40
2.3.1　索引选择度  40
2.3.2　数据分布的影响  41
2.3.3　索引聚簇因子  45
2.3.4　数据存储的影响  47
2.3.5　复合索引  50
2.3.6　索引被无视  54
2.4　索引分裂  58
2.4.1　分裂原理  59
2.4.2　实例分析  61
2.5　索引维护  70
2.5.1　为何重建索引  71
2.5.2　何时重建索引  73
2.5.3　如何重建索引  76
2.5.4　废旧索引清理  77
2.6　本章小结  78
第3章　高效表设计  79
3.1　数据生命周期管理  80
3.1.1　什么是数据生命周期管理  80
3.1.2　架构模型设计  81
3.1.3　数据分层存储  86
3.2　常用字段类型选择  87
3.2.1　VARCHAR2与CHAR  87
3.2.2　NUMBER与VARCHAR2  88
3.2.3　主键字段的选择  90
3.2.4　LOB字段  91
3.3　字段顺序  95
3.3.1　热字段靠前排  95
3.3.2　行宽需要控制  97
3.4　行链接与行迁移  99
3.4.1　行链接原理  99
3.4.2　行迁移原理  101
3.4.3　发现问题  101
3.4.4　解决问题  104
3.5　分区表的使用  105
3.5.1　何时使用分区表  105
3.5.2　分区表设计思路  106
3.5.3　分区表特性  106
3.6　适当的冗余  110
3.6.1　反范式建模  110
3.6.2　物化视图  113
3.6.3　结果集缓存  117
3.6.4　直接路径插入  120
3.7　碎片分析与整理  122
3.7.1　碎片的产生  123
3.7.2　DBMS_SPACE包  125
3.7.3　碎片的整理  130
3.8　本章小结  138
第4章　查询优化器  139
4.1　优化器概述  140
4.1.1　优化器简介  140
4.1.2　参数配置  143
4.2　像优化器一样思考  147
4.2.1　成本计算机制  147
4.2.2　成本计算公式推导  150
4.3　统计信息管理  155
4.3.1　统计信息分类  156
4.3.2　制定收集策略  158
4.3.3　管理收集方式  164
4.3.4　制定备份策略  168
4.3.5　收集直方图  174
4.4　执行计划管理  175
4.4.1　获取执行计划  175
4.4.2　固化执行计划  176
4.5　性能影响分析  183
4.6　数据库重放  188
4.6.1　普通数据库重放特性  188
4.6.2　强化数据库重放特性  193
4.7　本章小结  195
第5章　常见高并发案例  196
5.1　锁相关问题  196
5.1.1　Lock、Latch、Pin、Mutex  196
5.1.2　游标争用问题解决  198
5.1.3　索引争用问题解决  203
5.1.4　LOB争用问题解决  207
5.1.5　全表锁问题解决  213
5.2　REDO相关问题  214
5.2.1　REDO块的大小  214
5.2.2　DIO与AIO  218
5.2.3　进程优先级  219
5.2.4　log file sync分析  221
5.3　本章小结  222
第二部分　纵横篇
第6章　TimesTen内存数据库  224
6.1　TimesTen概述  225
6.1.1　TimesTen历史与定位  225
6.1.2　TimesTen应用场景  226
6.1.3　TimesTen技术架构  228
6.2　开始使用  233
6.2.1　TimesTen安装  233
6.2.2　参数配置  237
6.2.3　创建独立实例  239
6.2.4　创建缓存实例  241
6.3　缓存集合管理  242
6.3.1　只读缓存集合  244
6.3.2　AWT缓存集合  248
6.3.3　SWT缓存集合  251
6.3.4　自定义缓存集合  254
6.3.5　多表缓存集合  258
6.3.6　缓存老化  259
6.3.7　缓存过滤器  261
6.3.8　动态缓存集合  261
6.3.9　PassThrough属性  263
6.4　高可用复制架构  263
6.4.1　复制原理  264
6.4.2　ASP架构  266
6.5　高可用网格架构  273
6.5.1　无网格双活架构  274
6.5.2　网格双活架构  274
6.5.3　ASP网格双活架构  280
6.6　分库分表  283
6.6.1　只读缓存集合的分库分表  283
6.6.2　AWT缓存集合的分库分表  285
6.7　TimesTen设计与管理  286
6.7.1　表设计与管理  286
6.7.2　索引管理  291
6.7.3　统计信息与执行计划  294
6.8　TimesTen性能监控  299
6.8.1　关键指标  299
6.8.2　SQL监控  300
6.8.3　监控报告  302
6.8.4　复制监控  305
6.8.5　自动刷新监控  307
6.9　TimesTen备份与恢复  309
6.9.1　数据库备份  309
6.9.2　数据库恢复  311
6.9.3　数据迁移  313
6.10　TimesTen高并发场景  315
6.10.1　场景选择  316
6.10.2　并发场景测试  317
6.11　本章小结  318
第7章　GoldenGate构建数据库群  319
7.1　GoldenGate概述  319
7.1.1　小核心，大外围  320
7.1.2　GoldenGate应用场景  321
7.1.3　GoldenGate技术架构  323
7.1.4　数据库群的制约因素  328
7.2　开始使用  329
7.2.1　GoldenGate安装  329
7.2.2　GoldenGate配置  331
7.2.3　基本链路的搭建  334
7.2.4　GoldenGate的监控  339
7.3　高级应用  343
7.3.1　DDL功能支持  343
7.3.2　用户级复制  345
7.4　异构数据库群  347
7.4.1　异构字符集数据库间复制  347
7.4.2　异构数据库间复制  351
7.5　本章小结  353
第8章　Data Guard的妙用  354
8.1　“T-1”交易数据库  354
8.1.1　实现原理与应用场景  355
8.1.2　“T-1”备库简介  356
8.1.3　“T-1”库闪回简介  357
8.1.4　“T-1”数据库搭建  358
8.2　ADG实现读写分离  361
8.2.1　ADG架构简介  361
8.2.2　ADG数据库搭建  362
8.3　本章小结  365
第9章　最佳实践  366
9.1　术  366
9.1.1　技术回顾  367
9.1.2　规矩方圆  369
9.1.3　穿越之眼  370
9.2　道  370
9.2.1　数据库架构师  370
9.2.2　沟通之道  371
9.3　势  374
9.4　本章小结  375
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高并发Oracle数据库系统的架构与设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle入门很简单
第1篇 数据库基础
第1章 数据库简介（教学视频：18分钟）	2
1.1 数据库简介	2
1.1.1 数据库的发展历史	2
1.1.2 主流数据库简介	3
1.1.3 oracle数据库的特点	4
1.2 安装及配置oracle数据库	4
1.2.1 oracle数据库的版本变迁	4
1.2.2 oracle数据库的安装环境	5
1.2.3 oracle数据库的安装步骤	5
1.3 本章小结	8
1.4 本章习题	8
第2章 实体-联系模型（教学视频：35分钟）	9
2.1 实体和联系的概念	9
2.1.1 实体	9
2.1.2 联系	10
2.2 e-r图	10
2.2.1 实体联系符号	10
2.2.2 e-r图示例	11
2.3 e-r模型到关系模型	12
2.3.1 实体集转换为关系	12
2.3.2 联系转换为关系	12
2.3.3 总结联系转换为关系	14
2.4 范式	15
2.4.1 第一范式	15
2.4.2 第二范式	15
2.4.3 第三范式	16
2.4.4 bcnf范式	16
2.5 数据库设计工具	17
2.5.1 powerdesigner	17
2.5.2 erwin	19
2.6 本章小结	20
2.7 本章习题	20
第3章 oracle数据库与数据表（教学视频：60分钟）	21
3.1 创建oracle数据库	21
3.2 配置/管理oracle数据库	24
3.2.1 网络配置助手工具——net configuration assistant	24
3.2.2 网络管理员工具——net manager	32
3.2.3 oracle自带的客户端工具——sqlplus/sqlplusw	36
3.2.4 开发利器——pl/sql developer	40
3.2.5 toad for oracle	47
3.3 oracle表空间	47
3.3.1 创建oracle表空间	47
3.3.2 表空间的使用	49
3.3.3 表空间的重命名及删除	50
3.4 oracle数据表	52
3.4.1 创建oracle数据表	52
3.4.2 数据表的相关操作	53
3.4.3 删除数据表	55
3.5 特殊的数据表dual	55
3.6 本章实例1——非1521端口监听程序的使用	56
3.7 本章实例2——根据列名获得表名	61
3.8 本章小结	62
3.9 本章习题	62
第2篇 pl/sql编程
第4章 sql查询（教学视频：54分钟）	64
4.1 基本查询	64
4.1.1 查询命令select	64
4.1.2 指定过滤条件——where子句	65
4.1.3 获取唯一记录——distinct	68
4.1.4 分组——group by子句	68
4.1.5 过滤分组——having子句	70
4.1.6 排序——order by子句	71
4.1.7 order by与group by子句	72
4.1.8 order by与distinct	74
4.2 子查询	75
4.2.1 查询条件中的子查询	75
4.2.2 建表语句中的子查询	76
4.2.3 插入语句中的子查询	77
4.3 联合语句	77
4.3.1 求并集（记录唯一）——union运算	77
4.3.2 求并集——union all运算	79
4.3.3 求交集——intersect运算	80
4.3.4 求差集——minus运算	80
4.3.5 联合语句的混合运算	81
4.4 连接	82
4.4.1 自然连接	82
4.4.2 内连接	84
4.4.3 外连接	86
4.5 层次化查询	91
4.5.1 树状模型	91
4.5.2 层次化查询	92
4.5.3 层次化查询的相关函数	94
4.5.4 总结一条记录衍生出多条记录	95
4.6 本章实例	97
4.7 本章小结	98
4.8 本章习题	98
第5章 sql更新数据（教学视频：18分钟）	99
5.1 插入数据——insert操作	99
5.1.1 单条插入	99
5.1.2 批量插入	101
5.1.3 注意事项与技巧	101
5.2 更新数据——update操作	103
5.2.1 update更新单列	103
5.2.2 update更新多列	104
5.2.3 注意事项	105
5.3 删除数据——delete操作	106
5.3.1 delete操作	106
5.3.2 delete操作与truncate table操作	107
5.4 本章实例	108
5.5 本章小结	110
5.6 本章习题	111
第6章 oracle中的字符型及处理方法（教学视频：34分钟）	112
6.1 字符型简介	112
6.1.1 固定长度字符串——char(n)	112
6.1.2 varchar(n)	113
6.1.3 varchar2(n)	113
6.2 字符型分析	114
6.2.1 varchar2(n)与char(n)的区别	114
6.2.2 varchar2(n)与char(n)的选择	115
6.2.3 变量声明中的字符串类型	115
6.3 字符型处理	116
6.3.1 向左补全字符串——lpad ()函数	116
6.3.2 向右补全字符串——rpad ()函数	116
6.3.3 返回字符串的小写形式——lower()函数	117
6.3.4 返回字符串的大写形式——upper()函数	117
6.3.5 单词首字符大写——initcap()函数	118
6.3.6 返回字符串长度——length()函数	119
6.3.7 截取字符串——substr()函数	119
6.3.8 获得字符串出现的位置——instr()函数	120
6.3.9 删除字符串左侧空格——ltrim()函数	121
6.3.10 删除字符串右侧空格——rtrim()函数	121
6.3.11 删除字符串两侧空格——trim()函数	121
6.3.12 串联字符串——concat()函数	122
6.3.13 翻译字符串——translate()函数	122
6.3.14 反转字符串——reverse()函数	123
6.4 本章实例	124
6.5 本章小结	124
6.6 本章习题	124
第7章 oracle中的数值型及处理方法（教学视频：26分钟）	125
7.1 oracle中的数值型	125
7.1.1 如何理解精度	125
7.1.2 精度与小数位数	125
7.2 oracle中的数值处理	127
7.2.1 返回数字的绝对值——abs ()函数	127
7.2.2 返回数字的“四舍五入”值——round ()函数	128
7.2.3 向上取整——ceil()函数	128
7.2.4 向下取整——floor()函数	129
7.2.5 取模操作——mod ()函数	129
7.2.6 返回数字的正负性——sign()函数	130
7.2.7 返回数字的平方根——sqrt()函数	130
7.2.8 乘方运算——power()函数	131
7.2.9 截取数字——trunc()函数	131
7.2.10 将ascii码转换为字符——chr()函数	132
7.2.11 格式化数值——to_char()函数	133
7.3 本章实例	137
7.4 本章小结	138
7.5 本章习题	138
第8章 oracle中的日期型及处理方法（教学视频：30分钟）	139
8.1 oracle中的日期型	139
8.2 oracle中的日期处理	139
8.2.1 获得当前日期——sysdate()函数	139
8.2.2 为日期加上特定月份——add_months()函数	140
8.2.3 返回特定日期所在月的最后一天——last_day()函数	141
8.2.4 返回两个日期所差的月数——months_between ()函数	141
8.2.5 返回特定日期之后的一周内的日期——next_day()函数	142
8.2.6 截取日期——trunc()函数	142
8.2.7 返回当前会话时区的当前日期——current_date()函数	144
8.2.8 返回当前会话时区的时间戳——current_timestamp()函数	144
8.2.9 返回日期的某个域——extract()函数	144
8.2.10 将日期转换为字符串——to_char()函数	145
8.3 本章实例	147
8.4 本章小结	149
8.5 本章习题	149
第9章 oracle中的复杂数据处理（教学视频：88分钟）	150
9.1 利用聚合函数统计数据	150
9.1.1 求最大值——max()函数	150
9.1.2 求最小值——min()函数	151
9.1.3 求平均值——avg()函数	152
9.1.4 求和——sum()函数	152
9.1.5 统计记录数——count()函数	152
9.2 oracle中的常用技巧	155
9.2.1 多值判断——decode()函数	155
9.2.2 空值处理——nvl()函数	156
9.2.3 结果集的行号——rownum()函数	157
9.2.4 强制转换数据类型——cast()函数	160
9.3 oracle中的运算	161
9.3.1 数学运算	162
9.3.2 逻辑运算	164
9.3.3 按位运算	165
9.3.4 列的乘积	167
9.4 oracle中的特殊判式	169
9.4.1 between——范围测试	170
9.4.2 in——集合成员测试	171
9.4.3 like——模糊匹配	171
9.4.4 is null——空值判断	173
9.4.5 exists——存在性判断	174
9.4.6 all、some、any——集合判断	174
9.5 oracle中的分析函数与窗口函数	176
9.5.1 分析函数与窗口函数简介	176
9.5.2 排名函数	177
9.5.3 默认窗口	179
9.5.4 分区窗口	180
9.5.5 窗口子句	182
9.5.6 常用分析函数	185
9.6 本章实例	189
9.7 本章小结	190
9.8 本章习题	190
第10章 oracle中的控制语句（教学视频：17分钟）	191
10.1 oracle中的条件语句	191
10.1.1 流程控制——if else判断	191
10.1.2 流程控制——case when分支	193
10.2 oracle中的循环语句	194
10.2.1 无条件循环	194
10.2.2 while循环	196
10.2.3 for循环	197
10.3 本章实例	198
10.4 本章小结	198
10.5 本章习题	199
第3篇 oracle数据库对象
第11章 视图（教学视频：70分钟）	202
11.1 视图简介	202
11.1.1 什么是视图	202
11.1.2 为什么使用视图	203
11.2 创建和使用关系视图	204
11.2.1 创建关系视图	205
11.2.2 使用关系视图	206
11.2.3 修改/删除视图	210
11.2.4 只读视图	211
11.2.5 联接视图	212
11.2.6 强制创建视图	213
11.2.7 创建视图约束	214
11.3 使用内嵌视图	217
11.3.1 内嵌视图简介	217
11.3.2 使用内嵌视图	217
11.3.3 内嵌视图小结	219
11.4 使用对象视图	220
11.4.1 对象简介	220
11.4.2 对象视图	225
11.5 物化视图	227
11.5.1 物化视图简介	227
11.5.2 使用物化视图	227
11.5.3 延迟载入	231
11.5.4 数据刷新	232
11.5.5 查询重写	234
11.6 本章小结	236
11.7 本章习题	236
第12章 约束（教学视频：100分钟）	237
12.1 主键约束	237
12.1.1 为什么要使用主键约束	237
12.1.2 主键约束简介	238
12.1.3 创建主键约束	239
12.1.4 修改主键约束	245
12.1.5 主键与索引	247
12.1.6 总结	249
12.2 外键约束	250
12.2.1 为什么要使用外键约束	250
12.2.2 外键约束简介	250
12.2.3 创建外键约束	251
12.2.4 级联更新与级联删除	254
12.2.5 外键约束的相关操作	257
12.2.6 总结	260
12.3 唯一性约束	260
12.3.1 为什么要使用唯一性约束	260
12.3.2 唯一性约束简介	260
12.3.3 创建唯一性约束	261
12.3.4 修改唯一性约束	263
12.3.5 总结	265
12.4 检查约束	265
12.4.1 为什么要使用检查约束	265
12.4.2 检查约束简介	266
12.4.3 创建检查约束	266
12.4.4 修改检查约束	269
12.4.5 总结	270
12.5 默认值约束	270
12.5.1 为什么要使用默认值约束	271
12.5.2 默认值约束简介	271
12.5.3 创建默认值约束	271
12.5.4 修改默认值约束	273
12.5.5 总结	273
12.6 非空约束	274
12.6.1 为什么要使用非空约束	274
12.6.2 非空约束简介	274
12.6.3 创建非空约束	274
12.6.4 修改非空约束	277
12.6.5 总结	278
12.7 本章小结	278
12.8 本章习题	278
第13章 游标（教学视频：38分钟）	279
13.1 游标简介	279
13.1.1 为什么使用游标	279
13.1.2 游标简介	279
13.2 显式游标	280
13.2.1 声明显式游标	280
13.2.2 使用显式游标	282
13.2.3 游标属性	285
13.3 隐式游标	285
13.3.1 sql隐式游标的使用	285
13.3.2 cursor for游标的使用	288
13.3.3 总结显式游标和隐式游标	289
13.4 动态游标	289
13.4.1 强类型动态游标	289
13.4.2 弱类型动态游标	290
13.5 本章小结	292
13.6 本章习题	292
第14章 触发器（教学视频：51分钟）	293
14.1 触发器简介	293
14.1.1 什么是触发器	293
14.1.2 为什么需要触发器	293
14.2 语句触发器	294
14.2.1 创建语句触发器	294
14.2.2 触发器的作用对象与触发时机	295
14.2.3 多个激活动作	296
14.2.4 触发器谓词	297
14.2.5 总结语句触发器	300
14.3 行触发器	300
14.3.1 创建和使用行触发器	300
14.3.2 行触发器的变量引用	302
14.3.3 变量引用与referencing	304
14.3.4 多个触发器的执行顺序	305
14.3.5 触发器的条件限制	306
14.4 instead of触发器	307
14.4.1 创建和使用instead of触发器	307
14.4.2 instead of触发器中的变量引用	310
14.5 系统事件与用户事件触发器	311
14.5.1 系统事件触发器	311
14.5.2 用户事件触发器	313
14.6 触发器的相关操作	315
14.6.1 为什么要禁用触发器	315
14.6.2 禁用触发器——disable	316
14.6.3 启用触发器——enable	316
10.6.4 在数据字典中查看触发器信息	317
14.7 本章实例	318
14.8 本章小结	319
14.9 本章习题	319
第15章 序列（教学视频：26分钟）	320
15.1 自动生成序号	320
15.1.1 什么是自动生成序号	320
15.1.2 主流数据库的自动生成序号策略	320
15.2 创建和使用序列	321
15.2.1 创建序列	321
15.2.2 使用序列	322
15.2.3 指定序列初始值	324
15.3 序列属性	325
15.3.1 设置序列的最大值和最小值——minvalue和maxvalue属性	326
15.3.2 设置序列的增长步长——increment by属性	327
15.3.3 设置序列循环取值——cycle属性	329
15.3.4 设置序列缓存大小——cache属性	330
15.4 本章实例	332
15.5 本章小结	333
15.6 本章习题	333
第16章 用户、角色与权限控制（教学视频：36分钟）	334
16.1 用户	334
16.1.1 oracle中的用户概况	334
16.1.2 利用系统用户创建新的用户	335
16.1.3 用户的对象集合——模式	336
16.1.4 系统用户——system与sys	338
16.2 权限	339
16.2.1 系统权限	340
16.2.2 对象权限	346
16.3 角色	352
16.3.1 利用角色进行权限分配	352
16.3.2 角色的延伸——继承	355
16.3.3 禁用/启用角色	356
16.4 本章实例	358
16.5 本章小结	359
16.6 本章习题	359
第17章 函数与存储过程（教学视频：57分钟）	360
17.1 自定义函数	360
17.1.1 创建自定义函数	360
17.1.2 函数的参数	362
17.1.3 利用函数的确定性提高数据库效率	364
17.1.4 典型函数——行转列	365
17.2 存储过程	366
17.2.1 创建存储过程	366
17.2.2 “只进不出的参数”——in参数	369
17.2.3 “只出不进的参数”——out参数	371
17.2.4 “可进可出的参数”——in out参数	372
17.2.5 调试存储过程	373
17.3 程序包	377
17.3.1 程序包的规范	377
17.3.2 程序包的主体	379
17.3.3 调用程序包中的函数/存储过程	381
17.4 本章实例	381
17.5 本章小结	382
17.6 本章习题	382
第4篇 oracle数据库设计与优化
第18章 数据库性能优化（教学视频：52分钟）	384
18.1 在物理层面上提高oracle性能	384
18.1.1 修改sga	384
18.1.2 修改pga	390
18.1.3 异常情况	391
18.2 索引的使用	392
18.2.1 索引简介	392
18.2.2 索引的创建与使用	392
18.2.3 索引的开销	394
18.2.4 索引的使用场景	395
18.3 优化sql语句	396
18.3.1 sql语句的命中率	396
18.3.2 exists与in	397
18.3.3 where条件的合理利用	398
18.3.4 利用with子句重用查询	400
18.4 本章小结	401
18.5 本章习题	401
第19章 数据一致性与事务管理（教学视频：37分钟）	402
19.1 数据一致性和事务	402
19.1.1 oracle中的数据一致性	402
19.1.2 oracle中的事务	402
19.2 oracle中的事务处理	403
19.2.1 利用commit命令界定事务	403
19.2.2 利用rollback命令界定事务	407
19.2.3 oracle事务的属性和隔离级别	407
19.3 事务处理原则	412
19.3.1 事务的原子性——atomicity	413
19.3.2 事务的一致性——consistency	413
19.3.3 事务的隔离性——isolation	413
19.3.4 事务的持久性——durablity	414
19.4 本章实例	414
19.5 本章小结	416
19.6 本章习题	416
第20章 并发控制（教学视频：30分钟）	417
20.1 并发与锁定	417
20.1.1 并发与锁定举例	417
20.1.2 死锁	418
20.2 悲观锁定与乐观锁定	421
20.2.1 oracle中的悲观锁定	421
20.2.2 oracle中的乐观锁定	422
20.3 锁定转换	425
20.3.1 一般数据库中的锁定升级	425
20.3.2 oracle中的锁定转换	425
20.4 本章小结	430
20.5 本章习题	430
第5篇 oracle应用开发
第21章 oracle在开发中的应用（教学视频：22分钟）	432
21.1 oracle在java开发中的应用	432
21.1.1 利用jdbc操作oracle数据库	432
21.1.2 preparedstatement的使用	440
21.2 oracle在c#开发中的应用	442
21.2.1 在c#中连接oracle数据库	442
21.2.2 在c#中操作oracle数据库	443
21.2.3 在c#中使用oracle数据库事务	446
21.3 本章小结	448
21.4 本章习题	448
第22章 oracle+hibernate应用实例（教学视频：25分钟）	449
22.1 创建项目实例	449
22.2 建立映射关系	450
22.3 hibernate配置文件	451
22.4 加载hibernate文件	452
22.5 查询操作	454
22.6 更新操作	457
22.7 插入操作	458
22.8 本章小结	460
22.9 本章习题	460
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle入门很简单
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 11g数据库管理员指南
前言
第一部分   Oracle使用基础
第1章   SQL语言基础	1
1.1   查询语句	2
1.1.1   查询语句的基本用法	2
1.1.2   查询语句中的条件	6
1.1.3   查询语句中的单行函数	8
1.1.4   分组函数与分组统计	14
1.1.5   数据的排序	17
1.1.6   多表查询	18
1.1.7   子查询	20
1.2   DML语句	22
1.2.1   INSERT语句	22
1.2.2   DELETE语句	23
1.2.3   UPDATE语句	24
1.3   事务控制语句	24
1.4   DDL语句	27
1.4.1   表的创建	27
1.4.2   如何修改表的结构	29
1.4.3   其他DDL命令	31
1.5   约束	32
1.5.1   约束的类型	32
1.5.2   如何在创建表时指定约束	33
1.5.3   如何在创建表之后指定约束	35
1.5.4   约束的维护	36
1.6   视图	37
1.6.1   视图的创建、修改和删除	38
1.6.2   如何对视图进行访问	40
1.6.3   复杂视图	41
1.7   索引	42
1.7.1   索引的基本概念	42
1.7.2   索引的创建、修改和删除	45
1.7.3   索引信息的查询	46
1.8   序列	46
1.8.1   序列的创建、修改和删除	46
1.8.2   序列的使用	48
1.8.3   序列信息的查询	50
1.9   同义词	50
1.9.1   同义词的概念和类型	50
1.9.2   同义词的创建与删除	51
1.9.3   同义词信息的查询	52
第2章   SQL*Plus用法指南	53
2.1   SQL*Plus的基本用法	53
2.1.1   登录与退出	53
2.1.2   如何获取帮助信息	55
2.1.3   如何修改SQL*Plus的设置信息	55
2.1.4   实例的启动与关闭	57
2.2   SQL*Plus中的缓冲区	58
2.2.1   执行缓冲区中的内容	58
2.2.2   编辑缓冲区的内容	59
2.2.3   如何对操作系统文件进行读写	61
2.3   如何在SQL*Plus中使用变量	64
2.3.1   用户自定义的变量	64
2.3.2   参数变量	65
2.3.3   与变量有关的交互式命令	66
2.4   SQL*Plus的报表功能	67
2.4.1   报表的标题设计	68
2.4.2   报表显示格式的设计	69
2.4.3   如何对特定列进行统计	72
第3章   PL/SQL编程	75
3.1   PL/SQL概述	75
3.2   PL/SQL中的变量	76
3.2.1   变量的定义与使用	76
3.2.2   如何在PL/SQL中定义类型	78
3.3   PL/SQL中的流控制	81
3.3.1   IF语句	82
3.3.2   LOOP语句	83
3.3.3   WHILE语句	83
3.3.4   FOR语句	84
3.4   PL/SQL如何访问数据库	85
3.4.1   如何对数据进行查询	85
3.4.2   如何使用DML语句	87
3.5   子程序设计	88
3.5.1   如何使用过程	88
3.5.2   如何使用函数	91
3.5.3   函数与过程的重载	93
3.5.4   函数与过程的递归调用	95
3.6   存储过程与存储程序	97
3.6.1   存储过程	98
3.6.2   存储函数	100
3.6.3   程序包	101
3.6.4   系统预定义程序包	104
3.6.5   与存储程序有关的数据字典	110
3.7   异常处理	113
3.7.1   异常处理程序	113
3.7.2   预定义的异常	114
3.7.3   非预定义异常	117
3.7.4   用户自定义的异常	118
3.7.5   异常的传递	121
3.8   游标的应用	124
3.8.1   隐式游标	124
3.8.2   显式游标	125
3.8.3   带参数的游标	130
3.8.4   如何通过游标修改表中的数据	132
3.9   触发器	133
3.9.1   触发器的使用	134
3.9.2   语句级触发器	135
3.9.3   行触发器	137
3.9.4   视图上的触发器	141
3.9.5   与触发器有关的数据字典	144
第二部分   Oracle DBA
第4章   Oracle体系结构	147
4.1   实例的体系结构	148
4.1.1   实例的概念	148
4.1.2   实例的组成	148
4.2   实例的内存结构	149
4.2.1   数据库高速缓存	150
4.2.2   重做日志缓冲区	153
4.2.3   共享池	153
4.2.4   Java池	155
4.2.5   PGA	155
4.3   实例中的后台进程	156
4.3.1   DBWR进程	157
4.3.2   LGWR进程	158
4.3.3   CKPT进程	160
4.3.4   SMON进程	161
4.3.5   PMON进程	162
4.3.6   ARCH进程	162
4.4   实例的内存结构管理	163
4.4.1   自动内存管理	163
4.4.2   自动共享内存管理	164
4.4.3   手工共享内存管理	164
4.5   数据库的连接模式	165
4.5.1   专用数据库连接模式	165
4.5.2   共享数据库连接模式	166
4.5.3   如何设置共享连接模式	167
4.6   数据库的逻辑结构	168
4.6.1   表空间	169
4.6.2   段	171
4.6.3   区	172
4.6.4   数据块	172
4.7   数据库的物理结构	172
4.7.1   数据文件	173
4.7.2   控制文件	173
4.7.3   重做日志文件	174
4.7.4   跟踪文件和警告文件	174
4.8   特权用户与口令文件	175
4.9   数据字典视图与动态性能视图	176
4.9.1   数据字典视图	176
4.9.2   动态性能视图	177
4.10   初始化参数	178
4.10.1   参数文件	178
4.10.2   初始化参数的查看	179
4.10.3   初始化参数的修改	179
第5章   数据库的创建	181
5.1   数据库的规划	181
5.1.1   SGA的规划	181
5.1.2   数据文件的规划	182
5.1.3   控制文件的规划	183
5.1.4   重做日志文件的规划	183
5.1.5   参数文件的规划	183
5.2   如何利用DBCA创建数据库	184
5.3   如何利用命令行创建数据库	195
5.3.1   编辑文本参数文件	195
5.3.2   实例的管理	196
5.3.3   口令文件的创建	198
5.3.4   数据库的创建	200
5.3.5   如何创建数据字典视图	202
5.3.6   如何创建默认的profile	202
5.3.7   如何创建SCOTT模式	202
5.3.8   如何创建服务器参数文件	203
5.4   数据库服务器的启动和关闭	203
5.5   如何利用NET Manager配置客户端与服务器端的通信	205
5.5.1   监听器的创建	205
5.5.2   监听器的管理	206
5.5.3   Oracle客户端的配置	207
第6章   表空间的管理	209
6.1   表空间的结构	209
6.1.1   区管理方式	209
6.1.2   段管理方式	210
6.1.3   数据文件	210
6.2   本地管理表空间的管理	211
6.2.1   本地管理表空间的创建	211
6.2.2   表空间信息的查询	212
6.2.3   表空间的删除	213
6.3   大文件表空间的管理	213
6.3.1   大文件表空间的支持	213
6.3.2   大文件表空间的创建	214
6.3.3   大文件表空间的修改	214
6.4   临时表空间的管理	214
6.4.1   临时表空间的创建	215
6.4.2   临时表空间组	215
6.5   UNDO表空间的管理	216
6.5.1   UNDO表空间的创建	217
6.5.2   UNDO表空间的切换	217
6.6   表空间的扩展	218
6.6.1   如何添加新的数据文件	219
6.6.2   如何扩展数据文件	219
6.7   表空间的维护	220
6.7.1   表空间的联机与脱机	220
6.7.2   数据文件的联机与脱机	222
6.7.3   表空间的读写权限	222
6.7.4   数据文件的移动和重命名	223
第7章   存储空间管理	225
7.1   段的管理	225
7.1.1   段的类型	225
7.1.2   段的空间管理	228
7.2   区的管理	229
7.2.1   区的分配	229
7.2.2   区的回收	230
7.3   数据块的管理	230
7.3.1   数据块的组成	230
7.3.2   数据块的空间管理	231
第8章   控制文件管理	234
8.1   控制文件的规划	234
8.1.1   控制文件的镜像	234
8.1.2   控制文件的存储位置	235
8.2   控制文件的重新创建	236
8.2.1   如何增加新的控制文件	236
8.2.2   如何重新创建控制文件	236
8.3   控制文件的备份与删除	240
8.4   控制文件信息的查询	240
8.4.1   查询控制文件的位置和名称	241
8.4.2   查询控制文件中记录的信息	241
第9章   重做日志管理	243
9.1   重做日志的规划	244
9.1.1   重做日志缓冲区的规划	245
9.1.2   重做日志文件组的规划	245
9.1.3   如何对重做日志文件进行规划	246
9.2   重做日志文件的管理	247
9.2.1   增加重做日志组	247
9.2.2   增加日志成员	248
9.2.3   修改重做日志文件的存储位置和名称	248
9.2.4   删除重做日志文件	249
9.2.5   重做日志文件的清空	250
9.2.6   重做日志的切换	250
9.2.7   重做日志信息的查询	251
9.3   归档日志的管理	252
9.3.1   数据库的日志模式	252
9.3.2   切换日志模式	253
9.3.3   设置归档位置	254
9.3.4   归档信息的查询	255
9.4   如何对重做日志进行分析	256
9.4.1   如何创建字典文件	256
9.4.2   如何创建分析列表	257
9.4.3   如何开始日志分析	257
9.4.4   如何查看日志分析结果	258
9.4.5   如何结束日志分析	259
第10章   基本数据库对象管理	260
10.1   表的管理	260
10.1.1   表的结构	260
10.1.2   表的创建	262
10.1.3   表的修改	264
10.1.4   表的删除	266
10.2   分区表的管理	267
10.2.1   分区的概念	268
10.2.2   范围分区	268
10.2.3   列表分区	269
10.2.4   散列分区	270
10.2.5   复合分区	270
10.3   索引的管理	271
10.3.1   索引概述	272
10.3.2   反向索引	272
10.3.3   位图索引	273
10.3.4   基于函数的索引	274
10.3.5   分区索引	275
10.3.6   索引的维护	275
10.4   簇的管理	276
10.4.1   簇的创建	277
10.4.2   簇的修改	278
10.4.3   簇的删除	278
10.4.4   簇信息的查询	279
10.5   索引组织表的管理	279
10.5.1   索引组织表的概念	279
10.5.2   索引组织表的创建	280
10.5.3   索引组织表的维护	281
第11章   用户与权限管理	282
11.1   用户管理	282
11.1.1   数据库中有哪些用户	282
11.1.2   如何创建用户	283
11.1.3   如何修改用户的信息	284
11.1.4   如何删除用户	285
11.2   用户权限的管理	285
11.2.1   系统权限的管理	286
11.2.2   对象权限的管理	288
11.2.3   权限信息的查询	291
11.3   角色的管理	292
11.3.1   角色的创建和删除	293
11.3.2   角色中权限的添加和删除	294
11.3.3   角色的分配和回收	295
11.3.4   角色信息的查询	295
11.4   PROFILE的管理	296
11.4.1   PROFILE的创建与删除	296
11.4.2   如何利用PROFILE对用户口令进行控制	297
11.4.3   如何利用PROFILE对用户使用资源进行控制	298
11.4.4   默认的PROFILE	299
第三部分   自动文件管理和自动存储管理
第12章   自动文件管理	301
12.1   如何激活自动文件管理功能	301
12.2   文件的命名规则	302
12.3   如何创建OMF数据库	302
12.4   如何创建OMF表空间	304
12.5   如何创建OMF控制文件	305
12.6   如何创建OMF重做日志文件	306
第13章   自动存储管理	307
13.1   ASM实例	307
13.2   磁盘组的管理	309
13.3   如何使用ASM磁盘组	312
第四部分   备份与恢复
第14章   数据库的导入与导出	315
14.1   导入导出工具的用法	316
14.2   表的导入与导出	317
14.3   用户模式的导入与导出	319
14.4   数据库的导入与导出	319
14.5   表空间的导入与导出	319
第15章   数据库的常规备份与恢复	322
15.1   备份与恢复的相关概念	322
15.1.1   冷备份与热备份	322
15.1.2   物理备份与逻辑备份	322
15.1.3   完全备份与增量备份	322
15.1.4   备份策略	323
15.1.5   完全恢复与不完全恢复	324
15.1.6   日志模式对备份与恢复的影响	324
15.1.7   哪些情况将导致数据丢失	324
15.1.8   哪些文件需要备份	325
15.2   控制文件的备份与恢复	326
15.3   重做日志文件的备份与恢复	326
15.4   数据文件的备份	326
15.5   数据库的完全恢复	327
15.6   两个实际的备份与恢复的例子	328
15.6.1   模拟数据文件损坏的例子	328
15.6.2   模拟磁盘损坏的例子	329
15.7   Flashback技术在数据库恢复中的应用	329
15.7.1   回收站的应用	330
15.7.2   Flashback技术在表上的应用	331
15.7.3   Flashback技术在数据库恢复中的应用	331
第16章   如何利用RMAN对数据库进行备份与恢复	332
16.1   RMAN的基本结构	332
16.2   RMAN的配置	334
16.2.1   如何配置RMAN客户端的连接	334
16.2.2   恢复目录的创建	334
16.3   如何利用RMAN对数据库进行备份	335
16.3.1   通道的设置	335
16.3.2   存储脚本的用法	336
16.3.3   控制文件的备份	337
16.3.4   参数文件的备份	338
16.3.5   归档日志文件的备份	338
16.3.6   非归档模式下数据文件的备份	339
16.3.7   归档模式下数据文件的备份	339
16.3.8   备份集的备份	341
16.4   如何对数据库进行完全恢复	342
16.4.1   如何对备份文件进行校验	342
16.4.2   如何对数据文件进行恢复	342
16.5   两个实际的例子	344
16.5.1   模拟数据文件损坏的例子	344
16.5.2   模拟磁盘损坏的例子	345
16.6   如何对坏块进行恢复	346
16.6.1   什么叫块介质恢复	346
16.6.2   如何进行块介质恢复	347
16.7   如何对数据进行跨平台移植	347
16.7.1   字节存储次序相同时的移植	348
16.7.2   字节存储次序不同时的移植	349
附录A   Oracle   11g在AIX下的安装	351
附录B   Oracle   11g在Linux下的安装	360
附录C   Oracle   11g在Solaris下的安装	364
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 11g数据库管理员指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 11g PL/SQL编程实战
第Ⅰ部分 PL/SQL 基础	1
第1章 Oracle开发概述	3
1.1 历史和背景知识	4
1.2 架构	5
1.2.1 两层模型	8
1.2.2 三层模型	12
1.3 可下载代码	13
1.4 小结	13
1.4.1 最佳实践回顾	13
1.4.2 测验	13
第2章 PL/SQL基础	15
2.1 PL/SQL块	16
2.1.1 原型	17
2.1.2 基本匿名块	18
2.1.3 Hello World匿名块	19
2.1.4 Hello Somebody匿名块	20
2.1.5 Hello Somebody命名块	23
2.1.6 嵌套块	24
2.2 变量：类型、赋值和运算符	25
2.2.1 文本数据类型	27
2.2.2 日期和时间戳类型	28
2.2.3 数值类型	31
2.2.4 复合变量类型	34
2.3 控制结构	37
2.3.1 if语句	37
2.3.2 case语句	38
2.3.3 循环结构	39
2.4 批量操作	47
2.5 可下载代码	48
2.6 小结	48
2.6.1 最佳实践回顾	49
2.6.2 测验	49
第3章 事务作用域	51
3.1 数据库ACID测试	52
3.1.1 原子性	52
3.1.2 一致性	53
3.1.3 隔离性	53
3.1.4 持久性	54
3.2 多版本并发控制	54
3.3 保存点、提交和事务回滚	54
3.3.1 保存点和回滚	54
3.3.2 提交	59
3.4 DML锁定和隔离控制	61
3.5 调用者和定义者权限	67
3.6 可下载代码	68
3.7 小结	69
3.7.1 最佳实践回顾	69
3.7.2 测验	69
第4章 错误管理	71
4.1 错误类型	72
4.1.1 编译时错误	72
4.1.2 语义错误	77
4.2 PL/SQL工具	87
4.3 可下载代码	91
4.4 小结	91
4.4.1 最佳实践回顾	92
4.4.2 测验	92
第Ⅱ部分 PL/SQL 编程	95
第5章 函数	97
5.1 函数架构	98
5.1.1 传值函数	98
5.1.2 传址函数	99
5.1.3 函数模型选择	100
5.1.4 事务作用域	101
5.1.5 调用参数说明	101
5.2 函数开发	103
5.2.1 确定性子句	104
5.2.2 PARALLEL_ENABLE子句	105
5.2.3 管线表子句	105
5.2.4 RESULT_CACHE子句	110
5.2.5 系统引用游标	112
5.2.6 递归函数	114
5.2.7 传址函数	114
5.3 可下载代码	115
5.4 小结	115
5.4.1 最佳实践回顾	116
5.4.2 测验	116
第6章 过程	119
6.1 过程架构	120
6.1.1 传值过程	120
6.1.2 传址函数	121
6.1.3 事务作用域	121
6.1.4 调用参数说明	122
6.2 过程开发	122
6.2.1 传值过程	123
6.2.2 传址过程	130
6.3 可下载代码	131
6.4 小结	132
6.4.1 最佳实践回顾	132
6.4.2 测验	132
第7章 集合	135
7.1 标量集合	137
7.1.1 varray	137
7.1.2 嵌套表	144
7.1.3 关联数组	145
7.2 对象类型集合	146
7.2.1 SQL嵌套表	146
7.2.2 PL/SQL嵌套表	148
7.3 记录类型集合	150
7.4 可下载代码	153
7.5 小结	153
7.5.1 最佳实践回顾	153
7.5.2 测验	153
第8章 包	157
8.1 包架构	158
8.1.1 更大的组织	158
8.1.2 程序持续性和内存驻留	159
8.1.3 更大的程序规模	159
8.2 包规范	159
8.3 无主体包	162
8.4 包主体	163
8.5 %TYPE和%ROWTYPE	166
8.6 模块化编程	168
8.7 重载	171
8.8 增强安全性	173
8.9 定义者和调用者权限	176
8.10 可下载代码	179
8.11 小结	179
8.11.1 最佳实践回顾	179
8.11.2 测验	180
第9章 触发器	183
9.1 触发器架构	184
9.2 触发器引发次序	186
9.3 触发器类型	188
9.3.1 DML触发器	188
9.3.2 DDL触发器	192
9.3.3 系统事件触发器	193
9.4 安全性和Oracle细粒度审计	195
9.5 分布式数据完整性	198
9.6 可下载代码	201
9.7 小结	201
9.7.1 最佳实践回顾	201
9.7.2 测验	202
第10章 对象	205
10.1 基本声明、实现和使用	207
10.1.1 定义并实现对象类型	207
10.1.2 实现Getter和Setter	210
10.1.3 实现静态方法	212
10.2 比较对象	216
10.2.1 MAP函数比较	217
10.2.2 ORDER函数比较	219
10.3 继承和多态	221
10.4 对象集合	224
10.5 可下载代码	227
10.6 小结	227
10.6.1 最佳实践回顾	227
10.6.2 测验	228
第Ⅲ部分 PL/SQL高级编程	231
第11章 动态SQL	233
11.1 本地动态SQL	234
11.1.1 无绑定变量的动态语句	235
11.1.2 带绑定变量的动态语句	237
11.2 DBMS_SQL包	246
11.2.1 无绑定变量的动态语句	246
11.2.2 带绑定变量的动态语句	247
11.2.3 混合并匹配NDS和DBMS_SQL	250
11.3 可下载代码	251
11.4 小结	251
11.4.1 最佳实践回顾	252
11.4.2 测验	252
第12章 外部文件	255
12.1 外部表架构	256
12.1.1 CSV文件	257
12.1.2 位置特定文件	260
12.1.3 TSV文件	261
12.1.4 转换XML为CSV文件	262
12.1.5 使用Java存储库清理文件	264
12.2 导入CLOB	268
12.3 可下载代码	276
12.4 小结	276
12.4.1 最佳实践回顾	277
12.4.2 测验	277
第Ⅳ部分 附录	279
附录A 包装PL/SQL	281
附录B PL/SQL层次性能分析器	287
附录C PL/Scope	299
附录D PL/SQL内置包和类型	303
附录E 测验答案	321
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 11g PL/SQL编程实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Oracle RAC 12c
第1 章 Oracle RAC 概述 ..................................................... 1
高可用性和可扩展性 ....................................................... 2
什么是高可用性 ............................................................. 2
数据库的可扩展性 ......................................... 3
Oracle RAC ........................................ 5
数据库集群体系架构 ........................................ 5
RAC 架构 ................... 6
RAC 的硬件要求 ............................... 8
RAC 的组件 .......................................................................... 10
Oracle RAC 的缓存融合 ....................................................... 13
RAC 的后台进程 .................................................................. 16
获得Oracle RAC 的好处 ................................................... 19
高可用性和意外停机 ............................... 19
高可用性和计划停机时间 ........................................................ 23
使用Oracle RAC One Node 实现高可用性 ....................... 25
RAC 的可扩展性 ....................................................... 25
使用Oracle RAC 整合数据库服务 .............................. 28
部署RAC 时的注意事项 ........................................ 30
拥有成本 .................................................. 30
高可用性的注意事项 ....................................... 31
可扩展性的注意事项 ............................................. 32
是否选择RAC ................................... 33
本章小结 ......................................... 34
第2 章 Oracle 集群件堆栈的管理和故障诊断 ................................... 35
Oracle 12cR1 的集群件及其组件 ............................................. 36
Oracle 集群件的存储组件 .................................... 36
集群件软件堆栈 .............................................. 38
集群件启动顺序 ................................................. 40
ASM 和集群件谁先启动 .................................. 42
集群件管理 .......................................................... 43
集群件的管理工具和实用程序 ............................. 43
启动和停止集群件 ............................................ 45
管理Oracle 集群件 ................................................ 45
管理OCR 和表决磁盘 ........................................... 48
管理CRS 资源 ......................................................... 50
添加和删除集群节点 ............................................. 50
常见集群件启动问题的解决方法 .................................. 53
诊断、调试、跟踪集群件和RAC 问题 ................................. 58
调试集群件的组件和资源 ...................................... 58
网格架构中各组件的目录结构 ............................... 61
Oracle 集群件故障诊断工具 .................................. 64
CHM .................................................... 69
本章小结 ....................................................... 77
第3 章 Oracle RAC 运行实践 ............................... 79
工作负载管理 .......................................... 79
服务 ............................................... 80
服务指标 ........................................................ 82
负载均衡目标 ................................................ 83
运行时的故障切换 ........................... 86
第二个网络中的服务 ........................... 86
服务的使用指导 ...................................... 86
SCAN 和SCAN 监听 ............................. 87
第二个网络中的SCAN 监听（12c） ........................... 91
SCAN 监听使用指南 ....................................... 92
全局数据库服务（12c） .................................................. 93
RAC 中的故障切换 .............................................. 94
透明应用程序故障切换（TAF） ............................................................................................ 95
快速连接故障切换（FCF）.................................................................................................... 96
WebLogic Active GridLink ...................................................................................................... 97
事务卫士（12c） ................................................................................................................... 97
应用程序的连续性（12c） ........................................................... 98
策略管理的数据库 ...................................... 99
临时表空间 ..................................... 100
大量数据的修改 .................................................... 101
性能指标收集 ............................................. 102
参数文件管理 ............................................ 102
密码文件管理 .................................... 103
管理数据库和实例 ........................................... 104
管理VIP 和监听 .................................... 106
其他主题 ......................................... 107
进程优先级 ...................................................... 107
内存不足 .......................... 108
SGA 的大小 ................................................... 109
文件系统缓存 ........................... 110
本章小结 ........................................ 110
第4 章 RAC 12c 的新特性 ................................................... 111
Oracle Flex 集群 ............................. 112
Oracle Flex 集群的架构 ..................................... 112
Flex 集群的扩展性和可用性 ....................................... 114
配置Flex 集群 ..................................... 115
Flex ASM 架构 ..................................................... 120
Oracle Flex ASM 架构 ............................................. 120
Flex ASM 和Flex 集群 ..................................... 122
配置Flex ASM ...................................... 122
ASM 客户端和重定位 ................................. 124
新的ASM 存储限制 ...................................... 125
在磁盘组中更换ASM 磁盘 .................................. 125
清理ASM 磁盘组和文件 .................................... 125
在ASM 磁盘组中均匀地读取数据 ............................ 126
衡量和优化ASM 重新平衡操作 ................................ 126
系统命令的假设分析和评估 ................................ 126
Oracle RAC 中的可插拔数据库 .................................. 128
可插拔数据库的体系结构概述 .................................... 128
Oracle RAC 中的PDB 数据库 ...................................... 132
12cR1：RAC 中的其他新功能 ........................................... 136
RAC 中的公共网络：添加对IPv6 的支持 ........................... 136
全球数据服务 ...................................... 136
在线修改资源的属性 ......................................... 136
12cR1 RAC：基于策略的数据库管理 ......................... 136
ASM 磁盘组：共享的ASM 密码文件 ........................ 137
节点的有效性检查：限制服务的注册 ................................ 137
12cR1：共享的GNS 服务 ................................ 137
RAC 12cR1：限制服务注册 ................................................... 137
Oracle ASM、ACFS 和ADVM：功能的改进以及新特性 ................... 137
NFS 的高可用性 ........................................... 138
12cR1：CHM 的增强 ..................................... 138
Windows：支持Oracle 安装用户 ..................................... 138
OUI 的增强和改进 .......................................... 138
12cR1：安装和升级——自动运行脚本 .............................. 139
12cR1：应用的连续性 ............................................ 139
事务的幂等性和Java 事务卫士 ............................... 139
已废弃和不再支持的功能 .......................................... 139
本章小结 ......................................................... 140
第5 章 存储和自动存储管理 ............................................... 141
Oracle RAC 中的存储架构和配置 .......................................... 143
Oracle RAC 中的存储架构和I/O .......................................... 143
磁盘冗余阵列配置 .................................................. 146
存储协议 ............................................................... 148
多路径设备配置 ..................................................... 151
设置设备的所有权 ............................................. 153
自动存储管理 ........................................... 155
ASM 实例 .............................................................. 156
ASM 存储结构 ................................ 164
用SQL 命令和V$ASM 视图管理ASM .............. 173
在ASM 上存放Oracle 集群注册表和表决磁盘 ............................... 173
在安装网格架构时选择ASM 存放Oracle 集群注册表和表决磁盘 ..................... 173
将Oracle 集群注册表和表决磁盘迁移到新的ASM 磁盘组 .................. 176
ASM 集群系统文件 ........................................................ 179
建立ACFS ....................................................................... 181
用ASMCA 为Oracle RAC 创建ACFS 的主目录 ..................................... 183
本章小结 ......................................................................... 185
第6 章 应用设计上的问题 ................................... 186
局部性插入操作 .................................................. 186
大量的TRUNCATE 或DROP 命令.......................... 189
序列缓存 ..................................................................... 191
空闲块链表和自动段表空间管理 ................................. 193
过多的提交 ...................................................................... 194
长时间没有提交的事务 .......................................................... 195
本地访问 ............................................................... 196
小表的更新 ................................................................................ 197
索引设计 .................................................................. 198
低效的执行计划 ................................................................... 199
过多的平行扫描 ............................................................ 199
全表扫描 .................................................................................. 199
应用之间的关联性 ....................................... 200
管道 ............................................... 201
应用改变的实施 ........................................... 201
本章小结 ............................................ 202
第7 章 管理和调优一个复杂的RAC 环境 ..................................... 203
比较共享和非共享的Oracle 主目录的优点和缺点 .................... 204
服务器池 .............................................. 205
服务器池的类型 ....................................................... 206
系统定义的服务器池 ........................................... 206
用户定义的服务器池 .................................................. 206
创建和管理服务器池 ........................................... 207
计划和设计RAC 数据库 ...................................... 209
策略管理数据库 ............................................. 210
实例锁定 ................................................ 213
小规模和大规模的集群环境设定 ............................. 214
裂脑案例和如何避免 ................................................. 215
理解、解决和防止节点驱逐 ............................... 217
节点驱逐——梗概和综述 ................................ 217
延伸距离（伸展）集群——摘要、概况和最佳实践 ......................................................... 221
延伸距离（伸展）集群：创建和配置最佳实践 .................... 222
创建和配置 ................................................................ 223
Oracle 图形界面 ...................................................... 223
Oracle 企业管理器云控制12c ....................... 225
RAC 的安装和设置——在不同操作系统：Linux、Solaris 和Windows 中的考虑和窍门 ....................... 227
RAC 数据库性能调优：一个迅速简单的途径 ................................... 228
性能调优的3 个A 工具 ................................................. 229
本章小结 ........................................................... 234
第8 章 RAC 的备份与恢复 ....................................... 235
RMAN 概要 ............................................................. 235
介质管理层 ................................................................ 237
联机备份和恢复的预备知识 ................................................ 238
非RAC 数据库和RAC 数据库的对比 ............................. 239
重做日志和归档日志的共享存储位置 .......................... 240
快照控制文件配置 ........................................... 241
为RAC 配置多通道 ..................................... 242
RAC 中的并行机制 ....................... 245
RAC 中的实例恢复和崩溃恢复 .................................. 245
真实世界中的例子 ...................................... 250
使用12c 的OEM 云控制器来管理RMAN .............................. 254
OCR 恢复 ....................................................... 259
本章小结 ............................................... 261
第9 章 网络实践 .................................................. 262
网络类型 .............................................. 262
网络层 ................................................ 263
协议 ................................... 265
VIP ......................... 269
子网划分 .......................................... 270
集群内联 .............................. 271
巨帧 .................................................. 274
负载均衡和故障转移 ......................................... 279
内核参数 .................................................. 282
网络测试工具 ............................................ 283
GC Lost Block 问题 ...................................... 288
配置Oracle RAC 和集群件网络环境 .................... 290
建立IP 和域名地址的解析 ............................... 293
网格构架安装过程中的网络设置 ................ 297
集群件的网络配置 ......................................... 300
网络故障转移 .......................................... 306
第二网络配置 .......................................... 307
本章小结 .......................................................... 308
第10 章 优化RAC 数据库 ........................................ 309
缓存融合介绍 ............................................................. 309
缓存融合的处理 .......................... 310
GRD ............................................................ 312
BL 资源和锁 ................................................. 313
性能分析 ............................. 317
接收端的分析 ....................................................................... 318
RAC 等待事件 ............................................................ 325
GC Current Block 2-Way/3-Way ................. 325
GC CR Block 2-Way/3-Way .................................................. 327
GC CR Grant 2-Way/GC Current Grant 2-Way ........................ 329
GC CR Block Busy/GC Current Block Busy ........................... 329
GC CR Block Congested/GC Current Block Congested ............................ 329
占位等待事件 ......................................... 329
发送端分析 ..................................... 330
曾用块的类型（被使用的块的类型） .............................. 333
GCS Log Flush Sync ............................................ 334
保护LMS 进程 ...................................................... 335
GC Buffer Busy Acquire/Release .......................... 335
唯一索引 ..................................... 338
表块 .................................................................................. 339
DRM ................................................................ 341
DRM 进程概述 ....................................................... 342
DRM 的阶段 ......................................................... 344
GRD 冻结 .............................................. 345
参数 ........................................................ 345
在12c 中的改变 ......................................... 346
DRM 和Undo ........................................... 346
DRM 的故障诊断 ...................................................... 347
AWR 报告和ADDM ............................................. 347
ASH 报告 ........................................................ 348
本章小结 ......................................................... 348
第11 章 锁和死锁 .................................................... 350
资源和锁 ........................................................ 350
SGA 的内存分配 ............................................................ 352
资源类型 ............................................................ 354
锁模式 ........................................................... 356
锁相关的视图 .................................................. 357
可插拔数据库（12c） ............................................................ 357
锁争用的故障排除方法 ................................... 358
入队争用 ............................................................................ 360
TX 入队争用（Enqueue Contention） ............................... 361
TM 入队争用 .......................................... 364
HW 入队争用 .................................. 366
DFS Lock Handle ......................................... 366
SV 资源 .................................... 368
CI 资源 ................................................... 371
DFS lock handle 总结 ....................................... 373
Library Cache Locks/Pins ...................................... 373
诊断Library Cache Lock 争用 .................................... 376
队列统计信息 ................................................................... 377
v$wait_chains ............................................ 378
Hanganalyze ................................................ 379
死锁 .............................................. 380
LMD 跟踪文件的分析 .................................... 381
本章小结 ................................................... 385
第12 章 RAC 中的并行查询 ......................................... 386
概述 ................................................................................ 386
RAC 中的并行执行 ..................................................... 390
PX 服务进程的位置 .................................... 391
测量PX 通信 ...................................................... 395
并行执行与缓存融合 ................................................... 397
PEMS ................................................................... 398
并行特性与RAC .................................................................... 398
诊断并行执行问题 ............................................ 411
在RAC 中创建索引 ......................................... 413
RAC 中的并行DML ............................................. 414
12c 中的并发联合处理 ............................. 415
Partition-Wise Join .............................................. 416
本章小结 .................................................. 417
第13 章 集群件和数据库升级 ......................................................... 419
配置 ............................................................ 419
升级之前的检查 ............................................................... 421
开始Oracle 集群件升级 ................................................. 423
rootupgrade.sh 脚本的重要性 ...................................... 430
升级后的工作 ............................................... 433
集群件降级 ................................................................ 434
数据库升级 ................................................................................ 437
手动升级数据库 ..................................................................... 438
数据库升级后的步骤 .............................................................. 440
使用DBUA 升级数据库 .............................................................. 440
DBUA 的优势 ........................................................................... 443
数据库降级 .................................................................. 443
本章小结 .................................................................. 444
第14 章 RAC One Node ........................................................ 445
RAC One Node 概述 .................................. 445
升级到11.2.0.2 或更高版本 ...................................... 446
配置RAC One Node 环境 ........................................ 447
配置RAC One Node 数据库 .................................... 449
先决条件 .......................................... 449
开始DBCA 创建过程 .................... 450
指定RAC One Node 初始化参数 ............................ 452
管理RAC One Node 数据库 ......................... 453
核实配置信息 ................................................... 453
验证在线迁移状态 .............................. 454
停止和启动数据库 ...................................... 454
完成数据库在线迁移 ................................ 455
处理计划外的节点和集群重启 ................................................. 457
RAC One Node 和标准RAC 之间的转换 .............................. 458
扩展为标准RAC ................................................................................... 458
降级到RAC One Node ....................................................... 459
通过12c 中的云控制管理RAC One Node ............................... 460
通过12c 中的云控制进行数据库迁移 ................................... 460
第三方故障转移技术和RAC One Node 的对比 ............................. 463
本章小结 .......................................................... 464
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Oracle RAC 12c
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 11g R2 DBA 操作指南
目 录
第1章 Oracle数据库基础.............................................................................................. 1
1.1 什么是关系数据库................................................................................................................................ 1
1.1.1 关系数据库模型........................................................................................................................ 1
1.1.2 关系数据模型的创始人............................................................................................................ 2
1.2 Oracle 数据库发展简史......................................................................................................................... 3
1.2.1 公司之初................................................................................................................................... 3
1.2.2 Oracle 数据库的发展历程......................................................................................................... 3
1.3 数据库RDBMS..................................................................................................................................... 4
1.4 SQL语言简介........................................................................................................................................ 5
1.4.1 SQL语言概述............................................................................................................................ 5
1.4.2 SQL语句的操作........................................................................................................................ 6
1.5 本章小结................................................................................................................................................ 8
第2章 Oracle 11g 数据库初体验................................................................................... 9
2.1 安装数据库的环境要求......................................................................................................................... 9
2.2 Windows 环境下Oracle 11g 的安装步骤............................................................................................. 9
2.3 SQL Plus工具以及scott 用户............................................................................................................. 16
2.4 Linux 环境下Oracle 11g 的安装步骤................................................................................................. 20
2.4.1 安装前的配置任务.................................................................................................................. 20
2.4.2 安装数据库软件...................................................................................................................... 24
2.4.3 启动监听................................................................................................................................. 33
2.4.4 使用DBCA图形化工具建库................................................................................................. 36
2.5 测试到数据库的连接........................................................................................................................... 42
2.6 删除数据库软件.................................................................................................................................. 43
2.7 本章小结.............................................................................................................................................. 43
第3章 数据库的启动与关闭......................................................................................... 44
3.1 启动数据库............................................................................................................................................ 44
3.1.1 数据库启动过程...................................................................................................................... 44
3.1.2 数据库启动到NOMOUNT 状态............................................................................................ 45
3.1.3 数据库启动到MOUNT 状态.................................................................................................. 49
3.1.4 数据库启动到OPEN状态...................................................................................................... 50
3.2 关闭数据库.......................................................................................................................................... 51
3.2.1 数据库关闭过程...................................................................................................................... 51
3.2.2 数据库关闭的几个参数及其含义.......................................................................................... 53
3.3 本章小结.............................................................................................................................................. 54
第4章 Oracle数据库体系结构..................................................................................... 55
4.1 Oracle 体系结构概述........................................................................................................................... 55
4.2 Oracle 数据库体系结构....................................................................................................................... 55
4.2.1 Oracle 服务器和实例............................................................................................................... 56
4.2.2 Oracle 数据库物理结构（文件组成）................................................................................... 58
4.2.3 参数文件、密码文件和归档日志文件.................................................................................. 58
4.3 数据库连接（connection）与会话（session）.................................................................................. 58
4.3.1 数据库连接（connection）..................................................................................................... 58
4.3.2 会话（session）....................................................................................................................... 59
4.4 Oracle 数据库内存结构....................................................................................................................... 60
4.4.1 共享池（Shared pool）........................................................................................................... 60
4.4.2 数据库高速缓冲区（Database buffer cache）....................................................................... 62
4.4.3 重做日志高速缓冲区（Redo buffer cache）......................................................................... 64
4.4.4 大池（Large pool）和Java 池（Java pool）......................................................................... 65
4.4.5 流池（Streaming pool）.......................................................................................................... 66
4.4.6 PGA（进程全局区）和UGA（用户全局区）..................................................................... 66
4.4.7 如何获得内存缓冲区的信息.................................................................................................. 68
4.5 Oracle 服务器进程和用户进程........................................................................................................... 68
4.6 Oracle 数据库后台进程....................................................................................................................... 69
4.6.1 系统监控进程（SMON）....................................................................................................... 69
4.6.2 进程监控进程（PMON）....................................................................................................... 70
4.6.3 数据库写进程（DBWR）...................................................................................................... 70
4.6.4 重做日志写进程（LGWR）................................................................................................... 71
4.6.5 归档日志进程（ARCH）....................................................................................................... 72
4.6.6 校验点进程（Checkpoint process）....................................................................................... 74
4.7 本章小结.............................................................................................................................................. 74
第5章 SQL 语言概述................................................................................................... 75
5.1 SQL语句分类...................................................................................................................................... 75
5.2 SQL的查询语句.................................................................................................................................. 76
5.2.1 SELECT语句的语法及书写要求........................................................................................... 76
5.2.2 简单查询................................................................................................................................. 77
5.2.3 特定的列查询.......................................................................................................................... 78
5.2.4 WHERE子句........................................................................................................................... 79
5.2.5 列标题的默认显示格式.......................................................................................................... 79
5.2.6 在SQL语句中使用列的别名................................................................................................. 80
5.2.7 算数运算符及使用.................................................................................................................. 81
5.2.8 DISTINCT运算符................................................................................................................... 81
5.2.9 连接（contatenation）运算符及使用..................................................................................... 83
5.3 书写规范.............................................................................................................................................. 83
5.4 单行函数.............................................................................................................................................. 84
5.4.1 字符型单行函数...................................................................................................................... 84
5.4.2 数字型单行函数...................................................................................................................... 88
5.4.3 日期型单行函数...................................................................................................................... 89
5.5 空值（NULL）和空值处理函数........................................................................................................ 92
5.5.1 什么是空值.............................................................................................................................. 92
5.5.2 NVL函数和NVL2 函数......................................................................................................... 94
5.5.3 NULLIF 函数........................................................................................................................... 96
5.5.4 COALESCE函数..................................................................................................................... 97
5.6 条件表达式.......................................................................................................................................... 97
5.6.1 CASE表达式........................................................................................................................... 97
5.6.2 DECODE函数......................................................................................................................... 98
5.7 分组函数.............................................................................................................................................. 99
5.7.1 AVG和SUM函数................................................................................................................ 100
5.7.2 MAX和MIN 函数................................................................................................................ 100
5.7.3 COUNT 函数.......................................................................................................................... 101
5.7.4 GROUP BY 子句.................................................................................................................. 101
5.7.5 分组函数的嵌套使用............................................................................................................ 102
5.7.6 HAVING 子句........................................................................................................................ 102
5.8 数据操纵语言（DML）.................................................................................................................... 103
5.8.1 INSERT语句......................................................................................................................... 103
5.8.2 UPDATE语句........................................................................................................................ 105
5.8.3 DELETE语句........................................................................................................................ 107
5.9 本章小结.............................................................................................................................................. 107
第6章 数据字典......................................................................................................... 108
6.1 数据字典中的内容............................................................................................................................. 108
6.2 使用和操作数据字典视图................................................................................................................. 108
6.3 数据字典视图分类............................................................................................................................. 109
6.4 使用数据字典视图............................................................................................................................. 113
6.5 动态性能视图及使用......................................................................................................................... 115
6.6 本章小结............................................................................................................................................ 118
第7章 网络配置管理.................................................................................................. 119
7.1 Oracle 的网络连接............................................................................................................................. 119
7.2 服务器端监听器配置......................................................................................................................... 120
7.2.1 动态注册............................................................................................................................... 122
7.2.2 静态注册............................................................................................................................... 124
7.2.3 连接测试............................................................................................................................... 127
7.2.4 监听程序管理........................................................................................................................ 129
7.3 客户端配置........................................................................................................................................ 130
7.3.1 本地命名............................................................................................................................... 130
7.3.2 简单命名............................................................................................................................... 131
7.4 Oracle 数据库服务器支持的两种连接方式..................................................................................... 132
7.4.1 服务器进程............................................................................................................................ 133
7.4.2 共享连接............................................................................................................................... 133
7.4.3 共享连接涉及初始化参数.................................................................................................... 134
7.4.4 共享连接的工作过程............................................................................................................ 134
7.4.5 共享连接的配置.................................................................................................................... 135
7.4.6 共享连接的一些问题............................................................................................................ 139
7.4.7 专有连接............................................................................................................................... 139
7.5 数据库驻留连接池............................................................................................................................. 140
7.5.1 DRCP的工作原理................................................................................................................. 140
7.5.2 如何配置DRCP..................................................................................................................... 141
7.6 本章小结............................................................................................................................................ 144
第8章 内存管理......................................................................................................... 145
8.1 内存架构............................................................................................................................................ 145
8.1.1 PGA 概述............................................................................................................................... 146
8.1.2 SGA 概述............................................................................................................................... 147
8.1.3 UGA概述............................................................................................................................... 150
8.2 内存管理............................................................................................................................................ 150
8.2.1 配置内存组件........................................................................................................................ 150
8.2.2 SGA与PGA 的自动调整..................................................................................................... 152
8.2.3 配置数据库smart flash 缓存................................................................................................. 153
8.3 本章小结............................................................................................................................................ 154
第9章 用户管理和资源文件....................................................................................... 155
9.1 创建用户............................................................................................................................................ 155
9.1.1 初试创建新用户.................................................................................................................... 155
9.1.2 创建用户语法及参数含义.................................................................................................... 157
9.1.3 改变用户参数........................................................................................................................ 158
9.2 删除用户............................................................................................................................................ 160
9.3 用户和数据库模式............................................................................................................................. 161
9.4 用户管理中的重要文件—概要文件............................................................................................. 162
9.4.1 什么是概要文件.................................................................................................................... 162
9.4.2 使用资源管理和口令管理的概要文件步骤........................................................................ 162
9.4.3 使用概要文件管理会话资源................................................................................................ 163
9.4.4 口令管理参数以及含义........................................................................................................ 164
9.4.5 创建口令管理的概要文件.................................................................................................... 167
9.5 修改和删除概要文件......................................................................................................................... 168
9.6 本章小结............................................................................................................................................ 169
第10章 控制文件和数据库启动................................................................................. 170
10.1 控制文件和数据库启动概述........................................................................................................... 170
10.2 如何获得控制文件的信息............................................................................................................... 171
10.3 控制文件的内容............................................................................................................................... 172
10.3.1 控制文件中所存的内容...................................................................................................... 172
10.3.2 如何查看控制文件中所存内容的记录信息...................................................................... 172
10.4 存储多重控制文件........................................................................................................................... 174
10.4.1 多重控制文件...................................................................................................................... 174
10.4.2 移动控制文件...................................................................................................................... 175
10.4.3 添加控制文件...................................................................................................................... 178
10.5 备份和恢复控制文件....................................................................................................................... 179
10.5.1 控制文件的备份.................................................................................................................. 179
10.5.2 控制文件的恢复.................................................................................................................. 180
10.6 本章小结.......................................................................................................................................... 183
第11章 重做日志管理................................................................................................ 184
11.1 Oracle 为何引入重做日志............................................................................................................... 184
11.2 读取重做日志文件信息................................................................................................................... 185
11.2.1 v$log视图............................................................................................................................ 185
11.2.2 v$logfile 视图....................................................................................................................... 186
11.2.3 判断是否归档...................................................................................................................... 187
11.2.4 设置数据库为归档模式...................................................................................................... 187
11.3 重做日志组及其管理....................................................................................................................... 188
11.3.1 添加重做日志组.................................................................................................................. 188
11.3.2 删除联机重做日志组.......................................................................................................... 190
11.4 重做日志成员及维护....................................................................................................................... 192
11.4.1 添加重做日志成员.............................................................................................................. 192
11.4.2 删除联机重做日志成员...................................................................................................... 193
11.4.3 重设联机重做日志的大小.................................................................................................. 194
11.5 清除联机重做日志........................................................................................................................... 197
11.6 日志切换和检查点事件................................................................................................................... 197
11.7 归档重做日志.................................................................................................................................. 198
11.8 本章小结.......................................................................................................................................... 198
第12章 管理归档日志................................................................................................ 199
12.1 归档模式.......................................................................................................................................... 199
12.2 设置归档模式.................................................................................................................................. 200
12.3 设置归档进程与归档目录............................................................................................................... 201
12.4 维护归档目录.................................................................................................................................. 207
12.5 本章小结.......................................................................................................................................... 211
第13章 表空间与数据文件管理................................................................................. 212
13.1 Oracle 数据库的逻辑结构............................................................................................................... 212
13.2 表空间的分类以及创建表空间....................................................................................................... 214
13.3 表空间磁盘管理的两种方案........................................................................................................... 217
13.3.1 数据字典管理的表空间磁盘管理...................................................................................... 217
13.3.2 本地管理的表空间磁盘管理.............................................................................................. 217
13.4 创建表空间...................................................................................................................................... 217
13.4.1 创建数据字典管理的表空间.............................................................................................. 218
13.4.2 创建本地管理的表空间...................................................................................................... 219
13.4.3 创建还原表空间.................................................................................................................. 220
13.4.4 创建临时表空间.................................................................................................................. 222
13.4.5 默认临时表空间.................................................................................................................. 224
13.4.6 创建大文件表空间.............................................................................................................. 226
13.5 表空间管理...................................................................................................................................... 229
13.5.1 脱机管理.............................................................................................................................. 229
13.5.2 只读管理.............................................................................................................................. 231
13.6 表空间和数据文件管理................................................................................................................... 234
13.6.1 修改表空间大小.................................................................................................................. 234
13.6.2 修改表空间的存储参数...................................................................................................... 237
13.6.3 删除表空间.......................................................................................................................... 238
13.6.4 迁移数据文件...................................................................................................................... 238
13.6.5 数据字典和本地管理的表空间.......................................................................................... 241
13.7 本章小结.......................................................................................................................................... 242
第14章 UNDO表空间管理........................................................................................ 243
14.1 引入还原段的作用........................................................................................................................... 243
14.2 还原段如何完成读一致性............................................................................................................... 244
14.2.1 Oracle 如何实现读一致性................................................................................................... 244
14.2.2 读一致性的进一步复杂化分析.......................................................................................... 244
14.2.3 读一致性的具体步骤.......................................................................................................... 245
14.3 还原段的实例恢复与事务回滚....................................................................................................... 246
14.4 UNDO SEGMENT 的选择算法....................................................................................................... 246
14.5 讨论undo_retention参数................................................................................................................. 246
14.6 还原段分类...................................................................................................................................... 248
14.7 Oracle 的自动还原段管理............................................................................................................... 249
14.8 创建还原表空间............................................................................................................................... 250
14.9 维护还原表空间............................................................................................................................... 251
14.10 切换还原表空间............................................................................................................................. 253
14.10.1 UNDO表空间切换示例.................................................................................................... 253
14.10.2 UNOD表空间切换涉及状态............................................................................................ 254
14.10.3 删除UNDO表空间示例................................................................................................... 254
14.11 dba_undo_extents 数据字典........................................................................................................... 256
14.12 本章小结........................................................................................................................................ 257
第15章 事务（Transaction）.................................................................................... 258
15.1 Oracle 事务的由来........................................................................................................................... 258
15.2 什么是事务...................................................................................................................................... 258
15.3 事务的特点...................................................................................................................................... 259
15.4 事务控制.......................................................................................................................................... 259
15.4.1 使用COMMIT 的显式事务控制........................................................................................ 259
15.4.2 使用ROLLBACK实现事务控制....................................................................................... 261
15.4.3 程序异常退出对事务的影响.............................................................................................. 262
15.4.4 使用AUTOCOMMIT 实现事务的自动提交..................................................................... 264
15.5 本章小结.......................................................................................................................................... 265
第16章 角色管理....................................................................................................... 266
16.1 什么是角色...................................................................................................................................... 266
16.2 创建角色.......................................................................................................................................... 267
16.3 修改角色.......................................................................................................................................... 269
16.4 赋予角色权限.................................................................................................................................. 270
16.5 赋予用户角色.................................................................................................................................. 271
16.6 默认角色.......................................................................................................................................... 274
16.7 禁止和激活角色............................................................................................................................... 277
16.8 回收和删除角色............................................................................................................................... 279
16.9 Oracle 预定义的角色....................................................................................................................... 281
16.10 本章小结........................................................................................................................................ 283
第17章 管理和维护表................................................................................................ 284
17.1 Oracle 基本的数据存储机制—表............................................................................................... 284
17.1.1 数据的存储类型.................................................................................................................. 284
17.1.2 行ID（ROWID）................................................................................................................ 286
17.2 创建表.............................................................................................................................................. 287
17.2.1 Oracle 创建表的规则........................................................................................................... 287
17.2.2 创建普通表.......................................................................................................................... 287
17.2.3 创建临时表.......................................................................................................................... 289
17.3 段空间管理...................................................................................................................................... 291
17.4 理解高水位线（HWM）................................................................................................................. 292
17.5 理解行迁移...................................................................................................................................... 292
17.6 创建索引组织表（IOT）................................................................................................................ 293
17.6.1 IOT 表的结构....................................................................................................................... 293
17.6.2 创建IOT 表.......................................................................................................................... 294
17.7 表参数以及参数维护....................................................................................................................... 295
17.8 维护列.............................................................................................................................................. 297
17.9 删除和截断表.................................................................................................................................. 302
17.10 本章小结........................................................................................................................................ 304
第18章 索引.............................................................................................................. 305
18.1 索引的概念...................................................................................................................................... 305
18.2 Oracle 实现数据访问的方法........................................................................................................... 305
18.2.1 全表扫描（FULL TABLE SCAN)...................................................................................... 306
18.2.2 通过行ID（ROWID）........................................................................................................ 306
18.2.3 使用索引.............................................................................................................................. 307
18.3 索引扫描类型.................................................................................................................................. 308
18.3.1 索引唯一扫描（INDEX UNIQUE SCAN)......................................................................... 308
18.3.2 索引范围扫描（INDEX RANGE SCAN) .......................................................................... 309
18.3.3 索引全扫描（INDEX FULL SCAN).................................................................................. 309
18.3.4 索引快速扫描（INDEX FAST FULL SCAN) ................................................................... 310
18.4 限制索引使用的情况....................................................................................................................... 310
18.4.1 使用不等于运算符.............................................................................................................. 310
18.4.2 使用 IS NULL或IS NOT NULL....................................................................................... 311
18.4.3 使用函数.............................................................................................................................. 312
18.4.4 比较不匹配的数据类型...................................................................................................... 313
18.5 集群因子.......................................................................................................................................... 314
18.6 二元高度.......................................................................................................................................... 314
18.7 直方图.............................................................................................................................................. 315
18.8 建立索引.......................................................................................................................................... 316
18.9 查看索引.......................................................................................................................................... 319
18.10 B树索引........................................................................................................................................ 320
18.10.1 B树索引的工作原理......................................................................................................... 320
18.10.2 B树索引的注意事项......................................................................................................... 321
18.11 位图索引........................................................................................................................................ 321
18.11.1 位图索引的使用讨论........................................................................................................ 321
18.11.2 创建位图索引.................................................................................................................... 322
18.11.3 B位图索引的插入问题..................................................................................................... 323
18.12 Hash 索引....................................................................................................................................... 324
18.13 反向键索引.................................................................................................................................... 326
18.14 基于函数的索引............................................................................................................................. 326
18.15 监控索引的使用............................................................................................................................. 328
18.16 重建索引........................................................................................................................................ 329
18.17 维护索引........................................................................................................................................ 331
18.18 删除索引........................................................................................................................................ 332
18.19 本章小结........................................................................................................................................ 333
第19章 系统和对象权限管理..................................................................................... 334
19.1 权限的概念和分类........................................................................................................................... 334
19.2 系统权限.......................................................................................................................................... 334
19.3 授予用户系统权限........................................................................................................................... 335
19.4 SYSDBA 和SYSOPER系统特权................................................................................................... 339
19.5 回收用户系统权限........................................................................................................................... 340
19.6 授予对象权限.................................................................................................................................. 343
19.7 回收对象权限.................................................................................................................................. 345
19.8 本章小结.......................................................................................................................................... 346
第20章 视图.............................................................................................................. 347
20.1 什么是视图...................................................................................................................................... 347
20.2 创建视图.......................................................................................................................................... 347
20.3 使用视图的WITH 子句................................................................................................................... 350
20.4 视图的修改...................................................................................................................................... 352
20.5 Oracle 的视图管理........................................................................................................................... 354
20.5.1 通过数据字典查询视图...................................................................................................... 354
20.5.2 Oracle 视图查询的内部过程............................................................................................... 354
20.6 视图DML 操作的限制.................................................................................................................... 355
20.6.1 简单视图.............................................................................................................................. 355
20.6.2 复杂视图.............................................................................................................................. 355
20.7 视图的优点...................................................................................................................................... 356
20.8 删除视图.......................................................................................................................................... 356
20.9 物化视图.......................................................................................................................................... 357
20.9.1 什么是物化视图.................................................................................................................. 357
20.9.2 查询重写的概念.................................................................................................................. 357
20.9.3 物化视图的同步.................................................................................................................. 358
20.9.4 创建物化视图...................................................................................................................... 359
20.9.5 物化视图的使用环境.......................................................................................................... 361
20.10 本章小结........................................................................................................................................ 362
第21章 序列号和同义词............................................................................................ 363
21.1 什么是序列号.................................................................................................................................. 363
21.2 创建和使用序列号........................................................................................................................... 363
21.3 修改序列号...................................................................................................................................... 366
21.4 删除序列号...................................................................................................................................... 369
21.5 什么是同义词.................................................................................................................................. 369
21.6 创建公有同义词............................................................................................................................... 370
21.7 创建私有同义词............................................................................................................................... 371
21.8 删除同义词...................................................................................................................................... 372
21.9 切换用户模式.................................................................................................................................. 373
21.10 本章小结........................................................................................................................................ 373
第22章 RMAN备份与恢复数据库............................................................................. 374
22.1 RMAN概述..................................................................................................................................... 374
22.2 RMAN的独特之处.......................................................................................................................... 374
22.3 RMAN系统架构详解...................................................................................................................... 375
22.4 快闪恢复区（flash recovery area）................................................................................................. 376
22.4.1 修改快闪恢复区大小.......................................................................................................... 376
22.4.2 解决快闪恢复区的空间不足问题...................................................................................... 378
22.5 建立RMAN到数据库的连接......................................................................................................... 379
22.6 RMAN的相关概念与配置参数...................................................................................................... 380
22.7 RMAN备份控制文件...................................................................................................................... 382
22.8 RMAN实现脱机备份...................................................................................................................... 384
22.9 RMAN联机备份.............................................................................................................................. 385
22.9.1 联机备份前的准备工作...................................................................................................... 385
22.9.2 联机备份整个数据库.......................................................................................................... 387
22.9.3 联机备份一个表空间.......................................................................................................... 390
22.9.4 联机备份一个数据文件...................................................................................................... 391
22.9.5 RMAN 备份坏块处理方式................................................................................................. 392
22.10 RMAN的增量备份........................................................................................................................ 393
22.11 快速增量备份................................................................................................................................ 395
22.12 在映像副本上应用增量备份......................................................................................................... 396
22.13 创建和维护恢复目录..................................................................................................................... 398
22.14 RMAN的脚本管理........................................................................................................................ 401
22.15 使用RMAN非归档模式下的完全恢复....................................................................................... 403
22.15.1 控制文件、数据文件以及重做日志文件丢失的恢复.................................................... 403
22.15.2 只有数据文件丢失的恢复................................................................................................ 407
22.15.3 联机重做日志文件和数据文件损坏的恢复.................................................................... 409
22.15.4 如何将数据文件恢复到其他磁盘目录下........................................................................ 412
22.16 使用RMAN归档模式下的完全恢复........................................................................................... 412
22.16.1 非系统表空间损坏的恢复................................................................................................ 412
22.16.2 系统表空间损坏的恢复.................................................................................................... 415
22.16.3 所有数据文件丢失的恢复................................................................................................ 416
22.17 RMAN实现数据块恢复................................................................................................................ 416
22.18 RMAN的备份维护指令................................................................................................................ 420
22.18.1 RMAN 的VALIDATE BACKUPSET指令..................................................................... 420
22.18.2 RMAN 的RESTORE…VALIDATE指令....................................................................... 421
22.18.3 RMAN 的RESTORE…PREVIEW指令.......................................................................... 422
22.18.4 RMAN 的LIST 指令......................................................................................................... 423
22.18.5 RMAN 的REPORT指令.................................................................................................. 426
22.19 本章小结........................................................................................................................................ 427
第23章 Oracle闪回技术............................................................................................ 428
23.1 理解闪回级别.................................................................................................................................. 428
23.2 闪回数据库...................................................................................................................................... 428
23.2.1 闪回数据库概述.................................................................................................................. 428
23.2.2 启用闪回数据库.................................................................................................................. 429
23.2.3 关闭闪回数据库.................................................................................................................. 432
23.2.4 闪回数据库方法.................................................................................................................. 434
23.2.5 使用闪回数据库.................................................................................................................. 434
23.2.6 监控闪回数据库.................................................................................................................. 437
23.2.7 使用闪回数据库的限制...................................................................................................... 438
23.3 闪回删除.......................................................................................................................................... 439
23.3.1 闪回删除原理...................................................................................................................... 439
23.3.2 回收站的使用...................................................................................................................... 440
23.3.3 恢复删除的表...................................................................................................................... 442
23.3.4 恢复多个同名的表.............................................................................................................. 446
23.3.5 应用Purge 永久删除表....................................................................................................... 448
23.4 闪回表.............................................................................................................................................. 450
23.5 闪回版本查询.................................................................................................................................. 453
23.6 闪回事务查询.................................................................................................................................. 454
23.7 闪回查询.......................................................................................................................................... 455
23.8 复原点技术...................................................................................................................................... 456
23.9 本章小结.......................................................................................................................................... 457
第24章 手工管理的备份恢复..................................................................................... 459
24.1 备份恢复的概念............................................................................................................................... 459
24.1.1 物理备份.............................................................................................................................. 459
24.1.2 逻辑备份.............................................................................................................................. 460
24.1.3 冷备份与热备份.................................................................................................................. 460
24.1.4 数据库恢复.......................................................................................................................... 460
24.2 非归档模式下的冷备与恢复........................................................................................................... 461
24.2.1 冷备的步骤.......................................................................................................................... 462
24.2.2 冷备下的恢复...................................................................................................................... 464
24.2.3 缺少重做日志文件的恢复方法.......................................................................................... 466
24.3 归档模式与非归档模式................................................................................................................... 468
24.3.1 设置数据库的归档模式...................................................................................................... 468
24.3.2 设置归档进程相关参数...................................................................................................... 470
24.3.3 管理归档文件和归档目录.................................................................................................. 471
24.4 手工热备数据库的步骤................................................................................................................... 474
24.5 热备过程中对数据库崩溃的处理方法........................................................................................... 477
24.6 热备的原理...................................................................................................................................... 480
24.7 备份控制文件.................................................................................................................................. 481
24.8 介质恢复的原理............................................................................................................................... 484
24.9 归档模式下的完全恢复................................................................................................................... 489
24.9.1 数据文件在有备份情况下的恢复...................................................................................... 490
24.9.2 数据文件在无备份情况下的恢复...................................................................................... 493
24.9.3 系统表空间数据文件损坏的完全恢复.............................................................................. 495
24.9.4 当前UNDO表空间损坏的完全恢复................................................................................. 497
24.9.5 非当前UNDO表空间损坏的完全恢复............................................................................. 499
24.10 何时使用不完全恢复..................................................................................................................... 502
24.10.1 不完全恢复的场合............................................................................................................ 502
24.10.2 不完全恢复的类型............................................................................................................ 502
24.11 所有控制文件丢失的恢复方法..................................................................................................... 503
24.11.1 使用备份的控制文件........................................................................................................ 503
24.11.2 重建控制文件.................................................................................................................... 507
24.12 本章小结........................................................................................................................................ 511
第25章 OEM管理与使用.......................................................................................... 512
25.1 OEM 架构........................................................................................................................................ 512
25.2 OEM 的安装.................................................................................................................................... 513
25.2.1 第一种安装方式.................................................................................................................. 513
25.2.2 第二种安装方式.................................................................................................................. 514
25.2.3 第三种安装方式.................................................................................................................. 516
25.3 OEM 的启动与关闭......................................................................................................................... 518
25.4 OEM 监控数据库运行..................................................................................................................... 520
25.4.1 Home 目录............................................................................................................................ 521
25.4.2 Performance 部分................................................................................................................. 522
25.4.3 Availablity 部分................................................................................................................... 523
25.4.4 Server 部分........................................................................................................................... 528
25.4.5 Schema 部分......................................................................................................................... 530
25.4.6 Data Movement 部分............................................................................................................ 531
25.4.7 Software and Support 部分................................................................................................... 531
25.5 本章小结.......................................................................................................................................... 533
第26章 Oracle数据库实例优化................................................................................. 534
26.1 详解SGA 与实例优化..................................................................................................................... 534
26.2 将程序常驻内存............................................................................................................................... 539
26.2.1 创建软件包DBMS_SHARED_POOL................................................................................ 539
26.2.2 将程序常驻内存的过程...................................................................................................... 541
26.2.3 从DBMSPOOL脚本理解软件包DBMS_SHARED_POOL............................................ 543
26.3 将数据常驻内存............................................................................................................................... 545
26.3.1 再论数据块缓存池.............................................................................................................. 545
26.3.2 将数据常驻内存的过程...................................................................................................... 546
26.3.3 将常驻内存的程序恢复为默认缓冲池.............................................................................. 549
26.4 优化重做日志缓冲区....................................................................................................................... 550
26.4.1 深入理解重做日志缓冲区的工作机制.............................................................................. 550
26.4.2 重做日志缓冲区相关的等待事件...................................................................................... 552
26.4.3 设置重做日志缓冲区大小.................................................................................................. 554
26.5 优化共享池（Shared Pool）............................................................................................................ 556
26.5.1 库高速缓存.......................................................................................................................... 556
26.5.2 使用绑定变量...................................................................................................................... 556
26.5.3 调整CURSOR_SHARING参数......................................................................................... 559
26.5.4 设置共享池的大小.............................................................................................................. 560
26.6 优化数据库高速缓存（DB Cache）............................................................................................... 561
26.6.1 调整数据库缓冲区大小...................................................................................................... 561
26.6.2 使用缓冲池.......................................................................................................................... 563
26.7 优化PGA 内存................................................................................................................................ 565
26.8 本章小结.......................................................................................................................................... 568
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 11g R2 DBA 操作指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Wait Interface性能诊断与调整实践指南 (平装)
第1章 介绍Oracle Wait Interface 1
1.1 Oracle性能优化的旧方式 2
1.2 高速缓存命中率极度无效率的原因 2
1.3 Oracle性能优化的新方式 4
1.4 OWI基本原理 4
1.5 数据库响应时间调整模型 6
1.6 思维的变迁 8
1.7 小结 9
第2章 Oracle Wait Interface组件 11
2.1 什么是等待事件 11
2.2 OWI组件 12
2.2.1 V$EVENT_NAME视图 13
2.2.2 V$SYSTEM_EVENT视图 14
2.2.3 V$SESSION_EVENT视图 17
2.2.4 V$SESSION_WAIT视图 19
2.2.5 追踪事件10046-- 扩充的SQL追踪 21
2.3 Oracle Database 10g Release 1中的新OWI视图 27
2.3.1 V$SESSION_WAIT_HISTORY视图 27
2.3.2 V$SYSTEM_WAIT_CLASS视图 28
2.3.3 V$SESSION_WAIT_CLASS视图 29
2.3.4 V$EVENT_HISTOGRAM视图 29
2.3.5 等待事件的类型 31
2.4 OWI的局限 33
2.4.1 没有CPU统计 33
2.4.2 没有端到端的可视性 33
2.4.3 没有历史数据 34
2.4.4 不精确 34
2.5 小结 35
第3章 常见的等待事件 37
3.1 常见等待事件简介 37
3.1.1 buffer busy waits等待事件 38
3.1.2 control file parallel write等待事件 39
3.1.3 db file parallel read等待事件 40
3.1.4 db file parallel write等待事件 40
3.1.5 db file scattered read等待事件 41
3.1.6 db file sequential read等待事件 41
3.1.7 db file single write等待事件 42
3.1.8 direct path read等待事件 42
3.1.9 direct path write等待事件 43
3.1.10 enqueue等待事件 43
3.1.11 free buffer waits等待事件 44
3.1.12 latch free等待事件 45
3.1.13 library cache pin等待事件 46
3.1.14 library cache lock等待事件 46
3.1.15 log buffer space等待事件 47
3.1.16 log file parallel write等待事件 47
3.1.17 log file sequential read等待事件 47
3.1.18 log file switch(archiving needed)等待事件 48
3.1.19 log file switch(checkpoint incomplete)等待事件 48
3.1.20 log file switch completion等待事件 48
3.1.21 log file sync等待事件 49
3.1.22 SQL*Net message from client等待事件 49
3.1.23 SQL*Net message to client等待事件 50
3.2 Oracle Real Application Clusters环境中的常见等待事件 50
3.2.1 global cache cr request 50
3.2.2 buffer busy global cache等待事件 51
3.2.3 buffer busy global cr等待事件 52
3.2.4 global cache busy等待事件 52
3.2.5 global cache null to x等待事件 53
3.2.6 global cache null to s等待事件 53
3.2.7 global cache s to x等待事件 54
3.2.8 global cache open x等待事件 54
3.2.9 global cache open s等待事件 54
3.2.10 row cache lock 55
3.3 追踪CPU和其他统计 55
3.4 小结 57
第4章 OWI监控和收集方法 59
4.1 性能历史数据重要的原因 60
4.2 对根本原因快速而精确的分析 60
4.3 追踪事件10046不适合用作数据收集器的原因 61
4.4 Statspack不适合用作数据收集器的原因 62
4.5 将Database Logoff Trigger用作数据收集器 62
4.6 利用PL/SQL过程进行性能数据采样 66
4.6.1 数据源 66
4.6.2 采样频率 67
4.6.3 存储库 69
4.6.4 监控的事件 70
4.6.5 优点与缺点 76
4.7 利用非SQL式SGA访问进行性能数据采样 77
4.8 小结 77
第5章 解释常见的与I/O有关的等待事件 79
5.1 db file sequential read等待事件 80
5.2 db file scattered read等待事件 86
5.2.1 常见的原因、诊断和动作 86
5.2.2 db file sequential read事件出现在全表扫描操作中的原因 89
5.2.3 全局扫描操作比MBRC请求更少块的原因 90
5.2.4 设置DB_FILE_MULTIBLOCK_READ_COUNT(MBRC) 91
5.2.5 为什么物理I/O需要巨大代价 92
5.3 direct path read事件 92
5.3.1 常见的原因、诊断和动作 92
5.3.2 关注的初始参数 96
5.4 direct path write等待事件 98
5.5 db file parallel write等待事件 100
5.6 log file parallel write等待事件 103
5.7 control file parallel write等待事件 106
5.8 小结 107
第6章 解释与锁有关的等待事件 109
6.1 latch free等待事件 110
6.1.1 什么是锁存器 110
6.1.2 锁存器和锁两者之间的区别 110
6.1.3 锁存器家族 111
6.1.4 锁存器获取 111
6.1.5 锁存器分类 112
6.1.6 latch free等待事件表明的内容 114
6.1.7 锁存器丢失位置 115
6.1.8 Oracle Database 10g Release 1中的锁存器 115
6.1.9 常见的原因、诊断和动作 116
6.1.10 shared pool锁存器和library cache锁存器 117
6.1.11 cache buffers chains锁存器 123
6.1.12 cache buffers lru chain锁存器 129
6.1.13 row cache objects锁存器 131
6.2 enqueue等待事件 131
6.2.1 什么是排队 132
6.2.2 什么是排队资源 132
6.2.3 什么是排队锁 134
6.2.4 排队体系结构 135
6.2.5 解码排队类型和模式 135
6.2.6 常见的原因、诊断和动作 137
6.3 buffer busy waits等待事件 143
6.4 小结 150
第7章 解释与延迟有关的常见等待事件 153
7.1 log file sync等待事件 153
7.2 log buffer space等待事件 158
7.3 free buffer waits等待事件 159
7.4 write complete waits等待事件 163
7.5 log file switch completion等待事件 163
7.6 log file switch(checkpoint incomplete)等待事件 164
7.7 小结 165
第8章 Real Application Clusters环境中的等待事件 167
8.1 Real Application Clusters中等待事件的特殊之处 167
8.2 全局高速缓存等待事件 173
8.2.1 global cache cr request等待事件 173
8.2.2 global cache busy等待事件 176
8.3 Oracle Database 10g中增加的RAC等待事件 178
8.4 enqueue等待事件 178
8.5 小结 182
第9章 Oracle Database 10g中的性能管理 183
9.1 数据库统计 184
9.1.1 时间模型统计 184
9.1.2 等待模型统计 185
9.1.3 操作系统统计 185
9.1.4 其他SQL统计 186
9.1.5 数据库度量 186
9.2 新的后台进程 186
9.3 Automatic Workload Repository 187
9.3.1 存储库快照 188
9.3.2 快照基线 188
9.3.3 使用EM管理AWR 188
9.3.4 手工管理AWR 191
9.4 Active Session History 194
9.4.1 什么是活动会话 195
9.4.2 ASH的组成部分 195
9.5 ADDM 199
9.5.1 ADDM设置 200
9.5.2 使用EM访问ADDM 201
9.5.3 手工运行ADDM报告 207
9.5.4 ADDM视图 208
9.6 小结 208
附录A Oracle Database 10g的诊断事件 209
A.1 Oracle诊断事件 209
A.1.1 诊断事件的类型 210
A.1.2 设置诊断事件 212
A.1.3 事件的内部工作 216
附录B Oracle Database 10g中的enqueue等待事件 219
附录C Oracle转储和追踪 227
C.1 oradebug：追踪和转储的重要工具 227
C.2 数据块转储 229
C.3 缓冲区转储 230
C.3.1 语法 230
C.3.2 控制转储信息 231
C.4 缓冲区转储 231
C.4.1 语法 231
C.4.2 使用级别控制转储信息 232
C.5 文件头转储 232
C.5.1 语法 232
C.5.2 使用级别控制转储信息 233
C.6 控制文件转储 234
C.6.1 语法 234
C.6.2 使用级别控制转储信息 234
C.7 堆转储 234
C.7.1 语法 235
C.7.2 使用级别控制转储信息 235
C.8 库高速缓存转储 236
C.8.1 语法 236
C.8.2 使用级别控制转储信息 236
C.9 进程状态转储 236
C.10 Shared Server状态转储 237
C.10.1 语法 237
C.10.2 使用级别控制转储信息 238
C.11 系统状态转储 238
C.11.1 语法 238
C.11.2 使用级别控制转储信息 238
C.12 重做日志转储 239
C.12.1 语法 239
C.12.2 使用级别控制转储信息 239
附录D 直接访问SGA 241
D.1 开销 241
D.2 安全性 242
D.3 速度 242
D.4 并发性 242
D.5 获取隐藏信息 242
D.6 X$视图简介 242
D.7 必要的成份 244
D.7.1 查找SGA ID 245
D.7.2 查找SGA基地址 245
D.7.3 查找X$KSUSECST的起始地址 246
D.7.4 查找X$KSUSECST结构中的记录大小 246
D.7.5 查找X$KSUSECST结构中的记录数 246
D.7.6 查找X$KSUSECST视图列的偏移量 247
D.8 使用C程序访问SGA 248
附录E 参考文献 253
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Wait Interface性能诊断与调整实践指南 (平装)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle RAC 11g实战指南
前言
第1章   高可用性概述	1
1.1   什么是高可用性	1
1.2   如何获得高可用性	2
1.3   什么是集群	3
1.4   Oracle的高可用性产品	7
第2章   Oracle RAC 11g的体系结构	9
2.1   Oracle RAC 11g的新特性	9
2.2   RAC集群的体系结构	10
第3章   安装RAC之前的准备工作	15
3.1   系统需要满足什么条件	15
3.1.1   系统需要满足的硬件条件	15
3.1.2   系统需要满足的软件条件	16
3.1.3   节点间的网络需要满足什么条件	18
3.1.4   存储设备需要满足什么条件	21
3.1.5   节点的时钟需要满足什么条件	22
3.2   root用户需要完成的工作	23
3.2.1   如何调整操作系统	23
3.2.2   如何创建用户和用户组	25
3.2.3   如何配置存储设备	26
3.2.4   如何配置网络	29
3.3   oracle用户需要完成的工作	30
3.3.1   如何设置环境变量	30
3.3.2   如何手工配置SSH	31
第4章   Grid Infrastructure软件的安装	37
4.1   如何进行安装前的校验	37
4.2   开始安装Grid Infrastructure软件	39
4.3   如何查看安装结果	55
4.3.1   如何查看节点的状态	55
4.3.2   如何查看VIP和SCAN	56
4.3.3   如何查看Clusterware中服务的状态	57
4.3.4   如何查看ASM实例的状态	60
4.4   如何删除Grid Infrastructure	60
第5章   Oracle数据库软件的安装	64
5.1   安装前的准备工作	64
5.2   开始安装Oracle数据库软件	65
5.3   如何删除Oracle数据库软件	74
第6章   集群数据库的创建	75
6.1   创建集群数据库之前的准备工作	75
6.2   开始创建集群数据库	76
6.3   如何删除集群数据库	90
第7章   RAC集群的维护	93
7.1   如何管理Voting文件	93
7.2   如何管理OCR文件	95
7.3   如何管理RAC集群中的各种资源	97
7.4   如何管理RAC集群中的网络	99
7.4.1   如何修改VIP	99
7.4.2   如何修改SCAN	100
7.4.3   如何修改私有和公共IP地址	101
7.5   如何扩展RAC集群	102
7.5.1   扩展RAC之前的准备工作	103
7.5.2   如何扩展Clusterware	103
7.5.3   如何扩展Oracle数据库服务器	104
第8章   自动存储管理	105
8.1   ASM实例的创建	106
8.2   磁盘组的管理	110
8.2.1   磁盘组的创建和删除	110
8.2.2   磁盘的添加和删除	112
8.2.3   磁盘组信息的查询	112
8.2.4   磁盘组的重新平衡	114
8.2.5   磁盘组的挂接和卸载	114
8.2.6   磁盘组中目录的管理	115
8.3   如何使用ASM磁盘组	117
8.3.1   如何激活自动文件管理功能	118
8.3.2   文件的命名规则	118
8.3.3   如何创建OMF数据库	119
8.3.4   如何创建OMF表空间	122
8.3.5   如何创建OMF控制文件	123
8.3.6   如何创建OMF重做日志文件	123
8.3.7   如何存储归档日志文件	124
8.4   命令行工具ASMCMD的用法	124
8.4.1   如何通过ASMCMD管理ASM实例	125
8.4.2   如何通过ASMCMD管理ASM磁盘组	128
8.4.3   如何通过ASMCMD管理磁盘组中的文件	131
8.5   ACFS文件系统管理	133
8.5.1   如何管理ASM磁盘组中的卷	134
8.5.2   如何管理ASM磁盘组中的文件系统	137
8.5.3   ACFSUTIL工具的用法	139
第9章   集群数据库的维护	141
9.1   数据库的启动和关闭	141
9.2   如何对初始化参数进行维护	142
9.3   如何对重做日志进行维护	144
9.4   如何对表空间进行维护	147
9.5   如何对控制文件进行维护	149
第10章   数据库的备份与恢复—RMAN的用法	150
10.1   RMAN的基本结构	150
10.2   RMAN的配置	152
10.2.1   如何配置RMAN客户端的连接	153
10.2.2   恢复目录的创建	153
10.2.3   如何对目标数据库的归档日志文件进行配置	154
10.3   如何利用RMAN对数据库进行备份	155
10.3.1   通道的设置	156
10.3.2   存储脚本的用法	157
10.3.3   控制文件的备份	158
10.3.4   参数文件的备份	159
10.3.5   归档日志文件的备份	159
10.3.6   非归档模式下数据文件的备份	160
10.3.7   归档模式下数据文件的备份	161
10.3.8   备份集的备份	163
10.4   如何对数据库进行完全恢复	164
10.4.1   如何对备份文件进行校验	164
10.4.2   如何对数据文件进行恢复	165
10.5   两个实际的例子	167
10.5.1   模拟数据文件损坏的例子	167
10.5.2   模拟磁盘损坏的例子	168
10.6   如何对坏块进行恢复	169
10.6.1   什么叫块介质恢复	169
10.6.2   如何进行块介质恢复	170
10.7   如何对数据进行跨平台移植	171
10.7.1   字节存储次序相同时的移植	171
10.7.2   字节存储次序不同时的移植	173
附录A   Oracle RAC 11g在Solaris下的安装	175
附录B   Oracle RAC 11g在Linux下的安装	189
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle RAC 11g实战指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle性能优化技术内幕
序言
前言
第一部分 方法
第二部分 应用程序优化
第三部分 实例与数据库优化
第四部分 特殊优化
第五部分 环境优化
第六部分 附录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle性能优化技术内幕
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Oracle Database 12c SQL & PLSQL编程（第3版）
目    录
第1章  简介	1
1.1  关系数据库简介	1
1.2  SQL简介	2
1.3  使用SQL*Plus	4
1.3.1  启动SQL*Plus	4
1.3.2  从命令行启动SQL*Plus	4
1.3.3  使用SQL*Plus执行SELECT语句	5
1.4  使用SQL Developer	6
1.5  创建store模式	8
1.5.1  检查脚本	8
1.5.2  运行脚本	10
1.5.3  用来创建store模式的DDL语句	11
1.6  添加、修改和删除行	17
1.6.1  向表中添加行	17
1.6.2  修改表中的现有行	19
1.6.3  从表中删除行	20
1.7  连接数据库和断开连接	20
1.8  退出SQL*Plus	20
1.9  Oracle PL/SQL简介	21
1.10  小结	22
第2章  从数据库表中检索信息	23
2.1  对单表执行SELECT语句	24
2.2  选择一个表中的所有列	24
2.3  使用WHERE子句限定行	25
2.4  行标识符	25
2.5  行号	26
2.6  执行算术运算	26
2.6.1  执行日期运算	27
2.6.2  列运算	28
2.6.3  算术运算操作符的优先级	29
2.7  使用列别名	29
2.8  使用连接操作合并列的输出结果	30
2.9  空值	31
2.10  禁止显示重复行	32
2.11  比较值	33
2.11.1  使用不等于操作符	33
2.11.2  使用大于操作符	34
2.11.3  使用小于或等于操作符	34
2.11.4  使用ANY操作符	34
2.11.5  使用ALL操作符	35
2.12  使用SQL操作符	35
2.12.1  使用LIKE操作符	36
2.12.2  使用IN操作符	37
2.12.3  使用BETWEEN操作符	38
2.13  使用逻辑操作符	38
2.13.1  使用AND操作符	38
2.13.2  使用OR操作符	39
2.14  逻辑操作符的优先级	39
2.15  使用ORDER BY子句对行进行排序	40
2.16  执行使用两个表的SELECT语句	41
2.17  使用表别名	43
2.18  笛卡尔积	43
2.19  执行使用多于两个表的SELECT语句	44
2.20  连接条件和连接类型	45
2.20.1  不等连接	46
2.20.2  外连接	46
2.20.3  自连接	50
2.21  使用SQL/92语法执行连接	51
2.21.1  使用SQL/92标准语法执行两个表的内连接	51
2.21.2  使用USING关键字简化连接	51
2.21.3  使用SQL/92执行多于两个表的内连接	52
2.21.4  使用SQL/92执行多列的内连接	53
2.21.5  使用SQL/92执行外连接	53
2.21.6  使用SQL/92执行自连接	55
2.21.7  使用SQL/92执行交叉连接	55
2.22  小结	55
第3章  使用SQL*Plus	57
3.1  查看表的结构	58
3.2  编辑SQL语句	58
3.3  保存、检索并运行文件	60
3.4  格式化列	63
3.5  设置页面大小	65
3.6  设置行大小	66
3.7  清除列的格式	67
3.8  使用变量	67
3.8.1  临时变量	67
3.8.2  已定义变量	70
3.9  创建简单报表	73
3.9.1  在脚本中使用临时变量	73
3.9.2  在脚本中使用已定义变量	73
3.9.3  向脚本中的变量传递值	74
3.9.4  添加页眉和页脚	75
3.9.5  计算小计	76
3.10  从SQL*Plus获取帮助信息	78
3.11  自动生成SQL语句	79
3.12  断开数据库连接并退出SQL*Plus	79
3.13  小结	79
第4章  使用简单函数	81
4.1  使用单行函数	82
4.1.1  字符函数	82
4.1.2  数值函数	91
4.1.3  转换函数	96
4.1.4  正则表达式函数	106
4.2  使用聚合函数	112
4.2.1  AVG()	113
4.2.2  COUNT()	114
4.2.3  MAX()和MIN()	114
4.2.4  STDDEV()	115
4.2.5  SUM()	115
4.2.6  VARIANCE()	115
4.3  对行进行分组	116
4.3.1  使用GROUP BY子句对行进行分组	116
4.3.2  调用聚合函数的错误用法	119
4.3.3  使用HAVING子句过滤行组	120
4.3.4  组合使用WHERE和GROUP BY子句	120
4.3.5  组合使用WHERE、GROUP BY和HAVING子句	121
4.4  小结	122
第5章  日期和时间的存储与处理	123
5.1  几个简单的存储和检索日期的例子	123
5.2  使用TO_CHAR()和TO_DATE()转换时间值	125
5.2.1  使用TO_CHAR()将时间值转换为字符串	125
5.2.2  使用TO_DATE()将字符串转换为时间值	130
5.3  设置默认的日期格式	132
5.4  Oracle对两位年份的处理	133
5.4.1  使用YY格式	133
5.4.2  使用RR格式	134
5.5  使用时间值函数	135
5.5.1  ADD_MONTHS()	136
5.5.2  LAST_DAY()	137
5.5.3  MONTHS_BETWEEN()	137
5.5.4  NEXT_DAY()	138
5.5.5  ROUND()	138
5.5.6  SYSDATE	139
5.5.7  TRUNC()	139
5.6  使用时区	140
5.6.1  与时区有关的函数	140
5.6.2  数据库时区和会话时区	141
5.6.3  获取时区的时差	142
5.6.4  获取时区名	142
5.6.5  将时间值从一个时区转换为另一个时区	143
5.7  使用时间戳	143
5.7.1  使用时间戳类型	143
5.7.2  与时间戳有关的函数	147
5.8  使用时间间隔	152
5.8.1  使用INTERVAL YEAR TO MONTH类型	153
5.8.2  使用INTERVAL DAY TO SECOND类型	155
5.8.3  与时间间隔有关的函数	157
5.9  小结	158
第6章  子查询	159
6.1  子查询的类型	159
6.2  编写单行子查询	160
6.2.1  在WHERE子句中使用子查询	160
6.2.2  使用其他单行操作符	161
6.2.3  在HAVING子句中使用子查询	161
6.2.4  在FROM子句中使用子查询(内联视图)	162
6.2.5  可能碰到的错误	163
6.3  编写多行子查询	164
6.3.1  在多行子查询中使用IN操作符	165
6.3.2  在多行子查询中使用ANY操作符	165
6.3.3  在多行子查询中使用ALL操作符	166
6.4  编写多列子查询	166
6.5  编写关联子查询	167
6.5.1  关联子查询的例子	167
6.5.2  在关联子查询中使用EXISTS和NOT EXISTS	168
6.6  编写嵌套子查询	170
6.7  编写包含子查询的UPDATE和DELETE语句	172
6.7.1  编写包含子查询的UPDATE语句	172
6.7.2  编写包含子查询的DELETE语句	172
6.8  使用子查询因子化	173
6.9  小结	174
第7章  高级查询	175
7.1  使用集合操作符	176
7.1.1  示例表	176
7.1.2  使用UNION ALL操作符	177
7.1.3  使用UNION操作符	178
7.1.4  使用INTERSECT操作符	179
7.1.5  使用MINUS操作符	179
7.1.6  组合使用集合操作符	180
7.2  使用TRANSLATE()函数	182
7.3  使用DECODE()函数	183
7.4  使用CASE表达式	185
7.4.1  使用简单CASE表达式	185
7.4.2  使用搜索CASE表达式	186
7.5  层次化查询	187
7.5.1  示例数据	187
7.5.2  使用CONNECT BY和START WITH子句	189
7.5.3  使用伪列LEVEL	190
7.5.4  格式化层次化查询的结果	190
7.5.5  从非根节点开始遍历191
7.5.6  在START WITH子句中使用子查询	192
7.5.7  从下向上遍历树	192
7.5.8  从层次化查询中删除节点和分支	193
7.5.9  在层次化查询中加入其他条件	194
7.5.10  使用递归子查询因子化查询分层数据	194
7.6  使用ROLLUP和CUBE子句	198
7.6.1  示例表	199
7.6.2  使用ROLLUP子句	200
7.6.3  使用CUBE子句	203
7.6.4  使用GROUPING()函数	204
7.6.5  使用GROUPING SETS子句	207
7.6.6  使用GROUPING_ID()函数	207
7.6.7  在GROUP BY子句中多次使用某个列	209
7.6.8  使用GROUP_ID()函数	210
7.7  使用CROSS APPLY和OUTER APPLY	211
7.7.1  CROSS APPLY	212
7.7.2  OUTER APPLY	212
7.8  使用LATERAL	213
7.9  小结	214
第8章  分析数据	215
8.1  使用分析函数	215
8.1.1  示例表	216
8.1.2  使用评级函数	217
8.1.3  使用反百分位函数	223
8.1.4  使用窗口函数	224
8.1.5  使用报表函数	230
8.1.6  使用LAG()和LEAD()函数	233
8.1.7  使用FIRST和LAST函数	234
8.1.8  使用线性回归函数	234
8.1.9  使用假想评级与分布函数	235
8.2  使用MODEL子句	236
8.2.1  MODEL子句示例	236
8.2.2  用位置标记和符号标记访问数据单元	238
8.2.3  用BETWEEN和AND返回特定范围内的数据单元	239
8.2.4  用ANY和IS ANY访问所有的数据单元	239
8.2.5  用CURRENTV()函数获取某个维度的当前值	239
8.2.6  用FOR循环访问数据单元	240
8.2.7  处理空值和缺失值	242
8.2.8  更新已有的单元	244
8.3  使用PIVOT和UNPIVOT子句	245
8.3.1  PIVOT子句的简单示例	245
8.3.2  转换多个列	246
8.3.3  在转换中使用多个聚合函数	247
8.3.4  使用UNPIVOT子句	248
8.4  执行Top-N查询	249
8.4.1  使用FETCH FIRST子句	250
8.4.2  使用OFFSET子句	250
8.4.3  使用PERCENT子句	251
8.4.4  使用WITH TIES子句	252
8.5  在数据中发现模式	252
8.5.1  在all_sales2表中发现V形数据模式	253
8.5.2  在all_sales3表中发现W型数据模式	256
8.5.3  在all_sales3表中发现V形数据模式	257
8.6  小结	258
第9章  修改表的内容	259
9.1  使用INSERT语句添加行	260
9.1.1  省略列的列表	261
9.1.2  为列指定空值	261
9.1.3  在列值中使用单引号和双引号	261
9.1.4  从一个表向另一个表复制行	262
9.2  使用UPDATE语句修改行	262
9.3  使用RETURNING子句返回聚合函数的计算结果	263
9.4  使用DELETE语句删除行	264
9.5  数据库的完整性	264
9.5.1  主键约束	264
9.5.2  外键约束	265
9.6  使用默认值	266
9.7  使用MERGE合并行	267
9.8  数据库事务	269
9.8.1  事务的提交和回滚	269
9.8.2  事务的开始与结束	270
9.8.3  保存点	271
9.8.4  事务的ACID特性	272
9.8.5  并发事务	273
9.8.6  事务锁	274
9.8.7  事务隔离级别	274
9.8.8  SERIALIZABLE事务隔离级别的一个例子	275
9.9  查询闪回	276
9.9.1  授权使用闪回	276
9.9.2  时间查询闪回	277
9.9.3  SCN查询闪回	278
9.10  小结	280
第10章  用户、特权和角色	281
10.1  用户	282
10.1.1  创建用户	282
10.1.2  修改用户密码	283
10.1.3  删除用户	283
10.2  系统特权	284
10.2.1  向用户授予系统特权	284
10.2.2  检查授予用户的系统特权	285
10.2.3  使用系统特权	286
10.2.4  撤消用户的系统特权	286
10.3  对象特权	287
10.3.1  向用户授予对象特权	287
10.3.2  检查已授予的对象特权	288
10.3.3  检查已接受的对象特权	289
10.3.4  使用对象特权	291
10.3.5  创建同义词	291
10.3.6  创建公共同义词	292
10.3.7  撤消用户的对象特权	293
10.4  角色	293
10.4.1  创建角色	293
10.4.2  为角色授权	294
10.4.3  将角色授予用户	294
10.4.4  检查授予用户的角色	294
10.4.5  检查授予角色的系统特权	296
10.4.6  检查授予角色的对象特权	296
10.4.7  使用已授予角色的特权	298
10.4.8  启用和禁用角色	299
10.4.9  撤消角色	300
10.4.10  从角色中撤消特权	300
10.4.11  删除角色	300
10.5  审计	300
10.5.1  执行审计需要的特权	300
10.5.2  审计示例	301
10.5.3  审计跟踪视图	302
10.6  小结	303
第11章  创建表、序列、索引和视图	305
11.1  表	305
11.1.1  创建表	306
11.1.2  获得有关表的信息	307
11.1.3  获得表中列的信息	308
11.1.4  修改表	308
11.1.5  重命名表	317
11.1.6  向表中添加注释	317
11.1.7  截断表	318
11.1.8  删除表	318
11.1.9  使用BINARY_FLOAT和BINARY_ DOUBLE数据类型	319
11.1.10  使用DEFAULT ON NULL列	320
11.1.11  在表中使用可见及不可见列	321
11.2  序列	323
11.2.1  创建序列	324
11.2.2  获取有关序列的信息	325
11.2.3  使用序列	326
11.2.4  使用序列填充主键	328
11.2.5  使用序列指定默认列值	329
11.2.6  使用标识列	329
11.2.7  修改序列	330
11.2.8  删除序列	330
11.3  索引	331
11.3.1  创建B-树索引	331
11.3.2  创建基于函数的索引	332
11.3.3  获取有关索引的信息	333
11.3.4  获取列索引的信息	333
11.3.5  修改索引	334
11.3.6  删除索引	334
11.3.7  创建位图索引	334
11.4  视图	335
11.4.1  创建并使用视图	336
11.4.2  修改视图	343
11.4.3  删除视图	343
11.4.4  在视图中使用可见列和不可见列	343
11.5  闪回数据归档	344
11.6  小结	347
第12章  PL/SQL编程简介	349
12.1  块结构	350
12.2  变量和类型	351
12.3  条件逻辑	352
12.4  循环	352
12.4.1  简单循环	353
12.4.2  WHILE循环	354
12.4.3  FOR循环	354
12.5  游标	355
12.5.1  步骤(1)：声明用于保存列值的变量	355
12.5.2  步骤(2)：声明游标	355
12.5.3  步骤(3)：打开游标	356
12.5.4  步骤(4)：从游标中取得行	356
12.5.5  步骤(5)：关闭游标	357
12.5.6  完整的示例：product_cursor.sql	357
12.5.7  游标与FOR循环	358
12.5.8  OPEN-FOR语句	359
12.5.9  无约束游标	361
12.6  异常	362
12.6.1  ZERO_DIVIDE异常	364
12.6.2  DUP_VAL_ON_INDEX异常	365
12.6.3  INVALID_NUMBER异常	365
12.6.4  OTHERS异常	365
12.7  过程	366
12.7.1  创建过程	366
12.7.2  调用过程	368
12.7.3  获取有关过程的信息	369
12.7.4  删除过程	370
12.7.5  查看过程中的错误	370
12.8  函数	371
12.8.1  创建函数	371
12.8.2  调用函数	372
12.8.3  获取有关函数的信息	373
12.8.4  删除函数	373
12.9  包	373
12.9.1  创建包的规范	373
12.9.2  创建包体	374
12.9.3  调用包中的函数和过程	375
12.9.4  获取有关包中函数和过程的信息	376
12.9.5  删除包	376
12.10  触发器	377
12.10.1  触发器启动的时机	377
12.10.2  设置示例触发器	377
12.10.3  创建触发器	377
12.10.4  启动触发器	379
12.10.5  获取有关触发器的信息	380
12.10.6  禁用和启用触发器	382
12.10.7  删除触发器	382
12.11  其他PL/SQL特性	382
12.11.1  SIMPLE_INTEGER类型	382
12.11.2  在PL/SQL中使用序列	383
12.11.3  PL/SQL本地机器代码 生成	384
12.11.4  WITH子句	385
12.12  小结	386
第13章  数据库对象	387
13.1  对象简介	387
13.2  创建对象类型	388
13.3  使用DESCRIBE获取有关对象类型的信息	390
13.4  在数据库表中使用对象类型	391
13.4.1  列对象	391
13.4.2  对象表	394
13.4.3  对象标识符和对象引用	397
13.4.4  比较对象值	399
13.5  在PL/SQL中使用对象	402
13.5.1  get_products()函数	403
13.5.2  display_product()过程	403
13.5.3  insert_product()过程	404
13.5.4  update_product_price()过程	405
13.5.5  get_product()函数	406
13.5.6  update_product()过程	406
13.5.7  get_product_ref()函数	407
13.5.8  delete_product()过程	408
13.5.9  product_lifecycle()过程	408
13.5.10  product_lifecycle2()过程	409
13.6  类型继承	410
13.6.1  运行脚本以创建第2个对象模式	411
13.6.2  继承属性	411
13.7  用子类型对象代替超类型对象	413
13.7.1  SQL例子	413
13.7.2  PL/SQL示例	414
13.7.3  NOT SUBSTITUTABLE对象	415
13.8  其他有用的对象函数	416
13.8.1  IS OF()函数	416
13.8.2  TREAT()函数	419
13.8.3  SYS_TYPEID()函数	423
13.9  NOT INSTANTIABLE对象类型	424
13.10  用户自定义的构造函数	425
13.11  重载方法	429
13.12  通用调用	430
13.12.1  运行脚本以创建第3个对象模式	431
13.12.2  继承属性	431
13.13  小结	432
第14章  集合	435
14.1  集合简介	435
14.2  创建集合类型	436
14.2.1  创建变长数组类型	436
14.2.2  创建嵌套表类型	437
14.3  使用集合类型定义表列	437
14.3.1  使用变长数组类型定义表列	437
14.3.2  使用嵌套表类型定义表列	438
14.4　获取集合信息	438
14.4.1  获取变长数组信息	438
14.4.2  获得嵌套表信息	439
14.5  填充集合元素	441
14.5.1  填充变长数组元素	441
14.5.2  填充嵌套表元素	441
14.6  检索集合元素	442
14.6.1  检索变长数组元素	442
14.6.2  检索嵌套表元素	443
14.7  使用TABLE()函数将集合视为一系列行	443
14.7.1  将TABLE()函数应用于变长数组	444
14.7.2  将TABLE()函数应用于嵌套表	445
14.8  更改集合元素	445
14.8.1  更改变长数组元素	445
14.8.2  更改嵌套表元素	446
14.9  使用映射方法比较嵌套表的内容	447
14.10  使用CAST()函数将集合从一种类型转换为另一种类型	449
14.10.1  使用CAST()函数将变长数组转换为嵌套表	449
14.10.2  使用CAST()函数将嵌套表转换为变长数组	450
14.11  在PL/SQL中使用集合	451
14.11.1  操作变长数组	451
14.11.2  操作嵌套表	453
14.11.3  PL/SQL集合方法	455
14.12  创建和使用多级集合	464
14.12.1  运行脚本创建第二个集合模式	464
14.12.2  使用多级集合	464
14.13  Oracle Database 10g对集合的增强	467
14.13.1  运行脚本以创建第三个集合模式	467
14.13.2  关联数组	467
14.13.3  更改元素类型的大小	468
14.13.4  增加变长数组中元素的数目	469
14.13.5  在临时表中使用变长数组	469
14.13.6  为嵌套表的存储表使用不同的表空间	469
14.13.7  嵌套表对ANSI的支持	470
14.14  小结	478
第15章  大对象	479
15.1  大对象(LOB)简介	480
15.2  示例文件	480
15.3  理解大对象类型	480
15.4  创建包含大对象的表	481
15.5  在SQL中使用大对象	483
15.5.1  使用CLOB和BLOB对象	483
15.5.2  使用BFILE对象	485
15.6  在PL/SQL中使用大对象	486
15.6.1  APPEND()方法	489
15.6.2  CLOSE()方法	489
15.6.3  COMPARE()方法	489
15.6.4  COPY()方法	491
15.6.5  CREATETEMPORARY()方法	492
15.6.6  ERASE()方法	492
15.6.7  FILECLOSE()方法	493
15.6.8  FILECLOSEALL()方法	493
15.6.9  FILEEXISTS()方法	494
15.6.10  FILEGETNAME()方法	494
15.6.11  FILEISOPEN()方法	495
15.6.12  FILEOPEN()方法	495
15.6.13  FREETEMPORARY()方法	496
15.6.14  GETCHUNKSIZE()方法	496
15.6.15  GETLENGTH()方法	497
15.6.16  GET_STORAGE_LIMIT()方法	497
15.6.17  INSTR()方法	498
15.6.18  ISOPEN()方法	499
15.6.19  ISTEMPORARY()方法	499
15.6.20  LOADFROMFILE()方法	500
15.6.21  LOADBLOBFROMFILE()方法	501
15.6.22  LOADCLOBFROMFILE()方法	502
15.6.23  OPEN()方法	503
15.6.24  READ()方法	503
15.6.25  SUBSTR()方法	504
15.6.26  TRIM()方法	505
15.6.27  WRITE()方法	506
15.6.28  WRITEAPPEND()方法	507
15.6.29  PL/SQL示例过程	507
15.7  LONG和LONG RAW类型	524
15.7.1  示例表	524
15.7.2  向LONG和LONG RAW列添加数据	525
15.7.3  将LONG和LONG RAW列转换为LOB	525
15.8  Oracle Database 10g对大对象的增强	526
15.8.1  CLOB和NCLOB对象之间的隐式转换	527
15.8.2  在触发器中使用LOB时:new属性的用法	528
15.9  Oracle Database 11g对大对象的增强	528
15.9.1  加密LOB数据	528
15.9.2  压缩LOB数据	532
15.9.3  删除LOB重复数据	533
15.10  Oracle Database 12c对大对象的增强	533
15.11  小结	534
第16章  SQL优化	535
16.1  SQL优化简介	535
16.2  使用WHERE子句过滤行	536
16.3  使用表连接而不是多个查询	536
16.4  执行连接时使用完全限定的列引用	537
16.5  使用CASE表达式而不是多个查询	538
16.6  添加表索引	539
16.6.1  何时创建B-树索引	539
16.6.2  何时创建位图索引	540
16.7  使用WHERE而不是HAVING	540
16.8  使用UNION ALL而不是UNION	541
16.9  使用EXISTS而不是IN	542
16.10  使用EXISTS而不是DISTINCT	543
16.11  使用GROUPING SETS而不是CUBE	543
16.12  使用绑定变量	543
16.12.1  不相同的SQL语句	544
16.12.2  使用绑定变量定义相同的SQL语句	544
16.12.3  列出和输出绑定变量	545
16.12.4  使用绑定变量存储PL/SQL函数的返回值	545
16.12.5  使用绑定变量存储来自REFCURSOR的返回值	546
16.13  比较执行查询的成本	546
16.13.1  检查执行计划	547
16.13.2  比较执行计划	552
16.14  为优化器传递提示	553
16.15  其他优化工具	554
16.15.1  Oracle Enterprise Manager	555
16.15.2  Automatic Database Diagnostic Monitor	555
16.16  小结	556
第17章  XML和Oracle数据库	557
17.1  XML简介	557
17.2  从关系数据生成XML	558
17.2.1  XMLELEMENT()函数	558
17.2.2  XMLATTRIBUTES()函数	561
17.2.3  XMLFOREST()函数	562
17.2.4  XMLAGG()函数	563
17.2.5  XMLCOLATTVAL()函数	565
17.2.6  XMLCONCAT()函数	566
17.2.7  XMLPARSE()函数	566
17.2.8  XMLPI()函数	567
17.2.9  XMLCOMMENT()函数	567
17.2.10  XMLSEQUENCE()函数	568
17.2.11  XMLSERIALIZE()函数	569
17.2.12  PL/SQL示例：将XML数据写入文件	569
17.2.13  XMLQUERY()函数	571
17.3  将XML保存到数据库中	575
17.3.1  示例XML文件	575
17.3.2  创建示例XML模式	576
17.3.3  从示例XML模式检索信息	577
17.3.4  更新示例XML模式中的信息	582
17.4  小结	585
附录  Oracle数据类型	587
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Oracle Database 12c SQL & PLSQL编程（第3版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 9i UNIX 管理手册
第一部分
UNIX服务器的基础

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 9i UNIX 管理手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle DBA实战攻略
推荐序一
推荐序二
推荐序三
前言
第1章　数据库故障的诊断方法与分析思路
1.1　数据库安装类故障
1.1.1　安装数据库时容易犯的错误
1.1.2　无法启动安装界面的解决方法
1.1.3　安装数据库的最佳实践
1.2　数据库连接类故障
1.2.1　检查是否由网络故障引起
1.2.2　检查是否由主机资源引起
1.2.3　检查是否由监听故障引起
1.2.4　检查是否由数据库故障引起
1.3　数据库HANG类故障
1.3.1　数据库全局性HANG的处理过程
1.3.2　数据库局部性HANG处理过程
1.4　数据库性能类故障
1.4.1　性能类故障的处理思路
1.4.2　怎样快速定位资源持有者
1.5　数据误操作类故障的处理思路
1.6　数据库坏块类故障
1.6.1　数据库对象坏块的处理思路
1.6.2　SYSTEMUNDO表空间损坏的处理思路
1.6.3　数据库在线日志文件损坏的处理思路
1.6.4　控制文件损坏的处理思路
1.7　总结
第2章　监听的配置和管理
2.1　简析监听连接示意图
2.2　深入解析监听配置文件
2.2.1　一个典型的监听配置模板
2.2.2　监听的常用命令
2.2.3　配置监听别名
2.2.4　配置文件中的关键字解析
2.3　tnsping命令的作用和适用场景
2.4　监听的静态注册
2.4.1　静态注册的配置内容
2.4.2　监听状态中服务名和实例名
2.5　监听的动态注册
2.5.1　动态注册的内容
2.5.2　监听状态中的服务名和实例名
2.5.3　监听动态注册时的实例状态
2.5.4　动态注册的时间点
2.5.5　实例不能动态注册的处理思路
2.5.6　跟踪实例的动态注册过程
2.6　巧用SSH的端口转发功能
2.7　跟踪监听的工作过程
2.8　监听的优化思路
2.9　诊断案例之一：RAC 某节点宕机之后的监听故障处理
2.10　诊断案例之二：使用客户端跟踪数据库连接问题
2.11　诊断案例之三：本地sqlplus连接HANG的诊断和分析
第3章　命令行创建和删除数据库
3.1　创建数据库的大概流程
3.2　理解Oracle SID
3.3　检查操作系统环境
3.4　规划数据库文件系统
3.5　创建Oracle日志文件目录和密码文件
3.6　创建Oracle参数文件
3.6.1　设置内存相关参数
3.6.2　设置进程相关参数
3.6.3　设置DB_FILES参数
3.6.4　设置BLOCK_SIZE和DB_FILE_MULTIBLOCK_READ_COUNT参数
3.6.5　设置参数OPEN_CURSORS和SESSION_CACHED_CURSORS
3.6.6　一个典型的数据库参数文件
3.7　创建数据库
3.7.1　数据库的创建脚本
3.7.2　使用OMF特性创建数据库
3.8　创建数据字典
3.8.1　执行catalog.sql
3.8.2　执行catproc.sql
3.8.3　执行utlrp.sql
3.8.4　执行pupbld.sql
3.9　命令行创建RAC数据库
3.10　怎样彻底删除数据库
第4章　SCN和CHECKPOINT
4.1　SCN
4.1.1　SCN的作用
4.1.2　SCN和时间之间的转换
4.2　SCN的最大阈值
4.3　几种常见的SCN
4.3.1　控制文件中的SCN
4.3.2　数据文件头中的SCN
4.3.3　数据块中的SCN
4.3.4　日志文件头中的SCN
4.3.5　事务开始时的SCN
4.3.6　数据库的CURRENT SCN
4.4　CHECKPOINT
4.4.1　CHECKPOINT的作用
4.4.2　全量CHECKPOINT和增量CHECKPOINT
4.4.3　CHECKPOINT和REDOLOG
4.4.4　影响数据库打开速度的因素
4.4.5　CHECKPOINT的优化思路
第5章　数据库的启动与关闭
5.1　实例与数据库
5.2　数据库参数文件
5.2.1　参数文件的类型
5.2.2　参数设置
5.2.3　参数文件之间的类型转换
5.3　简述数据库的启动步骤
5.4　数据库的启动步骤之一：NOMOUNT
5.4.1　连接至空闲实例
5.4.2　读取数据库参数文件
5.4.3　分配SGA内存
5.4.4　派生后台进程
5.4.5　诊断案例：主机内存的使用率达到99%
5.5　数据库的启动步骤之二：MOUNT
5.5.1　读取控制文件
5.5.2　校验控制文件
5.5.3　MOUNT数据库
5.5.4　控制文件损坏的处理思路
5.6　数据库的启动步骤之三：OPEN
5.6.1　详解CRASH RECOVERY
5.6.2　CRASH RECOVERY的故障处理思路
5.6.3　详解CACHE  RECOVERY
5.6.4　CACHE RECOVERY的故障处理思路
5.6.5　详解TX RECOVERY
5.6.6　TX RECOVERY的故障处理思路
5.7　数据库打开HANG的故障处理思路
5.8　如何强制打开数据库
5.9　如何快速关闭数据库
5.9.1　影响数据库关闭速度的因素
5.9.2　数据库无法关闭的诊断方法
第6章　数据库空间的管理与监控
6.1　数据库的空间管理
6.2　表空间管理
6.2.1　区管理和段管理
6.2.2　临时段管理
6.2.3　回滚段管理
6.2.4　表空间的监控脚本
6.2.5　维护表空间的注意事项
6.3　数据文件管理
6.3.1　裸设备头上的保留信息
6.3.2　浅析数据文件的操作系统头
6.3.3　破解数据文件头内容
6.3.4　维护数据文件的注意事项
6.4　在线日志文件管理
6.4.1　破解日志文件头信息
6.4.2　LGWR进程在日志文件中的写进度
6.4.3　维护日志文件的注意事项
6.5　归档日志管理
6.5.1　开启和关闭归档模式步骤
6.5.2　归档日志的命名参数
6.5.3　查看归档日志的几个脚本
6.5.4　使用LOGMNR挖掘归档日志
6.5.5　开启归档模式的注意点
6.5.6　开启归档模式的好处
6.6　闪回日志管理
6.6.1　数据库闪回相关的视图和参数
6.6.2　数据库级别的闪回种类
6.6.3　闪回日志空间的释放
6.7　控制文件管理
6.7.1　常见的控制文件故障处理
6.7.2　维护控制文件的注意事项
6.8　跟踪文件管理
第7章　Oracle性能优化方法论
7.1　数据库性能优化的目标
7.2　建立数据库性能基线
7.3　寻找关键变化
7.4　定位主要影响因素
7.5　检查操作系统资源
7.5.1　查看CPU资源
7.5.2　查看内存资源
7.5.3　查看IO资源
7.5.4　查看网络资源
7.6　常见的数据库性能故障
7.7　数据库性能优化的常规方法
7.7.1　数据库性能调整的基本流程
7.7.2　调整Oracle内存参数
7.7.3　调整数据库在线日志
7.7.4　调整SQL的执行计划
7.7.5　优化对象的IO读取
7.7.6　降低CURSOR解析成本
7.7.7　其他数据库性能调整手段
7.8　利用OWI监控数据库性能
7.8.1　OWI的基本原理
7.8.2　等待事件的含义
7.8.3　监控数据库的手段
7.9　利用时间模型监控数据库性能
第8章　SGA的性能调整和优化思路
8.1　BUFFER CACHE的内部结构
8.1.1　BUFFER HEADER
8.1.2　HASH CHAIN和HASH BUCKET
8.1.3　LATCH:CACHE BUFFERS CHAINS
8.1.4　LATCH:CACHE BUFFERS LRU CHAIN
8.1.5　FREE BUFFER WAITS
8.1.6　BUFFER BUSY WAITS
8.2　BUFFER CACHE的优化指标
8.2.1　BUFFER CACHE的命中率
8.2.2　AWR报告中BUFFER CACHE的一些争用指标
8.2.3　BUFFER CACHE大小的建议值
8.3　BUFFER CACHE的优化思路
8.3.1　BUFFER CACHE内存不足的优化思路
8.3.2　BUFFER CACHE的数据块争用的优化思路
8.3.3　其他有关BUFFER CACHE的优化思路
8.4　SHARED POOL的内部结构
8.4.1　堆管理
8.4.2　CHUNK
8.4.3　FREE LIST
8.4.4　LRU LIST
8.4.5　RESERVED FREE LIST
8.4.6　SHARED POOL的SUB POOL技术
8.4.7　关于SGA内存抖动
8.5　LIBRARY CACHE的内部结构及等待事件
8.5.1　LATCH:LIBRARY CACHE
8.5.2　LIBRARY CACHE LOCKPIN
8.5.3　LIBRARY CACHE OBJECT
8.6　浅析SQL的解析过程
8.6.1　软解析
8.6.2　硬解析
8.6.3　软软解析
8.7　ROW CACHE上的故障诊断方法
8.7.1　ROW CACHE的大小
8.7.2　ROW CACHE上的LATCH
8.7.3　诊断案例：LATCH:ROW CACHE OBJECTS故障处理
8.7.4　建立测试环境重现问题
8.8　SHARED POOL上的优化思路
8.9　LOG BUFFER上的优化思路
8.9.1　LOG BUFFER的大小
8.9.2　浅析REDO WASTAGE
8.9.3　LOG FILE SYNC等待事件
8.9.4　减少日志量的方法
第9章　数据库的物理备份与恢复
9.1　物理备份与恢复的基本概念
9.1.1　物理备份的基本概念
9.1.2　物理备份时的注意点
9.1.3　物理恢复的基本概念
9.1.4　物理恢复时的注意点
9.2　数据库的冷备份和恢复
9.2.1　冷备份数据库步骤
9.2.2　冷备份下的数据库恢复
9.3　数据库手动热备份和恢复
9.3.1　手动热备份
9.3.2　热备份下的数据库恢复
9.4　使用RMAN备份和恢复数据库
9.4.1　RMAN的结构
9.4.2　RMAN占用的内存
9.4.3　RMAN备份与恢复示例
9.5　数据库闪回
9.5.1　数据库闪回和普通闪回点
9.5.2　强制闪回点
第10章　物理Data Guard的配置与管理
10.1　Data Guard的原理
10.1.1　解析Data Guard原理图
10.1.2　Data Guard正常运行的前提
10.2　Data Guard的保护模式
10.2.1　最大保护模式
10.2.2　最大可用模式
10.2.3　最大性能模式
10.2.4　切换保护模式
10.3　配置物理Data Guard
10.3.1　配置Data Guard简要流程
10.3.2　配置Data Guard相关参数
10.4　管理物理Data Guard
10.4.1　配置Data Guard的注意点
10.4.2　管理Data Guard的注意点
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle DBA实战攻略
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>基于Linux平台的Oracle Database 10g管理
第Ⅰ部分 Linux平台上的Oracle概述　第1章 Linux体系结构 　　1.1 操作系统概述　　1.2 Linux概述 　　1.3 Linux用户界面　　1.4 Linux Web服务器实用程序　　1.5 进程与线程　　1.6 设备　　1.7 文件系统　　1.8 本章小结 　第2章 Oracle体系结构 　　2.1 Oracle数据库服务器 　　2.2 Oracle数据库　　2.3 Oracle实例 　　2.4 用户进程　　2.5 Oracle 10g的新特性 　　2.6 网格计算 　　2.7 本章小结 　第3章 事务管理与Oracle模式对象 　　3.1 Oracle的功能概述　　3.2 事务管理概述 　　3.3 Oracle模式对象简介　　3.4 本章小结 第Ⅱ部分 在Linux平台上部署Oracle 10g　第4章 确定Oracle 10g的系统规模 　　4.1 概述　　4.2 系统资源、容量与排队　　4.3 度量 　　4.4 Oracle规模的调整　　4.5 硬件规模的调整　　4.6 RAID磁盘子系统　　4.7 容量规划 　　4.8 本章小结 　第5章 Oracle配置Linux系统 　　5.1 准备工作 　　5.2 安装后的工作　　5.3 安装检查表　　5.4 本章小结 　第6章 在Linux上安装Oracle 10g 　　6.1 准备工作 　　6.2 安装过程　　6.3 后续工作 　　6.4 本章小结 第Ⅲ部分 Linux平台上的超越基本Oracle RAC　第7章 Oracle真正的应用集群 　　7.1 什么是集群？ 　　7.2 真正的应用集群　　7.3 本章小结 　第8章 在Linux上部署Oracle RAC 　　8.1 规划RAC系统 　　8.2 配置Linux 　　8.3 配置Linux的模块/程序　　8.4 配置RAC　　8.5 Oracle 10g RAC的帮助 　　8.6 本章小结 　第9章 在Linux平台上管理Oracle及RAC 　　9.1 配置Linux内核 　　9.2 配置网络 　　9.3 监视Linux　　9.4 Linux操作系统的升级 　　9.5 启动实例 　　9.6 Oracle Database 10g与CSSD 　　9.7 用户认证 　　9.8 添加用户账号 　　9.9 本章小结 　第10章 在Linux平台上调整Oracle和RAC 第Ⅳ部分 在Linux平台上管理和调整Oracle 10g数据库　第11章 备份与恢复 　第12章 还原 　第13章 Linux平台上的Oracle Data Guard 　第14章 Linux平台上Oracle数据库的高级复制　第15章 为Linux和Oracle配置硬件 　第16章 调整SQL　第17章 索引与分区第Ⅴ部分 Linux平台上的Oracle产品　第18章 Linux平台上的OracleApplication Server 10g　第19章 Linux平台上的Oracle E-Business Suite
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>基于Linux平台的Oracle Database 10g管理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle精髓:Oracle9i,Oracle8i&Oracle8(第二版)
前言
第一章 Oracle简介
第二章 Oracle体系结构
第三章 安装和运行Oracle
第四章 数据结构
第五章 Oracle管理
第六章 Oracle性能
第七章 多用户并发性
第八章 Oracle和事务处理
第九章 Oracle和数据仓库
第十章 Oracle和高可用性
第十一章 Oracle和硬件体系结构
……
附录一 本书中增加的有关Oracle9i的内容
附录二 附加资源
词汇表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle精髓:Oracle9i,Oracle8i&Oracle8(第二版)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>21天学通Oracle
第一篇  Oracle管理配置　第1章  Oracle安装配置(教学视频:10分钟)　第2章  Oracle常用工具(教学视频:7分钟)　第3章  SQL Plus和PL/SQL(教学视频:11分钟)第二篇  Oracle数据库对象　第4章  Oralce数据库(教学视频:15分钟)　第5章  Oracle数据表对象(教学视频:42分钟)　第6章  约束(教学视频:43分钟)　第7章  视图(教学视频:50分钟)　第8章  函数与存储过程(教学视频:48分钟)　第9章  游标(教学视频:36分钟)　第10章  触发器(教学视频:58分钟)　第11章  序列(教学视频:28分钟)　第12章  用户角色与权限控制(教学视频:45分钟)第三篇  Oracle中的SQL　第13章  Oracle数据类型(教学视频:21分钟)　第14章  Oracle中的函数与表达式(教学视频:111分钟)　第15章  Oracle中的控制语句(教学视频:16分钟)　第16章  SQL查询(教学视频:55分钟)　第17章  SQL更新数据(教学视频:34分钟)第四篇  Oracle编程高级应用　第18章  数据库速度优化与数据完整性(教学视频:32分钟)　第19章  数据一致性与事务管理(教学视频:46分钟)　第20章  并发控制(教学视频:35分钟)　第21章  Oracle中的正则表达式(教学视频:29分钟)第五篇  Oracle与编程语言综合使用实例　第22章  Oracle在Java开发中的应用(教学视频:38分钟)　第23章  Oracle在C#开发中的应用(教学视频:12分钟)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>21天学通Oracle
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库应用开发基础
第1章 数据库基础知识
第2章 SQL语言基础
第3章 基本SQL语句
第4章 SQL*Plus
第5章 PL/SQL程序设计
第6章 存储子程序与触发器
第7章 数据库对象――包
第8章 实用工具包
第9章 对象关系数据库
第10章 分布式数据库系统
第11章 事务处理与并发控制
第12章 LOB数据类型
第13章 大型数据库应用设计与性能改善
第14章 数据库应用实例
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库应用开发基础
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle SQL必备参考
序
前言
第一章 SQL元素
词汇习惯
SQL命名
架构对象
数据类型
数据转换
关系操作符
SQL语句的结构
SQL语句
第二章 数据定义语句
按任务列出的SQL DLL语句
SQL语句的语法
第三章 数据操纵和控制语句
根据任务说明SQL DML和控制语句
SQL语句语法
第四章 公共SQL元素
第五章 SQL函数
聚集函数
数字函数
字符函数
日期函数
转换函数
其他函数
第六章 SQL*Plus
命令行语法
SQL*Plus编辑命令
规定SQL*Plus输出的格式
各种各样的SQL*Plus命令
SQL*Plus变量和相关命令
SQL*Plus系统变量
第七章 PL/SQL
PL/SQL结构
块头
声明部分
执行部分
异常部分
过程和包
触发器
第八章 SQL语句调试
使用EXPLAIN PLAN
使用Oracle的SQL 跟踪工具
SQL*Plus调试助手
改进查询性能
附录 SQL资源
词汇表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle SQL必备参考
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle RAC核心技术详解
序言一
序言二
前言
第一部分集群管理软件
第1章　Oracle 集群技术介绍2
1.1　集群技术简介2
1.1.1　高可用集群2
1.1.2　负载均衡集群3
1.1.3高性能计算集群3
1.1.4　share-nothing结构4
1.1.5　share-everything结构4
1.2　Oracle集群技术简介5
1.2.1　Oracle RAC 历史5
1.2.2　小结9
总结10
第2章　安装Oracle 集群11
2.1　安装集群管理软件11
2.1.1　安装前准备11
2.1.2　安装软件12
2.1.3　配置集群13
2.2　安装集群管理软件中的重要部分13
2.2.1　角色任务分离14
2.2.2　中央目录15
2.2.3　cluvfy 工具17
2.2.4　root.sh 脚本20
总结29
第3章　11gR2 集群新增组件30
3.1　OHAS31
3.1.1　集群启动方式31
3.1.2　资源管理方式39
3.1.3　ohasd 管理的资源47
3.2　案例分析55
3.2.1　由于丢失OLR 导致的节点无法启动55法启动56
总结58
第4章　11gR2 集群新增的集群守护进程59
4.1　mdns 59
4.1.1　mdnsd.log60
4.1.2　gpnpd.log61
4.1.3　ohasd.log62
4.2　gpnp63
4.2.1　gpnp wallet63
4.2.2gpnp profile63
4.2.3　gpnpd 守护进程65
4.2.4　gpnpd.log 实例66
4.3　gipc68
4.3.1　gipc 的概念和功能68
4.3.2　gipcd.log 实例69
4.4　DiskMON73
4.5　CTSS73
4.6　cssdagent 和 cssdmonitor77
4.7　案例分析78
4.7.1　由于同一个子网中存在同名集群导致的gpnp 无法启动78
4.7.2　由gipc进程导致的节点无法启动81
总结87
第5章　CSS部分88
5.1　CSS 组件的启动顺序88
5.1.1　ocssd 启动顺序88
5.1.2　cssd 启动日志分析89
5.2　集群心跳机制98
5.2.1　网络心跳98
5.2.2　磁盘心跳100
5.2.3　本地心跳102
5.2.4　集群重新配置场景104
5.2.5　术语和参数简介111
5.3　CSS组管理113
5.3.1　ASM 实例关闭114
5.3.2　ASM 磁盘组被卸载118
5.4　11g CSS新特性120
5.4.1　成员终止升级120
5.4.2 Rebootless Restart124
5.5　案例分析127
5.5.1　 AIX 平台上著名的bug 13940331 导致的节点重启问题127
5.5.2　典型的由于丢失网络心跳导致的集群脑裂134
5.5.3　由于OS 性能问题导致的oprocd 进程重启节点138
5.5.4　 由于OS 层面的套接字参数设置导致的ORA-29701 错误141
总结145
第6章　CRS 部分146
6.1　CRSD 功能介绍146
6.1.1　10gR2 版本146
6.1.2　11gR2版本172
6.2　案例分析192
6.2.1　由于CVU导致的VIP 无法漂移192
6.2.2　由于著名的bug10058182导致的CRSD挂起195
6.2.3　由于CRSD工作方式导致的数据库实例无法被关闭197
总结203
第7章　Oracle集群管理软件的启动顺序204
7.1　OHAS 层面205
7.2　CSS层面210
7.3　CRSD层面216
7.4　GI的关闭顺序223
7.5　集群的套接字文件和网络验证224
7.5.1　套接字文件225
7.5.2　网络验证226
7.5.3　常用的网络检查命令和输出226
总结230
第8章　集群诊断工具概述231
8.1　diagcollection.pl231
8.1.1　10gR2和11gR1 版本231
8.1.2　11gR2版本232
8.2　orachk233
8.2.1　简介233
8.2.2　安装并运行234
8.2.3　升级检查236
8.2.4　检查报告237
8.3　TFA239
8.3.1　简介239
8.3.2　安装和使用239
8.3.3　手动运行TFA242
8.4　OSWbb242
8.4.1　安装和卸载OSWbb243
8.4.2　配置、运行和停止OSWbb243
8.4.3　OSWbb搜集的信息244
总结246
第9章　ASM基础247
9.1　ASM的功能和架构248
9.1.1　ASM功能248
9.1.2　磁盘组248
9.2　ASM实例254
9.2.1　初始化参数文件254
9.2.2　内存结构255
9.2.3　后台进程256
9.2.4　ASM实例启动顺序256
9.3　数据库和ASM实例通信258
9.3.1　基本概念258
9.3.2　后台进程259
9.3.3　基本操作261
9.4　OCR/VF和ASM磁盘组261
9.4.1　存放方式262
9.4.2　Quorum disk264
9.5　案例分析265
总结270
第二部分　RAC数据库软件
第10章　解析内存融合技术272
10.1　RAC和单实例数据库的区别272
10.1.1　内存结构273
10.1.2　后台进程274
10.1.3　物理数据库275
10.1.4　小结278
10.2　内存融合概念278
10.2.1　全局资源目录278
10.2.2　资源和锁280
10.2.3　主节点284
10.2.4　消息机制286
10.3　内存融合的过程289
10.3.1　非PCM资源的访问过程289
10.3.2　PCM资源的访问过程294
10.4　SCN的传播与log file sync310
10.4.1　SCN的传播方式310
10.4.2　log file sync 等待事件316
10.5　DRM和read mostly317
10.5.1　DRM的基本概念317
10.5.2　DRM过程319
10.5.3　DRM 过程示例320
10.5.4　read mostly325
10.6　案例分析326
10.6.1　DRM性能问题导致的数据库实例崩溃326
10.6.2　内存问题导致的数据库实例崩溃329
总结332
第11章　 RAC 数据库的实例管理333
11.1　节点管理333
11.1.1　基本概念333
11.1.2　节点列表334
11.1.3　实例启动和关闭334
11.2　CGS340
11.2.1　实例之间的心跳机制340
11.2.2　数据库的重新配置343
11.2.3　重新配置的类型348
11.2.4　数据库层面的脑裂349
11.3　实例恢复349
11.3.1　阶段1350
11.3.2　阶段2352
11.3.3　阶段3353
11.3.4　lazy remaster353
11.3.5　实例恢复示例353
11.4　LMHB354
11.4.1　LMHB 工作机制354
11.4.2　LMHB终止实例示例355
11.5　案例分析360
总结361
第12章　RAC 性能调优362
12.1　基本概念362
12.1.1　RAC相关的统计信息362
12.1.2　AWR报告中RAC相关的信息364
12.1.3　RAC 相关的等待事件374
12.2　RAC数据库的常见性能问题382
12.2.1　序列导致的性能问题382
12.2.2　索引块争用导致的性能问题388
12.2.3　过多物理读导致的性能问题392
12.2.4　缓存尺寸导致的性能问题395
12.3　11gR2新特性之HM399
12.3.1　基本概念399
12.3.2　HM工作方式399
12.3.3　示例日志输出403
12.4　案例分析406
12.4.1　由于存储问题导致的数据库性能下降406
12.4.2　由于连接风暴导致的数据库性能问题409
总结414
第13章　RAC中的连接管理和工作负载管理415
13.1　数据库连接的基础知识415
13.1.1　连接建立的过程415
13.1.2　配置文件416
13.1.3　数据库参数418
13.1.4　RAC数据库的连接420
13.2　负载均衡430
13.2.1　客户端负载均衡430
13.2.2　服务器端负载均衡431
13.3　连接的故障切换436
13.3.1　连接时故障切换436
13.3.2　已存在连接的故障切换437
总结441
附录A　11gR2 集群安装指南442
附录B　11gR2 集群升级指南475
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle RAC核心技术详解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 高性能 SQL 调整
第一部分 背景知识第1章 SQL

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 高性能 SQL 调整
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle管理之道
第Ⅰ部分  基本架构运行方式
第1章  Oracle数据库架构概述	3
1.1  Oracle的内存结构	4
1.2  Oracle的实体结构	8
1.2.1  物理存储结构	8
1.2.2  逻辑存储结构	12
本章小结	15
第2章  Oracle实例	17
2.1  系统全局区	18
2.1.1  系统全局区的重要概念	20
2.1.2  系统全局区的重要参数	21
2.1.3  系统全局区的重要视图	29
2.2  数据库高速缓冲区	34
2.2.1  数据库高速缓冲区的
重要概念	36
2.2.2  数据库高速缓冲区的
重要参数	38
2.2.3  数据库高速缓冲区的
重要视图	42
2.3  共享池	51
2.3.1  库缓存	51
2.3.2  数据字典高速缓存	53
2.3.3  共享池的重要概念	53
2.3.4  共享池的重要参数	58
2.3.5  共享池的重要视图	60
2.4  重做日志缓冲区	69
2.4.1  重做日志缓冲区的
重要概念	70
2.4.2  重做日志缓冲区的
重要参数	75
2.4.3  重做日志缓冲区的
重要视图	76
2.5 大型池	78
2.5.1  大型池的重要概念	78
2.5.2  大型池的重要参数	79
2.5.3  大型池的重要视图	79
2.6  Java池	80
2.6.1  JAVA_POOL_SIZE	80
2.6.2  JAVA_MAX_
SESSIONSPACE_SIZE	80
2.6.3  JAVA_SOFT_
SESSIONSPACE_LIMIT	80
2.7  流池	81
2.8  软件程序代码区	81
2.9  Oracle自动内存管理	82
本章小结	87
第3章  Oracle的PGA与UGA	89
3.1  程序全局区	90
3.1.1  PGA的重要概念	91
3.1.2  PGA的重要参数	93
3.1.3  PGA的重要视图	104
3.2  用户全局区	121
3.2.1  UGA的重要概念	121
3.2.2  UGA的重要视图	122
本章小结	124
第4章  Oracle存储结构	125
4.1  Oracle数据库与磁盘
I/O关系	127
4.1.1  读取Oracle文件	128
4.1.2  写入Oracle文件	131
4.2  文件系统与裸设备	136
4.2.1  文件系统	136
4.2.2  裸设备	139
4.2.3  I/O的种类	148
4.3  数据库存储架构设计概述	149
4.3.1  磁盘阵列	149
4.3.2  存储设备	154
4.4  Oracle数据库I/O问题
解决方案	159
4.4.1  数据文件I/O等待事件
解决方案	162
4.4.2  控制文件I/O等待事件
解决方案	174
4.4.3  联机重做日志文件I/O
等待事件解决方案	175
4.4.4  其他I/O等待事件
解决方案	179
本章小结	180
第5章  Oracle字符集	183
5.1  字符集	184
5.1.1  字符集的基本知识	184
5.1.2  字符集的历史演进	185
5.2  Oracle字符集的基本知识	186
5.2.1  字符集的组成	187
5.2.2  Oracle字符集的
子集与母集	189
5.3  Oracle字符集的设置	191
5.3.1  设置存储用字符集	191
5.3.2  设置显示用字符集	193
5.3.3  如何选择正确的
Oracle字符集	213
5.4  维护Oracle字符集	214
5.4.1  确认字符集的方式	214
5.4.2  修改数据库字符集	217
本章小结	227
第6章  Oracle的事务控制	229
6.1  系统变更号	231
6.2  SCN与检查点的关系	232
6.3  REDO与UNDO的关系
及其作用	235
6.3.1  REDO	235
6.3.2  UNDO	237
6.4  Latch与Lock机制	238
6.4.1  Latch机制	238
6.4.2  Lock机制	247
6.5  Oracle并行控制的事务
隔离等级	258
本章小结	261
第7章  Oracle并行执行	263
7.1  Oracle并行执行架构	264
7.2  Oracle并行执行的种类	269
7.2.1  并行查询作业	269
7.2.2  并行DML作业	269
7.2.3  并行DDL作业	271
7.3  Oracle并行执行的启用与
关闭方式	272
7.3.1  针对对象启用/关闭
Oracle并行执行	272
7.3.2  针对用户会话启用/关闭
Oracle并行执行	274
7.3.3  针对SQL语句启用
Oracle并行执行	275
7.4  Oracle并行执行的相关
设置	276
本章小结	279
第Ⅱ部分  Oracle的高可用性
第8章  Oracle自动存储管理	283
8.1  Oracle自动存储管理基本
概念	284
8.1.1  ASM磁盘组	285
8.1.2  ASM实例	286
8.2  安装与设置ASM存储
管理架构	288
8.2.1  安装前的准备事项	289
8.2.2  安装Grid Infrastructure	294
8.2.3  安装Oracle 11g R2
数据库软件	305
8.2.4  配置ASM架构Oracle
数据库	312
8.3  管理ASM文件与磁盘组	323
8.3.1  管理ASM磁盘组	323
8.3.2  管理ASM文件	338
8.4  维护ASM实例	348
8.4.1  打开与关闭ASM实例	348
8.4.2  ASM初始参数	349
8.4.3  ASM的动态视图	351
8.4.4  使用ASMCMD
管理ASM	357
8.5  使用OEM管理ASM
存储管理架构	359
8.5.1  使用OEM管理ASM
实例	360
8.5.2  使用OEM管理ASM
相关数据库文件	364
本章小结	366
第9章  初探Oracle真正应用集群：
Oracle RAC	367
9.1  Oracle真正应用集群的
基本原理	369
9.1.1  RAC内存结构与
实体结构	370
9.1.2  Oracle集群软件基本
组件与运行原理	374
9.2  创建Oracle RAC数据库	379
9.2.1  RAC安装前的环境设置	379
9.2.2  安装Grid Infrastructure	384
9.2.3  安装Oracle软件	403
9.2.4  配置Oracle RAC数据库	410
9.3  Oracle RAC基本管理
与维护	419
9.3.1  srvctl整合管理指令	419
9.3.2  crs_stat集群监控指令	424
9.3.3  crsctl监控与管理指令	426
9.3.4  Oracle RAC的打开
关闭流程	429
本章小结	433
第10章  Oracle Stream快速
复制功能	435
10.1  Oracle Stream的基本
运行架构	436
10.1.1  捕获	437
10.1.2  数据暂存	439
10.1.3  数据消费	440
10.2  Oracle Stream设置
前的准备	442
10.2.1  设置相关参数	442
10.2.2  确认归档日志模式	444
10.2.3  配置Stream的管理
账号与专用的表空间	446
10.2.4  配置数据库链接	447
10.3  Oracle Stream的基本设置	447
10.3.1  利用Oracle Stream设置
整个数据库复制	448
10.3.2  利用Oracle Stream设置
表空间复制	453
10.3.3  利用Oracle Stream设置
Schema复制	454
10.3.4  利用Oracle Stream设置
表复制	455
10.4  Oracle Stream的相关
管理与维护	456
10.4.1  执行Stream Package的
过程中产生错误信息	456
10.4.2  确认Capture运行情况	459
10.4.3  删除Oracle Stream的
设置	459
本章小结	461
第11章  Oracle管理工具：
OEM Database Control	463
11.1  企业管理器的基本架构	464
11.2  OEM Database Control的
安装方式	466
11.2.1  第一种安装方式	466
11.2.2  第二种安装方式	469
11.2.3  第三种安装方式	470
11.2.4  第四种安装方式	472
11.3  OEM Database Control的
目录结构	475
11.4  利用OEM Database Control
管理数据库	476
11.4.1  OEM Database Control：
首页	478
11.4.2  OEM Database Control：
性能	500
11.4.3  OEM Database Control：
可用性	506
11.4.4  OEM Database Control：
服务器	516
11.4.5  Schema：模式	555
11.5  其他高可用性相关链接	561
11.5.1  SQL工作表	562
11.5.2  EM SQL历史记录	563
11.5.3  警告日志内容	564
11.5.4  警告历史记录	565
本章小结	566
第12章  Oracle整合性管理工具：
OEM Grid Control	567
12.1  OEM Grid Control的
组成架构	568
12.2  OEM Grid Control安装前
须知	569
12.3  安装OEM Grid Control	572
12.3.1  OEM Grid Control
主程序安装	572
12.3.2  OEM Grid Control
主程序升级安装	585
12.3.3  安装Oracle Management
Agent	594
12.4  OEM Grid Control的
目录结构	603
12.5  OEM Grid Control的基本
设置	605
12.5.1  设置角色	607
12.5.2  设置管理员	613
12.5.3  设置通知方法	619
12.5.4  设置中断	620
12.5.5  设置注册密码	624
12.5.6  设置监控模板	625
12.5.7  设置添加的目标	630
12.5.8  设置发送邮件信箱	634
12.6  利用OEM Grid Control
管理目标	640
12.6.1  主机管理	640
12.6.2  中间件管理	646
12.6.3  Web应用程序管理	650
12.7  其他高可用性功能	652
12.7.1  配置	652
12.7.2  工作	654
12.7.3  报表	655
12.8  维护OEM Grid Control	660
12.8.1  维护Oracle
Management Service	660
12.8.2  维护Oracle
Management Agent	665
本章小结	667
第Ⅲ部分  有效的监控与优化
第13章  解析Oracle性能监控
工具与诊断工具	671
13.1  Oracle自动化管理架构	672
13.2  自动工作负荷存储库	674
13.2.1  运行方式	674
13.2.2  管理与维护	675
13.2.3  产生AWR报表	689
13.3  数据库会话历史记录	696
13.3.1  运行方式	696
13.3.2  管理与维护	697
13.3.3  产生ASH报表	704
13.4  统计数据自动收集机制	709
13.4.1  统计数据自动收集的
运行方式	709
13.4.2  管理与维护统计数据
自动收集	712
13.5  自动诊断监控工具	718
13.5.1  运行方式	718
13.5.2  管理与维护	719
本章小结	727
第14章  Oracle性能顾问工具	729
14.1  SQL自动调整优化器概述	731
14.1.1  自动调整优化器	732
14.1.2  SQL语句调优顾问
工具	735
14.1.3  SQL访问顾问工具	750
14.1.4  SQL语句性能分析	755
14.1.5  维护自动SQL调优	762
14.2  内存顾问工具	764
14.2.1  一般内存管理工具	765
14.2.2  SGA自动共享内存
管理	768
14.2.3  自动内存管理	771
14.3  空间指导管理工具	772
14.3.1  自动撤消管理	772
14.3.2  段顾问工具	776
14.4  其他顾问工具	781
14.4.1  自动还原顾问工具	781
14.4.2  最佳可用架构顾问
工具	782
本章小结	783
第15章  Oracle数据库资源管理	785
15.1  数据库资源管理的基本
概念	786
15.2  数据库资源管理的内容	788
15.3  利用OEM操作数据库
资源管理器	789
15.3.1  创建资源使用者组	791
15.3.2  创建资源计划	796
15.4  利用PL/SQL操作数据库
资源管理器	801
本章小结	804
第16章  活用Linux/Unix监控
工具	805
16.1  监控系统整体性使用情况	806
16.1.1  使用top指令工具监控
系统整体运行状态	806
16.1.2  使用vmstat指令工具监控
系统整体运行状态	809
16.2  监控CPU的使用情况	810
16.2.1  使用sar指令工具监控
CPU运行状态	810
16.2.2  使用mpstat指令工具
监控CPU运行状态	813
16.2.3  使用uptime指令工具
监控CPU运行状态	815
16.3  监控磁盘I/O使用情况	815
16.3.1  使用sar指令工具监控
磁盘I/O运行状态	816
16.3.2  使用iostat指令工具监控
磁盘I/O运行状态	817
16.4  监控内存使用情况	819
16.4.1  使用sar指令工具监控
内存运行状态	819
16.4.2  使用free指令工具监控
内存运行状态	819
16.4.3  使用ipcs与/proc/meminfo
确认目前内存分配状态	820
本章小结	821
第Ⅳ部分  安 全 管 理
第17章  数据库安全基本认知	825
17.1  数据库安全分析	826
17.2  数据库安全策略	827
17.3  Oracle数据库基本安全防护
的概念	828
本章小结	833
第18章  Oracle审计机制	835
18.1  标准数据库审计	836
18.1.1  利用OEM设置标准
数据库审计	837
18.1.2  利用PL/SQL设置标准
数据库审计	841
18.2  细粒度审计	849
18.2.1  添加细粒度审计	850
18.2.2  启动细粒度审计	853
18.2.3  删除细粒度审计	853
18.2.4  查询细粒度审计	854
18.3  强制性审计	855
18.4  基于值的审计	857
18.5  数据库管理员审计	859
本章小结	860
第19章  Oracle数据加密机制	861
19.1  Oracle透明数据加密的
运行方式	862
19.2  Oracle透明数据加密	863
19.3  使用Oracle TDE的
注意事项	869
本章小结	872
第20章  Oracle权限管理机制	873
20.1  一般标准权限管理方式	874
20.1.1  视图	874
20.1.2  角色	874
20.2  细粒度访问控制	879
20.2.1  虚拟专用数据库
的管理	879
20.2.2  虚拟专用数据库
的管理	889
本章小结	892
附录A  安装Oracle 11g R2
数据库	893
附录B  安装Oracle WebLogic	911
附录C  安装OEM Grid
Control 11g	921
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle管理之道
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle DBA工作笔记
第1篇 数据库运维篇
第１章 数据库安装配置
1.1 安装前的准备 1
1.2 安装数据库软件 5
1.2.1 方法1：OUI安装 6
1.2.2 方法2：静默安装 8
1.2.3 方法3：克隆安装 11
1.2.4 诊断案例：克隆安装后无法登录的问题 13
1.3 创建/删除数据库 16
1.3.1 方法1：DBCA图形建库 16
1.3.2 方法2：手工建库 18
1.3.3 方法3：DBCA静默建库 22
1.3.4 方法4：OMF建库 22
1.3.5 诊断案例：create database语句在10g、11g中的不同 23
1.3.6 创建数据库后的补充工作 26
1.3.7 删除数据库的步骤 29
1.4 关于SYSDBA、SYSOPER、DBA的区别和联系 29
第２章 常用工具和问题分析
2.1 SQL*Plus使用及常见问题 34
2.1.1 SQL*Plus使用细则 34
2.1.2 SQL*Plus无法启动的常见原因 41
特殊问题：乱码导致的SQL*Plus无法启动的问题 43
特殊问题：使用strace诊断奇怪的SQL*Plus登录问题 44
2.2 解析exp/imp及常见问题 47
2.2.1 exp/imp使用场景及示例 47
2.2.2 exp/imp使用常见问题 50
诊断案例：生产系统exp无法使用的紧急诊断和修复 55
诊断案例：外部表的导入导出问题 57
诊断案例：IMP-00013 问题及解决方法 58
诊断案例：使用strace分析exp中buffer设置的奇怪问题 60
经验分享：你可能不了解的dump文件 63
2.3 解析Datapump及常见问题 66
2.3.1 Datapump使用场景及示例 66
2.3.3 只言片语分析Datapump的工作原理 68
诊断案例：impdp异常中断导致的问题 70
诊断案例：使用impdp选项不当导致的数据丢失 73
第3章 服务连接配置
3.1 监听配置与客户端配置简介 76
3.2 网络服务配置 78
3.2.1 网络配置细则与实践 78
诊断案例：Session跟踪失效的问题和原因 82
3.2.2 监听配置文件格式探究——一个空格的威力 84
3.2.3 RAC中的TAF的配置 88
3.2.4 RAC中的SCAN的配置 90
3.2.5 通过单例模式模拟RAC连接 93
3.3 监听器无法启动的几个原因 94
诊断案例：使用strace分析TNS-12543的案例 96
第4章 数据库启/停和宕机问题
4.1 数据库启停的问题分析 99
4.2 数据库无法启动案例 100
诊断案例：数据库参数设置不当导致无法启动的问题 100
诊断案例：服务器增加内存后无法重启数据库的问题及解决方案 102
诊断案例：数据库shutdown之后无法启动的问题 103
诊断案例：RAC节点无法启动的ORA-29702问题及分析 105
诊断案例：连续出现的RAC节点问题 108
4.3 数据库无法登录问题分析 110
4.4 数据库无法登录案例 111
诊断案例：归档空间不足导致的数据库无法登录问题 111
诊断案例：Session Leak导致的数据库无法登录问题 115
诊断案例：undo缺失导致的数据库无法登录问题 118
4.5 数据库宕机问题和原因分析 119
4.6 数据库宕机问题案例 119
诊断案例：一条SQL语句导致的数据库宕机问题及分析 119
诊断案例：存储导致的数据库宕机问题及分析 121
诊断案例：I/O问题导致的数据库突然宕机的问题及分析 124
诊断案例：数据库导致突然宕机的问题及解决 126
第5章 容灾与备份恢复
5.1 备份恢复应用及实践 132
5.1.1 归档模式下的四种完全恢复场景 132
5.1.2 RMAN中三个不完全恢复场景 137
实验1：使用句柄实现特定场景的无备份恢复 141
实验2：关于DUAL表的破坏性测试 145
5.2 闪回应用及实践 149
5.2.1 关于delete、drop、truncate异同和无备份恢复场景 149
5.2.2 使用闪回查询备份数据 152
5.2.3 使用Flashback Query巧妙抽取指定数据 154
实战案例：巧用Flashback Database实现灵活的数据回滚 155
实战案例：巧用Flashback Database实现灵活的数据切换 156
5.3 Data Guard搭建与应用 160
5.3.1 常见的Data Guard隐患 161
5.3.2 11g Data Guard搭建实践 163
5.3.3 论Oracle备库的设计方案 169
5.3.4 实用至上的 Snapshot Standby特性 171
实践案例：Data Guard备库中的几个数据文件问题 175
实践案例：Data Guard备库的数据文件的迁移实战 179
诊断案例：由Drop Datafile导致的Oracle Bug 182
诊断案例：一个Oracle bug的手工修复 185
诊断案例：11g备库无法开启ADG的原因分析 188
第6章 监控管理和故障处理
6.1 Zabbix、Orabbix简介 191
6.2 Zabbix Agent部署 191
6.3 Orabbix的部署 194
6.4 浅谈Zabbix和Grid Control的优劣 197
6.5 Orabbix定制监控Oracle的简单配置 198
实践案例：Orabbix结合Python发送图形报表 200
实践案例：Zabbix中配置Data Guard的监控 205
6.6 两条腿走路更稳当——硬件监控很有必要 207
6.7 运维平台的建设思考——元数据管理 209
6.8 监控盲点与诊断案例 210
监控盲点：由DUAL导致的一个潜在的监控问题 210
诊断案例：备库CPU使用异常优化 213
诊断案例：两条报警信息结合分析DG问题 216
诊断案例：监控反被监控误——一则Orabbix报警的分析 222
诊断案例：自定义监控项快速定位问题 224
诊断案例：CPU报警信息的分析 226
第2篇 数据迁移篇
第7章 数据库升级
7.1 数据库升级常用方法与准备工作 230
7.2 Oracle10g升级至11g完整呈现 231
7.2.1 准备流程图 231
7.2.2 10g升级至11g需要考虑的参数优化 232
7.2.3 Oracle10g升级至11g准备工作详细步骤 233
7.2.4 升级流程示意图 236
7.2.5 升级后需要考虑的补充工作 237
7.2.6 实战汇总：Oracle 10g 升级 11g过程中常见问题及解决方案 238
7.3 升级后常见问题与解决方案 243
7.3.1 问题分析：关于Oracle Invalid Components问题的解决 243
7.3.2 问题分析：10g升级至11g后数据库无法启动的问题 246
7.3.3 问题分析：10g升级至11g后exp启用consistent=y的问题 248
7.3.4 问题分析：查询user_synonyms超时的问题 254
7.3.5 问题分析：impdp 10g/11g问题解决 255
7.3.6 问题分析：升级后数据库日志里的外部表错误 257
第8章 数据迁移及问题处理
8.1 数据迁移工具和使用场景分析 261
8.2 利用SQL*Loader进行数据迁移 263
8.2.1 关于SQL*Loader-805问题的解决 263
8.2.2 SQL*Loader加载性能问题的排查 265
8.2.3 Excel文件内容导入数据库的问题及解决 267
诊断案例：生产环境SQL*Loader加载性能问题及分析 269
8.3 传输表空间 275
8.4 分区表迁移相关 277
8.4.1 分区表的水平、垂直切分 278
8.4.2 关于分区表的move操作 279
8.4.3 批量转换分区表为普通表 281
8.5 外部表 282
8.5.1 外部表简单总结 282
诊断案例：巧用外部表避免大量的insert 284
诊断案例：巧用外部表备份历史数据 286
诊断案例：通过外部表改进一个烦琐的大查询 289
8.6 其他迁移方式 292
8.6.1 数据库文件的迁移 292
8.6.2 Data Guard环境中的数据文件迁移方式对比 295
8.6.3 关于move tablespace的问题总结 298
第9章 数据迁移之外部表实战
9.1 失败的经验总结：数据迁移问题汇总 300
9.1.1 非空约束导致的数据加载失败 301
9.1.2 外键数据差异导致的约束无法启用 301
9.1.3 网络问题导致数据加载中断 301
9.1.4 约束问题导致Datapump加载回滚 302
9.1.5 undo不足的困扰 302
9.1.6 冲突数据不易展现 302
9.1.7 sequence冲突检查 303
9.1.8 加载LOB数据的假并行 303
9.1.9 数据乱码的影响 303
9.1.10 数据转储文件不可读/不易读 303
9.1.11 大分区表的加载性能问题 304
9.2 外部表方案的产生 304
9.2.1 SQL*Loader和ORACLE_DATAPUMP性能大比拼 304
9.2.2 海量数据迁移之通过shell脚本估算数据量 305
9.2.3 数据迁移前的数据库检查和建议 308
9.2.4 数据迁移前的系统检查 313
小技巧：怎样突破表名30个字符的限制 315
小技巧：使用shell生成状态报表 317
9.3 数据抽取 318
9.3.1 外部表切分原理 319
9.3.2 抽取方式1：使用utl_file做选择性数据导出 321
9.3.3 抽取方式2：海量数据迁移之外部表并行抽取 324
9.3.4 抽取方式3：海量数据迁移之分区并行抽取 327
9.3.5 抽取方式4：海量数据迁移之分区并行切分 331
9.3.6 抽取方式5：海量数据迁移之通过rowid切分大表 332
小技巧：海量数据迁移之使用shell启用多个动态并行 336
9.4 数据预检查 338
9.4.1 海量数据迁移之冲突数据筛查 339
9.4.2 数据迁移判断非空约束 340
小技巧：使用shell进行日志分析 342
小技巧：使用shell脚本巧妙统计文件 344
9.5 数据加载 345
9.5.1 海量数据迁移之外部表加载 345
9.5.2 巧用Parallel极速提升数据加载速度 348
9.5.3 海量数据迁移之使用分区并行切分导入 350
9.5.4 海量数据迁移之分区表批量insert性能改进 352
9.6 可能碰到的数据修复问题 352
9.6.1 使用错误日志修复数据的利弊 353
诊断案例：数据紧急修复之启用错误日志 355
9.6.2 人为操作失误的分析和应对 356
9.7 数据迁移经验总结 358
9.7.1 海量数据迁移之误操作和防范建议 358
9.7.2 数据迁移需要考虑的问题 360
第3篇 数据库优化篇
第10章 优化工具简介和定制
10.1 AWR简介 362
10.1.1 AWR的常用功能 363
10.1.2 解析AWR中的CPU信息 367
10.1.3 使用shell定制AWR脚本 370
10.1.4 强大的AWR Format 373
小技巧：使用AWR来分析Session Leak问题 375
实例分析：一份AWR报告分析的思路 376
10.2 ASH 380
10.2.1 ASH中的数据字典基表 380
10.2.2 通过shell定制ASH脚本 383
10.3 ADDM 385
10.3.1 使用shell定制ADDM脚本 385
诊断案例 通过ADDM明确I/O问题 387
10.4 SQL Profile简介 389
10.4.1 SQL Profile的使用功能 389
10.4.2 使用SQLT手工创建SQL Profile 393
10.4.4 性能下降的不定时炸弹——过旧的SQL Profile 400
10.5 SQL Monitor的功劳 401
10.5.1 SQL Monitor的使用功能 401
10.5.2 OSM的改进点和简单定制 403
10.6 数据字典 405
10.6.1 数据字典管理 405
实例诊断：数据字典中的细节问题 406
诊断案例：关于dba_data_files无法访问一个小问题 409
10.7 自定义脚本 410
10.7.1 关于Session Leak的问题分析 410
诊断案例：关于ORA-00020问题的反思 413
10.7.2 高级开发语言定制，量力而行 414
第11章 数据库实例调优
11.1 调整数据库参数 417
诊断案例：关于修改数据库参数的测试 417
11.2 内存组件调整 421
诊断案例：关于纠结的RECYCLE Pool的设置 426
诊断案例：分区表放入KEEP Pool、RECYCLE Pool的问题及解析 427
11.3 等待事件分析 430
诊断案例：关于等待事件“read by other session” 431
诊断案例：关于enq：TX - allocate ITL entry的问题分析 434
11.4 日志分析调优 437
诊断案例：由一条日志警告所做的调优分析 437
诊断案例：ORA-17500 ODM err的问题排查 440
诊断案例：alert日志中一条ORA警告信息的分析 441
11.5 分区表优化 443
诊断案例：通过分区键值发现性能问题 443
经验分享：修改分区表的问题总结 445
11.6 需要重视的并发 447
第12章 系统调优
12.1 I/O问题诊断 451
12.1.1 Orion的简单部署和测试 452
诊断案例：启用ODM极速调优I/O 455
诊断案例：一次数据库响应缓慢的问题排查 459
12.2 通过Linux命令诊断性能问题 460
12.2.1 那些极度危险的Linux命令 461
12.2.2 一些“简单”的Linux命令 464
诊断案例：Crontab导致CPU异常的问题分析及处理 471
诊断案例：服务器进程异常的原因分析 474
12.3 内核参数优化诊断 477
诊断案例：Linux Kernel引发的数据库连接问题 478
诊断案例：Linux Kernel引发的Data Guard问题 481
第13章 SQL优化前奏和SQL审核
13.1 SQL优化前奏 487
13.1.1 SQL的查询转换 487
13.1.2 通过错误的SQL来测试推理SQL的解析过程 494
诊断案例：从查询转换的角度来调优SQL 496
13.1.3 聚簇因子和执行计划的联系 501
13.1.4 常见的三种表连接 504
13.1.5 Oracle中的半连接 508
13.1.6 Oracle中的反连接 510
诊断案例：一条运行了3天的“简单”的SQL 514
13.1.7 理解Consistent Gets 515
13.1.8 读懂执行计划中“%CPU”的含义 520
13.2 解析索引 523
13.2.1 关于索引的内部信息 524
13.2.2 关于索引的访问模式 526
13.2.3 索引和空值的恩恩怨怨 529
13.2.4 很多人比较纠结的约束和索引的关系 533
诊断案例：索引列顺序导致的性能问题 537
13.2.5 索引进阶之虚拟索引 540
13.2.6 索引进阶之不可见索引 543
13.3 SQL需求审核 547
13.3.1 关于评审开发人员的SQL语句 549
诊断案例：通过ORA错误反思SQL语句规范 551
诊断案例：记一次数据同步需求的改进和实践 552
第14章 SQL优化技巧
14.1 常规SQL优化技巧 558
14.1.1 SQL优化中的简化 559
诊断案例：简化SQL中的子查询 559
诊断案例：通过图表简化表SQL中的表关联 560
14.1.2 统计信息是SQL优化的基础 563
诊断案例：物化视图查询优化之统计信息分析 563
14.1.3 索引是SQL优化的催化剂 566
诊断案例：Union语句中的全表扫描优化 566
14.1.4 并行加速数据处理 569
诊断案例：查看并行进程的简单信息 570
诊断案例：通过图表分析Oracle的Parallel性能 572
诊断案例：使用dbms_parallel_execute来加速DML的并行 576
诊断案例：由一条SQL语句导致的系统I/O问题 579
14.2 其他SQL优化技巧 582
14.2.1 敢于质疑 582
优化案例：质疑一条运行已久的SQL语句 582
14.2.2 学会变通，变通则达 587
优化案例：验证表中有无数据的方法比较 588
优化案例：递归查询语句的优化 590
优化案例：PL/SQL和SQL之间的转换 592
14.2.3 使用Hint 594
优化案例：使用Hint来调优SQL语句 595
14.2.4 结合业务优化是王道 597
优化案例：结合业务优化全表扫描 598
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle DBA工作笔记
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle VM实现与管理实战
第1部分简介
第1章虚拟化简介
1.1什么是虚拟化
1.2采用虚拟化的原因
1.3虚拟化技术概述
1.4管理程序
1.5硬件虚拟化和准虚拟化的对比
1.6本章小结
第2章Oracle VM简介
2.1Oracle VM的历史
2.2Oracle VM的特性
2.3Oracle对虚拟机的支持
2.4 Oracle的虚拟机模板库
2.5本章小结
第3章Oracle VM体系结构
3.1Oracle VM体系结构
3.2Xen体系结构
3.3Oracle VM的特性
3.4 Oracle VM的硬件支持
3.5本章小结
第4章Oracle VM生命周期管理
4.1Oracle VM虚拟机生命周期
4.2状态管理与转换
4.3本章小结
第5章企业级VM Server农场的规划和规模设计
5.1规划VM Server农场
5.2规模和容量规划
5.3本章小结
第Ⅱ部分安装和配置Ofacle VM
第6章安装Oracle VM Server
6.1Oracle VM Server的硬件需求
6.2安装VM Sewer
6.3升级VM Server
6.4本章小结
第7章安装和配置Oracle VM Manager
7.1VM Manager的硬件和软件需求
7.2安装VM Manager
7.3安装VM Manager Template
7.4管理VM Manager主机系统
7.5本章小结
第8章配置Oracle VM Management Pack
8.1Oracle Enterprise Manager Grid Control
8.2安装Oracle VM ManagementPaCk
8.3配置Oracle VM ManagementPaCk
8.4通过OEMGridControl管理虚拟化环境
8.5本章小结
第9章安装和配置Oracle VM
9.1Oracle VM CLI简介
9.2通过ULN安装OVMCL
9.3通过Oracle public yum存储库安装OVMCLI
9.4配置OVM CLI
9.5使用OVM CLI
9.6本章小结
第10章配置VM Server网络
10.1配置和管理VM Server网络
10.2管理VM Server网绍
10.3监视网络
10.4本章小结
第11章配置VM Server存储
11.1共享式存储与非共享式存储
11.2存储仓库
11.3配置存储的硬件
11.4向OracleVM添加额外的存储
11.5本章小结
第Ⅲ部分管理Oragle VM Server和客户机
第12章创建服务器池和服务器
12.1配置服务器池
12.2用Oracle VM Manager创建和管理服务器池与服务器
12.3用OEM Grid Control创建和管理服务器池与服务器
12.4用Oracle VM CLI创建和管理服务器池与服务器
12.5本章小结
第13章配置服务器资沥
13.1服务器资源
13.2用Oracle VM Manager配置服务器资源
13.3用OEM Grid Control配置服务器资源
13.4用Oracle VM CLI配置服务器资源
13.5本章小结
第14章虚拟机服务器的监视和调优
14.1性能监视
14.2 Oracle VM Server系统的调优
14.3虚拟机调优
14.4本章小结
第Ⅳ部分安装和配置客户操作系统
第15章创建模板
15.1手工创建模板
15.2用Template Builderer创建模板
15.3本章小结
第16章用模板创建虚拟机和配置资源
16.1用模板创建虚拟机
16.2配置虚拟机上的资源
16.3本章小结
第17章手工创建虚拟机
17.1用ISO镜像和安装媒体创建虚拟机
17.2用PXEBoot创建虚拟柳
17.3安装客户操作系统
17.4本章小结
第18章将其他虚拟机镜像转换为Oracle VM镜你
18.1将外部虚拟机镜像转换Oracle VM镜像
18.2VMware
18.3Microsoft Hyper-V
18.4物理机
18.5镜像转换最佳实践
18.6本章小结
第19章管理虚拟机环境和虚拟机
19.1管理虚拟机的状态
19.2修改虚拟机的配置
19.3部署和克隆虚拟机
19.4本章小结
第20章虚拟化小结和最佳实践
20.1虚拟化的未来
20.2最佳实践
20.3本章小结
第Ⅴ部分附录和词汇表
附录A 配置Linux支持功能
附录B Oracle VM日志文件
词汇表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle VM实现与管理实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库攻防之道
第1章　Oracle RDBMS概述　1.1　体系结构　1.2　进程　1.3　文件系统　1.4　网络　1.5　数据库对象　1.6　用户和角色　1.7　权限　1.8  Oracle补丁　1.9　小结第2章　Oracle网络体系结构　2.1　TNS协议　2.2　获得Oracle版本　2.3　小结第3章　攻击TNS LISTENER和调度器　3.1　攻击TNS LISTENER  3.2  Aurora GIOP Server  3.3  XML数据库  3.4  小结第4章  攻击身份验证过程  4.1  身份验证的工作原理  4.2  攻击密码术  4.3  默认用户名和密码  4.4  账户穷举与蛮力攻击    4.4.1  长用户名缓冲区溢出    4.4.2  对Windows XP平台上Oracle的注释  4.5  小结第5章  Oracle与PL/SQL  5.1  PL/SQL的概念  5.2  PL/SQL的执行权限  5.3  包装PL/SOL    5.3.1  在10g版本上包装和解包装    5.3.2  在9i及更早版本上包装和解包装    5.3.3  脱离代码的工作  5.4  PL/SOL注入    5.4.1  注入SELECT语句来获得更多的数据    5.4.2  注入函数    5.4.3  注入匿名PL/SQL块    5.4.4  PL/SQL注入的弊端  5.5  隐患研究  5.6  直接执行SQL的隐患  5.7  PL/SQL的紊乱条件  5.8  审计PL/sQL代码  5.9  DBMS ASSEI汀包  5.10  实例    5.10.1  利用DBMS_CDC_IMPDP的漏洞    5.10.2  利用LT    5.10.3  利用漏洞DBMS_CDC_SUBSCRIBE和DBMS CDC ISUBSCRIBE    5.10.4  PL/SQL与触发器  5.11  小结第6章  触发器  6.1  出于玩笑和利益的目的利用触发器的漏洞  6.2  利用触发器漏洞的实例    6.2.1  触发器MDSYS.SDO_GEOM_TRIG_INS1和SDO_GEOM_TRIG_INS1    6.2.2  触发器MDSYS SDO CMT CBK TRIG    6.2.3  触发器sYS.CDC DROP CTABLE BEFORE    6.2.4  触发器MDSY s_SDO DROP USER BEFORE  6.3  小结第7章  间接增加权限  7.1  逐步间接获得数据库管理员的权限    7.1.1  由CREATE ANY TRIGGER获得数据库管理员权限    7.1.2  由CREATE ANY VI.EW获得数据库管理员权限    7.1.3  由EXECUTE ANY PROCEDUR.E获得数据库管理员权限    7.1.4  由CREATE PROCEDUER获得数据库管理员权限  7.2  小结第8章  战胜虚拟专有数据库  8.1  设计使Oracle丢弃某种机制  8.2  利用原文件访问战胜VPD  8.3  通用权限  8.4  小结第9章  攻击OracIe PL，SQL Web应用程序  9.1  Oracle PL/SQL网关体系结构  9.2  识别Oracle PL/SQL网关    9.2.1  PL/SSQ网关URL    9.2.2  Oracle Portal  9.3  验证Oracle PL/SQL网关的存在    9.3.1  Web服务器、HTTP服务器响应的报头    9.3.2  Oracle PL/SQL网关与数据库服务器的通信方式  9.4  攻击PL/SQL网关  9.5  小结第10章  运行操作系统命令  10.1  通过PL/SQL运行OS命令  10.2  用Java运行OS命令  10.3  使用DBMS_SCHEDULER运行OS命令  10.4  直接用任务调度程序运行OS命令  10.5  使用ALTER SYSTEM运行OS命令  10.6  小结第11章  访问文件系统  11.1  用UTL FILE包访问文件系统  11.2  用Java访问文件系统  11.3  访问二进制文件  11.4  利用操作系统环境变量  11.5  小结第12章  访问网络  12.1  数据泄露    12.1.1  使用UTL_TCP    12.1.2  使用UTL_HTTP    12.1.3  使用DNS查询和UTL_INADDR  12.2  数据加密优先于数据泄露  12.3  攻击网络上的其他系统  12.4  Java和其他网络  12.5  数据库链接  12.6  小结附录  默认用户名和密码
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库攻防之道
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 12c完全参考手册（第7版）
目    录
第Ⅰ部分  数据库核心概念
第1章  Oracle Database 12c架构选件	3
1.1  数据库和实例	4
1.2  数据库技术	5
1.2.1  存储数据	6
1.2.2  数据保护	7
1.2.3  可编程的结构	8
1.3  选择体系结构和选件	9
第2章  安装Oracle Database 12c和创建数据库	11
2.1  许可证和安装选项概览	13
2.2  安装Oracle软件	13
2.2.1  安装Grid Infrastructure	13
2.2.2  安装Oracle数据库	16
第3章  升级到Oracle Database 12c	19
3.1  选择升级方法	20
3.2  升级之前的准备	21
3.3  升级Grid Infrastructure和数据库	22
3.3.1  升级Grid Infrastructure	22
3.3.2  升级数据库	25
3.4  升级之后的工作	32
第4章  规划Oracle应用程序——方法、风险和标准	33
4.1  协作方法	34
4.2  每个人都有“数据”	35
4.3  熟悉的Oracle语言	36
4.3.1  存储信息的表	36
4.3.2  结构化查询语言	37
4.3.3  简单的Oracle查询	37
4.3.4  为什么称作“关系”	39
4.4  一些通用的、常见的示例	40
4.5  风险所在	42
4.6  新视角的重要性	43
4.6.1  变化的环境	43
4.6.2  代码、缩写和命名标准	43
4.7  如何减少混淆	45
4.7.1  规范化	45
4.7.2  表和列的英文名称	49
4.7.3  数据中的英文单词	50
4.8  名称和数据中的大写	51
4.9  规范化名称	51
4.10  人性化和优秀的设计	52
4.10.1  理解应用程序的任务	52
4.10.2  任务概要	53
4.11  理解数据	55
4.11.1  原子数据模型	56
4.11.2  原子业务模型	57
4.11.3  业务模型	57
4.11.4  数据项	57
4.11.5  查询和报告	57
4.12  关于对象名称的规范化	58
4.12.1  级别-名称完整性	58
4.12.2  外键	59
4.12.3  单数名称	59
4.12.4  简洁	60
4.12.5  对象名辞典	60
4.13  智能键和列值	60
4.14  建议	61
第Ⅱ部分  SQL和SQL*Plus
第5章  SQL中的基本语法	65
5.1  样式	67
5.2  创建NEWSPAPER表	67
5.3  用SQL从表中选择数据	68
5.4  select、from、where和order by	71
5.5  逻辑和值	73
5.5.1  单值测试	74
5.5.2  值列表的简单测试	79
5.5.3  组合逻辑	81
5.6  WHERE的另一个用途：子查询	82
5.6.1  从子查询得到单值	83
5.6.2  从子查询得到值列表	84
5.7  组合表	85
5.8  创建视图	87
5.9  扩展视图	89
第6章  基本的SQL*Plus报表和命令	91
6.1  构建简单的报表	93
6.1.1  REMARK	95
6.1.2  SET HEADSEP	96
6.1.3  TTITLE和BTITLE	96
6.1.4  COLUMN	96
6.1.5  BREAK ON	97
6.1.6  COMPUTE AVG	98
6.1.7  SET LINESIZE	99
6.1.8  SET PAGESIZE	99
6.1.9  SET NEWPAGE	99
6.1.10  SPOOL	100
6.1.11  /* */	101
6.1.12  关于列标题的一些说明	101
6.2  其他特性	102
6.2.1  命令行编辑器	102
6.2.2  设置停顿	105
6.2.3  保存	106
6.2.4  存储	106
6.2.5  编辑	106
6.2.6  HOST	107
6.2.7  添加SQL*Plus命令	108
6.2.8  START	108
6.3  检查SQL*Plus环境	108
6.4  构件块	110
第7章  文本信息的收集与更改	111
7.1  数据类型	112
7.2  什么是串	112
7.3  表示法	113
7.4  连接符(||)	114
7.5  剪切和粘贴串	116
7.5.1  RPAD和LPAD	116
7.5.2  LTRIM、RTRIM和TRIM	117
7.5.3  组合两个函数	118
7.5.4  使用TRIM函数	120
7.5.5  再次使用填充函数	121
7.5.6  LOWER、UPPER和INITCAP	121
7.5.7  LENGTH	122
7.5.8  SUBSTR	123
7.5.9  INSTR	126
7.5.10  ASCII和CHR	130
7.6  在ORDER BY和WHERE子句中使用串函数	130
7.6.1  SOUNDEX	132
7.6.2  国际语言支持	133
7.6.3  正则表达式支持	133
7.7  小结	133
第8章  正则表达式搜索	135
8.1  搜索串	136
8.2  REGEXP_SUBSTR	139
8.3  REGEXP_INSTR	141
8.4  REGEXP_LIKE	142
8.5  REPLACE和REGEXP_
REPLACE	143
8.6  REGEXP_COUNT	148
第9章  数值处理	151
9.1  三类数值函数	151
9.2  表示法	152
9.3  单值函数	152
9.3.1  加减乘除	153
9.3.2  NULL	153
9.3.3  NVL：空值置换函数	154
9.3.4  ABS：绝对值函数	155
9.3.5  CEIL	155
9.3.6  FLOOR	156
9.3.7  MOD	156
9.3.8  POWER	157
9.3.9  SQRT：求平方根	157
9.3.10  EXP、LN和LOG	158
9.3.11  ROUND和TRUNC	158
9.3.12  SIGN	160
9.3.13  SIN、SINH、COS、COSH、TAN、TANH、ACOS、ATAN、ATAN2和ASIN	160
9.4  聚集函数	160
9.4.1  组值函数中的NULL	160
9.4.2  单值函数和组值函数的示例	162
9.4.3  AVG、COUNT、MAX、MIM和SUM	162
9.4.4  组值函数和单值函数的组合	163
9.4.5  STDDEV和VARIANCE	165
9.4.6  组函数中的DISTINCT	165
9.5  列表函数	166
9.6  使用MAX或MIN函数查找行	168
9.7  优先级和圆括号的应用	169
9.8  小结	170
第10章  日期：过去、现在及日期的差	173
10.1  日期算法	173
10.1.1  SYSDATE、CURRENT_DATE及SYSTIMESTAMP	174
10.1.2  两个日期的差	175
10.1.3  添加月份	176
10.1.4  减少月份	176
10.1.5  GREATEST和LEAST	176
10.1.6  NEXT_DAY	178
10.1.7  LAST_DAY	179
10.1.8  MOMTHS_BETWEEN	179
10.1.9  组合日期函数	180
10.2  日期计算中的ROUND和TRUNC	181
10.3  使用TO_DATE和TO_CHAR设置日期格式	181
10.3.1  最常见的TO_CHAR错误	186
10.3.2  NEW_TIME：切换时区	187
10.3.3  TO_DATE计算	187
10.4  WHERE子句中的日期	189
10.5  处理多个世纪	191
10.6  使用EXTRACT函数	191
10.7  使用TIMESTAMP数据类型	192
第11章  转换函数与变换函数	195
11.1  基本的转换函数	197
11.1.1  数据类型的自动转换	199
11.1.2  关于自动转换的注意事项	202
11.2  特殊的转换函数	202
11.3  变换函数	203
11.3.1  TRANSLATE	203
11.3.2  DECODE	204
11.4  小结	205
第12章  分组函数	207
12.1  GROUP BY和HAVING的用法	207
12.1.1  添加ORDER BY子句	209
12.1.2  执行顺序	210
12.2  分组视图	212
12.3  用别名重命名列	213
12.4  分组视图的功能	214
12.4.1  在视图中使用
ORDER BY	215
12.4.2  HAVING子句中的逻辑	216
12.4.3  对列和分组函数进行排序	217
12.4.4  连接列	218
12.5  更多分组可能性	218
第13章  当一个查询依赖于另一个查询时	219
13.1  高级子查询	219
13.1.1  相关子查询	220
13.1.2  并列的逻辑测试	221
13.1.3  EXISTS及其相关子查询的使用	223
13.2  外部连接	225
13.2.1  Oracle 9i以前版本中的外部连接语法	225
13.2.2  现在的外部连接语法	227
13.2.3  用外部连接代替
NOT IN	228
13.2.4  用NOT EXISTS代替
NOT IN	230
13.3  自然连接和内部连接	231
13.4  UNION﹑INTERSECT和MINUS	232
13.4.1  IN子查询	235
13.4.2  UNION、INTERSECT和MINUS的限制	235
第14章  一些复杂的技术	237
14.1  复杂的分组	237
14.2  使用临时表	239
14.3  使用ROLLUP﹑GROUPING和CUBE	240
14.4  家族树和CONNECT BY	244
14.4.1  排除个体和分支	248
14.4.2  向根遍历	249
14.4.3  找出叶节点	251
14.4.4  基本规则	252
第15章  更改数据：插入﹑更新﹑合并和删除	253
15.1  插入	253
15.1.1  插入时间	254
15.1.2  用SELECT插入	255
15.1.3  使用APPEND提示改善插入性能	256
15.2  ROLLBACK、COMMIT和AUTOCOMMIT命令	256
15.2.1  使用SAVEPOINT	257
15.2.2  隐式提交	258
15.2.3  自动回滚	258
15.3  多表插入	259
15.4  DELETE命令	263
15.5  UPDATE命令	264
15.5.1  用嵌入式SELECT进行更新	265
15.5.2  用NULL更新	266
15.6  使用MERGE命令	266
15.7  处理错误	269
第16章  DECODE和CASE：SQL中的if-then-else	271
16.1  if-then-else	271
16.2  通过DECODE替换值	275
16.3  DECODE中的DECODE	276
16.4  DECODE中的大于和小于	279
16.5  使用CASE	281
16.6  使用PIVOT	284
第17章  创建和管理表、视图、索引、集群和序列	287
17.1  创建表	287
17.1.1  字符宽度和数值精度	289
17.1.2  在插入时进行舍入	290
17.1.3  在CREATE TABLE中定义约束	292
17.1.4  指定索引表空间	293
17.1.5  命名约束	294
17.2  删除表	295
17.3  更改表	296
17.3.1  添加或修改列的规则	298
17.3.2  创建只读表	299
17.3.3  更改当前使用的表	299
17.3.4  创建虚拟列	300
17.3.5  删除列	301
17.4  根据一个表创建另一个表	302
17.5  创建索引组织表	303
17.6  创建视图	304
17.6.1  视图的稳定性	305
17.6.2  视图中的ORDER BY	306
17.6.3  创建只读视图	306
17.7  索引	307
17.7.1  创建索引	307
17.7.2  实施唯一性	308
17.7.3  创建唯一索引	308
17.7.4  创建位图索引	309
17.7.5  何时创建索引	310
17.7.6  创建不可见索引	310
17.7.7  索引列的变化	310
17.7.8  一个表能使用的索引数目	311
17.7.9  在数据库中放置索引	311
17.7.10  重建索引	312
17.7.11  基于函数的索引	312
17.8  集群	313
17.9  序列	314
第18章  分区	317
18.1  创建分区表	318
18.2  列表分区	320
18.3  创建子分区	320
18.4  创建引用分区和间隔分区	321
18.4.1  引用分区	321
18.4.2  间隔分区	322
18.5  索引分区	323
18.6  管理分区表	323
第19章  Oracle基本安全	325
19.1  用户、角色和权限	325
19.1.1  创建用户	326
19.1.2  密码管理	326
19.1.3  标准角色	330
19.1.4  GRANT命令的格式	331
19.1.5  撤消权限	331
19.2  可以授予用户何种权限	332
19.2.1  使用CONNECT切换到另一个用户	334
19.2.2  创建同义词	337
19.2.3  使用未授权的权限	337
19.2.4  权限的传递	337
19.2.5  创建角色	339
19.2.6  为角色授权	339
19.2.7  将一个角色授予另一个角色	340
19.2.8  为用户授予角色	340
19.2.9  为角色添加密码	340
19.2.10  删除角色的密码	341
19.2.11  启用和禁用角色	341
19.2.12  撤消角色的权限	342
19.2.13  删除角色	342
19.2.14  给指定的列授予UPDATE
权限	343
19.2.15  撤消对象权限	343
19.2.16  用户安全性	343
19.2.17  给public授予访问权	345
19.3  有限资源的授权	345
第Ⅲ部分  进    阶
第20章  高级安全性——虚拟专用数据库	349
20.1  初始配置	350
20.2  创建应用程序上下文	351
20.3  创建登录触发器	353
20.4  创建安全策略	354
20.5  将安全策略应用于表	355
20.6  测试VPD	355
20.7  如何实现列级别的VPD	357
20.8  如何禁用VPD	357
20.9  如何使用策略组	359
第21章  高级安全性：透明数据加密	361
21.1  列的透明数据加密	361
21.1.1  设置TDE以便使用加密列	362
21.1.2  RAC数据库的额外设置	363
21.1.3  钱夹的打开和关闭	363
21.1.4  列的加密和解密	364
21.2  表空间的加密	365
21.2.1  在表空间上设置TDE	365
21.2.2  创建加密的表空间	366
第22章  使用表空间	367
22.1  表空间与数据库的结构	367
22.1.1  表空间内容	368
22.1.2  表空间中的RECYCLEBIN空间	370
22.1.3  只读表空间	371
22.1.4  无日志表空间	371
22.1.5  临时表空间	372
22.1.6  用于系统管理撤消的表空间	372
22.1.7  大文件表空间	372
22.1.8  加密的表空间	373
22.1.9  支持闪回数据库	373
22.1.10  移动表空间	373
22.2  规划表空间的使用	374
22.2.1  分离活动表与静态表	374
22.2.2  分离索引与表	374
22.2.3  分离大对象与小对象	374
22.2.4  将应用程序表与核心对象分开	375
第23章  用SQL*Loader加载数据	377
23.1  控制文件	378
23.2  开始加载	379
23.3  逻辑记录与物理记录	382
23.4  控制文件语法注释	383
23.5  管理数据加载	385
23.6  重复数据加载	385
23.7  调整数据加载	386
23.8  直接路径加载	387
23.9  SQL*Loader Express Mode	389
23.10  附加功能	390
第24章  使用Data Pump Export和Data Pump Import	391
24.1  创建目录	392
24.2  Data Pump Export选项	392
24.3  启动Data Pump Export作业	395
24.3.1  停止和重新启动运行的作业	396
24.3.2  从另一个数据库中导出	397
24.3.3  使用EXCLUDE、INCLUDE和QUERY	397
24.4  Data Pump Import选项	398
24.5  启动Data Pump Import作业	401
24.5.1  停止和重新启动运行的作业	402
24.5.2  EXCLUDE、INCLUDE和QUERY	403
24.5.3  生成SQL	403
第25章  访问远程数据	407
25.1  数据库链接	407
25.1.1  数据库链接是如何工作的	408
25.1.2  利用数据库链接进行远程查询	408
25.1.3  对同义词和视图使用数据库链接	409
25.1.4  利用数据库链接进行远程更新	410
25.1.5  数据库链接的语法	411
25.2  为位置透明性使用同义词	414
25.3  在视图中使用USER伪列	415
第26章  使用物化视图	417
26.1  功能	417
26.2  必需的系统权限	418
26.3  必需的表权限	419
26.4  只读物化视图与可更新的物化视图	419
26.5  创建物化视图的语法	419
26.5.1  物化视图的类型	423
26.5.2  基于ROWID和基于主键的物化视图	423
26.5.3  使用预建表	423
26.5.4  为物化视图表创建索引	424
26.6  用物化视图更改查询执行路径	424
26.7  使用DBMS_ADVISOR	425
26.8  刷新物化视图	428
26.8.1  可执行何种刷新	428
26.8.2  用CONSIDER FRESH快速刷新	431
26.8.3  自动刷新	432
26.8.4  人工刷新	432
26.9  创建物化视图日志的语法	434
26.10  更改物化视图和日志	435
26.11  删除物化视图和日志	435
第27章  使用Oracle Text进行文本搜索	437
27.1  将文本添加到数据库中	437
27.2  文本查询和文本索引	439
27.2.1  文本查询	439
27.2.2  可用的文本查询表达式	440
27.2.3  精确匹配单个单词的搜索	440
27.2.4  精确匹配多个单词的搜索	441
27.2.5  短语精确匹配的搜索	445
27.2.6  搜索互相接近的单词	446
27.2.7  在搜索中使用通配符	446
27.2.8  搜索具有相同词根的单词	447
27.2.9  模糊匹配搜索	448
27.2.10  搜索发音相似的词	449
27.2.11  使用ABOUT运算符	450
27.2.12  索引同步	451
27.3  索引集	451
第28章  使用外部表	453
28.1  访问外部数据	454
28.2  创建外部表	455
28.2.1  外部表创建选项	458
28.2.2  创建时加载外部表	464
28.3  更改外部表	465
28.3.1  ACCESS PARAMETERS子句	465
28.3.2  ADD COLUMN子句	466
28.3.3  DEFAULT DIRECTORY子句	466
28.3.4  DROP COLUMN子句	466
28.3.5  LOCATION子句	466
28.3.6  MODIFY COLUMN子句	466
28.3.7  PARALLEL子句	466
28.3.8  PROJECT COLUMN子句	466
28.3.9  REJECT LIMIT子句	466
28.3.10  RENAME TO子句	466
28.4  外部表的优缺点和潜在用途	467
第29章  使用闪回查询	469
29.1  基于时间的闪回示例	470
29.2  保存数据	471
29.3  基于SCN的闪回示例	472
29.4  闪回查询失败的后果	473
29.5  什么SCN与每一行关联	474
29.6  闪回版本查询	475
29.7  闪回计划	478
第30章  闪回：表和数据库	479
30.1  FLASHBACK TABLE命令	479
30.1.1  必需的权限	480
30.1.2  恢复删除的表	480
30.1.3  启用和禁用回收站	481
30.1.4  闪回SCN或时间戳	482
30.1.5  索引和统计信息	483
30.2  FLASHBACK DATABASE命令	483
第31章  SQL重放	487
31.1  高级别配置	487
31.1.1  分离和连接	488
31.1.2  创建工作负载目录	488
31.2  捕获工作负载	489
31.2.1  定义过滤器	489
31.2.2  启动捕获	490
31.2.3  停止捕获	491
31.2.4  导出AWR数据	491
31.3  处理工作负载	491
31.4  重放工作负载	492
31.4.1  控制和启动重放客户	492
31.4.2  初始化和运行重放	493
31.4.3  导出AWR数据	494
第Ⅳ部分  PL/SQL
第32章  PL/SQL简介	497
32.1  PL/SQL概述	497
32.2  声明部分	498
32.3  可执行命令部分	501
32.3.1  条件逻辑	503
32.3.2  循环	504
32.3.3  case语句	512
32.4  异常处理部分	514
第33章  应用程序在线升级	517
33.1  高可用数据库	517
33.1.1  Oracle Data Guard(数据卫士)体系结构	518
33.1.2  创建备用数据库配置	519
33.1.3  管理角色——切换和故障转移	521
33.2  最小化DDL变更的影响	524
33.2.1  创建虚拟列	524
33.2.2  改变正在使用的表	525
33.2.3  添加NOT NULL列	525
33.2.4  在线对象重新组织	525
33.2.5  删除列	528
第34章  触发器	531
34.1  必需的系统权限	531
34.2  必需的表权限	532
34.3  触发器的类型	532
34.3.1  行级触发器	532
34.3.2  语句级触发器	532
34.3.3  BEFORE和AFTER触发器	533
34.3.4  INSTEAD OF触发器	533
34.3.5  模式触发器	533
34.3.6  数据库级触发器	533
34.3.7  复合触发器	534
34.4  触发器语法	534
34.4.1  DML触发器类型的组合	536
34.4.2  设置插入值	537
34.4.3  维护复制的数据	538
34.4.4  定制错误条件	539
34.4.5  在触发器中调用过程	541
34.4.6  命名触发器	542
34.4.7  创建DDL事件触发器	542
34.4.8  创建数据库事件触发器	546
34.4.9  创建复合触发器	546
34.5  启用和禁用触发器	548
34.6  替换触发器	549
34.7  删除触发器	549
第35章  过程、函数与程序包	551
35.1  必需的系统权限	552
35.2  必需的表权限	553
35.3  过程与函数	553
35.4  过程与程序包	554
35.5  CREATE PROCEDURE语法	554
35.6  CREATE FUNCTION语法	556
35.6.1  在过程中引用远程表	558
35.6.2  调试过程	559
35.6.3  创建自己的函数	560
35.6.4  定制错误条件	561
35.6.5  命名过程和函数	563
35.7  CREATE PACKAGE语法	563
35.8  查看过程对象的源代码	566
35.9  编译过程、函数和程序包	567
35.10  替换过程、函数和程序包	567
35.11  删除过程、函数和程序包	568
第36章  使用本地动态SQL和DBMS_SQL	569
36.1  使用EXECUTE IMMEDIATE	569
36.2  使用绑定变量	571
36.3  使用DBMS_SQL	572
36.3.1  OPEN_CURSOR	573
36.3.2  PARSE	573
36.3.3  BIND_VARIABLE和BIND_ARRAY	574
36.3.4  EXECUTE	574
36.3.5  DEFINE_COLUMN	574
36.3.6  FETCH_ROWS、
EXECUTE_AND_FETCH和COLUMN_VALUE	575
36.3.7  CLOSE_CURSOR	575
第37章  PL/SQL调整	577
37.1  调整SQL	577
37.2  调整PL/SQL的步骤	578
37.3  在SQL语句中使用PL/SQL	579
37.4  使用DBMS_PROFILE识别问题	580
37.5  将PL/SQL特性用于批量操作	585
37.5.1  forall	586
37.5.2  bulk collect	588
第Ⅴ部分  面向对象数据库
第38章  实现对象类型、对象视图和方法	593
38.1  使用对象类型	593
38.1.1  对象类型的安全性	594
38.1.2  索引对象类型属性	597
38.2  实现对象视图	598
38.2.1  通过对象视图操作数据	601
38.2.2  使用INSTEAD OF触发器	601
38.3  方法	604
38.3.1  创建方法的语法	604
38.3.2  管理方法	606
第39章  收集器(嵌套表和可变数组)	607
39.1  可变数组	607
39.1.1  创建可变数组	608
39.1.2  描述可变数组	608
39.1.3  向可变数组中插入记录	609
39.1.4  从可变数组中选择数据	611
39.2  嵌套表	613
39.2.1  指定嵌套表的表空间	614
39.2.2  向嵌套表中插入记录	615
39.2.3  使用嵌套表	616
39.3  嵌套表与可变数组的附加函数	617
39.4  嵌套表和可变数组的管理问题	618
39.4.1  收集器的可变性	618
39.4.2  数据的位置	619
第40章  使用大对象	621
40.1  可用的数据类型	621
40.2  为LOB数据指定存储参数	623
40.3  LOB值的操作和选择	625
40.3.1  初始化值	626
40.3.2  用子查询插入数据	628
40.3.3  更新LOB值	628
40.3.4  使用串函数处理LOB值	629
40.3.5  使用DBMS_LOB操作LOB值	630
40.3.6  删除LOB	646
第41章  面向对象的高级概念	647
41.1  行对象和列对象	648
41.2  对象表和OID	648
41.2.1  把行插入对象表	649
41.2.2  从对象表中选择值	649
41.2.3  从对象表中更新和删除数据	650
41.2.4  使用REF函数	651
41.2.5  使用DEREF函数	651
41.2.6  使用VALUE函数	654
41.2.7  无效引用	655
41.3  具有REF的对象视图	655
41.3.1  对象视图的简要回顾	655
41.3.2  包含引用的对象视图	656
41.4  对象PL/SQL	659
41.5  数据库中的对象	661
第Ⅵ部分  Java相关知识
第42章  Java简介	665
42.1  Java与PL/SQL概述	666
42.2  开始	666
42.3  声明	667
42.4  可执行命令	667
42.4.1  条件逻辑	668
42.4.2  循环	672
42.4.3  异常处理	674
42.4.4  保留字	675
42.5  类	675
第43章  JDBC程序设计	681
43.1  使用JDBC类	682
43.2  使用JDBC进行数据操作	685
第44章  Java存储过程	691
44.1  将类加载到数据库中	693
44.2  如何访问类	697
44.2.1  直接调用Java存储过程	699
44.2.2  在何处执行命令	699
第Ⅶ部分  指    南
第45章  Oracle数据字典指南	703
45.1  关于名称的说明	704
45.2  Oracle Database 12c中引入的新视图	704
45.3  Oracle Database 11g中引入的新视图	711
45.4  路线图：DICTIONARY(DICT)和DICT_COLUMNS	714
45.5  从表、列、视图、同义词和序列中选择	716
45.5.1  目录：USER_CATALOG(CAT)	716
45.5.2  对象：USER_OBJECTS(OBJ)	716
45.5.3  表：USER_TABLES(TABS)	717
45.5.4  列：USER_TAB_COLUMNS(COLS)	719
45.5.5  视图：USER_VIEWS	720
45.5.6  同义词：USER_SYNONYMS(SYN)	722
45.5.7  序列：USER_SEQUENCES(SEQ)	723
45.6  回收站：USER_RECYCLEBIN和DBA_RECYCLEBIN	723
45.7  约束和注释	724
45.7.1  约束：USER_CONSTRAINTS	724
45.7.2  约束列：USER_CONS_COLUMNS	725
45.7.3  约束异常：EXCEPTIONS	726
45.7.4  表注释：USER_TAB_COMMENTS	727
45.7.5  列注释：USER_COL_COMMENTS	727
45.8  索引和集群	728
45.8.1  索引：USER_INDEXES(IND)	728
45.8.2  索引列：USER_IND_COLUMNS	730
45.8.3  集群：USER_CLUSTERS(CLU)	731
45.8.4  集群列：USER_CLU_COLUMNS	732
45.9  抽象数据类型和LOB	732
45.9.1  抽象数据类型：USER_TYPES	732
45.9.2  LOB：USER_LOBS	734
45.10  数据库链接和物化视图	735
45.10.1  数据库链接：USER_DB_LINKS	735
45.10.2  物化视图	736
45.10.3  物化视图日志：USER_MVIEW_LOGS	737
45.11  触发器、过程、函数和程序包	738
45.11.1  触发器：USER_TRIGGERS	738
45.11.2  过程、函数和程序包：USER_SOURCE	738
45.12  维度	740
45.13  包括分区和子分区的空间分配和使用情况	741
45.13.1  表空间：USER_TABLESPACES	741
45.13.2  空间限额：USER_TS_QUOTAS	742
45.13.3  段和区：USER_SEGMENTS和USER_EXTENTS	742
45.13.4  分区和子分区	743
45.13.5  可用空间：USER_FREE_SPACE	746
45.14  用户和权限	746
45.14.1  用户：USER_USERS	746
45.14.2  资源限制：USER_RESOURCE_LIMITS	746
45.14.3  表的权限：USER_TAB_PRIVS	747
45.14.4  列权限：USER_COL_PRIVS	747
45.14.5  系统权限：USER_SYS_PRIVS	747
45.15  角色	748
45.16  审计	749
45.17  监控对象使用	749
45.18  其他视图	750
45.19  监控：V$动态性能表	750
45.19.1  CHAINED_ROWS	750
45.19.2  PLAN_TABLE	751
45.19.3  相互依赖性：USER_DEPENDENCIES和IDEPTREE	751
45.19.4  只属于DBA的视图	751
45.19.5  Oracle Label Security	751
45.19.6  SQL*Loader直接加载视图	752
45.19.7  全球支持视图	752
45.19.8  库	752
45.19.9  异构服务	752
45.19.10  索引类型和运算符	752
45.19.11  存储概要	753
45.19.12  顾问程序	753
45.19.13  调度程序	753
第46章  应用程序和SQL调整指南	755
46.1  数据库性能调整概览	755
46.2  调整—— 最佳实践	757
46.2.1  尽可能少做	757
46.2.2  尽可能简单地完成	760
46.2.3  告诉数据库需要知道什么	761
46.2.4  最大化环境中的吞吐量	761
46.2.5  分开处理数据	763
46.2.6  正确测试	763
46.3  生成并读取说明计划	765
46.3.1  使用SET AUTOTRACE ON命令	765
46.3.2  使用EXPLAIN PLAN命令	769
46.4  说明计划中的主要操作	770
46.4.1  TABLE ACCESS FULL	770
46.4.2  TABLE ACCESS BY INDEX ROWID	771
46.4.3  相关提示	771
46.4.4  使用索引的操作	772
46.4.5  何时使用索引	773
46.4.6  操纵数据集的操作	778
46.4.7  执行连接的操作	784
46.4.8  Oracle如何处理两个以上的表的连接	785
46.4.9  并行化和缓存问题	790
46.5  小结	791
第47章  SQL结果缓存和客户端查询缓存	793
47.1  SQL结果缓存的数据库参数设置	801
47.2  DBMS_RESULT_CACHE程序包	802
47.3  SQL结果缓存的字典视图	803
47.4  SQL结果缓存的更多细节	803
47.5  Oracle调用接口(OCI)客户端查询缓存	803
47.6  Oracle调用接口(OCI)客户端查询缓存的限制	804
第48章  关于调整的示例分析	805
48.1  案例分析1：等待、等待、再等待	805
48.2  案例分析2：破坏应用程序的查询	808
48.3  案例分析3：长期运行的批处理作业	811
第49章  可插入数据库漫游指南	815
49.1  可插入数据库的概念	816
49.1.1  CDB的组成	816
49.1.2  CDB用户	816
49.1.3  先决条件	817
49.2  创建CDB和PDB	817
49.2.1  创建CDB	817
49.2.2  创建PDB	819
49.2.3  管理PDB	821
49.2.4  拔出PDB	821
49.2.5  删除PDB	822
49.2.6  插入PDB	822
49.2.7  监控PDB	822
第50章  Oracle RAC集群	825
50.1  安装前的准备	826
50.2  安装RAC	826
50.2.1  存储	827
50.2.2  初始化参数	827
50.3  启动和停止RAC实例	829
50.4  透明应用程序故障切换	831
50.5  为集群添加节点和实例	832
第51章  数据库管理指南	833
51.1  创建数据库	834
51.2  启动和停止数据库	835
51.3  设置和管理内存区域大小	835
51.4  分配和管理对象的空间	838
51.4.1  存储子句的含义	838
51.4.2  表段	840
51.4.3  索引段	841
51.4.4  系统管理的Undo	841
51.4.5  临时段	842
51.4.6  可用空间	843
51.4.7  设置数据库对象的大小	844
51.5  监控Undo表空间	846
51.6  自动存储管理	846
51.7  段空间管理	847
51.8  移动表空间	848
51.8.1  生成可移动表空间集	848
51.8.2  插入可移动表空间集	849
51.9  进行备份	850
51.9.1  Data Pump Export和
Data Pump Import	850
51.9.2  脱机备份	850
51.9.3  联机备份	851
51.9.4  Recovery Manager	854
51.10  展望	855
第52章  Oracle中的XML指南	857
52.1  文档类型定义、元素及属性	857
52.2  XML模式	861
52.3  使用XSU选择、插入、更新和删除XML值	863
52.3.1  使用XSU进行插入、更新和删除	865
52.3.2  XSU和Java	866
52.3.3  定制查询过程	867
52.4  使用XMLType	868
52.5  其他功能	870
附录  命令和术语参考(位于本书光盘)

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 12c完全参考手册（第7版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Unix和Linux下的Oracle数据库管理
第1章  DBA的任务	1
1.1  什么是DBA	2
1.1.1  取决于所在机构	2
1.1.2  DBA来自何处	2
1.2  成为DBA的途径	3
1.2.1  系统管理员（SA）	3

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Unix和Linux下的Oracle数据库管理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 优势策略
一，导言
二，公司特点
三，公司策略
四，产品研发
五，惊人的销售团队
六，顾客关系
七，击退竞争对手
八，用人策略
九，管理哲学
十，面对危机的生存之道
十一，开发新市场
十二，Oracle公司的未来

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 优势策略
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle性能预测
《oracle性能预测》
译者序
前言
第1章 性能预测导论	1
1.1 风险：一个四个字母的单词（risk）	2
1.2 服务水平管理	3
1.3 建模：化繁为简	5
1.4 模型类型	6
1.4.1 数学模型	6
1.4.2 基准模型	7
1.4.3 模拟模型	7
1.4.4 基准和模拟之间的差异	8
1.5 oracle性能预测的挑战	9
第2章 基本性能预测	12
2.1 计算系统是活的	12
2.2 事务是工作的单元/计量单位	13
2.2.1 到达率	14
2.2.2 事务处理器	14
2.2.3 队列	16
2.2.4 事务流	16
.2.3 响应时间曲线	17
2.4 cpu和io子系统建模	19
2.5 方法是必须的	20
2.6 数据采集	21
2.7 基础数学	24
2.7.1 公式	24
2.7.2 应用程序	26
2.7.3 管理层需要知道什么	28
2.8 风险缓解策略	29
2.8.1 优化应用程序和oracle	30
2.8.2 购买更多的cpu能力	31
2.8.3 平衡现有的工作负载	33
2.9 小结	36
第3章 提高预测精度	37
3.1 预测陷阱	37
3.2 模型选择	38
3.2.1 要问的问题	38
3.2.2 基本预测模型	40
3.3 基线选择	43
3.4 响应时间数学	45
3.4.1 erlang c预测公式	45
3.4.2 对比预测公式	54
3.5 计算平均值	56
3.5.1 正确的分布模式	57
3.5.2 如何求多个值的平均值	58
3.6 案例研究：高光公司	61
3.6.1 确定研究课题	62
3.6.2 收集和描述工作负载	62
3.6.3 选择预测模型	62
3.6.4 预测和验证	63
3.6.5 我们告诉管理层什么	67
3.7 小结	68
第4章 基础预测统计	69
4.1 什么是统计	69
4.2 样本与总体	71
4.3 描述样本	71
4.3.1 用数值描述样本	71
4.3.2 可视化地描述数据样本	73
4.3.3 完整地描述样本数据	76
4.4 做出推断	81
4.4.1 使用总体标准差	82
4.4.2 使用标准误	82
4.5 骗人的精度	83
4.6 小结	86
第5章 实用排队论	87
5.1 排队系统符号	87
5.2 little法则	90
5.3 kendall的符号	94
5.4 排队论工作簿	96
5.5 队列配置和响应时间曲线位移	103
5.5.1 观察不同队列配置的影响	103
5.5.2 响应时间曲线的上下左右移动	108
5.6 应用排队论所面临的挑战	112
5.7 小结	123
第6章 系统化地预测性能	124
6.1 需要有一种方法	124
6.2 orapub的预测方法	125
6.2.1 确定研究课题	126
6.2.2 收集工作负载数据	128
6.2.3 描述工作负载	129
6.2.4 开发和使用适当的模型	130
6.2.5 验证预测	131
6.2.6 预测	135
6.3 小结	135
第7章 描述工作负载	136
7.1 面临的挑战	136
7.2 收集工作负载	137
7.2.1 收集操作系统数据	138
7.2.2 收集oracle数据	141
7.3 定义工作负载组成部分	143
7.4 对工作负载建模	144
7.4.1 简单工作负载模型	145
7.4.2 单类工作负载模型	146
7.4.3 多类工作负载模型	150
7.5 选择峰值	161
7.5.1 选择单一样本	163
7.5.2 汇总多个工作负载样本	164
7.6 小结	164
第8章 比例模型	166
8.1 比例模型概念	166
8.2 比例模型公式	167
8.3 收集和描述工作负载	168
8.4 推导比例	170
8.4.1 推导出批处理对cpu的比例	170
8.4.2 推导oltp对cpu的比例	173
8.5 比例模型预测	175
8.6 小结	178
第9章 线性回归模型	179
9.1 避免非线性领域	179
9.2 寻找关系	180
9.3 确定线性关系	183
9.3.1 查看原始数据	183
9.3.2 查看原始数据曲线图	184
9.3.3 查看残差数据	186
9.3.4 查看残差数据曲线图	187
9.3.5 查看回归公式	191
9.3.6 查看相关性强度	192
9.3.7 如果一切正常，执行预测	193
9.4 处理离群值	193
9.4.1 离群值的识别	195
9.4.2 确定何时停止	198
9.5 回归分析案例研究	199
9.6 小结	206
第10章 可扩展性	207
10.1 物理cpu和有效cpu之间的关系	207
10.2 预测时如何使用可扩展性	208
10.3 可扩展性涉及什么	210
10.4 加速和扩展	212
10.5 哪个预测模型受到可扩展性影响	213
10.6 可扩展性模型	214
10.6.1 阿姆达尔扩展	214
10.6.2 几何级数扩展	216
10.6.3 二次方扩展	217
10.6.4 超级串行扩展	219
10.7 确定可扩展性的方法	220
10.7.1 从物理cpu数据到有效cpu数据	220
10.7.2 基准：物理cpu数量对吞吐量的数据	224
10.7.3 真实系统：系统负载和吞吐量数据	226
10.8 小结	228
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle性能预测
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 11g权威指南(第2版）
第一部分  Oracle数据库11g基础第1章  数据库基础简介  1.1  数据库起源  1.2  数据库主要特征  1.3  数据库构成  1.4  数据库管理系统  1.5  关系数据库  1.6  本章小结第2章  Oracle 11g概述  2.1  Oracle数据库发展演进史  2.2  Oracle版本号的含义  2.3  Oracle网格技术    2.3.1  网格概述    2.3.2  网格的基本属性    2.3.3  Oracle网格基础架构  2.4  Oracle 11g新特性    2.4.1  企业网格管理的高可用性    2.4.2  更加优化的性能    2.4.3  简化的信息管理    2.4.4  集成的信息    2.4.5  内置的业务智能    2.4.6  开发平台  2.5  本章小结第3章  Oracle 11g数据库的安装、启动及关闭  3.1  在Windows环境下安装的软硬件要求  3.2  在Windows环境下安装Oracle 11g  3.3  在Linux环境下安装前的准备    3.3.1  安装Oracle 11g对硬件的要求    3.3.2  安装Oracle 11g对操作系统的要求    3.3.3  安装RedHat AS4操作系统时的注意事项    3.3.4  检查安装Oracle 11g所必需的包    3.3.5  内核参数配置    3.3.6  创建安装数据库所需要的用户(组)    3.3.7  添加Oracle用户的限制参数    3.3.8  创建安装所需要的目录    3.3.9  设置Oracle的环境变量    3.3.10  解压缩安装包  3.4  在Linux环境下安装Oracle 11g    3.4.1  Oracle用户图形终端方式登录    3.4.2  安装操作过程    3.4.3  登录OEM界面验证安装  3.5  Oracle 11g数据库实例的创建    3.5.1  在Windows环境下创建数据库    3.5.2  在Linux环境下用DBCA创建数据库  3.6  Oracle 11g实例的启动和关闭46    3.6.1  在Windows操作系统下启动和关闭Oracle实例    3.6.2  在Linux环境下启动Oracle实例    3.6.3  在Linux环境下关闭Oracle实例    3.6.4  在Linux环境下启动和关闭Oracle监听进程  3.7  本章小结第4章  Oracle数据库结构  4.1  Oracle体系结构    4.1.1  基本术语    4.1.2  体系结构图解    4.1.3  表空间与数据文件    4.1.4  临时表空间与临时文件    4.1.5  Oracle存储结构介绍    4.1.6  控制文件    4.1.7  日志文件    4.1.8  服务器参数文件    4.1.9  密码文件/跟踪文件/警告日志  4.2  Oracle服务器结构    4.2.1  Oracle服务器与Oracle实例    4.2.2  物理结构与逻辑结构的关系    4.2.3  系统全局区(SGA)    4.2.4  后台进程    4.2.5  程序全局区PGA  4.3  数据字典    4.3.1  Oracle数据字典的构成    4.3.2  Oracle常用的数据字典    4.3.3  Oracle常用的动态性能视图  4.4  本章小结  ……第二部分  Oracle之SQL＆PL/SQL第5章  SQL语言介绍第6章  PL/SQL基础编程第7章  PL/SQL高级应用第三部分  Oracle客户端工具第8章  SQL*Plus工具介绍第9章  Oracle SQL Developer工具介绍第四部分  Oracle 11g数据库管理第10章  管理控制文件第11章  管理日志文件第12章  管理表空间和数据文件第13章  模式对象管理第14章  表分区与索引分区第15章  用户管理与安全第16章  数据完整性和数据约束第17章  Oracle 11g Enterprise Manager简介第五部分  Oracle数据库优化第18章  Oracle系统调整第19章  Oracle SQL语句优化第六部分  Oracle 11g数据库的备份与恢复第20章  备份与恢复第21章  RMAN工具的使用第22章  Oracle闪回技术(Flashback)第23章  使用OEM向导备份和恢复数据库第24章  逻辑备份及数据导入/导出第七部分  Oracle 11g数据库集群技术与高可用性第25章  Oracle RAC应用第26章  自动存储管理(ASM)第27章  容灾与数据卫士第28章  故障诊断第29章  真正应用测试第八部分  商业智能与数据仓库第30章  ETL相关的功能第31章  多维数据库第32章  数据挖掘第九部分  非结构化数据库第33章  空间数据库第34章  XML数据库第十部分  Oracle 11g数据库的其他新特性第35章  Oracle 11g应用增强第36章  高级数据管理第37章  数据库升级参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 11g权威指南(第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle PL/SQL程序设计基础教程
译者序
前言
第一部分 数据库基础
第1章 数据库介绍	1
1.1 是什么数据库	1
1.1.1 表	1
1.1.2 行/记录	2
1.1.3 列/字段	2
1.2 数据库与电子表格有何不同	3
1.2.1 行数多	3
1.2.2 允许许多用户同时使用	3
1.2.3 安全	4
1.2.4 关系能力	4
1.2.5 保证数据质量的约束条件	5
1.3 怎样知道本书是否对你有用	6
1.3.1 在作为数据库管理员时	6
1.3.2 在开发软件时	6
1.3.3 在进行业务分析时	6
1.3.4 如果只想知道怎样更好地利用数据库	6
.1.4 sql的历史	7
1.5 sql命令种类	7
1.5.1 数据定义命令	8
1.5.2 数据操纵命令	8
1.5.3 数据控制命令	8
1.5.4 数据检索命令	8
1.5.5 事务处理控制命令	8
1.6 小结	9
1.7 习题	10
1.8 习题答案	11
第2章 数据存储和检索基础	12
2.1 一个快速的练习	12
2.1.1 建立一个表	12
2.1.2 插入记录	13
2.1.3 选择记录	14
2.1.4 删除表	14
2.2 建立表	16
2.2.1 表和列的命名准则	16
2.2.2 建立更复杂的表	20
2.2.3 显示表的结构	26
2.2.4 null和not null列	27
2.3 插入数据	28
2.3.1 怎样插入包含null值的记录	29
2.3.2 怎样插入包含单引号的数据	31
2.4 查看数据	32
2.4.1 选择特定的列	32
2.4.2 改变列的次序	33
2.4.3 利用表中数据进行计算	34
2.4.4 将两个或多个文本连接在一起	36
2.4.5 对列指定别名	37
2.5 小结	37
2.6 习题	39
2.7 习题答案	41
第3章 高级数据操纵	42
3.1 限定所选择的记录	42
3.1.1 基于数值过滤记录	42
3.1.2 基于文本过滤记录	46
3.1.3 基于日期过滤记录	48
3.2 改变记录顺序	49
3.3 显示唯一值	52
3.4 从dual中选择	54
3.5 更改表中的数据	55
3.6 删除表中的记录	56
3.6.1 删除匹配指定条件的行	56
3.6.2 删除所有的行	57
3.7 事务处理控制	57
3.7.1 撤消dml事务处理	57
3.7.2 使数据为其他人所用	61
3.7.3 隐式和显式的commit	62
3.8 小结	62
3.9 习题	63
3.10 习题答案	64
第4章 控制sql*plus	65
4.1 编辑命令	65
4.1.1 使用文本编辑器	65
4.1.2 行编辑	67
4.2 复制和粘贴	69
4.3 清除sql*plus屏幕	71
4.4 定制sql*plus环境	71
4.4.1 用sql*plus菜单进行定制	71
4.4.2 使用命令进行定制	73
4.5 保存环境定制值	73
4.6 产生更可读的输出	74
4.6.1 在sql*plus中格式化数值	74
4.6.2 sql*plus中的格式化文本	76
4.6.3 格式化sql*plus的列标题	76
4.7 将输出结果假脱机到磁盘	78
4.8 sql脚本文件	78
4.8.1 建立脚本文件	79
4.8.2 运行脚本文件	79
4.8.3 在脚本文件中使用变量	80
4.9 小结	82
4.10 习题	82
4.11 习题答案	83
第二部分 高级sql
第5章 sql函数	85
5.1 常用的单行函数	86
5.1.1 系统变量函数	86
5.1.2 数值函数	88
5.1.3 文本函数	90
5.1.4 日期函数	100
5.1.5 数据转换函数	105
5.1.6 其他函数	112
5.2 常用的分组函数	119
5.2.1 利用group by子句分组数据	121
5.2.2 利用having子句包含和排除分组
的行	123
5.3 小结	124
5.4 习题	124
5.5 习题答案	125
第6章 使用索引和约束条件	127
6.1 索引	129
6.1.1 数据库的索引	129
6.1.2 索引何时有用	130
6.1.3 如何建立索引	131
6.1.4 各种索引类型	132
6.2 保持数据的完整性：约束条件	134
6.2.1 什么是约束条件	134
6.2.2 怎样建立约束条件	134
6.2.3 启用和禁止已有的约束条件	141
6.2.4 更改和删除已有的约束条件	143
6.2.5 约束条件使用范围	144
6.3 表之间的关系	145
6.3.1 数据模型介绍	145
6.3.2 使用约束条件加强表之间的关系	146
6.3.3 编写select语句显示多个表中的
数据	151
6.3.4 外部连接	154
6.3.5 连接运算符	155
6.4 编写子查询	158
6.4.1 什么是子查询	158
6.4.2 子查询可以解决的问题类型	158
6.4.3 单行子查询	158
6.4.4 多行子查询	160
6.4.5 多列子查询	161
6.5 小结	162
6.6 习题	163
6.7 习题答案	164
第7章 其他有用的oracle技术	165
7.1 在表之间传输数据	168
7.1.1 利用insert传输数据	169
7.1.2 基于已有的表建立新表	170
7.2 重新命名表	171
7.3 更改表的结构	172
7.3.1 增加列	172
7.3.2 更改列的数据类型	173
7.3.3 更改空值选项	173
7.4 视图	174
7.4.1 建立视图	175
7.4.2 删除视图	176
7.4.3 更改视图的定义	177
7.4.4 top n分析	177
7.5 其他数据库对象	178
7.5.1 序列	178
7.5.2 同义词	181
7.5.3 oracle数据字典	183
7.6 小结	183
7.7 习题	185
7.8 习题答案	186
第三部分 用pl/sql编程
第8章 pl/sql	187
8.1 pl/sql介绍	187
8.1.1 pl/sql描述	191
8.1.2 pl/sql、sql和sql*plus之间的
关系	191
8.1.3 存储过程、函数和触发器	191
8.1.4 存储过程和sql脚本	193
8.2 pl/sql块的结构	193
8.2.1 标题部分	194
8.2.2 定义部分	195
8.2.3 执行部分	195
8.2.4 异常部分	195
8.3 建立一个简单的pl/sql过程	196
8.4 pl/sql变量和常量	198
8.4.1 定义pl/sql变量	199
8.4.2 定义pl/sql常量	199
8.4.3 给变量赋值	199
8.4.4 使用变量	201
8.5 pl/sql中的控制结构	201
8.5.1 if语句	202
8.5.2 循环	204
8.5.3 游标	207
8.5.4 嵌套循环与游标例子	210
8.6 错误处理	213
8.6.1 异常	213
8.6.2 系统定义异常	213
8.6.3 程序员定义的异常	215
8.7 小结	216
8.8 习题	216
8.9 习题答案	217
第9章 其他pl/sql工具	219
9.1 编码约定	223
9.2 关于pl/sql和oracle服务器的更多
知识	224
9.2.1 定义动态变量和pl/sql记录	224
9.2.2 pl/sql中的dml或隐式游标	228
9.2.3 隐式游标与显式游标	232
9.3 计时操作	232
9.3.1 用一个程序来度量时间	233
9.3.2 使用timing命令记录实际的时间	235
9.4 pl/sql程序包	236
9.5 触发器	241
9.5.1 触发器类型	243
9.5.2 触发器举例	243
9.5.3 修改触发器	246
9.5.4 关于触发器的要点	247
9.6 odbc	247
9.6.1 建立odbc连接	248
9.6.2 odbc连接的应用	252
9.7 小结	256
9.8 习题	257
9.9 习题答案	257
术语	259
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle PL/SQL程序设计基础教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Fusion Middleware 11g架构与管理
目    录

第Ⅰ部分  Oracle Fusion Middleware 11g架构与管理
第1章  Fusion Middleware入门	3
1.1  企业应用程序和中间件	3
1.2  Oracle Fusion Middleware产品	5
1.2.1  集成开发环境与框架	5
1.2.2  应用网格	7
1.2.3  身份管理	8
1.2.4  面向服务的架构	8
1.2.5  用户体验	9
1.2.6  内容管理、数据集成与
商业智能	9
1.3  小结	11
第2章  Oracle WebLogic Server	13
2.1  Oracle WebLogic Server简介	14
2.1.1  服务器、群集和域	14
2.1.2  安装和域组件	15
2.1.3  服务器启动和节点管理器	18
2.2  应用程序容器和部署	19
2.2.1  应用程序容器	20
2.2.2  应用程序部署	25
2.2.3  共享库	28
2.2.4  部署模式	28
2.2.5  部署计划	28
2.3  管理功能	30
2.3.1  域创建和模板	30
2.3.2  WebLogic Java Management
Extension MBean Server	31
2.3.3  WebLogic Server Scripting
Tool	33
2.4  身份验证和授权服务	34
2.4.1  嵌入式LDAP	35
2.4.2  安全提供者	35
2.4.3  用户、组、角色和授权
策略	36
2.5  JDBC服务	38
2.6  JMS服务	41
2.6.1  JMS服务器	41
2.6.2  JMS模块	43
2.7  WebLogic Server请求管理	44
2.7.1  连接和端口管理	44
2.7.2  Work Manager	45
2.8  本章用例	47
2.8.1  用例描述	47
2.8.2  理解应用程序及其环境	47
2.8.3  设计评估环境	49
2.9  小结	52
第3章  Fusion Middleware公共基础
设施	53
3.1  Fusion Middleware公共基础
设施简介	53
3.1.1  系统组件、实例和场	54
3.1.2  OPMN	55
3.1.3  安装和配置工件	56
3.2  Enterprise Manager Fusion
Middleware Control	60
3.3  元数据存储库服务	65
3.3.1  元数据管理	65
3.3.2  部署模型	66
3.3.3  运行时架构	67
3.4  Oracle Web Services Manager	68
3.4.1  策略管理	68
3.4.2  运行时架构	70
3.5  本章用例	72
3.5.1  用例描述	72
3.5.2  创建扩展的应用程序域	74
3.5.3  将应用程序作为Oracle HTTP
Server的前端	76
3.5.4  使用Oracle Web Services Manager
保护应用程序Web服务的
安全	78
3.6  小结	79
第4章  Oracle Fusion Middleware
平台安全服务和身份管理	81
4.1  Oracle平台安全服务简介	82
4.1.1  体系结构概述	82
4.1.2  身份、身份存储和
身份认证提供者	83
4.1.3  策略和策略存储	83
4.1.4  凭据和凭据存储	85
4.1.5  User & Role API	85
4.1.6  审计框架	86
4.1.7  Oracle Security Developer
Tools	87
4.1.8  OPSS策略模型和Oralce
Authorization Policy
Manager	88
4.2  Oracle身份管理简介	91
4.2.1  Oracle Internet Directory	92
4.2.2  Oracle Directory Server
Enterprise Edition	92
4.2.3  Oracle Virtual Directory	92
4.2.4  Oracle Access Manager	93
4.2.5  Oracle Identity Federation	95
4.2.6  Oracle Enterprise Single
Sign-On	95
4.2.7  Oracle Adaptive Access
Manager	96
4.2.8  Oracle Entitlements Server	97
4.2.9  Oracle Identity Manager	97
4.2.10  Oracle Identity Analytics	99
4.3  本章用例	99
4.3.1  配置身份存储	100
4.3.2  使用User & Role API	101
4.3.3  使用OAM配置单点登录	102
4.3.4  管理凭据存储	103
4.3.5  配置组件审计	103
4.4  小结	105
第5章  Oracle面向服务的
架构套件	107
5.1  Oracle SOA套件介绍	108
5.1.1  SOA平台方案	108
5.1.2  SOA套件组件	109
5.2  SOA基础设施	110
5.2.1  组合容器	111
5.2.2  服务组件架构入门	112
5.2.3  组合的生命周期	114
5.2.4  部署组合	115
5.2.5  组合服务和引用	118
5.2.6  组合管理	123
5.2.7  传感器和传感器动作	126
5.2.8  WebLogic脚本工具	127
5.3  Oracle业务活动监控	128
5.3.1  Oracle BAM组件和架构	128
5.3.2  Oracle BAM管理	131
5.4  用户消息服务	134
5.5  本章用例	136
5.5.1  用例描述	136
5.5.2  设置适当的用户、群组
及角色	138
5.5.3  设置SOA组合	139
5.5.4  配置Oracle BAM	141
5.6  小结	141
第6章  Oracle应用程序开发框架	143
6.1  ADF简介	143
6.2  架构	144
6.2.1  视图层	145
6.2.2  控制器层	146
6.2.3  ADF Binding层	146
6.2.4  ADF业务组件	146
6.2.5  ADF元数据和自定义	147
6.3  管理ADF应用程序	148
6.3.1  部署ADF应用程序	148
6.3.2  配置ADF应用程序	150
6.3.3  配置连接	150
6.3.4  配置ADF业务组件	151
6.3.5  配置MDS	152
6.3.6  配置MDS自定义	155
6.4  升级应用程序和最佳做法	155
6.5  本章用例	156
6.6  小结	158
第7章  Oracle WebCenter	159
7.1  Oracle WebCenter简介	159
7.1.1  安装WebCenter	160
7.1.2  WebCenter Composer	162
7.1.3  WebCenter Composer管理	163
7.1.4  WebCenter Enterprise 2.0
服务	167
7.2  管理Enterprise 2.0服务	168
7.2.1  连接	169
7.2.2  服务属性	172
7.2.3  服务任务流	172
7.2.4  Enterprise 2.0服务中的
测试—生产迁移	173
7.3  WebCenter门户技术	174
7.3.1  管理门户生产者连接	175
7.3.2  门户自定义设置和个性化
设置	178
7.3.3  门户应用程序的测试—生产
迁移	179
7.3.4  WebCenter门户元数据	179
7.3.5  高级功能	181
7.4  WebCenter空间	181
7.4.1  管理Oracle WebCenter
空间	182
7.4.2  Spaces应用程序管理	183
7.4.3  空间的测试—生产迁移	189
7.5  本章用例	192
7.6  小结	195
第Ⅱ部分  部署和管理Fusion Middleware中的企业
应用程序
第8章  部署Fusion Middleware
企业应用程序	199
8.1  定价应用程序概述	200
8.2  创建单个节点的拓扑结构	201
8.2.1  用于创建环境的整体
事件流	203
8.2.2  安装Fusion Middleware
软件	203
8.2.3  配置初始环境	208
8.2.4  部署定价应用程序工件	224
8.2.5  配置Oracle HTTP服务器	231
8.3  扩展群集用于可扩展性	232
8.3.1  扩展WebLogic Server定价
群集	232
8.3.2  配置客户端	236
8.4  小结	237
第9章  保护Fusion Middleware
企业应用程序	239
9.1  保护定价应用程序	240
9.2  保护部署时的整体事件流	241
9.3  保护物理主机	241
9.4  保护SSL通信	243
9.4.1  密钥库和钱包管理	245
9.4.2  在Web层配置SSL	245
9.4.3  在Oracle Internet Directory中为
Oracle平台安全性服务配置
SSL	248
9.4.4  其他SSL考虑	251
9.5  保护访问Oracle Internet Directory
的Oracle平台安全服务	251
9.6  配置单点登录	252
9.6.1  安装WebGate	252
9.6.2  创建并注册WebGate
实例	253
9.7  保护Web服务	254
9.8  配置审核	255
9.8.1  安装审核架构	255
9.8.2  配置审核存储库	256
9.8.3  配置审核策略	259
9.8.4  设置Business Intelligence
Publisher	259
9.9  小结	261
第10章  优化Fusion Middleware
企业应用程序	263
10.1  性能优化	264
10.2  余下部分的结构	264
10.3  优化Java Virtual Machine和
WebLogic Server	265
10.3.1  Java Virtual Machine	265
10.3.2  WebLogic Server	269
10.3.3  优化定价应用程序的Java
Virtual Machine和WebLogic
Server配置	271
10.4  优化Fusion Middleware共享
基础设施	277
10.4.1  Oracle Web Services
Manager	277
10.4.2  元数据存储库服务	279
10.5  优化分层的Fusion Middleware
组件	281
10.5.1  SOA Suite	281
10.5.2  应用程序开发框架	282
10.5.3  WebCenter	283
10.6  小结	286
第11章  监控和诊断Fusion Middleware
企业应用程序	287
11.1  理解Fusion Middleware
日志	288
11.1.1  WebLogic Server日志
基础设施	288
11.1.2  Oracle Diagnostics
Logging	293
11.2  使用WebLogic Diagnostics
Framework	297
11.2.1  诊断图像	298
11.2.2  诊断模块	300
11.2.3  Administration Console
监控	305
11.3  配置和使用节点管理器	306
11.4  小结	309
第12章  虚拟化Fusion Middleware
企业应用程序	311
12.1  Oracle Virtual Machine	312
12.2  JRockit和WebLogic Server
Virtual Edition	315
12.2.1  JRockit Virtual Edition	315
12.2.2  WebLogic Server Virtual
Edition	316
12.2.3  JRockit VE上的定价
应用程序	318
12.3  Oracle Virtual Assembly
Builder	318
12.4  Oracle Exalogic	320
12.4.1  Exalogic硬件	320
12.4.2  Exalogic软件	321
12.4.3  Exalogic虚拟平台	322
12.5  小结	323

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Fusion Middleware 11g架构与管理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle PL/SQL必知必会
版权
版权声明
内容提要
关于作者
致谢
关于译者
前言
第1章　了解SQL
第2章　初识Oracle和PL/SQL
第3章　使用Oracle
第4章　检索数据
第5章　对检索的数据进行排序
第6章　过滤数据
第7章　高级数据过滤
第8章　使用通配符过滤
第9章　使用正则表达式执行搜索
第10章　创建计算字段
第11章　使用数据操作函数
第12章　汇总数据
第13章　分组数据
第14章　使用子查询
第15章　连接表
第16章　创建高级连接
第17章　组合查询
第18章　插入数据
第19章　更新和删除数据
第20章　创建和操作表
第21章　使用视图
第22章　使用存储过程
第23章　使用游标
第24章　使用触发器
第25章　管理事务处理
第26章　管理安全性
附录A　示例表
附录B　Oracle PL/SQL数据类型
附录C　Oracle PL/SQL的保留字和关键字
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle PL/SQL必知必会
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8i初学者指南
贺辞序译者序伍德利序前

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8i初学者指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>名师讲坛——Oracle开发实战经典
第1部分  Oracle开发前奏

第1章  数据库系统概述	2
（视频讲解：1小时10分钟）
1.1  数据库的产生动机	3
1.2  数据、数据库、数据库管理系统、数据库系统	4
1.3  数据管理与数据库系统的特点	6
1.4  数据模型	8
1.4.1  两类数据模型	8
1.4.2  概念模型	10
1.4.3  数据模型	14
1.4.4  关系模型基础	19
1.5  SQL概述	21
提示：关于NOSQL技术	22
1.6  本章小结	22
第2章  Oracle的安装与基本使用	23
（视频讲解：1小时40分钟）
2.1  Oracle简介	24
2.2  安装Oracle数据库	25
提示：关于CDB与PDB	29
注意：如果不进行口令配置，有可能
某些用户为锁定状态	32
2.3  Oracle体系结构	33

提示：Oracle服务器、Oracle实例
（instance）、Oracle数据库
（database）的关系	34
2.3.1  Oracle实例体系	34
2.3.2  Oracle物理体系	38
2.4  Oracle监听服务	38
2.4.1  注册表被破坏导致监听无法
启动	39
2.4.2  计算机名称修改导致监听无法
启动	39
2.4.3  监听工具LSNRCTL	40
2.5  SQLPlus简介	41
2.6  SQLPlus常用命令	42
提示：关于sqlplus.exe工具的
补充说明	42
提示：sqlplusw.exe的输入形式	44
提示：需要设置命令行格式	45
2.7  配置SQL Developer	48
2.8  c##scott用户表	51
2.8.1  部门表dept	51
2.8.2  雇员表emp	52
2.8.3  工资等级表salgrade	52
2.8.4  工资补贴表bonus	53
2.9  本章小结	53
第2部分  SQL基础语法
第3章  简单查询	56
（视频讲解：35分钟）
3.1  简单查询语句	57
提示：关于null的问题	57
提示：关于SQL中的投影概念	59
3.2  其他简单查询	60
3.3  本章小结	65
第4章  限定查询与排序显示	66
（视频讲解：1小时12分钟）
4.1  限定查询	67
4.1.1  认识限定查询	67
提示：一般在执行查询之前都先查看
一下表中的记录数	67
4.1.2  对数据进行限定查询	70
提示：阅读查询语句的小技巧	71
注意：在使用NOT IN操作符时列表不能有NULL	78
4.2  对结果排序：ORDER BY	82
提示：语句执行顺序	82
4.3  本章小结	84
第5章  单行函数	85
（视频讲解：2小时6分钟）
5.1  单行函数简介	86
5.2  字符函数	87
5.3  数值函数	92
5.4  日期函数	94
提示：关于日期和数字的问题	95
5.5  转换函数	101
注意：建议保留前导0	102
提示：关于数据的隐式转换操作	103
5.6  通用函数	106
5.7  本章小结	112
第6章  多表查询	113
（视频讲解：1小时30分钟）
6.1  多表查询的基本语法	114
提示：关于笛卡尔积的代数表示	115
提示：关于笛卡尔积的消除	117
6.2  多表查询实例	117
6.3  表的连接操作	121
提示：左外连接与右外连接的操作	123
6.4  自身关联	125
6.5  SQL:1999语法	129
6.5.1  交叉连接	129
6.5.2  自然连接	130
提示：自然连接的操作	130
6.5.3  USING子句	131
6.5.4  ON子句	132
提示：关于θ连接	132
6.5.5  外连接	133
6.6  数据的集合运算	135
6.7  本章小结	138
第7章  分组统计查询	139
（视频讲解：1小时20分钟）
7.1  统计函数	140
7.2  单字段分组统计	142
提示：分享一下个人的分组规律	145
7.3  多字段分组统计	149
7.4  HAVING子句	152
7.5  本章小结	156
第8章  子查询	157
（视频讲解：4小时3分钟）
8.1  认识子查询	158
8.2  在WHERE子句中使用子
查询	160
8.2.1  子查询返回单行单列数据	160
8.2.2  子查询返回单行多列数据	162
8.2.3  子查询返回多行单列数据	164
提示：关于SOME操作符	168
8.2.4  空数据判断	170
8.3  在HAVING子句中使用
子查询	170
8.4  在FROM子句中使用
子查询	172
8.5  在SELECT子句中使用
子查询	180
8.6  WITH子句	181
8.7  分析函数	182
8.7.1  分析函数基本语法	183
提示：关于"分组"与"分区"	183
8.7.2  分析函数范例	191
8.8  行列转换	197
提示：使用XML与ANY	200
8.9  设置数据层次	205
8.10  本章小结	210
第9章  更新及事务处理	211
（视频讲解：1小时32分钟）
9.1  更新操作前的准备	212
9.2  数据的增加操作	213
9.2.1  增加数据	213
9.2.2  增加子查询结果数据	215
9.3  数据的更新操作	215
9.3.1  由用户指定更新数据	216
9.3.2  使用已有数据更新数据表	217
9.4  数据的删除操作	217
9.5  事务处理	218
9.6  锁	225
9.6.1  行级锁定	227
9.6.2  表级锁定	227
9.6.3  解除锁定	228
9.7  本章小结	229
第10章  替代变量	230
（视频讲解：43分钟）
10.1  替代变量的基本概念	231
10.2  替代变量的详细说明	233
10.3  定义替代变量	236
10.4  ACCEPT指令	237
10.5  本章小结	240
第11章  表的创建与管理	241
（视频讲解：1小时48分钟）
11.1  数据表的基本概念	242
11.2  Oracle常用数据类型	242
11.3  表的创建	243
11.4  表的复制	246
11.5  数据表重命名	248
11.6  截断表	249
11.7  表的删除	250
11.8  闪回技术（FlashBack）	250
11.9  修改表结构	253
11.10  添加注释	257
11.11  设置可见/不可见字段	258
11.12  表空间	261
提示：关于数据库系统的三级
模式结构	261
提示：关于数据库、表空间、表的
简单理解	263
提示：关于非系统表空间的称呼	263
11.12.1  创建表空间	264
提示：Oracle中的默认表空间	265
11.12.2  使用表空间	266
11.13  本章小结	267
第12章  完整性约束	268
（视频讲解：2小时20分钟）
12.1  数据库完整性约束简介	269
12.2  非空约束NK	270
12.3  唯一约束UK	270
12.4  主键约束PK	272
12.5  检查约束CK	274
12.6  主-外键约束FK	275
12.7  查看约束	283
12.8  修改约束	284
注意：在为表中添加约束时一定要保证表中的数据没有违反约束	285
12.9  数据库综合实战	288
12.9.1  建立数据表	288
12.9.2  为数据表增加数据	290
12.9.3  数据操作	293
12.10  本章小结	298
第13章  其他数据库对象	299
（视频讲解：2小时46分钟）
13.1  视图	300
13.1.1  创建视图	301
提示：关于Oracle 12c创建视图时出现的权限不足的错误	302
13.1.2  在视图上执行DML操作	304
13.1.3  WITH CHECK OPTION
子句	308
13.1.4  WITH READ ONLY子句	310
13.1.5  删除视图	311
13.2  序列	312
13.2.1  序列的作用及创建	312
13.2.2  序列的删除	314
13.2.3  创建特殊功能的序列	315
提示：设置缓存有可能造成跳号
的情况	316
13.2.4  修改序列	318
13.2.5  自动序列	319
注意：自动序列对象的删除	321
13.3  同义词	321
13.4  Oracle伪列	323
13.4.1  ROWID伪列	324
13.4.2  ROWNUM伪列	326
13.4.3  Oracle 12c新特性FETCH	332
13.5  索引	334
提示：关于索引深层次学习	334
13.5.1  B*Tree索引	334
提示：关于全表扫描	335
13.5.2  位图索引	340
13.5.3  删除索引	341
13.6  本章小结	341
第14章  用户权限及角色管理	343
（视频讲解：1小时23分钟）
14.1  用户管理	344
14.1.1  创建用户	344
注意：Oracle 12c的新限制	345
14.1.2  概要文件（profiles）	346
14.1.3  维护用户	348
14.1.4  删除用户	350
注意：删除用户是一个危险操作	350
14.2  权限管理	350
14.2.1  系统权限	350
提示：SYSOPER和SYSDBA权限	352
提示：用户SESSION连接	353
14.2.2  对象权限	355
14.3  角色	357
14.3.1  创建角色	358
14.3.2  角色授权	359
14.3.3  为用户授予角色	359
14.3.4  修改角色及回收角色权限	360
14.3.5  删除角色	361
14.3.6  预定义角色	361
14.4  本章小结	362
第15章  数据库设计	363
（视频讲解：1小时36分钟）
15.1  数据库设计概述	364
15.2  概念模型与E-R图概述	365
15.2.1  实体	365
15.2.2  属性	366
15.2.3  联系	366
15.2.4  E-R模型实例	367
15.3  数据库设计范式	370
15.3.1  第一范式（1NF）	371
15.3.2  第二范式（2NF）	372
提示：关于函数依赖的解释	372
15.3.3  第三范式（3NF）	377
15.3.4  鲍依斯-科得范式（BCNF）	379
15.4  Sybase PowerDesigner设计
工具	381
15.4.1  概念模型设计	381
15.4.2  物理数据模型设计	385
15.5  数据库设计案例	386
15.5.1  功能描述	387
15.5.2  概念模型	388
15.5.3  物理数据模型	389
15.6  本章小结	397

第3部分  数据库编程
第16章  PL/SQL编程基础	400
（视频讲解：3小时）
16.1  PL/SQL简介	401
16.2  变量的声明与赋值	403
16.2.1  声明并使用变量	403
提示：关于Oracle关键字说明	403
注意：PL/SQL中的变量不区分
大小写	404
16.2.2  使用%TYPE声明变量
类型	405
16.2.3  使用%ROWTYPE声明变
量类型	405
16.3  运算符	406
16.3.1  赋值运算符	407
16.3.2  连接运算符	407
16.3.3  关系运算符	408
16.3.4  逻辑运算符	408
16.4  数据类型划分	410
16.5  标量类型	410
16.5.1  数值型	411
提示：关于数据溢出问题	413
16.5.2  字符型	415
16.5.3  日期型	418
16.5.4  布尔型	421
16.5.5  子类型	421
16.6  程序结构	422
16.6.1  分支结构	423
提示：Oracle也支持正则验证	426
16.6.2  循环结构	431
16.6.3  循环控制	433
16.6.4  GOTO语句	435
16.7  内部程序块	435
16.8  异常处理	436
16.8.1  异常简介	437
16.8.2  使用EXCEPTION来
处理异常	438
16.8.3  用户自定义异常	442
16.9  本章小结	447
第17章  集合	448
（视频讲解：2小时52分钟）
17.1  记录类型	449
17.2  索引表	454
17.3  嵌套表	457
17.3.1  定义简单类型嵌套表	457
17.3.2  定义复合类型嵌套表	460
17.3.3  在PL/SQL中使用嵌套表	463
17.4  可变数组	468
17.4.1  定义简单类型的可变数组	468
17.4.2  定义复合类型的可变数组	470
17.4.3  在PL/SQL中使用可变
数组	471
17.5  集合运算符	473
17.6  集合函数	476
17.7  处理集合异常	481
17.8  使用FORALL批量绑定	483
17.9  BULK COLLECT批量接收
数据	484
17.10  本章小结	485
第18章  游标	486
（视频讲解：1小时19分钟）
18.1  游标简介	487
18.2  隐式游标	487
18.3  显式游标	489
18.4  修改游标数据	498
18.4.1  FOR UPDATE子句	499
18.4.2  WHERE CURRENT OF
子句	500
18.5  游标变量	502
18.6  本章小结	505
第19章  子程序	506
（视频讲解：2小时26分钟）
19.1  子程序定义	507
19.1.1  定义过程	507
19.1.2  定义函数	509
19.2  查询子程序	512
19.3  删除子程序	515
19.4  参数模式	516
提示：不再重复演示函数的
参数模式	518
19.5  子程序嵌套	522
19.6  NOCOPY选项	527
19.7  自治事务	530
19.8  子程序权限	531
19.9  利用Java调用子程序	533
19.10  本章小结	535
第20章  包	536
（视频讲解：1小时38分钟）
20.1  包的定义及使用	537
20.1.1  包的基本概念	537
20.1.2  重新编译包	541
20.1.3  包的作用域	541
20.1.4  重载包中的子程序	543
20.1.5  包的初始化	544
20.1.6  包的纯度级别	546
注意：关于公用函数的说明	548
20.2  系统工具包	548
20.2.1  DBMS_OUTPUT包	548
20.2.2  DBMS_JOB包与数据库
作业	551
20.2.3  DBMS_ASSERT包	555
提示：利用DBMS_ASSERT可以解决SQL注入攻击	556
20.2.4  DBMS_LOB包	556
20.3  本章小结	559
第21章  触发器	560
（视频讲解：3小时30分钟）
21.1  触发器简介	561
21.2  DML触发器	562
21.3  表级DML触发器	564
21.4  行级DML触发器	568
21.4.1  使用":old.字段"和":new.字段"标识符	568
注意：不能将":new"或":old"设置为ROWTYPE类型	571
21.4.2  使用REFERENCING子句
设置别名	575
21.4.3  使用WHEN子句定义
触发条件	575
21.4.4  触发器谓词	577
21.4.5  使用FOLLOWS子句	578
21.5  变异表	580
21.6  复合触发器	581
21.7  instead-of触发器	586
21.7.1  在视图上定义替代触发器	586
21.7.2  在嵌套表上定义替代
触发器	591
21.8  DDL触发器	593
21.9  系统触发器	599
21.10  管理触发器	603
提示：Oracle 11g之后可以建立禁用
触发器	604
21.11  触发器中调用子程序	605
21.12  本章小结	606
第22章  动态SQL	607
（视频讲解：1小时17分钟）
22.1  动态SQL简介	608
提示：如果不使用EXECUTE
IMMEDIATE，则程序会
出现错误	609
提示：在get_table_count_fun()函数执行时可能出现"ORA-01031：权限不足"错误提示	610
22.2  EXECUTE IMMEDIATE
语句	610
22.2.1  执行动态SQL	611
22.2.2  设置绑定变量	612
22.2.3  接收DML更新行数	614
提示：也可以使用RETURN接收
影响数据行的数据	615
22.3  批量绑定	616
22.4  处理游标操作	618
22.5  DBMS_SQL包简介	620
22.6  本章小结	623
第23章  面向对象编程	624
（视频讲解：2小时35分钟）
23.1  面向对象简介	625
23.2  类与对象	625
23.3  定义对象类型--类	626
23.4  操作类中的其他结构	630
23.4.1  定义函数	630
23.4.2  构造函数	632
提示：关于默认构造函数	632
23.4.3  定义MAP与ORDER
函数	633
23.4.4  对象嵌套关系	637
23.4.5  继承性	639
23.4.6  函数覆写	641
23.4.7  对象多态性	642
23.4.8  使用FINAL关键字	644
23.4.9  定义抽象函数	645
23.5  对象表	646
23.5.1  创建对象表	648
23.5.2  维护对象表数据	649
23.6  对象视图	655
23.7  本章小结	656



>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>名师讲坛——Oracle开发实战经典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle性能优化科学与艺术
第1章 性能优化的挑战
1．1 为什么要进行性能优化
1．2 编写本书的原因
1．3 本书读者对象
1．4 读者的好消息
1．5 医师到魔术师的方法
1．5．1 可适应性的需要
1．5．2 理解而非技巧
1．5．3 避免猜测
1．5．4 银弹
1．5．5 解决错误问题
1．5．6 揭露一个大秘密
1．5．7 与Oracle保持同步更新
1．6 艺术还是科学
1．7 预优化
1．8 小结
第2章 许多优化策略失败的原因
2．1 失败的策略
2．2 不完善的性能优化方法
2．2．1 银弹方法
2．2．2 偷工减料
2．2．3 快速培训班
2．2．4 偏爱的思想
2．2．5 解决错误的问题
2．2．6 猜测法
2．2．7 避免责备
2．2．8 其他障碍
2．3 小结
第3章 Oracle医师
3．1 定义问题
3. 1. 1 确定需求
3．1．2 定义需求的艺术
3．1．3 切忌孤军奋战
3．1．4 Oracle医生的"就职誓言"
3．1．5 无需太多的技术
3．2 找到主诉症状
3．2．1 "数据库是坏的"
3．2．2 仔细倾听
3．2．3 适时地问一些问题
3．2．4 查看所展示的问题
3．2．5 必要时寻求帮助
3．3 小结
第4章 处理人际关系
4．1 性能优化问题中的人为因素
4．2 DBA的角色
4．2．1 集中解决客户的问题
4．2．2 采取一个积极的方法
4．2．3 建立相互信任的人际关系
4．2．4 准确地报告问题
4．2．5 避免傲慢的态度
4．2．6 承担责任
4．2．7 避免责备
4．2．8 询问问题
4．2．9 接受批评
4．3 小结
第5章 Oracle侦探
5．1 验证问题的存在
5．1．1 问题确实存在吗
5．1．2 检查基本信息
5．1．3 错误消息
5．1．4 在控制环境下重新运行应用程序
5．1．5 检查运行日志
5．1．6 查询V$SQL视图以找到SQL语句
5．1．7 未使用绑定变量所带来的问题
5．1．8 采用工具监控应用程序
5．1．9 监视活动和非活动会话
5．2 量化问题
5. 2. 1 需要关注的问题
5．2．2 方法
5．2．3 生成跟踪文件
5．2．4 计时信息
5．2．5 许可及文件大小
5．2．6 TKPROF
5．3 注意所有异常因素
5．4 小结
第6章 收集更多的线索
6．1 等什么
6．2 等待事件的类型
6．3 视图概述
6．3．1 V$EVENT_NAME
6．3．2 V$SYSTEM_EVEN7
6．3．3 V$SESSION_EVENT
6．3．4 V$SESSION_WAIT
6．4 使用系统事件10046进行跟踪
6．5 等待事件的使用例子
6．6 重要的警告
6．6．1 不是数据库引起的延迟
6．6．2 无法监测CPU时间
6．6．3 没有监测到的逻辑读
6．6．4 时间精确度
6．7 小结
第7章 Oracle病理学家
7．1 隔离根本原因
7．2 找出性能降低的根源
7．2．1 找出真正的原因
7．2．2 性能预算
7．3 简化
7．4 分治法
7．4．1 分化SQL代码
7．4．2 简化表连接
7．5 活动时间表方法
7．6 性能问题的常见原因
7．6．1 应用程序设计
7．6．2 数据库设计
7．6．4 批处理任务的干扰
7．6．5 硬件
7．7 寻找根本原因的其他建议
7．7．1 简单的计时测试
7．7．2 大的结果集
7．8 小结
第8章 分析SQL瓶颈
8．1 SQL优化的作用
8．1．1 SQL分析人员的好消息
8．1．2 SQL分析的其他好处
8．2 使用新的数据库功能
8．2．1 需要重新学习一些内容
8．2．2 更改过程中的稳定性
8．2．3 工具集中的新工具
8．3 从哪儿开始
8．3．1 查看统计数字
8．3．2 产生新的统计数字
8．3．3 确保运行的SQL可实现预期的功能
8．3．4 查看结果集的大小
8．3．5 各种优化过程入口的汇总
8．4 Oracle执行计划
8．4．1 获得执行计划
8．4．2 准备使用EXPLAINPLAN功能
8．4．3 运行EXPLANPLAN语句
8．4．4 执行计划的内容
8．4．5 Oracle提供的其他脚本
8．4．6 使用SQL*PlusAUTOTRACE获得执行计划
8．4．7 解释执行计划
8．5 视图和过滤
8．6 子查询
8．7 SQL优化的其他技巧
8．7．1 对象浏览工具
8．7．2 索引浏览工具
8．7．3 注意全表扫描
8．7．4 不要忽略逻辑读
8．7．5 指导开发人员
8．7．6 考虑缓存效果
8．8 计划表更为高级的功能
8．9 小结
第9章 分析SQL连接
9．1 什么是连接
9．1．1 等值连接和9连接
9．1．2 内连接
9．1．3 外连接
9．2 连接技巧
9．2．1 嵌套循环
9．2．2 排序合并
9．2．3 哈希连接
9．2．4 群集连接
9．3 连接优化
9．3．1 选择合适的连接
9．3．2 SQL提示
9．4 分析连接的图形化方法
9．4．1 显示表和连接条件
9．4．2 列出过滤统计数字
9．4．3 开始连接
9．4．4 继续连接
9．4．5 多个条件
9．4．6 处理到大表的连接
9．5 影响连接的init.ora参数
9．6 其他连接主题
9．6．1 连接远程表
9．6．2 笛卡尔积
9．6．3 数据仓库的特殊连接
9．7 小结
第10章 病理学家的工具箱：其他策略
10．1 分析缓慢的数据库
10．1．1 是否每个人都觉得性能很慢
10．1．2 是否能够将问题归结于一部分原因
10．2 找出最差的症状
10．2．1 监视活动会话
10．2．2 确保没有阻塞会话
10．2．3 彻底检查网络
10．2．4 查看资源消耗大户
10．2．5 磁盘等待时间
10．2．6 查看参数极值的设置
10．2．7 留心分布式查询
10．3 操作系统工具
10．3．1 top
10．3．2 uptime
10．3．3 sar
10．3．4 sar选项
10．3．5 使用Sar查找历史记录
10．3．6 iostat
10．3．7 vmstat
10．3．8 Windows操作系统中的工具
10．4 Oracle Statspack
10．4．1 安装Statspack
10．4．2 使用PERFSTAT快照
10．4．3 运行Statspack报告
10．4．4 报告示例
10．4．5 基础信息
10．4．6 缓存大小
10．4．7 加载简档
10．4．8 实例效率
10．4．9 前五个等待事件
10．4．10 与前台进程相关的所有等待事件
10．4．11 与后台进程相关的所有等待事件
10．4．12 实例统计
10．4．13 表空间统计数字
10．4．14 文件I／O统计数字
10．4．15 缓冲池统计数字
10．4．16 实例恢复统计数字
10．4．17 PGA聚集内存统计数字
10．4．18 PGA内存统计数字
10．4．19 回滚段统计数字
10．4．20 回滚段存储
10．4．21 撤销段摘要
10．4．22 闩锁活动
10．4．23 SGA内存摘要
10．4．24 init．ora参数
10．4．25 删除过时的快照数据
10．4．26 使用Statspack的建议
10．5 其他技巧
10．5．1 Oracle9i对Statspack的改进
10．5．2 后台揭密：快照的实际工作
10．6 小结
第11章 Oracle艺术家
11．1 绘制解决方案
11．1．1 常规解决方案
11．1．2 更为复杂问题的解决方案：特殊的性能策略
11．2 OracleBug
11．2．1 难道处处都有Bug
11．2．2 找出大Bug：报警
11．2．3 TAR的麻烦世界
11．2．4 其他排除Bug的方法
11．3 新的优化选项
11．3．1 DatabaseResourceManager
11．3．2 物化视图
11．3．3 查询改写
11．4 "不可能"的问题
11．4．1 与其他Oracle专业人员联系
11．4．2 咨询系统管理员
11．4．3 Metalink
11．4．4 Oracle论坛
11．4．5 白皮书
11．4．6 有用的Web网站
11．5 小结
第12章 艺术家的调色板
12．1 SQL提示
12．1．1 何时使用SQL提示
12．1．2 如何使用提示
12．1．3 优化器模式提示
12．1．4 表和索引提示
12．1．5 连接提示
12．1．6 特殊的SQL提示
12．1．7 SQL提示疑难解分析
12．1．8 语法注意事项
12．2 PGA自动内存管理
10．2．5 磁盘等待时间
10．2．6 查看参数极值的设置
10．2．7 留心分布式查询
12．2．1 设置PGA目标
12．2．2 PGA目标的优势
12．2．3 使用新的PGA参数
12．2．4 估算PGA需求
12．2．5 特殊的PGA视图
12．2．6 特殊的PGA术语
12．2．7 监视PGA内存优化
12．2．8 计算新的PGA内存目标
12．3 柱状图
12．3．1 柱状图需求
12．3．2 柱状图的样式
12．3．3 Oracle风格的柱状图
12．3．4 生成柱状图的传统方法
12．3．5 生成柱状图的新方法
12．3．6 查看柱状图
12．3．7 柱状图的局限性
12．4 小结
第13章 Oracle魔术师
13．1 设置舞台
13．1．1 测试解决方案
13．1．2 考虑对产品系统的影响
13．1．3 保存现有系统
13．2 挥动魔棒
13．2．1 念动咒语!让所有不满意的用户消失
13．2．2 确定性能变化
13．2．3 检查统计数据
13．2．4 观察意外出现的结果
13．3 如果犯了错
13．3．1 是否是正确的修正
13．3．2 系统如何不同
13．3．3 捕获相关的SQL
13．4 做好收尾工作
13．4．1 将解决方案记录入档
13．4．2 性能改进日志
13．4．3 结束与客户的交流
13．5 下一步操作
13．5．1 公布所学的内容
13．5．2 创建性能公文夹
13．6 小结
第14章 案例分析
14．1 为什么要花时间进行案例分析
14．2 使用案例分析
14．3 小结
附录A 有用的V$视图定义
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle性能优化科学与艺术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Forms与Reports高级开发
译者序序言第一部分  概
述

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Forms与Reports高级开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle PL/SQL完全自学手册
第1章  初识OracIe11g
第2章  初识PL SQL
第3章 PUSQL常用开发工具
第4章 数据表的基本操作
第5章 数据的增、删、改
第6章 热据的基本查询
第7章 数据的复杂查询
第8章 视图
第9章 触发器
第10章 游标
第11章 数据为事务
第12章 集合
第13章 过程、函数和包
第14章 安全管理
第15章 PL/SQL性能优级化
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle PL/SQL完全自学手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle性能优化与诊断案例精选
第一篇　成长之路
第1章　三十八载，Oracle伴我同行　1
1.1　缘起边陲，恰同学风华正茂　2
1.2　京师磨练，转眼已历十二载　4
1.3　笔耕不辍，年少曾怀作家梦　6
1.4　三重境界，见山见水见真我　9
1.5　云和恩墨，数据服务起征途　12
1.6　理想实践，开发运维一体化　13
1.7　快乐生活，此心安处是吾乡　16
第2章　回首向来萧瑟处，也无风雨也无晴　18
2.1　人生若只如初见　18
2.2　日久生情见真心　19
2.3　衣带渐宽终不悔　19
2.4　天下谁人不识君　20
2.5　回首向来萧瑟处，也无风雨也无晴　21
第3章　正确抉择，丰富人生　23
3.1　初闻Oracle　23
3.2　选择适合自己的路　24
3.2.1　选择合适的资料书　24
3.2.2　融入圈子　24
3.2.3　关于大学的课程　25
3.3　树立目标　26
3.3.1　参与论坛分享　26
3.3.2　写作　26
3.3.3　参加技术研讨会　27
3.4　关于认证　27
第二篇　知识基础
第4章　Oracle数据库的跟踪和分析方法　30
4.1　SQL_TRACE及10046事件　31
4.2　SQL_TRACE说明　31
4.2.1　DBMS_SYSTEM跟踪案例　32
4.2.2　系统递归调用的跟踪　36
4.3　10046与等待事件　39
4.3.1　通过跟踪理解数据库的初始化　42
4.3.2　远程支持之10046事件　50
4.3.3　通过10046事件跟踪解决未知问题　52
4.3.4　通过10046解决数据库RAC集群案例　56
4.4　Oracle跟踪总结　62
4.5　参考资料：数据类型比较规则　62
4.5.1　数值类型　62
4.5.2　日期类型　62
4.5.3　字符类型　62
4.5.4　对象类型　65
4.5.5　数组和嵌套表类型　65
第5章　兴趣、思考与实践　72
5.1　Kamus谈技术、学习与分享　72
5.1.1　Oracle的适用场景　72
5.1.2　为什么Oracle广受欢迎　73
5.1.3　如何实现灾备　73
5.1.4　数据库发展对DBA工作的影响　73
5.1.5　Oracle的学习方法　74
5.1.6　如何成为ACE　74
5.2　以12c Identity类型示范自我探索式学习方法　75
5.3　Dump Block是否会引起Block读入内存　84
5.4　Dump Block是否会引起脏数据写入磁盘　85
5.5　如何验证ASM的块头备份块的位置　88
5.6　如何利用文件句柄恢复误删除的文件　90
5.7　从一道面试题看分析问题的思路　93
5.7.1　检查被阻塞会话的等待事件　93
5.7.2　查找blocker　94
5.7.3　乙方DBA需谨慎　94
5.7.4　清除blocker　94
5.7.5　深入一步　95
5.8　涓涓细流终聚海　96
第6章　使用XTTS技术进行U2L跨平台数据迁移　97
6.1　XTTS 概述　97
6.2　XTTS技术迁移应用场景　99
6.2.1　应用场景一：全国“去IOE”战略实施　99
6.2.2　应用场景二：“云平台”数据中心建设　99
6.2.3　应用场景三：老旧环境淘汰改造　100
6.2.4　应用场景四：数据库分布式存储重构　100
6.2.5　应用场景五：其他应用场景　101
6.3　XTTS迁移步骤　101
6.4　XTTS迁移方式　101
6.4.1　方式一：dbms_file_transfer　102
6.4.2　方式二：RMAN Backup　103
6.4.3　方式三：手工XTTS迁移　104
6.5　XTTS前置条件检查　106
迁移检查　107
6.6　XTTS最佳实践方案论证　109
6.6.1　技术方案概况　109
6.6.2　技术方案实施步骤　110
6.6.3　技术方案模型　110
6.6.4　方案可行性说明　110
6.6.5　方案优缺点论述　111
6.6.6　技术方案论证结论　111
6.7　XTTS RMAN Backup步骤　111
6.8　XTTS实战案例分享　113
6.8.1　案例现状介绍　113
6.8.2　系统现状评估　114
6.8.3　迁移需求分析　114
6.8.4　迁移方案选型　115
6.8.5　迁移的具体实施　116
6.9　XTTS风险预估　122
6.10　XTTS总结　123
第7章　Oracle的参数和参数文件　124
7.1　参数的分类　124
7.1.1　推导参数　125
7.1.2　操作系统依赖参数　125
7.1.3　可变参数　126
7.1.4　不推荐参数　126
7.1.5　废弃参数　126
7.2　参数文件管理和使用　128
7.2.1　参数文件的创建　128
7.2.2　12c create spfile的警示　130
7.3　12c 参数与参数文件新特性　134
7.3.1　参数表的引入　135
7.3.2　参数表在PDB启动中的作用　138
7.4　参数修改及重置　139
7.4.1　解决参数文件的修改错误　144
7.4.2　通过event事件来跟踪对参数文件的修改　145
7.5　参数的查询　145
7.5.1　参数查询的基本方式　146
7.5.2　参数值的可选项　148
7.6　不同查询方法之间的区别　149
7.6.1　V$PARAMETER和V$PARAMETER2的区别　149
7.6.2　V$PARAMETER和V$SYSTEM_PARAMETER的区别　150
7.6.3　GV$SPPARAMETER和V$SPPARAMETER的区别　152
7.7　RAC下参数的维护　154
7.7.1　RAC下共享spfile　154
7.7.2　使用ASM存储参数文件　155
7.7.3　谨慎修改RAC参数　156
7.7.4　RAC环境下初始化参数的查询方法　156
7.8　参数文件备份　158
7.9　参数文件恢复　160
第三篇　SQL之美
第8章　学习与分享　164
8.1　对数据库开发和运维的认识　164
8.2　行业发展给DBA带来的挑战　165
8.3　个人学习经验分享　165
8.4　Oracle中的NULL剖析　166
8.4.1　NULL的基础概念和由来　167
8.4.2　NULL的布尔运算的特点　168
8.4.3　NULL的默认数据类型　173
8.4.4　空字符串’ ’与NULL的关系　176
8.4.5　NULL和索引　179
8.4.6　NULL的其他方面特点　183
第9章　诊断Cache buffers chains案例一则　185
9.1　详细诊断过程　185
9.2　总结　194
第10章　戒骄戒躁、细致入微　195
10.1　我的职业生涯　195
10.2　运维的现状及发展　196
10.3　如何提高数据库的开发水平　196
10.4　DBA面临的挑战　197
10.5　数据库优化的思考　197
10.6　提问的智慧　199
10.7　细致入微方显价值——通过真实案例认识SQL审核　200
10.7.1　案例一 仅仅是NULL的问题　200
10.7.2　案例二 想不到的优化方式　202
10.8　号段选取应用的SQL技巧　204
10.8.1　问题的提出　204
10.8.2　相关基础知识　205
10.8.3　解决问题　207
10.8.4　小结　220
10.9　connect y的作用与技巧　220
10.9.1　connect y是什么　221
10.9.2　connect y可以做什么　221
第四篇　诊断分析
第11章　抽丝剥茧——一次特殊的ORA-04030故障处理　238
11.1　聚集数据的信息采集和分析　238
11.2　聚焦疑点的跟踪测试与验证　242
11.3　解析原理的问题总结与建议　245
第12章　不积跬步，无以至千里　247
12.1　技术生涯有感　247
12.2　自我定位及规划　248
12.3　对数据库运维工作的认识　249
12.4　学习理念分享　249
12.5　RAC数据库频繁hang问题诊断案例　249
12.5.1　案例现象及概要　250
12.5.2　故障详细分析　251
12.5.3　案例总结　260
12.6　Exadata环境下SQL性能问题诊断案例　262
12.6.1　AWR报告　262
12.6.2　生成SQL报告　263
12.6.3　检查历史数据　266
12.6.4　判断问题产生的流程　268
12.6.5　查询历史数据　268
12.6.6　并列执行的序列过程　268
12.6.7　检查call tack　271
12.6.8　检查并行会话　271
12.7　关于RAC数据库load alance案例分析　276
12.8　总结　285
第13章　反思与总结：轻松从菜鸟到专家　286
13.1　一波三折：释放内存导致数据库崩溃的案例　287
13.2　层层深入：DRM引发RAC的故障分析　292
13.3　始于垒土：应用无法连接数据库问题分析　300
13.4　变与不变：应用SQL突然变慢优化分析　308
13.5　实践真知：INSERT入库慢的案例分析　314
13.6　按图索骥：Expdp遭遇ORA-07445的背后　319
13.7　城门失火：Goldengate引发的数据库故障　323
第14章　勤奋与汗水　329
14.1　我的职业生涯与思考　329
14.2　如何看待企业运维　329
14.3　对性能问题的认识　331
14.4　学习方法　332
14.5　所有奇异的故障都有一个最简单的本质　332
14.6　案例一：意料之外的RAC宕机祸首——子游标　333
14.6.1　信息采集，准确定位问题　333
14.6.2　层层分析，揪出罪魁祸首　336
14.6.3　对症下药，排除数据故障　341
14.6.4　深入总结，一次故障长久经验　342
14.7　案例二：异常诡异的SQL性能分析　342
14.7.1　信息收集　342
14.7.2　新特性分析　344
14.8　总结　345
参考文献　346
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle性能优化与诊断案例精选
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle性能调整与优化
第一部分  实例调整
第1章  Oracle系统调整基础	3
1.1  系统调整的基本概念	 3
1.1.1  系统调整的含义	3
1.1.2  确定系统是否需要调整	 3
1.1.3  确定何时停止调整系统

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle性能调整与优化
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Applications应用大全
一，回顾ERP和Oracle&nbsp;公司
二，Oracle&nbsp;Applications
三，软件IMP方法
四，影响工作量和成本的因素
五，理解项目管理和控制
六，开始项目
七，项目分析
八，分析到解决方案的转换
九，系统启用
十，启动新系统
十一，使用Oracle&nbsp;General&nbsp;Ledger
十二

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Applications应用大全
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>基于Linux的Oracle数据库管理
第1章 Oracle与Linux
1.1 Oracle支持Linux的历史
1.2 Oracle对Linux的贡献
1.3 Oracle的Linux发行版
1.4 Oracle Database 10g支持的Linux发行版
第2章 搭建实验环境
2.1 实验环境所需软件介绍
2.2 存储空间规划
2.3 软件配置
2.4 安装VMware Tools
2.5 虚拟机与宿主机的网络设置
2.6 使用PUTTY及VNC进行系统管理
2.7 常见问题及解决方法
第3章 Linux基础
3.1 Linux启动过程分析
3.2 ext2文件系统结构
3.3 inode
3.4 Linux目录结构
3.5 软链接与硬链接
3.6 文件的时间属性
3.7 目录权限
3.8 和用户环境相关的几个配置文件
第4章 Linux常用命令
4.1 字符串模式匹配
4.2 ls命令
4.3 sort命令
4.4 tail及head命令
4.5 find命令
4.6 grep命令
4.7 cut命令
4.8 sed
4.9 awk
4.10 发送邮件
4.1.1 自动执行作业
4.12 磁盘管理及空间监控命令
4.13 文件压缩与备份：tar
4.14 I／O重定向：“2]&1]file”还是“]file 2]&1”?
第5章 准备安装Oracle Linux配置及验证
5.1 检查软件包及其版本
5.2 检查物理内存及磁盘空间
5.3 配置内核参数
5.4 创建安装及管理Oracle软件的用户及组
5.5 设置Oracle用户登录环境
5.6 配置X Window
第6章 安装Oracle Database 10g for Linux
6.1 准备Oracle 10g安装文件
6.2 安装Oracle 10g
6.3 软件安装后的后续千作
6.4 在Linux上彻底删除Oracle软件
第7章 创建Oracle数据库
7.1 使用dbca创建数据库
7.2 使用命令手了建库
7.3 配置SQL*Plus客户端环境
第8章 Oracle数据库服务器常用存储模式
8.1 文件系统
8.2 裸设备
8.3 自动存储管理——ASM..
8.4 逻辑卷管理——LVM
第9章 配置网络连接
9.1 配置专用服务器模式
9.2 配置共享服务器模式
第10章 常用数据库维护命令
10.1 删除旧的归档文件或跟踪文件
10.2 查找大文件
10.3 在跟踪文件中查找错误信息
10.4 查看内存使用情况
10.5 系统状态监控命令
第11章 编写shell脚本程序
11.1 “hello.world”程序
11.2 变量
11.3 由键盘输入获得变量的值
11.4 数值运算
11.5 if语句
11.6 case语句
11.7 循环结构
第12章 shell脚本程序中调用SQL*Plus
12.1 here document
12.2 在shell脚本程序中调用SQL*Plus
12.3 把SQL查询结果赋给shell变量
12.4 把shell程序参数传递给SQL命令
12.5 shell中常用的SQL*Plus环境设置
12.6 调用SQL*Plus时的口令安全问题
第13章 数据库的自动启动与关闭
13.1 单数据库的情况
13.2 多数据库的情况
第14章 数据库管理shell程序
14.1 监控监听器进程是否运行
14.2 监控数据库是否运行
14.3 监控归档目录空间
14.4 监控警告文件错误信息
14.5 监控磁盘空间
14.6 监控表空间空闲空间
第15章 数据库备份shell程序
15.1 Oracle数据库备份简介
15.2 全库冷备份shell程序
15.3 全库热备份shell程序
15.4 rman备份shell程序
15.5 逻辑备份shell程序
参考文献
参考网址
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>基于Linux的Oracle数据库管理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ORACLE 24*7技术与技巧
贺辞序译者序引言前言第

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ORACLE 24*7技术与技巧
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle E-Business Financials 手册
第一部分  起
步第1章

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle E-Business Financials 手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库编程经典300例(含DVD光盘1张)
第1篇  初识Oracle PL/SQL
第1章  走进Oracle PL/SQL	2
实例001  安装Oracle 10g	2
难度指数 ★☆☆☆☆  占用时间 ○○
实例002  启动SQL*Plus工具	7
难度指数 ★★☆☆☆  占用时间 ○○
实例003  使用SQL*Plus命令行工具	8
难度指数 ★★☆☆☆  占用时间 ○
实例004  配置连接字符串	10
难度指数 ★★☆☆☆  占用时间 ○
实例005  使用PL/SQL Developer工具	11
难度指数 ★☆☆☆☆  占用时间 ○○
实例006  启动和关闭Oracle	12
难度指数 ★☆☆☆☆  占用时间 ○
实例007  创建PL/SQL块	14
难度指数 ★★☆☆☆  占用时间 ○○
实例008  使用变量输出字符串	16
难度指数 ★★☆☆☆  占用时间 ○
实例009  变量初始化及存储数据记录	17
难度指数 ★★☆☆☆  占用时间 ○
实例010  使用常量计算圆面积	18
难度指数 ★★★☆☆  占用时间 ○○
实例011  使用宿主变量	19
难度指数 ★★★☆☆  占用时间 ○○
实例012  输出指定精度的数据	20
难度指数 ★☆☆☆☆  占用时间 ○
实例013  获取当前日期时间	21
难度指数 ★☆☆☆☆  占用时间 ○
实例014  使用记录类型输出数据表中的一行	22
难度指数 ★★☆☆☆  占用时间 ○
实例015  引用并输出数据表中的列	23
难度指数 ★★☆☆☆  占用时间 ○
第2章  操作数据表结构	25
实例016  使用CREATE TABLE命令创建基本表	25
难度指数 ★★☆☆☆  占用时间 ○○
实例017  使用ALTER TABLE命令增加新字段	27
难度指数 ★★☆☆☆  占用时间 ○
实例018  使用ALTER TABLE命令修改字段	28
难度指数 ★★☆☆☆  占用时间 ○
实例019  使用ALTER TABLE命令删除字段	29
难度指数 ★★☆☆☆  占用时间 ○
实例020  重命名基本表	30
难度指数 ★★☆☆☆  占用时间 ○
实例021  复制相同结构的表	31
难度指数 ★★★☆☆  占用时间 ○○
实例022  使用DROP TABLE命令删除表	33
难度指数 ★☆☆☆☆  占用时间 ○
实例023  创建主键约束	34
难度指数 ★★★☆☆  占用时间 ○○
实例024  创建唯一性约束	35
难度指数 ★★★☆☆  占用时间 ○○
实例025  创建CHECK约束	37
难度指数 ★★☆☆☆  占用时间 ○
实例026  创建外键约束	39
难度指数 ★★★☆☆  占用时间 ○○
实例027  删除约束	40
难度指数 ★☆☆☆☆  占用时间 ○
实例028  为字段设置默认值	42
难度指数 ★★☆☆☆  占用时间 ○
第2篇  数据查询
第3章  简单数据查询	46
实例029  查询输出基本表中指定列	46
难度指数 ★☆☆☆☆  占用时间 ○
实例030  对数据列进行运算并输出	47
难度指数 ★★☆☆☆  占用时间 ○
实例031  单条件查询	49
难度指数 ★☆☆☆☆  占用时间 ○
实例032  根据查询结果创建和复制表	50
难度指数 ★★★☆☆  占用时间 ○○
实例033  返回表中的前N行记录	51
难度指数 ★★☆☆☆  占用时间 ○
实例034  消除重复行	52
难度指数 ★★★☆☆  占用时间 ○○
实例035  NULL值的判定	54
难度指数 ★★☆☆☆  占用时间 ○
实例036  查询字段值为某个范围内的记录	55
难度指数 ★☆☆☆☆  占用时间 ○
实例037  返回字段值为列表中某个值的记录	56
难度指数 ★★☆☆☆  占用时间 ○
实例038  条件组合查询	57
难度指数 ★★★☆☆  占用时间 ○○
实例039  复合条件查询	59
难度指数 ★★★★☆  占用时间 ○○○
实例040  实现模糊查询	61
难度指数 ★★★☆☆  占用时间 ○○
实例041  使用ESCAPE和转义字符	62
难度指数 ★★★☆☆  占用时间 ○○
第4章  数据查询中函数的使用	64
实例042  使用COUNT函数统计表中的记录数	64
难度指数 ★★☆☆☆  占用时间 ○
实例043  使用SUM函数求和	66
难度指数 ★★★☆☆  占用时间 ○○
实例044  使用AVG函数求平均值	67
难度指数 ★★☆☆☆  占用时间 ○
实例045  返回最大值	68
难度指数 ★★☆☆☆  占用时间 ○
实例046  返回最小值	69
难度指数 ★★☆☆☆  占用时间 ○
实例047  查找并替换字符串	70
难度指数 ★★★☆☆  占用时间 ○○
实例048  获取字符的ASCII码	71
难度指数 ★★★☆☆  占用时间 ○○
实例049  返回字符串长度	72
难度指数 ★★☆☆☆  占用时间 ○
实例050  使用ROUND函数确定精度	73
难度指数 ★★★☆☆  占用时间 ○○
实例051  日期运算	74
难度指数 ★★★☆☆  占用时间 ○○
实例052  日期格式化输出	75
难度指数 ★★☆☆☆  占用时间 ○
实例053  提取日期特定部分	77
难度指数 ★★★☆☆  占用时间 ○○
实例054  数据类型转换	79
难度指数 ★★★☆☆  占用时间 ○○
实例055  提取日期的星期值	80
难度指数 ★★☆☆☆  占用时间 ○
实例056  提取一年中的第几天	81
难度指数 ★★☆☆☆  占用时间 ○
实例057  计算时间差	82
难度指数 ★☆☆☆☆  占用时间 ○
实例058  获取某月的第一天与最后一天	83
难度指数 ★★☆☆☆  占用时间 ○
实例059  NVL函数的使用	85
难度指数 ★★★☆☆  占用时间 ○○
第5章  高级查询	87
实例060  使用GROUP BY子句实现分组	87
难度指数 ★★★☆☆  占用时间 ○○
实例061  按条件查询并分组	89
难度指数 ★★★★☆  占用时间 ○○○
实例062  使用CUBE汇总数据	90
难度指数 ★★★☆☆  占用时间 ○○
实例063  使用ROLLUP汇总数据	91
难度指数 ★★★☆☆  占用时间 ○○
实例064  用GROUPING函数区分NULL值	93
难度指数 ★★★★☆  占用时间 ○○○
实例065  使用HAVING子句过滤分组数据	94
难度指数 ★★★☆☆  占用时间 ○○
实例066  区别HAVING子句与WHERE子句	95
难度指数 ★★★★☆  占用时间 ○○○
实例067  使用ORDER BY子句排序	96
难度指数 ★★☆☆☆  占用时间 ○
实例068  对字符串列排序	98
难度指数 ★★☆☆☆  占用时间 ○
实例069  多列排序	100
难度指数 ★★★☆☆  占用时间 ○○
实例070  对查询进行集合运算	101
难度指数 ★★★★☆  占用时间 ○○○
实例071  返回多个表的共有数据	102
难度指数 ★★★☆☆  占用时间 ○○
实例072  返回各个表的所有数据	103
难度指数 ★★★☆☆  占用时间 ○○
实例073  无条件多表查询	104
难度指数 ★★☆☆☆  占用时间 ○
实例074  有共同字段的表等值连接	105
难度指数 ★★★☆☆  占用时间 ○○
实例075  含条件的等值连接	106
难度指数 ★★★★☆  占用时间 ○○○
实例076  有共同字段的表非等值连接	107
难度指数 ★★★☆☆  占用时间 ○○
实例077  两个表进行内连接	108
难度指数 ★★★☆☆  占用时间 ○○
实例078  两个表进行自然连接	109
难度指数 ★★★★☆  占用时间 ○○○
实例079  一个表进行自连接	110
难度指数 ★★★☆☆  占用时间 ○○
实例080  两个表进行左外连接	111
难度指数 ★★★☆☆  占用时间 ○○
实例081  两个表进行右外连接	112
难度指数 ★★★☆☆  占用时间 ○○
实例082  两个表进行全外连接	113
难度指数 ★★★☆☆  占用时间 ○○
实例083  多表连接	114
难度指数 ★★★★★  占用时间 ○○○
第6章  子查询	116
实例084  返回单行的子查询	116
难度指数 ★★☆☆☆  占用时间 ○
实例085  含有聚合函数的单行子查询	118
难度指数 ★★★☆☆  占用时间 ○○
实例086  多表查询中返回结果为单行的子查询	119
难度指数 ★★★☆☆  占用时间 ○○
实例087  用IN谓词实现多行子查询	120
难度指数 ★★★★☆  占用时间 ○○
实例088  多表查询中使用IN谓词	122
难度指数 ★★★★★  占用时间 ○○○
实例089  EXISTS子查询	123
难度指数 ★★★★☆  占用时间 ○○○
实例090  EXISTS替代单行子查询	124
难度指数 ★★★★☆  占用时间 ○○○
实例091  相关子查询	125
难度指数 ★★★★☆  占用时间 ○○○
实例092  含聚合函数的相关子查询	126
难度指数 ★★★★★  占用时间 ○○○
实例093  带IN谓词的相关子查询	127
难度指数 ★★★★★  占用时间 ○○○
实例094  包含分组的相关子查询	128
难度指数 ★★★★★  占用时间 ○○○
实例095  带ANY的子查询	130
难度指数 ★★★★☆  占用时间 ○○○
实例096  带ALL的子查询	131
难度指数 ★★★★☆  占用时间 ○○○
实例097  嵌套子查询	132
难度指数 ★★★★★  占用时间 ○○○
实例098  FROM子句后的子查询	134
难度指数 ★★★★☆  占用时间 ○○○
实例099  SELECT子句后的子查询	135
难度指数 ★★★★★  占用时间 ○○○
实例100  HAVING子句后的子查询	136
难度指数 ★★★★☆  占用时间 ○○○
实例101  子查询返回值为空	138
难度指数 ★★★☆☆  占用时间 ○○
第3篇  数据操纵DML
第7章  数据操作	140
实例102  不指定字段的整行插入	140
难度指数 ★★☆☆☆  占用时间 ○
实例103  指定字段的整行插入	142
难度指数 ★☆☆☆☆  占用时间 ○
实例104  插入空值	144
难度指数 ★☆☆☆☆  占用时间 ○
实例105  插入唯一值	145
难度指数 ★★☆☆☆  占用时间 ○
实例106  使用过程插入多行	146
难度指数 ★★★☆☆  占用时间 ○○
实例107  使用INSERT SELECT语句插入多行	148
难度指数 ★★★★☆  占用时间 ○○○
实例108  通过输入修改单个列值	149
难度指数 ★★☆☆☆  占用时间 ○
实例109  通过函数修改单个列值	150
难度指数 ★★★☆☆  占用时间 ○○
实例110  修改数据为空值	151
难度指数 ★★☆☆☆  占用时间 ○
实例111  通过运算修改单列值	152
难度指数 ★★☆☆☆  占用时间 ○
实例112  通过表其他列修改单列值	154
难度指数 ★★☆☆☆  占用时间 ○
实例113  通过外表的某列修改单列值	154
难度指数 ★★★☆☆  占用时间 ○○
实例114  修改单行的多个列值	156
难度指数 ★★☆☆☆  占用时间 ○○
实例115  修改多行的多个列值	156
难度指数 ★★★☆☆  占用时间 ○○
实例116  删除单行数据	157
难度指数 ★★☆☆☆  占用时间 ○
实例117  删除多行数据	158
难度指数 ★★☆☆☆  占用时间 ○
实例118  删除所有行	159
难度指数 ★☆☆☆☆  占用时间 ○
实例119  使用TRUNCATE命令清空表	160
难度指数 ★☆☆☆☆  占用时间 ○
第8章  索引与视图	162
实例120  创建唯一索引	162
难度指数 ★★☆☆☆  占用时间 ○
实例121  创建单列索引	163
难度指数 ★★☆☆☆  占用时间 ○
实例122  创建复合索引	164
难度指数 ★★★☆☆  占用时间 ○○
实例123  使用ALTER INDEX重建索引	165
难度指数 ★★★☆☆  占用时间 ○○
实例124  删除索引	166
难度指数 ★★☆☆☆  占用时间 ○
实例125  创建简单视图	167
难度指数 ★★☆☆☆  占用时间 ○
实例126  创建复杂视图	169
难度指数 ★★★☆☆  占用时间 ○○
实例127  创建基于视图的视图	170
难度指数 ★★★★☆  占用时间 ○○○
实例128  通过视图插入数据	171
难度指数 ★★★☆☆  占用时间 ○○
实例129  通过视图修改数据	173
难度指数 ★★★☆☆  占用时间 ○○
实例130  通过视图删除数据	174
难度指数 ★★★☆☆  占用时间 ○○
实例131  删除视图	175
难度指数 ★★☆☆☆  占用时间 ○
实例132  创建同义词	176
难度指数 ★★★☆☆  占用时间 ○○
实例133  生成序列号	177
难度指数 ★★★★☆  占用时间 ○○○
实例134  修改和注销序列	178
难度指数 ★★★☆☆  占用时间 ○○
实例135  创建表空间	179
难度指数 ★★★☆☆  占用时间 ○○
实例136  扩充和删除表空间	180
难度指数 ★★★☆☆  占用时间 ○○
实例137  为用户指定表空间	182
难度指数 ★★☆☆☆  占用时间 ○
实例138  为表指定表空间	183
难度指数 ★★☆☆☆  占用时间 ○
实例139  为索引指定表空间	184
难度指数 ★★☆☆☆  占用时间 ○
实例140  查看索引个数和类别	185
难度指数 ★★★☆☆  占用时间 ○○
实例141  查看被索引的列	185
难度指数 ★★★☆☆  占用时间 ○○
实例142  查看索引的大小	186
难度指数 ★★★☆☆  占用时间 ○○
第4篇  数据安全应用
第9章  用户权限及角色	190
实例143  创建与注销用户	190
难度指数 ★★☆☆☆  占用时间 ○
实例144  修改用户口令	191
难度指数 ★★☆☆☆  占用时间 ○
实例145  设置和解除用户锁定	193
难度指数 ★★☆☆☆  占用时间 ○
实例146  更改用户名	194
难度指数 ★★☆☆☆  占用时间 ○
实例147  将系统权限授予用户	196
难度指数 ★★★☆☆  占用时间 ○○
实例148  将对象权限授予用户	197
难度指数 ★★★☆☆  占用时间 ○○
实例149  授予用户角色	199
难度指数 ★★☆☆☆  占用时间 ○
实例150  创建自定义角色	201
难度指数 ★★★☆☆  占用时间 ○○
实例151  收回对象权限	202
难度指数 ★★☆☆☆  占用时间 ○
实例152  回收系统权限	203
难度指数 ★★☆☆☆  占用时间 ○
实例153  级联对象权限的授予	204
难度指数 ★★★☆☆  占用时间 ○○
实例154  收回级联的对象权限	206
难度指数 ★★★☆☆  占用时间 ○○
实例155  级联系统权限的授予	207
难度指数 ★★★☆☆  占用时间 ○○
实例156  收回级联的系统权限	208
难度指数 ★★★☆☆  占用时间 ○○
实例157  收回角色权限	209
难度指数 ★★☆☆☆  占用时间 ○
实例158  删除自定义角色	210
难度指数 ★★☆☆☆  占用时间 ○
实例159  启用/禁用角色	211
难度指数 ★★☆☆☆  占用时间 ○
实例160  显示用户所拥有的角色	212
难度指数 ★★★☆☆  占用时间 ○○
实例161  显示角色的权限	213
难度指数 ★★☆☆☆  占用时间 ○
实例162  显示用户的所有系统权限	214
难度指数 ★★☆☆☆  占用时间 ○
第10章  完整性控制	215
实例163  防止无效数据被插入数据表中	215
难度指数 ★★★★☆  占用时间 ○○○
实例164  防止将已有的数据更改成无效值	217
难度指数 ★★★★☆  占用时间 ○○○
实例165  防止删除已有的数据造成数据失效	218
难度指数 ★★★★★  占用时间 ○○○
实例166  删除级联数据行	219
难度指数 ★★★☆☆  占用时间 ○○
实例167  防止输入NULL值	220
难度指数 ★★★☆☆  占用时间 ○○
实例168  防止输入重复值	222
难度指数 ★★★★☆  占用时间 ○○○
第11章  PL/SQL控制语句和存储过程	224
实例169  比较两个变量的大小并单输出	224
难度指数 ★☆☆☆☆  占用时间 ○
实例170  比较两个变量的大小并双输出	226
难度指数 ★★☆☆☆  占用时间 ○
实例171  使用标识符	227
难度指数 ★☆☆☆☆  占用时间 ○
实例172  使用条件嵌套语句	228
难度指数 ★★★☆☆  占用时间 ○○
实例173  使用CASE语句	230
难度指数 ★★☆☆☆  占用时间 ○
实例174  LOOP语句实现累加	231
难度指数 ★★★☆☆  占用时间 ○○
实例175  计算100以内所有偶数之和	233
难度指数 ★★★☆☆  占用时间 ○○
实例176  计算100以内所有奇数之和	234
难度指数 ★★★☆☆  占用时间 ○○
实例177  FOR语句实现累加	235
难度指数 ★★★☆☆  占用时间 ○○
实例178  创建不带参数的存储过程	236
难度指数 ★★☆☆☆  占用时间 ○
实例179  调用不带参数的存储过程	237
难度指数 ★★★☆☆  占用时间 ○○
实例180  创建带参数的存储过程	239
难度指数 ★★★★☆  占用时间 ○○○
实例181  调用带参数的存储过程	240
难度指数 ★★★☆☆  占用时间 ○○
实例182  创建并调用带输出参数的存储过程	241
难度指数 ★★★★☆  占用时间 ○○○
实例183  创建并调用带默认值的存储过程	242
难度指数 ★★★☆☆  占用时间 ○○
实例184  查看存储过程	243
难度指数 ★★☆☆☆  占用时间 ○○
实例185  调试存储过程	245
难度指数 ★★★★☆  占用时间 ○○○
实例186  重新编译存储过程	246
难度指数 ★★★☆☆  占用时间 ○○
实例187  删除存储过程	246
难度指数 ★★☆☆☆  占用时间 ○○
实例188  动态SQL执行DDL语句	247
难度指数 ★★★★☆  占用时间 ○○○
实例189  动态SQL执行DML语句	249
难度指数 ★★★★☆  占用时间 ○○○
第12章  触发器	251
实例190  创建语句触发器	251
难度指数 ★★★☆☆  占用时间 ○○
实例191  语句触发器被触发	252
难度指数 ★★★☆☆  占用时间 ○○
实例192  查看触发器	253
难度指数 ★★☆☆☆  占用时间 ○
实例193  创建并触发行触发器	255
难度指数 ★★★☆☆  占用时间 ○○
实例194  INSERT触发器	256
难度指数 ★★★☆☆  占用时间 ○○
实例195  UPDATE指定列触发器	257
难度指数 ★★★☆☆  占用时间 ○○
实例196  DELETE触发器	258
难度指数 ★★☆☆☆  占用时间 ○
实例197  创建INSTEAD OF触发器	259
难度指数 ★★★★☆  占用时间 ○○○
实例198  创建用户事件触发器	261
难度指数 ★★★☆☆  占用时间 ○○
实例199  创建系统事件触发器	262
难度指数 ★★★☆☆  占用时间 ○○
实例200  禁用/启用触发器	264
难度指数 ★★☆☆☆  占用时间 ○
实例201  以表为单位禁用/启用触发器	265
难度指数 ★★★☆☆  占用时间 ○○
实例202  将删除记录自动写入日志表	266
难度指数 ★★★★☆  占用时间 ○○○
实例203  限制非工作时间操作数据	268
难度指数 ★★★★☆  占用时间 ○○○
实例204  限制对保护数据的操作	269
难度指数 ★★★★☆  占用时间 ○○○
实例205  实现级联更新	270
难度指数 ★★★★☆  占用时间 ○○○
实例206  创建数据对象结构操作事件日志	272
难度指数 ★★★★☆  占用时间 ○○○
实例207  删除触发器	273
难度指数 ★★★☆☆  占用时间 ○○
第13章  事务处理和并发控制	275
实例208  事务开始	275
难度指数 ★★☆☆☆  占用时间 ○
实例209  提交事务	276
难度指数 ★★★☆☆  占用时间 ○○
实例210  回滚事务	278
难度指数 ★★★☆☆  占用时间 ○○
实例211  设置保存点	279
难度指数 ★★★☆☆  占用时间 ○○
实例212  回滚部分事务	280
难度指数 ★★★★☆  占用时间 ○○○
实例213  DDL语句对事务的影响	281
难度指数 ★★★☆☆  占用时间 ○○
实例214  DCL语句提交事务	282
难度指数 ★★★☆☆  占用时间 ○○
实例215  断开数据库连接对事务的影响	283
难度指数 ★★★☆☆  占用时间 ○○
实例216  异常断开数据库连接回滚事务	284
难度指数 ★★★★☆  占用时间 ○○
实例217  避免脏读	285
难度指数 ★★★★★  占用时间 ○○○
实例218  避免不可重复读	287
难度指数 ★★★★★  占用时间 ○○○
实例219  判断数据是否被锁	288
难度指数 ★★★★☆  占用时间 ○○○
实例220  锁定数据表	289
难度指数 ★★★☆☆  占用时间 ○○
实例221  查看被锁定的数据对象	290
难度指数 ★★★☆☆  占用时间 ○○
实例222  为被锁定表解锁	291
难度指数 ★★★☆☆  占用时间 ○○
实例223  创建程序包	292
难度指数 ★★★★☆  占用时间 ○○○
实例224  使用程序包	294
难度指数 ★★★☆☆  占用时间 ○○
实例225  查看程序包	295
难度指数 ★★★☆☆  占用时间 ○○
实例226  删除程序包	296
难度指数 ★★★☆☆  占用时间 ○○
第14章  游标	298
实例227  声明游标	298
难度指数 ★★★☆☆  占用时间 ○○
实例228  打开游标	299
难度指数 ★★★☆☆  占用时间 ○○
实例229  提取数据	300
难度指数 ★★★★☆  占用时间 ○○○
实例230  关闭游标	302
难度指数 ★★☆☆☆  占用时间 ○
实例231  循环语句中的游标使用	303
难度指数 ★★★★☆  占用时间 ○○○
实例232  视图中游标的使用	304
难度指数 ★★★☆☆  占用时间 ○○
实例233  提取整行数据	306
难度指数 ★★★☆☆  占用时间 ○○
实例234  用游标名定义记录变量	307
难度指数 ★★★☆☆  占用时间 ○○
实例235  使用带参数的游标	308
难度指数 ★★★★☆  占用时间 ○○○
实例236  使用含默认值参数的游标	309
难度指数 ★★★☆☆  占用时间 ○○
实例237  使用参数为变量的游标	310
难度指数 ★★★★☆  占用时间 ○○○
实例238  使用游标FOR循环	313
难度指数 ★★★☆☆  占用时间 ○○
实例239  游标FOR循环中使用子查询	314
难度指数 ★★★★★  占用时间 ○○○
实例240  使用游标更新数据	315
难度指数 ★★★★☆  占用时间 ○○○
实例241  使用游标删除数据	316
难度指数 ★★★☆☆  占用时间 ○○
实例242  判断游标是否打开	318
难度指数 ★★★☆☆  占用时间 ○○
实例243  获取游标读取的记录行数	319
难度指数 ★★★☆☆  占用时间 ○○
实例244  游标中的子查询	320
难度指数 ★★★★★  占用时间 ○○○
第15章  数据导入/导出	322
实例245  备份数据库	322
难度指数 ★★★☆☆  占用时间 ○○
实例246  导出用户所有数据	324
难度指数 ★★★★☆  占用时间 ○○○
实例247  导出指定表数据	325
难度指数 ★★★☆☆  占用时间 ○○
实例248  导出指定表的部分数据	326
难度指数 ★★★☆☆  占用时间 ○○
实例249  恢复数据库	328
难度指数 ★★★☆☆  占用时间 ○○
实例250  导入数据表	328
难度指数 ★★★☆☆  占用时间 ○○
实例251  导出Excel文件	329
难度指数 ★★★★☆  占用时间 ○○○
实例252  导入Excel数据	331
难度指数 ★★★★☆  占用时间 ○○○
实例253  在PL/SQL Developer下导出表结构	333
难度指数 ★★★☆☆  占用时间 ○○
实例254  在PL/SQL Developer下导入表结构	335
难度指数 ★★★☆☆  占用时间 ○○
实例255  在PL/SQL Developer下导出数据	337
难度指数 ★★★☆☆  占用时间 ○○
实例256  在PL/SQL Developer下导入数据	339
难度指数 ★★★☆☆  占用时间 ○○
第5篇  Oracle高级应用技术
第16章  Oracle性能优化	344
实例257  在SELECT语句中避免使用“*”	344
难度指数 ★★☆☆☆  占用时间 ○
实例258  尽可能减小记录集行数	345
难度指数 ★★☆☆☆  占用时间 ○
实例259  使用ROWID高效删除重复记录	347
难度指数 ★★★☆☆  占用时间 ○○
实例260  使用TRUNCATE替代DELETE删除记录	348
难度指数 ★★★☆☆  占用时间 ○○
实例261  高效统计记录行数	349
难度指数 ★★★☆☆  占用时间 ○○
实例262  尽量多使用COMMIT	350
难度指数 ★★☆☆☆  占用时间 ○
实例263  避免使用HAVING子句	351
难度指数 ★★★☆☆  占用时间 ○○
实例264  用EXISTS替代IN谓词	353
难度指数 ★★★★★  占用时间 ○○○
实例265  用“>=”替代“>”运算符	354
难度指数 ★★★★☆   占用时间 ○○○
实例266  避免在SELECT子句中使用DISTINCT关键字	355
难度指数 ★★★☆☆  占用时间 ○○
实例267  用索引提高检索效率	356
难度指数 ★★★☆☆  占用时间 ○○
实例268  避免在索引列上进行运算	357
难度指数 ★★★☆☆  占用时间 ○○
实例269  在索引列上用UNION替换OR	358
难度指数 ★★★☆☆  占用时间 ○○
实例270  避免在索引列上用IS NULL	360
难度指数 ★★★★☆  占用时间 ○○○
实例271  使用WHERE子句优化GROUP BY	361
难度指数 ★★★★★  占用时间 ○○○
实例272  处理预定义异常	362
难度指数 ★★★★☆  占用时间 ○○○
实例273  处理自定义异常	364
难度指数 ★★★☆☆  占用时间 ○○
第17章  Oracle 实用技巧	366
实例274  查看Oracle版本	366
难度指数 ★☆☆☆☆  占用时间 ○
实例275  查看表所占用的空间	367
难度指数 ★☆☆☆☆  占用时间 ○
实例276  查看Oracle最大连接数	368
难度指数 ★★☆☆☆  占用时间 ○
实例277  查看并统计当前活动用户	369
难度指数 ★★☆☆☆  占用时间 ○
实例278  查看表空间占用空间情况	370
难度指数 ★★☆☆☆  占用时间 ○
实例279  按中文拼音/笔画/部首排序输出	371
难度指数 ★★★☆☆  占用时间 ○○
实例280  修改数据库默认日期格式	372
难度指数 ★★★☆☆  占用时间 ○○
实例281  自动生成查询结果序号	373
难度指数 ★★★☆☆  占用时间 ○○
实例282  查看数据文件放置的路径	374
难度指数 ★★☆☆☆  占用时间 ○
实例283  将查询结果导出到文本文件	375
难度指数 ★★★☆☆  占用时间 ○○
实例284  跟踪SQL语句执行	377
难度指数 ★★★★☆  占用时间 ○○○
实例285  插入全年日期	378
难度指数 ★★★☆☆  占用时间 ○○
实例286  输出表中某列第N大的记录	379
难度指数 ★★★☆☆  占用时间 ○○
实例287  返回记录行的物理地址	380
难度指数 ★★★☆☆  占用时间 ○○
实例288  查找列存在重复值的记录	381
难度指数 ★★★★☆  占用时间 ○○○
实例289  只保留一行列存在重复值的记录	382
难度指数 ★★★★☆  占用时间 ○○○
实例290  秒转换为时分秒格式	383
难度指数 ★★★☆☆  占用时间 ○○
实例291  创建脚本文件	384
难度指数 ★★★☆☆  占用时间 ○○
实例292  执行脚本文件	385
难度指数 ★★★☆☆  占用时间 ○○
实例293  加密存储过程	386
难度指数 ★★★★★  占用时间 ○○○
实例294  监控索引是否被引用	388
难度指数 ★★★☆☆  占用时间 ○○
实例295  去除无用索引	389
难度指数 ★★★☆☆  占用时间 ○○
实例296  提取表中[N,M]条记录	390
难度指数 ★★★★☆  占用时间 ○○○
实例297  快速编译所有视图	391
难度指数 ★★★☆☆  占用时间 ○○
实例298  读写文本型操作系统文件	392
难度指数 ★★★★☆  占用时间 ○○○
实例299  移动数据库文件	393
难度指数 ★★★☆☆  占用时间 ○○
实例300  创建一个编号会自动增加的列	394
难度指数 ★★★☆☆  占用时间 ○○
实例301  查看对象的依赖关系	395
难度指数 ★★★☆☆  占用时间 ○○
实例302  找出某段时间中的具体日期	396
难度指数 ★★★★☆  占用时间 ○○○
实例303  在查询中不让记录被更新	397
难度指数 ★★★★☆  占用时间 ○○○
实例304  避免基本表被误删	398
难度指数 ★★★☆☆  占用时间 ○○
实例305  更新数据前先保存旧值	399
难度指数 ★★★★☆  占用时间 ○○○
实例306  设置多条记录具有相同值	400
难度指数 ★★★☆☆  占用时间 ○○
实例307  列值为NULL情形的处理	401
难度指数 ★★★☆☆  占用时间 ○○
实例308  创建用户的脚本文件	402
难度指数 ★★★☆☆  占用时间 ○○
第18章  PL/SQL编程——职工管理系统	404
实例309  创建独立用户EMP	404
难度指数 ★★★☆☆  占用时间 ○○
实例310  创建基本表MYEMP	405
难度指数 ★★☆☆☆  占用时间 ○
实例311  根据职工编号查询姓名	406
难度指数 ★★☆☆☆  占用时间 ○
实例312  根据用户输入插入记录	407
难度指数 ★★☆☆☆  占用时间 ○
实例313  根据职工姓名改变工资	409
难度指数 ★★☆☆☆  占用时间 ○
实例314  根据编号查询多列信息	410
难度指数 ★★★☆☆  占用时间 ○○
实例315  根据部门号输出多行记录	411
难度指数 ★★★☆☆  占用时间 ○○
实例316  计算个人所得税	412
难度指数 ★★★☆☆  占用时间 ○○
实例317  排除无须缴纳个税的职工	413
难度指数 ★★★★☆  占用时间 ○○○
实例318  插入记录后返回提示信息	414
难度指数 ★★★☆☆  占用时间 ○○
实例319  更新工资数据后对比	415
难度指数 ★★★★★  占用时间 ○○○
实例320  设置调整工资幅度限制	416
难度指数 ★★★★☆  占用时间 ○○○
实例321  根据编号删除职工信息	417
难度指数 ★★☆☆☆  占用时间 ○
实例322  删除数据前对其备份	418
难度指数 ★★★☆☆  占用时间 ○○
实例323  禁止用户对数据进行操作	419
难度指数 ★★★★☆  占用时间 ○○○
实例324  禁止特定时间操作数据	420
难度指数 ★★★★★  占用时间 ○○○
实例325  记录用户操作表结构日志	422
难度指数 ★★★☆☆  占用时间 ○○
实例326  记录用户登录日志	423
难度指数 ★★★☆☆  占用时间 ○○
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库编程经典300例(含DVD光盘1张)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库精讲与疑难解析
第1篇  创建属于自己的Oracle数据库
第1章  认识Oracle的世界——Oracle的体系结构	2
1.1  Oracle的发家史	2
1.2  数据库	3
1.3  数据库管理系统（DBMS）	3
1.4  关系数据库的概念（RDBMS）	3
1.4.1  关系数据库模型	4
1.4.2  表	5
1.5  Oracle的总体框架结构	5
1.5.1  Oracle实例（Oracle Instance）	6
1.5.2  Oracle的存储结构	7
1.6  数据字典（Data Dictionary）	8
1.6.1  数据字典概述	8
1.6.2  数据字典的结构	8
1.6.3  数据字典的使用	8
第2章  迈出第1步——Oracle的安装/卸载	10
2.1  Oracle的安装	10
2.1.1  Oracle安装的几个概念	10
2.1.2  Oracle 11g R2（11.2）的安装——Windows篇	12
2.1.3  Oracle 11g RAC的安装——Linux篇	27
2.1.4  Oracle安装疑难解析	98
2.2  Oracle的卸载	123
2.2.1  Oracle完全卸载——Windows篇	123
2.2.2  Oracle完全卸载——UNIX篇	128
第3章  有米之炊——数据库的创建与删除	137
3.1  创建数据库	137
3.1.1  数据库创建概述	137
3.1.2  Solaris下用DBCA创建数据库	139
3.1.3  DIY——Solaris下手工创建数据库	149
3.1.4  数据库创建疑难解析	155
3.2  删除数据库	164
3.2.1  数据库删除概述	164
3.2.2  数据库删除——手工篇	165
3.2.3  数据库删除——DBCA篇	165
第2篇  网络管理
第4章  Oracle网络管理并不难	168
4.1  Oracle网络体系结构	168
4.1.1  Oracle应用的几种网络结构	168
4.1.2  Oracle Net	170
4.1.3  OSI模型	170
4.1.4  Oracle Net的堆栈结构	171
4.1.5  Oracle监听器	172
4.1.6  连接描述符（connect identifier）	173
4.1.7  网络服务名（Net Service Name）	174
4.1.8  命名方法	176
4.1.9  配置Oracle网络的工具	176
4.2  Oracle网络管理实务	176
4.2.1  Oracle网络服务器端配置	176
4.2.2  Oracle网络客户端配置	182
4.3  Oracle网络管理疑难解析	187
4.3.1  Oracle网络服务器端配置疑难解析	187
4.3.2  Oracle网络客户端配置疑难解析	194
4.3.3  Oracle网络与防火墙（Firewall）	215
第3篇  系统管理
第5章  系统管家婆——SQL*Plus的使用	222
5.1  系统管理工具SQL*Plus	222
5.2  SQL缓冲区（SQL Buffer）	223
5.3  SQL*Plus的环境配置	223
5.3.1  SQL*Plus的环境变量	223
5.3.2  SQL*Plus站点配置文件（Site Profile）	223
5.3.3  SQL*Plus用户配置文件（User Profile）	223
5.4  SQL*Plus的启动	223
5.5  SQL*Plus专有命令介绍	225
5.5.1  登录、注销命令	225
5.5.2  编辑命令	225
5.5.3  其他有用的SQL*Plus命令	227
5.6  SQL*Plus实务与疑难解析	228
第6章  有始有终——数据库的启动与关闭	247
6.1  数据库启动	247
6.1.1  数据库启动原理	247
6.1.2  数据库启动实务	248
6.1.3  数据库启动疑难解析	261
6.2  数据库关闭	284
6.2.1  数据库关闭原理	284
6.2.2  数据库的关闭（SHUTDOWN）实务	284
6.2.3  数据库关闭疑难解析	288
第7章  理清两个模式问题——专有/共享服务器模式	292
7.1  理解专有服务器模式	292
7.2  共享服务器模式原理	293
7.2.1  共享服务器模式的架构	293
7.2.2  监听器和调度进程的关系	293
7.2.3  请求队列（Request Queue）/响应队列（Response Queue）	294
7.2.4  调度进程（Dispatcher Processes，Dnnn）	294
7.2.5  共享服务器进程（Shared Server Processes，Snnn）	294
7.3  共享服务器模式实务	294
7.4  共享服务器模式疑难解析	305
第8章  掌握两个管理问题——表空间和数据文件的管理	317
8.1  数据库存储结构	317
8.1.1  物理结构	317
8.1.2  逻辑结构	320
8.2  深刻理解表空间	327
8.2.1  大文件表空间	327
8.2.2  系统表空间	327
8.2.3  辅助表空间	327
8.2.4  回滚表空间（Undo Tablespace）	327
8.2.5  临时表空间	330
8.2.6  表空间中区的管理方式	331
8.2.7  表空间中段的管理方式	332
8.2.8  非标准块表空间	333
8.2.9  表空间的离线（Offline）与在线（Online）	333
8.2.10  只读表空间（Read-Only Tablespace）	333
8.3  深刻理解数据文件	334
8.3.1  数据文件的内容	334
8.3.2  数据文件的尺寸（Size）	334
8.3.3  离线数据文件	334
8.3.4  临时数据文件（Temporary Datafiles）	334
8.4  表空间管理实务与疑难解析	335
8.4.1  永久表空间管理	335
8.4.2  临时表空间管理实务与疑难解析	366
8.4.3  回滚表空间管理实务与疑难解析	373
8.5  数据文件管理实务与疑难解析	379
8.5.1  数据文件管理实务	379
8.5.2  数据文件管理疑难解析	388
第9章  进程管理	390
9.1  Oracle进程简介	390
9.2  用户进程	391
9.3  Oracle进程	391
9.3.1  服务器进程	391
9.3.2  后台进程	391
9.4  进程综合管理实务与疑难解析	395
9.5  会话管理实务与疑难解析	403
第10章  内存管理	408
10.1  Oracle内存结构简介	408
10.2  系统全局区（SGA）	409
10.2.1  SGA简介	410
10.2.2  SGA组成	411
10.3  程序全局区（PGA）	414
10.3.1  私有SQL区	414
10.3.2  SQL工作区	415
10.3.3  用户全局区	415
10.4  软件代码区	415
10.5  管理Oracle内存的方式	415
10.5.1  PGA自动管理	415
10.5.2  SGA自动管理	416
10.5.3  自动内存管理	416
10.6  内存管理实务与疑难解析	416
第11章  用户管理	439
11.1  用户验证	440
11.1.1  口令认证	440
11.1.2  外部认证	440
11.1.3  全局认证	441
11.2  Oracle的安全大门——权限（Privileges）	441
11.2.1  系统权限	441
11.2.2  对象权限	444
11.3  使权限管理变得更加容易——角色（Role）	445
11.4  限制用户的资源消耗——资源限制文件（Profile）	446
11.4.1  资源限制的级别	447
11.4.2  限制资源的参数	447
11.5  用户与权限管理实务与疑难解析	448
11.5.1  用户管理实务与疑难解析	448
11.5.2  权限管理实务与疑难解析	453
11.5.3  角色管理实务与疑难解析	457
11.5.4  资源限制文件管理实务与疑难解析	463
第4篇  移动数据库
第12章  数据导出	468
12.1  数据导出方法介绍	468
12.1.1  Oracle最新导出工具——Data Pump Export	468
12.1.2  Oracle原来的导出工具——Export	468
12.2  数据导出实务	471
12.3  数据导出疑难解析	489
第13章  数据导入	508
13.1  数据导入方法介绍	508
13.1.1  Oracle最新导入工具——Data Pump Import	508
13.1.2  Oracle以前的导入方法——Import	508
13.2  数据导入实务	510
13.3  数据导入疑难解析	530
第5篇  Oracle文件管理
第14章  重中之重——控制文件的管理	544
14.1  控制文件的概念	544
14.2  控制文件管理实务与疑难解析	545
第15章  成为数据库的最高统治者——口令文件（Password File）管理	555
15.1  超级用户权限（SYSDBA、SYSOPER）介绍	555
15.2  口令文件的基本概念	556
15.3  启用口令文件认证	557
15.4  口令文件管理实务与疑难解析	558
第16章  联机日志文件管理	571
16.1  联机日志文件的概念	571
16.1.1  联机日志文件的内容	571
16.1.2  联机日志文件的循环利用	572
16.2  联机日志文件管理实务与疑难解析	572
第17章  参数文件（PFILE/SPFILE）管理	584
17.1  参数文件的基本概念	584
17.2  初始化参数文件	585
17.3  服务器参数文件	585
17.4  初始化参数的修改	585
17.5  参数管理实务与疑难解析	586
第6篇  Oracle高级专题
第18章  全球应用——分布式数据库疑难攻略	594
18.1  分布式数据库系统的概念	594
18.1.1  同构分布式数据库系统	595
18.1.2  异构分布式数据库系统	595
18.1.3  数据库链接（Database Link）	595
18.2  分布式数据库管理实务与疑难解析	595
第19章  并不陌生的问题——裸设备	603
19.1  裸设备的概念	603
19.2  裸设备管理实务与疑难解析	604
第7篇  数据库备份/恢复
第20章  备份/恢复之基石——归档（Archivelog）管理	612
20.1  归档的基本概念	612
20.1.1  非归档模式	612
20.1.2  归档模式	613
20.1.3  归档路径	613
20.2  归档管理实务与疑难解析	614
第21章  必行之举——数据库备份	636
21.1  理解数据库备份	636
21.1.1  数据库失败的种类	637
21.1.2  备份和恢复的解决方案	637
21.1.3  备份和恢复的物理结构	638
21.1.4  备份的类型	638
21.1.5  执行用户管理的备份	638
21.2  恢复管理器（RMAN）	639
21.2.1  通道	640
21.2.2  备份集的维护	640
21.2.3  RMAN资料库	642
21.2.4  RMAN的使用	643
21.3  数据库备份实务与疑难解析	643
21.4  恢复目录管理实务与疑难解析	665
第22章  失而复得——数据库恢复	673
22.1  数据库恢复	673
22.1.1  实例恢复	673
22.1.2  介质恢复	674
22.1.3  用户错误（User Error）的恢复	675
22.2  数据库闪回（Flashback Database）	676
22.3  用户管理的恢复（User-managed Recovery）	676
22.4  联机日志文件丢失的恢复	677
22.5  控制文件损坏的恢复	689
22.6  数据文件损坏的恢复	700
22.7  表的恢复（用户错误的恢复）	711
第8篇  Oracle程序设计
第23章  数据库通用语言——SQL语句	742
23.1  结构化查询语言简介	742
23.2  SELECT语句	743
23.2.1  理解SELECT语句	743
23.2.2  SELECT语句使用实务与疑难解析	744
23.3  INSERT语句	754
23.3.1  理解INSERT语句	754
23.3.2  INSERT语句使用实务与疑难解析	755
23.4  UPDATE语句	761
23.4.1  理解UPDATE语句	761
23.4.2  UPDATE语句使用实务与疑难解析	761
23.5  DELETE语句	763
23.5.1  理解DELETE语句	763
23.5.2  DELETE语句的使用	763
23.6  SQL语句中，集合函数使用实务与疑难解析	766
第24章  模式对象（Schema Object）的管理	771
24.1  模式（Schema）的概念	771
24.2  模式对象管理	772
24.2.1  表（Table）	772
24.2.2  索引（Index）	790
24.2.3  外部表（External Table）	795
24.2.4  临时表（Temporary Table）	805
24.2.5  分区表（Partition Table）	809
24.2.6  聚簇（Cluster）	822
24.2.7  索引组织表（Index-Organized Table，IOT）	825
24.2.8  视图	831
24.2.9  同义词	836
24.2.10  序列	839
第25章  PL/SQL应用程序开发	844
25.1  PL/SQL简述	844
25.1.1  PL/SQL块结构	844
25.1.2  数据类型	845
25.1.3  运算符	845
25.1.4  PL/SQL语句控制结构	846
25.2  存储过程（Stored Procedure）	847
25.2.1  存储过程的基本原理	847
25.2.2  存储过程管理实务与疑难解析	847
25.3  函数（Function）	863
25.3.1  函数的基本原理	863
25.3.2  函数的管理实务与疑难解析	863
25.4  包	871
25.4.1  包的基本原理	871
25.4.2  包管理实务与疑难解析	871
25.5  触发器	878
25.5.1  触发器的基本原理	878
25.5.2  触发器管理实务与疑难解析	879
25.6  游标	899
25.6.1  游标的基本原理	899
25.6.2  游标管理实务与疑难解析	899
第9篇  内存探索
第26章  勿忘历史——Oracle内存管理的变迁	908
26.1  Oracle 内存变迁概述	908
26.2  Oracle 7 的内存管理	908
26.3  Oracle 8/8i的内存管理	909
26.4  Oracle 9i的内存管理	909
26.5  Oracle 10g的内存管理	909
26.6  Oracle 11g的内存管理	909
第27章  SGA之家——共享内存段	911
27.1  共享内存段的基本概念	911
27.2  共享内存段与内核参数	911
27.3  数据库启动与共享内存段	911
27.4  设置共享内存段	912
27.5  共享内存段的管理工具	913
27.5.1  Oracle小工具——sysresv	914
27.5.2  Oracle调试工具——oradebug	914
27.5.3  操作系统工具——ipcs（ipcrm）	915
27.6  查看内核参数对共享内存段的限制	916
27.7  共享内存段的空间使用情况	916
27.8  共享内存段与进程	917
27.9  删除共享内存段	917
第28章  内存管理效率的提升——HugePage	919
28.1  HugePage的原理	919
28.2  HugePage的配置	920
28.3  HugePage疑难解析	923
第29章  内存管理方式的巨变——内存文件系统	928
29.1  内存文件系统	928
29.2  第一阶段：传统模式（共享内存段）	929
29.3  第二阶段：新型模式（内存文件系统）	929
29.4  第三阶段：内存文件系统的设置	931
29.5  第四阶段：从“新型模式”切换到“传统模式”	931
第10篇  I/O探索
第30章  永恒的主题——I/O（同步I/O、异步I/O、直接I/O）	934
30.1  磁盘的物理结构	934
30.1.1  盘片（碟片，Platter）	934
30.1.2  磁头（Head）	934
30.1.3  磁道（Track）	934
30.1.4  扇区（Sector）	934
30.2  磁盘工作原理	935
30.2.1  寻道时间（Seek Time）	935
30.2.2  旋转延迟（Rotational Latency）	935
30.2.3  传输时间（Transfer Time）	935
30.2.4  访问时间（Access Time）	935
30.3  衡量磁盘性能的两个指标	935
30.4  I/O介绍	935
30.4.1  同步I/O	936
30.4.2  异步I/O	936
30.4.3  直接I/O	936
30.4.4  Oracle与I/O配置	936
30.4.5  异步I/O的使用	936
30.4.6  直接I/O的使用	938
30.5  随机I/O和顺序I/O	939
30.5.1  随机I/O的原理	939
30.5.2  顺序I/O的原理	940
30.6  I/O大比拼	940
30.6.1  随机I/O和顺序I/O的巨大反差	940
30.6.2  同步I/O和异步I/O的对比	940
30.6.3  直接I/O与内存的使用	941
第11篇  RAC管理
第31章  理论奠基——RAC简介	944
31.1  高可用性介绍	944
31.2  Oracle 集群	945
31.3  硬件架构	946
31.3.1  服务器介绍	946
31.3.2  共享存储介绍	946
31.3.3  网络介绍	952
31.4  软件架构	954
31.4.1  软件分层	954
31.4.2  Oracle Clusterware软件	955
31.4.3  Oracle RAC软件	962
第32章  RAC的意义——负载均衡和失败转移	963
32.1  负载均衡	963
32.1.1  负载均衡简介	963
32.1.2  客户端负载均衡	964
32.1.3  服务器端负载均衡	967
32.2  失败转移	967
32.2.1  失败转移简介	967
32.2.2  失败转移实战	967
第33章  存储的主打曲——自动存储管理（ASM）	973
33.1  ASM基本概念	973
33.1.1  ASM实例（ASM Instance）	973
33.1.2  ASM磁盘组（ASM Disk Group）	973
33.1.3  ASM文件（ASM File）	974
33.1.4  区（Extent）	974
33.1.5  镜像和失败组（Mirroring and Failure Group）	975
33.2  配置ASM实例	976
33.2.1  创建ASM实例	976
33.2.2  ASM的初始化参数	978
33.2.3  ASM实例的连接	979
33.2.4  ASM的启动	979
33.2.5  ASM的关闭	980
33.2.6  检查ASM实例的状态	981
33.3  磁盘组的管理	981
33.3.1  准备磁盘（以裸设备为例）	981
33.3.2  确保ASM能够搜索到磁盘	984
33.3.3  创建磁盘组	985
33.3.4  磁盘组的加载/卸载	987
33.3.5  在磁盘组上创建表空间	988
33.3.6  往磁盘组中添加磁盘	989
33.3.7  从磁盘组中删除磁盘	989
33.3.8  删除磁盘组	989
33.3.9  手工重平衡磁盘组中的文件	990
33.3.10  磁盘和磁盘组的信息	990
33.4  管理工具ASMCMD	991
33.5  动态卷管理器（ADVM）和集群文件系统（ACFS）	992
33.5.1  动态卷管理器（ADVM）的使用	993
33.5.2  集群文件系统（ACFS）的使用	996
33.6  ASM管理疑难解析	997
第34章  练兵场——RAC管理	1003
34.1  你必须清楚的一件情——命令运行环境	1003
34.2  集群管理工具	1003
34.3  集群的启动和关闭	1004
34.4  IP地址管理	1005
34.4.1  SCAN VIP的漂移	1005
34.4.2  检查SCAN的配置	1005
34.4.3  修改SCAN VIP和VIP	1005
34.4.4  私有IP地址的修改	1008
34.4.5  修改SCAN监听器的端口	1009
34.5  实例的管理	1010
34.5.1  实例的启动和关闭	1010
34.5.2  数据库的启动和关闭	1011
34.5.3  参数文件（PFILE、SPFILE）管理	1011
34.5.4  会话管理	1013
34.6  物理结构管理	1013
34.6.1  回滚表空间的管理	1013
34.6.2  联机重做日志的管理	1014
34.6.3  集群注册表（OCR）的管理	1015
34.6.4  Oracle本地注册表（OLR）的管理	1019
34.6.5  表决盘（Voting Disk）的管理	1020
34.6.6  集群注册表和表决盘管理实务	1022
34.7  节点管理	1029
34.7.1  节点失败那点事儿	1029
34.7.2  数据库管理模式	1030
34.7.3  删除节点	1031
34.7.4  增加节点	1042
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库精讲与疑难解析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入解析oracle
第1章 oracle数据库的创建
第2章 使用模板创建数据库
第3章 插接式数据库
第4章 数据库的启动和关闭
第5章 参数及参数文件
第6章 控制文件与数据库初始化
第7章 控制文件与启动校验
第8章 数据字典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入解析oracle
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle大数据解决方案
第Ⅰ部分引言
第1章大数据简介
1.1大数据
1.2谷歌的MapReduce算法和ApacheHadoop
1.3Oracle的大数据平台
1.4总结
第2章大数据的价值
2.1我是大数据吗？还是大数据是我？
2.2大数据，小数据--仍然是数据
2.2.1什么已经发生了？
2.2.2现在发生了什么？
2.3请看看现实！
2.4你想把它做成什么？
2.5大数据，大数字，大企业？
2.5.1Twitter
2.5.2Facebook
2.5.3内部源
2.5.4ICR：连接
2.5.5ICR：变更
2.6需要：大数据的价值
2.6.1大数据案例1：医疗行业的临床试验研究
2.6.2大数据案例2：在汽车行业的汽车设计中改进驾驶员安全
2.7总结
第II部分大数据平台
第3章ApacheHadoop平台
3.1软件与硬件
3.2Hadoop的软件平台
3.2.1Hadoop的发布与版本
3.2.2HadoopDistributedFileSystem(HDFS)
3.2.3调度、计算和处理
3.3操作系统的选择
3.4Hadoop硬件平台
3.4.1CPU和内存
3.4.2网络
3.4.3磁盘
3.5整合在一起
第4章选择Appliance的理由
4.1Oracle创建大数据机的理由
4.2Appliance的概念
4.3OracleBigDataAppliance的发展目标
4.4Appliance优化
4.5OracleBigDataAppliance第2版软件
4.6Oracle大数据机X3-2硬件
4.7Oracle获取Hadoop知识的地方
4.8配置Hadoop集群
4.8.1选择核心集群组件
4.8.2组装集群
4.9自己组建的集群
4.10集群总成本
4.11时间价值
4.12如何打造更大的集群
4.13Oracle大数据机可否支持其他软件
4.14一体机的缺陷
第5章BDA配置、部署架构和监控
5.1介绍
5.1.1大数据机X3-2满配机架(18个节点)
5.1.2大数据机X3-2入门机架(6个节点)
5.1.3大数据机X3-2扩展机架(6个节点)
5.1.4BDA的硬件修改
5.1.5大数据机X3-2的软件支持
5.2BDA安装和配置过程
5.3关键和非关键节点
5.4NameNode故障自动切换
5.5BDA磁盘存储布局
5.6为Hadoop集群增加存储
5.7仅有Hadoop配置和Hadoop+NoSQL数据库
5.7.1仅有Hadoop的一体机
5.7.2Hadoop和NoSQL数据库
5.8内存选项
5.9部署架构
5.9.1云中的多租户和Hadoop
5.9.2可扩展性
5.9.3BDA多机架的注意事项
5.10在BDA上安装其他软件
5.11数据中心的BDA
5.11.1管理网络
5.11.2客户端访问网络
5.11.3Infiniband私有网络
5.11.4网络需求
5.11.5连接到数据中心的局域网
5.11.6连接架构的例子
5.12Oracle大数据机的使用限制
5.13BDA的管理和监控
5.13.1企业管理器
5.13.2Cloudera管理器
5.13.3Hadoop的监控工具：Web图形用户界面
5.13.4OracleILOM
5.13.5Hue
5.13.6DCLI工具
第6章为大数据集成数据仓库和分析基础架构
6.1数据仓库作为存储历史记录的数据库
6.1.1Oracle数据库作为数据仓库
6.1.2为什么要把数据仓库和Hadoop部署在一起
6.2完成路径：业务分析师工具
6.3扩建基础设施
第7章BDA连接器
7.1OracleBigDataConnectors
7.2OracleLoaderforHadoop
7.2.1在线模式
7.2.2OracleOCIDirectPathOutput
7.2.3JDBCOutput
7.2.4离线模式
7.2.5OracleDataPumpOutput
7.2.6带分隔符的文本输出
7.3安装OracleLoaderforHadoop
7.4调用OracleLoaderforHadoop
7.5输入格式
7.5.1DelimitedTextInputFormat
7.5.2RegexInputFormat
7.5.3AvroInputFormat
7.5.4HiveToAvroInputFormat
7.5.5KVAvroInputFormat
7.5.6自定义输入格式
7.6OracleLoaderforHadoop配置文件
7.6.1LoaderMaps
7.6.2额外的优化
7.6.3利用Infiniband
7.6.4对比ApacheSqoop
7.7OracleSQLConnectorforHDFS
7.8安装OracleSQLConnectorforHDFS
7.9Hive安装
7.10使用OracleSQLConnectorforHDFS创建外部表
7.10.1ExternalTable配置工具
7.10.2数据源类型
7.10.3配置工具语法
7.10.4必需的属性
7.10.5可选属性
7.10.6针对带分隔符的ExternalTable工具
7.10.7在使用--noexecute选项的情况下测试DDL
7.10.8在位置文件里增加一个新的HDFS文件
7.10.9外部表的手动配置
7.11Hive源
7.12OracleDataPump源
7.13配置文件
7.14使用OracleSQLConnectorforHDFS查询
7.15OracleRConnectorforHadoop
7.16OracleDataIntegratorApplicationAdapterforHadoop
第8章OracleNoSQL数据库
8.1NoSQL数据库系统的定义
8.2OracleNoSQL数据库
8.3架构
8.3.1客户端驱动程序
8.3.2键-值对
8.3.3存储节点
8.3.4复制
8.3.5智能拓扑
8.3.6在线的灵活性
8.3.7没有单点故障
8.4数据管理
8.4.1API
8.4.2CRUD操作
8.4.3多种更新操作
8.4.4查找操作
8.4.5事务
8.4.6可预测的性能
8.5集成
8.6安装和管理
8.6.1简单安装
8.6.2管理
8.7OracleNoSQL数据库的特性
8.8有用的链接
第III部分分析信息和制定决策
第9章数据库库内分析：快速交付彰显时间价值
9.1介绍
9.1.1Oracle数据库内分析
9.1.2为什么在数据库内运行如此重要
9.2Oracle数据挖掘和统计分析介绍
9.2.1Oracle库内高级分析
9.2.2Oracle数据挖掘
9.2.3R语言介绍
9.2.4文本挖掘
9.3库内统计函数
9.4空间分析
9.4.1理解空间数据模型
9.4.2查询空间数据模型
9.4.3使用空间分析
9.4.4让BI工具更聪明
9.5基于图形分析
9.5.1图形数据模型
9.5.2查询图形数据
9.6多维分析
9.7库内分析：综合范例
9.7.1在ETL过程中集成分析
9.7.2提供指导浏览
9.7.3提供混搭式分析
9.8总结
第10章使用R分析数据
第11章Endeca信息发现
第12章大数据治理
第13章大数据开发架构和路线图
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle大数据解决方案
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8初学者指南
目 录
译者序
序
引言
第1章 Oracle介绍
1.1术语
1.2什么是Oracle
1.2.1开端
1.2.2开端小结
1.2.3今天的Oracle
1.3Oracle8服务器
1.3.1为什么Oracle拥有今天的地位
1.3.2Oracle7/8服务器的组件
1.4SQL*Plus――友好的用户接口
1.5OracleForms―― 前端产品
1.6Orac leReports――报表生成器
1.6.1主/细 目报表
1.6.2矩阵报表
1.6.3窗体信件
1.7Orac leBook
1.8OracleLoader和SQL*Connect
1.9Oracle使用自己的工具――应用软件
1.10OracleInterOffice
1.11Develope r/2000与Designer/2000
1.12PersonalOracle
1.13服务
1.14Oracle用户组――事件和出版物
1.15Oracle的数据仓库
1.16网络计算
1.17本章小结
第2章 Oracle8一瞥以及面向对象的
数据库
2.1术语
2.2什么是面向对象的数据库
2.2.1什么是对象
2.2.2什么是类
2.2.3封装
2.2.4数据库触发器
2.2.5可扩充性
2.2.6继承
2.2.7多态
2.2.8面向对象技术小结
2.3Oracle8一瞥
2.3.1Oracle8的聚焦区
2.3.2Oracle8备份和恢复
2.4Oracle8的对象和新数据库对象
2.4.1嵌套对象
2.4.2可变数组
2.4.3类型中的类型
2.4.4方法和类型
2.4.5对象视图
2.5小结
2.6本章小结
第3章 结构
3.1术语
3.2为什么要学习结构
3.3什么是数据库
3.3.1数据文件
3.3.2用户数据和系统数据
3.3.3什么是数据库小结
3.4表空间――Oracle的文件夹
3.4.1表空间的名称和内容
3.4.2表空间小结，
3.5重演日志――事务日志
3.5.1重演日志怎样工作
3.5.2重演日志小结
3.6控制文件
3.7程序
3.7.1用户（客户机）进程
3.7.2服务器进程
3.7.3程序小结
3.8数据库支持进程
3.8.1数据库写入器
3.8.2校验点
3.8.3日志写入器
3.8.4系统监控器
3.8.5进程监控器
3.8.6归档器
3.8.7锁
3.8.8恢复器
3.8.9调度
3.8.10数据库支持进程小结
3.9内存结构――电话线路
3.9.1系统全局区
3.9.2程序全局区
3.9.3内存结构小结
3.10什么是Oracle实例
3.11综合举例
3.12多线程服务器（MTS）的进一步了解
3.13本章小结
第4章 数据库对象
4.1术语
4.2表――Oracle存放用户数据的所在
4.3视图――数据查看的特殊方式
4.3.1为何要用视图
4.3.2创建视图
4.4索引――加快访问数据的方法
4.4.1索引有顺序
4.4.2索引可保证数据唯一性
4.4.3并联索引
4.4.4where子句和索引
4.5同义词――新的标识符
4.6授权访问
4.6.1给用户授权
4.6.2接受授权
4.7角色――成组管理用户的方法
4.8Oracle8中可能会见到的对象
4.8.1快照
4.8.2存贮对象
4.8.3数据库连接
4.8.4序列
4.8.5 聚集
4.9查看数据字典中的对象
4.10 本章小结
第5章 安 装
5.1术语
5.2Oracle8的通用服务器
5.2.1服务器安装
5.2.2客户机安装
5.3在UNIX上安装Oracle
5.3.1创建中转区
5.3.2启动安装程序
5.3.3友好的安装程序
5.3.4安装程序环境
5.4非桌面环境Oracle产品安装
5.5桌面环境PersonalOracle安装
5.5.1预安装活动
5.5.2从90天试用CD 上安装Personal
Oracle
5.5.3安装从Web卸载的Personal
Oracle
5.6桌面环境Oracle产品安装
5.7本章小结
第6章 SQL101
6.1术语
6.2两种类型的SQL语句
6.2.1DDL
6.2.2DML
6.3SQLPlus人门
6.3.1create语句
6.3.2Describe
6.3.3insert
6.3.4select
6.3.5where
6.3.6orderby
6.4数值型数据
6.5字符型数据
6.6日期型数据
6.6.1日期型函数
6.6.2特殊格式的日期型数据
6.6.3日期运算
6.7表列数据类型转换
6.8Update、IDelete和Alter
6.8.1update
6.8.2delete
6.8.3alter
6.9连接两个表
6.10格式化输出
6.10.1页和行的大小
6.10.2页头标
6.10.3页脚标
6.10.4写SQL*Plus结果到文件
6.10.5格式化输出表列
6.11本章小结
第7章 PL/SQL
7.1术语
7.2为什么要学习PL/SQL
7.3PL/SQL字符集
7.3.1合法字符
7.3.2算术运算符
7.3.3关系运算符
7.3.4杂符号
7.4变量
7.5常用数据类型
7.5.1varchar2
7.5.2number
7.5.3date
7.5.4Boolean
7.6PL/SQL的组件
7.6.1异常
7.6.2 控制结构
7.6.3“DoNothing”与“Null”结构
7.6.4declare段
7.7光标
7.7.1显式光标
7.7.2隐式光标
7.7.3用何种光标
7.8PL/SQL表
7.9PL/SQL的注释
7.10编释错误
7.11编程实例
7.11.1实例1
7.11.2实例2
7.11.3实例3
7.12本章小结
第8章 OracleForms
8.1术语
8.2什么是OracleForms
8.3运行OracleForms所需的硬件环境
8.4如何安装OracleForms
8.5怎样在PC上运行OracleForms
8.6OracleForms Designer
8.6.1对象导航器
8.6.2画布视图
8.6.3属性表
8.6.4PL/SQL编辑器
8.6.5设置选项
8.6.6处理OracleForms文件
8.6.7右鼠标按钮
8.7缺省块实用工具
8.8经验传授
8.8.1练习＃1
8.8.2 练习＃2
8.8.3 练习＃3
8.9屏幕格式化
8.9.1色彩
8.9.2字体
8.9.3 图形
8.10（OracleFormsRuntime
8.11本章小结
第 9章 OracleReports
9.1样例数据
9.2术语
9.3什么是Ora cleReports
9.4运行OracleReports所需硬件环境
9.5安装OracleReports
9.6为运行OracleReports准备PC机
9.7OracleReports如何处理查询
9.8Orac leRe ports Desi gner
9.8.1ObjectNavigator
9.8.2设置个性
9.8.3如何利用OracleReports文件
9.8.4两个主要的Designer部件
9.8.5样例报表＃1
9.8.6样例报表＃2
9.8.7样例报表＃3
9.9Ora cleReportsRun time
9.10本章小结
第10章 Loa der
10.1术语
10.2什么是OracleLoader
10.3运行OracleLoader――Oracle8
10.3.1Userid
10.3.2Control
10.3.3Parallel
10.3.4Direct
10.3.5Skip
10.3.6Load
10.3.7Log 和Bad
10.3.8Discard
10.3.9实例＃1
10.3.10实例＃2
10.3.11实例＃3
10.4OracleLoader控制文件
10.4.1第一部分：LoadDate
10.4.2第二部分：Infile
10.4.3第三部分：IntoTable
10.4.4第四部分：列和域的说明
10.5OracleLoader的输出
10.5.1日志文件――完全装载
10.5.2日志文件――不完全装载
10.5.3Bad文件
10.5.4Discard文件
10.6本章小结
第11章 应用协调101
11.1为什么要协调Oracle系统
11.2术语
11.3协调处理中的主要组成部分
11.3.1内存
11.3.2磁盘访问
11.4使用共享池中的语句
11.4.1SQL语句处理步骤
11.4.2 书写可重用共享池中语句的
SQL语句
11.5并行处理
11.6减少等待状态
11.6.1经常提交（commit）工作
11.6.2使（Oracle做自我锁定
11.6.3 关闭不被使用的应用窗口
11.6.4有节制地使用多任务
11.7本章小结
第12章 高级SQL
12.1术语
12.2 分组结果函数
12.2.1使用groupby子句
12.2.2使用having子句
12.3嵌套查询
12.4为其他程序建立数据文件
12.5SQL创建SQL
12.6decode语句
12.7在SQL*Plus中定义变量
12.8在SQL*Plus中置换变量
12.9SQL*Plus4.0的变化
12.9.1表头和表尾命令
12.9.2存贮SQL*Plus环境
12.9.3setautotrace
12.9.4serveroutput
12.10repheader――整个表头，仅仅是
表头
12.11column――整个表列，仅仅是表
列
12.11.1格式化数字数据
12.11.2格式化字符数据
12.12new－value
12.13SQLPlus集合论
12.13.1集合并
12.13.2集合交
12.13.3集合差
12.14结构化编程技术
12.15命令行编辑
12.16SQLPlus中的空
12.16.1比较操作中的空问题
12.16.2使用NV1进行空比较操作
12.16.3Null＝Null比较的异常情况
12.17本章小结
第13章 高级应用协调
13.1术语
13.2优化
13.2.1基于代价的方法
13.2.2CBO使用控制
13.2.3统计收集（statisticcollection）的
方法学
13.2.4基于规则的方法
13.2.5为什么CBO超过基于规则的
优化
13.3SQL语句处理过程
13.3.1句法分析
13.3.2运行
13.3.3读取
13.4 命名变量
13.5索引
13.6主关键字的限定
13.7协调交换的工具
13.7.1查看SQL*Plus中共享池的
内容
13.7.2explainplan
13.7.3setautotrace的使用
13.7.4SQL跟踪程序与tkprof
13.7.5查找跟踪程序文件
13.8OracleTrace
13.9本章小结
第14章 DBA101
14.1成为数据库管理员
14.2术语
14.3企业管理器
14.3.1OEM管理工具
14.3.2企业管理器：调用
14.3.3企业管理器：连接到储藏室
14.3.4企业管理器：启动
14.3.5企业管理器：停机
14.3.6企业管理器：授予用户访问
权限
14.3.7企业管理器：回收用户访问
权限
14.3.8企业管理器：创建表空间
14.3.9企业管理器：增加空间至已有
表空间
14.4行方式服务器管理器
14.4.1服务器管理器：调用
14.4.2服务器管理器：连接内部命令
14.4.3服务器管理器：启动
14.4.4服务器管理器：关机
14.4.5服务器管理器：退出
14.4.6服务器管理器：授予用户访问
数据权限
14.4.7服务器管理器：回收用户访问
数据权限
14.4.8服务器管理器：创建表空间
14.4.9服务器管理器：为已有的表空
间增加空间
14.5全屏幕服务器管理器
14.5.1服务器管理器：调用
14.5.2服务器管理器：内部连接命令
14.5.3服务器管理器：启动
14.5.4服务器管理器：关闭
14.5.5服务器管理器：退出
14.5.6服务器管理器：授予用户访问
数据权限
14.5.7服务器管理器：回收用户访问
数据权限
14.5.8服务器管理器：创建表空间
14.5.9服务器管理器：增加空间至已
有表空间
14.6PersonalOracleforWindows95
14.6.1启动和关闭数据库
14.6.2创建一个用户
14.6.3撤销用户
14.6.4增加空间至已有表空间
14.7本章小结
第15章 卸库与装库
15.1术语
15.2卸库与装库的功能
15.3卸库与装库的相似之处
15.4卸库与装库的差异
15.5操作方法
15.5.1交互式卸库：无参数调用
15.5.2交互式装库：无参数调用
15.5.3提示应答对下一步对话产生的
影响
15.5.4提示应答对操作成功或失败的
影响
15.5.5参数驱动方式的卸库
15.5.6参数驱动方式装库
15.5.7Parfile关键字参数
15.5.8交互式与参数驱动方法的混合
使用
15.6卸库与装库方式
15.6.1表方式卸库
15.6.2用户方式卸库
15.6.3全库方式卸库
15.6.4表方式装库
15.6.5用户方式装库
15.6.6全库方式装库
15.6.7方式转换
15.6.8方式使用
15.7带分区表的卸库与装库程序
的使用
15.8运行卸库与装库的要求
15.9错误情况及解决办法
15.9.1Oracle不运行
15.9.2读取DBA创建的卸库文件
15.9.3不能启动全库方式卸库
15.10 参数之间关系
15.11 实例
15.11.1样例＃1
15.11.2 样例＃2
15.11.3样例＃3
15.12 本章小结
第16章 备份与恢复
16.1术语
16.2 由备份提供的保护措施
16.2.1保护丢失的对象
16.2.2保护丢失的数据库
16.3Oracle企业管理器备份
16.3.1BackupWizard
16.3.2数据库打开时的备份
16.4卸库与装库备份
16.4.1具有足够的空闲时限
16.4.2空闲时限不够长
16.4.3从卸库文件恢复
16.5映像备份
16.5.1冷备份
16.5.2热备份
16.6恢复
16.6.1什么是恢复
16.6.2重演日志类型
16.6.3恢复的类型
16.6.4实施完全恢复
16.6.5实施不完全恢复
16.7一个完全备份方案
16.8本章小结
第17章 数据库协调
17.1术语
17.2初始化参数文件
17.2.1初始化参数文件项的类型
17.2.2Oracle实例管理器――浏览
设置
17.2.3服务器管理器――浏览设置
17.2.4初始化参数文件――修改哪些
内容
17.2.5在Oracle8实例管理器中修改参
数值
17.2.6使用文本编辑器修改参数项
17.2.7浏览SGA的当前容量
17.2.8假脱机结果
17.3I/O流
17.3.1表和索引
17.3.2 系统表
17.3.3临时段
17.3.4回滚段
17.3.5联机重演日志
17.4概要
17.5本章小结
第18章 高级DBA
18.1术语
18.2启动命令选项
18.2.1正常启动
18.2.2安装启动
18.2.3非安装启动
18.2.4约束启动
18.2.5强制启动
18.2.6带初始化参数文件的启动
18.3操作方式
18.4 关闭选项
18.5附加的用户管理职责
18.5.1给数据库用户授权
18.5.2创建和分配新的模式文件
18.5.3创建和分配新角色
18.6附加的表空间维护职责
18.6.1为表空间增加更多的空间
18.6.2删除表空间
18.7管理重演日志组
18.7.1镜像重演日志
18.7.2增加新的重演日志组
18.7.3删除已有的重演日志组
18.8回滚段
18.8.1获取回滚段
18.8.2创建回滚段
18.8.3改变回滚段状态
18.8.4删除回滚段
18.9初始化参数文件
18.9.1初始化参数文件项的格式
18.9.2检查初始化参数文件内容
18.9.3修改参数值
18.9.4最常修改的项
18.10控制文件职责
18.10.1控制文件的使用
18.10.2增加控制文件
18.10.3删除控制文件
18.10.4移动已有的控制文件
18.10.5建立新的控制文件
18.11 最常见的错误信息
18.11.1通用DBA信息范围
18.11.2联机错误信息
18.11.3ORA－00600内部错误
18.12数据字典
18.12.1字典视图类型
18.12.2最有用的dba和V＄视图
18.13 与OracleWorldwideCustomer
Sup per保持联系
18.14结束语
第19章 数据仓库
19.1术语
19.2位图索引
19.3优化程序直方图
19.4 并行
19.4.1查询处理
19.4.2装载操作
19.4.3表和索引创建
19.5分区对象
19.5.1为什么要分区对象
19.5.2处理分区对象
19.6分区视图
19.7星形查询优化
19.8本章小结
第20章 网络计算机NC及其体系
结构
20.1术语
20.2网络计算机”NC”
20.2.1并非人人都需要强客户机
20.2.2经济地工作
20.2.3什么是零管理
20.2.4NC――模式必须变动
20.3网络计算体系结构
20.3.1何为数据插件
20.3.2插件交换
20.4本章小结
20.5结束语
附录A SQL*DBA
A.1行方式 sqldba
A.2调用
A.2.1内部连接命令
A.2.2启动数据库
A.2.3关闭数据库
A.2.4退出
A.2.5授予用户访问数据库的权限
A.2.6撤销用户的访问权限
A.2.7创建表空间
A.2.8给已有的表空间增加新的空间
A.3全屏幕sqldba
A.3.1调用
A.3.2连接内部命令
A.3.3启动数据库
A.3.4关闭数据库
A.3.5退出
A.3.6授予用户访问数据库的权限
A.3.7撤销用户的访问权限
A.3.8创建表空间
A.3.9给已有表空间增加新的空间
A.4全屏幕sqldba 的高级操作
A.5附加的用户管理职责
A.5.1分配缺省的表空间
A.5.2为用户分配空间限额
A.5.3为排序分配表空间
A.5.4组合前三个命令
A.6附加的表空间维护职责
A.6.1移动数据文件
A.6.2 删除表空间
A.7管理重演日志组
A.7.1镜像重演日志
A.7.2增加新的重演日志组
A.7.3删除已有的重演日志组
A.7.4删除重演日志文件组的问题
A.8回滚段
A.8.1获取回滚段
A.8.2创建回滚段
A.8.3改变回滚段的状态
A.8.4删除回滚段
A.9本附录小结

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8初学者指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8完全参考手册
目录
贺词
序
译者的话
前言
第一部分 必备的数据库概念
第1章 共享知识与成功
1.1 协同开发技术
1.2每个人都拥有数据
1.3Oracle语言
1.3.1信息表
1.3.2结构查询语言（SQL）
1.3.3简单的Oracle查询
1.3.4 关系的含义
1.4 一些日常的例子
1.5一个具有百年历史的例子
第2章 关系数据库中的风险
2.1真像他们所说的那么容易吗？
2.2有什么风险？
2.3新思维的重要性
2.4代码、缩写和命名标准
2.4.1为什么使用代码而不是英语
2.4.2用户反馈的益处
2.5如何减少混乱？
2.5.1规范化
2.5.2表和列的英文名称
2.5.3数据的英文名称
2.6名称和数据的大小写
2.7规范化的名称
2.8把握机会
第二部分SQL： 从入门到精通
第3章 SQL基础
3.1约定
3.2使用SQL从表中提取数据
3.3select，from，where和orderby
3.4逻辑与值
3.5LIKE
3.5.1对值的列表进行简单测试
3.5.2组合逻辑
3.6where的另一个用途――子查询
3.6.1单值子查询
3.6.2值列表子查询
3.7组合表
3.8建立视图
第4章 对象―关系数据库基础
4.1必须使用对象吗？
4.2为什么要使用对象？
4.3每个人都拥有对象
4.3.1抽象数据类型
4.3.2嵌套表
4.3.3可变数组
4.3.4大型对象
4.3.5引用
4.3.6对象视图
4.3.7对象的命名约定
4.4 一个普通的对象例子
4.4.1一个简单对象的结构
4.4.2向CUSTOMER表中插入记录
4.4.3查询抽象数据类型
4.5面向对象的分析与设计
4.6小结
第5章 基本的SQLPLUS报表和命令
5.1一个简单报表的建立
5.1.1remark
5.1.2setheadsep
5.1.3ttitle和btitle
5.1.4co1umn
5.1.5breakon
5.1.6computesum
5.1.7setlinesize
5.1.8setpagesize
5.1.9setnewpage
5.1.10spool
5.1.11
5.1.12对列标题的进一步说明
5.2其它特性
5.2.1 命令行编辑器
5.2.2setpause（页间暂停）命令
5.2.3save（保存SQL查询）命令
5.2.4编辑
5.2.5host（将命令传送给主机操作系统）
命令
5.2.6 增加SQLPLUS命令
5.2.7start（启动.SQL文件）命令
5.3 检测SQLPLUS环境
5.4小结
第6章 提取和修改文本信息
6.1 数据类型
6.2什么是串？
6.3函数的表示法
6.4 ∥（并置运算符）
6.5如何剪切和粘贴串
6.5.1RPAD（右填充）和LPAD（左填充）
函数
6.5.2LTRIM（左截断）和RTRIM
（右截断）函数
6.5.3组合使用两个函数
6.5.4 增加多个函数
6.5.5LOWER（小写转换）、UPPER（大
写转换）和INITCAP（首字母大写
转换）函 数
6.5.6 LENGTH（计算串长）函数
6.5.7SUBSTR（子串）函数
6.5.8INSTR（串搜索）函数
6.6 带串函数的orderby和where命令子句
6.6.1SOUNDEX（同音串搜索）函数
6.6.2本地语言支持
6.7 小结
第7章 处理数字
7.1数字函数的三种类型
7.2函数的表示法
7.3单值函数
7.3.1加、减、乘、除
7.3.2NULL（空值）
7.3.3NVL（空值替换）函数
7.3.4ABS（绝对值）函数
7.3.5CEIL（求最小整数）函数
7.3.6FLOOR（求最大整数）函数
7.3.7MOD（取模）函数
7.3.8POWER（求幂）函数
7.3.9SQRT（平方根）函数
7.3.10EXP，LN和LOG函数
7.3.11ROUND和TRUNC函数
7.3.12SIGN函数
7.3.13SIN，SINH，COSCOSH，TAN
和TANH函数
7.4组值函数
7.4.1组值函数中的空值（NULL）
7.4.2单值和组值函数的例子
7.4.3 AVG，COUNT，MAX，MIN和
SUM函数
7.4.4组值函数和单值函数的组合
7.4.5STDDEV和VARIANCE函数
7.4.6组值函数中的DISTINCT
7.5列表函数
7.6通过MAX或MIN查找行
7.7优先级和圆括号
7.8小结
第8章 日期：过去、现在及其差值
8.1日期运算
8.1.1系统日期（SysDate）
8.1.2两个日期之间的差值
8.1.3增加月份
8.1.4减去月份
8.1.5GREATEST和LEAST函数
8.1.6NEXT＿DAY函数
8.1.7LAST＿DAY函数
8.1.8用MONTHS＿BETWEEN
处理两个日期
8.1.9组合日期函数
8.2 日期计算中的ROUND和TRUNC
函数
8.3TO＿DATE和TO＿CHAR的格式转换
8.3.1使用TO＿CHAR函数时最常见的
错误
8.3.2NEW＿TIME函数――时区转换
8.3.3使用TO＿DATE函数进行计算
8.4 where子句中的日期
8.52000年带来的问题
第9章 转换和变换函数
9.1基本的转换函数
9.1.1数据类型的自动转换
9.1.2数据类型自动转换的注意事项
9.2特殊的转换函数
9.3变换函数
9.3.1TRANSLATE函数
9.3.2DECODE函数
9.4 小结
第10章 分组聚合
10.1groupby和having子句的用法
10.1.1orderby子句
10.1.2执行的顺序
10.2聚组视图
10.3聚组视图功能
10.3.1having子句中的逻辑
10.3.2用列和组函数排序
10.3.3列的连接
10.4小结
第11章 查询间的依赖关系
11.1高级子查询
11.1.1 相关子查询
11.1.2对等逻辑测试
11.1.3EXISTS（存在性测试）及其
相关子查询
11.2 外连接
11.2.1用外连接替代“NOTIN”
11.2.2用NOTEXISTS代替NOTIN
11.3UNION、INTERSECT和
MINUS运算符
11.3.1IN子查询
11.3.2UNION运算符
11.3.3INTERSECT运算符
11.3.4 MINUS运算符
11.3.5小结（关于UNIONINTERSECT
和MINUS的限制）
第12章 几个复杂功能
12.1创建复杂的视图
12.1.1组视图
12.1.2合计视图
12.1.3组合视图
12.2家族树（familytree）和connectby
子句
12.2.1排除单一体及分枝
12.2.2遍历至根
12.2.3基本规则
12.3在from子句中使用视图
第13章 在SQLPLUS中建立报表
13.1高级格式
13.1.1数字的格式问题
13.1.2breakon命令
13.1.3breakon命令中列的顺序
13.1.4行中的breakon命令
13.1.5增加视图
13.1.6 使用ttitle和btitle命令的列
13.1.7关于break和compute命令的
进一步说明
13.2settermoutoff和settermouton
命令
13.3SQLPLUS中的变量
13.4数字格式
13.5使用mask.sql
13.6使用缓冲区保存SQLPLUS命令
13.7showall命令及转储
13.8折到新的一行
13.9其他报表控制
第14章 改变数据：插入 修改和删除
14.1insert命令
14.1.1插入时间
14.1.2 带select子句的插入
14.2rollback（转返），commit提交）和
autocommit（自动提交）命令
14.2.1隐式提交
14.2.2自动转返
14.3delete（删除）命令
14.4update（修改）命令
14.4.1嵌入select语句的update命令
14.4.2用NULL（空值）进行修改
第15章 函数和变量的高级用途
15.1orderby子句中的函数
15.2直方图和图形
15.3使用TRANSLATE函数
15.3.1消去字符
15.3.2清除美元符号和逗号
15.4复杂的剪切和粘贴
15.5统计串在更大串中的出现次数
15.6变量和转储代换
15.6.1关于变量的一些其他情况
15.6.2有关set命令
第16章 DECODE――一个有特异功能的
函数
16.1if，then和else
16.2实例：发票
16.3表的转置
16.4在DECODE函数中使用MOD函数
16.5orderby和RowNum
16.6在then和else子句中的列和计算
16.7DECODE函数中的大于（GreaterThan）
小于（LessThen）和等于（Equal）
第17章 创建 删除 修改表与视图
17.1创建 个表
17.1.1 字符型列的宽度和数值型列
的精度
17.1.2插入中的截取
17.1.3创建表时受到的限制
17.1.4 约束的命名
17.2删除表
17.3修改表的结构
17.4创建视图
17.4.1视图的稳定性
17.4.2视图中的orderby子句
17.4.3创建只读视图
17.5从表中创建表
17.6创建一个Index－Only表
17.7使用分区的表
17.7.1创建分区的表
17.7.2索引分区
17.7.3管理分区的表
17.7.4 从分区中直接查询
第18章 权限
18.1用户、角色和权限
18.1.1创建用户
18.1.2口令管理
18.1.3三种标准角色
18.1.4grant（授权）命令的格式
18.1.5撤消权限
18.2用户可授予什么？
18.2.1用connect命令连接到其他用户
18.2.2创建同义词
18.2.3使用未授予的权限
18.2.4 传递权限
18.2.5创建角色
18.2.6给角色授权
18.2.7将一个角色授予另一个角色
18.2.8给角色增加口令
18.2.9删除角色的口令
18.2.10启用和禁用角色
18.2.11从角色撤消权限
18.2.12删除角色
18.2.13授权修改指定的列
18.2.14撤消权限
18.2.15用户安全性
18.2.16对公众授予访问权
18.3授予有限的资源
第19章 改变Oracle环境
19.1索引
19.1.1创建索引
19.1.2强制唯
19.1.3建立位图索引
19.1.4何时建立索引
19.1.5何时忽略索引
19.1.6索引列数据的变化
19.1.7一个表可使用多少索引
19.1.8在数据库中放置索引
19.1.9重建索引
19.2表空间和数据库结构
19.3簇（cluster）
19.4序列
第20章 SQLPLUS
20.1生成查询代码
20.2装载变量
20.2.1改变变量值
20.2.2在ttitle命令中使用变量
20.2.3字符串和日期
20.3建立并嵌套启动文件和命令
20.4小结
第21章 访问远程数据
21.1数据库链接
21.1.1数据库链接是如何工作的
21.1.2对远程查询使用数据库链接
21.1.3对同义词和视图使用数据库
链接
21.1.4 使用数据库链接进行远程
更新
21.1.5 数据库链接语法
21.2为地点透明性而使用同义词
21.3在视图中使用user伪列
21.4动态链接：使用SQLPLUScopy
命令
21.5链接一个远程数据库
21.6管理工具：Oracle*Names
第22章 PL/SQL介绍
22.1PL/SQL简介
22.2声明段
22.3可执行命令段
22.3.1条件逻辑
22.3.2循环
22.3.3Goto语句
22.4异常处理段
第23章 触发器
23.1所需的系统特权
23.2所需的表权限
23.3触发器类型
23.3.1行级别（Row－Level）触发器
23.3.2语句级别（Statement－Level）
触发器
23.3.3BEFORE和AFTER触发器
命令
23.3.4INSTEADOF触发器命令
23.3.5合法的触发器类型
23.4触发器语法
23.4.1合并触发器类型
23.4.2设置插入值
23.4.3维护数据复本
23.4.4定义错误条件
23.4.5触发器命名
23.5激活和取消触发器
23.6替代触发器
23.7删除触发器
第24章 过程
24.1必要的系统权限
24.2必要的表权限
24.3过程与函数的比较
24.4过程与包的比较
24.5创建过程的语法
24.6创建函数的语法
24.6.1在过程中引用远程表
24.6.2过程的调试
24.6.3创建用户自己的函数
24.6.4定制错误条件
24.6.5过程的命名
24.7创建包的语法
24.8查看当前过程对象的源代码
24.9编译过程、函数和包
24.10过程、函数和包的替换
24.11过程、函数和包的删除
第25章 类型、对象视图和方法的实现
25.1 再谈抽象数据类型
25.1.1 抽象数据类型的安全性
25.1.2索引抽象数据类型属性
25.2对象视图的实现
25.2.1通过对象视图的数据操作
25.2.2使用INSTEAD OF触发器
25.3方法（methods）
25.3.1创建方法的语法
25.3.2方法的管理
第26章 收集器（嵌套表和可变数组）
26.1可变数组（varing Arrays）
26.1.1创建一个可变数组
26.1.2可变数组的描述
26.1.3向可变数组中插入数据
26.1.4 从可变数组中提取数据
26.2嵌套表
26.2.1向嵌套表中插入记录
26.2.2查询嵌套表
26.3嵌套表和可变数组的管理
26.3.1对大型收集器的管理
26.3.2 收集器中的可变性
26.3.3数据的存放位置
第27章 在Oracle8中使用大型对象
（LOB）
27.1可用的数据类型
27.2对LOB数据指定存储
27.3操作和检索LOB数值
27.3.1初始化值
27.3.2带子查询的数据输入
27.3.3更新LOB值
27.3.4 使用DBMS＿LOB来操作
LOB值
27.3.5删除LOBs
第28章 快照
28.1快照的功能
28.2所需的系统权限
28.3所需的表权限
28.4 简单的和复杂的快照
28.5只读和可更新的快照
28.6创建快照的语法
28.6.1ROWID和基于主键的数据库
快照
28.6.2本地和远程对象的创建
28.7刷新数据库快照
28.7.1自动刷新
28.7.2手工刷新
28.7.3使用快照刷新组（Refresh
Groups）
28.8快照和触发器
28.9创建快照日志的语法
28.9.1必要的系统权限
28.9.2生成本地和远程对象
28.10 查看当前数据库快照的信息
28.11 改变快照和快照日志
28.12 删除快照和快照日志
第29章 使用上下文进行文本搜索
29.1在数据库中添加文本
29.2从数据库中查询文本
29.2.1上下文查询
29.2.2可用的上下文查询表达式
29.2.3单个词精确匹配搜索
29.2.4多个词的精确匹配搜索
29.2.5词组的精确匹配搜索
29.2.6相近词的搜索
29.2.7在搜索中使用通配符
29.2.8具有相同词根词的搜索
29.2.9模糊匹配搜索
29.2.10 读音相似词的搜索
29.2.11 组合搜索方法
29.3配置上下文选项
第30章 配置上下文选项
30.1为文本搜索设置数据库
30.1.1 init.ora文件的修改
30.1.2必要的角色
30.2为上下文查询设置表
30.2.1显示和修改选项
30.2.2建立文本索引
30.3优化文本索引
30.4两步查询
30.5使用语言服务
第31章 Oracle8中高级面向对象概念
31.1行对象与列对象
31.2对象表和OIDs
31.2.1向对象表中插入记录
31.2.2从对象表中查询数据
31.2.3 对象表中记录的修改和删除
31.2.4REF操作符
31.2.5使用DEREF操作符
31.2.6VALUE操作符
31.2.7无效的引用
31.3带有REF的对象视图
31.3.1对象视图的快速回顾
31.3.2涉及引用的对象视图
31.4 对象PL/SQL
31.5数据库中的对象
第三部分 Oracle8数据字典
第32章 Oracle8数据字典简要指南
32.1命名说明
32.2数据地图：DICTIONARY（DCT）和
DICT＿COLUMNS
32.3从何处选择：表（及列）视图
同义词，和序列
32.3.1目录：USER＿CATALOG
（CAT）
32.3.2对象：USER＿OBJECTS
（OBJ）
32.3.3表：USER＿TABLES（TABS）
32.3.4 列：USER＿TAB＿COLUMNS
（COLS）
32.3.5视图：USER＿VIEWS
32.3.6同义词：USERSYNONYMS
（SYN）
32.3.7序列：USER＿SEQUENCES
（SEQ）
32.4 限定和注释
姬.4.1限定：USER＿CONSTRAI－
NTS
32.4.2限定列：USER＿CONS＿CO－
LUMNS
32.4.3限定特例：EXCEPTIONS
32.4.4 表注释：USER＿TAB＿CO－
MMENTS
32.4.5列注释：USER＿COL＿CO－
MMENTS
32.5索引和簇
32.5.1索引：USER＿INDEXES
（IND）
32.5.2索引列：USER＿IND＿CO－
LUMNS
32.5.3簇：USER＿CLUSTERS
（CLU）
32.5.4 簇列：USER＿CLU＿CO
LUMNS
32.6 Oracle8－特定的对象
32.6.1抽象数据类型
32.6.2 LOBs
32.7数据库链接和快照
32.7.1数据库链接：USER＿DB＿LI－
NKS
32.7.2快照：USER＿SNAPSHOTS
32.7.3快照日志：USER＿SNAP－
SHOTLOGS
32.8触发器、过程、函数和包
32.8.1触发器：USER＿TRIGGERS
32.8.2过程、函数和包：
USERS0URCE
32.9空间分配与使用，包括分区
32.9.1表空间：USER＿TABLE－
SPACES
32.9.2 空间限额：USER＿TS＿QU
OTA S
32.9.3 段与区域：USER＿SEGMENTS和
USEREXTENTS
32.9.4 分区
32.9.5自由空间：USER＿FREE＿
SPACE
32.10 用户与权限
32.10.1用户：USER＿USERS
32.10.2资源限制：USER＿RESOUR－
CELIMITS
32.10.3表权限：USER＿TAB＿PR－
IVS
32.10.4 系统权限：USER＿SYS＿
PRIVS
32.11 角色
32.12审计
32.13监控：V＄动态性能表
32.14 其它
32.14.1CHAINED＿ROWS
32.14.2PLAN一TABLE
32.14.3相互信赖性：USER＿DEPEN
DENCIES和IDEPTREE
32.14.4 DBA（数据库管理员）专用
视图
32.14.5可信的Oracle数据库
32.14.6SQL*LOADER（载入器）直接载入
视图
32.14.7 本地语言支持（NLS）视图
32.14.8库
第四部分 讲究效率的设计方法
第33章 良好的设计具有好的技巧
33.1理解应用任务
33.2理解数据
33.2.1原子数据模型
33.2.2原子业务模型
33.3业务模型
33.4 数据项
33.5查询和报表
33.6 小结
第34章 性能与设计
34.1规范分解与数据完整性
34.1.1有意义的关键字
34.1.2实际的规范分解
34.1.3 行、列和容量
34.1.4 内存约束
34.1.5 厨房中的杂物抽屉
34.1.6 真的应该做这些吗？
34.2计算表
34.3 总结
第35章 良好设计的十条戒律
35.1面向对象的命名规范
35.1.1级别－命名完整性
35.1.2外关键字
35.1.3单数性
35.1.4 简洁性
35.1.5 对象名称字典
35.2 智能关键字和列值
35.3戒律
第36章 Oracle优化器简介
36.1哪个优化器？
36.2访问表操作
36.2.1全表访问
36.2.2 通过ROWID的表访问
36.2.3相关提示
36.3使用索引操作
36.3.1唯一索引扫描
36.3.2 索引范围扫描
36.3.3何时使用索引
36.3.4 多索引扫描的输出合并
36.3.5相关提示
36.3.6 对索引的附加调整问题
36.4控制数据集合的操作
36.4.1行排序
36.4.2行分组
36.4.3使用RowNum的操作
36.4.4 UNION MINUS和INTERSECT
函数
36.4.5选择行更新操作
36.4.6从视图中选取操作
36.4.7从子查询中选取数据操作
36.4.8相关的提示和参数
36.4.9另外的性能优化问题
36.5执行联合的操作
36.5.1Oracle如何处理两个表以
上的联合
36.5.2联合合并
36.5.3嵌套循环（NESTEDLOOPS）
36.5.4 HASH JOIN
36.5.5外部联合处理
36.5.6相关提示
36.5.7附加的性能优化问题
36.6显示执行路径
36.6.1使用setautotraceon命令
36.6.2使用命令explainplan
36.7其他操作
36.7.1过滤行（Filtering Rows）操作
36.7.2使用connect by子句的操作
36.7.3使用sequences的查询
36.7.4 使用数据库链接的查询
36.7.5使用簇的查询
36.7.6相关提示
36.7.7附加的性能调整问题
36.8总结
第五部分 参考手册
第37章 按字母顺序排列的参考
37.1本参考包括的内容
37.2本参考不包括的内容
37.3一般格式
37.3.1各条目的主要部分
37.3.2变量的标准用法
37.3.3其他有关格式的规定
37.3.4条目的其他成份
37.4列表顺序
第六部分 附 录
附录A 本书中用到的表
A.1使用本书中的表
A.2activity.sql启动文件
A.3math.sql启动文件
A.4 ADDRESS＿TY类型
A.5ANIMAL＿TY类型
A.6PERSON＿TY类型
A.7TOOLS＿VA类型
A.8ADDRESS表
A.9AREAS表
A.10 ASOF表
A.11 BIRTHDAY表
A.12BORROWER表
A.13BREEDER表
A.14 BREEDING表
A.15 CD表
A.16COMFORT 表
A.17COMMA表
A.18 CUSTOMER表
A.19EMPTY表
A.20 HOCKEY表
A.21 HOLIDAY表
A.22 INVOICE表
A.23 LEDGER表
A.24 LOCATION表
A.25 LODGING表
A.26LONGTIME表
A.27MAGAZINE表
A.28 MATH表
A.29 NAME表
A.30 NEWSPAPER表
A.31 NUMBERTEST表
A.32 PAY表
A.33 PAYDAY表
A.34 PROPOSAL表
A.35PROSPECT表
A.36RADIUS＿VALS表
A.37 ROSE 表
A.38 SHIPPING表
A.39 SKILL表
A.40 STOCK表
A.41TROUBLE表
A.42 TWONAME表
A.43 WEATHER表
A.44 WORKER表
A.45 WORKERSKILL表

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8完全参考手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle PL/SQL完全自学手册
第1章 初识Oracle11g
第2章 初识PUSQL
第3章 PL/SQL常用开发工具
第4章 数据表的基本操作
第5章 数据的增、删、改
第6章 数据的基本查询
第7章 数据的复杂查询
第8章 视图
第9章 触发器
第10章 游标
第11章 数据库事务
第12章 集合
第13章 过程、函数和包
第14章 安全管理
第15章 PL/SQL性能优化
第16章 常见故障排除
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle PL/SQL完全自学手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 9i JDBC 程序设计
3. 17 准备好的SQL语句

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 9i JDBC 程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle SQL疑难解析
《Oracle SQL疑难解析》
第一部分　数据处理基础
第1章　章基础　2
1.1　从表中查询数据　2
1.2　把表中所有字段都列出来　4
1.3　将结果排序　5
1.4　在表中添加记录行　6
1.5　把数据记录从一张表复制到另一张表　7
1.6　批量地从一个表中复制数据到另一个表　8
1.7　改变行记录的值　9
1.8　在一个语句中修改多个字段值　9
1.9　从表中删除不需要的行　10
1.10　删除表中的所有行　11
1.11　从其他查询结果中再次进行查询　12
1.12　查询的WHERE子句基于另一个查询的结果　13
1.13　在语句中找到和消除空值　14
1.14　排序　16
1.15　启用其他排序和比较选项　17
1.16　基于条件的插入或修改　18
第2章　汇总和聚合数据　20
2.1　对某字段值进行汇总　20
2.2　分组进行数据汇总　22
2.3　以多字段分组　23
2.4　在聚合数据集时排除某些组　25
2.5　分多级聚合数据　26
2.6　把聚合结果用在其他查询中　28
2.7　在分组和集合里统计成员　29
2.8　在表中查找重复值和唯一值　31
2.9　合计与小计　32
2.10　构建自己的聚合函数　34
2.11　从之前或之后的行中存取数据　37
2.12　对查询结果行进行排名　39
2.13　在分组内查找最大和最小值　42
2.14　在移动窗口中进行聚合　43
2.15　基于字段子集的数据记录去重　45
2.16　找出表中的序列空挡　48
第3章　多表数据查询　51
3.1　对多表的对应行进行连接　52
3.2　垂直堆叠查询结果　54
3.3　选择性连接　56
3.4　从两个方向进行可选连接　57
3.5　基于其他表中的数据删除记录　59
3.6　跨表寻找匹配的数据　60
3.7　在聚合上进行连接　61
3.8　查找不匹配的行　63
3.9　查找表中不匹配的行　65
3.10　生成测试数据　67
3.11　基于其他表中的数据更新记录　69
3.12　在连接条件里处理和比较NULL值　70
第4章　生成和获取数据　73
4.1　派生新的列　73
4.2　返回不存在的行　77
4.3　把行变换为列　78
4.4　在多列上透视　81
4.5　将列转换成行　83
4.6　出于易读性连接数据　86
4.7　把字符串转换成对应的数值　88
4.8　生成随机数　90
4.9　创建一个逗号分隔值文件　93
第5章　通用查询模式　95
5.1　把NULL转换成其他值　95
5.2　对NULL值排序　97
5.3　为查询结果标记页码　98
5.4　检测数据是否存在　102
5.5　SQL语句中的条件分支　104
5.6　根据条件和函数排序　105
5.7　当子查询返回多个值时的处理　107
5.8　将数字进行不同进制间的转换　108
5.9　在不知道列名或表名的情况下查找字符串　111
5.10　对数据系列进行后续值或趋势预测　113
5.11　修改记录时进行显式锁(悲观锁)　116
5.12　对两张表的内容进行同步　119
第二部分　数据类型和问题
第6章　日期和时间值的处理　124
6.1　将日期时间值转换成可读的字符串　124
6.2　将字符串转换为日期时间值　126
6.3　检测重叠的日期范围　127
6.4　自动跟踪数据更改的日期和时间　128
6.5　利用GAPS在数据中生成一个无间隔的时间序列　130
6.6　不同时区之间日期和时间的转换　132
6.7　检测闰年　133
6.8　确定一个月的最后一天的日期　135
6.9　确定一个月的第一天的日期或第一个星期几　136
6.10　判断星期几　137
6.11　通过时间段进行分组和聚合　138
6.12　查找两个日期或部分日期之间的差值　139
6.13　确定任何一年的复活节日期　141
6.14　为网站用户计算“X天活动”　143
第7章　字符串　145
7.1　搜索子字符串　145
7.2　提取子字符串　147
7.3　单字符的字符串替换　149
7.4　搜索模式　151
7.5　提取一个模式　154
7.6　计数模式　155
7.7　替换字符串中的文本　157
7.8　加快字符串搜索　159
第8章　处理数字　163
8.1　字符串和数字类型之间的转换　163
8.2　数字类型之间的转换　164
8.3　选择数据类型精度和刻度　166
8.4　正确执行非数字和无限数字计算　167
8.5　在字符串中验证数字　169
8.6　生成连续的编号　171
8.7　为公式或模式生成数字　172
8.8　处理数值计算中的 NULL　174
8.9　自动四舍五入数字　176
8.10　自动生成数字列表　178
第三部分　开发环境
第9章　事务管理　180
9.1　回滚部分事务　180
9.2　如何识别阻塞的事务　183
9.3　优化行级锁与表级锁　185
9.4　如何避免死锁　187
9.5　如何延期约束验证　188
9.6　确保事务的一致性读　193
9.7　管理事务的隔离级别　194
第10章　数据字典　196
10.1　图形工具与SQL　196
10.2　数据字典体系结构　197
10.3　显示用户信息　199
10.4　确定有权访问的表　201
10.5　显示一张表的磁盘空间使用情况　202
10.6　显示表的记录数　205
10.7　显示表的索引　207
10.8　显示未建索引的外键　208
10.9　显示约束　209
10.10　展示主键与外键的关系　210
10.11　显示对象间的依赖关系　212
10.12　显示同义词的元数据　214
10.13　显示视图的文本　215
10.14　显示数据库代码　216
10.15　显示授予的角色　217
10.16　显示对象权限　219
10.17　显示系统权限　220
第四部分　特殊话题
第11章　常见报表问题　224
11.1　避免报表中的重复数据　224
11.2　在SQL报表里使用参数　227
11.3　在分组的结果中返回具体列的数据　229
11.4　将排序结果放入相等大小的BUCKET中　231
11.5　创建报表直方图　233
11.6　根据不同的排名进行结果筛选　234
11.7　对假设数据集进行比较　236
11.8　用图形和文字来展示数据的分布　238
11.9　从数据库中直接生成网页报表　239
第12章　清理数据　244
12.1　检测重复数据行　244
12.2　删除重复行　245
12.3　判断数据是否可以加载到数值类型字段中　246
12.4　判断数据是否可以加载到日期类型字段中　247
12.5　执行不区分大小写的查询　248
12.6　对值进行模糊处理　250
12.7　删除所有索引　252
12.8　禁用约束　253
12.9　禁用触发器　257
12.10　从表中删除数据　258
12.11　查找两个SCHEMA的不同之处　259
第13章　树状结构数据　263
13.1　从上到下遍历层级数据　265
13.2　在层次结构同层级中对节点排序　267
13.3　从层次结构表中生成路径名　270
13.4　在层次结构表中辨认叶子数据　272
13.5　检查层次结构数据中的循环　276
13.6　创建固定数量的连续序号的主键值　277
第14章　处理XML数据　280
14.1　将SQL转换成XML　280
14.2　以原生形式存储XML　284
14.3　分解XML供关系型逻辑使用　286
14.4　从XML文档中抽取关键元素　287
14.5　生成复杂的XML文档　289
14.6　验证XML SCHEMA　290
14.7　直接修改XML数据　293
第15章　分区　295
15.1　确定一个表是否应该分区　296
15.2　范围分区　297
15.3　列表分区　299
15.4　哈希分区　299
15.5　复合分区　300
15.6　按需创建分区　302
15.7　引用分区　303
15.8　基于虚拟列的分区　304
15.9　系统分区　305
15.10　配置分区的表空间　306
15.11　自动移动更新的记录　307
15.12　系统分区　308
15.13　对分区增加分区　309
15.14　交换分区　310
15.15　重命名分区　312
15.16　拆分分区　313
15.17　合并分区　314
15.18　删除分区　315
15.19　从一个分区中删除记录　316
15.20　收集分区统计信息　317
15.21　创建本地索引　317
15.22　创建全局索引　319
第16章　大对象　321
16.1　将大文档加载至CLOB字段　322
16.2　将图像数据加载至BLOB字段　324
16.3　使用SQL*Loader进行大对象的批量加载　326
16.4　利用HTTP访问大对象　328
16.5　使得外部大对象(BFILE)对数据库有效　332
16.6　在数据库表中更新或删除LOB　334
第五部分　管理
第17章　数据库管理　338
17.1　创建数据库　339
17.2　删除数据库　341
17.3　验证连接信息　342
17.4　创建表空间　343
17.5　删除表空间　345
17.6　调整表空间大小　346
17.7　限制每个会话的数据库资源　347
17.8　关联一组权限　349
17.9　创建用户　351
17.10　删除用户　352
17.11　修改密码　353
17.12　强制密码复杂性　354
第18章　对象管理　356
18.1　创建表　356
18.2　临时存储数据　358
18.3　移动表　359
18.4　重命名对象　360
18.5　删除表　362
18.6　恢复被删除的表　363
18.7　创建索引　364
18.8　创建一个基于函数的索引　366
18.9　创建位图索引　367
18.10　创建一个索引组织表　368
18.11　创建视图　369
18.12　为对象创建替代名称　370
18.13　强制表中的行的唯一性　372
18.14　确保查找值存在　374
18.15　根据条件检查数据　376
18.16　在数据库之间创建连接　377
18.17　创建自动递增的值　379
第19章　SQL监控和优化　381
19.1　实时监控SQL执行统计信息　381
19.2　显示查询的执行计划进展　383
19.3　确定还需要多长时间来完成SQL　385
19.4　识别资源密集型SQL语句　387
19.5　使用Oracle性能报告来确定资源消耗密集型SQL　388
19.6　在操作系统中识别资源密集型查询　391
19.7　使用AUTOTRACE显示执行计划　393
19.8　使用DBMS_XPLAN生成执行计划　395
19.9　跟踪会话的所有SQL语句　397
19.10　解释执行计划　402
19.11　获取调优SQL的建议　406
19.12　强制查询使用自己的执行计划　408
19.13　查看优化器统计信息　409
19.14　生成统计信息　411
第20章　数据库故障排除　413
20.1　确定数据库问题的原因　413
20.2　显示打开的游标　417
20.3　确定联机重做日志的大小是否合适　418
20.4　确定撤销表空间的大小是否合适　420
20.5　确定临时表空间的大小是否合适　422
20.6　完整显示表空间　423
20.7　显示对象大小　426
20.8　监控索引的使用　427
20.9　审计对象的使用　428
20.10　精细审计　430
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle SQL疑难解析
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Developer/2000R2.0开发与应用实例
第一部分  Oracle数据库简介
1，Oracle数据库系统结构与产品组成
2，Developer/2000 R2.0产品安装与应用管理
第二部分  Oracle Forms5.0设计实例
3，Oracle Forms5.0基础
4，Form应用设计
5，触发器设计
6，Form高级技巧（1）
7，Form高级技巧（2）
第三部分  Oracle Reports3.0设计实例
8，创建一个简单的报表
9，创建分组报表
10，布局设计
11，创建主从型报表
12，创建矩阵报表
第四部分  Oracle Graphics3.0设计实例
13，Graphics Builder入门
14，创建Drill-Down型图表
15，在不同显示层创建图表
第五部分  Developer/2000 R2.0开发工具集成
17，开发工具集成与动态参数传递

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Developer/2000R2.0开发与应用实例
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8体系结构
目 录
贺辞
序
译者序
前言
引言
第一部分 Oracle介绍
第1章 Oracle8简介
1.1信息管理
1.1.1数据库
1.1.2数据库管理系统
1.1.3创建于Oracle7基础上的Oracle8
1.2Oracle8与高端数据库环境
1.2.1分区表与索引
1.2.2海量用户的管理
1.2.3高级队列
1.2.4并行处理能力的增强
1.3Oracle8与Oracle的网络计算结构（NCA）
1.3.1Oracle8――对象关系型数据库管理系统
1.3.2Sedona――Oracle新的应用开发环境
1.4Oracle8数据库管理与安全性
1.4.1备份与恢复
1.4.2口令管理
1.5Oracle8与分布式数据库
1.5.1复制性能的增强
1.5.2分布式安全域
1.5.3异类数据存取
1.6展望
第二部分 Oracle8基础
第2章 基本的关系型数据库结构
2.1模式――有组织的数据库对象
2.1.1模式――一个完全的逻辑学概念
2.1.2模式与数据库用户帐号的相互关系
2.1.3数据字典――一个唯一的模式
2.2数据库表
2.2.1列与数据类型
2.2.2数据完整性与完整性限制
2.3视图――查看表中数据的另一种不同方法
2.3.1只读视图
2.3.2可更新视图
2.3.3其他类型的视图
2.4索引――改进表存取的性能
2.4.1B树索引
2.4.2位图索引
2.4.3索引表
2.4.4其他索引选项
2.5数据簇――存储表数据的独特方法
2.5.1索引数据簇
2.5.2哈希簇
2.6序列――有效地生成唯一值
2.7同义词――同一对象的不同名字
2.8模式应用示例
第3章 使用SQL与事务
3.1SQL――与Oracle8交互
3.1.1查询
3.1.2DML语句
3.1.3DDL语句
3.1.4DCL语句
3.1.5应用的可移植性与ANSI/ISOSQL标准
3.2优化――可执行的SQL语句
3.2.1优化统计
3.2.2优化选项
3.2.3提示与优化控制
3.3事务――完成工作
3.3.1所有工作或什么也不做
3.3.2事务类型
3.3.3设计事务
第4章 对服务器编程
4.1PL/SQL――增加SQL过程流能力
4.1.1程序块
4.1.2程序注释
4.1.3程序声明
4.1.4程序功能
4.1.5程序例外处理
4.2PL/SQL程序类型
4.2.1匿名PL/SQL块
4.2.2存储过程和函数
4.2.3包
4.2.4数据库触发器
4.3外部过程
4.4小结
第5章 使用对象扩展Oracle
5.1面向对象
5.1.1Oracle8和面向对象数据库
5.1.2面向对象数据库术语及概念
5.2怎样使用对象
5.3使用对象类型
5.3.1设计对象类型
5.3.2创建对象类型
5.3.3创建与使用对象类型示例
5.3.4方法详解
5.4对象与视图
5.4.1对象型表的对象视图
5.4.2关系型表的视图
5.4.3视图与INSTEAD OF触发器
5.5小结
第三部分 Oracle8数据库结构
第6章 控制数据库访问
6.1用户管理
6.1.1用户验证
6.1.2用户的缺省表空间
6.1.3用户的临时空间表
6.1.4用户账号的锁定与解锁
6.2权限管理
6.2.1数据库权限类型
6.2.2授权与收回特权
6.2.3使用角色管理权限
6.3资源限制
6.3.1表空间限额
6.3.2资源限制环境文件
6.4数据库审计
6.4.1有选择地审计
6.4.2审计记录与审计追踪
6.4.3设置审计选项
6.5什么是可信任Oracle
6.6小结
第7章 数据库存储
7.1表空间
7.1.1SYSTEM表空间
7.1.2其他表空间
7.1.3联机表空间和脱机表空间
7.1.4永久表空间和临时表空间
7.1.5只读表空间和可读写表空间
7.2 数据文件详细介绍
7.2.1一个表空间的数据文件数量
7.2.2数据文件的空间使用
7.2.3数据文件大小
7.2.4数据文件损坏
7.2.5联机数据文件和脱机数据文件
7.3控制文件
7.4段、区间和数据块
7.5数据段和索引段
7.5.1临时段
7.5.2临时表空间
7.6回滚段
7.6.1Oracle怎样写回滚段
7.6.2SYSTEM回滚段
7.6.3多个回滚段
7.6.4联机回滚段和脱机回滚段
7.6.5公共回滚段和私有回滚段
7.6.6延期回滚段
7.6.7回滚段的其他功能
7.7数据块
7.7.1数据块分配
7.7.2数据块可用性和空闲列表
7.7.3行链接与数据块大小
7.8对象存储设置
7.8.1表空间配置
7.8.2区间设置
7.8.3数据块设置
7.8.4对象存储的缺省设置
7.9多媒体数据的特有数据存储
7.10数据分区
7.10.1分区表
7.10.2在数据分区中放置记录
7.10.3使用最大值（MAXVALUE）
7.10.4分区索引
7.10.5分区索引选项
7.10.6分区扩展表名
7.10.7分区管理
7.11小结
第四部分 Oracle8软件体系结构
第8章 Oracle软件结构
8.1数据库服务器与数据库实例
8.1.1服务器启动与关闭
8.1.2服务器连接
8.2Oracle8进程
8.2.1服务器端后台进程
8.2.2支持用户连接的进程选项
8.2.3Oracle特定的进程结构
8.3内存区与数据缓存区
8.4Oracle8内存区
8.4.1高速缓存区
8.4.2共享池
8.4.3系统全局区（SGA）
8.4.4程序全局区（PGA）
8.4.5排序区
8.5Oracle8网络与Net8
8.5.1透明的网络底层（TNS）与其他Net8层
8.5.2TNS连接、初始化与目的地
8.5.3TNS监听器
8.5.4TNS地址
8.5.5多网络与多协议交换
8.5.6Net8配置
8.6小结
第9章 共享数据库访问机制
9.1三个C――竞争性、并发性与一致性
9.1.1Oracle的并发性与一致性机制
9.1.2事务与冲突
9.1.3隔离的级别
9.2Oracle的锁机制
9.2.1自动锁与显式锁
9.2.2锁级别
9.2.3DML锁
9.2.4DDL锁
9.2.5内部闩锁
9.3多版本
9.3.1系统修改序列号
9.3.2非块查询
9.3.3多版本与事务级读一致性
9.3.4快照太老的错误
9.4记住，一切都是自动的
9.5小结
第10章 数据库保护
10.1不同类型的问题
10.1.1系统崩溃或服务器崩溃
10.1.2由于用户错误、冲突或者磁盘失效导致的文件丢失
10.1.3场地灾难
10.2数据库保护机制一览
10.3恢复管理器介绍
10.4事务日志或重做日志
10.4.1事务日志结构
10.4.2检查点
10.5保护数据库控制文件
10.6数据库备份
10.6.1完全数据库备份
10.6.2表空间备份
10.6.3恢复管理器备份概念
10.6.4逻辑数据库备份
10.7数据库恢复
10.7.1前滚和回滚恢复阶段
10.7.2崩溃恢复
10.7.3介质恢复――从文件损坏中恢复
10.7.4完全恢复
10.7.5不完全恢复
10.8恢复优化
10.9日志组和控制文件受到破坏该怎么办
10.10高可用性选项
10.10.1备用数据库
10.10.2超越故障节点与数据复制
10.11小结
第五部分 特定Oracle环境
第11章 分布式数据与数据复制
11.1分布式数据库结构
11.1.1合作与自动
11.1.2客户/服务器的扩展
11.1.3网络和分布式数据库系统
11.1.4分布式数据库中的数据库服务与命名
11.1.5数据库链接
11.1.6异构型分布式数据库
11.2应用程序与分布式数据库
11.2.1远程查询
11.2.2分布式查询
11.2.3远程更新
11.2.4分布式更新
11.2.5远程过程调用（RPC）
11.2.6远程事务
11.2.7分布式事务
11.3分布式数据库透明性
11.4独特的分布式数据库安全问题
11.5数据复制简介
11.5.1数据复制的用途
11.5.2数据复制的类型
11.6基本复制与只读快照
11.6.1复杂快照
11.6.2快照数据存储
11.6.3快照刷新
11.7高级复制环境
11.7.1多主机复制
11.7.2快照节点与可更新快照
11.7.3高级复制选项比较
11.8高级复制系统体系结构
11.8.1复制对象与复制组
11.8.2主节点与快照节点
11.8.3复制目录
11.8.4Oracle的复制管理API
11.9Oracle的高级复制软件机制
11.9.1行级复制
11.9.2异步（存储然后传播）数据传播
11.9.3一个示例
11.10高级复制系统中的复制冲突
11.10.1复制冲突的类型
11.10.2避免冲突
11.10.3冲突检测与解决
11.11其他的高级复制选项
11.11.1过程化复制
11.11.2同步（实时）数据传播
11.12 小结
第12章 Oracle的并行处理选项
12.1并行处理介绍
12.1.1单处理器计算机与多处理器计算机
12.1.2共享内存系统
12.1.3共享磁盘系统
12.1.4非共享系统
12.2并行处理SQL
12.2.1串行处理
12.2.2并行SQL处理
12.2.3并行SQL处理体系结构
12.2.4数据分区与并行SQL处理
12.3Oracle的并行服务器选项――高可用性的多个实例
12.3.1什么是并行数据库访问
12.3.2并行服务器体系结构
12.3.3并行服务器数据库管理
12.3.4自动实例恢复
12.3.5透明的超越故障应用
12.3.6从介质失效中恢复数据库
12.4并行服务器配置的独特的数据库特性
12.4.1序列生成器
12.4.2数据块空闲列表
12.4.3特定实例区间分配
12.4.4私有回滚段
12.4.5反向键值索引
12.5并行SQL处理与并行服务器处理混合
12.6小结

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8体系结构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库管理员技术指南
贺辞序译者序前言第1章

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库管理员技术指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Developer/2000 R2.0开发技巧与应用实例
第1部分  Oracle数据库简介
第1章  Oracle数据库系统结构与产品组成
1. 1  Oracle数据库概述
1. 1. 1  Oracle数据库特点
1. 1. 2  Oracle数据库发展过程

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Developer/2000 R2.0开发技巧与应用实例
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle STATSPACK 高性能调整技术
第一部分 方法和工具概述第1章

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle STATSPACK 高性能调整技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 10g宝典
第1部分  数据库基础  第1章  数据库基础知识  第2章  安装Oracle 10g  第3章  OEM数据库控制工具  第4章  SQL*Plus工具  第5章  SQL语言  第6章  PL/SQL语言第2部分  体系结构与存储管理  第7章  体系结构  第8章  管理控制文件  第9章  管理表空间  第10章  管理数据文件  第11章  管理重做日志文件第3部分  数据库管理  第12章  创建和删除数据库  第13章  启动和关闭数据库  第14章  管理网络第4部分  方案对象管理  第15章  管理表  第16章  管理索引  第17章  管理视图  第18章  管理序列第5部分  安全管理  第19章  数据库安全综述  第20章  管理权限  第21章  管理角色  第22章  管理概要文件  第23章  管理用户  第24章  备份与恢复第6部分  应用开发  第25章  利用PowerBuilder开发Oracle数据库应用系统
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 10g宝典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 12c DBA官方手册
目 录
第Ⅰ部分 数据库体系结构
第1章 Oracle体系结构概述 3
1.1 数据库和实例概述 4
1.1.1 数据库 4
1.1.2 实例 5
1.2 Oracle逻辑存储结构 5
1.2.1 表空间 6
1.2.2 块 7
1.2.3 盘区 7
1.2.4 段 7
1.3 Oracle逻辑数据库结构 8
1.3.1 表 8
1.3.2 约束 14
1.3.3 索引 16
1.3.4 视图 18
1.3.5 用户和模式 20
1.3.6 配置文件 20
1.3.7 序列 20
1.3.8 同义词 21
1.3.9 PL/SQL 21
1.3.10 外部文件访问 22
1.3.11 数据库链接和远程数据库 22
1.4 Oracle物理存储结构 23
1.4.1 数据文件 24
1.4.2 重做日志文件 24
1.4.3 控制文件 24
1.4.4 归档的日志文件 25
1.4.5 初始参数文件 25
1.4.6 警报和跟踪日志文件 26
1.4.7 备份文件 26
1.4.8 Oracle管理文件 27
1.4.9 密码文件 27
1.5 多元复用数据库文件 27
1.5.1 自动存储管理 28
1.5.2 手动的多元复用 28
1.6 Oracle内存结构 30
1.6.1 系统全局区域 30
1.6.2 程序全局区域 32
1.6.3 软件代码区域 33
1.6.4 后台进程 33
1.7 备份/恢复概述 35
1.7.1 导出/导入 35
1.7.2 脱机备份 36
1.7.3 联机备份 36
1.7.4 RMAN 36
1.8 安全功能 36
1.8.1 权限和角色 37
1.8.2 审核 37
1.8.3 细粒度的审核 38
1.8.4 虚拟私有数据库 38
1.8.5 标号安全性 38
1.9 实时应用群集 38
1.10 Oracle流 39
1.11 Oracle企业管理器 39
1.12 Oracle初始参数 40
1.12.1 基本初始参数 40
1.12.2 高级初始参数 44
1.13 本章小结 45
第2章 升级到Oracle Database 12c 47
2.1 选择升级方法 48
2.2 升级前的准备工作 50
2.3 使用DBUA 50
2.4 执行手动直接升级 51
2.5 使用Data Pump Export和Import 53
2.5.1 使用的Export和Import版本 53
2.5.2 执行升级 53
2.6 使用数据复制方法 54
2.7 升级后的工作 54
2.8 本章小结 55
第3章 计划和管理表空间 57
3.1 表空间的体系结构 58
3.1.1 表空间类型 58
3.1.2 OFA 64
3.2 Oracle安装表空间 68
3.2.1 SYSTEM 68
3.2.2 SYSAUX 68
3.2.3 TEMP 68
3.2.4 UNDOTBS1 69
3.2.5 USERS 69
3.2.6 EXAMPLE 69
3.3 段分离 69
3.4 本章小结 70
第4章 物理数据库布局和存储管理 71
4.1 传统磁盘空间存储 72
4.1.1 重设表空间和数据文件的大小 72
4.1.2 移动数据文件 78
4.1.3 移动联机重做日志文件 81
4.1.4 移动控制文件 83
4.2 自动存储管理 85
4.2.1 ASM体系结构 85
4.2.2 创建ASM实例 86
4.2.3 ASM实例组件 88
4.2.4 ASM动态性能视图 90
4.2.5 ASM文件名格式 91
4.2.6 ASM文件类型和模板 93
4.2.7 管理ASM磁盘组 94
4.3 本章小结 103
第Ⅱ部分 数据库管理
第5章 开发和实现应用程序 107
5.1 调整设计：最佳实践 108
5.1.1 做尽可能少的工作 108
5.1.2 做尽可能简单的工作 111
5.1.3 告诉数据库需要知道的内容 112
5.1.4 最大化环境中的吞吐量 113
5.1.5 分开处理数据 113
5.1.6 正确测试 114
5.1.7 标准的可交付成果 116
5.2 资源管理 118
5.2.1 实现数据库资源管理器 118
5.2.2 调整数据库对象的大小 123
5.2.3 使用全局临时表 129
5.3 支持基于抽象数据类型的表 130
5.3.1 使用对象视图 130
5.3.2 抽象数据类型的安全性 133
5.3.3 对抽象数据类型属性创建索引 135
5.4 停顿并挂起数据库 136
5.5 支持迭代开发 137
5.5.1 迭代式列定义 137
5.5.2 强制光标共享 138
5.6 管理程序包开发 139
5.6.1 生成图表 139
5.6.2 空间需求 139
5.6.3 调整目标 139
5.6.4 安全性需求 139
5.6.5 数据需求 140
5.6.6 版本需求 140
5.6.7 执行计划 140
5.6.8 验收测试过程 140
5.6.9 测试环境 140
5.7 本章小结 141
第6章 监控空间利用率 143
6.1 常见的空间管理问题 144
6.1.1 用尽表空间中的空闲空间 144
6.1.2 用于临时段的空间不足 145
6.1.3 所分配的撤消空间过多或过少 145
6.1.4 分片的表空间和段 145
6.2 Oracle段、盘区和块 146
6.2.1 数据块 147
6.2.2 盘区 148
6.2.3 段 149
6.3 数据字典视图和动态性能视图 150
6.3.1 DBA_TABLESPACES 150
6.3.2 DBA_SEGMENTS 150
6.3.3 DBA_EXTENTS 151
6.3.4 DBA_FREE_SPACE 151
6.3.5 DBA_LMT_FREE_SPACE 152
6.3.6 DBA_THRESHOLDS 152
6.3.7 DBA_OUTSTANDING_ALERTS 152
6.3.8 DBA_OBJECT_USAGE 152
6.3.9 DBA_ALERT_HISTORY 153
6.3.10 V$ALERT_TYPES 153
6.3.11 V$UNDOSTAT 153
6.3.12 V$SORT_SEGMENT 154
6.3.13 V$TEMPSEG_USAGE 154
6.4 空间管理方法学 154
6.4.1 本地管理的表空间 154
6.4.2 使用OMF管理空间 155
6.4.3 大文件表空间 157
6.4.4 自动存储管理 158
6.4.5 撤消管理的考虑事项 160
6.5 SYSAUX监控和使用 161
6.6 归档重做日志文件的管理 162
6.7 内置的空间管理工具 163
6.7.1 段顾问 163
6.7.2 撤消顾问和自动工作负荷存储库 166
6.7.3 索引利用率 167
6.7.4 空间利用率警告级别 169
6.7.5 可恢复的空间分配 171
6.7.6 用ADR管理警报日志和跟踪文件 174
6.7.7 OS空间管理 176
6.8 空间管理脚本 176
6.8.1 无法分配额外盘区的段 176
6.8.2 表空间和数据文件已使用的空间和空闲空间 176
6.9 自动化和精简通知过程 178
6.9.1 使用DBMS_SCHEDULER 178
6.9.2 Cloud Control和监控 178
6.10 本章小结 185
第7章 使用撤消表空间管理事务 187
7.1 事务基础 188
7.2 撤消基础 188
7.2.1 回滚 189
7.2.2 读一致性 189
7.2.3 数据库恢复 189
7.2.4 闪回操作 189
7.3 管理撤消表空间 190
7.3.1 创建撤消表空间 190
7.3.2 撤消表空间的动态性能视图 195
7.3.3 撤消表空间的初始参数 195
7.3.4 多个撤消表空间 197
7.3.5 撤消表空间的大小调整和监控 199
7.3.6 读一致性与成功的DML 202
7.4 闪回特性 202
7.4.1 Flashback Query(闪回查询) 203
7.4.2 DBMS_FLASHBACK 204
7.4.3 Flashback Transaction Backout(闪回事务停止) 206
7.4.4 Flashback Table(闪回表) 207
7.4.5 Flashback Version Query(闪回版本查询) 208
7.4.6 Flashback Transaction Query(闪回事务查询) 211
7.4.7 Flash Data Archive(闪回数据归档) 212
7.4.8 闪回与LOB 216
7.5 迁移到自动撤消管理 216
7.6 本章小结 216
第8章 数据库调整 219
8.1 调整应用程序设计 220
8.1.1 有效的表设计 220
8.1.2 CPU需求的分布 221
8.1.3 有效的应用程序设计 223
8.2 调整SQL 224
8.2.1 顺序对加载速率的影响 225
8.2.2 其他索引选项 225
8.2.3 生成解释计划 227
8.3 调整内存使用率 229
8.3.1 管理SGA池 229
8.3.2 指定SGA的大小 231
8.3.3 使用基于成本的优化器 232
8.4 调整数据访问 233
8.4.1 标识链行 233
8.4.2 使用索引组织表 234
8.4.3 索引组织表的调整问题 235
8.5 调整数据操作 236
8.5.1 批量插入：使用SQL*Loader Direct Path选项 236
8.5.2 批量数据移动：使用外部表 237
8.5.3 批量插入：常见的陷阱和成功技巧 238
8.5.4 批量删除：TRUNCATE命令 239
8.5.5 使用分区 240
8.6 减少网络流量 240
8.6.1 使用物化视图复制数据 240
8.6.2 使用远程过程调用 242
8.7 使用AWR 243
8.7.1 管理快照 243
8.7.2 管理基线 244
8.7.3 生成AWR报告 244
8.7.4 运行Automatic Database Diagnostic Monitor报告 245
8.7.5 使用自动SQL调整顾问 246
8.8 多租户环境中的性能调整 247
8.8.1 调整方法 248
8.8.2 调整CDB 248
8.8.3 使用内存顾问 250
8.8.4 使用AWR报告 251
8.8.5 使用SQL调整顾问 251
8.9 管理PDB中的资源分配 252
8.9.1 使用份额来管理PDB之间的资源分配 252
8.9.2 创建和修改Resource Manager计划 253
8.10 执行数据库重放 257
8.10.1 分析源数据库工作负荷 257
8.10.2 捕获源数据库工作负荷 258
8.10.3 在目标系统上处理工作负荷 258
8.10.4 在目标CDB上重放工作负荷 258
8.10.5 验证重放结果 258
8.11 本章小结 258
第9章 In-Memory选项 261
9.1 Oracle In-Memory选项概述 261
9.1.1 系统需求和设置 262
9.1.2 In-Memory案例研究 262
9.2 数据字典视图 266
9.2.1 V$IM_SEGMENTS 266
9.2.2 V$INMEMORY_AREA 267
9.2.3 V$SGA 267
9.3 本章小结 267
第10章 数据库安全性和审核 269
10.1 非数据库的安全性 270
10.2 数据库身份验证方法 271
10.2.1 数据库身份验证 271
10.2.2 数据库管理员身份验证 271
10.2.3 操作系统身份验证 274
10.2.4 网络身份验证 275
10.2.5 三层身份验证 277
10.2.6 客户端身份验证 277
10.2.7 用户账户 278
10.3 数据库授权方法 283
10.3.1 配置文件的管理 283
10.3.2 系统权限 290
10.3.3 对象权限 292
10.3.4 创建、分配和维护角色 296
10.3.5 使用VPD实现应用程序安全策略 302
10.4 审核 319
10.4.1 审核位置 319
10.4.2 语句审核 320
10.4.3 权限审核 324
10.4.4 模式对象审核 325
10.4.5 细粒度的审核 326
10.4.6 与审核相关的数据字典视图 327
10.4.7 保护审核跟踪 328
10.5 数据加密技术 328
10.5.1 DBMS_CRYPTO程序包 329
10.5.2 透明数据加密 329
10.6 本章小结 330
第11章 多租户数据库体系结构 331
11.1 理解多租户体系结构 332
11.1.1 利用多租户数据库 333
11.1.2 理解多租户配置 333
11.2 在多租户环境中预配 335
11.2.1 理解可插入数据库预配 335
11.2.2 配置和创建CDB 338
11.2.3 理解新增的后续数据字典视图 342
11.2.4 创建PDB 344
11.2.5 拔下和删除PDB 349
11.3 管理CDB和PDB 352
11.3.1 理解CDB和PDB服务名 352
11.3.2 使用SQL Developer连接到CDB或PDB 353
11.3.3 为CDB或PDB创建服务 354
11.3.4 在CDB中切换连接 355
11.3.5 启动和关闭CDB及PDB 355
11.3.6 更改CDB中的参数 362
11.3.7 管理CDB和PDB中的永久和临时表空间 363
11.4 多租户安全 366
11.4.1 管理公共和本地用户 366
11.4.2 管理公共和本地权限 368
11.4.3 管理公共和本地角色 369
11.4.4 使公共用户访问特定PDB中的数据 370
11.5 多租户环境中的备份和恢复 372
11.5.1 执行CDB和所有PDB的备份 372
11.5.2 备份CDB 375
11.5.3 备份PDB 377
11.5.4 恢复丢失的PDB数据文件 379
11.5.5 使用DRA 387
11.5.6 确定受损的块 392
11.5.7 使用RMAN复制PDB 393
11.6 本章小结 393
第Ⅲ部分 高 可 用 性
第12章 实时应用群集 397
12.1 实时应用群集概述 398
12.1.1 硬件配置 398
12.1.2 软件配置 399
12.1.3 网络配置 399
12.1.4 磁盘存储 400
12.2 RAC特征 400
12.2.1 服务器参数文件特征 400
12.2.2 与RAC相关的初始化参数 401
12.2.3 动态性能视图 401
12.3 RAC维护 403
12.3.1 启动RAC 403
12.3.2 RAC环境中的重做日志 404
12.3.3 RAC环境中的撤消表空间 404
12.3.4 故障转移情况和TAF 404
12.3.5 调整RAC节点 406
12.4 本章小结 406
第13章 备份和恢复选项 409
13.1 备份功能 409
13.2 逻辑备份 410
13.3 物理备份 411
13.3.1 脱机备份 411
13.3.2 联机备份 411
13.4 使用Data Pump Export和Data Pump Import 413
13.4.1 创建目录 413
13.4.2 Data Pump Export选项 414
13.4.3 启动Data Pump Export作业 417
13.4.4 Data Pump Import选项 421
13.5 实现脱机备份 428
13.6 实现联机备份 428
13.6.1 开始(操作) 429
13.6.2 执行联机数据库备份 430
13.7 集成备份过程 431
13.7.1 集成逻辑备份和物理备份 431
13.7.2 集成数据库备份和操作系统备份 432
13.8 本章小结 433
第14章 使用恢复管理器(RMAN) 435
14.1 RMAN的特性和组件 436
14.1.1 RMAN组件 436
14.1.2 RMAN与传统备份方法 437
14.1.3 备份类型 439
14.2 RMAN命令和选项的概述 440
14.2.1 在RMAN中运行SQL命令 440
14.2.2 常用命令 441
14.2.3 设置存储库 442
14.2.4 注册数据库 444
14.2.5 持久保存RMAN设置 445
14.2.6 初始化参数 449
14.2.7 数据字典和动态性能视图 449
14.3 备份操作 451
14.3.1 完整数据库备份 451
14.3.2 备份表空间 456
14.3.3 备份数据文件 457
14.3.4 映像副本备份 457
14.3.5 备份控制文件和SPFILE 459
14.3.6 备份归档重做日志 459
14.3.7 增量备份 460
14.3.8 增量更新的备份 462
14.3.9 增量备份块变化跟踪 464
14.3.10 使用快速恢复区 465
14.3.11 验证备份 465
14.4 恢复操作 468
14.4.1 块介质恢复 468
14.4.2 还原控制文件 469
14.4.3 还原表空间 469
14.4.4 还原表 471
14.4.5 还原数据文件 472
14.4.6 还原整个数据库 472
14.4.7 验证还原操作 474
14.4.8 时间点恢复 476
14.4.9 数据恢复顾问 476
14.5 其他操作 479
14.5.1 编目其他备份 479
14.5.2 目录维护 480
14.5.3 REPORT和LIST 481
14.6 本章小结 483
第15章 Oracle Data Guard 485
15.1 Data Guard体系结构 485
15.1.1 物理备用数据库与逻辑备用数据库 486
15.1.2 数据保护模式 487
15.2 LOG_ARCHIVE_DEST_n参数属性 489
15.3 创建备用数据库配置 489
15.3.1 准备主数据库 490
15.3.2 创建逻辑备用数据库 494
15.4 使用实时应用 496
15.5 管理归档日志序列中的间隙 497
15.6 管理角色—— 切换和故障转移 497
15.6.1 切换 497
15.6.2 故障转移 500
15.7 管理数据库 501
15.7.1 启动和关闭物理备用数据库 501
15.7.2 以只读模式打开物理备用数据库 502
15.7.3 在Data Guard环境中管理数据文件 502
15.7.4 在逻辑备用数据库上执行DDL 502
15.8 本章小结 503
第16章 其他高可用性特性 505
16.1 使用闪回删除来恢复被删除的表 506
16.2 FLASHBACK DATABASE命令 507
16.3 使用LogMiner 510
16.3.1 LogMiner的工作方式 510
16.3.2 提取数据字典 510
16.3.3 分析一个或多个重做日志文件 511
16.4 联机对象重组织 514
16.4.1 联机创建索引 514
16.4.2 联机重建索引 515
16.4.3 联机合并索引 515
16.4.4 联机重建以索引组织的表 515
16.4.5 联机重新定义表 515
16.4.6 联机移动数据文件 517
16.5 本章小结 517
第Ⅳ部分 网络化的Oracle
第17章 Oracle Net 521
17.1 Oracle Net概述 522
17.1.1 连接描述符 525
17.1.2 网络服务名 525
17.1.3 用Oracle Internet Directory替换tnsnames.ora 526
17.1.4 侦听程序 526
17.2 使用Oracle Net Configuration Assistant 530
17.2.1 配置侦听程序 531
17.2.2 Naming Methods Configuration 532
17.2.3 Local Net Service Name Configuration 532
17.2.4 Directory Usage Configuration 533
17.3 使用Oracle Net Manager 534
17.4 启动侦听程序服务器进程 535
17.5 对侦听程序服务器进程进行控制 537
17.6 Oracle Connection Manager 539
17.6.1 使用Oracle Connection Manager 540
17.6.2 配置Oracle Connection Manager 540
17.6.3 使用连接管理器控制实用程序(CMCTL) 542
17.7 使用Oracle Internet Directory 的目录命名 543
17.7.1 Oracle Internet Directory体系结构 543
17.7.2 设置Oracle Internet Directory 544
17.8 使用Easy Connect Naming 545
17.9 使用数据库链接 546
17.10 调整Oracle Net 547
17.10.1 限制资源的使用 548
17.10.2 使用压缩 548
17.10.3 调试连接问题 549
17.11 本章小结 550
第18章 管理大型数据库 551
18.1 在VLDB环境中创建表空间 552
18.1.1 大文件表空间的基本知识 553
18.1.2 创建和修改大文件表空间 553
18.1.3 大文件表空间ROWID格式 554
18.1.4 DBMS_ROWID和大文件表空间 555
18.1.5 将DBVERIFY用于大文件表空间 557
18.1.6 大文件表空间的初始化参数需要考虑的因素 559
18.1.7 大文件表空间数据字典的变化 559
18.2 高级的Oracle表类型 560
18.2.1 索引组织的表 560
18.2.2 全局临时表 561
18.2.3 外部表 562
18.2.4 分区表 564
18.2.5 物化视图 588
18.3 使用位图索引 589
18.3.1 理解位图索引 589
18.3.2 使用位图索引 590
18.3.3 使用位图连接索引 590
18.4 本章小结 591
第19章 管理分布式数据库 593
19.1 远程查询 594
19.2 远程数据处理：两阶段提交 595
19.3 动态数据复制 596
19.4 管理分布式数据 597
19.4.1 基础设施：实施位置透明性 597
19.4.2 管理数据库链接 602
19.4.3 管理数据库触发器 603
19.4.4 管理物化视图 604
19.4.5 使用DBMS_MVIEW和DBMS_ADVISOR 608
19.4.6 可执行什么类型的更新 617
19.4.7 使用物化视图改变查询执行路径 620
19.5 管理分布式事务 622
19.5.1 解决未确定的事务 622
19.5.2 提交点强度 623
19.6 监控分布式数据库 623
19.7 调整分布式数据库 624
19.8 本章小结 626
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 12c DBA官方手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>21天学通Oracle（第3版）
第一篇 Oracle管理配置
第1章  Oracle安装配置
1.1  Oracle简介	1
1.1.1  数据库术语	1
1.1.2  主流数据库简介	2
1.1.3  Oracle数据库的特点	2
1.2  安装Oracle数据库	3
1.2.1  Oracle数据库的版本变迁及安装环境	3
1.2.2  安装过程	4
1.2.3  安装中需要注意的问题	9
1.3  本章小结	9
1.4  习题	9
第2章  Oracle常用工具
2.1  Net Configuration Assistant（网络配置助手）	10
2.1.1  监听程序配置	10
2.1.2  命名方法配置	13
2.1.3  本地网络服务名配置	15
2.2  Net Manager（网络管理员）	17
2.3  本章实例	19
2.4  本章小结	21
2.5  习题	21
第3章  SQL Plus和PL/SQL
3.1  SQL Plus与PL/SQL简介	22
3.2  使用SQL Plus	23
3.2.1 登录SQL Plus	23
3.2.2  SQL Plus输出结果的格式化	24
3.2.3  SQL Plus小结	29
3.3  PL/SQL	29
3.3.1  PL/SQL常用开发工具	29
3.3.2  开发一个简单的PL/SQL程序	30
3.4  本章实例	31
3.5  本章小结	32
3.6  习题	32
第二篇 Oracle数据库对象
第4章  Oracle数据库
4.1  创建Oracle数据库	33
4.2  Oracle数据库的相关术语	35
4.2.1  数据库	35
4.2.2  数据库实例和SID	36
4.2.3  ORACLE_SID	37
4.3  Oracle数据库的备份与恢复	37
4.3.1  逻辑备份/恢复（导出/导入）	37
4.3.2  物理备份/恢复	38
4.3.3  利用SQL Developer备份数据库	39
4.4  本章实例	41
4.5  本章小结	41
4.6  习题	42
第5章  Oracle数据表对象
5.1  Oracle表空间	43
5.1.1  Oracle表空间简介	43
5.1.2  创建Oracle表空间	44
5.1.3  查看表空间	47
5.1.4  修改数据库默认表空间	47
5.1.5  修改表空间名称	48
5.1.6  删除表空间	49
5.2  创建Oracle数据表	50
5.2.1  利用工具创建数据表	50
5.2.2  利用工具查看数据表	51
5.2.3  利用命令创建数据表	52
5.2.4  利用命令查看表结构	52
5.3  修改Oracle数据表结构	53
5.3.1  利用工具修改数据表结构	53
5.3.2  利用命令修改数据表结构	54
5.4  删除数据表	56
5.4.1  利用工具删除数据表	56
5.4.2  利用SQL语句删除数据表	56
5.5  备份/恢复数据表	57
5.5.1  利用工具备份/恢复数据表	57
5.5.2  利用命令备份/恢复数据表	60
5.6  临时表	61
5.6.1  临时表简介	61
5.6.2  会话级临时表	61
5.6.3  事务级临时表	62
5.6.4  查看临时表在数据库中的信息	63
5.6.5  临时表的应用场景	64
5.7  特殊的表dual	64
5.7.1  分析dual表	65
5.7.2  dual表的应用场景	65
5.7.3  修改dual表对查询结果的影响	66
5.8  本章实例	66
5.9  本章小结	67
5.10  习题	67
第6章  约束
6.1  主键约束	68
6.1.1  主键简介	68
6.1.2  创建主键约束	69
6.1.3  修改表的主键约束	71
6.1.4  主键应用场景	73
6.2  外键约束	74
6.2.1  外键简介	74
6.2.2  创建外键约束	74
6.2.3  级联更新与级联删除	77
6.2.4  修改外键属性	79
6.2.5  外键使用	81
6.3  唯一性约束	82
6.3.1  唯一性约束简介	82
6.3.2  创建唯一性约束	82
6.3.3  修改唯一性约束	83
6.3.4  唯一性约束的使用	84
6.4  检查约束	85
6.4.1  检查约束简介	85
6.4.2  创建检查约束	85
6.4.3  修改检查约束	87
6.4.4  检查约束的使用	88
6.5  默认值约束	88
6.5.1  默认值约束简介	88
6.5.2  创建默认值约束	88
6.5.3  修改默认值约束	90
6.6  本章实例	91
6.7  本章小结	92
6.8  习题	92
第7章  视图
7.1  关系视图	93
7.1.1  建立关系视图	93
7.1.2  修改/删除视图	94
7.1.3  连接视图	96
7.1.4  编译视图	98
7.1.5  使用force选项强制创建视图	100
7.1.6  利用视图更新数据表	101
7.1.7  with check option选项	103
7.1.8  关系视图小结	104
7.2  内嵌视图	104
7.2.1  内嵌视图简介	105
7.2.2  内嵌视图的使用	105
7.2.3  内嵌视图小结	107
7.3  对象视图	107
7.3.1  对象视图简介	107
7.3.2  对象视图的创建与使用	107
7.4  物化视图	109
7.4.1  物化视图简介	109
7.4.2  物化视图的使用	109
7.4.3  物化视图的数据加载	111
7.4.4  物化视图的数据更新	111
7.4.5  查询重写	112
7.5  本章实例	113
7.6  本章小结	113
7.7  习题	113
第8章  函数与存储过程
8.1  函数	114
8.1.1  函数简介	114
8.1.2  创建函数	114
8.1.3  函数中的括号	116
8.1.4  函数的参数	117
8.1.5  函数的确定性	118
8.1.6  典型函数举例	119
8.2  存储过程	120
8.2.1  存储过程简介	120
8.2.2  创建存储过程	120
8.2.3  存储过程的参数——IN参数	122
8.2.4  存储过程的参数——OUT参数	123
8.2.5  存储过程的参数——IN OUT参数	125
8.2.6  存储过程的参数——参数顺序	125
8.2.7  存储过程的参数——参数的默认值	128
8.2.8  存储过程的参数——参数顺序总结	129
8.3  程序包	129
8.3.1  规范	129
8.3.2  主体	131
8.3.3  调用程序包中的函数/存储过程	133
8.3.4  程序包中的变量	134
8.4  本章实例	135
8.5  本章小结	137
8.6  习题	137
第9章  游标
9.1  游标简介	138
9.2  显式游标	138
9.2.1  声明游标	138
9.2.2  使用游标	140
9.3  隐式游标	142
9.3.1  sql隐式游标	143
9.3.2  cursor for游标	144
9.3.3  隐式游标和显式游标	145
9.4  游标属性	145
9.5  动态游标	147
9.5.1  强类型动态游标	147
9.5.2  弱类型动态游标	149
9.5.3  比较两种动态游标	152
9.6  本章实例	152
9.7  本章小结	153
9.8  习题	153
第10章  触发器
10.1  触发器简介	154
10.2  创建和使用触发器	154
10.2.1  创建触发器	155
10.2.2  触发器的作用级别	156
10.2.3  在多个事件上定义触发器	157
10.2.4  为同一事件定义多个触发器	158
10.2.5  触发器限制	159
10.3  语句触发器	160
10.3.1  创建语句触发器	160
10.3.2  触发器谓词	162
10.3.3  触发时机	164
10.3.4  触发器级联	164
10.4  行触发器	165
10.4.1  行触发器与引用	166
10.4.2  触发时机与引用	168
10.4.3  触发时机与瞬态	169
10.5  instead of触发器	171
10.5.1  创建和使用instead of触发器	171
10.5.2  instead of触发器与引用	174
10.6  系统事件与用户事件触发器	175
10.6.1  系统事件触发器	175
10.6.2  用户事件触发器	176
10.7  启用和禁用触发器	178
10.7.1  启用和禁用触发器的场景	178
10.7.2  禁用触发器	178
10.7.3  启用触发器	179
10.7.4  触发器信息	180
10.8  本章实例	180
10.9  本章小结	182
10.11  习题	182
第11章  序列
11.1  创建和使用序列	183
11.1.1  创建序列	183
11.1.2  使用序列	184
11.1.3  序列初始值start with	185
11.2  修改序列属性	186
11.2.1  修改minvalue和maxvalue	186
11.2.2  修改increment by	187
11.2.3  修改cycle	188
11.2.4  修改cache	189
11.3  本章实例	190
11.4  本章小结	191
11.5  习题	191
第12章  用户角色与权限控制
12.1  用户	192
12.1.1  Oracle中的用户	192
12.1.2  创建新用户	193
12.1.3  用户与模式（Schema）	194
12.1.4  系统用户sys和system	194
12.2  权限	195
12.2.1  系统权限	195
12.2.2  对象权限	197
12.3  角色	201
12.3.1  创建和使用角色	201
12.3.2  继承角色	203
12.3.3  禁用和启用角色	204
12.4  本章实例	205
12.5  本章小结	206
12.6  习题	206
第三篇 Oracle中的SQL
第13章  Oracle数据类型
13.1  Oracle中的数据类型	207
13.1.1  字符型	207
13.1.2  数值型	208
13.1.3  日期时间型	208
13.1.4  lob类型	209
13.2  Oracle中的特殊数据	209
13.2.1  rowid	209
13.2.2  null与空字符串	210
13.2.3  单引号与双引号	211
13.3  本章实例	213
13.4  本章小结	215
13.5  习题	215
第14章  Oracle中的函数与表达式
14.1  Oracle中的字符串函数	216
14.1.1  lpad()函数	216
14.1.2  rpad()函数	217
14.1.3  lower()函数——返回小写字符串	217
14.1.4  upper()函数——返回大写字符串	217
14.1.5  initcap ()函数——单词首字母大写	218
14.1.6  length()函数——返回字符串长度	218
14.1.7  substr()函数——截取字符串	219
14.1.8  instr()函数——获得字符串出现的位置	219
14.1.9  ltrim()函数——删除字符串首部空格	220
14.1.10  rtrim()函数——删除字符串尾部空格	220
14.1.11  trim()函数——删除字符串首尾空格	220
14.1.12  to_char()函数——将其他类型转换为字符类型	221
14.1.13  chr()函数——将ASCII码转换为字符串	223
14.1.14  translate()函数——替换字符	223
14.2  Oracle中的数学函数	224
14.2.1  abs ()函数——返回数字的绝对值	224
14.2.2  round ()函数——返回数字的“四舍五入”值	224
14.2.3  ceil()函数——向上取整	225
14.2.4  floor()函数——向下取整	225
14.2.5  mod ()函数——取模操作	226
14.2.6  sign()函数——返回数字的正负性	226
14.2.7  sqrt()函数——返回数字的平方根	226
14.2.8  power()函数——乘方运算	227
14.2.9  trunc()函数——截取数字	227
14.2.10  vsize()函数——返回数据的存储空间	227
14.2.11  to_number()函数——将字符串转换为数值类型	228
14.3  Oracle中的日期函数	228
14.3.1  to_date()函数——将字符串转换为日期型	228
14.3.2  add_months()函数——为日期加上特定月份	229
14.3.3  last_day()函数——返回特定日期所在月的最后一天	230
14.3.4  months_between ()函数——返回两个日期所差的月数	230
14.3.5  current_date()函数——返回当前会话时区的当前日期	230
14.3.6  current_timestamp()函数——返回当前会话时区的 当前时间戳	231
14.3.7  extract()函数——返回日期的某个域	231
14.4  Oracle中的聚合函数	232
14.4.1  max()函数——求最大值	233
14.4.2  min()函数——求最小值	233
14.4.3  avg()函数——求平均值	234
14.4.4  sum()函数——求和	234
14.4.5  count()函数——获得记录数	235
14.5  Oracle中的其他函数	236
14.5.1  decode()函数——多值判断	236
14.5.2  nvl()函数——处理空值	237
14.5.3  cast()函数——强制转换数据类型	238
14.6  Oracle中的运算表达式	239
14.6.1  数学运算	240
14.6.2  逻辑运算	241
14.6.3  位运算	242
14.7  Oracle中的特殊判式	242
14.7.1  between——范围测试	243
14.7.2  in——集合成员测试	244
14.7.3  like——模式匹配	244
14.7.4  is null——空值判断	244
14.7.5  exists——存在性判断	245
14.7.6  all、some和any——数量判断	245
14.8  Oracle高级函数——分析函数与窗口函数	246
14.8.1  排名	246
14.8.2  分区窗口	248
14.8.3  窗口子句	250
14.8.4  主要的分析函数	253
14.9  本章实例	256
14.10  本章小结	257
14.11  习题	258
第15章  Oracle中的控制语句
15.1  Oracle中的条件语句	259
15.1.1  利用if else进行条件判断	259
15.1.2  利用case when进行分支判断	260
15.2  Oracle中的循环语句	262
15.2.1  无条件循环	262
15.2.2  while循环	263
15.2.3  for循环	264
15.3  本章实例	265
15.4  本章小结	265
15.5  习题	266
第16章 SQL查询
16.1  基本查询	267
16.1.1  select语句查询执行步骤	267
16.1.2  where子句	269
16.1.3  利用distinct获得唯一性记录	270
16.1.4  order by子句	270
16.1.5  group by子句	271
16.1.6  having子句	274
16.2  子查询	275
16.2.1  理解子查询	275
16.2.2  子查询使用实例	275
16.3  联合语句	277
16.3.1  union查询	277
16.3.2  union all查询	278
16.3.3  intersect查询	280
16.3.4  minus查询	280
16.4  连接	281
16.4.1  自然连接	281
16.4.2  内连接	282
16.4.3  外连接——左连接	283
16.4.4  外连接——右连接	285
16.4.5  外连接——完全连接	287
16.5  层次化查询	289
16.5.1  利用connect by进行层次化查询	290
16.5.2  connect by的使用场景	291
16.5.3  sys_connect_by_path()函数的使用	292
16.6  本章实例	293
16.7  本章小结	295
16.8  习题	295
第17章  SQL更新数据
17.1  插入数据	296
17.1.1  insert语句向表中插入数据	296
17.1.2  利用子查询批量插入数据	297
17.1.3  insert语句与默认值	298
17.1.4  insert语句与唯一性约束	298
17.1.5  insert语句与外键约束	298
17.2  修改数据	299
17.2.1  利用update修改单列的值	299
17.2.2  利用update修改多列的值	300
17.2.3  利用where子句限制修改范围	300
17.3  删除数据	301
17.3.1  利用delete命令删除数据	301
17.3.2  利用truncate命令删除数据	302
17.4  数据提交与回滚	302
17.4.1  回滚动作	302
17.4.2  提交动作	303
17.4.3  SQL Developer中的回滚与提交	304
17.5  本章实例	305
17.6  本章小结	307
17.7  习题	307
第四篇 Oracle编程高级应用
第18章  数据库速度优化与数据完整性
18.1  利用索引加快数据引用	308
18.1.1  索引的原理	308
18.1.2  利用索引提高数据库性能	309
18.1.3  索引对DML的影响	311
18.1.4  索引的使用时机	312
18.2  利用约束保持数据完整性	312
18.2.1  数据库完整性的重要性	313
18.2.2  保持数据库完整性的重要方面	313
18.2.3  利用约束保持数据完整性	313
18.3  本章实例	314
18.3.1  使用比较运算符不当	314
18.3.2  函数的使用	315
18.3.3  联合索引	315
18.4  本章小结	316
18.6  习题	316
第19章  数据一致性与事务管理
19.1  什么是数据一致性和事务	317
19.1.1  数据一致性	317
19.1.2  事务	317
19.2  Oracle中的事务处理	318
19.2.1  commit命令	318
19.2.2  rollback命令	319
19.2.3  savepoint和rollback to savepoint命令	319
19.2.4  事务的属性和隔离级别	321
19.3  事务处理原则	325
19.3.1  原子性	325
19.3.2  一致性	326
19.3.3  隔离性	328
19.3.4  持久性	329
19.4  本章实例	329
19.5  本章小结	331
19.6  习题	331
第20章  并发控制
20.1  并发与锁定	332
20.2  数据锁定	335
20.2.1  悲观锁定	335
20.2.2  乐观锁定	336
20.2.3  悲观锁定与乐观锁定的比较	338
20.2.4  锁定转换	338
20.3  并发控制的其他方法	339
20.4  本章实例	339
20.5  本章小结	343
20.6  习题	343
第21章  Oracle中的正则表达式
21.1  正则表达式简介	344
22.1.1  正则表达式与通配符	344
22.1.2  正则表达式与编程语言	344
21.2  正则表达式基础知识	345
21.2.1  元字符和普通字符	345
21.2.2  量词	345
21.2.3  字符转义与字符类	345
21.2.4  字符组的使用	346
21.2.5  正则表达式分支	346
21.2.6  Oracle中正则表达式的特殊性	346
21.3  正则表达式在Oracle中的应用	347
21.3.1  regexp_like()的使用	347
21.3.2  regexp_instr()的使用	347
21.3.3  regexp_substr()的使用	348
21.3.4  regexp_ replace ()的使用	348
21.4  本章实例	349
21.5  本章小结	349
21.6  习题	350
第五篇 Oracle与编程语言综合使用实例
第22章  Oracle在Java开发中的应用
22.1  通过JDBC使用Oracle	351
22.1.1  JDBC简介	351
22.1.2  准备工作	351
22.1.3  JDBC连接Oracle	352
22.1.4  利用JDBC查询数据	354
22.1.5  利用JDBC更新数据	355
22.1.6  总结JDBC操作数据库	357
22.2  通过Hibernate操作Oracle数据库	357
22.2.1  准备工作	357
22.2.2  配置Hibernate	358
22.2.3  利用Hibernate查询数据	361
22.2.4  利用Hibernate更新数据	362
22.2.5  利用Hibernate插入数据	364
22.3  本章小结	365
22.4  习题	365
第23章  Oracle在C#开发中的应用
23.1  在C#中连接Oracle数据库	366
23.2  在C#中操作Oracle数据库	367
23.3  在C#中使用Oracle数据库事务	369
23.4  本章小结	371
23.5  习题	372
第六篇  应试指南
第24章  常见面试习题
24.1  简历准备	373
24.2  简历投递及面试	374
24.3  常见数据库理论问题	375
24.4  常见PL/SQL相关面试问题	375
24.5  常见Oracle维护相关面试问题	377
24.6  常见Oracle应用开发相关面试问题	379
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>21天学通Oracle（第3版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库性能优化方法论和最佳实践
目录
前言
第1章Oracle性能优化漫谈1
1.1从生活场景漫谈性能优化1
1.1.1从一个真实病例说起1
1.1.2如何改善宝马汽车的运行速度2
1.2性能优化目标的确定和衡量3
1.2.1性能优化的范畴或优化对象确定4
1.2.2性能优化目标的用户期望管理4
1.2.3性能优化的目标衡量5
1.3吞吐量和响应时间6
1.3.1吞吐量6
1.3.2响应时间7
1.3.3吞吐量和响应时间关系曲线8
1.3.4医院挂号窗口的吞吐量和响应时间曲线8
1.3.5tpcc测试的吞吐量和响应时间曲线10
1.3.6磁盘I／O系统吞吐量和响应时间曲线10
1.4Oracle性能优化工作的分类12
1.4.1上线优化或从未达到过性能期望的系统优化12
1.4.2响应速度逐步变慢的系统优化13
1.4.3运行过程中突然变慢的系统优化13
1.4.4突然变慢，持续一段时间后又恢复正常的业务系统优化14
1.4.5基于降低资源消耗的系统优化14
1.4.6预防性日常性能优化14
1.5测量和变化15
1.5.1测量和性能15
1.5.2变化检测和性能优化17
1.5.3量变和质变18
1.6基线管理19
1.6.1基准点和基线19
1.6.2沟通基线19
1.6.3基线管理和动态基线20
1.7Oracle性能优化的神话和误区23
1.7.1艺术和科学23
1.7.2Oracle业务系统性能优化是高手的专利23
1.7.3测试系统性能很好，生产系统为什么不行24
1.7.4针对特定性能问题的标准解决方案24
1.7.5只要资源充足，数据库性能就不会差24
1.7.6只要数据库性能好，业务系统性能必然良好25
1.7.7降低等待时间就可以提高业务系统性能25
第2章Oracle性能优化方法论的发展27
2.1基于局部命中率分析的优化方法论28
2.2基于OWI的优化方法论29
2.2.1OWI优化方法论简述29
2.2.2OWI方法论的可检测体系30
2.2.3OWI方法中waitevent的发展31
2.3响应时间分析优化方法论32
2.3.1RTA方法论简述32
2.3.2RTA方法论的不足和改善35
2.4基于工作单元的响应时间分析优化方法论35
2.4.1UOWTBA优化方法论的导入35
2.4.2输入吞吐量指标的选择36
2.4.3采用UOWTBA优化方法工作38
2.5基于资源瓶颈分析的优化方法论38
2.5.1基于资源瓶颈分析优化方法论简述38
2.5.2主要的数据库服务资源供给39
2.5.3有效运行资源瓶颈分析优化方法40
2.6流程、资源和组件优化方法论41
2.6.1吞吐量和响应时间关系曲线41
2.6.2流程和流程响应分析41
2.6.3资源分析43
2.6.4组件45
第3章流程分析之数据库登录流程46
3.1数据库登录导致业务系统性能恶化案例分享46
3.2数据库登录流程的相关指标与优化47
3.2.1数据库登录流程的输入吞吐量和输出响应指标47
3.2.2输入压力与输出响应之间的关系58
3.2.3数据库登录流程响应问题的优化案例64
第4章流程分析之数据访问处理流程67
4.1数据访问处理流程优化案例分享68
4.2数据访问处理流程的分解68
4.3数据访问处理流程的输入和输出69
4.3.1输入单元和输出单元的确定69
4.3.2输入和输出指标的测量74
4.3.3输入和输出指标的关系曲线79
4.4数据访问流程优化步骤80
4.5客户端运行和响应阶段80
4.5.1子流程过程性分解80
4.5.2子流程的输入和输出指标81
4.5.3相关资源和组件84
4.5.4业务请求和响应阶段优化案例84
4.6SQL语句分析阶段（parse阶段）85
4.6.1parse阶段子流程分解85
4.6.2hard parse／soft parse／soft soft parse／no parse的区别87
4.6.3SQL语句parse的高版本93
4.6.4复杂语句和简单语句的parse差异96
4.6.5parse阶段的输入／输出指标99
4.6.6parse阶段的优化道路113
4.6.7相关资源和组件121
4.6.8parse阶段优化案例分析122
4.7SQL语句执行阶段（execute阶段）123
4.7.1SQL执行阶段子流程分解123
4.7.2SQL执行子流程输入／输出指标144
4.7.3SQL执行子流程的输入／输出指标衡量147
4.7.4SQL执行阶段输入／输出关系图155
4.7.5SQL执行阶段的优化道路158
4.7.6SQL执行阶段相关资源和组件162
4.7.7SQL执行阶段优化案例164
4.8fetch次数对逻辑读的影响165
4.9提交（Commit）阶段的流程分解和分析167
4.9.1提交阶段的主要执行过程167
4.9.2高并发性提交的响应问题169
4.9.3提交阶段的优化道路174
第5章资源175
5.1简单的资源供给类176
5.1.1资源使用的突变曲线176
5.1.2资源的使用率和队列长度176
5.1.3导致资源供给性能问题的主要场景177
5.2并发性资源178
5.2.1并发性资源效率的衡量178
5.2.2主要的并发性资源和响应突变曲线178
第6章资源供给：CPU179
6.1简单案例分享179
6.2CPU的特殊性179
6.3CPU的工作和运行性能的衡量180
6.3.1CPU的主要工作180
6.3.2CPU运行性能的衡量：利用率和运行队列长度180
6.3.3CPU的运行性能曲线180
6.4CPU资源的主要衡量指标186
6.4.1CPU的主要性能衡量指标186
6.4.2CPU的主要性能衡量指标的测量187
6.4.3CPU相关的主要Oracle指标189
6.5几个CPU资源常见问题的讨论191
6.5.1CPU资源的100%利用率191
6.5.2CPU运行队列的长度标准191
6.5.3CPUsys部分的资源消耗问题192
6.6CPU资源优化的目标和道路193
6.6.1CPU资源问题的场景和优化道路193
6.6.2降低CPU的输入压力195
6.6.3分布局部的CPU输入压力204
6.6.4提高CPU处理效率204
6.6.5合理调度平缓化CPU使用206
6.7CPU资源优化案例206
第7章资源供给：内存和虚拟内存208
7.1简单案例分享208
7.2物理内存和虚拟内存208
7.3简单的虚拟内存管理209
7.3.1工作存储分页和永久存储分页209
7.3.2计算分页和非计算分页210
7.3.3页面大小和大页管理215
7.3.4进程内存管理218
7.4虚拟内存运行性能的衡量221
7.4.1虚拟内存运行性能221
7.4.2虚拟内存的运行性能曲线222
7.5虚拟内存资源的主要衡量指标225
7.5.1虚拟内存的主要性能衡量指标225
7.5.2虚拟内存主要性能衡量指标的测量226
7.5.3虚拟内存相关的主要Oracle指标229
7.6几个虚拟内存资源常见问题的讨论231
7.6.1有128GB的内存，为什么自由空间还是很少231
7.6.2Oracle业务系统环境下的文件系统缓冲231
7.6.3如何从AWR报告中发现可能存在的虚拟问题232
7.6.4如何检测和发现内存泄漏233
7.7虚拟内存资源优化的目标和道路234
7.7.1虚拟内存资源问题的场景和优化道路234
7.7.2合理配置内存分配参数，避免发生swapin和swapout234
7.7.3合理分配内存，让内存的使用处于安全可控的范围236
7.7.4充分利用内存，提高业务处理程序运行效率237
7.7.5合理调度业务程序，使内存使用平缓化238
7.8虚拟内存资源优化案例239
第8章资源供给：I／O子系统243
8.1简单案例分享243
8.2I／O子系统和构成243
8.3卷管理器和文件系统245
8.3.1卷管理器245
8.3.2文件系统和逻辑卷246
8.4HBA、SAN交换机及其他存储系统链路通道249
8.4.1HBA和SAN249
8.4.2NIC和网络交换机250
8.4.3IB和IB交换机250
8.5磁盘和磁盘阵列251
8.5.1磁盘251
8.5.2磁盘的硬件基础性能衡量252
8.5.3磁盘的iops和数据传输率253
8.5.4磁盘平均队列长度254
8.5.5磁盘阵列254
8.6Raid和LUN255
8.7磁盘多路径访问和基于存储的容灾复制影响258
8.7.1磁盘多路径访问258
8.7.2基于存储（卷）的容灾复制系统的影响259
8.8固态硬盘和PCIe260
8.8.1固态硬盘和传统机械硬盘260
8.8.2SSD的简单结构261
8.8.3固态硬盘不是机械设备261
8.8.4固态硬盘不支持原址更新263
8.8.5Oracle和固态硬盘263
8.9随机访问和顺序访问266
8.10基于Oracle数据库的存储系统设计269
8.10.1Oracle online redo logfile和磁盘阵列269
8.10.2临时表空间的存储设计269
8.10.3OLTP业务系统或混合型业务系统269
8.10.4数据仓库或DSS决策系统270
8.11I／O子系统的运行性能衡量270
8.11.1I／O子系统运行性能的衡量指标270
8.11.2I／O子系统的运行性能曲线271
8.11.3I／O资源主要性能衡量指标的测量272
8.11.4I／O子系统相关的主要Oracle指标275
8.12几个I／O子系统资源常见问题的讨论275
8.12.1I／O资源极度紧张但I／Owait表现不高275
8.12.2发现大量的磁盘Cache但似乎Oracle不理会276
8.12.3磁盘利用率为100%，但处理能力还在不断上涨277
8.12.4如何发现因存储系统导致的性能故障277
8.13I／O子系统资源优化的目标和道路278
8.13.1I／O资源问题的场景和优化道路278
8.13.2明确存储故障，修正配置或修复存储278
8.13.3降低存储系统的全局I／O压力280
8.13.4分布存储系统压力，使每个I／O设备处于合理范畴290
8.13.5合理调度业务程序，使I／O资源使用平缓化291
8.14I／O子系统资源优化案例291
……
第9章资源供给：网络子系统
第10章资源供给：队列锁
第11章资源供给：row cache lock和library cache lock
第12章资源供给：buffer lock
第13章资源供给：latch
第14章资源供给：mutex
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库性能优化方法论和最佳实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>零基础学Oracle
前言
第一篇  数据库安装篇
第1章  Oracle 11g数据库简介
1.1  认识Oracle 11g
1.1.1  Oracle的成长历程
1.1.2  了解Oracle 11g
1.1.3  Oracle与SQL Server
1.2  Oracle的产品版本
1.3  Oracle 11g的新特性
1.3.1  数据库管理部分
1.3.2  PL/SQL部分
1.4  小结
1.5  习题
第2章  Oracle 11g的安装与卸载
2.1  使用Oracle 11g的基本条件
2.1.1  硬件条件
2.1.2  软件条件
2.2  在Windows 2003系统中安装Oracle 11g
2.2.1  获取Oracle 11g的安装文件
2.2.2  安装Oracle 11g
2.2.3  安装中遇到的问题
2.3  移除Oracle 11g
2.3.1  停止服务
2.3.2  卸载Oracle产品
2.3.3  删除注册表项
2.3.4  删除环境变量
2.3.5  删除目录并重启计算机
2.4  小结
2.5  习题
第二篇  数据库基础篇
第3章  熟悉数据库
3.1  什么是数据库
3.1.1  了解数据管理的历史
3.1.2  数据库的模型
3.1.3  数据库的三级模式和二级映像
3.1.4  数据库相关术语
3.1.5  数据库设计的完整性
3.2  范式--设计关系型数据库的准则
3.2.1  第一范式--关系型数据库的第一步
3.2.2  第二范式--关系型数据库的第二步
3.2.3  第三范式--关系型数据库设计的第三步
3.3  绘制E-R图设计数据库
3.3.1  绘制E-R图的基本要素
3.3.2  E-R图绘制实例
3.4  小结
3.5  习题
第4章  SQL基础
4.1  SQL-数据库沟通的语言标准
4.1.1  什么是SQL
4.1.2  了解SQL的种类
4.2  Oracle 11g中支持的数据类型
4.2.1  查看Oracle 11g中的数据类型
4.2.2  常用的数据类型
4.3  数据库定义语言（DDL）
4.3.1  使用CREATE语句创建表
4.3.2  使用ALTER语句修改表
4.3.3  使用DROP语句删除表
4.4   约束的使用
4.4.1  主键约束
4.4.2  外键约束
4.4.3  检查约束
4.4.4  唯一约束
4.4.5  非空约束
4.5  数据操纵语言（DML）和数据查询语言（DQL）
4.5.1  添加数据（INSERT）
4.5.2  修改数据（UPDATE）
4.5.3  删除数据（DELETE）
4.5.4  查询数据（SELECT）
4.5.5  其他数据操纵语句
4.6  数据控制语言（DCL）
4.7  小结
4.8  习题
第5章  利用SELECT检索数据
5.1  查询数据必备SELECT
5.1.1  SELECT语句概述
5.1.2  获取指定字段的数据
5.1.3  获取所有字段的数据
5.1.4  使用别名替代表中的字段名
5.1.5  使用表达式操作查询的字段
5.1.6  使用函数操作查询的字段
5.1.7  去除检索数据中的重复记录
5.2  对检索出来的数据排序
5.2.1  排序的语法
5.2.2  使用升序和降序来处理数据
5.2.3  排序时对NULL值的处理
5.2.4  使用别名作为排序字段
5.2.5  使用表达式作为排序字段
5.2.6  使用字段的位置作为排序字段
5.2.7  使用多个字段排序
5.3  WHERE子句
5.3.1  查询中使用单一条件限制
5.3.2  查询中使用多个条件限制
5.3.3  模糊查询数据
5.3.4  查询条件限制在某个列表（list）范围之内
5.3.5  专门针对NULL值的查询
5.4  GROUP BY和HAVING子句
5.4.1  GROUP BY子句的使用
5.4.2  HAVING子句的使用
5.5  子查询
5.5.1  子查询返回单行数据
5.5.2  子查询返回多行数据
5.6  连接查询
5.6.1  最简单的连接查询
5.6.2  内连接
5.6.3  自连接
5.6.4  外连接
5.7  小结
5.8  习题
第6章  Oracle内置函数
6.1  数值型函数
6.1.1  绝对值、取余、判断数值正负函数
6.1.2  三角函数
6.1.3  返回以指定数值为准整数的函数
6.1.4  指数、对数函数
6.1.5  截取函数
6.2  字符型函数
6.2.1  ASCII码与字符转换函数
6.2.2  获取字符串长度的函数（LENGTH函数）
6.2.3  字符串截取函数
6.2.4  字符串连接函数
6.2.5  字符串搜索函数
6.2.6  字母大小写转换函数
6.2.7  带排序参数的字母大小写转换函数
6.2.8  为指定参数排序的函数
6.2.9  替换字符串函数
6.2.10  字符串填充函数
6.2.11  删除字符串首尾指定字符的函数
6.2.12  字符集名称和ID互换的函数
6.3  日期型函数
6.3.1  系统日期、时间函数
6.3.2  得到数据库时区的函数
6.3.3  为日期加上指定月份的函数
6.3.4  返回指定月份最后一天的函数
6.3.5  返回指定日期下一周的日期的函数
6.3.6  返回会话所在时区当前日期的函数
6.3.7  提取指定日期特定部分的函数
6.3.8  得到两个日期之间的月份数的函数
6.3.9  时区时间转换函数
6.3.10  日期截取函数
6.4  转换函数
6.4.1  字符串转ASCII类型字符串函数
6.4.2  二/十进制转换函数
6.4.3  数据类型转换函数
6.4.4  字符串和ROWID相互转换的函数
6.4.5  字符串在字符集间转换的函数
6.4.6  十六进制字符串与RAW类型相互转换的函数
6.4.7  数值转换成字符型数据的函数
6.4.8  字符转日期型数据的函数
6.4.9  字符串转数字的函数
6.4.10  全角转半角的函数
6.5  NULL函数
6.5.1  返回表达式为NULL的函数
6.5.2  排除指定条件的函数
6.5.3  替换NULL值的函数
6.6  集合函数
6.6.1  平均值函数
6.6.2  计数函数
6.6.3  最大最小值函数
6.6.4  求和函数
6.7  其他函数
6.7.1  返回登录名函数
6.7.2  返回会话以及上下文信息的函数
6.7.3  表达式匹配函数
6.8  小结
6.9  习题
第7章  PL/SQL基础
7.1  什么是PL/SQL
7.1.1  认识PL/SQL
7.1.2  PL/SQL的优势
7.1.3  PL/SQL的结构
7.1.4  PL/SQL的基本规则
7.1.5  PL/SQL中的注释
7.2  PL/SQL变量的使用
7.2.1  变量、常量的类型及使用语法
7.2.2  标量类型的变量
7.2.3  复合类型的变量
7.3  表达式
7.3.1  数值表达式
7.3.2  关系表达式和逻辑表达式
7.4  PL/SQL结构控制
7.4.1  IF条件控制语句
7.4.2  CASE条件控制语句
7.4.3  LOOP循环控制语句
7.5  PL/SQL中使用DML和DDL语言
7.5.1  DML语句的使用
7.5.2  DDL语句的使用
7.6  PL/SQL中的异常
7.6.1  什么是异常
7.6.2  处理异常的语法
7.6.3  预定义异常
7.6.4  非预定义异常
7.6.5  自定义异常
7.7  PL/SQL函数
7.7.1  函数的组成
7.7.2  函数的语法
7.7.3  查看函数
7.7.4  使用PLSQL Developer创建函数
7.7.5  函数的修改、删除
7.8  小结
7.9  习题
第8章  游标--数据的缓存区
8.1  什么是游标
8.1.1  游标的概念
8.1.2  游标的种类
8.2  显式游标
8.2.1  游标语法
8.2.2  游标的使用步骤
8.2.3  游标中的LOOP语句
8.2.4  使用BULK COLLECT和FOR语句的游标
8.2.5  使用CURSOR FOR LOOP
8.2.6  显式游标的属性
8.2.7  带参数的游标
8.3  隐式游标
8.3.1  隐式游标的特点
8.3.2  游标中的异常处理
8.3.3  隐式游标的属性
8.4  有关游标的案例
8.5  小结
8.6  习题
第9章  视图--数据库中虚拟的表
9.1  什么是视图
9.1.1  认识视图
9.1.2  视图的作用
9.1.3  视图的语法
9.2  创建的视图
9.2.1  创建单表视图
9.2.2  创建多表视图
9.2.3  创建视图的视图
9.2.4  创建没有源表的视图
9.2.5  使用PL/SQL工具创建视图
9.2.6  创建带约束的视图
9.2.7  有关视图的案例
9.3  操作视图数据的限制
9.3.1  视图的READ ONLY属性设置
9.3.2  视图的CHECK OPTION属性设置
9.3.3  视图创建语句对视图操作的影响
9.4  视图的修改
9.4.1  视图结构的修改
9.4.2  视图约束的修改
9.5  视图的删除
9.6  小结
9.7  习题
第10章  存储过程--提高程序执行的效率
10.1  什么是存储过程
10.1.1  认识存储过程
10.1.2  存储过程的作用
10.1.3  存储过程的语法
10.2  在SQL*Plus中创建存储过程
10.2.1  创建第一个存储过程
10.2.2  查看存储过程
10.2.3  显示存储过程的错误
10.2.4  无参存储过程
10.2.5  在存储过程中使用游标
10.2.6  存储过程中的DDL语句
10.2.7  有参存储过程
10.3  使用PL/SQL工具创建存储过程
10.3.1  在PL/SQL Developer中创建存储过程
10.3.2  调试存储过程
10.4  修改、删除存储过程
10.4.1  修改存储过程
10.4.2  删除存储过程
10.5  小结
10.6  习题
第11章  触发器--保证数据的正确性
11.1  什么是触发器
11.1.1  认识触发器
11.1.2  触发器的作用
11.1.3  触发器的类型
11.1.4  触发器的语法
11.2  使用SQL*Plus操作触发器
11.2.1  利用SQL*Plus创建触发器
11.2.2  查看触发器
11.2.3  DML类型触发器
11.2.4  触发器执行顺序
11.2.5  复合型触发器
11.2.6  INSTEAD OF类型触发器
11.2.7  DDL类型触发器
11.2.8  用户和系统事件触发器
11.3  使用PL/SQL工具操作触发器
11.3.1  使用PL/SQL Developer创建触发器
11.3.2  设置触发器是否可用
11.4  修改、删除触发器
11.4.1  修改触发器
11.4.2  删除触发器
11.5  小结
11.6  习题
第12章  事务和锁--确保数据安全
12.1  什么是事务
12.1.1  认识事务
12.1.2  事务的类型
12.1.3  事务的保存点
12.1.4  事务的ACID特性
12.2  锁
12.2.1  认识锁
12.2.2  锁的分类
12.2.3  锁的类型
12.2.4  锁等待与死锁
12.3  小结
12.4  习题
第三篇  数据库管理篇
第13章  使用Oracle 11g Enterprise Manager
13.1  Oracle 11g Enterprise Manager
13.1.1  Oracle 11g Enterprise Manager概述
13.1.2  启动OEM
13.2  使用OEM管理Oracle
13.2.1  OEM中的性能菜单
13.2.2  OEM中的可用性菜单
13.2.3  OEM中的服务器菜单
13.2.4  OEM中的方案菜单
13.2.5  OEM中的数据移动菜单
13.2.6  OEM中的软件和支持菜单
13.3  小结
13.4  习题
第14章  常用工具介绍
14.1  什么是SQL*Plus
14.1.1  SQL*Plus简介
14.1.2  启动SQL*Plus
14.2  使用SQL*Plus
14.2.1  使用SQL*Plus编辑命令
14.2.2  使用SQL*Plus保存命令
14.2.3  使用SQL*Plus运行命令
14.2.4  使用SQL*Plus格式化查询结果
14.2.5  在SQL*Plus中为语句添加注释
14.3  使用PL/SQL Developer
14.3.1  PL/SQL Developer的安装
14.3.2  PL/SQL Developer的布局
14.4  小结
14.5  习题
第15章  控制文件和日志文件
15.1  控制文件与日志文件
15.1.1  控制文件
15.1.2  日志文件
15.2  初识控制文件
15.2.1  控制文件的内容
15.2.2  更新控制文件
15.3  控制文件的多路复用
15.3.1  使用init.ora多路复用控制文件
15.3.2  使用SPFILE多路复用控制文件
15.4  创建控制文件
15.5  日志文件的管理
15.5.1  新建日志文件组
15.5.2  添加日志文件到日志文件组
15.5.3  删除日志文件组及日志文件
15.5.4  查询日志文件组和日志文件
15.6  小结
15.7  习题
第16章  表空间的管理
16.1  表空间的概述
16.1.1  表空间的相关概念
16.1.2  默认表空间
16.2  表空间的管理
16.2.1  创建表空间
16.2.2  重命名表空间
16.2.3  设置表空间的读写状态
16.2.4  设置表空间的可用状态
16.2.5  建立大文件表空间
16.2.6  删除表空间
16.3  临时表空间的管理
16.3.1  建立临时表空间
16.3.2  查询临时表空间
16.3.3  创建临时表空间组
16.3.4  查询临时表空间组
16.3.5  删除临时表空间组
16.4  数据文件的管理
16.4.1  移动数据文件
16.4.2  删除数据文件
16.5  小结
16.6  习题
第17章  与数据库安全性有关的对象
17.1  用户管理
17.1.1  什么是用户管理
17.1.2  创建用户
17.1.3  修改用户信息
17.1.4  删除用户
17.2  权限管理
17.2.1  什么是权限管理
17.2.2  授予权限
17.2.3  撤销权限
17.2.4  查询用户的权限
17.3  角色管理
17.3.1  什么是角色
17.3.2  创建角色
17.3.3  设置角色
17.3.4  修改角色
17.3.5  删除角色
17.3.6  查询角色
17.4  概要文件PROFILE
17.4.1  什么是PROFILE
17.4.2  创建PROFILE
17.4.3  修改PROFILE
17.4.4  删除PROFILE
17.4.5  查询PROFILE
17.5  小结
17.6  习题
第18章  备份与恢复
18.1  数据库的备份与恢复
18.1.1  数据库备份
18.1.2  数据库恢复
18.2  物理备份和恢复数据库
18.2.1  对数据库进行脱机备份
18.2.2  对数据库进行联机备份
18.3  逻辑备份和恢复数据库
18.3.1  逻辑导出数据
18.3.2  逻辑导入数据
18.4  小结
18.5  习题
第19章  使用RMAN工具
19.1  RMAN的概述
19.1.1  RMAN的特点
19.1.2  与RMAN有关的概念
19.2  使用恢复目录
19.2.1  创建恢复目录
19.2.2  使用RMAN连接
19.2.3  在恢复目录中注册数据库
19.2.4  使用企业管理器创建恢复目录
19.3  通道分配
19.3.1  什么是通道分配
19.3.2  手动通道分配
19.3.3  自动通道分配
19.4  备份集
19.4.1  什么是备份集
19.4.2  BACKUP命令的使用
19.5  从备份中恢复
19.5.1  使用RESTORE命令还原
19.5.2  使用RECOVER命令恢复
19.6  小结
19.7  习题
第四篇  数据库应用篇
第20章  在线考试系统数据库设计
20.1  在线考试系统需求分析
20.2  模块设计
20.2.1  模块分类
20.2.2  数据库总体结构
20.2.3  数据库表结构
20.2.4  建表脚本
20.3  小结
20.4  习题
第21章  在.NET中连接Oracle
21.1  什么是ADO.NET
21.1.1  ADO.NET概述
21.1.2  ADO.NET中的对象
21.2  使用绑定的方式连接Oracle
21.2.1  数据控件概述
21.2.2  使用DataGridView控件绑定Oracle数据库
21.3  使用写代码的方式连接Oracle
21.3.1  使用Command对象操作Oracle数据库
21.3.2  使用DataSet对象存储查询结果
21.3.3  商品信息存储实例
21.4  小结
21.5  习题
第22章  在Java中连接Oracle
22.1  JDBC与ODBC简介
22.1.1  什么是JDBC
22.1.2  什么是ODBC
22.2  使用Thin方式连接Oracle
22.3  使用JDBC-ODBC桥连接Oracle
22.3.1  配置ODBC数据源
22.3.2  使用JDBC-ODBC桥连接Oracle
22.4  小结
22.5  习题
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>零基础学Oracle
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle DBA 高可用、备份恢复与性能优化
第 1章 RAC真应用集群 1
1.1 单实例数据库并发控制原理 ..... 1
1.1.1 并发访问的数据不一致问题 .... 1
1.1.2 事务以及隔离级别 .. 2
1.1.3 支持并发的 lock机制 ... 3
1.1.4 支持并发的 latch机制 .. 6
1.1.5 Lock和 Latch的使用.... 7
1.2 RAC并发控制的实现.... 8
1.2.1 RAC的并发控制问题... 8
1.2.2 RAC的实现并发访问... 9
1.3 Oracle为何引入 RAC .. 10
1.4 RAC集群简介 .. 11
1.4.1 集群分类 .... 11
1.4.2 RAC环境的特殊问题. 12
1.4.3 RAC集群 ... 13
1.5 RAC架构详解 .. 15
1.6 RAC与 Clusterware 17
1.7 安装 RAC.... 18
1.7.1 设计 RAC应用环境.... 18
1.7.2 确认安装的软件组件 .. 19
1.7.3 任务规划 .... 20
1.7.4 安装虚拟机  21
1.7.5 在虚拟机上安装 linux操作系统.. 24
1.7.6 配置主机 .... 30
1.7.7 安装 Clusterware.... 43
1.7.8 安装数据库软件 .... 54
1.7.9 启动监听 .... 56
1.7.10 创建 ASM. 58
1.7.11 创建数据库 .... 62
1.8 Failover和 Load balance测试 . 66
1.8.1 Failover失败转移.. 67
1.8.2 LoadBalance负载均衡  68
1.9 本章小结 ..... 69
第 2章 ASM自动存储管理 70
2.1 Oracle自动存储管理概述 . 70
2.2 自动存储管理的优点 ... 71
2.3 ASM系统架构.. 72
2.4 ASM和 CSS集群同步服务 .... 73
2.5 创建 ASM实例  74
2.6 启动 ASM实例  80
2.7 理解 ASM实例架构 .... 83
2.8 ASM命令行管理工具 . 83
2.9 管理 ASM磁盘组 .. 86
2.9.1 使用 ASM磁盘组管理文件的优势 ... 86
2.9.2 创建磁盘组  88
2.9.3 向磁盘组添加磁盘  91
2.9.4 删除磁盘和磁盘组  92
2.9.5 平衡磁盘组  94
2.9.6 MOUNT和 DISMOUNT磁盘组 . 95
2.10 管理 ASM文件 .... 96
2.10.1 ASM磁盘组文件名结构  96
2.10.2 ASM磁盘组中目录管理  97
2.10.3 添加和删除别名 .. 98
2.10.4 删除文件 .. 99
2.10.5 使用 ASM文件模板 . 99
2.11 使用 RMAN将数据库迁移到 ASM实例 .. 101
2.12 管理 ASM的数据字典视图  108
2.13 本章小结 . 108
第 3章管理 Clusterware组件及管理指令..... 109
3.1 Clusterware及其组件. 109
3.2 备份和恢复 VotingDisks.. 110
3.3 添加和删除 VotingDisks.. 111
3.4 备份和恢复 OCR.. 113
3.4.1 从自动备份中恢复 OCR. 115
3.4.2 从人工备份文件中恢复 .. 115
3.5 修改 OCR存储配置信息. 116
3.6 删除 OCR存储 ..... 118
3.7 ocrconfig指令功能汇总... 119
3.8 管理 Clusterware指令 120
3.8.1 srvctl指令  120
3.8.2 crs_stat指令 ... 126
3.8.3 onsctl指令 130
3.8.4 crsctl指令. 134
3.8.5 ocrcheck指令. 137
3.8.6 ocrdump指令. 138
3.8.7 oifcfg指令 140
3.8.8 olsnodes指令 . 142
3.9 本章小结 ... 143
第 4章  DataGuard的安装与管理 144
4.1 DataGuard是什么. 144
4.2 DataGuard体系结构... 144
4.2.1 DataGuard的架构 144
4.2.2 DataGuard的后台进程.... 145
4.3 DataGuard配置及相关概念... 146
4.4 DataGuard服务本质... 147
4.4.1 Apply服务 ..... 148
4.4.2 Redo 应用 148
4.4.3 SQL 应用. 149
4.4.4 角色转换服务  149
4.5 DataGuard的保护模式..... 150
4.6 DataGuard的优点. 151
4.7 手工搭建物理 DataGuard. 152
4.8 物理 DataGuard的 SWITCHOVER .. 161
4.9 物理 DataGuard的 FAILOVER... 164
4.10 如何转换 FAILOVER后的主库为新备库 . 166
4.11 管理物理 Standby数据库 .... 168
4.11.1 启动 Standby数据库 ..... 168
4.11.2 关闭 Standby数据库 ..... 169
4.11.3 Primary数据库结构变化的传播 .... 170
4.11.4 自动传播数据文件和表空间的变化 .... 170
4.11.5 手工修改数据文件和表空间的变化 .... 171
4.11.6 重命名数据文件  174
4.11.7 添加或删除重做日志组  176
4.11.8 监控 DataGuard数据库视图..... 176
4.11.9 设置 DataGuard保护模式... 179
4.12 DataGuard broker  181
4.12.1 DataGuard Broker概述 . 181
4.12.2 DataGuard Broker的配置 ... 181
4.12.3 DataGuard Broker的组件 ... 182
4.12.4 DataGuard Broker的 DMON进程 . 183
4.12.5 DataGuard Broker使用的前提条件 ..... 184
4.12.6 DataGuard Broker配置实例演示 ... 184
4.12.7 DataGuard Broker完成物理 DG的 SWITCHOVER .. 187
4.12.8 DataGuard Broker实现 DG的自动 FAILOVER... 189
4.12.9 DG的 DGMGRL维护指令设置 .... 191
4.13 DataGuard 的日志传输服务 192
4.13.1 通过 ARCn进程来传送 Redo .. 193
4.13.2 LGWR进程同步传送 Redo 195
4.13.3 LGWR进程异步传送 Redo 196
4.14 本章小结 . 197
第 5章  Streams技术原理与应用. 198
5.1 Streams概述  198
5.2 Streams的原理 ..... 199
5.3 Streams体系结构概述 ..... 199
5.4 配置本地捕获进程的单向复制 ... 201
5.4.1 具体配置之前的任务  202
5.4.2 Stream单向本地复制配置.... 204
5.5 使用 MAINTAIN_*存储过程配置流 210
5.6 Streams的几个重要视图 . 213
5.7 小结 ..... 215
第 6章 RMAN备份与恢复数据库 216
6.1 RMAN概述 .... 216
6.2 RMAN的独特之处 .... 216
6.3 RMAN系统架构详解  217
6.4 快闪恢复区（flash recovery area）... 218
6.4.1 修改快闪恢复区大小  218
6.4.2 解决快闪恢复区的空间不足问题 .... 220
6.5 建立 RMAN到数据库的连接 ..... 221
6.6 RMAN的相关概念与配置参数 .. 222
6.7 RMAN备份控制文件  224
6.8 RMAN实现脱机备份  226
6.9 RMAN联机备份 .. 228
6.9.1 联机备份前的准备工作 .. 228
6.9.2 联机备份整个数据库  229
6.9.3 联机备份一个表空间  233
6.9.4 联机备份一个数据文件 .. 234
6.9.5 RMAN备份坏块处理方式 ... 235
6.10 RMAN的增量备份 .. 235
6.11 快速增量备份 ..... 237
6.12 在映像副本上应用增量备份 ..... 239
6.13 创建和维护恢复目录 ..... 240
6.14 RMAN的脚本管理 .. 243
6.15 使用 RMAN非归档模式下的完全恢复 ..... 245
6.15.1 控制文件、数据文件以及重做日志文件丢失的恢复  245
6.15.2 只有数据文件丢失的恢复 .. 249
6.15.3 联机重做日志文件和数据文件损坏的恢复 .... 251
6.15.4 如何将数据文件恢复到其它磁盘目录下 .. 254
6.16 使用 RMAN归档模式下的完全恢复 ... 254
6.16.1 非系统表空间损坏的恢复 .. 254
6.16.2 系统表空间损坏的恢复  257
6.16.3 所有数据文件丢失的恢复 .. 258
6.17 RMAN实现数据块恢复  258
6.18 RMAN的备份维护指令  262
6.18.1 RMAN的 VALIDATE BACKUPSET指令 .... 262
6.18.2 RMAN的 RESTORE…VALIDATE指令 . 263
6.18.3 RMAN的 RESTORE…PREVIEW指令.... 264
6.18.4 RMAN的 LIST指令..... 265
6.18.5 RMAN的 REPORT指令.... 268
6.19 本章小结 . 269
第 7章手工管理的备份恢复.. 270
7.1 备份恢复的概念 ... 270
7.1.1 物理备份 .. 270
7.1.2 逻辑备份 .. 271
7.1.3 冷备份与热备份 .. 271
7.1.4 数据库恢复 .... 271
7.2 非归档模式下的冷备与恢复 . 272
7.2.1 冷备的步骤 .... 273
7.2.2 冷备下的恢复  274
7.2.3 缺少重做日志文件的恢复方法 .. 276
7.3 归档模式与非归档模式 ... 278
7.3.1 设置数据库的归档模式 .. 278
7.3.2 设置归档进程相关参数 .. 280
7.3.3 管理归档文件和归档目录 .... 281
7.4 手工热备数据库的步骤 ... 284
7.5 热备过程中对数据库崩溃的处理方法 ... 287
7.6 热备的原理 ..... 289
7.7 备份控制文件 . 290
7.8 介质恢复的原理 ... 293
7.9 归档模式下的完全恢复 ... 298
7.9.1 数据文件在有备份情况下的恢复 .... 298
7.9.2 数据文件在无备份情况下的恢复 .... 301
7.9.3 系统表空间数据文件损坏的完全恢复 .. 303
7.9.4 当前 UNDO表空间损坏的完全恢复..... 304
7.9.5 非当前 UNDO表空间损坏的完全恢复. 306
7.10 何时使用不完全恢复 ..... 309
7.10.1 不完全恢复的场合 .. 309
7.10.2 不完全恢复的类型 .. 309
7.11 所有控制文件丢失的恢复方法 . 310
7.11.1 使用备份的控制文件 .... 310
7.11.2 重建控制文件 .... 313
7.12 本章小结 . 317
第 8章 Oracle闪回技术... 318
8.1 理解闪回级别 . 318
8.2 闪回数据库 ..... 319
8.2.1 闪回数据库概述 .. 319
8.2.2 启用闪回数据库 .. 320
8.2.3 关闭闪回数据库 .. 322
8.2.4 闪回数据库方法 .. 323
8.2.5 使用闪回数据库 .. 324
8.2.6 监控闪回数据库 .. 326
8.2.7 使用闪回数据库的限制 .. 328
8.3 闪回删除 ... 328
8.3.1 闪回删除原理  328
8.3.2 回收站的使用  329
8.3.3 恢复删除的表  332
8.3.4 恢复多个同名的表 .... 335
8.3.5 应用 Purge永久删除表... 337
8.4 闪回表 . 339
8.5 闪回版本查询 . 341
8.6 闪回事务查询 . 342
8.7 闪回查询 ... 343
8.8 复原点技术 ..... 344
8.9 本章小结 ... 345
第 9章数据迁移-EXP/IMP .... 347
9.1 关于备份的几个概念 . 347
9.2 使用 EXP指令实现逻辑备份 348
9.2.1 EXP指令详解 348
9.2.2 不带参数的 EXP 备份.... 350
9.2.3 EXP指令导出整个数据库.... 353
9.2.4 EXP指令导出特定的表.. 354
9.2.5 EXP指令导出指定的用户.... 355
9.2.6 EXP指令导出特定的表空间 356
9.3 使用 IMP指令实现逻辑恢复  357
9.3.1 IMP指令详解  358
9.3.2 IMP指令恢复整个数据库 .... 359
9.3.3 IMP指令恢复特定的表 .. 360
9.3.4 IMP指令恢复指定的用户 .... 361
9.4 使用 EXP/IMP实现传输表空间 . 363
9.4.1 理解 Big/Little Endian ..... 363
9.4.2 传输表空间的限制 .... 364
9.4.3 传输表空间的兼容性问题 .... 365
9.4.4 传输表空间的自包含特性 .... 365
9.4.5 实现传输表空间的步骤 .. 365
9.4.6 使用 EXP/IMP实现同平台表空间迁移  367
9.4.7 使用 EXP/IMP实现跨平台表空间迁移  370
9.5 本章小结 ... 374
第 10章数据迁移-EXPDP/IMPDP .... 375
10.1 数据泵导出（EXPDP）简介 .... 375
10.1.1 数据泵导入导出技术的结构 .... 375
10.1.2 数据泵导入导出技术的优点 .... 376
10.1.3 数据泵导入导出的目录对象 .... 376
10.2 数据泵导入导出与 EXP/IMP技术的区别 . 378
10.3 数据泵导出（EXPDP）数据库实例 .... 379
10.3.1 数据泵导出的参数含义  379
10.3.2 数据泵导出数据库实例  384
10.4 数据泵导入数据库实例 . 389
10.4.1 数据泵导入概述及参数含义 .... 389
10.4.2 数据泵导入数据库实例步骤 .... 396
10.5 使用数据泵迁移表空间 . 399
10.6 使用数据泵生成外部表 . 401
10.7 本章小结 . 403
第 11章基于 CBO的 SQL优化.. 404
11.1 性能调整方法 ..... 404
11.2 SQL查询处理过程详解. 405
11.2.1 语法分析  405
11.2.2 语句优化  405
11.2.3 查询执行  405
11.3 基于成本的优化 . 406
11.3.1 选择 CBO的优化方式.. 406
11.3.2 优化器工作过程  407
11.4 自动统计数据 ..... 408
11.5 手工统计数据库数据 ..... 409
11.6 统计操作系统数据 ... 413
11.7 手工统计字典数据 ... 415
11.8 主动优化 SQL语句.. 416
11.8.1 WHERE谓词的注意事项... 416
11.8.2 SQL语句优化工具.. 417
11.8.3 使用索引  425
11.8.4 索引类型及使用时机 .... 432
11.8.5 使用绑定变量 .... 438
11.8.6 消除子查询优化 SQL语句. 439
11.9 被动优化 SQL语句.. 441
11.9.1 使用分区表 .. 441
11.9.2 使用表和索引压缩 .. 442
11.9.3 保持 CBO的稳定性 442
11.9.4 创建合适的索引  446
11.10 详解 V$SQL视图... 446
11.11 本章小结 ..... 448
第 12章 Oracle数据库实例优化.. 449
12.1 详解 SGA与实例优化 ... 449
12.2 将程序常驻内存 . 454
12.2.1 创建软件包 DBMS_SHARED_POOL . 454
12.2.2 将程序常驻内存的过程  456
12.2.3 从 DBMSPOOL脚本理解软件包 DBMS_SHARED_POOL . 458
12.3 将数据常驻内存 . 460
12.3.1 再论数据块缓存池 .. 460
12.3.2 将数据常驻内存的过程  461
12.3.3 将常驻内存的程序恢复为默认缓冲池  464
12.4 优化重做日志缓冲区 ..... 465
12.4.1 深入理解重做日志缓冲区的工作机制  465
12.4.2 重做日志缓冲区相关的等待事件 .. 467
12.4.3 设置重做日志缓冲区大小 .. 469
12.5 优化共享池(Shared Pool) ..... 471
12.5.1 库高速缓存 .. 471
12.5.2 使用绑定变量 .... 471
12.5.3 调整参数 CURSOR_SHARING ..... 474
12.5.4 设置共享池的大小 .. 475
12.6 优化数据库高速缓存 ..... 476
12.6.1 调整数据库缓冲区大小  477
12.6.2 使用缓冲池 .. 478
12.7 优化 PGA内存 ... 480
12.8 本章小结 . 484
第 13章  Statspack与 AWR ... 485
13.1 Statspack安装..... 485
13.2 设置 Statspack相关参数 487
13.3 statspack数据收集.... 490
13.3.1 STATSPACK收集统计数据的原理 .... 490
13.3.2 创建性能数据报表 .. 492
13.3.3 自动收集性能报告 .. 494
13.4 初步分析 STATSPACK性能报告 .. 496
13.5 AWR是什么. 501
13.6 管理 AWR.....502
13.6.1 DBMS_WORKLOAD_REPOSITORY包的使用.. 503
13.6.2 AWR快照与 STATISTICS_LEVEL参数的关系. 504
13.6.3 手工创建 AWR快照..... 504
13.6.4 清除 AWR快照. 505
13.6.5 修改 AWR快照参数..... 506
13.6.6 创建和删除 AWR快照基线..... 506
13.6.7 创建 AWR报告. 508
13.7 ASH是 AWR的补充..... 511
13.8 创建并分析 ASH报告 ... 511
13.9 AWR与 ADDM的关系. 514
13.10 本章小结 ..... 519
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle DBA 高可用、备份恢复与性能优化
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8性能优化和管理手册
目 录
贺辞
序
译者序
前言
第一部分 管理数据库的规模、性能和紧急事件
第1章 管理数据库的规模、性能和紧急事件
1.1应用程序展开的螺旋周期
1.1.1阶段1：应用程序的初期使用
1.1.2阶段2：硬件升级和优化
1.1.3阶段3：重新展开
1.1.4阶段4：又一个重新展开
1.1.5主要重新展开
1.2规划应用程序展开的螺旋式周期
1.2.1降低危机水平
1.2.2管理资源需求
1.2.3管理硬件问题
1.2.4为未来做准备
第二部分 数据库增长的管理
第2章 数据库增长的规划
2.1增长配置文件
2.1.1事务相关表
2.1.2应用相关表
2.1.3商业事务处理表
2.1.4临时/接口表
2.2在规划中使用增长配置文件
第3章 内存和CPU 的优化调整问题
3.1应用的类型
3.1.1Oracl如何响应OLTP数据访问请求
3.1.2Orac le如何响应批数据访问请求
3.2如何计算命中率
3.3影响命中率的因素
3.3.1字典表活动
3.3.2临时段的活动
3.3.3回滚段的活动
3.3.4索引活动
3.3.5表扫描
3.3.6OLTP和批应用类型
3.4内存和CPU 的优化调整问题
3.5为应用选择目标命中率
3.6内存和CPU 的要求
第4章 硬件调整问题
4.1估计磁盘容量需要
4.1.1数据库内部空间
4.1.2Oracle使用的外部空间
4.1.3应用管理空间
4.1.4冗余/应急空间
4.2识别I/O瓶颈
4.3传统的硬件方法
4.3.1文件的独立
4.3.2数据分离
4.3.3使用分区
4.4如何使用RAID技术
4.4.1RAID如何工作
4.4.2什么时候使用数据分离
4.4.3什么时候使用镜像
4.4.4什么时候使用奇偶系统
4.4.5选择RAID配置
4.5裸设备和文件系统
4.6支持改变容量需求
第5章 管理数据库的内部空间
5.1数据表的类型
5.2管理区间
5.2.1Oracle如何分配区间
5.2.2考虑性能定区间的大小
5.3管理数据表
5.3.1高位标志
5.3.2在块的内部
5.3.3簇
5.4管理索引
5.5管理临时段
5.6管理回滚段
5.7管理自由空间
5.8存储参数参考资料
第6章 数据库关闭/启动工具
6.1删除或归档旧的跟踪文件和跟踪日志
6.2重新命名警报日志
6.3产生创建控制文件命令
6.4装订程序包
6.5创建拥有者－对象的位置图
6.6重新计算统计资料
6.7缩小扩展超过最佳值的回滚段
6.8执行关机/启动工具
第三部分 优化增长的数据库
第7章 性能管理
7.1从哪儿开始
7.1.1确保稳定协调的产品环境
7.1.2应用事务和查询分类
7.1.3着眼棘手的SQL
7.1.4调整特殊的长时间运行的进程和批作业
7.1.5优化对单个表的访问
7.2使用优化程序
7.2.1基于规则的优化程序
7.2.2基于开销的优化程序
7.2.3混合方法
7.2.4选择优化程序
7.2.5实现基于开销的优化程序
7.2.6添加的优化程序目标
7.3下一步往哪儿去
第8章 监控
8.1监控类型
8.2Oracle的性能统计数字问题
8.2.1值的范围
8.2.2准确性
8.2.3统计数字视图的性能
8.2.4命名
8.3收集统计数字
8.4解释统计数字
8.4.1查询处理
8.4.2事务管理
8.4.3内存和CPU的使用
8.4.4数据库管理
8.4.5用户统计数字
8.5企业管理器
8.6开发一个监控计划
第9章 环境的优化
9.1关键的init.ora参数
9.1.1DB BLOCK SIZE
9.1.2DB BLOCK BUFFERS
9.1.3SHARED POOLSIZE
9.1.4LOG BUFFER
9.1.5DBWR IO SLAVES
9.1.6 DB FILE MULTIBLOCK
READ COUNT
9.1.7 SORT －AREA －SIZE 和SORT AREA
RET AINED SIZE
9.1.8 SORT－DIRECT －WRITES
9.1.9 ROLLBACK SEGMENTS
9.2内存优化
9.2.1全部内存冲突
9.2.2设立共享内存
9.2.3设置信号灯
9.2.4管理内存交换
9.3I/O优化
9.3.1实现最优的灵活结构
9.3.2I/O分配
9.4CPU优化
9.5优化应用
第10章 解释SQL语句优化
10.1怎样为一个查询生成ExplainPlan
10.1.1解释操作次序
10.1.2在SQL*plus里自动产生解释方案
10.2操作
10.2.1在执行路径说明中使用的约定
10.2.2AND－ EQU AL
10.2.3BITMAPAND BITMAPOR和BITMAP MERGE
10.2.4BITMAPCONVERSION
10.2.5BITMAPINDEX
10.2.6CONCATENATION
10.2.7CONNECTBY
10.2.8COUNT
10.2.9COUNT STOPKEY
10.2.10FILTER
10.2.11FORUPDATE
10.2.12HASHJOIN
10.2.13INDEXRANGESCAN
10.2.14INDEX UNIQUE SCAN
10.2.15INTERSECTION
10.2.16MERGEJOIN
10.2.17MINUS
10.2.18NESTEDLOOPS
10.2.19OUTERJOIN
10.2.20PROJECTION
10.2.21REMOTE
10.2.22SEQUENCE
10.2.23SORTAGGREGATE
10.2.24SORTGROUP BY
10.2.25SORTJOIN
10.2.26SORTORDERBY
10.2.27SORT UNIQUE
10.2.28TABLEACCESSBYROWID
10.2.29TABLE ACCESSCLUSTER
10.2.30TABLEACCESSFULL
10.2.31TABLEACCESSHASH
10.2.32UNION
10.2.33VIEW
10.3解释ExplainPlan的输出
10.4应用查询调整到进程调整
10.5使用提示
10.5.1All ROWS
10.5.2AND －EQUAL
10.5.3APPENDandNOAPPEND
10.5.4CACHE
10.5.5CHOOSE
10.5.6CLUSTER
10.5.7FIRST ROWS
10.5.8FULL
10.5.9HASH
10.5.10HASH 　AJ
10.5.11INDEX
10.5.12INDEX ASC
10.5.13INDEX COMBINE
10.5.14INDEX DESC
10.5.15INDEX　FFS
10.5.16MERGE　AJ
10.5.17NO MERGE
10.5.18NOCACHE
10.5.19NOPARALLEL
10.5.20ORDER ED
10.5.21PARALLEL
10.5.22PUSH　SEBQ
10.5.23ROWID
10.5.24RULE
10.5.25STAR
10.5.26USE CONCAT
10.5.27USE HASH
10.5.28USE MERGE
10.5.29USE NL
第11章 13个SQL优化技巧
11.1避免无计划的全表扫描
11.1.1使用全表扫描
11.1.2怎样确保查询能使用索引
11.1.3创建索引时遇到的问题
11.2只使用选择性索引
11.2.1测量索引的选择性
11.2.2选择复合索引的主列
11.2.3在复合索引和多个单列索引间做选择
11.3管理多表联结（NESTEDLOOPS MERGE
JOIN s和 HASHJOINS）
11.3.1MERGEJOINS所涉及的步骤
11.3.2MERGEJOIN的优化含义
11.3.3怎样指定只供临时段使用的表空间
11.3.4涉及NESTEDLOOPS的步骤
11.3.5NESTEDLOOPS联结里驱动表的含义
11.3.6怎样改变联结路径
11.3.7从无选择性规则开始时会发生什么
11.3.8给联结增加更多表时会发生什么
11.3.9怎样索引有多对多关系的数据表
11.3.10哈希（散列）联结
11.3.11哈希（散列）联结的管理问题
11.3.12哈希（散列）联结的性能概述
11.3.13怎样改变数据库的设计以降低联结的数目
11.3.14管理联结
11.4管理包含视图的SQL语句
11.4.1提高视图到查询里的集成
11.4.2强制视图保持独立
11.5优化子查询
11.5.1当执行子查询时
11.5.2对返回最大值的子查询的提示
11.5.3如何组合子查询
11.5.4怎样进行存在检查
11.6使用复合的Keys/star 查询
11.6.1怎样创建星形图
11.6.2查询星形图
11.6.3传统的执行路径
11.6.4怎样创建星形查询执行路径
11.6.5星形查询的管理问题
11.7适当地索引CONNECTBY操作
11.8限制对远程表的访问
11.9管理对非常巨大的表的访问
11.9.1问题
11.9.2管理数据接近
11.9.3避免没有帮助的索引扫描
11.9.4创建充分索引的表
11.9.5创建哈希（散列）簇
11.9.6如果使用等价查询
11.9.7如果没有办法执行行接近
11.9.8如果空间分配不成问题
11.9.9创建分区表
11.9.10使用并行选项
11.10使用UNIONALL而不是UNION
11.11避免在SQL里使用PL/SQL功能调用
11.12管理赋值变量的使用
11.13回访优化过程
第四部分 先进的优化调整选项
第12章 并行选项
12.1并行选项的影响
12.2什么是选择项
12.3并行查询如何工作
12.3.1常规查询处理
12.3.2数据表扫描的并行查询处理
12.3.3排序的并行查询处理
12.4如何管理和优化调整并行查询选择项
12.4.1如何分配查询服务器进程
12.4.2如何管理查询服务器池
12.4.3在数据表层定义并行度
12.4.4使用查询提示强制并行
12.4.5如何监控并行查询选择
12.4.6了解解释方案输出
12.4.7调整并行操作
12.4.8Oracle如何确定并行度
12.4.9选择并行度的技巧
12.5附加的并行选项
12.5.1并行DML
12.5.2并行创建数据表
12.5.3并行创建索引
12.5.4并行数据加载
12.5.5并行恢复
12.5.6Oracle并行服务器
12.5.7在并行选项中选择
第13章 新的及改进的优化调整选项
13.1有关性能的变化
13.1.1直方图
13.1.2快速全索引扫描
13.1.3不可恢复和不记录的动作
13.1.4直接路径输出
13.1.5专用的临时表空间
13.1.6排序直接写
13.2对象管理的变化
13.2.1不限制最大区间数
13.2.2重新分配数据表和索引中未使用的空间
13.2.3重建快速索引
13.2.4位图索引
13.2.5用户指定的哈希簇
13.2.6分区
13.2.7存储的触发器
13.3数据库管理的变化
13.3.1可重定尺寸的数据文件
13.3.2可动态改变的init.ora参数
13.3.3表空间合并
13.3.4只读表空间
13.3.5缩小回滚段
13.3.6媒体恢复状态
13.3.7复制
13.3.8Oracle7.3补充的变化
13.3.9Oracle8补充的变化
13.3.10有关复制的问题
13.3.11多线程服务器
13.3.12延迟记录块的清除
13.3.13可伸缩的缓冲区高速缓存
13.3.14展开的RowID格式
13.3.15OID和REF产生器
13.4新的数据库管理实用程序
13.4.1TRACE
13.4.2DB VER IFY
第五部分 数据库管理的实际问题
第14章 Oracle数据库管理的实际问题
14.1问题的格式
14.2记录答案
14.3如果被难住了，怎么办
14.4通过的评分等级是什么
14.5时间限制
14.6问题
14.7问题答案表
第15章 实际问题分析
15.1回答实际问题的关键
15.2实际问题的一般分析
15.3参考资料
15.3.1综合参考资料
15.3.2备份与恢复
15.3.3资源管理
15.3.4维护与操作
15.3.5安全性
15.3.6调整与故障排除
15.3.7数据管理
15.3.8体系结构与选项
15.4问题分析

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8性能优化和管理手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8数据仓库分析、构建实用指南
目 录
贺辞
序
译者序
引言
前言
第1章 数据仓库概论
1.1特别糟糕的一天
1.2当前报表构架的问题所在
1.3目标：决策支持
1.4一个数据自动出纳机
1.5什么是数据仓库？
1.5.1面向主题
1.5.2完整性
1.5.3非易失性
1.5.4居于不同时间
1.6决策支持不同于事务处理
1.7数据仓库：一个肮脏的小秘密
1.8投资回报
1.9关于本书
第2章 需要考虑的问题
2.1不要轻信我们――应该客观点
2.2文章和书籍只包含观点，而不包含事实
2.3从商业需求开始――而不是技术
2.4哪些数据进入数据仓库？
2.5数据集市还是数据仓库？
2.6大笨钟与小迭代――开发阶段
2.7参照完整性（RI）永存
2.8查询工具――多多益善
2.9数据仓库的不同之处――开发者的观点
2.10数据仓库的不同之处――用户的观点
2.11授权用户
2.12Oracle数据仓库为什么独占鳌头
2.12.1全面解决方案
2.12.2OLAP和通用服务器
2.12.3一个仓储/多种解决方案
2.12.4现存的关系
2.13投资回报
第3章 组建开发团队
3.1数据仓库开发团队角色清单
3.2数据仓库工程所需要的角色
3.2.1数据仓库工程导演
3.2.2数据仓库工程经理
3.2.3数据准备专家/商务分析专家
3.2.4数据仓库工程师
3.2.5数据库管理员
3.2.6系统管理员
3.2.7数据迁移专家
3.2.8数据转换/整饰专家
3.2.9数据集市开发负责人
3.2.10质量保证/测试专家
3.2.11基础结构专家
3.2.12权威用户 （旧有系统专家）
3.2.13培训者
3.2.14技术书记员
3.2.15公共关系人员
3.2.16企业中的盟友
3.2.17桌面帮助功能设计人员
3.2.18工具专家
3.2.19经销商关系人
3.2.20Web大师
3.3顾问
第4章 数据仓库工程管理
4.1什么是工程管理？
4.2什么是一个工程
4.3工程范围说明书
4.4工作细目结构
4.5工程估算
4.6工程管理总结
第5章 数据仓库设计
5.1设计――下一逻辑步骤
5.2深入与用户交流
5.3数据仓库数据库与操作型数据库
5.4“规范的”操作型设计
5.4.1第一范式
5.4.2第二范式
5.4.3第三范式
5.5维数据仓库设计
5.6星型模式
5.6.1事实表
5.6.2维表
5.7粒度
5.8数据仓库设计方法与指南
5.8.1工程分析与计划
5.8.2高层设计
5.8.3中层设计
5.8.4低层设计
弟6章 数据集市
6.1数据集市
6.1.1独立数据集市
6.1.2维数据库
6.1.3影响设计的维
6.1.4下钻需求对设计的影响
6.2查询数据集市
6.2.1查询条件的类型
6.2.2聚集
6.3数据仓库与数据集市
6.4参照完整性
6.4.1主键
6.4.2外键
6.5最好的数据集市工具软件
6.6数据集市还是数据仓库？
第7章 物理数据仓库
7.1超大型数据库
7.1.1时机窗
7.1.2精心管理和填充超大型数据库
7.2民族语言支持（NLS）
7.2.1客户端民族语言支持
7.2.2服务器端民族语言支持
7.2.3初始化参数文件
7.3并行性
7.3.1大规模并行处理和对称式多处理
7.3.2并行查询
7.3.3并行化与数据仓库
7.3.4并行度
7.3.5在实例级设置并行查询
7.4 为基于代价的优化器收集统计信息
7.4.1SQL的Analyze命令
7.4.2粗估与计算的比较
7.4.3如何分析对象
7.4.4何时分析对象
7.4.5在何处查看统计数据
7.4.6过时的统计数据
7.4.7统计数据收集的一致性
7.5分割表空间
7.5.1系统支持的表空间
7.5.2应用表空间
7.5.3为用户指定表空间
7.6从理论到实践
7.6.1系统的逆规范化
7.6.2星型模式的实现
7.7双向模式存取方法
7.7.1双向模式的属主
7.7.2存取模式
7.7.3激活和挂起一个模式
7.7.4双向模式存取方法的威力
7.8物理实现核查清单
第8章 将数据移入数据仓库
8.1数据库对象
8.2SQL*Loader
8.2.1SQL*Loader的特征
8.2.2激活SQL*Loader
8.2.3SQL*Loader的输入和输出
8.2.4控制文件
8.2.5并行和直接装载
8.2.6抑制产生重演日志和恢复信息
8.3导入和导出
8.3.1操作方式
8.3.2操作方法
8.3.3导出
8.3.4导出程序的参数
8.3.5关于导出分区表的一点说明
8.3.6导出样例1
8.3.7导出样例2
8.3.8导出样例3
8.3.9导入
8.3.10导人程序的参数
8.3.11关于将数据导人分区的一点说明
8.3.12导人样例1
8.3.13导人样例2
8.3.14导人样例3
8.4使用Oracle企业管理器装载数据
8.5oracle数据集市套件
8.6基于引擎的工具
8.6.1ELT工具特性
8.6.2功能性测试
8.6.3数据量测试
8.7代码生成工具
8.7.1ETI*EXTRACT
8.7.2PrismSolutions公司的数据仓库软件
8.8Oracle透明网关
8.9在数据转换中运用网关技术
第9章 分区
9.1什么是分区选项
9.1.1分区表与未分区表的区别
9.1.2创建分区对象
9.1.3选择分区键
9.1.4行放置
9.2传统的分区
9.2.1分割
9.2.2分块
第10章 索引数据仓库
10.1索引哪些列
10.1.1考虑列的可选度
10.1.2考虑谓词中涉及的列
10.1.3数据仓库的独特性
10.2单列索引和复合索引
10.3Oracle8索引方法
10.3.1B树索引
10.3.2位图索引
10.4分区表索引
10.5索引组织化表
10.5.1定义索引组织化表
10.5.2索引组织化表的优点
10.5.3何处使用索引组织化表
10.6优化直方图
10.7主键索引
10.8优化索引创建过程
10.8.1建立索引时，抑制产生恢复信息
10.8.2快速索引重建
10.9索引的创建和维护指南
10.9.1装载数据，然后建立索引
10.9.2为索引的创建分配大的排序空间
10.9.3临时工作空间
10.9.4共享池和索引建立
10.9.5每个表中的索引数目
10.9.6明确地设置存储参数
10.9.7事务项参数
第11章 备份与恢复数据仓库
11.1备份
11.1.1提供保护机制防止错误
11.1.2数据备份能提供什么
11.1.3影响备份策略的因素
11.1.4最佳备份时机
11.1.5何时进行备份
11.1.6映像备份
11.1.7无人值守的24*7备份
11.1.8备份技术的发展趋势
11.2恢复
11.2.1恢复的种类
11.2.2用映像备份进行恢复
第12章 数据仓库安全
12.1安全策略
12.1.1工作站安全
12.1.2窥探
12.2安全
12.2.1查看数据仓库数据
12.2.2如何在数据仓库中进行权限管理
12.2.3在何处实现安全
12.3基于工具的安全
12.3.1表的访问
12.3.2商业域的访问
12.4Oracle8的口令安全
12.4.1帐号锁定
12.4.2口令生存期与口令到期
12.5数据库用户管理
12.6Oracle企业管理器与安全
12.6.1Users
12.6.2Roles
12.6.3Profiles
12.6.4OEM的威力
第13章 冗余独立磁盘阵列
13.1RAI D的产生与发展
13.1.1革新阶段
13.1.2 仿制阶段
13.1.3成熟阶段
13.1.4 巩固阶段
13.1.5商品化阶段
13.2为什么使用RAID
13.3RAID1――磁盘镜像
13.4RAID2――不可兼容
13.5RAID3――有奇偶校验位的数据分割
13.6RAID4――有奇偶校验位的数据分块
13.7RAID5――独立的磁盘访问、无
奇偶校验的磁盘瓶颈
13.8RAID――未来的选择，为什么每
一个数据仓库都需要它
第14章 用户对数据的获取
14.1查询工具的特性
14.1.1易于使用
14.1.2性能
14.1.3多数据源
14.1.4集中式管理
14.1.5数据安全性
14.1.6与Web的融合
14.1.7集成化分析
14.2使用SQL*Plus生成报表
14.3OracleDiscoverer
14.3.1OracleDiscoverer管理器
14.3.2Discoverer终端用户工具
14.4CognosImprom ptu
14.4.1定义到数据库的连接
14.4.2创建目录
14.4.3添加表
14.4.4定义所要求的连接
14.4.5创建文件夹结构
14.4.6增加参数配置文件
14.5从终端用户的角度看Impromptu
14.6总结
第15章 关系型OLAP与聚集导航器
15.1OLAP： 仅仅是四个单词吗？
15.1.1多维性
15.1.2钻取
15.1.3旋转或切片与切块
15.1.4多视图模式
15.1.5OLAP小结
15.2ROLAP与MOLAP
15.2.1多维数据库
15.2.2关系型数据库
15.2.3回到特洛伊：ROLAP与M0LAP
15.2.4ROLAP与MOLAP的和平共处
15.3为提高ROLAP的性能而对数据建模
15.4三种ROLAP
15.5结论
第16章 联机分析处理
16.1什么是MOLAP、ROLAP和DOLAP
16.2MOLAP还是ROLAP？
16.3我们为什么需要OLAP？
16.4OLAP工具
16.4.1OLAP工具的评估
16.4.2使用CognosTransformer建立OLAP模型
16.4.3Cognos的PoWerplay
16.5Oracle与OLAP的市场
第17章 OracleExpress方案
17.1为什么要用Express
17.2Express的优势
17.2.1Express适合数据仓库
17.2.2完全开放的连接
17.2.3标准的操作环境
17.2.4一步到位的方案
17.2.5与数据仓库的集成
17.3OracleEXpress服务器
17.3.1概述
17.3.2通信基础设施
17.4Express数据模型
17.4.1维
17.4.2变量
17.4.3公式
17.4.4关系
17.5使用OracleExpress服务器完成数据操作
17.6 Orac leExpress管理器
17.6.1创建数据库
17.6.2与现存数据库相关的操作
17.7Express DBA简介
17.7.1数据库
17.7.2 导人/导出
17.8Orac leExpress 对象
17.9Express对象之旅
17.10Oracle财政分析器
17.10.1与OracleGL的集成
17.10.2关键特性及功能
17.11Oracle销售分析程序
17.12关系型访问管理器
17.13OracleWeb代理
17.14Express Web应用程序的工作情况
第18章 数据挖掘
18.1什么是数据挖掘？
18.1.1发现
18.1.2关系
18.1.3模式
18.2数据挖掘带来的收益
18.2.1欺诈检测
18.2.2投资回报
18.2.3电子化方案的可伸缩性
18.3数据挖掘辅助决策
18.4数据挖掘技术
18.4.1神经网络
18.4.2关联发现
18.4.3分类
18.4.4分簇
18.4.5顺序发现
18.5数据挖掘方案核查表
18.5.1对Oracle数据库的直接访问
18.5.2可视化分析的能力
18.5.3吸收大量数据的能力
18.5.4对数据质量的敏感性
18.6数据挖掘的前景
第19章 数据仓库与万维网
19.1什么是Internet
19.2什么是WorldWideWeb
19.3Internet的飞速发展
19.4什么是Intranet
19.4.1Intranet的演化
19.4.2走近Intranet
19.4.3Intranet与安全
19.4.4Intranet的优势
19.4.5Intranet的劣势
19.4.6Intranet小结
第20章 数据仓库的协调
20.1共享池
20.1.1三个共享池参数
20.1.2确定这些参数的值
20.2有关协调的各种特性
20.2.1只读表空间
20.2.2临时表空间
20.2.3并行感知优化器
20.2.4读优先机制
20.2.5导出程序的直接路径存取选项
20.2.6Hash连接的处理
20.3主管程序
20.3.1生成参数配置文件
20.3.2指派参数配置文件
20.3.3改变参数配置文件并重新设置用户
20.4初始化参数文件
20.4.1参数项类型
20.4.2重要参数的描述
20.5使用不同的初始化参数文件启动Oracle
20.6OEM实例管理程序

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8数据仓库分析、构建实用指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 11g数据库最佳入门教程
第1章  数据库简介	1
1-1　Oracle 11g简介	1
1-1-1  Oracle 11g数据库产品版本	2
1-1-2  Oracle 11g数据库的基本概念	4
1-2  数据模型	6
1-2-1　层级式数据模型	8
1-2-2　网络式数据模型	9
1-2-3　关系数据模型	10
1-3　功能依赖性	11
1-4  规范化	12
1-5  实体-关系模型	16
1-5-1  实体-关系的表现方式	16
1-5-2  实体-关系模型的建立	17
1-5-3  实体-关系图的转换	20
1-6　Oracle数据库的应用	21
第2章 数据库的安装与管理工具	23
2-1　Oracle 11g数据库的软硬件需求	23
2-2　Oracle 11g数据库的安装	24
2-3　Oracle 11g数据库的测试	30
2-4　Oracle 11g数据库的管理工具	32
2-5　Oracle 11g数据库的内存架构	35
2-5-1  System Global Area（SGA）	36
2-5-2  Program Global Area（PGA）	37
第3章   数据库的管理	39
3-1　启动数据库	39
3-2　关闭数据库	45
3-3　设置数据库	48
3-4　建立数据库	53
3-5　删除数据库	60
第4章  表空间的管理	64
4-1　简介	64
4-2　创建表空间	65
4-3　修改表空间	66
4-3-1  修改表空间的记录属性	66
4-3-2  把表空间修改为离线状态	67
4-3-3  把表空间修改为连线状态	67
4-3-4  在表空间中添加数据文件	68
4-4　删除表空间	68
第5章  表的管理	71
5-1　概述	71
5-2　创建表（Create Table）	72
5-3　修改表（Alter Table）	73
5-4　截断表	75
5-5  查询用户拥有的对象数据	75
5-5-1　查询用户拥有表的说明（user_tables）	75
5-5-2　查询用户拥有的对象类型（user_objects）	76
5-5-3　查询用户拥有的表、视图（user_catalog）	77
5-6　添加表注释	78
5-7　重命名表	79
5-8  删除表	80
第6章  数据的操作与管理	81
6-1　简介	81
6-2　添加一条数据	82
6-3　使用系统日期函数	83
6-4　查询一条数据	84
6-5　使用默认值	84
6-5-1　默认值用于INSERT	84
6-5-2　默认值用于UPDATE	85
6-6　使用替代变量	85
6-7　使用To_Date函数	86
6-8　添加多条数据	87
6-9　修改数据	88
6-10　删除数据	89
6-11　使用事务机制	90
6-12　复制数据	93
第7章  E-R模型转换成关系表	95
7-1　简介	95
7-2　唯一键	95
7-3　主键	97
7-4　非空值	99
7-5　检查	100
7-6　外键	102
7-7　约束条件	106
7-7-1  启动约束条件	106
7-7-2　关闭约束条件	107
7-7-3  删除约束条件	107
7-7-4  验证外键约束条件	108
7-8　实践操作：将E-R模型转换成关系表	109
第8章  用户与权限的管理	122
8-1　简介	122
8-2　创建用户	122
8-3　修改用户	124
8-4　管理系统权限	125
8-4-1　授予权限	125
8-4-2　撤销权限	128
8-5　简化管理	129
8-6　授予对象权限	131
8-7　实践操作：用户权限的管理	134
第9章  生产管理系统实战	140
9-1  简介	140
9-2  说明基本需求	140
9-3  绘制公司组织图	141
9-4  创建数据库表及关系说明	141
9-5  列出表的字段	142
9-6  E-R模型关系说明	145
9-7　绘制关系结构图	146
9-8　设置用户权限	147
9-9  添加表数据	158
9-10　开发程序代码	165
9-11　创建生产管理系统验证	209
第10章  Schema对象的管理	224
10-1　数据库的对象	224
10-2　视图（View）	224
10-2-1  建立视图	224
10-2-2  修改视图	226
10-2-3  删除视图	226
10-2-4  内嵌视图	226
10-2-5  建立复杂视图	227
10-2-6  限制视图	227
10-2-7  验证视图	228
10-3　序列（Sequence）	229
10-3-1  建立序列	229
10-3-2  验证序列	230
10-3-3  使用序列	231
10-3-4  修改序列	232
10-3-5  删除序列	233
10-4　索引（Index）	233
10-4-1  建立索引	234
10-4-2  验证索引	234
10-4-3  转换索引	235
10-4-4  删除索引	236
10-5　同义字（Synonyms）	236
第11章  单行函数的应用	237
11-1　单行函数简介	237
11-2　数值的操作函数	238
11-3　字符的操作函数	239
11-4  日期的操作函数	239
11-5　其他操作函数	244
11-5-1  NVL函数的使用	245
11-5-2  NVL2函数的使用	245
11-5-3  NULLIF函数的使用	246
11-5-4  COALESCE函数的使用	246
11-5-5  CASE函数的使用	247
11-5-6  DECODE函数的使用	247
11-6  数据类型的转换	248
第12章  企业数据管理实战入门	250
12-1　使用SELECT语句	250
12-1-1　查询所有的字段	250
12-1-2　查询指定字段的数据	254
12-1-3　查询不同表下的数据	255
12-2　使用加减乘除运算	256
12-3　使用括号	257
12-4　使用字段别名	259
12-5　使用表格别名	260
12-6　使用连接运算符	260
12-7　使用Distinct关键词	261
12-8　使用Where条件子句	262
12-9　使用比较运算符	263
12-9-1  比较运算符BETWEEN…AND	264
12-9-2  比较运算符LIKE	264
12-10　使用逻辑运算符	265
12-10-1  逻辑运算符AND	265
12-10-2  逻辑运算符NOT	265
12-11　使用Order By子句	266
12-12　使用字符查询	270
12-13　使用Upper函数	270
12-14　使用字符串	271
12-15　使用Top-n查询	272
12-16　连接多个表	272
12-17　使用SQL:1999 Syntax连接表格	278
12-18　使用群组函数	284
12-18-1  查询平均薪资、最高薪资、最低薪资和薪资的总和	284
12-18-2　查询资历最深和资历最浅的员工到职日期	285
12-18-3　计算所有行的数目	285
12-18-4  计算佣金字段的行数目	285
12-18-5  计算佣金的平均数	286
12-18-6  计算佣金的平均数且包含NULL值	286
12-18-7  使用群组函数且搭配Group By子句	287
12-18-8　进行多字段排序	287
12-18-9　限制群组函数	289
12-18-10　群组函数嵌套群组函数	289
12-19　使用子查询功能	290
12-19-1  通过子查询包含多个条件	291
12-19-2　通过子查询包含群组函数	291
12-19-3　通过子查询响应Multiple Row	292
12-19-4　利用子查询新增数据	292
12-19-5　利用子查询修改数据	293
12-20　使用MERGE功能	294
12-21　使用WITH CHECK OPTION关键词	296
第13章  企业数据管理实战进阶	297
13-1  管理需求示例一	297
13-2  管理需求示例二	300
13-3  管理需求示例三	304
13-4  管理需求示例四	306
13-5  管理需求示例五	308
13-6  管理需求示例六	310
13-7  管理需求示例七	315
13-8  管理需求示例八	316
13-9  管理需求示例九	318
13-10  管理需求示例十	319
第14章  通过ASP和JSP程序访问Oracle 11g数据库	323
14-1　简介	323
14-2  设置ODBC	325
14-3　设置Web Server	329
14-3-1　设置默认网站的IP地址	330
14-3-2　设置虚拟目录	334
14-4　实践操作：ASP程序的开发	337
14-4-1　查询EMP数据	338
14-4-2　查询Depart数据	340
14-4-3　查询Probuy数据	342
14-4-4　查询Invoice数据	343
14-4-5　查询Customer数据	344
14-4-6　查询Delivery数据	346
14-4-7　查询Ord数据	347
14-4-8　查询Product数据	349
14-4-9　查询Stock数据	350
14-4-10　查询WIP数据	351
14-4-11　查询SalGrade数据	352
14-5　实践操作：JSP程序的开发	354
第15章  使用JSP开发生产管理系统	364
15-1　简介	364
15-2  网页基本设计	367
15-3  程序代码评析	373
15-3-1  index.html的源代码	373
15-3-2  index12.html的源代码	375
15-3-3  index01.html的源代码	375
15-3-4  index0.html的源代码	375
15-3-5  insert01.html的源代码	376
15-3-6  insert1.jsp的源代码	376
15-3-7  update01.html的源代码	378
15-3-8  update01.jsp的源代码	378
15-3-9  delete01.html的源代码	380
15-3-10  delete01.jsp的源代码	380
15-3-11  select01.html 的源代码	381
15-3-12  select01.jsp的源代码	381
第16章  Enterprise Manager实战入门	383
16-1　简介	383
16-2　管理Enterprise Manager	383
16-3　查看预警	387
16-4　编辑阈值	388
16-5　监听程序	390
16-6　管理主机	398
16-7　管理内存指导	401
16-8　管理初始化参数	403
第17章  Enterprise Manager 实战进阶	406
17-1　简介	406
17-2　数据库的关闭和启动	406
17-3　表空间的创建、编辑和删除	410
17-4　表的创建、编辑和删除	417
17-5　用户的创建、编辑和删除	424
附录A  下载Oracle 11g数据库	441
附录B  下载、安装与卸载 Oracle 11g客户端管理工具	444
附录C   Oracle SQL的常用命令语法	457
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 11g数据库最佳入门教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle PL/SQL宝典（第2版）
第1篇  PL/SQL简介
第1章  走进Oracle	2
1.1  数据库系统与数据模型	2
1.1.1  基本术语	2
1.1.2  数据库技术的发展	3
1.1.3  数据模型	5
1.2  数据库系统的体系结构	6
1.2.1  数据库系统的三级模式	6
1.2.2  数据库管理系统	7
1.2.3  数据库系统的工作流程	8
1.3  关系数据库的简单介绍	9
1.3.1  关系数据库的基本特性	10
1.3.2  关系数据库的设计规范	10
1.4  认识Oracle 11g R2	11
1.4.1  什么是Oracle 11g R2	11
1.4.2  Oracle的发展历程	12
1.4.3  Oracle 11g R2的新特性	13
1.5  小结	13
第2章  认识PL/SQL	14
2.1  SQL语言概述	14
2.2  什么是PL/SQL	19
2.3  PL/SQL在SQL*Plus中的使用	26
2.3.5  SQL*Plus删除命令	31
2.3.6  SQL*Plus清除缓冲区命令	32
2.3.7  SQL*Plus显示缓冲区内容命令	33
2.3.8  SQL*Plus保存命令	34
2.3.9  查询结果的格式化	36
2.3.10 注释的使用	43
2.3.11 在SQL*Plus中编辑语句	44
2.4  PL/SQL在SQL Developer中的使用	45
2.5  小结	47
第2篇  PL/SQL基础
第3章  数据表的基本操作	50
3.1  创建表	50
3.1.3  创建表实例	52
3.2  约束	54
3.2.1  约束的类型	55
3.2.2  创建一个带检查约束的表	55
3.2.3  创建一个带非空约束的表	56
3.2.4  创建一个带唯一约束的表	57
3.2.5  创建一个带外键约束的表	58
3.2.6  创建一个含多个约束的表	61
3.3  修改表	62
3.3.2  给表添加约束	65
3.3.3  删除表中的约束	66
3.4  删除表	67
3.5  重命名表	67
3.6  使用企业管理器操作表	67
3.6.1  启用企业管理器	68
3.6.2  使用企业管理器创建表	69
3.6.4  使用企业管理器删除表	74
3.7  小结	75
第4章  表中数据的基本操作	76
4.1  查询数据表	76
4.1.1  查询表中的数据	76
4.1.2  使用SQL Developer工具查询表中的数据	77
4.2  添加数据	79
4.2.1  添加操作的基本语法	79
4.2.2  直接向表中添加数据	80
4.2.3  数据中NULL值的处理	82
4.2.4  插入值是默认值的处理	84
4.2.5  插入值是唯一值的处理	85
4.2.6  使用INSERT...SELECT插入数据	86
4.2.7  使用SQL Developer工具添加数据	87
4.3  修改数据	88
4.3.1  修改操作的基本语法	88
4.3.2  使用UPDATE语句更新数据行	89
4.3.3  根据条件修改表中的数据	91
4.3.4  使用SQL Developer工具修改数据	91
4.4  删除数据	91
4.4.1  删除操作的基本语法	91
4.4.2  删除表中的数据	92
4.4.3  有关TRUNCATE的使用	92
4.4.4  使用SQL Developer工具删除数据	94
4.5  小结	94
第5章  数据的基本查询	95
5.1  查询语句的基础	95
5.1.1  查询语句语法	95
5.1.2  查询各关键词的顺序及功能	96
5.1.3  查询语句执行顺序	96
5.2  最容易理解的查询	97
5.2.1  增加实验数据	97
5.2.2  查询表中列的数据	99
5.2.3  查询所有列	101
5.2.4  去除查询结果中的重复记录	102
5.2.5  返回查询的部分数据	104
5.3  带条件的查询	104
5.3.1  单一的条件查询	105
5.3.2  查询中使用比较表达式	106
5.3.3  使用简单逻辑表达式	108
5.3.4  有关NULL值的判断	114
5.3.5  有关模糊查询	115
5.3.6  指定数据范围	120
5.3.7  如何限制检索数据范围	122
5.3.8  定义转义符	123
5.4  排序查询结果	125
5.4.1  基本排序	125
5.4.2  多列排序	129
5.5  PL/SQL中的运算符	131
5.5.1  算术运算符	132
5.5.2  比较运算符	132
5.5.3  逻辑运算符	132
5.5.4  字符串连接符	133
5.5.5  赋值运算符	133
5.5.6  运算符的优先级	133
5.6  查询中表达式的使用	134
5.6.1  使用连接符连接列	134
5.6.2  算术表达式的使用	136
5.7  小结	137
第6章  查询中函数的使用	138
6.1  常用的单行函数	138
6.1.1  字符处理函数	138
6.1.2  数值处理函数	143
6.1.3  日期处理函数	146
6.1.4  转换函数	149
6.1.5  替换NULL值函数	151
6.1.6  排除指定条件函数	152
6.2  聚合函数	152
6.2.1  聚合函数的种类	152
6.2.2  计数函数	153
6.2.3  求和函数	155
6.2.4  均值函数	156
6.2.5  最大值/最小值函数	158
6.2.6  统计函数	160
6.2.7  聚合函数的重值处理	161
6.3  分组查询	162
6.3.1  简单分组	162
6.3.2  多列分组	163
6.3.3  分组查询中NULL值的处理	164
6.3.4  汇总数据运算符	165
6.3.5  筛选分组结果	168
6.4  其他函数	170
6.4.1  返回登录名函数	170
6.4.2  返回SESSIONID和
LANGUAGE函数	170
6.4.3  数据匹配函数	171
6.5  小结	172
第7章  查询中特殊的转换函数	173
7.1  基本的转换函数	173
7.1.1  数据类型的自动转换	173
7.1.2  关于自动转换的注意事项	176
7.2  特殊的转换函数	177
7.3  变换函数	178
7.3.1  TRANSLATE函数	178
7.3.2  DECODE函数	180
7.4  小结	182
第8章  数据表的高级查询	183
8.1  理解什么是多表连接	183
8.1.1  什么是连接	183
8.1.2  连接的类型与实现	184
8.2  简单的多表查询	184
8.2.1  创建实例表	185
8.2.2  如何实现多表查询	186
8.2.3  指定连接条件	187
8.2.4  使用别名作为表名的简写	188
8.2.5  自连接表进行查询	189
8.3  表的连接查询	192
8.3.1  基本连接语法	193
8.3.2  内部连接	193
8.3.3  自然连接	196
8.3.4  外部连接	198
8.3.5  交叉连接	203
8.3.6  连接中空值问题	204
8.3.7  表的连接与聚合分析	206
8.4  集合运算	208
8.4.1  集合运算的种类	208
8.4.2  UNION的使用	208
8.4.3  有关多表的UNION操作	211
8.4.4  UNION与JOIN的区别	212
8.4.5  MINUS与INTERSECT的使用	213
8.5  子查询的使用	217
8.5.1  认识子查询	217
8.5.2  非相关子查询与相关子查询	217
8.5.3  子查询的组成	219
8.5.4  子查询的使用方式及限制	220
8.6  在子查询中使用各种限制条件	220
8.6.1  比较运算符引入子查询	221
8.6.2  子查询中的聚合函数	223
8.6.3  在子查询中使用IN	224
8.7  在子查询中使用EXISTS	227
8.7.1  使用EXISTS的子查询	228
8.7.2  EXISTS子查询的使用	229
8.7.3  使用EXISTS子查询检查表中的重复行	230
8.8  子查询的其他应用	231
8.8.1  在子查询中使用ROWNUM关键词	231
8.8.2  在SELECT子句中使用子查询	234
8.8.3  在HAVING子句中使用子查询	235
8.8.4  在数据操纵语言（DML）中使用子查询	236
8.9  小结	238
第3篇  PL/SQL高级技术
第9章  索引和视图的使用	240
9.1  索引及其操作	240
9.1.1  什么是索引	240
9.1.2  索引的种类及语法	240
9.1.3  索引的创建	241
9.1.4  创建索引的注意事项	246
9.1.5  索引的管理	246
9.2  视图及其应用	250
9.2.1  什么是视图	250
9.2.2  视图的作用	251
9.3  创建视图	251
9.3.1  视图的语法	251
9.3.2  创建单表视图	252
9.3.3  创建多表视图	253
9.3.4  视图的视图	254
9.3.5  无源表视图	255
9.3.6  设置视图只读	255
9.3.7  设置视图的检查约束	257
9.3.8  内嵌视图的使用	259
9.3.9  查询视图的定义和相关信息	259
9.4  修改、删除视图	260
9.4.1  修改视图内容	260
9.4.2  删除视图	261
9.5  小结	262
第10章  序列	263
10.1  创建序列	263
10.2  使用序列	265
10.3  序列属性	269
10.3.1  创建序列的注意事项	269
10.3.2  指定序列的初始值	269
10.3.3  序列的最大值和最小值	270
10.3.4  序列的步长	271
10.3.5  序列的循环取值	272
10.3.6  序列的缓存大小	273
10.4  小结	274
第11章  数据类型、流程控制和游标	275
11.1  PL/SQL数据类型	275
11.1.1  标量类型	275
11.1.2  复合类型	276
11.2  变量和常量	284
11.2.1  变量的声明语法	284
11.2.2  常量的声明语法	285
11.3  程序流控制语句	285
11.3.1  IF...ELSE条件选择结构	286
11.3.2  CASE条件控制语句	291
11.3.3  LOOP循环控制语句	295
11.4  游标	300
11.4.1  游标的概念	301
11.4.2  显式游标的定义和操作	302
11.4.3  显式游标的属性	306
11.4.4  隐式游标	308
11.5  小结	311
第12章  存储过程、函数	312
12.1  理解存储过程	312
12.1.1  认识存储过程	312
12.1.2  存储过程的优点	312
12.1.3  存储过程的语法	313
12.2  存储过程的创建和执行	313
12.2.1  存储过程的执行	313
12.2.2  创建无参数的存储过程	314
12.2.3  带有输入参数的存储过程	318
12.2.4  带有输出参数的存储过程	321
12.3  存储过程的管理	323
12.3.1  查看存储过程	323
12.3.2  查看存储过程的错误	324
12.3.3  修改存储过程	326
12.3.4  存储过程的重新编译	326
12.3.5  删除存储过程	327
12.4  函数	327
12.4.1  函数的组成和语法	327
12.4.2  创建无参数函数	328
12.4.3  创建有参数函数	330
12.4.4  查看函数	335
12.4.5  修改函数	336
12.4.6  重新编译函数	337
12.4.7  删除函数	338
12.5  小结	338
第13章  程序包	339
13.1  程序包简介	339
13.2  构建程序包的规则	339
13.2.1  程序包规范	339
13.2.2  程序包主体	341
13.3  调用程序包中的函数/存储过程	343
13.4  删除程序包	343
13.5  小结	344
第14章  触发器	345
14.1  触发器的基本概念	345
14.1.1  触发器简介	345
14.1.2  触发器的类型	345
14.1.3  触发器的作用及使用	346
14.1.4  触发器的执行环境	346
14.2  触发器的创建和使用	347
14.2.1  触发器的语法和组成	347
14.2.2  创建DML触发器	349
14.2.3  替代类型触发器	360
14.2.4  复合类型触发器	362
14.2.5  DDL类型触发器	364
14.3  触发器管理	366
14.3.1  查看触发器	366
14.3.2  修改触发器	367
14.3.3  删除触发器	369
14.4  小结	370
第15章  异常处理	371
15.1  理解异常	371
15.1.1  异常的分类	371
15.1.2  异常的结构	372
15.2  异常的应用	372
15.2.1  预定义异常	373
15.2.2  非预定义异常	377
15.2.3  自定义异常	379
15.3  小结	380
第16章  事务和锁	381
16.1  事务控制的基本概念	381
16.1.1  事务控制的必要性	381
16.1.2  事务的ACID特性及实现	382
16.1.3  事务的状态	382
16.1.4  PL/SQL中事务的执行	383
16.2  PL/SQL中事务的实现	384
16.2.1  事务的类型	384
16.2.2  提交事务	385
16.2.3  设置事务的保存点	387
16.3  并发控制及其实现	388
16.3.1  并发访问的常见问题	389
16.3.2  什么是锁	390
16.3.3  锁的分类	390
16.3.4  事务隔离级别	392
16.3.5  事务阻塞及其解决方法	394
16.3.6  死锁	396
16.4  小结	398
第17章  安全管理	399
17.1  用户管理	399
17.1.1  什么是用户	399
17.1.2  创建用户	399
17.1.3  修改用户	405
17.1.4  删除用户	407
17.2  权限管理	409
17.2.1  授予权限	409
17.2.2  权限回收	413
17.2.3  查看权限	415
17.3  角色管理	416
17.3.1  理解角色	416
17.3.2  创建角色	417
17.3.3  角色的管理设置	419
17.3.4  修改、删除角色	420
17.4  概要文件（PROFILE）	421
17.4.1  理解概要文件	421
17.4.2  创建概要文件	421
17.4.3  修改、删除概要文件	424
17.4.4  查询概要文件	425
17.5  小结	426
第18章  动态SQL和动态PL/SQL	427
18.1  动态SQL	427
18.1.1  EXECUTE IMMEDIATE语句	427
18.1.2  OPEN FOR语句	428
18.1.3  4种动态SQL方法	429
18.2  动态PL/SQL	431
18.3  小结	431
第19章  管理PL/SQL代码	432
19.1  管理数据库中的代码	432
19.1.1  数据字典视图概述	432
19.1.2  显示存储对象的信息	433
19.1.3  源代码的显示和搜索	434
19.1.4  通过数据字典视图查看编译器属性	434
19.1.5  通过视图分析和更改触发器的状态	436
19.1.6  分析参数信息	437
19.2  依赖关系的管理和代码的重编译	437
19.2.1  通过数据字典视图查看依赖关系	437
19.2.2  失效的程序单元的重编译	438
19.3  编译时警告	439
19.4  PL/SQL程序的执行和调试	441
19.4.1  PL/SQL程序的执行	441
19.4.2  PL/SQL程序的调试	442
19.4.3  调试技巧和策略	442
19.5  I/O操作与PL/SQL	446
19.5.1  显示信息	446
19.5.2  启用DBMS_OUTPUT	446
19.6  应用安全与PL/SQL	448
19.7  小结	449
第20章  PL/SQL语句优化	450
20.1  一般的SQL技巧	450
20.1.1  在查询中尽量不使用“*”	450
20.1.2  多表查询时多使用别名	450
20.1.3  条件查询多使用WHERE	451
20.1.4  计算时不用索引列	451
20.1.5  指定查询范围时多使用IN	452
20.1.6  使用TRUNCATE清空表中记录	453
20.1.7  及时提交事务	453
20.1.8  DECODE函数的使用	454
20.1.9  多使用EXISTS语句判断条件	455
20.1.10 其他技巧	455
20.2  Oracle优化器	456
20.2.1  Oracle优化器的分类	456
20.2.2  Oracle优化器的模式	457
20.2.3  查看Oracle执行计划	457
20.3  SQL性能指导	458
20.3.1  ADDM	458
20.3.2  SQL访问指导	458
20.3.3  SQL优化指导	462
20.4  小结	462
第21章  备份与恢复	463
21.1  备份与恢复简介	463
21.1.1  备份	463
21.1.2  恢复	463
21.2  逻辑备份与恢复	463
21.2.1  使用expdp和impdp工具进行逻辑备份与恢复	463
21.2.2  使用OEM进行逻辑备份与恢复	466
21.3  脱机备份与恢复	475
21.3.1  脱机备份	475
21.3.2  脱机恢复	476
21.4  联机备份与恢复	476
21.4.1  使用RMAN管理备份与恢复	477
21.4.2  恢复	479
21.5  小结	482
第4篇  Oracle应用开发
第22章  在.NET中连接Oracle数据库	484
22.1  ADO.NET概述	484
22.1.1  什么是ADO.NET	484
22.1.2  ADO.NET中的对象	484
22.2  使用绑定的方式连接Oracle数据库	485
22.2.1  数据控件概述	485
22.2.2  使用DataGridView控件绑定Oracle数据库	486
22.3  使用代码的方式连接Oracle数据库	492
22.3.1  使用Command对象操作Oracle数据库	492
22.3.2  使用DataSet对象存储查询结果	494
22.3.3  商品信息存储实例	495
22.4  小结	499
第23章  在Java中连接Oracle数据库	500
23.1  JDBC与ODBC简介	500
23.1.1  什么是JDBC	500
23.1.2  什么是ODBC	501
23.2  使用Thin方式连接Oracle数据库	502
23.3  使用JDBC-ODBC桥连接Oracle数据库	510
23.3.1  配置ODBC数据源	510
23.3.2  连接Oracle数据库	513
23.4  小结	513
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle PL/SQL宝典（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>多核应用编程实战
第1章　硬件、进程和线程　　1
1.1 　计算机的内部结构　　1
1.2 　多核处理器的缘起　　3
1.2.1 　在单芯片上支持多线程　　4
1.2.2 　通过处理器核心流水线作业提高指令发出率　　8
1.2.3 　使用缓存保存最近使用的数据　　10
1.2.4 　用虚拟内存存储数据　　12
1.2.5 　从虚拟地址转换到物理地址　　13
1.3 　多处理器系统的特征　　14
1.4 　源代码到汇编语言的转换　　16
1.4.1 　32位与64位代码的性能　　18
1.4.2 　确保内存操作的正确顺序　　19
1.4.3 　进程和线程的差异　　21
1.5 　小结　　23
第2章　高性能编码　　24
2.1 　定义性能　　24
2.2 　了解算法复杂度　　25
2.2.1 　算法复杂度的示例　　26
2.2.2 　算法复杂度的重要性　　28
2.2.3 　谨慎运用算法复杂度　　30
2.3 　结构如何影响性能　　30
2.3.1 　在源代码和生成结构上权衡性能和便利性　　30
2.3.2 　利用库结构化应用程序　　33
2.3.3 　数据结构对性能的影响　　42
2.4 　编译器的作用　　47
2.4.1 　两种编译器优化　　48
2.4.2 　选择合适的编译器选项　　50
2.4.3 　如何用跨文件优化提高性能　　51
2.4.4 　使用配置文件反馈　　53
2.4.5 　潜在的指针别名会如何抑制编译器优化　　55
2.5 　通过分析确定占用时间的地方　　58
2.6 　怎样避免手动优化　　64
2.7 　从设计角度看性能　　64
2.8 　小结　　65
第3章　识别并行机会　　66
3.1 　使用多进程提高系统工作效率　　66
3.2 　多用户使用一个系统　　67
3.3 　通过整合提高机器工作效率　　68
3.3.1 　用容器隔离共享一个系统的应用程序　　69
3.3.2 　使用虚拟机监控程序托管多个操作系统　　69
3.4 　采用并行机制提高单个任务的性能　　71
3.4.1 　理解并行应用程序　　72
3.4.2 　并行如何影响算法的选择　　72
3.4.3 　Amdahl定律　　73
3.4.4 　确定最大实际线程数　　75
3.4.5 　同步成本怎样降低扩展性　　76
3.5 　并行模式　　78
3.5.1 　使用SIMD指令的数据并行　　78
3.5.2 　通过进程或线程实现并行化　　79
3.5.3 　多个独立任务　　79
3.5.4 　多个松散耦合的任务　　80
3.5.5 　相同任务的多个副本　　81
3.5.6 　单个任务拆分到多个线程　　82
3.5.7 　使用流水线任务完成某个事项　　82
3.5.8 　将工作分配给客户端和服务器　　83
3.5.9 　将责任划分给生产者和消费者　　84
3.5.10 　结合多种并行化策略　　85
3.6 　依赖关系对并行运行代码能力的影响　　85
3.6.1 　反依赖和输出依赖　　86
3.6.2 　通过推测打破依赖　　88
3.6.3 　关键路径　　91
3.7 　发现并行机会　　92
3.8 　小结　　93
第4章　同步和数据共享　　94
4.1 　数据争用　　94
4.1.1 　使用工具检测数据争用　　95
4.1.2 　避免数据争用　　98
4.2 　同步原语　　98
4.2.1 　互斥量和临界区　　98
4.2.2 　自旋锁　　99
4.2.3 　信号量　　100
4.2.4 　读写锁　　100
4.2.5 　屏障　　101
4.2.6 　原子操作和无锁代码　　102
4.3 　死锁和活锁　　103
4.4 　线程和进程间的通信　　104
4.4.1 　内存、共享内存和内存映射文件　　104
4.4.2 　条件变量　　105
4.4.3 　信号和事件　　107
4.4.4 　消息队列　　108
4.4.5 　命名管道　　108
4.4.6 　通过网络栈进行通信　　109
4.4.7 　线程之间共享数据的其他方法　　110
4.5 　存储线程私有数据　　110
4.6 　小结　　112
第5章　使用POSIX线程　　113
5.1 　创建线程　　113
5.1.1 　线程终止　　114
5.1.2 　用子线程接收和传递数据　　115
5.1.3 　分离线程　　116
5.1.4 　设置pthread的属性　　117
5.2 　编译多线程代码　　119
5.3 　进程终止　　121
5.4 　线程之间共享数据　　122
5.4.1 　使用互斥锁保护访问　　122
5.4.2 　互斥锁属性　　124
5.4.3 　使用自旋锁　　125
5.4.4 　读写锁　　127
5.4.5 　屏障　　129
5.4.6 　信号量　　130
5.4.7 　条件变量　　136
5.5 　变量和内存　　140
5.6 　多进程编程　　143
5.6.1 　在进程之间共享内存　　144
5.6.2 　在进程之间共享信号量　　147
5.6.3 　消息队列　　147
5.6.4 　管道和命名管道　　150
5.6.5 　使用信号与进程通信　　151
5.7 　套接字　　156
5.8 　可重入代码和编译器标志　　158
5.9 　小结　　160
第6章　Windows线程　　161
6.1 　创建Windows本机线程　　161
6.1.1 　终止线程　　165
6.1.2 　创建和重新启动挂起的线程　　167
6.1.3 　使用内核资源的句柄　　168
6.2 　同步和资源共享的方式　　168
6.2.1 　线程间需要同步的一个例子　　169
6.2.2 　保护对临界区代码的访问　　170
6.2.3 　用互斥量保护代码段　　172
6.2.4 　轻量级读写锁　　173
6.2.5 　信号量　　175
6.2.6 　条件变量　　177
6.2.7 　向其他线程或进程发出事件完成的信号　　178
6.3 　Windows中的宽字符串处理　　179
6.4 　创建进程　　180
6.4.1 　在进程之间共享内存　　182
6.4.2 　在子进程中继承句柄　　185
6.4.3 　互斥量命名及其在进程间的共享　　186
6.4.4 　用管道通信　　187
6.4.5 　用套接字进行通信　　190
6.5 　变量的原子更新　　193
6.6 　分配线程本地存储　　195
6.7 　设置线程的优先级　　197
6.8 　小结　　198
第7章　自动并行化和OpenMP　　199
7.1 　使用自动并行化产生并行代码　　199
7.1.1 　识别和并行约简　　203
7.1.2 　对包含调用的代码进行自动并行化　　204
7.1.3 　协助编译器实现代码的自动并行化　　206
7.2 　使用OpenMP生成并行应用程序　　208
7.2.1 　使用OpenMP并行化循环　　209
7.2.2 　OpenMP应用程序的运行时行为　　210
7.2.3 　OpenMP并行区域中的变量作用域　　210
7.2.4 　使用OpenMP并行化约简　　212
7.2.5 　在并行区域外访问私有数据　　212
7.2.6 　使用调度改进工作分配　　214
7.2.7 　用并行段完成独立工作　　217
7.2.8 　嵌套并行　　218
7.2.9 　使用OpenMP动态定义并行任务　　219
7.2.10 　保持数据对线程私有　　223
7.2.11 　控制OpenMP运行时环境　　225
7.2.12 　等待工作完成　　227
7.2.13 　限制执行代码区域的线程　　229
7.3 　确保并行区域的代码按顺序执行　　232
7.4 　折叠循环改进工作负荷均衡　　233
7.5 　强制实现内存一致性　　234
7.6 　并行化示例　　235
7.7 　小结　　239
第8章　手工编码的同步和共享　　240
8.1 　原子操作　　240
8.1.1 　用比较和交换指令构成更复杂的原子操作　　242
8.1.2 　强制实现内存排序以确保正确操作　　245
8.1.3 　编译器对内存排序指令的支持　　247
8.1.4 　编译器对操作的重新排序　　247
8.1.5 　易失变量　　251
8.2 　操作系统提供的原子操作　　251
8.3 　无锁算法　　254
8.3.1 　Dekker算法　　254
8.3.2 　带循环缓存的生产者/消费者　　256
8.3.3 　扩展到多个消费者或生产者　　259
8.3.4 　将生产者/消费者扩展到多个线程　　260
8.3.5 　更改生产者/消费者代码为使用原子操作　　266
8.3.6 　ABA问题　　268
8.4 　小结　　271
第9章　基于多核处理器的扩展　　272
9.1 　对应用程序扩展的限制　　272
9.1.1 　串行代码对性能的限制　　272
9.1.2 　超线性扩展　　275
9.1.3 　工作负荷不均衡　　276
9.1.4 　热锁　　277
9.1.5 　库代码扩展　　282
9.1.6 　工作量不足　　284
9.1.7 　算法限制　　286
9.2 　扩展的硬件限制　　288
9.2.1 　核心之间的带宽共享　　288
9.2.2 　伪共享　　290
9.2.3 　缓存冲突和容量　　293
9.2.4 　流水线资源匮乏　　297
9.3 　操作系统对扩展性的限制　　301
9.3.1 　过度订阅　　301
9.3.2 　使用处理器绑定改善内存局部性　　303
9.3.3 　优先级反转　　310
9.4 　多核处理器和扩展　　310
9.5 　小结　　311
第10章　其他并行技术　　312
10.1 　基于GPU的运算　　312
10.2 　语言扩展　　314
10.2.1 　线程构建模块　　314
10.2.2 　Cilk++　　317
10.2.3 　Grand Central Dispatch　　320
10.2.4 　为未来C和C++标准提议的可能功能　　321
10.2.5 　微软的C++/CLI　　324
10.3 　其他语言　　325
10.4 　集群技术　　327
10.4.1 　MPI　　328
10.4.2 　以MapReduce作为扩展策略　　331
10.4.3 　网格　　332
10.5 　事务性内存　　332
10.6 　向量化　　333
10.7 　小结　　334
第11章　结束语　　335
11.1 　编写并行应用程序　　335
11.1.1 　识别任务　　335
11.1.2 　估算性能提升　　336
11.1.3 　确定依赖关系　　336
11.1.4 　数据争用和互斥锁扩展限制　　336
11.1.5 　锁的粒度　　337
11.2 　多核处理器上的并行代码　　337
11.3 　并行化的未来　　339
参考文献　　340
索引　　342

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>多核应用编程实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>OCP
简介
第一章 Oracle 10g的安装和升级
第二章 移动数据和管理Scheduler
第三章 自动管理
第四章 常用存储管理
第五章 自动存储管理
第六章 性能和应用程序调整
第七章 备份、恢复和高可用性
第八章 安全性和SQL功能的增强
附录A SQL*Plus的增强功能
附录B 新增的和过时的初始化参数
附录C PL/SQL功能的增强和新的程序包
词汇表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>OCP
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Discoverer 手册
第一部分
Discoverer

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Discoverer 手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle WebDB实用大全
译者序
前言
致谢
第一部分 简介
第一章 WebDB简介
1.1 为什么要有WebDB

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle WebDB实用大全
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 9i从基础到应用
第1章 Oracle9i数据库的安装与卸载
第2章 Oracle9i结构简介
第3章 设计规划和创建数据库
第4章 创建和管理数据库对象
第5章 Oracle9i的安全管理
第6章 数据库备份和恢复
第7章 Oracle9i SQL*Plus
第8章 PL/SQL简介
附录1 
附录2
附录3
附录4
附录5
参考书目
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 9i从基础到应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库性能优化实践指南
第1部分　性能优化是怎么回事儿
第1章　了解性能优化	2
1.1　性能优化包括几个方面	2
1.1.1　性能计划	2
1.1.2　实例优化	2
1.1.3　SQL优化	4
1.2　哪些工具和特性可以帮助进行性能优化	5
1.2.1　自动性能调优特性	5
1.2.2　其他Oracle数据库工具	6
第2部分　性能优化的通用方法
第2章性能优化的通用方法	8
2.1　Oracle性能提升方法	8
2.1.1　Oracle性能提升方法的步骤	9
2.1.2　性能概念建模的决策过程	10
2.1.3　Oracle系统中最常发生的十大错误	11
2.2　紧急情况下的性能提升方法	12
第3部分　性能优化三件事之一：设计者如何优化设计和开发
第3章性能优化从设计和开发开始	16
3.1　Oracle方法论	16
3.2　理解投资选项	16
3.3　理解延展性	17
3.3.1　什么是延展性	17
3.3.2　系统延展性	17
3.3.3　阻碍延展性的因素	18
3.4　系统架构	19
3.4.1　硬件和软件组件	19
3.4.2　为需求配置匹配的系统架构	22
3.5　应用程序设计原理	24
3.5.1　简单的应用程序设计	24
3.5.2　数据建模	24
3.5.3　表和索引设计	25
3.5.4　使用视图	27
3.5.5　SQL执行效率	27
3.5.6　应用程序的实现	28
3.5.7　应用程序开发的趋势	29
3.5.8　负载测试、建模和实现	30
3.5.9　部署新的应用程序	32
第4部分　性能优化三件事之二：DBA如何合理使用资源而改善实例性能
第4章　资源有哪些	36
4.1　配置和使用内存	36
4.1.1　理解内存分配	36
4.1.2　配置和使用缓存	40
4.1.3　配置及使用共享池和大池	49
4.1.4　配置和使用重做日志缓存	68
4.1.5　PGA内存管理	70
4.1.6　管理服务器和客户端结果缓冲	82
4.2　I/O的配置和设计	92
4.2.1　关于I/O	92
4.2.2　I/O配置	93
4.2.3　数据库的I/O校准	100
4.2.4　使用Oracle Orion校准工具进行I/O校准	102
4.3　管理操作系统资源	113
4.3.1　理解操作系统性能问题	113
4.3.2　解决操作系统问题	116
4.3.3　理解CPU	117
4.3.4　解决CPU的问题	118
第5章配置数据库如何使用资源	123
5.1　初始实例配置时的性能考虑	123
5.1.1　初始化参数	123
5.1.2　撤销（undo）空间的配置	124
5.1.3　指定重做日志文件的大小	125
5.1.4　创建后续的表空间	125
5.2　创建表和维护表时的性能考虑	126
5.2.1　表压缩	126
5.2.2　回收不用的空间	127
5.2.3　创建数据索引	127
5.3　共享服务器的性能考虑	128
5.3.1　使用与分配器相关的视图识别争用	128
5.3.2　识别共享服务器的争用	129
第6章　统计资源使用的效果	131
6.1　数据收集概览	131
6.1.1　数据库统计信息	132
6.1.2　操作系统统计信息	134
6.1.3　解释统计信息	136
6.2　AWR概览	137
6.2.1　快照	138
6.2.2　基线	138
6.3　AWR管理	141
6.3.1　管理快照	141
6.3.2　管理基线	143
6.3.3　管理基线模板	145
6.3.4　转移AWR数据	147
6.3.5　使用AWR视图	149
6.3.6　生成AWR报告	150
6.3.7　生成AWR时间段比较报告	155
6.3.8　生成活动会话历史报告	161
6.3.9　使用活动会话历史报告	165
第7章　实例优化：更合理地使用资源	169
7.1　自动化的性能诊断	169
7.1.1　自动数据库诊断监视器（ADDM）概览	169
7.1.2　设置ADDM	173
7.1.3　使用ADDM诊断数据库性能问题	173
7.1.4　查看ADDM信息	176
7.2　使用性能视图进行实例调优	176
7.2.1　实例调优步骤	177
7.2.2　解释Oracle数据库统计信息	185
7.2.3　等待事件统计信息	191
7.2.4　实时SQL监控	211
7.2.5　优化实例的恢复性能：快速启动错误恢复	215
第5部分　性能优化三件事之三：开发人员如何优化SQL执行计划
第8章　好的数据结构产生好的执行计划：索引和簇	224
8.1　理解索引的性能	224
8.1.1　优化逻辑结构	225
8.1.2　使用SQL Access Advisor优化索引	225
8.1.3　为索引选择列和表达式	225
8.1.4　选择混合索引	226
8.1.5　书写使用索引的语句	227
8.1.6　书写避免使用索引的语句	227
8.1.7　重建索引	228
8.1.8　精简索引	228
8.1.9　使用非唯一索引实现唯一性	228
8.1.10　使用启用的非验证性约束	229
8.2　为性能而使用基于函数的索引	230
8.3　为性能而使用分区索引	230
8.4　为性能而使用索引组织表	231
8.5　为性能而使用位图索引	231
8.6　为性能而使用位图连接索引	232
8.7　为性能而使用域索引	232
8.8　为性能而使用表簇	232
8.9　为性能而使用哈希簇	233
第9章　执行计划	235
9.1　查询优化器统计信息：选择执行计划的依据	235
9.1.1　查询优化器统计信息概览	235
9.1.2　管理“自动查询优化器统计信息收集”	236
9.1.3　手工收集统计信息	239
9.1.4　系统统计信息	244
9.1.5　管理统计信息	247
9.1.6　控制动态统计信息	255
9.1.7　查看统计信息	259
9.2　查询优化器：选择执行计划	262
9.2.1　查询优化器概览	262
9.2.2　查询优化器访问路径概览	274
9.2.3　连接概览	282
9.2.4　读懂执行计划	292
9.2.5　控制查询优化器的行为	294
9.3　解释计划：显示执行计划	297
9.3.1　理解EXPLAIN PLAN	297
9.3.2　PLAN_TABLE输出表	300
9.3.3　运行EXPLAIN PLAN	300
9.3.4　显示PLAN_TABLE的输出	301
9.3.5　阅读EXPLAIN PLAN的输出	302
9.3.6　使用EXPLAIN PLAN查看并行执行	303
9.3.7　使用EXPLAIN PLAN查看位图索引	306
9.3.8　使用EXPLAIN PLAN查看结果缓冲	307
9.3.9　使用EXPLAIN PLAN查看分区对象	307
9.3.10　PLAN_TABLE列	314
9.4　查询优化器提示：“大纲”的建筑材料，让查询优化器按指示行事	322
9.4.1　查询优化器提示概览	322
9.4.2　指定提示	328
9.4.3　使用视图的提示	332
9.5　计划稳定性：大纲，以“查询优化器提示”记录和存储计划	334
9.5.1　通过计划稳定性以保留执行计划	335
9.5.2　在查询优化器升级中使用计划稳定性	340
9.6　SQL计划管理器：“计划基线”，大纲的升级版	342
9.6.1　SQL计划基线概览	342
9.6.2　管理SQL计划基线	344
9.6.3　在SQL优化顾问中使用SQL计划基线	348
9.6.4　使用固定的SQL计划基线	349
9.6.5　显示SQL计划基线	349
9.6.6　SQL管理基地	350
9.6.7　导入和导出SQL计划基线	352
9.6.8　将存储大纲迁移到SQL计划基线	353
第10章　对SQL和执行计划进行跟踪与分析	363
10.1　端到端应用程序跟踪：得到客户端跟踪信息	363
10.1.1　为端到端应用程序跟踪启用和禁用统计信息的收集	364
10.1.2　查看为端到端应用程序跟踪收集的统计信息	365
10.1.3　启用和禁用端到端跟踪	365
10.1.4　查看启用的端到端跟踪	368
10.2　使用trcsess工具：组织跟踪信息	368
10.2.1　trcsess工具的语法	368
10.2.2　trcsess输出样例	369
10.3　了解SQL Trace和TKPROF	370
10.3.1　了解SQL Trace工具	370
10.3.2　了解TKPROF	370
10.4　使用SQL Trace和TKPROF	371
10.4.1　第1步：为跟踪文件管理设置初始化参数	371
10.4.2　第2步：启用SQL Trace工具	372
10.4.3　第3步：使用TKPROF格式化跟踪文件	373
10.4.4　第4步：解释TKPROF输出	376
10.4.5　第5步：保存SQL Trace工具统计信息	380
10.5　避免TKPROF解释错误	382
10.5.1　避免绑定变量陷阱	382
10.5.2　避免读一致性陷阱	383
10.5.3　避免模式陷阱	383
10.5.4　避免时间陷阱	384
10.6　TKPROF输出样例	385
10.6.1　TKPROF头样例	385
10.6.2　TKPROF正文样例	385
10.6.3　TKPROF总结样例	388
第11章　SQL优化：得到更好的执行计划	389
11.1　SQL优化概览	389
11.1.1　SQL优化介绍	389
11.1.2　优化目标	389
11.1.3　识别高负载SQL语句	390
11.1.4　自动SQL优化特性	392
11.1.5　开发高效的SQL语句	393
11.1.6　构建SQL测试用例	401
11.2　SQL调优顾问：针对SQL语句改善执行计划	403
11.2.1　自动调优优化器概览	403
11.2.2　管理自动SQL调优顾问	406
11.2.3　使用SQL调优顾问进行优化	410
11.2.4　管理SQL调优集合	416
11.2.5　管理SQL Profile	420
11.2.6　SQL调优视图	427
11.3　SQL访问顾问：针对整体负载改善执行计划	428
11.3.1　SQL访问顾问概览	428
11.3.2　使用SQL访问顾问	431
11.3.3　为“快速刷新”和“查询重写”优化物化视图	453
附录A　名词解释	462
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库性能优化实践指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>OCA认证考试指南(1Z0-062):Oracle Database 12c 安装与管理
第1章  安装Oracle数据库软件	1
1.1  规划Oracle数据库软件的安装	2
1.1.1  支持的平台	2
1.1.2  获取Oracle数据库软件	2
1.1.3  用户账户	2
1.1.4  磁盘空间和目录	2
1.1.5  先决条件检查	4
1.2  安装Oracle数据库软件	4
1.2.1  OUI产品清单	4
1.2.2  OUI对话框：交互式安装	5
1.2.3  静默安装和响应文件	6
1.2.4  Windows和Linux的区别	7
1.3  认证小结	8
1.4  本章知识点回顾	9
1.5  自测题	9
1.6  实验题	10
1.7  自测题答案	10
1.8  实验题答案	11
第2章  使用DBCA创建Oracle数据库	13
2.1  使用数据库配置助手(DBCA)创建数据库	14
2.1.1  实例、数据库和数据字典	14
2.1.2  使用DBCA创建数据库	15
2.1.3  DBCA对话框	16
2.2  使用DBCA生成数据库创建脚本	29
2.2.1  生成脚本	29
2.2.2  创建脚本	30
2.2.3  初始化参数文件	32
2.3  利用DBCA管理数据库设计模板	33
2.4  利用DBCA配置数据库选项	34
2.5  认证小结	35
2.6  本章知识点回顾	36
2.7  自测题	36
2.8  实验题	38
2.9  自测题答案	38
2.10  实验题答案	39
第3章  了解Oracle数据库体系结构	41
3.1  列出Oracle数据库构件	42
3.1.1  单实例数据库体系结构	42
3.1.2  分布式系统体系结构	44
3.2  解释内存结构	45
3.2.1  数据库缓冲区缓存	46
3.2.2  日志缓冲区	47
3.2.3  共享池	48
3.2.4  大池	51
3.2.5  Java池	51
3.2.6  流池	52
3.3  描述后台进程	53
3.3.1  SMON，系统监视器	53
3.3.2  PMON，进程监视器	53
3.3.3  DBWn，数据库写入器	54
3.3.4  LGWR，日志写入器	55
3.3.5  CKPT，检查点进程	56
3.3.6  MMON，管理监视器	56
3.3.7  MMNL，管理监控灯	57
3.3.8  MMAN，内存管理器	57
3.3.9  LREG，监听器注册进程	57
3.3.10  ARCn，归档器	57
3.3.11  RECO，恢复器进程	58
3.3.12  其他一些后台进程	58
3.4  解释逻辑和物理存储结构之间的关系	61
3.4.1  物理数据库结构	61
3.4.2  逻辑数据库结构	65
3.4.3  数据字典	65
3.5  认证小结	67
3.6  本章知识点回顾	67
3.7  自测题	68
3.8  实验题	70
3.9  自测题答案	70
3.10  实验题答案	72
第4章  管理数据库实例	73
4.1  使用数据库管理工具	74
4.1.1  使用SQL*Plus	74
4.1.2  以普通用户或特权用户登录	75
4.1.3  使用Database Express	76
4.1.4  使用SQL Developer	78
4.2  了解数据库初始化参数文件	80
4.2.1  静态和动态参数文件	80
4.2.2  静态和动态参数以及初始化参数文件	81
4.2.3  基本参数	82
4.2.4  更改参数	84
4.3  启动和关闭数据库实例	87
4.3.1  启动数据库监听器	87
4.3.2  启动和关闭数据库	88
4.4  查看警报日志和访问动态性能视图	93
4.4.1  警报日志	93
4.4.2  DDL日志	94
4.4.3  动态性能视图	94
4.5  认证小结	96
4.6  本章知识点回顾	96
4.7  自测题	97
4.8  实验题	99
4.9  自测题答案	99
4.10  实验题答案	100
第5章  配置Oracle网络环境	103
5.1  配置Oracle Net服务	104
5.1.1  Oracle Net和客户端-服务器范例	104
5.1.2  建立会话	105
5.1.3  创建监听器	107
5.1.4  动态服务注册	107
5.1.5  共享服务器	108
5.2  使用工具配置和管理Oracle网络	113
5.2.1  Net Manager	113
5.2.2  Net配置助手	114
5.2.3  监听器控制实用程序	114
5.2.4  TNS_ADMIN环境变量	115
5.3  配置客户端网络	116
5.3.1  Easy Connect	116
5.3.2  本地名称解析方法	116
5.3.3  目录名称解析方法和外部名称解析方法	117
5.3.4  测试Oracle Net连通性	117
5.4  了解数据库驻留连接池	121
5.5  配置数据库之间的通信	122
5.6  认证小结	123
5.7  本章知识点回顾	123
5.8  自测题	124
5.9  实验题	126
5.10  自测题答案	127
5.11  实验题答案	128
第6章  管理数据库存储结构	129
6.1  描述表行数据在块中的存储	130
6.1.1  Oracle数据存储模型	130
6.1.2  段、区块、块和行	132
6.2  创建和管理表空间	135
6.2.1  创建表空间	135
6.2.2  更改表空间	139
6.2.3  删除表空间	142
6.2.4  区块管理	143
6.2.5  管理段空间	144
6.2.6  Oracle管理的文件(OMF)	145
6.3  认证小结	147
6.4  本章知识点回顾	147
6.5  自测题	148
6.6  实验题	150
6.7  自测题答案	150
6.8  实验题答案	151
第7章  空间管理	153
7.1  解释Oracle数据库服务器如何自动管理空间	154
7.1.1  区块管理	154
7.1.2  自动段空间管理(ASSM)	156
7.2  利用压缩来节省空间	157
7.3  主动监控和管理表空间使用情况	159
7.4  使用段顾问程序	160
7.5  利用段收缩功能从表和索引回收浪费的空间	161
7.6  管理可恢复的空间分配	162
7.7  认证小结	164
7.8  本章知识点回顾	165
7.9  自测题	166
7.10  实验题	167
7.11  自测题答案	168
7.12  实验题答案	169
第8章  管理用户安全	171
8.1  创建和管理数据库用户账户	172
8.1.1  用户账户属性	172
8.1.2  身份验证方法	175
8.1.3  创建账户	178
8.2  授予和撤消权限	180
8.2.1  系统权限	180
8.2.2  对象权限	182
8.3  创建和管理角色	185
8.3.1  创建角色并授予角色权限	185
8.3.2  预先定义的角色	186
8.3.3  启用角色	187
8.3.4  权限分析	188
8.4  创建和管理配置文件	189
8.4.1  配置口令限制	190
8.4.2  配置文件的创建和分配	190
8.5  认证小结	192
8.6  本章知识点回顾	192
8.7  自测题	193
8.8  实验题	195
8.9  自测题答案	195
8.10  实验题答案	197
第9章  管理撤消数据	199
9.1  解释DML和撤消数据生成	200
9.1.1  数据库事务	200
9.1.2  撤消的生成	201
9.1.3  执行SQL语句	203
9.1.4  事务如何使用撤消段	208
9.2  监控和管理撤消数据	210
9.2.1  与撤消相关的错误条件	210
9.2.2  用于撤消管理与保留保证的参数	210
9.2.3  调整与监控撤消表空间	211
9.2.4  临时撤消	212
9.2.5  创建和管理撤消表空间	213
9.3  描述撤消数据和重做数据的
区别	214
9.4  配置撤消保留	215
9.4.1  配置撤消保留用于支持长时间的查询	215
9.4.2  闪回查询和撤消保留	216
9.5  认证小结	217
9.6  本章知识点回顾	218
9.7  自测题	218
9.8  实验题	220
9.9  自测题答案	221
9.10  实验题答案	222
第10章  管理数据并发性	225
10.1  描述锁机制和Oracle如何管理数据并发性	226
10.1.1  共享锁与独占锁	226
10.1.2  排队机制	227
10.1.3  自动和手动锁定	227
10.2  监控和解决锁冲突	228
10.2.1  锁争用的原因	229
10.2.2  检测锁争用	230
10.2.3  解决锁争用	231
10.2.4  死锁(一个特例)	232
10.3  认证小结	234
10.4  本章知识点回顾	234
10.5  自测题	234
10.6  实验题	235
10.7  自测题答案	235
10.8  实验题答案	236
第11章  实现Oracle数据库审计	237
11.1  解释DBA的安全和审计责任	238
11.1.1  为何审计	238
11.1.2  审计技术	238
11.2  启用标准数据库审计和统一审计	242
11.2.1  启用标准审计	242
11.2.2  启用统一审计	243
11.3  认证小结	245
11.4  本章知识点回顾	246
11.5  自测题	246
11.6  自测题答案	247
第12章  执行数据库维护	249
12.1  管理自动工作负荷仓库(AWR)	250
12.1.1  收集AWR统计信息	250
12.1.2  管理AWR	251
12.2  使用自动数据库诊断监视器(ADDM)	252
12.3  描述和使用顾问程序框架	254
12.4  设置警报阈值	255
12.4.1  警报条件监视和通知	255
12.4.2  设置阈值	256
12.5  使用自动任务	259
12.5.1  自动作业	259
12.5.2  控制自动任务	259
12.6  认证小结	260
12.7  本章知识点回顾	261
12.8  自测题	261
12.9  实验题	263
12.10  自测题答案	264
12.11  实验题答案	265
第13章  性能管理	267
13.1  使用企业管理器监控性能	268
13.1.1  性能调整方法论	268
13.1.2  性能监控数据	269
13.1.3  Database Express性能页	269
13.2  使用自动内存管理	270
13.2.1  PGA内存管理	271
13.2.2  SGA内存管理	273
13.2.3  自动内存管理	274
13.3  使用内存顾问程序修改内存缓冲区大小	276
13.4  认证小结	278
13.5  本章知识点回顾	278
13.6  自测题	278
13.7  实验题	279
13.8  自测题答案	280
13.9  实验题答案	280
第14章  管理性能：SQL调优	283
14.1  管理优化器统计信息	284
14.1.1  对象统计信息	284
14.1.2  优化器如何使用统计信息	285
14.1.3  手动收集统计信息	286
14.2  使用SQL调整顾问程序	289
14.2.1  SQL调整顾问程序的功能	289
14.2.2  SQL调整顾问程序API：DBMS_SQLTUNE包	290
14.3  使用SQL访问顾问程序对工作负载进行调优	291
14.3.1  SQL访问顾问程序的功能	291
14.3.2  利用DBMS_ADVISOR来使用SQL访问顾问程序	292
14.4  认证小结	293
14.5  本章知识点回顾	294
14.6  自测题	294
14.7  实验题	295
14.8  自测题答案	296
14.9  实验题答案	297
第15章  使用数据库资源管理器管理资源	299
15.1  配置数据库资源管理器	300
15.1.1  资源管理需求	300
15.1.2  资源管理器架构	301
15.1.3  资源管理器配置	304
15.2  访问和创建资源计划	305
15.2.1  CPU方法	305
15.2.2  CPU使用比例方法	308
15.2.3  活动会话池方法	308
15.2.4  限制并行度	309
15.2.5  根据执行时间控制作业	310
15.2.6  根据空闲时间终止会话	310
15.2.7  限制撤消数据的生成	311
15.3  监视资源管理器	313
15.4  认证小结	314
15.5  本章知识点回顾	315
15.6  自测题	315
15.7  实验题	317
15.8  自测题答案	317
15.9  实验题答案	319
第16章  通过使用Oracle调度程序自动执行任务	321
16.1  使用Oracle调度程序简化管理任务	322
16.1.1  调度程序架构	322
16.1.2  调度程序对象	323
16.2  使用作业链执行一系列相关的任务	327
16.3  在远程系统上使用调度程序作业	328
16.4  使用高级调度程序功能来设定作业优先级	329
16.4.1  使用作业类	329
16.4.2  使用窗口	330
16.5  认证小结	332
16.6  本章知识点回顾	332
16.7  自测题	333
16.8  实验题	334
16.9  自测题答案	334
16.10  实验题答案	336
第17章  移动数据	337
17.1  描述数据移动方法	338
17.2  创建和使用目录对象	338
17.3  使用SQL*Loader从非Oracle数据库加载数据	339
17.3.1  使用SQL*Loader	339
17.3.2  SQL*Loader快捷模式	342
17.4  使用外部表通过与平台无关的文件来移动数据	343
17.5  解释Oracle 数据泵的一般体系结构	345
17.6  使用数据泵导出和导入在Oracle数据库之间移动数据	347
17.6.1  功能	347
17.6.2  通过命令行实用程序使用数据泵	347
17.6.3  表空间导出和导入	348
17.7  认证小结	351
17.8  本章知识点回顾	352
17.9  自测题	353
17.10  实验题	354
17.11  自测题答案	355
17.12  实验题答案	356
第18章  备份和恢复：概念与配置	357
18.1  认识检查点、重做日志文件和归档日志文件的重要性	358
18.1.1  实例恢复	358
18.1.2  数据库不可能受到的损坏	358
18.1.3  检查点	359
18.1.4  保护联机重做日志文件	360
18.1.5  归档日志模式和归档器进程	362
18.2  备份和恢复：配置	364
18.3  快速恢复区配置	365
18.4  配置归档日志模式	366
18.5  认证小结	368
18.6  本章知识点回顾	368
18.7  自测题	369
18.8  实验题	370
18.9  自测题答案	370
18.10  实验题答案	371
第19章  数据库备份和恢复操作	373
19.1  创建一致的数据库备份	374
19.2  在不关闭数据库的情况下备份数据库	377
19.3  创建增量备份	378
19.4  自动化的数据库备份	379
19.5  管理备份	379
19.5.1  RMAN信息库	379
19.5.2  对备份进行报告	380
19.5.3  管理备份	381
19.6  决定是否需要执行恢复	381
19.7  使用恢复管理器(RMAN)和数据恢复顾问执行控制文件、重做日志文件和数据文件的恢复	382
19.7.1  Health Monitor和ADR	382
19.7.2  使用数据恢复顾问(DRA)	382
19.8  认证小结	386
19.9  本章知识点回顾	386
19.10  自测题	387
19.11  实验题	389
19.12  自测题答案	390
19.13  实验题答案	391
第20章  为独立服务器安装Oracle网格基础体系结构	393
20.1  为Oracle自动存储管理(ASM)配置存储	394
20.1.1  GI体系结构	394
20.1.2  ASM的体系结构	395
20.1.3  ASM磁盘	396
20.1.4  创建ASM磁盘	397
20.2  为独立服务器安装Oracle网格基础体系结构	398
20.3  认证小结	403
20.4  本章知识点回顾	404
20.5  自测题	404
20.6  实验题	405
20.7  自测题答案	407
20.8  实验题答案	408
第21章  使用Oracle Restart	409
21.1  使用Oracle Restart来管理组件	410
21.1.1  管理Oracle Restart进程	410
21.1.2  管理已注册资源	411
21.1.3  重新启动功能	413
21.2  认证小结	415
21.3  本章知识点回顾	415
21.4  自测题	416
21.5  实验题	417
21.6  自测题答案	417
21.7  实验题答案	417
第22章  升级Oracle数据库软件并迁移数据	419
22.1  描述升级方法	420
22.1.1  软件升级	420
22.1.2  数据库升级：DBUA或手动	421
22.2  描述数据迁移方法	422
22.3  描述升级过程	423
22.4  利用Oracle数据泵来迁移数据	423

22.5  认证小结	425
22.6  本章知识点回顾	425
22.7  自测题	426
22.8  自测题答案	427
第23章  数据库升级：准备、升级和升级后的任务	429
23.1  描述在Oracle数据库中使用特定功能或选项时的升级要求	430
23.1.1  Oracle标签安全性和Oracle Data Vault	430
23.1.2  Oracle数据仓库构建器	430
23.2  在执行升级前使用升级前信息工具	431
23.3  在执行升级前准备新的Oracle主目录	432
23.4  利用数据库升级助手(DBUA) 将数据库升级到Oracle Database 12c	433
23.5  利用脚本和工具手工执行升级到Oracle Database 12c	435
23.6  迁移到统一审计	436
23.7  执行升级后任务	436
23.8  认证小结	437
23.9  本章知识点回顾	438
23.10  自测题	438
23.11  实验题	440
23.12  自测题答案	441
23.13  实验题答案	442
术语表	443
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>OCA认证考试指南(1Z0-062):Oracle Database 12c 安装与管理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ORACLE数据存储与访问技术
第1章 ORACLE的物理存储及其管理
1.1 tablespace与存储空间
1.2 系统表空间与数据字典
1.2.1 system和sysaux表空间
1.2.2 数据字典（data dictionary）
1.3 临时信息与临时表空间
1.4 回滚信息与回滚表空间
1.4.1 回滚段的分类
1.4.2 创建回滚段
1.4.3 管理回滚段
1.4.4 undo空间及其自动管理
1.5 数据库表空间的存储结构
1.5.1 表空间的存储关系
1.5.2 表空间的存储参数设置
1.5.3 表空间的维护
1.6 数据库文件管理
1.6.1 控制文件的管理
1.6.2 数据文件的管理
1.6.3 联机日志的配置与管理
1.7 OMF方式管理文件
1.8 闪回恢复区fra
1.8.1 闪回恢复区的作用
1.8.2 配置闪回恢复区
1.8.3 闪回恢复区的文件保留策略
1.8.4 使用闪回恢复区
1.9 RAID磁盘阵列存储
1.9.1 RAID存储规范
1.9.2 ORACLE的RAID存储方案建议
第2章 自动存储管理与ASM数据库
2.1 自动存储的主要概念
2.2 ASM的系统结构
2.3 准备ASM存储设备
2.3.1 LVM与ASM
2.3.2 创建raw device
2.3.3 标识ASM磁盘
2.4 ORACLE集群同步服务CSS
2.5 创建并启动ASM实例
2.6 在ASM实例中创建磁盘组
2.6.1 磁盘组的冗余级别
2.6.2 创建ASM磁盘组
2.6.3 在ASM实例中加载磁盘组
2.7 ASM实例与RDBMS实例的关系
2.8 直接创建ASM数据库
2.9 将现有数据库迁移至ASM
2.9.1 启用基于磁盘组的OMF
2.9.2 迁移控制文件至ASM磁盘组
2.9.3 迁移数据文件至ASM磁盘组
2.9.4 切换数据库至ASM磁盘组上运行
2.9.5 迁移临时表空间
2.9.6 迁移联机日志文件
2.9.7 关于闪回日志和块跟踪文件
2.10 ASM信息与ASM文件管理
2.10.1 动态性能视图
2.10.2 ASM磁盘文件管理
2.10.3 ASM命令行工具
第3章 数据块结构
3.1 data block描述
3.2 data block结构
3.3 行链接与行迁移
第4章 ITL与事务处理
4.1 ITL描述
4.2 ITL等待
4.3 ITL实验案例
4.4 ITL进一步研究
4.5 ITL与CR块
第5章 数据块损坏的修复
5.1 数据块损坏描述
5.2 数据块损坏的检测
5.2.1 初始化参数设置
5.2.2 RMAN检查
5.2.3 dbverify工具
5.2.4 其他工具检查
5.3 数据块损坏的模拟和修复
5.3.1 段与存储数据块
5.3.2 模拟数据块损坏
5.3.3 基于块的数据恢复
第6章 dump数据块
6.1 block dump描述
6.2 dump数据块
6.3 dump索引块
第7章 系统改变号SCN
7.1 SCN描述
7.2 SCN与数据恢复
7.3 SCN数据恢复案例
第8章 伪列pseudo column
8.1 伪列描述
8.2 常用伪列的研究
8.2.1 伪列rowid
8.2.2 伪列rownum
8.3 伪列ora_rowscn研究
8.4 伪列level与层次查询
第9章 表存储结构与访问优化
9.1 存储结构中的块
9.1.1 块结构及其控制参数
9.1.2 行迁移与行链接
9.2 正确设置参数pctfree
9.3 避免行迁移与行链接
9.3.1 行迁移与行链接的检测
9.3.2 行迁移与行链接的消除方法
9.4 消除迁移行和链接行实例
9.5 高水位线HWM
9.6 表存储统计实验
9.6.1 验证表结构
9.6.2 发现行迁移
9.6.3 收集统计信息
9.6.4 表分析实验
第10章 分区Partition技术
10.1 分区Partition概述
10.2 表分区的基本类别
10.2.1 范围分区（by range）
10.2.2 列表分区（by list）
10.2.3 散列分区（by hash）
10.2.4 间隔分区（by interval）
10.3 基本分区的复合
10.4 分区索引技术
10.4.1 索引分区与表
10.4.2 本地分区索引
10.4.3 全局分区索引
10.5 分区表与索引的维护
10.6 分区交换及其应用
10.7 联机分区处理
第11章 数据访问之多表联接
11.1 多表联接概述
11.2 联接条件和类型
11.2.1 笛卡尔乘积
11.2.2 多表的条件联接
11.2.3 避免使用子查询
11.3 多表联接的方法
11.3.1 嵌套循环
11.3.2 融合联接
11.3.3 哈希联接
11.3.4 三种联接方式比较
第12章 数据访问之ORACLE索引
12.1 ORACLE索引概述
12.2 b树索引和bitmap索引
12.2.1 b树索引结构
12.2.2 bitmap索引结构
12.2.3 对null值的索引
12.3 聚簇因子
12.3.1 计算聚簇因子
12.3.2 对访问性能的影响
12.4 索引分析与重建
12.4.1 索引分析与统计
12.4.2 查询索引状态及使用信息
12.4.3 索引重建
12.5 与索引有关的参数
12.6 访问索引的方式
12.6.1 索引扫描方式
12.6.2 两类数据块扫描
12.7 b树索引的维护机制
12.7.1 insert操作的b树维护
12.7.2 delete操作的b树维护
12.7.3 update操作的b树维护
12.8 复合索引的使用
12.8.1 两个使用原则
12.8.2 复合索引和order by
12.9 关于索引使用的建议
第13章 数据库访问性能的几个基本问题
13.1 内存问题
13.2 CPU利用率
13.3 I/O问题
13.4 高资源消耗的SQL
13.5 引发性能瓶颈的应用问题
13.6 OLTP与OLAP
第14章 性能问题的度量手段
14.1 性能调优的度量概述
14.2 explain解释SQL
14.2.1 配置explain
14.2.2 获得执行计划
14.3 语句级跟踪autotrace
14.4 会话级跟踪sql_trace
14.4.1 设置SQL跟踪
14.4.2 tkprof格式化跟踪文件
14.5 扩展的SQL跟踪
第15章 ORACLE锁机制与锁争用问题
15.1 ORACLE数据库的锁类型
15.2 数据访问过程中的加锁
15.3 与锁有关的字典参数与指令
15.3.1 有关锁的数据字典视图
15.3.2 有关锁的初始化参数
15.3.3 事务的隔离级别
15.4 锁争用与死锁
15.4.1 量测锁争用
15.4.2 处理死锁
15.5 锁存器latch
15.5.1 锁存器机制
15.5.2 检查latch争用
第16章 wait与time响应问题
16.1 基于wait的性能问题描述
16.2 用户响应的时间模型
16.2.1 CPU服务时间
16.2.2 等待事件及等待时间
16.3 统计项与等待事件
16.4 db time和db CPU
16.5 top SQL说明
16.6 等待事件直方图
第17章 等待事件接口与性能调整
17.1 性能与等待事件
17.2 常见的等待事件及其描述
17.3 等待事件不能反映的信息
17.4 收集等待事件信息
17.5 利用等待事件发现性能瓶颈
17.5.1 一个慢速查询的处理
17.5.2 耗时的调度批处理
17.5.3 客户服务
……
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ORACLE数据存储与访问技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库管理与开发 （适用于OCP认证）
目  录

第0章  Oracle的安装及相关配置	1
0.1  Oracle的安装	1
0.2  进入Oracle的SQL*Plus界面	5
0.3  scott用户及其对象维护	6
0.4  本书中将用到的表	7
0.5  SQL（Structured Query Language）
语言	7
0.6  本书所用的术语	8
0.7  Oracle 11g上的SQL*Plus	9
0.8  使用iSQL*Plus	10
0.9  使用DOS窗口启动SQL*Plus	13
第1章  简单查询、限制性查询和数据的
排序	15
1.1  最简单的查询语句	16
1.2  在查询语句中如何选择特定的
列（投影操作）	16
1.3  如何书写查询语句	18
1.4  列标题和数据的默认显示格式	19
1.5  如何在SQL语句中使用算术
表达式	20
1.6  如何在SQL语句中使用列的
别名	22
1.7  连接运算符	23
1.8  DISTINCT运算符	23
1.9  基本查询语句的格式	25
1.10  如何限制所选择的数据行（选择
操作）	26
1.11  如何使用BETWEEN AND比较
运算符	27
1.12  在SQL语句中使用字符串和
日期	28
1.13  使用IN比较运算符	29
1.14  使用LIKE比较运算符	31
1.15  如何使用转义操作符	32
1.16  ORDER BY子句（排序
操作）	33
1.17  在ORDER BY子句中使用别名
或表达式	34
1.18  在ORDER BY子句中使用列号
及使用多列	35
1.19  扩充后的查询语句的格式	37
1.20  练习题	38
第2章  常用的SQL*Plus命令和环境
变量	40
2.1  DESC[RIBE]命令	40
2.2  SET LINE[SIZE]{80|n}命令	41
2.3  L命令和n text命令	42
2.4  “/”（RUN）命令	43
2.5  n（设置当前行）命令和A[PPEND]
（附加）命令	44
2.6  DEL命令	45
2.7  C[HANGE]命令	46
2.8  如何生成脚本文件	48
2.9  如何编辑脚本文件	50
2.10  如何直接运行脚本文件	51
2.11  SPOOL命令	52
2.12  控制SQL*Plus的环境	53
2.13  SQL*Plus的环境变量ECHO	54
2.14  常用的SQL*Plus环境变量	56
2.15  SQL*Plus的COLUMN格式化
命令	57
2.16  SQL*Plus的其他格式化命令	61
2.17  怎样获取SQL*Plus的帮助
信息	62
2.18  练习题	63
第3章  函数、NULL值的处理以及逻辑
操作	65
3.1  什么是函数	65
3.2  单行函数简介	65
3.3  单行字符型函数	65
3.4  使用单行字符型函数的实例	70
3.5  数字型函数	71
3.6  日期型数据的处理	72
3.7  日期函数	74
3.8  ROUND和TRUNC函数用于
日期型数据	76
3.9  不同数据类型之间的隐含
转换	77
3.10  不同数据类型之间的显式
转换	78
3.11  什么是空值	81
3.12  含有空值的表达式的运算	82
3.13  空值的排序	84
3.14  逻辑表达式和逻辑运算符	84
3.15  运算符的优先级	87
3.16  NVL函数	88
3.17  DECODE函数	88
3.18  单值函数的嵌套	89
3.19  Oracle 9i新增加的单值函数和
表达式	90
3.20  COUNT函数	94
3.21  AVG和SUM函数	95
3.22  MAX和MIN函数	95
3.23  GROUP BY子句的应用与排列
次序	96
3.24  GROUP BY子句的特殊用法
以及非法操作	97
3.25  HAVING子句的使用	99
3.26  分组函数的嵌套	100
3.27  分组函数的空值问题	101
3.28  其他的分组函数和分组函数的
小结	103
3.29  练习题	103
第4章  多表查询和单行子查询	106
4.1  数据库的规范化	106
4.2  主键和实体完整性	107
4.3  第一范式	107
4.4  消除部分依赖	108
4.5  外键和引用完整性	109
4.6  第二范式和第三范式	109
4.7  规范化过程小结	111
4.8  多表连接	112
4.9  相等连接	112
4.10  连接中表别名的使用	113
4.11  笛卡儿乘积（乘积连接）	114
4.12  自连接	115
4.13  两个以上表的连接	116
4.14  不等连接	116
4.15  外连接	118
4.16  SQL:1999语法的笛卡儿乘积
和自然连接	119
4.17  使用USING子句和ON子句
的连接	119
4.18  使用ON子句的多表连接和
附加条件	121
4.19  左外连接和右外连接	122
4.20  全外连接	123
4.21  为什么引入单行子查询	124
4.22  WHERE子句中的单行子
查询	125
4.23  HAVING子句和FROM子句
中的单行子查询	127
4.24  练习题	128
第5章  表、索引以及替代变量	130
5.1  创建表的语句以及命名和引用
规则	130
5.2  列的数据类型和默认值	131
5.3  创建表的例子	133
5.4  利用子查询来创建表	134
5.5  修改表的结构	135
5.6  改变对象的名称	139
5.7  截断表和删除表	140
5.8  为什么引入索引	142
5.9  如何建立索引	143
5.10  如何查看索引	144
5.11  使用索引时应注意的问题	145
5.12  如何删除索引	146
5.13  替代变量引入的原因	147
5.14  以&开始的替代变量	148
5.15  字符型和日期型替代变量	150
5.16  以&&开始的替代变量	151
5.17  替代变量可以出现的地方	153
5.18  使用DEFINE定义替代变量	154
5.19  使用ACCEPT定义替代变量	155
5.20  ACCEPT命令的格式和选项	156
5.21  练习题	157
第6章  数据的维护	159
6.1  准备工作	159
6.2  INSERT语句	159
6.3  INSERT语句中的空值问题	161
6.4  如何向表中插入特殊的值	163
6.5  如何利用子查询向表中插入
数据	163
6.6  如何利用替代变量向表中插入
数据和将INSERT语句存入脚
本文件	164
6.7  利用ACCEPT在INSERT语句中
产生用户友好的系统提示	166
6.8  UPDATE语句	167
6.9  基于另一个表来修改记录	169
6.10  利用多列子查询来修改
记录	171
6.11  DELETE语句	172
6.12  在使用DELETE时可能出现的
问题	173
6.13  基于另一个表来删除行	174
6.14  引入事务处理的原因和Oracle
数据库的事务	175
6.15  利用COMMIT和ROLLBACK
语句控制事务	176
6.16  有关事务处理应注意的一些
问题	178
6.17  练习题	179
第7章  Oracle系统的约束	181
7.1  Oracle系统提供的约束	181
7.2  非空约束	181
7.3  查看有关约束的信息	183
7.4  唯一约束	184
7.5  条件约束	187
7.6  主键约束	189
7.7  外键约束	192
7.8  外键约束对DML语句和DDL
语句的影响	194
7.9  外键的ON DELETE SET NULL
和ON DELETE CASCADE
子句	195
7.10  约束的维护	200
7.11  约束小结	204
7.12  练习题	205
第8章  视图、序列和同义词	207
8.1  为什么引入视图	207
8.2  使用视图的好处	208
8.3  如何创建视图	210
8.4  如何修改视图	212
8.5  Oracle系统如何管理视图	213
8.6  如何使用视图来进行DML
操作	214
8.7  如何使用视图的WITH CHECK
OPTION子句	215
8.8  WITH READ ONLY子句的
使用	216
8.9  如何删除视图	218
8.10  ROWNUM的更多应用	219
8.11  序列号的引入及创建序列号
语句的格式	220
8.12  如何创建序列号	222
8.13  如何使用创建的序列号	223
8.14  NEXTVAL和CURRVAL虚
（伪）列介绍和它们的使用
规则	225
8.15  序列号的修改	226
8.16  删除序列号	227
8.17  同义词的引入及创建	228
8.18  创建公用同义词及删除
同义词	230
8.19  练习题	232
第9章  Oracle的体系结构	234
9.1  Oracle引入复杂的体系结构的
原因	234
9.2  Oracle数据库中常用的术语	235
9.3  Oracle数据库管理系统的体系
结构	236
9.4  Oracle服务器的安装方式	237
9.5  Oracle实例和数据库以及其他的
关键文件	237
9.6  建立与Oracle实例的连接	238
9.7  各种不同的连接方式	239
9.8  服务器进程	239
9.9  Oracle执行SQL查询语句的
步骤	240
9.10  共享池（shared pool）	240
9.11  数据库高速缓冲区（database
buffer cache）	242
9.12  内存缓冲区顾问（v$db_cache_
advice）	243
9.13  重做日志缓冲区（redo log
buffer）	244
9.14  大池（large pool）和Java池
（Java pool）	244
9.15  内存缓冲区大小的设定	245
9.16  内存缓冲区信息的获取	246
9.17  重做日志写进程（LGWR）及
快速提交（fast commit）	246
9.18  数据库写进程
（DBWR/DBWn）	247
9.19  系统监督进程（SMON）和进程
监督进程（PMON）	248
9.20  校验点（checkpoint）和校验点
进程	249
9.21  归档日志（ARCH/ARCn）
进程	249
9.22  小结	250
9.23  练习题	251
第10章  Oracle数据库管理工具与实例
管理	253
10.1  Oracle通用安装程序（Oracle
Universal Installer）	253
10.2  Oracle数据库配置助手
（DBCA）	254
10.3  数据库管理员用户sys和
system	257
10.4  SQL*Plus命令行工具	257
10.5  Oracle 10g企业管理器
（EM）	258
10.6  初始化参数文件（initialization
parameter files）	260
10.7  静态参数文件（PFILE）	260
10.8  动态服务器参数文件
（SPFILE）	262
10.9  启动数据库	264
10.10  将数据库置为限制模式	266
10.11  关闭数据库	268
10.12  如何利用诊断文件来监督
实例	269
10.13  练习题	271
第11章  数据字典和控制文件	273
11.1  数据字典简介	273
11.2  数据字典的操作和使用	274
11.3  格式化数据字典视图的输出	275
11.4  如何使用数据字典视图	276
11.5  动态性能表（视图）	278
11.6  数据字典应用实例	279
11.7  控制文件及控制文件中所存放
的内容	283
11.8  从控制文件中获取信息的
数据字典	284
11.9  如何限定控制文件的大小	284
11.10  怎样查看控制文件的配置	285
11.11  怎样添加和移动控制文件	286
11.12  控制文件的备份	287
11.13  虚拟环境的创建	288
11.14  练习题	290
第12章  重做日志文件	292
12.1  引入重做日志的目的	292
12.2  重做日志组	293
12.3  重做日志成员	294
12.4  日志切换和检查点	294
12.5  获取重做日志的信息	295
12.6  添加和删除联机重做日志
文件组	297
12.7  添加和删除联机重做日志
成员（文件）	299
12.8  清除联机重做日志文件	301
12.9  利用OMF来管理联机重做
日志文件	304
12.10  联机重做日志的配置	307
12.11  练习题	308
第13章  表空间和数据文件的管理	310
13.1  Oracle引入逻辑结构的目的	310
13.2  Oracle数据库中存储结构之间
的关系	310
13.3  表空间和数据文件之间的关系
及表空间的分类	311
13.4  表空间中的磁盘空间管理	312
13.5  创建本地管理的表空间	313
13.6  还原表空间	315
13.7  临时表空间	316
13.8  默认临时表空间	318
13.9  设置表空间为脱机	320
13.10  只读（read-only）表空间	322
13.11  重置表空间的大小	324
13.12  移动数据文件的方法	325
13.13  删除表空间	326
13.14  利用OMF来管理表空间	329
13.15  练习题	332
第14章  存储结构及其之间的关系和
创建数据库	334
14.1  各种类型的段	334
14.2  存储子句的优先级	335
14.3  区段（extent）	336
14.4  数据库块（database block）	337
14.5  自动的段空间管理	339
14.6  创建数据库概述	340
14.7  筹划和组织数据库优化而弹性
的体系结构	340
14.8  创建数据库的先决条件	342
14.9  创建数据库的方法	343
14.10  创建数据库过程中的排错	344
14.11  利用Oracle Managed Files来
创建数据库	345
14.12  练习题	345
第15章  管理还原数据	347
15.1  还原数据的管理方法	347
15.2  Oracle使用还原段的目的	348
15.3  还原段的类型	349
15.4  自动还原数据管理的概念和
配置	349
15.5  还原表空间的创建与维护	350
15.6  还原表空间之间的切换	352
15.7  删除还原表空间	354
15.8  自动还原数据管理的一些
参数	355
15.9  获得还原数据的信息	356
15.10  练习题	357
第16章  管理表	358
16.1  存储数据的方法和Oracle内置
数据类型	358
16.2  ROWID	360
16.3  Oracle数据行的结构	362
16.4  创建普通表	363
16.5  创建临时表	364
16.6  表的维护和管理	366
16.7  非分区表的重组	367
16.8  列的维护	371
16.9  表的截断和删除	373
16.10  练习题	374
第17章  索引的管理与维护	375
17.1  Oracle引入索引的目的	375
17.2  索引的分类	375
17.3  B-树索引	376
17.4  位图索引	377
17.5  B-树索引和位图索引的
比较	379
17.6  创建索引	380
17.7  重建和维护索引	383
17.8  标识索引的使用情况	386
17.9  删除索引	387
17.10  练习题	388
第18章  用户及系统资源和安全的
管理	390
18.1  创建用户	390
18.2  数据库模式	392
18.3  改变用户在表空间上的
配额	393
18.4  删除用户	394
18.5  用户的安全控制域	395
18.6  概要文件（profiles）	396
18.7  利用概要文件进行资源
管理	396
18.8  创建资源限制的概要文件	397
18.9  口令管理	399
18.10  口令验证函数	400
18.11  创建口令限制的概要文件	401
18.12  修改和删除概要文件	403
18.13  创建概要文件的应用实例	405
18.14  练习题	407
第19章  管理权限	408
19.1  权限的分类以及系统权限	408
19.2  系统权限的限制	410
19.3  授予系统权限	410
19.4  回收系统权限	415
19.5  对象权限	418
19.6  对象权限的授权和回收	418
19.7  练习题	422
第20章  管理角色	424
20.1  引入角色（role）的原因	424
20.2  角色的创建	425
20.3  角色的修改	426
20.4  角色的授权	427
20.5  建立默认角色	429
20.6  激活和禁止角色	433
20.7  角色的回收和删除	435
20.8  创建和使用角色指南	439
20.9  Oracle预定义的角色	444
20.10  用户、概要文件、权限和角色
的应用实例	446
20.11  练习题	453
参考文献	454

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库管理与开发 （适用于OCP认证）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>从零开始学Oracle
第1篇  Oracle基础篇
第1章  数据库入门
（  教学视频：40分钟）	1
1.1  数据库基础	1
1.1.1  什么是关系型数据库	1
1.1.2  实体关系模型	3
1.1.3  数据库管理系统	3
1.1.4  使用SQL语言管理数据库	5
1.2  理解数据库范式	7
1.2.1  什么是数据库范式	7
1.2.2  第一范式1NF	8
1.2.3  第二范式2NF	8
1.2.4  第三范式3NF	9
1.2.5  使用数据库建模工具	9
1.3  认识Oracle数据库系统	14
1.3.1  Oracle数据库特性	14
1.3.2  Oracle数据库术语	15
1.3.3  Oracle数据库系统的组成	17
1.3.4  与SQL Server数据库的比较	18
1.4  安装Oracle数据库	19
1.4.1  获取Oracle数据库软件	19
1.4.2  使用Oracle技术与文档库	20
1.4.3  安装Oracle数据库	21
1.4.4  卸载Oracle数据库	25
1.5  小结	26
1.6  习题	26
第2章  使用Oracle数据库
（  教学视频：28分钟）	28
2.1  管理Oracle系统	28
2.1.1  启动和停止监听程序	28
2.1.2  数据库的启动和关闭	29
2.1.3  配置网络监听程序	33
2.1.4  使用网络配置助手工具	34
2.1.5  Net Manager网络管理员	36
2.2  创建Oracle数据库	37
2.2.1  使用DBCA创建数据库	37
2.2.2  数据库安装参数	41
2.2.3  删除现有数据库	43
2.2.4  手动安装数据库	44
2.3  连接Oracle数据库	47
2.3.1  安装Oracle客户端	47
2.3.2  客户端网络配置工具	49
2.3.3  使用Oracle企业管理器	52
2.3.4  使用SQL*Plus	53
2.3.5  使用Oracle SQL Developer	56
2.3.6  使用PL/SQL Developer	58
2.3.7  使用Toad	59
2.4  小结	62
2.5  习题	62
第3章  SQL与SQL*Plus
（  教学视频：27分钟）	63
3.1  SQL语言基础	63
3.1.1  SQL、SQL*Plus与Oracle的关系	64
3.1.2  SQL语言的特点	64
3.1.3  SQL语言的分类	65
3.1.4  SQL语言的编写规则	66
3.2  认识SQL*Plus	68
3.2.1  SQL*Plus的功能	68
3.2.2  启动SQL *Plus	69
3.2.3  重新连接数据库	70
3.2.4  SQL*Plus运行环境设置	70
3.2.5  使用命令帮助	71
3.3  使用SQL*Plus管理数据库对象	72
3.3.1  执行SQL语句	72
3.3.2  了解SQL缓冲区	73
3.3.3  运行脚本文件	75
3.3.4  显示表结构	75
3.4  格式化查询结果	76
3.4.1  格式化列	76
3.4.2  清除列格式	79
3.4.3  限制重复行	79
3.4.4  使用汇总行	80
3.5  小结	82
3.6  习题	82
第2篇  管理Oracle对象篇
第4章  操纵数据表
（  教学视频：22分钟）	83
4.1  表基础	83
4.1.1  表和实体	83
4.1.2  表的分类	84
4.1.3  表和列命名规则	85
4.1.4  内置列数据类型	86
4.2  创建表	87
4.2.1  理解表空间	88
4.2.2  创建标准表	88
4.2.3  全局临时表	91
4.2.4  使用Dual表	93
4.2.5  查看表信息	94
4.3  修改表	96
4.3.1  添加表列	96
4.3.2  修改表列	97
4.3.3  删除表列	98
4.3.4  重命名表列	98
4.3.5  删除数据表	99
4.4  小结	100
4.5  习题	100
第5章  索引和约束
（  教学视频：31分钟）	101
5.1  创建索引	101
5.1.1  索引的作用	101
5.1.2  索引的原理	103
5.1.3  索引的分类	104
5.1.4  创建B树索引	105
5.1.5  创建位图索引	107
5.1.6  创建函数索引	107
5.1.7  修改索引	108
5.1.8  删除索引	110
5.1.9  查看索引信息	111
5.1.10  索引创建策略	112
5.2  创建约束	112
5.2.1  约束的分类	112
5.2.2  主键约束	113
5.2.3  外键约束	115
5.2.4  检查约束	117
5.2.5  唯一性约束	119
5.3  管理约束	120
5.3.1  修改约束	120
5.3.2  禁用和启用约束	121
5.3.3  查询约束信息	123
5.4  小结	125
5.5  习题	125
第6章  视图
（  教学视频：20分钟）	126
6.1  视图基础	126
6.1.1  什么是视图	126
6.1.2  视图的分类	127
6.1.3  视图创建语法	128
6.1.4  创建简单视图	128
6.1.5  创建复杂视图	130
6.1.6  视图的修改	131
6.1.7  视图的删除	132
6.2  内联视图	133
6.2.1  什么是内联视图	133
6.2.2  内联视图的执行顺序	133
6.2.3  内联视图与DML语句	134
6.3  物化视图	135
6.3.1  什么是物化视图	135
6.3.2  创建物化视图	137
6.3.3  删除物化视图	138
6.4  小结	138
6.5  习题	139
第7章  序列和同义词
（  教学视频：15分钟）	140
7.1  使用序列	140
7.1.1  序列的作用	140
7.1.2  创建自增序列	141
7.1.3  NEXTVAL和CURRVAL伪列	143
7.1.4  使用序列编号	144
7.1.5  修改序列	145
7.1.6  删除序列	146
7.2  使用同义词	146
7.2.1  同义词的作用	146
7.2.2  创建和使用同义词	147
7.3  小结	148
7.4  习题	148
第3篇  使用SQL语言篇
第8章  SQL查询
（  教学视频：44分钟）	149
8.1  单表查询	149
8.1.1  SELECT语句	149
8.1.2  查询指定列数据	150
8.1.3  移除重复列值	151
8.1.4  表达式查询	152
8.1.5  指定查询条件	152
8.1.6  BETWEEN、IN和LIKE范围查询	154
8.1.7  处理NULL列值	157
8.1.8  AND、OR、NOT逻辑运算符	157
8.1.9  ORDER BY排序	159
8.1.10  ROWNUM伪列	161
8.1.11  ROWID伪列	163
8.1.12  使用CASE表达式	164
8.2  分组查询	167
8.2.1  分组查询简介	167
8.2.2  使用分组函数	167
8.2.3  使用GROUP BY子句分组	170
8.2.4  使用HAVING子句分组过滤	172
8.3  多表查询	173
8.3.1  多表查询分类	173
8.3.2  内连接	175
8.3.3  外连接	177
8.3.4  自引用连接	180
8.3.5  交叉连接	180
8.3.6  自然连接	181
8.4  小结	181
8.5  习题	182
第9章  操纵数据
（  教学视频：22分钟）	183
9.1  插入数据	183
9.1.1  理解DML语言	183
9.1.2  使用INSERT语句	184
9.1.3  DEFAULT和NULL值	185
9.1.4  使用子查询插入多行数据	187
9.1.5  插入多表数据	188
9.2  更新数据	190
9.2.1  使用UPDATE语句	190
9.2.2  使用RETURNING子句	191
9.2.3  使用子查询更新多行记录	192
9.2.4  使用MERGE合并数据表	193
9.3  删除数据	195
9.3.1  删除单行记录	195
9.3.2  删除多行记录	196
9.3.3  使用TRUNCATE清空表数据	197
9.4  小结	198
9.5  习题	198
第10章  Oracle内置函数
（  教学视频：39分钟）	200
10.1  函数基础	200
10.1.1  函数简介	200
10.1.2  函数的分类	201
10.2  字符型函数	202
10.2.1  字符型函数列表	202
10.2.2  大小写转换函数	203
10.2.3  字符串处理函数	203
10.2.4  字符串替代函数	204
10.3  数字型函数	205
10.3.1  数字型函数列表	205
10.3.2  数字型函数示例	206
10.4  日期时间函数	206
10.4.1  日期时间函数列表	206
10.4.2  日期时间函数示例	208
10.5  类型转换函数	208
10.5.1  类型转换函数列表	209
10.5.2  TO_CHAR将日期型转换为字符串	210
10.5.3  TO_CHAR将数字型转换为字符串	211
10.5.4  TO_DATE将字符串转换为日期	213
10.5.5  TO_NUMBER将字符串转换为数字	213
10.6  通用函数列表	213
10.7  小结	214
10.8  习题	214
第4篇  PL/SQL编程篇
第11章  PL/SQL入门
（  教学视频：19分钟）	215
11.1  PL/SQL基础	215
11.1.1  结构化程序设计	215
11.1.2  与SQL语言整合	217
11.1.3  提高程序性能	219
11.1.4  模块化应用程序开发	220
11.1.5  面向对象的开发	221
11.2  PL/SQL语言概览	223
11.2.1  PL/SQL块	223
11.2.2  变量和数据类型	225
11.2.3  程序控制语句	225
11.2.4  存储过程、函数与包	229
11.2.5  触发器简介	231
11.2.6  结构化异常处理	233
11.2.7  集合与记录	234
11.2.8  游标基础	235
11.3  小结	237
11.4  习题	237
第12章  存储子程序和包
（  教学视频：37分钟）	238
12.1  定义子程序	238
12.1.1  什么是子程序	238
12.1.2  子程序的调试	240
12.1.3  创建过程	243
12.1.4  创建函数	244
12.1.5  使用RETURN语句	246
12.1.6  查看子程序	247
12.1.7  删除子程序	249
12.2  子程序参数	250
12.2.1  形式参数与实际参数	250
12.2.2  IN、OUT和IN OUT模式	251
12.2.3  参数调用方式	253
12.3  定义PL/SQL包	254
12.3.1  什么是包（Package）	254
12.3.2  定义包规范	255
12.3.3  定义包体	257
12.3.4  调用包组件	258
12.4  小结	259
12.5  习题	260
第13章  记录与集合
（  教学视频：33分钟）	261
13.1  使用PL/SQL记录	261
13.1.1  什么是记录	261
13.1.2  定义记录类型	263
13.1.3  记录类型赋值	264
13.1.4  在DML中使用记录	266
13.2  使用集合类型	267
13.2.1  集合的分类	268
13.2.2  定义索引表	268
13.2.3  操纵索引表	270
13.2.4  定义嵌套表	271
13.2.5  操纵嵌套表	272
13.2.6  数据库中的嵌套表	273
13.2.7  定义变长数组	275
13.2.8  操纵变长数组	276
13.2.9  数据库中的变长数组	277
13.3  小结	278
13.4  习题	278
第14章  触发器和游标
（  教学视频：43分钟）	280
14.1  理解触发器	280
14.1.1  触发器的作用	280
14.1.2  触发器的分类	282
14.2  DML触发器	283
14.2.1  触发器的执行顺序	283
14.2.2  定义DML触发器	284
14.2.3  理解:OLD和:NEW谓词记录	287
14.2.4  使用REFERENCING子句	288
14.2.5  使用WHEN子句	289
14.2.6  理解自治事务	290
14.3  替代触发器	291
14.3.1  什么是替代触发器	292
14.3.2  定义替代触发器	292
14.3.3  UPDATE和DELETE替代触发器	294
14.4  系统事件触发器	295
14.4.1  定义系统事件触发器	296
14.4.2  使用DDL触发器	296
14.4.3  使用数据库触发器	298
14.4.4  SERVERERROR触发器	301
14.5  游标	302
14.5.1  什么是游标	302
14.5.2  定义游标	303
14.5.3  打开游标	305
14.5.4  提取游标数据	305
14.5.5  关闭游标	307
14.6  小结	308
14.7  习题	308
第5篇  Oracle维护篇
第15章  数据库安全性管理
（  教学视频：34分钟）	309
15.1  用户管理	309
15.1.1  用户与方案简介	309
15.1.2  创建用户	310
15.1.3  修改用户	312
15.1.4  删除用户	313
15.1.5  查询用户	313
15.1.6  在Oracle SQL Developer中管理用户	314
15.2  权限管理	315
15.2.1  理解权限	315
15.2.2  分配权限	317
15.2.3  撤销权限	319
15.2.4  查看权限	320
15.3  角色管理	321
15.3.1  角色简介	321
15.3.2  创建角色	323
15.3.3  分配权限	324
15.3.4  管理角色	324
15.3.5  查看角色	326
15.4  小结	327
15.5  习题	327
第16章  数据库空间管理
（  教学视频：24分钟）	329
16.1  理解表空间	329
16.1.1  表空间概述	329
16.1.2  表空间分类	330
16.1.3  表空间的创建	331
16.1.4  创建普通表空间	332
16.1.5  创建临时表空间	333
16.1.6  创建大文件表空间	333
16.1.7  创建撤销表空间	333
16.2  管理表空间	334
16.2.1  调整表空间大小	334
16.2.2  调整脱机和联机状态	334
16.2.3  调整只读和只写状态	335
16.2.4  更改表空间名称	335
16.2.5  删除表空间	336
16.2.6  查询表空间信息	336
16.3  小结	338
16.4  习题	338
第17章  备份和恢复数据库
（  教学视频：29分钟）	339
17.1  理解备份与恢复	339
17.1.1  什么是备份与恢复	339
17.1.2  备份与恢复的方法	340
17.2  脱机备份与恢复	340
17.2.1  理解脱机状态	340
17.2.2  脱机备份	341
17.2.3  脱机恢复	342
17.3  逻辑备份与恢复	343
17.3.1  理解数据泵	343
17.3.2  使用expdp导出数据	344
17.3.3  使用impdp导入数据	346
17.4  联机备份与恢复	348
17.4.1  设置归档日志模式	348
17.4.2  创建恢复表空间	349
17.4.3  创建RMAN用户	349
17.4.4  创建恢复目录	349
17.4.5  注册目标数据库	350
17.4.6  使用RMAN进行备份	350
17.4.7  使用RMAN进行恢复	351
17.5  小结	352
17.6  习题	352
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>从零开始学Oracle
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库问题解决方案和故障排除手册
第1 章　LOB 段性能的诊断与调优  1
1.1　LOB 数据类型的介绍  1
1.1.1　解决LOB 问题：一个真实的案例  2
1.1.2　另一个真实案例：HW 分析  4
1.1.3　BASICFILE LOB ：更完美的解决方案   7
1.2　BASICFILE 与SECUREFILE LOB  7
1.2.1　LOB 新旧类型的差异   8
1.2.2　迁移BASICFILE LOB 到SECUREFILE LOB  10
1.3　PCTFREE 对LOB 的影响  12
1.4　解决糟糕的INSERT 性能  15
1.5　总结    15
第2 章　处理undo 表空间损坏  16
2.1　undo 管理概述  16
2.1.1　UNDO_RETENTION 的重要性  16
2.1.2　优化UNDO_RETENTION  17
2.2　DTP、XA 和回滚段  18
2.3　undo 表空间损坏的恢复  20
2.3.1　预防、检测和修复损坏   20
2.3.2　处理内存损坏  21
2.3.3　处理逻辑损坏  24
2.3.4　解决介质损坏  24
2.4　总结    27
第3 章　处理全局缓存缓冲区忙等待事件   28
3.1　缓冲区忙等待事件概述  28
3.2　使用ORAchk 工具  29
3.2.1　安装ORAchk  29
3.2.2　ORAchk 执行结果：示例输出  30
3.3　查找GC 缓冲区忙等待事件   32
3.3.1　用ADDM 查找事件的信息  33
3.3.2　用AWR 查找等待事件的信息  33
3.3.3　用ASH 查找等待事件的信息  35
3.4　查找GC 缓冲区忙等待事件的原因  36
3.4.1　使用ASH 视图查找等待会话  36
3.4.2　快速查找性能瓶颈   38
3.5　解决GC 缓冲区忙等待  40
3.6　总结    41
第4 章　自适应游标共享   42
4.1　ACS 工作算法  42
4.1.1　绑定敏感与范围谓词   43
4.1.2　绑定敏感与等式谓词和直方图  45
4.1.3　绑定敏感与分区键   46
4.2　ACS 的使用    48
4.2.1　监控ACS 的绑定感知   51
4.2.2　BUCKET_ID 和COUNT 的关系  52
4.2.3　标记游标为绑定感知   55
4.3　游标绑定感知  61
4.4　一个真实案例   64
4.5　总结    69
第5 章　使用SPM 稳定查询响应时间  70
5.1　入门指南    70
5.2　创建SQL 计划基线  73
5.2.1　自动捕获计划  73
5.2.2　从游标缓存加载计划   76
5.3　伪造基线    77
5.4　Oracle 优化器和SPM 的交互   81
5.4.1　当CBO 计划与SQL 计划基线匹配时   82
5.4.2　当CBO 计划与SQL 计划基线不匹配时   84
5.4.3　当SQL 计划基线不可复制时  89
5.5　SQL 计划基线的复制性  93
5.5.1　重命名索引  93
5.5.2　修改索引类型  95
5.5.3　向索引中添加尾列   96
5.5.4　反向索引  97
5.6　NLS_SORT 与SQL 计划基线的复制性  98
5.7　ALL_ROWS 与FIRST_ROWS   100
5.8　自适应游标共享与SPM  104
5.8.1　Oracle 11.2.0.3.0 中的ACS 和SPM   105
5.8.2　Oracle 12.1.0.1.0 中的ACS 和SPM   109
5.9　总结    112
第6 章　DDL 优化技巧和技术  114
6.1　DDL 优化的概念  114
6.2　DDL 优化的机制  117
6.2.1　表基数估算  117
6.2.2　虚拟列中的C_DDL 列   119
6.2.3　列组扩展中的C_DDL 列  120
6.2.4　C_DDL 的默认值发生变化时  122
6.2.5　C_DDL 列和索引  124
6.2.6　空列的DDL 优化   126
6.3　总结    130
第7 章　管理、优化、调整大型数据库   131
7.1　大型数据库概述  131
7.2　优化基本配置   132
7.2.1　数据库仓库模板  132
7.2.2　优化数据块大小  133
7.2.3　大文件表空间  134
7.2.4　调整SGA 和PGA   135
7.2.5　临时表空间组  135
7.2.6　数据分区  136
7.2.7　本地分区索引和全局分区索引  136
7.2.8　数据压缩  137
7.2.9　表压缩  137
7.2.10　热图和自动数据优化   137
7.2.11　高级索引分区压缩   138
7.3　大型数据库性能调整的原则   139
7.3.1　真实的案例  139
7.3.2　控制索引对数据加载的影响  140
7.3.3　资源利用率的最大化   141
7.4　收集统计信息   142
7.4.1　增量统计信息摘要   142
7.4.2　并发收集统计信息   144
7.4.3　设置ESTIMATE_PERCENT 的值   145
7.5　备份与恢复的最佳实践  145
7.5.1　Exadata 解决方案  146
7.5.2　利用Data Guard 环境   147
7.6　总结    147
第8 章　RMAN 备份恢复最佳实践  148
8.1　完美的备份恢复计划  148
8.2　概述    149
8.3　数据库备份策略的技巧  149
8.3.1　完全备份和增量备份   150
8.3.2　压缩备份  150
8.3.3　增量备份  151
8.3.4　快速增量备份  151
8.3.5　Oracle 闪回技术之回退   152
8.3.6　基于磁盘的备份解决方案  153
8.3.7　增量更新的镜像副本   153
8.4　验证RMAN 备份  159
8.5　备份的优化与调整  160
8.6　RAC 集群下的RMAN  162
8.7　恢复目录    163
8.8　恢复策略    164
8.9　数据恢复顾问   165
8.10　总结    166
第9 章　使用AWR 分析优化数据库（一）  167
9.1　什么是AWR   167
9.2　知道要查找什么  168
9.3　报告头部信息   169
9.3.1　负载状况  171
9.3.2　实例效率  171
9.3.3　共享池内存  172
9.3.4　等待事件  172
9.3.5　平均负载  175
9.3.6　实例CPU  175
9.3.7　内存统计数据  176
9.4　RAC 特有的页面  176
9.4.1　RAC 统计数据  177
9.4.2　全局缓存负载统计数据   177
9.4.3　全局缓存和队列服务   177
9.4.4　集群互连  178
9.5　时间模型统计  179
9.6　操作系统统计数据  180
9.6.1　前台等待事件  181
9.6.2　后台等待事件  182
9.6.3　等待事件直方图  183
9.6.4　服务相关统计数据   184
9.7　SQL 章节    185
9.7.1　总运行时间  185
9.7.2　总CPU 时间  185
9.7.3　总缓冲区获取  186
9.7.4　总磁盘读  186
9.7.5　总执行次数  186
9.7.6　解析调用  186
9.7.7　可共享内存  187
9.7.8　版本数  187
9.7.9　集群等待时间  187
9.8　实例活动统计   188
9.8.1　一致性读统计数据   191
9.8.2　数据块读统计数据   191
9.8.3　脏块统计  191
9.8.4　队列统计  191
9.8.5　执行计数  191
9.8.6　空闲缓冲区统计  192
9.8.7　全局缓存统计  192
9.8.8　索引扫描统计数据   192
9.8.9　叶子节点统计数据   193
9.8.10　打开的游标  193
9.8.11　解析统计数据  193
9.8.12　物理读写统计数据   193
9.8.13　递归统计数据  195
9.8.14　重做相关的统计数据   195
9.8.15　会话游标统计数据   196
9.8.16　排序统计数据  196
9.8.17　脏队列长度汇总   196
9.8.18　表获取统计数据   197
9.8.19　事务回滚  197
9.8.20　撤销更改矢量统计   197
9.8.21　用户统计数据  198
9.8.22　工作区统计数据   198
9.8.23　实例活动统计——绝对值  198
9.8.24　实例活动统计——线程活动  199
9.9　总结    199
第10 章　使用AWR 分析优化数据库（二）  200
10.1　表空间I/O 统计数据  200
10.2　缓冲池    202
10.2.1　缓冲池统计数据   203
10.2.2　实例恢复统计数据   203
10.2.3　缓冲池建议部分   204
10.3　PGA 统计数据  204
10.3.1　PGA 汇总  206
10.3.2　PGA 总目标统计数据   206
10.3.3　PGA 总目标直方图   206
10.3.4　PGA 内存建议  208
10.4　共享池统计数据  208
10.5　其他建议    209
10.5.1　SGA 目标建议  210
10.5.2　流池建议  210
10.5.3　Java 池建议  211
10.6　缓冲区等待统计数据  211
10.7　队列统计数据  212
10.8　撤销段统计数据  214
10.9　闩锁统计数据  215
10.9.1　闩锁活动  216
10.9.2　闩锁休眠分类  217
10.9.3　闩锁和自旋数  217
10.9.4　闩锁丢失源  218
10.9.5　互斥锁休眠汇总   218
10.9.6　父类和子类闩锁   218
10.10　段访问区   218
10.11　库缓存活动部分  220
10.12　动态内存组件部分  223
10.13　进程内存部分  224
10.13.1　进程内存汇总  226
10.13.2　SGA 内存汇总  226
10.13.3　SGA 分类和差异   226
10.14　流组件部分   226
10.15　资源限制统计数据  228
10.16　初始化参数的改变  228
10.17　全局队列和其他RAC 部分   229
10.17.1　全局队列统计数据   233
10.17.2　全局CR 服务统计数据  233
10.17.3　全局当前服务统计数据  233
10.17.4　全局缓存传输统计数据  233
10.17.5　全局缓存传输时间   233
10.17.6　全局缓存传输  233
10.17.7　全局缓存时间  234
10.17.8　互连ping 延迟统计数据  234
10.17.9　客户端的互连吞吐量   234
10.17.10　互联设备统计数据   234
10.18　总结    234
第11 章　RAC 的故障诊断  236
11.1　RAC 的故障诊断和调优   236
11.1.1　ORAchk 工具  237
11.1.2　TFA 收集器  237
11.1.3　自动诊断库  237
11.1.4　告警和跟踪日志文件   237
11.2　运转良好的RAC 生态系统   239
11.2.1　最高可用性架构  239
11.2.2　优化和高效的RAC 数据库  240
11.2.3　基于OEM 12C 的RAC 故障诊断   241
11.2.4　故障诊断的程序和命令   242
11.3　总结    247
第12 章　利用SQL 顾问来分析和修复SQL 问题  248
12.1　OEM 12c ：SQL 顾问首页   248
12.2　SQL 调优顾问  249
12.2.1　在OEM 12c 中运行SQL 调优顾问   250
12.2.2　在SQL*Plus 中手动运行SQL 调优顾问  253
12.3　SQL 访问顾问  253
12.3.1　在OEM 12c 中运行SQL 访问顾问   254
12.3.2　在SQL*Plus 中手动运行SQL 访问顾问  257
12.4　SQL 修复顾问  258
12.5　SQL 性能分析器  259
12.6　总结    260
第13 章　使用数据泵迁移数据和对象   261
13.1　使用数据泵   261
13.1.1　复制对象  262
13.1.2　数据泵模式  263
13.2　处理私有和公共对象  263
13.2.1　保存和恢复数据库链接  264
13.2.2　导出公共数据库链接和同义词  264
13.2.3　验证导出的转储文件内容  265
13.3　查找有效的INCLUDE 和EXCLUDE 值   265
13.4　导出数据子集  267
13.5　修改对象属性  269
13.5.1　将分区表导入为非分区表  269
13.5.2　将表分区导入为单独的表  269
13.5.3　屏蔽数据  270
13.5.4　重命名表或使用不同的表空间  270
13.5.5　使用默认存储参数   270
13.5.6　导入期间调整表空间大小  271
13.5.7　合并多个表空间   271
13.6　通过PL/SQL API 使用Data Pump  273
13.7　监控和修改资源  274
13.8　提升性能    275
13.9　升级数据库   276
13.10　总结    277
第14 章　数据库快速迁移数据的策略   278
14.1　为什么要迁移  278
14.2　确定最好的策略  279
14.2.1　实时与准实时迁移   279
14.2.2　接受只读  279
14.2.3　可逆性  280
14.3　考虑迁移什么数据  280
14.4　数据迁移的方法  281
14.4.1　事务性捕获迁移方法   281
14.4.2　非事务性迁移方法   283
14.4.3　其他迁移方法  295
14.5　总结    301
第15 章　临时文件I/O 问题的诊断和恢复  302
15.1　临时表空间概述  302
15.1.1　只读数据库  303
15.1.2　本地管理的临时表空间  303
15.1.3　临时表空间组  303
15.1.4　全局临时表  304
15.2　解决TEMPFILE I/O 等待   307
15.2.1　过小的PGA  307
15.2.2　不恰当的TEMPFILE 扩展区大小   311
15.2.3　不恰当地使用GTT   312
15.3　总结    312
第16 章　处理闩锁和互斥锁争用  313
16.1　闩锁和互斥锁架构概述  313
16.1.1　什么是闩锁  314
16.1.2　什么是互斥锁  315
16.1.3　闩锁和互斥锁的内部结构  315
16.2　检测闩锁和互斥锁争用  316
16.2.1　识别独特的闩锁   317
16.2.2　查找段和SQL 语句   318
16.3　闩锁和互斥锁场景  320
16.3.1　库缓存互斥锁等待   320
16.3.2　library cache pin  322
16.3.3　共享池闩锁  322
16.3.4　缓存缓冲区链闩锁   323
16.3.5　其他的闩锁场景   325
16.4　棘手的闩锁争用  326
16.5　总结    328
第17 章　使用SSD 解决I/O 瓶颈  329
17.1　磁盘技术：SSD 与 HDD   329
17.1.1　固态闪存盘的崛起   330
17.1.2　SSD 闪存的延迟   331
17.1.3　SSD 的经济性  332
17.1.4　SLC、MLC 和TLC   333
17.1.5　写性能与寿命  334
17.1.6　垃圾回收和磨损均衡   334
17.1.7　SATA 与 PCIe SSD   336
17.1.8　在Oracle 数据库中使用SSD  336
17.2　Oracle 数据库的闪存缓存   337
17.2.1　空闲缓冲区等待   337
17.2.2　配置和监控DBFC   339
17.2.3　使用FLASH_CACHE 子句  340
17.2.4　闪存缓存的性能统计数据  341
17.3　比较SSD 的部署选择  342
17.3.1　索引读  343
17.3.2　OLTP 上的读/ 写负载   344
17.3.3　全表扫描性能  344
17.3.4　SSD 本地缓存和全表扫描  345
17.3.5　磁盘排序和散列操作   346
17.3.6　重做日志的优化   349
17.4　存储分层    349
17.5　闪存和Exadata  353
17.6　总结    357
第18 章　为最佳性能设计和监控索引   359
18.1　索引的类型   359
18.1.1　B 树索引  359
18.1.2　位图索引  362
18.1.3　分区索引  364
18.1.4　其他索引类型  366
18.2　同一列上的多个索引  368
18.3　索引的性能问题  369
18.3.1　索引统计信息  369
18.3.2　高集群因子的影响   372
18.3.3　索引操作的注意事项   373
18.3.4　隐藏非选择的索引   374
18.3.5　RAC 数据库中的索引性能问题  375
18.4　总结    377
第19 章　使用SQLT 提升查询性能   379
19.1　安装SQLT   379
19.2　使用XTRACT 方法  380
19.3　使用XECUTE 方法  381
19.4　其他SQLT 方法  384
19.5　一个真实的案例  385
19.6　总结    386
第20 章　处理XA 分布式事务的问题   387
20.1　修复常见的分布式事务问题   387
20.2　修复幽灵分布式事务  388
20.2.1　信息存在，但事务不在  389
20.2.2　ORA-1591 没有对应的信息  389
20.2.3　提交或回滚之后事务挂起  391
20.3　监控分布式事务  393
20.4　总结    395
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库问题解决方案和故障排除手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 12c性能优化攻略
《Oracle Database 12c性能优化攻略》
第1章　优化表性能　　1
攻略1-1　创建具有最优性能的数据库　　2
攻略1-2　创建具有最优性能的表空间　　6
攻略1-3　匹配表类型与业务需求　　8
攻略1-4　选择有益于性能的表特性　　9
攻略1-5　恰当选择数据类型　　10
攻略1-6　在创建数据表时避免盘区分配延迟　　15
攻略1-7　数据加载速度最大化　　17
攻略1-8　高效移除表中数据　　19
攻略1-9　显示自动段顾问建议　　21
攻略1-10　手工生成段顾问建议　　24
攻略1-11　自动发送段顾问输出电子邮件　　27
攻略1-12　重建跨多个数据块的数据行　　28
攻略1-13　检测行链接和行迁移　　32
攻略1-14　区分行迁移和行链接　　34
攻略1-15　积极预防行迁移/行链接的产生　　35
攻略1-16　检测表中未使用的空间　　36
攻略1-17　追踪检测到的位于高水位线下的空间　　37
攻略1-18　使用DBMS_SPACE来检测位于高水位线之下的空间　　38
攻略1-19　释放未使用的表存储空间　　40
攻略1-20　压缩数据以进行直接路径加载　　41
攻略1-21　为所有DML操作压缩数据　　44
攻略1-22　在列级压缩数据　　45
第2章　选择和优化索引　　47
攻略2-1　理解B树索引　　49
攻略2-2　选择需要建立索引的列　　54
攻略2-3　创建主键约束和索引　　57
攻略2-4　确保唯一列值　　59
攻略2-5　为外键列创建索引　　61
攻略2-6　决定何时使用组合索引　　65
攻略2-7　通过压缩减少索引大小　　67
攻略2-8　实现基于函数的索引　　68
攻略2-9　在虚拟列上创建索引　　70
攻略2-10　在多个进程并行插入时限制索引争夺　　71
攻略2-11　触发索引对优化器的可见性　　72
攻略2-12　创建支持星型架构的位图索引　　74
攻略2-13　创建位图连接索引　　77
攻略2-14　创建索引组织表　　78
攻略2-15　监控索引使用　　79
攻略2-16　索引创建速度最大化　　80
攻略2-17　回收未使用的索引空间　　82
第3章　优化实例内存　　85
攻略3-1　自动内存管理　　85
攻略3-2　管理多个缓冲池　　88
攻略3-3　设定内存最小值　　90
攻略3-4　监控内存调整操作　　91
攻略3-5　优化内存使用　　93
攻略3-6　调优PGA内存分配　　94
攻略3-7　配置服务器查询缓存　　97
攻略3-8　管理服务器结果缓存　　99
攻略3-9　缓存SQL查询结果　　101
攻略3-10　缓存客户端结果集　　105
攻略3-11　缓存PL/SQL函数结果　　107
攻略3-12　配置Oracle数据库智能闪存缓存　　110
攻略3-13　调节重做日志缓冲区　　112
攻略3-14　限制PGA内存分配　　113
第4章　监控系统性能　　115
攻略4-1　实现AWR　　116
攻略4-2　修改统计信息时间间隔和保存期限　　118
攻略4-3　手工生成AWR报表　　119
攻略4-4　通过企业管理器生成一份AWR报告　　122
攻略4-5　为一条SQL语句生成AWR报告　　124
攻略4-6　为数据库创建统计基线　　125
攻略4-7　通过企业管理器管理AWR基线　　129
攻略4-8　管理AWR统计信息库　　131
攻略4-9　自动创建AWR基线　　133
攻略4-10　快速分析AWR输出　　134
攻略4-11　手工获取活动会话信息　　136
攻略4-12　从企业管理器中获取ASH信息　　140
攻略4-13　从数据字典中获取ASH信息　　142
第5章　最小化系统资源争夺　　145
攻略5-1　理解响应时间　　145
攻略5-2　确定引起最多等待的SQL语句　　148
攻略5-3　分析等待事件　　149
攻略5-4　理解等待事件的分类　　150
攻略5-5　检查会话等待　　151
攻略5-6　按类型检查等待事件　　153
攻略5-7　解决缓冲区忙等待　　155
攻略5-8　解决日志文件同步等待　　157
攻略5-9　被另一个会话读取等待事件的最小化　　158
攻略5-10　减少直接路径读取等待事件　　160
攻略5-11　恢复写入器等待最小化　　161
攻略5-12　找出谁持有阻塞锁　　162
攻略5-13　确定被阻塞和引起阻塞的会话　　164
攻略5-14　处理引起阻塞的锁　　166
攻略5-15　确定被锁定的对象　　167
攻略5-16　解决enq:TM锁资源争夺　　168
攻略5-17　确定最近被锁住的会话　　170
攻略5-18　分析数据库中最近的等待事件　　173
攻略5-19　确定由于锁定所花费的等待时间　　174
攻略5-20　锁存器争夺的最小化　　176
第6章　分析操作系统性能　　180
攻略6-1　检测磁盘空间问题　　182
攻略6-2　确定系统瓶颈　　185
攻略6-3　确定消耗服务器资源最多的进程　　187
攻略6-4　检测CPU瓶颈　　189
攻略6-5　确定CPU和内存瓶颈　　190
攻略6-6　确定I/O瓶颈　　191
攻略6-7　检测网络密集型进程　　194
攻略6-8　将一个资源密集型进程映射到一个数据库进程　　196
攻略6-9　终止一个资源密集型进程　　198
第7章　检修数据库　　201
攻略7-1　确定最优的撤销保留时间　　201
攻略7-2　找出是什么消耗了最多的撤销空间　　206
攻略7-3　解决ORA-01555错误　　207
攻略7-4　监控临时表空间使用率　　209
攻略7-5　确定是谁在使用临时表空间　　210
攻略7-6　解决“无法扩展临时数据段”错误　　212
攻略7-7　解决打开游标错误　　213
攻略7-8　解决被挂起的数据库问题　　215
攻略7-9　激活自动诊断库命令解释器　　219
攻略7-10　从ADRCI中来查看报警日志　　223
攻略7-11　使用ADRCI查看事件　　225
攻略7-12　将事件打包发给Oracle技术支持团队　　227
攻略7-13　运行一次数据库健康检查　　228
攻略7-14　创建SQL测试用例　　230
攻略7-15　生成一份AWR报告　　233
攻略7-16　比较两个阶段的数据库性能　　235
攻略7-17　分析一份AWR报告　　237
第8章　创建高效的SQL　　241
攻略8-1　获取一张表中的所有数据行　　242
攻略8-2　获取一张表中的部分数据行　　243
攻略8-3　通过相对应的行来连接表　　245
攻略8-4　在没有相对应数据行的情况下连接表　　248
攻略8-5　构造简单的子查询　　251
攻略8-6　构建相关子查询　　254
攻略8-7　比较两个表找出缺失的数据行　　256
攻略8-8　比较两张表找出匹配的数据行　　258
攻略8-9　将相似SELECT语句的结果集合并　　259
攻略8-10　查找一定范围内的值　　261
攻略8-11　处理空值　　264
攻略8-12　搜索部分列值　　267
攻略8-13　重用共享池中的SQL语句　　270
攻略8-14　避免偶然的全表扫描　　275
攻略8-15　创建高效的临时视图　　276
攻略8-16　避免使用NOT子句　　279
攻略8-17　控制事务大小　　281
第9章　SQL手工调优　　284
攻略9-1　显示查询的执行计划　　285
攻略9-2　定制执行计划输出　　287
攻略9-3　图形化显示执行计划　　290
攻略9-4　解读一份执行计划　　291
攻略9-5　监控运行时间较长的SQL语句　　294
攻略9-6　确定当前正在执行的耗占资源的SQL语句　　295
攻略9-7　查看当前正在运行的SQL语句的统计信息　　296
攻略9-8　监控一个SQL执行计划的处理过程　　299
攻略9-9　确定过去执行的SQL语句中最耗占资源的语句　　302
攻略9-10　比较系统修改后的SQL性能　　304
第10章　追踪SQL执行　　309
攻略10-1　环境准备　　309
攻略10-2　追踪一个特定的SQL语句　　311
攻略10-3　在你所拥有的会话中启用追踪　　313
攻略10-4　找到追踪文件　　314
攻略10-5　检查原始SQL追踪文件　　315
攻略10-6　分析Oracle追踪文件　　316
攻略10-7　使用TKPROF设置追踪文件的格式　　317
攻略10-8　分析TKPROF输出　　318
攻略10-9　使用Oracle追踪分析器分析追踪文件　　321
攻略10-10　追踪一个并行查询　　324
攻略10-11　追踪特定的并行查询进程　　325
攻略10-12　在RAC系统中追踪并行查询　　326
攻略10-13　合并多个追踪文件　　327
攻略10-14　找出正确的会话来进行追踪　　328
攻略10-15　追踪一个SQL会话　　329
攻略10-16　通过进程ID来追踪会话　　330
攻略10-17　追踪多个会话　　331
攻略10-18　追踪一个实例或数据库　　332
攻略10-19　为会话生成事件10046追踪　　333
攻略10-20　为实例生成事件10046追踪　　335
攻略10-21　在一个正在运行的会话上设置追踪　　336
攻略10-22　登录之后启用会话追踪　　337
攻略10-23　追踪优化器的执行路径　　337
攻略10-24　生成Oracle错误自动追踪　　340
攻略10-25　追踪后台进程　　341
攻略10-26　启用Oracle监听器追踪　　342
攻略10-27　为数据卫士设置归档追踪　　343
第11章　SQL自动调优　　345
攻略11-1　显示自动SQL调优工作详细信息　　347
攻略11-2　显示SQL自动调优建议　　349
攻略11-3　生成SQL脚本来实现自动调优建议　　352
攻略11-4　修改SQL自动调优特性　　353
攻略11-5　禁用和启用SQL自动调优　　355
攻略11-6　修改维护窗口属性　　357
攻略11-7　创建SQL调优集对象　　358
攻略11-8　查看AWR中的资源密集型SQL语句　　359
攻略11-9　用AWR中高资源消耗的SQL来填充优化集　　361
攻略11-10　查看内存中的资源密集型SQL语句　　363
攻略11-11　用内存中高资源消耗的SQL来填充调优集　　365
攻略11-12　将内存中所有SQL语句填充到SQL调优集　　366
攻略11-13　显示SQL调优集的内容　　367
攻略11-14　有选择地从SQL调优集中删除语句　　369
攻略11-15　传输SQL调优集　　370
攻略11-16　创建调优任务　　372
攻略11-17　手工运行SQL调优顾问　　375
攻略11-18　从数据库自动诊断监视器中获得SQL调优建议　　378
第12章　执行计划优化与一致性　　381
攻略12-1　创建并接受SQL概要文件　　385
攻略12-2　确认某个查询是否使用了SQL概要文件　　389
攻略12-3　自动接受SQL概要文件　　390
攻略12-4　显示SQL概要文件信息　　392
攻略12-5　选择性测试SQL概要文件　　393
攻略12-6　将SQL概要文件迁移到另一个数据库中　　394
攻略12-7　禁用SQL概要文件　　396
攻略12-8　删除SQL概要文件　　397
攻略12-9　为内存中的一条SQL语句创建计划基线　　398
攻略12-10　为包含在SQL调优集中的SQL语句创建计划基线　　400
攻略12-11　自动增加计划基线　　403
攻略12-12　修改计划基线　　404
攻略12-13　确认是否存在计划基线　　405
攻略12-14　确认某个查询是否使用了计划基线　　407
攻略12-15　显示计划基线执行计划　　408
攻略12-16　手工在计划基线中加入一个新的计划（扩展）　　409
攻略12-17　阻止自动接受新的低成本执行计划　　412
攻略12-18　禁用计划基线　　412
攻略12-19　移除计划基线信息　　413
攻略12-20　迁移计划基线　　414
第13章　优化器配置　　417
攻略13-1　选择优化器目标　　417
攻略13-2　启用统计信息自动收集　　418
攻略13-3　为统计信息收集设置首选参数　　420
攻略13-4　手工生成统计信息　　425
攻略13-5　锁定统计信息　　427
攻略13-6　处理统计信息的缺失　　428
攻略13-7　导出统计信息　　430
攻略13-8　还原以前版本的统计信息　　432
攻略13-9　收集系统统计信息　　433
攻略13-10　验证新的统计信息　　436
攻略13-11　强制优化器使用某个索引　　438
攻略13-12　启用查询优化器特性　　439
攻略13-13　阻止数据库创建柱状图　　441
攻略13-14　不使用绑定变量提高性能　　442
攻略13-15　理解自适应游标共享　　445
攻略13-16　在表达式上创建统计信息　　449
攻略13-17　为相关列创建统计信息　　451
攻略13-18　自动创建列组　　452
攻略13-19　维护分区表统计信息　　453
攻略13-20　为大表并行收集统计信息　　454
攻略13-21　确定统计信息何时过期　　456
攻略13-22　预览统计信息收集对象　　457
第14章　实现查询提示　　460
攻略14-1　编写一个提示　　460
攻略14-2　改变访问路径　　462
攻略14-3　改变连接顺序　　465
攻略14-4　改变连接方法　　467
攻略14-5　改变优化器版本　　469
攻略14-6　在快速响应和整体优化之间进行选择　　470
攻略14-7　进行直接路径插入　　473
攻略14-8　在视图中加入提示　　476
攻略14-9　缓存查询结果　　478
攻略14-10　将分布式查询引导到一个特定的数据库　　482
攻略14-11　收集查询执行的扩展统计信息　　485
攻略14-12　启用查询改写　　487
攻略14-13　提升星型架构查询的性能　　489
第15章　并行执行SQL　　492
攻略15-1　为特定查询启用并行　　492
攻略15-2　在创建对象时启用并行　　496
攻略15-3　为已经存在的对象启用并行　　497
攻略15-4　实现并行DML　　498
攻略15-5　并行创建表　　501
攻略15-6　并行创建索引　　503
攻略15-7　并行重建索引　　504
攻略15-8　并行移动分区　　506
攻略15-9　并行拆分分区　　508
攻略15-10　启用自动并行度　　509
攻略15-11　检查并行解释计划　　512
攻略15-12　监控并行操作　　515
攻略15-13　找出并行进程中的瓶颈　　517
攻略15-14　获取并行会话的详细信息　　518
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 12c性能优化攻略
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>OCP认证考试指南 1ZO-063 Oracle Database 12c 高级管理
第1章 数据库备份解决方案和ASM 1
1.1 解释Oracle的备份和恢复解决方案 2
1.1.1 Oracle逻辑存储结构 2
1.1.2 Oracle物理存储结构 4
1.1.3 Oracle内存结构 8
1.1.4 描述ASM 13
1.1.5 ASM体系结构 13
1.1.6 数据库故障和备份解决方案 16
1.2 本章小结 18
1.3 本章知识点回顾 18
1.4 自测题 19
1.5 自测题答案 21
第2章 配置数据库可恢复性 23
2.1 配置和管理RMAN设置 24
2.1.1 逻辑备份 24
2.1.2 物理备份 25
2.1.3 RMAN命令简介 27
2.2 配置快速恢复区 32
2.2.1 定义快速恢复区的大小和位置 32
2.2.2 监视和管理快速恢复区 35
2.3 配置控制文件和重做日志文件来提高可恢复性 36
2.3.1 配置ARCHIVELOG模式 37
2.3.2 利用多个归档目标 38
2.4 备份和恢复NOARCHIVELOG数据库 40
2.5 本章小结 41
2.6 本章知识点回顾 41
2.7 自测题 43
2.8 自测题答案 46
第3章 使用RMAN恢复目录 49
3.1 创建和使用RMAN恢复目录 50
3.1.1 使用控制文件来保存RMAN元数据 50
3.1.2 使用恢复目录来保存RMAN元数据 50
3.1.3 配置恢复目录数据库 51
3.1.4 创建恢复目录所有者 51
3.1.5 创建恢复目录 52
3.1.6 同步恢复目录 52
3.1.7 创建和使用RMAN存储脚本 60
3.2 保护RMAN恢复目录 63
3.2.1 备份恢复目录 63
3.2.2 在丢失恢复目录后进行恢复 64
3.2.3 导出和导入恢复目录 64
3.2.4 删除恢复目录 65
3.2.5 更新恢复目录 65
3.3 创建和使用虚拟专用目录 66
3.3.1 了解虚拟专用目录 66
3.3.2 创建和管理虚拟专用目录 66
3.4 本章小结 68
3.5 本章知识点回顾 69
3.6 自测题 71
3.7 自测题答案 73
第4章 创建高级RMAN备份 77
4.1 使用多种RMAN备份类型和策略 78
4.1.1 RMAN备份的类型 78
4.1.2 RMAN备份目标 80
4.1.3 持久保存RMAN设置 80
4.1.4 自动备份控制文件 83
4.1.5 分配备份通道 83
4.2 执行完全和增量备份 83
4.2.1 创建备份集 85
4.2.2 创建映像副本 87
4.2.3 完整数据库备份 88
4.2.4 完全备份 89
4.2.5 增量备份 90
4.3 使用技术改进备份 93
4.3.1 了解块更改跟踪文件 94
4.3.2 启用快速增量备份 95
4.3.3 监视块更改跟踪文件 96
4.3.4 创建多路复用备份集 96
4.3.5 创建备份集的备份 97
4.3.6 备份只读表空间 97
4.3.7 了解归档备份 97
4.3.8 创建多段备份 99
4.3.9 压缩备份 102
4.3.10 加密备份 103
4.4 管理备份 106
4.4.1 使用LIST命令 106
4.4.2 使用REPORT命令 107
4.4.3 使用DELETE命令 108
4.4.4 使用CROSSCHECK命令 109
4.5 执行非数据库文件的备份 109
4.5.1 备份控制文件 110
4.5.2 备份ASM元数据 111
4.5.3 记录其他备份文件 112
4.6 本章小结 112
4.7 本章知识点回顾 113
4.8 自测题 116
4.9 自测题答案 121
第5章 使用RMAN备份进行恢复 125
5.1 描述和调整实例恢复 127
5.2 执行完整和不完整恢复 128
5.2.1 使用RMAN RESTORE和RECOVER命令 128
5.2.2 为不重要的文件执行完整恢复 128
5.2.3 执行重要数据文件的完整恢复 130
5.2.4 使用RMAN执行不完整恢复 131
5.2.5 使用增量更新备份进行恢复 135
5.2.6 切换使用映像副本以便加快恢复速度 136
5.3 执行SPFILE、口令文件、控制文件和重做日志文件的恢复 142
5.3.1 从自动备份还原SPFILE 142
5.3.2 从自动备份还原控制文件 143
5.3.3 在丢失重做日志组时进行恢复 146
5.3.4 了解日志组状态 146
5.3.5 在发生日志组成员故障后进行恢复 147
5.3.6 在丢失整个日志组时进行恢复 148
5.3.7 在丢失口令文件后进行恢复 150
5.3.8 恢复控制文件 153
5.4 执行索引和只读表空间和临时文件的恢复 155
5.5 将数据库还原到新主机上 157
5.5.1 了解还原到新主机的含义 157
5.5.2 准备新主机 157
5.5.3 在新主机上执行还原和恢复 157
5.6 本章小结 159
5.7 本章知识点回顾 161
5.8 自测题 163
5.9 自测题答案 168
第6章 诊断数据库故障及ADR 171
6.1 自动诊断工作流程 172
6.1.1 了解ADR 172
6.1.2 使用ADRCI工具 174
6.1.3 了解警报、问题和事件 177
6.1.4 使用Health Monitor 177
6.2 处理块损坏 180
6.2.1 了解受损块 180
6.2.2 使用DB_BLOCK_CHECKING参数 180
6.2.3 使用块介质恢复方法 181
6.2.4 使用Data Recovery Advisor 183
6.3 本章小结 184
6.4 本章知识点回顾 185
6.5 自测题 186
6.6 自测题答案 187
第7章 加密、保护、监视和调整 RMAN备份 189
7.1 创建RMAN加密备份 190
7.1.1 配置和使用透明加密 190
7.1.2 使用口令加密 192
7.1.3 使用双模式加密 193
7.2 配置和使用Oracle安全备份 193
7.2.1 Oracle安全备份概述 194
7.2.2 安装和配置Oracle安全备份 194
7.2.3 使用RMAN和Oracle 安全备份 196
7.2.4 各个obtool命令 196
7.3 调整RMAN性能 198
7.4 调整RMAN性能 203
7.4.1 确定备份和还原步骤 204
7.4.2 并行执行备份集 204
7.4.3 了解RMAN多路复用操作 205
7.4.4 调整RMAN通道 206
7.4.5 调整BACKUP命令 206
7.4.6 配置LARGE_POOL_SIZE 206
7.5 本章小结 207
7.6 本章知识点回顾 207
7.7 自测题 208
7.8 自测题答案 211
第8章 配置和使用闪回功能 213
8.1 闪回技术 214
8.1.1 闪回类型和从属项 214
8.1.2 配置闪回参数 215
8.2 使用闪回查询数据 216
8.2.1 使用闪回查询 216
8.2.2 使用闪回版本查询 218
8.3 执行闪回表操作 221
8.3.1 利用回收站 221
8.3.2 了解闪回表 229
8.3.3 了解闪回事务查询 231
8.4 使用备份执行表恢复 233
8.4.1 从备份恢复表的场景 234
8.4.2 使用备份执行表恢复的先决条件和限制 234
8.4.3 使用备份执行表恢复 234
8.5 Flashback Data Archive简介及其使用 235
8.5.1 了解Flashback Data Archive 235
8.5.2 创建归档 236
8.5.3 使用Flashback Data Archive数据字典视图 237
8.5.4 指定Flashback Data Archive权限 237
8.5.5 管理Flashback Data Archive 237
8.5.6 将表分配到Flashback Data Archive 238
8.5.7 查询Flashback Data
Archive 238
8.6 执行闪回数据库 239
8.6.1 了解闪回数据库 239
8.6.2 配置闪回数据库 240
8.6.3 使用闪回数据库 240
8.7 本章小结 243
8.8 本章知识点回顾 244
8.9 自测题 247
8.10 自测题答案 250
第9章 传输及复制表空间和数据库 253
9.1 描述和使用可传输表空间和数据库 254
9.1.1 配置可传输表空间 254
9.1.2 传输表空间 256
9.2 选择一种数据库复制技术 267
9.2.1 跨平台数据传输 267
9.2.2 使用映像副本进行数据传输 267
9.2.3 使用RMAN备份集进行数据库传输 267
9.3 创建基于备份的副本数据库 268
9.3.1 使用RMAN创建副本数据库 268
9.3.2 使用副本数据库 270
9.4 基于运行实例复制数据库 270
9.4.1 配置辅助实例 271
9.4.2 创建初始化参数文件 271
9.4.3 在NOMOUNT模式下启动辅助实例并创建SPFILE 272
9.4.4 在MOUNT或OPEN模式下启动源数据库 273
9.4.5 为DUPLICATE命令创建备份 274
9.4.6 必要时分配辅助通道 274
9.4.7 运行RMAN DUPLICATE命令 274
9.5 本章小结 276
9.6 本章知识点回顾 277
9.7 自测题 278
9.8 自测题答案 279
第10章 多租户数据库的架构 281
10.1 多租户架构 282
10.1.1 利用多租户数据库 282
10.1.2 了解多租户配置 283
10.2 可插入数据库的配置 285
10.3 本章小结 287
10.4 本章知识点回顾 288
10.5 自测题 289
10.6 自测题答案 290
第11章 创建多租户容器数据库和可插入数据库 291
11.1 配置和创建CDB 292
11.1.1 使用不同的方法创建CDB 292
11.1.2 了解新的数据字典视图 299
11.2 使用不同的方法创建PDB 301
11.2.1 使用PDB$SEED 创建新的PDB 301
11.2.2 克隆PDB，以创建新的PDB 303
11.2.3 把非CDB插入CDB 304
11.2.4 把拔出的PDB插入CDB 307
11.3 拔出和删除PDB 307
11.3.1 使用不同的方法拔出一个PDB 308
11.3.2 删除PDB 309
11.4 把12.1版本以前的非CDB数据库迁移到CDB 310
11.4.1 使用升级方法来迁移非CDB 310
11.4.2 使用Data Pump方法来迁移非CDB 310
11.4.3 使用数据库链接方法来迁移非CDB 310
11.5 本章小结 310
11.6 本章知识点回顾 311
11.7 自测题 312
11.8 自测题答案 313
第12章 管理CDB和PDB 315
12.1 建立到CDB和PDB的连接 316
12.1.1 了解CDB 和 PDB 服务名 316
12.1.2 使用SQL Developer连接到CDB或PDB 318
12.1.3 为CDB或PDB创建服务 318
12.1.4 在CDB中切换连接 319
12.2 启动和关闭CDB，以及
打开和关闭PDB 320
12.2.1 CDB 实例的启动 320
12.2.2 打开和关闭PDB 322
12.2.3 CDB 实例的关闭 324
12.2.4 自动启动PDB 325
12.2.5 改变PDB 的状态 326
12.3 评估参数值变化的影响 327
12.3.1 了解参数变化的范围 327
12.3.2 在多租户环境中使用ALTER SYSTEM 327
12.4 管理CDB和PDB中的永久和临时表空间 328
12.5 管理公共用户和本地用户 331
12.6 管理公共权限和本地权限 332
12.7 管理公共角色和本地角色 334
12.8 允许公共用户访问特定PDB中的数据 334
12.9 本章小结 336
12.10 本章知识点回顾 337
12.11 自测题 339
12.12 自测题答案 341
第13章 备份与恢复CDB和PDB 345
13.1 执行CDB和PDB的备份 346
13.1.1 备份CDB 349
13.1.2 备份PDB 351
13.2 在丢失PDB数据文件后恢复PDB 353
13.2.1 恢复临时文件 353
13.2.2 在丢失控制文件后恢复 354
13.2.3 在丢失重做日志文件后恢复 357
13.2.4 在丢失根数据文件后恢复 357
13.2.5 从PDB数据文件恢复 359
13.3 使用数据恢复顾问 361
13.3.1 数据故障 361
13.3.2 PITR场景 365
13.3.3 使用闪回CDB 365
13.3.4 识别块损坏 366
13.4 使用RMAN复制PDB 367
13.5 本章小结 367
13.6 本章知识点回顾 368
13.7 自测题 369
13.8 自测题答案 370
第14章 管理性能 373
第15章 有关实用程序：Data Pump、SQL*Loader和审核 391
术语表 407
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>OCP认证考试指南 1ZO-063 Oracle Database 12c 高级管理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库备份、恢复与迁移
出版说明
前言
第 1 章 Oracle 体系结构 1
1.1 实例的结构 2
1.1.1 实例的概念 2
1.1.2 实例的组成 3
1.2 实例中的内存结构 4
1.2.1 数据库缓冲区缓存 6
1.2.2 重做日志缓冲区 10
1.2.3 共享池 11
1.2.4 Java 池 15
1.2.5 固定 SGA 16
1.2.6 PGA 16
1.3 前台进程和后台进程 18
1.3.1 前台进程 19
1.3.2 后台进程 DBWR 19
1.3.3 后台进程 LGWR 20
1.3.4 后台进程 CKPT 23
1.3.5 后台进程 SMON 24
1.3.6 后台进程 PMON 25
1.3.7 后台进程 ARCH 25
1.3.8 数据库的实例恢复 26
1.4 实例的内存空间管理 28
1.4.1 自动内存管理 28
1.4.2 自动共享内存管理 29
1.4.3 手工共享内存管理 31
1.5 数据库的连接模式 32
1.5.1 连接与会话 32
1.5.2 专用服务器连接模式 34
1.5.3 共享服务器连接模式 35
1.5.4 如何设置共享连接模式 37
1.5.5 数据库服务器的远程连接 38
第 2 章 数据库的物理结构和逻辑结构 44
2.1 数据库的逻辑结构 44
2.1.1 什么是表空间 45
2.1.2 什么是段 46
2.1.3 什么是区 47
2.1.4 什么是数据块 47
2.2 表空间与数据文件 47
2.2.1 什么是数据文件 47
2.2.2 数据库中默认存在哪些表空间 48
2.2.3 表空间的创建与删除 50
2.2.4 表空间的扩展 52
2.2.5 表空间状态的改变 55
2.2.6 数据文件的移动——一种简单的数据迁移 56
2.2.7 使用非标准块的表空间 58
2.2.8 临时表空间的管理 59
2.2.9 UNDO 表空间的管理 61
2.3 段的空间管理 62
2.3.1 段的空间分配 63
2.3.2 段的空间回收 66
2.4 控制文件 67
2.5 重做日志文件 68
2.5.1 重做日志的产生过程 69
2.5.2 重做日志文件的查询 70
2.5.3 重做日志文件的创建 71
2.5.4 重做日志文件的删除 72
2.6 归档日志文件 73
2.6.1 归档日志文件的产生 73
2.6.2 日志模式的切换 74
2.6.3 归档路径的设置 75
2.7 数据库中的事务 78
2.7.1 与事务有关的数据库结构 79
2.7.2 事务与备份/恢复的关系 79
2.8 数据库中的其他文件 80
2.8.1 口令文件 80
2.8.2 参数文件 83
2.8.3 警告文件与跟踪文件 85
2.9 数据字典视图与动态性能视图 86
2.9.1 数据字典视图 86
2.9.2 动态性能视图 87
2.10 数据库服务器的启动和关闭 88
2.10.1 数据库服务器的启动 88
2.10.2 数据库服务器的关闭 90
2.11 Oracle 12C 在数据库结构方面的变化 92
2.11.1 什么是 CDB 93
2.11.2 关于 CDB 中的用户 94
2.11.3 关于 CDB 中的数据字典视图 95
2.11.4 关于 CDB 中的文件 96
2.11.5 关于数据库的备份与恢复 96
2.11.6 关于数据库的迁移 97
第 3 章 自动存储管理 （ASM ） 100
3.1 ASM 实例的管理 101
3.1.1 ASM 实例与 ASM 磁盘组的关系 101
3.1.2 ASM 实例的创建 103
3.1.3 ASM 实例中的用户 105
3.2 ASM 磁盘组的管理 106
3.2.1 ASM 磁盘组的结构 106
3.2.2 ASM 磁盘组的创建 109
3.2.3 ASM 磁盘组的扩展 112
3.2.4 ASM 磁盘组的重新平衡 113
3.2.5 ASM 磁盘组的挂载和卸载 114
3.2.6 ASM 磁盘组的文件模板管理 115
3.2.7 ASM 磁盘组的目录管理 117
3.2.8 ASM 磁盘组的应用 118
3.2.9 关于 ASM 磁盘组的兼容性属性 120
3.3 自动文件管理 121
3.3.1 如何激活自动文件管理功能 122
3.3.2 文件的命名规则 122
3.3.3 如何创建 OMF 数据库 123
3.3.4 如何创建 OMF 表空间 125
3.3.5 如何创建 OMF 控制文件 126
3.3.6 如何创建 OMF 重做日志文件 126
3.4 命令行工具 ASMCMD 的用法 127
3.4.1 如何通过 ASMCMD 管理 ASM 实例 127
3.4.2 如何通过 ASMCMD 管理 ASM 磁盘组 130
3.4.3 如何通过 ASMCMD 管理磁盘组中的文件 133
3.5 ASM 磁盘组中的卷管理 135
3.5.1 ADVM 卷的创建与删除 136
3.5.2 ADVM 卷信息的查询 137
3.5.3 ADVM 卷的扩展 138
3.5.4 ADVM 卷的激活与关闭 138
3.6 ACFS 文件系统管理 139
3.6.1 ASM 磁盘组中文件系统的管理 139
3.6.2 ACFSUTIL工具的用法 141
第 4 章 再议事务 143
4.1 什么是事务 143
4.1.1 事务的属性 143
4.1.2 事务处理方法 144
4.2 与备份恢复有关的存储结构 147
4.2.1 快速恢复区 148
4.2.2 UNDO 表空间 148
4.3 事务一致性的维护 151
4.3.1 数据库中的锁 151
4.3.2 事务的隔离级别 153
4.3.3 系统锁 158
4.3.4 死锁 159
第 5 章 数据库的 FLASHBACK 技术 161
5.1 快速恢复区的设置 161
5.2 回收站在防止误删除方面的作用 162
5.3 表的 FLASHBACK 查询 165
5.4 表的 FLASHBACK 166
5.5 更久远的 FLASHBACK——Total Recall 168
5.6 数据库的 FLASHBACK 171
第 6 章 数据库的常规备份与恢复 174
6.1 备份与恢复的相关概念 174
6.1.1 冷备份与热备份 174
6.1.2 物理备份与逻辑备份 175
6.1.3 完全备份与增量备份 175
6.1.4 完全恢复与不完全恢复 175
6.1.5 日志模式对备份与恢复的影响 176
6.1.6 哪些情况将导致数据丢失 176
6.1.7 哪些文件需要备份 178
6.1
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库备份、恢复与迁移
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Exadata专家手册
译者序
前言
致谢
关于作者
关于技术审校人员和贡献者
第1章　全方位了解Exadata1
1.1　Exadata概览2
1.1.1　数据库一体机2
1.1.2　Exadata会改变你的工作职责3
1.1.3　Oracle企业管理器12c3
1.2　Exadata硬件架构4
1.2.1　服务器层—计算节点4
1.2.2　共享存储—存储单元5
1.2.3　网络结构—InfiniBand5
1.2.4　电源单元—PDU5
1.2.5　Cisco交换机5
1.2.6　2U自定义网络交换空间5
1.3　软件架构6
1.3.1　实时应用集群（RAC）6
1.3.2　自动存储管理（ASM）6
1.3.3　数据库计算节点6
1.3.4　存储单元软件7
1.4　型号和配置7
1.4.1　Exadata历史简介7
1.4.2　Exadata的进化8
1.4.3　Exadata SuperCluster T4-418
1.4.4　Exadata SuperCluster T5-820
1.4.5　Exadata SuperCluster M6-3222
1.4.6　Exadata存储扩展柜23
1.4.7　Exadata存储单元（存储节点）24
1.4.8　硬件的发展24
1.5　考察Exadata一体机27
1.6　本章小结29
第2章　Exadata里的RAC30
2.1　Exadata上RAC的意义30
2.2　RAC概述31
2.2.1　Exadata RAC快速入门32
2.2.2　RAC对DBA的影响33
2.3　在Exadata上搭建RAC集群33
2.4　运维最佳实践34
2.4.1　最大可用性架构（MAA）34
2.4.2　优化设置让RAC数据库高效运行35
2.5　使用OEM 12c管理RAC37
2.6　常用工具和命令38
2.7　诊断RAC问题44
2.7.1　从ORAchk开始44
2.7.2　使用TFA问题搜集工具44
2.7.3　使用自动诊断库44
2.7.4　检查告警日志和跟踪日志文件45
2.7.5　使用3A工具45
2.7.6　检查集群私网45
2.7.7　启用跟踪功能和检查跟踪日志45
2.7.8　集群健康状态监视器45
2.7.9　使用OEM 12c46
2.7.10　其他工具46
2.7.11　有用的Oracle支持资源46
2.8　本章小结47
第3章　独家秘方—Exadata存储服务器48
3.1　Exadata存储服务器概述48
3.1.1　存储服务器架构49
3.1.2　存储节点软件的功能和管理50
3.1.3　配置用于告警通知的邮件服务器53
3.1.4　列出存储服务器的详细信息54
3.1.5　存储的指标和告警历史54
3.1.6　查询存储节点上的历史告警信息55
3.1.7　查询V$视图56
3.2　存储架构和规划56
3.3　非Exadata中的存储架构58
3.4　Exadata中的存储架构59
3.5　管理存储的系统用户61
3.5.1　列出磁盘信息61
3.5.2　创建Cell Disk64
3.5.3　创建Grid Disk65
3.5.4　配置Flash Grid Disk65
3.5.5　创建ASM磁盘组65
3.6　管理存储服务器66
3.7　存储服务器故障排查67
3.7.1　SunDiag67
3.7.2　ExaWatcher67
3.7.3　Exachk68
3.7.4　CheckHWnFWProfile68
3.8　存储节点的启停69
3.9　处理磁盘问题70
3.10　部署存储安全策略72
3.10.1　配置ASM范围的安全策略72
3.10.2　配置数据库范围的安全73
3.10.3　取消存储安全策略74
3.11　本章小结74
第4章　闪存缓存、智能扫描和智能卸载75
4.1　Exadata智能闪存缓存的概念75
4.1.1　为什么闪存缓存很必要75
4.1.2　Exadata闪存缓存的演变76
4.2　Exadata存储服务器和闪存缓存77
4.2.1　Exadata智能闪存缓存的特性77
4.2.2　使用闪存缓存78
4.2.3　Exadata智能闪存缓存日志79
4.3　数据库和闪存缓存80
4.3.1　智能扫描和智能卸载82
4.3.2　存储索引87
4.3.3　在闪存中缓存数据94
4.4　本章小结98
第5章　Exadata压缩:揭秘混合列压缩99
5.1　列式存储模型100
5.1.1　PAX模型101
5.1.2　碎片镜像102
5.1.3　精细混合102
5.2　列存储在Oracle数据库中的实现—混合列压缩102
5.2.1　Oracle数据库压缩技术103
5.2.2　HCC原理103
5.2.3　压缩比率105
5.2.4　压缩类型和压缩单元106
5.3　混合列压缩和性能108
5.3.1　批量数据加载操作108
5.3.2　批量读I/O操作111
5.3.3　小I/O操作113
5.4　混合列压缩和DML语句操作115
5.5　混合列压缩和锁资源管理120
5.6　混合列压缩的实际应用122
5.7　本章小结123
第6章　Oracle 12c数据库和Exadata124
6.1　Oracle 12c分区的特性124
6.1.1　部分分区索引124
6.1.2　分区索引的维护127
6.1.3　移动分区129
6.2　Oracle 12c中优化器的新特性131
6.2.1　自适应计划131
6.2.2　自动重优化132
6.2.3　动态自适应统计133
6.3　信息生命周期管理136
6.4　应用程序连续性139
6.5　多租户架构140
6.5.1　概述140
6.5.2　PDB：新的整合模式140
6.5.3　插拔操作147
6.5.4　RAC和PDB149
6.6　Exadata软件更新153
6.7　本章小结153
第7章　Exadata网络管理155
7.1　Exadata网络组件155
7.2　InfiniBand网络的作用156
7.3　网络架构157
7.4　网络安装要求157
7.5　故障排除工具159
7.6　收集日志文件163
7.7　集成的 Lights Out Manager163
7.8　OEM Cloud Control 12c165
7.9　本章小结167
第8章　Exadata的备份、恢复和Data Guard168
8.1　使用RMAN从磁盘备份到磁盘169
8.1.1　Exadata上RMAN备份的设置169
8.1.2　rman2disk Shell脚本170
8.1.3　rman2disk模板文件172
8.1.4　使用rman2disk172
8.1.5　创建RMAN备份174
8.1.6　RMAN备份计划178
8.1.7　容器和可插拔数据库179
8.2　Data Guard181
8.2.1　补丁181
8.2.2　会话数据单元181
8.2.3　带宽时延积182
8.2.4　网络队列大小183
8.2.5　禁用TCP Nagle算法184
8.2.6　启用网络时间协议184
8.2.7　跟踪数据块的修改185
8.2.8　快速恢复区185
8.2.9　自动切换归档日志186
8.2.10　并行执行消息大小186
8.2.11　数据缓冲区大小187
8.2.12　备库重做日志187
8.2.13　数据库强制日志188
8.2.14　闪回日志189
8.2.15　实时应用日志189
8.2.16　net_timeout和reopen选项190
8.2.17　归档生成速度190
8.2.18　备库的文件管理192
8.2.19　Data Guard Standby-First Patching192
8.2.20　Active Data Guard（ADG）193
8.3　Far Sync194
8.3.1　归档日志保留策略194
8.3.2　数据损坏195
8.3.3　Data Guard实例化195
8.3.4　配置Data Guard Broker199
8.3.5　监控、维护Data Guard的最佳工具—OEM Cloud Control 12c201
8.4　切换DG注意事项201
8.4.1　跟踪DG切换202
8.4.2　保证还原点203
8.5　本章小结203
第9章　使用OEM 12c管理Exadata204
9.1　Exadata目标发现205
9.2　Oracle Exadata插件205
9.2.1　先决条件检查207
9.2.2　手动部署207
9.3　发现Exadata数据库一体机207
9.3.1　先决条件检查208
9.3.2　开始Exadata的发现过程208
9.3.3　发现完成后的过程217
9.4　Exadata组件218
9.4.1　监控和管理218
9.4.2　执行管理221
9.5　本章小结223
第10章　迁移至Exadata224
10.1　Exadata实施生命周期224
10.2　第一阶段：架构策略225
10.3　第二阶段：规划和设计231
10.3.1　自定义和第三方应用程序232
10.3.2　选择实施的Exadata功能233
10.3.3　考虑范例变化233
10.3.4　确定迁移策略234
10.4　第三阶段：迁移测试239
10.4.1　备份和恢复策略239
10.4.2　Exadata监控和报警240
10.4.3　给Exadata打补丁240
10.5　Exadata迁移最佳实践241
10.6　本章小结242
第11章　Exadata和ZFS存储设备升级及补丁修复243
11.1　规划Exadata和ZFS升级243
11.2　季度补丁全栈下载246
11.3　补丁修复工具和过程247
11.3.1　OPatch247
11.3.2　patchmgr248
11.3.3　OPlan249
11.4　Oracle补丁类型251
11.4.1　补丁集更新251
11.4.2　关键补丁更新和安全补丁更新252
11.4.3　Oracle补丁修复标准252
11.4.4　小补丁252
11.5　Exadata高可用性升级252
11.6　使用Exachk检查Exadata设置253
11.7　Exadata全栈升级254
11.7.1　Exadata升级路径255
11.7.2　下载Exadata和ZFS的补丁258
11.7.3　升级存储节点258
11.7.4　更新计算节点260
11.7.5　更新InfiniBand交换机264
11.7.6　更新Grid Home264
11.7.7　升级以太网交换机268
11.7.8　升级KVM交换机274
11.7.9　升级PDU274
11.8　ZFS升级275
11.8.1　ZFSSA配置和升级275
11.8.2　ZFS更新第一阶段276
11.8.3　ZFS更新第二阶段276
11.8.4　更新ZFS BIOS277
11.9　本章小结278
第12章　Exadata的ZFS存储设备279
12.1　ZFS产品系列279
12.2　增加存储容量282
12.2.1　从DBFS中回收资源和空间282
12.2.2　信息生命周期管理283
12.3　ZFSSA浏览器用户界面283
12.4　创建NFS共享284
12.5　设置Exadata以进行直接NFS286
12.5.1　配置和安装NFS共享288
12.5.2　快照288
12.5.3　克隆290
12.5.4　利用Data Guard创建快照和克隆291
12.5.5　ZFS共享上的最佳实践设置291
12.6　其他的行业应用案例293
12.7　模拟器学习293
12.8　本章小结294
第13章　Exadata性能优化295
13.1　Oracle性能调优295
13.1.1　系统性Oracle性能调优296
13.1.2　Oracle性能问题处理296
13.2　Exadata的应用设计298
13.3　Exadata数据库设计300
13.3.1　存储索引301
13.3.2　卸载301
13.3.3　Exadata的智能闪存与索引302
13.3.4　为新应用设计索引302
13.3.5　现有应用的索引策略303
13.3.6　选择压缩等级306
13.4　Exadata的SQL调优307
13.5　Exadata RAC调优308
13.5.1　全局缓存基础308
13.5.2　RAC调优准则309
13.5.3　集群开销309
13.5.4　减少全局缓存延迟311
13.5.5　LMS延迟313
13.5.6　平衡Exadata的RAC数据库315
13.5.7　使用IORM和DBRM平衡负载316
13.6　优化Exadata的I/O317
13.6.1　让闪存发挥更高的效率318
13.6.2　配置回写功能318
13.6.3　配置ASM318
13.6.4　改变数据块的大小319
13.7　本章小结319
第14章　Exadata数据库整合320
14.1　数据库整合模型320
14.2　Exadata整合规划321
14.3　应用分组321
14.3.1　服务器池321
14.3.2　Chargeback322
14.4　规格评定需求323
14.5　建立Exadata整合323
14.5.1　存储和I/O设置324
14.5.2　内存设置327
14.5.3　CPU设置328
14.6　隔离管理332
14.6.1　数据库整合的故障隔离333
14.6.2　模式整合的故障隔离333
14.6.3　数据库整合中的操作隔离333
14.6.4　模式整合的操作隔离334
14.6.5　数据库整合中的资源隔离334
14.6.6　模式整合的资源隔离335
14.6.7　数据库整合的安全隔离335
14.6.8　模式整合的安全隔离336
14.7　Oracle 12c可插拔数据库336
14.8　本章小结337
第15章　Exadata智能闪存缓存深入讲解338
15.1　固态硬盘技术338
15.1.1　硬盘技术的局限性338
15.1.2　固态闪盘的兴起339
15.1.3　Flash SSD的结构和性能340
15.1.4　Oracle数据库闪存缓存343
15.2　Exadata闪存硬件344
15.3　Exadata智能闪存缓存345
15.3.1　Exadata智能闪存缓存结构345
15.3.2　Exadata智能闪存缓存存储什么347
15.3.3　闪存缓存压缩347
15.3.4　CELL_FLASH_CACHE存储子句347
15.3.5　闪存缓存的KEEP使用期348
15.3.6　监控Exadata智能闪存缓存348
15.3.7　Exadata智能闪存缓存的性能350
15.4　监控、控制和测试Exadata智能闪存缓存日志354
15.4.1　监控和控制智能闪存缓存日志355
15.4.2　测试智能闪存缓存日志356
15.5　智能闪存缓存回写358
15.5.1　数据文件写I/O瓶颈358
15.5.2　回写缓存架构360
15.5.3　启动和关闭回写闪存360
15.5.4　回写缓存性能361
15.6　本章小结361
第16章　高级Exadata闪存配置362
16.1　使用Flash作为Grid Disk362
16.1.1　Grid Disk、Cell Disk和闪存缓存363
16.1.2　创建一个基于Flash硬盘的ASM磁盘组365
16.2　Flash表空间与闪存缓存366
16.2.1　Index Fetch性能366
16.2.2　扫描性能368
16.2.3　创建一个Flash临时表空间369
16.2.4　为重做日志使用闪存371
16.3　存储分层解决方案372
16.3.1　使用分区进行数据分层373
16.3.2　Oracle 12c ILM和ADO376
16.4　本章小结376
第17章　Exadata工具和实用命令377
17.1　Exadata诊断工具377
17.1.1　SunDiag378
17.1.2　Exachk：Exadata健康检查工具378
17.2　InfiniBand网络诊断工具380
17.2.1　校验InfiniBand拓扑结构383
17.2.2　infinicheck384
17.3　其他有用的Exadata命令386
17.3.1　imageinfo和imagehistory386
17.3.2　InfiniBand网络相关的命令387
17.4　监控Exadata存储节点393
17.4.1　Dell的Exadata软件工具393
17.4.2　使用企业管理器监控存储节点395
17.4.3　比较分析多节点的CellCLI统计数据397
17.5　本章小结400
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Exadata专家手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据库应用与设计
教学建议
第一部分案例引入
第0章案例介绍及分析
0.1案例介绍
0.1.1城市公交行车安全管理系统
0.1.2事故信息管理系统
0.2系统需求分析
0.2.1系统设计的目标及原则
0.2.2系统业务分析
0.2.3系统用例分析
0.2.4系统流程分析
第二部分Oracle数据库应用
第1章Oracle数据库简介
1.1Oracle数据库产品发展史
1.2Oracle11g新特性
1.3相关术语
第2章Oracle数据库体系结构
2.1概述
2.2实例
2.2.1系统全局区
2.2.2程序全局区
2.2.3用户全局区
2.3Oracle数据库逻辑存储结构
2.3.1表空间
2.3.2段
2.3.3区
2.3.4数据块
2.4Oracle数据库物理存储结构
2.4.1数据文件
2.4.2重做日志文件
2.4.3控制文件
2.4.4归档重做日志文件
2.4.5参数文件
2.4.6口令文件
2.5Oracle关键进程
2.5.1PMON
2.5.2SMON
2.5.3DBWn
2.5.4LGWR
2.5.5CKPT
2.5.6ARCn
2.5.7Dnnn
2.5.8RECO
2.5.9LCKn
第3章数据库管理工具入门
3.1Oracle11g软件安装
3.1.1安装Oracle11g软件的系统需求
3.1.2Oracle11g软件安装过程
3.2Oracle11g工具介绍
3.2.1SQL*Plus的使用
3.2.2数据库配置工具
3.2.3Oracle企业管理器简介
3.2.4网络配置工具
第4章创建Oracle数据库
4.1创建数据库
4.1.1创建数据库的准备工作
4.1.2使用DBCA创建和删除数据库
4.1.3手动方式创建数据库
4.1.4网络配置管理
4.2启动和关闭数据库
4.2.1初始化参数文件管理
4.2.2启动数据库
4.2.3关闭数据库
第5章存储管理
5.1存储管理概述
5.2控制文件管理
5.2.1控制文件概述
5.2.2查询控制文件信息
5.2.3添加、移动和删除控制文件
5.2.4备份控制文件
5.3重做日志文件管理
5.3.1重做日志文件概述
5.3.2查询重做日志文件组和成员
5.3.3添加重做日志文件组和成员
5.3.4删除重做日志文件组和成员
5.4表空间管理
5.4.1表空间概述
5.4.2创建表空间
5.4.3查询表空间信息
5.4.4表空间状态管理
5.4.5删除表空间
5.5数据文件管理
5.5.1数据文件概述
5.5.2创建、修改、移动和删除数据文件
第6章数据字典
6.1数据字典简介
6.2数据字典的组成
6.2.1数据字典表
6.2.2数据字典视图
第7章安全管理
7.1Oracle认证方法
7.1.1操作系统身份认证
7.1.2Oracle数据库身份认证
7.1.3数据库管理员认证
7.2用户管理
7.2.1创建用户
7.2.2修改用户密码
7.2.3锁定用户和解除用户锁定
7.2.4修改用户的默认表空间
7.2.5查看用户信息
7.2.6删除用户
7.3系统权限管理
7.3.1为用户授予系统权限
7.3.2查看用户的系统权限
7.3.3收回授予的系统权限
7.4对象权限管理
7.4.1对象权限授予
7.4.2对象权限查看
7.4.3撤销对象权限
7.5角色管理
7.5.1创建角色
7.5.2为角色和用户授予权限
7.5.3查看角色信息
7.5.4撤销角色权限
7.5.5删除角色
第8章数据库备份与恢复
8.1备份与恢复概述
8.1.1备份概述
8.1.2恢复概述
8.1.3常见备份与恢复方法
8.2逻辑导出／导人
8.2.1Export／lmport
8.2.2数据泵
8.3用户管理的备份与恢复
8.3.1用户管理的脱机备份与恢复
8.3.2归档模式设置
8.3.3用户管理的联机备份与恢复
8.4闪回技术和撤销表空间
8.4.1闪回技术概述
8.4.2闪回查询
8.4.3闪回表
8.4.4闪回删除
8.4.5闪回数据库
8.4.6闪回数据归档
8.4.7撤销表空间管理
8.5恢复管理器（RMAN）
8.5.1RMAN概述
8.5.2创建恢复目录
8.5.3连接目标数据库
8.5.4RMAN配置参数和常用命令
8.5.5RMAN备份数据库
8.5.6RMAN恢复数据库
第三部分Oracle数据库设计
第9章案例分析和设计
9.1数据库设计模式
9.1.1数据字典通用模式设计
9.1.2树形结构通用模式设计
9.2数据库概念结构设计
9.2.1公共信息管理部分数据库概念结构设计
9.2.2事故处理管理部分数据库概念结构设计
9.3数据库逻辑结构设计
9.3.1将E—R图转换成关系模式
9.3.2关系模式优化
第10章表的创建及数据管理
10.1SQL概述
10.2数据类型
10.3表的管理
10.3.1表类型
10.3.2创建表
10.3.3更改表
10.3.4删除表
10.4表数据维护
10.4.1插入数据
10.4.2更新数据
10.4.3删除数据
10.4.4合并数据
10.5索引管理
10.5.1索引概述
10.5.2索引的分类
10.5.3创建索引
10.5.4查询索引信息
10.5.5更改索引
10.5.6删除索引
第11章数据完整性
11.1数据完整性简介
11.2约束
11.2.1主键约束
11.2.2外键约束
11.2.3非空约束
11.2.4检查约束
11.2.5唯一约束
11.2.6默认值
11.3添加约束
11.4删除约束
11.5约束状态
第12章查询构建
12.1数据查询
12.1.1基本语法
12.1.2基本查询
12.1.3分组查询
12.1.4连接查询
12.1.5子查询
12.1.6集合查询
12.2常用函数介绍
12.2.1数值处理函数
12.2.2字符函数
12.2.3日期函数
12.2.4转换函数
12.2.5使用CASE
12.3视图管理
12.3.1视图的概念
12.3.2创建和修改视图
12.3.3查询和更新视图
12.3.4删除视图
第13章PL／SQL编程基础
13.1序列简介
13.1.1序列的定义
13.1.2序列的使用
13.2PL／SQL编程体系结构
13.2.1PL／SQL简介
13.2.2PL／SQL体系结构
13.2.3PL／SQL中的变量和常量
13.2.4PL／SQL中的运算符和表达式
13.3PL／SQL的控制结构
13.3.1条件控制
13.3.2循环控制
13.3.3其他控制
13.4PL／SQL的子程序和包
13.4.1创建子程序
13.4.2子程序参数
13.4.3过程和函数的差异
13.4.4包的创建
13.4.5包的使用
13.4.6删除过程、函数和包
第14章PL／SQL编程进阶
14.1PL／SQL中的异常处理
14.1.1什么是异常
14.1.2为何使用异常
14.1.3异常的使用
14.2游标
14.2.1游标的定义
14.2.2隐式游标的使用
14.2.3显式游标的使用
14.3触发器
14.3.1触发器的作用
14.3.2触发器的创建和使用
14.3.3变异表的处理
14.4案例的解答
附录APL／SQLDeveloper工具简介
附录B事故信息管理系统数据库表结构
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据库应用与设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云构建与管理
第1章 引言
1.1 有关云的不同声音
1.2 云计算是什么
1.2.1 云计算的特性
1.2.2 云计算与网格计算
1.3 云计算的好处
1.3.1 敏捷
1.3.2 弹性
1.3.3 成本有效性
1.4 云服务提交模型
1.4.1 SaaS
1.4.2 PaaS
1.4.3 IaaS
1.5 云计算和企业
1.5.1 符合性风险和缺乏控制
1.5.2 缺乏企业级服务级别协议
1.5.3 平台锁定
1.5.4 前期投资
1.5.5 资本费用与运营费用
1.6 私有云与公有云
1.7 Oracle和云计算
1.7.1 Oracle的服务产品
1.7.2 Oracle的产品
1.7.3 云计算中的Oracle技术
1.8 小结
第2章 云的规划与架构
2.1 云的规划
2.1.1 确定利益相关方及其责任
2.1.2 发现和评估现有的资产和当前的工作负载
2.1.3 整合计划
2.2 云架构
2.2.1 云管理层组件
2.2.2 云基础设施层组件
2.2.3 云基础设施规划
2.3 小结
第3章 自助服务供应
3.1 自助供应的好处
3.2 Oracle的自助供应工具
3.3 自助服务供应设置阶段
3.3.1 第一阶段：设计
3.3.2 第二阶段：筹备
3.3.3 第三阶段：发布
3.4 Oracle Enterprise Manager 12c供应框架
3.4.1 Software Library
3.4.2 Job System
3.4.3 Deployment Procedure
3.4.4 定制Deployment Procedure
3.5 Oracle Virtual Assembly Builder
3.5.1 虚拟设备
3.5.2 Virtual Assembly
3.5.3 Assembly的生命周期
3.6 Oracle Enterprise Manager Self Service Portal
3.7 基于Web服务的API和CLI
3.8 小结
第4章 基础设施即服务
4.1 服务器虚拟化在云计算中的角色
4.2 Oracle的服务器虚拟化技术
4.2.1 Oracle VM Server for SPARC
4.2.2 Oracle VM Server for x
4.3 设置云基础设施
4.3.1 供应Oracle虚拟机服务器
4.3.2 网络配置
4.3.3 存储配置
4.3.4 创建服务器池和区域
4.4 打包并发布云服务
4.4.1 Oracle VM Template
4.4.2 Oracle Virtual Assembly
4.5 设置自助服务应用程序
4.5.1 机器的大小
4.5.2 请求设置
4.5.3 访问控制和配额
4.5.4 软件组件的发布
4.5.5 设置退费
4.6 自助服务应用程序
4.7 监控云资源
4.8 小结
第5章 平台即服务
5.1 中间件云的部署模型
5.2 Oracle Virtual Assembly Builder
5.3 中间件云的生命周期
5.3.1 规划和设置
5.3.2 构建、测试和部署
5.3.3 监控和管理
5.3.4 度量、计费和优化
5.4 云中的角色及其职责
5.4.1 云基础设施管理员
5.4.2 自助服务管理员
5.4.3 云自助服务用户
5.5 Oracle Exalogic Elastic Cloud：应用程序的工程系统
5.6 小结
第6章 数据库即服务
6.1 数据库云中的模型
6.2 数据库云的生命周期
6.2.1 规划和设置
6.2.2 构建、测试和部署
6.2.3 监控和管理
6.2.4 度量、计费和优化
6.3 云中的角色和其职责
6.3.1 云基础设施管理员
6.3.2 自助服务管理员
6.3.3 云自助服务用户
6.4 Oracle Exadata：数据库的工程系统
6.5 小结
第7章 度量和退费
7.1 采用退费还是回放
7.2 Oracle Enterprise Manager在退费或回放方面的特性
7.3 度量 Oracle Enterprise Manager的目标
7.4 定价模型：费率的分配
7.5 成本层次结构的管理
7.5.1 成本中心层次结构的LDAP集成
7.5.2 给成本中心指定计费计划
7.6 设置退费收集过程
7.7 使用和计费报告
7.7.1 总结报告
7.7.2 趋势报告
7.7.3 报告界面
7.8 用于退费的Oracle Enterprise Manager EMCLI API
7.8.1 EMCLI的语法和用法
7.8.2 EMCLI的输出
7.9 小结
第8章 管理云：监控、配置管理和合规性
8.1 大规模监控
8.1.1 异常监控
8.1.2 监控自助服务请求
8.2 性能和服务级别管理
8.2.1 诊断组件级问题
8.2.2 管理整体云服务级别
8.3 配置管理与合规性
8.4 重复性管理任务的自动化
8.5 小结
第9章 现实生活中的案例分析
案例1：私有IaaS
案例2：基于程序集的私有PaaS
案例3：计量和退费
案例4：私有DBaaS
案例5：Java PaaS
案例6：公有IaaS
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云构建与管理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle J.D.Edwards技术与应用
第1章  企业信息化概述  1.1  企业信息化的概念、内涵和作用  1.2  企业信息化的内容  1.3  ERP的发展历史  1.4  ERP的基本概念和主要管理思想  1.5  典型的ERP产品    1.5.1  SAP公司与SAP ERP产品简介    1.5.2  Oracle公司与EBS、JDE产品简介    1.5.3  用友与金蝶    1.5.4  神州数码公司及相关产品简介第2章  JDE E1概述  2.1  JDE系统软件组成和功能介绍    2.1.1  总账管理(General Accounting)    2.1.2  财务预算(Financial Budgeting)    2.1.3  应收账管理(Accounts Receivable)    2.1.4  应付账系统(Accounts Payable)    2.1.5  固定资产管理(Fixed Assets)    2.1.6  成本管理(Cost Management)    2.1.7  高级成本管理(Advanced Cost)    2.1.8  地址名册管理(Address Book)    2.1.9  库存管理(Inventory Management)    2.1.10  销售订单管理(Sales Order Management)    2.1.11  采购管理(Procurement)    2.1.12  高级定价(Advanced Pricing)    2.1.13  运输管理(Transportation Management)    2.1.14  预测(Forecasting)    2.1.15  分销资源计划(Distribution Resource Planning)    2.1.16  车间生产管理(Shop Floor Management)    2.1.17  质量管理(Quality Management)    2.1.18  JDE的Oracle 基础技术架构  2.2  JDE系统主业务流程  2.3  JDE导航及GUI常用操作    2.3.1  JDE界面    2.3.2  导航菜单及快捷路径    2.3.3  工具栏    2.3.4  网格    2.3.5  UBE、报表及计划作业    2.3.6  用户自定义码UDC    2.3.7  地址簿    2.3.8  自动会计指令AAI & DMAAI第3章  JDE中几个子系统的原理与功能  3.1  财务管理子系统    3.1.1  总账    3.1.2  应付账款    3.1.3  应收账款  3.2  固定资产子系统  3.3  采购管理子系统    3.3.1  采购管理子系统概述及主要功能    3.3.2  采购管理子系统流程及分析    3.3.3  采购管理子系统与其他子系统的关系    3.3.4  采购管理子系统实例操作介绍  3.4  库存管理子系统    3.4.1  库存管理子系统概述及主要功能    3.4.2  库存管理子系统流程及分析    3.4.3  库存管理子系统与其他子系统的关系    3.4.4  库存管理子系统实例操作介绍  3.5  销售管理子系统    3.5.1  销售管理子系统概述及主要功能    3.5.2  销售管理子系统流程及分析    3.5.3  销售管理子系统与子系统的关系    3.5.4  销售管理子系统实例操作介绍  3.6  生产管理    3.6.1  产品数据管理    3.6.2  车间管理    3.6.3  需求计划    3.6.4  质量管理    3.6.5  产品成本核算和制造会计  3.7  J.D. Edwards BI    3.7.1  工厂管理者信息显示板(Plant Manager Dashboard)    3.7.2  财务管理及法规遵守控制台    3.7.3  BI Publisher 报表工具第4章  JDE实施  4.1  ERP项目实施原理  4.2  JDE项目的OBA实施方法学、实施指南  4.3  JDE OBA实施项目管理五大阶段    4.3.1  项目启动阶段    4.3.2  系统安装阶段    4.3.3  调研与配置阶段    4.3.4  培训与测试阶段    4.3.5  正式上线阶段  4.4  JDE项目管理的常用手段介绍    4.4.1  变更控制    4.4.2  项目问题跟踪    4.4.3  项目的风险分析  4.5  项目准备评估    4.5.1  ERP项目成本评估    4.5.2  ERP项目的收益估算    4.5.3  ERP项目价值评估第5章  JDE系统管理  5.1  JDE系统的基础知识  5.2  JDE CNC介绍  5.3  系统管理    5.3.1  权限管理    5.3.2  添加角色    5.3.3  添加用户    5.3.4  权限控制  5.4  作业监控附录A  JDE资源  用户组  网站  会议  就业参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle J.D.Edwards技术与应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java安全编码标准
《java安全编码标准》
译者序
序
前言
致谢
第1章　概述1
1.1 错位的信任1
1.2 注入攻击2
1.3 敏感数据泄露3
1.4 效能泄露5
1.5 拒绝服务6
1.6 序列化8
1.7 并发性、可见性和内存8
1.8 最低权限原则14
1.9 安全管理器15
1.10　类装载器16
1.11　小结16
第2章　输入验证和数据净化（ids）17
规则17
风险评估概要17
.2.1　ids00-j净化穿越受信边界的非受信数据18
2.2　ids01-j验证前标准化字符串26
2.3　ids02-j在验证之前标准化路径名28
2.4　ids03-j不要记录未经净化的用户输入31
2.5　ids04-j限制传递给zipinputstream的文件大小33
2.6　ids05-j使用ascii字符集的子集作为文件名和路径名35
2.7　ids06-j从格式字符串中排除用户输入37
2.8　ids07-j不要向runtime.exec()?方法传递非受信、未净化的数据38
2.9　ids08-j净化传递给正则表达式的非受信数据41
2.10　ds09-j如果没有指定适当的locale，不要使用locale相关方法处理与locale相关的数据44
2.11　ids10-j不要拆分两种数据结构中的字符串45
2.12　ids11-j在验证前去掉非字符码点50
2.13　ids12-j在不同的字符编码中无损转换字符串数据51
2.14　ids13-j在文件或者网络i/o两端使用兼容的编码方式53
第3章　声明和初始化（dcl）56
规则56
风险评估概要56
3.1　dcl00-j防止类的循环初始化56
3.2　dcl01-j不要重用java标准库的已经公开的标识59
3.3　dcl02-j将所有增强for语句的循环变量声明为final类型60
第4章　表达式（exp）63
规则63
风险评估概要63
4.1　exp00-j不要忽略方法的返回值63
4.2　exp01-j不要解引用空指针65
4.3　exp02-j使用两个参数的arrays.equals()方法来比较两个数组的内容67
4.4　exp03-j不要用相等操作符来比较两个基础数据类型的值67
4.5　exp04-j确保使用正确的类型来自动封装数值72
4.6　exp05-j不要在一个表达式中对同一变量进行多次写入73
4.7　exp06-j不要在断言中使用有副作用的表达式76
第5章　数值类型与运算（num）78
规则78
风险评估概要78
5.1　num00-j检测和避免整数溢出79
5.2　num01-j不要对同一数据进行位运算和数学运算85
5.3　num02-j确保除法运算和模运算中的除数不为088
5.4　num03-j使用可容纳无符号数据合法取值范围的整数类型89
5.5　num04-j不要使用浮点数进行精细计算90
5.6　num05-j不要使用非标准化数92
5.7　num06-j使用strictfp修饰符确保跨平台浮点运算的一致性94
5.8　num07-j不要尝试与nan进行比较97
5.9　num08-j检查浮点输入特殊的数值98
5.10　num09-j不要使用浮点变量作为循环计数器100
5.11　num10-j不要从浮点字元构造bigdecimal对象101
5.12　num11-j不要比较或者审查以字符串表达的浮点数值102
5.13　num12-j确保将数值转换成较小类型时不会产生数据丢失或曲解103
5.14　num13-j转换基本整数类型至浮点类型时应避免精度损失107
第6章　面向对象（obj）110
规则110
风险评估概要110
6.1　obj00-j只有受信子类能对具有不变性的类和方法进行扩展111
6.2　obj01-j声明数据成员为私有并提供可访问的封装器方法116
6.3　obj02-j当改变基类时，保存子类之间的依赖关系118
6.4　obj03-j在新代码中，不要混用具有泛型和非泛型的原始数据类型124
6.5　obj04-j为可变类提供复制功能，并通过此功能允许将实例传递给非受信代码128
6.6　obj05-j在返回引用之前，防御性复制私有的可变的类成员132
6.7　obj06-j对可变输入和可变的内部组件创建防御性复制136
6.8　obj07-j不允许敏感类复制其自身138
6.9　obj08-j不要在嵌套类中暴露外部类的私有字段141
6.10　obj09-j比较类而不是类名称143
6.11　obj10-j不要使用公有静态的非final变量144
6.12　obj11-j小心处理构造函数抛出异常的情况146
第7章　方法（met）153
规则153
风险评估概要153
7.1　met00-j验证方法参数154
7.2　met01-j不要使用断言验证方法参数156
7.3　met02-j不要使用弃用的或过时的类和方法157
7.4　met03-j进行安全检测的方法必须声明为private或final158
7.5　met04-j不要增加被覆写方法和被隐藏方法的可访问性160
7.6　met05-j确保构造函数不会调用可覆写的方法161
7.7　met06-j不要在clone()中调用可覆写的方法163
7.8　met07-j不要定义类方法来隐藏基类或基类接口中声明的方法165
7.9　met08-j确保比较等同的对象能得到相等的结果167
7.10　met09-j定义了equlas()方法的类必须定义hashcode()方法174
7.11　met10-j实现compareto()方法时遵守常规合约176
7.12　met11-j确保比较中的关键码是不可变的178
7.13　met12-j不要使用析构函数182
第8章　异常行为（err）187
规则187
风险评估概要187
8.1　err00-j不要消除或忽略可检查的异常187
8.2　err01-j不能允许异常泄露敏感信息192
8.3　err02-j记录日志时应避免异常196
8.4　err03-j在方法失败时恢复对象先前的状态197
8.5　err04-j不要在finally程序段非正常退出201
8.6　err05-j不要在finally程序段中遗漏可检查异常202
8.7　err06-j不要抛出未声明的可检查异常205
8.8　err07-j不要抛出runtimeexception、exception或throwable209
8.9　err08-j不要捕捉nullpointerexception或任何它的基类210
8.10　err09-j禁止非受信代码终止jvm216
第9章　可见性和原子性（vna）219
规则219
风险评估概要219
9.1　vna00-j当需要读取共享基础数据类型变量时，需要保证其可见性219
9.2　vna01-j保证对一个不可变对象的共享引用的可见性222
9.3　vna02-j保证对于共享变量的组合操作是原子性的225
9.4　vna03-j即使每一个方法都是相互独立并且是原子性的，也不要假设一组调用是原子性的230
9.5　vna04-j保证串联在一起的方法调用是原子性的235
9.6　vna05-j保证在读写64位的数值时的原子性239
第10章　锁（lck）241
规则241
风险评估概要241
10.1　lck00-j通过私有final锁对象可以同步那些与非受信代码交互的类242
10.2　lck01-j不要基于那些可能被重用的对象进行同步246
10.3　lck02-j不要基于那些通过getclass()返回的类对象来实现同步249
10.4　lck03-j不要基于高层并发对象的内置锁来实现同步252
10.5　lck04-j即使集合是可访问的，也不要基于集合视图使用同步253
10.6　lck05-j对那些可以被非受信代码修改的静态字段，需要同步进入255
10.7　lck06-j不要使用一个实例锁来保护共享静态数据256
10.8　lck07-j使用相同的方式请求和释放锁来避免死锁258
10.9　lck08-j在异常条件时，保证释放已经持有的锁266
10.10　lck09-j不要执行那些持有锁时会阻塞的操作270
10.11　lck10-j不要使用不正确形式的双重锁定检查惯用法273
10.12　lck11-j当使用那些不能对锁策略进行承诺的类时，避免使用客户端锁定277
第11章　线程api（thi）282
规则282
风险评估概要282
11.1 thi00-j不要调用thread.run()282
11.2 thi01-j不能调用threadgroup方法284
11.3 thi02-j通知所有等待中的线程而不是单一线程287
11.4 thi03-j始终在循环中调用wait()和await()方法292
11.5 thi04-j确保可以终止受阻线程295
11.6 thi05-j不要使用thread.stop()来终止线程300
第12章　线程池（tps）304
规则304
风险评估概要304
12.1 tps00-j使用线程池处理流量突发以实现降低性能运行304
12.2 tps01-j不要使用有限的线程池来执行相互依赖的任务307
12.3 tps02-j确保提交至线程池的任务是可中断的312
12.4 tps03-j确保线程池中正在执行的任务不会失败而不给出任何提示315
12.5 tps04-j使用线程池时，确保threadlocal变量可以重新初始化318
第13章　与线程安全相关的其他规则（tsm）323
规则323
风险评估概要323
13.1 tsm00-j不要使用非线程安全方法来覆写线程安全方法323
13.2 tsm01-j不要让this引用在创建对象时泄漏326
13.3 tsm02-j不要在初始化类时使用后台线程332
13.4 tsm03-j不要发布部分初始化的对象336
第14章　输入输出（fio）342
规则342
风险评估概要342
14.1 fio00-j不要操作共享目录中的文件343
14.2 fio01-j使用合适的访问权限创建文件351
14.3 fio02-j发现并处理与文件相关的错误352
14.4 fio03-j在终止前移除临时文件354
14.5 fio04-j在不需要时关闭资源357
14.6 fio05-j不要使用wrap()或duplicate()创建缓存，并将这些缓存暴露给非受信代码361
14.7 fio06-j不能在一个单独的inputstream上创建多个缓存区封装器364
14.8 fio07-j不要让外部进程阻塞输入和输出流367
14.9 fio08-j对读取一个字符或者字节的方法，使用int类型的返回值370
14.10 fio09-j不要使用write()方法输出超过0～255的整数372
14.11 fio10-j使用read()方法保证填充一个数组373
14.12 fio11-j不要将原始的二进制数据作为字符数据读入375
14.13 fio12-j为小端数据的读写提供方法376
14.14 fio13-j不要在受信边界之外记录敏感信息379
14.15 fio14-j在程序终止时执行正确的清理动作381
第15章　序列化（ser）387
规则387
风险评估概要387
15.1 ser00-j在类的演化过程中维护其序列化的兼容性388
15.2 ser01-j不要偏离序列化方法的正确签名390
15.3 ser02-j在将对象向信任边界之外发送时，需要签名并且封装敏感对象392
15.4 ser03-j不要序列化未经加密的敏感数据397
15.5 ser04-j不要允许序列化和反序列化绕过安全管理器401
15.6 ser05-j不要序列化内部类实例404
15.7 ser06-j在反序列化时，对私有的可变的组件进行防御性复制405
15.8 ser07-j不要对实现定义的不可变因素使用默认的序列化格式406
15.9 ser08-j在从拥有特性的环境中进行反序列化之前最小化特权410
15.10 ser09-j不要从readobject()方法中调用可以被覆写的方法413
15.11 ser10-j在序列化时，避免出现内存和资源泄漏414
15.12 ser11-j防止覆盖外部化的对象415
第16章　平台安全性（sec）417
规则417
风险评估概要417
16.1 sec00-j不要允许特权代码块越过受信边界泄露敏感信息417
16.2 sec01-j不要在特权代码块中使用污染过的变量420
16.3 sec02-j不要基于非受信源进行安全检查422
16.4 sec03-j不要在允许非受信代码装载任意类之后装载受信类424
16.5 sec04-j使用安全管理器检查来保护敏感操作426
16.6 sec05-j不要使用反射来增加类、方法和字段的可访问性429
16.7 sec06-j不要依赖于默认的由urlclassloader和java.util.jar提供的自动化签名检查434
16.8 sec07-j当编写一个自定义的类装载器时调用基类的getpermissions()方法437
16.9 sec08-j定义基于原生方法的封装器438
第17章　运行环境（env）441
规则441
风险评估概要441
17.1 env00-j不要签名只执行非特权操作的代码441
17.2 env01-j将所有安全敏感的代码置于单独一个jar包中，并且在签名之后封装它443
17.3 env02-j不要信任环境变量的值446
17.4 env03-j不要赋予危险的权限组合448
17.5 env04-j不要关闭字节码验证功能451
17.6 env05-j不要部署一个被远程监视的应用452
第18章　其他（msc）457
规则457
风险评估概要457
18.1 msc00-j在交换安全数据时使用sslsocket而不是socket457
18.2 msc01-j不要使用空的无限循环461
18.3 msc02-j生成强随机数462
18.4 msc03-j不要硬编码敏感信息464
18.5 msc04-j防止内存泄漏466
18.6 msc05-j不要耗尽堆空间473
18.7 msc06-j当一个遍历正在进行时，不要修改它对应的集合477
18.8 msc07-j防止多次实例化单例对象481
术语表490
参考资源497
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Java安全编码标准
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>巴菲特箴言
第一章 投资 / 001
第二章 华尔街与投机 / 053
第三章 商业 / 073
第四章 伯克希尔哈撒韦股份有限公司 / 113
第五章 美国的政策与政治 / 151
第六章 财富和税收 / 183
第七章 人生的经验 / 207
大事记 / 245
参考资料 / 265
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>巴菲特箴言
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle SQL培训教程
第0章  Oracle的安装及相关配置  0.1  Oracle的安装  0.2  进入Oracle的SQL*Plus界面  0.3  scott用户及其对象维护  0.4  本书中将用到的表  0.5  SQL(Structured Query Language)语言  0.6  本书所用的术语  0.7  Oracle 11g上的SQL*Plus  0.8  使用iSQL*Plus  0.9  使用DOS窗口启动SQL*Plus第1章  简单查询语句  ……第2章  限制性查询和数据的排序第3章  常用的SQL*Plus命令第4章  单行函数第5章  NULL值的处理、逻辑操作和函数嵌套第6章  综合数据和分组函数第7章  多表查询第8章  子查询第9章  控制SQL*Plus的环境和数据字典简介第10章  创建表第11章  替代变量第12章  数据的维护第13章  索引与约束第14章  视图第15章  序列号和同义词第16章  用户管理第17章  图形工具简介和集合操作第18章  Express概述和安装第19章  Express的用户界面第20章  创建和预览Express网页第21章  编辑Express网页第22章  在网页中加入链接第23章  管理数据和部署应用程序参考文献结束语鸣谢
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle SQL培训教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Solaris 10系统管理基础教程
第1章 安装Solaris 10操作系统        1
1.1 适合你的需求的方法        1
1.2 Solaris安装基础知识        2
1.2.1 在SPARC系统上安装Solaris        4
1.2.2 在x86系统上安装Solaris        6
1.3 Solaris JumpStart安装        9
1.3.1 设置JumpStart Server        9
1.3.2 为联网的系统创建配置文件服务器        10
1.3.3 执行自定义JumpStart安装        16
1.4 升级Solaris系统        18
1.5 Solaris Live Upgrade        19
1.6 参考资料        20
第2章 引导、服务管理和关闭        23
2.1 引导        23
2.1.1 引导装载程序        23
2.1.2 内核        24
2.1.3 用户态程序        24
2.1.4 GRUB 扩展        25
2.1.5 修改引导行为        25
2.1.6 运行级别        26
2.1.7 故障排除        27
2.2 服务管理工具        27
2.2.1 enabled        28
2.2.2 state、next_state和state_time        28
2.2.3 logfile        29
2.2.4 依赖关系        29
2.2.5 SMF如何与服务实例交互        30
2.2.6 服务配置工具        31
2.2.7 健康状况和故障排除        31
2.2.8 服务清单        32
2.2.9 SCF数据的备份与恢复        32
2.3 关闭        33
2.3.1 特定于应用程序的关闭        33
2.3.2 独立于应用程序的关闭        33
第3章 软件管理：软件包        35
3.1 管理软件包        35
3.2 什么是软件包        35
3.2.1 SVR4软件包内容        35
3.2.2 软件包命名约定        36
3.3 管理软件包的工具        36
3.4 使用pkgadd或pkgrm命令安装或删除软件包        37
3.5 使用软件包命令管理软件包        38
3.5.1 如何使用pkgadd命令安装包        38
3.5.2 将经常安装的软件包添加到暂存目录        40
3.5.3 删除软件包        42
第4章 软件管理：修补程序        45
4.1 使用修补程序管理软件        45
4.2 什么是修补程序        45
4.2.1 修补程序内容        46
4.2.2 修补程序ID        46
4.3 修补程序管理最佳实践        47
4.3.1 前瞻性修补程序管理战略        47
4.3.2 反应性修补程序管理战略        52
4.3.3 安全性修补程序管理战略        53
4.3.4 在安装新系统时进行前瞻性修补        54
4.3.5 确定并获取用于前瞻性修补的修补程序        56
4.4 使用Solaris Live Upgrade安装修补程序的示例        57
4.4.1 使用Solaris Live Upgrade进行修补概述        57
4.4.2 计划使用Solaris Live Upgrade        58
4.4.3 当为Solaris 10 8/07版本使用Solaris Live Upgrade时如何应用修补程序        60
4.5 修补程序自动化工具        66
4.6 修补程序类型概述        67
4.7 修补程序自述文件特殊说明        70
4.7.1 何时在单用户模式下进行修补        70
4.7.2 在应用或删除修补程序之后何时重新引导        71
4.7.3 非全局区域的修补程序元数据        72
4.8 修补程序依赖关系（相互关系）        72
4.8.1 针对修补程序依赖关系的SUNW_REQUIRES字段        73
4.8.2 表示修补程序累加和废弃的SUNW_OBSOLETES字段        73
4.8.3 表示不兼容性的SUNW_INCOMPAT字段        74
第5章 Solaris文件系统        75
5.1 Solaris文件系统概述        75
5.1.1 挂载文件系统        76
5.1.2 卸载文件系统        78
5.1.3 使用/etc/vfstab文件        78
5.1.4 确定文件系统类型        79
5.1.5 监控文件系统        80
5.2 UFS文件系统        80
5.2.1 创建UFS文件系统        81
5.2.2 备份和恢复UFS文件系统        82
5.2.3 使用配额管理磁盘空间        83
5.2.4 检查文件系统完整性        84
5.2.5 使用访问控制列表        86
5.2.6 使用UFS日志        87
5.2.7 使用扩展文件属性        88
5.2.8 使用TB级UFS文件系统        88
5.2.9 创建UFS快照        89
5.3 ZFS文件系统管理        90
5.3.1 使用池和文件系统        90
5.3.2 备份ZFS文件系统        93
5.3.3 使用镜像和条带        93
5.3.4 使用RAID-Z        94
5.3.5 使用写时复制和快照        95
5.3.6 使用文件压缩        96
5.3.7 度量性能        97
5.3.8 扩展池        98
5.3.9 检查池        99
5.3.10 更换磁盘        99
5.4 NFS文件系统管理        100
5.4.1 查找可用的NFS文件系统        100
5.4.2 挂载NFS文件系统        101
5.4.3 卸载NFS文件系统        101
5.4.4 配置自动文件系统共享        102
5.4.5 自动挂载文件系统        102
5.5 可移除介质        105
5.5.1 使用PCFS文件系统        106
5.5.2 使用HSFS文件系统        106
5.6 伪文件系统管理        107
5.6.1 使用交换空间        107
5.6.2 使用TMPFS文件系统        108
5.6.3 使用回送文件系统        109
参考资料        110
第6章 管理系统进程        111
6.1 概述        111
6.1.1 进程状态        112
6.1.2 进程上下文        112
6.2 监视进程        114
6.2.1 进程状态：ps        115
6.2.2 进程搜索：pgrep        117
6.2.3 进程统计数据摘要：prstat        118
6.2.4 捕获僵停进程：greap        120
6.2.5 临时停止进程：pstop        120
6.2.6 恢复暂停的进程：prun        120
6.2.7 等待进程完成：pwait        120
6.2.8 进程工作目录：pwdx        121
6.2.9 进程参数：pargs        121
6.2.10 进程文件表：pfiles        122
6.2.11 进程库：pldd        122
6.2.12 进程树：ptree        123
6.2.13 进程栈：pstack        123
6.2.14 跟踪进程：truss        124
6.3 控制进程        127
6.3.1 nice和renice命令        127
6.3.2 信号        128
6.4 进程管理器        131
6.5 调度进程        135
6.5.1 cron实用程序        136
6.5.2 at命令        139
第7章 故障管理        143
7.1 概述        143
7.2 故障通知        144
7.3 显示故障        146
7.4 修复故障        147
7.5 管理故障管理日志文件        148
7.5.1 自动日志轮转        148
7.5.2 手动日志轮转        149
7.5.3 日志轮转故障        151
7.5.4 检查历史日志文件        151
7.6 管理fmd和fmd模块        152
7.6.1 加载和卸载模块        152
7.6.2 fmd统计信息        154
7.6.3 配置文件        155
7.7 故障管理目录        156
7.8 Solaris故障管理下载资源        157
7.8.1 Solaris FMA演示包        157
7.8.2 事件注册表        158
第8章 管理磁盘        159
8.1 硬盘驱动器        159
8.2 磁盘术语        160
8.3 磁盘设备命名约定        161
8.4 磁盘管理概述        163
8.4.1 设备驱动程序        163
8.4.2 磁盘标签（VTOC或EFI）        164
8.4.3 磁盘分片        165
8.4.4 多个磁盘上的分片安排        167
8.4.5 分区表        167
8.4.6 format实用程序        169
8.4.7 format菜单和命令说明        170
8.4.8 Partition菜单        172
8.4.9 x86：fdisk菜单        173
8.4.10 Analyze菜单        173
8.4.11 Defect菜单        175
8.5 磁盘管理过程        176
8.5.1 如何标识系统中的磁盘        176
8.5.2 如何确定磁盘是否被格式化        177
8.5.3 如何格式化磁盘        177
8.5.4 如何执行表面分析来识别缺陷扇区        179
8.5.5 如何修复缺陷扇区        180
8.5.6 如何显示分区表或分片信息        181
8.5.7 创建磁盘分片（分区磁盘）并为磁盘添加标签        183
8.5.8 在磁盘上创建文件系统        187
8.5.9 管理磁盘的其他命令        187
第9章 管理设备        193
9.1 Solaris设备驱动程序简介        193
9.2 缺乏设备支持故障分析        194
9.2.1 设备无法运转        194
9.2.2 获取关于设备的信息        194
9.2.3 获取关于驱动程序的信息        199
9.2.4 设备有驱动程序吗        204
9.2.5 当前驱动程序不工作        206
9.2.6 类似设备的驱动程序可以工作吗        206
9.3 安装和更新驱动程序        207
9.3.1 备份当前有效的驱动程序二进制文件        207
9.3.2 包安装        207
9.3.3 安装时更新        208
9.3.4 手动驱动程序二进制文件安装        208
9.3.5 向网络安装映像添加设备驱动程序        211
9.3.6 向CD/DVD安装映像添加设备驱动程序        215
9.3.7 交换磁盘        216
9.4 在驱动程序引起系统挂起或瘫痪时        218
9.4.1 设备驱动程序导致系统挂起        219
9.4.2 设备驱动程序导致系统瘫痪        220
9.4.3 设备驱动程序导致系统性能下降        221
9.5 驱动程序管理命令和文件        222
9.5.1 驱动程序管理命令总结        222
9.5.2 驱动程序管理文件总结        224推荐阅读        224
第10章 Solaris网络        225
10.1 网络配置介绍        225
10.1.1 TCP/IP网络协议栈概述        225
10.1.2 以超级用户身份配置网络        227
10.2 设置网络        227
10.2.1 XYZ, Inc.网络的组件        228
10.2.2 配置销售域        229
10.2.3 配置会计域        232
10.2.4 配置多宿主主机        235
10.2.5 设置系统静态路由        242
10.2.6 配置公司域        245
10.2.7 测试网络配置        247
10.3 监控网络性能        248
10.3.1 dladm命令        249
10.3.2 ifconfig命令        249
10.3.3 netstat命令        250
10.3.4 snoop命令        251
10.3.5 traceroute命令        252
参考资料        253
第11章 Solaris用户管理        255
11.1 Solaris用户、组和角色        255
11.1.1 文件系统对象权限        256
11.1.2 用户账户组件        257
11.1.3 用户管理工具        258
11.1.4 用户管理文件        258
11.2 管理用户和组        259
11.2.1 启动Solaris Management Console        259
11.2.2 向本地文件添加组和用户        259
11.2.3 向NIS域添加组和用户        261
11.3 管理角色        262
11.3.1 将根用户更改为角色        262
11.3.2 查看角色列表        263
11.3.3 为本地用户分配角色        264
第12章 Solaris区域        265
12.1 概述        265
12.2 区域的工作原理        266
12.3 品牌化区域        267
12.4 区域中的网络接口        268
12.5 区域中的设备        268
12.6 区域环境中的软件包和修补程序        268
12.7 管理区域        269
12.7.1 区域配置        270
12.7.2 查看区域配置        273
12.7.3 区域安装和引导        273
12.7.4 使用zlogin命令登录区域        274
12.8 停止、卸载、移动和克隆区域        274
12.9 将区域迁移到新系统        275
12.10 删除区域        277
12.11 列出系统上的区域        277
12.12 区域用法示例        278
12.12.1 向非全局区域添加专用设备        278
12.12.2 如何将全局区域中的主目录导出到非全局区域        278
12.12.3 更改非全局区域中的权限        279
12.12.4 查看SMF服务的状态        279
12.12.5 修改区域中的CPU、交换空间和锁定内存上限        279
12.12.6 在非全局区域中使用Dtrace程序        280
第13章 使用命名服务        281
13.1 使用命名服务（DNS、NIS和LDAP）        281
13.1.1 nscd        282
13.1.2 DNS命名服务        282
13.1.3 NIS命名服务        282
13.1.4 LDAP命名服务        283
13.1.5 组织对命名服务的使用        283
13.1.6 网络数据库源        284
13.2 名称服务交换文件        286
13.2.1 配置名称服务交换文件        286
13.2.2 数据库状态和操作        288
13.3 DNS设置和配置        289
13.3.1 解析器文件        289
13.3.2 DNS客户端解析名称的步骤        289
13.4 NIS设置和配置        290
13.4.1 设置NIS客户端        290
13.4.2 处理NIS映射        291
13.5 LDAP设置和配置        294
13.5.1 使用按用户发放的凭证初始化客户端        294
13.5.2 配置LDAP客户端        296
13.5.3 使用配置文件初始化LDAP客户端        299
13.5.4 使用代理凭证初始化LDAP客户端        299
13.5.5 手动初始化LDAP        299
13.5.6 修改手动LDAP客户端配置        300
13.5.7 对LDAP客户端配置进行故障排除        300
13.5.8 取消LDAP客户端的初始化        301
13.5.9 初始化本机LDAP客户端        301
13.5.10 LDAP API条目列表        304
13.5.11 名称服务信息故障排除        305
第14章 Solaris打印管理        307
14.1 Solaris打印体系结构概述        307
14.2 关键概念        308
14.2.1 打印机种类（本地打印机和远程打印机）        308
14.2.2 打印机连接（直接连接和网络连接）        308
14.2.3 打印服务器和打印客户端介绍        308
14.3 Solaris打印工具和服务        308
14.3.1 Solaris打印管理器        309
14.3.2 LP打印服务        309
14.3.3 PostScript打印机定义文件管理器        309
14.4 网络协议        309
14.4.1 Berkeley软件分发协议        310
14.4.2 传输控制协议        310
14.4.3 因特网打印协议        310
14.4.4 服务器消息块协议        310
14.5 规划打印机设置        311
14.5.1 打印服务器要求        311
14.5.2 查找受支持打印机的信息        311
14.5.3 查找可用PPD文件的信息        312
14.5.4 向系统添加一个新的PPD文件        312
14.5.5 在命名服务中添加打印机        313
14.5.6 命名服务交换中的打印机支持        314
14.5.7 启用网络侦听服务        314
14.6 使用Solaris打印管理器设置打印机        315
14.6.1 指定打印机定义        315
14.6.2 启动Solaris打印管理器        316
14.6.3 使用Solaris打印管理器设置新的直接连接打印机        316
14.6.4 使用Solaris打印管理器设置新的网络连接打印机        317
14.7 使用Solaris打印管理器在打印客户端上设置打印机        318
14.8 使用LP打印命令管理打印机        319
14.8.1 常用LP打印命令        319
14.8.2 使用lpstat命令        320
14.8.3 禁用和启用打印机        321
14.8.4 接受或拒绝打印请求        321
14.8.5 取消打印请求        321
14.8.6 将打印请求从一个打印机移动到另一个打印机        322
14.8.7 删除打印机        323
14.9 打印故障排除        325
14.9.1 无输出（不打印任何内容）问题的故障排除        325
14.9.2 检查打印调度程序是否正在运行        325
14.9.3 调试打印问题        326
14.9.4 检查打印机网络连接        326
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Solaris 10系统管理基础教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Oracle 12c数据库管理（第2版）
第1章　安装Oracle　　1
1.1 　了解OFA　　1
1.1.1 　Oracle清单目录　　2
1.1.2 　Oracle基础目录　　3
1.1.3 　Oracle主目录　　3
1.1.4 　Oracle网络文件目录　　4
1.1.5 　自动诊断信息库　　4
1.2 　安装Oracle　　5
1.2.1 　步骤1：创建OS组和用户　　5
1.2.2 　步骤2：确保充分配置了OS　　7
1.2.3 　步骤3：获取Oracle安装软件　　8
1.2.4 　步骤4：解压缩文件　　8
1.2.5 　步骤5：创建oraInst.loc文件　　9
1.2.6 　步骤6：配置应答文件，然后运行安装程序　　9
1.2.7 　步骤7：解决任何疑难问题　　13
1.3 　使用已安装程序的副本安装Oracle　　14
1.3.1 　步骤1：使用OS实用程序复制已安装的程序　　14
1.3.2 　步骤2：附加Oracle主目录　　15
1.4 　升级Oracle软件　　16
1.5 　安装失败后的重新安装　　17
1.6 　安装临时补丁　　18
1.7 　使用图形界面的安装程序执行远程安装　　19
1.7.1 　步骤1：在本地计算机上安装X Window系统和网络实用程序　　20
1.7.2 　步骤2：在本地计算机上启动X Window系统会话　　20
1.7.3 　步骤3：将Oracle安装文件复制到远程服务器上　　20
1.7.4 　步骤4：运行xhost命令　　21
1.7.5 　步骤5：通过X Window系统登录远程计算机　　21
1.7.6 　步骤6：确保在远程计算机上正确设置DISPLAY变量　　21
1.7.7 　步骤7：运行runInstaller实用程序　　22
1.7.8 　步骤8：解决问题　　23
1.8 　小结　　23
第2章　实现数据库　　24
2.1 　设置OS变量　　24
2.1.1 　手动加强方法　　25
2.1.2 　使用Oracle的方法设置OS变量　　25
2.1.3 　我最喜欢的设置OS变量的方法　　27
2.2 　创建数据库　　28
2.2.1 　步骤1：设置OS变量　　29
2.2.2 　步骤2：配置初始化文件　　29
2.2.3 　步骤3：创建必需的目录　　31
2.2.4 　步骤4：创建数据库　　31
2.2.5 　步骤5：创建数据目录　　35
2.3 　配置和实现监听器　　36
2.3.1 　手动配置监听器　　36
2.3.2　　使用Net Configuration Assistant实现监听器　　37
2.3.3 　通过网络连接数据库　　38
2.4 　创建密码文件　　39
2.5 　启动和停止数据库　　40
2.5.1 　了解OS认证　　40
2.5.2 　启动数据库　　41
2.5.3 　停止数据库　　43
2.6 　使用dbca创建数据库　　44
2.7 　删除数据库　　46
2.8 　一台服务器上运行多少个数据库　　47
2.9 　了解Oracle体系结构　　49
2.10 　小结　　51
第3章　配置高效环境　　52
3.1 　自定义OS命令提示符　　53
3.2 　自定义SQL提示符　　54
3.3 　为常用命令创建快捷方式　　56
3.3.1 　使用别名　　56
3.3.2 　使用函数　　57
3.4 　快速再次运行命令　　58
3.4.1 　使用向上箭头键和向下箭头键滚动　　59
3.4.2 　使用Ctrl+P和Ctrl+N组合键　　59
3.4.3 　列出命令的历史记录　　59
3.4.4 　反向搜索　　60
3.4.5 　设置命令编辑器　　60
3.5 　开发标准脚本　　61
3.5.1 　dba_setup　　61
3.5.2 　dba_fcns　　62
3.5.3 　tbsp_chk.bsh　　62
3.5.4 　conn.bsh　　64
3.5.5 　filesp.bsh　　65
3.5.6 　login.sql　　67
3.5.7 　top.sql　　67
3.5.8 　lock.sql　　68
3.5.9 　users.sql　　70
3.6 　组织脚本　　70
3.6.1 　步骤1：创建目录　　71
3.6.2 　步骤2：将文件复制到目录　　71
3.6.3 　步骤3：配置启动文件　　71
3.7 　小结　　72
第4章　表空间和数据文件　　73
4.1 　最初创建的5个表空间　　74
4.2 　了解更多需求　　74
4.3 　创建表空间　　75
4.4 　重命名表空间　　78
4.5 　控制重做日志　　79
4.6 　更改表空间的写入模式　　80
4.7 　删除表空间　　80
4.8 　使用Oracle管理的文件　　82
4.9 　创建大文件表空间　　83
4.10 　在表空间中启用默认的表压缩　　83
4.11 　显示表空间的尺寸　　84
4.12 　更改表空间尺寸　　86
4.13 　切换数据文件的联机状态　　87
4.14 　重命名和移动数据文件　　89
4.14.1 　执行数据文件联机操作　　89
4.14.2 　执行数据文件脱机操作　　89
4.15 　小结　　93
第5章　管理控制文件、联机重做日志和归档　　94
5.1 　管理控制文件　　94
5.1.1 　查看控制文件的名称和位置　　96
5.1.2 　增加控制文件　　97
5.1.3 　移动控制文件　　99
5.1.4 　删除控制文件　　100
5.2 　管理联机重做日志　　101
5.2.1 　显示联机重做日志信息　　103
5.2.2 　确定联机重做日志组的最优尺寸　　104
5.2.3 　确定重做日志组的最优数量　　106
5.2.4 　增加联机重做日志组　　107
5.2.5 　调整联机重做日志组的尺寸和删除联机重做日志组　　107
5.2.6 　向日志组增加联机重做日志文件　　109
5.2.7 　从日志组删除联机重做日志文件　　109
5.2.8 　移动或重命名重做日志文件　　110
5.3 　实现归档模式　　111
5.3.1 　体系结构决策　　111
5.3.2 　设置归档重做日志文件的存储位置　　112
5.3.3  “非Oracle模式”的FRA思想　　115
5.3.4 　启用归档日志模式　　116
5.3.5 　禁用归档日志模式　　117
5.3.6 　归档日志的存储位置缺少可用空间时的应对方法　　117
5.3.7 　备份归档重做日志文件　　119
5.4 　小结　　119
第6章　用户账号和基本安全　　120
6.1 　管理默认用户　　120
6.1.1 　锁定账号和密码过期　　121
6.1.2 　区分DBA创建的账号　　123
6.1.3 　检查默认密码　　124
6.2 　创建用户账号　　125
6.2.1 　选择用户名和验证方式　　125
6.2.2 　分配默认的永久和临时表空间　　128
6.3 　修改密码　　130
6.4 　使用其他用户账号登录　　130
6.5 　修改用户　　132
6.6 　删除用户　　133
6.7 　提高密码安全性和资源使用限制　　134
6.7.1 　密码的基本安全性　　134
6.7.2 　密码长度　　136
6.7.3 　限制数据库资源的使用　　138
6.8 　管理权限　　139
6.8.1 　分配数据库系统权限　　139
6.8.2 　分配数据库对象权限　　140
6.8.3 　以集中方式分配权限　　141
6.9 　小结　　142
第7章　表和约束　　144
7.1 　表的类型　　144
7.2 　数据类型　　145
7.2.1 　字符型　　146
7.2.2 　数值型　　147
7.2.3 　日期型　　148
7.2.4 　RAW　　149
7.2.5 　ROWID　　149
7.2.6 　大对象　　150
7.2.7 　可扩展的字符类型　　150
7.3 　创建表　　151
7.3.1 　创建堆组织表　　152
7.3.2 　实现虚拟列　　154
7.3.3 　实现隐藏列　　156
7.3.4 　创建只读表　　157
7.3.5 　创建延迟段　　157
7.3.6 　创建含有自动增长（标识）列的表　　158
7.3.7 　默认的SQL并行执行方式　　160
7.3.8 　压缩表数据　　161
7.3.9 　减少重做日志　　163
7.3.10 　通过查询结果创建表　　165
7.4 　修改表　　167
7.4.1 　获得必需的锁机制　　167
7.4.2 　重命名表　　168
7.4.3 　增加列　　168
7.4.4 　更改列　　168
7.4.5 　重命名列　　170
7.4.6 　删除列　　170
7.5 　显示表的DDL代码　　171
7.6 　删除表　　172
7.7 　恢复已删除的表　　172
7.8 　删除表中的数据　　174
7.8.1 　使用DELETE语句　　174
7.8.2 　使用TRUNCATE语句　　174
7.9 　查看和调整高水位线标记　　175
7.10 　与高水位线有关的性能问题　　175
7.10.1 　跟踪检测高水位线标记下方的空间　　176
7.10.2 　使用DBMS_SPACE软件包检查高水位线标记下方的空间　　176
7.10.3 　查看数据字典的分区视图　　178
7.10.4 　降低高水位线标记　　178
7.11 　创建临时表　　180
7.12 　创建索引组织表　　181
7.13 　管理约束　　182
7.13.1 　创建主键约束　　182
7.13.2 　强制应用唯一键　　184
7.13.3 　创建外键约束　　185
7.13.4 　检查特定的数据条件　　186
7.13.5 　强制应用NOT NULL约束　　187
7.13.6 　禁用约束　　187
7.13.7 　启用约束　　189
7.14 　小结　　191
第8章　索引　　192
8.1 　创建索引的时机　　193
8.1.1 　以积极方式创建索引　　193
8.1.2 　以消极方式创建索引　　193
8.2 　规划健壮性　　194
8.2.1 　索引的类型　　195
8.2.2 　估算索引的尺寸　　196
8.2.3 　为索引创建独立表空间　　197
8.2.4 　创建便携脚本　　199
8.2.5 　创建命名标准　　199
8.3 　创建索引　　200
8.3.1 　创建二叉树索引　　200
8.3.2 　创建组合索引　　202
8.3.3 　实现基于函数的索引　　204
8.3.4 　创建唯一索引　　205
8.3.5 　实现位图索引　　206
8.3.6 　创建位图连接索引　　207
8.3.7 　实现反向键索引　　208
8.3.8 　创建压缩键索引　　208
8.3.9 　以并行方式创建索引　　209
8.3.10 　减少创建索引时生成的重做日志　　209
8.3.11 　实现隐藏索引　　210
8.4 　维护索引　　212
8.4.1 　重命名索引　　212
8.4.2 　显示重新创建索引的代码　　212
8.4.3 　重建索引　　213
8.4.4 　将索引标记为不可用　　214
8.4.5 　监控索引的使用情况　　215
8.4.6 　删除索引　　216
8.5 　在外键列上创建索引　　216
8.5.1 　在外键列上创建索引　　216
8.5.2 　确定是否在外键列上创建了索引　　217
8.6 　小结　　220
第9章　视图、同义词和序列　　222
9.1 　实现视图　　222
9.1.1 　创建视图　　222
9.1.2 　检查更新数据　　224
9.1.3 　创建只读视图　　225
9.1.4 　可更新的连接视图　　225
9.1.5 　创建INSTEAD OF触发器　　226
9.1.6 　实现隐藏列　　227
9.1.7 　修改视图定义　　229
9.1.8 　显示用于创建视图的SQL代码　　230
9.1.9 　重命名视图　　230
9.1.10 　删除视图　　231
9.2 　管理同义词　　231
9.2.1 　创建同义词　　232
9.2.2 　创建公有同义词　　233
9.2.3 　以动态方式创建同义词　　233
9.2.4 　显示同义词元数据　　234
9.2.5 　重命名同义词　　234
9.2.6 　删除同义词　　235
9.3 　管理序列　　235
9.3.1 　创建序列　　235
9.3.2 　使用序列伪列　　236
9.3.3 　自动增长列　　237
9.3.4 　实现生成唯一值的多重序列　　238
9.3.5 　创建一个或多个序列　　239
9.3.6 　查看序列元数据　　239
9.3.7 　重命名序列　　239
9.3.8 　删除序列　　240
9.3.9 　重置序列　　240
9.4 　小结　　241
第10章　数据字典的基础结构　　243
10.1 　数据字典的结构　　243
10.1.1 　静态视图　　244
10.1.2 　动态性能视图　　245
10.2 　元数据的其他视图　　247
10.3 　数据字典的几种灵活用法　　249
10.3.1 　溯源文档　　249
10.3.2 　显示用户信息　　250
10.3.3 　显示表的行数　　253
10.3.4 　显示主键和外键关系　　255
10.3.5 　显示对象的依赖关系　　256
10.4 　小结　　258
第11章　大对象　　259
11.1 　描述大对象类型　　259
11.2 　大对象定位器、索引和块　　260
11.3 　区分BasicFiles和SecureFiles　　262
11.3.1 　BasicFiles　　262
11.3.2 　SecureFiles　　262
11.4 　创建含有大对象列的表　　263
11.4.1 　创建BasicFiles大对象列　　263
11.4.2 　在指定表空间中实现大对象　　265
11.4.3 　创建SecureFiles大对象列　　265
11.4.4 　实现分区表大对象　　266
11.5 　管理大对象列　　267
11.5.1 　移动大对象列　　267
11.5.2 　添加大对象列　　268
11.5.3 　删除大对象列　　268
11.5.4 　缓存大对象　　269
11.5.5 　大对象的内嵌和行外存储方式　　269
11.6 　实现SecureFiles高级功能　　270
11.6.1 　压缩大对象　　270
11.6.2 　对大对象应用删除重复数据功能　　271
11.6.3 　加密大对象　　272
11.6.4 　从BasicFiles迁移到SecureFiles　　274
11.7 　加载大对象　　276
11.7.1 　加载CLOB数据　　276
11.7.2 　加载BLOB数据　　277
11.8 　测量大对象占用的空间　　278
11.8.1 　BasicFiles大对象占用的空间　　278
11.8.2 　SecureFiles大对象占用的空间　　279
11.9 　读取BFILE数据　　280
11.10 　小结　　281
第12章　分区：分而治之　　282
12.1 　应对哪种表应用分区功能　　283
12.2 　创建分区表　　284
12.2.1 　按范围分区　　284
12.2.2 　使用表空间存储分区　　287
12.2.3 　根据列表值分区　　290
12.2.4 　散列分区　　291
12.2.5 　组合使用多种分区方法　　292
12.2.6 　根据需要创建分区　　293
12.2.7 　根据父表分区　　296
12.2.8 　虚拟列分区　　298
12.2.9 　赋予应用控制分区的能力　　299
12.3 　管理分区　　299
12.3.1 　查看分区的元数据　　299
12.3.2 　移动分区　　300
12.3.3 　自动移动更新的行　　301
12.3.4 　为现存的表创建分区　　302
12.3.5 　增加分区　　303
12.3.6 　通过现存的表交换分区　　305
12.3.7 　重命名分区　　306
12.3.8 　拆分分区　　307
12.3.9 　合并分区　　307
12.3.10 　删除分区　　308
12.3.11 　统计分区数据　　309
12.3.12 　删除分区中的行　　309
12.3.13 　操作分区中的数据　　310
12.4 　索引分区　　311
12.4.1 　使用表分区策略创建索引分区　　311
12.4.2 　使用与表不同的分区策略创建索引分区　　314
12.4.3 　部分索引　　315
12.5 　分区修剪　　316
12.6 　小结　　317
第13章　数据泵　　319
13.1 　数据泵的结构　　319
13.2 　入门　　322
13.2.1 　执行导出操作　　323
13.2.2 　导入表　　325
13.2.3 　使用参数文件　　325
13.3 　深入了解导出和导入操作　　326
13.3.1 　全数据库级　　326
13.3.2 　方案级　　327
13.3.3 　表级　　328
13.3.4 　表空间级　　329
13.4 　传输数据　　329
13.4.1 　直接通过网络执行导出和导入操作　　329
13.4.2 　复制数据文件　　331
13.5 　管理存储方式的功能　　333
13.5.1 　导出表空间元数据　　333
13.5.2 　设置不同的数据文件路径和名称　　333
13.5.3　　向结构与源数据库不相同的目的数据库导入表空间　　334
13.5.4 　更改数据文件的尺寸　　334
13.5.5 　更改段和存储属性　　335
13.6 　过滤数据和对象　　335
13.6.1 　设置QUERY参数　　336
13.6.2 　按百分比导出数据　　337
13.6.3 　从导出文件排除对象　　337
13.6.4 　排除统计数据　　338
13.6.5 　仅在导出文件中包含指定对象　　339
13.6.6 　导出表、索引、约束和触发器DDL　　339
13.6.7 　从导入文件中排除对象　　339
13.6.8 　在导入内容中包含对象　　340
13.7 　常见的数据泵任务　　340
13.7.1 　估算导出作业的尺寸　　340
13.7.2 　列出数据泵文件的内容　　341
13.7.3 　克隆用户　　341
13.7.4 　创建一致的导出文件　　342
13.7.5 　在对象已经存在的情况下执行导入操作　　343
13.7.6 　重命名表　　344
13.7.7 　重新映射数据　　345
13.7.8 　不创建日志文件　　346
13.7.9 　使用并行机制　　346
13.7.10 　设置额外的数据泵文件　　347
13.7.11 　重用导出文件名称　　347
13.7.12 　创建处理日常任务的DDL文件　　348
13.7.13 　压缩导出文件　　348
13.7.14 　在导入时更改表的压缩属性　　349
13.7.15 　加密数据　　349
13.7.16 　将视图导出为表　　350
13.7.17 　在导入时禁用重做日志功能　　351
13.8 　命令行交互模式　　351
13.8.1 　进入命令行交互模式　　351
13.8.2 　附加正在运行的作业　　353
13.8.3 　停止和重启作业　　353
13.8.4 　终止数据泵作业　　354
13.9 　监控数据泵作业　　354
13.9.1 　数据泵日志文件　　355
13.9.2 　数据字典视图　　355
13.9.3 　数据泵警告日志　　355
13.9.4 　状态表　　356
13.9.5 　命令行交互模式STATUS命令　　356
13.9.6 　OS实用程序　　357
13.10 　数据泵传统模式　　357
13.10.1 　将数据泵映射到exp实用程序上　　357
13.10.2 　将数据泵映射到imp实用程序上　　358
13.11 　小结　　359
第14章　外部表　　361
14.1 　SQL*Loader和外部表　　361
14.2 　向数据库加载CSV文件　　362
14.2.1 　创建目录对象并分配访问权限　　363
14.2.2 　创建外部表　　364
14.2.3 　生成用于创建外部表的SQL代码　　364
14.2.4 　查看外部表元数据　　366
14.2.5 　通过外部表为普通表加载数据　　367
14.3 　执行高级转换任务　　368
14.4 　通过SQL查看文本文件　　369
14.5 　使用外部表卸载、加载数据　　371
14.5.1 　启用并行机制加快处理速度　　373
14.5.2 　压缩数据泵文件　　373
14.5.3 　加密数据泵文件　　374
14.6 　小结　　375
第15章　物化视图　　376
15.1 　MV简介　　376
15.1.1 　MV的术语　　377
15.1.2 　参考有用的视图　　378
15.2 　创建基本物化视图　　379
15.2.1 　创建完全刷新MV　　379
15.2.2 　创建快速刷新的MV　　382
15.3 　MV进阶　　386
15.3.1 　创建MV并为MV和索引设置表空间　　386
15.3.2 　在MV上创建索引　　387
15.3.3 　分区MV　　387
15.3.4 　压缩MV　　388
15.3.5 　加密MV列　　388
15.3.6 　使用预建表创建MV　　389
15.3.7 　创建不含数据的MV　　390
15.3.8 　创建在提交时刷新的MV　　391
15.3.9 　创建从不刷新的MV　　391
15.3.10 　为查询重写创建MV　　392
15.3.11 　使用复杂查询操作创建快速刷新MV　　393
15.3.12 　查看MV的DDL代码　　395
15.3.13 　删除MV　　395
15.4 　修改MV　　396
15.4.1 　修改主表的DDL代码并使MV反映这些更改　　396
15.4.2 　触发MV上的重做日志功能　　399
15.4.3 　更改并行机制　　400
15.4.4 　移动MV　　400
15.5 　管理MV日志　　400
15.5.1 　创建MV日志　　401
15.5.2 　索引MV日志列　　402
15.5.3 　查看MV日志占用的空间　　403
15.5.4 　缩小MV日志占用的空间　　403
15.5.5 　检查MV日志的行数　　404
15.5.6 　移动MV日志　　404
15.5.7 　删除MV日志　　405
15.6 　刷新MV　　405
15.6.1 　利用SQL*Plus手动刷新MV　　406
15.6.2 　使用Shell脚本和调度实用程序执行自动刷新　　407
15.6.3 　使用Oracle内置的作业调度程序自动刷新MV　　408
15.6.4 　高效执行完全刷新操作　　409
15.6.5 　处理ORA-12034错误　　409
15.7 　监控MV的刷新操作　　410
15.7.1 　查看上次刷新时间　　410
15.7.2 　确定刷新作业是否正在进行　　410
15.7.3 　监控刷新操作的进度　　410
15.7.4 　检查MV是否按计划刷新　　411
15.8 　创建远程MV　　412
15.8.1 　了解远程刷新操作的结构　　413
15.8.2 　查看MV主表的信息　　414
15.8.3 　确定中心MV日志被多少个MV引用　　415
15.9 　管理MV组　　416
15.9.1 　创建MV组　　417
15.9.2 　更改MV组　　417
15.9.3 　刷新MV组　　418
15.9.4 　DBMS_MVIEW和DBMS_REFRESH　　418
15.9.5 　确定MV组中的MV　　419
15.9.6 　向MV组中添加MV　　419
15.9.7 　从MV组删除MV　　419
15.9.8 　删除MV组　　420
15.10 　小结　　420
第16章　用户管理的备份与恢复　　421
16.1 　为没有处于归档日志模式的数据库实现冷备份策略　　422
16.1.1 　冷备份非归档模式数据库　　422
16.1.2 　使用含有联机重做日志的冷备份恢复非归档日志模式的数据库　　424
16.1.3 　使用不含有联机重做日志的冷备份恢复非归档日志模式的数据库　　425
16.1.4 　编写执行冷备份与恢复的脚本　　426
16.2 　冷备份处于归档日志模式的数据库　　428
16.3 　热备份策略　　429
16.3.1 　创建热备份　　430
16.3.2 　使用脚本执行热备份　　432
16.3.3 　了解分割块问题　　434
16.3.4 　了解在备份过程中生成重做日志的必要性　　437
16.3.5 　了解数据文件的更新情况　　438
16.4 　对处于归档重做日志模式的数据库执行完全恢复　　439
16.4.1 　在脱机情况下恢复数据库　　439
16.4.2 　恢复联机数据库　　443
16.4.3 　恢复控制文件　　444
16.5 　对处于归档日志模式的数据库执行不完全恢复　　447
16.6 　小结　　449
第17章　配置RMAN　　450
17.1 　了解RMAN　　451
17.2 　启动RMAN　　453
17.3 　RMAN结构决策　　454
17.3.1 　以远程或本地方式运行RMAN客户端　　456
17.3.2 　设置备份用户　　457
17.3.3 　使用联机或脱机备份　　457
17.3.4 　设置归档重做日志的存储位置和文件格式　　457
17.3.5 　配置RMAN备份的存储位置和文件格式　　458
17.3.6 　设置自动备份控制文件的功能　　460
17.3.7 　设置控制文件自动备份的存储位置　　461
17.3.8 　备份归档重做日志　　461
17.3.9 　确定控制文件快照的存储位置　　462
17.3.10 　使用恢复目录　　462
17.3.11 　使用介质管理器　　463
17.3.12 　设置初始化参数CONTROL_FILE_RECORD_KEEP_TIME　　463
17.3.13 　配置RMAN备份的保留策略　　464
17.3.14 　配置归档重做日志的删除策略　　465
17.3.15 　设置并行度　　466
17.3.16 　使用备份集或镜像副本　　467
17.3.17 　使用增量备份　　468
17.3.18 　使用增量更新备份　　468
17.3.19 　使用块修改跟踪功能　　468
17.3.20 　配置二进制文件压缩功能　　469
17.3.21 　配置加密功能　　470
17.3.22 　配置各种设置　　471
17.3.23 　配置输出信息　　471
17.4 　后续决策　　472
17.5 　小结　　476
第18章　RMAN备份和报告　　477
18.1 　运行RMAN BACKUP命令的准备工作　　477
18.1.1 　设置NLS_DATE_FORMAT变量　　478
18.1.2 　设置ECHO参数　　478
18.1.3 　查看RMAN变量　　479
18.2 　运行备份操作　　479
18.2.1 　备份整个数据库　　479
18.2.2 　备份表空间　　481
18.2.3 　备份数据文件　　481
18.2.4 　备份控制文件　　481
18.2.5 　备份spfile　　482
18.2.6 　备份归档重做日志　　482
18.2.7 　备份FRA　　483
18.2.8 　从备份中去除表空间的备份　　483
18.2.9 　备份还未备份的数据文件　　484
18.2.10 　跳过只读表空间　　484
18.2.11 　跳过脱机文件和无法访问的文件　　484
18.2.12 　以并行方式备份大型文件　　485
18.2.13 　向RMAN仓库中添加RMAN备份信息　　486
18.3 　备份可插拔数据库　　486
18.3.1 　连接根容器数据库　　487
18.3.2 　连接可插拔数据库　　487
18.4 　创建增量备份　　488
18.4.1 　创建分级增量备份　　489
18.4.2 　创建增量更新备份　　490
18.4.3 　使用块修改跟踪功能　　490
18.5 　检查数据文件和备份文件中的坏块　　491
18.5.1 　使用VALIDATE命令　　492
18.5.2 　使用BACKUP…VALIDATE命令　　493
18.5.3 　使用RESTORE…VALIDATE命令　　493
18.6 　使用恢复目录　　493
18.6.1 　创建恢复目录　　493
18.6.2 　注册目标数据库　　495
18.6.3 　备份恢复目录　　495
18.6.4 　同步恢复目录　　495
18.6.5 　创建恢复目录的Oracle版本　　496
18.6.6 　删除恢复目录　　496
18.7 　记录RMAN的输出结果　　496
18.7.1 　将输出结果重定向到文件　　497
18.7.2 　使用Linux/UNIX的记录日志命令捕捉输出信息　　497
18.7.3 　将输出信息记录到文件中　　498
18.7.4 　通过数据字典查询输出信息　　498
18.8 　RMAN报告　　499
18.8.1 　使用LIST命令　　499
18.8.2 　使用REPORT命令　　500
18.8.3 　使用SQL查询命令　　500
18.9 　小结　　503
第19章　RMAN恢复操作　　504
19.1 　确定是否需要执行介质恢复操作　　505
19.2 　确定需要恢复的内容　　506
19.2.1 　恢复操作的运作过程　　506
19.2.2 　使用Data Recovery Advisor　　507
19.3 　使用RMAN关闭或启动数据库　　510
19.3.1 　关闭数据库　　510
19.3.2 　启动数据库　　511
19.4 　完全恢复　　511
19.4.1 　测试恢复操作　　511
19.4.2 　恢复整个数据库　　513
19.4.3 　恢复表空间　　514
19.4.4 　恢复只读表空间　　515
19.4.5 　恢复临时表空间　　516
19.4.6 　恢复数据文件　　516
19.4.7 　将数据文件恢复到非默认位置　　518
19.4.8 　执行数据块级恢复操作　　519
19.4.9 　恢复容器数据库和与其关联的可插拔数据库　　520
19.5 　恢复归档日志文件　　522
19.5.1 　将备份恢复到默认位置　　522
19.5.2 　将备份恢复到非默认位置　　523
19.6 　恢复控制文件　　523
19.6.1 　使用恢复目录　　523
19.6.2 　使用自动备份　　524
19.6.3 　指定备份文件的名称　　524
19.7 　恢复spfile文件　　524
19.8 　不完全恢复　　525
19.8.1 　如何选择不完全恢复操作　　527
19.8.2 　基于时间的恢复操作　　528
19.8.3 　基于日志序列号的恢复操作　　528
19.8.4 　基于SCN的恢复操作　　529
19.8.5 　恢复到还原点　　529
19.8.6 　将表恢复到过去的时间点　　530
19.9 　闪回表　　531
19.9.1 　FLASHBACK TABLE TO BEFORE DROP命令　　531
19.9.2 　将表闪回到过去的时间点　　533
19.10 　闪回数据库　　534
19.11 　将备份恢复到其他服务器　　535
19.12 　小结　　545
第20章　Oracle安全备份　　546
20.1 　OSB的版本和功能　　546
20.2 　OSB术语　　547
20.2.1 　OSB管理域和服务器　　547
20.2.2 　OSB的界面　　548
20.2.3 　OSB用户和等级　　549
20.2.4 　OSB守护进程　　549
20.3 　下载和安装　　549
20.4 　通过命令行界面访问OSB　　552
20.5 　配置OSB　　553
20.5.1 　配置用户和等级　　553
20.5.2 　配置介质家族　　555
20.5.3 　配置数据库备份存储选择器　　555
20.6 　数据库备份　　556
20.7 　恢复数据库操作　　557
20.8 　文件系统备份　　558
20.8.1 　创建数据集文件　　559
20.8.2 　配置备份窗口　　560
20.8.3 　配置备份时间表和触发器　　560
20.8.4 　根据需要执行文件系统备份操作　　561
20.9 　文件系统恢复操作　　562
20.9.1 　执行基于目录的恢复操作　　562
20.9.2 　执行原始数据恢复操作　　562
20.9.3 　执行obtar命令　　563
20.10 　监控OSB作业　　564
20.10.1 　列出作业　　564
20.10.2 　显示作业的脚本　　566
20.10.3 　监控OSB日志　　567
20.11 　虚拟测试设备　　568
20.12 　云计算中的Oracle数据库备份　　569
20.13 　升级OSB软件　　571
20.14 　小结　　571
第21章　作业自动化　　572
21.1 　使用Oracle Scheduler实现自动化作业　　573
21.1.1 　创建和调度作业　　573
21.1.2 　查看作业的细节　　574
21.1.3 　修改作业的日志历史记录　　574
21.1.4 　修改作业　　575
21.1.5 　停止作业　　575
21.1.6 　暂停作业　　575
21.1.7 　启动作业　　575
21.1.8 　复制作业　　576
21.1.9 　手动运行作业　　576
21.1.10 　删除作业　　576
21.2 　Oracle Scheduler和cron　　576
21.3 　通过cron使作业自动化　　577
21.3.1 　cron的运作方式　　577
21.3.2 　启用cron　　579
21.3.3 　了解cron表条目　　579
21.3.4 　使作业自动运行　　580
21.3.5 　重定向cron输出结果　　583
21.3.6 　处理cron问题　　584
21.4 　自动化DBA作业的示例　　584
21.4.1 　启动和停止数据库与监听器　　585
21.4.2 　检查归档重做日志存储位置的可用空间　　588
21.4.3 　跟踪大型日志文件　　590
21.4.4 　检查锁定的产品数据库账号　　591
21.4.5 　检查某个时间点前的文件　　592
21.4.6 　检查是否存在过多的进程　　592
21.4.7 　检查RMAN备份的完整性　　593
21.5 　小结　　594
第22章　数据库疑难解答　　595
22.1 　快速分类　　595
22.1.1 　检查数据库的可用性　　595
22.1.2 　检查可用空间　　597
22.1.3 　检查警告日志　　599
22.2 　通过OS实用程序找出瓶颈问题　　602
22.2.1 　寻找系统瓶颈　　603
22.2.2 　将操作系统进程与SQL命令对应起来　　606
22.3 　寻找资源密集型SQL命令　　608
22.3.1 　实时监控SQL命令的执行情况　　608
22.3.2 　运行Oracle诊断实用程序　　610
22.4 　检测和解决锁定问题　　613
22.5 　解决最大打开游标数量问题　　615
22.6 　撤销表空间疑难解答　　616
22.6.1 　确定撤销表空间尺寸是否正确　　616
22.6.2　　检查使用撤销表空间的SQL命令　　618
22.7 　处理临时表空间问题　　619
22.7.1 　确定临时表空间的尺寸是否正确　　619
22.7.2 　检查使用临时表空间的SQL命令　　621
22.8 　小结　　621
第23章　可插拔数据库　　623
23.1 　了解可插拔体系结构　　624
23.1.1 　转换范例　　626
23.1.2 　对备份与恢复操作的意义　　627
23.1.3 　细微调优　　628
23.2 　创建CDB　　629
23.2.1 　使用SQL命令手动创建CDB　　629
23.2.2 　使用DBCA　　631
23.2.3 　通过DBCA生成创建CDB的脚本　　632
23.2.4 　检查是否已经创建了CDB　　632
23.3 　管理根容器　　633
23.3.1 　连接根容器　　634
23.3.2 　显示当前连接容器的信息　　635
23.3.3 　启动和停止根容器　　635
23.3.4 　创建公用用户　　636
23.3.5 　创建公用角色　　636
23.3.6 　报告容器空间的相关信息　　637
23.3.7 　切换容器　　638
23.4 　在CDB中创建可插拔数据库　　638
23.4.1 　克隆种子容器　　639
23.4.2 　克隆现存的可插拔数据库　　640
23.4.3 　克隆非CDB数据库　　641
23.4.4 　从CDB中拔出可插拔数据库　　643
23.4.5 　将拔出的可插拔数据库插入CDB　　643
23.4.6 　使用DBCA通过种子容器创建可插拔数据库　　644
23.4.7 　检查可插拔数据库的状态　　645
23.5 　管理可插拔数据库　　645
23.5.1 　连接可插拔数据库　　645
23.5.2 　在可插拔环境中管理监听器　　646
23.5.3 　查看当前连接的可插拔数据库　　647
23.5.4 　启动和停止可插拔数据库　　648
23.5.5 　修改应用于可插拔数据库的初始化参数　　649
23.5.6 　重命名可插拔数据库　　649
23.5.7　　限定可插拔数据库使用空间的尺寸　　649
23.5.8 　查看可插拔数据库的历史记录　　650
23.5.9 　删除可插拔数据库　　650
23.6 　小结　　651
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Oracle 12c数据库管理（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle PL/SQL实例精解
译者序
前言
作者简介
致谢
第1章PL／SQL概念1
1.1实验1：PL／SQL架构1使用8
1.2.1初步掌握SQL Developer的使用
1.2.2初步掌握SQL*Plus的使用10
1.2.3执行PL／SQL脚本11
1.3实验3：PL／SQL基础知识14
1.3.1DBMS_OUTPUT.PUT_LINE语句14
1.3.2替代变量功能17
1.4总结21
第2章PL／SQL语言基础22
2.1实验：PL／SQL编程基础22
2.1.1PL／SQL语言组件23
2.1.2PL／SQL变量23
2.1.3PL／SQL保留字26
2.1.4PL／SQL中的标识符26
2.1.5挂靠的数据类型27
2.1.6声明和初始化变量29
2.1.7块作用域、嵌套块和标签32
2.2总结34
第3章在PL／SQL中的SQL35
3.1实验1：在PL／SQL中的DML
语句35
3.1.1使用SELECTINTO初始化变量36
3.1.2使用变量初始化的SELECTINTO语法37
3.1.3在PL／SQL块中使用DML38
3.1.4在PL／SQL块中使用序列39
3.2实验2：在PL／SQL中的事务控制40
3.2.1使用COMMIT、ROLLBACK和
SAVEPOINT40
3.2.2将DML和事务控制相结合43
3.3总结45
第4章条件控制：IF语句46
4.1实验1：IF语句46
4.1.1IF—THEN语句47
4.1.2IF—THEN—ELSE语句48
4.2实验2：ELSIF语句50
4.3实验3：嵌套的IF语句54
4.4总结56
第5章条件控制：CASE语句57
5.1实验1：CASE语句57
5.1.1CASE语句57
5.1.2搜索CASE语句59
5.2实验2：CASE表达式64
5.3实验3：NULLIF和COALESCE
函数67
5.3.1NULLIF函数67
5.3.2COALESCE函数69
5.4总结71
第6章迭代控制：第一部分72
6.1实验1：简单循环72
6.1.1EXIT语句73
6.1.2EXITWHEN语句76
6.2实验2：WHILE循环77
6.2.1使用WHILE循环77
6.2.2提前终止WHILE循环80
6.3实验3：数字FOR循环81
6.3.1在循环中使用IN选项82
6.3.2在循环中使用REVERSE选项84
6.3.3提前终止数字FOR循环84
6.4总结85
第7章迭代控制：第二部分86
7.1实验1：CONTINUE语句86
7.1.1使用CONTINUE语句86
7.1.2CONTINUEWHEN语句89
7.2实验2：嵌套循环92
7.2.1使用嵌套循环92
7.2.2使用循环标签93
7.3总结95
第8章错误处理和内置异常96
8.1实验1：处理错误96
8.2实验2：内置异常98
8.3总结103
第9章异常104
9.1实验1：异常作用域104
9.2实验2：用户定义的异常107
9.3实验3：异常传播111
9.4总结116
第10章异常：高级概念117
10.1实验1：RAISE_APPLICATION_ERROR117
10.2实验2：EXCEPTION_INIT编译指示120
10.3实验3：SQLCODE和SQLERRM122
10.4总结124
第11章游标简介125
11.1实验1：游标类型125
11.1.1使用隐式游标126
11.1.2使用显式游标127
11.2实验2：游标循环130
11.2.1处理显式游标130
11.2.2使用用户定义的记录133
11.2.3使用游标属性134
11.3实验3：游标FOR循环138
11.4实验4：嵌套游标139
11.5总结143
第12章高级游标144
12.1实验1：参数化游标144
12.2实验2：复杂的嵌套游标145
12.3实验3：FORUPDATE和WHERECURRENT游标147
12.3.1FORUPDATE游标147
12.3.2游标中的FORUPDATE触发器151
13.1.1数据库触发器151
13.1.2BEFORE触发器154
13.1.3AFTER触发器159
13.1.4自治事务160
13.2实验2：触发器类型162
13.2.1行触发器和语句触发器162
13.2.2INSTEADOF触发器163
13.3总结167
第14章变异表和复合触发器168
14.1实验1：变异表168
14.1.1什么是变异表168
14.1.2解决变异表问题170
14.2实验2：复合触发器172
14.2.1什么是复合触发器172
14.2.2解决变异表问题的复合触发器174
14.3总结177
第15章集合178
15.1实验1：PL／SQL表178
15.1.1关联数组179
15.1.2嵌套表181
15.1.3集合方法184
15.2实验2：变长数组187
15.3实验3：多级集合190
15.4总结192
第16章记录193
16.1实验1：记录类型193
16.1.1基于表和基于游标的记录194
16.1.2用户定义的记录196
16.1.3记录兼容性197
16.2实验2：嵌套记录199
16.3实验3：记录集合202
16.4总结205
第17章本地动态SQL206
17.1实验1：EXECUTEIMMEDIATE语句206
17.1.1使用EXECUTEIMMEDIATE语句207
17.1.2如何避免使用EXECUTEIMMEDIATE的常见ORA错误209
17.2实验2：OPEN—FOR、FETCH和CLOSE语句216
17.2.1打开游标216
17.2.2从游标中读取217
17.2.3关闭游标217
17.3总结223
第18章批量SQL224
18.1实验1：FORALL语句224
18.1.1使用FORALL语句225
18.1.2SAVEEXCEPTIONS选项228
18.1.3INDICESOF选项230
18.1.4VALUESOF选项230
18.2实验2：BULKCOLLECT子句232
18.3实验3：在SQL语句中绑定集合239
18.3.1将集合与EXECUTEIMMEDIATE语句绑定240
18.3.2将集合与OPEN—FOR、FETCH和CLOSE语句绑定245
18.4总结248
第19章过程249
19.1模块化代码的好处249
19.1.1块结构250
19.1.2匿名块250
19.2实验1：创建过程250
19.2.1实践创建过程的语法251
19.2.2查询数据字典来获取过程的信息252
19.3实验2：传递的过程参数IN和OUT253
19.4总结255
第20章函数256
20.1实验1：创建函数256
20.1.1创建存储函数257
20.1.2使用函数259
20.2实验2：在SQL语句中使用函数260
20.2.1在SQL语句中调用函数261
20.2.2编写复杂函数261
20.3实验3：在SQL中优化函数执行262
20.3.1使用WITH子句定义函数262
20.3.2使用UDF编译指示创建函数263
20.4总结263
……
第21章包264
第22章存储代码297
第23章Oracle对象类型306
第24章Oracle提供的包323
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle PL/SQL实例精解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库基础
第1章 Oracle简介　1.1　数据库理论简介　　1.1.1　关系数据库　　1.1.2　面向对象数据库系统　　1.1.3　分布式数据库　　1.1.4　并行数据库系统　　1.1.5　多媒体数据库　　1.1.6　数据仓库　1.2　Oracle软件体系结构　　1.2.1　Oracle数据库文件　　1.2.2　Oracle内存结构　　1.2.3　Oracle进程　1.3　C/S和B/S软件体系结构　　1.3.1　C/S软件体系结构　　1.3.2　B/S软件体系结构　　1.3.3　基于B/S结构与C/S结构结合的体系结构　1.4　Oracle 9i产品介绍　　1.4.1　Oracle 9i产品介绍　　1.4.2　Oracle 9i关键应用程序　　1.4.3　下一代数据库产品Oracle10g　1.5　数据库对象　1.6　SQL　1.7　PL/SQL　1.8　SQL*Plus　　1.8.1　SQL*Plus启动　　1.8.2　SQL*Plus命令　本章小结　习题1第2章　表管理和查询　2.1　列数据类型　　2.1.1　Oracle内建数据类型　　2.1.2　ANSI、DB2和SQL/DS数据类型　　2.1.3　用户自定义类型　　2.1.4　Oracle补充类型　2.2　表管理　　2.2.1　create table命令　　2.2.2　alter table命令　　2.2.3　rename命令　　2.2.4　truncate table命令　　2.2.5　drop table命令　2.3　select命令　　2.3.1　投影操作　　2.3.2　选择操作　2.4　运算符　　2.4.1　算术运算符　　2.4.2　连接运算符　　2.4.3　条件运算符　　2.4.4　集合运算符　2.5　单行函数　　2.5.1　字符函数　　2.5.2　数值函数　　2.5.3　日期函数　　2.5.4　转换函数　2.6　order by子句　2.7　组函数　　2.7.1　group by子句　　2.7.2　having子句　本章小结　习题2第3章　数据管理　3.1　数据操纵语言　　3.1.1　insert命令　　3.1.2　update命令　　3.1.3　delete命令　3.2　列约束　　3.2.1　unique约束　　3.2.2　check约束　　3.2.3　not null约束　3.3　表约束　　3.3.1　primary key约束　　3.3.2　foreign key约束　3.4　变更约束　　3.4.1　增加约束　　3.4.2　禁用约束　　3.4.3　启动约束　　3.4.4　删除约束　3.5　连接查询　　3.5.1　等值查询　　3.5.2　不等值查询　　3.5.3　外部连接　　3.5.4　自连接　3.6　嵌套查询　3.7　集合运算符　　3.7.1　并操作union　　3.7.2　交操作intersect　　3.7.3　差操作minus　本章小结　习题3第4章　数据库对象管理　4.1　视图管理　　4.1.1　创建视图　　4.1.2　创建可更新视图　　4.1.3　with check option和with read only选项　　4.1.4　drop view命令　4.2　索引管理　　4.2.1　create index命令　　4.2.2　drop index命令　4.3　序列管理　　4.3.1　create sequence命令　　4.3.2　alter sequence命令　　4.3.3　drop sequence命令　4.4　同义词管理　　4.4.1　create synonym命令　　4.4.2　drop synonym命令　4.5　用户管理　　4.5.1　create user命令　　4.5.2　alter user命令　　4.5.3　drop user命令　4.6　权限管理　　4.6.1　grant命令　　4.6.2　revoke命令　4.7　角色管理　　4.7.1　create role命令　　4.7.2　alter role命令　　4.7.3　set role命令　　4.7.4　drop role命令　4.8　数据字典　　4.8.1　静态数据字典　　4.8.2　动态数据字典　本章小结　习题4第5章　PL/SQL基础　5.1　PL/SQL块结构　5.2　PL/SQL基本数据类型　　5.2.1　预定义数据类型　　5.2.2　定义变量　　5.2.3　输入字符&　5.3　PL/SQL操作符　5.4　复合数据类型　　5.4.1　PL/SQL记录　　5.4.2　显式定义记录　　5.4.3　隐式定义记录　　5.4.4　PL/SQL集合　5.5　执行SQL　　5.5.1　select　　5.5.2　DML语句　　5.5.3　动态SQL　5.6　条件语句　　5.6.1　ifthen语句　　5.6.2　ifthenelse语句　　5.6.3　ifthenelsif语句　　5.6.4　case语句　5.7　循环语句　　5.7.1　loop和exit语句　　5.7.2　forloop语句　　5.7.3　whileloop语句　本章小结　习题5第6章　游标和异常管理　6.1　游标概述　6.2　显式游标　　6.2.1　declare语句　　6.2.2　open语句　　6.2.3　fetch语句　　6.2.4　close语句　6.3　显式游标属性　　6.3.1　%found属性　　6.3.2　%notfound属性　　6.3.3　%isopen属性　　6.3.4　%rowcount属性　6.4　cursor for循环　6.5　隐式游标　　6.5.1　SQL%found属性　　6.5.2　SQL%notfound属性　　6.5.3　SQL%isopen属性　　6.5.4　SQL%rowcount属性　6.6　异常处理概述　6.7　异常处理种类　　6.7.1　预定义异常　　6.7.2　自定义异常　　6.7.3　SQLCODE和SQLERRM　　6.7.4　给自定义错误标注号码　本章小结　习题6第7章　PL/SQL子程序设计　7.1　子程序　7.2　过程　　7.2.1　过程概述　　7.2.2　参数模式in举例　　7.2.3　参数模式out举例　　7.2.4　参数模式in out举例　7.3　函数　7.4　包　　7.4.1　包概述　　7.4.2　创建包　　7.4.3　使用DBMS_SQL包　7.5　触发器　　7.5.1　触发器概述　　7.5.2　referencing选项　　7.5.3　for each row选项　　7.5.4　when选项　　7.5.5　instead of选项　　7.5.6　条件谓词inserting、updating和deleting　7.6　数据字典　本章小结　习题7第8章　事务和备份恢复管理　8.1　事务处理概述　　8.1.1　事务管理目的　　8.1.2　事务属性　　8.1.3　分布式事务　8.2　提交和回滚　　8.2.1　事务提交　　8.2.2　事务回滚　　8.2.3　保存点　8.3　日志　8.4　锁机制　　8.4.1　并发控制　　8.4.2　Oracle锁类别　　8.4.3　行级别锁定　　8.4.4　表级别锁定　8.5　备份与恢复概述　　8.5.1　备份与恢复　　8.5.2　恢复管理器　　8.5.3　export和import安装　8.6　导出　　8.6.1　export命令　　8.6.2　通过参数文件导出　　8.6.3　增量导出　8.7　导入　　8.7.1　import命令　　8.7.2　通过参数文件导入　本章小结　习题8第9章　支付信息交换软件的数据库设计与实现　9.1　支付交易模型　9.2　软件体系结构　　9.2.1　层次结构　　9.2.2　面向对象结构　9.3　软件解决方案　　9.3.1　数据获取方式　　9.3.2　软件设计方案　9.4　支付数据交换接口设计　　9.4.1　CM过程　　9.4.2　MC过程　　9.4.3　MB过程　　9.4.4　BC过程　9.5　数据库设计　　9.5.1　表设计　　9.5.2　视图设计　　9.5.3　索引设计　　9.5.4　序列设计　　9.5.5　同义词设计　　9.5.6　包设计　　9.5.7　触发器设计　　9.5.8　异常处理　　9.5.9　角色设计　　9.5.10　备份计划设计　9.6　定义支付数据交换接口　　9.6.1　CM过程数据接口　　9.6.2　MB过程数据接口　　9.6.3　金融产品信息数据接口　　9.6.4　非金融产品数据接口　9.7　与现有系统数据交换接口　　9.7.1　与现有供货商IT系统接口　　9.7.2　与现有银行IT系统接口　9.8　UML描述　　9.8.1　用况图　　9.8.2　类图　　9.8.3　时序图　9.9　公共API　　9.9.1　EXML　　9.9.2　EFTP　9.10　项目功能设计　　9.10.1　供货商IT系统　　9.10.2　支付工具　　9.10.3　项目演示　本章小结　习题9附录A　Oracle 9i服务器端安装设置　A.1　服务器端安装　A.2　启动和关闭Oracle数据库　　A.2.1　启动和关闭监听器　　A.2.2　连接数据库　　A.2.3　启动和关闭数据库附录B　Oracle 9i客户端安装设置　B.1　客户端安装　B.2　配置Oracle Net Configuration Assistant
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库基础
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Visual C++与Oracle数据库编程案例
第1章 Oracle数据库基础
第2章 Visual C++数据库开发技术介绍
第3章 家庭备忘录管理系统
第4章 企业设备管理系统
第5章 人脉资源管理系统
第6章 客户资源管理系统
第7章 行业监管系统
第8章 公司人才储备管理系统
第9章 家庭账务管理系统
第10章 会议纪要管理系统
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Visual C++与Oracle数据库编程案例
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>AJAX+PHP+Oracle数据库Web开发
第Ⅰ部分　构建基础第1章　JavaScript和PHP的可扩展性  1.1  可扩展性  1.2　减少占用的CPU周期和RAM大小  1.3　扩展控制结构  1.4　扩展字符串操作  1.5　扩展简单的数学操作  1.6　扩展对象及其方法的影响  1.7　多个打印调用的可扩展性影响  1.8　减少网络负载　  1.8.1　使用AJAX减少网络负载　  1.8.2　使用压缩减少负载  1.9　小结第2章  PHP和JavaScript的模块性　2.1  模块性　  2.2　现实中的设计　  2.3　主模块和控制器　  2.4　应用程序控制器和反射　  2.5　使用控制器和反射时JavaScript的模块性　  2.6　小结第3章　JavaScript和PHP对象　3.1　类的定义与创建　3.2　继承　3.3　构造函数　3.4  public、protected和private　3.5  JavaScript属性及方法　3.6  PHP模型、控制器和控制对象　3.7  JavaScript模型、控制器和控制对象　3.8　小结    第Ⅱ部分　动态表示：用户接口与服务器之间的通信第4章　XMLHttpRequest对象　4.1　创建请求并处理结果　4.2　创建Server Access Object模块　4.3  小结第5章　AJAX、高级HTML及HTTP通信　5.1　创建HTML下钻表　5.2　HTTP头、错误及服务器通信　5.3  小结第6章　使用JavaScript操作DOM　6.1　文档对象模型　6.2　拖放功能　  6.2.1  拖放库　  6.2.2  PHP控制对象　  6.2.3  JavaScript控制对象　6.3　在数据库内保存拖放信息　6.4　小结    第Ⅲ部分　动态表示和通信的高级话题第7章　使用PHP数据访问对象进行远程处理  7.1  使用PHP和HTTP—RPC进行远程处理　7.2　使用Peat XML-RPC客户端和服务进行远程处理  7.3  小结第8章　AJAX、制图和简单的数据传输  8.1  使用SimplePlot库  8.2　在服务器上生成图表数据  8.3　使用AJAX获取数据  8.4　小结第9章　在AJAX中启用后退按钮    第Ⅳ部分　创建具有高灵活性、高可扩展性的应用程序第10章　客户端和服务端会话第11章　创建用户定义的内容聚合第12章　多模式通信：VOIP、IM和存储报告    第Ⅴ部分　附录附录A　HTML标记索引附录B　PHP入门附录C　Oracle数据库管理入门附录D　Oracle数据库SQL入门附录E　PL/SQL入门
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>AJAX+PHP+Oracle数据库Web开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Application Server 10g管理手册
第一章 Oracle Application Server 10g的体系结构和管理
第二章 Oracle Application Server 10g的基础结构
第三章 安装Oracle Application Server 10g
第四章 使用Oracle HTTP服务器
第五章 Web Cache管理
第六章 Application Server 10g中J2EE的使用
第七章 OC4J
第八章 数据库连接和TOPLinK
第九章 高可用性
第十章 性能调整
第十一章 备份与恢复
第十二章 Oracle Application Server 10g的安全性
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Application Server 10g管理手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Microsoft，UNIX及Oracle主机和网络安全
第一章 评测内部网的安全性
第二章 公司资产清单和暴露点
第三章 寻找高危漏洞
第四章 攻击和防护WINDOWS XP PROFESSIONAL
第五章 攻击和防护WINDOWS 2000
第六章 保护活动目录
第七章 保护EXCHANGE和OUTLOOK网络入口
第八章 攻击和防护DNS
第九章 攻击和防护MICROSOFT终端服务器
第十章 保护IIS
第十一章 攻击客户WEB应用程序
第十二章 攻击和防护MICROSOFT SQL SERVER
第十三章 攻击和防护ORACLE
第十四章 攻击和防护UNIX
第十五章 无线LAN：发现和防护
第十六章 网络架构
第十七章 构建人力资源因素
第十八章 创建高效的企业安全策略
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Microsoft，UNIX及Oracle主机和网络安全
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 10g基础教程
第一章  网格计算时代
第二章  安装和配置
第三章  Oracle Database 10g的新增功能
第四章  体系结构
第五章  SQL基础
第六章  SQL*Plus基础
第七章  PL/SQL语言
第八章  管理用户和表
第九章  管理安全性
第十章  事务处理和并发控制
第十一章  管理表
第十二章  索引
第十三章  视图
第十四章  过程、函数和程序包
第十五章  触发器
第十六章  闪回操作
第十七章  管理高可用性
第十八章  数据传输技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 10g基础教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle高级编程
第1章  Oracle体系结构和存储
第2章  使用SQL
第3章  多用户控制
第4章  数据库设计基础
第5章  Oracle安全性
第6章  Oracle数据字典
第7章  安装Oracle
第8章  SQL概述
第9章  扩展的SQL
第10章  索引
第11章  约束
第12章  其他数据库结构
第13章  函数
第14章  分布式查询、事务与数据库
第15章  PL/SQL基础
第16章  PL/SQL与SQL
第17章  PL/SQL包
第18章  Java数据库编程简介
第19章  触发器
第20章  正则表达式和表达式过滤器
第21章  对象关系与Oracle的交互
第22章  Oracle XML DB
第23章  HTML-DB
第24章  高速数据移动
第25章  数据装载和管理
第26章  业务智能化查询
第27章  业务智能化分析
第28章  优化
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle高级编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle性能诊断艺术（第2版）
第一部分 　基　础
第1章 　性能问题　　2
1.1 　需要为性能做规划吗　　2
1.1.1 　需求分析　　2
1.1.2 　分析与设计　　4
1.1.3 　编码和单元测试　　4
1.1.4 　集成和验收测试　　6
1.2 　为性能而设计　　6
1.2.1 　缺乏数据库逻辑设计　　6
1.2.2 　实现通用表　　7
1.2.3 　未使用约束加强数据完整性　　7
1.2.4 　缺乏数据库物理设计　　7
1.2.5 　未正确选择数据类型　　8
1.2.6 　未正确使用绑定变量　　8
1.2.7 　未利用数据库高级特性　　8
1.2.8 　未使用PL/SQL进行以数据为中心的处理　　9
1.2.9 　执行不必要的提交　　9
1.2.10 　持续打开和关闭数据库连接　　9
1.3 　你真的面临性能问题吗　　9
1.3.1 　系统监控　　10
1.3.2 　响应时间监控　　10
1.3.3 　强迫性调优障碍　　10
1.4 　如何处理性能问题　　11
1.4.1 　业务视角和系统视角　　11
1.4.2 　问题的编录　　12
1.4.3 　解决问题　　12
1.5 　小结　　15
第2章 　关键概念　　16
2.1 　选择率和基数　　16
2.2 　什么是游标　　17
2.3 　游标的生命周期　　18
2.4 　解析的工作原理　　20
2.4.1 　可共享游标　　22
2.4.2 　绑定变量　　25
2.5 　读写数据块　　35
2.6 　检测　　36
2.6.1 　应用程序代码　　37
2.6.2 　数据库调用　　39
2.7 　小结　　42
第二部分 　识　别
第3章 　分析可重现的问题　　45
3.1 　跟踪数据库调用　　45
3.1.1 　SQL跟踪　　45
3.1.2 　跟踪文件的结构　　57
3.1.3 　使用TRCSESS　　59
3.1.4 　探查器　　60
3.1.5 　使用TKPROF　　60
3.1.6 　使用TVD$XTAT　　70
3.2 　探查PL/SQL代码　　79
3.2.1 　使用DMBS_HPROF　　79
3.2.2 　使用DBMS_PROFILER　　85
3.2.3 　触发探查器　　89
3.3 　小结　　90
第4章 　实时分析不可重现的问题　　91
4.1 　分析路线图　　91
4.2 　动态性能视图　　93
4.2.1 　操作系统统计信息　　93
4.2.2 　时间模型统计信息　　94
4.2.3 　等待级别和等待事件　　96
4.2.4 　系统和会话统计信息　　100
4.2.5 　度量值　　101
4.2.6 　当前会话状态　　102
4.2.7 　活动会话历史　　103
4.2.8 　SQL语句统计信息　　111
4.2.9 　实时监控　　112
4.3 　使用Diagnostics Pack和Tuning Pack进行分析　　115
4.3.1 　数据库服务器负载　　115
4.3.2 　系统级别分析　　116
4.3.3 　会话级别分析　　120
4.3.4 　SQL语句信息　　122
4.4 　不使用Diagnostics Pack进行分析　　125
4.4.1 　数据库服务器负载　　125
4.4.2 　系统级别分析　　126
4.4.3 　会话级别分析　　129
4.4.4 　SQL语句信息　　130
4.5 　小结　　131
第5章 　不可重现问题的事后分析　　132
5.1 　知识库　　132
5.2 　自动工作负载存储库　　133
5.2.1 　执行配置　　133
5.2.2 　捕获快照　　134
5.2.3 　管理基线　　135
5.3 　Statspack　　136
5.3.1 　执行安装　　137
5.3.2 　配置存储库　　137
5.3.3 　捕获和清除快照　　138
5.3.4 　管理基线　　139
5.4 　使用Diagnostics Pack进行分析　　140
5.5 　不使用Diagnostics Pack进行分析　　140
5.6 　小结　　145
第三部分 　查询优化器
第6章 　查询优化器简介　　148
6.1 　基础知识　　148
6.2 　体系结构　　150
6.3 　查询转换　　152
6.3.1 　计数转换　　152
6.3.2 　公共子表达式消除　　153
6.3.3 　“或”扩张　　153
6.3.4 　视图合并　　154
6.3.5 　选择列表裁剪　　155
6.3.6 　谓词下推　　156
6.3.7 　谓词迁移　　158
6.3.8 　非重复放置　　158
6.3.9 　非重复消除　　159
6.3.10 　Group-by放置　　159
6.3.11 　Order-By消除　　160
6.3.12 　子查询展开　　160
6.3.13 　子查询合并　　161
6.3.14 　使用窗口函数移除子查询　　162
6.3.15 　联接消除　　162
6.3.16 　联接因式分解　　163
6.3.17 　外联接转内联接　　163
6.3.18 　完全外联接　　164
6.3.19 　表扩张　　164
6.3.20 　集合操作联接转变　　165
6.3.21 　星型转换　　166
6.3.22 　物化视图查询重写　　166
6.4 　小结　　166
第7章 　系统统计信息　　167
7.1 　dbms_stats包　　167
7.2 　有哪些系统统计信息可用　　168
7.3 　收集系统统计信息　　170
7.3.1 　无工作负载统计信息　　170
7.3.2 　工作负载统计信息　　171
7.3.3 　在无工作负载统计信息和工作负载统计信息之间进行选择　　174
7.4 　还原系统统计信息　　174
7.5 　使用备份表　　175
7.6 　管理操作的日志记录　　176
7.7 　对查询优化器的影响　　177
7.8 　小结　　182
第8章 　对象统计信息　　183
8.1 　 dbms_stats包　　183
8.2 　有哪些对象统计信息可用　　185
8.2.1 　表统计信息　　186
8.2.2 　列统计信息　　187
8.2.3 　直方图　　189
8.2.4 　扩展统计信息　　200
8.2.5 　索引统计信息　　205
8.2.6 　分区对象统计信息　　206
8.3 　收集对象统计信息　　207
8.3.1 　目标对象　　208
8.3.2 　收集选项　　212
8.3.3 　备份表　　217
8.4 　配置dbms_stats包　　218
8.4.1 　传统方式　　218
8.4.2 　现代方式　　219
8.5 　处理全局临时表　　221
8.6 　处理挂起的对象统计信息　　222
8.7 　处理分区对象　　223
8.7.1 　挑战　　223
8.7.2 　增量统计信息　　226
8.7.3 　复制统计信息　　228
8.8 　调度对象统计信息的收集　　229
8.8.1 　10g方式　　229
8.8.2 　11g和12c方式　　231
8.9 　还原对象统计信息　　232
8.10 　锁定对象统计信息　　234
8.11 　比较对象统计信息　　236
8.12 　删除对象统计信息　　238
8.13 　导出、导入、获取和设置对象统计信息　　239
8.14 　管理操作的日志记录　　239
8.15 　保持对象统计信息为最新的策略　　241
8.16 　小结　　242
第9章 　配置查询优化器　　243
9.1 　配置还是不配置　　243
9.2 　配置路线图　　244
9.3 　设置正确的参数　　245
9.3.1 　查询优化器参数　　246
9.3.2 　PGA管理　　260
9.4 　小结　　266
第10章 　执行计划　　267
10.1 　获取执行计划　　267
10.1.1 　EXPLAIN PLAN语句　　267
10.1.2 　动态性能视图　　270
10.1.3 　自动工作负载存储库和Statspack　　272
10.1.4 　跟踪工具　　274
10.2 　dbms_xplan包　　277
10.2.1 　输出　　277
10.2.2 　display函数　　281
10.2.3 　display_cursor函数　　286
10.2.4 　display_awr函数　　288
10.3 　解释执行计划　　289
10.3.1 　父?子关系　　290
10.3.2 　操作的类型　　292
10.3.3 　独立操作　　292
10.3.4 　迭代操作　　295
10.3.5 　无关联组合操作　　295
10.3.6 　关联组合操作　　297
10.3.7 　分而治之　　305
10.3.8 　特殊情况　　307
10.3.9 　自适应执行计划　　310
10.4 　识别低效的执行计划　　314
10.4.1 　错误的估算　　314
10.4.2 　未识别限制条件　　316
10.5 　小结　　317
第四部分 　优　化
第11章 　SQL优化技巧　　320
11.1 　修改访问结构　　321
11.1.1 　工作原理　　321
11.1.2 　何时使用　　322
11.1.3 　陷阱和谬误　　322
11.2 　修改SQL语句　　322
11.2.1 　工作原理　　322
11.2.2 　何时使用　　323
11.2.3 　陷阱和谬误　　324
11.3 　hint　　324
11.3.1 　工作原理　　324
11.3.2 　何时使用　　330
11.3.3 　陷阱和谬误　　330
11.4 　修改执行环境　　332
11.4.1 　工作原理　　332
11.4.2 　何时使用　　334
11.4.3 　陷阱和谬误　　334
11.5 　存储概要　　334
11.5.1 　工作原理　　335
11.5.2 　何时使用　　343
11.5.3 　陷阱和谬误　　343
11.6 　SQL配置文件　　344
11.6.1 　工作原理　　345
11.6.2 　何时使用　　357
11.6.3 　陷阱和谬误　　357
11.7 　SQL计划管理　　358
11.7.1 　工作原理　　359
11.7.2 　何时使用　　372
11.7.3 　陷阱和谬误　　372
11.8 　小结　　373
第12章 　解析　　374
12.1 　识别解析问题　　374
12.1.1 　快速解析　　375
12.1.2 　长解析　　380
12.2 　解决解析问题　　381
12.2.1 　快速解析　　381
12.2.2 　长解析　　387
12.3 　避开解析问题　　387
12.3.1 　游标共享　　388
12.3.2 　服务器端语句缓存　　390
12.4 　使用应用编程接口　　392
12.4.1 　PL/SQL　　392
12.4.2 　OCI　　395
12.4.3 　JDBC　　396
12.4.4 　ODP.NET　　398
12.4.5 　PHP　　399
12.5 　小结　　400
第13章 　优化数据访问　　401
13.1 　识别次优访问路径　　401
13.1.1 　识别　　401
13.1.2 　误区　　403
13.1.3 　原因　　405
13.1.4 　解决方案　　406
13.2 　弱选择性的SQL语句　　409
13.2.1 　全表扫描　　409
13.2.2 　全分区扫描　　411
13.2.3 　范围分区　　411
13.2.4 　散列和列表分区　　422
13.2.5 　复合分区　　422
13.2.6 　设计要素　　424
13.2.7 　全索引扫描　　426
13.3 　强选择性的SQL语句　　429
13.3.1 　Rowid访问　　429
13.3.2 　索引访问　　430
13.3.3 　单表散列群集访问　　468
13.4 　小结　　470
第14章 　优化联接　　471
14.1 　定义　　471
14.1.1 　联接树　　471
14.1.2 　联接的类型　　475
14.1.3 　限制条件与联接条件　　478
14.2 　嵌套循环联接　　479
14.2.1 　概念　　479
14.2.2 　两表联接　　480
14.2.3 　四表联接　　481
14.2.4 　缓冲区缓存预取　　482
14.3 　合并联接　　484
14.3.1 　概念　　484
14.3.2 　两表联接　　485
14.3.3 　四表联接　　488
14.3.4 　工作区　　489
14.4 　散列联接　　494
14.4.1 　概念　　494
14.4.2 　两表联接　　495
14.4.3 　四表联接　　496
14.4.4 　工作区　　498
14.4.5 　索引联接　　498
14.5 　外联接　　499
14.6 　选择联接方法　　499
14.6.1 　First-Rows优化　　500
14.6.2 　All-Rows优化　　500
14.6.3 　支持的联接方法　　500
14.6.4 　并行联接　　500
14.7 　分区智能联接　　501
14.7.1 　完全智能化分区连接　　501
14.7.2 　部分智能化分区联接　　504
14.8 　星型转换　　505
14.9 　小结　　511
第15章 　数据访问和联接优化之外　　512
15.1 　物化视图　　512
15.1.1 　工作原理　　512
15.1.2 　何时使用　　530
15.1.3 　陷阱和谬误　　531
15.2 　结果缓存　　531
15.2.1 　工作原理　　532
15.2.2 　何时使用　　538
15.2.3 　陷阱和谬误　　538
15.3 　并行处理　　539
15.3.1 　工作原理　　540
15.3.2 　何时使用　　567
15.3.3 　陷阱和谬误　　567
15.4 　直接路径插入　　571
15.4.1 　工作原理　　572
15.4.2 　何时使用　　574
15.4.3 　陷阱和谬误　　574
15.5 　行预取　　575
15.5.1 　工作原理　　575
15.5.2 　何时使用　　579
15.5.3 　陷阱和谬误　　580
15.6 　数组接口　　580
15.6.1 　工作原理　　580
15.6.2 　何时使用　　583
15.6.3 　陷阱和谬误　　583
15.7 　小结　　583
第16章 　优化物理设计　　584
16.1 　最优列顺序　　584
16.2 　最优数据类型　　586
16.2.1 　数据类型选择中的陷阱　　586
16.2.2 　数据类型选择最佳实践　　589
16.3 　行迁移和行链接　　591
16.3.1 　迁移与链接　　591
16.3.2 　问题描述　　593
16.3.3 　问题识别　　593
16.3.4 　解决方案　　594
16.4 　块争用　　594
16.4.1 　问题描述　　594
16.4.2 　问题识别　　595
16.4.3 　解决方案　　599
16.5 　数据压缩　　602
16.5.1 　概念　　602
16.5.2 　要求　　603
16.5.3 　方法　　603
参考文献　　606
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle性能诊断艺术（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>神奇獨角獸神諭占卜卡
如何使用神奇獨角獸神諭卡
牌卡意義
相信自己
最好的朋友
兄弟姊妹
改變
創意
好奇心
決定
肯定是
運動
家族文化
有始有終
原諒
祖父母
驚喜
快樂的想法
治療師
迎新送舊
想像
與眾不同沒有問題
就是做自己
笑聲
釋放壓力！
光
傾聽你的真實感受
愛
來自父母的愛
愛療癒恐懼
一次一步
寵物
練習
放鬆──每件事都很好
分享
簡單
說出你的感受
團隊工作
感激
真實
試點新鮮的
很快
水
向星星許願
值得等待
你充滿天賦
你會在早晨知曉
藝術作品訂購資訊
感謝
關於作者
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>神奇獨角獸神諭占卜卡
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>名师讲坛——Oracle DBA入门与实战经典
第0章  Oracle的安装及相关配置	1
（ 视频讲解：30分钟）
0.1  Oracle的安装	2
0.2  Oracle 11g中的SQL*Plus	6
0.3  scott用户及其对象维护	8
0.4  虚拟环境的创建	8
0.5  虚拟人物	10
第1章  Oracle的体系结构	12
1.1  Oracle引入复杂的体系结构的原因	13
1.2  Oracle数据库中常用的术语	14
1.3  Oracle数据库管理系统的体系结构	14
1.4  Oracle服务器	14
1.5  Oracle实例	15
1.6  Oracle数据库	15
1.7  Oracle其他的关键文件	15
1.8  建立与Oracle实例的连接	16
1.9  各种不同的连接方式	16
1.10  服务器进程	17
1.11  Oracle执行SQL查询语句的步骤	18
1.12  共享池	19
1.13  数据库高速缓冲区	20
1.14  内存缓冲区顾问	21
1.15  重做日志缓冲区	22
1.16  大池和Java池	23
1.17  内存缓冲区大小的设定	23
1.18  内存缓冲区信息的获取	24
1.19  重做日志写进程及快速提交	25
1.20  数据库写进程	26
1.21  系统监督进程	27
1.22  进程监督进程	27
1.23  校验（检查）点和校验点进程	27
1.24  归档日志进程	28
1.25  小结	29
1.26  您应该掌握的内容	30
第2章   数据库管理工具	31
（ 视频讲解：10分钟）
2.1  Oracle通用安装程序	32
2.2  交互式启动Oracle Universal Installer	32
2.3  非交互式启动Oracle Universal
Installer	33
2.4  Oracle数据库配置助手	33
2.5  使用Oracle数据库配置助手创建
数据库	34
2.6  数据库管理员用户sys和system	36
2.7  SQL*Plus命令行工具	38
2.8  服务器管理程序命令行工具	39
2.9  Oracle 9i企业管理器	40
2.10  Oracle 10g的iSQL*Plus工具	42
2.11  Oracle 10g企业管理器	43
2.12  Oracle 11g企业管理器	44
2.13  将SYSDBA权限授予普通用户	45
2.14  您应该掌握的内容	48
第3章  Oracle实例的管理	49
3.1  初始化参数文件	50
3.2  静态参数文件	50
3.3  静态参数文件的创建和例子	51
3.4  动态服务器参数文件	52
3.5  动态服务器参数文件的创建和参数的
浏览	53
3.6  启动数据库	54
3.7  将数据库置为限制模式	56
3.8  关闭数据库	58
3.9  关闭数据库的实际例子	59
3.10  如何利用诊断文件来监督实例	60
3.11  Oracle 11g诊断文件	63
3.12  Oracle 11g的ADRCI	66
3.13  您应该掌握的内容	70
第4章  数据字典和控制文件	71
4.1  数据字典简介	72
4.2  数据字典中所存的信息	72
4.3  数据字典的操作和使用	73
4.4  数据字典视图	73
4.5  格式化数据字典视图的输出	75
4.6  如何使用数据字典视图	77
4.7  动态性能表（视图）	79
4.8  数据字典应用实例	80
4.9  控制文件的定义及引入的目的	84
4.10  控制文件中所存的内容	84
4.11  从控制文件中获取信息的数据字典	85
4.12  如何限定控制文件的大小	85
4.13  怎样查看控制文件的配置	86
4.14  怎样添加和移动控制文件	88
4.15  控制文件的备份	89
4.16  移动控制文件的实例	90
4.17  您应该掌握的内容	96
第5章  重做日志文件	97
5.1  引入重做日志的目的	98
5.2  重做日志组	98
5.3  重做日志成员	99
5.4  日志切换和检查点	100
5.5  获取重做日志的信息	100
5.6  添加和删除联机重做日志文件组	102
5.7  添加和删除联机重做日志
成员（文件）	104
5.8  清除联机重做日志文件	107
5.9  利用OMF来管理联机重做日志文件	110
5.10  联机重做日志的配置	112
5.11  重做日志配置的应用实例	113
5.12  您应该掌握的内容	121
第6章  表空间和数据文件的管理	122
（ 视频讲解：18分钟）
6.1  Oracle引入逻辑结构的目的	123
6.2  Oracle数据库中存储结构之间的
关系	123
6.3  表空间和数据文件之间的关系及
表空间的分类	124
6.4  表空间中的磁盘空间管理	125
6.5  创建本地管理的表空间	126
6.6  还原表空间	128
6.7  临时表空间	129
6.8  默认临时表空间	131
6.9  设置表空间为脱机	133
6.10  只读表空间	135
6.11  重置表空间的大小	137
6.12  手工重置数据文件的大小	139
6.13  移动数据文件的方法	140
6.14  移动数据文件的应用实例	141
6.15  删除表空间	147
6.16  利用OMF来管理表空间	150
6.17  创建表空间的应用实例	153
6.18  您应该掌握的内容	157
第7章  存储结构和它们之间的关系	158
7.1  各种类型的段	159
7.2  存储子句的优先级	161
7.3  区段	161
7.4  数据库块	162
7.5  Oracle数据块的大小	163
7.6  数据库块的内容和参数	164
7.7  手工数据块的管理	166
7.8  自动的段空间管理	168
7.9  小结	170
7.10  您应该掌握的内容	170
第8章  管理还原数据	172
8.1  还原数据的管理方法	173
8.2  Oracle使用还原段的目的	173
8.3  还原段的类型	176
8.4  自动还原数据管理的概念和配置	176
8.5  还原表空间的创建与维护	177
8.6  还原表空间之间的切换	179
8.7  删除还原表空间	181
8.8  自动还原数据管理的一些参数及
应用实例	181
8.9  获得还原数据的信息	185
8.10  您应该掌握的内容	188
第9章  创建数据库	189
9.1  筹划和组织数据库优化而弹性的
体系结构	190
9.2  创建数据库的先决条件	191
9.3  创建数据库的方法	193
9.4  手工创建数据库	193
9.5  创建数据库过程中的排错	197
9.6  利用Oracle Managed Files来创建
数据库	198
9.7  您应该掌握的内容	199
第10章  表管理与维护	200
（ 视频讲解：11分钟）
10.1  存储数据的方法和Oracle内置
数据类型	201
10.2  ROWID	202
10.3  Oracle数据行的结构	204
10.4  创建普通表	205
10.5  创建临时表	206
10.6  表的维护和管理	208
10.7  非分区表的重组	209
10.8  列的维护	213
10.9  表的截断和删除	215
10.10  高水线及直接装入数据	216
10.11  收缩段	221
10.12  表压缩	225
10.13  创建表的应用实例	228
10.14  您应该掌握的内容	231
第11章  索引的管理与维护	232
11.1  Oracle引入索引的目的	233
11.2  索引的分类	233
11.3  B-树索引	234
11.4  位图索引	235
11.5  B-树索引和位图索引的比较	236
11.6  创建索引	237
11.7  重建和维护索引	240
11.8  标识索引的使用情况	243
11.9  删除索引	245
11.10  不可见索引	246
11.11  创建索引的应用实例	249
11.12  您应该掌握的内容	251
第12章  管理和维护数据完整性	252
12.1  数据的完整性	253
12.2  完整性约束的类型	253
12.3  完整性约束的状态	254
12.4  完整性约束的检验与定义	254
12.5  定义和维护约束的指导原则	259
12.6  关闭（禁止）和开启（激活）约束	259
12.7  重新命名和删除约束	266
12.8  您应该掌握的内容	268
第13章  用户及系统资源和安全的
管理	269
13.1  创建用户	270
13.2  数据库模式	272
13.3  改变用户在表空间上的配额	273
13.4  删除用户	274
13.5  用户的安全控制域	275
13.6  概要文件	275
13.7  利用概要文件进行资源管理	276
13.8  资源限制的设置	276
13.9  创建资源限制的概要文件	277
13.10  口令管理	279
13.11  口令验证函数	280
13.12  创建口令限制的概要文件	281
13.13  修改和删除概要文件	282
13.14  创建概要文件的应用实例	284
13.15  您应该掌握的内容	286
第14章  管理权限	288
14.1  权限的分类	289
14.2  系统权限	289
14.3  系统权限的限制	290
14.4  授予系统权限	291
14.5  回收系统权限	295
14.6  对象权限	298
14.7  对象权限的授权和回收	299
14.8  与Select Any Table权限相关的
应用实例	304
14.9  您应该掌握的内容	307
第15章  管理角色	308
15.1  引入角色的原因	309
15.2  角色的创建	309
15.3  角色的修改	310
15.4  角色的授权	311
15.5  建立默认角色	313
15.6  激活和禁止角色	317
15.7  角色的回收和删除	318
15.8  创建和使用角色指南	322
15.9  Oracle预定义的角色	327
15.10  用户、概要文件、权限和角色的
应用实例	329
15.11  您应该掌握的内容	336
第16章  非归档模式下的冷备份和
恢复	337
16.1  实验环境的搭建	338
16.2  数据库的非归档模式和备份的术语	340
16.3  冷备份（脱机备份）	342
16.4  冷恢复（脱机恢复）	343
16.5  脱机备份和脱机恢复的优缺点	343
16.6  脱机备份的应用实例	344
16.7  脱机恢复到原来位置的应用实例	352
16.8  脱机恢复到非原来位置的应用
实例	353
16.9  您应该掌握的内容	357
第17章  数据库的归档模式	358
17.1  归档模式的特点和要求	359
17.2  将数据库设置为归档模式	359
17.3  归档进程和归档文件目录的设置	361
17.4  归档文件和归档进程的管理与
维护	367
17.5  改变成归档模式的应用实例	371
17.6  您应该掌握的内容	376
第18章  数据库的联机备份及备份的
自动化	377
18.1  联机备份的重要性和特点	378
18.2  联机备份步骤的演示	379
18.3  联机备份步骤的解释	382
18.4  联机备份的其他问题	384
18.5  联机备份的应用实例	385
18.6  备份操作自动化的实例	388
18.7  您应该掌握的内容	394
第19章  归档模式下的数据库恢复	395
19.1  在归档模式下的介质恢复	396
19.2  数据库的完全恢复	396
19.3  RECOVER命令及与恢复有关的
数据字典	397
19.4  RECOVER期间归档日志文件的
使用	403
19.5  获取SQL*Plus命令的信息和
使用方法	404
19.6  数据库完全恢复方法	405
19.7  最初处于打开状态下进行的开启
数据库恢复	406
19.8  最初处于关闭状态下进行的开启
数据库恢复	407
19.9  恢复没有备份的数据文件	410
19.10  在关闭状态下进行数据库的
恢复	411
19.11  最初在关闭状态下进行开启数
据库恢复的实例	411
19.12  在关闭状态下进行数据库
恢复的实例	415
19.13  您应该掌握的内容	418
第20章  数据的移动	419
20.1  Oracle导出和导入应用程序	420
20.2  导出应用程序的用法	421
20.3  导入应用程序的用法	422
20.4  导出和导入程序的应用实例	423
20.5  数据泵	427
20.6  不同用户及不同表空间之间
数据的移动	432
20.7  将Oracle的数据传给其他软件
（系统）	438
20.8  将其他软件（系统）的数据
导入Oracle	443
20.9  数据泵操作的自动化	451
20.10  您应该掌握的内容	456
第21章  闪回技术、备份恢复与优化	457
21.1  闪回已经删除的表	458
21.2  闪回错误的DML操作	463
21.3  非当前的还原表空间的恢复	468
21.4  只读表空间和临时表空间的恢复	473
21.5  索引表空间的恢复	478
21.6  加快数据表空间的恢复	485
21.7  您应该掌握的内容	491
第22章  设计、程序及内存的优化	492
22.1  优化概述	493
22.2  优化系统设计的基本原理	494
22.3  以命令行方式获取系统的设计	497
22.4  优化应用程序和SQL语句的
基本原理	500
22.5  以命令行方式获取SQL语句执行
的信息	504
22.6  反转关键字索引	507
22.7  基于函数的索引	509
22.8  导出存储程序的源代码	512
22.9  SGA内存的优化	515
22.10  PGA内存的优化	521
22.11  将程序常驻内存	526
22.12  将数据缓存在内存	529
22.13  将数据常驻内存	531
22.14  将查询的结果缓存在内存	537
22.15  SGA和PGA内存的设置与它们
之间内存的转换	542
22.16  您应该掌握的内容	543
第23章  I/O优化	545
23.1  输入/输出优化概述	546
23.2  表空间与输入/输出优化	547
23.3  数据文件量的监控与诊断	548
23.4  表和索引一级的优化	552
23.5  删除操作对还原段的冲击及
解决方法	555
23.6  重做日志的优化	557
23.7  通过移动表和索引来减少I/O竞争的
实例	559
23.8  您应该掌握的内容	563
第24章  EM、iSQL*Plus和数据库
自动管理	564
（ 视频讲解：17分钟）
24.1  Oracle 10g和Oracle 11g企业管
理器简介	565
24.2  Oracle 10g和Oracle  11g数据库自动管理简介	574
24.3  数据库自动管理中的常用术语和
统计级别	575
24.4  自动工作负荷资料档案库	576
24.5  AWR基线	578
24.6  获取快照的信息与创建基线	580
24.7  AWR报告的创建与分析	582
24.8  不同时间段的AWR数据的比较	586
24.9  自动数据库诊断监视器	591
24.10  您应该掌握的内容	592
第25章  SQL语句追踪与优化	593
25.1  发现有问题的SQL语句及执行
计划的概念	594
25.2  利用AUTOTRACE追踪SQL
语句	595
25.3  执行计划的应用和EXPLAIN PLAN
命令	598
25.4  DBMS_XPLAN 软件包与编译树
简介	600
25.5  数据字典V$SQL与编译树应用
实例	602
25.6  位图连接（Bitmap Join）索引	605
25.7  手工设置排序区的实例	610
25.8  您应该掌握的内容	614
结束语		615
鸣谢		618
参考文献		619


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>名师讲坛——Oracle DBA入门与实战经典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JSP+Oracle组建动态网站实例精讲（附1光盘）
第一章 JSP应用指南
第二章 架设LINUX下的聊天聊务系统
第三章 架设LINUX下的电子邮件系统
第四章 信息查询系统网站
第五章 办公自动化网站
第六章 求职招聘
第七章 电子商务网站
第八章 交友网站
第九章 共享资源下载网站
第十章 在线宽带点播网站
第十一章 在线教育网站
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JSP+Oracle组建动态网站实例精讲（附1光盘）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库进阶
第1部分  高可用性第1章 RAC真应用集群第2章 ASM自动存储管理第3章 管理Clusterware组件及管理指令第4章 RAC与DataGuard    第2部分  数据库优化第5章 SQL优化第6章 Oracle实例优化第7章 I/O以及系统优化    第3部分  数据库备份与恢复第8章 RMAN备份与恢复数据库第9章 EXP/IMP及数据库备份与恢复第10章 Oracle数据泵技术第11章 用户管理的备份与恢复第12章 Oracle闪回技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库进阶
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle自学视频教程
目  录
本书光盘"自主学习系统"内容索引...XIII
第1篇  入  门  篇
第1章  数据库基础	2
（ 视频讲解：26分钟）
1.1  数据库概述	3
1.1.1  数据库的发展史	3
1.1.2  数据库系统的组成	3
1.1.3  什么是数据库管理系统	4
1.2  关系型数据库基础	4
1.2.1  关系型数据库概述	4
1.2.2  关系型数据库的E-R模型	6
1.2.3  关系型数据库的设计范式	7
1.3  本章常见错误	10
1.3.1  关系型数据库的概念错误	10
1.3.2  关于数据库范式的问题	10
1.4  本章小结	10
1.5  跟我上机	10
第2章  搭建Oracle数据库环境	11
（ 视频讲解：1小时6分钟）
2.1  Oracle概述	12
2.1.1  Oracle的发展历程	12
2.1.2  Oracle 11g新特性	12
2.2  Oracle 11g的安装与卸载	14
2.2.1  Oracle 11g的安装	14
2.2.2  Oracle 11g的卸载	20
2.3  Oracle 11g的管理工具	23
2.3.1  SQL*Plus工具	24
2.3.2  Oracle企业管理器	25
2.3.3  数据库配置助手	26
2.4  Oracle数据库的启动与关闭	27
2.4.1  启动Oracle数据库	27
2.4.2  关闭Oracle数据库	29
2.5  综合应用	30
2.5.1  通过DBCA创建一个数据库	30
2.5.2  强制关闭Oracle数据库	32
2.6  本章常见错误	32
2.6.1  安装Oracle数据库时出现错误	32
2.6.2  如果忘记Oracle密码，如何进
行登录	33
2.7  本章小结	33
2.8  跟我上机	33
第3章  Oracle数据库基础	34
（ 视频讲解：1小时30分钟）
3.1  Oracle体系结构概述	35
3.2  Oracle数据库的逻辑存储结构	35
3.2.1  数据块（Data Blocks）	36
3.2.2  数据区（Extent）	37
3.2.3  段（Segment）	37
3.2.4  表空间（TableSpace）	38
3.3  Oracle数据库的物理存储结构	39
3.3.1  数据文件	40
3.3.2  控制文件	42
3.3.3  日志文件	42
3.3.4  服务器参数文件	44
3.3.5  其他辅助文件	46
3.4  Oracle 11g服务器的结构	48
3.4.1  实例	48
3.4.2  程序全局区	54
3.4.3  前台进程	55
3.5  Oracle数据字典	55
3.5.1  Oracle数据字典概述	55
3.5.2  常用的Oracle数据字典	56
3.6  综合应用	57
3.6.1  查询数据库中所有段的存储
空间	57
3.6.2  查询数据库所使用的数据文件	58
3.7  本章常见错误	58
3.7.1  Oracle数据库实例与Oracle用户
的关系	58
3.7.2  如何获取数据库的sid	59
3.7.3  获取哪些用户在使用数据库	59
3.8  本章小结	59
3.9  跟我上机	59
第4章  SQL*Plus命令行工具的使用	60
（ 视频讲解：1小时22分钟）
4.1  SQL*Plus命令行工具概述	61
4.2  设置SQL*Plus的运行环境	61
4.2.1  SET命令讲解	61
4.2.2  使用SET命令设置运行环境	63
4.3  常用的SQL*Plus命令	67
4.3.1  HELP命令	68
4.3.2  DESCRIBE命令	68
4.3.3  SPOOL命令	70
4.3.4  其他常用命令	71
4.4  格式化查询结果	73
4.4.1  COLUMN命令	74
4.4.2  TTITLE和BTITLE命令	76
4.5  综合应用	78
4.5.1  使用SET NEWPAGE命令修改
指定数量的空行	78
4.5.2  使用TEXT值代替NULL值列	79
4.6  本章常见错误	79
4.6.1  通过SQL*Plus命令查看本机IP
地址的问题	79
4.6.2  SQL*Plus下如何修改编辑器	80
4.6.3  如何修改Oracle的默认日期	80
4.7  本章小结	80
4.8  跟我上机	80
第5章  SQL语言基础	81
（ 视频讲解：2小时12分钟）
5.1  SQL语言概述	82
5.1.1  SQL语言的特点	82
5.1.2  SQL语言的分类	83
5.1.3  SQL语言的编写规则	83
5.2  用户模式	84
5.2.1  模式与模式对象	85
5.2.2  示例模式SCOTT	85
5.3  Oracle常用函数	86
5.3.1  字符类函数	86
5.3.2  数字类函数	89
5.3.3  日期和时间类函数	91
5.3.4  转换类函数	92
5.3.5  聚合类函数	93
5.4  数据的查询	93
5.4.1  基本查询	94
5.4.2  筛选查询	97
5.4.3  分组查询	101
5.4.4  排序查询	102
5.4.5  多表关联查询	103
5.5  子查询的使用	107
5.5.1  子查询概述	108
5.5.2  单行子查询	108
5.5.3  多行子查询	109
5.5.4  关联子查询	110
5.6  常用数据库操作	110
5.6.1  添加数据（INSERT语句）	111
5.6.2  修改数据（UPDATE语句）	113
5.6.3  删除数据（DELETE语句和
TRUNCATE语句）	114
5.7  事务处理	115
5.7.1  事务概述	115
5.7.2  事务的操作	116
5.8  综合应用	118
5.8.1  统计某一个部门的雇员的最高和
最低工资	118
5.8.2  创建employees表的一个
副本	118
5.9  本章常见错误	119
5.9.1  插入数据时的效率问题	119
5.9.2  Oracle的分析数据对SQL执行
计划的影响	119
5.9.3  Oracle中如何搜索前N条
记录	120
5.10  本章小结	120
5.11  跟我上机	120
第6章  PL/SQL基础编程	121
（ 视频讲解：1小时8分钟）
6.1  PL/SQL编程基础	122
6.1.1  PL/SQL块结构	122
6.1.2  代码注释和标识符	123
6.2  数据类型的使用	124
6.2.1  基本数据类型	125
6.2.2  特殊数据类型	126
6.3  流程控制语句	129
6.3.1  选择语句	129
6.3.2  循环控制语句	133
6.4  PL/SQL游标编程	135
6.4.1  显式游标	136
6.4.2  游标的常用属性	138
6.4.3  设置隐式游标	139
6.4.4  使用for语句遍历游标	139
6.5  PL/SQL的异常处理	141
6.5.1  预定义异常的使用	141
6.5.2  自定义异常	143
6.6  综合应用	145
6.6.1  判断用户是否可以申请退休	145
6.6.2  使用游标读取员工信息	146
6.7  本章常见错误	147
6.7.1  Oracle数据库中连接字符串的
问题	147
6.7.2  如何查看Oracle的错误信息	147
6.8  本章小结	147
6.9  跟我上机	147
第7章  PL/SQL高级编程	148
（ 视频讲解：1小时38分钟）
7.1  存储过程	149
7.1.1  创建存储过程	149
7.1.2  存储过程的模式参数	150
7.2  函数	156
7.2.1  函数的创建	156
7.2.2  函数的调用	157
7.2.3  函数的删除	158
7.3  触发器	158
7.3.1  触发器概述	158
7.3.2  行级触发器	159
7.3.3  语句级触发器	161
7.3.4  替换触发器	164
7.3.5  用户事件触发器	165
7.4  程序包的使用	167
7.4.1  程序包的规范	167
7.4.2  程序包的主体	168
7.5  综合应用	170
7.5.1  调用存储过程计算平方或平
方根	170
7.5.2  通过程序包调用存储过程和
函数	171
7.6  本章常见错误	171
7.6.1  Oracle存储过程编译错误的
问题	171
7.6.2  "ORA-60512"错误的解决	172
7.7  本章小结	172
7.8  跟我上机	172
第8章  控制文件和日志文件的使用	173
（ 视频讲解：1小时16分钟）
8.1  控制文件的使用	174
8.1.1  控制文件概述	174
8.1.2  控制文件的多路复用	175
8.1.3  创建控制文件	176
8.1.4  备份和恢复控制文件	180
8.1.5  查询控制文件信息	182
8.1.6  控制文件的删除	183
8.2  重做日志文件的使用	183
8.2.1  重做日志文件概述	183
8.2.2  添加日志组及其成员	184
8.2.3  更改重做日志的位置或名称	186
8.2.4  查看重做日志文件信息	187
8.2.5  重做日志文件的删除	188
8.3  归档日志文件的使用	189
8.3.1  归档日志文件概述	189
8.3.2  归档日志文件常用操作	191
8.3.3  设置归档日期文件的位置	192
8.3.4  查看归档日志文件信息	194
8.4  综合应用	195
8.4.1  为数据库实例添加重做日志文
件组	195
8.4.2  查看并修改数据库归档模式	196
8.5  本章常见错误	197
8.5.1  "Oracle not available"错误的
解决	197
8.5.2  无法打开日志组成员的错误	197
8.6  本章小结	198
8.7  跟我上机	198
第9章  Oracle数据核心--表空间	199
（ 视频讲解：58分钟）
9.1  表空间基础	200
9.1.1  查看表空间对应的数据文件	200
9.1.2  Oracle 11g的默认表空间	201
9.2  表空间的创建	202
9.2.1  创建表空间的语法	203
9.2.2  通过本地化管理方式创建表
空间	204
9.2.3  通过段空间管理方式创建表
空间	205
9.2.4  创建非标准块表空间	206
9.2.5  创建大文件表空间	206
9.3  表空间常用操作	208
9.3.1  设置默认表空间	208
9.3.2  更改表空间的状态	208
9.3.3  重命名表空间	209
9.3.4  删除表空间	209
9.3.5  维护表空间中的数据文件	210
9.4  撤销表空间的使用	211
9.4.1  撤销表空间的作用	212
9.4.2  撤销表空间的初始化参数	212
9.4.3  撤销表空间的常用操作	213
9.5  使用临时表空间	217
9.5.1  临时表空间的创建	217
9.5.2  查询临时表空间的信息	218
9.5.3  临时表空间组的使用	218
9.6  综合应用	220
9.6.1  创建并设置默认永久表空间	220
9.6.2  创建并设置默认临时表空间	221
9.7  本章常见错误	221
9.7.1  创建临时表空间的错误	221
9.7.2  设置表空间为只读的错误	222
9.8  本章小结	222
9.9  跟我上机	222
第10章  Oracle数据库常用对象	223
（ 视频讲解：2小时6分钟）
10.1  数据表对象	224
10.1.1  数据表概述	224
10.1.2  数据表的创建	224
10.1.3  数据表的特性	226
10.2  数据表的常用操作	231
10.2.1  增加和删除字段	231
10.2.2  修改字段	232
10.2.3  重命名数据表	233
10.2.4  改变表空间和存储参数	233
10.2.5  修改数据表的状态	234
10.2.6  删除数据表	235
10.3  数据的完整性和约束性	236
10.3.1  非空约束	236
10.3.2  主键约束	238
10.3.3  唯一性约束	239
10.3.4  外键约束	241
10.3.5  禁用约束	243
10.3.6  激活约束	244
10.3.7  删除约束	245
10.4  索引对象	246
10.4.1  索引概述	246
10.4.2  创建索引	247
10.4.3  对索引进行修改	251
10.4.4  索引的删除操作	253
10.4.5  显示索引信息	253
10.5  视图对象	256
10.5.1  视图的创建	256
10.5.2  视图的管理操作	259
10.6  同义词对象	261
10.6.1  同义词对象概述	261
10.6.2  同义词的创建及应用	261
10.7  序列对象	262
10.7.1  序列的创建	263
10.7.2  序列的管理操作	264
10.8  综合应用	265
10.8.1  将创建的数据表置于指定的表
空间中	265
10.8.2  创建数据表并添加索引	266

10.8.3  通过序列对象为数据表添加
数据	266
10.9  本章常见错误	267
10.9.1  主键约束和唯一性约束的混
淆错误	267
10.9.2  start with和minvalue的区别	268
10.9.3  如何利用序列为数据表提供
主键支持	268
10.10  本章小结	268
10.11  跟我上机	268
第2篇  提  高  篇
第11章  分区技术	270
（ 视频讲解：46分钟）
11.1  分区技术概述	271
11.2  常见的几种表分区	271
11.2.1  RANGE范围分区	271
11.2.2  HASH散列分区	273
11.2.3  LIST列表分区	275
11.2.4  组合分区	276
11.2.5  Interval分区	277
11.3  表分区的使用	278
11.3.1  表分区的策略	278
11.3.2  添加表分区	278
11.3.3  合并表分区	279
11.3.4  删除表分区	279
11.3.5  并入表分区	281
11.4  索引分区的使用	282
11.4.1  索引分区概述	282
11.4.2  本地索引分区的使用	282
11.4.3  全局索引分区的使用	284
11.4.4  索引分区的常用操作	285
11.5  综合应用	286
11.5.1  根据指定字段创建多个列表
分区	286
11.5.2  根据表分区创建本地索引
分区	287
11.6  本章常见错误	287
11.6.1  表分区方面的误区	287
11.6.2  大批量数据处理的问题	288
11.6.3  合适的索引分区设计是否有
必要	288
11.7  本章小结	288
11.8  跟我上机	288
第12章  用户、角色与权限控制	289
（ 视频讲解：48分钟）
12.1  创建与管理用户	290
12.1.1  用户与方案	290
12.1.2  身份验证概述	291
12.1.3  创建用户	292
12.1.4  修改用户	294
12.1.5  删除用户	295
12.2  用户权限管理	295
12.2.1  用户权限概述	295
12.2.2  为用户指定权限	296
12.2.3  回收系统权限	297
12.2.4  为用户授予对象权限	298
12.2.5  回收对象权限	298
12.2.6  查询用户及其权限	299
12.3  角色管理	299
12.3.1  角色概述	300
12.3.2  系统预定义角色	300
12.3.3  角色的创建与授权	302
12.3.4  角色的常用操作	303
12.3.5  角色与权限的查询	305
12.4  资源配置PROFILE	306
12.4.1  PROFILE概述	306
12.4.2  使用PROFILE管理密码	306
12.4.3  使用PROFILE管理资源	309
12.4.4  维护PROFILE文件	310
12.4.5  显示PROFILE信息	311
12.5  综合应用	312
12.5.1  创建用户并为其授予连接和
创建表权限	312
12.5.2  创建角色并为其授予连接和
创建表权限	313
12.6  本章常见错误	314
12.6.1  用户与方案的混淆错误	314
12.6.2  区分Oracle的系统权限与对
象权限	314
12.7  本章小结	314
12.8  跟我上机	314
第13章  数据库性能优化	315
（ 视频讲解：52分钟）
13.1  初始化参数的应用	316
13.1.1  初始化参数的分类	316
13.1.2  常用的系统优化参数	316
13.2  系统全局区优化	318
13.2.1  内存分配的调整	318
13.2.2  调整日志缓冲区	318
13.2.3  调整共享池	320
13.2.4  调整数据库缓冲区	323
13.2.5  SGA调优建议	324
13.3  排序区优化	324
13.3.1  排序区与其他内存区的关系	325
13.3.2  专用模式下排序区的调整	325
13.3.3  共享模式下排序区的调整	327
13.4  优化SQL语句	328
13.4.1  不用"*"代替所有列名	328
13.4.2  使用TRUNCATE代替
DELETE	328
13.4.3  在确保完整性的情况下多用
COMMIT语句	329
13.4.4  尽量减少表的查询次数	330
13.4.5  用[NOT] EXISTS代替
[NOT] IN	330
13.5  优化数据表连接	330
13.5.1  驱动表的选择	331
13.5.2  WHERE子句的连接顺序	331
13.6  索引在性能优化中的使用	331
13.6.1  使用索引的基本原则	331
13.6.2  索引列和表达式的选择	332
13.6.3  选择复合索引主列	332
13.6.4  避免全表扫描	333
13.6.5  监视索引是否被使用	333
13.7  优化器的使用	334
13.7.1  优化器概述	334
13.7.2  运行EXPLAIN PLAN	335
13.7.3  Oracle 11g中SQL执行计划的
管理	335
13.8  Oracle的性能顾问	336
13.8.1  SQL调优顾问	336
13.8.2  SQL访问顾问	336
13.9  综合应用	337
13.9.1  修改large_pool_size的值并查看
修改结果	337
13.9.2  查询高速缓存在调用阶段的
不命中数	337
13.9.3  使用TRUNCATE语句清空指定
数据表	337
13.10  本章常见错误	338
13.10.1  如何修改Oracle数据库中SGA
的大小	338
13.10.2  什么情况下不适合创建
索引	338
13.10.3  优化SQL语句的标准是
什么	339
13.11  本章小结	339
13.12  跟我上机	339
第14章  数据的备份与恢复	340
（ 视频讲解：44分钟）
14.1  备份与恢复概述	341
14.2  RMAN备份恢复工具	342
14.2.1  RMAN组件基础	342
14.2.2  分配RMAN通道	344
14.2.3  RMAN的常用命令	346
14.3  使用RMAN工具实现数据
备份	348
14.3.1  RMAN的备份策略	348
14.3.2  备份数据库文件和归档日志	349
14.3.3  增量备份	352
14.4  使用RMAN工具实现数据
恢复	353
14.4.1  数据的完全恢复	353
14.4.2  数据的部分恢复	356
14.5  综合应用	359
14.5.1  使用RMAN工具备份表
空间	359
14.5.2  使用RMAN工具还原备份的
表空间	360
14.6  本章常见错误	361
14.6.1  恢复数据文件的问题	361
14.6.2  何时可以删除归档日志	361
14.6.3  全备份时一定要备份所有数据
文件吗	362
14.6.4  联机日志需要备份吗	362
14.7  本章小结	362
14.8  跟我上机	362
第15章  数据的导出与导入	363
（ 视频讲解：40分钟）
15.1  数据泵技术概述	364
15.2  使用EXPDP导出数据	364
15.2.1  执行EXPDP命令	364
15.2.2  EXPDP命令参数的使用	367
15.3  使用IMPDP导入数据	369
15.3.1  执行IMPDP命令	370
15.3.2  IMPDP命令参数的使用	371
15.4  使用SQL* Loader工具加载外部
数据	372
15.4.1  初识SQL* Loader工具	372
15.4.2  加载多种格式的数据	373
15.5  综合应用	376
15.5.1  导出HR方案中的regions表	376
15.5.2  将regions表导入到SCOTT
方案中	376
15.6  本章常见错误	377
15.6.1  导入数据库时出现同名数据表
的错误	377
15.6.2  导出数据正常，导入数据时却
出现错误	377
15.7  本章小结	378
15.8  跟我上机	378
第16章  闪回技术的应用	379
（ 视频讲解：30分钟）
16.1  闪回技术概述	380
16.2  对数据库进行闪回	380
16.2.1  配置闪回恢复区	381
16.2.2  配置闪回数据库	381
16.2.3  闪回数据库的使用	383
16.3  对数据表进行闪回	383
16.3.1  闪回表命令的语法	383
16.3.2  闪回表的使用	384
16.4  闪回丢弃技术的使用	385
16.4.1  闪回丢弃基础--回收站	385
16.4.2  闪回丢弃技术的应用	386
16.5  其他闪回技术	387
16.5.1  闪回版本查询	387
16.5.2  闪回事务查询	388
16.5.3  闪回数据归档	388
16.6  综合应用	389
16.6.1  使用闪回丢弃还原已经drop
掉的表	389
16.6.2  使用闪回表命令清除记录	390
16.7  本章常见错误	391
16.7.1  "ORA-08189：无法闪回表"
的错误	391
16.7.2  没有启动数据库就执行闪回的
错误	392
16.8  本章小结	392
16.9  跟我上机	392

第3篇  实  战  篇
第17章  Oracle在Java开发中的应用--
企业人事管理系统	394
（ 视频讲解：2小时52分钟）
17.1  需求分析	395
17.2  系统设计	395
17.2.1  系统目标	395
17.2.2  系统功能结构	395
17.2.3  系统业务流程图	395
17.2.4  系统预览	396
17.2.5  系统编码规范	399
17.3  系统开发及运行环境	400
17.4  数据库设计	400
17.4.1  实体E-R图设计	400
17.4.2  数据库逻辑结构设计	401
17.5  系统文件夹组织结构	403
17.6  公共模块设计	403
17.6.1  编写Hibernate配置文件	403
17.6.2  编写Hibernate持久化类和映射
文件	404
17.6.3  编写通过Hibernate操作持久化
对象的常用方法	405
17.6.4  创建用于特殊效果的部门树
对话框	406
17.6.5  创建通过部门树选取员工的
面板和对话框	408
17.7  Hibernate关联关系的建立
方法	409
17.7.1  建立一对一关联	409
17.7.2  建立一对多关联	411
17.8  主窗体设计	412
17.8.1  实现导航栏	413
17.8.2  实现工具栏	415
17.9  人事管理模块设计	417
17.9.1  实现上传员工照片功能	418
17.9.2  实现组件联动功能	420
17.9.3  通过Java反射验证数据是否
为空	422
17.10  待遇管理模块设计	423
17.10.1  实现建立一个新的账套	424
17.10.2  实现为新建的账套添加项目	425
17.10.3  实现修改项目的金额	426
17.10.4  实现统计报表	427
17.11  系统维护模块设计	428
17.11.1  实现修改名称功能	430
17.11.2  实现添加部门的功能	431
17.11.3  实现删除现有部门的功能	432
17.12  开发常见问题与解决	434
17.13  本章小结	434
第18章  Oracle在VC++开发中的应用--
汽配管理系统	435
18.1  需求分析	436
18.2  系统设计	436
18.2.1  系统功能结构	436
18.2.2  系统业务流程图	436
18.2.3  系统预览	437
18.3  数据库设计	439
18.3.1  数据库概要说明	439
18.3.2  数据库逻辑设计	440
18.4  公共模块设计	441
18.4.1  数据库操作类RxADO的
设计	441
18.4.2  特殊按钮类CBaseButton类的
制作	445
18.4.3  扩展的组合框
CBaseComboBox类	448
18.5  主窗体设计	450
18.5.1  主窗体模块概述	450
18.5.2  主窗体实现过程	451
18.6  系统登录模块设计	455
18.6.1  系统登录模块概述	455
18.6.2  系统登录模块逻辑分析	455
18.6.3  系统登录模块实现过程	456
18.7  基础信息查询模块设计	458
18.7.1  基础信息查询模块概述	458
18.7.2  基础信息查询模块实现过程	459
18.8  商品信息模块设计	461
18.8.1  商品信息模块概述	461
18.8.2  商品信息模块数据表分析	461
18.8.3  商品信息模块实现过程	462
18.9  日常业务处理模块设计	467
18.9.1  日常业务处理模块概述	467
18.9.2  日常业务处理模块实现过程	467
18.10  开发常见问题与解决	480
18.10.1  用户界面与RxGrid类的连接与
使用方法	480
18.10.2  打印设置、打印预览与打印
对话框的调用	481
18.11  本章小结	481





>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle自学视频教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle DBA教程
第1章  数据库的安装与卸载  1．1  安装Oracle数据库    1．1．1  系统需求    1．1．2  安装过程    1．1．3  SQL*Plus工具和SCOTT用户  1．2  卸载Oracle数据库  1．3  本章  小结第2章  OFaGIe数据库体系结构第3章  数据库管理工具SQL*Plus第4章  SQL语言概述第5章  创建OracIe数据库第6章  管理和维护表第7章  数据字典第8章  视图第9章  事务第10章  数据查询第11章  索引与约束第12章  数据库的启动与关闭第14章  参数文件第15章  表空间与数据文件管理第16章  重做日志管理第17章  还原数据管理第18章  PUSQL语言基础第19章  存储过程、函数和游标第20章  触发器第21章  序列号和同义词第22章  用户管理和概要文件第23章  角色管理第24章  系统和对象权限管第25章  EXP／IMP及数据泵的备份与恢复第26章  RMAN备份与恢复数据库第27章  优化的概述第28章  SQL语句以及内存优化第29章  I／0以及系统优化
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle DBA教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ORACLE 8i 安装配置与性能调整
第一章
数据库系统的现状和发展趋势 第二章
Oracle体系结构 第三章
安装和配置应用服务器 第四章
Oracle应用服务器的插件 第五章
应用程序Web页面设计 第六章
ODBC概述 第七章
Oracle　ODBC安装和结构分析 第八章
ODBC编程和应用开发 第九章
Java的发展和JDBC的提出 第十章
JDBC驱动程序及其安装 第十一章
JDBC　API接口 第十二

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ORACLE 8i 安装配置与性能调整
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库管理系统教程(SQL PowerBuilder原理与应用)
第一篇 数据库管理系统基础
第1章 数据库的基本概念
1.1 数据处理的基本概念
1.2 数据管理方法的发展
1.3 数据模型
1.4 分布式数据库
1.5 多媒体数据库
第2章 Oracle数据库管理系统
2.1 Oracle系统及其特点
2.2 Oracle的主要产品
2.3 Oracle系统的目录结构
第3章Oracle数据库管理系统的基本概念
3.1 Oracle数据库的逻辑结构
3.2 数据库对象
3.3 数据字典
第二篇 SQL语言
第4章 SQL语言简介
4.1 概述
4.2 SQL语句的分类及格式
4.3 SQL语句的字符、语言符号和标识符
4.4 数据类型
4.5 运算符和表达式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库管理系统教程(SQL PowerBuilder原理与应用)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>OCP Oracle 9i Database Fundamentals I 考试指南
Oracle认证专家
序
前言
第一部分 OCP Database Administration Fundamentals I考试准备
第1章 Oracle数据库体系结构基础
第2章 管理物理数据库结构
第3章 管理表空间和数据文件
第4章 存储结构及撤销数据
第5章 管理数据库对象
第6章 管理数据库用户
第二部分 OCP Oracle9i DBA Fundamentals模拟试题
附录
附录A 全球化支持
附录B BeachFrontQuizzer光盘介绍
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>OCP Oracle 9i Database Fundamentals I 考试指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8 UML对象建模设计
贺辞序译者序福勒序前言

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8 UML对象建模设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle PL/SQL宝典
第1部分 pl/sql简介
第1章 走进oracle
1.1 数据库系统与数据模型
1.1.1 基本术语
1.1.2 数据库技术的发展
1.1.3 数据模型
1.2 数据库系统的体系结构
1.2.1 数据库系统的三级模式
1.2.2 数据库管理系统
1.2.3 数据库系统的工作流程
1.3 关系数据库的简单介绍
1.3.1 关系数据库的基本特性
1.3.2 关系数据库的设计规范
1.4 认识oracle 11g
1.4.1 什么是oracle 11g
1.4.2 oracle的发展历程
1.4.3 oracle 11g的新特性
1.5 小结
第2章 认识pl/sql
2.1 sql语言概述
2.1.1 sql语言的发展
2.1.2 sql语言的功能
2.1.3 sql语言的执行方式
2.1.4 sql语句结构
2.1.5 sql环境
2.1.6 sql dbms的客户/服务器模型
2.2 什么是pl/sql
2.2.1 认识pl/sql
2.2.2 pl/sql结构
2.2.3 pl/sql的主要组成部分
2.2.4 pl/sql基本规范
2.3 pl/sql在sql*plus中的使用
2.3.1 启动sql*plus
2.3.2 sql*plus追加文本命令
2.3.3 sql*plus增加文本命令
2.3.4 sql*plus替换文本命令
2.4 pl/sql在pl/sql developer中的使用
2.4.1 安装pl/sql developer
2.4.2 pl/sql developer的布局
2.5 小结

第2部分 pl/sql基础
第3章 数据表的基本操作
3.1 创建表
3.1.1 创建表的语法
3.1.2 常用的数据类型
3.1.3 创建表实例
3.2 约束
3.2.1 约束的类型
3.2.2 创建一个带检查约束的表
3.2.3 创建一个带非空约束的表
3.2.4 创建一个带唯一约束的表
3.2.5 创建一个带外键约束的表
3.2.6 创建一个含多个约束的表
3.3 修改表
3.3.1 修改表的结构
3.3.2 给表添加约束
3.3.3 删除表中的约束
3.4 删除表
3.5 重命名表
3.6 使用企业管理器操作表
3.6.1 启用企业管理器
3.6.2 使用企业管理器创建表
3.6.3 使用企业管理器修改表
3.6.4 使用企业管理器删除表
3.7 小结
第4章 表中数据的基本操作
4.1 查询数据表
4.1.1 查询表中的数据
4.1.2 使用pl/sql developer工具查询表中的数据
4.2 添加数据
4.2.1 添加操作的基本语法
4.2.2 直接向表中添加数据
4.2.3 数据中null值的处理
4.2.4 插入值是默认值的处理
4.2.5 插入值是唯一值的处理
4.2.6 使用insert...select插入数据
4.2.7 使用pl/sql developer工具添加数据
4.3 修改数据
4.3.1 修改操作的基本语法
4.3.2 使用update语句更新数据行
4.3.3 根据条件修改表中的数据
4.3.4 使用pl/sql developer工具修改数据
4.4 删除数据
4.4.1 删除操作的基本语法
4.4.2 删除表中的数据
4.4.3 有关truncate的使用
4.4.4 使用pl/sql developer工具删除数据
4.5 小结
第5章 数据的基本查询
5.1 查询语句的基础
5.1.1 查询语句语法
5.1.2 查询各关键词的顺序及功能
5.1.3 查询语句执行顺序
5.2 最容易理解的查询
5.2.1 增加实验数据
5.2.2 查询表中列的数据
5.2.3 查询所有列
5.2.4 去除查询结果中的重复记录
5.2.5 返回查询的部分数据
5.3 带条件的查询
5.3.1 单一的条件查询
5.3.2 查询中使用比较表达式
5.3.3 使用简单逻辑表达式
5.3.4 有关null值的判断
5.3.5 有关模糊查询
5.3.6 指定数据范围
5.3.7 如何限制检索数据范围
5.3.8 定义转义符
5.4 排序查询结果
5.4.1 基本排序
5.4.2 多列排序
5.5 pl/sql中的运算符
5.5.1 算术运算符
5.5.2 比较运算符
5.5.3 逻辑运算符
5.5.4 字符串连接符
5.5.5 赋值运算符
5.5.6 运算符的优先级
5.6 查询中表达式的使用
5.6.1 使用连接符连接列
5.6.2 算术表达式的使用
5.7 小结
第6章 查询中函数的使用
6.1 常用的单行函数
6.1.1 字符处理函数
6.1.2 数值处理函数
6.1.3 日期处理函数
6.1.4 转换函数
6.1.5 替换null值函数
6.1.6 排除指定条件函数
6.2 聚合函数
6.2.1 聚合函数的种类
6.2.2 计数函数
6.2.3 求和函数
6.2.4 均值函数
6.2.5 最大值/最小值函数
6.2.6 统计函数
6.2.7 聚合函数的重值处理
6.3 分组查询
6.3.1 简单分组
6.3.2 多列分组
6.3.3 分组查询中null值的处理
6.3.4 汇总数据运算符
6.3.5 筛选分组结果
6.4 其他函数
6.4.1 返回登录名函数
6.4.2 返回sessionid和language函数
6.4.3 数据匹配函数
6.5 小结
第7章 数据表的高级查询
7.1 理解什么是多表连接
7.1.1 什么是连接
7.1.2 连接的类型与实现
7.2 简单的多表查询
7.2.1 创建实例表
7.2.2 如何实现多表查询
7.2.3 指定连接条件
7.2.4 使用别名作为表名的简写
7.2.5 自连接表进行查询
7.3 表的连接查询
7.3.1 基本连接语法
7.3.2 内部连接
7.3.3 自然连接
7.3.4 外部连接
7.3.5 交叉连接
7.3.6 连接中空值问题
7.3.7 表的连接与聚合分析
7.4 集合运算
7.4.1 集合运算的种类
7.4.2 union的使用
7.4.3 有关多表的union操作
7.4.4 union与join的区别
7.4.5 minus与intersect的使用
7.5 子查询的使用
7.5.1 认识子查询
7.5.2 非相关子查询与相关子查询
7.5.3 子查询的组成
7.5.4 子查询的使用方式及限制
7.6 在子查询中使用各种限制条件
7.6.1 比较运算符引入子查询
7.6.2 子查询中的聚合函数
7.6.3 在子查询中使用in
7.7 在子查询中使用exists
7.7.1 使用exists的子查询
7.7.2 exists子查询的使用
7.7.3 使用exists子查询检查表中的重复行
7.8 子查询的其他应用
7.8.1 在子查询中使用rownum关键词
7.8.2 在select子句中使用子查询
7.8.3 在having子句中使用子查询
7.8.4 在数据操纵语言（dml）中使用子查询
7.9 小结

第3部分 pl/sql 高级技术
第8章 索引和视图的使用
8.1 索引及其操作
8.1.1 什么是索引
8.1.2 索引的种类及语法
8.1.3 索引的创建
8.1.4 创建索引的注意事项
8.1.5 索引的管理
8.2 视图及其应用
8.2.1 什么是视图
8.2.2 视图的作用
8.3 创建视图
8.3.1 视图的语法
8.3.2 创建单表视图
8.3.3 创建多表视图
8.3.4 视图的视图
8.3.5 无源表视图
8.3.6 设置视图只读
8.3.7 设置视图的检查约束
8.3.8 内嵌视图的使用
8.3.9 查询视图的定义和相关信息
8.4 修改、删除视图
8.4.1 修改视图内容
8.4.2 删除视图
8.5 小结
第9章 数据类型、流程控制和游标
第10章 存储过程、函数
第11章 触发器
第12章 异常处理
第13章 事务和锁
第14章 安全管理
第15章 pl/sql语句优化

第4部分 oracle项目应用
第16章 利用asp.net实现网上记账系统
第17章 利用java实现订票券系统
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle PL/SQL宝典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>PRO C程序设计和Oracle调用接口
第一篇 PRO＊C程序设计
第一章 PRO＊C程序概述
第二章 PRO＊C程序设计的基础知识
第三章 应用程序的设计方法及举例
第四章 事务处理
第五章 动态SQL技术
第六章 编写SQL＊FORMS的用户出口
第七章 运行PRO＊C预编译程序
第二篇 ORACLE调用接口
第一章 ORACLE调用接口概述
第二章 OCI程序设计的基础知识
第三章 OCI程序的编码方法及所引用的OCI库函数
第四章 OCI程序实例
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>PRO C程序设计和Oracle调用接口
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 12c PL/SQL程序设计终极指南
作者：玄魂工作室-玄魂
链接：https://zhuanlan.zhihu.com/p/23322284
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
前言
基础篇
第1章 PL/SQL概述
1.1 什么是PL/SQL
1.2 PL/SQL优点
1.3 PL/SQL特性
1.4 PL/SQL运行机制
1.4.1 PL/SQL引擎
1.4.2 PL/SQL单元与编译参数
1.5 PL/SQL 12.1新特性
1.6 案例数据库介绍
1.6.1 案例数据库表与序列
1.6.2 创建表与序列
1.6.3 向表中插入数据
1.7 使用Oracle文档
1.8 小结
第2章 PL/SQL开发工具的使用
2.1 SQL Plus
2.1.1 SQL Plus简介
2.1.2 SQL Plus的启动与退出
2.1.3 SQL Plus常用命令
2.2 SQL Developer
2.2.1 SQL Developer简介
2.2.2 创建数据库连接
2.2.3 浏览与管理数据库对象
2.2.4 执行SQL语句
2.2.5 开发PL/SQL程序
2.2.6 执行与调试PL/SQL程序
2.3 PL/SQL Developer
2.3.1 PL/SQL Developer简介
2.3.2 连接数据库
2.3.3 编写与运行PL/SQL程序
2.3.4 测试PL/SQL程序
2.4 小结
第3章 PL/SQL基础
3.1 PL/SQL程序结构
3.1.1 PL/SQL块结构
3.1.2 PL/SQL块分类
3.2 PL/SQL词法单元
3.2.1 字符集
3.3.2 标识符
3.2.3 分隔符
3.2.4 字面值
3.2.5 注释
3.3 PL/SQL数据类型
3.3.1 PL/SQL数据类型概述
3.3.2 字符类型
3.3.3 数字类型
3.3.4 日期/时间类型
3.3.5 布尔类型
3.3.6 复合类型
3.3.7 引用类型
3.3.8 LOB类型
3.3.9 %TYPE属性
3.3.10 %ROWTYPE属性
3.4 PL/SQL变量与常量
3.4.1 常量与变量的声明
3.4.2 变量作用域与可见性
3.5 运算符与表达式
3.5.1 运算符
3.5.2 表达式
3.6 编译指示
3.7 小结
第4章 PL/SQL控制语句
4.1 条件选择语句
4.1.1 IF语句
4.1.2 CASE语句
4.2 循环语句
4.2.1 简单循环语句
4.2.2 WHILE循环语句
4.2.3 FOR循环语句
4.2.4 CONTINUE语句
4.3 顺序控制语句
4.3.1 GOTO语句
4.3.2 NULL语句
4.4 小结
第5章 数据查询
5.1 SQL语言概述
5.1.1 SQL语言介绍
5.1.2 SQL语言的分类
5.1.3 SQL语言的特点
5.2 SELECT语句基本语法
5.3 简单查询
5.3.1 无条件查询
5.3.2 有条件查询
5.4 查询排序
5.5 分组查询
5.5.1 常用的聚集函数
5.5.2 分组查询的语法
5.5.3 单列分组查询
5.5.4 多列分组查询
5.5.5 使用HAVING子句
5.5.6 使用ROLLUP 和CUBE子句
5.5.7 合并分组查询
5.6 连接查询
5.6.1 笛卡尔积连接
5.6.2 内连接
5.6.3 自然连接
5.6.4 使用USING子句的连接
5.6.5 外连接
5.7 子查询
5.7.1 子查询概述
5.7.2 单行单列子查询
5.7.3 多行单列子查询
5.7.4 单行多列子查询
5.7.5 多行多列子查询
5.7.6 相关子查询
5.7.7 在FROM子句中使用子查询
5.7.8 在DDL语句中使用子查询
5.7.9 使用WITH子句的子查询
5.8 层次查询
5.8.1 层次结构的概念
5.8.2 层次查询的语法
5.8.3 层次查询的执行过程
5.8.4 层次查询相关伪列
5.9 集合查询
5.9.1 UNION
5.9.2 UNION ALL
5.9.3 INTERSECT
5.9.4 MINUS
5.10 分析查询
5.10.1 分析查询概述
5.10.2 分析查询的语法
5.10.3 分析函数的应用
5.11 TOP-N与分页查询
5.11.1 Oracle 12c之前的TOP-N与分页查询
5.11.2 Oracle 12c中的TOP-N与分页查询
5.12 小结
第6章 数据操纵与事务控制
6.1 数据插入
6.1.1 数据插入介绍
6.1.2 INSERT语句的语法
6.1.3 插入单行记录
6.1.4 使用子查询插入数据
6.1.5 使用Direct-Path方法插入数据
6.1.6 无条件多表插入
6.1.7 有条件多表插入
6.2 数据修改
6.2.1 UPDATE语句的语法
6.2.2 使用子查询修改数据
6.3 MERGE语句
6.4 数据删除
6.4.1 DELETE语句的语法
6.4.2 使用子查询删除数据
6.4.3 使用TRUNCATE清除数据
6.5 事务控制
6.5.1 事务概述
6.5.2 Oracle事务的隔离级别
6.5.3 使用SET TRANSACTION语句设置事务
6.5.4 事务提交与回滚
6.6 锁
6.6.1 Oracle数据库中锁的分类
6.6.2 Oracle数据库中的DML锁
6.6.3 使用LOCK TABLE语句
6.7 小结
第7章 内置SQL函数
7.1 内置SQL函数概述
7.2 单行函数
7.2.1 数字函数
7.2.2 字符函数
7.2.3 日期函数
7.2.4 转换函数
7.2.5 空值函数
7.2.6 其他单行函数
7.3 聚集函数
7.4 分析函数
7.5 其他函数
7.6 小结
第8章 PL/SQL中的静态SQL语句
8.1 静态SQL语句概述
8.1.1 静态SQL语句类型
8.1.2 PL/SQL中的SELECT语句
8.1.3 PL/SQL中的DML语句
8.1.4 PL/SQL中的字符匹配
8.2 显式游标
8.2.1 游标概述
8.2.2 声明与定义显式游标
8.2.3 打开与关闭显式游标
8.2.4 检索显式游标
8.2.5 显式游标的属性
8.2.6 显式游标定义中的变量
8.2.7 参数化显式游标
8.2.8 FOR UPDATE游标
8.3 隐式游标
8.3.1 隐式游标介绍
8.3.2 隐式游标的属性
8.4 游标变量
8.4.1 游标变量简介
8.4.2 声明游标变量
8.4.3 打开与关闭游标变量
8.4.4 检索游标变量
8.5 游标表达式
8.6 自治事务
8.6.1 自治事务的概念
8.6.2 声明自治程序
8.6.3 自治事务的控制
8.6.4 自治触发器
8.7 小结
第9章 记录
9.1 记录类型概述
9.2 声明记录类型
9.3 记录类型变量
9.3.1 声明记录类型变量
9.3.2 利用%ROWTYPE声明记录类型变量
9.3.3 记录类型变量赋值
9.4 记录类型变量的应用
9.4.1 记录类型变量在SELECT语句中的应用
9.4.2 记录类型变量在INSERT语句中的应用
9.4.3 记录类型变量在UPDATE语句中的应用
9.4.4 DML语句中记录类型变量使用的限制
9.5 小结
第10章 错误处理
10.1 编译警告
10.2 异常处理概述
10.2.1 Oracle错误处理机制
10.2.2 使用异常处理的优点
10.3 异常的类型
10.3.1 预定义异常
10.3.2 内部定义异常
10.3.3 用户定义异常
10.4 抛出异常
10.4.1 用户定义异常的抛出
10.4.2 预定义异常的抛出
10.4.3 内部定义异常的抛出
10.4.4 重新抛出当前异常
10.4.5 RAISE_APPLICATION_ERROR方法的使用
10.5 捕获与处理异常
10.5.1 异常处理器
10.5.2 OTHERS异常处理器
10.6 异常的传播
10.6.1 执行部分异常的传播
10.6.2 声明部分与异常处理部分异常的传播
10.7 异常处理策略
10.7.1 异常处理的基本原则
10.7.2 异常的范围
10.7.3 避免未处理的异常
10.7.4 异常与事务
10.7.5 错误位置标识
10.8 小结
开发篇
第11章 PL/SQL子程序
11.1 PL/SQL子程序概述
11.1.1 PL/SQL子程序的概念与分类
11.1.2 PL/SQL子程序的优点
11.2 独立子程序
11.2.1 子程序结构
11.2.2 创建存储过程
11.2.3 创建函数
11.3 调用子程序
11.3.1 调用存储过程
11.3.2 在PL/SQL程序中调用函数
11.3.3 在SQL语句中调用函数
11.4 子程序参数
11.4.1 形式参数与实际参数
11.4.2 参数的传递方式
11.4.3 参数模式
11.4.4 NOCOPY关键字
11.4.5 参数的约束
11.4.6 IN模式参数默认值
11.4.7 无参子程序
11.4.8 实参与形参的对应关系
11.5 嵌套子程序
11.5.1 嵌套子程序的概念
11.5.2 嵌套子程序的创建
11.5.3 嵌套子程序的向前声明
11.5.4 嵌套子程序的重载
11.6 独立子程序的管理
11.7 小结
第12章 PL/SQL包
12.1 包概述
12.1.1 包的概念
12.1.2 包的分类
12.1.3 使用包的优点
12.2 创建包
12.2.1 包规范
12.2.2 包体
12.3 调用包
12.4 重载包
12.5 实例化与初始化包
12.6 包的纯度等级
12.7 包的状态
12.7.1 变量持续性
12.7.2 游标持续性
12.7.3 SERIALLY_REUSABLE包
12.8 包编写指南
12.9 STANDARD包
12.10 包管理
12.11 小结
第13章 子程序依赖性与权限管理
13.1 对象依赖性概述
13.1.1 对象依赖性的概念
13.1.2 对象依赖关系查询
13.2 子程序的本地依赖性
13.2.1 子程序的依赖关系
13.2.2 包的依赖性关系
13.3 子程序的远程依赖性
13.3.1 远程依赖关系的建立
13.3.2 远程依赖失效的识别
13.4 子程序权限概述
13.4.1 子程序调用需要的权限
13.4.2 子程序定义者需要的权限
13.5 调用者权限与定义者权限
13.6 小结
第14章 触发器
14.1 触发器简介
14.1.1 触发器的概念
14.1.2 触发器的作用
14.1.3 触发器的种类
14.1.4 触发器的结构
14.2 简单的DML触发器
14.2.1 简单DML触发器概述
14.2.2 语句级简单DML触发器
14.2.3 行级简单DML触发器
14.2.4 简单DML触发器的执行顺序
14.3 INSTEAD OF DML触发器
14.3.1 INSTEAD OF DML触发器概述
14.3.2 创建INSTEAD OF DML触发器
14.3.3 基于视图嵌套表列的INST-EAD OF DML触发器
14.4 复合DML触发器
14.4.1 复合DML触发器概述
14.4.2 创建复合DML触发器
14.4.3 复合DML触发器应用
14.5 利用DML触发器保证引用完整性
14.6 系统触发器
14.6.1 系统触发器的响应事件
14.6.2 创建系统触发器
14.6.3 事件属性函数
14.7 变异表触发器
14.7.1 变异表触发器的限制
14.7.2 变异表触发器应用
14.8 触发器设计指南
14.9 触发器管理
14.9.1 触发器定义的限制
14.9.2 触发器的禁用与激活
14.9.3 触发器的修改、重编译与删除
14.9.4 触发器的信息查询
14.10 小结
第15章 集合
15.1 集合概述
15.2 联合数组
15.2.1 联合数组概述
15.2.2 定义联合数组
15.2.3 操作联合数组
15.3 嵌套表
15.3.1 嵌套表概述
15.3.2 定义嵌套表
15.3.3 初始化嵌套表
15.3.4 操作嵌套表
15.4 可变数组
15.4.1 可变数组概述
15.4.2 可变数组的定义与初始化
15.4.3 操作可变数组
15.5 集合方法
15.6 集合类型变量的比较
15.6.1 集合类型变量与NULL的比较
15.6.2 嵌套表变量比较
15.6.3 嵌套表变量多集合条件比较
15.7 独立集合类型
15.7.1 嵌套表在数据库中的应用
15.7.2 可变数组在数据库中的应用
15.8 在包中定义的集合类型
15.9 多维集合
15.10 小结
第16章 动态SQL语句
16.1 动态SQL语句概述
16.1.1 动态SQL语句的概念
16.1.2 动态SQL语句与静态SQL语句的比较
16.2 本地动态SQL
16.2.1 EXECUTE IMMEDIATE语句
16.2.2 动态DDL操作
16.2.3 动态DCL操作
16.2.4 动态DML操作
16.2.5 动态单行查询操作
16.2.6 动态多行查询操作
16.2.7 在动态SQL语句中调用子程序
16.2.8 动态SQL语句中的重名占位符
16.3 DBMS_SQL包
16.3.1 DBMS_SQL包概述
16.3.2 DBMS_SQL包中方法介绍
16.3.3 DBMS_SQL操作流程
16.3.4 使用DBMS_SQL包执行动态DDL语句
16.3.5 使用DBMS_SQL包进行动态DML语句
16.3.6 使用DBMS_SQL包执行动态查询语句
16.3.7 使用DBMS_SQL包执行匿名块
16.3.8 其他常用DBMS_SQL方法应用
16.4 小结
第17章 批绑定
17.1 批绑定概述
17.2 FORALL语句
17.2.1 FORALL语句的语法
17.2.2 FORALL语句与FOR LOOP语句比较
17.2.3 批量DML操作
17.2.4 使用稀疏集合的FORALL语句
17.2.5 FORALL语句的异常处理
17.2.6 获取FORALL语句影响的记录数量
17.3 BULK COLLECT短语
17.3.1 SELECT BULK COLLECT语句
17.3.2 FETCH BULK COLLECT语句
17.3.3 RETURNING BULK COLLECT短语
17.4 动态批绑定
17.4.1 动态批量DML操作
17.4.2 动态批查询操作
17.5 小结
高级篇
第18章 对象
18.1 Oracle对象概述
18.1.1 Oracle对象简介
18.1.2 使用Oracle对象的优势
18.1.3 Oracle数据库的对象特性
18.2 对象类型定义
18.2.1 对象类型规范
18.2.2 对象类型体
18.3 对象类型方法
18.3.1 MEMBER方法
18.3.2 STATIC方法
18.3.3 MAP与ORDER方法
18.3.4 构造方法
18.4 对象类型的继承
18.4.1 对象类型继承概述
18.4.2 FINAL与NOT FINAL对象类型与方法
18.4.3 创建子对象类型
18.4.4 方法重定义与重载
18.4.5 NOT INSTANTIABLE对象类型与方法
18.5 操作数据库中对象
18.5.1 创建对象表
18.5.2 操作对象表
18.5.3 操作列对象
18.5.4 对象引用
18.6 对象视图
18.6.1 对象视图概述
18.6.2 创建对象视图
18.6.3 在对象视图中嵌套对象
18.6.4 操作对象视图
18.7 在PL/SQL中使用对象类型
18.7.1 对象的声明与初始化
18.7.2 操作PL/SQL中的对象
18.8 与对象相关的函数和操作符
18.9 对象类型的管理
18.9.1 修改对象类型
18.9.2 删除对象类型
18.10 小结
第19章 大对象
19.1 大对象概述
19.1.1 为什么使用大对象
19.1.2 LOB与LONG的比较
19.1.3 LOB分类
19.1.4 LOB存储结构与定位器
19.1.5 LOB操作技术与接口
19.2 利用SQL操纵LOB对象
19.2.1 创建包含LOB列的数据库表
19.2.2 利用SQL操作内部LOB
19.2.3 利用SQL操作外部LOB
19.3 DBMS_LOB包
19.3.1 DBMS_LOB包简介
19.3.2 DBMS_LOB包中子程序介绍
19.4 利用PL/SQL操纵LOB对象
19.4.1 利用DBMS_LOB包操作CLOB对象
19.4.2 利用DBMS_LOB包操作BLOB对象
19.4.3 利用DBMS_LOB包操作BFILE对象
19.5 小结
第20章 Oracle任务调度
20.1 Oracle调度器概述
20.1.1 Oracle调度器的概念
20.1.2 调度对象
20.2 作业对象管理
20.2.1 创建作业对象
20.2.2 修改作业对象
20.2.3 运行作业对象
20.2.4 停止作业对象
20.2.5 删除作业对象
20.2.6 禁用作业对象
20.2.7 激活作业对象
20.3 程序对象管理
20.4 调度对象管理
20.5 小结
第21章 PL/SQL性能优化
21.1 PL/SQL性能优化简介
21.2 子程序内联
21.3 SQL语句优化
21.3.1 SQL语句优化概述
21.3.2 SQL语句执行过程
21.3.3 将常用程序驻留内存
21.3.4 有效使用索引
21.3.5 采用适当的多表连接技术
21.3.6 SQL语句使用技巧
21.4 最小化CPU载荷
21.4.1 优化查询中的函数调用
21.4.2 优化子程序调用
21.4.3 优化循环
21.4.4 优化用于计算的PL/SQL代码
21.4.5 使用SQL字符函数
21.4.6 批SQL与批绑定
21.5 管道函数的使用
21.5.1 表函数概述
21.5.2 创建管道表函数
21.5.3 管道表函数作为转换函数
21.5.4 检索管道表函数的返回结果集
21.5.5 向管道表函数传递游标表达式
21.6 性能优化工具
21.6.1 使用Profiler API工具
21.6.2 使用Trace API工具
21.6.3 使用PL/SQL hierarchical profiler工具
21.7 小结
第22章 常用的Oracle内置包
22.1 Oracle内置包简介
22.2 DBMS_ALERT包
22.3 DBMS_DDL包
22.4 DBMS_FLASHBACK包
22.5 DBMS_METADATA包
22.5.1 DBMS_METADATA包简介
22.5.2 DBMS_METADATA包中子程序
22.6 DBMS_LOGMNR包
22.7 DBMS_LOGMNR_D包
22.8 DBMS_PIPE包
22.8.1 Oracle管道通信概述
22.8.2 DBMS_PIPE包中子程序
22.9 DBMS_RANDOM包
22.10 DBMS_ROWID包
22.11 DBMS_TRANSACTION包
22.12 UTL_FILE包
22.13 UTL_TCP包
22.14 小结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 12c PL/SQL程序设计终极指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle NoSQL数据库：实时大数据管理
第1章  Oracle NoSQL数据库和大数据概况	1
1.1  NoSQL系统概论	2
1.2  数据库系统发展回顾	3
1.3  大数据和NoSQL：特点和架构权衡	5
1.4  大数据处理的类型	7
1.5  NoSQL数据库和关系数据库	7
1.6  NoSQL数据库的类型	9
1.6.1  键值存储	9
1.6.2  文档存储	10
1.6.3  图形存储	10
1.6.4  列式存储	10
1.7  大数据的用例	11
1.8  Oracle的大数据解决方案	13
1.8.1  数据获取	14
1.8.2  数据组织	15
1.8.3  数据分析	17
1.8.4  Oracle的大数据工程系统	19
1.9  小结	23
第2章  Oracle NoSQL数据库简介	25
2.1  Oracle Berkeley DB	26
2.2  Oracle NoSQL数据库	29
2.3  数据库系统架构	31
2.3.1  分区和分片	33
2.3.2  可用性	35
2.3.3  最终一致性	37
2.3.4  持久性	39
2.3.5  事务	41
2.3.6  数据模型	42
2.3.7  性能	44
2.3.8  管理	45
2.3.9  与其他产品集成	45
2.3.10  授权	46
2.4  小结	47
第3章  Oracle NoSQL数据库体系结构	49
3.1  高层体系结构以及术语	50
3.2  智能客户端驱动程序	51
3.3  分片、存储和网络拓扑	54
3.4  哈希、分区和数据分布	57
3.4.1  改变分片数量	59
3.4.2  改变复制因子	63
3.5  考虑多个数据中心	64
3.6  存储记录和灵活的数据模型	67
3.7  日志结构存储	72
3.8  持久性	74
3.9  ACID事务和分布式事务	77
3.10  小结	79
第4章  Oracle NoSQL数据库的安装和配置	81
4.1  Oracle NoSQL数据库的安装	82
4.1.1  下载Oracle NoSQL数据库软件	84
4.1.2  软件安装	84
4.1.3  Oracle NoSQL数据库管理服务	86
4.1.4  创建启动配置文件	89
4.1.5  进行合理性检查	93
4.2  Oracle NoSQL数据库的配置	94
4.2.1  计划	94
4.2.2  配置步骤	96
4.2.3  配置过程的自动化	102
4.2.4  部署的验证	103
4.3  小结	107
第5章  NoSQL数据库开发入门	109
5.1  基于KVLite开发	110
5.2  如何建立键空间模型	116
5.3  读写单一键值对的基础知识	119
5.4  从编程人员角度理解一致性和持久性	121
5.4.1  持久性	121
5.4.2  一致性	123
5.5  小结	126
第6章  读写数据	127
6.1  开发环境设置	128
6.2  写入数据	129
6.2.1  基本API功能	130
6.2.2  如何指定写API调用的持久性	134
6.3  读取记录	141
6.3.1  采用多种方式读取一条或多条记录	141
6.3.2  介绍保持读一致性的API	151
6.3.3  处理读操作的异常	159
6.4  删除记录	160
6.5  根据版本更新记录	163
6.6  小结	166
第7章  高级编程概念：Avro schema和绑定	167
7.1  Avro schema	168
7.1.1  schema演变	172
7.1.2  管理Avro schema	175
7.2  Avro绑定	179
7.2.1  特定绑定	180
7.2.2  通用绑定	189
7.2.3  JSON绑定	196
7.3  小结	199
第8章  数据库容量规划与大小调整	201
8.1  收集容量大小需求	202
8.1.1  应用程序的特性	203
8.1.2  硬件规格	208
8.2  容量规划和大小调整	209
8.2.1  测算一个典型分片的容量	210
8.2.2  决定分片和数据分区的总数	219
8.3  小结	221
第9章  高级主题	223
9.1  集成Hadoop	224
9.2  RDF Graph	228
9.3  集成Complex Event Processing	230
9.4  数据库外部表	231
9.4.1  定义外部表	233
9.4.2  编辑配置文件	235
9.4.3  发布配置	235
9.4.4  测试nosql-stream脚本	235
9.4.5  使用外部表读取Oracle NoSQL数据库中的数据	236
9.5  小结	237
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle NoSQL数据库：实时大数据管理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库管理与应用实例教程
第1章  案例数据库设计第2章  初识Oracle 11g第3章  数据库操作第4章  数据表操作第5章  查询操作第6章  视图和索引操作第7章  存储过程操作第8章  游标、事务和锁第9章  触发器操作第10章  数据库安全操作第11章  数据库管理操作第12章  数据库应用程序开发附录  综合实训参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库管理与应用实例教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle移动网络应用程序设计——基于Oracle Application Express
第1章  APEX移动Web开发简介	1
1.1  设计移动应用程序	2
1.2  基于Web的应用程序与本地移动应用程序的对比	6
1.3  响应式设计	7
1.4  响应式设计的选择，桌面环境或移动环境	8
1.5  总结	10
第2章  创建移动Web页面	11
2.1  如何构建jQuery Mobile页面	11
2.2  首个移动APEX应用程序	13
2.3  对话框	19
2.4  页面过渡	23
2.5  弹出窗口	25
2.6  加载微件	25
2.7  模板	26
2.8  混合的应用程序	27
2.9  总结	27
第3章  通过列表视图呈现数据	29
3.1  创建基本列表	29
3.2  设计列表的风格	30
3.2.1  Inset List	30
3.2.2  Enable Search	31
3.2.3  Show List Divider	33
3.2.4  Counter Column	34
3.2.5  Show Image	35
3.2.6  Link Target	37
3.2.7  Has Split Button	37
3.2.8  Is Nested List View	38
3.2.9  Advanced Formatting	38
3.2.10  Number of Fetched Rows	40
3.3  添加滑动删除功能	41
3.4  添加自动推送下一组记录的功能	46
3.5  列表视图功能实战	46
3.6  实现自定义排序	49
3.7  总结	52
第4章  通过表单接收数据	53
4.1  Login页面回顾	53
4.2  网格布局	58
4.2.1  使用网格布局	58
4.2.2  在APEX中使用网格布局	61
4.3  可折叠内容	63
4.3.1  使用可折叠内容	64
4.3.2  在APEX中使用可折叠内容	64
4.4  HTML5输入元素	65
4.5  其他移动输入元素	68
4.5.1  滑块	68
4.5.2  选择列表	69
4.5.3  单选按钮组	70
4.5.4  切换开关	71
4.6  添加滑动导航功能	73
4.7  修改删除确认对话框	75
4.8  修改处理成功消息提示	78
4.9  完成表单	80
4.10  总结	83
第5章  显示日历和图表	84
5.1  日历	84
5.2  图表	92
5.3  其他的选择	94
5.3.1  Google Maps	94
5.3.2  Highcharts	96
5.3.3  Flotcharts	96
5.4  总结	100
第6章  实现导航标准	101
6.1  尽可能地融入到系统中	101
6.2  创建自定义Springboard	103
6.2.1  设置Springboard	104
6.2.2  增强Springboard	106
6.3  创建Tab风格的导航	109
6.4  移除HTML风格的按钮	113
6.5  创建滑动菜单	116
6.6  总结	120
第7章  为移动应用程序定制主题	121
7.1  ThemeRoller的使用	121
7.1.1  ThemeRoller入门	121
7.1.2  修改默认主题	123
7.2  创建自定义主题	124
7.2.1  对全局色板进行修改	124
7.2.2  新建色板	126
7.2.3  为应用程序添加自定义主题	126
7.2.4  由最终用户来改变色板	129
7.3  创建自定义图标	131
7.4  总结	134
第8章  使用Dynamic Actions	135
8.1  客户端交互	135
8.2  Dynamic Actions简介	136
8.2.1  Dynamic Actions组件	136
8.2.2  创建测试页面	137
8.2.3  深入研究Dynamic Action	138
8.2.4  创建Dynamic Action	139
8.2.5  声明一个服务器调用的例子	142
8.3  转换为APEX 4.2中的Dynamic Actions	145
8.3.1  不再出现的Standard与Advanced选项	145
8.3.2  新增的声明事件	146
8.4  移动设备特定事件的实例	148
8.4.1  Orientation Change事件	148
8.4.2  Swipe Left以及Swipe Right事件	149
8.5  高级Dynamic Actions	150
8.5.1  自定义JavaScript	150
8.5.2  非标准Selection Types	151
8.5.3  Event Scope	152
8.5.4  自定义事件	153
8.5.5  Virtual Click事件	154
8.5.6  Dynamic Action事件的完整列表清单	156
8.6  总结	158
第9章  部署应用程序	159
9.1  原生App、Web App与混合App之间的取舍	159
9.1.1  Web App	159
9.1.2  原生App	160
9.1.3  混合App	161
9.2  PhoneGap架构	162
9.2.1  应用程序的用户界面	162
9.2.2  PhoneGap API	163
9.2.3  PhoneGap API功能概览	163
9.2.4  PhoneGap 应用程序打包与发布	164
9.3  为Cordova配置Android开发环境	164
9.3.1  设置Eclipse	164
9.3.2  设置Android工具	165
9.4  创建PhoneGap App项目	167
9.4.1  创建新的Eclipse项目	167
9.4.2  向Android项目中添加PhoneGap	171
9.4.3  配置Android App	174
9.4.4  在模拟器中部署App	176
9.4.5  部署App至移动设备	177
9.5  APEX与PhoneGap	178
9.6  白名单	179
9.6.1  语法	179
9.6.2  配置	179
9.7  在APEX页面中使用PhoneGap API	180
9.7.1  交叉平台页面模板	180
9.7.2  操控摄像头设备的例子	183
9.7.3  使用iFrame访问PhoneGap API	189
9.8  使用Adobe PhoneGap Build	194
9.8.1  为PhoneGap Build准备应用程序	195
9.8.2  使用config.xml进行配置	196
9.8.3  编译App	196
9.9  总结	197
第10章  移动应用程序的安全性	198
10.1  考虑安全性的影响	198
10.2  应用常规安全设置	199
10.2.1  配置SSL	199
10.2.2  超时设置	199
10.2.3  对数据进行加密	202
10.3  使用APEX安全特性	203
10.4  拆分应用程序	204
10.5  总结	206
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle移动网络应用程序设计——基于Oracle Application Express
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Mobile Application Frameword开发指南——构建多平台企业移动应用
目    录
第Ⅰ部分 了解Oracle Mobile Application Framework
第1章  移动应用开发导论	3
1.1  回顾一段短暂的历史	3
1.2  移动设计原则	5
1.3  移动平台	7
1.3.1  iOS	8
1.3.2  Android	8
1.3.3  Windows	8
1.4  你需要了解的技术有哪些	8
1.5  HTML5	9
1.5.1  CSS3	9
1.5.2  JSON	9
1.5.3  Apache Cordova与PhoneGap	9
1.6  移动开发面临的挑战	10
1.7  Oracle Mobile Application Framework简介	11
1.8  Mobile Application Framework Runtime Architecture	11
1.9  使用Oracle Mobile Application Framework进行开发	13
1.9.1  设计Oracle Mobile Application Framework应用	13
1.9.2  开发Oracle Mobile Application Framework 应用	13
1.9.3  部署Oracle Mobile Application Framework应用	14
1.9.4  应用开发过程中的其他任务	14
1.9.5  将Oracle Mobile Application Framework 应用部署到生产环境	14
1.10  小结	15
第2章  安装Oracle JDeveloper和开发平台	17
2.1  Android开发的准备工作	18
2.1.1  下载和安装Android API	18
2.1.2  Android模拟器	20
2.1.3  Android模拟器 Intel HAXM软件	21
2.2  iOS开发的准备工作	23
2.2.1  iOS开发者程序和
Apple ID	24
2.2.2  应用发布	24
2.2.3  下载Xcode	25
2.2.4  启动iOS模拟器	26
2.2.5  使用iOS模拟器的多个版本	27
2.3  设置Oracle JDeveloper	28
2.3.1  为Android开发设置
Oracle JDeveloper	28
2.3.2  设置为iOS开发的Oracle JDeveloper	29
2.4  小结	30
第3章  Oracle JDeveloper——用于Oracle Mobile Application Framework开发	31
3.1  Oracle JDeveloper概述	32
3.2  探讨并定制Oracle JDeveloper IDE	33
3.2.1  Oracle JDeveloper中的窗口	34
3.2.2  代码编辑器	36
3.3  创建一个Oracle Mobile Application Framework应用	38
3.4  Oracle JDeveloper中的版本控制	41
3.5  小结	42
第4章  创建AMX页面	43
4.1  基于组件的开发简介	44
4.1.1  Oracle Mobile Application Framework中可用的组件	44
4.1.2  更改组件属性	46
4.2  布局组件	48
4.2.1  列表视图	49
4.2.2  创建自己的列表视图布局	52
4.2.3  panelSplitter组件	56
4.3  使用手势	57
4.3.1  如何使用手势	58
4.3.2  在列表中对列表项重新排序	59
4.4  Oracle Mobile Application Framework应用的皮肤	59
4.5  Oracle Mobile Application Framework的数据可视化
工具	61
4.5.1  创建条形图	61
4.5.2  使用Gauge组件	64
4.5.3  使用Map组件	64
4.6  Oracle Mobile Application Framework说明的任务流	67
4.6.1  导航	68
4.6.2  全球导航	70
4.7  小结	71
第5章  绑定和数据控件	73
5.1  创建一个简单的数据绑定的Mobile Application
Framework AMX页面	75
5.2  Model层中文件的职能	77
5.2.1  adfm.xml	77
5.2.2  DataControls.dcx	78
5.2.3  DataBindings.cpx	78
5.3  PageDefinition文件	79
5.3.1  可使用的绑定类型	81
5.3.2  可获得的执行文件是什么	81
5.4  数据控件	81
5.4.1  创建Bean数据控件	82
5.4.2  数据控件概览编辑器	84
5.5  不同部分之间如何联系	84
5.6  实现验证	87
5.7  Oracle Mobile Application Framework使用的其他数据控件	91
5.8  用编程的方法处理绑定	91
5.8.1  Getting和Setting绑定属性值	92
5.8.2  调用方法	92
5.9  小结	92
第6章  应用特性	93
6.1  Oracle Mobile Application Framework特性以及应用配置文件	94
6.1.1  应用配置文件	94
6.1.2  特性配置文件	95
6.2  定义应用特性	95
6.3  定义Oracle Mobile Application Framework特性的内容	96
6.3.1  Oracle Mobile Application Framework特性的内容	97
6.3.2  远程URL和本地HTML	98
6.4  如何控制应用特性的显示	98
6.5  使用springboards和导航栏	99
6.6  springboard导航	101
6.7  小结	107
第7章  使用Web服务和本地数据库	109
7.1  使用Web服务	109
7.1.1  SOAP-XML与REST-JSON	110
7.1.2  SOAP-XML服务	111
7.1.3  REST-XML服务	112
7.1.4  REST JSON服务	114
7.2  使用本地数据库	116
7.2.1  为什么使用SQLite数据库	117
7.2.2  如何使用SQLite数据库	118
7.2.3  连接到SQLite数据库	118
7.2.4  加密SQLite数据库	119
7.2.5  SQLite的局限	119
7.2.6  SQLite创建数据库对象	121
7.2.7  通过SQLite进行数据选择和操作	123
7.3  属性更改事件的概念	124
7.4  小结	128
第8章  设备交互	129
8.1  设备交互的概念	130
8.1.1  使用DeviceFeatures数据控件	130
8.1.2  使用Java API	133
8.1.3  使用JavaScript API	134
8.1.4  DeviceScope对象	134
8.2  实现设备交互	135
8.2.1  与联系人列表进行交互	136
8.2.2  与摄像头进行交互	137
8.2.3  发送短信	139
8.2.4  发送E-mail	139
8.2.5  集成GPS	140
8.2.6  文件显示	141
8.3  实现常用的用例	143
8.3.1  用例1：用于设备交互：带有照片附件的E-mail	143
8.3.2  用例2：跟踪你的日常锻炼	145
8.3.3  用例3：用于设备交互——创建一个自定义
通讯录应用	148
8.4  小结	152
第9章  调试并测试Oracle Mobile Application Framework应用	153
9.1 移动应用的测试策略	154
9.2  测试Oracle Mobile Application Framework应用	155
9.3  调试Oracle Mobile Application Framework应用	155
9.3.1  配置调试模式	155
9.3.2  启动调试会话	157
9.3.3  使用断点调试Java代码	158
9.3.4  Oracle JDeveloper调试器	159
9.3.5  调试JavaScript	160
9.3.6  日志	163
9.4  小结	167
第10章  安全性和部署	169
10.1  Oracle Mobile Application Framework安全性的概念	170
10.1.1  实现登录	170
10.1.2  理解认证流程	171
10.2  部署Oracle Mobile Application Framework应用	183
10.2.1  部署配置文件	183
10.2.2  不同平台上的部署	183
10.3  小结	189
第Ⅱ部分  开发样例应用
第11章  TAMCAPP样例应用	193
11.1  数据模型	194
11.1.1  企业数据模型	195
11.1.2  设备上的数据模型	195
11.2  Web服务	196
11.3  TAMCAPP应用设计和流	196
11.4  注册和登录	197
11.5  Springboard	198
11.6  与会者	198
11.7  社交媒体	199
11.8  地图	199
11.9  会议	200
11.9.1  我的日程表	202
11.9.2  发言人	202
11.9.3  组织	202
11.10  平板布局	204
11.11  小结	204
第12章  开发Springboard	205
12.1  创建应用	205
12.2  定义TAMCAPP应用的特性	206
12.2.1  使用特性存档	208
12.2.2  本地HTML：社交媒体特性	209
12.2.3  远程URL：组织远程特性	209
12.3  使用图片	210
12.4  创建TAMCAPP自定义的Springboard	211
12.5  小结	217
第13章  创建Conference Session特性	219
13.1  实现Browse Conference Sessions	220
13.1.1  连接数据	220
13.1.2  创建Conference-Session Bean	221
13.1.3  创建Conference Session POJO	223
13.1.4  创建Bean Data Control	223
13.1.5  创建Conference Session列表AMX页面	224
13.1.6  实现查找会议	226
13.2  阻止不必要的Web
服务调用	227
13.3  会议会话的详细
信息页面	228
13.4  查看会议会话文件	229
13.5  创建视觉跟踪指示器	230
13.6  评价会议会话	231
13.7  查看对会议会话的评价	232
13.8  日程表生成器	233
13.8.1  设置本地SQLite数据库	234
13.8.2  添加一个会议会话到mySchedule	235
13.8.3  同步日程表数据	239
13.8.4  读写本地数据库	239
13.9  小结	244
第14章  创建与会者特性	245
14.1  实现Attendees List AMX页面	246
14.1.1  实现导航到Attendee Details AMX页面	246
14.1.2  智能导航	248
14.2  实现Attendee Details AMX页面	249
14.3  编辑个人信息	254
14.3.1  保存修改	254
14.3.2  与会者图片	255
14.4  小结	257
第15章  开发地图和社交网络	259
15.1  实现地图特性	259
15.1.1  会场地图	260
15.1.2  景点地图	266
15.2  嵌入Twitter时间轴	274
15.2.1  研究Twitter小部件	274
15.2.2  在示例应用中使用Twitter小部件	275
15.2.3  将Twitter域加入白名单	276
15.3  小结	277
第16章  配置安全性和首选项	279
16.1  初始注册进程	280
16.2  实现TAMCAPP的安全性	282
16.2.1  TAMCAPP登录	283
16.2.2  应用首选项	289
16.2.3  实现TAMCAPP首选项	290
16.2.4  在Java代码中使用首选项	291
16.3  小结	292
第17章  实现推送通知	295
17.1  理解推送通知的架构	296
17.2  设置云服务	297
17.3  设置Apple Push Notification Service	298
17.4  创建一个推送通知提供者应用	303
17.4.1  配置Provider
Application	303
17.4.2  推送到Android	304
17.4.3  推送到iOS	305
17.5  实现TAMCAPP中的推送支持	306
17.5.1  在提供者应用中注册	308
17.5.2  配置通知的显示方式	308
17.6  响应推送通知	309
17.6.1  onMessage()方法	310
17.6.2  特性的生命周期监听器	311
17.6.3  使用推送通知有效载荷	313
17.7  小结	314
第18章  优化TAMCAPP	315
18.1  实现平板电脑布局	316
18.2  使用条形码扫描器来
注册会议会话的与会者	322
18.3  使用Cordova插件	328
18.3.1  准备TAMCAPP应用程序	328
18.3.2  添加Android条形码插件	329
18.3.3  添加iOS条形码插件	330
18.3.4  在Oracle Mobile Application Framework应用中使用插件	331
18.4  向TAMCAPP添加一个自定义搜索组件	334
18.4.1  创建自定义搜索组件的步骤	334
18.4.2  准备特性以使用组件	336
18.5  实现一个后台进程	337
18.6  小结	339

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Mobile Application Frameword开发指南——构建多平台企业移动应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle PL SQL性能调优诀窍与方法
目    录

第Ⅰ部分  PL/SQL性能调优的核心理念和要素
第1章  PL/SQL在当前开发中的角色	3
1.1  典型的Web应用程序处理流程	3
1.2  Web应用程序的性能问题区域	4
1.2.1  步骤1：客户机的性能问题	4
1.2.2  步骤2：客户机到应用服务器的传输问题	5
1.2.3  步骤3：应用服务器的性能问题	5
1.2.4  步骤4：应用服务器到数据库的传输问题	5
1.2.5  步骤5：数据库的性能问题	5
1.2.6  步骤6：数据库到应用服务器的传输问题	6
1.2.7  步骤7：应用服务器处理性能问题	6
1.2.8  步骤8：应用服务器到客户机的传输问题	6
1.2.9  步骤9：客户机的性能问题	6
1.3  发现使得Web应用程序性能变慢的原因	6
1.3.1  使用计时器来收集有关性能的数据	7
1.3.2  性能测量	8
1.4  解决Web应用程序的性能问题	9
1.4.1  解决客户机的性能问题(步骤1和9)	9
1.4.2  分清客户机和应用服务器之间的性能问题(步骤2)	9
1.4.3  解决应用服务器中的性能问题(步骤3和7)	10
1.4.4  解决客户机中的性能问题(步骤9)	10
1.4.5  心得	10
1.5  总结	10
第2章  DBA/开发者的界线：工具和特性	13
2.1  数据字典视图	14
2.2  Oracle日志记录和跟踪	16
2.2.1  日志记录的基础知识	16
2.2.2  跟踪的基础知识	17
2.2.3  日志记录/跟踪示例	18
2.3  PL/SQL层次式分析器	20
2.4  RUNSTATS	23
2.5  PL/SQL环境设置	24
2.5.1  PLSQL_OPTIMIZE_LEVEL	25
2.5.2  PLSQL_CODE_TYPE	27
2.5.3  PLSQL_WARNINGS	29
2.5.4  PLSQL_CCFLAGS	31
2.6  PL/Scope	31
2.7  总结	33
第3章  PL/SQL中的代码插桩	35
3.1  问题真的出在数据库中吗	36
3.2  应用程序日志	37
3.2.1  内置代码导航API	37
3.2.2  用户驱动的日志	39
3.3  代码插桩的最佳实践	43
3.3.1  设置过程标记	44
3.3.2  设置错误标记	46
3.4  总结	47
第Ⅱ部分  链接SQL和PL/SQL
第4章  扩展SQL的范围	51
4.1  跳出SQL模式	52
4.1.1  切换至PL/SQL，使生活变得更简单	52
4.1.2  使用PL /SQL填补功能空白	55
4.2  调用SQL内置函数	59
4.2.1  单表问题	60
4.2.2  多表问题	63
4.3  和PL/SQL相关的统计及其对执行计划的影响	64
4.3.1  PL /SQL函数的硬件成本	64
4.3.2  PL/SQL函数的基数	70
4.3.3  PL/SQL函数的选择率	74
4.4  只有Oracle Database 12c才有的特性	77
4.4.1  PRAGMA UDF子句	77
4.4.2  在WITH子句中添加函数	78
4.5  总结	79
第5章  用集合的概念来思考	81
5.1  游标	82
5.2  从SQL到PL/SQL加载集合	83
5.2.1  Oracle Database 12c：隐式分页与持续获取	88
5.2.2  用PL/SQL合并集合	90
5.3  FORALL语句	94
5.3.1  保持语法最新：稀疏集合	96
5.3.2  直接插入	98
5.3.3  FORALL和表触发器	99
5.4  总结	101
第6章  使用触发器	103
6.1  DML触发器	104
6.1.1  数据保护：约束与触发器	104
6.1.2  默认值	107
6.1.3  非规范化的代价	110
6.2  INSTEAD OF触发器	112
6.2.1  基本的DML操作	112
6.2.2  逻辑主键的危害	115
6.2.3  处理UPDATE语句	117
6.3  总结	120
第Ⅲ部分  调优人员的工具包
第7章  不仅限于标量数据类型	125
7.1  LOB的管理	126
7.1.1  访问LOB	126
7.1.2  存储机制	127
7.1.3  I/O调优注意事项	129
7.1.4  仅SecureFile才有的特性	135
7.2  管理XML	139
7.2.1  存储XML	139
7.2.2  操作XML	144
7.3  总结	148
第8章  保持使用缓存	151
8.1  内置缓存技术	151
8.1.1  确定性函数	152
8.1.2  标量子查询缓存	156
8.1.3  PL/SQL函数结果缓存	158
8.2  手动缓存技术	165
8.2.1  PL/SQL集合	166
8.2.2  Oracle上下文	168
8.3  总结	169
第9章  射击移动目标	171
9.1  扩展基础知识	172
9.1.1  CLOB输入	172
9.1.2  光标转换	173
9.1.3  PL/SQL函数结果缓存的
集成	173
9.1.4  支持复杂的数据类型	175
9.2  深度挖掘	179
9.2.1  有关搜索的更多内容	179
9.2.2  列表内陷阱	182
9.3  应对Dynamic SQL误解带来的挑战	183
9.3.1  偏见#1：Dynamic SQL会引起安全风险	184
9.3.2  偏见#2：Dynamic SQL总是比正规的SQL慢	184
9.3.3  偏见#3：Dynamic SQL总是引起解析	185
9.3.4  偏见#4：DDL语句只能服务于DBA	187
9.4  总结	188
第Ⅳ部分  日常生活中的PL/SQL
第10章  来自战壕的传奇	191
10.1  第三方的打包代码	191
10.2  无状态问题	194
10.3  未知的撤消	197
10.4  递归的诅咒	200
10.4.1  递归和光标	200
10.4.2  递归和变量	203
10.5  总结	203
第11章  真实系统中的代码管理	205
11.1  代码管理的问题	206
11.1.1  DBA的Lite版	207
11.1.2  国产版本控制	209
11.2  基于版本的重定义和性能调优	213
11.2.1  理解Edition-Based Redefinition	213
11.2.2  在Oracle Database 12c中对EBR所做的重要修改	214
11.3  系统环境的差异以及与性能相关的代码管理	217
11.4  总结	218
第12章  额外的秘诀、技巧和理念	221
12.1  回到基础	221
12.1.1  VARCHAR2内存的分配	222
12.1.2  当前日期的成本	223
12.1.3  二进制数据类型	225
12.2  文本操作	226
12.2.1  检查文本字符串的有效字符	226
12.2.2  词的相似度	228
12.2.3  VARCHAR2和视图	230
12.3  增加处理的复杂性	232
12.3.1  NOCACHE优化	232
12.3.2  ACCESSIBLE BY子句	234
12.3.3  关于流水线函数的更多
知识	235
12.4  总结	236
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle PL SQL性能调优诀窍与方法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle PL/SQL程序设计
（上）
第1部分 用PL／SQL编程
第1章 PL／SQL介绍	3
1.1 什么是PL／SQL	3
1.2 PL／SQL的起源	4
1.2.1 早期的PL／SQL	4
1.2.2 提高应用的可移植性	4
1.2.3 提高执行权限控制和交易完整性	5
1.2.4 低调开始，持续改进	5
1.3 这就是PL／SQL	6
1.3.1 与SQL的集成	6
1.3.2 控制和条件逻辑	7
1.3.3 出错处理	8
1.4 关于PL／SQL版本	9
1.4.1 Oracle数据库12c中PL／SQL的新特性	10
1.5 可供PL／SQL开发者使用的资源	12
1.5.1 O’Reilly的PL／SQL系列图书	13
1.5.2 网络上的PL／SQL资源	14
1.6 一些建议	15
1.6.1 别急，慢慢来	15
1.6.2 不要畏惧寻求帮助	16
1.6.3 采用有创造性的甚至激进的方法	17
第2章 创建和运行PL／SQL代码	18
2.1 在数据库中导航	18
2.2 创建和编辑源代码	19
2.3 SQL*Plus	19
2.3.1 启动SQL*Plus	21
2.3.2 运行SQL语句	22
2.3.3 运行PL／SQL程序	22
2.3.4 运行一个脚本	24
2.3.5 什么是“当前目录”	24
2.3.6 其他SQL*Plus任务	25
2.3.7 SQL*Plus中的异常处理	29
2.3.8 为什么SQL*Plus让我们又爱又恨	30
2.4 执行基本的PL／SQL任务	30
2.4.1 创建存储程序	31
2.4.2 执行存储的程序	33
2.4.3 显示存储程序	34
2.4.4 存储程序的授权和别名	35
2.4.5 删除一个存储程序	36
2.4.6 隐藏存储程序的源代码	36
2.5 编辑PL／SQL的环境	37
2.6 从其他语言中调用PL／SQL	37
2.6.1 C语言，使用Oracle预编辑器（Pro*C）	38
2.6.2 Java：使用JDBC	39
2.6.3 Perl：使用PerlDBI和DBD：：Oracle	40
2.6.4 PHP：使用Oracle扩展	41
2.6.5 PL／SQLServerPages	42
2.6.6 其他	43
第3章 语言基础	44
3.1 PL／SQL块结构	44
3.1.1 匿名块	46
3.1.2 命名块	47
3.1.3 嵌套块	47
3.1.4 作用范围	48
3.1.5 规范SQL语句中对变量和列的引用	49
3.1.6 可见性	51
3.2 PL／SQL字符集	54
3.3 标识符	56
3.3.1 保留字	57
3.3.2 空白和关键字	58
3.4 直接量	59
3.4.1 NULL	60
3.4.2 在一个直接量字符串中嵌入单引号	61
3.4.3 数字直接量	61
3.4.4 布尔直接量	62
3.5 分号分隔符	62
3.6 注释	63
3.6.1 单行注释语法	63
3.6.2 多行注释语法	63
3.7 PRAGMA关键字	64
3.8 标签	65
第2部分 PL／SQL程序结构
第4章 条件与顺序控制	69
4.1 IF语句	69
4.1.1 IF—THEN组合	69
4.1.2 IF—THEN—ELSE的组合	71
4.1.3 IF—THEN—ELSIF组合	73
4.1.4 避免IF语法陷阱	73
4.1.5 嵌套的IF语句	75
4.1.6 短路估算	75
4.2 CASE语句和表达式	77
4.2.1 简单的CASE语句	77
4.2.2 搜索CASE语句	79
4.2.3 嵌套CASE语句	81
4.2.4 CASE表达式	81
4.3 GOTO语句	83
4.4 NULL语句	84
4.4.1 提高程序的可读性	84
4.4.2 在标签后使用NULL	84
第5章 循环迭代处理	86
5.1 循环的基础知识	86
5.1.1 不同循环的示例	86
5.1.2 PL／SQL循环的结构	88
5.2 简单循环	89
5.2.1 终止简单循环：EXIT和EXITWHEN	89
5.2.2 模仿REPEATUNTIL循环	90
5.2.3 故意的无限循环	91
5.3 WHILE循环	92
5.4 数值型FOR循环	93
5.4.1 数值型FOR循环的规则	94
5.4.2 数值型FOR循环的示例	94
5.4.3 处理特殊增量	95
5.5 游标FOR循环	96
5.5.1 游标FOR循环的示例	97
5.6 循环标签	98
5.7 CONTINUE语句	99
5.8 迭代处理技巧	102
5.8.1 为循环索引使用可理解的名称	102
5.8.2 以正确的方式说再见	102
5.8.3 获取FOR循环执行的信息	103
5.8.4 循环SQL语句	104
第6章 异常处理	106
6.1 异常处理概念和术语	106
6.2 定义异常	108
6.2.1 声明命名异常	108
6.2.2 关联异常名称与错误代码	109
6.2.3 命名的系统异常	112
6.2.4 异常作用范围	114
6.3 引发异常	115
6.3.1 RAISE语句	115
6.3.2 使用RAISE_APPLICATION_ERROR	116
6.4 处理异常	117
6.4.1 内置错误函数	118
6.4.2 单一处理句柄中结合多个异常	122
6.4.3 未处理异常	123
6.4.4 未处理异常的传播	123
6.4.5 继续过去的异常	125
6.4.6 编写WHENOTHERS处理代码	127
6.5 构建有效的错误管理架构	129
6.5.1 确定我们的异常管理策略	129
6.5.2 对不同类型异常进行标准化处理	130
6.5.3 程序特定错误代码的组织使用	133
6.5.4 使用标准的错误管理程序	133
6.5.5 使用自己的异常“对象”	135
6.5.6 创建常见错误处理的标准模板	137
6.6 充分利用PL／SQL错误管理	138
第3部分 PL／SQL程序数据
第7章 使用程序数据	141
7.1 程序数据的命名	141
7.2 PL／SQL数据类型概述	143
7.2.1 字符数据	143
7.2.2 数字	144
7.2.3 日期、时间戳和时间间隔	145
7.2.4 布尔类型	145
7.2.5 二进制数据类型	146
7.2.6 ROWID	146
7.2.7 REFCURSOR	146
7.2.8 Internet数据类型	147
7.2.9“Any”数据类型	147
7.2.10 用户自定义数据类型	147
7.3 程序数据的声明	147
7.3.1 声明一个变量	148
7.3.2 声明常量	148
7.3.3 NOTNULL语句	149
7.3.4 锚定声明	149
7.3.5 游标和表的锚	151
7.3.6 使用锚定声明的益处	152
7.3.7 NOTNULL数据类型的锚	153
7.4 程序员定义的子类型	153
7.5 数据类型转换	154
7.5.1 隐式类型转换	155
7.5.2 显式类型转换	156
第8章 字符串	162
8.1 字符串类型	162
8.1.1 VARCHAR2数据类型	163
8.1.2 CHAR数据类型	164
8.1.3 String子类型	164
8.2 使用字符串	165
8.2.1 指定字符串常量	165
8.2.2 不可打印字符	167
8.2.3 拼接字符串	168
8.2.4 处理大小写	169
8.2.5 传统的检索、提取和替换	172
8.2.6 填充	174
8.2.7 剪裁	176
8.2.8 正则表达式的检索、提取和替换	177
8.2.9 使用空字符串	187
8.2.10 混用CHAR和VARCHAR2188
8.3 字符串函数快速参考	190
第9章 数字	199
9.1 数值型数字类型	199
9.1.1 NUMBER类型	200
9.1.2 PLS_INTEGER类型	204
9.1.3 BINARY_INTEGER类型	205
9.1.4 SIMPLE_INTEGER类型	205
9.1.5 BINARY_FLOAT和BINARY_DOUBLE类型	207
9.1.6 SIMPLE_FLOAT和SIMPLE_DOUBLE类型	212
9.1.7 数字子类型	212
9.2 数字转换	213
9.2.1 TO_NUMBER函数	213
9.2.2 TO_CHAR函数	216
9.2.3 CAST函数	221
9.2.4 隐式转换	222
9.3 数字运算符	224
9.4 数字函数	224
9.4.1 四舍五入和截断函数	224
9.4.2 三角函数	225
9.4.3 数字函数的快速参考	225
第10章 日期和时间戳	230
10.1 Datetime数据类型	230
10.1.1 声明日期时间变量	233
10.1.2 选择日期时间数据类型	233
10.2 获取当前日期和时间	234
10.3 INTERVAL数据类型	236
10.3.1 声明INTERVAL变量	237
10.3.2 什么时候使用INTERVAL	238
10.4 日期时间转换	240
10.4.1 从字符串到日期时间	240
10.4.2 从日期时间到字符串	242
10.4.3 使用时区	245
10.4.4 精确匹配需要格式掩码	247
10.4.5 让精确匹配更轻松	248
10.4.6 解释滑动窗口中两位数字的年份	248
10.4.7 把时区转换成字符串	249
10.4.8 用填充模式把输出补齐	250
10.5 日期和时间戳直接量	251
10.6 时间间隔的转换	252
10.6.1 从数字到时间间隔的转换	252
10.6.2 把字符串转换成间隔	253
10.6.3 时间间隔的格式化显示	254
10.7 时间间隔直接量	254
10.8 CAST和EXTRACT	256
10.8.1 CAST函数	256
10.8.2 EXTRACT函数	258
10.9 日期时间的算法	258
10.9.1 时间间隔和日期时间的算法	259
10.9.2 DATE数据类型的日期算法	260
10.9.3 计算两个日期时间之间的时间间隔	260
10.9.4 DATE和TIMESTAMP混合计算	262
10.9.5 时间间隔的加减运算	263
10.9.6 时间间隔的乘除运算	264
10.9.7 使用不受限制的时间间隔类型	264
10.10 日期／时间函数的快速参考	266
第11章 记录类型	269
11.1 PL／SQL中的记录	269
11.1.1 使用记录的好处	270
11.1.2 声明记录	271
11.1.3 程序员自定义的记录类型	273
11.1.4 使用记录类型	275
11.1.5 记录的比较	281
11.1.6 触发器伪记录	282
第12章 集合	284
12.1 集合概述	285
12.1.1 集合概念和术语	285
12.1.2 集合类型	287
12.1.3 集合示例	288
12.1.4 使用集合的场合	291
12.1.5 选择一个集合类型	296
12.2 集合方法（内置）	297
12.2.1 COUNT方法	298
12.2.2 DELETE方法	299
12.2.3 EXISTS方法	300
12.2.4 EXTEND方法	300
12.2.5 FIRST和LAST方法	301
12.2.6 LIMIT方法	302
12.2.7 PRIOR和NEXT方法	303
12.2.8 TRIM方法	304
12.3 使用集合	305
12.3.1 声明集合类型	306
12.3.2 集合变量的声明和初始化	310
12.3.3 用数据填充集合	313
12.3.4 访问集合内的数据	318
12.3.5 使用字符串索引的集合	319
12.3.6 复杂数据类型的集合	324
12.3.7 多级集合	327
12.3.8 在SQL中使用集合	335
12.4 嵌套表的多重集合操作	342
12.4.1 测试嵌套表是否相等及成员归属	343
12.4.2 检查元素是否是嵌套表的成员	344
12.4.3 执行高级别集合操作	345
12.4.4 嵌套表中的去重	346
12.5 schema级别集合的维护	347
12.5.1 必需的权限	347
12.5.2 集合和数据字典	348
第13章 其他数据类型	349
13.1 BOOLEAN类型	349
13.2 RAW数据类型	350
13.3 UROWID和ROWID数据类型	351
13.3.1 获取ROWID	352
13.3.2 使用ROWID	352
13.4 LOB数据类型	353
13.5 使用LOB	354
13.5.1 理解LOB定位符	356
13.5.2 LOB的空和NULL	357
13.5.3 向LOB中写入数据	359
13.5.4 读取LOB数据	361
13.5.5 BFILE的不同之处	363
13.5.6 SecureFiles和BasicFiles	367
13.5.7 临时LOB	369
13.5.8 原生的LOB操作	372
13.5.9 LOB转换函数	376
13.6 预定义的对象类型	376
13.6.1 XMLType类型	376
13.6.2 URI类型	379
13.6.3 Any类型	381
第4部分 PL／SQL中的SQL
第14章 DML和事务管理	387
14.1 PL／SQL中的DML	388
14.1.1 DML简介	388
14.1.2 DML操作符的游标属性	391
14.1.3 从DML语句返回信息	392
14.1.4 DML和异常处理	393
14.1.5 DML和记录	394
14.2 事务管理	397
14.2.1 COMMIT语句	397
14.2.2 ROLLBACK语句	398
14.2.3 SAVEPOINT语句	399
14.2.4 SETTRANSACTION语句	399
14.2.5 LOCKTABLE语句	400
14.3 自治事务	400
14.3.1 定义自治事务	401
14.3.2 自治事务的规则和限制	402
14.3.3 事务的可见性	403
14.3.4 何时使用自治事务	403
14.3.5 创建自治日志记录机制	404
第15章 数据提取	407
15.1 游标基础	408
15.1.1 一些数据提取术语	408
15.1.2 典型的查询操作	410
15.1.3 游标属性介绍	411
15.1.4 在游标中引用PL／SQL变量	413
15.1.5 显式与隐式游标之间的选择	414
15.2 使用隐式游标	414
15.2.1 隐式游标示例	415
15.2.2 隐式游标的异常处理	416
15.2.3 隐式SQL游标的属性	418
15.3 使用显式游标	419
15.3.1 声明显式游标	420
15.3.2 打开显式游标	423
15.3.3 从显式游标获取	424
15.3.4 显式游标中的列别名	425
15.3.5 关闭显式游标	426
15.3.6 显式游标属性	427
15.3.7 游标参数	429
15.4 SELECT…FORUPDATE	432
15.4.1 COMMIT释放锁定	433
15.4.2 WHERECURRENTOF子句	434
15.5 游标变量和REFCURSOR	435
15.5.1 为什么使用游标变量	436
15.5.2 与静态游标的相似之处	437
15.5.3 声明REFCURSOR类型	437
15.5.4 声明游标变量	438
15.5.5 打开游标变量	439
15.5.6 从游标变量中提取数据	440
15.5.7 游标变量的使用规则	442
15.5.8 将游标变量作为参数传递	445
15.5.9 游标变量的约束限制	447
15.6 游标表达式	447
15.6.1 使用游标表达式	448
15.6.2 游标表达式的约束限制	450
第16章 动态SQL和动态
PL／SQL	451
16.1 NDS语句	452
16.1.1 EXECUTEIMMEDIATE语句	452
16.1.2 OPENFOR语句	455
16.1.34种动态SQL方法	460
16.2 绑定变量	462
16.2.1 参数模式	463
16.2.2 重复的占位符	465
16.2.3 传递NULL值	465
16.3 使用对象和集合	466
16.4 动态PL／SQL	468
16.4.1 建立动态PL／SQL块	469
16.4.2 用动态块替换重复代码	470
16.5 NDS建议	471
16.5.1 对共享程序使用调用者权限	471
16.5.2 预测并处理动态错误	472
16.5.3 使用绑定而非拼接	474
16.5.4 减少代码注入的危险	475
16.6 何时使用DBMS_SQL	478
16.6.1 获得查询列信息	478
16.6.2 实现第四种方法的动态SQL需求	479
16.6.3 最小化动态游标解析	485
16.6.4 Oracle数据库11g新动态SQL特性	486
16.6.5 DBMS_SQL增强安全	490
（下）
第5部分 构造PL／SQL应用程序
第17章 过程、函数和参数	497
17.1 代码模块化	497
17.2 过程	499
17.2.1 调用一个过程	501
17.2.2 过程头部	501
17.2.3 过程体	501
17.2.4 END标签	502
17.2.5 RETURN语句	502
17.3 函数	502
17.3.1 函数的结构	503
17.3.2 返回的数据类型	504
17.3.3 END标签	506
17.3.4 调用函数	506
17.3.5 不带参数的函数	507
17.3.6 函数头	508
17.3.7 函数体	508
17.3.8 RETURN语句	509
17.4 参数	510
17.4.1 定义参数	511
17.4.2 实参和形参	511
17.4.3 参数模式	512
17.4.4 在PL／SQL中显式地关联实参和形参	515
17.4.5 NOCOPY参数模式限定符	519
17.4.6 缺省值	519
17.5 局部或者嵌套模块	520
17.5.1 使用局部模块的益处	521
17.5.2 局部模块的作用范围	523
17.5.3 用局部模块使得代码更整洁	524
17.6 模块的重载	524
17.6.1 重载的益处	525
17.6.2 重载的限制	528
17.6.3 数字类型的重载	528
17.7 前置声明	529
17.8 高级主题	530
17.8.1 在SQL内部调用我们的函数	530
17.8.2 表函数	536
17.8.3 确定性函数	545
17.8.4 隐式游标结果（Oracle数据库12c）	546
17.9 将模块化进行到底	547
第18章 程序包	548
18.1 为什么使用程序包	548
18.1.1 演示程序包的能力	549
18.1.2 与程序包相关的一些概念	552
18.1.3 图示私有性	553
18.2 构建程序包的规则	554
18.2.1 程序包说明	554
18.2.2 包体	555
18.2.3 包的初始化	557
18.3 包元素的调用规则	561
18.4 使用包数据	562
18.4.1 在一个Oracle会话内全局可见	562
18.4.2 全局公有数据	563
18.4.3 包游标	563
18.4.4 包的串行化	568
18.5 何时使用包	570
18.5.1 封装对数据的访问	570
18.5.2 避免直接量的硬编码	573
18.5.3 提高内置特性的可用性	575
18.5.4 把逻辑上相关的功能组织在一起	576
18.5.5 缓存静态的会话数据	576
18.6 包和对象类型	577
第19章 触发器	578
19.1 DML触发器	579
19.1.1 DML触发器的概念	580
19.1.2 创建DML触发器	581
19.1.3 DML触发器的例子：严禁作弊！	586
19.1.4 同一类型的多个触发器	591
19.1.5 如何对触发顺序排序	592
19.1.6 突变表的错误	594
19.1.7 复合触发器：聚在一处	595
19.2 DDL触发器	598
19.2.1 创建DDL触发器	598
19.2.2 可用事件	600
19.2.3 可用属性	601
19.2.4 使用事件和属性	602
19.2.5 删除不可删除的	606
19.2.6 INSTEADOFCREATE触发器	606
19.3 数据库事件触发器	607
19.3.1 创建数据库事件触发器	608
19.3.2 STARTUP触发器	609
19.3.3 SHUTDOWN触发器	610
19.3.4 LOGON触发器	610
19.3.5 LOGOFF触发器	610
19.3.6 SERVERERROR触发器	611
19.4 INSTEADOF触发器	615
19.4.1 创建INSTEADOF触发器	615
19.4.2 INSTEADOFINSERT触发器	616
19.4.3 INSTEADOFUPDATE触发器	618
19.4.4 INSTEADOFDELETE触发器	619
19.4.5 填充表	619
19.4.6 嵌套表的lNSTEADOF触发器	620
19.5 AFTERSUSPEND触发器	621
19.5.1 建立AFTERSUSPEND触发器	622
19.5.2 看看真实的触发器	623
19.5.3 ORA_SPACE_ERROR_INFO函数	624
19.5.4 DBMS_RESUMABLE包	625
19.5.5 捕获多个时间	626
19.5.6 是否该处理？	627
19.6 维护触发器	628
19.6.1 禁用、启用以及删除触发器	628
19.6.2 创建一个禁用的触发器	628
19.6.3 查看触发器	629
19.6.4 检查触发器的有效性	630
第20章 管理PL／SQL代码	631
20.1 管理数据库内的代码	632
20.1.1 数据字典视图概述	632
20.1.2 显示存储对象的信息	634
20.1.3 源代码的显示和搜索	635
20.1.4 根据程序的大小确定Pinning需求	637
20.1.5 获得存储代码的属性	637
20.1.6 通过视图分析和更改触发器状态	638
20.1.7 分析参数信息	639
20.1.8 分析标识符的使用（Oracle数据库11g的PL／Scope）	640
20.2 管理依赖关系及重编译代码	643
20.2.1 通过数据字典视图分析依赖关系	643
20.2.2 细粒度依赖（Oracle数据库11g）	647
20.2.3 远程依赖	648
20.2.4 Oracle的远程调用模式的限制	650
20.2.5 重编译无效的程序单元	651
20.3 编译时刻警告	655
20.3.1 一个快速示例	655
20.3.2 开启编译时刻告警	656
20.3.3 一些有用的警告	657
20.4 测试PL／SQL程序	664
20.4.1 典型的、华而不实的测试技术	665
20.4.2 PL／SQL代码测试的一般建议	668
20.4.3 PL／SQL的自动测试选项	669
20.5 跟踪PL／SQL的执行	670
20.5.1 DBMS_UTILITY.FORMAT_CALL_STACK	671
20.5.2 UTL_CALL_STACK（Oracle数据库12c）	673
20.5.3 DBMS_APPLICATION_INFO	676
20.5.4 使用opp_trace进行跟踪	677
20.5.5 DBMS_TRACE工具包	678
20.6 PL／SQL程序的调试	681
20.6.1 错误的调试方法	682
20.6.2 调试技巧和策略	683
20.7 使用白名单来控制对程序单元的访问	687
20.8 存储代码的保护	689
20.8.1 封装的约束和局限	690
20.8.2 使用封装程序	690
20.8.3 使用DBMS_DDL进行动态封装	690
20.8.4 封装代码的使用指导	691
20.9 基于版本的重定义（Oracle数据库11gR2版本）	692
第21章 PL／SQL的性能优化	695
21.1 辅助优化的工具	696
21.1.1 内存使用分析	696
21.1.2 发现PL／SQL代码中的瓶颈	697
21.1.3 计算花费时间	701
21.1.4 选择最快的程序	703
21.1.5 避免无限循环	704
21.1.6 性能相关的警告	706
21.2 优化编译器	706
21.2.1 优化器工作原理	707
21.2.2 循环Fetch操作的运行时优化	710
21.3 数据缓存技术	710
21.3.1 基于包的缓存	711
21.3.2 确定性函数的缓存	716
21.3.3 函数结果缓存（Oracle数据库11g）	718
21.3.4 缓存总结	731
21.4 重复的SQL的语句批处理	732
21.4.1 通过BULKCOLLECT加速查询	733
21.4.2 使用FORALL加速DML	739
21.5 利用管道化的表函数提升性能	749
21.5.1 用基于管道化函数的加载方式替换基于行的插入	750
21.5.2 用管道函数调优Merge操作	756
21.5.3 用并行管道函数进行异步数据导出	758
21.5.4 并行管道函数中的分区和流子句对性能的影响	761
21.5.5 管道函数和基于成本的优化器	763
21.5.6 用管道函数优化负载的数据加载	768
21.5.7 管道函数结束语	775
21.6 专用的优化技术	775
21.6.1 使用NOCOPY参数模式提示符	775
21.6.2 使用正确的数据类型	778
21.6.3 SQL（12.1及更高版本）的函数性能优化	779
21.7 性能回顾	780
第22章 I／O操作和PL／SQL	781
22.1 显示信息	781
22.1.1 启用DBMS_OUTPUT	782
22.1.2 向缓存中写入行	782
22.1.3 从缓存中读取内容	783
22.2 文件的读写	784
22.2.1 UTL_FILE_DIR参数	784
22.2.2 使用Oracle目录	786
22.2.3 打开文件	787
22.2.4 文件已经打开了吗？	789
22.2.5 关闭文件	789
22.2.6 读取文件	790
22.2.7 向文件中写	792
22.2.8 复制文件	795
22.2.9 删除文件	795
22.2.10 改名和移动文件	796
22.2.11 提取文件属性	797
22.3 发送邮件	798
22.3.1 Oracle的前提条件	798
22.3.2 设置网络安全	799
22.3.3 发送一个短的（小于32767字节）的纯文本消息	799
22.3.4 在邮件地址中加上“界面友好的”的名字	801
22.3.5 发送任意长度的纯文本消息	802
22.3.6 发送带有小附件（小于32767字节）的消息	803
22.3.7 以附件形式发送一个小文件（小于32767字节）	805
22.3.8 任意大小的附件	805
22.4 使用基于Web的数据（HTTP）	808
22.4.1“分片”获得一个Web页面	808
22.4.2 把页面提取到一个LOB中	809
22.4.3 使用HTTP的用户名／密码验证	810
22.4.4 获取一个SSL加密的Web页面（使用HTTPS）	811
22.4.5 通过GET或者POST向Web页面提交数据	812
22.4.6 禁用cookie或者使cookie持久化	816
22.4.7 从FTP服务器获取数据	816
22.4.8 使用代理服务器	817
22.5 PL／SQL中可用的其他I／O类型	817
22.5.1 数据库管道、队列、告警	817
22.5.2 TCPSocket	818
22.5.3 Oracle的内置Web服务器	818
第6部分 高级PL／SQL主题
第23章 应用系统安全与PL／SQL	821
23.1 安全概述	821
23.2 加密	822
23.2.1 密钥长度	823
23.2.2 算法	824
23.2.3 填补和连接	825
23.2.4 DBMS_CRYPTO包	825
23.2.5 数据加密	827
23.2.6 LOB的加密	830
23.2.7 安全文件	830
23.2.8 数据解密	831
23.2.9 生成密钥	832
23.2.10 密钥的管理	833
23.2.11 加密哈希	838
23.2.12 使用消息验证码	839
23.2.13 使用透明数据加密（TDE）	841
23.2.14 透明的表空间加密	843
23.3 行级安全	844
23.3.1 为什么要学习RLS	846
23.3.2 一个简单的RLS示例	847
23.3.3 静态与动态策略	850
23.3.4 使用列敏感的RLS	854
23.3.5 RLS调试	857
23.4 应用程序上下文	861
23.4.1 使用应用程序上下文	862
23.4.2 上下文的安全	863
23.4.3 把上下文用作RLS的谓词条件	863
23.4.4 识别出非数据库的用户	867
23.5 细粒度审计	868
23.5.1 为什么要学习FGA	869
23.5.2 一个简单的FGA示例	870
23.5.3 访问多少列	872
23.5.4 查看审计跟踪信息	873
23.5.5 使用绑定变量	874
23.5.6 使用句柄模块	875
第24章 PL／SQL架构	877
24.1 DIANA	877
24.2 Oracle如何执行PL／SQL代码	878
24.2.1 一个示例	879
24.2.2 编译器的限制	881
24.3 PL／SQL的缺省包	882
24.4 执行权限模型	884
24.4.1 定义者权限模型	885
24.4.2 调用者权限模型	889
24.4.3 组合权限模型	891
24.4.4 给PL／SQL程序单元授予角色（Oracle数据库12c）	892
24.4.5“谁调用了我？”函数（Oracle数据库12c）	895
24.4.6 视图的BEQUEATHCURRENT_USER子句（Oracle数据库12c）	895
24.4.7 调用者权限优点的限制（Oracle数据库12c）	897
24.5 条件编译	898
24.5.1 条件编译的示例	899
24.5.2 查询指令	900
24.5.3 $IF指令	903
24.5.4 $ERROR指令	904
24.5.5 将代码与包常量同步	905
24.5.6 用查询指令实现程序专有设置	906
24.5.7 使用预处理后的代码	907
24.6 PL／SQL和数据库实例内存	908
24.6.1 SGA、PGA和UGA	908
24.6.2 游标、内存及其他	909
24.6.3 减少内存使用的技巧	910
24.6.4 内存用光了怎么办	920
24.7 原生式编译	922
24.7.1 什么时候使用解释模式	922
24.7.2 什么时候使用原生模式	922
24.7.3 原生编译和数据库版本	923
24.8 一些须知	923
第25章 PL／SQL的全球化和本地化	925
25.1 概述和术语	926
25.2 Unicode入门	928
25.2.1 国家字符集的数据类型	929
25.2.2 字符编码	929
25.2.3 和全球化支持相关的参数	930
25.2.4 Unicode函数	931
25.3 字符语义	938
25.4 字符串排序顺序	941
25.4.1 二进制排序	942
25.4.2 单语言排序	943
25.4.3 多语言排序	945
25.5 多语言信息检索	946
25.5.1 信息检索和PL／SQL	948
25.6 日期／时间	950
25.6.1 时间戳数据类型	951
25.6.2 日期／时间格式	952
25.7 货币转换	955
25.8 PL／SQL的全球化开发工具箱	957
25.8.1 UTL_I18N工具包	957
25.8.2 UTL_LMS异常处理包	960
25.8.3 GDK实现选项	961
第26章 PL／SQL的面向对象特性	963
26.1 Oracle对象特性的介绍	963
26.2 对象类型示例	965
26.2.1 创建一个基类	966
26.2.2 创建子类型	967
26.2.3 方法	968
26.2.4 在Oracle数据库11g及以后版本中调用父类的方法	972
26.2.5 保存、提取、使用持久化对象	974
26.2.6 演变和创建	981
26.2.7 回到指针吗？	983
26.2.8 泛化数据：ANY类型	989
26.2.9 我们自己做	993
26.2.10 对象的比较	996
26.3 对象视图	1001
26.3.1 一个关系型系统的示例	1002
26.3.2 带有集合属性的对象视图	1003
26.3.3 对象子视图	1006
26.3.4 带有反关系的对象视图	1008
26.3.5 INSTEADOF触发器	1008
26.3.6 对象视图和对象表的区别	1010
26.4 维护对象类型和对象视图	1012
26.4.1 数据字典	1012
26.4.2 权限	1013
26.5 来自一个关系开发者的总结思考（C551，E1200）	1015
第27章 从PL／SQL中调用Java	1017
27.1 Oracle和Java	1017
27.2 准备好在Oracle中使用Java	1018
27.2.1 安装Java	1019
27.2.2 创建和编译我们的Java代码	1019
27.2.3 设置Java开发和执行的权限	1020
27.3 一个简单的演示	1022
27.3.1 查找Java功能	1023
27.3.2 创建一个自定义Java类	1023
27.3.3 编译和加载到Oracle	1025
27.3.4 创建一个PL／SQL的包装器	1026
27.3.5 从PL／SQL删除文件	1027
27.4 使用loadjava	1028
27.5 使用dropjava	1030
27.6 管理数据库中的Java	1030
27.6.1 Oracle中的Java命名空间	1030
27.6.2 检查加载的Java元素	1031
27.7 使用DBMS_JAVA	1032
27.7.1 LONGNAME：转换Java长名字	1032
27.7.2 GET_、SET_和RESET_COMPILER_OPTION：得到和设置（一些）编译器选项	1033
27.7.3 SET_OUTPUT：允许从Java中输出	1034
27.7.4 EXPORT_SOURCE、EXPORT_RESOURCE和EXPORT_CLASS：导出模式对象	1034
27.8 在PL／SQL中发布与使用Java	1036
27.8.1 调用规范	1036
27.8.2 一些调用规范的规则	1037
27.8.3 映射数据类型	1038
27.8.4 在SQL中调用Java方法	1039
27.8.5 Java的异常处理	1040
27.8.6 扩展文件I／O功能	1042
27.8.7 其他示例	1046
第28章 外部过程	1049
28.1 外部过程介绍	1050
28.1.1 示例：调用一个系统命令	1050
28.1.2 外部过程的架构	1052
28.2 Oracle网络配置	1053
28.2.1 定义监听配置	1053
28.2.2 配置的安全特性	1055
28.3 设置多线程模式	1056
28.4 创建一个Oracle库	1058
28.5 编写调用规范	1059
28.5.1 调用规范：整体语法	1060
28.5.2 参数映射：示例重温	1061
28.5.3 参数映射：完整的内容	1063
28.5.4 更多的语法：参数子句	1064
28.5.5 参数属性	1065
28.6 从调用的C程序中引发一个异常	1068
28.7 非默认的代理	1071
28.8 维护外部过程	1073
28.8.1 删除库	1073
28.8.2 数据字典	1074
28.8.3 规则和警示	1074
附录A 正则表达式元字符和函数参数	1075
附录B 数字格式模型	1080
附录C 日期格式模型 1083
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle PL/SQL程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Oracle R Enterprise大数据 在Oracle数据库中充分利用R的强大功能
目    录
第1章  Oracle R Enterprise简介     1
1.1  本书的目标     3
1.2  Oracle Advanced Analytics选件     4
1.3  Oracle R Enterprise(Oracle R企业版)     5
1.4  利用Oracle R Enterprise易于部署R     7
1.5  Oracle的R技术     9
1.6  客户如何使用Oracle R Enterprise和Oracle Advanced Analytics     10
1.7  小结     11
第2章  安装Oracle R Enterprise     13
2.1  安装的先决条件     13
2.2  设置Oracle Database     14
2.3  安装Oracle R Enterprise     15
2.3.1  Oracle R Enterprise的软件包     15
2.3.2  安装前的要求     16
2.3.3  在Oracle Database Server上的安装     17
2.3.4  安装客户端     22
2.4  验证ORE的安装     25
2.5  安装RStudio     26
2.6  使用Oracle的预制应用     27
2.6.1  预制应用Oracle Database Developer     27
2.6.2  预制应用Oracle OBIEE Sample App     28
2.6.3  预制应用Oracle Big Data Lite     29
2.7  小结     29
第3章  Oracle R Enterprise入门     31
3.1  创建和管理到数据库的ORE连接     31
3.1.1  使用ore.connect创建ORE连接     32
3.1.2  使用ore.sync同步数据     33
3.1.3  使用ore.attach将对象加入搜索空间     35
3.2  执行SQL命令     36
3.3  在Oracle Database中处理数据     36
3.4  在数据库中存储数据     40
3.4.1  使用ore.creat函数建表     40
3.4.2  使用ore.drop函数删除表     40
3.4.3  ore.create函数和ore.drop函数组合使用的示例     41
3.5  在数据库自带的R Datastore中存储ORE对象     41
3.6  断开与数据库的连接     46
3.7  小结     46
第4章  透明层     47
4.1  透明层概述     47
4.2  探寻ORE透明层背后的真相     50
4.3  小结     53
第5章  Oracle R Enterprise程序包     55
5.1  Oracle R Enterprise程序包     55
5.2  探索ORE包函数和程序包版本     57
5.3  ORE设置和选项     59
5.4  获得ORE的帮助     61
5.5  ORE演示脚本     62
5.6  小结     66
第6章  探索数据     67
6.1  探索性数据分析(EDA)     68
6.2  数据抽样     73
6.3  数据聚合     78
6.4  数据转换     80
6.4.1  派生属性     80
6.4.2  分块属性     81
6.4.3  组合数据     82
6.5  数据排序     82
6.6  小结     83
第7章  使用ODM算法建立模型     85
7.1  Oracle Data Mining(Oracle数据挖掘)     86
7.1.1  ORE中可用的ODM算法     87
7.1.2  利用OREdm软件包在Oracle中进行自动数据准备     87
7.2  使用OREdm软件包建立模型和对数据进行评分     88
7.2.1  属性重要性     88
7.2.2  关联规则分析     89
7.2.3  决策树     92
7.2.4  支持向量机     94
7.2.5  朴素贝叶斯     98
7.2.6  广义线性模型     99
7.2.7  聚类     100
7.3  保存数据挖掘模型     101
7.4  小结     103
第8章  利用ORE和其他算法建立模型     105
8.1  什么算法是可用的？     106
8.2  为建模而准备数据     106
8.3  使用ORE算法建立模型     107
8.3.1  广义线性模型     108
8.3.2  线性和逐步回归模型     109
8.3.3  神经网络     111
8.3.4  随机森林     112
8.4  使用R软件包和算法构建模型     113
8.5  使用ore.predict优化数据库自带的评分过程     115
8.6  小结     117
第9章  在用户定义的R脚本库中生成R脚本     119
9.1  使用R脚本库     120
9.2  创建和删除R脚本     120
9.3  授予和撤消用户定义的R 脚本的特权     122
9.4  管理R Script Repository     123
9.5  使用SQL API创建脚本     123
9.5.1  创建一个R脚本     124
9.5.2  删除一个脚本     126
9.5.3  授予和撤消访问权限     126
9.5.4  用户定义的R脚本的数据字典视图     127
9.6  小结     127
第10章  嵌入式R执行     129
10.1  通过R接口使用嵌入式R执行     129
10.1.1  如何使用ore.doEval函数     130
10.1.2  如何使用ore.tableApply函数     132
10.1.3  如何使用ore.groupApply函数     134
10.1.4  如何使用ore.rowApply函数     135
10.1.5  如何使用ore.indexApply函数     136
10.1.6  并行执行嵌入式R函数     137
10.2  通过SQL接口使用嵌入式R执行     138
10.2.1  如何使用rqEval SQL函数     138
10.2.2  如何使用SQL函数rqTableEval     140
10.2.3  如何使用SQL函数“rqGroupEval”     144
10.2.4  如何使用SQL函数rqRowEval     146
10.3  小结     147
第11章  针对Hadoop的Oracle R Advanced Analytics     149
11.1  连接到Apache Hive上并处理数据     152
11.2  使用ORCH管理Map-Reduce作业     155
11.3  通过ORAAH使用Spark     157
11.4  小结     158
第12章  通过Oracle Data Mining使用ORE     159
12.1  Oracle Data Mining     160
12.2  Oracle Data Miner     164
12.3  通过SQL Node来包含R脚本     165
12.4  使用R节点     167
12.5  小结     168
第13章  在APEX和OBIEE中使用ORE     171
13.1  Oracle APEX     171
13.1.1  在APEX应用程序中包含ORE脚本     173
13.1.2  向APEX应用程序中添加R图形     175
13.2  Oracle Business Intelligence     177
13.2.1  设置OBIEE以便能使用ORE     178
13.2.2  在OBIEE RPD中使用R脚本     180
13.2.3  在仪表板上呈现由R脚本产生的结果     180
13.3  小结     182
第14章  针对Oracle DBA的ORE     183
14.1  在数据库中创建一个新的ORE模式     183
14.2  在Oracle R Enterprise中安装新的R软件包     184
14.2.1  在数据库服务器上安装新的R软件包     185
14.2.2  在客户机上安装新软件包     186
14.3  ORE的全局变量和选项     187
14.4  使用ore.parallel特性     189
14.5  卸载Oracle R Enterprise     189
14.5.1  从Oracle Database服务器中卸载Oracle R Enterprise     190
14.5.2  从客户端卸载Oracle R Enterprise     191
14.6  小结     192
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Oracle R Enterprise大数据 在Oracle数据库中充分利用R的强大功能
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>构建Oracle数据库云最佳实践 使用Oracle Enterprise Manager Cloud Control 13c
第1章  云端的整合规划 1
1.1  Oracle云计算介绍 1
1.2  物理服务器的整合管理 2
1.3  执行主机整合规划 2
1.4  创建P2P的自定义整合场景 10
1.5  整合至Oracle公共云服务器 17
1.6  整合至虚拟服务器 19
1.7  更新基准率 20
1.8  Database Consolidation Workbench 21
1.9  创建D2S项目及场景 22
1.10  创建D2D项目及场景 27
1.11  实施整合规划 30
1.12  小结 31
第2章  数据库即服务 33
2.1  Self Service Portal配置 34
2.2  Software Library配置 34
2.3  Self Update配置 35
2.4  部署插件 37
2.5  创建门户角色和用户 40
2.6  创建PaaS Infrastructure Zone 40
2.7  创建数据库池 42
2.8  Quotas设置 45
2.9  创建数据配置文件：单实例数据库 46
2.10  创建数据配置文件：快照克隆数据库 50
2.11  创建服务模板：单实例数据库 51
2.12  创建服务模板：Snap Clone Database 57
2.13  启用Request Settings 59
2.14  Chargeback配置 61
2.14.1  更改Chargeback的全局设置 64
2.14.2  添加成本中心 64
2.15  自助服务：请求和创建数据库服务 68
2.16  自助服务：请求和创建Snap Clone(CloneDB)数据库服务 80
2.17  小结 87
第3章  模式即服务 89
3.1  创建一个模式池 90
3.2  处理配额 93
3.3  创建数据配置文件 94
3.4  从HR模式创建一个服务模板 97
3.5  为用户自定义模式创建服务模板 99
3.6  请求设置 101
3.7  配置计费 102
3.8   自助服务：请求和创建一个模式服务 104
3.9  自助服务：请求和创建用户自定义模式 110
3.10  小结 114
第4章  可插拔数据库即服务 115
4.1  创建一个可插拔数据库池 116
4.2  设置配额 119
4.3  为PDB创建数据配置文件 120
4.4  从PDB配置文件创建服务模板 122
4.5  为空PDB创建服务模板 125
4.6  设立请求设置 128
4.7  配置计费 128
4.8  自助服务：为SALES PDB请求和创建PDB服务 130
4.9  自助服务：为空PDB请求和创建PDB服务 136
4.10  查看计费结果 138
4.11  管理云 141
4.12  小结 143
第5章  数据库混合云 145
5.1  混合云的预安装步骤 146
5.1.1  第一步：注册代理 146
5.1.2  第二步：生成SSH
密钥 147
5.1.3  第三步：创建命名
证书 147
5.1.4  第四步：将SELINUX设置
为Permissive 148
5.1.5  其他要求 149
5.2  测试混合云 149
5.2.1  安装云代理 150
5.2.2  在云服务器上发现数据
库和侦听器 156
5.2.3  比较本地和云数据库
的配置 160
5.2.4  将本地的PDB克隆
到云上 162
5.3  当给云数据库打补丁时，先
保存Agent Home目录 163
5.4  克隆到Oracle云上 163
5.4.1  对结果进行遮蔽 170
5.4.2  验证CDB的APEX
版本 171
5.5  从Oracle云端克隆 172
5.6  小结 174
第6章  使用Cloud REST API 175
6.1  安装REST客户端 176
6.2  前期准备步骤 177
6.3  步骤1：查看详细信息 178
6.4  步骤2：创建数据库 182
6.4.1  通过Enterprise Manager
API检查数据库的
创建进度 184
6.4.2  通过Cloud REST API
检查数据库的创建
进度 186
6.5  步骤3：刷新已完成创建
请求的数据库 186
6.6  步骤4：删除之前通过请求
完成创建的数据库 188
6.7  步骤5：创建Schema 189
6.7.1  通过EM13c界面检查
schema创建请求进度 191
6.7.2  通过Cloud REST API
检查schema的创建请求
进度 191
6.8  步骤6：删除之前通过请求
完成创建的schema服务 192
6.9  步骤7：创建可插入数据库 193
6.9.1  通过EM13c界面检查PDB
创建请求的完成进度 195
6.9.2  通过Cloud REST API
检查PDB创建请求的完成
进度 196
6.10  步骤8：删除完成创建的可
插拔数据库 197
6.11  通过JSON文件导入
Postman Collections(可选) 198
6.12  小结 199
第7章  管理数据库备份 201
7.1  在过去的备份 202
7.2  RMAN的优点 203
7.3  初始备份步骤 203
7.4  备份设置 205
7.5  调度完整的备份 210
7.6  管理备份 215
7.7  调度增量备份 216
7.8  备份策略 220
7.9  数据库组备份 220
7.10  Oracle Database 12c的备份 227
7.11  创建备份报告 228
7.12  小结 229
第8章  管理备用数据库 231
8.1  Oracle灾难恢复的旧时代 232
8.2  初始步骤 234
8.3  添加备用数据库 235
8.4  Data Guard的菜单选项 243
8.5  Data Guard Administration 246
8.6  编辑备用数据库属性 247
8.6.1  General选项卡设置 248

8.6.2  Standby Role Properties
选项卡设置 248
8.6.3  Common Properties选项
卡设置 249
8.6.4  保存并检查你的设置 249
8.7  编辑主数据库属性 250
8.8  转换为快照备用数据库 250
8.9  计划切换和故障切换 251
8.9.1  执行计划切换 252
8.9.2  执行故障切换 254
8.10  Oracle Database 12c中的
远程同步 258
8.11  通过自助服务实现
Data Guard 263
8.12  小结 263
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>构建Oracle数据库云最佳实践 使用Oracle Enterprise Manager Cloud Control 13c
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 12c Oracle RMAN备份与恢复（第4版）
第Ⅰ部分  开始在Oracle Database     12c中使用RMAN
第1章  RMAN和Oracle Database 12c快速入门指南 3
1.1  预备步骤 4
1.2  为RMAN操作配置数据库 4
1.2.1  确定FRA的正确位置并创建FRA 5
1.2.2  登录到数据库并将其配置为使用FRA 5
1.2.3  将数据库置于ARCHIVELOG模式 5
1.3  备份数据库 6
1.4  还原数据库 7
1.5  小结 7
第2章  Oracle Database 12c备份与恢复体系结构概述 9
2.1  本书主要内容 10
2.2  RMAN专家也需要学习本章和本书 11
2.3  开始学习之旅 12
2.4  备份和恢复概要 12
2.4.1  高可用性 13
2.4.2  备份和恢复 14
2.5  需要掌握的Oracle术语 16
2.6  多租户功能推出之前的Oracle 数据库体系结构 19
2.6.1  Oracle进程 19
2.6.2  Oracle内存和RMAN 24
2.6.3  Oracle数据库 26
2.6.4  更多关于Oracle重做日志的内容 29
2.6.5  ARCHIVELOG模式与NOARCHIVELOG模式 32
2.6.6  Oracle逻辑结构 33
2.7  组合情况 33
2.8  Oracle数据库内核的更多信息 35
2.9  控制数据库软件 38
2.10  Oracle备份与恢复入门 39
2.10.1  逻辑备份与恢复 40
2.10.2  Oracle物理备份与恢复 40
2.10.3  备份其他Oracle组件 44
2.11  小结 45
第3章  RMAN体系结构概述 47
3.1  服务器管理的恢复 48
3.2  RMAN实用程序 48
3.3  RMAN备份的网络拓扑结构 51
3.3.1  RMAN和扩展 51
3.3.2  RMAN和共享服务器 52
3.3.3  在目标数据库的
ORACLE_HOME中本地
运行RMAN 53
3.4  数据库控制文件 53
3.4.1  在控制文件中重用记录 54
3.4.2  快照控制文件 55
3.4.3  重建控制文件 56
3.5  RMAN服务器进程 56
3.6  RMAN使用的SYS数据包 57
3.6.1  SYS.DBMS_RCVMAN
数据包 57
3.6.2  SYS.DBMS_BACKUP_
RESTORE数据包 57
3.7  备份数据块 58
3.7.1  数据块备份概述 58
3.7.2  块级备份的优点 59
3.8  内存中的RMAN 61
3.8.1  输入内存缓冲区 62
3.8.2  RMAN内存利用：PGA与
SGA 63
3.9  恢复目录 64
3.10  辅助数据库 66
3.11  兼容性问题 67
3.12  RMAN进程 68
3.13  快速恢复区 70
3.14  小结 71
第4章  Oracle Database 12c
多租户 73
4.1  Oracle多租户简介 74
4.1.1  CDB 75
4.1.2  可插入数据库 79
4.1.3  Oracle多租户对RMAN
备份和恢复的影响 81
4.2  管理容器数据库 81
4.2.1  启动和停止CDB 81
4.2.2  普通用户 82
4.3  可插入数据库 84
4.3.1  PDB名称 85
4.3.2  创建PDB 85
4.3.3  PDB用户 85
4.3.4  连接到PDB 86
4.3.5  确定当前所在的PDB 89
4.3.6  可插入数据库的体系结构 90
4.3.7  PDB约束 92
4.3.8  PDB性能 92
4.3.9  PDB资源管理 93
4.4  CDB和PDB以及数据字典 94
4.4.1  多租户数据库数据字典 94
4.4.2  PDB管理 96
4.5  与CDB相关的其他主题 101
4.5.1  删除CDB 102
4.5.2  删除PDB 102
4.5.3  克隆PDB以及插入和
卸下PDB 102
4.6  小结 102
第Ⅱ部分  RMAN配置、备份和
恢复基础知识
第5章  RMAN设置和配置 105
5.1  配置数据库以在ARCHIVELOG
模式运行 106
5.1.1  ARCHIVELOG目标目录 106
5.1.2  快速恢复区 108
5.1.3  是否应使用FRA 121
5.1.4  ARCHIVELOG模式之间的
切换 121
5.1.5  使用ODBCA创建数据库 122
5.2  Oracle Database 12c故障诊断
基础架构 124
5.2.1  ADR和相关的故障诊断
基础架构组件 124
5.2.2  配置故障诊断基础架构 129
5.3  RMAN命令行 131
5.3.1  通过RMAN命令行连接 131
5.3.2  退出RMAN客户端 136
5.4  为RMAN操作配置数据库 136
5.4.1  设置数据库用户 137
5.4.2  设置数据库安全性 139
5.4.3  设置CONTROL_FILE_
RECORD_KEEP_TIME
参数 140
5.5  配置RMAN默认设置 141
5.5.1  configure命令介绍 142
5.5.2  配置多种RMAN默认
设置 142
5.5.3  configure命令的使用
示例 143
5.5.4  使用共享服务器的情况 156
5.6  RMAN配置任务总结 157
5.7  其他备份和恢复设置与配置
问题 158
5.8  小结 158
第6章  RMAN恢复目录 159
6.1  恢复目录的含义 160
6.1.1  在非多租户数据库中创建
恢复目录拥有模式 162
6.1.2  在多租户数据库中创建
恢复目录拥有模式 164
6.1.3  创建恢复目录模式对象 167
6.1.4  使用RMAN虚拟私有
目录 170
6.2  合并多个恢复目录 173
6.3  RMAN存储脚本 174
6.3.1  创建存储脚本 175
6.3.2  在恢复目录中查询存储脚本
信息 175
6.3.3  修改存储脚本 175
6.3.4  删除存储脚本 176
6.3.5  使用存储脚本 176
6.3.6  打印存储脚本 176
6.4  维护恢复目录 177
6.4.1  取消RMAN中的数据库
注册 177
6.4.2  数据库迁移/升级问题 178
6.4.3  手动重新设置数据库
化身 178
6.4.4  手动执行恢复目录的重新
同步操作(resync catalog) 179
6.4.5  清除恢复目录记录 179
6.5  备份恢复目录 180
6.6  恢复目录视图 180
6.6.1  恢复目录视图和数据库数据
字典视图的目的 180
6.6.2  恢复目录基表、视图和数据
库数据字典视图 180
6.6.3  使用恢复目录基表和视图的
示例 183
6.6.4  为Oracle 企业管理器提供
的目录视图 186
6.7  小结 187
第7章  RMAN备份 189
7.1  使用RMAN Backup命令 190
7.1.1  Backup命令 190
7.1.2  Backup命令、信道和
性能 190
7.2  RMAN Backup命令选项 191
7.2.1  备份到特定设备类型 192
7.2.2  控制备份集和备份集片的
特性 192
7.2.3  多段备份 192
7.2.4  RMAN压缩 193
7.2.5  标记 197
7.2.6  还原点 198
7.2.7  使用duration参数设置
备份限制 198
7.2.8  归档的备份 199
7.2.9  重写configure exclude
命令 201
7.2.10  跳过脱机的、不可访问的或
只读的数据文件 201
7.2.11  重写备份优化 201
7.2.12  基于上次备份时间来备份
数据文件 202
7.2.13  在备份操作期间检查逻辑
损坏 203
7.2.14  在RMAN复制设备上生成
备份副本 203
7.2.15  捕获隐蔽的控制文件 204
7.3  使用RMAN set命令 204
7.4  脱机RMAN数据库备份 205
7.4.1  使用已配置的设置执行脱机
备份 205
7.4.2  分析实习的输出结果 210
7.4.3  不使用默认的设置执行脱机
备份操作 217
7.5  联机RMAN数据库备份 218
7.6  其他类型的RMAN联机
备份 221
7.6.1  表空间备份 221
7.6.2  数据文件备份 222
7.6.3  归档重做日志备份 223
7.6.4  控制文件和参数文件备份 224
7.6.5  备份集备份 224
7.6.6  快速恢复区备份 225
7.7  副本 226
7.7.1  映像副本 226
7.7.2  数据库、表空间和数据文件
的映像副本 226
7.7.3  控制文件副本 227
7.7.4  ARCHIVELOG映像副本 228
7.8  增量RMAN备份 228
7.8.1  块更改跟踪文件 229
7.8.2  基本备份 230
7.8.3  差异增量备份与累积增量
备份 230
7.9  增量更新备份 232
7.10  开始备份数据库 234
7.11  本章介绍的RMAN最佳
实践 237
7.12  小结 237
第8章   RMAN还原与恢复 239
8.1  RMAN还原与恢复基础 240
8.2  Oracle 数据库恢复的类型 241
8.3  关于还原多租户数据库 241
8.4  准备RMAN还原 241
8.5  暂存RMAN备份集片供还原
之用 242
8.5.1  还原SPFILE 243
8.5.2  还原控制文件 251
8.6  在NOARCHIVELOG模式中
还原和恢复数据库 255
8.6.1  还原的准备工作 255
8.6.2  在不同位置上还原数据库 259
8.7  在ARCHIVELOG模式中恢复
数据库 263
8.7.1  故障点数据库恢复 264
8.7.2  表空间恢复 272
8.7.3  数据文件恢复 273
8.7.4  使用增量备份的恢复操作 274
8.8  联机重做日志丢失的恢复 274
8.8.1  非活动的联机重做日志组
成员的丢失 275
8.8.2  非活动的联机重做日志组
的丢失 275
8.8.3  丢失活动但非当前状态的
联机重做日志组 277
8.8.4  丢失当前联机重做日志组 277
8.9  数据恢复顾问 277
8.9.1  通过RMAN使用数据恢复
顾问 277
8.9.2  DRA数据字典视图 283
8.10  小结 284
第9章  RMAN的高级恢复主题 285
9.1  恢复可插入数据库 286
9.1.1  恢复根容器 286
9.1.2  恢复种子容器 287
9.1.3  恢复PDB 288
9.2  在非CDB和整个CDB数据库
上执行不完全数据库恢复 291
9.2.1  不完全恢复的含义 292
9.2.2  不完全恢复的工作原理 292
9.2.3  创建恢复点 293
9.2.4  基于时间的恢复 294
9.2.5  基于SCN的恢复 294
9.2.6  基于更改的恢复 295
9.2.7  基于还原点的恢复 295
9.3  执行PDB的不完全恢复 296
9.3.1  关于PDB时间点恢复 296
9.3.2  与PDB时间点恢复相关的
限制和要求 297
9.3.3  基于时间恢复PDB 298
9.3.4  基于SCN恢复PDB 299
9.3.5  基于更改恢复PDB 301
9.3.6  基于还原点恢复 301
9.4  其他RMAN恢复主题 301
9.4.1  只读表空间的恢复 302
9.4.2  归档重做日志的还原 302
9.4.3  数据文件副本的还原 302
9.4.4  恢复受损的数据块 303
9.4.5  恢复到前一个化身 304
9.5  表和分区时间点恢复 306
9.5.1  还原和恢复数据库表及分区
的前提条件 306
9.5.2  还原和恢复数据库表及分区
的限制 307
9.5.3  还原表和分区时考虑的
选项 307
9.5.4  RMAN还原和恢复表及
分区的方式 308
9.5.5  从PDB还原表和分区 308
9.5.6  使用RMAN还原和恢复
数据库表的示例 308
9.6  表空间时间点恢复 311
9.6.1  为TSPITR做准备 311
9.6.2  执行实际的TSPITR 312
9.6.3  带有自动实例的自定义
自动TSPITR 313
9.7  小结 314
第10章  复制：克隆目标数据库 315
10.1  RMAN复制的基础知识 316
10.1.1  使用RMAN复制的
原因 316
10.1.2  RMAN复制的不同
类型 317
10.1.3  复制体系结构 318
10.2  复制的位置 323
10.2.1  复制到同一服务器 324
10.2.2  复制到同一服务器的不同
ORACLE_HOME目录 325
10.2.3  复制到远程服务器 325
10.2.4  复制和网络 328
10.3  在同一服务器上复制 331
10.4  复制到远程服务器 334
10.5  12c的无目标复制 336
10.6  12c中的新RMAN克隆
功能 338
10.6.1  使用压缩 339
10.6.2  复制大表空间 339
10.7  小结 340
第Ⅲ部分  RMAN维护与管理
第11章  RMAN维护 343
11.1  RMAN的维护 344
11.2  备份的验证 347
11.2.1  restore…preview命令 347
11.2.2  restore…validate和check
logical命令 348
11.2.3  使用validate命令 348
11.2.4  备份保留策略 349
11.2.5  归档日志保留策略 350
11.2.6  change命令 353
11.2.7  delete命令 357
11.2.8  在RMAN中为其他备份
编写目录 358
11.3  RMAN存储的脚本 359
11.3.1  创建存储的脚本 360
11.3.2  在恢复目录中查询存储的
脚本信息 360
11.3.3  修改存储的脚本 360
11.3.4  删除存储的脚本 360
11.3.5  使用存储的脚本 360
11.3.6  打印存储的脚本 361
11.4  删除数据库 362
11.5  小结 362
第12章  RMAN的监视和报告 363
12.1  RMAN的list命令 363
12.1.1  列出化身 364
12.1.2  列出备份 365
12.1.3  列出映像副本 373
12.1.4  列出还原点 376
12.1.5  列出DB_UNIQUE_
NAME 376
12.2  RMAN的report命令 377
12.2.1  报告最近没有被备份的
数据文件 377
12.2.2  报告备份冗余或恢复
窗口 377
12.2.3  报告数据文件的不可
恢复操作 378
12.2.4  报告数据库模式 378
12.2.5  报告过时的备份 379
12.3  用于报告的数据字典视图 380
12.4  小结 381
第13章  调整RMAN备份与恢复操作
的性能 383
13.1  调整RMAN前的工作 384
13.1.1  可达到的RMAN性能 384
13.1.2  使用合适的硬件 385
13.1.3  使用正确的备份策略 387
13.1.4  调整数据库 387
13.2  调整RMAN 389
13.2.1  调整RMAN设置 390
13.2.2  调整MML层 392
13.2.3  确认与数据库相关的
RMAN问题 393
13.3  跟踪RMAN会话 399
13.4  小结 400
第14章  使用Oracle Cloud Control
实现备份和恢复操作 401
14.1  EM12c体系结构 402
14.1.1  Oracle管理存储库 402
14.1.2  Oracle管理服务 402
14.1.3  Oracle管理代理 402
14.1.4  Cloud Control控制台 403
14.1.5  插件 404
14.2  安装和配置Enterprise Manager
Cloud Control 12c以进行数据
库备份 404
14.2.1  安装Enterprise Manager
代理 404
14.2.2  发现目标 405
14.3  使用EM12c配置备份和
恢复 407
14.4  使用EM12c备份数据库 411
14.4.1  调度Oracle建议的
备份 411
14.4.2  调度自定义备份 413
14.4.3  一次性备份多个
数据库 416
14.5  管理备份 418
14.6  备份报告 418
14.7  使用EM12c进行恢复 419
14.7.1  还原点 419
14.7.2  执行恢复 421
14.8  小结 423
第Ⅳ部分  高可用体系结构
中的RMAN
第15章  RMAN最佳实践 427
15.1  数据保护 428
15.1.1  企业体系结构 428
15.1.2  备份和恢复 429
15.1.3  高可用性 430
15.1.4  灾难恢复 431
15.1.5  数据监管和安全 431
15.1.6  监视和调度 432
15.2  最佳实践 433
15.2.1  服务级别协议 433
15.2.2  标准和过程 437
15.3  RMAN最佳实践 438
15.4  小结 439
第16章  从用户错误中恢复：
闪回技术 441
16.1  为不可避免的问题做准备：
闪回技术 442
16.2  闪回和撤销段的密切关系 443
16.3  闪回查询 444
16.4  闪回版本查询 444
16.5  闪回表 446
16.5.1  从SQL中执行闪回表
操作 446
16.5.2  在Oracle Enterprise
Manager中使用闪回表 447
16.6  闪回事务 447
16.7  闪回删除 448
16.8  闪回数据库 450
16.8.1  闪回日志 450
16.8.2  闪回保存目标 450
16.8.3  闪回数据库的优化和
调整 452
16.9  闪回数据归档(完全撤销) 453
16.10  小结 453
第17章  RMAN与Data Guard 455
17.1  备用数据库的类型 456
17.1.1  物理备用数据库 456
17.1.2  逻辑备用数据库 456
17.2  使用RMAN创建备用
数据库 456
17.3  准备创建备用数据库 457
17.3.1  确定命名约定 457
17.3.2  将数据库置于ARCHIVELOG
模式并强制启用日志记录
模式 458
17.3.3  设置数据库参数 459
17.3.4  创建辅助数据库口令
文件 460
17.3.5  配置Oracle Network 460
17.3.6  准备和启动辅助实例 463
17.3.7  启动RMAN 463
17.3.8  创建备用数据库 463
17.4  创建备用数据库之后 464
17.5  从备用数据库生成备份 470
17.6  其他RMAN和Data Guard
主题 471
17.6.1  使用RMAN从备用数据库还原丢失的数据文件、表空间或数据库 471
17.6.2  再同步备用数据库 471
17.7  从备用数据库备份归档
日志 472
17.8  小结 472
第18章  RMAN与Real Application
Clusters 473
18.1  RAC独特的备份问题 474
18.1.1  数据文件备份 475
18.1.2  归档日志备份 476
18.2  RAC恢复问题 478
18.2.1  还原操作 478
18.2.2  还原操作期间的介质
管理事项 479
18.2.3  还原操作后的恢复
问题 480
18.3  高级RMAN/RAC功能 481
18.3.1  复制到单节点系统 481
18.3.2  单节点上的备用
数据库 484
18.3.3  备份多节点RAC
数据库 486
18.4  小结 487
第19章  Zero Data Loss Recovery
Appliance：RMAN演变为企业级数据库保护解决方案 489
19.1  Zero Data Loss Recovery
Appliance概述 490
19.1.1  体系结构 491
19.1.2  受保护的数据库 491
19.1.3  增量推送 491
19.1.4  增量存储 493
19.1.5  复制 494
19.1.6  自动磁带归档 494
19.1.7  备份验证 495
19.2  保护策略 495
19.3  协作化空间管理 496
19.4  监视和管理 497
19.5  扩展硬件 498
19.6  小结 499
第20章  在实际工作中使用RMAN：
案例研究 501
20.1  恢复操作前的准备工作 502
20.1.1  故障的本质 502
20.1.2  可用的恢复选项 503
20.1.3  可能需要的Oracle
支持 503
20.1.4  在恢复操作期间寻求
帮助 503
20.2  恢复案例研究 504
20.3  小结 522
第Ⅴ部分  RMAN介质管理
第21章  介质管理问题 525
21.1  磁盘备份领域中的磁带
备份 526
21.2  RMAN和介质管理器概述 527
21.2.1  介质管理器目录 527
21.2.2  介质管理器的其他
软件组件 528
21.2.3  介质管理库 528
21.2.4  与MML交互 530
21.3  SBT API 530
21.4  磁带备份的全过程 531
21.5  磁带还原的全过程 532
21.6  使用sbttest和loadsbt.exe 532
21.7  介质管理错误 533
21.8  小结 534
第22章  Oracle安全备份 535
22.1  OSB的特性 536
22.1.1  OSB和恢复管理器 536
22.1.2  OSB和OSB Express的
区别 536
22.1.3  备份加密 537
22.1.4  快速数据库备份压缩 537
22.1.5  Oracle安全备份云
模块 537
22.2  OSB的接口 537
22.3  OSB的组件 538
22.3.1  OSB守护进程 539
22.3.2  主机访问模式 540
22.3.3  管理数据 540
22.3.4  OSB用户和类 541
22.3.5  操作系统账户 541
22.3.6  NDMP主机 542
22.3.7  OSB权限和类 542
22.4  安装与配置OSB 543
22.5  使用OSB备份Oracle数据库
及文件系统数据 554
22.6  使用OSB云模块备份Oracle
数据库 559
22.7  小结 562
第23章  使用OSB云模块将数据库备份
到 Amazon Web服务 563
23.1  传统备份：前提与限制 564
23.2  OSB云模块 564
23.3  云计算的含义 564
23.4  Oracle与Amazon云 565
23.4.1  弹性计算云(EC2)与
弹性块存储(EBS) 565
23.4.2  简单存储服务(S3)——
Oracle的云备份解决
方案 565
23.4.3  RMAN备份到S3：OSB
云模块 565
23.4.4  通过Internet备份到S3
或从Amazon EC2备份
到S3 566
23.5  Oracle云备份的优点 566
23.6  使用OSB云模块执行备份 568
23.6.1  永久存储S3作为默认
的SBT信道配置 569
23.6.2  每次分配信道时指定
OSB云模块 569
23.7  列出存储在S3中的RMAN
备份和备份集 570
23.7.1  通过Internet使用OSB
云模块和Amazon S3
优化备份与恢复 570
23.7.2  多个信道及压缩备份集的
示例 572
23.8  许可问题 572
23.9  小结 572
第24章  使用Oracle的Veritas NetBackup 增强RMAN 573
24.1  关键特性 574
24.2  必要的组件 574
24.3  存储/介质设备配置 575
24.4  NetBackup的安装 575
24.4.1  安装NetBackup for Oracle
代理之前的任务 576
24.4.2  NetBackup for Oracle
代理安装步骤 576
24.5  链接Oracle与NetBackup介质
管理器的方法 577
24.5.1  自动链接方法 577
24.5.2  手动链接方法 578
24.6  体系结构 579
24.7  配置NetBackup策略 580
24.7.1  添加新策略 580
24.7.2  定义时间表 583
24.7.3  定义备份选项 585
24.7.4  定义策略客户端 586
24.8  管理到期的备份映像 587
24.8.1  使用NetBackup存储库
删除到期的备份 587
24.8.2  使用RMAN删除到期的
备份 587
24.9  RMAN示例脚本 588
24.10  故障诊断 589
24.10.1  使用NetBackup
日志 589
24.10.2  确定正在使用的库 590
24.11  维护安全的最佳方法 590
24.12  成本调整 590
24.13  小结 591
第25章  配置Oracle的HP Data
Protector 593
25.1  集成Oracle与Data
Protector 594
25.1.1  支持矩阵 594
25.1.2  集成组件 594
25.1.3  集成限制 595
25.2  在Data Protector上配置
RMAN备份 598
25.3  RMAN备份 605
25.3.1  备份方法 605
25.3.2  备份过程 606
25.4  使用Data Protector GUI
还原Oracle数据库 606
25.4.1  还原控制文件 607
25.4.2  还原Oracle 数据库
对象 608
25.5  Oracle RMAN 元数据与Data
Protector 介质管理数据库
同步 609
25.6  小结 609
第26章  RMAN和Tivoli Storage
Manager 611
26.1  Tivoli Storage Manager
概述 612
26.1.1  TSM服务器系统对象 613
26.1.2  TSM客户端 614
26.2  使用TDPO完成RMAN
备份 618
26.3  删除数据库备份 623
26.4  公共备份场景的故障诊断 623
26.5  小结 625
第27章  RMAN和CommVault
Simpana 627
27.1  Simpana简介 628
27.1.1  安装 628
27.1.2  数据保留期 630
27.1.3  调度策略 630
27.2  CommVault Oracle iDA的
含义 631
27.2.1  配置Oracle 实例 632
27.2.2  配置子客户端 634
27.3  初始化备份 635
27.4  还原 637
27.5  高级配置 638
27.6  RMAN接口 641
27.7  排除故障 641
27.8  小结 643
第Ⅵ部分  附    录
附录A  RMAN脚本示例 647
A.1  用于Windows的RMAN
脚本 648
A.1.1  创建Windows脚本以
调度备份 648
A.1.2  调度备份 649
A.2  用于Unix的RMAN脚本 649
附录B  创建RMAN测试环境 651
B.1  测试机器 652
B.1.1  匹配生产环境 653
B.1.2  节省成本是需要付出
代价的 653
B.2  Oracle配置 653
B.2.1  多个主目录 654
B.2.2  创建数据库 654
B.3  RMAN配置 654
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 12c Oracle RMAN备份与恢复（第4版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8数据库管理员手册
目录
译者序
作者序
第一部分 数据库体系结构
第1章 Oracle体系结构
1.1数据库概述及实例
1.2数据库
1.2.1表空间（Tablespace）
1.2.2文件（File）
1.3实例 （Instance）
1.4数据库内部结构
1.4.1表、列及数据类型（Table
Column，Datatype）
1.4.2约束条件
1.4.3抽象数据类（Abstract
Datatype）
1.4.4分区（Partition）
1.4.5用户（user）
1.4.6模式（schema）
1.4.7索引 （Indexe）
1.4.8簇（cluster）
1.4.9散列簇（HashClusters）
1.4.10视图（View）
1.4.11 序列（Sequence）
1.4.12 过程（procedure）
1.4.13 函数（Function）
1.4.14包（Package）
1.4.15触发器（Trigger）
1.4.16同义词 （Synonyms）
1.4.17权限及角色（Privilege，
Role）
1.4.18数据库链接（Database
Link）
1.4.19段、范围及块（Segment， Extent，
Block）
1.4.20 回滚段（RollbackSegment）
1.5内部存储结构
1.5.1系统全局区（SystemGlobal
Area，SGA）
1.5.2 正文区域（ContextArea）
1.5.3程序全局区（Program
GlobalArea， PGA ）
1.6后台进程（BackgroundProcesses）
1.7外部结构（ExternalStructure）
1.7.1日志文件（RedoLog）
1.7.2控制文件（ControlFile）
1.7.3跟踪文件与修改日志（Trace
FileandtheAlertLog）
1.8数据库的基本实现
1.8.1备份/恢复功能（Backup/
RecoveryCapability）
1.8.2安全性能
1.8.3典型数据库逻辑设计
1.8.4典型数据库物理设计
1.9逻辑模式规则
1.9.1 一对一关联
1.9.2 一对多关联
1.9.3多对多关联
第2章 硬件配置研究
2.1结构概述
2.2独立宿主（Stand－AloneHost）
2.2.1磁盘阵列独立宿主（Stand－Alone
HostswithDiskArray）
2.2.2磁盘映像独立宿主（Stand－Alone
HostswithDiskShadowing）
2.2.3多数据库的独立宿主（Stand－Alone
HostsswithMultipleDatabase）
2.3网络宿主
2.3.1数据库网络（Networkof
Database）
2.3.2远程更新：高级复制选项（Advanced
ReplicationOption）
2.3.3服务器簇：Oracle并行服务器
（ParallelServer）
2.3.4多处理器：并行查询（Parallel
Query）与并行装载（Parallel
Load）选项
2.3.5客户/服务器数据库应用
第3章 数据库逻辑设计
3.1最终产品
3.2优化结构（OptimalFlexible
Architecture，OFA）
3.2.1起点：系统表空间（System
Tablespace）
3.2.2分离应用程序数据段：DATA
3.2.3分离应用程序索引段：
INDEXES
3.2.4分离工具段：TOOLS
3.2.5分离回滚段：RBS
3.2.6分离临时段：TEMP
3.2.7分离用户：USERS
3.3OFA扩展
3.3.1分离低使用（Low－Usage）数据段：
DATA＿2
3.3.2分离低使用 （LowUsage）索引段：
INDEXES2
3.3.3分离工具索引：TOOLS－1
3.3.4分离特殊回滚段：RBS－2
3.3.5分离特殊用户临时段：
TEMP USER
3.3.6附加的特殊应用OFA扩展
3.4普通意义的逻辑设计
第4章 数据库物理设计
4.1数据库文件设计
4.1.1数据文件间的I/O冲突
4.1.2所有数据文件中的I/O
瓶颈
4.1.3后台进程中并发的I/O
4.1.4定义系统恢复能力与性能
目标
4.1.5系统硬件的定义及结构镜像
4.1.6确定数据库磁盘
4.1.7选择正确的设计
4.2I/O量估计的校验
4.3文件放置
4.4数据库空间使用概述
4.4.1storage参数意义
4.4.2Table段
4.4.3Index段
4.4.4Rollback段
4.4.5Temporary段
4.4.6自由空间 （FreeSpace）
4.5重新确定Oracle7.2及更高版本中
的数据文件大小
4.6数据文件的移动
4.6.1移动数据库文件（Moving
Datafile）
4.6.2移动联机日志文件（MovingOnline
RedoLogFile）
4.6.3移动控制文件（Moving
ControlFile）
4.7Oracle7.2及Oracle7.3的空间
管理
4.7.1数据文件收缩（Shrinking
Datafile）
4.7.2数据表、簇、索引的收缩（Shrinking
TableClusterIndexes）
4.7.3重建索引（RebuildIndexes）
4.7.4物理条件的满足（PhysicallyFit）
第二部分 数据库管理
第5章 开发过程管理
5.1成功的三要素
5.2培植（cultural）过程
5.3管理（management）过程
5.3.1定义环境（Definingthe
Environment）
5.3.2角色的定义（RoleDefirition）
5.3.3方案报告（Deliverable）
5.3.4确定数据库对象的尺寸（Sizing
Data base Objects）
5.3.5迭代（Iterative）开发
5.4技术方法
5.4.1CASE 工具
5.4.2共享路径（shared
Directory）
5.4.3项目管理数据库
5.4.4讨论数据库
5.5管理包的开发
5.5.1生成图表
5.5.2空间需求
5.5.3协调目标
5.5.4安全需求
5.5.5数据需求
5.5.6执行规划
5.5.7验收测试进程
5.6管理环境
第6章 监控多数据库
6.1普通问题领域
6.1.1超出表空间中的自由空间
6.1.2缺乏临时段空间
6.1.3达到扩展极限的回滚段
6.1.4数据段碎片
6.1.5自由空间碎片
6.1.6不合适的SGA大小
6.2目标选择
6.3最终产品
6.4建立中央命令数据库
6.4.1数据获取
6.4.2产生警报报告（Alert
Report）
6.4.3空间摘要报告
6.4.4数据过滤
6.5监控内存对象
6.5.1UTLBSTAT及UTLESTAT的
必要修改
6.5.2统计报告解释
6.5.3统计报告的扩展
6.6良好管理的数据库
第7章 回滚段管理
7.1回滚段概述
7.1.1数据库对回滚段的使用
7.1.2激活回滚段
7.1.3为事务处理指定回滚段
7.2回滚段的空间使用
7.2.1存储优化
7.3监控回滚段使用
7.3.1监控当前空间分配
7.3.2回滚段收缩
7.3.3监控当前状态
7.3.4监控动态扩展
7.3.5回滚段中的事务
7.3.6回滚段中的数据
7.4选择回滚段的数量和大小
7.4.1事务项
7.4.2事务数量
7.4.3确定优化值
7.4.4建立回滚段
7.4.5回滚段数据装载及结果
第8章 数据库的协调
8.1协调应用程序设计
8.1.1有效的表设计
8.1.2分配CPU请求
8.1.3有效进行应用设计
8.2协调SQL
8.3协调内存
8.4数据存储的协调
8.4.1段的碎片整理
8.4.2自由范围的碎片整理
8.4.3行链接
8.4.4增加Oracle块尺寸
8.5协调数据库操作
8.5.1大量数据的插入：使用SQLLoader
DirectPath选项
8.5.2大量数据的删除：truncate
命令
8.6协调物理存储
8.6.1整理文件碎片
8.6.2使用RawDevices
8.7逻辑存储的协调
8.8减少网络访问
8.8.1数据复制
8.8.2使用远程进程调用
第9章 数据库安全与审计
9.1安全性能
9.1.1帐户安全性
9.1.2对象权限
9.1.3系统级角色和权限
9.2实现安全性
9.2.1操作系统安全性
9.2.2建立用户
9.2.3删除用户
9.2.4系统级权限
9.2.5用户环境文件
9.2.6口令管理
9.2.7防止口令重使用
9.2.8设置口令组合
9.2.9数据库帐户与主机帐户相连
9.2.10口令保护
9.2.11对象级权限
9.2.12 列表权限
9.3限制可用命令：产品用户环境
文件
9.4注册期间的口令安全
9.5口令编码与技巧
9.5.1口令是怎样存储的
9.5.2设置不存在的口令
9.5.3变成另一个用户
9.6审计
9.6.1审计注册
9.6.2操作审计
9.6.3对象审计
9.7保护审计踪迹
9.8分布环境的安全性
第10章 优化备份和恢复过程
10.1特性
10.2逻辑备份
10.2.1输出 （Export）
10.2.2输入（Import）
10.3物理备份
10.3.1脱机备份
10.3.2联机（ARCHIVELOG）
备份
10.4执行
10.4.1输出
10.4.2输入
10.4.3脱机备份
10.4.4联机备份
10.4.5备用数据库
10.5集成备份过程
10.5.1集成逻辑和物理备份
10.5.2集成数据库和操作系统备份
10.6使用恢复过程的恢复情形
10.6.1实例失败（InotanceFailure）
10.6.2媒体（磁盘disk）失败（Media
Failure）
10.6.3意外删除或修改对象的
恢复
10.6.4并行恢复
10.6.5恢复管理器
第11章 管理Oracle财务和其他软件包
及实用程序
11.1软件包的通用管理准则
11.1.1协调数据库结构
11.1.2安全与数据存取控制
11.1.3事务管理
11.1.4文件定位
11.1.5监控
11.1.6版本的考虑
11.1.7DBA的作用
11.2管理Oracle财务软件包的
特殊准则
11.2.1库结构
11.2.2数据库的存取
11.2.3并发管理器
11.2.4演示数据库
11.2.5版本
11.2.6文件定位
11.2.7init.ora参数
11.3管理Designer/2000的特殊准则
11.3.1数据库结构
11.3.2init.ora参数
11.3.3最活跃的表和索引
11.3.4优化器
11.4管理其他包和实用工具
11.4.1ConText
11.4.2Export
11.4.3SQL装载
11.4.4程序接口
11.4.5在SQL*Plus中使用PRODUCT
USER＿PROFILE
第12章 大数据库管理
12.1设置环境
12.1.1大数据库容量
12.1.2设置支持区大小
12.1.3选择物理设计
12.1.4分区
12.1.5建立完全索引表
12.1.6唯一索引表（Index－OnlyTable）
建立及管理
12.1.7建立和管理位图索引
12.2事务管理
12.2.1设置批量事务环境
12.2.2装载数据
12.2.3插入数据
12.2.4删除数据
12.3备份
12.3.1备份需求及方式
12.3.2备份方案
12.4协调
12.4.1协调大表查询
第三部分 网络ORACLE
第13章 SQL NetV2及Net8
13.1SQL NetV2及Net8概述
13.1.1连接描述器
13.1.2服务名
13.1.3监听器（Listener）
13.2使用Net8 Assistant
13.2.1多协议交换（Multiprotocol
Interchange）
13.2.2使用连接管理器（Connection
Manager）
13.2.3使用Oracle名称（Oracle
Name）
13.3应用样例：客户－服务器应用
13.4应用样例：数据库链接
13.5应用实例：拷贝命令
13.6协调SQL Net及Net8
第14章 UNIX上的联网技术
14.1宿主的识别
14.2数据库的识别
14.3服务的识别
14.4启动监听服务器进程
14.5控制监听服务器进程
14.6调试连接问题
第15章 分布式数据库管理
15.1分布数据库概述
15.1.1远程查询
15.1.2远程数据管理：TWO Phase
Commit
15.1.3动态数据复制
15.2分布式数据管理
15.2.1基础结构：位置透明化
15.2.2数据库链接管理
15.2.3数据库触发器管理
15.2.4快照管理
15.2.5选择刷新类型
15.2.6快照的脱机实例
15.2.7净化快照日志
15.3管理分布式事务
15.3.1解决不确定事务
15.4数据库域（Domain）和群
（Community）
15.5监控分布式数据库
15.6协调分布式数据库
15.7使用作业队列
第16章 配置客户服务器和网络
计算机环境
16.1客户－服务器处理概述
16.2配置服务器
16.2.1识别可用宿主
16.2.2识别可用的服务
16.2.3识别可用数据库
16.2.4启动SQL Net
16.3配置客户机
16.3.1识别可用宿主
16.3.2识别可用服务
16.3.3客户机说明
16.3.4运行SQL Net
16.4关于网络计算机配置
第四部分 附录
附录A Oracle7到Oracle8的移植
A.1安装Oracle8
A.1.1init.ora文件在何处
A.1.2警报日志文件在何处
A.1.3用户输出文件在何处
A.1.4过时和修改的init.ora参数
A.1.5过时的sqlnet.ora参数
A.1.6过时的ensnamesora和
listener.ora参数
A.1.7过时的Net8参数文件
A.2 如何移植
A.2.1 使用输出/输入方法
A.2.2 使用移植工具（Migration
Utility）
A.3 RowID的变动
A.3.1 什么是 ObjectID 值
A.3.2 将 RowID转换成严格格式
A.3.3 行在什么文件中
A.3.4 行在哪个块中
A.3.5 行的序列号是什么
A.3.6 管理口令
A.3.7 分区 （Partition）
A.3.8 大型对象 （LOB）
A.3.9 禁止日志子句
A.3.10 管理抽象数据类型
A.4 企业管理器
附录 B 管理企业管理器
B.1 OEM的独特性能
B.1.1 恢复管理器
B.1.2 性能封装软件包及 Oracle
跟踪工具
B.2 数据仓库管理
B.3 远程安全管理
B.4 配置文件管理
附录C DBA的SQL命令参考
C.1 ALTERDATABASE
C.2 ALTERINDEX
C.3 ALTERPROFILE
C.4 ALTERROLE
C.5 ALTERROLLBACKSEGMENT
C.6 ALTERSYST EM
C.7 ALTERTABLE
C.8 ALTERTABLESPACE
C.9 ALTERUSER
C.10 ANALYZE
C.11 ARCHIVELOG子句
C.12 AUDIT （SQL语句）
C.13 AUDIT（模式对象）
C.14 CREATECONTROLFILE
C.15 CREATEDATABASE
C.16 CREATEDATABASELINK
C.17 CREATEINDEX
C.18 CREATEPROFILE
C.19 CREATEROLE
C.20 CR EATERO）LLBACKSEGMENT
C.21 CREATESYNONYM
C.22 CREATETABLE
C.23 CREATETABLESPACE
C.24 CREATEUSER
C.25 EXPLAINPLAN
C.26 Filespec
C.27 GRANT（系统权限和角色）
C.28 GRANT（对象权限）
C.29 NOAUDIT（SQL语句）
C.30 NOAUDIT（模式对象）
C.31 RECOVER子句
C.32 STORAGE子句
C.33 TRUNCATE

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8数据库管理员手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle企业管理器基础教程
序
前言
第一部分 Oracle企业管理器简介
第1章 什么是企业管理器
第2章 安装EM的组件
第二部分 EM控制台组件
第3章 EM控制台简介
第4章 作业、事件、组和报表概念
第5章 控制台中的配置选项
……
第三部分 使用EM
第8章 发现Oracle环境
第9章 配置EM环境
……
第四部分 其他有用的信息
第19章 命令行实用程序
第20章 故障检测

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle企业管理器基础教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8 学习教程
第1章 数据库基本概念
1.1

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8 学习教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 9iAS J2EE应用程序开发
第一部分 概述
第一章 J2EE 介绍
第二章 Oracle9i J2EE应用服务器容器（OC4J）概述
第三章 OC4H服务概述
第二部分 构建 J2EE业务层组件
第四章 介绍 Enterprise JavaBean（EJB）
第五章 实体Bean的开发
第六章 会话Bean的开发
第七章 EJB消息驱动型 Bean的开发
第三部分 构建J2EE Web和表示层组件
第八章 OC4J安全性
第九章 Web服务：SOAP，WSDL和UDDI
第十章 开发Web应用程序
第一十章 JSP介绍
第四部分 附录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 9iAS J2EE应用程序开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Oracle核心技术与项目实战
第１篇　Oracle基础篇
第1章　Oracle的安装	1
1.1  Oracle数据库简介	1
1.1.1  数据库术语	1
1.1.2  主流数据库简介	2
1.1.3  Oracle数据库的特点	2
1.2  安装Oracle数据库	3
1.2.1  Oracle数据库的版本变迁及安装环境	3
1.2.2  下载Oracle安装文件	4
1.2.3  安装过程	6
1.2.4  安装中需要注意的问题	11
1.3  小结	11
第2章  Oracle常用工具	12
2.1  Oracle企业管理器	12
2.1.1  Oracle企业管理器概述	12
2.1.2  使用Oracle企业管理器	13
2.2  网络配置助手（Net Configuration Assistant）	14
2.2.1  Net Configuration Assistant概述	14
2.2.2  配置监听程序	14
2.2.3  配置本地网络服务器名	16
2.3  网络管理器（Oracle Net Manager）	19
2.3.1  Oracle Net Manager概述	19
2.3.2  监听器配置（LISTENER）	20
2.3.3  本地服务名配置	21
2.4  小结	23
第3章  SQL Plus和SQL Developer	24
3.1  使用SQL Plus	24
3.1.1  登录SQL Plus	24
3.1.2  利用SQL Plus执行数据库操作	25
3.1.3  利用SQL Plus解决数据库管理员密码丢失问题	25
3.2  使用SQL Developer	26
3.2.1  登录SQL Developer	26
3.2.2  SQL Developer操作简介	27
3.3  小结	27
第4章  Oracle数据库	28
4.1  创建Oracle数据库	28
4.2  删除Oracle数据库	34
4.2.1  删除数据库	34
4.2.2  修改注册表	36
4.3  安装示例数据库	37
4.4  小结	40
第5章  Oracle数据类型与表的管理	41
5.1  Oracle常用的数据类型	41
5.2  创建Oracle数据表	42
5.2.1  设计数据表	42
5.2.2  利用OEM创建数据表	43
5.2.3  利用工具创建数据表	48
5.2.4  利用命令创建数据表	49
5.3  修改数据表结构	50
5.3.1  利用OEM修改数据表结构	51
5.3.2  利用工具修改数据表结构	53
5.3.3  利用命令查看、修改数据表结构	53
5.4  删除数据表	55
5.4.1  利用OEM删除数据表	55
5.4.2  利用工具删除数据表	56
5.4.3  利用drop命令删除数据表	56
5.5  对数据表中数据的操作	57
5.5.1  添加数据	57
5.5.2  查看数据	58
5.5.3  修改数据	60
5.5.4  删除数据	61
5.6  特殊的数据表dual	61
5.7  小结	62
第6章  表的约束	63
6.1  约束简介	63
6.2  主键约束	63
6.2.1  主键简介	64
6.2.2  利用命令添加主键约束	64
6.2.3  主键使用场景	66
6.2.4  修改主键约束	67
6.2.5  删除主键约束	70
6.2.6  主键与索引	71
6.3  外键约束	73
6.3.1  外键简介	73
6.3.2 添加外键约束	74
6.3.3  验证外键约束	76
6.3.4  修改外键约束	78
6.3.5  使用SQL Developer添加、删除外键约束	80
6.3.6  外键使用场景	80
6.4  唯一性约束	81
6.4.1  唯一性约束简介	81
6.4.2  添加唯一性约束	82
6.4.3  验证唯一性约束	83
6.4.4  修改唯一性约束	83
6.4.5  使用SQL Developer添加、删除唯一性约束	85
6.4.6  唯一性约束使用场景	86
6.5  检查约束	86
6.5.1  检查约束简介	86
6.5.2  添加检查约束	87
6.5.3  验证检查约束	88
6.5.4  修改检查约束	89
6.5.5  使用SQL Developer添加、删除检查约束	91
6.5.6  检查约束使用场景	91
6.6  非空约束	91
6.6.1  为列添加非空约束	91
6.6.2  撤销非空约束	93
6.7  默认约束	94
6.7.1  为列添加默认（default）约束	94
6.7.2  删除默认（default）约束	96
6.8  小结	97
第2篇　Oracle查询篇
第7章　数据查询	98
7.1  基本查询	98
7.1.1  select语句查询执行步骤	98
7.1.2  为列设置别名	99
7.1.3  利用distinct获得唯一性记录	100
7.1.4  返回查询的部分结果	101
7.2  简单条件查询	101
7.2.1  where子句	102
7.2.2  在查询中使用比较表达式	103
7.2.3  使用简单逻辑表达式	104
7.2.4  指定数据范围	105
7.2.5  有关null值判断	107
7.2.6  like进行模糊查询	107
7.2.7  order by子句	109
7.2.8  group by子句	111
7.2.9  having子句	112
7.3  小结	114
第8章  高级查询	115
8.1  连接简介	115
8.1.1  连接的定义	115
8.1.2  连接的类型	115
8.1.3  简单的多表查询	116
8.2  表的连接查询	118
8.2.1  自然连接	118
8.2.2  内连接	120
8.2.3  外连接	122
8.3  单表中的联合语句	125
8.3.1  union查询	125
8.3.2  union all查询	126
8.3.3  intersect查询	127
8.3.4  minus查询	128
8.4  子查询	128
8.4.1  理解子查询	128
8.4.2  子查询的使用	129
8.4.3  子查询的使用方式及限制	130
8.5  查询语句优化	135
8.5.1  在查询中尽量不使用“*”	136
8.5.2  多表查询中尽量使用表别名	136
8.5.3  条件查询多使用where	136
8.5.4  指定查询范围多使用in	136
8.5.5  子查询中多使用exists语句判断条件	136
8.6  小结	137
第9章  常用函数	138
9.1  聚合函数	138
9.1.1  计数函数count()	138
9.1.2  求和函数sum()	140
9.1.3  均值函数avg()	141
9.1.4  最大值max()和最小值min()	142
9.2  数学函数	143
9.2.1  Oracle中的数值型	143
9.2.2  绝对值、取余、判断数值正负	144
9.2.3  近似值函数、截取、取整函数	145
9.2.4  平方根、乘方运算函数	149
9.2.5  格式化数值——to_char()函数	150
9.3  字符串函数	153
9.3.1  字符型简介	154
9.3.2  删除空格	154
9.3.3  求字符串长度函数	155
9.3.4  字符转换函数	156
9.3.5  连接字符串	159
9.3.6  检索字符串、取子串函数	161
9.4  日期函数	166
9.4.1  获取日期和时间的函数	166
9.4.2  日期和时间差的函数	170
9.5  转换函数	172
9.5.1  类型转换——cast()函数	173
9.5.2  将数值或日期转换为字符串——to_char()函数	173
9.5.3  字符转数值——to_number()函数	175
9.5.4  字符转日期——to_date()函数	176
9.6  null函数	177
9.7  小结	177
第10章  索引	178
10.1  索引简介	178
10.2  索引的创建	178
10.2.1  何时创建索引	178
10.2.2  使用工具创建索引	179
10.2.3  使用OEM创建索引	180
10.2.4  使用语句创建索引	182
10.2.5  创建索引的注意事项	184
10.3  索引的管理	184
10.3.1  修改索引	184
10.3.2  删除索引	189
10.4  小结	192
第11章  视图	193
11.1  Oracle视图	193
11.1.1  视图的概念	193
11.1.2  视图的作用	193
11.1.3  视图的分类	194
11.2  关系视图的创建和使用	194
11.2.1  使用语句创建视图	194
11.2.2  使用SQL Developer创建视图	202
11.2.3  使用OEM创建视图	204
11.2.4  查看及操作访问视图	206
11.2.5  使用SQL Developer工具访问视图	212
11.3  内嵌视图的创建和使用	215
11.4  视图的修改	216
11.4.1  使用语句修改视图	216
11.4.2  使用SQL Developer工具修改视图	217
11.4.3  使用OEM修改视图	218
11.5  视图的删除	220
11.5.1  使用语句删除视图	220
11.5.2  使用SQL Developer 工具删除视图	221
11.5.3  使用OEM删除视图	221
11.6  小结	222
第3篇　PL/SQL编程篇
第12章　Oracle编程基础	223
12.1  PL/SQL简介	223
12.1.1  PL/SQL基本结构	223
12.1.2  PL/SQL注释	225
12.1.3  PL/SQL基本规则	225
12.1.4  PL/SQL数据类型	226
12.1.5  PL/SQL运算符	227
12.1.6  PL/SQL表达式	229
12.1.7  PL/SQL中变量、常量的定义与使用	230
12.2  PL/SQL中定义类型	233
12.2.1  记录类型	233
12.2.2  集合类型	235
12.3  Oracle中的条件控制语句	238
12.3.1  流程控制——if else判断	238
12.3.2  流程控制——case when分支	241
12.4  Oracle中的循环语句	245
12.4.1  无条件循环	245
12.4.2  while循环	247
12.4.3  for循环	248
12.5  小结	250
第13章  游标	251
13.1  什么是游标	251
13.1.1  游标概念	251
13.1.2  游标种类	252
13.2  显式游标	252
13.2.1  创建显式游标步骤	252
13.2.2  游标中的loop语句	256
13.2.3  使用bulk collect和for语句的游标	258
13.2.4  使用for loop语句	260
13.2.5  为游标传递参数	262
13.2.6  显式游标的属性	263
13.3  隐式游标	266
13.3.1  隐式游标的特点	266
13.3.2  隐式游标的属性	267
13.3.3  使用SQL隐式游标	268
13.3.4  使用cursor for隐式游标	268
13.4  动态（REF）游标	269
13.4.1  强类型动态游标	270
13.4.2  弱类型动态游标	272
13.5  小结	273
第14章  存储过程	274
14.1  存储过程简介	274
14.1.1  认识存储过程	274
14.1.2  存储过程的作用	274
14.2  创建和执行存储过程	275
14.2.1  创建存储过程	275
14.2.2  有参数的存储过程	279
14.2.3  in参数	280
14.2.4  out参数	284
14.2.5  in out参数	286
14.3  SQL Developer工具创建存储过程	287
14.3.1  创建存储过程	287
14.3.2  调试存储过程	288
14.4  管理存储过程	290
14.4.1  修改存储过程	290
14.4.2  重新编译存储过程	291
14.4.3  删除存储过程	292
14.5  小结	293
第15章  函数和程序包	294
15.1  自定义函数	294
15.1.1  创建自定义函数	294
15.1.2  带参数的函数	297
15.1.3  行转列函数	301
15.1.4  使用SQL Developer创建函数	303
15.1.5  管理函数	305
15.2  程序包	306
15.2.1  程序包说明	306
15.2.2  程序包主体	308
15.2.3  调用程序包中的函数/存储过程	309
15.2.4  删除程序包	309
15.3  小结	309
第16章  触发器	310
16.1  触发器简介	310
16.1.1  认识触发器	310
16.1.2  触发器类型	310
16.1.3  触发器的作用	311
16.2  DML触发器	311
16.3  语句级触发器	313
16.3.1  创建语句级触发器	314
16.3.2  触发器的作用对象与类型	316
16.3.3  多个激活动作	317
16.3.4  触发器谓词	318
16.4  行触发器	322
16.4.1  创建和使用行触发器	323
16.4.2  行触发器的变量引用	326
16.4.3  变量引用与referencing	330
16.4.4  触发器的执行顺序	331
16.4.5  触发器的条件限制	331
16.5  instead of触发器	333
16.5.1  instead of触发器简介	333
16.5.2  创建和使用instead of触发器	334
16.6  DDL触发器	338
16.7  系统事件与用户事件触发器	339
16.7.1  系统事件触发器	339
16.7.2  用户事件触发器	341
16.8  使用SQL Developer工具操作触发器	344
16.9  管理触发器	346
16.9.1  查看触发器	346
16.9.2  设置触发器是否可用	347
16.10  小结	349
第17章  序列	350
17.1  自动生成序号	350
17.2  创建和使用序列	350
17.2.1  创建序列	350
17.2.2  使用序列	352
17.3  序列属性	357
17.3.1  创建序列的注意事项	358
17.3.2  指定序列初始值	358
17.3.3  序列的最大值和最小值	359
17.3.4  序列的增长步长	360
17.3.5  序列循环取值	363
17.3.6  序列缓存大小	364
17.4  小结	367
第18章  事务和锁	368
18.1  什么是事务	368
18.1.1  事务概述	368
18.1.2  事务的ACID特性	369
18.1.3  事务类型	369
18.1.4  事务的状态	370
18.1.5  提交事务	371
18.1.6  事务的保存点	373
18.2  锁	376
18.2.1  并发访问的常见问题	376
18.2.2  锁概述	377
18.2.3  锁分类	377
18.2.4  锁等待和死锁	377
18.2.5  预防死锁	382
18.3  小结	382
第4篇　Oracle维护篇
第19章  表空间管理	383
19.1  Oracle 11g的基础结构	383
19.1.1  模式	383
19.1.2  存储结构	384
19.1.3  表空间相关概念	384
19.2  表空间管理	385
19.2.1  查看表空间	385
19.2.2  创建表空间	389
19.2.3  重命名表空间	392
19.2.4  设置表空间的状态	393
19.3  合理利用表空间	394
19.3.1  处理空间不足的情况	394
19.3.2  正确的数据类型	398
19.3.3  回收利用表空间	398
19.4  小结	400
第20章  数据库安全管理	401
20.1  Oracle数据库安全性概述	401
20.2  用户	401
20.2.1  用户简介	401
20.2.2  创建用户	402
20.2.3  用户管理	406
20.3  权限	408
20.3.1  权限简介	408
20.3.2  授予系统权限	411
20.3.3  授予对象权限	414
20.3.4  权限的传递	418
20.3.5  收回对象的权限	420
20.3.6  用户和权限	423
20.4  角色	423
20.4.1  角色简介	424
20.4.2  创建角色	424
20.4.3  为角色授权	426
20.4.4  将一个角色授予另一个角色	428
20.4.5  为用户授予角色	429
20.4.6  禁用和启用角色	430
20.4.7  撤销角色权限	432
20.4.8  删除角色	432
20.5  概要文件	433
20.5.1  创建概要文件	433
20.5.2  概要文件管理	436
20.6  小结	437
第21章  备份与恢复	438
21.1  备份与恢复简介	438
21.1.1  备份	438
21.1.2  恢复	438
21.2  逻辑备份与恢复	438
21.2.1  使用expdp和impdp工具进行逻辑备份恢复	438
21.2.2  使用OEM进行逻辑备份恢复	441
21.3  脱机备份	449
21.3.1  脱机备份	449
21.3.2  脱机恢复	450
21.4  联机备份恢复	450
21.4.1  使用RAMN	450
21.4.2  备份恢复	453
21.5  小结	455
第22章  控制文件和日志文件	456
22.1  控制文件	456
22.1.1  控制文件概述	456
22.1.2  查询控制文件	456
22.1.3  创建控制文件	457
22.2  日志文件	459
22.2.1  日志文件概述	459
22.2.2  创建日志组和日志文件	460
22.2.3  查询日志文件组和日志文件	461
22.3  小结	462
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Oracle核心技术与项目实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库管理与维护实战
第一篇　数据库体系结构
第1章　Oracle产品系列
1.1　Oracle产品组成
1.1.1　数据库组件
?
1.1.2　开发套件
1.1.3　应用服务器
1.1.4　协作套件
1.1.5　应用软件
1.2　Oracle各版本异同
1.2.1　Oracle.8i和Oracle.9i
1.2.2　Oracle.10g和Oracle.11g
1.2.3　Oracle.12c
1.2.4　Oracle企业版、标准版及其他版本的异同
1.3　Oracle.12c新特性
1.3.1　支持多线程模式
1.3.2　加强Defaults功能
1.3.3　更新了多种数据类型长度限制
1.3.4　增强PL/SQL性能
1.3.5　实现Native.TOP.N查询
1.3.6　加强行模式匹配
1.3.7　增加Adaptive.Plans
1.3.8　改进分区特性
1.3.9　增强数据优化
1.3.10　加强应用连续性
1.3.11　引入临时UNDO段
1.3.12　支持PDB
1.3.13　提供CDB容器
1.3.14　支持表级别恢复
1.3.15　支持网络恢复
1.3.16　增添了Flex.ASM
第2章　Oracle体系结构及其基本概念
2.1　Oracle总体结构
2.1.1　Oracle实例
2.1.2　数据库
2.1.3　Oracle相关的几个概念
2.1.4　Oracle的结构划分
2.2　Oracle内存结构
2.2.1　系统全局区SGA
2.2.2　数据库缓冲区
2.2.3　重做日志缓冲区
2.2.4　共享池
2.2.5　数据字典缓冲区
2.2.6　程序全局区PGA
2.2.7　排序区
2.2.8　软件代码区
2.2.9　大池
2.2.10　Java池
2.2.11　Streams池
2.3　Oracle进程
2.3.1　用户进程
2.3.2　服务器进程
2.3.3　专用服务器和共享服务器
2.4　Oracle后台进程结构
2.4.1　SMON系统监控进程
2.4.2　PMON进程监控进程
2.4.3　DBWR数据库写入进程
2.4.4　LGWR日志写入进程
2.4.5　CKPT检查点进程
2.4.6　RECO恢复进程
2.4.7　ARCH归档进程
2.4.8　SNPn作业队列进程
2.4.9　LCKn锁进程
2.4.10　Dnnn调度进程
2.4.11　Snnn共享服务器进程
2.4.12　QMNn队列监视进程
2.5　Oracle物理结构
2.5.1　数据文件
2.5.2　控制文件
2.5.3　重做日志文件
2.5.4　参数文件
2.5.5　跟踪文件
2.5.6　警告日志文件
2.6　Oracle逻辑结构
2.6.1　逻辑结构概述
2.6.2　表空间
2.6.3　System表空间、SYSAUX表空间以及其他表空间
2.6.4　段
2.6.5　区
2.6.6　数据块
2.6.7　用户与模式
2.6.8　表
2.6.9　列与数据类型
2.6.10　ROWID伪列
2.6.11　约束条件
2.6.12　索引
2.6.13　视图
2.6.14　序列
2.6.15　过程与过程包
2.6.16　函数
2.6.17　触发器
2.6.18　同义词
2.6.19　权限及角色
2.6.20　快照
2.6.21　聚集
2.6.22　散列聚集
2.6.23　数据库链
2.7　数据分区
2.7.1　分区表
2.7.2　分区表的类型
2.7.3　分区索引
2.7.4　索引的类型
2.7.5　表分区和分区管理
2.8　数据库访问
2.8.1　竞争性、并发性与一致性概念
2.8.2　事务之间的冲突
2.9　锁
2.9.1　锁级别
2.9.2　DML锁
2.9.3　DDL锁
2.10　SQL语句的处理过程
2.10.1　SQL.语句的处理过程
2.10.2　分析
2.10.3　执行
2.10.4　返回结果
2.10.5　SELECT语句的处理步骤
2.10.6　其他语句的处理步骤
2.10.7　SCN的运行机制
2.10.8　Commit的处理
2.10.9　Rollback回滚的处理
2.11　Oracle数据字典
2.11.1　静态数据字典
2.11.2　查看各类静态对象
2.11.3　动态数据字典
2.11.4　各类数据字典区分
2.11.5　动态数据字典结构
2.11.6　动态数据字典分类
第3章　Oracle.Net体系结构和云体验
3.1　Oracle网络概述
3.1.1　网络的连接方式
3.1.2　Oracle的网络连接方式
3.2　Oracle.Net.Services
3.2.1　Oracle.Net
3.2.2　Oracle网络监听
3.2.3　Oracle连接管理器
3.2.4　网络工具
3.2.5　Oracle高级安全性
3.3　Oracle网络体系结构
3.3.1　Oracle.Net.C/S连接的栈结构
3.3.2　Java的连接栈结构
3.3.3　Web连接的栈结构
3.3.4　网络监听体系结构
3.3.5　数据库服务器体系结构
3.3.6　连接管理器体系结构
3.4　Oracle网络的概念
3.4.1　连接的概念
3.4.2　配置管理概念
3.4.3　命名方法
3.5　Oracle云数据库
3.5.1　云数据库基本介绍和申请
3.5.2　构建和发布数据库应用
第4章　安装与配置
4.1　通用安装工具OUI简介
4.2　Optimal.Flexible.Architecture简介
4.3　数据库软件版本说明
4.4　Windows下Oracle的安装
4.4.1　安装的基本硬件要求
4.4.2　安装过程
4.4.3　安装后的环境变量
4.4.4　安装后文件目录
4.5　Oracle的简单网络配置
4.5.1　服务器网络配置
4.5.2　Oracle客户端的配置
4.5.3　如何查看安装的数据库版本号
4.6　Oracle完全卸载
第5章　创建数据库
5.1　手动创建数据库
5.1.1　狭义数据库和广义数据库
5.1.2　准备前提条件
5.1.3　规划物理文件的存放
5.1.4　手动创建数据库的步骤概述
5.1.5　设定环境变量
5.1.6　创建参数文件
5.1.7　创建服务器参数文件
5.1.8　创建数据库
5.1.9　建立数据字典
5.2　通过DBCA创建数据库
5.2.1　DBCA简介
5.2.2　进入DBCA
5.2.3　创建数据库
5.2.4　手动卸载数据库
5.2.5　使用DBCA卸载数据库
5.3　配置数据库全球化支持
5.3.1　国际语言支持
5.3.2　数据库字符集
5.3.3　数据库字符集类型
5.3.4　字节长度和字符长度
5.3.5　数据库字符集与国际语言字符集
5.3.6　各种语言支持的字符集
5.3.7　Oracle字符集配置结构
5.3.8　NLS的参数说明
5.3.9　语言和区域参数
5.3.10　NLS的日期时间参数
5.3.11　NLS的货币参数
5.3.12　数字表示格式
5.3.13　排序参数
5.3.14　其他参数
5.3.15　NLS的参数设置方法
5.3.16　更改初始化参数中的NLS值
5.3.17　NLS的session级设值
5.3.18　NLS的环境变量设置
5.3.19　使用NLS参数的SQL函数
5.3.20　Oracle客户端字符集设置
5.4　查询全球化参数信息
5.4.1　查询数据库级的NLS设置
5.4.2　查询实例级的NLS信息
5.4.3　查询SESSION级的NLS信息
5.4.4　查询NLS可设置的值
5.4.5　查询NLS所有参数
5.5　更改数据库字符集
5.5.1　用ALTER命令更改字符集
5.5.2　使用导入导出更改字符集
5.6　配置多个数据库
5.6.1　创建另一个新的数据库
5.6.2　更改默认数据库
5.6.3　配置数据库监听
5.7　Oracle系统用户和系统权限
5.7.1　SYS用户
5.7.2　SYSTEM用户
5.7.3　SYSDBA和SYSOPER系统权限
5.8　数据库名、实例名等的区分
5.8.1　数据库名
5.8.2　数据库实例名
5.8.3　环境变量ORACLE_SID
第二篇　数据库管理
第6章　管理数据库实例
6.1　Enterprise.Manager.DatabaseExpress.12c
6.1.1　EM.12c体系结构
6.1.2　启动EM.12c
6.1.3　使用EM.12c
6.2　使用Oracle.SQL.Developer
6.2.1　启动Oracle.SQL.Developer
6.2.2　连接数据库
6.3　初始化参数文件
6.3.1　初始化参数文件的作用
6.3.2　PFILE和SPFILE
6.3.3　初始化参数文件的优先级
6.3.4　创建初始化参数文件的技巧
6.3.5　导出服务器参数文件
6.3.6　修改初始化参数文件
6.3.7　数据库关闭时修改SPFILE
6.3.8　判断使用了SPFILE还是PFILE文件
6.4　使用口令文件
6.4.1　口令文件的创建
6.4.2　设置初始化参数REMOTE_LOGIN_PASSWORDFILE
6.4.3　向口令文件中增加、删除用户
6.4.4　使用口令文件登录
6.4.5　维护口令文件
6.5　管理初始化参数
6.5.1　初始化参数的分类
6.5.2　Oracle12c基本参数
6.5.3　Oracle.12c其他常见参数
6.5.4　查询设置的初始化参数
6.5.5　修改动态参数
6.5.6　使用SQL*Plus修改参数
6.5.7　使用EM.12c管理初始化参数
6.5.8　修改参数文件
6.6　启动和关闭数据库
6.6.1　数据库的启动(STARTUP)
6.6.2　数据库的关闭(SHUTDOWN)
6.6.3　停顿数据库
6.6.4　挂起和恢复数据库
6.6.5　使用PFILE和SPFILE启动
6.6.6　使用EM.12c启动关闭数据库
6.6.7　关闭自启动
6.7　更改SID名称
第7章　管理数据库存储
7.1　管理表空间
7.1.1　默认的表空间
7.1.2　创建表空间
7.1.3　表空间创建的几个参数
7.1.4　删除表空间
7.1.5　修改表空间
7.1.6　查询表空间信息
7.2　管理段
7.2.1　数据段和索引段的管理
7.2.2　临时段的管理
7.2.3　回滚段的管理
7.2.4　查询回滚段
7.3　管理撤销表空间
7.3.1　自动撤销管理概述
7.3.2　回滚保持
7.3.3　创建、删除撤销表空间
7.3.4　切换回滚表空间
7.4　管理区
7.4.1　区的参数
7.4.2　区的分配和回收
7.4.3　查询区的信息
7.5　管理数据块
7.5.1　管理数据块参数
7.5.2　设置数据块参数
第8章　管理物理文件
8.1　管理数据文件
8.1.1　数据文件概述
8.1.2　建立数据文件
8.1.3　调整数据文件大小
8.1.4　重命名和移动数据文件
8.1.5　删除数据文件
8.1.6　校验数据块
8.1.7　查询数据文件信息
8.2　管理日志文件
8.2.1　日志文件概述
8.2.2　建立日志文件
8.2.3　配置日志文件
8.2.4　控制日志切换
8.2.5　控制检查点
8.2.6　镜像日志文件
8.2.7　增加日志文件组成员
8.2.8　移动日志文件
8.2.9　删除日志文件组
8.2.10　删除日志文件组成员
8.2.11　清除日志文件
8.2.12　查看日志文件信息
8.3　管理控制文件
8.3.1　创建初始的控制文件
8.3.2　创建新的控制文件
8.3.3　镜像控制文件
8.3.4　删除控制文件
8.3.5　恢复控制文件
8.3.6　查询控制文件信息
8.4　管理归档日志文件
8.4.1　归档日志文件概述
8.4.2　NOARCHIVELOG与ARCHIVELOG模式
8.4.3　控制归档方式
8.4.4　设置归档目的地
8.4.5　设置日志文件传送模式
8.4.6　管理归档目的地点失败
8.4.7　控制归档进程的跟踪输出
8.4.8　查看归档日志文件信息
8.5　管理警告日志文件
8.5.1　查看警告日志文件
8.5.2　警告日志中的消息
8.5.3　归档警告日志
8.6　使用EM管理物理文件
8.6.1　用EM.12c管理数据文件
8.6.2　用EM.12管日志文件
8.6.3　使用EM.12c管理控制文件
8.6.4　使用EM.12c管理其他物理文件
第9章　逻辑对象管理
9.1　管理表
9.1.1　创建表
9.1.2　管理完整性约束
9.1.3　修改表
9.1.4　删除表
9.1.5　查询表的信息
9.2　管理索引
9.2.1　创建索引
9.2.2　修改索引
9.2.3　删除索引
9.2.4　查询索引信息
9.3　管理分区
9.3.1　分区表的创建
9.3.2　添加分区
9.3.3　接合分区
9.3.4　删除分区
9.3.5　转换分区
9.3.6　合并分区
9.3.7　修改缺省属性
9.3.8　修改分区的属性
9.3.9　修改列表分区的值
9.3.10　移动分区
9.3.11　重命名分区
9.3.12　分割分区
9.3.13　截断分区
9.3.14　删除分区
9.3.15　分区表的查询
9.4　管理聚集
9.4.1　创建聚集
9.4.2　创建聚集表
9.4.3　创建聚集索引
9.4.4　修改聚集
9.4.5　删除聚集
9.4.6　查询聚集
9.5　管理散列聚集
9.5.1　创建散列聚集
9.5.2　设置散列聚集参数
9.5.3　修改删除散列聚集
9.5.4　查询散列聚集
9.6　管理视图
9.6.1　创建视图
9.6.2　创建连接视图
9.6.3　更改视图
9.6.4　删除视图
9.6.5　查询视图信息
9.7　管理序列
9.7.1　创建序列
9.7.2　修改序列
9.7.3　删除序列
9.7.4　使用序列
9.7.5　查询序列信息
9.8　同义词管理
9.8.1　创建同义词
9.8.2　删除同义词
9.8.3　查询同义词信息
9.9　管理数据库链
9.9.1　创建数据库链
9.9.2　删除数据库链
9.9.3　查询数据库链信息
9.10　管理数据库触发器
9.10.1　创建触发器
9.10.2　启用和禁用触发器
9.10.3　删除触发器
9.10.4　查询触发器信息
9.11　使用Oracle.SQL.Developer管理数据库对象
9.11.1　使用Oracle.SQL.Developer管理表
9.11.2　使用Oracle.SQL.Developer管理索引
9.11.3　使用Oracle.SQL.Developer管理视图
9.11.4　使用Oracle.SQL.Developer管理同义词
9.11.5　使用Oracle.SQL.Developer管理序列
9.11.6　使用Oracle.SQL.Developer管理触发器
第10章　数据库安全管理
10.1　数据库安全的概念
10.1.1　数据库级安全性
10.1.2　表级安全性
10.1.3　行级安全性
10.1.4　列级安全性
10.2　用户管理
10.2.1　用户的验证方式
10.2.2　创建和修改用户账号
10.2.3　删除用户
10.3　查询用户信息
10.3.1　查询用户会话信息
10.3.2　查询用户会话统计信息
10.3.3　查询用户基本信息
10.3.4　查询用户详细信息
10.3.5　查询用户表空间配额
10.4　权限管理
10.4.1　系统权限分类详解
10.4.2　授予系统权限
10.4.3　回收系统权限
10.4.4　对象权限分类
10.4.5　授予对象权限
10.4.6　回收对象权限
10.4.7　查看权限信息
10.5　角色管理
10.5.1　创建角色
10.5.2　定义角色的权限
10.5.3　授予角色给用户
10.5.4　给用户指定默认角色
10.5.5　修改角色
10.5.6　删除角色
10.5.7　控制角色可用性
10.5.8　预定义的角色
10.5.9　查询角色信息
10.6　资源管理
10.6.1　Oracle概要文件
10.6.2　建立概要文件
10.6.3　修改概要文件
10.6.4　删除概要文件
10.6.5　概要文件的参数
10.6.6　概要文件的口令管理
10.6.7　查询资源和口令信息
10.7　使用EM进行安全管理
10.7.1　使用EM.12c管理用户
10.7.2　使用EM.12c管理角色
第11章　数据库审计管理
11.1　启动数据库审计
11.2　语句审计
11.2.1　启动语句审计
11.2.2　查询语句审计
11.2.3　删除语句审计
11.2.4　查看审计记录
11.3　权限审计
11.3.1　启动权限审计
11.3.2　查询权限审计
11.3.3　删除权限审计
11.4　对象审计
11.4.1　启动对象审计
11.4.2　查询对象审计
11.4.3　删除对象审计
11.5　精细审计
11.5.1　创建精细审计
11.5.2　启动关闭精细审计
11.5.3　删除精细审计
11.5.4　查询精细审计定义
11.5.5　查询精细审计记录
11.6　删除审计记录
第12章　数据库备份
12.1　数据库备份与恢复概述
12.1.1　数据库故障
12.1.2　数据库备份的分类
12.1.3　备份方法比较
12.2　用户管理的备份
12.2.1　全数据库脱机备份
12.2.2　表空间和数据文件的脱机备份
12.2.3　全数据库联机备份
12.2.4　表空间或数据文件联机备份
12.2.5　处理联机备份失败
12.2.6　备份控制文件
12.2.7　备份归档日志文件
12.3　数据库逻辑备份工具Export
12.3.1　Export的配置与启动
12.3.2　Export的各个选项
12.4　Oracle逻辑备份工具数据泵
12.4.1　使用数据泵导出数据
12.4.2　设置并行导出
12.4.3　数据泵导出参数
12.5　DBVERIFY工具
12.5.1　DBVERIFY参数
12.5.2　验证数据文件
12.5.3　验证表或索引数据块
12.6　DBNEWID工具
12.6.1　更改全局数据库名
12.6.2　更改DBID
12.6.3　更改DBNAME
第13章　数据库恢复
13.1　完全介质恢复
13.1.1　SYSTEM表空间数据文件的介质恢复
13.1.2　非SYSTEM表空间数据文件的介质恢复
13.1.3　恢复控制文件
13.1.4　恢复重做日志文件
13.1.5　恢复临时文件
13.2　数据库不完全恢复
13.2.1　基于时间的恢复
13.2.2　基于取消的恢复
13.2.3　基于SCN的恢复
13.3　用户管理的表空间及时点恢复
13.3.1　表空间及时点恢复的概念
13.3.2　表空间及时点恢复的准备
13.3.3　执行用户管理的TSPITR
13.4　数据库逻辑恢复
13.4.1　使用IMP导入
13.4.2　Import的各个参数
13.4.3　使用IMPDP导入
13.4.4　数据泵导入参数
13.4.5　搬移表空间
13.5　数据库闪回恢复
13.5.1　行级闪回
13.5.2　使用闪回表
13.6　数据库闪回恢复
13.6.1　数据库闪回的语法
13.6.2　配置数据库闪回
13.6.3　闪回数据库到某个时间点
13.6.4　闪回数据库到某个SCN
13.7　LogMiner
13.7.1　LogMiner的概念
13.7.2　LogMiner配置要求
13.7.3　使用LogMiner的步骤
13.7.4　LogMiner分析日志文件举例
13.7.5　查询LogMiner信息
第三篇　数据库高级特性
第14章　使用RMAN
14.1　RMAN体系结构
14.2　启动与配置RMAN
14.2.1　启动RMAN
14.2.2　连接RMAN
14.2.3　运行RMAN各类命令
14.2.4　RMAN的环境配置
14.3　使用RMAN备份
14.3.1　备份整个数据库
14.3.2　备份部分数据库
14.3.3　差异增量备份和累积增量备份
14.3.4　建立镜像副本
14.3.5　查询备份信息
14.4　使用RMAN恢复
14.4.1　数据库完全恢复
14.4.2　数据库不完全恢复
14.4.3　块级别的恢复
14.5　RMAN维护命令
14.5.1　Report命令
14.5.2　LIST命令
14.5.3　CROSSCHECK命令
14.5.4　DELETE命令
14.5.5　CHANGE命令
14.5.6　CATALOG命令
14.6　管理恢复目录
14.6.1　创建恢复目录
14.6.2　维护恢复目录
14.6.3　使用存储脚本
14.6.4　查询恢复目录
第15章　自动存储管理
15.1　自动存储管理概述
15.1.1　自动存储管理和文件系统管理的区别
15.1.2　自动存储管理概念
15.2　配置自动存储管理
15.2.1　准备ASM的硬件条件
15.2.2　配置ASM
15.3　管理ASM实例
15.3.1　启动关闭ASM实例
15.3.2　ASM的初始化参数
15.4　管理ASM磁盘组
15.4.1　添加磁盘戳记
15.4.2　创建磁盘组
15.4.3　删除磁盘组
15.4.4　修改磁盘组
15.5　ASM文件
15.5.1　ASM文件类型
15.5.2　创建数据库对象
15.6　查询ASM信息
第16章　管理Oracle网络
16.1　配置Oracle服务器网络
16.1.1　Oracle服务器网络配置概述
16.1.2　使用Oracle.Net.Manager配置监听
16.1.3　使用lsnrctl工具管理监听
16.1.4　动态服务注册
16.1.5　诊断服务器连接
16.1.6　使用Oracle.Net.Configuration.Assistant管理监听
16.2　配置Oracle客户端网络
16.2.1　客户端名称解析方法
16.2.2　主机命名方法
16.2.3　简单命名方法
16.2.4　本地命名方法
16.2.5　Sqlnet.ora文件
16.3　Oracle共享服务器
16.3.1　何时使用共享服务器
16.3.2　监听器在共享服务器中的作用
16.3.3　共享服务器参数
16.3.4　使用DBCA配置共享服务器
16.3.5　查询共享服务器信息
16.3.6　在共享服务器中配置专用连接
16.3.7　调节共享服务器
第17章　使用SQL*Plus
17.1　启动SQL*Plus
17.2　登录SQL*Plus
17.3　执行命令
17.3.1　执行SQL语句
17.3.2　执行PL/SQL语句块
17.3.3　执行SQL*Plus内部命令
17.3.4　执行操作系统命令
17.3.5　退出SQL*Plus
17.3.6　使用帮助
17.3.7　清屏命令
17.4　SQL*Plus编辑命令
17.4.1　APPEND命令
17.4.2　CHANGE命令
17.4.3　CLEAR命令
17.4.4　DEL命令
17.4.5　INPUT命令
17.4.6　LIST命令
17.5　SQL*Plus文件操作命令
17.5.1　保存文件
17.5.2　在文件内加注释
17.5.3　读命令文件到缓冲区
17.5.4　运行命令文件
17.6　格式化查询结果
17.6.1　格式化列
17.6.2　使用SQL*Plus制作报表
17.7　存取数据库
17.7.1　连接到本地数据库
17.7.2　连接到远程数据库
17.7.3　将A数据库数据复制到B数据库
17.8　配置SQL*Plus环境
17.8.1　使用环境变量
17.8.2　设置环境参数
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库管理与维护实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>名师讲坛：Oracle SQL入门与实战经典
第0章 Oracle的安装及相关配置
0.1 Oracle的安装
0.2 Oracle 11g中的SQL*Plus
0.3 scott用户及其对象维护
0.4 本书中将用到的表
0.5 SQL（Structured Query Language）语言
0.6 本书所用的术语
0.7 Oracle 10g的SQL*Plus界面
0.8 使用iSQL*Plus
0.9 使用DOS窗口启动SQL*Plus
第1章 简单查询语句
1.1 最简单的查询语句
1.2 在查询语句中如何选择特定的列
1.3 如何书写查询语句
1.4 列标题和数据的默认显示格式
1.5 如何在SQL语句中使用算术表达式
1.6 如何在SQL语句中使用列的别名
1.7 连接运算符
1.8 DISTINCT运算符
1.9 基本查询语句的格式
1.10 您应该掌握的内容
第2章 限制性查询和数据的排序
2.1 如何限制所选择的数据行
2.2 比较运算符
2.3 如何使用BETWEEN AND比较运算符
2.4 在SQL语句中使用字符串和日期
2.5 使用IN比较运算符
2.6 使用LIKE比较运算符
2.7 如何使用转义操作符
2.8 ORDER BY子句
2.9 在ORDER BY子句中使用别名或表达式
2.10 在ORDER BY子句中使用列号
2.11 在ORDER BY子句中使用多列
2.12 在ORDER BY子句中使用在SELECT 列表中没有的列
2.13 扩充后的查询语句的格式
2.14 您应该掌握的内容
第3章 常用的SQL*Plus命令
3.1 DESC[RIBE]命令
3.2 SET LINE[SIZE]{80|n}命令
3.3 L命令和n text命令
3.4 “/”命令
3.5 n（设置当前行）命令和A[PPEND]（附加）命令
3.6 DEL命令
3.7 C[HANGE]命令
3.8 如何生成脚本文件
3.9 如何编辑脚本文件
3.10 如何直接运行脚本文件
3.11 SPOOL命令
3.12 将Oracle数据库的数据导出给其他系统
3.13 将数据导出操作自动化
3.14 商业智能软件读取Oracle数据的简单方法
3.15 您应该掌握的内容
第4章 单行函数
4.1 什么是函数
4.2 单行函数简介
4.3 单行字符型函数
4.4 使用单行字符型函数的实例
4.5 数字型函数
4.6 日期型数据的处理
4.7 日期型函数
4.8 ROUND和TRUNC函数用于日期型数据
4.9 不同数据类型之间的隐含转换
4.10 不同数据类型之间的显式转换
4.11 您应该掌握的内容
第5章 NULL值的处理、逻辑操作和函数嵌套
5.1 什么是空值
5.2 含有空值的表达式的运算
5.3 空值的排序
5.4 逻辑表达式和逻辑运算符
5.5 运算符的优先级
5.6 用AND和OR替代BETWEEN AND和IN运算符
5.7 NVL函数
5.8 DECODE函数
5.9 单值函数的嵌套
5.10 Oracle 9i之后新增加的单值函数和表达式
5.11 您应该掌握的内容
第6章 综合数据和分组函数
6.1 5个常用的分组函数
6.2 COUNT函数
6.3 AVG和SUM函数
6.4 MIN和MAX函数
6.5 GROUP BY子句的应用
6.6 改变GROUP BY子句的排序次序
6.7 GROUP BY子句的特殊用法
6.8 分组函数与GROUP BY子句的非法操作
6.9 HAVING子句的使用
6.10 分组函数的嵌套
6.11 分组函数的空值问题
6.12 NVL函数在分组函数中的使用
6.13 是否在分组函数中使用NVL函数的商业背景
6.14 使用多列进行分组操作
6.15 其他的分组函数和分组函数的小结
6.16 您应该掌握的内容
第7章 多表查询
7.1 数据库的规范化
7.2 主键和实体完整性
7.3 第一范式
7.4 消除部分依赖
7.5 外键和引用完整性
7.6 第二范式
7.7 第三范式
7.8 规范化过程小结
7.9 多表连接
7.10 相等连接
7.11 连接中表别名的使用
7.12 笛卡儿乘积（乘积连接）
7.13 自连接
7.14 两个以上的表的连接
7.15 不等连接
7.16 外连接
7.17 SQL:1999语法的连接
7.18 SQL:1999语法的乘积连接和自然连接
7.19 使用USING子句的连接
7.20 使用ON子句的连接
7.21 使用ON子句的多表连接和附加条件
7.22 左外连接
7.23 右外连接
7.24 全外连接
7.25 利用ON子句进行自连接
7.26 利用ON子句进行不等连接
7.27 您应该掌握的内容
第8章 子查询
8.1 为什么引入单行子查询
8.2 WHERE子句中的单行子查询
8.3 HAVING子句中的单行子查询
8.4 FROM子句中的单行子查询
8.5 多行子查询
8.6 子查询中的空值问题
8.7 多列子查询
8.8 小结
8.9 您应该掌握的内容
第9章 控制SQL*Plus的环境和数据字典简介
9.1 控制SQL*Plus的环境
9.2 SQL*Plus的环境变量ECHO
9.3 SQL*Plus的环境变量FEEDBACK
9.4 SQL*Plus其他常用的环境变量
9.5 SQL*Plus的COLUMN格式化命令
9.6 SQL*Plus的其他格式化命令
9.7 数据字典和数据字典视图
9.8 格式化数据字典视图的输出
9.9 如何使用数据字典视图
9.10 小结
9.11 您应该掌握的内容
第10章 创建表
10.1 创建表的语句和例子
10.2 命名和引用规则
10.3 列的数据类型和默认值
10.4 创建表的例子
10.5 利用子查询来创建表
10.6 修改表的结构
10.7 改变对象的名字
10.8 为表和列加注释
10.9 截断表和删除表
10.10 只读（Read Only）表
10.11 小结
10.12 您应该掌握的内容
第11章 替代变量
11.1 替代变量引入的原因
11.2 以&开始的替代变量
11.3 字符型和日期型替代变量
11.4 以&&开始的替代变量
11.5 替代变量可以出现的地方
11.6 使用DEFINE定义替代变量
11.7 使用ACCEPT定义替代变量
11.8 如何使用ACCEPT命令的HIDE选项
11.9 ACCEPT命令的格式和选项
11.10 参数和替代变量的永久设置
11.11 小结
11.12 您应该掌握的内容
第12章 数据的维护
12.1 准备工作
12.2 INSERT语句
12.3 INSERT语句中的空值问题
12.4 如何向表中插入特殊的值
12.5 如何利用子查询向表中插入数据
12.6 如何利用替代变量向表中插入数据?和将INSERT语句存入脚本文件
12.7 利用ACCEPT在INSERT语句中 产生用户友好的系统提示
12.8 UPDATE语句
12.9 基于另一个表来修改记录
12.10 利用多列子查询来修改记录
12.11 DELETE语句
12.12 在使用DELETE时可能出现的问题
12.13 基于另一个表来删除行
12.14 引入事务处理的原因
12.15 什么是Oracle数据库的事务
12.16 利用COMMIT和ROLLBACK语句进行事务控制
12.17 利用DDL和DCL语句进行事务控制
12.18 非正常退出和正常退出SQL*Plu对事务控制的影响
12.19 利用AUTOCOMMIT进行事务控制
12.20 有关事务处理应注意的一些问题
12.21 您应该掌握的内容
第13章 索引与约束
13.1 为什么引入索引
13.2 如何建立索引
13.3 如何查看索引
13.4 使用索引时应注意的问题
13.5 基于函数的索引
13.6 如何确认Oracle系统是否使用了索引
13.7 如何删除索引
13.8 为什么要引入约束及如何定义约束
13.9 非空约束
13.10 查看有关约束的信息
13.11 唯一约束
13.12 条件约束
13.13 主键约束
13.14 外键约束
13.15 外键约束对INSERT语句的影响
13.16 外键约束对DELETE语句的影响
13.17 外键约束对UPDATE语句的影响
13.18 外键约束对DDL语句的影响
13.19 外键的ON DELETE SET NULL和ON DELETE CASCADE子句
13.20 约束的维护
13.21 约束小结
13.22 您应该掌握的内容
第14章 视图
14.1 为什么引入视图
14.2 使用视图的好处
14.3 如何创建视图
14.4 如何修改视图
14.5 Oracle系统如何管理视图
14.6 如何使用视图来进行DML操作
14.7 如何使用视图的WITH CHECK OPTION子句
14.8 为什么要使用WITH READ ONLY子句
14.9 如何删除视图
14.10 内嵌式视图
14.11 前n行查询/分析
14.12 ROWNUM的更多应用
14.13 您应该掌握的内容
第15章 序列号和同义词
15.1 序列号的引入
15.2 创建序列号语句的格式
15.3 如何创建序列号
15.4 如何使用创建的序列号
15.5 使用序列号的实例
15.6 NEXTVAL和CURRVAL虚（伪）列介绍和它们的使用规则
15.7 序列号的修改
15.8 删除序列号
15.9 引入同义词的原因
15.10 如何创建同义词
15.11 创建公用同义词
15.12 删除同义词
15.13 您应该掌握的内容
第16章 用户管理
16.1 控制用户对数据库的访问
16.2 创建用户及给用户赋口令
16.3 Oracle数据库管理系统中的权限
16.4 如何将系统权限授予用户
16.5 如何查看用户具有的系统权限
16.6 引入角色的原因
16.7 角色的创建和使用
16.8 对象的权限和授权语句
16.9 对象权限授权实例
16.10 权限的回收
16.11 改变用户的口令
16.12 删除用户
16.13 CONNECT和RESOURCE角色
16.14 您应该掌握的内容
第17章 SQL Developer简介和集合操作
17.1 Oracle SQL Developer 简介
17.2 为Oracle SQL Developer配置连接
17.3 集合操作符及将使用的表
17.4 UNION集合操作（运算）符
17.5 UNION ALL集合操作（运算）符
17.6　INTERSECT和MINUS集合操作（运算）符
17.7 集合操作（运算）符的特点
17.8 查询语句的匹配
17.9 获取执行计划和控制行的顺序
17.10 利用AUTOTRACE追踪SQL语句
17.11 获取SQL*Plus的帮助信息
第18章 Express概述和安装
18.1 Oracle Application Express简介
18.2 Oracle Application Express的诱人之处
18.3 可以使用Express完成的工作
18.4 适合于使用Express开发的系统
18.5 HTTP 服务器的选择和软硬件要求
18.6 Oracle Application Express安装
18.7 Express工作区和用户角色
18.8 设置自己的本地环境
18.9 登录本地Express实例
18.10 创建新用户（账户）
第19章 Express的用户界面
19.1 Express工作区主页
19.2 使用SQL工作室与数据库交互
19.3 应用程序构建器
第20章 创建和预览Express网页
20.1 创建最初的Express应用程序
20.2 预览所建的应用程序
20.3 使用网络浏览器启动应用程序主页
20.4 修改分公司报表
20.5 添加员工报表和表单
20.6 预览所创建的员工信息网页
第21章 编辑Express网页
21.1 创建函数
21.2 创建列和修改列名
21.3 修改列显示格式
21.4 以选择列表来显示项的准备工作
21.5 为JOBS创建值列表
21.6 为EMPLOYEES创建值列表
21.7 为DEPARTMENTS创建值列表
21.8 编辑JOB项
21.9 编辑MANAGER项
21.10 编辑DEPARTMENT项
21.11 运行并预览网页
21.12 汉化报表的显示
21.13 汉化表单的显示
第22章 在网页中加入链接
22.1 在主页上添加“人才荟萃”报表的超链接
22.2 创建区域
22.3 创建项
22.4 将项与报表链接
22.5 创建分支
22.6 将一列的值链接到另一个网页
22.7 创建报表和条件
22.8 关闭页码
22.9 添加广告用语
22.10 如何使用“发现”图标
22.11 在主页上加入客户信息
22.12 在网页上添加图形
第23章 管理数据和部署应用程序
23.1 数据加载/卸载工具（数据车间）
23.2 将数据卸载到正文文件中
23.3 将数据卸载到电子表格文件中
23.4 将正文文件的数据加载到Oracle数据库中
23.5 将电子表格的数据加载到Oracle数据库中
23.6 部署应用程序原理
23.7 导出应用程序
23.8 下载客户追踪包和创建安装所用的工作区
23.9 在cust工作区上安装客户追踪软件包
23.10 创建终端用户
23.11 通过切换主题来改变用户的界面
23.12 公布应用程序的网址
23.13 普通用户利用公布的URL访问应用程序
结束语
鸣谢
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>名师讲坛：Oracle SQL入门与实战经典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>专业级Oracle Database 12c安装、配置与维护
第1章  Oracle Database 12c基础知识	1
1.1  定义数据库	2
1.2  熟悉数据库的特性	4
1.2.1  共享	4
1.2.2  存储	4
1.2.3  数据一致性	5
1.2.4  数据完整性	6
1.3  了解何时使用数据库	8
1.4  了解Oracle Database 12c的架构	8
1.4.1  共享内存	9
1.4.2  系统支持进程	10
1.4.3  操作系统文件	11
1.5  处理Oracle数据库中的对象	12
1.5.1  表	13
1.5.2  视图	13
1.5.3  同义词	14
1.5.4  存储对象	15
1.6  在Oracle数据库中处理数据类型	15
1.6.1  变长字符VARCHAR2	16
1.6.2  数字	16
1.6.3  日期时间	17
1.6.4  CLOB/BLOB	18
1.7  结合：对象和数据类型	19
1.8  与数据交互	20
1.8.1  SQL*Developer	21
1.8.2  sqlplus	24
1.8.3  PL/SQL	27
1.9  了解Oracle Database 12c的新功能	28
1.9.1  可插拔数据库	28
1.9.2  应用开发	29
1.9.3  可用性	29
1.9.4  商业智能和数据仓库	30
1.9.5  压缩和归档	30
1.9.6  总体数据库功能	30
1.9.7  网格功能	31
1.9.8  可管理性	31
1.9.9  性能	31
1.9.10  安全	32
1.9.11  XML DB	32
本章能力测试	33
第2章  安装Oracle	35
2.1  研究和规划安装	36
2.1.1  定义系统需求	36
2.1.2  安装Linux	37
2.2  安装操作系统	40
2.3  熟悉Linux	44
2.4  选择要安装的组件	45
2.5  安装Oracle软件	46
2.5.1  数据库配置助手	52
2.5.2  验证安装	60
2.5.3  小结	61
本章能力测试	61
第3章  访问和获取数据	63
3.1  了解SQL语句的组成部分	64
3.1.1  DDL	64
3.1.2  DML	66
3.2  使用基本的insert和select语句	66
3.2.1  insert语句	66
3.2.2  select语句	67
3.3  使用简单的WHERE子句	68
3.3.1  在WHERE子句中使用AND/OR	71
3.3.2  在WHERE子句中使用NOT	72
3.3.3  在WHERE子句中使用范围搜索	72
3.3.4  在WHERE子句中使用搜索列表	72
3.3.5  在WHERE子句中使用模式搜索	73
3.3.6  WHERE子句：常用运算符	76
3.4  使用基本的update、delete和merge语句	77
3.4.1  update语句	77
3.4.2  delete语句	78
3.4.3  insert语句	78
3.4.4  使用基本的merge语句	78
3.5  对数据排序	81
3.6  使用函数：字符串函数、数值函数、聚合函数(不分组)	82
3.6.1  字符串函数	82
3.6.2  数值函数	83
3.6.3  聚合函数	83
3.7  使用日期和数据函数(格式化和
按时间顺序排列)	83
3.7.1  日期函数	84
3.7.2  特殊格式的日期数据类型	84
3.7.3  嵌套函数	85
3.8  运用连接(ANSI与Oracle)：内连接、外连接和自连接	86
3.8.1  内连接	86
3.8.2  外连接	89
3.8.3  自连接	93
3.9  学习GROUP BY和
HAVING子句	94
3.9.1  GROUP BY子句	95
3.9.2  HAVING子句	95
3.10  了解子查询：简单子查询和带有
相关比较连接的子查询	98
3.10.1  简单子查询	98
3.10.2  带有连接的相关子查询	99
3.11  使用集合运算符：UNION、INTERSECT、MINUS	100
3.11.1  UNION	101
3.11.2  UNION ALL	101
3.11.3  INTERSECT	102
3.11.4  MINUS	102
3.12  使用视图	103
3.13  学习序列	105
3.14  使用限制：联动到实体模型、类型、
递延、执行、收集异常	106
3.14.1  联动到实体模型	107
3.14.2  类型	107
3.14.3  延迟	108
3.15  使用SQL*Plus格式化输出	108
3.15.1  页和行大小	108
3.15.2  页标题	108
3.15.3  页脚	109
3.15.4  格式化列	109
3.15.5  将SQL*Plus输出写入到文件中	111
本章能力测试	111
第4章  数据库编程	113
4.1  PL/SQL的定义和功能	114
4.2  描述基本的PL/SQL程序结构	116
4.3  定义PL/SQL数据类型	117
4.3.1  有效字符	117
4.3.2  算术运算符	117
4.3.3  varchar2数据类型	119
4.3.4  number数据类型	119
4.3.5  date数据类型	120
4.3.6  布尔数据类型	120
4.3.7  varray数据类型	121
4.4  在SQL*Plus中编写PL/SQL
程序	123
4.4.1  PL/SQL程序中的SQL	125
4.4.2  PL/SQL游标	125
4.4.3  游标FOR循环	127
4.5  处理PL/SQL中的错误情况	128
4.6  在程序中包含条件	133
4.6.1  程序控制	133
4.6.2  IF逻辑结构	134
4.6.3  CASE语句	136
4.6.4  LOOP循环	137
4.6.5  WHILE循环	138
4.6.6  FOR循环	138
4.7  如何以及为何创建存储过程	141
4.8  创建和使用函数	144
4.9  调用PL/SQL程序	146
本章能力测试	147
第5章  数据库管理员	149
5.1  了解数据库管理员的职责	150
5.2  执行日常运作	151
5.2.1  架构与设计	151
5.2.2  容量规划	151
5.2.3  备份和恢复	151
5.2.4  安全	152
5.2.5  性能和调优	152
5.2.6  管理数据库对象	152
5.2.7  存储管理	152
5.2.8  变更管理	152
5.2.9  计划作业	153
5.2.10  网络管理	153
5.2.11  高可用性	153
5.2.12  故障排除	153
5.3  了解Oracle Database 12c架构	153
5.3.1  模式	153
5.3.2  段、区和块	154
5.3.3  可插拔数据库	155
5.3.4  逻辑模式结构	155
5.3.5  存储结构	156
5.4  Oracle Database 12c的操作模式	157
5.4.1  操作模式	157
5.4.2  启动容器数据库	158
5.4.3  打开数据库的其他方法	158
5.4.4  强制启动	159
5.4.5  数据库和实例的关闭	159
5.5  开始使用Oracle企业管理器	161
5.5.1  实例配置	164
5.5.2  用户会话	164
5.5.3  资源使用者组	165
5.5.4  其他工具	166
5.6  了解数据库连接	167
5.6.1  Oracle网络服务	168
5.6.2  命令行实用程序	168
5.6.3  连接	169
5.6.4  维护连接	170
5.6.5  定义位置	170
5.6.6  连接描述符	171
5.6.7  定义连接描述符	171
5.7  管理数据库对象	172
5.7.1  控制文件	172
5.7.2  重做日志	172
5.7.3  还原管理	172
5.7.4  模式对象	172
5.8  空间管理	174
5.8.1  归档日志	174
5.8.2  表空间和数据文件	174
5.9  管理用户	175
5.9.1  创建用户	176
5.9.2  编辑用户	177
5.10  管理数据库用户的权限	177
5.10.1  授权	178
5.10.2  授权的类型	178
5.10.3  取消授权	178
5.10.4  角色	178
5.10.5  Oracle定义的角色	179
5.10.6  创建并授予角色	179
5.10.7  配置文件	179
5.10.8  小结	180
本章能力测试	182
第6章  备份和恢复	183
6.1  了解RMAN	184
6.2  使用RMAN的理由	185
6.3  了解存储介质	186
6.4  检查RMAN的组件	187
6.4.1  备份	187
6.4.2  还原	187
6.4.3  恢复	187
6.5  调用RMAN	188
6.6  了解RMAN命令	189
6.7  RMAN通道综述	192
6.8  检查RMAN配置	193
6.9  探索备份命令	195
6.9.1  数据库	195
6.9.2  表空间	195
6.9.3  数据文件	195
6.9.4  控制文件	196
6.9.5  服务器参数文件	196
6.9.6  归档重做日志	196
6.10  进行增量备份	196
6.11  列出备份列表	197
6.12  查看RMAN元数据	198
6.13  使用RMAN还原	200
6.14  了解RMAN恢复	201
6.15  了解备份保留	201
6.16  检查语法	202
6.17  恢复表	202
6.18  总结	202
6.18.1  备份脚本	202
6.18.2  还原和恢复脚本	203
本章能力测试	204
第7章  高可用性：RAC、ASM和
Data Guard	205
7.1  定义高可用性	206
7.2  了解真正应用集群	207
7.3  安装RAC	208
7.4  测试RAC	211
7.4.1  工作负载管理器	212
7.4.2  ASM	212
7.5  建立ASM实例	213
7.6  创建ASM磁盘组	218
7.7  使用ASMCMD和ASMLib	220
7.8  将现有的数据库转换到ASM	221
7.9  理解Data Guard	223
7.10  解释Data Guard保护模式	224
7.11  创建物理备用服务器	226
本章能力测试	229
第8章  使用和管理大型数据库	231
8.1  学会识别超大型数据库	232
8.2  使用数据分区的原因和方法	232
8.2.1  使用数据分区的原因	232
8.2.2  管理	234
8.2.3  性能	235
8.2.4  实现数据分区	236
8.2.5  定义分区的索引策略	244
8.3  压缩数据	250
8.3.1  数据压缩	250
8.3.2  索引键压缩	251
8.3.3  自动数据优化	252
8.4  使用并行处理提高性能	253
8.4.1  并行处理数据库组件	253
8.4.2  并行处理配置	253
8.4.3  调用并行执行	255
8.5  使用物化视图	256
8.5.1  物化视图的用途	256
8.5.2  查询重写	257
8.5.3  何时创建物化视图	258
8.5.4  创建物化视图	258
8.6  使用SQL聚合函数和分析函数	259
8.6.1  聚合函数	259
8.6.2  rollup扩展	259
8.6.3  cube扩展	260
8.6.4  分析函数	261
8.6.5  窗口函数	266
8.6.6  其他函数	267
8.7  创建SQL模型	268
本章能力测试	271
第9章  Oracle的工程系统：从数据库机到Exadata	273
9.1  了解Oracle数据库机	274
9.2  管理Oracle数据库机	275
9.3  了解Exadata的主要组件	276
9.4  了解Exadata存储	277
9.5  利用存储分担加快大型查询	279
9.5.1  智能扫描实践	279
9.5.2  为什么可能不会发生智能扫描	281
9.6  了解存储索引	281
9.7  使用Exadata闪存缓存	282
9.8  节省存储空间与混合列压缩	284
9.8.1  混合列压缩实践	285
9.8.2  使用DBMS_COMPRESSION估算压缩	285
9.9  使用I/O资源管理启用数据库整合	286
9.10  执行常见的Exadata管理任务	288
9.10.1  Exadata存储服务器上的用户账户	288
9.10.2  使用DCLI从存储服务器检索指标	288
9.10.3  使用EXACHK验证Exadata配置	289
9.11  使用Oracle企业管理器管理Exadata	290
本章能力测试	291
附录  能力测试答案	293
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>专业级Oracle Database 12c安装、配置与维护
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8 入门与提高
引  言
第1章  0racle概述
1. 1  0racle的发展与现状
1. 1. 1  0racle的历史
1. 1. 2  0racle8的优越性
1. 1.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8 入门与提高
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 9i中文版数据库系统管理
第1章 Oracle 9i基础
第2章 例程的管理
第3章 表
第4章 索引和视图
第5章 管理用方案对象
第6章 PL/SQL编程用方案对象
第7章 安全性管理
第8章 存储的管理
第9章 数据库的配置
第10章 网络的配置
第11章 Oracle网络的集中管理
第12章 数据库的备份
第13章 数据库的恢复
第14章 使用恢复管理器备份与恢复
第15章 性能分析与调整
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 9i中文版数据库系统管理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Developer2000学习教程
第一部分 Oracle SQL*PLUS
第1章	SQL*PLUS基础
第2章	结构化查询语言SQL
第3章	格式化查询结果
第4章	SQL*PLUS的高级特性
第5章	数据库安全管理
第二部分 Oracle PL/SQL
第6章	PL/SQL简介
第7章	PL/SQL基础
第8章	数据操纵语句
第9章

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Developer2000学习教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle SQL简明教程
第Ⅰ部分   基础篇
第0章 软件工程过程和关系数据库
第1章 在Wiondws系统中使用Oracle
第2章 基本SQL语句
第3章 笛卡尔积、连接运算和别名
第4章 函数和匹配
第5章 查询开发、权限和导出结构
第6章 集合操作
第7章 连接和子查询
第8章 GROUP BY 和 HAVING子句
第9章 相关子查询
第Ⅱ部分   高级篇
第10章 创建表和使用SQLLOANDER
……
附录
附录A 在UNLX系统中使用Oracle
附录B 数据字典
附录C 学生数据库及相关表
附录D Oracle 8i和Oracle 9i新增的改进
术语表
重要命令和函数表
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle SQL简明教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ORACLE Developer/2000 使用技术与方法
第一部分SQL*PLUS使用方法
第一章SQL*PLUS简介
1??1结构化查询语言SQL
1??2启动SQL*PLUS
1??3预备知识
1??4SQL和SQL*PLUS命令
1??5几个主要的SQL*PLUS命令
第二章数据操纵语言
2??1简单的数据查询命令
2??2数据更新命令
2??3事务控制命令
第三章数据定义语言
3??1Oracle数据库实体
3??2数据

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ORACLE Developer/2000 使用技术与方法
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 10g 升级指南
第1章 认识Oracle Database 10g
第2章 服务器管理
第3章 性能调整
第4章 安全性
第5章 可用性和可恢复性
第6章 商业智能
第7章 应用程序开发
第8章 其他新特性
第9章 Oracle Enteprise Manager 10g
附录 新的Oracle Database 10g进程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 10g 升级指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Jdeveloper 10g与J2EE实战演练
第1章 Oracle应用程序开发框架（ADF）简介
第2章 安装Oracle JDeveloper 10g与OC4J
第3章 安装Oracle 10g数据库服务器
第4章 JDeveloper 集成开发环境
第5章 JDeveloper 的项目管理技巧
第6章 编译与执行JAVA应用程序
第7章 使用JDeveloper调试器与性能调校工具
第8章 使用JDBC 取存Oracle 10g数据库
……
附录A Oracle 10g使用的端口范围与设置方式
附录B OC4J基本管理方式
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Jdeveloper 10g与J2EE实战演练
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 9i数据仓库构建技术
第一章 数据仓库概念
第二章 ORACLE WAREHOUSE BUILDER概述
第三章 OWB安装与配置
第四章 使用OWB创建工程
第五章 数据仓库的逻辑设计
第六章 数据创库特理设计
第七章 数据仓库的硬件和I/O考虑
第八章 数据装载和转换
第九章 实体化视图
第十章 数据仓库并行处理和分区
……
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 9i数据仓库构建技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 9i Jdeveloper Web应用与开发
第1部分 IDE与软件开发技术
第1章 Oracle9i JDeveloper概述
第2章 用JDeveloper开发Java程序
第3章 面向对象软件开发技术
……
第2部分 Web应用开发技术
第6章 Oracle9iAS Container for J2EE
第7章 基本Servlet程序设计
……
第3部分 Oracle9i Web应用开发技术
第11章 基本JDBC程序设计
第12章 JDBC API程序设计
……
第4部分 Web应用开发示例
第20章 Web应用设计模式
第21章 Web应用开发示例
附录 Java/Servlet/JSP/UML资源列表
主要参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 9i Jdeveloper Web应用与开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>基于Linux的Apache+JSP+Oracle
绪论
企业上网
Linux在企业网站建设中的角色
基于Linux的Apache JSP
本书的组织
第1章  JSP介绍
1. 1  JSP的由来

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>基于Linux的Apache+JSP+Oracle
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Developer使用指南
贺辞序译者的话前言第一

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Developer使用指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库管理员基础教程
贺辞序译者序作者序第一部分
从

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库管理员基础教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8优化技术
目 录
贺辞
序
引言
译者序
第1章 安装
1.1README文件
1.2硬件和软件需求
1.3磁盘空间
1.4NLS的研究
1.4.1设置NLSLANG
1.4.2初始化参数文件中NLS项
1.4.3地区信息文件
1.5特权（O/S级）
1.6特权（在数据库中）
1.6.1在SYS模式中浏览对象
1.6.2SYSOPER和SYSDBA特权
1.7SHAR ED ＿POOL＿SIZE 陷阱
1.8安装日志文件
1.9文件结构
1.10数据库创建问题
1.10.1最大化数据文件参数
1.10.2重演日志
1.10.3日志历史
1.10.4重演日志组成员
1.10.5表空间配置
1.10.6初始化参数文件大小
1.10.7Orac leReport
1.10.8控制文件
1.10.9脚本
1.10.10初始化参数文件中的非缺省项
1.11产品完整性检查
1.11.1Oracle8Server报告
1.11.2PL/SQL的正确运行方式
1.11.3数据库触发器、存储过程、函
数和软件包
1.11.4由Net8支持的数据库连接
1.11.5重新连接服务器的问题
1.11.6其他附加文件
1.11.7 第三方产品
1.12本章小结
1.13 Oracle7.X说明
第2章 内存/CPU
2.1WindowsNT性能监视器
2.2后台进程
2.3跟踪文件和实例警报文件
2.4 系统全局区（SGA）
2.5分页与对换
2.6存储器需求
2.6.1第一步：未包括SGA的需求
2.6.2 第二步：估计SGA存储器需求
2.7存储器需求多大？
2.8共享池
2.8.1库高速缓存
2.8.2字典高速缓存
2.9数据库缓冲区高速缓存
2.10重演日志缓冲区高速缓存
2.11 多线程服务器
2.11.1启动MTS
2.11.2改变初始化参数文件
2.12排序区域大小（SORT＿AREA＿
SIZE）
2.13重视CPU
2.13.1SMP
2.13.2MPP
2.14 Oracle8的并行查询
2.15CPU的繁忙程度
2.15.1估计CPU的繁忙程度
2.15.2从例子中得出的结论
2.15.3 CPU 太小
2.16 使CPU功能最大化
2.17 会话控制
2.17.1限制访问
2.17.2删除不需要的会话
2.17.3利用profile
2.18 本章小结
2.19Oracle7.x说明
第3章 输入/输出
3.1访问SYS的DBA和V＄视图
3.2在链中的慢连接
3.3表和索引段
3.4索引组织表
3.4.1为什么使用索引组织表
3.4.2建立索引组织表
3.4.3从索引组织表获益的应用程序
3.4.4DML和DDL的区别
3.5表和索引的分离
3.6表和索引的磁盘分区
3.7行迁移和行链接
3.8转返段
3.9减少碎片
3.10 临时段
3.11重演日志
3.12磁盘控制器
3.13 热点
3.13.1数据文件热点
3.13.2对象热点
3.13.3报告审计信息
3.13.4关闭审计
3.14 确定合适的表和索引大小
3.14.1用公式来定义大小
3.14.2利用现存数据段确定大小
3.15真正利用的空间
3.15.1在初始化加载后表中所用的空
间
3.15.2在表存在的任何时间内所用的
空间
3.15.3索引中所用空间
3.16空间分配和I/O的各种调整
3.16.1 回收未使用的空间
3.16.2利用分区来进行划分
3.16.3安排pctfree对表或索引进行分
区
3.16.4 pctused和自由表
3.16.5 修改SQL .BSQ
3.17本章小结
3.18Oracle7.x说明
第4章 分区
4.1分区与调整过程
4.2可用的分区类型
4.2.1范围分区
4.2.2分区视图
4.2.3处理分区视图上的查询
4.3表的分区
4.3.1决定如何分区
4.3.2将数据放人正确的分区
4.3.3数据放入分区对象
4.3.4分区对象的表空间
4.3.5处理分区及其表空间
4.4 分区索引
4.4.1全局索引
4.4.2局部索引
4.5分区对象的公共操作
4.5.1统计收集
4.5.2 基于分区的卸出和装人
4.5.3 转换分区视图到分区表
4.5.4分区维护和全局索引
4.6本章小结
4.7Oracle7.x说明
第5章 并行性
5.1并行查询处理
5.2并行查询外观
5.3并行执行
5.3.1PARALLEL提示
5.3.2PARAL LEL ＿INDEX 提示
5.3.3NOPARALLEL提示
5.3.4APPEND和NOAPPEND提示
5.4并行SQL语句
5.4.1并行度是什么
5.4.2操作的并行度
5.5SQL语句的并行形式
5.6创建表
5.6.1影响并行处理的Orac1e8物理
设计
5.6 .2Insert ，Updates和Deletes
5.7 并行索引
5.8并行加载
5.8.1分解传统加载
5.8.2不同对象的并行加载
5.8.3并行加载到相同对象
5.9并行操作的限制
5.10并行的性能
5.11本章小结
5.12Oracle7.x说明
第6章 数据库的其他有关问题
6.1初始化参数（INIT.0RA）文件
6.1.1数据库范围参数
6.1.2独立用户/进程参数
6.2 utlbstat和ut1estat
6.2.1utlbstat简介
6.2.2 utlestat简介
6.3 utlestat/utlbstat例子
6.3.1选择正确的时间片
6.3.2检测初始参数文件
6.3.3在适当的时候切换到ultbstat
6.3.4在时间周期末运行utlestat
6.3.5输出结果说明
6.4其他调整设想
6.4.1PCTFREE
6.4.2调整重演日志
6.5本章小结
6.6Oracle7.X说明
第7章 显示终止
7.1扩充字符集的数据处理
7.1.1WindowsNT
7.1.2UNIX
7.1.3检查重音符号
7.2客户机/服务器的驱动器赋值
7.3索引文件的变化
7.4数据库及操作系统的限制
7.5操作系统的限制
7.5.1操作系统的最大打开文件数
7.5.2操作系统初始化文件
7.6Oracle8数据类型的限制
7.7Oracle的限制
7.7.1DB FILES
7.7.2ENQUE UE RES OUR CES
7.8重建数据库
7.9自由空间争用
7.10失控规模
7.11索引中的自由空间
7.12事务空间
7.13档案日志目标区已满
7.14上锁
7.15ANSIC编译器
7.16不要怕阅读使用指南
7.17数据库的使用权限
7.18磁盘空间和内存
7.19截除（truncate），而不要删除
（drop）
7.20 碰到困难如何寻求帮助
7.20.1正确估计形势
7.20.2联系遍布世界各国的售后服
务商
7.20.3西蒙说
7.20.4使用个人的Oracle关系网
7.20.5使用Internet或其他的信息
网
7.20.6这里没有魔弹
7.21 本章小结
7.22 Oracle7.x说明
第8章 应用程序调整
8.1Oracle企业管理器
8.2共享SQL区
8.2.1查看共享池
8.2.2调整共享池
8.2.3手工管理共享池
8.3SQL语句处理
8.4使用通用代码
8.4.1描述的完整性
8.4.2数据库触发器
8.4.3过程和软件包
8.4.4执行模式
8.5基于开销的优化（CBO）
8.5.1搜集统计数字
8.5.2开发一个统计搜集方案
8.5.3统计数字的存储
8.5.4使用提示
8.5.5优化方式
8.6解释方案
8.7设置自动跟踪
8.7.1允许用户使用自动跟踪
8.7.2自动跟踪方式
8.8提示和解释方案工具箱
8.9tkprof 和SQL跟踪
8.10SQL跟踪黑洞
8.11索引列
8.12锁
8.13 本章小结
8.14Oracle7.x说明
第9章 性能包
9.1性能包的组成
9.1.1Oracle跟踪
9.1 2 Oracle专家
9.1.3性能管理器
9.1.4锁管理器
9.1.5表空间管理器
9.1.6Oracle顶层会话
9.2性能包和调整过程
9.2.1文件I/O率细目
9.2.2系统I/O率
9.2.3内存库高速缓存细目
9.2.4内存排序命中率
9.2.5转返无等待命中率
9.2.6概览
9.3定制图表
9.3.1设备I/O
9.3.2设备表空间
9.4使用建议
9.4.1局部与远程数据存放
9.4.2性能干扰
9.4.3重用与用户定义图表
9.5本章小结
9.6Oracle7.x说明
第10章 综合论述
10.1Oracle连接管理器
10.1.1允许多重通讯
10.1.2外加的安全层
10.1.3多协议支持
10.1.4配置Oracle连接管理器
10.2 时间
10.3PL/SQL中的调整
10.3.1在转返段中指明事务
10.3.2会话控制
10.4验证数据库文件的完整性
10.5WorldWideWeb上的资源
10.6备用数据库设施
10.6.1创建备用数据库
10.6.2调理备用数据库
10.6.3两个站点间的名字差异
10.6.4激活备用数据库
10.6.5产品及备用参数的同步
10.7调整数据库备份
10.7.1调整卸出和装人
10.7.2调整在线备份
10.8调整数据库恢复
10.9扩展ROWID
10.10 对付DBA错误的方法
10.10.1后台进程跟踪文件
10.10.2数据库自由空间
10.10.3用户临时段
10.10.4 失控进程
10.10.5双任务研究
10.112000年日期掩码
10.12事务控制功能
10.13有效的资源管理
10.13.1提交语句的频率
10.13.2利用PL/SQL的光标管理
10.14簇（Clusters）
10.14.1索引簇
10.14.2杂凑簇
10.15PL/SQL文件I/O
10.15.1文件句柄说明
10.15.2打开文件
10.15.3写文件
10.158154关闭文件
10.15.5把各段放到一起
10.16本章小结
10.17Oracle7.x说明
第11章 脚本和技巧
11.1备份数据库的技巧
11.2主备份阶段
11.3空间管理技巧
11.3.1区域监视
11.3.2连续空间的监视
11.3.3监视表空间的自由空间
11.4用户信息
11.5访问所有V＄和DBA＿字典视图
11.6设置共享池大小
11.7使用SGA中的数据库块缓冲区
11.8创建实例控制文件
11.9重命名某个表中的表列
11.10利用SQL写SQL
11.11重建存储对象
11.11.1重建软件包的代码
11.11.2重建过程和函数的代码
11.11.3编译全模式
11.12本章小结
11.13Oracle7.x说明
附录A 本书中使用过的表
附录B 对象管理
B.1访问一个Oracle8数据库
B.2SQL程序设计器
B.2.1数据库浏览器
B.2.2脚本生成器
B.3帮助调整进程
B.4联系地址
附录C 在NT上创建第二个数据库

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8优化技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>新版Oracle 8故障解决手册
目 录
贺辞
序
译者序
引言
前言
第一部分 Oracle数据库 工具与连接性
第1章 MS－WindowsNT上的预防性维护
1.1Oracle8产品选项
1.2安装前的任务
1.2.1检测资源的有效性
1.2.2备份配置信息
1.2.3其他任务
1.2.4用文件服务器安装的特殊任务
1.3了解Oracle安装程序及在WindowsNT上的安装过程
1.3.1概述
1.3.2重要的安装文件
1.3.3可安装的产品/组件
1.3.4安装过程
1.4安装后的任务
1.4.1备份配置信息
1.4.2运行脚本创建工具所需要的表
1.4.3添加环境变量
1.5五种安装类型
1.5.1Oracle单机安装
1.5.2Oracle的客户机/服务器安装
1.5.3三层安装
1.5.4第三方产品
1.5.5非Oracle的RDBMS
1.6优化WindowsNT
1.6.1内存
1.6.2CPU
1.6.3物理输入/输出
1.6.4Oracle8性能监视器
1.6.5EXPLAINPLAN
1.6.6实例优化脚本
1.7备份WindowsNT上的Oracle8Server
1.7.1冷备份
1.7.2在线备份
1.8常见问题
第2章 MS－Windows95上的预防性维护
2.1安装前的任务
2.1.1检查资源的有效性
2.1.2备份配置信息
2.1.3其他任务
2.1.4为网络驱动器指定一个固定的盘符
2.2了解Oracle在Windows95上的安装程序和安装过程
2.2.1概述
2.2.2重要的安装文件
2.2.3可安装的产品和组件
2.2.4安装过程
2.3安装后的任务
2.3.1备份配置信息
2.3.2创建系统表
2.3.3添加环境变量
2.4四种安装类型
2.4.1单机安装
2.4.2客户机/服务器安装
2.4.3第三方产品安装
2.4.4非OracleRDBMS安装
2.5优化
2.5.1硬盘优化
2.5.2 虚拟内存
2.6常见问题
第3章 Solaris中的预防性维护
3.1安装前的任务
3.1.1检测资源的有效性
3.1.2配置UNIX环境
3.2SunSolaris2.x中的Oracle安装过程
3.2.1预览Oracle安装程序
3.2.2重要安装文件
3.2.3可安装的产品和组件
3.2.4使用Oracle安装程序安装
3.2.5重新链接可执行的Oracle产品
3.3两种安装类型
3.3.1单机安装
3.3.2客户机/服务器安装
3.4常见问题
第4章 UNIX上的预防性维护
4.1配置UNIX环境
4.2重新链接可执行的Oracle产品
4.3配置共享内存和信号量
4.4核心转储
4.5建立永久性活动域
4.6常见问题
第5章 解决RDBMS问题
5.1性能优化
5.1.1优化内存
5.1.2优化输入/输出
5.1.3优化排序
5.1.4优化索引建立
5.2备份和恢复
5.2.1备份提示
5.2.2恢复
5.3Oracle8Server诊断特性
5.3.1Oracle跟踪文件
5.3.2设置跟踪事件
5.3.3V＄监视视图
5.3.4锁实用程序
5.4Oracle错误分析和解决方案
5.4.1常见Oracle错误
5.4.2Oracle内部错误
5.4.3优先权1/优先权2问题分类和诊断操作
5.5常见问题
第6章 解决连接性问题
6.1Net8概述
6.2安装Net8
6.2.1在UNIX上安装Net8
6.2.2在WindowsNT上安装Net8
6.3多线程服务器
6.3.1MTS的配置
6.3.2监听器注册
6.3.3客户机连接
6.4OracleNames
6.5Net8跟踪
6.5.1跟踪级
6.5.2解释Net8跟踪信息
6.5.3包信息
6.5.4错误输出
6.6ODBC概述
6.7安装ODBC
6.7.1WindowsNT中的ODBC配置
6.7.2测试ODBC驱动程序
6.8Net8Assistant
6.9Net8主机名解析
6.10常见问题
第7章 解决应用开发工具的问题
7.1Developer/2000的安装
7.2Developer/2000的环境变量
7.3升级Developer/2000
7.3.1GUI的区别
7.3.2升级过程概述
7.4Designer/2000的安装
7.5常见问题
第8章 解决Oracle预编译器问题
8.1用预编译器开发程序
8.2对浮点数和双精度数的处理
8.3字符串和可变字符串的处理
8.4长原型数据
8.5C＋＋编译器
8.6不同操作系统所支持的编译器
8.7常见问题
第二部分 Intemet计算结构与Oracle应用服务器
第9章 Internet计算结构
9.1Internet计算
9.2Oracle的Internet计算结构
9.3ICA环境的故障解决方法
9.3.1ICA的基本组件
9.3.2性能
9.3.3调试错误
第10章Oracle Application Server
10.1OracleApplicationServer结构
10.2孤立OracleApplicationServer中的问题
10.2.1一个Web请求示例
10.2.2内插件交换举例
10.2.3监视工具
10.3安装OracleApplicationServer
10.3.1计划安装
10.3.2选择用户标识符
10.3.3选择端口
10.3.4选择主机名
10.4解决OracleWeb监听器的故障问题
10.4.1启动问题
10.4.2关闭问题
10.4.3多主机和无效的虚拟主机错误
10.4.4第三方的监听器
10.4.5监听器的可测性和性能优化
10.5解决WebRequestBroker的故障
10.5.1启动问题
10.5.2关闭问题
10.5.3软插件结构
10.5.4内部错误故障解决方法
10.5.5PL/SQL软插件故障解决方法
10.5.6Java软插件故障解决方法
10.5.7LiveHTML软插件故障解决方法
10.5.8可测性与性能优化
10.6OracleApplicationServer登录
10.6.1系统状态登录
10.6.2每条请求的登录
10.7OracleApplicationServer的安全性
10.7.1授权类型
10.7.2授权服务器
10.7.3授权服务器配置的故障解决方法
10.7.4建立安全的Web会话
10.8向OSS报告OracleApplicationServer的问题
10.8.1测试事例指南
10.8.2重现间歇性问题
10.8.3登录已格式化好的疵漏
10.8.4用WebStone强化测试
第三部分 核心应用
第11章 OracleApplications介绍
11.1什么是OracleApplications
11.2产品系列
11.3Applications发行版
11.4 应用结构
11.4.1字符模式客户机
11.4.2SmartClient
11.4.3网络计算结构
11.4.410SC和NCAGUI特点
11.4.5R11
11.52000年问题的准备
第12章 OracleApplicationsR10.7的安装
12.1结构规划
12.1.1所需要的文档
12.1.2技术栈认证
12.1.3系统要求
12.1.4软件要求
12.2 建立应用技术栈
12.2.1安装OracleServer和Oracle工具
12.2.2应用OracleServer和工具的补丁
12.2.3创建数据库与管理空间
12.2.4在技术栈中安装附加的Oracle软件
12.3安装OracleApplications
12.3.1安装前的任务
12.3.2装载应用数据到数据库
12.3.3安装后的任务
12.4 安装R10SmartClient
12.4.1OracleApplications数据库服务器更新
12.4.2开发客户机软件
12.5安装网络计算结构
12.5.1安装UNIXFormsServer
12.5.2在NT平台上安装Forms Server
12.6服务器分区
12.7互操作性补丁
12.8安装的核查清单
12.92000年问题的准备
12.9.1OracleApplications与RR日期格式
12.9.2Oracle服务器与RR日期格式
12.10 常见问题（FAQ）
第13章 升级和移植
13.1升级试验
13.1.1选择升级试验方法
13.1.2拷贝产品数据库
13.1.3升级数据库和工具及应用补丁
13.1.4完成升级前的操作步骤
13.1.5卸载及重新链接应用代码
13.1.6运行AutoInstall
13.1.7完成升级后的操作步骤
13.1.8分析升级试验
13.2将OracleApplications从字符/SmartClient移植到10.7NCA
13.2.1NCA结构
13.2.2补丁结构
13.2.3补丁集和其他补丁
13.3产品升级
13.4常见问题
第14章 AOL故障解决方法
14.1OracleAlert
14.1.1建立OracleAlert
14.1.2应答处理
14.1.3阈值组
14.1.4升迁组
14.1.5警告的故障解决方法
14.2并发管理器
14.2.1概述
14.2.2 并发管理器和事务管理器的维护
14.2.3定制并发管理器
14.2.4故障解决方法/常见问题
14.3软字段
14.3.1软字段概念介绍
14.3.2常见问题
14.4打印机
14.4.1引言
14.4.2打印机的建立
14.4.3故障解决方法
14.5报表
14.5.1OracleApplications报表和并发管理器接口
14.5.2位图报表
14.5.3重要的环境变量
14.5.4登记定制报表
14.5.5故障解决方法提示
14.5.6常见问题
14.6Oracle工作流
14.6.1引言
14.6.2主要组件
14.6.3术语
14.6.4创建工作流进程
14.6.5OracleWorkflow表格
14.6.6并发程序
14.6.7保证工作流监视器和工作流Web页面的安全
14.6.8实用程序和诊断工具
14.6.9常见问题
14.7一般性保护错误
14.7.1概述
14.7.2故障解决项目
14.7.3故障解决工具
第15章 有效利用OSS
15.1Oracle支持服务机构
15.1.1工具和术语
15.1.2与支持部联系
15.1.3支持分析员做什么
15.1.4角色和职责
15.1.5支持处理过程
15.2登录有效的TAR
15.2.1使TAR要求最小化
15.2.2准备
15.2.3定义TAR的严重级
15.3提高用户支持服务质量的步骤
15.3.1问题归档―提前准备
15.3.2登录电子TAR
15.3.3定义用于支持的用户内部进程
15.3.4管理用户进程
15.3.5有效地通信
15.3.6拥有适当的部件
15.3.7拥有适当的技能集
15.3.8管理定制
15.3.9使用逐步升级处理
15.3.10评估工程计划
15.3.11安装与升级
15.3.12做备份
15.3.13加入Oracle Applications用户组
15.3.14填写用户调查
15.4结论

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>新版Oracle 8故障解决手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle DBA电子商务指南
译者序
前言
第一部分 问题介绍
第二部分 商业电子化
第三部分 处理关键问题
第四部分 部署系统
附录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle DBA电子商务指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库体系结构和管理
第1章 Oracle数据库管理系统的体系结构
第2章 管理Oracle实例
第3章 Oracle的存储分配和管理
第4章 建立数据库和数据字典
第5章 物理文件的管理
第6章 安全管理
第7章 装载数据和重新组织数据
第8章 审计
第9章 管理表、索引、完整性
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库体系结构和管理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库指南
译者序前言开始阅读之前

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ORACLE 9i 开发教程
第1章 0racle基础
1.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ORACLE 9i 开发教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>基于Oracle应用服务器的Web开发技术
第1部分 HTML网页制作
第1章 基础知识与常用标识
第2章 多窗口的应用
第3章 表单的使用
第4章 JavaScript应用简介
第5章 利用FrontPage制作网页
第2部分 Oracle Application Server应用与开发
第6章 网络的基础知识
第7章 Web应用基础
第8章 OAS的体系结构和安装配置
第9章 IAS的安装和配置
第10章 用PL/SQL开发Web应用
第11章 开发实例
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>基于Oracle应用服务器的Web开发技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>完全接触Oracle
第1章  Oracle数据库的基本概念
1.1 Oracle数据库存的组成
……
第2章  Oracle数据库的安装和建立新的数据库
2.1 环境的设定
……
第3章  Oracle的网络连接与服务器和客户机的通信
3.1 连接通信的必条件
……
第4章  Oracle Developer程序设计的基本概念
4.1 程序操作界面
……
第5章  Oracle Developer程序设计
5.1 快速开发基本程序
……
第6章  Oracle命令速查
6.1 SQL函数
……
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>完全接触Oracle
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8服务器技术精粹
目录
第1部分 Oracle8服务器
第1章 Oracle8
1.1 最新版本的Oracle
1.2 主要的改进
1.3 Oracle8产品家族
1.4 在应用环境中装备Oracle8
1.5 小结
第2章 Oracle数据库结构
2.1 数据库体系结构
2.1.1 实例
2.2 Oracle进程
2.2.1 用户进程
2.2.2 数据写入进程
2.2.3 日志进程
2.2.4 监控进程
2.3 内存与速度
2.3.1 软件代码区
2.3.2 系统全局区（SGA）
2.3.3 程序全局区（PGA）
2.3.4 排序区
2.4 磁盘存储
2.4.1 数据文件
2.4.2 日志文件
2.4.3 支持文件
2.4.4 控制文件
2.4.5 SGA定义文件
2.4.6 日志与错误消息文件
2.5 与DBMS的连接
2.6 多处理器配置
2.7 容错
2.8 微软WindowsNT环境下的配置
2.8.1 WindowsNT下的Oracle8
2.9 小结
第3章 Oracle8的网络计算
3.1 网络计算的迅猛发展
3.1.1 汇合点（convergence）
3.1.2 Web改变一切
3.1.3 PC计算的缺陷
3.1.4 网络中心和网络计算
3.1.5 网络计算的吸引力
3.2 正在发展的技术
3.2.1 对象技术的优点
3.2.2 Java
3.2.3 CORBA
3.2.4 EnterpriseJavaBeans
3.3 一种网络计算的结构
3.3.1 网络计算结构
3.3.2 从2级到3级的计算
3.3.3 客户端
3.3.4 应用服务器
3.3.5 数据库服务器
3.4 网络计算机
3.4.1 一种典型的NC
3.4.2 NC参考说明
3.4.3 开放性问题
3.5 小结
第4章 Oracle8服务器和选项
4.1 数据库产品的选项
4.1.1 规模
4.1.2 体系结构
4.1.3 用途
4.2 OraCle8服务器
4.2.1 朝着面向对象的范型转移
4.2.2 计算机体系结构日益复杂化
4.2.3 Internet商务的激增
4.2.4 Oracle8与数据的仓库化
4.3 Oracle8企业版
4.3.1 企业级管理器性能包
4.3.2 增量与并行备份
4.3.3 即时点表空间
4.3.4 位映像索引
4.3.5 并行查询
4.3.6 并行DML
4.3.7 并行索引扫描
4.3.8 并行位映像星式查询联接
4.4 OracleLite――味道好，热量低
4.5 操作系统之战――UNIX对NT
4.5.1 微软的NT与UNIX的比较
4.6 小结
第2部分 安装、升级和迁移
第5章 实现从PC到企业服务器的规划
5.1 安装规划过程概述
5.1.1 从商业需求开始
5.1.2 有关安装的技术文档
5.1.3 README文件
5.1.4 制定你自己的安装规划
5.1.5 征求建议
5.2 系统硬件
5.3 软件模块规划
5.4 优化灵活结构
5.4.1 管理目录
5.4.2 本地目录
5.4.3 数据与日志目录
5.5 内存分配和变更
5.6 逻辑数据库设计
5.7 物理数据库设计
5.8 RAID和其他存储技术
5.9 进程选项
5.10 升级和新安装
5.10.1 要考虑的因素
5.10.2 取消计划
5.10.3 寻求支持
5.11 一个样本规划
5.12 小结
第6章 安装和升级
6.1 SunSolaris安装过程概述
6.1.1 硬件与软件要求
6.1.2 对网络产品的软件要求
6.1.3 优化灵活结构（OFA）
6.2 安装准备与安装
6.2.1 安装文档
6.3 Oracle8服务器安装后的步骤
6.3.1 新安装――恢复管理程序
6.3.2 新安装――时间序列插件
6.4把数据库向Oracle8迁移
6.4.1 拷贝数据
6.4.2 做一个测试计划
6.5 迁移实用程序
6.5.1 迁移准备
6.5.2 现有系统的备份
6.5.3 常见问题和故障检修
6.6 小结
第7章 非Oracle数据库的迁移
7.1 系统迁移面临的问题
7.1.1 系统迁移的现实
7.1.2 ANSISQL的神话
7.1.3 操作系统方面的障碍
7.1.4 Oracle联盟设计和迁移服务部
7.2 常用迁移方案
7.3 小型化
7.3.1 有关前端的考虑
7.3.2 有关数据库的考虑
7.3.3 管理方面的考虑
7.4 使用OraCle数据转换工具
7.4.1 转换工具究竟是什么
7.4.2 使用DCT做数据迁移的步骤
7.4.3 使用DCT和Oracle*Forms4.5迁移前端
7.4.4 使用DCT值吗
7.5 小结
第8章 与非Oracle数据库共存
8.1 多种数据库共存于一个环境
8.1.1 不同的操作系统
8.1.2 不同的硬件供应商
8.1.3 不同的RDBMS供应商
8.1.4 不同的范型
8.2 万能网关
8.2.1 你需要哪种类型的网关
8.3 共存和复制
8.3.1 复制的区别
8.3.2 OraCle复制服务的特点
8.4 小结
第3部分 Orac1e8组件和对象
第9章 Oracle进程
9.1 OracLe进程
9.2 Oracle主进程
9.2.1 系统监视进程
9.2.2 进程监视进程
9.2.3 数据库写入进程
9.2.4 日志写入进程
9.3 选项进程
9.3.1 归档进程
9.3.2 恢复进程
9.3.3 加锁写入进程
9.3.4 专用服务器进程
9.3.5 Net8进程
9.3.6 并行查询进程
9.3.7 WeB服务器进程
9.4 小结
第10章 Oracle内存区
10.1 在OraCle8中使用内存
10.1.1 虚拟内存
10.1.2 系统全局区
10.1.3 共享内存
10.2 系统全局区（SGA）
10.2.1 数据库缓冲器高速缓存
10.2.2 共享池
10.3 程序全局区
10.4 用户工作空间
10.4.1 Oracle应用软件内存
10.5 小结
第11章 Oracle文件
11.1 Oracle文件和它们的用途
11.2 数据文件
11.3 日志文件
11.4 控制文件
11.5 初始化和配置文件
11.6 日志和跟踪文件
11.7 文件大小的自动调整
11.8 数据分布优化
11.9 标准文件位置
11.10 小结
第12章 Oracle数据库对象
12.1 Oracle8数据库对象
12.2 表
12.3 索引
12.4 视图
12.5 同义词
12.6 存储过程和包
12.7 聚簇
12.8 序列
12.9 表空间
12.10 分区
12.11 对象数据类型
12.12 约束
12.13 小结
第13章 Oracle系统与对象权限
13.1 Oracle安全概念
13.2 系统权限
13.3 对象权限
13.3.1 表权限
13.3.2 视图权限
13.3.3 序列权限
13.3.4 过程权限
13.3.5 列权限
13.4 用户权限
13.5 开发者权限
13.6 DBA（数据库管理员）权限
13.7 数据库维护权限
13.8 监控权限
13.9 缺省权限
13.10 内部连接
13.11 哑对象所有者
13.12 一个典型的权限分配方案
13.13 小结
第14章 角色与授权
14.1 管理授权与角色
14.1.1 授权
14.1.2 角色
14.2 没有角色的授权
14.3 使用脚本捕获权限集
14.4 企业管理器中角色和授权的管理
14.5 命令行角色与授权管理
14.6 一个典型的权限分配方案
14.7 小结
第15章 Oracle8中面向对象的扩展
15.1 引言
15.2 对象的基本组成部分
15.2.1 方法
15.3 对象排序
15.3.1 映像法
15.3.2 顺序法
15.4 类型与类型的安装
15.5 REF
15.6 嵌套表和VARRAY
15.6.1 嵌套表
15.6.2 VARRAY
15.7 使用基类型
15.8 对象视图
15.8.1 INSTEADOF触发器
15.9 大对象
15.9.1 BLOB
15.9.2 CLOB
15.9.3 NCLOB
15.9.4 BFILE
15.10 小结
第16章 复制
16.1 为什么要复制
16.2 复制和数据仓库
16.3 只读复制和快照
16.3.1 快照日志
16.3.2 远程数据库
16.4 复杂的复制――分布式数据库
16.4.1 复制和虚拟数据库领域
16.4.2 创建一个复制环境“ReplicationGod”
16.4.3 复制的管理以及两阶段提交的秘密
16.5 冲突的解决方案
16.5.1 冲突的种类
16.5.2 更新冲突的管理
16.5.3 创建列组
16.5.4 为列组定义一种解决冲突的方法
16.6 抗毁性
16.7 Oracle8和复制管理器的优点
16.8 小结
第17章 查询和事务处理
17.1 事务处理
17.2 SQL语句的处理
17.2.1 游标的创建
17.2.2 语句的语法分析
17.2.3 查询处理
17.2.4 赋值变量
17.2.5 语句执行
17.2.6 并行化
17.2.7 取回返回行
17.3 使用Oracle优化器
17.3.1 优化器是如何工作的
17.3.2 优化器初始化参数
17.3.3 优化方法
17.4 使用ANALYZE 命令
17.4.1 如何运行ANALYzE命令
17.4.2 数据字典统计
17.5 分析SQL语句
17.6 使用EXPLAINPLAN和SQLTrace
17.6.1 SQLTrace
17.6.2 使用EXPLAINPLAN
17.7 设计新SQL语句
17.7.1 使用索引
17.7.2 聚簇
17.7.3 哈希聚簇
17.7.4 范围分割
17.7.5 包、过程和函数
17.8 使用提示
17.9 小结
第18章 PL/SQL包
18.1 PL/SQL包简介
18.2 创建包
18.3 包的语法概述
18.3.1 读写文件
18.3.2 处理LOB数据
18.3.3 执行动态SQL和数据定义语言语句
18.3.4 进程间通信
18.3.5 高级队列
18.3.6 调度作业
18.4小结
第4部分 Oracle8系统管理
第19章 Oracle8系统管理要求
19.1 Oracle8系统管理概述
19.2 备份和恢复概念
19.3 安全性和存取概念
19.3.1 Oracle8权限和配置文件概述
19.3.2 SQL*Net，Net8和ConnectionManager概述
19.4 表空间维护概念
19.4.1 组织的重要性
19.4.2 优化调整分布
19.4.3 调整缺省大小
19.4.4 存储碎片及设计考虑
19.5 模式维护概念
19.5.1 对象维护
19.5.2 参照完整性
19.5.3 加载/卸载表
19.5.4 调整缺省大小
19.5.5 估计对象大小
19.6 调整概念
19.6.1 谁负责调整工作
19.6.2 四级调整
19.7 其他任务
19.7.1 监视
19.7.2 故障检修
19.8 小结
第20章 日常维护和调度任务
20.1 用户、系统和批处理
20.1.1 用户处理
20.1.2 系统处理
20.1.3 监控进程
20.1.4 初始化进程
20.1.5 调度批处理进程
20.2 审计
20.2.1 允许和禁止审计
20.2.2 操作系统审计跟踪
20.2.3 数据库审计跟踪
20.2.4 AUDIT命令
20.2.5 审计的类型
20.2.6 审计选项
20.2.7 管理审计跟踪
20.2.8 审计查询举例
20.3 公共监视脚本
20.3.1 监视类型
20.3.2 监视什么
20.3.3 监视脚本举例
20.3.4 用Oracle工具监视
20.4 调度作业
20.4.1 管理作业队列
20.4.2 提交和操纵作业
20.4.3 数据字典中的作业队列信息
20.5 小结
第21章 使用EnterpriseManager管理
33.4 超大型数据库的性能调整
33.4.1 VLDB系统中的事务处理
33.4.2 回滚段问题的考虑
33.4.3 存档问题的考虑
33.5 大型数据库的操作
33.5.1 回滚段的设计
33.5.2 使用恢复管理器（RMAN）进行备份和恢复
33.5.3 类型中的类型
33.5.4 对象视图
33.5.5 VARRAY
33.6 小结

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8服务器技术精粹
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入浅出Oracle 之Form开发
第 1 部分 开发基础知识
Chapter 01
开发背景与基础1
1.1 读者基础要求2
1.2 认识EBS 架构.2
1.2.1 R12.X.X 版本架构2
1.2.2 桌面层 3
1.2.3 应用层 4
1.2.4 数据库层4
1.3 用户和常用工具.5
1.3.1 区分三类用户 5
1.3.2 Form 开发使用的用户和工具5
1.4 AOL 开发框架.6
1.4.1 导航菜单6
1.4.2 EBS 功能安全性基本原理 7
1.4.3 Form 开发模板文件Template.fmb  7
1.4.4 EBS 文件系统 8
1.5 多组织支持.11
1.6 主要示例12
1.6.1 销售订单12
1.6.2 开发需求分析12
1.6.3 其他说明13
第2 部分 Form开发基础
Chapter 02
基于EBS 的Form 开发.14
2.1 Form 文件类型.15
2.2 开发工具Forms Builder 安装15
2.2.1 开发工具版本15
2.2.2 Oracle Home16
2.2.3 基本安装过程16
2.2.4 配置TNSNAME 20
2.2.5 配置FORMS_PATH 20
2.2.6 配置NLS_LANG21
2.3 下载Template 相关文件.22
2.3.1 下载Template 模板22
2.3.2 启动Forms Builder 开发工具.22
2.3.3 打开TEMPLATE.fmb 及报错分析.23
2.3.4 下载必要的文件到FORMS_PATH 对应目录24
2.4 开发工具Forms Builder25
2.4.1 快速认识Forms Builder 环境.25
2.4.2 进入Form 设计界面26
2.4.3 对象导航器27
2.4.4 布局编辑器30
2.4.5 属性选项板31
2.4.6 Form 中常用对象介绍32
2.4.7 其他Form 设计工具35
2.5 案例：创建数据库对象36
2.5.1 创建数据量对象.36
2.5.2 注册表和字段40
2.5.3 创建用户开发Form 使用的视图.42
2.5.4 创建表操作API44
2.6 案例：从模板开始设计45
2.6.1 复制TEMPLATE.fmb.45
2.6.2 删除多余对象45
2.6.3 修改Windows 名称.46
2.6.4 修改2 个触发器、1 个程序单元.46
2.6.5 创建Block 数据块47
2.6.6 设置Block 属性及其Subclass 49
2.6.7 设置Item 属性及其Subclass49
2.6.8 创建Canvas 画布51
2.6.9 设置画布属性和子类、调整布局53
2.6.10 调整布局.55
2.6.11 调整Prompt 提示55
2.6.12 设置Window 属性.56
2.6.13 设置Form 属性56
2.7 案例：编写数据库操作触发器57
2.7.1 编写数据库操作Program Unit 57
2.7.2 编写数据库块ON-触发器64
2.8 案例：上传和编译.65
2.9 案例：在EBS 中注册运行67
2.9.1 登录EBS 67
2.9.2 注册Form67
2.9.3 定义Function 67
2.9.4 加入Menu68
2.9.5 运行Form69
Chapter 03
触发器、变量、参数、内部子程序70
3.1 触发器71
3.1.1 触发器的定义71
3.1.2 触发器的类型71
3.1.3 触发器中的代码.71
3.1.4 触发器的作用范围72
3.1.5 触发器事件72
3.1.6 常用触发器73
3.2 变量.75
3.2.1 Form 变量75
3.2.2 PL/SQL 变量76
3.2.3 Form 系统变量76
3.3 参数.77
3.3.1 Parameter 参数77
3.3.2 创建Parameter 参数78
3.3.3 初始化Parameter 参数78
3.3.4 使用Parameter 参数78
3.4 内部子程序.79
3.4.1 内部子程序的定义79
3.4.2 使用内部子程序.80
3.4.3 常用内部子程序.81
Chapter 04
List、LOV、字段和记录控制、日历82
4.1 案例：List 值列表83
4.1.1 关于List83
4.1.2 创建List83
4.1.3 删除List 条目.85
4.1.4 运行实例85
4.1.5 列表风格List Style 85
4.2 案例：LOV 窗口式值列表86
4.2.1 关于LOV 86
4.2.2 创建LOV 87
4.2.3 改进LOV 91
4.2.4 完善实例92
4.2.5 运行实例93
4.2.6 常用LOV 属性设置93
4.3 案例：字段和记录控制95
4.3.1 关于字段属性95
4.3.2 设置字段属性101
4.3.3 字段控制.102
4.3.4 记录控制.102
4.3.5 运行实例.103
4.4 案例：日历104
4.4.1 日历控件.104
4.4.2 运行实例.104
4.5 总结105
Chapter 05
行指示符、主从块、滚动条、Stacked&Tab 画布、多行文本106
5.1 案例：销售订单行107
5.1.1 创建数据库对象107
5.1.2 创建数据库块ORDER_LINES107
5.1.3 增加行指示Item107
5.1.4 设置Item 属性及其Subclass108
5.1.5 创建Canvas 画布108
5.1.6 调整布局、Prompt 提示.109
5.1.7 设置头行块互为前后导航块110
5.1.8 创建LOV 110
5.1.9 创建行块增/删/改ON-触发器.111
5.1.10 运行实例112
5.2 案例：Master-Detial 主从块112
5.2.1 关于主从块112
5.2.2 创建主从关系113
5.2.3 关于删除记录行为的说明.114
5.2.4 运行实例.115
5.3 案例：滚动条.115
5.3.1 关于滚动条115
5.3.2 设置滚动条116
5.3.3 运行实例.116
5.4 案例：Stacked（堆叠）画布117
5.4.1 创建堆叠画布117
5.4.2 设置Item 到新建的堆叠画布118
5.4.3 调整堆叠画布119
5.4.4 调整堆叠画布在主画布上的位置.120
5.4.5 运行实例.122
5.5 画布小结123
5.5.1 子类与画布123
5.5.2 从UI 角度看对象关系.124
5.6 案例：Tab 画布.125
5.6.1 创建Tab 画布和标签页125
5.6.2 设置Item 到标签页并调整布局.125
5.6.3 调整主画布布局126
5.6.4 运行实例.128
5.7 案例：控制Tab 画布.128
5.7.1 控制思路.128
5.7.2 控制代码.129
5.7.3 运行实例.131
5.8 案例：多行文本框132
5.8.1 关于多行文本框132
5.8.2 运行实例.132
第3 部分 Form开发进阶
Chapter 06
LOV 查询、块查询、Button133
6.1 查询原理134
6.1.1 【F11】查询原理134
6.1.2 理解其他查询134
6.2 案例：LOV 查询135
6.2.1 什么是LOV 查询135
6.2.2 创建LOV 查询135
6.2.3 运行实例.136
6.3 案例：块查询.137
6.3.1 什么是块查询137
6.3.2 复制标准查询块137
6.3.3 修改标准查询块138
6.3.4 创建查询条件Item 139
6.3.5 修改块触发器139
6.3.6 修改目标Item 查询长度140
6.3.7 对于几个内置查询子程序的说明.140
6.3.8 运行实例.141
6.4 案例：Button 141
Chapter 07
触发器层次关系、常用触发器编写规范143
7.1 理解层次关系.144
7.1.1 说明144
7.1.2 WHEN-VALIDATE-ITEM 例子.144
7.2 触发器原理145
7.2.1 触发器堆栈145
7.2.2 常用触发器及其执行顺序.146
7.3 基于EBS 模板开发的触发器146
7.4 对触发器的一些理解.148
7.4.1 On-Lock148
7.4.2 Pre-Form 和When-New-Form-Instance148
7.4.3 Post-Query 和When-New-Record-Instance149
7.4.4 When-Validate-Item 和When-Validate-Record149
Chapter 08
说明性弹性域、键弹性域、键弹性域查询150
8.1 说明性弹性域开发151
8.1.1 关于说明性弹性域.151
8.1.2 基表要求：基表中需含有1 个结构字段和若干个自定义字段151
8.1.3 注册要求：注册表和字段到EBS 中152
8.1.4 字段要求：一个非数据库项156
8.1.5 触发器要求：Form 级.157
8.1.6 触发器要求：块级.157
8.1.7 触发器要求：Item 级157
8.1.8 启用弹性域158
8.1.9 运行实例.159
8.2 键弹性域开发.159
8.2.1 关于键弹性域159
8.2.2 基表要求：基表中需含有1 个ID 字段160
8.2.3 字段要求：一个键代码组合字段+一个可选的键描述组合字段160
8.2.4 触发器要求：Form 级.161
8.2.5 触发器要求：块级.162
8.2.6 触发器要求：Item 级162
8.2.7 运行实例.163
8.2.8 开发客户化键弹性域163
第4 部分 Folder和JTF Grid
Chapter 09
Folder、JTF Grid 开发164
9.1 Folder 开发步骤（从头开始）.165
9.1.1 什么是Folder 165
9.1.2 创建数据库对象165
9.1.3 复制TEMPLATE.fmb 开发Form167
9.1.4 复制标准Folder 对象167
9.1.5 引用Folder 的PLL 库.167
9.1.6 创建Folder 块168
9.1.7 修改Folder 块169
9.1.8 创建Prompt 块.170
9.1.9 修改Prompt 块和Folder 块171
9.1.10 Folder 自动布局原理.172
9.1.11 创建堆叠画布、内容画布、窗口172
9.1.12 布局Item 到画布.173
9.1.13 调整画布布局及位置.174
9.1.14 追加Form 级触发器175
9.1.15 设置Form 第一导航块.177
9.1.16 运行实例177
9.1.17 高级Folder 功能178
9.2 Folder 开发步骤（基于模板）.178
9.2.1 基于模板新建Form178
9.2.2 创建数据块178
9.2.3 创建标题块179
9.2.4 修改数据块179
9.2.5 修改标题块179
9.2.6 修改触发器179
9.3 JTF Grid 开发步骤180
9.3.1 关于JTF Grid 180
9.3.2 复制TEMPLATE.fmb 开发Form180
9.3.3 复制标准JTF Grid 对象.180
9.3.4 引用JTF Grid 的PLL 库181
9.3.5 创建数据库对象181
9.3.6 定义CRM 电子表格.182
9.3.7 创建Grid 块183
9.3.8 修改Grid 块183
9.3.9 布局Item 到画布183
9.3.10 追加Form 级触发器184
9.3.11 编写Find Button 触发器184
9.3.12 处理选择事件.185
9.3.13 运行实例186
第5 部分 多语言开发和附件开发
Chapter 10
多语言开发187
10.1 国际化支持188
10.2 Form 自身的多语言版本188
10.3 数据多语言开发步骤189
10.3.1 数据库对象的要求：基表B189
10.3.2 数据库对象的要求：多语言表TL 190
10.3.3 数据库对象的要求：视图VL190
10.3.4 数据库对象的要求：表操作API191
10.3.5 Form 对象的要求：2 个Form 级触发器193
10.3.6 Form 对象的要求：5 个Block 级触发器193
10.3.7 Form 对象的要求：多语言字段在画布的显示194
10.4 EBS 启用新语言时的考虑195
10.4.1 EBS 启用新语言的过程195
10.4.2 Maintain Multi-lingual Tables 核心过程195
10.4.3 如何客户化196
Chapter 11
附件开发.197
11.1 关于附件.198
11.2 标准附件设置198
11.2.1 表及其关系198
11.2.2 定义Entity 实体198
11.2.3 定义Categories 类别199
11.2.4 定义Attachement Function200
11.2.5 定义Function 和Category 关联201
11.2.6 定义启用附件的Block202
11.2.7 定义Block-Entity 关系.203
11.2.8 定义关键字204
11.2.9 使用过程205
第6 部分 JavaBean
Chapter 12
JavaBean 206
12.1 Form 与Java207
12.1.1 Form 就是Java207
12.1.2 关于Implementation Class207
12.1.3 Form 中的Java 类规范.208
12.1.4 Form 与Java 类的交互.208
12.1.5 Form 中使用自定义JavaBean209
12.2 案例：Hello World 210
12.2.1 功能.210
12.2.2 按规范编写Java 类：BeanTemplate.java 210
12.2.3 编译：BeanTemplate.class 212
12.2.4 制作JAR 认证文件.213
12.2.5 打包JAR 214
12.2.6 认证JAR 214
12.2.7 服务器配置JavaBean 程序.214
12.2.8 Form 中使用BeanTemplate 215
12.3 案例：CSV 通用导入.217
12.3.1 功能.217
12.3.2 设计思路217
12.3.3 表设计217
12.3.4 设置Form.219
12.3.5 导入Form.219
12.3.6 通用导入安装.221
12.3.7 具体开发使用.221
第7 部分 个性化
Chapter 13
Form 个性化.223
13.1 Form 个性化概述224
13.1.1 个性化与客户化224
13.1.2 个性化原理225
13.2 案例：修改字段Prompt 225
13.2.1 打开欲个性化的Form，调出个性化定义界面225
13.2.2 输入个性化条件、个性化内容226
13.3 案例：有条件显示消息.227
13.3.1 打开欲个性化的Form，调出个性化定义界面227
13.3.2 输入个性化条件227
13.3.3 输入个性化Action228
13.4 案例：调用数据库Package.228
13.4.1 条件中调用Package 228
13.4.2 Action 中调用Package228
13.5 案例：添加菜单.229
13.5.1 打开欲个性化的Form，调出个性化定义界面229
13.5.2 输入个性化Action229
13.6 案例：打开功能.230
13.6.1 打开欲个性化的Form，调出个性化定义界面230
13.6.2 输入个性化条件230
13.6.3 输入个性化Action231
13.7 案例：执行查询.231
13.7.1 打开欲个性化的Form，调出个性化定义界面231
13.7.2 输入个性化条件232
13.7.3 输入个性化Action232
13.8 案例：其他应用.233
13.9 CUSTOM.PLL 实现个性化.233
13.9.1 建议使用的方法233
13.9.2 编译脚本234
13.9.3 CUSTOM 中的Function 和Procedure 简介.234
13.10 个性化迁移.237
第8 部分 Form开发规范及常用代码参考
Chapter 14
Form 开发规范（建议）及常用代码参考238
14.1 命名规约.239
14.1.1 文件命名规约.239
14.1.2 Form 对象命名规约239
14.2 Form 按钮常用快捷键242
14.3 Form 程序单元命名规则243
14.4 编程规范及常用代码244
14.4.1 布局规范244
14.4.2 Form 各对象的布局要求.245
14.4.3 子类属性246
14.4.4 触发器编程规范248
14.4.5 WHO 字段的维护253
14.4.6 基于视图块的数据更新253
14.4.7 动态控制Item 属性258
14.4.8 消息的输出259
14.4.9 日历的使用259
14.4.10 菜单和工具条的使用260
14.4.11 Window 的打开265
14.4.12 Window 的关闭266
14.4.13 Window 的标题设定266
14.4.14 异常处理266
14.4.15 Form 中的变量267
14.4.16 Item 的初始值属性267
14.4.17 库存组织访问267
14.4.18 树形Form 开发268
14.4.19 其他注意事项269
附录.273
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入浅出Oracle 之Form开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 12c PL/SQL开发指南（第7版）
第Ⅰ部分 Oracle PL／SQL
第1章 Oracle PL／SQL程序开发概览 3
1.1 PL／SQL的历史和背景 4
1.2 Oracle开发架构 6
1.2.1 数据库 7
1.2.2 PL／SQL语言 8
1.2.3 Oracle处理架构 10
1.2.4 两层模型 11
1.2.5 n层模型 12
1.3 本章小结 13
1.4 精熟测验 13
第2章 新特性 15
2.1 SQL新特性 16
2.1.1 用数据目录DIRECTORY限定LIBRARY对象 16
2.1.2 使用有效时间（VT）来定义表 17
2.1.3 增强的Oracle原生LEFT OUTER JOIN语法 18
2.1.4 基于序列的列的默认值 18
2.1.5 显式NULL插入的默认值 19
2.1.6 标识列 20
2.1.7 STRING和RAW类型大小限制的增加 21
2.1.8 将SQL语句的结果传递给外部程序 21
2.1.9 查询行限制和偏移的原生SQL支持 23
2.1.10 MySQL应用程序的Oracle数据库驱动程序 26
2.1.11 SQL CROSS APPLY、OUTER APPLY和LATERAL 26
2.1.12 BEQUEATH CURRENT_USER视图 28
2.2 PL／SQL新特性 28
2.2.1 调用者权限函数的缓存 29
2.2.2 添加PL／SQL程序单元调用者到白名单 29
2.2.3 PL／SQL类型的原生客户端API支持 30
2.2.4 新的PL／SQL包utl_call_stack 30
2.2.5 dbms_utility包添加了expand_sql_txt子程序 30
2.2.6 dbms_sql包为parse过程添加了新的模式 32
2.2.7 SQL WITH子句中的PL／SQL函数 32
2.2.8 SQL中允许PL／SQL特定的数据类型 33
2.2.9 隐式的REF CURSOR参数绑定 36
2.3 支持脚本 36
2.4 本章小结 36
2.5 精熟测验 36
第3章 PL／SQL基础知识 39
3.1 块结构 40
3.1.1 执行块 40
3.1.2 基本块结构 41
3.1.3 声明块 43
3.1.4 异常块 44
3.2 块中变量的行为 45
3.2.1 匿名块 45
3.2.2 嵌套匿名块 49
3.2.3 局部命名块 51
3.2.4 存储命名块 54
3.3 基本标量和复合数据类型 56
3.3.1 标量数据类型 56
3.3.2 属性和表的锚定 58
3.3.3 复合数据类型 60
3.4 控制结构 72
3.4.1 条件结构 72
3.4.2 迭代结构 74
3.5 异常 81
3.5.1 用户自定义异常 82
3.5.2 动态的用户自定义异常 84
3.6 批量操作 84
3.7 函数、过程和包 86
3.7.1 函数 87
3.7.2 过程 88
3.7.3 包 90
3.8 事务作用域 94
3.8.1 单事务作用域 95
3.8.2 多事务作用域 96
3.9 数据库触发器 96
3.10 本章小结 97
3.11 精熟测验 97
第4章 语言基本知识 99
4.1 词汇单元 99
4.1.1 分隔符 100
4.1.2 标识符 103
4.1.3 字面值 105
4.1.4 注释 106
4.2 变量和数据类型 107
4.2.1 变量数据类型 108
4.2.2 标量数据类型 111
4.2.3 大对象 125
4.2.4 复合数据类型 126
4.2.5 系统引用游标 130
4.3 本章小结 132
4.4 精熟测验 132
第5章 控制结构 134
5.1 条件语句 135
5.1.1 IF语句 141
5.1.2 CASE语句 145
5.1.3 条件编译语句 147
5.2 迭代语句 150
5.2.1 简单循环语句 150
5.2.2 FOR循环语句 156
5.2.3 WHILE循环语句 158
5.3 游标结构 161
5.3.1 隐式游标 162
5.3.2 显式游标 166
5.4 批语句 177
5.4.1 BULK COLLECT INTO语句 178
5.4.2 FORALL语句 182
5.5 支持脚本 187
5.6 本章小结 187
5.7 精熟测验 187
第6章 集合 189
6.1 集合介绍 190
6.2 对象类型：变长数组和表集合 192
6.2.1 变长数组集合 192
6.2.2 表集合 195
6.3 关联数组 209
6.4 Oracle集合API 216
6.4.1 COUNT方法 218
6.4.2 DELETE方法 219
6.4.3 EXISTS方法 220
6.4.4 EXTEND方法 221
6.4.5 FIRST方法 222
6.4.6 LAST方法 222
6.4.7 LIMIT方法 223
6.4.8 NEXT方法 223
6.4.9 PRIOR方法 224
6.4.10 TRIM方法 224
6.5 支持脚本 226
6.6 本章小结 226
6.7 精熟测验 226
第7章 错误管理 228
7.1 异常类型和作用域 229
7.1.1 编译时错误 230
7.1.2 运行时错误 232
7.2 异常管理内置函数 238
7.3 用户定义的异常 240
7.3.1 声明用户定义的异常 240
7.3.2 动态的用户定义的异常 242
7.4 异常堆栈函数 245
7.5 支持脚本 250
7.6 本章小结 250
7.7 精熟测验 251
第Ⅱ部分 PL／SQL编程
第8章 函数和过程 255
8.1 函数和过程架构 256
8.2 事务作用域 262
8.2.1 调用子例程 263
8.2.2 位置表示法 264
8.2.3 命名表示法 264
8.2.4 混合表示法 264
8.2.5 排除表示法 264
8.2.6 SQL调用表示法 265
8.3 函数 265
8.3.1 函数模型选择 267
8.3.2 创建选项 267
8.3.3 按值传递函数 279
8.3.4 按引用传递函数 291
8.4 过程 294
8.4.1 按值传递过程 295
8.4.2 按引用传递过程 297
8.5 支持脚本 299
8.6 本章小结 300
8.7 精熟测验 300
第9章 包 302
9.1 包架构 303
9.2 包规范 308
9.2.1 原型特性 309
9.2.2 连续可重用预编译器指令 311
9.2.3 变量 312
9.2.4 类型 314
9.2.5 组件：函数与过程 316
9.3 包主体 318
9.3.1 原型特性 318
9.3.2 变量 320
9.3.3 类型 322
9.3.4 组件：函数与过程 323
9.4 定义者与调用者权限模型 326
9.5 管理数据库目录中的包 329
9.5.1 查找、验证和描述包 329
9.5.2 检查依赖关系 330
9.5.3 比较验证方法：时间戳与签名 331
9.6 本章小结 332
9.7 精熟测验 332
第10章 大对象 334
10.1 使用内部存储的LOB类型 335
10.1.1 低于32K的LOB赋值 335
10.1.2 高于32K的LOB赋值 337
10.2 将文件读入内部存储的列 345
10.2.1 将本地文件读入CLOB或NCLOB列 346
10.2.2 将本地文件读入BLOB列 348
10.2.3 通过Web页面处理LOB 351
10.3 使用二进制文件（BFILE） 358
10.3.1 创建和使用虚拟目录 359
10.3.2 读取规范路径名与文件名 365
10.4 了解dbms_lob包 371
10.4.1 包常量 371
10.4.2 包异常 373
10.4.3 打开与关闭方法 373
10.4.4 操作方法 374
10.4.5 内省方法 380
10.4.6 BFILE方法 384
10.4.7 临时LOB方法 385
10.4.8 安全链接方法 387
10.5 支持脚本 390
10.5.1 从LONG转换为CLOB的脚本 390
10.5.2 管理来自于文件系统的LOB 390
10.5.3 通过Web管理CLOB和BLOB LOB 390
10.5.4 通过Web管理
BFILE LOB 390
10.6 本章小结 391
10.7 精熟测验 391
第11章 对象类型 393
11.1 对象基础知识 396
11.1.1 声明对象类型 396
11.1.2 实现对象主体 399
11.1.3 对象类型白名单 403
11.1.4 getter和setter 404
11.1.5 静态成员方法 406
11.1.6 比较对象 408
11.2 继承和多态 415
11.2.1 声明子类 416
11.2.2 实现子类 417
11.2.3 类型演变 421
11.3 实现对象类型集合 422
11.3.1 声明对象类型集合 422
11.3.2 实现对象类型集合 423
11.4 支持脚本 426
11.5 本章小结 426
11.6 精熟测验 426
第12章 触发器 429
12.1 触发器简介 430
12.2 数据库触发器架构 432
12.3 数据定义语言触发器 435
12.3.1 事件属性函数 437
12.3.2 构建DDL触发器 448
12.4 数据操作语言触发器 450
12.4.1 语句级触发器 451
12.4.2 行级触发器 453
12.5 复合触发器 460
12.6 Instead of触发器 464
12.7 系统和数据库事件触发器 468
12.8 触发器限制 470
12.8.1 最 大触发器尺寸 470
12.8.2 SQL语句 470
12.8.3 LONG和LONG RAW数据类型 471
12.8.4 变异表 471
12.8.5 系统触发器 472
12.9 支持脚本 473
12.10 本章小结 473
12.11 精熟测验 473
第13章 动态SQL 475
13.1 动态SQL架构 476
13.2 本地动态SQL（NDS） 477
13.2.1 动态语句 478
13.2.2 带输入的动态语句 481
13.2.3 带输入和输出的动态语句 483
13.2.4 带未知数量的输入的动态语句 486
13.3 dbms_sql包 488
13.3.1 动态语句 489
13.3.2 带输入变量的动态语句 492
13.3.3 带输入变量和固定输出的动态语句 494
13.3.4 带输入和输出变量的动态语句 498
13.3.5 dbms_sql包定义 503
13.4 支持脚本 516
13.5 本章小结 517
13.6 精熟测验 517
第Ⅲ部分 附录和术语表
附录A Oracle数据库入门 521
A.1 Oracle数据库架构 522
A.2 启动和停止Oracle
Database 12c服务器 528
A.2.1 UNIX或Linux操作 529
A.2.2 Microsoft Windows操作 533
A.3 启动和停止Oracle侦听器 534
A.4 多版本并发控制 539
A.4.1 数据事务 540
A.4.2 DML锁定和隔离控制 542
A.5 定义者权限和调用者权限 543
A.5.1 定义者权限 544
A.5.2 调用者权限 544
A.6 SQL交互和批处理 545
A.6.1 SQL*Plus命令行界面 545
A.6.2 Oracle SQL Developer界面 564
A.7 数据库管理员 570
A.7.1 配置用户 570
A.7.2 使用数据库约束 577
A.7.3 安全加固 586
A.7.4 数据管理 595
A.8 SQL调优 597
A.8.1 EXPLAIN PLAN语句 598
A.8.2 DBMS_XPLAN包 599
A.9 SQL跟踪 603
A.9.1 跟踪会话状态 603
A.9.2 将原始跟踪文件转换为可读跟踪文件 605
A.10 本附录小结 606
附录B SQL入门 607
B.1 Oracle SQL数据类型 610
B.2 数据定义语言（DDL） 614
B.2.1 CREATE语句 615
B.2.2 ALTER语句 675
B.2.3 RENAME语句 691
B.2.4 DROP语句 691
B.2.5 TRUNCATE语句 694
B.2.6 COMMENT语句 694
B.3 数据管理语言（DML） 694
B.3.1 符合ACID的事务 695
B.3.2 INSERT语句 698
B.3.3 UPDATE语句 712
B.3.4 DELETE语句 724
B.3.5 MERGE语句 728
B.4 事务控制语言（TCL） 735
B.5 查询：SELECT语句 736
B.5.1 返回列或者返回列运算结果的查询 738
B.5.2 聚合查询 751
B.5.3 选择性返回列或结果的查询 756
B.5.4 联接结果 765
B.5.5 数据的联接 767
B.5.6 集合的联接 775
B.6 本附录小结 778
附录C SQL内置函数 779
C.1 字符函数 780
C.1.1 ASCII函数 780
C.1.2 ASCIISTR函数 780
C.1.3 CHR函数 781
C.1.4 CONCAT函数 781
C.1.5 INITCAP函数 782
C.1.6 INSTR函数 782
C.1.7 LENGTH函数 783
C.1.8 LOWER函数 783
C.1.9 LPAD函数 784
C.1.10 LTRIM函数 784
C.1.11 REPLACE函数 785
C.1.12 REVERSE函数 785
C.1.13 RPAD函数 785
C.1.14 RTRIM函数 786
C.1.15 UPPER函数 786
C.2 数据类型转换函数 787
C.2.1 CAST函数 787
C.2.2 CONVERT函数 789
C.2.3 TO_CHAR函数 790
C.2.4 TO_CLOB函数 792
C.2.5 TO_DATE函数 792
C.2.6 TO_LOB函数 793
C.2.7 TO_NCHAR函数 794
C.2.8 TO_NCLOB函数 795
C.2.9 TO_NUMBER函数 795
C.3 日期—时间转换函数 796
C.3.1 ADD_MONTHS函数 796
C.3.2 CURRENT_DATE函数 796
C.3.3 CURRENT_TIMESTAMP函数 796
C.3.4 DBTIMEZONE函数 797
C.3.5 EXTRACT函数 797
C.3.6 FROM_TZ函数 798
C.3.7 LAST_DAY函数 798
C.3.8 LOCALTIMESTAMP函数 799
C.3.9 MONTHS_BETWEEN函数 799
C.3.10 NEW_TIME函数 799
C.3.11 ROUND函数 800
C.3.12 SYSDATE函数 801
C.3.13 SYSTIMESTAMP函数 801
C.3.14 TO_CHAR（date）函数 801
C.3.15 TO_DSINTERVAL函数 802
C.3.16 TO_TIMESTAMP函数 803
C.3.17 TO_TIMESTAMP_TZ函数 803
C.3.18 TO_YMINTERVAL函数 804
C.3.19 TRUNC（date）函数 804
C.3.20 TZ_OFFSET函数 804
C.4 集合管理函数 805
C.4.1 CARDINALITY函数 805
C.4.2 COLLECT函数 805
C.4.3 POWERMULTISET函数 809
C.4.4 POWERMULTISET_BY_CARDINALITY函数 809
C.4.5 SET函数 810
C.5 集合运算符 810
C.5.1 CARDINALITY运算符 812
C.5.2 EMPTY运算符 812
C.5.3 MULTISET运算符 812
C.5.4 MULTISET EXCEPT运算符 813
C.5.5 MULTISET INTERSECT运算符 814
C.5.6 MULTISET UNION运算符 814
C.5.7 SET运算符 815
C.5.8 SUBMULTISET OF运算符 816
C.6 数字函数 816
C.6.1 CEIL函数 817
C.6.2 FLOOR函数 817
C.6.3 MOD函数 817
C.6.4 POWER函数 819
C.6.5 REMAINDER函数 820
C.6.6 ROUND函数 821
C.7 错误报告函数 821
C.7.1 SQLCODE函数 821
C.7.2 SQLERRM函数 822
C.8 杂项函数 823
C.8.1 BFILENAME函数 824
C.8.2 COALESCE函数 826
C.8.3 DECODE函数 826
C.8.4 DUMP函数 827
C.8.5 EMPTY_BLOB函数 828
C.8.6 EMPTY_CLOB函数 830
C.8.7 GREATEST函数 831
C.8.8 LEAST函数 833
C.8.9 NANVL函数 834
C.8.10 NULLIF函数 835
C.8.11 NVL函数 836
C.8.12 SYS_CONTEXT函数 836
C.8.13 TABLE函数 839
C.8.14 TREAT函数 842
C.8.15 USERENV函数 843
C.8.16 VSIZE函数 844
C.9 本附录小结 844
附录D PL／SQL内置程序包和类型 845
D.1 Oracle Database 11g和12c的新程序包 846
D.2 程序包使用示例 852
D.2.1 DBMS_APPLICATION_INFO示例 853
D.2.2 DBMS_COMPARISON 858
D.2.3 DBMS_CRYPTO 863
D.2.4 DBMS_FGA 866
D.2.5 案例研究：查询工具 867
D.3 支持脚本 874
D.4 本附录小结 874
附录E 正则表达式入门 875
E.1 正则表达式简介 876
E.1.1 字符类 876
E.1.2 校准类 880
E.1.3 元字符 880
E.1.4 元序列 880
E.1.5 字面值 881
E.2 正则表达式实现 881
E.2.1 REGEXP_COUNT函数 882
E.2.2 REGEXP_INSTR函数 885
E.2.3 REGEXP_LIKE函数 886
E.2.4 REGEXP_REPLACE函数 887
E.2.5 REGEXP_SUBSTR函数 889
E.3 支持脚本 890
E.4 本附录小结 890
附录F 包装PL／SQL代码入门 891
F.1 包装PL／SQL的限制 892
F.1.1 PL／SQL的wrap实用程序的局限性 892
F.1.2 DBMS_DDL.WRAP函数的限制 892
F.2 使用wrap命令行实用程序 893
F.3 使用DBMS_DDL命令行实用程序 893
F.3.1 WRAP函数 893
F.3.2 CREATE_WRAPPED过程 898
F.4 本附录小结 899
附录G PL／SQL分层的配置文件入门 900
G.1 配置架构 901
G.2 收集配置文件数据 902
G.3 配置文件数据 905
G.3.1 读取原始输出 905
G.3.2 定义PL／SQL配置文件表 907
G.3.3 查询分析数据 909
G.4 使用plshprof命令行实用程序 910
G.5 支持脚本 912
G.6 本附录小结 912
附录H PL／SQL保留字和关键字 913
附录I 精熟测验答案 927
术语表 951
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Database 12c PL/SQL开发指南（第7版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 数据库管理员日常操作手册
目  录
第一篇　Oracle 12c SQL	1
第1章　SQL *Plus的使用	1
1.1　SQL*Plus基础	1
1.2　日常操作命令	6
1.3　查询输出与报表	10
1.4　Oracle 数据字典与性能视图	20
1.5　Oracle数据字典与计量单位	24
1.6　本章小结	28
第2章　SELECT语句入门	29
2.1　查询语句的使用	29
2.2　基本函数的使用	33
2.3　组函数与分组的使用	40
2.4　集合操作的使用	44
2.5　如何使用合并语句MERGE	47
2.6　本章小结	51
第3章　较复杂SELECT语句的使用	53
3.1　高级子查询	53
3.2　高级连接用法	61
3.3　层次查询	67
3.4　正则表达式的使用	71
3.5　其他语句	77
3.6　本章小结	85
第4章　DML语句的使用	86
4.1　INSERT 语句的使用	86
4.2　UPDATE语句的使用	90
4.3　DELETE与TRUNCATE语句的使用	94
4.4　MERGE语句的使用	97
4.5　本章小结	101
第5章　表与约束的创建及管理	102
5.1　创建表结构	102
5.2　表与约束的创建	121
5.3　表的维护	125
5.4　约束的维护	132
5.5　本章小结	140
第6章　索引创建与维护	141
6.1　创建普通索引	141
6.2　索引的一般维护	144
6.3　索引的特别维护	147
6.4　本章小结	151
第7章　Oracle常见对象创建与维护	152
7.1　创建与维护视图	152
7.2　创建与维护序列	156
7.3　创建与维护同义词	161
7.4　CLUSTER对象与表	164
7.5　本章小结	168
第8章　大数据对象设计与维护	169
8.1　大型表/索引数据压缩设计与维护	169
8.2　表分区创建与管理	177
8.3　索引分区创建与管理	183
8.4　创建Oracle LOB表与维护	187
8.5　Spatial创建与维护	193
8.6　Oracle Text使用初步	200
8.7　本章小结	207
第9章　大数据环境的容量规划与设计	208
9.1　应用系统段对象数据量获取	208
9.2　Oracle数据库规模获取	211
9.3　Oracle数据库规划与设计	219
9.4　Oracle大数据表空间设计	225
9.5　本章小结	228
第二篇　Oracle 12c PL/SQL	229
第10章　Oracle 12c PL/SQL基础	229
10.1　PL/SQL基础	229
10.2　光标的使用	238
10.3　异常处理与编程	242
10.4　本章小结	247
第11章　存储过程、函数和包	248
11.1　存储过程	248
11.2　函数	252
11.3　包的创建与使用	258
11.4　常见内置包的使用	263
11.5　存储过程、函数和包的维护	278
11.6　本章小结	288
第12章　Oracle 12c触发器	289
12.1　表级触发器	289
12.2　数据库触发器	295
12.3　触发器维护	300
12.4　本章小结	303
第13章　常用内置包的使用	304
13.1　Oracle 12c版本支持的内置包	304
13.2　Oracle系统内部有关的包使用	307
13.3　应用有关的包使用	320
13.4　外部有关的包使用	335
13.5　性能诊断与监控有关包的使用	342
13.6　数据安全/保密有关的内置包	354
13.7　本章小结	362
第三篇　Oracle 12c管理基础	363
第14章　Oracle12c系统实例的管理	363
14.1　Oracle 12c数据库启动与关闭	363
14.2　维护方式的启动	369
14.3　数据库关闭与等待	373
14.4　Oracle内存分配监控	379
14.5　Oracle系统进程管理	386
14.6　应用系统进程与会话	395
14.7　Oracle系统并行进程管理	407
14.8　本章小结	412
第15章　Oracle 12c系统安全与用户管理	413
15.1　创建与管理 Oracle 用户	413
15.2　Oracle 用户与表空间	422
15.3　权限与角色管理	427
15.4　PROFILE与资源配置	434
15.5　本章小结	444
第16章　Oracle 12c数据库审计与访问控制	445
16.1　Oracle系统简单审计	445
16.2　Oracle 系统精细审计	457
16.3　Oracle 12c 统一审计	462
16.4　一些安全访问控制	466
16.5　本章小结	468
第17章　Oracle 12c表空间与数据文件管理	469
17.1　表空间与数据文件有关信息	469
17.2　SYSTEM与SYSAUX表空间维护	479
17.3　表空间维护	486
17.4　本章小结	493
第18章　Oracle 12c撤销表空间与临时表空间	494
18.1　撤销表空间管理	494
18.2　Oracle 12c临时undo	499
18.3　临时表空间管理	501
18.4　本章小结	507
第19章　Oracle 12c控制文件管理	508
19.1　控制文件管理	508
19.2　控制文件备份与恢复	514
19.3　本章小结	519
第20章　Oracle 12c日志文件管理	520
20.1　日志文件的一般管理	520
20.2　日志文件较为复杂的管理	525
20.3　日志文件与性能	528
20.4　本章小结	533
第21章　Oracle 12c闪回的使用	534
21.1　DROP操作与闪回	534
21.2　DML操作与闪回事务	540
21.3　闪回的管理与维护	547
21.4　数据库级闪回功能与配置	553
21.5　本章小结	558
第四篇　Oracle 12c性能诊断与调整	559
第22章　Oracle 12c系统内存使用优化	559
22.1　Oracle系统调整准备	559
22.2　SGA调整基础	568
22.3　SGA调整实战	573
22.4　PGA调整与排序优化	579
22.5　Oracle 12c的In-Memory功能	583
22.6　本章小结	589
第23章　Oracle 12c应用系统性能调整	590
23.1　DML操作与性能	590
23.2　索引与性能	595
23.3　调整表的连接	600
23.4　提高应用运行效率与并行的使用	604
23.5　SQL语句性能问题分析	609
23.6　编程与会话参数设置	615
23.7　本章小结	621
第24章　应用系统性能监控与故障问题诊断	622
24.1　应用SQL语句实时监控	622
24.2　会话历史与性能诊断	631
24.3　SQL语句性能诊断	635
24.4　Oradebug工具与诊断	642
24.5　本章小结	648
第25章　Oracle 12c CBO模式下任务	649
25.1　Oracle优化器与CBO	649
25.2　表/索引的统计数据搜集	649
25.3　表/索引统计数据搜集管理	654
25.4　搜集更多的统计数据	661
25.5　本章小结	665
第26章　应用系统I/O效率与段重组	666
26.1　磁盘相关概念与术语	666
26.2　Oracle文件分布合理性诊断	667
26.3　存储I/O能力与I/O调整	672
26.4　段对象与存储问题	678
26.5　应用系统段重构问题	687
26.6　本章小结	699
第27章　Oracle 12c系统故障诊断与修复	700
27.1　诊断文件的使用	700
27.2　维护ADR数据	708
27.3　Oracle 12c健康监控检查	715
27.4　数据文件与冲突块	724
27.5　本章小结	731
第28章　Oracle 12c应用系统问题诊断与维护	732
28.1　应用系统对象可用性检查	732
28.2　应用系统数据完整性与数据质量检查	738
28.3　关于自动数据优化ADO	747
28.4　本章小结	758
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 数据库管理员日常操作手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle云管理平台
序——驾驭云管理
致谢
第1章oracle enterprise manager cloud control 12c简介
1.1em12c概览
1.2em12c架构
第2章em12c安装
2.1硬件要求
2.2软件包要求
2.3安装介质
2.4oracle rdbms安装
2.4.1数据库安装软、硬件要求
2.4.2安装数据库软件
2.4.3创建数据库
2.4.4环境变量设置
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle云管理平台
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle程序员面试笔试宝典
前言
上篇  面试笔试经验技巧篇
第1章   求职经验分享	2
1.1  踩别人没有踩过的坑，犯别人没有犯过的错	2
1.2  只要肯钻研，就能成大咖	3
1.3  普通DBA的逆袭经验	3
第2章   数据库程序员的求职现状	5
2.1  当前市场对于数据库程序员的需求如何？待遇如何？	5
2.2  数据库程序员有哪些可供选择的职业发展道路？	6
2.3  当企业在招聘时，对数据库程序员通常有何要求？	6
2.4  数据库程序员的日常工作是什么？	7
2.5  要想成为一名出色的数据库程序员，需要掌握哪些必备的知识？	8
第3章   如何应对程序员面试笔试？	11
3.1  如何巧妙地回答面试官的问题？	11
3.2  如何回答技术性的问题？	12
3.3  如何回答非技术性问题？	13
3.4  被企业拒绝后是否可以再申请？	14
3.5  如何应对自己不会回答的问题？	14
3.6  如何应对面试官的“激将法”语言？	14
3.7  如何处理与面试官持不同观点这个问题？	15
3.8  什么是职场暗语？	15
下篇  面试笔试技术攻克篇
第4章   数据库基础	20
4.1  为什么使用数据库？	20
4.2  数据库的常见分类有哪些？	20
4.3  关系型数据库完整性规则	24
4.4  数据库的约束有哪些？	25
4.5  什么是第一、二、三、BC范式？	26
4.6  事务	31
4.6.1  事务的概念及其4个特性是什么？	31
4.6.2  事务的4种隔离级别（Isolation Level）分别是什么？	32
4.7  锁（Lock）	33
4.7.1  基础知识	33
4.7.2  死锁（DeadLock）	34
4.8  存储过程	35
4.8.1  什么是存储过程？它有什么优点？	35
4.8.2  存储过程和函数的区别是什么？各自的作用是什么？	37
4.9  触发器的作用、优缺点有哪些？	37
4.10  什么是游标？如何知道游标已经执行到了最后？	38
4.11  视图	39
4.11.1  什么是视图？视图的作用是什么？	39
4.11.2  在什么情况下可以对视图执行增、删、改操作？	39
4.12  SQL语句有哪些常见的分类？	40
4.13  SQL语言的数据查询	41
4.13.1  多表连接查询	42
4.13.2  笛卡尔积是什么？	43
4.13.3  Top-N分析	44
4.13.4  子查询	44
4.13.5  合并查询（集合查询）	47
4.13.6  SQL：1999语法对SQL的支持	47
4.13.7  WITH语法	53
4.13.8  SQL部分练习题	53
4.14  什么是SQL注入？	56
4.15  索引（INDEX）	56
4.15.1  索引的优缺点与分类	56
4.15.2  索引的分类	57
4.16  热备份和冷备份的区别是什么？	58
4.17  什么是OLAP和OLTP?	59
4.18  与OS相关的面试题	60
4.18.1  接触过哪些OS系统？常用命令有哪些？	60
4.18.2  会写SHELL脚本吗？	61
4.19  数据库基础部分其他真题解析	61
第5章   Oracle数据库	63
5.1  开发类常考知识点	63
5.1.1  Oracle的数据类型	63
5.1.2  Oracle有哪些预定义角色？	65
5.1.3  如何定义序列？其作用是什么？	66
5.1.4  同义词的定义及其作用是什么？	67
5.1.5  Oracle中的视图	67
5.1.6  PL/SQL程序	68
5.1.7  异常处理	70
5.1.8  Oracle中的触发器	72
5.1.9  函数相关	79
5.1.10  高级操作	87
5.1.11  分区表	93
5.1.12  NULL的注意事项	98
5.1.13  树形查询（层次查询）	99
5.1.14  Oracle JOB	100
5.1.15  SQL*Plus问题	102
5.1.16  如何判断一个存储过程是否正在运行？	103
5.1.17  如何将文本文件或Excel中的数据导入数据库？	103
5.1.18  开发类真题	108
5.2  维护类常考知识点	110
5.2.1  系统包	110
5.2.2  Oracle对象	112
5.2.3  体系结构	116
5.2.4  索引相关	165
5.2.5  SQL优化相关	184
5.2.6  统计信息	239
5.2.7  等待事件	253
5.2.8  Oracle性能相关	261
5.2.9  数据库诊断	279
5.2.10  会话	294
5.2.11  ASM和RAC维护	298
5.2.12  DG维护	318
5.2.13  OGG维护	332
5.2.14  备份恢复	337
5.2.15  ASH/AWR/ADDM	376
5.2.16  审计（Audit）	386
5.2.17  网络相关	389
5.2.18  建库与删库	396
5.2.19  Oracle故障案例分析	402
第6章   操作系统	409
6.1   进程管理	409
6.1.1  进程与线程有什么区别？	409
6.1.2  内核线程和用户线程的区别？	410
6.2   内存管理	410
6.2.1  内存管理有哪几种方式？	410
6.2.2  什么是虚拟内存？	411
6.2.3  什么是内存碎片？什么是内碎片？什么是外碎片？	411
6.2.4  虚拟地址、逻辑地址、线性地址、物理地址有什么区别？	411
6.2.5  Cache替换算法有哪些？	412
6.3   用户编程接口	413
6.3.1  库函数调用与系统调用有什么不同？	413
6.3.2  静态链接与动态链接有什么区别？	414
6.3.3  静态链接库与动态链接库有什么区别？	414
第7章   计算机网络与通信	415
7.1   网络模型	415
7.1.1  OSI七层模型是什么？	415
7.1.2  TCP/IP模型是什么？	416
7.1.3  B/S与C/S有什么区别？	416
7.2   网络设备	417
7.2.1  交换机与路由器有什么区别？	417
7.2.2  路由表的功能有哪些？	417
7.3   网络协议	418
7.3.1  TCP和UDP的区别有哪些？	418
7.3.2  什么是ARP/RARP？	418
7.3.3  IP Phone的原理是什么?都用了哪些协议？	419
7.3.4  Ping命令是什么？	419
7.3.5  基本的HTTP流程有哪些？	420
7.4   网络其他问题	420
7.4.1  常用的网络安全防护措施有哪些？	420
7.4.2  相比IPv4，IPv6有什么优点？	421
第8章   面试笔试真题库	422
8.1   真题一	422
8.2   真题二	423
8.3   真题三	425
8.4   真题一答案	426
8.5   真题二答案	427
8.6   真题三答案	428
附录	429
推荐资料	429
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle程序员面试笔试宝典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库应用开发及实践
理论篇第1章数据库概述1．1数据库概述1．1．1数据库基本概念1．1．2数据库发展史1．1．3数据库特征1．1．4常见数据库1．2数据模型1．2．1概念模型1．2．2逻辑模型1．3关系模型理论1．3．1  关系1．3．2关系模式i．3．3关系的完整性1．3．4关系代数1．4规范化理论1．4．1规范化理论的提出1．4．2函数依赖1．4．3函数依赖定义的码1．4．4范式及各范式的关系1．4．5规范化思想1．5数据库设计1．5．1数据库设计特点1．5．2需求分析1．6概念结构设计1．6．1概念结构设计定义1．6．2概念结构设计的方法和步骤1．6．3数据抽象1．6．4 e．r图的生成1 7逻辑结构设计1．7．1初始关系模式设计1．7．2数据模型优化的方法1．7．3模式评价与改进1．8 0racle数据库概述1．8．1 0racle数据库简介1．8．2 0racle发展史1．8．3 0racle数据库的应用结构本章小结本章练习 第2章客户端开发工具2．1 sql developer概述2．2 sql developer简介2．2．1 sql developer下载2．2．2创建数据库连接2．3 sql developer基本操作2．3．1  数据操作2．3．2表的创建、修改2．4开发与调试2．4．1创建存储过程2．4．2运行存储过程2．4．3调试存储过程2．4．4调试plsql块2．5导入与导出2．5．1  导出数据2．5．2导入数据2．6 sql*plus概述2．6．1 sql*plus启动2．6．2 sql*plus使用本章小结本章练习 第3章数据表对象3．1  表3．1．1创建表……实践篇附录a　常用sql*plus命令附录b　oracle 数据隐式转换规则
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库应用开发及实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>零基础学Oracle（全彩版）
第1篇 基础知识
第1章 Oracle 11g概述
1.1 数据库的产生
1.2 数据库基本概念
1.2.1 数据、数据库、数据库管理系统和数据库系统
1.2.2 数据库的标准语言—— SQL
1.3 Oracle简介
1.3.1 Oracle公司介绍
1.3.2 Oracle体系介绍
1.4 Oracle数据库环境
1.4.1 Oracle数据库版本简介
1.4.2 Oracle 11g的下载与安装
1.4.3 Oracle 11g的卸载
1.5 难点解答
1.5.1 数据管理与数据库系统的特点
1.5.2 Oracle服务器、Oracle实例（Instance）、Oracle数据库（Database）的关系
1.6 小结
第2章 Oracle 管理工具
2.1 SQL*Plus工具
2.1.1 启动和连接SQL*Plus
2.1.2 使用SQL*Plus查询数据库
2.1.3 创建SQL*Plus快捷方式
2.1.4 退出SQL*Plus
2.2 SQL Developer工具
2.2.1 启动SQL Developer
2.2.2 创建数据库连接
2.2.3 使用SQL Developer查询数据库
2.3 企业管理器（OEM）
2.4 数据库配置助手（DBCA）
2.5 难点解答
2.5.1 SQL*Plus中的代码为什么大小写都有？
2.5.2 使用OEM管理数据库的好处
2.6 小结
2.7 动手纠错
第3章 SQL*Plus命令
3.1 SQL*Plus与数据库的交互
3.2 设置SQL*Plus的运行环境
3.2.1 SET命令简介
3.2.2 使用SET命令设置运行环境
3.3 常用的SQL*Plus命令
3.3.1 HELP命令
3.3.2 DESCRIBE命令
3.3.3 CONN命令
3.3.4 加入注释
3.4 格式化SQL*Plus输出
3.4.1 格式化列
3.4.2 定义页与报告的标题
3.5 数据字典
3.5.1 Oracle数据字典简介
3.5.2 Oracle常用数据字典
3.6 难点解答
3.6.1 为什么设置了linesize的值为300，运行结果还会出现折行的现象？
3.6.2 SQL*Plus命令与SQL语句的区别
3.7 小结
3.8 动手纠错
第4章 数据表操作
4.1 数据表概述
4.2 表与表结构操作
4.2.1 Oracle常用数据类型
4.2.2 表和表结构
4.2.3 表结构设计
4.3 OEM方式操作表
4.3.1 创建表
4.3.2 修改表
4.3.3 删除表
4.4 使用SQL Developer操作表
4.4.1 创建表
4.4.2 修改表
4.4.3 删除表
4.5 在SQL*Plus上操作表
4.5.1 创建表
4.5.2 修改表
4.5.3 删除表
4.6 难点解答
4.6.1 一条语句中删除多个字段
4.6.2 drop命令和delete命令的区别
4.7 小结
4.8 动手纠错
第5章 SQL查询基础
5.1 SQL语言简介
5.1.1 SQL语言的分类
5.1.2 SQL语言的编写规则
5.2 SELECT语句简介
5.3 查询所有列
5.3.1 查询单个表中所有列
5.3.2 查询多个表中所有列
5.4 查询特定列
5.4.1 查询特定列
5.4.2 伪列
5.5 消除重复行
5.5.1 查询结果中包含重复行
5.5.2 查询结果中消除重复行
5.6 带有表达式的SELECT子句
5.7 为列指定别名
5.7.1 不使用列别名
5.7.2 使用列别名
5.8 处理NULL
5.8.1 不处理NULL
5.8.2 使用NVL函数处理NULL
5.8.3 使用NVL2函数处理NULL
5.9 连接字符串
5.9.1 使用||操作符连接字符串
5.9.2 使用函数CONCAT连接字符串
5.10 难点解答
5.10.1 NULL和0的区别
5.10.2 为什么有的地方用了单引号“ ‘ ”，有的地方没用？
5.11 小结
5.12 动手纠错
第6章 SQL查询进阶
6.1 筛选查询
6.1.1 比较筛选
6.1.2 逻辑查询（AND、OR和NOT）
6.1.3 模糊查询（LIKE、NOT LIKE）
6.1.4 列表范围查找（IN、NOT IN）
6.1.5 范围查询（BETWEEN…AND）
6.1.6 判断内容是否为NULL（IS NULL、IS NOT NULL）
6.2 分组查询
6.2.1 使用GROUP BY进行单字段分组
6.2.2 使用GROUP BY进行多字段分组
6.2.3 使用HAVING子句限制分组结果
6.3 排序查询
6.3.1 单列排序
6.3.2 多列排序
6.4 多表关联查询
6.4.1 表的别名
6.4.2 内连接
6.4.3 外连接
6.4.4 自然连接
6.4.5 自连接
6.4.6 交叉连接
6.5 难点解答
6.5.1 如何区分左表、右表？
6.5.2 遇到复杂查询应该如何分析
6.6 小结
6.7 动手纠错
第7章 子查询及常用系统函数
7.1 初识子查询
7.2 单行子查询
7.3 多行子查询
7.3.1 使用IN运算符
7.3.2 使用ANY运算符
7.3.3 使用ALL运算符
7.4 Oracle常用系统函数
7.4.1 字符类函数
7.4.2 数字类函数
7.4.3 日期和时间类函数
7.4.4 转换类函数
7.4.5 聚合类函数
7.5 操作数据库(数据操纵语言)
7.5.1 插入数据（INSERT语句）
7.5.2 更新数据（UPDATE语句）
7.5.3 删除数据（DELETE语句和TRUNCATE语句）
7.6 难点解答
7.6.1 SQL语句中单引号的用法
7.6.2 DROP、DELETE和TRUNCATE命令的区别
7.7 小结
7.8 动手纠错
第2篇 核心技术
第8章 PL/SQL语言编程
8.1 PL/SQL简介
8.1.1 PL/SQL块结构
8.1.2 代码注释
8.1.3 标识符
8.1.4 分界符
8.2 数据类型
8.2.1 基本数据类型
8.2.2 数值型
8.2.3 字符型
8.2.4 日期型
8.2.5 布尔型
8.3 变量的声明与赋值
8.3.1 定义一般变量
8.3.2 使用%TYPE声明变量类型
8.3.3 使用RECORD声明变量类型
8.3.4 使用%ROWTYPE声明变量
8.4 流程控制语句
8.4.1 选择分支语句
8.4.2 循环语句
8.5 难点解答
8.5.1 变量定义时，如何选择使用CHAR还是VARCHAR2？
8.5.2 LOOP循环语句和WHILE…LOOP循环语句的区别
8.6 小结
8.7 动手纠错
第9章 游标
9.1 游标简介
9.2 隐式游标
9.3 显式游标
9.3.1 声明游标
9.3.2 打开游标
9.3.3 读取游标
9.3.4 关闭游标
9.3.5 显式游标的属性
9.4 游标变量
9.4.1 声明游标变量
9.4.2 打开游标变量
9.4.3 关闭游标变量
9.5 通过FOR语句遍历游标
9.5.1 隐式游标中使用FOR语句
9.5.2 显式游标中使用FOR语句
9.6 难点解答
9.6.1 游标操作前必须打开，关闭后的游标不可再用
9.6.2 PL/SQL中显式游标的操作步骤
9.7 小结
9.8 动手纠错
第10章 储存过程、函数和触发器
10.1 存储过程
10.1.1 创建存储过程
10.1.2 执行存储过程
10.1.3 存储过程的参数
10.1.4 删除存储过程
10.2 函数
10.2.1 创建函数
10.2.2 调用函数
10.2.3 删除函数
10.3 触发器
10.3.1 触发器简介
10.3.2 语句级触发器
10.3.3 行级触发器
10.3.4 替换触发器
10.3.5 删除触发器
10.4 难点解答
10.4.1 函数与存储过程的区别
10.4.2 替换触发器和语句级触发器的不同之处
10.5 小结
10.6 动手纠错
第11章 数据表约束
11.1 数据表约束简介
11.2 非空约束
11.2.1 设置非空约束
11.2.2 修改非空约束
11.2.3 删除非空约束
11.3 唯一性约束
11.3.1 设置唯一性约束
11.3.2 删除唯一性约束
11.4 主键约束
11.4.1 创建表的同时设置主键约束
11.4.2 创建表之后添加主键约束
11.4.3 删除主键约束
11.5 外键约束
11.5.1 设置外键约束
11.5.2 删除具有外键约束的表
11.5.3 删除外键约束
11.6 禁用和激活约束
11.6.1 在定义约束时禁用
11.6.2 禁用已经存在的约束
11.6.3 激活约束
11.7 删除约束
11.8 难点解答
11.8.1 为什么要在设置外键之前设置被引用表的主键？
11.8.2 各种约束的英文简写形式是什么？
11.9 小结
11.10 动手纠错
第12章 其他数据对象
12.1 索引对象
12.1.1 索引概述
12.1.2 创建索引
12.1.3 合并和重建索引
12.1.4 删除索引
12.1.5 显示索引信息
12.2 视图对象
12.2.1 创建视图
12.2.2 管理视图
12.3 序列对象
12.3.1 创建序列
12.3.2 管理序列
12.4 难点解答
12.4.1 建立索引的注意事项
12.4.2 在SQL Developer中如何创建索引?
12.5 小结
12.6 动手纠错
第3篇 高级应用
第13章 管理表空间和数据文件314
13.1 表空间与数据文件的关系
13.2 Oracle 11g的默认表空间
13.2.1 SYSTEM表空间
13.2.2 SYSAUX表空间
13.3 创建表空间
13.3.1 界面方式创建表空间
13.3.2 命令方式创建表空间
13.4 维护表空间与数据文件
13.4.1 设置默认表空间
13.4.2 更改表空间的状态
13.4.3 重命名表空间
13.4.4 删除表空间
13.4.5 维护表空间中的数据文件
13.5 难点解答
13.5.1 如何理解数据库、表空间和表
13.5.2 数据表默认创建在哪个表空间当中？
13.6 小结
13.7 动手纠错
第14章 事务
14.1 事务的概述
14.1.1 事务的特性
14.1.2 事务的状态
14.2 操作事务
14.2.1 设置事务
14.2.2 提交事务（COMMIT语句）
14.2.3 回滚事务（ROLLBACK语句）
14.2.4 设置回退点
14.3 难点解答
14.3.1 事务如何自动提交
14.3.2 如何预防死锁
14.4 小结
14.5 动手纠错
第15章 数据的导入与导出
15.1 EXPDP和IMPDP概述
15.2 EXPDP导出数据
15.2.1 导出数据时准备
15.2.2 导出表
15.2.3 导出模式
15.2.4 导出表空间
15.2.5 导出全数据库
15.3 IMPDP导入数据
15.3.1 导入表
15.3.2 导入模式
15.3.3 导入表空间
15.3.4 导入全数据库
15.4 图形界面导入导出数据
15.4.1 通过SQL Developer导出数据
15.4.2 通过SQL Developer导入数据
15.5 难点解答
15.5.1 导入、导出全数据库时，参数full=y是什么意思？
15.5.2 如何进行Oracle数据备份？
15.6 小结
15.7 动手纠错
第4篇 项目实战
第16章 企业人事管理系统
16.1 开发背景
16.2 系统分析
16.3 系统设计
16.3.1 系统目标
16.3.2 系统功能结构
16.3.3 系统预览
16.3.4 业务流程图
16.3.5 文件夹结构设计
16.4 数据库设计
16.4.1 数据库分析
16.4.2 数据库概念设计
16.4.3 数据库逻辑结构设计
16.5 主窗体设计
16.5.1 导航栏的设计
16.5.2 工具栏的设计
16.6 公共模块设计
16.6.1 编写Hibernate配置文件
16.6.2 编写Hibernate持久化类和映射文件
16.6.3 编写通过Hibernate操作持久化对象的常用方法
16.6.4 创建具有特殊效果的部门树对话框
16.6.5 创建通过部门树选取员工的面板和对话框
16.7 人事管理模块设计
16.7.1 人事管理模块功能概述
16.7.2 人事管理模块技术分析
16.7.3 人事管理模块的实现过程
16.8 待遇管理模块设计
16.8.1 待遇管理模块功能概述
16.8.2 待遇管理模块技术分析
16.8.3 待遇管理模块的实现过程
16.9 小结
附录1 Oracle中的SQL命令
附录2 PL/SQL命令
附录3 Oracle中的SQL函数
附录4 实例索引
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>零基础学Oracle（全彩版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 9i企业管理器详解
第1章 Oracle 企业管理器概述
第2章 Oracle 企业管理器控制台
第3章 Oracle9i企业管理器事件系统
第4章 Oracle9i企业管理器作业系统
第5章 Oracle企业管理器监控系统
第6章 Oracle企业管理器更改管理工具包
第7章 Oracle诊断工具包
第8章 Oracle9i企业管理器调节工具包
第9章 Oracle企业管理器SAP R/3管理工具包
第10章 Oracle目录管理
第11章 Oracle9i Net服务管理
第12章 Oracle9i文本管理
第13章 Oracle企业安全管理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 9i企业管理器详解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库实用指南
第一篇 Oracle SQL*Plus基础
第1章 Oracle数据库基础
1.1 理解关系数据库管理系统
1.2 关系数据库管理系统的组成
1.3 SQL. SQL*

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库实用指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Visual Basic + Oracle 9i数据库应用系统开发与实例（附1光盘）
第一章 Oracle 9i数据库管理
第二章 PL/SQL程序设计语言
第三章 Visual Basic数据库工程实用管理
第四章 小区物业管理系统
第五章 企业购销存管理系统
第六章 图书借阅管理系统
第七章 项目售后支持管理系统
第八章 应用程序的优化和发布
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Visual Basic + Oracle 9i数据库应用系统开发与实例（附1光盘）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据库原理及应用(ORACLE)
第一章 数据库导论
1．l 数据库的意义
1．2 数据库的由来和发展
1．3 数据库的体系结构
1．4 数据库系统
1．5 数据库管理系统
习题

第二章 实体联系模型（Entity―Relatiopship Model）
2．1 实体和实体集合
2．2 联系和联系集合
2．3 属性、映射限制和关键字
2．4 实体联系E－R图解和将之归纳为表
2．5 概括和聚集
2．6 E－R数据库模式设计
习题

第三章 网状、层次及面向对象数据库
3．1 网状数据库DBTG
3．2 层次数据库IMS
3．3 面向对象模型
习题

第四章 关系数据库
4．1 关系模型和基本概念
4．2 关系代数
4．3 关系演算
4．4 关系查询语言；ISBL、QUEL和QBE
4．5 关系数据库标准语言――一SQL
4．6 ORACLE关系数据库系统
习题

第五章 ORACLE SQL和 PL／SQL
5．1 ORACLE SQL介绍
5．2 定义、修改、删除表（Table）
5．3 模式对象、直接量、函数和表达式
5．4 数据操纵语言（Insert、Delete和Update）
5．5 视图
5．6 ORACLE PL／SQL
习题

第六章 关系数据库设计理论
6．1 引言
6．2 函数依赖
6．3 范式
6．4 多值依赖和4NF
习题

第七章 数据库的设计与维护
7．l 概述
7．2 需求分析
7．3 概念结构设计
7．4 逻辑结构设计
7．5 物理设计
7．6 实现与维护
7．7 用ORACLE建立数据库
7．8 ORACLE数据库和实例的启动及关闭（ORACLE的DBA）
7．9 数据字典（Data Dictionary）
习题

第八章 数据库保护
8．l 数据库的安全性（用户鉴别、特权、角色、审计）
8．2 数据完整性（数据库触发器）
8．3 并发控制
8．4 数据库后备和恢复
习题

第九章 分布式数据库系统
9．l 概述（客户／服务器结构、服务器一服务器结构）
9．2 分布式数据库的连接
9．3 分布式查询处理及其它
9．4 事务管理
9．5 多协议信息交换
9．6 表快照与复制
习题

第十章 数据库应用程序开发工具ORACLE Developer／2000
10．1 ORACLE Forms工具
10．2 ORACLE Report
10．3 ORACLE Graphics
习题

第十一章 ORACLE程序实例――图书管理信息系统
习题
附录A 《数据库原理及应用（ORACLE）》教学大纲
附录B 实验指导书
主要参考文献



>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>数据库原理及应用(ORACLE)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Designer信息系统开发
贺辞
序
译者序
OracleDesigner内容概览
引言
第一部分 基础知识
第1章 系统设计方法简介
1.1 CADM概述
1.2 超越传统方法
1.3 策略阶段的概念
1.4 预分析阶段的概念
1.5 分析阶段的概念
1.6 预设计阶段的概念
1.7 设计阶段的概念
1.8 建造阶段的概念
1.9 测试阶段的概念
1.10 实现阶段的概念
1.11 维护阶段的概念
1.12 本章小结
第2章 OracleDesigner简介
2.1 信息仓储
2.1.1 信息仓储的构成
2.1.2 信息仓储存放的内容
2.1.3 信息仓储的表征
2.2 前端工具
2.2.1 安装和硬件系统需求简述
2.2.2 前端程序
2.2.3 OracleDesigner功能的种类
2.2.4 系统需求建模
2.2.5 产生初步设计
2.2.6 设计和生成
2.2.7 实用程序
2.3 OracleDesigner界面
2.3.1 OracleDesigner窗口
2.3.2 启动OracleDesigner窗口
2.3.3 Help系统
2.3.4 浏览器界面
2.3.5 图示化工具界面
2.3.6 实用程序界面
2.4 OracleDesigner工具如何配合CADM
2.5 本章小结
第二部分 生命周期的各个阶段
第3章 策略阶段
3.1 策略阶段概述
3.2 提交
3.2.1 初始项目文档
3.2.2 项目合同
3.3 策略文档
3.3.1 策略文档的目标
3.3.2 策略文档的结构
3.3.3 执行概要
3.3.4 原有系统的描述
3.3.5 相关的项目
3.3.6 业务和财政支持人
3.3.7 动机
3.3.8 项目范围
3.3.9 解决方案
3.3.10 成本效益分析
3.3.11 项目组织和成员
3.3.12 工作计划
3.3.13 业务效果
3.3.14 策略文档结束语
3.4 应用系统分割
3.5 范围
3.6 策略文档的例子
3.7 对小系统的改动
3.8 策略阶段何时结束
第4章 策略阶段中的OracleDesigner
4.1 ProcessModeller
4.1 相对于功能的业务过程
4.1.2 基本技术
4.1.3 高级技术
4.1.4 在ProcessModeller中保存图形优选项集合
4.1.5 建立多媒体表现
4.1.6 其它菜单和工具栏的功能
4.1.7 所提供信息的用途
4.2 EntityRelationshipDiagrammer
4.2.1 基本技术
4.2.2 其它菜单和工具栏功能
4.2.3 所提供信息的用途
4.3 在RON中跟踪文档
第5章 预分析阶段
5.1 预分析阶段概述
5.2 提交
5.3 预分析的目标
5.4 信息搜集
5.4.1 用户提供的需求
5.4.2 对原有系统的重新检查
5.5 需求分析
5.6 分析计划
5.7 分析计划样例
5.8 对小系统的改动
5.9 预分析阶段何时结束
第6章 预分析阶段中的Oracle Designer
6.1 Repository Object Navigator
6.1.1 基本技术
6.1.2 其它菜单和工具栏功能
6.1.3 使用RON抽查策略工作
6.1.4 使用RON创建新版本
6.2 RepositoryReports
6.2.1 基本技术
6.2.2 输出窗口
6.2.3 自制报表
6.2.4 其它菜单和工具栏的功能
6.3 将系统需求映射为信息仓储元素
6.3.1 使用OracleDesigner系统需求的元素
6.3.2 使用用户需求扩展
6.3.3 在用户扩展和基于表的系统之间选择
第7章 分析阶段――信息收集
7.1 提交
7.2 信息收集概述
7.3 从用户那里得到需求
7.3.1 会谈
7.3.2 调查表
7.3.3 电子通信
7.3.4 联合应用开发会议
7.4 原有系统检查
7.5 安全
7.6 单元级分析
7.7 对小系统的改动
7.8 信息收集何时结束
第8章 分析阶段――信息收集中的Oracle Designer
8.1 信息收集使用的Process Modeller和Entity Relation ship Diagrammer
8.2 DataflowDiagrammer
8.2.1 DataflowDiagrammer和ProcessModeller之间的区别
8.2.2 基本技术
8.2.3 Function/AttributeMatrix实用程序
8.2.4 其它技术
8.2.5 其它菜单和工具栏功能
8.2.6 所提供信息的用途
8.3 原有系统的ERD
8.3.1 设计捕获实用程序
8.3.2 Tableto Entity Retrofit实用程序
8.3.3 Entity Relation ship Diagrammer和原有系统的ERD
8.4 利用用户扩展跟踪报表审计
第9章 分析阶段――需求分析
9.1 需求分析概述
9.2 提交
9.3 安全
9.4 执行人员信息系统和特殊查询要求
9.5 对小系统的改动
9.6 何时结束IS需求分析
第10章 分析阶段――需求分析中的Oracle Designer
10.1 Entity Relation ship Diagrammer
10.1.1 使用域
10.1.2 增加属性
10.1.3 关系的详细设计
10.1.4 完成实体细节
10.1.5 使用UpdateAttributesinDomains实用程序
10.1.6 使用Function/AttributeMatrix实用程序
10.1.7 所提供信息的用途
10.2 需求分析中的ProcessModeller
10.3 需求分析中的Dataflow Diagrammer
10.3.1 技术和特性
10.3.2 上下文图
10.4 FHD
10.4.1 FHD的用途
10.4.2 基本技术
10.4.3 其它的菜单和工具栏功能
10.4.4 分析阶段中典型的FHD任务
10.4.5 所提供信息的用途
10.5 MatrixDiagrammer
10.5.1 建立阵列
10.5.2 阵列视图模式
10.5.3 修改值
10.5.4 其它技术
10.5.5 其它的菜单和工具栏功能
10.5.6 其它有用的阵列
10.5.7 所提供信息的用途
10.6 分析阶段中的RepositoryReports
第11章 预设计阶段
11.1 预设计阶段概述
11.2 提交
11.3 设计标准
11.3.1 建立GUI设计标准
11.3.2 制定编码标准
11.3.3 建立设计命名约定
11.4 应用系统概念设计
11.5 设计计划
11.6 对小系统的改动
11.7 预设计阶段何时结束
第12章 预设计阶段的Oracle Designer
12.1 Design Editor
12.1.1 基本技术
12.1.2 其它菜单和工具栏功能
12.2 生成器优选项
12.2.1 优选项级别
12.2.2 显示优选项
12.2.3 设置优选项
12.2.4 继承优选项
12.2.5 优选项集合
12.2.6 其它层次视图
12.2.7 优选项安全性
12.2.8 所提供信息的用途
12.3 Database Design Transformer
12.3.1 DDT的输出
12.3.2 TableMappings标签页
12.3.3 OtherMappings标签页
12.3.4 RunOptions标签页
12.3.5 Settings对话框
12.3.6 运行DDT
12.3.7 其它功能
12.3.8 所提供信息的用途
12.4 ApplicationDesignTransformer
12.4.1 ADT窗口
12.4.2 对模块运行ADT
12.4.3 对菜单运行ADT
12.4.4 ADT规则
12.4.5 所提供信息的用途
12.5 归并提要表
12.6 归并提要模块
12.7 Capture Design of Formand Report实用程序
12.8 预设计阶段中的Repository Object Navigator和API
12.9 预设计阶段中的信息仓储报表
第13章 设计阶段――数据库设计
13.1 数据库设计概述
13.2 DBA的问题
13.3 对象关系数据库
13.4 对小系统的改动
13.5 数据库设计何时结束
第14章 设计阶段――数据库设计中的Oracle Designer
14.1 Server Model Diagram
14.1.1 Server Model Diagrammer
14.1.2 基本技术
14.1.3 其它菜单和工具栏功能
14.1.4 所提供信息的用途
14.2 定义设计元素
14.2.1 表
14.2.2 表列
14.2.3 域
14.2.4 约束
14.2.5 索引
14.2.6 同义词
14.2.7 触发器
14.2.8 视图与快照定义
14.2.9 TableAPI
14.2.10 其它数据库对象
14.2.11 Design Editor向导
14.3 Logic Editor
14.3.1 PL/SQL定义的类型
14.3.2 定义代码
14.3.3 定义PL/SQL的方法
14.3.4 PL/SQL定义特性
14.3.5 PL/SQL的实现特性
14.3.6 定义软件包
14.3.7 更改选项
14.3.8 用外部编辑器建立PL/SQL定义
14.3.9 利用Capture Design of Server Model实用程序建立PL/SQL定义
14.4 利用Oracle Designer设计对象
14.4.1 对象概念
14.4.2 Object Database Designer
14.4.3 Design Editor对象支持
14.5 Database Navigator
14.6 设计阶段：数据库设计中的Repository Reports
第15章 设计阶段――应用程序设计
15.1 应用程序设计概述
15.2 提交
15.3 内部控制和安全
15.4 测试计划
15.5 对小系统的改动
15.6 应用程序设计何时结束
第16章 设计阶段――应用程序设计中的Oracle Designer
16.1 Module Network Viewer
16.1.1 Module Structure Diagrammer
16.1.2 基本技术
16.1.3 使用RON输入模块定义
16.1.4 所提供信息的用途
16.2 Module Diagram
16.2.1 模块组件
16.2.2 表用法
16.2.3 基本技术
16.2.4 建造模块
16.2.5 可重用的模块组件
16.2.6 其它技术
16.2.7 Create Default Module Data Usages实用程序
16.2.8 Default Links实用程序
16.2.9 所提供信息的用途
16.3 Module Component API
16.4 Module Application Guide
16.5 引用表
16.5.1 引用代码表
16.5.2 代码控制表
16.5.3 帮助表
16.6 实现控制隐患阵列
16.7 应用程序设计中的Matrix Diagrammer
16.8 设计阶段：应用程序设计中的Repository Reports
第17章 建造阶段
17.1 建造阶段概述
17.2 提交
17.3 建造数据库
17.4 建造模块
17.5 优化与单元级测试
17.6 文档与帮助
17.7 对小系统的改动
17.8 建造阶段何时结束
17.9 本章小结
第18章 建造阶段的Oracle Designer
18.1 Generate Database from ServerModel实用程序
18.1.1 运行Generate Database from Server Model实用程序
18.1.2 其它生成数据库对象的实用程序
18.2 生成模块
18.2.1 成分列表
18.2.2 编写应用逻辑
18.2.3 拷贝模块和菜单
18.3 FormGenerator
18.3.1 使用模块定义
18.3.2 执行Form Generator
18.3.3 设置Form Generator优选项
18.3.4 利用对象库
18.3.5 使用模板
18.3.6 生成菜单
18.3.7 窗体生成实用程序与技术
18.4 库生成器
18.4.1 生成库
18.4.2 附加库
18.4.3 设计捕获库
18.5 Web Server Generator
18.5.1 所需组件
18.5.2 应用服务器结构
18.5.3 执行Web Server Generator
18.5.4 某些特性和优选项
18.5.5 WSG模板
18.6 Report Generator
18.6.1 输出格式
18.6.2 生成报表
18.6.3 报表模板
18.6.4 Capture Design of Report
18.7 Visual Basicgenerator
18.7.1 所需的组件
18.7.2 生成器的输出
18.7.3 运行Visual Basic Generator
18.7.4 捕获Visual Basic设计的实用程序
18.8 MS Help Generator
18.8.1 Help Generator所用的信息仓储特性
18.8.2 运行MS Help Generator
18.9 建造阶段的信息仓储报表
第19章 测试、实现和维护阶段
19.1 测试阶段
19.1.1 测试计划
19.1.2 系统测试
19.1.3 用户验收测试
19.1.4 培训和文档编制
19.2 对小系统的改动
19.3 测试阶段何时结束
19.4 实现阶段
19.5 对小系统实现的改动
19.6 实现阶段何时结束
19.7 维护阶段
19.8 对小系统维护的改动
19.9 维护阶段何时结束
19.10 本章小结
第20章 测试、实现以及维护阶段中的Oracle Designer
20.1 Oracle Designer中的测试阶段
20.1.1 单元和系统测试文档
20.1.2 问题跟踪
20.1.3 Reconcile RePort
20.1.4 测试阶段中的Repository Reports
20.2O racle Designer中的实现阶段
20.3O racle Designer中的维护阶段
第21章 更改控制
21.1 防止“范围蔓延”
21.2 开发过程的每个阶段中更改的控制
第三部分 CADM 新增内容
第22章 RAD－CADM
22.1 RAD－CADM简介
22.2 RAD－CADM 工作的主要成功因素
22.3 RAD－CADM过程的细节
22.4 本章小结
第23章 从中间开始
23.1 从一个失败的工作开始
23.2 评估一个未完成的项目
23.3 从中间开始的提交文档和方法
23.4 本章小结
第24章 业务过程重构
24.1 重构的概念
24.2 重构的原因
24.3 重构的决策框架
24.4 成功进行重构的关键
第25章 数据移植
25.1 综述
25.2 数据移植的困难
25.3 数据移植阶段
25.3.1 移植策路
25.3.2 移植预分析
25.3.3 移植分析
25.3.4 移植设计
25.3.5 移植建造和单元测试
25.3.6 移植测试
25.3.7 移植修正
25.3.8 移植实现
25.3.9 移植维护
25.4 数据转换工具和程序员
25.5 本章小结
第四部分 附加的OracleDesigner活动
第26章 应用系统和信息仓储管理
26.1 利用RON管理应用系统
26.1.1 PropertyPalette
26.1.2 File菜单
26.1.3 Utilities菜单
26.1.4 Application菜单
26.1.5 Options菜单
26.1.6 多应用系统项目
26.2 利用RAU管理信息仓储
26.2.1 InstalI/Upgrade
26.2.2 Repository Maintenance
26.2.3 Deinstall
26.2.4 Check Requirements
26.2.5 Backup
26.3 管理的信息仓储报表
26.4绕过OracleDesigner窗口
26.5 附加的信息来源
第27章 用户扩展
27.1 用户扩展概念
27.2 元素类型、关联类型和文本类型
27.3 创建用户扩展
27.3.1 可以进行扩展的方面
27.3.2 如何在RAU中定义用户扩展
27.4 后续工作
第28章 应用程序接口
28.1 什么是API
28.2 使用API
28.2.1 有关视图和软件包的详细内容
28.2.2 API代码
28.2.3 API视图
28.2.4 API软件包
28.2.5 API事务处理模型
28.3 处理多行文本
28.4 使用API的例子
第29章 信息流
29.1 信息仓储回顾
29.2 信息如何在信息仓储中流动
29.3 发现信息流的方法
29.4 分析阶段到设计阶段的举例
29.4.1 实体到表
29.4.2 属性到表列
29.4.3 实体关系到外部键约束
29.5 信息流从设计定义到产生代码的例子
29.5.1 服务器代码
29.5.2 客户端代码
29.6 数据库和应用程序设计捕获的例子
29.6.1 表和表实现特性
29.6.2 表列特性
29.6.3 索引特性
29.6.4 主键和外部键约束特性
29.6.5 软件包过程和功能特性

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Designer信息系统开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ORACLE8.1.6应用系统使用指南(含盘)-Oracle数据库技术丛书5
第一篇：Oracle销售分析系统管理指南
1、Oracle销售分析器介绍
2、管理员的职责
3、安装分析器
4、构造数据库
5、使用Express数据库和分类
6、建立客户访问
7、为客户访问建立通信
8、建立Web访问
9、建立数据库安全机制
1、限定对数据库的访问范围
11、构造片段
12、定制数据库
13、控制数据

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>ORACLE8.1.6应用系统使用指南(含盘)-Oracle数据库技术丛书5
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8备份与恢复手册
目 录
贺词
序
译者的话
前言
引言
第1章 备份和恢复综述
1.1为什么要设计备份
1.2系统失败的原因
1.3硬件保护和冗余
1.4归档日志模式和不归档日志模式
1.5诊断功能和调试RDBMS
1.6备份综述
1.6.1使用恢复管理器备份
1.6.2操作系统备份
1.6.3数据库冷备份
1.6.4热备份
1.6.5逻辑备份――导出
1.6.6自动备份
1.6.7备份内容
1.7恢复综述
1.7.1故障类型
1.7.2恢复类型
1.7.3使用物理备份恢复
1.7.4使用逻辑备份恢复
第2章 Oracle体系结构和配置
2.1系统上的Orac1e文件
2.1.1Oracle代码
2.1.2数据文件
2.1.3重做日志文件
2.1.4控制文件
2.1.5INIT.ORA文件
2.1.6Oracle跟踪文件
2.2数据库操作
2.2.1系统全局区
2.2.2Oralce进程
2.2.3数据库的启动和关闭
2.3数据存储
2.3.1表空间和数据文件
2.3.2分区
2.3.3段、区间和数据块
2.4数据库配置
2.4.1管理控制文件
2.4.2管理联机重做日志组
2.4.3管理归档重做日志文件
2.5配置Oracle并行服务器选项
第3章 备份原则
3.1数据库设计和基本备份规则
3.2物理备份
3.2.1脱机（冷）备份
3.2.2联机（热）备份
3.3逻辑备份
3.3.1导出方法
3.3.2导出参数
3.3.3导出模式
3.3.4在使用导出之前
3.3.5导出过程示例
3.4各种操作系统中的备份命令
3.4.1VMS环境中的备份/恢复
3.4.2UNIX环境中的备份/恢复
3.4.3IBMMVS环境中的备份/恢复
3.4.4WindowsNT环境中的备份/恢复
3.5特殊环境中的备份
3.5.1在线事物处理环境中的备份问题
3.5.2决策支持系统环境中的备份问题
3.5.3热备用数据库
第4章 WindowsNT，UNIX和OpenVMS环境中的备份脚本
4.1VMS环境中的备份脚本
4.1.1BACKUP　MAIN.COM
4.1.2EXPORTDATABASE.COM
4.1.3HOT　BACKUP.COM
4.1.4COLD　BACKUP.COM
4.1.5BACKUP　TABLESPACE.COM
4.1.6INSTANCE　UP.COM
4.1.7ENV　SYMBOLS　SAMPLE.COM
4.1.8SHUTDOWN　 IMMEDIATE.COM
4.1.9STARTUP　DBAMODE.COM
4.1.10SUBMIT　sample.COM
4.1.11db　name　DEVICES　 SAMPLE.COM
4.1.12Tbs　hotbackup.sq1
4.1.13Tbs　codbackup.aql
4.1.14Tablespace　State.sql
4.1.15Hot　Backup　Sample　Run.log
4.2WindowsNT环境中的备份脚本
4.3UNIX环境中的备份脚本
4.3.1dbbackup
4.3.2dbbackup　begin
4.3.3dbexport　begin
4.3.4dbbackup　sched.dat
4.3.5crontab.env
4.3.6sample　ru n.log
第5章 恢复原则
5.1定义和内部恢复的概念
5.1.1重做的生成和估计
5.1.2系统修改号（SCN）
5.1.3重做线程
5.1.4重做日志的切换
5.1.5检查点
5.1.6日志历史记录
5.1.7控制文件、数据文件和日志文件的结构
5.2恢复方法
5.2.1重做应用
5.2.2数据块恢复
5.2.3线程恢复
5.2.4介质恢复
5.2.5数据库的恢复和实现
5.2.6表空间恢复
5.2.7数据文件恢复
5.2.8创建控制文件和数据文件
5.2.9用Import实用程序进行恢复
5.2.10由增量导出重建数据库
5.2.11恢复策略
5.3恢复管理器实用程序
5.3.1恢复目录
5.3.2创建恢复目录
5.3.3登记数据库到恢复目录
5.4如何用恢复管理器建立备份
5.4.1完全数据库备份
5.4.2表空间备份
5.4.3数据文件备份
5.4.4控制文件备份
5.4.5归档日志备份
5.4.6增量备份
5.4.7更改恢复目录
5.4.8恢复管理器的报告功能
5.4.9恢复管理器中的脚本
5.4.10恢复管理器的错误诊断
5.4.11收集恢复管理器会话期的运很记录
5.4.12恢复管理器的坏数据块控制
5.5故障恢复
5.5.1概念与术语
5.5.2选择、设计和规划
5.5.3准备工作
5.5.4运用
5.5.5维护
5.5.6激活
5.6故障分析
5.6.1系统中断调查
5.6.2系统停机及恢复调查
5.6.3对于故障恢复的建议
第6章 诊断工具和调试RDBMS
6.1Oracle跟踪文件
6.2诊断工具
6.2.1设置跟踪事件
6.2.2INIT.ORA参数
6.2.3其他诊断程序
6.3调试RDBMS
6.3.1控制文件的转储
6.3.2Oracle7的控制文件转储
6.3.3Oracle8的控制文件转储
6.3.4重做日志文件转储
6.3.5数据文件转储
6.4Oracle错误和解决方案
6.4.1常见的Oracle错误
6.4.2Oracle内部错误
第7章 备份和恢复实例学习
7.1实例学习
7.1.1实例1：非归档模式和恢复
7.1.2实例2：在非归档模式下删除数据文件
7.1.3实例3：系统数据文件丢失
7.1.4实例4：丢失没有回滚段的非SYSTEM数据文件
7.1.5实例5：丢失有回滚段的非SYSTEM数据文件
7.1.6实例6：丢失未归档的联机日志文件
7.1.7实例7热备份期间的数据库崩溃
7.1.8实例8：使用备份控制文件恢复
7.1.9实例9：Oracle 7版本7.冲的空 间管理
7.1.10实例10：在Oracle7版本7.2及高版本中重定数据文件长度
7.1.11实例11：通过复位日志恢复
7.1.12实例11（a）：通过复位日志恢复（续）
7.1.13实例12：创建数据文件
7.1.14实例13：系统时钟改变和时间点恢复
7.1.15实例14：脱机表空间和介质恢复
7.1.16实例15：只读表空间和恢复
7.1.17实例16：备用数据库问题解答
7.1.18实例17：Oracle8中数据分区丢失
7.1.19实例18：通过时间点表空间恢复实现表/分区的恢复（TSPITR）
7.2 小结
附录A Oracle7版本7.1，7.2，7.3和Oracle8的新特性
A.1Oracle7版本7.1的新特性
A.1.1服务管理器
A.1.2对称复制
A.1.3一致性快照刷新
A.1.4SQL和PL/SQL增强
A.1.5只读表空间
A.1.6并行恢复
A.1.7并行查询选项
A.1.8动态SQL
A.2Oracle7版本7.2的新特性
A.2.1数据库管理增强
A.2.2应用程序开发增强特性
A.2.3其他特性
A.3Oracle7版本7.3的新特性
A.3.1快速事务回滚（7.3）
A.3.2新的介质恢复视图
A.3.3线程/例程恢复改善
A.3.4备用数据库
A.4Oracle8的新特性
A.4.1可分区的表和索引
A.4.2支持并行DML
A.4.3对象类型、对象扩展和对象视图
A.4.4口令管理的增强
A.4.5存储范围的增强
A.4.6大型对象（LOBs）
A.4.7支持多字节数据类型
A.4.8集合
A.4.9Oracle8助手
A.4.10恢复管理器
A.4.11Net8安装向导
A.4.12新的扩展ROWID格式
A.4.13Oracle高级排队
A.4.14增强的限制管理
A.4.15索引表

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8备份与恢复手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 10g管理及应用
序
前言
第1章 Oracle 1 0g简介
本章学习目标
1.1　数据库管理系统
1.2　Oracle l 0g基础知识
1.2.1 Oracle的发展历史
1.2.2 Oracle 10g的产品构成
1.2.3 Oracle的网络资源
本章小结
习题
第2章　Oracle 10g的安装和工具
本章学习目标
2.1　Oracle 10g for Windows的安装与配置
2.1.1　安装Oracle 10g数据库服务器
2.1.2　Oracle 10g与Windows
2.1.3　服务器当前配置
2.1.4　安装Oracle 10g客户端
2.2　Oracle 10g基本操作
2.2.1　登录Oracle 10g数据库服务器
2.2.2　启动Oracle 1 0g数据库服务器
2.2.3　关闭Oracle 1 0g数据库服务器
2.2.4　创建ODBC数据源
本章小结
实训1 Oracle 10g的安装和配置
习题
第3章　Oracle 1 0g体系结构
本章学习目标
3.1 Oracle数据库的存储结构
3.1.1 Oracle数据库主要的存储结构
3.1.2　数据库表空间
3.1.3　段、区间和数据块
3.1.4　表
3.2　Oracle 10g数据库的物理结构
3.2.1　数据文件
3.2.2　控制文件
3.2.3 日志文件
3.2.4　初始化参数
3.2.5　其他文件
3.3　数据库的系统结构
3.3.1 Oracle实例
3.3.2 Oracle数据库系统的内存结构
3.3.3 Oracle数据库系统的后台进程
3.4 Oracle数据库的应用结构
3.4.1　多磁盘结构
3.4.2　磁盘映像系统
3.4.3　客户服务器系统
3.4.4　多线程服务器系统
3.4.5　并行数据库系统
3.4.6　分布式数据库系统
3.4.7　Oracle　WebServer系统
本章小结
习题
第4章　用SQL语言访问数据库
本章学习目标
4.1 SQL的概念
4.1.1 SQL的特点和命令类型
4.1.2　应用程序的可移植性和ANSI/ISO SQL标准
4.1.3 Oracle 10g中的SQL环境
4.2　通过查询检索数据
4.2.1　查询结构
4.2.2　建立基本查询
4.2.3 在查询的SELEcT子句中建立表达式
4.2.4　从表中检索特定行
4.2.5　分组和排序查询结果集的数据
4.2.6　连接相关表中的数据
4.3　插入、更新和删除表中行
4.4　提交和回退事务
4.5　事务处理设计
4.5.1 工作单元
4.5.2　读写事务处理
4.5.3 只读事务处理
本章小结
实训2　用SQL语言访问数据库
习题
第5章　SQL*Plus基础
第6章　数据常规管理
第7章　Oracle对象管理
第8章　用户账号管理和权限控制
第9章　PL/SQL程序设计
第10章　审计与优代
第11章　数据库的备份与恢复
第12章　课程设计——人事管理信息系统数据库
参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 10g管理及应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle计算机语言函数应用
引言
1. Oracle概述
1?1 Oracle数据库简介
1?2 Oracle8的新特性
2. SQL命令
3. SQL函数
3?1 字符函数
3?1?1 字符函数――返回字符值
3?1?2 字符函数――返回数字值
3?2 数值函数
3?3 日期函数
3?4 转换函数
3?5 单行函数
3?6 对象参考函数
3?7 组函数
第4章 SQL*PLUS命令
附录

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle计算机语言函数应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 9i 应用服务器详解
第1章 Oracle9i应用服务器概述
第2章 Oracle9i应用服务器管理概述
第3章 启动和停止应用服务器
第4章 管理站点和程序
第5章 管理和配置
第6章 安全管理
第7章 注册第三方HTTP服务器
第8章 部署应用
第9章 管理EJB、ECO/Java和CORBA
第10章 Cartridge管理
第11章 日志处理
第12章 事务处理
第13章 Oracle9i应用服务器的灾难恢复
第14章 Oracle9i应用服务器性能优化与调试
第15章 Oracle9i应用服务器应用开发概述
……
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 9i 应用服务器详解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 9i/10g开发管理与实例
第1章　数据库对象与开发过程管理　1
1-1　开发过程管理　1
1-1-1　成功三要素　1
1-1-2　需求获取过程　1
1-1-3　管理过程　2
1-1-4　管理包开发　5
1-1-5　管理环境　8
1-2　如何在开发过程中成功确定数据库对象　8
1-2-1　“.net”与ado.net初探　8
1-2-2　实例——web-iaround系统的表结构分析　12
1-2-3　web-iaround系统的视图、索引对象分析　22
1-2-4　web-iaround系统存储对象分析与数据库接口　24
1-2-5　web-iaround系统其他方面的接口描述　27
思考题　29
第2章　oracle designer与uml对象建模设计　35
2-1　oracle 9i designer case工具　35
2-1-1　designer：oracle 9i的常用计算机辅助工程解决方案　35
2-1-2　oracle 9i designer一览　36
2-1-3　提高oracle 9i designer性能　42
2-1-4　应用编程界面　43
2-2　uml对象建模初探　44
2-2-1　uml简述　44
2-2-2　uml的基本目标　45
2-2-3　uml的组成部分　46
2-2-4　uml建模的特点　46
2-3　uml基本建模与web-iaround系统对象建模分析　50
2-3-1　uml命名规则　51
2-3-2　uml扩展　52
2-3-3　uml的规范化设计　54
2-3-4　uml的实现　54
2-3-5　uml建模的深化与web-iaround系统建模　58
2-3-6　uml建模方法论　66
2-3-7　uml建模的泛化对象类　73
2-4　uml历史记录建模　81
2-4-1　跟踪历史记录　81
2-4-2　实现历史记录　86
思考题　90
第3章　oracle数据库调整与网络管理　91
3-1　数据库调整　91
3-1-1　调整数据库应用系统设计　91
3-1-2　调整sql语句　94
3-1-3　调整内存使用　98
3-1-4　调整数据存储　101
3-1-5　调整数据操作　107
3-1-6　调整物理存储　111
3-1-7　调整逻辑存储　112
3-1-8　减少网络流量　113
3-1-9　使用oem和性能调整组件　118
3-1-10　调整方案　124
3-2　卸库与装库　125
3-2-1　卸库与装库的功能　126
3-2-2　卸库与装库的相同点和不同点　126
3-2-3　操作方法　127
3-2-4　卸库与装库的模式　131
3-2-5　分区表上的卸库与装库　133
3-2-6　运行程序的要求与错误的解决办法　133
3-2-7　参数之间的关系　134
3-2-8　从oem中卸库与装库　135
3-3　sql * loader　139
3-3-1　运行sql * loader　139
3-3-2　sql * loader组件　141
3-3-3　sql * loader示例一览　143
3-3-4　常规路径装载与直接路径装载　152
3-4　sql*net v2和net　157
3-4-1　sql*net v2和net概述　157
3-4-2　sql*net/net配置　160
3-4-3　使用net configuration assistant　164
3-4-4　使用net manager　169
3-4-5　应用样例　170
3-4-6　调整sql * net和net　173
3-4-7　对sql * net/net进行性能优化　174
3-5　管理网络　176
3-5-1　确保网络没有过载　177
3-5-2　用发送报文命令连接主机　178
3-5-3　使用网络电缆分析器　179
3-5-4　勿在nfs的mount分区创建数据文件　179
3-5-5　勿用数据库服务器作为nfs服务器　180
3-5-6　有效利用子网　180
3-6　unix/linux上的oracle联网技术　180
3-7　windows 2000/windows server 2003上的oracle联网技术　184
3-8　c/s配置、web网络环境配置　188
3-9　web-iaround系统网络管理实务　189
3-9-1　检查网络状况　190
3-9-2　设置数据库联网环境　191
思考题　192
第4章　web server与internet计算结构　203
4-1　oracle web server概述　203
4-1-1　oracle web server的组成部分　203
4-1-2　oracle web listener监听程序　204
4-1-3　oracle web agent代理　205
4-1-4　oracle web server开发者工具箱　205
4-1-5　oracle server　205
4-2　oracle web listener　205
4-2-1　oracle web listener的特性　206
4-2-2　oracle web listener的配置参数　210
4-3　oracle web agent　216
4-3-1　oracle web agent的使用者　216
4-3-2　oracle web agent的工作过程　216
4-3-3　oracle web agent的服务(service)　217
4-3-4　oracle web agent如何使用cgi环境变量　219
4-3-5　传递参数给pl/sql　220
4-3-6　oracle web agent错误处理　224
4-4　web server开发工具箱　226
4-5　oracle internet计算结构　226
4-5-1　internet计算　226
4-5-2　internet计算结构　227
4-5-3　ica环境及故障评估　229
4-6　web-iaround系统应用oracle web agent示例　232
思考题　236
第5章　oas应用　237
5-1　oas结构　237
5-2　oas的安装　241
5-3　oas常见故障与排除　244
5-4　oas的安全性　246
思考题　251
第6章　oracle预编译器与嵌入式sql　252
6-1　oracle预编译器概述　252
6-1-1　oracle预编译器支持的语言　253
6-1-2　预编译器概述　253
6-1-3　oracle预编译器的特点　254
6-2　变量声明和数据类型　255
6-2-1　变量声明与嵌入式sql语句　255
6-2-2　数据类型　257
6-3　连接数据库　259
6-4　用嵌入式sql访问和操纵数据　261
6-4-1　事务处理　261
6-4-2　动态sql　263
6-5　错误与通信处理　268
6-6　预编译源代码　269
6-6-1　条件预编译　269
6-6-2　预编译选项　271
6-6-3　预编译配置　273
6-7　web-iaround系统中的预编译技术应用　275
6-7-1　cgi概述　275
6-7-2　web-iaround系统应用　278
思考题　282
第7章　大型数据库管理　284
7-1　设置大型数据库环境　284
7-1-1　大型数据库容量设置　285
7-1-2　设置其他磁盘空间大小　287
7-1-3　选择物理设计　287
7-1-4　创建并管理分区　288
7-2　创建并管理索引结构表　292
7-2-1　创建显形图　292
7-2-2　创建完全索引表　293
7-2-3　创建和管理索引组织表　293
7-2-4　创建和管理位映射索引　294
7-3　大型事务管理　295
7-3-1　配置批事务环境　295
7-3-2　装载数据　296
7-3-3　插入数据　297
7-3-4　删除数据　298
7-4　大型数据库备份　300
7-4-1　备份需求及评估　301
7-4-2　备份策略分析　301
7-5　数据库环境调整　302
7-6　使用可迁移表空间　304
7-6-1　生成可迁移的表空间集　304
7-6-2　导入可迁移的表空间集　305
7-7　局部管理的表空间　305
思考题　306
第8章　分布式数据库管理　307
8-1　分布式数据库的管理和维护　307
8-1-1　管理分布式系统中的全局名　307
8-1-2　创建数据库链接　310
8-1-3　创建共享数据库链接　313
8-1-4　管理数据库链接　315
8-1-5　查看有关数据库链接的信息　316
8-1-6　dml语句区域无关性　319
8-2　基于分布式数据库的应用开发　319
8-2-1　管理应用数据的分布　320
8-2-2　控制靠数据库链接建立起来的连接　320
8-2-3　维护分布式系统中的参照完整性约束　320
8-2-4　协调分布式查询　321
8-2-5　远程过程管理异常　324
思考题　324
附录　325
i.　oracle 9i在不同环境下的安装　325
i-1　在windows 2000环境下的安装　325
i-2　安装oracle 10g(10.1.0)for linux　337
ii.　web server开发过程和函数参考　350
iii.　oracle预编译连接文件示例　367
iv.　oracle预编译后的c语言源代码　370
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 9i/10g开发管理与实例
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8/8i开发使用手册
目目目录译者序前言第一部分
数

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8/8i开发使用手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8i SQLJ编程指南
贺辞序译者序科瑞恩序前

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8i SQLJ编程指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8i 数据库开发技术与技巧
贺词序作者简介马瑞斯序

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8i 数据库开发技术与技巧
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库应用管理解决方案
第1章 数据库在信息系统中的地位和作用
第2章 信息系统中数据库管理员的职责
第3章 应用系统数据库设计与实现
第4章 数据库运行中的常见问题及解决方法
第5章 数据的备份与恢复
第6章 应用系统过期数据的管理
第7章 历史数据库服务器的建立与维护
第8章 分布式数据库的应用与实现
第9章 数据库性能调整
第10章 数据库升级的实施
第11章 数据仓库技术的应用
第12章 自制数据库管理工具
附录A Oracle数据仓库解决方案
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库应用管理解决方案
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Portal Web开发
第一部分  开
篇第1章

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Portal Web开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8开发人员指南
译者序
前言
引言
第一部分 Oracle Designer
第1章 Designer的概念
1.1 查看Designer 2.

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8开发人员指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8故障解决手册
目 录
贺词
序
译者的话
前言
第1章 MS－Windows3.1中的预防性维护
1.1安装前的任务
1.1.1检验资源的有效性
1.1.2备份环境文件
1.1.3其他任务
1.1.4用文件服务器进行安装的特殊任务
1.2了解Windows3.1中的Oracle安装过程
1.2.1概述
1.2.2重要的安装文件
1.2.3可安装的产品/组件
1.2.4安装过程
1.3安装后的任务
1.3.1备份环境文件
1.3.2创建工具所需要表的脚本
1.3.3添加环境变量
1.4四种安装类型
1.4.1Oracle单机安装
1.4.2Oracle客户机/服务器安装
1.4.3第三方产品
1.4.4非Oracle的RDBMS
1.5优化
1.5.1SMARTDrive
1.5.2硬盘优化
1.5.3永久交换文件
1.5.4 FILESYSCHANGE
1.5.5图形端口
1.5.6DOS缓冲区
1.5.7显示驱动程序
1.5.8RESERVEPAGEFRAM E
1.5.9D2KINIT.EXE（仅限于Developer/2000）
1.5.10报表服务器（仅限于Developer/2000Reports）
1.5.11扩展内存
1.5.12字体别名化（仅用于Developer/2000）
1.6一些其他提示
1.6.1定义缺省连接
1.6.2为程序项提供命令行参数
1.6.3在用户名域中提供登录参数
1.6.4在WIN.INI中覆盖ORACLE.INI中的参数
1.6.5放弃ORACLE.INI中的参数
1.7常见问题
第2章 MS－Windows95中的预防性维护
2.1安装前的任务
2.1.1检查资源的有效性
2.1.2备份配置信息
2.1.3其他任务
2.1.4用文件服务器进行安装的特殊任务
2.2了解Windows95中的Oracle安装程序和安装过程
2.2.1概述
2.2.2重要的安装文件
2.2.3可安装的产品/组件概述
2.2.4安装过程
2.3安装后的任务
2.3.1备份配置信息
2.3.2创建工具所需要的表脚本
2.3.3添加环境变量
2.4四种安装类型
2.4.1Oracle单机安装的例子
2.4.2Oracle客户机/服务器安装
2.4.3第三方产品
2.4.4非Oracle的RDBMS
2.5优化
2.5.1硬盘优化
2.5.2虚拟内存
2.5.3报表服务器（仅限于Developer/2000 Reports）
2.6常见问题
第3章 MS－WindowsNT中的预防性维护
3.1安装前的任务
3.1.1检测资源的有效性
3.1.2备份配置信息
3.1.3其他任务
3.1.4用文件服务器进行安装的特殊任务
3.2了解OracleforWindowsNT的安装过程
3.3优化WindowsNT
3.4备份WindowsNT中的Oracle7工作组服务器
3.4.1冷备份
3.4.2在线备份
3.5常见问题
第4章Solaris中的预防性维护
4.1安装前的任务
4.1.1检测资源的有效性
4.1.2配置UNIX环境
4.2Sun Solaris2.x中的Oracle安装过程
4.2.1预览Oracle安装程序
4.2.2重要安装文件
4.2.3可用产品和组件的安装
4.2.4使用Oracle安装程序安装
4.2.5重新链接可执行的Oracle产品
4.3两种类型的安装
4.3.1Oracle单机安装
4.3.2Oracle客户机/服务器安装
4.4常见问题
第5章 UNIX中的预防性维护
5.1配置用户UNIX环境
5.2重新链接可执行的Oracle产品
5.3配置共享内存和信号
5.4核心转储
5.5建立永久性配置域
5.6常见问题
第6章 OpenVMS中的预防性维护
6.1安装前的任务
6.1.1检查许可权
6.1.2检查磁盘空间
6.1.3安装联机文档
6.2在OpenVMS上的ORACLE安装程序（ORACLEINS.COM）
6.3安装
6.3.1装入产品
6.3.2产品配置
6.3.3建立可执行文件
6.4建立一个新的实例和数据库
6.5安装后的任务
6.5.1创建演示图表
6.5.2测试数据库的安装
6.5.3选择ARCHIVELOG方式
6.5.4测试安装的Oracle共享图像
6.6常见问题
第7章 解决RDBMS问题
7.1创建数据库
7.2用户管理
7.2.1创建Oracle用户
7.2.2删除Oracle用户
7.2.3修改Oracle用户的口令
7.2.4环境文件
7.3重建数据库模式和对象
7.3.1回滚段
7.3.2重做日志文件
7.3.3表空间
7.3.4表
7.4空间管理
7.4.1管理数据目录下的空间数据
7.4.2表的空间管理
7.4.3索引的空间管理
7.4.4临时段的空间管理
7.4.5回滚段管理
7.4.6管理重做日志文件
7.4.7数据库增大的管理
7.5性能优化
7.5.1优化内存管理
7.5.2输入/输出优化
7.5.3优化排序
7.5.4优化索引结构
7.6备份和恢复
7.6.1备份的提示
7.6.2恢复
7.7Oracle7服务器诊断特征
7.7.1Oracle跟踪文件
7.7.2设置跟踪事件
7.7.3V＄监视视图
7.7.4加锁实用程序
7.8Oracle错误分析和解决方案
7.8.1常见Oracle错误
7.8.2Oracle内部错误
7.8.3优先权1/优先2问题分类和诊断操作
7.9常见问题
第8章 连接性问题的解决
8.1SQL Net概述
8.2安装SQL Net
8.2.1在UNIX（SunSo1aris2.5）上安装SQL Net
8.2.2在WindowsNT上安装SQL Net
8.3多线程服务器（MTS）
8.3.1MTS的配置
8.3.2向监听器注册
8.3.3客户机连接
8.4OracleNames
8.5SQL Net跟踪
8.5.1跟踪水平
8.5.2解释SQL Net跟踪信息
8.5.3信息包
8.5.4错误输出
8.6ODBC概述
8.7安装
8.7.1Windows95中的ODBC配置
8.7.2测试ODBC驱动器
8.8常见问题
第9章 解决Developer/2000问题
9.1安装
9.2环境变量
9.3升级Developer/2000
9.3.1GUI的区别
9.3.2升级过程概述
9.4Developer/2000工具中的常见错误
9.5常见问题
第10章 解决Oracle预编译器问题
10.1用预编译器开发程序
10.2对浮点数和双精度数的处理
10.3字符串和可变字符串的处理
10.4长原型数据
10.5C＋＋编译器
10.6不同操作系统支持的编译器
10.7常见问题
第11章 访问Oracle全球客户支持
11.1关于Oracle全球客户支持
11.1.1Oraclemetals
11.1.2Oraclefoundation
11.2Oracle产品信息
11.3操作系统信息
11.3.1个人计算机的通用信息
11.3.2UNIX计算机的通用信息
11.3.3VAX或ALPHAOpenVMS系统的通用信息
11.4为了获得更好支持的8条提示
11.5常见问题

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8故障解决手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8起步与进阶
第1章　Oracle　8起步
1. 1　Personal　Oracle　8
1. 2　数据类型
1. 2. 1　字符型数据类型
1. 2. 2　数字型数据类型（NUMBER）
1. 2. 3　DAT

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8起步与进阶
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 数据库的实施和管理
第1章  Oracle数据库概述
1. 1  什么是Oracle数据库
1. 1. 1  怎样实施Oracle数据库
1. 1. 2  如何管理Oracle数据库
1. 2

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 数据库的实施和管理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8.x for Windows NT 实用教程
第1章 数据库系统基础知识
1

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8.x for Windows NT 实用教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle与Visual Basic编程指南
第一部分  Oracle简介
第1章
Oracle与VisualBasic
Oracle的简史
关系数据库的结构
Oracle服务器
Oracle服务器的高级功能

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle与Visual Basic编程指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Financials 使用手册
贺辞序译者的话前言第一

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Financials 使用手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle安全手册
译者序
前言
第一部分 基础知识
第二部分 操作系统的安全
第三部分 保护Oracel数据库
第四部分 保护网络通信
第五部分 黑客和问题解决
附录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle安全手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle XML开发手册
贺辞序作者简介菲利普序前言第1章

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle XML开发手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle程序设计
第1章  数据库基础
1. 1  数据库基本概念
1. 1. 1  数据. 数据库. 数据库管理系统. 数据库系统
1. 1. 2  数据模型
1. 1. 3  数据库系统体系结构
1. 2  关系数据库

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8i for NT DBA培养手册
第1章  0racle公司和Oracle的来历
1. 1  Larry Ellison的背景
1. 2  Ellison的处事风格
1. 3  创业过程
1. 4  0racle名称的由来

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8i for NT DBA培养手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle WebDB 应用开发技术
第1章 绪论
1 WWW技术概览
……
第2章 WebDB的安装与配置
1 系统环境要求
……
第3章 WebDB应用开发技术
1 用户管理
……
第4章 JavaScript与数据合法性检查
1 数据合法性检查
……
第5章 建立WebDB站点
1 创建WebDB站点
……
第6章 发布WebDB站点
1 WebDB的发布组件与体系结构
……
第7章 WebDB性能监视
1 组件监视实用程序
……
附录A 建立TUTORIAL上机实习环境
附录B 术语
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle WebDB 应用开发技术
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Web应用培训教程
译者序
序言
前言
第一部分 Web应用介绍
第1章 为什么使用Web应用
第2章 如何建立Web应用
第3章 Oracle Web体系结构
第二部分 建立Web应用
第5章 设计HTML应用
第6章 使用Java
第7章 编写PL/SQL
第三部分 参考
第11章 商务工具
第12章 Web应用工具箱
第13章 有用的书籍和Web站点
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Web应用培训教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Applications性能调整手册
译者序
序言
前言
第一部分  用于调查和编制应用性能文档的工具
第1章 性能方法论
……
第二部分 优化应用技术栈
第3章 开始调查
……
第三部分 优化用户和应用子系统
第12章 优化用户
……
第四部分 优化案例和回顾
第15章 案例研究
……
第五部分 附录
附录A 项目文档摘要
附录B 记录性能问题
附录C 本书光盘内容介绍
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle Applications性能调整手册
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle与PowerBuilder实战演练
第一篇  战前准备
第1章  软件工程理论的准备
1. 1  系统开发计划
1. 1. 1  可行性研究
1. 1. 2  系统需求鉴别
1. 1. 3  成本／效益分析

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle与PowerBuilder实战演练
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8.1.6开发指南(1CD)
第一篇 Oracle 8i性能设计与优化
第一部分 性能优化基础知识
1 理解Oracle性能优化
1.1 性能优化定义
1.2 优化的执行者
1.3 设置性能目标
1.4 设置用户期望值
1.5 性能评价
2 性能优化方法
2.1 何时优化效率最高
2.2 优化的优先步骤
2.3 应用优化方法
第二部分 设计人员和开发人员的应用程序设计优化

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle 8.1.6开发指南(1CD)
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库设计与实现
前言第1章  数据库基础知识  1.1 数据库基本概念    1.1.1 数据库及其基本特点    1.1.2 数据库技术发展历史    1.1.3 关系数据库基本概念    1.1.4 数据库管理系统简介  1.2 数据库开发简介    1.2.1 数据库开发的目标    1.2.2 数据库开发过程  1.3 工作环境的准备    1.3.1 Oracle10gR2Express的安装及启动    1.3.2 Oracle Application Express的安装    1.3.3 Oracle Application Express的使用  1.4 项目案例介绍    1.4.1 项目案例1公司人事管理系统    1.4.2 项目案例2GreenOil公司信息系统    1.4.3 项目案例3GeBID(全球传染数据银行)  1.5 技术小结  1.6 关键术语  1.7 章 节练习第2章  数据建模语言  ……第3章  数据库建模过程第4章  概念模型向物理模型转换第5章  使用SQL实现数据库设计第6章  使用SQL检索数据库第7章  使用Oracle Application Express开发Web应用第8章  数据库设计项目实训附录A 公司人事管理系统概念模型和物理模型附录B  Green Oil公司信息系统概念模型和物理模型附录C  Green Oil公司矩阵图参考文献
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oracle数据库设计与实现
