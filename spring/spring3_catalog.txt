>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring 3.x企业应用开发实战
第1篇 概述
第1章 Spring概述
1.1 认识Spring
1.2 关于SpringSource
1.3 Spring带给我们什么
1.4 Spring体系结构
1.5 Spring 3.0的新功能
1.5.1 核心API更新到Java 5.
1.5.2 Spring表达式语言
1.5.3 可通过Java类提供IoC配置信息
1.5.4 通用类型转换系统和属性格式化系统
1.5.5 数据访问层新增OXM功能
1.5.6 Web层的增强
1.5.7 其他
1.6 Spring对Java版本的要求
1.7 如何获取Spring
1.8 小结
第2章 快速入门
2.1 实例功能概述
2.1.1 比Hello World更适用的实例
2.1.2 实例功能简介
2.2 环境准备
2.2.1 创建库表
2.2.2 建立工程
2.2.3 类包及Spring配置文件规划
2.3 持久层
2.3.1 建立领域对象
2.3.2 UserDao
2.3.3 LoginLogDao
2.3.4 在Spring中装配DAO
2.4 业务层
2.4.1 UserService
2.4.2 在Spring中装配Service
2.4.3 单元测试
2.5 展现层
2.5.1 配置Spring MVC框架
2.5.2 处理登录请求
2.5.3 JSP视图页面
2.6 运行Web应用
2.7 小结
第2篇 IoC和AOP
第3章 IoC容器概述
3.1 IoC概述
3.1.1 通过实例理解IoC的概念
3.1.2 IoC的类型
3.1.3 通过容器完成依赖关系的注入
3.2 相关Java基础知识
3.2.1 简单实例
3.2.2 类装载器ClassLoader
3.2.3 Java反射机制
3.3 资源访问利器
3.3.1 资源抽象接口
3.3.2 资源加载
3.4 BeanFactory和ApplicationContext
3.4.1 BeanFactory介绍
3.4.2 ApplicationContext介绍
3.4.3 父子容器
3.5 Bean的生命周期
3.5.1 BeanFactory中Bean的生命周期
3.5.2 ApplicationContext中Bean的生命周期
3.6 小结
第4章 在IoC容器中装配Bean
4.1 Spring配置概述
4.1.1 Spring容器高层视图
4.1.2 基于XML的配置
4.2 Bean基本配置
4.2.1 装配一个Bean
4.2.2 Bean的命名
4.3 依赖注入
4.3.1 属性注入
4.3.2 构造函数注入
4.3.3 工厂方法注入
4.3.4 选择注入方式的考量
4.4 注入参数详解
4.4.1 字面值
4.4.2 引用其他Bean
4.4.3 内部Bean
4.4.4 null值
4.4.5 级联属性
4.4.6 集合类型属性
4.4.7 简化配置方式
4.4.8 自动装配
4.5 方法注入
4.5.1 lookup方法注入
4.5.2 方法替换
4.6 ＜bean＞之间的关系
4.6.1 继承
4.6.2 依赖
4.6.3 引用
4.7 整合多个配置文件
4.8 Bean作用域
4.8.1 singleton作用域
4.8.2 prototype作用域
4.8.3 Web应用环境相关的Bean作用域
4.8.4 作用域依赖问题
4.9 FactoryBean
4.10 基于注解的配置
4.10.1 使用注解定义Bean
4.10.2 使用注解配置信息启动Spring容器
4.10.3 自动装配Bean
4.10.4 Bean作用范围及生命过程方法
4.11 基于Java类的配置
4.11.1 使用Java类提供Bean定义信息
4.11.2 使用基于Java类的配置信息启动Spring容器
4.12 不同配置方式比较
4.13 小结
第5章 Spring容器高级主题
5.1 Spring容器技术内幕
5.1.1 内部工作机制
5.1.2 BeanDefinition
5.1.3 InstantiationStrategy
5.1.4 BeanWrapper
5.2 属性编辑器
5.2.1 JavaBean的编辑器
5.2.2 Spring默认属性编辑器
5.2.3 自定义属性编辑器
5.3 使用外部属性文件
5.3.1 使用外部属性文件
5.3.2 使用加密的属性文件
5.3.3 属性文件自身的引用
5.4 引用Bean的属性值
5.5 国际化信息
5.5.1 基础知识
5.5.2 MessageSource
5.5.3 容器级的国际化信息资源
5.6 容器事件
5.6.1 Spring事件类结构
5.6.2 解构Spring事件体系的具体实现
5.6.3 一个实例
5.7 小结
第6章 Spring AOP基础
6.1 AOP概述
6.1.1 AOP到底是什么
6.1.2 AOP术语
6.1.3 AOP的实现者
6.2 基础知识
6.2.1 带有横切逻辑的实例
6.2.2 JDK动态代理
6.2.3 CGLib动态代理
6.2.4 AOP联盟
6.2.5 代理知识小结
6.3 创建增强类
6.3.1 增强类型
6.3.2 前置增强
6.3.3 后置增强
6.3.4 环绕增强
6.3.5 异常抛出增强
6.3.6 引介增强
6.4 创建切面
6.4.1 切点类型
6.4.2 切面类型
6.4.3 静态普通方法名匹配切面
6.4.4 静态正则表达式方法匹配切面
6.4.5 动态切面
6.4.6 流程切面
6.4.7 复合切点切面
6.4.8 引介切面
6.5 自动创建代理
6.5.1 实现类介绍
6.5.2 BeanNameAutoProxyCreator
6.5.3 DefaultAdvisorAutoProxyCreator
6.6 小结
第7章 基于@AspectJ和Schema的AOP
7.1 Spring对AOP的支持
7.2 JDK 5.0注解知识快速进阶
7.2.1 了解注解
7.2.2 一个简单的注解类
7.2.3 使用注解
7.2.4 访问注解
7.3 着手使用@AspectJ
7.3.1 使用前的准备
7.3.2 一个简单的例子
7.3.3 如何通过配置使用@AspectJ切面
7.4 @AspectJ语法基础
7.4.1 切点表达式函数
7.4.2 在函数入参中使用通配符
7.4.3 逻辑运算符
7.4.4 不同增强类型
7.4.5 引介增强用法
7.5 切点函数详解
7.5.1 @annotation（）
7.5.2 execution（）
7.5.3 args（）和@args（）
7.5.4 within（）
7.5.5 @within（）和@target（）
7.5.6 target（）的this（）
7.6 @AspectJ进阶
7.6.1 切点复合运算
7.6.2 命名切点
7.6.3 增强织入的顺序
7.6.4 访问连接点信息
7.6.5 绑定连接点方法入参
7.6.6 绑定代理对象
7.6.7 绑定类注解对象
7.6.8 绑定返回值
7.6.9 绑定抛出的异常
7.7 基于Schema配置切面
7.7.1 一个简单切面的配置
7.7.2 配置命名切点
7.7.3 各种增强类型的配置
7.7.4 绑定连接点信息
7.7.5 Advisor配置
7.8 混合切面类型
7.8.1 混合使用各种切面类型
7.8.2 各种切面类型总结
7.9 JVM Class文件字节码转换基础知识
7.9.1 java.lang.instrument包的工作原理
7.9.2 如何向JVM中注册转换器
7.9.3 使用JVM启动参数注册转换器的问题
7.10 使用LTW织入切面
7.10.1 Spring的LoadTimeWeaver
7.10.2 使用LTW织入一个切面
7.10.3 在Tomcat下的配置
7.10.4 在其他Web应用服务器下的配置
7.11 小结
第3篇 数据访问
第8章 Spring对DAO的支持
8.1 Spring的DAO理念
8.2 统一的异常体系
8.2.1 Spring的DAO异常体系
8.2.2 JDBC的异常转换器
8.2.3 其他持久技术的异常转换器
8.3 统一数据访问模板
8.3.1 使用模板和回调机制
8.3.2 Spring为不同持久化技术所提供的模板类
8.4 数据源
8.4.1 配置一个数据源
8.4.2 获取JNDI数据源
8.4.3 Spring的数据源实现类
8.5 小结
第9章 Spring的事务管理
9.1 数据库事务基础知识
9.1.1 何为数据库事务
9.1.2 数据并发的问题
9.1.3 数据库锁机制
9.1.4 事务隔离级别
9.1.5 JDBC对事务支持
9.2 ThreadLocal基础知识
9.2.1 ThreadLocal是什么
9.2.2 ThreadLocal的接口方法
9.2.3 一个TheadLocal实例
9.2.4 与Thread同步机制的比较
9.2.5 Spring使用ThreadLocal解决线程安全问题
9.3 Spring对事务管理的支持
9.3.1 事务管理关键抽象
9.3.2 Spring的事务管理器实现类
9.3.3 事务同步管理器
9.3.4 事务传播行为
9.4 编程式的事务管理
9.5 使用XML配置声明式事务
9.5.1 一个将被实施事务增强的服务接口
9.5.2 使用原始的
TransactionProxyFactoryBean
9.5.3 基于tx/aop命名空间的配置
9.6 使用注解配置声明式事务
9.6.1 使用@Transactional注解
9.6.2 通过AspectJ LTW引入事务切面
9.7 集成特定的应用服务器
9.7.1 BEA WebLogic
9.7.2 BEA WebLogic
9.8 小结
第10章 Spring的事务管理难点剖析
10.1 DAO和事务管理的牵绊
10.1.1 JDBC访问数据库
10.1.2 Hibernate访问数据库
10.2 应用分层的迷惑
10.3 事务方法嵌套调用的迷茫
10.3.1 Spring事务传播机制回顾
10.3.2 相互嵌套的服务方法
10.4 多线程的困惑
10.4.1 Spring通过单实例化Bean简化多线程问题
10.4.2 启动独立线程调用事务方法
10.5 联合军种作战的混乱
10.5.1 Spring事务管理器的应对
10.5.2 Hibernate+Spring JDBC混合框架的事务管理
10.6 特殊方法成漏网之鱼
10.6.1 哪些方法不能实施Spring AOP事务
10.6.2 事务增强遗漏实例
10.7 数据连接泄漏
10.7.1 底层连接资源的访问问题
10.7.2 Spring JDBC数据连接泄漏
10.7.3 通过DataSourceUtils获取数据连接
10.7.4 通过DataSourceUtils获取数据连接
10.7.5 JdbcTemplate如何做到对连接泄漏的免疫
10.7.6 使用TransactionAwareDataSourceProxy
10.7.7 其他数据访问技术的等价类
10.8 小结
第11章 使用Spring JDBC访问数据库
11.1 使用Spring JDBC
11.1.1 JDBCTemplate小试牛刀
11.1.2 在DAO中使用JDBCTemplate
11.2 基本的数据操作
11.2.1 更改数据
11.2.2 返回数据库的表自增主键值
11.2.3 批量更改数据
11.2.4 查询数据
11.2.5 查询单值数据
11.2.6 调用存储过程
11.3 BLOB/CLOB类型数据的操作
11.3.1 如何获取本地数据连接
11.3.2 相关的操作接口
11.3.3 插入Lob类型的数据
11.3.4 以块数据方式读取Lob数据
11.3.5 以流数据方式读取Lob数据
11.4 自增键和行集
11.4.1 自增键的使用
11.4.2 如何规划主键方案
11.4.3 以行集返回数据
11.5 其他类型的JDBCTemplate
11.5.1 NamedParameterJDBCTemplate
11.5.2 SimpleJDBCTemplate
11.6 以OO方式访问数据库
11.6.1 使用MappingSqlQuery查询数据
11.6.2 使用SqlUpdate更新数据
11.6.3 使用StoredProcedure执行存储过程
11.6.4 SqlFunction类
11.7 小结
第12章 整合其他ORM框架
12.1 Spring整合ORM技术
12.2 在Spring中使用Hibernate
12.2.1 配置SessionFactory
12.2.2 使用HibernateTemplate
12.2.3 处理LOB类型数据
12.2.4 添加Hibernate事件监听器
12.2.5 使用原生Hibernate API
12.2.6 使用注解配置
12.2.7 事务处理
12.2.8 延迟加载的问题
12.3 在Spring中使用myBatis
12.3.1 配置SqlMapClient
12.3.2 在Spring配置myBatis
12.3.3 编写myBatis的DAO
12.5 DAO层设计
12.5.1 DAO基类的设计
12.5.2 查询接口方法的设计
12.5.3 分页查询接口设计
12.6 小结
第4篇 业务层及Web层技术
第13章 任务调度和异步执行器
13.1 任务调度概述
13.2 Quartz快速进阶
13.2.1 Quartz基础结构
13.2.2 使用SimpleTrigger
13.2.3 使用CronTrigger
13.2.4 使用Calendar
13.2.5 任务调度信息存储
13.3 在Spring中使用Quartz
13.3.1 创建JobDetail
13.3.2 创建Trigger
13.3.3 创建Scheduler
13.4 Spring中使用JDK Timer
13.4.1 Timer和TimerTask
13.4.2 Spring对JDK Timer的支持
13.5 Spring对JDK 5.0 Executor的支持
13.5.1 了解JDK 5.0的Executor
13.5.2 Spring对Executor所提供的抽象
13.6 实际应用中的任务调度
13.6.1 如何产生任务
13.6.2 任务调度对应用程序集群的影响
13.6.3 任务调度云
13.6.4 Web应用程序中调度器的启动和关闭问题
13.7 小结
第14章 使用OXM进行对象XML映射
14.1 认识XML解析技术
14.1.1 什么是XML
14.1.2 XML的处理技术
14.2 XML处理利器：XStream
14.2.1 XStream概述
14.2.2 快速入门
14.2.3 使用XStream别名
14.2.4 XStream转换器
14.2.5 XStream注解
14.2.6 流化对象
14.2.7 持久化API
14.2.8 额外功能：处理JSON
14.3 其他常见O/X Mapping开源项目
14.3.1 JAXB
14.3.2 XMLBeans
14.3.3 Castor
14.3.4 JiBX
14.3.5 总结比较
14.4 与Spring OXM整合
14.4.1 Spring OXM概述
14.4.2 整合OXM实现者
14.4.3 如何在Spring中进行配置
14.4.4 Spring OXM 简单实例
14.5 小结
第15章 Spring MVC
15.1 Spring MVC概述
15.1.1 体系结构
15.1.2 配置DispatcherServlet
15.1.3 一个简单的实例
15.2 注解驱动的控制器
15.2.1 使用@RequestMapping映射请求
15.2.2 请求处理方法签名概述
15.2.3 处理方法签名详细说明
15.2.4 使用HttpMessageConverter＜T＞
15.2.5 处理模型数据
15.3 处理方法的数据绑定
15.3.1 数据绑定流程剖析
15.3.2 数据转换
15.3.3 数据格式化
15.3.4 数据校验
15.4 视图和视图解析器
15.4.1 认识视图
15.4.2 认识视图解析器
15.4.3 JSP和JSTL
15.4.4 模板视图
15.4.5 Excel
15.4.6 PDF
15.4.7 输出XML
15.4.8 输出JSON
15.4.9 使用XmlViewResolver
15.4.10 使用ResourceBundle ViewResolver
15.4.11 混合使用多种视图技术
15.5 本地化解析
15.5.1 本地化概述
15.5.2 使用CookieLocaleResolver
15.5.3 使用SessionLocaleResolver
15.5.4 使用LocaleChangeInterceptor
15.6 文件上传
15.6.1 配置MultipartResolver
15.6.2 编写控制器和文件上传表单页面
15.7 杂项
15.7.1 静态资源处理
15.7.2 装配拦截器
15.7.3 异常处理
15.8 小结
第5篇 测试及实战
第16章 实战型单元测试
16.1 单元测试概述
16.1.1 为什么需要单元测试
16.1.2 单元测试之误解
16.1.3 单元测试之困境
16.1.4 单元测试基本概念
16.2 JUnit 4快速进阶
16.2.1 JUnit 4概述
16.2.2 JUnit 4生命周期
16.2.3 使用JUnit
16.3 模拟利器Mockito
16.3.1 模拟测试概述
16.3.2 创建Mock对象
16.3.3 设定Mock对象的期望行为及返回值
16.3.4 验证交互行为
16.4 测试整合之王Unitils
16.4.1 Unitils概述
16.4.2 集成Spring
16.4.3 集成Hibernate
16.4.4 集成Dbunit
16.4.5 自定义扩展模块
16.5 使用Unitils测试DAO层
16.5.1 数据库测试的难点
16.5.2 扩展Dbunit用Excel准备数据
16.5.3 测试实战
16.6 使用unitils测试Service层
16.7 测试Web层
16.7.1 对LoginController进行单元测试
16.7.2 使用Spring Servlet API模拟对象
16.7.3 使用Spring RestTemplate测试
16.7.4 使用Selenium测试
16.8 小结
第17章 实战案例开发
17.1 论坛案例概述
17.1.1 论坛整体功能结构
17.1.2 论坛用例描述
17.1.3 主要功能流程描述
17.2 系统设计
17.2.1 技术框架选择
17.2.2 Web目录结构及类包结构规划
17.2.3 单元测试类包结构规划
17.2.4 系统的结构图
17.2.5 PO的类设计
17.2.6 持久层设计
17.2.7 服务层设计
17.2.8 Web层设计
17.2.9 数据库设计
17.3 开发前的准备
17.4 持久层开发
17.4.1 PO类
17.4.2 DAO基类
17.4.3 通过扩展基类所定义DAO类
17.4.4 DAO Bean的装配
17.4.5 使用Hibernate二级缓存
17.5 对持久层进行测试
17.5.1 配置Unitils测试环境
17.5.2 准备测试数据库及测试数据
17.5.3 编写DAO测试基类
17.5.4 编写BoardDao测试用例
17.6 服务层开发
17.6.1 UserService的开发
17.6.2 ForumService的开发
17.6.3 服务类Bean的装配
17.7 对服务层进行测试
17.7.1 编写Service测试基类
17.7.2 编写ForumService测试用例
17.8 Web层开发
17.8.1 BaseController的基类
17.8.2 用户登录和注销
17.8.3 用户注册
17.8.4 论坛管理
17.8.5 论坛普通功能
17.8.6 分页显示论坛版块的主题帖子
17.8.7 web.xml配置
17.8.8 Spring MVC配置
17.9 对Web层进行测试
17.9.1 编写Web测试基类
17.9.2 编写ForumManageController测试用例
17.10 部署和运行应用
17.11 小结
以下内容详见本书配书光盘：
附录A JavaMail发送邮件
附录B 在Spring中开发Web Service
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring 3.x企业应用开发实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻量级Java EE企业应用实战
第1章  Java EE应用和开发环境  1.1  Java EE应用概述    1.1.1  Java EE应用的分层模型    1.1.2  Java EE应用的组件    1.1.3  Java EE应用结构和优势    1.1.4  常用的Java EE服务器  1.2  轻量级Java EE应用相关技术    1.2.1  JSP、Servlet 3.0和JavaBean及替代技术    1.2.2  Struts 2.2及替代技术    1.2.3  Hibernate 3.6及替代技术    1.2.4  Spring 3.0及替代技术  1.3  Tomcat的下载和安装    1.3.1  安装Tomcat服务器    1.3.2  配置Tomcat的服务端口    1.3.3  进入控制台    1.3.4  部署Web应用    1.3.5  配置Tomcat的数据源  1.4  Eclipse的安装和使用    1.4.1  Eclipse的下载和安装    1.4.2  在线安装Eclipse插件    1.4.3  从本地压缩包安装插件    1.4.4  手动安装Eclipse插件    1.4.5  使用Eclipse开发Java EE应用    1.4.6  导入Eclipse项目    1.4.7  导入非Eclipse项目  1.5  Ant的安装和使用    1.5.1  Ant的下载和安装    1.5.2  使用Ant工具    1.5.3  定义生成文件    1.5.4  Ant的任务(task)  1.6  使用CVS进行协作开发    1.6.1  安装CVS服务器    1.6.2  配置CVS资源库    1.6.3  安装CVS客户端    1.6.4  发布项目到服务器    1.6.5  从服务器下载项目    1.6.6  同步(Update)本地文件    1.6.7  提交(Commit)修改    1.6.8  添加文件和目录    1.6.9  删除文件和目录    1.6.10  查看文件的版本变革    1.6.11  提取文件以前版本的内容    1.6.12  从以前版本重新开始    1.6.13  创建标签    1.6.14  创建分支    1.6.15  沿着分支开发    1.6.16  使用Eclipse作为CVS客户端  1.7  本章小结第2章  JSP/Servlet及相关技术详解  ……第3章  Struts 2的基本用法第4章  深入使用Struts 2第5章  Hibernate的基本用法第6章  深入使用Hibernate第7章  Spring的基本用法第8章  深入使用Spring第10章  简单工作流系统
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻量级Java EE企业应用实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻量级Java Web 整合开发入门——Struts 2+Hibernate 4+Spring 3
第1章  轻量级Java Web开发概述	1
1.1  Java概述	1
1.2  Java Web开发概述	2
1.2.1  Java Web项目基本结构	2
1.2.2  轻量级Java Web开发概述	7
1.2.3  经典Java Web开发概述	7
1.3  常用的Java Web服务器	7
1.4  轻量级Java Web开发环境	9
1.4.1  环境变量的配置	9
1.4.2  常用的集成开发环境	10
1.5  轻量级Java Web开发相关技术	11
1.5.1  JSP简介	12
1.5.2  数据库技术简介	13
1.5.3  配置文件的格式	13
1.5.4  其他相关软件	15
1.6  Java Web项目的部署	15
1.6.1  拷贝部署法	15
1.6.2  WAR包部署法	16
1.6.3  IDE部署法	17
1.7  学习轻量级Java Web开发的方法	18
1.8  本章小结	18
1.9  习题	18
1.10  实验	19
第2章  设计模式概述	21
2.1  单例模式	22
2.2  工厂模式	23
2.2.1  简单工厂模式	23
2.2.2  工厂方法模式	27
2.2.3  抽象工厂模式	29
2.3  代理模式	31
2.4  命令模式	33
2.5  策略模式	36
2.6  MVC	38
2.7  本章小结	40
2.8  习题	41
2.9  实验	42
第3章  Struts 2框架	43
3.1  Struts 2框架概述	43
3.1.1  Struts 2框架的由来	43
3.1.2  Struts 2框架的下载和安装	44
3.1.3  Struts 2框架的体系结构图	45
3.2  Struts 2框架的基本用法	46
3.2.1  使用Struts 2框架的开发步骤	47
3.2.2  Struts 2框架的Action接口	48
3.2.3  Struts 2框架的配置文件	49
3.2.4  完整的Struts 2框架应用实例	50
3.3  Struts 2框架的标签库	57
3.3.1  Struts 2标签库和JSP标签库的
区别	57
3.3.2  常用的Struts 2标签介绍	58
3.3.3  Struts 2框架的国际化支持	59
3.3.4  用户注册的实例	64
3.4  Struts 2框架的高级应用	66
3.4.1  Struts 2的类型转换	66
3.4.2  Struts 2的输入校验	72
3.4.3  Struts 2的文件上传与下载	76
3.4.4  Struts 2的拦截器	83
3.5  本章小结	90
3.6  习题	91
3.7  实验	92
第4章  Hibernate框架	93
4.1  Hibernate框架概述	93
4.1.1  ORM的概念	93
4.1.2  常用的ORM框架	94
4.1.3  JPA的概念	94
4.1.4  Hibernate的下载和安装	95
4.1.5  Hibernate框架的结构图	96
4.2  Hibernate框架的基本用法	98
4.2.1  使用Hibernate框架的流程	98
4.2.2  Hibernate框架的核心类	110
4.2.3  持久化类的概念	112
4.2.4  Hibernate框架的配置文件	114
4.2.5  Hibernate框架的映射文件	116
4.2.6  使用Hibernate进行增删改查	118
4.3  Hibernate框架的高级应用	124
4.3.1  Hibernate框架的关联映射	124
4.3.2  Hibernate框架的查询	138
4.3.3  Hibernate的批量处理	146
4.4  本章小结	149
4.5  习题	149
4.6  实验	150
第5章  Spring框架	151
5.1  Spring框架概述	151
5.1.1  Spring框架简介	152
5.1.2  Spring框架的下载和安装	153
5.1.3  Spring框架的结构图	154
5.1.4  使用Spring框架的好处	156
5.2  Spring框架的基本用法	157
5.2.1  使用Spring框架的流程	157
5.2.2  Spring框架的使用范围	158
5.2.3  Spring框架的依赖注入	159
5.2.4  Spring框架的配置文件	164
5.3  Spring框架的高级应用	165
5.3.1  Spring的后处理器	165
5.3.2  Spring的资源访问	168
5.3.3  Spring的AOP	171
5.3.4  使用AOP进行权限验证及
日志记录	172
5.4  Java的反射和代理	176
5.4.1  Java的反射	176
5.4.2  Java的代理	181
5.5  本章小结	186
5.6  习题	186
5.7  实验	187
第6章  轻量级整合开发实例	189
6.1  整合开发概述	189
6.1.1  为什么要整合开发	189
6.1.2  常用的轻量级整合开发	189
6.2  Struts和Hibernate的整合开发	190
6.2.1  整合开发步骤	190
6.2.2  整合开发实例	190
6.3  Struts、Hibernate及Spring的整合开发	202
6.3.1  整合开发步骤	203
6.3.2  整合开发实例	203
6.3.3  整合开发注意事项	205
6.4  SSH整合开发实例：权限管理
系统	206
6.4.1  项目概述	206
6.4.2  项目详细创建过程	207
6.4.3  项目小结	221
6.5  轻量级整合和经典整合的区别	221
6.6  本章小结	221
6.7  习题	221
6.8  实验	222
第7章  Java Web开发常见问题	223
7.1  Struts 2框架常见问题	223
7.1.1  核心过滤器的配置	223
7.1.2  Web页面中文乱码问题	224
7.2  Hibernate框架常见问题	224
7.2.1  MySql服务不能启动	224
7.2.2  MySql数据库乱码问题	225

7.2.3  1-N双向关联映射统一外键问题	226
7.2.4  Hibernate 3和Hibernate 4二级缓存的配置区别	226
7.2.5  Hibernate生成表的默认名称对Linux和Windows的区别	227
7.2.6  Linux和Windows对路径表示方式的区别	228
7.3  Spring框架常见问题	228
7.4  一切问题的根源	228

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻量级Java Web 整合开发入门——Struts 2+Hibernate 4+Spring 3
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大型门户网站是这样炼成的！
第1篇 技术篇　第1章 大型门户网站架构分析　　1.1 大型门户网站与小型企业网站的区别　　1.2 高性能、高负载门户网站架构剖析　　　1.2.1 服务器操作系统的选择　　　1.2.2 DNS服务器BIND　　　1.2.3 Cache服务器Squid　　　1.2.4 带负载均衡的HTTP服务器Apache　　　1.2.5 支持集群功能的Web服务器Tomcat　　　1.2.6 开源数据库服务器之骄子MySQL　　　1.2.7 功能强大的FlV流媒体服务器RED5　　1.3 门户网站开发指导思想　　1.4 SSH 2组合框架—门户网站开发之首选　　　1.4.1 MVC混血宠儿Struts 2　　　1.4.2 幕后的财政部长Spring 2.5　　　1.4.3 ORM中间件香馍馍Hibernate 3.2　　1.5 小结　第2章 MVC混血宠儿Struts 2　　2.1 初识MVC新秀Struts 2　　　2.1.1 MVC概述　　　2.1.2 Struts 2的MVC实现　　　2.1.3 Struts 2的基本组成　　　2.1.4 Struts 2的常用类介绍　　　2.1.5 Struts 2的业务控制器Action实现　　　2.1.6 Struts 2的处理结果Result　　　2.1.7 功能强大的表达式语言OGNL　　　2.1.8 Struts 2的运行流程分析—HelloWorld　　　2.1.9 Struts 2的异常处理　　2.2 Struts 2配置精要　　　2.2.1 web.xml中Struts 2的配置实现　　　2.2.2 Struts 2属性配置文件struts.properties详解　　　2.2.3 Struts 2核心配置文件struts.xml详解　　2.3 Struts 2应用开发实务　　　2.3.1 Struts 2应用开发环境的搭建　　　2.3.2 Struts 2应用基本开发步骤—搭建ePortal应用　　　2.3.3 Struts 2中集成FCKeditor　　　2.3.4 Struts 2中集成DisplayTag　　2.4 Struts 2国际化实现　　　2.4.1 Web应用的中文本地化　　　2.4.2 Struts 2应用的国际化　　　2.4.3 Struts 2国际化语言的动态切换　　2.5 Struts 2的校验框架　　　2.5.1 在Action中实现手动校验　　　2.5.2 调用校验框架进行自动校验　　　2.5.3 自定义国际化Struts 2校验错误消息　　　2.5.4 Struts 2的自带校验器　　2.6 Struts 2的拦截器　　　2.6.1 Struts 2内建拦截器介绍　　　2.6.2 定义和使用拦截器栈　　　2.6.3 使用自定义拦截器　　2.7 小结　第3章 Struts 2标签库详解与AJAX技术应用　　3.1 Struts 2主题与模板　　3.2 Struts 2控制标签详解　　　3.2.1 if/elseif/else标签详解　　　3.2.2 iterator标签详解　　　3.2.3 append标签详解　　　3.2.4 generator标签详解　　　3.2.5 merge标签详解　　　3.2.6 subset标签详解　　　3.2.7 sort标签详解　　3.3 Struts 2数据标签详解　　　3.3.1 action标签详解　　　3.3.2 bean标签详解　　　3.3.3 date标签详解　　　3.3.4 debug标签详解　　　3.3.5 i18n标签详解　　　3.3.6 include标签详解　　　3.3.7 param标签详解　　　3.3.8 push标签详解　　　3.3.9 set标签详解　　　3.3.10 text标签详解　　　3.3.11 url标签详解　　　3.3.12 property标签详解　　3.4 Struts 2表单标签详解　　　3.4.1 checkbox标签详解　　　3.4.2 checkboxlist标签详解　　　3.4.3 combobox标签详解　　　3.4.4 doubleselect标签详解　　　3.4.5 file标签详解　　　3.4.6 form标签详解　　　3.4.7 hidden标签详解　　　3.4.8 select标签详解　　　3.4.9 optgroup标签详解　　　3.4.10 optiontransferselect标签详解　　　3.4.11 password标签详解　　　3.4.12 radio标签详解　　　3.4.13 reset与submit标签详解　　　3.4.14 textarea标签详解　　　3.4.15 textfield标签详解　　　3.4.16 token标签详解　　　3.4.17 updownselect标签详解　　3.5 Struts 2 AJAX标签详解　　　3.5.1 a与submit标签详解　　　3.5.2 autocompleter标签详解　　　3.5.3 datetimepicker标签详解　　　3.5.4 div标签详解　　　3.5.5 head标签详解　　　3.5.6 tabbedPanel标签详解　　3.6 Struts 2其他标签详解　　　3.6.1 actionerror与actionmessage标签详解　　　3.6.2 fielderror标签详解　　　3.6.3 tree与treenode标签详解　　3.7 Struts 2全力支持AJAX　　　3.7.1 Struts 2中原始AJAX技术应用　　　3.7.2 基于DWR的AJAX实现　　　3.7.3 基于DWR的AJAX表单验证　　　3.7.4 基于JSON插件的AJAX实现　　3.8 小结　第4章 ORM中间件名流Hibernate 3接管持久层　　4.1 ORM简介　　　4.1.1 持久化与持久层　　　4.1.2 JDBC劣势　　　4.1.3 实体域模型与关系数据模型　　　4.1.4 ORM中间件　　4.2 Hibernate简介　　　4.2.1 Hibernate体系结构　　　4.2.2 Hibernate API简介　　　4.2.3 配置Hibernate　　　4.2.4 Hibernate的映射配置文件　　　4.2.5 体验Hibernate（会员管理）　　4.3 Hibernate的映射机制　　　4.3.1 Hibernate的基本映射数据类型　　　4.3.2 Hibernate的主键映射　　　4.3.3 Hibernate的实体映射　　　4.3.4 映射一对一关联关系　　　4.3.5 映射多对一单向关联关系　　　4.3.6 映射一对多双向关联关系　　　4.3.7 映射一对多双向自身关联关系　　　4.3.8 映射多对多单向关联关系　　　4.3.9 映射多对多双向关联关系　　　4.3.10 映射组成关系　　　4.3.11 映射继承关系　　　4.3.12 Hibernate的集合映射　　4.4 小结　第5章 Hibernate 3持久化技术实践与性能优化　　5.1 操作持久化对象的常用方法介绍　　　5.1.1 使用Session的beginTransaction()方法　　　5.1.2 使用Session的close()方法　　　5.1.3 使用Session的connection()方法　　　5.1.4 使用Session的delete()方法　　　5.1.5 使用Session的get()方法　　　5.1.6 使用Session的load()方法　　　5.1.7 使用Session的save()方法　　　5.1.8 使用Session的update()方法　　　5.1.9 使用Session的saveOrUpdate()方法　　　5.1.10 使用Hibernate的isInitialized()与initialize()方法　　　5.1.11 持久化对象间的级联操作　　5.2 Hibernate的检索策略　　　5.2.1 立即检索　　　5.2.2 延迟检索　　　5.2.3 迫切左外连接检索　　5.3 HQL查询方式　　　5.3.1 基本查询　　　5.3.2 条件查询　　　5.3.3 分页查询　　　5.3.4 连接查询　　　5.3.5 子查询　　　5.3.6 动态实例化查询结果　　5.4 QBC查询方式　　　5.4.1 基本查询　　　5.4.2 QBE查询　　　5.4.3 分页查询　　　5.4.4 复合查询　　　5.4.5 离线查询　　5.5 本地SQL查询　　5.6 Hibernate的批量处理　　　5.6.1 批量插入　　　5.6.2 批量更新　　　5.6.3 批量删除　　5.7 Hibernate的事务管理　　　5.7.1 事务边界声明　　　5.7.2 并发控制　　　5.7.3 悲观锁　　　5.7.4 乐观锁　　5.8 Hibernate的缓存机制　　　5.8.1 Hibernate的缓存分类　　　5.8.2 Hibernate的缓存范围　　　5.8.3 Hibernate的缓存管理　　　5.8.4 Hibernate二级缓存的并发访问策略　　　5.8.5 Hibernate的二级缓存配置　　5.9 Hibernate应用的性能优化　　5.10 多数据源的应用　　5.11 JDBC的应用　　5.12 Hibernate调用存储过程　　5.13 XML数据持久化　　5.14 小结　第6章 充分利用Spring 2.5的IoC利器统管Bean世界　　6.1 Java程序员的春天厚礼—Spring 2.5　　　6.1.1 爱上Spring 2.5的十大理由　　　6.1.2 一睹Spring 2.5芳容　　　6.1.3 Spring 2.5拿手戏——控制反转与依赖注入　　　6.1.4 何为“面向切面编程AOP”　　　6.1.5 Spring 2.5圣经——面向接口编程　　　6.1.6 开始Spring 2.5旅程—Hello World　　6.2 Spring 2.5核心技术　　　6.2.1 Bean工厂之BeanFactory介绍　　　6.2.2 实用的Bean工厂ApplicationContext　　　6.2.3 Spring 2.5配置文件详解　　　6.2.4 Bean的作用域与生命周期　　　6.2.5 基于XML方式的Bean装配　　　6.2.6 基于Annotation方式的Bean装配　　　6.2.7 基于XML方式的AOP实现　　　6.2.8 基于Annotation方式的AOP实现　　6.3 Spring 2.5事务管理机制　　　6.3.1 Spring 2.5的声明式事务管理　　　6.3.2 基于XML方式的事务管理配置　　　6.3.3 基于Annotation方式的事务管理配置　　6.4 “桃园三结义”——SSH 2组合开发框架始成　　　6.4.1 Spring 2.5集成ORM中间件Hibernate 3.2　　　6.4.2 Spring 2.5集成MVC框架Struts 2　　　6.4.3 SSH 2组合框架的基本开发步骤—ePortal启程　　6.5 小结第2篇 实践篇　第7章 SSH 2热身——构建新闻发布系统　　7.1 门户网站新闻资讯基本分类　　7.2 新闻发布系统需求分析　　7.3 新闻发布系统功能设计　　7.4 新闻栏目后台管理　　　7.4.1 展示层JSP 2+Struts 2 标签库实现　　　7.4.2 控制层Struts2实现　　　7.4.3 持久层Hibernate3实现　　　7.4.4 Spring2接管业务逻辑层　　7.5 新闻内容后台管理　　　7.5.1 展示层JSP2+Struts2标签库实现　　　7.5.2 控制层Struts 2实现　　　7.5.3 持久层Hibernate3实现　　　7.5.4 Spring2接管业务逻辑层　　7.6 新闻资讯前台展现　　　7.6.1 文本新闻列表自定义标签类TextnewsTag　　　7.6.2 文本新闻列表分页控制自定义标签类TextnewsPageTag　　　7.6.3 图片新闻列表自定义标签类PicnewsTag　　　7.6.4 幻灯片新闻列表自定义标签类SlidenewsTag　　　7.6.5 Struts2与AJAX完全结合实现点击数加一　　7.7 基于HttpClient构建通用静态页面发布引擎　　　7.7.1 优秀的模拟浏览器HttpClient　　　7.7.2 构建通用静态页面发布引擎　　7.8 小结　第8章 通用新闻采集系统　　8.1 新闻采集系统需求分析　　8.2 新闻采集系统功能设计　　8.3 使用正则表达式与HTMLParser采集新闻内容　　　8.3.1 正则表达式基本知识　　　8.3.2 体验HTMLParser　　8.4 量身定制采集规则　　　8.4.1 展示层JSP 2+Struts 2标签库实现　　　8.4.2 控制层Struts 2实现　　　8.4.3 持久层Hibernate3实现　　　8.4.4 Spring 2接管业务逻辑层　　8.5 新闻采集功能实现　　8.6 小结　第9章 会员注册及会员管理系统　　9.1 会员管理系统需求分析　　9.2 会员管理系统功能设计　　9.3 会员级别后台管理　　　9.3.1 展示层JSP 2+Struts 2标签库实现　　　9.3.3 持久层Hibernate 3实现　　　9.3.4 Spring 2接管业务逻辑层　　9.4 注册会员后台管理　　　9.4.1 展示层JSP 2+Struts 2标签库实现　　　9.4.2 控制层Struts2实现　　　9.4.3 持久层Hibernate3实现　　　9.4.4 Spring 2接管业务逻辑层　　9.5 前台会员注册与登录　　9.6 小结　第10章 举一反三—实现商品分类管理　　10.1 商品管理系统需求分析　　10.2 商品管理系统功能设计　　10.3 商品类别后台管理　　　10.3.1 展示层JSP 2+Struts 2标签库实现　　　10.3.2 控制层Struts 2实现　　　10.3.3 持久层Hibernate3实现　　　10.3.4 Spring2接管业务逻辑层　　10.4 商品后台管理　　　10.4.1 展示层JSP 2+Struts 2标签库实现　　　10.4.2 控制层Struts 2实现　　　10.4.3 持久层Hibernate3实现　　　10.4.4 Spring 2接管业务逻辑层　　10.5 小结　第11章 温故知新—打造购物车与订单管理系统　　11.1 购物车与订单管理系统需求分析　　11.2 购物车及订单管理系统功能设计　　11.3 购物车自助管理　　　11.3.1 展示层JSP2+Struts2标签库实现　　　11.3.2 控制层Struts 2实现　　　11.3.3 持久层Hibernate3实现　　　11.3.4 Spring2接管业务逻辑层　　11.4 订单管理　　　11.4.1 展示层JSP 2+Struts 2标签库实现　　　11.4.2 控制层Struts 2实现　　　11.4.3 持久层Hibernate 3实现　　　11.4.4 Spring 2接管业务逻辑层　　11.5 小结　第12章 站务必备—系统用户管理与流量统计　　12.1 系统用户管理与流量统计需求分析　　12.2 系统用户管理与流量统计功能设计　　12.3 系统用户管理　　　12.3.1 展示层JSP 2+Struts 2标签库实现　　　12.3.2 控制层Struts 2实现　　　12.3.3 持久层Hibernate3实现　　　12.3.4 Spring2接管业务逻辑层　　12.4 流量统计分析　　　12.4.1 展示层JSP 2+Struts 2标签库实现　　　12.4.2 控制层Struts 2实现　　　12.4.3 持久层Hibernate3实现　　　12.4.4 Spring2接管业务逻辑层　　12.5 小结第3篇 部署篇　第13章 门户网站的搜索引擎优化—SEO技术　　13.1 为什么要进行搜索引擎优化　　　13.1.1 搜索引擎概述　　　13.1.2 网络营销催生SEO　　　13.1.3 SEO让你的网站脱颖而出　　13.2 搜索引擎到底喜欢什么样的网站　　　13.2.1 影响网站自然排名的主要因素　　　13.2.2 评价网站优劣的重要指标　　　13.2.3 正确看待SEO　　　13.2.4 远离Google的“沙盒”　　13.3 搜索引擎优化最佳实践　　　13.3.1 如何快速被搜索引擎收录　　　13.3.2 建立合理的网站结构与网站地图的应用　　　13.3.3 设计良好的网页结构　　　13.3.4 SEO基本功——关键词的选用　　　13.3.5 域名与空间对SEO的影响　　　13.3.6 搜索引擎偏爱“勤快”的网站　　13.4 搜索引擎优化辅助工具大本营　　　13.4.1 关键字选词辅助工具　　　13.4.2 关键字排名查询　　　13.4.3 关键字密度查询　　　13.4.4 热门关键字及搜索量查询　　　13.4.5 PR值查询　　　13.4.6 Alexa世界排名查询　　　13.4.7 搜索引擎收录页面数查询　　　13.4.8 搜索引擎反向链接查询　　　13.4.9 网站地图制作工具　　　13.4.10 百度指数查询　　　13.4.11 网页中无效链接检测工具　　13.5 小结　第14章 基于RHEL 5的服务器架构　　14.1 Red Hat Enterprise Linux 5安装与优化　　14.2 Linux客户端工具Secure SSH安装与应用　　14.3 RHEL5服务器维护的基本操作　　　14.3.1 系统维护相关的Linux命令　　　14.3.2 文件操作相关的Linux命令　　　14.3.3 网络维护相关的Linux命令　　　14.3.4 日志查看相关的Linux命令　　　14.3.5 用户管理相关的Linux命令　　　14.3.6 应用软件安装相关的Linux命令　　14.4 RHEL5中的JDK1.6安装　　14.5 RHEL5中的MySQL5安装与性能优化　　14.6 基于vsftpd搭建FTP服务器　　14.7 RHEL5中的Tomcat6安装与性能优化　　14.8 RHEL5中的Apache2.2安装与性能优化　　14.9 Apache2.2配置文件httpd.conf详解　　14.10 使用subversion搭建SVN版本控制服务器　　14.11 利用Red5搭建Flash流媒体服务器　　14.12 利用vncserver服务实现远程桌面　　14.13 小结　第15章 负载均衡与服务器集群　　15.1 Web服务器集群概述　　15.2 搭建Apache2.2+Tomcat6分工协作服务器架构　　15.3 构建Apache2.2负载均衡与Tomcat6集群　　15.4 搭建主从结构的MySQL数据库集群　　15.5 基于MySQL Proxy的负载均衡与读写分离　　15.6 小结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>大型门户网站是这样炼成的！
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻量级Java EE企业应用实战
第1章  Java EE应用和开发环境	1
1.1  Java EE应用概述	2
1.1.1  Java EE应用的分层模型	2
1.1.2  Java EE应用的组件	3
1.1.3  Java EE应用的结构和优势	4
1.1.4  常用的Java EE服务器	4
1.2  轻量级Java EE应用相关技术	5
1.2.1  JSP、Servlet 3.0和JavaBean及替代技术	5
1.2.2  Struts 2.2及替代技术	5
1.2.3  Hibernate 3.6及替代技术	6
1.2.4  Spring 3.0及替代技术	6
1.3  Tomcat的下载和安装	7
1.3.1  安装Tomcat服务器	8
1.3.2  配置Tomcat的服务端口	9
1.3.3  进入控制台	10
1.3.4  部署Web应用	12
1.3.5  配置Tomcat的数据源	13
1.4  Eclipse的安装和使用	15
1.4.1  Eclipse的下载和安装	15
1.4.2  在线安装Eclipse插件	15
1.4.3  从本地压缩包安装插件	17
1.4.4  手动安装Eclipse插件	17
1.4.5  使用Eclipse开发Java EE应用	18
1.4.6  导入Eclipse项目	21
1.4.7  导入非Eclipse项目	22
1.5  Ant的安装和使用	23
1.5.1  Ant的下载和安装	23
1.5.2  使用Ant工具	24
1.5.3  定义生成文件	25
1.5.4  Ant的任务（task）	29
1.6  使用CVS进行协作开发	31
1.6.1  安装CVS服务器	32
1.6.2  配置CVS资源库	34
1.6.3  安装CVS客户端	35
1.6.4  发布项目到服务器	35
1.6.5  从服务器下载项目	37
1.6.6  同步（Update）本地文件	38
1.6.7  提交（Commit）修改	39
1.6.8  添加文件和目录	39
1.6.9  删除文件和目录	40
1.6.10  查看文件的版本变革	41
1.6.11  提取文件以前版本的内容	42
1.6.12  从以前版本重新开始	42
1.6.13  创建标签	43
1.6.14  创建分支	43
1.6.15  沿着分支开发	44
1.6.16  使用Eclipse作为CVS客户端	44
1.7  本章小结	46
第2章  JSP/Servlet及相关技术详解	47
2.1  Web应用和web.xml文件	48
2.1.1  构建Web应用	48
2.1.2  配置描述符web.xml	49
2.2  JSP的基本原理	50
2.3  JSP注释	54
2.4  JSP声明	54
2.5  输出JSP表达式	56
2.6  JSP脚本	56
2.7  JSP的3个编译指令	59
2.7.1  page指令	59
2.7.2  include指令	63
2.8  JSP的7个动作指令	63
2.8.1  forward指令	64
2.8.2  include指令	66
2.8.3  useBean、setProperty、getProperty指令	67
2.8.4  plugin指令	70
2.8.5  param指令	70
2.9  JSP脚本中的9个内置对象	70
2.9.1  application对象	72
2.9.2  config对象	77
2.9.3  exception对象	79
2.9.4  out对象	81
2.9.5  pageContext对象	82
2.9.6  request对象	84
2.9.7  response对象	91
2.9.8  session对象	95
2.10  Servlet介绍	97
2.10.1  Servlet的开发	97
2.10.2  Servlet的配置	99
2.10.3  JSP/Servlet的生命周期	101
2.10.4  load-on-startup Servlet	101
2.10.5  访问Servlet的配置参数	102
2.10.6  使用Servlet作为控制器	104
2.11  JSP 2的自定义标签	108
2.11.1  开发自定义标签类	109
2.11.2  建立TLD文件	109
2.11.3  使用标签库	110
2.11.4  带属性的标签	111
2.11.5  带标签体的标签	115
2.11.6  以页面片段作为属性的标签	117
2.11.7  动态属性的标签	118
2.12  Filter介绍	120
2.12.1  创建Filter类	120
2.12.2  配置Filter	121
2.12.3  使用URL Rewrite实现网站伪静态	125
2.13  Listener介绍	126
2.13.1  实现Listener类	127
2.13.2  配置Listener	128
2.13.3  使用ServletContextAttribute-Listener	129
2.13.4  使用ServletRequestListener和ServletRequestAttributeListener	130
2.13.5  使用HttpSessionListener和HttpSessionAttributeListener	131
2.14  JSP 2特性	136
2.14.1  配置JSP属性	136
2.14.2  表达式语言	138
2.14.3  Tag File支持	146
2.15  Servlet 3.0新特性	148
2.15.1  Servlet 3.0的Annotation	148
2.15.2  Servlet 3.0的Web模块支持	149
2.15.3  Servlet 3.0提供的异步处理	151
2.15.4  改进的Servlet API	154
2.16  本章小结	156
第3章  Struts 2的基本用法	157
3.1  MVC思想概述	158
3.1.1  传统Model 1和Model 2	158
3.1.2  MVC思想及其优势	159
3.2  Struts 2的下载和安装	160
3.2.1  为Web应用增加Struts 2支持	160
3.2.2  在Eclipse中使用Struts 2	161
3.2.3  增加登录处理	162
3.3  Struts 2的流程	165
3.3.1  Struts 2应用的开发步骤	165
3.3.2  Struts 2的流程	166
3.4  Struts 2的常规配置	167
3.4.1  常量配置	167
3.4.2  包含其他配置文件	173
3.5  实现Action	174
3.5.1  Action接口和ActionSupport基类	175
3.5.2  Action访问Servlet API	177
3.5.3  Action直接访问Servlet API	179
3.5.4  使用ServletActionContext访问Servlet API	181
3.6  配置Action	182
3.6.1  包和命名空间	182
3.6.2  Action的基本配置	185
3.6.3  使用Action的动态方法调用	186
3.6.4  指定method属性及使用通配符	188
3.6.5  配置默认Action	194
3.6.6  配置Action的默认处理类	194
3.7  配置处理结果	195
3.7.1  理解处理结果	195
3.7.2  配置结果	195
3.7.3  Struts 2支持的结果类型	197
3.7.4  plainText结果类型	198
3.7.5  redirect结果类型	200
3.7.6  redirectAction结果类型	201
3.7.7  动态结果	202
3.7.8  Action属性值决定物理视图资源	202
3.7.9  全局结果	204
3.7.10  使用PreResultListener	205
3.8  配置Struts 2的异常处理	206
3.8.1  Struts 2的异常处理机制	207
3.8.2  声明式异常捕捉	208
3.8.3  输出异常信息	210
3.9  Convention插件与“约定”支持	211
3.9.1  Action的搜索和映射约定	211
3.9.2  按约定映射Result	214
3.9.3  Action链的约定	216
3.9.4  自动重加载映射	218
3.9.5  Convention插件的相关常量	218
3.9.6  Convention插件相关Annotation	219
3.10  使用Struts 2的国际化	219
3.10.1  Struts 2中加载全局资源文件	219
3.10.2  访问国际化消息	220
3.10.3  输出带占位符的国际化消息	222
3.10.4  加载资源文件的方式	224
3.10.5  加载资源文件的顺序	228
3.11  使用Struts 2的标签库	228
3.11.1  Struts 2标签库概述	228
3.11.2  使用Struts 2标签	229
3.11.3  Struts 2的OGNL表达式语言	230
3.11.4  OGNL中的集合操作	232
3.11.5  访问静态成员	233
3.11.6  Lambda（）表达式	234
3.11.7  控制标签	234
3.11.8  数据标签	244
3.11.9  主题和模板	254
3.11.10  自定义主题	256
3.11.11  表单标签	257
3.11.12  非表单标签	270
3.12  本章小结	273
第4章  深入使用Struts 2	274
4.1  详解Struts 2的类型转换	275
4.1.1  Struts 2内建的类型转换器	276
4.1.2  基于OGNL的类型转换	276
4.2.3  指定集合元素的类型	279
4.1.4  自定义类型转换器	280
4.1.5  注册类型转换器	283
4.1.6  基于Struts 2的自定义类型转换器	284
4.1.7  处理Set集合	285
4.1.8  类型转换中的错误处理	288
4.2  使用Struts 2的输入校验	293
4.2.1  编写校验规则文件	294
4.2.2  国际化提示信息	296
4.2.3  使用客户端校验	298
4.2.4  字段校验器配置风格	300
4.2.5  非字段校验器配置风格	301
4.2.6  短路校验器	302
4.2.7  校验文件的搜索规则	304
4.2.8  校验顺序和短路	305
4.2.9  内建校验器	306
4.2.10  基于Annotation的输入校验	316
4.2.11  手动完成输入校验	318
4.3  使用Struts 2控制文件上传	322
4.3.1  Struts 2的文件上传	322
4.3.2  实现文件上传的Action	322
4.3.3  配置文件上传的Action	325
4.3.4  手动实现文件过滤	326
4.3.5  拦截器实现文件过滤	328
4.3.6  输出错误提示	329
4.3.7  文件上传的常量配置	330
4.4  使用Struts 2控制文件下载	330
4.4.1  实现文件下载的Action	330
4.4.2  配置Action	332
4.4.3  下载前的授权控制	332
4.5  详解Struts 2的拦截器机制	334
4.5.1  拦截器在Struts 2中的作用	334
4.5.2  Struts 2内建的拦截器	334
4.5.3  配置拦截器	336
4.5.4  使用拦截器	338
4.5.5  配置默认拦截器	338
4.5.6  实现拦截器类	340
4.5.7  使用拦截器	342
4.5.8  拦截方法的拦截器	343
4.5.9  拦截器的执行顺序	345
4.5.10  拦截结果的监听器	347
4.5.11  覆盖拦截器栈里特定拦截器的参数	348
4.5.12  使用拦截器完成权限控制	349
4.6  使用Struts 2的Ajax支持	351
4.6.1  使用stream类型的Result实现Ajax	352
4.6.2  JSON的基本知识	354
4.6.3  实现Action逻辑	356
4.6.4  JSON插件与json类型的Result	357
4.6.5  实现JSP页面	359
4.7  本章小结	361
第5章  Hibernate的基本用法	362
5.1  ORM和Hibernate	363
5.1.1  对象/关系数据库映射（ORM）	363
5.1.2  基本映射方式	364
5.1.3  流行的ORM框架简介	365
5.1.4  Hibernate概述	366
5.2  Hibernate入门	366
5.2.1  Hibernate下载和安装	366
5.2.2  Hibernate的数据库操作	367
5.2.3  在Eclipse中使用Hibernate	371
5.3  Hibernate的体系结构	376
5.4  深入Hibernate的配置文件	377
5.4.1  创建Configuration对象	377
5.4.2  hibernate.properties文件与hibernate.cfg.xml文件	380
5.4.3  JDBC连接属性	380
5.4.4  数据库方言	381
5.4.5  JNDI数据源的连接属性	382
5.4.6  Hibernate事务属性	382
5.4.7  二级缓存相关属性	383
5.4.8  外连接抓取属性	383
5.4.9  其他常用的配置属性	383
5.5  深入理解持久化对象	384
5.5.1  持久化类的要求	384
5.5.2  持久化对象的状态	385
5.5.3  改变持久化对象状态的方法	386
5.6  深入Hibernate的映射文件	389
5.6.1  映射文件结构	389
5.6.2  映射主键	392
5.6.3  映射普通属性	393
5.6.4  映射集合属性	398
5.6.5  集合属性的性能分析	407
5.6.6  有序集合映射	409
5.6.7  映射数据库对象	411
5.7  映射组件属性	414
5.7.1  组件属性为集合	416
5.7.2  集合属性的元素为组件	418
5.7.3  组件作为Map的索引	420
5.7.4  组件作为复合主键	422
5.7.5  多列作为联合主键	425
5.8  使用JPA Annotation标注实体	426
5.8.1  增加JPA Annotation支持	426
5.8.2  Annotation？还是XML映射文件	429
5.9  本章小结	429
第6章  深入使用Hibernate	430
6.1  Hibernate的关联映射	431
6.1.1  单向N－1关联	431
6.1.2  单向1－1关联	436
6.1.3  单向1－N关联	439
6.1.4  单向N－N关联	443
6.1.5  双向1－N关联	443
6.1.6  双向N－N关联	448
6.1.7  双向1－1关联	450
6.1.8  组件属性包含的关联实体	453
6.1.9  基于复合主键的关联关系	456
6.1.10  复合主键的成员属性为关联实体	458
6.1.11  持久化的传播性	461
6.2  继承映射	462
6.2.1  采用subclass元素的继承映射	466
6.2.2  采用joined-subclass元素的继承映射	467
6.2.3  采用union-subclass元素的继承映射	470
6.3  Hibernate的批量处理	472
6.3.1  批量插入	473
6.3.2  批量更新	474
6.3.3  DML风格的批量更新/删除	474
6.4  使用HQL查询	476
6.4.1  HQL查询	476
6.4.2  HQL查询的from子句	478
6.4.3  关联和连接	478
6.4.4  HQL查询的select子句	481
6.4.5  HQL查询的聚集函数	482
6.4.6  多态查询	483
6.4.7  HQL查询的where子句	483
6.4.8  表达式	484
6.4.9  order by子句	486
6.4.10  group by子句	486
6.4.11  子查询	487
6.4.12  命名查询	488
6.5  条件查询	488
6.5.1  关联和动态关联	491
6.5.2  投影、聚合和分组	492
6.5.3  离线查询和子查询	495
6.6  SQL查询	496
6.6.1  标量查询	496
6.6.2  实体查询	498
6.6.3  处理关联和继承	500
6.6.4  命名SQL查询	501
6.6.5  调用存储过程	502
6.6.6  使用定制SQL	503
6.7  数据过滤	505
6.8  事务控制	508
6.8.1  事务的概念	508
6.8.2  Session与事务	509
6.8.3  上下文相关的Session	511
6.9  二级缓存和查询缓存	511
6.9.1  开启二级缓存	512
6.9.2  管理缓存和统计缓存	515
6.9.3  使用查询缓存	516
6.10  事件机制	518
6.10.1  拦截器	519
6.10.2  事件系统	521
6.11  本章小结	525
第7章  Spring的基本用法	526
7.1  Spring简介和Spring 3.0的变化	527
7.1.1  Spring简介	527
7.1.2  Spring 3.0的变化	528
7.2  Spring的下载和安装	528
7.2.1  在Java SE应用中使用Spring	528
7.2.2  在Web应用中使用Spring	529
7.2.3  在Eclipse中开发Spring应用	530
7.3  Spring的核心机制：依赖注入	533
7.3.1  理解依赖注入	533
7.3.2  设值注入	534
7.3.3  构造注入	538
7.3.4  两种注入方式的对比	539
7.4  使用Spring容器	539
7.4.1  Spring容器	540
7.4.2  使用ApplicationContext	541
7.4.3  ApplicationContext的国际化支持	542
7.4.4  ApplicationContext的事件机制	544
7.4.5  让Bean获取Spring容器	546
7.5  Spring容器中的Bean	548
7.5.1  Bean的基本定义	548
7.5.2  容器中Bean的作用域	551
7.5.3  配置依赖	553
7.5.4  设置普通属性值	555
7.5.5  配置合作者Bean	557
7.5.6  使用自动装配注入合作者Bean	557
7.5.7  注入嵌套Bean	560
7.5.8  注入集合值	561
7.5.9  组合属性名称	565
7.5.10  Spring的Bean和JavaBean	566
7.6  Spring 3.0提供的Java配置管理	567
7.7  Bean实例的创建方式及依赖配置	570
7.7.1  使用构造器创建Bean实例	570
7.7.2  使用静态工厂方法创建Bean	572
7.7.3  调用实例工厂方法创建Bean	575
7.8  深入理解容器中的Bean	577
7.8.1  使用抽象Bean	577
7.8.2  使用子Bean	578
7.8.3  Bean继承与Java继承的区别	579
7.8.4  容器中的工厂Bean	580
7.8.5  获得Bean本身的id	582
7.8.6  强制初始化Bean	583
7.9  容器中Bean的生命周期	583
7.9.1  依赖关系注入之后的行为	584
7.9.2  Bean销毁之前的行为	585
7.9.3  协调作用域不同步的Bean	588
7.10  深入理解依赖关系配置	591
7.10.1  注入其他Bean的属性值	592
7.10.2  注入其他Bean的Field值	594
7.10.3  注入其他Bean的方法返回值	595
7.11  基于XML Schema的简化配置方式	598
7.11.1  使用p名称空间配置属性	599
7.11.2  使用util Schema	600
7.12  Spring 3.0提供的表达式语言（SpEL）	602
7.12.1  使用Expression接口进行表达式求值	603
7.12.2  Bean定义中的表达式语言支持	604
7.12.3  SpEL语法详述	606
7.13  本章小结	611
第8章  深入使用Spring	612
8.1  两种后处理器	613
8.1.1  Bean后处理器	613
8.1.2  Bean后处理器的用处	617
8.1.3  容器后处理器	617
8.1.4  属性占位符配置器	619
8.1.5  重写占位符配置器	620
8.2  Spring的“零配置”支持	621
8.2.1  搜索Bean类	621
8.2.2  指定Bean的作用域	624
8.2.3  使用@Resource配置依赖	625
8.2.4  使用@PostConstruct和@PreDestroy定制生命周期行为	626
8.2.5  Spring 3.0新增的Annotation	626
8.2.6  自动装配和精确装配	627
8.3  资源访问	629
8.3.1  Resource实现类	630
8.3.2  ResourceLoader接口和ResourceLoaderAware接口	635
8.3.3  使用Resource作为属性	638
8.3.4  在ApplicationContext中使用资源	639
8.4  Spring的AOP	643
8.4.1  为什么需要AOP	643
8.4.2  使用AspectJ实现AOP	644
8.4.3  AOP的基本概念	649
8.4.4  Spring的AOP支持	650
8.4.5  基于Annotation的“零配置”方式	651
8.4.6  基于XML配置文件的管理方式	666
8.5  Spring的事务	672
8.5.1  Spring支持的事务策略	673
8.5.2  使用TransactionProxyFactoryBean创建事务代理	678
8.5.3  Spring 2.X的事务配置策略	681
8.5.4  使用@Transactional	685
8.6  Spring整合Struts 2	686
8.6.1  启动Spring容器	686
8.6.2  MVC框架与Spring整合的思考	688
8.6.3  让Spring管理控制器	689
8.6.4  使用自动装配	692
8.7  Spring整合Hibernate	695
8.7.1  Spring提供的DAO支持	695
8.7.2  管理Hibernate的SessionFactory	696
8.7.3  使用HibernateTemplate	697
8.7.4  使用HibernateCallback	701
8.7.5  实现DAO组件	703
8.7.6  使用IoC容器组装各种组件	705
8.7.7  使用声明式事务	707
8.8  Spring整合JPA	708
8.8.1  管理EntityManager	709
8.8.2  使用JpaTemplate	711
8.8.3  使用JpaCallback	713
8.8.4  借助JpaDaoSupport实现DAO组件	714
8.8.5  使用声明式事务	714
8.9  本章小结	715
第9章  企业应用开发的思考和策略	716
9.1  企业应用开发面临的挑战	717
9.1.1  可扩展性、可伸缩性	717
9.1.2  快捷、可控的开发	718
9.1.3  稳定性、高效性	719
9.1.4  花费最小化，利益最大化	719
9.2  如何面对挑战	719
9.2.1  使用建模工具	719
9.2.2  利用优秀的框架	720
9.2.3  选择性地扩展	722
9.2.4  使用代码生成器	722
9.3  常见设计模式精讲	722
9.3.1  单例模式	723
9.3.2  简单工厂	724
9.3.3  工厂方法和抽象工厂	730
9.3.4  代理模式	733
9.3.5  命令模式	739
9.3.6  策略模式	741
9.3.7  门面模式	743
9.3.8  桥接模式	746
9.3.9  观察者模式	750
9.4  常见的架构设计策略	753
9.4.1  贫血模型	753
9.4.2  领域对象模型	756
9.4.3  合并业务逻辑对象与DAO对象	758
9.4.4  合并业务逻辑对象和Domain Object	759
9.4.5  抛弃业务逻辑层	761
9.5  本章小结	762
第10章  简单工作流系统	763
10.1  项目背景及系统结构	764
10.1.1  应用背景	764
10.1.2  系统功能介绍	764
10.1.3  相关技术介绍	765
10.1.4  系统结构	766
10.1.5  系统的功能模块	766
10.2  Hibernate持久层	767
10.2.1  设计持久化实体	767
10.2.2  创建持久化实体类	768
10.2.3  映射持久化实体	772
10.3  实现DAO层	777
10.3.1  DAO组件的定义	778
10.3.2  实现DAO组件	783
10.3.3  部署DAO层	787
10.4  实现Service层	789
10.4.1  业务逻辑组件的设计	789
10.4.2  实现业务逻辑组件	789
10.4.3  事务管理	795
10.4.4  部署业务逻辑组件	795
10.5  实现任务的自动调度	797
10.5.1  使用Quartz	797
10.5.2  在Spring中使用Quartz	802
10.6  实现系统Web层	804
10.6.1  Struts 2和Spring的整合	804
10.6.2  控制器的处理顺序	805
10.6.3  员工登录	806
10.6.4  进入打卡	808
10.6.5  处理打卡	810
10.6.6  进入申请	811
10.6.7  提交申请	812
10.6.8  使用拦截器完成权限管理	814
10.7  本章小结	816
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻量级Java EE企业应用实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring实战（第3版）
第一部分 Spring的核心
第1章 Spring之旅 2
1.1 简化Java开发 3
1.1.1 激发POJO的潜能 4
1.1.2 依赖注入 5
1.1.3 应用切面 9
1.1.4 使用模板消除样板式代码 13
1.2 容纳你的Bean 15
1.2.1 与应用上下文共事 16
1.2.2 Bean的生命周期 17
1.3 俯瞰Spring风景线 19
1.3.1 Spring模块 19
1.3.2 Spring Portfolio 22
1.4 Spring新功能 25
1.4.1 Spring 2.5新特性 26
1.4.2 Spring 3.0新特性 26
1.4.3 Spring Portfollo新特性 27
1.5 小结 28
第2章 装配Bean 29
2.1 声明Bean 30
2.1.1 创建Spring配置 30
2.1.2 声明一个简单Bean 31
2.1.3 通过构造器注入 33
2.1.4 Bean的作用域 37
2.1.5 初始化和销毁Bean 38
2.2 注入Bean属性 40
2.2.1 注入简单值 41
2.2.2 引用其他Bean 42
2.2.3 使用Spring的命名空间p装配属性 45
2.2.4 装配集合 46
2.2.5 装配空值 50
2.3 使用表达式装配 51
2.3.1 SpEL的基本原理 51
2.3.2 在SpEL值上执行操作 54
2.3.3 在SpEL中筛选集合 58
2.4 小结 62
第3章 最小化Spring XML配置 63
3.1 自动装配Bean属性 64
3.1.1 4种类型的自动装配 64
3.1.2 默认自动装配 68
3.1.3 混合使用自动装配和显式装配 68
3.2 使用注解装配 69
3.2.1 使用@Autowired 70
3.2.2 借助@Inject实现基于标准的自动装配 74
3.2.3 在注解注入中使用表达式 76
3.3 自动检测Bean 77
3.3.1 为自动检测标注Bean 78
3.3.2 过滤组件扫描 79
3.4 使用Spring基于Java的配置 80
3.4.1 创建基于Java的配置 80
3.4.2 定义一个配置类 81
3.4.3 声明一个简单的Bean 81
3.4.4 使用Spring的基于Java的配置进行注入 82
3.5 小结 83
第4章 面向切面的Spring 84
4.1 什么是面向切面编程 85
4.1.1 定义AOP术语 86
4.1.2 Spring对AOP的支持 88
4.2 使用切点选择连接点 90
4.2.1 编写切点 91
4.2.2 使用Spring的bean()指示器 92
4.3 在XML中声明切面 93
4.3.1 声明前置和后置通知 94
4.3.2 声明环绕通知 96
4.3.3 为通知传递参数 98
4.3.4 通过切面引入新功能 100
4.4 注解切面 102
4.4.1 注解环绕通知 104
4.4.2 传递参数给所标注的通知 105
4.4.3 标注引入 105
4.5 注入AspectJ切面 107
4.6 小结 109
第二部分 Spring应用程序的核心组件
第5章 征服数据库 112
5.1 Spring的数据访问哲学 113
5.1.1 了解Spring的数据访问异常体系 114
5.1.2 数据访问模板化 116
5.1.3 使用DAO支持类 118
5.2 配置数据源 119
5.2.1 使用JNDI数据源 119
5.2.2 使用数据源连接池 120
5.2.3 基于JDBC驱动的数据源 121
5.3 在Spring中使用JDBC 122
5.3.1 应对失控的JDBC代码 122
5.3.2 使用JDBC模板 125
5.4 在Spring中集成Hibernate 130
5.4.1 Hibernate概览 131
5.4.2 声明Hibernate的Session工厂 132
5.4.3 构建不依赖于Spring的Hibernate代码 134
5.5 Spring与Java持久化API 136
5.5.1 配置实体管理器工厂 136
5.5.2 编写基于JPA的DAO 140
5.6 小结 142
第6章 事务管理 144
6.1 理解事务 145
6.1.1 用4个词来表示事务 146
6.1.2 理解Spring对事务管理的支持 147
6.2 选择事务管理器 147
6.2.1 JDBC事务 149
6.2.2 Hibernate事务 149
6.2.3 Java持久化API事务 150
6.2.4 JTA(Java Transaction API)事务 151
6.3 在Spring中的编码事务 151
6.4 声明式事务 153
6.4.1 定义事务属性 154
6.4.2 在XML中定义事务 157
6.4.3 定义注解驱动的事务 159
6.5 小结 160
第7章 使用Spring MVC构建Web应用程序 162
7.1 Spring MVC起步 163
7.1.1 跟踪Spring MVC的请求 163
7.1.2 搭建Spring MVC 165
7.2 编写基本的控制器 166
7.2.1 配置注解驱动的Spring MVC 167
7.2.2 定义首页的控制器 168
7.2.3 解析视图 171
7.2.4 定义首页的视图 175
7.2.5 完成Spring应用上下文 177
7.3 处理控制器的输入 178
7.3.1 编写处理输入的控制器 179
7.3.2 渲染视图 181
7.4 处理表单 183
7.4.1 展现注册表单 183
7.4.2 处理表单输入 185
7.4.3 校验输入 187
7.5 处理文件上传 191
7.5.1 在表单上添加文件上传域 191
7.5.2 接收上传的文件 192
7.5.3 配置Spring支持文件上传 195
7.6 小结 196
第8章 使用Spring Web Flow 197
8.1 安装Spring Web Flow 198
8.1.1 在Spring中使用Web Flow 198
8.2 流程的组件 201
8.2.1 状态 201
8.2.2 转移 204
8.2.3 流程数据 205
8.3 组合起来：披萨流程 207
8.3.1 定义基本流程 207
8.3.2 收集顾客信息 211
8.3.3 构建订单 216
8.3.4 支付 219
8.4 保护Web流程 211
8.5 小结 221
第9章 保护Spring应用 223
9.1 Spring Security介绍 224
9.1.1 Spring Security起步 224
9.1.2 使用Spring Security配置命名空间 225
9.2 保护Web请求 226
9.2.1 代理Servlet过滤器 226
9.2.2 配置最小化的Web安全性 227
9.2.3 拦截请求 231
9.3 保护视图级别的元素 234
9.3.1 访问认证信息的细节 234
9.3.2 根据权限渲染 235
9.4 认证用户 237
9.4.1 配置内存用户存储库 238
9.4.2 基于数据库进行认证 239
9.4.3 基于LDAP进行认证 240
9.4.4 启用remember-me功能 244
9.5 保护方法调用 245
9.5.1 使用@Secured注解保护方法调用 245
9.5.2 使用JSR-250的@RolesAllowed注解 246
9.5.3 使用SpEL实现调用前后的安全性 246
9.5.4 声明方法级别的安全性切点 250
9.6 小结 251
第三部分 Spring集成
第10章 使用远程服务 254
10.1 Spring远程调用概览 255
10.2 使用RMI 257
10.2.1 发布一个RMI服务 257
10.2.2 装配RMI服务 260
10.3 使用Hessian和Burlap发布远程服务 262
10.3.1 使用Hessian和Burlap发布Bean的功能 263
10.3.2 访问Hessian/Burlap服务 266
10.4 使用Spring的HttpInvoker 267
10.4.1 将把Bean发布为HTTP服务 267
10.4.2 通过HTTP访问服务 269
10.5 发布和使用Web服务 270
10.5.1 创建JAX-WS端点 271
10.5.2 在客户端代理JAX-WS服务 275
10.6 小结 276
第11章 为Spring添加REST功能 277
11.1 了解REST 278
11.1.1 REST的基本原理 278
11.1.2 Spring是如何支持REST的 279
11.2 编写面向资源的控制器 279
11.2.1 剖析RESTless的控制器 280
11.2.2 处理RESTful URL 281
11.2.3 执行REST动作 284
11.3 表述资源 287
11.3.1 协商资源表述 287
11.3.2 使用HTTP信息转换器 290
11.4 编写REST客户端 293
11.4.1 了解RestTemplate的操作 295
11.4.2 GET资源 296
11.4.3 PUT资源 298
11.4.4 DELETE资源 300
11.4.5 POST资源数据 301
11.4.6 交换资源 303
11.5 提交RESTful表单 305
11.5.1 在JSP中渲染隐藏的方法域 306
11.5.2 发布真正的请求 307
11.6 小结 308
第12章 Spring消息 310
12.1 JMS简介 311
12.1.1 构建JMS 312
12.1.2 评估JMS的优点 314
12.2 在Spring中搭建消息代理 316
12.2.1 创建连接工厂 316
12.2.2 声明ActiveMQ消息目的地 317
12.3 使用Spring的JMS模板 318
12.3.1 处理失控的JMS代码 318
12.3.2 使用JMS模板 319
12.4 创建消息驱动的POJO 324
12.4.1 创建消息监听器 325
12.4.2 配置消息监听器 326
12.5 使用基于消息的RPC 327
12.5.1 使用Spring基于消息的RPC 328
12.5.2 使用Lingo实现异步RPC 330
12.6 小结 332
第13章 使用JMX管理Spring Bean 333
13.1 将Spring Bean导出为MBean 334
13.1.1 通过名称发布方法 337
13.1.2 使用接口定义MBean的操作和属性 339
13.1.3 使用注解驱动的MBean 340
13.1.4 处理MBean冲突 342
13.2 远程MBean 343
13.2.1 发布远程MBean 343
13.2.2 访问远程MBean 344
13.2.3 代理MBean 346
13.3 处理通知 347
13.3.1 监听通知 348
13.4 小结 349
第14章 其他Spring技巧 350
14.1 外部化配置 351
14.1.1 替换属性占位符 351
14.1.2 重写属性 354
14.1.3 加密外部属性 355
14.2 装配JNDI对象 357
14.2.1 JNDI的传统用法 357
14.2.2 装配JNDI对象 359
14.2.3 将EJB装配到Spring中 362
14.3 发送邮件 363
14.3.1 配置邮件发送器 363
14.3.2 构建邮件 365
14.4 调度和后台任务 370
14.4.1 声明调度方法 371
14.4.2 声明异步方法 372
14.5 小结 373
14.6 结束语 374
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring实战（第3版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>龙枪编年史3
译者序•001
作者序克莱恩，你心中真实的世界•005
作者序是故事将我们联系在一起•006
主要人物介绍•007
第1卷
坦尼斯的道别•001
序曲：永恒之人•003
难逃黑暗魔掌•013
追逐•024
凝聚的黑暗•038
“弟弟……”•049
历史学者和法师•062
帕兰萨斯•075
索兰尼亚骑士指挥官•093
龙之誓约•106
胜利•118
第2卷
春晓•137
失败的处罚•151
黑玫瑰骑士•164
陷阱……•169
平静的间奏•186
“我杀死过他……”•196
阿波莉塔•209
贝伦意料之外的帮助•221
黑潮•228
一根蜡烛•240
第3卷
一位老人和一条金龙•251
金色拱桥•262
神之乡•275
永恒之人的故事•287
奈拉卡•297
坦尼斯的条件加汉的调查•311
黑暗之后的神殿•324
黑暗之后•339
末日号角声•351
“戴上此冠者将君临天下”•367
“洁思拉在呼唤我——”•376
还债•384
奇蒂拉•394
善良与邪恶的结局•406
回家•421
雷斯林的道别•424
后记•427
中英名词对照表•429
克莱恩历史简表•443
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>龙枪编年史3
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>手编大好！3：花片拼接的针织衫
本书中的个性时尚单品
南明奈穿着示范 甜美休闲针织物
今年春夏流行趋势舒适自然的针织衫

经久不衰！人气花片拼接
简单易学！！直线钩织的针织物
快乐的针织家族 时尚无龄差针织衫	温馨舒适家庭装针织衫
帽子·围巾·手提包 春夏外出小物件
用钩针钩织梦幻的手工作品 婚礼·饰品
“织花屋”简单编织法！花朵花样的小物件和衣物
Fukuyoka老师推荐的个性针织衫
编制培训班 花朵花片拼接的套头衫
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>手编大好！3：花片拼接的针织衫
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring学习指南(第3版)
第 1章 Spring框架简介 1
1.1　简介　1
1.2　Spring框架的模块　1
1.3　Spring IoC容器　2
1.4　使用Spring框架的好处　4
1.5　一个简单的Spring应用程序　9
1.6　建立在Spring之上的框架　16
1.7　小结　16
第　2章 Spring框架基础　17
2.1　简介　17
2.2　面向接口编程的设计方法　17
2.3　使用静态和实例工厂方法
创建Spring　bean　20
2.4　基于构造函数的 DI　24
2.5　将配置详细信息传递给bean　26
2.6　bean的作用域　27
2.7　小结　35
第3章　bean的配置　36
3.1　简介　36
3.2　bean定义的继承　36
3.3　构造函数参数匹配　42
3.4　配置不同类型的bean属性和
构造函数参数　49
3.5　内置属性编辑器　57
3.6　向Spring容器注册属性编辑器　60
3.7　具有p和c命名空间的简明
bean定义　61
3.8　Spring的util模式　64
3.9　FactoryBean 接口　68
3.10　模块化bean配置　73
3.11　小结　74
第4章　依赖注入　75
4.1　简介　75
4.2　内部bean　75
4.3　使用depends-on特性控制bean的
初始化顺序　76
4.4　singleton和prototype范围的bean的
依赖项　81
4.5　通过singleton bean中获取
prototype　bean的新实例　85
4.6　自动装配依赖项　92
4.7　小结　98
第5章　自定义bean和bean定义　99
5.1　简介　99
5.2　自定义bean的初始化和销毁逻辑　99
5.3　使用BeanPostProcessor与新创建的
bean实例进行交互　105
5.4　使用BeanFactoryPostProcessor修改bean定义　114
5.5　小结　125
第6章　使用Spring进行注释
驱动开发　126
6.1　简介　126
6.2　用@Component标识Spring bean　126
6.3　@Autowired 通过类型自动
装配依赖项　128
6.4　@Qualifier 按名称自动装配依赖项　131
6.5　JSR 330的@Inject和@Named注释　135
6.6　JSR 250的 @Resource 注释　137
6.7　@Scope、@Lazy、@DependsOn和
@Primary注释　138
6.8　使用@Value简化注释的
bean类的配置　142
6.9　使用Spring的 Validator
接口验证对象　148
6.10　使用JSR 349注释指定约束　151
6.11　bean定义配置文件　157
6.12　小结　161
第7章　基于Java的容器配置　162
7.1　简介　162
7.2　使用@Configuration和@Bean
注释配置bean　162
7.3　注入bean 依赖项　165
7.4　配置Spring容器　167
7.5　生命周期回调　169
7.6　导入基于Java的配置　170
7.7　附加主题　172
7.8　小结　181
第8章　使用Spring进行数
据库交互　182
8.1　简介　182
8.2　MyBank应用程序的需求　182
8.3　使用Spring JDBC模块开发
MyBank应用程序　183
8.4　使用Hibernate开发MyBank
应用程序　190
8.5　使用Spring的事务管理　192
8.6　使用基于Java的配置开发
MyBank应用程序　199
8.7　小结　201
第9章　Spring Data　202
9.1　简介　202
9.2　核心概念和接口　202
9.3　Spring Data JPA　205
9.4　使用Querydsl创建查询　214
9.5　按示例查询　217
9.6　Spring Data MongoDB　219
9.7　小结　225
第　10章 使用Spring进行消息传递、
电子邮件发送、异步方法执行和
缓存　226
10.1　简介　226
10.2　MyBank应用程序的需求　226
10.3　发送JMS 消息　227
10.4　接收JMS消息　234
10.5　发送电子邮件　239
10.6　任务调度和异步执行　243
10.7　缓存　248
10.8　运行MyBank应用程序　253
10.9　小结　255
第　11章 面向切面编程　256
11.1　简介　256
11.2　一个简单的AOP示例　256
11.3　Spring AOP 框架　258
11.4　切入点表达式　261
11.5　通知类型　266
11.6　Spring AOP - XML模式样式　270
11.7　小结　272
第　12章 Spring Web MVC
基础知识　273
12.1　简介　273
12.2　示例Web项目的目录结构　273
12.3　了解“Hello World”网络应用程序　274
12.4　DispatcherServlet——前端控制器　279
12.5　使用@Controller和@RequestMapping
注释开发控制器　281
12.6　MyBank Web 应用程序的需求　283
12.7　Spring Web MVC 注释
——@RequestMapping和
@RequestParam　284
12.8　验证　294
12.9　使用@ExceptionHandler
注释处理异常　296
12.10　加载根Web应用程序
上下文XML文件　297
12.11　小结　298
第　13章 Spring Web MVC中的
验证和数据绑定　299
13.1　简介　299
13.2　使用@ModelAttribute注释
添加和获取模型特性　299
13.3　使用@SessionAttributes注释
缓存模型特性　306
13.4　Spring中对数据绑定的支持　308
13.5　Spring中的验证支持　317
13.6　Spring的form标签库　323
13.7　使用基于Java的配置方式来
配置Web应用程序　325
13.8　小结　327
第　14章 使用Spring Web MVC
开发RESTful Web服务　328
14.1　简介　328
14.2　定期存款Web 服务　328
14.3　使用Spring Web MVC实现
RESTful Web服务　329
14.4　使用RestTemplate和
AsyncRestTemplate访问
RESTful Web服务　336
14.5　使用HttpMessageConverter将
Java对象与HTTP请求和响应
相互转换　342
14.6　@PathVariable和@MatrixVariable
注释　343
14.7　小结　346
第　15章 Spring Web MVC
进阶——国际化、文件上传
和异步请求处理　347
15.1　简介　347
15.2　使用处理程序拦截器对请求
进行预处理和后处理　347
15.3　使用资源束进行国际化　349
15.4　异步地处理请求　351
15.5　Spring中的类型转换和格式化支持　360
15.6　Spring Web MVC中的文件
上传支持　365
15.7　小结　368
第　16章 使用Spring Security
保护应用程序　369
16.1　简介　369
16.2　MyBank Web应用程序的
安全性需求　369
16.3　使用Spring Security保护
MyBank Web 应用程序　370
16.4　MyBank Web 应用程序——
使用Spring Security的ACL
模块保护 FixedDepositDetails
实例　377
16.5　使用基于Java的配置方法
配置Spring Security　391
16.6　小结　394
附录A　下载和安装MongoDB
数据库　395
A.1　下载并安装MongoDB数据库　395
A.2　连接MongoDB数据库　395
附录B　在Eclipse IDE
(或IntelliJ IDEA)中导入和
部署示例项目　397
B.1　下载和安装Eclipse IDE、
Tomcat 8和Maven 3　397
B.2　将示例项目导入Eclipse IDE
（或IntelliJ　IDEA）中　397
B.3　在 Eclipse IDE中配置Tomcat　8
服务器　399
B.4　在Tomcat 8 服务器上部署
Web项目　400
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring学习指南(第3版)
