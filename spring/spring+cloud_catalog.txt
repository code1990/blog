>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务实战
第1章　基础知识	1
什么是微服务架构	1
-- 与单体系统的区别	1
-- 如何实施微服务	2
为什么选择Spring Cloud	6
Spring Cloud简介	7
版本说明	8
第2章　微服务构建：Spring Boot	11
框架简介	12
快速入门	13
-- 项目构建与解析	13
-- 实现RESTful API	17
配置详解	20
-- 配置文件	20
-- 自定义参数	22
-- 参数引用	22
-- 使用随机数	23
-- 命令行参数	23
-- 多环境配置	24
-- 加载顺序	25
监控与管理	26
-- 初识actuator	27
-- 原生端点	28
小结	38
第3章　服务治理：Spring Cloud Eureka	39
服务治理	39
-- Netflix Eureka	40
--搭建服务注册中心	41
--注册服务提供者	43
--高可用注册中心	46
--服务发现与消费	48
Eureka详解	51
--基础架构	52
--服务治理机制	52
--源码分析	56
配置详解	65
--服务注册类配置	65
--服务实例类配置	67
跨平台支持	71
第4章　客户端负载均衡：Spring Cloud Ribbon	73
客户端负载均衡	73
RestTemplate详解	75
-- GET请求	75
-- POST请求	77
-- PUT请求	79
-- DELETE请求	79
源码分析	80
-- 负载均衡器	91
-- 负载均衡策略	109
配置详解	123
--自动化配置	124
-- Camden版本对RibbonClient配置的优化	125
-- 参数配置	127
-- 与Eureka结合	127
重试机制	128
第5章　服务容错保护：Spring Cloud Hystrix	130
快速入门	131
原理分析	135
-- 工作流程	135
-- 断路器原理	144
-- 依赖隔离	148
使用详解	151
-- 创建请求命令	151
-- 定义服务降级	154
-- 异常处理	157
-- 命令名称、分组以及线程池划分	158
-- 请求缓存	159
-- 请求合并	166
属性详解	172
-- Command属性	174
-- collapser属性	184
-- threadPool属性	185
Hystrix仪表盘	187
Turbine集群监控	192
-- 构建监控聚合服务	192
-- 与消息代理结合	196
第6章　声明式服务调用：Spring Cloud Feign	199
快速入门	200
参数绑定	202
继承特性	205
Ribbon配置	209
全局配置	209
指定服务配置	209
重试机制	210
Hystrix配置	211
全局配置	211
禁用Hystrix	211
指定命令配置	212
服务降级配置	212
其他配置	214
第7章　API网关服务：Spring Cloud Zuul	217
快速入门	219
-- 构建网关	220
-- 请求路由	221
-- 请求过滤	223
路由详解	226
-- 传统路由配置	226
-- 服务路由配置	228
-- 服务路由的默认规则	229
-- 自定义路由映射规则	229
-- 路径匹配	230
-- 路由前缀	233
-- 本地跳转	234
--  Cookie与头信息	235
-- Hystrix和Ribbon支持	236
过滤器详解	238
-- 过滤器	238
-- 请求生命周期	239
-- 核心过滤器	240
-- 异常处理	244
-- 禁用过滤器	256
动态加载	257
-- 动态路由	257
-- 动态过滤器	261
第8章　分布式配置中心：Spring Cloud Config	267
快速入门	267
-- 构建配置中心	268
-- 配置规则详解	269
-- 客户端配置映射	272
服务端详解	274
-- 基础架构	274
-- Git配置仓库	276
-- SVN配置仓库	279
-- 本地仓库	279
-- 本地文件系统	279
-- 健康监测	280
-- 属性覆盖	281
-- 安全保护	281
-- 加密解密	282
-- 高可用配置	286
客户端详解	286
--  URI指定配置中心	287
-- 服务化配置中心	287
-- 失败快速响应与重试	290
-- 获取远程配置	292
-- 动态刷新配置	293
第9章　消息总线：Spring Cloud Bus	295
消息代理	295
RabbitMQ实现消息总线	296
-- 基本概念	297
-- 安装与使用	298
-- 快速入门	302
-- 整合Spring Cloud Bus	306
-- 原理分析	307
-- 指定刷新范围	308
-- 架构优化	309
-- RabbitMQ配置	310
Kafka实现消息总线	312
-- Kafka简介	312
-- 快速入门	313
--整合Spring Cloud Bus	315
-- Kafka配置	318
深入理解	318
-- 源码分析	320
-- 其他消息代理的支持	342
第10章　消息驱动的微服务：Spring Cloud Stream	344
快速入门	344
核心概念	349
-- 绑定器	350
-- 发布-订阅模式	351
-- 消费组	353
-- 消息分区	354
使用详解	355
-- 开启绑定功能	355
-- 绑定消息通道	356
-- 消息生产与消费	360
-- 响应式编程	366
-- 消费组与消息分区	368
-- 消息类型	370
绑定器详解	373
-- 绑定器SPI	373
-- 自动化配置	374
-- 多绑定器配置	374
--  RabbitMQ与Kafka绑定器	376
配置详解	376
-- 基础配置	377
-- 绑定通道配置	377
-- 绑定器配置	379
第11章　分布式服务跟踪：Spring Cloud Sleuth	386
快速入门	386
-- 准备工作	386
-- 实现跟踪	389
跟踪原理	390
抽样收集	392
与Logstash整合	394
与Zipkin整合	397
--  HTTP收集	398
-- 消息中间件收集	402
-- 收集原理	404
-- 数据存储	414
--  API接口	417
附录A　Starter POMs	419
后记	421
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud与Docker微服务架构实战
1 微服务架构概述. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.1 单体应用架构存在的问题1
1.2 如何解决单体应用架构存在的问题3
1.3 什么是微服务3
1.4 微服务架构的优点与挑战5
1.4.1 微服务架构的优点5
1.4.2 微服务架构面临的挑战5
1.5 微服务设计原则6
1.6 如何实现微服务架构7
1.6.1 技术选型7
1.6.2 架构图及常用组件8
2 微服务开发框架——Spring Cloud . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
2.1 Spring Cloud 简介10
2.2 Spring Cloud 特点10
2.3 Spring Cloud 版本11
2.3.1 版本简介11
2.3.2 子项目一览12
2.3.3 Spring Cloud/Spring Boot 版本兼容性13
3 开始使用Spring Cloud 实战微服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
3.1 Spring Cloud 实战前提14
3.1.1 技术储备14
3.1.2 工具及软件版本15
3.2 服务提供者与服务消费者16
3.3 编写服务提供者16
3.3.1 手动编写项目17
3.3.2 使用Spring Initializr 快速创建Spring Boot 项目21
3.4 编写服务消费者23
3.5 为项目整合Spring Boot Actuator 25
3.6 硬编码有哪些问题27
4 微服务注册与发现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
4.1 服务发现简介29
4.2 Eureka 简介31
4.3 Eureka 原理31
4.4 编写Eureka Server 33
4.5 将微服务注册到Eureka Server 上35
4.6 Eureka Server 的高可用36
4.6.1 将应用注册到Eureka Server 集群上38
4.7 为Eureka Server 添加用户认证39
4.7.1 将微服务注册到需认证的Eureka Server 40
4.8 理解Eureka 的元数据41
4.8.1 改造用户微服务41
4.8.2 改造电影微服务41
4.9 Eureka Server 的REST 端点43
4.9.1 示例45
4.9.2 注销微服务实例49
4.10 Eureka 的自我保护模式51
4.11 多网卡环境下的IP 选择52
4.11.1 忽略指定名称的网卡52
4.11.2 使用正则表达式，指定使用的网络地址52
4.11.3 只使用站点本地地址53
4.11.4 手动指定IP 地址53
4.12 Eureka 的健康检查53
5 使用Ribbon 实现客户端侧负载均衡. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56
5.1 Ribbon 简介56
5.2 为服务消费者整合Ribbon 57
5.3 使用Java 代码自定义Ribbon 配置60
5.4 使用属性自定义Ribbon 配置63
5.5 脱离Eureka 使用Ribbon 64
6 使用Feign 实现声明式REST 调用. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
6.1 Feign 简介67
6.2 为服务消费者整合Feign 67
6.3 自定义Feign 配置69
6.4 手动创建Feign 72
6.4.1 修改用户微服务72
6.4.2 修改电影微服务76
6.5 Feign 对继承的支持78
6.6 Feign 对压缩的支持79
6.7 Feign 的日志80
6.8 使用Feign 构造多参数请求82
6.8.1 GET 请求多参数的URL 82
6.8.2 POST 请求包含多个参数83
7 使用Hystrix 实现微服务的容错处理. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85
7.1 实现容错的手段85
7.1.1 雪崩效应85
7.1.2 如何容错86
7.2 使用Hystrix 实现容错88
7.2.1 Hystrix 简介88
7.2.2 通用方式整合Hystrix 89
7.2.3 Hystrix 断路器的状态监控与深入理解91
7.2.4 Hystrix 线程隔离策略与传播上下文93
7.2.5 Feign 使用Hystrix 96
7.3 Hystrix 的监控101
7.3.1 Feign 项目的Hystrix 监控102
7.4 使用Hystrix Dashboard 可视化监控数据103
7.5 使用Turbine 聚合监控数据105
7.5.1 Turbine 简介105
7.5.2 使用Turbine 监控多个微服务105
7.5.3 使用消息中间件收集数据108
8 使用Zuul 构建微服务网关. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
8.1 为什么要使用微服务网关113
8.2 Zuul 简介115
8.3 编写Zuul 微服务网关115
8.4 Zuul 的路由端点118
8.5 Zuul 的路由配置详解119
8.6 Zuul 的安全与Header 122
8.6.1 敏感Header 的设置122
8.6.2 忽略Header 123
8.7 使用Zuul 上传文件124
8.7.1 编写文件上传微服务124
8.8 Zuul 的过滤器127
8.8.1 过滤器类型与请求生命周期127
8.8.2 编写Zuul 过滤器128
8.8.3 禁用Zuul 过滤器130
8.9 Zuul 的容错与回退130
8.9.1 为Zuul 添加回退131
8.10 Zuul 的高可用133
8.10.1 Zuul 客户端也注册到了Eureka Server 上133
8.10.2 Zuul 客户端未注册到Eureka Server 上133
8.11 使用Sidecar 整合非JVM 微服务134
8.11.1 编写Node.js 微服务135
8.11.2 编写Sidecar 136
8.11.3 Sidecar 的端点138
8.11.4 Sidecar 与Node.js 微服务分离部署139
8.11.5 Sidecar 原理分析139
9 使用Spring Cloud Config 统一管理微服务配置. . . . . . . . . . . . . . . . . . . . . . . 142
9.1 为什么要统一管理微服务配置142
9.2 Spring Cloud Config 简介143
9.3 编写Config Server 144
9.3.1 Config Server 的端点145
9.4 编写Config Client 147
9.5 Config Server 的Git 仓库配置详解149
9.6 Config Server 的健康状况指示器152
9.7 配置内容的加解密153
9.7.1 安装JCE 153
9.7.2 Config Server 的加解密端点153
9.7.3 对称加密153
9.7.4 存储加密的内容154
9.7.5 非对称加密155
9.8 使用/refresh 端点手动刷新配置155
9.9 使用Spring Cloud Bus 自动刷新配置157
9.9.1 Spring Cloud Bus 简介157
9.9.2 实现自动刷新158
9.9.3 局部刷新159
9.9.4 架构改进159
9.9.5 跟踪总线事件160
9.10 Spring Cloud Config 与Eureka 配合使用161
9.11 Spring Cloud Config 的用户认证162
9.11.1 Config Client 连接需用户认证的Config Server 163
9.12 Config Server 的高可用164
9.12.1 Git 仓库的高可用164
9.12.2 RabbitMQ 的高可用164
9.12.3 Config Server 自身的高可用165
10 使用Spring Cloud Sleuth 实现微服务跟踪. . . . . . . . . . . . . . . . . . . . . . . . . . . . 167
10.1 为什么要实现微服务跟踪167
10.2 Spring Cloud Sleuth 简介168
10.3 整合Spring Cloud Sleuth 170
10.4 Spring Cloud Sleuth 与ELK 配合使用172
10.5 Spring Cloud Sleuth 与Zipkin 配合使用176
10.5.1 Zipkin 简介176
10.5.2 编写Zipkin Server 176
10.5.3 微服务整合Zipkin 178
10.5.4 使用消息中间件收集数据181
10.5.5 存储跟踪数据183
11 Spring Cloud 常见问题与总结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186
11.1 Eureka 常见问题186
11.1.1 Eureka 注册服务慢186
11.1.2 已停止的微服务节点注销慢或不注销187
11.1.3 如何自定义微服务的Instance ID 188
11.1.4 Eureka 的UNKNOWN 问题总结与解决189
11.2 Hystrix/Feign 整合Hystrix 后首次请求失败190
11.2.1 原因分析191
11.2.2 解决方案191
11.3 Turbine 聚合的数据不完整191
11.3.1 解决方案192
11.4 Spring Cloud 各组件配置属性193
11.4.1 Spring Cloud 的配置193
11.4.2 原生配置193
11.5 Spring Cloud 定位问题思路总结194
12 Docker 入门. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197
12.1 Docker 简介197
12.2 Docker 的架构197
12.3 安装Docker 199
12.3.1 系统要求199
12.3.2 移除非官方软件包199
12.3.3 设置Yum 源199
12.3.4 安装Dokcer 200
12.3.5 卸载Docker 201
12.4 配置镜像加速器201
12.5 Docker 常用命令202
12.5.1 Docker 镜像常用命令202
12.5.2 Docker 容器常用命令204
13 将微服务运行在Docker 上. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209
13.1 使用Dockerfile 构建Docker 镜像209
13.1.1 Dockerfile 常用指令210
13.1.2 使用Dockerfile 构建镜像215
13.2 使用Docker Registry 管理Docker 镜像217
13.2.1 使用Docker Hub 管理镜像217
13.2.2 使用私有仓库管理镜像219
13.3 使用Maven 插件构建Docker 镜像220
13.3.1 快速入门221
13.3.2 插件读取Dockerfile 进行构建222
13.3.3 将插件绑定在某个phase 执行223
13.3.4 推送镜像224
13.4 常见问题与总结226
14 使用Docker Compose 编排微服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227
14.1 Docker Compose 简介227
14.2 安装Docker Compose 227
14.2.1 安装Compose 228
14.2.2 安装Compose 命令补全工具228
14.3 Docker Compose 快速入门229
14.3.1 基本步骤229
14.3.2 入门示例229
14.3.3 工程、服务、容器230
14.4 docker-compose.yml 常用命令230
14.4.1 build 230
14.4.2 command 231
14.4.3 dns 231
14.4.4 dns_search 231
14.4.5 environment 231
14.4.6 env_file 232
14.4.7 expose 232
14.4.8 external_links 232
14.4.9 image 232
14.4.10 links 232
14.4.11 networks 233
14.4.12 network_mode 233
14.4.13 ports 233
14.4.14 volumes 233
14.4.15 volumes_from 234
14.5 docker-compose 常用命令234
14.5.1 build 234
14.5.2 help 235
14.5.3 kill 235
14.5.4 logs 235
14.5.5 port 235
14.5.6 ps 235
14.5.7 pull 235
14.5.8 rm 236
14.5.9 run 236
14.5.10 scale 236
14.5.11 start 236
14.5.12 stop 236
14.5.13 up 236
14.6 Docker Compose 网络设置237
14.6.1 基本概念237
14.6.2 更新容器237
14.6.3 links 238
14.6.4 指定自定义网络238
14.6.5 配置默认网络239
14.6.6 使用已存在的网络239
14.7 综合实战：使用Docker Comose 编排Spring Cloud 微服务240
14.7.1 编排Spring Cloud 微服务240
14.7.2 编排高可用的Eureka Server 243
14.7.3 编排高可用Spring Cloud 微服务集群及动态伸缩245
14.8 常见问题与总结247
后记. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 248
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud与Docker微服务架构实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务：入门、实战与进阶
Contents 目　　录
赞誉
前言
第一部分　准备篇
第1章　Spring Cloud 与微服务概述  2
1.1　传统的单体应用  2
1.1.1　改进单体应用的架构  2
1.1.2　向微服务靠拢  3
1.2　什么是微服务  4
1.2.1　使用微服务架构的优势和劣势  4
1.2.2　重构前的准备工作  5
1.3　什么是Spring Cloud  5
1.3.1　Spring Cloud模块介绍  6
1.3.2　Spring Cloud版本介绍  6
1.4　本章小结  7
第2章　实战前的准备工作  8
2.1　开发环境的准备  8
2.2　Spring Boot入门  9
2.2.1　Spring Boot简介  9
2.2.2　搭建Spring Boot项目  9
2.2.3　编写第一个REST接口  11
2.2.4　读取配置文件  11
2.2.5　profiles多环境配置  13
2.2.6　热部署  13
2.2.7　actuator监控  15
2.2.8　自定义actuator端点  17
2.2.9　统一异常处理  18
2.2.10　异步执行  20
2.2.11　随机端口  22
2.2.12　编译打包  24
2.3　Spring Boot Starter自定义  25
2.3.1　Spring Boot Starter项目创建  25
2.3.2　自动创建客户端  26
2.3.3　使用Starter  27
2.3.4　使用注解开启Starter自动构建  27
2.3.5　使用配置开启Starter自动构建  28
2.3.6　配置Starter内容提示  29
2.4　本章小结  29
第二部分　基础篇
第3章　Eureka 注册中心  32
3.1　Eureka  32
3.2　使用 Eureka 编写注册中心服务  33
3.3　编写服务提供者  35
3.3.1　创建项目注册到Eureka  35
3.3.2　编写提供接口  36
3.4　编写服务消费者  37
3.4.1　直接调用接口  37
3.4.2　通过Eureka来消费接口  38
3.5　开启 Eureka 认证  38
3.6　Eureka 高可用搭建  39
3.6.1　高可用原理  39
3.6.2　搭建步骤  40
3.7　常用配置讲解  41
3.7.1　关闭自我保护  41
3.7.2　自定义Eureka的
InstanceID  41
3.7.3　自定义实例跳转链接  42
3.7.4　快速移除已经失效的服务信息  43
3.8　扩展使用  44
3.8.1　Eureka REST API  44
3.8.2　元数据使用  46
3.8.3　EurekaClient使用  47
3.8.4　健康检查  49
3.8.5　服务上下线监控  50
3.9　本章小结  51
第4章　客户端负载均衡 Ribbon  52
4.1　Ribbon  52
4.1.1　Ribbon模块  52
4.1.2　Ribbon 使用  53
4.2　RestTemplate 结合 Ribbon 使用  54
4.2.1　使用 RestTemplate 与整合 Ribbon  54
4.2.2　RestTemplate 负载均衡示例  57
4.2.3　@LoadBalanced 注解原理  58
4.2.4　Ribbon API 使用  62
4.2.5　Ribbon 饥饿加载  63
4.3　负载均衡策略介绍  64
4.4　自定义负载策略  65
4.5　配置详解  66
4.5.1　常用配置  66
4.5.2　代码配置 Ribbon  67
4.5.3　配置文件方式配置Ribbon  67
4.6　重试机制  68
4.7　本章小结  69
第5章　声明式REST客户端Feign  70
5.1　使用 Feign 调用服务接口  70
5.1.1　在Spring Cloud中集成Feign  71
5.1.2　使用Feign调用接口  71
5.2　自定义 Feign的配置  72
5.2.1　日志配置  72
5.2.2　契约配置  73
5.2.3　Basic认证配置  74
5.2.4　超时时间配置  75
5.2.5　客户端组件配置  75
5.2.6　GZIP压缩配置  76
5.2.7　编码器解码器配置  77
5.2.8　使用配置自定义Feign的配置  78
5.2.9　继承特性  78
5.2.10　多参数请求构造  80
5.3　脱离 Spring Cloud 使用 Feign  80
5.3.1　原生注解方式  81
5.3.2　构建Feign对象  82
5.3.3　其他配置  83
5.4　本章小结  83
第6章　Hystrix 服务容错处理  84
6.1　Hystrix  84
6.1.1　Hystrix的简单使用  84
6.1.2　回退支持  85
6.1.3　信号量策略配置  86
6.1.4　线程隔离策略配置  86
6.1.5　结果缓存  87
6.1.6　缓存清除  88
6.1.7　合并请求  89
6.2　在 Spring Cloud 中使用Hystrix  91
6.2.1　简单使用  91
6.2.2　配置详解  92
6.2.3　Feign整合Hystrix服务容错  95
6.2.4　Feign中禁用Hystrix  97
6.3　Hystrix 监控  97
6.4　整合 Dashboard 查看监控数据  98
6.5　Turbine 聚合集群数据  100
6.5.1　Turbine使用  100
6.5.2　context-path导致监控失败  101
6.6　本章小结  102
第7章　API网关  103
7.1　Zuul 简介  103
7.2　使用 Zuul 构建微服务网关  104
7.2.1　简单使用  104
7.2.2　集成Eureka  105
7.3　Zuul 路由配置  105
7.4　Zuul过滤器讲解  106
7.4.1　过滤器类型  106
7.4.2　请求生命周期  107
7.4.3　使用过滤器  108
7.4.4　过滤器禁用  109
7.4.5　过滤器中传递数据  110
7.4.6　过滤器拦截请求  111
7.4.7　过滤器中异常处理  113
7.5　Zuul 容错和回退  115
7.5.1　容错机制  115
7.5.2　回退机制  116
7.6　Zuul使用小经验  118
7.6.1　/routes 端点  118
7.6.2　/filters 端点  118
7.6.3　文件上传  119
7.6.4　请求响应信息输出  121
7.6.5　Zuul自带的Debug功能  124
7.7　Zuul 高可用  126
7.8　本章小结  127
第三部分　实战篇
第8章　API 网关之Spring Cloud Gateway  130
8.1　Spring Cloud Gateway介绍  130
8.2　Spring Cloud Gateway工作原理  131
8.3　Spring Cloud Gateway快速上手  131
8.3.1　创建Gateway项目  131
8.3.2　路由转发示例  132
8.3.3　整合Eureka路由  133
8.3.4　整合Eureka的默认路由  133
8.4　Spring Cloud Gateway路由断言工厂  134
8.4.1　路由断言工厂使用  134
8.4.2　自定义路由断言工厂  136
8.5　Spring Cloud Gateway过滤器工厂  137
8.5.1　Spring Cloud Gateway过滤器工厂使用  137
8.5.2　自定义Spring Cloud Gateway过滤器工厂  138
8.6　全局过滤器  140
8.7　实战案例  143
8.7.1　限流实战  143
8.7.2　熔断回退实战  145
8.7.3　跨域实战  145
8.7.4　统一异常处理  147
8.7.5　重试机制  150
8.8　本章小结  151
第9章　自研分布式配置管理  152
9.1　自研配置管理框架 Smconf 简介  152
9.2　Smconf 工作原理  153
9.3　Smconf 部署  154
9.3.1　Mongodb 安装  154
9.3.2　Zookeeper 安装  155
9.3.3　Smconf Server 部署  156
9.4　项目中集成 Smconf  157
9.4.1　集成Smconf  157
9.4.2　使用Smconf  158
9.4.3　配置更新回调  159
9.5　Smconf 详细使用  160
9.5.1　源码编译问题  160
9.5.2　后台账号管理  160
9.5.3　REST API  161
9.6　Smconf 源码解析  163
9.6.1　Client启动  163
9.6.2　启动加载配置  165
9.6.3　配置修改推送原理  166
9.7　本章小结  167
第10章　分布式配置中心Apollo  168
10.1　Apollo简介  168
10.2　Apollo的核心功能点  168
10.3　Apollo核心概念  170
10.4　Apollo本地部署  171
10.5　Apollo Portal管理后台使用  172
10.6　Java中使用Apollo  174
10.6.1　普通Java项目中使用  174
10.6.2　Spring Boot中使用  177
10.7　Apollo的架构设计  179
10.7.1　Apollo架构设计介绍  179
10.7.2　Apollo服务端设计  181
10.7.3　Apollo客户端设计  188
10.7.4　Apollo高可用设计  195
10.8　本章小结  196
第11章　Sleuth 服务跟踪  197
11.1　Spring Cloud 集成 Sleuth  197
11.2　整合 Logstash  198
11.2.1　ELK 简介  198
11.2.2　输出 JSON 格式日志  198
11.3　整合 Zipkin  200
11.3.1　Zipkin 数据收集服务  200
11.3.2　项目集成 Zipkin 发送调用链数据  201
11.3.3　抽样采集数据  203
11.3.4　异步任务线程池定义  203
11.3.5　TracingFilter  204
11.3.6　监控本地方法  205
11.3.7　过滤不想跟踪的请求  206
11.3.8　用 RabbitMq 代替 Http 发送调用链数据  206
11.3.9　用 Elasticsearch 存储调用链数据  207
11.4　本章小结  208
第12章　微服务之间调用的安全认证  209
12.1　什么是 JWT  209
12.2　创建统一的认证服务  210
12.2.1　表结构  210
12.2.2　JWT工具类封装  210
12.2.3　认证接口  212
12.3　服务提供方进行调用认证  212
12.4　服务消费方申请 Token  214
12.5　Feign 调用前统一申请 Token 传递到调用的服务中  216
12.6　RestTemplate调用前统一申请 Token 传递到调用的服务中  217
12.7　Zuul 中传递 Token 到路由的服务中  218
12.8　本章小结  219
第13章　Spring Boot Admin  220
13.1　Spring Boot Admin 的使用方法  220
13.1.1　创建 Spring Boot Admin项目  220
13.1.2　将服务注册到 Spring Boot Admin  221
13.1.3　监控内容介绍  223
13.1.4　如何在 Admin 中查看各个服务的日志  225
13.2　开启认证  226
13.3　集成 Eureka  227
13.4　监控服务  228
13.4.1　邮件警报  228
13.4.2　自定义钉钉警报  229
13.5　本章小结  232
第14章　服务的API文档管理  233
14.1　Swagger 简介  233
14.2　集成 Swagger 管理 API 文档  234
14.2.1　项目中集成 Swagger  234
14.2.2　使用 Swagger 生成文档  234
14.2.3　在线测试接口  235
14.3　Swagger 注解  236
14.4　Eureka 控制台快速查看 Swagger 文档  240
14.5　请求认证  240
14.6　Zuul中聚合多个服务Swagger  241
14.7　本章小结  242
第四部分　高级篇
第15章　API 网关扩展  244
15.1　用户认证  244
15.1.1　动态管理不需要拦截的 API 请求  244
15.1.2　创建认证的用户服务  246
15.1.3　路由之前的认证  247
15.1.4　向下游微服务中传递认证之后的用户信息  248
15.1.5　内部服务间的用户信息传递  248
15.2　服务限流  250
15.2.1　限流算法  250
15.2.2　单节点限流  251
15.2.3　集群限流  255
15.2.4　具体服务限流  258
15.2.5　具体接口限流  258
15.3　服务降级  262
15.4　灰度发布  264
15.4.1　原理讲解  264
15.4.2　根据用户做灰度发布  265
15.4.3　根据 IP 做灰度发布  268
15.5　本章小结  268
第16章　微服务之缓存  269
16.1　Guava Cache 本地缓存  269
16.1.1　Guava Cache 简介  269
16.1.2　代码示例  270
16.1.3　回收策略  270
16.2　Redis 缓存  271
16.2.1　用 Redistemplate 操作 Redis  271
16.2.2　用 Repository 操作 Redis  272
16.2.3　Spring Cache 缓存数据  274
16.2.4　缓存异常处理  278
16.2.5　自定义缓存工具类  279
16.3　防止缓存穿透方案  282
16.3.1　什么是缓存穿透  282
16.3.2　缓存穿透的危害  282
16.3.3　解决方案  282
16.3.4　布隆过滤器介绍  283
16.3.5　代码示例  283
16.4　防止缓存雪崩方案  284
16.4.1　什么是缓存雪崩  284
16.4.2　缓存雪崩的危害  284
16.4.3　解决方案  284
16.4.4　代码示例  285
16.4.5　分布式锁方式  285
16.5　本章小结  286
第17章　微服务之存储  287
17.1　存储选型  287
17.2　Mongodb  288
17.2.1　集成 Spring Data Mongodb  288
17.2.2　添加数据操作  288
17.2.3　索引使用  290
17.2.4　修改数据操作  291
17.2.5　删除数据操作  293
17.2.6　查询数据操作  294
17.2.7　GridFS 操作  295
17.2.8　用 Repository方式操作数据  296
17.2.9　自增 ID 实现  300
17.2.10　批量更新扩展  303
17.3　Mysql  304
17.3.1　集成 Spring Jdbc-Template  304
17.3.2　JdbcTemplate 代码示例  305
17.3.3　封装 JdbcTemplate 操作 Mysql 更简单  305
17.3.4　扩展 JdbcTemplate 使用方式  306
17.3.5　常见问题  310
17.4　Elasticsearch  312
17.4.1　集成 Spring Data Elasticsearch  312
17.4.2　Repository 示例  312
17.4.3　ElasticsearchTemplate 示例  315
17.4.4　索引构建方式  318
17.5　本章小结  319
第18章　微服务之分布式事务解决方案  320
18.1　两阶段型  320
18.2　TCC 补偿型  321
18.3　最终一致性  321
18.3.1　原理讲解  321
18.3.2　创建可靠性消息服务  323
18.3.3　消息存储表设计  324
18.3.4　提供服务接口  325
18.3.5　创建消息发送系统  329
18.3.6　消费消息逻辑  332
18.3.7　消息管理系统  335
18.4　最大努力通知型事务  335
18.5　本章小结  335
第19章　分布式任务调度  336
19.1　Elastic-Job  336
19.1.1　Elastic-Job 介绍  336
19.1.2　任务调度目前存在的问题  336
19.1.3　为什么选择 Elastic-Job  337
19.2　快速集成  338
19.3　任务使用  339
19.3.1　简单任务  339
19.3.2　数据流任务  340
19.3.3　脚本任务  340
19.4　配置参数讲解  341
19.4.1　注册中心配置  341
19.4.2　作业配置  342
19.4.3　dataflow 独有配置  343
19.4.4　script独有配置  343
19.5　多节点并行调度  344
19.5.1　分片概念  344
19.5.2　任务节点分片策略  344
19.5.3　业务数据分片处理  345
19.6　事件追踪  347
19.7　扩展功能  349
19.7.1　自定义监听器  349
19.7.2　定义异常处理  349
19.8　运维平台  350
19.8.1　功能列表  350
19.8.2　部署运维平台  351
19.8.3　运维平台使用  351
19.9　使用经验分享  355
19.9.1　任务的划分和监控  355
19.9.2　任务的扩展性和节点数量  355
19.9.3　任务的重复执行  355
19.9.4　overwrite 覆盖问题  356
19.9.5　流水式任务  356
19.10　本章小结  357
第20章　分库分表解决方案  358
20.1　Sharding-JDBC  358
20.1.1　介绍  358
20.1.2　功能列表  359
20.1.3　相关概念  359
20.2　快速集成  360
20.3　读写分离实战  362
20.3.1　准备数据  362
20.3.2　配置读写分离  363
20.3.3　验证读从库  363
20.3.4　验证写主库  365
20.3.5　Hint 强制路由主库  366
20.4　分库分表实战  367
20.4.1　常用分片算法  367
20.4.2　使用分片算法  368
20.4.3　不分库只分表实战  368
20.4.4　既分库又分表实战  372
20.5　分布式主键  375
20.6　本章小结  377
第21章　最佳生产实践经验  378
21.1　开发环境和测试环境共用Eureka  378
21.2　Swagger和Actuator访问进行权限控制  379
21.3　Spring Boot Admin监控被保护的服务  380
21.4　Apollo配置中心简化版搭建分享  380
21.5　Apollo使用小经验  382
21.5.1　公共配置  382
21.5.2　账号权限  383
21.5.3　环境配置和项目配置  385
21.6　Apollo动态调整日志级别  385
21.7　Apollo存储加密  387
21.8　扩展Apollo支持存储加解密  390
21.9　Apollo结合Zuul实现动态路由  391
21.10　Apollo整合Archaius  393
21.11　Elastic-Job的Spring-Boot-Starter封装  394
21.12　Spring Boot中Mongodb多数据源封装  396
21.13　Zuul中对API进行加解密  398
21.14　本章小结  400
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务：入门、实战与进阶
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云原生Java
目录
前言（James Watters）.......................................................xv
前言（Rod Johnson）........................................................ xvii
前言................................................................................ xix
第Ⅰ部分　基础知识
第1 章　云原生应用程序.......................................................... 3
亚马逊的故事 ........................................................................................................ 3
平台的承诺 ............................................................................................................ 5
模式 ........................................................................................................................ 7
可扩展性 ................................................................................................................. 7
可靠性 .................................................................................................................... 8
敏捷性 ..................................................................................................................... 8
Netflix 的故事 ......................................................................................................... 9
微服务 ................................................................................................................. 11
拆分单体系统 ...................................................................................................... 12
Netflix OSS ......................................................................................................... 13
云原生Java ......................................................................................................... 14
十二要素原则 ....................................................................................................... 14
代码库 ................................................................................................................. 15
依赖 ..................................................................................................................... 15
配置 ..................................................................................................................... 16
x ｜ 目录
后端服务 ............................................................................................................. 17
构建、发布、运行 .............................................................................................. 17
进程 ..................................................................................................................... 17
端口绑定 ............................................................................................................. 18
并发 ..................................................................................................................... 18
易处理 ................................................................................................................. 18
开发/ 生产环境一致 ........................................................................................... 19
日志 ..................................................................................................................... 19
管理进程 ............................................................................................................. 19
总结 ........................................................................................................................ 20
第2 章　训练营：Spring Boot 和Cloud Foundry......................21
什么是Spring Boot ................................................................................................ 21
Spring Initializr 入门 .............................................................................................. 21
Spring Tool Suite 入门 ............................................................................................ 30
安装Spring Tool Suite（STS）............................................................................. 30
使用Spring Initializr 创建一个新项目 ................................................................ 31
Spring 指南大全 ................................................................................................... 36
遵循STS 中的指南 ............................................................................................. 38
配置 ....................................................................................................................... 40
Cloud Foundry 平台 ............................................................................................... 52
总结 ....................................................................................................................... 66
第3 章　符合十二要素程序风格的配置....................................... 67
令人迷惑的“配置”合并 ........................................................................................... 67
Spring 框架对配置的支持 .................................................................................... 67
PropertyPlaceholderConfigurer ............................................................................ 68
Environment 接口和@Value 注解 ....................................................................... 69
Profile .................................................................................................................. 71
启动配置 ............................................................................................................. 73
使用Spring Cloud Config Server 进行中心化、日志型的配置................................... 76
Spring Cloud Config Server ................................................................................. 76
Spring Cloud Config 客户端 ................................................................................ 78
安全 ..................................................................................................................... 79
目录 ｜ xi
可刷新的配置 ....................................................................................................... 79
总结 ...................................................................................................................... 83
第４章　测试..................................................................... 85
测试的构成 ........................................................................................................... 86
在Spring Boot 中进行测试 ................................................................................... 86
集成测试 ............................................................................................................. 88
测试切片 ............................................................................................................. 89
测试中的Mock ................................................................................................... 89
使用@SpringBootTest 中的Servlet 容器 ............................................................ 93
测试分片 ............................................................................................................. 94
端到端测试 ......................................................................................................... 102
测试分布式系统 ................................................................................................ 102
消费者驱动的契约测试 ..................................................................................... 104
Spring Cloud Contract ....................................................................................... 105
总结 .................................................................................................................... 113
第5 章　迁移遗留的应用程序................................................. 115
契约 .................................................................................................................... 115
迁移应用程序环境 ................................................................................................ 116
开箱即用的构建包（Buildpacks） ..................................................................... 116
自定义的构建包 ................................................................................................ 117
容器化的应用程序 ............................................................................................ 118
将应用程序迁移到云上的微重构 ........................................................................ 119
连接后端服务 .................................................................................................... 120
用Spring 实现服务平等 .................................................................................... 121
总结 .................................................................................................................... 133
第Ⅱ部分　Web 服务
第6 章　REST API........................................................... 137
伦纳德· 理查森的成熟模型 .................................................................................. 137
使用Spring MVC 实现简单的REST API ................................................................. 139
内容协商 .............................................................................................................. 142
xii ｜ 目录
读写二进制数据 ................................................................................................ 142
Google Protocol Buffers .................................................................................... 145
错误处理 ............................................................................................................. 150
超媒体 ................................................................................................................. 152
媒体类型和模式 ................................................................................................ 158
API 版本 ............................................................................................................. 159
编写REST API 文档 ........................................................................................... 162
客户端 ................................................................................................................ 167
用于临时浏览和交互的REST 客户端 ............................................................... 167
RestTemplate ..................................................................................................... 171
总结 ................................................................................................................... 177
第7 章　路由.................................................................... 179
DiscoveryClient 接口 .......................................................................................... 180
Cloud Foundry Route 服务 .................................................................................. 190
总结 ...................................................................................................................... 195
第8 章　边缘服务............................................................... 197
Greetings 服务 ...................................................................................................... 198
一个简单的边缘服务 ........................................................................................... 200
Netflix Feign ........................................................................................................ 202
使用Netflix Zuul 进行过滤和代理 ........................................................................... 204
自定义Zuul 过滤器 ........................................................................................... 214
边缘服务的安全 .................................................................................................... 218
OAuth ................................................................................................................... 219
服务端应用程序 ................................................................................................ 220
HTML5 和JavaScript 单页面应用程序 ............................................................. 221
没有用户的应用 ................................................................................................ 221
受信任的客户端 ................................................................................................ 221
Spring Security .................................................................................................... 222
Spring Cloud Security ........................................................................................... 227
一个Spring Security OAuth 授权服务器 ........................................................... 227
保护Greetings 资源服务器的安全 .................................................................... 232
创建一个受OAuth 保护的单页面应用程序 ...................................................... 238
总结 ..................................................................................................................... 247
目录 ｜ xiii
第Ⅲ部分　数据整合
第9 章　数据管理............................................................... 251
数据建模 ............................................................................................................... 251
关系数据库管理系统（RDBMS） ...................................................................... 252
NoSQL............................................................................................................... 253
Spring Data ......................................................................................................... 253
Spring Data 应用程序的结构 ............................................................................. 254
域类 ................................................................................................................... 254
库 ...................................................................................................................... 254
为领域数据组织Java 包 .................................................................................... 255
使用JDBC 访问RDBMS 数据 ............................................................................... 258
Spring 的JDBC 支持 ........................................................................................... 259
Spring Data 示例 ................................................................................................. 261
Spring Data JPA.................................................................................................... 264
Account Service ................................................................................................. 264
集成测试 ........................................................................................................... 274
Spring Data MongoDB ......................................................................................... 275
Order Service ..................................................................................................... 275
集成测试 ........................................................................................................... 282
Spring Data Neo4j ............................................................................................... 284
Inventory Service ............................................................................................... 284
集成测试 ........................................................................................................... 294
Spring Data Redis ................................................................................................ 297
高速缓存 ........................................................................................................... 298
总结 .................................................................................................................... 302
第10 章　消息系统............................................................. 303
Spring Integration 的事件驱动架构 ..................................................................... 304
消息端点 ........................................................................................................... 305
使用简单的组件构建复杂的系统 ...................................................................... 306
消息代理、桥接、竞争消费者模式和事件溯源 ................................................... 314
发布—订阅目的地 ............................................................................................ 314
点对点目的地 .................................................................................................... 315
xiv ｜ 目录
Spring Cloud Stream .......................................................................................... 315
流生产者 ........................................................................................................... 316
流消费者 ........................................................................................................... 321
总结 .................................................................................................................... 323
第11 章　批处理和任务........................................................ 325
批处理工作 ........................................................................................................ 325
Spring Batch ....................................................................................................... 326
我们的第一个批处理作业 ................................................................................. 327
调度 .................................................................................................................... 336
通过消息传递远程分区Spring 批处理作业 ............................................................. 337
任务管理 ............................................................................................................. 346
通过Workflow 进行的以工作流为中心的整合 ........................................................ 348
使用消息传递的分布式......................................................................................... 362
总结 ..................................................................................................................... 362
第12 章　数据集成............................................................. 363
分布式事务 .......................................................................................................... 364
故障隔离和优雅的降级........................................................................................ 364
saga 模式 ............................................................................................................. 369
CQRS（命令查询责任分离） .............................................................................. 369
投诉API ............................................................................................................ 371
投诉统计API .................................................................................................... 383
Spring Cloud Data Flow ...................................................................................... 385
Stream ............................................................................................................... 387
任务 ................................................................................................................... 390
REST API .......................................................................................................... 391
实现Data Flow 客户端 ...................................................................................... 392
总结 .................................................................................................................... 407
第IV 部分　生产
第13 章　可观测的系统....................................................... 411
你构建，你运行 ................................................................................................. 412
目录 ｜ xv
谋杀神秘微服务 .................................................................................................. 413
十二要素运维 ..................................................................................................... 413
新方式 ................................................................................................................. 414
可观测性 ............................................................................................................ 416
推与拉的可观测性和解析率 ................................................................................ 416
使用Spring Boot Actuator 捕获应用程序的当前状态 .......................................... 417
度量 ...................................................................................................................... 418
通过/info 端点识别服务 ......................................................................................... 431
健康检查 ............................................................................................................. 432
审计事件 .............................................................................................................. 436
应用程序日志 ...................................................................................................... 439
指定日志输出 .................................................................................................... 440
指定日志级别 .................................................................................................... 441
分布式跟踪 ......................................................................................................... 445
用Spring Cloud Sleuth 寻找线索 ...................................................................... 446
多少数据是足够的 ............................................................................................ 447
OpenZipkin ：一张图片胜过千丝万缕 ............................................................... 448
跟踪其他平台和技术 ......................................................................................... 454
仪表板 ................................................................................................................ 455
使用Hystrix 仪表板监控下游服务 .................................................................... 455
Codecentric 的Spring Boot Admin .................................................................... 459
Ordina Microservices 仪表板 ............................................................................. 462
Pivotal Cloud Foundry 的AppsManager ............................................................ 463
修复 .................................................................................................................. 465
总结 ................................................................................................................... 467
第14 章　服务代理.............................................................................................469
创建后台服务 .................................................................................................. 470
平台视图 ............................................................................................................ 472
使用Spring Cloud Cloud Foundry Service Broker 实现服务代理 ........................ 473
简单的Amazon S3 服务代理 ............................................................................ 473
服务目录 ........................................................................................................... 474
管理服务实例 .................................................................................................... 476
服务绑定 ........................................................................................................... 482
保护服务代理 .................................................................................................... 486
xvi ｜ 目录
部署 ................................................................................................................... 487
使用BOSH 发布 ............................................................................................... 487
使用Cloud Foundry 发布 .................................................................................. 488
注册Amazon S3 Service Broker ....................................................................... 489
创建Amazon S3 服务实例 ................................................................................ 490
消费服务实例 .................................................................................................... 491
S3 客户端应用程序 ........................................................................................... 493
运行测试 ........................................................................................................... 496
总结 .................................................................................................................. 496
第15 章　持续交付.............................................................497
持续集成之外 .................................................................................................. 497
John Allspaw 在Flickr 以及后来的Etsy ........................................................... 498
Netflix 的Adrian Cockroft ................................................................................ 499
亚马逊的持续交付 ............................................................................................ 500
流水线 ................................................................................................................ 500
测试 .................................................................................................................... 501
持续交付微服务 ................................................................................................502
工具 .................................................................................................................. 503
Concourse ......................................................................................................... 503
容器 ................................................................................................................... 504
持续交付微服务 ................................................................................................. 504
安装Concourse ................................................................................................. 505
基本的管道设计 ................................................................................................ 506
持续集成 ........................................................................................................... 518
消费者驱动的协约测试......................................................................................  518
User 微服务流水线 ............................................................................................ 519
数据 ................................................................................................................... 522
生产 ................................................................................................................... 523
第V 部分　附录
附录A　在Java EE 中使用Spring Boot................................527
索引............................................................................... 552
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>云原生Java
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud与Docker微服务架构实战（第2版）
1 微服务架构概述  1
1.1 单体应用架构存在的问题  . 1
1.2 如何解决单体应用架构存在的问题  3
1.3 什么是微服务  . 3
1.4 微服务架构的优点与挑战  . 4
1.4.1 微服务架构的优点  5
1.4.2 微服务架构面临的挑战  5
1.5 微服务设计原则  6
1.6 如何实现微服务架构  7
1.6.1 技术选型  7
1.6.2 架构图及常用组件  8
2 微服务开发框架——Spring Cloud  . 9
2.1 Spring Cloud 简介  . 9
2.2 Spring Cloud 特点  . 10
2.3 Spring Cloud 版本  . 10
2.3.1 版本简介  10
2.3.2 子项目一览  . 12
2.3.3 Spring Cloud/Spring Boot 版本兼容性  . 13
3 开始使用Spring Cloud 实战微服务  14
3.1 Spring Cloud 实战前提  14
3.1.1 技术储备  14
3.1.2 工具及软件版本  . 15
3.2 服务提供者与服务消费者  . 16
3.3 编写服务提供者  16
3.3.1 手动编写项目  . 17
3.3.2 使用Spring Initializr 快速创建Spring Boot 项目  . 21
3.4 编写服务消费者  23
3.5 为项目整合Spring Boot Actuator  . 25
3.6 硬编码有哪些问题  28
4 微服务注册与发现  30
4.1 服务发现简介  . 30
4.2 Eureka 简介  . 32
4.3 Eureka 原理  . 32
4.4 编写Eureka Server  34
4.5 将微服务注册到Eureka Server 上  36
4.6 Eureka Server 的高可用  38
4.6.1 编写高可用Eureka Server  38
4.6.2 将应用注册到Eureka Server 集群上  41
4.7 用户认证  . 41
4.7.1 为Eureka Server 添加用户认证  . 41
4.7.2 将微服务注册到需认证的Eureka Server  43
4.8 Eureka 的元数据  43
4.8.1 改造用户微服务  . 43
4.8.2 改造电影微服务  . 44
4.9 Eureka Server 的REST 端点  46
4.9.1 示例  47
4.9.2 注销微服务实例  . 52
4.10 Eureka 的自我保护模式  . 53
4.11 多网卡环境下的IP 选择  . 54
4.12 Eureka 的健康检查  56
4.13 排除Jersey 依赖  . 57
5 使用Ribbon 实现客户端侧负载均衡  . 59
5.1 Ribbon 简介  59
5.2 为服务消费者整合Ribbon  . 60
5.3 Ribbon 配置自定义  63
5.3.1 使用Java 代码自定义Ribbon 配置  63
5.3.2 使用属性自定义Ribbon 配置  67
5.4 脱离Eureka 使用Ribbon  68
5.5 饥饿加载  . 70
6 使用Feign 实现声明式REST 调用  . 72
6.1 Feign 简介  73
6.2 为服务消费者整合Feign  73
6.3 自定义Feign 配置  . 75
6.3.1 使用Java 代码自定义Feign 配置  . 75
6.3.2 使用属性自定义Feign 配置  79
6.4 手动创建Feign  80
6.4.1 修改用户微服务  . 80
6.4.2 修改电影微服务  . 84
6.5 Feign 对继承的支持  . 86
6.6 Feign 对压缩的支持  . 87
6.7 Feign 的日志  87
6.7.1 编码方式设置日志级别  88
6.7.2 使用属性配置日志级别  89
6.8 使用Feign 构造多参数请求  90
6.8.1 GET 请求多参数的URL  . 90
6.8.2 POST 请求包含多个参数  91
6.9 使用Feign 上传文件  92
7 使用Hystrix 实现微服务的容错处理  . 94
7.1 实现容错的手段  94
7.1.1 雪崩效应  95
7.1.2 如何容错  95
7.2 使用Hystrix 实现容错  . 97
7.2.1 Hystrix 简介  . 97
7.2.2 通用方式整合Hystrix  98
7.2.3 Hystrix 断路器的状态监控与深入理解  102
7.2.4 Hystrix 线程隔离策略与传播上下文  103
7.2.5 Feign 使用Hystrix  . 106
7.3 Hystrix 的监控  112
7.4 使用Hystrix Dashboard 可视化监控数据  . 113
7.5 使用Turbine 聚合监控数据  116
7.5.1 Turbine 简介  116
7.5.2 使用Turbine 监控多个微服务  117
7.5.3 使用消息中间件收集数据  119
8 使用Zuul 构建微服务网关  124
8.1 为什么要使用微服务网关  . 124
8.2 Zuul 简介  . 126
8.3 编写Zuul 微服务网关  . 126
8.4 管理端点  . 129
8.4.1 routes 端点  129
8.4.2 filters 端点  131
8.5 路由配置详解  . 132
8.6 Zuul 的安全与Header  . 136
8.6.1 敏感Header 的设置  . 136
8.6.2 忽略Header  . 136
8.7 使用Zuul 上传文件  . 137
8.8 Zuul 的过滤器  140
8.8.1 过滤器类型与请求生命周期  . 140
8.8.2 内置过滤器详解  . 141
8.8.3 编写Zuul 过滤器  144
8.8.4 禁用Zuul 过滤器  146
8.9 Zuul 的容错与回退  146
8.10 饥饿加载  . 149
8.11 Query String 编码  . 150
8.12 Hystrix 隔离策略与线程池  . 150
8.12.1 隔离策略  150
8.12.2 线程池配置  . 151
8.13 Zuul 的高可用  152
8.13.1 Zuul 客户端也注册到了Eureka Server 上  . 152
8.13.2 Zuul 客户端未注册到Eureka Server 上  152
8.14 使用Sidecar 整合非JVM 微服务  . 154
8.14.1 编写Node.js 微服务  . 154
8.14.2 编写Sidecar  . 155
8.14.3 Sidecar 的端点  . 157
8.14.4 Sidecar 与Node.js 微服务分离部署  . 158
8.14.5 Sidecar 原理分析  158
8.15 使用Zuul 聚合微服务  . 160
9 使用Spring Cloud Config 统一管理微服务配置  166
9.1 为什么要统一管理微服务配置  . 166
9.2 Spring Cloud Config 简介  167
9.3 编写Config Server  . 168
9.4 编写Config Client  . 171
9.5 Config Server 的Git 仓库配置详解  . 173
9.5.1 占位符支持  . 173
9.5.2 模式匹配  174
9.5.3 搜索目录  174
9.5.4 启动时加载配置文件  175
9.6 Config Server 的健康状况指示器  . 176
9.7 配置内容的加解密  177
9.7.1 安装JCE  177
9.7.2 Config Server 的加解密端点  177
9.7.3 对称加密  177
9.7.4 存储加密的内容  . 178
9.7.5 非对称加密  . 179
9.8 使用/refresh 端点手动刷新配置  180
9.9 使用Spring Cloud Bus 自动刷新配置  . 181
9.9.1 Spring Cloud Bus 简介  181
9.9.2 实现自动刷新  . 182
9.9.3 局部刷新  183
9.9.4 架构改进  184
9.9.5 跟踪总线事件  . 184
9.10 Spring Cloud Config 与Eureka 配合使用  186
9.11 Spring Cloud Config 的用户认证  . 187
9.12 Config Server 的高可用  188
9.12.1 Git 仓库的高可用  188
9.12.2 RabbitMQ 的高可用  . 189
9.12.3 Config Server 自身的高可用  189
10 使用Spring Cloud Sleuth 实现微服务跟踪  . 191
10.1 为什么要实现微服务跟踪  . 191
10.2 Spring Cloud Sleuth 简介  . 192
10.3 整合Spring Cloud Sleuth  . 194
10.4 Spring Cloud Sleuth 与ELK 配合使用  . 196
10.5 Spring Cloud Sleuth 与Zipkin 配合使用  . 200
10.5.1 Zipkin 简介  . 200
10.5.2 编写Zipkin Server  . 200
10.5.3 微服务整合Zipkin  . 202
10.5.4 Zipkin 与Eureka 配合使用  . 205
10.5.5 使用消息中间件收集数据  206
10.5.6 使用Elasticsearch 存储跟踪数据  209
10.5.7 依赖关系图  . 211
11 Spring Cloud 常见问题与总结  . 213
11.1 Eureka 常见问题  213
11.1.1 Eureka 注册服务慢  213
11.1.2 已停止的微服务节点注销慢或不注销  214
11.1.3 如何自定义微服务的Instance ID  . 215
11.1.4 Eureka 的UNKNOWN 问题总结与解决  217
11.2 整合Hystrix 后首次请求失败  218
11.2.1 原因分析  218
11.2.2 解决方案  218
11.3 Turbine 聚合的数据不完整  219
11.4 Spring Cloud 各组件超时  220
11.4.1 RestTemplate 的超时  . 221
11.4.2 Ribbon 的超时  . 221
11.4.3 Feign 的超时  221
11.4.4 Hystrix 的超时  222
11.4.5 Zuul 的超时  . 222
11.5 Spring Cloud 各组件重试  223
11.5.1 重试步骤  224
11.5.2 基于HTTP 响应码重试  224
11.5.3 关闭重试  224
11.5.4 注意点  224
11.6 Spring Cloud 各组件调优  225
11.6.1 Tomcat 参数  . 225
11.6.2 Hystrix 参数  . 225
11.6.3 Feign 参数  226
11.6.4 Zuul 参数  . 226
11.7 Spring Cloud 各组件配置属性  228
11.7.1 Spring Boot 的配置  228
11.7.2 Spring Cloud 的配置  . 228
11.7.3 原生配置  229
11.8 Spring Cloud 定位问题思路总结  . 229
12 Docker 入门  232
12.1 Docker 简介  232
12.2 版本与迭代计划  232
12.2.1 版本区别  233
12.2.2 迭代计划  233
12.3 Docker 的架构  234
12.4 安装Docker  236
12.4.1 CentOS 7 安装Docker  . 236
12.4.2 Ubuntu 安装Docker  . 239
12.4.3 Windows 安装Docker  244
12.4.4 Mac OS 安装Docker  . 245
12.5 配置镜像加速器  245
12.6 Docker 常用命令  246
12.6.1 Docker 镜像常用命令  246
12.6.2 Docker 容器常用命令  252
13 将微服务运行在Docker 上  260
13.1 使用Dockerfile 构建Docker 镜像  260
13.1.1 Dockerfile 常用指令  . 261
13.1.2 使用Dockerfile 构建镜像  266
13.2 使用Docker Registry 管理Docker 镜像  . 268
13.2.1 使用Docker Hub 管理镜像  . 268
13.2.2 使用私有仓库管理镜像  270
13.3 使用Maven 插件构建Docker 镜像  . 271
13.3.1 快速入门  272
13.3.2 插件读取Dockerfile 进行构建  273
13.3.3 将插件绑定在某个phase 执行  274
13.3.4 推送镜像  275
13.4 常见问题与总结  277
14 使用Docker Compose 编排微服务  . 278
14.1 Docker Compose 简介  . 278
14.2 安装Docker Compose  . 279
14.2.1 安装Compose  . 279
14.2.2 安装Compose 命令补全工具  . 279
14.3 Docker Compose 快速入门  . 280
14.3.1 基本步骤  280
14.3.2 入门示例  280
14.3.3 工程、服务、容器  281
14.4 docker-compose.yml 常用命令  . 281
14.5 docker-compose 常用命令  . 285
14.6 Docker Compose 网络设置  . 286
14.6.1 基本概念  286
14.6.2 更新容器  287
14.6.3 links  287
14.6.4 指定自定义网络  . 288
14.6.5 配置默认网络  . 289
14.6.6 使用已存在的网络  289
14.7 综合实战：使用Docker Comose 编排Spring Cloud 微服务  289
14.7.1 编排Spring Cloud 微服务  289
14.7.2 编排高可用的Eureka Server  293
14.7.3 编排高可用Spring Cloud 微服务集群及动态伸缩  . 295
14.8 常见问题与总结  297
后记  298
附录A：本书配套代码  . 299
附录B：Spring Cloud YES——快速开发脚手架  300
附录C：使用Docker 快速安装本书中的组件  301
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud与Docker微服务架构实战（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务
前言
第一部分　准备篇
第1章　Spring Cloud与微服务概述 2
1.1　传统的单体应用 2
1.1.1　改进单体应用的架构 2
1.1.2　向微服务靠拢 3
1.2　什么是微服务 4
1.2.1　使用微服务架构的优势和劣势 4
1.2.2　重构前的准备工作 5
1.3　什么是Spring Cloud 5
1.3.1　Spring Cloud模块介绍 5
1.3.2　Spring Cloud版本介绍 6
1.4　本章小结 7
第2章　实战前的准备工作 8
2.1　开发环境的准备 8
2.2　Spring Boot入门 9
2.2.1　Spring Boot简介 9
2.2.2　搭建Spring Boot项目 9
2.2.3　编写第一个REST接口 11
2.2.4　读取配置文件 11
2.2.5　profiles多环境配置 13
2.2.6　热部署 13
2.2.7　actuator监控 15
2.2.8　统一异常处理 16
2.2.9　异步执行 18
2.2.10　随机端口 21
2.3　本章小结 23
第二部分　基础篇
第3章　Eureka注册中心 26
3.1　Eureka 26
3.2　使用Eureka编写注册中心服务 27
3.3　编写服务提供者 29
3.3.1　创建项目注册到Eureka 29
3.3.2　编写提供接口 30
3.4　编写服务消费者 31
3.4.1　直接调用接口 31
3.4.2　通过Eureka来消费接口 32
3.5　开启Eureka认证 33
3.6　Eureka高可用搭建 33
3.6.1　高可用原理 33
3.6.2　搭建步骤 34
3.7　常用配置讲解 35
3.7.1　关闭自我保护 35
3.7.2　自定义Eureka的Instance ID 35
3.7.3　自定义实例跳转链接 36
3.7.4　快速移除已经失效的服务信息 37
3.8　扩展使用 38
3.8.1　Eureka REST API 38
3.8.2　元数据使用 40
3.8.3　EurekaClient使用 41
3.8.4　健康检查 43
3.8.5　服务上下线监控 45
3.9　本章小结 46
第4章　客户端负载均衡Ribbon 47
4.1　Ribbon 47
4.1.1　Ribbon模块 47
4.1.2　Ribbon使用 48
4.2　RestTemplate结合Ribbon使用 49
4.2.1　使用RestTemplate与整合Ribbon 49
4.2.2　RestTemplate负载均衡示例 52
4.2.3　@LoadBalanced注解原理 53
4.2.4　Ribbon API使用 57
4.2.5　Ribbon饥饿加载 58
4.3　负载均衡策略介绍 59
4.4　自定义负载策略 60
4.5　配置详解 61
4.5.1　常用配置 61
4.5.2　代码配置Ribbon 62
4.6　重试机制 63
4.7　本章小结 64
第5章　声明式REST客户端Feign 65
5.1　使用Feign调用服务接口 65
5.1.1　在Spring Cloud中集成Feign 66
5.1.2　使用Feign调用接口 66
5.2　自定义Feign的配置 67
5.2.1　日志配置 67
5.2.2　契约配置 69
5.2.3　Basic认证配置 69
5.2.4　超时时间配置 70
5.2.5　客户端组件配置 71
5.2.6　GZIP压缩配置 72
5.2.7　编码器解码器配置 72
5.3　脱离Spring Cloud 使用Feign 73
5.3.1　原生注解方式 73
5.3.2　构建Feign对象 74
5.3.3　其他配置 75
5.4　本章小结 76
第6章　Hystrix 服务容错处理 77
6.1　Hystrix 77
6.1.1　Hystrix的简单使用 77
6.1.2　回退支持 78
6.1.3　信号量策略配置 79
6.1.4　线程隔离策略配置 79
6.1.5　结果缓存 80
6.1.6　缓存清除 81
6.1.7　合并请求 83
6.2　在Spring Cloud中使用Hystrix 84
6.2.1　简单使用 84
6.2.2　配置详解 85
6.2.3　Feign整合Hystrix服务容错 88
6.2.4　Feign中禁用Hystrix 90
6.3　Hystrix监控 91
6.4　整合Dashboard查看监控数据 92
6.5　Turbine聚合集群数据 94
6.5.1　Turbine使用 94
6.5.2　context-path导致监控失败 95
6.6　本章小结 95
第7章　API网关 96
7.1　Zuul 简介 96
7.2　使用Zuul构建微服务网关 97
7.2.1　简单使用 97
7.2.2　集成Eureka 98
7.3　Zuul路由配置 98
7.4　Zuul过滤器讲解 99
7.4.1　过滤器类型 100
7.4.2　请求生命周期 100
7.4.3　使用过滤器 101
7.4.4　过滤器禁用 103
7.4.5　过滤器中传递数据 103
7.4.6　过滤器拦截请求 104
7.4.7　过滤器中异常处理 106
7.5　Zuul容错和回退 108
7.5.1　容错机制 108
7.5.2　回退机制 109
7.6　Zuul高可用 111
7.7　本章小结 111
第三部分　实战篇
第8章　分布式配置管理 114
8.1　自研配置管理框架Smconf简介 114
8.2　Smconf工作原理 115
8.3　Smconf 部署 116
8.3.1　Mongodb安装 116
8.3.2　Zookeeper安装 117
8.3.3　Smconf Server部署 118
8.4　项目中集成Smconf 119
8.4.1　集成Smconf 119
8.4.2　使用Smconf 120
8.4.3　配置更新回调 121
8.5　Smconf详细使用 122
8.5.1　源码编译问题 122
8.5.2　后台账号管理 122
8.5.3　REST API 123
8.6　Smconf源码解析 125
8.6.1　Client启动 125
8.6.2　启动加载配置 127
8.6.3　配置修改推送原理 128
8.7　本章小结 129
第9章　Sleuth服务跟踪 130
9.1　Spring Cloud集成Sleuth 130
9.2　整合Logstash 131
9.2.1　ELK简介 131
9.2.2　输出JSON格式日志 131
9.3　整合Zipkin 133
9.3.1　创建Zipkin数据收集服务 133
9.3.2　项目集成Zipkin发送调用链数据 134
9.3.3　抽样采集数据 135
9.3.4　用RabbitMq代替Http发送调用链数据 135
9.3.5　用Elasticsearch存储调用链数据 136
9.4　本章小结 137
第10章　微服务之间调用的安全认证 138
10.1　什么是JWT 138
10.2　创建统一的认证服务 139
10.2.1　表结构 139
10.2.2　JWT工具类封装 139
10.2.3　认证接口 141
10.3　服务提供方进行调用认证 142
10.4　服务消费方申请Token 143
10.5　Feign调用前统一申请Token传递到调用的服务中 145
10.6　Zuul中传递Token到路由的服务中 147
10.7　本章小结 148
第11章　Spring Boot Admin 149
11.1　Spring Boot Admin的使用方法 149
11.1.1　创建Spring Boot Admin项目 149
11.1.2　将服务注册到Spring Boot Admin 150
11.1.3　如何在Admin中查看各个服务的日志 151
11.2　开启认证 152
11.3　集成Eureka 153
11.4　集成Turbine 154
11.5　监控服务 155
11.5.1　邮件警报 156
11.5.2　自定义钉钉警报 156
11.6　本章小结 159
第12章　服务的API文档管理 160
12.1　Swagger简介 160
12.2　集成Swagger管理API文档 161
12.2.1　封装Swagger Starter 161
12.2.2　在项目中集成Swagger starter 162
12.2.3　使用Swagger生成文档 162
12.2.4　在线测试接口 163
12.3　Swagger注解 164
12.4　Eureka 控制台快速查看Swagger文档 169
12.5　本章小结 169
第四部分　高级篇
第13章　API网关扩展 172
13.1　用户认证 172
13.1.1　动态管理不需要拦截的API请求 172
13.1.2　创建认证的用户服务 174
13.1.3　路由之前的认证 175
13.1.4　向下游微服务中传递认证之后的用户信息 176
13.1.5　内部服务间的用户信息传递 177
13.2　服务限流 179
13.2.1　限流算法 179
13.2.2　单节点限流 179
13.2.3　集群限流 184
13.2.4　具体服务限流 187
13.2.5　具体接口限流 188
13.3　服务降级 194
13.4　灰度发布 196
13.4.1　原理讲解 196
13.4.2　根据用户做灰度发布 197
13.4.3　根据IP做灰度发布 200
13.5　本章小结 200
第14章　微服务之缓存 201
14.1　Guava Cache本地缓存 201
14.1.1　Guava Cache简介 201
14.1.2　代码示例 202
14.1.3　回收策略 202
14.2　Redis缓存 203
14.2.1　用Redistemplate 操作Redis 203
14.2.2　用Repository操作Redis 204
14.2.3　Spring Cache 缓存数据 206
14.2.4　扩展Spring Cache支持对每个缓存的时间配置 211
14.2.5　缓存异常处理 212
14.2.6　自定义缓存工具类 214
14.3　防止缓存穿透方案 216
14.3.1　什么是缓存穿透 216
14.3.2　缓存穿透的危害 216
14.3.3　解决方案 217
14.3.4　布隆过滤器介绍 217
14.3.5　代码示例 217
14.4　防止缓存雪崩方案 219
14.4.1　什么是缓存雪崩 219
14.4.2　缓存雪崩的危害 219
14.4.3　解决方案 219
14.4.4　代码示例 219
14.4.5　分布式锁方式 220
14.5　本章小结 221
第15章　微服务之存储 222
15.1　存储选型 222
15.2　Mongodb 223
15.2.1　集成Spring Data Mongodb 223
15.2.2　添加数据操作 223
15.2.3　索引使用 225
15.2.4　修改数据操作 227
15.2.5　删除数据操作 228
15.2.6　查询数据操作 229
15.2.7　GridFS操作 231
15.2.8　用Repository方式操作数据 232
15.2.9　自增ID实现 236
15.2.10　批量更新扩展 239
15.3　Mysql 243
15.3.1　集成Spring JdbcTemplate 243
15.3.2　JdbcTemplate代码示例 243
15.3.3　封装JdbcTemplate 操作Mysql更简单 244
15.3.4　扩展JdbcTemplate使用方式 244
15.3.5　常见问题 248
15.4　Elasticsearch 251
15.4.1　集成Spring Data Elasticsearch 251
15.4.2　Repository示例 251
15.4.3　ElasticsearchTemplate示例 254
15.4.4　索引构建方式 257
15.5　本章小结 259
第16章　微服务之分布式事物解决方案 260
16.1　两阶段型 260
16.2　TCC补偿型 261
16.3　最终一致性 261
16.3.1　原理讲解 261
16.3.2　创建可靠性消息服务 263
16.3.3　消息存储表设计 264
16.3.4　提供服务接口 265
16.3.5　创建消息发送系统 269
16.3.6　消费消息逻辑 273
16.3.7　消息管理系统 275
16.4　最大努力通知型事物 276
16.4.1　介绍 276
16.4.2　原理 276
16.5　本章小结 276
第17章　分布式任务调度 277
17.1　Elastic-Job 277
17.1.1　Elastic-Job介绍 277
17.1.2　任务调度目前存在的问题 277
17.1.3　为什么选择Elastic-Job 278
17.2　快速集成 279
17.3　任务使用 280
17.3.1　简单任务 280
17.3.2　数据流任务 281
17.3.3　脚本任务 282
17.4　配置参数讲解 282
17.4.1　注册中心配置 283
17.4.2　作业配置 283
17.4.3　dataflow独有配置 284
17.4.4　script独有配置 284
17.5　多节点并行调度 285
17.5.1　分片概念 285
17.5.2　任务节点分片策略 285
17.5.3　业务数据分片处理 286
17.6　事件追踪 289
17.7　扩展功能 290
17.7.1　自定义监听器 290
17.7.2　定义异常处理 291
17.8　运维平台 291
17.8.1　功能列表 292
17.8.2　部署运维平台 292
17.8.3　运维平台使用 293
17.9　使用经验分享 296
17.9.1　任务的划分和监控 296
17.9.2　任务的扩展性和节点数量 297
17.9.3　任务的重复执行 297
17.9.4　overwrite覆盖问题 298
17.9.5　流水式任务 298
17.10　本章小结 299
第18章　分库分表解决方案 300
18.1　Sharding-JDBC 300
18.1.1　介绍 300
18.1.2　功能列表 301
18.1.3　相关概念 301
18.2　快速集成 302
18.3　读写分离实战 304
18.3.1　准备数据 304
18.3.2　配置读写分离 304
18.3.3　验证读从库 305
18.3.4　验证写主库 307
18.3.5　Hint强制路由主库 308
18.4　分库分表实战 309
18.4.1　常用分片算法 310
18.4.2　使用分片算法 310
18.4.3　不分库只分表实战 311
18.4.4　既分库又分表实战 314
18.5　分布式主键 317
18.6　本章小结 319
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Spring Cloud与微服务构建 第2版
第 1章 微服务简介1
1．1 单体架构及其存在的不足 1
1．1．1 单体架构简介 1
1．1．2 单体架构存在的不足 2
1．1．3 单体架构使用服务器集群及存在的不足 2
1．2 微服务 3
1．2．1 什么是微服务 4
1．2．2 微服务的优势 8
1．3 微服务的不足 9
1．3．1 微服务的复杂度 9
1．3．2 分布式事务 9
1．3．3 服务的划分 11
1．3．4 服务的部署 11
1．4 微服务和SOA的关系 12
1．5 微服务的设计原则 12
第 2章 Spring Cloud简介 14
2．1 微服务应该具备的功能 14
2．1．1 服务的注册与发现 15
2．1．2 服务的负载均衡 15
2．1．3 服务的容错 16
2．1．4 服务网关 18
2．1．5 服务配置的统一管理 19
2．1．6 服务链路追踪 20
2．2 Spring Cloud 20
2．2．1 简介 20
2．2．2 常用组件 21
2．2．3 项目一览 22
2．3 Dubbo简介 23
2．4 Spring Cloud与Dubbo比较 24
2．5 Kubernetes简介 25
2．6 Spring Could与Kubernetes比较 27
2．7 总结 28
第3章 构建微服务的准备 29
3．1 JDK的安装 29
3．1．1 JDK的下载和安装 29
3．1．2 环境变量的配置 29
3．2 IDEA的安装 30
3．2．1 IDEA的下载 30
3．2．2 用IDEA创建一个Spring Boot工程 31
3．2．3 用IDEA启动多个Spring Boot工程实例 33
3．3 构建工具Maven的使用 34
3．3．1 Maven简介 34
3．3．2 Maven的安装 34
3．3．3 Maven的核心概念 36
3．3．4 编写Pom文件 36
3．3．5 Maven构建项目的生命周期 38
3．3．6 常用的Maven命令 39
第4章 开发框架Spring Boot 41
4．1 Spring Boot简介 41
4．1．1 Spring Boot的特点 41
4．1．2 Spring Boot的优点 42
4．2 用IDEA构建Spring Boot工程 42
4．2．1 项目结构 42
4．2．2 在Spring Boot工程中构建Web程序 43
4．2．3 Spring Boot的测试 44
4．3 Spring Boot配置文件详解 45
4．3．1 自定义属性 45
4．3．2 将配置文件的属性赋给实体类 46
4．3．3 自定义配置文件 47
4．3．4 多个环境的配置文件 48
4．4 运行状态监控Actuator 48
4．4．1 查看运行程序的健康状态 50
4．4．2 查看运行程序的Bean 51
4．4．3 使用Actuator关闭应用程序 53
4．4．4 使用shell连接Actuator 54
4．5 Spring Boot整合JPA 55
4．6 Spring Boot整合Redis 58
4．6．1 Redis简介 58
4．6．2 Redis的安装 58
4．6．3 在Spring Boot中使用Redis 58
4．7 Spring Boot整合Swagger2，搭建Restful API在线文档 60
第5章 服务注册和发现Eureka 64
5．1 Eureka简介 64
5．1．1 什么是Eureka 64
5．1．2 为什么选择Eureka 64
5．1．3 Eureka的基本架构 65
5．2 编写Eureka Server 65
5．3 编写Eureka Client 68
5．4 源码解析Eureka 71
5．4．1 Eureka的一些概念 71
5．4．2 Eureka的高可用架构 72
5．4．3 Register服务注册 72
5．4．4 Renew服务续约 76
5．4．5 为什么Eureka Client获取服务实例这么慢 77
5．4．6 Eureka 的自我保护模式 78
5．5 构建高可用的Eureka Server集群 79
5．6 总结 81
第6章 负载均衡Ribbon 82
6．1 RestTemplate简介 82
6．2 Ribbon简介 83
6．3 使用RestTemplate和Ribbon来消费服务 83
6．4 LoadBalancerClient简介 86
6．5 源码解析Ribbon 88
第7章 声明式调用Feign 99
7．1 写一个Feign客户端 99
7．2 FeignClient详解 103
7．3 FeignClient的配置 104
7．4 从源码的角度讲解Feign的工作原理 105
7．5 在Feign中使用HttpClient和OkHttp 108
7．6 Feign是如何实现负载均衡的 110
7．7 总结 112
第8章 熔断器Hystrix 113
8．1 Hystrix简介 113
8．2 Hystrix解决的问题 113
8．3 Hystrix的设计原则 115
8．4 Hystrix的工作机制 115
8．5 在RestTemplate和Ribbon上使用熔断器 116
8．6 在Feign上使用熔断器 117
8．7 使用Hystrix Dashboard监控熔断器的状态 118
8．7．1 在RestTemplate中使用Hystrix Dashboard 118
8．7．2 在Feign中使用Hystrix Dashboard 121
8．8 使用Turbine聚合监控 122
第9章 路由网关Spring Cloud Zuul 124
9．1 为什么需要Zuul 124
9．2 Zuul的工作原理 124
9．3 案例实战 126
9．3．1 搭建Zuul服务 126
9．3．2 在Zuul上配置API接口的版本号 129
9．3．3 在Zuul上配置熔断器 130
9．3．4 在Zuul中使用过滤器 131
9．3．5 Zuul的常见使用方式 133
第 10章 服务网关 135
10．1 服务网关的实现原理 135
10．2 断言工厂 136
10．2．1 After路由断言工厂 136
10．2．2 Header断言工厂 138
10．2．3 Cookie路由断言工厂 139
10．2．4 Host路由断言工厂 140
10．2．5 Method路由断言工厂 140
10．2．6 Path 路由断言工厂 141
10．2．7 Query 路由断言工厂 141
10．3 过滤器 142
10．3．1 过滤器的作用 143
10．3．2 过滤器的生命周期 144
10．3．3 网关过滤器 144
10．3．4 全局过滤器 151
10．4 限流 153
10．4．1 常见的限流算法 153
10．4．2 服务网关的限流 154
10．5 服务化 156
10．5．1 工程介绍 156
10．5．2 service-gateway工程详细介绍 157
10．6 总结 159
第 11章 服务注册和发现Consul 160
11．1 什么是Consul 160
11．1．1 基本术语 160
11．1．2 Consul的特点和功能 161
11．1．3 Consul的原理 161
11．1．4 Consul的基本架构 161
11．1．5 Consul服务注册发现流程 163
11．2 Consul与Eureka比较 163
11．3 下载和安装Consul 164
11．4 使用Spring Cloud Consul进行服务注册和发现 165
11．4．1 服务提供者consul-provider 165
11．4．2 服务消费者consul-provider 167
11．5 使用Spring Cloud Consul Config做服务配置中心 168
11．6 动态刷新配置 170
11．7 总结 171
第 12章 配置中心Spring Cloud Config 172
12．1 Config Server从本地读取配置文件 172
12．1．1 构建Config Server 172
12．1．2 构建Config Client 174
12．2 Config Server从远程Git仓库读取配置文件 175
12．3 构建高可用的Config Server 176
12．3．1 构建Eureka Server 177
12．3．2 改造Config Server 178
12．3．3 改造Config Client 178
12．4 使用Spring Cloud Bus刷新配置 180
12．5 将配置存储在MySQL数据库中 182
12．5．1 改造config-server工程 182
12．5．2 初始化数据库 183
第 13章 服务链路追踪Spring Cloud Sleuth 184
13．1 为什么需要Spring Cloud Sleuth 184
13．2 基本术语 184
13．3 案例讲解 186
13．3．1 启动Zipkin Server 187
13．3．2 构建服务提供者 187
13．3．3 构建服务消费者 189
13．3．4 项目演示 191
13．4 在链路数据中添加自定义数据 192
13．5 使用RabbitMQ 传输链路数据 192
13．6 在MySQL数据库中存储链路数据 194
13．7 在ElasticSearch中存储链路数据 195
13．8 用Kibana展示链路数据 196
第 14章 微服务监控Spring Boot Admin 198
14．1 使用Spring Boot Admin监控Spring Boot应用程序 199
14．1．1 创建Spring Boot Admin Server 199
14．1．2 创建Spring Boot Admin Client 200
14．2 使用Spring Boot Admin监控Spring Cloud微服务 202
14．2．1 构建Admin Server 202
14．2．2 构建Admin Client 204
14．3 在Spring Boot Admin中添加Security和Mail组件 205
14．3．1 Spring Boot Admin集成Security组件 206
14．3．2 Spring Boot Admin集成Mail组件 208
第 15章 Spring Boot Security详解 209
15．1 Spring Security简介 209
15．1．1 什么是Spring Security 209
15．1．2 为什么选择Spring Security 209
15．1．3 Spring Security提供的安全模块 210
15．2 Spring Boot Security与Spring Security的关系 211
15．3 Spring Boot Security案例详解 211
15．3．1 构建Spring Boot Security工程 211
15．3．2 配置Spring Security 213
15．3．3 编写相关界面 215
15．3．4 Spring Security方法级别上的保护 220
15．3．5 从数据库中读取用户的认证信息 223
15．4 总结 228
第 16章 使用Spring Cloud OAuth2保护微服务系统 230
16．1 什么是OAuth2 230
16．2 如何使用Spring OAuth2 231
16．2．1 OAuth2 Provider 231
16．2．2 OAuth2 Client 235
16．3 案例分析 236
16．3．1 编写Eureka Server 237
16．3．2 编写Uaa授权服务 237
16．3．3 编写service-hi资源服务 244
16．4 总结 250
第 17章 使用Spring Security OAuth2和JWT保护微服务系统 251
17．1 JWT简介 251
17．1．1 什么是JWT 251
17．1．2 JWT的结构 252
17．1．3 JWT的应用场景 253
17．1．4 如何使用JWT 253
17．2 案例分析 253
17．2．1 案例架构设计 253
17．2．2 编写主Maven工程 254
17．2．3 编写Eureka Server 256
17．2．4 编写Uaa授权服务 256
17．2．5 编写user-service资源服务 262
17．3 总结 270
第 18章 使用Spring Cloud构建微服务综合案例 271
18．1 案例介绍 271
18．1．1 工程结构 271
18．1．2 使用的技术栈 271
18．1．3 工程架构 272
18．1．4 功能展示 274
18．2 案例详解 277
18．2．1 准备工作 278
18．2．2 构建主Maven工程 278
18．2．3 构建eureka-server工程 279
18．2．4 构建config-server工程 280
18．2．5 构建Zipkin工程 281
18．2．6 构建monitoring-service工程 282
18．2．7 构建uaa-service工程 284
18．2．8 构建gateway-service工程 286
18．2．9 构建admin-service工程 287
18．2．10 构建user-service工程 287
18．2．11 构建blog-service工程 290
18．2．12 构建log-service工程 291
18．3 启动源码工程 294
18．4 项目演示 295
18．5 总结 296
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Spring Cloud与微服务构建 第2版
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务架构基础:Spring Boot+Spring Cloud+Docker
第1章认识微服务架构1
1.1 为什么需要微服务架构 2
1.1.1 传统单体应用架构的问题 2
1.1.2 如何解决传统应用架构的问题 3
1.2 微服务架构是什么 4
1.2.1 微服务架构的概念 4
1.2.2 微服务架构的优点 5
1.2.3 微服务架构的不足 6
1.2.4 微服务架构与SOA的区别 6
1.3 如何构建微服务架构 6
1.3.1 微服务的拆分 7
1.3.2 微服务架构的组件 7
1.3.3 微服务架构的搭建 7
1.3.4 微服务架构的技术选型 8
1.4 本章小结 10
第2章 初识Spring Boot 11
2.1 Spring Boot介绍 12
2.1.1 Spring Boot的由来和特点 12
2.1.2 Spring Boot的使用要求 12
2.2 Spring Boot入门 13
2.2.1 Spring Boot项目的快速搭建 13
2.2.2 第一个Spring Boot程序 18
2.3 Spring Boot的工作机制 20
2.3.1 @Spring BootApplication 20
2.3.2 Spring Application 21
2.4 本章小结 22
第3章 Spring Boot应用开发 23
3.1 Spring Boot与MyBatis的集成 24
3.2 Spring Boot与Redis的集成 29
3.2.1 添加Redis缓存 29
3.2.2 清除Redis缓存 31
3.3 Spring Boot与ActiveMQ的集成 31
3.3.1 使用内嵌的ActiveMQ 31
3.3.2 使用外部的ActiveMQ 33
3.4 Spring Boot应用的打包和部署 35
3.4.1 JAR包 35
3.4.2 WAR包 36
3.5 本章小结 37
第4章 Spring Cloud（上） 38
4.1 Spring Cloud简介 39
4.1.1 什么是Spring Cloud 39
4.1.2 Spring Cloud的特点 39
4.1.3 Spring Cloud的版本 39
4.2 服务发现 40
4.2.1 Eureka介绍 40
4.2.2 如何使用Eureka注册服务 41
4.2.3 如何实现服务间的调用 47
4.3 客户端负载均衡 50
4.3.1 Ribbon介绍 50
4.3.2 Ribbon的使用 51
4.4 本章小结 53
第5章 Spring Cloud（下） 54
5.1 服务容错保护 55
5.1.1 Spring Cloud Hystrix介绍 55
5.1.2 Spring Cloud Hystrix的使用 56
5.1.3 HystrixDashboard的使用 59
5.2 API网关服务 63
5.2.1 为什么需要API网关 63
5.2.2 如何使用Zuul构建API网关服务 64
5.3 分布式配置管理 68
5.3.1 Spring Cloud Config简介 68
5.3.2 使用本地存储的方式实现配置管理 69
5.3.3 使用Git存储的方式实现配置管理 73
5.4 本章小结 76
第6章 初识Docker 77
6.1 Docker概述 78
6.1.1 什么是Docker 78
6.1.2 Docker的特点 78
6.1.3 Docker与虚拟机的区别 79
6.2 Docker的安装要求 79
6.3 Docker的安装方式 80
6.3.1 在线安装 80
6.3.2 离线安装 82
6.3.3 脚本文件安装 83
6.3.4 安装时的问题及解决方法 84
6.4 Docker的运行机制 85
6.4.1 Docker的引擎 85
6.4.2 Docker的架构 85
6.5 Docker的底层技术 87
6.6 本章小结 87
第7章 Docker的使用 88
7.1 Docker入门程序 89
7.2 Dockerfile介绍 92
7.2.1 Dockerfile基本结构 92
7.2.2 Dockerfile常用指令 93
7.2.3 dockerignore文件 95
7.3 Docker客户端常用指令 96
7.3.1 Docker常用操作指令 96
7.3.2 Docker管理指令 101
7.4 Docker镜像管理 102
7.4.1 Docker镜像管理工具 102
7.4.2 Docker Hub远程镜像管理 103
7.4.3 Docker Registry本地私有仓库搭建 106
7.4.4 Docker Registry本地私有仓库配置 107
7.5 本章小结 112
第8章 Docker中的网络与数据管理 113
8.1 Docker网络管理 114
8.1.1 Docker默认网络管理 114
8.1.2 自定义网络介绍 115
8.1.3 自定义bridge网络 116
8.1.4 容器之间的网络通信 118
8.2 Docker Swarm集群 122
8.2.1 Docker Swarm概述 122
8.2.2 Docker Swarm使用 123
8.3 Docker数据管理 127
8.3.1 Docker数据存储机制 127
8.3.2 Docker数据存储方式 129
8.4 Volumes数据卷管理 129
8.4.1 Volumes数据卷的优势 129
8.4.2 Volumes数据卷使用 130
8.5 本章小结 134
第9章 微服务项目的整合与测试 135
9.1 微服务项目整合 136
9.1.1 微服务项目结构预览 136
9.1.2 微服务项目功能介绍 136
9.1.3 微服务项目的启动和测试 140
9.2 接口可视化工具—Swagger—UI 143
9.2.1 Swagger—UI使用方法 143
9.2.2 Swagger—UI使用测试 145
9.3 本章小结 147
第10章 微服务的部署 149
10.1 Docker Compose编排工具 150
10.1.1 Docker Compose介绍 150
10.1.2 Docker Compose的安装与卸载 150
10.1.3 Composefile文件的使用说明 151
10.2 微服务与Docker的整合 154
10.3 环境搭建以及镜像准备 159
10.3.1 环境搭建 159
10.3.2 镜像准备 161
10.4 微服务的手动部署 162
10.4.1 非集群环境下的服务部署 162
10.4.2 集群环境下服务部署 163
10.4.3 微服务测试 167
10.5 使用Jenkins自动部署微服务 169
10.5.1 Jenkins介绍 169
10.5.2 Jenkins安装 170
10.5.3 Jenkins集成插件配置 173
10.5.4 服务自动化部署 175
10.6 本章小结 180
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务架构基础:Spring Boot+Spring Cloud+Docker
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>疯狂Spring Cloud微服务架构实战
第1章　Spring Cloud概述	1
1.1　传统的应用	2
1.1.1　单体应用	2
1.1.2　架构演进	3
1.1.3　架构要求	4
1.2　微服务与Spring Cloud	5
1.2.1　什么是微服务	5
1.2.2　关于Netflix OSS	6
1.2.3　Spring Cloud与Netflix	6
1.2.4　Spring Cloud的主要模块	6
1.3　学习方面的准备工作	7
1.3.1　下载本书的软件及源码	7
1.3.2　导入本书的案例	7
1.4　本章小结	8
第2章　搭建开发环境	9
2.1　安装与配置Maven	10
2.1.1　关于Maven	10
2.1.2　下载与安装Maven	11
2.1.3　配置远程仓库	11
2.2　安装Eclipse	12
2.2.1　Eclipse版本	12
2.2.2　在Eclipse中配置Maven	12
2.3　Spring Boot	13
2.3.1　Spring Boot简介	13
2.3.2　新建Maven项目	14
2.3.3　编写启动类	15
2.3.4　编写控制器	16
2.3.5　发布REST WebService	17
2.4　Spring Boot配置文件	18
2.4.1　默认配置文件	18
2.4.2　指定配置文件位置	19
2.4.3　yml文件	19
2.4.4　运行时指定profiles配置	20
2.4.5　热部署	20
2.5　Spring Cloud的版本	21
2.6　本章小结	21
第3章　微服务发布与调用	22
3.1　Eureka介绍	23
3.1.1　关于Eureka	23
3.1.2　Eureka架构	23
3.1.3　服务器端	24
3.1.4　服务提供者	24
3.1.5　服务调用者	24
3.2　第一个Eureka应用	24
3.2.1　构建服务器	24
3.2.2　服务器注册开关	27
3.2.3　编写服务提供者	27
3.2.4　编写服务调用者	29
3.2.5　程序结构	32
3.3　Eureka集群搭建	33
3.3.1　本例集群结构图	33
3.3.2　改造服务器端	34
3.3.3　改造服务提供者	35
3.3.4　改造服务调用者	37
3.3.5　编写REST客户端进行测试	37
3.4　服务实例的健康自检	38
3.4.1　程序结构	39
3.4.2　使用Spring Boot Actuator	39
3.4.3　实现应用健康自检	39
3.4.4　服务查询	42
3.5　Eureka的常用配置	44
3.5.1　心跳检测配置	44
3.5.2　注册表抓取间隔	44
3.5.3　配置与使用元数据	45
3.5.4　自我保护模式	45
3.6　本章小结	46
第4章　负载均衡	47
4.1　Ribbon介绍	48
4.1.1　Ribbon简介	48
4.1.2　Ribbon子模块	48
4.1.3　负载均衡器组件	48
4.2　第一个Ribbon程序	49
4.2.1　编写服务	49
4.2.2　编写请求客户端	51
4.2.3　Ribbon的配置	52
4.3　Ribbon的负载均衡机制	53
4.3.1　负载均衡器	53
4.3.2　自定义负载规则	54
4.3.3　Ribbon自带的负载规则	56
4.3.4　Ping机制	57
4.3.5　自定义Ping	59
4.3.6　其他配置	59
4.4　在Spring Cloud中使用Ribbon	60
4.4.1　准备工作	60
4.4.2　使用代码配置Ribbon	61
4.4.3　使用配置文件设置Ribbon	63
4.4.4　Spring使用Ribbon的API	64
4.5　RestTemplate负载均衡	66
4.5.1　@LoadBalanced注解概述	66
4.5.2　编写自定义注解以及拦截器	66
4.5.3　使用自定义拦截器以及注解	68
4.5.4　在控制器中使用RestTemplate	69
4.6　本章小结	71
第5章　REST客户端Feign	72
5.1　REST客户端	73
5.1.1　使用CXF调用REST服务	73
5.1.2　使用Restlet调用REST服务	74
5.1.3　Feign框架介绍	75
5.1.4　第一个Feign程序	76
5.1.5　请求参数与返回对象	77
5.2　使用Feign	78
5.2.1　编码器	79
5.2.2　解码器	80
5.2.3　XML的编码与解码	80
5.2.4　自定义编码器与解码器	83
5.2.5　自定义Feign客户端	83
5.2.6　使用第三方注解	85
5.2.7　Feign解析第三方注解	86
5.2.8　请求拦截器	89
5.2.9　接口日志	89
5.3　在Spring Cloud中使用Feign	90
5.3.1　Spring Cloud整合Feign	91
5.3.2　Feign负载均衡	93
5.3.3　默认配置	93
5.3.4　自定义配置	94
5.3.5　可选配置	97
5.3.6　压缩配置	98
5.4　本章小结	98
第6章　Spring Cloud的保护机制	99
6.1　概述	100
6.1.1　实际问题	100
6.1.2　传统的解决方式	101
6.1.3　集群容错框架Hystrix	101
6.1.4　Hystrix的功能	102
6.2　第一个Hystrix程序	103
6.2.1　准备工作	103
6.2.2　客户端使用Hystrix	103
6.2.3　调用错误服务	105
6.2.4　Hystrix的运作流程	106
6.3　Hystrix的使用	108
6.3.1　命令执行	108
6.3.2　属性配置	110
6.3.3　回退	111
6.3.4　回退的模式	112
6.3.5　断路器开启	113
6.3.6　断路器关闭	116
6.3.7　隔离机制	118
6.3.8　合并请求	121
6.3.9　请求缓存	125
6.4　在Spring Cloud中使用Hystrix	127
6.4.1　整合Hystrix	128
6.4.2　命令配置	130
6.4.3　默认配置	131
6.4.4　缓存注解	132
6.4.5　合并请求注解	134
6.4.6　Feign与Hystrix整合	136
6.4.7　Hystrix监控	140
6.5　本章小结	142
第7章　微服务集群网关	143
7.1　Zuul框架介绍	144
7.1.1　关于Zuul	144
7.1.2　Zuul的功能	144
7.2　在Web项目中使用Zuul	145
7.2.1　Web项目整合Zuul	145
7.2.2　测试路由功能	145
7.2.3　过滤器运行机制	147
7.3　在微服务集群中初试Zuul	148
7.3.1　集群搭建	149
7.3.2　路由到集群服务	150
7.3.3　Zuul Http客户端	153
7.4　路由配置	153
7.4.1　简单路由	154
7.4.2　跳转路由	155
7.4.3　Ribbon路由	155
7.4.4　自定义路由规则	156
7.4.5　忽略路由	157
7.5　Zuul的其他配置	157
7.5.1　请求头配置	157
7.5.2　路由端点	158
7.5.3　Zuul与Hystrix	158
7.5.4　在Zuul中预加载Ribbon	161
7.6　Zuul功能进阶	161
7.6.1　过滤器优先级	161
7.6.2　自定义过滤器	162
7.6.3　动态加载过滤器	163
7.6.4　禁用过滤器	165
7.6.5　请求上下文	166
7.6.6　@EnableZuulServer注解	168
7.6.7　error过滤器	169
7.6.8　动态路由	171
7.7　本章小结	172
第8章　微服务与消息驱动	173
8.1　Spring Cloud Stream介绍	174
8.1.1　关于Stream框架	174
8.1.2　Stream框架的组成部分	174
8.1.3　消息代理中间件	174
8.2　RabbitMQ框架	175
8.2.1　RabbitMQ和AMQP	175
8.2.2　下载与运行	176
8.2.3　编写生产者	177
8.2.4　编写消费者	179
8.2.5　交换器、绑定与队列	180
8.3　Apache Kafka框架	181
8.3.1　关于Kafka	181
8.3.2　运行Kafka服务器	182
8.3.3　编写生产者	182
8.3.4　编写消费者	184
8.3.5　消费者组	185
8.4　开发消息微服务	185
8.4.1　准备工作	186
8.4.2　编写生产者	187
8.4.3　编写消费者	188
8.4.4　更换绑定器	189
8.4.5　Sink、Source与Processor	190
8.4.6　消费者组	191
8.5　本章小结	192
第9章　集群配置中心	193
9.1　概述	194
9.1.1　关于Spring Cloud Config	194
9.1.2　应用结构	195
9.1.3　引导程序简介	195
9.1.4　搭建SVN环境	196
9.2　构建第一个例子	196
9.2.1　创建服务器	196
9.2.2　配置SVN仓库	197
9.2.3　创建客户端	199
9.2.4　从客户端读取SVN配置	200
9.2.5　目录配置总结	201
9.2.6　刷新配置	202
9.2.7　刷新Bean	203
9.3　配置的加密和解密	205
9.3.1　为服务器安装JCE	205
9.3.2　加密和解密端点	205
9.3.3　SVN存储加密数据	206
9.3.4　非对称加密	207
9.4　其他配置	207
9.4.1　服务器健康指示器	207
9.4.2　客户端的错误提前与重试机制	208
9.4.3　安全配置	209
9.4.4　访问服务器配置	210
9.5　整合使用	210
9.5.1　准备工作	210
9.5.2　配置服务器、客户端整合Eureka	212
9.5.3　整合Zuul	214
9.5.4　整合Spring Cloud Bus刷新配置	216
9.5.5　刷新单个节点配置	217
9.6　本章小结	217
第10章　微服务跟踪	219
10.1　概述	220
10.1.1　实际问题与Sleuth	220
10.1.2　服务跟踪系统	220
10.1.3　Sleuth的基本概念	220
10.1.4　项目准备	221
10.2　Sleuth整合Zipkin	222
10.2.1　Zipkin简介	222
10.2.2　构建Zipkin服务器项目	223
10.2.3　配置微服务	224
10.2.4　查看数据	225
10.2.5　使用MySQL保存数据	228
10.2.6　使用消息采集数据	230
10.3　Sleuth整合ELK	232
10.3.1　关于ELK	232
10.3.2　下载ELK	233
10.3.3　运行Elasticsearch	233
10.3.4　使用Logstash读取JSON	234
10.3.5　使用Kibana展示数据	235
10.3.6　使用Logback转换JSON	237
10.4　本章小结	240
第11章　微服务数据库实战	241
11.1　概述	242
11.1.1　关于Spring Data	242
11.1.2　Spring Data的功能	243
11.1.3　Spring Data的模块	243
11.2　Spring Data与JPA	243
11.2.1　构建项目	244
11.2.2　数据访问层与业务层	245
11.2.3　自定义数据存储逻辑	247
11.2.4　方法名查询	248
11.2.5　使用@Query注解	249
11.3　Spring Data与MongoDB	250
11.3.1　安装MongoDB	250
11.3.2　配置权限	251
11.3.3　MongoDB的概念	252
11.3.4　构建项目	252
11.3.5　数据访问层与业务层	253
11.3.6　自定义数据存储逻辑	254
11.3.7　方法名查询	256
11.3.8　使用@Query注解	258
11.4　Spring Data与Redis	258
11.4.1　Redis的安装与配置	258
11.4.2　Redis的数据类型	259
11.4.3　使用Jedis	260
11.4.4　构建Spring Data项目	262
11.4.5　数据访问层与业务层	263
11.4.6　自定义数据存储逻辑	265
11.4.7　方法名查询	267
11.5　本章小结	268
第12章　案例实战	269
12.1　概述	270
12.1.1　表现层技术	270
12.1.2　案例概述	270
12.1.3　案例技术选型	270
12.2　Spring Boot与JSP	271
12.2.1　构建项目	271
12.2.2　配置	272
12.2.3　打包部署	273
12.3　模板引擎Thymeleaf	274
12.3.1　关于Thymeleaf	274
12.3.2　Spring Boot整合Thymeleaf	274
12.3.3　加载资源	275
12.3.4　获取请求数据	276
12.3.5　调用Bean方法	276
12.3.6　遍历集合	277
12.3.7　表单提交	277
12.4　图书管理案例	278
12.4.1　运行案例	278
12.4.2　案例模块	279
12.4.3　案例架构	279
12.4.4　数据库	280
12.4.5　用户登录	280
12.4.6　新建图书	284
12.4.7　图书展示	286
12.5　本章小结	287
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>疯狂Spring Cloud微服务架构实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Spring Cloud与微服务构建
第1章　微服务简介 1
1.1　单体架构及其存在的不足 1
1.1.1　单体架构简介 1
1.1.2　单体架构存在的不足 2
1.1.3　单体架构使用服务器集群
及存在的不足 2
1.2　微服务 3
1.2.1　什么是微服务 4
1.2.2　微服务的优势 8
1.3　微服务的不足 9
1.3.1　微服务的复杂度 9
1.3.2　分布式事务 9
1.3.3　服务的划分 11
1.3.4　服务的部署 11
1.4　微服务和SOA的关系 12
1.5　微服务的设计原则 12
第2章　Spring Cloud简介 14
2.1　微服务应该具备的功能 14
2.1.1　服务的注册与发现 15
2.1.2　服务的负载均衡 15
2.1.3　服务的容错 17
2.1.4　服务网关 18
2.1.5　服务配置的统一管理 19
2.1.6　服务链路追踪 20
2.2　Spring Cloud 21
2.2.1　简介 21
2.2.2　常用组件 21
2.2.3　项目一览表 23
2.3　Dubbo简介 24
2.4　Spring Cloud与Dubbo比较 25
2.5　Kubernetes简介 26
2.6　Spring Could与Kubernetes比较 27
2.7　总结 29
第3章　构建微服务的准备 30
3.1　JDK的安装 30
3.1.1　JDK的下载和安装 30
3.1.2　环境变量的配置 30
3.2　IDEA的安装 31
3.2.1　IDEA的下载 31
3.2.2　用IDEA创建一个Spring Boot
工程 32
3.2.3　用IDEA启动多个Spring Boot
工程实例 34
3.3　构建工具Maven的使用 35
3.3.1　Maven简介 35
3.3.2　Maven的安装 35
3.3.3　Maven的核心概念 37
3.3.4　编写Pom文件 37
3.3.5　Maven构建项目的生命周期 39
3.3.6　常用的Maven命令 40
第4章　开发框架Spring Boot 43
4.1　Spring Boot简介 43
4.1.1　Spring Boot的特点 43
4.1.2　Spring Boot的优点 44
4.2　用IDEA构建Spring Boot工程 44
4.2.1　项目结构 44
4.2.2　在Spring Boot工程中构建
Web 45
4.2.3　Spring Boot的测试 46
4.3　Spring Boot配置文件详解 46
4.3.1　自定义属性 47
4.3.2　将配置文件的属性赋给
实体类 47
4.3.3　自定义配置文件 49
4.3.4　多个环境的配置文件 50
4.4　运行状态监控Actuator 50
4.4.1　查看运行程序的健康状态 52
4.4.2　查看运行程序的Bean 53
4.4.3　使用Actuator关闭应用程序 55
4.4.4　使用shell连接Actuator 56
4.5　Spring Boot整合JPA 57
4.6　Spring Boot整合Redis 60
4.6.1　Redis简介 60
4.6.2　Redis的安装 60
4.6.3　在Spring Boot中使用Redis 60
4.7　Spring Boot整合Swagger2，搭建
Restful API在线文档 62
第5章　服务注册和发现Eureka 66
5.1　Eureka简介 66
5.1.1　什么是Eureka 66
5.1.2　为什么选择Eureka 66
5.1.3　Eureka的基本架构 67
5.2　编写Eureka Server 67
5.3　编写Eureka Client 70
5.4　源码解析Eureka 73
5.4.1　Eureka的一些概念 73
5.4.2　Eureka的高可用架构 74
5.4.3　Register服务注册 74
5.4.4　Renew服务续约 78
5.4.5　为什么Eureka Client获取
服务实例这么慢 80
5.4.6　Eureka 的自我保护模式 80
5.5　构建高可用的Eureka Server集群 81
5.6　总结 83
第6章　负载均衡Ribbon 84
6.1　RestTemplate简介 84
6.2　Ribbon简介 85
6.3　使用RestTemplate和Ribbon来消费
服务 85
6.4　LoadBalancerClient简介 88
6.5　源码解析Ribbon 90
第7章　声明式调用Feign 101
7.1　写一个Feign客户端 101
7.2　FeignClient详解 105
7.3　FeignClient的配置 106
7.4　从源码的角度讲解Feign的工作
原理 107
7.5　在Feign中使用HttpClient和
OkHttp 110
7.6　Feign是如何实现负载均衡的 112
7.7　总结 114
第8章　熔断器Hystrix 115
8.1　什么是Hystrix 115
8.2　Hystrix解决了什么问题 115
8.3　Hystrix的设计原则 117
8.4　Hystrix的工作机制 117
8.5　在RestTemplate和Ribbon上使用
熔断器 118
8.6　在Feign上使用熔断器 119
8.7　使用Hystrix Dashboard监控熔断器的
状态 120
8.7.1　在RestTemplate中使用Hystrix Dashboard 120
8.7.2　在Feign中使用
Hystrix Dashboard 123
8.8　使用Turbine聚合监控 124
第9章　路由网关Spring Cloud Zuul 126
9.1　为什么需要Zuul 126
9.2　Zuul的工作原理 126
9.3　案例实战 128
9.3.1　搭建Zuul服务 128
9.3.2　在Zuul上配置API接口的
版本号 131
9.3.3　在Zuul上配置熔断器 132
9.3.4　在Zuul中使用过滤器 133
9.3.5　Zuul的常见使用方式 135
第10章　配置中心
Spring Cloud Config 137
10.1　Config Server从本地读取配置
文件 137
10.1.1　构建Config Server 137
10.1.2　构建Config Client 138
10.2　Config Server从远程Git仓库读取
配置文件 140
10.3　构建高可用的Config Server 141
10.3.1　构建Eureka Server 141
10.3.2　改造Config Server 142
10.3.3　改造Config Client 143
10.4 使用Spring Cloud Bus刷新配置 144
第11章　服务链路追踪
Spring Cloud Sleuth 147
11.1　为什么需要Spring Cloud Sleuth 147
11.2　基本术语 147
11.3　案例讲解 148
11.3.1　构建Zipkin Server 148
11.3.2　构建User Service 149
11.3.3　构建Gateway Service 151
11.3.4　项目演示 152
11.4　在链路数据中添加自定义数据 153
11.5　使用RabbitMQ 传输链路数据 154
11.6　在MySQL数据库中存储链路数据 155
11.6.1　使用Http传输链路数据，
并存储在MySQL数据
库中 156
11.6.2　使用RabbitMQ传输链路
数据，并存储在MySQL
数据库中 157
11.7　在ElasticSearch中存储链路数据 158
11.8　用Kibana展示链路数据 159
第12章　微服务监控
Spring Boot Admin 161
12.1　使用Spring Boot Admin监控Spring Cloud微服务 161
12.1.1　构建Admin Server 161
12.1.2　构建Admin Client 163
12.2　在Spring Boot Admin中集成Turbine 166
12.2.1　改造Eureka Client 166
12.2.2　另行构建Eureka Client 167
12.2.3　构建Turbine工程 168
12.2.4　在Admin Server中集成
Turbine 169
12.3　在Spring Boot Admin中添加安全
登录界面 172
第13章　Spring Boot Security详解 174
13.1　Spring Security简介 174
13.1.1　什么是Spring Security 174
13.1.2　为什么选择Spring Security 174
13.1.3　Spring Security提供的安全
模块 175
13.2　Spring Boot Security与Spring Security
的关系 176
13.3　Spring Boot Security案例详解 176
13.3.1　构建Spring Boot Security
工程 176
13.3.2　配置Spring Security 178
13.3.3　编写相关界面 180
13.3.4　Spring Security方法级别上
的保护 185
13.3.5　从数据库中读取用户的
认证信息 188
13.4　总结 193
第14章　使用Spring Cloud OAuth2
保护微服务系统 195
14.1　什么是OAuth2 195
14.2　如何使用Spring OAuth2 196
14.2.1　OAuth2 Provider 196
14.2.2　OAuth2 Client 200
14.3　案例分析 201
14.3.1　编写Eureka Server 202
14.3.2　编写Uaa授权服务 202
14.3.3　编写service-hi资源服务 209
14.4　总结 215
第15章　使用Spring Security OAuth2
和JWT保护微服务系统 217
15.1　JWT简介 217
15.1.1　什么是JWT 217
15.1.2　JWT的结构 218
15.1.3　JWT的应用场景 219
15.1.4　如何使用JWT 219
15.2　案例分析 219
15.2.1　案例架构设计 219
15.2.2　编写主Maven工程 220
15.2.3　编写Eureka Server 221
15.2.4　编写Uaa授权服务 222
15.2.5　编写user-service资源服务 227
15.3 总结 236
第16章　使用Spring Cloud构建微
服务综合案例 237
16.1　案例介绍 237
16.1.1　工程结构 237
16.1.2　使用的技术栈 238
16.1.3　工程架构 238
16.1.4　功能展示 240
16.2　案例详解 244
16.2.1　准备工作 244
16.2.2　构建主Maven工程 244
16.2.3　构建eureka-server工程 245
16.2.4　构建config-server工程 246
16.2.5　构建zipkin-service工程 247
16.2.6　构建monitoring-service
工程 248
16.2.7　构建uaa-service工程 250
16.2.8　构建gateway-service工程 251
16.2.9　构建admin-service工程 253
16.2.10　构建user-service工程 253
16.2.11　构建blog-service工程 256
16.2.12　构建log-service工程 256
16.3　启动源码工程 260
16.4　项目演示 261
16.5　总结 262
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入理解Spring Cloud与微服务构建
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud 微服务架构开发实战
内容简介
前言
第1章 微服务概述
1.1 传统软件行业面临的挑战
1.2 常见分布式系统架构
1.3 单块架构如何进化为微服务架构
1.4 微服务架构的设计原则
1.5 如何来设计微服务系统
第2章 微服务的基石——Spring Boot
2.1 Spring Boot 简介
2.2 开启第一个 Spring Boot 项目
2.3 Hello World
2.4 如何搭建开发环境
2.5 Gradle 与 Maven 的抉择
第3章 Spring Boot 的高级主题
3.1 构建 RESTful 服务
3.2 Spring Boot 的配置详解
3.3 内嵌 Servlet 容器
3.4 实现安全机制
3.5 允许跨域访问
3.6 消息通信
3.7 数据持久化
3.8 实现热插拔（hot swapping）
第4章 微服务的测试
4.1 测试概述
4.2 测试的类型和范围
4.3 如何进行微服务的测试
第5章 微服务的协调者——Spring Cloud
5.1 Spring Cloud 简介
5.2 Spring Cloud 入门配置
5.3 Spring Cloud 的子项目介绍
第6章 服务拆分与业务建模
6.1 从一个天气预报系统讲起
6.2 使用Redis提升应用的并发访问能力
6.3 实现天气数据的同步
6.4 给天气预报一个“面子”
6.5 如何进行微服务的拆分
6.6 领域驱动设计与业务建模
第7章 天气预报系统的微服务架构设计与实现
7.1 天气预报系统的架构设计
7.2 天气数据采集微服务的实现
7.3 天气数据API微服务的实现
7.4 天气预报微服务的实现
7.5 城市数据API微服务的实现
第8章 微服务的注册与发现
8.1 服务发现的意义
8.2 如何集成 Eureka Server
8.3 如何集成 Eureka Client
8.4 实现服务的注册与发现
第9章 微服务的消费
9.1 微服务的消费模式
9.2 常见微服务的消费者
9.3 使用 Feign 实现服务的消费者
9.4 实现服务的负载均衡及高可用
第10章 API 网关
10.1 API 网关的意义
10.2 常见 API 网关的实现方式
10.3 如何集成Zuul
10.4 实现 API 网关
第11章 微服务的部署与发布
11.1 部署微服务将面临的挑战
11.2 持续交付与持续部署微服务
11.3 基于容器的部署与发布微服务
11.4 使用 Docker 来构建、运行、发布微服务
第12章 微服务的日志与监控
12.1 微服务日志管理将面临的挑战
12.2 日志集中化的意义
12.3 常见日志集中化的实现方式
12.4 Elastic Stack 实现日志集中化
第13章 微服务的集中化配置
13.1 为什么需要集中化配置
13.2 使用 Config 实现的配置中心
第14章 微服务的高级主题——自动扩展
14.1 什么是自动扩展
14.2 自动扩展的意义
14.3 自动扩展的常见模式
14.4 如何实现微服务的自动扩展
第15章 微服务的高级主题——熔断机制
15.1 什么是服务的熔断机制
15.2 熔断的意义
15.3 熔断与降级的区别
15.4 如何集成 Hystrix
15.5 实现微服务的熔断机制
第16章 微服务的高级主题——分布式消息总线
16.1 什么是消息总线
16.2 Spring Cloud Bus 设计原理
16.3 如何集成 Bus
16.4 实现配置信息的自动更新
附录A：本书所涉及到的技术及相关版本
参考资料
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud 微服务架构开发实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>极简Spring Cloud实战
序
前言
第一篇　基础服务篇
第1章　微服务与Spring Cloud2
1.1　架构演进2
1.1.1　服务端架构发展2
1.1.2　微服务架构4
1.2　Spring Cloud面面观7
1.2.1　Spring Cloud与Dubbo对比7
1.2.2　Spring Cloud好在哪里9
1.2.3　Spring Cloud子项目与解决方案10
1.3　小结15
第2章　服务发现：Eureka16
2.1　使用Eureka17
2.1.1　Eureka服务提供方18
2.1.2　Eureka服务调用方19
2.2　进阶场景20
2.3　小结24
第3章　配置中心：Config25
3.1　Spring Cloud Config的组成25
3.2　使用Config Server配置服务端26
3.3　使用Config Client配置客户端29
3.4　进阶场景31
3.4.1　热生效31
3.4.2　高可用32
3.4.3　安全与加解密34
3.4.4　自定义格式文件支持36
3.5　其他仓库的实现配置37
3.6　小结39
第4章　客户端负载均衡：Ribbon40
4.1　使用Ribbon40
4.2　进阶场景42
4.2.1　使用配置类42
4.2.2　使用配置文件42
4.2.3　默认实现43
4.3　小结44
第5章　RESTful客户端：Feign45
5.1　使用Feign45
5.2　进阶场景46
5.2.1　配置与默认实现46
5.2.2　Feign整合Hystrix47
5.2.3　数据压缩48
5.2.4　日志48
5.3　小结49
第6章　熔断器：Hystrix50
6.1　为什么要有熔断50
6.2　熔断原理52
6.3　使用Hystrix55
6.4　Hystrix数据监控58
6.4.1　健康指示器58
6.4.2　监控面板59
6.4.3　聚合监控61
6.5　小结62
第7章　路由网关：Zuul63
7.1　使用Zuul64
7.2　业务场景深入解析65
7.3　小结71
第8章　网关新选择：Gateway72
8.1　使用Gateway73
8.2　路由断言76
8.3　过滤器81
8.4　小结88
第9章　调用链追踪：Spring Cloud Sleuth89
9.1　术语解释90
9.2　Zipkin简介91
9.3　使用Zipkin93
9.4　Span进阶场景97
9.4.1　自定义日志采样策略97
9.4.2　Span的生命周期98
9.4.3　重命名Span99
9.4.4　自定义Span100
9.5　其他场景与配置101
9.6　小结104
第10章　加密管理：Vault105
10.1　初识HashiCorp Vault105
10.2　整合Spring Cloud Vault111
10.3　认证模式114
10.4　三方组件支持116
10.5　小结118
第11章　公共子项目119
11.1　命令行工具：Spring Boot CLI119
11.1.1　安装Spring Boot CLI119
11.1.2　使用Spring Cloud CLI120
11.1.3　加解密122
11.2　注册中心：Spring Cloud ZooKeeper122
11.2.1　安装ZooKeeper122
11.2.2　基于ZooKeeper服务发现122
11.2.3　相关配置124
11.2.4　节点监听126
11.3　注册中心：Spring Cloud Consul127
11.3.1　安装Consul127
11.3.2　基于Consul注册服务127
11.4　小结128
第二篇　任务与消息篇
第12章　消息驱动：Spring Cloud Stream130
12.1　Stream应用模型130
12.2　示例131
12.3　代码解析133
12.4　Spring Integration支持137
12.5　Binder解析138
12.6　常用配置141
12.7　小结142
第13章　消息总线：Spring Cloud Bus143
13.1　使用Spring Cloud Bus144
13.2　进阶场景144
13.3　小结148
第14章　批处理：Spring Cloud Task149
14.1　使用Spring Cloud Task149
14.2　进阶场景150
14.2.1　数据库集成150
14.2.2　任务事件监听152
14.2.3　相关配置项153
12.4.4　整合Spring Cloud Stream154
14.3　源码解析154
14.4　小结156
第三篇　微服务实战篇
第15章　利用Docker进行编排与整合158
15.1　Docker基础应用158
15.1.1　Docker基础158
15.1.2　Dockerfile基础159
15.2　Spring Cloud核心组件整合161
15.3　Dockerfile编写186
15.4　启动与接口测试188
15.5　小结190
后记191
附录　配置汇总192
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>极简Spring Cloud实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud与Docker高并发微服务架构设计实施
第一部分架 构 篇
1 微服务架构与 Spring Cloud  2
1.1 微服务概念的由来  2
1.2 微服务的定义  3
1.3 微服务架构与整体式架构的区别  5
1.4 微服务架构与SOA 的比较  8
1.5 为什么要使用微服务架构  9
1.6 为实施微服务架构做好准备  10
1.6.1 思想观念的转变  10
1.6.2 团队管理方式的改变  11
1.6.3 自动化基础设施的建设  11
1.7 为什么要使用Spring Cloud  12
1.8 Spring Cloud 组件介绍  13
1.9 Spring Cloud 的版本说明  15
1.10 小结  17
2 微服务架构最佳设计  18
2.1 合理划分微服务  19
2.2 微服务治理  19
2.3 Rest API 微服务设计  21
2.3.1 使用数据库集群  22
2.3.2 读写分离设计  22
2.3.3 使用缓存  22
2.3.4 保证Rest API 微服务的独立性  23
2.4 Web UI 微服务设计  23
2.4.1 使用FeignClient 实现负载均衡调用  23
2.4.2 使用Hystrix 实现容错设计  23
2.4.3 使用非阻塞的异步编程技术实现高并发调用  24
2.4.4 使用分布式文件系统  24
2.5 微服务之间调用规则设计  24
2.6 数据最终一致性设计  25
2.7 分布式集群架构设计  26
2.8 微服务运行环境安全设计  27
2.9 小结  27
3 电商平台微服务设计实例  29
3.1 电商平台总体设计  29
3.1.1 总体业务流程设计  29
3.1.2 总体业务功能设计  31
3.2 电商平台业务模型设计  32
3.2.1 移动商城业务模型  32
3.2.2 商家管理后台业务模型  33
3.2.3 平台管理后台业务模型  33
3.3 创建Rest API 微服务  34
3.4 创建Web UI 微服务  36
3.4.1 移动商城Web UI 微服务  36
3.4.2 商家管理后台的Web UI 微服务  37
3.4.3 平台管理后台Web UI 微服务  37
3.5 电商平台微服务体系结构  38
3.6 小结  39
第二部分 开 发 篇
4 开发工具选用及 Spring Boot 基础  41
4.1 开发工具选择  42
4.2 开发环境配置  42
4.3 创建Spring Boot 工程  43
4.4 使用JPA  47
4.4.1 数据源配置  48
4.4.2 JPA 配置  48
4.4.3 数据实体设计  49
4.4.4 存储库接口设计  49
4.4.5 单元测试  50
4.5 使用Thymeleaf  51
4.5.1 控制器设计  51
4.5.2 视图设计  52
4.6 运行与部署  52
4.7 小结  54
5 电商平台微服务工程设计  55
5.1 微服务工程结构  55
5.2 电商平台微服务工程组建  57
5.3 数据库选型  57
5.4 微服务工程创建步骤  58
5.5 项目基本配置  60
5.6 创建模块  64
5.7 小结  66
6 微服务治理基础服务开发  67
6.1 注册管理中心  68
6.1.1 创建注册管理中心  68
6.1.2 运行注册管理中心  70
6.1.3 微服务怎样使用注册管理中心  70
6.1.4 构建高可用的注册管理中心  72
6.2 配置管理中心  73
6.2.1 创建配置管理中心  73
6.2.2 微服务如何使用配置管理中心  76
6.2.3 在线更新配置信息  77
6.3 微服务监控中心  78
6.3.1 使用断路器仪表盘实现监控  79
6.3.2 聚合服务监控管理中心  81
6.4 服务跟踪分析中心  86
6.4.1 创建服务跟踪分析中心  86
6.4.2 在微服务中启用服务跟踪功能  90
6.5 日志分析平台  93
6.5.1 创建日志分析平台  93
6.5.2 使用日志分析平台  93
6.6 小结  94
7 Rest API 微服务开发  96
7.1 领域业务开发  96
7.1.1 使用Druid 数据源  98
7.1.2 JPA 及其配置  100
7.1.3 数据实体建模  101
7.1.4 查询对象设计  104
7.1.5 实体持久化设计  106
7.1.6 持久化测试  107
7.1.7 领域服务开发  109
7.1.8 领域服务的单元测试  111
7.1.9 使用Redis 实现缓存设计  112
7.2 Rest API 应用开发  117
7.2.1 Rest API 应用配置  117
7.2.2 启动程序设计  119
7.2.3 接口开发  119
7.3 使用消息处理事件  123
7.3.1 消息生产者设计  124
7.3.2 消息消费者设计  125
7.3.3 使用消息测试  128
7.4 小结  129
8 Web UI 微服务开发  131
8.1 高并发接口调用分层设计  131
8.2 通过FeignClient 调用Rest API  132
8.3 使用Hystrix 断路器  134
8.4 使用非阻塞异步编程方法  136
8.4.1 CompletableFuture 介绍  137
8.4.2 性能比较测试  140
8.5 Web 应用开发  145
8.5.1 项目引用配置  145
8.5.2 应用程序配置  146
8.5.3 业务功能开发  148
8.6 开发环境的热部署设置  154
8.7 使用分布式文件系统  157
8.7.1 分布式文件系统客户端开发  157
8.7.2 商品图片上传设计  159
8.7.3 富文本编辑器上传文件设计  160
8.7.4 建立本地文件信息库  163
8.8 小结  166
9 电商平台移动商城开发  167
9.1 移动商城首页设计  168
9.2 使用负载均衡的导航设计  174
9.3 按分类查询设计  176
9.4 商品详情页设计  179
9.5 购买下单实现  181
9.6 用户登录与账户切换设计  184
9.6.1 用户登录设计  184
9.6.2 切换账号设计  186
9.7 订单查询设计  188
9.8 集成测试  191
9.9 小结  192
10 商家管理后台与 SSO 设计  193
10.1 商家权限管理体系设计及开发  194
10.1.1 商家权限体系建模  195
10.1.2 商家权限体系的持久化设计  199
10.1.3 商家权限体系的领域服务开发  201
10.2 商家管理微服务开发  204
10.2.1 商家领域服务层单元测试  204
10.2.2 商家服务的接口开发  208
10.3 SSO 设计  213
10.3.1 SSO 基本配置  213
10.3.2 在SSO 中使用商家的权限体系  214
10.3.3 用户登录设计  216
10.3.4 有关验证码的说明  218
10.3.5 SSO 的主页设计  220
10.3.6 OAuth2 服务端设计  222
10.4 SSO 客户端设计  224
10.4.1 客户端的项目管理配置  224
10.4.2 客户端的安全管理配置  225
10.4.3 权限验证实现原理  226
10.4.4 如何在应用中接入SSO  228
10.4.5 有关跨站请求伪造防御的相关设置  230
10.4.6 根据用户权限自动分配菜单  230
10.5 小结  232
11 平台管理后台开发  233
11.1 平台管理后台领域设计  233
11.1.1 领域实体建模  233
11.1.2 实体的行为设计  236
11.1.3 领域服务开发  236
11.1.4 领域服务单元测试  239
11.2 平台管理后台访问控制设计  240
11.2.1 使用平台管理的用户体系  240
11.2.2 权限管理设计  242
11.3 商家的注册设计  245
11.4 商家菜单体系管理开发  248
11.4.1 分类菜单管理开发  248
11.4.2 模块菜单管理开发  249
11.4.3 访问资源管理开发  252
11.5 商家角色管理开发  255
11.6 小结  257
第三部分运 维 篇
12 服务器架构设计与 Docker 使用  259
12.1 服务器组建  259
12.2 安全的服务器架构设计  260
12.2.1 防火墙安装及配置  260
12.2.2 建立安全的局域网环境  264
12.3 服务器资源分配  266
12.4 CentOS 安装  269
12.4.1 IP 地址设置  270
12.4.2 安全设置  270
12.4.3 语言配置  270
12.4.4 时间同步配置  271
12.5 Docker 和docker-compose 安装  271
12.5.1 Docker 安装及使用  272
12.5.2 docker-compose 安装及使用  275
12.6 使用Docker 搭建微服务治理环境  279
12.6.1 服务器1 的部署配置  279
12.6.2 服务器2 的部署配置  281
12.7 使用Docker 部署日志分析平台  283
12.8 使用Docker 部署微服务应用  286
12.9 小结  286
13 数据库集群设计与高可用读写分离实施  288
13.1 MySQL 安装  289
13.2 主从同步设置  291
13.3 主主同步设置  294
13.4 数据库代理中间件选择  296
13.5 使用OneProxy 实现读写分离设计  297
13.5.1 OneProxy 安装  297
13.5.2 高可用读写分离配置  298
13.6 OneProxy 分库分区设计  302
13.6.1 按范围分库分表  303
13.6.2 按值分库分表  303
13.6.3 按哈希算法分库分表  304
13.7 双机热备设计  306
13.8 小结  307
14 分布式文件系统等基础设施安装与配置  308
14.1 高可用的分布式文件系统构建  308
14.1.1 FastDFS 安装  310
14.1.2 跟踪服务器配置  310
14.1.3 存储节点配置  311
14.1.4 上传文件测试  312
14.1.5 Nginx 安装及负载均衡配置  313
14.1.6 开机启动设置  317
14.2 GitLab 安装  322
14.3 Redis 安装  324
14.4 RabbitMQ 安装  326
14.5 小结  327
15 使用自动化构建工具 Jenkins 实现CI/CD  328
15.1 持续交付工作流程  330
15.2 Jenkins 安装  331
15.3 Jenkins 基本配置  333
15.4 Jenkins 自动部署实例  335
15.4.1 创建任务  336
15.4.2 任务配置  337
15.4.3 执行任务  340
15.5 小结  343
后记  345
参考文献  346
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud与Docker高并发微服务架构设计实施
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务架构进阶
前言
第1章 微服务架构介绍1
1.1 微服务架构的出现1
1.1.1 单体应用架构1
1.1.2 SOA架构2
1.1.3 微服务架构3
1.2 微服务架构的流派5
1.3 云原生与微服务9
1.4 本章小结12
第2章 Spring Cloud总览13
2.1 Spring Cloud架构13
2.2 Spring Cloud特性16
2.2.1 Spring Cloud Context：应用上下文16
2.2.2 Spring Cloud Commons：公共抽象19
2.3 本章小结21
第3章 Spring Cloud的基础：Spring Boot22
3.1 Spring Boot简介22
3.2 构建一个微服务24
3.3 Spring Boot配置文件29
3.3.1 默认配置文件29
3.3.2 外部化配置29
3.3.3 YAML30
3.3.4 自动载入外部属性到Bean30
3.3.5 多Profile31
3.3.6 Starter32
3.3.7 自制一个Starter32
3.3.8 Actuator36
3.4 本章小结38
第4章 服务注册与发现：Eureka39
4.1 基础应用40
4.1.1 Eureka简介40
4.1.2 搭建Eureka服务注册中心40
4.1.3 搭建Eureka服务提供者42
4.1.4 搭建Eureka服务调用者43
4.1.5 Eureka服务注册和发现44
4.1.6 Consul的简单应用46
4.2 服务发现原理48
4.3 Eureka Client源码解析49
4.3.1 读取应用自身配置信息50
4.3.2 服务发现客户端52
4.3.3 拉取注册表信息56
4.3.4 服务注册61
4.3.5 初始化定时任务62
4.3.6 服务下线68
4.4 Eureka Server源码解析70
4.4.1 服务实例注册表70
4.4.2 服务注册72
4.4.3 接受服务心跳74
4.4.4 服务剔除75
4.4.5 服务下线77
4.4.6 集群同步78
4.4.7 获取注册表中服务实例信息82
4.5 进阶应用84
4.5.1 Eureka Instance和Client的元数据84
4.5.2 状态页和健康检查页端口设置85
4.5.3 区域与可用区85
4.5.4 高可用性服务注册中心86
4.6 本章小结87
第5章 声明式RESTful客户端：Spring Cloud OpenFeign88
5.1 基础应用88
5.1.1 微服务之间的交互88
5.1.2 OpenFeign简介89
5.1.3 代码示例89
5.2 源码分析91
5.2.1 核心组件与概念91
5.2.2 动态注册BeanDefinition92
5.2.3 实例初始化98
5.2.4 函数调用和网络请求107
5.3 进阶应用111
5.3.1 Decoder与Encoder的定制化111
5.3.2 请求/响应压缩112
5.4 本章小结113
第6章 断路器：Hystrix114
6.1 基础应用114
6.1.1 RestTemplate与Hystrix115
6.1.2 OpenFeign与Hystrix117
6.2 Hystrix原理118
6.2.1 服务雪崩118
6.2.2 断路器119
6.2.3 服务降级操作120
6.2.4 资源隔离121
6.2.5 Hystrix实现思路122
6.3 源码解析123
6.3.1 封装HystrixCommand123
6.3.2 HystrixCommand类结构129
6.3.3 异步回调执行命令129
6.3.4 异步执行命令和同步执行命令137
6.3.5 断路器逻辑137
6.3.6 资源隔离143
6.3.7 请求超时监控148
6.3.8 失败回滚逻辑150
6.4 进阶应用152
6.4.1 异步与异步回调执行命令152
6.4.2 继承HystrixCommand153
6.4.3 请求合并157
6.5 本章小结161
第7章 客户端负载均衡器：Spring Cloud Netflix Ribbon162
7.1 负载均衡162
7.2 基础应用163
7.3 源码分析165
7.3.1 配置和实例初始化165
7.3.2 与OpenFeign的集成167
7.3.3 负载均衡器LoadBalancerClient171
7.3.4 ILoadBalancer173
7.3.5 负载均衡策略实现177
7.4 进阶应用184
7.4.1 Ribbon API184
7.4.2 使用Netty发送网络请求185
7.4.3 只读数据库的负载均衡实现186
7.5 本章小结187
第8章 API网关：Spring Cloud Gateway189
8.1 Spring Cloud Gateway介绍189
8.2 基础应用190
8.2.1 用户服务191
8.2.2 网关服务192
8.2.3 客户端的访问195
8.3 源码解析195
8.3.1 初始化配置196
8.3.2 网关处理器197
8.3.3 路由定义定位器202
8.3.4 路由定位器205
8.3.5 路由断言208
8.3.6 网关过滤器216
8.3.7 全局过滤器227
8.3.8 API端点234
8.4 应用进阶235
8.4.1 限流机制235
8.4.2 熔断降级238
8.4.3 网关重试过滤器240
8.5 本章小结241
第9章 配置中心：Spring Cloud Config243
9.1 基础应用244
9.1.1 配置客户端244
9.1.2 配置仓库245
9.1.3 服务端246
9.1.4 配置验证248
9.1.5 配置动态更新249
9.2 源码解析250
9.2.1 配置服务器251
9.2.2 配置客户端261
9.3 应用进阶267
9.3.1 为Config Server配置多个repo268
9.3.2 客户端覆写远端的配置属性268
9.3.3 属性覆盖269
9.3.4 安全保护269
9.3.5 加密解密270
9.3.6 快速响应失败与重试机制272
9.4 本章小结272
第10章 消息驱动：Spring Cloud Stream274
10.1 消息队列274
10.2 基础应用276
10.2.1 声明和绑定通道276
10.2.2 自定义通道276
10.2.3 接收消息276
10.2.4 配置278
10.3 源码分析278
10.3.1 动态注册BeanDefinition279
10.3.2 绑定服务282
10.3.3 获取绑定器284
10.3.4 绑定生产者289
10.3.5 消息发送的流程291
10.3.6 StreamListener注解的处理293
10.3.7 绑定消费者298
10.3.8 消息的接收304
10.4 进阶应用306
10.4.1 Bin
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务架构进阶
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务架构开发实战
第1篇  微服务开发基础——Spring Boot框架及使用
第1章  微服务架构开发    2
1.1  单体架构应用的困境   2
1.2  微服务架构   3
1.2.1  如何定义微服务架构       4
1.2.2  微服务架构的优点   5
1.2.3  微服务架构的缺点   6
1.3  微服务架构设计   7
1.3.1  微服务粒度       7
1.3.2  微服务拆分原则       8
1.3.3  微服务自治原则       9
1.3.4  微服务交互原则       10
1.3.5  微服务架构迁移       10
1.4  不应使用微服务架构的情形      11
第2章  微服务基础——Spring Boot 12
2.1  Spring与Spring Boot  12
2.2  快速启动Spring Boot  13
2.2.1  编写pom.xml文件   14
2.2.2  编写应用引导类       16
2.2.3  编写配置文件   17
2.2.4  运行项目   17
2.3  使用Spring Boot构建示例项目 19
2.3.1  经典三层应用架构   19
2.3.2  设计领域对象   20
2.3.3  实现数据管理   23
2.3.4  编写业务逻辑层       29
2.3.5  编写RESTful API     31
2.3.6  数据库初始化   35
2.3.7  启动测试   36
2.4  Spring Boot特性  37
2.4.1  Spring Boot自动配置机制      37
2.4.2  Spring Boot扩展属性配置      38
2.4.3  Spring Boot日志配置      39
2.5  关于敏捷开发      40
2.6  关于RESTful API设计       41
2.6.1  以资源为中心进行URL设计  42
2.6.2  正确使用HTTP方法及状态码       42
2.6.3  查询及分页处理原则       43
2.6.4  其他指导原则   43
第2篇  Spring Cloud组件实战
第3章  Spring Cloud简介  46
3.1  微服务架构的核心关键点   46
3.2  Spring Cloud技术概览       49
3.2.1  Spring Cloud子项目 50
3.2.2  为何选择Spring Cloud     53
3.3  Spring Cloud版Hello World示例      54
第4章  服务治理与负载均衡    58
4.1  什么是服务治理   58
4.2  构建服务治理——Eureka   59
4.2.1  搭建微服务Parent工程   60
4.2.2  搭建服务治理服务器——Eureka服务器       62
4.2.3  搭建服务提供者——注册服务       64
4.2.4  搭建服务消费者——获取服务       68
4.3  使用客户端负载均衡——Ribbon      72
4.3.1  什么是客户端负载均衡   72
4.3.2  启用Ribbon      74
4.3.3  负载均衡测试   75
4.4  使用Feign简化微服务调用       77
4.5  深入Eureka  80
4.5.1  服务注册及相关原理       80
4.5.2  Eureka自我保护模式       82
4.5.3  注册一个服务实例需要的时间       84
4.5.4  Eureka高可用集群及示例       84
4.5.5  多网卡及IP指定      88
4.5.6  Eureka服务访问安全       89
4.6  深入Ribbon  90
4.6.1  Ribbon客户端负载均衡原理   90
4.6.2  Ribbon负载均衡策略及配置   92
4.6.3  直接使用Ribbon API       94
4.7  深入Feign    96
4.7.1  Feign的参数绑定     96
4.7.2  Feign中的继承  97
4.7.3  Feign与Swagger的冲突  98
4.8  微服务健康监控   99
4.9  异构服务解决方案——Sidecar   101
第5章  微服务容错保护——Hystrix       102
5.1  什么是微服务容错保护      102
5.2  快速启动Hystrix  103
5.2.1  引入Hystrix依赖     104
5.2.2  开启Hystrix支持     104
5.2.3  修改UserService实现      104
5.2.4  容错测试   105
5.2.5  服务降级的两种实现方式       107
5.2.6  在Feign中使用Hystrix回退   109
5.3  Hystrix容错机制分析  110
5.3.1  Hystrix整体处理流程      111
5.3.2  HystrixCommand与HystrixObservableCommand   113
5.3.3  断路器原理分析       115
5.3.4  Hystrix异常——HystrixBadRequestException       117
5.4  服务隔离      117
5.4.1  线程池隔离与信号量隔离       118
5.4.2  服务隔离的颗粒度   119
5.4.3  服务隔离配置   119
5.4.4  小结   120
5.5  服务降级模式      121
5.5.1  快速失败   121
5.5.2  静默失败   121
5.5.3  返回默认值       122
5.5.4  返回组装的值   122
5.5.5  返回远程缓存   123
5.5.6  主/从降级模式  124
5.6  请求缓存      127
5.7  请求合并      128
5.8  Hystrix监控  130
5.8.1  Hystrix仪表盘   131
5.8.2  Turbine仪表盘集群监控  133
5.8.3  Turbine与消息服务器集成      136
……
第6章  API服务网关——Zuul 137
第7章  统一配置中心——Config     166
第8章  分布式服务跟踪——Sleuth  192
第9章  消息驱动——Stream    215
第10章  微服务应用安全——Security    258
第3篇  微服务与Docker容器技术
第11章  微服务与Docker  288
11.1  Docker简介 288
11.2  Docker的使用    289
11.3  Docker与Spring Cloud微服务 301
11.4  微服务与Jenkins       305
11.5  微服务编排 315
显示部分信息
前　　言
前言　　2014年3月，Martin Fowler在其博客上发表了Microservices（微服务）一文，对过去几年逐渐开始流行的微服务架构开发模式给出了正式的定义。同年，Netflix OSS将自己多年来在实际开发中所使用的微服务基础组件开源。随后，Pivotal在Netflix OSS的基础上对这些组件进行了封装和集成，推出了Spring Cloud。到如今，微服务架构已逐渐普及，在技术生态上也得到了不断完善和更新，其在容器、应用框架、发布管理及监控等方面都有了长足进步。微服务在日常开发中也崭露头角，逐渐得到了开发者的认同。与此同时，Spring Cloud在过去几年中快速发展，不断迭代和更新，已经形成了微服务开发“全家桶”式的解决方案，逐渐在微服务开发领域奠定了坚实的基础。
当我第一次接触微服务的概念时，以为这又是一个“新瓶装旧酒”的把戏。就像当年一些大公司为解决分布式大型应用所提出的COBRA、EJB、DCOM和ESB等概念一样难以使用，它们甚至还没有来得及等用户完全掌握就退出了历史的舞台。当我再次注意到微服务时，是因为Spring Cloud的推出。在大致阅读了相关文档之后顺便“跑”了一下示例项目，我就被其深深吸引了。正是这次接触，使我改变了对微服务的看法。正巧接下来的一段时间，公司内部正在做架构调整，也发现了微服务有其可用之处，所以便在架构调整中引入了Spring Cloud，并最终在项目中取得了不错的效果。这加深了我对微服务的好感，所以后续对Spring Cloud进行了更加深入和系统的学习与研究。
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud微服务架构开发实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud实战演练
第一部分　基础篇
第1章　微服务概述　　2
1.1　应用架构概述　　2
1.1.1　单体架构　　2
1.1.2　微服务架构　　3
1.1.3　如何选择架构风格　　4
1.2　微服务现状及发展趋势　　4
1.2.1　微服务现状　　4
1.2.2　微服务发展趋势　　5
1.3　微服务架构面临的挑战　　5
1.4　怎样实现微服务架构　　6
1.4.1　技术选型　　6
1.4.2　整体架构思路　　7
1.5　小结　　7
第2章　Spring Boot基础　　9
2.1　Spring Boot简介　　9
2.2　第一个Spring Boot工程　　9
2.3　使用YAML文件配置属性　　12
2.3.1　YAML的基本用法　　12
2.3.2　多环境配置　　13
2.4　常用注解　　14
2.4.1　@SpringBootApplication　　15
2.4.2　@SpringBootConfiguration　　15
2.4.3　@Bean　　16
2.4.4　@Value　　18
2.5　Spring Boot集成模板引擎　　19
2.6　更改默认的JSON转换器　　21
2.7　打包发布到服务器上　　22
2.7.1　使用内置Tomcat发布jar包　　22
2.7.2　打包成war包发布　　24
2.8　WebFlux快速入门　　27
2.9　小结　　29
第3章　Spring Boot核心原理　　31
3.1　起步依赖机制　　31
3.2　自动配置管理　　32
3.3　Actuator监控管理　　34
3.4　Spring Boot CLI命令行工具　　36
3.4.1　安装　　36
3.4.2　用法　　37
3.5　小结　　38
第4章　Spring Cloud概述　　40
4.1　简介　　40
4.2　优缺点　　41
4.3　现状　　41
4.4　开始Spring Cloud实战　　42
4.4.1　技术储备　　42
4.4.2　准备工作　　42
4.4.3　从Hello World开始你的实战之旅　　43
4.5　小结　　52
第二部分　实战篇
第5章　项目准备阶段　　54
5.1　项目介绍　　54
5.2　需求分析　　54
5.3　产品设计　　55
5.4　架构方案分析　　58
5.4.1　技术选型　　58
5.4.2　架构图设计　　58
5.4.3　根据架构图创建工程　　59
5.5　数据库结构设计　　62
5.6　小结　　63
第6章　公共模块封装　　65
6.1　common工程常用类库的封装　　65
6.1.1　日期时间的处理　　65
6.1.2　字符串的处理　　68
6.1.3　加密/解密封装　　69
6.1.4　消息队列的封装　　74
6.2　接口版本管理　　78
6.3　输入参数的合法性校验　　80
6.4　异常的统一处理　　82
6.5　更换JSON转换器　　83
6.6　Redis的封装　　84
6.7　小结　　85
第7章　注册中心：Spring Cloud Netflix Eureka　　87
7.1　Eureka简介　　87
7.2　创建注册中心　　87
7.3　创建客户端工程以验证注册中心　　91
7.4　实现注册中心的高可用　　92
7.5　添加用户认证　　96
7.6　开启自我保护模式　　99
7.7　注册中心的健康检查　　100
7.8　多网卡环境下的IP选择问题　　101
7.9　小结　　103
第8章　配置中心：Spring Cloud Config　　105
8.1　Spring Cloud Config简介　　105
8.2　创建配置中心　　105
8.3　对配置内容进行加密　　111
8.3.1　安装JCE　　111
8.3.2　对称加密　　112
8.3.3　对配置内容加密　　114
8.3.4　非对称加密　　114
8.4　配置自动刷新　　118
8.4.1　使用refresh端点刷新配置　　118
8.4.2　Spring Cloud Bus自动刷新配置　　119
8.5　添加用户认证　　122
8.6　小结　　123
第9章　服务网关：Spring Cloud Gateway　　125
9.1　Gateway简介　　125
9.2　创建服务网关　　125
9.3　利用过滤器拦截API请求　　128
9.4　请求失败处理　　130
9.5　小结　　133
第10章　功能开发　　135
10.1　开发前的准备　　135
10.1.1　MyBatis的集成　　135
10.1.2　Elasticsearch的集成　　137
10.2　利用代码生成器提升开发效率　　140
10.3　使用代码生成器生成的代码操作数据库　　147
10.4　MyBatis应对复杂SQL　　149
10.4.1　注解　　149
10.4.2　Provider　　150
10.5　功能开发　　151
10.6　网关鉴权　　154
10.6.1　防止参数被篡改　　155
10.6.2　拦截非法请求　　157
10.7　单元测试　　159
10.8　小结　　160
第三部分　高级篇
第11章　服务间通信：Spring Cloud Netflix Ribbon和Spring Cloud OpenFeign　　162
11.1　Spring Cloud Netflix Ribbon的使用　　162
11.2　Spring Cloud OpenFeign　　164
11.3　自定义OpenFeign配置　　166
11.4　Spring Cloud OpenFeign熔断　　167
11.4.1　Spring Cloud Netflix Hystrix简介　　167
11.4.2　Spring Cloud Netflix Hystrix的使用　　168
11.4.3　OpenFeign集成Hystrix熔断器　　172
11.5　小结　　173
第12章　服务链路追踪：Spring Cloud Sleuth　　175
12.1　Spring Cloud Sleuth简介　　175
12.2　利用链路追踪监听网络请求　　176
12.2.1　服务端的实现　　176
12.2.2　客户端集成Spring Cloud Sleuth　　179
12.3　通过消息中间件实现链路追踪　　180
12.4　存储追踪数据　　182
12.5　小结　　184
第13章　服务治理：Spring Cloud Consul和Spring Cloud ZooKeeper　　186
13.1　服务治理简介　　186
13.2　Spring Cloud Consul的使用　　186
13.2.1　Consul的安装与部署　　187
13.2.2　Spring Cloud集成Consul　　189
13.3　Spring Cloud ZooKeeper的使用　　190
13.3.1　ZooKeeper的安装和部署　　191
13.3.2　Spring Cloud集成ZooKeeper　　191
13.4　小结　　193
第四部分　部署篇
第14章　系统发布上线　　195
14.1　发布前准备　　195
14.1.1　虚拟机的安装　　195
14.1.2　Linux常用命令　　198
14.1.3　安装常用软件　　198
14.2　编译、打包、发布　　207
14.3　利用Jenkins实现持续集成　　210
14.3.1　安装并配置Jenkins　　210
14.3.2　创建任务　　215
14.3.3　构建项目　　220
14.4　小结　　221
第15章　使用Kubernetes部署分布式集群　　223
15.1　Docker介绍　　223
15.1.1　Docker安装　　223
15.1.2　Docker镜像　　224
15.1.3　Docker容器　　228
15.2　K8S集群环境搭建　　229
15.2.1　环境准备　　229
15.2.2　集群搭建　　230
15.2.3　分布式应用部署　　232
15.3　小结　　237
附录A　如何编写优雅的Java代码　　239
附录B　IDEA插件之Alibaba Cloud Toolkit　　258


>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring Cloud实战演练
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring响应式微服务
第1章  直面响应式微服务架构	1
1.1  响应式系统核心概念	1
1.1.1  从传统编程方法到响应式编程方法	1
1.1.2  响应式宣言与响应式系统	4
1.2  剖析微服务架构	6
1.2.1  分布式系统与微服务架构	6
1.2.2  服务拆分与集成	8
1.2.3  微服务架构的核心组件	11
1.2.4  微服务架构技术体系	13
1.3  构建响应式微服务架构	15
1.3.1  响应式微服务架构设计原则	15
1.3.2  整合响应式编程与微服务架构	18
1.4  全书架构	19
1.5  本章小结	20
第2章  响应式编程模型与Reactor框架	21
2.1  响应式编程模型	21
2.1.1  流	22
2.1.2  背压	24
2.1.3  响应式流	25
2.2  Reactor框架	28
2.2.1  响应式编程实现技术概述	28
2.2.2  引入Reactor框架	31
2.3  创建Flux和Mono	34
2.3.1  创建Flux	34
2.3.2  创建Mono	37
2.4  Flux和Mono操作符	39
2.4.1  转换操作符	39
2.4.2  过滤操作符	43
2.4.3  组合操作符	46
2.4.4  条件操作符	49
2.4.5  数学操作符	52
2.4.6  Observable工具操作符	54
2.4.7  日志和调试操作符	56
2.5  Reactor框架中的背压机制	58
2.6  本章小结	60
第3章  构建响应式RESTful服务	61
3.1  使用Spring Boot 2.0构建微服务	61
3.1.1  Spring Boot基本特性	61
3.1.2  基于Spring Boot的第一个RESTful服务	63
3.1.3  使用Actuator组件强化服务	67
3.2  使用Spring WebFlux构建响应式服务	80
3.2.1  使用Spring Initializer初始化响应式Web应用	80
3.2.2  对比响应式Spring WebFlux与传统Spring WebMvc	82
3.2.3  使用注解编程模型创建响应式RESTful服务	84
3.2.4  使用函数式编程模型创建响应式RESTful服务	88
3.3  本章小结	93
第4章  构建响应式数据访问组件	94
4.1  Spring Data数据访问模型	94
4.1.1  Spring Data抽象	95
4.1.2  集成Spring Data JPA	98
4.1.3  集成Spring Data Redis	100
4.1.4  集成Spring Data Mongodb	103
4.2  响应式数据访问模型	104
4.2.1  Spring Reactive Data抽象	105
4.2.2  创建响应式数据访问层组件	107
4.3  响应式Mongodb	108
4.3.1  初始化Reactive Mongodb运行环境	109
4.3.2  创建Reactive Mongodb Repository	112
4.3.3  使用CommandLineRunner初始化Mongodb数据	113
4.3.4  在Service层中调用Reactive MongodbRepository	114
4.4  响应式Redis	117
4.4.1  初始化Reactive Redis运行环境	117
4.4.2  创建Reactive Redis Repository	121
4.4.3  在Service层中调用Reactive Repository	122
4.5  本章小结	123
第5章  构建响应式消息通信组件	124
5.1  消息通信系统简介	125
5.2  使用Spring Cloud Stream构建消息通信系统	126
5.2.1  Spring Cloud Stream基本架构	126
5.2.2  Spring Cloud Stream中的Binder组件	130
5.2.3  使用Source组件实现消息发布者	135
5.2.4  使用@StreamListener注解实现消息消费者	137
5.3  引入Reactive Spring Cloud Stream实现响应式 消息通信系统	139
5.3.1  Reactive Spring Cloud Stream组件	139
5.3.2  Reactive Spring Cloud Stream示例	141
5.4  本章小结	147
第6章  构建响应式微服务架构	148
6.1  使用Spring Cloud创建响应式微服务架构	148
6.1.1  服务治理	149
6.1.2  负载均衡	154
6.1.3  服务容错	161
6.1.4  服务网关	166
6.1.5  服务配置	173
6.1.6  服务监控	177
6.2  使用WebClient实现响应式服务调用	182
6.2.1  创建和配置WebClient	182
6.2.2  使用WebClient访问服务	183
6.3  本章小结	187
第7章  测试响应式微服务架构	188
7.1  初始化测试环境	189
7.1.1  引入spring-boot-starter-test组件	189
7.1.2  解析基础类测试注解	190
7.1.3  编写第一个测试用例	191
7.2  测试Reactor组件	192
7.3  测试响应式Repository层组件	194
7.3.1  测试内嵌式Mongodb	194
7.3.2  测试真实MongoDB	197
7.4　测试响应式Service层组件	199
7.5  测试响应式Controller层组件	201
7.6  本章小结	204
第8章  响应式微服务架构演进案例分析	205
8.1  PrescriptionSystem案例简介	205
8.2  传统微服务架构实现案例	207
8.2.1  构建基础设施类服务	207
8.2.2  构建Medicine服务	213
8.2.3  构建Card服务	219
8.2.4  构建Prescription服务	224
８.3  响应式微服务架构演进案例	237
8.3.1  更新基础设施类服务	237
8.3.2  更新数据访问方式	241
8.3.3  更新事件通信方式	246
8.4  本章小结	266
参考文献	267
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring响应式微服务
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高可用可伸缩微服务架构
1.1 什么是架构 1
1.2 几个相关概念 3
1.3 从软件的生命周期看架构设计 7
1.4 架构的形式与特点 9
1.5 架构的目标与方法 13
1.6 架构的不同风格 18
第2章 微服务领域驱动设计 30
2.1 领域驱动设计 31
2.1.1 领域驱动设计概览 31
2.1.2 问题域与解决方案域 34
2.1.3 限界上下文 35
2.1.4 上下文映射 40
2.1.5 领域架构 43
2.2 微服务的设计 48
2.2.1 限界上下文的边界 48
2.2.2 限界上下文即微服务 51
2.2.3 识别限界上下文 53
2.2.4 微服务之间的协作 59
2.3 小结 63
第3章 Apache Dubbo框架的原理与实现 64
3.1 Dubbo框架的选型与使用 64
3.1.1 Dubbo框架的选型 64
3.1.2 Dubbo框架的使用 65
3.2 Dubbo框架的原理分析 70
3.2.1 总体架构分析 70
3.2.2 Dubbo Bean的加载 73
3.2.3 Dubbo Extension机制 77
3.2.4 Dubbo消费端 91
3.2.5 Dubbo服务端 126
3.2.6 Dubbo的通信机制 144
3.3 基于Dubbo的自动化Mock系统 165
3.3.1 Mock模拟系统的产生 166
3.3.2 Dubbo Mock的使用 167
3.3.3 Dubbo Mock的原理解析 168
3.3.4 自动化Mock系统的实现 170
第4章 Spring Boot/Spring Cloud实践 177
4.1 Spring Boot原理剖析 178
4.1.1 Spring Boot Quick Start 178
4.1.2 Spring Boot之SpringApplication 180
4.1.3 spring-boot-loaded模块分析 186
4.1.4 spring-boot-autoconfigure模块分析 190
4.1.5 Spring Boot Conditional注解分析 195
4.2 Dubbo Spring Boot Starter 198
4.2.1 Dubbo Spring Boot Starter简介 198
4.2.2 Dubbo Initializr及sample 198
4.2.3 dubbo-spring-boot-autoconfigure模块 201
4.2.4 dubbo-spring-boot-actuator模块 204
4.3 Spring Cloud栈 211
4.3.1 为什么微服务架构需要Spring Cloud 212
4.3.2 Spring Cloud技术栈总览 214
4.3.3 spring-cloud-scaffold基础库集合 215
4.4 基于Maven Archetype的脚手架 239
4.4.1 Maven Archetype 239
4.4.2 脚手架的搭建 240
4.4.3 生成脚手架 247
第5章 微服务稳定性保证的常用手段 250
5.1 微服务的稳定性 250
5.2 高可用 250
5.2.1 限流原理与实现 250
5.2.2 断路器原理与实现 256
5.2.3 超时与重试 260
5.3 高并发 262
5.3.1 异步 263
5.3.2 缓存 270
5.4 总结 272
第6章 微服务下如何保证事务的一致性 273
6.1 从本地事务到分布式事务的演变 273
6.2 强一致性解决方案 276
6.2.1 二阶段提交协议 276
6.2.2 三阶段提交协议 278
6.3 最终一致性解决方案 280
6.3.1 TCC模式 280
6.3.2 补偿模式 285
6.3.3 可靠事件模式 286
6.4 开源项目的分布式事务实现解读 288
6.4.1 Apache RocketMQ 288
6.4.2 ServiceComb 289
第7章 百亿流量微服务网关的设计与实现 293
7.1 API网关概述 293
7.1.1 分布式服务架构、微服务架构与 API 网关 293
7.1.2 API网关的定义、职能与关注点 296
7.1.3 API网关的分类与技术分析 298
7.2 开源网关的分析与调研 300
7.2.1 常见的开源网关介绍 300
7.2.2 四大开源网关的对比分析 308
7.2.3 开源网关的技术总结 309
7.3 百亿流量交易系统API网关设计 310
7.3.1 百亿流量交易系统API网关的现状和面临问题 310
7.3.2 业务网关的设计与最佳实践 313
第8章 微服务编排 317
8.1 Netflix Conductor 317
8.2 Netflix Conductor的架构 319
8.3 Conductor的使用案例 320
8.4 Netflix Conductor源码分析 328
8.4.1 Client层源码分析 330
8.4.2 Server端源码分析 337
8.4.3 core端源码分析 344
第9章 微服务数据抽取与统计 356
9.1 案例小故事 356
9.2 数据仓库概述 358
9.2.1 什么是数据仓库 358
9.2.2 数据仓库架构 360
9.2.3 数据仓库建模方法 361
9.2.4 数据抽取、转换和加载 361
9.2.5 数据统计 362
9.3 数据仓库工具Hive 362
9.3.1 安装Hive 364
9.3.2 Hive数据库 366
9.3.3 Hive表 367
9.4 使用Sqoop抽取数据 369
9.4.1 安装Sqoop 370
9.4.2 将MySQL表数据导入Hive表 372
9.5 ETL作业调度 375
第10章 微服务双活体系建设 377
10.1 系统高可用 377
10.2 双活数据中心 379
10.2.1 单机房部署 379
10.2.2 双机房部署 380
10.2.3 基于支付场景的双活体系建设 383
第11章 基于支付场景下的微服务改造与性能优化 399
11.1 支付场景的介绍 399
11.2 支付业务建模和服务划分 400
11.3 支付场景下微服务架构的详解与分析 402
11.3.1 业务架构分析 402
11.3.2 技术平台详解 404
11.4 从代码层面提升微服务架构的性能 407
11.4.1 从代码和设计的角度看 407
11.4.2 从整体架构的角度看 418
11.5 微服务架构中常见的一些故障分析技巧 421
第12章 遗留系统的微服务架构改造 426
12.1 代码分层结构的转变 426
12.2 遗留系统的债券与思考 430
12.3 从单体系统拆分服务的方法论 431
12.4 遗留系统的微服务架构改造 436
12.4.1 从代码重构开始 436
12.4.2 拆分服务需要面向服务进行架构设计 437
12.4.3 改造是一个渐进的过程 437
12.4.4 单元测试是基石 440
12.4.5 面向失败的设计 440
12.4.6 前后端分离 441
12.4.7 共享现有数据库 441
12.4.8 灰度发布的必要性 442
12.4.9 日志聚合与全链路监控 442
第13章 Service Mesh详解 443
13.1 Service Mesh是什么 443
13.2 Service Mesh的背景 443
13.3 Service Mesh介绍 444
13.3.1 Service Mesh架构 444
13.3.2 Service Mesh能做什么 445
13.4 Service Mesh的价值 446
13.5 Service Mesh现状 447
13.6 Service Mesh存在的问题 448
13.7 Istio详解 449
13.7.1 Istio架构 449
13.7.2 数据平面 450
13.7.3 控制平面 455
13.7.4 Isito案例 458
13.8 Service Mesh展望 461
第14章 微服务监控实战 463
14.1 APM原理与应用 464
14.1.1 什么是APM 464
14.1.2 APM监控点 464
14.1.3 APM深入解析 464
14.2 Prometheus监控系统介绍 492
14.2.1 Prometheus的主要特点 493
14.2.2 Prometheus的架构及组件介绍 493
14.2.3 Prometheus的安装 494
14.2.4 使用Prometheus对MySQL进行监控 498
14.2.5 Prometheus的告警机制 501
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>高可用可伸缩微服务架构
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务架构实战
第1章 微服务架构设计 1
1.1 直面微服务架构 1
1.1.1 分布式系统与微服务架构 1
1.1.2 微服务架构的优势与挑战 3
1.1.3 实施微服务架构 5
1.2 服务建模方法 6
1.2.1 服务的模型 6
1.2.2 服务的边界 7
1.2.3 服务的数据 7
1.3 服务拆分与集成 8
1.3.1 服务拆分 8
1.3.2 服务集成 9
1.4 微服务架构的基础组件和关键要素 10
1.4.1 微服务架构的基础组件 11
1.4.2 微服务架构的关键元素 11
1.5 实现微服务架构 13
1.5.1 微服务架构技术体系 13
1.5.2 微服务架构实现技术选型 14
1.6 案例分析 17
1.7 全书架构 18
1.8 本章小结 19
第2章 使用Spring Boot构建服务 21
2.1 引入Spring Boot 21
2.2 基于Spring Boot的第一个服务 23
2.2.1 环境准备 23
2.2.2 实现RESTful服务 24
2.3 Spring Boot常见功能 28
2.3.1 集成Spring Data 28
2.3.2 集成消息中间件 37
2.3.3 系统监控 39
2.4 Spring Boot基本原理 44
2.5 本章小结 46
第3章 Spring Cloud Netflix Eureka与服务治理 47
3.1 服务治理解决方案 48
3.1.1 服务治理的需求和模型 48
3.1.2 服务治理的基本方案 49
3.2 构建Eureka服务 52
3.2.1 构建单个Eureka服务器 52
3.2.2 构建Eureka服务器集群 55
3.3 使用Eureka注册和发现服务 57
3.3.1 通过配置实现服务注册 58
3.3.2 获取服务注册信息 59
3.4 Eureka基本架构 61
3.4.1 Eureka服务注册和发现架构 61
3.4.2 Eureka高可用架构 64
3.4.3 Eureka区域亲和性 65
3.5 本章小结 66
第4章 Spring Cloud Netflix Ribbon与负载均衡 67
4.1 负载均衡 68
4.1.1 负载均衡的类型 68
4.1.2 负载均衡的算法 70
4.2 使用Ribbon实现客户端负载均衡 71
4.2.1 Spring Cloud Netflix Ribbon简介 71
4.2.2 使用DiscoveryClient查找服务 72
4.2.3 通过RestTemplate调用服务 74
4.3 Ribbon基本架构 78
4.3.1 Ribbon核心机制 79
4.3.2 Ribbon负载均衡策略 81
4.3.3 @LoadBalanced注解与RestTemplate 82
4.3.4 @RibbonClient注解与自定义负载均衡策略 83
4.4 本章小结 85
第5章 Spring Cloud Netflix Hystrix与服务容错 86
5.1 服务消费者容错思想和模式 87
5.1.1 服务消费者容错的需求 87
5.1.2 服务隔离 88
5.1.3 服务熔断 90
5.1.4 服务回退 91
5.2 使用Hystrix实现服务容错 91
5.2.1 引入Hystrix 92
5.2.2 使用Hystrix实现服务隔离 93
5.2.3 使用Hystrix实现服务熔断 96
5.2.4 使用Hystrix实现服务回退 99
5.3 Hystrix基本原理 101
5.3.1 服务隔离 101
5.3.2 服务熔断 103
5.3.3 Hystrix配置项 105
5.4 本章小结 109
第6章 Spring Cloud Netflix Zuul与API网关 110
6.1 服务网关的设计理念 111
6.1.1 服务网关的作用 111
6.1.2 服务网关的结构和功能 112
6.2 使用Zuul构建服务网关 113
6.2.1 构建Zuul服务器 113
6.2.2 配置Zuul服务路由 115
6.3 Zuul基本架构 120
6.3.1 ZuulFilter组件架构 120
6.3.2 使用Zuul过滤器 124
6.4 本章小结 129
第7章 Spring Cloud Config与配置中心 130
7.1 分布式配置中心方案 131
7.1.1 分布式配置模型 131
7.1.2 配置中心实现工具 133
7.2 构建配置中心服务器 134
7.2.1 引入Spring Cloud Config 134
7.2.2 实现基于本地文件系统的配置方案 135
7.2.3 实现基于Git的配置方案 139
7.3 使用配置服务 140
7.3.1 访问配置项 141
7.3.2 配置数据安全性 145
7.4 Spring Cloud Config特性 148
7.4.1 Spring Cloud Config对比Zookeeper 148
7.4.2 Spring Cloud Config高可用 149
7.5 本章小结 150
第8章 Spring Cloud Stream与事件驱动 151
8.1 事件驱动架构与模型 152
8.1.1 基本事件驱动架构与实现机制 152
8.1.2 事件驱动与领域模型 155
8.2 引入Spring Cloud Stream 157
8.2.1 Spring Cloud Stream基本架构 157
8.2.2 Spring Cloud Stream与Spring Integration 159
8.2.3 Spring Cloud Stream与消息中间件 162
8.3 实现消息发布者 165
8.3.1 消息发送场景与实现流程 165
8.3.2 在服务中添加消息发布者 166
8.4 实现消息消费者 170
8.4.1 消息消费场景与实现流程 170
8.4.2 在服务中添加消息消费者 172
8.5 本章小结 177
第9章 Spring Cloud Security与服务安全 178
9.1 服务访问安全性与OAuth协议 178
9.1.1 微服务架构中的安全性设计 179
9.1.2 OAuth协议 180
9.2 构建OAuth认证服务器 184
9.2.1 引入Spring Cloud Security 185
9.2.2 初始化用户与客户端 186
9.2.3 生成Token 191
9.3 使用OAuth保护服务访问 195
9.3.1 集成OAuth认证服务 195
9.3.2 创建服务访问策略 196
9.3.3 使用OAuth2RestTemplate传播Token 201
9.4 本章小结 206
第10章 Spring Cloud Sleuth与服务监控 207
10.1 服务监控与Spring Cloud Sleuth 207
10.1.1 服务监控基本原理 207
10.1.2 引入Spring Cloud Sleuth 209
10.2 整合Spring Cloud Sleuth与Zipkin 215
10.2.1 Zipkin基本结构 215
10.2.2 引入Zipkin 216
10.2.3 使用Zipkin跟踪服务调用链路 218
10.2.4 使用Zipkin实现自定义跟踪 226
10.3 本章小结 228
第11章 Spring Test与服务测试 230
11.1 微服务测试的方法 231
11.1.1 单元测试 231
11.1.2 集成测试 233
11.1.3 端到端测试 233
11.2 测试Spring Boot应用程序 234
11.2.1 初始化测试环境 234
11.2.2 执行单元测试 237
11.3 使用Mock和注解实施集成测试 241
11.3.1 使用@JsonTest注解测试JSON数据 242
11.3.2 使用@DataJpaTest注解测试Repository层 244
11.3.3 使用Mock测试Service层 248
11.3.4 使用Mock和@WebMvcTest注解测试Controller层 252
11.4 消费者驱动的契约测试 254
11.4.1 面向契约的端对端测试 254
11.4.2 实现面向契约的端对端测试 257
11.5 本章小结 266
第12章 Docker与服务部署 267
12.1 Docker与微服务架构 267
12.1.1 Docker的优势 268
12.1.2 Docker组件与命令 268
12.2 使用Dockerfile构建服务镜像 272
12.2.1 Dockerfile命令 272
12.2.2 使用Dockerfile命令构建镜像 273
12.3 使用Docker Compose编排服务 276
12.3.1 Docker Compose组件与命令 276
12.3.2 使用Docker Compose 279
12.3.3 Docker Compose案例分析 281
12.4 本章小结 283
参考文献 284
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务架构实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务那些事儿
目 录
第一部分 微服务解惑篇
第1章 微服务架构 2
1.1 不微你就OUT了 2
1.2 产生背景 3
1.2.1 时代的召唤 3
1.2.2 容器神助攻 4
1.2.3 微服务的进击 4
1.3 微服务的标签 5
1.3.1 单一职责 6
1.3.2 微 6
1.3.3 面向服务 7
1.3.4 自治 8
1.3.5 易扩展 9
1.3.6 流程化 10
1.4 实力碾压 11
1.4.1 组件化 11
1.4.2 快速 13
1.4.3 可复用 13
1.4.4 机动灵活 13
1.5 不要奶我 14
1.5.1 不足 14
1.5.2 挑战 15
1.5.3 小结 16
1.6 本章小结 17
第2章 为何选择微服务 18
2.1 传统架构的病 18
2.1.1 中年危机 18
2.1.2 宝宝心里苦 19
2.2 微服务有药 21
2.2.1 讳疾忌医 21
2.2.2 朋友听说过安利么 22
2.2.3 沙盘演练看效果 22
2.3 微服务的价值 23
2.3.1 资源价值 24
2.3.2 业务价值 24
2.3.3 技术价值 24
2.3.4 用户价值 25
2.3.5 未来价值 25
2.3.6 小结 26
2.4 定个小目标 26
2.4.1 持续交付 26
2.4.2 业务敏捷 26
2.4.3 独立演进 27
2.4.4 高可用 27
2.4.5 高性能 27
2.4.6 站在云端 28
2.5 别人家的公司 28
2.6 来不及解释快上车 29
第3章 我拆我拆我拆拆拆 30
3.1 拆还是不拆 30
3.2 如何拆 32
3.2.1 庖丁解牛 32
3.2.2 数据模型和业务模型 33
3.2.3 金字塔结构图 33
3.2.4 关键指标 33
3.3 粒度 35
3.3.1 五笔字根 36
3.3.2 被遗忘的字典师傅 37
3.3.3 小结 37
3.4 边界 37
3.5 本章小结 38
第4章 如何使用微服务 39
4.1 如何规划 39
4.2 微服务重构 42
4.2.1 影响因素 42
4.2.2 重构原则 43
4.2.3 重构方法 44
4.3 本章小结 45
第5章 微服务的朋友圈 46
5.1 好朋友容器 46
5.1.1 容器的来历 46
5.1.2 容器的好处 47
5.1.3 小结 49
5.2 天生一对DevOps 49
5.2.1 DevOps是什么 49
5.2.2 为什么采用DevOps 50
5.2.3 小结 51
5.3 SOA是谁 51
5.3.1 接着忽悠 52
5.3.2 SOA是个什么鬼 52
5.3.3 小结 53
第二部分 技术实现篇
第6章 Spring Boot 56
6.1 介绍 56
6.2 特点 57
6.3 Spring Boot和微服务之间的关系 57
6.4 如何使用 58
6.5 可定制化 61
6.6 本章小结 64
第7章 Spring Cloud 65
7.1 Spring Cloud优势 66
7.2 Spring Cloud特点 67
7.3 Spring Cloud之服务管理 68
7.4 注册中心Eureka 69
7.4.1 什么是注册中心 69
7.4.2 为什么要有注册中心 69
7.4.3 Eureka来历 70
7.4.4 Eureka机制 71
7.4.5 如何使用 72
7.5 网关Zuul 77
7.5.1 Zuul 78
7.5.2 反向代理 78
7.5.3 如何使用 79
7.6 客户端负载均衡Ribbon 84
7.6.1 负载均衡 85
7.6.2 如何使用 85
7.6.3 补充说明 91
7.7 断路器Hystrix 92
7.7.1 如何隔离 93
7.7.2 电路熔断器模式 93
7.7.3 回滚降级 94
7.7.4 如何使用 95
7.7.5 交通疏导 101
7.7.6 小结 101
7.8 分布式配置中心Spring Cloud Config 101
7.8.1 为什么要有配置 102
7.8.2 集中配置的好处 103
7.8.3 配置方式的演进 103
7.8.4 如何使用 104
7.9 服务之间调用Feign 114
7.9.1 Feign如何使用 114
7.9.2 补充说明 118
7.10 服务追踪 119
7.10.1 Spring Cloud Sleuth介绍 119
7.10.2 Sleuth如何使用 120
7.10.3 日志聚合Zipkin 122
7.10.4 小结 127
7.11 Spring Cloud和Dubbo的比较 127
7.11.1 生的伟大 127
7.11.2 死的憋屈 127
7.11.3 没比较没伤害 128
7.11.4 现状 128
7.12 Spring Cloud与Spring Boot的关系 129
7.13 本章小结 130
第8章 其他相关技术和工具 131
8.1 数据库开发持续集成工具Liquibase 131
8.1.1 特性 132
8.1.2 使用 136
8.2 Swagger 144
8.2.1 为什么使用Swagger 144
8.2.2 如何使用 145
8.2.3 小结 149
8.3 权限spring security 150
8.4 微服务架构的通信方式 152
8.4.1 同步 153
8.4.2 异步 156
8.5 服务编排 160
8.6 管理工具JIRA 162
第9章 测试相关 166
9.1 单元测试 166
9.1.1 Mockito如何使用 168
9.1.2 Mock 与InjectMocks的区别 171
9.2 接口测试 173
9.3 代码质量管理工具Sonar 174
9.3.1 特点 174
9.3.2 使用 175
第三部分 项目实战篇
第10章 三个典型系统案例 188
10.1 企业运营支撑系统 188
10.1.1 背景 188
10.1.2 现状 188
10.1.3 原因调查 189
10.1.4 解决方案 190
10.2 车队管理系统 193
10.2.1 背景 193
10.2.2 技术架构 193
10.2.3 服务如何拆分 194
10.3 财务管理系统 195
10.3.1 背景 195
10.3.2 现状 195
10.3.3 原因调查 196
10.3.4 解决方案 196
10.4 本章小结 197
第11章 开发管理 198
11.1 管理原则 198
11.2 日常管理 198
11.3 代码质量管理 199
11.4 工作方式 199
11.5 BA的职责 199
11.6 SA的职责 200
11.7 DEV的工作原则 201
11.8 本章小结 201
后记 202
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>微服务那些事儿
