>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Spring 4.x
第1篇 基础篇
第1章 Spring概述\t2
1．1 认识Spring\t2
1．2 关于SpringSource\t4
1．3 Spring带给我们什么\t5
1．4 Spring体系结构\t6
1．5 Spring对Java版本的要求\t8
1．6 Spring 4．0新特性\t8
1．6．1 全面支持Java 8．0\t9
1．6．2 核心容器的增强\t11
1．6．3 支持用Groovy定义Bean\t12
1．6．4 Web的增强\t12
1．6．5 支持WebSocket\t12
1．6．6 测试的增强\t13
1．6．7 其他\t13
1．7 Spring子项目\t13
1．8 如何获取Spring\t15
1．9 小结\t16
第2章 快速入门\t17
2．1 实例概述\t17
2．1．1 比Hello World更适用的实例\t18
2．1．2 实例功能简介\t18
2．2 环境准备\t20
2．2．1 构建工具Maven\t20
2．2．2 创建库表\t22
2．2．3 建立工程\t23
2．2．4 类包及Spring配置文件规划\t28
2．3 持久层\t29
2．3．1 建立领域对象\t29
2．3．2 UserDao\t30
2．3．3 LoginLogDao\t33
2．3．4 在Spring中装配DAO\t34
2．4 业务层\t35
2．4．1 UserService\t35
2．4．2 在Spring中装配Service\t37
2．4．3 单元测试\t38
2．5 展现层\t40
2．5．1 配置Spring MVC框架\t40
2．5．2 处理登录请求\t42
2．5．3 JSP视图页面\t44
2．6 运行Web应用\t46
2．7 小结\t48
第3章 Spring Boot\t49
3．1 Spring Boot概览\t49
3．1．1 Spring Boot发展背景\t50
3．1．2 Spring Boot特点\t50
3．1．3 Spring Boot启动器\t50
3．2 快速入门\t52
3．3 安装配置\t54
3．3．1 基于Maven环境配置\t54
3．3．2 基于Gradle环境配置\t56
3．3．3 基于Spring Boot CLI环境
配置\t57
3．3．4 代码包结构规划\t58
3．4 持久层\t59
3．4．1 初始化配置\t59
3．4．2 UserDao\t61
3．5 业务层\t62
3．6 展现层\t64
3．6．1 配置pom．xml依赖\t64
3．6．2 配置Spring MVC框架\t65
3．6．3 处理登录请求\t65
3．7 运维支持\t67
3．8 小结\t70
第2篇 核心篇
第4章 IoC容器\t72
4．1 IoC概述\t72
4．1．1 通过实例理解IoC的概念\t73
4．1．2 IoC的类型\t75
4．1．3 通过容器完成依赖关系的
注入\t77
4．2 相关Java基础知识\t78
4．2．1 简单实例\t78
4．2．2 类装载器ClassLoader\t80
4．2．3 Java反射机制\t83
4．3 资源访问利器\t85
4．3．1 资源抽象接口\t85
4．3．2 资源加载\t88
4．4 BeanFactory和ApplicationContext\t91
4．4．1 BeanFactory介绍\t92
4．4．2 ApplicationContext介绍\t94
4．4．3 父子容器\t103
4．5 Bean的生命周期\t103
4．5．1 BeanFactory中Bean的生命
周期\t103
4．5．2 ApplicationContext中Bean
的生命周期\t112
4．6 小结\t114
第5章 在IoC容器中装配Bean\t115
5．1 Spring配置概述\t116
5．1．1 Spring容器高层视图\t116
5．1．2 基于XML的配置\t117
5．2 Bean基本配置\t120
5．2．1 装配一个Bean\t120
5．2．2 Bean的命名\t120
5．3 依赖注入\t121
5．3．1 属性注入\t121
5．3．2 构造函数注入\t124
5．3．3 工厂方法注入\t128
5．3．4 选择注入方式的考量\t130
5．4 注入参数详解\t130
5．4．1 字面值\t130
5．4．2 引用其他Bean\t131
5．4．3 内部Bean\t133
5．4．4 null值\t133
5．4．5 级联属性\t134
5．4．6 集合类型属性\t134
5．4．7 简化配置方式\t138
5．4．8 自动装配\t141
5．5 方法注入\t142
5．5．1 lookup方法注入\t142
5．5．2 方法替换\t143
5．6 ＜bean＞之间的关系\t144
5．6．1 继承\t144
5．6．2 依赖\t145
5．6．3 引用\t146
5．7 整合多个配置文件\t147
5．8 Bean作用域\t148
5．8．1 singleton作用域\t148
5．8．2 prototype作用域\t149
5．8．3 与Web应用环境相关的Bean
作用域\t150
5．8．4 作用域依赖问题\t152
5．9 FactoryBean\t153
5．10 基于注解的配置\t155
5．10．1 使用注解定义Bean\t155
5．10．2 扫描注解定义的Bean\t156
5．10．3 自动装配Bean\t157
5．10．4 Bean作用范围及生命过程
方法\t162
5．11 基于Java类的配置\t164
5．11．1 使用Java类提供Bean定义
信息\t164
5．11．2 使用基于Java类的配置信息
启动Spring容器\t167
5．12 基于Groovy DSL的配置\t169
5．12．1 使用Groovy DSL提供Bean
定义信息\t169
5．12．2 使用GenericGroovyApplication
Context启动Spring容器\t171
5．13 通过编码方式动态添加Bean\t172
5．13．1 通过DefaultListableBean
Factory\t172
5．13．2 扩展自定义标签\t173
5．14 不同配置方式比较\t175
5．15 小结\t177
第6章 Spring容器高级主题\t178
6．1 Spring容器技术内幕\t178
6．1．1 内部工作机制\t179
6．1．2 BeanDefinition\t182
6．1．3 InstantiationStrategy\t183
6．1．4 BeanWrapper\t183
6．2 属性编辑器\t184
6．2．1 JavaBean的编辑器\t185
6．2．2 Spring默认属性编辑器\t188
6．2．3 自定义属性编辑器\t189
6．3 使用外部属性文件\t192
6．3．1 PropertyPlaceholderConfigurer
属性文件\t192
6．3．2 使用加密的属性文件\t195
6．3．3 属性文件自身的引用\t198
6．4 引用Bean的属性值\t199
6．5 国际化信息\t201
6．5．1 基础知识\t201
6．5．2 MessageSource\t206
6．5．3 容器级的国际化信息资源\t209
6．6 容器事件\t210
6．6．1 Spring事件类结构\t211
6．6．2 解构Spring事件体系的具体
实现\t213
6．6．3 一个实例\t214
6．7 小结\t215
第7章 Spring AOP基础\t216
7．1 AOP概述\t216
7．1．1 AOP到底是什么\t217
7．1．2 AOP术语\t219
7．1．3 AOP的实现者\t221
7．2 基础知识\t222
7．2．1 带有横切逻辑的实例\t222
7．2．2 JDK动态代理\t224
7．2．3 CGLib动态代理\t228
7．2．4 AOP联盟\t229
7．2．5 代理知识小结\t230
7．3 创建增强类\t230
7．3．1 增强类型\t230
7．3．2 前置增强\t231
7．3．3 后置增强\t235
7．3．4 环绕增强\t236
7．3．5 异常抛出增强\t237
7．3．6 引介增强\t239
7．4 创建切面\t243
7．4．1 切点类型\t243
7．4．2 切面类型\t244
7．4．3 静态普通方法名匹配切面\t246
7．4．4 静态正则表达式方法匹配
切面\t248
7．4．5 动态切面\t251
7．4．6 流程切面\t254
7．4．7 复合切点切面\t256
7．4．8 引介切面\t258
7．5 自动创建代理\t259
7．5．1 实现类介绍\t259
7．5．2 BeanNameAutoProxyCreator\t260
7．5．3 DefaultAdvisorAutoProxy
Creator\t261
7．5．4 AOP无法增强疑难问题
剖析\t262
7．6 小结\t267
第8章 基于@AspectJ和Schema的
AOP\t269
8．1 Spring对AOP的支持\t269
8．2 Java 5．0注解知识快速进阶\t270
8．2．1 了解注解\t270
8．2．2 一个简单的注解类\t271
8．2．3 使用注解\t272
8．2．4 访问注解\t273
8．3 着手使用@AspectJ\t274
8．3．1 使用前的准备\t275
8．3．2 一个简单的例子\t275
8．3．3 如何通过配置使用@AspectJ
切面\t277
8．4 @AspectJ语法基础\t278
8．4．1 切点表达式函数\t278
8．4．2 在函数入参中使用通配符\t279
8．4．3 逻辑运算符\t280
8．4．4 不同增强类型\t281
8．4．5 引介增强用法\t282
8．5 切点函数详解\t283
8．5．1 @annotation()\t284
8．5．2 execution()\t285
8．5．3 args()和@args()\t287
8．5．4 within()\t288
8．5．5 @within()和@target()\t289
8．5．6 target()和this()\t290
8．6 @AspectJ进阶\t291
8．6．1 切点复合运算\t292
8．6．2 命名切点\t292
8．6．3 增强织入的顺序\t294
8．6．4 访问连接点信息\t294
8．6．5 绑定连接点方法入参\t295
8．6．6 绑定代理对象\t297
8．6．7 绑定类注解对象\t298
8．6．8 绑定返回值\t299
8．6．9 绑定抛出的异常\t299
8．7 基于Schema配置切面\t300
8．7．1 一个简单切面的配置\t300
8．7．2 配置命名切点\t302
8．7．3 各种增强类型的配置\t303
8．7．4 绑定连接点信息\t305
8．7．5 Advisor配置\t306
8．8 混合切面类型\t307
8．8．1 混合使用各种切面类型\t308
8．8．2 各种切面类型总结\t308
8．9 其他\t309
8．9．1 JVM Class文件字节码转换
基础知识\t309
8．9．2 使用LTW织入切面\t311
8．10 小结\t314
第9章 Spring SpEL\t316
9．1 JVM动态语言\t316
9．2 SpEL表达式概述\t318
9．3 SpEL核心接口\t319
9．3．1 EvaluationContext接口\t320
9．3．2 SpEL编译器\t321
9．4 SpEL基础表达式\t323
9．4．1 文本字符解析\t323
9．4．2 对象属性解析\t323
9．4．3 数组、集合类型解析\t324
9．4．4 方法解析\t326
9．4．5 操作符解析\t327
9．4．6 安全导航操作符\t329
9．4．7 三元操作符\t330
9．4．8 Elvis操作符\t331
9．4．9 赋值、类型、构造器、变量\t332
9．4．10 集合过滤\t335
9．4．11 集合转换\t335
9．5 在Spring中使用SpEL\t336
9．5．1 基于XML的配置\t336
9．5．2 基于注解的配置\t337
9．6 小结\t338
第3篇 数据篇
第10章 Spring对DAO的支持\t340
10．1 Spring的DAO理念\t340
10．2 统一的异常体系\t341
10．2．1 Spring的DAO异常体系\t341
10．2．2 JDBC的异常转换器\t343
10．2．3 其他持久化技术的异常
转换器\t344
10．3 统一数据访问模板\t344
10．3．1 使用模板和回调机制\t345
10．3．2 Spring为不同持久化技术
所提供的模板类\t347
10．4 数据源\t348
10．4．1 配置一个数据源\t348
10．4．2 获取JNDI数据源\t352
10．4．3 Spring的数据源实现类\t353
10．5 小结\t353
第11章 Spring的事务管理\t355
11．1 数据库事务基础知识\t355
11．1．1 何为数据库事务\t356
11．1．2 数据并发的问题\t357
11．1．3 数据库锁机制\t359
11．1．4 事务隔离级别\t360
11．1．5 JDBC对事务的支持\t361
11．2 ThreadLocal基础知识\t362
11．2．1 ThreadLocal是什么\t363
11．2．2 ThreadLocal的接口方法\t363
11．2．3 一个TheadLocal实例\t364
11．2．4 与Thread同步机制的比较\t366
11．2．5 Spring使用ThreadLocal解决
线程安全问题\t366
11．3 Spring对事务管理的支持\t368
11．3．1 事务管理关键抽象\t369
11．3．2 Spring的事务管理器实现类\t371
11．3．3 事务同步管理器\t374
11．3．4 事务传播行为\t375
11．4 编程式的事务管理\t376
11．5 使用XML配置声明式事务\t377
11．5．1 一个将被实施事务增强的
服务接口\t379
11．5．2 使用原始的TransactionProxy
FactoryBean\t379
11．5．3 基于aop/tx命名空间的配置\t382
11．6 使用注解配置声明式事务\t385
11．6．1 使用@Transactional注解\t385
11．6．2 通过AspectJ LTW引入事务
切面\t389
11．7 集成特定的应用服务器\t390
11．7．1 BEA WebLogic\t390
11．7．2 WebSphere\t390
11．8 小结\t390
第12章 Spring的事务管理难点剖析\t392
12．1 DAO和事务管理的牵绊\t393
12．1．1 JDBC访问数据库\t393
12．1．2 Hibernate访问数据库\t395
12．2 应用分层的迷惑\t398
12．3 事务方法嵌套调用的迷茫\t401
12．3．1 Spring事务传播机制回顾\t401
12．3．2 相互嵌套的服务方法\t402
12．4 多线程的困惑\t405
12．4．1 Spring通过单实例化Bean
简化多线程问题\t405
12．4．2 启动独立线程调用事务
方法\t405
12．5 联合军种作战的混乱\t408
12．5．1 Spring事务管理器的应对\t408
12．5．2 Hibernate+Spring JDBC
混合框架的事务管理\t408
12．6 特殊方法成漏网之鱼\t412
12．6．1 哪些方法不能实施Spring
AOP事务\t412
12．6．2 事务增强遗漏实例\t413
12．7 数据连接泄露\t416
12．7．1 底层连接资源的访问问题\t416
12．7．2 Spring JDBC数据连接泄露\t417
12．7．3 事务环境下通过DataSource
Utils获取数据连接\t420
12．7．4 无事务环境下通过DataSource
Utils获取数据连接\t422
12．7．5 JdbcTemplate如何做到对连接
泄露的免疫\t424
12．7．6 使用TransactionAwareData
SourceProxy\t425
12．7．7 其他数据访问技术的等价类\t426
12．8 小结\t426
第13章 使用Spring JDBC访问
数据库\t428
13．1 使用Spring JDBC\t428
13．1．1 JdbcTemplate小试牛刀\t429
13．1．2 在DAO中使用Jdbc
Template\t429
13．2 基本的数据操作\t431
13．2．1 更改数据\t431
13．2．2 返回数据库的表自增主键值\t434
13．2．3 批量更改数据\t436
13．2．4 查询数据\t437
13．2．5 查询单值数据\t440
13．2．6 调用存储过程\t442
13．3 BLOB/CLOB类型数据的操作\t444
13．3．1 如何获取本地数据连接\t445
13．3．2 相关的操作接口\t446
13．3．3 插入LOB类型的数据\t448
13．3．4 以块数据方式读取LOB
数据\t450
13．3．5 以流数据方式读取LOB
数据\t451
13．4 自增键和行集\t452
13．4．1 自增键的使用\t452
13．4．2 如何规划主键方案\t454
13．4．3 以行集返回数据\t456
13．5 NamedParameterJdbcTemplate
模板类\t456
13．6 小结\t459
第14章 整合其他ORM框架\t460
14．1 Spring整合ORM技术\t460
14．2 在Spring中使用Hibernate\t462
14．2．1 配置SessionFactory\t462
14．2．2 使用HibernateTemplate\t465
14．2．3 处理LOB类型的数据\t469
14．2．4 添加Hibernate事件监听器\t470
14．2．5 使用原生的Hibernate API\t471
14．2．6 使用注解配置\t472
14．2．7 事务处理\t474
14．2．8 延迟加载问题\t475
14．3 在Spring中使用MyBatis\t476
14．3．1 配置SqlMapClient\t476
14．3．2 在Spring中配置MyBatis\t478
14．3．3 编写MyBatis的DAO\t479
14．4 DAO层设计\t482
14．4．1 DAO基类设计\t482
14．4．2 查询接口方法设计\t484
14．4．3 分页查询接口设计\t486
14．5 小结\t487
第4篇 应用篇
第15章 Spring Cache\t490
15．1 缓存概述\t490
15．1．1 缓存的概念\t490
15．1．2 使用Spring Cache\t493
15．2 掌握Spring Cache抽象\t498
15．2．1 缓存注解\t498
15．2．2 缓存管理器\t504
15．2．3 使用SpEL表达式\t506
15．2．4 基于XML的Cache声明\t506
15．2．5 以编程方式初始化缓存\t507
15．2．6 自定义缓存注解\t509
15．3 配置Cache存储\t509
15．3．1 EhCache\t510
15．3．2 Guava\t510
15．3．3 HazelCast\t511
15．3．4 GemFire\t511
15．3．5 JSR-107 Cache\t511
15．4 实战经验\t513
15．5 小结\t514
第16章 任务调度和异步执行器\t516
16．1 任务调度概述\t516
16．2 Quartz快速进阶\t517
16．2．1 Quartz基础结构\t518
16．2．2 使用SimpleTrigger\t520
16．2．3 使用CronTrigger\t522
16．2．4 使用Calendar\t526
16．2．5 任务调度信息存储\t527
16．3 在Spring中使用Quartz\t530
16．3．1 创建JobDetail\t530
16．3．2 创建Trigger\t533
16．3．3 创建Scheduler\t534
16．4 在Spring中使用JDK Timer\t536
16．4．1 Timer和TimerTask\t536
16．4．2 Spring对Java Timer的支持\t539
16．5 Spring对Java 5．0 Executor的
支持\t540
16．5．1 了解Java 5．0的Executor\t541
16．5．2 Spring对Executor所提供的
抽象\t543
16．6 实际应用中的任务调度\t544
16．6．1 如何产生任务\t545
16．6．2 任务调度对应用程序集群的
影响\t547
16．6．3 任务调度云\t547
16．6．4 Web应用程序中调度器的
启动和关闭问题\t549
16．7 小结\t552
第17章 Spring MVC\t553
17．1 Spring MVC体系概述\t554
17．1．1 体系结构\t554
17．1．2 配置DispatcherServlet\t555
17．1．3 一个简单的实例\t560
17．2 注解驱动的控制器\t565
17．2．1 使用@RequestMapping
映射请求\t565
17．2．2 请求处理方法签名\t569
17．2．3 使用矩阵变量绑定参数\t570
17．2．4 请求处理方法签名详细说明\t571
17．2．5 使用HttpMessageConverter
＜T＞\t575
17．2．6 使用@RestController和AsyncRestTemplate\t584
17．2．7 处理模型数据\t586
17．3 处理方法的数据绑定\t591
17．3．1 数据绑定流程剖析\t592
17．3．2 数据转换\t592
17．3．3 数据格式化\t598
17．3．4 数据校验\t602
17．4 视图和视图解析器\t611
17．4．1 认识视图\t611
17．4．2 认识视图解析器\t612
17．4．3 JSP和JSTL\t613
17．4．4 模板视图\t618
17．4．5 Excel\t621
17．4．6 PDF\t623
17．4．7 输出XML\t625
17．4．8 输出JSON\t626
17．4．9 使用XmlViewResolver\t626
17．4．10 使用ResourceBundleView
Resolver\t627
17．4．11 混合使用多种视图技术\t628
17．5 本地化解析\t630
17．5．1 本地化的概念\t630
17．5．2 使用CookieLocaleResolver\t631
17．5．3 使用SessionLocaleResolver\t632
17．5．4 使用LocaleChange
Interceptor\t632
17．6 文件上传\t633
17．6．1 配置MultipartResolver\t633
17．6．2 编写控制器和文件上传表单
页面\t633
17．7 WebSocket支持\t634
17．7．1 使用WebSocket\t634
17．7．2 WebSocket的限制\t638
17．8 杂项\t639
17．8．1 静态资源处理\t639
17．8．2 装配拦截器\t643
17．8．3 异常处理\t644
17．8．4 RequestContextHolder的
使用\t646
17．9 小结\t646
第18章 实战案例开发\t648
18．1 论坛案例概述\t648
18．1．1 论坛整体功能结构\t648
18．1．2 论坛用例描述\t649
18．1．3 主要功能流程描述\t651
18．2 系统设计\t655
18．2．1 技术框架选择\t655
18．2．2 采用Maven构建项目\t656
18．2．3 单元测试类包结构规划\t657
18．2．4 系统架构图\t658
18．2．5 PO类设计\t658
18．2．6 持久层设计\t659
18．2．7 服务层设计\t660
18．2．8 Web层设计\t661
18．2．9 数据库设计\t662
18．3 开发前的准备\t663
18．4 持久层开发\t664
18．4．1 PO类\t664
18．4．2 DAO基类\t666
18．4．3 通过扩展基类定义DAO类\t670
18．4．4 DAO Bean的装配\t672
18．4．5 使用Hibernate二级缓存\t673
18．5 对持久层进行测试\t675
18．5．1 配置Unitils测试环境\t675
18．5．2 准备测试数据库及测试
数据\t676
18．5．3 编写DAO测试基类\t677
18．5．4 编写BoardDao测试用例\t678
18．6 服务层开发\t680
18．6．1 UserService的开发\t680
18．6．2 ForumService的开发\t681
18．6．3 服务类Bean的装配\t683
18．7 对服务层进行测试\t684
18．7．1 编写Service测试基类\t685
18．7．2 编写ForumService测试
用例\t685
18．8 Web层开发\t687
18．8．1 BaseController的基类\t687
18．8．2 用户登录和注销\t689
18．8．3 用户注册\t691
18．8．4 论坛管理\t692
18．8．5 论坛普通功能\t694
18．8．6 分页显示论坛版块的主题
帖子\t696
18．8．7 web．xml配置\t700
18．8．8 Spring MVC配置\t702
18．9 对Web层进行测试\t703
18．9．1 编写Web测试基类\t703
18．9．2 编写ForumManageController
测试用例\t704
18．10 开发环境部署\t705
18．11 项目配置实战经验\t708
18．11．1 “传统的”Web项目属性
文件\t708
18．11．2 如何规划便于部署的Web
项目属性文件\t709
18．11．3 数据源的配置\t710
18．12 小结\t712
第5篇 提高篇
第19章 Spring OXM\t714
19．1 认识XML解析技术\t714
19．1．1 什么是XML\t714
19．1．2 XML的处理技术\t715
19．2 XML处理利器：XStream\t717
19．2．1 XStream概述\t717
19．2．2 快速入门\t718
19．2．3 使用XStream别名\t720
19．2．4 XStream转换器\t721
19．2．5 XStream注解\t723
19．2．6 流化对象\t725
19．2．7 持久化API\t726
19．2．8 额外功能：处理JSON\t727
19．3 其他常见的O/X Mapping开源
项目\t729
19．3．1 JAXB\t729
19．3．2 Castor\t733
19．3．3 JiBX\t738
19．3．4 总结比较\t741
19．4 与Spring OXM整合\t742
19．4．1 Spring OXM概述\t742
19．4．2 整合OXM实现者\t744
19．4．3 如何在Spring中进行配置\t744
19．4．4 Spring OXM简单实例\t747
19．5 小结\t749
第20章 实战型单元测试\t750
20．1 单元测试概述\t751
20．1．1 为什么需要单元测试\t751
20．1．2 单元测试之误解\t752
20．1．3 单元测试之困境\t754
20．1．4 单元测试基本概念\t755
20．2 TestNG快速进阶\t757
20．2．1 TestNG概述\t757
20．2．2 TestNG生命周期\t758
20．2．3 使用TestNG\t758
20．3 模拟利器Mockito\t763
20．3．1 模拟测试概述\t763
20．3．2 创建Mock对象\t763
20．3．3 设定Mock对象的期望行为
及返回值\t764
20．3．4 验证交互行为\t766
20．4 测试整合之王Unitils\t767
20．4．1 Unitils概述\t767
20．4．2 集成Spring\t770
20．4．3 集成Hibernate\t773
20．4．4 集成DbUnit\t774
20．4．5 自定义扩展模块\t775
20．5 使用Unitils测试DAO层\t776
20．5．1 数据库测试的难点\t776
20．5．2 扩展DbUnit用Excel准备
数据\t776
20．5．3 测试实战\t779
20．6 使用Unitils测试Service层\t789
20．7 测试Web层\t794
20．7．1 对LoginController进行单元
测试\t794
20．7．2 使用Spring Servlet API模拟
对象\t795
20．7．3 使用Spring RestTemplate
测试\t797
20．8 小结\t798
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Spring 4.x
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻量级Java EE企业应用实战（第4版）
第1章　Java EE应用和开发环境	1
1.1　Java EE应用概述	2
1.1.1　Java EE应用的分层模型	2
1.1.2　Java EE应用的组件	3
1.1.3　Java EE应用的结构和优势	4
1.1.4　常用的Java EE服务器	4
1.2  轻量级Java EE应用相关技术	5
1.2.1  JSP、Servlet 3.x和JavaBean及替代技术	5
1.2.2  Struts 2.3及替代技术	5
1.2.3  Hibernate 4.3及替代技术	6
1.2.4  Spring 4.0及替代技术	6
1.3  Tomcat的下载和安装	7
1.3.1  安装Tomcat服务器	7
1.3.2  配置Tomcat的服务端口	9
1.3.3  进入控制台	9
1.3.4  部署Web应用	12
1.3.5  配置Tomcat的数据源	12
1.4  Eclipse的安装和使用	14
1.4.1  Eclipse的下载和安装	14
1.4.2  在线安装Eclipse插件	14
1.4.3  从本地压缩包安装插件	16
1.4.4  手动安装Eclipse插件	17
1.4.5  使用Eclipse开发Java EE应用	17
1.4.6  导入Eclipse项目	20
1.4.7  导入非Eclipse项目	21
1.5  Ant的安装和使用	22
1.5.1  Ant的下载和安装	22
1.5.2  使用Ant工具	23
1.5.3  定义生成文件	24
1.5.4  Ant的任务（task）	29
1.6  Maven的安装和使用	31
1.6.1  下载和安装Maven	31
1.6.2  设置Maven	32
1.6.3  创建、构建简单的项目	33
1.6.4  Maven的核心概念	36
1.6.5  依赖管理	41
1.6.6  POM文件的元素	44
1.7  使用SVN进行协作开发	44
1.7.1  下载和安装SVN服务器	45
1.7.2  配置SVN资源库	46
1.7.3  下载和安装SVN客户端	47
1.7.4  将项目发布到服务器	48
1.7.5  从服务器下载项目	48
1.7.6  提交（Commit）修改	49
1.7.7  同步（Update）本地文件	49
1.7.8  添加文件和目录	50
1.7.9  删除文件和目录	50
1.7.10 查看文件或目录的版本变革	51
1.7.11 从以前版本重新开始	51
1.7.12 创建分支	52
1.7.13 沿着分支开发	52
1.7.14 合并分支	53
1.7.15 使用Eclipse作为SVN客户端	54
1.8  本章小结	57
第2章　JSP/Servlet及相关技术详解	58
2.1  Web应用和web.xml文件	59
2.1.1  构建Web应用	59
2.1.2  配置描述符web.xml	60
2.2  JSP的基本原理	61
2.3  JSP的4种基本语法	65
2.3.1  JSP注释	65
2.3.2  JSP声明	66
2.3.3  输出JSP表达式	67
2.3.4  JSP脚本	68
2.4  JSP的3个编译指令	70
2.4.1  page指令	70
2.4.2  include指令	74
2.5  JSP的7个动作指令	75
2.5.1  forward指令	75
2.5.2  include指令	77
2.5.3  useBean、setProperty、getProperty指令	79
2.5.4  plugin指令	81
2.5.5  param指令	81
2.6  JSP脚本中的9个内置对象	82
2.6.1  application对象	83
2.6.2  config对象	88
2.6.3  exception对象	90
2.6.4  out对象	92
2.6.5  pageContext对象	93
2.6.6  request对象	95
2.6.7  response对象	102
2.6.8  session对象	106
2.7  Servlet介绍	108
2.7.1  Servlet的开发	108
2.7.2  Servlet的配置	110
2.7.3  JSP/Servlet的生命周期	111
2.7.4  load-on-startup Servlet	112
2.7.5  访问Servlet的配置参数	113
2.7.6  使用Servlet作为控制器	115
2.8  JSP 2的自定义标签	119
2.8.1  开发自定义标签类	120
2.8.2  建立TLD文件	120
2.8.3  使用标签库	121
2.8.4  带属性的标签	122
2.8.5  带标签体的标签	125
2.8.6  以页面片段作为属性的标签	128
2.8.7  动态属性的标签	129
2.9  Filter介绍	131
2.9.1  创建Filter类	132
2.9.2  配置Filter	133
2.9.3  使用URL Rewrite实现网站伪静态	136
2.10  Listener介绍	137
2.10.1 实现Listener类	138
2.10.2 配置Listener	139
2.10.3 使用ServletContextAttributeListener	140
2.10.4 使用ServletRequestListener和ServletRequestAttributeListener	141
2.10.5 使用HttpSessionListener和HttpSessionAttributeListener	142
2.11  JSP 2特性	147
2.11.1 配置JSP属性	147
2.11.2 表达式语言	149
2.11.3  Tag File支持	157
2.12  Servlet 3.0新特性	159
2.12.1  Servlet 3.0的注解	159
2.12.2  Servlet 3.0的Web模块支持	160
2.12.3  Servlet 3.0提供的异步处理	162
2.12.4改进的Servlet API	165
2.13  Servlet 3.1新增的非阻塞式IO	167
2.14  Tomcat 8的WebSocket支持	170
2.15 本章小结	174
第3章　Struts 2的基本用法	175
3.1  MVC思想概述	176
3.1.1  传统Model 1和Model 2	176
3.1.2  MVC思想及其优势	177
3.2  Struts 2的下载和安装	178
3.2.1  为Web应用增加Struts 2支持	178
3.2.2  在Eclipse中使用Struts 2	179
3.2.3  增加登录处理	180
3.3  Struts 2的流程	183
3.3.1  Struts 2应用的开发步骤	183
3.3.2  Struts 2的流程	184
3.4  Struts 2的常规配置	185
3.4.1  常量配置	185
3.4.2  包含其他配置文件	191
3.5  实现Action	191
3.5.1  Action接口和ActionSupport基类	193
3.5.2  Action访问Servlet API	195
3.5.3  Action直接访问Servlet API	197
3.5.4  使用ServletActionContext访问Servlet API	199
3.6  配置Action	200
3.6.1  包和命名空间	200
3.6.2  Action的基本配置	203
3.6.3  使用Action的动态方法调用	204
3.6.4  指定method属性及使用通配符	205
3.6.5  配置默认Action	211
3.6.6  配置Action的默认处理类	211
3.7  配置处理结果	212
3.7.1  理解处理结果	212
3.7.2  配置结果	213
3.7.3  Struts 2支持的结果类型	214
3.7.4  plainText结果类型	215
3.7.5  redirect结果类型	217
3.7.6  redirectAction结果类型	218
3.7.7  动态结果	219
3.7.8  Action属性值决定物理视图资源	219
3.7.9  全局结果	221
3.7.10  使用PreResultListener	222
3.8  配置Struts 2的异常处理	223
3.8.1  Struts 2的异常处理机制	223
3.8.2  声明式异常捕捉	225
3.8.3  输出异常信息	226
3.9  Convention插件与“约定”支持	227
3.9.1  Action的搜索和映射约定	228
3.9.2  按约定映射Result	230
3.9.3  Action链的约定	233
3.9.4  自动重加载映射	234
3.9.5  Convention插件的相关常量	234
3.9.6  Convention插件相关Annotation	235
3.10  使用Struts 2的国际化	235
3.10.1  视图页面的国际化	235
3.10.2  Action的国际化	236
3.10.3  使用包范围的国际化资源	238
3.10.4  使用全局国际化资源	239
3.10.5  输出带占位符的国际化消息	241
3.10.6  加载资源文件的顺序	243
3.11  使用Struts 2的标签库	243
3.11.1  Struts 2标签库概述	243
3.11.2  使用Struts 2标签	244
3.11.3  Struts 2的OGNL表达式语言	245
3.11.4  OGNL中的集合操作	247
3.11.5  访问静态成员	248
3.11.6  Lambda（）表达式	248
3.11.7  控制标签	249
3.11.8  数据标签	259
3.11.9  主题和模板	268
3.11.10  自定义主题	270
3.11.11  表单标签	271
3.11.12  非表单标签	284
3.12  本章小结	287
第4章　深入使用Struts 2	288
4.1  详解Struts 2的类型转换	289
4.1.1  Struts 2内建的类型转换器	290
4.1.2  基于OGNL的类型转换	290
4.1.3  指定集合元素的类型	292
4.1.4  自定义类型转换器	294
4.1.5  注册类型转换器	297
4.1.6  基于Struts 2的自定义类型转换器	298
4.1.7  处理Set集合	299
4.1.8  类型转换中的错误处理	301
4.2  使用Struts 2的输入校验	307
4.2.1  编写校验规则文件	307
4.2.2  国际化提示信息	310
4.2.3  使用客户端校验	311
4.2.4  字段校验器配置风格	312
4.2.5  非字段校验器配置风格	313
4.2.6  短路校验器	315
4.2.7  校验文件的搜索规则	316
4.2.8  校验顺序和短路	318
4.2.9  内建校验器	318
4.2.10  基于注解的输入校验	329
4.2.11  手动完成输入校验	330
4.3  使用Struts 2控制文件上传	334
4.3.1  Struts 2的文件上传	334
4.3.2  实现文件上传的Action	335
4.3.3  配置文件上传的Action	337
4.3.4  手动实现文件过滤	338
4.3.5  拦截器实现文件过滤	340
4.3.6  输出错误提示	341
4.3.7  文件上传的常量配置	342
4.4  使用Struts 2控制文件下载	343
4.4.1  实现文件下载的Action	343
4.4.2  配置Action	343
4.4.3  下载前的授权控制	344
4.5  详解Struts 2的拦截器机制	345
4.5.1  拦截器在Struts 2中的作用	346
4.5.2  Struts 2内建的拦截器	346
4.5.3  配置拦截器	348
4.5.4  使用拦截器的配置语法	349
4.5.5  配置默认拦截器	350
4.5.6  实现拦截器类	351
4.5.7  使用拦截器	353
4.5.8  拦截方法的拦截器	354
4.5.9  拦截器的执行顺序	356
4.5.10 拦截结果的监听器	358
4.5.11 覆盖拦截器栈里特定拦截器的参数	359
4.5.12 使用拦截器完成权限控制	360
4.6  使用Struts 2的Ajax支持	362
4.6.1  使用stream类型的Result实现Ajax	363
4.6.2  JSON的基本知识	365
4.6.3  实现Action逻辑	367
4.6.4  JSON插件与json类型的Result	368
4.6.5  实现JSP页面	370
4.7  本章小结	371
第5章　Hibernate的基本用法	372
5.1  ORM和Hibernate	373
5.1.1  对象/关系数据库映射（ORM）	373
5.1.2  基本映射方式	374
5.1.3  流行的ORM框架简介	375
5.1.4  Hibernate概述	376
5.2  Hibernate入门	376
5.2.1  Hibernate下载和安装	376
5.2.2  Hibernate的数据库操作	377
5.2.3  在Eclipse中使用Hibernate	381
5.3  Hibernate的体系结构	386
5.4  深入Hibernate配置文件	388
5.4.1  创建Configuration对象	388
5.4.2  hibernate.properties文件与hibernate.cfg.xml文件	390
5.4.3  JDBC连接属性	390
5.4.4  数据库方言	391
5.4.5  JNDI数据源的连接属性	393
5.4.6  Hibernate事务属性	393
5.4.7  二级缓存相关属性	393
5.4.8  外连接抓取属性	394
5.4.9  其他常用的配置属性	394
5.5  深入理解持久化对象	394
5.5.1  持久化类的要求	395
5.5.2  持久化对象的状态	396
5.5.3  改变持久化对象状态的方法	397
5.6  深入Hibernate映射	399
5.6.1  映射属性	402
5.6.2  映射主键	409
5.6.3  使用Hibernate的主键生成策略	411
5.6.4  映射集合属性	412
5.6.5  集合属性的性能分析	419
5.6.6  有序集合映射	420
5.6.7  映射数据库对象	422
5.7　映射组件属性	424
5.7.1　组件属性为集合	426
5.7.2　集合属性的元素为组件	427
5.7.3  组件作为Map的索引	429
5.7.4  组件作为复合主键	430
5.7.5  多列作为联合主键	432
5.8  使用传统的映射文件	433
5.8.1  增加XML映射文件	433
5.8.2  注解，还是XML映射文件	436
5.9  本章小结	436
第6章　深入使用Hibernate	437
6.1  Hibernate的关联映射	438
6.1.1  单向N－1关联	438
6.1.2  单向1－1关联	443
6.1.3  单向1－N关联	444
6.1.4  单向N－N关联	448
6.1.5  双向1－N关联	449
6.1.6  双向N－N关联	452
6.1.7  双向1－1关联	454
6.1.8  组件属性包含的关联实体	456
6.1.9  基于复合主键的关联关系	458
6.1.10 复合主键的成员属性为关联实体	460
6.1.11 持久化的传播性	463
6.2  继承映射	464
6.2.1  整个类层次对应一个表的映射策略	466
6.2.2  连接子类的映射策略	468
6.2.3  每个具体类对应一个表的映射策略	471
6.3  Hibernate的批量处理	473
6.3.1  批量插入	473
6.3.2  批量更新	474
6.3.3  DML风格的批量更新/删除	475
6.4  使用HQL查询	476
6.4.1  HQL查询	476
6.4.2  HQL查询的from子句	478
6.4.3  关联和连接	479
6.4.4  HQL查询的select子句	482
6.4.5  HQL查询的聚集函数	482
6.4.6  多态查询	483
6.4.7  HQL查询的where子句	483
6.4.8  表达式	484
6.4.9  order by子句	486
6.4.10  group by子句	486
6.4.11  子查询	487
6.4.12  命名查询	487
6.5  条件查询	489
6.5.1  关联和动态关联	491
6.5.2  投影、聚合和分组	493
6.5.3  离线查询和子查询	496
6.6  SQL查询	497
6.6.1  标量查询	497
6.6.2  实体查询	499
6.6.3  处理关联和继承	501
6.6.4  命名SQL查询	502
6.6.5  调用存储过程	504
6.6.6  使用定制SQL	505
6.7  数据过滤	507
6.8  事务控制	510
6.8.1  事务的概念	510
6.8.2  Session与事务	511
6.8.3  上下文相关的Session	513
6.9  二级缓存和查询缓存	514
6.9.1  开启二级缓存	514
6.9.2  管理缓存和统计缓存	517
6.9.3  使用查询缓存	518
6.10  事件机制	520
6.10.1  拦截器	521
6.10.2  事件系统	523
6.11  本章小结	525
第7章　Spring的基本用法	526
7.1  Spring简介和Spring 4.0的变化	527
7.1.1  Spring简介	527
7.1.2  Spring 4.0的变化	528
7.2  Spring入门	528
7.2.1  Spring下载和安装	528
7.2.2  使用Spring管理Bean	529
7.2.3  在Eclipse中使用Spring	532
7.3  Spring的核心机制：依赖注入	535
7.3.1  理解依赖注入	536
7.3.2  设值注入	538
7.3.3  构造注入	541
7.3.4  两种注入方式的对比	543
7.4  使用Spring容器	543
7.4.1  Spring容器	544
7.4.2  使用ApplicationContext	545
7.4.3  ApplicationContext的国际化支持	546
7.4.4  ApplicationContext的事件机制	548
7.4.5  让Bean获取Spring容器	551
7.5  Spring容器中的Bean	552
7.5.1  Bean的基本定义和Bean别名	553
7.5.2  容器中Bean的作用域	554
7.5.3  配置依赖	557
7.5.4  设置普通属性值	559
7.5.5  配置合作者Bean	560
7.5.6  使用自动装配注入合作者Bean	561
7.5.7  注入嵌套Bean	563
7.5.8  注入集合值	564
7.5.9  组合属性	568
7.5.10  Spring的Bean和JavaBean	569
7.6  Spring 3.0提供的Java配置管理	571
7.7  创建Bean的3种方式	573
7.7.1  使用构造器创建Bean实例	574
7.7.2  使用静态工厂方法创建Bean	574
7.7.3  调用实例工厂方法创建Bean	576
7.8  深入理解容器中的Bean	578
7.8.1  抽象Bean与子Bean	578
7.8.2  Bean继承与Java继承的区别	580
7.8.3  容器中的工厂Bean	580
7.8.4  获得Bean本身的id	582
7.8.5  强制初始化Bean	583
7.9  容器中Bean的生命周期	584
7.9.1  依赖关系注入之后的行为	584
7.9.2  Bean销毁之前的行为	586
7.9.3  协调作用域不同步的Bean	589
7.10  高级依赖关系配置	592
7.10.1 获取其他Bean的属性值	592
7.10.2 获取Field值	595
7.10.3 获取方法返回值	596
7.11  基于XML Schema的简化配置方式	599
7.11.1 使用p:命名空间简化配置	599
7.11.2 使用c:命名空间简化配置	601
7.11.3 使用util:命名空间简化配置	602
7.12  Spring 3.0提供的表达式语言（SpEL）	604
7.12.1 使用Expression接口进行表达式求值	604
7.12.2  Bean定义中的表达式语言支持	606
7.12.3  SpEL语法详述	607
7.13  本章小结	612
第8章　深入使用Spring	613
8.1  两种后处理器	614
8.1.1  Bean后处理器	614
8.1.2  Bean后处理器的用处	617
8.1.3  容器后处理器	618
8.1.4  属性占位符配置器	619
8.1.5  重写占位符配置器	620
8.2  Spring的“零配置”支持	622
8.2.1  搜索Bean类	622
8.2.2  指定Bean的作用域	625
8.2.3  使用@Resource配置依赖	625
8.2.4  使用@PostConstruct和@PreDestroy定制生命周期行为	626
8.2.5  Spring 3.0新增的注解	627
8.2.6  Spring 4.0增强的自动装配和精确装配	627
8.3  资源访问	631
8.3.1  Resource实现类	632
8.3.2  ResourceLoader接口和ResourceLoaderAware接口	636
8.3.3  使用Resource作为属性	639
8.3.4  在ApplicationContext中使用资源	640
8.4  Spring的AOP	643
8.4.1  为什么需要AOP	643
8.4.2  使用AspectJ实现AOP	644
8.4.3  AOP的基本概念	651
8.4.4  Spring的AOP支持	652
8.4.5  基于注解的“零配置”方式	653
8.4.6  基于XML配置文件的管理方式	667
8.5  Spring 3.1新增的缓存机制	673
8.5.1  启用Spring缓存	674
8.5.2  使用@Cacheable执行缓存	676
8.5.3  使用@CacheEvict清除缓存	680
8.6  Spring的事务	681
8.6.1  Spring支持的事务策略	681
8.6.2  使用XML Schema配置事务策略	686
8.6.3  使用@Transactional	692
8.7  Spring整合Struts 2	693
8.7.1  启动Spring容器	693
8.7.2  MVC框架与Spring整合的思考	694
8.7.3  让Spring管理控制器	695
8.7.4  使用自动装配	699
8.8  Spring整合Hibernate	701
8.8.1  Spring提供的DAO支持	701
8.8.2  管理Hibernate的SessionFactory	702
8.8.3  实现DAO组件的基类	703
8.8.4  传统的HibernateTemplate和HibernateDaoSupport	706
8.8.5  实现DAO组件	709
8.8.6  使用IoC容器组装各种组件	709
8.8.7  使用声明式事务	712
8.9  Spring整合JPA	713
8.9.1  管理EntityManagerFactory	713
8.9.2  实现DAO组件基类	715
8.9.3  使用声明式事务	718
8.10  本章小结	719
第9章　企业应用开发的思考和策略	720
9.1  企业应用开发面临的挑战	721
9.1.1  可扩展性、可伸缩性	721
9.1.2  快捷、可控的开发	722
9.1.3  稳定性、高效性	722
9.1.4  花费最小化，利益最大化	723
9.2  如何面对挑战	723
9.2.1  使用建模工具	723
9.2.2  利用优秀的框架	723
9.2.3  选择性地扩展	725
9.2.4  使用代码生成器	726
9.3  常见设计模式精讲	726
9.3.1  单例模式	727
9.3.2  简单工厂	728
9.3.3  工厂方法和抽象工厂	734
9.3.4  代理模式	737
9.3.5  命令模式	742
9.3.6  策略模式	745
9.3.7  门面模式	748
9.3.8  桥接模式	750
9.3.9  观察者模式	754
9.4  常见的架构设计策略	757
9.4.1  贫血模型	757
9.4.2  领域对象模型	760
9.4.3  合并业务逻辑对象与DAO对象	762
9.4.4  合并业务逻辑对象和Domain Object	763
9.4.5  抛弃业务逻辑层	764
9.5  本章小结	765
第10章　简单工作流系统	766
10.1  项目背景及系统结构	767
10.1.1  应用背景	767
10.1.2  系统功能介绍	767
10.1.3  相关技术介绍	768
10.1.4  系统结构	768
10.1.5  系统的功能模块	769
10.2  Hibernate持久层	770
10.2.1  设计持久化实体	770
10.2.2  创建持久化实体类	771
10.3  实现DAO层	777
10.3.1  DAO组件的定义	778
10.3.2  实现DAO组件	780
10.3.3  部署DAO层	783
10.4  实现Service层	784
10.4.1  业务逻辑组件的设计	785
10.4.2  实现业务逻辑组件	785
10.4.3  事务管理	790
10.4.4  部署业务逻辑组件	791
10.5  实现任务的自动调度	791
10.5.1  使用Quartz	791
10.5.2  在Spring中使用Quartz	795
10.6  实现系统Web层	798
10.6.1  Struts 2和Spring的整合	798
10.6.2  控制器的处理顺序图	799
10.6.3  员工登录	799
10.6.4  进入打卡	802
10.6.5  处理打卡	803
10.6.6  进入申请	805
10.6.7  提交申请	806
10.6.8  使用拦截器完成权限管理	808
10.7  本章小结	809
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻量级Java EE企业应用实战（第4版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring实战（第4版）
第1部分　Spring的核心
第1章　Spring之旅　3
1.1　简化Java开发　4
1.1.1　激发POJO的潜能　5
1.1.2　依赖注入　5
1.1.3　应用切面　11
1.1.4　使用模板消除样板式代码　16
1.2　容纳你的Bean　18
1.2.1　使用应用上下文　19
1.2.2　bean的生命周期　20
1.3　俯瞰Spring风景线　21
1.3.1　Spring模块　22
1.3.2　Spring Portfolio　24
1.4　Spring的新功能　27
1.4.1　Spring 3.1新特性　27
1.4.2　Spring 3.2新特性　28
1.4.3　Spring 4.0新特性　30
1.5　小结　30
第2章　装配Bean　33
2.1　Spring配置的可选方案　34
2.2　自动化装配bean　35
2.2.1　创建可被发现的bean　35
2.2.2　为组件扫描的bean命名　38
2.2.3　设置组件扫描的基础包　39
2.2.4　通过为bean添加注解实现自动装配　40
2.2.5　验证自动装配　42
2.3　通过Java代码装配
bean　44
2.3.1　创建配置类　44
2.3.2　声明简单的bean　45
2.3.3　借助JavaConfig实现注入　46
2.4　通过XML装配bean　48
2.4.1　创建XML配置规范　48
2.4.2　声明一个简单的
[bean]　49
2.4.3　借助构造器注入初始化bean　50
2.4.4　设置属性　56
2.5　导入和混合配置　61
2.5.1　在JavaConfig中引用XML配置　61
2.5.2　在XML配置中引用JavaConfig　63
2.6　小结　65
第3章　高级装配　67
3.1　环境与profile　67
3.1.1　配置profile bean　69
3.1.2　激活profile　73
3.2　条件化的bean　75
3.3　处理自动装配的歧义性　78
3.3.1　标示首选的bean　79
3.3.2　限定自动装配的bean　80
3.4　bean的作用域　84
3.4.1　使用会话和请求作用域　86
3.4.2　在XML中声明作用域代理　88
3.5　运行时值注入　88
3.5.1　注入外部的值　89
3.5.2　使用Spring表达式语言进行装配　93
3.6　小结　99
第4章　面向切面的Spring　101
4.1　什么是面向切面编程？　102
4.1.1　定义AOP术语　103
4.1.2　Spring对AOP的支持　105
4.2　通过切点来选择连接点　107
4.2.1　编写切点　108
4.2.2　在切点中选择bean　109
4.3　使用注解创建切面　109
4.3.1　定义切面　110
4.3.2　创建环绕通知　114
4.3.3　处理通知中的参数　115
4.3.4　通过注解引入新功能　118
4.4　在XML中声明切面　120
4.4.1　声明前置和后置通知　122
4.4.2　声明环绕通知　124
4.4.3　为通知传递参数　125
4.4.4　通过切面引入新的功能　127
4.5　注入AspectJ切面　128
4.5　小结　131
第２部分　Web中的Spring
第5章　构建Spring Web应用程序　135
5.1　Spring MVC起步　136
5.1.1　跟踪Spring MVC的请求　136
5.1.2　搭建Spring MVC　138
5.1.3　Spittr应用简介　142
5.2　编写基本的控制器　143
5.2.1　测试控制器　145
5.2.2　定义类级别的请求处理　146
5.2.3　传递模型数据到视图中　147
5.3　接受请求的输入　153
5.3.1　处理查询参数　153
5.3.2　通过路径参数接受输入　155
5.4　处理表单　157
5.4.1　编写处理表单的控制器　160
5.4.2　校验表单　163
5.5　小结　166
第6章　渲染Web视图　167
6.1　理解视图解析　167
6.2　创建JSP视图　170
6.2.1　配置适用于JSP的视图解析器　170
6.2.2　使用Spring的JSP库　172
6.3　使用Apache Tiles视图定义布局　184
6.3.1　配置Tiles视图解析器　185
6.4　使用Thymeleaf　190
6.4.1　配置Thymeleaf视图解析器　190
6.4.2　定义Thymeleaf模板　192
6.5　小结　196
第7章　Spring MVC的高级技术　197
7.1　Spring MVC配置的替代方案　198
7.1.1　自定义DispatcherServlet配置　198
7.1.2　添加其他的Servlet和Filter　199
7.1.3　在web.xml中声明DispatcherServlet　201
7.2　处理multipart形式的数据　204
7.2.1　配置multipart解析器　205
7.2.2　处理multipart请求　208
7.3　处理异常　212
7.3.1　将异常映射为HTTP状态码　213
7.3.2　编写异常处理的方法　214
7.4　为控制器添加通知　216
7.5　跨重定向请求传递数据　217
7.5.1　通过URL模板进行重定向　218
7.5.2　使用flash属性　219
7.6　小结　221
第8章　使用Spring WebFlow　223
8.1　在Spring中配置Web　Flow　224
8.1.1　装配流程执行器　224
8.1.2　配置流程注册表　224
8.1.3　处理流程请求　225
8.2　流程的组件　226
8.2.1　状态　226
8.2.2　转移　230
8.2.3　流程数据　231
8.3　组合起来：披萨流程　232
8.3.1　定义基本流程　233
8.3.2　收集顾客信息　236
8.3.2　构建订单　242
8.3.2　支付　244
8.4　保护Web流程　246
8.5　小结　246
第9章　保护Web应用　249
9.1　Spring Security简介　250
9.1.1　理解Spring Security的模块　250
9.1.2　过滤Web请求　251
9.1.3　编写简单的安全性配置　252
9.2　选择查询用户详细信息的服务　255
9.2.1使用基于内存的用户存储　255
9.2.2　基于数据库表进行认证　257
9.2.3　基于LDAP进行认证　259
9.2.4　配置自定义的用户服务　263
9.3　拦截请求　265
9.3.1　使用Spring表达式进行安全保护　267
9.3.2　强制通道的安全性　269
9.3.3　防止跨站请求伪造　270
9.4　认证用户　271
9.4.1　添加自定义的登录页　272
9.4.2　启用HTTP Basic认证　274
9.4.3　启用Remember-me功能　274
9.4.4　退出　275
9.5　保护视图　276
9.5.1　使用Spring Security的JSP标签库　276
9.5.2　使用Thymeleaf的SpringSecurity方言　280
9.6　小结　281
第3部分　后端中的Spring
第10章　通过Spring和JDBC征服数据库　285
10.1　Spring的数据访问哲学　286
10.1.1　了解Spring的数据访问异常体系　287
10.1.2　数据访问模板化　289
10.2　配置数据源　291
10.2.1　使用JNDI数据源　292
10.2.2　使用数据源连接池　292
10.2.3　基于JDBC驱动的数据源　294
10.2.4　使用嵌入式的数据源　295
10.2.5　使用profile选择数据源　296
10.3　在Spring中使用
JDBC　298
10.3.1　应对失控的JDBC代码　299
10.3.2　使用JDBC模板　302
10.4　小结　307
第11章　使用对象-关系映射持久化数据　309
11.1　在Spring中集成Hibernate　310
11.1.1　声明Hibernate的Session工厂　311
11.1.2　构建不依赖于Spring的Hibernate代码　313
11.2　Spring与Java持久化API　315
11.2.1　配置实体管理器工厂　315
11.2.2　编写基于JPA的Repository　320
11.3　借助Spring Data实现自动化的JPA　Repository　322
11.3.1　定义查询方法　325
11.3.2　声明自定义查询　328
11.3.3　混合自定义的功能　329
11.4　小结　330
第12章　使用NoSQL数据库　333
12.1　使用MongoDB持久化文档数据　334
12.1.1　启用MongoDB　335
12.1.2　为模型添加注解，实现MongoDB持久化　338
12.1.3　使用MongoTemplate访问MongoDB　341
12.1.4　编写MongoDBRepository　342
12.2　使用Neo4j操作图数据　347
12.2.1　配置Spring DataNeo4j　347
12.2.2　使用注解标注图实体　350
12.2.3　使用Neo4jTemplate　353
12.2.4　创建自动化的Neo4j　Repository　354
12.3　使用Redis操作key-value数据　359
12.3.1　连接到Redis　359
12.3.2　使用RedisTemplate　360
12.3.3　使用key和value的序列化器　364
12.4　小结　365
第13章　缓存数据　367
13.1　启用对缓存的支持　368
13.1.1　配置缓存管理器　369
13.2　为方法添加注解以支持缓存　373
13.2.1　填充缓存　374
13.2.2　移除缓存条目　378
13.3　使用XML声明缓存　379
13.4　小结　383
第14章　保护方法应用　385
14.1　使用注解保护方法　386
14.1.1　使用@Secured注解限制方法调用　386
14.1.2　在Spring Security中使用
JSR-250的@RolesAllowed注解　387
14.2　使用表达式实现方法级别的安全性　388
14.2.1　表述方法访问规则　389
14.2.2　过滤方法的输入和输出　391
14.3　小结　395
第4部分　Spring集成
第15章　使用远程服务　399
15.1　Spring远程调用概览　400
15.2　使用RMI　402
15.2.1　导出RMI服务　403
15.2.2　装配RMI服务　405
15.3　使用Hessian和Burlap发布远程服务　407
15.3.1　使用Hessian和Burlap导出bean的功能　408
15.3.2　访问Hessian/Burlap服务　411
15.4　使用Spring的HttpInvoker　413
15.4.1　将bean导出为HTTP服务　413
15.4.2　通过HTTP访问服务　414
15.5　发布和使用Web服务　416
15.5.1　创建基于Spring的JAX-WS端点　416
15.5.2　在客户端代理JAX-WS服务　419
15.6　小结　421
第16章　使用Spring MVC创建REST API　423
16.1　了解REST　424
16.1.1　REST的基础知识　424
16.1.2　Spring是如何支持REST的　425
16.2　创建第一个REST端点　426
16.2.1　协商资源表述　428
16.2.2　使用HTTP信息转换器　433
16.3　提供资源之外的其他内容　438
16.3.1　发送错误信息到客户端　438
16.3.2　在响应中设置头部信息　443
16.4　编写REST客户端　445
16.4.1　了解RestTemplate的操作　446
16.4.2　GET资源　447
16.4.3　检索资源　448
16.4.4　抽取响应的元数据　449
16.4.5　PUT资源　450
16.4.6　DELETE资源　451
16.4.7　POST资源数据　452
16.4.8　在POST请求中获取响应对象　452
16.4.9　在POST请求后获取资源位置　453
16.4.10　交换资源　454
16.5　小结　456
第17章　Spring消息　457
17.1　异步消息简介　458
17.1.1　发送消息　459
17.1.2　评估异步消息的优点　461
17.2　使用JMS发送消息　463
17.2.1　在Spring中搭建消息代理　463
17.2.2　使用Spring的JMS模板　465
17.2.3　创建消息驱动的POJO　474
17.2.4　使用基于消息的RPC　477
17.3　使用AMQP实现消息功能　479
17.3.1　AMQP简介　480
17.3.2　配置Spring支持AMQP消息　481
17.3.3　使用RabbitTemplate发送消息　484
17.3.4　接收AMQP消息　486
17.4　小结　489
第18章　使用WebSocket和STOMP实现消息功能　491
18.1　使用Spring的低层级WebSocket　API　492
18.2　应对不支持WebSocket的场景　497
18.3　使用STOMP消息　500
18.3.1　启用STOMP消息功能　501
18.3.2　处理来自客户端的STOMP消息　504
18.3.3　发送消息到客户端　507
18.4　为目标用户发送消息　511
18.4.1　在控制器中处理用户的消息　512
18.4.2　为指定用户发送消息　514
18.5　处理消息异常　515
18.6　小结　516
第19章　使用Spring发送Email　517
19.1　配置Spring发送邮件　518
19.1.1　配置邮件发送器　518
19.1.2　装配和使用邮件发送器　520
19.2　构建丰富内容的Email消息　521
19.2.1　添加附件　521
19.2.2　发送富文本内容的Email　522
19.3　使用模板生成Email　524
19.3.1　使用Velocity构建Email消息　524
19.3.2　使用Thymeleaf构建Email消息　526
19.4　小结　528
第20章　使用JMX管理Spring　Bean　529
20.1　将Spring bean导出为MBean　530
20.1.1　通过名称暴露方法　533
20.1.2　使用接口定义MBean的操作和属性　535
20.1.3　使用注解驱动的MBean　536
20.1.4　处理MBean冲突　538
20.2　远程MBean　539
20.2.1　暴露远程MBean　539
20.2.2　访问远程MBean　540
20.2.3　代理MBean　542
20.3　处理通知　543
20.3.1　监听通知　544
20.4　小结　545
第21章　借助Spring Boot简化Spring开发　547
21.1　Spring Boot简介　548
21.1.1　添加Starter依赖　548
21.1.2　自动配置　552
21.1.3　Spring Boot CLI　552
21.1.4　Actuator　553
21.2　使用Spring Boot构建应用　553
21.2.1　处理请求　556
21.2.2　创建视图　558
21.2.3　添加静态内容　560
21.2.4　持久化数据　561
21.2.5　尝试运行　563
21.3　组合使用Groovy与SpringBoot　CLI　566
21.3.1　编写Groovy控制器　566
21.3.2　使用Groovy Repository实现数据持久化　569
21.3.3　运行Spring Boot CLI　570
21.4　通过Actuator获取了解应用内部状况　571
21.5　小结　574
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Spring实战（第4版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>四季成长路-每日一个希腊词灵修（全套4册）
《四季成长路•春》
第一部
1不住更新3
2变5
3超越环境的福乐7
4化时为机9
5每一天11
6灵里贫穷12
7温柔的人14
8真正的怜恤16
9清心的福乐18
10和平使者20
11恩慈相待22
12谦让的心24
13当神“有”到26
14神，你真厉害!28
15一队兵32
16神迹34
17你怕错了!36
18为父为师38
19赦罪的主40
20借神图利43
21像天父完全45
22神的愤怒47
23灵性尘封49
24耶稣是谁?52
25死亡与荣耀54
26如此无礼?!56
27反倒虚己58
28保惠师60
29圣灵的工作62
30凭据64
31一切从悔罪开始66
第二部
32教会71
33教会——治疗的群体75
34教会——祷告的群体77
35牧者的榜样79
36天国的真义81
37家在教会85
38不可停止聚会87
39割礼89
40开开心心地献上91
41耶稣的差遣93
42听道的艺术95
43优先次序97
44托付99
45沟通的艺术101
46彼此分担103
47提防弄权105
48人在江湖107
49身不由己111
50你对什么曾说：不!114
51心疲117
52暂时拥有VS天长地久120
53钱!钱!钱!122
54忍耐125
55忍耐宽容128
56随流失去130
57终132
58客旅134
59罪136
60泪138
第三部
61激发爱心143
62劝勉的威力145
63男人，你在哪里?147
64不要勉强!149
65自己可靠吗?151
66真真假假153
67出去痛哭155
68出埃及157
69有情有理159
70跳下去!161
71永垂不朽的美163
72绊脚石166
73抚摸的事奉168
74多可喜亦多可悲170
75化咒诅为祝福172
76痛174
77苦难176
78苦难神学178
79人间无情180
80最佳回报之投资183
81随风飘来飘去的信徒185
82输不起187
83愈饮愈渴的私欲189
84耶稣的嘶叫191
85英雄彼得193
86预表死亡的生日礼物196
87死啊!你得胜的权势在哪里？198
88髑髅地200
89胜过焦虑202
90和平之君204
希腊文索引206
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>四季成长路-每日一个希腊词灵修（全套4册）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Spring MVC 4
第1章　快速搭建Spring Web应用　1
1．1　Spring Tool Suite简介　2
1．2　IntelliJ简介　7
1．3　start．Spring．io简介　8
1．4　命令行方式简介　8
1．5　那就正式开始吧　9
1．5．1　Gradle构建　11
1．5．2　让我们看一下代码　15
1．6　幕后的Spring Boot　17
1．6．1　分发器和multipart配置　17
1．6．2　视图解析器、静态资源以及
区域配置　22
1．7　错误与转码配置　24
1．8　嵌入式Servlet容器（Tomcat）的
配置　27
1．8．1　HTTP端口　29
1．8．2　SSL配置　29
1．8．3　其他配置　29
1．9　小结　30
第2章　精通MVC架构　32
2．1　MVC架构　32
2．2　对MVC的质疑及其最佳实践　33
2．2．1　贫血的领域模型　33
2．2．2　从源码中学习　35
2．3　Spring MVC 1-0-1　35
2．4　使用Thymeleaf　36
2．5　Spring MVC架构　40
2．5．1　DispatcherServlet　40
2．5．2　将数据传递到给视图　41
2．6　Spring表达式语言　42
2．7　结束Hello World，开始获取
Tweet　44
2．7．1　注册应用　44
2．7．2　搭建Spring Social Twitter　46
2．7．3　访问Twitter　46
2．8　Java 8的流和lambda表达式　48
2．9　使用WebJars实现质感设计　49
2．9．1　使用布局　52
2．9．2　导航　54
2．10　检查点　59
2．11　小节　59
第3章　处理表单和复杂的URL映射　60
3．1　基本信息页——表单　60
3．2　校验　68
3．2．1　自定义校验信息　70
3．2．2　用于校验的自定义注解　73
3．3　国际化　74
3．3．1　修改地域　76
3．3．2　翻译应用的文本　79
3．3．3　表单中的列表　81
3．4　客户端校验　84
3．5　检查点　86
3．6　小结　87
第4章　文件上传与错误处理　88
4．1　上传文件　88
4．1．1　将图片写入到响应中　93
4．1．2　管理上传属性　94
4．1．3　展现上传的图片　97
4．1．4　处理文件上传的错误　99
4．2　转换错误信息　102
4．3　将基本信息放到会话中　103
4．4　自定义错误页面　107
4．5　使用矩阵变量进行URL映射　108
4．6　将其组合起来　114
4．7　检查点　121
4．8　小结　122
第5章　创建RESTful应用　123
5．1　什么是REST　123
5．2　Richardson的成熟度模型　124
5．2．1　第0级——HTTP　124
5．2．2　第1级——资源　124
5．2．3　第2级——HTTP动作　124
5．2．4　第3级——超媒体控制　126
5．3　API版本化　127
5．4　有用的HTTP代码　127
5．5　客户端为王　128
5．6　调试RESTful API　130
5．6．1　JSON格式化扩展　130
5．6．2　浏览器中的RESTful
客户端　130
5．6．3　httpie　131
5．7　自定义JSON输出　131
5．8　用户管理API　136
5．9　状态码与异常处理　140
5．9．1　带有状态码的
ResponseEntity　140
5．9．2　使用异常来处理状态码　142
5．10　通过Swagger实现文档化　146
5．11　生成XML　148
5．12　检查点　149
5．13　小结　150
第6章　保护应用　151
6．1　基本认证　151
6．1．1　用户授权　152
6．1．2　URL授权　155
6．1．3　Thymeleaf安全标签　156
6．2　登录表单　158
6．3　Twitter认证　163
6．3．1　搭建社交认证环境　164
6．3．2　详解　167
6．4　分布式会话　169
6．5　SSL　171
6．5．1　生成自签名的证书　172
6．5．2　单一模式　173
6．5．3　双通道模式　173
6．5．4　置于安全的服务器之后　174
6．6　检查点　175
6．7　小结　175
第7章　不要心存侥幸——单元测试与
验收测试　176
7．1　为什么要测试我的代码　176
7．2　该如何测试自己的代码　177
7．3　测试驱动开发　178
7．4　单元测试　179
7．5　验收测试　180
7．6　第一个单元测试　180
7．7　Mock与Stub　184
7．7．1　使用Mockito进行mock　184
7．7．2　在测试时Stub bean　186
7．7．3　该使用Mock还是Stub　189
7．8　对REST控制器进行单元
测试　189
7．9　测试认证　196
7．10　编写验收测试　198
7．10．1　Gradle配置　198
7．10．2　第一个FluentLenium
测试　200
7．10．3　使用FluentLenium创建
页面对象　206
7．10．4　用Groovy实现测试　209
7．10．5　使用Spock进行单元
测试　210
7．10．6　使用Geb进行集成测试　213
7．10．7　在Geb中使用页面对象　215
7．11　检查点　218
7．12　小结　220
第8章　优化请求　221
8．1　生产环境的profile　221
8．2　Gzip　222
8．3　缓存控制　222
8．4　应用缓存　224
8．4．1　缓存失效　229
8．4．2　分布式缓存　230
8．5　异步方法　231
8．6　ETag　237
8．7　WebSocket　241
8．8　检查点　244
8．9　小结　245
第9章　将Web应用部署到云中　246
9．1　选择主机　246
9．1．1　Cloud Foundry　246
9．1．2　OpenShift　247
9．1．3　Heroku　248
9．2　将Web应用部署到Pivotal Web
Services中　248
9．2．1　安装Cloud Foundry CLI
工具　248
9．2．2　装配应用　249
9．2．3　激活Redis　252
9．3　将Web应用部署到
Heroku中　253
9．3．1　安装工具　254
9．3．2　搭建应用　255
9．3．3　Heroku profile　256
9．3．4　运行应用　257
9．3．5　激活Redis　258
9．4　改善应用的功能　260
9．5　小结　261
第10章　超越Spring Web　262
10．1　Spring生态系统　262
10．1．1　核心　263
10．1．2　执行　263
10．1．3　数据　263
10．1．4　其他值得关注的项目　264
10．2　部署　264
10．3　单页面应用　265
10．3．1　参与者　265
10．3．2　未来的前景　266
10．3．3　实现无状态　267
10．4　小结　267
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>精通Spring MVC 4
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻量级Java Web 整合开发入门——Struts 2+Hibernate 4+Spring 3
第1章  轻量级Java Web开发概述	1
1.1  Java概述	1
1.2  Java Web开发概述	2
1.2.1  Java Web项目基本结构	2
1.2.2  轻量级Java Web开发概述	7
1.2.3  经典Java Web开发概述	7
1.3  常用的Java Web服务器	7
1.4  轻量级Java Web开发环境	9
1.4.1  环境变量的配置	9
1.4.2  常用的集成开发环境	10
1.5  轻量级Java Web开发相关技术	11
1.5.1  JSP简介	12
1.5.2  数据库技术简介	13
1.5.3  配置文件的格式	13
1.5.4  其他相关软件	15
1.6  Java Web项目的部署	15
1.6.1  拷贝部署法	15
1.6.2  WAR包部署法	16
1.6.3  IDE部署法	17
1.7  学习轻量级Java Web开发的方法	18
1.8  本章小结	18
1.9  习题	18
1.10  实验	19
第2章  设计模式概述	21
2.1  单例模式	22
2.2  工厂模式	23
2.2.1  简单工厂模式	23
2.2.2  工厂方法模式	27
2.2.3  抽象工厂模式	29
2.3  代理模式	31
2.4  命令模式	33
2.5  策略模式	36
2.6  MVC	38
2.7  本章小结	40
2.8  习题	41
2.9  实验	42
第3章  Struts 2框架	43
3.1  Struts 2框架概述	43
3.1.1  Struts 2框架的由来	43
3.1.2  Struts 2框架的下载和安装	44
3.1.3  Struts 2框架的体系结构图	45
3.2  Struts 2框架的基本用法	46
3.2.1  使用Struts 2框架的开发步骤	47
3.2.2  Struts 2框架的Action接口	48
3.2.3  Struts 2框架的配置文件	49
3.2.4  完整的Struts 2框架应用实例	50
3.3  Struts 2框架的标签库	57
3.3.1  Struts 2标签库和JSP标签库的
区别	57
3.3.2  常用的Struts 2标签介绍	58
3.3.3  Struts 2框架的国际化支持	59
3.3.4  用户注册的实例	64
3.4  Struts 2框架的高级应用	66
3.4.1  Struts 2的类型转换	66
3.4.2  Struts 2的输入校验	72
3.4.3  Struts 2的文件上传与下载	76
3.4.4  Struts 2的拦截器	83
3.5  本章小结	90
3.6  习题	91
3.7  实验	92
第4章  Hibernate框架	93
4.1  Hibernate框架概述	93
4.1.1  ORM的概念	93
4.1.2  常用的ORM框架	94
4.1.3  JPA的概念	94
4.1.4  Hibernate的下载和安装	95
4.1.5  Hibernate框架的结构图	96
4.2  Hibernate框架的基本用法	98
4.2.1  使用Hibernate框架的流程	98
4.2.2  Hibernate框架的核心类	110
4.2.3  持久化类的概念	112
4.2.4  Hibernate框架的配置文件	114
4.2.5  Hibernate框架的映射文件	116
4.2.6  使用Hibernate进行增删改查	118
4.3  Hibernate框架的高级应用	124
4.3.1  Hibernate框架的关联映射	124
4.3.2  Hibernate框架的查询	138
4.3.3  Hibernate的批量处理	146
4.4  本章小结	149
4.5  习题	149
4.6  实验	150
第5章  Spring框架	151
5.1  Spring框架概述	151
5.1.1  Spring框架简介	152
5.1.2  Spring框架的下载和安装	153
5.1.3  Spring框架的结构图	154
5.1.4  使用Spring框架的好处	156
5.2  Spring框架的基本用法	157
5.2.1  使用Spring框架的流程	157
5.2.2  Spring框架的使用范围	158
5.2.3  Spring框架的依赖注入	159
5.2.4  Spring框架的配置文件	164
5.3  Spring框架的高级应用	165
5.3.1  Spring的后处理器	165
5.3.2  Spring的资源访问	168
5.3.3  Spring的AOP	171
5.3.4  使用AOP进行权限验证及
日志记录	172
5.4  Java的反射和代理	176
5.4.1  Java的反射	176
5.4.2  Java的代理	181
5.5  本章小结	186
5.6  习题	186
5.7  实验	187
第6章  轻量级整合开发实例	189
6.1  整合开发概述	189
6.1.1  为什么要整合开发	189
6.1.2  常用的轻量级整合开发	189
6.2  Struts和Hibernate的整合开发	190
6.2.1  整合开发步骤	190
6.2.2  整合开发实例	190
6.3  Struts、Hibernate及Spring的整合开发	202
6.3.1  整合开发步骤	203
6.3.2  整合开发实例	203
6.3.3  整合开发注意事项	205
6.4  SSH整合开发实例：权限管理
系统	206
6.4.1  项目概述	206
6.4.2  项目详细创建过程	207
6.4.3  项目小结	221
6.5  轻量级整合和经典整合的区别	221
6.6  本章小结	221
6.7  习题	221
6.8  实验	222
第7章  Java Web开发常见问题	223
7.1  Struts 2框架常见问题	223
7.1.1  核心过滤器的配置	223
7.1.2  Web页面中文乱码问题	224
7.2  Hibernate框架常见问题	224
7.2.1  MySql服务不能启动	224
7.2.2  MySql数据库乱码问题	225

7.2.3  1-N双向关联映射统一外键问题	226
7.2.4  Hibernate 3和Hibernate 4二级缓存的配置区别	226
7.2.5  Hibernate生成表的默认名称对Linux和Windows的区别	227
7.2.6  Linux和Windows对路径表示方式的区别	228
7.3  Spring框架常见问题	228
7.4  一切问题的根源	228

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>轻量级Java Web 整合开发入门——Struts 2+Hibernate 4+Spring 3
