>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js实战
第一部分　Node基础
第1章　欢迎进入Node.js世界　　2
1.1　构建于JavaScript之上　　3
1.2　异步和事件触发：浏览器　　4
1.3　异步和事件触发：服务器　　5
1.4　DIRT程序　　6
1.5　默认DIRT　　8
1.5.1　简单的异步程序　　9
1.5.2　Hello World HTTP服务器　　10
1.5.3　流数据　　10
1.6　小结　　11
第2章　构建有多个房间的聊天室程序　　12
2.1　程序概览　　12
2.2　程序需求及初始设置　　15
2.2.1　提供HTTP和WebSocket服务　　15
2.2.2　创建程序的文件结构　　16
2.2.3　指明依赖项　　16
2.2.4　安装依赖项　　17
2.3　提供HTML、CSS和客户端JavaScript的服务　　18
2.3.1　创建静态文件服务器　　19
2.3.2　添加HTML和CSS文件　　21
2.4　用Socket.IO处理与聊天相关的消息　　23
2.4.1　设置Socket.IO服务器　　24
2.4.2　处理程序场景及事件　　25
2.5　在程序的用户界面上使用客户端JavaScript　　29
2.5.1　将消息和昵称/房间变更请求传给服务器　　29
2.5.2　在用户界面中显示消息及可用房间　　30
2.6　小结　　34
第3章　Node编程基础　　35
3.1　Node功能的组织及重用　　36
3.1.1　创建模块　　37
3.1.2　用module.exports微调模块的创建　　39
3.1.3　用node_modules重用模块　　40
3.1.4　注意事项　　41
3.2　异步编程技术　　42
3.2.1　用回调处理一次性事件　　43
3.2.2　用事件发射器处理重复性事件　　46
3.2.3　异步开发的难题　　53
3.3　异步逻辑的顺序化　　54
3.3.1　什么时候使用串行流程控制　　55
3.3.2　实现串行化流程控制　　56
3.3.3　实现并行化流程控制　　58
3.3.4　利用社区里的工具　　60
3.4　小结　　61
第二部分　用Node开发Web程序
第4章　构建Node Web程序　　64
4.1　HTTP服务器的基础知识　　64
4.1.1　Node如何向开发者呈现HTTP请求　　65
4.1.2　一个用“Hello World”做响应的HTTP服务器　　67
4.1.3　读取请求头及设定响应头　　67
4.1.4　设定HTTP响应的状态码　　67
4.2　构建RESTful Web服务　　68
4.2.1　用POST请求创建资源　　69
4.2.2　用GET请求获取资源　　71
4.2.3　用DELETE请求移除资源　　72
4.3　提供静态文件服务　　73
4.3.1　创建一个静态文件服务器　　73
4.3.2　处理服务器错误　　77
4.3.3　用fs.stat()实现先发制人的错误处理　　77
4.4　从表单中接受用户输入　　78
4.4.1　处理提交的表单域　　78
4.4.2　用formidable处理上传的文件　　81
4.4.3　计算上传进度　　84
4.5　用HTTPS加强程序的安全性　　85
4.6　小结　　86
第5章　存储Node程序中的数据　　87
5.1　无服务器的数据存储　　88
5.1.1　内存存储　　88
5.1.2　基于文件的存储　　88
5.2　关系型数据库管理系统　　91
5.2.1　MySQL　　91
5.2.2　PostgreSQL　　99
5.3　NoSQL数据库　　100
5.3.1　Redis　　101
5.3.2　MongoDB　　105
5.3.3　Mongoose　　107
5.4　小结　　109
第6章　Connect　　110
6.1　搭建一个Connect程序　　111
6.2　Connect的工作机制　　112
6.2.1　做日志的中间件　　112
6.2.2　响应“hello world”的中间件　　113
6.3　为什么中间件的顺序很重要　　114
6.3.1　中间件什么时候不调用next()　　114
6.3.2　用中间件的顺序执行认证　　115
6.4　挂载中间件和服务器　　115
6.4.1　认证中间件　　116
6.4.2　显示管理面板的中间件　　117
6.5　创建可配置中间件　　118
6.5.1　创建可配置的logger中间件组件　　119
6.5.2　构建路由中间件组件　　120
6.5.3　构建一个重写URL的中间件组件　　122
6.6　使用错误处理中间件　　123
6.6.1　Connect的默认错误处理器　　124
6.6.2　自行处理程序错误　　124
6.6.3　使用多个错误处理中间件组件　　125
6.7　小结　　129
第7章　Connect自带的中间件　　130
7.1　解析cookie、请求主体和查询字符串的中间件　　131
7.1.1　cookieParser()：解析HTTP cookie　　131
7.1.2　bodyParser()：解析请求主体　　134
7.1.3　limit()：请求主体的限制　　135
7.1.4　query()：查询字符串解析　　137
7.2　实现Web程序核心功能的中间件　　138
7.2.1　logger()：记录请求　　138
7.2.2　favicon()：提供favicon　　140
7.2.3　methodOverride()：伪造HTTP方法　　141
7.2.4　vhost()：虚拟主机　　143
7.2.5　session()：会话管理　　144
7.3　处理Web程序安全的中间件　　148
7.3.1　basicAuth()：HTTP基本认证　　148
7.3.2　csrf()：跨站请求伪造防护　　150
7.3.3　errorHandler()：开发错误处理　　150
7.4　提供静态文件服务的中间件　　152
7.4.1　static()：静态文件服务　　152
7.4.2　compress()：压缩静态文件　　154
7.4.3　directory()：目录列表　　156
7.5　小结　　157
第8章　Express　　158
8.1　生成程序骨架　　160
8.1.1　安装Express的可执行程序　　161
8.1.2　生成程序　　162
8.1.3　探索程序　　162
8.2　配置Express和你的程序　　164
8.3　渲染视图　　166
8.3.1　视图系统配置　　167
8.3.2　视图查找　　169
8.3.3　把数据输出到视图中　　171
8.4　处理表单和文件上传　　175
8.4.1　实现照片模型　　175
8.4.2　创建照片上传表单　　176
8.4.3　显示上传照片列表　　178
8.5　创建资源下载　　179
8.5.1　创建照片下载路由　　179
8.5.2　实现照片下载路由　　180
8.6　小结　　182
第9章　Express进阶　　183
9.1　认证用户　　184
9.1.1　保存和加载用户　　184
9.1.2　注册新用户　　189
9.1.3　已注册用户登录　　194
9.1.4　用户加载中间件　　197
9.2　先进的路由技术　　199
9.2.1　校验用户内容提交　　199
9.2.2　特定路由中间件　　202
9.2.3　实现分页　　205
9.3　创建一个公开的REST API　　208
9.3.1　设计API　　208
9.3.2　添加基本的认证　　209
9.3.3　实现路由　　209
9.3.4　启用内容协商　　212
9.4　错误处理　　214
9.4.1　处理404错误　　215
9.4.2　处理错误　　217
9.5　小结　　220
第10章　测试Node程序　　221
10.1　单元测试　　222
10.1.1　assert模块　　222
10.1.2　Nodeunit　　225
10.1.3　Mocha　　227
10.1.4　Vows　　232
10.1.5　should.js　　234
10.2　验收测试　　235
10.2.1　Tobi　　236
10.2.2　Soda　　237
10.3　小结　　239
第11章　Web程序模板　　240
11.1　用模板保持代码的整洁性　　240
11.2　嵌入JavaScript的模板　　244
11.2.1　创建模板　　245
11.2.2　用EJS过滤器处理模板数据　　246
11.2.3　将EJS集成到你的程序中　　249
11.2.4　在客户端程序中使用EJS　　250
11.3　使用Mustache模板语言与Hogan　　251
11.3.1　创建模板　　251
11.3.2　Mustache标签　　252
11.3.3　微调Hogan　　254
11.4　用Jade做模板　　255
11.4.1　Jade基础知识　　256
11.4.2　Jade模板中的逻辑　　258
11.4.3　组织Jade模板　　260
11.5　小结　　264
第三部分　在Node中更进一步
第12章　部署Node程序并维持正常运行时间　　266
12.1　安置Node程序　　266
12.1.1　专用的和虚拟私有服务器　　267
12.1.2　云主机　　268
12.2　部署的基础知识　　269
12.2.1　从Git存储库部署　　270
12.2.2　让Node保持运行　　270
12.3　让正常运行时间和性能达到最优　　271
12.3.1　用Upstart维护正常运行时间　　272
12.3.2　集群API：利用多核的优势　　273
12.3.3　静态文件及代理　　275
12.4　小结　　277
第13章　超越Web服务器　　278
13.1　Socket.IO　　278
13.1.1　创建一个最小的Socket.IO程序　　279
13.1.2　用Socket.IO触发页面和CSS的重新加载　　281
13.1.3　Socket.IO的其他用法　　283
13.2　深入TCP/IP网络　　284
13.2.1　处理缓冲区和二进制数据　　284
13.2.2　创建TCP服务器　　286
13.2.3　创建TCP客户端　　289
13.3　跟操作系统交互的工具　　290
13.3.1　单例的全局process对象　　291
13.3.2　使用文件系统模块　　293
13.3.3　繁衍外部进程　　296
13.4　开发命令行工具　　301
13.4.1　解析命令行参数　　301
13.4.2　处理stdin和stdout　　302
13.4.3　添加彩色的输出　　304
13.5　小结　　306
第14章　Node生态系统　　307
14.1　给Node开发人员的在线资源　　308
14.1.1　Node和模块的参考资料　　308
14.1.2　Google群组　　309
14.1.3　IRC　　309
14.1.4　GitHub问题列表　　310
14.2　GitHub　　310
14.2.1　GitHub入门　　311
14.2.2　添加一个项目到GitHub中　　312
14.2.3　用GitHub协作　　314
14.3　为npm库做贡献　　316
14.3.1　准备包　　317
14.3.2　编写包规范　　317
14.3.3　测试和发布包　　318
14.4　小结　　320
附录A　安装Node和社区附加组件　　321
附录B　调试Node　　329
附录C　Express的扩展及配置　　336
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入浅出Node.js
第1章　Node简介　　1
1.1 　Node的诞生历程　　1
1.2 　Node的命名与起源　　1
1.2.1 　为什么是JavaScript　　2
1.2.2 　为什么叫Node　　2
1.3 　Node给JavaScript带来的意义　　2
1.4 　Node的特点　　4
1.4.1 　异步I/O　　4
1.4.2 　事件与回调函数　　6
1.4.3 　单线程　　7
1.4.4 　跨平台　　7
1.5 　Node的应用场景　　8
1.5.1 　I/O密集型　　8
1.5.2 　是否不擅长CPU密集型业务　　8
1.5.3 　与遗留系统和平共处　　10
1.5.4 　分布式应用　　10
1.6 　Node的使用者　　10
1.7 　参考资源　　11
第2章　模块机制　　12
2.1 　CommonJS规范　　13
2.1.1 　CommonJS的出发点　　13
2.1.2 　CommonJS的模块规范　　14
2.2 　Node的模块实现　　15
2.2.1 　优先从缓存加载　　16
2.2.2 　路径分析和文件定位　　16
2.2.3 　模块编译　　18
2.3 　核心模块　　20
2.3.1 　JavaScript核心模块的编译过程　　21
2.3.2 　C/C++核心模块的编译过程　　22
2.3.3 　核心模块的引入流程　　25
2.3.4 　编写核心模块　　25
2.4 　C/C++扩展模块　　27
2.4.1 　前提条件　　28
2.4.2 　C/C++扩展模块的编写　　29
2.4.3 　C/C++扩展模块的编译　　30
2.4.4 　C/C++扩展模块的加载　　31
2.5 　模块调用栈　　32
2.6 　包与NPM　　33
2.6.1 　包结构　　34
2.6.2 　包描述文件与NPM　　34
2.6.3 　NPM常用功能　　37
2.6.4 　局域NPM　　42
2.6.5 　NPM潜在问题　　43
2.7 　前后端共用模块　　44
2.7.1 　模块的侧重点　　44
2.7.2 　AMD规范　　44
2.7.3 　CMD规范　　45
2.7.4 　兼容多种模块规范　　45
2.8 　总结　　46
2.9 　参考资源　　46
第3章　异步I/O　　47
3.1 　为什么要异步I/O　　47
3.1.1 　用户体验　　48
3.1.2 　资源分配　　49
3.2 　异步I/O实现现状　　50
3.2.1 　异步I/O与非阻塞I/O　　50
3.2.2 　理想的非阻塞异步I/O　　54
3.2.3 　现实的异步I/O　　54
3.3 　Node的异步I/O　　56
3.3.1 　事件循环　　56
3.3.2 　观察者　　56
3.3.3 　请求对象　　57
3.3.4 　执行回调　　59
3.3.5 　小结　　60
3.4 　非I/O的异步API　　60
3.4.1 　定时器　　60
3.4.2 　process.nextTick()　　61
3.4.3 　setImmediate()　　62
3.5 　事件驱动与高性能服务器　　63
3.6 　总结　　65
3.7 　参考资源　　65
第4章　异步编程　　66
4.1 　函数式编程　　66
4.1.1 　高阶函数　　66
4.1.2 　偏函数用法　　67
4.2 　异步编程的优势与难点　　68
4.2.1 　优势　　69
4.2.2 　难点　　70
4.3 　异步编程解决方案　　74
4.3.1 　事件发布/订阅模式　　74
4.3.2 　Promise/Deferred模式　　82
4.3.3 　流程控制库　　93
4.4 　异步并发控制　　105
4.4.1 　bagpipe的解决方案　　105
4.4.2 　async的解决方案　　109
4.5 　总结　　110
4.6 　参考资源　　110
第5章　内存控制　　111
5.1 　V8的垃圾回收机制与内存限制　　111
5.1.1 　Node与V8　　112
5.1.2 　V8的内存限制　　112
5.1.3 　V8的对象分配　　112
5.1.4 　V8的垃圾回收机制　　113
5.1.5 　查看垃圾回收日志　　119
5.2 　高效使用内存　　121
5.2.1 　作用域　　121
5.2.2 　闭包　　123
5.2.3 　小结　　124
5.3 　内存指标　　124
5.3.1 　查看内存使用情况　　124
5.3.2 　堆外内存　　126
5.3.3 　小结　　127
5.4 　内存泄漏　　127
5.4.1 　慎将内存当做缓存　　127
5.4.2 　关注队列状态　　130
5.5 　内存泄漏排查　　130
5.5.1 　node-heapdump　　131
5.5.2 　node-memwatch　　132
5.5.3 　小结　　135
5.6 　大内存应用　　135
5.7 　总结　　136
5.8 　参考资源　　136
第6章 　理解Buffer　　137
6.1 　Buffer结构　　137
6.1.1 　模块结构　　137
6.1.2 　Buffer对象　　138
6.1.3 　Buffer内存分配　　139
6.2 　Buffer的转换　　141
6.2.1 　字符串转Buffer　　141
6.2.2 　Buffer转字符串　　142
6.2.3 　Buffer不支持的编码类型　　142
6.3 　Buffer的拼接　　143
6.3.1 　乱码是如何产生的　　144
6.3.2 　setEncoding()与string_decoder()　　144
6.3.3 　正确拼接Buffer　　145
6.4 　Buffer与性能　　146
6.5 　总结　　149
6.6 　参考资源　　149
第7章　网络编程　　150
7.1 　构建TCP服务　　150
7.1.1 　TCP　　150
7.1.2 　创建TCP服务器端　　151
7.1.3 　TCP服务的事件　　153
7.2 　构建UDP服务　　154
7.2.1 　创建UDP套接字　　154
7.2.2 　创建UDP服务器端　　154
7.2.3 　创建UDP客户端　　155
7.2.4 　UDP套接字事件　　155
7.3 　构建HTTP服务　　155
7.3.1 　HTTP　　156
7.3.2 　http模块　　157
7.3.3 　HTTP客户端　　161
7.4 　构建WebSocket服务　　163
7.4.1 　WebSocket握手　　164
7.4.2 　WebSocket数据传输　　167
7.4.3 　小结　　169
7.5 　网络服务与安全　　169
7.5.1 　TLS/SSL　　170
7.5.2 　TLS服务　　172
7.5.3 　HTTPS服务　　173
7.6 　总结　　175
7.7 　参考资源　　176
第8章　构建Web应用　　177
8.1 　基础功能　　177
8.1.1 　请求方法　　178
8.1.2 　路径解析　　179
8.1.3 　查询字符串　　180
8.1.4 　Cookie　　181
8.1.5 　Session　　184
8.1.6 　缓存　　190
8.1.7 　Basic认证　　193
8.2 　数据上传　　195
8.2.1 　表单数据　　195
8.2.2 　其他格式　　196
8.2.3 　附件上传　　197
8.2.4 　数据上传与安全　　199
8.3 　路由解析　　201
8.3.1 　文件路径型　　202
8.3.2 　MVC　　202
8.3.3 　RESTful　　207
8.4 　中间件　　210
8.4.1 　异常处理　　214
8.4.2 　中间件与性能　　215
8.4.3 　小结　　216
8.5 　页面渲染　　217
8.5.1 　内容响应　　217
8.5.2 　视图渲染　　219
8.5.3 　模板　　220
8.5.4 　Bigpipe　　231
8.6 　总结　　235
8.7 　参考资源　　235
第9章　玩转进程　　236
9.1 　服务模型的变迁　　236
9.1.1 　石器时代：同步　　236
9.1.2 　青铜时代：复制进程　　237
9.1.3 　白银时代：多线程　　237
9.1.4 　黄金时代：事件驱动　　237
9.2 　多进程架构　　238
9.2.1 　创建子进程　　239
9.2.2 　进程间通信　　240
9.2.3 　句柄传递　　242
9.2.4 　小结　　247
9.3 　集群稳定之路　　248
9.3.1 　进程事件　　248
9.3.2 　自动重启　　249
9.3.3 　负载均衡　　254
9.3.4 　状态共享　　255
9.4 　Cluster模块　　257
9.4.1 　Cluster工作原理　　258
9.4.2 　Cluster事件　　259
9.5 　总结　　259
9.6 　参考资源　　260
第10章　测试　　261
10.1 　单元测试　　261
10.1.1 　单元测试的意义　　261
10.1.2 　单元测试介绍　　263
10.1.3 　工程化与自动化　　276
10.1.4 　小结　　277
10.2 　性能测试　　278
10.2.1 　基准测试　　278
10.2.2 　压力测试　　280
10.2.3 　基准测试驱动开发　　281
10.2.4 　测试数据与业务数据的转换　　283
10.3 　总结　　284
10.4 　参考资源　　284
第11章　产品化　　285
11.1 　项目工程化　　285
11.1.1 　目录结构　　285
11.1.2 　构建工具　　286
11.1.3 　编码规范　　289
11.1.4 　代码审查　　289
11.2 　部署流程　　290
11.2.1 　部署环境　　291
11.2.2 　部署操作　　291
11.3 　性能　　293
11.3.1 　动静分离　　293
11.3.2 　启用缓存　　294
11.3.3 　多进程架构　　294
11.3.4 　读写分离　　295
11.4 　日志　　295
11.4.1 　访问日志　　295
11.4.2 　异常日志　　296
11.4.3 　日志与数据库　　299
11.4.4 　分割日志　　299
11.4.5 　小结　　299
11.5 　监控报警　　299
11.5.1 　监控　　300
11.5.2 　报警的实现　　302
11.5.3 　监控系统的稳定性　　303
11.6 　稳定性　　303
11.7 　异构共存　　304
11.8 　总结　　305
11.9 　参考资源　　305
附录A 　安装Node　　306
A.1 　Windows系统下的Node安装　　306
A.2 　Mac系统下Node的安装　　307
A.3 　Linux系统下Node的安装　　308
A.4 　总结　　309
A.5 　参考资源　　309
附录B 　调试Node　　310
B.1 　Debugger　　310
B.2 　Node Inspector　　311
B.2.1 　安装Node Inspector　　312
B.2.2 　错误堆栈　　312
B.3 　总结　　313
附录C 　Node编码规范　　314
C.1 　根源　　314
C.2 　编码规范　　315
C.2.1 　空格与格式　　315
C.2.2 　命名规范　　317
C.2.3 　比较操作　　318
C.2.4 　字面量　　318
C.2.5 　作用域　　318
C.2.6 　数组与对象　　319
C.2.7 　异步　　320
C.2.8 　类与模块　　320
C.2.9 　注解规范　　321
C.3 　最佳实践　　321
C.3.1 　冲突的解决原则　　321
C.3.2 　给编辑器设置检测工具　　321
C.3.3 　版本控制中的hook　　322
C.3.4 　持续集成　　322
C.4 　总结　　322
C.5 　参考资源　　323
附录D 　搭建局域NPM仓库　　324
D.1 　NPM仓库的安装　　325
D.1.1 　安装Erlang和CouchDB　　325
D.1.2 　搭建NPM仓库　　326
D.2 　高阶应用　　328
D.2.1 　镜像仓库　　328
D.2.2 　私有模块应用　　328
D.2.3 　纯私有仓库　　329
D.3 　总结　　331
D.4 　参考资源　　332
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>深入浅出Node.js
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js开发实战
第一部分  开始接触Node.js 1
第1章  入门 3
1.1  不限于Web 3
1.2  Node.js的应用范围 4
1.3  Node.js的工作原理 6
1.4  Node.js开发的5个方面 8
1.5  安装Node.js 9
第2章  文件操作 11
2.1  Node.js事件循环编程 12
2.2  创建子进程 16
2.3  使用EventEmitter 获取数据 18
2.4  异步读/写文件 20
2.5  Node.js程序运行的两个阶段 24
2.6  小结与练习 24
第3章  Socket网络编程 26
3.1  监听Socket连接 27
3.2  实现消息协议 32
3.3  建立Socket客户端连接 34
3.4  网络应用功能测试 36
3.5  在自定义模块中扩展Node.js核心类 39
3.6  使用Mocha编写单元测试 44
3.7  小结与练习 50
第4章  创建健壮的微服务 52
4.1  安装ØMQ 53
4.2  发布和订阅消息 58
4.3  响应网络请求 61
4.4  运用ROUTER/DEALER模式 65
4.5  多进程Node.js 68
4.6  推送和拉取消息 72
4.7  小结与练习 75
第二部分  数据处理 79
第5章  数据转换 81
5.1  获取外部数据 82
5.2  基于Mocha和Chai的行为驱动开发 84
5.3  提取数据 90
5.4  依次处理数据文件 100
5.5  使用Chrome DevTools调试测试 103
5.6  小结与练习 108
第6章  操作数据库 111
6.1  Elasticsearch入门 112
6.2  使用Commander创建命令行程序 114
6.3  使用request获取JSON 120
6.4  使用jq处理JSON 125
6.5  批量插入Elasticsearch文档 128
6.6  实现Elasticsearch查询命令 132
6.7  小结与练习 139
第三部分  从头开始创建应用程序 143
第7章  开发RESTful Web服务 145
7.1  使用Express的好处 146
7.2  运用Express开发服务端API 147
7.3  编写模块化的Express的服务 149
7.4  使用nodemon保持服务不间断运行 153
7.5  添加搜索API 154
7.6  使用Promise简化代码 159
7.7  操作RESTfull文档 165
7.8  使用async和await模拟同步 168
7.9  为Express提供一个async处理函数 170
7.10  小结与练习 178
第8章  打造漂亮的用户界面 181
8.1  开始使用webpack 182
8.2  生成第一个webpack Bundle 186
8.3  使用Bootstrap美化页面 188
8.4  引入Bootstrap Javascript和jQuery 192
8.5  使用TypeScript进行转译 193
8.6  使用Handlebars处理HTML模板 197
8.7  实现hash路由 200
8.8  在页面中展示对象数据 202
8.9  使用表单保存数据 207
8.10  小结与练习 211
第9章  强化你的应用 214
9.1  设置初始项目 215
9.2  在Express中管理用户会话 219
9.3  添加身份验证UI元素 222
9.4  设置Passport 224
9.5  通过社交账号进行身份验证 228
9.6  编写Express路由 240
9.7  引入书单UI 245
9.8  在生产模式下部署服务 246
9.9  小结与练习 250
第10章  使用Node-RED进行流式开发 252
10.1  配置Node-RED 252
10.2  保护Node-RED 254
10.3  开发一个Node-RED流 255
10.4  使用Node-RED创建HTTP API 259
10.5  处理Node-RED流中的错误 269
10.6  小结 276
附录A  配置Angular开发环境 277
附录B  配置React开发环境 282
索引 285
翻译审校名单 300
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js开发实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node Web开发
目          录
第1章     Node入门    1
1.1     Node能做什么    1
1.2     为什么要使用Node    3
1.2.1     架构问题：线程，还是异步事件驱动    4
1.2.2     性能和利用率    5
1.2.3     服务器利用率、成本和绿色Web托管服务    6
1.3     Node、Node.js还是Node .JS    7
1.4     小结    7
第2章     安装并配置Node    8
2.1     系统要求    8
2.2     在符合POSIX标准的系统上安装    9
2.3     在Mac OS X上安装开发者工具    9
2.3.1     在home目录下安装    9
2.3.2     在系统级目录下安装Node    11
2.3.3     在Mac OS X上使用MacPorts安装    12
2.3.4     在Mac OS X上使用homebrew安装    12
2.3.5     在Linux上使用软件包管理系统安装    12
2.3.6     同时安装并维护多个Node    13
2.4     验证安装成功与否    14
2.4.1     Node命令行工具    14
2.4.2     用Node运行简单的脚本    15
2.4.3     用Node启动服务器    16
2.5     安装npm——Node包管理器    16
2.6     系统启动时自动启动Node服务器    17
2.7     小结    22
第3章     Node模块    23
3.1     什么是模块    23
3.1.1     Node模块    24
3.1.2     Node解析require ('module')的方式    24
3.2     Node包管理器    28
3.2.1     npm包的格式    29
3.2.2     查找npm包    30
3.2.3     使用npm命令    31
3.2.4     Node包版本的标识和范围    38
3.2.5     CommonJS模块    39
3.3     小结    40
第4章     几种典型的简单应用    41
4.1     Math Wizard    41
4.2     不依赖框架的实现    41
4.2.1     路由请求    42
4.2.2     处理URL查询参数    43
4.2.3     乘法运算    44
4.2.4     其他数学函数的执行    45
4.2.5     扩展Math Wizard    48
4.2.6     长时间运行的运算（斐波那契数）    48
4.2.7     还缺什么功能    51
4.2.8     使用Connect框架实现Math Wizard    52
4.2.9     安装和设置Connect    52
4.2.10     使用Connect    53
4.3     使用Express框架实现Math Wizard    55
4.3.1     准备工作    55
4.3.2     处理错误    59
4.3.3     参数化的URL和数据服务    60
4.4     小结    64
第5章     简单的Web服务器、EventEmitter和HTTP客户端    65
5.1     通过EventEmitter发送和接收事件    65
5.2     HTTP Sniffer——监听HTTP会话    67
5.3     基本的Web服务器    69
5.4     MIME类型和MIME npm包    78
5.5     处理cookie    79
5.6     虚拟主机和请求路由    79
5.7     发送HTTP客户端请求    79
5.8     小结    81
第6章     存取数据    83
6.1     Node的数据存储引擎    83
6.2     SQLite3——轻量级的进程内SQL引擎    83
6.2.1     安装SQLite 3    83
6.2.2     用SQLite3实现便签应用    84
6.2.3     在Node中使用其他SQL数据库    95
6.3     Mongoose    96
6.3.1     安装Mongoose    96
6.3.2     用Mongoose实现便签应用    97
6.3.3     对MongoDB数据库的其他支持    102
6.4     如何实现用户验证    102
6.5     小结    104

>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node Web开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node即学即用
目录
第一部分 　基础入门
第1 章 　Node.js 简介　　3
1.1 　安装Node.js　　4
1.2 　开始写代码　　7
1.2.1 　Node REPL　　7
1.2.2 　编写首个服务器程序　　9
1.3 　为什么选择Node　　11
1.3.1 　高性能Web 服务器　　11
1.3.2 　专业的JavaScript　　12
1.3.3 　浏览器之战 2.0　　13
第2 章 　编写有趣的应用　　15
2.1 　创建一个聊天服务器　　15
2.2 　我们也来编写个Twitter　　23
第3 章 　编写健壮的Node 程序　　33
3.1 　事件循环　　33
3.2 　模式　　39
3.3 　编写产品代码　　44
3.3.1 　差错处理　　45
3.3.2 　使用多处理器　　46
第二部分 　API 和常用模块
第4 章 　核心API　　55
4.1 　Events　　55
4.1.1 　EventEmitter　　56
4.1.2 　Callback 语法　　57
4.2 　HTTP　　59
4.2.1 　HTTP 服务器　　59
4.2.2 　HTTP 客户端　　61
4.2.3 　URL　　65
4.2.4 　querystring　　67
4.3 　I/O　　68
4.3.1 　数据流（stream）　　68
4.3.2 　文件系统　　69
4.3.3 　Buffer　　70
4.3.4 　console.log　　76
第5 章 　工具类API　　77
5.1 　DNS　　77
5.2 　加密　　79
5.2.1 　Hashing　　79
5.2.2 　HMAC　　81
5.2.3 　公钥加密　　82
5.3 　进程　　86
5.3.1 　process 模块　　87
5.3.2 　子进程　　95
5.4 　用assert 来测试　　101
5.5 　虚拟机　　104
第6 章 　数据访问　　109
6.1 　NoSQL 和文档存储　　109
6.1.1 　CouchDB　　109
6.1.2 　Redis　　117
6.1.3 　MongoDB　　25
6.2 　关系型数据库　　129
6.2.1 　MySQL　　129
6.2.2 　PostgreSQL　　136
6.3 　连接池　　139
6.4 　消息队列协议　　141
第7 章 　重要的外部模块　　147
7.1 　Express　　147
7.1.1 　一个简单的Express 应用　　147
7.1.2 　在Express 中设置路由　　148
7.1.3 　处理表单数据　　153
7.1.4 　模板引擎　　154
7.1.5 　中间件　　158
7.2 　Socket.IO　　161
7.2.1 　命名空间　　163
7.2.2 　Express 中使用Socket.IO　　165
第8 章 　扩展Node　　171
8.1 　模块　　171
8.2 　包管理　　172
8.2.1 　搜索包　　172
8.2.2 　创建包　　172
8.2.3 　发布包　　173
8.2.4 　链接　　173
8.3 　附加组件　　174
词汇表　　175
索引　　176
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node即学即用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node与Express开发
序　　XIV
前言　　XV
第1章　初识Express　　1
1.1　JavaScript革命　　1
1.2　初识Express　　2
1.3　Express 简史　　3
1.4　升级到Express 4.0　　4
1.5　Node：一种新型Web 服务器　　4
1.6　Node 的生态系统　　5
1.7　授权　　6
第2章　从Node开始　　8
2.1　获取Node　　8
2.2　使用终端　　9
2.3　编辑器　　10
2.4　npm　　11
2.5　用Node 实现的简单Web服务器　　12
2.5.1　Hello World　　12
2.5.2　事件驱动编程　　13
2.5.3　路由　　13
2.5.4　静态资源服务　　14
2.6　走向Express　　16
第3章　省时省力的Express　　17
3.1　脚手架　　17
3.2　草地鹨旅行社网站　　18
3.3　初始步骤　　18
3.3.1　视图和布局　　21
3.3.2　视图和静态文件　　24
3.3.3　视图中的动态内容　　24
3.4　小结　　25
第4章　工欲善其事，必先利其器　　26
4.1　最佳实践　　26
4.2　版本控制　　27
4.3　针对本书如何使用Git　　27
4.3.1　如果你要自己动手　　28
4.3.2　如果你要使用官方存储库　　29
4.4　npm 包　　29
4.5　项目元数据　　31
4.6　Node 模块　　31
第5章　质量保证　　33
5.1　QA：值得吗　　34
5.2　逻辑与展示　　35
5.3　测试的类型　　35
5.4　QA 技术概览　　35
5.5　运行你的服务器　　36
5.6　页面测试　　36
5.7　跨页测试　　40
5.8　逻辑测试　　43
5.9　去毛　　43
5.10　链接检查　　44
5.11　用Grunt 实现自动化　　44
5.12　持续集成　　46
第6章　请求和响应对象　　48
6.1　URL 的组成部分　　48
6.2　HTTP 请求方法　　49
6.3　请求报头　　50
6.4　响应报头　　50
6.5　互联网媒体类型　　51
6.6　请求体　　51
6.7　参数　　51
6.8　请求对象　　51
6.9　响应对象　　53
6.10　获取更多信息　　55
6.11　小结　　56
6.11.1　内容渲染　　56
6.11.2　处理表单　　57
6.11.3　提供一个API　　58
第7章　Handlebars 模板引擎　　60
7.1　唯一一条绝对规则　　61
7.2　选择模板引擎　　61
7.3　Jade：不走寻常路　　62
7.4　Handlebars 基础　　63
7.4.1　注释　　64
7.4.2　块级表达式　　64
7.4.3　服务器端模板　　66
7.4.4　视图和布局　　67
7.4.5　在Express 中使用（或不使用）布局　　69
7.4.6　局部文件　　69
7.4.7　段落　　71
7.4.8　完善你的模板　　72
7.4.9　客户端Handlebars　　73
7.5　小结　　75
第8章　表单处理　　76
8.1　向服务器发送客户端数据　　76
8.2　HTML 表单　　76
8.3　编码　　77
8.4　处理表单的不同方式　　78
8.5　Express 表单处理　　79
8.6　处理AJAX 表单　　81
8.7　文件上传　　83
8.8　jQuery 文件上传　　85
第9章　Cookie 与会话　　88
9.1　凭证的外化　　89
9.2　Express 中的Cookie　　90
9.3　检查Cookie　　91
9.4　会话　　92
9.4.1　内存存储　　92
9.4.2　使用会话　　93
9.5　用会话实现即显消息　　93
9.6　会话的用途　　95
第10章　中间件　　96
10.1　常用中间件　　100
10.2　第三方中间件　　102
第11章　发送邮件　　103
11.1　SMTP、MSA 和MTA　　103
11.2　接收邮件　　104
11.3　邮件头　　104
11.4　邮件格式　　104
11.5　HTML 邮件　　105
11.6　Nodemailer　　105
11.6.1　发送邮件　　106
11.6.2　将邮件发送给多个接收者　　107
11.7　发送批量邮件的更佳选择　　108
11.8　发送HTML 邮件　　108
11.8.1　HTML 邮件中的图片　　108
11.8.2　用视图发送HTML 邮件　　109
11.8.3　封装邮件功能　　 111
11.9　将邮件作为网站监测工具　　112
第12章　与生产相关的问题　　113
12.1　执行环境　　113
12.2　环境特定配置　　114
12.3　扩展你的网站　　115
12.3.1　用应用集群扩展　　116
12.3.2　处理未捕获的异常　　118
12.3.3　用多台服务器扩展　　121
12.4　网站监控　　122
12.4.1　第三方正常运行监控　　122
12.4.2　应用程序故障　　122
12.5　压力测试　　123
第13章　持久化　　124
13.1　文件系统持久化　　124
13.2　云持久化　　126
13.3　数据库持久化　　126
13.3.1　关于性能　　127
13.3.2　设置MongoDB　　127
13.3.3　Mongoose　　128
13.3.4　使用Mongoose连接数据库　　128
13.3.5　创建模式和模型　　129
13.3.6　添加初始数据　　130
13.3.7　获取数据　　131
13.3.8　添加数据　　133
13.3.9　用MongoDB存储会话数据　　134
第14章　路由　　137
14.1　路由和SEO　　139
14.2　子域名　　139
14.3　路由处理器是中间件　　140
14.4　路由路径和正则表达式　　141
14.5　路由参数　　142
14.6　组织路由　　143
14.7　在模块中声明路由　　143
14.8　按逻辑对处理器分组　　144
14.9　自动化渲染视图　　145
14.10　其他的路由组织方式　　146
第15章　REST API 和JSON　　147
15.1　JSON和XML　　148
15.2　我们的API　　148
15.3　API 错误报告　　149
15.4　跨域资源共享　　150
15.5　我们的数据存储　　150
15.6　我们的测试　　151
15.7　用Express 提供API　　152
15.8　使用REST 插件　　153
15.9　使用子域名　　155
第16章　静态内容　　157
16.1　性能方面的考虑　　158
16.2　面向未来的网站　　158
16.2.1　静态映射　　159
16.2.2　视图中的静态资源　　160
16.2.3　CSS 中的静态资源　　161
16.3　服务器端JavaScript中的静态资源　　162
16.4　客户端JavaScript中的静态资源　　163
16.5　提供静态资源　　164
16.6　修改静态内容　　165
16.7　打包和缩小　　165
16.8　关于第三方库　　170
16.9　QA　　170
16.10　小结　　171
第17章　在Express 中实现MVC　　173
17.1　模型　　174
17.2　视图模型　　175
17.3　控制器　　177
17.4　小结　　179
第18章　安全　　180
18.1　HTTPS　　180
18.1.1　生成自己的证书　　181
18.1.2　使用免费的证书颁发机构　　182
18.1.3　购买证书　　182
18.1.4　对你的Express 应用启用HTTPS　　184
18.1.5　关于端口的说明　　185
18.1.6　HTTPS 和代理　　185
18.2　跨站请求伪造　　187
18.3　认证　　187
18.3.1　认证与授权　　188
18.3.2　密码的问题　　188
18.3.3　第三方认证　　188
18.3.4　把用户存在数据库中　　189
18.3.5　认证与注册和用户体验　　190
18.3.6　Passport　　190
18.3.7　基于角色的授权　　199
18.3.8　添加更多认证提供者　　200
18.4　小结　　201
第19章　集成第三方API　　202
19.1　社交媒体　　202
19.1.1　社交媒体插件和站点性能　　202
19.1.2　搜索推文　　203
19.1.3　渲染推文　　206
19.2　地理编码　　209
19.2.1　用谷歌的地理编码　　209
19.2.2　对你的数据做地理编码　　210
19.2.3　显示地图　　213
19.2.4　提升客户端性能　　215
19.3　天气数据　　216
19.4　小结　　217
第20章　调试　　218
20.1　调试的首要原则　　218
20.2　利用好REPL 和控制台　　219
20.3　利用Node 内置的调试器　　220
20.4　Node 探查器　　220
20.5　调试异步函数　　223
20.6　调试Express　　224
第21章　正式启用　　226
21.1　域名注册和托管服务　　226
21.1.1　域名系统　　227
21.1.2　安全　　227
21.1.3　顶级域名　　228
21.1.4　子域名　　229
21.1.5　域名服务器　　229
21.1.6　托管　　230
21.1.7　部署　　233
21.2　小结　　236
第22章　维护　　237
22.1　维护的原则　　237
22.1.1　有长远规划　　237
22.1.2　使用源码控制系统　　239
22.1.3　使用问题追踪系统　　239
22.1.4　良好的卫生习惯　　239
22.1.5　不要拖延　　239
22.1.6　做常规的QA检查　　240
22.1.7　监测分析　　240
22.1.8　性能优化　　240
22.1.9　潜在用户追踪优先　　241
22.1.10　防止出现“不可见的”错误　　242
22.2　代码重用及重构　　243
22.2.1　私有npm库　　243
22.2.2　中间件　　244
22.3　小结　　246
第23章　其他资源　　247
23.1　在线文档　　247
23.2　期刊　　248
23.3　Stack Overflow　　248
23.4　为Express做贡献　　250
23.5　小结　　252
关于封面　　253
关于作者　　254
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node与Express开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>狼书（卷1）：更了不起的Node.js
第1章  Node.js初识	1
1.1  引子	1
1.2  JavaScript	7
1.3  什么是Node.js	9
1.3.1  Node.js概述	9
1.3.2  Node.js的特点	12
1.3.3  Node.js的应用场景	16
1.4  本章小结	18
第2章  Node.js安装与入门	19
2.1  安装Node.js	19
2.1.1  3m安装法	19
2.1.2  nvm	20
2.1.3  npm	26
2.1.4  nrm	32
2.1.5  从源码进行编译	35
2.1.6  状态理论	35
2.2  Hello Node.js！	36
2.2.1  Hello World	36
2.2.2  Hello CommonJS	37
2.2.3  Hello HTTP	38
2.3  编辑器与调试	41
2.3.1  IDE/编辑器	41
2.3.2  VSCode	42
2.3.3  调试	45
2.4  本章小结	52
第3章  更了不起的Node.js	53
3.1  架构升级	53
3.1.1  从LAMP到MEAN	54
3.1.2  前后端分离	55
3.1.3  页面即服务	58
3.1.4  场景决定选型	59
3.2  贯穿开发全过程	60
3.2.1  静态API	60
3.2.2  现代Web开发	63
3.2.3  后端开发	68
3.3  更多乐趣	78
3.3.1  更多应用场景	78
3.3.2  C/C++扩展	79
3.3.3  团队优化	80
3.3.4  全栈之路	81
3.4  本章小结	85
第4章  更好的Node.js	86
4.1  选择	86
4.1.1  语法可难可易	86
4.1.2  开发大型软件	90
4.1.3  特定场景下的快速开发	91
4.2  单线程会“死”吗	92
4.2.1  uncaughtException	93
4.2.2  异常捕获	94
4.2.3  forever	95
4.2.4  小集群：单台服务器上多个实例	95
4.2.5  大集群：多台机器	96
4.3  为Node.js正名	98
4.3.1  版本帝？	98
4.3.2  已无性能优势？	99
4.3.3  异步和回调地狱？	100
4.3.5  技术栈演进	101
4.4  更好的实践	102
4.4.1  ES.next	102
4.4.2  类型系统	110
4.4.3  更好的npm替代品——Yarn	111
4.4.4  多模块管理器Lerna	113
4.5  本章小结	114
第5章  Node.js是如何执行的	115
5.1  准备	115
5.1.1  编辑器	116
5.1.2  编译	117
5.1.3  调试	118
5.2  编译步骤	120
5.2.1  configure	120
5.2.2  make	130
5.2.3  make install	132
5.3  从入口开始	135
5.3.1  核心流程	137
5.3.2  构造process对象	139
5.3.3  LoadEnvironment	147
5.3.4  bootstrap_node.js	148
5.3.5  EventLoop启动方法	160
5.4  API调用过程	162
5.4.1  相关的引用	163
5.4.2  FSReqWrap	163
5.4.3  核心open方法	164
5.4.4  src/node_file.cc	164
5.5  事件循环机制	167
5.5.1  概览	167
5.5.2  生命周期	169
5.5.3  microtask和macrotask	170
5.5.4  process.nextTick(callback)	173
5.6  本章小结	175
第6章  模块与核心	176
6.1  CommonJS规范	176
6.1.1  简介	176
6.1.2  核心技术	181
6.2  Node.js 模块	189
6.2.1  从源码分析实现原理	189
6.2.2  从Node.js代码执行开始	191
6.2.3  深入理解模块	195
6.2.4  全局对象	205
6.2.5  Node.js模块详解	215
6.3  未来展望：ES模块	220
6.3.1  ES模块入门	221
6.3.2  模块导入	222
6.3.3  模块导出	222
6.3.4  ES模块示例	223
6.3.5  兼容性更好的@std/esm	224
6.4  本章小结	224
第7章  异步写法与流程控制	225
7.1  异步调用	226
7.1.1  异步与同步	226
7.1.2  浏览器中的异步	227
7.1.3  Node.js异步原理	227
7.1.4  API和示例	229
7.1.5  代码优化	231
7.2  Node.js自带的异步写法	236
7.2.1  错误优先的回调方式	236
7.2.2  EventEmitter	240
7.2.3  该选择哪种风格的写法	247
7.3  更好的异步流程控制	248
7.3.1  回调地狱	248
7.3.2  Thunk	252
7.3.3  Promise	254
7.3.4  Generator	276
7.3.5  async函数	282
7.4  本章小结	287
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>狼书（卷1）：更了不起的Node.js
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>移动Web前端高效开发实战
第1章　初识移动Web前端	1
1.1  移动Web前端史	1
1.1.1  Web开发的变迁	2
1.1.2  移动Web与HTML 5不得不说的关系	3
1.1.3  移动Web与原生应用的优劣势	5
1.2  移动Web前端现状与未来	6
1.2.1  移动Web的现状	6
1.2.2  您需要掌握的知识体系	7
1.2.3  技术拐点与未来趋势	10
1.3  常见问题	11
1.3.1  移动Web前端开发有前景吗	11
1.3.2  PC Web和移动Web开发区别	12
1.4  本章小结	13
第2章　移动Web开发环境搭建	14
2.1  Visual Studio Code免费跨平台编辑器	14
2.2  使用Node.js	16
2.2.1  Node.js的用途	16
2.2.2  安装和调试Node.js	17
2.2.3  什么是NPM	19
2.2.4  Web代理工具NProxy	22
2.2.5  HTTP服务器http-server	24
2.3  本章小结	25
第3章　HTML 5 必会实际常用特性	26
3.1  新的语义	26
3.1.1  新元素的到来	26
3.1.2  表单的增强应用	28
3.1.3  使用音频和视频	32
3.2  访问你的设备	34
3.2.1  定位当前地埋位置	35
3.2.2  实战演练：调用摄像头拍个照	37
3.2.3  实战演练：在手机上实现摇一摇	41
3.3  离线和存储	44
3.3.1  实战演练：搭建一个简单的离线应用	44
3.3.2  离线之后资源该如何更新——Service Worker	47
3.3.3  LocalStorage与SessionStorage	48
3.3.4  实战演练：利用IndexedDB实现便签管理	51
3.4  图像效果	56
3.4.1  使用Canvas绘制一个简单的饼图	56
3.4.2  使用SVG实现奥运五环	58
3.4.3  WebGL带来了3D图像功能	60
3.5  不一样的通信	62
3.5.1  PostMessages	62
3.5.2  XMLHttpRequest Level 2	65
3.5.3  Server Sent Event	69
3.5.4  WebSocket	72
3.5.5  WebRTC	73
3.6  其他常用特性	77
3.6.1  History API与单页应用	77
3.6.2  Drag和Drop介绍	79
3.6.3  利用Web Workers加速应用计算	81
3.6.4  利用Performance API分析网站性能	82
3.7  本章小结	85
第4章　CSS 3 必会实战技巧	86
4.1  认识CSS 3	86
4.1.1  什么是CSS 3	87
4.1.2  移动Web的CSS 3现状	89
4.1.3  用Modernizr检测浏览器是否支持CSS 3	93
4.2  选择器	96
4.2.1  常见选择器	97
4.2.2  伪类和伪元素	99
4.2.3  优先级和权重	104
4.3  响应式开发	106
4.3.1  常见设备的宽高	106
4.3.2  Flex弹性盒布局	108
4.3.3  媒体查询（Media Query）	112
4.3.4  用rem开发响应式设计	115
4.3.5  多列（Multiple Columns）	119
4.4  动效	122
4.4.1  转换（Transform）	122
4.4.2  过渡（Transition）	126
4.4.3  动画（Animation）	128
4.5  常用特性	131
4.5.1  开放字体格式（WOFF）	131
4.5.2  背景（Backgrounds）	134
4.5.3  颜色（Color）	138
4.5.4  文字效果（Text Effects）	141
4.5.5  边框（Border）	144
4.6  预编译	147
4.6.1  Less介绍和安装	147
4.6.2  Less使用	150
4.6.3  Sass介绍和安装	154
4.6.4  Sass使用	156
4.6.5  Compass的安装和使用	160
4.7  本章小结	163
第5章　JavaScript关键语法及使用技巧	164
5.1  理解JavaScript	164
5.1.1  语言基础	165
5.1.2  函数和参数	168
5.2  事件	171
5.2.1  事件概述	171
5.2.2  事件委托	172
5.2.3  移动端事件	175
5.3  作用域、闭包和this	178
5.3.1  使用let实现块级作用域	178
5.3.2  闭包	180
5.3.3  采用call、apply、bind改变this	182
5.4  面向对象	184
5.4.1  原型和原型链	184
5.4.2  Mixin模式	186
5.4.3  ECMAScript 6的Class和Extends	188
5.5  异步编程	189
5.5.1  AJAX中的Callback回调函数	189
5.5.2  Promise模式	190
5.5.3  生成器Generator	192
5.6  模块化	194
5.6.1  为什么需要模块化	195
5.6.2  AMD和CMD规范	197
5.6.3  ECMAScript 6标准的模块支持	205
5.7  ECMAScript 6其他常用功能	207
5.7.1  基础数据类型的扩展	207
5.7.2  使用解构赋值来简化代码	210
5.7.3  使用Babel插件提前使用新特性	212
5.8  本章小结	215
第6章　HTML 5 移动开发实战	216
6.1  在地图上显示行走轨迹	216
6.2  仿原生相册	220
6.2.1  实现相册初始展示页	221
6.2.2  通过手势操作控制相片	222
6.3  使用Socket.IO制作小型聊天室	224
6.3.1  前端HTML+JavaScript实现聊天界面	225
6.3.2  服务器端Node.js监听连接	227
6.4  移动端拍照上传实践	228
6.4.1  前端HTML+CSS+JavaScript	229
6.4.2  服务器端Node.js	232
6.5  利用Microdata进行SEO优化	232
6.5.1  认识Microdata	233
6.5.2  提升网页SEO效果	233
6.6  制作一个带字幕的视频播放器	237
6.7  使用Pixi.js制作“抓住开学君”游戏（Canvas+WebGL）	242
6.8  用Canvas制作刮刮卡	248
6.9  实战演练：实现3D全景效果	251
6.9.1  需要的CSS 3特性	251
6.9.2  实现原理	251
6.9.3  实现代码	253
6.10  本章小结	255
第7章　移动网页样式布局实战	256
7.1  静态布局的实际应用	256
7.1.1  设计活动页面静态布局	257
7.1.2  静态布局在移动端上的自适应	257
7.2  水平居中与垂直居中实战	259
7.2.1  水平居中	259
7.2.2  自适应块级元素水平居中	260
7.2.3  行内元素垂直居中	261
7.2.4  块级元素的垂直居中	263
7.2.5  基于视口单位的解决方案	264
7.2.6  基于Flexbox的解决方案	265
7.3  栅格系统实现响应式列表	267
7.3.1  实现栅格布局	267
7.3.2  栅格布局的原理	269
7.4  Flex多栏布局实战	269
7.5  实战演练：沪江网校首页rem布局实践	272
7.6  实战演练：侧边栏的滑进滑出效果	276
7.7  实战演练：模拟原生的页面切换效果	280
7.7.1  实现页面切换过渡效果	280
7.7.2  模拟切换原理解析	283
7.8  提高Web动画的性能实战	284
7.8.1  使用CSS 3动画	284
7.8.2  使用高性能的JavaScript动画	285
7.9  实战演练：课程分类列表实战	286
7.9.1  实现主页结构	287
7.9.2  响应式CSS实现（Compass）	289
7.9.3  添加页面动态效果	293
7.10  本章小结	294
第8章　前端工程化实战	295
8.1  前端工程化	295
8.1.1  前端工程化的必要性	296
8.1.2  前端工程化的发展史	298
8.2  工程化入门Grunt	300
8.2.1  安装和配置	301
8.2.2  Grunt插件	302
8.2.3  实战演练：使用Grunt开发一个简易相册	305
8.3  使用Gulp构建一个ECMAScript 6和Sass应用	309
8.3.1  安装和配置	309
8.3.2  预处理任务	310
8.3.3  实战演练：采用ECMAScript 6开发一个Markdown编辑器	312
8.3.4  代码检查任务	315
8.3.5  代码合并、压缩、重命名任务	317
8.3.6  监听文件变化自动构建	318
8.4  实战演练：使用Webpack构建一个React应用	320
8.4.1  安装和配置	320
8.4.2  常用的加载器和插件	323
8.4.3  缓存控制	327
8.4.4  简化模块引用	330
8.4.5  异步模块加载	332
8.4.6  使用Source Map调试代码	335
8.5  本章小结	338
第9章　移动Web常用开发方式实战	339
9.1  基于DOM的开发方式	339
9.1.1  使用Zepto和前端模板开发简单备忘录	340
9.1.2  解决原生单击事件的缺陷	341
9.1.3  为何抛弃掉Zepto	343
9.2  基于React的开发方式	345
9.2.1  使用JSX语法创建React组件	345
9.2.2  在实践中掌握React生命周期	348
9.2.3  实现组件间通信	353
9.2.4  实现组件关注分离	355
9.2.5  实战演练：运用组件化方式开发一个备忘录	358
9.2.6  如何管理应用的状态	364
9.2.7  添加动画效果	366
9.2.8  提高React组件性能	369
9.3  基于Vue.js的开发方式	372
9.3.1  实战演练：开发一个简单的备忘录应用（Vue.js 2.0）	372
9.3.2  管理应用的状态及实现组件间的通信	375
9.3.3  添加动画效果	379
9.4  打造单页应用SPA	381
9.4.1  单页应用的优势是什么	382
9.4.2  实战演练：实现一个单页路由	382
9.4.3  实战演练：使用React开发一个简单的单页应用	384
9.4.4  单页应用的状态管理	386
9.5  本章小结	388
第10章　混合式开发实战	389
10.1  为什么需要混合式开发	389
10.1.1  混合式开发种类	389
10.1.2  混合式开发的优势	390
10.1.3  选择合适的混合式开发方案	391
10.2  Cordova开发入门	392
10.2.1  JavaScript和Native互相调用	392
10.2.2  Cordova介绍和安装	394
10.2.3  Cordova开发使用	397
10.3  React Native实战	400
10.3.1  React Native简介	400
10.3.2  React Native样式和布局	402
10.3.3  React Native组件概念	404
10.3.4  简单组件实战	404
10.3.5  复合组件实战	405
10.3.6  第三方组件实战	406
10.3.7  常用API实践	407
10.4  实战演练：用React Native开发新闻阅读应用	410
10.4.1  React Native的工程项目结构一览	410
10.4.2  列表页	411
10.4.3  新闻评论页	414
10.4.4  新闻展示页	414
10.5  本章小结	415
第11章　前端开发调试实战	417
11.1  浏览器调试	417
11.1.1  Chrome开发者工具	418
11.1.2  Safari开发者工具	421
11.2  代理工具	424
11.2.1  Mac OS下Charles的用法	424
11.2.2  Windows下Fiddler的用法	426
11.3  多终端同步工具	428
11.3.1  多设备浏览器同步测试工具BrowserSync	429
11.3.2  双向自动刷新样式工具Emmet LiveStyle	431
11.4  模拟器调试	432
11.4.1  Android模拟器调试	432
11.4.2  iOS模拟器调试	434
11.4.3  在线模拟器Manymo	436
11.5  多平台调试	437
11.5.1  网站响应式设计测试工具Ghostlab	437
11.5.2  移动端Web开发调试工具Weinre	439
11.5.3  JavaScript远程调试和测试工具Vorlon.JS	442
11.6  云真机调试	444
11.6.1  浏览器兼容性云端测试应用BrowserStack	444
11.6.2  Web端移动设备管理控制工具STF	446
11.6.3  多浏览器兼容性测试平台F2etest	448
11.7  React调试	452
11.7.1  React Developer Tools	452
11.7.2  Redux DevTools	455
11.8  本章小结	458
第12章　前端单元测试实战	459
12.1  JavaScript单元测试框架Jasmine实战	459
12.2  使用Mocha和Chai在Node.js进行单元测试	462
12.3  使用Sinon辅助单元测试	465
12.4  使用Karma自动化单元测试	468
12.5  使用Istanbul计算代码覆盖率	470
12.6  使用Benchmark.js进行基准测试	473
12.7  实战演练：React版备忘录项目的完整单元测试	475
12.8  本章小结	479
第13章　前端性能优化实战	480
13.1  常用网站性能优化指标	480
13.1.1  网页的资源请求与加载阶段	481
13.1.2  网页渲染阶段	482
13.1.3  JavaScript脚本的执行速度	484
13.2  依旧有效的Yahoo性能优化法则	484
13.3  性能优化工具使用实战	486
13.3.1  YSlow	486
13.3.2  PageSpeed	487
13.3.3  WebPagetest	488
13.4  HTTP协议头缓存实战	489
13.4.1  客户端缓存流程	489
13.4.2  缓存协议内容	490
13.4.3  实战演练：HTTP缓存	491
13.5  资源按需加载实战	492
13.5.1  基于RequireJS的按需加载	492
13.5.2  基于Webpack的按需加载	493
13.5.3  图片懒加载	494
13.6  不同网络类型的优化实战	495
13.6.1  获取网络类型	495
13.6.2  弱网图片优化	496
13.6.3  弱网缓存优化	496
13.7  实战演练：Nginx配置Combo合并HTTP请求	497
13.7.1  安装Nginx和文件合并模块	498
13.7.2  配置Nginx和Combo	499
13.8  本章小结	499
第14章　项目实战：搭建直播平台（Cordova+Koa+React）	500
14.1  项目的安装和启动	500
14.1.1  安装依赖	501
14.1.2  启动项目	501
14.1.3  Cordova打包	502
14.2  直播平台功能预览	502
14.2.1  直播流程	503
14.2.2  直播核心页面	503
14.3  页面的布局和结构	504
14.3.1  首页	504
14.3.2  发起直播页面	505
14.3.3  观看直播页面	505
14.4  搭建WebRTC服务端——Koa	506
14.5  实现多人在线直播功能	512
14.6  实现弹幕客户端与服务端通信	517
14.6.1  客户端与服务端通信的过程	517
14.6.2  客户端代码设计——React	518
14.6.3  服务端代码设计	520
14.7  本章小结	521
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>移动Web前端高效开发实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JavaScript应用程序设计
目录
前言 1
第1章 JavaScript的革命时代 7
JavaScript的特性 8
性能 8
对象 8
语法 9
函数是一等公民 9
事件 9
复用性 10
结论 10
解构现代JavaScript应用 10
基础架构 10
JSON ——数据存储与通信 11
NoSQL数据库 12
RESTful JSON Web Services 12
第2章 函数 15
减少隐式副作用 16
函数声明 18
lambdas 22
立即执行函数表达式 23
方法上下文 25
函数作用域 27
变量提升 28
闭包 30
方法API的设计 33
参数命名 33
多态函数 34
范型编程与集合多态 37
链式调用与流式API 40
函数式编程 41
无状态函数(纯函数) 43
偏函数应用与函数加里化 44
异步操作 45
回调函数 46
Promises与Deferreds 46
小结 49
第3章 对象 50
过时的类继承 51
流式JavaScript 53
原型 56
原型代理 56
原型克隆 58
享元模式 60
创建对象 61
工厂函数 63
使用Stamps进行原型继承 66
小结 71
第4章 模块 73
模块化编程原则 74
接口 75
模块模式 79
AMD规范 81
加载器插件 82
CommonJS模块规范 84
npm包管理器 85
ES6模块规范 87
基于CommonJS、npm、Grunt与Browserify构建客户端应用 89
定义应用 89
特性实现 91
构建与部署 94
小结 98
第5章 关注点分离 99
客户端的关注点 100
模块管理 101
模型－视图－控制器 113
表现层与Dom操作 116
服务端关注点 123
Node与Express入门 124
在Node中组织代码 125
小结 132
第6章 访问控制 134
身份验证 134
密码认证 134
Credential类库 138
多因素身份验证 140
联合认证与授权认证 142
应用功能授权 144
应用授权 144
OAuth 2.0协议 145
小结 146
第7章 日志 147
调试 147
服务端数据监控 149
安全/入侵检测 149
审计 150
业务指标分析 150
传播力度 151
日志清单 151
应用请求日志 152
异常日志 156
日志输出示例 158
日志预警 161
跟踪业务指标（效果跟踪） 162
性能分析与优化 162
客户端事件记录 163
日志数据挖掘 164
小结 165
第8章 构建RESTful API 166
可用性 167
专一性 167
一致性 169
自描述的超媒体 177
功能可见性 177
超媒体即应用状态引擎 178
HTML：一种特别的API媒介类型 180
Jade 180
Jiron 182
响应式API 184
性能优化 186
小结 187
第9章 特性开关 188
组织特性 188
特性的规模 188
特性编组 189
特性的生命周期 189
开发阶段 190
预发布阶段 190
灰度测试 190
正式发布 190
默认激活 191
完整集成 191
客户端实现 191
小结 195
第10章 应用工程国际化 196
小结 198
附录A JavaScript编码风格指南 199
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>JavaScript应用程序设计
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Koa与Node.js开发实战
第1篇  基础知识
第1章  Node.js入门  2
1.1  Node.js介绍  2
1.1.1  什么是Node.js  3
1.1.2  Node.js的历史和发展过程  4
1.1.3  Node.js的特点和应用场景  7
1.1.4  安装Node.js  8
1.1.5  实战演练：使用Node.js搭建一个HTTP Server  10
1.2  NPM  11
1.2.1  NPM介绍  12
1.2.2  NPM模块结构  13
1.2.3  使用NVM控制Node.js版本  16
1.2.4  Web代理工具NProxy  18
1.2.5  实战演练：在npm.org上发布一个模块  20
1.3  Visual Studio Code编辑器  22
1.3.1  Visual Studio Code的安装及其功能  22
1.3.2  使用Visual Studio Code调试Node.js  23
1.4  本章小结  25
第2章  遇见Koa  26
2.1  Koa介绍  26
2.1.1  Koa的前世今生  26
2.1.2  Koa的安装及搭建（视频演示）  29
2.2  Context对象  30
2.2.1  什么是Context对象  31
2.2.2  常用属性和方法  31
2.3  Koa的中间件  35
2.3.1  中间件概念  35
2.3.2  实战演练：使用中间件获取响应时间（视频演示）  38
2.3.3  常用Koa中间件介绍  39
2.4  本章小结  43
第3章  路由  44
3.1  路由介绍  44
3.1.1  路由的概念  45
3.1.2  实战演练：使用Koa中的简单路由自定义404页面  46
3.2  koa-router路由中间件  48
3.2.1  koa-router的安装和介绍  48
3.2.2  RESTful规范  48
3.2.3  koa-router用法（视频演示）  50
3.2.4  通过koa-router实现接口的权限控制  55
3.3  本章小结  58
第4章  HTTP  59
4.1  HTTP介绍  59
4.1.1  HTTP的诞生  59
4.1.2  URI和URL  62
4.1.3  常用的HTTP状态码  63
4.1.4  常用的请求方法  63
4.1.5  常用的HTTP首部字段  64
4.2  HTTP/2  65
4.2.1  采用二进制格式传输数据  65
4.2.2  多路复用  65
4.2.3  流的优先级  66
4.2.4  首部压缩  66
4.2.5  服务端推送  67
4.3  Node.js的querystring模块  67
4.3.1  querystring模块的使用  67
4.3.2  koa-router中的querystring（视频演示）  68
4.3.3  实战演练：电影搜索列表  69
4.4  koa-bodyparser中间件  72
4.4.1  koa-bodyparser介绍  72
4.4.2  koa-bodyparser的使用（视频演示）  73
4.4.3  实战演练：实现用户注册功能并进行数据解析  74
4.5  本章小结  77
第2篇  应用实战
第5章  构建Koa Web应用  80
5.1  MVC  80
5.1.1  MVC的发展历程  81
5.1.2  MVC三层架构  81
5.1.3  在Koa中实现MVC（视频演示）  83
5.2  模板引擎  87
5.2.1  什么是模板引擎  88
5.2.2  常见的模板引擎有哪些  88
5.2.3  Nunjucks语法介绍  91
5.2.4  Nunjucks在Koa中的应用（视频演示）  96
5.3  静态资源  97
5.3.1  静态资源的类型  98
5.3.2  koa-static简介  99
5.3.3  koa-static常用配置（视频演示）  99
5.3.4  实战演练：开发登录验证页面（视频演示）  100
5.4  其他常用开发技巧  103
5.4.1  简易版koa-json插件开发（视频演示）  103
5.4.2  使用koa-multer中间件实现文件上传  106
5.5  本章小结  110
第6章  数据库  111
6.1  数据库介绍  111
6.1.1  什么是数据库  111
6.1.2  常见的数据库  113
6.2  在Koa中应用MySQL数据库  114
6.2.1  下载安装MySQL  114
6.2.2  Sequelize介绍  118
6.2.3  实战演练：客户信息数据展现  122
6.3  在Koa中应用MongoDB数据库  126
6.3.1  下载安装MongoDB  126
6.3.2  Mongoose介绍  128
6.3.3  实战演练：课程表数据展现  132
6.4  在Koa中应用Redis数据库  135
6.4.1  什么是Redis  135
6.4.2  Redis库介绍  138
6.4.3  实战演练：持久化用户Session状态  141
6.5  本章小结  145
第7章  单元测试  146
7.1  Chai断言库  147
7.1.1  Chai的介绍和安装  147
7.1.2  Chai的使用  147
7.2  Mocha框架  149
7.2.1  Mocha的介绍和安装  150
7.2.2  Mocha的使用  150
7.3  SuperTest测试RESTful API  154
7.3.1  SuperTest的介绍和安装  154
7.3.2  SuperTest的使用  154
7.4  其他常用工具  155
7.4.1  Nock模拟服务器响应  156
7.4.2  Nyc测试覆盖率  157
7.5  本章小结  159
第8章  优化与部署  161
8.1  服务优化  161
8.1.1  使用log4js记录日志（视频演示）  162
8.1.2  自定义错误页（视频演示）  168
8.1.3  异常捕获处理  173
8.1.4  实战演练：优化Web开发项目结构（视频演示）  176
8.2  部署  179
8.2.1  Node.js进程管理器PM2  179
8.2.2  应用容器引擎Docker  182
8.2.3  在线免费开源集成Travis CI  185
8.2.4  利用Nginx部署HTTPS  189
8.3  服务监控  192
8.3.1  Node.js服务性能指标及采集  192
8.3.2  日志分析系统ELK  196
8.3.3  Keymetrics监控云服务  197
8.4  本章小结  199
第3篇  项目实战：从零开始搭建微信小程序后台
第9章  云相册功能介绍和准备工作  203
9.1  应用介绍  204
9.2  小程序开发账户申请  206
9.3  准备域名  209
9.3.1  注册域名  209
9.3.2  实名认证  211
9.3.3  域名备案  212
9.4  准备云服务器  216
9.5  配置DNS解析  218
9.6  本章小结  221
第10章  云相册服务开发  222
10.1  小程序登录  222
10.2  扫码登录  230
10.3  小程序接口  236
10.3.1  建立数据模型  236
10.3.2  定义相册接口  238
10.3.3  定义照片接口  242
10.4  后台管理系统接口  244
10.4.1  定义用户列表接口  244
10.4.2  定义权限管理接口  246
10.4.3  定义获取照片接口  247
10.4.4  定义审核照片接口  249
10.5  记录日志  249
10.6  本章小结  252
第11章  云相册小程序开发  254
11.1  项目介绍  254
11.2  结合Redux实现小程序组件通信  259
11.3  “个人中心”页面  264
11.4  “新建相册”页面  267
11.4.1  自定义组件用法介绍  267
11.4.2  组件事件  269
11.4.3  实现“新建相册”组件  270
11.5  “相册列表”页面  272
11.5.1  展示相册列表  273
11.5.2  进入指定相册页面  274
11.5.3  调用“新建相册”组件  274
11.6  “照片列表”页面  275
11.6.1  获取照片列表数据  276
11.6.2  数据按日期分组  277
11.6.3  上传照片到当前相册  278
11.6.4  单击图片显示高清大图  279
11.7  小程序审核发布  280
11.8  本章小结  282
第12章  云相册后台管理系统  283
12.1  整体架构  284
12.1.1  基本文件结构  285
12.1.2  前端模板结构  287
12.1.3  路由设计  290
12.2  相册列表及相关功能  292
12.2.1  分类展示照片  293
12.2.2  审核照片  297
12.2.3  HTTP通信  301
12.2.4  分页控件  302
12.3  用户列表及相关功能  304
12.4  登录与鉴权  309
12.4.1  登录  310
12.4.2  鉴权中间件  315
12.5  额外展开：SVG动画效果及其他  317
12.6  本章小结  318
第13章  云相册服务器部署  319
13.1  部署数据库  321
13.1.1  存储设置  322
13.1.2  安全策略  323
13.2  部署Nginx  325
13.2.1  安装OpenResty  325
13.2.2  Nginx配置  326
13.2.3  插件扩展  328
13.3  部署HTTPS  329
13.3.1  强制HTTPS跳转  329
13.3.2  添加WWW跳转  330
13.4  配置Koa服务  331
13.5  本章小结  332
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Koa与Node.js开发实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node学习指南
《node学习指南》
第1章　node.js：启动与运行　1
1.1　搭建node开发环境　2
1.1.1　linux(ubuntu)下安装node　2
1.1.2　windows 7平台下node+webmatrix　4
1.1.3　升级node　8
1.2　开始node开发　9
1.2.1　hello, world in node　9
1.2.2　分析“hello,world”　11
1.3　异步函数及node事件循环　13
1.3.1　使用异步方式读取文件　14
1.3.2　观察异步程序流程　15
1.4　node的优势　19
第2章　node与repl　20
2.1　repl：先睹为快和未定义的表达式　20
2.2　repl的优势：更好地理解表层之下的javascript　22
2.3　多行以及更复杂的javascript　23
2.3.1　repl命令　26
2.3.2　repl和rlwrap　27
2.3.3　定制repl　28
.2.4　不可预计的意外——记得经常保存　32
第3章　node核心库　33
3.1　全局对象：global、process和buffer　34
3.1.1　global　34
3.1.2　process　36
3.1.3　buffer　38
3.2　定时器：settimeout、cleartimeout、setinterval 和clearinterval　39
3.3　servers、streams和sockets　40
3.3.1　tcp sockets和servers　41
3.3.2　http　43
3.3.3　udp数据报套接字　45
3.3.4　流、管道和readline　47
3.4　子进程　49
3.4.1　child_process.spawn　50
3.4.2　child_process.exec和child_process.execfile　52
3.4.3　child_process.fork　52
3.4.4　在windows系统中使用子进程　53
3.5　域名解析和url处理　54
3.6　utilities模块和对象继承　55
3.7　events和eventemitter　59
第4章　node模块系统　63
4.1　使用require和默认路径加载模块　63
4.2　外部模块和node包管理工具　65
4.3　如何找到你需要的模块　69
4.3.1　colors：简单至上　71
4.3.2　optimist：另一个简单的小模块　73
4.3.3　underscore　74
4.4　创建自定义模块　75
4.4.1　打包整个目录　76
4.4.2　为你的模块发布做准备　76
4.4.3　发布模块　80
第5章　控制流、异步模式和异常处理　82
5.1　使用callback而不使用promises　82
5.2　顺序调用、嵌套回调、异常捕获　85
5.3　异步模式和控制流模块　92
5.3.1　step　93
5.3.2　async　96
5.4　node编码风格　101
第6章　路由寻址、服务文件和中间件　103
6.1　从头开始：创建一个简单的静态文件服务器　103
6.2　中间件　110
6.2.1　connect基本知识　111
6.2.2　connect中间件　113
6.2.3　定制connect中间件　118
6.3　routers　121
6.4　proxies　124
第7章　express框架　128
7.1　express：启动和运行　129
7.2　app.js文件　130
7.3　错误处理　133
7.4　express与connect的关系　134
7.5　路由　135
7.5.1　路由路径　137
7.5.2　路由和http动词　140
7.6　关于mvc　147
7.7　使用curl测试express应用程序　152
第8章　express、模板系统和css　154
8.1　ejs模板系统(embedded javascript template system)　154
8.1.1　基本语法　155
8.1.2　node与ejs　156
8.1.3　ejs与node filters　158
8.2　在express中使用ejs　159
8.2.1　多对象环境的改造　161
8.2.2　静态文件路由　162
8.2.3　处理一个新对象的post请求　164
8.2.4　widget索引和生成picklist　166
8.2.5　显示单个对象并确认对象的删除操作　168
8.2.6　提供更新信息的表达以及处理put请求　170
8.3　jade模板系统　173
8.3.1　jade语法简介　173
8.3.2　使用block和extends模块化视图模板　176
8.3.3　widget view转换为jade模板　178
8.3.4　转换edit和delete表单　179
8.4　使用stylus完成简单的css样式　182
第9章　结构化数据、noe和redis　187
9.1　node和redis　188
9.2　构建游戏得分排行榜　190
9.3　创建消息队列　197
9.4　为express应用程序添加统计中间件　201
第10章　node和mongodb：文档中心数据　206
10.1　mongodb native node.js driver(mongodb原生node.js驱动)　207
10.1.1　mongodb入门　207
10.1.2　定义、创建以及销毁mongodb collection　208
10.1.3　为collection添加数据　209
10.1.4　查询数据　212
10.1.5　使用updates、upserts、find和remove　216
10.2　使用mongoose实现widget模块　221
10.3 重构widget工厂　222
10.4　添加mongodb后台　223
第11章　node与关系型数据库　228
11.1　db-mysql入门　229
11.1.1　查询字符串和方法链　229
11.1.2　使用查询字符串更新数据库　233
11.1.3　使用方法链更新数据库　235
11.2　使用node-mysql实现本地mysql访问　237
11.2.1　使用node-mysql做基本的crud操作　237
11.2.2　mysql事务与mysql-queues　239
11.3　orm与sequelize　241
11.3.1　定义模型　241
11.3.2　orm风格的crud实现　243
11.3.3　添加多个对象　246
11.3.4　从关系型到orm　247
第12章　图形和html5 video　248
12.1　创建和使用pdf　248
12.1.1　使用子进程访问pdf工具　249
12.1.2　使用pdfkit创建pdf　257
12.2　从子进程访问imagemagick　258
12.3　通过http提供html5 video服务　263
12.4　创建和流化画布内容(canvas content)　267
第13章　websockets和socket.io　271
13.1　websockets　271
13.2　socket.io简介　272
13.2.1　一个简单的通信范例　273
13.2.2　异步世界里的websockets　276
13.2.3　关于客户端代码　277
13.3　配置socket.io　278
13.4　chat：websockets版本的“hello, world”　279
13.5　在express中使用socket.io　282
第14章　node应用程序的测试和调试　284
14.1　调试　284
14.1.1　node.js debugger　284
14.1.2　使用node inspector的客户端调试　287
14.2　单元测试(unit testing)　289
14.2.1　assert与单元测试　289
14.2.2　nodeunit与单元测试　293
14.2.3　其他测试框架　295
14.3　验收测试　299
14.3.1　soda和selenium测试　299
14.3.2　通过tobi和zombie模拟浏览器　303
14.4　性能测试：基准问题和负载测试　304
14.4.1　apachebench基准测试　305
14.4.2　nodeload与负载测试　309
14.5　nodemon更新代码　312
第15章　安全及防护　313
15.1　数据加密　314
15.1.1　tsl/ssl配置　314
15.1.2　使用https　315
15.1.3　如何安全的保存密码　317
15.2　认证/授权及passport　320
15.2.1　授权/认证策略：oauth、openid、用户名/密码验证　321
15.2.2　local passport strategy　323
15.2.3　twitter passport strategy(oauth)　330
15.3　保护应用程序，防止攻击　336
15.3.1　不要使用eval　336
15.3.2　尽量使用复选框、单选按钮和下拉式选项　337
15.3.3　使用node-validator　337
15.4　在沙箱中执行代码　339
第16章　扩展和部署node应用　343
16.1　把你的节点部署到服务器上　343
16.1.1　编写package.json文件　344
16.1.2　使用forever让你的应用“永不掉线”　347
16.1.3　使用node和apache　350
16.1.4　改善性能　352
16.2　部署到云服务　352
16.2.1　通过cloud9 ide部署到windows azure　353
16.2.2　joyent development smartmachine　355
16.2.3　heroku　355
16.2.4　amazon ec2　356
16.2.5　nodejitsu　356
附录　node、git和github　357
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node学习指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>全栈开发之道
入 门 篇
第1章 Bootstrap基础 2
1.1 概述 2
1.2 Bootstrap开发环境 3
1.2.1 Bootstrap的安装 3
1.2.2 Bootstrap的加载 5
1.3 Bootstrap 常用工具 6
1.3.1 Bootstrap代码编辑工具 6
1.3.2 Bootstrap设计工具——Layout IT 7
1.4 Bootstrap 布局 8
1.4.1 HTML标准模板 8
1.4.2 自定义CSS 10
1.4.3 响应式布局的实现 12
1.4.4 禁用响应式布局 16
1.5 小结 16
第2章 JavaScript基础 17
2.1 概述 17
2.2 JavaScript 语法 17
2.2.1 变量中的声明与赋值 18
2.2.2 如何判断两个字符串是否相等 19
2.2.3 创建JavaScript对象的三种方法 21
2.2.4 函数声明与函数表达式 23
2.2.5 可立即调用的函数表达式 25
2.2.6 循环的实现 27
2.2.7 防止JavaScript自动插入分号 28
2.2.8 严格模式 29
2.3 如何运行与调试JavaScript代码 30
2.3.1 把JavaScript代码内嵌到HTML页面中 30
2.3.2 通过Node.js运行JavaScript代码 31
2.4 JavaScript的面向对象设计思想 32
2.5 JavaScript的异步编程模式 33
2.5.1 Promise对象 34
2.5.2 生成Promise实例对象 34
2.5.3 Promise原型方法 35
2.5.4 Promise的catch方法 36
2.5.5 Promise在Node.js中的应用 37
2.6 如何在HTML中嵌入JavaScript 37
2.6.1 ＜script＞标签 37
2.6.2 ＜script＞标签的位置 38
2.6.3 嵌入JavaScript代码与外部文件引用 39
2.7 JavaScript与JSON 39
2.7.1 JSON概述 39
2.7.2 什么是JSON 40
2.7.3 JSON语法规则 40
2.8 小结 42
基 础 篇
第3章 Node.js入门指南 44
3.1 概述 44
3.2 Node.js生态 44
3.3 Node开发环境的搭建 45
3.4 Node.js验证 45
3.5 第一个Node.js工程 46
3.5.1 创建Node.js工程 46
3.5.2 运行Node.js工程 47
3.6 Node.js的module应用 50
3.7 Node.js 编码规范 52
3.8 小结 53
第4章 Express——后端框架 54
4.1 概述 54
4.2 第一个Express工程 54
4.2.1 Express工程的创建 54
4.2.2 Express的路由 55
4.2.3 Express的中间件 56
4.2.4 设置静态目录 57
4.3 Express中的Cookie与Session 58
4.3.1 Cookie是如何工作的 58
4.3.2 Session是什么 58
4.3.3 为什么需要Session 59
4.3.4 Session应用场景 59
4.4 Express中的网络请求方法 59
4.4.1 req.params 60
4.4.2 req.query 61
4.4.3 req.body 61
4.4.4 网络请求方法 61
4.5 Express中的GET与POST请求 62
4.5.1 GET请求 62
4.5.2 post请求 62
4.6 通过Express 实现登录页面 63
4.6.1 get请求验证 66
4.6.2 post请求验证 68
4.7 小结 69
第5章 Express的模板引擎 70
5.1 模板引擎概述 70
5.1.1 什么是模板引擎 70
5.1.2 模板引擎的选择 71
5.1.3 服务器端模板引擎 71
5.2 模板引擎的种类 72
5.2.1 模板引擎Jade 72
5.2.2 模板引擎Handlebars 73
5.2.3 模板引擎EJS 73
5.3 Express中的EJS 73
5.3.1 创建工程Express工程 74
5.3.2 引入工程的依赖包（dependency） 74
5.3.3 启动应用 76
5.3.4 EJS模板引擎的触发 77
5.4 小结 78
第6章 AngularJS——Google前端框架 79
6.1 AngularJS概述 79
6.2 AngularJS 常用指令 81
6.2.1 AngularJS 指令概述 81
6.2.2 AngualrJS指令：ng-app 81
6.2.3 AngularJS指令：ng-init 82
6.2.4 AngularJS表达式 82
6.2.5 AngularJS指令：ng-model 83
6.2.6 ng-app与ng-model示例 83
6.2.7 ng-app与ng-model常见错误分析 84
6.2.8 {{ }}的应用 85
6.2.9 指令：ng-bind 86
6.2.10 指令：ng-click 86
6.3 AngularJS构建单页面应用 86
6.3.1 单页面应用的优势 86
6.3.2 轻松构建单页面应用 88
6.3.3 单页面应用的实现 89
6.4 AngularJS的加载 93
6.4.1 AngularJS的引用 93
6.4.2 加载AngularJS静态资源库 94
6.5 AngularJS 的注入 94
6.5.1 依赖注入 94
6.5.2 依赖注入的行内声明 97
6.6 AngularJS 的Module 99
6.6.1 AngularJS Module 概述 99
6.6.2 AngularJS的Module 应用 100
6.7 AngularJS 控制器 102
6.7.1 控制器命名方法 102
6.7.2 AngularJS 控制器的创建 102
6.7.3 AngularJS控制器的应用 103
6.8 AngularJS的数据绑定 105
6.9 $scope用法 106
6.10 小结 109
第7章 MongoDB——文档数据库 110
7.1 MongoDB概述 110
7.1.1 MongoDB简介 110
7.1.2 MongoDB的历史 110
7.1.3 MongoDB的优势 111
7.1.4 MongoDB的安装 111
7.1.5 启动MongoDB 112
7.2 数据库存储机制 112
7.2.1 关系型数据库 112
7.2.2 NoSQL数据库 112
7.3 MongoDB数据结构 113
7.3.1 文档 113
7.3.2 集合 114
7.3.3 MongoDB存储格式——BSON 115
7.4 Mongo Shell 116
7.4.1 Mongo Shell简介 116
7.4.2 运行Mongo Shell 116
7.4.3 Mongo Shell基本操作 117
7.5 MongoDB文档操作 118
7.5.1 创建一个文档 118
7.5.2 查询所有文档 118
7.5.3 查询某一个文档 119
7.5.4 文档的更新 120
7.5.5 文档的删除 120
7.5.6 删除集合 121
7.6 _id和ObjectId 121
7.7 MongoDB管理工具 121
7.7.1 MongoDB可视化工具——Robomongo 121
7.7.2 Robomongo的安装 122
7.8 用mongoose操作MongoDB 125
7.8.1 mongoose概述 125
7.8.2 初识mongoose 125
7.8.3 mongoose的安装 126
7.8.4 mongoose连接数据库 126
7.8.5 Schema 127
7.8.6 Model及其操作 127
7.9 小结 132
实 战 篇
第8章 应用实例1——用户管理 134
8.1 概述 134
8.2 实现的思路 135
8.3 Node.js工程结构 135
8.3.1 创建一个Node服务 136
8.3.2 构建index.html页面 136
8.3.3 构建AngularJS页面 137
8.3.4 构建controller数据 138
8.3.5 构建路由 138
8.3.6 连接MongoDB 140
8.4 简单的用户管理操作 142
8.4.1 增加一条记录 142
8.4.2 删除一条记录 144
8.4.3 编辑与更新一条记录 146
8.4.4 $set与$unset的应用 149
8.5 小结 150
第9章 应用实例2——登录管理 151
9.1 概述 151
9.2 安装Express 151
9.3 创建Express工程 151
9.4 构建登录页面 157
9.4.1 构建登录的静态页面 157
9.4.2 构建路由 159
9.4.3 添加路由中间件 161
9.5 构建注册页面 161
9.5.1 静态页面的创建 161
9.5.2 构建注册页面的路由 163
9.5.3 添加路由中间件 166
9.6 小结 166
第10章 应用实例3——记事本 167
10.1 概述 167
10.2 实现思路 168
10.3 构建AngularJS应用 168
10.3.1 控制器 169
10.3.2 模块 171
10.3.3 模板 172
10.3.4 布局模板 172
10.3.5 路由 173
10.3.6 工厂方法 175
10.3.7 页面跳转 177
10.3.8 $routeProvider 180
10.3.9 过滤器 182
10.3.10 $index的应用 184
10.3.11 控制器之间的传值 185
10.3.12 $rootScope 185
10.3.13 使用$watch监控数据模型的变化 186
10.4 创建Express工程 189
10.5 创建MongoDB 190
10.5.1 连接MongoDB 190
10.5.2 创建mongoose的model 191
10.6 创建RESTful API 191
10.6.1 GET请求 191
10.6.2 POST请求 192
10.6.3 查找指定的对象 193
10.6.4 更新 194
10.6.5 删除 194
10.7 构建MEAN工程 194
10.7.1 路由 194
10.7.2 构建动态页面 196
10.7.3 $http的应用 196
10.7.4 基于$http的工厂方法 197
10.7.5 RESTful API的调用 198
10.7.6 基于$resource的工厂方法 199
10.7.7 创建一条记录 199
10.7.8 查看记录详情 201
10.7.9 更新记录 203
10.7.10 删除记录 206
10.7.11 运行结果 207
10.8 小结 208
第11章 应用实例4——商品管理 210
11.1 概述 210
11.2 实现思路 211
11.2.1 开发环境的搭建 211
11.2.2 创建Express工程 211
11.2.3 安装Monk 212
11.3 数据库管理 212
11.3.1 构建数据库模拟数据 213
11.3.2 通过Express创建访问数据库的API 213
11.4 重构页面 219
11.4.1 引入AngularJS 219
11.4.2 通过AngularJS重构首页 220
11.4.3 控制器的实现 222
11.4.4 when方法 225
11.4.5 $resource的调用 225
11.4.6 文档对象的创建 226
11.4.7 $location的应用 233
11.4.8 文档对象的编辑 234
11.4.9 $routeParams的应用 242
11.4.10 文档对象的删除 243
11.5 小结 245
参考文献 247
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>全栈开发之道
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>使用HTML5和Node构建超媒体API
序 ................................................................................. xi
前言 .............................................................................xiii
第1 章 理解超媒体 ........................................................ 1
HTTP、MIME 和超媒体 ........................................................................................2
HTTP 是传输协议 ...........................................................................................2
MIME 是媒体类型标准 ...................................................................................3
超媒体是引擎 ..................................................................................................5
使用超媒体APIs 编写Web 应用 ...........................................................................6
类型封送困局 ..................................................................................................7
超媒体解决方案 ............................................................................................10
识别超媒体：超媒体因子（H-Factors） ...............................................................13
链接因子 .......................................................................................................14
控制因子 .......................................................................................................16
超媒体设计元素 ...................................................................................................19
基本格式 .......................................................................................................20
状态转移 .......................................................................................................23
领域风格 .......................................................................................................25
应用流程 .......................................................................................................28
总结 .....................................................................................................................32
后续内容 ..............................................................................................................33
第2 章 XML 超媒体 .................................................... 35
场景 .....................................................................................................................35
设计Maze XML 媒体类型 ...................................................................................36
识别状态转移 ................................................................................................36
选择基本设计元素 ........................................................................................37
Maze+XML 文档 ...........................................................................................38
示例数据 ..............................................................................................................41
服务器代码 ..........................................................................................................42
集合状态响应 ................................................................................................43
单项状态响应 ................................................................................................43
格子状态响应 ................................................................................................44
退出状态响应 ................................................................................................45
客户端代码 ..........................................................................................................46
迷宫游戏示例 ................................................................................................46
迷宫机器人示例 ............................................................................................51
总结 .....................................................................................................................56
第3 章 JSON 超媒体 ................................................... 57
场景 .....................................................................................................................57
设计Collection+JSON 媒体类型 .........................................................................58
识别状态转移 ................................................................................................58
选择基本设计元素 ........................................................................................59
Collection+JSON 文档...................................................................................60
任务应用语义 ......................................................................................................64
数据模型 .......................................................................................................65
写入模板 .......................................................................................................66
预定义查询 ...................................................................................................67
示例数据 ..............................................................................................................68
任务文档 .......................................................................................................69
设计文档 .......................................................................................................69
服务器代码 ..........................................................................................................70
集合状态响应 ................................................................................................71
条目状态响应 ................................................................................................72
查询状态表示 ................................................................................................73
处理模板写入 ................................................................................................75
客户端代码 ..........................................................................................................77
单页界面任务示例 ........................................................................................77
任务命令行示例 ............................................................................................88
总结 .....................................................................................................................92
第4 章 HTML5 超媒体 ................................................. 95
场景 .....................................................................................................................95
设计Microblog 媒体类型 ....................................................................................96
使用HTML5 表达应用领域语义 ..................................................................96
识别状态转移 ................................................................................................98
选择基本设计元素 ...................................................................................... 103
Microblog 应用语义配置 ............................................................................. 104
示例数据 ............................................................................................................ 110
用户文档 ..................................................................................................... 111
消息文档 ..................................................................................................... 111
关注文档 ..................................................................................................... 111
设计文档 ..................................................................................................... 111
服务器代码 ........................................................................................................ 113
验证用户 ..................................................................................................... 114
注册新用户 ................................................................................................. 115
消息响应 ..................................................................................................... 117
用户响应 ..................................................................................................... 119
客户端代码 ........................................................................................................ 122
POSH 客户端 .............................................................................................. 123
Ajax 风格的QuoteBot 客户端 ..................................................................... 126
总结 ................................................................................................................... 134
第5 章 为超媒体设计编写文档 ................................... 135
要求、遵从性与RFC 2119 ................................................................................ 135
RFC 2119 关键词 ........................................................................................ 136
使用RFC 2119 关键词编写的示例文档 ...................................................... 137
定义遵从性 ................................................................................................. 137
为媒体类型设计编写文档 .................................................................................. 138
一般布局安排 .............................................................................................. 138
为XML 设计编写文档 ................................................................................ 143
为JSON 设计编写文档 ............................................................................... 144
为HTML 设计编写文档 .............................................................................. 146
为应用领域特定信息编写文档 .................................................................... 148
发布媒体类型设计 ...................................................................................... 152
媒体类型的扩展与版本控制 .............................................................................. 152
扩展 ............................................................................................................. 153
版本化 ......................................................................................................... 154
注册媒体类型与链接关系 .................................................................................. 157
媒体类型 ..................................................................................................... 157
链接关系类型 .............................................................................................. 159
设计与实现技巧 ................................................................................................. 162
Joshua Bloch 总结的良好的API 所具有的特征 .......................................... 162
Roy Fielding 的超文本API 准则 ................................................................. 163
Jon Postel 的健壮性原则 ............................................................................. 164
其他考虑 ..................................................................................................... 164
后记 ........................................................................... 167
附录A 参考文献 ........................................................ 169
附录B 补充阅读 ........................................................ 175
附录C Maze+XML 媒体类型 ...................................... 177
附录D Collection+JSON 媒体类型 ............................. 185
附录E 微博HTML 语义配置 ...................................... 197
附录F IANA 媒体类型注册文档 .................................. 207
附录G IETF 链接关系互联网草案............................... 209
附录H 本书所用源代码、软件及其安装说明 ............... 215__
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>使用HTML5和Node构建超媒体API
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>完美图解物联网IoT实操
0无所不在的JavaScript 与物联网设备 1
0.1 JavaScript 与物联网.3
0.2 MPU、MCU 与SoC 介绍 6
0.3 章节导读 9
1 JavaScript 入门 13
1.1 JavaScript 入门14
1.2 JavaScript 语言基础19
1.3 函数定义与事件处理程序. 29
1.4 定时产生随机数 32
1.5 Array（数组）对象. 34
1.6 认识Object（对象）类型. 36
1.7 BOM（浏览器对象模型）与DOM（文档对象模型）41
动手做 操作网页对象 43
1.8 在网页中嵌入JavaScript 44
1.9 事件触发程序 46
2 认识jQuery 库 53
2.1 jQuery 简介 54
2.2 jQuery 语法基础 59
2.3 AJAX 技术：动态更新HTML 内容 64
动手做 从Arduino 输出纯文本温度 66
2.4 网页消息交换格式 69
2.5 Arduino 输出JSON 消息 73
2.6 调整灯光亮度的网页界面 76
动手做 接收调光值的Arduino 网站程序 76
2.7 使用jQuery UI 附加网页用户界面元素 79
动手做 制作滑块界面网页 82
2.8 AJAX 的安全限制 85
3 Node.js 入门 91
3.1 在电脑以及树莓派上安装Node.js 94
3.2 Node 编程起步 99
3.3 使用http 模块创建网站服务器程序 103
3.4 事件驱动、非阻塞I/O 示范：读取文件 107
3.5 global（全局）对象与模块文件 113
3.6 安装与管理模块：使用npm 工具程序115
3.7 使用Express 框架开发网站应用程序 118
3.8 接收URL 数据. 122
3.9 接收与处理POST 数据 125
3.10 使用package.json 管理Node 项目的模块程序 129
动手做 从Arduino 传递温湿度值给Node 网站 131
3.11 使用JSONP 格式跨网域访问信息 136
4 Node.js 串口通信与树莓派GPIO 控制 143
4.1 安装编译Node 模块所需的软件144
4.2 安装C/C++ 编译器147
动手做 Node.js 串口通信 150
动手做 从Node.js 发送串口数据 154
4.3 通过Node.js 运行系统指令（运行raspistill 指令拍照） 157
4.4 树莓派的GPIO 简介 162
4.5 Node.js 程序GPIO 控制：使用onoff 模块 166
动手做 GPIO 输入/ 输出信号练习：按开关闪烁LED 167
动手做 通过红外传感模块拍摄照片 170
4.6 树莓派GPIO 集成Arduino 控制板 172
4.7 5V 和3.3V 电压准位转换 182
4.8 MOSFET 逻辑电位转换电路原理解说 185
5 使用霹雳五号操控Arduino 189
5.1 霹雳五号：用JavaScript 控制Arduino. 190
动手做 用霹雳五号指挥Arduino 闪烁LED 192
动手做 启用上拉电阻并读取开关信号200
动手做 模拟输入与PWM 输出程序实验 201
动手做 检测温度203
动手做 控制舵机 207
动手做 控制LED 矩阵显示图像.209
5.2 使用socket.io 创建实时连接 211
动手做 创建实时通信程序 214
动手做 浏览器与矩阵LED 作画 217
6 电子邮件、串流视频、计算机视觉与操控舵机 227
6.1 通过Node 发送电子邮件 228
动手做 云搜证：拍照自动发送E-mail. 233
动手做 串流视频：推播实时影像 234
6.2 使用MJPG 压缩与串流视频. 240
6.3 控制舵机云台  246
动手做 使用方向键操控舵机云台 247
动手做 摄像头云台的Node 服务器代码 249
6.4 使用触摸屏幕虚拟摇杆操控摄像头云台 250
6.5 浏览器连接游戏控制器（电玩控制器） 254
动手做 使用gamepad.js 库创建游戏器操作的网页程序255
6.6 计算机视觉（computer vision）应用260
6.7 使用tracking.js 侦测人脸. 264
动手做 脸孔侦测与舵机联动 270
动手做 侦测颜色 273
7 使用MongoDB 数据库以及ejs 模板引擎创建动态网页279
7.1 数据库简介. 280
7.2 安装MongoDB 285
7.3 MongoDB 的基本操作 289
7.4 查询数据 294
7.5 更新与删除数据. 298
7.6 使用mongoose 包连接MongoDB 数据库299
7.7 连接MongoDB 并读取数据的程序 303
动手做 存储Arduino 上传的温湿度数据 307
7.8 认识模板引擎309
动手做 在ejs 模板中显示最近10 笔温湿度数据 315
动手做 分页显示数据 318
8 数据可视化——使用C3.js 与D3.js 绘制图表321
8.1 使用C3.js 绘制图表. 322
8.2 显示动态平移的实时线条图 327
动手做 使用数据库数据描绘折线 331
8.3 动态显示Arduino 检测模拟值 334
8.4 简易数字滤波. 340
8.5 使用D3 库 344
8.6 认识SVG 348
8.7 使用D3 绘制SVG 图像 353
8.8 使用动态数据绘制折线图355
8.9 结合数据动态附加HTML 元素 364
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>完美图解物联网IoT实操
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js开发指南
目 　 　录
第1章 　Node.js简介　　1
1.1 　Node.js 是什么　　2
1.2 　Node.js 能做什么　　3
1.3 　异步式 I/O 与事件驱动　　4
1.4 　Node.js 的性能　　5
1.4.1 　Node.js 架构简介　　5
1.4.2 　Node.js 与 PHP + Nginx　　6
1.5 　JavaScript 简史　　6
1.5.1 　Netscape 与 LiveScript　　7
1.5.2 　Java 与 Javascript　　7
1.5.3 　微软的加入—— JScript　　8
1.5.4 　标准化—— ECMAScript　　8
1.5.5 　浏览器兼容性问题　　9
1.5.6 　引擎效率革命和 JavaScript 的未来　　9
1.6 　CommonJS　　10
1.6.1 　服务端 JavaScript 的重生　　10
1.6.2 　CommonJS 规范与实现　　11
1.7 　参考资料　　12
第2章 　安装和配置Node.js　　13
2.1 　安装前的准备　　14
2.2 　快速安装　　14
2.2.1 　Microsoft Windows系统上安装Node.js　　14
2.2.2 　Linux 发行版上安装Node.js　　16
2.2.3 　Mac OS X上安装Node.js　　16
2.3 　编译源代码　　17
2.3.1 　在 POSIX 系统中编译　　17
2.3.2 　在 Windows系统中编译　　18
2.4 　安装Node 包管理器　　18
2.5 　安装多版本管理器　　19
2.6 　参考资料　　21
第3章 　Node.js快速入门　　23
3.1 　开始用 Node.js 编程　　24
3.1.1 　Hello World　　24
3.1.2 　Node.js 命令行工具　　25
3.1.3 　建立 HTTP 服务器　　26
3.2 　异步式 I/O 与事件式编程　　29
3.2.1 　阻塞与线程　　29
3.2.2 　回调函数　　31
3.2.3 　事件　　33
3.3 　模块和包　　34
3.3.1 　什么是模块　　35
3.3.2 　创建及加载模块　　35
3.3.3 　创建包　　38
3.3.4 　Node.js 包管理器　　41
3.4 　调试　　45
3.4.1 　命令行调试　　45
3.4.2 　远程调试　　47
3.4.3 　使用 Eclipse 调试 Node.js　　48
3.4.4 　使用 node-inspector 调试Node.js　　54
3.5 　参考资料　　55
第4章 　Node.js核心模块　　57
4.1 　全局对象　　58
4.1.1 　全局对象与全局变量　　58
4.1.2 　process　　58
4.1.3 　console　　60
4.2 　常用工具 util　　61
4.2.1 　util.inherits　　61
4.2.2 　util.inspect　　62
4.3 　事件驱动 events　　63
4.3.1 　事件发射器　　64
4.3.2 　error 事件　　65
4.3.3 　继承 EventEmitter　　65
4.4 　文件系统 fs　　65
4.4.1 　fs.readFile　　66
4.4.2 　fs.readFileSync　　67
4.4.3 　fs.open　　67
4.4.4 　fs.read　　68
4.5 　HTTP 服务器与客户端　　70
4.5.1 　HTTP 服务器　　70
4.5.2 　HTTP 客户端　　74
4.6 　参考资料　　77
第5章 　使用Node.js进行Web开发　　79
5.1 　准备工作　　80
5.1.1 　使用http模块　　82
5.1.2 　Express 框架　　83
5.2 　快速开始　　84
5.2.1 　安装 Express　　84
5.2.2 　建立工程　　85
5.2.3 　启动服务器　　86
5.2.4 　工程的结构　　87
5.3 　路由控制　　89
5.3.1 　工作原理　　89
5.3.2 　创建路由规则　　92
5.3.3 　路径匹配　　93
5.3.4 　REST 风格的路由规则　　94
5.3.5 　控制权转移　　95
5.4 　模板引擎　　97
5.4.1 　什么是模板引擎　　97
5.4.2 　使用模板引擎　　98
5.4.3 　页面布局　　99
5.4.4 　片段视图　　100
5.4.5 　视图助手　　100
5.5 　建立微博网站　　102
5.5.1 　功能分析　　102
5.5.2 　路由规划　　102
5.5.3 　界面设计　　103
5.5.4 　使用Bootstrap　　104
5.6 　用户注册和登录　　107
5.6.1 　访问数据库　　107
5.6.2 　会话支持　　110
5.6.3 　注册和登入　　111
5.6.4 　页面权限控制　　120
5.7 　发表微博　　123
5.7.1 　微博模型　　123
5.7.2 　发表微博　　125
5.7.3 　用户页面　　126
5.7.4 　首页　　127
5.7.5 　下一步　　129
5.8 　参考资料　　129
第6章 　Node.js进阶话题　　131
6.1 　模块加载机制　　132
6.1.1 　模块的类型　　132
6.1.2 　按路径加载模块　　132
6.1.3 　通过查找node_modules目录加载模块　　133
6.1.4 　加载缓存　　134
6.1.5 　加载顺序　　134
6.2 　控制流　　135
6.2.1 　循环的陷阱　　135
6.2.2 　解决控制流难题　　137
6.3 　Node.js 应用部署　　138
6.3.1 　日志功能　　138
6.3.2 　使用cluster模块　　140
6.3.3 　启动脚本　　142
6.3.4 　共享80端口　　143
6.4 　Node.js 不是银弹　　144
6.5 　参考资料　　146
附录A 　JavaScript的高级特性　　147
附录B 　Node.js编程规范　　167
索引　　175
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js开发指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node应用程序构建
目　录
第一部分　Node．js、Backbone．js和MongoDB简介
第1章　介绍与总览　2
1．1　打造一个社交网络　3
1．2　模型-视图-控制器(MVC)　3
1．3　纯JavaScript　4
第2章　Node．js　5
2．1　安装Node．js　5
2．2　Express　6
模板　8
2．3　事件　10
2．4　Socket．io　12
2．5　模块与CommonJS　14
第3章　Backbone．js　16
3．1　模型　16
3．2　视图　17
3．3　集合　20
3．4　路由和历史　21
第4章　MongoDB　23
4．1　数据访问　23
4．1．1　写入　24
4．1．2　查询　27
4．1．3　索引　28
4．1．4　映射规约　29
4．2　携手Node．js　31
4．3　并发访问　31
第二部分　建立社交网络
第5章　创建项目　36
5．1　目录结构　36
文件列表　37
5．2　包定义　38
5．3　网站服务器　39
5．3．1　索引模板　41
5．3．2　应用程序JavaScript　42
5．3．3　应用程序类　43
5．3．4　索引视图对象　43
第6章　认证　45
6．1　账户　45
6．2　路由　48
6．2．1　身份验证　49
6．2．2　身份验证处理程序　50
6．3　注册　51
6．3．1　注册模版　51
6．3．2　注册处理程序　53
6．4　登录　54
6．4．1　登录模板　54
6．4．2　登录处理程序　56
6．5　忘记口令　57
6．5．1　忘记口令模板　57
6．5．2　忘记口令处理程序　58
6．6　重置口令　60
6．6．1　重置口令模板　60
6．6．2　重置口令处理函数　61
6．7　整合　62
Node．js　62
第7章　用户界面　65
7．1　账户明细　65
7．1．1　账户明细模板　66
7．1．2　账户明细处理程序　67
7．2　联系人列表　68
7．3　活动流　69
7．3．1　活动流模板　69
7．3．2　活动流处理程序　72
7．4　数据模型　73
7．5　整合　76
7．5．1　Backbone　76
7．5．2　Node．js　78
第8章　交朋友　82
8．1　联系人列表　82
8．1．1　联系人列表模板　82
8．1．2　联系人列表处理程序　86
8．2　添加联系人　87
8．2．1　添加联系人模板　87
8．2．2　添加联系人处理程序　89
8．3　删除联系人　91
8．3．1　删除联系人模板　91
8．3．2　删除联系人处理程序　92
8．4　评论　93
8．4．1　评论模板　94
8．4．2　评论处理程序　96
8．5　整合　97
8．5．1　Backbone　97
8．5．2　Node．js　99
第9章　聊天　109
9．1　重构　109
9．2　连接到聊天服务器　110
9．2．1　Backbone　111
9．2．2　Node．js　113
9．3　发送和接收聊天消息　114
9．3．1　Backbone　116
9．3．2　Node．js　121
9．4　整合　121
9．4．1　Backbone　121
9．4．2　Node．js　125
第10章　实时互动　134
10．1　增加自定义事件　134
10．1．1　触发事件　135
10．1．2　添加监听器　135
10．2　联系人登录通知　137
10．2．1　Backbone．js　137
10．2．2　Node．js　139
10．3　状态更新　141
10．3．1　Backbone．js　141
10．3．2　Node．js　143
10．4　整合　144
10．4．1　Backbone．js　144
10．4．2　Node．js　155
10．4．3　静态文件　166
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node应用程序构建
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js 实战
第1章　使用Express + MongoDB搭建多人博客.................. 1
1.1　一个简单的博客.......................... 2
1.1.1　学习环境......................... 2
1.1.2　快速开始......................... 2
1.1.3　路由控制......................... 7
1.1.4　模板引擎....................... 11
1.1.5　搭建多人博客............... 13
1.1.6　使用数据库................... 17
1.1.7　注册和登录................... 21
1.1.8　发表文章....................... 35
1.2　使用Markdown............................... 40
1.3　增加文件上传功能.................... 42
1.4　实现用户页面和文章页面................... 45
1.5　增加编辑与删除功能................ 49
1.6　实现留言功能............................ 54
1.7　实现分页功能............................ 57
1.8　增加存档页面............................ 60
1.9　增加标签和标签页面................ 62
1.10　增加pv统计和留言统计..................... 68
1.11　增加文章检索功能....................... 70
1.12　增加友情链接......................... 72
1.13　增加404页面........................... 73
1.14　增加用户头像......................... 74
1.15　增加转载功能和转载统计............ 77
1.16　增加日志功能......................... 84
1.17　小结......................................... 85
第2章　使用Express+MongoDB搭建多人博客番外篇.................... 87
2.1　番外篇之一——使用Passport....................... 88
2.2　番外篇之二——部署到Heroku................................... 91
2.3　番外篇之三——使用Mongoose...................... 95
2.4　番外篇之四——使用Async.......................... 98
2.5　番外篇之五——使用KindEditor.................... 102
2.6　番外篇之六——使用Handlebars................ 105
2.7　番外篇之七——使用KindEditor............. 109
第3章　使用Redis搭建漂流瓶服务器..............................111
3.1　初识Redis.................................. 112
3.2　开始漂流瓶之旅............................. 119
3.3　讨厌的海星................................... 127
3.4　扔回海里......................................... 127
3.5　今天的瓶子已经用完啦.................. 129
3.6　我的瓶子.................................. 131
3.7　女神，我们做朋友吧....................... 134
3.8　部署.......................................... 137
3.9　小结.......................................... 139
3.10　参考文献............................... 139
第4章　使用Meteor搭建微博网站................ 141
4.1　Meteor简介............................. 142
4.2　Meteor的安装与使用................. 142
4.3　快速入门.................................. 145
4.3.1　测试一：客户端和服务器端执行同一段代码............ 156
4.3.2　测试二：响应式............. 156
4.3.3　测试三：insecure包................ 157
4.3.4　测试四：autopublish包.............................. 159
4.3.5　测试五：加载顺序............... 161
4.4　开始搭建微博网站.................................... 161
4.4.1　开发环境............................ 161
4.4.2　学习目标.......................... 162
4.4.3　创建应...................................... 162
4.5　路由功能....................................... 165
4.6　用户注册..................................... 169
4.7　用户登录.................................. 173
4.8　发表微博.................................. 174
4.9　使用Markdown.................................. 176
4.10　部署....................................... 177
4.11　小结....................................... 179
4.12　参考文献.................................. 179
第5章　使用socket.io+Angular打造单页应用.......................... 181
5.1　最简单的聊天室............................ 182
5.1.1　socket.io简介..................... 182
5.1.2　Angular.js................................. 182
5.1.3　开始新建TechNode目录.............. 182
5.1.4　express.js服务器.................... 183
5.1.5　安装Bootstrap和Angular.js........ 185
5.1.6　搭建聊天室......................... 186
5.1.7　开始与好友聊天................ 192
5.2　让用户不再匿名........................... 192
5.2.1　添加登录功能..................... 192
5.2.2　用户登录与认证................ 195
5.2.3　socket.io验证...................... 200
5.2.4　显示用户名和在线用户列表................................. 202
5.2.5　我不喜欢你们................................ 211
5.3　提供不同的房间................................ 211
5.3.1　设计房间列表页面............................. 211
5.3.2　添加房间API.......................... 212
5.3.3　实现room的controller................. 213
5.3.4　提供socket的房间API................ 214
5.3.5　登录后跳转至房间列表.............. 215
5.3.6　房间列表............................. 216
5.3.7　进入单独的房间........................ 219
5.3.8　让消息只在房间内传递................... 224
5.3.9　用户离开房间.......................... 225
5.3.10　坏代码的味道...................... 227
5.4　架构优化与发布....................... 227
5.4.1　项目结构..................... 228
5.4.2　分拆http和socket服务...................... 229
5.4.3　客户端缓存................. 231
5.4.4　使用Grunt打包TechNode..... 236
5.4.5　发布TechNode.................. 242
5.4.6　聊天室之旅结束啦.................. 242
第6章　网络爬虫与数据操作........................... 243
6.1　学习目标.................................. 244
6.2　网络爬虫.................................. 245
6.2.1　相关模块介绍.................. 246
6.2.2　创建网络爬虫前的准备工作................................. 253
6.2.3　获取文章分类列表...................... 254
6.2.4　获取分类下的文章列表............... 257
6.2.5　获取文章的内容.................. 262
6.2.6　获取文章分类下的所有文章................................... 264
6.2.7　将结果保存到数据库中................... 267
6.2.8　保存文章分类............................. 269
6.2.9　一个完整的爬虫实例............... 270
6.3　显示数据库中的数据.............................. 279
6.3.1　相关模块介绍......................... 279
6.3.2　创建Web服务器前的工作........................... 280
6.3.3　查询数据.................................... 281
6.3.4　博客首页.................................. 283
6.3.5　文章页面................................. 285
6.4　自动更新文章数据.................................. 286
6.4.1　相关模块介绍.............................. 287
6.4.2　准备工作........................... 290
6.4.3　定时执行更新任务............................... 290
6.5　让程序更稳定地运行................................. 291
6.5.1　处理uncaughtException事件................................ 291
6.5.2　使用pm2来启动程序.................................. 291
6.5.3　安装pm2........................................... 292
6.5.4　启动和停止程序..................... 292
6.6　处理 GBK 编码的网页.......................... 292
6.7　小结.......................................... 294
6.8　参考文献.................................. 294
第7章　Node.js的进程与线程............................ 295
7.1　Node.js和PHP................................. 296
7.2　单线程的Node.js............................... 298
7.3　单线程的优缺点.......................... 298
7.4　多线程...................................... 300
7.5　多进程...................................... 305
7.6　多进程和多线程使用的比较................ 310
7.7　总结.......................................... 314
7.8　参考文献.................................. 315
第8章　发布一个Package............................ 317
8.1　Node.js包解决的问题...................... 318
8.2　创建package.json............................ 318
8.3　设计package的文件目录..................... 319
8.4　纯js包开发............................... 321
8.5　安装node-gyp......................................... 323
8.6　创建binding.byp............................... 324
8.7　C++插件包开发............................ 324
8.8　包的测试.................................. 330
8.9　跨平台测试................................. 333
8.10　readme.md......................................... 334
8.11　发布到GitHub............................ 334
8.12　发布到npm............................. 334
8.13　状态图标............................... 335
8.14　总结....................................... 336
8.15　参考文献............................... 337
第9章　Web安全实战............................... 339
9.1　什么是Web安全............................ 340
安全的定义和意识........................ 340
9.2　Node.js中的Web安全................ 341
HTTP管道洪水漏洞...................... 341
9.3　SQL注入....................................... 343
9.4　XSS脚本攻击................................ 345
9.5　CSRF请求伪造............................. 350
9.6　应用层DoS拒绝服务................... 358
9.7　文件路径漏洞............................... 366
9.8　加密安全.......................................... 372
9.9　小结.............................................. 375
9.10　参考文献.................................. 375
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js 实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>尋找生命的定位
謝辭
前言
第一部  星盤上的四個軸點
以身體定位
卯酉圈（主垂圈）
子午線
理論（合理）地平線
地平線系統
黃道
天頂／天底以及上升／下降
象徵性定位
四個半球
神聖的空間
元素
極端的緯度
模式
守護星、原始與個體
上升／天頂中點
關於存在的問題
軸點的前／後宮位
匡圓為方
上升：我是誰？
誕生與超越
先有雞還是先有蛋？
身體的外表
動機與動力
單一元素
在開始之前
門檻邊的守護者
天底：我從哪裡來？
宇宙起源
個人的根源
父親——隱性的父母
圖騰與禁忌
壁爐、家和招待
第三宮的連結
子宮與墳墓
天頂：我要去哪裡？
公眾之前
命運和責任
母親——顯性的父母
權威、成功與失敗
偉大的期望
抱負、願景和職業
下降：你是誰？
分離性
平等與崇高的可敬對手
配對遊戲
投射
合作夥伴／伴侶
準備相遇
到前為止有問題嗎？
軸點的行運
最近幾十年
敏感度數區
外行星的行運
跨越上升點的行運
跨越天底的行運
跨越下降的行運
跨越天頂的行運
引導式冥想練習
第二部  月亮交點
太陽、月亮與地球
均分點
略談天文學
實際交點與平均交點
再談天文學
一些數據軼聞
月亮交點的奇妙定律
占星符號
你的地球星座
太陽、月亮與地球 – 象徵
月亮
太陽
守護關係
月亮交點
重新架構
「話說龍的故事……」
北交點
南交點
轉世輪迴
平衡
關係與命運
丹恩
魯依爾的概念
蛇梯棋盤
月亮交點的高空表演
星盤中的月亮交點
支配關係的軌跡
幫助者與阻撓者
平衡點
與交點軸線合相的行星
月交點旅程
月交點的四分相
月交點的半回歸與回歸
與交點形成的行運
星盤案例
莎比恩符號
合盤
龍頭圖
胡柏學派的北交點星盤
月亮交點軸線的兩端
牡羊／天秤軸線
金牛／天蠍軸線
雙子／射手軸線
巨蟹／魔羯軸線
獅子／水瓶軸線
處女／雙魚軸線
日月食
沙羅週期
月食
日環食
日全食
資訊的運用
出生前日食
結語與引導冥想
附錄 I –月亮交點的奇妙定律
附錄II –檢視人生的過程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>尋找生命的定位
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MERN全栈开发 使用Mongo Express React和Node
目    录
第1章　引言     1
1.1　MERN是什么     1
1.2　本书的目标读者     3
1.3　本书组织结构     3
1.4　格式约定     5
1.5　读者须知     7
1.6　MERN的组件     8
1.6.1　React     8
1.6.2　Node.js     11
1.6.3　Express     14
1.6.4　MongoDB     15
1.6.5　工具与库     17
1.7　为何使用MERN技术栈     19
1.7.1　清一色的JavaScript语言     19
1.7.2　清一色的JSON数据格式     20
1.7.3　Node.js的性能     20
1.7.4　npm生态系统     21
1.7.5　同构性     21
1.7.6　它不是一个框架     22
1.8　小结     22
第2章　Hello World     23
2.1　脱离服务器的Hello World     23
2.2　服务器搭建     27
2.2.1　nvm     27
2.2.2　Node.js     28
2.2.3　项目     29
2.2.4　npm     30
2.2.5　Express     32
2.3　构建阶段的JSX编译     34
2.3.1　分离脚本文件     35
2.3.2　转换     36
2.3.3　自动化     38
2.3.4　React库     39
2.4　ES2015     39
2.5　小结     43
2.6　习题答案     43
2.6.1　习题：JSX     43
2.6.2　习题：npm     44
2.6.3　习题：Express     44
2.6.4　习题：babel     45
2.6.5　习题：ES2015     45
第3章　React组件     47
3.1　Issue Tracker(问题追踪)     47
3.2　React类     49
3.3　组件组装     51
3.4　传递数据     53
3.4.1　使用属性     53
3.4.2　属性校验     56
3.4.3　使用Children     57
3.5　动态组装     59
3.6　小结     64
3.7　习题答案     64
3.7.1　习题：React类     64
3.7.2　习题：传递数据     64
3.7.3　习题：动态组装     65
第4章　React状态     67
4.1　设置状态     67
4.2　异步状态初始化     71
4.3　事件处理     73
4.4　从子组件到父组件的通信     74
4.5　无状态组件     77
4.6　设计组件     79
4.6.1　状态与props     79
4.6.2　组件层次结构     80
4.6.3　通信     80
4.6.4　无状态组件     80
4.7　小结     81
4.8　习题答案     81
4.8.1　习题：设置状态     81
4.8.2　习题：从子组件到父组件的通信     82
第5章　Express REST APIs     83
5.1　REST     83
5.1.1　基于资源     84
5.1.2　使用HTTP Methods标识操作     84
5.1.3　JSON     87
5.2　Express     87
5.2.1　路由     87
5.2.2　处理程序函数     89
5.2.3　中间件     91
5.3　List API     92
5.3.1　服务器自动重启     94
5.3.2　测试     95
5.4　Create API     97
5.5　使用List API     100
5.6　使用Create API     102
5.7　错误处理     104
5.8　小结     108
5.9　习题答案     109
5.9.1　习题：List API     109
5.9.2　习题：Create API     110
5.9.3　习题：使用List API     111
5.9.4　习题：使用Create API     111
5.9.5　习题：错误处理     111
第6章　使用MongoDB     113
6.1　MongoDB基础     113
6.1.1　文档     113
6.1.2　集合     114
6.1.3　查询语言     115
6.1.4　安装     116
6.1.5　mongo shell     117
6.1.6　shell脚本     121
6.2　架构初始化     122
6.3　MongoDB Node.js驱动程序     123
6.3.1　回调     126
6.3.2　Promises     127
6.3.3　Generator和co模块     128
6.3.4　async模块     129
6.4　从MongoDB读取数据     131
6.5　向MongoDB写入数据     134
6.6　小结     136
6.7　习题答案     136
6.7.1　习题：mongo shell     136
6.7.2　习题：架构初始化     137
6.7.3　习题：从MongoDB读取数据     137
6.7.4　习题：向MongoDB写入数据     138
第7章　模块化与webpack     139
7.1　服务器端模块     139
7.2　webpack简介     142
7.3　手工使用webpack     143
7.4　转换和打包     146
7.5　库捆绑包     151
7.6　模块热替换     155
7.7　使用中间件实现HMR     158
7.8　调试     161
7.9　服务器端ES2015     163
7.10　ESLint     168
7.11　小结     176
7.12　习题答案     177
7.12.1　习题：转换和打包     177
7.12.2　习题：模块热替换     178
7.12.3　习题：服务器端ES2015     178
7.12.4　习题：ESLint     179
第8章　使用React Router进行路由     181
8.1　路由技术     182
8.2　简单的路由     183
8.3　路由参数     185
8.4　路由查询字符串     188
8.5　使用程序进行导航     193
8.6　嵌套的路由     196
8.7　浏览器历史     200
8.8　小结     202
8.9　习题答案     202
8.9.1　习题：路由参数     202
8.9.2　习题：路由查询字符串     203
8.9.3　习题：使用程序进行导航     204
第9章　表单     205
9.1　List API中的更多过滤功能     205
9.2　过滤表单     207
9.3　Get API     214
9.4　Edit页面     216
9.5　UI组件     220
9.5.1　数字输入框     221
9.5.2　Date输入框     226
9.6　Update API     232
9.7　使用Update API     236
9.8　Delete API     238
9.9　使用Delete API     239
9.10　小结     242
9.11　习题答案     242
9.11.1　习题：在List API中添加更多过滤条件     242
9.11.2　习题：过滤表单     242
9.11.3　习题：Edit页面     243
9.11.4　习题：Date输入框     243
9.11.5　习题：Update API     244
第10章　React-Bootstrap     245
10.1　安装Bootstrap     246
10.2　导航     249
10.3　表格和面板     256
10.4　表单     258
10.4.1　基于栅格的表单     259
10.4.2　内联表单     263
10.4.3　横向表单     265
10.5　提示     270
10.5.1　验证消息     270
10.5.2　结果消息     272
10.6　模态对话框     279
10.7　小结     284
10.8　习题答案     285
10.8.1　习题：导航     285
10.8.2　习题：基于栅格的表单     285
10.8.3　习题：内联表单     286
10.8.4　习题：模态对话框     286
第11章　服务器端渲染     287
11.1　基本的服务器端渲染     288
11.2　处理state     293
11.3　初始state     296
11.4　服务器端bundle     298
11.5　后端HMR     301
11.6　配合路由功能的服务器端渲染     306
11.7　封装Fetch操作     314
11.8　小结     319
11.9　习题答案     320
11.9.1　习题：后端HMR     320
11.9.2　习题：配合路由功能的服务器端渲染     320
第12章　高级特性     321
12.1　MongoDB聚合     321
12.2　分页     331
12.3　高阶组件(Higher Order Components)     336
12.4　搜索栏     345
12.5　Google账号登录     351
12.6　会话处理     359
12.7　小结     367
第13章　展望     369
13.1　Mongoose     370
13.2　Flux     371
13.3　部署     373
13.4　mern.io     375
13.5　同学们，下课     377
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MERN全栈开发 使用Mongo Express React和Node
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node js开发实战
●篇Node.js概述和开发环境的搭建
●第1章Node.js介绍3
●1.1Node.js简介3
●1.2Node.js的发展历史和特点4
●1.2.1Node.js发展历史4
●1.2.2Node.js未来版本规划5
●1.2.3Node.js的结构6
●1.2.4Node.js的特点7
●1.2.5Node.js的应用场景9
●1.3Node.js在中国的发展10
●1.3.1Node.js中文资源汇总10
●1.3.2Node.js的发展和未来10
●1.4温故知新12
●第2章部署Node.js开发环境13
●2.1Windows10下部署Node.js开发环境13
●2.1.1使用安装包进行Node.js安装14
●2.1.2测试Node.js开发环境16
●2.2Linux下部署Node.js开发环境17
●2.2.1通过源码安装Node.js18
●2.2.2通过包管理器安装Node.js18
●部分目录
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node js开发实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js+MongoDB+AngularJS Web开发
第1部分  引    言
第1章  介绍Node.js-to-AngularJS套件	3
1.1  了解基本的Web开发框架	3
1.1.1  用户	4
1.1.2  浏览器	4
1.1.3  Web服务器	6
1.1.4  后端服务	6
1.2  了解Node.js-to-AngularJS套件组件	7
1.2.1  Node.js	7
1.2.2  MongoDB	8
1.2.3  Express	9
1.2.4  AngularJS	9
1.3  小结	10
1.4  下一章	10
第2章  JavaScript基础	11
2.1  定义变量	11
2.2  了解JavaScript数据类型	12
2.3  使用运算符	13
2.3.1  算术运算符	13
2.3.2  赋值运算符	14
2.3.3  运用比较和条件运算符	14
2.4  实现循环	16
2.4.1  while循环	17
2.4.2  do/while循环	17
2.4.3  for循环	17
2.4.4  for/in循环	18
2.4.5  中断循环	19
2.5  创建函数	19
2.5.1  定义函数	20
2.5.2  传递变量给函数	20
2.5.3  从函数返回值	20
2.5.4  使用匿名函数	21
2.6  理解变量作用域	22
2.7  使用JavaScript对象	22
2.7.1  使用对象语法	23
2.7.2  创建自定义对象	23
2.7.3  使用原型对象模式	24
2.8  处理字符串	25
2.8.1  合并字符串	26
2.8.2  在字符串中搜索子串	26
2.8.3  在一个字符串中替换单词	27
2.8.4  将字符串分割成数组	27
2.9  使用数组	27
2.9.1  合并数组	28
2.9.2  遍历数组	29
2.9.3  将数组转换为字符串	29
2.9.4  检查数组是否包含某个条目	29
2.9.5  在数组中添加条目和删除条目	30
2.10  添加错误处理	30
2.10.1  try/catch块	30
2.10.2  抛出你自己的错误	31
2.10.3  使用finally	31
2.11  小结	32
2.12  下一章	32
第2部分  学习Node.js
第3章  开始使用Node.js	35
3.1  了解Node.js	35
3.1.1  谁在使用Node.js	35
3.1.2  Node.js的用途	36
3.2  Node.js安装	36
3.2.1  纵观Node.js安装位置	36
3.2.2  验证Node.js可执行文件	37
3.2.3  选择Node.js IDE	37
3.3  使用Node.js包	38
3.3.1  什么是Node封装模块	38
3.3.2  了解Node包注册表	38
3.3.3  使用Node包管理器	38
3.3.4  搜索Node封装模块	39
3.3.5  安装Node封装模块	40
3.3.6  使用package.json	41
3.4  创建Node.js应用程序	43
3.4.1  创建Node.js模块封装	43
3.4.2  将一个Node.js封装模块发布到NPM注册表	45
3.4.3  在Node.js应用程序中使用Node.js封装模块	46
3.5  将数据写入控制台	47
3.6  小结	49
3.7  下一章	49
第4章  在Node.js中使用事件、监听器、定时器和回调	51
4.1  了解Node.js事件模型	51
4.1.1  比较事件回调和线程模型	51
4.1.2  在Node.js中阻塞I/O	52
4.1.3  会话示例	54
4.2  将工作添加到事件队列	54
4.2.1  实现定时器	55
4.2.2  使用nextTick来调度工作	58
4.2.3  实现事件发射器和监听器	59
4.3  实现回调	62
4.3.1  向回调函数传递额外的参数	63
4.3.2  在回调中实现闭包	64
4.3.3  链式回调	65
4.4  小结	66
4.5  下一章	66
第5章  在Node.js中处理数据I/O	67
5.1  处理JSON	67
5.1.1  把JSON转换成JavaScript对象	67
5.1.2  把JavaScript对象转换为JSON	68
5.2  使用Buffer模块缓冲数据	68
5.2.1  了解缓冲数据	69
5.2.2  创建缓冲区	69
5.2.3  写入缓冲区	70
5.2.4  从缓冲区读取	71
5.2.5  确定缓冲区长度	72
5.2.6  复制缓冲区	73
5.2.7  对缓冲区切片	74
5.2.8  拼接缓冲区	75
5.3  使用Stream模块来传送数据	76
5.3.1  Readable流	76
5.3.2  Writable流	78
5.3.3  Duplex流	81
5.3.4  Transform流	82
5.3.5  把Readable流用管道输送到Writable流	84
5.4  用Zlib压缩与解压缩数据	85
5.4.1  压缩和解压缩缓冲区	85
5.4.2  压缩/解压缩流	87
5.5  小结	88
5.6  下一章	88
第6章  从Node.js访问文件系统	89
6.1  同步和异步文件系统调用	89
6.2  打开和关闭文件	90
6.3  写入文件	91
6.3.1  简单文件写入	91
6.3.2  同步文件写入	92
6.3.3  异步写入文件	93
6.3.4  流式文件写入	95
6.4  读取文件	96
6.4.1  简单文件读取	96
6.4.2  同步文件读取	97
6.4.3  异步文件读取	98
6.4.4  流式文件读取	100
6.5  其他文件系统任务	101
6.5.1  验证路径的存在性	101
6.5.2  获取文件信息	102
6.5.3  列出文件	103
6.5.4  删除文件	104
6.5.5  截断文件	105
6.5.6  建立和删除目录	105
6.5.7  重命名文件和目录	106
6.5.8  监视文件更改入	107
6.6  小结	107
6.7  下一章	107
第7章  在Node.js中实现HTTP服务	109
7.1  处理URL	109
7.1.1  了解URL对象	110
7.1.2  解析URL组件	111
7.2  处理查询字符串和表单参数	111
7.3  了解请求、响应和服务器对象	112
7.3.1  http.ClientRequest对象	112
7.3.2  http.ServerResponse对象	114
7.3.3  http.IncomingMessage对象	115
7.3.4  HTTP Server对象	116
7.4  在Node.js中实现HTTP客户端和服务器	118
7.4.1  提供静态文件服务	118
7.4.2  实现动态的GET服务器	120
7.4.3  实现POST服务器	122
7.4.4  与外部源交互	124
7.5  实现HTTPS服务器和客户端	127
7.5.1  创建HTTPS客户端	127
7.5.2  创建HTTPS服务器	129
7.6  小结	129
7.7  下一章	129
第8章  在Node.js中实现套接字服务	131
8.1  了解网络套接字	131
8.2  了解TCP服务器和Socket对象	132
8.2.1  net.Socket对象	132
8.2.2  net.Server对象	135
8.3  实现TCP套接字服务器和客户端	137
8.3.1  实现TCP套接字客户端	138
8.3.2  实现TCP套接字服务器	140
8.4  实现TLS服务器和客户端	143
8.4.1  创建TLS套接字客户端	144
8.4.2  创建TLS套接字服务器	145
8.5  小结	147
8.6  下一章	147
第9章  在Node.js中使用多处理器扩展应用程序	149
9.1  了解process模块	149
9.1.1  了解进程I/O管道	149
9.1.2  了解进程的信号	150
9.1.3  使用process模块控制进程执行	150
9.1.4  从process模块获取信息	151
9.2  实现子进程	153
9.2.1  了解ChildProcess对象	153
9.2.2  使用exec()在另一个进程上执行一个系统命令	154
9.2.3  使用execFile()在另一个进程上执行一个可执行文件	156
9.2.4  使用spawn()在另一个Node.js实例中产生一个进程	157
9.2.5  实现子派生	159
9.3  实现进程集群	161
9.3.1  使用cluster模块	162
9.3.2  了解Worker对象	163
9.3.3  实现一个HTTP集群	164
9.4  小结	166
9.5  下一章	166
第10章  使用其他Node.js模块	167
10.1  使用os模块	167
10.2  使用util模块	169
10.2.1  格式化字符串	169
10.2.2  检查对象类型	170
10.2.3  同步写入输出流	170
10.2.4  将JavaScript对象转换为字符串	170
10.2.5  从其他对象继承功能	171
10.2.6  使用dns模块	172
10.3  小结	174
10.4  下一章	174
第3部分  学习MongoDB
第11章  了解NoSQL和MongoDB	177
11.1  为什么要采用NoSQL	177
11.2  了解MongoDB	178
11.2.1  理解集合	178
11.2.2  了解文档	178
11.3  MongoDB的数据类型	179
11.4  规划你的数据模型	180
11.4.1  使用文档引用来规范化数据	181
11.4.2  使用嵌入式文档反规范化数据	182
11.4.3  使用封顶集合	183
11.4.4  了解原子写操作	184
11.4.5  考虑文件增长	184
11.4.6  识别索引、分片和复制的机会	184
11.4.7  大集合与大量集合的对比	185
11.4.8  决定数据生命周期	185
11.4.9  考虑数据的可用性和性能	185
11.5  小结	186
11.6  下一章	186
第12章  MongoDB入门	187
12.1  构建MongoDB的环境	187
12.1.1  MongoDB的安装	187
12.1.2  启动MongoDB	188
12.1.3  停止MongoDB	189
12.1.4  从shell客户端访问MongoDB	189
12.2  管理用户账户	192
12.2.1  列出用户	192
12.2.2  创建用户账户	193
12.2.3  删除用户	194
12.3  配置访问控制	194
12.3.1  创建用户管理员账户	195
12.3.2  打开身份验证	196
12.3.3  创建数据库管理员账户	196
12.4  管理数据库	197
12.4.1  显示数据库清单	197
12.4.2  切换当前数据库	197
12.4.3  创建数据库	197
12.4.4  删除数据库	198
12.4.5  复制数据库	198
12.5  管理集合	199
12.5.1  显示数据库中的集合列表	199
12.5.2  创建集合	199
12.5.3  删除集合	200
12.5.4  在集合中查找文档	201
12.5.5  将文档添加到集合中	201
12.5.6  从集合中删除文档	202
12.5.7  更新集合中的文档	202
12.6  小结	204
12.7  下一章	204
第13章  MongoDB和Node.js入门	205
13.1  把MongoDB的驱动程序添加到Node.js	205
13.2  从Node.js连接到MongoDB	206
13.2.1  了解写入关注	206
13.2.2  了解Server对象	206
13.2.3  通过Client对象连接到MongoDB	207
13.2.4  通过一个连接字符串连接到MongoDB	210
13.3  了解用在MongoDB Node.js驱动程序中的对象	211
13.3.1  了解Db对象	212
13.3.2  了解Admin对象	213
13.3.3  了解Collection对象	214
13.3.4  了解Cursor对象	215
13.4  访问和操作数据库	216
13.4.1  列出数据库	217
13.4.2  创建数据库	217
13.4.3  删除数据库	217
13.4.4  创建、列出和删除数据库实例	218
13.4.5  获取MongoDB服务器的状态	219
13.5  访问和操作集合	220
13.5.1  列出集合	220
13.5.2  创建集合	221
13.5.3  删除集合	221
13.5.4  创建、列出和删除集合的示例	221
13.5.5  获取集合信息	222
13.6  小结	223
13.7  下一章	223
第14章  从Node.js操作MongoDB文档	225
14.1  了解数据库更改选项	225
14.2  了解数据库更新运算符	226
14.3  将文档添加到集合	227
14.4  从集合获取文档	229
14.5  更新集合中的文档	230
14.6  原子地修改文档的集合	232
14.7  保存集合中的文档	234
14.8  使用upsert往集合中插入文档	235
14.9  从集合中删除文档	236
14.10  从集合中删除单个文档	238
14.11  小结	240
14.12  下一章	240
第15章  从Node.js访问MongoDB的文档	241
15.1  介绍数据集	241
15.2  了解query对象	242
15.3  了解查询options对象	243
15.4  查找特定文档集合	244
15.5  清点文档数量	247
15.6  对结果集进行限制	249
15.6.1  按大小限制结果	249
15.6.2  限制对象返回的字段	250
15.6.3  对结果进行分页	252
15.7  对结果集进行排序	253
15.8  查找不同的字段值	255
15.9  对结果进行分组	256
15.10  通过聚合结果来应用MapReduce	259
15.10.1  了解aggregate()方法	259
15.10.2  使用聚合框架运算符	260
15.10.3  实现聚合表达式运算符	261
15.10.4  聚合的例子	262
15.11  小结	263
15.12  下一章	264
第16章  利用Mongoose来使用结构化模式与验证	265
16.1  了解Mongoose	265
16.2  利用Mongoose连接到MongoDB数据库	266
16.3  定义模式	267
16.3.1  了解路径	268
16.3.2  创建一个模式定义	268
16.3.3  把索引添加到一个模式	269
16.3.4  实现字段的唯一性	269
16.3.5  强制字段的必需性	270
16.3.6  添加Schema对象的方法	270
16.3.7  在words数据库上实现一个模式	270
16.4  编译模型	271
16.5  了解Query对象	272
16.5.1  设置查询数据库操作	273
16.5.2  设置查询数据库操作选项	274
16.5.3  设置查询运算符	275
16.6  了解Document对象	276
16.7  利用Mongoose查找文档	278
16.8  利用Mongoose添加文档	280
16.9  利用Mongoose更新文档	281
16.9.1  保存文档更改	282
16.9.2  更新单个文档	283
16.9.3  更新多个文档	284
16.10  利用Mongoose删除文档	286
16.10.1  删除单个文档	286
16.10.2  删除多个文档	287
16.11  利用Mongoose聚合文档	288
16.12  使用验证框架	291
16.13  实现中间件函数	293
16.14  小结	295
16.15  下一章	295
第17章  高级MongoDB概念	297
17.1  添加索引	297
17.2  使用封顶集合	299
17.3  应用复制	300
17.3.1  复制策略	302
17.3.2  部署一个副本集	302
17.4  实施分片	303
17.4.1  分片服务器类型	304
17.4.2  选择一个分片键	305
17.4.3  选择一种分区方法	306
17.4.4  部署一个分片的MongoDB集群	307
17.5  实现一个GridFS Store	310
17.5.1  在Node.js实现Grid对象	311
17.5.2  在Node.js实现GridStore对象	313
17.6  修复MongoDB数据库	315
17.7  备份MongoDB	316
17.8  小结	317
17.9  下一章	317
第4部分  使用Express使生活更轻松
第18章  在Node.js中实现Express	321
18.1  Express入门	321
18.1.1  配置Express设置	321
18.1.2  启动Express服务器	322
18.2  配置路由	323
18.2.1  实现路由	323
18.2.2  在路由中应用参数	324
18.3  使用Request对象	328
18.4  使用Response对象	330
18.4.1  设置标头	330
18.4.2  设置状态	331
18.4.3  发送响应	331
18.4.4  发送JSON响应	333
18.4.5  发送文件	335
18.4.6  发送下载响应	336
18.4.7  重定向响应	336
18.5  实现一个模板引擎	337
18.5.1  定义一个模板引擎	338
18.5.2  加入本地对象	338
18.5.3  创建模板	339
18.5.4  在响应中呈现模板	340
18.6  小结	342
18.7  下一章	342
第19章  实现Express中间件	343
19.1  了解中间件	343
19.1.1  在全局范围内把中间件分配给某个路径	344
19.1.2  把中间件分配到单个路由	345
19.1.3  添加多个中间件函数	345
19.2  使用query中间件	345
19.3  提供静态文件服务	346
19.4  处理POST正文数据	348
19.5  发送和接收cookie	349
19.6  实现会话	350
19.7  应用基本的HTTP身份验证	352
19.8  实现会话身份验证	354
19.9  创建自定义中间件	356
19.10  小结	357
19.11  下一章	357
第5部分  学习AngularJS
第20章  AngularJS入门	361
20.1  为什么选择AngularJS	361
20.2  了解AngularJS	362
20.2.1  模块	362
20.2.2  作用域和数据模型	363
20.2.3  具有模板和指令的视图	363
20.2.4  表达式	363
20.2.5  控制器	363
20.2.6  数据绑定	364
20.2.7  服务	364
20.2.8  依赖注入	364
20.2.9  职责分离	364
20.3  AngularJS生命周期概述	365
20.3.1  引导阶段	365
20.3.2  编译阶段	365
20.3.3  运行时数据绑定阶段	366
20.4  将AngularJS与现有的JavaScript和jQuery整合	366
20.5  将AngularJS添加到Node.js的环境	367
20.6  在HTML文档中引导AngularJS	367
20.7  使用全局API	368
20.8  创建基本的AngularJS应用程序	369
20.8.1  加载AngularJS库和你的主模块	370
20.8.2  定义AngularJS应用程序根元素	370
20.8.3  将控制器添加到模板	370
20.8.4  实现作用域模型	371
20.9  小结	372
20.10  下一章	372
第21章  了解AngularJS模块和依赖注入	373
21.1  模块和依赖注入概述	373
21.1.1  了解模块	373
21.1.2  依赖注入	374
21.2  定义AngularJS模块	374
21.2.1  创建AngularJS Module对象	374
21.2.2  使用配置块	375
21.2.3  使用运行块	375
21.2.4  把提供器添加到AngularJS模块	376
21.3  实现依赖注入	377
21.4  小结	379
21.5  下一章	380
第22章  把作用域实现为数据模型	381
22.1  了解作用域	381
22.1.1  根作用域和应用程序之间的关系	381
22.1.2  作用域和控制器之间的关系	382
22.1.3  作用域和模板之间的关系	383
22.1.4  作用域和后端服务器数据之间的关系	385
22.1.5  作用域的生命周期	385
22.2  实现作用域层次结构	387
22.3  发出和广播活动	389
22.4  小结	392
22.5  下一章	393
第23章  使用AngularJS模板来创建视图	395
23.1  了解模板	395
23.2  使用表达式	396
23.3  使用过滤器	399
23.3.1  使用内置过滤器	400
23.3.2  使用过滤器来实现排序和过滤	402
23.4  创建自定义过滤器	405
23.5  小结	406
23.6  下一章	407
第24章  在AngularJS视图中实现指令	409
24.1  了解指令	409
24.2  使用内置指令	409
24.2.1  支持AngularJS功能的指令	410
24.2.2  扩展表单元素的指令	411
24.2.3  把模型绑定到页面元素的指令	414
24.2.4  把页面事件绑定到控制器的指令	418
24.3  创建你自己的指令来扩展HTML	420
24.3.1  定义指令视图模板	421
24.3.2  限制指令行为	422
24.3.3  更换模板元素	423
24.3.4  转置外部作用域	423
24.3.5  配置指令的作用域	423
24.3.6  操纵DOM的链接功能	425
24.3.7  添加一个控制器到指令	426
24.3.8  创建自定义指令	426
24.4  小结	428
24.5  下一章	429
第25章  在Web应用程序中实现AngularJS服务	431
25.1  了解AngularJS服务	431
25.2  使用内置的服务	431
25.2.1  使用$http服务发送HTTP的GET和PUT请求	432
25.2.2  使用$cacheFactory服务	436
25.2.3  使用$window服务实现浏览器警报	437
25.2.4  使用$cookieStore服务与浏览器cookie交互	437
25.2.5  使用$interval和$timeout服务实现定时器	439
25.2.6  使用$animate服务	440
25.3  创建自定义服务	445
25.3.1  创建value服务	445
25.3.2  创建constant服务	445
25.3.3  创建factory服务	445
25.3.4  创建service服务	446
25.3.5  把服务集成在一个模块中	446
25.4  小结	447
25.5  下一章	447
第6部分  建立实用的Web应用程序组件
第26章  将用户账户添加到你的网站	451
26.1  用到的库	451
26.2  项目的目录结构	451
26.3  定义用户模型	452
26.4  创建服务器	453
26.5  实现路由	454
26.6  实现用户控制器路由	456
26.6.1  实现用户注册路由	456
26.6.2  实现用户登录路由	457
26.6.3  实现获得用户配置文件的路由	457
26.6.4  实现更新用户路由	458
26.6.5  实现删除用户路由	458
26.6.6  完整的用户控制器代码	459
26.7  实现用户和身份验证视图	461
26.7.1  实现signup视图	461
26.7.2  实现index视图	462
26.7.3  实现login视图	463
26.7.4  实现user视图	464
26.7.5  添加CSS代码到样式视图	466
26.8  实现AngularJS模块和控制器	466
26.9  使用社交媒体账户作为身份验证来源	467
26.9.1  添加Passport	467
26.9.2  添加身份验证策略	467
26.9.3  实现应用程序中间件	468
26.9.4  添加已验证身份的用户序列化和反序列化	469
26.9.5  实现路由以使用身份验证	469
26.9.6  使用谷歌验证身份	470
26.10  小结	473
26.11  下一章	473
第27章  添加评论主题页	475
27.1  用到的库	475
27.2  项目的目录结构	475
27.3  定义评论、回复、照片和页面模型	477
27.3.1  定义Page模型	477
27.3.2  定义Photo模型	478
27.3.3  定义CommentThread模型	478
27.4  创建评论服务器	479
27.5  实现路由，以支持查看和添加评论	480
27.6  实现基于模型的控制器路由	481
27.6.1  实现Page模型控制器	481
27.6.2  实现Photo模型控制器	482
27.6.3  实现CommentThread模型控制器	482
27.7  实现照片和评论视图	486
27.7.1  实现照片视图	486
27.7.2  实现评论主题视图	489
27.7.3  实现评论视图	491
27.7.4  添加CSS来设置视图的样式	492
27.8  实现AngularJS模块和控制器来支持评论视图	493
27.8.1  创建一个评论服务	493
27.8.2  实现照片控制器	494
27.8.3  实现页面AngularJS控制器	495
27.8.4  完整的AngularJS应用程序	496
27.9  初始化应用程序	499
27.10  小结	500
27.11  下一章	500
第28章  创建你自己的购物车	501
28.1  项目简介	501
28.2  用到的库	502
28.3  项目的目录结构	502
28.4  定义顾客、产品和订单模式	504
28.4.1  定义地址模式	504
28.4.2  定义账单模式	505
28.4.3  定义产品模式	505
28.4.4  定义数量模式	506
28.4.5  定义订单模式	506
28.4.6  定义顾客模式	506
28.5  创建购物车服务器	508
28.6  实现路由，以支持产品、购物车和订单请求	508
28.7  实现基于模型的控制器路由	509
28.7.1  实现产品模型控制器	509
28.7.2  实现订单模型控制器	510
28.7.3  实现顾客模型控制器	511
28.8  实现购物车和结账视图	513
28.8.1  实现购物视图	513
28.8.2  实现产品视图	515
28.8.3  实现产品页面视图	516
28.8.4  实现购物车视图	516
28.8.5  实现发货视图	518
28.8.6  实现账单视图	519
28.8.7  实现复核视图	521
28.8.8  实现订单视图	523
28.8.9  添加CSS来设置视图的样式	524
28.9  实现AngularJS模块和控制器，以支持购物车视图	526
28.9.1  初始化购物作用域	526
28.9.2  实现辅助函数	527
28.9.3  将物品添加到购物车	527
28.9.4  从购物车删除物品	528
28.9.5  结账	529
28.9.6  设置发货信息	529
28.9.7  验证账单	530
28.9.8  执行购买	530
28.9.9  完整的控制器	531
28.10  初始化应用程序	534
28.11  小结	536
28.12  下一章	536
第29章  构建交互式的Web 2.0应用程序组件	537
29.1  项目简介	537
29.2  用到的库	538
29.3  项目的目录结构	538
29.4  定义项目模型	540
29.5  创建应用程序服务器	540
29.6  实现支持视图的路由	541
29.7  实现选项卡视图	542
29.7.1  创建AngularJS选项卡视图模板	542
29.7.2  定义窗格模板	542
29.7.3  定义卡片模板	542
29.7.4  实现选项卡视图	543
29.7.5  实现AngularJS自定义指令	544
29.7.6  设置卡片视图的样式	545
29.8  实现天气服务视图	546
29.8.1  创建后端天气服务	546
29.8.2  定义天气AngularJS控制器	548
29.8.3  定义天气AngularJS视图	549
29.8.4  设置天气视图的样式	549
29.9  实现可拖动的元素	551
29.9.1  定义可拖动的自定义AngularJS指令	551
29.9.2  在AngularJS视图中实现可拖动的指令	552
29.9.3  设置可拖动视图的样式	552
29.10  实现动态数据访问	553
29.10.1  创建/words路由的Express路由控制器	553
29.10.2  定义表格AngularJS控制器	554
29.10.3  实现表格AngularJS视图	556
29.10.4  设置表格视图的样式	557
29.11  初始化应用程序	558
29.12  小结	560
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js+MongoDB+AngularJS Web开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js实战（第2季）
第1章 通过Docker快速发布Node.js应用/ 1
1.1 什么是Docker /1
1.2 Nginx作为Node.js前端Web Server的作用 /3
1.3 安装Docker和下载Images镜像/ 5
1.4 Docker常用命令 /8
1.5 启动Container盒子 /10
1.6 文件卷标加载/ 11
1.7 将多个Container盒子连接起来 /13
1.8 不要用SSH连接到你的Container盒子 /15
1.9 配置DockerImages镜像和发布应用/ 19
1.10 什么是Jenkins/ 26
1.11 通过Docker安装和启动Jenkins /28
1.12 配置Jenkins并自动化部署Node.js项目/ 29
1.13 小结/ 36
1.14 参考文献/ 37
第2章 开发OAuth2认证服务器 /38
2.1 本章所用到的第三方模块/ 38
2.2 REST风格的API/ 39
2.3 定义返回数据格式/ 40
2.4 实现简单的API/ 41
2.4.1 扩展Response对象/ 41
2.4.2 统一处理出错信息/ 43
2.4.3 实现简单的API/ 43
2.4.4 API版本/ 44
2.5 关于OAuth认证/ 45
2.5.1 OAuth 2.0授权流程/ 45
2.5.2 OAuth 2.0授权详解/ 45
2.5.3 定义授权接口/ 48
2.6 实现OAuth认证/ 48
2.6.1 OAuth2/authorize接口/ 48
2.6.2 OAuth2/access_token接口/ 52
2.6.3 在处理API请求前验证Access Token/ 55
2.6.4 Access Token过期的问题/ 56
2.7 实现API客户端/ 58
2.8 API传输过程中的安全问题/ 62
2.9 API请求频率限制/ 63
2.10 让API返回结果支持不同的格式/65
2.10.1 通过后缀来指定返回的数据格式/ 65
2.10.2 通过Accept请求头来指定返回的数据格式/ 67
2.11 生成随机的测试数据/ 68
2.12 小结/ 69
2.13 参考文献及开源项目/ 70
第3章 基于RabbitMQ搭建消息队列/ 72
3.1 什么是消息队列，消息队列的优势/72
3.2 安装和启动RabbitMQ /75
3.3 RabbitMQ的Hello World/ 76
3.4 RabbitMQ的工作队列/80
3.5 RabbitMQ的PUB/SUB队列/ 84
3.6 RabbitMQ的队列路由 /89
3.7 RabbitMQ的RPC远程过程调用/ 94
3.8 基于RabbitMQ的Node.js和Python通信实例/ 99
3.9 RabbitMQ方案和HTTP方案的对比 /103
3.10 小结/ 117
3.11 参考文献 117
第4章 编写命令行工具——打造一个静态博客系统/ 118
4.1 本章所使用到的第三方模块/ 119
4.2 命令格式/ 120
4.2.1 常见的命令格式/ 121
4.2.2 定义静态博客命令格式/121
4.3 编写命令行工具/ 122
4.4 实时预览/ 126
4.4.1 启动Web服务器 /127
4.4.2 渲染文章页面/ 128
4.4.3 文章元数据/ 131
4.4.4 增加模板/ 132
4.4.5 渲染文章列表/ 136
4.5 生成静态博客/ 140
4.6 配置文件/ 146
4.7 创建空白博客模板/ 150
4.8 一些有用的第三方服务/ 153
4.8.1 评论组件/ 153
4.8.2 分享组件/ 154
4.9 小结/ 155
4.10 参考文献/ 156
第5章 基于Koa快速开发Web应用/ 157
5.1 ES6时代的来临/ 157
5.1.1 function和function*/ 158
5.1.2 yield和yield*/ 1605.1.3 co和Koa/ 162
5.2 模板系统/ 170
5.2.1 ejs和co-ejs/ 170
5.2.2 过滤器/ 173
5.3 路由/ 173
5.4 参数验证与错误处理/ 175
5.4.1 koa-scheme /175
5.4.2 koa-errorhandler/ 178
5.5 缓存和配置/ 182
5.5.1 koa-router-cache和co-cache /182
5.5.2 config-lite/ 184
5.6 测试/ 184
5.6.1 单元测试/ 184
5.6.2 co-mocha和co-supertest 185
5.7 开发一个论坛系统/ 189
5.7.1 基础项目搭建/ 189
5.7.2 路由和功能设计/ 193
5.7.3 自定义模型/ 194
5.7.4 theme的设计/ 200
5.7.5 注册/ 206
5.7.6 登录与登出/ 213
5.7.7 主页与版块/ 216
5.7.8 用户页/ 221
5.7.9 发表页与话题页/ 222
5.7.10 测试/ 228
5.7.11 部署 231
5.8 小结/ 233
5.9 参考文献/ 233
第6章 Node.js测试服务搭建 /235
6.1 概述/ 235
6.1.1 目的/ 2356.1.2 Pixbi/ 236
6.2 搭建后端测试服务/ 238
6.2.1 单元测试/ 239
6.2.2 功能性测试/ 259
6.2.3 可拓展性测试/ 260
6.3 搭建前端测试服务/ 261
6.3.1 PhantomJS/ 262
6.3.2 BrowserStack/ 266
6.3.3 Adobe CEP（Common Extensibility Platform）/269
6.4 加入持续集成工作流/ 271
6.5 小结/ 274
6.6 参考资料/ 276
第7章 使用Node.js绑定C语言库——51Degrees.node /277
7.1 开发背景/ 277
7.2 预备知识/ 279
7.2.1 51Degrees-C /279
7.2.2 C/C++中的Node.js API/ 282
7.2.3 使用nan/ 284
7.3 编码/ 285
7.3.1 项目初始化/ 285
7.3.2 创建v8胶水层接口/ 286
7.3.3 创建JavaScript代码/ 293
7.4 构建与发布/ 294
7.4.1 node-gyp与binding.gyp/ 294
7.4.2 发布/ 296
7.5 如何从nan 1.x升级到nan 2.x /296
7.6 后记/ 298
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js实战（第2季）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js区块链开发
目录
推荐序一
推荐序二
推荐序三
前言
第一部分　了解区块链
第1章	加密货币就是货币 2
1.1	加密货币简史 2
1.2	什么是加密货币 3
1.3	加密货币就是货币 4
1.4	加密货币可靠吗 4
1.5	总结 6
1.6	参考 6
第2章	区块链，承载人类信用的基石 7
2.1	利益，现实世界的内在驱动力 7
2.2	信用，决定着利益转移的方向 7
2.3	未来趋势 9
2.4	应用场景 9
2.5	风险提示 11
2.6	总结 12
2.7	参考 12
第3章	共识机制，可编程的利益转移规则 13
3.1	机制，左右产品走向的根源 13
3.2	PoW：工作量证明机制 14
3.3	PoS：股权证明机制 15
3.4	DPoS：授权股权证明机制 16
3.5	亿书对DPoS机制的改进 17
3.6	总结 17
3.7	参考 18
第4章	区块链架构设计 19
4.1	基本概念 19
4.2	架构图 20
4.3	协议层 20
4.4	扩展层 22
4.5	应用层 22
4.6	编程实现 23
4.7	知识图谱 25
4.8	总结 26
4.9	参考 27
第二部分　Node.js入门指南
第5章	Node.js在币圈流行么 30
5.1	Node.js在开源社区很流行 30
5.2	Node.js在币圈也同样流行 32
5.2.1	Github自带搜索 32
5.2.2	自制查询工具 32
5.3	Github上前10个应用的简介 34
5.4	结论 36
5.5	总结 36
5.6	参考 36
第6章	Node.js让前端开发像子弹飞一样 37
6.1	项目需求 37
6.2	技术选型 37
6.3	Node.js简介 38
6.4	开发步骤 39
6.4.1	搭建环境 39
6.4.2	新建工程 40
6.4.3	前端组件 40
6.4.4	前端流程 42
6.4.5	学习API 43
6.4.6	数据整理 44
6.4.7	D3.js渲染 46
6.4.8	代码调试 48
6.4.9	部署发布 48
6.5	总结 51
6.6	参考 51
第7章	Node.js让后台开发像前端一样简单 53
7.1	需求 53
7.2	开发 54
7.2.1	安装Express 54
7.2.2	创建简单应用 54
7.2.3	使用模板引擎 55
7.2.4	使用静态文件服务 55
7.2.5	后台请求Github API 56
7.2.6	模块化重构 57
7.2.7	测试和部署 61
7.3	总结 61
7.4	参考 62
第8章	你必须知道的几个Node.js编码习惯 63
8.1	一切都是数据流 63
8.2	事事皆回调 65
8.3	异常要捕捉 67
8.4	总结 72
8.5	参考 73
第三部分　源码解读
第9章	亿书，一个面向未来的自出版平台 76
9.1	亿书是什么 76
9.2	使用场景 76
9.3	主要特点 77
9.4	核心功能 77
9.5	技术架构 78
9.6	总结 79
9.7	参考 79
第10章	入口程序app.js解读 80
10.1	源码与类图 80
10.2	解读 80
10.2.1	配置处理 80
10.2.2	异常捕捉 82
10.2.3	模块加载 83
10.3	总结 86
第11章	一个精巧的P2P网络实现 88
11.1	源码、类图与流程图 88
11.2	解读 89
11.2.1	路由扩展 89
11.2.2	节点路由 92
11.2.3	节点保存 94
11.3	总结 98
11.4	参考 98
第12章	加密和验证 99
12.1	源码、类图与流程图 99
12.2	概念 101
12.2.1	私钥和公钥 101
12.2.2	加密货币地址 101
12.2.3	加密过程 101
12.2.4	验证过程 102
12.3	实践 102
12.4	总结 104
12.5	参考 104
第13章	地址 105
13.1	源码、类图与流程图 105
13.2	解读 105
13.2.1	公共API 107
13.2.2	Hash地址 109
13.2.3	别名地址 110
13.2.4	注册用户名 111
13.2.5	联系人列表 113
13.3	总结 115
13.4	参考 115
第14章	签名和多重签名 116
14.1	源码 116
14.2	解读 116
14.2.1	签名 116
14.2.2	多重签名 120
14.3	总结 125
第15章	交易 126
15.1	源码与类图 126
15.2	解读 128
15.2.1	交易的本质 128
15.2.2	交易的生命周期 129
15.2.3	亿书的交易类型 129
15.2.4	交易的基本流程 130
15.2.5	转账交易分析 136
15.3	总结 141
15.4	参考 141
第16章	区块链 142
16.1	源码、类图与流程图 142
16.2	解读 143
16.2.1	区块链是什么 143
16.2.2	区块链的特点 147
16.2.3	区块链开发应该解决的问题 148
16.2.4	亿书区块链数据库设计 148
16.2.5	亿书区块链的实现 149
16.3	总结 162
16.4	参考 163
第17章	DPoS机制 164
17.1	源码与类图 164
17.2	受托人数据库表 165
17.3	解读 167
17.3.1	拜占庭将军问题 167
17.3.2	亿书DPoS机制概述 169
17.3.3	注册受托人 170
17.3.4	投票 170
17.3.5	块（时段）周期 170
17.3.6	受托人（循环）周期 172
17.3.7	奖励周期 174
17.4	总结 176
17.5	参考 176
第四部分　开发实践
第18章	函数式编程入门经典 178
18.1	什么是函数式编程 178
18.1.1	面向对象的编码方式 179
18.1.2	函数式编程的方式 179
18.1.3	函数式编程的延伸 180
18.2	函数式编程的优势 181
18.3	函数式编程的基本原则 181
18.3.1	直接把函数赋值给变量 182
18.3.2	使用最普适的方式命名 182
18.3.3	避免依赖外部变量 183
18.3.4	面对this值时，小心加小心 184
18.4	怎样进行函数式编程 184
18.4.1	柯里化：动态产生新函数 184
18.4.2	组合：自由组合新函数 186
18.4.3	注释：签名函数的行为和目的 187
18.4.4	容器：处理控制流、异常、异步和状态的独立模块 189
18.4.5	数据验证仿函数 191
18.4.6	错误处理仿函数 191
18.4.7	异步处理仿函数 194
18.4.8	嵌套处理仿函数 195
18.5	总结 197
18.6	参考 198
第19章	轻松从JavaScript文件生成UML类图 199
19.1	工具简要介绍 199
19.2	能从中学点什么 201
19.3	关于抽象语法树 201
19.4	工具实现过程 202
19.4.1	基本需求 202
19.4.2	架构流程和代码结构 203
19.5	总结 204
19.6	参考 204
第20章	命令行开发介绍 205
20.1	commander 205
20.2	概念定义 205
20.3	用法介绍 206
20.4	案例分析 208
20.5	总结 209
20.6	参考 209
第21章	一张图学会使用async组件进行异步流程控制 210
21.1	概念定义 211
21.2	流程类别 211
21.3	用法分类 212
21.4	脑图 213
21.5	总结 215
21.6	参考 215
第22章	静态网站开发全景扫描 216
22.1	亿书官网介绍 216
22.1.1	资源信息 216
22.1.2	功能特点 217
22.2	静态网站开发方案 218
22.3	与Ember.js的“前仇旧恨” 218
22.4	理解Ember.js几个让人迷乱的深“坑” 219
22.4.1	什么是前端框架 219
22.4.2	一定要使用它的命令行工具Ember-cli 219
22.4.3	在浏览器上安装使用Ember-inspector插件 219
22.4.4	Ember.js提倡的MVC模型里没有了VC 220
22.4.5	有了组件，自然就没了全局模板layout和局部模板partial 220
22.4.6	玩转Ember.js的必经之路 220
22.4.7	学会插件开发，把一切现成的插件装进Ember.js里 221
22.5	总结 222
22.6	参考 222
第23章	开发通用的HTML组件 223
23.1	插件简介 224
23.2	概念解读 225
23.3	开发过程 226
23.3.1	插件的基本情况 226
23.3.2	插件的工程结构 227
23.3.3	插件的开发设计 229
23.3.4	加载第三方库 231
23.3.5	测试插件 232
23.3.6	蓝图模板 233
23.3.7	辅助工具 234
23.4	Ember.js的钩子方法介绍 235
23.4.1	contentFor钩子方法 235
23.4.2	写入命令行 235
23.4.3	其他钩子方法 236
23.5	总结 236
23.6	参考 236
第24章	三张图让你全面掌握加密解密技术 237
24.1	密码学纵览 237
24.2	场景与算法 237
24.3	Node.js中的加密和解密、签名和认证 237
24.4	趣味实践 241
24.4.1	场景 241
24.4.2	需求 241
24.4.3	方案 241
24.4.4	编码 241
24.5	参考 243
第25章	在时间和数据计算方面应该注意的问题 244
25.1	时间戳处理问题 244
25.1.1	问题再现 244
25.1.2	时间戳的重要性 245
25.1.3	不同产品对时间处理的需求 245
25.1.4	时间处理的基本原理 245
25.1.5	JavaScript语言的Date对象 246
25.1.6	实践 247
25.2	数据计算处理问题 248
25.2.1	问题再现 248
25.2.2	终极答案 249
25.3	参考 249
第26章	测试 251
26.1	概念解释 251
26.2	框架流程 252
26.3	测试框架与库介绍 252
26.4	实践 253
26.5	总结 257
26.6	参考 257
第五部分　附录
附录A	区块链相关术语 260
附录B	区块链相关名词 273
附录C	关于区块链俱乐部 280
后记 282
↑折 叠
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js区块链开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js进阶之路
第1章 Node异步编程范式 1
1.1 同步与异步的比较 2
1.2 Node异步的实现 7
1.2.1 HTTP请求——完全异步的例子 8
1.2.2 本地磁盘I/O——多线程模拟 17
1.3 事件驱动 18
参考资料 19
第2章 搭建自己的开发环境 21
2.1 Node的编译与安装 22
2.2 开发与调试 23
2.3 单元测试 29
2.3.1 Mocha 测试框架 29
2.3.2 TDD 风格 32
2.3.3 BDD 风格 34
2.3.4 生成不同形式的测试报告 35
2.3.5 代码覆盖率工具Istanbul36
参考资料 40
第3章 使用Docker部署Node服务 43
3.1 Docker基础 44
3.2 在Docker中运行Node 45
3.3 导出配置好的容器 47
参考资料 48
第4章 Node模块 49
4.1 程序入口 50
4.2 VM模块 50
4.3 模块加载与缓存 52
4.4 模块分类 54
4.5 正确导出模块 55
4.6 小心使用全局变量 56
第5章 V8引擎 57
5.1 Java Script代码的编译与优化 58
5.1.1 即时编译 58
5.1.2 隐藏类 59
5.1.3 内联缓存 60
5.1.4 优化回退 61
5.1.5 写出更具亲和性的代码 62
5.1.6 借助TypeScript 63
5.2 垃圾回收与内存控制 65
5.2.1 V8的垃圾回收算法 65
5.2.2 使用Buffer 67
5.2.3 避免内存泄漏 70
参考资料 77
V
第6章 Promise对象 79
6.1 Promise的含义 80
6.2 基本用法 80
6.3 then的链式写法 82
6.4 bluebird库 85
参考资料 86
第7章 用ES6 Generator解决回调金字塔 87
7.1 Node异步实现流程 88
7.2 用Generator实现异步调用与多并发 89
7.3 严格模式下运行 99
7.4 理解执行过程 100
7.5 本章结语 106
第8章 LoopBack开源框架 107
8.1 安装与运行 108
8.2 路由与权限控制 113
8.3 添加新模型 121
8.4 初始化数据库 131
8.5 钩子机制 134
8.6 中间件 137
8.7 模型关系 139
8.8 使用cluster模式运行服务 141
参考资料 144
第9章 编写C++扩展 145
9.1 使用C++编写扩展模块 146
9.1.1 导出对象 146
9.1.2 导出函数 149
9.1.3 导出构造函数 151
9.2 线程模型与CPU密集型任务 164
9.3 线程对象 164
9.4 本章结语 170
参考资料 170
附 录 171
附录 A JavaScript 严格模式 172
附录 B JavaScript 编码规范 182
参考资料 195
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js进阶之路
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MEAN Web开发
第1章　MEAN简介　　 1
1.1 三层Web应用开发　　1
1.2 JavaScript的演进　　2
1.3 MEAN简介　　3
1.4 安装MongoDB　　4
1.4.1 在Windows上安装MongoDB　　5
1.4.2 在Mac OS X和Linux上安装MongoDB　　7
1.4.3 使用MongoDB命令行工具　　8
1.5 安装Node.js　　9
1.5.1 在Windows上安装Node.js　　10
1.5.2 在Mac OS X上安装Node.js　　11
1.5.3 在Linux上安装Node.js 　　12
1.5.4 运行Node.js　　12
1.6 NPM简介　　13
1.7 总结　　18
第2章　Node.js入门　　19
2.1 Node.js简介　　19
2.1.1 JavaScript事件驱动编程　　20
2.1.2 Node.js事件驱动编程　　22
2.2 JavaScript闭包　　23
2.3 Node模块　　24
2.3.1 CommonJS模块　　24
2.3.2 Node.js核心模块　　26
2.3.3 Node.js第三方模块　　26
2.3.4 Node.js文件模块　　26
2.3.5 Node.js文件夹模块　　27
2.4 Node.js Web应用开发　　27
2.5 总结　　34
第3章　使用Express开发Web应用　　35
3.1 Express简介　　35
3.2 Express安装　　36
3.3 创建第一个Express应用　　36
3.4 应用、请求和响应对象　　37
3.4.1 应用对象　　37
3.4.2 请求对象　　38
3.4.3 响应对象　　38
3.5 外部的中间件　　39
3.6 实现MVC模式　　40
3.7 Express应用配置　　48
3.8 渲染视图　　51
3.8.1 配置视图系统　　51
3.8.2 EJS视图渲染　　53
3.9 静态文件服务　　53
3.10 配置会话　　55
3.11 总结　　57
第4章　MongoDB入门　　58
4.1 NoSQL简介　　58
4.2 MongoDB简介　　60
4.3 MongoDB的关键特性　　61
4.3.1 BSON格式　　61
4.3.2 MongoDB即席查询　　61
4.3.3 MongoDB索引　　62
4.3.4 MongoDB副本集　　63
4.3.5 MongoDB分片　　64
4.4 MongoDB命令行工具　　65
4.5 MongoDB数据库　　66
4.6 MongoDB集合　　66
4.7 MongoDB增删改查操作　　67
4.7.1 创建新文档　　67
4.7.2 读取文档　　68
4.7.3 更新已有文档　　69
4.7.4 删除文档　　70
4.8 总结　　71
第5章　Mongoose入门　　72
5.1 Mongoose简介　　72
5.1.1 安装Mongoose　　72
5.1.2 连接MongoDB　　73
5.2 理解Mongoose的模式　　74
5.2.1 创建User模式与模型　　74
5.2.2 注册USer模型　　75
5.2.3 使用save()创建新文档　　75
5.2.4 使用find()查找多个文档　　77
5.2.5 使用findOne()读取单个文档　　79
5.2.6 更新已有文档　　80
5.2.7 删除已有文档　　81
5.3 扩展Mongoose模式　　82
5.3.1 定义默认值　　82
5.3.2 使用模式修饰符　　83
5.3.3 增加虚拟属性　　85
5.3.4 使用索引优化查询　　85
5.4 模型方法自定义　　86
5.4.1 自定义静态方法　　86
5.4.2 自定义实例方法　　87
5.5 模型的校验　　87
5.5.1 预定义的验证器　　87
5.5.2 自定义的验证器　　89
5.6 使用Mongoose中间件　　89
5.6.1 预处理中间件　　89
5.6.2 后置处理中间件　　90
5.7 使用Mongoose DBRef　　90
5.8 总结　　91
第6章　使用Passport模块管理用户权限　　92
6.1 Passport简介　　92
6.1.1 安装　　92
6.1.2 配置　　93
6.2 理解Passport策略　　 95
6.2.1 使用Passport的本地策略　　 95
6.2.2 修改User模型　　 97
6.2.3 创建身份验证视图　　 99
6.2.4 修改用户控制器　　 101
6.2.5 添加用户路由　　 105
6.3 理解Passport的OAuth策略　　 107
6.4 总结　　 118
第7章　AngularJS入门　　 119
7.1 AngularJS简介　　 119
7.2 AngularJS的核心概念　　 119
7.2.1 核心模块　　 120
7.2.2 模块　　 120
7.2.3 双向数据绑定　　 121
7.2.4 依赖注入　　 122
7.2.5 AngularJS指令　　 123
7.2.6 AngularJS应用的引导　　 124
7.3 安装AngularJS　　 125
7.3.1 Bower包管理器　　 125
7.3.2 配置Bower　　 126
7.3.3 使用Bower安装AngularJS 　　 126
7.3.4 配置AngularJS　　 127
7.4 AngularJS应用的结构　　 127
7.5 引导AngularJS应用　　 130
7.6 AngularJS的MVC实体　　 131
7.6.1 视图　　 132
7.6.2 控制器和scope　　 133
7.7 AngularJS路由　　 135
7.7.1 安装ngRoute模块　　 136
7.7.2 配置URL模式　　 137
7.7.3 AngularJS应用路由　　 137
7.8 AngularJS服务　　 139
7.8.1 预置服务　　 139
7.8.2 自定义服务　　 140
7.8.3 服务的使用　　 141
7.9 管理AngularJS的身份验证　　 141
7.9.1 将user对象填充到视图　　 141
7.9.2 添加身份验证服务　　 142
7.9.3 使用身份验证服务　　 144
7.10 总结　　144
第8章　创建MEAN的CURD模块　　 145
8.1 CURD模块简介　　145
8.2 配置Express组件　　145
8.2.1 创建Mongoose模型　　146
8.2.2 建立Express控制器　　147
8.2.3 编写Express路由　　152
8.2.4 配置Express应用　　153
8.3 ngResource模块简介　　154
8.3.1 安装ngResource模块　　154
8.3.2 使用$resource服务　　156
8.4 实现AngularJS的MVC模块　　157
8.4.1 创建模块服务　　157
8.4.2 建立模块控制器　　158
8.4.3 实现模块视图　　161
8.4.4 编写AngularJS路由　　164
8.5 最终实现　　164
8.6 总结　　166
第9章　基于Socket.io的实时通信　　 167
9.1 WebSockets简介　　167
9.2 Socket.io简介　　168
9.2.1 Socket.io服务器端对象　　169
9.2.2 Socket.io客户端对象　　171
9.2.3 Socket.io的事件　　171
9.2.4 Socket.io命名空间　　174
9.2.5 Socket.io的房间　　175
9.3 Socket.io的安装　　176
9.3.1 配置Socket.io的服务器　　177
9.3.2 配置Socket.io的会话　　178
9.4 使用Socket.io创建聊天室　　182
9.4.1 设置聊天服务器的事件处理程序　　182
9.4.2 在AngularJS中创建Socket服务　　184
9.4.3 控制器　　185
9.4.4 视图　　186
9.4.5 路由　　186
9.4.6 实现　　187
9.5 总结　　189
第10章　MEAN应用的测试　　 190
10.1 JavaScript测试简介　　190
10.1.1 TDD、BDD和单元测试　　191
10.1.2 测试框架　　192
10.1.3 断言库　　192
10.1.4 测试执行过程管理工具　　192
10.2 Express应用测试　　193
10.2.1 Mocha简介　　193
10.2.2 Should.js简介　　194
10.2.3 SuperTest简介　　194
10.2.4 Mocha的安装　　195
10.2.5 安装Should.js和SuperTest模块　　195
10.2.6 测试环境配置　　196
10.2.7 编写Mocha测试　　197
10.2.8 执行Mocha测试　　201
10.3 AngularJS应用测试　　202
10.3.1 Jasmine框架简介　　203
10.3.2 AngularJS单元测试　　203
10.3.3 AngularJS E2E测试　　213
10.4 总结　　217
第11章　MEAN应用的调试与自动化　　 218
11.1 构建工具Grunt　　218
11.1.1 安装　　218
11.1.2 Grunt的配置　　220
11.2 使用node-inspector调试Express程序　　230
11.2.1 使用Grunt任务安装node-inspector　　231
11.2.2 使用Grunt任务配置node-inspector　　232
11.2.3 使用Grunt任务运行调试　　234
11.3 使用Batarang调试AngularJS程序　　236
11.4 总结　　241
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>MEAN Web开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js：来一打 C++ 扩展
1 Node.js 的 C++ 扩展前驱知识储备 1
1.1 Node.js 的模块机制 2
1.1.1 CommonJS 的模块规范 2
1.1.2 Node.js 的模块 4
1.1.3 小结 9
1.1.4 参考资料 9
1.2 Node.js 的包机制 9
1.2.1 CommonJS 的包规范 9
1.2.2 Node.js / NPM 下的包 13
1.2.3 NPM 与 CNPM 16
1.2.4 小结 19
1.2.5 参考资料 19
1.3 Node.js 依赖简介 20
1.3.1 Chrome V8 20
1.3.2 libuv 25
1.3.3 其他依赖 28
1.3.4 小结 30
1.3.5 参考资料 30
1.4 C++ 扩展开发的准备工作 31
1.4.1 编辑器 / IDE 31
1.4.2 node-gyp 36
1.4.3 其他构建工具 54
1.4.4 小结 56
1.4.5 参考资料 56
2 C++ 模块原理简析 57
2.1 为什么要写 C++ 模块 57
2.1.1 C++ 比 JavaScript 解释器高效 57
2.1.2 已有的 C++ 轮子 72
2.1.3 小结 77
2.1.4 参考资料 77
2.2 什么是 C++ 扩展 78
2.2.1 C++ 模块本质 78
2.2.2 Node.js 模块加载原理 80
2.2.3 小结 102
2.2.4 参考资料 103
3 Chrome V8 基础 104
3.1 Node.js 与 Chrome V8 104
3.2 基本概念 105
3.2.1 内存机制 105
3.2.2 隔离实例（Isolate） 108
3.2.3 上下文（Context） 109
3.2.4 脚本（Script） 110
3.2.5 小结 110
3.2.6 参考资料 111
3.3 句柄（Handle） 111
3.3.1 本地句柄（Local） 112
3.3.2 持久句柄（Persistent） 115
3.3.3 永生句柄（Eternal） 119
3.3.4 待实本地句柄（Maybe Local） 119
3.3.5 小结 121
3.3.6 参考资料 121
3.4 句柄作用域 121
3.4.1 一般句柄作用域（Handle Scope） 122
3.4.2 可逃句柄作用域（Escapable Handle Scope） 125
3.4.3 小结 129
3.4.4 参考资料 129
3.5 上下文（Context） 129
3.6 模板（Template） 133
3.6.1 函数模板（Function Template） 133
3.6.2 对象模板（Object Template） 138
3.6.3 对象模板的访问器（Accessor）与拦截器（Interceptor） 144
3.6.4 对象模板的内置字段（Internal Field） 175
3.6.5 函数模板的继承（Inherit） 183
3.6.6 小结 188
3.6.7 参考资料 189
3.7 常用数据类型 189
3.7.1 基值（Value） 189
3.7.2 字符串（String） 194
3.7.3 数值类型 196
3.7.4 布尔类型（Boolean） 196
3.7.5 对象（Object） 196
3.7.6 函数（Function） 200
3.7.7 数组（Array） 202
3.7.8 JSON 解析器 203
3.7.9 函数回调信息（Function Callback Info） 203
3.7.10 函数返回值（Return Value） 204
3.7.11 隔离实例（Isolate） 204
3.7.12 小结 205
3.7.13 参考资料 206
3.8 异常机制 206
3.8.1 try-catch 206
3.8.2 抛出异常 209
3.8.3 异常生成类（Exception） 211
3.8.4 小结 211
3.8.5 参考资料 211
4 C++ 扩展实战初探 212
4.1 binding.gyp 212
4.1.1 惊鸿一瞥 213
4.1.2 binding.gyp 基础结构 213
4.1.3 GYP 文件 214
4.1.4 常用字段 221
4.1.5 小结 228
4.1.6 参考资料 228
4.2 牛刀小试 229
4.2.1 又是 Hello World 229
4.2.2 函数参数 232
4.2.3 回调函数 234
4.2.4 函数返回 238
4.2.5 小结 239
4.2.6 参考资料 240
4.3 循序渐进 240
4.3.1 C++ 与 JavaScript 类封装 240
4.3.2 实例化 C++ 类封装对象的函数 250
4.3.3 将 C++ 类封装对象传来传去 253
4.3.4 进程退出钩子 255
4.3.5 小结 259
4.3.6 参考资料 259
5 Node.js 原生抽象——NAN 260
5.1 Node.js 原生模块开发方式的变迁 260
5.1.1 以不变应万变 260
5.1.2 时代在召唤 261
5.1.3 小结 267
5.1.4 参考资料 267
5.2 基础开发 267
5.2.1 什么是 NAN 267
5.2.2 安装和配置 269
5.2.3 先睹为快——搭上NAN 的快车 270
5.2.4 基础帮助函数和宏 276
5.2.5 忽略 node_modules 279
5.2.6 小结 279
5.2.7 参考资料 280
5.3 JavaScript 函数 280
5.3.1 函数参数类型 280
5.3.2 函数声明 282
5.3.3 函数设置 288
5.3.4 小结 296
5.3.5 参考资料 296
5.4 常用帮助类与函数 296
5.4.1 句柄相关 296
5.4.2 创建数据对象 298
5.4.3 与数据对象“玩耍” 300
5.4.4 封装一个类 314
5.4.5 异常处理 315
5.4.6 小结 315
5.4.7 参考资料 316
5.5 NAN 中的异步机制 316
5.5.1 Nan::AsyncQueueWorker 316
5.5.2 Nan::Callback 317
5.5.3 Nan::AsyncWorker 317
5.5.4 Nan::AsyncProgressWorker 323
5.5.5 小结 327
5.5.6 参考资料 327
6 异步之旅——libuv 328
6.1 基础概念 329
6.1.1 事件循环 330
6.1.2 句柄（Handle）与请求（Request） 333
6.1.3 尝尝甜头 335
6.1.4 小结 340
6.1.5 参考资料 340
6.2 libuv 的跨线程编程基础 341
6.2.1 libuv 的线程 342
6.2.2 同步原语（Synchronization Primitive） 347
6.2.3 工作队列 355
6.2.4 小结 356
6.2.5 参考资料 357
6.3 跨线程通信 357
6.3.1 uv_async_t 句柄 357
6.3.2 Watchdog 半成品实战解析 358
6.3.3 Watchdog 试运行 367
6.3.4 小结 368
6.3.5 参考资料 369
7 实战——文件监视器 370
7.1 准备工作 370
7.1.1 功能规划 370
7.1.2 文件系统监听库——efsw 373
7.1.3 小结 376
7.1.4 参考资料 376
7.2 核心设计 376
7.2.1 API 设计 377
7.2.2 EFSWCore 的血肉之躯 377
7.2.3 EFSWCore 的灵魂 381
7.2.4 小结 385
7.3 编写JavaScript 类 386
7.3.1 类的设计 386
7.3.2 核心逻辑 388
7.3.3 简单容错 391
7.3.4 小结 393
7.4 进一步完善 393
7.4.1 C++ 代码的完善 393
7.4.2 JavaScript 代码的完善 398
7.4.3 小结 400
8 实战——现有包剖析 401
8.1 字符串哈希模块——Bling Hashes 401
8.1.1 文件设定 402
8.1.2 C++ 源码剖析 403
8.1.3 JavaScript 源码剖析 408
8.1.4 小结 409
8.1.5 参考资料 410
8.2 类 Proxy 包——Auto Object 410
8.2.1 Proxy 410
8.2.2 Auto Object 使用范例 412
8.2.3 代码剖析 415
8.2.4 小结 424
8.2.5 参考资料 424
9 N-API——下一代 Node.js C++ 扩展开发方式 425
9.1 浅尝辄止 426
9.1.1 实现一个 Echo 函数 426
9.1.2 尝试运行 N-API 扩展 430
9.1.3 向下兼容 431
9.1.4 N-API Package——C++ 封装 433
9.1.5 小结 433
9.1.6 参考资料 433
9.2 基本数据类型与错误处理 433
9.2.1 基本数据类型 433
9.2.2 与作用域及生命周期相关的数据类型 435
9.2.3 回调数据类型 438
9.2.4 错误处理 439
9.2.5 模块注册 441
9.2.6 小结 442
9.2.7 参考资料 442
9.3 对象与函数 442
9.3.1 对象 442
9.3.2 函数 448
9.3.3 类的封装 453
9.3.4 小结 455
9.3.5 参考资料 455
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js：来一打 C++ 扩展
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>了不起的Node.js
PART Ⅰ　从安装与概念开始
CHAPTER 1　安装............................................... 3
在Windows下安装............................................... 3
在OS.X下安装. ................................................ 4
在Linux下安装................................................. 5
编译. ............................................................5
确保安装成功. ...............................................5
Node.REPL................................................. 5
执行文件.......................................................... 6
NPM................................................................. 6
安装模块...........................................................7
自定义模块. .......................................................8
安装二进制工具包. ..................................................9
浏览NPM仓库. .......................................................9
小结................................................................. 10
CHAPTER 2　JavaScript概览.........................................11
介绍.......................................................... 11
JavaScript基础..................................................... 12
类型. ......................................................... 12
类型的困惑. ............................................... 12
函数. .......................................................... 13
THIS、FUNCTION #CALL以及FUNCTION#APPLY.................... 14
函数的参数数量. ........................... 14
闭包. ........................................................ 14
类. .............................................................. 15
继承. ..................................................... 16
TRY.{}.CATCH.{}...................................... 17
v8中的JavaScript............................... 17
OBJECT#KEYS....................................................... 18
ARRAY#ISARRAY................................................ 18
数组方法................................................. 18
字符串方法.. .................................................... 19
JSON............................................................. 19
FUNCTION#BIND....................................................... 19
FUNCTION#NAME.............................................. 19
_PROTO_（继承）. ............................................ 20
存取器....................................................... 20
小结.............................................................. 21
CHAPTER ３　阻塞与非阻塞IO................................. 23
能力越强，责任就越大................................................. 23
阻塞. ............................................................. 25
单线程的世界. ............................................... 27
错误处理..................................................... 29
堆栈追踪................................................ 30
小结............................................................... 32
CHAPTER 4　Node中的JavaScript ..................................... 33
global对象....................................................... 33
实用的全局对象. ................................................ 34
模块系统............................................................ 34
绝对和相对模块. .................................................. 35
暴露API. ............................................................... 37
事件......................................................... 38
buffer............................................................... 40
小结................................................................... 41
PART Ⅱ　Node重要的API
CHAPTER 5　命令行工具（CLI）以及FS API：首个Node应用................... 45
需求................................................. 45
编写首个Node程序...................................... 46
创建模块.............................................. 46
同步还是异步. ............................ 47
理解什么是流（stream）................................... 49
输入和输出. .......................................................... 50
重构. ........................................ 53
用fs进行文件操作. .............................. 55
对CLI一探究竟. ................................................. 56
argv.................................................... 57
工作目录...................................... 57
环境变量........................................... 58
退出. ............................................... 58
信号. .......................................................... 58
ANSI转义码............................................ 59
对fs一探究竟. ................................................. 59
Stream......................................................... 59
监视. .......................................... 60
小结...................................................... 61
CHAPTER 6　TCP ........................................... 63
TCP有哪些特性. ..................................................... 64
面向连接的通信和保证顺序的传递. ........................... 64
面向字节........................................ 65
可靠性............................................... 65
流控制......................................... 65
拥堵控制.............................................. 65
Telnet................................................................ 65
基于TCP的聊天程序............................................... 68
创建模块..................................... 68
理解NET.SERVER.API........................ 68
接收连接....................................... 70
data事件. ...................................................... 71
状态以及记录连接情况. ........................................ 73
圆满完成此程序. ............................................ 75
一个IRC客户端程序.......................................... 77
创建模块.............................................. 77
理解NET#STREAM.API.. ......................................... 78
实现部分IRC协议. .................................................. 78
测试实际的IRC服务器. .................................. 78
小结................................................................. 79
CHAPTER 7　HTTP .................................................. 81
HTTP结构......................................................... 81
头信息. ...................................................... 82
连接.............................................................. 87
一个简单的Web服务器.................................................. 88
创建模块....................................... 88
输出表单.................................................... 88
method和URL. ........................................... 90
数据. .............................................. 92
整合. ................................................ 94
让程序更健壮. ..................................... 95
一个Twitter.Web客户端......................................... 96
创建模块....................................... 96
发送一个简单的HTTP请求. ...................... 97
发送数据......................................... 98
获取推文................................................. 99
superagent来拯救.............................................. 102
使用up重启HTTP服务器..................................... 103
小结............................................. 104
PART Ⅲ　Web开发
CHAPTER 8　Connect .............................. 107
使用HTTP构建一个简单的网站. ....................................... 108
通过Connect实现一个简单的网站...................................... 111
中间件. ................................................. 112
书写可重用的中间件. .........................114
static中间件. .............................................119
query中间件. .......................................120
logger中间件................................................... 120
body.parser中间件. .................................122
cookie.........................................................125
会话（session）. ......................................126
Redis.session..................................................131
methodOverride中间件. ...........................132
basicAuth中间件. ......................................132
小结.............................................................. 134
CHAPTER 9　Express..................................................135
一个小型Express应用. ...................................... 135
创建模块..............................................136
HTML...........................................................136
SETUP..........................................................137
定义路由............................................137
查询. .................................................140
运行. .....................................................141
设置......................................................... 142
模板引擎...................................................... 143
错误处理........................................................ 144
快捷方法................................................. 144
路由................................................ 146
中间件. .................................................... 148
代码组织策略. ......................................... 149
小结................................................. 151
CHAPTER 10　WebSocket .................. 153
Ajax.............................................. 153
HTML5.WebSocket............................................... 156
一个ECHO示例. ......................................................... 157
初始化项目. .............................................157
建立服务器. ..................................................158
建立客户端. ......................................159
运行示例程序. ...................................160
鼠标光标.......................................... 161
初始化示例程序. .........................................161
建立服务器. ............................................161
建立客户端. .....................................164
运行示例程序. .........................................166
面临一个挑战. ............................................. 166
关闭并不意味着断开连接. .............................166
JSON...........................................167
重连. ...................................................167
广播. ................................................167
WebSocket属于HTML5：早期浏览器不支持. ..........................167
解决方案.................................................167
小结............................................................. 167
CHAPTER 11　Socket.IO.............................................169
传输................................................. 170
断开.VS.关闭. ............................................170
事件. ..........................................170
命名空间..............................................171
聊天程序................................................. 172
初始化程序. .......................................172
构建服务器. ..........................................172
构建客户端. .......................................173
事件和广播. ........................................175
消息接收确认. .................................179
一个轮流做DJ的应用................................ 180
扩展聊天应用. ...........................................181
集成Grooveshark.API. ...............................182
播放歌曲...............................................185
小结.................................................... 190
PART Ⅳ　数据库
CHAPTER 12　MongoDB.......................193
安装.................................................. 195
使用MongoDB：一个用户认证的例子. .................................. 195
构建应用程序. .......................................195
创建Express.App.. ..............................196
连接MongoDB. ...................................200
创建文档......................................201
查找文档..................................203
身份验证中间件. ..................................204
校验.. ..............................................205
原子性..............................................206
安全模式................................206
Mongoose介绍......................................... 206
定义模型........................................207
定义嵌套的键. ..........................208
定义嵌套文档. .....................................209
构建索引..........................................209
中间件.................................................209
探测模型状态.. ...............................210
查询. ..............................................210
扩展查询........................................210
排序.. ........................................211
选择. ......................................................211
限制.. .....................................211
跳过. .........................................211
自动产生键. ...............................211
转换. ..............................................212
一个使用Mongoose的例子........................................ 212
构建应用.................................212
重构. ..............................213
建立模型.................................213
小结.......................................... 215
CHAPTER 13　MySQL...........................................217
node-mysql........................................ 217
初始化项目. .......................................217
Express应用. ...................................218
连接MySQL. .....................................219
初始化脚本. .......................................220
创建数据................................................224
获取数据.....................................228
sequelize............................................ 229
初始化sequelize. ................................230
初始化Express应用. ....................................230
连接sequelize. .........................233
定义模型和同步. ........................... 234
创建数据.................................236
获取数据......................................238
删除数据..............................239
完整地完成应用. ...............................240
小结.......................................... 241
CHAPTER 14　Redis......................................... 243
安装Redis............................................... 244
Redis查询语言. ............................................... 245
数据类型............................................. 245
字符串. ...................................246
哈希. .................................................246
列表. ......................................... 248
数据集. .....................................249
有序数据集. .........................................249
Redis和Node. .......................................... 249
使用node-redis实现一个社交图谱. .............250
小结......................................... 259
PART Ⅴ　测试
CHAPTER 15　代码共享 ................................. 263
什么样的代码可以共享........................................... 263
书写兼容的JavaScript代码................................ 264
导出模块......................................................264
模拟实现ECMA.API. ................................265
模拟实现Node.API. ......................................267
模拟实现浏览器端API. ...............................267
跨浏览器的继承实现. ...........................268
集成到一起：browserbuild. ...................... 268
基础案例....................................269
小结......................................... 271
CHAPTER 16　测试................................... 273
简单测试........................................ 273
测试目标............................................. 274
测试策略................................... 274
测试程序...................................................275
expect.js................................................. 276
API一览. .........................................276
Mocha................................................. 278
测试异步代码. ..................................279
BDD风格. ................................281
TDD风格. .......................................281
export风格. .................................282
在浏览器端使用Mocha. ...................................282
小结.................................... 284
索引 ...................................... 285
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>了不起的Node.js
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js入门经典
第1部分　入门
第1章　Node.js介绍　2
1.1　什么是Node.js　2
1.2　使用Node.js能做什么　3
1.3　安装并创建第一个Node.js程序　3
1.3.1　验证Node.js正确安装　4
1.3.2　创建“Hello World”Node.js程序　4
1.4　小结　5
1.5　问与答　6
1.6　测验　6
1.6.1　问题　6
1.6.2　答案　7
1.7　练习　7
第2章　npm(Node包管理器)　8
2.1　npm是什么　8
2.2　安装npm　9
2.3　安装模块　9
2.4　使用模块　10
2.5　如何找模块　11
2.5.1　官方来源　11
2.5.2　非官方来源　12
2.6　本地和全局的安装　13
2.6.1　本地安装　13
2.6.2　全局安装　13
2.7　如何找模块文档　14
2.8　使用package.json指定依赖关系(dependency)　14
2.9　小结　16
2.10　问与答　16
2.11　测验　16
2.11.1　问题　16
2.11.2　答案　17
2.12　练习　17
第3章　Node.js的作用　18
3.1　设计Node.js的目的　18
3.2　理解I/O　19
3.3　处理输入　19
3.4　联网的I/O是不可预测的　22
3.5　人类是不可预测的　24
3.6　处理不可预测性　25
3.7　小结　26
3.8　问与答　26
3.9　测验　27
3.9.1　问题　27
3.9.2　答案　27
3.10　练习　27
第4章　回调(Callback)　29
4.1　什么是回调　29
4.2　剖析回调　33
4.3　Node.js如何使用回调　34
4.4　同步和异步代码　36
4.5　事件循环　39
4.6　小结　39
4.7　问与答　39
4.8　测验　40
4.8.1　问题　40
4.8.2　答案　40
4.9　练习　40
第2部分　使用Node.js的基本网站
第5章　HTTP　44
5.1　什么是HTTP　44
5.2　使用Node.js的HTTP服务器　44
5.2.1　一个基础的服务器　44
5.2.2　加入头(Header)　45
5.2.3　检查响应头　46
5.2.4　Node.js中的重定向　49
5.2.5　响应不同的请求　50
5.3　使用Node.js的HTTP客户端　52
5.4　小结　53
5.5　问与答　53
5.6　测验　54
5.6.1　问题　54
5.6.2　答案　54
5.7　练习　54
第6章　Express介绍　55
6.1　什么是Express　55
6.2　为什么使用Express　55
6.3　安装Express　56
6.4　创建一个基础的Express站点　56
6.5　探索Express　58
6.5.1　app.js　58
6.5.2　node_modules　58
6.5.3　package.json　58
6.5.4　public　58
6.5.5　routes　58
6.5.6　views　58
6.6　介绍Jade　59
6.6.1　使用Jade定义页面结构　60
6.6.2　使用Jade输出数据　62
6.7　小结　68
6.8　问与答　68
6.9　测验　68
6.9.1　问题　69
6.9.2　答案　69
6.10　练习　69
第7章　深入Express　70
7.1　Web应用程序中的路由　70
7.2　在Express中路由如何工作　70
7.3　添加GET路由　71
7.4　添加POST路由　72
7.5　在路由中使用参数　73
7.6　让路由保持可维护性　74
7.7　视图渲染　75
7.8　使用本地变量　76
7.9　小结　78
7.10　问与答　78
7.11　测验　78
7.11.1　问题　79
7.11.2　答案　79
7.12　练习　79
第8章　数据的持久化　80
8.1　什么是持久的数据　80
8.2　将数据写入文件　81
8.3　从文件读取数据　82
8.4　读取环境变量　83
8.5　使用数据库　84
8.5.1　关系数据库　84
8.5.2　NoSQL数据库　85
8.6　在Node.js中使用MongoDB　85
8.6.1　安装MongoDB　86
8.6.2　连接MongoDB　87
8.6.3　定义文档　89
8.6.4　将Twitter Bootstrap包含进来　90
8.6.5　索引(Index)视图　91
8.6.6　创建(Create)视图　93
8.6.7　编辑视图　95
8.6.8　删除任务　98
8.6.9　添加闪出消息　99
8.6.10　验证输入的数据　101
8.7　小结　102
8.8　问与答　103
8.9　测验　103
8.9.1　问题　103
8.9.2　答案　103
8.10　练习　104
第3部分　调试、测试与部署
第9章　调试Node.js应用程序　106
9.1　调试　106
9.2　STDIO模块　107
9.3　Node.js调试器　111
9.4　Node Inspector　113
9.5　关于测试的注释　116
9.6　小结　116
9.7　问与答　116
9.8　测验　117
9.8.1　问题　117
9.8.2　答案　117
9.9　练习　117
第10章　测试Node.js应用程序　119
10.1　为什么测试　119
10.2　Assert(断言)模块　120
10.3　第三方测试工具　122
10.4　行为驱动的开发(Behavior Driven Development)　125
10.4.1　Vows　125
10.4.2　Mocha　128
10.5　小结　131
10.6　问与答　131
10.7　测验　132
10.7.1　问题　132
10.7.2　答案　132
10.8　练习　132
第11章　部署Node.js应用程序　133
11.1　准备好部署　133
11.2　在云上托管　133
11.3　Heroku　135
11.3.1　注册Heroku　135
11.3.2　为Heroku准备应用程序　136
11.3.3　将应用程序部署到Heroku　137
11.4　Cloud Foundry　138
11.4.1　注册Cloud Foundry　138
11.4.2　为Cloud Foundry准备应用程序　139
11.4.3　将应用程序部署到Cloud Foundry　140
11.5　Nodester　141
11.5.1　注册Nodester　141
11.5.2　为Nodester准备应用程序　142
11.5.3　将应用程序部署到Nodester　143
11.6　其他PaaS提供商　144
11.7　小结　144
11.8　问与答　144
11.9　测验　145
11.9.1　测验　145
11.9.2　答案　145
11.10　练习　145
第4部分　使用Node.js的中间站点
第12章　介绍Socket.IO　148
12.1　现在要开始学习一些完全不同的技术了　148
12.2　动态Web简史　148
12.3　Socket.IO　149
12.4　基础的Socket.IO示例　150
12.5　从服务器发送数据到客户端　152
12.6　将数据广播给客户端　156
12.7　双向数据　160
12.8　小结　163
12.9　问与答　163
12.10　测验　164
12.10.1　问题　164
12.10.2　答案　164
12.11　练习　165
第13章　一个Socket.IO聊天服务器　166
13.1　Express和Socket.IO　166
13.2　添加昵称　168
13.2.1　将昵称发送给服务器　169
13.2.2　管理昵称列表　171
13.2.3　使用回调来验证　174
13.2.4　广播昵称列表　178
13.2.5　添加消息收发功能　179
13.3　小结　183
13.4　问与答　184
13.5　测验　184
13.5.1　问题　184
13.5.2　答案　184
13.6　练习　185
第14章　一个流Twitter客户端　186
14.1　流API　186
14.2　注册Twitter　187
14.3　和Node.js一起使用Twitter的API　189
14.4　从数据中挖掘含义　191
14.5　将数据推送到浏览器　194
14.6　创建一个实时的爱恨表　197
14.7　小结　206
14.8　问与答　206
14.9　测验　206
14.9.1　问题　206
14.9.2　答案　206
14.10　练习　207
第15章　JSON API　208
15.1　API　208
15.2　JSON　209
15.3　使用Node.js发送JSON数据　211
15.4　从JavaScript对象创建JSON　212
15.5　使用Node.js消费JSON数据　213
15.6　使用Node.js创建JSON API　216
15.6.1　在Express中以JSON发送数据　216
15.6.2　构建应用程序　219
15.7　小结　224
15.8　问与答　225
15.9　测验　225
15.9.1　问题　225
15.9.2　答案　225
15.10　练习　226
第5部分　探索Node.js API
第16章　进程模块　228
16.1　进程是什么　228
16.2　退出进程以及进程中的错误　230
16.3　进程与信号　230
16.4　向进程发送信号　231
16.5　使用Node.js创建脚本　233
16.6　给脚本传递参数　234
16.7　小结　236
16.8　问与答　236
16.9　测验　237
16.9.1　问题　237
16.9.2　答案　237
16.10　练习　238
第17章　子进程模块　239
17.1　什么是子进程　239
17.2　杀死子进程　241
17.3　与子进程通信　242
17.4　集群(Cluster)模块　244
17.5　小结　246
17.6　问与答　246
17.7　测验　246
17.7.1　问题　246
17.7.2　答案　246
17.8　练习　247
第18章　事件模块　248
18.1　理解事件　248
18.2　通过HTTP演示事件　251
18.3　用事件玩乒乓　254
18.4　动态编写事件侦听器程序　255
18.5　小结　258
18.6　问与答　258
18.7　测验　259
18.7.1　问题　259
18.7.2　答案　259
18.8　练习　259
第19章　缓冲区模块　260
19.1　二进制数据初步　260
19.2　从二进制到文本　261
19.3　二进制和Node.js　262
19.4　Node.js中的缓冲区是什么？　264
19.5　写入缓冲区　265
19.6　向缓冲区追加数据　266
19.7　复制缓冲区　267
19.8　修改缓冲区中的字符串　267
19.9　小结　268
19.10　问与答　268
19.11　测验　268
19.11.1　问题　268
19.11.2　答案　269
19.12　练习　269
第20章　流模块　270
20.1　流简介　270
20.2　可读流　272
20.3　可写流　275
20.4　通过管道连接流　276
20.5　流的MP3　277
20.6　小结　278
20.7　问与答　278
20.8　测验　279
20.8.1　问题　279
20.8.2　答案　279
20.9　练习　279
第6部分　进一步的Node.js开发
第21章　CoffeeScript　282
21.1　什么是CoffeeScript　282
21.2　安装与运行CoffeeScript　284
21.3　为什么要使用预编译器　285
21.4　CoffeeScript的功能　286
21.4.1　最小语法　286
21.4.2　条件和比较　287
21.4.3　循环　288
21.4.4　字符串　289
21.4.5　对象　290
21.4.6　类、继承和super　291
21.5　调试CoffeeScript　294
21.6　对CoffeeScript的反应　294
21.7　小结　295
21.8　问与答　295
21.9　测验　296
21.9.1　问题　296
21.9.2　答案　296
21.10　练习　296
第22章　创建Node.js模块　298
22.1　为什么创建模块　298
22.2　流行的Node.js模块　298
22.3　package.json文件　299
22.4　文件夹结构　301
22.5　开发和测试模块　302
22.6　添加可执行文件　304
22.7　使用面向对象或者基于原型的编程　305
22.8　通过GitHub共享代码　306
22.9　使用Travis CI　307
22.10　发布到npm　309
22.11　公开模块　310
22.12　小结　310
22.13　问与答　310
22.14　测验　311
22.14.1　问题　311
22.14.2　答案　311
22.15　练习　311
第23章　使用Connect创建中间件　312
23.1　什么是中间件　312
23.2　Connect中的中间件　313
23.3　使用中间件的访问控制　317
23.4　按IP地址限制访问　319
23.5　将用户强制到单个域上　321322
23.6　小结　323324
23.7　问与答　324
23.8　测验　324
23.8.1　问题　324
23.8.2　答案　324325
23.9　练习　324325
第24章　结合使用Backbone.js与Node.js　326
24.1　什么是Backbone.js　326
24.2　Backbone.js如何工作　327
24.3　一个简单的Backbone.js视图　332
24.4　使用Backbone.js创建记录　336
24.5　小结　337
24.6　问与答　337
24.7　测验　338
24.7.1　问题　338
24.7.2　答案　338
24.8　练习　338
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js入门经典
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js硬实战：115个核心技巧
第一部分Node 基础
1 入门. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
1.1 Node 入门3
1.1.1 为什么使用Node 3
1.1.2 Node 的主要特性5
1.2 构建一个Node 应用7
1.2.1 创建一个新的Node 项目8
1.2.2 创建一个流的类9
1.2.3 使用流10
1.2.4 编写测试11
1.3 总结13
2 全局变量：Node 环境. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
2.1 模块16
技巧1 安装与加载模块16
技巧2 创建与管理模块17
技巧3 加载一组相关的模块20
技巧4 使用路径22
2.2 标准I/O 以及console 对象23
技巧5 标准I/O 流的读写24
技巧6 打印日志消息25
技巧7 基准测试27
2.3 操作系统与命令行29
技巧8 获取平台信息29
技巧9 传递命令行参数30
技巧10 退出程序31
技巧11 响应信号量33
2.4 使用timer 延迟执行35
技巧12 通过setTimeout 延迟执行函数35
技巧13 通过定时器定时调用回调函数37
技巧14 安全的操作异步接口38
2.5 总结41
3 Buffers：使用比特、字节以及编码. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
3.1 修改数据编码44
技巧15 Buffer 转换为其他格式44
技巧16 使用Buffers 来修改字符串编码46
3.2 二进制文件转换为JSON 49
技巧17 使用Buffer 来转换原始数据49
3.3 创建你自己的二进制协议65
技巧18 创建自己的网络协议65
3.4 总结71
4 Events：玩转EventEmitter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72
4.1 基础用法73
技巧19 从EventEmitter 继承73
技巧20 混合EventEmitter 76
4.2 异常处理78
技巧21 管理异常78
技巧22 通过domains 管理异常80
4.3 高级模式82
技巧23 反射82
技巧24 探索EventEmitter 85
技巧25 组织事件名称87
4.4 第三方模块以及扩展88
技巧26 EventEmitter 的替代方案89
4.5 总结91
5 流：最强大和最容易误解的功能. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 93
5.1 流的介绍94
5.1.1 流的类型94
5.1.2 什么时候使用流94
5.1.3 历史95
5.1.4 第三方模块中的流96
5.1.5 流继承事件97
5.2 内置流98
技巧27 使用内置的流来实现静态web 服务器98
技巧28 流的错误处理101
5.3 第三方模块和流102
技巧29 使用流的第三方模块102
5.4 使用流基类105
技巧30 正确地从流的基类继承105
技巧31 实现一个可读流107
技巧32 实现一个可写流111
技巧33 使用双工流转换和接收数据113
技巧34 使用转换流解析数据114
5.5 高级模式和优化118
技巧35 流的优化118
技巧36 使用老的流API 121
技巧37 基于功能的流适配123
技巧38 测试流125
5.6 总结128
6 文件系统：通过异步和同步的方法处理文件. . . . . . . . . . . . . . . . . . . . . . . . . 129
6.1 fs 模块概述130
6.1.1 POSIX 文件系统包装器130
6.1.2 流132
6.1.3 批量文件操作133
6.1.4 文件监视133
6.1.5 同步的替代方案133
技巧39 读取配置文件134
技巧40 使用文件描述136
技巧41 使用文件锁137
技巧42 递归文件操作142
技巧43 编写文件数据库147
技巧44 监视文件以及文件夹151
6.2 总结154
7 网络：Node 真正的“Hello, World” . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
7.1 Node 中的网络156
7.1.1 网络技术157
7.1.2 Node 网络模块161
7.1.3 非阻塞网络和线程池162
7.2 TCP 客户端和服务端163
技巧45 创建TCP 服务端和客户端163
技巧46 使用客户端测试TCP 服务端165
技巧47 改进实时性低的应用168
7.3 UDP 客户端和服务端170
技巧48 通过UDP 传输文件170
技巧49 UDP 客户端服务应用174
7.4 HTTP 客户端和服务端179
技巧50 HTTP 服务器179
技巧51 重定向181
技巧52 HTTP 代理186
7.5 创建DNS 请求189
技巧53 创建DNS 请求189
7.6 加密191
技巧54 一个加密的TCP 服务器192
技巧55 加密的Web 服务器和客户端196
7.7 总结198
8 子进程：利用Node 整合外部应用程序. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200
8.1 执行外部应用程序202
技巧56 执行外部应用程序202
8.1.1 路径和Path 的环境变量203
8.1.2 执行外部程序时候出现的异常204
技巧57 流和外部应用程序205
8.1.3 外部应用程序的串联调用206
技巧58 在shell 中执行命令208
8.1.4 安全性和shell 命令执行209
技巧59 分离子进程210
8.1.5 父进程和子进程之间的I/O 处理211
8.1.6 引用计数和子进程213
8.2 执行Node 程序213
技巧60 执行Node 程序214
技巧61 Forking Node 模块216
技巧62 运行作业218
8.2.1 工作池220
8.2.2 使用池模块222
8.3 同步运行223
技巧63 同步子进程223
8.4 总结227
第二部分实践中的技巧
9 网络：构建精简的网络应用. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230
9.1 前端技术231
技巧64 快速的静态网站服务器231
技巧65 在Node 中使用DOM 236
技巧66 在浏览器端使用Node 模块238
9.2 服务端技术241
技巧67 Express 路由分离241
技巧68 自动重启服务器245
技巧69 配置web 应用248
技巧70 优雅地处理错误253
技巧71 RESTful web 应用257
技巧72 使用自定义的中间件267
技巧73 使用事件进行解耦273
技巧74 使用WebSockets 来处理sessions 276
技巧75 升级Express 3 到4 281
9.3 web 应用程序的测试285
技巧76 测试路由286
技巧77 为中间件注入创建seams 288
技巧78 测试依赖远程服务的应用291
9.4 全栈框架297
9.5 实时服务299
9.6 总结300
10 测试：编写健壮代码的关键. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 301
10.1 Node 测试的相关介绍303
10.2 使用断言编写简单的测试304
技巧79 用内置的模块编写测试305
技巧80 编写验证异常的测试308
技巧81 创建自定义的断言312
10.3 测试装置314
技巧82 使用一个测试装置组织测试314
10.4 测试框架318
技巧83 使用Mocha 编写测试319
技巧84 使用Mocha 测试web 应用323
技巧85 万能测试协议（TAP） 328
10.5 测试工具331
技巧86 持续集成331
技巧87 数据库装置335
10.6 扩展阅读343
10.7 总结343
11 调试：用于发现和解决问题. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 344
11.1 内省345
11.1.1 显式异常345
11.1.2 隐藏的异常346
11.1.3 错误事件346
11.1.4 错误参数347
技巧88 处理未捕获的异常348
技巧89 检查我们的Node 代码351
11.2 问题的调试352
技巧90 使用Node 内置的调试器352
技巧91 使用Node Inspector 359
技巧92 对Node 应用进行性能分析361
技巧93 内存泄漏的调试365
技巧94 使用REPL 来检测运行中的程序370
技巧95 跟踪系统调用377
11.3 总结381
12 生产环境中的Node：安全地部署应用程序. . . . . . . . . . . . . . . . . . . . . . . . . . 382
12.1 部署383
技巧96 将Node 程序部署到云端383
技巧97 使用Apache 和Ngnix 部署Node 程序389
技巧98 在80 端口上安全地运行Node 程序392
技巧99 保持Node 进程一直运行394
技巧100 在生产环境中使用WebSockets 396
12.2 Node 程序的缓存和扩展性402
技巧101 HTTP 缓存402
技巧102 为程序的路由和扩展使用Node 代理404
技巧103 使用集群保持程序的扩展性和弹性408
12.3 维护413
技巧104 包的优化413
技巧105 日志和日志服务415
12.4 更多关于Node 程序的扩展性和弹性的备注418
12.5 总结419
第三部分编写模块
13 编写模块，掌握Node 的所有. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 422
13.1 头脑风暴424
13.1.1 更快的斐波那契模块424
技巧106 计划编写我们的模块425
技巧107 验证我们模块的想法427
13.2 创建package.json 文件433
技巧108 创建package.json 文件433
技巧109 依赖处理436
技巧110 语义化版本号441
13.3 用户体验444
技巧111 添加可执行脚本444
技巧112 在本地测试模块446
技巧113 在不同版本Node 中测试448
13.4 发布451
技巧114 发布模块451
技巧115 使用私有模块453
13.5 总结455
A 社区. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 457
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js硬实战：115个核心技巧
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js高级编程
第Ⅰ部分 概述和安装
第1章 安装Node 3
1.1 在Windows上安装Node 4
1.2 在MAC OS X上安装Node 6
1.3 使用源代码安装Node 7
1.3.1 选择Node的版本 7
1.3.2 下载Node源代码 7
1.3.3 编译Node 8
1.3.4 安装Node 8
1.3.5 运行Node 8
1.4 安装和应用Node包管理器 9
1.5 本章小结 14
第2章 Node简介 15
2.1 事件驱动编程风格介绍 16
2.2 Node和JavaScript如何简化异步应用程序的编写 17
2.2.1 什么是闭包 17
2.2.2 闭包如何辅助异步编程 18
2.3 本章小结 19
第Ⅱ部分 Node核心API基础
第3章 加载模块 23
3.1 理解Node如何加载模块 24
3.2 导出模块 24
3.3 加载模块 25
3.3.1 加载核心模块 25
3.3.2 加载文件模块 26
3.3.3 加载文件夹模块 26
3.3.4 从node_modules文件夹加载 26
3.3.5 缓存模块 27
3.4 本章小结 28
第4章 应用缓冲区处理、编码和解码二进制数据 29
4.1 创建缓冲区 30
4.2 在缓冲区中获取和设置数据 30
4.3 切分缓冲区 31
4.4 复制缓冲区 32
4.5 缓冲区解码 32
4.6 本章小结 33
第5章 使用事件发射器模式简化事件绑定 35
5.1 理解标准回调模式 35
5.2 理解事件发射器模式 36
5.3 理解事件类型 37
5.4 应用事件发生器API 38
5.4.1 使用.addListener( )或.on( )绑定回调函数 38
5.4.2 绑定多个事件监听器 39
5.4.3 使用.removeListener( )从事件发射器中删除一个事件监听器 40
5.4.4 使用.once()使回调函数最多执行一次 40
5.4.5 使用.removeAllListeners()从事件发射器删除所有事件监听器 41
5.5 创建事件发射器 41
5.5.1 从Node事件发射器继承 41
5.5.2 发射事件 42
5.6 本章小结 42
第6章 使用定时器制定函数执行计划 45
6.1 使用setTimeout推迟函数执行 46
6.2 使用clearTimeout取消函数执行 46
6.3 制定和取消函数的重复执行计划 47
6.4 使用process.nextTick将函数执行推迟到下一轮事件循环 47
6.5 阻塞事件循环 48
6.6 退出事件循环 49
6.7 使用setTimeout代替setInterval强制函数串行执行 49
6.8 本章小结 50
第Ⅲ部分 文件、进程、流和网络
第7章 查询和读写文件 53
7.1 处理文件路径 54
7.1.1 规范化路径 54
7.1.2 连接路径 54
7.1.3 解析路径 55
7.1.4 查找两个绝对路径之间的相对路径 55
7.1.5 提取路径的组成部分 55
7.1.6 确定路径是否存在 56
7.2 fs模块简介 57
7.3 打开文件 58
7.4 读取文件 58
7.4.1 写入文件 59
7.4.2 关闭文件 60
7.5 本章小结 62
第8章 创建和控制外部进程 63
8.1 执行外部命令 63
8.2 生成子进程 68
8.2.1 创建子进程 68
8.2.2 监听子进程的输出数据 69
8.2.3 向子进程发送数据 69
8.2.4 当子进程退出时获得通知 71
8.3 向进程发送信号并终止进程 72
8.4 本章小结 73
第9章 读写数据流 75
9.1 使用可读流 76
9.1.1 等待数据 76
9.1.2 暂停与恢复流 76
9.1.3 了解流何时终止 77
9.2 使用可写流 77
9.2.1 将数据写入流 77
9.2.2 等待流被清空 78
9.3 考虑几个流的例子 78
9.3.1 创建文件系统流 78
9.3.2 理解网络流 80
9.4 避免慢客户端问题以及挽救服务器 80
9.4.1 理解慢客户端问题 80
9.4.2 避免慢客户端问题 81
9.4.3 应用stream.pipe()避免慢客户端问题与使用pipe()集成可读流和可写流 81
9.5 本章小结 82
第10章 构建TCP服务器 83
10.1 创建TCP服务器 83
10.1.1 应用套接字对象 85
10.1.2 理解空闲套接字 86
10.1.3 设置保持运行 87
10.1.4 应用延时或非延时 87
10.1.5 监听连接 88
10.1.6 关闭服务器 88
10.1.7 处理错误 88
10.2 构建一个简单的TCP聊天服务器 89
10.2.1 接受连接 89
10.2.2 从连接中读取数据 89
10.2.3 聚合所有客户端 90
10.2.4 广播数据 91
10.2.5 删除被关闭的连接 91
10.2.6 使用TCP聊天服务器 92
10.3 本章小结 93
第11章 构建HTTP服务器 95
11.1 理解http.ServerRequest对象 96
11.2 理解http.ServerResponse对象 98
11.2.1 写入响应头 98
11.2.2 修改或设置响应头 98
11.2.3 删除响应头 99
11.2.4 写入一块响应主体 99
11.3 以流的形式传送HTTP分块响应 99
11.3.1 传送文件 99
11.3.2 传送其他进程的输出 100
11.4 关闭服务器 100
11.5 示例1：构建提交静态文件的服务器 101
11.6 示例2：使用HTTP分块响应和定时器 102
11.7 本章小结 102
第12章 构建TCP客户端 103
12.1 连接服务器 104
12.2 发送和接收数据 104
12.3 终止连接 105
12.4 处理错误 106
12.5 创建命令行TCP客户端的示例 106
12.5.1 连接服务器 107
12.5.2 向服务器发送命令行 107
12.5.3 打印服务器消息 107
12.5.4 在连接终止时重新连接 108
12.5.5 关闭连接 110
12.5.6 前述内容综合 111
12.6 本章小结 112
第13章 创建HTTP请求 113
13.1 创建GET请求 113
13.2 使用其他HTTP动词 114
13.2.1 查看响应对象 115
13.2.2 获取响应主体 116
13.2.3 以流的方式传送响应主体 116
13.3 使用HTTP.Agent维护套接字池 116
13.4 应用第三方请求模块简化HTTP请求 118
13.4.1 安装和应用request模块 118
13.4.2 创建测试服务器 119
13.4.3 跟随重定向 121
13.4.4 设置请求选项 122
13.4.5 对请求体进行编码 125
13.4.6 流式传送 126
13.4.7 使用Cookie Jar 127
13.5 本章小结 127
第14章 使用用户数据报 129
14.1 理解用户数据报 129
14.2 理解用户数据报的使用 130
14.3 构建数据报服务器 130
14.3.1 监听消息 130
14.3.2 测试服务器 131
14.3.3 查看附加的消息信息 132
14.4 创建简单的数据报回送服务器 132
14.4.1 等待消息 132
14.4.2 向发送端发回消息 132
14.4.3 前述内容综合 133
14.5 构建数据报客户端 133
14.5.1 创建客户端 134
14.5.2 发送消息 134
14.5.3 关闭套接字 134
14.6 创建一个简单的数据报命令行客户端 134
14.6.1 读取命令行 135
14.6.2 向服务器发送数据 135
14.6.3 从服务器接收数据 135
14.6.4 前述内容综合 136
14.7 理解和使用数据报多播 136
14.7.1 接收多播消息 137
14.7.2 发送多播消息 137
14.7.3 理解数据报最大容量 138
14.8 本章小结 138
第15章 用TLS/SSL保证服务器的安全性 139
15.1 理解私钥和公钥 139
15.1.1 产生私钥 140
15.1.2 产生公钥 140
15.2 构建TLS服务器 140
15.2.1 初始化服务器 141
15.2.2 监听连接 141
15.2.3 从客户端读取数据 142
15.2.4 向客户端发送数据 142
15.2.5 终止连接 142
15.3 构建TLS客户端 142
15.3.1 初始化客户端 143
15.3.2 连接服务器 143
15.3.3 验证服务器证书 143
15.3.4 向服务器发送数据 144
15.3.5 从服务器读取数据 144
15.3.6 终止连接 144
15.4 创建几个示例 144
15.4.1 创建TLS聊天服务器 145
15.4.2 创建TLS命令行聊天客户端 146
15.4.3 验证客户端证书 147
15.5 本章小结 148
第16章 用HTTPS保证HTTP服务器的安全性 149
16.1 构建安全的HTTP服务器 149
16.1.1 设置服务器选项 150
16.1.2 监听连接 150
16.1.3 验证HTTPS客户端证书 151
16.2 创建HTTPS客户端 152
16.2.1 初始化客户端 152
16.2.2 创建请求 152
16.2.3 验证HTTPS服务器证书 153
16.3 本章小结 154
第Ⅳ部分 构建与调试模块及应用程序
第17章 测试模块及应用程序 157
17.1 应用测试运行工具 157
17.1.1 编写测试 158
17.1.2 运行测试 159
17.2 使用断言测试模块 159
17.2.1 使用断言模块 159
17.2.2 使用Node-Tap中的内置断言函数 161
17.3 测试异步模块 163
17.4 本章小结 166
第18章 调试模块及应用程序 167
18.1 使用console.log 167
18.2 使用Node内置调试器 169
18.3 使用Node检查器 173
18.4 本章小结 175
第19章 控制回调流程 177
19.1 理解飞去来器效应 177
19.2 通过声明函数避免飞去来器效应 179
19.3 使用ASYNC流程控制库 183
19.3.1 串行执行 184
19.3.2 并行执行 185
19.3.3 连续传递 186
19.3.4 排队 187
19.3.5 迭代 189
19.3.6 映射 190
19.3.7 规约 191
19.3.8 过滤 192
19.3.9 检测 193
19.4 本章小结 194
第Ⅴ部分 构建Web应用程序
第20章 构建和使用HTTP中间件 197
20.1 理解Connect HTTP中间件框架 198
20.2 构建自定义HTTP中间件 198
20.2.1 创建异步中间件 199
20.2.2 在中间件内部注册回调函数 201
20.2.3 在中间件内处理错误 202
20.3 使用捆绑在Connect中的HTTP中间件 206
20.3.1 记录请求 206
20.3.2 处理错误 208
20.3.3 提交静态文件 209
20.3.4 解析查询字符串 210
20.3.5 解析请求主体 211
20.3.6 解析Cookies 212
20.3.7 使用会话 213
20.3.8 其他可用的中间件 216
20.4 本章小结 216
第21章 用Express.js创建Web应用程序 217
21.1 初始化Express.js应用程序 218
21.2 在应用程序中设置中间件 220
21.3 路由请求 222
21.3.1 处理路由 222
21.3.2 使用会话 229
21.3.3 使用路由中间件 234
21.4 本章小结 238
第22章 使用Socket.IO创建通用的实时Web应用程序 241
22.1 理解WebSockets如何工作 242
22.2 使用Socket.IO创建WebSocket应用程序 243
22.2.1 在服务器上安装和运行Socket.IO 243
22.2.2 使用Socket.IO创建实时网络聊天应用程序 245
22.2.3 扩展聊天应用程序 250
22.2.4 检测连接断开 253
22.2.5 将用户分隔到聊天室中 255
22.2.6 使用名称空间 259
22.2.7 使用Redis分布运行服务器端应用程序 260
22.3 本章小结 263
第Ⅵ部分 连接数据库
第23章 使用node-mysql连接MySQL数据库 267
23.1 应用库与MySQL数据库进行连接和通信 267
23.2 向数据库添加数据时请记住安全性 269
23.3 高效读取数据 272
23.4 本章小结 276
第24章 使用Nano连接CouchDB数据库 277
24.1 安装Nano 278
24.2 连接和创建数据库 281
24.3 存储文档 285
24.4 创建和使用CouchDB视图 286
24.5 将文件附加到CouchDB文档上 299
24.6 本章小结 312
第25章 使用Mongoose连接MongoDB 数据库 313
25.1 安装Mongoose 315
25.2 理解Mongoose如何使用模型封装对数据库的访问 315
25.3 连接MongoDB数据库 316
25.4 定义模式 316
25.5 定义模型 316
25.5.1 使用验证器 326
25.5.2 使用修改器 332
25.5.3 使用取值器 333
25.5.4 使用虚拟属性 334
25.5.5 使用默认值 340
25.5.6 定义索引 341
25.5.7 使用DB Refs引用其他文档 343
25.5.8 定义实例方法 349
25.5.9 定义静态方法 350
25.6 本章小结 351
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js高级编程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js权威指南
前言
第1章　Node.js介绍 / 1
1.1　Node.js概述 / 2
1.1.1　使用Node.js能够解决什么问题 / 2
1.1.2　实现高性能服务器 / 2
1.1.3　非阻塞型I/O及事件环机制 / 2
1.1.4 　Node.js适合开发的应用程序 / 3
1.2　安装Node.js / 3
1.3　Node.js中的模块 / 4
1.4　一个简单的示例应用程序 / 6
1.5　小结 / 8
第2章　Node.js中的交互式运行环境——REPL / 9
2.1　REPL运行环境概述 / 10
2.2　在REPL运行环境中操作变量 / 10
2.3　在REPL运行环境中使用下划线字符 / 12
2.4　在REPL运行环境中直接运行函数 / 12
2.5　在REPL运行环境中定义并启动服务器 / 13
2.6　REPL运行环境中的上下文对象 / 13
2.7　REPL运行环境中的基础命令 / 14
2.8　小结 / 17
第3章　Node.js基础知识 / 18
3.1　Node.js中的控制台 / 19
3.1.1　console.log方法 / 19
3.1.2　console.error方法 / 20
3.1.3　console.dir方法 / 21
3.1.4　console.time方法与console.timeEnd方法 / 22
3.1.5　console.trace方法 / 22
3.1.6　console.assert方法 / 23
3.2　Node.js中的全局作用域及全局函数 / 23
3.2.1　Node.js中的全局作用域 / 23
3.2.2　setTimeout函数与clearTimeout函数 / 25
3.2.3　setInterval函数与clearInterval函数 / 25
3.2.4　定时器对象的unref方法与ref方法 / 27
3.2.5　与模块相关的全局函数及对象 / 28
3.3　__filename变量与__dirname变量 / 33
3.3.1　__filename变量 / 33
3.3.2　__dirname变量 / 34
3.4　事件处理机制及事件环机制 / 34
3.4.1　EventEmitter类 / 35
3.4.2　EventEmitter类的各个方法 / 35
3.4.3　获取指定事件的事件处理函数的数量 / 41
3.4.4　EventEmitter类自身所拥有的事件 / 42
3.4.5　事件环机制 / 44
3.5　在Node.js中使用调试器 / 45
3.5.1　在命令行窗口中使用调试器 / 45
3.5.2　观察变量值或表达式的执行结果 / 48
3.5.3　设置与取消断点 / 49
3.5.4　调试器中可以使用的其他实用命令 / 50
3.5.5　使用node-inspector调试工具 / 54
3.6　小结 / 55
第4章　模块与npm包管理工具 / 56
4.1　核心模块与文件模块 / 57
4.2　从模块外部访问模块内的成员 / 58
4.2.1　使用exports对象 / 58
4.2.2　将模块定义为类 / 58
4.2.3　为模块类定义类变量或类函数 / 61
4.3　组织与管理模块 / 61
4.3.1　从node_modules目录中加载模块 / 61
4.3.2　使用目录来管理模块 / 62
4.3.3　从全局目录中加载模块 / 62
4.4　模块对象的属性 / 63
4.5　包与npm包管理工具 / 65
4.5.1　Node.js中的包 / 65
4.5.2　npm包管理工具 / 67
4.6　小结 / 68
第5章　使用Buffer类处理二进制数据 / 69
5.1　创建Buffer对象 / 70
5.2　字符串的长度与缓存区的长度 / 72
5.3　Buffer对象与字符串对象之间的相互转换 / 74
5.3.1　Buffer对象的toString方法 / 74
5.3.2　Buffer对象的write方法 / 75
5.3.3　StringDecoder对象 / 75
5.4　Buffer对象与数值对象之间的相互转换 / 77
5.5　Buffer对象与JSON对象之间的相互转换 / 79
5.6　复制缓存数据 / 80
5.7　Buffer类的类方法 / 81
5.7.1　isBuffer方法 / 81
5.7.2　byteLength方法 / 81
5.7.3　concat方法 / 82
5.7.4　isEncoding方法 / 83
5.8　小结 / 83
第6章　在Node.js中操作文件系统 / 84
6.1　同步方法与异步方法 / 85
6.2　对文件执行读写操作 / 86
6.2.1　文件的完整读写 / 86
6.2.2　从指定位置处开始读写文件 / 91
6.3　创建与读取目录 / 97
6.3.1　创建目录 / 97
6.3.2　读取目录 / 98
6.4　查看与修改文件或目录的信息 / 99
6.4.1　查看文件或目录的信息 / 99
6.4.2　检查文件或目录是否存在 / 101
6.4.3　获取文件或目录的绝对路径 / 102
6.4.4　修改文件访问时间及修改时间 / 103
6.4.5　修改文件或目录的读写权限 / 104
6.5　可以对文件或目录执行的其他操作 / 105
6.5.1　移动文件或目录 / 105
6.5.2　创建与删除文件的硬链接 / 106
6.5.3　创建与查看符号链接 / 107
6.5.4　截断文件 / 110
6.5.5　删除空目录 / 111
6.5.6　监视文件或目录 / 111
6.6　使用文件流 / 116
6.6.1　流的基本概念 / 116
6.6.2　使用ReadStream对象读取文件 / 119
6.6.3　使用WriteStream对象写入文件 / 121
6.7　对路径进行操作 / 127
6.8　小结 / 134
第7章　实现基于TCP与UDP的数据通信 / 135
7.1　使用net模块实现基于TCP的数据通信 / 136
7.1.1　创建TCP服务器 / 136
7.1.2　socket端口对象 / 142
7.1.3　创建TCP客户端 / 151
7.1.4　net模块中的类方法 / 164
7.2　使用dgram模块实现基于UDP的数据通信 / 165
7.2.1　创建UDP服务器与客户端 / 165
7.2.2　实现广播与组播 / 172
7.3　小结 / 175
第8章　创建HTTP与HTTPS服务器及客户端 / 176
8.1　HTTP服务器 / 177
8.1.1　创建HTTP服务器 / 177
8.1.2　获取客户端请求信息 / 182
8.1.3　转换URL字符串与查询字符串 / 184
8.1.4　发送服务器端响应流 / 191
8.2　HTTP客户端 / 202
8.2.1　向其他网站请求数据 / 202
8.2.2　向本地服务器请求数据 / 208
8.2.3　制作代理服务器 / 210
8.3　创建HTTPS服务器与客户端 / 211
8.3.1　创建HTTPS服务器 / 211
8.3.2　创建HTTPS客户端 / 216
8.4　小结 / 223
第9章　进程与子进程 / 224
9.1　Node.js中的进程 / 225
9.1.1　进程对象的属性 / 225
9.1.2　进程对象的方法与事件 / 227
9.2　创建多进程应用程序 / 235
9.2.1　使用spawn方法开启子进程 / 236
9.2.2　使用fork方法开启子进程 / 243
9.2.3　使用exec方法开启子进程 / 250
9.2.4　使用execFile方法开启子进程 / 253
9.3　在多个子进程中运行Node.js应用程序 / 254
9.3.1　使用fork方法创建worker对象 / 254
9.3.2　worker对象的方法与事件 / 262
9.4　小结 / 270
第10章　Node.js中的错误处理与断言处理 / 271
10.1　使用domain模块处理错误 / 272
10.1.1　domain模块概述 / 272
10.1.2　创建并使用Domain对象 / 274
10.1.3　隐式绑定与显式绑定 / 276
10.1.4　绑定回调函数与拦截回调函数 / 279
10.1.5　domain堆栈的弹出与推入 / 280
10.1.6　Domain对象的销毁 / 286
10.2　Node.js中的断言处理 / 286
10.2.1　equal方法与notEqual方法 / 287
10.2.2　strictEqual方法与notStrictEqual方法 / 288
10.2.3　assert方法与ok方法 / 288
10.2.4　deepEqual方法与notDeepEqual方法 / 289
10.2.5　throws方法与doesNotThrow方法 / 290
10.3　小结 / 293
第11章　加密与压缩 / 294
11.1　加密与解密处理 / 295
11.1.1　crypto模块概述 / 295
11.1.2　散列算法 / 296
11.1.3　HMAC算法 / 297
11.1.4　公钥加密 / 298
11.2　压缩与解压缩处理 / 305
11.2.1　创建各种用于压缩及解压缩的对象 / 305
11.2.2　zlib模块中的各种方法 / 310
11.3　小结 / 311
第12章　Node.js中的其他模块 / 312
12.1　使用dns模块解析域名 / 313
12.1.1　使用resolve方法将域名解析为DNS记录 / 313
12.1.2　使用lookup方法查询IP地址 / 315
12.1.3　使用reverse方法反向解析IP地址 / 316
12.1.4　dns模块中的各种错误代码 / 317
12.2　使用punycode模块转换punycode编码 / 318
12.3　使用os模块获取操作系统信息 / 320
12.4　使用readline模块逐行读取流数据 / 323
12.4.1　创建 Interface对象 / 323
12.4.2　Interface对象所拥有的各种方法与事件 / 327
12.5　使用util模块中提供的一些实用方法 / 335
12.6　使用vm模块改变脚本运行环境 / 346
12.6.1　在独立环境中运行JavaScript代码 / 346
12.6.2　创建并使用Script对象 / 350
12.7　自定义REPL运行环境 / 352
12.8　小结 / 358
第13章　数据库访问 / 359
13.1　在MongoDB数据库中存取数据 / 360
13.1.1　MongoDB概述 / 360
13.1.2　安装MongoDB数据库 / 360
13.1.3　安装MongoDB包 / 361
13.1.4　连接MongoDB数据库 / 361
13.1.5　在MongoDB数据库中插入数据 / 364
13.1.6　在MongoDB数据库中查询数据 / 369
13.1.7　在MongoDB数据库中更新与删除数据 / 384
13.1.8　使用Mongoose类库 / 393
13.2　在MySQL数据库中存取数据 / 395
13.2.1　建立连接与关闭连接 / 395
13.2.2　执行数据的基本处理 / 399
13.2.3　执行存储过程 / 404
13.2.4　执行多表结合查询 / 406
13.2.5　以数据流的方式处理查询数据 / 409
13.2.6　创建连接池 / 411
13.3　小结 / 413
第14章　使用Express构建Web应用程序 / 414
14.1　Express概述 / 415
14.1.1　安装Express / 415
14.1.2　使用Express开发一个简单的示例应用程序 / 415
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js权威指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js 设计模式（第 2 版）
第1 章欢迎来到Node.js 平台 1
Node.js 的哲学思想2
小核心2
小模块2
小接触面3
简单和实用3
认识Node.js 6 和ES2015 4
let 和const 关键字5
箭头函数6
类语法8
增强的对象字面量10
Map 和Set 集合11
WeakMap 和WeakSet 集合13
模板字面量14
其他ES2015 特性14
Reactor 模式15
I/O 是缓慢的15
阻塞I/O 15
非阻塞I/O 16
事件多路分解器17
Reactor 模式简介19
Node.js-libuv 的非阻塞I/O 引擎20
Node.js 的秘诀21
总结21
第2 章Node.js 基础设计模式  23
回调模式24
CPS（Continuation Passing Style） 24
同步或异步26
Node.js 回调约定31
模块系统及其模式34
揭示模块模式34
Node.js 模块解释35
模块定义模式42
观察者模式49
EventEmitter 类49
创建和使用EventEmitter 50
传播错误51
使任何对象可观察51
同步和异步事件53
EventEmitter 与回调54
组合回调和EventEmitter 55
总结55
第3 章异步控制流模式之回调函数  56
异步编程的困难56
创建一个简单的网络蜘蛛57
回调地狱59
使用纯JavaScript 60
回调规则60
应用回调规则61
顺序执行63
并行执行68
有限制的并行执行73
async 库77
顺序执行78
并行执行81
有限制的并行执行81
总结83
第4 章异步控制流模式之ES2015+   84
promise 84
什么是promise 85
Promises/A+ 实现87
Node.js 风格函数的promise 化88
顺序执行90
并行执行93
有限制的并行执行93
在公共API 中暴露callback 和promise 95
generator 97
generator 基础97
generator 的异步控制流100
顺序执行104
并行执行106
有限制的并行执行108
使用Babel 的async await 111
安装和运行Babel 112
比较113
总结114
第5 章流编程  115
流的重要性115
缓冲和流116
空间效率117
时间效率118
组合性121
开始学习流122
流的分类122
可读流123
可写流127
双向流(Duplex stream) 132
变换流132
使用管道拼接流135
使用流处理异步流程137
顺序执行138
无序并行执行139
无序有限制的并行执行143
顺序并行执行145
管道模式146
组合流146
复制流149
合并流150
复用和分解152
总结159
第6 章设计模式  160
工厂模式161
创建对象的通用接口161
一种封装的机制162
构建一个简单的代码分析器164
可组合的工厂函数166
扩展169
揭示构造函数170
只读事件触发器171
扩展172
代理模式173
实现代理模式的方法174
不同方法的比较176
创建日志记录的写入流176
生态系统中的代理模式——函数钩子与面向行为编程(AOP) 178
ES2015 中的Proxy 对象178
扩展180
装饰者模式(Decorator) 180
实现装饰者模式的方法181
装饰一个LevelUP 数据库182
扩展185
适配器模式(Adapter) 185
通过文件系统API 来使用LevelUP 数据库186
扩展189
策略模式(Strategy) 189
支持多种格式的配置对象190
扩展193
状态模式193
实现一个基本的自动防故障套接字194
模板模式(Template) 199
配置管理器模板199
扩展201
中间件(Middleware) 202
Express 中的中间件202
设计模式中的中间件203
为ØMQ 创建中间件框架204
在Koa 中使用生成器的中间件210
命令模式(Command) 213
灵活的设计模式214
总结218
第7 章连接模块  220
模块和依赖221
Node.js 中最常见的依赖221
内聚和耦合222
有状态的模块222
连接模块模式224
硬编码依赖224
依赖注入229
服务定位器234
依赖注入容器239
连接插件243
插件作为包243
扩展点245
插件控制与应用程序控制的扩展245
实现注销插件248
总结256
第8 章通用JavaScript 的Web 应用程序  257
与浏览器端共享代码258
共享模块258
Webpack 简介262
Webpack 的魔力263
Webpack 的优点264
使用ES2015 和Webpack 265
跨平台开发基础267
运行时代码分支268
构建时代码分支269
模块交换271
用于跨平台开发的设计模式273
React 介绍274
第一个React 组件275
JSX 是什么277
配置Webpack 以实现JSX 转换279
在浏览器中渲染280
React 路由库281
创建通用JavaScript 应用程序286
创建可用的组件287
服务端渲染289
通用渲染和路由293
通用数据检索294
总结304
第9 章高级异步编程技巧  305
需要异步初始化的模块305
规范解决方案306
预初始化队列307
题外话311
异步批处理和缓存312
实现没有缓存或批处理的服务器312
异步请求批处理314
异步请求缓存316
使用promise 进行批处理和缓存319
运行CPU 绑定的任务322
解决子集和问题322
交叉使用setImmediate 325
使用多进程328
总结335
第10 章扩展与架构模式  336
应用程序扩展介绍337
扩展Node.js 应用程序337
可扩展性的三个维度337
克隆和负载均衡339
集群模块340
处理有状态通信348
使用反向代理进行扩展350
使用服务注册表354
对等负载均衡360
分解复杂的应用程序362
单体式架构362
微服务架构364
微服务架构中的集成模式367
总结372
第11 章消息传递与集成模式  374
消息系统的基础375
单向和请求/应答模式375
消息类型376
异步消息和队列377
对等或基于代理的消息378
发布/订阅模式379
构建简约的实时聊天应用程序380
使用Redis 作为消息代理383
使用ØMQ 对等发布/订阅385
持久订阅者389
管道和任务分配模式396
ØMQ 扇出/扇入模式397
使用AMQP 实现管道和竞争消费者模式401
请求/应答模式406
关联标识符406
返回地址410
总结415
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js 设计模式（第 2 版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js项目实践
第1 章 安装Node.js 及相关要点 .............. 1
安装Node.js 和NPM ................................. 1
一键安装 ................................................ 2
通过HomeBrew 或MacPorts 安装 ........ 3
通过tar 文件安装 .................................. 4
无须sudo 授权进行安装 ........................ 4
通过Git Repo 进行安装 ......................... 5
通过Nave 进行多版本安装 ................... 5
通过NVM 进行多版本安装................... 6
其他的多版本系统 .................................. 6
检查安装 ................................................ 7
Node.js 控制台（REPL） ....................... 7
加载Node.js 脚本....................................... 9
Node.js 的基础和语法 ............................... 9
弱类型 .................................................... 9
Buffer——Node.js 特殊数据类型..........10
对象字面量 ...........................................10
函数 ....................................................... 11
数组 .......................................................12
原型特性 ...............................................12
编码规范 ...............................................13
Node.js 的全局变量和保留字 ................14
__dirname 与process.cwd 的对比 .........17
浏览器API 输助工具 ............................17
Node.js 的核心模块 ...............................18
便捷的Node.js 工具 ..............................20
在Node.js 中读写文件 ..........................20
Node.js 中的数据流 ...............................21
使用NPM 安装Node.js 模块 ................21
优化Node.js 中的回调函数...................22
使用Node.js 的HTTP 模块来创建一个简单服务器 ...................23
调试Node.js 程序......................................24
核心Node.js 调试 ..................................24
使用Node Inspector 来调试 ..................25
Node.js 集成开发环境和代码编辑器 ...28
监听文件变化 .............................................30
小结 ...............................................................31
第2 章 使用Express.js 4 创建Node.js 的Web 应用程序 ...................32
什么是Express.js .......................................32
Express.js 是如何工作的 ..........................35
Express.js 的安装 .......................................36
Express.js 的版本 ..................................36
Express.js 生成器 ..................................37
本地Express.js ......................................38
Express.js 脚手架 .......................................40
Express.js 命令行界面 ...........................41
Express.js 中的路由 ...............................43
Express.js 的核心——中间件 ................44
一个Express.js 应用的配置...................45
Jade 就是Express.js/Node.js 的Haml ...45
脚手架总结 ...........................................45
博客项目概述 .............................................46
提交数据 ...............................................47
Express.js 4 中的Hello World 例子 .......48
创建文件夹 ...........................................49
NPM 初始化和package.json .................50
依赖声明：npm install ...........................50
app.js 文件 .............................................51
Jade 模板 ...............................................55
运行Hello World 应用 ...........................56
小结 ...............................................................56
第3 章 Node.js 基于Mocha 的测试驱动开发和行为驱动开发 ......................57
安装与理解Mocha ...................................58
理解Mocha 的hook 机制 ......................60
用assert 进行TDD ...................................61
断言库Chai ...........................................63
用Expect.js 进行BDD .............................64
Expect.js 的语法 ....................................65
项目：为博客开发一个BDD 测试 ......65
将配置参数写入Makefile .....................68
小结 ...............................................................69
第4 章 模板引擎：Jade 和Handlebars 70
Jade 的语法和特性 ...................................70
标签 .......................................................71
变量/数据 ..............................................71
属性 .......................................................72
字面量 ...................................................73
文本 .......................................................73
Script 和 Style 块 ..................................74
JavaScript 代码 ......................................74
注释 .......................................................75
if 语句 ....................................................75
each 语句 ...............................................75
过滤器 ...................................................76
读取变量 ...............................................76
case ........................................................76
函数mixin .............................................77
include ....................................................78
extend .....................................................78
单独使用Jade .............................................79
Handlebars 的语法 ....................................83
变量 .......................................................83
each 语句 ...............................................83
非转义输出 ...........................................84
if 语句 ....................................................85
unless .....................................................85
with ........................................................86
注释 .......................................................87
自定义 Helpers .....................................87
Include ...................................................88
单独使用Handlebars .................................88
Express.js 4 中Jade 和Handlebars 的用法 ............................................91
Jade 和 Express.js .................................92
Handlebars 和Express.js ........................92
项目：给博客添加Jade 模板 .................93
layout.jade ..............................................94
index.jade ...............................................96
article.jade ..............................................97
login.jade ................................................98
post.jade .................................................99
admin.jade ............................................ 100
小结 ............................................................. 101
第5 章 MongoDB、Mongoskin 特性 .... 102
简单且正确地安装MongoDB .............. 103
如何运行Mongo 服务 ............................ 104
用控制台操作Mongo ............................. 105
MongoDB shell 命令介绍 ...................... 106
Node.js 版原生MongoDB 驱动示例 .. 107
Mongoskin 的主要方法介绍 ................. 111
项目：用Mongoskin 把博客数据存储到MongoDB ............................ 112
项目：在MongoDB 中添加seed 数据 ......................................... 112
项目：Mocha 测试 ............................... 113
项目：添加持久连接 ........................... 115
运行App .............................................. 126
小结 ............................................................. 127
第6 章 在Node.js 应用中使用session 和OAuth 进行用户认证和授权 ............... 128
使用Express.js 中间件权限管理 ......... 128
基于token 的用户认证 ........................... 129
基于session 的用户认证 ........................ 130
项目实践：为博客增加邮箱和密码登录功能 .......................................... 132
session 中间件 ..................................... 132
博客中的权限管理 ............................... 133
博客中的用户授权 ............................... 136
运行应用 ............................................. 138
Node.js OAuth ........................................... 138
使用Node.js OAuth 实现Twitter OAuth 2.0 的示例 ................................ 139
Everyauth ............................................. 140
项目实践：为博客增加Twitter OAuth 1.0 第三方登录（使用Everyauth 实现） .......... 141
添加“使用Twitter 账户登录”链接 .. 142
配置EveryauthTwitter 模块 ................. 142
小结 ............................................................. 148
第7 章 使用ORM 类库Mongoose 提升你的Node.js 数据 ......................... 149
安装Mongoose ......................................... 150
用独立的Mongoose 脚本建立数据库连接 .................................. 150
Mongoose 的原型 .................................... 152
使用钩子保持代码的逻辑清晰 ............ 154
自定义静态方法和实例方法 ................ 155
Mongoose 模型 ....................................... 155
使用population 建立关系和连接 ........ 158
嵌套的文档 ............................................... 160
虚拟字段 .................................................... 161
修改原型的行为 ...................................... 162
Express.js + Mongoose =真正的MVC ..................................... 164
小结 ................................. 175
第8 章 使用Express.js 和Hapi 构建Node.js REST API 服务 ....................... 176
RESTful API 基础 ................................... 177
项目依赖 .................................................... 179
使用Mocha 和Superagent 进行测试 . 180
使用Express 和Mongoskin 实现REST API 服务器 ...................................... 185
重构：使用Hapi 搭建REST API 服务器 .............................................. 192
小结 ............................................................. 199
第9 章 WebSocket、Socket.IO 和DerbyJS 的实时应用程序 .................... 200
什么是WebSocket ................................... 200
用ws 模块的例子介绍本地WebSocket 和Node.js .............................. 201
浏览器WebSocket 的实现 ................... 201
用ws 模块实现Node.js 服务器 .......... 202
Socket.IO 和Express.js 的例子 ............ 204
用DerbyJS、Express.js 和MongoDB 搭建一个在线协作的代码编辑器例子 ........ 209
项目依赖和package.json ..................... 210
服务器端代码 ...................................... 211
DerbyJS 应用程序 ................................ 213
DerbyJS 视图 ....................................... 215
编辑器Tryout ...................................... 217
小结 ............................................................. 218
第10 章 为Node.js 应用上线做准备 ..... 219
环境变量 .................................................... 219
生产环境下的Express.js ........................ 220
生产环境下的Socket.IO ........................ 222
错误处理 ................................ 223
错误处理工具Node.js domains ............ 225
使用Cluster 处理多线程 ........................ 229
使用Cluster2 处理多线程 ..................... 232
事件日志和监控 ...................................... 233
监控 ..................................................... 233
生产环境下的REPL ............................ 235
Winston ................................................ 236
使用Papertrail 应用来管理日志 ......... 237
使用Grunt 处理任务 ............................... 237
使用Git 来做版本控制和发布代码 ... 241
安装Git ............................................... 242
生成SSH 密钥 .................................... 242
创建本地Git 仓库................................ 245
将本地仓库推送到GitHub .................. 245
在云上使用TravisCI 运行测试用例 .. 246
TravisCI 配置 ...................................... 247
小结 ............................................................. 248
第11 章 部署Node.js 应用 ....................... 249
部署到Heroku .......................................... 249
部署到Amazon 网络服务 ..................... 255
使用forever、Upstart 和init.d 保持Node.js 持续运行 ................ 259
forever .................................................. 259
Upstart .................................................. 260
init.d ..................................................... 262
尽可能使用Nginx 提供静态资源 ....... 264
使用Varnish 缓存 .................................... 266
小结 ............................................................. 268
第12 章 Node.js 模块发布和参与开源 . 269
推荐的目录结构 ...................................... 270
所需模式 .................................................... 270
package.json............................................... 273
发布到NPM ............................................. 274
锁定版本 .................................................... 274
小结 ............................................................. 275
结束语 ......................................................... 275
进阶阅读 .................................................... 276
勘误和联系方式 ...................................... 276
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js项目实践
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js开发实战详解
第1章Node.js基础知识
1.1概述
1.1.1Node.js是什么
1.1.2Node.js带来了什么
1.2Node.js配置开发
1.2.1Windows配置
1.2.2Linux配置
1.2.3HelloWorld
1.2.4常见问题
1.3异步编程
1.3.1同步调用和异步调用
1.3.2回调和异步调用
1.3.3获取异步函数的执行结果
1.4本章实践
1.5本章小结
第2章模块和NPM
2.1什么是模块
2.1.1模块的概念
2.1.2Node.js如何处理模块
2.1.3Node.js实现Web解析DNS
2.1.4Node.js重构DNS解析网站
2.1.5exports和module.eXports
2.2NPM简介
2.2.1NPM和配置
2.2.2Express框架
2.2.3jade模板
2.2.4forever模块
2.2.5socket.io模块
2.2.6request模块
2.2.7Formidable模块
2.2.8NPM模块开发指南
2.3Node.js设计模式
2.3.1模块与类
2.3.2Node.js中的继承
2.3.3单例模式
2.3.4适配器模式
2.3.5装饰模式
2.3.6工厂模式
2.4本章实践
2.5本章小结
第3章Node.js的Web应用
3.1HTTP服务器
3.1.1简单的HTTP服务器
3.1.2路由处理
3.1.3GET和POST
3.1.4GET方法实例
3.1.5POST方法实例
3.1.6HTTP和HTTPS模块介绍
3.2Node.js静态资源管理
3.2.1为什么需要静态资源管理
3.2.2Node.js实现简单静态资源管理
3.2.3静态资源库设计
3.2.4静态文件的缓存控制
3.3文件处理
3.3.1FileSystem模块介绍
3.3.2图片和文件上传
3.3.3jade模板实现图片上传展示功能
3.3.4上传图片存在的问题
3.3.5文件读写
3.4Cookie和Session
3.4.1Cookie和Session
3.4.2Session模块实现
3.4.3Session模块的应用
3.5Crypto模块加密
3.5.1Crypto介绍
3.5.2Web数据密码的安全
3.5.3简单加密模块设计
3.6Node.js+INginx
3.6.1Nginx概述
3.6.2Nginx的配置安装
3.6.3如何构建
3.7 文字直播实例
3.7.1 系统分析
3.7.2 重要模块介绍
3.8 扩展阅读
3.9 本章实践
3.10 本章小结
第4章 Node.js高级编程
4.1 构建UDP服务器
4.1.1 UDP 模块概述
4.1.2 UDP Server构建
4.2 UDP服务器应用
4.2.1 应用分析介绍
4.2.2 UDP Server端（图片处理服务器）实现
4.2.3 UDP Client端（Web Server）
4.2.4 Jade页面实现
4.2.5 应用体验
4.3 Node.js与PHP合作
4.3.1 UDP方式
4.3.2 脚本执行
4.3.3 HTTP方式
4.3.4 三种方式的比较
4.4 本章实践
4.5 本章小结
第5章 深入Node.js
5.1 Node.js的相关实现机制
5.2 Node.js原生扩展
5.2.1 Node.js扩展开发基础V8
5.2.2 Node.js插件开发介绍
5.3 Node.js异步扩展开发与应用
5.4 本章实践
5.5 本章小结
第6章 Node.js编码习惯
6.1 Node.js规范
6.1.1 变量和函数命名规范
6.1.2 模块编写规范
6.1.3 注释
6.2 Node.js异步编程规范
6.2.1 Node.js的异步实现
6.2.2 异步函数的调用
6.2.3 Node.js异步回调深度
6.2.4 解决异步编程带来的麻烦
6.3 异常逻辑的处理
6.3.1 require模块对象不存在异常
6.3.2 对象中不存在方法或者属性时的异常
6.3.3 异步执行的for循环异常
6.3.4 利用异常处理办法优化路由
6.3.5 异常情况汇总
6.4 本章实践
6.5 本章小结
第7章 Node.js与数据库
7.1 两种数据库介绍
7.1.1 MySQL介绍
7.1.2 MongoDB模块介绍
7.2 Node.js与MySQL
7.2.1 MySQL安装配置应用
7.2.2 MySQL数据库接口设计
7.2.3 数据库连接
7.2.4 数据库插入数据
7.2.5 查询一条数据记录
7.2.6 修改数据库记录
7.2.7 删除数据库记录
7.2.8 数据条件查询
7.3 Node.js与MongoDB
7.3.1 MongoDB的安装以及工具介绍
7.3.2 MongOD的启动运行方法
7.3.3 MongoDB的启动运行
7.3.4 MongoDB数据库接口设计
7.3.5 数据插入
7.3.6 数据修改
7.3.7 查询一条数据
7.3.8 删除数据
7.3.9 查询数据
7.4 MySQL与MongoDB性能
7.4.1 测试工具及测试逻辑
7.4.2 MySQL性能测试代码
7.4.3 MongoDB性能测试代码
7.4.4 性能测试数据分析
7.5 本章实践
7.6 本章小结
第8章 MyWeb框架介绍
8.1 MyWeb框架介绍
8.1.1 MyWeb框架涉及的应用
8.1.2 MyWeb框架应用模块
8.2 MyWeb源码架构
8.2.1 框架MVC设计图
8.2.2 框架文件结构
8.2.3 扩展阅读之更快地了解新项目
8.3 框架源码分析
8.3.1 框架入口文件模块
8.3.2 路由处理模块
8.3.3 Model层基类
8.3.4 Controller层基类
8.4 本章实践
8.5 本章小结
第9章 框架应用MyChat
9.1 编码前的准备
9.1.1 应用分析
9.1.2 应用模块
9.1.3 功能模块设计
9.2 系统的编码开发
9.2.1 Model层
9.2.2 Controller层
9.2.3 View层
9.3 项目总结
9.3.1 forever启动运行项目
9.3.2 系统应用体验
9.3.3 系统开发总结
9.4 扩展阅读之MyWeb 2.0的介绍
9.5 本章实践
9.6 本章小结
第10章 Node.js实例应用
10.1 实时聊天对话
10.1.1 系统设计
10.1.2 系统的模块设计
10.1.3 系统编码实现
10.2 联网中国象棋游戏
10.2.1 系统设计
10.2.2 系统的模块设计
10.2.3 系统编码实现
10.2.4 系统体验
10.3 本章小结
第11章 Node.js实用工具
11.1 日志模块工具
11.1.1 日志模块介绍
11.1.2 日志模块实现
11.1.3 日志模块应用
11.2 配置文件读取模块
11.2.1 配置文件解析模块介绍
11.2.2 配置文件解析模块实现
11.3 curl模块
11.3.1 curl模块介绍
11.3.2 curl模块实现
11.3.3 curl模块应用
11.4 crontab模块
11.4.1 crontab模块介绍
11.4.2 crontab模块设计实现
11.4.3 crontab模块应用
11.5 forever运行脚本
11.5.1 forever运行脚本介绍
11.5.2 forever运行脚本实现
11.5.3 forever运行脚本应用
11.6 xml模块的应用
11.6.1 xml解析模块介绍
11.6.2 xml模块设计实现
11.6.3 xml模块应用
11.7 邮件发送模块应用
11.7.1 邮件模块介绍
11.7.2 邮件模块设计实现
11.7.3 邮件模块应用
11.8 本章小结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js开发实战详解
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Google御用網頁語言Node.js
前言
第1章　Node.js簡介
1.1 Node.js 是什麼
1.1.1 Node.js 與 JavaScript
1.2 Node.js 能做什麼
1.3 非同步式 I/O 與事件驅動
1.4 Node.js 的效能
1.4.1 Node.js 架構簡介
1.4.2 Node.js 與 PHP + Nginx
1.5 JavaScript 簡史
1.5.1 Netscape 與 LiveScript
1.5.2 Java 與 Javascript
1.5.3 微軟的加入 — JScript
1.5.4 標準化 — ECMAScript
1.5.5 瀏覽器相容性問題
1.5.6 引擎效率革命和 JavaScript 的未來
1.6 CommonJS
1.6.1 服務端 JavaScript 的重生
1.6.2 CommonJS 標準與實現
1.7 參考資料
第2章　安裝和設定Node.js
2.1 安裝前的準備
2.2 快速安裝
2.2.1 Microsoft Windows系統上安裝Node.js
2.2.2 Linux 發行版本上安裝Node.js
2.2.3 Mac OS X上安裝Node.js
2.3 編譯原始程式碼
2.3.1 在 POSIX 系統中編譯
2.3.2 在 Windows系統中編譯
2.4 安裝Node 套件管理員
2.5 安裝多版本管理員
2.6 參考資料
第3章　Node.js 快速入門
3.1 開始用 Node.js 程式設計
3.1.1 Hello World
3.1.2 Node.js 命令列工具
3.1.3 建立 HTTP 伺服器
3.2 非同步式 I/O 與事件式程式設計
3.2.1 阻塞與執行緒
3.2.2 回呼函數
3.2.3 事件
3.3 模組和套件
3.3.1 什麼是模組
3.3.2 建立及載入模組
3.3.3 建立套件
3.3.4 Node.js 套件管理員
3.4 偵錯
3.4.1 命令列偵錯
3.4.2 遠端偵錯
3.4.3 使用 Eclipse 偵錯 Node.js
3.4.4 使用 node-inspector 偵錯 Node.js
3.5 參考資料
第4章　Node.js 核心模組
4.1 全域物件
4.1.1 全域物件與全域變數
4.1.2 process
4.1.3 console
4.2 常用工具 util
4.2.1 util.inherits
4.2.2 util.inspect
4.3 事件驅動 events
4.3.1 事件發射器
4.3.2 error 事件
4.3.3 繼承 EventEmitter
4.4 檔案系統 fs
4.4.1 fs.readFile
4.4.2 fs.readFileSync
4.4.3 fs.open
4.4.4 fs.read
4.5 HTTP 伺服器與用戶端
4.5.1 HTTP 伺服器
4.5.2 HTTP 用戶端
4.6 參考資料
第5章　使用Node.js進行Web開發
5.1 準備工作
5.1.1 使用 http 模組
5.1.2 Express 框架
5.2 快速開始
5.2.1 安裝 Express
5.2.2 建立專案
5.2.3 啟動伺服器
5.2.4 專案的結構
5.3 路由控制
5.3.1 工作原理
5.3.2 建立路由規則
5.3.3 路徑比對
5.3.4 REST 風格的路由規則
5.3.5 控制權轉移
5.4 模版引擎
5.4.1 什麼是模版引擎
5.4.2 使用模版引擎
5.4.3 頁面設定
5.4.4 部分視圖
5.4.5 視圖幫手
5.5 建立微博網站
5.5.1 功能分析
5.5.2 路由規劃
5.5.3 介面設計
5.5.4 使用 Bootstrap
5.6 使用者註冊和登入
5.6.1 存取資料庫
5.6.2 階段支援
5.6.3 註冊和登入
5.6.4 頁面許可權控制
5.7 發表微博
5.7.1 微博模型
5.7.2 發表微博
5.7.3 使用者頁面
5.7.4 首頁
5.7.5 下一步
5.8 參考資料
第6章　Node.js 進階話題
6.1 模組載入機制
6.1.1 模組的型態
6.1.2 按路徑載入模組
6.1.3 透過尋找 node_modules 目錄載入模組
6.1.4 載入快取
6.1.5 載入順序
6.2 控制流
6.2.1 迴圈的陷阱
6.2.2 解決控制流難題
6.3 Node.js 應用部署
6.3.1 記錄檔功能
6.3.2 使用cluster 模組
6.3.3 啟動指令稿
6.3.4 共用80通訊埠
6.4 Node.js 不是銀彈
6.5 參考資料
附錄A　 JavaScript的進階特性
A.1 作用域
A.1.1 函數作用域
A.1.2 全域作用域
A.2 閉包
A.2.1 什麼是閉包
A.2.2 閉包的用途
A.3 物件
A.3.1 建立和存取
A.3.2 建構函數
A.3.3 上下文物件
A.3.4 原型
A.3.5 物件的複製
附錄B　 Node.js程式設計標準
B.1 縮排
B.2 行寬
B.3 敘述分隔符號
B.4 變數定義
B.5 變數名稱和屬性名稱
B.6 函數
B.7 引號
B.8 連結陣列的初始化
B.9 等號
B.10 命名函數
B.11 物件定義
B.12 繼承
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Google御用網頁語言Node.js
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js微服务
1　微服务架构	1
微服务应运而生	1
单块软件	2
现实世界中的微服务	2
面向微服务的架构	3
为什么面向微服务的架构更好	3
不足之处	3
关键设计原则	4
从组件到业务单元	5
智能的服务，愚蠢的通信管道	7
去中心化	8
技术对比	10
多微才是足够的微	10
关键的好处	11
弹性	11
可伸缩性	11
技术多样性	13
可替换性	14
独立性	15
SOA与微服务的比较	16
为什么选择Node.js	18
API聚合	18
展望Node.js	19
小结	20
2　基于Seneca和PM2构建Node.js微服务	21
选择Node.js的理由	21
安装Node.js、npm、Seneca和PM2	22
第一个程序——Hello World	25
Node.js的线程模型	27
模块化组织的最佳实践	27
微服务框架Seneca	32
实现控制反转	35
Seneca的模式匹配	35
PM2——Node.js的任务执行器	46
单线程应用及异常	46
PM2——业界标准的任务执行器	47
小结	52
3　从单块软件到微服务	53
首先，我们拥有一个单块软件	53
如何控制自然增长	54
多抽象才是过度抽象	57
微服务的出现	58
微服务的缺陷	64
分割单块软件	64
数据才是分割单块软件的主要问题	65
组织架构适配	66
小结	67
4　编写你的第一个Node.js微服务	69
微电子商务概览	69
商品管理服务——双重核心	71
获取商品信息	72
获取指定类别的商品	73
根据ID获取商品	74
添加商品	75
删除商品	75
编辑商品	76
整合各模块	76
集成Express与Seneca——如何创建REST API	81
邮件服务：一个常见的问题	82
如何发送邮件	82
接口定义	83
设置Mandrill	84
亲自动手在微服务中集成Mandrill	86
回退策略	91
订单管理服务	92
根据如何获取非本地数据来定义微服务	93
订单管理服务代码	95
UI——API聚合的产物	99
前端微服务的必要性	99
代码	99
服务降级——当出现非灾难性故障时	107
断路器	108
Seneca——一块使我们工作变得更容易的拼图	109
Seneca和promise	111
调试	115
小结	118
5　安全性和可追溯性	119
基础设施的逻辑安全	119
利用SSH来对通信加密	120
应用程序安全	122
保持安全方面的与时俱进来应对常见威胁	123
有效的代码审阅	131
可追溯性	132
日志	132
请求追踪	134
审计	135
HTTP状态码	136
小结	138
6　Node.js微服务的测试及文档化	140
功能性测试	141
自动化测试的金字塔	142
采用Node.js测试微服务	145
对微服务进行文档化	175
采用Swagger对API进行文档化	175
根据Swagger定义来生成项目	182
小结	184
7　微服务的监控	185
服务监控	185
采用PM2和Keymetrics进行监控	186
类人猿大军—来自Netflix的主动监控	201
吞吐量和性能的降级	204
小结	206
8　微服务的部署	208
软件部署的一些概念	208
持续集成	209
持续交付	209
采用PM2进行部署	209
PM2中的“生态系统”	210
采用PM2来部署微服务	212
Docker——一种可用于软件交付的容器	213
组装容器	215
部署Node.js应用	221
将Docker容器的创建过程自动化	223
Node.js事件循环—入门容易精通难	225
Node.js应用的集群化	228
为应用增加负载均衡	233
NGINX的健康检查	238
小结	239
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js微服务
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js实战
目　　录
译者序
前　言
第一部分　基础篇
第1章　入门
1.1　安装Node.js
1.1.1　在Windows上安装
1.1.2　在Mac上安装
1.1.3　在Linux上安装
1.2　"Hello World!"
1.2.1　Node Shell
1.2.2　编辑并运行JavaScript文件
1.3　第一个Web服务器
1.4　调试Node.js程序
1.5　保持最新及获取帮助
1.6　小结
第2章　进一步了解JavaScript
2.1　数据类型
2.1.1　类型基础
2.1.2　常量
2.1.3　number类型
2.1.4　boolean类型
2.1.5　string类型
2.1.6　object类型
2.1.7　array类型
2.2　类型比较和转换
2.3　函数
2.3.1　基本概念
2.3.2　函数作用域
2.4　语言结构
2.5　类、原型和继承
2.6　错误和异常
2.7　几个重要的Node.js全局对象
2.7.1　global对象
2.7.2　console对象
2.7.3　process对象
2.8　小结
第3章　异步编程
3.1　传统编程方式
3.2　Node.js的编程方式
3.3　错误处理和异步函数
3.4　我是谁--如何维护本体
3.5　保持优雅--学会放弃控制权
3.6　同步函数调用
3.7　小结
第二部分　提高篇
第4章　编写简单应用
4.1　第一个JSON服务器
4.2　Node模式：异步循环
4.3　小戏法：处理更多的请求
4.4　请求和响应对象的更多细节
4.5　提高灵活性：GET参数
4.6　修改内容：POST数据
4.6.1　接收JSON POST数据
4.6.2　接收表单POST数据
4.7　小结
第5章　模块化
5.1　编写简单模块
5.2　npm：Node包管理器
5.3　使用模块
5.3.1　查找模块
5.3.2　模块缓存
5.3.3　循环
5.4　编写模块
5.4.1　创建模块
5.4.2　使用模块进行开发
5.4.3　发布模块
5.5　应当内置的通用模块
5.5.1　常见问题
5.5.2　解决方案
5.6　小结
第6章　扩展Web服务器
6.1　使用Stream处理静态内容
6.1.1　读取文件
6.1.2　在Web服务器中使用Buffer处理静态文件
6.1.3　不仅仅支持HTML
6.2　在客户端组装内容：模板
6.2.1　HTML骨架页面
6.2.2　处理静态内容
6.2.3　修改URL解析机制
6.2.4　JavaScript加载器
6.2.5　使用Mustache模板化
6.2.6　首页Mustache模板
6.2.7　整合应用
6.3　小结
第三部分　实战篇
第7章　使用express构建Web应用
7.1　安装express
7.2　express中的路由和分层
7.2.1　路由基础
7.2.2　更新相册应用路由
7.3　REST API设计和模块
7.3.1　API设计
7.3.2　模块
7.4　中间件功能
7.4.1　基本用法
7.4.2　配置
7.4.3　中间件执行顺序
7.4.4　静态文件处理
7.4.5　POST数据、cookie和session
7.4.6　对PUT和DELETE更友好的浏览器支持
7.4.7　压缩输出
7.4.8　HTTP基本身份验证
7.4.9　错误处理
7.5　小结
第8章　数据库I：NoSQL（MongoDB）
8.1　设置MongoDB
8.1.1　安装MongoDB
8.1.2　在Node.js中使用MongoDB
8.2　MongoDB数据结构
8.2.1　全是JavaScript的世界
8.2.2　数据类型
8.3　理解基本操作
8.3.1　连接并创建数据库
8.3.2　创建集合
8.3.3　向集合中插入文档
8.3.4　更新文档内容
8.3.5　删除集合中的文档
8.3.6　查询集合
8.4　更新相册应用
8.4.1　编写基本操作
8.4.2　修改JSON服务器的API
8.4.3　更新处理程序
8.4.4　为应用添加新页面
8.5　应用结构回顾
8.6　小结
第9章　数据库II：SQL（MySQL）
9.1　准备工作
9.1.1　安装MySQL
9.1.2　从npm添加mysql模块
9.2　创建数据库模式
9.3　基本数据库操作
9.3.1　连接数据库
9.3.2　添加查询
9.4　添加应用身份验证
9.4.1　更新API以支持用户
9.4.2　检测核心用户数据操作
9.4.3　更新express应用
9.4.4　创建用户处理程序
9.4.5　创建登录和注册页面
9.5　资源池
9.5.1　入门
9.5.2　处理连接
9.6　验证API
9.7　小结
第四部分　进阶篇
第10章　部署和开发
10.1　部署
10.1.1　级别：基础
10.1.2　级别：Ninja
10.2　多处理器部署：使用代理
10.3　虚拟主机
10.3.1　内置支持
10.3.2　代理服务器支持
10.4　使用HTTPS/SSL保障项目安全
10.4.1　生成测试证书
10.4.2　内置支持
10.4.3　代理服务器支持
10.5　多平台开发
10.5.1　位置和配置文件
10.5.2　处理路径差异
10.6　小结
第11章　命令行编程
11.1　运行命令行脚本
11.1.1　UNIX和Mac
11.1.2　Windows
11.1.3　脚本和参数
11.2　同步处理文件
11.2.1　基本文件API
11.2.2　文件和状态
11.2.3　目录内容
11.3　用户交互：标准输入和输出
11.3.1　基本缓冲输入和输出
11.3.2　无缓冲输入
11.3.3　Readline模块
11.4　进程处理
11.4.1　简单进程创建
11.4.2　使用Spawn创建进程
11.5　小结
第12章　测试
12.1　测试框架选择
12.2　编写测试用例
12.2.1　简单功能测试
12.2.2　异步功能测试
12.3　RESTful API测试
12.4　小结
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>代码逆袭 超实用的Node.js代码段
第1章  Node.js控制台模块应用	1
1.1　Node.js版之“Hello World”程序	1
1.2  日志输出与信息输出功能	3
1.3  字符串格式化的应用	5
1.4  数值型格式化的应用	6
1.5  JSON数据交换格式应用	7
1.6  测试特殊运算符如何取值	8
1.7  特殊格式化参数应用	9
1.8  斐波那契（Fibonacci）数列应用	10
1.9  错误与警告提示应用	11
1.10  重定向标准错误输出流	12
1.11  查看Node.js对象的属性和方法	13
1.12  时间计时器应用	14
1.13  查看当前调用栈的方法	16
1.14  对表达式结果进行评估	17
1.15  读取命令行输入信息	18
1.16  阶乘运算输出	20
1.17  向控制台输出组合控制键	22
1.18  模拟一个简单的控制台界面	23
1.19  输出水仙花数	26
1.20  输出质数	27
1.21  打印输出杨辉三角	28
1.22  汉诺塔（Hanoi）问题	30
1.23  简单四则运算应用	33
第2章  Node.js模块与包管理	36
2.1  Node.js框架加载核心模块	36
2.2  Node.js框架加载文件模块	37
2.3  从node_modules文件夹中加载	39
2.4  模块的循环调用问题	40
2.5  module.exports对象应用	42
2.6  module.exports对象与exports对象	43
2.7  汇率换算实用程序	45
2.8  简单计数器实用程序	46
2.9  包管理之package.json详解	49
2.10  基于包管理的四则运算应用	52
第3章　Node.js异步I/O与Async流程控制库	58
3.1  Node.js框架异步机制基础	58
3.2  Node.js框架异常捕获机制	60
3.3  Async串行流程控制	62
3.4  Async瀑布模式流程控制	64
3.5  Async并行流程控制	66
3.6  Async限制性并行流程控制	67
3.7  Async循环流程控制	69
3.8  Async队列流程控制	72
第4章  Buffer模块处理	75
4.1  定义Buffer对象的基本方法	75
4.2  定义Buffer对象的特别方法	77
4.3  如何判断Buffer对象	79
4.4  获取Buffer对象字节长度	80
4.5  读取Buffer对象	82
4.6  写入Buffer对象	84
4.7  Buffer对象转字符串	86
4.8  Buffer对象裁剪	88
4.9  拷贝Buffer对象	89
4.10  正确拼接Buffer	91
4.11  应用Buffer操作HTTP Request Header	93
第5章  Node.js进程管理	98
5.1  获取应用程序当前目录	98
5.2  改变应用程序目录	99
5.3  获取系统相关信息	100
5.4  实现标准输出流	105
5.5  实现标准错误流	107
5.6  实现标准输入流	108
5.7  Kill当前进程	109
5.8  Process模块的异步方法	111
第6章  child_process及进程通信	113
6.1  使用spawn方法创建子进程	113
6.2  使用exec方法创建子进程	115
6.3  使用spawn方法绑定系统事件	117
6.4  使用exec方法绑定错误事件	118
6.5  创建子进程查看用户目录	120
6.6  查看用户目录出现错误的处理方法	122
6.7  查看物理内存使用状态	123
6.8  查看子进程pid的方法	125
6.9  创建子进程统计系统登录次数	127
6.10  使用execFile方法创建子进程	128
6.11  使用execFile方法绑定错误事件	130
6.12  使用fork方法获取CPU信息	131
6.13  使用fork方法实现进程间通信	132
6.14  使用fork方法实现斐波那契数列	134
第7章  OS模块应用	138
7.1  获取当前操作系统类型与平台	138
7.2  获取操作系统默认的临时文件目录	139
7.3  获取操作系统主机名	140
7.4  获取操作系统架构	141
7.5  获取操作系统的发行版本	142
7.6  返回操作系统运行时间	143
7.7  获取操作系统内存状态	145
7.8  获取CPU内核信息	146
7.9  获取网络接口信息	147
第8章  文件系统模块应用	149
8.1  重命名文件	149
8.2  打开与关闭文件	152
8.3  截取文件内容	155
8.4  修改文件长度	156
8.5  获取文件信息	158
8.6  更改文件所有权	159
8.7  更改文件权限	161
8.8  创建与删除文件硬链接	163
8.9  创建文件符号链接	165
8.10  读取文件符号链接	168
8.11  相对路径转绝对路径	169
8.12  创建与删除目录	170
8.13  读取文件目录	172
8.14  读文件的应用	173
8.15  功能增强的读文件应用	175
8.16  写文件的应用	176
8.17  功能增强的写文件应用	178
8.18  追加写入文件	180
8.19  监控文件的应用	182
第9章  路径处理应用	185
9.1  规范化字符串路径	185
9.2  合并字符串路径	187
9.3  解析绝对路径	188
9.4  解析相对路径	189
9.5  获取文件夹路径	191
9.6  获取路径中文件扩展名	192
9.7  如何获取路径中最后部分	193
9.8  解析与格式化url路径	194
9.9  url路径转化	196
9.10  url参数转化url对象	197
第10章  TCP/UDP网络应用	199
10.1  创建基本的TCP服务器	199
10.2  创建基本的TCP客户端	201
10.3  创建简单的TCP通信应用	202
10.4  创建TCP服务器的另一种方式	206
10.5  服务器端绑定事件	207
10.6  获取服务器地址参数	210
10.7  获取当前服务器连接数	211
10.8  获取套接字地址	215
10.9  获取远程地址	216
10.10  使用套接字写数据	218
10.11  控制套接字数据流的应用	221
10.12  创建UDP服务器	225
10.13  创建UDP客户端	227
10.14  创建简单的UDP应用	229
10.15  UDP广播服务的实现	233
10.16  模仿简单的聊天室应用	236
第11章　Node.js流（Stream）应用	241
11.1  创建可读（Readable）流	241
11.2  测试可读readable事件处理	244
11.3  使用data事件读取文件	246
11.4  可读流错误事件处理	247
11.5  暂停与恢复可读（Readable）流	248
11.6  使用可读（Readable）流发送数据	251
11.7  使用可读（Readable）流读取文件	252
11.8  使用pipe方法实现复制文件	253
11.9  解除pipe方法设置的流	255
11.10  使用可写（Writable）流写文件	257
11.11  可写（Writable）流drain事件处理	258
11.12  可写（Writable）流finish事件处理	260
第12章  Node.js Web开发	263
12.1  构建一个基本的HTTP服务器	263
12.2  编写一个简单的HTTP客户端	265
12.3  HTTP响应状态码	268
12.4  设定和获取HTTP头文件	271
12.5  写HTTP头文件的方法	273
12.6  发送与处理GET请求	276
12.7  进行重定向操作	278
12.8  服务器多路径处理方式	281
12.9  模拟ping命令连接服务器	284
12.10  安装Express开发框架	286
12.11  使用Express开发框架开发的Hello World	287
12.12  Express开发框架路由处理	292
12.13  应用Express框架实现登录页面	296
12.14  Express框架实现Ajax方式操作	301
第13章  Node.js Util常用工具	306
13.1  原型对象继承	306
13.2  将任意对象转换为字符串	308
13.3  验证是否为数组	310
13.4  验证是否为日期格式	310
13.5  验证是否为正则表达式	311
13.6  验证是否为错误类型	312
13.7  格式化字符串	313
第14章  Node.js与MySQL交互	315
14.1  连接MySQL数据库	315
14.2  查询MySQL数据库	317
14.3  插入MySQL数据库	318
14.4  删除MySQL数据库	320
14.5  更新MySQL数据库	321
14.6  操作MySQL数据库连接池	322
第15章　Node.js与MongoDB交互	325
15.1  连接MongoDB数据库	326
15.2  连接MongoDB数据集合	328
15.3  查询MongoDB数据集合	330
15.4  插入MongoDB数据集合	333
15.5  删除MongoDB数据集合	335
15.6  更新MongoDB数据集合	336
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>代码逆袭 超实用的Node.js代码段
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js by Examples
第一章 Node.js 基础
理解 node.js 架构，安装 node.js, 定义和使用模块，管理和分发包，内置模块介绍，小结
第二章 架构项目
应用程序基本层面介绍，任务运行器和构建系统，发现 Gulp，测试驱动开发TDD，MVC模式，REST API 概念介绍
第三章 管理资产
使用node.js服务文件，css预处理器，打包客户端JS，交付HTML模板，小结
第四章 开发 MVC 层
当前设定演进，实现router，构造程序入口，定义一个控制器，管理我们的视图，创建一个模型，小结
第五章 管理用户
和 MongoDB 数据库一起工作，从之前章节扩展代码，注册一个新用户，使用 session 进行用户鉴权，管理用户profile，小结
第六章 添加朋友关系能力
查找朋友，标记一个用户为朋友，在profile页面上显示链接的用户，小结
第七章 发布内容
第8章 创建页面和事件
第9章 标记，共享和点赞
第10章 添加实时聊天
第11章 测试用户界面
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js by Examples
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js实战（第2版）
第一部分　Node基础知识介绍
第1章　欢迎进入Node.js的世界　　2
1.1　一个典型的Node Web应用程序　　2
1.1.1　非阻塞I/O　　3
1.1.2　事件轮询　　4
1.2　ES2015、Node和V8　　5
1.2.1　Node与V8　　7
1.2.2　使用特性组　　8
1.2.3　了解Node的发布计划　　8
1.3　安装Node　　8
1.4　Node自带的工具　　9
1.4.1　npm　　9
1.4.2　核心模块　　10
1.4.3　调试器　　11
1.5　三种主流的Node程序　　12
1.5.1　Web应用程序　　12
1.5.2　命令行工具和后台程序　　13
1.5.3　桌面程序　　14
1.5.4　适合Node的应用程序　　14
1.6　总结　　15
第2章　Node编程基础　　16
2.1　Node功能的组织及重用　　16
2.2　开始一个新的Node项目　　18
2.3　用module.exports微调模块的创建　　20
2.4　用node_modules重用模块　　22
2.5　注意事项　　23
2.6　使用异步编程技术　　24
2.7　用回调处理一次性事件　　25
2.8　用事件发射器处理重复性事件　　28
2.8.1　事件发射器示例　　28
2.8.2　响应只应该发生一次的事件　　29
2.8.3　创建事件发射器：一个PUB/SUB的例子　　29
2.8.4　扩展事件监听器：文件监视器　　32
2.9　异步开发的难题　　34
2.10　异步逻辑的顺序化　　35
2.11　何时使用串行流程控制　　36
2.12　实现串行化流程控制　　37
2.13　实现并行化流程控制　　39
2.14　利用社区里的工具　　41
2.15　总结　　43
第3章　Node Web程序是什么　　44
3.1　了解Node Web程序的结构　　45
3.1.1　开始一个新的Web程序　　45
3.1.2　跟其他平台比一比　　47
3.1.3　然后呢　　47
3.2　搭建一个RESTful Web服务　　47
3.3　添加数据库　　50
3.3.1　制作自己的模型API　　51
3.3.2　让文章可读并把它存起来　　53
3.4　添加用户界面　　54
3.4.1　支持多种格式　　54
3.4.2　渲染模板　　55
3.4.3　用npm管理客户端依赖项　　56
3.5　总结　　57
第二部分　Node的Web开发
第4章　前端构建系统　　60
4.1　了解基于Node的前端开发　　60
4.2　用npm运行脚本　　61
4.2.1　创建定制的npm脚本　　62
4.2.2　配置前端构建工具　　63
4.3　用Gulp实现自动化　　63
4.3.1　把Gulp添加到项目中　　64
4.3.2　Gulp任务的创建及运行　　64
4.3.3　监测变化　　66
4.3.4　在大项目中把任务分散到不同文件中　　66
4.4　用Webpack构建Web程序　　67
4.4.1　使用打包器和插件　　67
4.4.2　配置和运行Webpack　　68
4.4.3　用Webpack开发服务器　　68
4.4.4　加载CommonJS模块和静态资源　　70
4.5　总结　　71
第5章　服务器端框架　　72
5.1　用户画像　　72
5.1.1　菲尔：代理开发者　　73
5.1.2　纳迪娜：开源开发者　　73
5.1.3　爱丽丝：产品开发者　　73
5.2　框架是什么　　74
5.3　Koa　　74
5.3.1　设置　　76
5.3.2　定义路由　　76
5.3.3　REST API　　77
5.3.4　优点　　77
5.3.5　弱点　　77
5.4　Kraken　　77
5.4.1　设置　　77
5.4.2　定义路由　　78
5.4.3　REST API　　79
5.4.4　优点　　79
5.4.5　弱点　　79
5.5　hapi　　79
5.5.1　设置　　80
5.5.2　定义路由　　80
5.5.3　插件　　81
5.5.4　REST API　　82
5.5.5　优点　　83
5.5.6　弱点　　83
5.6　Sails.js　　83
5.6.1　设置　　83
5.6.2　定义路由　　84
5.6.3　REST API　　84
5.6.4　优点　　85
5.6.5　弱点　　85
5.7　DerbyJS　　85
5.7.1　设置　　85
5.7.2　定义路由　　86
5.7.3　REST API　　87
5.7.4　优点　　87
5.7.5　弱点　　87
5.8　Flatiron.js　　87
5.8.1　设置　　88
5.8.2　定义路由　　88
5.8.3　REST API　　89
5.8.4　优点　　90
5.8.5　弱点　　90
5.9　LoopBack　　90
5.9.1　设置　　91
5.9.2　定义路由　　92
5.9.3　REST API　　92
5.9.4　优点　　93
5.9.5　弱点　　93
5.10　比较　　93
5.11　编写模块化代码　　95
5.12　用户选择　　95
5.13　总结　　95
第6章　深入了解Connect和Express　　96
6.1　Connect　　96
6.1.1　创建Connect程序　　97
6.1.2　了解Connect中间件的工作机制　　97
6.1.3　组合中间件　　98
6.1.4　中间件的顺序　　98
6.1.5　创建可配置的中间件　　99
6.1.6　使用错误处理中间件　　101
6.2　Express　　103
6.2.1　生成程序框架　　103
6.2.2　Express和程序的配置　　107
6.2.3　渲染视图　　109
6.2.4　Express路由入门　　113
6.2.5　用户认证　　120
6.2.6　注册新用户　　124
6.2.7　已注册用户登录　　130
6.2.8　用户加载中间件　　133
6.2.9　创建REST API　　134
6.2.10　启用内容协商　　140
6.3　总结　　142
第7章　Web程序的模板　　143
7.1　用模板保持代码的整洁性　　143
7.2　Embedded JavaScript的模板　　147
7.2.1　创建模板　　148
7.2.2　将EJS集成到你的程序中　　149
7.2.3　在客户端程序中使用EJS　　150
7.3　使用Mustache模板语言与Hogan　　151
7.3.1　创建模板　　151
7.3.2　Mustache标签　　151
7.3.3　微调Hogan　　154
7.4　用Pug做模板　　154
7.4.1　Pug基础知识　　155
7.4.2　Pug模板中的逻辑　　157
7.4.3　组织Pug模板　　159
7.5　总结　　163
第8章　存储数据　　164
8.1　关系型数据库　　164
8.2　PostgreSQL　　164
8.2.1　安装及配置　　164
8.2.2　创建数据库　　165
8.2.3　从Node中连接Postgres　　165
8.2.4　定义表　　166
8.2.5　插入数据　　166
8.2.6　更新数据　　166
8.2.7　查询数据　　167
8.3　Knex　　167
8.3.1　查询构建器　　168
8.3.2　用Knex实现连接和查询　　168
8.3.3　切换数据库　　170
8.3.4　注意抽象漏洞　　171
8.4　MySQL和PostgreSQL　　171
8.5　ACID保证　　172
8.5.1　原子性：无论成败，事务必须整体执行　　172
8.5.2　一致性：始终确保约束条件　　172
8.5.3　隔离性：并发事务不会相互干扰　　172
8.5.4　耐用性：事务是永久性的　　173
8.6　NoSQL　　173
8.7　分布式数据库　　173
8.8　MongoDB　　174
8.8.1　安装和配置　　174
8.8.2　连接MongoDB　　174
8.8.3　插入文档　　175
8.8.4　查询　　176
8.8.5　使用MongoDB标识　　177
8.8.6　使用复制集　　178
8.8.7　了解写关注　　180
8.9　键/值存储　　181
8.10　Redis　　181
8.10.1　安装和配置　　182
8.10.2　初始化　　182
8.10.3　处理键/值对　　183
8.10.4　处理键　　184
8.10.5　编码与数据类型　　184
8.10.6　使用散列表　　186
8.10.7　使用列表　　186
8.10.8　使用集合　　187
8.10.9　用频道实现发布/订阅功能　　188
8.10.10　提升性能　　189
8.11　嵌入式数据库　　189
8.12　LevelDB　　190
8.12.1　LevelUP与LevelDOWN　　190
8.12.2　安装　　191
8.12.3　API概览　　191
8.12.4　初始化　　191
8.12.5　键/值编码　　192
8.12.6　键/值对的读写　　192
8.12.7　可插拔的后台　　193
8.12.8　模块化数据库　　194
8.13　昂贵的序列化和反序列化　　195
8.14　浏览器内存储　　196
8.14.1　Web存储：localStorage和sessionStorage　　196
8.14.2　值的读写　　197
8.14.3　localForage　　199
8.14.4　读和写　　199
8.15　存储托管　　200
8.16　选哪个数据库　　201
8.17　总结　　201
第9章　测试Node程序　　202
9.1　单元测试　　203
9.1.1　assert模块　　203
9.1.2　Mocha　　206
9.1.3　Vows　　211
9.1.4　Chai　　213
9.1.5　Should.js　　214
9.1.6　Sinon.JS的探测器和存根　　216
9.2　功能测试　　218
9.3　处理失败的测试　　221
9.3.1　获取更详细的日志　　221
9.3.2　更好的栈跟踪　　223
9.4　总结　　224
第10章　Node程序的部署及运维　　225
10.1　安置Node程序　　225
10.1.1　平台即服务　　226
10.1.2　服务器　　227
10.1.3　容器　　228
10.2　部署的基础知识　　229
10.2.1　从Git库部署　　229
10.2.2　保证Node不掉线　　230
10.3　在线时长和性能的最大化　　231
10.3.1　用Upstart保证在线时长　　232
10.3.2　集群API：充分利用多核处理器　　233
10.3.3　静态文件及代理　　235
10.4　总结　　236
第三部分　超越Web开发
第11章　编写命令行程序　　238
11.1　了解惯例和理念　　238
11.2　parse-json　　239
11.3　使用命令行参数　　239
11.3.1　解析命令行参数　　239
11.3.2　验证参数　　240
11.3.3　将stdin作为文件传递　　241
11.4　用npm分享命令行工具　　242
11.5　用管道连接脚本　　243
11.5.1　将数据通过管道传给parse-json　　243
11.5.2　处理错误和退出码　　243
11.5.3　在Node中使用管道　　245
11.5.4　管道与命令的执行顺序　　246
11.6　解释真正的脚本　　247
11.7　总结　　247
第12章　用Electron征服桌面　　248
12.1　认识Electron　　248
12.1.1　Electron的技术栈　　249
12.1.2　界面设计　　250
12.2　创建一个Electron程序　　250
12.3　搭建完整的桌面端程序　　252
12.3.1　引导React与Babel　　253
12.3.2　安装依赖项　　253
12.3.3　设置Webpack　　254
12.4　React程序　　255
12.4.1　定义Request组件　　256
12.4.2　定义Response组件　　258
12.4.3　React组件之间的通信　　261
12.5　构建与分发　　261
12.5.1　用Electron打包器构建程序　　261
12.5.2　打包　　262
12.6　总结　　263
附录A　安装Node　　264
附录B　自动化的网络抓取　　267
附录C　Connect的官方中间件　　277
术语表　　307
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js实战（第2版）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>写给PHP开发者的Node.js学习指南
第1章　node.js基本介绍
1.1　node和npm命令
1.2　堆栈追踪
1.3　eclipse pdt
第2章　简单的node.js框架
2.1　http服务器
2.2　预定义的php变量
2.3　一个php示例页面
第3章　简单回调
3.1　线性
3.2　线性化代码
第4章　高级回调
4.1　匿名函数、lambda和闭包
4.2　php 5.3
4.3　php 4
第5章　http response
5.1　headers
5.2　body
5.3　php页面的例子
第6章　语法
6.1　字符串字面量
6.2　语法差异
6.3　php的替代语法
第7章　变量
7.1　简单变量
7.2　数组变量
7.3　其他变量类型
7.4　undefined变量
7.5　作用域
第8章　类
8.1　封装encapsiulation
8.2　继承inheritance
8.3　php parent和static关键字
第9章　文件访问
9.1　读写文件
9.2　php file()api方法
9.3　低级别的文件处理
9.4　文件名
第10章　mysql数据库访问
10.1　数据库方法
10.2　node-mysql
第11章　文本、json和xml
11.1　文本
11.2　json
11.3　xml
第12章　各种各样的函数
12.1　array
12.2　time和date
12.3　file
12.4　json
12.5　math
12.6　string
12.7　类型
12.8　文本
12.9　mysql
12.10　变量
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>写给PHP开发者的Node.js学习指南
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js调试指南（全彩）
第1 章  CPU 1
1.1  理解perf 与火焰图（FlameGraph） 2
1.1.1  perf 2
1.1.2  火焰图 6
1.1.3  红蓝差分火焰图 8
1.2  使用 v8-profiler 分析 CPU 的使用情况 11
1.3  Tick Processor 及Web UI 16
1.3.1  Tick Processor 16
1.3.2  Web UI 21
第2 章  内存 23
2.1  gcore 与llnode 24
2.1.1  Core 和 Core Dump 24
2.1.2  gcore 25
2.1.3  llnode 25
2.1.4  测试 Core Dump 26
2.1.5  分析Core 文件 27
2.1.6  --abort-on-uncaught-exception 29
2.1.7  小结 30
2.2  heapdump 30
2.2.1  使用heapdump 30
2.2.2  Chrome DevTools 32
2.2.3  对比快照 34
2.3  memwatch-next 35
2.3.1  使用memwatch-next 35
2.3.2  使用Heap Diff 38
2.3.3  结合 heapdump 使用 40
2.4  cpu-memory-monitor 41
2.4.1  使用cpu-memory-monitor 41
2.4.2  cpu-memory-monitor 源码解读 43
第3 章  代码 46
3.1  Promise 47
3.1.1  Promise/A+ 规范 48
3.1.2  从零开始实现 Promise 48
3.1.3  Promise 的实现原理 50
3.1.4  safelyResolveThen 52
3.1.5  doResolve 和 doReject 54
3.1.6  Promise.prototype.then 和 Promise.prototype.catch 55
3.1.7  值穿透 58
3.1.8  Promise.resolve 和 Promise.reject 60
3.1.9  Promise.all 61
3.1.10  Promise.race 62
3.1.11  代码解析 63
3.2  Async + Await 69
3.2.1  例1 ：async + await 70
3.2.2  例2 ：co + yield 71
3.2.3  例3 ：co + yield* 72
3.2.4  例4 ：co + bluebird 73
3.2.5  从yield 转为yield* 遇到的坑 75
3.2.6  async + bluebird 76
3.3  Error Stack 77
3.3.1  Stack Trace 78
3.3.2  Error.captureStackTrace 80
3.3.3  captureStackTrace 在 Mongolass 中的应用 83
3.3.4  Error.prepareStackTrace 84
3.3.5  Error.prepareStackTrace 的其他用法 86
3.3.6  Error.stackTraceLimit 88
3.3.7  Long Stack Trace 88
3.4  node@8 89
3.4.1  Ignition + Turbofan 90
3.4.2  版本的对应关系 91
3.4.3  try/catch 91
3.4.4  delete 93
3.4.5  arguments 95
3.4.6  async 性能提升 97
3.4.7  不会优化的特性 98
3.5  Rust Addons 100
3.5.1  Rust 100
3.5.2  FFI 100
3.5.3  Neon 103
3.5.4  NAPI 108
3.6  Event Loop 110
3.6.1  什么是 Event Loop 110
3.6.2  poll 阶段 112
3.6.3  process.nextTick() 112
3.6.4  代码解析 113
3.7  处理 uncaughtException 120
3.7.1  uncaughtException 120
3.7.2  使用 llnode 121
3.7.3  ReDoS 122
第4 章  工具 125
4.1  Source Map 126
4.1.1  uglify-es 126
4.1.2  TypeScript 128
4.1.3  source-map-support 的高级用法 129
4.2  Chrome DevTools 129
4.2.1  使用 Chrome DevTools 130
4.2.2  NIM 132
4.2.3  inspect-process 133
4.2.4  process._debugProcess 133
4.3  Visual Studio Code 134
4.3.1  基本调试 134
4.3.2  launch.json 136
4.3.3  技巧 1——条件断点 138
4.3.4  技巧 2——skipFiles 139
4.3.5  技巧 3——自动重启 140
4.3.6  技巧 4——对特定操作系统的设置 142
4.3.7  技巧 5——多配置 142
4.3.8  总结 144
4.4  debug + repl2 + power-assert 144
4.4.1  debug 144
4.4.2  repl2 146
4.4.3  power-assert 148
4.5  supervisor-hot-reload 151
4.5.1  Proxy 151
4.5.2  用Proxy 实现 Hot Reload 153
4.5.3  supervisor-hot-reload 155
4.5.4  内存泄漏问题 160
第5 章  日志 161
5.1  koa-await-breakpoint 162
5.1.1  koa-await-breakpoint 的实现原理 162
5.1.2  使用 koa-await-breakpoint 165
5.1.3  自定义日志存储 167
5.2  使用async_hooks 168
5.3  ELK 177
5.3.1  安装 ELK 177
5.3.2  使用 ELK 178
5.4  OpenTracing + Jaeger 182
5.4.1  什么是 OpenTracing 182
5.4.2  什么是 Jaeger 184
5.4.3  启动 Jaeger 及Jaeger UI 184
5.4.4  使用 OpenTracing 及Jaeger 185
5.4.5  koa-await-breakpoint-jaeger 187
5.5  使用Sentry 190
第6 章  APM 197
6.1  使用NewRelic 198
6.2  Elastic APM 201
6.2.1  什么是 Elastic APM 201
6.2.2  启动 ELK 203
6.2.3  启动 APM Server 203
6.2.4  使用 Elastic APM 203
6.2.5  错误日志 205
第7 章  监控 207
7.1  Telegraf + InfluxDB + Grafana（上） 208
7.1.1  Telegraf（StatsD） + InfluxDB + Grafana 简介 208
7.1.2  启动 docker-statsd-influxdb-grafana 208
7.1.3  熟悉 InfluxDB 209
7.1.4  配置 Grafana 210
7.1.5  node-statsd 211
7.1.6  创建 Grafana 图表 213
7.1.7  模拟真实环境 214
7.2  Telegraf + InfluxDB + Grafana（下） 217
7.2.1  Grafana + ELK 217
7.2.2  监控报警 220
7.2.3  脚本一键生成图表 222
第8 章  应用 224
8.1  使用 node-clinic 225
8.2  alinode 227
8.2.1  什么是 alinode 227
8.2.2  创建 alinode 应用 228
8.2.3  安装 alinode 228
8.2.4  使用 alinode 诊断内存泄露 229
8.2.5  使用 alinode 诊断 CPU 性能瓶颈 232
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js调试指南（全彩）
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js 核心技术教程
第1章 模块化编程
1.1 初识模块化思想
1.1.1 模块化的概念
1.1.2 模块化开发
1.2 模块化编程的演变
1.2.1 全局函数
1.2.2 对象命名空间
1.2.3 函数的作用域(闭包)
1.2.4 维护和扩展
小结
习题
第2章 初识Node.js
2.1 Node.js概述
2.1.1 学习Node.js的目的
2.1.2 客户端和服务器端
2.1.3 在客户端和服务器端的区别
2.2 Node.js简介
2.2.1 Node.js的概念
2.2.2 Node.js的特点和优势
2.3 Node.js的安装和配置
2.3.1 下载和安装
2.3.2 CMD命令台.
2.3.3 Path环境变量
2.3.4 快速体验Node.js
2.4 Node.js基础入门
2.4.1 REPL运行环境
2.4.2 global对象和模块作用域
2.4.3 全局可用变量、函数和对象
2.4.4 Node.js模块化重写计算器案例
2.4.5 require()的模块加载规则
2.4.6 模块的缓存
小结
习题
第3章 异步编程和包资源管理
3.1 异步编程
3.1.1 同步和异步
3.1.2 回调函数
3.2 Node.js的包和NPM
3.2.1 包的概念
3.2.2 NPM的概念
3.2.3 NPM的基本应用
3.2.4 包模块加载规则
小结
习题
第4章 Node.js文件操作
4.1 基本文件操作
4.1.1 文件写入
4.1.2 向文件中追加内容
4.1.3 文件读取
4.1.4 文件复制
4.1.5 获取文件信息
4.2 案例——控制歌词滚动
4.3 文件相关操作
4.3.1 路径字符串操作(Path模块)
4.3.2 目录操作
小结
习题
第5章 Node.js中处理数据I/O
5.1 Buffer缓冲区
5.1.1 二进制数据和乱码
5.1.2 Buffer的构造函数
5.1.3 写入缓冲区
5.1.4 从缓冲区读取数据
5.1.5 拼接缓冲区
5.2 Stream文件流
5.2.1 文件流的概念
5.2.2 Node.js的可读流和可写流
5.2.3 使用pipe()处理大文件
小结
习题
第6章 Node.js网络编程
6.1 Node.js网络编程基础
6.1.1 IP地址和端口号
6.1.2 套接字Socket简单模型
6.2 Node.js中实现套接字服务
6.2.1 Net.Server对象
6.2.2 Net.Socket对象
6.3 Node.js进程管理
6.3.1 Process模块获取终端输入
6.3.2 多人广播消息
6.4 案例——终端聊天室
小结
习题
第7章 Noe.js中实现HTTP服务
7.1 HTTP协议
7.1.1 HTTPt协议简介
7.1.2 HTTP请求响应流程
7.1.3 HTTP的请求报文和响应报文
7.2 Node.js的HTTP服务
7.2.1 HTTP模块常用APT
7.2.2 使用HTTP模块构建Web服务器
7.3 HTTP服务请求处理
7.3.1 根据不同的URL发送不同响应消息
7.3.2 HTTP处理静态资源服务
7.3.3 动态处理静态资源请求
小结
习题
第8章 综合项目——我的音乐
8.1 项目简介
8.1.1 项目功能展示
8.1.2 项目开发流程
8.1.3 需求分析
8.1.4 项目结构
8.2 项目实现
8.2.1 项目初始化
8.2.2 制作数据文件
8.2.3 制作音乐首页
8.2.4 添加歌曲
8.2.5 删除歌曲
8.2.6 编辑歌曲
小结
习题
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js 核心技术教程
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js实战：使用Egg.js+Vue.js+Docker构建渐进式、可持续集成与交付应用
第1章  Node.js的优势  1
1.1  为什么是JavaScript语言  1
1.2  为什么经常说Node.js不适合大型应用  3
第2章  Egg.js框架核心原理与实现  6
2.1  异步基础  6
2.2  Koa.js基础知识  15
2.2.1  Koa.js 中间件核心代码  16
2.2.2  Koa.js插件  18
2.3  Egg.js 基础知识  21
2.3.1  实现 egg-core  22
2.3.2  实现 egg-init  26
2.3.3  实现egg-cluster  30
2.4  Egg.js插件  33
2.4.1  egg-socket.io  33
2.4.2  原理解读  39
2.5  制作一个Egg.js插件  43
第3章  构建后端API服务  52
3.1  安装相关组件  52
3.2  发布一个插件  59
3.2.1  创建Flash插件  59
3.2.2  使用egg-msg-flash  72
3.2.3  使用egg-y-validator  73
3.3  规范化  73
3.3.1  添加新的scripts支持ESLint自修复  74
3.3.2  添加插件支持  74
3.3.3  prettier格式化工具  76
3.3.4  同步代码编辑器配置  76
3.4  第一个JSON请求  77
3.4.1  给全局添加一些方法  77
3.4.2  全局化一些东西  84
3.4.3  自动路由  86
3.4.4  创建 PostMan 测试  88
3.5  注册服务  91
3.5.1  Invitation模型  91
3.5.2  注释  93
3.5.3  User模型  96
3.5.4  修改控制器  97
3.5.5  添加验证逻辑  98
3.5.6  帮助方法  99
3.5.7  User服务  101
3.5.8  PostMan测试  103
3.6  登录服务  104
3.7  邮件与调试  115
3.7.1  理解发送邮件的原理  115
3.7.2  安装邮件插件  115
3.7.3  环境与调试  116
3.7.4  全局调试  118
3.7.5  VSCode全局调试  121
3.7.6  发送验证邮件  122
3.7.7  添加逻辑  125
3.7.8  验证  135
3.8  构建 RESTful API  137
3.8.1  什么是RESTful API  137
3.8.2  创建RESTController基础类便于继承  138
3.8.3  测试Images RESTful API  141
3.8.4  构建后台的REST路由  143
3.8.5  构建控制器  145
3.8.6  测试后台路由  148
3.8.7  关于验证  149
3.9  安全地开放API  151
3.10  实现OAuth接口  158
3.10.1  实现授权码官方文档所要求的接口  158
3.10.2  实现刷新验证码接口  167
3.10.3  实现 authenticate 所需接口  169
3.11  完善OAuth与测试  170
3.11.1  发放Token  170
3.11.2  新建客户端项目  172
3.11.3  测试OAuth  173
3.12  支付宝支付  176
3.12.1  什么是非对称加密  176
3.12.2  注册支付宝  176
3.12.3  生成非对称秘钥  176
3.12.4  实现  177
3.12.5  添加路由  180
3.12.6  内网穿透  180
3.12.7  测试  182
3.13  社会化登录  183
第4章  构建后台管理页面  189
4.1  后端开发  189
4.1.1  安装VSCode插件  189
4.1.2  获取脚手架  189
4.1.3  安装依赖  190
4.1.4  修改代码  190
4.1.5  跨域请求  191
4.1.6  修改后端代码支持跨域  192
4.1.7  在前端添加存储  198
4.2  模型列表  200
4.3  添加数据  209
4.4  修改逻辑  220
第5章  前端界面设计与实现  228
5.1  搭建前端开发环境  228
5.1.1  开始  228
5.1.2  创建Header头部  229
5.1.3  将变量提取出来  234
5.1.4  添加路径重写  235
5.2  AppFooter组件  237
5.2.1  做一些配置  237
5.2.2  创建src/components/layouts/AppFooter.vue  238
5.2.3  网络识别信息  247
5.2.4  修改一下全局样式  247
5.2.5  查看页面  248
5.2.6  提升编译速度  248
5.3  首页  249
5.4  替换成为真实数据  269
5.4.1  完成后端Image API  269
5.4.2  修改首页的代码  271
5.4.3  添加API逻辑  276
5.4.4  效果  278
5.5  图片详情页  278
5.5.1  创建路由  279
5.5.2  安装依赖  279
5.5.3  创建视图  279
5.5.4  添加插件  285
5.5.5  创建评论组件  286
5.5.6  测试  290
5.5.7  关于服务端访问DOM  290
5.6  注册页面  294
5.6.1  注册路由  294
5.6.2  新建signup.vue页面  295
5.6.3  增强错误提示  299
5.7  登录页面  299
5.8  完善详情与评论  310
5.9  个人中心  321
5.10  创建图片  336
5.10.1  创建又拍云存储  336
5.10.2  添加后端API  338
5.10.3  前端界面  340
5.10.4  测试  348
5.11  团队  349
5.11.1  功能是如何工作的  350
5.11.2  数据库  350
5.11.3  后端  356
5.11.4  前端  363
5.11.5  测试  372
第6章  部署与运维  374
6.1  认识Docker  374
6.1.1  解决了什么问题  374
6.1.2  使用Docker的流程  375
6.1.3  安装Docker  378
6.1.4  使用加速器  378
6.1.5  下载一个基础镜像  379
6.1.6  hello world  379
6.2  手动构建镜像  380
6.3  编写Dockerfile文件  384
6.4  Docker Compose  387
6.4.1  安装docker-compose  387
6.4.2  命令行接口  388
6.4.3  Egg.js简单实例  389
6.4.4  增加服务  391
6.5  集群  396
6.5.1  Docker集群  396
6.5.2  集群初始化  396
6.5.3  实例  397
6.6  持续部署  400
6.6.1  部署主机免密码登录  400
6.6.2  客户端钩子  401
6.6.3  使用服务端钩子进行部署  403
6.6.4  使用 shipit  404
6.6.5  使用 Ansible 部署  406
6.7  持续集成  409
6.8  Kubernetes集群  423
6.8.1  简单使用  423
6.8.2  如何创建应用  425
6.8.3  命令行管理  430
6.8.4  通过UI创建应用  433
6.8.5  添加持续集成  439
6.8.6  固定IP地址  441
6.8.7  部署前端  442
第7章  性能分析与优化  448
7.1  服务器性能分析与测试  448
7.2  用户追踪  458
7.2.1  百度分析  458
7.2.2  Google分析  460
7.2.3  其他付费服务  461
7.3  前端性能分析与优化  461
7.3.1  lighthouse  461
7.3.2  sonarwhal  462
7.3.3  图片压缩  464
7.3.4  错误上报  465
7.3.5  接收用户反馈  466
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js实战：使用Egg.js+Vue.js+Docker构建渐进式、可持续集成与交付应用
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js+MongoDB+Angular Web开发
引 言  1
第1 部分 入 门
第1 章 介绍Node.js-to-Angular 套件  9
1.1 了解基本的Web 开发框架  9
1.1.1 用户  10
1.1.2 浏览器  10
1.1.3 Web 服务器  12
1.1.4 后端服务  12
1.2 了解Node.js-to-Angular 套件组件  13
1.2.1 Node.js  13
1.2.2 MongoDB  14
1.2.3 Express  15
1.2.4 Angular  15
1.3 小结  16
1.4 下一章  16
第2 章 JavaScript 基础  17
2.1 定义变量  17
2.2 了解JavaScript 数据类型  18
2.3 使用运算符  19
2.3.1 算术运算符  19
2.3.2 赋值运算符  20
2.3.3 运用比较和条件运算符  20
2.4 实现循环  22
2.4.1 while 循环  23
2.4.2 do/while 循环  23
2.4.3 for 循环  23
2.4.4 for/in 循环  24
2.4.5 中断循环  25
2.5 创建函数  26
2.5.1 定义函数  26
2.5.2 将变量传递给函数  26
2.5.3 从函数返回值  27
2.5.4 使用匿名函数  27
2.6 理解变量作用域  28
2.7 使用JavaScript 对象  28
2.7.1 使用对象语法  29
2.7.2 创建自定义对象  30
2.7.3 使用原型对象模式  30
2.8 处理字符串  31
2.8.1 合并字符串  32
2.8.2 在字符串中搜索子串  33
2.8.3 在一个字符串中替换单词  33
2.8.4 将字符串分割成数组  33
2.9 使用数组  33
2.9.1 合并数组  35
2.9.2 遍历数组  35
2.9.3 将数组转换为字符串  35
2.9.4 检查数组是否包含某个条目  36
2.9.5 在数组中添加条目和删除条目  36
2.10 添加错误处理  36
2.10.1 try/catch 块  37
2.10.2 抛出你自己的错误  37
2.10.3 使用finally  38
2.11 小结  38
2.12 下一章  38
第2 部分 学习Node.js
第3 章 开始使用Node.js  41
3.1 了解Node.js  41
3.1.1 谁在使用Node.js  41
3.1.2 Node.js 的用途  42
3.1.3 Node.js 包含的内容  42
3.2 Node.js 安装  44
3.2.1 纵观Node.js 安装位置  44
3.2.2 验证Node.js 可执行文件  44
3.2.3 选择Node.js IDE  45
3.3 使用Node 包  45
3.3.1 什么是Node 封装模块  45
3.3.2 了解Node 包注册表  46
3.3.3 使用Node 包管理器  46
3.3.4 搜索Node 封装模块  47
3.3.5 安装Node 封装模块  48
3.3.6 使用package.json  49
3.4 创建Node.js 应用程序  50
3.4.1 创建Node.js 模块封装  51
3.4.2 将一个Node.js 封装模块发布到NPM 注册表  52
3.4.3 在Node.js 应用程序中使用Node.js 封装模块  54
3.5 将数据写入控制台  55
3.6 小结  56
3.7 下一章  56
第4 章 在Node.js 中使用事件、监听器、定时器和回调  57
4.1 了解Node.js 事件模型  57
4.1.1 比较事件回调和线程模型  57
4.1.2 在Node.js 中阻塞I/O  58
4.1.3 会话示例  60
4.2 将工作添加到事件队列  60
4.2.1 实现定时器  61
4.2.2 使用nextTick 来调度工作  64
4.2.3 实现事件发射器和监听器  65
4.3 实现回调  68
4.3.1 向回调函数传递额外的参数  69
4.3.2 在回调中实现闭包  70
4.3.3 链式回调  71
4.4 小结  72
4.5 下一章  72
第5 章 在Node.js 中处理数据I/O  73
5.1 处理JSON  73
5.1.1 把JSON 转换成JavaScript 对象  73
5.1.2 把JavaScript 对象转换为JSON  74
5.2 使用Buffer 模块缓冲数据  74
5.2.1 了解缓冲数据  75
5.2.2 创建缓冲区  75
5.2.3 写入缓冲区  76
5.2.4 从缓冲区读取  77
5.2.5 确定缓冲区的长度  78
5.2.6 复制缓冲区  78
5.2.7 对缓冲区切片  80
5.2.8 拼接缓冲区  80
5.3 使用Stream 模块来传送数据  81
5.3.1 Readable 流  82
5.3.2 Writable 流  84
5.3.3 Duplex 流  86
5.3.4 Transform 流  88
5.3.5 把Readable 流用管道输送到Writable 流  89
5.4 用Zlib 压缩与解压缩数据  91
5.4.1 压缩和解压缩缓冲区  91
5.4.2 压缩/解压缩流  93
5.5 小结  93
5.6 下一章  93
第6 章 从Node.js 访问文件系统  95
6.1 同步和异步文件系统调用  95
6.2 打开和关闭文件  96
6.3 写入文件  97
6.3.1 简单文件写入  97
6.3.2 同步文件写入  98
6.3.3 异步写入文件  99
6.3.4 流式文件写入  101
6.4 读取文件  102
6.4.1 简单文件读取  102
6.4.2 同步文件读取  103
6.4.3 异步文件读取  104
6.4.4 流式文件读取  105
6.5 其他文件系统任务  106
6.5.1 验证路径的存在性  106
6.5.2 获取文件信息  107
6.5.3 列出文件  108
6.5.4 删除文件  110
6.5.5 截断文件  110
6.5.6 建立和删除目录  111
6.5.7 重命名文件和目录  112
6.5.8 监视文件更改  112
6.6 小结  113
6.7 下一章  113
第7 章 在Node.js 中实现HTTP 服务  115
7.1 处理URL  115
7.1.1 了解URL 对象  116
7.1.2 解析URL 组件  117
7.2 处理查询字符串和表单参数  117
7.3 了解请求、响应和服务器对象  118
7.3.1 http.ClientRequest 对象  118
7.3.2 http.ServerResponse 对象  121
7.3.3 http.IncomingMessage 对象  122
7.3.4 http.Server 对象  122
7.4 在Node.js 中实现HTTP 客户端和服务器  124
7.4.1 提供静态文件服务  124
7.4.2 实现动态的GET 服务器  126
7.4.3 实现POST 服务器  128
7.4.4 与外部源交互  131
7.5 实现HTTPS 服务器和客户端  133
7.5.1 创建HTTPS 客户端  134
7.5.2 创建HTTPS 服务器  135
7.6 小结  136
7.7 下一章  136
第8 章 在Node.js 中实现套接字服务  137
8.1 了解网络套接字  137
8.2 了解TCP 服务器和Socket 对象  138
8.2.1 net.Socket 对象  138
8.2.2 net.Server 对象  141
8.3 实现TCP 套接字服务器和客户端  144
8.3.1 实现TCP 套接字客户端  144
8.3.2 实现TCP 套接字服务器  146
8.4 实现TLS 服务器和客户端  149
8.4.1 创建TLS 套接字客户端  150
8.4.2 创建TLS 套接字服务器  151
8.5 小结  153
8.6 下一章  153
第9 章 在Node.js 中使用多处理器扩展应用程序  155
9.1 了解process 模块  155
9.1.1 了解进程I/O 管道  155
9.1.2 了解进程的信号  156
9.1.3 使用process 模块控制进程执行  156
9.1.4 从process 模块获取信息  157
9.2 实现子进程  159
9.2.1 了解ChildProcess 对象  159
9.2.2 使用exec()在另一个进程上执行一个系统命令  161
9.2.3 使用execFile()在另一个进程上执行一个可执行文件  162
9.2.4 使用spawn()在另一个Node.js 实例中产生一个进程  163
9.2.5 实现子派生  165
9.3 实现进程集群  167
9.3.1 使用cluster 模块  168
9.3.2 了解Worker 对象  169
9.3.3 实现一个HTTP 集群  170
9.4 小结  172
9.5 下一章  172
第10 章 使用其他Node.js 模块  173
10.1 使用os 模块  173
10.2 使用util 模块  175
10.2.1 格式化字符串  175
10.2.2 检查对象类型  176
10.2.3 将JavaScript 对象转换为字符串  176
10.2.4 从其他对象继承功能  177
10.3 使用dns 模块  178
10.4 使用crypto 模块  180
10.5 其他Node 模块和对象  181
10.6 小结  182
10.7 下一章  182
第3 部分 学习MongoDB
第11 章 了解NoSQL 和MongoDB  185
11.1 为什么要采用NoSQL  185
11.2 了解MongoDB  186
11.2.1 理解集合  186
11.2.2 了解文档  186
11.3 MongoDB 的数据类型  187
11.4 规划你的数据模型  188
11.4.1 使用文档引用来规范化数据  189
11.4.2 使用嵌入式文档反规范化数据  190
11.4.3 使用封顶集合  191
11.4.4 了解原子写操作  192
11.4.5 考虑文件增长  192
11.4.6 识别索引、分片和复制的机会  193
11.4.7 大集合与大量集合的对比  193
11.4.8 决定数据生命周期  193
11.4.9 考虑数据的可用性和性能  194
11.5 小结  194
11.6 下一章  194
第12 章 MongoDB 入门  195
12.1 构建MongoDB 的环境  195
12.1.1 MongoDB 的安装  195
12.1.2 启动MongoDB  196
12.1.3 停止MongoDB  197
12.1.4 从shell 客户端访问MongoDB  197
12.2 管理用户账户  200
12.2.1 列出用户  200
12.2.2 创建用户账户  201
12.2.3 删除用户  202
12.3 配置访问控制  203
12.3.1 创建用户管理员账户  203
12.3.2 打开身份验证  204
12.3.3 创建数据库管理员账户  204
12.4 管理数据库  205
12.4.1 显示数据库清单  205
12.4.2 切换当前数据库  205
12.4.3 创建数据库  206
12.4.4 删除数据库  206
12.4.5 复制数据库  207
12.5 管理集合  207
12.5.1 显示数据库中的集合列表  207
12.5.2 创建集合  208
12.5.3 删除集合  208
12.5.4 在集合中查找文档  209
12.5.5 将文档添加到集合中  210
12.5.6 从集合中删除文档  210
12.5.7 更新集合中的文档  211
12.6 小结  212
12.7 下一章  212
第13 章 MongoDB 和Node.js 入门  213
13.1 把MongoDB 的驱动程序添加到Node.js  213
13.2 从Node.js 连接到MongoDB  213
13.2.1 了解写入关注  214
13.2.2 通过MongoClient 对象从Node.js 连接到MongoDB  214
13.3 了解用在MongoDB Node.js 驱动程序中的对象  218
13.3.1 了解Db 对象  218
13.3.2 了解Admin 对象  220
13.3.3 了解Collection 对象  220
13.3.4 了解Cursor 对象  222
13.4 访问和操作数据库  223
13.4.1 列出数据库  223
13.4.2 创建数据库  223
13.4.3 删除数据库  224
13.4.4 创建、列出和删除数据库实例  224
13.4.5 获取MongoDB 服务器的状态  226
13.5 访问和操作集合  227
13.5.1 列出集合  227
13.5.2 创建集合  227
13.5.3 删除集合  227
13.5.4 创建、列出和删除集合的示例  228
13.5.5 获取集合信息  229
13.6 小结  230
13.7 下一章  230
第14 章 从Node.js 操作MongoDB 文档  231
14.1 了解数据库更改选项  231
14.2 了解数据库更新运算符  232
14.3 将文档添加到集合  233
14.4 从集合获取文档  235
14.5 更新集合中的文档  237
14.6 原子地修改文档的集合  239
14.7 保存集合中的文档  241
14.8 使用upsert 往集合中插入文档  242
14.9 从集合中删除文档  244
14.10 从集合中删除单个文档  246
14.11 小结  248
14.12 下一章  248
第15 章 从Node.js 访问MongoDB  249
15.1 介绍数据集  249
15.2 了解query 对象  250
15.3 了解查询options 对象  251
15.4 查找特定文档集合  252
15.5 清点文档数量  255
15.6 对结果集进行限制  257
15.6.1 按大小限制结果  257
15.6.2 限制对象返回的字段  258
15.6.3 对结果进行分页  260
15.7 对结果集进行排序  262
15.8 查找不同的字段值  263
15.9 对结果进行分组  265
15.10 通过聚合结果来应用MapReduce  269
15.10.1 了解aggregate()方法  269
15.10.2 使用聚合框架运算符  270
15.10.3 实现聚合表达式运算符  272
15.10.4 聚合的例子  273
15.11 小结  274
15.12 下一章  274
第16 章 利用Mongoose 来使用结构化模式与验证  275
16.1 了解Mongoose  275
16.2 利用Mongoose 连接到MongoDB 数据库  276
16.3 定义模式  278
16.3.1 了解路径  278
16.3.2 创建一个模式定义  278
16.3.3 把索引添加到一个模式  279
16.3.4 实现字段的唯一性  280
16.3.5 强制字段的必需性  280
16.3.6 往Schema 模型添加方法  280
16.3.7 在words 数据库上实现模式  281
16.4 编译模型  282
16.5 了解Query 对象  282
16.5.1 设置查询数据库操作  283
16.5.2 设置查询数据库操作选项  284
16.5.3 设置查询运算符  285
16.6 了解Document 对象  287
16.7 利用Mongoose 查找文档  288
16.8 利用Mongoose 添加文档  290
16.9 利用Mongoose 更新文档  292
16.9.1 保存文档更改  292
16.9.2 更新单个文档  293
16.9.3 更新多个文档  295
16.10 利用Mongoose 删除文档  296
16.10.1 删除单个文档  296
16.10.2 删除多个文档  298
16.11 利用Mongoose 聚合文档  299
16.12 使用验证框架  302
16.13 实现中间件函数  304
16.14 小结  306
16.15 下一章  307
第17 章 高级MongoDB 概念  309
17.1 添加索引  309
17.2 使用封顶集合  311
17.3 应用复制  312
17.3.1 复制策略  314
17.3.2 部署一个副本集  314
17.4 实施分片  315
17.4.1 分片服务器类型  316
17.4.2 选择一个分片键  317
17.4.3 选择一种分区方法  318
17.4.4 部署一个分片的MongoDB 集群  319
17.5 修复MongoDB 数据库  322
17.6 备份MongoDB  323
17.7 小结  324
17.8 下一章  324
第4 部分 使用Express 使生活更轻松
第18 章 在Node.js 中实现Express  327
18.1 Express 入门  327
18.1.1 配置Express 设置  327
18.1.2 启动Express 服务器  328
18.2 配置路由  329
18.2.1 实现路由  329
18.2.2 在路由中应用参数  330
18.3 使用Request 对象  334
18.4 使用Response 对象  336
18.4.1 设置标头  336
18.4.2 设置状态  337
18.4.3 发送响应  337
18.4.4 发送JSON 响应  339
18.4.5 发送文件  341
18.4.6 发送下载响应  342
18.4.7 重定向响应  343
18.5 实现一个模板引擎  343
18.5.1 定义引擎  344
18.5.2 加入本地对象  345
18.5.3 创建模板  345
18.5.4 在响应中呈现模板  347
18.6 小结  348
18.7 下一章  348
第19 章 实现Express 中间件  349
19.1 了解中间件  349
19.1.1 在全局范围内把中间件分配给某个路径  350
19.1.2 把中间件分配到单个路由  350
19.1.3 添加多个中间件函数  351
19.2 使用query 中间件  351
19.3 提供静态文件服务  351
19.4 处理POST 正文数据  353
19.5 发送和接收cookie  354
19.6 实现会话  356
19.7 应用基本的HTTP 身份验证  358
19.8 实现会话身份验证  359
19.9 创建自定义中间件  362
19.10 小结  363
19.11 下一章  364
第5 部分 学习Angular
第20 章 TypeScript 入门  367
20.1 学习不同的类型  367
20.2 了解接口  369
20.3 实现类  370
20.4 实现模块  371
20.5 理解函数  372
20.6 小结  373
20.7 下一章  373
第21 章 Angular 入门  375
21.1 为什么选择Angular  375
21.2 了解Angular  375
21.2.1 模块  376
21.2.2 指令  376
21.2.3 数据绑定  376
21.2.4 依赖注入  376
21.2.5 服务  377
21.3 职责分离  377
21.4 为你的环境添加Angular  377
21.5 使用Angular CLI  378
21.6 创建一个基本的Angular 应用程序  379
21.6.1 创建你的第一个Angular 应用程序  380
21.6.2 了解和使用NgModule  381
21.6.3 创建Angular 引导程序  382
21.7 小结  386
21.8 下一章  386
第22 章 Angular 组件  387
22.1 组件配置  387
22.2 建立模板  388
22.3 使用构造函数  391
22.4 使用外部模板  392
22.5 注入指令  394
22.5.1 使用依赖注入构建嵌套组件  395
22.5.2 通过依赖注入传递数据  397
22.5.3 创建使用输入的Angular 应用程序  397
22.6 小结  399
22.7 下一章  399
第23 章 表达式  401
23.1 使用表达式  401
23.1.1 使用基本表达式  402
23.1.2 在表达式中与Component 类交互  404
23.1.3 在Angular 表达式中使用TypeScript  405
23.2 使用管道  408
23.3 建立一个自定义管道  412
23.4 小结  414
23.5 下一章  414
第24 章 数据绑定  415
24.1 了解数据绑定  415
24.1.1 插值  415
24.1.2 性质绑定  417
24.1.3 属性绑定  419
24.1.4 类绑定  419
24.1.5 样式绑定  420
24.1.6 事件绑定  421
24.1.7 双向绑定  424
24.2 小结  426
24.3 下一章  426
第25 章 内置指令  427
25.1 了解指令  427
25.2 使用内置指令  427
25.2.1 组件指令  428
25.2.2 结构指令  428
25.2.3 属性指令  431
25.3 小结  434
25.4 下一章  434
第6 部分 高级Angular
第26 章 自定义指令  437
26.1 创建自定义属性指令  437
26.2 使用组件创建自定义指令  440
26.3 小结  444
26.4 下一章  444
第27 章 事件和变更检测  445
27.1 使用浏览器事件  445
27.2 发出自定义事件  446
27.2.1 将自定义事件发送到父组件层次结构  446
27.2.2 使用监听器处理自定义事件  446
27.2.3 在嵌套组件中实现自定义事件  446
27.2.4 从子组件中删除父组件中的数据  448
27.3 使用可观察物  452
27.3.1 创建一个可观察物对象  452
27.3.2 利用可观察物观察数据变化  453
27.4 小结  455
27.5 下一章  456
第28 章 在Web 应用程序中实现Angular 服务  457
28.1 了解Angular 服务  457
28.2 使用内置的服务  457
28.3 使用http 服务发送HTTP GET 和PUT 请求  458
28.3.1 配置HTTP 请求  459
28.3.2 实现HTTP 响应回调函数  459
28.3.3 实现一个简单的JSON 文件并使用http 服务来访问它  460
28.4 使用http 服务实现一个简单的模拟服务器  463
28.5 使用router 服务更改视图  474
28.5.1 在Angular 中使用routes  475
28.5.2 实现一个简单的路由  476
28.6 用导航栏实现路由  479
28.7 实现带参数的路由  484
28.8 小结  488
28.9 下一章  488
第29 章 创建自己的自定义Angular 服务  489
29.1 将自定义服务集成到Angular 应用程序中  489
29.2 实现一个使用常量数据服务的简单应用程序  490
29.3 实现数据转换服务  492
29.4 实现可变数据服务  496
29.5 实现一个返回promise 的服务  500
29.6 实现共享服务  501
29.7 小结  508
29.8 下一章  508
第30 章 玩转Angular  509
30.1 实现使用动画服务的Angular 应用程序  509
30.2 实现放大图像的Angular 应用程序  514
30.3 实现启用拖放的Angular 应用程序  517
30.4 实现星级评级的Angular 组件  522
30.5 小结  530
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Node.js+MongoDB+Angular Web开发
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>从物联到万联：Node.js与树莓派万维物联网构建实战
第I 部分 物联网与万维物联网基础  1
1 从物联网到万维物联网  3
1.1  定义物联网  4
1.2  进入万维物联网  6
1.2.1  万维物联网场景：连接旅店  6
1.2.2  对比物联网和万维物联网  8
1.2.3  物联网简史  11
1.3  使用案例——为什么连接设备  13
1.3.1  无线传感器网络和分布式传感  13
1.3.2  可穿戴和自我量化  14
1.3.3  智能家居和建筑  16
1.3.4  智能城市和能源网络  16
1.3.5  智能制造与工业4.0  17
1.3.6  智能物流和供应链  18
1.3.7  营销2.0  19
1.4  万维物联网——增强版的物联网  21
1.4.1  更容易编程  22
1.4.2  开放和可扩展标准  22
1.4.3  快速且易于部署、维护与集成  23
1.4.4  元素之间的松耦合  23
1.4.5  广泛使用的安全和隐私机制  24
1.4.6  万维物联网的弊端  25
1.5  总结  26
2 你好，万维物联网  27
2.1  初识万维物联网设备  28
2.1.1  主角登场：树莓派  29
2.2  练习1——在万维物联网上浏览一个设备  30
2.2.1  第1 部分——Web 作为用户界面  30
2.2.2  第2 部分——Web 作为API  34
2.2.3  小结  39
2.3  练习2——从一个WoT 传感器中轮询数据  40
2.3.1  第1 部分——轮询当前传感器读数  40
2.3.2  第2 部分——轮询和绘制传感器读数  41
2.3.3  第3 部分——实时更新数据  42
2.3.4  小结  44
2.4  练习3——作用于现实世界  44
2.4.1  第1 部分——使用一个表单来更新显示的文字  44
2.4.2  第2 部分——创建你自己的表单来控制设备  46
2.4.3  小结  48
2.5  练习4——让别人知道你的设备存在  49
2.5.1  小结  52
2.6  练习5——创建你的第一个物理网聚合应用  53
2.6.1  小结  55
2.7  总结  55
3 Node.js 与万维物联网  .57
3.1  JavaScript 崛起：从客户端到服务端到智能产品  58
3.1.1  在智能产品中引入JavaScript  59
3.2  Node.js 简介  60
3.2.1  在电脑上安装Node.js  61
3.2.2  用Node.js 写一个Web 服务器  61
3.2.3  以JSON 格式返回传感器数据  63
3.3  Node.js 的模块化  64
3.3.1  npm——Node 的包管理器  64
3.3.2  通过package.json 和npm 完全管理依赖  65
3.3.3  你的第一个Node 模块  67
3.4  理解Node.js 事件循环  68
3.4.1  多线程Web 服务器  68
3.4.2  单线程、非阻塞Web 服务器  69
3.5  开始异步编程  71
3.5.1  匿名回调  72
3.5.2  具名回调  75
3.5.3  控制流库  76
3.6  总结和课外阅读  79
4 嵌入式系统入门  81
4.1  进入嵌入式设备的世界  82
4.1.1  业余爱好者的设备与工业级设备  82
4.1.2  实时操作系统与Linux  83
4.1.3  小结及超越树莓派  85
4.2  建立你的第一台WoT 设备——树莓派  86
4.2.1  入手树莓派  86
4.2.2  选择你的树莓派  88
4.2.3  购物清单  88
4.2.4  设置你的树莓派  89
4.2.5  连接你的设备  94
4.3  安装Node.js 到树莓派  95
4.3.1  在树莓派上使用Git 和GitHub  97
4.3.2  小结  97
4.4  连接传感器和执行器到树莓派  98
4.4.1  理解GPIO 端口  98
4.4.2  使用面包板连接电子元件  98
4.4.3  用Node.js 访问GPIO  100
4.4.4  课外阅读  105
4.5  总结  106
5 构建智能产品网络  107
5.1  连接智能产品  109
5.1.1  网络拓扑结构  109
5.1.2  网络分层模型  111
5.2  智能产品的网络层协议  112
5.2.1  从空间的角度考虑  113
5.2.2  网络协议和IoT  113
5.2.3  IoT 个人局域网  118
5.2.4  IoT 广域网  122
5.2.5  网络层协议的选择  124
5.3  智能产品的应用层协议  127
5.3.1  ZigBee 和蓝牙的应用层  128
5.3.2  Apple HomeKit 和Google Weave  129
5.3.3  消息队列遥测传输  130
5.3.4  资源受限的应用协议  133
5.3.5  应用层协议的选择  134
5.4  万维物联网架构  134
5.4.1  第1 层：接入层  135
5.4.2  第2 层：发现层  136
5.4.3  第3 层：共享层  136
5.4.4  第4 层：整合层  136
5.4.5  为什么WoT 是重要的  137
5.4.6  课外阅读  137
5.5  总结  138
第II 部分 构建万维物联网  139
6 接入层：智能产品的API  141
6.1  设备、资源和Web 智能产品  142
6.1.1  表述性状态转移  142
6.1.2  为什么需要一致的接口  144
6.1.3  原则1 ：可访问资源  145
6.1.4  原则2 ：通过表述来操作资源  149
6.1.5  原则3 ：自描述信息  151
6.1.6  原则4 ：超媒体作为应用程序状态引擎  157
6.1.7  小结——Web 智能产品设计过程  160
6.2  超越REST ：实时万维物联网  161
6.2.1  WoT 需要事件  161
6.2.2  发布/ 订阅  162
6.2.3  webhook——HTTP 回调  163
6.2.4  Comet——用hack 的方式让HTTP 支持实时Web  165
6.2.5  WebSocket  166
6.2.6  未来：从HTTP/1.1 到HTTP/2  170
6.3  总结  171
7 实现 Web 智能产品  173
7.1  连接设备到Web  174
7.2  直接集成模式——在设备上实现 REST  175
7.2.1  创建WoT 服务器  175
7.2.2  资源设计  177
7.2.3  表述设计  184
7.2.4  接口设计  187
7.2.5  通过WebSocket 实现pub/sub 接口  189
7.2.6  小结——直接集成模式  192
7.3  网关集成模式——CoAP  193
7.3.1  运行一个CoAP 服务器  194
7.3.2  通过网关代理CoAP  195
7.3.3  小结——网关集成模式  197
7.4  云端集成模式——EVRYTHNG 的MQTT  198
7.4.1  设置EVRYTHNG 账号  200
7.4.2  创建MQTT 客户端应用程序  204
7.4.3  使用action 来控制智能插座  206
7.4.4  创建一个简单的Web 控制应用  208
7.4.5  小结——云端集成模式  211
7.5  总结  212
8 发现层：描述和发现Web 智能产品  213
8.1  可发现性问题  214
8.2  发现智能产品  216
8.2.1  网络发现（Network discovery）  216
8.2.2  Web 上的资源发现  219
8.3  描述Web 智能产品  222
8.3.1  Web 智能产品模型简介  224
8.3.2  元数据  226
8.3.3  属性  226
8.3.4  行为  228
8.3.5  智能产品  230
8.3.6  在树莓派上实现Web 智能产品模型  231
8.3.7  小结——Web 智能产品模型  237
8.4  语义化的Web 智能产品  238
8.4.1  关联数据和RDFa  238
8.4.2  约定的语义：schema.org  242
8.4.3  JSON-LD  243
8.4.4  课外阅读  245
8.5  总结  246
9 共享层：安全地分享Web 智能产品  247
9.1  保障智能产品安全性  248
9.1.1  加密基础  250
9.1.2  Web 安全与TLS ：HTTPS 的S  251
9.1.3  在树莓派中启用TLS 以支持HTTPS 和WSS  253
9.2  授权和访问控制  258
9.2.1  通过 REST 和 API token 进行访问控制  258
9.2.2  OAuth ：一个Web 身份验证框架  261
9.3  社交化万维物联网  264
9.3.1  社交化万维物联网认证代理  264
9.3.2  实现社交化万维物联网认证代理  267
9.4  课外阅读  274
9.5  总结  276
10 整合层：物理网聚合应用  277
10.1  构建一个简单的App——自动生成UI  278
10.1.1  Web 智能产品的通用用户界面  279
10.2  物理网聚合应用  286
10.2.1  使用Node-RED 工具创建物理网聚合应用  287
10.3  使用向导式工具来创建物理网聚合应用：IFTTT  293
10.3.1  将入侵者警报推送到 Google 电子表格上  294
10.3.2  使用自建通道发送请求  296
10.3.3  将入侵警报信息从Twitter 推送到Google 电子表格  297
10.4  课外阅读  299
10.4.1  从简单的聚合应用到大数据聚合应用  299
10.4.2  更好的用户体验  300
10.5  总结  300
附录A Arduino、BeagleBone、Intel Edison 与WoT  301
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>从物联到万联：Node.js与树莓派万维物联网构建实战
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>新时期的Node.js入门
第1章 基础知识
1.1 Node是什么
1.1.1 Node与JavaScript
1.1.2 runtime和VM
1.2 Node的内部机制
1.2.1 何为回调
1.2.2 同步/异步和阻塞/非阻塞
1.2.3 单线程和多线程
1.2.4 并行和并发
1.3 事件循环（Event loop）
1.3.1 事件与循环
1.3.2 Node中的事件循环
1.3.3 process.nextTick
1.4 总结
1.5 参考资源
第2章 常用模块
2.1 Module
2.1.1 JavaScript的模块规范
2.1.2 require及其运行机制
2.1.3 require的隐患
2.1.4 模块化与作用域
2.2 Buffer
2.2.1 Buffer的构建与转换
2.2.2 Buffer的拼接
2.3 File System
2.4 HTTP服务
2.4.1 创建HTTP 服务器
2.4.2 处理HTTP请求
2.4.3 Response对象
2.4.4 上传数据
2.4.5 HTTP客户端服务
2.4.6 创建代理服务器
2.5 TCP服务
2.5.1 TCP和Socket
2.5.2 创建TCP服务器
2.6 更安全的传输方式——SSL
2.6.1 什么是SSL
2.6.2 SSL原理
2.6.3 对称加密与非对称加密
2.6.4 关于CA
2.6.5 创建HTTPS服务
2.7 WebSocket
2.7.1 保持通话
2.7.2 为什么要有WebSocket
2.7.3 WebSocket与Node
2.8 Stream
2.8.1 Stream 的种类
2.8.2 ReadLine
2.8.3 自定义Stream
2.9 Events
2.9.1 事件和监听器
2.9.2 处理error事件
2.9.3 继承Events模块
2.10 多进程服务
2.10.1 child_process模块
2.10.2 spawn
2.10.3 fork
2.10.4 exec和execFile
2.10.5 各方法之间的比较
……
第3章 用ES6来书写Node
第4章 书写异步代码
第5章 使用Koa2构建Web站点
第6章 爬虫系统的开发
第7章 测试与调试
第8章 Node中的错误处理
附录A 进程、线程、协程
附录B Lua语言简介
附录C 从零开发一个Node Web框架
附录D MongoDB和Redis简介
附录E 使用Docker来实现虚拟化
附录F npm与包管理
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>新时期的Node.js入门
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>你不能錯過的 Node.js 指南
第1章 Node.js控制台模組應用
介紹Node.js框架的控制台模組，透過該模組的方法可以向作業系統控制台實作各種格式化輸入和輸出等操作。
第2章 Node.js模組與套件管理
介紹Node.js框架自有的一套模組載入系統，透過該模組可以把各個功能拆分、封裝到不同的模組之中，在需要的時候使用該模組。
第3章 Node.js非同步I/O與Async流程控制庫
介紹Node.js非同步I/O程式設計，透過本章的介紹，讀者可以學到非同步I/O機制、非同步I/O應用和Async流程控制庫應用。
第4章 Buffer模組處理
介紹Node.js框架中Buffer的概念，它可以理解為是緩衝區或臨時儲存區，是暫時存放輸入、輸出資料的一小塊記憶體。
第5章 Node.js處理程序管理
介紹使用Node.js框架中功能強大的處理程序管理模組（Process）的方法。
第6章 使用jQuery實作滑鼠拖曳功能
介紹使用Node.js框架的child_process模組建立子處理程序的四個方法，分別是spawn()、exec()、execFile()和fork()。
第7章 OS模組應用
介紹Node.js框架中的作業系統（OS）模組，該模組提供了一系列與作業系統相關的函數方法。
第8章 檔案系統模組應用
介紹Node.js框架中的檔案系統（File System）模組如何來支援I/O操作的方法，這些操作方法是對標準POSIX函數的簡單封裝，它提供了檔案的讀取、寫入、更名、刪除、瀏覽目錄、連結等POSIX檔案系統操作。
第9章 路徑處理應用
介紹Node.js框架中的路徑處理（Path）模組、url路徑處理（url）模組以及字串解析（Query String）模組，這些模組提供了一系列與路徑解析處理相關的函數方法，這些方法對於處理常規的需求是足夠的。
第10章 TCP/UDP網路應用
Node.js框架為設計人員提供了網路（Net）模組來支援TCP協定應用，資料通訊端（UDP）模組來支援UDP協定應用，這兩個模組提供了一系列與網路相關的函數方法，透過這些方法可以建構基本的網路應用。
第11章 Node.js串流（Stream）應用
介紹Node.js框架中的抽象介面串流（Stream）模組，串流（Stream）模組操作最主要的是.pipe()方法，它可以為開發者提供可以重複使用的統一的介面，透過抽象的串流（Stream）介面來控制串流（Stream）之間的讀寫平衡。
第12章 Node.js Web開發
介紹應用Node.js框架中的HTTP模組與HTTPS模組開發Web應用的方法，這兩個模組基於HTTP協定與HTTPS協定開發，提供了一系列與Web應用開發相關的函數方法，透過這些方法可以建構各種功能複雜且強大的Web 應用。
第13章 Node.js Util常用工具
介紹Node.js框架中的常用工具（Util）模組，該模組是為了解決核心JavaScript的功能過於精簡而設計的。
第14章 Node.js與MySQL互動
介紹Node.js框架與MySQL資料庫互動的方法。
第15章 Node.js與MongoDB互動
介紹Node.js框架與MongoDB資料庫互動的方法。
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>你不能錯過的 Node.js 指南
